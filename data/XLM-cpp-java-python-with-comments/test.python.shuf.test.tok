MAXIMUM_@@ NUMBER_@@ CHARAC@@ TER@@ S_@@ TWO_@@ CHARACTER_@@ STRING | def maximum@@ Chars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res = max ( res , abs ( j - i - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
FIND_@@ MIRR@@ OR_@@ IMAGE_@@ POINT_@@ 2_@@ D_@@ PLAN@@ E | def mirror@@ Image ( a , b , c , x1 , y1 ) : NEW_LINE INDENT temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) NEW_LINE x = temp * a + x1 NEW_LINE y = temp * b + y1 NEW_LINE return ( x , y ) NEW_LINE DEDENT
EF@@ FI@@ CI@@ EN@@ TL@@ Y_@@ COMP@@ UTE_@@ SUM@@ S_@@ OF_@@ DIAG@@ ON@@ AL@@ S_@@ OF_@@ A_@@ MATRIX | def print@@ Diag@@ onal@@ Sum@@ s ( mat , n ) : NEW_LINE INDENT principal = 0 NEW_LINE secondary = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT principal += mat [ i ] [ j ] NEW_LINE DEDENT if ( ( i + j ) == ( n - 1 ) ) : NEW_LINE INDENT secondary += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( " Principal ▁ Diagonal : " , principal ) NEW_LINE print ( " Secondary ▁ Diagonal : " , secondary ) NEW_LINE DEDENT
COUN@@ TS_@@ PATH@@ S_@@ POINT_@@ REACH_@@ ORIGIN | def count@@ Paths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( count@@ Paths ( n - 1 , m ) + count@@ Paths ( n , m - 1 ) ) NEW_LINE DEDENT
FIND_@@ A_@@ TR@@ IP@@ LET_@@ TH@@ AT_@@ S@@ UM_@@ TO_@@ A_@@ GI@@ V@@ EN_@@ VALUE_@@ 1 | def find@@ 3@@ Numbers ( A , arr_@@ size , sum ) : NEW_LINE INDENT A . sort ( ) NEW_LINE for i in range ( 0 , arr_@@ size - 2 ) : NEW_LINE INDENT l = i + 1 NEW_LINE r = arr_@@ size - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( A [ i ] + A [ l ] + A [ r ] == sum ) : NEW_LINE INDENT print ( " Trip@@ let ▁ is " , A [ i ] , ' , ▁ ' , A [ l ] , ' , ▁ ' , A [ r ] ) ; NEW_LINE return True NEW_LINE DEDENT elif ( A [ i ] + A [ l ] + A [ r ] < sum ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
CHECK_@@ GI@@ V@@ EN_@@ MATRIX_@@ IS_@@ MAG@@ IC@@ _S@@ QU@@ ARE_@@ OR_@@ NOT | def is@@ Magic@@ Square ( mat ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT s = s + mat [ i ] [ i ] NEW_LINE DEDENT s2 = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT s2 = s2 + mat [ i ] [ N - i - 1 ] NEW_LINE DEDENT if ( s != s2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT row@@ Sum = 0 ; NEW_LINE for j in range ( 0 , N ) : NEW_LINE INDENT row@@ Sum += mat [ i ] [ j ] NEW_LINE DEDENT if ( row@@ Sum != s ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT col@@ Sum = 0 NEW_LINE for j in range ( 0 , N ) : NEW_LINE INDENT col@@ Sum += mat [ j ] [ i ] NEW_LINE DEDENT if ( s != col@@ Sum ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
SEQU@@ EN@@ CES_@@ GI@@ V@@ EN_@@ LENGTH_@@ EVER@@ Y_@@ ELEMENT_@@ EQUAL_@@ TWI@@ CE_@@ PREVI@@ OUS_@@ 1 | def getTotal@@ NumberOf@@ Sequences ( m , n ) : NEW_LINE INDENT T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif i < j : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif j == 1 : NEW_LINE INDENT T [ i ] [ j ] = i NEW_LINE DEDENT else : NEW_LINE INDENT T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i // 2 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return T [ m ] [ n ] NEW_LINE DEDENT
FIND_@@ DIFF@@ ER@@ ENCE_@@ BETWE@@ EN@@ _S@@ UM@@ S_@@ OF_@@ TWO_@@ DIAG@@ ON@@ AL@@ S_@@ 1 | def difference ( arr , n ) : NEW_LINE INDENT d1 = 0 NEW_LINE d2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT d1 = d1 + arr [ i ] [ i ] NEW_LINE d2 = d2 + arr [ i ] [ n - i - 1 ] NEW_LINE DEDENT return abs ( d1 - d2 ) NEW_LINE DEDENT
MINIMUM_@@ NUMBER@@ _SUB@@ SE@@ TS_@@ DISTIN@@ CT_@@ ELEMENTS | def subset ( ar , n ) : NEW_LINE INDENT res = 0 NEW_LINE ar . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ar [ i ] == ar [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT res = max ( res , count ) NEW_LINE DEDENT return res NEW_LINE DEDENT
DECIMAL_@@ BINARY_@@ CON@@ VERSION_@@ WITH@@ OUT_@@ USING_@@ ARI@@ TH@@ ME@@ TIC_@@ OPER@@ ATORS | def dec@@ To@@ Bin ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return "0" ; NEW_LINE DEDENT bin = " " ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n & 1 == 0 ) : NEW_LINE INDENT bin = '0' + bin ; NEW_LINE DEDENT else : NEW_LINE INDENT bin = '1' + bin ; NEW_LINE DEDENT n = n >> 1 ; NEW_LINE DEDENT return bin ; NEW_LINE DEDENT
FIND_@@ N@@ TH_@@ TER@@ M_@@ DRAG@@ ON_@@ CUR@@ VE_@@ SEQUENCE | def Drag@@ on_@@ Cur@@ ve_@@ Sequence ( n ) : NEW_LINE INDENT s = "1" NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT temp = "1" NEW_LINE prev = '1' NEW_LINE zero = '0' NEW_LINE one = '1' NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE if ( prev == '0' ) : NEW_LINE INDENT temp += one NEW_LINE prev = one NEW_LINE DEDENT else : NEW_LINE INDENT temp += zero NEW_LINE prev = zero NEW_LINE DEDENT DEDENT s = temp NEW_LINE DEDENT return s NEW_LINE DEDENT
STACK@@ _SET_@@ 3_@@ REVERSE_@@ STRING_@@ USING_@@ STACK | def reverse ( string ) : NEW_LINE INDENT string = string [ : : - 1 ] NEW_LINE return string NEW_LINE DEDENT
SORT_@@ EV@@ EN_@@ PL@@ AC@@ ED_@@ ELEMEN@@ TS_@@ INCRE@@ AS@@ ING_@@ OD@@ D_@@ PL@@ AC@@ ED_@@ DECRE@@ AS@@ ING_@@ ORDER_@@ 1 | def bit@@ on@@ ic@@ Generator ( arr , n ) : NEW_LINE INDENT i = 1 NEW_LINE j = n - 1 NEW_LINE if ( j % 2 != 0 ) : NEW_LINE INDENT j = j - 1 NEW_LINE DEDENT while ( i < j ) : NEW_LINE INDENT arr [ j ] , arr [ i ] = arr [ i ] , arr [ j ] NEW_LINE i = i + 2 NEW_LINE j = j - 2 NEW_LINE DEDENT arr_@@ f = [ ] NEW_LINE arr_@@ s = [ ] NEW_LINE for i in range ( int ( ( n + 1 ) / 2 ) ) : NEW_LINE INDENT arr_@@ f . append ( arr [ i ] ) NEW_LINE DEDENT i = int ( ( n + 1 ) / 2 ) NEW_LINE while ( i < n ) : NEW_LINE INDENT arr_@@ s . append ( arr [ i ] ) NEW_LINE i = i + 1 NEW_LINE DEDENT arr_@@ f . sort ( ) NEW_LINE arr_@@ s . sort ( reverse = True ) NEW_LINE for i in arr_@@ s : NEW_LINE INDENT arr_@@ f . append ( i ) NEW_LINE DEDENT return arr_@@ f NEW_LINE DEDENT
GI@@ V@@ EN_@@ TWO_@@ NUMB@@ ERS_@@ B_@@ FIND_@@ X_@@ X_@@ B | def mod@@ ular@@ Equation ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT print ( " No ▁ solution ▁ possible ▁ " ) NEW_LINE return NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT print ( " In@@ finite ▁ Solution ▁ possible ▁ " ) NEW_LINE return NEW_LINE DEDENT count = 0 NEW_LINE n = a - b NEW_LINE y = ( int ) ( math . sqrt ( a - b ) ) NEW_LINE for i in range ( 1 , y + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i > b ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( i > b ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT if ( y * y == n and y > b ) : NEW_LINE INDENT count = count - 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
CHECK_@@ CHARAC@@ TER@@ S_@@ GI@@ V@@ EN_@@ STRING_@@ CAN_@@ RE@@ AR@@ RANGE@@ D_@@ FORM_@@ PA@@ LIN@@ DRO@@ ME | def can@@ Form@@ Pal@@ ind@@ ro@@ me ( st ) : NEW_LINE INDENT count = [ 0 ] * ( NO_@@ OF_@@ CHARS ) NEW_LINE for i in range ( 0 , len ( st ) ) : NEW_LINE INDENT count [ ord ( st [ i ] ) ] = count [ ord ( st [ i ] ) ] + 1 NEW_LINE DEDENT odd = 0 NEW_LINE for i in range ( 0 , NO_@@ OF_@@ CHARS ) : NEW_LINE INDENT if ( count [ i ] & 1 ) : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT if ( odd > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
MAXIMUM_@@ TR@@ IP@@ LET_@@ S@@ UM_@@ ARRAY_@@ 1 | def max@@ Trip@@ let@@ Sum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ) NEW_LINE DEDENT
FIND_@@ MEDI@@ AN_@@ ROW_@@ WI@@ SE_@@ SOR@@ TED_@@ MATRIX | def binary@@ Medi@@ an ( m , r , d ) : NEW_LINE INDENT mi = m [ 0 ] [ 0 ] NEW_LINE mx = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT if m [ i ] [ 0 ] < mi : NEW_LINE INDENT mi = m [ i ] [ 0 ] NEW_LINE DEDENT if m [ i ] [ d - 1 ] > mx : NEW_LINE INDENT mx = m [ i ] [ d - 1 ] NEW_LINE DEDENT DEDENT desired = ( r * d + 1 ) // 2 NEW_LINE while ( mi < mx ) : NEW_LINE INDENT mid = mi + ( mx - mi ) // 2 NEW_LINE place = [ 0 ] ; NEW_LINE for i in range ( r ) : NEW_LINE INDENT j = upper_bound ( m [ i ] , mid ) NEW_LINE place [ 0 ] = place [ 0 ] + j NEW_LINE DEDENT if place [ 0 ] < desired : NEW_LINE INDENT mi = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mx = mid NEW_LINE DEDENT DEDENT print ( " Medi@@ an ▁ is " , mi ) NEW_LINE return NEW_LINE DEDENT
HEIGHT_@@ N_@@ ARY_@@ TREE_@@ PARENT_@@ ARRAY_@@ GI@@ VEN | def find@@ Height ( parent , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT p = i NEW_LINE current = 1 NEW_LINE while ( parent [ p ] != - 1 ) : NEW_LINE INDENT current += 1 NEW_LINE p = parent [ p ] NEW_LINE DEDENT res = max ( res , current ) NEW_LINE DEDENT return res NEW_LINE DEDENT
CHECK_@@ LARGE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 20 | def di@@ visible@@ By@@ 20 ( num ) : NEW_LINE INDENT last@@ Two@@ Digits = int ( num [ - 2 : ] ) NEW_LINE return ( ( last@@ Two@@ Digits % 5 == 0 and last@@ Two@@ Digits % 4 == 0 ) ) NEW_LINE DEDENT
MAXIMUM_@@ VALUE_@@ CHO@@ ICE_@@ EI@@ THER_@@ DIV@@ ID@@ ING_@@ CON@@ SI@@ DER@@ ING | def max@@ DP ( n ) : NEW_LINE INDENT res = list ( ) NEW_LINE res . append ( 0 ) NEW_LINE res . append ( 1 ) NEW_LINE i = 2 NEW_LINE while i < n + 1 : NEW_LINE INDENT res . append ( max ( i , ( res [ int ( i / 2 ) ] + res [ int ( i / 3 ) ] + res [ int ( i / 4 ) ] + res [ int ( i / 5 ) ] ) ) ) NEW_LINE i = i + 1 NEW_LINE DEDENT return res [ n ] NEW_LINE DEDENT
QUER@@ I@@ ES_@@ ON_@@ ARRAY_@@ WITH_@@ DIS@@ AP@@ PE@@ AR@@ ING_@@ AND_@@ RE@@ AP@@ PE@@ AR@@ ING_@@ ELEMENTS | def Perform@@ Queries ( a , vec ) : NEW_LINE INDENT ans = [ ] ; NEW_LINE n = len ( a ) - 1 ; NEW_LINE q = len ( vec ) ; NEW_LINE for i in range ( q ) : NEW_LINE INDENT t = vec [ i ] [ 0 ] ; NEW_LINE m = vec [ i ] [ 1 ] ; NEW_LINE if ( m > n ) : NEW_LINE INDENT ans . append ( - 1 ) ; NEW_LINE continue ; NEW_LINE DEDENT turn = t // n ; NEW_LINE rem = t % n ; NEW_LINE if ( rem == 0 and turn % 2 == 1 ) : NEW_LINE INDENT ans . append ( - 1 ) ; NEW_LINE continue ; NEW_LINE DEDENT if ( rem == 0 and turn % 2 == 0 ) : NEW_LINE INDENT ans . append ( a [ m ] ) ; NEW_LINE continue ; NEW_LINE DEDENT if ( turn % 2 == 0 ) : NEW_LINE INDENT cur@@ size = n - rem ; NEW_LINE if ( cur@@ size < m ) : NEW_LINE INDENT ans . append ( - 1 ) ; NEW_LINE continue ; NEW_LINE DEDENT ans . append ( a [ m + rem ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT cur@@ size = rem ; NEW_LINE if ( cur@@ size < m ) : NEW_LINE INDENT ans . append ( - 1 ) ; NEW_LINE continue ; NEW_LINE DEDENT ans . append ( a [ m ] ) ; NEW_LINE DEDENT DEDENT for i in ans : NEW_LINE INDENT print ( i ) ; NEW_LINE DEDENT DEDENT
FIND_@@ THE_@@ MINIMUM_@@ DISTAN@@ CE_@@ BETWE@@ EN_@@ TWO_@@ NUMB@@ ERS_@@ 1 | def min@@ Dist ( arr , n , x , y ) : NEW_LINE INDENT min_@@ dist = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == x or arr [ i ] == y : NEW_LINE INDENT prev = i NEW_LINE break NEW_LINE DEDENT DEDENT while i < n : NEW_LINE INDENT if arr [ i ] == x or arr [ i ] == y : NEW_LINE INDENT if arr [ prev ] != arr [ i ] and ( i - prev ) < min_@@ dist : NEW_LINE INDENT min_@@ dist = i - prev NEW_LINE prev = i NEW_LINE DEDENT else : NEW_LINE INDENT prev = i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return min_@@ dist NEW_LINE DEDENT
UNI@@ ON_@@ AND_@@ INTER@@ SECTION_@@ OF_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S_@@ 2 | def print@@ Union ( ar@@ r1 , ar@@ r2 , m , n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if ar@@ r1 [ i ] < ar@@ r2 [ j ] : NEW_LINE INDENT print ( ar@@ r1 [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT elif ar@@ r2 [ j ] < ar@@ r1 [ i ] : NEW_LINE INDENT print ( ar@@ r2 [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( ar@@ r2 [ j ] ) NEW_LINE j += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT while i < m : NEW_LINE INDENT print ( ar@@ r1 [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT while j < n : NEW_LINE INDENT print ( ar@@ r2 [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT
WORD_@@ WRAP_@@ PRO@@ BLE@@ M@@ _SPACE_@@ OPTIMIZ@@ ED@@ _S@@ OL@@ U@@ TION | def solve@@ Word@@ Wrap ( arr , n , k ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE ans = [ 0 ] * n NEW_LINE dp [ n - 1 ] = 0 NEW_LINE ans [ n - 1 ] = n - 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT curr@@ len = - 1 NEW_LINE dp [ i ] = sys . maxsize NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr@@ len += ( arr [ j ] + 1 ) NEW_LINE if ( curr@@ len > k ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( j == n - 1 ) : NEW_LINE INDENT cost = 0 NEW_LINE DEDENT else : NEW_LINE INDENT cost = ( ( k - curr@@ len ) * ( k - curr@@ len ) + dp [ j + 1 ] ) NEW_LINE DEDENT if ( cost < dp [ i ] ) : NEW_LINE INDENT dp [ i ] = cost NEW_LINE ans [ i ] = j NEW_LINE DEDENT DEDENT DEDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT print ( i + 1 , ans [ i ] + 1 , end = " ▁ " ) NEW_LINE i = ans [ i ] + 1 NEW_LINE DEDENT DEDENT
COUNT_@@ DISTIN@@ CT_@@ SUB@@ SEQU@@ EN@@ CES | def count@@ Sub ( ss ) : NEW_LINE INDENT last = [ - 1 for i in range ( MAX_@@ CHAR + 1 ) ] NEW_LINE n = len ( ss ) NEW_LINE dp = [ - 2 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] = 2 * dp [ i - 1 ] NEW_LINE if last [ ord ( ss [ i - 1 ] ) ] != - 1 : NEW_LINE INDENT dp [ i ] = dp [ i ] - dp [ last [ ord ( ss [ i - 1 ] ) ] ] NEW_LINE DEDENT last [ ord ( ss [ i - 1 ] ) ] = i - 1 NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
LON@@ GE@@ ST_@@ EV@@ EN_@@ LENGTH@@ _SUB@@ STRING@@ _S@@ UM_@@ FIR@@ ST@@ _SECON@@ D_@@ HALF_@@ 3 | def find@@ Length ( st , n ) : NEW_LINE INDENT total = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT total [ i ] = ( total [ i - 1 ] + int ( st [ i - 1 ] ) - int ( '0' ) ) NEW_LINE DEDENT ans = 0 NEW_LINE l = 2 NEW_LINE while ( l <= n ) : NEW_LINE INDENT for i in range ( n - l + 1 ) : NEW_LINE INDENT j = i + l - 1 NEW_LINE if ( total [ i + int ( l / 2 ) ] - total [ i ] == total [ i + l ] - total [ i + int ( l / 2 ) ] ) : NEW_LINE INDENT ans = max ( ans , l ) NEW_LINE DEDENT DEDENT l = l + 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
MAXIMUM_@@ PATH@@ _S@@ UM_@@ MATRIX | def find@@ Max@@ Path ( mat ) : NEW_LINE INDENT res = - 1 NEW_LINE for i in range ( M ) : NEW_LINE INDENT res = max ( res , mat [ 0 ] [ i ] ) NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT res = - 1 NEW_LINE for j in range ( M ) : NEW_LINE INDENT if ( j > 0 and j < M - 1 ) : NEW_LINE INDENT mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) NEW_LINE DEDENT elif ( j > 0 ) : NEW_LINE INDENT mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT elif ( j < M - 1 ) : NEW_LINE INDENT mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) NEW_LINE DEDENT res = max ( mat [ i ] [ j ] , res ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
MAXIMUM_@@ CON@@ SEC@@ UTI@@ VE_@@ REPE@@ ATING_@@ CHARACTER_@@ STRING | def max@@ Repe@@ ating ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE count = 0 NEW_LINE res = str [ 0 ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT cur_@@ count = 1 NEW_LINE for j in range ( i + 1 , l ) : NEW_LINE INDENT if ( str [ i ] != str [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT cur_@@ count += 1 NEW_LINE DEDENT if cur_@@ count > count : NEW_LINE INDENT count = cur_@@ count NEW_LINE res = str [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
MAXIMUM_@@ LENGTH@@ _SUB@@ SEQU@@ ENCE_@@ DIFF@@ ER@@ ENCE_@@ AD@@ J@@ AC@@ ENT_@@ ELEMEN@@ TS_@@ EI@@ THER_@@ 0_@@ 1 | def max@@ Len@@ Sub ( arr , n ) : NEW_LINE INDENT m@@ ls = [ ] NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m@@ ls . append ( 1 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and m@@ ls [ i ] < m@@ ls [ j ] + 1 ) : NEW_LINE INDENT m@@ ls [ i ] = m@@ ls [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < m@@ ls [ i ] ) : NEW_LINE INDENT max = m@@ ls [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
BREA@@ KING_@@ NUMBER_@@ FIRST_@@ PART_@@ INTEGR@@ AL_@@ DI@@ VISI@@ ON@@ _SECON@@ D_@@ POWER_@@ 10 | def calculate ( N ) : NEW_LINE INDENT length = len ( N ) NEW_LINE l = int ( ( length ) / 2 ) NEW_LINE count = 0 NEW_LINE for i in range ( l + 1 ) : NEW_LINE INDENT s = N [ 0 : 0 + i ] NEW_LINE l1 = len ( s ) NEW_LINE t = N [ i : l1 + i ] NEW_LINE try : NEW_LINE INDENT if s [ 0 ] == '0' or t [ 0 ] == '0' : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT continue NEW_LINE DEDENT if s == t : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
PROGRAM_@@ BINARY_@@ DECIMAL_@@ CONVERSION | def binary@@ To@@ Decimal ( n ) : NEW_LINE INDENT num = n ; NEW_LINE dec_@@ value = 0 ; NEW_LINE base = 1 ; NEW_LINE temp = num ; NEW_LINE while ( temp ) : NEW_LINE INDENT last_@@ digit = temp % 10 ; NEW_LINE temp = int ( temp / 10 ) ; NEW_LINE dec_@@ value += last_@@ digit * base ; NEW_LINE base = base * 2 ; NEW_LINE DEDENT return dec_@@ value ; NEW_LINE DEDENT
HO@@ W_@@ CAN_@@ W@@ E_@@ S@@ UM_@@ THE_@@ DIG@@ IT@@ S_@@ OF_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ IN@@ _SIN@@ GLE_@@ STATEMENT | def getS@@ um ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum = sum + int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
FIND_@@ N_@@ TH_@@ ELEMENT_@@ FROM_@@ STER@@ NS_@@ DI@@ ATOMI@@ C@@ _SERI@@ ES | def find@@ SD@@ S@@ Func ( n ) : NEW_LINE INDENT DP = [ 0 ] * ( n + 1 ) NEW_LINE DP [ 0 ] = 0 NEW_LINE DP [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( int ( i % 2 ) == 0 ) : NEW_LINE INDENT DP [ i ] = DP [ int ( i / 2 ) ] NEW_LINE DEDENT else : NEW_LINE INDENT DP [ i ] = ( DP [ int ( ( i - 1 ) / 2 ) ] + DP [ int ( ( i + 1 ) / 2 ) ] ) NEW_LINE DEDENT DEDENT return DP [ n ] NEW_LINE DEDENT
NUMBER@@ _SIN@@ K_@@ NODE@@ S_@@ GRAP@@ H | def count@@ Sink ( n , m , edge@@ From , edge@@ To ) : NEW_LINE INDENT mark = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT mark [ edge@@ From [ i ] ] = 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( not mark [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
BREAK_@@ NUMBER_@@ THRE@@ E_@@ PAR@@ TS | def count_@@ of_@@ ways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , n + 1 ) : NEW_LINE INDENT for k in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( i + j + k == n ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
PRINT_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ GI@@ V@@ EN_@@ INTEGER_@@ ARRAY | def print@@ Distin@@ ct ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT d = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT d = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( d == 0 ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT
MAXIMUM_@@ NUMBER@@ _SEG@@ MEN@@ TS_@@ LENGTH@@ S_@@ B_@@ C | def maximum@@ Segments ( n , a , b , c ) : NEW_LINE INDENT dp = [ - 1 ] * ( n + 10 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( dp [ i ] != - 1 ) : NEW_LINE INDENT if ( i + a <= n ) : NEW_LINE INDENT dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) NEW_LINE DEDENT if ( i + b <= n ) : NEW_LINE INDENT dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) NEW_LINE DEDENT if ( i + c <= n ) : NEW_LINE INDENT dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
CHECK_@@ VALI@@ D@@ _SEQU@@ ENCE_@@ DI@@ VISI@@ BLE_@@ M | def is@@ Possible ( n , index , Sum , M , arr , dp ) : NEW_LINE INDENT global MAX NEW_LINE if index == n : NEW_LINE INDENT if ( Sum % M ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if dp [ index ] [ Sum ] != - 1 : NEW_LINE INDENT return dp [ index ] [ Sum ] NEW_LINE DEDENT place@@ Add = is@@ Possible ( n , index + 1 , Sum + arr [ index ] , M , arr , dp ) NEW_LINE place@@ Minus = is@@ Possible ( n , index + 1 , Sum - arr [ index ] , M , arr , dp ) NEW_LINE res = place@@ Add or place@@ Minus NEW_LINE dp [ index ] [ Sum ] = res NEW_LINE return res NEW_LINE DEDENT
FIND_@@ PA@@ IR_@@ WITH_@@ GREA@@ TEST_@@ PRODUCT_@@ IN_@@ ARRAY | def find@@ Gre@@ atest ( arr , n ) : NEW_LINE INDENT result = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] * arr [ k ] == arr [ i ] ) : NEW_LINE INDENT result = max ( result , arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
MAX@@ IM@@ UM@@ _SUB@@ ARRA@@ Y_S@@ UM_@@ ARRAY_@@ CRE@@ ATED_@@ REPE@@ ATED_@@ CON@@ CAT@@ EN@@ ATION | def max@@ Sub@@ Array@@ Sum@@ Repe@@ ated ( a , n , k ) : NEW_LINE INDENT max_@@ so@@ _f@@ ar = - 214748364@@ 8 NEW_LINE max_@@ ending_@@ here = 0 NEW_LINE for i in range ( n * k ) : NEW_LINE INDENT max_@@ ending_@@ here = max_@@ ending_@@ here + a [ i % n ] NEW_LINE if ( max_@@ so@@ _f@@ ar < max_@@ ending_@@ here ) : NEW_LINE INDENT max_@@ so@@ _f@@ ar = max_@@ ending_@@ here NEW_LINE DEDENT if ( max_@@ ending_@@ here < 0 ) : NEW_LINE INDENT max_@@ ending_@@ here = 0 NEW_LINE DEDENT DEDENT return max_@@ so@@ _f@@ ar NEW_LINE DEDENT
LE@@ ON@@ AR@@ DO_@@ NUMBER_@@ 1 | def le@@ on@@ ar@@ do ( n ) : NEW_LINE INDENT dp = [ ] ; NEW_LINE dp . append ( 1 ) ; NEW_LINE dp . append ( 1 ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp . append ( dp [ i - 1 ] + dp [ i - 2 ] + 1 ) ; NEW_LINE DEDENT return dp [ n ] ; NEW_LINE DEDENT
S@@ UM_@@ OF_@@ ALL@@ _SUB@@ STRING@@ S_@@ OF_@@ A_@@ STRING_@@ RE@@ PRESEN@@ TING_@@ A_@@ NUMBER | def sum@@ Of@@ Sub@@ strings ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE su@@ mo@@ f@@ digit = [ ] NEW_LINE su@@ mo@@ f@@ digit . append ( int ( num [ 0 ] ) ) NEW_LINE res = su@@ mo@@ f@@ digit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT num@@ i = int ( num [ i ] ) NEW_LINE su@@ mo@@ f@@ digit . append ( ( i + 1 ) * num@@ i + 10 * su@@ mo@@ f@@ digit [ i - 1 ] ) NEW_LINE res += su@@ mo@@ f@@ digit [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
PR@@ U@@ F@@ ER_@@ CODE_@@ TREE_@@ CRE@@ ATION | def print@@ Tree@@ Edges ( pr@@ u@@ fer , m ) : NEW_LINE INDENT vertices = m + 2 NEW_LINE vertex@@ _set = [ 0 ] * vertices NEW_LINE for i in range ( vertices - 2 ) : NEW_LINE INDENT vertex@@ _set [ pr@@ u@@ fer [ i ] - 1 ] += 1 NEW_LINE DEDENT print ( " The ▁ edge ▁ set ▁ E ( G ) ▁ is ▁ : " ) NEW_LINE j = 0 NEW_LINE for i in range ( vertices - 2 ) : NEW_LINE INDENT for j in range ( vertices ) : NEW_LINE INDENT if ( vertex@@ _set [ j ] == 0 ) : NEW_LINE INDENT vertex@@ _set [ j ] = - 1 NEW_LINE print ( " ( " , ( j + 1 ) , " , ▁ " , pr@@ u@@ fer [ i ] , " ) ▁ " , sep = " " , end = " " ) NEW_LINE vertex@@ _set [ pr@@ u@@ fer [ i ] - 1 ] -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT j = 0 NEW_LINE for i in range ( vertices ) : NEW_LINE INDENT if ( vertex@@ _set [ i ] == 0 and j == 0 ) : NEW_LINE INDENT print ( " ( " , ( i + 1 ) , " , ▁ " , sep = " " , end = " " ) NEW_LINE j += 1 NEW_LINE DEDENT elif ( vertex@@ _set [ i ] == 0 and j == 1 ) : NEW_LINE INDENT print ( ( i + 1 ) , " ) " ) NEW_LINE DEDENT DEDENT DEDENT
PROGRAM_@@ FIN@@ D_S@@ MAL@@ LE@@ ST_@@ DIFF@@ ER@@ ENCE_@@ ANG@@ LES_@@ TWO_@@ PAR@@ TS_@@ GI@@ V@@ EN_@@ CIRC@@ LE | def find@@ Minimum@@ Angle ( arr , n ) : NEW_LINE INDENT l = 0 NEW_LINE _@@ sum = 0 NEW_LINE ans = 360 NEW_LINE for i in range ( n ) : NEW_LINE INDENT _@@ sum += arr [ i ] NEW_LINE while _@@ sum >= 180 : NEW_LINE INDENT ans = min ( ans , 2 * abs ( 180 - _@@ sum ) ) NEW_LINE _@@ sum -= arr [ l ] NEW_LINE l += 1 NEW_LINE DEDENT ans = min ( ans , 2 * abs ( 180 - _@@ sum ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
FIND_@@ MAXIMUM_@@ AVER@@ AGE_@@ SUB@@ ARRAY_@@ OF_@@ K_@@ LENGTH | def find@@ Max@@ Average ( arr , n , k ) : NEW_LINE INDENT if k > n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT c@@ sum = [ 0 ] * n NEW_LINE c@@ sum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT c@@ sum [ i ] = c@@ sum [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT max_@@ sum = c@@ sum [ k - 1 ] NEW_LINE max_@@ end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_@@ sum = c@@ sum [ i ] - c@@ sum [ i - k ] NEW_LINE if curr_@@ sum > max_@@ sum : NEW_LINE INDENT max_@@ sum = curr_@@ sum NEW_LINE max_@@ end = i NEW_LINE DEDENT DEDENT return max_@@ end - k + 1 NEW_LINE DEDENT
SQU@@ ARE_@@ PY@@ RAM@@ ID@@ AL_@@ NUMBER@@ _S@@ UM@@ _S@@ QUAR@@ ES | def find@@ S ( s ) : NEW_LINE INDENT _@@ sum = 0 NEW_LINE n = 1 NEW_LINE while ( _@@ sum < s ) : NEW_LINE INDENT _@@ sum += n * n NEW_LINE n += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if _@@ sum == s : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
PROGRAM_@@ TO_@@ CAL@@ CUL@@ ATE_@@ AREA_@@ OF_@@ AN_@@ CI@@ R@@ CLE_@@ IN@@ SCRI@@ BED_@@ IN_@@ A@@ _S@@ QU@@ ARE | def area@@ Of@@ In@@ scri@@ bed@@ Circle ( a ) : NEW_LINE INDENT return ( PI / 4 ) * a * a NEW_LINE DEDENT
MINIMUM_@@ NUMBER_@@ CHARAC@@ TER@@ S_@@ REMO@@ VED_@@ MAKE_@@ BINARY_@@ STRING_@@ ALTER@@ N@@ ATE | def count@@ To@@ Make@@ 0@@ l@@ tern@@ ate ( s ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
FIND_@@ ELEMEN@@ TS_@@ PRES@@ ENT_@@ FIRST_@@ ARRAY_@@ NOT_@@ SECOND | def find@@ Missing ( a , b , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( a [ i ] == b [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == m - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
RE@@ AR@@ RANGE_@@ ARRAY_@@ MAXIMUM_@@ MINIMUM_@@ FORM | def re@@ arrange ( arr , n ) : NEW_LINE INDENT temp = n * [ None ] NEW_LINE small , large = 0 , n - 1 NEW_LINE flag = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if flag is True : NEW_LINE INDENT temp [ i ] = arr [ large ] NEW_LINE large -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ i ] = arr [ small ] NEW_LINE small += 1 NEW_LINE DEDENT flag = bool ( 1 - flag ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT return arr NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 15_@@ LON@@ GE@@ ST_@@ BIT@@ ON@@ IC@@ _SUB@@ SEQUENCE | def l@@ bs ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE lis = [ 1 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( ( arr [ i ] > arr [ j ] ) and ( lis [ i ] < lis [ j ] + 1 ) ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT lds = [ 1 for i in range ( n + 1 ) ] NEW_LINE for i in reversed ( range ( n - 1 ) ) : NEW_LINE INDENT for j in reversed ( range ( i - 1 , n ) ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT maximum = lis [ 0 ] + lds [ 0 ] - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT
COUNT_@@ PAIR@@ S_@@ WHO@@ SE_@@ PRODUC@@ TS_@@ EXI@@ ST_@@ IN_@@ ARRAY | def count@@ Pairs ( arr , n ) : NEW_LINE INDENT result = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product = arr [ i ] * arr [ j ] ; NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ k ] == product ) : NEW_LINE INDENT result = result + 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT
COUNT_@@ SINGLE_@@ NODE_@@ ISO@@ LA@@ TED@@ _SUB_@@ GRAP@@ H@@ S_@@ DIS@@ CONNEC@@ TED_@@ GRAP@@ H | def compute ( graph , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( len ( graph [ i ] ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
HARD@@ Y_@@ RAM@@ AN@@ U@@ J@@ AN_@@ THE@@ O@@ RE@@ M | def exact@@ Prime@@ Factor@@ Count ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE DEDENT DEDENT i = 3 NEW_LINE while ( i <= int ( math . sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n = int ( n / i ) NEW_LINE DEDENT DEDENT i = i + 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
SHOR@@ TEST_@@ COMM@@ ON@@ _SUP@@ ER@@ SEQU@@ ENCE_@@ 1 | def super@@ Seq ( X , Y , m , n ) : NEW_LINE INDENT dp = [ [ 0 ] * ( n + 2 ) for i in range ( m + 2 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( not i ) : dp [ i ] [ j ] = j NEW_LINE elif ( not j ) : dp [ i ] [ j ] = i NEW_LINE elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
POWER@@ _SET | def print@@ Power@@ Set ( set , set_size ) : NEW_LINE INDENT pow_@@ set_size = ( int ) ( math . pow ( 2 , set_size ) ) ; NEW_LINE counter = 0 ; NEW_LINE j = 0 ; NEW_LINE for counter in range ( 0 , pow_@@ set_size ) : NEW_LINE INDENT for j in range ( 0 , set_size ) : NEW_LINE INDENT if ( ( counter & ( 1 << j ) ) > 0 ) : NEW_LINE INDENT print ( set [ j ] , end = " " ) ; NEW_LINE DEDENT DEDENT print ( " " ) ; NEW_LINE DEDENT DEDENT
CHECK_@@ ARRAY_@@ MAJ@@ ORI@@ TY_@@ ELEMENT | def is@@ Maj@@ ority ( a ) : NEW_LINE INDENT mp = { } NEW_LINE for i in a : NEW_LINE INDENT if i in mp : mp [ i ] += 1 NEW_LINE else : mp [ i ] = 1 NEW_LINE DEDENT for x in mp : NEW_LINE INDENT if mp [ x ] >= len ( a ) // 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
PRINT_@@ GI@@ V@@ EN_@@ MATRIX_@@ COUNTER_@@ CLOCK_@@ WI@@ SE_@@ SPIR@@ AL_@@ FORM | def counter@@ Clock@@ spir@@ al@@ Print ( m , n , arr ) : NEW_LINE INDENT k = 0 ; l = 0 NEW_LINE cnt = 0 NEW_LINE total = m * n NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT if ( cnt == total ) : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( k , m ) : NEW_LINE INDENT print ( arr [ i ] [ l ] , end = " ▁ " ) NEW_LINE cnt += 1 NEW_LINE DEDENT l += 1 NEW_LINE if ( cnt == total ) : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( l , n ) : NEW_LINE INDENT print ( arr [ m - 1 ] [ i ] , end = " ▁ " ) NEW_LINE cnt += 1 NEW_LINE DEDENT m -= 1 NEW_LINE if ( cnt == total ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( k < m ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT print ( arr [ i ] [ n - 1 ] , end = " ▁ " ) NEW_LINE cnt += 1 NEW_LINE DEDENT n -= 1 NEW_LINE DEDENT if ( cnt == total ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( l < n ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT print ( arr [ k ] [ i ] , end = " ▁ " ) NEW_LINE cnt += 1 NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT DEDENT
PRI@@ MALI@@ TY_@@ TEST@@ _SET_@@ 1_@@ INTRO@@ DUC@@ TION_@@ AND@@ _S@@ CHOOL_@@ METHOD | def is@@ Prime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
FIND_@@ CHARACTER_@@ FIRST_@@ STRING_@@ PRES@@ ENT_@@ MINIMUM_@@ INDEX@@ _SECON@@ D_@@ STRING | def print@@ Min@@ Index@@ Char ( Str , pat@@ t ) : NEW_LINE INDENT min@@ Index = 10 ** 9 NEW_LINE m = len ( Str ) NEW_LINE n = len ( pat@@ t ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( pat@@ t [ i ] == Str [ j ] and j < min@@ Index ) : NEW_LINE INDENT min@@ Index = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( min@@ Index != 10 ** 9 ) : NEW_LINE INDENT print ( " Minimum ▁ Index ▁ Character ▁ = ▁ " , Str [ min@@ Index ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ character ▁ present " ) NEW_LINE DEDENT DEDENT
PROGRAM_@@ TO_@@ FIND_@@ TRANSP@@ OS@@ E_@@ OF_@@ A_@@ MATRIX_@@ 1 | def transpose ( A , B ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT B [ i ] [ j ] = A [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT
COUNT_@@ N@@ ATUR@@ AL_@@ NUMB@@ ERS_@@ WHO@@ SE_@@ PER@@ MU@@ TATION_@@ GREATER_@@ NUMBER | def count@@ Number ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT s = [ ] NEW_LINE if ( i <= n ) : NEW_LINE INDENT s . append ( i ) NEW_LINE result += 1 NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT tp = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE for j in range ( tp % 10 , 10 ) : NEW_LINE INDENT x = tp * 10 + j NEW_LINE if ( x <= n ) : NEW_LINE INDENT s . append ( x ) NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
FIND_@@ FIRST_@@ N@@ ATUR@@ AL_@@ NUMBER_@@ WHO@@ SE_@@ FAC@@ TOR@@ I@@ AL_@@ DI@@ VISI@@ BLE_@@ X | def first@@ Fac@@ tori@@ al@@ Di@@ visible@@ Number ( x ) : NEW_LINE INDENT i = 1 ; NEW_LINE fact = 1 ; NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( fact % x == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT
PRINT_@@ EQUAL@@ _S@@ UM@@ _SE@@ TS_@@ ARRAY_@@ PARTITION_@@ PRO@@ BLE@@ M@@ _SET_@@ 2 | def print@@ Equal@@ Sum@@ Sets ( arr , n ) : NEW_LINE INDENT sum_@@ array = sum ( arr ) NEW_LINE if ( sum_@@ array & 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT k = sum_@@ array >> 1 NEW_LINE dp = np . zeros ( ( n + 1 , k + 1 ) ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for curr@@ Sum in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ curr@@ Sum ] = dp [ i - 1 ] [ curr@@ Sum ] NEW_LINE if ( arr [ i - 1 ] <= curr@@ Sum ) : NEW_LINE INDENT dp [ i ] [ curr@@ Sum ] = ( dp [ i ] [ curr@@ Sum ] or dp [ i - 1 ] [ curr@@ Sum - arr [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT set1 , set2 = [ ] , [ ] NEW_LINE if ( not dp [ n ] [ k ] ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT i = n NEW_LINE curr@@ Sum = k NEW_LINE while ( i > 0 and curr@@ Sum >= 0 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ curr@@ Sum ] ) : NEW_LINE INDENT i -= 1 NEW_LINE set2 . append ( arr [ i ] ) NEW_LINE DEDENT elif ( dp [ i - 1 ] [ curr@@ Sum - arr [ i - 1 ] ] ) : NEW_LINE INDENT i -= 1 NEW_LINE curr@@ Sum -= arr [ i ] NEW_LINE set1 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT print ( " Set ▁ 1 ▁ elements : " , end = " ▁ " ) NEW_LINE for i in range ( len ( set1 ) ) : NEW_LINE INDENT print ( set1 [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " \n Set ▁ 2 ▁ elements : " , end = " ▁ " ) NEW_LINE for i in range ( len ( set2 ) ) : NEW_LINE INDENT print ( set2 [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
COUN@@ TING_@@ PAIR@@ S_@@ PERS@@ ON_@@ CAN_@@ FORM_@@ PA@@ IR_@@ ONE@@ _1 | def numberOf@@ W@@ ays ( x ) : NEW_LINE INDENT if x == 0 or x == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( numberOf@@ W@@ ays ( x - 1 ) + ( x - 1 ) * numberOf@@ W@@ ays ( x - 2 ) ) NEW_LINE DEDENT DEDENT
COUNT_@@ NEGATIVE_@@ NUMB@@ ERS_@@ IN_@@ A_@@ COLUMN_@@ WI@@ SE_@@ ROW_@@ WI@@ SE_@@ SOR@@ TED_@@ MATRIX | def count@@ Negative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if M [ i ] [ j ] < 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
COUNT_@@ SET_@@ BITS_@@ IN_@@ AN_@@ INTEGER | def count@@ Set@@ Bits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
MODUL@@ US_@@ TWO_@@ FLOAT_@@ DOUBLE_@@ NUMB@@ ERS | def find@@ Mod ( a , b ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT a = - a NEW_LINE DEDENT if ( b < 0 ) : NEW_LINE INDENT b = - b NEW_LINE DEDENT mod = a NEW_LINE while ( mod >= b ) : NEW_LINE INDENT mod = mod - b NEW_LINE DEDENT if ( a < 0 ) : NEW_LINE INDENT return - mod NEW_LINE DEDENT return mod NEW_LINE DEDENT
FIND_@@ A@@ _SPECI@@ FIC_@@ PA@@ IR_@@ IN_@@ MATRIX_@@ 1 | def find@@ Max@@ Value ( mat ) : NEW_LINE INDENT maxValue = - sys . maxsize - 1 NEW_LINE max@@ Arr = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE max@@ Arr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] NEW_LINE max@@ v = mat [ N - 1 ] [ N - 1 ] ; NEW_LINE for j in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ N - 1 ] [ j ] > max@@ v ) : NEW_LINE INDENT max@@ v = mat [ N - 1 ] [ j ] NEW_LINE DEDENT max@@ Arr [ N - 1 ] [ j ] = max@@ v NEW_LINE DEDENT max@@ v = mat [ N - 1 ] [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ N - 1 ] > max@@ v ) : NEW_LINE INDENT max@@ v = mat [ i ] [ N - 1 ] NEW_LINE DEDENT max@@ Arr [ i ] [ N - 1 ] = max@@ v NEW_LINE DEDENT for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( max@@ Arr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) : NEW_LINE INDENT maxValue = ( max@@ Arr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ) NEW_LINE DEDENT max@@ Arr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( max@@ Arr [ i ] [ j + 1 ] , max@@ Arr [ i + 1 ] [ j ] ) ) NEW_LINE DEDENT DEDENT return maxValue NEW_LINE DEDENT
MIN@@ IM@@ UM@@ _S@@ UM_@@ TWO_@@ NUMB@@ ERS_@@ FOR@@ MED_@@ DIG@@ IT@@ S_@@ ARRAY | def solve ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE a = 0 ; b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT a = a * 10 + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT b = b * 10 + arr [ i ] NEW_LINE DEDENT DEDENT return a + b NEW_LINE DEDENT
COUNT_@@ DISTIN@@ CT_@@ NON_@@ NEGATIVE_@@ PAIR@@ S_@@ X_@@ Y_S@@ ATI@@ SF@@ Y_@@ IN@@ EQU@@ ALI@@ TY_@@ X@@ X_@@ YY_@@ N_@@ 2_1 | def count@@ Solutions ( n ) : NEW_LINE INDENT x = 0 NEW_LINE res = 0 NEW_LINE y@@ Count = 0 NEW_LINE while ( y@@ Count * y@@ Count < n ) : NEW_LINE INDENT y@@ Count = y@@ Count + 1 NEW_LINE DEDENT while ( y@@ Count != 0 ) : NEW_LINE INDENT res = res + y@@ Count NEW_LINE x = x + 1 NEW_LINE while ( y@@ Count != 0 and ( x * x + ( y@@ Count - 1 ) * ( y@@ Count - 1 ) >= n ) ) : NEW_LINE INDENT y@@ Count = y@@ Count - 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
FIND_@@ INDEX_@@ GI@@ V@@ EN_@@ FI@@ BON@@ ACC@@ I_@@ NUMBER_@@ CONSTANT_@@ TIME | def find@@ Index ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res = res + 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT
PROGRAM_@@ OC@@ TAL_@@ DECIMAL_@@ CONVERSION | def oct@@ al@@ To@@ Decimal ( n ) : NEW_LINE INDENT num = n ; NEW_LINE dec_@@ value = 0 ; NEW_LINE base = 1 ; NEW_LINE temp = num ; NEW_LINE while ( temp ) : NEW_LINE INDENT last_@@ digit = temp % 10 ; NEW_LINE temp = int ( temp / 10 ) ; NEW_LINE dec_@@ value += last_@@ digit * base ; NEW_LINE base = base * 8 ; NEW_LINE DEDENT return dec_@@ value ; NEW_LINE DEDENT
FIND_@@ PER@@ MU@@ TED_@@ RO@@ WS_@@ GI@@ V@@ EN_@@ ROW_@@ MATRIX | def per@@ mut@@ ated@@ Rows ( mat , m , n , r ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT s . add ( mat [ r ] [ j ] ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if i == r : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if mat [ i ] [ j ] not in s : NEW_LINE INDENT j = j - 2 NEW_LINE break ; NEW_LINE DEDENT DEDENT if j + 1 != n : NEW_LINE INDENT continue NEW_LINE DEDENT print ( i ) NEW_LINE DEDENT DEDENT
PRINT_@@ A_@@ CLO@@ SE@@ ST_@@ STRING_@@ TH@@ AT_@@ DO@@ ES_@@ NOT_@@ CONTA@@ IN_@@ AD@@ J@@ AC@@ ENT_@@ DUPLIC@@ A@@ TES | def no@@ Adjac@@ ent@@ D@@ up ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT s [ i ] = " a " NEW_LINE while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) : NEW_LINE INDENT s [ i ] += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
S@@ UM_@@ MAN@@ H@@ ATTA@@ N_@@ DISTAN@@ CES_@@ PAIR@@ S_@@ POINTS | def distance@@ sum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
PROGRAM_@@ FIND_@@ STRING_@@ START_@@ END_@@ GE@@ E@@ KS | def is@@ Corner@@ Present ( str , corner ) : NEW_LINE INDENT n = len ( str ) NEW_LINE cl = len ( corner ) NEW_LINE if ( n < cl ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( str [ : cl ] == corner ) and ( str [ n - cl : ] == corner ) ) NEW_LINE DEDENT
LON@@ GE@@ ST@@ _SUB@@ ARRAY_@@ COUNT_@@ 1@@ S_@@ ONE_@@ COUNT_@@ 0@@ S | def len@@ Of@@ Long@@ Sub@@ arr ( arr , n ) : NEW_LINE INDENT um = { i : 0 for i in range ( 10 ) } NEW_LINE sum = 0 NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT sum += - 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif ( sum not in um ) : NEW_LINE INDENT um [ sum ] = i NEW_LINE DEDENT if ( ( sum - 1 ) in um ) : NEW_LINE INDENT if ( maxLen < ( i - um [ sum - 1 ] ) ) : NEW_LINE INDENT maxLen = i - um [ sum - 1 ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT
DI@@ VI@@ DE_@@ CON@@ QUER@@ _SET_@@ 6@@ _SEARCH_@@ ROW_@@ WI@@ SE_@@ COLUMN_@@ WI@@ SE_@@ SOR@@ TED_@@ 2D_@@ ARRAY | def search ( mat , from@@ Row , to@@ Row , from@@ Col , to@@ Col , key ) : NEW_LINE INDENT i = from@@ Row + ( to@@ Row - from@@ Row ) // 2 ; NEW_LINE j = from@@ Col + ( to@@ Col - from@@ Col ) // 2 ; NEW_LINE if ( mat [ i ] [ j ] == key ) : NEW_LINE INDENT print ( " Found ▁ " , key , " ▁ at ▁ " , i , " ▁ " , j ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( i != to@@ Row or j != from@@ Col ) : NEW_LINE INDENT search ( mat , from@@ Row , i , j , to@@ Col , key ) ; NEW_LINE DEDENT if ( from@@ Row == to@@ Row and from@@ Col + 1 == to@@ Col ) : NEW_LINE INDENT if ( mat [ from@@ Row ] [ to@@ Col ] == key ) : NEW_LINE INDENT print ( " Found ▁ " , key , " ▁ at ▁ " , from@@ Row , " ▁ " , to@@ Col ) ; NEW_LINE DEDENT DEDENT if ( mat [ i ] [ j ] < key ) : NEW_LINE INDENT if ( i + 1 <= to@@ Row ) : NEW_LINE INDENT search ( mat , i + 1 , to@@ Row , from@@ Col , to@@ Col , key ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( j - 1 >= from@@ Col ) : NEW_LINE INDENT search ( mat , from@@ Row , to@@ Row , from@@ Col , j - 1 , key ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT
SHOR@@ TEST_@@ COMM@@ ON@@ _SUP@@ ER@@ SEQUENCE | def super@@ Seq ( X , Y , m , n ) : NEW_LINE INDENT if ( not m ) : return n NEW_LINE if ( not n ) : return m NEW_LINE if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT return 1 + super@@ Seq ( X , Y , m - 1 , n - 1 ) NEW_LINE DEDENT return 1 + min ( super@@ Seq ( X , Y , m - 1 , n ) , super@@ Seq ( X , Y , m , n - 1 ) ) NEW_LINE DEDENT
UR@@ LI@@ FY_@@ GI@@ V@@ EN_@@ STRING_@@ REPL@@ ACE_@@ SPAC@@ ES | def replace@@ Spaces ( string ) : NEW_LINE INDENT string = string . strip ( ) NEW_LINE i = len ( string ) NEW_LINE space_@@ count = string . count ( ' ▁ ' ) NEW_LINE new_@@ length = i + space_@@ count * 2 NEW_LINE if new_@@ length > MAX : NEW_LINE INDENT return - 1 NEW_LINE DEDENT index = new_@@ length - 1 NEW_LINE string = list ( string ) NEW_LINE for f in range ( i - 2 , new_@@ length - 2 ) : NEW_LINE INDENT string . append ( '0' ) NEW_LINE DEDENT for j in range ( i - 1 , 0 , - 1 ) : NEW_LINE INDENT if string [ j ] == ' ▁ ' : NEW_LINE INDENT string [ index ] = '0' NEW_LINE string [ index - 1 ] = '2' NEW_LINE string [ index - 2 ] = ' % ' NEW_LINE index = index - 3 NEW_LINE DEDENT else : NEW_LINE INDENT string [ index ] = string [ j ] NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT return ' ' . join ( string ) NEW_LINE DEDENT
MAXIMUM_@@ PATH@@ _S@@ UM_@@ START@@ ING_@@ CELL_@@ 0_@@ TH_@@ ROW_@@ END@@ ING_@@ CELL_@@ N_@@ 1_@@ TH_@@ ROW | def Maximum@@ Path ( Mat ) : NEW_LINE INDENT result = 0 NEW_LINE dp = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + \ NEW_LINE INDENT Mat [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( N + 1 ) : NEW_LINE INDENT result = max ( result , dp [ N - 1 ] [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
COMP@@ UTE_@@ THE_@@ INTEGER_@@ ABSOL@@ UTE_@@ VALUE_@@ AB@@ S_@@ WITH@@ OUT_@@ BRAN@@ CH@@ ING | def get@@ Abs ( n ) : NEW_LINE INDENT mask = n >> ( SIZE_@@ INT * CHAR@@ BIT - 1 ) ; NEW_LINE return ( ( n + mask ) ^ mask ) ; NEW_LINE DEDENT
COUNT_@@ PA@@ LIN@@ DRO@@ MI@@ C@@ _SUB@@ SEQU@@ ENCE_@@ GI@@ V@@ EN_@@ STRING_@@ 1 | def count@@ PS ( i , j ) : NEW_LINE INDENT if ( i >= n or j < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( abs ( i - j ) == 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 3 NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 2 NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT DEDENT if ( i == j ) : NEW_LINE INDENT dp [ 1 ] [ j ] = 1 NEW_LINE return dp [ 1 ] [ j ] NEW_LINE DEDENT elif ( str [ i ] == str [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = ( count@@ PS ( i + 1 , j ) + count@@ PS ( i , j - 1 ) + 1 ) NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( count@@ PS ( i + 1 , j ) + count@@ PS ( i , j - 1 ) - count@@ PS ( i + 1 , j - 1 ) ) NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT DEDENT
LAR@@ GE@@ ST@@ _S@@ UM_@@ CON@@ TI@@ GU@@ OU@@ S@@ _SUB@@ ARRAY_@@ 2 | def max@@ Sub@@ Array@@ Sum ( a , size ) : NEW_LINE INDENT max_@@ so@@ _f@@ ar = a [ 0 ] NEW_LINE curr_@@ max = a [ 0 ] NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT curr_@@ max = max ( a [ i ] , curr_@@ max + a [ i ] ) NEW_LINE max_@@ so@@ _f@@ ar = max ( max_@@ so@@ _f@@ ar , curr_@@ max ) NEW_LINE DEDENT return max_@@ so@@ _f@@ ar NEW_LINE DEDENT
COUNT_@@ MINIMUM_@@ STE@@ PS_@@ GET_@@ GI@@ V@@ EN_@@ DE@@ SI@@ RED_@@ ARRAY | def count@@ Min@@ Operations ( target , n ) : NEW_LINE INDENT result = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT zero_@@ count = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( ( target [ i ] & 1 ) > 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT elif ( target [ i ] == 0 ) : NEW_LINE INDENT zero_@@ count += 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT if ( zero_@@ count == n ) : NEW_LINE INDENT return result ; NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT target [ j ] = target [ j ] // 2 ; NEW_LINE DEDENT result += 1 ; NEW_LINE DEDENT for j in range ( i , n ) : NEW_LINE INDENT if ( target [ j ] & 1 ) : NEW_LINE INDENT target [ j ] -= 1 ; NEW_LINE result += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT
PRINT_@@ FI@@ BON@@ AC@@ CI@@ _SEQU@@ ENCE_@@ USING_@@ 2_@@ VARIAB@@ LES_@@ 1 | def fi@@ b ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n >= 0 ) : NEW_LINE INDENT print ( a , end = ' ▁ ' ) NEW_LINE DEDENT if ( n >= 1 ) : NEW_LINE INDENT print ( b , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT print ( a + b , end = ' ▁ ' ) NEW_LINE b = a + b NEW_LINE a = b - a NEW_LINE DEDENT DEDENT
PROGRAM_@@ CHECK_@@ INPUT_@@ INTEGER_@@ STRING | def is@@ Number ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] . isdigit ( ) != True : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
MINIMUM_@@ HEIGHT_@@ TRIANGLE_@@ GI@@ V@@ EN_@@ BASE_@@ AREA | def min@@ Height ( area , base ) : NEW_LINE INDENT return math . ceil ( ( 2 * area ) / base ) NEW_LINE DEDENT
FIND_@@ POSITION_@@ GI@@ V@@ EN_@@ NUMBER_@@ AM@@ ONG_@@ NUMB@@ ERS_@@ MA@@ DE_@@ 4_@@ 7 | def find@@ pos ( n ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( n ) NEW_LINE pos = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( n [ i ] == '4' ) : NEW_LINE INDENT pos = pos * 2 + 1 NEW_LINE DEDENT if ( n [ i ] == '7' ) : NEW_LINE INDENT pos = pos * 2 + 2 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return pos NEW_LINE DEDENT
MINIMUM_@@ OPER@@ ATION@@ S_@@ REQUI@@ RED@@ _SET_@@ ELEMEN@@ TS_@@ BINARY_@@ MATRIX | def min@@ Operation ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE for k in range ( i + 1 ) : NEW_LINE INDENT for h in range ( j + 1 ) : NEW_LINE INDENT if ( arr [ k ] [ h ] == 1 ) : NEW_LINE INDENT arr [ k ] [ h ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] [ h ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
LON@@ GE@@ ST_@@ EV@@ EN_@@ LENGTH@@ _SUB@@ STRING@@ _S@@ UM_@@ FIR@@ ST@@ _SECON@@ D_@@ HALF_@@ 2 | def find@@ Length ( string , n ) : NEW_LINE INDENT Sum = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT Sum [ i ] = ( Sum [ i - 1 ] + int ( string [ i - 1 ] ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for length in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT for i in range ( 0 , n - length + 1 ) : NEW_LINE INDENT j = i + length - 1 NEW_LINE if ( Sum [ i + length // 2 ] - Sum [ i ] == Sum [ i + length ] - Sum [ i + length // 2 ] ) : NEW_LINE INDENT ans = max ( ans , length ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
MULTI@@ PLY_@@ LARGE_@@ NUMB@@ ERS_@@ RE@@ PRESEN@@ TED_@@ AS_@@ STRINGS | def multiply ( num1 , num2 ) : NEW_LINE INDENT len1 = len ( num1 ) NEW_LINE len2 = len ( num2 ) NEW_LINE if len1 == 0 or len2 == 0 : NEW_LINE INDENT return "0" NEW_LINE DEDENT result = [ 0 ] * ( len1 + len2 ) NEW_LINE i_@@ n1 = 0 NEW_LINE i_@@ n2 = 0 NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT carry = 0 NEW_LINE n1 = ord ( num1 [ i ] ) - 48 NEW_LINE i_@@ n2 = 0 NEW_LINE for j in range ( len2 - 1 , - 1 , - 1 ) : NEW_LINE INDENT n2 = ord ( num2 [ j ] ) - 48 NEW_LINE sum@@ m = n1 * n2 + result [ i_@@ n1 + i_@@ n2 ] + carry NEW_LINE carry = sum@@ m // 10 NEW_LINE result [ i_@@ n1 + i_@@ n2 ] = sum@@ m % 10 NEW_LINE i_@@ n2 += 1 NEW_LINE DEDENT if ( carry > 0 ) : NEW_LINE INDENT result [ i_@@ n1 + i_@@ n2 ] += carry NEW_LINE DEDENT i_@@ n1 += 1 NEW_LINE DEDENT i = len ( result ) - 1 NEW_LINE while ( i >= 0 and result [ i ] == 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT s = " " NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT s += chr ( result [ i ] + 48 ) NEW_LINE i -= 1 NEW_LINE DEDENT return s NEW_LINE DEDENT
PARTITION_@@ NUMBER_@@ TWO_@@ DI@@ VI@@ S@@ BLE_@@ PAR@@ TS | def find@@ Division ( str , a , b ) : NEW_LINE INDENT len@@ n = len ( str ) NEW_LINE lr = [ 0 ] * ( len@@ n + 1 ) NEW_LINE lr [ 0 ] = ( int ( str [ 0 ] ) ) % a NEW_LINE for i in range ( 1 , len@@ n ) : NEW_LINE INDENT lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + \ int ( str [ i ] ) ) % a NEW_LINE DEDENT rl = [ 0 ] * ( len@@ n + 1 ) NEW_LINE rl [ len@@ n - 1 ] = int ( str [ len@@ n - 1 ] ) % b NEW_LINE power@@ 10 = 10 NEW_LINE for i in range ( len@@ n - 2 , - 1 , - 1 ) : NEW_LINE INDENT rl [ i ] = ( rl [ i + 1 ] + int ( str [ i ] ) * power@@ 10 ) % b NEW_LINE power@@ 10 = ( power@@ 10 * 10 ) % b NEW_LINE DEDENT for i in range ( 0 , len@@ n - 1 ) : NEW_LINE INDENT if ( lr [ i ] != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( rl [ i + 1 ] == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE for k in range ( 0 , i + 1 ) : NEW_LINE INDENT print ( str [ k ] , end = " " ) NEW_LINE DEDENT print ( " , " , end = " ▁ " ) NEW_LINE for i in range ( i + 1 , len@@ n ) : NEW_LINE INDENT print ( str [ k ] , end = " " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " NO " ) NEW_LINE DEDENT
PROGRAM_@@ BE@@ ST_@@ FI@@ T_@@ ALGORITH@@ M_@@ MEMORY_@@ MAN@@ A@@ GEMENT | def best@@ Fit ( blockSize , m , process@@ Size , n ) : NEW_LINE INDENT allocation = [ - 1 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT best@@ Idx = - 1 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if blockSize [ j ] >= process@@ Size [ i ] : NEW_LINE INDENT if best@@ Idx == - 1 : NEW_LINE INDENT best@@ Idx = j NEW_LINE DEDENT elif blockSize [ best@@ Idx ] > blockSize [ j ] : NEW_LINE INDENT best@@ Idx = j NEW_LINE DEDENT DEDENT DEDENT if best@@ Idx != - 1 : NEW_LINE INDENT allocation [ i ] = best@@ Idx NEW_LINE blockSize [ best@@ Idx ] -= process@@ Size [ i ] NEW_LINE DEDENT DEDENT print ( " Process ▁ No . ▁ Process ▁ Size ▁ ▁ ▁ ▁ ▁ Block ▁ no . " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( i + 1 , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , process@@ Size [ i ] , end = " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " ) NEW_LINE if allocation [ i ] != - 1 : NEW_LINE INDENT print ( allocation [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT DEDENT
FIN@@ DING_@@ THE_@@ MAX@@ IM@@ UM@@ _S@@ QU@@ ARE_@@ SUB_@@ MATRIX_@@ WITH_@@ ALL_@@ EQUAL_@@ ELEMENTS | def lar@@ gest@@ K@@ Sub@@ matrix ( a ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( Row ) ] for y in range ( Col ) ] NEW_LINE result = 0 NEW_LINE for i in range ( Row ) : NEW_LINE INDENT for j in range ( Col ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] and a [ i ] [ j ] == a [ i ] [ j - 1 ] and a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT result = max ( result , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
FRI@@ END@@ S_@@ PAIR@@ ING_@@ PRO@@ BLE@@ M_@@ 1 | def count@@ Fri@@ ends@@ Pair@@ ings ( n ) : NEW_LINE INDENT dp = [ - 1 ] * 100 NEW_LINE if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT dp [ n ] = ( count@@ Fri@@ ends@@ Pair@@ ings ( n - 1 ) + ( n - 1 ) * count@@ Fri@@ ends@@ Pair@@ ings ( n - 2 ) ) NEW_LINE return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ n ] = n NEW_LINE return dp [ n ] NEW_LINE DEDENT DEDENT
FIRST_@@ ELEMENT_@@ OC@@ CURR@@ ING_@@ K_@@ TIME@@ S_@@ ARRAY | def first@@ Element ( arr , n , k ) : NEW_LINE INDENT count_@@ map = { } ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] in count_@@ map . keys ( ) ) : NEW_LINE INDENT count_@@ map [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_@@ map [ arr [ i ] ] = 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( count_@@ map [ arr [ i ] ] == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
SUM@@ _SERI@@ ES_@@ 0_@@ 6_@@ 0_@@ 06_@@ 0_@@ 00@@ 6_@@ 0_@@ 00@@ 06_@@ N_@@ TER@@ MS | def sum@@ Of@@ Series ( n ) : NEW_LINE INDENT return ( ( 0.@@ 666 ) * ( 1 - 1 / pow ( 10 , n ) ) ) ; NEW_LINE DEDENT
COUNT_@@ WOR@@ DS_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ STRING | def count@@ Words ( string ) : NEW_LINE INDENT state = OUT NEW_LINE wc = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ' ▁ ' or string [ i ] == ' \n ' or string [ i ] == ' \t ' ) : NEW_LINE INDENT state = OUT NEW_LINE DEDENT elif state == OUT : NEW_LINE INDENT state = IN NEW_LINE wc += 1 NEW_LINE DEDENT DEDENT return wc NEW_LINE DEDENT
PARTITION_@@ IN@@ TO_@@ TW@@ O@@ _SUB@@ ARRAY@@ S_@@ OF_@@ LENGTH@@ S_@@ K_@@ AND_@@ N_@@ K@@ _SU@@ CH_@@ TH@@ AT_@@ THE_@@ DIFF@@ ER@@ ENCE_@@ OF@@ _S@@ UM@@ S_@@ IS_@@ MAX@@ IMUM | def max@@ Difference ( arr , N , k ) : NEW_LINE INDENT S = 0 NEW_LINE S1 = 0 NEW_LINE max_@@ difference = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE DEDENT arr . sort ( reverse = True ) NEW_LINE M = max ( k , N - k ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT S1 += arr [ i ] NEW_LINE DEDENT max_@@ difference = S1 - ( S - S1 ) NEW_LINE return max_@@ difference NEW_LINE DEDENT
HO@@ W_@@ WI@@ LL_@@ Y@@ OU@@ _@@ PRINT_@@ NUMB@@ ERS_@@ FROM_@@ 1_@@ TO_@@ 200@@ _@@ WITH@@ OUT_@@ USING_@@ LOOP | def print@@ No@@ s ( n ) : NEW_LINE INDENT if n > 0 : NEW_LINE INDENT print@@ No@@ s ( n - 1 ) NEW_LINE print ( n , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
GI@@ V@@ EN_@@ A@@ _S@@ OR@@ TED_@@ AND_@@ ROTA@@ TED_@@ ARRAY_@@ FIND_@@ IF_@@ THER@@ E_@@ IS_@@ A_@@ PA@@ IR_@@ WITH_@@ A_@@ GI@@ VEN@@ _S@@ UM@@ _1 | def pair@@ sIn@@ Sorted@@ Rot@@ ated ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE cnt = 0 NEW_LINE while ( l != r ) : NEW_LINE INDENT if arr [ l ] + arr [ r ] == x : NEW_LINE INDENT cnt += 1 NEW_LINE if l == ( r - 1 + n ) % n : NEW_LINE INDENT return cnt NEW_LINE DEDENT l = ( l + 1 ) % n NEW_LINE r = ( r - 1 + n ) % n NEW_LINE DEDENT elif arr [ l ] + arr [ r ] < x : NEW_LINE INDENT l = ( l + 1 ) % n NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
FIND_@@ THE_@@ ELEMENT_@@ TH@@ AT_@@ AP@@ PE@@ AR@@ S_@@ ONCE | def get@@ Single ( arr , n ) : NEW_LINE INDENT ones = 0 NEW_LINE tw@@ os = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tw@@ os = tw@@ os | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_@@ bit@@ _mask = ~ ( ones & tw@@ os ) NEW_LINE ones &= common_@@ bit@@ _mask NEW_LINE tw@@ os &= common_@@ bit@@ _mask NEW_LINE DEDENT return ones NEW_LINE DEDENT
CAS@@ SIN@@ IS_@@ IDENTITY | def c@@ ass@@ ini ( n ) : NEW_LINE INDENT return - 1 if ( n & 1 ) else 1 NEW_LINE DEDENT
DISTRIBU@@ TING_@@ ALL_@@ BAL@@ LS_@@ WITH@@ OUT_@@ REPE@@ TI@@ TION | def distribu@@ ting@@ Bal@@ ls ( k , n , string ) : NEW_LINE INDENT a = [ 0 ] * MAX_@@ CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_@@ CHAR ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
DISTRIBU@@ TING_@@ ITE@@ MS_@@ PERS@@ ON_@@ CANNOT_@@ TA@@ KE_@@ TWO_@@ ITE@@ MS_@@ TYPE | def check@@ Count ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if arr [ j ] == arr [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count > 2 * k : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
MAXI@@ MI@@ ZE_@@ ARR@@ J_@@ AR@@ RI@@ _@@ ARR@@ L_@@ ARR@@ K@@ _SU@@ CH_@@ TH@@ AT_@@ I_@@ J_@@ K_@@ L | def find@@ Max@@ Value ( arr , n ) : NEW_LINE INDENT if n < 4 : NEW_LINE INDENT print ( " The ▁ array ▁ should ▁ have ▁ at@@ le@@ st ▁ 4 ▁ elements " ) NEW_LINE return MIN NEW_LINE DEDENT table1 , table@@ 2 = [ MIN ] * ( n + 1 ) , [ MIN ] * n NEW_LINE table@@ 3 , table@@ 4 = [ MIN ] * ( n - 1 ) , [ MIN ] * ( n - 2 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT table@@ 2 [ i ] = max ( table@@ 2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT table@@ 3 [ i ] = max ( table@@ 3 [ i + 1 ] , table@@ 2 [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 4 , - 1 , - 1 ) : NEW_LINE INDENT table@@ 4 [ i ] = max ( table@@ 4 [ i + 1 ] , table@@ 3 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT return table@@ 4 [ 0 ] NEW_LINE DEDENT
COUNT_@@ NEGATIVE_@@ NUMB@@ ERS_@@ IN_@@ A_@@ COLUMN_@@ WI@@ SE_@@ ROW_@@ WI@@ SE_@@ SOR@@ TED_@@ MATRIX_@@ 1 | def count@@ Negative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE j = m - 1 NEW_LINE while j >= 0 and i < n : NEW_LINE INDENT if M [ i ] [ j ] < 0 : NEW_LINE INDENT count += ( j + 1 ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
SORT_@@ AN_@@ ARRAY_@@ OF_@@ 0@@ S_@@ 1@@ S_@@ AND_@@ 2@@ S | def sort@@ 012 ( a , arr_@@ size ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = arr_@@ size - 1 NEW_LINE mid = 0 NEW_LINE while mid <= hi : NEW_LINE INDENT if a [ mid ] == 0 : NEW_LINE INDENT a [ lo ] , a [ mid ] = a [ mid ] , a [ lo ] NEW_LINE lo = lo + 1 NEW_LINE mid = mid + 1 NEW_LINE DEDENT elif a [ mid ] == 1 : NEW_LINE INDENT mid = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ mid ] , a [ hi ] = a [ hi ] , a [ mid ] NEW_LINE hi = hi - 1 NEW_LINE DEDENT DEDENT DEDENT
N@@ TH_@@ EV@@ EN_@@ FI@@ BON@@ ACC@@ I_@@ NUMBER | def even@@ Fi@@ b ( n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return ( ( 4 * even@@ Fi@@ b ( n - 1 ) ) + even@@ Fi@@ b ( n - 2 ) ) NEW_LINE DEDENT
NEXT_@@ GREATER_@@ ELEMENT | def print@@ N@@ GE ( arr ) : NEW_LINE INDENT for i in range ( 0 , len ( arr ) , 1 ) : NEW_LINE INDENT next = - 1 NEW_LINE for j in range ( i + 1 , len ( arr ) , 1 ) : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT next = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( str ( arr [ i ] ) + " ▁ - - ▁ " + str ( next ) ) NEW_LINE DEDENT DEDENT
CHECK_@@ WHE@@ THER_@@ GI@@ V@@ EN_@@ CI@@ R@@ CLE_@@ RE@@ SIDE_@@ BOUN@@ DARY_@@ MAIN@@ TA@@ IN@@ ED_@@ OU@@ TER_@@ CI@@ R@@ CLE_@@ IN@@ NER_@@ CIRC@@ LE | def fit@@ Or@@ Not@@ Fit ( R , r , x , y , rad ) : NEW_LINE INDENT val = math . sqrt ( math . pow ( x , 2 ) + math . pow ( y , 2 ) ) NEW_LINE if ( val + rad <= R and val - rad >= R - r ) : NEW_LINE INDENT print ( " F@@ its \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Doesn ' t ▁ Fit " ) NEW_LINE DEDENT DEDENT
BASIC_@@ AND_@@ EXTENDED_@@ EUC@@ LI@@ DE@@ AN_@@ ALGORITH@@ MS_@@ 1 | def g@@ cd@@ Extended ( a , b , x , y ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT x = 0 NEW_LINE y = 1 NEW_LINE return b NEW_LINE DEDENT x1 = 1 NEW_LINE y1 = 1 NEW_LINE gcd = g@@ cd@@ Extended ( b % a , a , x1 , y1 ) NEW_LINE x = y1 - ( b / a ) * x1 NEW_LINE y = x1 NEW_LINE return gcd NEW_LINE DEDENT
FIN@@ D_S@@ MAL@@ LE@@ ST_@@ RANGE_@@ CONTAIN@@ ING_@@ ELEMEN@@ TS_@@ FROM_@@ K_@@ LI@@ STS | def find@@ S@@ malle@@ st@@ Range ( arr , n , k ) : NEW_LINE INDENT i , min@@ val , maxval , min@@ range , min@@ el , max@@ el , flag , min@@ ind = 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT ptr [ i ] = 0 NEW_LINE DEDENT min@@ range = 10 ** 9 NEW_LINE while ( 1 ) : NEW_LINE INDENT min@@ ind = - 1 NEW_LINE min@@ val = 10 ** 9 NEW_LINE maxval = - 10 ** 9 NEW_LINE flag = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( ptr [ i ] == n ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < min@@ val ) : NEW_LINE INDENT min@@ ind = i NEW_LINE min@@ val = arr [ i ] [ ptr [ i ] ] NEW_LINE DEDENT if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval ) : NEW_LINE INDENT maxval = arr [ i ] [ ptr [ i ] ] NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT break NEW_LINE DEDENT ptr [ min@@ ind ] += 1 NEW_LINE if ( ( maxval - min@@ val ) < min@@ range ) : NEW_LINE INDENT min@@ el = min@@ val NEW_LINE max@@ el = maxval NEW_LINE min@@ range = max@@ el - min@@ el NEW_LINE DEDENT DEDENT print ( " The ▁ smallest ▁ range ▁ is ▁ [ " , min@@ el , max@@ el , " ] " ) NEW_LINE DEDENT
FIND_@@ THE_@@ MINIMUM_@@ CO@@ ST_@@ TO_@@ REACH_@@ A_@@ DESTIN@@ ATION_@@ W@@ HER@@ E_@@ EVER@@ Y_@@ ST@@ ATION_@@ IS_@@ CONNEC@@ TED_@@ IN_@@ ONE_@@ DIRECTION | def min@@ Cost ( cost ) : NEW_LINE INDENT dist = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dist [ i ] = INF NEW_LINE DEDENT dist [ 0 ] = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) : NEW_LINE INDENT dist [ j ] = dist [ i ] + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dist [ N - 1 ] NEW_LINE DEDENT
MIDD@@ LE_@@ OF_@@ THRE@@ E_@@ USING_@@ MINIMUM_@@ COMP@@ ARIS@@ ONS_@@ 1 | def middle@@ Of@@ Three ( a , b , c ) : NEW_LINE INDENT if a > b : NEW_LINE INDENT if ( b > c ) : NEW_LINE INDENT return b NEW_LINE DEDENT elif ( a > c ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( a > c ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( b > c ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT DEDENT
CHECK_@@ LARGE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 11_@@ NOT | def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE odd@@ Dig@@ Sum = 0 NEW_LINE even@@ Dig@@ Sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT odd@@ Dig@@ Sum = odd@@ Dig@@ Sum + ( ( int ) ( st [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT even@@ Dig@@ Sum = even@@ Dig@@ Sum + ( ( int ) ( st [ i ] ) ) NEW_LINE DEDENT DEDENT return ( ( odd@@ Dig@@ Sum - even@@ Dig@@ Sum ) % 11 == 0 ) NEW_LINE DEDENT
COMP@@ UTE_@@ MODUL@@ US_@@ DI@@ VISI@@ ON_@@ BY_@@ A_@@ POWER_@@ OF_@@ 2_@@ NUMBER | def get@@ Modul@@ o ( n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) NEW_LINE DEDENT
COUNT_@@ BINARY_@@ STRING@@ S_@@ K_@@ TIME@@ S_@@ AP@@ PE@@ AR@@ ING_@@ AD@@ J@@ AC@@ ENT_@@ TW@@ O@@ _SET_@@ BITS | def count@@ Strings ( n , k ) : NEW_LINE INDENT dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) NEW_LINE dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] NEW_LINE if j >= 1 : NEW_LINE INDENT dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] NEW_LINE DEDENT
FIN@@ DING_@@ K_@@ MODUL@@ US_@@ ARRAY_@@ ELEMENT | def print@@ Equal@@ Mod@@ Numbers ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE d = arr [ n - 1 ] - arr [ 0 ] ; NEW_LINE v = [ ] ; NEW_LINE i = 1 ; NEW_LINE while ( i * i <= d ) : NEW_LINE INDENT if ( d % i == 0 ) : NEW_LINE INDENT v . append ( i ) ; NEW_LINE if ( i != d / i ) : NEW_LINE INDENT v . append ( d / i ) ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT for i in range ( len ( v ) ) : NEW_LINE INDENT temp = arr [ 0 ] % v [ i ] ; NEW_LINE j = 1 ; NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( arr [ j ] % v [ i ] != temp ) : NEW_LINE INDENT break ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT print ( v [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
CIRC@@ ULAR_@@ MATRIX_@@ CONSTRUC@@ T_@@ A_@@ MATRIX_@@ WITH_@@ NUMB@@ ERS_@@ 1_@@ TO_@@ M@@ N_@@ IN@@ _SP@@ IR@@ AL_@@ WAY | def spir@@ al@@ Fill ( m , n , a ) : NEW_LINE INDENT val = 1 NEW_LINE k , l = 0 , 0 NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT a [ k ] [ i ] = val NEW_LINE val += 1 NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT a [ i ] [ n - 1 ] = val NEW_LINE val += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if ( k < m ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT a [ m - 1 ] [ i ] = val NEW_LINE val += 1 NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if ( l < n ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ l ] = val NEW_LINE val += 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT DEDENT
FIND_@@ THE_@@ TWO_@@ REPE@@ ATING_@@ ELEMEN@@ TS_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ 2 | def print@@ Repe@@ ating ( arr , size ) : NEW_LINE INDENT xor = arr [ 0 ] NEW_LINE n = size - 2 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT xor ^= arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT xor ^= i NEW_LINE DEDENT set_@@ bit_@@ no = xor & ~ ( xor - 1 ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] & set_@@ bit_@@ no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i & set_@@ bit_@@ no ) : NEW_LINE INDENT x = x ^ i NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ i NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ repe@@ ating " , " elements ▁ are " , y , x ) NEW_LINE DEDENT
COUNT_@@ POSSI@@ BLE_@@ WAY@@ S_TO_@@ CONSTRUC@@ T_@@ BUILD@@ INGS | def count@@ W@@ ays ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT count@@ B = 1 NEW_LINE count@@ S = 1 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT prev_@@ count@@ B = count@@ B NEW_LINE prev_@@ count@@ S = count@@ S NEW_LINE count@@ S = prev_@@ count@@ B + prev_@@ count@@ S NEW_LINE count@@ B = prev_@@ count@@ S NEW_LINE DEDENT result = count@@ S + count@@ B NEW_LINE return ( result * result ) NEW_LINE DEDENT
ONE_@@ LINE_@@ FUNCTION_@@ FOR_@@ FAC@@ TOR@@ I@@ AL_@@ OF_@@ A_@@ NUMBER | def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) ; NEW_LINE DEDENT
CHECK_@@ GI@@ V@@ EN_@@ MATRI@@ X@@ _S@@ PARSE_@@ NOT | def is@@ Sparse ( array , m , n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( array [ i ] [ j ] == 0 ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT DEDENT return ( counter > ( ( m * n ) // 2 ) ) NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 10_@@ 0_@@ 1_@@ KN@@ AP@@ S@@ ACK_@@ PRO@@ BLE@@ M | def kn@@ ap@@ S@@ ack ( W , wt , val , n ) : NEW_LINE INDENT if n == 0 or W == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt [ n - 1 ] > W ) : NEW_LINE INDENT return kn@@ ap@@ S@@ ack ( W , wt , val , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( val [ n - 1 ] + kn@@ ap@@ S@@ ack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , kn@@ ap@@ S@@ ack ( W , wt , val , n - 1 ) ) NEW_LINE DEDENT DEDENT
FIN@@ D@@ _SUB@@ ARRAY_@@ LEA@@ ST_@@ AVER@@ AGE | def find@@ Min@@ Avg@@ Sub@@ array ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : return 0 NEW_LINE res_@@ index = 0 NEW_LINE curr_@@ sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT curr_@@ sum += arr [ i ] NEW_LINE DEDENT min_@@ sum = curr_@@ sum NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_@@ sum += arr [ i ] - arr [ i - k ] NEW_LINE if ( curr_@@ sum < min_@@ sum ) : NEW_LINE INDENT min_@@ sum = curr_@@ sum NEW_LINE res_@@ index = ( i - k + 1 ) NEW_LINE DEDENT DEDENT print ( " Sub@@ array ▁ between ▁ [ " , res_@@ index , " , ▁ " , ( res_@@ index + k - 1 ) , " ] ▁ has ▁ minimum ▁ average " ) NEW_LINE DEDENT
QUER@@ I@@ ES_@@ FOR_@@ CHARAC@@ TER@@ S_IN_@@ A_@@ REPE@@ ATED_@@ STRING | def query ( s , i , j ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i %= n NEW_LINE j %= n NEW_LINE print ( " Yes " ) if s [ i ] == s [ j ] else print ( " No " ) NEW_LINE DEDENT
A_@@ PRODUCT_@@ ARRAY_@@ PU@@ ZZ@@ LE_@@ 1 | def product@@ Array ( arr , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT i , temp = 1 , 1 NEW_LINE prod = [ 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod [ i ] = temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT temp = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT prod [ i ] *= temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( prod [ i ] , end = " ▁ " ) NEW_LINE DEDENT return NEW_LINE DEDENT
FIND_@@ PAIR@@ S_@@ GI@@ VEN@@ _S@@ UM_@@ ELEMEN@@ TS_@@ PA@@ IR_@@ DIFF@@ ER@@ ENT_@@ ROWS | def pair@@ Sum ( mat , n , sum ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT mat [ i ] . sort ( ) NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT left = 0 NEW_LINE right = n - 1 NEW_LINE while ( left < n and right >= 0 ) : NEW_LINE INDENT if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) : NEW_LINE INDENT print ( " ( " , mat [ i ] [ left ] , " , ▁ " , mat [ j ] [ right ] , " ) , ▁ " , end = " ▁ " ) NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT
CHECK_@@ STRING_@@ CAN_@@ OB@@ TA@@ IN@@ ED_@@ ROTA@@ TING_@@ AN@@ OTHER_@@ STRING_@@ 2_@@ PL@@ AC@@ ES | def is@@ Rot@@ ated ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) != len ( str2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT clock_@@ rot = " " NEW_LINE an@@ tic@@ lock_@@ rot = " " NEW_LINE l = len ( str2 ) NEW_LINE an@@ tic@@ lock_@@ rot = ( an@@ tic@@ lock_@@ rot + str2 [ l - 2 : ] + str2 [ 0 : l - 2 ] ) NEW_LINE clock_@@ rot = clock_@@ rot + str2 [ 2 : ] + str2 [ 0 : 2 ] NEW_LINE return ( str1 == clock_@@ rot or str1 == an@@ tic@@ lock_@@ rot ) NEW_LINE DEDENT
N_@@ TH_@@ NUMBER_@@ WHO@@ SE_@@ S@@ UM_@@ OF_@@ DIG@@ IT@@ S_@@ IS_@@ TEN | def find@@ N@@ th ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for curr in itertools . count ( ) : NEW_LINE INDENT sum = 0 NEW_LINE x = curr NEW_LINE while ( x ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
PROGRAM_@@ FIN@@ D_S@@ LO@@ PE_@@ LINE | def slope ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return ( float ) ( y2 - y1 ) / ( x2 - x1 ) NEW_LINE DEDENT
GC@@ D_@@ ELEMEN@@ TS_@@ GI@@ V@@ EN_@@ RANGE | def range@@ GC@@ D ( n , m ) : NEW_LINE INDENT return n if ( n == m ) else 1 NEW_LINE DEDENT
LON@@ GE@@ ST_@@ ALTER@@ N@@ AT@@ ING@@ _SUB_@@ ARRAY_@@ START@@ ING_@@ EVER@@ Y_@@ INDEX_@@ BINARY_@@ ARRAY_@@ 1 | def alternate@@ Sub@@ array ( arr , n ) : NEW_LINE INDENT count = 1 NEW_LINE prev = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] ^ prev ) == 0 ) : NEW_LINE INDENT while ( count ) : NEW_LINE INDENT print ( count , end = " ▁ " ) NEW_LINE count -= 1 NEW_LINE DEDENT DEDENT count += 1 NEW_LINE prev = arr [ i ] NEW_LINE DEDENT while ( count ) : NEW_LINE INDENT print ( count , end = " ▁ " ) NEW_LINE count -= 1 NEW_LINE DEDENT DEDENT
FIND_@@ UNIT_@@ DIG@@ IT_@@ X_@@ RAI@@ SED_@@ POWER_@@ Y | def unit@@ Digit@@ X@@ Rai@@ sed@@ Y ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( y ) : NEW_LINE INDENT res = ( res * x ) % 10 NEW_LINE DEDENT return res NEW_LINE DEDENT
MULTI@@ PLY_@@ LARGE_@@ INTEG@@ ERS_@@ UN@@ DER_@@ LARGE_@@ MODUL@@ O | def modu@@ lo@@ Multiplic@@ ation ( a , b , mod ) : NEW_LINE INDENT res = 0 ; NEW_LINE a = a % mod ; NEW_LINE while ( b ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = ( res + a ) % mod ; NEW_LINE DEDENT a = ( 2 * a ) % mod ; NEW_LINE b >>= 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
FIN@@ D_S@@ MAL@@ LE@@ ST_@@ NUMBER_@@ WITH_@@ GI@@ V@@ EN_@@ NUMBER_OF_@@ DIG@@ IT@@ S_@@ AND_@@ DIG@@ IT_@@ SUM | def find@@ S@@ malle@@ st ( m , s ) : NEW_LINE INDENT if ( s == 0 ) : NEW_LINE INDENT if ( m == 1 ) : NEW_LINE INDENT print ( " S@@ malle@@ st ▁ number ▁ is ▁ 0" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT return NEW_LINE DEDENT if ( s > 9 * m ) : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE return NEW_LINE DEDENT res = [ 0 for i in range ( m + 1 ) ] NEW_LINE s -= 1 NEW_LINE for i in range ( m - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( s > 9 ) : NEW_LINE INDENT res [ i ] = 9 NEW_LINE s -= 9 NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = s NEW_LINE s = 0 NEW_LINE DEDENT DEDENT res [ 0 ] = s + 1 NEW_LINE print ( " S@@ malle@@ st ▁ number ▁ is ▁ " , end = " " ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT print ( res [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
C_@@ PROGRAM_@@ FIND_@@ LAR@@ GE@@ ST_@@ ELEMENT_@@ ARRAY | def largest ( arr , n ) : NEW_LINE INDENT max = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
COUNT_@@ NUMB@@ ERS_@@ CAN_@@ CONSTRUC@@ TED_@@ USING_@@ TWO_@@ NUMB@@ ERS | def count@@ Num@@ s ( n , x , y ) : NEW_LINE INDENT arr = [ False for i in range ( n + 2 ) ] NEW_LINE if ( x <= n ) : NEW_LINE INDENT arr [ x ] = True NEW_LINE DEDENT if ( y <= n ) : NEW_LINE INDENT arr [ y ] = True NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( min ( x , y ) , n + 1 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT if ( i + x <= n ) : NEW_LINE INDENT arr [ i + x ] = True NEW_LINE DEDENT if ( i + y <= n ) : NEW_LINE INDENT arr [ i + y ] = True NEW_LINE DEDENT result = result + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
BU@@ BB@@ LE_@@ SORT_@@ 1 | def bu@@ bble@@ Sort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT swapped = False NEW_LINE for j in range ( 0 , n - i - 1 ) : NEW_LINE INDENT if arr [ j ] > arr [ j + 1 ] : NEW_LINE INDENT arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT if swapped == False : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
MAX@@ IM@@ UM@@ _S@@ UM_@@ 2_@@ X_@@ N_@@ GRID_@@ NO_@@ TWO_@@ ELEMEN@@ TS_@@ AD@@ J@@ AC@@ ENT | def max@@ Sum ( grid , n ) : NEW_LINE INDENT in@@ cl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) NEW_LINE ex@@ cl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ex@@ cl_@@ new = max ( ex@@ cl , in@@ cl ) NEW_LINE in@@ cl = ex@@ cl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) NEW_LINE ex@@ cl = ex@@ cl_@@ new NEW_LINE DEDENT return max ( ex@@ cl , in@@ cl ) NEW_LINE DEDENT
GC@@ D_@@ FAC@@ TOR@@ I@@ AL@@ S_@@ TWO_@@ NUMB@@ ERS | def g@@ cd@@ Of@@ Fac@@ tori@@ al ( m , n ) : NEW_LINE INDENT return math . factorial ( min ( m , n ) ) NEW_LINE DEDENT
AREA_@@ OF_@@ A@@ _SEC@@ TOR | def Sector@@ Area ( radius , angle ) : NEW_LINE INDENT pi = 22 / 7 NEW_LINE if angle >= 360 : NEW_LINE INDENT print ( " Angle ▁ not ▁ possible " ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT sector = ( pi * radius ** 2 ) * ( angle / 360 ) NEW_LINE print ( sector ) NEW_LINE return NEW_LINE DEDENT DEDENT
COUNT_@@ EV@@ EN_@@ LENGTH_@@ BIN@@ AR@@ Y@@ _SEQU@@ EN@@ CES_@@ WITH@@ _S@@ AME_@@ S@@ UM_@@ OF_@@ FIRST_@@ AND@@ _SECON@@ D_@@ HALF_@@ BITS_@@ 1 | def count@@ Seq ( n ) : NEW_LINE INDENT n@@ Cr = 1 NEW_LINE res = 1 NEW_LINE for r in range ( 1 , n + 1 ) : NEW_LINE INDENT n@@ Cr = ( n@@ Cr * ( n + 1 - r ) ) / r ; NEW_LINE res += n@@ Cr * n@@ Cr ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
LON@@ GE@@ ST_@@ EV@@ EN_@@ LENGTH@@ _SUB@@ STRING@@ _S@@ UM_@@ FIR@@ ST@@ _SECON@@ D_@@ HALF_@@ 1 | def find@@ Length ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE maxlen = 0 NEW_LINE Sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum [ i ] [ i ] = int ( string [ i ] ) NEW_LINE DEDENT for length in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( 0 , n - length + 1 ) : NEW_LINE INDENT j = i + length - 1 NEW_LINE k = length // 2 NEW_LINE Sum [ i ] [ j ] = ( Sum [ i ] [ j - k ] + Sum [ j - k + 1 ] [ j ] ) NEW_LINE if ( length % 2 == 0 and Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] and length > maxlen ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT
SW@@ AP_@@ ALL_@@ OD@@ D_@@ AND_@@ EV@@ EN_@@ BITS | def swap@@ Bits ( x ) : NEW_LINE INDENT even@@ _bits = x & 0x@@ AAAA@@ AAAA NEW_LINE od@@ d_@@ bits = x & 0x5@@ 5555@@ 555 NEW_LINE even@@ _bits >>= 1 NEW_LINE od@@ d_@@ bits <<= 1 NEW_LINE return ( even@@ _bits | od@@ d_@@ bits ) NEW_LINE DEDENT
SORT_@@ ARRAY_@@ WAVE_@@ FORM_@@ 2 | def sort@@ In@@ Wave ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT
FIND_@@ HAR@@ MON@@ IC_@@ ME@@ AN_@@ USING_@@ ARI@@ TH@@ ME@@ TIC_@@ ME@@ AN_@@ GEO@@ METRIC_@@ MEAN | def compute ( a , b ) : NEW_LINE INDENT AM = ( a + b ) / 2 NEW_LINE GM = math . sqrt ( a * b ) NEW_LINE H@@ M = ( GM * GM ) / AM NEW_LINE return H@@ M NEW_LINE DEDENT
COUNT_@@ BAL@@ AN@@ CED_@@ BINARY_@@ TRE@@ ES_@@ HEIGHT_@@ H | def count@@ BT ( h ) : NEW_LINE INDENT MOD = 100000000@@ 7 NEW_LINE dp = [ 0 for i in range ( h + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , h + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD NEW_LINE DEDENT return dp [ h ] NEW_LINE DEDENT
MINIMUM_@@ INSER@@ TIONS_@@ TO_@@ FORM_@@ A_@@ PA@@ LIN@@ DRO@@ ME_@@ WITH_@@ PER@@ MU@@ TA@@ TIONS_@@ ALLOWED | def min@@ Insertion ( tr1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 0 NEW_LINE count = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( count [ i ] % 2 == 1 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT if ( res == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return res - 1 NEW_LINE DEDENT DEDENT
SHUFF@@ LE_@@ A_@@ GI@@ V@@ EN_@@ ARRAY | def randomize ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT j = random . randint ( 0 , i + 1 ) NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT return arr NEW_LINE DEDENT
U@@ GL@@ Y_@@ NUMB@@ ERS | def getN@@ th@@ U@@ gl@@ y@@ No ( n ) : NEW_LINE INDENT ugly = [ 0 ] * n NEW_LINE ugly [ 0 ] = 1 NEW_LINE i2 = i3 = i@@ 5 = 0 NEW_LINE next_@@ multiple_@@ of_@@ 2 = 2 NEW_LINE next_@@ multiple_@@ of_@@ 3 = 3 NEW_LINE next_@@ multiple_@@ of_@@ 5 = 5 NEW_LINE for l in range ( 1 , n ) : NEW_LINE INDENT ugly [ l ] = min ( next_@@ multiple_@@ of_@@ 2 , next_@@ multiple_@@ of_@@ 3 , next_@@ multiple_@@ of_@@ 5 ) NEW_LINE if ugly [ l ] == next_@@ multiple_@@ of_@@ 2 : NEW_LINE INDENT i2 += 1 NEW_LINE next_@@ multiple_@@ of_@@ 2 = ugly [ i2 ] * 2 NEW_LINE DEDENT if ugly [ l ] == next_@@ multiple_@@ of_@@ 3 : NEW_LINE INDENT i3 += 1 NEW_LINE next_@@ multiple_@@ of_@@ 3 = ugly [ i3 ] * 3 NEW_LINE DEDENT if ugly [ l ] == next_@@ multiple_@@ of_@@ 5 : NEW_LINE INDENT i@@ 5 += 1 NEW_LINE next_@@ multiple_@@ of_@@ 5 = ugly [ i@@ 5 ] * 5 NEW_LINE DEDENT DEDENT return ugly [ - 1 ] NEW_LINE DEDENT
MINIMUM_@@ CO@@ ST_@@ CU@@ T_@@ BO@@ AR@@ D_S@@ QUAR@@ ES | def minimum@@ Cost@@ Of@@ Brea@@ king ( X , Y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE X . sort ( reverse = True ) NEW_LINE Y . sort ( reverse = True ) NEW_LINE h@@ z@@ n@@ tl = 1 ; vert = 1 NEW_LINE i = 0 ; j = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( X [ i ] > Y [ j ] ) : NEW_LINE INDENT res += X [ i ] * vert NEW_LINE h@@ z@@ n@@ tl += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += Y [ j ] * h@@ z@@ n@@ tl NEW_LINE vert += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE while ( i < m ) : NEW_LINE INDENT total += X [ i ] NEW_LINE i += 1 NEW_LINE DEDENT res += total * vert NEW_LINE total = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT total += Y [ j ] NEW_LINE j += 1 NEW_LINE DEDENT res += total * h@@ z@@ n@@ tl NEW_LINE return res NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 10_@@ 0_@@ 1_@@ KN@@ AP@@ S@@ ACK_@@ PRO@@ BLE@@ M_@@ 1 | def kn@@ ap@@ S@@ ack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT return K [ n ] [ W ] NEW_LINE DEDENT
STACK_@@ PER@@ MU@@ TA@@ TIONS_@@ CHECK_@@ IF_@@ AN_@@ ARRAY_@@ IS_@@ STACK_@@ PER@@ MU@@ TATION_@@ OF_@@ OTHER | def check@@ Stack@@ Permutation ( ip , op , n ) : NEW_LINE INDENT Input = Queue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Input . put ( ip [ i ] ) NEW_LINE DEDENT output = Queue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT output . put ( op [ i ] ) NEW_LINE DEDENT temp@@ Stack = [ ] NEW_LINE while ( not Input . empty ( ) ) : NEW_LINE INDENT ele = Input . queue [ 0 ] NEW_LINE Input . get ( ) NEW_LINE if ( ele == output . queue [ 0 ] ) : NEW_LINE INDENT output . get ( ) NEW_LINE while ( len ( temp@@ Stack ) != 0 ) : NEW_LINE INDENT if ( temp@@ Stack [ - 1 ] == output . queue [ 0 ] ) : NEW_LINE INDENT temp@@ Stack . pop ( ) NEW_LINE output . get ( ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT temp@@ Stack . append ( ele ) NEW_LINE DEDENT DEDENT return ( Input . empty ( ) and len ( temp@@ Stack ) == 0 ) NEW_LINE DEDENT
PRO@@ B@@ AB@@ ILITY_@@ THRE@@ E_@@ RAN@@ DOM@@ LY_@@ CH@@ OS@@ EN_@@ NUMB@@ ERS_@@ AP | def pro@@ cal ( n ) : NEW_LINE INDENT return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) NEW_LINE DEDENT
REMOVE_@@ BRAC@@ KE@@ TS_@@ AL@@ GE@@ BRA@@ IC_@@ STRING_@@ CONTAIN@@ ING_@@ OPER@@ ATORS | def simplify ( Str ) : NEW_LINE INDENT Len = len ( Str ) NEW_LINE res = [ None ] * Len NEW_LINE index = 0 NEW_LINE i = 0 NEW_LINE s = [ ] NEW_LINE s . append ( 0 ) NEW_LINE while ( i < Len ) : NEW_LINE INDENT if ( Str [ i ] == ' + ' ) : NEW_LINE INDENT if ( s [ - 1 ] == 1 ) : NEW_LINE INDENT res [ index ] = ' - ' NEW_LINE index += 1 NEW_LINE DEDENT if ( s [ - 1 ] == 0 ) : NEW_LINE INDENT res [ index ] = ' + ' NEW_LINE index += 1 NEW_LINE DEDENT DEDENT elif ( Str [ i ] == ' - ' ) : NEW_LINE INDENT if ( s [ - 1 ] == 1 ) : NEW_LINE INDENT res [ index ] = ' + ' NEW_LINE index += 1 NEW_LINE DEDENT elif ( s [ - 1 ] == 0 ) : NEW_LINE INDENT res [ index ] = ' - ' NEW_LINE index += 1 NEW_LINE DEDENT DEDENT elif ( Str [ i ] == ' ( ' and i > 0 ) : NEW_LINE INDENT if ( Str [ i - 1 ] == ' - ' ) : NEW_LINE INDENT x = 0 if ( s [ - 1 ] == 1 ) else 1 NEW_LINE s . append ( x ) NEW_LINE DEDENT elif ( Str [ i - 1 ] == ' + ' ) : NEW_LINE INDENT s . append ( s [ - 1 ] ) NEW_LINE DEDENT DEDENT elif ( Str [ i ] == ' ) ' ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ index ] = Str [ i ] NEW_LINE index += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
FIND_@@ NUMBER_@@ PER@@ F@@ ECT_@@ SQU@@ AR@@ ES_@@ TWO_@@ GI@@ V@@ EN_@@ NUMB@@ ERS | def Count@@ Squ@@ ares ( a , b ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT j = 1 ; NEW_LINE while j * j <= i : NEW_LINE INDENT if j * j == i : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
K_@@ NUMB@@ ERS_@@ DIFF@@ ER@@ ENCE_@@ MAXIMUM_@@ MINIMUM_@@ K_@@ NUMBER_@@ MINI@@ MIZ@@ ED | def min@@ Diff ( arr , n , k ) : NEW_LINE INDENT result = + 2147483647 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT result = int ( min ( result , arr [ i + k - 1 ] - arr [ i ] ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
CHECK_@@ LARGE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 13_@@ NOT | def check@@ Di@@ visibility ( num ) : NEW_LINE INDENT length = len ( num ) NEW_LINE if ( length == 1 and num [ 0 ] == '0' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( length % 3 == 1 ) : NEW_LINE INDENT num = str ( num ) + "@@ 00" NEW_LINE length += 2 NEW_LINE DEDENT elif ( length % 3 == 2 ) : NEW_LINE INDENT num = str ( num ) + "0" NEW_LINE length += 1 NEW_LINE DEDENT sum = 0 NEW_LINE p = 1 NEW_LINE for i in range ( length - 1 , - 1 , - 1 ) : NEW_LINE INDENT group = 0 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE i -= 1 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 NEW_LINE i -= 1 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 NEW_LINE sum = sum + group * p NEW_LINE p *= ( - 1 ) NEW_LINE DEDENT sum = abs ( sum ) NEW_LINE return ( sum % 13 == 0 ) NEW_LINE DEDENT
GI@@ V@@ EN_@@ N_@@ X_@@ N_S@@ QU@@ ARE_@@ MATRIX_@@ FIN@@ D_S@@ UM@@ _SUB@@ _S@@ QUAR@@ ES@@ _SIZE_@@ K_@@ X_@@ K | def print@@ Sum@@ Simple ( mat , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT for j in range ( n - k + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for p in range ( i , k + i ) : NEW_LINE INDENT for q in range ( j , k + j ) : NEW_LINE INDENT sum += mat [ p ] [ q ] NEW_LINE DEDENT DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
FIND_@@ THE_@@ POINT_@@ W@@ HER@@ E_@@ MAXIMUM_@@ INTER@@ VAL@@ S_@@ OVER@@ L@@ AP_@@ 1 | def max@@ Overlap ( start , end ) : NEW_LINE INDENT n = len ( start ) NEW_LINE max@@ a = max ( start ) NEW_LINE max@@ b = max ( end ) NEW_LINE max@@ c = max ( max@@ a , max@@ b ) NEW_LINE x = ( max@@ c + 2 ) * [ 0 ] NEW_LINE cur = 0 ; idx = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT x [ start [ i ] ] += 1 NEW_LINE x [ end [ i ] + 1 ] -= 1 NEW_LINE DEDENT maxy = - 1 NEW_LINE for i in range ( 0 , max@@ c + 1 ) : NEW_LINE INDENT cur += x [ i ] NEW_LINE if maxy < cur : NEW_LINE INDENT maxy = cur NEW_LINE idx = i NEW_LINE DEDENT DEDENT print ( " Maximum ▁ value ▁ is : ▁ { 0 : d } " . format ( maxy ) , " ▁ at ▁ position : ▁ { 0 : d } " . format ( idx ) ) NEW_LINE DEDENT
MAX@@ IM@@ UM@@ _SUB@@ SEQU@@ ENCE_@@ SUM@@ _SU@@ CH_@@ TH@@ AT_@@ NO_@@ THRE@@ E_@@ ARE_@@ CON@@ SEC@@ UTI@@ VE_@@ 1 | def max@@ Sum@@ WO@@ 3@@ Con@@ sec ( n ) : NEW_LINE INDENT if ( sum [ n ] != - 1 ) : NEW_LINE INDENT return sum [ n ] NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT sum [ n ] = 0 NEW_LINE return sum [ n ] NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT sum [ n ] = arr [ 0 ] NEW_LINE return sum [ n ] NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT sum [ n ] = arr [ 1 ] + arr [ 0 ] NEW_LINE return sum [ n ] NEW_LINE DEDENT sum [ n ] = max ( max ( max@@ Sum@@ WO@@ 3@@ Con@@ sec ( n - 1 ) , max@@ Sum@@ WO@@ 3@@ Con@@ sec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + max@@ Sum@@ WO@@ 3@@ Con@@ sec ( n - 3 ) ) NEW_LINE return sum [ n ] NEW_LINE DEDENT
C_@@ PROGRAM_@@ ADDI@@ TION_@@ TWO_@@ MATRI@@ CES | def add ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT
FIND_@@ MAXIMUM_@@ AVER@@ AGE_@@ SUB@@ ARRAY_@@ OF_@@ K_@@ LENGTH_@@ 1 | def find@@ Max@@ Average ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sum = arr [ 0 ] NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT max_@@ sum = sum NEW_LINE max_@@ end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = sum + arr [ i ] - arr [ i - k ] NEW_LINE if ( sum > max_@@ sum ) : NEW_LINE INDENT max_@@ sum = sum NEW_LINE max_@@ end = i NEW_LINE DEDENT DEDENT return max_@@ end - k + 1 NEW_LINE DEDENT
FIND_@@ CENTER_@@ CI@@ R@@ CLE_@@ USING_@@ END@@ POINT@@ S_@@ DI@@ AME@@ TER | def center ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( int ( ( x1 + x2 ) / 2 ) , end = " " ) NEW_LINE print ( " , " , int ( ( y1 + y2 ) / 2 ) ) NEW_LINE DEDENT
TOTAL_@@ NUMBER_OF_@@ NON_@@ DECRE@@ AS@@ ING_@@ NUMB@@ ERS_@@ WITH_@@ N_@@ DIGITS | def count@@ Non@@ Decre@@ asing ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 10 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = 1 NEW_LINE DEDENT for digit in range ( 10 ) : NEW_LINE INDENT for len in range ( 2 , n + 1 ) : NEW_LINE INDENT for x in range ( digit + 1 ) : NEW_LINE INDENT dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT count += dp [ i ] [ n ] NEW_LINE DEDENT return count NEW_LINE DEDENT
PRINT_@@ REVERSE_@@ STRING_@@ REMO@@ V@@ ING_@@ VO@@ WEL@@ S | def replace@@ Original ( s , n ) : NEW_LINE INDENT r = [ ' ▁ ' ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT r [ i ] = s [ n - 1 - i ] NEW_LINE if ( s [ i ] != ' a ' and s [ i ] != ' e ' and s [ i ] != ' i ' and s [ i ] != ' o ' and s [ i ] != ' u ' ) : NEW_LINE INDENT print ( r [ i ] , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
FIND_@@ ELEMEN@@ TS_@@ PRES@@ ENT_@@ FIRST_@@ ARRAY_@@ NOT_@@ SECON@@ D_@@ 1 | def find@@ Missing ( a , b , n , m ) : NEW_LINE INDENT s = dict ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT s [ b [ i ] ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] not in s . keys ( ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
COUNT_@@ STRING@@ S_@@ CAN_@@ FOR@@ MED_@@ USING_@@ B_@@ C_@@ GI@@ V@@ EN_@@ CONSTRA@@ INTS | def count@@ Str ( n , b@@ Count , c@@ Count ) : NEW_LINE INDENT if ( b@@ Count < 0 or c@@ Count < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( b@@ Count == 0 and c@@ Count == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = count@@ Str ( n - 1 , b@@ Count , c@@ Count ) NEW_LINE res += count@@ Str ( n - 1 , b@@ Count - 1 , c@@ Count ) NEW_LINE res += count@@ Str ( n - 1 , b@@ Count , c@@ Count - 1 ) NEW_LINE return res NEW_LINE DEDENT
GO@@ LD_@@ MINE_@@ PRO@@ BLE@@ M | def getMax@@ G@@ old ( gold , m , n ) : NEW_LINE INDENT gold@@ Table = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for col in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for row in range ( m ) : NEW_LINE INDENT if ( col == n - 1 ) : NEW_LINE INDENT right = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right = gold@@ Table [ row ] [ col + 1 ] NEW_LINE DEDENT if ( row == 0 or col == n - 1 ) : NEW_LINE INDENT right_@@ up = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_@@ up = gold@@ Table [ row - 1 ] [ col + 1 ] NEW_LINE DEDENT if ( row == m - 1 or col == n - 1 ) : NEW_LINE INDENT right_@@ down = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_@@ down = gold@@ Table [ row + 1 ] [ col + 1 ] NEW_LINE DEDENT gold@@ Table [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_@@ up , right_@@ down ) NEW_LINE DEDENT DEDENT res = gold@@ Table [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT res = max ( res , gold@@ Table [ i ] [ 0 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
COUNT_@@ WAY@@ S_@@ BUILD_@@ STRE@@ ET_@@ GI@@ V@@ EN_@@ CONSTRA@@ INTS | def count@@ W@@ ays ( n ) : NEW_LINE INDENT dp = [ [ 0 ] * ( n + 1 ) for i in range ( 2 ) ] NEW_LINE dp [ 0 ] [ 1 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] NEW_LINE dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ) NEW_LINE DEDENT return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] NEW_LINE DEDENT
RETURN_@@ A_@@ PA@@ IR_@@ WITH_@@ MAXIMUM_@@ PRODUCT_@@ IN_@@ ARRAY_@@ OF_@@ INTEG@@ ERS_@@ 1 | def max@@ Product ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " No ▁ pairs ▁ exists " ) NEW_LINE return NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT print ( arr [ 0 ] , " ▁ " , arr [ 1 ] ) NEW_LINE return NEW_LINE DEDENT pos@@ a = 0 NEW_LINE pos@@ b = 0 NEW_LINE neg@@ a = 0 NEW_LINE neg@@ b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > pos@@ a ) : NEW_LINE INDENT pos@@ b = pos@@ a NEW_LINE pos@@ a = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > pos@@ b ) : NEW_LINE INDENT pos@@ b = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( neg@@ a ) ) : NEW_LINE INDENT neg@@ b = neg@@ a NEW_LINE neg@@ a = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( neg@@ b ) ) : NEW_LINE INDENT neg@@ b = arr [ i ] NEW_LINE DEDENT DEDENT if ( neg@@ a * neg@@ b > pos@@ a * pos@@ b ) : NEW_LINE INDENT print ( " Max ▁ product ▁ pair ▁ is ▁ { " , neg@@ a , " , ▁ " , neg@@ b , " } " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Max ▁ product ▁ pair ▁ is ▁ { " , pos@@ a , " , ▁ " , pos@@ b , " } " ) NEW_LINE DEDENT DEDENT
POSITION_@@ OF_@@ RIGHT@@ MO@@ ST@@ _SET_@@ BIT | def getFirst@@ Set@@ Bit@@ Pos ( n ) : NEW_LINE INDENT return math . log2 ( n & - n ) + 1 NEW_LINE DEDENT
LON@@ GE@@ ST@@ _SUB@@ SEQU@@ ENCE_@@ W@@ HER@@ E_@@ EVER@@ Y_@@ CHARACTER_@@ AP@@ PE@@ AR@@ S_@@ AT_@@ LEA@@ ST_@@ K_@@ TIMES | def lon@@ gest@@ Sub@@ seq@@ With@@ K ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE freq = [ 0 ] * MAX_@@ CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] >= k ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
POSSI@@ BLE_@@ TO_@@ MAKE_@@ A_@@ DI@@ VISI@@ BLE_@@ BY_@@ 3_@@ NUMBER_@@ USING_@@ ALL_@@ DIG@@ IT@@ S_IN_@@ AN_@@ ARRAY | def is@@ Possible@@ To@@ Make@@ Di@@ visible ( arr , n ) : NEW_LINE INDENT remainder = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT remainder = ( remainder + arr [ i ] ) % 3 NEW_LINE DEDENT return ( remainder == 0 ) NEW_LINE DEDENT
ARE@@ A@@ _S@@ QU@@ ARE_@@ CIRCUM@@ SCRI@@ BED_@@ CIRC@@ LE | def find_@@ Area ( r ) : NEW_LINE INDENT return ( 2 * r * r ) NEW_LINE DEDENT
FIND_@@ MAXIMUM_@@ DOT_@@ PRODUCT_@@ TWO_@@ ARRAY@@ S_@@ INSER@@ TION_@@ 0@@ S | def Max@@ DotProduct ( A , B , m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT for j in range ( i , m + 1 , 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
FIND_@@ DISTIN@@ CT_@@ SUB@@ SET_@@ SUB@@ SEQU@@ ENCE_@@ SUM@@ S_@@ ARRAY | def print@@ Dist@@ Sum ( arr , n ) : NEW_LINE INDENT Sum = sum ( arr ) NEW_LINE dp = [ [ False for i in range ( Sum + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i - 1 ] ] = True NEW_LINE for j in range ( 1 , Sum + 1 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = True NEW_LINE dp [ i ] [ j + arr [ i - 1 ] ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( Sum + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ j ] == True ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
SP@@ LIT_@@ NUMERIC_@@ ALPH@@ AB@@ E@@ TIC_@@ AND@@ _SPECI@@ AL_@@ SYMBO@@ LS_@@ FROM_@@ A_@@ STRING | def split@@ String ( str ) : NEW_LINE INDENT alpha = " " NEW_LINE num = " " NEW_LINE special = " " NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . isdigit ( ) ) : NEW_LINE INDENT num = num + str [ i ] NEW_LINE DEDENT elif ( ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) or ( str [ i ] >= ' a ' and str [ i ] <= ' z ' ) ) : NEW_LINE INDENT alpha += str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT special += str [ i ] NEW_LINE DEDENT DEDENT print ( alpha ) NEW_LINE print ( num ) NEW_LINE print ( special ) NEW_LINE DEDENT
MAX@@ IM@@ UM@@ _S@@ UM_@@ ALTER@@ N@@ AT@@ ING@@ _SUB@@ SEQU@@ ENCE_@@ SUM | def max@@ Alternate@@ Sum ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT dec = [ 0 for i in range ( n + 1 ) ] NEW_LINE inc = [ 0 for i in range ( n + 1 ) ] NEW_LINE dec [ 0 ] = inc [ 0 ] = arr [ 0 ] NEW_LINE flag = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) NEW_LINE flag = 1 NEW_LINE DEDENT elif ( arr [ j ] < arr [ i ] and flag == 1 ) : NEW_LINE INDENT inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT result = - 214748364@@ 8 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( result < inc [ i ] ) : NEW_LINE INDENT result = inc [ i ] NEW_LINE DEDENT if ( result < dec [ i ] ) : NEW_LINE INDENT result = dec [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
FIND_@@ PA@@ IR_@@ MAXIMUM_@@ GC@@ D_@@ ARRAY | def find@@ Max@@ GC@@ D ( arr , n ) : NEW_LINE INDENT high = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT high = max ( high , arr [ i ] ) NEW_LINE i = i + 1 NEW_LINE DEDENT di@@ visors = [ 0 ] * ( high + 1 ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT j = 1 NEW_LINE while j <= math . sqrt ( arr [ i ] ) : NEW_LINE INDENT if ( arr [ i ] % j == 0 ) : NEW_LINE INDENT di@@ visors [ j ] = di@@ visors [ j ] + 1 NEW_LINE if ( j != arr [ i ] / j ) : NEW_LINE INDENT di@@ visors [ arr [ i ] / j ] = di@@ visors [ arr [ i ] / j ] NEW_LINE INDENT + 1 NEW_LINE DEDENT DEDENT DEDENT j = j + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT i = high NEW_LINE while i >= 1 : NEW_LINE INDENT if ( di@@ visors [ i ] > 1 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i - 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
FIND_@@ MINIMUM_@@ NUMBER_OF_@@ CO@@ INS_@@ TH@@ AT_@@ MAKE_@@ A_@@ CHANGE_@@ 1 | def min@@ Coins ( coins , m , V ) : NEW_LINE INDENT table = [ 0 for i in range ( V + 1 ) ] NEW_LINE table [ 0 ] = 0 NEW_LINE for i in range ( 1 , V + 1 ) : NEW_LINE INDENT table [ i ] = sys . maxsize NEW_LINE DEDENT for i in range ( 1 , V + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( coins [ j ] <= i ) : NEW_LINE INDENT sub_@@ res = table [ i - coins [ j ] ] NEW_LINE if ( sub_@@ res != sys . maxsize and sub_@@ res + 1 < table [ i ] ) : NEW_LINE INDENT table [ i ] = sub_@@ res + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return table [ V ] NEW_LINE DEDENT
S@@ UM_@@ NODE@@ S_@@ K_@@ TH_@@ LEVEL_@@ TREE_@@ RE@@ PRESEN@@ TED_@@ STRING | def sum@@ At@@ K@@ th@@ Level ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE sum = 0 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level += 1 NEW_LINE DEDENT elif ( tree [ i ] == ' ) ' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( level == k ) : NEW_LINE INDENT sum += ( ord ( tree [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 4_@@ LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ SEQUENCE | def l@@ cs ( X , Y , m , n ) : NEW_LINE INDENT if m == 0 or n == 0 : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif X [ m - 1 ] == Y [ n - 1 ] : NEW_LINE INDENT return 1 + l@@ cs ( X , Y , m - 1 , n - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return max ( l@@ cs ( X , Y , m , n - 1 ) , l@@ cs ( X , Y , m - 1 , n ) ) ; NEW_LINE DEDENT DEDENT
CHECK_@@ GI@@ VEN@@ _S@@ ENT@@ ENCE_@@ GI@@ VEN@@ _SET_@@ SIMPLE_@@ GR@@ AM@@ M@@ ER_@@ RULES | def check@@ Sentence ( string ) : NEW_LINE INDENT length = len ( string ) NEW_LINE if string [ 0 ] < ' A ' or string [ 0 ] > ' Z ' : NEW_LINE INDENT return False NEW_LINE DEDENT if string [ length - 1 ] != ' . ' : NEW_LINE INDENT return False NEW_LINE DEDENT prev_state = 0 NEW_LINE curr_@@ state = 0 NEW_LINE index = 1 NEW_LINE while ( string [ index ] ) : NEW_LINE INDENT if string [ index ] >= ' A ' and string [ index ] <= ' Z ' : NEW_LINE INDENT curr_@@ state = 0 NEW_LINE DEDENT elif string [ index ] == ' ▁ ' : NEW_LINE INDENT curr_@@ state = 1 NEW_LINE DEDENT elif string [ index ] >= ' a ' and string [ index ] <= ' z ' : NEW_LINE INDENT curr_@@ state = 2 NEW_LINE DEDENT elif string [ index ] == ' . ' : NEW_LINE INDENT curr_@@ state = 3 NEW_LINE DEDENT if prev_state == curr_@@ state and curr_@@ state != 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if prev_state == 2 and curr_@@ state == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if curr_@@ state == 3 and prev_state != 1 : NEW_LINE INDENT return True NEW_LINE DEDENT index += 1 NEW_LINE prev_state = curr_@@ state NEW_LINE DEDENT return False NEW_LINE DEDENT
CHECK_@@ DI@@ VISIBILITY_@@ LARGE_@@ NUMBER_@@ 999 | def is@@ Di@@ visible@@ 999 ( num ) : NEW_LINE INDENT n = len ( num ) ; NEW_LINE if ( n == 0 or num [ 0 ] == '0' ) : NEW_LINE INDENT return true NEW_LINE DEDENT if ( ( n % 3 ) == 1 ) : NEW_LINE INDENT num = "@@ 00" + num NEW_LINE DEDENT if ( ( n % 3 ) == 2 ) : NEW_LINE INDENT num = "0" + num NEW_LINE DEDENT g@@ Sum = 0 NEW_LINE for i in range ( 0 , n , 3 ) : NEW_LINE INDENT group = 0 NEW_LINE group += ( ord ( num [ i ] ) - 48 ) * 100 NEW_LINE group += ( ord ( num [ i + 1 ] ) - 48 ) * 10 NEW_LINE group += ( ord ( num [ i + 2 ] ) - 48 ) NEW_LINE g@@ Sum += group NEW_LINE DEDENT if ( g@@ Sum > 1000 ) : NEW_LINE INDENT num = str ( g@@ Sum ) NEW_LINE n = len ( num ) NEW_LINE g@@ Sum = is@@ Di@@ visible@@ 999 ( num ) NEW_LINE DEDENT return ( g@@ Sum == 999 ) NEW_LINE DEDENT
CHECK_@@ LARGE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 9_@@ NOT | def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE digit@@ Sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digit@@ Sum = digit@@ Sum + ( int ) ( st [ i ] ) NEW_LINE DEDENT return ( digit@@ Sum % 9 == 0 ) NEW_LINE DEDENT
NUMBER_OF_@@ BINARY_@@ TRE@@ ES_@@ FOR_@@ GI@@ V@@ EN_@@ PRE@@ ORDER@@ _SEQU@@ ENCE_@@ LENGTH | def count@@ Trees ( n ) : NEW_LINE INDENT BT = [ 0 ] * ( n + 1 ) NEW_LINE BT [ 0 ] = BT [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT BT [ i ] += BT [ j ] * BT [ i - j - 1 ] NEW_LINE DEDENT DEDENT return BT [ n ] NEW_LINE DEDENT
PROGR@@ AM@@ _SW@@ AP_@@ UPPER_@@ DIAG@@ ON@@ AL_@@ ELEMEN@@ TS_@@ LOWER_@@ DIAG@@ ON@@ AL_@@ ELEMEN@@ TS_@@ MATRIX | def swap@@ Upper@@ ToLower ( arr ) : NEW_LINE INDENT n = 4 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT temp = arr [ i ] [ j ] ; NEW_LINE arr [ i ] [ j ] = arr [ j ] [ i ] ; NEW_LINE arr [ j ] [ i ] = temp ; NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( " ▁ " ) ; NEW_LINE DEDENT DEDENT
FIN@@ D_S@@ UM_@@ MODUL@@ O_@@ K_@@ FIRST_@@ N_@@ N@@ ATUR@@ AL_@@ NUMBER_@@ 1 | def find@@ Sum ( N , K ) : NEW_LINE INDENT ans = 0 ; NEW_LINE y = N / K ; NEW_LINE x = N % K ; NEW_LINE ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT
WAY@@ S_@@ REMOVE_@@ ONE_@@ ELEMENT_@@ BINARY_@@ STRING_@@ X@@ OR_@@ BE@@ CO@@ ME@@ S_@@ ZERO | def xor@@ Zero ( str ) : NEW_LINE INDENT one_@@ count = 0 NEW_LINE zero_@@ count = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT one_@@ count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero_@@ count += 1 NEW_LINE DEDENT DEDENT if ( one_@@ count % 2 == 0 ) : NEW_LINE INDENT return zero_@@ count NEW_LINE DEDENT return one_@@ count NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 7_@@ CO@@ IN_@@ CHANGE | def count ( S , m , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( m <= 0 and n >= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; NEW_LINE DEDENT
MIN@@ IM@@ UM@@ _S@@ UM@@ _SUB@@ SEQU@@ ENCE_@@ LEA@@ ST_@@ ONE_@@ EVER@@ Y_@@ FOUR_@@ CON@@ SEC@@ UTI@@ VE_@@ ELEMEN@@ TS_@@ PIC@@ KED | def min@@ Sum ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return min ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return min ( arr [ 0 ] , min ( arr [ 1 ] , arr [ 2 ] ) ) NEW_LINE DEDENT if ( n == 4 ) : NEW_LINE INDENT return min ( min ( arr [ 0 ] , arr [ 1 ] ) , min ( arr [ 2 ] , arr [ 3 ] ) ) NEW_LINE DEDENT dp [ 0 ] = arr [ 0 ] NEW_LINE dp [ 1 ] = arr [ 1 ] NEW_LINE dp [ 2 ] = arr [ 2 ] NEW_LINE dp [ 3 ] = arr [ 3 ] NEW_LINE for i in range ( 4 , n ) : NEW_LINE INDENT dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp [ i - 2 ] ) , min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) NEW_LINE DEDENT return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) NEW_LINE DEDENT
MAXIMUM_@@ PATH@@ _S@@ UM_@@ TRI@@ ANGLE | def max@@ Path@@ Sum ( tri , m , n ) : NEW_LINE INDENT for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT return tri [ 0 ] [ 0 ] NEW_LINE DEDENT
FIND_@@ THRE@@ E_@@ ELEMENT_@@ FROM_@@ DIFF@@ ER@@ ENT_@@ THRE@@ E_@@ ARRAY@@ S@@ _SU@@ CH_@@ TH@@ AT_@@ TH@@ AT_@@ A_@@ B_@@ C_@@ K | def find@@ Trip@@ let ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : NEW_LINE INDENT for i in range ( 0 , n1 ) : NEW_LINE INDENT for j in range ( 0 , n2 ) : NEW_LINE INDENT for k in range ( 0 , n3 ) : NEW_LINE INDENT if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
TA@@ IL_@@ RECUR@@ SION_@@ FI@@ BON@@ AC@@ CI | def fi@@ b ( n , a = 0 , b = 1 ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return b NEW_LINE DEDENT return fi@@ b ( n - 1 , b , a + b ) ; NEW_LINE DEDENT
PROGRAM_@@ TO_@@ CHECK_@@ IF_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ IS_@@ L@@ UC@@ K@@ Y_@@ ALL_@@ DIG@@ IT@@ S_@@ ARE_@@ DIFF@@ ER@@ ENT | def is@@ Lu@@ ck@@ y ( n ) : NEW_LINE INDENT ar = [ 0 ] * 10 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = math . floor ( n % 10 ) NEW_LINE if ( ar [ digit ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ar [ digit ] = 1 NEW_LINE n = n / 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
GI@@ V@@ EN_@@ N_@@ X_@@ N_S@@ QU@@ ARE_@@ MATRIX_@@ FIN@@ D_S@@ UM@@ _SUB@@ _S@@ QUAR@@ ES@@ _SIZE_@@ K_@@ X_@@ K_@@ 1 | def print@@ Sum@@ Tri@@ ck@@ y ( mat , k ) : NEW_LINE INDENT global n NEW_LINE if k > n : NEW_LINE INDENT return NEW_LINE DEDENT strip@@ Sum = [ [ None ] * n for i in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT Sum += mat [ i ] [ j ] NEW_LINE DEDENT strip@@ Sum [ 0 ] [ j ] = Sum NEW_LINE for i in range ( 1 , n - k + 1 ) : NEW_LINE INDENT Sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) NEW_LINE strip@@ Sum [ i ] [ j ] = Sum NEW_LINE DEDENT DEDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT Sum = 0 NEW_LINE for j in range ( k ) : NEW_LINE INDENT Sum += strip@@ Sum [ i ] [ j ] NEW_LINE DEDENT print ( Sum , end = " ▁ " ) NEW_LINE for j in range ( 1 , n - k + 1 ) : NEW_LINE INDENT Sum += ( strip@@ Sum [ i ] [ j + k - 1 ] - strip@@ Sum [ i ] [ j - 1 ] ) NEW_LINE print ( Sum , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
SCHEDUL@@ E_@@ ELE@@ V@@ ATOR_@@ TO_@@ RED@@ UCE_@@ THE_@@ TOTAL_@@ TIME_@@ TA@@ KEN | def min@@ Time ( n , k , a ) : NEW_LINE INDENT a . sort ( reverse = True ) ; NEW_LINE min@@ Time = 0 ; NEW_LINE for i in range ( 0 , n , k ) : NEW_LINE INDENT min@@ Time += ( 2 * a [ i ] ) ; NEW_LINE DEDENT return min@@ Time ; NEW_LINE DEDENT
OD@@ D_@@ EV@@ EN@@ _S@@ ORT_@@ B@@ RICK@@ _S@@ ORT | def odd@@ Even@@ Sort ( arr , n ) : NEW_LINE INDENT is@@ Sorted = 0 NEW_LINE while is@@ Sorted == 0 : NEW_LINE INDENT is@@ Sorted = 1 NEW_LINE temp = 0 NEW_LINE for i in range ( 1 , n - 1 , 2 ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE is@@ Sorted = 0 NEW_LINE DEDENT DEDENT for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE is@@ Sorted = 0 NEW_LINE DEDENT DEDENT DEDENT return NEW_LINE DEDENT
RETURN_@@ MAXIMUM_@@ OC@@ CURR@@ ING_@@ CHARACTER_@@ IN_@@ THE_@@ INPUT_@@ STRING | def getMax@@ Occur@@ ing@@ Char ( str ) : NEW_LINE INDENT count = [ 0 ] * ASCII@@ _SIZE NEW_LINE max = - 1 NEW_LINE c = ' ' NEW_LINE for i in str : NEW_LINE INDENT count [ ord ( i ) ] += 1 ; NEW_LINE DEDENT for i in str : NEW_LINE INDENT if max < count [ ord ( i ) ] : NEW_LINE INDENT max = count [ ord ( i ) ] NEW_LINE c = i NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT
COUNT_@@ NUMBER_@@ PAIR@@ S_@@ N_@@ B_@@ N_@@ GC@@ D_@@ B_@@ B | def Count@@ Pairs ( n ) : NEW_LINE INDENT k = n NEW_LINE im@@ in = 1 NEW_LINE ans = 0 NEW_LINE while ( im@@ in <= n ) : NEW_LINE INDENT imax = n / k NEW_LINE ans += k * ( imax - im@@ in + 1 ) NEW_LINE im@@ in = imax + 1 NEW_LINE k = n / im@@ in NEW_LINE DEDENT return ans NEW_LINE DEDENT
K_@@ TH_@@ DISTIN@@ CT_@@ OR_@@ NON_@@ REPE@@ ATING_@@ ELEMENT_@@ IN_@@ AN_@@ ARRAY_@@ 1 | def print@@ K@@ Distin@@ ct ( arr , size , K@@ th@@ Index ) : NEW_LINE INDENT dict = { } NEW_LINE vect = [ ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] in dict ) : NEW_LINE INDENT dict [ arr [ i ] ] = dict [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dict [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if ( dict [ arr [ i ] ] > 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT K@@ th@@ Index = K@@ th@@ Index - 1 NEW_LINE DEDENT if ( K@@ th@@ Index == 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
GENERATE_@@ BINARY_@@ PER@@ MU@@ TA@@ TIONS_@@ 1@@ S_@@ 0@@ S_@@ EVER@@ Y_@@ POINT_@@ PER@@ MU@@ TA@@ TIONS | def generate ( ones , zeroes , str , len1 ) : NEW_LINE INDENT if ( len1 == len ( str ) ) : NEW_LINE INDENT print ( str , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT generate ( ones + 1 , zeroes , str + "1" , len1 ) NEW_LINE if ( ones > zeroes ) : NEW_LINE INDENT generate ( ones , zeroes + 1 , str + "0" , len1 ) NEW_LINE DEDENT DEDENT
SEARCH_@@ INSERT_@@ AND_@@ DELETE_@@ IN_@@ AN_@@ UN@@ SOR@@ TED_@@ ARRAY | def findElement ( arr , n , key ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == key ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
LC@@ S_@@ LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ SEQU@@ ENCE_@@ THRE@@ E_@@ STRINGS | def l@@ cs@@ Of@@ 3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ [ 0 for i in range ( o + 1 ) ] for j in range ( n + 1 ) ] for k in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( o + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 or k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT
MAX@@ IM@@ UM@@ _S@@ UM@@ _SUB@@ ARRAY_@@ REMO@@ V@@ ING_@@ ONE_@@ ELEMENT | def max@@ Sum@@ Sub@@ array@@ Remo@@ ving@@ One@@ E@@ le ( arr , n ) : NEW_LINE INDENT fw = [ 0 for k in range ( n ) ] NEW_LINE bw = [ 0 for k in range ( n ) ] NEW_LINE cur_@@ max , max_@@ so@@ _f@@ ar = arr [ 0 ] , arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cur_@@ max = max ( arr [ i ] , cur_@@ max + arr [ i ] ) NEW_LINE max_@@ so@@ _f@@ ar = max ( max_@@ so@@ _f@@ ar , cur_@@ max ) NEW_LINE fw [ i ] = cur_@@ max NEW_LINE DEDENT cur_@@ max = max_@@ so@@ _f@@ ar = bw [ n - 1 ] = arr [ n - 1 ] NEW_LINE i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT cur_@@ max = max ( arr [ i ] , cur_@@ max + arr [ i ] ) NEW_LINE max_@@ so@@ _f@@ ar = max ( max_@@ so@@ _f@@ ar , cur_@@ max ) NEW_LINE bw [ i ] = cur_@@ max NEW_LINE i -= 1 NEW_LINE DEDENT f@@ ans = max_@@ so@@ _f@@ ar NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT f@@ ans = max ( f@@ ans , fw [ i - 1 ] + bw [ i + 1 ] ) NEW_LINE DEDENT return f@@ ans NEW_LINE DEDENT
COUNT_@@ NUMBER_@@ WAY@@ S_@@ TILE_@@ FLO@@ OR@@ _SIZE_@@ N_@@ X_@@ M_@@ USING_@@ 1_@@ X_@@ M@@ _SIZE_@@ TI@@ LES | def count@@ W@@ ays ( n , m ) : NEW_LINE INDENT count = [ ] NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT count . append ( 0 ) NEW_LINE DEDENT count [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i > m ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + count [ i - m ] NEW_LINE DEDENT elif ( i < m ) : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 2 NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT
MIDD@@ LE_@@ OF_@@ THRE@@ E_@@ USING_@@ MINIMUM_@@ COMP@@ ARIS@@ ONS | def middle@@ Of@@ Three ( a , b , c ) : NEW_LINE INDENT if ( ( a < b and b < c ) or ( c < b and b < a ) ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT if ( ( b < a and a < c ) or ( c < a and a < b ) ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT else : NEW_LINE INDENT return c NEW_LINE DEDENT DEDENT
LON@@ GE@@ ST_@@ COMMON_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQU@@ ENCE_@@ LC@@ S_@@ LI@@ S | def LC@@ IS ( ar@@ r1 , n , ar@@ r2 , m ) : NEW_LINE INDENT table = [ 0 ] * m NEW_LINE for j in range ( m ) : NEW_LINE INDENT table [ j ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT current = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( ar@@ r1 [ i ] == ar@@ r2 [ j ] ) : NEW_LINE INDENT if ( current + 1 > table [ j ] ) : NEW_LINE INDENT table [ j ] = current + 1 NEW_LINE DEDENT DEDENT if ( ar@@ r1 [ i ] > ar@@ r2 [ j ] ) : NEW_LINE INDENT if ( table [ j ] > current ) : NEW_LINE INDENT current = table [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT result = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( table [ i ] > result ) : NEW_LINE INDENT result = table [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
MAX@@ IM@@ UM@@ _SUB@@ SEQU@@ ENCE_@@ SUM@@ _SU@@ CH_@@ TH@@ AT_@@ NO_@@ THRE@@ E_@@ ARE_@@ CON@@ SEC@@ UTI@@ VE | def max@@ Sum@@ WO@@ 3@@ Con@@ sec ( arr , n ) : NEW_LINE INDENT sum = [ 0 for k in range ( n ) ] NEW_LINE if n >= 1 : NEW_LINE INDENT sum [ 0 ] = arr [ 0 ] NEW_LINE DEDENT if n >= 2 : NEW_LINE INDENT sum [ 1 ] = arr [ 0 ] + arr [ 1 ] NEW_LINE DEDENT if n > 2 : NEW_LINE INDENT sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) NEW_LINE DEDENT for i in range ( 3 , n ) : NEW_LINE INDENT sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) NEW_LINE DEDENT return sum [ n - 1 ] NEW_LINE DEDENT
E@@ UL@@ ERI@@ AN_@@ NUMBER_@@ 1 | def e@@ ul@@ eri@@ an ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , m + 1 ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
DOUBLE_@@ FAC@@ TOR@@ I@@ AL | def double@@ factorial ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return n * double@@ factorial ( n - 2 ) ; NEW_LINE DEDENT
RE@@ AR@@ RANGE_@@ POSITIVE_@@ AND_@@ NEGATIVE_@@ NUMB@@ ERS_@@ PUBLI@@ SH | def re@@ arrange ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] < 0 ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT pos , neg = i + 1 , 0 NEW_LINE while ( pos < n and neg < pos and arr [ neg ] < 0 ) : NEW_LINE INDENT arr [ neg ] , arr [ pos ] = arr [ pos ] , arr [ neg ] NEW_LINE pos += 1 NEW_LINE neg += 2 NEW_LINE DEDENT DEDENT
MAXI@@ MI@@ ZE_@@ ARRA@@ Y_S@@ UN_@@ AFTER_@@ K_@@ NEG@@ ATION_@@ OPER@@ ATIONS | def maximum@@ Sum ( arr , n , k ) : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT min = + 2147483647 NEW_LINE index = - 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] < min ) : NEW_LINE INDENT min = arr [ j ] NEW_LINE index = j NEW_LINE DEDENT DEDENT if ( min == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT arr [ index ] = - arr [ index ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
MAX@@ IM@@ UM@@ _S@@ UM_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQU@@ ENCE_@@ FROM_@@ A_@@ PREFIX_@@ AND_@@ A_@@ GI@@ V@@ EN_@@ ELEMENT_@@ AFTER_@@ PREFIX_@@ IS_@@ MUST | def pre_@@ compute ( a , n , index , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > a [ 0 ] : NEW_LINE INDENT dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = a [ i ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ j ] > a [ i ] and j > i : NEW_LINE INDENT if dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dp [ index ] [ k ] NEW_LINE DEDENT
FUNCTION_@@ COPY_@@ STRING_@@ ITER@@ ATI@@ VE_@@ RECUR@@ SIVE | def my@@ Copy ( s1 , s2 ) : NEW_LINE INDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT s2 [ i ] = s1 [ i ] ; NEW_LINE DEDENT DEDENT
GI@@ V@@ EN_@@ TWO_@@ STRING@@ S_@@ FIND_@@ FIRST_@@ STRING@@ _SUB@@ SEQU@@ ENCE_@@ SECON@@ D_@@ 1 | def isSub@@ Sequence ( str1 , str2 , m , n ) : NEW_LINE INDENT j = 0 NEW_LINE i = 0 NEW_LINE while j < m and i < n : NEW_LINE INDENT if str1 [ j ] == str2 [ i ] : NEW_LINE INDENT j = j + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return j == m NEW_LINE DEDENT
FIND_@@ UNIT_@@ DIG@@ IT_@@ X_@@ RAI@@ SED_@@ POWER_@@ Y_@@ 1 | def unit@@ number ( x , y ) : NEW_LINE INDENT x = x % 10 NEW_LINE if y != 0 : NEW_LINE INDENT y = y % 4 + 4 NEW_LINE DEDENT return ( ( ( int ) ( math . pow ( x , y ) ) ) % 10 ) NEW_LINE DEDENT
PROGRAM_@@ NEXT_@@ FI@@ T_@@ ALGORITH@@ M_@@ MEMORY_@@ MAN@@ A@@ GEMENT | def Next@@ Fit ( blockSize , m , process@@ Size , n ) : NEW_LINE INDENT allocation = [ - 1 ] * n NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while j < m : NEW_LINE INDENT if blockSize [ j ] >= process@@ Size [ i ] : NEW_LINE INDENT allocation [ i ] = j NEW_LINE blockSize [ j ] -= process@@ Size [ i ] NEW_LINE break NEW_LINE DEDENT j = ( j + 1 ) % m NEW_LINE DEDENT DEDENT print ( " Process ▁ No . ▁ Process ▁ Size ▁ Block ▁ no . " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( i + 1 , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , process@@ Size [ i ] , end = " ▁ ▁ ▁ ▁ ▁ " ) NEW_LINE if allocation [ i ] != - 1 : NEW_LINE INDENT print ( allocation [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT DEDENT
NO@@ BLE_@@ INTEG@@ ERS_@@ IN_@@ AN_@@ ARRAY_@@ COUNT_@@ OF_@@ GREATER_@@ ELEMEN@@ TS_@@ IS_@@ EQUAL_@@ TO_@@ VALUE | def no@@ ble@@ Integer ( arr , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == arr [ i ] ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
MINIMUM_@@ FLI@@ P_@@ REQUIRED_@@ MAKE_@@ BINARY_@@ MATRIX_@@ SYM@@ METRIC | def minimum@@ flip ( mat , n ) : NEW_LINE INDENT transpose = [ [ 0 ] * n ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT transpose [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE DEDENT DEDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if transpose [ i ] [ j ] != mat [ i ] [ j ] : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( flip / 2 ) NEW_LINE DEDENT
SEG@@ REG@@ ATE_@@ EV@@ EN_@@ OD@@ D_@@ NUMBER@@ S@@ _SET_@@ 3 | def array@@ Even@@ And@@ Odd ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE j = 0 NEW_LINE while ( j != n ) : NEW_LINE INDENT if ( arr [ j ] % 2 == 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT for i in arr : NEW_LINE INDENT print ( str ( i ) + " ▁ " , end = ' ' ) NEW_LINE DEDENT DEDENT
DFS_@@ N_@@ ARY_@@ TREE_@@ AC@@ Y@@ CLI@@ C_@@ GRAPH_@@ RE@@ PRESEN@@ TED_@@ AD@@ J@@ AC@@ ENCY_@@ LIST | def dfs ( List , node , arri@@ val ) : NEW_LINE INDENT print ( node ) NEW_LINE for i in range ( len ( List [ node ] ) ) : NEW_LINE INDENT if ( List [ node ] [ i ] != arri@@ val ) : NEW_LINE INDENT dfs ( List , List [ node ] [ i ] , node ) NEW_LINE DEDENT DEDENT DEDENT
HO@@ W_@@ TO_@@ TURN_@@ OFF_@@ A_@@ PARTIC@@ ULAR_@@ BIT_@@ IN_@@ A_@@ NUMBER | def turn@@ Off@@ K ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n & ~ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT
NUMBER@@ _SUB@@ STRING@@ S_@@ DI@@ VISI@@ BLE_@@ 8_@@ NOT_@@ 3 | def count ( s , Len ) : NEW_LINE INDENT global MAX NEW_LINE cur = 0 NEW_LINE dig = 0 NEW_LINE Sum = [ 0 ] * MAX NEW_LINE dp = [ [ 0 , 0 , 0 ] for i in range ( MAX ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , Len + 1 ) : NEW_LINE INDENT dig = int ( s [ i - 1 ] ) - 48 NEW_LINE cur += dig NEW_LINE cur %= 3 NEW_LINE Sum [ i ] = cur NEW_LINE dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] NEW_LINE dp [ i ] [ Sum [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE d@@ prev = 0 NEW_LINE value = 0 NEW_LINE d@@ pre@@ v2 = 0 NEW_LINE for i in range ( 1 , Len + 1 ) : NEW_LINE INDENT dig = int ( s [ i - 1 ] ) - 48 NEW_LINE if dig == 8 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if i - 2 >= 0 : NEW_LINE INDENT d@@ prev = int ( s [ i - 2 ] ) - 48 NEW_LINE value = d@@ prev * 10 + dig NEW_LINE if ( value % 8 == 0 ) and ( value % 3 != 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if i - 3 >= 0 : NEW_LINE INDENT d@@ pre@@ v2 = int ( s [ i - 3 ] ) - 48 NEW_LINE d@@ prev = int ( s [ i - 2 ] ) - 48 NEW_LINE value = ( d@@ pre@@ v2 * 100 + d@@ prev * 10 + dig ) NEW_LINE if value % 8 != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT ans += ( i - 2 ) NEW_LINE ans -= ( dp [ i - 3 ] [ Sum [ i ] ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
ADD_@@ 1_@@ TO_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ 1 | def add@@ One ( x ) : NEW_LINE INDENT return ( - ( ~ x ) ) ; NEW_LINE DEDENT
CHECK_@@ STRING_@@ FOL@@ LO@@ WS_@@ AN@@ BN_@@ PATTERN_@@ NOT | def is@@ An@@ B@@ n ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] != ' a ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i * 2 != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT for j in range ( i , n ) : NEW_LINE INDENT if ( str [ j ] != ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
FIND_@@ FIRST_@@ REPE@@ ATING_@@ ELEMENT_@@ ARRAY_@@ INTEG@@ ERS | def print@@ First@@ Repe@@ ating ( arr , n ) : NEW_LINE INDENT Min = - 1 NEW_LINE my@@ set = dict ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] in my@@ set . keys ( ) : NEW_LINE INDENT Min = i NEW_LINE DEDENT else : NEW_LINE INDENT my@@ set [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT if ( Min != - 1 ) : NEW_LINE INDENT print ( " The ▁ first ▁ repe@@ ating ▁ element ▁ is " , arr [ Min ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " There ▁ are ▁ no ▁ repe@@ ating ▁ elements " ) NEW_LINE DEDENT DEDENT
CO@@ ST_@@ BAL@@ ANCE_@@ PAR@@ AN@@ THE@@ SES | def cost@@ To@@ Balance ( s ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT ans = 0 NEW_LINE o = 0 NEW_LINE c = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT o += 1 NEW_LINE DEDENT if ( s [ i ] == ' ) ' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( o != c ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = [ 0 for i in range ( len ( s ) ) ] NEW_LINE if ( s [ 0 ] == ' ( ' ) : NEW_LINE INDENT a [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ 0 ] = - 1 NEW_LINE DEDENT if ( a [ 0 ] < 0 ) : NEW_LINE INDENT ans += abs ( a [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] = a [ i - 1 ] - 1 NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT ans += abs ( a [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
CO@@ IN_@@ GAME_@@ WIN@@ NER_@@ EVER@@ Y_@@ PLAYER_@@ THRE@@ E_@@ CHOICES | def find@@ Win@@ ner ( x , y , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = False NEW_LINE dp [ 1 ] = True NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i - 1 >= 0 and not dp [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] = True NEW_LINE DEDENT elif ( i - x >= 0 and not dp [ i - x ] ) : NEW_LINE INDENT dp [ i ] = True NEW_LINE DEDENT elif ( i - y >= 0 and not dp [ i - y ] ) : NEW_LINE INDENT dp [ i ] = True NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = False NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
SEQU@@ EN@@ CES_@@ GI@@ V@@ EN_@@ LENGTH_@@ EVER@@ Y_@@ ELEMENT_@@ EQUAL_@@ TWI@@ CE_@@ PREVI@@ OUS | def getTotal@@ NumberOf@@ Sequences ( m , n ) : NEW_LINE INDENT if m < n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = ( getTotal@@ NumberOf@@ Sequences ( m - 1 , n ) + getTotal@@ NumberOf@@ Sequences ( m // 2 , n - 1 ) ) NEW_LINE return res NEW_LINE DEDENT
FIND_@@ DUPLIC@@ ATE@@ S_@@ GI@@ V@@ EN_@@ ARRAY_@@ ELEMEN@@ TS_@@ NOT_@@ LIMITED_@@ RANGE | def print@@ Duplicates ( arr ) : NEW_LINE INDENT dict = { } NEW_LINE for ele in arr : NEW_LINE INDENT try : NEW_LINE INDENT dict [ ele ] += 1 NEW_LINE DEDENT except : NEW_LINE INDENT dict [ ele ] = 1 NEW_LINE DEDENT DEDENT for item in dict : NEW_LINE INDENT if ( dict [ item ] > 1 ) : NEW_LINE INDENT print ( item , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( " \n " ) NEW_LINE DEDENT
LON@@ GE@@ ST_@@ REPE@@ AT@@ ING@@ _SUB@@ SEQU@@ ENCE_@@ 1 | def find@@ Lon@@ gest@@ Repe@@ ating@@ Sub@@ Seq ( X , m , n ) : NEW_LINE INDENT if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT dp [ m ] [ n ] = 0 NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT if ( X [ m - 1 ] == X [ n - 1 ] and m != n ) : NEW_LINE INDENT dp [ m ] [ n ] = find@@ Lon@@ gest@@ Repe@@ ating@@ Sub@@ Seq ( X , m - 1 , n - 1 ) + 1 NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT dp [ m ] [ n ] = max ( find@@ Lon@@ gest@@ Repe@@ ating@@ Sub@@ Seq ( X , m , n - 1 ) , find@@ Lon@@ gest@@ Repe@@ ating@@ Sub@@ Seq ( X , m - 1 , n ) ) NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT
COUNT_@@ OF_@@ N_@@ DIG@@ IT_@@ NUMB@@ ERS_@@ WHO@@ SE_@@ S@@ UM_@@ OF_@@ DIG@@ IT@@ S_@@ EQUAL@@ S_TO_@@ GI@@ VEN@@ _S@@ UM | def find@@ Count ( n , sum ) : NEW_LINE INDENT start = math . pow ( 10 , n - 1 ) ; NEW_LINE end = math . pow ( 10 , n ) - 1 ; NEW_LINE count = 0 ; NEW_LINE i = start ; NEW_LINE while ( i <= end ) : NEW_LINE INDENT cur = 0 ; NEW_LINE temp = i ; NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT cur += temp % 10 ; NEW_LINE temp = temp // 10 ; NEW_LINE DEDENT if ( cur == sum ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE i += 9 ; NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 ; NEW_LINE DEDENT DEDENT print ( count ) ; NEW_LINE DEDENT
MINIMUM_@@ CO@@ ST_@@ CONNECT_@@ WE@@ I@@ GH@@ TED_@@ NODE@@ S_@@ RE@@ PRESEN@@ TED_@@ ARRAY | def minimum_@@ cost ( a , n ) : NEW_LINE INDENT mn = sys . maxsize NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mn = min ( a [ i ] , mn ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT return mn * ( sum - mn ) NEW_LINE DEDENT
FIND_@@ ALL_@@ DI@@ VI@@ SOR@@ S_@@ OF_@@ A_@@ N@@ ATUR@@ AL_@@ NUMBER@@ _SET_@@ 2 | def print@@ Di@@ visors ( n ) : NEW_LINE INDENT list = [ ] NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE list . append ( int ( n / i ) ) NEW_LINE DEDENT DEDENT DEDENT for i in list [ : : - 1 ] : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
SQU@@ AR@@ ES_@@ OF_@@ MATRIX_@@ DIAG@@ ON@@ AL_@@ ELEMEN@@ TS_@@ 1 | def diag@@ onal@@ square ( mat , row , column ) : NEW_LINE INDENT print ( " Diagonal ▁ one ▁ : ▁ " , end = " " ) NEW_LINE for i in range ( 0 , row ) : NEW_LINE INDENT print ( mat [ i ] [ i ] * mat [ i ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " \n \n Diagonal ▁ two ▁ : ▁ " , end = " " ) NEW_LINE for i in range ( 0 , row ) : NEW_LINE INDENT print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
C_@@ PROGRAM_@@ FIND_@@ AREA_@@ TRIANGLE_@@ 1 | def polygon@@ Area ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE j = i NEW_LINE DEDENT return abs ( area // 2.0 ) NEW_LINE DEDENT
RANGE_@@ QUER@@ I@@ ES_@@ FOR_@@ FREQU@@ ENCI@@ ES_@@ OF_@@ ARRAY_@@ ELEMENTS | def find@@ Frequency ( arr , n , left , right , element ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( left - 1 , right ) : NEW_LINE INDENT if ( arr [ i ] == element ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
SERI@@ ES_@@ LAR@@ GE@@ ST_@@ G@@ CD@@ _S@@ UM_@@ EQUAL@@ S_@@ N | def print_@@ sequence ( n , k ) : NEW_LINE INDENT b = int ( n / ( k * ( k + 1 ) / 2 ) ) ; NEW_LINE if b == 0 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT r = 1 ; NEW_LINE x = 1 NEW_LINE while x ** 2 <= n : NEW_LINE INDENT if n % x != 0 : NEW_LINE INDENT continue ; NEW_LINE DEDENT elif x <= b and x > r : NEW_LINE INDENT r = x NEW_LINE DEDENT elif n / x <= b and n / x > r : NEW_LINE INDENT r = n / x NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < k : NEW_LINE INDENT print ( r * i , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE DEDENT last_@@ term = n - ( r * ( k * ( k - 1 ) / 2 ) ) NEW_LINE print ( last_@@ term ) NEW_LINE DEDENT DEDENT
FIND_@@ THRE@@ E_@@ ELEMENT_@@ FROM_@@ DIFF@@ ER@@ ENT_@@ THRE@@ E_@@ ARRAY@@ S@@ _SU@@ CH_@@ TH@@ AT_@@ TH@@ AT_@@ A_@@ B_@@ C_@@ K_@@ 1 | def find@@ Trip@@ let ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT s . add ( a1 [ i ] ) NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT for j in range ( n3 ) : NEW_LINE INDENT if sum - a2 [ i ] - a3 [ j ] in s : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
FIND_@@ THE_@@ MAXIMUM_@@ ELEMENT_@@ IN_@@ AN_@@ ARRAY_@@ WHI@@ CH_@@ IS_@@ FIRST_@@ INCRE@@ AS@@ ING_@@ AND_@@ TH@@ EN_@@ DECRE@@ AS@@ ING_@@ 1 | def find@@ Maximum ( arr , low , high ) : NEW_LINE INDENT if low == high : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT if high == low + 1 and arr [ low ] >= arr [ high ] : NEW_LINE INDENT return arr [ low ] ; NEW_LINE DEDENT if high == low + 1 and arr [ low ] < arr [ high ] : NEW_LINE INDENT return arr [ high ] NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [ mid - 1 ] : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return find@@ Maximum ( arr , low , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return find@@ Maximum ( arr , mid + 1 , high ) NEW_LINE DEDENT DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 1 | def fi@@ b ( n , lookup ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT lookup [ n ] = n NEW_LINE DEDENT if lookup [ n ] is None : NEW_LINE INDENT lookup [ n ] = fi@@ b ( n - 1 , lookup ) + fi@@ b ( n - 2 , lookup ) NEW_LINE DEDENT return lookup [ n ] NEW_LINE DEDENT
MODUL@@ AR_@@ EXPO@@ NE@@ N@@ TI@@ ATION_@@ POWER_@@ IN_@@ MODUL@@ AR_@@ ARI@@ TH@@ ME@@ TIC | def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) == 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
WRITE_@@ ONE_@@ LINE_@@ C_@@ FUNCTION_@@ TO_@@ FIND_@@ WHE@@ THER_@@ A_@@ NO_@@ IS_@@ POWER_@@ OF_@@ TWO_@@ 1 | def is@@ PowerOf@@ Two ( x ) : NEW_LINE INDENT return ( x and ( not ( x & ( x - 1 ) ) ) ) NEW_LINE DEDENT
LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ SEQU@@ ENCE_@@ WITH_@@ PER@@ MU@@ TA@@ TIONS_@@ ALLOWED | def lon@@ gest@@ String ( str1 , str2 ) : NEW_LINE INDENT count@@ 1 = [ 0 ] * 26 NEW_LINE count2 = [ 0 ] * 26 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count@@ 1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT result = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( 1 , min ( count@@ 1 [ i ] , count2 [ i ] ) + 1 ) : NEW_LINE INDENT result = result + chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
DIFF@@ ER@@ ENCE_@@ MAX@@ IM@@ UM@@ _S@@ UM_@@ MIN@@ IM@@ UM@@ _S@@ UM_@@ N_@@ M_@@ ELEMEN@@ TS@@ IN_@@ RE@@ VIEW | def find_@@ difference ( arr , n , m ) : NEW_LINE INDENT max = 0 ; min = 0 NEW_LINE arr . sort ( ) ; NEW_LINE j = n - 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT min += arr [ i ] NEW_LINE max += arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT return ( max - min ) NEW_LINE DEDENT
PRINT_@@ NUMBER_@@ ASC@@ END@@ ING_@@ ORDER_@@ CONTAIN@@ S_@@ 1_2_@@ 3_@@ DIGITS | def print@@ Numbers ( numbers ) : NEW_LINE INDENT numbers = map ( str , numbers ) NEW_LINE result = [ ] NEW_LINE for num in numbers : NEW_LINE INDENT if ( '1' in num and '2' in num and '3' in num ) : NEW_LINE INDENT result . append ( num ) NEW_LINE DEDENT DEDENT if not result : NEW_LINE INDENT result = [ ' - 1' ] NEW_LINE DEDENT return sorted ( result ) ; NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 3_@@ LON@@ GE@@ ST_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQUENCE | def lis ( arr ) : NEW_LINE INDENT global maximum NEW_LINE n = len ( arr ) NEW_LINE maximum = 1 NEW_LINE _@@ lis ( arr , n ) NEW_LINE return maximum NEW_LINE DEDENT
MINIMUM_@@ RE@@ VO@@ LU@@ TIONS_@@ MOVE_@@ CENTER_@@ CI@@ R@@ CLE_@@ TARGET | def min@@ Re@@ volu@@ tions ( r , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT d = math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) NEW_LINE return math . ceil ( d // ( 2 * r ) ) NEW_LINE DEDENT
CHECK_@@ TWO_@@ GI@@ VEN@@ _SE@@ TS_@@ DIS@@ JOINT | def are@@ Dis@@ joint ( set1 , set2 , m , n ) : NEW_LINE INDENT for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( set1 [ i ] == set2 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
FIND_@@ MIN@@ IM@@ UM@@ _S@@ UM_@@ FAC@@ TOR@@ S_@@ NUMBER | def find@@ Min@@ Sum ( num ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 2 NEW_LINE while ( i * i <= num ) : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE num /= i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT sum += num NEW_LINE return sum NEW_LINE DEDENT
FREQU@@ ENT_@@ ELEMENT_@@ ARRAY | def most@@ Frequ@@ ent ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE max_@@ count = 1 ; res = arr [ 0 ] ; curr_@@ count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT curr_@@ count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( curr_@@ count > max_@@ count ) : NEW_LINE INDENT max_@@ count = curr_@@ count NEW_LINE res = arr [ i - 1 ] NEW_LINE DEDENT curr_@@ count = 1 NEW_LINE DEDENT DEDENT if ( curr_@@ count > max_@@ count ) : NEW_LINE INDENT max_@@ count = curr_@@ count NEW_LINE res = arr [ n - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT
MINIMUM_@@ X@@ OR_@@ VALUE_@@ PA@@ IR_@@ 1 | def min@@ XOR ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE min@@ Xor = int ( sys . float@@ _info . max ) NEW_LINE val = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ i + 1 ] ; NEW_LINE min@@ Xor = min ( min@@ Xor , val ) ; NEW_LINE DEDENT return min@@ Xor NEW_LINE DEDENT
MIN@@ IM@@ UM@@ _S@@ UM_@@ PRODUCT_@@ TWO_@@ ARRAY@@ S | def min@@ product ( a , b , n , k ) : NEW_LINE INDENT diff = 0 NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT pro = a [ i ] * b [ i ] NEW_LINE res = res + pro NEW_LINE if ( pro < 0 and b [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] + 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro < 0 and a [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] - 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro > 0 and a [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] + 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro > 0 and a [ i ] > 0 ) : NEW_LINE INDENT temp = ( a [ i ] - 2 * k ) * b [ i ] NEW_LINE DEDENT d = abs ( pro - temp ) NEW_LINE if ( d > diff ) : NEW_LINE INDENT diff = d NEW_LINE DEDENT DEDENT return res - diff NEW_LINE DEDENT
FAST_@@ MULTIP@@ LIC@@ ATION_@@ METHOD_@@ WITH@@ OUT_@@ USING_@@ MULTIP@@ LIC@@ ATION_@@ OPERATOR_@@ R@@ US@@ SI@@ AN_@@ PE@@ AS@@ AN@@ TS_@@ ALGORITH@@ M | def rus@@ sian@@ Pe@@ as@@ ant ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a << 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
DI@@ VISIBILITY_@@ 9_@@ USING_@@ BIT@@ WI@@ SE_@@ OPER@@ ATORS | def is@@ Div@@ By@@ 9 ( n ) : NEW_LINE INDENT if ( n == 0 or n == 9 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n < 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return is@@ Div@@ By@@ 9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) ) NEW_LINE DEDENT
CHECK_@@ ARRAY_@@ RE@@ PRESEN@@ TS_@@ IN@@ ORDER_@@ BIN@@ AR@@ Y@@ _SEARCH_@@ TREE_@@ NOT | def isIn@@ order ( arr , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
GI@@ V@@ EN_@@ TWO_@@ UN@@ SOR@@ TED_@@ ARRAY@@ S_@@ FIND_@@ PAIR@@ S_@@ WHO@@ SE_@@ S@@ UM_@@ X | def find@@ Pairs ( ar@@ r1 , ar@@ r2 , n , m , x ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( ar@@ r1 [ i ] + ar@@ r2 [ j ] == x ) : NEW_LINE INDENT print ( ar@@ r1 [ i ] , ar@@ r2 [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
BINARY_@@ RE@@ PRESEN@@ TATION_@@ OF_@@ NEXT_@@ NUMBER | def next@@ Greater ( num1 ) : NEW_LINE INDENT l = len ( num1 ) ; NEW_LINE num = list ( num1 ) ; NEW_LINE i = l - 1 ; NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( num [ i ] == '0' ) : NEW_LINE INDENT num [ i ] = '1' ; NEW_LINE break ; NEW_LINE DEDENT else : NEW_LINE INDENT num [ i ] = '0' ; NEW_LINE DEDENT i -= 1 ; NEW_LINE DEDENT num1 = ' ' . join ( num ) ; NEW_LINE if ( i < 0 ) : NEW_LINE INDENT num1 = '1' + num1 ; NEW_LINE DEDENT return num1 ; NEW_LINE DEDENT
LAR@@ GE@@ ST@@ _SUB@@ ARRAY_@@ WITH_@@ EQUAL_@@ NUMBER_OF_@@ 0@@ S_@@ AND_@@ 1@@ S | def find@@ Sub@@ Array ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE maxsize = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT sum = - 1 if ( arr [ i ] == 0 ) else 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1 NEW_LINE if ( sum == 0 and maxsize < j - i + 1 ) : NEW_LINE INDENT maxsize = j - i + 1 NEW_LINE start@@ index = i NEW_LINE DEDENT DEDENT DEDENT if ( maxsize == - 1 ) : NEW_LINE INDENT print ( " No ▁ such ▁ sub@@ array " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( start@@ index , " to " , start@@ index + maxsize - 1 ) ; NEW_LINE DEDENT return maxsize NEW_LINE DEDENT
COUNT_@@ PAIR@@ S_@@ WHO@@ SE_@@ PRODUC@@ TS_@@ EXI@@ ST_@@ IN_@@ ARRAY_@@ 1 | def count@@ Pairs ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE Hash = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash . add ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product = arr [ i ] * arr [ j ] NEW_LINE if product in ( Hash ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 12_@@ LON@@ GE@@ ST_@@ PA@@ LIN@@ DRO@@ MI@@ C@@ _SUB@@ SEQUENCE | def l@@ ps ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE L = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if str [ i ] == str [ j ] and cl == 2 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif str [ i ] == str [ j ] : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT
COUNT_@@ IN@@ VERSION@@ S_@@ OF@@ _SIZE_@@ THRE@@ E_@@ IN_@@ A_@@ GI@@ VE_@@ ARRAY_@@ 1 | def getIn@@ v@@ Count ( arr , n ) : NEW_LINE INDENT inv@@ count = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT small = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT small += 1 NEW_LINE DEDENT DEDENT great = 0 ; NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT great += 1 NEW_LINE DEDENT DEDENT inv@@ count += great * small NEW_LINE DEDENT return inv@@ count NEW_LINE DEDENT
DECIMAL_@@ RE@@ PRESEN@@ TATION_@@ GI@@ V@@ EN_@@ BINARY_@@ STRING_@@ DI@@ VISI@@ BLE_@@ 10_@@ NOT | def is@@ Di@@ visible@@ By@@ 10 ( bin ) : NEW_LINE INDENT n = len ( bin ) NEW_LINE if ( bin [ n - 1 ] == '1' ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( bin [ i ] == '1' ) : NEW_LINE INDENT pos@@ From@@ Right = n - i - 1 NEW_LINE if ( pos@@ From@@ Right % 4 == 1 ) : NEW_LINE INDENT sum = sum + 2 NEW_LINE DEDENT elif ( pos@@ From@@ Right % 4 == 2 ) : NEW_LINE INDENT sum = sum + 4 NEW_LINE DEDENT elif ( pos@@ From@@ Right % 4 == 3 ) : NEW_LINE INDENT sum = sum + 8 NEW_LINE DEDENT elif ( pos@@ From@@ Right % 4 == 0 ) : NEW_LINE INDENT sum = sum + 6 NEW_LINE DEDENT DEDENT i = i - 1 NEW_LINE DEDENT if ( sum % 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
FIND_@@ WHE@@ THER_@@ AN_@@ ARRAY_@@ IS@@ _SUB@@ SET_@@ OF_@@ AN@@ OTHER_@@ ARRAY@@ _SET_@@ 1_1 | def is@@ Subset ( ar@@ r1 , ar@@ r2 , m , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE if m < n : NEW_LINE INDENT return 0 NEW_LINE DEDENT ar@@ r1 . sort ( ) NEW_LINE ar@@ r2 . sort ( ) NEW_LINE while i < n and j < m : NEW_LINE INDENT if ar@@ r1 [ j ] < ar@@ r2 [ i ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif ar@@ r1 [ j ] == ar@@ r2 [ i ] : NEW_LINE INDENT j += 1 NEW_LINE i += 1 NEW_LINE DEDENT elif ar@@ r1 [ j ] > ar@@ r2 [ i ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return False if i < n else True NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SUB@@ SET_@@ S@@ UM_@@ PRO@@ BLE@@ M_@@ 1 | def isSub@@ set@@ Sum ( set , n , sum ) : NEW_LINE INDENT subset = ( [ [ False for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if j < set [ i - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] NEW_LINE DEDENT if j >= set [ i - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return subset [ n ] [ sum ] NEW_LINE DEDENT
S@@ UM_@@ K_@@ TH_@@ GROUP_@@ OD@@ D_@@ POSITIVE_@@ NUMB@@ ERS_@@ 1 | def k@@ th@@ group@@ sum ( k ) : NEW_LINE INDENT return k * k * k NEW_LINE DEDENT
THIR@@ D_@@ LAR@@ GE@@ ST_@@ ELEMENT_@@ ARRAY_@@ DISTIN@@ CT_@@ ELEMENTS | def third@@ Lar@@ gest ( arr , arr_@@ size ) : NEW_LINE INDENT if ( arr_@@ size < 3 ) : NEW_LINE INDENT print ( " ▁ Invalid ▁ Input ▁ " ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE for i in range ( 1 , arr_@@ size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT first = arr [ i ] NEW_LINE DEDENT DEDENT second = - sys . maxsize NEW_LINE for i in range ( 0 , arr_@@ size ) : NEW_LINE INDENT if ( arr [ i ] > second and arr [ i ] < first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT third = - sys . maxsize NEW_LINE for i in range ( 0 , arr_@@ size ) : NEW_LINE INDENT if ( arr [ i ] > third and arr [ i ] < second ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ Third ▁ Lar@@ gest " , " element ▁ is " , third ) NEW_LINE DEDENT
FIN@@ D_S@@ UM_@@ NODE@@ S_@@ GI@@ V@@ EN_@@ PER@@ F@@ ECT_@@ BINARY_@@ TREE_@@ 1 | def sum@@ Nodes ( l ) : NEW_LINE INDENT leaf@@ Node@@ Count = math . pow ( 2 , l - 1 ) ; NEW_LINE sum@@ Last@@ Level = 0 ; NEW_LINE sum@@ Last@@ Level = ( ( leaf@@ Node@@ Count * ( leaf@@ Node@@ Count + 1 ) ) / 2 ) ; NEW_LINE sum = sum@@ Last@@ Level * l ; NEW_LINE return int ( sum ) ; NEW_LINE DEDENT
MIDD@@ LE_@@ OF_@@ THRE@@ E_@@ USING_@@ MINIMUM_@@ COMP@@ ARIS@@ ONS_@@ 2 | def middle@@ Of@@ Three ( a , b , c ) : NEW_LINE INDENT x = a - b NEW_LINE y = b - c NEW_LINE z = a - c NEW_LINE if x * y > 0 : NEW_LINE INDENT return b NEW_LINE DEDENT elif ( x * z > 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT
MAXIMUM_@@ TR@@ IP@@ LET_@@ S@@ UM_@@ ARRAY_@@ 2 | def max@@ Trip@@ let@@ Sum ( arr , n ) : NEW_LINE INDENT max@@ A = - 1@@ 00000000 NEW_LINE max@@ B = - 1@@ 00000000 NEW_LINE max@@ C = - 1@@ 00000000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > max@@ A ) : NEW_LINE INDENT max@@ C = max@@ B NEW_LINE max@@ B = max@@ A NEW_LINE max@@ A = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > max@@ B ) : NEW_LINE INDENT max@@ C = max@@ B NEW_LINE max@@ B = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > max@@ C ) : NEW_LINE INDENT max@@ C = arr [ i ] NEW_LINE DEDENT DEDENT return ( max@@ A + max@@ B + max@@ C ) NEW_LINE DEDENT
COUNT_@@ PAIR@@ S_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL_@@ GI@@ V@@ EN_@@ VALUE_@@ X_@@ 1 | def count@@ Pairs ( ar@@ r1 , ar@@ r2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE us = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT us . add ( ar@@ r1 [ i ] ) NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if x - ar@@ r2 [ j ] in us : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
MINIMUM_@@ STE@@ PS_@@ REACH_@@ END_@@ ARRAY_@@ CONSTRA@@ INTS | def getMin@@ Step@@ To@@ Reach@@ End ( arr , N ) : NEW_LINE INDENT visit = [ False for i in range ( N ) ] NEW_LINE distance = [ 0 for i in range ( N ) ] NEW_LINE digit = [ [ 0 for i in range ( N ) ] for j in range ( 10 ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT digit [ arr [ i ] ] . append ( i ) NEW_LINE DEDENT distance [ 0 ] = 0 NEW_LINE visit [ 0 ] = True NEW_LINE q = [ ] NEW_LINE q . append ( 0 ) NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT idx = q [ 0 ] NEW_LINE q . remove ( q [ 0 ] ) NEW_LINE if ( idx == N - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT d = arr [ idx ] NEW_LINE for i in range ( len ( digit [ d ] ) ) : NEW_LINE INDENT nex@@ ti@@ dx = digit [ d ] [ i ] NEW_LINE if ( visit [ nex@@ ti@@ dx ] == False ) : NEW_LINE INDENT visit [ nex@@ ti@@ dx ] = True NEW_LINE q . append ( nex@@ ti@@ dx ) NEW_LINE distance [ nex@@ ti@@ dx ] = distance [ idx ] + 1 NEW_LINE DEDENT DEDENT if ( idx - 1 >= 0 and visit [ idx - 1 ] == False ) : NEW_LINE INDENT visit [ idx - 1 ] = True NEW_LINE q . append ( idx - 1 ) NEW_LINE distance [ idx - 1 ] = distance [ idx ] + 1 NEW_LINE DEDENT if ( idx + 1 < N and visit [ idx + 1 ] == False ) : NEW_LINE INDENT visit [ idx + 1 ] = True NEW_LINE q . append ( idx + 1 ) NEW_LINE distance [ idx + 1 ] = distance [ idx ] + 1 NEW_LINE DEDENT DEDENT return distance [ N - 1 ] NEW_LINE DEDENT
LE@@ XI@@ CO@@ GRAPHIC@@ AL@@ LY@@ _S@@ MAL@@ LE@@ ST_@@ ARRAY_@@ K_@@ CON@@ SEC@@ UTI@@ VE_@@ SWAP@@ S | def minim@@ ize@@ With@@ K@@ Sw@@ aps ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT pos = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j - i > k ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ j ] < arr [ pos ] ) : NEW_LINE INDENT pos = j NEW_LINE DEDENT DEDENT for j in range ( pos , i , - 1 ) : NEW_LINE INDENT arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] NEW_LINE DEDENT k -= pos - i NEW_LINE DEDENT DEDENT
CONVERT_@@ SEN@@ T@@ ENCE_@@ EQU@@ I@@ VAL@@ ENT_@@ MOBI@@ LE_@@ NUMERIC_@@ KEY@@ PAD@@ _SEQU@@ ENCE | def print@@ Sequence ( arr , input ) : NEW_LINE INDENT n = len ( input ) NEW_LINE output = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( input [ i ] == ' ▁ ' ) : NEW_LINE INDENT output = output + "0" NEW_LINE DEDENT else : NEW_LINE INDENT position = ord ( input [ i ] ) - ord ( ' A ' ) NEW_LINE output = output + arr [ position ] NEW_LINE DEDENT DEDENT return output NEW_LINE DEDENT
PROGRAM_@@ CHECK_@@ ARRA@@ Y_S@@ OR@@ TED_@@ NOT_@@ ITER@@ ATI@@ VE_@@ RECUR@@ SIVE | def array@@ Sorted@@ Or@@ Not ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE if n == 1 or n == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return arr [ 0 ] <= arr [ 1 ] and array@@ Sorted@@ Or@@ Not ( arr [ 1 : ] ) NEW_LINE DEDENT
CHECK_@@ TWO_@@ GI@@ V@@ EN_@@ CIRC@@ LES_@@ TOUCH_@@ INTER@@ S@@ ECT | def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT dist@@ Sq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; NEW_LINE rad@@ Sum@@ Sq = ( r1 + r2 ) * ( r1 + r2 ) ; NEW_LINE if ( dist@@ Sq == rad@@ Sum@@ Sq ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( dist@@ Sq > rad@@ Sum@@ Sq ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
SM@@ ALLE@@ ST_@@ POWER_@@ OF_@@ 2_@@ GREATER_@@ TH@@ AN_@@ OR_@@ EQUAL_@@ TO_@@ N_@@ 2 | def next@@ PowerOf@@ 2 ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT
PAD@@ OV@@ AN@@ _SEQU@@ ENCE | def pad ( n ) : NEW_LINE INDENT p@@ Prev@@ Prev , p@@ Prev , pCur@@ r , pNext = 1 , 1 , 1 , 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT pNext = p@@ Prev@@ Prev + p@@ Prev NEW_LINE p@@ Prev@@ Prev = p@@ Prev NEW_LINE p@@ Prev = pCur@@ r NEW_LINE pCur@@ r = pNext NEW_LINE DEDENT return pNext ; NEW_LINE DEDENT
CHECK_@@ GI@@ V@@ EN_@@ STRING_@@ CAN@@ _SP@@ LIT_@@ FOUR_@@ DISTIN@@ CT_@@ STRINGS | def check ( s ) : NEW_LINE INDENT if ( len ( s ) >= 10 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT for k in range ( j + 1 , len ( s ) ) : NEW_LINE INDENT s1 = s [ 0 : i ] NEW_LINE s2 = s [ i : j - i ] NEW_LINE s3 = s [ j : k - j ] NEW_LINE s4 = s [ k : len ( s ) - k ] NEW_LINE if ( s1 != s2 and s1 != s3 and s1 != s4 and s2 != s3 and s2 != s4 and s3 != s4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
PER@@ M@@ UTE_@@ TWO_@@ ARRAY@@ S_S@@ UM_@@ EVER@@ Y_@@ PA@@ IR_@@ GREATER_@@ EQUAL_@@ K | def is@@ Possible ( a , b , n , k ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] + b [ i ] < k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
ARRAY_@@ ELEMENT_@@ MOVE@@ D_@@ K_@@ US@@ ING@@ _SIN@@ GLE_@@ MOV@@ ES | def winner ( a , n , k ) : NEW_LINE INDENT if k >= n - 1 : NEW_LINE INDENT return n NEW_LINE DEDENT best = 0 NEW_LINE times = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > best : NEW_LINE INDENT best = a [ i ] NEW_LINE if i == True : NEW_LINE INDENT times = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT times += 1 NEW_LINE DEDENT if times >= k : NEW_LINE INDENT return best NEW_LINE DEDENT DEDENT return best NEW_LINE DEDENT
DIRECTION_@@ LAST@@ _S@@ QU@@ ARE_@@ BLOCK | def direction ( R , C ) : NEW_LINE INDENT if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Left " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( " Up " ) NEW_LINE return NEW_LINE DEDENT if R == C and R % 2 != 0 and C % 2 != 0 : NEW_LINE INDENT print ( " Right " ) NEW_LINE return NEW_LINE DEDENT if R == C and R % 2 == 0 and C % 2 == 0 : NEW_LINE INDENT print ( " Left " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Right " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) : NEW_LINE INDENT print ( " Down " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Left " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( " Up " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) : NEW_LINE INDENT print ( " Down " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Right " ) NEW_LINE return NEW_LINE DEDENT DEDENT
NUMBER_@@ NON_@@ NEGATIVE_@@ INTEGR@@ AL_S@@ OL@@ U@@ TIONS_@@ B_@@ C_@@ N | def count@@ Integr@@ al@@ Solutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT if i + j + k == n : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
SW@@ AP_@@ MAJ@@ OR_@@ MIN@@ OR_@@ DIAG@@ ON@@ AL@@ S_S@@ QU@@ ARE_@@ MATRIX | def swap@@ Diagonal ( matrix ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] = \ NEW_LINE INDENT matrix [ i ] [ N - i - 1 ] , matrix [ i ] [ i ] NEW_LINE DEDENT DEDENT DEDENT
MINIMUM_@@ OPER@@ ATION@@ S_@@ MAKE_@@ GC@@ D_@@ ARRAY_@@ MULTIPLE_@@ K | def Min@@ Operation ( a , n , k ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 1 and a [ i ] > k ) : NEW_LINE INDENT result = ( result + min ( a [ i ] % k , k - a [ i ] % k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT result = result + k - a [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
MAXIMUM_@@ DECIMAL_@@ VALUE_@@ PATH_@@ IN_@@ A_@@ BINARY_@@ MATRIX | def max@@ Decimal@@ Value ( mat , i , j , p ) : NEW_LINE INDENT if i >= N or j >= N : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = max ( max@@ Decimal@@ Value ( mat , i , j + 1 , p + 1 ) , max@@ Decimal@@ Value ( mat , i + 1 , j , p + 1 ) ) NEW_LINE if mat [ i ] [ j ] == 1 : NEW_LINE INDENT return pow ( 2 , p ) + result NEW_LINE DEDENT else : NEW_LINE INDENT return result NEW_LINE DEDENT DEDENT
SQU@@ ARE_@@ ROOT_@@ OF_@@ A_@@ PER@@ F@@ ECT_@@ SQU@@ ARE_@@ 1 | def square@@ Root ( n ) : NEW_LINE INDENT x = n ; NEW_LINE y = 1 ; NEW_LINE while ( x > y ) : NEW_LINE INDENT x = ( x + y ) / 2 ; NEW_LINE y = n / x ; NEW_LINE DEDENT return x ; NEW_LINE DEDENT
FIND_@@ MIN@@ IM@@ UM@@ _SH@@ IFT_@@ LON@@ GE@@ ST_@@ COMMON_@@ PREFIX | def K@@ MP ( m , n , str2 , str1 ) : NEW_LINE INDENT pos = 0 NEW_LINE Len = 0 NEW_LINE p = [ 0 for i in range ( m + 1 ) ] NEW_LINE k = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT while ( k > 0 and str1 [ k ] != str1 [ i - 1 ] ) : NEW_LINE INDENT k = p [ k ] NEW_LINE DEDENT if ( str1 [ k ] == str1 [ i - 1 ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT p [ i ] = k NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT while ( j > 0 and j < n and str1 [ j ] != str2 [ i ] ) : NEW_LINE INDENT j = p [ j ] NEW_LINE DEDENT if ( j < n and str1 [ j ] == str2 [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if ( j > Len ) : NEW_LINE INDENT Len = j NEW_LINE pos = i - j + 1 NEW_LINE DEDENT DEDENT print ( " Shift ▁ = ▁ " , pos ) NEW_LINE print ( " Prefix ▁ = ▁ " , str1 [ : Len ] ) NEW_LINE DEDENT
SOR@@ TED_@@ ORDER_@@ PRINT@@ ING_@@ OF_@@ AN_@@ ARRAY_@@ TH@@ AT_@@ RE@@ PRESEN@@ TS_@@ A_@@ B@@ ST | def print@@ Sorted ( arr , start , end ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return NEW_LINE DEDENT print@@ Sorted ( arr , start * 2 + 1 , end ) NEW_LINE print ( arr [ start ] , end = " ▁ " ) NEW_LINE print@@ Sorted ( arr , start * 2 + 2 , end ) NEW_LINE DEDENT
CHECK_@@ WHE@@ THER_@@ GI@@ V@@ EN_@@ DEGRE@@ ES_@@ VER@@ TIC@@ ES_@@ RE@@ PRES@@ ENT_@@ GRAPH_@@ TREE | def check ( degree , n ) : NEW_LINE INDENT de@@ g_@@ sum = sum ( degree ) NEW_LINE if ( 2 * ( n - 1 ) == de@@ g_@@ sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
MOVE_@@ ZER@@ O@@ ES_@@ END_@@ ARRAY | def push@@ Zer@@ os@@ To@@ End ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while count < n : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT
COUNT_@@ ELEMEN@@ TS_@@ WHI@@ CH_@@ DI@@ VI@@ DE_@@ ALL_@@ NUMB@@ ERS_@@ IN_@@ RANGE_@@ L_@@ R | def answer@@ Query ( a , n , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE l = l - 1 NEW_LINE for i in range ( l , r , 1 ) : NEW_LINE INDENT element = a [ i ] NEW_LINE di@@ visors = 0 NEW_LINE for j in range ( l , r , 1 ) : NEW_LINE INDENT if ( a [ j ] % a [ i ] == 0 ) : NEW_LINE INDENT di@@ visors += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( di@@ visors == ( r - l ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
S@@ UM_@@ LAR@@ GE@@ ST_@@ PRI@@ ME_@@ FAC@@ TOR_@@ NUMBER_@@ LESS_@@ EQUAL_@@ N | def sum@@ Of@@ Large@@ Prime@@ Factor ( n ) : NEW_LINE INDENT prime = [ 0 ] * ( n + 1 ) NEW_LINE sum = 0 NEW_LINE max = int ( n / 2 ) NEW_LINE for p in range ( 2 , max + 1 ) : NEW_LINE INDENT if prime [ p ] == 0 : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = p NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT sum += prime [ p ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += p NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
RE@@ AR@@ RANGE_@@ A_@@ STRING_@@ IN@@ _S@@ OR@@ TED_@@ ORDER_@@ FOL@@ LO@@ WED_@@ BY_@@ THE_@@ INTEG@@ ER@@ _S@@ UM | def arrange@@ String ( string ) : NEW_LINE INDENT char@@ _count = [ 0 ] * MAX_@@ CHAR NEW_LINE s = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if string [ i ] >= " A " and string [ i ] <= " Z " : NEW_LINE INDENT char@@ _count [ ord ( string [ i ] ) - ord ( " A " ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s += ord ( string [ i ] ) - ord ( "0" ) NEW_LINE DEDENT DEDENT res = " " NEW_LINE for i in range ( MAX_@@ CHAR ) : NEW_LINE INDENT ch = chr ( ord ( " A " ) + i ) NEW_LINE while char@@ _count [ i ] : NEW_LINE INDENT res += ch NEW_LINE char@@ _count [ i ] -= 1 NEW_LINE DEDENT DEDENT if s > 0 : NEW_LINE INDENT res += str ( s ) NEW_LINE DEDENT return res NEW_LINE DEDENT
COUNT_@@ POSSI@@ BLE_@@ PATH@@ S_@@ TOP_@@ LEFT_@@ BOTTOM_@@ RIGHT_@@ NX@@ M_@@ MATRIX_@@ 1 | def numberOf@@ Paths ( m , n ) : NEW_LINE INDENT count = [ [ 0 for x in range ( m ) ] for y in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT count [ i ] [ 0 ] = 1 ; NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT count [ 0 ] [ j ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 5_@@ EDIT_@@ DISTAN@@ CE_@@ 1 | def edit@@ Dist@@ DP ( str1 , str2 , m , n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif str1 [ i - 1 ] == str2 [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
FIND_@@ NUMBER_@@ OF@@ _S@@ OL@@ U@@ TIONS_@@ OF_@@ A_@@ LINEAR_@@ EQU@@ ATION_@@ OF_@@ N_@@ VARIABLES | def count@@ So@@ l ( coeff , start , end , rhs ) : NEW_LINE INDENT if ( rhs == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( coeff [ i ] <= rhs ) : NEW_LINE INDENT result += count@@ So@@ l ( coeff , i , end , rhs - coeff [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
S@@ UM_@@ ELEMEN@@ TS_@@ K@@ 1@@ TH_@@ K@@ 2@@ TH@@ _S@@ MAL@@ LE@@ ST_@@ ELEMEN@@ TS_@@ 1 | def min@@ heap@@ ify ( a , index ) : NEW_LINE INDENT small = index NEW_LINE l = 2 * index + 1 NEW_LINE r = 2 * index + 2 NEW_LINE if ( l < n and a [ l ] < a [ small ] ) : NEW_LINE INDENT small = l NEW_LINE DEDENT if ( r < n and a [ r ] < a [ small ] ) : NEW_LINE INDENT small = r NEW_LINE DEDENT if ( small != index ) : NEW_LINE INDENT ( a [ small ] , a [ index ] ) = ( a [ index ] , a [ small ] ) NEW_LINE min@@ heap@@ ify ( a , small ) NEW_LINE DEDENT DEDENT
SE@@ ARCH@@ ING_@@ FOR_@@ PATTER@@ NS@@ _SET_@@ 2_@@ K@@ MP_@@ ALGORITH@@ M | def compute@@ LP@@ S@@ Array ( pat , M , l@@ ps ) : NEW_LINE INDENT len = 0 NEW_LINE l@@ ps [ 0 ] NEW_LINE i = 1 NEW_LINE while i < M : NEW_LINE INDENT if pat [ i ] == pat [ len ] : NEW_LINE INDENT len += 1 NEW_LINE l@@ ps [ i ] = len NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if len != 0 : NEW_LINE INDENT len = l@@ ps [ len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT l@@ ps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
FIND_@@ MINIMUM_@@ DIFF@@ ER@@ ENCE_@@ PAIR | def find@@ Min@@ Diff ( arr , n ) : NEW_LINE INDENT diff = 10 ** 20 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if abs ( arr [ i ] - arr [ j ] ) < diff : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return diff NEW_LINE DEDENT
PRINT_@@ FIRST_@@ K_@@ DIG@@ IT@@ S_@@ 1@@ N_@@ N_@@ POSITIVE_@@ INTEGER | def Print ( n , k ) : NEW_LINE INDENT rem = 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT print ( math . floor ( ( ( 10 * rem ) / n ) ) , end = " " ) NEW_LINE rem = ( 10 * rem ) % n NEW_LINE DEDENT DEDENT
GROUP_@@ MULTIPLE_@@ OC@@ CURR@@ ENCE_@@ OF_@@ ARRAY_@@ ELEMEN@@ TS_@@ ORDE@@ RED_@@ BY_@@ FIRST_@@ OC@@ CURR@@ ENCE | def group@@ Elements ( arr , n ) : NEW_LINE INDENT visited = [ False ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT visited [ i ] = False NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE visited [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
CHECK_@@ WHE@@ THER_@@ ARI@@ TH@@ ME@@ TIC_@@ PROG@@ RES@@ SION_@@ CAN_@@ FOR@@ MED_@@ GI@@ V@@ EN_@@ ARRAY | def check@@ Is@@ AP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : return True NEW_LINE arr . sort ( ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
N@@ TH_@@ MULTIPLE_@@ NUMBER_@@ FI@@ BON@@ AC@@ CI@@ _SERI@@ ES | def find@@ Position ( k , n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE i = 2 ; NEW_LINE while i != 0 : NEW_LINE INDENT f3 = f1 + f2 ; NEW_LINE f1 = f2 ; NEW_LINE f2 = f3 ; NEW_LINE if f2 % k == 0 : NEW_LINE INDENT return n * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return NEW_LINE DEDENT
COUNT_@@ PAIR@@ S_@@ DIFF@@ ER@@ ENCE_@@ EQUAL_@@ K_@@ 1 | def count@@ Pai@@ rs@@ With@@ Diff@@ K ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE while r < n : NEW_LINE INDENT if arr [ r ] - arr [ l ] == k : NEW_LINE INDENT count += 1 NEW_LINE l += 1 NEW_LINE r += 1 NEW_LINE DEDENT elif arr [ r ] - arr [ l ] > k : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
ELEMEN@@ TS_@@ TO_@@ BE_@@ AD@@ DE@@ D_S@@ O_@@ TH@@ AT_@@ ALL_@@ ELEMEN@@ TS_@@ OF_@@ A_@@ RANGE_@@ ARE_@@ PRES@@ ENT_@@ IN_@@ ARRAY | def count@@ Num ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) : NEW_LINE INDENT count += arr [ i + 1 ] - arr [ i ] - 1 ; NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
MAKE_@@ LAR@@ GE@@ ST_@@ PA@@ LIN@@ DRO@@ ME_@@ CHAN@@ G@@ ING_@@ K_@@ DIGITS | def maximum@@ Pal@@ in@@ Using@@ K@@ Changes ( str@@ r , k ) : NEW_LINE INDENT pal@@ in = str@@ r NEW_LINE l = 0 NEW_LINE r = len ( str@@ r ) - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( str@@ r [ l ] != str@@ r [ r ] ) : NEW_LINE INDENT pal@@ in [ l ] = pal@@ in [ r ] = max ( str@@ r [ l ] , str@@ r [ r ] ) NEW_LINE k -= 1 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT if ( k < 0 ) : NEW_LINE INDENT return " Not ▁ possible " NEW_LINE DEDENT l = 0 NEW_LINE r = len ( str@@ r ) - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT if ( k > 0 ) : NEW_LINE INDENT pal@@ in [ l ] = '9' NEW_LINE DEDENT DEDENT if ( pal@@ in [ l ] < '9' ) : NEW_LINE INDENT if ( k >= 2 and pal@@ in [ l ] == str@@ r [ l ] and pal@@ in [ r ] == str@@ r [ r ] ) : NEW_LINE INDENT k -= 1 NEW_LINE pal@@ in [ l ] = pal@@ in [ r ] = '9' NEW_LINE DEDENT elif ( k >= 1 and ( pal@@ in [ l ] != str@@ r [ l ] or pal@@ in [ r ] != str@@ r [ r ] ) ) : NEW_LINE INDENT k -= 1 NEW_LINE pal@@ in [ l ] = pal@@ in [ r ] = '9' NEW_LINE DEDENT DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return pal@@ in NEW_LINE DEDENT
SUB@@ ARRAY@@ SUB@@ STRING_@@ VS@@ _SUB@@ SEQU@@ ENCE_@@ AND_@@ PROGR@@ AM@@ S_TO_@@ GENERATE_@@ THE@@ M | def sub@@ Array ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = " ▁ " ) NEW_LINE DEDENT print ( " \n " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
MAX@@ IM@@ UM@@ _S@@ UM_@@ INCRE@@ AS@@ ING_@@ ORDER_@@ ELEMEN@@ TS_@@ N_@@ ARRAY@@ S | def maximum@@ Sum ( a , n ) : NEW_LINE INDENT global M ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT a [ i ] . sort ( ) ; NEW_LINE DEDENT sum = a [ n - 1 ] [ M - 1 ] ; NEW_LINE prev = a [ n - 1 ] [ M - 1 ] ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] [ j ] < prev ) : NEW_LINE INDENT prev = a [ i ] [ j ] ; NEW_LINE sum += prev ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( j == - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT
C_@@ PROGRAM_@@ FAC@@ TOR@@ I@@ AL_@@ NUMBER | def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) ; NEW_LINE DEDENT
PRINT_@@ SQU@@ AR@@ ES_@@ FIRST_@@ N_@@ N@@ ATUR@@ AL_@@ NUMB@@ ERS_@@ WITH@@ OUT_@@ USING | def print@@ Squ@@ ares ( n ) : NEW_LINE INDENT square = 0 ; prev_@@ x = 0 ; NEW_LINE for x in range ( 0 , n ) : NEW_LINE INDENT square = ( square + x + prev_@@ x ) NEW_LINE print ( square , end = " ▁ " ) NEW_LINE prev_@@ x = x NEW_LINE DEDENT DEDENT
RO@@ PE@@ S_@@ DATA_@@ STRUC@@ TURE_@@ FAST_@@ STRING_@@ CON@@ CAT@@ EN@@ ATION | def concatenate ( a , b , c , n1 , n2 ) : NEW_LINE INDENT i = - 1 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT c [ i ] = a [ i ] NEW_LINE DEDENT for j in range ( n2 ) : NEW_LINE INDENT c [ i ] = b [ j ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
GI@@ V@@ EN_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S_@@ NUMBER_@@ X_@@ FIND_@@ PA@@ IR_@@ WHO@@ SE_@@ S@@ UM_@@ CLO@@ SE@@ ST_@@ X | def print@@ Close@@ st ( ar@@ 1 , ar@@ 2 , m , n , x ) : NEW_LINE INDENT diff = sys . maxsize NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while ( l < m and r >= 0 ) : NEW_LINE INDENT if abs ( ar@@ 1 [ l ] + ar@@ 2 [ r ] - x ) < diff : NEW_LINE INDENT res_@@ l = l NEW_LINE res_@@ r = r NEW_LINE diff = abs ( ar@@ 1 [ l ] + ar@@ 2 [ r ] - x ) NEW_LINE DEDENT if ar@@ 1 [ l ] + ar@@ 2 [ r ] > x : NEW_LINE INDENT r = r - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = l + 1 NEW_LINE DEDENT DEDENT print ( " The ▁ closest ▁ pair ▁ is ▁ [ " , ar@@ 1 [ res_@@ l ] , " , " , ar@@ 2 [ res_@@ r ] , " ] " ) NEW_LINE DEDENT
CONVERT_@@ STRIC@@ TL@@ Y_@@ INCRE@@ AS@@ ING_@@ ARRAY_@@ MINIMUM_@@ CHAN@@ GES | def min@@ Remove ( arr , n ) : NEW_LINE INDENT LI@@ S = [ 0 for i in range ( n ) ] NEW_LINE len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT LI@@ S [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LI@@ S [ i ] = max ( LI@@ S [ i ] , LI@@ S [ j ] + 1 ) NEW_LINE DEDENT DEDENT len = max ( len , LI@@ S [ i ] ) NEW_LINE DEDENT return ( n - len ) NEW_LINE DEDENT
TA@@ IL_@@ RECUR@@ SION | def fact ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT
RECUR@@ SIVE_@@ FUNCTIONS | def tower ( n , source@@ Po@@ le , destination@@ Po@@ le , auxili@@ ary@@ Po@@ le ) : NEW_LINE INDENT if ( 0 == n ) : NEW_LINE INDENT return NEW_LINE DEDENT tower ( n - 1 , source@@ Po@@ le , auxili@@ ary@@ Po@@ le , destination@@ Po@@ le ) NEW_LINE print ( " Move ▁ the ▁ disk " , source@@ Po@@ le , " from " , source@@ Po@@ le , " to " , destination@@ Po@@ le ) NEW_LINE tower ( n - 1 , auxili@@ ary@@ Po@@ le , destination@@ Po@@ le , source@@ Po@@ le ) NEW_LINE DEDENT
FIND_@@ X_@@ Y_S@@ ATI@@ SF@@ Y@@ ING_@@ A@@ X_@@ N | def solution ( a , b , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i * a <= n : NEW_LINE INDENT if ( n - ( i * a ) ) % b == 0 : NEW_LINE INDENT print ( " x ▁ = ▁ " , i , " , ▁ y ▁ = ▁ " , int ( ( n - ( i * a ) ) / b ) ) NEW_LINE return 0 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT print ( " No ▁ solution " ) NEW_LINE DEDENT
EXPO@@ NE@@ N@@ TI@@ AL_S@@ QUAR@@ ING_@@ FAST_@@ MODUL@@ O_@@ MULTIP@@ LIC@@ ATION_@@ 1 | def expon@@ enti@@ ation ( b@@ as , exp ) : NEW_LINE INDENT t = 1 ; NEW_LINE while ( exp > 0 ) : NEW_LINE INDENT if ( exp % 2 != 0 ) : NEW_LINE INDENT t = ( t * b@@ as ) % N ; NEW_LINE DEDENT b@@ as = ( b@@ as * b@@ as ) % N ; NEW_LINE exp = int ( exp / 2 ) ; NEW_LINE DEDENT return t % N ; NEW_LINE DEDENT
CHECK_@@ OC@@ CURR@@ EN@@ CES_@@ CHARACTER_@@ AP@@ PE@@ AR_@@ TO@@ GE@@ THER | def check@@ If@@ All@@ To@@ gether ( s , c ) : NEW_LINE INDENT one@@ Seen = False NEW_LINE i = 0 NEW_LINE n = len ( s ) NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == c ) : NEW_LINE INDENT if ( one@@ Seen == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( i < n and s [ i ] == c ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT one@@ Seen = True NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
MAXIMUM_@@ AREA_@@ REC@@ TAN@@ GLE_@@ PIC@@ KING_@@ FOUR@@ _SI@@ DES_@@ ARRAY | def find@@ Area ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE dimension = [ 0 , 0 ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n - 1 and j < 2 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT dimension [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( dimension [ 0 ] * dimension [ 1 ] ) NEW_LINE DEDENT
PYTHON_@@ PROGRAM_@@ FIND_@@ PER@@ I@@ ME@@ TER_@@ CIRCUM@@ FER@@ ENCE_@@ SQU@@ ARE_@@ REC@@ TA@@ NG@@ LE | def Cir@@ cum@@ ference ( a ) : NEW_LINE INDENT return ( 4 * a ) NEW_LINE DEDENT
CY@@ CLE_@@ S@@ ORT | def cycle@@ Sort ( array ) : NEW_LINE INDENT writes = 0 NEW_LINE for cycle@@ Start in range ( 0 , len ( array ) - 1 ) : NEW_LINE INDENT item = array [ cycle@@ Start ] NEW_LINE pos = cycle@@ Start NEW_LINE for i in range ( cycle@@ Start + 1 , len ( array ) ) : NEW_LINE INDENT if array [ i ] < item : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT DEDENT if pos == cycle@@ Start : NEW_LINE INDENT continue NEW_LINE DEDENT while item == array [ pos ] : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT array [ pos ] , item = item , array [ pos ] NEW_LINE writes += 1 NEW_LINE while pos != cycle@@ Start : NEW_LINE INDENT pos = cycle@@ Start NEW_LINE for i in range ( cycle@@ Start + 1 , len ( array ) ) : NEW_LINE INDENT if array [ i ] < item : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT DEDENT while item == array [ pos ] : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT array [ pos ] , item = item , array [ pos ] NEW_LINE writes += 1 NEW_LINE DEDENT DEDENT return writes NEW_LINE DEDENT
SELECT_@@ A_@@ RANDOM_@@ NUMBER_@@ FROM_@@ STREAM_@@ WITH_@@ O@@ 1@@ _SPACE | def select@@ Random ( x ) : NEW_LINE INDENT res = 0 ; NEW_LINE count = 0 ; NEW_LINE count += 1 ; NEW_LINE if ( count == 1 ) : NEW_LINE INDENT res = x ; NEW_LINE DEDENT else : NEW_LINE INDENT i = random . randrange ( count ) ; NEW_LINE if ( i == count - 1 ) : NEW_LINE INDENT res = x ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT
HO@@ SO@@ Y@@ AS_@@ TRI@@ ANGLE | def print@@ Ho@@ so@@ ya ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT print ( dp [ i ] [ j ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
DISTRIBU@@ TING_@@ M_@@ ITE@@ MS_@@ CI@@ R@@ CLE_@@ SIZE_@@ N_@@ START@@ ING_@@ K_@@ TH_@@ POSITION | def last@@ Position ( n , m , k ) : NEW_LINE INDENT if ( m <= n - k + 1 ) : NEW_LINE INDENT return m + k - 1 NEW_LINE DEDENT m = m - ( n - k + 1 ) NEW_LINE if ( m % n == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT return m % n NEW_LINE DEDENT DEDENT
PRINT@@ ING_@@ LON@@ GE@@ ST_@@ INCRE@@ AS@@ ING_@@ CON@@ SEC@@ UTI@@ VE_@@ SUB@@ SEQUENCE | def lon@@ gest@@ Sub@@ sequence ( a , n ) : NEW_LINE INDENT mp = { i : 0 for i in range ( 13 ) } NEW_LINE dp = [ 0 for i in range ( n ) ] NEW_LINE maximum = - sys . maxsize - 1 NEW_LINE index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] - 1 ) in mp ) : NEW_LINE INDENT lastIndex = mp [ a [ i ] - 1 ] - 1 NEW_LINE dp [ i ] = 1 + dp [ lastIndex ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT mp [ a [ i ] ] = i + 1 NEW_LINE if ( maximum < dp [ i ] ) : NEW_LINE INDENT maximum = dp [ i ] NEW_LINE index = i NEW_LINE DEDENT DEDENT for curr in range ( a [ index ] - maximum + 1 , a [ index ] + 1 , 1 ) : NEW_LINE INDENT print ( curr , end = " ▁ " ) NEW_LINE DEDENT DEDENT
NUMBER_OF_@@ TRIANG@@ LES_@@ IN_@@ DIREC@@ TED_@@ AND_@@ UN@@ DIREC@@ TED_@@ GRAP@@ HS | def count@@ Triangle ( g , is@@ Direc@@ ted ) : NEW_LINE INDENT nodes = len ( g ) NEW_LINE count_@@ Triangle = 0 NEW_LINE for i in range ( nodes ) : NEW_LINE INDENT for j in range ( nodes ) : NEW_LINE INDENT for k in range ( nodes ) : NEW_LINE INDENT if ( i != j and i != k and j != k and g [ i ] [ j ] and g [ j ] [ k ] and g [ k ] [ i ] ) : NEW_LINE INDENT count_@@ Triangle += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count_@@ Triangle / 3 if is@@ Direc@@ ted else count_@@ Triangle / 6 NEW_LINE DEDENT
CHECK_@@ GI@@ V@@ EN_@@ ARRAY_@@ CONTAIN@@ S_@@ DUPLIC@@ ATE_@@ ELEMEN@@ TS_@@ WITH@@ IN_@@ K_@@ DISTANCE | def check@@ Duplicate@@ sWith@@ in@@ K ( arr , n , k ) : NEW_LINE INDENT my@@ set = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in my@@ set : NEW_LINE INDENT return True NEW_LINE DEDENT my@@ set . append ( arr [ i ] ) NEW_LINE if ( i >= k ) : NEW_LINE INDENT my@@ set . remove ( arr [ i - k ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
MINIMUM_@@ INSER@@ TION@@ S_S@@ ORT_@@ ARRAY | def min@@ Insertion@@ Step@@ To@@ Sort@@ Array ( arr , N ) : NEW_LINE INDENT lis = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT max = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( max < lis [ i ] ) : NEW_LINE INDENT max = lis [ i ] NEW_LINE DEDENT DEDENT return ( N - max ) NEW_LINE DEDENT
GENERATE_@@ TWO_@@ OUTPUT_@@ STRING@@ S_@@ DEPEND@@ ING_@@ UP@@ ON_@@ OC@@ CURR@@ ENCE_@@ CHARACTER_@@ INPUT_@@ STRING | def print@@ Du@@ o ( string ) : NEW_LINE INDENT count@@ Char = [ 0 for i in range ( MAX_@@ CHAR ) ] NEW_LINE n = len ( string ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count@@ Char [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT str1 = " " NEW_LINE str2 = " " NEW_LINE for i in range ( MAX_@@ CHAR ) : NEW_LINE INDENT if ( count@@ Char [ i ] > 1 ) : NEW_LINE INDENT str2 = str2 + chr ( i + ord ( ' a ' ) ) NEW_LINE DEDENT elif ( count@@ Char [ i ] == 1 ) : NEW_LINE INDENT str1 = str1 + chr ( i + ord ( ' a ' ) ) NEW_LINE DEDENT DEDENT print ( " String ▁ with ▁ characters ▁ occur@@ ring ▁ once : " , " \n " , str1 ) NEW_LINE print ( " String ▁ with ▁ characters ▁ occur@@ ring " , " multiple ▁ times : " , " \n " , str2 ) NEW_LINE DEDENT
NUMBER_@@ DIG@@ IT@@ S_@@ PRODUCT_@@ TWO_@@ NUMB@@ ERS_@@ 1 | def count@@ Digits ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return math . floor ( math . log10 ( abs ( a ) ) + math . log10 ( abs ( b ) ) ) + 1 NEW_LINE DEDENT
TOTAL_@@ NUMBER_OF_@@ NON_@@ DECRE@@ AS@@ ING_@@ NUMB@@ ERS_@@ WITH_@@ N_@@ DIG@@ IT@@ S_@@ 1 | def count@@ Non@@ Decre@@ asing ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count = int ( count * ( N + i - 1 ) ) NEW_LINE count = int ( count / i ) NEW_LINE DEDENT return count NEW_LINE DEDENT
COUNT_@@ STRING@@ S_@@ AD@@ J@@ AC@@ ENT_@@ CHARAC@@ TER@@ S_@@ DIFF@@ ER@@ ENCE_@@ ONE | def count@@ Str@@ s ( n ) : NEW_LINE INDENT dp = [ [ 0 for j in range ( 27 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , 26 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , 26 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( 0 , 26 ) : NEW_LINE INDENT sum = sum + dp [ n ] [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
PROGRAM_@@ TO_@@ EF@@ FI@@ CI@@ EN@@ TL@@ Y_@@ CAL@@ CUL@@ ATE_@@ EX | def exponential ( n , x ) : NEW_LINE INDENT sum = 1.0 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT sum = 1 + x * sum / i NEW_LINE DEDENT print ( " e ^ x ▁ = " , sum ) NEW_LINE DEDENT
EF@@ FI@@ CI@@ EN@@ TL@@ Y_@@ COMP@@ UTE_@@ SUM@@ S_@@ OF_@@ DIAG@@ ON@@ AL@@ S_@@ OF_@@ A_@@ MATRIX_@@ 1 | def print@@ Diag@@ onal@@ Sum@@ s ( mat , n ) : NEW_LINE INDENT principal = 0 NEW_LINE secondary = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT principal += mat [ i ] [ i ] NEW_LINE secondary += mat [ i ] [ n - i - 1 ] NEW_LINE DEDENT print ( " Principal ▁ Diagonal : " , principal ) NEW_LINE print ( " Secondary ▁ Diagonal : " , secondary ) NEW_LINE DEDENT
PRINT_@@ WAY@@ S_@@ BREAK_@@ STRING_@@ BRAC@@ KET_@@ FORM | def find@@ Combin@@ ations ( string , index , out ) : NEW_LINE INDENT if index == len ( string ) : NEW_LINE INDENT print ( out ) NEW_LINE DEDENT for i in range ( index , len ( string ) , 1 ) : NEW_LINE INDENT find@@ Combin@@ ations ( string , i + 1 , out + " ( " + string [ index : i + 1 ] + " ) " ) NEW_LINE DEDENT DEDENT
LINE@@ AR@@ _SEARCH | def search ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT
FIND_@@ THE_@@ ELEMENT_@@ TH@@ AT_@@ AP@@ PE@@ AR@@ S_@@ ON@@ CE_@@ 2 | def single@@ Number ( nums ) : NEW_LINE INDENT return ( 3 * sum ( set ( nums ) ) - sum ( nums ) ) / 2 NEW_LINE DEDENT
SEARCH_@@ AL@@ MO@@ ST@@ _S@@ OR@@ TED_@@ ARRAY | def binary@@ Search ( arr , l , r , x ) : NEW_LINE INDENT if ( r >= l ) : NEW_LINE INDENT mid = int ( l + ( r - l ) / 2 ) NEW_LINE if ( arr [ mid ] == x ) : return mid NEW_LINE if ( mid > l and arr [ mid - 1 ] == x ) : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if ( mid < r and arr [ mid + 1 ] == x ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( arr [ mid ] > x ) : NEW_LINE INDENT return binary@@ Search ( arr , l , mid - 2 , x ) NEW_LINE DEDENT return binary@@ Search ( arr , mid + 2 , r , x ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
E@@ UL@@ ERS_@@ TO@@ TI@@ ENT_@@ FUNCTION_@@ FOR_@@ ALL_@@ NUMBER@@ S_S@@ MAL@@ LER_@@ TH@@ AN_@@ OR_@@ EQUAL_@@ TO_@@ N | def compute@@ To@@ ti@@ ent ( n ) : NEW_LINE INDENT phi = [ ] NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT phi . append ( 0 ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " To@@ ti@@ ent ▁ of ▁ " , i , " ▁ is ▁ " , phi [ i ] ) NEW_LINE DEDENT DEDENT
FIND_@@ MINIMUM_@@ NUMBER_@@ DI@@ VIDE@@ D_@@ MAKE_@@ NUMBER_@@ PER@@ F@@ ECT_@@ SQUARE | def find@@ Min@@ Number ( n ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT count += 1 NEW_LINE n /@@ /= 2 NEW_LINE DEDENT if count % 2 is not 0 : NEW_LINE INDENT ans *= 2 NEW_LINE DEDENT for i in range ( 3 , ( int ) ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT count = 0 NEW_LINE while n % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE n /@@ /= i NEW_LINE DEDENT if count % 2 is not 0 : NEW_LINE INDENT ans *= i NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT ans *= n NEW_LINE DEDENT return ans NEW_LINE DEDENT
COUNT_@@ NUMBER_@@ WAY@@ S_@@ JUM@@ P_@@ REACH_@@ END | def count@@ Way@@ sTo@@ Jump ( arr , n ) : NEW_LINE INDENT count_@@ jump = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT count_@@ jump [ i ] += 1 NEW_LINE DEDENT j = i + 1 NEW_LINE while ( j < n - 1 and j <= arr [ i ] + i ) : NEW_LINE INDENT if ( count_@@ jump [ j ] != - 1 ) : NEW_LINE INDENT count_@@ jump [ i ] += count_@@ jump [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( count_@@ jump [ i ] == 0 ) : NEW_LINE INDENT count_@@ jump [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( count_@@ jump [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
CONVERT_@@ SUB@@ STRING@@ S_@@ LENGTH_@@ K_@@ BASE_@@ B_@@ DECIMAL_@@ 1 | def sub@@ string@@ Conversions ( str1 , k , b ) : NEW_LINE INDENT for i in range ( 0 , len ( str1 ) - k + 1 ) : NEW_LINE INDENT sub = str1 [ i : k + i ] NEW_LINE Sum = 0 NEW_LINE counter = 0 NEW_LINE for i in range ( len ( sub ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT Sum = ( Sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) ) NEW_LINE counter += 1 NEW_LINE DEDENT print ( Sum , end = " ▁ " ) NEW_LINE DEDENT DEDENT
TWO_@@ ELEMEN@@ TS_@@ WHO@@ SE_@@ S@@ UM_@@ IS_@@ CLO@@ SE@@ ST_@@ TO_@@ ZERO | def min@@ Abs@@ Sum@@ Pair ( arr , arr_@@ size ) : NEW_LINE INDENT inv_@@ count = 0 NEW_LINE if arr_@@ size < 2 : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return NEW_LINE DEDENT min_@@ l = 0 NEW_LINE min_@@ r = 1 NEW_LINE min_@@ sum = arr [ 0 ] + arr [ 1 ] NEW_LINE for l in range ( 0 , arr_@@ size - 1 ) : NEW_LINE INDENT for r in range ( l + 1 , arr_@@ size ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if abs ( min_@@ sum ) > abs ( sum ) : NEW_LINE INDENT min_@@ sum = sum NEW_LINE min_@@ l = l NEW_LINE min_@@ r = r NEW_LINE DEDENT DEDENT DEDENT print ( " The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are " , arr [ min_@@ l ] , " and ▁ " , arr [ min_@@ r ] ) NEW_LINE DEDENT
HO@@ W_@@ TO_@@ PRINT_@@ MAXIMUM_@@ NUMBER_OF_@@ A_@@ USING_@@ GI@@ V@@ EN_@@ FOUR_@@ KEYS | def find@@ optimal ( N ) : NEW_LINE INDENT if ( N <= 6 ) : NEW_LINE INDENT return N NEW_LINE DEDENT screen = [ 0 ] * N NEW_LINE for n in range ( 1 , 7 ) : NEW_LINE INDENT screen [ n - 1 ] = n NEW_LINE DEDENT for n in range ( 7 , N + 1 ) : NEW_LINE INDENT screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; NEW_LINE DEDENT return screen [ N - 1 ] NEW_LINE DEDENT
PROGRAM_@@ DECIMAL_@@ BINARY_@@ CON@@ VERSION_@@ 2 | def decimal@@ To@@ Binary ( N ) : NEW_LINE INDENT B_@@ Number = 0 NEW_LINE cnt = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT rem = N % 2 NEW_LINE c = pow ( 10 , cnt ) NEW_LINE B_@@ Number += rem * c NEW_LINE N /@@ /= 2 NEW_LINE cnt += 1 NEW_LINE DEDENT return B_@@ Number NEW_LINE DEDENT
COUN@@ TS_@@ PATH@@ S_@@ POINT_@@ REACH_@@ ORIG@@ IN_@@ 1 | def count@@ Paths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( count@@ Paths ( n - 1 , m ) + count@@ Paths ( n , m - 1 ) ) NEW_LINE DEDENT
S@@ UM_@@ ELEMEN@@ TS_@@ K@@ 1@@ TH_@@ K@@ 2@@ TH@@ _S@@ MAL@@ LE@@ ST_@@ ELEMENTS | def sum@@ Between@@ Two@@ K@@ th ( arr , n , k1 , k2 ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE result = 0 NEW_LINE for i in range ( k1 , k2 - 1 ) : NEW_LINE INDENT result += arr [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
SM@@ ALLE@@ ST@@ _SUB@@ ARRAY_@@ K_@@ DISTIN@@ CT_@@ NUMB@@ ERS | def min@@ Range ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = [ ] NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT s . append ( arr [ j ] ) NEW_LINE if ( len ( s ) == k ) : NEW_LINE INDENT if ( ( j - i ) < ( r - l ) ) : NEW_LINE INDENT r = j NEW_LINE l = i NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT if ( j == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( l == 0 and r == n ) : NEW_LINE INDENT print ( " Invalid ▁ k " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l , r ) NEW_LINE DEDENT DEDENT
AREA_@@ OF_@@ A_@@ HEX@@ AG@@ ON | def hex@@ ag@@ on@@ Area ( s ) : NEW_LINE INDENT return ( ( 3 * math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ; NEW_LINE DEDENT
NEXT_@@ POWER_@@ OF_@@ 2_2 | def next@@ PowerOf@@ 2 ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT
COUNT_@@ SUB@@ STRING@@ S_@@ BINARY_@@ STRING_@@ CONTAIN@@ ING_@@ K_@@ ONE@@ S | def count@@ Of@@ Sub@@ string@@ With@@ K@@ Ones ( s , K ) : NEW_LINE INDENT N = len ( s ) NEW_LINE res = 0 NEW_LINE count@@ Of@@ One = 0 NEW_LINE freq = [ 0 for i in range ( N + 1 ) ] NEW_LINE freq [ 0 ] = 1 NEW_LINE for i in range ( 0 , N , 1 ) : NEW_LINE INDENT count@@ Of@@ One += ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( count@@ Of@@ One >= K ) : NEW_LINE INDENT res += freq [ count@@ Of@@ One - K ] NEW_LINE DEDENT freq [ count@@ Of@@ One ] += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
NUMBER_@@ INDEX@@ ES_@@ EQUAL_@@ ELEMEN@@ TS_@@ GI@@ V@@ EN_@@ RANGE | def answer_@@ query ( a , n , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
CHECK_@@ WHE@@ THER_@@ NUMBER_@@ DUC@@ K_@@ NUMBER_@@ NOT | def check_@@ du@@ ck ( num ) : NEW_LINE INDENT l = len ( num ) NEW_LINE count_@@ zero = 0 NEW_LINE i = 1 NEW_LINE while i < l : NEW_LINE INDENT ch = num [ i ] NEW_LINE if ( ch == "0" ) : NEW_LINE INDENT count_@@ zero = count_@@ zero + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return count_@@ zero NEW_LINE DEDENT
NUMBER_@@ NON_@@ NEGATIVE_@@ INTEGR@@ AL_S@@ OL@@ U@@ TIONS_@@ B_@@ C_@@ N_@@ 1 | def count@@ Integr@@ al@@ Solutions ( n ) : NEW_LINE INDENT return int ( ( ( n + 1 ) * ( n + 2 ) ) / 2 ) NEW_LINE DEDENT
MAXIMUM_@@ PROFI@@ T_@@ BY_@@ BU@@ Y@@ ING_@@ AND@@ _S@@ EL@@ LING_@@ A@@ _SH@@ ARE_@@ AT_@@ MO@@ ST_@@ K_@@ TIME@@ S_@@ 1 | def max@@ Pro@@ fit ( price , n , k ) : NEW_LINE INDENT pro@@ fit = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT prev@@ Diff = float ( ' - inf ' ) NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT prev@@ Diff = max ( prev@@ Diff , pro@@ fit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) NEW_LINE pro@@ fit [ i ] [ j ] = max ( pro@@ fit [ i ] [ j - 1 ] , price [ j ] + prev@@ Diff ) NEW_LINE DEDENT DEDENT return pro@@ fit [ k ] [ n - 1 ] NEW_LINE DEDENT
COUNT_@@ CHARAC@@ TER@@ S_@@ POSITION_@@ ENGLI@@ SH_@@ ALPH@@ AB@@ E@@ TS | def find@@ Count ( str ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ( i == ord ( str [ i ] ) - ord ( ' a ' ) ) or ( i == ord ( str [ i ] ) - ord ( ' A ' ) ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
COUNT_@@ GF@@ G@@ _SUB@@ SEQU@@ EN@@ CES_@@ GI@@ V@@ EN_@@ STRING | def count@@ Sub@@ sequence ( s , n ) : NEW_LINE INDENT cnt@@ G = 0 NEW_LINE cnt@@ F = 0 NEW_LINE result = 0 NEW_LINE C = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' G ' ) : NEW_LINE INDENT cnt@@ G += 1 NEW_LINE result += C NEW_LINE continue NEW_LINE DEDENT if ( s [ i ] == ' F ' ) : NEW_LINE INDENT cnt@@ F += 1 NEW_LINE C += cnt@@ G NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
FIN@@ D_S@@ MAL@@ LE@@ ST_@@ VALUE_@@ RE@@ PRESEN@@ TE@@ D_S@@ UM@@ _SUB@@ SET_@@ GI@@ V@@ EN_@@ ARRAY | def find@@ S@@ malle@@ st ( arr , n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] <= res : NEW_LINE INDENT res = res + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
MAXIMUM_@@ POINT@@ S_@@ COLLEC@@ TED_@@ BY_@@ TWO_@@ PER@@ SON@@ S_@@ ALLOWED_@@ TO_@@ ME@@ ET_@@ ONCE | def find@@ Max@@ Points ( A ) : NEW_LINE INDENT P1@@ S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE P@@ 1E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE P2@@ S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE P2@@ E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT P1@@ S [ i ] [ j ] = max ( P1@@ S [ i - 1 ] [ j ] , P1@@ S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT for j in range ( M , 0 , - 1 ) : NEW_LINE INDENT P@@ 1E [ i ] [ j ] = max ( P@@ 1E [ i + 1 ] [ j ] , P@@ 1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT P2@@ S [ i ] [ j ] = max ( P2@@ S [ i + 1 ] [ j ] , P2@@ S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( M , 0 , - 1 ) : NEW_LINE INDENT P2@@ E [ i ] [ j ] = max ( P2@@ E [ i - 1 ] [ j ] , P2@@ E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT for j in range ( 2 , M ) : NEW_LINE INDENT op1 = P1@@ S [ i ] [ j - 1 ] + P@@ 1E [ i ] [ j + 1 ] + \ NEW_LINE INDENT P2@@ S [ i + 1 ] [ j ] + P2@@ E [ i - 1 ] [ j ] NEW_LINE DEDENT op2 = P1@@ S [ i - 1 ] [ j ] + P@@ 1E [ i + 1 ] [ j ] + \ NEW_LINE INDENT P2@@ S [ i ] [ j - 1 ] + P2@@ E [ i ] [ j + 1 ] NEW_LINE DEDENT ans = max ( ans , max ( op1 , op2 ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
PROGRAM_@@ FIND_@@ CIRCUM@@ FER@@ ENCE_@@ CIRC@@ LE | def circum@@ ference ( r ) : NEW_LINE INDENT return ( 2 * PI * r ) NEW_LINE DEDENT
QU@@ ICK@@ LY_@@ FIND_@@ MULTIPLE_@@ LEFT_@@ ROTA@@ TIONS_@@ OF_@@ AN_@@ ARRAY | def left@@ Rotate ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , k + n ) : NEW_LINE INDENT print ( str ( arr [ i % n ] ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT
MIN@@ IM@@ UM@@ _S@@ UM_@@ CHO@@ OS@@ ING_@@ MINIMUM_@@ PAIR@@ S_@@ ARRAY | def min@@ Sum ( A ) : NEW_LINE INDENT min_@@ val = min ( A ) ; NEW_LINE return min_@@ val * ( len ( A ) - 1 ) NEW_LINE DEDENT
RECUR@@ SIVE_@@ PROGRAM_@@ PRI@@ ME_@@ NUMBER | def is@@ Prime ( n , i = 2 ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return True if ( n == 2 ) else False NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i * i > n ) : NEW_LINE INDENT return true NEW_LINE DEDENT return is@@ Prime ( n , i + 1 ) NEW_LINE DEDENT
SPAR@@ SE_@@ SEARCH | def sparse@@ Search ( arr , key , low , high ) : NEW_LINE INDENT left = 0 ; right = 0 NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if arr [ mid ] == ' ' : NEW_LINE INDENT left = mid - 1 NEW_LINE right = mid + 1 NEW_LINE if left < low and right > high : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif right <= high and arr [ right ] != ' ' : NEW_LINE INDENT mid = right NEW_LINE DEDENT elif left >= low and arr [ left ] != ' ' : NEW_LINE INDENT mid = left NEW_LINE DEDENT DEDENT if arr [ mid ] == key : NEW_LINE INDENT print ( ' Found ▁ string ▁ { } ▁ at ▁ index ▁ { } ' . format ( arr [ mid ] , mid ) ) NEW_LINE return NEW_LINE DEDENT elif arr [ mid ] > key : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT elif arr [ mid ] < key : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT left -= 1 NEW_LINE right += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
FIND_@@ NUMBER_@@ TIME@@ S_@@ STRING_@@ OC@@ CUR@@ S_@@ GI@@ V@@ EN_@@ STRING | def count ( a , b , m , n ) : NEW_LINE INDENT if ( ( m == 0 and n == 0 ) or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a [ m - 1 ] == b [ n - 1 ] ) : NEW_LINE INDENT return ( count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return count ( a , b , m - 1 , n ) NEW_LINE DEDENT DEDENT
PROGRAM_@@ CHECK_@@ ARRA@@ Y_S@@ OR@@ TED_@@ NOT_@@ ITER@@ ATI@@ VE_@@ RECUR@@ SIVE_@@ 1 | def array@@ Sorted@@ Or@@ Not ( arr , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
FIND_@@ INDEX_@@ 0_@@ REPL@@ AC@@ ED_@@ 1_@@ GET_@@ LON@@ GE@@ ST_@@ CONTINU@@ OU@@ S@@ _SEQU@@ ENCE_@@ 1@@ S_@@ BINARY_@@ ARRAY | def max@@ One@@ sIndex ( arr , n ) : NEW_LINE INDENT max_@@ count = 0 NEW_LINE max_@@ index = 0 NEW_LINE prev_@@ zero = - 1 NEW_LINE prev_@@ prev_@@ zero = - 1 NEW_LINE for curr in range ( n ) : NEW_LINE INDENT if ( arr [ curr ] == 0 ) : NEW_LINE INDENT if ( curr - prev_@@ prev_@@ zero > max_@@ count ) : NEW_LINE INDENT max_@@ count = curr - prev_@@ prev_@@ zero NEW_LINE max_@@ index = prev_@@ zero NEW_LINE DEDENT prev_@@ prev_@@ zero = prev_@@ zero NEW_LINE prev_@@ zero = curr NEW_LINE DEDENT DEDENT if ( n - prev_@@ prev_@@ zero > max_@@ count ) : NEW_LINE INDENT max_@@ index = prev_@@ zero NEW_LINE DEDENT return max_@@ index NEW_LINE DEDENT
FIND_@@ MAXIMUM_@@ PRODUCT_@@ OF_@@ A_@@ TR@@ IP@@ LET_@@ IN_@@ ARRAY_@@ 1 | def max@@ Product ( arr , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) NEW_LINE DEDENT
COORDIN@@ ATE@@ S_@@ REC@@ TAN@@ GLE_@@ GI@@ V@@ EN_@@ POINT@@ S_@@ LI@@ E_@@ INS@@ IDE | def print@@ Rect ( X , Y , n ) : NEW_LINE INDENT X@@ max = max ( X ) NEW_LINE X@@ min = min ( X ) NEW_LINE Y@@ max = max ( Y ) NEW_LINE Y@@ min = min ( Y ) NEW_LINE print ( " { " , X@@ min , " , ▁ " , Y@@ min , " } " , sep = " " ) NEW_LINE print ( " { " , X@@ min , " , ▁ " , Y@@ max , " } " , sep = " " ) NEW_LINE print ( " { " , X@@ max , " , ▁ " , Y@@ max , " } " , sep = " " ) NEW_LINE print ( " { " , X@@ max , " , ▁ " , Y@@ min , " } " , sep = " " ) NEW_LINE DEDENT
COUNT_@@ BINARY_@@ DIG@@ IT_@@ NUMBER@@ S_S@@ MAL@@ LER_@@ N | def count@@ Of@@ Binary@@ Number@@ LessThan@@ N ( N ) : NEW_LINE INDENT q = deque ( ) NEW_LINE q . append ( 1 ) NEW_LINE cnt = 0 NEW_LINE while ( q ) : NEW_LINE INDENT t = q . pop@@ left ( ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE q . append ( t * 10 ) NEW_LINE q . append ( t * 10 + 1 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
CONVERT_@@ DECIMAL_@@ FR@@ ACTION_@@ BINARY_@@ NUMBER | def decimal@@ To@@ Binary ( num , k_@@ prec ) : NEW_LINE INDENT binary = " " NEW_LINE Integral = int ( num ) NEW_LINE fractional = num - Integral NEW_LINE while ( Integral ) : NEW_LINE INDENT rem = Integral % 2 NEW_LINE binary += str ( rem ) ; NEW_LINE Integral /@@ /= 2 NEW_LINE DEDENT binary = binary [ : : - 1 ] NEW_LINE binary += ' . ' NEW_LINE while ( k_@@ prec ) : NEW_LINE INDENT fractional *= 2 NEW_LINE fr@@ act_@@ bit = int ( fractional ) NEW_LINE if ( fr@@ act_@@ bit == 1 ) : NEW_LINE INDENT fractional -= fr@@ act_@@ bit NEW_LINE binary += '1' NEW_LINE DEDENT else : NEW_LINE INDENT binary += '0' NEW_LINE DEDENT k_@@ prec -= 1 NEW_LINE DEDENT return binary NEW_LINE DEDENT
MAXIMUM_@@ NUMBER_OF_@@ TRAI@@ LING_@@ ZER@@ OS_@@ IN_@@ THE_@@ PRODUCT_@@ OF_THE_@@ SUB@@ SE@@ TS_@@ OF@@ _SIZE_@@ K | def maximum@@ Zeros ( arr , n , k ) : NEW_LINE INDENT global MAX@@ 5 NEW_LINE subset = [ [ - 1 ] * ( MAX@@ 5 + 5 ) for _ in range ( k + 1 ) ] NEW_LINE subset [ 0 ] [ 0 ] = 0 NEW_LINE for p in arr : NEW_LINE INDENT pw@@ 2 , pw@@ 5 = 0 , 0 NEW_LINE while not p % 2 : NEW_LINE INDENT pw@@ 2 += 1 NEW_LINE p /@@ /= 2 NEW_LINE DEDENT while not p % 5 : NEW_LINE INDENT pw@@ 5 += 1 NEW_LINE p /@@ /= 5 NEW_LINE DEDENT for i in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( MAX@@ 5 ) : NEW_LINE INDENT if subset [ i ] [ j ] != - 1 : NEW_LINE INDENT subset [ i + 1 ] [ j + pw@@ 5 ] = ( max ( subset [ i + 1 ] [ j + pw@@ 5 ] , ( subset [ i ] [ j ] + pw@@ 2 ) ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( MAX@@ 5 ) : NEW_LINE INDENT ans = max ( ans , min ( i , subset [ k ] [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
SEARCH_@@ AN_@@ ELEMENT_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ AND_@@ PI@@ VO@@ TED_@@ ARRAY | def search ( arr , l , h , key ) : NEW_LINE INDENT if l > h : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( l + h ) // 2 NEW_LINE if arr [ mid ] == key : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ l ] <= arr [ mid ] : NEW_LINE INDENT if key >= arr [ l ] and key <= arr [ mid ] : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT if key >= arr [ mid ] and key <= arr [ h ] : NEW_LINE INDENT return search ( a , mid + 1 , h , key ) NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT
PROGRAM_@@ FIND_@@ AREA_@@ CIRC@@ UL@@ AR@@ _SEG@@ MENT | def area_@@ of_@@ segment ( radius , angle ) : NEW_LINE INDENT area_@@ of_@@ sector = pi * NEW_LINE INDENT ( radius * radius ) NEW_LINE * ( angle / 360 ) NEW_LINE DEDENT area_@@ of_@@ triangle = 1 / 2 * NEW_LINE INDENT ( radius * radius ) * NEW_LINE math . sin ( ( angle * pi ) / 180 ) NEW_LINE DEDENT return area_@@ of_@@ sector - area_@@ of_@@ triangle ; NEW_LINE DEDENT
K@@ _S@@ MAL@@ LE@@ ST_@@ ELEMEN@@ TS_@@ ORDER_@@ USING_@@ O@@ 1_@@ EX@@ TRA@@ _SPACE | def print@@ Small ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , n ) : NEW_LINE INDENT max_@@ var = arr [ k - 1 ] NEW_LINE pos = k - 1 NEW_LINE for j in range ( k - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] > max_@@ var ) : NEW_LINE INDENT max_@@ var = arr [ j ] NEW_LINE pos = j NEW_LINE DEDENT DEDENT if ( max_@@ var > arr [ i ] ) : NEW_LINE INDENT j = pos NEW_LINE while ( j < k - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE j += 1 NEW_LINE DEDENT arr [ k - 1 ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
N@@ TH_@@ NON_@@ FI@@ BON@@ ACC@@ I_@@ NUMBER | def non@@ Fi@@ bon@@ ac@@ ci ( n ) : NEW_LINE INDENT prev@@ Prev = 1 NEW_LINE prev = 2 NEW_LINE curr = 3 NEW_LINE while n > 0 : NEW_LINE INDENT prev@@ Prev = prev NEW_LINE prev = curr NEW_LINE curr = prev@@ Prev + prev NEW_LINE n = n - ( curr - prev - 1 ) NEW_LINE DEDENT n = n + ( curr - prev - 1 ) NEW_LINE return prev + n NEW_LINE DEDENT
ANALY@@ SI@@ S_@@ OF_@@ ALGORITH@@ MS@@ _SET_@@ 2_@@ A@@ SYM@@ P@@ TO@@ TIC_@@ ANALY@@ SIS | def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE for i in range ( i , n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Z@@ EC@@ K@@ END@@ OR@@ FS_@@ THE@@ O@@ RE@@ M_@@ NON_@@ NEIGH@@ BO@@ UR@@ ING_@@ FI@@ BON@@ ACC@@ I_@@ RE@@ PRESEN@@ TATION | def nearest@@ Small@@ er@@ Eq@@ Fi@@ b ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT f1 , f2 , f3 = 0 , 1 , 1 NEW_LINE while ( f3 <= n ) : NEW_LINE INDENT f1 = f2 ; NEW_LINE f2 = f3 ; NEW_LINE f3 = f1 + f2 ; NEW_LINE DEDENT return f2 ; NEW_LINE DEDENT
PRINT_@@ MAX@@ IM@@ UM@@ _SH@@ OR@@ TEST_@@ DISTANCE | def find_@@ maximum ( a , n , k ) : NEW_LINE INDENT b = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE d = min ( 1 + i , n - i ) NEW_LINE if x not in b . keys ( ) : NEW_LINE INDENT b [ x ] = d NEW_LINE DEDENT else : NEW_LINE INDENT b [ x ] = min ( d , b [ x ] ) NEW_LINE DEDENT DEDENT ans = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE if ( x != ( k - x ) and ( k - x ) in b . keys ( ) ) : NEW_LINE INDENT ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
GENER@@ ATING_@@ DISTIN@@ CT_@@ SUB@@ SEQU@@ EN@@ CES_@@ OF_@@ A_@@ GI@@ V@@ EN_@@ STRING_@@ IN_@@ LE@@ XI@@ CO@@ GRAP@@ HI@@ C_@@ ORDER | def generate ( st , s ) : NEW_LINE INDENT if len ( s ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT if s not in st : NEW_LINE INDENT st . add ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT t = list ( s ) . copy ( ) NEW_LINE t . remove ( s [ i ] ) NEW_LINE t = ' ' . join ( t ) NEW_LINE generate ( st , t ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
WRITE_@@ Y@@ OU@@ _@@ OW@@ N_@@ POWER_@@ WITH@@ OUT_@@ USING_@@ MULTIP@@ LIC@@ ATION_@@ AND_@@ DI@@ VISION | def pow ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT answer = a NEW_LINE increment = a NEW_LINE for i in range ( 1 , b ) : NEW_LINE INDENT for j in range ( 1 , a ) : NEW_LINE INDENT answer += increment NEW_LINE DEDENT increment = answer NEW_LINE DEDENT return answer NEW_LINE DEDENT
MAXI@@ MI@@ ZE_@@ VOLUME_@@ CU@@ BO@@ ID_@@ GI@@ VEN@@ _S@@ UM@@ _SI@@ DES_@@ 1 | def max@@ volume ( s ) : NEW_LINE INDENT length = int ( s / 3 ) NEW_LINE s -= length NEW_LINE bread@@ th = s / 2 NEW_LINE height = s - bread@@ th NEW_LINE return int ( length * bread@@ th * height ) NEW_LINE DEDENT
HOR@@ NE@@ RS_@@ METHOD_@@ POLY@@ NO@@ MI@@ AL_@@ EVALU@@ ATION | def hor@@ ner ( poly , n , x ) : NEW_LINE INDENT result = poly [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT result = result * x + poly [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
MINIMUM_@@ TIME_@@ REQUIRED_@@ PRODUC@@ E_@@ M_@@ ITEMS | def min@@ Time ( arr , n , m ) : NEW_LINE INDENT t = 0 NEW_LINE while ( 1 ) : NEW_LINE INDENT items = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT items += ( t // arr [ i ] ) NEW_LINE DEDENT if ( items >= m ) : NEW_LINE INDENT return t NEW_LINE DEDENT t += 1 NEW_LINE DEDENT DEDENT
FIND_@@ DIFF@@ ER@@ ENCE_@@ BETWE@@ EN@@ _S@@ UM@@ S_@@ OF_@@ TWO_@@ DIAG@@ ON@@ ALS | def difference ( arr , n ) : NEW_LINE INDENT d1 = 0 NEW_LINE d2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT d1 += arr [ i ] [ j ] NEW_LINE DEDENT if ( i == n - j - 1 ) : NEW_LINE INDENT d2 += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return abs ( d1 - d2 ) ; NEW_LINE DEDENT
SHOR@@ TEST_@@ UN@@ COMM@@ ON@@ _SUB@@ SEQUENCE | def shor@@ test@@ Seq ( S : list , T : list ) : NEW_LINE INDENT m = len ( S ) NEW_LINE n = len ( T ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = MAX NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT ch = S [ i - 1 ] NEW_LINE k = j - 1 NEW_LINE while k >= 0 : NEW_LINE INDENT if T [ k ] == ch : NEW_LINE INDENT break NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT if k == - 1 : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT ans = dp [ m ] [ n ] NEW_LINE if ans >= MAX : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
MIN_@@ FLI@@ PS_@@ OF_@@ CONTINU@@ OUS_@@ CHARAC@@ TER@@ S_TO_@@ MAKE_@@ ALL_@@ CHARAC@@ TER@@ S_S@@ AME_@@ IN_@@ A_@@ STRING | def find@@ Fli@@ ps ( str , n ) : NEW_LINE INDENT last = ' ▁ ' NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( last != str [ i ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT last = str [ i ] NEW_LINE DEDENT return res // 2 NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 28@@ _@@ MINIMUM_@@ INSER@@ TIONS_@@ TO_@@ FORM_@@ A_@@ PA@@ LIN@@ DRO@@ ME | def find@@ Min@@ Inser@@ tions ( str , l , h ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( l == h ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l == h - 1 ) : NEW_LINE INDENT return 0 if ( str [ l ] == str [ h ] ) else 1 NEW_LINE DEDENT if ( str [ l ] == str [ h ] ) : NEW_LINE INDENT return find@@ Min@@ Inser@@ tions ( str , l + 1 , h - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( min ( find@@ Min@@ Inser@@ tions ( str , l , h - 1 ) , find@@ Min@@ Inser@@ tions ( str , l + 1 , h ) ) + 1 ) NEW_LINE DEDENT DEDENT
COUNT_@@ CHARAC@@ TER@@ S_@@ STRING_@@ DISTAN@@ CE_@@ ENGLI@@ SH_@@ ALPH@@ AB@@ E@@ TS | def count@@ Pairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ] ) ) == abs ( i - j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT
MULTI@@ STAGE_@@ GRAP@@ H@@ _SH@@ OR@@ TEST_@@ PATH | def shor@@ test@@ Dist ( graph ) : NEW_LINE INDENT global INF NEW_LINE dist = [ 0 ] * N NEW_LINE dist [ N - 1 ] = 0 NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT dist [ i ] = INF NEW_LINE for j in range ( N ) : NEW_LINE INDENT if graph [ i ] [ j ] == INF : NEW_LINE INDENT continue NEW_LINE DEDENT dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) NEW_LINE DEDENT DEDENT return dist [ 0 ] NEW_LINE DEDENT
MAX@@ IM@@ UM@@ _SIZE_@@ SUB_@@ MATRIX_@@ WITH_@@ ALL_@@ 1@@ S_IN_@@ A_@@ BINARY_@@ MATRIX | def print@@ Max@@ Sub@@ Square ( M ) : NEW_LINE INDENT R = len ( M ) NEW_LINE C = len ( M [ 0 ] ) NEW_LINE S = [ [ 0 for k in range ( C ) ] for l in range ( R ) ] NEW_LINE for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT if ( M [ i ] [ j ] == 1 ) : NEW_LINE INDENT S [ i ] [ j ] = min ( S [ i ] [ j - 1 ] , S [ i - 1 ] [ j ] , S [ i - 1 ] [ j - 1 ] ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT S [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT max_@@ of_@@ s = S [ 0 ] [ 0 ] NEW_LINE max_@@ i = 0 NEW_LINE max_@@ j = 0 NEW_LINE for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT if ( max_@@ of_@@ s < S [ i ] [ j ] ) : NEW_LINE INDENT max_@@ of_@@ s = S [ i ] [ j ] NEW_LINE max_@@ i = i NEW_LINE max_@@ j = j NEW_LINE DEDENT DEDENT DEDENT print ( " Maximum ▁ size ▁ sub - matrix ▁ is : ▁ " ) NEW_LINE for i in range ( max_@@ i , max_@@ i - max_@@ of_@@ s , - 1 ) : NEW_LINE INDENT for j in range ( max_@@ j , max_@@ j - max_@@ of_@@ s , - 1 ) : NEW_LINE INDENT print ( M [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT DEDENT
GI@@ VEN@@ _S@@ OR@@ TED_@@ ARRAY_@@ NUMBER_@@ X_@@ FIND_@@ PA@@ IR_@@ ARRAY_@@ WHO@@ SE_@@ S@@ UM_@@ CLO@@ SE@@ ST_@@ X | def print@@ Close@@ st ( arr , n , x ) : NEW_LINE INDENT res_@@ l , res_@@ r = 0 , 0 NEW_LINE l , r , diff = 0 , n - 1 , MAX_@@ VAL NEW_LINE while r > l : NEW_LINE INDENT if abs ( arr [ l ] + arr [ r ] - x ) < diff : NEW_LINE INDENT res_@@ l = l NEW_LINE res_@@ r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if arr [ l ] + arr [ r ] > x : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( ' The ▁ closest ▁ pair ▁ is ▁ { } ▁ and ▁ { } ' . format ( arr [ res_@@ l ] , arr [ res_@@ r ] ) ) NEW_LINE DEDENT
SORT_@@ 1_@@ N@@ _SW@@ APP@@ ING_@@ AD@@ J@@ AC@@ ENT_@@ ELEMEN@@ TS_@@ 1 | def sorted@@ After@@ Swap ( A , B , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if B [ i ] : NEW_LINE INDENT if A [ i ] != i + 1 : NEW_LINE INDENT A [ i ] , A [ i + 1 ] = A [ i + 1 ] , A [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if A [ i ] != i + 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
TILE_@@ ST@@ AC@@ KING_@@ PRO@@ BLE@@ M | def possible@@ W@@ ays ( n , m , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] NEW_LINE pres@@ um = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 0 NEW_LINE pres@@ um [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 0 , m + 1 ) : NEW_LINE INDENT pres@@ um [ i ] [ 0 ] = 1 NEW_LINE dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = pres@@ um [ i - 1 ] [ j ] NEW_LINE if j > k : NEW_LINE INDENT dp [ i ] [ j ] -= pres@@ um [ i - 1 ] [ j - k - 1 ] NEW_LINE DEDENT DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT pres@@ um [ i ] [ j ] = dp [ i ] [ j ] + pres@@ um [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
NUMBER_OF_@@ PAIR@@ S_IN_@@ AN_@@ ARRAY_@@ H@@ AV@@ ING_S@@ UM_@@ EQUAL_@@ TO_@@ PRODUCT | def sum@@ Equal@@ Product ( a , n ) : NEW_LINE INDENT zero = 0 NEW_LINE two = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if a [ i ] == 2 : NEW_LINE INDENT two += 1 NEW_LINE DEDENT DEDENT cnt = ( zero * ( zero - 1 ) ) // 2 + \ NEW_LINE INDENT ( two * ( two - 1 ) ) // 2 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 17@@ _@@ PA@@ LIN@@ DRO@@ ME_@@ PARTI@@ TION@@ ING | def min@@ Pal@@ Par@@ tion ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE C = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE P = [ [ False for i in range ( n ) ] for i in range ( n ) ] NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE L = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT P [ i ] [ i ] = True ; NEW_LINE C [ i ] [ i ] = 0 ; NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE if L == 2 : NEW_LINE INDENT P [ i ] [ j ] = ( str [ i ] == str [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT P [ i ] [ j ] = ( ( str [ i ] == str [ j ] ) and P [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT if P [ i ] [ j ] == True : NEW_LINE INDENT C [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = 1@@ 00000000 NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return C [ 0 ] [ n - 1 ] NEW_LINE DEDENT
FIND_@@ ONE_@@ MULTIPLE_@@ REPE@@ ATING_@@ ELEMEN@@ TS_@@ READ_@@ ARRAY | def find@@ Repe@@ ating@@ Number ( arr , n ) : NEW_LINE INDENT sq = sqrt ( n ) NEW_LINE range@@ __ = int ( ( n / sq ) + 1 ) NEW_LINE count = [ 0 for i in range ( range@@ __ ) ] NEW_LINE for i in range ( 0 , n + 1 , 1 ) : NEW_LINE INDENT count [ int ( ( arr [ i ] - 1 ) / sq ) ] += 1 NEW_LINE DEDENT selected_@@ block = range@@ __ - 1 NEW_LINE for i in range ( 0 , range@@ __ - 1 , 1 ) : NEW_LINE INDENT if ( count [ i ] > sq ) : NEW_LINE INDENT selected_@@ block = i NEW_LINE break NEW_LINE DEDENT DEDENT m = { i : 0 for i in range ( n ) } NEW_LINE for i in range ( 0 , n + 1 , 1 ) : NEW_LINE INDENT if ( ( ( selected_@@ block * sq ) < arr [ i ] ) and ( arr [ i ] <= ( ( selected_@@ block + 1 ) * sq ) ) ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE if ( m [ arr [ i ] ] > 1 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT
MIN@@ IM@@ UM@@ _S@@ UM_@@ PATH_@@ TRI@@ ANGLE | def min@@ Sum@@ Path ( A ) : NEW_LINE INDENT memo = [ None ] * len ( A ) NEW_LINE n = len ( A ) - 1 NEW_LINE for i in range ( len ( A [ n ] ) ) : NEW_LINE INDENT memo [ i ] = A [ n ] [ i ] NEW_LINE DEDENT for i in range ( len ( A ) - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( len ( A [ i ] ) ) : NEW_LINE INDENT memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , memo [ j + 1 ] ) ; NEW_LINE DEDENT DEDENT return memo [ 0 ] NEW_LINE DEDENT
HO@@ W_@@ CAN_@@ W@@ E_@@ S@@ UM_@@ THE_@@ DIG@@ IT@@ S_@@ OF_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ IN@@ _SIN@@ GLE_@@ STATE@@ MENT_@@ 1 | def getS@@ um ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
RECUR@@ SION | def print@@ Fun ( test ) : NEW_LINE INDENT if ( test < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT print ( test , end = " ▁ " ) NEW_LINE print@@ Fun ( test - 1 ) NEW_LINE print ( test , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT DEDENT
MAXIMUM_@@ TR@@ IP@@ LET_@@ S@@ UM_@@ ARRAY | def max@@ Trip@@ let@@ Sum ( arr , n ) : NEW_LINE INDENT sm = - 1000000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) : NEW_LINE INDENT sm = arr [ i ] + arr [ j ] + arr [ k ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return sm NEW_LINE DEDENT
MINIMUM_@@ NUMBER_OF_@@ JUM@@ PS_@@ TO_@@ REACH_@@ END_OF_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ 1 | def min@@ Jump@@ s ( arr , n ) : NEW_LINE INDENT jumps = [ 0 for i in range ( n ) ] NEW_LINE if ( n == 0 ) or ( arr [ 0 ] == 0 ) : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT jumps [ 0 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT jumps [ i ] = float ( ' inf ' ) NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( i <= j + arr [ j ] ) and ( jumps [ j ] != float ( ' inf ' ) ) : NEW_LINE INDENT jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return jumps [ n - 1 ] NEW_LINE DEDENT
MAXI@@ MI@@ ZE_@@ ARRAY_@@ ELEMEN@@ TS_@@ UP@@ TO_@@ GI@@ V@@ EN_@@ NUMBER | def find@@ Max@@ Val ( arr , n , num , max@@ Limit ) : NEW_LINE INDENT ind = - 1 ; NEW_LINE val = - 1 ; NEW_LINE dp = [ [ 0 for i in range ( max@@ Limit + 1 ) ] for j in range ( n ) ] ; NEW_LINE for ind in range ( n ) : NEW_LINE INDENT for val in range ( max@@ Limit + 1 ) : NEW_LINE INDENT if ( ind == 0 ) : NEW_LINE INDENT if ( num - arr [ ind ] == val or num + arr [ ind ] == val ) : NEW_LINE INDENT dp [ ind ] [ val ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ ind ] [ val ] = 0 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( val - arr [ ind ] >= 0 and val + arr [ ind ] <= max@@ Limit ) : NEW_LINE INDENT if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 or dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) : NEW_LINE INDENT dp [ ind ] [ val ] = 1 ; NEW_LINE DEDENT DEDENT elif ( val - arr [ ind ] >= 0 ) : NEW_LINE INDENT dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] ; NEW_LINE DEDENT elif ( val + arr [ ind ] <= max@@ Limit ) : NEW_LINE INDENT dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ ind ] [ val ] = 0 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT for val in range ( max@@ Limit , - 1 , - 1 ) : NEW_LINE INDENT if ( dp [ n - 1 ] [ val ] == 1 ) : NEW_LINE INDENT return val ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT
PROGRAM_@@ FOR_@@ DEAD@@ LOCK_@@ FREE_@@ CONDITION_@@ IN_@@ OPER@@ ATING_@@ SYSTEM | def Resources ( process , need ) : NEW_LINE INDENT min@@ Resources = 0 NEW_LINE min@@ Resources = process * ( need - 1 ) + 1 NEW_LINE return min@@ Resources NEW_LINE DEDENT
NUMBER_@@ DIG@@ IT@@ S_@@ PRODUCT_@@ TWO_@@ NUMB@@ ERS | def count@@ Digits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE p = abs ( a * b ) NEW_LINE if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE p = p // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
FLO@@ OR_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY | def floor@@ Search ( arr , low , high , x ) : NEW_LINE INDENT if ( low > high ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( x >= arr [ high ] ) : NEW_LINE INDENT return high NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] ) : NEW_LINE INDENT return mid - 1 NEW_LINE DEDENT if ( x < arr [ mid ] ) : NEW_LINE INDENT return floor@@ Search ( arr , low , mid - 1 , x ) NEW_LINE DEDENT return floor@@ Search ( arr , mid + 1 , high , x ) NEW_LINE DEDENT
CHECK_@@ WHE@@ THER_@@ TRIANGLE_@@ VALID_@@ NOT_@@ SI@@ DES_@@ GI@@ VEN | def check@@ Validity ( a , b , c ) : NEW_LINE INDENT if ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
PRINT_@@ N_@@ X_@@ N@@ _SP@@ IR@@ AL_@@ MATRIX_@@ USING_@@ O@@ 1_@@ EX@@ TRA@@ _SPACE | def print@@ Sp@@ ir@@ al ( n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT x = min ( min ( i , j ) , min ( n - 1 - i , n - 1 - j ) ) NEW_LINE if ( i <= j ) : NEW_LINE INDENT print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) , end = " \t " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) ) , end = " \t " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
POSITION_@@ ELEMENT_@@ STABLE_@@ S@@ ORT | def getIndex@@ In@@ Sorted@@ Array ( arr , n , idx ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ idx ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT if ( arr [ i ] == arr [ idx ] and i < idx ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT
MAX@@ IM@@ UM@@ _SEG@@ MENT_@@ VALUE_@@ PUT@@ TING_@@ K_@@ BREAK@@ POINT@@ S_@@ NUMBER | def find@@ Max@@ Segment ( s , k ) : NEW_LINE INDENT seg_@@ len = len ( s ) - k NEW_LINE res = 0 NEW_LINE for i in range ( seg_@@ len ) : NEW_LINE INDENT res = res * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT seg_@@ len_@@ pow = pow ( 10 , seg_@@ len - 1 ) NEW_LINE curr_@@ val = res NEW_LINE for i in range ( 1 , len ( s ) - seg_@@ len ) : NEW_LINE INDENT curr_@@ val = curr_@@ val - ( ord ( s [ i - 1 ] ) - ord ( '0' ) ) * seg_@@ len_@@ pow NEW_LINE curr_@@ val = ( curr_@@ val * 10 + ( ord ( s [ i + seg_@@ len - 1 ] ) - ord ( '0' ) ) ) NEW_LINE res = max ( res , curr_@@ val ) NEW_LINE DEDENT return res NEW_LINE DEDENT
FIN@@ DING_@@ POWER_@@ PRI@@ ME_@@ NUMBER_@@ P_@@ N_@@ 1 | def Power@@ OFP@@ IN@@ n@@ factorial ( n , p ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = p NEW_LINE while ( temp <= n ) : NEW_LINE INDENT ans += n / temp NEW_LINE temp = temp * p NEW_LINE DEDENT return int ( ans ) NEW_LINE DEDENT
PROGRAM_@@ PR@@ IN@@ T_ID@@ ENTITY_@@ MATRIX | def Identity ( size ) : NEW_LINE INDENT for row in range ( 0 , size ) : NEW_LINE INDENT for col in range ( 0 , size ) : NEW_LINE INDENT if ( row == col ) : NEW_LINE INDENT print ( "1 ▁ " , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0 ▁ " , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
S@@ UM_@@ MATRIX_@@ ELEMENT_@@ ELEMENT_@@ INTEGER_@@ DI@@ VISI@@ ON_@@ ROW_@@ COLUMN | def find@@ Sum ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += i // j NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
TI@@ LING_@@ WITH_@@ DO@@ MIN@@ OES | def count@@ W@@ ays ( n ) : NEW_LINE INDENT A = [ 0 ] * ( n + 1 ) NEW_LINE B = [ 0 ] * ( n + 1 ) NEW_LINE A [ 0 ] = 1 NEW_LINE A [ 1 ] = 0 NEW_LINE B [ 0 ] = 0 NEW_LINE B [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] NEW_LINE B [ i ] = A [ i - 1 ] + B [ i - 2 ] NEW_LINE DEDENT return A [ n ] NEW_LINE DEDENT
COUNT_@@ DE@@ RANGE@@ MEN@@ TS_@@ PER@@ MU@@ TA@@ TION@@ _SU@@ CH_@@ TH@@ AT_@@ NO_@@ ELEMENT_@@ AP@@ PE@@ AR@@ S_IN_@@ IT@@ S_@@ ORIGIN@@ AL_@@ POSITION | def count@@ D@@ er ( n ) : NEW_LINE INDENT if ( n == 1 ) : return 0 NEW_LINE if ( n == 0 ) : return 1 NEW_LINE if ( n == 2 ) : return 1 NEW_LINE return ( n - 1 ) * ( count@@ D@@ er ( n - 1 ) + count@@ D@@ er ( n - 2 ) ) NEW_LINE DEDENT
FREQU@@ ENCY_@@ ELEMENT_@@ UN@@ SOR@@ TED_@@ ARRAY_@@ 1 | def count@@ Freq ( a , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ a [ i ] ] = hm . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT cum@@ ul = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cum@@ ul += hm [ a [ i ] ] NEW_LINE if ( hm [ a [ i ] ] > 0 ) : NEW_LINE INDENT print ( a [ i ] , " - > " , cum@@ ul ) NEW_LINE DEDENT hm [ a [ i ] ] = 0 NEW_LINE DEDENT DEDENT
MINI@@ MI@@ ZE_@@ THE_@@ S@@ UM_@@ OF_@@ DIG@@ IT@@ S_@@ OF_@@ A_@@ AND_@@ B@@ _SU@@ CH_@@ TH@@ AT_@@ A_@@ B_@@ N | def min@@ Sum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += ( n % 10 ) ; NEW_LINE n /@@ /= 10 ; NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT return 10 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
DI@@ VI@@ DE_@@ CU@@ BO@@ ID_@@ CU@@ BE@@ S_S@@ UM_@@ VOLUM@@ ES_@@ MAX@@ IMUM | def maxim@@ iz@@ ecu@@ be ( l , b , h ) : NEW_LINE INDENT side = gcd ( l , gcd ( b , h ) ) NEW_LINE num = int ( l / side ) NEW_LINE num = int ( num * b / side ) NEW_LINE num = int ( num * h / side ) NEW_LINE print ( side , num ) NEW_LINE DEDENT
CHECK_@@ NUMBER_@@ POWER_@@ K_@@ USING_@@ BASE_@@ CHAN@@ G@@ ING_@@ METHOD | def is@@ PowerOf@@ K ( n , k ) : NEW_LINE INDENT one@@ Seen = False NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % k NEW_LINE if ( digit > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( digit == 1 ) : NEW_LINE INDENT if ( one@@ Seen ) : NEW_LINE INDENT return False NEW_LINE DEDENT one@@ Seen = True NEW_LINE DEDENT n /@@ /= k NEW_LINE DEDENT return True NEW_LINE DEDENT
POSITION_@@ OF_@@ RIGHT@@ MO@@ ST@@ _SET_@@ BIT_@@ 1 | def Position@@ Right@@ most@@ Set@@ bit ( n ) : NEW_LINE INDENT position = 1 NEW_LINE m = 1 NEW_LINE while ( not ( n & m ) ) : NEW_LINE INDENT m = m << 1 NEW_LINE position += 1 NEW_LINE DEDENT return position NEW_LINE DEDENT
SEARCH_@@ INSERT_@@ AND_@@ DELETE_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY_@@ 1 | def insert@@ Sorted ( arr , n , key , capacity ) : NEW_LINE INDENT if ( n >= capacity ) : NEW_LINE INDENT return n NEW_LINE DEDENT i = n - 1 NEW_LINE while i >= 0 and arr [ i ] > key : NEW_LINE INDENT arr [ i + 1 ] = arr [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT arr [ i + 1 ] = key NEW_LINE return ( n + 1 ) NEW_LINE DEDENT
FIND_@@ THE_@@ MAXIMUM_@@ OF_@@ MIN@@ IM@@ UM@@ S_@@ FOR_@@ EVER@@ Y_@@ WINDOW@@ _SIZE_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ 1 | def print@@ Max@@ Of@@ Min ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE left = [ - 1 ] * ( n + 1 ) NEW_LINE right = [ n ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( len ( s ) != 0 and arr [ s [ - 1 ] ] >= arr [ i ] ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT if ( len ( s ) != 0 ) : NEW_LINE INDENT left [ i ] = s [ - 1 ] NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( len ( s ) != 0 and arr [ s [ - 1 ] ] >= arr [ i ] ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT if ( len ( s ) != 0 ) : NEW_LINE INDENT right [ i ] = s [ - 1 ] NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT ans = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT ans [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT Len = right [ i ] - left [ i ] - 1 NEW_LINE ans [ Len ] = max ( ans [ Len ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT ans [ i ] = max ( ans [ i ] , ans [ i + 1 ] ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
MAXIMUM_@@ DECIMAL_@@ VALUE_@@ PATH_@@ IN_@@ A_@@ BINARY_@@ MATRIX_@@ 1 | def Maximum@@ Decimal@@ Value ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE if ( mat [ 0 ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ 0 ] [ i ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 ** i NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 ** i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( 2 ** ( i + j ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT
COUNT_@@ NUMBER_OF_@@ WAY@@ S_TO_@@ CO@@ VER_@@ A_@@ DISTANCE | def print@@ Count@@ Rec ( dist ) : NEW_LINE INDENT if dist < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dist == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( print@@ Count@@ Rec ( dist - 1 ) + print@@ Count@@ Rec ( dist - 2 ) + print@@ Count@@ Rec ( dist - 3 ) ) NEW_LINE DEDENT
MOVE_@@ VE_@@ ELEMEN@@ TS_@@ END_@@ ORDER_@@ EX@@ TRA@@ _SPACE_@@ ALLOWED | def se@@ greg@@ ate@@ Elements ( arr , n ) : NEW_LINE INDENT temp = [ 0 for k in range ( n ) ] NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= 0 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if ( j == n or j == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for k in range ( n ) : NEW_LINE INDENT arr [ k ] = temp [ k ] NEW_LINE DEDENT DEDENT
MINIMUM_@@ PER@@ I@@ ME@@ TER_@@ N_@@ BLOCKS | def min@@ Per@@ imeter ( n ) : NEW_LINE INDENT l = math . sqrt ( n ) NEW_LINE sq = l * l NEW_LINE if ( sq == n ) : NEW_LINE INDENT return l * 4 NEW_LINE DEDENT else : NEW_LINE INDENT row = n / l NEW_LINE per@@ imeter = 2 * ( l + row ) NEW_LINE if ( n % l != 0 ) : NEW_LINE INDENT per@@ imeter += 2 NEW_LINE DEDENT return per@@ imeter NEW_LINE DEDENT DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 36@@ _@@ CU@@ T_@@ A_@@ RO@@ PE_@@ TO_@@ MAXI@@ MI@@ ZE_@@ PRODUCT | def max@@ Prod ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT max_@@ val = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT max_@@ val = max ( max_@@ val , max ( i * ( n - i ) , max@@ Prod ( n - i ) * i ) ) NEW_LINE DEDENT return max_@@ val ; NEW_LINE DEDENT
LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ STRING@@ _SPACE_@@ OPTIMIZ@@ ED_@@ D@@ P_S@@ OL@@ U@@ TION | def LC@@ Sub@@ Str ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE result = 0 NEW_LINE len_@@ mat = np . zeros ( ( 2 , n ) ) NEW_LINE curr@@ Row = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == 0 | j == 0 ) : NEW_LINE INDENT len_@@ mat [ curr@@ Row ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT len_@@ mat [ curr@@ Row ] [ j ] = len_@@ mat [ 1 - curr@@ Row ] [ j - 1 ] + 1 NEW_LINE result = max ( result , len_@@ mat [ curr@@ Row ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT len_@@ mat [ curr@@ Row ] [ j ] = 0 NEW_LINE DEDENT DEDENT curr@@ Row = 1 - curr@@ Row NEW_LINE DEDENT return result NEW_LINE DEDENT
CHECK_@@ GI@@ V@@ EN_@@ STRING_@@ ROTATION_@@ PA@@ LIN@@ DRO@@ ME | def is@@ Pal@@ ind@@ ro@@ me ( string ) : NEW_LINE INDENT l = 0 NEW_LINE h = len ( string ) - 1 NEW_LINE while h > l : NEW_LINE INDENT l += 1 NEW_LINE h -= 1 NEW_LINE if string [ l - 1 ] != string [ h + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
FIND_@@ NUMBER_@@ OF@@ _S@@ OL@@ U@@ TIONS_@@ OF_@@ A_@@ LINEAR_@@ EQU@@ ATION_@@ OF_@@ N_@@ VARIAB@@ LES_@@ 1 | def count@@ So@@ l ( coeff , n , rhs ) : NEW_LINE INDENT dp = [ 0 for i in range ( rhs + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( coeff [ i ] , rhs + 1 ) : NEW_LINE INDENT dp [ j ] += dp [ j - coeff [ i ] ] NEW_LINE DEDENT DEDENT return dp [ rhs ] NEW_LINE DEDENT
FIND_@@ THE_@@ LAR@@ GE@@ ST_@@ PAIR@@ _S@@ UM_@@ IN_@@ AN_@@ UN@@ SOR@@ TED_@@ ARRAY | def find@@ Largest@@ Sum@@ Pair ( arr , n ) : NEW_LINE INDENT if arr [ 0 ] > arr [ 1 ] : NEW_LINE INDENT first = arr [ 0 ] NEW_LINE second = arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT first = arr [ 1 ] NEW_LINE second = arr [ 0 ] NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if arr [ i ] > first : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif arr [ i ] > second and arr [ i ] != first : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT return ( first + second ) NEW_LINE DEDENT
FIND_@@ BIT@@ ON@@ IC_@@ POINT_@@ GI@@ V@@ EN_@@ BIT@@ ON@@ IC@@ _SEQU@@ ENCE | def binary@@ Search ( arr , left , right ) : NEW_LINE INDENT if ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) // 2 ; NEW_LINE if ( arr [ mid - 1 ] < arr [ mid ] and arr [ mid ] > arr [ mid + 1 ] ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT if ( arr [ mid ] < arr [ mid + 1 ] ) : NEW_LINE INDENT return binary@@ Search ( arr , mid + 1 , right ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return binary@@ Search ( arr , left , mid - 1 ) ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT
PRINT_@@ ALL_@@ DISTIN@@ CT_@@ CHARAC@@ TER@@ S_@@ OF_@@ A_@@ STRING_@@ IN_@@ ORDER_@@ 3_@@ METHO@@ DS_@@ 1 | def print@@ Distin@@ ct ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE count = [ 0 for i in range ( MAX_@@ CHAR ) ] NEW_LINE index = [ n for i in range ( MAX_@@ CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = ord ( Str [ i ] ) NEW_LINE count [ x ] += 1 NEW_LINE if ( count [ x ] == 1 and x != ' ▁ ' ) : NEW_LINE INDENT index [ x ] = i NEW_LINE DEDENT if ( count [ x ] == 2 ) : NEW_LINE INDENT index [ x ] = n NEW_LINE DEDENT DEDENT index = sorted ( index ) NEW_LINE for i in range ( MAX_@@ CHAR ) : NEW_LINE INDENT if index [ i ] == n : NEW_LINE INDENT break NEW_LINE DEDENT print ( Str [ index [ i ] ] , end = " " ) NEW_LINE DEDENT DEDENT
FIND_@@ TW@@ O@@ _SI@@ DES_@@ RIGHT_@@ ANGLE_@@ TRI@@ ANGLE | def print@@ Other@@ Si@@ des ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n - 1 ) // 2 NEW_LINE c = ( n * n + 1 ) // 2 NEW_LINE print ( " b ▁ = " , b , " , ▁ c ▁ = " , c ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = n * n // 4 - 1 NEW_LINE c = n * n // 4 + 1 NEW_LINE print ( " b ▁ = " , b " , ▁ c ▁ = " , c ) NEW_LINE DEDENT DEDENT DEDENT
COUNT_@@ NUMBER_OF_@@ STRING@@ S_@@ MA@@ DE_@@ OF_@@ R_@@ G_@@ AND_@@ B_@@ USING_@@ GI@@ V@@ EN_@@ COMBIN@@ ATION | def possible@@ Strings ( n , r , b , g ) : NEW_LINE INDENT fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT left = n - ( r + g + b ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , left + 1 , 1 ) : NEW_LINE INDENT for j in range ( 0 , left - i + 1 , 1 ) : NEW_LINE INDENT k = left - ( i + j ) NEW_LINE sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
RE@@ AR@@ RANGE_@@ ARRAY_@@ MAXIMUM_@@ MINIMUM_@@ FORM@@ _SET_@@ 2_@@ O@@ 1_@@ EX@@ TRA@@ _SPACE_@@ 1 | def re@@ arrange ( arr , n ) : NEW_LINE INDENT max_@@ ele = arr [ n - 1 ] NEW_LINE min_@@ ele = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT arr [ i ] = max_@@ ele NEW_LINE max_@@ ele -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = min_@@ ele NEW_LINE min_@@ ele += 1 NEW_LINE DEDENT DEDENT DEDENT
EVALU@@ ATE_@@ AN_@@ ARRAY_@@ EXPRES@@ SION_@@ WITH_@@ NUMB@@ ERS_@@ AND | def calculate@@ Sum ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = arr [ 0 ] NEW_LINE value = int ( s ) NEW_LINE sum = value NEW_LINE for i in range ( 2 , n , 2 ) : NEW_LINE INDENT s = arr [ i ] NEW_LINE value = int ( s ) NEW_LINE operation = arr [ i - 1 ] [ 0 ] NEW_LINE if ( operation == ' + ' ) : NEW_LINE INDENT sum += value NEW_LINE DEDENT else : NEW_LINE INDENT sum -= value NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
S@@ UM_@@ MATRIX_@@ ELEMENT_@@ ELEMENT_@@ INTEGER_@@ DI@@ VISI@@ ON_@@ ROW_@@ COLUMN_@@ 1 | def find@@ Sum ( n ) : NEW_LINE INDENT ans = 0 ; temp = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if temp < n : NEW_LINE INDENT temp = i - 1 NEW_LINE num = 1 NEW_LINE while temp < n : NEW_LINE INDENT if temp + i <= n : NEW_LINE INDENT ans += i * num NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( n - temp ) * num NEW_LINE DEDENT temp += i NEW_LINE num += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
SHUFF@@ LE_@@ A_@@ DE@@ CK_@@ OF_@@ CAR@@ DS_@@ 3 | def shuffle ( card , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT r = i + ( random . randint ( 0 , 55 ) % ( 52 - i ) ) NEW_LINE tmp = card [ i ] NEW_LINE card [ i ] = card [ r ] NEW_LINE card [ r ] = tmp NEW_LINE DEDENT DEDENT
DO@@ O@@ LITTLE_@@ ALGORITH@@ M_@@ L@@ U_@@ DE@@ COMPOSI@@ TION | def lu@@ De@@ composition ( mat , n ) : NEW_LINE INDENT lower = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] ; NEW_LINE upper = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for k in range ( i , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for j in range ( i ) : NEW_LINE INDENT sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) ; NEW_LINE DEDENT upper [ i ] [ k ] = mat [ i ] [ k ] - sum ; NEW_LINE DEDENT for k in range ( i , n ) : NEW_LINE INDENT if ( i == k ) : NEW_LINE INDENT lower [ i ] [ i ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT sum = 0 ; NEW_LINE for j in range ( i ) : NEW_LINE INDENT sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) ; NEW_LINE DEDENT lower [ k ] [ i ] = int ( ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ) ; NEW_LINE DEDENT DEDENT DEDENT print ( " Lower ▁ Tri@@ angular@@ \t\t@@ Upper ▁ Tri@@ angular " ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( lower [ i ] [ j ] , end = " \t " ) ; NEW_LINE DEDENT print ( " " , end = " \t " ) ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT print ( upper [ i ] [ j ] , end = " \t " ) ; NEW_LINE DEDENT print ( " " ) ; NEW_LINE DEDENT DEDENT
PROGRAM_@@ N@@ TH_@@ CATA@@ LAN@@ _@@ NUMBER | def catal@@ an ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += catal@@ an ( i ) * catal@@ an ( n - i - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
NUMBER_@@ DIG@@ IT@@ S_@@ REMO@@ VED_@@ MAKE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 3 | def di@@ visible ( num ) : NEW_LINE INDENT n = len ( num ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += int ( num [ i ] ) ; NEW_LINE DEDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( sum % 3 == int ( num [ i ] ) % 3 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT DEDENT if ( n == 2 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return 2 ; NEW_LINE DEDENT
CHECK_@@ IF_@@ A_@@ NUMBER_@@ IS_@@ POWER_@@ OF_@@ AN@@ OTHER_@@ NUMBER_@@ 1 | def is@@ Power ( x , y ) : NEW_LINE INDENT res1 = math . log ( y ) / math . log ( x ) ; NEW_LINE res2 = math . log ( y ) / math . log ( x ) ; NEW_LINE return 1 if ( res1 == res2 ) else 0 ; NEW_LINE DEDENT
LAR@@ GE@@ ST@@ _SUB@@ SEQU@@ ENCE_@@ GC@@ D_@@ GREATER_@@ 1 | def lar@@ gest@@ G@@ CD@@ Sub@@ sequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE max@@ ele = max ( arr ) NEW_LINE for i in range ( 2 , max@@ ele + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
FIND_@@ COMMON_@@ ELEMENT_@@ RO@@ WS_@@ ROW_@@ WI@@ SE_@@ SOR@@ TED_@@ MATRIX | def find@@ Common ( mat ) : NEW_LINE INDENT column = [ N - 1 ] * M NEW_LINE min_@@ row = 0 NEW_LINE while ( column [ min_@@ row ] >= 0 ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT if ( mat [ i ] [ column [ i ] ] < mat [ min_@@ row ] [ column [ min_@@ row ] ] ) : NEW_LINE INDENT min_@@ row = i NEW_LINE DEDENT DEDENT eq_@@ count = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT if ( mat [ i ] [ column [ i ] ] > mat [ min_@@ row ] [ column [ min_@@ row ] ] ) : NEW_LINE INDENT if ( column [ i ] == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT column [ i ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT eq_@@ count += 1 NEW_LINE DEDENT DEDENT if ( eq_@@ count == M ) : NEW_LINE INDENT return mat [ min_@@ row ] [ column [ min_@@ row ] ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
CHECK_@@ GI@@ V@@ EN_@@ CI@@ R@@ CLE_@@ LI@@ ES_@@ COMPLE@@ TE@@ LY_@@ IN@@ SIDE_@@ R@@ ING_@@ FOR@@ MED_@@ TWO_@@ CON@@ CEN@@ TRI@@ C_@@ CIRC@@ LES | def check@@ circle ( r , R , r1 , x1 , y1 ) : NEW_LINE INDENT dis = int ( math . sqrt ( x1 * x1 + y1 * y1 ) ) NEW_LINE return ( dis - r1 >= R and dis + r1 <= r ) NEW_LINE DEDENT
COUNT_@@ TO@@ TAL@@ _SET_@@ BITS_@@ IN_@@ ALL_@@ NUMB@@ ERS_@@ FROM_@@ 1_@@ TO_@@ N | def count@@ Set@@ Bits ( n ) : NEW_LINE INDENT i = 0 NEW_LINE ans = 0 NEW_LINE while ( ( 1 << i ) <= n ) : NEW_LINE INDENT k = 0 NEW_LINE change = 1 << i NEW_LINE for j in range ( 0 , n + 1 ) : NEW_LINE INDENT ans += k NEW_LINE if change == 1 : NEW_LINE INDENT k = not k NEW_LINE change = 1 << i NEW_LINE DEDENT else : NEW_LINE INDENT change -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
LON@@ GE@@ ST_@@ REPE@@ AT@@ ING@@ _SUB@@ SEQUENCE | def find@@ Lon@@ gest@@ Repe@@ ating@@ Sub@@ Seq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ n ] NEW_LINE DEDENT
FIND_@@ THE_@@ FIRST_@@ MISSING_@@ NUMBER | def find@@ First@@ Missing ( array , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return end + 1 NEW_LINE DEDENT if ( start != array [ start ] ) : NEW_LINE INDENT return start ; NEW_LINE DEDENT mid = int ( ( start + end ) / 2 ) NEW_LINE if ( array [ mid ] == mid ) : NEW_LINE INDENT return find@@ First@@ Missing ( array , mid + 1 , end ) NEW_LINE DEDENT return find@@ First@@ Missing ( array , start , mid ) NEW_LINE DEDENT
SORT_@@ ARRAY_@@ CONVER@@ TING_@@ ELEMEN@@ TS@@ _S@@ QUAR@@ ES_@@ 1 | def sort@@ Squ@@ ares ( arr , n ) : NEW_LINE INDENT K = 0 NEW_LINE for K in range ( n ) : NEW_LINE INDENT if ( arr [ K ] >= 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i = K - 1 NEW_LINE j = K NEW_LINE ind = 0 NEW_LINE temp = [ 0 ] * n NEW_LINE while ( i >= 0 and j < n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) : NEW_LINE INDENT temp [ ind ] = arr [ i ] * arr [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ ind ] = arr [ j ] * arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT ind += 1 NEW_LINE DEDENT while ( i >= 0 ) : NEW_LINE INDENT temp [ ind ] = arr [ i ] * arr [ i ] NEW_LINE i -= 1 NEW_LINE ind += 1 NEW_LINE DEDENT while ( j < n ) : NEW_LINE INDENT temp [ ind ] = arr [ j ] * arr [ j ] NEW_LINE j += 1 NEW_LINE ind += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT DEDENT
PROGRAM_@@ TO_@@ FIND_@@ RE@@ MA@@ INDE@@ R_@@ WITH@@ OUT_@@ USING_@@ MODUL@@ O_@@ OR_@@ OPERATOR | def getRe@@ main@@ der ( num , divisor ) : NEW_LINE INDENT return ( num - divisor * ( num // divisor ) ) NEW_LINE DEDENT
MINIMUM_@@ CO@@ ST_@@ TO_@@ FILL_@@ GI@@ V@@ EN_@@ WEIGHT_@@ IN_@@ A_@@ BA@@ G | def Minimum@@ Cost ( cost , n , W ) : NEW_LINE INDENT val = list ( ) NEW_LINE wt = list ( ) NEW_LINE size = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( cost [ i ] != - 1 ) : NEW_LINE INDENT val . append ( cost [ i ] ) NEW_LINE wt . append ( i + 1 ) NEW_LINE size += 1 NEW_LINE DEDENT DEDENT n = size NEW_LINE min_@@ cost = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( W + 1 ) : NEW_LINE INDENT min_@@ cost [ 0 ] [ i ] = INF NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT min_@@ cost [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , W + 1 ) : NEW_LINE INDENT if ( wt [ i - 1 ] > j ) : NEW_LINE INDENT min_@@ cost [ i ] [ j ] = min_@@ cost [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT min_@@ cost [ i ] [ j ] = min ( min_@@ cost [ i - 1 ] [ j ] , min_@@ cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if ( min_@@ cost [ n ] [ W ] == INF ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return min_@@ cost [ n ] [ W ] NEW_LINE DEDENT DEDENT
COUNT_@@ CHARAC@@ TER@@ S_@@ STRING_@@ DISTAN@@ CE_@@ ENGLI@@ SH_@@ ALPH@@ AB@@ E@@ TS_@@ 1 | def count@@ Pairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 1 , MAX_@@ CHAR + 1 ) : NEW_LINE INDENT if ( ( i + j ) < n ) : NEW_LINE INDENT if ( ( abs ( ord ( str1 [ i + j ] ) - ord ( str1 [ i ] ) ) == j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
A_@@ PRODUCT_@@ ARRAY_@@ PU@@ ZZ@@ LE | def product@@ Array ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT left = [ 0 ] * n NEW_LINE right = [ 0 ] * n NEW_LINE prod = [ 0 ] * n NEW_LINE left [ 0 ] = 1 NEW_LINE right [ n - 1 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT left [ i ] = arr [ i - 1 ] * left [ i - 1 ] NEW_LINE DEDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT right [ j ] = arr [ j + 1 ] * right [ j + 1 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT prod [ i ] = left [ i ] * right [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( prod [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
FREQU@@ ENT_@@ ELEMENT_@@ ARRAY_@@ 1 | def most@@ Frequ@@ ent ( arr , n ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in Hash . keys ( ) : NEW_LINE INDENT Hash [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Hash [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT max_@@ count = 0 NEW_LINE res = - 1 NEW_LINE for i in Hash : NEW_LINE INDENT if ( max_@@ count < Hash [ i ] ) : NEW_LINE INDENT res = i NEW_LINE max_@@ count = Hash [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
PRINT_@@ UNI@@ QUE_@@ ROWS | def print@@ Array ( matrix ) : NEW_LINE INDENT rowCount = len ( matrix ) NEW_LINE if rowCount == 0 : NEW_LINE INDENT return NEW_LINE DEDENT columnCount = len ( matrix [ 0 ] ) NEW_LINE if columnCount == 0 : NEW_LINE INDENT return NEW_LINE DEDENT row_@@ output_format = " ▁ " . join ( [ " % s " ] * columnCount ) NEW_LINE printed = { } NEW_LINE for row in matrix : NEW_LINE INDENT rout@@ put = row_@@ output_format % tuple ( row ) NEW_LINE if rout@@ put not in printed : NEW_LINE INDENT printed [ rout@@ put ] = True NEW_LINE print ( rout@@ put ) NEW_LINE DEDENT DEDENT DEDENT
COUNT_@@ 1@@ S_S@@ OR@@ TED_@@ BINARY_@@ ARRAY | def count@@ Ones ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = low + ( high - low ) / 2 NEW_LINE if ( ( mid == high or arr [ mid + 1 ] == 0 ) and ( arr [ mid ] == 1 ) ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT if arr [ mid ] == 1 : NEW_LINE INDENT return count@@ Ones ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT return count@@ Ones ( arr , low , mid - 1 ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT
POSSI@@ BLE_@@ MOVE@@ S_@@ KN@@ IGHT | def find@@ Possible@@ Moves ( mat , p , q ) : NEW_LINE INDENT global n , m ; NEW_LINE X = [ 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 ] ; NEW_LINE Y = [ 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 ] ; NEW_LINE count = 0 ; NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT x = p + X [ i ] ; NEW_LINE y = q + Y [ i ] ; NEW_LINE if ( x >= 0 and y >= 0 and x < n and y < m and mat [ x ] [ y ] == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT
ROTA@@ TE_@@ MATRIX_@@ ELEMENTS | def rotate@@ Matrix ( mat ) : NEW_LINE INDENT if not len ( mat ) : NEW_LINE INDENT return NEW_LINE DEDENT top = 0 NEW_LINE bottom = len ( mat ) - 1 NEW_LINE left = 0 NEW_LINE right = len ( mat [ 0 ] ) - 1 NEW_LINE while left < right and top < bottom : NEW_LINE INDENT prev = mat [ top + 1 ] [ left ] NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT curr = mat [ top ] [ i ] NEW_LINE mat [ top ] [ i ] = prev NEW_LINE prev = curr NEW_LINE DEDENT top += 1 NEW_LINE for i in range ( top , bottom + 1 ) : NEW_LINE INDENT curr = mat [ i ] [ right ] NEW_LINE mat [ i ] [ right ] = prev NEW_LINE prev = curr NEW_LINE DEDENT right -= 1 NEW_LINE for i in range ( right , left - 1 , - 1 ) : NEW_LINE INDENT curr = mat [ bottom ] [ i ] NEW_LINE mat [ bottom ] [ i ] = prev NEW_LINE prev = curr NEW_LINE DEDENT bottom -= 1 NEW_LINE for i in range ( bottom , top - 1 , - 1 ) : NEW_LINE INDENT curr = mat [ i ] [ left ] NEW_LINE mat [ i ] [ left ] = prev NEW_LINE prev = curr NEW_LINE DEDENT left += 1 NEW_LINE DEDENT return mat NEW_LINE DEDENT
FIND_@@ K@@ TH_@@ CHARACTER_@@ OF_@@ DE@@ CRYP@@ TED_@@ STRING | def encoded@@ Char ( str , k ) : NEW_LINE INDENT expand = " " NEW_LINE freq = 0 NEW_LINE i = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT temp = " " NEW_LINE freq = 0 NEW_LINE while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( ' a ' ) and ord ( str [ i ] ) <= ord ( ' z ' ) ) : NEW_LINE INDENT temp += str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( '1' ) and ord ( str [ i ] ) <= ord ( '9' ) ) : NEW_LINE INDENT freq = freq * 10 + ord ( str [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( 1 , freq + 1 , 1 ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT DEDENT if ( freq == 0 ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT return expand [ k - 1 ] NEW_LINE DEDENT
EF@@ FI@@ CI@@ ENT_@@ SEARCH_@@ IN_@@ AN_@@ ARRAY_@@ W@@ HER@@ E_@@ DIFF@@ ER@@ ENCE_@@ BETWE@@ EN_@@ AD@@ J@@ AC@@ ENT_@@ IS_@@ 1 | def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i <= n - 1 ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += abs ( arr [ i ] - x ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
MAXIMUM_@@ POSSI@@ BLE_@@ S@@ UM_@@ WINDOW_@@ ARRAY_@@ ELEMEN@@ TS_@@ WINDOW_@@ ARRAY_@@ UNIQUE | def return@@ Max@@ Sum ( A , B , n ) : NEW_LINE INDENT mp = set ( ) NEW_LINE result = 0 NEW_LINE curr_@@ sum = curr_@@ begin = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while A [ i ] in mp : NEW_LINE INDENT mp . remove ( A [ curr_@@ begin ] ) NEW_LINE curr_@@ sum -= B [ curr_@@ begin ] NEW_LINE curr_@@ begin += 1 NEW_LINE DEDENT mp . add ( A [ i ] ) NEW_LINE curr_@@ sum += B [ i ] NEW_LINE result = max ( result , curr_@@ sum ) NEW_LINE DEDENT return result NEW_LINE DEDENT
WRITE_@@ AN_@@ EF@@ FI@@ CI@@ ENT_@@ METHOD_@@ TO_@@ CHECK_@@ IF_@@ A_@@ NUMBER_@@ IS_@@ MULTIPLE_@@ OF_@@ 3 | def is@@ Multiple@@ Of@@ 3 ( n ) : NEW_LINE INDENT od@@ d_@@ count = 0 NEW_LINE ev@@ en_@@ count = 0 NEW_LINE if ( n < 0 ) : NEW_LINE INDENT n = - n NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT od@@ d_@@ count += 1 NEW_LINE DEDENT if ( n & 2 ) : NEW_LINE INDENT ev@@ en_@@ count += 1 NEW_LINE DEDENT n = n >> 2 NEW_LINE DEDENT return is@@ Multiple@@ Of@@ 3 ( abs ( od@@ d_@@ count - ev@@ en_@@ count ) ) NEW_LINE DEDENT
MAX@@ IM@@ UM@@ _S@@ UM_@@ I@@ AR@@ RI@@ _@@ AM@@ ONG_@@ ROTA@@ TIONS_@@ GI@@ V@@ EN_@@ ARRAY_@@ 1 | def max@@ Sum ( arr , n ) : NEW_LINE INDENT cum@@ _@@ sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cum@@ _@@ sum += arr [ i ] NEW_LINE DEDENT curr_@@ val = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_@@ val += i * arr [ i ] NEW_LINE DEDENT res = curr_@@ val NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT next_@@ val = ( curr_@@ val - ( cum@@ _@@ sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ) NEW_LINE curr_@@ val = next_@@ val NEW_LINE res = max ( res , next_@@ val ) NEW_LINE DEDENT return res NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 34@@ _@@ ASSEMB@@ LY_@@ LINE_@@ SCH@@ ED@@ U@@ LING | def car@@ Assembly ( a , t , e , x ) : NEW_LINE INDENT NUM_@@ ST@@ ATION = len ( a [ 0 ] ) NEW_LINE T1 = [ 0 for i in range ( NUM_@@ ST@@ ATION ) ] NEW_LINE T2 = [ 0 for i in range ( NUM_@@ ST@@ ATION ) ] NEW_LINE T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] NEW_LINE T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] NEW_LINE for i in range ( 1 , NUM_@@ ST@@ ATION ) : NEW_LINE INDENT T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) NEW_LINE T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) NEW_LINE DEDENT return min ( T1 [ NUM_@@ ST@@ ATION - 1 ] + x [ 0 ] , T2 [ NUM_@@ ST@@ ATION - 1 ] + x [ 1 ] ) NEW_LINE DEDENT
PRINT_@@ MATRI@@ X@@ _SP@@ IR@@ AL_@@ FORM_@@ START@@ ING_@@ POINT | def print@@ Sp@@ ir@@ al ( mat , r , c ) : NEW_LINE INDENT a = 0 NEW_LINE b = 2 NEW_LINE low_@@ row = 0 if ( 0 > a ) else a NEW_LINE low_@@ column = 0 if ( 0 > b ) else b - 1 NEW_LINE high_@@ row = r - 1 if ( ( a + 1 ) >= r ) else a + 1 NEW_LINE high_@@ column = c - 1 if ( ( b + 1 ) >= c ) else b + 1 NEW_LINE while ( ( low_@@ row > 0 - r and low_@@ column > 0 - c ) ) : NEW_LINE INDENT i = low_@@ column + 1 NEW_LINE while ( i <= high_@@ column and i < c and low_@@ row >= 0 ) : NEW_LINE INDENT print ( mat [ low_@@ row ] [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT low_@@ row -= 1 NEW_LINE i = low_@@ row + 2 NEW_LINE while ( i <= high_@@ row and i < r and high_@@ column < c ) : NEW_LINE INDENT print ( mat [ i ] [ high_@@ column ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT high_@@ column += 1 NEW_LINE i = high_@@ column - 2 NEW_LINE while ( i >= low_@@ column and i >= 0 and high_@@ row < r ) : NEW_LINE INDENT print ( mat [ high_@@ row ] [ i ] , end = " ▁ " ) NEW_LINE i -= 1 NEW_LINE DEDENT high_@@ row += 1 NEW_LINE i = high_@@ row - 2 NEW_LINE while ( i > low_@@ row and i >= 0 and low_@@ column >= 0 ) : NEW_LINE INDENT print ( mat [ i ] [ low_@@ column ] , end = " ▁ " ) NEW_LINE i -= 1 NEW_LINE DEDENT low_@@ column -= 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
M@@ ID_@@ POINT_@@ CI@@ R@@ CLE_@@ DRAWIN@@ G_@@ ALGORITH@@ M | def mid@@ Point@@ Circle@@ Draw ( x_@@ centre , y_@@ centre , r ) : NEW_LINE INDENT x = r NEW_LINE y = 0 NEW_LINE print ( " ( " , x + x_@@ centre , " , ▁ " , y + y_@@ centre , " ) " , sep = " " , end = " " ) NEW_LINE if ( r > 0 ) : NEW_LINE INDENT print ( " ( " , x + x_@@ centre , " , ▁ " , - y + y_@@ centre , " ) " , sep = " " , end = " " ) NEW_LINE print ( " ( " , y + x_@@ centre , " , ▁ " , x + y_@@ centre , " ) " , sep = " " , end = " " ) NEW_LINE print ( " ( " , - y + x_@@ centre , " , ▁ " , x + y_@@ centre , " ) " , sep = " " ) NEW_LINE DEDENT P = 1 - r NEW_LINE while ( x > y ) : NEW_LINE INDENT y += 1 NEW_LINE if ( P <= 0 ) : NEW_LINE INDENT P = P + 2 * y + 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE P = P + 2 * y - 2 * x + 1 NEW_LINE DEDENT if ( x < y ) : NEW_LINE INDENT break NEW_LINE DEDENT print ( " ( " , x + x_@@ centre , " , ▁ " , y + y_@@ centre , " ) " , sep = " " , end = " " ) NEW_LINE print ( " ( " , - x + x_@@ centre , " , ▁ " , y + y_@@ centre , " ) " , sep = " " , end = " " ) NEW_LINE print ( " ( " , x + x_@@ centre , " , ▁ " , - y + y_@@ centre , " ) " , sep = " " , end = " " ) NEW_LINE print ( " ( " , - x + x_@@ centre , " , ▁ " , - y + y_@@ centre , " ) " , sep = " " ) NEW_LINE if ( x != y ) : NEW_LINE INDENT print ( " ( " , y + x_@@ centre , " , ▁ " , x + y_@@ centre , " ) " , sep = " " , end = " " ) NEW_LINE print ( " ( " , - y + x_@@ centre , " , ▁ " , x + y_@@ centre , " ) " , sep = " " , end = " " ) NEW_LINE print ( " ( " , y + x_@@ centre , " , ▁ " , - x + y_@@ centre , " ) " , sep = " " , end = " " ) NEW_LINE print ( " ( " , - y + x_@@ centre , " , ▁ " , - x + y_@@ centre , " ) " , sep = " " ) NEW_LINE DEDENT DEDENT DEDENT
SM@@ ALLE@@ ST_@@ ELEMENT_@@ REPE@@ ATED_@@ EXAC@@ TL@@ Y_@@ K_@@ TIME@@ S_@@ NOT_@@ LIMI@@ TE@@ D_S@@ M@@ ALL_@@ RANGE | def smalle@@ st@@ K@@ Freq ( arr , n , k ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT res = sys . maxsize NEW_LINE res1 = sys . maxsize NEW_LINE for key , values in mp . items ( ) : NEW_LINE INDENT if values == k : NEW_LINE INDENT res = min ( res , key ) NEW_LINE DEDENT DEDENT return res if res != res1 else - 1 NEW_LINE DEDENT
MINIMUM_@@ X@@ OR_@@ VALUE_@@ PAIR | def min@@ XOR ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE min_@@ xor = 999999 NEW_LINE val = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ j ] NEW_LINE min_@@ xor = min ( min_@@ xor , val ) NEW_LINE DEDENT DEDENT return min_@@ xor NEW_LINE DEDENT
MIRR@@ OR_@@ CHARAC@@ TER@@ S_@@ STRING | def compute ( st , n ) : NEW_LINE INDENT reverse@@ Alphabet = " zy@@ x@@ w@@ v@@ ut@@ sr@@ qp@@ on@@ ml@@ k@@ ji@@ hg@@ fed@@ cb@@ a " NEW_LINE l = len ( st ) NEW_LINE answer = " " NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT answer = answer + st [ i ] ; NEW_LINE DEDENT for i in range ( n , l ) : NEW_LINE INDENT answer = ( answer + reverse@@ Alphabet [ ord ( st [ i ] ) - ord ( ' a ' ) ] ) ; NEW_LINE DEDENT return answer ; NEW_LINE DEDENT
PROGRAM_@@ CHECK_@@ PL@@ US_@@ PER@@ F@@ ECT_@@ NUMBER | def check@@ plu@@ sper@@ f@@ ect ( x ) : NEW_LINE INDENT temp = x NEW_LINE n = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x // 10 NEW_LINE n = n + 1 NEW_LINE DEDENT x = temp NEW_LINE sm = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sm = sm + ( int ) ( math . pow ( x % 10 , n ) ) NEW_LINE x = x // 10 NEW_LINE DEDENT return ( sm == temp ) NEW_LINE DEDENT
AR@@ C_@@ LENGTH_@@ ANGLE | def arc@@ Length ( diameter , angle ) : NEW_LINE INDENT if angle >= 360 : NEW_LINE INDENT print ( " Angle ▁ cannot ▁ be ▁ formed " ) NEW_LINE return 0 NEW_LINE DEDENT else : NEW_LINE INDENT arc = ( 3.14@@ 28@@ 57@@ 14@@ 28@@ 57@@ 143 * diameter ) * ( angle / 36@@ 0.0 ) NEW_LINE return arc NEW_LINE DEDENT DEDENT
FIND_@@ LAST_@@ INDEX_@@ CHARACTER_@@ STRING | def find@@ Last@@ Index ( str , x ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if str [ i ] == x : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
COUNT_@@ TRAI@@ LING_@@ ZER@@ O@@ ES_@@ FAC@@ TOR@@ I@@ AL_@@ NUMBER | def find@@ Trailing@@ Zeros ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 5 NEW_LINE while ( n / i >= 1 ) : NEW_LINE INDENT count += int ( n / i ) NEW_LINE i *= 5 NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT
ROTA@@ TE_@@ MATRIX_@@ 18@@ 0_@@ DEGRE@@ E | def rotate@@ Matrix ( mat ) : NEW_LINE INDENT i = N - 1 ; NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT j = N - 1 ; NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) ; NEW_LINE j = j - 1 ; NEW_LINE DEDENT print ( ) ; NEW_LINE i = i - 1 ; NEW_LINE DEDENT DEDENT
S@@ UM_@@ FI@@ BON@@ ACC@@ I_@@ NUMB@@ ERS | def calculate@@ Sum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fi@@ bo = [ 0 ] * ( n + 1 ) NEW_LINE fi@@ bo [ 1 ] = 1 NEW_LINE sm = fi@@ bo [ 0 ] + fi@@ bo [ 1 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fi@@ bo [ i ] = fi@@ bo [ i - 1 ] + fi@@ bo [ i - 2 ] NEW_LINE sm = sm + fi@@ bo [ i ] NEW_LINE DEDENT return sm NEW_LINE DEDENT
LAR@@ GE@@ ST_@@ LE@@ XI@@ CO@@ GRAP@@ HI@@ C_@@ ARRAY_@@ WITH_@@ AT_@@ MO@@ ST_@@ K_@@ CON@@ SEC@@ UTI@@ VE_@@ SWAP@@ S | def K@@ Swap@@ Maximum ( n , k ) : NEW_LINE INDENT global arr NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( k > 0 ) : NEW_LINE INDENT index@@ Position = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( k <= j - i ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ j ] > arr [ index@@ Position ] ) : NEW_LINE INDENT index@@ Position = j NEW_LINE DEDENT DEDENT for j in range ( index@@ Position , i , - 1 ) : NEW_LINE INDENT t = arr [ j ] NEW_LINE arr [ j ] = arr [ j - 1 ] NEW_LINE arr [ j - 1 ] = t NEW_LINE DEDENT k = k - index@@ Position - i NEW_LINE DEDENT DEDENT DEDENT
FIND_@@ WHE@@ THER_@@ GI@@ V@@ EN_@@ INTEGER_@@ POWER_@@ 3_@@ NOT | def check ( n ) : NEW_LINE INDENT return 11@@ 6@@ 22@@ 614@@ 67 % n == 0 NEW_LINE DEDENT
FIND_@@ THE_@@ TWO_@@ REPE@@ ATING_@@ ELEMEN@@ TS_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY | def print@@ Repe@@ ating ( arr , size ) : NEW_LINE INDENT print ( " Repe@@ ating ▁ elements ▁ are ▁ " , end = ' ' ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT for j in range ( i + 1 , size ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
C_@@ PROGRAM_@@ FIND_@@ AREA_@@ TRI@@ ANGLE | def find@@ Area ( a , b , c ) : NEW_LINE INDENT if ( a < 0 or b < 0 or c < 0 or ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) ) : NEW_LINE INDENT print ( ' Not ▁ a ▁ valid ▁ triang@@ len ' ) NEW_LINE return NEW_LINE DEDENT s = ( a + b + c ) / 2 NEW_LINE area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** 0.5 NEW_LINE print ( ' Area ▁ of ▁ a ▁ tra@@ ing@@ le ▁ is ▁ % f ' % area ) NEW_LINE DEDENT
GI@@ V@@ EN_@@ LARGE_@@ NUMBER_@@ CHECK@@ _SUB@@ SEQU@@ ENCE_@@ DIG@@ IT@@ S_@@ DI@@ VISI@@ BLE_@@ 8_@@ 1 | def isSub@@ Seq@@ Di@@ visible ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for i in range ( 10 ) ] for i in range ( n + 1 ) ] NEW_LINE arr = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ i ] = int ( str [ i - 1 ] ) ; NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i ] % 8 ] = 1 ; NEW_LINE for j in range ( 8 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) : NEW_LINE INDENT dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( dp [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
DELETE_@@ ARRAY_@@ ELEMEN@@ TS_@@ WHI@@ CH_@@ ARE_@@ SM@@ ALL@@ ER_@@ TH@@ AN_@@ NEXT_@@ OR_@@ BE@@ COM@@ E_@@ SMAL@@ LER | def delete@@ Elements ( arr , n , k ) : NEW_LINE INDENT st = [ ] NEW_LINE st . append ( arr [ 0 ] ) NEW_LINE top = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( st ) != 0 and count < k and st [ top ] < arr [ i ] ) : NEW_LINE INDENT st . pop ( ) NEW_LINE count += 1 NEW_LINE top -= 1 NEW_LINE DEDENT st . append ( arr [ i ] ) NEW_LINE top += 1 NEW_LINE DEDENT for i in range ( 0 , len ( st ) ) : NEW_LINE INDENT print ( st [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT
MINIMUM_@@ LENGTH@@ _SUB@@ ARRA@@ Y_S@@ UM_@@ GREATER_@@ GI@@ V@@ EN_@@ VALUE | def smalle@@ st@@ Sub@@ With@@ Sum ( arr , n , x ) : NEW_LINE INDENT curr_@@ sum = 0 NEW_LINE min_@@ len = n + 1 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT while ( curr_@@ sum <= x and end < n ) : NEW_LINE INDENT curr_@@ sum += arr [ end ] NEW_LINE end += 1 NEW_LINE DEDENT while ( curr_@@ sum > x and start < n ) : NEW_LINE INDENT if ( end - start < min_@@ len ) : NEW_LINE INDENT min_@@ len = end - start NEW_LINE DEDENT curr_@@ sum -= arr [ start ] NEW_LINE start += 1 NEW_LINE DEDENT DEDENT return min_@@ len NEW_LINE DEDENT
FIND_@@ PAIR@@ S_IN_@@ ARRAY_@@ WHO@@ SE_@@ SUM@@ S_@@ ALREADY_@@ EXI@@ ST_@@ IN_@@ ARRAY_@@ 1 | def find@@ Pair ( arr , n ) : NEW_LINE INDENT s = { i : 1 for i in arr } NEW_LINE found = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] + arr [ j ] in s . keys ( ) : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT if found == False : NEW_LINE INDENT print ( " Not ▁ exist " ) NEW_LINE DEDENT DEDENT
COUNT_@@ ARI@@ TH@@ ME@@ TIC_@@ PROG@@ RES@@ SION@@ _SUB@@ SEQU@@ EN@@ CES_@@ ARRAY | def nu@@ mo@@ f@@ AP ( a , n ) : NEW_LINE INDENT min@@ arr = + 2147483647 NEW_LINE max@@ arr = - 214748364@@ 8 NEW_LINE for i in range ( n ) : NEW_LINE INDENT min@@ arr = min ( min@@ arr , a [ i ] ) NEW_LINE max@@ arr = max ( max@@ arr , a [ i ] ) NEW_LINE DEDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE ans = n + 1 NEW_LINE for d in range ( ( min@@ arr - max@@ arr ) , ( max@@ arr - min@@ arr ) + 1 ) : NEW_LINE INDENT sum = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE if ( a [ i ] - d >= 1 and a [ i ] - d <= 1000000 ) : NEW_LINE INDENT dp [ i ] += sum [ a [ i ] - d ] NEW_LINE DEDENT ans += dp [ i ] - 1 NEW_LINE sum [ a [ i ] ] += dp [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
COUNT_@@ NUMB@@ ERS_@@ TH@@ AT_@@ DONT_@@ CONTA@@ IN_@@ 3 | def count ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return n NEW_LINE DEDENT elif n >= 3 and n < 10 : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT po = 1 NEW_LINE while n / po > 9 : NEW_LINE INDENT po = po * 10 NEW_LINE DEDENT ms@@ d = n / po NEW_LINE if ms@@ d != 3 : NEW_LINE INDENT return count ( ms@@ d ) * count ( po - 1 ) + count ( ms@@ d ) + count ( n % po ) NEW_LINE DEDENT else : NEW_LINE INDENT return count ( ms@@ d * po - 1 ) NEW_LINE DEDENT DEDENT
PROGRAM_@@ TO_@@ FIND_@@ TRANSP@@ OS@@ E_@@ OF_@@ A_@@ MATRIX_@@ 2 | def transpose ( A ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT A [ i ] [ j ] , A [ j ] [ i ] = A [ j ] [ i ] , A [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT
S@@ UM_@@ DIAG@@ ON@@ AL@@ S@@ _SP@@ IR@@ AL_@@ OD@@ D_@@ ORDER@@ _S@@ QU@@ ARE_@@ MATRIX | def spir@@ al@@ Di@@ a@@ Sum ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( 4 * n * n - 6 * n + 6 + spir@@ al@@ Di@@ a@@ Sum ( n - 2 ) ) NEW_LINE DEDENT
COUNT_@@ IN@@ VERSION@@ S_@@ OF@@ _SIZE_@@ THRE@@ E_@@ IN_@@ A_@@ GI@@ VE_@@ ARRAY | def getIn@@ v@@ Count ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE inv@@ count = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ k ] : NEW_LINE INDENT inv@@ count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return inv@@ count NEW_LINE DEDENT
FIN@@ D_S@@ UM_@@ NODE@@ S_@@ GI@@ V@@ EN_@@ PER@@ F@@ ECT_@@ BINARY_@@ TREE | def Sum@@ Nodes ( l ) : NEW_LINE INDENT leaf@@ Node@@ Count = pow ( 2 , l - 1 ) NEW_LINE vec = [ [ ] for i in range ( l ) ] NEW_LINE for i in range ( 1 , leaf@@ Node@@ Count + 1 ) : NEW_LINE INDENT vec [ l - 1 ] . append ( i ) NEW_LINE DEDENT for i in range ( l - 2 , - 1 , - 1 ) : NEW_LINE INDENT k = 0 NEW_LINE while ( k < len ( vec [ i + 1 ] ) - 1 ) : NEW_LINE INDENT vec [ i ] . append ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ) NEW_LINE k += 2 NEW_LINE DEDENT DEDENT Sum = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT for j in range ( len ( vec [ i ] ) ) : NEW_LINE INDENT Sum += vec [ i ] [ j ] NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT
S@@ UM_@@ OF_@@ ALL_@@ PRO@@ PER_@@ DI@@ VI@@ SOR@@ S_@@ OF_@@ A_@@ N@@ ATUR@@ AL_@@ NUMBER | def div@@ Sum ( num ) : NEW_LINE INDENT result = 0 NEW_LINE i = 2 NEW_LINE while i <= ( math . sqrt ( num ) ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT if ( i == ( num / i ) ) : NEW_LINE INDENT result = result + i ; NEW_LINE DEDENT else : NEW_LINE INDENT result = result + ( i + num / i ) ; NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return ( result + 1 ) ; NEW_LINE DEDENT
FIND_@@ A_@@ TR@@ IP@@ LET_@@ TH@@ AT_@@ S@@ UM_@@ TO_@@ A_@@ GI@@ V@@ EN_@@ VALUE_@@ 2 | def find@@ 3@@ Numbers ( A , arr_@@ size , sum ) : NEW_LINE INDENT for i in range ( 0 , arr_@@ size - 1 ) : NEW_LINE INDENT s = set ( ) NEW_LINE curr_@@ sum = sum - A [ i ] NEW_LINE for j in range ( i + 1 , arr_@@ size ) : NEW_LINE INDENT if ( curr_@@ sum - A [ j ] ) in s : NEW_LINE INDENT print ( " Trip@@ let ▁ is " , A [ i ] , " , ▁ " , A [ j ] , " , ▁ " , curr_@@ sum - A [ j ] ) NEW_LINE return True NEW_LINE DEDENT s . add ( A [ j ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
N@@ TH_@@ EV@@ EN_@@ LENGTH_@@ PA@@ LIN@@ DRO@@ ME | def even@@ length ( n ) : NEW_LINE INDENT res = n NEW_LINE for j in range ( len ( n ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT res += n [ j ] NEW_LINE DEDENT return res NEW_LINE DEDENT
FIN@@ DING_@@ POWER_@@ PRI@@ ME_@@ NUMBER_@@ P_@@ N | def Power@@ OFP@@ IN@@ n@@ factorial ( n , p ) : NEW_LINE INDENT ans = 0 ; NEW_LINE temp = p ; NEW_LINE while ( temp <= n ) : NEW_LINE INDENT ans += n / temp ; NEW_LINE temp = temp * p ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
MINIMUM_@@ CO@@ ST_@@ MAKE_@@ LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ SEQU@@ ENCE_@@ LENGTH_@@ K | def solve ( X , Y , l , r , k , dp ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if l < 0 or r < 0 : NEW_LINE INDENT return 1000000000 NEW_LINE DEDENT if dp [ l ] [ r ] [ k ] != - 1 : NEW_LINE INDENT return dp [ l ] [ r ] [ k ] NEW_LINE DEDENT cost = ( ( ord ( X [ l ] ) - ord ( ' a ' ) ) ^ ( ord ( Y [ r ] ) - ord ( ' a ' ) ) ) NEW_LINE dp [ l ] [ r ] [ k ] = min ( [ cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) , solve ( X , Y , l , r - 1 , k , dp ) ] ) NEW_LINE return dp [ l ] [ r ] [ k ] NEW_LINE DEDENT
PRINT_@@ STRING@@ _SPECI@@ FI@@ ED_@@ CHARACTER_@@ OC@@ CUR@@ RED_@@ GI@@ V@@ EN_@@ NO_@@ TIMES | def print@@ String ( str , ch , count ) : NEW_LINE INDENT oc@@ c , i = 0 , 0 NEW_LINE if ( count == 0 ) : NEW_LINE INDENT print ( str ) NEW_LINE DEDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ch ) : NEW_LINE INDENT oc@@ c += 1 NEW_LINE DEDENT if ( oc@@ c == count ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i < len ( str ) - 1 ) : NEW_LINE INDENT print ( str [ i + 1 : len ( str ) - i + 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Empty ▁ string " ) NEW_LINE DEDENT DEDENT
SORT_@@ 1_@@ N@@ _SW@@ APP@@ ING_@@ AD@@ J@@ AC@@ ENT_@@ ELEMENTS | def sorted@@ After@@ Swap ( A , B , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( B [ i ] == 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( B [ j ] == 1 ) : NEW_LINE INDENT j = j + 1 NEW_LINE DEDENT A = A [ 0 : i ] + sorted ( A [ i : j + 1 ] ) + A [ j + 1 : ] NEW_LINE i = j NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( A [ i ] != i + 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
GENERATE_@@ PYTH@@ AG@@ O@@ RE@@ AN_@@ TR@@ IP@@ LET@@ S | def py@@ th@@ ag@@ ore@@ an@@ Trip@@ lets ( limits ) : NEW_LINE INDENT c , m = 0 , 2 NEW_LINE while c < limits : NEW_LINE INDENT for n in range ( 1 , m ) : NEW_LINE INDENT a = m * m - n * n NEW_LINE b = 2 * m * n NEW_LINE c = m * m + n * n NEW_LINE if c > limits : NEW_LINE INDENT break NEW_LINE DEDENT print ( a , b , c ) NEW_LINE DEDENT m = m + 1 NEW_LINE DEDENT DEDENT
COUNT_@@ EV@@ EN_@@ LENGTH_@@ BIN@@ AR@@ Y@@ _SEQU@@ EN@@ CES_@@ WITH@@ _S@@ AME_@@ S@@ UM_@@ OF_@@ FIRST_@@ AND@@ _SECON@@ D_@@ HALF_@@ BITS | def count@@ Seq ( n , diff ) : NEW_LINE INDENT if ( abs ( diff ) > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 and diff == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( n == 1 and abs ( diff ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = ( count@@ Seq ( n - 1 , diff + 1 ) + 2 * count@@ Seq ( n - 1 , diff ) + count@@ Seq ( n - 1 , diff - 1 ) ) NEW_LINE return res NEW_LINE DEDENT
POSSI@@ BLE_@@ FORM_@@ TRIANGLE_@@ ARRAY_@@ VALUES | def is@@ Possible@@ Triangle ( arr , N ) : NEW_LINE INDENT if N < 3 : NEW_LINE INDENT return False NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( N - 2 ) : NEW_LINE INDENT if arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT
PRINT_@@ ARRAY_@@ STRING@@ S_S@@ OR@@ TED_@@ ORDER_@@ WITH@@ OUT_@@ COPY@@ ING_@@ ONE_@@ STRING_@@ AN@@ OTHER | def print@@ In@@ Sorted@@ Order ( arr , n ) : NEW_LINE INDENT index = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT index [ i ] = i NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT min = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) : NEW_LINE INDENT min = j NEW_LINE DEDENT DEDENT if ( min != i ) : NEW_LINE INDENT index [ min ] , index [ i ] = index [ i ] , index [ min ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ index [ i ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
GAME_@@ REPL@@ AC@@ ING_@@ ARRAY_@@ ELEMENTS | def play@@ Game ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT return 1 if len ( s ) % 2 == 0 else 2 NEW_LINE DEDENT
BASIC_@@ AND_@@ EXTENDED_@@ EUC@@ LI@@ DE@@ AN_@@ ALGORITH@@ MS | def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
SORT_@@ ARRAY_@@ WAVE_@@ FORM_@@ 2_1 | def sort@@ In@@ Wave ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if ( i > 0 and arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT arr [ i ] , arr [ i - 1 ] = arr [ i - 1 ] , arr [ i ] NEW_LINE DEDENT if ( i < n - 1 and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT DEDENT
MAX@@ IM@@ UM@@ _SUB@@ ARRA@@ Y_S@@ UM_@@ USING_@@ PRE@@ FIX@@ _S@@ UM | def maximum@@ Sum@@ Sub@@ array ( arr , n ) : NEW_LINE INDENT min_@@ prefix_@@ sum = 0 NEW_LINE res = - math . inf NEW_LINE prefix_@@ sum = [ ] NEW_LINE prefix_@@ sum . append ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix_@@ sum . append ( prefix_@@ sum [ i - 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT res = max ( res , prefix_@@ sum [ i ] - min_@@ prefix_@@ sum ) NEW_LINE min_@@ prefix_@@ sum = min ( min_@@ prefix_@@ sum , prefix_@@ sum [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
STRING_@@ CONTAIN@@ ING_@@ FIRST_@@ LET@@ TER_@@ EVER@@ Y_@@ WORD_@@ GI@@ V@@ EN_@@ STRING@@ _SPAC@@ ES | def first@@ Letter@@ Word ( str ) : NEW_LINE INDENT result = " " NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT elif ( str [ i ] != ' ▁ ' and v == True ) : NEW_LINE INDENT result += ( str [ i ] ) NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
S@@ UM_@@ PAIR@@ WI@@ SE_@@ PRODUC@@ TS_@@ 1 | def find@@ Sum ( n ) : NEW_LINE INDENT multi@@ Terms = n * ( n + 1 ) // 2 NEW_LINE sm = multi@@ Terms NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT multi@@ Terms = multi@@ Terms - ( i - 1 ) NEW_LINE sm = sm + multi@@ Terms * i NEW_LINE DEDENT return sm NEW_LINE DEDENT
CLU@@ STER@@ ING@@ PARTI@@ TION@@ ING_@@ AN_@@ ARRAY@@ _SU@@ CH_@@ TH@@ AT_@@ S@@ UM_@@ OF@@ _S@@ QU@@ ARE_@@ DIFF@@ ER@@ EN@@ CES_@@ IS_@@ MIN@@ IM@@ UM@@ _1 | def min@@ Cost ( a , n , k ) : NEW_LINE INDENT dp = [ [ inf for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] ; NEW_LINE dp [ 0 ] [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT for m in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] ; NEW_LINE DEDENT
LE@@ IB@@ NI@@ Z_@@ HAR@@ MON@@ IC_@@ TRI@@ ANGLE | def Le@@ ib@@ n@@ iz@@ Harmon@@ ic@@ Triangle ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] ; NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( "1 / " , end = " " ) ; NEW_LINE print ( i * C [ i - 1 ] [ j - 1 ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT
CHECK_@@ WHE@@ THER@@ _SECON@@ D_@@ STRING_@@ CAN_@@ FOR@@ MED_@@ FIRST_@@ STRING_@@ USING_@@ COUNT_@@ ARRAY | def can@@ Make@@ Str@@ 2 ( s1 , s2 ) : NEW_LINE INDENT count = { s1 [ i ] : 0 for i in range ( len ( s1 ) ) } NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT count [ s1 [ i ] ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT if count [ s2 [ i ] ] == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT count [ s2 [ i ] ] -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
S@@ UM_@@ MINIMUM_@@ MAXIMUM_@@ ELEMEN@@ TS@@ _SUB@@ ARRAY@@ S@@ _SIZE_@@ K | def Sum@@ Of@@ K@@ sub@@ Array ( arr , n , k ) : NEW_LINE INDENT Sum = 0 NEW_LINE S = deque ( ) NEW_LINE G = deque ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT while ( len ( S ) > 0 and arr [ S [ - 1 ] ] >= arr [ i ] ) : NEW_LINE INDENT S . pop ( ) NEW_LINE DEDENT while ( len ( G ) > 0 and arr [ G [ - 1 ] ] <= arr [ i ] ) : NEW_LINE INDENT G . pop ( ) NEW_LINE DEDENT G . append ( i ) NEW_LINE S . append ( i ) NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ] NEW_LINE while ( len ( S ) > 0 and S [ 0 ] <= i - k ) : NEW_LINE INDENT S . pop@@ left ( ) NEW_LINE DEDENT while ( len ( G ) > 0 and G [ 0 ] <= i - k ) : NEW_LINE INDENT G . pop@@ left ( ) NEW_LINE DEDENT while ( len ( S ) > 0 and arr [ S [ - 1 ] ] >= arr [ i ] ) : NEW_LINE INDENT S . pop ( ) NEW_LINE DEDENT while ( len ( G ) > 0 and arr [ G [ - 1 ] ] <= arr [ i ] ) : NEW_LINE INDENT G . pop ( ) NEW_LINE DEDENT G . append ( i ) NEW_LINE S . append ( i ) NEW_LINE DEDENT Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ] NEW_LINE return Sum NEW_LINE DEDENT
LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ SEQUENCE | def l@@ cs ( X , Y , m , n ) : NEW_LINE INDENT if m == 0 or n == 0 : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif X [ m - 1 ] == Y [ n - 1 ] : NEW_LINE INDENT return 1 + l@@ cs ( X , Y , m - 1 , n - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return max ( l@@ cs ( X , Y , m , n - 1 ) , l@@ cs ( X , Y , m - 1 , n ) ) ; NEW_LINE DEDENT DEDENT
MIN@@ IM@@ UM@@ _S@@ UM_@@ ABSOL@@ UTE_@@ DIFF@@ ER@@ ENCE_@@ PAIR@@ S_@@ TWO_@@ ARRAY@@ S | def find@@ Min@@ Sum ( a , b , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
COUNT_@@ DISTIN@@ CT_@@ NON_@@ NEGATIVE_@@ PAIR@@ S_@@ X_@@ Y_S@@ ATI@@ SF@@ Y_@@ IN@@ EQU@@ ALI@@ TY_@@ X@@ X_@@ YY_@@ N_@@ 2 | def count@@ Solutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE x = 0 NEW_LINE while ( x * x < n ) : NEW_LINE INDENT y = 0 NEW_LINE while ( x * x + y * y < n ) : NEW_LINE INDENT res = res + 1 NEW_LINE y = y + 1 NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
FIND_@@ NUMBER_@@ TRANS@@ FORMA@@ TION_@@ MAKE_@@ TWO_@@ MATRIX_@@ EQUAL | def count@@ Ops ( A , B , m , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT A [ i ] [ j ] -= B [ i ] [ j ] ; NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT DEDENT result = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += abs ( A [ i ] [ 0 ] ) ; NEW_LINE DEDENT for j in range ( m ) : NEW_LINE INDENT result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) ; NEW_LINE DEDENT return ( result ) ; NEW_LINE DEDENT
EF@@ FI@@ CI@@ EN@@ TL@@ Y_@@ FIND_@@ FIRST_@@ REPE@@ ATED_@@ CHARACTER_@@ STRING_@@ WITH@@ OUT_@@ USING_@@ ADDI@@ TIONAL_@@ DATA_@@ STRUC@@ TURE_@@ ONE_@@ TRA@@ VERS@@ AL | def First@@ Repe@@ ated ( string ) : NEW_LINE INDENT checker = 0 NEW_LINE pos = 0 NEW_LINE for i in string : NEW_LINE INDENT val = ord ( i ) - ord ( ' a ' ) ; NEW_LINE if ( ( checker & ( 1 << val ) ) > 0 ) : NEW_LINE INDENT return pos NEW_LINE DEDENT checker |= ( 1 << val ) NEW_LINE pos += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
MAXIMUM_@@ UNI@@ QUE_@@ ELEMENT_@@ EVER@@ Y@@ _SUB@@ ARRAY@@ _SIZE_@@ K | def find_@@ max ( A , N , K ) : NEW_LINE INDENT Count = dict ( ) NEW_LINE for i in range ( K - 1 ) : NEW_LINE INDENT Count [ A [ i ] ] = Count . get ( A [ i ] , 0 ) + 1 NEW_LINE DEDENT My@@ set = dict ( ) NEW_LINE for x in Count : NEW_LINE INDENT if ( Count [ x ] == 1 ) : NEW_LINE INDENT My@@ set [ x ] = 1 NEW_LINE DEDENT DEDENT for i in range ( K - 1 , N ) : NEW_LINE INDENT Count [ A [ i ] ] = Count . get ( A [ i ] , 0 ) + 1 NEW_LINE if ( Count [ A [ i ] ] == 1 ) : NEW_LINE INDENT My@@ set [ A [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT del My@@ set [ A [ i ] ] NEW_LINE DEDENT if ( len ( My@@ set ) == 0 ) : NEW_LINE INDENT print ( " Nothing " ) NEW_LINE DEDENT else : NEW_LINE INDENT max@@ m = - 10 ** 9 NEW_LINE for i in My@@ set : NEW_LINE INDENT max@@ m = max ( i , max@@ m ) NEW_LINE DEDENT print ( max@@ m ) NEW_LINE DEDENT x = A [ i - K + 1 ] NEW_LINE if x in Count . keys ( ) : NEW_LINE INDENT Count [ x ] -= 1 NEW_LINE if ( Count [ x ] == 1 ) : NEW_LINE INDENT My@@ set [ x ] = 1 NEW_LINE DEDENT if ( Count [ x ] == 0 ) : NEW_LINE INDENT del My@@ set [ x ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
MINIMUM_@@ CO@@ ST@@ _S@@ ORT_@@ MATRIX_@@ NUMB@@ ERS_@@ 0_@@ N@@ 2_1 | def calculate@@ Energy ( mat , n ) : NEW_LINE INDENT tot_@@ energy = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT q = mat [ i ] [ j ] // n NEW_LINE i_@@ des = q NEW_LINE j_@@ des = mat [ i ] [ j ] - ( n * q ) NEW_LINE tot_@@ energy += ( abs ( i_@@ des - i ) + abs ( j_@@ des - j ) ) NEW_LINE DEDENT DEDENT return tot_@@ energy NEW_LINE DEDENT
LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ STRING | def LC@@ Sub@@ Str ( X , Y , m , n ) : NEW_LINE INDENT LC@@ Su@@ ff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LC@@ Su@@ ff [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LC@@ Su@@ ff [ i ] [ j ] = LC@@ Su@@ ff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LC@@ Su@@ ff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LC@@ Su@@ ff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
MAX@@ IM@@ UM@@ _S@@ UM_@@ BIT@@ ON@@ IC@@ _SUB@@ ARRAY | def max@@ Sum@@ Bit@@ on@@ ic@@ Sub@@ Arr ( arr , n ) : NEW_LINE INDENT m@@ sis = [ None ] * n NEW_LINE ms@@ ds = [ None ] * n NEW_LINE max_@@ sum = 0 NEW_LINE m@@ sis [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT m@@ sis [ i ] = m@@ sis [ i - 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT m@@ sis [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT ms@@ ds [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT ms@@ ds [ i ] = ms@@ ds [ i + 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ms@@ ds [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max_@@ sum < ( m@@ sis [ i ] + ms@@ ds [ i ] - arr [ i ] ) ) : NEW_LINE INDENT max_@@ sum = ( m@@ sis [ i ] + ms@@ ds [ i ] - arr [ i ] ) NEW_LINE DEDENT DEDENT return max_@@ sum NEW_LINE DEDENT
NEW@@ MAN_@@ CON@@ WAY@@ _SEQU@@ ENCE | def sequence ( n ) : NEW_LINE INDENT if n == 1 or n == 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ; NEW_LINE DEDENT DEDENT
PRINT_@@ TR@@ IP@@ LET@@ S_S@@ OR@@ TED_@@ ARRAY_@@ FORM_@@ AP | def print@@ All@@ AP@@ Trip@@ lets ( arr , n ) : NEW_LINE INDENT s = [ ] ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] ; NEW_LINE if ( ( arr [ i ] - diff ) in arr ) : NEW_LINE INDENT print ( " { } ▁ { } ▁ { } " . format ( ( arr [ i ] - diff ) , arr [ i ] , arr [ j ] ) , end = " \n " ) ; NEW_LINE DEDENT DEDENT DEDENT s . append ( arr [ i ] ) ; NEW_LINE DEDENT
QUER@@ I@@ ES_@@ COUN@@ TS_@@ ARRAY_@@ ELEMEN@@ TS_@@ VALU@@ ES_@@ GI@@ V@@ EN_@@ RANGE | def count@@ InRange ( arr , n , x , y ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= x and arr [ i ] <= y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
HIGH@@ WA@@ Y_@@ B@@ IL@@ L@@ BOARD_@@ PRO@@ BLE@@ M | def max@@ Re@@ venue ( m , x , re@@ venue , n , t ) : NEW_LINE INDENT max@@ Rev = [ 0 ] * ( m + 1 ) NEW_LINE nx@@ tbb = 0 ; NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( nx@@ tbb < n ) : NEW_LINE INDENT if ( x [ nx@@ tbb ] != i ) : NEW_LINE INDENT max@@ Rev [ i ] = max@@ Rev [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( i <= t ) : NEW_LINE INDENT max@@ Rev [ i ] = max ( max@@ Rev [ i - 1 ] , re@@ venue [ nx@@ tbb ] ) NEW_LINE DEDENT else : NEW_LINE INDENT max@@ Rev [ i ] = max ( max@@ Rev [ i - t - 1 ] + re@@ venue [ nx@@ tbb ] , max@@ Rev [ i - 1 ] ) ; NEW_LINE DEDENT nx@@ tbb += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT max@@ Rev [ i ] = max@@ Rev [ i - 1 ] NEW_LINE DEDENT DEDENT return max@@ Rev [ m ] NEW_LINE DEDENT
CONSTRUC@@ T_@@ GRAPH_@@ GI@@ V@@ EN_@@ DEGRE@@ ES_@@ VER@@ TIC@@ ES | def print@@ Mat ( deg@@ seq , n ) : NEW_LINE INDENT mat = [ [ 0 ] * n for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( deg@@ seq [ i ] > 0 and deg@@ seq [ j ] > 0 ) : NEW_LINE INDENT deg@@ seq [ i ] -= 1 NEW_LINE deg@@ seq [ j ] -= 1 NEW_LINE mat [ i ] [ j ] = 1 NEW_LINE mat [ j ] [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT print ( " ▁ ▁ ▁ ▁ ▁ ▁ " , end = " ▁ " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( " ▁ " , " ( " , i , " ) " , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE print ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( " ▁ " , " ( " , i , " ) " , end = " " ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT print ( " ▁ ▁ ▁ ▁ ▁ " , mat [ i ] [ j ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
DETE@@ CT_@@ IF_@@ TWO_@@ INTEG@@ ERS_@@ HAVE_@@ OP@@ POSI@@ TE_@@ SIGN@@ S | def opposi@@ te@@ Sig@@ ns ( x , y ) : NEW_LINE INDENT return ( ( x ^ y ) < 0 ) ; NEW_LINE DEDENT
TRIANG@@ ULAR_@@ NUMB@@ ERS_@@ 1 | def is@@ Tri@@ angular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT c = ( - 2 * num ) NEW_LINE b , a = 1 , 1 NEW_LINE d = ( b * b ) - ( 4 * a * c ) NEW_LINE if ( d < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT roo@@ t1 = ( - b + math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE root@@ 2 = ( - b - math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE if ( roo@@ t1 > 0 and math . floor ( roo@@ t1 ) == roo@@ t1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( root@@ 2 > 0 and math . floor ( root@@ 2 ) == root@@ 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
FIND_@@ WHE@@ THER_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ IS_@@ A_@@ POWER_@@ OF_@@ 4_@@ OR_@@ NOT | def is@@ PowerOf@@ Four ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 4 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 4 NEW_LINE DEDENT return True NEW_LINE DEDENT
LAST_@@ NON_@@ ZERO_@@ DIG@@ IT_@@ FAC@@ TOR@@ I@@ AL | def last@@ Non@@ 0@@ Digit ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return dig [ n ] NEW_LINE DEDENT if ( ( ( n // 10 ) % 10 ) % 2 == 0 ) : NEW_LINE INDENT return ( 6 * last@@ Non@@ 0@@ Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT else : NEW_LINE INDENT return ( 4 * last@@ Non@@ 0@@ Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
SORT_@@ STRING_@@ AC@@ COR@@ DING_@@ ORDER_@@ DEFINED_@@ AN@@ OTHER_@@ STRING | def sort@@ By@@ Pattern ( str , pat ) : NEW_LINE INDENT global MAX_@@ CHAR NEW_LINE count = [ 0 ] * MAX_@@ CHAR NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT count [ ord ( str [ i ] ) - 97 ] += 1 NEW_LINE DEDENT index = 0 ; NEW_LINE str = " " NEW_LINE for i in range ( 0 , len ( pat ) ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < count [ ord ( pat [ i ] ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT str += pat [ i ] NEW_LINE j = j + 1 NEW_LINE index += 1 NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT
NUMBER_@@ VISI@@ BLE_@@ BOX@@ ES_@@ PUT@@ TING_@@ ONE_@@ IN@@ SIDE_@@ AN@@ OTHER | def minimum@@ Box ( arr , n ) : NEW_LINE INDENT q = collections . deque ( [ ] ) NEW_LINE arr . sort ( ) NEW_LINE q . append ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT now = q [ 0 ] NEW_LINE if ( arr [ i ] >= 2 * now ) : NEW_LINE INDENT q . pop@@ left ( ) NEW_LINE DEDENT q . append ( arr [ i ] ) NEW_LINE DEDENT return len ( q ) NEW_LINE DEDENT
SEARCH_@@ INSERT_@@ AND_@@ DELETE_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY | def binary@@ Search ( arr , low , high , key ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE if ( key == arr [ int ( mid ) ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( key > arr [ int ( mid ) ] ) : NEW_LINE INDENT return binary@@ Search ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT return ( binary@@ Search ( arr , low , ( mid - 1 ) , key ) ) NEW_LINE DEDENT
FIND_@@ THE_@@ TWO_@@ REPE@@ ATING_@@ ELEMEN@@ TS_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ 3 | def print@@ Repe@@ ating ( arr , size ) : NEW_LINE INDENT print ( " ▁ The ▁ repe@@ ating ▁ elements ▁ are " , end = " ▁ " ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ abs ( arr [ i ] ) ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( arr [ i ] ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
COUNT_@@ POSSI@@ BLE_@@ GROUP@@ S@@ _SIZE_@@ 2_@@ 3@@ _S@@ UM_@@ MULTIPLE_@@ 3 | def find@@ groups ( arr , n ) : NEW_LINE INDENT c = [ 0 , 0 , 0 ] NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT c [ arr [ i ] % 3 ] += 1 NEW_LINE DEDENT res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) NEW_LINE res += c [ 1 ] * c [ 2 ] NEW_LINE res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 NEW_LINE res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 NEW_LINE res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) NEW_LINE res += c [ 0 ] * c [ 1 ] * c [ 2 ] NEW_LINE return res NEW_LINE DEDENT
PRINT_@@ STRING_@@ IGNOR@@ ING_@@ ALTER@@ N@@ ATE_@@ OC@@ CURR@@ EN@@ CES_@@ CHARACTER | def print@@ String@@ Altern@@ ate ( string ) : NEW_LINE INDENT oc@@ c = { } NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT temp = string [ i ] . lower ( ) NEW_LINE oc@@ c [ temp ] = oc@@ c . get ( temp , 0 ) + 1 NEW_LINE if oc@@ c [ temp ] & 1 : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
NUMBER_@@ DAY@@ S_@@ TAN@@ K_@@ WI@@ LL_@@ BE@@ COM@@ E_@@ EMPTY | def min@@ Day@@ sTo@@ Empty ( C , l ) : NEW_LINE INDENT if ( l >= C ) : return C NEW_LINE eq_@@ root = ( math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 NEW_LINE return math . ceil ( eq_@@ root ) + l NEW_LINE DEDENT
REVERSE_@@ STRING_@@ WITH@@ OUT_@@ USING_@@ ANY_@@ TEMPOR@@ ARY_@@ VARIABLE | def rever@@ sing@@ String ( str , start , end ) : NEW_LINE INDENT while ( start < end ) : NEW_LINE INDENT str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) ; NEW_LINE str = ( str [ : end ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ end + 1 : ] ) ; NEW_LINE str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) ; NEW_LINE start += 1 ; NEW_LINE end -= 1 ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT
FREQU@@ ENCY_@@ ELEMENT_@@ UN@@ SOR@@ TED_@@ ARRAY | def count@@ Freq ( a , n ) : NEW_LINE INDENT hm = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT hm [ a [ i ] ] = hm . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT st = set ( ) NEW_LINE for x in hm : NEW_LINE INDENT st . add ( ( x , hm [ x ] ) ) NEW_LINE DEDENT cum@@ ul = 0 NEW_LINE for x in sorted ( st ) : NEW_LINE INDENT cum@@ ul += x [ 1 ] NEW_LINE print ( x [ 0 ] , cum@@ ul ) NEW_LINE DEDENT DEDENT
FIND_@@ ROTATION_@@ COUNT_@@ ROTA@@ TE@@ D_S@@ OR@@ TED_@@ ARRAY | def count@@ Rot@@ ations ( arr , n ) : NEW_LINE INDENT min = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( min > arr [ i ] ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE min_@@ index = i NEW_LINE DEDENT DEDENT return min_@@ index ; NEW_LINE DEDENT
LON@@ GE@@ ST_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQU@@ ENCE_@@ 1 | def lis ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE lis = [ 1 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT maximum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maximum = max ( maximum , lis [ i ] ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT
MEDI@@ AN_@@ OF_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S | def get@@ Medi@@ an ( ar@@ 1 , ar@@ 2 , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE m1 = - 1 NEW_LINE m2 = - 1 NEW_LINE count = 0 NEW_LINE while count < n + 1 : NEW_LINE INDENT count += 1 NEW_LINE if i == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar@@ 2 [ 0 ] NEW_LINE break NEW_LINE DEDENT elif j == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar@@ 1 [ 0 ] NEW_LINE break NEW_LINE DEDENT if ar@@ 1 [ i ] < ar@@ 2 [ j ] : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar@@ 1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar@@ 2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ( m1 + m2 ) / 2 NEW_LINE DEDENT
LE@@ XI@@ CO@@ GRAPHIC@@ AL@@ LY_@@ MINIMUM_@@ STRING_@@ RO@@ TATION | def min@@ Lex@@ Rotation ( str_ ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE arr = [ 0 ] * n NEW_LINE concat = str_ + str_ NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = concat [ i : n + i ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE return arr [ 0 ] NEW_LINE DEDENT
INTER@@ PO@@ LA@@ TION@@ _SEARCH | def interpol@@ ation@@ Search ( arr , n , x ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = ( n - 1 ) NEW_LINE while lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] : NEW_LINE INDENT if lo == hi : NEW_LINE INDENT if arr [ lo ] == x : NEW_LINE INDENT return lo ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT pos = lo + int ( ( ( float ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ) NEW_LINE if arr [ pos ] == x : NEW_LINE INDENT return pos NEW_LINE DEDENT if arr [ pos ] < x : NEW_LINE INDENT lo = pos + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT hi = pos - 1 ; NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
COUNT_@@ PAIR@@ S_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL_@@ GI@@ V@@ EN_@@ VALUE_@@ X_@@ 2 | def count@@ Pairs ( ar@@ r1 , ar@@ r2 , m , n , x ) : NEW_LINE INDENT count , l , r = 0 , 0 , n - 1 NEW_LINE while ( l < m and r >= 0 ) : NEW_LINE INDENT if ( ( ar@@ r1 [ l ] + ar@@ r2 [ r ] ) == x ) : NEW_LINE INDENT l += 1 NEW_LINE r -= 1 NEW_LINE count += 1 NEW_LINE DEDENT elif ( ( ar@@ r1 [ l ] + ar@@ r2 [ r ] ) < x ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
COUNT_@@ SUB@@ SE@@ TS_@@ DISTIN@@ CT_@@ EV@@ EN_@@ NUMB@@ ERS | def count@@ Sub@@ Sets ( arr , n ) : NEW_LINE INDENT us = set ( ) NEW_LINE ev@@ en_@@ count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT us . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in us : NEW_LINE INDENT ev@@ en_@@ count += 1 NEW_LINE DEDENT return pow ( 2 , ev@@ en_@@ count ) - 1 NEW_LINE DEDENT
COUNT_@@ NUMBER_OF_@@ OC@@ CURR@@ EN@@ CES_@@ OR_@@ FREQU@@ ENCY_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY | def count@@ Occurren@@ ces ( arr , n , x ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x == arr [ i ] : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
CONSTRUC@@ T_@@ THE_@@ ROO@@ TED_@@ TREE_@@ BY_@@ USING_@@ START_@@ AND_@@ FINI@@ SH_@@ TIME_@@ OF_@@ IT@@ S_@@ DFS_@@ TRA@@ VERS@@ AL | def Re@@ store_@@ Tree ( S , E ) : NEW_LINE INDENT Identity = N * [ 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT Identity [ Start [ i ] ] = i NEW_LINE DEDENT parent = N * [ - 1 ] NEW_LINE curr_@@ parent = Identity [ 0 ] NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT child = Identity [ j ] NEW_LINE if End [ child ] - j > 1 : NEW_LINE INDENT parent [ child ] = curr_@@ parent NEW_LINE curr_@@ parent = child NEW_LINE DEDENT else : NEW_LINE INDENT parent [ child ] = curr_@@ parent NEW_LINE while End [ child ] == End [ parent [ child ] ] : NEW_LINE INDENT child = parent [ child ] NEW_LINE curr_@@ parent = parent [ child ] NEW_LINE if curr_@@ parent == Identity [ 0 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT parent [ i ] += 1 NEW_LINE DEDENT return parent NEW_LINE DEDENT
NUMBER@@ _SUB@@ SEQU@@ EN@@ CES_@@ AB_@@ STRING_@@ REPE@@ ATED_@@ K_@@ TIMES | def count@@ Occurren@@ ces ( s , K ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c1 = 0 NEW_LINE c2 = 0 NEW_LINE C = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' a ' : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT if s [ i ] == ' b ' : NEW_LINE INDENT c2 += 1 NEW_LINE C += c1 NEW_LINE DEDENT DEDENT return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 NEW_LINE DEDENT
NUMBER@@ _SUB@@ STRING@@ S_@@ STRING | def count@@ Non@@ Empty@@ Sub@@ str ( str ) : NEW_LINE INDENT n = len ( str ) ; NEW_LINE return int ( n * ( n + 1 ) / 2 ) ; NEW_LINE DEDENT
MAXIMUM_@@ NUMBER_@@ CHARAC@@ TER@@ S_@@ TWO_@@ CHARACTER_@@ STRING_@@ 1 | def maximum@@ Chars ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = - 1 NEW_LINE first@@ Ind = [ - 1 for i in range ( MAX_@@ CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT first_@@ ind = first@@ Ind [ ord ( str1 [ i ] ) ] NEW_LINE if ( first_@@ ind == - 1 ) : NEW_LINE INDENT first@@ Ind [ ord ( str1 [ i ] ) ] = i NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , abs ( i - first_@@ ind - 1 ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
SUM@@ _S@@ QUAR@@ ES_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENTS | def su@@ mo@@ f@@ square ( n ) : NEW_LINE INDENT C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
PRINT_@@ POSSI@@ BLE_@@ STRING@@ S_@@ CAN_@@ MA@@ DE_@@ PL@@ AC@@ ING@@ _SPAC@@ ES_@@ 2 | def print@@ Sub@@ sequences ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE op@@ size = int ( pow ( 2 , n - 1 ) ) NEW_LINE for counter in range ( op@@ size ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( str [ j ] , end = " " ) NEW_LINE if ( counter & ( 1 << j ) ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT print ( " \n " , end = " " ) NEW_LINE DEDENT DEDENT
NON_@@ REPE@@ ATING_@@ ELEMENT | def first@@ Non@@ Repe@@ ating ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( i != j and arr [ i ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
S@@ UM_@@ OF_@@ ALL_@@ ELEMEN@@ TS_@@ UP_@@ TO_@@ N@@ TH_@@ ROW_@@ IN_@@ A_@@ PAS@@ CAL@@ S_@@ TRI@@ ANGLE | def calculate@@ Sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for row in range ( n ) : NEW_LINE INDENT sum = sum + ( 1 << row ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
CHECK_@@ TWO_@@ STRING@@ S_@@ K_@@ AN@@ AG@@ RAM@@ S_@@ NOT | def are@@ k@@ An@@ agram@@ s ( str1 , str2 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if ( len ( str2 ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT count@@ 1 = [ 0 ] * MAX_@@ CHAR NEW_LINE count2 = [ 0 ] * MAX_@@ CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT count@@ 1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( MAX_@@ CHAR ) : NEW_LINE INDENT if ( count@@ 1 [ i ] > count2 [ i ] ) : NEW_LINE INDENT count = count + abs ( count@@ 1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT DEDENT return ( count <= k ) NEW_LINE DEDENT
LON@@ GE@@ ST@@ _SP@@ AN@@ _S@@ UM_@@ TWO_@@ BINARY_@@ ARRAY@@ S | def lon@@ gest@@ Common@@ Sum ( ar@@ r1 , ar@@ r2 , n ) : NEW_LINE INDENT maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum@@ 1 = 0 NEW_LINE sum@@ 2 = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT sum@@ 1 += ar@@ r1 [ j ] NEW_LINE sum@@ 2 += ar@@ r2 [ j ] NEW_LINE if ( sum@@ 1 == sum@@ 2 ) : NEW_LINE INDENT len = j - i + 1 NEW_LINE if ( len > maxLen ) : NEW_LINE INDENT maxLen = len NEW_LINE DEDENT DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT
RE@@ MA@@ INDE@@ R_@@ 7_@@ LARGE_@@ NUMB@@ ERS | def remain@@ der@@ With@@ 7 ( num ) : NEW_LINE INDENT series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ] ; NEW_LINE series_@@ index = 0 ; NEW_LINE result = 0 ; NEW_LINE for i in range ( ( len ( num ) - 1 ) , - 1 , - 1 ) : NEW_LINE INDENT digit = ord ( num [ i ] ) - 48 ; NEW_LINE result += digit * series [ series_@@ index ] ; NEW_LINE series_@@ index = ( series_@@ index + 1 ) % 6 ; NEW_LINE result %= 7 ; NEW_LINE DEDENT if ( result < 0 ) : NEW_LINE INDENT result = ( result + 7 ) % 7 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT
LE@@ XI@@ CO@@ GRAPHIC@@ AL@@ LY_@@ PREVI@@ OUS_@@ PER@@ MU@@ TATION_@@ IN_@@ C | def prev@@ Permutation ( str ) : NEW_LINE INDENT n = len ( str ) - 1 NEW_LINE i = n NEW_LINE while ( i > 0 and str [ i - 1 ] <= str [ i ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i <= 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT j = i - 1 NEW_LINE while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT str = list ( str ) NEW_LINE temp = str [ i - 1 ] NEW_LINE str [ i - 1 ] = str [ j ] NEW_LINE str [ j ] = temp NEW_LINE str = ' ' . join ( str ) NEW_LINE str [ : : - 1 ] NEW_LINE return True , str NEW_LINE DEDENT
NUMBER@@ _SUB@@ SEQU@@ EN@@ CES_@@ FORM_@@ AI_@@ B@@ J_@@ CK | def count@@ Sub@@ sequences ( s ) : NEW_LINE INDENT a@@ Count = 0 NEW_LINE b@@ Count = 0 NEW_LINE c@@ Count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT a@@ Count = ( 1 + 2 * a@@ Count ) NEW_LINE DEDENT elif ( s [ i ] == ' b ' ) : NEW_LINE INDENT b@@ Count = ( a@@ Count + 2 * b@@ Count ) NEW_LINE DEDENT elif ( s [ i ] == ' c ' ) : NEW_LINE INDENT c@@ Count = ( b@@ Count + 2 * c@@ Count ) NEW_LINE DEDENT DEDENT return c@@ Count NEW_LINE DEDENT
PROGRAM_@@ PR@@ IN@@ T_ID@@ ENTITY_@@ MATRIX_@@ 1 | def is@@ Identity ( mat , N ) : NEW_LINE INDENT for row in range ( N ) : NEW_LINE INDENT for col in range ( N ) : NEW_LINE INDENT if ( row == col and mat [ row ] [ col ] != 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT elif ( row != col and mat [ row ] [ col ] != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT
MAXIMUM_@@ POSSI@@ BLE_@@ DIFF@@ ER@@ ENCE_@@ TW@@ O@@ _SUB@@ SE@@ TS_@@ ARRAY_@@ 1 | def max@@ Diff ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) != abs ( arr [ i + 1 ] ) ) : NEW_LINE INDENT result += abs ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT if ( arr [ n - 2 ] != arr [ n - 1 ] ) : NEW_LINE INDENT result += abs ( arr [ n - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
PROGRAM_@@ PRINT_@@ S@@ UM_@@ GI@@ V@@ EN_@@ N@@ TH_@@ TERM | def summ@@ ing@@ Series ( n ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT S += i * i - ( i - 1 ) * ( i - 1 ) NEW_LINE DEDENT return S NEW_LINE DEDENT
PRE@@ FIX@@ _S@@ UM_@@ 2D_@@ ARRAY | def prefix@@ Sum@@ 2D ( a ) : NEW_LINE INDENT global C , R NEW_LINE ps@@ a = [ [ 0 for x in range ( C ) ] for y in range ( R ) ] NEW_LINE ps@@ a [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , C ) : NEW_LINE INDENT ps@@ a [ 0 ] [ i ] = ( ps@@ a [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] ) NEW_LINE DEDENT for i in range ( 0 , R ) : NEW_LINE INDENT ps@@ a [ i ] [ 0 ] = ( ps@@ a [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT ps@@ a [ i ] [ j ] = ( ps@@ a [ i - 1 ] [ j ] + ps@@ a [ i ] [ j - 1 ] - ps@@ a [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( 0 , R ) : NEW_LINE INDENT for j in range ( 0 , C ) : NEW_LINE INDENT print ( ps@@ a [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
MAXIMUM_@@ NUMBER_@@ 2@@ X@@ 2@@ _S@@ QUAR@@ ES_@@ CAN_@@ FI@@ T_@@ IN@@ SIDE_@@ RIGHT_@@ ISO@@ SCE@@ LES_@@ TRI@@ ANGLE | def numberOf@@ Squ@@ ares ( base ) : NEW_LINE INDENT base = ( base - 2 ) NEW_LINE base = base / 2 NEW_LINE return base * ( base + 1 ) / 2 NEW_LINE DEDENT
GI@@ V@@ EN_@@ BINARY_@@ STRING_@@ COUNT_@@ NUMBER@@ _SUB@@ STRING@@ S_@@ START_@@ END_@@ 1_1 | def count@@ Sub@@ Str ( st , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == '1' ) : NEW_LINE INDENT m = m + 1 NEW_LINE DEDENT DEDENT return m * ( m - 1 ) // 2 NEW_LINE DEDENT
CONVER@@ TING_@@ ONE_@@ STRING_@@ USING_@@ APP@@ END_@@ DELETE_@@ LAST_@@ OPER@@ ATIONS | def is@@ Conver@@ tible ( str1 , str2 , k ) : NEW_LINE INDENT if ( ( len ( str1 ) + len ( str2 ) ) < k ) : NEW_LINE INDENT return True NEW_LINE DEDENT common@@ Length = 0 NEW_LINE for i in range ( 0 , min ( len ( str1 ) , len ( str2 ) ) , 1 ) : NEW_LINE INDENT if ( str1 [ i ] == str2 [ i ] ) : NEW_LINE INDENT common@@ Length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( ( k - len ( str1 ) - len ( str2 ) + 2 * common@@ Length ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
FIND_@@ THE_@@ NUMBER_@@ OC@@ CURR@@ ING_@@ OD@@ D_@@ NUMBER_OF_@@ TIME@@ S_@@ 2 | def getO@@ dd@@ Occurren@@ ce ( arr ) : NEW_LINE INDENT res = 0 NEW_LINE for element in arr : NEW_LINE INDENT res = res ^ element NEW_LINE DEDENT return res NEW_LINE DEDENT
S@@ UM_@@ MIDD@@ LE_@@ ROW_@@ COLUMN_@@ MATRIX | def middle@@ sum ( mat , n ) : NEW_LINE INDENT row_@@ sum = 0 NEW_LINE col_@@ sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT row_@@ sum += mat [ n // 2 ] [ i ] NEW_LINE DEDENT print ( " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " , row_@@ sum ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT col_@@ sum += mat [ i ] [ n // 2 ] NEW_LINE DEDENT print ( " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " , col_@@ sum ) NEW_LINE DEDENT
K_@@ TH_@@ DISTIN@@ CT_@@ OR_@@ NON_@@ REPE@@ ATING_@@ ELEMENT_@@ IN_@@ AN_@@ ARRAY | def print@@ K@@ Distin@@ ct ( arr , n , k ) : NEW_LINE INDENT dist@@ _count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE while j < n : NEW_LINE INDENT if ( i != j and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT dist@@ _count += 1 NEW_LINE DEDENT if ( dist@@ _count == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
MER@@ G@@ ING_@@ INTER@@ VAL@@ S | def merge@@ Intervals ( arr ) : NEW_LINE INDENT arr . sort ( key = lambda x : x [ 0 ] ) NEW_LINE m = [ ] NEW_LINE s = - 10000 NEW_LINE max = - 100000 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT a = arr [ i ] NEW_LINE if a [ 0 ] > max : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT m . append ( [ s , max ] ) NEW_LINE DEDENT max = a [ 1 ] NEW_LINE s = a [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT if a [ 1 ] >= max : NEW_LINE INDENT max = a [ 1 ] NEW_LINE DEDENT DEDENT DEDENT if max != - 100000 and [ s , max ] not in m : NEW_LINE INDENT m . append ( [ s , max ] ) NEW_LINE DEDENT print ( " The ▁ Mer@@ ged ▁ Intervals ▁ are ▁ : " , end = " ▁ " ) NEW_LINE for i in range ( len ( m ) ) : NEW_LINE INDENT print ( m [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
FIND_@@ NUMBER_@@ PER@@ F@@ ECT_@@ SQU@@ AR@@ ES_@@ TWO_@@ GI@@ V@@ EN_@@ NUMB@@ ERS_@@ 1 | def Count@@ Squ@@ ares ( a , b ) : NEW_LINE INDENT return ( math . floor ( math . sqrt ( b ) ) - math . ceil ( math . sqrt ( a ) ) + 1 ) NEW_LINE DEDENT
LAR@@ GE@@ ST@@ _SUB@@ SET_@@ WHO@@ SE_@@ ALL_@@ ELEMEN@@ TS_@@ ARE_@@ FI@@ BON@@ ACC@@ I_@@ NUMB@@ ERS | def find@@ Fi@@ b@@ Subset ( arr , n ) : NEW_LINE INDENT m = max ( arr ) NEW_LINE a = 0 NEW_LINE b = 1 NEW_LINE hash = [ ] NEW_LINE hash . append ( a ) NEW_LINE hash . append ( b ) NEW_LINE while ( b < m ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE hash . append ( b ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in hash : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
LE@@ XI@@ CO@@ GRAPHIC@@ AL_@@ CON@@ CAT@@ EN@@ ATION@@ _SUB@@ STRING@@ S_@@ STRING | def lex@@ ico@@ graphic@@ Sub@@ Concat ( s ) : NEW_LINE INDENT n = len ( s ) ; NEW_LINE sub@@ _count = ( n * ( n + 1 ) ) // 2 ; NEW_LINE arr = [ 0 ] * sub@@ _count ; NEW_LINE index = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , n - i + 1 ) : NEW_LINE INDENT arr [ index ] = s [ i : i + j ] ; NEW_LINE index += 1 ; NEW_LINE DEDENT DEDENT arr . sort ( ) ; NEW_LINE res = " " ; NEW_LINE for i in range ( sub@@ _count ) : NEW_LINE INDENT res += arr [ i ] ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
COUNT_@@ OPER@@ ATION@@ S_@@ MAKE_@@ STRING@@ AB_@@ FREE | def ab@@ Free ( s ) : NEW_LINE INDENT b_@@ count = 0 NEW_LINE res = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ ~ i ] == ' a ' : NEW_LINE INDENT res = ( res + b_@@ count ) NEW_LINE b_@@ count = ( b_@@ count * 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT b_@@ count += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
MAXIMUM_@@ HEIGHT_@@ OF_@@ TRIANG@@ ULAR_@@ AR@@ RANGE@@ MENT_@@ OF_@@ ARRAY_@@ VALU@@ ES_@@ 1 | def Maximum@@ Height ( a , n ) : NEW_LINE INDENT return ( - 1 + int ( math . sqrt ( 1 + ( 8 * n ) ) ) ) // 2 NEW_LINE DEDENT
MAXI@@ MI@@ ZE_@@ VOLUME_@@ CU@@ BO@@ ID_@@ GI@@ VEN@@ _S@@ UM@@ _SI@@ DES | def max@@ volume ( s ) : NEW_LINE INDENT max@@ value = 0 NEW_LINE i = 1 NEW_LINE for i in range ( s - 1 ) : NEW_LINE INDENT j = 1 NEW_LINE for j in range ( s ) : NEW_LINE INDENT k = s - i - j NEW_LINE max@@ value = max ( max@@ value , i * j * k ) NEW_LINE DEDENT DEDENT return max@@ value NEW_LINE DEDENT
PROGRAM_@@ DECIMAL_@@ HEX@@ A@@ DECIMAL_@@ CONVERSION | def dec@@ To@@ Hex@@ a ( n ) : NEW_LINE INDENT hexa@@ Deci@@ Num = [ '0' ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT temp = 0 ; NEW_LINE temp = n % 16 ; NEW_LINE if ( temp < 10 ) : NEW_LINE INDENT hexa@@ Deci@@ Num [ i ] = chr ( temp + 48 ) ; NEW_LINE i = i + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT hexa@@ Deci@@ Num [ i ] = chr ( temp + 55 ) ; NEW_LINE i = i + 1 ; NEW_LINE DEDENT n = int ( n / 16 ) ; NEW_LINE DEDENT j = i - 1 ; NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT print ( ( hexa@@ Deci@@ Num [ j ] ) , end = " " ) ; NEW_LINE j = j - 1 ; NEW_LINE DEDENT DEDENT
SM@@ ALLE@@ ST@@ _SUB@@ ARRAY_@@ WITH_@@ ALL_@@ OC@@ CURR@@ EN@@ CES_@@ OF_@@ A_@@ MO@@ ST_@@ FREQU@@ ENT_@@ ELEMENT | def smalle@@ st@@ Sub@@ segment ( a , n ) : NEW_LINE INDENT left = dict ( ) NEW_LINE count = dict ( ) NEW_LINE mx = 0 NEW_LINE mn , str@@ index = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE if ( x not in count . keys ( ) ) : NEW_LINE INDENT left [ x ] = i NEW_LINE count [ x ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ x ] += 1 NEW_LINE DEDENT if ( count [ x ] > mx ) : NEW_LINE INDENT mx = count [ x ] NEW_LINE mn = i - left [ x ] + 1 NEW_LINE str@@ index = left [ x ] NEW_LINE DEDENT elif ( count [ x ] == mx and i - left [ x ] + 1 < mn ) : NEW_LINE INDENT mn = i - left [ x ] + 1 NEW_LINE str@@ index = left [ x ] NEW_LINE DEDENT DEDENT for i in range ( str@@ index , str@@ index + mn ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
FIND_@@ LAST_@@ INDEX_@@ CHARACTER_@@ STRING_@@ 1 | def find@@ Last@@ Index ( str , x ) : NEW_LINE INDENT for i in range ( len ( str ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
RE@@ CAM@@ AN@@ S@@ _SEQU@@ ENCE | def rec@@ am@@ an ( n ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE arr [ 0 ] = 0 NEW_LINE print ( arr [ 0 ] , end = " , ▁ " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = arr [ i - 1 ] - i NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if ( ( arr [ j ] == curr ) or curr < 0 ) : NEW_LINE INDENT curr = arr [ i - 1 ] + i NEW_LINE break NEW_LINE DEDENT DEDENT arr [ i ] = curr NEW_LINE print ( arr [ i ] , end = " , ▁ " ) NEW_LINE DEDENT DEDENT
C_@@ PROGRAM_@@ FIN@@ D@@ _SECON@@ D_@@ FREQU@@ ENT_@@ CHARACTER | def get@@ Second@@ Most@@ Freq ( str ) : NEW_LINE INDENT NO_@@ OF_@@ CHARS = 256 NEW_LINE count = [ 0 ] * NO_@@ OF_@@ CHARS NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT first , second = 0 , 0 NEW_LINE for i in range ( NO_@@ OF_@@ CHARS ) : NEW_LINE INDENT if count [ i ] > count [ first ] : NEW_LINE INDENT second = first NEW_LINE first = i NEW_LINE DEDENT elif ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) : NEW_LINE INDENT second = i NEW_LINE DEDENT DEDENT return chr ( second ) NEW_LINE DEDENT
FIND_@@ MAXIMUM_@@ HEIGHT_@@ PY@@ RAM@@ ID_@@ FROM_@@ THE_@@ GI@@ V@@ EN_@@ ARRAY_@@ OF_@@ OBJECTS | def max@@ Level ( boxes , n ) : NEW_LINE INDENT boxes . sort ( ) NEW_LINE ans = 1 NEW_LINE prev_@@ width = boxes [ 0 ] NEW_LINE prev_@@ count = 1 NEW_LINE curr_@@ count = 0 NEW_LINE curr_@@ width = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_@@ width += boxes [ i ] NEW_LINE curr_@@ count += 1 NEW_LINE if ( curr_@@ width > prev_@@ width and curr_@@ count > prev_@@ count ) : NEW_LINE INDENT prev_@@ width = curr_@@ width NEW_LINE prev_@@ count = curr_@@ count NEW_LINE curr_@@ count = 0 NEW_LINE curr_@@ width = 0 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
COUN@@ TING_@@ IN@@ VERSIONS | def getIn@@ v@@ Count ( arr , n ) : NEW_LINE INDENT inv_@@ count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT inv_@@ count += 1 NEW_LINE DEDENT DEDENT DEDENT return inv_@@ count NEW_LINE DEDENT
SQU@@ AR@@ ES_@@ OF_@@ MATRIX_@@ DIAG@@ ON@@ AL_@@ ELEMENTS | def diag@@ onal@@ square ( mat , row , column ) : NEW_LINE INDENT print ( " Diagonal ▁ one ▁ : ▁ " , end = " " ) NEW_LINE for i in range ( 0 , row ) : NEW_LINE INDENT for j in range ( 0 , column ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT print ( " { } ▁ " . format ( mat [ i ] [ j ] * mat [ i ] [ j ] ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT print ( " ▁ \n \n Diagonal ▁ two ▁ : ▁ " , end = " " ) NEW_LINE for i in range ( 0 , row ) : NEW_LINE INDENT for j in range ( 0 , column ) : NEW_LINE INDENT if ( i + j == column - 1 ) : NEW_LINE INDENT print ( " { } ▁ " . format ( mat [ i ] [ j ] * mat [ i ] [ j ] ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
ROW_@@ WI@@ SE_@@ COMMON_@@ ELEMEN@@ TS_@@ TWO_@@ DIAG@@ ON@@ AL@@ S_S@@ QU@@ ARE_@@ MATRIX | def count@@ Common ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
E@@ UL@@ ERI@@ AN_@@ NUMBER | def e@@ ul@@ eri@@ an ( n , m ) : NEW_LINE INDENT if ( m >= n or n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return ( ( n - m ) * e@@ ul@@ eri@@ an ( n - 1 , m - 1 ) + ( m + 1 ) * e@@ ul@@ eri@@ an ( n - 1 , m ) ) NEW_LINE DEDENT
E@@ UL@@ ERS_@@ CRITERI@@ ON_@@ CHECK_@@ IF@@ _S@@ QU@@ ARE_@@ ROOT_@@ UN@@ DER_@@ MODUL@@ O_@@ P_@@ EXISTS | def square@@ Root@@ Exists ( n , p ) : NEW_LINE INDENT n = n % p NEW_LINE for x in range ( 2 , p , 1 ) : NEW_LINE INDENT if ( ( x * x ) % p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
COUNT_@@ POSSI@@ BLE_@@ PATH@@ S_@@ TOP_@@ LEFT_@@ BOTTOM_@@ RIGHT_@@ NX@@ M_@@ MATRIX_@@ 3 | def numberOf@@ Paths ( m , n ) : NEW_LINE INDENT for i in range ( n , ( m + n - 1 ) ) : NEW_LINE INDENT path *= i ; NEW_LINE path /@@ /= ( i - n + 1 ) ; NEW_LINE DEDENT return path ; NEW_LINE DEDENT
MODI@@ FY_@@ ARRAY_@@ TO_@@ MAXI@@ MI@@ ZE_@@ S@@ UM_@@ OF_@@ AD@@ J@@ AC@@ ENT_@@ DIFF@@ ER@@ EN@@ CES | def maximum@@ Difference@@ Sum ( arr , N ) : NEW_LINE INDENT dp = [ [ 0 , 0 ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 NEW_LINE DEDENT for i in range ( N - 1 ) : NEW_LINE INDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) NEW_LINE DEDENT return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) NEW_LINE DEDENT
STER@@ N_@@ BRO@@ CO@@ T_@@ SEQUENCE | def St@@ er@@ n@@ Sequence@@ Func ( Bro@@ co@@ t@@ Sequence , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT consi@@ dered_@@ element = Bro@@ co@@ t@@ Sequence [ i ] NEW_LINE pre@@ ced@@ ent = Bro@@ co@@ t@@ Sequence [ i - 1 ] NEW_LINE Bro@@ co@@ t@@ Sequence . append ( consi@@ dered_@@ element + pre@@ ced@@ ent ) NEW_LINE Bro@@ co@@ t@@ Sequence . append ( consi@@ dered_@@ element ) NEW_LINE DEDENT for i in range ( 0 , 15 ) : NEW_LINE INDENT print ( Bro@@ co@@ t@@ Sequence [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
NUMBER@@ _SUB@@ SEQU@@ EN@@ CES_@@ STRING_@@ DI@@ VISI@@ BLE_@@ N | def count@@ Di@@ visible@@ Sub@@ seq ( str , n ) : NEW_LINE INDENT l = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( l ) ] for y in range ( n ) ] NEW_LINE dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % n ] += 1 NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % n ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT return dp [ l - 1 ] [ 0 ] NEW_LINE DEDENT
HO@@ W_@@ TO_@@ BEGIN_@@ WITH_@@ COMP@@ E@@ TI@@ TIVE_@@ PROGR@@ AM@@ M@@ ING | def search ( arr , x ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( x == arr [ j ] ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
COUNT_@@ PAIR@@ S_@@ WITH_@@ GI@@ VEN@@ _S@@ UM@@ _1 | def get@@ Pai@@ rs@@ Count ( arr , n , sum ) : NEW_LINE INDENT m = [ 0 ] * 1000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT m [ arr [ i ] ] NEW_LINE m [ arr [ i ] ] += 1 NEW_LINE DEDENT tw@@ ice_@@ count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT tw@@ ice_@@ count += m [ sum - arr [ i ] ] NEW_LINE if ( sum - arr [ i ] == arr [ i ] ) : NEW_LINE INDENT tw@@ ice_@@ count -= 1 NEW_LINE DEDENT DEDENT return int ( tw@@ ice_@@ count / 2 ) NEW_LINE DEDENT
FIND_@@ THE_@@ MINIMUM_@@ DISTAN@@ CE_@@ BETWE@@ EN_@@ TWO_@@ NUMB@@ ERS | def min@@ Dist ( arr , n , x , y ) : NEW_LINE INDENT min_@@ dist = 9999@@ 9999 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( x == arr [ i ] and y == arr [ j ] or y == arr [ i ] and x == arr [ j ] ) and min_@@ dist > abs ( i - j ) : NEW_LINE INDENT min_@@ dist = abs ( i - j ) NEW_LINE DEDENT DEDENT return min_@@ dist NEW_LINE DEDENT DEDENT
FIND_@@ REPE@@ TI@@ TIVE_@@ ELEMENT_@@ 1_@@ N_@@ 1_2 | def find@@ Repe@@ ating ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT res = res ^ ( i + 1 ) ^ arr [ i ] NEW_LINE DEDENT res = res ^ arr [ n - 1 ] NEW_LINE return res NEW_LINE DEDENT
SHOR@@ TEST_@@ PATH_@@ EXAC@@ TL@@ Y_@@ K_@@ ED@@ GE@@ S_@@ DIREC@@ TED_@@ WE@@ I@@ GH@@ TED_@@ GRAPH_@@ 1 | def shor@@ test@@ Path ( graph , u , v , k ) : NEW_LINE INDENT global V , INF NEW_LINE sp = [ [ None ] * V for i in range ( V ) ] NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT sp [ i ] [ j ] = [ None ] * ( k + 1 ) NEW_LINE DEDENT DEDENT for e in range ( k + 1 ) : NEW_LINE INDENT for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT sp [ i ] [ j ] [ e ] = INF NEW_LINE if ( e == 0 and i == j ) : NEW_LINE INDENT sp [ i ] [ j ] [ e ] = 0 NEW_LINE DEDENT if ( e == 1 and graph [ i ] [ j ] != INF ) : NEW_LINE INDENT sp [ i ] [ j ] [ e ] = graph [ i ] [ j ] NEW_LINE DEDENT if ( e > 1 ) : NEW_LINE INDENT for a in range ( V ) : NEW_LINE INDENT if ( graph [ i ] [ a ] != INF and i != a and j != a and sp [ a ] [ j ] [ e - 1 ] != INF ) : NEW_LINE INDENT sp [ i ] [ j ] [ e ] = min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return sp [ u ] [ v ] [ k ] NEW_LINE DEDENT
LON@@ GE@@ ST@@ _SUB@@ ARRAY_@@ NOT_@@ K_@@ DISTIN@@ CT_@@ ELEMENTS | def longest ( a , n , k ) : NEW_LINE INDENT freq = [ 0 ] * n NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE now = 0 NEW_LINE l = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE if ( freq [ a [ i ] ] == 1 ) : NEW_LINE INDENT now += 1 NEW_LINE DEDENT while ( now > k ) : NEW_LINE INDENT freq [ a [ l ] ] -= 1 NEW_LINE if ( freq [ a [ l ] ] == 0 ) : NEW_LINE INDENT now -= 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT if ( i - l + 1 >= end - start + 1 ) : NEW_LINE INDENT end = i NEW_LINE start = l NEW_LINE DEDENT DEDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
MAXIMUM_@@ X@@ OR_@@ VALUE_@@ MATRIX | def max@@ XOR ( mat , N ) : NEW_LINE INDENT max_@@ xor = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT r_@@ xor = 0 NEW_LINE c_@@ xor = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT r_@@ xor = r_@@ xor ^ mat [ i ] [ j ] NEW_LINE c_@@ xor = c_@@ xor ^ mat [ j ] [ i ] NEW_LINE DEDENT if ( max_@@ xor < max ( r_@@ xor , c_@@ xor ) ) : NEW_LINE INDENT max_@@ xor = max ( r_@@ xor , c_@@ xor ) NEW_LINE DEDENT DEDENT return max_@@ xor NEW_LINE DEDENT
LENGTH_@@ LON@@ GE@@ ST@@ _SUB_@@ STRING_@@ CAN_@@ MAKE_@@ REMOVED | def lon@@ gest@@ Null ( S ) : NEW_LINE INDENT arr = [ ] NEW_LINE arr . append ( [ ' @ ' , - 1 ] ) NEW_LINE maxlen = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT arr . append ( [ S [ i ] , i ] ) NEW_LINE while ( len ( arr ) >= 3 and arr [ len ( arr ) - 3 ] [ 0 ] == '1' and arr [ len ( arr ) - 2 ] [ 0 ] == '0' and arr [ len ( arr ) - 1 ] [ 0 ] == '0' ) : NEW_LINE INDENT arr . pop ( ) NEW_LINE arr . pop ( ) NEW_LINE arr . pop ( ) NEW_LINE DEDENT tmp = arr [ - 1 ] NEW_LINE maxlen = max ( maxlen , i - tmp [ 1 ] ) NEW_LINE DEDENT return maxlen NEW_LINE DEDENT
LON@@ GE@@ ST_@@ ALTER@@ N@@ AT@@ ING@@ _SUB_@@ ARRAY_@@ START@@ ING_@@ EVER@@ Y_@@ INDEX_@@ BINARY_@@ ARRAY | def alternate@@ Sub@@ array ( arr , n ) : NEW_LINE INDENT len = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT len . append ( 0 ) NEW_LINE DEDENT len [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] ^ arr [ i + 1 ] == True ) : NEW_LINE INDENT len [ i ] = len [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT len [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( len [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT
WI@@ LD@@ CARD_@@ CHARACTER_@@ MATCH@@ ING | def match ( first , second ) : NEW_LINE INDENT if len ( first ) == 0 and len ( second ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if len ( first ) > 1 and first [ 0 ] == ' * ' and len ( second ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( len ( first ) > 1 and first [ 0 ] == ' ? ' ) or ( len ( first ) != 0 and len ( second ) != 0 and first [ 0 ] == second [ 0 ] ) : NEW_LINE INDENT return match ( first [ 1 : ] , second [ 1 : ] ) ; NEW_LINE DEDENT if len ( first ) != 0 and first [ 0 ] == ' * ' : NEW_LINE INDENT return match ( first [ 1 : ] , second ) or match ( first , second [ 1 : ] ) NEW_LINE DEDENT return False NEW_LINE DEDENT
FIND_@@ FAC@@ TOR@@ I@@ AL_@@ NUMB@@ ERS_@@ LESS_@@ EQUAL_@@ N | def print@@ Fac@@ tori@@ al@@ Num@@ s ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE x = 2 NEW_LINE while fact <= n : NEW_LINE INDENT print ( fact , end = " ▁ " ) NEW_LINE fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT DEDENT
FRI@@ END@@ S_@@ PAIR@@ ING_@@ PRO@@ BLE@@ M_@@ 2 | def count@@ Fri@@ ends@@ Pair@@ ings ( n ) : NEW_LINE INDENT a , b , c = 1 , 2 , 0 ; NEW_LINE if ( n <= 2 ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT for i in range ( 3 , n + 1 ) : NEW_LINE INDENT c = b + ( i - 1 ) * a ; NEW_LINE a = b ; NEW_LINE b = c ; NEW_LINE DEDENT return c ; NEW_LINE DEDENT
FIND_@@ THE_@@ LAR@@ GE@@ ST_@@ REC@@ TAN@@ GLE_@@ OF_@@ 1@@ S_@@ WITH@@ _SW@@ APP@@ ING_@@ OF_@@ COLUM@@ NS_@@ ALLOWED | def max@@ Area ( mat ) : NEW_LINE INDENT hist = [ [ 0 for i in range ( C + 1 ) ] for i in range ( R + 1 ) ] NEW_LINE for i in range ( 0 , C , 1 ) : NEW_LINE INDENT hist [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , R , 1 ) : NEW_LINE INDENT if ( ( mat [ j ] [ i ] == 0 ) ) : NEW_LINE INDENT hist [ j ] [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , R , 1 ) : NEW_LINE INDENT count = [ 0 for i in range ( R + 1 ) ] NEW_LINE for j in range ( 0 , C , 1 ) : NEW_LINE INDENT count [ hist [ i ] [ j ] ] += 1 NEW_LINE DEDENT col_@@ no = 0 NEW_LINE j = R NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT for k in range ( 0 , count [ j ] , 1 ) : NEW_LINE INDENT hist [ i ] [ col_@@ no ] = j NEW_LINE col_@@ no += 1 NEW_LINE DEDENT DEDENT j -= 1 NEW_LINE DEDENT DEDENT max_@@ area = 0 NEW_LINE for i in range ( 0 , R , 1 ) : NEW_LINE INDENT for j in range ( 0 , C , 1 ) : NEW_LINE INDENT curr_@@ area = ( j + 1 ) * hist [ i ] [ j ] NEW_LINE if ( curr_@@ area > max_@@ area ) : NEW_LINE INDENT max_@@ area = curr_@@ area NEW_LINE DEDENT DEDENT DEDENT return max_@@ area NEW_LINE DEDENT
SUM@@ _SEQU@@ ENCE_@@ 2_@@ 22_@@ 222 | def sum@@ Of@@ Series ( n ) : NEW_LINE INDENT return 0.02@@ 46 * ( math . pow ( 10 , n ) - 1 - ( 9 * n ) ) NEW_LINE DEDENT
PROGRAM_@@ FIRST_@@ FI@@ T_@@ ALGORITH@@ M_@@ MEMORY_@@ MAN@@ A@@ GEMENT | def first@@ Fit ( blockSize , m , process@@ Size , n ) : NEW_LINE INDENT allocation = [ - 1 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if blockSize [ j ] >= process@@ Size [ i ] : NEW_LINE INDENT allocation [ i ] = j NEW_LINE blockSize [ j ] -= process@@ Size [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( " ▁ Process ▁ No . ▁ Process ▁ Size ▁ ▁ ▁ ▁ ▁ ▁ Block ▁ no . " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( " ▁ " , i + 1 , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , process@@ Size [ i ] , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , end = " ▁ " ) NEW_LINE if allocation [ i ] != - 1 : NEW_LINE INDENT print ( allocation [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT DEDENT
CHECK_@@ IF_@@ A_@@ NUMBER_@@ IS_@@ POWER_@@ OF_@@ AN@@ OTHER_@@ NUMBER | def is@@ Power ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while ( pow < y ) : NEW_LINE INDENT pow = pow * x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT
DI@@ VI@@ DE_@@ LARGE_@@ NUMBER_@@ RE@@ PRESEN@@ TED_@@ STRING | def long@@ Division ( number , divisor ) : NEW_LINE INDENT ans = " " ; NEW_LINE idx = 0 ; NEW_LINE temp = ord ( number [ idx ] ) - ord ( '0' ) ; NEW_LINE while ( temp < divisor ) : NEW_LINE INDENT temp = ( temp * 10 + ord ( number [ idx + 1 ] ) - ord ( '0' ) ) ; NEW_LINE idx += 1 ; NEW_LINE DEDENT idx += 1 ; NEW_LINE while ( ( len ( number ) ) > idx ) : NEW_LINE INDENT ans += chr ( math . floor ( temp // divisor ) + ord ( '0' ) ) ; NEW_LINE temp = ( ( temp % divisor ) * 10 + ord ( number [ idx ] ) - ord ( '0' ) ) ; NEW_LINE idx += 1 ; NEW_LINE DEDENT ans += chr ( math . floor ( temp // divisor ) + ord ( '0' ) ) ; NEW_LINE if ( len ( ans ) == 0 ) : NEW_LINE INDENT return "0" ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
FIND_@@ ROW_@@ NUMBER_@@ BINARY_@@ MATRIX_@@ MAXIMUM_@@ NUMBER_@@ 1@@ S | def find@@ Max ( arr ) : NEW_LINE INDENT row = 0 NEW_LINE j = N - 1 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT while ( arr [ i ] [ j ] == 1 and j >= 0 ) : NEW_LINE INDENT row = i NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT print ( " Row ▁ number ▁ = ▁ " , row + 1 , " , ▁ Max@@ Count ▁ = ▁ " , N - 1 - j ) NEW_LINE DEDENT
MINIMUM_@@ ROTA@@ TIONS_@@ REQUIRED_@@ GET_@@ STRING | def find@@ Rot@@ ations ( str ) : NEW_LINE INDENT tmp = str + str NEW_LINE n = len ( str ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT substring = tmp [ i : n ] NEW_LINE if ( str == substring ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
COUNT_@@ POSSI@@ BLE_@@ PATH@@ S_@@ TOP_@@ LEFT_@@ BOTTOM_@@ RIGHT_@@ NX@@ M_@@ MATRIX | def numberOf@@ Paths ( m , n ) : NEW_LINE INDENT if ( m == 1 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return numberOf@@ Paths ( m - 1 , n ) + numberOf@@ Paths ( m , n - 1 ) NEW_LINE DEDENT
N_@@ TH_@@ NUMBER_@@ WHO@@ SE_@@ S@@ UM_@@ OF_@@ DIG@@ IT@@ S_@@ IS_@@ T@@ EN_@@ 1 | def find@@ N@@ th ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE curr = 19 ; NEW_LINE while ( True ) : NEW_LINE INDENT sum = 0 ; NEW_LINE x = curr ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT sum = sum + x % 10 ; NEW_LINE x = int ( x / 10 ) ; NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr ; NEW_LINE DEDENT curr += 9 ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT
S@@ UM_@@ NODE@@ S_@@ K_@@ TH_@@ LEVEL_@@ TREE_@@ RE@@ PRESEN@@ TED_@@ STRING_@@ 1 | def sum@@ At@@ K@@ th@@ Level ( tree , k , i , level ) : NEW_LINE INDENT if ( tree [ i [ 0 ] ] == ' ( ' ) : NEW_LINE INDENT i [ 0 ] += 1 NEW_LINE if ( tree [ i [ 0 ] ] == ' ) ' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT sum = 0 NEW_LINE if ( level == k ) : NEW_LINE INDENT sum = int ( tree [ i [ 0 ] ] ) NEW_LINE DEDENT i [ 0 ] += 1 NEW_LINE left@@ sum = sum@@ At@@ K@@ th@@ Level ( tree , k , i , level + 1 ) NEW_LINE i [ 0 ] += 1 NEW_LINE right@@ sum = sum@@ At@@ K@@ th@@ Level ( tree , k , i , level + 1 ) NEW_LINE i [ 0 ] += 1 NEW_LINE return sum + left@@ sum + right@@ sum NEW_LINE DEDENT DEDENT
COUNT_@@ OF@@ DIFF@@ ER@@ ENT_@@ WAY@@ S_@@ EXP@@ RESS_@@ N_S@@ UM_@@ 1_@@ 3_@@ 4 | def count@@ W@@ ays ( n ) : NEW_LINE INDENT DP = [ 0 for i in range ( 0 , n + 1 ) ] NEW_LINE DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1 NEW_LINE DP [ 3 ] = 2 NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ] NEW_LINE DEDENT return DP [ n ] NEW_LINE DEDENT
MAXIMUM_@@ EQU@@ LIB@@ RI@@ UM@@ _S@@ UM_@@ ARRAY | def find@@ Max@@ Sum ( arr , n ) : NEW_LINE INDENT res = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix_@@ sum = arr [ i ] NEW_LINE for j in range ( i ) : NEW_LINE INDENT prefix_@@ sum += arr [ j ] NEW_LINE DEDENT suffix_@@ sum = arr [ i ] NEW_LINE j = n - 1 NEW_LINE while ( j > i ) : NEW_LINE INDENT suffix_@@ sum += arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT if ( prefix_@@ sum == suffix_@@ sum ) : NEW_LINE INDENT res = max ( res , prefix_@@ sum ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
STE@@ INS_@@ ALGORITH@@ M_@@ FOR_@@ FIN@@ DING_@@ GC@@ D_@@ 1 | def gcd ( a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( ( ~ a & 1 ) == 1 ) : NEW_LINE INDENT if ( ( b & 1 ) == 1 ) : NEW_LINE INDENT return gcd ( a >> 1 , b ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( gcd ( a >> 1 , b >> 1 ) << 1 ) NEW_LINE DEDENT DEDENT if ( ( ~ b & 1 ) == 1 ) : NEW_LINE INDENT return gcd ( a , b >> 1 ) NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( ( a - b ) >> 1 , b ) NEW_LINE DEDENT return gcd ( ( b - a ) >> 1 , a ) NEW_LINE DEDENT
PROGRAM_@@ TO_@@ FIND_@@ THE_@@ VOLUME_@@ OF_@@ A_@@ TRIANG@@ ULAR_@@ PRI@@ SM | def find@@ Volume ( l , b , h ) : NEW_LINE INDENT return ( ( l * b * h ) / 2 ) NEW_LINE DEDENT
FIND_@@ REC@@ TAN@@ GLE_@@ BINARY_@@ MATRIX_@@ COR@@ NE@@ RS_@@ 1 | def is@@ Rectangle ( m ) : NEW_LINE INDENT rows = len ( m ) NEW_LINE if ( rows == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT columns = len ( m [ 0 ] ) NEW_LINE for y1 in range ( rows ) : NEW_LINE INDENT for x1 in range ( columns ) : NEW_LINE INDENT if ( m [ y1 ] [ x1 ] == 1 ) : NEW_LINE INDENT for y2 in range ( y1 + 1 , rows ) : NEW_LINE INDENT for x2 in range ( x1 + 1 , columns ) : NEW_LINE INDENT if ( m [ y1 ] [ x2 ] == 1 and m [ y2 ] [ x1 ] == 1 and m [ y2 ] [ x2 ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
CHECK_@@ IF_@@ STRING_@@ RE@@ MA@@ INS_@@ PA@@ LIN@@ DRO@@ ME_@@ AFTER_@@ REMO@@ V@@ ING_@@ GI@@ V@@ EN_@@ NUMBER_OF_@@ CHARAC@@ TERS | def is@@ Possible ( str , n ) : NEW_LINE INDENT l = len ( str ) NEW_LINE if ( l >= n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
CHECK_@@ STAR@@ _@@ GRAP@@ H | def check@@ Star ( mat ) : NEW_LINE INDENT global size NEW_LINE vertex@@ D1 = 0 NEW_LINE vertex@@ D@@ n_@@ 1 = 0 NEW_LINE if ( size == 1 ) : NEW_LINE INDENT return ( mat [ 0 ] [ 0 ] == 0 ) NEW_LINE DEDENT if ( size == 2 ) : NEW_LINE INDENT return ( mat [ 0 ] [ 0 ] == 0 and mat [ 0 ] [ 1 ] == 1 and mat [ 1 ] [ 0 ] == 1 and mat [ 1 ] [ 1 ] == 0 ) NEW_LINE DEDENT for i in range ( 0 , size ) : NEW_LINE INDENT degree@@ I = 0 NEW_LINE for j in range ( 0 , size ) : NEW_LINE INDENT if ( mat [ i ] [ j ] ) : NEW_LINE INDENT degree@@ I = degree@@ I + 1 NEW_LINE DEDENT DEDENT if ( degree@@ I == 1 ) : NEW_LINE INDENT vertex@@ D1 = vertex@@ D1 + 1 NEW_LINE DEDENT elif ( degree@@ I == size - 1 ) : NEW_LINE INDENT vertex@@ D@@ n_@@ 1 = vertex@@ D@@ n_@@ 1 + 1 NEW_LINE DEDENT DEDENT return ( vertex@@ D1 == ( size - 1 ) and vertex@@ D@@ n_@@ 1 == 1 ) NEW_LINE DEDENT
ROO@@ TS_@@ OF_@@ UNI@@ TY | def print@@ Roots ( n ) : NEW_LINE INDENT theta = math . pi * 2 / n NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT real = math . cos ( k * theta ) NEW_LINE img = math . sin ( k * theta ) NEW_LINE print ( real , end = " ▁ " ) NEW_LINE if ( img >= 0 ) : NEW_LINE INDENT print ( " ▁ + ▁ i ▁ " , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ - ▁ i ▁ " , end = " ▁ " ) NEW_LINE DEDENT print ( abs ( img ) ) NEW_LINE DEDENT DEDENT
FIND_@@ LAR@@ GE@@ ST_@@ D_@@ IN_@@ ARRAY@@ _SU@@ CH_@@ TH@@ AT_@@ A_@@ B_@@ C_@@ D | def find@@ Large@@ std ( S , n ) : NEW_LINE INDENT found = False NEW_LINE S . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( i == k ) : NEW_LINE INDENT continue NEW_LINE DEDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( i == l ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : NEW_LINE INDENT found = True NEW_LINE return S [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
GI@@ V@@ EN_@@ NUMBER_@@ STRING_@@ FIND_@@ NUMBER_@@ CON@@ TI@@ GU@@ OU@@ S@@ _SUB@@ SEQU@@ EN@@ CES_@@ RECUR@@ SI@@ VEL@@ Y_@@ ADD_@@ 9@@ _SET_@@ 2 | def count@@ 9@@ s ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE d = [ 0 for i in range ( 9 ) ] NEW_LINE d [ 0 ] = 1 NEW_LINE result = 0 NEW_LINE mod_@@ sum = 0 NEW_LINE continu@@ ous_@@ zero = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ord ( number [ i ] ) - ord ( '0' ) == 0 ) : NEW_LINE INDENT continu@@ ous_@@ zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continu@@ ous_@@ zero = 0 NEW_LINE DEDENT mod_@@ sum += ord ( number [ i ] ) - ord ( '0' ) NEW_LINE mod_@@ sum %= 9 NEW_LINE result += d [ mod_@@ sum ] NEW_LINE d [ mod_@@ sum ] += 1 NEW_LINE result -= continu@@ ous_@@ zero NEW_LINE DEDENT return result NEW_LINE DEDENT
LE@@ XI@@ CO@@ GRAPHIC@@ AL_@@ MAX@@ IM@@ UM@@ _SUB@@ STRING_@@ STRING | def Lex@@ ico@@ graphic@@ al@@ Max@@ String ( str ) : NEW_LINE INDENT mx = " " NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT mx = max ( mx , str [ i : ] ) NEW_LINE DEDENT return mx NEW_LINE DEDENT
CHECK_@@ TWO_@@ GI@@ VEN@@ _SE@@ TS_@@ DIS@@ JO@@ INT_@@ 1 | def are@@ Dis@@ joint ( set1 , set2 , m , n ) : NEW_LINE INDENT set1 . sort ( ) NEW_LINE set2 . sort ( ) NEW_LINE i = 0 ; j = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( set1 [ i ] < set2 [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( set2 [ j ] < set1 [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
EQU@@ ILI@@ BRI@@ UM_@@ INDEX_@@ OF_@@ AN_@@ ARRAY_@@ 1 | def equi@@ lib@@ ri@@ um ( arr ) : NEW_LINE INDENT total_@@ sum = sum ( arr ) NEW_LINE left@@ sum = 0 NEW_LINE for i , num in enumerate ( arr ) : NEW_LINE INDENT total_@@ sum -= num NEW_LINE if left@@ sum == total_@@ sum : NEW_LINE INDENT return i NEW_LINE DEDENT left@@ sum += num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
AREA_@@ CIRCUM@@ SCRI@@ BED_@@ CI@@ R@@ CLE_@@ SQUARE | def are@@ ac@@ ir@@ cum@@ scri@@ bed ( a ) : NEW_LINE INDENT return ( a * a * ( PI / 2 ) ) NEW_LINE DEDENT
LON@@ GE@@ ST_@@ REPE@@ ATING_@@ AND_@@ NON_@@ OVER@@ L@@ APP@@ ING@@ _SUB@@ STRING | def lon@@ gest@@ Repeated@@ Sub@@ string ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE L@@ CS@@ Re = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE res = " " NEW_LINE res_@@ length = 0 NEW_LINE index = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and L@@ CS@@ Re [ i - 1 ] [ j - 1 ] < ( j - i ) ) : NEW_LINE INDENT L@@ CS@@ Re [ i ] [ j ] = L@@ CS@@ Re [ i - 1 ] [ j - 1 ] + 1 NEW_LINE if ( L@@ CS@@ Re [ i ] [ j ] > res_@@ length ) : NEW_LINE INDENT res_@@ length = L@@ CS@@ Re [ i ] [ j ] NEW_LINE index = max ( i , index ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT L@@ CS@@ Re [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT if ( res_@@ length > 0 ) : NEW_LINE INDENT for i in range ( index - res_@@ length + 1 , index + 1 ) : NEW_LINE INDENT res = res + str [ i - 1 ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
HO@@ W_@@ TO_@@ AV@@ OID_@@ OVERFLOW_@@ IN_@@ MODUL@@ AR_@@ MULTIP@@ LIC@@ ATION | def mul@@ mod ( a , b , mod ) : NEW_LINE INDENT res = 0 ; NEW_LINE a = a % mod ; NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod ; NEW_LINE DEDENT a = ( a * 2 ) % mod ; NEW_LINE b /@@ /= 2 ; NEW_LINE DEDENT return res % mod ; NEW_LINE DEDENT
PA@@ IR_@@ WITH_@@ GI@@ V@@ EN_@@ PRODUCT_@@ SET_@@ 1_@@ FIND_@@ IF_@@ ANY_@@ PA@@ IR_@@ EXI@@ ST@@ S_@@ 1 | def is@@ Product ( arr , n , x ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return False NEW_LINE DEDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT if x % arr [ i ] == 0 : NEW_LINE INDENT if x // arr [ i ] in s : NEW_LINE INDENT return True NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
S@@ UM_@@ K_@@ TH_@@ GROUP_@@ OD@@ D_@@ POSITIVE_@@ NUMB@@ ERS | def k@@ th@@ group@@ sum ( k ) : NEW_LINE INDENT cur = int ( ( k * ( k - 1 ) ) + 1 ) NEW_LINE sum = 0 NEW_LINE while k : NEW_LINE INDENT sum += cur NEW_LINE cur += 2 NEW_LINE k = k - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
FIND_@@ ELEMEN@@ TS_@@ ARRAY_@@ LEA@@ ST_@@ TWO_@@ GREATER_@@ ELEMEN@@ TS_@@ 1 | def find@@ Elements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
MINIMUM_@@ STE@@ PS_@@ TO_@@ DELETE_@@ A_@@ STRING_@@ AFTER_@@ REPE@@ ATED_@@ DELE@@ TION_@@ OF_@@ PA@@ LIN@@ DRO@@ ME_@@ SUB@@ STRINGS | def min@@ Step@@ To@@ Delete@@ String ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( N + 1 ) ] for y in range ( N + 1 ) ] NEW_LINE for l in range ( 1 , N + 1 ) : NEW_LINE INDENT i = 0 NEW_LINE j = l - 1 NEW_LINE while j < N : NEW_LINE INDENT if ( l == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] NEW_LINE if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT for K in range ( i + 2 , j + 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ K ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return dp [ 0 ] [ N - 1 ] NEW_LINE DEDENT
CAL@@ CUL@@ ATE_@@ AREA_@@ TE@@ TRA@@ HE@@ DRO@@ N | def vol_@@ te@@ tra ( side ) : NEW_LINE INDENT volume = ( side ** 3 / ( 6 * math . sqrt ( 2 ) ) ) NEW_LINE return round ( volume , 2 ) NEW_LINE DEDENT
SI@@ EV@@ E_@@ OF_@@ AT@@ K@@ IN | def Si@@ eve@@ Of@@ At@@ kin ( limit ) : NEW_LINE INDENT if ( limit > 2 ) : NEW_LINE INDENT print ( 2 , end = " ▁ " ) NEW_LINE DEDENT if ( limit > 3 ) : NEW_LINE INDENT print ( 3 , end = " ▁ " ) NEW_LINE DEDENT si@@ eve = [ False ] * limit NEW_LINE for i in range ( 0 , limit ) : NEW_LINE INDENT si@@ eve [ i ] = False NEW_LINE DEDENT x = 1 NEW_LINE while ( x * x < limit ) : NEW_LINE INDENT y = 1 NEW_LINE while ( y * y < limit ) : NEW_LINE INDENT n = ( 4 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and ( n % 12 == 1 or n % 12 == 5 ) ) : NEW_LINE INDENT si@@ eve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and n % 12 == 7 ) : NEW_LINE INDENT si@@ eve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) - ( y * y ) NEW_LINE if ( x > y and n <= limit and n % 12 == 11 ) : NEW_LINE INDENT si@@ eve [ n ] ^= True NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT r = 5 NEW_LINE while ( r * r < limit ) : NEW_LINE INDENT if ( si@@ eve [ r ] ) : NEW_LINE INDENT for i in range ( r * r , limit , r * r ) : NEW_LINE INDENT si@@ eve [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for a in range ( 5 , limit ) : NEW_LINE INDENT if ( si@@ eve [ a ] ) : NEW_LINE INDENT print ( a , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
LENGTH_@@ OF_THE_@@ LON@@ GE@@ ST_@@ ARI@@ TH@@ MA@@ TIC_@@ PROG@@ RES@@ SION_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY | def l@@ eng@@ ht@@ Of@@ Lon@@ gest@@ AP ( set , n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE l@@ lap = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ n - 1 ] = 2 NEW_LINE DEDENT for j in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k <= n - 1 ) : NEW_LINE INDENT if ( set [ i ] + set [ k ] < 2 * set [ j ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = L [ j ] [ k ] + 1 NEW_LINE l@@ lap = max ( l@@ lap , L [ i ] [ j ] ) NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return l@@ lap NEW_LINE DEDENT
COUNT_@@ GROUP@@ INGS_@@ NUMBER@@ _S@@ UM_@@ DIG@@ IT@@ S_@@ EVER@@ Y@@ _SUB_@@ GROUP_@@ LESS_@@ EQUAL@@ S_@@ IM@@ MEDI@@ ATE_@@ RIGHT_@@ SUB_@@ GROUP_@@ 1 | def count@@ Groups ( position , previous_@@ sum , length , num ) : NEW_LINE INDENT if ( position == length ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ position ] [ previous_@@ sum ] != - 1 ) : NEW_LINE INDENT return dp [ position ] [ previous_@@ sum ] NEW_LINE DEDENT dp [ position ] [ previous_@@ sum ] = 0 NEW_LINE res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( position , length ) : NEW_LINE INDENT sum += ( ord ( num [ i ] ) - ord ( '0' ) ) NEW_LINE if ( sum >= previous_@@ sum ) : NEW_LINE INDENT res += count@@ Groups ( i + 1 , sum , length , num ) NEW_LINE DEDENT DEDENT dp [ position ] [ previous_@@ sum ] = res NEW_LINE return res NEW_LINE DEDENT
LON@@ GE@@ ST@@ _SP@@ AN@@ _S@@ UM_@@ TWO_@@ BINARY_@@ ARRAY@@ S_@@ 1 | def lon@@ gest@@ Common@@ Sum ( ar@@ r1 , ar@@ r2 , n ) : NEW_LINE INDENT maxLen = 0 NEW_LINE pres@@ um@@ 1 = pres@@ um@@ 2 = 0 NEW_LINE diff = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT pres@@ um@@ 1 += ar@@ r1 [ i ] NEW_LINE pres@@ um@@ 2 += ar@@ r2 [ i ] NEW_LINE curr_@@ diff = pres@@ um@@ 1 - pres@@ um@@ 2 NEW_LINE if curr_@@ diff == 0 : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif curr_@@ diff not in diff : NEW_LINE INDENT diff [ curr_@@ diff ] = i NEW_LINE DEDENT else : NEW_LINE INDENT length = i - diff [ curr_@@ diff ] NEW_LINE maxLen = max ( maxLen , length ) NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT
PROGRAM_@@ TO_@@ PRINT_@@ FIRST_@@ N_@@ FI@@ BON@@ ACC@@ I_@@ NUMB@@ ERS | def print@@ Fi@@ bon@@ ac@@ ci@@ Numbers ( n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT for x in range ( 0 , n ) : NEW_LINE INDENT print ( f2 , end = " ▁ " ) NEW_LINE next = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = next NEW_LINE DEDENT DEDENT
LAR@@ GE@@ ST@@ _S@@ UM_@@ CON@@ TI@@ GU@@ OU@@ S@@ _SUB@@ ARRAY_@@ 3 | def max@@ Sub@@ Array@@ Sum ( a , size ) : NEW_LINE INDENT max_@@ so@@ _f@@ ar = - maxsize - 1 NEW_LINE max_@@ ending_@@ here = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE s = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT max_@@ ending_@@ here += a [ i ] NEW_LINE if max_@@ so@@ _f@@ ar < max_@@ ending_@@ here : NEW_LINE INDENT max_@@ so@@ _f@@ ar = max_@@ ending_@@ here NEW_LINE start = s NEW_LINE end = i NEW_LINE DEDENT if max_@@ ending_@@ here < 0 : NEW_LINE INDENT max_@@ ending_@@ here = 0 NEW_LINE s = i + 1 NEW_LINE DEDENT DEDENT print ( " Maximum ▁ contiguous ▁ sum ▁ is ▁ % d " % ( max_@@ so@@ _f@@ ar ) ) NEW_LINE print ( " Starting ▁ Index ▁ % d " % ( start ) ) NEW_LINE print ( " Ending ▁ Index ▁ % d " % ( end ) ) NEW_LINE DEDENT
FIND_@@ EQUAL_@@ POINT_@@ STRING_@@ BRAC@@ KETS | def find@@ Index ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE open = [ None ] * ( l + 1 ) NEW_LINE close = [ None ] * ( l + 1 ) NEW_LINE index = - 1 NEW_LINE open [ 0 ] = 0 NEW_LINE close [ l ] = 0 NEW_LINE if ( str [ 0 ] == ' ( ' ) : NEW_LINE INDENT open [ 1 ] = 1 NEW_LINE DEDENT if ( str [ l - 1 ] == ' ) ' ) : NEW_LINE INDENT close [ l - 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , l ) : NEW_LINE INDENT if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT open [ i + 1 ] = open [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT open [ i + 1 ] = open [ i ] NEW_LINE DEDENT DEDENT for i in range ( l - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == ' ) ' ) : NEW_LINE INDENT close [ i ] = close [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT close [ i ] = close [ i + 1 ] NEW_LINE DEDENT DEDENT if ( open [ l ] == 0 ) : NEW_LINE INDENT return len NEW_LINE DEDENT if ( close [ 0 ] == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( l + 1 ) : NEW_LINE INDENT if ( open [ i ] == close [ i ] ) : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
COUNT_@@ NUMBER_OF_@@ WAY@@ S_TO_@@ PARTITION_@@ A@@ _SET_@@ IN@@ TO_@@ K@@ _SUB@@ SE@@ TS_@@ 1 | def count@@ P ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( k + 1 ) : NEW_LINE INDENT dp [ 0 ] [ k ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( j == 1 or i == j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
LON@@ GE@@ ST_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQUENCE | def lis ( arr ) : NEW_LINE INDENT global maximum NEW_LINE n = len ( arr ) NEW_LINE maximum = 1 NEW_LINE _@@ lis ( arr , n ) NEW_LINE return maximum NEW_LINE DEDENT
FIND_@@ REPE@@ ATED_@@ CHARACTER_@@ PRES@@ ENT_@@ FIRST_@@ STRING | def find@@ Repeat@@ First@@ N2 ( s ) : NEW_LINE INDENT p = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT p = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( p != - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return p NEW_LINE DEDENT
K_@@ TH@@ _S@@ MAL@@ LE@@ ST_@@ ELEMENT_@@ REMO@@ V@@ ING_@@ INTEG@@ ERS_@@ N@@ ATUR@@ AL_@@ NUMB@@ ERS | def k@@ smallest ( arr , n , k ) : NEW_LINE INDENT b = [ 0 ] * MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ arr [ i ] ] = 1 ; NEW_LINE DEDENT for j in range ( 1 , MAX ) : NEW_LINE INDENT if ( b [ j ] != 1 ) : NEW_LINE INDENT k -= 1 ; NEW_LINE DEDENT if ( k is not 1 ) : NEW_LINE INDENT return j ; NEW_LINE DEDENT DEDENT DEDENT
CHECK_@@ IF_@@ STACK_@@ ELEMEN@@ TS_@@ ARE_@@ PAIR@@ WI@@ SE_@@ CON@@ SEC@@ UTI@@ VE | def pair@@ Wi@@ se@@ Con@@ sec@@ utive ( s ) : NEW_LINE INDENT aux = [ ] NEW_LINE while ( len ( s ) != 0 ) : NEW_LINE INDENT aux . append ( s [ - 1 ] ) NEW_LINE s . pop ( ) NEW_LINE DEDENT result = True NEW_LINE while ( len ( aux ) > 1 ) : NEW_LINE INDENT x = aux [ - 1 ] NEW_LINE aux . pop ( ) NEW_LINE y = aux [ - 1 ] NEW_LINE aux . pop ( ) NEW_LINE if ( abs ( x - y ) != 1 ) : NEW_LINE INDENT result = False NEW_LINE DEDENT s . append ( x ) NEW_LINE s . append ( y ) NEW_LINE DEDENT if ( len ( aux ) == 1 ) : NEW_LINE INDENT s . append ( aux [ - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
BIN@@ AR@@ Y@@ _SEARCH_@@ 1 | def binary@@ Search ( arr , l , r , x ) : NEW_LINE INDENT while l <= r : NEW_LINE INDENT mid = l + ( r - l ) // 2 ; NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < x : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
COUNT_@@ DISTIN@@ CT_@@ OC@@ CURR@@ EN@@ CES_@@ AS_@@ A@@ _SUB@@ SEQUENCE | def find@@ Sub@@ sequence@@ Count ( S , T ) : NEW_LINE INDENT m = len ( T ) NEW_LINE n = len ( S ) NEW_LINE if m > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT mat = [ [ 0 for _ in range ( n + 1 ) ] for __ in range ( m + 1 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT mat [ i ] [ 0 ] = 0 NEW_LINE DEDENT for j in range ( n + 1 ) : NEW_LINE INDENT mat [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if T [ i - 1 ] != S [ j - 1 ] : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return mat [ m ] [ n ] NEW_LINE DEDENT
SW@@ AP_@@ TWO_@@ NUMB@@ ERS_@@ WITH@@ OUT_@@ USING_@@ TEMPOR@@ ARY_@@ VARIABLE | def swap ( xp , yp ) : NEW_LINE INDENT xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE DEDENT
POLIC@@ E@@ MEN@@ _C@@ ATCH_@@ TH@@ I@@ EV@@ ES | def poli@@ ce@@ Th@@ ie@@ f ( arr , n , k ) : NEW_LINE INDENT i = 0 NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE res = 0 NEW_LINE th@@ i = [ ] NEW_LINE pol = [ ] NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] == ' P ' : NEW_LINE INDENT pol . append ( i ) NEW_LINE DEDENT elif arr [ i ] == ' T ' : NEW_LINE INDENT th@@ i . append ( i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while l < len ( th@@ i ) and r < len ( pol ) : NEW_LINE INDENT if ( abs ( th@@ i [ l ] - pol [ r ] ) <= k ) : NEW_LINE INDENT res += 1 NEW_LINE l += 1 NEW_LINE r += 1 NEW_LINE DEDENT elif th@@ i [ l ] < pol [ r ] : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
LAR@@ GE@@ ST@@ _SUB@@ ARRAY_@@ WITH_@@ EQUAL_@@ NUMBER_OF_@@ 0@@ S_@@ AND_@@ 1@@ S_@@ 1 | def maxLen ( arr , n ) : NEW_LINE INDENT hash_@@ map = { } ; NEW_LINE curr_@@ sum = 0 ; NEW_LINE max_len = 0 ; NEW_LINE ending_@@ index = - 1 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT arr [ i ] = - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 1 ; NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT curr_@@ sum = curr_@@ sum + arr [ i ] ; NEW_LINE if ( curr_@@ sum == 0 ) : NEW_LINE INDENT max_len = i + 1 ; NEW_LINE ending_@@ index = i ; NEW_LINE DEDENT if ( curr_@@ sum + n ) in hash_@@ map : NEW_LINE INDENT max_len = max ( max_len , i - hash_@@ map [ curr_@@ sum + n ] ) NEW_LINE DEDENT else : NEW_LINE INDENT hash_@@ map [ curr_@@ sum ] = i ; NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == - 1 ) : NEW_LINE INDENT arr [ i ] = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 1 ; NEW_LINE DEDENT DEDENT print ( ending_@@ index - max_len + 1 , end = " ▁ " ) ; NEW_LINE print ( " to " , end = " ▁ " ) ; NEW_LINE print ( ending_@@ index ) ; NEW_LINE return max_len ; NEW_LINE DEDENT
MAXIMUM_@@ DIFF@@ ER@@ ENCE_@@ ZER@@ OS_@@ ONE@@ S_@@ BINARY_@@ STRING@@ _SET_@@ 2_@@ TIME | def find@@ Length ( string , n ) : NEW_LINE INDENT current_@@ sum = 0 NEW_LINE max_@@ sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_@@ sum += ( 1 if string [ i ] == '0' else - 1 ) NEW_LINE if current_@@ sum < 0 : NEW_LINE INDENT current_@@ sum = 0 NEW_LINE DEDENT max_@@ sum = max ( current_@@ sum , max_@@ sum ) NEW_LINE DEDENT return max_@@ sum if max_@@ sum else 0 NEW_LINE DEDENT
MAXIMUM_@@ CON@@ SEC@@ UTI@@ VE_@@ NUMB@@ ERS_@@ PRES@@ ENT_@@ ARRAY | def find@@ Lon@@ gest@@ Con@@ seq@@ Sub@@ seq ( arr , n ) : NEW_LINE INDENT S = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT S . add ( arr [ i ] ) ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if S . __contains__ ( arr [ i ] ) : NEW_LINE INDENT j = arr [ i ] ; NEW_LINE while ( S . __contains__ ( j ) ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT ans = max ( ans , j - arr [ i ] ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
LE@@ XI@@ CO@@ GRAPHIC@@ AL@@ LY_@@ NEXT_@@ STRING | def next@@ Word ( s ) : NEW_LINE INDENT if ( s == " ▁ " ) : NEW_LINE INDENT return " a " NEW_LINE DEDENT i = len ( s ) - 1 NEW_LINE while ( s [ i ] == ' z ' and i >= 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT s = s + ' a ' NEW_LINE DEDENT else : NEW_LINE INDENT s = s . replace ( s [ i ] , chr ( ord ( s [ i ] ) + 1 ) , 1 ) NEW_LINE DEDENT return s NEW_LINE DEDENT
SCHEDUL@@ E_@@ J@@ OBS@@ _SERVER_@@ GE@@ TS_@@ EQUAL_@@ LOAD | def solve ( a , b , n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s += a [ i ] + b [ i ] NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return a [ 0 ] + b [ 0 ] NEW_LINE DEDENT if s % n != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = s // n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] > x : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT a [ i ] += b [ i - 1 ] NEW_LINE b [ i - 1 ] = 0 NEW_LINE DEDENT if a [ i ] == x : NEW_LINE INDENT continue NEW_LINE DEDENT y = a [ i ] + b [ i ] NEW_LINE if i + 1 < n : NEW_LINE INDENT y += b [ i + 1 ] NEW_LINE DEDENT if y == x : NEW_LINE INDENT a [ i ] = y NEW_LINE b [ i ] = 0 NEW_LINE if i + 1 < n : b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT if a [ i ] + b [ i ] == x : NEW_LINE INDENT a [ i ] += b [ i ] NEW_LINE b [ i ] = 0 NEW_LINE continue NEW_LINE DEDENT if i + 1 < n and a [ i ] + b [ i + 1 ] == x : NEW_LINE INDENT a [ i ] += b [ i + 1 ] NEW_LINE b [ i + 1 ] = 0 NEW_LINE continue NEW_LINE DEDENT return - 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if b [ i ] != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT
FORM_@@ MINIMUM_@@ NUMBER_@@ FROM_@@ GI@@ VEN@@ _SEQU@@ ENCE_@@ 1 | def getMin@@ Number@@ For@@ Pattern ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE if ( n >= 9 ) : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT result = [ None ] * ( n + 1 ) NEW_LINE count = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i == n or seq [ i ] == ' I ' ) : NEW_LINE INDENT for j in range ( i - 1 , - 2 , - 1 ) : NEW_LINE INDENT result [ j + 1 ] = int ( '0' + str ( count ) ) NEW_LINE count += 1 NEW_LINE if ( j >= 0 and seq [ j ] == ' I ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
SHUFF@@ LE_@@ 2@@ N_@@ INTEG@@ ERS_@@ FORMAT_@@ A@@ 1_@@ B@@ 1_@@ A@@ 2_@@ B@@ 2_@@ A@@ 3_@@ B@@ 3_@@ BN_@@ WITH@@ OUT_@@ USING_@@ EX@@ TRA@@ _SPACE | def shuffle@@ Array ( a , n ) : NEW_LINE INDENT i , q , k = 0 , 1 , n NEW_LINE while ( i < n ) : NEW_LINE INDENT j = k NEW_LINE while ( j > i + q ) : NEW_LINE INDENT a [ j - 1 ] , a [ j ] = a [ j ] , a [ j - 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT i += 1 NEW_LINE k += 1 NEW_LINE q += 1 NEW_LINE DEDENT DEDENT
FIND_@@ REPE@@ TI@@ TIVE_@@ ELEMENT_@@ 1_@@ N_@@ 1_1 | def find@@ Repe@@ ating ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in s : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT r@@ te@@ urn - 1 NEW_LINE DEDENT
C_@@ PROGR@@ AM@@ _SUB@@ TRAC@@ TION_@@ MA@@ TIC@@ ES | def multiply ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT
FIRST_@@ NEGATIVE_@@ INTEGER_@@ EVER@@ Y_@@ WINDOW@@ _SIZE_@@ K | def print@@ First@@ Negative@@ Integer ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , ( n - k + 1 ) ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( 0 , k ) : NEW_LINE INDENT if ( arr [ i + j ] < 0 ) : NEW_LINE INDENT print ( arr [ i + j ] , end = " ▁ " ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not ( flag ) ) : NEW_LINE INDENT print ( "0" , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
NUMBER_@@ FULL_@@ BINARY_@@ TRE@@ ES_@@ NODE_@@ PRODUCT_@@ CHILDREN | def nu@@ mo@@ ff@@ bt ( arr , n ) : NEW_LINE INDENT max@@ value = - 2147483647 NEW_LINE min@@ value = 2147483647 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max@@ value = max ( max@@ value , arr [ i ] ) NEW_LINE min@@ value = min ( min@@ value , arr [ i ] ) NEW_LINE DEDENT mark = [ 0 for i in range ( max@@ value + 2 ) ] NEW_LINE value = [ 0 for i in range ( max@@ value + 2 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT mark [ arr [ i ] ] = 1 NEW_LINE value [ arr [ i ] ] = 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( min@@ value , max@@ value + 1 ) : NEW_LINE INDENT if ( mark [ i ] != 0 ) : NEW_LINE INDENT j = i + i NEW_LINE while ( j <= max@@ value and j // i <= i ) : NEW_LINE INDENT if ( mark [ j ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT value [ j ] = value [ j ] + ( value [ i ] * value [ j // i ] ) NEW_LINE if ( i != j // i ) : NEW_LINE INDENT value [ j ] = value [ j ] + ( value [ i ] * value [ j // i ] ) NEW_LINE DEDENT j += i NEW_LINE DEDENT DEDENT ans += value [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
TRIANG@@ ULAR_@@ MATCH@@ STICK_@@ NUMBER | def numberOf@@ S@@ ticks ( x ) : NEW_LINE INDENT return ( 3 * x * ( x + 1 ) ) / 2 NEW_LINE DEDENT
K_@@ MAX@@ IM@@ UM@@ _S@@ UM_@@ COMBIN@@ ATION@@ S_@@ TWO_@@ ARRAY@@ S | def K@@ Max@@ Combin@@ ations ( A , B , N , K ) : NEW_LINE INDENT pq = PriorityQueue ( ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT a = A [ i ] + B [ j ] NEW_LINE pq . put ( ( - a , a ) ) NEW_LINE DEDENT DEDENT count = 0 NEW_LINE while ( count < K ) : NEW_LINE INDENT print ( pq . get ( ) [ 1 ] ) NEW_LINE count = count + 1 NEW_LINE DEDENT DEDENT
CONSTRUC@@ T_@@ ARRAY_@@ PAIR@@ _S@@ UM_@@ ARRAY | def construct@@ Arr ( arr , pair , n ) : NEW_LINE INDENT arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) // 2 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT arr [ i ] = pair [ i - 1 ] - arr [ 0 ] NEW_LINE DEDENT DEDENT
CHECK_@@ HALF_@@ STRING_@@ CHARACTER_@@ FREQU@@ ENCY_@@ CHARACTER | def check@@ Correct@@ Or@@ Not ( s ) : NEW_LINE INDENT global MAX_@@ CHAR NEW_LINE count@@ 1 = [ 0 ] * MAX_@@ CHAR NEW_LINE count2 = [ 0 ] * MAX_@@ CHAR NEW_LINE n = len ( s ) NEW_LINE if n == 1 : NEW_LINE INDENT return true NEW_LINE DEDENT i = 0 ; j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT count@@ 1 [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE count2 [ ord ( s [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 ; j -= 1 NEW_LINE DEDENT for i in range ( MAX_@@ CHAR ) : NEW_LINE INDENT if count@@ 1 [ i ] != count2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
MINI@@ MI@@ ZE_@@ THE_@@ MAXIMUM_@@ DIFF@@ ER@@ ENCE_@@ BETWE@@ EN_@@ THE_@@ HE@@ IGHT@@ S | def getMin@@ Diff ( arr , n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] - arr [ 0 ] NEW_LINE small = arr [ 0 ] + k NEW_LINE big = arr [ n - 1 ] - k NEW_LINE if ( small > big ) : NEW_LINE INDENT small , big = big , small NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT subtract = arr [ i ] - k NEW_LINE add = arr [ i ] + k NEW_LINE if ( subtract >= small or add <= big ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( big - subtract <= add - small ) : NEW_LINE INDENT small = subtract NEW_LINE DEDENT else : NEW_LINE INDENT big = add NEW_LINE DEDENT DEDENT return min ( ans , big - small ) NEW_LINE DEDENT
MINIMUM_@@ POSSI@@ BLE_@@ VALUE_@@ AI_@@ A@@ J_@@ K_@@ GI@@ V@@ EN_@@ ARRAY_@@ K | def pairs ( arr , n , k ) : NEW_LINE INDENT smallest = 99999999@@ 9999 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if abs ( arr [ i ] + arr [ j ] - k ) < smallest : NEW_LINE INDENT smallest = abs ( arr [ i ] + arr [ j ] - k ) NEW_LINE count = 1 NEW_LINE DEDENT elif abs ( arr [ i ] + arr [ j ] - k ) == smallest : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( " Min@@ imal ▁ Value ▁ = ▁ " , smallest ) NEW_LINE print ( " Total ▁ Pairs ▁ = ▁ " , count ) NEW_LINE DEDENT
SIZE_@@ SUB@@ ARRAY_@@ MAX@@ IM@@ UM@@ _S@@ UM | def max@@ Sub@@ Array@@ Sum ( a , size ) : NEW_LINE INDENT max_@@ so@@ _f@@ ar = - maxsize - 1 NEW_LINE max_@@ ending_@@ here = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE s = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT max_@@ ending_@@ here += a [ i ] NEW_LINE if max_@@ so@@ _f@@ ar < max_@@ ending_@@ here : NEW_LINE INDENT max_@@ so@@ _f@@ ar = max_@@ ending_@@ here NEW_LINE start = s NEW_LINE end = i NEW_LINE DEDENT if max_@@ ending_@@ here < 0 : NEW_LINE INDENT max_@@ ending_@@ here = 0 NEW_LINE s = i + 1 NEW_LINE DEDENT DEDENT return ( end - start + 1 ) NEW_LINE DEDENT
MINIMUM_@@ NUMBER_@@ OF@@ _S@@ QUAR@@ ES_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL@@ S_TO_@@ GI@@ V@@ EN_@@ NUMBER_@@ N_@@ 1 | def getMin@@ Squ@@ ares ( n ) : NEW_LINE INDENT dp = [ 0 , 1 , 2 , 3 ] NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT dp . append ( i ) NEW_LINE for x in range ( 1 , int ( ceil ( sqrt ( i ) ) ) + 1 ) : NEW_LINE INDENT temp = x * x ; NEW_LINE if temp > i : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
DI@@ VISIBILITY_@@ BY_@@ 7 | def is@@ Di@@ visible@@ By@@ 7 ( num ) : NEW_LINE INDENT if num < 0 : NEW_LINE INDENT return is@@ Di@@ visible@@ By@@ 7 ( - num ) NEW_LINE DEDENT if ( num == 0 or num == 7 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( num < 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return is@@ Di@@ visible@@ By@@ 7 ( num / 10 - 2 * ( num - num / 10 * 10 ) ) NEW_LINE DEDENT
POSITION_@@ OF_@@ RIGHT@@ MO@@ ST@@ _SET_@@ BIT_@@ 2 | def R@@ ight_@@ most_@@ set@@ bit ( num ) : NEW_LINE INDENT pos = 1 NEW_LINE for i in range ( INT_@@ SIZE ) : NEW_LINE INDENT if not ( num & ( 1 << i ) ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT
EF@@ FI@@ CI@@ ENT_@@ WA@@ Y_@@ TO_@@ MULTI@@ PLY_@@ WITH_@@ 7 | def multiply@@ By@@ Se@@ ven ( n ) : NEW_LINE INDENT return ( ( n << 3 ) - n ) NEW_LINE DEDENT
NEXT_@@ HIGH@@ ER_@@ NUMBER_@@ WITH@@ _S@@ AME_@@ NUMBER_@@ OF@@ _SET_@@ BITS | def sno@@ ob ( x ) : NEW_LINE INDENT next = 0 NEW_LINE if ( x ) : NEW_LINE INDENT right@@ One = x & - ( x ) NEW_LINE next@@ High@@ er@@ One@@ Bit = x + int ( right@@ One ) NEW_LINE right@@ One@@ s@@ Pattern = x ^ int ( next@@ High@@ er@@ One@@ Bit ) NEW_LINE right@@ One@@ s@@ Pattern = ( int ( right@@ One@@ s@@ Pattern ) / int ( right@@ One ) ) NEW_LINE right@@ One@@ s@@ Pattern = int ( right@@ One@@ s@@ Pattern ) >> 2 NEW_LINE next = next@@ High@@ er@@ One@@ Bit | right@@ One@@ s@@ Pattern NEW_LINE DEDENT return next NEW_LINE DEDENT
CHANGE_@@ ARRAY_@@ PER@@ MU@@ TATION_@@ NUMB@@ ERS_@@ 1_@@ N | def make@@ Permutation ( a , n ) : NEW_LINE INDENT count = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if count . get ( a [ i ] ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ a [ i ] ] = 1 ; NEW_LINE DEDENT DEDENT next_@@ missing = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if count [ a [ i ] ] != 1 or a [ i ] > n or a [ i ] < 1 : NEW_LINE INDENT count [ a [ i ] ] -= 1 NEW_LINE while count . get ( next_@@ missing ) : NEW_LINE INDENT next_@@ missing += 1 NEW_LINE DEDENT a [ i ] = next_@@ missing NEW_LINE count [ next_@@ missing ] = 1 NEW_LINE DEDENT DEDENT DEDENT
MAXIMUM_@@ AREA_@@ QUAD@@ RI@@ LAT@@ ER@@ AL | def max@@ Area ( a , b , c , d ) : NEW_LINE INDENT semi@@ per@@ imeter = ( a + b + c + d ) / 2 NEW_LINE return math . sqrt ( ( semi@@ per@@ imeter - a ) * ( semi@@ per@@ imeter - b ) * ( semi@@ per@@ imeter - c ) * ( semi@@ per@@ imeter - d ) ) NEW_LINE DEDENT
REPL@@ ACE_@@ OC@@ CURR@@ EN@@ CES_@@ STRING_@@ AB_@@ C_@@ WITH@@ OUT_@@ USING_@@ EX@@ TRA@@ _SPACE_@@ 1 | def translate ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE if ( l < 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( j < l - 1 ) : NEW_LINE INDENT if ( st [ j ] == ' A ' and st [ j + 1 ] == ' B ' ) : NEW_LINE INDENT j += 2 NEW_LINE st [ i ] = ' C ' NEW_LINE i += 1 NEW_LINE continue NEW_LINE DEDENT st [ i ] = st [ j ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT if ( j == l - 1 ) : NEW_LINE INDENT st [ i ] = st [ j ] NEW_LINE i += 1 NEW_LINE DEDENT st [ i ] = ' ▁ ' NEW_LINE st [ l - 1 ] = ' ▁ ' NEW_LINE DEDENT
FIND_@@ POWER_@@ POWER_@@ MOD_@@ PRI@@ ME | def calculate ( A , B , C , M ) : NEW_LINE INDENT res = pow ( B , C , M - 1 ) NEW_LINE ans = pow ( A , res , M ) NEW_LINE return ans NEW_LINE DEDENT
CHECK_@@ EXI@@ ST_@@ TWO_@@ ELEMEN@@ TS_@@ ARRAY_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL@@ _S@@ UM_@@ REST_@@ ARRAY | def check@@ Pair ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if sum % 2 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT sum = sum / 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = sum - arr [ i ] NEW_LINE if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT if val in s : NEW_LINE INDENT print ( " Pair ▁ elements ▁ are " , arr [ i ] , " and " , int ( val ) ) NEW_LINE DEDENT DEDENT DEDENT
PROGRAM_@@ FOR@@ _SUR@@ FACE_@@ AREA_@@ OF_@@ OC@@ TA@@ HE@@ DRO@@ N | def surface_@@ area_@@ oc@@ ta@@ hedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT
FIND_@@ A@@ _SPECI@@ FIC_@@ PA@@ IR_@@ IN_@@ MATRIX | def find@@ Max@@ Value ( mat ) : NEW_LINE INDENT maxValue = 0 NEW_LINE for a in range ( N - 1 ) : NEW_LINE INDENT for b in range ( N - 1 ) : NEW_LINE INDENT for d in range ( a + 1 , N ) : NEW_LINE INDENT for e in range ( b + 1 , N ) : NEW_LINE INDENT if maxValue < int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) : NEW_LINE INDENT maxValue = int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return maxValue ; NEW_LINE DEDENT
MULTI@@ PLY_@@ TWO_@@ NUMB@@ ERS_@@ WITH@@ OUT_@@ USING_@@ MULTI@@ PLY_@@ DI@@ VISI@@ ON_@@ BIT@@ WI@@ SE_@@ OPER@@ ATOR@@ S_@@ AND_@@ NO_@@ LOOP@@ S | def multiply ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( y > 0 ) : NEW_LINE INDENT return ( x + multiply ( x , y - 1 ) ) NEW_LINE DEDENT if ( y < 0 ) : NEW_LINE INDENT return - multiply ( x , - y ) NEW_LINE DEDENT DEDENT
FIND_@@ TR@@ IP@@ LET@@ S_@@ ARRAY_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL_@@ ZERO_@@ 1 | def find@@ Trip@@ lets ( arr , n ) : NEW_LINE INDENT found = False NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT x = - ( arr [ i ] + arr [ j ] ) NEW_LINE if x in s : NEW_LINE INDENT print ( x , arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if found == False : NEW_LINE INDENT print ( " No ▁ Trip@@ let ▁ Found " ) NEW_LINE DEDENT DEDENT
FIND_@@ MAXIMUM_@@ VALUE_@@ OF@@ _S@@ UM_@@ I@@ AR@@ RI@@ _@@ WITH_@@ ONLY_@@ ROTA@@ TIONS_@@ ON_@@ GI@@ V@@ EN_@@ ARRAY_@@ ALLOWED | def max@@ Sum ( arr ) : NEW_LINE INDENT arr@@ Sum = 0 NEW_LINE curr@@ Val = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT arr@@ Sum = arr@@ Sum + arr [ i ] NEW_LINE curr@@ Val = curr@@ Val + ( i * arr [ i ] ) NEW_LINE DEDENT maxVal = curr@@ Val NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT curr@@ Val = curr@@ Val + arr@@ Sum - n * arr [ n - j ] NEW_LINE if curr@@ Val > maxVal : NEW_LINE INDENT maxVal = curr@@ Val NEW_LINE DEDENT DEDENT return maxVal NEW_LINE DEDENT
PROGRAM_@@ FOR@@ _SCAL@@ AR_@@ MULTIP@@ LIC@@ ATION_@@ OF_@@ A_@@ MATRIX | def scalar@@ Product@@ Mat ( mat , k ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j ] * k NEW_LINE DEDENT DEDENT DEDENT
PRINT_@@ SQU@@ AR@@ ES_@@ FIRST_@@ N_@@ N@@ ATUR@@ AL_@@ NUMB@@ ERS_@@ WITH@@ OUT_@@ USING_@@ 1 | def print@@ Squ@@ ares ( n ) : NEW_LINE INDENT square = 0 NEW_LINE odd = 1 NEW_LINE for x in range ( 0 , n ) : NEW_LINE INDENT print ( square , end = " ▁ " ) NEW_LINE square = square + odd NEW_LINE odd = odd + 2 NEW_LINE DEDENT DEDENT
N@@ TH_@@ PEN@@ TAG@@ ON@@ AL_@@ NUMBER | def pent@@ ag@@ onal@@ Num ( n ) : NEW_LINE INDENT return ( 3 * n * n - n ) / 2 NEW_LINE DEDENT
COUNT_@@ ARRAY@@ S_@@ AD@@ J@@ AC@@ ENT_@@ ELEMEN@@ TS_@@ ONE_@@ DI@@ VI@@ DE_@@ AN@@ OTHER | def nu@@ mo@@ f@@ Array ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE di = [ [ ] for i in range ( MAX ) ] NEW_LINE mu = [ [ ] for i in range ( MAX ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 2 * i , m + 1 , i ) : NEW_LINE INDENT di [ j ] . append ( i ) NEW_LINE mu [ i ] . append ( j ) NEW_LINE DEDENT di [ i ] . append ( i ) NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE for x in di [ j ] : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ] NEW_LINE DEDENT for x in mu [ j ] : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ i ] NEW_LINE di [ i ] . clear ( ) NEW_LINE mu [ i ] . clear ( ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
0_@@ 1_@@ KN@@ AP@@ S@@ ACK_@@ PRO@@ BLE@@ M_@@ D@@ P_@@ 10 | def kn@@ ap@@ S@@ ack ( W , wt , val , n ) : NEW_LINE INDENT if n == 0 or W == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt [ n - 1 ] > W ) : NEW_LINE INDENT return kn@@ ap@@ S@@ ack ( W , wt , val , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( val [ n - 1 ] + kn@@ ap@@ S@@ ack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , kn@@ ap@@ S@@ ack ( W , wt , val , n - 1 ) ) NEW_LINE DEDENT DEDENT
FIND_@@ TR@@ IP@@ LET@@ S_@@ ARRAY_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL_@@ ZERO | def find@@ Trip@@ lets ( arr , n ) : NEW_LINE INDENT found = True NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] , arr [ k ] ) NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " ▁ not ▁ exist ▁ " ) NEW_LINE DEDENT DEDENT
COUNT_@@ NUMBER_@@ WAY@@ S_@@ REACH_@@ GI@@ VEN@@ _S@@ CORE_@@ GAME | def count ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 3 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 10 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT
MAX@@ IM@@ UM@@ _S@@ UM_@@ ABSOL@@ UTE_@@ DIFF@@ ER@@ ENCE_@@ ARRAY | def Max@@ Sum@@ Difference ( a , n ) : NEW_LINE INDENT np . sort ( a ) ; NEW_LINE j = 0 NEW_LINE final@@ Sequence = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT final@@ Sequence [ j ] = a [ i ] NEW_LINE final@@ Sequence [ j + 1 ] = a [ n - i - 1 ] NEW_LINE j = j + 2 NEW_LINE DEDENT Maximum@@ Sum = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT Maximum@@ Sum = ( Maximum@@ Sum + abs ( final@@ Sequence [ i ] - final@@ Sequence [ i + 1 ] ) ) NEW_LINE DEDENT Maximum@@ Sum = ( Maximum@@ Sum + abs ( final@@ Sequence [ n - 1 ] - final@@ Sequence [ 0 ] ) ) ; NEW_LINE print ( Maximum@@ Sum ) NEW_LINE DEDENT
PROGRAM_@@ FIND_@@ M@@ ID_@@ POINT_@@ LINE | def midpoint ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( ( x1 + x2 ) // 2 , " ▁ , ▁ " , ( y1 + y2 ) // 2 ) NEW_LINE DEDENT
ALTER@@ NATIVE_@@ SOR@@ TING | def alternate@@ Sort ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT print ( arr [ j ] , end = " ▁ " ) NEW_LINE j -= 1 NEW_LINE print ( arr [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT if ( n % 2 != 0 ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT
NUMBER@@ _SUB@@ ARRAY@@ S_S@@ UM_@@ EXAC@@ TL@@ Y_@@ EQUAL_@@ K | def find@@ Sub@@ array@@ Sum ( arr , n , Sum ) : NEW_LINE INDENT prev@@ Sum = defaultdict ( lambda : 0 ) NEW_LINE res = 0 NEW_LINE curr@@ sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr@@ sum += arr [ i ] NEW_LINE if curr@@ sum == Sum : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( curr@@ sum - Sum ) in prev@@ Sum : NEW_LINE INDENT res += prev@@ Sum [ curr@@ sum - Sum ] NEW_LINE DEDENT prev@@ Sum [ curr@@ sum ] += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
FIND_@@ THE_@@ ELEMENT_@@ TH@@ AT_@@ AP@@ PE@@ AR@@ S_@@ ON@@ CE_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY | def search ( arr , low , high ) : NEW_LINE INDENT if low > high : NEW_LINE INDENT return None NEW_LINE DEDENT if low == high : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT mid = low + ( high - low ) / 2 NEW_LINE if mid % 2 == 0 : NEW_LINE INDENT if arr [ mid ] == arr [ mid + 1 ] : NEW_LINE INDENT return search ( arr , mid + 2 , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return search ( arr , low , mid ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if arr [ mid ] == arr [ mid - 1 ] : NEW_LINE INDENT return search ( arr , mid + 1 , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return search ( arr , low , mid - 1 ) NEW_LINE DEDENT DEDENT DEDENT
FORM_S@@ MAL@@ LE@@ ST_@@ NUMBER_@@ USING_@@ ONE@@ _SW@@ AP_@@ OPERATION | def smalle@@ st@@ Number ( num ) : NEW_LINE INDENT num = list ( num ) NEW_LINE n = len ( num ) NEW_LINE right@@ Min = [ 0 ] * n NEW_LINE right = 0 NEW_LINE right@@ Min [ n - 1 ] = - 1 ; NEW_LINE right = n - 1 ; NEW_LINE for i in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT if num [ i ] > num [ right ] : NEW_LINE INDENT right@@ Min [ i ] = right NEW_LINE DEDENT else : NEW_LINE INDENT right@@ Min [ i ] = - 1 NEW_LINE right = i NEW_LINE DEDENT DEDENT small = - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if num [ i ] != '0' : NEW_LINE INDENT if small == - 1 : NEW_LINE INDENT if num [ i ] < num [ 0 ] : NEW_LINE INDENT small = i NEW_LINE DEDENT DEDENT elif num [ i ] < num [ small ] : NEW_LINE INDENT small = i NEW_LINE DEDENT DEDENT DEDENT if small != - 1 : NEW_LINE INDENT num [ 0 ] , num [ small ] = num [ small ] , num [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if right@@ Min [ i ] != - 1 : NEW_LINE INDENT num [ i ] , num [ right@@ Min [ i ] ] = num [ right@@ Min [ i ] ] , num [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return ' ' . join ( num ) NEW_LINE DEDENT
PROGRAM_@@ ARE@@ A@@ _S@@ QU@@ ARE | def area@@ Square ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT
FIND_@@ DAY_OF_@@ THE_@@ WEEK_@@ FOR_@@ A_@@ GI@@ V@@ EN_@@ DATE | def day@@ of@@ week ( d , m , y ) : NEW_LINE INDENT t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] NEW_LINE y -= m < 3 NEW_LINE return ( ( y + int ( y / 4 ) - int ( y / 100 ) + int ( y / 400 ) + t [ m - 1 ] + d ) % 7 ) NEW_LINE DEDENT
CHECK_@@ QUEUE_@@ CAN@@ _S@@ OR@@ TED_@@ AN@@ OTHER_@@ QUEUE_@@ USING_@@ STACK | def check@@ Sorted ( n , q ) : NEW_LINE INDENT st = [ ] NEW_LINE expected = 1 NEW_LINE f@@ nt = None NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT f@@ nt = q . queue [ 0 ] NEW_LINE q . get ( ) NEW_LINE if ( f@@ nt == expected ) : NEW_LINE INDENT expected += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT st . append ( f@@ nt ) NEW_LINE DEDENT elif ( len ( st ) != 0 and st [ - 1 ] < f@@ nt ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( f@@ nt ) NEW_LINE DEDENT DEDENT while ( len ( st ) != 0 and st [ - 1 ] == expected ) : NEW_LINE INDENT st . pop ( ) NEW_LINE expected += 1 NEW_LINE DEDENT DEDENT if ( expected - 1 == n and len ( st ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
SORT_@@ ARRAY_@@ CONTA@@ IN_@@ 1_@@ N_@@ VALUES | def sor@@ tit ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = i + 1 NEW_LINE DEDENT DEDENT
LC@@ S_@@ LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ SEQU@@ ENCE_@@ THRE@@ E_@@ STRING@@ S_@@ 1 | def l@@ cs@@ Of@@ 3 ( i , j , k ) : NEW_LINE INDENT if ( i == - 1 or j == - 1 or k == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 1 + l@@ cs@@ Of@@ 3 ( i - 1 , j - 1 , k - 1 ) NEW_LINE return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = max ( max ( l@@ cs@@ Of@@ 3 ( i - 1 , j , k ) , l@@ cs@@ Of@@ 3 ( i , j - 1 , k ) ) , l@@ cs@@ Of@@ 3 ( i , j , k - 1 ) ) NEW_LINE return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT DEDENT
LOWER_@@ INSER@@ TION_@@ POINT | def Lower@@ Insertion@@ Point ( arr , n , X ) : NEW_LINE INDENT if ( X < arr [ 0 ] ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( X > arr [ n - 1 ] ) : NEW_LINE INDENT return n NEW_LINE DEDENT lower@@ Pnt = 0 NEW_LINE i = 1 NEW_LINE while ( i < n and arr [ i ] < X ) : NEW_LINE INDENT lower@@ Pnt = i NEW_LINE i = i * 2 NEW_LINE DEDENT while ( lower@@ Pnt < n and arr [ lower@@ Pnt ] < X ) : NEW_LINE INDENT lower@@ Pnt += 1 NEW_LINE DEDENT return lower@@ Pnt NEW_LINE DEDENT
CONSTRUC@@ T_@@ LE@@ XI@@ CO@@ GRAPHIC@@ AL@@ LY@@ _S@@ MAL@@ LE@@ ST_@@ PA@@ LIN@@ DRO@@ ME | def construct@@ Pal@@ in ( string , l ) : NEW_LINE INDENT string = list ( string ) NEW_LINE i = - 1 NEW_LINE j = l NEW_LINE while i < j : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE if ( string [ i ] == string [ j ] and string [ i ] != ' * ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( string [ i ] == string [ j ] and string [ i ] == ' * ' ) : NEW_LINE INDENT string [ i ] = ' a ' NEW_LINE string [ j ] = ' a ' NEW_LINE continue NEW_LINE DEDENT elif string [ i ] == ' * ' : NEW_LINE INDENT string [ i ] = string [ j ] NEW_LINE continue NEW_LINE DEDENT elif string [ j ] == ' * ' : NEW_LINE INDENT string [ j ] = string [ i ] NEW_LINE continue NEW_LINE DEDENT print ( " Not ▁ Possible " ) NEW_LINE return " " NEW_LINE DEDENT return ' ' . join ( string ) NEW_LINE DEDENT
SECTION_@@ FOR@@ MUL@@ A_@@ POINT_@@ DI@@ VIDE@@ S_@@ LINE_@@ GI@@ V@@ EN_@@ RATIO | def section ( x1 , x2 , y1 , y2 , m , n ) : NEW_LINE INDENT x = ( float ) ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ) NEW_LINE y = ( float ) ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) NEW_LINE print ( x , y ) NEW_LINE DEDENT
SQU@@ ARE_@@ ROOT_@@ NUMBER_@@ USING_@@ LOG | def square@@ Root ( n ) : NEW_LINE INDENT return pow ( 2 , 0.5 * math . log2 ( n ) ) NEW_LINE DEDENT
MAXI@@ MI@@ ZE_@@ S@@ UM_@@ AR@@ RI@@ I | def max@@ Sum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
STRING_@@ K_@@ DISTIN@@ CT_@@ CHARAC@@ TER@@ S_@@ NO_@@ CHARAC@@ TER@@ S_@@ AD@@ J@@ AC@@ ENT | def find@@ String ( n , k ) : NEW_LINE INDENT res = " " NEW_LINE for i in range ( k ) : NEW_LINE INDENT res = res + chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n - k ) : NEW_LINE INDENT res = res + chr ( ord ( ' a ' ) + count ) NEW_LINE count += 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT count = 0 ; NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
COUNT_@@ WOR@@ DS_@@ WHO@@ SE_@@ TH_@@ LET@@ TER_@@ EI@@ THER_@@ 1_@@ TH_@@ TH_@@ I@@ 1_@@ TH_@@ LET@@ TER_@@ GI@@ V@@ EN_@@ WORD | def count@@ Words ( str , l ) : NEW_LINE INDENT count = 1 ; NEW_LINE if ( l == 1 ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( str [ 0 ] == str [ 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT for j in range ( 1 , l - 1 ) : NEW_LINE INDENT if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT DEDENT if ( str [ l - 1 ] == str [ l - 2 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT
NUMBER_@@ JUM@@ P_@@ REQUIRED_@@ GI@@ V@@ EN_@@ LENGTH_@@ REACH_@@ POINT_@@ FORM_@@ D_@@ 0_@@ ORIG@@ IN_@@ 2D_@@ PLAN@@ E | def min@@ Jump@@ s ( a , b , d ) : NEW_LINE INDENT temp = a NEW_LINE a = min ( a , b ) NEW_LINE b = max ( temp , b ) NEW_LINE if ( d >= b ) : NEW_LINE INDENT return ( d + b - 1 ) / b NEW_LINE DEDENT if ( d == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( d == a ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT
S@@ UM_@@ FAC@@ TOR@@ S_@@ NUMBER_@@ 1 | def su@@ mo@@ f@@ Factors ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , int ( m . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT curr_@@ sum = 1 NEW_LINE curr_@@ term = 1 NEW_LINE while n % i == 0 : NEW_LINE INDENT n = n / i ; NEW_LINE curr_@@ term = curr_@@ term * i ; NEW_LINE curr_@@ sum += curr_@@ term ; NEW_LINE DEDENT res = res * curr_@@ sum NEW_LINE DEDENT if n > 2 : NEW_LINE INDENT res = res * ( 1 + n ) NEW_LINE DEDENT return res ; NEW_LINE DEDENT
DELETE_@@ CON@@ SEC@@ UTI@@ VE_@@ WOR@@ DS@@ _SEQU@@ ENCE | def remove@@ Con@@ sec@@ uti@@ ve@@ Same ( v ) : NEW_LINE INDENT n = len ( v ) NEW_LINE i = 0 NEW_LINE while ( i < n - 1 ) : NEW_LINE INDENT if ( ( i + 1 ) < len ( v ) ) and ( v [ i ] == v [ i + 1 ] ) : NEW_LINE INDENT v = v [ : i ] NEW_LINE v = v [ : i ] NEW_LINE if ( i > 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT n = n - 2 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return len ( v [ : i - 1 ] ) NEW_LINE DEDENT
COUNT_@@ NUMBER_@@ BINARY_@@ STRING@@ S_@@ WITH@@ OUT_@@ CON@@ SEC@@ UTI@@ VE_@@ 1@@ S | def count@@ Strings ( n ) : NEW_LINE INDENT a = [ 0 for i in range ( n ) ] NEW_LINE b = [ 0 for i in range ( n ) ] NEW_LINE a [ 0 ] = b [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ] NEW_LINE b [ i ] = a [ i - 1 ] NEW_LINE DEDENT return a [ n - 1 ] + b [ n - 1 ] NEW_LINE DEDENT
FIND_@@ THE_@@ MISSING_@@ NUMBER | def get@@ Missing@@ No ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE total = ( n + 1 ) * ( n + 2 ) / 2 NEW_LINE sum_@@ of_@@ A = sum ( A ) NEW_LINE return total - sum_@@ of_@@ A NEW_LINE DEDENT
SQU@@ ARE_@@ ROOT_@@ OF_@@ A_@@ PER@@ F@@ ECT_@@ SQUARE | def square@@ Root ( n ) : NEW_LINE INDENT x = n NEW_LINE y = 1 NEW_LINE e = 0.000001 NEW_LINE while ( x - y > e ) : NEW_LINE INDENT x = ( x + y ) / 2 NEW_LINE y = n / x NEW_LINE DEDENT return x NEW_LINE DEDENT
SUB@@ SET_@@ S@@ UM_@@ PRO@@ BLE@@ M_@@ OS@@ UM@@ _SPACE | def isSub@@ set@@ Sum ( arr , n , sum ) : NEW_LINE INDENT subset = [ [ False for j in range ( sum + 1 ) ] for i in range ( 3 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( sum + 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = True NEW_LINE DEDENT elif ( i == 0 ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = False NEW_LINE DEDENT elif ( arr [ i - 1 ] <= j ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] or subset [ ( i + 1 ) % 2 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return subset [ n % 2 ] [ sum ] NEW_LINE DEDENT
MULTIP@@ LIC@@ ATI@@ VE_@@ INVER@@ SE_@@ UN@@ DER_@@ MODUL@@ O_@@ M | def mod@@ Inverse ( a , m ) : NEW_LINE INDENT a = a % m ; NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( a * x ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
COMP@@ UTE_@@ AVER@@ AGE_@@ TWO_@@ NUMB@@ ERS_@@ WITH@@ OUT_@@ OVERFLOW | def compute_@@ average ( a , b ) : NEW_LINE INDENT return floor ( ( a + b ) / 2 ) NEW_LINE DEDENT
RE@@ PRES@@ ENT_@@ GI@@ VEN@@ _SET_@@ POINT@@ S_@@ BE@@ ST_@@ POSSI@@ BLE_@@ STR@@ AI@@ GHT_@@ LINE | def best@@ Approxim@@ ate ( x , y , n ) : NEW_LINE INDENT sum@@ _x = 0 NEW_LINE sum_@@ y = 0 NEW_LINE sum_@@ xy = 0 NEW_LINE sum_@@ x2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum@@ _x += x [ i ] NEW_LINE sum_@@ y += y [ i ] NEW_LINE sum_@@ xy += x [ i ] * y [ i ] NEW_LINE sum_@@ x2 += pow ( x [ i ] , 2 ) NEW_LINE DEDENT m = ( float ) ( ( n * sum_@@ xy - sum@@ _x * sum_@@ y ) / ( n * sum_@@ x2 - pow ( sum@@ _x , 2 ) ) ) ; NEW_LINE c = ( float ) ( sum_@@ y - m * sum@@ _x ) / n ; NEW_LINE print ( " m ▁ = ▁ " , m ) ; NEW_LINE print ( " c ▁ = ▁ " , c ) ; NEW_LINE DEDENT
SP@@ LIT_@@ ARRAY_@@ ADD_@@ FIRST_@@ PART_@@ END | def split@@ Arr ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , k ) : NEW_LINE INDENT x = arr [ 0 ] NEW_LINE for j in range ( 0 , n - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = x NEW_LINE DEDENT DEDENT
MAXIMUM_@@ POSSI@@ BLE_@@ DIFF@@ ER@@ ENCE_@@ TW@@ O@@ _SUB@@ SE@@ TS_@@ ARRAY | def max@@ Diff ( arr , n ) : NEW_LINE INDENT Subset@@ Sum@@ _1 = 0 NEW_LINE Subset@@ Sum@@ _2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT is@@ Single@@ Occur@@ ance = True NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT is@@ Single@@ Occur@@ ance = False NEW_LINE arr [ i ] = arr [ j ] = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( is@@ Single@@ Occur@@ ance == True ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT Subset@@ Sum@@ _1 += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT Subset@@ Sum@@ _2 += arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return abs ( Subset@@ Sum@@ _1 - Subset@@ Sum@@ _2 ) NEW_LINE DEDENT
LON@@ GE@@ ST@@ _SUB@@ SEQU@@ ENCE_@@ DIFF@@ ER@@ ENCE_@@ AD@@ J@@ AC@@ ENTS_@@ ONE@@ _SET_@@ 2 | def long@@ Len@@ Sub ( arr , n ) : NEW_LINE INDENT um = defaultdict ( lambda : 0 ) NEW_LINE long@@ Len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len1 = 0 NEW_LINE if ( arr [ i - 1 ] in um and len1 < um [ arr [ i ] - 1 ] ) : NEW_LINE INDENT len1 = um [ arr [ i ] - 1 ] NEW_LINE DEDENT if ( arr [ i ] + 1 in um and len1 < um [ arr [ i ] + 1 ] ) : NEW_LINE INDENT len1 = um [ arr [ i ] + 1 ] NEW_LINE DEDENT um [ arr [ i ] ] = len1 + 1 NEW_LINE if long@@ Len < um [ arr [ i ] ] : NEW_LINE INDENT long@@ Len = um [ arr [ i ] ] NEW_LINE DEDENT DEDENT return long@@ Len NEW_LINE DEDENT
LON@@ GE@@ ST_@@ REPE@@ ATE@@ D@@ _SUB@@ SEQU@@ ENCE_@@ 1 | def lon@@ gest@@ Repeated@@ Sub@@ Seq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT res = ' ' NEW_LINE i = n NEW_LINE j = n NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) : NEW_LINE INDENT res += str [ i - 1 ] NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT res = ' ' . join ( reversed ( res ) ) NEW_LINE return res NEW_LINE DEDENT
FIND_@@ INDEX_@@ MAXIMUM_@@ OC@@ CURR@@ ING_@@ ELEMENT_@@ EQUAL_@@ PRO@@ B@@ ABILITY | def find@@ Random@@ Index@@ Of@@ Max ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in mp ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT max_@@ element = - 32@@ 35@@ 67 NEW_LINE max_@@ so@@ _f@@ ar = - 32@@ 35@@ 67 NEW_LINE for p in mp : NEW_LINE INDENT if ( mp [ p ] > max_@@ so@@ _f@@ ar ) : NEW_LINE INDENT max_@@ so@@ _f@@ ar = mp [ p ] NEW_LINE max_@@ element = p NEW_LINE DEDENT DEDENT r = int ( ( ( random . randrange ( 1 , max_@@ so@@ _f@@ ar , 2 ) % max_@@ so@@ _f@@ ar ) + 1 ) ) NEW_LINE i = 0 NEW_LINE count = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == max_@@ element ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( count == r ) : NEW_LINE INDENT print ( " Element ▁ with ▁ maximum ▁ frequency ▁ present ▁ at ▁ index ▁ " , i ) NEW_LINE break NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT
CHECK_@@ NUMBER_@@ IS_@@ PER@@ F@@ ECT_@@ SQU@@ ARE_@@ USING_@@ ADDI@@ TION@@ SUB@@ TRAC@@ TION | def is@@ Per@@ fec@@ t@@ Square ( n ) : NEW_LINE INDENT i = 1 NEW_LINE the_@@ sum = 0 NEW_LINE while the_@@ sum < n : NEW_LINE INDENT the_@@ sum += i NEW_LINE if the_@@ sum == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return False NEW_LINE DEDENT
N_@@ BON@@ ACC@@ I_@@ NUMB@@ ERS_@@ 1 | def bon@@ ac@@ ci@@ series ( n , m ) : NEW_LINE INDENT a = [ 0 for i in range ( m ) ] NEW_LINE a [ n - 1 ] = 1 NEW_LINE a [ n ] = 1 NEW_LINE for i in range ( n + 1 , m ) : NEW_LINE INDENT a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
COUNT_@@ INDEX_@@ PAIR@@ S_@@ EQUAL_@@ ELEMEN@@ TS_@@ ARRAY_@@ 1 | def count@@ Pairs ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for it in mp : NEW_LINE INDENT count = mp [ it ] NEW_LINE ans += ( count * ( count - 1 ) ) // 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
SORT_@@ EV@@ EN_@@ PL@@ AC@@ ED_@@ ELEMEN@@ TS_@@ INCRE@@ AS@@ ING_@@ OD@@ D_@@ PL@@ AC@@ ED_@@ DECRE@@ AS@@ ING_@@ ORDER | def bit@@ on@@ ic@@ Generator ( arr , n ) : NEW_LINE INDENT even@@ Arr = [ ] NEW_LINE odd@@ Arr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( i % 2 ) == 0 ) : NEW_LINE INDENT even@@ Arr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT odd@@ Arr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT even@@ Arr = sorted ( even@@ Arr ) NEW_LINE odd@@ Arr = sorted ( odd@@ Arr ) NEW_LINE odd@@ Arr = odd@@ Arr [ : : - 1 ] NEW_LINE i = 0 NEW_LINE for j in range ( len ( even@@ Arr ) ) : NEW_LINE INDENT arr [ i ] = even@@ Arr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( len ( odd@@ Arr ) ) : NEW_LINE INDENT arr [ i ] = odd@@ Arr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 9_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENT | def bin@@ omi@@ al@@ Coeff ( n , k ) : NEW_LINE INDENT if k == 0 or k == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT return bin@@ omi@@ al@@ Coeff ( n - 1 , k - 1 ) + bin@@ omi@@ al@@ Coeff ( n - 1 , k ) NEW_LINE DEDENT
WRITE_@@ A_@@ C_@@ PROGRAM_@@ TO_@@ FIND_@@ THE_@@ PAR@@ ITY_@@ OF_@@ AN_@@ UNSIGNED_@@ INTEGER | def get@@ Par@@ ity ( n ) : NEW_LINE INDENT parity = 0 NEW_LINE while n : NEW_LINE INDENT parity = ~ parity NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return parity NEW_LINE DEDENT
CHECK_@@ WHE@@ THER_@@ LARGE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 7 | def is@@ di@@ visible@@ 7 ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE if ( n == 0 and num [ 0 ] == ' \n ' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 3 == 1 ) : NEW_LINE INDENT num = str ( num ) + "@@ 00" NEW_LINE n += 2 NEW_LINE DEDENT elif ( n % 3 == 2 ) : NEW_LINE INDENT num = str ( num ) + "0" NEW_LINE n += 1 NEW_LINE DEDENT GS@@ um = 0 NEW_LINE p = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT group = 0 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE i -= 1 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 NEW_LINE i -= 1 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 NEW_LINE GS@@ um = GS@@ um + group * p NEW_LINE p *= ( - 1 ) NEW_LINE DEDENT return ( GS@@ um % 7 == 0 ) NEW_LINE DEDENT
PRODUCT_@@ NODE@@ S_@@ K_@@ TH_@@ LEVEL_@@ TREE_@@ RE@@ PRESEN@@ TED_@@ STRING | def product@@ At@@ K@@ th@@ Level ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE product = 1 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level += 1 NEW_LINE DEDENT elif ( tree [ i ] == ' ) ' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( level == k ) : NEW_LINE INDENT product *= ( int ( tree [ i ] ) - int ( '0' ) ) NEW_LINE DEDENT DEDENT DEDENT return product NEW_LINE DEDENT
CHECK_@@ WHE@@ THER_@@ GI@@ V@@ EN_@@ NUMBER_@@ EV@@ EN_@@ O@@ DD | def is@@ Even ( n ) : NEW_LINE INDENT return ( n % 2 == 0 ) NEW_LINE DEDENT
COUNT_@@ GROUP@@ INGS_@@ NUMBER@@ _S@@ UM_@@ DIG@@ IT@@ S_@@ EVER@@ Y@@ _SUB_@@ GROUP_@@ LESS_@@ EQUAL@@ S_@@ IM@@ MEDI@@ ATE_@@ RIGHT_@@ SUB_@@ GROUP | def count@@ Groups ( position , previous_@@ sum , length , num ) : NEW_LINE INDENT if ( position == length ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( position , length ) : NEW_LINE INDENT sum = sum + int ( num [ i ] ) NEW_LINE if ( sum >= previous_@@ sum ) : NEW_LINE INDENT res = res + count@@ Groups ( i + 1 , sum , length , num ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
FIND_@@ THE_@@ ELEMENT_@@ TH@@ AT_@@ OD@@ D_@@ NUMBER_OF_@@ TIME@@ S_IN_@@ O@@ LOG_@@ N_@@ TIME | def search ( arr , low , high ) : NEW_LINE INDENT if low > high : NEW_LINE INDENT return None NEW_LINE DEDENT if low == high : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT mid = ( low + high ) / 2 ; NEW_LINE if mid % 2 == 0 : NEW_LINE INDENT if arr [ mid ] == arr [ mid + 1 ] : NEW_LINE INDENT return search ( arr , mid + 2 , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return search ( arr , low , mid ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if arr [ mid ] == arr [ mid - 1 ] : NEW_LINE INDENT return search ( arr , mid + 1 , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return search ( arr , low , mid - 1 ) NEW_LINE DEDENT DEDENT DEDENT
DELETE_@@ CON@@ SEC@@ UTI@@ VE_@@ WOR@@ DS@@ _SEQU@@ ENCE_@@ 1 | def remove@@ Con@@ sec@@ uti@@ ve@@ Same ( v ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT st . append ( v [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT Str = st [ - 1 ] NEW_LINE if ( Str == v [ i ] ) : NEW_LINE INDENT st . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( v [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return len ( st ) NEW_LINE DEDENT
MINIMUM_@@ NUMBER_OF_@@ JUM@@ PS_@@ TO_@@ REACH_@@ END_OF_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ 2 | def min@@ Jump@@ s ( arr , n ) : NEW_LINE INDENT jumps = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT jumps [ i ] = float ( ' inf ' ) NEW_LINE DEDENT elif ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT jumps [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT min = float ( ' inf ' ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j <= arr [ i ] + i ) : NEW_LINE INDENT if ( min > jumps [ j ] ) : NEW_LINE INDENT min = jumps [ j ] NEW_LINE DEDENT DEDENT DEDENT if ( min != float ( ' inf ' ) ) : NEW_LINE INDENT jumps [ i ] = min + 1 NEW_LINE DEDENT else : NEW_LINE INDENT jumps [ i ] = min NEW_LINE DEDENT DEDENT DEDENT return jumps [ 0 ] NEW_LINE DEDENT
PROGRAM_@@ FIND_@@ GC@@ D_@@ FLOAT@@ ING_@@ POINT_@@ NUMB@@ ERS | def gcd ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT return gcd ( b , a ) NEW_LINE DEDENT if ( abs ( b ) < 0.001 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return ( gcd ( b , a - math . floor ( a / b ) * b ) ) NEW_LINE DEDENT DEDENT
MAXIMUM_@@ PROFI@@ T_@@ BY_@@ BU@@ Y@@ ING_@@ AND@@ _S@@ EL@@ LING_@@ A@@ _SH@@ ARE_@@ AT_@@ MO@@ ST_@@ TWI@@ CE | def max@@ Pro@@ fit ( price , n ) : NEW_LINE INDENT pro@@ fit = [ 0 ] * n NEW_LINE max_@@ price = price [ n - 1 ] NEW_LINE for i in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT if price [ i ] > max_@@ price : NEW_LINE INDENT max_@@ price = price [ i ] NEW_LINE DEDENT pro@@ fit [ i ] = max ( pro@@ fit [ i + 1 ] , max_@@ price - price [ i ] ) NEW_LINE DEDENT min_@@ price = price [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if price [ i ] < min_@@ price : NEW_LINE INDENT min_@@ price = price [ i ] NEW_LINE DEDENT pro@@ fit [ i ] = max ( pro@@ fit [ i - 1 ] , pro@@ fit [ i ] + ( price [ i ] - min_@@ price ) ) NEW_LINE DEDENT result = pro@@ fit [ n - 1 ] NEW_LINE return result NEW_LINE DEDENT
COUNT_@@ SET_@@ BITS_@@ IN_@@ AN_@@ INTEGER_@@ 1 | def count@@ Set@@ Bits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n & 1 ) + count@@ Set@@ Bits ( n >> 1 ) NEW_LINE DEDENT DEDENT
RE@@ ORDER_@@ A_@@ ARRAY_@@ AC@@ COR@@ DING_@@ TO_@@ GI@@ V@@ EN_@@ INDEX@@ ES | def reorder ( arr , index , n ) : NEW_LINE INDENT temp = [ 0 ] * n ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp [ index [ i ] ] = arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE index [ i ] = i NEW_LINE DEDENT DEDENT
CHECK_@@ IF_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ CAN_@@ RE@@ PRES@@ ENT_@@ PRE@@ ORDER_@@ TRA@@ VERS@@ AL_@@ OF_@@ BIN@@ AR@@ Y@@ _SEARCH_@@ TREE | def can@@ Represent@@ B@@ ST ( pre ) : NEW_LINE INDENT s = [ ] NEW_LINE root = INT_@@ MIN NEW_LINE for value in pre : NEW_LINE INDENT if value < root : NEW_LINE INDENT return False NEW_LINE DEDENT while ( len ( s ) > 0 and s [ - 1 ] < value ) : NEW_LINE INDENT root = s . pop ( ) NEW_LINE DEDENT s . append ( value ) NEW_LINE DEDENT return True NEW_LINE DEDENT
FIND_@@ REPE@@ TI@@ TIVE_@@ ELEMENT_@@ 1_@@ N_@@ 1_@@ 3 | def find@@ Repe@@ ating ( arr , n ) : NEW_LINE INDENT missing@@ Element = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT element = arr [ abs ( arr [ i ] ) ] NEW_LINE if ( element < 0 ) : NEW_LINE INDENT missing@@ Element = arr [ i ] NEW_LINE break NEW_LINE DEDENT arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT return abs ( missing@@ Element ) NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 8_@@ MATRIX_@@ CHAIN_@@ MULTIP@@ LIC@@ ATION_@@ 1 | def Matrix@@ Chain@@ Order ( p , n ) : NEW_LINE INDENT m = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT m [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 2 , n ) : NEW_LINE INDENT for i in range ( 1 , n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE m [ i ] [ j ] = sys . maxint NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] NEW_LINE if q < m [ i ] [ j ] : NEW_LINE INDENT m [ i ] [ j ] = q NEW_LINE DEDENT DEDENT DEDENT DEDENT return m [ 1 ] [ n - 1 ] NEW_LINE DEDENT
COUNT_@@ NUMBER_@@ IS@@ LAND@@ S_@@ EVER@@ Y_@@ IS@@ LAND@@ _SE@@ PAR@@ ATED_@@ LINE | def count@@ Is@@ lands ( mat ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == ' X ' ) : NEW_LINE INDENT if ( ( i == 0 or mat [ i - 1 ] [ j ] == ' O ' ) and ( j == 0 or mat [ i ] [ j - 1 ] == ' O ' ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
MINI@@ MI@@ ZE_@@ MAX@@ AI_@@ B@@ J_@@ CK_@@ MIN@@ AI_@@ B@@ J_@@ CK_@@ THRE@@ E_@@ DIFF@@ ER@@ ENT_@@ SOR@@ TED_@@ ARRAY@@ S | def solve ( A , B , C ) : NEW_LINE INDENT i = len ( A ) - 1 NEW_LINE j = len ( B ) - 1 NEW_LINE k = len ( C ) - 1 NEW_LINE min_@@ diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) NEW_LINE while i != - 1 and j != - 1 and k != - 1 : NEW_LINE INDENT current_@@ diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) NEW_LINE if current_@@ diff < min_@@ diff : NEW_LINE INDENT min_@@ diff = current_@@ diff NEW_LINE DEDENT max_@@ term = max ( A [ i ] , B [ j ] , C [ k ] ) NEW_LINE if A [ i ] == max_@@ term : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT elif B [ j ] == max_@@ term : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT return min_@@ diff NEW_LINE DEDENT
ROO@@ TS_@@ QUAD@@ RATI@@ C_@@ EQU@@ ATION | def find@@ Roots ( a , b , c ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE return - 1 NEW_LINE DEDENT d = b * b - 4 * a * c NEW_LINE sq@@ rt_@@ val = math . sqrt ( abs ( d ) ) NEW_LINE if d > 0 : NEW_LINE INDENT print ( " Roots ▁ are ▁ real ▁ and ▁ different ▁ " ) NEW_LINE print ( ( - b + sq@@ rt_@@ val ) / ( 2 * a ) ) NEW_LINE print ( ( - b - sq@@ rt_@@ val ) / ( 2 * a ) ) NEW_LINE DEDENT elif d == 0 : NEW_LINE INDENT print ( " Roots ▁ are ▁ real ▁ and ▁ same " ) NEW_LINE print ( - b / ( 2 * a ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Roots ▁ are ▁ complex " ) NEW_LINE print ( - b / ( 2 * a ) , " ▁ + ▁ i " , sq@@ rt_@@ val ) NEW_LINE print ( - b / ( 2 * a ) , " ▁ - ▁ i " , sq@@ rt_@@ val ) NEW_LINE DEDENT DEDENT
GI@@ V@@ EN_@@ LEVEL_@@ ORDER_@@ TRA@@ VERS@@ AL_@@ BINARY_@@ TREE_@@ CHECK_@@ TREE_@@ MIN_@@ HEA@@ P | def is@@ Min@@ Heap ( level , n ) : NEW_LINE INDENT for i in range ( int ( n / 2 ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if level [ i ] > level [ 2 * i + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT if 2 * i + 2 < n : NEW_LINE INDENT if level [ i ] > level [ 2 * i + 2 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
FIND_@@ MINIMUM_@@ ELEMENT_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ AND_@@ ROTA@@ TED_@@ ARRAY | def find@@ Min ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT if high == low : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if mid < high and arr [ mid + 1 ] < arr [ mid ] : NEW_LINE INDENT return arr [ mid + 1 ] NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if arr [ high ] > arr [ mid ] : NEW_LINE INDENT return find@@ Min ( arr , low , mid - 1 ) NEW_LINE DEDENT return find@@ Min ( arr , mid + 1 , high ) NEW_LINE DEDENT
SM@@ ALLE@@ ST_@@ LENGTH_@@ STRING_@@ WITH_@@ REPE@@ ATED_@@ REPLACE@@ MENT_@@ OF_@@ TWO_@@ DISTIN@@ CT_@@ AD@@ J@@ AC@@ ENT | def string@@ Reduction ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 ] * 3 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if ( count [ 0 ] == n or count [ 1 ] == n or count [ 2 ] == n ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) and ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
CHECK_@@ LARGE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 3_@@ NOT | def check ( num ) : NEW_LINE INDENT digit@@ Sum = 0 NEW_LINE while num > 0 : NEW_LINE INDENT rem = num % 10 NEW_LINE digit@@ Sum = digit@@ Sum + rem NEW_LINE num = num / 10 NEW_LINE DEDENT return ( digit@@ Sum % 3 == 0 ) NEW_LINE DEDENT
COMP@@ UTE_@@ N_@@ UN@@ DER_@@ MODUL@@ O_@@ P | def mod@@ Fact ( n , p ) : NEW_LINE INDENT if n >= p : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT result = ( result * i ) % p NEW_LINE DEDENT return result NEW_LINE DEDENT
POSSI@@ BILITY_@@ OF_@@ A_@@ WORD_@@ FROM_@@ A_@@ GI@@ VEN@@ _SET_@@ OF_@@ CHARAC@@ TERS | def isPresent ( s , q ) : NEW_LINE INDENT freq = [ 0 ] * MAX_@@ CHAR NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , len ( q ) ) : NEW_LINE INDENT freq [ ord ( q [ i ] ) ] -= 1 NEW_LINE if ( freq [ ord ( q [ i ] ) ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
NEXT_@@ POWER_@@ OF_@@ 2_1 | def next@@ PowerOf@@ 2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p ; NEW_LINE DEDENT
RE@@ ORDER_@@ A_@@ ARRAY_@@ AC@@ COR@@ DING_@@ TO_@@ GI@@ V@@ EN_@@ INDEX@@ ES_@@ 1 | def reorder ( arr , index , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT while ( index [ i ] != i ) : NEW_LINE INDENT old@@ Target@@ I = index [ index [ i ] ] NEW_LINE old@@ Target@@ E = arr [ index [ i ] ] NEW_LINE arr [ index [ i ] ] = arr [ i ] NEW_LINE index [ index [ i ] ] = index [ i ] NEW_LINE index [ i ] = old@@ Target@@ I NEW_LINE arr [ i ] = old@@ Target@@ E NEW_LINE DEDENT DEDENT DEDENT
UN@@ BOUN@@ DED_@@ KN@@ AP@@ S@@ ACK_@@ REPE@@ TI@@ TION_@@ ITE@@ MS_@@ ALLOWED | def un@@ bounded@@ K@@ nap@@ s@@ ack ( W , n , val , wt ) : NEW_LINE INDENT dp = [ 0 for i in range ( W + 1 ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( W + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( wt [ j ] <= i ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ W ] NEW_LINE DEDENT
PROGRAM_@@ CHECK_@@ DIAG@@ ON@@ AL_@@ MATRI@@ X@@ _SCAL@@ AR_@@ MATRIX | def is@@ Diag@@ onal@@ Matrix ( mat ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
MAXIMUM_@@ REMO@@ VAL_@@ FROM_@@ ARRAY_@@ WH@@ EN_@@ REMO@@ VAL_@@ TIME_@@ WAIT@@ ING_@@ TIME | def max@@ Removal ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE cum@@ mul@@ ative@@ _@@ sum = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] >= cum@@ mul@@ ative@@ _@@ sum : NEW_LINE INDENT count += 1 NEW_LINE cum@@ mul@@ ative@@ _@@ sum += arr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
PROGRAM_@@ CEN@@ S@@ OR_@@ WORD_@@ AST@@ ER@@ IS@@ K@@ S_S@@ ENT@@ ENCE | def cen@@ sor ( text , word ) : NEW_LINE INDENT word_@@ list = text . split ( ) NEW_LINE result = ' ' NEW_LINE stars = ' * ' * len ( word ) NEW_LINE count = 0 NEW_LINE index = 0 ; NEW_LINE for i in word_@@ list : NEW_LINE INDENT if i == word : NEW_LINE INDENT word_@@ list [ index ] = stars NEW_LINE DEDENT index += 1 NEW_LINE DEDENT result = ' ▁ ' . join ( word_@@ list ) NEW_LINE return result NEW_LINE DEDENT
COUNT_@@ STRING@@ S_@@ WITH_@@ CON@@ SEC@@ UTI@@ VE_@@ 1@@ S | def count@@ Strings ( n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE b = [ 0 ] * n NEW_LINE a [ 0 ] = b [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ] NEW_LINE b [ i ] = a [ i - 1 ] NEW_LINE DEDENT return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] NEW_LINE DEDENT
LENGTH_@@ LON@@ GE@@ ST_@@ BAL@@ ANCE@@ D@@ _SUB@@ SEQUENCE | def maxLength ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' and s [ i + 1 ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ i + 1 ] = 2 NEW_LINE DEDENT DEDENT for l in range ( 2 , n ) : NEW_LINE INDENT i = - 1 NEW_LINE for j in range ( l , n ) : NEW_LINE INDENT i += 1 NEW_LINE if ( s [ i ] == ' ( ' and s [ j ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT
FIND_@@ THE_@@ POINT_@@ W@@ HER@@ E_@@ MAXIMUM_@@ INTER@@ VAL@@ S_@@ OVER@@ LA@@ P | def find@@ Max@@ Gue@@ sts ( ar@@ rl , exit , n ) : NEW_LINE INDENT ar@@ rl . sort ( ) ; NEW_LINE exit . sort ( ) ; NEW_LINE guest@@ s_@@ in = 1 ; NEW_LINE max_@@ gue@@ sts = 1 ; NEW_LINE time = ar@@ rl [ 0 ] ; NEW_LINE i = 1 ; NEW_LINE j = 0 ; NEW_LINE while ( i < n and j < n ) : NEW_LINE INDENT if ( ar@@ rl [ i ] <= exit [ j ] ) : NEW_LINE INDENT guest@@ s_@@ in = guest@@ s_@@ in + 1 ; NEW_LINE if ( guest@@ s_@@ in > max_@@ gue@@ sts ) : NEW_LINE INDENT max_@@ gue@@ sts = guest@@ s_@@ in ; NEW_LINE time = ar@@ rl [ i ] ; NEW_LINE DEDENT i = i + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT guest@@ s_@@ in = guest@@ s_@@ in - 1 ; NEW_LINE j = j + 1 ; NEW_LINE DEDENT DEDENT print ( " Maximum ▁ Number ▁ of ▁ Gue@@ sts ▁ = " , max_@@ gue@@ sts , " at ▁ time " , time ) NEW_LINE DEDENT
EF@@ FI@@ CI@@ ENT_@@ WA@@ Y_@@ CHECK_@@ WHE@@ THER_@@ N_@@ TH_@@ FI@@ BON@@ ACC@@ I_@@ NUMBER_@@ MULTIPLE_@@ 10 | def is@@ Multiple@@ Of@@ 10 ( n ) : NEW_LINE INDENT return ( n % 15 == 0 ) NEW_LINE DEDENT
MAX@@ IM@@ UM@@ _S@@ UM_@@ PAIR@@ S@@ _SPECI@@ FIC_@@ DIFF@@ ER@@ ENCE | def max@@ Sum@@ Pair@@ With@@ Difference@@ LessThan@@ K ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE dp = [ 0 ] * N NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] NEW_LINE if ( arr [ i ] - arr [ i - 1 ] < K ) : NEW_LINE INDENT if ( i >= 2 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT return dp [ N - 1 ] NEW_LINE DEDENT
FIND_@@ K_@@ PAIR@@ S_S@@ MAL@@ LE@@ ST@@ _S@@ UM@@ S_@@ TWO_@@ ARRAY@@ S | def k@@ S@@ malle@@ st@@ Pair ( ar@@ r1 , n1 , ar@@ r2 , n2 , k ) : NEW_LINE INDENT if ( k > n1 * n2 ) : NEW_LINE INDENT print ( " k ▁ pairs ▁ don ' t ▁ exist " ) NEW_LINE return NEW_LINE DEDENT index2 = [ 0 for i in range ( n1 ) ] NEW_LINE while ( k > 0 ) : NEW_LINE INDENT min_@@ sum = sys . maxsize NEW_LINE min_@@ index = 0 NEW_LINE for i1 in range ( 0 , n1 , 1 ) : NEW_LINE INDENT if ( index2 [ i1 ] < n2 and ar@@ r1 [ i1 ] + ar@@ r2 [ index2 [ i1 ] ] < min_@@ sum ) : NEW_LINE INDENT min_@@ index = i1 NEW_LINE min_@@ sum = ar@@ r1 [ i1 ] + ar@@ r2 [ index2 [ i1 ] ] NEW_LINE DEDENT DEDENT print ( " ( " , ar@@ r1 [ min_@@ index ] , " , " , ar@@ r2 [ index2 [ min_@@ index ] ] , " ) " , end = " ▁ " ) NEW_LINE index2 [ min_@@ index ] += 1 NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT
FIRST_@@ UP@@ PER@@ CASE_@@ LET@@ TER_@@ IN_@@ A_@@ STRING_@@ ITER@@ ATI@@ VE_@@ AND_@@ RECUR@@ SIVE_@@ 1 | def first ( str , i ) : NEW_LINE INDENT if ( str [ i ] == ' \0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( str [ i ] . is@@ upper ( ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT return first ( str , i + 1 ) NEW_LINE DEDENT
FIND_@@ PAIR@@ S_@@ B_@@ ARRAY_@@ B_@@ K | def print@@ Pairs ( arr , n , k ) : NEW_LINE INDENT is@@ Pair@@ Found = True NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i != j and arr [ i ] % arr [ j ] == k ) : NEW_LINE INDENT print ( " ( " , arr [ i ] , " , ▁ " , arr [ j ] , " ) " , sep = " " , end = " ▁ " ) NEW_LINE is@@ Pair@@ Found = True NEW_LINE DEDENT DEDENT DEDENT return is@@ Pair@@ Found NEW_LINE DEDENT
FIND_@@ AR@@ RANGE@@ MENT_@@ QUEUE_@@ GI@@ V@@ EN_@@ TIME | def solve ( n , t , p ) : NEW_LINE INDENT s = list ( p ) NEW_LINE for i in range ( 0 , t ) : NEW_LINE INDENT for j in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( s [ j ] == ' B ' and s [ j + 1 ] == ' G ' ) : NEW_LINE INDENT temp = s [ j ] ; NEW_LINE s [ j ] = s [ j + 1 ] ; NEW_LINE s [ j + 1 ] = temp ; NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT DEDENT print ( ' ' . join ( s ) ) NEW_LINE DEDENT
SHOR@@ TEST_@@ POSSI@@ BLE_@@ COMBIN@@ ATION_@@ TWO_@@ STRINGS | def print@@ Super@@ Seq ( a , b ) : NEW_LINE INDENT m = len ( a ) NEW_LINE n = len ( b ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ] NEW_LINE for i in range ( 0 , m + 1 ) : NEW_LINE INDENT for j in range ( 0 , n + 1 ) : NEW_LINE INDENT if not i : NEW_LINE INDENT dp [ i ] [ j ] = j ; NEW_LINE DEDENT elif not j : NEW_LINE INDENT dp [ i ] [ j ] = i ; NEW_LINE DEDENT elif ( a [ i - 1 ] == b [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT index = dp [ m ] [ n ] ; NEW_LINE res = [ " " ] * ( index ) NEW_LINE i = m NEW_LINE j = n ; NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( a [ i - 1 ] == b [ j - 1 ] ) : NEW_LINE INDENT res [ index - 1 ] = a [ i - 1 ] ; NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT elif ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) : NEW_LINE INDENT res [ index - 1 ] = a [ i - 1 ] NEW_LINE i -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res [ index - 1 ] = b [ j - 1 ] NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT while ( i > 0 ) : NEW_LINE INDENT res [ index - 1 ] = a [ i - 1 ] NEW_LINE i -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT while ( j > 0 ) : NEW_LINE INDENT res [ index - 1 ] = b [ j - 1 ] NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT print ( " " . join ( res ) ) NEW_LINE DEDENT
COUNT_@@ ROTA@@ TIONS_@@ DI@@ VISI@@ BLE_@@ 8 | def count@@ Rotation@@ s@@ Div@@ By@@ 8 ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE count = 0 NEW_LINE if ( l == 1 ) : NEW_LINE INDENT one@@ Digit = int ( n [ 0 ] ) NEW_LINE if ( one@@ Digit % 8 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( l == 2 ) : NEW_LINE INDENT first = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) NEW_LINE second = int ( n [ 1 ] ) * 10 + int ( n [ 0 ] ) NEW_LINE if ( first % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( second % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT three@@ Digit = 0 NEW_LINE for i in range ( 0 , ( l - 2 ) ) : NEW_LINE INDENT three@@ Digit = ( int ( n [ i ] ) * 100 + int ( n [ i + 1 ] ) * 10 + int ( n [ i + 2 ] ) ) NEW_LINE if ( three@@ Digit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT three@@ Digit = ( int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) ) NEW_LINE if ( three@@ Digit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT three@@ Digit = ( int ( n [ l - 2 ] ) * 100 + int ( n [ l - 1 ] ) * 10 + int ( n [ 0 ] ) ) NEW_LINE if ( three@@ Digit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ SEQU@@ ENCE_@@ WITH_@@ AT_@@ MO@@ ST_@@ K_@@ CHANGE@@ S_@@ ALLOWED | def l@@ cs ( dp , ar@@ r1 , n , ar@@ r2 , m , k ) : NEW_LINE INDENT if k < 0 : NEW_LINE INDENT return - ( 10 ** 7 ) NEW_LINE DEDENT if n < 0 or m < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = dp [ n ] [ m ] [ k ] NEW_LINE if ans != - 1 : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = max ( l@@ cs ( dp , ar@@ r1 , n - 1 , ar@@ r2 , m , k ) , l@@ cs ( dp , ar@@ r1 , n , ar@@ r2 , m - 1 , k ) ) NEW_LINE if ar@@ r1 [ n - 1 ] == ar@@ r2 [ m - 1 ] : NEW_LINE INDENT ans = max ( ans , 1 + l@@ cs ( dp , ar@@ r1 , n - 1 , ar@@ r2 , m - 1 , k ) ) NEW_LINE DEDENT ans = max ( ans , l@@ cs ( dp , ar@@ r1 , n - 1 , ar@@ r2 , m - 1 , k - 1 ) ) NEW_LINE return ans NEW_LINE DEDENT
CHECK_@@ LINE_@@ TOU@@ CHE@@ S_@@ INTER@@ SEC@@ TS_@@ CIRC@@ LE | def check@@ Collision ( a , b , c , x , y , radius ) : NEW_LINE INDENT dist = ( ( abs ( a * x + b * y + c ) ) / math . sqrt ( a * a + b * b ) ) NEW_LINE if ( radius == dist ) : NEW_LINE INDENT print ( " Touch " ) NEW_LINE DEDENT elif ( radius > dist ) : NEW_LINE INDENT print ( " Intersect " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Outside " ) NEW_LINE DEDENT DEDENT
FIND_@@ THE_@@ MAX@@ IM@@ UM@@ _SUB@@ ARRAY_@@ X@@ OR_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY | def max@@ Sub@@ array@@ XOR ( arr , n ) : NEW_LINE INDENT ans = - 214748364@@ 8 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_@@ xor = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_@@ xor = curr_@@ xor ^ arr [ j ] NEW_LINE ans = max ( ans , curr_@@ xor ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
SHOR@@ TEST_@@ PATH_@@ EXAC@@ TL@@ Y_@@ K_@@ ED@@ GE@@ S_@@ DIREC@@ TED_@@ WE@@ I@@ GH@@ TED_@@ GRAP@@ H | def shor@@ test@@ Path ( graph , u , v , k ) : NEW_LINE INDENT V = 4 NEW_LINE INF = 99999999@@ 9999 NEW_LINE if k == 0 and u == v : NEW_LINE INDENT return 0 NEW_LINE DEDENT if k == 1 and graph [ u ] [ v ] != INF : NEW_LINE INDENT return graph [ u ] [ v ] NEW_LINE DEDENT if k <= 0 : NEW_LINE INDENT return INF NEW_LINE DEDENT res = INF NEW_LINE for i in range ( V ) : NEW_LINE INDENT if graph [ u ] [ i ] != INF and u != i and v != i : NEW_LINE INDENT rec_@@ res = shor@@ test@@ Path ( graph , i , v , k - 1 ) NEW_LINE if rec_@@ res != INF : NEW_LINE INDENT res = min ( res , graph [ u ] [ i ] + rec_@@ res ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
FIN@@ D@@ _SUB@@ ARRAY_@@ WITH_@@ GI@@ VEN@@ _S@@ UM | def sub@@ Array@@ Sum ( arr , n , sum ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT curr_@@ sum = arr [ i ] NEW_LINE j = i + 1 NEW_LINE while j <= n : NEW_LINE INDENT if curr_@@ sum == sum : NEW_LINE INDENT print ( " Sum ▁ found ▁ between " ) NEW_LINE print ( " indexes ▁ % d ▁ and ▁ % d " % ( i , j - 1 ) ) NEW_LINE return 1 NEW_LINE DEDENT if curr_@@ sum > sum or j == n : NEW_LINE INDENT break NEW_LINE DEDENT curr_@@ sum = curr_@@ sum + arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT print ( " No ▁ sub@@ array ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT
K_@@ TH_@@ PRI@@ ME_@@ FAC@@ TOR_@@ GI@@ V@@ EN_@@ NUMBER | def k@@ Prime@@ Factor ( n , k ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT k = k - 1 NEW_LINE n = n / 2 NEW_LINE if ( k == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT i = 3 NEW_LINE while i <= math . sqrt ( n ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return i NEW_LINE DEDENT k = k - 1 NEW_LINE n = n / i NEW_LINE DEDENT i = i + 2 NEW_LINE DEDENT if ( n > 2 and k == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
FIND_@@ ROTATION_@@ COUNT_@@ ROTA@@ TE@@ D_S@@ OR@@ TED_@@ ARRAY_@@ 1 | def count@@ Rot@@ ations ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = low + ( high - low ) / 2 ; NEW_LINE mid = int ( mid ) NEW_LINE if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ high ] > arr [ mid ] ) : NEW_LINE INDENT return count@@ Rot@@ ations ( arr , low , mid - 1 ) ; NEW_LINE DEDENT return count@@ Rot@@ ations ( arr , mid + 1 , high ) NEW_LINE DEDENT
COMP@@ UTE_@@ AVER@@ AGE_@@ TWO_@@ NUMB@@ ERS_@@ WITH@@ OUT_@@ OVERFLOW_@@ 1 | def compute_@@ average ( a , b ) : NEW_LINE INDENT return ( a // 2 ) + ( b // 2 ) + ( ( a % 2 + b % 2 ) // 2 ) NEW_LINE DEDENT
SOR@@ TING_@@ USING_@@ TRI@@ VI@@ AL_@@ HASH_@@ FUNCTION_@@ 1 | def sort@@ Using@@ Hash ( a , n ) : NEW_LINE INDENT Max = max ( a ) NEW_LINE Min = abs ( min ( a ) ) NEW_LINE hash@@ pos = [ 0 ] * ( Max + 1 ) NEW_LINE hash@@ neg = [ 0 ] * ( Min + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] >= 0 : NEW_LINE INDENT hash@@ pos [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hash@@ neg [ abs ( a [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT for i in range ( Min , 0 , - 1 ) : NEW_LINE INDENT if hash@@ neg [ i ] != 0 : NEW_LINE INDENT for j in range ( 0 , hash@@ neg [ i ] ) : NEW_LINE INDENT print ( ( - 1 ) * i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , Max + 1 ) : NEW_LINE INDENT if hash@@ pos [ i ] != 0 : NEW_LINE INDENT for j in range ( 0 , hash@@ pos [ i ] ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
FIND_@@ THE_@@ TWO_@@ REPE@@ ATING_@@ ELEMEN@@ TS_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ 1 | def print@@ Repe@@ ating ( arr , size ) : NEW_LINE INDENT count = [ 0 ] * size NEW_LINE print ( " ▁ Repe@@ ating ▁ elements ▁ are ▁ " , end = " " ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( count [ arr [ i ] ] == 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT count [ arr [ i ] ] = count [ arr [ i ] ] + 1 NEW_LINE DEDENT DEDENT DEDENT
MINIMUM_@@ STE@@ PS_@@ MINI@@ MI@@ ZE_@@ N_@@ PER_@@ GI@@ V@@ EN_@@ CONDITION | def getMin@@ Steps ( n ) : NEW_LINE INDENT table = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT table [ i ] = n - i NEW_LINE DEDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( not ( i % 2 ) ) : NEW_LINE INDENT table [ i // 2 ] = min ( table [ i ] + 1 , table [ i // 2 ] ) NEW_LINE DEDENT if ( not ( i % 3 ) ) : NEW_LINE INDENT table [ i // 3 ] = min ( table [ i ] + 1 , table [ i // 3 ] ) NEW_LINE DEDENT DEDENT return table [ 1 ] NEW_LINE 
COUNT_@@ POSSI@@ BLE_@@ DE@@ COD@@ INGS_@@ GI@@ V@@ EN_@@ DIG@@ IT_@@ SEQU@@ ENCE_@@ 1 | def count@@ Decoding@@ DP ( digits , n ) : NEW_LINE INDENT count = [ 0 ] * ( n + 1 ) ; NEW_LINE count [ 0 ] = 1 ; NEW_LINE count [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT count [ i ] = 0 ; NEW_LINE if ( digits [ i - 1 ] > '0' ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] ; NEW_LINE DEDENT if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) ) : NEW_LINE INDENT count [ i ] += count [ i - 2 ] ; NEW_LINE DEDENT DEDENT return count [ n ] ; NEW_LINE DEDENT
E@@ UL@@ ERS_@@ FOUR@@ _S@@ QU@@ ARE_@@ IDENTI@@ TY_@@ 1 | def check@@ Euler@@ Four@@ Square@@ Identity ( a , b ) : NEW_LINE INDENT ab = a * b NEW_LINE flag = False NEW_LINE i = 0 NEW_LINE while i * i <= ab : NEW_LINE INDENT j = i NEW_LINE while i * i + j * j <= ab : NEW_LINE INDENT k = j NEW_LINE while i * i + j * j + k * k <= ab : NEW_LINE INDENT l = ( ab - ( i * i + j * j + k * k ) ) ** ( 0.5 ) NEW_LINE if l == int ( l ) and l >= k : NEW_LINE INDENT flag = True NEW_LINE print ( " i ▁ = ▁ " , i ) NEW_LINE print ( " j ▁ = ▁ " , j ) NEW_LINE print ( " k ▁ = ▁ " , k ) NEW_LINE print ( " l ▁ = ▁ " , l ) NEW_LINE print ( " Product ▁ of " , a , " and " , b , " can ▁ be ▁ written ▁ as ▁ sum ▁ of ▁ squares ▁ of ▁ i , ▁ j , ▁ k , ▁ l " ) NEW_LINE print ( ab , " ▁ = ▁ " , i , " * " , i , " + " , j , " * " , j , " + " , k , " * " , k , " + " , l , " * " , l ) NEW_LINE DEDENT k += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if flag == False : NEW_LINE INDENT print ( " Solution ▁ doesn ' t ▁ exist ! " ) NEW_LINE return NEW_LINE DEDENT DEDENT
COUNT_@@ NUMBER_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQU@@ EN@@ CE@@ S@@ _SIZE_@@ K | def numOf@@ Inc@@ Sub@@ seq@@ Of@@ Size@@ K ( arr , n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( k ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for l in range ( 1 , k ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT dp [ l ] [ i ] = 0 NEW_LINE for j in range ( l - 1 , i ) : NEW_LINE INDENT if ( arr [ j ] < arr [ i ] ) : NEW_LINE INDENT dp [ l ] [ i ] += dp [ l - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT Sum = 0 NEW_LINE for i in range ( k - 1 , n ) : NEW_LINE INDENT Sum += dp [ k - 1 ] [ i ] NEW_LINE DEDENT return Sum NEW_LINE DEDENT
KN@@ AP@@ S@@ ACK_@@ PRO@@ BLE@@ M_@@ 1 | def kn@@ ap@@ S@@ ack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT return K [ n ] [ W ] NEW_LINE DEDENT
PROGRAM_@@ TO_@@ PRINT_@@ DOUBLE_@@ HEA@@ DED_@@ ARROW_@@ PATTERN | def draw@@ Pattern ( N ) : NEW_LINE INDENT n = N ; NEW_LINE row = 1 ; NEW_LINE n@@ st = 1 ; NEW_LINE n@@ sp@@ 1 = n - 1 ; NEW_LINE n@@ sp@@ 2 = - 1 ; NEW_LINE val1 = row ; NEW_LINE val2 = 1 ; NEW_LINE while ( row <= n ) : NEW_LINE INDENT c@@ sp@@ 1 = 1 ; NEW_LINE while ( c@@ sp@@ 1 <= n@@ sp@@ 1 ) : NEW_LINE INDENT print ( " ▁ " , end = " ▁ " ) ; NEW_LINE c@@ sp@@ 1 = c@@ sp@@ 1 + 1 ; NEW_LINE DEDENT c@@ st1 = 1 ; NEW_LINE while ( c@@ st1 <= n@@ st ) : NEW_LINE INDENT print ( val1 , end = " ▁ " ) ; NEW_LINE val1 = val1 - 1 ; NEW_LINE c@@ st1 = c@@ st1 + 1 ; NEW_LINE DEDENT c@@ sp@@ 2 = 1 ; NEW_LINE while ( c@@ sp@@ 2 <= n@@ sp@@ 2 ) : NEW_LINE INDENT print ( " ▁ " , end = " ▁ " ) ; NEW_LINE c@@ sp@@ 2 = c@@ sp@@ 2 + 1 ; NEW_LINE DEDENT if ( row != 1 and row != n ) : NEW_LINE INDENT c@@ st2 = 1 ; NEW_LINE while ( c@@ st2 <= n@@ st ) : NEW_LINE INDENT print ( val2 , end = " ▁ " ) ; NEW_LINE val2 = val2 + 1 ; NEW_LINE c@@ st2 = c@@ st2 + 1 ; NEW_LINE DEDENT DEDENT print ( ) NEW_LINE if ( row <= n // 2 ) : NEW_LINE INDENT n@@ st = n@@ st + 1 ; NEW_LINE n@@ sp@@ 1 = n@@ sp@@ 1 - 2 ; NEW_LINE n@@ sp@@ 2 = n@@ sp@@ 2 + 2 ; NEW_LINE val1 = row + 1 ; NEW_LINE val2 = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT n@@ st = n@@ st - 1 ; NEW_LINE n@@ sp@@ 1 = n@@ sp@@ 1 + 2 ; NEW_LINE n@@ sp@@ 2 = n@@ sp@@ 2 - 2 ; NEW_LINE val1 = n - row ; NEW_LINE val2 = 1 ; NEW_LINE DEDENT row = row + 1 ; NEW_LINE DEDENT DEDENT
INTEGER_@@ POSITIVE_@@ VALUE_@@ POSITIVE_@@ NEGATIVE_@@ VALUE_@@ ARRAY | def find@@ Integer ( arr , n ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE maximum = 0 NEW_LINE for i in arr : NEW_LINE INDENT if ( i < 0 ) : NEW_LINE INDENT if abs ( i ) not in hash . keys ( ) : NEW_LINE INDENT hash [ abs ( i ) ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT hash [ abs ( i ) ] -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT hash [ i ] = hash . get ( i , 0 ) + 1 NEW_LINE DEDENT DEDENT for i in arr : NEW_LINE INDENT if i in hash . keys ( ) and hash [ i ] > 0 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
SPACE_@@ OPTIMIZ@@ ED@@ _S@@ OL@@ U@@ TION_@@ L@@ CS | def l@@ cs ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 2 ) ] NEW_LINE bi = bool NEW_LINE for i in range ( m ) : NEW_LINE INDENT bi = i & 1 NEW_LINE for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ bi ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ bi ] [ n ] NEW_LINE DEDENT
RE@@ PRES@@ ENT_@@ NUMBER@@ _S@@ UM_@@ MINIMUM_@@ POSSI@@ BLE_@@ P@@ SU@@ E@@ DO@@ BINARY_@@ NUMB@@ ERS | def p@@ su@@ e@@ do@@ Binary ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT temp = n ; NEW_LINE m = 0 ; NEW_LINE p = 1 ; NEW_LINE while ( temp ) : NEW_LINE INDENT rem = temp % 10 ; NEW_LINE temp = int ( temp / 10 ) ; NEW_LINE if ( rem != 0 ) : NEW_LINE INDENT m += p ; NEW_LINE DEDENT p *= 10 ; NEW_LINE DEDENT print ( m , end = " ▁ " ) ; NEW_LINE n = n - m ; NEW_LINE DEDENT DEDENT
FIND_@@ NUMBER_@@ CURRENCY_@@ NOTE@@ S_S@@ UM_@@ UP@@ TO_@@ GI@@ V@@ EN_@@ AMOUNT | def count@@ Currency ( amount ) : NEW_LINE INDENT notes = [ 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 ] NEW_LINE note@@ Counter = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE print ( " Currency ▁ Count ▁ - > ▁ " ) NEW_LINE for i , j in zip ( notes , note@@ Counter ) : NEW_LINE INDENT if amount >= i : NEW_LINE INDENT j = amount // i NEW_LINE amount = amount - j * i NEW_LINE print ( i , " ▁ : ▁ " , j ) NEW_LINE DEDENT DEDENT DEDENT
POSITIVE_@@ ELEMEN@@ TS_@@ EV@@ EN_@@ NEGATIVE_@@ OD@@ D_@@ POSI@@ TIONS | def re@@ arrange ( a , size ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 1 NEW_LINE while ( True ) : NEW_LINE INDENT while ( positive < size and a [ positive ] >= 0 ) : NEW_LINE INDENT positive = positive + 2 NEW_LINE DEDENT while ( negative < size and a [ negative ] <= 0 ) : NEW_LINE INDENT negative = negative + 2 NEW_LINE DEDENT if ( positive < size and negative < size ) : NEW_LINE INDENT temp = a [ positive ] NEW_LINE a [ positive ] = a [ negative ] NEW_LINE a [ negative ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
FIND_@@ WHE@@ THER_@@ AN_@@ ARRAY_@@ IS@@ _SUB@@ SET_@@ OF_@@ AN@@ OTHER_@@ ARRAY@@ _SET_@@ 1 | def is@@ Subset ( ar@@ r1 , ar@@ r2 , m , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( ar@@ r2 [ i ] == ar@@ r1 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
GI@@ V@@ EN_@@ A@@ _S@@ OR@@ TED_@@ AND_@@ ROTA@@ TED_@@ ARRAY_@@ FIND_@@ IF_@@ THER@@ E_@@ IS_@@ A_@@ PA@@ IR_@@ WITH_@@ A_@@ GI@@ VEN@@ _S@@ UM | def pair@@ In@@ Sorted@@ Rot@@ ated ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE while ( l != r ) : NEW_LINE INDENT if ( arr [ l ] + arr [ r ] == x ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( arr [ l ] + arr [ r ] < x ) : NEW_LINE INDENT l = ( l + 1 ) % n ; NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT
PROGRAM_@@ TO_@@ FIND_@@ RE@@ MA@@ INDE@@ R_@@ WITH@@ OUT_@@ USING_@@ MODUL@@ O_@@ OR_@@ OPERATOR_@@ 1 | def getRe@@ main@@ der ( num , divisor ) : NEW_LINE INDENT if ( divisor == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( divisor < 0 ) : NEW_LINE INDENT divisor = - divisor NEW_LINE DEDENT if ( num < 0 ) : NEW_LINE INDENT num = - num NEW_LINE DEDENT i = 1 NEW_LINE product = 0 NEW_LINE while ( product <= num ) : NEW_LINE INDENT product = divisor * i NEW_LINE i += 1 NEW_LINE DEDENT return num - ( product - divisor ) NEW_LINE DEDENT
G@@ NO@@ ME_@@ SORT_@@ A_@@ ST@@ UP@@ ID_@@ ONE | def g@@ nome@@ Sort ( arr , n ) : NEW_LINE INDENT index = 0 NEW_LINE while index < n : NEW_LINE INDENT if index == 0 : NEW_LINE INDENT index = index + 1 NEW_LINE DEDENT if arr [ index ] >= arr [ index - 1 ] : NEW_LINE INDENT index = index + 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ] NEW_LINE index = index - 1 NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT
NUMBER_@@ WAY@@ S_@@ INSERT_@@ CHARACTER_@@ INCRE@@ ASE_@@ LC@@ S_@@ ONE | def number@@ of@@ ways ( A , B , N , M ) : NEW_LINE INDENT pos = [ [ ] for _ in range ( MAX ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT pos [ ord ( B [ i ] ) ] . append ( i + 1 ) NEW_LINE DEDENT d@@ pl = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT if A [ i - 1 ] == B [ j - 1 ] : NEW_LINE INDENT d@@ pl [ i ] [ j ] = d@@ pl [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT d@@ pl [ i ] [ j ] = max ( d@@ pl [ i - 1 ] [ j ] , d@@ pl [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT L@@ CS = d@@ pl [ N ] [ M ] NEW_LINE d@@ pr = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ] NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT for j in range ( M , 0 , - 1 ) : NEW_LINE INDENT if A [ i - 1 ] == B [ j - 1 ] : NEW_LINE INDENT d@@ pr [ i ] [ j ] = d@@ pr [ i + 1 ] [ j + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT d@@ pr [ i ] [ j ] = max ( d@@ pr [ i + 1 ] [ j ] , d@@ pr [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( MAX ) : NEW_LINE INDENT for x in pos [ j ] : NEW_LINE INDENT if d@@ pl [ i ] [ x - 1 ] + d@@ pr [ i + 1 ] [ x + 1 ] == L@@ CS : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
MINIMUM_@@ PRODUCT_@@ K_@@ INTEG@@ ERS_@@ ARRAY_@@ POSITIVE_@@ INTEG@@ ERS | def min@@ Product ( arr , n , k ) : NEW_LINE INDENT heap@@ q . heap@@ ify ( arr ) NEW_LINE count = 0 NEW_LINE ans = 1 NEW_LINE while ( arr ) and count < k : NEW_LINE INDENT x = heap@@ q . heap@@ pop ( arr ) NEW_LINE ans = ans * x NEW_LINE count = count + 1 NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
FIND_@@ UNI@@ QUE_@@ ELEMEN@@ TS_@@ MATRIX | def unique ( mat , n , m ) : NEW_LINE INDENT maximum = 0 ; flag = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( maximum < mat [ i ] [ j ] ) : NEW_LINE INDENT maximum = mat [ i ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT unique@@ Element@@ Dict = [ 0 ] * ( maximum + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT unique@@ Element@@ Dict [ mat [ i ] [ j ] ] += 1 NEW_LINE DEDENT DEDENT for key in range ( maximum + 1 ) : NEW_LINE INDENT if unique@@ Element@@ Dict [ key ] == 1 : NEW_LINE INDENT print ( key , end = " ▁ " ) NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( " No ▁ unique ▁ element ▁ in ▁ the ▁ matrix " ) NEW_LINE DEDENT DEDENT
LON@@ GE@@ ST@@ _SUB@@ SEQU@@ ENCE_@@ SU@@ CH_@@ TH@@ AT_@@ DIFF@@ ER@@ ENCE_@@ BETWE@@ EN_@@ AD@@ J@@ AC@@ ENTS_@@ IS_@@ ONE | def lon@@ gest@@ Sub@@ seq@@ With@@ Diff@@ One ( arr , n ) : NEW_LINE INDENT dp = [ 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( ( arr [ i ] == arr [ j ] + 1 ) or ( arr [ i ] == arr [ j ] - 1 ) ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT result = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( result < dp [ i ] ) : NEW_LINE INDENT result = dp [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
C_@@ PROGRAM_@@ CON@@ CAT@@ EN@@ ATE_@@ STRING_@@ GI@@ V@@ EN_@@ NUMBER_@@ TIMES | def repeat ( s , n ) : NEW_LINE INDENT s1 = s NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s += s1 NEW_LINE DEDENT return s NEW_LINE DEDENT
SE@@ ARCH@@ ING_@@ FOR_@@ PATTER@@ NS@@ _SET_@@ 1_@@ N@@ AI@@ VE_@@ PATTER@@ N@@ _SE@@ ARCH@@ ING | def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < M ) : NEW_LINE INDENT if ( txt [ i + j ] != pat [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == M ) : NEW_LINE INDENT print ( " Pattern ▁ found ▁ at ▁ index ▁ " , i ) NEW_LINE DEDENT DEDENT DEDENT
COUNT_@@ POSSI@@ BLE_@@ PATH@@ S@@ _SOURCE_@@ DESTIN@@ ATION_@@ EXAC@@ TL@@ Y_@@ K_@@ ED@@ GES | def coun@@ tw@@ al@@ ks ( graph , u , v , k ) : NEW_LINE INDENT if ( k == 0 and u == v ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 1 and graph [ u ] [ v ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , V ) : NEW_LINE INDENT if ( graph [ u ] [ i ] == 1 ) : NEW_LINE INDENT count += coun@@ tw@@ al@@ ks ( graph , i , v , k - 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
COUNT_@@ DI@@ VISI@@ BLE_@@ PAIR@@ S_@@ ARRAY | def count@@ Di@@ visi@@ bles ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] % arr [ j ] == 0 or arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
PROGRAM_@@ TO_@@ CHECK_@@ IF_@@ A_@@ MATRIX_@@ IS_@@ SYM@@ METRIC | def is@@ Symmetri@@ c ( mat , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
COUNT_@@ PA@@ LIN@@ DRO@@ ME_@@ SUB_@@ STRING@@ S_@@ STRING | def Count@@ PS ( str , n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE P = [ [ False for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT P [ i ] [ i ] = True NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT P [ i ] [ i + 1 ] = True NEW_LINE dp [ i ] [ i + 1 ] = 1 NEW_LINE DEDENT DEDENT for gap in range ( 2 , n ) : NEW_LINE INDENT for i in range ( n - gap ) : NEW_LINE INDENT j = gap + i ; NEW_LINE if ( str [ i ] == str [ j ] and P [ i + 1 ] [ j - 1 ] ) : NEW_LINE INDENT P [ i ] [ j ] = True NEW_LINE DEDENT if ( P [ i ] [ j ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT
WAY@@ S_S@@ UM_@@ N_@@ USING_@@ ARRAY_@@ ELEMEN@@ TS_@@ REPE@@ TI@@ TION_@@ ALLOWED | def count@@ W@@ ays ( arr , m , N ) : NEW_LINE INDENT count = [ 0 for i in range ( N + 1 ) ] NEW_LINE count [ 0 ] = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( i >= arr [ j ] ) : NEW_LINE INDENT count [ i ] += count [ i - arr [ j ] ] NEW_LINE DEDENT DEDENT DEDENT return count [ N ] NEW_LINE DEDENT
MINIMUM_@@ NUMBER_OF_@@ OPER@@ ATION@@ S_TO_@@ MOVE_@@ ALL_@@ UP@@ PER@@ CASE_@@ CHARAC@@ TER@@ S_@@ BEFORE_@@ ALL_@@ LOWER_@@ CASE_@@ CHARAC@@ TERS | def min@@ Operations ( str , n ) : NEW_LINE INDENT last@@ Upper = - 1 NEW_LINE first@@ Lower = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] . is@@ upper ( ) ) : NEW_LINE INDENT last@@ Upper = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] . is@@ lower ( ) ) : NEW_LINE INDENT first@@ Lower = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( last@@ Upper == - 1 or first@@ Lower == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count@@ Upper = 0 NEW_LINE for i in range ( first@@ Lower , n ) : NEW_LINE INDENT if ( str [ i ] . is@@ upper ( ) ) : NEW_LINE INDENT count@@ Upper += 1 NEW_LINE DEDENT DEDENT count@@ Lower = 0 NEW_LINE for i in range ( last@@ Upper ) : NEW_LINE INDENT if ( str [ i ] . is@@ lower ( ) ) : NEW_LINE INDENT count@@ Lower += 1 NEW_LINE DEDENT DEDENT return min ( count@@ Lower , count@@ Upper ) NEW_LINE DEDENT
PRINT_@@ A_@@ GI@@ V@@ EN_@@ MATRIX_@@ IN@@ _SP@@ IR@@ AL_@@ FORM | def spir@@ al@@ Print ( m , n , a ) : NEW_LINE INDENT k = 0 ; l = 0 NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT print ( a [ k ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT print ( a [ i ] [ n - 1 ] , end = " ▁ " ) NEW_LINE DEDENT n -= 1 NEW_LINE if ( k < m ) : NEW_LINE INDENT for i in range ( n - 1 , ( l - 1 ) , - 1 ) : NEW_LINE INDENT print ( a [ m - 1 ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if ( l < n ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT print ( a [ i ] [ l ] , end = " ▁ " ) NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT DEDENT
FIND_@@ DISTIN@@ CT_@@ INTEG@@ ERS_@@ FOR_@@ A_@@ TR@@ IP@@ LET_@@ WITH_@@ GI@@ V@@ EN_@@ PRODUCT | def find@@ Trip@@ lets ( x ) : NEW_LINE INDENT fact = [ ] ; NEW_LINE factors = set ( ) ; NEW_LINE for i in range ( 2 , int ( sqrt ( x ) ) ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT fact . append ( i ) ; NEW_LINE if ( x / i != i ) : NEW_LINE INDENT fact . append ( x // i ) ; NEW_LINE DEDENT factors . add ( i ) ; NEW_LINE factors . add ( x // i ) ; NEW_LINE DEDENT DEDENT found = False ; NEW_LINE k = len ( fact ) ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT a = fact [ i ] ; NEW_LINE for j in range ( k ) : NEW_LINE INDENT b = fact [ j ] ; NEW_LINE if ( ( a != b ) and ( x % ( a * b ) == 0 ) and ( x / ( a * b ) != a ) and ( x / ( a * b ) != b ) and ( x / ( a * b ) != 1 ) ) : NEW_LINE INDENT print ( a , b , x // ( a * b ) ) ; NEW_LINE found = True ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( not found ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE DEDENT DEDENT
S@@ UM_@@ TWO_@@ LARGE_@@ NUMB@@ ERS_@@ 1 | def find@@ Sum ( str1 , str2 ) : NEW_LINE INDENT if len ( str1 ) > len ( str2 ) : NEW_LINE INDENT temp = str1 NEW_LINE str1 = str2 NEW_LINE str2 = temp NEW_LINE DEDENT str@@ 3 = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE diff = n2 - n1 NEW_LINE carry = 0 NEW_LINE for i in range ( n1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = ( ( ord ( str1 [ i ] ) - ord ( '0' ) ) + int ( ( ord ( str2 [ i + diff ] ) - ord ( '0' ) ) ) + carry ) NEW_LINE str@@ 3 = str@@ 3 + str ( sum % 10 ) NEW_LINE carry = sum // 10 NEW_LINE DEDENT for i in range ( n2 - n1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = ( ( ord ( str2 [ i ] ) - ord ( '0' ) ) + carry ) NEW_LINE str@@ 3 = str@@ 3 + str ( sum % 10 ) NEW_LINE carry = sum // 10 NEW_LINE DEDENT if ( carry ) : NEW_LINE INDENT str@@ 3 + str ( carry + '0' ) NEW_LINE DEDENT str@@ 3 = str@@ 3 [ : : - 1 ] NEW_LINE return str@@ 3 NEW_LINE DEDENT
CO@@ CK@@ TA@@ IL@@ _S@@ ORT | def co@@ ck@@ tail@@ Sort ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE swapped = True NEW_LINE start = 0 NEW_LINE end = n - 1 NEW_LINE while ( swapped == True ) : NEW_LINE INDENT swapped = False NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT if ( swapped == False ) : NEW_LINE INDENT break NEW_LINE DEDENT swapped = False NEW_LINE end = end - 1 NEW_LINE for i in range ( end - 1 , start - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT start = start + 1 NEW_LINE DEDENT DEDENT
COUNT_@@ DE@@ RANGE@@ MEN@@ TS_@@ PER@@ MU@@ TA@@ TION@@ _SU@@ CH_@@ TH@@ AT_@@ NO_@@ ELEMENT_@@ AP@@ PE@@ AR@@ S_IN_@@ IT@@ S_@@ ORIGIN@@ AL_@@ POSITION_@@ 1 | def count@@ D@@ er ( n ) : NEW_LINE INDENT der = [ 0 for i in range ( n + 1 ) ] NEW_LINE der [ 0 ] = 1 NEW_LINE der [ 1 ] = 0 NEW_LINE der [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) NEW_LINE DEDENT return der [ n ] NEW_LINE DEDENT
MAXIMUM_@@ PRODUCT_@@ SUB@@ ARRAY_@@ AD@@ DED_@@ NEGATIVE_@@ PRODUCT_@@ CASE | def find@@ Max@@ Product ( arr , n ) : NEW_LINE INDENT ans = - float ( ' inf ' ) NEW_LINE maxval = 1 NEW_LINE min@@ val = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT maxval = maxval * arr [ i ] NEW_LINE min@@ val = min ( 1 , min@@ val * arr [ i ] ) NEW_LINE DEDENT elif arr [ i ] == 0 : NEW_LINE INDENT min@@ val = 1 NEW_LINE maxval = 0 NEW_LINE DEDENT elif arr [ i ] < 0 : NEW_LINE INDENT prev@@ Max = maxval NEW_LINE maxval = min@@ val * arr [ i ] NEW_LINE min@@ val = prev@@ Max * arr [ i ] NEW_LINE DEDENT ans = max ( ans , maxval ) NEW_LINE if maxval <= 0 : NEW_LINE INDENT maxval = 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
RE@@ AR@@ RANGE_@@ ARRAY@@ _SU@@ CH_@@ TH@@ AT_@@ EV@@ EN_@@ POSI@@ TI@@ ONED_@@ ARE_@@ GREATER_@@ TH@@ AN_@@ O@@ DD | def assign ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE ans = [ 0 ] * n NEW_LINE p = 0 NEW_LINE q = n - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i + 1 ) % 2 == 0 : NEW_LINE INDENT ans [ i ] = a [ q ] NEW_LINE q = q - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans [ i ] = a [ p ] NEW_LINE p = p + 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
FRI@@ END@@ S_@@ PAIR@@ ING_@@ PRO@@ BLE@@ M | def count@@ Fri@@ ends@@ Pair@@ ings ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i <= 2 ) : NEW_LINE INDENT dp [ i ] = i NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
PRI@@ ME_@@ NUMB@@ ERS | def is@@ Prime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
PRO@@ B@@ AB@@ ILITY_@@ REACH@@ ING_@@ POINT_@@ 2_@@ 3_@@ STE@@ PS_@@ TIME | def find_@@ prob ( N , P ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 0 NEW_LINE dp [ 2 ] = P NEW_LINE dp [ 3 ] = 1 - P NEW_LINE for i in range ( 4 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] NEW_LINE DEDENT return dp [ N ] NEW_LINE DEDENT
SM@@ ALLE@@ ST_@@ OF_@@ THRE@@ E_@@ INTEG@@ ERS_@@ WITH@@ OUT_@@ COMP@@ ARIS@@ ON_@@ OPER@@ ATOR@@ S_@@ 1 | def smallest ( x , y , z ) : NEW_LINE INDENT if ( not ( y / x ) ) : NEW_LINE INDENT return y if ( not ( y / z ) ) else z NEW_LINE DEDENT return x if ( not ( x / z ) ) else z NEW_LINE DEDENT
COMMON_@@ ELEMEN@@ TS_@@ IN_@@ ALL_@@ RO@@ WS_@@ OF_@@ A_@@ GI@@ V@@ EN_@@ MATRIX | def print@@ Common@@ Elements ( mat ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for j in range ( N ) : NEW_LINE INDENT mp [ mat [ 0 ] [ j ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] in mp . keys ( ) and mp [ mat [ i ] [ j ] ] == i ) : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = i + 1 NEW_LINE if i == M - 1 : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
DETE@@ CT@@ ING_@@ NEGATIVE_@@ CY@@ CLE_@@ USING_@@ FLO@@ Y@@ D_@@ WAR@@ SHALL | def neg@@ Cycle@@ flo@@ y@@ d@@ War@@ shall ( graph ) : NEW_LINE INDENT dist = [ [ 0 for i in range ( V + 1 ) ] for j in range ( V + 1 ) ] NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT dist [ i ] [ j ] = graph [ i ] [ j ] NEW_LINE DEDENT DEDENT for k in range ( V ) : NEW_LINE INDENT for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) : NEW_LINE INDENT dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( V ) : NEW_LINE INDENT if ( dist [ i ] [ i ] < 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
PROGR@@ AM@@ _S@@ ORT_@@ STRING_@@ DESC@@ END@@ ING_@@ ORDER | def sort@@ String ( str ) : NEW_LINE INDENT char@@ Count = [ 0 ] * MAX_@@ CHAR ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT char@@ Count [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( MAX_@@ CHAR - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( char@@ Count [ i ] ) : NEW_LINE INDENT print ( chr ( 97 + i ) , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT
COUNT_@@ PAIR@@ S_@@ WITH_@@ GI@@ VEN@@ _S@@ UM | def get@@ Pai@@ rs@@ Count ( arr , n , sum ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] + arr [ j ] == sum : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
SUM@@ _SERI@@ ES_@@ 12_@@ 32_@@ 5@@ 2_@@ 2@@ N_@@ 12@@ _1 | def sum@@ Of@@ Series ( n ) : NEW_LINE INDENT return int ( ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ) NEW_LINE DEDENT
MAXIMUM_@@ DIFF@@ ER@@ ENCE_@@ BETWE@@ EN_@@ FREQU@@ ENCY_@@ OF_@@ TWO_@@ ELEMEN@@ TS@@ _SU@@ CH_@@ TH@@ AT_@@ ELEMENT_@@ H@@ AV@@ ING_@@ GREATER_@@ FREQU@@ ENCY_@@ IS_@@ AL@@ SO_@@ GREATER | def max@@ diff ( arr , n ) : NEW_LINE INDENT freq = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] : NEW_LINE INDENT ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) NEW_LINE DEDENT elif freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] : NEW_LINE INDENT ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
SHIFT_@@ MATRIX_@@ ELEMEN@@ TS_@@ K | def shift@@ Matrix@@ By@@ K ( mat , k ) : NEW_LINE INDENT if ( k > N ) : NEW_LINE INDENT print ( " shift@@ ing ▁ is " " ▁ not ▁ possible " ) NEW_LINE return NEW_LINE DEDENT j = 0 NEW_LINE while ( j < N ) : NEW_LINE INDENT for i in range ( k , N ) : NEW_LINE INDENT print ( " { } ▁ " . format ( mat [ j ] [ i ] ) , end = " " ) NEW_LINE DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT print ( " { } ▁ " . format ( mat [ j ] [ i ] ) , end = " " ) NEW_LINE DEDENT print ( " " ) NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT
MAXIMUM_@@ AND_@@ MINIMUM_@@ IN_@@ A@@ _S@@ QU@@ ARE_@@ MATRIX | def MAX@@ MIN ( arr , n ) : NEW_LINE INDENT MIN = 10 ** 9 NEW_LINE MAX = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n // 2 + 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT if ( MIN > arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT MIN = arr [ i ] [ n - j - 1 ] NEW_LINE DEDENT if ( MAX < arr [ i ] [ j ] ) : NEW_LINE INDENT MAX = arr [ i ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( MIN > arr [ i ] [ j ] ) : NEW_LINE INDENT MIN = arr [ i ] [ j ] NEW_LINE DEDENT if ( MAX < arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT MAX = arr [ i ] [ n - j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " MAX@@ imum ▁ = " , MAX , " , ▁ MIN@@ imum ▁ = " , MIN ) NEW_LINE DEDENT
FIND_@@ PA@@ IR_@@ WITH_@@ GREA@@ TEST_@@ PRODUCT_@@ IN_@@ ARRAY_@@ 1 | def find@@ Gre@@ atest ( arr , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in arr : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT arr = sorted ( arr ) NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < i and arr [ j ] <= sqrt ( arr [ i ] ) ) : NEW_LINE INDENT if ( arr [ i ] % arr [ j ] == 0 ) : NEW_LINE INDENT result = arr [ i ] // arr [ j ] NEW_LINE if ( result != arr [ j ] and ( result in m . keys ( ) ) and m [ result ] > 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT elif ( result == arr [ j ] and ( result in m . keys ( ) ) and m [ result ] > 1 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
0_@@ 1_@@ KN@@ AP@@ S@@ ACK_@@ PRO@@ BLE@@ M_@@ D@@ P_@@ 10@@ _1 | def kn@@ ap@@ S@@ ack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT return K [ n ] [ W ] NEW_LINE DEDENT
PROGRAM_@@ DECIMAL_@@ OC@@ TAL_@@ CONVERSION | def dec@@ To@@ Oct@@ al ( n ) : NEW_LINE INDENT oct@@ al@@ Num = [ 0 ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT oct@@ al@@ Num [ i ] = n % 8 ; NEW_LINE n = int ( n / 8 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( oct@@ al@@ Num [ j ] , end = " " ) ; NEW_LINE DEDENT DEDENT
SUB@@ SEQU@@ EN@@ CE@@ S@@ _SIZE_@@ THRE@@ E_@@ ARRAY_@@ WHO@@ SE_@@ S@@ UM_@@ DI@@ VISI@@ BLE_@@ M_@@ 1 | def count@@ Sub@@ Seq ( A , N , M ) : NEW_LINE INDENT ans = 0 NEW_LINE h = [ 0 ] * M NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT A [ i ] = A [ i ] % M NEW_LINE h [ A [ i ] ] = h [ A [ i ] ] + 1 NEW_LINE DEDENT for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( i , M ) : NEW_LINE INDENT rem = ( M - ( i + j ) % M ) % M NEW_LINE if ( rem < j ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == j and rem == j ) : NEW_LINE INDENT ans = ans + h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 NEW_LINE DEDENT elif ( i == j ) : NEW_LINE INDENT ans = ans + ( h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ) NEW_LINE DEDENT elif ( i == rem ) : NEW_LINE INDENT ans = ans + h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 NEW_LINE DEDENT elif ( rem == j ) : NEW_LINE INDENT ans = ans + h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + h [ i ] * h [ j ] * h [ rem ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
COUNT_@@ FI@@ BON@@ ACC@@ I_@@ NUMB@@ ERS_@@ GI@@ V@@ EN_@@ RANGE_@@ LOG_@@ TIME | def count@@ Fi@@ bs ( low , high ) : NEW_LINE INDENT f1 , f2 , f3 = 0 , 1 , 1 NEW_LINE result = 0 NEW_LINE while ( f1 <= high ) : NEW_LINE INDENT if ( f1 >= low ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT f1 = f2 NEW_LINE f2 = f3 NEW_LINE f3 = f1 + f2 NEW_LINE DEDENT return result NEW_LINE DEDENT
FIND_@@ WHE@@ THER_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ IS_@@ A_@@ POWER_@@ OF_@@ 4_@@ OR_@@ NOT_@@ 1 | def is@@ PowerOf@@ Four ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and ( not ( n & ( n - 1 ) ) ) ) : NEW_LINE INDENT while ( n > 1 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT
FIN@@ D_S@@ UM_@@ EV@@ EN_@@ FAC@@ TOR@@ S_@@ NUMBER | def su@@ mo@@ f@@ Factors ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 1 NEW_LINE for i in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE curr_@@ sum = 1 NEW_LINE curr_@@ term = 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE n = n // i NEW_LINE if ( i == 2 and count == 1 ) : NEW_LINE INDENT curr_@@ sum = 0 NEW_LINE DEDENT curr_@@ term = curr_@@ term * i NEW_LINE curr_@@ sum = curr_@@ sum + curr_@@ term NEW_LINE DEDENT res = res * curr_@@ sum NEW_LINE DEDENT if ( n >= 2 ) : NEW_LINE INDENT res = res * ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT
FIN@@ D_S@@ UM_@@ NON_@@ REPE@@ ATING_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ ARRAY | def find@@ Sum ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT return sum NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 17@@ _@@ PA@@ LIN@@ DRO@@ ME_@@ PARTI@@ TION@@ ING_@@ 1 | def min@@ Pal@@ Par@@ tion ( str1 ) : NEW_LINE INDENT n = len ( str1 ) ; NEW_LINE C = [ 0 ] * ( n + 1 ) ; NEW_LINE P = [ [ False for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT P [ i ] [ i ] = True ; NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 ; NEW_LINE if ( L == 2 ) : NEW_LINE INDENT P [ i ] [ j ] = ( str1 [ i ] == str1 [ j ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT P [ i ] [ j ] = ( ( str1 [ i ] == str1 [ j ] ) and P [ i + 1 ] [ j - 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( P [ 0 ] [ i ] == True ) : NEW_LINE INDENT C [ i ] = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] = sys . maxsize ; NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( P [ j + 1 ] [ i ] == True and 1 + C [ j ] < C [ i ] ) : NEW_LINE INDENT C [ i ] = 1 + C [ j ] ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return C [ n - 1 ] ; NEW_LINE DEDENT
MINIMUM_@@ POSITIVE_@@ POINT@@ S_TO_@@ REACH_@@ DESTIN@@ ATION | def min@@ Initial@@ Points ( points ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( C + 1 ) ] for y in range ( R + 1 ) ] NEW_LINE m , n = R , C NEW_LINE if points [ m - 1 ] [ n - 1 ] > 0 : NEW_LINE INDENT dp [ m - 1 ] [ n - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ m - 1 ] [ n - 1 ] = abs ( points [ m - 1 ] [ n - 1 ] ) + 1 NEW_LINE DEDENT for i in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) NEW_LINE DEDENT for i in range ( 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ m - 1 ] [ i ] = max ( dp [ m - 1 ] [ i + 1 ] - points [ m - 1 ] [ i ] , 1 ) NEW_LINE DEDENT for i in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT min_@@ points_@@ on_@@ exit = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) NEW_LINE dp [ i ] [ j ] = max ( min_@@ points_@@ on_@@ exit - points [ i ] [ j ] , 1 ) NEW_LINE DEDENT DEDENT return dp [ 0 ] [ 0 ] NEW_LINE DEDENT
COUNT_@@ OF_@@ PAIR@@ S_S@@ ATI@@ SF@@ Y@@ ING_@@ THE_@@ GI@@ V@@ EN_@@ CONDITION | def count@@ Pair ( a , b ) : NEW_LINE INDENT s = str ( b ) NEW_LINE i = 0 NEW_LINE while i < ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != '9' ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT result = 0 NEW_LINE if ( i == len ( s ) ) : NEW_LINE INDENT result = a * len ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT result = a * ( len ( s ) - 1 ) NEW_LINE DEDENT return result NEW_LINE DEDENT
SUR@@ VI@@ VAL | def survi@@ val ( S , N , M ) : NEW_LINE INDENT if ( ( ( N * 6 ) < ( M * 7 ) and S > 6 ) or M > N ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT days = ( M * S ) / N NEW_LINE if ( ( ( M * S ) % N ) != 0 ) : NEW_LINE INDENT days += 1 NEW_LINE DEDENT print ( " Yes ▁ " ) , NEW_LINE print ( days ) NEW_LINE DEDENT DEDENT
INTER@@ LE@@ AVE_@@ FIRST_@@ HALF_@@ QUEUE_@@ SECON@@ D_@@ HALF | def inter@@ Leave@@ Queue ( q ) : NEW_LINE INDENT if ( q . q@@ size ( ) % 2 != 0 ) : NEW_LINE INDENT print ( " Input ▁ even ▁ number ▁ of ▁ integers . " ) NEW_LINE DEDENT s = [ ] NEW_LINE half@@ Size = int ( q . q@@ size ( ) / 2 ) NEW_LINE for i in range ( half@@ Size ) : NEW_LINE INDENT s . append ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT q . put ( s [ - 1 ] ) NEW_LINE s . pop ( ) NEW_LINE DEDENT for i in range ( half@@ Size ) : NEW_LINE INDENT q . put ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT for i in range ( half@@ Size ) : NEW_LINE INDENT s . append ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT q . put ( s [ - 1 ] ) NEW_LINE s . pop ( ) NEW_LINE q . put ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT DEDENT
INTEGER_@@ POSITIVE_@@ VALUE_@@ POSITIVE_@@ NEGATIVE_@@ VALUE_@@ ARRAY_@@ 1 | def find@@ Integer ( arr , n ) : NEW_LINE INDENT neg = 0 NEW_LINE pos = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( arr [ i ] < 0 ) : NEW_LINE INDENT neg += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT DEDENT return ( sum / abs ( neg - pos ) ) NEW_LINE DEDENT
FIN@@ D_S@@ UM_@@ EV@@ EN_@@ INDEX_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENTS | def even@@ Sum ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n + 1 ) ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 ; NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT sum = sum + C [ n ] [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
DE@@ LAN@@ NO@@ Y_@@ NUMBER | def de@@ al@@ n@@ no@@ y ( n , m ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return de@@ al@@ n@@ no@@ y ( m - 1 , n ) + de@@ al@@ n@@ no@@ y ( m - 1 , n - 1 ) + de@@ al@@ n@@ no@@ y ( m , n - 1 ) NEW_LINE DEDENT
FIND_@@ THE_@@ LAR@@ GE@@ ST@@ _SUB@@ ARRAY_@@ WITH_@@ 0@@ _S@@ UM | def maxLen ( arr ) : NEW_LINE INDENT max_len = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT curr_@@ sum = 0 NEW_LINE for j in range ( i , len ( arr ) ) : NEW_LINE INDENT curr_@@ sum += arr [ j ] NEW_LINE if curr_@@ sum == 0 : NEW_LINE INDENT max_len = max ( max_len , j - i + 1 ) NEW_LINE DEDENT DEDENT DEDENT return max_len NEW_LINE DEDENT
NEXT_@@ POWER_@@ OF_@@ 2 | def next@@ PowerOf@@ 2 ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count ; NEW_LINE DEDENT
LON@@ GE@@ ST_@@ GEO@@ METRIC_@@ PROG@@ RES@@ SION | def len@@ Of@@ Lon@@ gest@@ GP ( set@@ t , n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return n NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return ( set@@ t [ 1 ] % set@@ t [ 0 ] == 0 ) NEW_LINE DEDENT set@@ t . sort ( ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE ll@@ gp = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if set@@ t [ n - 1 ] % set@@ t [ i ] == 0 : NEW_LINE INDENT L [ i ] [ n - 1 ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ n - 1 ] = 1 NEW_LINE DEDENT DEDENT for j in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while i >= 0 and k <= n - 1 : NEW_LINE INDENT if set@@ t [ i ] * set@@ t [ k ] < set@@ t [ j ] * set@@ t [ j ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif set@@ t [ i ] * set@@ t [ k ] > set@@ t [ j ] * set@@ t [ j ] : NEW_LINE INDENT if set@@ t [ j ] % set@@ t [ i ] == 0 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = L [ j ] [ k ] + 1 NEW_LINE if L [ i ] [ j ] > ll@@ gp : NEW_LINE INDENT ll@@ gp = L [ i ] [ j ] NEW_LINE DEDENT i -= 1 NEW_LINE k + 1 NEW_LINE DEDENT DEDENT while i >= 0 : NEW_LINE INDENT if set@@ t [ j ] % set@@ t [ i ] == 0 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT return ll@@ gp NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 6_@@ MIN_@@ CO@@ ST_@@ PATH | def min@@ Cost ( cost , m , n ) : NEW_LINE INDENT tc = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] NEW_LINE tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return tc [ m ] [ n ] NEW_LINE DEDENT
PROGRAM_@@ DISTAN@@ CE_@@ TWO_@@ POINT@@ S_@@ EAR@@ TH | def distance ( lat@@ 1 , lat@@ 2 , lon@@ 1 , lon@@ 2 ) : NEW_LINE INDENT lon@@ 1 = radians ( lon@@ 1 ) NEW_LINE lon@@ 2 = radians ( lon@@ 2 ) NEW_LINE lat@@ 1 = radians ( lat@@ 1 ) NEW_LINE lat@@ 2 = radians ( lat@@ 2 ) NEW_LINE dl@@ on = lon@@ 2 - lon@@ 1 NEW_LINE dl@@ at = lat@@ 2 - lat@@ 1 NEW_LINE a = sin ( dl@@ at / 2 ) ** 2 + cos ( lat@@ 1 ) * cos ( lat@@ 2 ) * sin ( dl@@ on / 2 ) ** 2 NEW_LINE c = 2 * asin ( sqrt ( a ) ) NEW_LINE r = 637@@ 1 NEW_LINE return ( c * r ) NEW_LINE DEDENT
B@@ IN_@@ PAC@@ KING_@@ PRO@@ BLE@@ M_@@ MINI@@ MI@@ ZE_@@ NUMBER_OF_@@ USED_@@ BIN@@ S | def next@@ fit ( weight , c ) : NEW_LINE INDENT res = 0 NEW_LINE rem = c NEW_LINE for _ in range ( len ( weight ) ) : NEW_LINE INDENT if rem >= weight [ _ ] : NEW_LINE INDENT rem = rem - weight [ _ ] NEW_LINE DEDENT else : NEW_LINE INDENT res += 1 NEW_LINE rem = c - weight [ _ ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
FIN@@ D@@ _SUB@@ ARRAY_@@ WITH_@@ GI@@ VEN@@ _S@@ UM@@ _1 | def sub@@ Array@@ Sum ( arr , n , sum ) : NEW_LINE INDENT curr_@@ sum = arr [ 0 ] NEW_LINE start = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT while curr_@@ sum > sum and start < i - 1 : NEW_LINE INDENT curr_@@ sum = curr_@@ sum - arr [ start ] NEW_LINE start += 1 NEW_LINE DEDENT if curr_@@ sum == sum : NEW_LINE INDENT print ( " Sum ▁ found ▁ between ▁ indexes " ) NEW_LINE print ( " % d ▁ and ▁ % d " % ( start , i - 1 ) ) NEW_LINE return 1 NEW_LINE DEDENT if i < n : NEW_LINE INDENT curr_@@ sum = curr_@@ sum + arr [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( " No ▁ sub@@ array ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT
SPACE_@@ OPTIMIZ@@ ED_@@ D@@ P_S@@ OL@@ U@@ TION_@@ 0_@@ 1_@@ KN@@ AP@@ S@@ ACK_@@ PRO@@ BLE@@ M_@@ 1 | def K@@ nap@@ S@@ ack ( val , wt , n , W ) : NEW_LINE INDENT dp = [ 0 ] * ( W + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( W , wt [ i ] , - 1 ) : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; NEW_LINE DEDENT DEDENT return dp [ W ] ; NEW_LINE DEDENT
FIND_@@ VALUE_@@ OF_@@ Y_@@ MOD_@@ 2_@@ RAI@@ SED_@@ TO_@@ POWER_@@ X | def y@@ Mod ( y , x ) : NEW_LINE INDENT return ( y % pow ( 2 , x ) ) NEW_LINE DEDENT
SUM@@ _SERI@@ ES_@@ 23@@ _@@ 45@@ _@@ 67@@ _@@ 89@@ _@@ UP@@ TO_@@ N_@@ TER@@ MS | def series@@ Sum ( n ) : NEW_LINE INDENT i = 1 ; NEW_LINE res = 0.0 ; NEW_LINE sign = True ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n - 1 ; NEW_LINE if ( sign ) : NEW_LINE INDENT sign = False ; NEW_LINE res = res + ( i + 1 ) / ( i + 2 ) ; NEW_LINE i = i + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT sign = True ; NEW_LINE res = res - ( i + 1 ) / ( i + 2 ) ; NEW_LINE i = i + 2 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT
LENGTH_@@ LON@@ GE@@ ST_@@ STRICT_@@ BIT@@ ON@@ IC@@ _SUB@@ SEQUENCE | def long@@ Len@@ Strict@@ Bit@@ on@@ ic@@ Sub ( arr , n ) : NEW_LINE INDENT inc , d@@ cr = dict ( ) , dict ( ) NEW_LINE len_@@ inc , len@@ _d@@ cr = [ 0 ] * n , [ 0 ] * n NEW_LINE long@@ Len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len = 0 NEW_LINE if inc . get ( arr [ i ] - 1 ) in inc . values ( ) : NEW_LINE INDENT len = inc . get ( arr [ i ] - 1 ) NEW_LINE DEDENT inc [ arr [ i ] ] = len_@@ inc [ i ] = len + 1 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT len = 0 NEW_LINE if d@@ cr . get ( arr [ i ] - 1 ) in d@@ cr . values ( ) : NEW_LINE INDENT len = d@@ cr . get ( arr [ i ] - 1 ) NEW_LINE DEDENT d@@ cr [ arr [ i ] ] = len@@ _d@@ cr [ i ] = len + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if long@@ Len < ( len_@@ inc [ i ] + len@@ _d@@ cr [ i ] - 1 ) : NEW_LINE INDENT long@@ Len = len_@@ inc [ i ] + len@@ _d@@ cr [ i ] - 1 NEW_LINE DEDENT DEDENT return long@@ Len NEW_LINE DEDENT
MAXIMUM_@@ DISTAN@@ CE_@@ TWO_@@ OC@@ CURR@@ EN@@ CES_@@ ELEMENT_@@ ARRAY | def max@@ Distance ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE max@@ Dict = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] = i NEW_LINE DEDENT else : NEW_LINE INDENT max@@ Dict = max ( max@@ Dict , i - mp [ arr [ i ] ] ) NEW_LINE DEDENT DEDENT return max@@ Dict NEW_LINE DEDENT
FIND_@@ REC@@ TAN@@ GLE_@@ BINARY_@@ MATRIX_@@ COR@@ NE@@ RS_@@ 1_1 | def is@@ Rectangle ( matrix ) : NEW_LINE INDENT rows = len ( matrix ) NEW_LINE if ( rows == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT columns = len ( matrix [ 0 ] ) NEW_LINE table = { } NEW_LINE for i in range ( rows ) : NEW_LINE INDENT for j in range ( columns - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , columns ) : NEW_LINE INDENT if ( matrix [ i ] [ j ] == 1 and matrix [ i ] [ k ] == 1 ) : NEW_LINE INDENT if ( j in table and k in table [ j ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( k in table and j in table [ k ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT if j not in table : NEW_LINE INDENT table [ j ] = set ( ) NEW_LINE DEDENT if k not in table : NEW_LINE INDENT table [ k ] = set ( ) NEW_LINE DEDENT table [ j ] . add ( k ) NEW_LINE table [ k ] . add ( j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
COUNT_@@ MINIMUM_@@ NUMBER@@ _SUB@@ SET@@ S@@ _SUB@@ SEQU@@ EN@@ CES_@@ CON@@ SEC@@ UTI@@ VE_@@ NUMB@@ ERS | def nu@@ mo@@ f@@ subset ( arr , n ) : NEW_LINE INDENT x = sorted ( arr ) NEW_LINE count = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( x [ i ] + 1 != x [ i + 1 ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
LAR@@ GE@@ ST@@ _S@@ UM_@@ CON@@ TI@@ GU@@ OU@@ S@@ _SUB@@ ARRAY | def max@@ Sub@@ Array@@ Sum ( a , size ) : NEW_LINE INDENT max_@@ so@@ _f@@ ar = - maxint - 1 NEW_LINE max_@@ ending_@@ here = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT max_@@ ending_@@ here = max_@@ ending_@@ here + a [ i ] NEW_LINE if ( max_@@ so@@ _f@@ ar < max_@@ ending_@@ here ) : NEW_LINE INDENT max_@@ so@@ _f@@ ar = max_@@ ending_@@ here NEW_LINE DEDENT if max_@@ ending_@@ here < 0 : NEW_LINE INDENT max_@@ ending_@@ here = 0 NEW_LINE DEDENT DEDENT return max_@@ so@@ _f@@ ar NEW_LINE DEDENT
PROGRAM_@@ TO_@@ FIND_@@ RE@@ MA@@ INDE@@ R_@@ WITH@@ OUT_@@ USING_@@ MODUL@@ O_@@ OR_@@ OPERATOR_@@ 2 | def getRe@@ main@@ der ( num , divisor ) : NEW_LINE INDENT while ( num >= divisor ) : NEW_LINE INDENT num -= divisor ; NEW_LINE DEDENT return num ; NEW_LINE DEDENT
CHECK_@@ LARGE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 4_@@ NOT | def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( ( st [ 0 ] - '0' ) % 4 == 0 ) NEW_LINE DEDENT last = ( int ) ( st [ n - 1 ] ) NEW_LINE second_@@ last = ( int ) ( st [ n - 2 ] ) NEW_LINE return ( ( second_@@ last * 10 + last ) % 4 == 0 ) NEW_LINE DEDENT
FIND_@@ THE_@@ ELEMENT_@@ TH@@ AT_@@ AP@@ PE@@ AR@@ S_@@ ON@@ CE_@@ 1 | def get@@ Single ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , INT_@@ SIZE ) : NEW_LINE INDENT sm = 0 NEW_LINE x = ( 1 << i ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] & x ) : NEW_LINE INDENT sm = sm + 1 NEW_LINE DEDENT DEDENT if ( sm % 3 ) : NEW_LINE INDENT result = result | x NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
NUMBER_@@ REC@@ TA@@ NG@@ LES_@@ NM_@@ GRID | def rect@@ Count ( n , m ) : NEW_LINE INDENT return ( m * n * ( n + 1 ) * ( m + 1 ) ) // 4 NEW_LINE DEDENT
MAXIMUM_@@ POINT@@ S_@@ INTER@@ SECTION_@@ N_@@ CIRC@@ LES | def intersection ( n ) : NEW_LINE INDENT return n * ( n - 1 ) ; NEW_LINE DEDENT
