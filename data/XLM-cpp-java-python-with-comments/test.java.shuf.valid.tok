PRINT_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ GI@@ V@@ EN_@@ INTEGER_@@ ARRAY_@@ 2 | static void print@@ Distin@@ ct ( int arr [ ] ) { HashSet < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( ! set . contains ( arr [ i ] ) ) { set . add ( arr [ i ] ) ; System . out . print ( arr [ i ] + " ▁ " ) ; } } }
CHECK_@@ RO@@ WS_@@ MATRIX_@@ CIRC@@ ULAR_@@ ROTA@@ TIONS | static boolean is@@ Per@@ mu@@ ted@@ Matrix ( int mat [ ] [ ] , int n ) { String str_@@ cat = " " ; for ( int i = 0 ; i < n ; i ++ ) { str_@@ cat = str_@@ cat + " - " + String . valueOf ( mat [ 0 ] [ i ] ) ; } str_@@ cat = str_@@ cat + str_@@ cat ; for ( int i = 1 ; i < n ; i ++ ) { String curr_@@ str = " " ; for ( int j = 0 ; j < n ; j ++ ) { curr_@@ str = curr_@@ str + " - " + String . valueOf ( mat [ i ] [ j ] ) ; } if ( str_@@ cat . content@@ Equals ( curr_@@ str ) ) { return false ; } } return true ; }
S@@ UM_@@ PAIR@@ WI@@ SE_@@ PRODUC@@ TS | static int find@@ Sum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; }
SORT_@@ 3_@@ INTEG@@ ERS_@@ WITH@@ OUT_@@ USING_@@ CONDITION_@@ USING_@@ MAX_@@ FUNCTION | static void print@@ Sorted ( int a , int b , int c ) { int get_@@ max = Math . max ( a , Math . max ( b , c ) ) ; int get_@@ min = - Math . max ( - a , Math . max ( - b , - c ) ) ; int get_@@ mid = ( a + b + c ) - ( get_@@ max + get_@@ min ) ; System . out . print ( get_@@ min + " ▁ " + get_@@ mid + " ▁ " + get_@@ max ) ; }
PROGRAM_@@ FOR_@@ FAC@@ TOR@@ I@@ AL_@@ OF_@@ A_@@ NUMBER_@@ 2 | int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
FIND_@@ INDEX_@@ OF_@@ AN_@@ EXTRA_@@ ELEMENT_@@ PRES@@ ENT_@@ IN_@@ ONE@@ _S@@ OR@@ TED_@@ ARRAY_@@ 2 | static int find_@@ extra_@@ element@@ _index ( int [ ] arr@@ A , int [ ] arr@@ B ) { int extra_@@ element = sum ( arr@@ A ) - sum ( arr@@ B ) ; return indexOf ( arr@@ A , extra_@@ element ) ; }
SUB@@ ARRAY@@ SUB@@ STRING_@@ VS@@ _SUB@@ SEQU@@ ENCE_@@ AND_@@ PROGR@@ AM@@ S_TO_@@ GENERATE_@@ THE@@ M_@@ 1 | static void print@@ Sub@@ sequences ( int n ) { int op@@ size = ( int ) Math . pow ( 2 , n ) ; for ( int counter = 1 ; counter < op@@ size ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( BigInteger . valueOf ( counter ) . test@@ Bit ( j ) ) System . out . print ( arr [ j ] + " ▁ " ) ; } System . out . println ( ) ; } }
N_@@ BON@@ ACC@@ I_@@ NUMB@@ ERS | static void bon@@ ac@@ ci@@ series ( int n , int m ) { int [ ] a = new int [ m ] ; a [ n - 1 ] = 1 ; for ( int i = n ; i < m ; i ++ ) for ( int j = i - n ; j < i ; j ++ ) a [ i ] += a [ j ] ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; }
LOWER_@@ CASE_@@ UPPER_@@ CASE_@@ INTER@@ EST@@ ING_@@ FAC@@ T | static String to_@@ upper ( char [ ] in ) { for ( int i = 0 ; i < in . length ; i ++ ) { if ( ' a ' <= in [ i ] & in [ i ] <= ' z ' ) { in [ i ] = ( char ) ( in [ i ] - ' a ' + ' A ' ) ; } } return String . valueOf ( in ) ; }
PRINT_@@ BRAC@@ KET_@@ NUMBER | static void print@@ Bracket@@ Number ( String exp , int n ) { int left_@@ b@@ num = 1 ; Stack < Integer > right_@@ b@@ num = new Stack < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( exp . charAt ( i ) == ' ( ' ) { System . out . print ( left_@@ b@@ num + " ▁ " ) ; right_@@ b@@ num . push ( left_@@ b@@ num ) ; left_@@ b@@ num ++ ; } else if ( exp . charAt ( i ) == ' ) ' ) { System . out . print ( right_@@ b@@ num . peek ( ) + " ▁ " ) ; right_@@ b@@ num . pop ( ) ; } } }
MAXIMUM_@@ PRODUCT_@@ OF_@@ 4_@@ AD@@ J@@ AC@@ ENT_@@ ELEMEN@@ TS_@@ IN_@@ MATRIX | static int Find@@ Max@@ Product ( int arr [ ] [ ] , int n ) { int max = 0 , result ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ; if ( max < result ) max = result ; } } } return max ; }
LON@@ GE@@ ST@@ _SUB@@ ARRA@@ Y_S@@ UM_@@ DI@@ VISI@@ BLE_@@ K | static int long@@ Sub@@ arr@@ W@@ th@@ Sum@@ Div@@ By@@ K ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int mod_@@ arr [ ] = new int [ n ] ; int max = 0 ; int curr_@@ sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_@@ sum += arr [ i ] ; mod_@@ arr [ i ] = ( ( curr_@@ sum % k ) + k ) % k ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mod_@@ arr [ i ] == 0 ) max = i + 1 ; else if ( um . containsKey ( mod_@@ arr [ i ] ) == false ) um . put ( mod_@@ arr [ i ] , i ) ; else if ( max < ( i - um . get ( mod_@@ arr [ i ] ) ) ) max = i - um . get ( mod_@@ arr [ i ] ) ; } return max ; }
CA@@ ES@@ AR_@@ CIPH@@ ER | public static StringBuffer encrypt ( String text , int s ) { StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { if ( Character . is@@ UpperCase ( text . charAt ( i ) ) ) { char ch = ( char ) ( ( ( int ) text . charAt ( i ) + s - 65 ) % 26 + 65 ) ; result . append ( ch ) ; } else { char ch = ( char ) ( ( ( int ) text . charAt ( i ) + s - 97 ) % 26 + 97 ) ; result . append ( ch ) ; } } return result ; }
SUB@@ ARRAY@@ S_@@ DISTIN@@ CT_@@ ELEMENTS | public static int su@@ mo@@ f@@ length ( int [ ] arr , int n ) { Set < Integer > s = new HashSet < > ( ) ; int j = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && ! s . contains ( arr [ j ] ) ) { s . add ( arr [ i ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . remove ( arr [ i ] ) ; } return ans ; }
K_@@ TH_@@ ELEMENT_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S | static int k@@ th ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int m , int n , int k ) { int [ ] sorted@@ 1 = new int [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( ar@@ r1 [ i ] < ar@@ r2 [ j ] ) sorted@@ 1 [ d ++ ] = ar@@ r1 [ i ++ ] ; else sorted@@ 1 [ d ++ ] = ar@@ r2 [ j ++ ] ; } while ( i < m ) sorted@@ 1 [ d ++ ] = ar@@ r1 [ i ++ ] ; while ( j < n ) sorted@@ 1 [ d ++ ] = ar@@ r2 [ j ++ ] ; return sorted@@ 1 [ k - 1 ] ; }
REMOVE_@@ CON@@ SEC@@ UTI@@ VE_@@ DUPLIC@@ ATE@@ S_@@ STRING | static void remove@@ Duplicates ( char [ ] S ) { int n = S . length ; if ( n < 2 ) { return ; } int j = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( S [ j ] != S [ i ] ) { j ++ ; S [ j ] = S [ i ] ; } } System . out . println ( Arrays . copy@@ Of@@ Range ( S , 0 , j + 1 ) ) ; }
MAJ@@ ORI@@ TY_@@ ELEMENT | static void find@@ Maj@@ ority ( int arr [ ] , int n ) { int maxCount = 0 ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) System . out . println ( arr [ index ] ) ; else System . out . println ( " No ▁ Maj@@ ority ▁ Element " ) ; }
FUNCTION_@@ COPY_@@ STRING_@@ ITER@@ ATI@@ VE_@@ RECUR@@ SIVE_@@ 1 | static void my@@ Copy ( char s1 [ ] , char s2 [ ] , int index ) { s2 [ index ] = s1 [ index ] ; if ( index == s1 . length - 1 ) { return ; } my@@ Copy ( s1 , s2 , index + 1 ) ; }
COUNT_@@ NUMBER_OF_@@ WAY@@ S_TO_@@ CO@@ VER_@@ A_@@ DISTAN@@ CE_@@ 1 | static int print@@ Count@@ DP ( int dist ) { int [ ] count = new int [ dist + 1 ] ; count [ 0 ] = 1 ; count [ 1 ] = 1 ; count [ 2 ] = 2 ; for ( int i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }
DISC@@ RE@@ TE_@@ LOG@@ ARI@@ TH@@ M_@@ FIND_@@ INTEGER_@@ K_@@ A@@ K_@@ CON@@ GR@@ U@@ ENT_@@ MODUL@@ O_@@ B | static int discre@@ te@@ Log@@ arith@@ m ( int a , int b , int m ) { int n = ( int ) ( Math . sqrt ( m ) + 1 ) ; int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * a ) % m ; int [ ] value = new int [ m ] ; for ( int i = 1 , cur = an ; i <= n ; ++ i ) { if ( value [ cur ] == 0 ) value [ cur ] = i ; cur = ( cur * an ) % m ; } for ( int i = 0 , cur = b ; i <= n ; ++ i ) { if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return - 1 ; }
CHANGE_@@ BITS_@@ CAN_@@ MA@@ DE_@@ ONE_@@ FLI@@ P_@@ 1 | static boolean is@@ One@@ Flip ( String str ) { int sum = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) sum += str . charAt ( i ) - '0' ; return ( sum == n - 1 || sum == 1 ) ; }
FIND_@@ PAIR@@ S_IN_@@ ARRAY_@@ WHO@@ SE_@@ SUM@@ S_@@ ALREADY_@@ EXI@@ ST_@@ IN_@@ ARRAY | static void find@@ Pair ( int [ ] arr , int n ) { boolean found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { System . out . println ( arr [ i ] + " ▁ " + arr [ j ] ) ; found = true ; } } } } if ( found == false ) System . out . println ( " Not ▁ exist " ) ; }
MODUL@@ AR_@@ MULTIP@@ LIC@@ ATI@@ VE_@@ INVER@@ SE_@@ 1_@@ N | static void mod@@ ular@@ Inverse ( int n , int prime ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ prime % i ] * ( prime - prime / i ) % prime ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( dp [ i ] + " ▁ " ) ; }
SHUFF@@ LE_@@ 2@@ N_@@ INTEG@@ ERS_@@ FORMAT_@@ A@@ 1_@@ B@@ 1_@@ A@@ 2_@@ B@@ 2_@@ A@@ 3_@@ B@@ 3_@@ BN_@@ WITH@@ OUT_@@ USING_@@ EX@@ TRA@@ _SPACE_@@ 1 | static void shu@@ fle@@ Array ( int a [ ] , int f , int l ) { if ( l > f ) return ; if ( l - f == 1 ) return ; int mid = ( f + l ) / 2 ; int temp = mid + 1 ; int mm@@ id = ( f + mid ) / 2 ; for ( int i = mm@@ id + 1 ; i <= mid ; i ++ ) { int temp1 = a [ i ] ; a [ i ] = a [ temp ] ; a [ temp ++ ] = temp1 ; } shu@@ fle@@ Array ( a , f , mid ) ; shu@@ fle@@ Array ( a , mid + 1 , l ) ; }
N_@@ TH_@@ ROOT_@@ NUMBER | static double n@@ th@@ Root ( int A , int N ) { double x@@ Pre = Math . random ( ) % 10 ; double eps = 0.001 ; double del@@ X = 2147483647 ; double x@@ K = 0.0 ; while ( del@@ X > eps ) { x@@ K = ( ( N - 1.0 ) * x@@ Pre + ( double ) A / Math . pow ( x@@ Pre , N - 1 ) ) / ( double ) N ; del@@ X = Math . abs ( x@@ K - x@@ Pre ) ; x@@ Pre = x@@ K ; } return x@@ K ; }
NUMBER_OF_@@ WAY@@ S_TO_@@ AR@@ RANGE_@@ N_@@ ITE@@ MS_@@ UN@@ DER_@@ GI@@ V@@ EN_@@ CONSTRA@@ INTS | static int way@@ sTo@@ Ar@@ range ( int N , int K , int [ ] k ) { int [ ] [ ] C = new int [ N + 1 ] [ N + 1 ] ; int i , j ; for ( i = 0 ; i <= N ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) { C [ i ] [ j ] = 1 ; } else { C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } } int [ ] dp = new int [ K + 1 ] ; int count = 0 ; dp [ 0 ] = 1 ; for ( i = 0 ; i < K ; i ++ ) { dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) ; count += k [ i ] ; } return dp [ K ] ; }
TEMP@@ LE_@@ OFF@@ ER@@ INGS | static int offer@@ ing@@ Number ( int n , int temp@@ le@@ Height [ ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int left = 0 , right = 0 ; for ( int j = i - 1 ; j >= 0 ; -- j ) { if ( temp@@ le@@ Height [ j ] < temp@@ le@@ Height [ j + 1 ] ) ++ left ; else break ; } for ( int j = i + 1 ; j < n ; ++ j ) { if ( temp@@ le@@ Height [ j ] < temp@@ le@@ Height [ j - 1 ] ) ++ right ; else break ; } sum += Math . max ( right , left ) + 1 ; } return sum ; }
CENTER_@@ ELEMENT_@@ OF_@@ MATRIX_@@ EQUAL@@ S_S@@ UM@@ S_@@ OF_@@ HALF_@@ DIAG@@ ON@@ ALS | static boolean Half@@ Diag@@ onal@@ Sum@@ s ( int mat [ ] [ ] , int n ) { int diag@@ 1_@@ left = 0 , diag@@ 1_@@ right = 0 ; int diag@@ 2_@@ left = 0 , diag@@ 2_@@ right = 0 ; for ( int i = 0 , j = n - 1 ; i < n ; i ++ , j -- ) { if ( i < n / 2 ) { diag@@ 1_@@ left += mat [ i ] [ i ] ; diag@@ 2_@@ left += mat [ j ] [ i ] ; } else if ( i > n / 2 ) { diag@@ 1_@@ right += mat [ i ] [ i ] ; diag@@ 2_@@ right += mat [ j ] [ i ] ; } } return ( diag@@ 1_@@ left == diag@@ 2_@@ right && diag@@ 2_@@ right == diag@@ 2_@@ left && diag@@ 1_@@ right == diag@@ 2_@@ left && diag@@ 2_@@ right == mat [ n / 2 ] [ n / 2 ] ) ; }
COUNT_@@ FAC@@ TOR@@ I@@ AL_@@ NUMB@@ ERS_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ RANGE | static int count@@ Fact ( int low , int high ) { int fact = 1 , x = 1 ; while ( fact < low ) { fact = fact * x ; x ++ ; } int res = 0 ; while ( fact <= high ) { res ++ ; fact = fact * x ; x ++ ; } return res ; }
PROGRAM_@@ REVERSE_@@ STRING_@@ ITER@@ ATI@@ VE_@@ RECUR@@ SIVE_@@ 1 | static void reverse@@ Str ( String str ) { int n = str . length ( ) ; char [ ] ch = str . toCharArray ( ) ; char temp ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { temp = ch [ i ] ; ch [ i ] = ch [ j ] ; ch [ j ] = temp ; } System . out . println ( ch ) ; }
FIND_@@ MINIMUM_@@ AD@@ JU@@ ST@@ MENT_@@ CO@@ ST_@@ OF_@@ AN_@@ ARRAY | static int min@@ Adjustment@@ Cost ( int A [ ] , int n , int target ) { int [ ] [ ] dp = new int [ n ] [ M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = Integer . MAX_VALUE ; int k = Math . max ( j - target , 0 ) ; for ( ; k <= Math . min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } } int res = Integer . MAX_VALUE ; for ( int j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; }
COUNT_@@ FREQU@@ ENCY_@@ K_@@ MATRI@@ X@@ _SIZE_@@ N_@@ MATRI@@ X@@ I_@@ J_@@ I@@ J | public static int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
MINIMUM_@@ FLI@@ P_@@ REQUIRED_@@ MAKE_@@ BINARY_@@ MATRIX_@@ SYM@@ METRIC_@@ 1 | static int minimum@@ flip ( int mat [ ] [ ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }
N@@ TH_@@ PA@@ LIN@@ DRO@@ ME_@@ K_@@ DIGITS | static void n@@ th@@ Pal@@ ind@@ ro@@ me ( int n , int k ) { int temp = ( k & 1 ) != 0 ? ( k / 2 ) : ( k / 2 - 1 ) ; int pal@@ ind@@ ro@@ me = ( int ) Math . pow ( 10 , temp ) ; pal@@ ind@@ ro@@ me += n - 1 ; System . out . print ( pal@@ ind@@ ro@@ me ) ; if ( ( k & 1 ) > 0 ) pal@@ ind@@ ro@@ me /= 10 ; while ( pal@@ ind@@ ro@@ me > 0 ) { System . out . print ( pal@@ ind@@ ro@@ me % 10 ) ; pal@@ ind@@ ro@@ me /= 10 ; } System . out . println ( " " ) ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 3_@@ LON@@ GE@@ ST_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQU@@ ENCE_@@ 1 | static int lis ( int arr [ ] , int n ) { int lis [ ] = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return max ; }
PATH_@@ MAXIMUM_@@ AVER@@ AGE_@@ VALUE | public static double max@@ Average@@ Of@@ Path ( int cost [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N + 1 ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
PROGRAM_@@ COUNT_@@ OC@@ CURR@@ ENCE_@@ GI@@ V@@ EN_@@ CHARACTER_@@ STRING | public static int count ( String s , char c ) { int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == c ) res ++ ; } return res ; }
K@@ TH@@ _S@@ MAL@@ LE@@ ST@@ LAR@@ GE@@ ST_@@ ELEMENT_@@ UN@@ SOR@@ TED_@@ ARRAY | public static int k@@ th@@ S@@ malle@@ st ( Integer [ ] arr , int k ) { Arrays . sort ( arr ) ; return arr [ k - 1 ] ; }
CONVERT_@@ ALTER@@ N@@ ATE_@@ CHARAC@@ TER@@ S_@@ STRING_@@ UPPER_@@ CASE | static void convert@@ Op@@ posi@@ te ( StringBuffer str ) { int ln = str . length ( ) ; for ( int i = 0 ; i < ln ; i ++ ) { Character c = str . charAt ( i ) ; if ( Character . is@@ LowerCase ( c ) ) str . replace ( i , i + 1 , Character . toUpperCase ( c ) + " " ) ; else str . replace ( i , i + 1 , Character . toLowerCase ( c ) + " " ) ; } }
SUM@@ _SERI@@ ES_@@ 5555@@ 55@@ _@@ N_@@ TER@@ MS | static int sum@@ Of@@ Series ( int n ) { return ( int ) ( 0.6@@ 172 * ( Math . pow ( 10 , n ) - 1 ) - 0.5@@ 5 * n ) ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 8_@@ MATRIX_@@ CHAIN_@@ MULTIP@@ LIC@@ ATION | static int Matrix@@ Chain@@ Order ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int min = Integer . MAX_VALUE ; for ( int k = i ; k < j ; k ++ ) { int count = Matrix@@ Chain@@ Order ( p , i , k ) + Matrix@@ Chain@@ Order ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }
COUNT_@@ SET_@@ BITS_@@ IN_@@ AN_@@ INTEGER_@@ 3 | public static int count@@ Set@@ Bits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + count@@ Set@@ Bits ( n & ( n - 1 ) ) ; }
MINIMUM_@@ LENGTH_@@ UN@@ SOR@@ TED@@ _SUB@@ ARRA@@ Y_S@@ OR@@ TING_@@ WHI@@ CH_@@ MAKE@@ S_@@ THE_@@ COMPLETE_@@ ARRA@@ Y_S@@ OR@@ TED | static void print@@ Un@@ sorted ( int arr [ ] , int n ) { int s = 0 , e = n - 1 , i , max , min ; for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; } if ( s == n - 1 ) { System . out . println ( " The ▁ complete ▁ array ▁ is ▁ sorted " ) ; return ; } for ( e = n - 1 ; e > 0 ; e -- ) { if ( arr [ e ] < arr [ e - 1 ] ) break ; } max = arr [ s ] ; min = arr [ s ] ; for ( i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } for ( i = 0 ; i < s ; i ++ ) { if ( arr [ i ] > min ) { s = i ; break ; } } for ( i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } } System . out . println ( " ▁ The ▁ un@@ sorted ▁ sub@@ array ▁ which " + " ▁ makes ▁ the ▁ given ▁ array ▁ sorted ▁ lies " + " ▁ ▁ between ▁ the ▁ indices ▁ " + s + " ▁ and ▁ " + e ) ; return ; }
STE@@ INS_@@ ALGORITH@@ M_@@ FOR_@@ FIN@@ DING_@@ GC@@ D | static int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; int k ; for ( k = 0 ; ( ( a | b ) & 1 ) == 0 ; ++ k ) { a >>= 1 ; b >>= 1 ; } while ( ( a & 1 ) == 0 ) a >>= 1 ; do { while ( ( b & 1 ) == 0 ) b >>= 1 ; if ( a > b ) { int temp = a ; a = b ; b = temp ; } b = ( b - a ) ; } while ( b != 0 ) ; return a << k ; }
HEX@@ AG@@ ON@@ AL_@@ NUMBER | int hex@@ ag@@ onal@@ Num ( int n ) { return n * ( 2 * n - 1 ) ; }
GOO@@ GLE_@@ CASE_@@ GI@@ VEN@@ _S@@ ENT@@ ENCE | static String convert ( String s ) { int n = s . length ( ) ; String s1 = " " ; s1 = s1 + Character . toLowerCase ( s . charAt ( 0 ) ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ▁ ' && i < n ) { s1 = s1 + " ▁ " + Character . toLowerCase ( s . charAt ( i + 1 ) ) ; i ++ ; } else s1 = s1 + Character . toUpperCase ( s . charAt ( i ) ) ; } return s1 ; }
FIND_@@ A_@@ ROTATION_@@ WITH_@@ MAXIMUM_@@ HAM@@ M@@ ING_@@ DISTANCE | static int max@@ Ham@@ ming ( int arr [ ] , int n ) { int br@@ r [ ] = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) br@@ r [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) br@@ r [ n + i ] = arr [ i ] ; int max@@ H@@ am = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int curr@@ H@@ am = 0 ; for ( int j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( br@@ r [ j ] != arr [ k ] ) curr@@ H@@ am ++ ; if ( curr@@ H@@ am == n ) return n ; max@@ H@@ am = Math . max ( max@@ H@@ am , curr@@ H@@ am ) ; } return max@@ H@@ am ; }
GI@@ V@@ EN_@@ A_@@ NUMBER_@@ N_@@ GENERATE_@@ BIT_@@ PATTER@@ NS_@@ FROM_@@ 0_@@ TO_@@ 2@@ N_@@ 1@@ _S@@ O_@@ TH@@ AT_@@ SUCCE@@ SSI@@ VE_@@ PATTER@@ NS_@@ DIFF@@ ER_@@ BY_@@ ONE_@@ BIT | static void generate@@ Gray@@ arr ( int n ) { if ( n <= 0 ) return ; ArrayList < String > arr = new ArrayList < String > ( ) ; arr . add ( "0" ) ; arr . add ( "1" ) ; int i , j ; for ( i = 2 ; i < ( 1 << n ) ; i = i << 1 ) { for ( j = i - 1 ; j >= 0 ; j -- ) arr . add ( arr . get ( j ) ) ; for ( j = 0 ; j < i ; j ++ ) arr . set ( j , "0" + arr . get ( j ) ) ; for ( j = i ; j < 2 * i ; j ++ ) arr . set ( j , "1" + arr . get ( j ) ) ; } for ( i = 0 ; i < arr . size ( ) ; i ++ ) System . out . println ( arr . get ( i ) ) ; }
MIN@@ IM@@ UM@@ _SW@@ AP@@ S_@@ REQUIRED_@@ BR@@ ING_@@ ELEMEN@@ TS_@@ LESS_@@ EQUAL_@@ K_@@ TO@@ GE@@ THER | static int min@@ Swap ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] <= k ) ++ count ; int bad = 0 ; for ( int i = 0 ; i < count ; ++ i ) if ( arr [ i ] > k ) ++ bad ; int ans = bad ; for ( int i = 0 , j = count ; j < n ; ++ i , ++ j ) { if ( arr [ i ] > k ) -- bad ; if ( arr [ j ] > k ) ++ bad ; ans = Math . min ( ans , bad ) ; } return ans ; }
FIND_@@ N@@ TH_@@ FI@@ BON@@ ACC@@ I_@@ NUMBER_@@ USING_@@ GO@@ LD@@ EN_@@ RATIO | static int fi@@ b ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 ; int fn = 5 ; while ( t < n ) { fn = ( int ) Math . round ( fn * PHI ) ; t ++ ; } return fn ; }
SOR@@ TING_@@ ARRAY_@@ REVERSE_@@ AR@@ OUND_@@ MIDDLE | static boolean if@@ Possible ( int arr [ ] , int n ) { int copy [ ] = Arrays . copyOf ( arr , arr . length ) ; Arrays . sort ( copy ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == copy [ i ] ) && ! ( arr [ n - 1 - i ] == copy [ i ] ) ) return false ; } return true ; }
COUNT_@@ ROTA@@ TIONS_@@ DI@@ VISI@@ BLE_@@ 4 | static int count@@ Rot@@ ations ( String n ) { int len = n . length ( ) ; if ( len == 1 ) { int one@@ Digit = n . charAt ( 0 ) - '0' ; if ( one@@ Digit % 4 == 0 ) return 1 ; return 0 ; } int two@@ Digit , count = 0 ; for ( int i = 0 ; i < ( len - 1 ) ; i ++ ) { two@@ Digit = ( n . charAt ( i ) - '0' ) * 10 + ( n . charAt ( i + 1 ) - '0' ) ; if ( two@@ Digit % 4 == 0 ) count ++ ; } two@@ Digit = ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( two@@ Digit % 4 == 0 ) count ++ ; return count ; }
N_@@ TH_@@ NUMBER_@@ WHO@@ SE_@@ S@@ UM_@@ OF_@@ DIG@@ IT@@ S_@@ IS_@@ T@@ EN_@@ 2 | public static int find@@ N@@ th ( int n ) { int n@@ th@@ Element = 19 + ( n - 1 ) * 9 ; int out@@ lier@@ sCount = ( int ) Math . log10 ( n@@ th@@ Element ) - 1 ; n@@ th@@ Element += 9 * out@@ lier@@ sCount ; return n@@ th@@ Element ; }
PRI@@ MALI@@ TY_@@ TEST@@ _SET_@@ 1_@@ INTRO@@ DUC@@ TION_@@ AND@@ _S@@ CHOOL_@@ METHOD_@@ 1 | static boolean is@@ Prime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
MINIMUM_@@ NUMBER@@ _SUB@@ SE@@ TS_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ 1 | static int subset ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; int res = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) res = Math . max ( res , entry . getValue ( ) ) ; return res ; }
RE@@ CAM@@ AN@@ S@@ _SEQU@@ ENCE_@@ 1 | static void rec@@ am@@ an ( int n ) { if ( n <= 0 ) return ; System . out . printf ( " % d , ▁ " , 0 ) ; HashSet < Integer > s = new HashSet < Integer > ( ) ; s . add ( 0 ) ; int prev = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int curr = prev - i ; if ( curr < 0 || s . contains ( curr ) ) curr = prev + i ; s . add ( curr ) ; System . out . printf ( " % d , ▁ " , curr ) ; prev = curr ; } }
GENERATE_@@ ROTA@@ TIONS_@@ GI@@ V@@ EN_@@ STRING_@@ 1 | static void print@@ Rot@@ ated@@ String ( String str ) { int n = str . length ( ) ; StringBuffer sb = new StringBuffer ( str ) ; sb . append ( str ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j != n ; j ++ ) System . out . print ( sb . charAt ( i + j ) ) ; System . out . println ( ) ; } }
FIT@@ T@@ ING@@ _SH@@ EL@@ VE@@ S_@@ PRO@@ BLE@@ M | static void min@@ Space@@ Pre@@ fer@@ Large ( int wall , int m , int n ) { int num_@@ m = 0 , num_@@ n = 0 , min_@@ empty = wall ; int p = 0 , q = 0 , rem ; while ( wall >= n ) { p = wall / m ; rem = wall % m ; if ( rem <= min_@@ empty ) { num_@@ m = p ; num_@@ n = q ; min_@@ empty = rem ; } q += 1 ; wall = wall - n ; } System . out . println ( num_@@ m + " ▁ " + num_@@ n + " ▁ " + min_@@ empty ) ; }
COUNT_@@ STRING@@ S_@@ CAN_@@ FOR@@ MED_@@ USING_@@ B_@@ C_@@ GI@@ V@@ EN_@@ CONSTRA@@ INT@@ S_@@ 1 | static int count@@ Str ( int n ) { return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) ; }
DI@@ VISIBILITY_@@ BY_@@ 12_@@ FOR_@@ A_@@ LARGE_@@ NUMBER | static boolean is@@ D@@ visible@@ By@@ 12 ( String num ) { if ( num . length ( ) >= 3 ) { int d1 = ( int ) num . charAt ( num . length ( ) - 1 ) ; if ( d1 % 2 != 0 ) return false ; int d2 = ( int ) num . charAt ( num . length ( ) - 2 ) ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num . charAt ( i ) ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = Integer . parseInt ( num ) ; return ( number % 12 == 0 ) ; } }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 36@@ _@@ CU@@ T_@@ A_@@ RO@@ PE_@@ TO_@@ MAXI@@ MI@@ ZE_@@ PRODUCT_@@ 1 | static int max@@ Prod ( int n ) { if ( n == 2 || n == 3 ) return ( n - 1 ) ; int res = 1 ; while ( n > 4 ) { n -= 3 ; res *= 3 ; } return ( n * res ) ; }
RETURN_@@ A_@@ PA@@ IR_@@ WITH_@@ MAXIMUM_@@ PRODUCT_@@ IN_@@ ARRAY_@@ OF_@@ INTEG@@ ERS | static void max@@ Product ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . println ( " No ▁ pairs ▁ exists " ) ; return ; } int a = arr [ 0 ] , b = arr [ 1 ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] > a * b ) { a = arr [ i ] ; b = arr [ j ] ; } System . out . println ( " Max ▁ product ▁ pair ▁ is ▁ { " + a + " , ▁ " + b + " } " ) ; }
S@@ UM_@@ MATRIX_@@ ELEMENT_@@ ABSOL@@ UTE_@@ DIFF@@ ER@@ ENCE_@@ ROW_@@ COLUMN_@@ NUMB@@ ERS_@@ 2 | static int find@@ Sum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
PRINT_@@ MATRIX_@@ ANTI@@ SPIR@@ AL_@@ FORM | public static void anti@@ Sp@@ ir@@ al@@ Traversal ( int m , int n , int a [ ] [ ] ) { int i , k = 0 , l = 0 ; Stack < Integer > stk = new Stack < Integer > ( ) ; while ( k <= m && l <= n ) { for ( i = l ; i <= n ; ++ i ) stk . push ( a [ k ] [ i ] ) ; k ++ ; for ( i = k ; i <= m ; ++ i ) stk . push ( a [ i ] [ n ] ) ; n -- ; if ( k <= m ) { for ( i = n ; i >= l ; -- i ) stk . push ( a [ m ] [ i ] ) ; m -- ; } if ( l <= n ) { for ( i = m ; i >= k ; -- i ) stk . push ( a [ i ] [ l ] ) ; l ++ ; } } while ( ! stk . empty ( ) ) { System . out . print ( stk . peek ( ) + " ▁ " ) ; stk . pop ( ) ; } }
DI@@ CE_@@ THROW_@@ PRO@@ BLE@@ M_@@ 1 | public static long find@@ W@@ ays ( int f , int d , int s ) { long mem [ ] [ ] = new long [ d + 1 ] [ s + 1 ] ; mem [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= d ; i ++ ) { for ( int j = i ; j <= s ; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ; if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ; } } return mem [ d ] [ s ] ; }
WRITE_@@ A_@@ C_@@ PROGRAM_@@ TO_@@ CAL@@ CUL@@ ATE_@@ PO@@ WX@@ N | static int power ( int x , int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; }
SM@@ ALLE@@ ST_@@ WINDOW_@@ CONTAIN@@ S_@@ CHARAC@@ TER@@ S_@@ STRING | static String find@@ Sub@@ String ( String str ) { int n = str . length ( ) ; int dist@@ _count = 0 ; boolean [ ] visited = new boolean [ MAX_@@ CHARS ] ; Arrays . fill ( visited , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ str . charAt ( i ) ] == false ) { visited [ str . charAt ( i ) ] = true ; dist@@ _count ++ ; } } int start = 0 , start_index = - 1 ; int min_@@ len = Integer . MAX_VALUE ; int count = 0 ; int [ ] curr_@@ count = new int [ MAX_@@ CHARS ] ; for ( int j = 0 ; j < n ; j ++ ) { curr_@@ count [ str . charAt ( j ) ] ++ ; if ( curr_@@ count [ str . charAt ( j ) ] == 1 ) count ++ ; if ( count == dist@@ _count ) { while ( curr_@@ count [ str . charAt ( start ) ] > 1 ) { if ( curr_@@ count [ str . charAt ( start ) ] > 1 ) curr_@@ count [ str . charAt ( start ) ] -- ; start ++ ; } int len_@@ window = j - start + 1 ; if ( min_@@ len > len_@@ window ) { min_@@ len = len_@@ window ; start_index = start ; } } } return str . substring ( start_index , start_index + min_@@ len ) ; }
CLU@@ STER@@ ING@@ PARTI@@ TION@@ ING_@@ AN_@@ ARRAY@@ _SU@@ CH_@@ TH@@ AT_@@ S@@ UM_@@ OF@@ _S@@ QU@@ ARE_@@ DIFF@@ ER@@ EN@@ CES_@@ IS_@@ MIN@@ IMUM | static void solve ( int i , int par , int a [ ] , int n , int k , int current_@@ ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = Math . min ( ans , current_@@ ans ) ; return ; } for ( int j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_@@ ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }
PROGRAM_@@ FIN@@ D_S@@ MAL@@ LE@@ ST_@@ LAR@@ GE@@ ST_@@ WORD_@@ STRING | static void min@@ Max@@ Length@@ Words ( String input ) { int len = input . length ( ) ; int si = 0 , ei = 0 ; int min_@@ length = len , min_@@ start_index = 0 , max_length = 0 , max_@@ start_index = 0 ; while ( ei <= len ) { if ( ei < len && input . charAt ( ei ) != ' ▁ ' ) { ei ++ ; } else { int curr_@@ length = ei - si ; if ( curr_@@ length < min_@@ length ) { min_@@ length = curr_@@ length ; min_@@ start_index = si ; } if ( curr_@@ length > max_length ) { max_length = curr_@@ length ; max_@@ start_index = si ; } ei ++ ; si = ei ; } } min@@ Word = input . substring ( min_@@ start_index , min_@@ start_index + min_@@ length ) ; max@@ Word = input . substring ( max_@@ start_index , max_length ) ; }
CHECK_@@ VALI@@ D@@ _SEQU@@ ENCE_@@ DI@@ VISI@@ BLE_@@ M_@@ 1 | static int is@@ Possible ( int n , int index , int modulo , int M , int arr [ ] , int dp [ ] [ ] ) { modulo = ( ( modulo % M ) + M ) % M ; if ( index == n ) { if ( modulo == 0 ) { return 1 ; } return 0 ; } if ( dp [ index ] [ modulo ] != - 1 ) { return dp [ index ] [ modulo ] ; } int place@@ Add = is@@ Possible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) ; int place@@ Minus = is@@ Possible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) ; int res = place@@ Add ; dp [ index ] [ modulo ] = res ; return res ; }
MINIMUM_@@ OPERATION_@@ MAKE_@@ ELEMEN@@ TS_@@ EQUAL_@@ ARRAY | public static int min@@ Operation ( int arr [ ] , int n ) { HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( hash . containsKey ( arr [ i ] ) ) hash . put ( arr [ i ] , hash . get ( arr [ i ] ) + 1 ) ; else hash . put ( arr [ i ] , 1 ) ; int max_@@ count = 0 ; Set < Integer > s = hash . keySet ( ) ; for ( int i : s ) if ( max_@@ count < hash . get ( i ) ) max_@@ count = hash . get ( i ) ; return ( n - max_@@ count ) ; }
HYPER@@ CUBE_@@ GRAP@@ H | static int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
PROGRAM_@@ FIND_@@ COR@@ RELA@@ TION_@@ CO@@ EF@@ FI@@ CI@@ ENT | static float correlation@@ Coefficient ( int X [ ] , int Y [ ] , int n ) { int sum_@@ X = 0 , sum_@@ Y = 0 , sum_@@ XY = 0 ; int square@@ Sum@@ _@@ X = 0 , square@@ Sum@@ _@@ Y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_@@ X = sum_@@ X + X [ i ] ; sum_@@ Y = sum_@@ Y + Y [ i ] ; sum_@@ XY = sum_@@ XY + X [ i ] * Y [ i ] ; square@@ Sum@@ _@@ X = square@@ Sum@@ _@@ X + X [ i ] * X [ i ] ; square@@ Sum@@ _@@ Y = square@@ Sum@@ _@@ Y + Y [ i ] * Y [ i ] ; } float corr = ( float ) ( n * sum_@@ XY - sum_@@ X * sum_@@ Y ) / ( float ) ( Math . sqrt ( ( n * square@@ Sum@@ _@@ X - sum_@@ X * sum_@@ X ) * ( n * square@@ Sum@@ _@@ Y - sum_@@ Y * sum_@@ Y ) ) ) ; return corr ; }
COUNT_@@ PA@@ LIN@@ DRO@@ MI@@ C@@ _SUB@@ SEQU@@ ENCE_@@ GI@@ V@@ EN_@@ STRING | static int count@@ PS ( String str ) { int N = str . length ( ) ; int [ ] [ ] c@@ ps = new int [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) c@@ ps [ i ] [ i ] = 1 ; for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i < N ; i ++ ) { int k = L + i - 1 ; if ( k < N ) { if ( str . charAt ( i ) == str . charAt ( k ) ) c@@ ps [ i ] [ k ] = c@@ ps [ i ] [ k - 1 ] + c@@ ps [ i + 1 ] [ k ] + 1 ; else c@@ ps [ i ] [ k ] = c@@ ps [ i ] [ k - 1 ] + c@@ ps [ i + 1 ] [ k ] - c@@ ps [ i + 1 ] [ k - 1 ] ; } } } return c@@ ps [ 0 ] [ N - 1 ] ; }
SM@@ ALLE@@ ST_@@ POWER_@@ OF_@@ 2_@@ GREATER_@@ TH@@ AN_@@ OR_@@ EQUAL_@@ TO_@@ N_@@ 1 | static int next@@ PowerOf@@ 2 ( int n ) { int p = 1 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( p < n ) p <<= 1 ; return p ; }
FIND_@@ LAST_@@ DIG@@ IT_@@ FAC@@ TOR@@ I@@ AL_@@ DI@@ VIDE@@ S_@@ FAC@@ TOR@@ I@@ AL_@@ B | static int compute@@ Last@@ Digit ( long A , long B ) { int variable = 1 ; if ( A == B ) return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( long i = A + 1 ; i <= B ; i ++ ) variable = ( int ) ( variable * ( i % 10 ) ) % 10 ; return variable % 10 ; } }
NUMBER@@ _SUB@@ STRING@@ S_@@ DI@@ VISI@@ BLE_@@ 4_@@ STRING_@@ INTEG@@ ERS | static int count@@ Di@@ vis@@ ble@@ by@@ 4 ( String s ) { int n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( s . charAt ( i ) == '4' || s . charAt ( i ) == '8' || s . charAt ( i ) == '0' ) count ++ ; for ( int i = 0 ; i < n - 1 ; ++ i ) { int h = ( s . charAt ( i ) - '0' ) * 10 + ( s . charAt ( i + 1 ) - '0' ) ; if ( h % 4 == 0 ) count = count + i + 1 ; } return count ; }
DECODE_@@ MEDI@@ AN_@@ STRING_@@ ORIGIN@@ AL_@@ STRING | static String decode@@ Median@@ String ( String s ) { int l = s . length ( ) ; String s1 = " " ; boolean is@@ Even = ( l % 2 == 0 ) ? true : false ; for ( int i = 0 ; i < l ; i += 2 ) { if ( is@@ Even ) { s1 = s . charAt ( i ) + s1 ; s1 += s . charAt ( i + 1 ) ; } else { if ( l - i > 1 ) { s1 += s . charAt ( i ) ; s1 = s . charAt ( i + 1 ) + s1 ; } else { s1 += s . charAt ( i ) ; } } } return s1 ; }
NUMBER_@@ WHI@@ CH_@@ HAS_@@ THE_@@ MAXIMUM_@@ NUMBER_OF_@@ DISTIN@@ CT_@@ PRI@@ ME_@@ FAC@@ TOR@@ S_IN_@@ RANGE_@@ M_@@ TO_@@ N | static int maximum@@ Number@@ Distinct@@ Prime@@ Range ( int m , int n ) { long factor@@ Count [ ] = new long [ n + 1 ] ; boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { factor@@ Count [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) { factor@@ Count [ i ] = 1 ; for ( int j = i * 2 ; j <= n ; j += i ) { factor@@ Count [ j ] ++ ; prime [ j ] = false ; } } } int max = ( int ) factor@@ Count [ m ] ; int num = m ; for ( int i = m ; i <= n ; i ++ ) { if ( factor@@ Count [ i ] > max ) { max = ( int ) factor@@ Count [ i ] ; num = i ; } } return num ; }
NUMBER_@@ EQUAL_@@ PAIR@@ S_@@ STRING | static int count@@ Pairs ( String s ) { int cnt [ ] = new int [ MAX ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) cnt [ s . charAt ( i ) ] ++ ; int ans = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) ans += cnt [ i ] * cnt [ i ] ; return ans ; }
COUNT_@@ NUMBER_@@ WAY@@ S_@@ REACH_@@ DESTIN@@ ATION_@@ MA@@ ZE | static int count@@ Paths ( int ma@@ ze [ ] [ ] ) { if ( ma@@ ze [ 0 ] [ 0 ] == - 1 ) return 0 ; for ( int i = 0 ; i < R ; i ++ ) { if ( ma@@ ze [ i ] [ 0 ] == 0 ) ma@@ ze [ i ] [ 0 ] = 1 ; else break ; } for ( int i = 1 ; i < C ; i ++ ) { if ( ma@@ ze [ 0 ] [ i ] == 0 ) ma@@ ze [ 0 ] [ i ] = 1 ; else break ; } for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) { if ( ma@@ ze [ i ] [ j ] == - 1 ) continue ; if ( ma@@ ze [ i - 1 ] [ j ] > 0 ) ma@@ ze [ i ] [ j ] = ( ma@@ ze [ i ] [ j ] + ma@@ ze [ i - 1 ] [ j ] ) ; if ( ma@@ ze [ i ] [ j - 1 ] > 0 ) ma@@ ze [ i ] [ j ] = ( ma@@ ze [ i ] [ j ] + ma@@ ze [ i ] [ j - 1 ] ) ; } } return ( ma@@ ze [ R - 1 ] [ C - 1 ] > 0 ) ? ma@@ ze [ R - 1 ] [ C - 1 ] : 0 ; }
FIND_@@ MAX@@ IM@@ UM@@ _S@@ UM_@@ POSSI@@ BLE_@@ EQUAL@@ _S@@ UM_@@ THRE@@ E_@@ ST@@ AC@@ KS | public static int max@@ Sum ( int stack@@ 1 [ ] , int stack@@ 2 [ ] , int stack@@ 3 [ ] , int n1 , int n2 , int n3 ) { int sum@@ 1 = 0 , sum@@ 2 = 0 , sum@@ 3 = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) sum@@ 1 += stack@@ 1 [ i ] ; for ( int i = 0 ; i < n2 ; i ++ ) sum@@ 2 += stack@@ 2 [ i ] ; for ( int i = 0 ; i < n3 ; i ++ ) sum@@ 3 += stack@@ 3 [ i ] ; int top@@ 1 = 0 , top@@ 2 = 0 , top@@ 3 = 0 ; int ans = 0 ; while ( true ) { if ( top@@ 1 == n1 || top@@ 2 == n2 || top@@ 3 == n3 ) return 0 ; if ( sum@@ 1 == sum@@ 2 && sum@@ 2 == sum@@ 3 ) return sum@@ 1 ; if ( sum@@ 1 >= sum@@ 2 && sum@@ 1 >= sum@@ 3 ) sum@@ 1 -= stack@@ 1 [ top@@ 1 ++ ] ; else if ( sum@@ 2 >= sum@@ 3 && sum@@ 2 >= sum@@ 3 ) sum@@ 2 -= stack@@ 2 [ top@@ 2 ++ ] ; else if ( sum@@ 3 >= sum@@ 2 && sum@@ 3 >= sum@@ 1 ) sum@@ 3 -= stack@@ 3 [ top@@ 3 ++ ] ; } }
MAX@@ IM@@ UM@@ _S@@ UM@@ _SUB@@ SEQU@@ ENCE_@@ LEA@@ ST_@@ K_@@ DISTAN@@ T_@@ ELEMENTS | static int max@@ Sum ( int arr [ ] , int N , int k ) { int MS [ ] = new int [ N ] ; MS [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( i + k + 1 >= N ) MS [ i ] = Math . max ( arr [ i ] , MS [ i + 1 ] ) ; else MS [ i ] = Math . max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) ; } return MS [ 0 ] ; }
CHECK_@@ WHE@@ THER_@@ GI@@ V@@ EN_@@ NUMBER_@@ EV@@ EN_@@ OD@@ D_@@ 1 | public static boolean is@@ Even ( int n ) { if ( ( n & 1 ) == 0 ) return true ; else return false ; }
SORT_@@ ARRAY_@@ TWO_@@ HAL@@ VE@@ S_S@@ OR@@ TED | static void merge@@ Two@@ Half ( int [ ] A , int n ) { Arrays . sort ( A ) ; }
PYTH@@ AG@@ O@@ RE@@ AN_@@ QUAD@@ RUP@@ LE | static Boolean py@@ th@@ ag@@ ore@@ an_@@ quad@@ r@@ uple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }
FIND_@@ THE_@@ MAXIMUM_@@ OF_@@ MIN@@ IM@@ UM@@ S_@@ FOR_@@ EVER@@ Y_@@ WINDOW@@ _SIZE_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY | static void print@@ Max@@ Of@@ Min ( int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int max@@ Of@@ Min = Integer . MIN_VALUE ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > max@@ Of@@ Min ) max@@ Of@@ Min = min ; } System . out . print ( max@@ Of@@ Min + " ▁ " ) ; } }
COUNT_@@ S@@ UM_@@ OF_@@ DIG@@ IT@@ S_IN_@@ NUMB@@ ERS_@@ FROM_@@ 1_@@ TO_@@ N | static int sum@@ Of@@ Digit@@ sFrom@@ 1@@ To@@ N ( int n ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; int d = ( int ) ( Math . log10 ( n ) ) ; int a [ ] = new int [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ; int p = ( int ) ( Math . ceil ( Math . pow ( 10 , d ) ) ) ; int ms@@ d = n / p ; return ( ms@@ d * a [ d ] + ( ms@@ d * ( ms@@ d - 1 ) / 2 ) * p + ms@@ d * ( 1 + n % p ) + sum@@ Of@@ Digit@@ sFrom@@ 1@@ To@@ N ( n % p ) ) ; }
RECUR@@ SI@@ VEL@@ Y_@@ BREAK_@@ NUMBER_@@ 3_@@ PAR@@ TS_@@ GET_@@ MAX@@ IM@@ UM@@ _S@@ UM@@ _1 | static int break@@ Sum ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = Math . max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ; return dp [ n ] ; }
FIND_@@ REPE@@ ATING_@@ ELEMENT_@@ SOR@@ TED_@@ ARRAY@@ _SIZE_@@ N | static int find@@ Repe@@ ating@@ Element ( int arr [ ] , int low , int high ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return find@@ Repe@@ ating@@ Element ( arr , low , mid - 1 ) ; } return find@@ Repe@@ ating@@ Element ( arr , mid + 1 , high ) ; }
COUNT_@@ SUB@@ ARRAY@@ S_@@ EQUAL_@@ NUMBER_@@ 1@@ S_@@ 0@@ S_@@ 1 | static int count@@ Sub@@ arr@@ With@@ Equal@@ Zero@@ And@@ One ( int [ ] arr , int n ) { Map < Integer , Integer > my@@ Map = new HashMap < > ( ) ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) arr [ i ] = - 1 ; sum += arr [ i ] ; if ( sum == 0 ) count ++ ; if ( my@@ Map . containsKey ( sum ) ) count += my@@ Map . get ( sum ) ; if ( ! my@@ Map . containsKey ( sum ) ) my@@ Map . put ( sum , 1 ) ; else my@@ Map . put ( sum , my@@ Map . get ( sum ) + 1 ) ; } return count ; }
UNI@@ ON_@@ AND_@@ INTER@@ SECTION_@@ OF_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S_@@ 2_1 | static void print@@ Intersection ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( ar@@ r1 [ i ] < ar@@ r2 [ j ] ) i ++ ; else if ( ar@@ r2 [ j ] < ar@@ r1 [ i ] ) j ++ ; else { System . out . print ( ar@@ r2 [ j ++ ] + " ▁ " ) ; i ++ ; } } }
COUNT_@@ ALL_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQU@@ EN@@ CES | static int count@@ Sub ( int arr [ ] , int n ) { int count [ ] = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - 1 ; j >= 0 ; j -- ) count [ arr [ i ] ] += count [ j ] ; count [ arr [ i ] ] ++ ; } int result = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) result += count [ i ] ; return result ; }
SM@@ ALLE@@ ST_@@ NUMBER@@ _S@@ UM_@@ DIG@@ IT@@ S_@@ N_@@ DI@@ VISI@@ BLE_@@ 10@@ N | static void digit@@ s@@ Num ( int N ) { if ( N == 0 ) System . out . println ( "0" ) ; if ( N % 9 != 0 ) System . out . print ( ( N % 9 ) ) ; for ( int i = 1 ; i <= ( N / 9 ) ; ++ i ) System . out . print ( "@@ 9" ) ; for ( int i = 1 ; i <= N ; ++ i ) System . out . print ( "0" ) ; System . out . print ( " " ) ; }
FIND_@@ THE_@@ NUMBER_@@ OC@@ CURR@@ ING_@@ OD@@ D_@@ NUMBER_OF_@@ TIME@@ S_@@ 1 | static int getO@@ dd@@ Occurren@@ ce ( int arr [ ] , int n ) { HashMap < Integer , Integer > h@@ map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( h@@ map . containsKey ( arr [ i ] ) ) { int val = h@@ map . get ( arr [ i ] ) ; h@@ map . put ( arr [ i ] , val + 1 ) ; } else h@@ map . put ( arr [ i ] , 1 ) ; } for ( Integer a : h@@ map . keySet ( ) ) { if ( h@@ map . get ( a ) % 2 != 0 ) return a ; } return - 1 ; }
CHECK_@@ IF_@@ X_@@ CAN_@@ GI@@ VE_@@ CHANGE_@@ TO_@@ EVER@@ Y_@@ PERS@@ ON_@@ IN_@@ THE_@@ QUEUE | static int is@@ Change@@ able ( int notes [ ] , int n ) { int fi@@ ve@@ Count = 0 ; int ten@@ Count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( notes [ i ] == 5 ) fi@@ ve@@ Count ++ ; else if ( notes [ i ] == 10 ) { if ( fi@@ ve@@ Count > 0 ) { fi@@ ve@@ Count -- ; ten@@ Count ++ ; } else return 0 ; } else { if ( fi@@ ve@@ Count > 0 && ten@@ Count > 0 ) { fi@@ ve@@ Count -- ; ten@@ Count -- ; } else if ( fi@@ ve@@ Count >= 3 ) { fi@@ ve@@ Count -= 3 ; } else return 0 ; } } return 1 ; }
MAXIMUM_@@ MINIMUM_@@ VALU@@ ES_@@ AL@@ GE@@ BRA@@ IC_@@ EXPRESSION | static void min@@ Max@@ Values ( int [ ] arr , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { sum += arr [ i ] ; arr [ i ] += 50 ; } boolean dp [ ] [ ] = new boolean [ MAX + 1 ] [ MAX * MAX + 1 ] ; dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { for ( int k = Math . min ( n , i + 1 ) ; k >= 1 ; k -- ) { for ( int j = 0 ; j < MAX * MAX + 1 ; j ++ ) { if ( dp [ k - 1 ] [ j ] ) dp [ k ] [ j + arr [ i ] ] = true ; } } } double max_value = - 1 * INF , min_value = INF ; for ( int i = 0 ; i < MAX * MAX + 1 ; i ++ ) { if ( dp [ n ] [ i ] ) { int temp = i - 50 * n ; max_value = Math . max ( max_value , temp * ( sum - temp ) ) ; min_value = Math . min ( min_value , temp * ( sum - temp ) ) ; } } System . out . print ( " Maximum ▁ Value : ▁ " + ( int ) max_value + " \n " + " Minimum ▁ Value : ▁ " + ( int ) min_value + " \n " ) ; }
MULTI@@ PLY_@@ AN_@@ INTEGER_@@ WITH_@@ 3_@@ 5 | static int multiply@@ With@@ 3@@ Point@@ 5 ( int x ) { return ( x << 1 ) + x + ( x > > 1 ) ; }
MINIMUM_@@ CEL@@ LS_@@ REQUIRED_@@ REACH_@@ DESTIN@@ ATION_@@ JUM@@ PS_@@ EQUAL_@@ CELL_@@ VALUES | static int min@@ Cells ( int mat [ ] [ ] , int m , int n ) { int dp [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = Integer . MAX_VALUE ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m - 1 ] [ n - 1 ] != Integer . MAX_VALUE ) return dp [ m - 1 ] [ n - 1 ] ; return - 1 ; }
FIND_@@ INDEX_@@ OF_@@ AN_@@ EXTRA_@@ ELEMENT_@@ PRES@@ ENT_@@ IN_@@ ONE@@ _S@@ OR@@ TED_@@ ARRAY | static int find@@ Extra ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ar@@ r1 [ i ] != ar@@ r2 [ i ] ) return i ; return n ; }
CAL@@ CUL@@ ATE_@@ S@@ UM_@@ OF_@@ ALL_@@ NUMB@@ ERS_@@ PRES@@ ENT_@@ IN_@@ A_@@ STRING | static int find@@ Sum ( String str ) { String temp = " " ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( Character . is@@ Digit ( ch ) ) temp += ch ; else { sum += Integer . parseInt ( temp ) ; temp = "0" ; } } return sum + Integer . parseInt ( temp ) ; }
CHECK_@@ REVER@@ SING@@ _SUB_@@ ARRAY_@@ MAKE_@@ ARRA@@ Y_S@@ OR@@ TED | static boolean check@@ Reverse ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { temp [ i ] = arr [ i ] ; } Arrays . sort ( temp ) ; int front ; for ( front = 0 ; front < n ; front ++ ) { if ( temp [ front ] != arr [ front ] ) { break ; } } int back ; for ( back = n - 1 ; back >= 0 ; back -- ) { if ( temp [ back ] != arr [ back ] ) { break ; } } if ( front >= back ) { return true ; } do { front ++ ; if ( arr [ front - 1 ] < arr [ front ] ) { return false ; } } while ( front != back ) ; return true ; }
GENERATE_@@ PYTH@@ AG@@ OR@@ AS_@@ TR@@ IP@@ LET_@@ SINGLE_@@ INTEGER | static void evaluate ( int n ) { if ( n == 1 || n == 2 ) System . out . println ( " No ▁ Py@@ th@@ ag@@ or@@ as ▁ " + " Trip@@ let ▁ exists " ) ; else if ( n % 2 == 0 ) { int var = 1 * n * n / 4 ; System . out . print ( " Py@@ th@@ ag@@ or@@ as ▁ Trip@@ lets ▁ " + " exist ▁ i . e . ▁ " ) ; System . out . print ( n + " ▁ " ) ; System . out . print ( var - 1 + " ▁ " ) ; System . out . println ( var + 1 + " ▁ " ) ; } else if ( n % 2 != 0 ) { int var = 1 * n * n + 1 ; System . out . print ( " Py@@ th@@ ag@@ or@@ as ▁ Trip@@ lets ▁ " + " exist ▁ i . e . ▁ " ) ; System . out . print ( n + " ▁ " ) ; System . out . print ( var / 2 - 1 + " ▁ " ) ; System . out . println ( var / 2 + " ▁ " ) ; } }
PE@@ TER@@ S@@ ON_@@ GRAP@@ H | static boolean find@@ the@@ path ( char [ ] S , int v ) { result [ 0 ] = ( char ) ( v + '0' ) ; for ( int i = 1 ; i < ( int ) S . length ; i ++ ) { if ( adj [ v ] [ S [ i ] - ' A ' ] || adj [ S [ i ] - ' A ' ] [ v ] ) { v = S [ i ] - ' A ' ; } else if ( adj [ v ] [ S [ i ] - ' A ' + 5 ] || adj [ S [ i ] - ' A ' + 5 ] [ v ] ) { v = S [ i ] - ' A ' + 5 ; } else return false ; result [ i ] = ( char ) ( v + '0' ) ; } return true ; }
COUNT_@@ NUMBER_@@ OF@@ _S@@ OL@@ U@@ TIONS_@@ OF_@@ X@@ 2_@@ 1_@@ MOD_@@ P_@@ IN_@@ GI@@ V@@ EN_@@ RANGE | static int find@@ Count@@ Of@@ Solutions ( int n , int p ) { int ans = 0 ; for ( int x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { int last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }
JUM@@ P@@ _SEARCH | public static int jump@@ Search ( int [ ] arr , int x ) { int n = arr . length ; int step = ( int ) Math . floor ( Math . sqrt ( n ) ) ; int prev = 0 ; while ( arr [ Math . min ( step , n ) - 1 ] < x ) { prev = step ; step += ( int ) Math . floor ( Math . sqrt ( n ) ) ; if ( prev >= n ) return - 1 ; } while ( arr [ prev ] < x ) { prev ++ ; if ( prev == Math . min ( step , n ) ) return - 1 ; } if ( arr [ prev ] == x ) return prev ; return - 1 ; }
FORM_@@ MINIMUM_@@ NUMBER_@@ FROM_@@ GI@@ VEN@@ _SEQU@@ ENCE | static void Print@@ Min@@ Number@@ For@@ Pattern ( String arr ) { int curr_@@ max = 0 ; int last_@@ entry = 0 ; int j ; for ( int i = 0 ; i < arr . length ( ) ; i ++ ) { int noOf@@ Next@@ D = 0 ; switch ( arr . charAt ( i ) ) { case ' I ' : j = i + 1 ; while ( j < arr . length ( ) && arr . charAt ( j ) == ' D ' ) { noOf@@ Next@@ D ++ ; j ++ ; } if ( i == 0 ) { curr_@@ max = noOf@@ Next@@ D + 2 ; System . out . print ( " ▁ " + ++ last_@@ entry ) ; System . out . print ( " ▁ " + curr_@@ max ) ; last_@@ entry = curr_@@ max ; } else { curr_@@ max = curr_@@ max + noOf@@ Next@@ D + 1 ; last_@@ entry = curr_@@ max ; System . out . print ( " ▁ " + last_@@ entry ) ; } for ( int k = 0 ; k < noOf@@ Next@@ D ; k ++ ) { System . out . print ( " ▁ " + -- last_@@ entry ) ; i ++ ; } break ; case ' D ' : if ( i == 0 ) { j = i + 1 ; while ( j < arr . length ( ) && arr . charAt ( j ) == ' D ' ) { noOf@@ Next@@ D ++ ; j ++ ; } curr_@@ max = noOf@@ Next@@ D + 2 ; System . out . print ( " ▁ " + curr_@@ max + " ▁ " + ( curr_@@ max - 1 ) ) ; last_@@ entry = curr_@@ max - 1 ; } else { System . out . print ( " ▁ " + ( last_@@ entry - 1 ) ) ; last_@@ entry -- ; } break ; } } System . out . println ( ) ; }
GI@@ V@@ EN_@@ LARGE_@@ NUMBER_@@ CHECK@@ _SUB@@ SEQU@@ ENCE_@@ DIG@@ IT@@ S_@@ DI@@ VISI@@ BLE_@@ 8 | static boolean isSub@@ Seq@@ Di@@ visible ( String str ) { int i , j , k , l = str . length ( ) ; int arr [ ] = new int [ l ] ; for ( i = 0 ; i < l ; i ++ ) { for ( j = i ; j < l ; j ++ ) { for ( k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }
PRINT_@@ FI@@ BON@@ AC@@ CI@@ _SEQU@@ ENCE_@@ USING_@@ 2_@@ VARIABLES | static void fi@@ b ( int n ) { int a = 0 , b = 1 , c ; if ( n >= 0 ) System . out . print ( a + " ▁ " ) ; if ( n >= 1 ) System . out . print ( b + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; System . out . print ( c + " ▁ " ) ; a = b ; b = c ; } }
INTER@@ CHANGE_@@ ELEMEN@@ TS_@@ OF_@@ FIRST_@@ AND_@@ LAST_@@ RO@@ WS_@@ IN_@@ MATRIX | static void inter@@ change@@ First@@ Last ( int m [ ] [ ] ) { int rows = m . length ; for ( int i = 0 ; i < m [ 0 ] . length ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } }
S@@ UM_@@ MATRIX_@@ ELEMENT_@@ ABSOL@@ UTE_@@ DIFF@@ ER@@ ENCE_@@ ROW_@@ COLUMN_@@ NUMB@@ ERS | static int find@@ Sum ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = Math . abs ( i - j ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }
FIND_@@ THE_@@ MAXIMUM_@@ ELEMENT_@@ IN_@@ AN_@@ ARRAY_@@ WHI@@ CH_@@ IS_@@ FIRST_@@ INCRE@@ AS@@ ING_@@ AND_@@ TH@@ EN_@@ DECRE@@ AS@@ ING | static int find@@ Maximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }
PROGRAM_@@ CHECK_@@ DIAG@@ ON@@ AL_@@ MATRI@@ X@@ _SCAL@@ AR_@@ MATRIX_@@ 1 | static boolean is@@ Scalar@@ Matrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( int i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; return true ; }
ST@@ OO@@ GE_@@ S@@ ORT | static void st@@ oo@@ ge@@ sort ( int arr [ ] , int l , int h ) { if ( l >= h ) return ; if ( arr [ l ] > arr [ h ] ) { int t = arr [ l ] ; arr [ l ] = arr [ h ] ; arr [ h ] = t ; } if ( h - l + 1 > 2 ) { int t = ( h - l + 1 ) / 3 ; st@@ oo@@ ge@@ sort ( arr , l , h - t ) ; st@@ oo@@ ge@@ sort ( arr , l + t , h ) ; st@@ oo@@ ge@@ sort ( arr , l , h - t ) ; } }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 11_@@ EG@@ G_@@ DRO@@ PP@@ ING_@@ PU@@ ZZ@@ LE | static int egg@@ Drop ( int n , int k ) { if ( k == 1 || k == 0 ) return k ; if ( n == 1 ) return k ; int min = Integer . MAX_VALUE ; int x , res ; for ( x = 1 ; x <= k ; x ++ ) { res = Math . max ( egg@@ Drop ( n - 1 , x - 1 ) , egg@@ Drop ( n , k - x ) ) ; if ( res < min ) min = res ; } return min + 1 ; }
DIFF@@ ER@@ ENT_@@ WAY@@ S_S@@ UM_@@ N_@@ USING_@@ NUMB@@ ERS_@@ GREATER_@@ EQUAL_@@ M | static int number@@ of@@ ways ( int n , int m ) { int dp [ ] [ ] = new int [ n + 2 ] [ n + 2 ] ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
BU@@ BB@@ LE_@@ S@@ ORT | void bu@@ bble@@ Sort ( int arr [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = 0 ; j < n - i - 1 ; j ++ ) if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; } }
GENERATE_@@ ROTA@@ TIONS_@@ GI@@ V@@ EN_@@ STRING | static void print@@ Rot@@ ated@@ String ( String str ) { int len = str . length ( ) ; StringBuffer sb ; for ( int i = 0 ; i < len ; i ++ ) { sb = new StringBuffer ( ) ; int j = i ; int k = 0 ; for ( int k2 = j ; k2 < str . length ( ) ; k2 ++ ) { sb . insert ( k , str . charAt ( j ) ) ; k ++ ; j ++ ; } j = 0 ; while ( j < i ) { sb . insert ( k , str . charAt ( j ) ) ; j ++ ; k ++ ; } System . out . println ( sb ) ; } }
M@@ ID_@@ POINT_@@ LINE_@@ GENERA@@ TION_@@ ALGORITH@@ M | static void mid@@ Point ( int X1 , int Y1 , int X2 , int Y2 ) { int dx = X2 - X1 ; int dy = Y2 - Y1 ; int d = dy - ( dx / 2 ) ; int x = X1 , y = Y1 ; System . out . print ( x + " , " + y + " \n " ) ; while ( x < X2 ) { x ++ ; if ( d < 0 ) d = d + dy ; else { d += ( dy - dx ) ; y ++ ; } System . out . print ( x + " , " + y + " \n " ) ; } }
FIN@@ DING_@@ VERTEX_@@ FOCUS_@@ DIREC@@ TRI@@ X_@@ PAR@@ ABO@@ LA | static void par@@ ab@@ ola ( float a , float b , float c ) { System . out . println ( " Vertex : ▁ ( " + ( - b / ( 2 * a ) ) + " , ▁ " + ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) + " ) " ) ; System . out . println ( " Focus : ▁ ( " + ( - b / ( 2 * a ) ) + " , ▁ " + ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) + " ) " ) ; System . out . println ( " Direc@@ tri@@ x : " + " ▁ y = " + ( int ) ( c - ( ( b * b ) + 1 ) * 4 * a ) ) ; }
TRIANG@@ ULAR_@@ NUMB@@ ERS | static boolean is@@ Tri@@ angular ( int num ) { if ( num < 0 ) return false ; int sum = 0 ; for ( int n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; }
PI@@ ZZ@@ A_@@ CU@@ T_@@ PRO@@ BLE@@ M_@@ CI@@ R@@ CLE_@@ DI@@ VISI@@ ON_@@ LINES | static int find@@ Maximum@@ Pieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
MINIMUM_@@ TIME_@@ WRITE_@@ CHARAC@@ TER@@ S_@@ USING_@@ INSERT_@@ DELETE_@@ COPY_@@ OPERATION | static int min@@ Time@@ For@@ Writing@@ Chars ( int N , int insert , int remove , int copy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insert ; int dp [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + copy ) ; else dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) / 2 ] + copy + remove ) ; } return dp [ N ] ; }
SE@@ ARCH@@ ING_@@ ARRAY_@@ AD@@ J@@ AC@@ ENT_@@ DIFF@@ ER_@@ K | static int search ( int arr [ ] , int n , int x , int k ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . max ( 1 , Math . abs ( arr [ i ] - x ) / k ) ; } System . out . println ( " number ▁ is ▁ " + " not ▁ present ! " ) ; return - 1 ; }
FIND_@@ MAXIMUM_@@ PRODUCT_@@ OF_@@ A_@@ TR@@ IP@@ LET_@@ IN_@@ ARRAY | static int max@@ Product ( int [ ] arr , int n ) { if ( n < 3 ) return - 1 ; int max_@@ product = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) max_@@ product = Math . max ( max_@@ product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_@@ product ; }
LON@@ GE@@ ST_@@ PA@@ LIN@@ DRO@@ ME_@@ SUB@@ SEQU@@ ENCE_@@ SPACE | static int l@@ ps ( String s ) { int n = s . length ( ) ; int a [ ] = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int back_@@ up = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( j == i ) a [ j ] = 1 ; else if ( s . charAt ( i ) == s . charAt ( j ) ) { int temp = a [ j ] ; a [ j ] = back_@@ up + 2 ; back_@@ up = temp ; } else { back_@@ up = a [ j ] ; a [ j ] = Math . max ( a [ j - 1 ] , a [ j ] ) ; } } } return a [ n - 1 ] ; }
CHECK_@@ HALF_@@ STRING_@@ CHARACTER_@@ FREQU@@ ENCY_@@ CHARACTER_@@ 1 | static boolean check@@ Correct@@ Or@@ Not ( String s ) { int [ ] count = new int [ MAX_@@ CHAR ] ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count [ s . charAt ( i ) - ' a ' ] ++ ; count [ s . charAt ( j ) - ' a ' ] -- ; } for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) if ( count [ i ] != 0 ) return false ; return true ; }
EXPO@@ NE@@ N@@ TI@@ AL_S@@ QUAR@@ ING_@@ FAST_@@ MODUL@@ O_@@ MULTIP@@ LIC@@ ATION | static long expon@@ enti@@ ation ( long base , long exp ) { if ( exp == 0 ) return 1 ; if ( exp == 1 ) return base % N ; long t = expon@@ enti@@ ation ( base , exp / 2 ) ; t = ( t * t ) % N ; if ( exp % 2 == 0 ) return t ; else return ( ( base % N ) * t ) % N ; }
REMOVE_@@ MINIMUM_@@ NUMBER_@@ ELEMEN@@ TS_@@ NO_@@ COMMON_@@ ELEMENT_@@ EXI@@ ST_@@ ARRAY | public static int min@@ Remove ( int a [ ] , int b [ ] , int n , int m ) { HashMap < Integer , Integer > count@@ A = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > count@@ B = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count@@ A . containsKey ( a [ i ] ) ) count@@ A . put ( a [ i ] , count@@ A . get ( a [ i ] ) + 1 ) ; else count@@ A . put ( a [ i ] , 1 ) ; } for ( int i = 0 ; i < m ; i ++ ) { if ( count@@ B . containsKey ( b [ i ] ) ) count@@ B . put ( b [ i ] , count@@ B . get ( b [ i ] ) + 1 ) ; else count@@ B . put ( b [ i ] , 1 ) ; } int res = 0 ; Set < Integer > s = count@@ A . keySet ( ) ; for ( int x : s ) if ( count@@ B . containsKey ( x ) ) res += Math . min ( count@@ B . get ( x ) , count@@ A . get ( x ) ) ; return res ; }
FIND_@@ A_@@ FIXED_@@ POINT_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY | static int linear@@ Search ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; }
ADD_@@ 1_@@ TO_@@ A_@@ GI@@ V@@ EN_@@ NUMBER | static int add@@ One ( int x ) { int m = 1 ; while ( ( int ) ( x & m ) >= 1 ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
HEIGHT_@@ COMPLETE_@@ BINARY_@@ TREE_@@ HEAP_@@ N_@@ NODES | static int height ( int N ) { return ( int ) Math . ceil ( Math . log ( N + 1 ) / Math . log ( 2 ) ) - 1 ; }
MINIMUM_@@ NUMBER_OF_@@ JUM@@ PS_@@ TO_@@ REACH_@@ END_OF_@@ A_@@ GI@@ V@@ EN_@@ ARRAY | static int min@@ Jump@@ s ( int arr [ ] , int l , int h ) { if ( h == l ) return 0 ; if ( arr [ l ] == 0 ) return Integer . MAX_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = l + 1 ; i <= h && i <= l + arr [ l ] ; i ++ ) { int jumps = min@@ Jump@@ s ( arr , i , h ) ; if ( jumps != Integer . MAX_VALUE && jumps + 1 < min ) min = jumps + 1 ; } return min ; }
PROGRAM_@@ FOR_@@ N@@ TH_@@ FI@@ BON@@ ACC@@ I_@@ NUMBER_@@ 2 | public static int fi@@ b ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 || n == 2 ) return ( f [ n ] = 1 ) ; if ( f [ n ] != 0 ) return f [ n ] ; int k = ( n & 1 ) == 1 ? ( n + 1 ) / 2 : n / 2 ; f [ n ] = ( n & 1 ) == 1 ? ( fi@@ b ( k ) * fi@@ b ( k ) + fi@@ b ( k - 1 ) * fi@@ b ( k - 1 ) ) : ( 2 * fi@@ b ( k - 1 ) + fi@@ b ( k ) ) * fi@@ b ( k ) ; return f [ n ] ; }
DECODE_@@ STRING_@@ RECUR@@ SI@@ VEL@@ Y_@@ EN@@ CODE@@ D_@@ COUNT_@@ FOL@@ LO@@ WE@@ D@@ _SUB@@ STRING | static String decode ( String str ) { Stack < Integer > integer@@ stack = new Stack < > ( ) ; Stack < Character > string@@ stack = new Stack < > ( ) ; String temp = " " , result = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int count = 0 ; if ( Character . is@@ Digit ( str . charAt ( i ) ) ) { while ( Character . is@@ Digit ( str . charAt ( i ) ) ) { count = count * 10 + str . charAt ( i ) - '0' ; i ++ ; } i -- ; integer@@ stack . push ( count ) ; } else if ( str . charAt ( i ) == ' ] ' ) { temp = " " ; count = 0 ; if ( ! integer@@ stack . isEmpty ( ) ) { count = integer@@ stack . peek ( ) ; integer@@ stack . pop ( ) ; } while ( ! string@@ stack . isEmpty ( ) && string@@ stack . peek ( ) != ' [ ' ) { temp = string@@ stack . peek ( ) + temp ; string@@ stack . pop ( ) ; } if ( ! string@@ stack . empty ( ) && string@@ stack . peek ( ) == ' [ ' ) string@@ stack . pop ( ) ; for ( int j = 0 ; j < count ; j ++ ) result = result + temp ; for ( int j = 0 ; j < result . length ( ) ; j ++ ) string@@ stack . push ( result . charAt ( j ) ) ; result = " " ; } else if ( str . charAt ( i ) == ' [ ' ) { if ( Character . is@@ Digit ( str . charAt ( i - 1 ) ) ) string@@ stack . push ( str . charAt ( i ) ) ; else { string@@ stack . push ( str . charAt ( i ) ) ; integer@@ stack . push ( 1 ) ; } } else string@@ stack . push ( str . charAt ( i ) ) ; } while ( ! string@@ stack . isEmpty ( ) ) { result = string@@ stack . peek ( ) + result ; string@@ stack . pop ( ) ; } return result ; }
HO@@ W_@@ TO_@@ CHECK_@@ IF_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ RE@@ PRESEN@@ TS_@@ A_@@ BINARY_@@ HEA@@ P | static boolean is@@ Heap ( int arr [ ] , int i , int n ) { if ( i > ( n - 2 ) / 2 ) { return true ; } if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && is@@ Heap ( arr , 2 * i + 1 , n ) && is@@ Heap ( arr , 2 * i + 2 , n ) ) { return true ; } return false ; }
HO@@ W_@@ TO_@@ CHECK_@@ IF_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ RE@@ PRESEN@@ TS_@@ A_@@ BINARY_@@ HEAP_@@ 1 | static boolean is@@ Heap ( int arr [ ] , int n ) { for ( int i = 0 ; i <= ( n - 2 ) / 2 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) { return false ; } if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) { return false ; } } return true ; }
CAL@@ CUL@@ ATE_@@ ANGLE_@@ HOUR_@@ H@@ AND_@@ MIN@@ UTE_@@ HAND | static int calc@@ Angle ( double h , double m ) { if ( h < 0 || m < 0 || h > 12 || m > 60 ) System . out . println ( " Wrong ▁ input " ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) m = 0 ; int hour@@ _@@ angle = ( int ) ( 0.5 * ( h * 60 + m ) ) ; int minu@@ te_@@ angle = ( int ) ( 6 * m ) ; int angle = Math . abs ( hour@@ _@@ angle - minu@@ te_@@ angle ) ; angle = Math . min ( 360 - angle , angle ) ; return angle ; }
CONVER@@ TING_@@ DECIMAL_@@ NUMBER_@@ LY@@ ING_@@ BETWE@@ EN_@@ 1_@@ TO_@@ 399@@ 9_@@ TO_@@ RO@@ MAN_@@ NUMER@@ ALS | static void print@@ Roman ( int number ) { char c [ ] = new char [ 100@@ 01 ] ; int i = 0 ; if ( number <= 0 ) { System . out . printf ( " Invalid ▁ number " ) ; return ; } while ( number != 0 ) { if ( number >= 1000 ) { i = digit ( ' M ' , number / 1000 , i , c ) ; number = number % 1000 ; } else if ( number >= 500 ) { if ( number < 900 ) { i = digit ( ' D ' , number / 500 , i , c ) ; number = number % 500 ; } else { i = sub_@@ digit ( ' C ' , ' M ' , i , c ) ; number = number % 100 ; } } else if ( number >= 100 ) { if ( number < 400 ) { i = digit ( ' C ' , number / 100 , i , c ) ; number = number % 100 ; } else { i = sub_@@ digit ( ' C ' , ' D ' , i , c ) ; number = number % 100 ; } } else if ( number >= 50 ) { if ( number < 90 ) { i = digit ( ' L ' , number / 50 , i , c ) ; number = number % 50 ; } else { i = sub_@@ digit ( ' X ' , ' C ' , i , c ) ; number = number % 10 ; } } else if ( number >= 10 ) { if ( number < 40 ) { i = digit ( ' X ' , number / 10 , i , c ) ; number = number % 10 ; } else { i = sub_@@ digit ( ' X ' , ' L ' , i , c ) ; number = number % 10 ; } } else if ( number >= 5 ) { if ( number < 9 ) { i = digit ( ' V ' , number / 5 , i , c ) ; number = number % 5 ; } else { i = sub_@@ digit ( ' I ' , ' X ' , i , c ) ; number = 0 ; } } else if ( number >= 1 ) { if ( number < 4 ) { i = digit ( ' I ' , number , i , c ) ; number = 0 ; } else { i = sub_@@ digit ( ' I ' , ' V ' , i , c ) ; number = 0 ; } } } System . out . printf ( " Roman ▁ numer@@ al ▁ is : ▁ " ) ; for ( int j = 0 ; j < i ; j ++ ) { System . out . printf ( " % c " , c [ j ] ) ; } }
SOR@@ TING_@@ USING_@@ TRI@@ VI@@ AL_@@ HASH_@@ FUNCTION | static void sort@@ Using@@ Hash ( int a [ ] , int n ) { int max = Arrays . stream ( a ) . max ( ) . getAs@@ Int ( ) ; int hash [ ] = new int [ max + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) hash [ a [ i ] ] += 1 ; for ( int i = 0 ; i <= max ; i ++ ) { if ( hash [ i ] != 0 ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) { System . out . print ( i + " ▁ " ) ; } } } }
S@@ UM_@@ PAIR@@ WI@@ SE_@@ PRODUC@@ TS_@@ 2 | static int find@@ Sum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ; }
ENTR@@ ING@@ ER_@@ NUMBER | static int zig@@ z@@ ag ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zig@@ z@@ ag ( n , k - 1 ) + zig@@ z@@ ag ( n - 1 , n - k ) ; }
MIN@@ IM@@ UM@@ _S@@ UM_@@ TWO_@@ NUMB@@ ERS_@@ FOR@@ MED_@@ DIG@@ IT@@ S_@@ ARRAY_@@ 2 | static int min@@ Sum ( int a [ ] , int n ) { Arrays . sort ( a ) ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }
SUB@@ ARRAY_@@ NO_@@ PAIR@@ _S@@ UM_@@ DI@@ VISI@@ BLE_@@ K | static void sub@@ array@@ Di@@ visible@@ By@@ K ( int [ ] arr , int n , int k ) { int [ ] mp = new int [ 1000 ] ; int s = 0 , e = 0 , maxs = 0 , max@@ e = 0 ; mp [ arr [ 0 ] % k ] ++ ; for ( int i = 1 ; i < n ; i ++ ) { int mod = arr [ i ] % k ; while ( mp [ k - mod ] != 0 || ( mod == 0 && mp [ mod ] != 0 ) ) { mp [ arr [ s ] % k ] -- ; s ++ ; } mp [ mod ] ++ ; e ++ ; if ( ( e - s ) > ( max@@ e - maxs ) ) { max@@ e = e ; maxs = s ; } } System . out . print ( " The ▁ maximum ▁ size ▁ is ▁ " + ( max@@ e - maxs + 1 ) + " ▁ and ▁ the ▁ sub@@ array ▁ is ▁ as ▁ follows \n " ) ; for ( int i = maxs ; i <= max@@ e ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
MAXIMUM_@@ PROFI@@ T_@@ BY_@@ BU@@ Y@@ ING_@@ AND@@ _S@@ EL@@ LING_@@ A@@ _SH@@ ARE_@@ AT_@@ MO@@ ST_@@ K_@@ TIMES | static int max@@ Pro@@ fit ( int [ ] price , int n , int k ) { int [ ] [ ] pro@@ fit = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) pro@@ fit [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) pro@@ fit [ 0 ] [ j ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { int max_@@ so@@ _f@@ ar = 0 ; for ( int m = 0 ; m < j ; m ++ ) max_@@ so@@ _f@@ ar = Math . max ( max_@@ so@@ _f@@ ar , price [ j ] - price [ m ] + pro@@ fit [ i - 1 ] [ m ] ) ; pro@@ fit [ i ] [ j ] = Math . max ( pro@@ fit [ i ] [ j - 1 ] , max_@@ so@@ _f@@ ar ) ; } } return pro@@ fit [ k ] [ n - 1 ] ; }
MINI@@ MI@@ ZE_@@ S@@ UM_@@ PRODUCT_@@ TWO_@@ ARRAY@@ S_PER@@ MU@@ TA@@ TIONS_@@ ALLOWED | static int minValue ( int A [ ] , int B [ ] , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }
FIND_@@ MAXIMUM_@@ ELEMENT_@@ ROW_@@ MATRIX | public static void max@@ element ( int no_@@ of_@@ rows , int [ ] [ ] arr ) { int i = 0 ; int max = 0 ; int [ ] result = new int [ no_@@ of_@@ rows ] ; while ( i < no_@@ of_@@ rows ) { for ( int j = 0 ; j < arr [ i ] . length ; j ++ ) { if ( arr [ i ] [ j ] > max ) { max = arr [ i ] [ j ] ; } } result [ i ] = max ; max = 0 ; i ++ ; } print@@ Array ( result ) ; }
ROUND_@@ OFF_@@ NUMBER_@@ GI@@ V@@ EN_@@ NUMBER@@ _SIGN@@ I@@ FI@@ CANT_@@ DIGITS | static void Ro@@ und_@@ off ( double N , double n ) { int h ; double l , a , b , c , d , e , i , j , m , f , g ; b = N ; c = floor ( N ) ; for ( i = 0 ; b >= 1 ; ++ i ) b = b / 10 ; d = n - i ; b = N ; b = b * pow ( 10 , d ) ; e = b + 0.5 ; if ( ( float ) e == ( float ) ceil ( b ) ) { f = ( ceil ( b ) ) ; h = ( int ) ( f - 2 ) ; if ( h % 2 != 0 ) { e = e - 1 ; } } j = floor ( e ) ; m = pow ( 10 , d ) ; j = j / m ; System . out . println ( " The ▁ number ▁ after ▁ rounding - off ▁ is ▁ " + j ) ; }
CHECK_@@ WHE@@ THER_@@ POINT_@@ EXI@@ ST@@ S_@@ CI@@ R@@ CLE_@@ SEC@@ TOR_@@ NOT | static void check@@ Point ( int radius , int x , int y , float percent , float start@@ Angle ) { float end@@ Angle = 360 / percent + start@@ Angle ; double polar@@ radius = Math . sqrt ( x * x + y * y ) ; double Angle = Math . atan ( y / x ) ; if ( Angle >= start@@ Angle && Angle <= end@@ Angle && polar@@ radius < radius ) System . out . print ( " Point " + " ( " + x + " , " + y + " ) " + " ▁ exist ▁ in ▁ the ▁ circle ▁ sector \n " ) ; else System . out . print ( " Point " + " ( " + x + " , " + y + " ) " + " ▁ exist ▁ in ▁ the ▁ circle ▁ sector \n " ) ; }
NUMBER_@@ IS_@@ DI@@ VISI@@ BLE_@@ BY_@@ 29@@ _@@ OR_@@ NOT | static boolean is@@ Di@@ visible ( long n ) { while ( n / 100 > 0 ) { int last_@@ digit = ( int ) n % 10 ; n /= 10 ; n += last_@@ digit * 3 ; } return ( n % 29 == 0 ) ; }
PRINT_@@ ALL_@@ DISTIN@@ CT_@@ CHARAC@@ TER@@ S_@@ OF_@@ A_@@ STRING_@@ IN_@@ ORDER_@@ 3_@@ METHODS | static void print@@ Distin@@ ct ( String str ) { int [ ] count = new int [ NO_@@ OF_@@ CHARS ] ; int i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) != ' ▁ ' ) count [ ( int ) str . charAt ( i ) ] ++ ; int n = i ; for ( i = 0 ; i < n ; i ++ ) if ( count [ ( int ) str . charAt ( i ) ] == 1 ) System . out . print ( str . charAt ( i ) ) ; }
PROGRAM_@@ REVERSE_@@ STRING_@@ ITER@@ ATI@@ VE_@@ RECUR@@ SIVE | public static String recursive@@ Reverse ( char [ ] str ) { Stack < Character > st = new Stack < > ( ) ; for ( int i = 0 ; i < str . length ; i ++ ) st . push ( str [ i ] ) ; for ( int i = 0 ; i < str . length ; i ++ ) { str [ i ] = st . peek ( ) ; st . pop ( ) ; } return String . valueOf ( str ) ; }
PA@@ INT@@ ING_@@ F@@ ENCE_@@ ALGORITH@@ M | static long count@@ W@@ ays ( int n , int k ) { long total = k ; int mod = 100000000@@ 7 ; int same = 0 , diff = k ; for ( int i = 2 ; i <= n ; i ++ ) { same = diff ; diff = ( int ) total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }
COUNT_@@ OF@@ _SUB_@@ STRING@@ S_@@ TH@@ AT_@@ DO_@@ NOT_@@ CONTA@@ IN_@@ ALL_@@ THE_@@ CHARAC@@ TER@@ S_@@ FROM_@@ THE_@@ SET_@@ A_@@ B_@@ C_@@ AT_@@ THE_@@ S@@ AME_@@ TIME | static int Count@@ Sub@@ string ( char str [ ] , int n ) { int ans = ( n * ( n + 1 ) ) / 2 ; int a_@@ index = 0 ; int b_@@ index = 0 ; int c_@@ index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' a ' ) { a_@@ index = i + 1 ; ans -= Math . min ( b_@@ index , c_@@ index ) ; } else if ( str [ i ] == ' b ' ) { b_@@ index = i + 1 ; ans -= Math . min ( a_@@ index , c_@@ index ) ; } else { c_@@ index = i + 1 ; ans -= Math . min ( a_@@ index , b_@@ index ) ; } } return ans ; }
CAL@@ CUL@@ ATING_@@ FAC@@ TOR@@ I@@ AL@@ S_@@ USING_@@ ST@@ IR@@ LING_@@ APPRO@@ XI@@ MATION | public static int st@@ ir@@ ling@@ Fac@@ tori@@ al ( double n ) { if ( n == 1 ) return 1 ; double z ; double e = 2.@@ 71 ; z = Math . sqrt ( 2 * 3.14 * n ) * Math . pow ( ( n / e ) , n ) ; return ( int ) ( z ) ; }
LE@@ XI@@ CO@@ GRAPHIC@@ AL@@ LY@@ _S@@ MAL@@ LE@@ ST_@@ STRING_@@ OB@@ TA@@ IN@@ ED_@@ CON@@ CAT@@ EN@@ ATING_@@ ARRAY | static String lex@@ smallest ( String a [ ] , int n ) { sort ( a , n ) ; String answer = " " ; for ( int i = 0 ; i < n ; i ++ ) answer += a [ i ] ; return answer ; }
PRODUCT_@@ MAXIMUM_@@ FIRST_@@ ARRAY_@@ MIN@@ IM@@ UM@@ _SECOND | public static int min@@ Max@@ Product ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int n1 , int n2 ) { Arrays . sort ( ar@@ r1 ) ; Arrays . sort ( ar@@ r2 ) ; return ar@@ r1 [ n1 - 1 ] * ar@@ r2 [ 0 ] ; }
FIND_@@ IF_@@ THER@@ E_@@ IS_@@ A@@ _SUB@@ ARRAY_@@ WITH_@@ 0@@ _S@@ UM | static Boolean sub@@ Array@@ Exists ( int arr [ ] ) { HashMap < Integer , Integer > h@@ M = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 || sum == 0 || h@@ M . get ( sum ) != null ) return true ; h@@ M . put ( sum , i ) ; } return false ; }
MINIMUM_@@ PRODUCT_@@ SUB@@ SET_@@ ARRAY | static int min@@ Product@@ Subset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int neg@@ max = Integer . MIN_VALUE ; int pos@@ min = Integer . MAX_VALUE ; int count_@@ neg = 0 , count_@@ zero = 0 ; int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_@@ zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_@@ neg ++ ; neg@@ max = Math . max ( neg@@ max , a [ i ] ) ; } if ( a [ i ] > 0 && a [ i ] < pos@@ min ) pos@@ min = a [ i ] ; product *= a [ i ] ; } if ( count_@@ zero == n || ( count_@@ neg == 0 && count_@@ zero > 0 ) ) return 0 ; if ( count_@@ neg == 0 ) return pos@@ min ; if ( count_@@ neg % 2 == 0 && count_@@ neg != 0 ) { product = product / neg@@ max ; } return product ; }
NUMBER_@@ NODE@@ S_@@ TWO_@@ VER@@ TIC@@ ES_@@ AC@@ Y@@ CLI@@ C_@@ GRAPH_@@ DIS@@ JO@@ INT_@@ UNI@@ ON_@@ METHOD | static int total@@ Nodes ( Vector < Integer > ad@@ jac [ ] , int n , int x , int y ) { Boolean visited [ ] = new Boolean [ n + 1 ] ; Arrays . fill ( visited , false ) ; int p [ ] = new int [ n ] ; Queue < Integer > q = new LinkedList < > ( ) ; q . add ( x ) ; visited [ x ] = true ; int m ; while ( ! q . isEmpty ( ) ) { m = q . peek ( ) ; q . poll ( ) ; for ( int i = 0 ; i < ad@@ jac [ m ] . size ( ) ; ++ i ) { int h = ad@@ jac [ m ] . get ( i ) ; if ( visited [ h ] != true ) { visited [ h ] = true ; p [ h ] = m ; q . add ( h ) ; } } } int count = 0 ; int i = p [ y ] ; while ( i != x ) { count ++ ; i = p [ i ] ; } return count ; }
PRINT@@ ING_@@ STRING_@@ PL@@ US_@@ PATTERN_@@ MATRIX | static void car@@ ve@@ Cross ( String str ) { int n = str . length ( ) ; if ( n % 2 == 0 ) { System . out . print ( " Not ▁ possible . ▁ Please ▁ enter ▁ " + " odd ▁ length ▁ string . \n " ) ; } else { char arr [ ] [ ] = new char [ max ] [ max ] ; int m = n / 2 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = ' X ' ; } } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] [ m ] = str . charAt ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ m ] [ i ] = str . charAt ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( arr [ i ] [ j ] + " ▁ " ) ; } System . out . print ( " \n " ) ; } } }
NEXT_@@ GREATER_@@ FREQU@@ ENCY_@@ ELEMENT | static void NF@@ G ( int a [ ] , int n , int freq [ ] ) { Stack < Integer > s = new Stack < Integer > ( ) ; s . push ( 0 ) ; int res [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) res [ i ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( freq [ a [ s . peek ( ) ] ] > freq [ a [ i ] ] ) s . push ( i ) ; else { while ( freq [ a [ s . peek ( ) ] ] < freq [ a [ i ] ] && s . size ( ) > 0 ) { res [ s . peek ( ) ] = a [ i ] ; s . pop ( ) ; } s . push ( i ) ; } } while ( s . size ( ) > 0 ) { res [ s . peek ( ) ] = - 1 ; s . pop ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( res [ i ] + " ▁ " ) ; } }
CHECK_@@ REVER@@ SING@@ _SUB_@@ ARRAY_@@ MAKE_@@ ARRA@@ Y_S@@ OR@@ TED_@@ 1 | static boolean check@@ Reverse ( int arr [ ] , int n ) { if ( n == 1 ) { return true ; } int i ; for ( i = 1 ; arr [ i - 1 ] < arr [ i ] && i < n ; i ++ ) ; if ( i == n ) { return true ; } int j = i ++ ; while ( arr [ j ] < arr [ j - 1 ] ) { if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) { return false ; } j ++ ; } if ( j == n ) { return true ; } int k = j ; if ( arr [ k ] < arr [ i - 1 ] ) { return false ; } while ( k > 1 && k < n ) { if ( arr [ k ] < arr [ k - 1 ] ) { return false ; } k ++ ; } return true ; }
FIND_@@ TR@@ IP@@ LET@@ S_@@ ARRAY_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL_@@ ZERO_@@ 2 | static void find@@ Trip@@ lets ( int arr [ ] , int n ) { boolean found = false ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int l = i + 1 ; int r = n - 1 ; int x = arr [ i ] ; while ( l < r ) { if ( x + arr [ l ] + arr [ r ] == 0 ) { System . out . print ( x + " ▁ " ) ; System . out . print ( arr [ l ] + " ▁ " ) ; System . out . println ( arr [ r ] + " ▁ " ) ; l ++ ; r -- ; found = true ; } else if ( x + arr [ l ] + arr [ r ] < 0 ) l ++ ; else r -- ; } } if ( found == false ) System . out . println ( " ▁ No ▁ Trip@@ let ▁ Found " ) ; }
FIND_@@ ELEMEN@@ TS_@@ ARRAY_@@ LEA@@ ST_@@ TWO_@@ GREATER_@@ ELEMENTS | static void find@@ Elements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
POSITIVE_@@ ELEMEN@@ TS_@@ EV@@ EN_@@ NEGATIVE_@@ OD@@ D_@@ POSI@@ TIONS_@@ 1 | static void print@@ Array ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; System . out . println ( ) ; }
FIND_@@ MINIMUM_@@ RADI@@ US_@@ AT@@ LEA@@ ST_@@ K_@@ POINT_@@ LI@@ E_@@ IN@@ SIDE_@@ CIRC@@ LE | static int min@@ Radius ( int k , int [ ] x , int [ ] y , int n ) { int [ ] dis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; Arrays . sort ( dis ) ; return dis [ k - 1 ] ; }
COUNT_@@ SUB@@ ARRAY@@ S_@@ EQUAL_@@ NUMBER_@@ 1@@ S_@@ 0@@ S | static int count@@ Sub@@ arr@@ With@@ Equal@@ Zero@@ And@@ One ( int arr [ ] , int n ) { Map < Integer , Integer > um = new HashMap < > ( ) ; int curr_@@ sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_@@ sum += ( arr [ i ] == 0 ) ? - 1 : arr [ i ] ; um . put ( curr_@@ sum , um . get ( curr_@@ sum ) == null ? 1 : um . get ( curr_@@ sum ) + 1 ) ; } int count = 0 ; for ( Map . Entry < Integer , Integer > itr : um . entrySet ( ) ) { if ( itr . getValue ( ) > 1 ) count += ( ( itr . getValue ( ) * ( itr . getValue ( ) - 1 ) ) / 2 ) ; } if ( um . containsKey ( 0 ) ) count += um . get ( 0 ) ; return count ; }
MINIMUM_@@ INDEX@@ _S@@ UM_@@ COMMON_@@ ELEMEN@@ TS_@@ TWO_@@ LI@@ STS | static void find ( Vector < String > list1 , Vector < String > list2 ) { Vector < String > res = new Vector < > ( ) ; int max_@@ possible_@@ sum = list1 . size ( ) + list2 . size ( ) - 2 ; for ( int sum = 0 ; sum <= max_@@ possible_@@ sum ; sum ++ ) { for ( int i = 0 ; i <= sum ; i ++ ) if ( i < list1 . size ( ) && ( sum - i ) < list2 . size ( ) && list1 . get ( i ) == list2 . get ( sum - i ) ) res . add ( list1 . get ( i ) ) ; if ( res . size ( ) > 0 ) break ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . get ( i ) + " ▁ " ) ; }
CHECK_@@ IF_@@ A_@@ NUMBER_@@ IS_@@ JUM@@ B@@ LED_@@ OR_@@ NOT | static boolean check@@ J@@ umb@@ led ( int num ) { if ( num / 10 == 0 ) return true ; while ( num != 0 ) { if ( num / 10 == 0 ) return true ; int digit@@ 1 = num % 10 ; int digit@@ 2 = ( num / 10 ) % 10 ; if ( Math . abs ( digit@@ 2 - digit@@ 1 ) > 1 ) return false ; num = num / 10 ; } return true ; }
CEI@@ LING_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY_@@ 1 | static int ceil@@ Search ( int arr [ ] , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceil@@ Search ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceil@@ Search ( arr , low , mid - 1 , x ) ; } }
GI@@ V@@ EN_@@ P_@@ AND_@@ N_@@ FIND_@@ THE_@@ LAR@@ GE@@ ST_@@ X@@ _SU@@ CH_@@ TH@@ AT_@@ P@@ X_@@ DI@@ VIDE@@ S_@@ N_@@ 2 | static int Largest@@ power ( int n , int p ) { int ans = 0 ; while ( n > 0 ) { n /= p ; ans += n ; } return ans ; }
MAX@@ IM@@ UM@@ _S@@ UM_@@ I@@ AR@@ RI@@ _@@ AM@@ ONG_@@ ROTA@@ TIONS_@@ GI@@ V@@ EN_@@ ARRAY | static int max@@ Sum ( int arr [ ] , int n ) { int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_@@ sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_@@ sum += j * arr [ index ] ; } res = Math . max ( res , curr_@@ sum ) ; } return res ; }
MINIMUM_@@ LENGTH@@ _SUB@@ ARRA@@ Y_S@@ UM_@@ GREATER_@@ GI@@ V@@ EN_@@ VALUE_@@ 1 | static int smalle@@ st@@ Sub@@ With@@ Sum ( int arr [ ] , int n , int x ) { int curr_@@ sum = 0 , min_@@ len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_@@ sum <= x && end < n ) { if ( curr_@@ sum <= 0 && x > 0 ) { start = end ; curr_@@ sum = 0 ; } curr_@@ sum += arr [ end ++ ] ; } while ( curr_@@ sum > x && start < n ) { if ( end - start < min_@@ len ) min_@@ len = end - start ; curr_@@ sum -= arr [ start ++ ] ; } } return min_@@ len ; }
LE@@ XI@@ CO@@ GRAPHIC@@ AL@@ LY@@ _S@@ MAL@@ LE@@ ST_@@ STRING_@@ WHO@@ SE_@@ HAM@@ M@@ ING_@@ DISTAN@@ CE_@@ GI@@ V@@ EN_@@ STRING_@@ EXAC@@ TL@@ Y_@@ K | static void find@@ String ( String str , int n , int k ) { if ( k == 0 ) { System . out . println ( str ) ; ; return ; } String str2 = str ; int p = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str2 . charAt ( i ) != ' a ' ) { str2 = str2 . substring ( 0 , i ) + ' a ' + str2 . substring ( i + 1 ) ; p ++ ; if ( p == k ) break ; } } if ( p < k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == ' a ' ) { str2 = str2 . substring ( 0 , i ) + ' b ' + str2 . substring ( i + 1 ) ; p ++ ; if ( p == k ) break ; } } System . out . println ( str2 ) ; }
SUB@@ SET_@@ S@@ UM_@@ DI@@ VISI@@ BLE_@@ M | static boolean mod@@ ular@@ Sum ( int arr [ ] , int n , int m ) { if ( n > m ) return true ; boolean DP [ ] = new boolean [ m ] ; Arrays . fill ( DP , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; boolean temp [ ] = new boolean [ m ] ; Arrays . fill ( temp , false ) ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }
FIN@@ D_S@@ UM_@@ EV@@ EN_@@ INDEX_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENTS_@@ 1 | static int even@@ bin@@ omi@@ al@@ Coeff@@ Sum ( int n ) { return ( 1 << ( n - 1 ) ) ; }
EV@@ EN_@@ FI@@ BON@@ ACC@@ I_@@ NUMBER@@ S_S@@ UM | static int even@@ Fi@@ b@@ Sum ( int limit ) { if ( limit < 2 ) return 0 ; long ef@@ 1 = 0 , ef@@ 2 = 2 ; long sum = ef@@ 1 + ef@@ 2 ; while ( ef@@ 2 <= limit ) { long ef@@ 3 = 4 * ef@@ 2 + ef@@ 1 ; if ( ef@@ 3 > limit ) break ; ef@@ 1 = ef@@ 2 ; ef@@ 2 = ef@@ 3 ; sum += ef@@ 2 ; } return ( int ) sum ; }
MA@@ KING_@@ ELEMEN@@ TS_@@ OF_@@ TWO_@@ ARRAY@@ S_S@@ AME_@@ WITH_@@ MINIMUM_@@ INCRE@@ MENT@@ DECRE@@ MENT | static int Min@@ Operation ( int a [ ] , int b [ ] , int n ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] > b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; } return result ; }
REQUIRED_@@ MINIMUM_@@ DIG@@ IT@@ S_@@ REMOVE_@@ NUMBER_@@ MAKE_@@ PER@@ F@@ ECT_@@ SQUARE | static int perfec@@ t@@ Square ( String s ) { int n = s . length ( ) ; int ans = - 1 ; String num = " " ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { String str = " " ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( i > > j ) & 1 ) == 1 ) { str += s . charAt ( j ) ; } } if ( str . charAt ( 0 ) != '0' ) { int temp = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) temp = temp * 10 + ( int ) ( str . charAt ( j ) - '0' ) ; int k = ( int ) Math . sqrt ( temp ) ; if ( k * k == temp ) { if ( ans < ( int ) str . length ( ) ) { ans = ( int ) str . length ( ) ; num = str ; } } } } if ( ans == - 1 ) return ans ; else { System . out . print ( num + " ▁ " ) ; return n - ans ; } }
COUNT_@@ WOR@@ DS_@@ AP@@ PE@@ AR_@@ EXAC@@ TL@@ Y_@@ TWO_@@ TIME@@ S_@@ ARRAY_@@ WORDS | static int count@@ Words ( String str [ ] , int n ) { HashMap < String , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( str [ i ] ) ) { int get = m . get ( str [ i ] ) ; m . put ( str [ i ] , get + 1 ) ; } else { m . put ( str [ i ] , 1 ) ; } } int res = 0 ; for ( Map . Entry < String , Integer > it : m . entrySet ( ) ) { if ( it . getValue ( ) == 2 ) res ++ ; } return res ; }
COUNT_@@ SET_@@ BITS_@@ IN_@@ AN_@@ INTEGER_@@ 4 | static int count@@ Set@@ Bits@@ Rec ( int num ) { int ni@@ bble = 0 ; if ( 0 == num ) return num_@@ to_@@ bits [ 0 ] ; ni@@ bble = num & 0xf ; return num_@@ to_@@ bits [ ni@@ bble ] + count@@ Set@@ Bits@@ Rec ( num > > 4 ) ; }
MAXIMUM_@@ WEIGHT_@@ PATH_@@ END@@ ING_@@ ELEMENT_@@ LAST_@@ ROW_@@ MATRIX | public static int max@@ Cost ( int mat [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ N ] ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + Math . max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }
PER@@ F@@ ECT_@@ RE@@ VERSI@@ BLE_@@ STRING | static boolean is@@ Rever@@ sible ( String str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str . charAt ( i ) != str . charAt ( j ) ) return false ; i ++ ; j -- ; } return true ; }
FIN@@ D_S@@ UM_@@ OD@@ D_@@ FAC@@ TOR@@ S_@@ NUMBER | static int su@@ mo@@ fo@@ dd@@ Factors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_@@ sum = 1 ; int curr_@@ term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_@@ term *= i ; curr_@@ sum += curr_@@ term ; } res *= curr_@@ sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
MAX@@ IM@@ UM@@ _S@@ UM_@@ PATH_@@ MATRIX_@@ TOP_@@ BOTTOM | static int max@@ Sum ( int [ ] [ ] mat , int n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; int dp [ ] [ ] = new int [ n ] [ n ] ; int max@@ Sum = Integer . MIN_VALUE , max ; for ( int j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { max = Integer . MIN_VALUE ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( int j = 0 ; j < n ; j ++ ) if ( max@@ Sum < dp [ 0 ] [ j ] ) max@@ Sum = dp [ 0 ] [ j ] ; return max@@ Sum ; }
COUNT_@@ DIG@@ IT@@ S_@@ FAC@@ TOR@@ I@@ AL@@ _SET_@@ 1 | static int find@@ Digits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += Math . log10 ( i ) ; return ( int ) ( Math . floor ( digits ) ) + 1 ; }
FIND_@@ UN@@ COMMON_@@ CHARAC@@ TER@@ S_@@ TWO_@@ STRINGS | static void find@@ And@@ Print@@ Un@@ common@@ Chars ( String str1 , String str2 ) { int present [ ] = new int [ MAX_@@ CHAR ] ; for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) { present [ i ] = 0 ; } int l1 = str1 . length ( ) ; int l2 = str2 . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) { present [ str1 . charAt ( i ) - ' a ' ] = 1 ; } for ( int i = 0 ; i < l2 ; i ++ ) { if ( present [ str2 . charAt ( i ) - ' a ' ] == 1 || present [ str2 . charAt ( i ) - ' a ' ] == - 1 ) { present [ str2 . charAt ( i ) - ' a ' ] = - 1 ; } else { present [ str2 . charAt ( i ) - ' a ' ] = 2 ; } } for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) { if ( present [ i ] == 1 || present [ i ] == 2 ) { System . out . print ( ( char ) ( i + ' a ' ) + " ▁ " ) ; } } }
SQU@@ ARE_@@ ROOT_@@ OF_@@ AN_@@ INTEGER_@@ 1 | public static int floor@@ Sqrt ( int x ) { if ( x == 0 || x == 1 ) return x ; int start = 1 , end = x , ans = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( mid * mid == x ) return mid ; if ( mid * mid < x ) { start = mid + 1 ; ans = mid ; } else end = mid - 1 ; } return ans ; }
CHECK_@@ POSSI@@ BLE_@@ PATH_@@ 2D_@@ MATRIX | static boolean is@@ Path ( int arr [ ] [ ] ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) if ( arr [ 0 ] [ i ] != - 1 ) arr [ 0 ] [ i ] = arr [ 0 ] [ i - 1 ] ; for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ j ] [ 0 ] != - 1 ) arr [ j ] [ 0 ] = arr [ j - 1 ] [ 0 ] ; for ( int i = 1 ; i < 5 ; i ++ ) for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = Math . max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) ; }
NEW@@ MAN_@@ CON@@ WAY@@ _SEQU@@ ENCE_@@ 1 | static int sequence ( int n ) { int f [ ] = new int [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; int i ; for ( i = 3 ; i <= n ; i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; return f [ n ] ; }
PRINT_@@ WOR@@ DS_@@ STRING_@@ REVERSE_@@ ORDER | static String word@@ Reverse ( String str ) { int i = str . length ( ) - 1 ; int start , end = i + 1 ; String result = " " ; while ( i >= 0 ) { if ( str . charAt ( i ) == ' ▁ ' ) { start = i + 1 ; while ( start != end ) result += str . charAt ( start ++ ) ; result += ' ▁ ' ; end = i ; } i -- ; } start = 0 ; while ( start != end ) result += str . charAt ( start ++ ) ; return result ; }
FIND_@@ NUMBER_@@ END@@ LESS_@@ POINTS | static int count@@ End@@ less ( boolean input [ ] [ ] , int n ) { boolean row [ ] [ ] = new boolean [ n ] [ n ] ; boolean col [ ] [ ] = new boolean [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { boolean is@@ End@@ less = true ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( input [ i ] [ j ] == false ) is@@ End@@ less = false ; col [ i ] [ j ] = is@@ End@@ less ; } } for ( int i = 0 ; i < n ; i ++ ) { boolean is@@ End@@ less = true ; for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( input [ i ] [ j ] == false ) is@@ End@@ less = false ; row [ i ] [ j ] = is@@ End@@ less ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ; return ans ; }
CHECK_@@ POSSI@@ BLE_@@ TRANSFORM_@@ ONE_@@ STRING_@@ AN@@ OTHER | static boolean check ( String s1 , String s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; boolean dp [ ] [ ] = new boolean [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = false ; } } dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { for ( int j = 0 ; j <= s2 . length ( ) ; j ++ ) { if ( dp [ i ] [ j ] ) { if ( j < s2 . length ( ) && ( Character . toUpperCase ( s1 . charAt ( i ) ) == s2 . charAt ( j ) ) ) dp [ i + 1 ] [ j + 1 ] = true ; if ( ! Character . is@@ UpperCase ( s1 . charAt ( i ) ) ) dp [ i + 1 ] [ j ] = true ; } } } return ( dp [ n ] [ m ] ) ; }
CAL@@ CUL@@ ATE_@@ VOLUME_@@ DO@@ DE@@ CA@@ HE@@ DRO@@ N | static double vol_@@ of_@@ do@@ deca@@ hedron ( int side ) { return ( ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( Math . pow ( side , 3 ) ) ) ; }
PROGRAM_@@ FIND_@@ RE@@ MA@@ INDE@@ R_@@ LARGE_@@ NUMBER_@@ DI@@ VIDE@@ D_@@ 11 | static int remainder ( String str ) { int len = str . length ( ) ; int num , rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str . charAt ( i ) - '0' ) ; rem = num % 11 ; } return rem ; }
SORT_@@ STRING_@@ CHARAC@@ TERS | static void sort@@ String ( String str ) { char [ ] arr = str . toCharArray ( ) ; Arrays . sort ( arr ) ; System . out . print ( String . valueOf ( arr ) ) ; }
B@@ IR@@ TH@@ DAY_@@ PAR@@ ADO@@ X | static double find ( double p ) { return Math . ceil ( Math . sqrt ( 2 * 365 * Math . log ( 1 / ( 1 - p ) ) ) ) ; }
CHECK_@@ LINE_@@ PAS@@ SES_@@ ORIGIN | static boolean check@@ Origin ( int x1 , int y1 , int x2 , int y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; }
FIND_@@ ELEMEN@@ TS_@@ ARRAY_@@ LEA@@ ST_@@ TWO_@@ GREATER_@@ ELEMEN@@ TS_@@ 2 | static void find@@ Elements ( int arr [ ] , int n ) { int first = Integer . MIN_VALUE ; int second = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) System . out . print ( arr [ i ] + " ▁ " ) ; }
MIN@@ IM@@ UM@@ _S@@ UM@@ _SUB@@ SEQU@@ ENCE_@@ LEA@@ ST_@@ ONE_@@ EVER@@ Y_@@ FOUR_@@ CON@@ SEC@@ UTI@@ VE_@@ ELEMEN@@ TS_@@ PIC@@ KED_@@ 1 | static int min@@ Sum ( int ar [ ] , int n ) { if ( n <= 4 ) return Arrays . stream ( ar ) . min ( ) . getAs@@ Int ( ) ; int [ ] sum = new int [ n ] ; sum [ 0 ] = ar [ 0 ] ; sum [ 1 ] = ar [ 1 ] ; sum [ 2 ] = ar [ 2 ] ; sum [ 3 ] = ar [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) sum [ i ] = ar [ i ] + Arrays . stream ( Arrays . copy@@ Of@@ Range ( sum , i - 4 , i ) ) . min ( ) . getAs@@ Int ( ) ; return Arrays . stream ( Arrays . copy@@ Of@@ Range ( sum , n - 4 , n ) ) . min ( ) . getAs@@ Int ( ) ; }
CEI@@ LING_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY | static int ceil@@ Search ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }
SW@@ AP_@@ TWO_@@ NUMB@@ ERS_@@ WITH@@ OUT_@@ USING_@@ TEMPOR@@ ARY_@@ VARIABLE_@@ 1 | static void swap ( int xp , int yp ) { if ( xp == yp ) return ; xp = xp + yp ; yp = xp - yp ; xp = xp - yp ; }
MINIMUM_@@ NUMBER_OF_@@ MAN@@ IP@@ UL@@ ATION@@ S_@@ REQUIRED_@@ TO_@@ MAKE_@@ TWO_@@ STRING@@ S_@@ AN@@ AG@@ RAM_@@ WITH@@ OUT_@@ DELE@@ TION_@@ OF_@@ CHARACTER | static int count@@ Manip@@ ul@@ ations ( String s1 , String s2 ) { int count = 0 ; int char@@ _count [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) char@@ _count [ s1 . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) if ( char@@ _count [ s2 . charAt ( i ) - ' a ' ] -- <= 0 ) count ++ ; return count ; }
CHECK_@@ IF_@@ ALL_@@ THE_@@ ELEMEN@@ TS_@@ CAN_@@ BE_@@ MA@@ DE_@@ OF@@ _S@@ AME_@@ PAR@@ ITY_@@ BY_@@ INVER@@ TING_@@ AD@@ J@@ AC@@ ENT_@@ ELEMENTS | static boolean fli@@ ps@@ Possible ( int [ ] a , int n ) { int count_@@ odd = 0 , count_@@ even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] & 1 ) == 1 ) count_@@ odd ++ ; else count_@@ even ++ ; } if ( count_@@ odd % 2 == 1 && count_@@ even % 2 == 1 ) return false ; else return true ; }
CONVERT_@@ SUB@@ STRING@@ S_@@ LENGTH_@@ K_@@ BASE_@@ B_@@ DECIMAL | static void sub@@ string@@ Conversions ( String str , int k , int b ) { for ( int i = 0 ; i + k <= str . length ( ) ; i ++ ) { String sub = str . substring ( i , i + k ) ; int sum = 0 , counter = 0 ; for ( int j = sub . length ( ) - 1 ; j >= 0 ; j -- ) { sum = ( int ) ( sum + ( ( sub . charAt ( j ) - '0' ) * Math . pow ( b , counter ) ) ) ; counter ++ ; } System . out . print ( sum + " ▁ " ) ; } }
FIND_@@ K@@ _SU@@ CH_@@ TH@@ AT_@@ ALL_@@ ELEMEN@@ TS_@@ IN_@@ K@@ TH_@@ ROW_@@ ARE_@@ 0_@@ AND_@@ K@@ TH_@@ COLUMN_@@ ARE_@@ 1_@@ IN_@@ A_@@ BOOLEAN_@@ MATRIX | static int find ( boolean arr [ ] [ ] ) { int i = 0 , j = n - 1 ; int res = - 1 ; while ( i < n && j >= 0 ) { if ( arr [ i ] [ j ] == false ) { while ( j >= 0 && ( arr [ i ] [ j ] == false || i == j ) ) { j -- ; } if ( j == - 1 ) { res = i ; break ; } else { i ++ ; } } else { while ( i < n && ( arr [ i ] [ j ] == true || i == j ) ) { i ++ ; } if ( i == n ) { res = j ; break ; } else { j -- ; } } } if ( res == - 1 ) { return res ; } for ( int k = 0 ; k < n ; k ++ ) { if ( res != k && arr [ k ] [ res ] != true ) { return - 1 ; } } for ( int l = 0 ; l < n ; l ++ ) { if ( res != l && arr [ res ] [ l ] != false ) { return - 1 ; } } return res ; }
NUMBER_@@ ORDE@@ RED_@@ PAIR@@ S_@@ AI_@@ A@@ J@@ _0 | static int count@@ Pairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( a [ i ] & a [ j ] ) == 0 ) count += 2 ; } return count ; }
CI@@ R@@ CLE_@@ LAT@@ TIC@@ E_@@ POINTS | static int count@@ Lat@@ tice ( int r ) { if ( r <= 0 ) return 0 ; int result = 4 ; for ( int x = 1 ; x < r ; x ++ ) { int y@@ Square = r * r - x * x ; int y = ( int ) Math . sqrt ( y@@ Square ) ; if ( y * y == y@@ Square ) result += 4 ; } return result ; }
MINIMUM_@@ CHARAC@@ TER@@ S_@@ AD@@ DED_@@ FRONT_@@ MAKE_@@ STRING_@@ PA@@ LIN@@ DRO@@ ME | static boolean isp@@ al@@ ind@@ ro@@ me ( String s ) { int l = s . length ( ) ; for ( int i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s . charAt ( i ) != s . charAt ( j ) ) { return false ; } } return true ; }
K_@@ TH_@@ MISSING_@@ ELEMENT_@@ INCRE@@ AS@@ ING@@ _SEQU@@ ENCE_@@ NOT_@@ PRES@@ ENT_@@ GI@@ VEN@@ _SEQU@@ ENCE | static int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) { LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ; for ( int i = 0 ; i < n2 ; i ++ ) s . add ( b [ i ] ) ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( ! s . contains ( a [ i ] ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return - 1 ; }
PROGRAM_@@ CHECK_@@ IS@@ BN | static boolean isValid@@ IS@@ BN ( String is@@ bn ) { int n = is@@ bn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = is@@ bn . charAt ( i ) - '0' ; if ( 0 > digit || 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = is@@ bn . charAt ( 9 ) ; if ( last != ' X ' && ( last < '0' || last > '9' ) ) return false ; sum += ( ( last == ' X ' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; }
COUNT_@@ WAY@@ S_@@ INCRE@@ ASE_@@ LC@@ S_@@ LENGTH_@@ TWO_@@ STRING@@ S_@@ ONE | static int way@@ sTo@@ Increase@@ L@@ CS@@ By@@ 1 ( String str1 , String str2 ) { int m = str1 . length ( ) , n = str2 . length ( ) ; Vector < Integer > [ ] position = new Vector [ M ] ; for ( int i = 0 ; i < M ; i ++ ) position [ i ] = new Vector < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) position [ str2 . charAt ( i - 1 ) - ' a ' ] . add ( i ) ; int [ ] [ ] l@@ cs@@ l = new int [ m + 2 ] [ n + 2 ] ; int [ ] [ ] l@@ csr = new int [ m + 2 ] [ n + 2 ] ; for ( int i = 0 ; i <= m + 1 ; i ++ ) for ( int j = 0 ; j <= n + 1 ; j ++ ) l@@ cs@@ l [ i ] [ j ] = l@@ csr [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) l@@ cs@@ l [ i ] [ j ] = 1 + l@@ cs@@ l [ i - 1 ] [ j - 1 ] ; else l@@ cs@@ l [ i ] [ j ] = Math . max ( l@@ cs@@ l [ i - 1 ] [ j ] , l@@ cs@@ l [ i ] [ j - 1 ] ) ; } } for ( int i = m ; i >= 1 ; i -- ) { for ( int j = n ; j >= 1 ; j -- ) { if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) l@@ csr [ i ] [ j ] = 1 + l@@ csr [ i + 1 ] [ j + 1 ] ; else l@@ csr [ i ] [ j ] = Math . max ( l@@ csr [ i + 1 ] [ j ] , l@@ csr [ i ] [ j + 1 ] ) ; } } int ways = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( char d = 0 ; d < 26 ; d ++ ) { for ( int j = 0 ; j < position [ d ] . size ( ) ; j ++ ) { int p = position [ d ] . elementAt ( j ) ; if ( l@@ cs@@ l [ i ] [ p - 1 ] + l@@ csr [ i + 1 ] [ p + 1 ] == l@@ cs@@ l [ m ] [ n ] ) ways ++ ; } } } return ways ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 11_@@ EG@@ G_@@ DRO@@ PP@@ ING_@@ PU@@ ZZ@@ LE_@@ 1 | static int egg@@ Drop ( int n , int k ) { int egg@@ Floor [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; int res ; int i , j , x ; for ( i = 1 ; i <= n ; i ++ ) { egg@@ Floor [ i ] [ 1 ] = 1 ; egg@@ Floor [ i ] [ 0 ] = 0 ; } for ( j = 1 ; j <= k ; j ++ ) egg@@ Floor [ 1 ] [ j ] = j ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { egg@@ Floor [ i ] [ j ] = Integer . MAX_VALUE ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( egg@@ Floor [ i - 1 ] [ x - 1 ] , egg@@ Floor [ i ] [ j - x ] ) ; if ( res < egg@@ Floor [ i ] [ j ] ) egg@@ Floor [ i ] [ j ] = res ; } } } return egg@@ Floor [ n ] [ k ] ; }
WAY@@ S_TO_@@ WRITE_@@ N_@@ AS@@ _S@@ UM_@@ OF_@@ TWO_@@ OR_@@ MORE_@@ POSITIVE_@@ INTEG@@ ERS | static int count@@ W@@ ays ( int n ) { int table [ ] = new int [ n + 1 ] ; Arrays . fill ( table , 0 ) ; table [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) table [ j ] += table [ j - i ] ; return table [ n ] ; }
PROGR@@ AM@@ _S@@ UM_@@ COS@@ X@@ _SERI@@ ES | static double cos@@ X@@ Ser@@ ties@@ Sum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }
UNI@@ QUE_@@ CEL@@ LS_@@ BINARY_@@ MATRIX | static int count@@ Unique ( int mat [ ] [ ] , int n , int m ) { int [ ] row@@ sum = new int [ n ] ; int [ ] col@@ sum = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 ) { row@@ sum [ i ] ++ ; col@@ sum [ j ] ++ ; } int unique@@ count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 && row@@ sum [ i ] == 1 && col@@ sum [ j ] == 1 ) unique@@ count ++ ; return unique@@ count ; }
GRE@@ ED@@ Y_@@ ALGORITH@@ M_@@ TO_@@ FIND_@@ MINIMUM_@@ NUMBER_OF_@@ CO@@ INS | static void find@@ Min ( int V ) { Vector < Integer > ans = new Vector < > ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( V >= den@@ o [ i ] ) { V -= den@@ o [ i ] ; ans . add ( den@@ o [ i ] ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( " ▁ " + ans . elementAt ( i ) ) ; } }
CHECK_@@ INTEGER_@@ OVERFLOW_@@ MULTIP@@ LIC@@ ATION | static Boolean is@@ Overflow ( long a , long b ) { if ( a == 0 || b == 0 ) return false ; long result = a * b ; if ( a == result / b ) return false ; else return true ; }
DIFF@@ ER@@ ENCE_@@ BETWE@@ EN_@@ HIGH@@ EST_@@ AND_@@ LEA@@ ST_@@ FREQU@@ ENCI@@ ES_@@ IN_@@ AN_@@ ARRAY_@@ 1 | static int find@@ Diff ( int arr [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int max_@@ count = 0 , min_@@ count = n ; for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) { max_@@ count = Math . max ( max_@@ count , x . getValue ( ) ) ; min_@@ count = Math . min ( min_@@ count , x . getValue ( ) ) ; } return ( max_@@ count - min_@@ count ) ; }
COMPOSI@@ TE_@@ NUMBER | static boolean is@@ Composite ( int n ) { if ( n <= 1 ) System . out . println ( " False " ) ; if ( n <= 3 ) System . out . println ( " False " ) ; if ( n % 2 == 0 || n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }
LAR@@ GE@@ ST_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQU@@ ENCE_@@ OF_@@ CON@@ SEC@@ UTI@@ VE_@@ INTEG@@ ERS | static void find@@ LI@@ S ( int A [ ] , int n ) { Map < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; int LI@@ S_@@ size = 1 ; int LI@@ S_@@ index = 0 ; hash . put ( A [ 0 ] , 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { hash . put ( A [ i ] , hash . get ( A [ i ] - 1 ) == null ? 1 : hash . get ( A [ i ] - 1 ) + 1 ) ; if ( LI@@ S_@@ size < hash . get ( A [ i ] ) ) { LI@@ S_@@ size = hash . get ( A [ i ] ) ; LI@@ S_@@ index = A [ i ] ; } } System . out . println ( " LI@@ S _ size ▁ = ▁ " + LI@@ S_@@ size ) ; System . out . print ( " LI@@ S ▁ : ▁ " ) ; int start = LI@@ S_@@ index - LI@@ S_@@ size + 1 ; while ( start <= LI@@ S_@@ index ) { System . out . print ( start + " ▁ " ) ; start ++ ; } }
COUNT_@@ SET_@@ BITS_@@ IN_@@ AN_@@ INTEGER_@@ 2 | static int count@@ Set@@ Bits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
FIND_@@ FOUR_@@ ELEMEN@@ TS_@@ A_@@ B_@@ C_@@ AND_@@ D_@@ IN_@@ AN_@@ ARRAY@@ _SU@@ CH_@@ TH@@ AT_@@ AB_@@ CD | boolean find@@ Pairs ( int arr [ ] ) { HashMap < Integer , pair > map = new HashMap < Integer , pair > ( ) ; int n = arr . length ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int sum = arr [ i ] + arr [ j ] ; if ( ! map . containsKey ( sum ) ) map . put ( sum , new pair ( i , j ) ) ; else { pair p = map . get ( sum ) ; System . out . println ( " ( " + arr [ p . first ] + " , ▁ " + arr [ p . second ] + " ) ▁ and ▁ ( " + arr [ i ] + " , ▁ " + arr [ j ] + " ) " ) ; return true ; } } } return false ; }
COUNT_@@ OB@@ T@@ USE_@@ ANG@@ LES_@@ CI@@ R@@ CLE_@@ K_@@ EQU@@ ID@@ I@@ STAN@@ T_@@ POINT@@ S_@@ 2_@@ GI@@ V@@ EN_@@ POINTS | static int count@@ Ob@@ t@@ use@@ Angles ( int a , int b , int k ) { int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return min ( c1 , c2 ) ; }
NUMBER_@@ TRIANG@@ LES_@@ N_@@ MOVE@@ S_@@ 1 | public static double numberOf@@ Triangles ( int n ) { double ans = 2 * ( pow ( 3 , n ) ) - 1 ; return ans ; }
FIND_@@ A_@@ REPE@@ ATING_@@ AND_@@ A_@@ MISSING_@@ NUMBER | static void print@@ Two@@ Elements ( int arr [ ] , int size ) { int i ; System . out . print ( " The ▁ repe@@ ating ▁ element ▁ is ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { int abs_@@ val = Math . abs ( arr [ i ] ) ; if ( arr [ abs_@@ val - 1 ] > 0 ) arr [ abs_@@ val - 1 ] = - arr [ abs_@@ val - 1 ] ; else System . out . println ( abs_@@ val ) ; } System . out . print ( " And ▁ the ▁ missing ▁ element ▁ is ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) System . out . println ( i + 1 ) ; } }
MINIMUM_@@ DIFF@@ ER@@ ENCE_@@ BETWE@@ EN_@@ GROUP@@ S_@@ OF@@ _SIZE_@@ TWO | static long calculate ( long a [ ] , int n ) { Arrays . sort ( a ) ; int i , j ; Vector < Long > s = new Vector < > ( ) ; for ( i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . add ( ( a [ i ] + a [ j ] ) ) ; long mini = Collections . min ( s ) ; long max@@ i = Collections . max ( s ) ; return Math . abs ( max@@ i - mini ) ; }
FIND_@@ PER@@ I@@ ME@@ TER_@@ CY@@ LIN@@ DER | static int per@@ imeter ( int diameter , int height ) { return 2 * ( diameter + height ) ; }
MAG@@ ICAL_@@ INDI@@ CES_@@ ARRAY | static int solve ( int [ ] A , int n ) { int i , cnt = 0 , j ; int [ ] parent = new int [ n + 1 ] ; int [ ] vis = new int [ n + 1 ] ; for ( i = 0 ; i < n + 1 ; i ++ ) { parent [ i ] = - 1 ; vis [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { j = i ; if ( parent [ j ] == - 1 ) { while ( parent [ j ] == - 1 ) { parent [ j ] = i ; j = ( j + A [ j ] + 1 ) % n ; } if ( parent [ j ] == i ) { while ( vis [ j ] == 0 ) { vis [ j ] = 1 ; cnt ++ ; j = ( j + A [ j ] + 1 ) % n ; } } } } return cnt ; }
FIND_@@ A_@@ FIXED_@@ POINT_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ 1 | static int binary@@ Search ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binary@@ Search ( arr , ( mid + 1 ) , high ) ; else return binary@@ Search ( arr , low , ( mid - 1 ) ) ; } return - 1 ; }
FIN@@ D@@ _SIZE_@@ OF_THE_@@ LAR@@ GE@@ ST_@@ FOR@@ MED_@@ BY_@@ ALL_@@ ONE@@ S_IN_@@ A_@@ BINARY_@@ MATRIX | static int find@@ Largest@@ Plus ( int mat [ ] [ ] ) { int left [ ] [ ] = new int [ N ] [ N ] ; int right [ ] [ ] = new int [ N ] [ N ] ; int top [ ] [ ] = new int [ N ] [ N ] ; int bottom [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { top [ 0 ] [ i ] = mat [ 0 ] [ i ] ; bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] ; left [ i ] [ 0 ] = mat [ i ] [ 0 ] ; right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ; else left [ i ] [ j ] = 0 ; if ( mat [ j ] [ i ] == 1 ) top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 ; else top [ j ] [ i ] = 0 ; j = N - 1 - j ; if ( mat [ j ] [ i ] == 1 ) bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 ; else bottom [ j ] [ i ] = 0 ; if ( mat [ i ] [ j ] == 1 ) right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 ; else right [ i ] [ j ] = 0 ; j = N - 1 - j ; } } int n = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int len = Math . min ( Math . min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , Math . min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) ; if ( len > n ) n = len ; } } if ( n > 0 ) return 4 * ( n - 1 ) + 1 ; return 0 ; }
LEVEL_@@ NODE_@@ TREE_@@ SOURCE_@@ NODE_@@ USING_@@ B@@ FS | static void print@@ Levels ( Vector < Vector < Integer > > graph , int V , int x ) { int level [ ] = new int [ V ] ; boolean marked [ ] = new boolean [ V ] ; Queue < Integer > que = new LinkedList < Integer > ( ) ; que . add ( x ) ; level [ x ] = 0 ; marked [ x ] = true ; while ( que . size ( ) > 0 ) { x = que . peek ( ) ; que . remove ( ) ; for ( int i = 0 ; i < graph . get ( x ) . size ( ) ; i ++ ) { int b = graph . get ( x ) . get ( i ) ; if ( ! marked [ b ] ) { que . add ( b ) ; level [ b ] = level [ x ] + 1 ; marked [ b ] = true ; } } } System . out . println ( " Nodes " + " ▁ " + " Level " ) ; for ( int i = 0 ; i < V ; i ++ ) System . out . println ( " ▁ " + i + " ▁ - - > ▁ " + level [ i ] ) ; }
FIN@@ D_S@@ QU@@ ARE_@@ ROOT_@@ UN@@ DER_@@ MODUL@@ O_@@ P@@ _SET_@@ 1_@@ WH@@ EN_@@ P_@@ IS_@@ IN_@@ FORM_@@ OF_@@ 4@@ I_@@ 3 | static void square@@ Root ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) { if ( ( x * x ) % p == n ) { System . out . println ( " Square ▁ " + " root ▁ is ▁ " + x ) ; return ; } } System . out . println ( " Square ▁ root ▁ " + " doesn ' t ▁ exist " ) ; }
CHECK_@@ IF_@@ ARRAY_@@ ELEMEN@@ TS_@@ ARE_@@ CON@@ SEC@@ UTI@@ VE | boolean are@@ Con@@ sec@@ utive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int min = get@@ Min ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { boolean visited [ ] = new boolean [ n ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - min ] != false ) return false ; visited [ arr [ i ] - min ] = true ; } return true ; } return false ; }
SM@@ ALLE@@ ST@@ _SUB@@ SET_@@ S@@ UM_@@ GREATER_@@ ELEMENTS | static int min@@ Elements ( int arr [ ] , int n ) { int half@@ Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) half@@ Sum = half@@ Sum + arr [ i ] ; half@@ Sum = half@@ Sum / 2 ; Arrays . sort ( arr ) ; int res = 0 , curr_@@ sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { curr_@@ sum += arr [ i ] ; res ++ ; if ( curr_@@ sum > half@@ Sum ) return res ; } return res ; }
S@@ UM_@@ OF_@@ ALL_@@ ELEMEN@@ TS_@@ UP_@@ TO_@@ N@@ TH_@@ ROW_@@ IN_@@ A_@@ PAS@@ CAL@@ S_@@ TRIANGLE_@@ 1 | static long calculate@@ Sum ( int n ) { long sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
SW@@ AP_@@ TWO_@@ NI@@ BB@@ LES_@@ BYTE | static int swap@@ Ni@@ bb@@ les ( int x ) { return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) > > 4 ) ; }
CHECK_@@ CHARAC@@ TER@@ S_@@ GI@@ V@@ EN_@@ STRING_@@ CAN_@@ RE@@ AR@@ RANGE@@ D_@@ FORM_@@ PA@@ LIN@@ DRO@@ ME_@@ 1 | static boolean can@@ Form@@ Pal@@ ind@@ ro@@ me ( String str ) { List < Character > list = new ArrayList < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( list . contains ( str . charAt ( i ) ) ) list . remove ( ( Character ) str . charAt ( i ) ) ; else list . add ( str . charAt ( i ) ) ; } if ( str . length ( ) % 2 == 0 && list . isEmpty ( ) || ( str . length ( ) % 2 == 1 && list . size ( ) == 1 ) ) return true ; else return false ; }
WAY@@ S@@ _SP@@ LIT_@@ STRING_@@ PARTITION_@@ STAR@@ TS_@@ DISTIN@@ CT_@@ CHARACTER | static int count@@ W@@ ays ( String s ) { int count [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) count [ s . charAt ( i ) - ' a ' ] ++ ; count [ s . charAt ( 0 ) - ' a ' ] = 1 ; int ans = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; }
ENTR@@ ING@@ ER_@@ NUMBER_@@ 1 | static int zig@@ z@@ ag ( int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= Math . min ( i , k ) ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; } return dp [ n ] [ k ] ; }
COUNT_@@ PAIR@@ S_@@ DIFF@@ ER@@ ENCE_@@ EQUAL_@@ K | static int count@@ Pai@@ rs@@ With@@ Diff@@ K ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }
EXPEC@@ TATION_@@ EXPECTED_@@ VALUE_@@ ARRAY | static float calc_@@ Expect@@ ation ( float a [ ] , float n ) { float pr@@ b = ( 1 / n ) ; float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] * pr@@ b ; return sum ; }
GROUP_@@ OC@@ CURR@@ EN@@ CES_@@ CHARAC@@ TER@@ S_@@ AC@@ COR@@ DING_@@ FIRST_@@ AP@@ PE@@ AR@@ ANCE | static void print@@ Group@@ ed ( String str ) { int n = str . length ( ) ; int count [ ] = new int [ MAX_@@ CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) count [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { while ( count [ str . charAt ( i ) - ' a ' ] != 0 ) { System . out . print ( str . charAt ( i ) ) ; count [ str . charAt ( i ) - ' a ' ] -- ; } count [ str . charAt ( i ) - ' a ' ] = 0 ; } }
MAXIMUM_@@ PATH@@ _S@@ UM_@@ POSITION_@@ JUM@@ PS_@@ DI@@ VISIBILITY_@@ CONDITION | static void print@@ Max@@ Sum ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; Arrays . fill ( dp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; int max@@ i = 0 ; for ( int j = 1 ; j <= Math . sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > max@@ i ) max@@ i = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > max@@ i && j != 1 ) max@@ i = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += max@@ i ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( dp [ i ] + " ▁ " ) ; }
PROGRAM_@@ CIRCUM@@ FER@@ ENCE_@@ PARALLE@@ LOG@@ RAM | static float circum@@ ference@@ paralle@@ log@@ ram ( float a , float b ) { return ( ( 2 * a ) + ( 2 * b ) ) ; }
COUNT_@@ POSSI@@ BLE_@@ PATH@@ S_@@ TOP_@@ LEFT_@@ BOTTOM_@@ RIGHT_@@ NX@@ M_@@ MATRIX_@@ 2 | static int numberOf@@ Paths ( int m , int n ) { int [ ] dp = new int [ n ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] += dp [ j - 1 ] ; } } return dp [ n - 1 ] ; }
REMOVE_@@ MINIMUM_@@ NUMBER_@@ CHARAC@@ TER@@ S_@@ TWO_@@ STRING@@ S_@@ BE@@ COM@@ E_@@ AN@@ AG@@ RAM | static int rem@@ An@@ agram ( String str1 , String str2 ) { int count@@ 1 [ ] = new int [ 26 ] ; int count2 [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) count@@ 1 [ str1 . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) count2 [ str2 . charAt ( i ) - ' a ' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += Math . abs ( count@@ 1 [ i ] - count2 [ i ] ) ; return result ; }
S@@ UM_@@ DI@@ VI@@ SOR@@ S_@@ 1_@@ N_@@ 1 | static int di@@ visor@@ Sum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }
FIND_@@ LENGTH_@@ LON@@ GE@@ ST@@ _SUB@@ SEQU@@ ENCE_@@ ONE_@@ STRING@@ _SUB@@ STRING_@@ AN@@ OTHER_@@ STRING | static int max@@ Sub@@ sequence@@ Sub@@ string ( char x [ ] , char y [ ] , int n , int m ) { int dp [ ] [ ] = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( x [ j - 1 ] == y [ i - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) ans = Math . max ( ans , dp [ i ] [ n ] ) ; return ans ; }
S@@ UM_@@ FA@@ I_@@ A@@ J_@@ PAIR@@ S_@@ ARRAY_@@ N_@@ INTEG@@ ERS | public static int sum ( int a [ ] , int n ) { Map < Integer , Integer > cnt = new HashMap < Integer , Integer > ( ) ; int ans = 0 , pre_@@ sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( i * a [ i ] ) - pre_@@ sum ; pre_@@ sum += a [ i ] ; if ( cnt . containsKey ( a [ i ] - 1 ) ) ans -= cnt . get ( a [ i ] - 1 ) ; if ( cnt . containsKey ( a [ i ] + 1 ) ) ans += cnt . get ( a [ i ] + 1 ) ; if ( cnt . containsKey ( a [ i ] ) ) { cnt . put ( a [ i ] , cnt . get ( a [ i ] ) + 1 ) ; } else { cnt . put ( a [ i ] , 1 ) ; } } return ans ; }
BINARY_@@ RE@@ PRESEN@@ TATION_@@ OF_@@ A_@@ GI@@ V@@ EN_@@ NUMBER | static void bin ( int n ) { if ( n > 1 ) bin ( n / 2 ) ; System . out . print ( n % 2 ) ; }
KN@@ AP@@ S@@ ACK_@@ PRO@@ BLE@@ M | static int kn@@ ap@@ S@@ ack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return kn@@ ap@@ S@@ ack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + kn@@ ap@@ S@@ ack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , kn@@ ap@@ S@@ ack ( W , wt , val , n - 1 ) ) ; }
DOUBLE_@@ FAC@@ TOR@@ I@@ AL_@@ 1 | static int double@@ factorial ( int n ) { int res = 1 ; for ( int i = n ; i >= 0 ; i = i - 2 ) { if ( i == 0 || i == 1 ) return res ; else res *= i ; } return res ; }
COUNT_@@ DIG@@ IT@@ S_@@ FAC@@ TOR@@ I@@ AL@@ _SET_@@ 2 | static long find@@ Digits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( n * Math . log10 ( n / M_@@ E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 ) ; return ( long ) Math . floor ( x ) + 1 ; }
DE@@ LAN@@ NO@@ Y_@@ NUMBER_@@ 1 | static int de@@ al@@ n@@ no@@ y ( int n , int m ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }
FIND_@@ THE_@@ MISSING_@@ NUMBER_@@ 2 | static int get@@ Missing@@ No ( int a [ ] , int n ) { int x1 = a [ 0 ] ; int x2 = 1 ; for ( int i = 1 ; i < n ; i ++ ) x1 = x1 ^ a [ i ] ; for ( int i = 2 ; i <= n + 1 ; i ++ ) x2 = x2 ^ i ; return ( x1 ^ x2 ) ; }
FIND_@@ NUMBER_OF_@@ TRIANG@@ LES_@@ POSSI@@ BLE | static int find@@ NumberOf@@ Triangles ( int arr [ ] ) { int n = arr . length ; Arrays . sort ( arr ) ; int count = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { int k = i + 2 ; for ( int j = i + 1 ; j < n ; ++ j ) { while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ k ; if ( k > j ) count += k - j - 1 ; } } return count ; }
NUMBER_@@ TRIANG@@ LES_@@ N_@@ MOV@@ ES | public static int numberOf@@ Triangles ( int n ) { int [ ] answer = new int [ n + 1 ] ; answer [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) answer [ i ] = answer [ i - 1 ] * 3 + 2 ; return answer [ n ] ; }
CHECK@@ _S@@ UM@@ S_@@ TH_@@ ROW_@@ TH_@@ COLUMN_@@ MATRIX | static boolean are@@ Sum@@ Same ( int a [ ] [ ] , int n , int m ) { int sum@@ 1 = 0 , sum@@ 2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum@@ 1 = 0 ; sum@@ 2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum@@ 1 += a [ i ] [ j ] ; sum@@ 2 += a [ j ] [ i ] ; } if ( sum@@ 1 == sum@@ 2 ) return true ; } return false ; }
WRITE_@@ ONE_@@ LINE_@@ C_@@ FUNCTION_@@ TO_@@ FIND_@@ WHE@@ THER_@@ A_@@ NO_@@ IS_@@ POWER_@@ OF_@@ TWO | static boolean is@@ PowerOf@@ Two ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 2 != 0 ) return false ; n = n / 2 ; } return true ; }
PUT_@@ SPAC@@ ES_@@ WOR@@ DS_@@ START@@ ING_@@ CAPI@@ TAL_@@ LET@@ TERS | public static void am@@ end@@ Sentence ( String s@@ str ) { char [ ] str = s@@ str . toCharArray ( ) ; for ( int i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { str [ i ] = ( char ) ( str [ i ] + 32 ) ; if ( i != 0 ) System . out . print ( " ▁ " ) ; System . out . print ( str [ i ] ) ; } else System . out . print ( str [ i ] ) ; } }
CHECK_@@ DI@@ VISIBILITY_@@ BINARY_@@ STRING_@@ 2@@ K | static boolean is@@ Di@@ visible ( String str , int k ) { int n = str . length ( ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str . charAt ( n - i - 1 ) == '0' ) c ++ ; return ( c == k ) ; }
SUB@@ SEQU@@ EN@@ CE@@ S@@ _SIZE_@@ THRE@@ E_@@ ARRAY_@@ WHO@@ SE_@@ S@@ UM_@@ DI@@ VISI@@ BLE_@@ M | static int co@@ ut@@ Sub@@ Seq ( int A [ ] , int N , int M ) { int sum = 0 ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; }
LON@@ GE@@ ST_@@ CON@@ SEC@@ UTI@@ VE_@@ SUB@@ SEQUENCE | static int find@@ Lon@@ gest@@ Con@@ seq@@ Sub@@ seq ( int arr [ ] , int n ) { HashSet < Integer > S = new HashSet < Integer > ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) S . add ( arr [ i ] ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! S . contains ( arr [ i ] - 1 ) ) { int j = arr [ i ] ; while ( S . contains ( j ) ) j ++ ; if ( ans < j - arr [ i ] ) ans = j - arr [ i ] ; } } return ans ; }
FIND_@@ INDEX_@@ GI@@ V@@ EN_@@ FI@@ BON@@ ACC@@ I_@@ NUMBER_@@ CONSTANT_@@ TIME_@@ 1 | static int find@@ Index ( int n ) { float fi@@ bo = 2.@@ 07@@ 808@@ 7@@ F * ( float ) Math . log ( n ) + 1.@@ 67@@ 22@@ 76@@ F ; return Math . round ( fi@@ bo ) ; }
LAR@@ GE@@ ST_@@ DI@@ VISI@@ BLE_@@ PAIR@@ S@@ _SUB@@ SET | static int lar@@ gest@@ Subset ( int [ ] a , int n ) { Arrays . sort ( a ) ; int [ ] dp = new int [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mx@@ m = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) { mx@@ m = Math . max ( mx@@ m , dp [ j ] ) ; } } dp [ i ] = 1 + mx@@ m ; } return Arrays . stream ( dp ) . max ( ) . getAs@@ Int ( ) ; }
FIND_@@ WHE@@ THER_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ IS_@@ A_@@ POWER_@@ OF_@@ 4_@@ OR_@@ NOT_@@ 2 | static boolean is@@ PowerOf@@ Four ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ( n & 0x@@ AAAA@@ AAAA ) == 0 ; }
COMP@@ UTE_@@ NC@@ R_@@ P@@ _SET_@@ 1_@@ INTRO@@ DUC@@ TION_@@ AND_@@ DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G_S@@ OL@@ U@@ TION | static int n@@ Cr@@ Mod@@ p ( int n , int r , int p ) { int C [ ] = new int [ r + 1 ] ; Arrays . fill ( C , 0 ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; }
ROUND_@@ THE_@@ GI@@ V@@ EN_@@ NUMBER_@@ TO_@@ NEARE@@ ST_@@ MULTIPLE_@@ OF_@@ 10 | static int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; }
SORT_@@ EV@@ EN_@@ NUMB@@ ERS_@@ ASC@@ END@@ ING_@@ ORDER@@ _S@@ ORT_@@ OD@@ D_@@ NUMB@@ ERS_@@ DESC@@ END@@ ING_@@ ORDER_@@ 1 | static void two@@ Way@@ Sort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; }
POINT_@@ CLI@@ PP@@ ING_@@ ALGORITH@@ M_@@ COMP@@ UT@@ ER_@@ GRAPHIC@@ S | static void point@@ Clip ( int XY [ ] [ ] , int n , int X@@ min , int Y@@ min , int X@@ max , int Y@@ max ) { System . out . printf ( " Point ▁ inside ▁ the ▁ view@@ ing ▁ pane : \n " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( XY [ i ] [ 0 ] >= X@@ min ) && ( XY [ i ] [ 0 ] <= X@@ max ) ) { if ( ( XY [ i ] [ 1 ] >= Y@@ min ) && ( XY [ i ] [ 1 ] <= Y@@ max ) ) System . out . printf ( " [ % d , ▁ % d ] ▁ " , XY [ i ] [ 0 ] , XY [ i ] [ 1 ] ) ; } } System . out . printf ( " \n Point ▁ outside ▁ the ▁ view@@ ing ▁ pane : \n " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( XY [ i ] [ 0 ] < X@@ min ) || ( XY [ i ] [ 0 ] > X@@ max ) ) System . out . printf ( " [ % d , ▁ % d ] ▁ " , XY [ i ] [ 0 ] , XY [ i ] [ 1 ] ) ; if ( ( XY [ i ] [ 1 ] < Y@@ min ) || ( XY [ i ] [ 1 ] > Y@@ max ) ) System . out . printf ( " [ % d , ▁ % d ] ▁ " , XY [ i ] [ 0 ] , XY [ i ] [ 1 ] ) ; } }
WAY@@ S_@@ TRANS@@ FORM@@ ING_@@ ONE_@@ STRING_@@ REMO@@ V@@ ING_@@ 0_@@ CHARAC@@ TERS | static int count@@ Transformation ( String a , String b ) { int n = a . length ( ) , m = b . length ( ) ; if ( m == 0 ) { return 1 ; } int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( i == 0 ) { if ( j == 0 ) { dp [ i ] [ j ] = ( a . charAt ( j ) == b . charAt ( i ) ) ? 1 : 0 ; } else if ( a . charAt ( j ) == b . charAt ( i ) ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 ; } else { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } else if ( a . charAt ( j ) == b . charAt ( i ) ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } } return dp [ m - 1 ] [ n - 1 ] ; }
FIND_@@ RELATIVE_@@ COMPLE@@ MENT_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S | static void relative@@ Comp@@ lement ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( ar@@ r1 [ i ] < ar@@ r2 [ j ] ) { System . out . print ( ar@@ r1 [ i ] + " ▁ " ) ; i ++ ; } else if ( ar@@ r1 [ i ] > ar@@ r2 [ j ] ) { j ++ ; } else if ( ar@@ r1 [ i ] == ar@@ r2 [ j ] ) { i ++ ; j ++ ; } } while ( i < n ) System . out . print ( ar@@ r1 [ i ] + " ▁ " ) ; }
COUNT_@@ INDEX_@@ PAIR@@ S_@@ EQUAL_@@ ELEMEN@@ TS_@@ ARRAY | static int count@@ Pairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; }
GI@@ V@@ EN_@@ AN_@@ ARRAY_@@ OF_@@ PAIR@@ S_@@ FIND_@@ ALL_@@ SYM@@ METRIC_@@ PAIR@@ S_IN_@@ IT | static void find@@ Sym@@ Pairs ( int arr [ ] [ ] ) { HashMap < Integer , Integer > h@@ M = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { int first = arr [ i ] [ 0 ] ; int sec = arr [ i ] [ 1 ] ; Integer val = h@@ M . get ( sec ) ; if ( val != null && val == first ) System . out . println ( " ( " + sec + " , ▁ " + first + " ) " ) ; else h@@ M . put ( first , sec ) ; } }
COUNT_@@ SUB@@ SEQU@@ EN@@ CES_@@ PRODUCT_@@ LESS_@@ K | public static int product@@ Sub@@ Seq@@ Count ( ArrayList < Integer > arr , int k ) { int n = arr . size ( ) ; int dp [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; if ( arr . get ( j - 1 ) <= i && arr . get ( j - 1 ) > 0 ) dp [ i ] [ j ] += dp [ i / arr . get ( j - 1 ) ] [ j - 1 ] + 1 ; } } return dp [ k ] [ n ] ; }
RE@@ AR@@ RANGE_@@ ARRAY_@@ AR@@ RI@@ _@@ ARR@@ J_@@ EV@@ EN_@@ AR@@ RI | public static void re@@ arrange@@ Arr ( int arr [ ] , int n ) { int even@@ Pos = n / 2 ; int odd@@ Pos = n - even@@ Pos ; int [ ] temp@@ Arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) temp@@ Arr [ i ] = arr [ i ] ; Arrays . sort ( temp@@ Arr ) ; int j = odd@@ Pos - 1 ; for ( int i = 0 ; i < n ; i += 2 ) { arr [ i ] = temp@@ Arr [ j ] ; j -- ; } j = odd@@ Pos ; for ( int i = 1 ; i < n ; i += 2 ) { arr [ i ] = temp@@ Arr [ j ] ; j ++ ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
MINIMUM_@@ ROTA@@ TIONS_@@ UN@@ LOCK_@@ CIRC@@ ULAR_@@ LOCK | static int min@@ Rotation ( int input , int un@@ lock_@@ code ) { int rotation = 0 ; int input_@@ digit , code_@@ digit ; while ( input > 0 || un@@ lock_@@ code > 0 ) { input_@@ digit = input % 10 ; code_@@ digit = un@@ lock_@@ code % 10 ; rotation += Math . min ( Math . abs ( input_@@ digit - code_@@ digit ) , 10 - Math . abs ( input_@@ digit - code_@@ digit ) ) ; input /= 10 ; un@@ lock_@@ code /= 10 ; } return rotation ; }
RE@@ AR@@ RANGE_@@ BINARY_@@ STRING_@@ ALTER@@ N@@ ATE_@@ X_@@ Y_@@ OC@@ CURR@@ EN@@ CES | static void arrange@@ String ( String str , int x , int y ) { int count_@@ 0 = 0 ; int count_@@ 1 = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '0' ) count_@@ 0 ++ ; else count_@@ 1 ++ ; } while ( count_@@ 0 > 0 || count_@@ 1 > 0 ) { for ( int j = 0 ; j < x && count_@@ 0 > 0 ; j ++ ) { if ( count_@@ 0 > 0 ) { System . out . print ( "0" ) ; count_@@ 0 -- ; } } for ( int j = 0 ; j < y && count_@@ 1 > 0 ; j ++ ) { if ( count_@@ 1 > 0 ) { System . out . print ( "1" ) ; count_@@ 1 -- ; } } } }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 14_@@ MAX@@ IM@@ UM@@ _S@@ UM_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQUENCE | static int max@@ Sum@@ IS ( int arr [ ] , int n ) { int i , j , max = 0 ; int m@@ sis [ ] = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) m@@ sis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && m@@ sis [ i ] < m@@ sis [ j ] + arr [ i ] ) m@@ sis [ i ] = m@@ sis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < m@@ sis [ i ] ) max = m@@ sis [ i ] ; return max ; }
NUMBER_@@ UNI@@ QUE_@@ REC@@ TA@@ NG@@ LES_@@ FOR@@ MED_@@ USING_@@ N_@@ UNIT_@@ SQU@@ AR@@ ES | static int count@@ Rect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= Math . sqrt ( n ) ; ++ length ) for ( int height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }
PROGRAM_@@ TO_@@ PRINT_@@ TE@@ TRA@@ HE@@ DR@@ AL_@@ NUMB@@ ERS_@@ UP@@ TO_@@ N@@ TH_@@ TERM | static void print@@ Series ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) / 6 ; System . out . print ( num + " ▁ " ) ; } }
PROGRAM_@@ TO_@@ FIND_@@ TRANSP@@ OS@@ E_@@ OF_@@ A_@@ MATRIX | static void transpose ( int A [ ] [ ] , int B [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; }
PROGRAM_@@ DECIMAL_@@ BINARY_@@ CON@@ VERSION_@@ 1 | public void dec@@ To@@ Binary ( int n ) { for ( int i = 31 ; i >= 0 ; i -- ) { int k = n > > i ; if ( ( k & 1 ) > 0 ) System . out . print ( "1" ) ; else System . out . print ( "0" ) ; } }
RE@@ AR@@ RANGE_@@ ARRAY_@@ ORDER@@ _S@@ MAL@@ LE@@ ST_@@ LAR@@ GE@@ ST_@@ 2@@ N@@ D_S@@ MAL@@ LE@@ ST_@@ 2@@ N@@ D_@@ LAR@@ GE@@ ST | static void re@@ arrange@@ Array ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int [ ] temp@@ Arr = new int [ n ] ; int Arr@@ Index = 0 ; for ( int i = 0 , j = n - 1 ; i <= n / 2 || j > n / 2 ; i ++ , j -- ) { if ( Arr@@ Index < n ) { temp@@ Arr [ Arr@@ Index ] = arr [ i ] ; Arr@@ Index ++ ; } if ( Arr@@ Index < n ) { temp@@ Arr [ Arr@@ Index ] = arr [ j ] ; Arr@@ Index ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp@@ Arr [ i ] ; }
S@@ UM_@@ AREA_@@ REC@@ TA@@ NG@@ LES_@@ POSSI@@ BLE_@@ ARRAY | static int Max@@ Total@@ Rectangle@@ Area ( int [ ] a , int n ) { Arrays . sort ( a ) ; int sum = 0 ; boolean flag = false ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ! flag ) { flag = true ; len = a [ i + 1 ] ; i ++ ; } else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i ++ ; } } return sum ; }
GI@@ V@@ EN_@@ BINARY_@@ STRING_@@ COUNT_@@ NUMBER@@ _SUB@@ STRING@@ S_@@ START_@@ END_@@ 1 | int count@@ Sub@@ Str ( char str [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] == '1' ) res ++ ; } } } return res ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 3@@ 1_@@ OP@@ TIM@@ AL_@@ STRATEG@@ Y_@@ FOR_@@ A_@@ GAME | static int optim@@ al@@ Strategy@@ Of@@ Game ( int arr [ ] , int n ) { int table [ ] [ ] = new int [ n ] [ n ] ; int gap , i , j , x , y , z ; for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = Math . max ( arr [ i ] + Math . min ( x , y ) , arr [ j ] + Math . min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }
REPL@@ ACE_@@ CHARACTER_@@ C@@ 1_@@ C@@ 2_@@ C@@ 2_@@ C@@ 1_@@ STRING_@@ S | static String replace ( String s , char c1 , char c2 ) { int l = s . length ( ) ; char [ ] arr = s . toCharArray ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( arr [ i ] == c1 ) arr [ i ] = c2 ; else if ( arr [ i ] == c2 ) arr [ i ] = c1 ; } return String . valueOf ( arr ) ; }
FIND_@@ THE_@@ LAR@@ GE@@ ST@@ _SUB@@ ARRAY_@@ WITH_@@ 0@@ _S@@ UM@@ _1 | static int maxLen ( int arr [ ] ) { HashMap < Integer , Integer > h@@ M = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; int max_len = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1 ; if ( sum == 0 ) max_len = i + 1 ; Integer prev_@@ i = h@@ M . get ( sum ) ; if ( prev_@@ i != null ) max_len = Math . max ( max_len , i - prev_@@ i ) ; else h@@ M . put ( sum , i ) ; } return max_len ; }
PROGRAM_@@ PRINT_@@ S@@ UM_@@ GI@@ V@@ EN_@@ N@@ TH_@@ TER@@ M_@@ 1 | static int summ@@ ing@@ Series ( long n ) { return ( int ) Math . pow ( n , 2 ) ; }
RECUR@@ SIVE_@@ C_@@ PROGRAM_@@ LINE@@ AR@@ LY@@ _SEARCH_@@ ELEMENT_@@ GI@@ V@@ EN_@@ ARRAY | static int rec@@ Search ( int arr [ ] , int l , int r , int x ) { if ( r < l ) return - 1 ; if ( arr [ l ] == x ) return l ; if ( arr [ r ] == x ) return r ; return rec@@ Search ( arr , l + 1 , r - 1 , x ) ; }
PRINT_@@ SHOR@@ TEST_@@ PATH_@@ PRINT_@@ STRING@@ _S@@ CRE@@ EN | static void print@@ Path ( String str ) { int i = 0 ; int cur@@ X = 0 , cur@@ Y = 0 ; while ( i < str . length ( ) ) { int next@@ X = ( str . charAt ( i ) - ' A ' ) / 5 ; int next@@ Y = ( str . charAt ( i ) - ' B ' + 1 ) % 5 ; while ( cur@@ X > next@@ X ) { System . out . println ( " Move ▁ Up " ) ; cur@@ X -- ; } while ( cur@@ Y > next@@ Y ) { System . out . println ( " Move ▁ Left " ) ; cur@@ Y -- ; } while ( cur@@ X < next@@ X ) { System . out . println ( " Move ▁ Down " ) ; cur@@ X ++ ; } while ( cur@@ Y < next@@ Y ) { System . out . println ( " Move ▁ Right " ) ; cur@@ Y ++ ; } System . out . println ( " Press ▁ OK " ) ; i ++ ; } }
COUNT_@@ EN@@ TRI@@ ES_@@ EQUAL_@@ TO_@@ X_@@ IN_@@ A@@ _SPECI@@ AL_@@ MATRIX | static int count ( int n , int x ) { int count = 0 ; for ( int i = 1 ; i <= n && i <= x ; i ++ ) { if ( x / i <= n && x % i == 0 ) count ++ ; } return count ; }
PROGRAM_@@ FIND_@@ LINE_@@ PASS@@ ING_@@ 2_@@ POINTS | static void line@@ From@@ Points ( Pair P , Pair Q ) { int a = Q . second - P . second ; int b = P . first - Q . first ; int c = a * ( P . first ) + b * ( P . second ) ; if ( b < 0 ) { System . out . println ( " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ " + a + " x ▁ " + b + " y ▁ = ▁ " + c ) ; } else { System . out . println ( " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ " + a + " x ▁ + ▁ " + b + " y ▁ = ▁ " + c ) ; } }
REMOVE_@@ ARRAY_@@ END_@@ ELEMENT_@@ MAXI@@ MI@@ ZE_@@ S@@ UM_@@ PRODUCT | static int solve ( int dp [ ] [ ] , int a [ ] , int low , int high , int turn ) { if ( low == high ) { return a [ low ] * turn ; } if ( dp [ low ] [ high ] != 0 ) { return dp [ low ] [ high ] ; } dp [ low ] [ high ] = Math . max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; return dp [ low ] [ high ] ; }
CHECK_@@ GRAP@@ H@@ S_@@ CY@@ CLE_@@ OD@@ D_@@ LENGTH | public static boolean contains@@ Odd ( int G [ ] [ ] , int src ) { int color@@ Arr [ ] = new int [ V ] ; for ( int i = 0 ; i < V ; ++ i ) color@@ Arr [ i ] = - 1 ; color@@ Arr [ src ] = 1 ; LinkedList < Integer > q = new LinkedList < Integer > ( ) ; q . add ( src ) ; while ( ! q . isEmpty ( ) ) { int u = q . peek ( ) ; q . pop ( ) ; if ( G [ u ] [ u ] == 1 ) return true ; for ( int v = 0 ; v < V ; ++ v ) { if ( G [ u ] [ v ] == 1 && color@@ Arr [ v ] == - 1 ) { color@@ Arr [ v ] = 1 - color@@ Arr [ u ] ; q . push ( v ) ; } else if ( G [ u ] [ v ] == 1 && color@@ Arr [ v ] == color@@ Arr [ u ] ) return true ; } } return false ; }
SUM@@ _SERI@@ ES_@@ ALTER@@ N@@ ATE_@@ SIGNE@@ D_S@@ QUAR@@ ES_@@ AP | static int se@@ i@@ res@@ Sum ( int n , int [ ] a ) { int res = 0 , i ; for ( i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }
PROGRAM_@@ DECIMAL_@@ BINARY_@@ CONVERSION | static void dec@@ To@@ Binary ( int n ) { int [ ] binary@@ Num = new int [ 32 ] ; int i = 0 ; while ( n > 0 ) { binary@@ Num [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( binary@@ Num [ j ] ) ; }
LON@@ GE@@ ST_@@ ALTER@@ N@@ ATING_@@ POSITIVE_@@ NEGATIVE_@@ SUB@@ ARRAY_@@ START@@ ING_@@ EVER@@ Y_@@ INDEX | public static void lon@@ gest@@ Altern@@ ating ( int arr [ ] , int n ) { int [ ] count = new int [ n ] ; count [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( count [ i ] + " ▁ " ) ; }
FIND_@@ STRING_@@ LE@@ XI@@ CO@@ GRAP@@ HI@@ C_@@ ORDER_@@ GI@@ V@@ EN_@@ TWO_@@ STRINGS | static String lex@@ Next ( String str , int n ) { char [ ] s = str . toCharArray ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != ' z ' ) { s [ i ] ++ ; return String . valueOf ( s ) ; } s [ i ] = ' a ' ; } return null ; }
NUMBER_@@ DECIMAL_@@ NUMB@@ ERS_@@ LENGTH_@@ K_@@ STRICT_@@ MON@@ OT@@ ONE | static int getNum@@ Strict@@ Mon@@ ot@@ one ( int len ) { int [ ] [ ] DP = new int [ len ] [ D@@ P_@@ s ] ; for ( int i = 0 ; i < D@@ P_@@ s ; ++ i ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 1 ; i < len ; ++ i ) for ( int j = 1 ; j < D@@ P_@@ s ; ++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] ; return DP [ len - 1 ] [ D@@ P_@@ s - 1 ] ; }
PRINT_@@ POSSI@@ BLE_@@ ED@@ GE@@ S_@@ TREE_@@ GI@@ V@@ EN_@@ DI@@ AME@@ TER_@@ HEIGHT_@@ VER@@ TIC@@ ES | static void construct@@ Tree ( int n , int d , int h ) { if ( d == 1 ) { if ( n == 2 && h == 1 ) { System . out . println ( "1 ▁ 2" ) ; return ; } System . out . println ( " - 1" ) ; return ; } if ( d > 2 * h ) { System . out . println ( " - 1" ) ; return ; } for ( int i = 1 ; i <= h ; i ++ ) System . out . println ( i + " ▁ " + ( i + 1 ) ) ; if ( d > h ) { System . out . println ( "1" + " ▁ " + ( h + 2 ) ) ; for ( int i = h + 2 ; i <= d ; i ++ ) { System . out . println ( i + " ▁ " + ( i + 1 ) ) ; } } for ( int i = d + 1 ; i < n ; i ++ ) { int k = 1 ; if ( d == h ) k = 2 ; System . out . println ( k + " ▁ " + ( i + 1 ) ) ; } }
MIN@@ IM@@ AL_@@ OPER@@ ATION@@ S_@@ MAKE_@@ NUMBER_@@ MAG@@ ICAL | static int calculate ( String s ) { int ans = 6 ; for ( int i = 0 ; i < 10 ; ++ i ) { for ( int j = 0 ; j < 10 ; ++ j ) { for ( int k = 0 ; k < 10 ; ++ k ) { for ( int l = 0 ; l < 10 ; ++ l ) { for ( int m = 0 ; m < 10 ; ++ m ) { for ( int n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { int c = 0 ; if ( i != s . charAt ( 0 ) - '0' ) c ++ ; if ( j != s . charAt ( 1 ) - '0' ) c ++ ; if ( k != s . charAt ( 2 ) - '0' ) c ++ ; if ( l != s . charAt ( 3 ) - '0' ) c ++ ; if ( m != s . charAt ( 4 ) - '0' ) c ++ ; if ( n != s . charAt ( 5 ) - '0' ) c ++ ; if ( c < ans ) ans = c ; } } } } } } } return ans ; }
FIND_@@ A_@@ TR@@ IP@@ LET_@@ TH@@ AT_@@ S@@ UM_@@ TO_@@ A_@@ GI@@ V@@ EN_@@ VALUE | boolean find@@ 3@@ Numbers ( int A [ ] , int arr_@@ size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_@@ size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_@@ size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_@@ size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { System . out . print ( " Trip@@ let ▁ is ▁ " + A [ i ] + " , ▁ " + A [ j ] + " , ▁ " + A [ k ] ) ; return true ; } } } } return false ; }
AREA_@@ OF_THE_@@ CI@@ R@@ CLE_@@ TH@@ AT_@@ HAS_@@ A@@ _S@@ QU@@ ARE_@@ AND_@@ A_@@ CI@@ R@@ CLE_@@ IN@@ SCRI@@ BED_@@ IN_@@ IT | static float get@@ Area ( int a ) { float area = ( float ) ( Math . PI * a * a ) / 4 ; return area ; }
GI@@ V@@ EN_@@ TWO_@@ UN@@ SOR@@ TED_@@ ARRAY@@ S_@@ FIND_@@ PAIR@@ S_@@ WHO@@ SE_@@ S@@ UM_@@ X_@@ 1 | public static void find@@ Pairs ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int n , int m , int x ) { HashMap < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . put ( ar@@ r1 [ i ] , 0 ) ; for ( int j = 0 ; j < m ; j ++ ) if ( s . containsKey ( x - ar@@ r2 [ j ] ) ) System . out . println ( x - ar@@ r2 [ j ] + " ▁ " + ar@@ r2 [ j ] ) ; }
QU@@ IC@@ K_@@ WA@@ Y_@@ CHECK_@@ CHARAC@@ TER@@ S_@@ STRING | static boolean all@@ Characters@@ Same ( String s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) if ( s . charAt ( i ) != s . charAt ( 0 ) ) return false ; return true ; }
RE@@ AR@@ RANGE_@@ ARRAY_@@ AR@@ RI | public static int [ ] fix ( int [ ] A ) { for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] != - 1 && A [ i ] != i ) { int x = A [ i ] ; while ( A [ x ] != - 1 && A [ x ] != x ) { int y = A [ x ] ; A [ x ] = x ; x = y ; } A [ x ] = x ; if ( A [ i ] != i ) { A [ i ] = - 1 ; } } } return A ; }
PA@@ IR_@@ WITH_@@ GI@@ V@@ EN_@@ PRODUCT_@@ SET_@@ 1_@@ FIND_@@ IF_@@ ANY_@@ PA@@ IR_@@ EXISTS | boolean is@@ Product ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; }
SORT_@@ GI@@ V@@ EN_@@ STRING_@@ USING_@@ CHARAC@@ TER@@ _SEARCH | static String sort@@ String ( String str , int n ) { String new_@@ str = " " ; for ( int i = ' a ' ; i <= ' z ' ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( str . charAt ( j ) == i ) new_@@ str += str . charAt ( j ) ; return new_@@ str ; }
COUNT_@@ OF_@@ OC@@ CURR@@ EN@@ CES_@@ OF_@@ A_@@ 101@@ _@@ PATTERN_@@ IN_@@ A_@@ STRING | static int count@@ Pattern ( String str ) { int len = str . length ( ) ; boolean one@@ Seen = false ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char getChar = str . charAt ( i ) ; if ( getChar == '1' && one@@ Seen == true ) { if ( str . charAt ( i - 1 ) == '0' ) count ++ ; } if ( getChar == '1' && one@@ Seen == false ) one@@ Seen = true ; if ( getChar != '0' && str . charAt ( i ) != '1' ) one@@ Seen = false ; } return count ; }
C_@@ PROGRAM_@@ CY@@ CLIC@@ AL@@ LY_@@ ROTA@@ TE_@@ ARRAY_@@ ONE | static void rotate ( ) { int x = arr [ arr . length - 1 ] , i ; for ( i = arr . length - 1 ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = x ; }
QUEUE_@@ BAS@@ ED_@@ APPRO@@ ACH@@ _@@ FOR_@@ FIRST_@@ NON_@@ REPE@@ ATING_@@ CHARACTER_@@ IN_@@ A_@@ STREAM | static void first@@ Non@@ Repe@@ ating ( String str ) { int [ ] char@@ Count = new int [ MAX_@@ CHAR ] ; Queue < Character > q = new LinkedList < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; q . add ( ch ) ; char@@ Count [ ch - ' a ' ] ++ ; while ( ! q . isEmpty ( ) ) { if ( char@@ Count [ q . peek ( ) - ' a ' ] > 1 ) q . remove ( ) ; else { System . out . print ( q . peek ( ) + " ▁ " ) ; break ; } } if ( q . isEmpty ( ) ) System . out . print ( - 1 + " ▁ " ) ; } System . out . println ( ) ; }
CHECK_@@ LARGE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 6_@@ NOT | static boolean check ( String str ) { int n = str . length ( ) ; if ( ( str . charAt ( n - 1 ) - '0' ) % 2 != 0 ) return false ; int digit@@ Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digit@@ Sum += ( str . charAt ( i ) - '0' ) ; return ( digit@@ Sum % 3 == 0 ) ; }
MINIMUM_@@ NUMBER_@@ OF@@ _S@@ QUAR@@ ES_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL@@ S_TO_@@ GI@@ V@@ EN_@@ NUMBER_@@ N | static int getMin@@ Squ@@ ares ( int n ) { if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMin@@ Squ@@ ares ( n - temp ) ) ; } return res ; }
OVER@@ L@@ APP@@ ING_S@@ UM_@@ TWO_@@ ARRAY | static int find@@ Sum ( int [ ] A , int [ ] B , int n ) { HashMap < Integer , Integer > hash = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash . containsKey ( A [ i ] ) ) hash . put ( A [ i ] , 1 + hash . get ( A [ i ] ) ) ; else hash . put ( A [ i ] , 1 ) ; if ( hash . containsKey ( B [ i ] ) ) hash . put ( B [ i ] , 1 + hash . get ( B [ i ] ) ) ; else hash . put ( B [ i ] , 1 ) ; } int sum = 0 ; for ( Map . Entry entry : hash . entrySet ( ) ) { if ( Integer . parseInt ( ( entry . getValue ( ) ) . toString ( ) ) == 1 ) sum += Integer . parseInt ( ( entry . getKey ( ) ) . toString ( ) ) ; } return sum ; }
MOBI@@ LE_@@ NUMERIC_@@ KEY@@ PAD_@@ PRO@@ BLE@@ M | static int getCount ( char keyp@@ ad [ ] [ ] , int n ) { if ( keyp@@ ad == null || n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; int [ ] odd = new int [ 10 ] ; int [ ] even = new int [ 10 ] ; int i = 0 , j = 0 , use@@ Odd = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) odd [ i ] = 1 ; for ( j = 2 ; j <= n ; j ++ ) { use@@ Odd = 1 - use@@ Odd ; if ( use@@ Odd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 8 ] ; even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] ; even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] ; even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] ; even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] ; even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] ; even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] ; even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ; even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ; even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] ; } else { odd [ 0 ] = even [ 0 ] + even [ 8 ] ; odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] ; odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] ; odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] ; odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] ; odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] ; odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] ; odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] ; odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] ; odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] ; } } totalCount = 0 ; if ( use@@ Odd == 1 ) { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += even [ i ] ; } else { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += odd [ i ] ; } return totalCount ; }
FIND_@@ ELEMEN@@ TS_@@ L@@ ARG@@ ER_@@ HALF_@@ ELEMEN@@ TS_@@ ARRAY | static void find@@ Lar@@ ger ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = n - 1 ; i >= n / 2 ; i -- ) System . out . print ( arr [ i ] + " ▁ " ) ; }
S@@ UM_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENTS | static int bin@@ omi@@ al@@ Coeff@@ Sum ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += C [ n ] [ i ] ; return sum ; }
FIND_@@ COMMON_@@ ELEMENT_@@ RO@@ WS_@@ ROW_@@ WI@@ SE_@@ SOR@@ TED_@@ MATRIX_@@ 1 | static int find@@ Common ( int mat [ ] [ ] ) { HashMap < Integer , Integer > cnt = new HashMap < Integer , Integer > ( ) ; int i , j ; for ( i = 0 ; i < M ; i ++ ) { if ( cnt . containsKey ( mat [ i ] [ 0 ] ) ) { cnt . put ( mat [ i ] [ 0 ] , cnt . get ( mat [ i ] [ 0 ] ) + 1 ) ; } else { cnt . put ( mat [ i ] [ 0 ] , 1 ) ; } for ( j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) if ( cnt . containsKey ( mat [ i ] [ j ] ) ) { cnt . put ( mat [ i ] [ j ] , cnt . get ( mat [ i ] [ j ] ) + 1 ) ; } else { cnt . put ( mat [ i ] [ j ] , 1 ) ; } } } for ( Map . Entry < Integer , Integer > ele : cnt . entrySet ( ) ) { if ( ele . getValue ( ) == M ) return ele . getKey ( ) ; } return - 1 ; }
SI@@ EV@@ E_@@ ER@@ ATO@@ ST@@ HE@@ NE@@ S_@@ 0@@ N_@@ TIME_@@ COMPLE@@ X@@ ITY | static void manipul@@ ated_@@ se@@ ive ( int N ) { i@@ spri@@ me . set ( 0 , false ) ; i@@ spri@@ me . set ( 1 , false ) ; for ( int i = 2 ; i < N ; i ++ ) { if ( i@@ spri@@ me . get ( i ) ) { prime . add ( i ) ; SP@@ F . set ( i , i ) ; } for ( int j = 0 ; j < prime . size ( ) && i * prime . get ( j ) < N && prime . get ( j ) <= SP@@ F . get ( i ) ; j ++ ) { i@@ spri@@ me . set ( i * prime . get ( j ) , false ) ; SP@@ F . set ( i * prime . get ( j ) , prime . get ( j ) ) ; } } }
COUNT_@@ SOR@@ TED_@@ RO@@ WS_@@ MATRIX | static int sorted@@ Count ( int mat [ ] [ ] , int r , int c ) { int result = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = 0 ; j < c - 1 ; j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ; if ( j == c - 1 ) result ++ ; } for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = c - 1 ; j > 0 ; j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ; if ( c > 1 && j == 0 ) result ++ ; } return result ; }
NUMBER_@@ WAY@@ S_@@ NODE_@@ MAKE_@@ LOOP@@ _SIZE_@@ K_@@ UN@@ DIREC@@ TED_@@ COMPLETE_@@ CONNEC@@ TED_@@ GRAPH_@@ N_@@ NODES | static int numOf@@ ways ( int n , int k ) { int p = 1 ; if ( k % 2 != 0 ) p = - 1 ; return ( int ) ( Math . pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; }
DI@@ CE_@@ THROW_@@ PRO@@ BLE@@ M | public static long find@@ W@@ ays ( int m , int n , int x ) { long [ ] [ ] table = new long [ n + 1 ] [ x + 1 ] ; for ( int j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= x ; j ++ ) { for ( int k = 1 ; k < j && k <= m ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; } } return table [ n ] [ x ] ; }
MINIMUM_@@ NUMBER_@@ DELE@@ TIONS_@@ MAKE_@@ STRING_@@ PA@@ LIN@@ DRO@@ ME_@@ SET_@@ 2 | static int get@@ Lev@@ en@@ stein ( StringBuilder input ) { StringBuilder rev@@ Input = new StringBuilder ( input ) ; rev@@ Input = rev@@ Input . reverse ( ) ; int n = input . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) { dp [ 0 ] [ i ] = i ; dp [ i ] [ 0 ] = i ; } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { if ( input . charAt ( i - 1 ) == rev@@ Input . charAt ( j - 1 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } int res = Integer . MAX_VALUE ; for ( int i = n , j = 0 ; i >= 0 ; i -- , j ++ ) { res = Math . min ( res , dp [ i ] [ j ] ) ; if ( i < n ) res = Math . min ( res , dp [ i + 1 ] [ j ] ) ; if ( i > 0 ) res = Math . min ( res , dp [ i - 1 ] [ j ] ) ; } return res ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 37@@ _@@ BOOLEAN_@@ PARENTHE@@ SIZ@@ ATION_@@ PRO@@ BLE@@ M | static int count@@ Paren@@ th ( char sym@@ b [ ] , char oper [ ] , int n ) { int F [ ] [ ] = new int [ n ] [ n ] ; int T [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { F [ i ] [ i ] = ( sym@@ b [ i ] == ' F ' ) ? 1 : 0 ; T [ i ] [ i ] = ( sym@@ b [ i ] == ' T ' ) ? 1 : 0 ; } for ( int gap = 1 ; gap < n ; ++ gap ) { for ( int i = 0 , j = gap ; j < n ; ++ i , ++ j ) { T [ i ] [ j ] = F [ i ] [ j ] = 0 ; for ( int g = 0 ; g < gap ; g ++ ) { int k = i + g ; int ti@@ k = T [ i ] [ k ] + F [ i ] [ k ] ; int tk@@ j = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ; if ( oper [ k ] == ' & ' ) { T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ; F [ i ] [ j ] += ( ti@@ k * tk@@ j - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == ' | ' ) { F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] ; T [ i ] [ j ] += ( ti@@ k * tk@@ j - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == ' ^ ' ) { T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ; F [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ; } } } } return T [ 0 ] [ n - 1 ] ; }
PYTHON_@@ PROGRAM_@@ FIND_@@ PER@@ I@@ ME@@ TER_@@ CIRCUM@@ FER@@ ENCE_@@ SQU@@ ARE_@@ REC@@ TAN@@ GLE_@@ 1 | static int Cir@@ cum@@ ference ( int l , int w ) { return ( 2 * ( l + w ) ) ; }
THIR@@ D_@@ LAR@@ GE@@ ST_@@ ELEMENT_@@ ARRAY_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ 1 | static void third@@ Lar@@ gest ( int arr [ ] , int arr_@@ size ) { if ( arr_@@ size < 3 ) { System . out . printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] , second = Integer . MIN_VALUE , third = Integer . MIN_VALUE ; for ( int i = 1 ; i < arr_@@ size ; i ++ ) { if ( arr [ i ] > first ) { third = second ; second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { third = second ; second = arr [ i ] ; } else if ( arr [ i ] > third ) { third = arr [ i ] ; } } System . out . printf ( " The ▁ third ▁ Lar@@ gest ▁ element ▁ is ▁ % d \n " , third ) ; }
MINIMUM_@@ ROO@@ MS_@@ FOR_@@ M_@@ EV@@ ENTS_@@ OF_@@ N_@@ BAT@@ CHE@@ S_@@ WITH_@@ GI@@ VEN@@ _SCH@@ EDUL@@ E | static int find@@ Min@@ Roo@@ ms ( String slots [ ] , int n , int m ) { int counts [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) counts [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] . charAt ( j ) == '1' ) counts [ j ] ++ ; int max = - 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ; return max ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SUB@@ SET_@@ S@@ UM_@@ PRO@@ BLE@@ M | static boolean isSub@@ set@@ Sum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSub@@ set@@ Sum ( set , n - 1 , sum ) ; return isSub@@ set@@ Sum ( set , n - 1 , sum ) || isSub@@ set@@ Sum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
COUNT_@@ WAY@@ S_@@ DI@@ VI@@ DE_@@ CI@@ R@@ CLE_@@ USING_@@ N_@@ NON_@@ INTER@@ SEC@@ TING_@@ CH@@ OR@@ DS | static int ch@@ ord@@ Cnt ( int A ) { int n = 2 * A ; int [ ] dp@@ Array = new int [ n + 1 ] ; dp@@ Array [ 0 ] = 1 ; dp@@ Array [ 2 ] = 1 ; for ( int i = 4 ; i <= n ; i += 2 ) { for ( int j = 0 ; j < i - 1 ; j += 2 ) { dp@@ Array [ i ] += ( dp@@ Array [ j ] * dp@@ Array [ i - 2 - j ] ) ; } } return dp@@ Array [ n ] ; }
BREAK_@@ NUMBER_@@ THRE@@ E_@@ PAR@@ TS_@@ 1 | static long count_@@ of_@@ ways ( long n ) { long count = 0 ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
PRINT_@@ DIG@@ IT@@ S_@@ POSITION_@@ REMO@@ VED_@@ MAKE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 6 | static void gre@@ atest ( String s ) { int n = s . length ( ) ; int [ ] a = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = s . charAt ( i ) - '0' ; sum += a [ i ] ; } if ( a [ n - 1 ] % 2 != 0 ) { if ( a [ n - 2 ] % 2 != 0 || ( sum - a [ n - 1 ] ) % 3 != 0 ) { System . out . println ( " - 1" ) ; } else { System . out . println ( n ) ; } } else { int re = sum % 3 ; int del = - 1 ; int flag = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] ) % 3 == re ) { if ( a [ i + 1 ] > a [ i ] ) { del = i ; flag = 1 ; break ; } else { del = i ; } } } if ( flag == 0 ) { if ( a [ n - 2 ] % 2 == 0 && re == a [ n - 1 ] % 3 ) del = n - 1 ; } if ( del == - 1 ) System . out . println ( - 1 ) ; else { System . out . println ( del + 1 ) ; } } }
MAXIMUM_@@ HEIGHT_@@ OF_@@ TRIANG@@ ULAR_@@ AR@@ RANGE@@ MENT_@@ OF_@@ ARRAY_@@ VALUES | static int Maximum@@ Height ( int [ ] a , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; }
SQU@@ AR@@ ED_@@ TRIANG@@ ULAR_@@ NUMBER@@ _S@@ UM_@@ CU@@ B@@ ES | static int find@@ S ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return - 1 ; }
EVALU@@ ATE_@@ A_@@ BOOLEAN_@@ EXPRES@@ SION_@@ RE@@ PRESEN@@ TED_@@ AS_@@ STRING | static int evaluate@@ Bool@@ Expr ( StringBuffer s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i += 2 ) { if ( i + 1 < n && i + 2 < n ) { if ( s . charAt ( i + 1 ) == ' A ' ) { if ( s . charAt ( i + 2 ) == '0' || s . charAt ( i ) == 0 ) s . set@@ Char@@ At ( i + 2 , '0' ) ; else s . set@@ Char@@ At ( i + 2 , '1' ) ; } else if ( ( i + 1 ) < n && s . charAt ( i + 1 ) == ' B ' ) { if ( s . charAt ( i + 2 ) == '1' || s . charAt ( i ) == '1' ) s . set@@ Char@@ At ( i + 2 , '1' ) ; else s . set@@ Char@@ At ( i + 2 , '0' ) ; } else { if ( s . charAt ( i + 2 ) == s . charAt ( i ) ) s . set@@ Char@@ At ( i + 2 , '0' ) ; else s . set@@ Char@@ At ( i + 2 , '1' ) ; } } } return s . charAt ( n - 1 ) - '0' ; }
PROGR@@ AM@@ M@@ ING_@@ PU@@ ZZ@@ LE_@@ ASSIGN_@@ VALUE_@@ WITH@@ OUT_@@ CONTROL_@@ STATEMENT | static int assign@@ Value ( int a , int b , int x ) { int arr [ ] = { a , b } ; return ( arr [ x ] ) ; }
MIN@@ IM@@ UM@@ _S@@ UM@@ _S@@ QUAR@@ ES_@@ CHARAC@@ TER@@ S_@@ COUN@@ TS_@@ GI@@ V@@ EN_@@ STRING_@@ REMO@@ V@@ ING_@@ K_@@ CHARAC@@ TERS | static int min@@ StringValue ( String str , int k ) { int l = str . length ( ) ; if ( k >= l ) return 0 ; int [ ] frequency = new int [ MAX_@@ CHAR ] ; for ( int i = 0 ; i < l ; i ++ ) frequency [ str . charAt ( i ) - ' a ' ] ++ ; Comparator < Integer > c = new Int@@ Compare ( ) ; PriorityQueue < Integer > q = new PriorityQueue < > ( c ) ; for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) { if ( frequency [ i ] != 0 ) q . add ( frequency [ i ] ) ; } while ( k != 0 ) { int temp = q . peek ( ) ; q . poll ( ) ; temp = temp - 1 ; q . add ( temp ) ; k -- ; } int result = 0 ; while ( ! q . isEmpty ( ) ) { int temp = q . peek ( ) ; result += temp * temp ; q . poll ( ) ; } return result ; }
MAJ@@ ORI@@ TY_@@ ELEMENT_@@ 1 | private static void find@@ Maj@@ ority ( int [ ] arr ) { HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( map . containsKey ( arr [ i ] ) ) { int count = map . get ( arr [ i ] ) + 1 ; if ( count > arr . length / 2 ) { System . out . println ( " Maj@@ ority ▁ found ▁ : - ▁ " + arr [ i ] ) ; return ; } else map . put ( arr [ i ] , count ) ; } else map . put ( arr [ i ] , 1 ) ; } System . out . println ( " ▁ No ▁ Maj@@ ority ▁ element " ) ; }
LAR@@ GE@@ ST@@ _SUB@@ SET_@@ GRAPH_@@ VER@@ TIC@@ ES_@@ ED@@ GE@@ S_@@ 2_@@ COLORS | static int sub@@ set@@ Graph ( int C [ ] [ ] ) { HashSet < Integer > vertices = new HashSet < > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { vertices . add ( i ) ; } while ( ! vertices . isEmpty ( ) ) { if ( vertices . size ( ) == 1 ) { return 1 ; } boolean some@@ one_@@ removed = false ; for ( int x : vertices ) { HashSet < Integer > values = new HashSet < > ( ) ; for ( int y : vertices ) { if ( y != x ) { values . add ( C [ x ] [ y ] ) ; } } if ( values . size ( ) == 1 ) { vertices . remove ( x ) ; some@@ one_@@ removed = true ; break ; } } if ( ! some@@ one_@@ removed ) { break ; } } return ( vertices . size ( ) ) ; }
FLO@@ OR_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY_@@ 1 | static int floor@@ Search ( int arr [ ] , int low , int high , int x ) { if ( low > high ) return - 1 ; if ( x >= arr [ high ] ) return high ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > 0 && arr [ mid - 1 ] <= x && x < arr [ mid ] ) return mid - 1 ; if ( x < arr [ mid ] ) return floor@@ Search ( arr , low , mid - 1 , x ) ; return floor@@ Search ( arr , mid + 1 , high , x ) ; }
LON@@ GE@@ ST_@@ PREFIX_@@ AL@@ SO@@ _SU@@ F@@ FIX_@@ 1 | static int lon@@ gest@@ Prefix@@ Suffix ( String s ) { int n = s . length ( ) ; int l@@ ps [ ] = new int [ n ] ; l@@ ps [ 0 ] = 0 ; int len = 0 ; int i = 1 ; while ( i < n ) { if ( s . charAt ( i ) == s . charAt ( len ) ) { len ++ ; l@@ ps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = l@@ ps [ len - 1 ] ; } else { l@@ ps [ i ] = 0 ; i ++ ; } } } int res = l@@ ps [ n - 1 ] ; return ( res > n / 2 ) ? n / 2 : res ; }
COUNT_@@ NUMBER_OF_@@ WAY@@ S_TO_@@ PARTITION_@@ A@@ _SET_@@ IN@@ TO_@@ K@@ _SUB@@ SETS | public static int count@@ P ( int n , int k ) { if ( n == 0 || k == 0 || k > n ) return 0 ; if ( k == 1 || k == n ) return 1 ; return ( k * count@@ P ( n - 1 , k ) + count@@ P ( n - 1 , k - 1 ) ) ; }
C_@@ PROGRAM_@@ FAC@@ TOR@@ I@@ AL_@@ NUMBER_@@ 2 | int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
FIND_@@ REPE@@ ATED_@@ CHARACTER_@@ PRES@@ ENT_@@ FIRST_@@ STRING_@@ 1 | public static int find@@ Repeat@@ First ( String s ) { int p = - 1 , i , k ; int MAX_@@ CHAR = 256 ; int hash [ ] = new int [ MAX_@@ CHAR ] ; int pos [ ] = new int [ MAX_@@ CHAR ] ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { k = ( int ) s . charAt ( i ) ; if ( hash [ k ] == 0 ) { hash [ k ] ++ ; pos [ k ] = i ; } else if ( hash [ k ] == 1 ) hash [ k ] ++ ; } for ( i = 0 ; i < MAX_@@ CHAR ; i ++ ) { if ( hash [ i ] == 2 ) { if ( p == - 1 ) p = pos [ i ] ; else if ( p > pos [ i ] ) p = pos [ i ] ; } } return p ; }
NUMBER_OF_@@ PER@@ MU@@ TATION_@@ WITH_@@ K_@@ IN@@ VERSIONS | static int numberOf@@ Perm@@ With@@ K@@ In@@ version ( int N , int K ) { if ( N == 0 ) return 0 ; if ( K == 0 ) return 1 ; if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ; int sum = 0 ; for ( int i = 0 ; i <= K ; i ++ ) { if ( i <= N - 1 ) sum += numberOf@@ Perm@@ With@@ K@@ In@@ version ( N - 1 , K - i ) ; } memo [ N ] [ K ] = sum ; return sum ; }
K_@@ TH_@@ LAR@@ GE@@ ST@@ _S@@ UM_@@ CON@@ TI@@ GU@@ OU@@ S@@ _SUB@@ ARRAY | static int k@@ th@@ Largest@@ Sum ( int arr [ ] , int n , int k ) { int sum [ ] = new int [ n + 1 ] ; sum [ 0 ] = 0 ; sum [ 1 ] = arr [ 0 ] ; for ( int i = 2 ; i <= n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] ; PriorityQueue < Integer > Q = new PriorityQueue < Integer > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { int x = sum [ j ] - sum [ i - 1 ] ; if ( Q . size ( ) < k ) Q . add ( x ) ; else { if ( Q . peek ( ) < x ) { Q . poll ( ) ; Q . add ( x ) ; } } } } return Q . poll ( ) ; }
FIND_@@ THE_@@ LAR@@ GE@@ ST_@@ THRE@@ E_@@ ELEMEN@@ TS_@@ IN_@@ AN_@@ ARRAY | void find@@ 3@@ largest ( int [ ] arr ) { Arrays . sort ( arr ) ; int n = arr . length ; int check = 0 , count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( count < 4 ) { if ( check != arr [ n - i ] ) { System . out . print ( arr [ n - i ] + " ▁ " ) ; check = arr [ n - i ] ; count ++ ; } } else break ; } }
MAXIMUM_@@ DISTIN@@ CT_@@ LOW@@ ER@@ CASE_@@ ALPH@@ AB@@ E@@ TS_@@ TWO_@@ UP@@ PER@@ CASE | static int max@@ Lower ( String str ) { int n = str . length ( ) ; int i = 0 ; for ( ; i < n ; i ++ ) { if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) { i ++ ; break ; } } int maxCount = 0 ; int count [ ] = new int [ MAX_@@ CHAR ] ; for ( ; i < n ; i ++ ) { if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) { int curr@@ Count = 0 ; for ( int j = 0 ; j < MAX_@@ CHAR ; j ++ ) { if ( count [ j ] > 0 ) { curr@@ Count ++ ; } } maxCount = Math . max ( maxCount , curr@@ Count ) ; Arrays . fill ( count , 0 ) ; } if ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) { count [ str . charAt ( i ) - ' a ' ] ++ ; } } return maxCount ; }
CHECK_@@ IF_@@ A_@@ STRING_@@ HAS_@@ ALL_@@ CHARAC@@ TER@@ S_@@ WITH@@ _S@@ AME_@@ FREQU@@ ENCY_@@ WITH_@@ ONE_@@ VARI@@ ATION_@@ ALLOWED | static boolean isValid@@ String ( String str ) { int freq [ ] = new int [ CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } int i , fre@@ q1 = 0 , count_@@ fre@@ q1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { fre@@ q1 = freq [ i ] ; count_@@ fre@@ q1 = 1 ; break ; } } int j , fre@@ q2 = 0 , count_@@ fre@@ q2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == fre@@ q1 ) { count_@@ fre@@ q1 ++ ; } else { count_@@ fre@@ q2 = 1 ; fre@@ q2 = freq [ j ] ; break ; } } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == fre@@ q1 ) { count_@@ fre@@ q1 ++ ; } if ( freq [ k ] == fre@@ q2 ) { count_@@ fre@@ q2 ++ ; } else { return false ; } } if ( count_@@ fre@@ q1 > 1 && count_@@ fre@@ q2 > 1 ) { return false ; } } return true ; }
MAXIMUM_@@ AVER@@ AGE_@@ S@@ UM_@@ PARTITION_@@ ARRAY | static double lar@@ gest@@ Sum@@ Of@@ Aver@@ ages ( int [ ] A , int K ) { int n = A . length ; double [ ] pre_@@ sum = new double [ n + 1 ] ; pre_@@ sum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) pre_@@ sum [ i + 1 ] = pre_@@ sum [ i ] + A [ i ] ; double [ ] dp = new double [ n ] ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = ( pre_@@ sum [ n ] - pre_@@ sum [ i ] ) / ( n - i ) ; for ( int k = 0 ; k < K - 1 ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) dp [ i ] = Math . max ( dp [ i ] , ( pre_@@ sum [ j ] - pre_@@ sum [ i ] ) / ( j - i ) + dp [ j ] ) ; return dp [ 0 ] ; }
FIN@@ D@@ _SUB@@ ARRAY_@@ WITH_@@ GI@@ VEN@@ _S@@ UM_@@ IN_@@ ARRAY_@@ OF_@@ INTEG@@ ERS | public static void sub@@ Array@@ Sum ( int [ ] arr , int n , int sum ) { int cur_@@ sum = 0 ; int start = 0 ; int end = - 1 ; HashMap < Integer , Integer > hash@@ Map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { cur_@@ sum = cur_@@ sum + arr [ i ] ; if ( cur_@@ sum - sum == 0 ) { start = 0 ; end = i ; break ; } if ( hash@@ Map . containsKey ( cur_@@ sum - sum ) ) { start = hash@@ Map . get ( cur_@@ sum - sum ) + 1 ; end = i ; break ; } hash@@ Map . put ( cur_@@ sum , i ) ; } if ( end == - 1 ) { System . out . println ( " No ▁ sub@@ array ▁ with ▁ given ▁ sum ▁ exists " ) ; } else { System . out . println ( " Sum ▁ found ▁ between ▁ indexes ▁ " + start + " ▁ to ▁ " + end ) ; } }
REMOVE_@@ MINIMUM_@@ ELEMEN@@ TS_@@ EI@@ THER@@ _SI@@ DE_@@ 2@@ MIN_@@ MAX | static int min@@ Removal@@ s@@ DP ( int arr [ ] , int n ) { int lon@@ gest_@@ start = - 1 , lon@@ gest_@@ end = 0 ; for ( int start = 0 ; start < n ; start ++ ) { int min = Integer . MAX_VALUE , max = Integer . MIN_VALUE ; for ( int end = start ; end < n ; end ++ ) { int val = arr [ end ] ; if ( val < min ) { min = val ; } if ( val > max ) { max = val ; } if ( 2 * min <= max ) { break ; } if ( end - start > lon@@ gest_@@ end - lon@@ gest_@@ start || lon@@ gest_@@ start == - 1 ) { lon@@ gest_@@ start = start ; lon@@ gest_@@ end = end ; } } } if ( lon@@ gest_@@ start == - 1 ) { return n ; } return ( n - ( lon@@ gest_@@ end - lon@@ gest_@@ start + 1 ) ) ; }
FIND_@@ THE_@@ MISSING_@@ NUMBER_@@ 1 | static int get@@ Missing@@ No ( int a [ ] , int n ) { int total = 1 ; for ( int i = 2 ; i <= ( n + 1 ) ; i ++ ) { total += i ; total -= a [ i - 2 ] ; } return total ; }
SI@@ EV@@ E_@@ SUN@@ DAR@@ AM_@@ PRINT_@@ PRI@@ ME@@ S_S@@ MAL@@ LER_@@ N | static int Si@@ eve@@ OfS@@ und@@ ar@@ am ( int n ) { int n@@ New = ( n - 2 ) / 2 ; boolean marked [ ] = new boolean [ n@@ New + 1 ] ; Arrays . fill ( marked , false ) ; for ( int i = 1 ; i <= n@@ New ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= n@@ New ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) System . out . print ( 2 + " ▁ " ) ; for ( int i = 1 ; i <= n@@ New ; i ++ ) if ( marked [ i ] == false ) System . out . print ( 2 * i + 1 + " ▁ " ) ; return - 1 ; }
MAXIMUM_@@ PRODUCT_@@ SUB@@ SET_@@ ARRAY | static int max@@ Product@@ Subset ( int a [ ] , int n ) { if ( n == 1 ) { return a [ 0 ] ; } int max_@@ neg = Integer . MIN_VALUE ; int count_@@ neg = 0 , count_@@ zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_@@ zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_@@ neg ++ ; max_@@ neg = Math . max ( max_@@ neg , a [ i ] ) ; } prod = prod * a [ i ] ; } if ( count_@@ zero == n ) { return 0 ; } if ( count_@@ neg % 2 == 1 ) { if ( count_@@ neg == 1 && count_@@ zero > 0 && count_@@ zero + count_@@ neg == n ) { return 0 ; } prod = prod / max_@@ neg ; } return prod ; }
FIND_@@ THE_@@ NEARE@@ ST@@ _S@@ MAL@@ LER_@@ NUMB@@ ERS_@@ ON_@@ LEFT_@@ SIDE_@@ IN_@@ AN_@@ ARRAY | static void print@@ Prev@@ S@@ mal@@ ler ( int [ ] arr , int n ) { System . out . print ( " _ , ▁ " ) ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ j ] < arr [ i ] ) { System . out . print ( arr [ j ] + " , ▁ " ) ; break ; } } if ( j == - 1 ) System . out . print ( " _ , ▁ " ) ; } }
FIND_@@ NUMBER_@@ PAIR@@ S_@@ ARRAY_@@ X@@ OR_@@ 0_@@ 1 | static int calculate ( int a [ ] , int n ) { int maximum = Arrays . stream ( a ) . max ( ) . getAs@@ Int ( ) ; int frequency [ ] = new int [ maximum + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ a [ i ] ] += 1 ; } int answer = 0 ; for ( int i = 0 ; i < ( maximum ) + 1 ; i ++ ) { answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) ; } return answer / 2 ; }
S@@ UM_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENTS_@@ 1 | static int bin@@ omi@@ al@@ Coeff@@ Sum ( int n ) { return ( 1 << n ) ; }
MAX@@ IM@@ UM@@ _S@@ UM_@@ PAIR@@ S@@ _SPECI@@ FIC_@@ DIFF@@ ER@@ ENCE_@@ 1 | static int max@@ Sum@@ Pair@@ With@@ Difference@@ LessThan@@ K ( int arr [ ] , int N , int k ) { int max@@ Sum = 0 ; Arrays . sort ( arr ) ; for ( int i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { max@@ Sum += arr [ i ] ; max@@ Sum += arr [ i - 1 ] ; -- i ; } } return max@@ Sum ; }
K@@ TH_@@ AD@@ J@@ AC@@ ENT_@@ NODE_@@ GRAPH_@@ VERTEX_@@ WEIGHT | static void print@@ k@@ th@@ node ( Vector < pair > adj [ ] , int wt [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) Collections . sort ( adj [ i ] , new Comparator < pair > ( ) { public int compare ( pair p1 , pair p2 ) { return p1 . first - p2 . first ; } } ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( adj [ i ] . size ( ) >= k ) System . out . print ( adj [ i ] . get ( adj [ i ] . size ( ) - k ) . second + " ▁ " ) ; else System . out . print ( " - 1" ) ; } }
SPACE_@@ OPTIMIZ@@ ED_@@ D@@ P_S@@ OL@@ U@@ TION_@@ 0_@@ 1_@@ KN@@ AP@@ S@@ ACK_@@ PRO@@ BLE@@ M | static int K@@ nap@@ S@@ ack ( int val [ ] , int wt [ ] , int n , int W ) { int mat [ ] [ ] = new int [ 2 ] [ W + 1 ] ; int i = 0 ; while ( i < n ) { int j = 0 ; if ( i % 2 != 0 ) { while ( ++ j <= W ) { if ( wt [ i ] <= j ) { mat [ 1 ] [ j ] = Math . max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) ; } else { mat [ 1 ] [ j ] = mat [ 0 ] [ j ] ; } } } else { while ( ++ j <= W ) { if ( wt [ i ] <= j ) { mat [ 0 ] [ j ] = Math . max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) ; } else { mat [ 0 ] [ j ] = mat [ 1 ] [ j ] ; } } } i ++ ; } return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ] ; }
BINARY_@@ RE@@ PRESEN@@ TATION_@@ OF_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ 1 | static void bin ( Integer n ) { if ( n > 1 ) bin ( n > > 1 ) ; System . out . printf ( " % d " , n & 1 ) ; }
PRI@@ ME_@@ FAC@@ TOR@@ S_@@ BIG_@@ NUMBER | static void factor@@ ize ( long n ) { int count = 0 ; while ( ! ( n % 2 > 0 ) ) { n >>= 1 ; count ++ ; } if ( count > 0 ) { System . out . println ( "2" + " ▁ " + count ) ; } for ( long i = 3 ; i <= ( long ) Math . sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n = n / i ; } if ( count > 0 ) { System . out . println ( i + " ▁ " + count ) ; } } if ( n > 2 ) { System . out . println ( n + " ▁ " + "1" ) ; } }
COUNT_@@ SUB@@ STRING@@ S_@@ WITH@@ _S@@ AME_@@ FIRST_@@ AND_@@ LAST_@@ CHARAC@@ TER@@ S_@@ 1 | static int count@@ Sub@@ string@@ With@@ Equal@@ Ends ( String s ) { int result = 0 ; int n = s . length ( ) ; int [ ] count = new int [ MAX_@@ CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) count [ s . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }
LON@@ GE@@ ST_@@ PA@@ LIN@@ DRO@@ ME_@@ SUB@@ STRING@@ _SET_@@ 1 | static void print@@ Sub@@ Str ( String str , int low , int high ) { System . out . println ( str . substring ( low , high + 1 ) ) ; }
FIND_@@ THE_@@ SM@@ ALLE@@ ST_@@ WINDOW_@@ IN_@@ A_@@ STRING_@@ CONTAIN@@ ING_@@ ALL_@@ CHARAC@@ TER@@ S_@@ OF_@@ AN@@ OTHER_@@ STRING | static String find@@ Sub@@ String ( String str , String pat ) { int len1 = str . length ( ) ; int len2 = pat . length ( ) ; if ( len1 < len2 ) { System . out . println ( " No ▁ such ▁ window ▁ exists " ) ; return " " ; } int hash@@ _p@@ at [ ] = new int [ no_@@ of_@@ chars ] ; int hash_@@ str [ ] = new int [ no_@@ of_@@ chars ] ; for ( int i = 0 ; i < len2 ; i ++ ) hash@@ _p@@ at [ pat . charAt ( i ) ] ++ ; int start = 0 , start_index = - 1 , min_@@ len = Integer . MAX_VALUE ; int count = 0 ; for ( int j = 0 ; j < len1 ; j ++ ) { hash_@@ str [ str . charAt ( j ) ] ++ ; if ( hash@@ _p@@ at [ str . charAt ( j ) ] != 0 && hash_@@ str [ str . charAt ( j ) ] <= hash@@ _p@@ at [ str . charAt ( j ) ] ) count ++ ; if ( count == len2 ) { while ( hash_@@ str [ str . charAt ( start ) ] > hash@@ _p@@ at [ str . charAt ( start ) ] || hash@@ _p@@ at [ str . charAt ( start ) ] == 0 ) { if ( hash_@@ str [ str . charAt ( start ) ] > hash@@ _p@@ at [ str . charAt ( start ) ] ) hash_@@ str [ str . charAt ( start ) ] -- ; start ++ ; } int len_@@ window = j - start + 1 ; if ( min_@@ len > len_@@ window ) { min_@@ len = len_@@ window ; start_index = start ; } } } if ( start_index == - 1 ) { System . out . println ( " No ▁ such ▁ window ▁ exists " ) ; return " " ; } return str . substring ( start_index , start_index + min_@@ len ) ; }
MAR@@ KO@@ V_@@ MATRIX | static boolean check@@ Mark@@ ov ( double m [ ] [ ] ) { for ( int i = 0 ; i < m . length ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < m [ i ] . length ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }
LE@@ AF_@@ NODE@@ S_@@ PRE@@ ORDER_@@ BIN@@ AR@@ Y@@ _SEARCH_@@ TREE | static void leaf@@ Node ( int pre@@ order [ ] , int n ) { Stack < Integer > s = new Stack < Integer > ( ) ; for ( int i = 0 , j = 1 ; j < n ; i ++ , j ++ ) { boolean found = false ; if ( pre@@ order [ i ] > pre@@ order [ j ] ) s . push ( pre@@ order [ i ] ) ; else { while ( ! s . isEmpty ( ) ) { if ( pre@@ order [ j ] > s . peek ( ) ) { s . pop ( ) ; found = true ; } else break ; } } if ( found ) System . out . print ( pre@@ order [ i ] + " ▁ " ) ; } System . out . println ( pre@@ order [ n - 1 ] ) ; }
SM@@ ALLE@@ ST_@@ POWER_@@ OF_@@ 2_@@ GREATER_@@ TH@@ AN_@@ OR_@@ EQUAL_@@ TO_@@ N | static int next@@ PowerOf@@ 2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
PROGRAM_@@ CHECK_@@ WAT@@ ER_@@ TAN@@ K_@@ OVER@@ FLO@@ WS_@@ N@@ _SO@@ LI@@ D_@@ BAL@@ LS_@@ DIP@@ PED_@@ WAT@@ ER_@@ TAN@@ K | static void overflow ( int H , int r , int h , int N , int R ) { double tan@@ k_@@ cap = 3.14 * r * r * H ; double wat@@ er_@@ vol = 3.14 * r * r * h ; double ball@@ s_@@ vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; double vol = wat@@ er_@@ vol + ball@@ s_@@ vol ; if ( vol > tan@@ k_@@ cap ) { System . out . println ( " Overflow " ) ; } else { System . out . println ( " Not ▁ in ▁ overflow ▁ state " ) ; } }
SM@@ ALLE@@ ST_@@ DE@@ RANGE@@ MENT_@@ SEQUENCE | static void generate_@@ der@@ ange@@ ment ( int N ) { int S [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) S [ i ] = i ; int D [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 2 ) { if ( i == N ) { D [ N ] = S [ N - 1 ] ; D [ N - 1 ] = S [ N ] ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( D [ i ] + " ▁ " ) ; System . out . println ( ) ; }
MAXIMUM_@@ PRODUCT_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQUENCE | static int lis ( int [ ] arr , int n ) { int [ ] mp@@ is = new int [ n ] ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) mp@@ is [ i ] = arr [ i ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && mp@@ is [ i ] < ( mp@@ is [ j ] * arr [ i ] ) ) mp@@ is [ i ] = mp@@ is [ j ] * arr [ i ] ; for ( int k = 0 ; k < mp@@ is . length ; k ++ ) { if ( mp@@ is [ k ] > max ) { max = mp@@ is [ k ] ; } } return max ; }
CHANGE_@@ BITS_@@ CAN_@@ MA@@ DE_@@ ONE_@@ FLI@@ P | static boolean can@@ Make@@ All@@ Same ( String str ) { int zeros = 0 , ones = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch == '0' ) ++ zeros ; else ++ ones ; } return ( zeros == 1 || ones == 1 ) ; }
FIND_@@ NUMBER_@@ PAIR@@ S_@@ ARRAY_@@ X@@ OR_@@ 0 | static int calculate ( int a [ ] , int n ) { Arrays . sort ( a ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; }
FIND_@@ ROOT_@@ TREE_@@ CHIL@@ DR@@ EN_@@ ID@@ _S@@ UM_@@ EVER@@ Y_@@ NODE_@@ GI@@ VEN | static int find@@ Root ( pair arr [ ] , int n ) { int root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { root += ( arr [ i ] . first - arr [ i ] . second ) ; } return root ; }
BIN@@ AR@@ Y@@ _SEARCH | int binary@@ Search ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binary@@ Search ( arr , l , mid - 1 , x ) ; return binary@@ Search ( arr , mid + 1 , r , x ) ; } return - 1 ; }
FI@@ BON@@ ACC@@ I_@@ MODUL@@ O_@@ P | static int find@@ Min@@ Zero ( int p ) { int first = 1 , second = 1 , number = 2 , next = 1 ; while ( next > 0 ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }
K_@@ LAR@@ GE@@ STOR@@ _S@@ MAL@@ LE@@ ST_@@ ELEMEN@@ TS_@@ IN_@@ AN_@@ ARRAY | public static void k@@ Lar@@ gest ( Integer [ ] arr , int k ) { Arrays . sort ( arr , Collections . reverse@@ Order ( ) ) ; for ( int i = 0 ; i < k ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
C_@@ PROGRAM_@@ FIND_@@ AREA_@@ CIRC@@ LE | static double find@@ Area ( int r ) { return PI * Math . pow ( r , 2 ) ; }
S@@ UM_@@ TWO_@@ LARGE_@@ NUMB@@ ERS | static String find@@ Sum ( String str1 , String str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) { String t = str1 ; str1 = str2 ; str2 = t ; } String str = " " ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; str1 = new StringBuilder ( str1 ) . reverse ( ) . toString ( ) ; str2 = new StringBuilder ( str2 ) . reverse ( ) . toString ( ) ; int carry = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { int sum = ( ( int ) ( str1 . charAt ( i ) - '0' ) + ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } for ( int i = n1 ; i < n2 ; i ++ ) { int sum = ( ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } if ( carry > 0 ) str += ( char ) ( carry + '0' ) ; str = new StringBuilder ( str ) . reverse ( ) . toString ( ) ; return str ; }
ARRAY_@@ RANGE_@@ QUER@@ I@@ ES_@@ ELEMEN@@ TS_@@ FREQU@@ ENCY_@@ VALUE | static int solve@@ Query ( int start , int end , int arr [ ] ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = start ; i <= end ; i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; int count = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) if ( entry . getKey ( ) == entry . getValue ( ) ) count ++ ; return count ; }
COUNT_@@ SUB@@ STRING@@ S_@@ WITH@@ _S@@ AME_@@ FIRST_@@ AND_@@ LAST_@@ CHARAC@@ TERS | static int count@@ Sub@@ string@@ With@@ Equal@@ Ends ( String s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( s . charAt ( i ) == s . charAt ( j ) ) result ++ ; return result ; }
DYNAMIC_@@ PROGR@@ AM@@ M@@ ING_@@ HIGH_@@ EFF@@ ORT_@@ VS_@@ LOW_@@ EFF@@ ORT_@@ TASK@@ S_@@ PRO@@ BLE@@ M | static int max@@ Tasks ( int high [ ] , int low [ ] , int n ) { if ( n <= 0 ) return 0 ; return Math . max ( high [ n - 1 ] + max@@ Tasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + max@@ Tasks ( high , low , ( n - 1 ) ) ) ; }
MAXIMUM_@@ DIFF@@ ER@@ ENCE_@@ S@@ UM_@@ ELEMEN@@ TS_@@ TWO_@@ RO@@ WS_@@ MATRIX | static int max@@ Row@@ Diff ( int mat [ ] [ ] , int m , int n ) { int row@@ Sum [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] ; row@@ Sum [ i ] = sum ; } int max_@@ diff = row@@ Sum [ 1 ] - row@@ Sum [ 0 ] ; int min_@@ element = row@@ Sum [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) { if ( row@@ Sum [ i ] - min_@@ element > max_@@ diff ) max_@@ diff = row@@ Sum [ i ] - min_@@ element ; if ( row@@ Sum [ i ] < min_@@ element ) min_@@ element = row@@ Sum [ i ] ; } return max_@@ diff ; }
PAP@@ ER_@@ CU@@ T_@@ MINIMUM_@@ NUMBER@@ _S@@ QUAR@@ ES | static int minimum@@ Square ( int a , int b ) { int result = 0 , rem = 0 ; if ( a < b ) swap ( a , b ) ; while ( b > 0 ) { result += a / b ; rem = a % b ; a = b ; b = rem ; } return result ; }
SEARCH_@@ AN_@@ ELEMENT_@@ IN_@@ AN_@@ ARRAY_@@ W@@ HER@@ E_@@ DIFF@@ ER@@ ENCE_@@ BETWE@@ EN_@@ AD@@ J@@ AC@@ ENT_@@ ELEMEN@@ TS_@@ IS_@@ 1 | static int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . abs ( arr [ i ] - x ) ; } System . out . println ( " number ▁ is ▁ not " + " ▁ present ! " ) ; return - 1 ; }
PAN@@ GR@@ AM_@@ CHECK@@ ING | public static boolean check@@ P@@ ang@@ ram ( String str ) { boolean [ ] mark = new boolean [ 26 ] ; int index = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ' A ' <= str . charAt ( i ) && str . charAt ( i ) <= ' Z ' ) index = str . charAt ( i ) - ' A ' ; else if ( ' a ' <= str . charAt ( i ) && str . charAt ( i ) <= ' z ' ) index = str . charAt ( i ) - ' a ' ; mark [ index ] = true ; } for ( int i = 0 ; i <= 25 ; i ++ ) if ( mark [ i ] == false ) return ( false ) ; return ( true ) ; }
PRINT_@@ SHOR@@ TEST_@@ COMM@@ ON@@ _SUP@@ ER@@ SEQUENCE | static String print@@ Shor@@ test@@ Super@@ Seq ( String X , String Y ) { int m = X . length ( ) ; int n = Y . length ( ) ; int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) { dp [ i ] [ j ] = j ; } else if ( j == 0 ) { dp [ i ] [ j ] = i ; } else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } } int index = dp [ m ] [ n ] ; String str = " " ; int i = m , j = n ; while ( i > 0 && j > 0 ) { if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { str += ( X . charAt ( i - 1 ) ) ; i -- ; j -- ; index -- ; } else if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] ) { str += ( Y . charAt ( j - 1 ) ) ; j -- ; index -- ; } else { str += ( X . charAt ( i - 1 ) ) ; i -- ; index -- ; } } while ( i > 0 ) { str += ( X . charAt ( i - 1 ) ) ; i -- ; index -- ; } while ( j > 0 ) { str += ( Y . charAt ( j - 1 ) ) ; j -- ; index -- ; } str = reverse ( str ) ; return str ; }
FIND_@@ PA@@ IR_@@ MAXIMUM_@@ GC@@ D_@@ ARRAY_@@ 1 | public static int find@@ Max@@ GC@@ D ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = Math . max ( high , arr [ i ] ) ; int count [ ] = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; int counter = 0 ; for ( int i = high ; i >= 1 ; i -- ) { int j = i ; while ( j <= high ) { if ( count [ j ] > 0 ) counter += count [ j ] ; j += i ; if ( counter == 2 ) return i ; } counter = 0 ; } return 1 ; }
PROGRAM_@@ CAL@@ CUL@@ ATE_@@ AREA_@@ OC@@ TAG@@ ON | static double area@@ Oct@@ ag@@ on ( double side ) { return ( float ) ( 2 * ( 1 + Math . sqrt ( 2 ) ) * side * side ) ; }
FIND_@@ INDEX_@@ OF_@@ AN_@@ EXTRA_@@ ELEMENT_@@ PRES@@ ENT_@@ IN_@@ ONE@@ _S@@ OR@@ TED_@@ ARRAY_@@ 1 | static int find@@ Extra ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int n ) { int index = n ; int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( ar@@ r2 [ mid ] == ar@@ r1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }
NO@@ BLE_@@ INTEG@@ ERS_@@ IN_@@ AN_@@ ARRAY_@@ COUNT_@@ OF_@@ GREATER_@@ ELEMEN@@ TS_@@ IS_@@ EQUAL_@@ TO_@@ VALUE_@@ 1 | public static int no@@ ble@@ Integer ( int arr [ ] ) { Arrays . sort ( arr ) ; int n = arr . length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return - 1 ; }
MAXIMUM_@@ NUMBER_@@ OF@@ _S@@ QUAR@@ ES_@@ TH@@ AT_@@ CAN_@@ BE_@@ FI@@ T_@@ IN_@@ A_@@ RIGHT_@@ ANGLE_@@ ISO@@ SCE@@ LES_@@ TRI@@ ANGLE | static int max@@ Square ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; }
HO@@ W_@@ TO_@@ COMP@@ UTE_@@ MOD_@@ OF_@@ A_@@ BIG_@@ NUMBER | static int mod ( String num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num . charAt ( i ) - '0' ) % a ; return res ; }
LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ STRING_@@ 1 | static int l@@ cs ( int i , int j , int count ) { if ( i == 0 || j == 0 ) { return count ; } if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { count = l@@ cs ( i - 1 , j - 1 , count + 1 ) ; } count = Math . max ( count , Math . max ( l@@ cs ( i , j - 1 , 0 ) , l@@ cs ( i - 1 , j , 0 ) ) ) ; return count ; }
FIND_@@ PATTER@@ NS_@@ 101@@ _@@ GI@@ V@@ EN_@@ STRING | static int pattern@@ Count ( String str ) { char last = str . charAt ( 0 ) ; int i = 1 , counter = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) == '0' && last == '1' ) { while ( str . charAt ( i ) == '0' ) i ++ ; if ( str . charAt ( i ) == '1' ) counter ++ ; } last = str . charAt ( i ) ; i ++ ; } return counter ; }
LON@@ GE@@ ST_@@ INCRE@@ AS@@ ING_@@ OD@@ D_@@ EV@@ EN@@ _SUB@@ SEQUENCE | public static int long@@ O@@ dd@@ Even@@ Inc@@ Seq ( int arr [ ] , int n ) { int [ ] li@@ o@@ es = new int [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) li@@ o@@ es [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && li@@ o@@ es [ i ] < li@@ o@@ es [ j ] + 1 ) li@@ o@@ es [ i ] = li@@ o@@ es [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < li@@ o@@ es [ i ] ) maxLen = li@@ o@@ es [ i ] ; return maxLen ; }
COUNT_@@ NUMBER_@@ OF@@ _SUB@@ STRING@@ S_@@ WITH_@@ EXAC@@ TL@@ Y_@@ K_@@ DISTIN@@ CT_@@ CHARAC@@ TERS | int count@@ k@@ Dist ( String str , int k ) { int res = 0 ; int n = str . length ( ) ; int cnt [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int dist@@ _count = 0 ; Arrays . fill ( cnt , 0 ) ; for ( int j = i ; j < n ; j ++ ) { if ( cnt [ str . charAt ( j ) - ' a ' ] == 0 ) dist@@ _count ++ ; cnt [ str . charAt ( j ) - ' a ' ] ++ ; if ( dist@@ _count == k ) res ++ ; } } return res ; }
C_@@ PROGRAM_@@ FAC@@ TOR@@ I@@ AL_@@ NUMBER_@@ 1 | static int factorial ( int n ) { int res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
K_@@ MAX@@ IM@@ UM@@ _S@@ UM@@ S_@@ NON_@@ OVER@@ L@@ APP@@ ING_@@ CON@@ TI@@ GU@@ OU@@ S@@ _SUB_@@ ARRAY@@ S | static void k@@ max ( int arr [ ] , int k , int n ) { for ( int c = 0 ; c < k ; c ++ ) { int max_@@ so@@ _f@@ ar = Integer . MIN_VALUE ; int max_@@ here = 0 ; int start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_@@ here += arr [ i ] ; if ( max_@@ so@@ _f@@ ar < max_@@ here ) { max_@@ so@@ _f@@ ar = max_@@ here ; start = s ; end = i ; } if ( max_@@ here < 0 ) { max_@@ here = 0 ; s = i + 1 ; } } System . out . println ( " Maximum ▁ non - overlapping ▁ sub - array@@ sum " + ( c + 1 ) + " : ▁ " + max_@@ so@@ _f@@ ar + " , ▁ starting ▁ index : ▁ " + start + " , ▁ ending ▁ index : ▁ " + end + " . " ) ; for ( int l = start ; l <= end ; l ++ ) arr [ l ] = Integer . MIN_VALUE ; } System . out . println ( ) ; }
DISTAN@@ CE_@@ NEARE@@ ST_@@ CELL_@@ 1_@@ BINARY_@@ MATRIX | static void print@@ Distance ( int mat [ ] [ ] ) { int ans [ ] [ ] = new int [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) ans [ i ] [ j ] = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) for ( int l = 0 ; l < M ; l ++ ) { if ( mat [ k ] [ l ] == 1 ) ans [ i ] [ j ] = Math . min ( ans [ i ] [ j ] , Math . abs ( i - k ) + Math . abs ( j - l ) ) ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) System . out . print ( ans [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } }
MINIMUM_@@ NUMBER_OF_@@ BRAC@@ KET_@@ REVER@@ S@@ AL@@ S_@@ NE@@ E@@ DED_@@ TO_@@ MAKE_@@ AN_@@ EXPRES@@ SION_@@ BAL@@ ANCE@@ D | static int count@@ Min@@ Re@@ vers@@ als ( String expr ) { int len = expr . length ( ) ; if ( len % 2 != 0 ) return - 1 ; Stack < Character > s = new Stack < > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = expr . charAt ( i ) ; if ( c == ' } ' && ! s . empty ( ) ) { if ( s . peek ( ) == ' { ' ) s . pop ( ) ; else s . push ( c ) ; } else s . push ( c ) ; } int red_@@ len = s . size ( ) ; int n = 0 ; while ( ! s . empty ( ) && s . peek ( ) == ' { ' ) { s . pop ( ) ; n ++ ; } return ( red_@@ len / 2 + n % 2 ) ; } public static void main ( String [ ] args ) { String expr = " } }
FIRST_@@ NEGATIVE_@@ INTEGER_@@ EVER@@ Y_@@ WINDOW@@ _SIZE_@@ K_@@ 1 | static void print@@ First@@ Negative@@ Integer ( int arr [ ] , int n , int k ) { LinkedList < Integer > D@@ i = new LinkedList < > ( ) ; int i ; for ( i = 0 ; i < k ; i ++ ) if ( arr [ i ] < 0 ) D@@ i . add ( i ) ; for ( ; i < n ; i ++ ) { if ( ! D@@ i . isEmpty ( ) ) System . out . print ( arr [ D@@ i . peek ( ) ] + " ▁ " ) ; else System . out . print ( "0" + " ▁ " ) ; while ( ( ! D@@ i . isEmpty ( ) ) && D@@ i . peek ( ) < ( i - k + 1 ) ) D@@ i . remove ( ) ; if ( arr [ i ] < 0 ) D@@ i . add ( i ) ; } if ( ! D@@ i . isEmpty ( ) ) System . out . print ( arr [ D@@ i . peek ( ) ] + " ▁ " ) ; else System . out . print ( "0" + " ▁ " ) ; }
MAG@@ IC@@ _S@@ QU@@ ARE | static void generate@@ Square ( int n ) { int [ ] [ ] magic@@ Square = new int [ n ] [ n ] ; int i = n / 2 ; int j = n - 1 ; for ( int num = 1 ; num <= n * n ; ) { if ( i == - 1 && j == n ) { j = n - 2 ; i = 0 ; } else { if ( j == n ) j = 0 ; if ( i < 0 ) i = n - 1 ; } if ( magic@@ Square [ i ] [ j ] != 0 ) { j -= 2 ; i ++ ; continue ; } else magic@@ Square [ i ] [ j ] = num ++ ; j ++ ; i -- ; } System . out . println ( " The ▁ Magic ▁ Square ▁ for ▁ " + n + " : " ) ; System . out . println ( " Sum ▁ of ▁ each ▁ row ▁ or ▁ column ▁ " + n * ( n * n + 1 ) / 2 + " : " ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) System . out . print ( magic@@ Square [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } }
PROGRAM_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENTS_@@ TABLE | static void print@@ binomial ( int max ) { for ( int m = 0 ; m <= max ; m ++ ) { System . out . print ( m + " ▁ " ) ; int bin@@ om = 1 ; for ( int x = 0 ; x <= m ; x ++ ) { if ( m != 0 && x != 0 ) bin@@ om = bin@@ om * ( m - x + 1 ) / x ; System . out . print ( bin@@ om + " ▁ " ) ; } System . out . println ( ) ; } }
CH@@ INE@@ SE_@@ RE@@ MA@@ INDE@@ R_@@ THE@@ O@@ RE@@ M@@ _SET_@@ 1_@@ INTRO@@ DUC@@ TION | static int find@@ Min@@ X ( int num [ ] , int rem [ ] , int k ) { int x = 1 ; while ( true ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } }
MINIMUM_@@ NUMBER_@@ POINT@@ S_@@ REMO@@ VED_@@ GET_@@ RE@@ MAIN@@ ING_@@ POINT@@ S_@@ ONE@@ _SI@@ DE_@@ AXIS | static int find@@ min ( Point p [ ] , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] . x <= 0 ) a ++ ; else if ( p [ i ] . x >= 0 ) b ++ ; if ( p [ i ] . y >= 0 ) c ++ ; else if ( p [ i ] . y <= 0 ) d ++ ; } return Math . min ( Math . min ( a , b ) , Math . min ( c , d ) ) ; }
REPL@@ ACE_@@ OC@@ CURR@@ EN@@ CES_@@ STRING_@@ AB_@@ C_@@ WITH@@ OUT_@@ USING_@@ EX@@ TRA@@ _SPACE | static void translate ( char str [ ] ) { for ( int i = 1 ; i < str . length ; i ++ ) { if ( str [ i - 1 ] == ' A ' && str [ i ] == ' B ' ) { str [ i - 1 ] = ' C ' ; int j ; for ( j = i ; j < str . length - 1 ; j ++ ) str [ j ] = str [ j + 1 ] ; str [ j ] = ' ▁ ' ; } } return ; }
PAIR@@ S_@@ OF_@@ POSITIVE_@@ NEGATIVE_@@ VALU@@ ES_@@ IN_@@ AN_@@ ARRAY | public static void print@@ Pairs ( int arr [ ] , int n ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( arr [ i ] ) == Math . abs ( arr [ j ] ) ) v . add ( Math . abs ( arr [ i ] ) ) ; if ( v . size ( ) == 0 ) return ; Collections . sort ( v ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) System . out . print ( - v . get ( i ) + " ▁ " + v . get ( i ) ) ; }
NON_@@ REPE@@ ATING_@@ ELEMENT_@@ 1 | static int first@@ Non@@ Repe@@ ating ( int arr [ ] , int n ) { Map < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } } for ( int i = 0 ; i < n ; i ++ ) if ( m . get ( arr [ i ] ) == 1 ) return arr [ i ] ; return - 1 ; }
PRINT_@@ FI@@ BON@@ AC@@ CI@@ _SERI@@ ES_@@ REVERSE_@@ ORDER | static void reverse@@ Fi@@ bon@@ ac@@ ci ( int n ) { int a [ ] = new int [ n ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { System . out . print ( a [ i ] + " ▁ " ) ; } }
FIND_@@ MINIMUM_@@ DIFF@@ ER@@ ENCE_@@ PA@@ IR_@@ 1 | static int find@@ Min@@ Diff ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }
MINIMUM_@@ NUMBER_@@ PLAT@@ FOR@@ MS_@@ REQUIRED_@@ RA@@ IL@@ WAY@@ BUS_@@ ST@@ ATION | static int find@@ Platform ( int arr [ ] , int dep [ ] , int n ) { Arrays . sort ( arr ) ; Arrays . sort ( dep ) ; int plat@@ _@@ needed = 1 , result = 1 ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arr [ i ] <= dep [ j ] ) { plat@@ _@@ needed ++ ; i ++ ; if ( plat@@ _@@ needed > result ) result = plat@@ _@@ needed ; } else { plat@@ _@@ needed -- ; j ++ ; } } return result ; }
MULTIP@@ LIC@@ ATI@@ VE_@@ INVER@@ SE_@@ UN@@ DER_@@ MODUL@@ O_@@ M_@@ 1 | static int mod@@ Inverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; }
NUMBER_@@ N_@@ DIG@@ IT_@@ STE@@ PP@@ ING_@@ NUMB@@ ERS | static long answer ( int n ) { int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; }
CREATE_@@ A_@@ MATRIX_@@ WITH_@@ ALTER@@ N@@ ATING_@@ REC@@ TA@@ NG@@ LES_@@ OF_@@ 0_@@ AND_@@ X | static void fill@@ 0@@ X ( int m , int n ) { int i , k = 0 , l = 0 ; int r = m , c = n ; char a [ ] [ ] = new char [ m ] [ n ] ; char x = ' X ' ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) a [ k ] [ i ] = x ; k ++ ; for ( i = k ; i < m ; ++ i ) a [ i ] [ n - 1 ] = x ; n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) a [ m - 1 ] [ i ] = x ; m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) a [ i ] [ l ] = x ; l ++ ; } x = ( x == '0' ) ? ' X ' : '0' ; } for ( i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) System . out . print ( a [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } }
FIN@@ D_S@@ UM_@@ UNI@@ QUE_@@ SUB_@@ ARRA@@ Y_S@@ UM_@@ GI@@ V@@ EN_@@ ARRAY | static int find@@ Sub@@ array@@ Sum ( int [ ] arr , int n ) { int res = 0 ; HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ j ] ; if ( m . containsKey ( sum ) ) { m . put ( sum , m . get ( sum ) + 1 ) ; } else { m . put ( sum , 1 ) ; } } } for ( Map . Entry < Integer , Integer > x : m . entrySet ( ) ) if ( x . getValue ( ) == 1 ) res += x . getKey ( ) ; return res ; }
REVERSE_@@ A_@@ STRING_@@ USING_@@ RECUR@@ SION | void reverse ( String str ) { if ( ( str == null ) || ( str . length ( ) <= 1 ) ) System . out . println ( str ) ; else { System . out . print ( str . charAt ( str . length ( ) - 1 ) ) ; reverse ( str . substring ( 0 , str . length ( ) - 1 ) ) ; } }
PRINT@@ ING_@@ ITE@@ MS_@@ 01_@@ KN@@ AP@@ S@@ ACK | static void print@@ kn@@ ap@@ S@@ ack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } int res = K [ n ] [ W ] ; System . out . println ( res ) ; w = W ; for ( i = n ; i > 0 && res > 0 ; i -- ) { if ( res == K [ i - 1 ] [ w ] ) continue ; else { System . out . print ( wt [ i - 1 ] + " ▁ " ) ; res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } }
FIND_@@ LAR@@ GE@@ ST_@@ PRI@@ ME_@@ FAC@@ TOR_@@ NUMBER | static long max@@ Prime@@ Factors ( long n ) { long max@@ Prime = - 1 ; while ( n % 2 == 0 ) { max@@ Prime = 2 ; n >>= 1 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { max@@ Prime = i ; n = n / i ; } } if ( n > 2 ) max@@ Prime = n ; return max@@ Prime ; }
FIND_@@ THE_@@ ELEMENT_@@ BEFORE_@@ WHI@@ CH_@@ ALL_@@ THE_@@ ELEMEN@@ TS_@@ ARE_@@ SM@@ ALL@@ ER_@@ TH@@ AN_@@ IT_@@ AND_@@ AFTER_@@ WHI@@ CH_@@ ALL_@@ ARE_@@ GREATER_@@ TH@@ AN_@@ IT | static int findElement ( int [ ] arr , int n ) { int [ ] left@@ Max = new int [ n ] ; left@@ Max [ 0 ] = Integer . MIN_VALUE ; for ( int i = 1 ; i < n ; i ++ ) left@@ Max [ i ] = Math . max ( left@@ Max [ i - 1 ] , arr [ i - 1 ] ) ; int right@@ Min = Integer . MAX_VALUE ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( left@@ Max [ i ] < arr [ i ] && right@@ Min > arr [ i ] ) return i ; right@@ Min = Math . min ( right@@ Min , arr [ i ] ) ; } return - 1 ; }
COMMON_@@ CHARAC@@ TER@@ S_@@ N_@@ STRINGS | public static void common@@ Characters ( String str [ ] , int n ) { Boolean [ ] prim = new Boolean [ MAX_@@ CHAR ] ; Arrays . fill ( prim , new Boolean ( true ) ) ; for ( int i = 0 ; i < n ; i ++ ) { Boolean [ ] sec = new Boolean [ MAX_@@ CHAR ] ; Arrays . fill ( sec , new Boolean ( false ) ) ; for ( int j = 0 ; j < str [ i ] . length ( ) ; j ++ ) { if ( prim [ str [ i ] . charAt ( j ) - ' a ' ] ) sec [ str [ i ] . charAt ( j ) - ' a ' ] = true ; } System . arraycopy ( sec , 0 , prim , 0 , MAX_@@ CHAR ) ; } for ( int i = 0 ; i < 26 ; i ++ ) if ( prim [ i ] ) { System . out . print ( Character . to@@ Chars ( i + 97 ) ) ; System . out . print ( " ▁ " ) ; } }
MIN@@ IM@@ AL_@@ MOVE@@ S_@@ FORM_@@ STRING_@@ ADD@@ ING_@@ CHARAC@@ TER@@ S_@@ APP@@ END@@ ING_@@ STRING | static int minim@@ al@@ Steps ( String s , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = Integer . MAX_VALUE ; String s1 = " " , s2 = " " ; dp [ 0 ] = 1 ; s1 += s . charAt ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { s1 += s . charAt ( i ) ; s2 = s . substring ( i + 1 , i + 1 ) ; dp [ i ] = Math . min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; if ( s1 == s2 ) dp [ i * 2 + 1 ] = Math . min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) ; } return dp [ n - 1 ] ; }
S@@ UM_@@ MATRIX_@@ ELEMENT_@@ ABSOL@@ UTE_@@ DIFF@@ ER@@ ENCE_@@ ROW_@@ COLUMN_@@ NUMB@@ ERS_@@ 1 | static int find@@ Sum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
FIND_@@ FREQU@@ ENCY_@@ EV@@ EN_@@ OD@@ D_@@ NUMB@@ ERS_@@ MATRIX | static void freq ( int ar [ ] [ ] , int m , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } System . out . print ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = " + odd + " ▁ \n " ) ; System . out . print ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = ▁ " + even + " ▁ \n " ) ; }
COUNT_@@ SUB@@ ARRAY@@ S_@@ WITH@@ _S@@ AME_@@ EV@@ EN_@@ AND_@@ OD@@ D_@@ ELEMENTS | static int count@@ Sub@@ arrays ( int [ ] arr , int n ) { int difference = 0 ; int ans = 0 ; int [ ] hash_@@ positive = new int [ n + 1 ] ; int [ ] hash_@@ negative = new int [ n + 1 ] ; hash_@@ positive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) == 1 ) { difference ++ ; } else { difference -- ; } if ( difference < 0 ) { ans += hash_@@ negative [ - difference ] ; hash_@@ negative [ - difference ] ++ ; } else { ans += hash_@@ positive [ difference ] ; hash_@@ positive [ difference ] ++ ; } } return ans ; }
PAS@@ CAL_@@ TRIANGLE_@@ 1 | public static void print@@ Pas@@ cal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { System . out . print ( C + " ▁ " ) ; C = C * ( line - i ) / i ; } System . out . println ( ) ; } }
NUMBER_OF_@@ TRIANG@@ LES_@@ IN_@@ A_@@ PLA@@ NE_@@ IF_@@ NO_@@ MORE_@@ TH@@ AN_@@ TWO_@@ POINT@@ S_@@ ARE_@@ COL@@ LINEAR | static int count@@ NumberOf@@ Triangles ( int n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }
MERGE_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S_@@ O@@ 1_@@ EX@@ TRA@@ _SPACE | static void merge ( int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j , last = ar@@ r1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && ar@@ r1 [ j ] > ar@@ r2 [ i ] ; j -- ) ar@@ r1 [ j + 1 ] = ar@@ r1 [ j ] ; if ( j != m - 2 || last > ar@@ r2 [ i ] ) { ar@@ r1 [ j + 1 ] = ar@@ r2 [ i ] ; ar@@ r2 [ i ] = last ; } } }
NEW@@ MAN@@ _SH@@ AN@@ KS_@@ WI@@ LLI@@ AM@@ S_@@ PRI@@ ME | static int n@@ sw@@ p ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return 2 * n@@ sw@@ p ( n - 1 ) + n@@ sw@@ p ( n - 2 ) ; }
SM@@ ALLE@@ ST_@@ OF_@@ THRE@@ E_@@ INTEG@@ ERS_@@ WITH@@ OUT_@@ COMP@@ ARIS@@ ON_@@ OPER@@ ATORS | static int smallest ( int x , int y , int z ) { int c = 0 ; while ( x != 0 && y != 0 && z != 0 ) { x -- ; y -- ; z -- ; c ++ ; } return c ; }
COUNT_@@ PAIR@@ S_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL_@@ GI@@ V@@ EN_@@ VALUE_@@ X | static int count@@ Pairs ( int [ ] ar@@ r1 , int [ ] ar@@ r2 , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( ar@@ r1 [ i ] + ar@@ r2 [ j ] ) == x ) count ++ ; return count ; }
SORT_@@ ARRAY_@@ AP@@ PL@@ Y@@ ING_@@ GI@@ V@@ EN_@@ EQU@@ ATION | static void sort@@ Array ( int arr [ ] , int n , int A , int B , int C ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ] + C ; int index = - 1 ; int maximum = - 999999 ; for ( int i = 0 ; i < n ; i ++ ) { if ( maximum < arr [ i ] ) { index = i ; maximum = arr [ i ] ; } } int i = 0 , j = n - 1 ; int [ ] new_@@ arr = new int [ n ] ; int k = 0 ; while ( i < index && j > index ) { if ( arr [ i ] < arr [ j ] ) new_@@ arr [ k ++ ] = arr [ i ++ ] ; else new_@@ arr [ k ++ ] = arr [ j -- ] ; } while ( i < index ) new_@@ arr [ k ++ ] = arr [ i ++ ] ; while ( j > index ) new_@@ arr [ k ++ ] = arr [ j -- ] ; new_@@ arr [ n - 1 ] = maximum ; for ( int p = 0 ; p < n ; p ++ ) arr [ p ] = new_@@ arr [ p ] ; }
PROGRAM_@@ TO_@@ FIND_@@ THE_@@ AREA_@@ OF_@@ PEN@@ TAG@@ ON | static float find@@ Area ( float a ) { float area ; area = ( float ) ( Math . sqrt ( 5 * ( 5 + 2 * ( Math . sqrt ( 5 ) ) ) ) * a * a ) / 4 ; return area ; }
MAXI@@ MI@@ ZE_@@ S@@ UM_@@ CON@@ SEC@@ UTI@@ VE_@@ DIFF@@ ER@@ EN@@ CES_@@ CIRC@@ ULAR_@@ ARRAY | static int max@@ Sum ( int arr [ ] , int n ) { int sum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { sum -= ( 2 * arr [ i ] ) ; sum += ( 2 * arr [ n - i - 1 ] ) ; } return sum ; }
COUNT_@@ ARRAY@@ S_@@ CON@@ SEC@@ UTI@@ VE_@@ ELEMENT_@@ DIFF@@ ER@@ ENT_@@ VALUES | public static int coun@@ tar@@ ray ( int n , int k , int x ) { int [ ] dp = new int [ 109 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; }
SUM@@ _SERI@@ ES_@@ 12_@@ 32_@@ 5@@ 2_@@ 2@@ N_@@ 12 | static int sum@@ Of@@ Series ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
FIND_@@ THE_@@ NEARE@@ ST@@ _S@@ MAL@@ LER_@@ NUMB@@ ERS_@@ ON_@@ LEFT_@@ SIDE_@@ IN_@@ AN_@@ ARRAY_@@ 1 | static void print@@ Prev@@ S@@ mal@@ ler ( int arr [ ] , int n ) { Stack < Integer > S = new Stack < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! S . empty ( ) && S . peek ( ) >= arr [ i ] ) { S . pop ( ) ; } if ( S . empty ( ) ) { System . out . print ( " _ , ▁ " ) ; } else { System . out . print ( S . peek ( ) + " , ▁ " ) ; } S . push ( arr [ i ] ) ; } }
FIND_@@ NUMBER_OF_@@ TRIANG@@ LES_@@ POSSI@@ BLE_@@ 1 | static void Count@@ Triangles ( int [ ] A ) { int n = A . length ; Arrays . sort ( A ) ; int count = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else { l ++ ; } } } System . out . print ( " No ▁ of ▁ possible ▁ solutions : ▁ " + count ) ; }
MAXIMUM_@@ GAME@@ S_@@ PLAY@@ ED_@@ WIN@@ NER | static int max@@ Game@@ By@@ Win@@ ner ( int N ) { int [ ] dp = new int [ N ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; int i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; }
NUMBER_@@ OF@@ _SUB@@ STRING@@ S_@@ WITH_@@ OD@@ D_@@ DECIMAL_@@ VALUE_@@ IN_@@ A_@@ BINARY_@@ STRING | static int count@@ Sub@@ str ( String s ) { int n = s . length ( ) ; int [ ] aux@@ Arr = new int [ n ] ; if ( s . charAt ( 0 ) == '1' ) aux@@ Arr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) aux@@ Arr [ i ] = aux@@ Arr [ i - 1 ] + 1 ; else aux@@ Arr [ i ] = aux@@ Arr [ i - 1 ] ; } int count = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) if ( s . charAt ( i ) == '1' ) count += aux@@ Arr [ i ] ; return count ; }
ELEMEN@@ TS_@@ TO_@@ BE_@@ AD@@ DE@@ D_S@@ O_@@ TH@@ AT_@@ ALL_@@ ELEMEN@@ TS_@@ OF_@@ A_@@ RANGE_@@ ARE_@@ PRES@@ ENT_@@ IN_@@ ARRAY_@@ 1 | static int count@@ Num ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < > ( ) ; int count = 0 , max@@ m = Integer . MIN_VALUE , min@@ m = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr [ i ] ) ; if ( arr [ i ] < min@@ m ) min@@ m = arr [ i ] ; if ( arr [ i ] > max@@ m ) max@@ m = arr [ i ] ; } for ( int i = min@@ m ; i <= max@@ m ; i ++ ) if ( ! s . contains ( i ) ) count ++ ; return count ; }
WRITE_@@ A_@@ C_@@ PROGRAM_@@ TO_@@ CAL@@ CUL@@ ATE_@@ PO@@ WX@@ N_@@ 1 | static float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }
N_@@ TH_@@ TER@@ M@@ _SERI@@ ES_@@ 2_@@ 12_@@ 36@@ _@@ 8@@ 0_@@ 150 | public static int n@@ th@@ Term ( int n ) { return ( n * n ) + ( n * n * n ) ; }
FIND_@@ THE_@@ NUMBER_@@ OC@@ CURR@@ ING_@@ OD@@ D_@@ NUMBER_OF_@@ TIMES | static int getO@@ dd@@ Occurren@@ ce ( int arr [ ] , int arr_@@ size ) { int i ; for ( i = 0 ; i < arr_@@ size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_@@ size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; }
EF@@ FI@@ CI@@ ENT_@@ METHOD_@@ 2@@ S_@@ COMPLE@@ MENT_@@ BINARY_@@ STRING | static String find@@ Tw@@ os@@ complement ( StringBuffer str ) { int n = str . length ( ) ; int i ; for ( i = n - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == '1' ) break ; if ( i == - 1 ) return "1" + str ; for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( str . charAt ( k ) == '1' ) str . replace ( k , k + 1 , "0" ) ; else str . replace ( k , k + 1 , "1" ) ; } return str . toString ( ) ; }
PAP@@ ER_@@ CU@@ T_@@ MINIMUM_@@ NUMBER@@ _S@@ QUAR@@ ES@@ _SET_@@ 2 | static int minimum@@ Square ( int m , int n ) { int vertical@@ _min = Integer . MAX_VALUE ; int horizont@@ al_@@ min = Integer . MAX_VALUE ; if ( m == n ) return 1 ; if ( dp [ m ] [ n ] != 0 ) return dp [ m ] [ n ] ; for ( int i = 1 ; i <= m / 2 ; i ++ ) { horizont@@ al_@@ min = Math . min ( minimum@@ Square ( i , n ) + minimum@@ Square ( m - i , n ) , horizont@@ al_@@ min ) ; } for ( int j = 1 ; j <= n / 2 ; j ++ ) { vertical@@ _min = Math . min ( minimum@@ Square ( m , j ) + minimum@@ Square ( m , n - j ) , vertical@@ _min ) ; } dp [ m ] [ n ] = Math . min ( vertical@@ _min , horizont@@ al_@@ min ) ; return dp [ m ] [ n ] ; }
MINI@@ MI@@ ZE_@@ ABSOL@@ UTE_@@ DIFF@@ ER@@ ENCE_@@ S@@ UM_@@ TW@@ O@@ _SUB@@ SETS | static void sub@@ set@@ Difference ( int n ) { int s = n * ( n + 1 ) / 2 ; if ( n % 4 == 0 ) { System . out . println ( " First ▁ subset ▁ sum ▁ = ▁ " + s / 2 ) ; System . out . println ( " Second ▁ subset ▁ sum ▁ = ▁ " + s / 2 ) ; System . out . println ( " Difference ▁ = ▁ " + 0 ) ; } else { if ( n % 4 == 1 || n % 4 == 2 ) { System . out . println ( " First ▁ subset ▁ sum ▁ = ▁ " + s / 2 ) ; System . out . println ( " Second ▁ subset ▁ sum ▁ = ▁ " + ( ( s / 2 ) + 1 ) ) ; System . out . println ( " Difference ▁ = ▁ " + 1 ) ; } else { System . out . println ( " First ▁ subset ▁ sum ▁ = ▁ " + s / 2 ) ; System . out . println ( " Second ▁ subset ▁ sum ▁ = ▁ " + s / 2 ) ; System . out . println ( " Difference ▁ = ▁ " + 0 ) ; } } }
PROGRAM_@@ CAL@@ CUL@@ ATE_@@ VOLUME_@@ ELLIP@@ SO@@ ID | public static float volume@@ Of@@ Ellip@@ soid ( float r1 , float r2 , float r3 ) { float pi = ( float ) 3.14 ; return ( float ) 1.@@ 33 * pi * r1 * r2 * r3 ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 13@@ _C@@ UT@@ TING_@@ A_@@ RO@@ D | static int cut@@ Ro@@ d ( int price [ ] , int n ) { int val [ ] = new int [ n + 1 ] ; val [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int max_@@ val = Integer . MIN_VALUE ; for ( int j = 0 ; j < i ; j ++ ) max_@@ val = Math . max ( max_@@ val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_@@ val ; } return val [ n ] ; }
RECUR@@ SIVE_@@ INSER@@ TION@@ _S@@ ORT | static void insertion@@ Sort@@ Recursive ( int arr [ ] , int n ) { if ( n <= 1 ) return ; insertion@@ Sort@@ Recursive ( arr , n - 1 ) ; int last = arr [ n - 1 ] ; int j = n - 2 ; while ( j >= 0 && arr [ j ] > last ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = last ; }
FIND_@@ EXPRES@@ SION_@@ DUPLIC@@ ATE_@@ PARENTHE@@ SI@@ S_@@ NOT | static boolean find@@ Duplicate@@ parenthesis ( String s ) { Stack < Character > Stack = new Stack < > ( ) ; char [ ] str = s . toCharArray ( ) ; for ( char ch : str ) { if ( ch == ' ) ' ) { char top = Stack . peek ( ) ; Stack . pop ( ) ; int element@@ sIn@@ side = 0 ; while ( top != ' ( ' ) { element@@ sIn@@ side ++ ; top = Stack . peek ( ) ; Stack . pop ( ) ; } if ( element@@ sIn@@ side < 1 ) { return true ; } } else { Stack . push ( ch ) ; } } return false ; }
FIND_@@ REPE@@ TI@@ TIVE_@@ ELEMENT_@@ 1_@@ N_@@ 1 | static int find@@ Repe@@ ating ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum - ( ( ( n - 1 ) * n ) / 2 ) ; }
CHECK_@@ ARRAY_@@ CONTAIN@@ S_@@ CON@@ TI@@ GU@@ OUS_@@ INTEG@@ ERS_@@ DUPLIC@@ ATE@@ S_@@ ALLOWED | static boolean are@@ Elements@@ Contigu@@ ous ( int arr [ ] , int n ) { int max = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { max = Math . max ( max , arr [ i ] ) ; min = Math . min ( min , arr [ i ] ) ; } int m = max - min + 1 ; if ( m > n ) return false ; boolean visited [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; }
LENGTH_@@ LON@@ GE@@ ST_@@ BAL@@ ANCE@@ D@@ _SUB@@ SEQU@@ ENCE_@@ 1 | static int maxLength ( String s , int n ) { int invalid@@ Open@@ Br@@ aces = 0 ; int invalid@@ Close@@ Br@@ aces = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) { invalid@@ Open@@ Br@@ aces ++ ; } else { if ( invalid@@ Open@@ Br@@ aces == 0 ) { invalid@@ Close@@ Br@@ aces ++ ; } else { invalid@@ Open@@ Br@@ aces -- ; } } } return ( n - ( invalid@@ Open@@ Br@@ aces + invalid@@ Close@@ Br@@ aces ) ) ; }
SUM@@ _SERI@@ ES_@@ ALTER@@ N@@ ATE_@@ SIGNE@@ D_S@@ QUAR@@ ES_@@ AP_@@ 1 | static int se@@ i@@ res@@ Sum ( int n , int [ ] a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }
EQU@@ ILI@@ BRI@@ UM_@@ INDEX_@@ OF_@@ AN_@@ ARRAY | int equi@@ lib@@ ri@@ um ( int arr [ ] , int n ) { int i , j ; int left@@ sum , right@@ sum ; for ( i = 0 ; i < n ; ++ i ) { left@@ sum = 0 ; for ( j = 0 ; j < i ; j ++ ) left@@ sum += arr [ j ] ; right@@ sum = 0 ; for ( j = i + 1 ; j < n ; j ++ ) right@@ sum += arr [ j ] ; if ( left@@ sum == right@@ sum ) return i ; } return - 1 ; }
COUNT_@@ WAY@@ S_@@ REACH_@@ N@@ TH_@@ ST@@ AI@@ R_@@ USING_@@ STEP_@@ 1_2_@@ 3 | public static int find@@ Step ( int n ) { if ( n == 1 || n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return find@@ Step ( n - 3 ) + find@@ Step ( n - 2 ) + find@@ Step ( n - 1 ) ; }
FIND_@@ MINIMUM_@@ NUMBER_OF_@@ CO@@ INS_@@ TH@@ AT_@@ MAKE_@@ A_@@ CHANGE | static int min@@ Coins ( int coins [ ] , int m , int V ) { if ( V == 0 ) return 0 ; int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { int sub_@@ res = min@@ Coins ( coins , m , V - coins [ i ] ) ; if ( sub_@@ res != Integer . MAX_VALUE && sub_@@ res + 1 < res ) res = sub_@@ res + 1 ; } } return res ; }
B@@ ELL_@@ NUMB@@ ERS_@@ NUMBER_OF_@@ WAY@@ S_TO_@@ PARTITION_@@ A@@ _SET | static int b@@ ell@@ Number ( int n ) { int [ ] [ ] b@@ ell = new int [ n + 1 ] [ n + 1 ] ; b@@ ell [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { b@@ ell [ i ] [ 0 ] = b@@ ell [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j <= i ; j ++ ) b@@ ell [ i ] [ j ] = b@@ ell [ i - 1 ] [ j - 1 ] + b@@ ell [ i ] [ j - 1 ] ; } return b@@ ell [ n ] [ 0 ] ; }
FIND_@@ ELEMENT_@@ GI@@ V@@ EN_@@ INDEX_@@ NUMBER_@@ ROTA@@ TIONS | static int findElement ( int [ ] arr , int [ ] [ ] ranges , int rot@@ ations , int index ) { for ( int i = rot@@ ations - 1 ; i >= 0 ; i -- ) { int left = ranges [ i ] [ 0 ] ; int right = ranges [ i ] [ 1 ] ; if ( left <= index && right >= index ) { if ( index == left ) index = right ; else index -- ; } } return arr [ index ] ; }
DY@@ CK_@@ PATH | public static int count@@ Dy@@ ck@@ Paths ( int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }
COUN@@ TING_@@ PAIR@@ S_@@ PERS@@ ON_@@ CAN_@@ FORM_@@ PA@@ IR_@@ ONE | static int numberOf@@ W@@ ays ( int x ) { if ( x == 0 || x == 1 ) return 1 ; else return numberOf@@ W@@ ays ( x - 1 ) + ( x - 1 ) * numberOf@@ W@@ ays ( x - 2 ) ; }
PROGRAM_@@ DISPLAY_@@ A@@ STRO@@ LOG@@ IC@@ AL@@ _SIGN@@ _@@ ZO@@ DI@@ AC@@ _SIGN@@ _@@ GI@@ V@@ EN_@@ DATE_@@ B@@ IR@@ TH | static void zo@@ di@@ ac_@@ sign ( int day , String month ) { String ast@@ ro_@@ sign = " " ; if ( month == " de@@ ce@@ mber " ) { if ( day < 22 ) ast@@ ro_@@ sign = " S@@ ag@@ it@@ t@@ ari@@ us " ; else ast@@ ro_@@ sign = " cap@@ ri@@ cor@@ n " ; } else if ( month == " j@@ anuary " ) { if ( day < 20 ) ast@@ ro_@@ sign = " Cap@@ ri@@ cor@@ n " ; else ast@@ ro_@@ sign = " a@@ qu@@ ari@@ us " ; } else if ( month == " fe@@ bruary " ) { if ( day < 19 ) ast@@ ro_@@ sign = " A@@ qu@@ ari@@ us " ; else ast@@ ro_@@ sign = " p@@ is@@ ces " ; } else if ( month == " mar@@ ch " ) { if ( day < 21 ) ast@@ ro_@@ sign = " P@@ is@@ ces " ; else ast@@ ro_@@ sign = " aries " ; } else if ( month == " ap@@ ri@@ l " ) { if ( day < 20 ) ast@@ ro_@@ sign = " Ari@@ es " ; else ast@@ ro_@@ sign = " ta@@ ur@@ us " ; } else if ( month == " may " ) { if ( day < 21 ) ast@@ ro_@@ sign = " Ta@@ ur@@ us " ; else ast@@ ro_@@ sign = " ge@@ mini " ; } else if ( month == " jun@@ e " ) { if ( day < 21 ) ast@@ ro_@@ sign = " Ge@@ mini " ; else ast@@ ro_@@ sign = " can@@ cer " ; } else if ( month == " j@@ uly " ) { if ( day < 23 ) ast@@ ro_@@ sign = " Can@@ cer " ; else ast@@ ro_@@ sign = " le@@ o " ; } else if ( month == " au@@ gu@@ st " ) { if ( day < 23 ) ast@@ ro_@@ sign = " Le@@ o " ; else ast@@ ro_@@ sign = " vir@@ go " ; } else if ( month == " sep@@ tember " ) { if ( day < 23 ) ast@@ ro_@@ sign = " Vi@@ r@@ go " ; else ast@@ ro_@@ sign = " libr@@ a " ; } else if ( month == " oc@@ to@@ ber " ) { if ( day < 23 ) ast@@ ro_@@ sign = " Libr@@ a " ; else ast@@ ro_@@ sign = " scor@@ p@@ io " ; } else if ( month == " no@@ vember " ) { if ( day < 22 ) ast@@ ro_@@ sign = " scor@@ p@@ io " ; else ast@@ ro_@@ sign = " sag@@ it@@ t@@ ari@@ us " ; } System . out . println ( ast@@ ro_@@ sign ) ; }
PROGRAM_@@ REVERSE_@@ STRING_@@ ITER@@ ATI@@ VE_@@ RECUR@@ SIVE_@@ 2 | static void recursive@@ Reverse ( char [ ] str , int i ) { int n = str . length ; if ( i == n / 2 ) return ; swap ( str , i , n - i - 1 ) ; recursive@@ Reverse ( str , i + 1 ) ; }
K_@@ TH_@@ DIG@@ IT_@@ RAI@@ SED_@@ POWER_@@ B | public static int k@@ th@@ digit ( int a , int b , int k ) { int p = ( int ) Math . pow ( a , b ) ; int count = 0 ; while ( p > 0 && count < k ) { int rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; }
SM@@ ALLE@@ ST_@@ DIFF@@ ER@@ ENCE_@@ PA@@ IR_@@ VALU@@ ES_@@ TWO_@@ UN@@ SOR@@ TED_@@ ARRAY@@ S | static int find@@ S@@ malle@@ st@@ Difference ( int A [ ] , int B [ ] , int m , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; int a = 0 , b = 0 ; int result = Integer . MAX_VALUE ; while ( a < m && b < n ) { if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
MAXIMUM_@@ AREA_@@ REC@@ TAN@@ GLE_@@ PIC@@ KING_@@ FOUR@@ _SI@@ DES_@@ ARRAY_@@ 1 | static int find@@ Area ( int arr [ ] , int n ) { Set < Integer > s = new HashSet < > ( ) ; int first = 0 , second = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . contains ( arr [ i ] ) ) { s . add ( arr [ i ] ) ; continue ; } if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } return ( first * second ) ; }
PROGRAM_@@ PAGE_@@ REPLACE@@ MENT_@@ ALGORITH@@ MS@@ _SET_@@ 2_@@ FIFO | static int page@@ Fa@@ ults ( int pages [ ] , int n , int capacity ) { HashSet < Integer > s = new HashSet < > ( capacity ) ; Queue < Integer > indexes = new LinkedList < > ( ) ; int page_@@ fa@@ ults = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . size ( ) < capacity ) { if ( ! s . contains ( pages [ i ] ) ) { s . add ( pages [ i ] ) ; page_@@ fa@@ ults ++ ; indexes . add ( pages [ i ] ) ; } } else { if ( ! s . contains ( pages [ i ] ) ) { int val = indexes . peek ( ) ; indexes . poll ( ) ; s . remove ( val ) ; s . add ( pages [ i ] ) ; indexes . add ( pages [ i ] ) ; page_@@ fa@@ ults ++ ; } } } return page_@@ fa@@ ults ; }
FIND_@@ LAR@@ GE@@ ST_@@ D_@@ IN_@@ ARRAY@@ _SU@@ CH_@@ TH@@ AT_@@ A_@@ B_@@ C_@@ D_@@ 1 | static int find@@ Four@@ Elements ( int [ ] arr , int n ) { HashMap < Integer , Indexes > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { map . put ( arr [ i ] + arr [ j ] , new Indexes ( i , j ) ) ; } } int d = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_@@ diff = Math . abs ( arr [ i ] - arr [ j ] ) ; if ( map . containsKey ( abs_@@ diff ) ) { Indexes indexes = map . get ( abs_@@ diff ) ; if ( indexes . get@@ I ( ) != i && indexes . get@@ I ( ) != j && indexes . get@@ J ( ) != i && indexes . get@@ J ( ) != j ) { d = Math . max ( d , Math . max ( arr [ i ] , arr [ j ] ) ) ; } } } } return d ; }
PRINT_@@ GI@@ V@@ EN_@@ MATRIX_@@ REVERSE_@@ SPIR@@ AL_@@ FORM | public static void Reverse@@ spir@@ al@@ Print ( int m , int n , int a [ ] [ ] ) { long b [ ] = new long [ 100 ] ; int i , k = 0 , l = 0 ; int z = 0 ; int size = m * n ; while ( k < m && l < n ) { int val ; for ( i = l ; i < n ; ++ i ) { val = a [ k ] [ i ] ; b [ z ] = val ; ++ z ; } k ++ ; for ( i = k ; i < m ; ++ i ) { val = a [ i ] [ n - 1 ] ; b [ z ] = val ; ++ z ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { val = a [ m - 1 ] [ i ] ; b [ z ] = val ; ++ z ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { val = a [ i ] [ l ] ; b [ z ] = val ; ++ z ; } l ++ ; } } for ( int x = size - 1 ; x >= 0 ; -- x ) { System . out . print ( b [ x ] + " ▁ " ) ; } }
NUMBER_@@ N_@@ DIG@@ IT@@ S_@@ NON_@@ DECRE@@ AS@@ ING_@@ INTEG@@ ERS | static int non@@ Dec@@ Num@@ s ( int n ) { int [ ] [ ] a = new int [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; }
LON@@ GE@@ ST_@@ EV@@ EN_@@ LENGTH@@ _SUB@@ STRING@@ _S@@ UM_@@ FIR@@ ST@@ _SECON@@ D_@@ HALF | static int find@@ Length ( String str ) { int n = str . length ( ) ; int maxlen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j += 2 ) { int length = j - i + 1 ; int left@@ sum = 0 , right@@ sum = 0 ; for ( int k = 0 ; k < length / 2 ; k ++ ) { left@@ sum += ( str . charAt ( i + k ) - '0' ) ; right@@ sum += ( str . charAt ( i + k + length / 2 ) - '0' ) ; } if ( left@@ sum == right@@ sum && maxlen < length ) maxlen = length ; } } return maxlen ; }
PROGRAM_@@ WOR@@ ST_@@ FI@@ T_@@ ALGORITH@@ M_@@ MEMORY_@@ MAN@@ A@@ GEMENT | static void wor@@ st@@ Fit ( int blockSize [ ] , int m , int process@@ Size [ ] , int n ) { int allocation [ ] = new int [ n ] ; for ( int i = 0 ; i < allocation . length ; i ++ ) allocation [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int w@@ st@@ Idx = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= process@@ Size [ i ] ) { if ( w@@ st@@ Idx == - 1 ) w@@ st@@ Idx = j ; else if ( blockSize [ w@@ st@@ Idx ] < blockSize [ j ] ) w@@ st@@ Idx = j ; } } if ( w@@ st@@ Idx != - 1 ) { allocation [ i ] = w@@ st@@ Idx ; blockSize [ w@@ st@@ Idx ] -= process@@ Size [ i ] ; } } System . out . println ( " \n Process ▁ No . \t@@ Process ▁ Size@@ \t@@ Block ▁ no . " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( " ▁ ▁ ▁ " + ( i + 1 ) + " \t\t " + process@@ Size [ i ] + " \t\t " ) ; if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 ) ; else System . out . print ( " Not ▁ Allocated " ) ; System . out . println ( ) ; } }
SUM@@ _SUB@@ SET@@ S@@ _SET_@@ FOR@@ MED_@@ FIRST_@@ N_@@ N@@ ATUR@@ AL_@@ NUMB@@ ERS | static long find@@ Sum@@ Sub@@ sets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
ADD_@@ TWO_@@ NUMB@@ ERS_@@ WITH@@ OUT_@@ USING_@@ ARI@@ TH@@ ME@@ TIC_@@ OPER@@ ATORS | static int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }
MAXIMUM_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENT_@@ TER@@ M_@@ VALUE | static int max@@ coeffici@@ ent@@ value ( int n ) { int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int max@@ value = 0 ; for ( int i = 0 ; i <= n ; i ++ ) max@@ value = Math . max ( max@@ value , C [ n ] [ i ] ) ; return max@@ value ; }
E@@ UL@@ ERI@@ AN_@@ PATH_@@ UN@@ DIREC@@ TED_@@ GRAP@@ H | static void find@@ path ( int [ ] [ ] graph , int n ) { Vector < Integer > nu@@ mo@@ f@@ adj = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) nu@@ mo@@ f@@ adj . add ( accumulate ( graph [ i ] , 0 ) ) ; int start@@ Point = 0 , nu@@ mo@@ fo@@ dd = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( nu@@ mo@@ f@@ adj . elementAt ( i ) % 2 == 1 ) { nu@@ mo@@ fo@@ dd ++ ; start@@ Point = i ; } } if ( nu@@ mo@@ fo@@ dd > 2 ) { System . out . println ( " No ▁ Solution " ) ; return ; } Stack < Integer > stack = new Stack < > ( ) ; Vector < Integer > path = new Vector < > ( ) ; int cur = start@@ Point ; while ( ! stack . isEmpty ( ) || accumulate ( graph [ cur ] , 0 ) != 0 ) { if ( accumulate ( graph [ cur ] , 0 ) == 0 ) { path . add ( cur ) ; cur = stack . pop ( ) ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( graph [ cur ] [ i ] == 1 ) { stack . add ( cur ) ; graph [ cur ] [ i ] = 0 ; graph [ i ] [ cur ] = 0 ; cur = i ; break ; } } } } for ( int ele : path ) System . out . print ( ele + " ▁ - > ▁ " ) ; System . out . println ( cur ) ; }
RECUR@@ SIVE_@@ SOLU@@ TION_@@ COUNT_@@ SUB@@ STRING@@ S_@@ FIRST_@@ LAST_@@ CHARAC@@ TERS | static int count@@ Sub@@ strs ( String str , int i , int j , int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; int res = count@@ Sub@@ strs ( str , i + 1 , j , n - 1 ) + count@@ Sub@@ strs ( str , i , j - 1 , n - 1 ) - count@@ Sub@@ strs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str . charAt ( i ) == str . charAt ( j ) ) res ++ ; return res ; }
FIND_@@ NUMBER_@@ TIME@@ S_@@ STRING_@@ OC@@ CUR@@ S_@@ GI@@ V@@ EN_@@ STRING_@@ 1 | static int count ( String a , String b ) { int m = a . length ( ) ; int n = b . length ( ) ; int lookup [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) lookup [ 0 ] [ i ] = 0 ; for ( int i = 0 ; i <= m ; ++ i ) lookup [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ; else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ; } } return lookup [ m ] [ n ] ; }
AREA_@@ OF_@@ A_@@ POLYG@@ ON_@@ WITH_@@ GI@@ V@@ EN_@@ N_@@ ORDE@@ RED_@@ VER@@ TIC@@ ES | public static double polygon@@ Area ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; }
PRINT_@@ POSSI@@ BLE_@@ SUM@@ S_@@ CON@@ SEC@@ UTI@@ VE_@@ NUMBER@@ S_S@@ UM_@@ N | static void find@@ Con@@ sec@@ utive ( int N ) { int start = 1 ; int end = ( N + 1 ) / 2 ; while ( start < end ) { int sum = 0 ; for ( int i = start ; i <= end ; i ++ ) { sum = sum + i ; if ( sum == N ) { for ( int j = start ; j <= i ; j ++ ) System . out . print ( j + " ▁ " ) ; System . out . println ( ) ; break ; } if ( sum > N ) break ; } sum = 0 ; start ++ ; } }
BAL@@ AN@@ CED_@@ EXPRES@@ SION@@ S@@ _SU@@ CH_@@ TH@@ AT_@@ GI@@ V@@ EN_@@ POSI@@ TIONS_@@ HAVE_@@ OPEN@@ ING_@@ BRAC@@ KETS | static long arrange@@ Br@@ aces ( int n , int pos [ ] , int k ) { boolean h [ ] = new boolean [ N ] ; int dp [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < k ; i ++ ) { h [ pos [ i ] ] = true ; } dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { for ( int j = 0 ; j <= 2 * n ; j ++ ) { if ( h [ i ] ) { if ( j != 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 0 ; } } else if ( j != 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } } } return dp [ 2 * n ] [ 0 ] ; }
GI@@ V@@ EN_@@ 1@@ S_@@ 2@@ S_@@ 3@@ S_@@ KS_@@ PRINT_@@ ZI@@ G_@@ Z@@ A@@ G_@@ WAY | public static void Z@@ ig@@ Z@@ ag ( int rows , int columns , int numbers [ ] ) { int k = 0 ; int [ ] [ ] arr = new int [ rows ] [ columns ] ; for ( int i = 0 ; i < rows ; i ++ ) { if ( i % 2 == 0 ) { for ( int j = 0 ; j < columns && numbers [ k ] > 0 ; j ++ ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) k ++ ; } } else { for ( int j = columns - 1 ; j >= 0 && numbers [ k ] > 0 ; j -- ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) k ++ ; } } } for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns ; j ++ ) System . out . print ( arr [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } }
CONVERT_@@ STRING_@@ BIN@@ AR@@ Y@@ _SEQU@@ ENCE | static void str@@ To@@ Binary ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int val = Integer . valueOf ( s . charAt ( i ) ) ; String bin = " " ; while ( val > 0 ) { if ( val % 2 == 1 ) { bin += '1' ; } else bin += '0' ; val /= 2 ; } bin = reverse ( bin ) ; System . out . print ( bin + " ▁ " ) ; } }
L@@ UC@@ K@@ Y_@@ NUMB@@ ERS | static boolean is@@ Lu@@ ck@@ y ( int n ) { int next_@@ position = n ; if ( counter > n ) return true ; if ( n % counter == 0 ) return false ; next_@@ position -= next_@@ position / counter ; counter ++ ; return is@@ Lu@@ ck@@ y ( next_@@ position ) ; }
SM@@ ALLE@@ ST@@ _S@@ UM_@@ CON@@ TI@@ GU@@ OU@@ S@@ _SUB@@ ARRAY | static int smalle@@ st@@ Sum@@ Sub@@ arr ( int arr [ ] , int n ) { int min_@@ ending_@@ here = 2147483647 ; int min_@@ so@@ _f@@ ar = 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_@@ ending_@@ here > 0 ) min_@@ ending_@@ here = arr [ i ] ; else min_@@ ending_@@ here += arr [ i ] ; min_@@ so@@ _f@@ ar = Math . min ( min_@@ so@@ _f@@ ar , min_@@ ending_@@ here ) ; } return min_@@ so@@ _f@@ ar ; }
PRINT_@@ N_@@ TER@@ MS_@@ NEW@@ MAN_@@ CON@@ WAY@@ _SEQU@@ ENCE | public static void sequence ( int n ) { int f [ ] = new int [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; System . out . print ( f [ 1 ] + " ▁ " + f [ 2 ] + " ▁ " ) ; for ( int i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; System . out . print ( f [ i ] + " ▁ " ) ; } }
MASTER_@@ THE@@ O@@ RE@@ M@@ _SUB@@ TRAC@@ T_@@ CON@@ QU@@ ER_@@ RE@@ CURR@@ EN@@ CES | static int fi@@ b ( int n ) { if ( n <= 1 ) return n ; return fi@@ b ( n - 1 ) + fi@@ b ( n - 2 ) ; }
MINIMUM_@@ CO@@ ST_@@ MAKE_@@ ARRAY@@ _SIZE_@@ 1_@@ REMO@@ V@@ ING_@@ L@@ ARG@@ ER_@@ PAIR@@ S | static int cost ( int [ ] a , int n ) { int min = a [ 0 ] ; for ( int i = 1 ; i < a . length ; i ++ ) { if ( a [ i ] < min ) min = a [ i ] ; } return ( n - 1 ) * min ; }
CHO@@ COL@@ ATE_@@ DISTRIBU@@ TION_@@ PRO@@ BLE@@ M | static int find@@ Min@@ Diff ( int arr [ ] , int n , int m ) { if ( m == 0 || n == 0 ) return 0 ; Arrays . sort ( arr ) ; if ( n < m ) return - 1 ; int min_@@ diff = Integer . MAX_VALUE ; int first = 0 , last = 0 ; for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_@@ diff ) { min_@@ diff = diff ; first = i ; last = i + m - 1 ; } } return ( arr [ last ] - arr [ first ] ) ; }
FIND_@@ ONE_@@ EXTRA_@@ CHARACTER_@@ STRING_@@ 1 | static char find@@ Extra@@ Char@@ c@@ ter ( String str@@ A , String str@@ B ) { int res = 0 , i ; for ( i = 0 ; i < str@@ A . length ( ) ; i ++ ) { res ^= str@@ A . charAt ( i ) ; } for ( i = 0 ; i < str@@ B . length ( ) ; i ++ ) { res ^= str@@ B . charAt ( i ) ; } return ( ( char ) ( res ) ) ; }
CHECK_@@ WHE@@ THER_@@ TWO_@@ STRING@@ S_@@ ARE_@@ AN@@ AG@@ RAM_@@ OF_@@ E@@ ACH@@ _@@ OTHER | static boolean are@@ An@@ agram ( char [ ] str1 , char [ ] str2 ) { int n1 = str1 . length ; int n2 = str2 . length ; if ( n1 != n2 ) return false ; Arrays . sort ( str1 ) ; Arrays . sort ( str2 ) ; for ( int i = 0 ; i < n1 ; i ++ ) if ( str1 [ i ] != str2 [ i ] ) return false ; return true ; }
CAL@@ CUL@@ ATE_@@ MAXIMUM_@@ VALUE_@@ US@@ ING@@ _SIGN@@ _@@ TWO_@@ NUMB@@ ERS_@@ STRING | static int calc@@ Max@@ Value ( String str ) { int res = str . charAt ( 0 ) - '0' ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == '0' || str . charAt ( i ) == '1' || res < 2 ) res += ( str . charAt ( i ) - '0' ) ; else res *= ( str . charAt ( i ) - '0' ) ; } return res ; }
FIN@@ D_S@@ UM_@@ MODUL@@ O_@@ K_@@ FIRST_@@ N_@@ N@@ ATUR@@ AL_@@ NUMBER | static int find@@ Sum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }
DISTRIBU@@ TING_@@ ITE@@ MS_@@ PERS@@ ON_@@ CANNOT_@@ TA@@ KE_@@ TWO_@@ ITE@@ MS_@@ TYPE_@@ 1 | static boolean check@@ Count ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > hash = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! hash . containsKey ( arr [ i ] ) ) hash . put ( arr [ i ] , 0 ) ; hash . put ( arr [ i ] , hash . get ( arr [ i ] ) + 1 ) ; } for ( Map . Entry x : hash . entrySet ( ) ) if ( ( int ) x . getValue ( ) > 2 * k ) return false ; return true ; }
SEARCH_@@ IN_@@ ROW_@@ WI@@ SE_@@ AND_@@ COLUMN_@@ WI@@ SE_@@ SOR@@ TED_@@ MATRIX | private static void search ( int [ ] [ ] mat , int n , int x ) { int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { System . out . print ( " n ▁ Found ▁ at ▁ " + i + " ▁ " + j ) ; return ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } System . out . print ( " n ▁ Element ▁ not ▁ found " ) ; return ; }
RETURN_@@ PREVI@@ OUS_@@ ELEMENT_@@ IN_@@ AN_@@ EXP@@ AND@@ ING_@@ MATRIX | static StringBuilder find@@ Left ( StringBuilder str ) { int n = str . length ( ) ; while ( n > 0 ) { n -- ; if ( str . charAt ( n ) == ' d ' ) { str . set@@ Char@@ At ( n , ' c ' ) ; break ; } if ( str . charAt ( n ) == ' b ' ) { str . set@@ Char@@ At ( n , ' a ' ) ; break ; } if ( str . charAt ( n ) == ' a ' ) str . set@@ Char@@ At ( n , ' b ' ) ; else if ( str . charAt ( n ) == ' c ' ) str . set@@ Char@@ At ( n , ' d ' ) ; } return str ; }
S@@ UM_@@ FAC@@ TOR@@ S_@@ NUMBER | static int div@@ Sum ( int n ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } } return ( result + n + 1 ) ; }
HO@@ W_@@ CAN_@@ W@@ E_@@ S@@ UM_@@ THE_@@ DIG@@ IT@@ S_@@ OF_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ IN@@ _SIN@@ GLE_@@ STATE@@ MENT_@@ 2 | static int sum@@ Digits ( int no ) { return no == 0 ? 0 : no % 10 + sum@@ Digits ( no / 10 ) ; }
CHECK_@@ POSSI@@ BLE_@@ SORT_@@ ARRAY_@@ CONDITION@@ AL@@ _SW@@ APP@@ ING_@@ AD@@ J@@ AC@@ ENT_@@ ALLOWED | static boolean checkFor@@ Sorting ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { int temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } else return false ; } } return true ; }
SUP@@ ER_@@ PRI@@ ME | static void Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( int n , boolean is@@ Prime [ ] ) { is@@ Prime [ 0 ] = is@@ Prime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) is@@ Prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( is@@ Prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) is@@ Prime [ i ] = false ; } } }
PROGRAM_@@ BINARY_@@ DECIMAL_@@ CON@@ VERSION_@@ 1 | static int binary@@ To@@ Decimal ( String n ) { String num = n ; int dec_@@ value = 0 ; int base = 1 ; int len = num . length ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( num . charAt ( i ) == '1' ) dec_@@ value += base ; base = base * 2 ; } return dec_@@ value ; }
LE@@ ON@@ AR@@ DO_@@ NUMBER | static int le@@ on@@ ar@@ do ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return ( le@@ on@@ ar@@ do ( n - 1 ) + le@@ on@@ ar@@ do ( n - 2 ) + 1 ) ; }
CHECK_@@ ARRAY_@@ CONTAIN@@ S_@@ CON@@ TI@@ GU@@ OUS_@@ INTEG@@ ERS_@@ DUPLIC@@ ATE@@ S_@@ ALLOWED_@@ 1 | static Boolean are@@ Elements@@ Contigu@@ ous ( int arr [ ] , int n ) { HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) us . add ( arr [ i ] ) ; int count = 1 ; int curr_@@ ele = arr [ 0 ] - 1 ; while ( us . contains ( curr_@@ ele ) == true ) { count ++ ; curr_@@ ele -- ; } curr_@@ ele = arr [ 0 ] + 1 ; while ( us . contains ( curr_@@ ele ) == true ) { count ++ ; curr_@@ ele ++ ; } return ( count == ( us . size ( ) ) ) ; }
SQU@@ ARE_@@ ROOT_@@ OF_@@ AN_@@ INTEGER | static int floor@@ Sqrt ( int x ) { if ( x == 0 || x == 1 ) return x ; int i = 1 , result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; }
LE@@ XI@@ CO@@ GRAPHIC@@ AL@@ LY_@@ LAR@@ GE@@ ST@@ _SUB@@ SEQU@@ ENCE_@@ EVER@@ Y_@@ CHARACTER_@@ OC@@ CUR@@ S_@@ LEA@@ ST_@@ K_@@ TIMES | static void sub@@ sequence ( char s [ ] , char t [ ] , int n , int k ) { int last = 0 , cnt = 0 , new_@@ last = 0 , size = 0 ; for ( char ch = ' z ' ; ch >= ' a ' ; ch -- ) { cnt = 0 ; for ( int i = last ; i < n ; i ++ ) { if ( s [ i ] == ch ) cnt ++ ; } if ( cnt >= k ) { for ( int i = last ; i < n ; i ++ ) { if ( s [ i ] == ch ) { t [ size ++ ] = ch ; new_@@ last = i ; } } last = new_@@ last ; } } t [ size ] = ' \0' ; }
RECUR@@ SI@@ VEL@@ Y_@@ BREAK_@@ NUMBER_@@ 3_@@ PAR@@ TS_@@ GET_@@ MAX@@ IM@@ UM@@ _S@@ UM | static int break@@ Sum ( int n ) { if ( n == 0 || n == 1 ) return n ; return Math . max ( ( break@@ Sum ( n / 2 ) + break@@ Sum ( n / 3 ) + break@@ Sum ( n / 4 ) ) , n ) ; }
MINIMUM_@@ NUMBER@@ _SW@@ AP@@ S_@@ REQUI@@ RE@@ D_S@@ ORT_@@ ARRAY | public static int min@@ Sw@@ aps ( int [ ] arr ) { int n = arr . length ; ArrayList < Pair < Integer , Integer > > arr@@ pos = new ArrayList < Pair < Integer , Integer > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) arr@@ pos . add ( new Pair < Integer , Integer > ( arr [ i ] , i ) ) ; arr@@ pos . sort ( new Comparator < Pair < Integer , Integer > > ( ) { @ Override public int compare ( Pair < Integer , Integer > o1 , Pair < Integer , Integer > o2 ) { if ( o1 . getKey ( ) > o2 . getKey ( ) ) return - 1 ; else if ( o1 . getKey ( ) . equals ( o2 . getKey ( ) ) ) return 0 ; else return 1 ; } } ) ; Boolean [ ] vis = new Boolean [ n ] ; Arrays . fill ( vis , false ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || arr@@ pos . get ( i ) . getValue ( ) == i ) continue ; int cycle@@ _size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = true ; j = arr@@ pos . get ( j ) . getValue ( ) ; cycle@@ _size ++ ; } if ( cycle@@ _size > 0 ) { ans += ( cycle@@ _size - 1 ) ; } } return ans ; }
DIAG@@ ON@@ AL@@ LY_@@ DO@@ MIN@@ ANT_@@ MATRIX | static boolean is@@ DD@@ M ( int m [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += Math . abs ( m [ i ] [ j ] ) ; sum -= Math . abs ( m [ i ] [ i ] ) ; if ( Math . abs ( m [ i ] [ i ] ) < sum ) return false ; } return true ; }
SP@@ LIT_@@ N_@@ MAXIMUM_@@ COMPOSI@@ TE_@@ NUMB@@ ERS | static int count ( int n ) { if ( n < 4 ) return - 1 ; int rem = n % 4 ; if ( rem == 0 ) return n / 4 ; if ( rem == 1 ) { if ( n < 9 ) return - 1 ; return ( n - 9 ) / 4 + 1 ; } if ( rem == 2 ) return ( n - 6 ) / 4 + 1 ; if ( rem == 3 ) { if ( n < 15 ) return - 1 ; return ( n - 15 ) / 4 + 2 ; } return 0 ; }
FIND_@@ DIMEN@@ SION@@ S_@@ RIGHT_@@ ANG@@ LED_@@ TRI@@ ANGLE | static void find@@ Di@@ men ( int H , int A ) { if ( H * H < 4 * A ) { System . out . println ( " Not ▁ Possible " ) ; return ; } double ap@@ b = Math . sqrt ( H * H + 4 * A ) ; double as@@ b = Math . sqrt ( H * H - 4 * A ) ; System . out . println ( " P ▁ = ▁ " + Math . round ( ( ( ap@@ b - as@@ b ) / 2.0 ) * 100.0 ) / 100.0 ) ; System . out . print ( " B ▁ = ▁ " + Math . round ( ( ( ap@@ b + as@@ b ) / 2.0 ) * 100.0 ) / 100.0 ) ; }
PRODUCT_@@ MAXIMUM_@@ FIRST_@@ ARRAY_@@ MIN@@ IM@@ UM@@ _SECON@@ D_@@ 1 | public static int min@@ Max@@ Product ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int n1 , int n2 ) { int max = ar@@ r1 [ 0 ] ; int min = ar@@ r2 [ 0 ] ; int i ; for ( i = 1 ; i < n1 && i < n2 ; ++ i ) { if ( ar@@ r1 [ i ] > max ) max = ar@@ r1 [ i ] ; if ( ar@@ r2 [ i ] < min ) min = ar@@ r2 [ i ] ; } while ( i < n1 ) { if ( ar@@ r1 [ i ] > max ) max = ar@@ r1 [ i ] ; i ++ ; } while ( i < n2 ) { if ( ar@@ r2 [ i ] < min ) min = ar@@ r2 [ i ] ; i ++ ; } return max * min ; }
PROGRAM_@@ CAL@@ CUL@@ ATE_@@ VOLUME_@@ OC@@ TA@@ HE@@ DRO@@ N | static double vol_@@ of_@@ oc@@ ta@@ hedron ( double side ) { return ( ( side * side * side ) * ( Math . sqrt ( 2 ) / 3 ) ) ; }
SORT_@@ STRING_@@ CHARAC@@ TER@@ S_@@ 1 | public static String sort@@ String ( String input@@ String ) { char temp@@ Array [ ] = input@@ String . toCharArray ( ) ; Arrays . sort ( temp@@ Array ) ; return new String ( temp@@ Array ) ; }
MOVE_@@ SPAC@@ ES_@@ FRONT_@@ STRING@@ _SIN@@ GLE_@@ TRA@@ VERS@@ AL | static void move@@ Space@@ In@@ Front ( char str [ ] ) { int i = str . length - 1 ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ▁ ' ) str [ i -- ] = str [ j ] ; while ( i >= 0 ) str [ i -- ] = ' ▁ ' ; }
MINIMUM_@@ INCRE@@ MENT_@@ K_@@ OPER@@ ATION@@ S_@@ MAKE_@@ ELEMEN@@ TS_@@ EQUAL | static int min@@ Ops ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int max = arr [ arr . length - 1 ] ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }
PROGRAM_@@ FOR_@@ FAC@@ TOR@@ I@@ AL_@@ OF_@@ A_@@ NUMBER_@@ 1 | static int factorial ( int n ) { int res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
MINIMUM_@@ TIME_@@ TO_@@ FINI@@ SH_@@ TASK@@ S_@@ WITH@@ OUT_@@ SKIP@@ P@@ ING_@@ TWO_@@ CON@@ SEC@@ UTI@@ VE | static int min@@ Time ( int arr [ ] , int n ) { if ( n <= 0 ) return 0 ; int in@@ cl = arr [ 0 ] ; int ex@@ cl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int in@@ cl_@@ new = arr [ i ] + Math . min ( ex@@ cl , in@@ cl ) ; int ex@@ cl_@@ new = in@@ cl ; in@@ cl = in@@ cl_@@ new ; ex@@ cl = ex@@ cl_@@ new ; } return Math . min ( in@@ cl , ex@@ cl ) ; }
CHECK_@@ IF_@@ TWO_@@ ARRAY@@ S_@@ ARE_@@ EQUAL_@@ OR_@@ NOT | public static boolean are@@ Equal ( int ar@@ r1 [ ] , int ar@@ r2 [ ] ) { int n = ar@@ r1 . length ; int m = ar@@ r2 . length ; if ( n != m ) return false ; Arrays . sort ( ar@@ r1 ) ; Arrays . sort ( ar@@ r2 ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ar@@ r1 [ i ] != ar@@ r2 [ i ] ) return false ; return true ; }
MINIMUM_@@ DIFF@@ ER@@ ENCE_@@ MAX_@@ MIN_@@ K@@ _SIZE_@@ SUB@@ SETS | static int min@@ Difference@@ A@@ mon@@ g@@ Max@@ Min ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int res = 2147483647 ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { int cur@@ Seq@@ Diff = arr [ i + K - 1 ] - arr [ i ] ; res = Math . min ( res , cur@@ Seq@@ Diff ) ; } return res ; }
SW@@ AP_@@ BITS_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ NUMBER | static int swap@@ Bits ( int x , int p1 , int p2 , int n ) { int set1 = ( x > > p1 ) & ( ( 1 << n ) - 1 ) ; int set2 = ( x > > p2 ) & ( ( 1 << n ) - 1 ) ; int xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; int result = x ^ xor ; return result ; }
COUNT_@@ NUMBER_OF_@@ WAY@@ S_TO_@@ FILL_@@ A_@@ N_@@ X_@@ 4_@@ GRID_@@ USING_@@ 1_@@ X_@@ 4_@@ TI@@ LES | static int count ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } } return dp [ n ] ; }
MAXIMUM_@@ CON@@ SEC@@ UTI@@ VE_@@ REPE@@ ATING_@@ CHARACTER_@@ STRING_@@ 1 | static char max@@ Repe@@ ating ( String str ) { int n = str . length ( ) ; int count = 0 ; char res = str . charAt ( 0 ) ; int cur_@@ count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str . charAt ( i ) == str . charAt ( i + 1 ) ) cur_@@ count ++ ; else { if ( cur_@@ count > count ) { count = cur_@@ count ; res = str . charAt ( i ) ; } cur_@@ count = 1 ; } } return res ; }
PAS@@ CAL_@@ TRI@@ ANGLE | public static void print@@ Pas@@ cal ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i || i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; System . out . print ( arr [ line ] [ i ] ) ; } System . out . println ( " " ) ; } }
TURN_@@ OFF_@@ THE_@@ RIGHT@@ MO@@ ST@@ _SET_@@ BIT | static int fun ( int n ) { return n & ( n - 1 ) ; }
RE@@ AR@@ RANGE_@@ ARRAY_@@ MAXIMUM_@@ MINIMUM_@@ FORM@@ _SET_@@ 2_@@ O@@ 1_@@ EX@@ TRA@@ _SPACE | public static void re@@ arrange ( int arr [ ] , int n ) { int max_@@ idx = n - 1 , min_@@ idx = 0 ; int max_@@ elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_@@ idx ] % max_@@ elem ) * max_@@ elem ; max_@@ idx -- ; } else { arr [ i ] += ( arr [ min_@@ idx ] % max_@@ elem ) * max_@@ elem ; min_@@ idx ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] / max_@@ elem ; }
COUNT_@@ ZER@@ OS_@@ IN_@@ A_@@ ROW_@@ WI@@ SE_@@ AND_@@ COLUMN_@@ WI@@ SE_@@ SOR@@ TED_@@ MATRIX | static int count@@ Zero@@ es ( int mat [ ] [ ] ) { int row = N - 1 , col = 0 ; int count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] > 0 ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; }
MINIMUM_@@ CO@@ ST_@@ FOR_@@ AC@@ QUIR@@ ING_@@ ALL_@@ CO@@ INS_@@ WITH_@@ K_@@ EXTRA_@@ CO@@ INS_@@ ALLOWED_@@ WITH_@@ EVER@@ Y_@@ COIN | static int min@@ Cost ( int coin [ ] , int n , int k ) { Arrays . sort ( coin ) ; int coin@@ s_@@ needed = ( int ) Math . ceil ( 1.0 * n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i <= coin@@ s_@@ needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }
COUNT_@@ SUB@@ ARRAY@@ S_@@ TOTAL_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ ORIGIN@@ AL_@@ ARRAY | static int count@@ Di@@ stic@@ t@@ Sub@@ array ( int arr [ ] , int n ) { HashMap < Integer , Integer > vis = new HashMap < Integer , Integer > ( ) { @ Override public Integer get ( Object key ) { if ( ! containsKey ( key ) ) return 0 ; return super . get ( key ) ; } } ; for ( int i = 0 ; i < n ; ++ i ) vis . put ( arr [ i ] , 1 ) ; int k = vis . size ( ) ; vis . clear ( ) ; int ans = 0 , right = 0 , window = 0 ; for ( int left = 0 ; left < n ; ++ left ) { while ( right < n && window < k ) { vis . put ( arr [ right ] , vis . get ( arr [ right ] ) + 1 ) ; if ( vis . get ( arr [ right ] ) == 1 ) ++ window ; ++ right ; } if ( window == k ) ans += ( n - right + 1 ) ; vis . put ( arr [ left ] , vis . get ( arr [ left ] ) - 1 ) ; if ( vis . get ( arr [ left ] ) == 0 ) -- window ; } return ans ; }
FIND_@@ POSSI@@ BLE_@@ ROTA@@ TE_@@ PAGE_@@ ANGLE_@@ NOT | static void possible@@ Or@@ Not ( long a1 , long a2 , long b1 , long b2 , long c1 , long c2 ) { long dis@@ 1 = ( long ) Math . pow ( b1 - a1 , 2 ) + ( long ) Math . pow ( b2 - a2 , 2 ) ; long dis@@ 2 = ( long ) Math . pow ( c1 - b1 , 2 ) + ( long ) Math . pow ( c2 - b2 , 2 ) ; if ( dis@@ 1 != dis@@ 2 ) System . out . print ( " No " ) ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) System . out . print ( " No " ) ; else System . out . print ( " Yes " ) ; }
TIME_@@ ME@@ ET_@@ ANIM@@ ALS | static void timeTo@@ Me@@ et ( double s , double v ) { double V = 3 * v / 2 ; double time = s / V ; System . out . println ( ( float ) time ) ; }
B@@ RES@@ EN@@ HAM@@ S_@@ LINE_@@ GENERA@@ TION_@@ ALGORITH@@ M | static void b@@ res@@ enh@@ am ( int x1 , int y1 , int x2 , int y2 ) { int m_@@ new = 2 * ( y2 - y1 ) ; int slo@@ pe_@@ error_@@ new = m_@@ new - ( x2 - x1 ) ; for ( int x = x1 , y = y1 ; x <= x2 ; x ++ ) { System . out . print ( " ( " + x + " , " + y + " ) \n " ) ; slo@@ pe_@@ error_@@ new += m_@@ new ; if ( slo@@ pe_@@ error_@@ new >= 0 ) { y ++ ; slo@@ pe_@@ error_@@ new -= 2 * ( x2 - x1 ) ; } } }
MAXIMUM_@@ NUMBER_@@ CHO@@ CO@@ LA@@ TES_@@ DISTRIBU@@ TED_@@ EQUAL@@ LY_@@ AM@@ ONG_@@ K_@@ STUD@@ ENTS | static int maxNum@@ Of@@ Cho@@ col@@ ates ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int [ ] sum = new int [ n ] ; int curr_@@ rem ; int max@@ Sum = 0 ; sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { curr_@@ rem = sum [ i ] % k ; if ( curr_@@ rem == 0 ) { if ( max@@ Sum < sum [ i ] ) max@@ Sum = sum [ i ] ; } else if ( ! um . containsKey ( curr_@@ rem ) ) um . put ( curr_@@ rem , i ) ; else if ( max@@ Sum < ( sum [ i ] - sum [ um . get ( curr_@@ rem ) ] ) ) max@@ Sum = sum [ i ] - sum [ um . get ( curr_@@ rem ) ] ; } return ( max@@ Sum / k ) ; }
CHECK_@@ TWO_@@ STRING@@ S_@@ K_@@ AN@@ AG@@ RAM@@ S_@@ NOT_@@ 1 | static boolean are@@ K@@ An@@ agram@@ s ( String str1 , String str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int [ ] hash_@@ str1 = new int [ MAX_@@ CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) hash_@@ str1 [ str1 . charAt ( i ) - ' a ' ] ++ ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash_@@ str1 [ str2 . charAt ( i ) - ' a ' ] > 0 ) hash_@@ str1 [ str2 . charAt ( i ) - ' a ' ] -- ; else count ++ ; if ( count > k ) return false ; } return true ; }
DI@@ VISIBILITY_@@ CHECK | static void di@@ visibility@@ Check ( List < Integer > arr , int n ) { List < Integer > s = new ArrayList < Integer > ( ) ; int max_@@ ele = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr . get ( i ) ) ; max_@@ ele = Math . max ( max_@@ ele , arr . get ( i ) ) ; } LinkedHashSet < Integer > res = new LinkedHashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr . get ( i ) != 0 ) for ( int j = arr . get ( i ) * 2 ; j <= max_@@ ele ; j += arr . get ( i ) ) { if ( s . contains ( j ) ) res . add ( j ) ; } } List < Integer > list = new ArrayList < Integer > ( res ) ; Collections . reverse ( list ) ; for ( Integer temp : list ) System . out . print ( temp + " ▁ " ) ; }
MAXIMUM_@@ LENGTH_@@ PREFIX_@@ ONE_@@ STRING_@@ OC@@ CURS@@ _SUB@@ SEQU@@ ENCE_@@ AN@@ OTHER | static int max@@ Prefix ( String s , String t ) { int count = 0 ; for ( int i = 0 ; i < t . length ( ) ; i ++ ) { if ( count == t . length ( ) ) break ; if ( t . charAt ( i ) == s . charAt ( count ) ) count ++ ; } return count ; }
COUNT_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ IN_@@ EVER@@ Y_@@ WINDOW_@@ OF@@ _SIZE_@@ K | static void count@@ Distin@@ ct ( int arr [ ] , int k ) { HashMap < Integer , Integer > h@@ M = new HashMap < Integer , Integer > ( ) ; int dist@@ _count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( h@@ M . get ( arr [ i ] ) == null ) { h@@ M . put ( arr [ i ] , 1 ) ; dist@@ _count ++ ; } else { int count = h@@ M . get ( arr [ i ] ) ; h@@ M . put ( arr [ i ] , count + 1 ) ; } } System . out . println ( dist@@ _count ) ; for ( int i = k ; i < arr . length ; i ++ ) { if ( h@@ M . get ( arr [ i - k ] ) == 1 ) { h@@ M . remove ( arr [ i - k ] ) ; dist@@ _count -- ; } else { int count = h@@ M . get ( arr [ i - k ] ) ; h@@ M . put ( arr [ i - k ] , count - 1 ) ; } if ( h@@ M . get ( arr [ i ] ) == null ) { h@@ M . put ( arr [ i ] , 1 ) ; dist@@ _count ++ ; } else { int count = h@@ M . get ( arr [ i ] ) ; h@@ M . put ( arr [ i ] , count + 1 ) ; } System . out . println ( dist@@ _count ) ; } }
LC@@ S_@@ FOR@@ MED_@@ CON@@ SEC@@ UTI@@ VE_@@ SEG@@ MEN@@ TS_@@ LEA@@ ST_@@ LENGTH_@@ K | static int lon@@ gest@@ Sub@@ sequence@@ Common@@ Segment ( int k , String s1 , String s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; int l@@ cs [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; int cnt [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { l@@ cs [ i ] [ j ] = Math . max ( l@@ cs [ i - 1 ] [ j ] , l@@ cs [ i ] [ j - 1 ] ) ; if ( s1 . charAt ( i - 1 ) == s2 . charAt ( j - 1 ) ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; if ( cnt [ i ] [ j ] >= k ) { for ( int a = k ; a <= cnt [ i ] [ j ] ; a ++ ) l@@ cs [ i ] [ j ] = Math . max ( l@@ cs [ i ] [ j ] , l@@ cs [ i - a ] [ j - a ] + a ) ; } } } return l@@ cs [ n ] [ m ] ; }
PRINT_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ GI@@ V@@ EN_@@ INTEGER_@@ ARRAY_@@ 1 | static void print@@ Distin@@ ct ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++ ; System . out . print ( arr [ i ] + " ▁ " ) ; } }
PRI@@ MALI@@ TY_@@ TEST@@ _SET_@@ 5@@ USING_@@ L@@ UC@@ AS_@@ LE@@ H@@ MER@@ _SERI@@ ES | static boolean is@@ Prime ( int p ) { double check@@ Number = Math . pow ( 2 , p ) - 1 ; double next@@ val = 4 % check@@ Number ; for ( int i = 1 ; i < p - 1 ; i ++ ) next@@ val = ( next@@ val * next@@ val - 2 ) % check@@ Number ; return ( next@@ val == 0 ) ; }
K@@ TH_@@ NON_@@ REPE@@ ATING_@@ CHARACTER | static int k@@ th@@ Non@@ Repe@@ ating ( String str , int k ) { int n = str . length ( ) ; int [ ] count = new int [ MAX_@@ CHAR ] ; int [ ] index = new int [ MAX_@@ CHAR ] ; for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) { count [ i ] = 0 ; index [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { char x = str . charAt ( i ) ; ++ count [ x ] ; if ( count [ x ] == 1 ) index [ x ] = i ; if ( count [ x ] == 2 ) index [ x ] = n ; } Arrays . sort ( index ) ; return ( index [ k - 1 ] != n ) ? index [ k - 1 ] : - 1 ; }
FIRST_@@ UP@@ PER@@ CASE_@@ LET@@ TER_@@ IN_@@ A_@@ STRING_@@ ITER@@ ATI@@ VE_@@ AND_@@ RECUR@@ SIVE | static char first ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( Character . is@@ UpperCase ( str . charAt ( i ) ) ) return str . charAt ( i ) ; return 0 ; }
GI@@ V@@ EN_@@ TWO_@@ STRING@@ S_@@ FIND_@@ FIRST_@@ STRING@@ _SUB@@ SEQU@@ ENCE_@@ SECOND | static boolean isSub@@ Sequence ( String str1 , String str2 , int m , int n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 . charAt ( m - 1 ) == str2 . charAt ( n - 1 ) ) return isSub@@ Sequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSub@@ Sequence ( str1 , str2 , m , n - 1 ) ; }
C_@@ PROGRAM_@@ FIND_@@ LAR@@ GE@@ ST_@@ ELEMENT_@@ ARRAY_@@ 1 | static int largest ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; return arr [ n - 1 ] ; }
DIFF@@ ER@@ ENCE_@@ BETWE@@ EN_@@ HIGH@@ EST_@@ AND_@@ LEA@@ ST_@@ FREQU@@ ENCI@@ ES_@@ IN_@@ AN_@@ ARRAY | static int find@@ Diff ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 0 , max_@@ count = 0 , min_@@ count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_@@ count = Math . max ( max_@@ count , count ) ; min_@@ count = Math . min ( min_@@ count , count ) ; count = 0 ; } } return ( max_@@ count - min_@@ count ) ; }
PROGRAM_@@ FOR_@@ FAC@@ TOR@@ I@@ AL_@@ OF_@@ A_@@ NUMBER | static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
