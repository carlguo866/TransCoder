PRINT_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ GI@@ V@@ EN_@@ INTEGER_@@ ARRAY_@@ 2 | void print@@ Distin@@ ct ( int arr [ ] , int n ) { unordered_@@ set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( arr [ i ] ) == s . end ( ) ) { s . insert ( arr [ i ] ) ; cout << arr [ i ] << " ▁ " ; } } }
CHECK_@@ RO@@ WS_@@ MATRIX_@@ CIRC@@ ULAR_@@ ROTA@@ TIONS | bool is@@ Per@@ mu@@ ted@@ Matrix ( int mat [ MAX ] [ MAX ] , int n ) { string str_@@ cat = " " ; for ( int i = 0 ; i < n ; i ++ ) str_@@ cat = str_@@ cat + " - " + to_string ( mat [ 0 ] [ i ] ) ; str_@@ cat = str_@@ cat + str_@@ cat ; for ( int i = 1 ; i < n ; i ++ ) { string curr_@@ str = " " ; for ( int j = 0 ; j < n ; j ++ ) curr_@@ str = curr_@@ str + " - " + to_string ( mat [ i ] [ j ] ) ; if ( str_@@ cat . find ( curr_@@ str ) == string :: npos ) return false ; } return true ; }
S@@ UM_@@ PAIR@@ WI@@ SE_@@ PRODUC@@ TS | long long int find@@ Sum ( int n ) { long long int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; }
SORT_@@ 3_@@ INTEG@@ ERS_@@ WITH@@ OUT_@@ USING_@@ CONDITION_@@ USING_@@ MAX_@@ FUNCTION | void print@@ Sorted ( int a , int b , int c ) { int get_@@ max = max ( a , max ( b , c ) ) ; int get_@@ min = - max ( - a , max ( - b , - c ) ) ; int get_@@ mid = ( a + b + c ) - ( get_@@ max + get_@@ min ) ; cout << get_@@ min << " ▁ " << get_@@ mid << " ▁ " << get_@@ max ; }
PROGRAM_@@ FOR_@@ FAC@@ TOR@@ I@@ AL_@@ OF_@@ A_@@ NUMBER_@@ 2 | int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
FIND_@@ INDEX_@@ OF_@@ AN_@@ EXTRA_@@ ELEMENT_@@ PRES@@ ENT_@@ IN_@@ ONE@@ _S@@ OR@@ TED_@@ ARRAY_@@ 2 | int find_@@ extra_@@ element@@ _index ( int arr@@ A [ ] , int arr@@ B [ ] , int n , int m ) { int extra_@@ element = sum ( arr@@ A , n ) - sum ( arr@@ B , m ) ; return indexOf ( arr@@ A , extra_@@ element , n ) ; }
SUB@@ ARRAY@@ SUB@@ STRING_@@ VS@@ _SUB@@ SEQU@@ ENCE_@@ AND_@@ PROGR@@ AM@@ S_TO_@@ GENERATE_@@ THE@@ M_@@ 1 | void print@@ Sub@@ sequences ( int arr [ ] , int n ) { unsigned int op@@ size = pow ( 2 , n ) ; for ( int counter = 1 ; counter < op@@ size ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( counter & ( 1 << j ) ) cout << arr [ j ] << " ▁ " ; } cout << endl ; } }
N_@@ BON@@ ACC@@ I_@@ NUMB@@ ERS | void bon@@ ac@@ ci@@ series ( long n , int m ) { int a [ m ] = { 0 } ; a [ n - 1 ] = 1 ; for ( int i = n ; i < m ; i ++ ) for ( int j = i - n ; j < i ; j ++ ) a [ i ] += a [ j ] ; for ( int i = 0 ; i < m ; i ++ ) cout << a [ i ] << " ▁ ▁ " ; }
LOWER_@@ CASE_@@ UPPER_@@ CASE_@@ INTER@@ EST@@ ING_@@ FAC@@ T | string to_@@ upper ( string & in ) { for ( int i = 0 ; i < in . length ( ) ; i ++ ) if ( ' a ' <= in [ i ] <= ' z ' ) in [ i ] = in [ i ] - ' a ' + ' A ' ; return in ; }
PRINT_@@ BRAC@@ KET_@@ NUMBER | void print@@ Bracket@@ Number ( string exp , int n ) { int left_@@ b@@ num = 1 ; stack < int > right_@@ b@@ num ; for ( int i = 0 ; i < n ; i ++ ) { if ( exp [ i ] == ' ( ' ) { cout << left_@@ b@@ num << " ▁ " ; right_@@ b@@ num . push ( left_@@ b@@ num ) ; left_@@ b@@ num ++ ; } else if ( exp [ i ] == ' ) ' ) { cout << right_@@ b@@ num . top ( ) << " ▁ " ; right_@@ b@@ num . pop ( ) ; } } }
MAXIMUM_@@ PRODUCT_@@ OF_@@ 4_@@ AD@@ J@@ AC@@ ENT_@@ ELEMEN@@ TS_@@ IN_@@ MATRIX | int Find@@ Max@@ Product ( int arr [ ] [ n ] , int n ) { int max = 0 , result ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ; if ( max < result ) max = result ; } } } return max ; }
LON@@ GE@@ ST@@ _SUB@@ ARRA@@ Y_S@@ UM_@@ DI@@ VISI@@ BLE_@@ K | int long@@ Sub@@ arr@@ W@@ th@@ Sum@@ Div@@ By@@ K ( int arr [ ] , int n , int k ) { unordered_map < int , int > um ; int mod_@@ arr [ n ] , max = 0 ; int curr_@@ sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_@@ sum += arr [ i ] ; mod_@@ arr [ i ] = ( ( curr_@@ sum % k ) + k ) % k ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mod_@@ arr [ i ] == 0 ) max = i + 1 ; else if ( um . find ( mod_@@ arr [ i ] ) == um . end ( ) ) um [ mod_@@ arr [ i ] ] = i ; else if ( max < ( i - um [ mod_@@ arr [ i ] ] ) ) max = i - um [ mod_@@ arr [ i ] ] ; } return max ; }
CA@@ ES@@ AR_@@ CIPH@@ ER | string encrypt ( string text , int s ) { string result = " " ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { if ( is@@ upper ( text [ i ] ) ) result += char ( int ( text [ i ] + s - 65 ) % 26 + 65 ) ; else result += char ( int ( text [ i ] + s - 97 ) % 26 + 97 ) ; } return result ; }
SUB@@ ARRAY@@ S_@@ DISTIN@@ CT_@@ ELEMENTS | int su@@ mo@@ f@@ length ( int arr [ ] , int n ) { unordered_@@ set < int > s ; int j = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && s . find ( arr [ j ] ) == s . end ( ) ) { s . insert ( arr [ j ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . erase ( arr [ i ] ) ; } return ans ; }
K_@@ TH_@@ ELEMENT_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S | int k@@ th ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int m , int n , int k ) { int sorted@@ 1 [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( ar@@ r1 [ i ] < ar@@ r2 [ j ] ) sorted@@ 1 [ d ++ ] = ar@@ r1 [ i ++ ] ; else sorted@@ 1 [ d ++ ] = ar@@ r2 [ j ++ ] ; } while ( i < m ) sorted@@ 1 [ d ++ ] = ar@@ r1 [ i ++ ] ; while ( j < n ) sorted@@ 1 [ d ++ ] = ar@@ r2 [ j ++ ] ; return sorted@@ 1 [ k - 1 ] ; }
REMOVE_@@ CON@@ SEC@@ UTI@@ VE_@@ DUPLIC@@ ATE@@ S_@@ STRING | void remove@@ Duplicates ( char S [ ] ) { int n = strlen ( S ) ; if ( n < 2 ) return ; int j = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( S [ j ] != S [ i ] ) { j ++ ; S [ j ] = S [ i ] ; } } j ++ ; S [ j ] = ' \0' ; }
MAJ@@ ORI@@ TY_@@ ELEMENT | void find@@ Maj@@ ority ( int arr [ ] , int n ) { int maxCount = 0 ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) cout << arr [ index ] << endl ; else cout << " No ▁ Maj@@ ority ▁ Element " << endl ; }
FUNCTION_@@ COPY_@@ STRING_@@ ITER@@ ATI@@ VE_@@ RECUR@@ SIVE_@@ 1 | void my@@ Copy ( char s1 [ ] , char s2 [ ] , int index = 0 ) { s2 [ index ] = s1 [ index ] ; if ( s1 [ index ] == ' \0' ) return ; my@@ Copy ( s1 , s2 , index + 1 ) ; }
COUNT_@@ NUMBER_OF_@@ WAY@@ S_TO_@@ CO@@ VER_@@ A_@@ DISTAN@@ CE_@@ 1 | int print@@ Count@@ DP ( int dist ) { int count [ dist + 1 ] ; count [ 0 ] = 1 , count [ 1 ] = 1 , count [ 2 ] = 2 ; for ( int i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }
DISC@@ RE@@ TE_@@ LOG@@ ARI@@ TH@@ M_@@ FIND_@@ INTEGER_@@ K_@@ A@@ K_@@ CON@@ GR@@ U@@ ENT_@@ MODUL@@ O_@@ B | int discre@@ te@@ Log@@ arith@@ m ( int a , int b , int m ) { int n = ( int ) sqrt ( m ) + 1 ; int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * a ) % m ; unordered_map < int , int > value ; for ( int i = 1 , cur = an ; i <= n ; ++ i ) { if ( ! value [ cur ] ) value [ cur ] = i ; cur = ( cur * an ) % m ; } for ( int i = 0 , cur = b ; i <= n ; ++ i ) { if ( value [ cur ] ) { int ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return - 1 ; }
CHANGE_@@ BITS_@@ CAN_@@ MA@@ DE_@@ ONE_@@ FLI@@ P_@@ 1 | bool is@@ One@@ Flip ( string str ) { int sum = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) sum += str [ i ] - '0' ; return ( sum == n - 1 || sum == 1 ) ; }
FIND_@@ PAIR@@ S_IN_@@ ARRAY_@@ WHO@@ SE_@@ SUM@@ S_@@ ALREADY_@@ EXI@@ ST_@@ IN_@@ ARRAY | void find@@ Pair ( int arr [ ] , int n ) { bool found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { cout << arr [ i ] << " ▁ " << arr [ j ] << endl ; found = true ; } } } } if ( found == false ) cout << " Not ▁ exist " << endl ; }
MODUL@@ AR_@@ MULTIP@@ LIC@@ ATI@@ VE_@@ INVER@@ SE_@@ 1_@@ N | void mod@@ ular@@ Inverse ( int n , int prime ) { int dp [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ prime % i ] * ( prime - prime / i ) % prime ; for ( int i = 1 ; i <= n ; i ++ ) cout << dp [ i ] << ' ▁ ' ; }
SHUFF@@ LE_@@ 2@@ N_@@ INTEG@@ ERS_@@ FORMAT_@@ A@@ 1_@@ B@@ 1_@@ A@@ 2_@@ B@@ 2_@@ A@@ 3_@@ B@@ 3_@@ BN_@@ WITH@@ OUT_@@ USING_@@ EX@@ TRA@@ _SPACE_@@ 1 | void shu@@ fle@@ Array ( int a [ ] , int f , int l ) { if ( l > f ) { return ; } if ( l - f == 1 ) return ; int mid = ( f + l ) / 2 ; int temp = mid + 1 ; int mm@@ id = ( f + mid ) / 2 ; for ( int i = mm@@ id + 1 ; i <= mid ; i ++ ) swap ( a [ i ] , a [ temp ++ ] ) ; shu@@ fle@@ Array ( a , f , mid ) ; shu@@ fle@@ Array ( a , mid + 1 , l ) ; }
N_@@ TH_@@ ROOT_@@ NUMBER | double n@@ th@@ Root ( int A , int N ) { double x@@ Pre = rand ( ) % 10 ; double eps = 1e - 3 ; double del@@ X = INT_MAX ; double x@@ K ; while ( del@@ X > eps ) { x@@ K = ( ( N - 1.0 ) * x@@ Pre + ( double ) A / pow ( x@@ Pre , N - 1 ) ) / ( double ) N ; del@@ X = abs ( x@@ K - x@@ Pre ) ; x@@ Pre = x@@ K ; } return x@@ K ; }
NUMBER_OF_@@ WAY@@ S_TO_@@ AR@@ RANGE_@@ N_@@ ITE@@ MS_@@ UN@@ DER_@@ GI@@ V@@ EN_@@ CONSTRA@@ INTS | int way@@ sTo@@ Ar@@ range ( int N , int K , int k [ ] ) { int C [ N + 1 ] [ N + 1 ] ; int i , j ; for ( i = 0 ; i <= N ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } int dp [ K ] ; int count = 0 ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < K ; i ++ ) { dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) ; count += k [ i ] ; } return dp [ K ] ; }
TEMP@@ LE_@@ OFF@@ ER@@ INGS | int offer@@ ing@@ Number ( int n , int temp@@ le@@ Height [ ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int left = 0 , right = 0 ; for ( int j = i - 1 ; j >= 0 ; -- j ) { if ( temp@@ le@@ Height [ j ] < temp@@ le@@ Height [ j + 1 ] ) ++ left ; else break ; } for ( int j = i + 1 ; j < n ; ++ j ) { if ( temp@@ le@@ Height [ j ] < temp@@ le@@ Height [ j - 1 ] ) ++ right ; else break ; } sum += max ( right , left ) + 1 ; } return sum ; }
CENTER_@@ ELEMENT_@@ OF_@@ MATRIX_@@ EQUAL@@ S_S@@ UM@@ S_@@ OF_@@ HALF_@@ DIAG@@ ON@@ ALS | bool Half@@ Diag@@ onal@@ Sum@@ s ( int mat [ ] [ MAX ] , int n ) { int diag@@ 1_@@ left = 0 , diag@@ 1_@@ right = 0 ; int diag@@ 2_@@ left = 0 , diag@@ 2_@@ right = 0 ; for ( int i = 0 , j = n - 1 ; i < n ; i ++ , j -- ) { if ( i < n / 2 ) { diag@@ 1_@@ left += mat [ i ] [ i ] ; diag@@ 2_@@ left += mat [ j ] [ i ] ; } else if ( i > n / 2 ) { diag@@ 1_@@ right += mat [ i ] [ i ] ; diag@@ 2_@@ right += mat [ j ] [ i ] ; } } return ( diag@@ 1_@@ left == diag@@ 2_@@ right && diag@@ 2_@@ right == diag@@ 2_@@ left && diag@@ 1_@@ right == diag@@ 2_@@ left && diag@@ 2_@@ right == mat [ n / 2 ] [ n / 2 ] ) ; }
COUNT_@@ FAC@@ TOR@@ I@@ AL_@@ NUMB@@ ERS_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ RANGE | int count@@ Fact ( int low , int high ) { int fact = 1 , x = 1 ; while ( fact < low ) { fact = fact * x ; x ++ ; } int res = 0 ; while ( fact <= high ) { res ++ ; fact = fact * x ; x ++ ; } return res ; }
PROGRAM_@@ REVERSE_@@ STRING_@@ ITER@@ ATI@@ VE_@@ RECUR@@ SIVE_@@ 1 | void reverse@@ Str ( string & str ) { int n = str . length ( ) ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) swap ( str [ i ] , str [ j ] ) ; }
FIND_@@ MINIMUM_@@ AD@@ JU@@ ST@@ MENT_@@ CO@@ ST_@@ OF_@@ AN_@@ ARRAY | int min@@ Adjustment@@ Cost ( int A [ ] , int n , int target ) { int dp [ n ] [ M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = INT_MAX ; for ( int k = max ( j - target , 0 ) ; k <= min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) ; } } int res = INT_MAX ; for ( int j = 0 ; j <= M ; j ++ ) res = min ( res , dp [ n - 1 ] [ j ] ) ; return res ; }
COUNT_@@ FREQU@@ ENCY_@@ K_@@ MATRI@@ X@@ _SIZE_@@ N_@@ MATRI@@ X@@ I_@@ J_@@ I@@ J | int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
MINIMUM_@@ FLI@@ P_@@ REQUIRED_@@ MAKE_@@ BINARY_@@ MATRIX_@@ SYM@@ METRIC_@@ 1 | int minimum@@ flip ( int mat [ ] [ N ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }
N@@ TH_@@ PA@@ LIN@@ DRO@@ ME_@@ K_@@ DIGITS | void n@@ th@@ Pal@@ ind@@ ro@@ me ( int n , int k ) { int temp = ( k & 1 ) ? ( k / 2 ) : ( k / 2 - 1 ) ; int pal@@ ind@@ ro@@ me = ( int ) pow ( 10 , temp ) ; pal@@ ind@@ ro@@ me += n - 1 ; printf ( " % d " , pal@@ ind@@ ro@@ me ) ; if ( k & 1 ) pal@@ ind@@ ro@@ me /= 10 ; while ( pal@@ ind@@ ro@@ me ) { printf ( " % d " , pal@@ ind@@ ro@@ me % 10 ) ; pal@@ ind@@ ro@@ me /= 10 ; } printf ( " \n " ) ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 3_@@ LON@@ GE@@ ST_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQU@@ ENCE_@@ 1 | int lis ( int arr [ ] , int n ) { int lis [ n ] ; lis [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { lis [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } return * max_@@ element ( lis , lis + n ) ; }
PATH_@@ MAXIMUM_@@ AVER@@ AGE_@@ VALUE | double max@@ Average@@ Of@@ Path ( int cost [ M ] [ M ] , int N ) { int dp [ N + 1 ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
PROGRAM_@@ COUNT_@@ OC@@ CURR@@ ENCE_@@ GI@@ V@@ EN_@@ CHARACTER_@@ STRING | int count ( string s , char c ) { int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s [ i ] == c ) res ++ ; return res ; }
K@@ TH@@ _S@@ MAL@@ LE@@ ST@@ LAR@@ GE@@ ST_@@ ELEMENT_@@ UN@@ SOR@@ TED_@@ ARRAY | int k@@ th@@ S@@ malle@@ st ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; return arr [ k - 1 ] ; }
CONVERT_@@ ALTER@@ N@@ ATE_@@ CHARAC@@ TER@@ S_@@ STRING_@@ UPPER_@@ CASE | void convert@@ Op@@ posi@@ te ( string & str ) { int ln = str . length ( ) ; for ( int i = 0 ; i < ln ; i ++ ) { if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) str [ i ] = str [ i ] - 32 ; else if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) str [ i ] = str [ i ] + 32 ; } }
SUM@@ _SERI@@ ES_@@ 5555@@ 55@@ _@@ N_@@ TER@@ MS | int sum@@ Of@@ Series ( int n ) { return 0.6@@ 172 * ( pow ( 10 , n ) - 1 ) - 0.5@@ 5 * n ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 8_@@ MATRIX_@@ CHAIN_@@ MULTIP@@ LIC@@ ATION | int Matrix@@ Chain@@ Order ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int k ; int min = INT_MAX ; int count ; for ( k = i ; k < j ; k ++ ) { count = Matrix@@ Chain@@ Order ( p , i , k ) + Matrix@@ Chain@@ Order ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }
COUNT_@@ SET_@@ BITS_@@ IN_@@ AN_@@ INTEGER_@@ 3 | int count@@ Set@@ Bits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + count@@ Set@@ Bits ( n & ( n - 1 ) ) ; }
MINIMUM_@@ LENGTH_@@ UN@@ SOR@@ TED@@ _SUB@@ ARRA@@ Y_S@@ OR@@ TING_@@ WHI@@ CH_@@ MAKE@@ S_@@ THE_@@ COMPLETE_@@ ARRA@@ Y_S@@ OR@@ TED | void print@@ Un@@ sorted ( int arr [ ] , int n ) { int s = 0 , e = n - 1 , i , max , min ; for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; } if ( s == n - 1 ) { cout << " The ▁ complete ▁ array ▁ is ▁ sorted " ; return ; } for ( e = n - 1 ; e > 0 ; e -- ) { if ( arr [ e ] < arr [ e - 1 ] ) break ; } max = arr [ s ] ; min = arr [ s ] ; for ( i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } for ( i = 0 ; i < s ; i ++ ) { if ( arr [ i ] > min ) { s = i ; break ; } } for ( i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } } cout << " The ▁ un@@ sorted ▁ sub@@ array ▁ which " << " ▁ makes ▁ the ▁ given ▁ array " << endl << " sorted ▁ lies ▁ between ▁ the ▁ inde@@ es ▁ " << s << " ▁ and ▁ " << e ; return ; }
STE@@ INS_@@ ALGORITH@@ M_@@ FOR_@@ FIN@@ DING_@@ GC@@ D | int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; int k ; for ( k = 0 ; ( ( a | b ) && 1 ) == 0 ; ++ k ) { a >>= 1 ; b >>= 1 ; } while ( ( a > 1 ) == 0 ) a >>= 1 ; do { while ( ( b > 1 ) == 0 ) b >>= 1 ; if ( a > b ) swap ( a , b ) ; b = ( b - a ) ; } while ( b != 0 ) ; return a << k ; }
HEX@@ AG@@ ON@@ AL_@@ NUMBER | int hex@@ ag@@ onal@@ Num ( int n ) { return n * ( 2 * n - 1 ) ; }
GOO@@ GLE_@@ CASE_@@ GI@@ VEN@@ _S@@ ENT@@ ENCE | string convert ( string s ) { int n = s . length ( ) ; s [ 0 ] = tolower ( s [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == ' ▁ ' && i < n ) { s [ i + 1 ] = tolower ( s [ i + 1 ] ) ; i ++ ; } else s [ i ] = toupper ( s [ i ] ) ; } return s ; }
FIND_@@ A_@@ ROTATION_@@ WITH_@@ MAXIMUM_@@ HAM@@ M@@ ING_@@ DISTANCE | int max@@ Ham@@ ming ( int arr [ ] , int n ) { int br@@ r [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) br@@ r [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) br@@ r [ n + i ] = arr [ i ] ; int max@@ H@@ am = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int curr@@ H@@ am = 0 ; for ( int j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( br@@ r [ j ] != arr [ k ] ) curr@@ H@@ am ++ ; if ( curr@@ H@@ am == n ) return n ; max@@ H@@ am = max ( max@@ H@@ am , curr@@ H@@ am ) ; } return max@@ H@@ am ; }
GI@@ V@@ EN_@@ A_@@ NUMBER_@@ N_@@ GENERATE_@@ BIT_@@ PATTER@@ NS_@@ FROM_@@ 0_@@ TO_@@ 2@@ N_@@ 1@@ _S@@ O_@@ TH@@ AT_@@ SUCCE@@ SSI@@ VE_@@ PATTER@@ NS_@@ DIFF@@ ER_@@ BY_@@ ONE_@@ BIT | void generate@@ Gray@@ arr ( int n ) { if ( n <= 0 ) return ; vector < string > arr ; arr . push_back ( "0" ) ; arr . push_back ( "1" ) ; int i , j ; for ( i = 2 ; i < ( 1 << n ) ; i = i << 1 ) { for ( j = i - 1 ; j >= 0 ; j -- ) arr . push_back ( arr [ j ] ) ; for ( j = 0 ; j < i ; j ++ ) arr [ j ] = "0" + arr [ j ] ; for ( j = i ; j < 2 * i ; j ++ ) arr [ j ] = "1" + arr [ j ] ; } for ( i = 0 ; i < arr . size ( ) ; i ++ ) cout << arr [ i ] << endl ; }
MIN@@ IM@@ UM@@ _SW@@ AP@@ S_@@ REQUIRED_@@ BR@@ ING_@@ ELEMEN@@ TS_@@ LESS_@@ EQUAL_@@ K_@@ TO@@ GE@@ THER | int min@@ Swap ( int * arr , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] <= k ) ++ count ; int bad = 0 ; for ( int i = 0 ; i < count ; ++ i ) if ( arr [ i ] > k ) ++ bad ; int ans = bad ; for ( int i = 0 , j = count ; j < n ; ++ i , ++ j ) { if ( arr [ i ] > k ) -- bad ; if ( arr [ j ] > k ) ++ bad ; ans = min ( ans , bad ) ; } return ans ; }
FIND_@@ N@@ TH_@@ FI@@ BON@@ ACC@@ I_@@ NUMBER_@@ USING_@@ GO@@ LD@@ EN_@@ RATIO | int fi@@ b ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 , fn = 5 ; while ( t < n ) { fn = round ( fn * PHI ) ; t ++ ; } return fn ; }
SOR@@ TING_@@ ARRAY_@@ REVERSE_@@ AR@@ OUND_@@ MIDDLE | bool if@@ Possible ( int arr [ ] , int n ) { int cp [ n ] ; copy ( arr , arr + n , cp ) ; sort ( cp , cp + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == cp [ i ] ) && ! ( arr [ n - 1 - i ] == cp [ i ] ) ) return false ; } return true ; }
COUNT_@@ ROTA@@ TIONS_@@ DI@@ VISI@@ BLE_@@ 4 | int count@@ Rot@@ ations ( string n ) { int len = n . length ( ) ; if ( len == 1 ) { int one@@ Digit = n . at ( 0 ) - '0' ; if ( one@@ Digit % 4 == 0 ) return 1 ; return 0 ; } int two@@ Digit , count = 0 ; for ( int i = 0 ; i < ( len - 1 ) ; i ++ ) { two@@ Digit = ( n . at ( i ) - '0' ) * 10 + ( n . at ( i + 1 ) - '0' ) ; if ( two@@ Digit % 4 == 0 ) count ++ ; } two@@ Digit = ( n . at ( len - 1 ) - '0' ) * 10 + ( n . at ( 0 ) - '0' ) ; if ( two@@ Digit % 4 == 0 ) count ++ ; return count ; }
N_@@ TH_@@ NUMBER_@@ WHO@@ SE_@@ S@@ UM_@@ OF_@@ DIG@@ IT@@ S_@@ IS_@@ T@@ EN_@@ 2 | int find@@ N@@ th ( int n ) { int n@@ th@@ Element = 19 + ( n - 1 ) * 9 ; int out@@ lier@@ sCount = ( int ) log10 ( n@@ th@@ Element ) - 1 ; n@@ th@@ Element += 9 * out@@ lier@@ sCount ; return n@@ th@@ Element ; }
PRI@@ MALI@@ TY_@@ TEST@@ _SET_@@ 1_@@ INTRO@@ DUC@@ TION_@@ AND@@ _S@@ CHOOL_@@ METHOD_@@ 1 | bool is@@ Prime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
MINIMUM_@@ NUMBER@@ _SUB@@ SE@@ TS_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ 1 | int subset ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; int res = 0 ; for ( auto x : mp ) res = max ( res , x . second ) ; return res ; }
RE@@ CAM@@ AN@@ S@@ _SEQU@@ ENCE_@@ 1 | void rec@@ am@@ an ( int n ) { if ( n <= 0 ) return ; printf ( " % d , ▁ " , 0 ) ; unordered_@@ set < int > s ; s . insert ( 0 ) ; int prev = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int curr = prev - i ; if ( curr < 0 || s . find ( curr ) != s . end ( ) ) curr = prev + i ; s . insert ( curr ) ; printf ( " % d , ▁ " , curr ) ; prev = curr ; } }
GENERATE_@@ ROTA@@ TIONS_@@ GI@@ V@@ EN_@@ STRING_@@ 1 | void print@@ Rot@@ ated@@ String ( char str [ ] ) { int n = strlen ( str ) ; char temp [ 2 * n + 1 ] ; strcpy ( temp , str ) ; strcat ( temp , str ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j != n ; j ++ ) printf ( " % c " , temp [ i + j ] ) ; printf ( " \n " ) ; } }
FIT@@ T@@ ING@@ _SH@@ EL@@ VE@@ S_@@ PRO@@ BLE@@ M | void min@@ Space@@ Pre@@ fer@@ Large ( int wall , int m , int n ) { int num_@@ m = 0 , num_@@ n = 0 , min_@@ empty = wall ; int p = 0 , q = 0 , rem ; while ( wall >= n ) { p = wall / m ; rem = wall % m ; if ( rem <= min_@@ empty ) { num_@@ m = p ; num_@@ n = q ; min_@@ empty = rem ; } q += 1 ; wall = wall - n ; } cout << num_@@ m << " ▁ " << num_@@ n << " ▁ " << min_@@ empty << endl ; }
COUNT_@@ STRING@@ S_@@ CAN_@@ FOR@@ MED_@@ USING_@@ B_@@ C_@@ GI@@ V@@ EN_@@ CONSTRA@@ INT@@ S_@@ 1 | int count@@ Str ( int n ) { return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) ; }
DI@@ VISIBILITY_@@ BY_@@ 12_@@ FOR_@@ A_@@ LARGE_@@ NUMBER | bool is@@ D@@ visible@@ By@@ 12 ( string num ) { if ( num . length ( ) >= 3 ) { int d1 = ( int ) num [ num . length ( ) - 1 ] ; if ( d1 % 2 != 0 ) return ( 0 ) ; int d2 = ( int ) num [ num . length ( ) - 2 ] ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num [ i ] ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = sto@@ i ( num ) ; return ( number % 12 == 0 ) ; } }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 36@@ _@@ CU@@ T_@@ A_@@ RO@@ PE_@@ TO_@@ MAXI@@ MI@@ ZE_@@ PRODUCT_@@ 1 | int max@@ Prod ( int n ) { if ( n == 2 || n == 3 ) return ( n - 1 ) ; int res = 1 ; while ( n > 4 ) { n -= 3 ; res *= 3 ; } return ( n * res ) ; }
RETURN_@@ A_@@ PA@@ IR_@@ WITH_@@ MAXIMUM_@@ PRODUCT_@@ IN_@@ ARRAY_@@ OF_@@ INTEG@@ ERS | void max@@ Product ( int arr [ ] , int n ) { if ( n < 2 ) { cout << " No ▁ pairs ▁ exists \n " ; return ; } int a = arr [ 0 ] , b = arr [ 1 ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] > a * b ) a = arr [ i ] , b = arr [ j ] ; cout << " Max ▁ product ▁ pair ▁ is ▁ { " << a << " , ▁ " << b << " } " ; }
S@@ UM_@@ MATRIX_@@ ELEMENT_@@ ABSOL@@ UTE_@@ DIFF@@ ER@@ ENCE_@@ ROW_@@ COLUMN_@@ NUMB@@ ERS_@@ 2 | int find@@ Sum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
PRINT_@@ MATRIX_@@ ANTI@@ SPIR@@ AL_@@ FORM | void anti@@ Sp@@ ir@@ al@@ Traversal ( int m , int n , int a [ R ] [ C ] ) { int i , k = 0 , l = 0 ; stack < int > stk ; while ( k <= m && l <= n ) { for ( i = l ; i <= n ; ++ i ) stk . push ( a [ k ] [ i ] ) ; k ++ ; for ( i = k ; i <= m ; ++ i ) stk . push ( a [ i ] [ n ] ) ; n -- ; if ( k <= m ) { for ( i = n ; i >= l ; -- i ) stk . push ( a [ m ] [ i ] ) ; m -- ; } if ( l <= n ) { for ( i = m ; i >= k ; -- i ) stk . push ( a [ i ] [ l ] ) ; l ++ ; } } while ( ! stk . empty ( ) ) { cout << stk . top ( ) << " ▁ " ; stk . pop ( ) ; } }
DI@@ CE_@@ THROW_@@ PRO@@ BLE@@ M_@@ 1 | long find@@ W@@ ays ( int f , int d , int s ) { long mem [ d + 1 ] [ s + 1 ] ; memset ( mem , 0 , sizeof mem ) ; mem [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= d ; i ++ ) { for ( int j = i ; j <= s ; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ; if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ; } } return mem [ d ] [ s ] ; }
WRITE_@@ A_@@ C_@@ PROGRAM_@@ TO_@@ CAL@@ CUL@@ ATE_@@ PO@@ WX@@ N | public : int power ( int x , unsigned int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; }
SM@@ ALLE@@ ST_@@ WINDOW_@@ CONTAIN@@ S_@@ CHARAC@@ TER@@ S_@@ STRING | string find@@ Sub@@ String ( string str ) { int n = str . length ( ) ; int dist@@ _count = 0 ; bool visited [ MAX_@@ CHARS ] = { false } ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ str [ i ] ] == false ) { visited [ str [ i ] ] = true ; dist@@ _count ++ ; } } int start = 0 , start_index = - 1 , min_@@ len = INT_MAX ; int count = 0 ; int curr_@@ count [ MAX_@@ CHARS ] = { 0 } ; for ( int j = 0 ; j < n ; j ++ ) { curr_@@ count [ str [ j ] ] ++ ; if ( curr_@@ count [ str [ j ] ] == 1 ) count ++ ; if ( count == dist@@ _count ) { while ( curr_@@ count [ str [ start ] ] > 1 ) { if ( curr_@@ count [ str [ start ] ] > 1 ) curr_@@ count [ str [ start ] ] -- ; start ++ ; } int len_@@ window = j - start + 1 ; if ( min_@@ len > len_@@ window ) { min_@@ len = len_@@ window ; start_index = start ; } } } return str . substr ( start_index , min_@@ len ) ; }
CLU@@ STER@@ ING@@ PARTI@@ TION@@ ING_@@ AN_@@ ARRAY@@ _SU@@ CH_@@ TH@@ AT_@@ S@@ UM_@@ OF@@ _S@@ QU@@ ARE_@@ DIFF@@ ER@@ EN@@ CES_@@ IS_@@ MIN@@ IMUM | void solve ( int i , int par , int a [ ] , int n , int k , int current_@@ ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = min ( ans , current_@@ ans ) ; return ; } for ( int j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_@@ ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }
PROGRAM_@@ FIN@@ D_S@@ MAL@@ LE@@ ST_@@ LAR@@ GE@@ ST_@@ WORD_@@ STRING | void min@@ Max@@ Length@@ Words ( string input , string & min@@ Word , string & max@@ Word ) { int len = input . length ( ) ; int si = 0 , ei = 0 ; int min_@@ length = len , min_@@ start_index = 0 , max_length = 0 , max_@@ start_index = 0 ; while ( ei <= len ) { if ( ei < len && input [ ei ] != ' ▁ ' ) ei ++ ; else { int curr_@@ length = ei - si ; if ( curr_@@ length < min_@@ length ) { min_@@ length = curr_@@ length ; min_@@ start_index = si ; } if ( curr_@@ length > max_length ) { max_length = curr_@@ length ; max_@@ start_index = si ; } ei ++ ; si = ei ; } } min@@ Word = input . substr ( min_@@ start_index , min_@@ length ) ; max@@ Word = input . substr ( max_@@ start_index , max_length ) ; }
CHECK_@@ VALI@@ D@@ _SEQU@@ ENCE_@@ DI@@ VISI@@ BLE_@@ M_@@ 1 | int is@@ Possible ( int n , int index , int modulo , int M , int arr [ ] , int dp [ ] [ MAX ] ) { modulo = ( ( modulo % M ) + M ) % M ; if ( index == n ) { if ( modulo == 0 ) return 1 ; return 0 ; } if ( dp [ index ] [ modulo ] != - 1 ) return dp [ index ] [ modulo ] ; int place@@ Add = is@@ Possible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) ; int place@@ Minus = is@@ Possible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) ; bool res = ( place@@ Add || place@@ Minus ) ; dp [ index ] [ modulo ] = res ; return res ; }
MINIMUM_@@ OPERATION_@@ MAKE_@@ ELEMEN@@ TS_@@ EQUAL_@@ ARRAY | int min@@ Operation ( int arr [ ] , int n ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < n ; i ++ ) hash [ arr [ i ] ] ++ ; int max_@@ count = 0 ; for ( auto i : hash ) if ( max_@@ count < i . second ) max_@@ count = i . second ; return ( n - max_@@ count ) ; }
HYPER@@ CUBE_@@ GRAP@@ H | int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
PROGRAM_@@ FIND_@@ COR@@ RELA@@ TION_@@ CO@@ EF@@ FI@@ CI@@ ENT | float correlation@@ Coefficient ( int X [ ] , int Y [ ] , int n ) { int sum_@@ X = 0 , sum_@@ Y = 0 , sum_@@ XY = 0 ; int square@@ Sum@@ _@@ X = 0 , square@@ Sum@@ _@@ Y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_@@ X = sum_@@ X + X [ i ] ; sum_@@ Y = sum_@@ Y + Y [ i ] ; sum_@@ XY = sum_@@ XY + X [ i ] * Y [ i ] ; square@@ Sum@@ _@@ X = square@@ Sum@@ _@@ X + X [ i ] * X [ i ] ; square@@ Sum@@ _@@ Y = square@@ Sum@@ _@@ Y + Y [ i ] * Y [ i ] ; } float corr = ( float ) ( n * sum_@@ XY - sum_@@ X * sum_@@ Y ) / sqrt ( ( n * square@@ Sum@@ _@@ X - sum_@@ X * sum_@@ X ) * ( n * square@@ Sum@@ _@@ Y - sum_@@ Y * sum_@@ Y ) ) ; return corr ; }
COUNT_@@ PA@@ LIN@@ DRO@@ MI@@ C@@ _SUB@@ SEQU@@ ENCE_@@ GI@@ V@@ EN_@@ STRING | int count@@ PS ( string str ) { int N = str . length ( ) ; int c@@ ps [ N + 1 ] [ N + 1 ] ; memset ( c@@ ps , 0 , sizeof ( c@@ ps ) ) ; for ( int i = 0 ; i < N ; i ++ ) c@@ ps [ i ] [ i ] = 1 ; for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i < N ; i ++ ) { int k = L + i - 1 ; if ( str [ i ] == str [ k ] ) c@@ ps [ i ] [ k ] = c@@ ps [ i ] [ k - 1 ] + c@@ ps [ i + 1 ] [ k ] + 1 ; else c@@ ps [ i ] [ k ] = c@@ ps [ i ] [ k - 1 ] + c@@ ps [ i + 1 ] [ k ] - c@@ ps [ i + 1 ] [ k - 1 ] ; } } return c@@ ps [ 0 ] [ N - 1 ] ; }
SM@@ ALLE@@ ST_@@ POWER_@@ OF_@@ 2_@@ GREATER_@@ TH@@ AN_@@ OR_@@ EQUAL_@@ TO_@@ N_@@ 1 | unsigned int next@@ PowerOf@@ 2 ( unsigned int n ) { unsigned int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
FIND_@@ LAST_@@ DIG@@ IT_@@ FAC@@ TOR@@ I@@ AL_@@ DI@@ VIDE@@ S_@@ FAC@@ TOR@@ I@@ AL_@@ B | int compute@@ Last@@ Digit ( long long int A , long long int B ) { int variable = 1 ; if ( A == B ) return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( long long int i = A + 1 ; i <= B ; i ++ ) variable = ( variable * ( i % 10 ) ) % 10 ; return variable % 10 ; } }
NUMBER@@ _SUB@@ STRING@@ S_@@ DI@@ VISI@@ BLE_@@ 4_@@ STRING_@@ INTEG@@ ERS | int count@@ Di@@ vis@@ ble@@ by@@ 4 ( char s [ ] ) { int n = strlen ( s ) ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( s [ i ] == '4' || s [ i ] == '8' || s [ i ] == '0' ) count ++ ; for ( int i = 0 ; i < n - 1 ; ++ i ) { int h = ( s [ i ] - '0' ) * 10 + ( s [ i + 1 ] - '0' ) ; if ( h % 4 == 0 ) count = count + i + 1 ; } return count ; }
DECODE_@@ MEDI@@ AN_@@ STRING_@@ ORIGIN@@ AL_@@ STRING | string decode@@ Median@@ String ( string s ) { int l = s . length ( ) ; string s1 = " " ; bool is@@ Even = ( l % 2 == 0 ) ? true : false ; for ( int i = 0 ; i < l ; i += 2 ) { if ( is@@ Even ) { s1 = s [ i ] + s1 ; s1 += s [ i + 1 ] ; } else { if ( l - i > 1 ) { s1 += s [ i ] ; s1 = s [ i + 1 ] + s1 ; } else { s1 += s [ i ] ; } } } return s1 ; }
NUMBER_@@ WHI@@ CH_@@ HAS_@@ THE_@@ MAXIMUM_@@ NUMBER_OF_@@ DISTIN@@ CT_@@ PRI@@ ME_@@ FAC@@ TOR@@ S_IN_@@ RANGE_@@ M_@@ TO_@@ N | int maximum@@ Number@@ Distinct@@ Prime@@ Range ( int m , int n ) { long long factor@@ Count [ n + 1 ] ; bool prime [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { factor@@ Count [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) { factor@@ Count [ i ] = 1 ; for ( int j = i * 2 ; j <= n ; j += i ) { factor@@ Count [ j ] ++ ; prime [ j ] = false ; } } } int max = factor@@ Count [ m ] ; int num = m ; for ( int i = m ; i <= n ; i ++ ) { if ( factor@@ Count [ i ] > max ) { max = factor@@ Count [ i ] ; num = i ; } } return num ; }
NUMBER_@@ EQUAL_@@ PAIR@@ S_@@ STRING | int count@@ Pairs ( string s ) { int cnt [ MAX ] = { 0 } ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) cnt [ s [ i ] ] ++ ; int ans = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) ans += cnt [ i ] * cnt [ i ] ; return ans ; }
COUNT_@@ NUMBER_@@ WAY@@ S_@@ REACH_@@ DESTIN@@ ATION_@@ MA@@ ZE | int count@@ Paths ( int ma@@ ze [ ] [ C ] ) { if ( ma@@ ze [ 0 ] [ 0 ] == - 1 ) return 0 ; for ( int i = 0 ; i < R ; i ++ ) { if ( ma@@ ze [ i ] [ 0 ] == 0 ) ma@@ ze [ i ] [ 0 ] = 1 ; else break ; } for ( int i = 1 ; i < C ; i ++ ) { if ( ma@@ ze [ 0 ] [ i ] == 0 ) ma@@ ze [ 0 ] [ i ] = 1 ; else break ; } for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) { if ( ma@@ ze [ i ] [ j ] == - 1 ) continue ; if ( ma@@ ze [ i - 1 ] [ j ] > 0 ) ma@@ ze [ i ] [ j ] = ( ma@@ ze [ i ] [ j ] + ma@@ ze [ i - 1 ] [ j ] ) ; if ( ma@@ ze [ i ] [ j - 1 ] > 0 ) ma@@ ze [ i ] [ j ] = ( ma@@ ze [ i ] [ j ] + ma@@ ze [ i ] [ j - 1 ] ) ; } } return ( ma@@ ze [ R - 1 ] [ C - 1 ] > 0 ) ? ma@@ ze [ R - 1 ] [ C - 1 ] : 0 ; }
FIND_@@ MAX@@ IM@@ UM@@ _S@@ UM_@@ POSSI@@ BLE_@@ EQUAL@@ _S@@ UM_@@ THRE@@ E_@@ ST@@ AC@@ KS | int max@@ Sum ( int stack@@ 1 [ ] , int stack@@ 2 [ ] , int stack@@ 3 [ ] , int n1 , int n2 , int n3 ) { int sum@@ 1 = 0 , sum@@ 2 = 0 , sum@@ 3 = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) sum@@ 1 += stack@@ 1 [ i ] ; for ( int i = 0 ; i < n2 ; i ++ ) sum@@ 2 += stack@@ 2 [ i ] ; for ( int i = 0 ; i < n3 ; i ++ ) sum@@ 3 += stack@@ 3 [ i ] ; int top@@ 1 = 0 , top@@ 2 = 0 , top@@ 3 = 0 ; int ans = 0 ; while ( 1 ) { if ( top@@ 1 == n1 || top@@ 2 == n2 || top@@ 3 == n3 ) return 0 ; if ( sum@@ 1 == sum@@ 2 && sum@@ 2 == sum@@ 3 ) return sum@@ 1 ; if ( sum@@ 1 >= sum@@ 2 && sum@@ 1 >= sum@@ 3 ) sum@@ 1 -= stack@@ 1 [ top@@ 1 ++ ] ; else if ( sum@@ 2 >= sum@@ 3 && sum@@ 2 >= sum@@ 3 ) sum@@ 2 -= stack@@ 2 [ top@@ 2 ++ ] ; else if ( sum@@ 3 >= sum@@ 2 && sum@@ 3 >= sum@@ 1 ) sum@@ 3 -= stack@@ 3 [ top@@ 3 ++ ] ; } }
MAX@@ IM@@ UM@@ _S@@ UM@@ _SUB@@ SEQU@@ ENCE_@@ LEA@@ ST_@@ K_@@ DISTAN@@ T_@@ ELEMENTS | int max@@ Sum ( int arr [ ] , int N , int k ) { int MS [ N ] ; MS [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( i + k + 1 >= N ) MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] ) ; else MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) ; } return MS [ 0 ] ; }
CHECK_@@ WHE@@ THER_@@ GI@@ V@@ EN_@@ NUMBER_@@ EV@@ EN_@@ OD@@ D_@@ 1 | bool is@@ Even ( int n ) { return ( ! ( n & 1 ) ) ; }
SORT_@@ ARRAY_@@ TWO_@@ HAL@@ VE@@ S_S@@ OR@@ TED | void merge@@ Two@@ Half ( int A [ ] , int n ) { sort ( A , A + n ) ; }
PYTH@@ AG@@ O@@ RE@@ AN_@@ QUAD@@ RUP@@ LE | bool py@@ th@@ ag@@ ore@@ an_@@ quad@@ r@@ uple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }
FIND_@@ THE_@@ MAXIMUM_@@ OF_@@ MIN@@ IM@@ UM@@ S_@@ FOR_@@ EVER@@ Y_@@ WINDOW@@ _SIZE_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY | void print@@ Max@@ Of@@ Min ( int arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int max@@ Of@@ Min = INT_@@ MIN ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > max@@ Of@@ Min ) max@@ Of@@ Min = min ; } cout << max@@ Of@@ Min << " ▁ " ; } }
COUNT_@@ S@@ UM_@@ OF_@@ DIG@@ IT@@ S_IN_@@ NUMB@@ ERS_@@ FROM_@@ 1_@@ TO_@@ N | int sum@@ Of@@ Digit@@ sFrom@@ 1@@ To@@ N ( int n ) { if ( n < 10 ) return n * ( n + 1 ) / 2 ; int d = log10 ( n ) ; int * a = new int [ d + 1 ] ; a [ 0 ] = 0 , a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ceil ( pow ( 10 , i - 1 ) ) ; int p = ceil ( pow ( 10 , d ) ) ; int ms@@ d = n / p ; return ms@@ d * a [ d ] + ( ms@@ d * ( ms@@ d - 1 ) / 2 ) * p + ms@@ d * ( 1 + n % p ) + sum@@ Of@@ Digit@@ sFrom@@ 1@@ To@@ N ( n % p ) ; }
RECUR@@ SI@@ VEL@@ Y_@@ BREAK_@@ NUMBER_@@ 3_@@ PAR@@ TS_@@ GET_@@ MAX@@ IM@@ UM@@ _S@@ UM@@ _1 | int break@@ Sum ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = 0 , dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ; return dp [ n ] ; }
FIND_@@ REPE@@ ATING_@@ ELEMENT_@@ SOR@@ TED_@@ ARRAY@@ _SIZE_@@ N | int find@@ Repe@@ ating@@ Element ( int arr [ ] , int low , int high ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return find@@ Repe@@ ating@@ Element ( arr , low , mid - 1 ) ; } return find@@ Repe@@ ating@@ Element ( arr , mid + 1 , high ) ; }
COUNT_@@ SUB@@ ARRAY@@ S_@@ EQUAL_@@ NUMBER_@@ 1@@ S_@@ 0@@ S_@@ 1 | int count@@ Sub@@ arr@@ With@@ Equal@@ Zero@@ And@@ One ( int arr [ ] , int n ) { map < int , int > mp ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) arr [ i ] = - 1 ; sum += arr [ i ] ; if ( sum == 0 ) count ++ ; if ( mp [ sum ] ) count += mp [ sum ] ; if ( mp [ sum ] == 0 ) mp [ sum ] = 1 ; else mp [ sum ] ++ ; } return count ; }
UNI@@ ON_@@ AND_@@ INTER@@ SECTION_@@ OF_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S_@@ 2_1 | int print@@ Intersection ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( ar@@ r1 [ i ] < ar@@ r2 [ j ] ) i ++ ; else if ( ar@@ r2 [ j ] < ar@@ r1 [ i ] ) j ++ ; else { cout << ar@@ r2 [ j ] << " ▁ " ; i ++ ; j ++ ; } } }
COUNT_@@ ALL_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQU@@ EN@@ CES | int count@@ Sub ( int arr [ ] , int n ) { int count [ 10 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - 1 ; j >= 0 ; j -- ) count [ arr [ i ] ] += count [ j ] ; count [ arr [ i ] ] ++ ; } int result = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) result += count [ i ] ; return result ; }
SM@@ ALLE@@ ST_@@ NUMBER@@ _S@@ UM_@@ DIG@@ IT@@ S_@@ N_@@ DI@@ VISI@@ BLE_@@ 10@@ N | void digit@@ s@@ Num ( int N ) { if ( N == 0 ) cout << "0 \n " ; if ( N % 9 != 0 ) cout << ( N % 9 ) ; for ( int i = 1 ; i <= ( N / 9 ) ; ++ i ) cout << "@@ 9" ; for ( int i = 1 ; i <= N ; ++ i ) cout << "0" ; cout << " \n " ; }
FIND_@@ THE_@@ NUMBER_@@ OC@@ CURR@@ ING_@@ OD@@ D_@@ NUMBER_OF_@@ TIME@@ S_@@ 1 | int getO@@ dd@@ Occurren@@ ce ( int arr [ ] , int size ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < size ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( auto i : hash ) { if ( i . second % 2 != 0 ) { return i . first ; } } return - 1 ; }
CHECK_@@ IF_@@ X_@@ CAN_@@ GI@@ VE_@@ CHANGE_@@ TO_@@ EVER@@ Y_@@ PERS@@ ON_@@ IN_@@ THE_@@ QUEUE | int is@@ Change@@ able ( int notes [ ] , int n ) { int fi@@ ve@@ Count = 0 ; int ten@@ Count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( notes [ i ] == 5 ) fi@@ ve@@ Count ++ ; else if ( notes [ i ] == 10 ) { if ( fi@@ ve@@ Count > 0 ) { fi@@ ve@@ Count -- ; ten@@ Count ++ ; } else return 0 ; } else { if ( fi@@ ve@@ Count > 0 && ten@@ Count > 0 ) { fi@@ ve@@ Count -- ; ten@@ Count -- ; } else if ( fi@@ ve@@ Count >= 3 ) { fi@@ ve@@ Count -= 3 ; } else return 0 ; } } return 1 ; }
MAXIMUM_@@ MINIMUM_@@ VALU@@ ES_@@ AL@@ GE@@ BRA@@ IC_@@ EXPRESSION | e@@ 9 int min@@ Max@@ Values ( int arr [ ] , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { sum += arr [ i ] ; arr [ i ] += 50 ; } bool dp [ MAX + 1 ] [ MAX * MAX + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { for ( int k = min ( n , i + 1 ) ; k >= 1 ; k -- ) { for ( int j = 0 ; j < MAX * MAX + 1 ; j ++ ) { if ( dp [ k - 1 ] [ j ] ) dp [ k ] [ j + arr [ i ] ] = 1 ; } } } int max_value = - INF , min_value = INF ; for ( int i = 0 ; i < MAX * MAX + 1 ; i ++ ) { if ( dp [ n ] [ i ] ) { int temp = i - 50 * n ; max_value = max ( max_value , temp * ( sum - temp ) ) ; min_value = min ( min_value , temp * ( sum - temp ) ) ; } } cout << " Maximum ▁ Value : ▁ " << max_value << " \n " << " Minimum ▁ Value : ▁ " << min_value << endl ; }
MULTI@@ PLY_@@ AN_@@ INTEGER_@@ WITH_@@ 3_@@ 5 | int multiply@@ With@@ 3@@ Point@@ 5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
MINIMUM_@@ CEL@@ LS_@@ REQUIRED_@@ REACH_@@ DESTIN@@ ATION_@@ JUM@@ PS_@@ EQUAL_@@ CELL_@@ VALUES | int min@@ Cells ( int mat [ SIZE ] [ SIZE ] , int m , int n ) { int dp [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = INT_MAX ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != INT_MAX && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != INT_MAX && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m - 1 ] [ n - 1 ] != INT_MAX ) return dp [ m - 1 ] [ n - 1 ] ; return - 1 ; }
FIND_@@ INDEX_@@ OF_@@ AN_@@ EXTRA_@@ ELEMENT_@@ PRES@@ ENT_@@ IN_@@ ONE@@ _S@@ OR@@ TED_@@ ARRAY | int find@@ Extra ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ar@@ r1 [ i ] != ar@@ r2 [ i ] ) return i ; return n ; }
CAL@@ CUL@@ ATE_@@ S@@ UM_@@ OF_@@ ALL_@@ NUMB@@ ERS_@@ PRES@@ ENT_@@ IN_@@ A_@@ STRING | int find@@ Sum ( string str ) { string temp = " " ; int sum = 0 ; for ( char ch : str ) { if ( isdigit ( ch ) ) temp += ch ; else { sum += atoi ( temp . c_str ( ) ) ; temp = " " ; } } return sum + atoi ( temp . c_str ( ) ) ; }
CHECK_@@ REVER@@ SING@@ _SUB_@@ ARRAY_@@ MAKE_@@ ARRA@@ Y_S@@ OR@@ TED | bool check@@ Reverse ( int arr [ ] , int n ) { int temp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) temp [ i ] = arr [ i ] ; sort ( temp , temp + n ) ; int front ; for ( front = 0 ; front < n ; front ++ ) if ( temp [ front ] != arr [ front ] ) break ; int back ; for ( back = n - 1 ; back >= 0 ; back -- ) if ( temp [ back ] != arr [ back ] ) break ; if ( front >= back ) return true ; do { front ++ ; if ( arr [ front - 1 ] < arr [ front ] ) return false ; } while ( front != back ) ; return true ; }
GENERATE_@@ PYTH@@ AG@@ OR@@ AS_@@ TR@@ IP@@ LET_@@ SINGLE_@@ INTEGER | void evaluate ( long long int n ) { if ( n == 1 || n == 2 ) printf ( " No ▁ Py@@ th@@ ag@@ or@@ as ▁ Trip@@ let ▁ exists " ) ; else if ( n % 2 == 0 ) { long long int var = 1@@ LL * n * n / 4 ; printf ( " Py@@ th@@ ag@@ or@@ as ▁ Trip@@ lets ▁ exist ▁ i . e . ▁ " ) ; printf ( " % lld ▁ % lld ▁ % lld " , n , var - 1 , var + 1 ) ; } else if ( n % 2 != 0 ) { long long int var = 1@@ LL * n * n + 1 ; printf ( " Py@@ th@@ ag@@ or@@ as ▁ Trip@@ lets ▁ exist ▁ i . e . ▁ " ) ; printf ( " % lld ▁ % lld ▁ % lld " , n , var / 2 - 1 , var / 2 ) ; } }
PE@@ TER@@ S@@ ON_@@ GRAP@@ H | bool find@@ the@@ path ( char * S , int v ) { result [ 0 ] = v + '0' ; for ( int i = 1 ; S [ i ] ; i ++ ) { if ( adj [ v ] [ S [ i ] - ' A ' ] || adj [ S [ i ] - ' A ' ] [ v ] ) { v = S [ i ] - ' A ' ; } else if ( adj [ v ] [ S [ i ] - ' A ' + 5 ] || adj [ S [ i ] - ' A ' + 5 ] [ v ] ) { v = S [ i ] - ' A ' + 5 ; } else return false ; result [ i ] = v + '0' ; } return true ; }
COUNT_@@ NUMBER_@@ OF@@ _S@@ OL@@ U@@ TIONS_@@ OF_@@ X@@ 2_@@ 1_@@ MOD_@@ P_@@ IN_@@ GI@@ V@@ EN_@@ RANGE | int find@@ Count@@ Of@@ Solutions ( int n , int p ) { ll ans = 0 ; for ( ll x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { ll last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }
JUM@@ P@@ _SEARCH | int jump@@ Search ( int arr [ ] , int x , int n ) { int step = sqrt ( n ) ; int prev = 0 ; while ( arr [ min ( step , n ) - 1 ] < x ) { prev = step ; step += sqrt ( n ) ; if ( prev >= n ) return - 1 ; } while ( arr [ prev ] < x ) { prev ++ ; if ( prev == min ( step , n ) ) return - 1 ; } if ( arr [ prev ] == x ) return prev ; return - 1 ; }
FORM_@@ MINIMUM_@@ NUMBER_@@ FROM_@@ GI@@ VEN@@ _SEQU@@ ENCE | void Print@@ Min@@ Number@@ For@@ Pattern ( string arr ) { int curr_@@ max = 0 ; int last_@@ entry = 0 ; int j ; for ( int i = 0 ; i < arr . length ( ) ; i ++ ) { int noOf@@ Next@@ D = 0 ; switch ( arr [ i ] ) { case ' I ' : j = i + 1 ; while ( arr [ j ] == ' D ' && j < arr . length ( ) ) { noOf@@ Next@@ D ++ ; j ++ ; } if ( i == 0 ) { curr_@@ max = noOf@@ Next@@ D + 2 ; cout << " ▁ " << ++ last_@@ entry ; cout << " ▁ " << curr_@@ max ; last_@@ entry = curr_@@ max ; } else { curr_@@ max = curr_@@ max + noOf@@ Next@@ D + 1 ; last_@@ entry = curr_@@ max ; cout << " ▁ " << last_@@ entry ; } for ( int k = 0 ; k < noOf@@ Next@@ D ; k ++ ) { cout << " ▁ " << -- last_@@ entry ; i ++ ; } break ; case ' D ' : if ( i == 0 ) { j = i + 1 ; while ( arr [ j ] == ' D ' && j < arr . length ( ) ) { noOf@@ Next@@ D ++ ; j ++ ; } curr_@@ max = noOf@@ Next@@ D + 2 ; cout << " ▁ " << curr_@@ max << " ▁ " << curr_@@ max - 1 ; last_@@ entry = curr_@@ max - 1 ; } else { cout << " ▁ " << last_@@ entry - 1 ; last_@@ entry -- ; } break ; } } cout << endl ; }
GI@@ V@@ EN_@@ LARGE_@@ NUMBER_@@ CHECK@@ _SUB@@ SEQU@@ ENCE_@@ DIG@@ IT@@ S_@@ DI@@ VISI@@ BLE_@@ 8 | bool isSub@@ Seq@@ Di@@ visible ( string str ) { for ( int i = 0 ; i < l ; i ++ ) { for ( int j = i ; j < l ; j ++ ) { for ( int k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }
PRINT_@@ FI@@ BON@@ AC@@ CI@@ _SEQU@@ ENCE_@@ USING_@@ 2_@@ VARIABLES | void fi@@ b ( int n ) { int a = 0 , b = 1 , c ; if ( n >= 0 ) cout << a << " ▁ " ; if ( n >= 1 ) cout << b << " ▁ " ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; cout << c << " ▁ " ; a = b ; b = c ; } }
INTER@@ CHANGE_@@ ELEMEN@@ TS_@@ OF_@@ FIRST_@@ AND_@@ LAST_@@ RO@@ WS_@@ IN_@@ MATRIX | void inter@@ change@@ First@@ Last ( int m [ ] [ n ] ) { int rows = n ; for ( int i = 0 ; i < n ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } }
S@@ UM_@@ MATRIX_@@ ELEMENT_@@ ABSOL@@ UTE_@@ DIFF@@ ER@@ ENCE_@@ ROW_@@ COLUMN_@@ NUMB@@ ERS | int find@@ Sum ( int n ) { int arr [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = abs ( i - j ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }
FIND_@@ THE_@@ MAXIMUM_@@ ELEMENT_@@ IN_@@ AN_@@ ARRAY_@@ WHI@@ CH_@@ IS_@@ FIRST_@@ INCRE@@ AS@@ ING_@@ AND_@@ TH@@ EN_@@ DECRE@@ AS@@ ING | int find@@ Maximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low + 1 ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else break ; } return max ; }
PROGRAM_@@ CHECK_@@ DIAG@@ ON@@ AL_@@ MATRI@@ X@@ _SCAL@@ AR_@@ MATRIX_@@ 1 | bool is@@ Scalar@@ Matrix ( int mat [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( int i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; return true ; }
ST@@ OO@@ GE_@@ S@@ ORT | void st@@ oo@@ ge@@ sort ( int arr [ ] , int l , int h ) { if ( l >= h ) return ; if ( arr [ l ] > arr [ h ] ) swap ( arr [ l ] , arr [ h ] ) ; if ( h - l + 1 > 2 ) { int t = ( h - l + 1 ) / 3 ; st@@ oo@@ ge@@ sort ( arr , l , h - t ) ; st@@ oo@@ ge@@ sort ( arr , l + t , h ) ; st@@ oo@@ ge@@ sort ( arr , l , h - t ) ; } }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 11_@@ EG@@ G_@@ DRO@@ PP@@ ING_@@ PU@@ ZZ@@ LE | int egg@@ Drop ( int n , int k ) { if ( k == 1 || k == 0 ) return k ; if ( n == 1 ) return k ; int min = INT_MAX , x , res ; for ( x = 1 ; x <= k ; x ++ ) { res = max ( egg@@ Drop ( n - 1 , x - 1 ) , egg@@ Drop ( n , k - x ) ) ; if ( res < min ) min = res ; } return min + 1 ; }
DIFF@@ ER@@ ENT_@@ WAY@@ S_S@@ UM_@@ N_@@ USING_@@ NUMB@@ ERS_@@ GREATER_@@ EQUAL_@@ M | int number@@ of@@ ways ( int n , int m ) { int dp [ n + 2 ] [ n + 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
BU@@ BB@@ LE_@@ S@@ ORT | void bu@@ bble@@ Sort ( int arr [ ] , int n ) { int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) for ( j = 0 ; j < n - i - 1 ; j ++ ) if ( arr [ j ] > arr [ j + 1 ] ) swap ( & arr [ j ] , & arr [ j + 1 ] ) ; }
GENERATE_@@ ROTA@@ TIONS_@@ GI@@ V@@ EN_@@ STRING | void print@@ Rot@@ ated@@ String ( char str [ ] ) { int len = strlen ( str ) ; char temp [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { int j = i ; int k = 0 ; while ( str [ j ] != ' \0' ) { temp [ k ] = str [ j ] ; k ++ ; j ++ ; } j = 0 ; while ( j < i ) { temp [ k ] = str [ j ] ; j ++ ; k ++ ; } printf ( " % s \n " , temp ) ; } }
M@@ ID_@@ POINT_@@ LINE_@@ GENERA@@ TION_@@ ALGORITH@@ M | void mid@@ Point ( int X1 , int Y1 , int X2 , int Y2 ) { int dx = X2 - X1 ; int dy = Y2 - Y1 ; int d = dy - ( dx / 2 ) ; int x = X1 , y = Y1 ; cout << x << " , " << y << " \n " ; while ( x < X2 ) { x ++ ; if ( d < 0 ) d = d + dy ; else { d += ( dy - dx ) ; y ++ ; } cout << x << " , " << y << " \n " ; } }
FIN@@ DING_@@ VERTEX_@@ FOCUS_@@ DIREC@@ TRI@@ X_@@ PAR@@ ABO@@ LA | void par@@ ab@@ ola ( float a , float b , float c ) { cout << " Vertex : ▁ ( " << ( - b / ( 2 * a ) ) << " , ▁ " << ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) << " ) " << endl ; cout << " Focus : ▁ ( " << ( - b / ( 2 * a ) ) << " , ▁ " << ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) << " ) " << endl ; cout << " Direc@@ tri@@ x : ▁ y = " << c - ( ( b * b ) + 1 ) * 4 * a << endl ; }
TRIANG@@ ULAR_@@ NUMB@@ ERS | bool is@@ Tri@@ angular ( int num ) { if ( num < 0 ) return false ; int sum = 0 ; for ( int n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; }
PI@@ ZZ@@ A_@@ CU@@ T_@@ PRO@@ BLE@@ M_@@ CI@@ R@@ CLE_@@ DI@@ VISI@@ ON_@@ LINES | int find@@ Maximum@@ Pieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
MINIMUM_@@ TIME_@@ WRITE_@@ CHARAC@@ TER@@ S_@@ USING_@@ INSERT_@@ DELETE_@@ COPY_@@ OPERATION | int min@@ Time@@ For@@ Writing@@ Chars ( int N , int insert , int remove , int copy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insert ; int dp [ N + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + copy ) ; else dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) / 2 ] + copy + remove ) ; } return dp [ N ] ; }
SE@@ ARCH@@ ING_@@ ARRAY_@@ AD@@ J@@ AC@@ ENT_@@ DIFF@@ ER_@@ K | int search ( int arr [ ] , int n , int x , int k ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + max ( 1 , abs ( arr [ i ] - x ) / k ) ; } cout << " number ▁ is ▁ not ▁ present ! " ; return - 1 ; }
FIND_@@ MAXIMUM_@@ PRODUCT_@@ OF_@@ A_@@ TR@@ IP@@ LET_@@ IN_@@ ARRAY | int max@@ Product ( int arr [ ] , int n ) { if ( n < 3 ) return - 1 ; int max_@@ product = INT_@@ MIN ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) max_@@ product = max ( max_@@ product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_@@ product ; }
LON@@ GE@@ ST_@@ PA@@ LIN@@ DRO@@ ME_@@ SUB@@ SEQU@@ ENCE_@@ SPACE | int l@@ ps ( string & s ) { int n = s . length ( ) ; int a [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int back_@@ up = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( j == i ) a [ j ] = 1 ; else if ( s [ i ] == s [ j ] ) { int temp = a [ j ] ; a [ j ] = back_@@ up + 2 ; back_@@ up = temp ; } else { back_@@ up = a [ j ] ; a [ j ] = max ( a [ j - 1 ] , a [ j ] ) ; } } } return a [ n - 1 ] ; }
CHECK_@@ HALF_@@ STRING_@@ CHARACTER_@@ FREQU@@ ENCY_@@ CHARACTER_@@ 1 | bool check@@ Correct@@ Or@@ Not ( string s ) { int count [ MAX_@@ CHAR ] = { 0 } ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count [ s [ i ] - ' a ' ] ++ ; count [ s [ j ] - ' a ' ] -- ; } for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) if ( count [ i ] != 0 ) return false ; return true ; }
EXPO@@ NE@@ N@@ TI@@ AL_S@@ QUAR@@ ING_@@ FAST_@@ MODUL@@ O_@@ MULTIP@@ LIC@@ ATION | long int expon@@ enti@@ ation ( long int base , long int exp ) { if ( exp == 0 ) return 1 ; if ( exp == 1 ) return base % N ; long int t = expon@@ enti@@ ation ( base , exp / 2 ) ; t = ( t * t ) % N ; if ( exp % 2 == 0 ) return t ; else return ( ( base % N ) * t ) % N ; }
REMOVE_@@ MINIMUM_@@ NUMBER_@@ ELEMEN@@ TS_@@ NO_@@ COMMON_@@ ELEMENT_@@ EXI@@ ST_@@ ARRAY | int min@@ Remove ( int a [ ] , int b [ ] , int n , int m ) { unordered_map < int , int > count@@ A , count@@ B ; for ( int i = 0 ; i < n ; i ++ ) count@@ A [ a [ i ] ] ++ ; for ( int i = 0 ; i < m ; i ++ ) count@@ B [ b [ i ] ] ++ ; int res = 0 ; for ( auto x : count@@ A ) if ( count@@ B . find ( x . first ) != count@@ B . end ( ) ) res += min ( x . second , count@@ B [ x . first ] ) ; return res ; }
FIND_@@ A_@@ FIXED_@@ POINT_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY | int linear@@ Search ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; }
ADD_@@ 1_@@ TO_@@ A_@@ GI@@ V@@ EN_@@ NUMBER | int add@@ One ( int x ) { int m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
HEIGHT_@@ COMPLETE_@@ BINARY_@@ TREE_@@ HEAP_@@ N_@@ NODES | int height ( int N ) { return ceil ( log2 ( N + 1 ) ) - 1 ; }
MINIMUM_@@ NUMBER_OF_@@ JUM@@ PS_@@ TO_@@ REACH_@@ END_OF_@@ A_@@ GI@@ V@@ EN_@@ ARRAY | int min@@ Jump@@ s ( int arr [ ] , int n ) { if ( n == 1 ) return 0 ; int res = INT_MAX ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( i + arr [ i ] >= n - 1 ) { int sub_@@ res = min@@ Jump@@ s ( arr , i + 1 ) ; if ( sub_@@ res != INT_MAX ) res = min ( res , sub_@@ res + 1 ) ; } } return res ; }
PROGRAM_@@ FOR_@@ N@@ TH_@@ FI@@ BON@@ ACC@@ I_@@ NUMBER_@@ 2 | int fi@@ b ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 || n == 2 ) return ( f [ n ] = 1 ) ; if ( f [ n ] ) return f [ n ] ; int k = ( n & 1 ) ? ( n + 1 ) / 2 : n / 2 ; f [ n ] = ( n & 1 ) ? ( fi@@ b ( k ) * fi@@ b ( k ) + fi@@ b ( k - 1 ) * fi@@ b ( k - 1 ) ) : ( 2 * fi@@ b ( k - 1 ) + fi@@ b ( k ) ) * fi@@ b ( k ) ; return f [ n ] ; }
DECODE_@@ STRING_@@ RECUR@@ SI@@ VEL@@ Y_@@ EN@@ CODE@@ D_@@ COUNT_@@ FOL@@ LO@@ WE@@ D@@ _SUB@@ STRING | string decode ( string str ) { stack < int > integer@@ stack ; stack < char > string@@ stack ; string temp = " " , result = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int count = 0 ; if ( str [ i ] >= '0' && str [ i ] <= '9' ) { while ( str [ i ] >= '0' && str [ i ] <= '9' ) { count = count * 10 + str [ i ] - '0' ; i ++ ; } i -- ; integer@@ stack . push ( count ) ; } else if ( str [ i ] == ' ] ' ) { temp = " " ; count = 0 ; if ( ! integer@@ stack . empty ( ) ) { count = integer@@ stack . top ( ) ; integer@@ stack . pop ( ) ; } while ( ! string@@ stack . empty ( ) && string@@ stack . top ( ) != ' [ ' ) { temp = string@@ stack . top ( ) + temp ; string@@ stack . pop ( ) ; } if ( ! string@@ stack . empty ( ) && string@@ stack . top ( ) == ' [ ' ) string@@ stack . pop ( ) ; for ( int j = 0 ; j < count ; j ++ ) result = result + temp ; for ( int j = 0 ; j < result . length ( ) ; j ++ ) string@@ stack . push ( result [ j ] ) ; result = " " ; } else if ( str [ i ] == ' [ ' ) { if ( str [ i - 1 ] >= '0' && str [ i - 1 ] <= '9' ) string@@ stack . push ( str [ i ] ) ; else { string@@ stack . push ( str [ i ] ) ; integer@@ stack . push ( 1 ) ; } } else string@@ stack . push ( str [ i ] ) ; } while ( ! string@@ stack . empty ( ) ) { result = string@@ stack . top ( ) + result ; string@@ stack . pop ( ) ; } return result ; }
HO@@ W_@@ TO_@@ CHECK_@@ IF_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ RE@@ PRESEN@@ TS_@@ A_@@ BINARY_@@ HEA@@ P | bool is@@ Heap ( int arr [ ] , int i , int n ) { if ( i > ( n - 2 ) / 2 ) return true ; if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && is@@ Heap ( arr , 2 * i + 1 , n ) && is@@ Heap ( arr , 2 * i + 2 , n ) ) return true ; return false ; }
HO@@ W_@@ TO_@@ CHECK_@@ IF_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ RE@@ PRESEN@@ TS_@@ A_@@ BINARY_@@ HEAP_@@ 1 | bool is@@ Heap ( int arr [ ] , int n ) { for ( int i = 0 ; i <= ( n - 2 ) / 2 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false ; if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) return false ; } return true ; }
CAL@@ CUL@@ ATE_@@ ANGLE_@@ HOUR_@@ H@@ AND_@@ MIN@@ UTE_@@ HAND | int calc@@ Angle ( double h , double m ) { if ( h < 0 || m < 0 || h > 12 || m > 60 ) printf ( " Wrong ▁ input " ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) m = 0 ; int hour@@ _@@ angle = 0.5 * ( h * 60 + m ) ; int minu@@ te_@@ angle = 6 * m ; int angle = abs ( hour@@ _@@ angle - minu@@ te_@@ angle ) ; angle = min ( 360 - angle , angle ) ; return angle ; }
CONVER@@ TING_@@ DECIMAL_@@ NUMBER_@@ LY@@ ING_@@ BETWE@@ EN_@@ 1_@@ TO_@@ 399@@ 9_@@ TO_@@ RO@@ MAN_@@ NUMER@@ ALS | int print@@ Roman ( int number ) { int num [ ] = { 1 , 4 , 5 , 9 , 10 , 40 , 50 , 90 , 100 , 400 , 500 , 900 , 1000 } ; string sym [ ] = { " I " , " IV " , " V " , " IX " , " X " , " X@@ L " , " L " , " X@@ C " , " C " , " CD " , " D " , " CM " , " M " } ; int i = 12 ; while ( number > 0 ) { int div = number / num [ i ] ; number = number % num [ i ] ; while ( div -- ) { cout << sym [ i ] ; } i -- ; } }
SOR@@ TING_@@ USING_@@ TRI@@ VI@@ AL_@@ HASH_@@ FUNCTION | void sort@@ Using@@ Hash ( int a [ ] , int n ) { int max = * std :: max_@@ element ( a , a + n ) ; int hash [ max + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) hash [ a [ i ] ] += 1 ; for ( int i = 0 ; i <= max ; i ++ ) { if ( hash [ i ] ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) { cout << i << " ▁ " ; } } } }
S@@ UM_@@ PAIR@@ WI@@ SE_@@ PRODUC@@ TS_@@ 2 | long long int find@@ Sum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ; }
ENTR@@ ING@@ ER_@@ NUMBER | int zig@@ z@@ ag ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zig@@ z@@ ag ( n , k - 1 ) + zig@@ z@@ ag ( n - 1 , n - k ) ; }
MIN@@ IM@@ UM@@ _S@@ UM_@@ TWO_@@ NUMB@@ ERS_@@ FOR@@ MED_@@ DIG@@ IT@@ S_@@ ARRAY_@@ 2 | int min@@ Sum ( int a [ ] , int n ) { sort ( a , a + n ) ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }
SUB@@ ARRAY_@@ NO_@@ PAIR@@ _S@@ UM_@@ DI@@ VISI@@ BLE_@@ K | void sub@@ array@@ Di@@ visible@@ By@@ K ( int arr [ ] , int n , int k ) { map < int , int > mp ; int s = 0 , e = 0 , maxs = 0 , max@@ e = 0 ; mp [ arr [ 0 ] % k ] ++ ; for ( int i = 1 ; i < n ; i ++ ) { int mod = arr [ i ] % k ; while ( mp [ k - mod ] != 0 || ( mod == 0 && mp [ mod ] != 0 ) ) { mp [ arr [ s ] % k ] -- ; s ++ ; } mp [ mod ] ++ ; e ++ ; if ( ( e - s ) > ( max@@ e - maxs ) ) { max@@ e = e ; maxs = s ; } } cout << " The ▁ maximum ▁ size ▁ is ▁ " << max@@ e - maxs + 1 << " ▁ and ▁ " " the ▁ sub@@ array ▁ is ▁ as ▁ follows \n " ; for ( int i = maxs ; i <= max@@ e ; i ++ ) cout << arr [ i ] << " ▁ " ; }
MAXIMUM_@@ PROFI@@ T_@@ BY_@@ BU@@ Y@@ ING_@@ AND@@ _S@@ EL@@ LING_@@ A@@ _SH@@ ARE_@@ AT_@@ MO@@ ST_@@ K_@@ TIMES | int max@@ Pro@@ fit ( int price [ ] , int n , int k ) { int pro@@ fit [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) pro@@ fit [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) pro@@ fit [ 0 ] [ j ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { int max_@@ so@@ _f@@ ar = INT_@@ MIN ; for ( int m = 0 ; m < j ; m ++ ) max_@@ so@@ _f@@ ar = max ( max_@@ so@@ _f@@ ar , price [ j ] - price [ m ] + pro@@ fit [ i - 1 ] [ m ] ) ; pro@@ fit [ i ] [ j ] = max ( pro@@ fit [ i ] [ j - 1 ] , max_@@ so@@ _f@@ ar ) ; } } return pro@@ fit [ k ] [ n - 1 ] ; }
MINI@@ MI@@ ZE_@@ S@@ UM_@@ PRODUCT_@@ TWO_@@ ARRAY@@ S_PER@@ MU@@ TA@@ TIONS_@@ ALLOWED | int minValue ( int A [ ] , int B [ ] , int n ) { sort ( A , A + n ) ; sort ( B , B + n ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }
FIND_@@ MAXIMUM_@@ ELEMENT_@@ ROW_@@ MATRIX | void max@@ element ( int no_@@ of_@@ rows , int arr [ ] [ N ] ) { int i = 0 ; int max = 0 ; int result [ no_@@ of_@@ rows ] ; while ( i < no_@@ of_@@ rows ) { for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ j ] > max ) { max = arr [ i ] [ j ] ; } } result [ i ] = max ; max = 0 ; i ++ ; } print@@ Array ( result , no_@@ of_@@ rows ) ; }
ROUND_@@ OFF_@@ NUMBER_@@ GI@@ V@@ EN_@@ NUMBER@@ _SIGN@@ I@@ FI@@ CANT_@@ DIGITS | void Ro@@ und_@@ off ( double N , double n ) { int h ; double l , a , b , c , d , e , i , j , m , f , g ; b = N ; c = floor ( N ) ; for ( i = 0 ; b >= 1 ; ++ i ) b = b / 10 ; d = n - i ; b = N ; b = b * pow ( 10 , d ) ; e = b + 0.5 ; if ( ( float ) e == ( float ) ceil ( b ) ) { f = ( ceil ( b ) ) ; h = f - 2 ; if ( h % 2 != 0 ) { e = e - 1 ; } } j = floor ( e ) ; m = pow ( 10 , d ) ; j = j / m ; cout << " The ▁ number ▁ after ▁ rounding - off ▁ is ▁ " << j ; }
CHECK_@@ WHE@@ THER_@@ POINT_@@ EXI@@ ST@@ S_@@ CI@@ R@@ CLE_@@ SEC@@ TOR_@@ NOT | void check@@ Point ( int radius , int x , int y , float percent , float start@@ Angle ) { float end@@ Angle = 360 / percent + start@@ Angle ; float polar@@ radius = sqrt ( x * x + y * y ) ; float Angle = atan ( y / x ) ; if ( Angle >= start@@ Angle && Angle <= end@@ Angle && polar@@ radius < radius ) printf ( " Point ▁ ( % d , ▁ % d ) ▁ exist ▁ in ▁ the ▁ circle ▁ sector \n " , x , y ) ; else printf ( " Point ▁ ( % d , ▁ % d ) ▁ does ▁ not ▁ exist ▁ in ▁ the ▁ circle ▁ sector \n " , x , y ) ; }
NUMBER_@@ IS_@@ DI@@ VISI@@ BLE_@@ BY_@@ 29@@ _@@ OR_@@ NOT | bool is@@ Di@@ visible ( long long int n ) { while ( n / 100 ) { int last_@@ digit = n % 10 ; n /= 10 ; n += last_@@ digit * 3 ; } return ( n % 29 == 0 ) ; }
PRINT_@@ ALL_@@ DISTIN@@ CT_@@ CHARAC@@ TER@@ S_@@ OF_@@ A_@@ STRING_@@ IN_@@ ORDER_@@ 3_@@ METHODS | void print@@ Distin@@ ct ( char * str ) { int count [ NO_@@ OF_@@ CHARS ] ; int i ; for ( i = 0 ; * ( str + i ) ; i ++ ) if ( * ( str + i ) != ' ▁ ' ) count [ * ( str + i ) ] ++ ; int n = i ; for ( i = 0 ; i < n ; i ++ ) if ( count [ * ( str + i ) ] == 1 ) cout << str [ i ] ; }
PROGRAM_@@ REVERSE_@@ STRING_@@ ITER@@ ATI@@ VE_@@ RECUR@@ SIVE | void recursive@@ Reverse ( string & str ) { stack < char > st ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) st . push ( str [ i ] ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { str [ i ] = st . top ( ) ; st . pop ( ) ; } }
PA@@ INT@@ ING_@@ F@@ ENCE_@@ ALGORITH@@ M | long count@@ W@@ ays ( int n , int k ) { long total = k ; int mod = 100000000@@ 7 ; int same = 0 , diff = k ; for ( int i = 2 ; i <= n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }
COUNT_@@ OF@@ _SUB_@@ STRING@@ S_@@ TH@@ AT_@@ DO_@@ NOT_@@ CONTA@@ IN_@@ ALL_@@ THE_@@ CHARAC@@ TER@@ S_@@ FROM_@@ THE_@@ SET_@@ A_@@ B_@@ C_@@ AT_@@ THE_@@ S@@ AME_@@ TIME | int Count@@ Sub@@ string ( char str [ ] , int n ) { int ans = ( n * ( n + 1 ) ) / 2 ; int a_@@ index = 0 ; int b_@@ index = 0 ; int c_@@ index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' a ' ) { a_@@ index = i + 1 ; ans -= min ( b_@@ index , c_@@ index ) ; } else if ( str [ i ] == ' b ' ) { b_@@ index = i + 1 ; ans -= min ( a_@@ index , c_@@ index ) ; } else { c_@@ index = i + 1 ; ans -= min ( a_@@ index , b_@@ index ) ; } } return ans ; }
CAL@@ CUL@@ ATING_@@ FAC@@ TOR@@ I@@ AL@@ S_@@ USING_@@ ST@@ IR@@ LING_@@ APPRO@@ XI@@ MATION | long int st@@ ir@@ ling@@ Fac@@ tori@@ al ( int n ) { if ( n == 1 ) return 1 ; long int z ; float e = 2.@@ 71 ; z = sqrt ( 2 * 3.14 * n ) * pow ( ( n / e ) , n ) ; return z ; }
LE@@ XI@@ CO@@ GRAPHIC@@ AL@@ LY@@ _S@@ MAL@@ LE@@ ST_@@ STRING_@@ OB@@ TA@@ IN@@ ED_@@ CON@@ CAT@@ EN@@ ATING_@@ ARRAY | string lex@@ S@@ malle@@ st ( string a [ ] , int n ) { sort ( a , a + n , compare ) ; string answer = " " ; for ( int i = 0 ; i < n ; i ++ ) answer += a [ i ] ; return answer ; }
PRODUCT_@@ MAXIMUM_@@ FIRST_@@ ARRAY_@@ MIN@@ IM@@ UM@@ _SECOND | int min@@ Max@@ Product ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int n1 , int n2 ) { sort ( ar@@ r1 , ar@@ r1 + n1 ) ; sort ( ar@@ r2 , ar@@ r2 + n2 ) ; return ar@@ r1 [ n1 - 1 ] * ar@@ r2 [ 0 ] ; }
FIND_@@ IF_@@ THER@@ E_@@ IS_@@ A@@ _SUB@@ ARRAY_@@ WITH_@@ 0@@ _S@@ UM | bool sub@@ Array@@ Exists ( int arr [ ] , int n ) { unordered_@@ set < int > sum@@ Set ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == 0 || sum@@ Set . find ( sum ) != sum@@ Set . end ( ) ) return true ; sum@@ Set . insert ( sum ) ; } return false ; }
MINIMUM_@@ PRODUCT_@@ SUB@@ SET_@@ ARRAY | int min@@ Product@@ Subset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int max_@@ neg = INT_@@ MIN ; int min_@@ pos = INT_MAX ; int count_@@ neg = 0 , count_@@ zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_@@ zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_@@ neg ++ ; max_@@ neg = max ( max_@@ neg , a [ i ] ) ; } if ( a [ i ] > 0 ) min_@@ pos = min ( min_@@ pos , a [ i ] ) ; prod = prod * a [ i ] ; } if ( count_@@ zero == n || ( count_@@ neg == 0 && count_@@ zero > 0 ) ) return 0 ; if ( count_@@ neg == 0 ) return min_@@ pos ; if ( ! ( count_@@ neg & 1 ) && count_@@ neg != 0 ) { prod = prod / max_@@ neg ; } return prod ; }
NUMBER_@@ NODE@@ S_@@ TWO_@@ VER@@ TIC@@ ES_@@ AC@@ Y@@ CLI@@ C_@@ GRAPH_@@ DIS@@ JO@@ INT_@@ UNI@@ ON_@@ METHOD | int total@@ Nodes ( vector < int > ad@@ jac [ ] , int n , int x , int y ) { bool visited [ n + 1 ] = { 0 } ; int p [ n ] ; queue < int > q ; q . push ( x ) ; visited [ x ] = true ; int m ; while ( ! q . empty ( ) ) { m = q . front ( ) ; q . pop ( ) ; for ( int i = 0 ; i < ad@@ jac [ m ] . size ( ) ; ++ i ) { int h = ad@@ jac [ m ] [ i ] ; if ( ! visited [ h ] ) { visited [ h ] = true ; p [ h ] = m ; q . push ( h ) ; } } } int count = 0 ; int i = p [ y ] ; while ( i != x ) { count ++ ; i = p [ i ] ; } return count ; }
PRINT@@ ING_@@ STRING_@@ PL@@ US_@@ PATTERN_@@ MATRIX | void car@@ ve@@ Cross ( string str ) { int n = str . length ( ) ; if ( n % 2 == 0 ) { cout << " Not ▁ possible . ▁ Please ▁ enter ▁ " << " odd ▁ length ▁ string . \n " ; } else { char arr [ max ] [ max ] ; int m = n / 2 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = ' X ' ; } } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] [ m ] = str [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ m ] [ i ] = str [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << arr [ i ] [ j ] << " ▁ " ; } cout << " \n " ; } } }
NEXT_@@ GREATER_@@ FREQU@@ ENCY_@@ ELEMENT | void NF@@ G ( int a [ ] , int n , int freq [ ] ) { stack < int > s ; s . push ( 0 ) ; int res [ n ] = { 0 } ; for ( int i = 1 ; i < n ; i ++ ) { if ( freq [ a [ s . top ( ) ] ] > freq [ a [ i ] ] ) s . push ( i ) ; else { while ( freq [ a [ s . top ( ) ] ] < freq [ a [ i ] ] && ! s . empty ( ) ) { res [ s . top ( ) ] = a [ i ] ; s . pop ( ) ; } s . push ( i ) ; } } while ( ! s . empty ( ) ) { res [ s . top ( ) ] = - 1 ; s . pop ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { cout << res [ i ] << " ▁ " ; } }
CHECK_@@ REVER@@ SING@@ _SUB_@@ ARRAY_@@ MAKE_@@ ARRA@@ Y_S@@ OR@@ TED_@@ 1 | bool check@@ Reverse ( int arr [ ] , int n ) { if ( n == 1 ) return true ; int i ; for ( i = 1 ; i < n && arr [ i - 1 ] < arr [ i ] ; i ++ ) ; if ( i == n ) return true ; int j = i ; while ( arr [ j ] < arr [ j - 1 ] ) { if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) return false ; j ++ ; } if ( j == n ) return true ; int k = j ; if ( arr [ k ] < arr [ i - 1 ] ) return false ; while ( k > 1 && k < n ) { if ( arr [ k ] < arr [ k - 1 ] ) return false ; k ++ ; } return true ; }
FIND_@@ TR@@ IP@@ LET@@ S_@@ ARRAY_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL_@@ ZERO_@@ 2 | void find@@ Trip@@ lets ( int arr [ ] , int n ) { bool found = false ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int l = i + 1 ; int r = n - 1 ; int x = arr [ i ] ; while ( l < r ) { if ( x + arr [ l ] + arr [ r ] == 0 ) { printf ( " % d ▁ % d ▁ % d \n " , x , arr [ l ] , arr [ r ] ) ; l ++ ; r -- ; found = true ; } else if ( x + arr [ l ] + arr [ r ] < 0 ) l ++ ; else r -- ; } } if ( found == false ) cout << " ▁ No ▁ Trip@@ let ▁ Found " << endl ; }
FIND_@@ ELEMEN@@ TS_@@ ARRAY_@@ LEA@@ ST_@@ TWO_@@ GREATER_@@ ELEMENTS | void find@@ Elements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) cout << arr [ i ] << " ▁ " ; } }
POSITIVE_@@ ELEMEN@@ TS_@@ EV@@ EN_@@ NEGATIVE_@@ OD@@ D_@@ POSI@@ TIONS_@@ 1 | void print@@ Array ( int * a , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << " ▁ " ; cout << endl ; return ; }
FIND_@@ MINIMUM_@@ RADI@@ US_@@ AT@@ LEA@@ ST_@@ K_@@ POINT_@@ LI@@ E_@@ IN@@ SIDE_@@ CIRC@@ LE | int min@@ Radius ( int k , int x [ ] , int y [ ] , int n ) { int dis [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; sort ( dis , dis + n ) ; return dis [ k - 1 ] ; }
COUNT_@@ SUB@@ ARRAY@@ S_@@ EQUAL_@@ NUMBER_@@ 1@@ S_@@ 0@@ S | int count@@ Sub@@ arr@@ With@@ Equal@@ Zero@@ And@@ One ( int arr [ ] , int n ) { unordered_map < int , int > um ; int curr_@@ sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_@@ sum += ( arr [ i ] == 0 ) ? - 1 : arr [ i ] ; um [ curr_@@ sum ] ++ ; } int count = 0 ; for ( auto itr = um . begin ( ) ; itr != um . end ( ) ; itr ++ ) { if ( itr -> second > 1 ) count += ( ( itr -> second * ( itr -> second - 1 ) ) / 2 ) ; } if ( um . find ( 0 ) != um . end ( ) ) count += um [ 0 ] ; return count ; }
MINIMUM_@@ INDEX@@ _S@@ UM_@@ COMMON_@@ ELEMEN@@ TS_@@ TWO_@@ LI@@ STS | void find ( vector < string > list1 , vector < string > list2 ) { vector < string > res ; int max_@@ possible_@@ sum = list1 . size ( ) + list2 . size ( ) - 2 ; for ( int sum = 0 ; sum <= max_@@ possible_@@ sum ; sum ++ ) { for ( int i = 0 ; i <= sum ; i ++ ) if ( i < list1 . size ( ) && ( sum - i ) < list2 . size ( ) && list1 [ i ] == list2 [ sum - i ] ) res . push_back ( list1 [ i ] ) ; if ( res . size ( ) > 0 ) break ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << " ▁ " ; }
CHECK_@@ IF_@@ A_@@ NUMBER_@@ IS_@@ JUM@@ B@@ LED_@@ OR_@@ NOT | bool check@@ J@@ umb@@ led ( int num ) { if ( num / 10 == 0 ) return true ; while ( num != 0 ) { if ( num / 10 == 0 ) return true ; int digit@@ 1 = num % 10 ; int digit@@ 2 = ( num / 10 ) % 10 ; if ( abs ( digit@@ 2 - digit@@ 1 ) > 1 ) return false ; num = num / 10 ; } return true ; }
CEI@@ LING_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY_@@ 1 | int ceil@@ Search ( int arr [ ] , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceil@@ Search ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceil@@ Search ( arr , low , mid - 1 , x ) ; } }
GI@@ V@@ EN_@@ P_@@ AND_@@ N_@@ FIND_@@ THE_@@ LAR@@ GE@@ ST_@@ X@@ _SU@@ CH_@@ TH@@ AT_@@ P@@ X_@@ DI@@ VIDE@@ S_@@ N_@@ 2 | int lar@@ gest@@ Power ( int n , int p ) { int x = 0 ; while ( n ) { n /= p ; x += n ; } return x ; }
MAX@@ IM@@ UM@@ _S@@ UM_@@ I@@ AR@@ RI@@ _@@ AM@@ ONG_@@ ROTA@@ TIONS_@@ GI@@ V@@ EN_@@ ARRAY | int max@@ Sum ( int arr [ ] , int n ) { int res = INT_@@ MIN ; for ( int i = 0 ; i < n ; i ++ ) { int curr_@@ sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_@@ sum += j * arr [ index ] ; } res = max ( res , curr_@@ sum ) ; } return res ; }
MINIMUM_@@ LENGTH@@ _SUB@@ ARRA@@ Y_S@@ UM_@@ GREATER_@@ GI@@ V@@ EN_@@ VALUE_@@ 1 | int smalle@@ st@@ Sub@@ With@@ Sum ( int arr [ ] , int n , int x ) { int curr_@@ sum = 0 , min_@@ len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_@@ sum <= x && end < n ) { if ( curr_@@ sum <= 0 && x > 0 ) { start = end ; curr_@@ sum = 0 ; } curr_@@ sum += arr [ end ++ ] ; } while ( curr_@@ sum > x && start < n ) { if ( end - start < min_@@ len ) min_@@ len = end - start ; curr_@@ sum -= arr [ start ++ ] ; } } return min_@@ len ; }
LE@@ XI@@ CO@@ GRAPHIC@@ AL@@ LY@@ _S@@ MAL@@ LE@@ ST_@@ STRING_@@ WHO@@ SE_@@ HAM@@ M@@ ING_@@ DISTAN@@ CE_@@ GI@@ V@@ EN_@@ STRING_@@ EXAC@@ TL@@ Y_@@ K | void find@@ String ( string str , int n , int k ) { if ( k == 0 ) { cout << str << endl ; return ; } string str2 = str ; int p = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str2 [ i ] != ' a ' ) { str2 [ i ] = ' a ' ; p ++ ; if ( p == k ) break ; } } if ( p < k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) if ( str [ i ] == ' a ' ) { str2 [ i ] = ' b ' ; p ++ ; if ( p == k ) break ; } } cout << str2 << endl ; }
SUB@@ SET_@@ S@@ UM_@@ DI@@ VISI@@ BLE_@@ M | bool mod@@ ular@@ Sum ( int arr [ ] , int n , int m ) { if ( n > m ) return true ; bool DP [ m ] ; memset ( DP , false , m ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; bool temp [ m ] ; memset ( temp , false , m ) ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }
FIN@@ D_S@@ UM_@@ EV@@ EN_@@ INDEX_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENTS_@@ 1 | int even@@ bin@@ omi@@ al@@ Coeff@@ Sum ( int n ) { return ( 1 << ( n - 1 ) ) ; }
EV@@ EN_@@ FI@@ BON@@ ACC@@ I_@@ NUMBER@@ S_S@@ UM | int even@@ Fi@@ b@@ Sum ( int limit ) { if ( limit < 2 ) return 0 ; long long int ef@@ 1 = 0 , ef@@ 2 = 2 ; long long int sum = ef@@ 1 + ef@@ 2 ; while ( ef@@ 2 <= limit ) { long long int ef@@ 3 = 4 * ef@@ 2 + ef@@ 1 ; if ( ef@@ 3 > limit ) break ; ef@@ 1 = ef@@ 2 ; ef@@ 2 = ef@@ 3 ; sum += ef@@ 2 ; } return sum ; }
MA@@ KING_@@ ELEMEN@@ TS_@@ OF_@@ TWO_@@ ARRAY@@ S_S@@ AME_@@ WITH_@@ MINIMUM_@@ INCRE@@ MENT@@ DECRE@@ MENT | int Min@@ Operation ( int a [ ] , int b [ ] , int n ) { sort ( a , a + n ) ; sort ( b , b + n ) ; int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { result = result + abs ( a [ i ] - b [ i ] ) ; } return result ; }
REQUIRED_@@ MINIMUM_@@ DIG@@ IT@@ S_@@ REMOVE_@@ NUMBER_@@ MAKE_@@ PER@@ F@@ ECT_@@ SQUARE | int perfec@@ t@@ Square ( string s ) { int n = s . size ( ) ; int ans = - 1 ; string num ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { string str = " " ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i >> j ) & 1 ) { str += s [ j ] ; } } if ( str [ 0 ] != '0' ) { int temp = 0 ; for ( int j = 0 ; j < str . size ( ) ; j ++ ) temp = temp * 10 + ( int ) ( str [ j ] - '0' ) ; int k = sqrt ( temp ) ; if ( k * k == temp ) { if ( ans < ( int ) str . size ( ) ) { ans = ( int ) str . size ( ) ; num = str ; } } } } if ( ans == - 1 ) return ans ; else { cout << num << " ▁ " ; return n - ans ; } }
COUNT_@@ WOR@@ DS_@@ AP@@ PE@@ AR_@@ EXAC@@ TL@@ Y_@@ TWO_@@ TIME@@ S_@@ ARRAY_@@ WORDS | int count@@ Words ( string str [ ] , int n ) { unordered_map < string , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ str [ i ] ] += 1 ; int res = 0 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) if ( ( it -> second == 2 ) ) res ++ ; return res ; }
COUNT_@@ SET_@@ BITS_@@ IN_@@ AN_@@ INTEGER_@@ 4 | unsigned int count@@ Set@@ Bits@@ Rec ( unsigned int num ) { int ni@@ bble = 0 ; if ( 0 == num ) return num_@@ to_@@ bits [ 0 ] ; ni@@ bble = num & 0xf ; return num_@@ to_@@ bits [ ni@@ bble ] + count@@ Set@@ Bits@@ Rec ( num >> 4 ) ; }
MAXIMUM_@@ WEIGHT_@@ PATH_@@ END@@ ING_@@ ELEMENT_@@ LAST_@@ ROW_@@ MATRIX | int max@@ Cost ( int mat [ ] [ MAX ] , int N ) { int dp [ N ] [ N ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }
PER@@ F@@ ECT_@@ RE@@ VERSI@@ BLE_@@ STRING | bool is@@ Rever@@ sible ( string str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; }
FIN@@ D_S@@ UM_@@ OD@@ D_@@ FAC@@ TOR@@ S_@@ NUMBER | int su@@ mo@@ fo@@ dd@@ Factors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 , curr_@@ sum = 1 ; int curr_@@ term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_@@ term *= i ; curr_@@ sum += curr_@@ term ; } res *= curr_@@ sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
MAX@@ IM@@ UM@@ _S@@ UM_@@ PATH_@@ MATRIX_@@ TOP_@@ BOTTOM | int max@@ Sum ( int mat [ SIZE ] [ SIZE ] , int n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; int dp [ n ] [ n ] ; int max@@ Sum = INT_@@ MIN , max ; for ( int j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { max = INT_@@ MIN ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( int j = 0 ; j < n ; j ++ ) if ( max@@ Sum < dp [ 0 ] [ j ] ) max@@ Sum = dp [ 0 ] [ j ] ; return max@@ Sum ; }
COUNT_@@ DIG@@ IT@@ S_@@ FAC@@ TOR@@ I@@ AL@@ _SET_@@ 1 | int find@@ Digits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += log10 ( i ) ; return floor ( digits ) + 1 ; }
FIND_@@ UN@@ COMMON_@@ CHARAC@@ TER@@ S_@@ TWO_@@ STRINGS | void find@@ And@@ Print@@ Un@@ common@@ Chars ( string str1 , string str2 ) { int present [ MAX_@@ CHAR ] ; for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) present [ i ] = 0 ; int l1 = str1 . size ( ) ; int l2 = str2 . size ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) present [ str1 [ i ] - ' a ' ] = 1 ; for ( int i = 0 ; i < l2 ; i ++ ) { if ( present [ str2 [ i ] - ' a ' ] == 1 || present [ str2 [ i ] - ' a ' ] == - 1 ) present [ str2 [ i ] - ' a ' ] = - 1 ; else present [ str2 [ i ] - ' a ' ] = 2 ; } for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) if ( present [ i ] == 1 || present [ i ] == 2 ) cout << ( char ( i + ' a ' ) ) << " ▁ " ; }
SQU@@ ARE_@@ ROOT_@@ OF_@@ AN_@@ INTEGER_@@ 1 | int floor@@ Sqrt ( int x ) { if ( x == 0 || x == 1 ) return x ; int start = 1 , end = x , ans ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( mid * mid == x ) return mid ; if ( mid * mid < x ) { start = mid + 1 ; ans = mid ; } else end = mid - 1 ; } return ans ; }
CHECK_@@ POSSI@@ BLE_@@ PATH_@@ 2D_@@ MATRIX | bool is@@ Path ( int arr [ row ] [ col ] ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < row ; i ++ ) if ( arr [ i ] [ 0 ] != - 1 ) arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] ; for ( int j = 1 ; j < col ; j ++ ) if ( arr [ 0 ] [ j ] != - 1 ) arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] ; for ( int i = 1 ; i < row ; i ++ ) for ( int j = 1 ; j < col ; j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ row - 1 ] [ col - 1 ] == 1 ) ; }
NEW@@ MAN_@@ CON@@ WAY@@ _SEQU@@ ENCE_@@ 1 | int sequence ( int n ) { int f [ n + 1 ] ; int i ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; return f [ n ] ; }
PRINT_@@ WOR@@ DS_@@ STRING_@@ REVERSE_@@ ORDER | string word@@ Reverse ( string str ) { int i = str . length ( ) - 1 ; int start , end = i + 1 ; string result = " " ; while ( i >= 0 ) { if ( str [ i ] == ' ▁ ' ) { start = i + 1 ; while ( start != end ) result += str [ start ++ ] ; result += ' ▁ ' ; end = i ; } i -- ; } start = 0 ; while ( start != end ) result += str [ start ++ ] ; return result ; }
FIND_@@ NUMBER_@@ END@@ LESS_@@ POINTS | int count@@ End@@ less ( bool input [ ] [ MAX ] , int n ) { bool row [ n ] [ n ] , col [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { bool is@@ End@@ less = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( input [ i ] [ j ] == 0 ) is@@ End@@ less = 0 ; col [ i ] [ j ] = is@@ End@@ less ; } } for ( int i = 0 ; i < n ; i ++ ) { bool is@@ End@@ less = 1 ; for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( input [ i ] [ j ] == 0 ) is@@ End@@ less = 0 ; row [ i ] [ j ] = is@@ End@@ less ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ; return ans ; }
CHECK_@@ POSSI@@ BLE_@@ TRANSFORM_@@ ONE_@@ STRING_@@ AN@@ OTHER | bool check ( string s1 , string s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; bool dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = false ; } } dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { for ( int j = 0 ; j <= s2 . length ( ) ; j ++ ) { if ( dp [ i ] [ j ] ) { if ( j < s2 . length ( ) && ( toupper ( s1 [ i ] ) == s2 [ j ] ) ) dp [ i + 1 ] [ j + 1 ] = true ; if ( ! is@@ upper ( s1 [ i ] ) ) dp [ i + 1 ] [ j ] = true ; } } } return ( dp [ n ] [ m ] ) ; }
CAL@@ CUL@@ ATE_@@ VOLUME_@@ DO@@ DE@@ CA@@ HE@@ DRO@@ N | double vol_@@ of_@@ do@@ deca@@ hedron ( int side ) { return ( ( ( 15 + ( 7 * ( sqrt ( 5 ) ) ) ) / 4 ) * ( pow ( side , 3 ) ) ) ; }
PROGRAM_@@ FIND_@@ RE@@ MA@@ INDE@@ R_@@ LARGE_@@ NUMBER_@@ DI@@ VIDE@@ D_@@ 11 | int remainder ( string str ) { int len = str . length ( ) ; int num , rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str [ i ] - '0' ) ; rem = num % 11 ; } return rem ; }
SORT_@@ STRING_@@ CHARAC@@ TERS | void sort@@ String ( string & str ) { sort ( str . begin ( ) , str . end ( ) ) ; cout << str ; }
B@@ IR@@ TH@@ DAY_@@ PAR@@ ADO@@ X | int find ( double p ) { return ceil ( sqrt ( 2 * 365 * log ( 1 / ( 1 - p ) ) ) ) ; }
CHECK_@@ LINE_@@ PAS@@ SES_@@ ORIGIN | bool check@@ Origin ( int x1 , int y1 , int x2 , int y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; }
FIND_@@ ELEMEN@@ TS_@@ ARRAY_@@ LEA@@ ST_@@ TWO_@@ GREATER_@@ ELEMEN@@ TS_@@ 2 | void find@@ Elements ( int arr [ ] , int n ) { int first = INT_@@ MIN , second = INT_@@ MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) cout << arr [ i ] << " ▁ " ; }
MIN@@ IM@@ UM@@ _S@@ UM@@ _SUB@@ SEQU@@ ENCE_@@ LEA@@ ST_@@ ONE_@@ EVER@@ Y_@@ FOUR_@@ CON@@ SEC@@ UTI@@ VE_@@ ELEMEN@@ TS_@@ PIC@@ KED_@@ 1 | int min@@ Sum ( int ar [ ] , int n ) { if ( n <= 4 ) return * min_@@ element ( ar , ar + n ) ; int sum [ n ] ; sum [ 0 ] = ar [ 0 ] ; sum [ 1 ] = ar [ 1 ] ; sum [ 2 ] = ar [ 2 ] ; sum [ 3 ] = ar [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) sum [ i ] = ar [ i ] + ( * min_@@ element ( sum + i - 4 , sum + i ) ) ; return * min_@@ element ( sum + n - 4 , sum + n ) ; }
CEI@@ LING_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY | int ceil@@ Search ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }
SW@@ AP_@@ TWO_@@ NUMB@@ ERS_@@ WITH@@ OUT_@@ USING_@@ TEMPOR@@ ARY_@@ VARIABLE_@@ 1 | void swap ( int * xp , int * yp ) { if ( xp == yp ) return ; * xp = * xp + * yp ; * yp = * xp - * yp ; * xp = * xp - * yp ; }
MINIMUM_@@ NUMBER_OF_@@ MAN@@ IP@@ UL@@ ATION@@ S_@@ REQUIRED_@@ TO_@@ MAKE_@@ TWO_@@ STRING@@ S_@@ AN@@ AG@@ RAM_@@ WITH@@ OUT_@@ DELE@@ TION_@@ OF_@@ CHARACTER | int count@@ Manip@@ ul@@ ations ( string s1 , string s2 ) { int count = 0 ; int char@@ _count [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { char@@ _count [ i ] = 0 ; } for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) char@@ _count [ s1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { char@@ _count [ s2 [ i ] - ' a ' ] -- ; if ( char@@ _count [ s2 [ i ] - ' a ' ] < 0 ) count ++ ; } return count ; }
CHECK_@@ IF_@@ ALL_@@ THE_@@ ELEMEN@@ TS_@@ CAN_@@ BE_@@ MA@@ DE_@@ OF@@ _S@@ AME_@@ PAR@@ ITY_@@ BY_@@ INVER@@ TING_@@ AD@@ J@@ AC@@ ENT_@@ ELEMENTS | bool fli@@ ps@@ Possible ( int a [ ] , int n ) { int count_@@ odd = 0 , count_@@ even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] & 1 ) count_@@ odd ++ ; else count_@@ even ++ ; } if ( count_@@ odd % 2 && count_@@ even % 2 ) return false ; else return true ; }
CONVERT_@@ SUB@@ STRING@@ S_@@ LENGTH_@@ K_@@ BASE_@@ B_@@ DECIMAL | int sub@@ string@@ Conversions ( string str , int k , int b ) { for ( int i = 0 ; i + k <= str . size ( ) ; i ++ ) { string sub = str . substr ( i , k ) ; int sum = 0 , counter = 0 ; for ( int i = sub . size ( ) - 1 ; i >= 0 ; i -- ) { sum = sum + ( ( sub . at ( i ) - '0' ) * pow ( b , counter ) ) ; counter ++ ; } cout << sum << " ▁ " ; } }
FIND_@@ K@@ _SU@@ CH_@@ TH@@ AT_@@ ALL_@@ ELEMEN@@ TS_@@ IN_@@ K@@ TH_@@ ROW_@@ ARE_@@ 0_@@ AND_@@ K@@ TH_@@ COLUMN_@@ ARE_@@ 1_@@ IN_@@ A_@@ BOOLEAN_@@ MATRIX | int find ( bool arr [ n ] [ n ] ) { int i = 0 , j = n - 1 ; int res = - 1 ; while ( i < n && j >= 0 ) { if ( arr [ i ] [ j ] == 0 ) { while ( j >= 0 && ( arr [ i ] [ j ] == 0 || i == j ) ) j -- ; if ( j == - 1 ) { res = i ; break ; } else i ++ ; } else { while ( i < n && ( arr [ i ] [ j ] == 1 || i == j ) ) i ++ ; if ( i == n ) { res = j ; break ; } else j -- ; } } if ( res == - 1 ) return res ; for ( int i = 0 ; i < n ; i ++ ) if ( res != i && arr [ i ] [ res ] != 1 ) return - 1 ; for ( int j = 0 ; j < n ; j ++ ) if ( res != j && arr [ res ] [ j ] != 0 ) return - 1 ; return res ; }
NUMBER_@@ ORDE@@ RED_@@ PAIR@@ S_@@ AI_@@ A@@ J@@ _0 | int count@@ Pairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( a [ i ] & a [ j ] ) == 0 ) count += 2 ; } return count ; }
CI@@ R@@ CLE_@@ LAT@@ TIC@@ E_@@ POINTS | int count@@ Lat@@ tice ( int r ) { if ( r <= 0 ) return 0 ; int result = 4 ; for ( int x = 1 ; x < r ; x ++ ) { int y@@ Square = r * r - x * x ; int y = sqrt ( y@@ Square ) ; if ( y * y == y@@ Square ) result += 4 ; } return result ; }
MINIMUM_@@ CHARAC@@ TER@@ S_@@ AD@@ DED_@@ FRONT_@@ MAKE_@@ STRING_@@ PA@@ LIN@@ DRO@@ ME | bool isp@@ al@@ ind@@ ro@@ me ( string s ) { int l = s . length ( ) ; int j ; for ( int i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s [ i ] != s [ j ] ) return false ; } return true ; }
K_@@ TH_@@ MISSING_@@ ELEMENT_@@ INCRE@@ AS@@ ING@@ _SEQU@@ ENCE_@@ NOT_@@ PRES@@ ENT_@@ GI@@ VEN@@ _SEQU@@ ENCE | int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) { unordered_@@ set < int > s ; for ( int i = 0 ; i < n2 ; i ++ ) s . insert ( b [ i ] ) ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( s . find ( a [ i ] ) == s . end ( ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return - 1 ; }
PROGRAM_@@ CHECK_@@ IS@@ BN | bool isValid@@ IS@@ BN ( string & is@@ bn ) { int n = is@@ bn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = is@@ bn [ i ] - '0' ; if ( 0 > digit || 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = is@@ bn [ 9 ] ; if ( last != ' X ' && ( last < '0' || last > '9' ) ) return false ; sum += ( ( last == ' X ' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; }
COUNT_@@ WAY@@ S_@@ INCRE@@ ASE_@@ LC@@ S_@@ LENGTH_@@ TWO_@@ STRING@@ S_@@ ONE | int way@@ sTo@@ Increase@@ L@@ CS@@ By@@ 1 ( string str1 , string str2 ) { int m = str1 . length ( ) , n = str2 . length ( ) ; vector < int > position [ M ] ; for ( int i = 1 ; i <= n ; i ++ ) position [ toInt ( str2 [ i - 1 ] ) ] . push_back ( i ) ; int l@@ cs@@ l [ m + 2 ] [ n + 2 ] ; int l@@ csr [ m + 2 ] [ n + 2 ] ; for ( int i = 0 ; i <= m + 1 ; i ++ ) for ( int j = 0 ; j <= n + 1 ; j ++ ) l@@ cs@@ l [ i ] [ j ] = l@@ csr [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) l@@ cs@@ l [ i ] [ j ] = 1 + l@@ cs@@ l [ i - 1 ] [ j - 1 ] ; else l@@ cs@@ l [ i ] [ j ] = max ( l@@ cs@@ l [ i - 1 ] [ j ] , l@@ cs@@ l [ i ] [ j - 1 ] ) ; } } for ( int i = m ; i >= 1 ; i -- ) { for ( int j = n ; j >= 1 ; j -- ) { if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) l@@ csr [ i ] [ j ] = 1 + l@@ csr [ i + 1 ] [ j + 1 ] ; else l@@ csr [ i ] [ j ] = max ( l@@ csr [ i + 1 ] [ j ] , l@@ csr [ i ] [ j + 1 ] ) ; } } int ways = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( char c = ' a ' ; c <= ' z ' ; c ++ ) { for ( int j = 0 ; j < position [ toInt ( c ) ] . size ( ) ; j ++ ) { int p = position [ toInt ( c ) ] [ j ] ; if ( l@@ cs@@ l [ i ] [ p - 1 ] + l@@ csr [ i + 1 ] [ p + 1 ] == l@@ cs@@ l [ m ] [ n ] ) ways ++ ; } } } return ways ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 11_@@ EG@@ G_@@ DRO@@ PP@@ ING_@@ PU@@ ZZ@@ LE_@@ 1 | int egg@@ Drop ( int n , int k ) { int egg@@ Floor [ n + 1 ] [ k + 1 ] ; int res ; int i , j , x ; for ( i = 1 ; i <= n ; i ++ ) { egg@@ Floor [ i ] [ 1 ] = 1 ; egg@@ Floor [ i ] [ 0 ] = 0 ; } for ( j = 1 ; j <= k ; j ++ ) egg@@ Floor [ 1 ] [ j ] = j ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { egg@@ Floor [ i ] [ j ] = INT_MAX ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( egg@@ Floor [ i - 1 ] [ x - 1 ] , egg@@ Floor [ i ] [ j - x ] ) ; if ( res < egg@@ Floor [ i ] [ j ] ) egg@@ Floor [ i ] [ j ] = res ; } } } return egg@@ Floor [ n ] [ k ] ; }
WAY@@ S_TO_@@ WRITE_@@ N_@@ AS@@ _S@@ UM_@@ OF_@@ TWO_@@ OR_@@ MORE_@@ POSITIVE_@@ INTEG@@ ERS | int count@@ W@@ ays ( int n ) { int table [ n + 1 ] ; memset ( table , 0 , sizeof ( table ) ) ; table [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) table [ j ] += table [ j - i ] ; return table [ n ] ; }
PROGR@@ AM@@ _S@@ UM_@@ COS@@ X@@ _SERI@@ ES | double cos@@ X@@ Ser@@ ties@@ Sum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }
UNI@@ QUE_@@ CEL@@ LS_@@ BINARY_@@ MATRIX | int count@@ Unique ( int mat [ ] [ MAX ] , int n , int m ) { int row@@ sum [ n ] , col@@ sum [ m ] ; memset ( col@@ sum , 0 , sizeof ( col@@ sum ) ) ; memset ( row@@ sum , 0 , sizeof ( row@@ sum ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] ) { row@@ sum [ i ] ++ ; col@@ sum [ j ] ++ ; } int unique@@ count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] && row@@ sum [ i ] == 1 && col@@ sum [ j ] == 1 ) unique@@ count ++ ; return unique@@ count ; }
GRE@@ ED@@ Y_@@ ALGORITH@@ M_@@ TO_@@ FIND_@@ MINIMUM_@@ NUMBER_OF_@@ CO@@ INS | void find@@ Min ( int V ) { vector < int > ans ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( V >= den@@ o [ i ] ) { V -= den@@ o [ i ] ; ans . push_back ( den@@ o [ i ] ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) cout << ans [ i ] << " ▁ ▁ " ; }
CHECK_@@ INTEGER_@@ OVERFLOW_@@ MULTIP@@ LIC@@ ATION | bool is@@ Overflow ( long long a , long long b ) { if ( a == 0 || b == 0 ) return false ; long long result = a * b ; if ( a == result / b ) return false ; else return true ; }
DIFF@@ ER@@ ENCE_@@ BETWE@@ EN_@@ HIGH@@ EST_@@ AND_@@ LEA@@ ST_@@ FREQU@@ ENCI@@ ES_@@ IN_@@ AN_@@ ARRAY_@@ 1 | int find@@ Diff ( int arr [ ] , int n ) { unordered_map < int , int > hm ; for ( int i = 0 ; i < n ; i ++ ) hm [ arr [ i ] ] ++ ; int max_@@ count = 0 , min_@@ count = n ; for ( auto x : hm ) { max_@@ count = max ( max_@@ count , x . second ) ; min_@@ count = min ( min_@@ count , x . second ) ; } return ( max_@@ count - min_@@ count ) ; }
COMPOSI@@ TE_@@ NUMBER | bool is@@ Composite ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 || n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }
LAR@@ GE@@ ST_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQU@@ ENCE_@@ OF_@@ CON@@ SEC@@ UTI@@ VE_@@ INTEG@@ ERS | int find@@ LI@@ S ( int A [ ] , int n ) { unordered_map < int , int > hash ; int LI@@ S_@@ size = 1 ; int LI@@ S_@@ index = 0 ; hash [ A [ 0 ] ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1 ; if ( LI@@ S_@@ size < hash [ A [ i ] ] ) { LI@@ S_@@ size = hash [ A [ i ] ] ; LI@@ S_@@ index = A [ i ] ; } } cout << " LI@@ S _ size ▁ = ▁ " << LI@@ S_@@ size << " \n " ; cout << " LI@@ S ▁ : ▁ " ; int start = LI@@ S_@@ index - LI@@ S_@@ size + 1 ; while ( start <= LI@@ S_@@ index ) { cout << start << " ▁ " ; start ++ ; } }
COUNT_@@ SET_@@ BITS_@@ IN_@@ AN_@@ INTEGER_@@ 2 | public : unsigned int count@@ Set@@ Bits ( int n ) { unsigned int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
FIND_@@ FOUR_@@ ELEMEN@@ TS_@@ A_@@ B_@@ C_@@ AND_@@ D_@@ IN_@@ AN_@@ ARRAY@@ _SU@@ CH_@@ TH@@ AT_@@ AB_@@ CD | bool find@@ Pairs ( int arr [ ] , int n ) { map < int , pair < int , int > > Hash ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int sum = arr [ i ] + arr [ j ] ; if ( Hash . find ( sum ) == Hash . end ( ) ) Hash [ sum ] = make_pair ( i , j ) ; else { pair < int , int > pp = Hash [ sum ] ; cout << " ( " << arr [ pp . first ] << " , ▁ " << arr [ pp . second ] << " ) ▁ and ▁ ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) n " ; return true ; } } } cout << " No ▁ pairs ▁ found " ; return false ; }
COUNT_@@ OB@@ T@@ USE_@@ ANG@@ LES_@@ CI@@ R@@ CLE_@@ K_@@ EQU@@ ID@@ I@@ STAN@@ T_@@ POINT@@ S_@@ 2_@@ GI@@ V@@ EN_@@ POINTS | int count@@ Ob@@ t@@ use@@ Angles ( int a , int b , int k ) { int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return min ( c1 , c2 ) ; }
NUMBER_@@ TRIANG@@ LES_@@ N_@@ MOVE@@ S_@@ 1 | int numberOf@@ Triangles ( int n ) { int ans = 2 * ( pow ( 3 , n ) ) - 1 ; return ans ; }
FIND_@@ A_@@ REPE@@ ATING_@@ AND_@@ A_@@ MISSING_@@ NUMBER | void print@@ Two@@ Elements ( int arr [ ] , int size ) { int i ; cout << " ▁ The ▁ repe@@ ating ▁ element ▁ is ▁ " ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) - 1 ] > 0 ) arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; else cout << abs ( arr [ i ] ) << " \n " ; } cout << " and ▁ the ▁ missing ▁ element ▁ is ▁ " ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) cout << ( i + 1 ) ; } }
MINIMUM_@@ DIFF@@ ER@@ ENCE_@@ BETWE@@ EN_@@ GROUP@@ S_@@ OF@@ _SIZE_@@ TWO | ll calculate ( ll a [ ] , ll n ) { sort ( a , a + n ) ; vector < ll > s ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . push_back ( a [ i ] + a [ j ] ) ; ll mini = * min_@@ element ( s . begin ( ) , s . end ( ) ) ; ll max@@ i = * max_@@ element ( s . begin ( ) , s . end ( ) ) ; return abs ( max@@ i - mini ) ; }
FIND_@@ PER@@ I@@ ME@@ TER_@@ CY@@ LIN@@ DER | int per@@ imeter ( int diameter , int height ) { return 2 * ( diameter + height ) ; }
MAG@@ ICAL_@@ INDI@@ CES_@@ ARRAY | make_pair push_back int solve ( int A [ ] , int n ) { int i , cnt = 0 , j ; int parent [ n + 1 ] ; int vis [ n + 1 ] ; memset ( parent , - 1 , sizeof ( parent ) ) ; memset ( vis , 0 , sizeof ( vis ) ) ; for ( i = 0 ; i < n ; i ++ ) { j = i ; if ( parent [ j ] == - 1 ) { while ( parent [ j ] == - 1 ) { parent [ j ] = i ; j = ( j + A [ j ] + 1 ) % n ; } if ( parent [ j ] == i ) { while ( ! vis [ j ] ) { vis [ j ] = 1 ; cnt ++ ; j = ( j + A [ j ] + 1 ) % n ; } } } } return cnt ; }
FIND_@@ A_@@ FIXED_@@ POINT_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ 1 | int binary@@ Search ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binary@@ Search ( arr , ( mid + 1 ) , high ) ; else return binary@@ Search ( arr , low , ( mid - 1 ) ) ; } return - 1 ; }
FIN@@ D@@ _SIZE_@@ OF_THE_@@ LAR@@ GE@@ ST_@@ FOR@@ MED_@@ BY_@@ ALL_@@ ONE@@ S_IN_@@ A_@@ BINARY_@@ MATRIX | int find@@ Largest@@ Plus ( int mat [ N ] [ N ] ) { int left [ N ] [ N ] , right [ N ] [ N ] , top [ N ] [ N ] , bottom [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { top [ 0 ] [ i ] = mat [ 0 ] [ i ] ; bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] ; left [ i ] [ 0 ] = mat [ i ] [ 0 ] ; right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ; else left [ i ] [ j ] = 0 ; if ( mat [ j ] [ i ] == 1 ) top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 ; else top [ j ] [ i ] = 0 ; j = N - 1 - j ; if ( mat [ j ] [ i ] == 1 ) bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 ; else bottom [ j ] [ i ] = 0 ; if ( mat [ i ] [ j ] == 1 ) right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 ; else right [ i ] [ j ] = 0 ; j = N - 1 - j ; } } int n = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int len = min ( min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) ; if ( len > n ) n = len ; } } if ( n ) return 4 * ( n - 1 ) + 1 ; return 0 ; }
LEVEL_@@ NODE_@@ TREE_@@ SOURCE_@@ NODE_@@ USING_@@ B@@ FS | void print@@ Levels ( vector < int > graph [ ] , int V , int x ) { int level [ V ] ; bool marked [ V ] ; queue < int > que ; que . push ( x ) ; level [ x ] = 0 ; marked [ x ] = true ; while ( ! que . empty ( ) ) { x = que . front ( ) ; que . pop ( ) ; for ( int i = 0 ; i < graph [ x ] . size ( ) ; i ++ ) { int b = graph [ x ] [ i ] ; if ( ! marked [ b ] ) { que . push ( b ) ; level [ b ] = level [ x ] + 1 ; marked [ b ] = true ; } } } cout << " Nodes " << " ▁ ▁ ▁ ▁ " << " Level " << endl ; for ( int i = 0 ; i < V ; i ++ ) cout << " ▁ " << i << " ▁ ▁ ▁ - - > ▁ ▁ ▁ " << level [ i ] << endl ; }
FIN@@ D_S@@ QU@@ ARE_@@ ROOT_@@ UN@@ DER_@@ MODUL@@ O_@@ P@@ _SET_@@ 1_@@ WH@@ EN_@@ P_@@ IS_@@ IN_@@ FORM_@@ OF_@@ 4@@ I_@@ 3 | void square@@ Root ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) { if ( ( x * x ) % p == n ) { cout << " Square ▁ root ▁ is ▁ " << x ; return ; } } cout << " Square ▁ root ▁ doesn ' t ▁ exist " ; }
CHECK_@@ IF_@@ ARRAY_@@ ELEMEN@@ TS_@@ ARE_@@ CON@@ SEC@@ UTI@@ VE | bool are@@ Con@@ sec@@ utive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int min = get@@ Min ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { bool * visited = ( bool * ) calloc ( n , sizeof ( bool ) ) ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - min ] != false ) return false ; visited [ arr [ i ] - min ] = true ; } return true ; } return false ; }
SM@@ ALLE@@ ST@@ _SUB@@ SET_@@ S@@ UM_@@ GREATER_@@ ELEMENTS | int min@@ Elements ( int arr [ ] , int n ) { int half@@ Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) half@@ Sum = half@@ Sum + arr [ i ] ; half@@ Sum = half@@ Sum / 2 ; sort ( arr , arr + n , greater < int > ( ) ) ; int res = 0 , curr_@@ sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_@@ sum += arr [ i ] ; res ++ ; if ( curr_@@ sum > half@@ Sum ) return res ; } return res ; }
S@@ UM_@@ OF_@@ ALL_@@ ELEMEN@@ TS_@@ UP_@@ TO_@@ N@@ TH_@@ ROW_@@ IN_@@ A_@@ PAS@@ CAL@@ S_@@ TRIANGLE_@@ 1 | long long int calculate@@ Sum ( int n ) { long long int sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
SW@@ AP_@@ TWO_@@ NI@@ BB@@ LES_@@ BYTE | int swap@@ Ni@@ bb@@ les ( int x ) { return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) ; }
CHECK_@@ CHARAC@@ TER@@ S_@@ GI@@ V@@ EN_@@ STRING_@@ CAN_@@ RE@@ AR@@ RANGE@@ D_@@ FORM_@@ PA@@ LIN@@ DRO@@ ME_@@ 1 | bool can@@ Form@@ Pal@@ ind@@ ro@@ me ( string str ) { vector < char > list ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { auto pos = find ( list . begin ( ) , list . end ( ) , str [ i ] ) ; if ( pos != list . end ( ) ) { auto pos@@ i = find ( list . begin ( ) , list . end ( ) , str [ i ] ) ; list . erase ( pos@@ i ) ; } else list . push_back ( str [ i ] ) ; } if ( str . length ( ) % 2 == 0 && list . empty ( ) || ( str . length ( ) % 2 == 1 && list . size ( ) == 1 ) ) return true ; else return false ; }
WAY@@ S@@ _SP@@ LIT_@@ STRING_@@ PARTITION_@@ STAR@@ TS_@@ DISTIN@@ CT_@@ CHARACTER | int count@@ W@@ ays ( string s ) { int count [ 26 ] = { 0 } ; for ( char x : s ) count [ x - ' a ' ] ++ ; count [ s [ 0 ] - ' a ' ] = 1 ; int ans = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; }
ENTR@@ ING@@ ER_@@ NUMBER_@@ 1 | int zig@@ z@@ ag ( int n , int k ) { int dp [ n + 1 ] [ k + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; return dp [ n ] [ k ] ; } int main ( ) { int n = 4 , k = 3 ; cout << zig@@ z@@ ag ( n , k ) << endl ; return 0 ; }
COUNT_@@ PAIR@@ S_@@ DIFF@@ ER@@ ENCE_@@ EQUAL_@@ K | int count@@ Pai@@ rs@@ With@@ Diff@@ K ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }
EXPEC@@ TATION_@@ EXPECTED_@@ VALUE_@@ ARRAY | float calc_@@ Expect@@ ation ( float a [ ] , float n ) { float pr@@ b = ( 1 / n ) ; float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] * pr@@ b ; return sum ; }
GROUP_@@ OC@@ CURR@@ EN@@ CES_@@ CHARAC@@ TER@@ S_@@ AC@@ COR@@ DING_@@ FIRST_@@ AP@@ PE@@ AR@@ ANCE | void print@@ Group@@ ed ( string str ) { int n = str . length ( ) ; int count [ MAX_@@ CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { while ( count [ str [ i ] - ' a ' ] -- ) cout << str [ i ] ; count [ str [ i ] - ' a ' ] = 0 ; } }
MAXIMUM_@@ PATH@@ _S@@ UM_@@ POSITION_@@ JUM@@ PS_@@ DI@@ VISIBILITY_@@ CONDITION | void print@@ Max@@ Sum ( int arr [ ] , int n ) { int dp [ n ] ; memset ( dp , 0 , sizeof dp ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; int max@@ i = 0 ; for ( int j = 1 ; j <= sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > max@@ i ) max@@ i = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > max@@ i && j != 1 ) max@@ i = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += max@@ i ; } for ( int i = 0 ; i < n ; i ++ ) cout << dp [ i ] << " ▁ " ; }
PROGRAM_@@ CIRCUM@@ FER@@ ENCE_@@ PARALLE@@ LOG@@ RAM | float circum@@ ference@@ paralle@@ log@@ ram ( float a , float b ) { return ( ( 2 * a ) + ( 2 * b ) ) ; }
COUNT_@@ POSSI@@ BLE_@@ PATH@@ S_@@ TOP_@@ LEFT_@@ BOTTOM_@@ RIGHT_@@ NX@@ M_@@ MATRIX_@@ 2 | int numberOf@@ Paths ( int m , int n ) { int dp [ n ] = { 1 } ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] += dp [ j - 1 ] ; } } return dp [ n - 1 ] ; }
REMOVE_@@ MINIMUM_@@ NUMBER_@@ CHARAC@@ TER@@ S_@@ TWO_@@ STRING@@ S_@@ BE@@ COM@@ E_@@ AN@@ AG@@ RAM | int rem@@ An@@ agram ( string str1 , string str2 ) { int count@@ 1 [ CHARS ] = { 0 } , count2 [ CHARS ] = { 0 } ; for ( int i = 0 ; str1 [ i ] != ' \0' ; i ++ ) count@@ 1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; str2 [ i ] != ' \0' ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += abs ( count@@ 1 [ i ] - count2 [ i ] ) ; return result ; }
S@@ UM_@@ DI@@ VI@@ SOR@@ S_@@ 1_@@ N_@@ 1 | int di@@ visor@@ Sum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }
FIND_@@ LENGTH_@@ LON@@ GE@@ ST@@ _SUB@@ SEQU@@ ENCE_@@ ONE_@@ STRING@@ _SUB@@ STRING_@@ AN@@ OTHER_@@ STRING | int max@@ Sub@@ sequence@@ Sub@@ string ( char x [ ] , char y [ ] , int n , int m ) { int dp [ MAX ] [ MAX ] ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( x [ j - 1 ] == y [ i - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) ans = max ( ans , dp [ i ] [ n ] ) ; return ans ; }
S@@ UM_@@ FA@@ I_@@ A@@ J_@@ PAIR@@ S_@@ ARRAY_@@ N_@@ INTEG@@ ERS | int sum ( int a [ ] , int n ) { unordered_map < int , int > cnt ; int ans = 0 , pre_@@ sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( i * a [ i ] ) - pre_@@ sum ; pre_@@ sum += a [ i ] ; if ( cnt [ a [ i ] - 1 ] ) ans -= cnt [ a [ i ] - 1 ] ; if ( cnt [ a [ i ] + 1 ] ) ans += cnt [ a [ i ] + 1 ] ; cnt [ a [ i ] ] ++ ; } return ans ; }
BINARY_@@ RE@@ PRESEN@@ TATION_@@ OF_@@ A_@@ GI@@ V@@ EN_@@ NUMBER | void bin ( unsigned n ) { if ( n > 1 ) bin ( n / 2 ) ; cout << n % 2 ; }
KN@@ AP@@ S@@ ACK_@@ PRO@@ BLE@@ M | int kn@@ ap@@ S@@ ack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return kn@@ ap@@ S@@ ack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + kn@@ ap@@ S@@ ack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , kn@@ ap@@ S@@ ack ( W , wt , val , n - 1 ) ) ; }
DOUBLE_@@ FAC@@ TOR@@ I@@ AL_@@ 1 | unsigned int double@@ factorial ( unsigned int n ) { int res = 1 ; for ( int i = n ; i >= 0 ; i = i - 2 ) { if ( i == 0 || i == 1 ) return res ; else res *= i ; } }
COUNT_@@ DIG@@ IT@@ S_@@ FAC@@ TOR@@ I@@ AL@@ _SET_@@ 2 | long long find@@ Digits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( ( n * log10 ( n / M_@@ E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ) ; return floor ( x ) + 1 ; }
DE@@ LAN@@ NO@@ Y_@@ NUMBER_@@ 1 | int de@@ al@@ n@@ no@@ y ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }
FIND_@@ THE_@@ MISSING_@@ NUMBER_@@ 2 | int get@@ Missing@@ No ( int a [ ] , int n ) { int x1 = a [ 0 ] ; int x2 = 1 ; for ( int i = 1 ; i < n ; i ++ ) x1 = x1 ^ a [ i ] ; for ( int i = 2 ; i <= n + 1 ; i ++ ) x2 = x2 ^ i ; return ( x1 ^ x2 ) ; }
FIND_@@ NUMBER_OF_@@ TRIANG@@ LES_@@ POSSI@@ BLE | int find@@ NumberOf@@ Triangles ( int arr [ ] , int n ) { q@@ sort ( arr , n , sizeof ( arr [ 0 ] ) , comp ) ; int count = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { int k = i + 2 ; for ( int j = i + 1 ; j < n ; ++ j ) { while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ k ; if ( k > j ) count += k - j - 1 ; } } return count ; }
NUMBER_@@ TRIANG@@ LES_@@ N_@@ MOV@@ ES | int numberOf@@ Triangles ( int n ) { int answer [ n + 1 ] = { 0 } ; answer [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) answer [ i ] = answer [ i - 1 ] * 3 + 2 ; return answer [ n ] ; }
CHECK@@ _S@@ UM@@ S_@@ TH_@@ ROW_@@ TH_@@ COLUMN_@@ MATRIX | bool are@@ Sum@@ Same ( int a [ ] [ MAX ] , int n , int m ) { int sum@@ 1 = 0 , sum@@ 2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum@@ 1 = 0 , sum@@ 2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum@@ 1 += a [ i ] [ j ] ; sum@@ 2 += a [ j ] [ i ] ; } if ( sum@@ 1 == sum@@ 2 ) return true ; } return false ; }
WRITE_@@ ONE_@@ LINE_@@ C_@@ FUNCTION_@@ TO_@@ FIND_@@ WHE@@ THER_@@ A_@@ NO_@@ IS_@@ POWER_@@ OF_@@ TWO | bool is@@ PowerOf@@ Two ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n / 2 ; } return 1 ; }
PUT_@@ SPAC@@ ES_@@ WOR@@ DS_@@ START@@ ING_@@ CAPI@@ TAL_@@ LET@@ TERS | void am@@ end@@ Sentence ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { str [ i ] = str [ i ] + 32 ; if ( i != 0 ) cout << " ▁ " ; cout << str [ i ] ; } else cout << str [ i ] ; } }
CHECK_@@ DI@@ VISIBILITY_@@ BINARY_@@ STRING_@@ 2@@ K | bool is@@ Di@@ visible ( char str [ ] , int k ) { int n = strlen ( str ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == '0' ) c ++ ; return ( c == k ) ; }
SUB@@ SEQU@@ EN@@ CE@@ S@@ _SIZE_@@ THRE@@ E_@@ ARRAY_@@ WHO@@ SE_@@ S@@ UM_@@ DI@@ VISI@@ BLE_@@ M | int co@@ ut@@ Sub@@ Seq ( int A [ ] , int N , int M ) { int sum = 0 ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; }
LON@@ GE@@ ST_@@ CON@@ SEC@@ UTI@@ VE_@@ SUB@@ SEQUENCE | int find@@ Lon@@ gest@@ Con@@ seq@@ Sub@@ seq ( int arr [ ] , int n ) { unordered_@@ set < int > S ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) S . insert ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( S . find ( arr [ i ] - 1 ) == S . end ( ) ) { int j = arr [ i ] ; while ( S . find ( j ) != S . end ( ) ) j ++ ; ans = max ( ans , j - arr [ i ] ) ; } } return ans ; }
FIND_@@ INDEX_@@ GI@@ V@@ EN_@@ FI@@ BON@@ ACC@@ I_@@ NUMBER_@@ CONSTANT_@@ TIME_@@ 1 | int find@@ Index ( int n ) { float fi@@ bo = 2.@@ 07@@ 808@@ 7 * log ( n ) + 1.@@ 67@@ 22@@ 76 ; return round ( fi@@ bo ) ; }
LAR@@ GE@@ ST_@@ DI@@ VISI@@ BLE_@@ PAIR@@ S@@ _SUB@@ SET | int lar@@ gest@@ Subset ( int a [ ] , int n ) { sort ( a , a + n ) ; int dp [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mx@@ m = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] == 0 ) mx@@ m = max ( mx@@ m , dp [ j ] ) ; dp [ i ] = 1 + mx@@ m ; } return * max_@@ element ( dp , dp + n ) ; }
FIND_@@ WHE@@ THER_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ IS_@@ A_@@ POWER_@@ OF_@@ 4_@@ OR_@@ NOT_@@ 2 | bool is@@ PowerOf@@ Four ( unsigned int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0x@@ AAAA@@ AAAA ) ; }
COMP@@ UTE_@@ NC@@ R_@@ P@@ _SET_@@ 1_@@ INTRO@@ DUC@@ TION_@@ AND_@@ DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G_S@@ OL@@ U@@ TION | int n@@ Cr@@ Mod@@ p ( int n , int r , int p ) { int C [ r + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; }
ROUND_@@ THE_@@ GI@@ V@@ EN_@@ NUMBER_@@ TO_@@ NEARE@@ ST_@@ MULTIPLE_@@ OF_@@ 10 | int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; }
SORT_@@ EV@@ EN_@@ NUMB@@ ERS_@@ ASC@@ END@@ ING_@@ ORDER@@ _S@@ ORT_@@ OD@@ D_@@ NUMB@@ ERS_@@ DESC@@ END@@ ING_@@ ORDER_@@ 1 | void two@@ Way@@ Sort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; }
POINT_@@ CLI@@ PP@@ ING_@@ ALGORITH@@ M_@@ COMP@@ UT@@ ER_@@ GRAPHIC@@ S | void point@@ Clip ( int XY [ ] [ 2 ] , int n , int X@@ min , int Y@@ min , int X@@ max , int Y@@ max ) { cout << " Point ▁ inside ▁ the ▁ view@@ ing ▁ pane : " << endl ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( XY [ i ] [ 0 ] >= X@@ min ) && ( XY [ i ] [ 0 ] <= X@@ max ) ) { if ( ( XY [ i ] [ 1 ] >= Y@@ min ) && ( XY [ i ] [ 1 ] <= Y@@ max ) ) cout << " [ " << XY [ i ] [ 0 ] << " , " << XY [ i ] [ 1 ] << " ] ▁ " ; } } cout << " \n " << endl ; cout << " Point ▁ outside ▁ the ▁ view@@ ing ▁ pane : " << endl ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( XY [ i ] [ 0 ] < X@@ min ) || ( XY [ i ] [ 0 ] > X@@ max ) ) cout << " [ " << XY [ i ] [ 0 ] << " , " << XY [ i ] [ 1 ] << " ] ▁ " ; if ( ( XY [ i ] [ 1 ] < Y@@ min ) || ( XY [ i ] [ 1 ] > Y@@ max ) ) cout << " [ " << XY [ i ] [ 0 ] << " , " << XY [ i ] [ 1 ] << " ] ▁ " ; } }
WAY@@ S_@@ TRANS@@ FORM@@ ING_@@ ONE_@@ STRING_@@ REMO@@ V@@ ING_@@ 0_@@ CHARAC@@ TERS | int count@@ Transformation ( string a , string b ) { int n = a . size ( ) , m = b . size ( ) ; if ( m == 0 ) return 1 ; int dp [ m + 1 ] [ n + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( i == 0 ) { if ( j == 0 ) dp [ i ] [ j ] = ( a [ j ] == b [ i ] ) ? 1 : 0 ; else if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } else { if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } } return dp [ m - 1 ] [ n - 1 ] ; }
FIND_@@ RELATIVE_@@ COMPLE@@ MENT_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S | void relative@@ Comp@@ lement ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( ar@@ r1 [ i ] < ar@@ r2 [ j ] ) { cout << ar@@ r1 [ i ] << " ▁ " ; i ++ ; } else if ( ar@@ r1 [ i ] > ar@@ r2 [ j ] ) { j ++ ; } else if ( ar@@ r1 [ i ] == ar@@ r2 [ j ] ) { i ++ ; j ++ ; } } while ( i < n ) cout << ar@@ r1 [ i ] << " ▁ " ; }
COUNT_@@ INDEX_@@ PAIR@@ S_@@ EQUAL_@@ ELEMEN@@ TS_@@ ARRAY | int count@@ Pairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; }
GI@@ V@@ EN_@@ AN_@@ ARRAY_@@ OF_@@ PAIR@@ S_@@ FIND_@@ ALL_@@ SYM@@ METRIC_@@ PAIR@@ S_IN_@@ IT | void find@@ Sym@@ Pairs ( int arr [ ] [ 2 ] , int row ) { unordered_map < int , int > h@@ M ; for ( int i = 0 ; i < row ; i ++ ) { int first = arr [ i ] [ 0 ] ; int sec = arr [ i ] [ 1 ] ; if ( h@@ M . find ( sec ) != h@@ M . end ( ) && h@@ M [ sec ] == first ) cout << " ( " << sec << " , ▁ " << first << " ) " << endl ; else h@@ M [ first ] = sec ; } }
COUNT_@@ SUB@@ SEQU@@ EN@@ CES_@@ PRODUCT_@@ LESS_@@ K | int product@@ Sub@@ Seq@@ Count ( vector < int > & arr , int k ) { int n = arr . size ( ) ; int dp [ k + 1 ] [ n + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; if ( arr [ j - 1 ] <= i && arr [ j - 1 ] > 0 ) dp [ i ] [ j ] += dp [ i / arr [ j - 1 ] ] [ j - 1 ] + 1 ; } } return dp [ k ] [ n ] ; }
RE@@ AR@@ RANGE_@@ ARRAY_@@ AR@@ RI@@ _@@ ARR@@ J_@@ EV@@ EN_@@ AR@@ RI | void re@@ arrange@@ Arr ( int arr [ ] , int n ) { int even@@ Pos = n / 2 ; int odd@@ Pos = n - even@@ Pos ; int temp@@ Arr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) temp@@ Arr [ i ] = arr [ i ] ; sort ( temp@@ Arr , temp@@ Arr + n ) ; int j = odd@@ Pos - 1 ; for ( int i = 0 ; i < n ; i += 2 ) { arr [ i ] = temp@@ Arr [ j ] ; j -- ; } j = odd@@ Pos ; for ( int i = 1 ; i < n ; i += 2 ) { arr [ i ] = temp@@ Arr [ j ] ; j ++ ; } for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
MINIMUM_@@ ROTA@@ TIONS_@@ UN@@ LOCK_@@ CIRC@@ ULAR_@@ LOCK | int min@@ Rotation ( int input , int un@@ lock_@@ code ) { int rotation = 0 ; int input_@@ digit , code_@@ digit ; while ( input || un@@ lock_@@ code ) { input_@@ digit = input % 10 ; code_@@ digit = un@@ lock_@@ code % 10 ; rotation += min ( abs ( input_@@ digit - code_@@ digit ) , 10 - abs ( input_@@ digit - code_@@ digit ) ) ; input /= 10 ; un@@ lock_@@ code /= 10 ; } return rotation ; }
RE@@ AR@@ RANGE_@@ BINARY_@@ STRING_@@ ALTER@@ N@@ ATE_@@ X_@@ Y_@@ OC@@ CURR@@ EN@@ CES | void arrange@@ String ( string str , int x , int y ) { int count_@@ 0 = 0 ; int count_@@ 1 = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) count_@@ 0 ++ ; else count_@@ 1 ++ ; } while ( count_@@ 0 > 0 || count_@@ 1 > 0 ) { for ( int j = 0 ; j < x && count_@@ 0 > 0 ; j ++ ) { if ( count_@@ 0 > 0 ) { cout << "0" ; count_@@ 0 -- ; } } for ( int j = 0 ; j < y && count_@@ 1 > 0 ; j ++ ) { if ( count_@@ 1 > 0 ) { cout << "1" ; count_@@ 1 -- ; } } } }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 14_@@ MAX@@ IM@@ UM@@ _S@@ UM_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQUENCE | int max@@ Sum@@ IS ( int arr [ ] , int n ) { int i , j , max = 0 ; int m@@ sis [ n ] ; for ( i = 0 ; i < n ; i ++ ) m@@ sis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && m@@ sis [ i ] < m@@ sis [ j ] + arr [ i ] ) m@@ sis [ i ] = m@@ sis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < m@@ sis [ i ] ) max = m@@ sis [ i ] ; return max ; }
NUMBER_@@ UNI@@ QUE_@@ REC@@ TA@@ NG@@ LES_@@ FOR@@ MED_@@ USING_@@ N_@@ UNIT_@@ SQU@@ AR@@ ES | int count@@ Rect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= sqrt ( n ) ; ++ length ) for ( int height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }
PROGRAM_@@ TO_@@ PRINT_@@ TE@@ TRA@@ HE@@ DR@@ AL_@@ NUMB@@ ERS_@@ UP@@ TO_@@ N@@ TH_@@ TERM | void print@@ Series ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) / 6 ; cout << num << " ▁ " ; } }
PROGRAM_@@ TO_@@ FIND_@@ TRANSP@@ OS@@ E_@@ OF_@@ A_@@ MATRIX | void transpose ( int A [ ] [ N ] , int B [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; }
PROGRAM_@@ DECIMAL_@@ BINARY_@@ CON@@ VERSION_@@ 1 | int dec@@ To@@ Binary ( int n ) { for ( int i = 31 ; i >= 0 ; i -- ) { int k = n >> i ; if ( k & 1 ) cout << "1" ; else cout << "0" ; } }
RE@@ AR@@ RANGE_@@ ARRAY_@@ ORDER@@ _S@@ MAL@@ LE@@ ST_@@ LAR@@ GE@@ ST_@@ 2@@ N@@ D_S@@ MAL@@ LE@@ ST_@@ 2@@ N@@ D_@@ LAR@@ GE@@ ST | void re@@ arrange@@ Array ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int temp@@ Arr [ n ] ; int Arr@@ Index = 0 ; for ( int i = 0 , j = n - 1 ; i <= n / 2 || j > n / 2 ; i ++ , j -- ) { temp@@ Arr [ Arr@@ Index ] = arr [ i ] ; Arr@@ Index ++ ; temp@@ Arr [ Arr@@ Index ] = arr [ j ] ; Arr@@ Index ++ ; } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp@@ Arr [ i ] ; }
S@@ UM_@@ AREA_@@ REC@@ TA@@ NG@@ LES_@@ POSSI@@ BLE_@@ ARRAY | int Max@@ Total@@ Rectangle@@ Area ( int a [ ] , int n ) { sort ( a , a + n , greater < int > ( ) ) ; int sum = 0 ; bool flag = false ; int len ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ( ! flag ) ) { flag = true ; len = a [ i + 1 ] ; i ++ ; } else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i ++ ; } } return sum ; }
GI@@ V@@ EN_@@ BINARY_@@ STRING_@@ COUNT_@@ NUMBER@@ _SUB@@ STRING@@ S_@@ START_@@ END_@@ 1 | int count@@ Sub@@ Str ( char str [ ] ) { int res = 0 ; for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) { if ( str [ i ] == '1' ) { for ( int j = i + 1 ; str [ j ] != ' \0' ; j ++ ) if ( str [ j ] == '1' ) res ++ ; } } return res ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 3@@ 1_@@ OP@@ TIM@@ AL_@@ STRATEG@@ Y_@@ FOR_@@ A_@@ GAME | int optim@@ al@@ Strategy@@ Of@@ Game ( int * arr , int n ) { int table [ n ] [ n ] ; for ( int gap = 0 ; gap < n ; ++ gap ) { for ( int i = 0 , j = gap ; j < n ; ++ i , ++ j ) { int x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; int y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; int z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }
REPL@@ ACE_@@ CHARACTER_@@ C@@ 1_@@ C@@ 2_@@ C@@ 2_@@ C@@ 1_@@ STRING_@@ S | string replace ( string s , char c1 , char c2 ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == c1 ) s [ i ] = c2 ; else if ( s [ i ] == c2 ) s [ i ] = c1 ; } return s ; }
FIND_@@ THE_@@ LAR@@ GE@@ ST@@ _SUB@@ ARRAY_@@ WITH_@@ 0@@ _S@@ UM@@ _1 | int maxLen ( int arr [ ] , int n ) { unordered_map < int , int > pres@@ um ; int sum = 0 ; int max_len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1 ; if ( sum == 0 ) max_len = i + 1 ; if ( pres@@ um . find ( sum ) != pres@@ um . end ( ) ) { max_len = max ( max_len , i - pres@@ um [ sum ] ) ; } else { pres@@ um [ sum ] = i ; } } return max_len ; }
PROGRAM_@@ PRINT_@@ S@@ UM_@@ GI@@ V@@ EN_@@ N@@ TH_@@ TER@@ M_@@ 1 | int summ@@ ing@@ Series ( long n ) { return pow ( n , 2 ) ; }
RECUR@@ SIVE_@@ C_@@ PROGRAM_@@ LINE@@ AR@@ LY@@ _SEARCH_@@ ELEMENT_@@ GI@@ V@@ EN_@@ ARRAY | int rec@@ Search ( int arr [ ] , int l , int r , int x ) { if ( r < l ) return - 1 ; if ( arr [ l ] == x ) return l ; if ( arr [ r ] == x ) return r ; return rec@@ Search ( arr , l + 1 , r - 1 , x ) ; }
PRINT_@@ SHOR@@ TEST_@@ PATH_@@ PRINT_@@ STRING@@ _S@@ CRE@@ EN | void print@@ Path ( string str ) { int i = 0 ; int cur@@ X = 0 , cur@@ Y = 0 ; while ( i < str . length ( ) ) { int next@@ X = ( str [ i ] - ' A ' ) / 5 ; int next@@ Y = ( str [ i ] - ' B ' + 1 ) % 5 ; while ( cur@@ X > next@@ X ) { cout << " Move ▁ Up " << endl ; cur@@ X -- ; } while ( cur@@ Y > next@@ Y ) { cout << " Move ▁ Left " << endl ; cur@@ Y -- ; } while ( cur@@ X < next@@ X ) { cout << " Move ▁ Down " << endl ; cur@@ X ++ ; } while ( cur@@ Y < next@@ Y ) { cout << " Move ▁ Right " << endl ; cur@@ Y ++ ; } cout << " Press ▁ OK " << endl ; i ++ ; } }
COUNT_@@ EN@@ TRI@@ ES_@@ EQUAL_@@ TO_@@ X_@@ IN_@@ A@@ _SPECI@@ AL_@@ MATRIX | int count ( int n , int x ) { int count == 0 ; for ( int i = 1 ; i <= n && i <= x ; i ++ ) { if ( x / i <= n && x % i == 0 ) count ++ ; } return count ; }
PROGRAM_@@ FIND_@@ LINE_@@ PASS@@ ING_@@ 2_@@ POINTS | pair < double , double > void line@@ From@@ Points ( p@@ dd P , p@@ dd Q ) { double a = Q . second - P . second ; double b = P . first - Q . first ; double c = a * ( P . first ) + b * ( P . second ) ; if ( b < 0 ) { cout << " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ " << a << " x ▁ " << b << " y ▁ = ▁ " << c << endl ; } else { cout << " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ " << a << " x ▁ + ▁ " << b << " y ▁ = ▁ " << c << endl ; } }
REMOVE_@@ ARRAY_@@ END_@@ ELEMENT_@@ MAXI@@ MI@@ ZE_@@ S@@ UM_@@ PRODUCT | int solve ( int dp [ ] [ MAX ] , int a [ ] , int low , int high , int turn ) { if ( low == high ) return a [ low ] * turn ; if ( dp [ low ] [ high ] != 0 ) return dp [ low ] [ high ] ; dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; return dp [ low ] [ high ] ; }
CHECK_@@ GRAP@@ H@@ S_@@ CY@@ CLE_@@ OD@@ D_@@ LENGTH | bool contains@@ Odd ( int G [ ] [ V ] , int src ) { int color@@ Arr [ V ] ; for ( int i = 0 ; i < V ; ++ i ) color@@ Arr [ i ] = - 1 ; color@@ Arr [ src ] = 1 ; queue < int > q ; q . push ( src ) ; while ( ! q . empty ( ) ) { int u = q . front ( ) ; q . pop ( ) ; if ( G [ u ] [ u ] == 1 ) return true ; for ( int v = 0 ; v < V ; ++ v ) { if ( G [ u ] [ v ] && color@@ Arr [ v ] == - 1 ) { color@@ Arr [ v ] = 1 - color@@ Arr [ u ] ; q . push ( v ) ; } else if ( G [ u ] [ v ] && color@@ Arr [ v ] == color@@ Arr [ u ] ) return true ; } } return false ; }
SUM@@ _SERI@@ ES_@@ ALTER@@ N@@ ATE_@@ SIGNE@@ D_S@@ QUAR@@ ES_@@ AP | int se@@ i@@ res@@ Sum ( int n , int a [ ] ) { int res = 0 ; for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }
PROGRAM_@@ DECIMAL_@@ BINARY_@@ CONVERSION | void dec@@ To@@ Binary ( int n ) { int binary@@ Num [ 32 ] ; int i = 0 ; while ( n > 0 ) { binary@@ Num [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) cout << binary@@ Num [ j ] ; }
LON@@ GE@@ ST_@@ ALTER@@ N@@ ATING_@@ POSITIVE_@@ NEGATIVE_@@ SUB@@ ARRAY_@@ START@@ ING_@@ EVER@@ Y_@@ INDEX | void lon@@ gest@@ Altern@@ ating ( int arr [ ] , int n ) { int count [ n ] ; count [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) cout << count [ i ] << " ▁ " ; }
FIND_@@ STRING_@@ LE@@ XI@@ CO@@ GRAP@@ HI@@ C_@@ ORDER_@@ GI@@ V@@ EN_@@ TWO_@@ STRINGS | string lex@@ Next ( string s , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != ' z ' ) { s [ i ] ++ ; return s ; } s [ i ] = ' a ' ; } }
NUMBER_@@ DECIMAL_@@ NUMB@@ ERS_@@ LENGTH_@@ K_@@ STRICT_@@ MON@@ OT@@ ONE | int getNum@@ Strict@@ Mon@@ ot@@ one ( int len ) { int DP [ len ] [ D@@ P_@@ s ] ; memset ( DP , 0 , sizeof ( DP ) ) ; for ( int i = 0 ; i < D@@ P_@@ s ; ++ i ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 1 ; i < len ; ++ i ) for ( int j = 1 ; j < D@@ P_@@ s ; ++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] ; return DP [ len - 1 ] [ D@@ P_@@ s - 1 ] ; }
PRINT_@@ POSSI@@ BLE_@@ ED@@ GE@@ S_@@ TREE_@@ GI@@ V@@ EN_@@ DI@@ AME@@ TER_@@ HEIGHT_@@ VER@@ TIC@@ ES | void construct@@ Tree ( int n , int d , int h ) { if ( d == 1 ) { if ( n == 2 && h == 1 ) { cout << "1 ▁ 2" << endl ; return ; } cout << " - 1" << endl ; return ; } if ( d > 2 * h ) { cout << " - 1" << endl ; return ; } for ( int i = 1 ; i <= h ; i ++ ) cout << i << " ▁ " << i + 1 << endl ; if ( d > h ) { cout << "1" << " ▁ " << h + 2 << endl ; for ( int i = h + 2 ; i <= d ; i ++ ) { cout << i << " ▁ " << i + 1 << endl ; } } for ( int i = d + 1 ; i < n ; i ++ ) { int k = 1 ; if ( d == h ) k = 2 ; cout << k << " ▁ " << i + 1 << endl ; } }
MIN@@ IM@@ AL_@@ OPER@@ ATION@@ S_@@ MAKE_@@ NUMBER_@@ MAG@@ ICAL | int calculate ( string s ) { int ans = 6 ; for ( int i = 0 ; i < 10 ; ++ i ) { for ( int j = 0 ; j < 10 ; ++ j ) { for ( int k = 0 ; k < 10 ; ++ k ) { for ( int l = 0 ; l < 10 ; ++ l ) { for ( int m = 0 ; m < 10 ; ++ m ) { for ( int n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { int c = 0 ; if ( i != s [ 0 ] - '0' ) c ++ ; if ( j != s [ 1 ] - '0' ) c ++ ; if ( k != s [ 2 ] - '0' ) c ++ ; if ( l != s [ 3 ] - '0' ) c ++ ; if ( m != s [ 4 ] - '0' ) c ++ ; if ( n != s [ 5 ] - '0' ) c ++ ; if ( c < ans ) ans = c ; } } } } } } } return ans ; }
FIND_@@ A_@@ TR@@ IP@@ LET_@@ TH@@ AT_@@ S@@ UM_@@ TO_@@ A_@@ GI@@ V@@ EN_@@ VALUE | bool find@@ 3@@ Numbers ( int A [ ] , int arr_@@ size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_@@ size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_@@ size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_@@ size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { cout << " Trip@@ let ▁ is ▁ " << A [ i ] << " , ▁ " << A [ j ] << " , ▁ " << A [ k ] ; return true ; } } } } return false ; }
AREA_@@ OF_THE_@@ CI@@ R@@ CLE_@@ TH@@ AT_@@ HAS_@@ A@@ _S@@ QU@@ ARE_@@ AND_@@ A_@@ CI@@ R@@ CLE_@@ IN@@ SCRI@@ BED_@@ IN_@@ IT | float get@@ Area ( int a ) { float area = ( M_PI * a * a ) / 4.0 ; return area ; }
GI@@ V@@ EN_@@ TWO_@@ UN@@ SOR@@ TED_@@ ARRAY@@ S_@@ FIND_@@ PAIR@@ S_@@ WHO@@ SE_@@ S@@ UM_@@ X_@@ 1 | void find@@ Pairs ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int n , int m , int x ) { unordered_@@ set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( ar@@ r1 [ i ] ) ; for ( int j = 0 ; j < m ; j ++ ) if ( s . find ( x - ar@@ r2 [ j ] ) != s . end ( ) ) cout << x - ar@@ r2 [ j ] << " ▁ " << ar@@ r2 [ j ] << endl ; }
QU@@ IC@@ K_@@ WA@@ Y_@@ CHECK_@@ CHARAC@@ TER@@ S_@@ STRING | bool all@@ Characters@@ Same ( string s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) if ( s [ i ] != s [ 0 ] ) return false ; return true ; }
RE@@ AR@@ RANGE_@@ ARRAY_@@ AR@@ RI | int fix ( int A [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) { if ( A [ i ] != - 1 && A [ i ] != i ) { int x = A [ i ] ; while ( A [ x ] != - 1 && A [ x ] != x ) { int y = A [ x ] ; A [ x ] = x ; x = y ; } A [ x ] = x ; if ( A [ i ] != i ) { A [ i ] = - 1 ; } } } }
PA@@ IR_@@ WITH_@@ GI@@ V@@ EN_@@ PRODUCT_@@ SET_@@ 1_@@ FIND_@@ IF_@@ ANY_@@ PA@@ IR_@@ EXISTS | bool is@@ Product ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; i < n ; i ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; }
SORT_@@ GI@@ V@@ EN_@@ STRING_@@ USING_@@ CHARAC@@ TER@@ _SEARCH | string sort@@ String ( string str , int n ) { string new_@@ str = " " ; for ( int i = ' a ' ; i <= ' z ' ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( str [ j ] == i ) new_@@ str += str [ j ] ; return new_@@ str ; }
COUNT_@@ OF_@@ OC@@ CURR@@ EN@@ CES_@@ OF_@@ A_@@ 101@@ _@@ PATTERN_@@ IN_@@ A_@@ STRING | int count@@ Pattern ( string str ) { int len = str . size ( ) ; bool one@@ Seen = 0 ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '1' && one@@ Seen == 1 ) if ( str [ i - 1 ] == '0' ) count ++ ; if ( str [ i ] == '1' && one@@ Seen == 0 ) { one@@ Seen = 1 ; continue ; } if ( str [ i ] != '0' && str [ i ] != '1' ) one@@ Seen = 0 ; } return count ; }
C_@@ PROGRAM_@@ CY@@ CLIC@@ AL@@ LY_@@ ROTA@@ TE_@@ ARRAY_@@ ONE | void rotate ( int arr [ ] , int n ) { int x = arr [ n - 1 ] , i ; for ( i = n - 1 ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = x ; }
QUEUE_@@ BAS@@ ED_@@ APPRO@@ ACH@@ _@@ FOR_@@ FIRST_@@ NON_@@ REPE@@ ATING_@@ CHARACTER_@@ IN_@@ A_@@ STREAM | void first@@ non@@ repe@@ ating ( char str [ ] ) { queue < char > q ; int char@@ Count [ MAX_@@ CHAR ] = { 0 } ; for ( int i = 0 ; str [ i ] ; i ++ ) { q . push ( str [ i ] ) ; char@@ Count [ str [ i ] - ' a ' ] ++ ; while ( ! q . empty ( ) ) { if ( char@@ Count [ q . front ( ) - ' a ' ] > 1 ) q . pop ( ) ; else { cout << q . front ( ) << " ▁ " ; break ; } } if ( q . empty ( ) ) cout << - 1 << " ▁ " ; } cout << endl ; }
CHECK_@@ LARGE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 6_@@ NOT | bool check ( string str ) { int n = str . length ( ) ; if ( ( str [ n - 1 ] - '0' ) % 2 != 0 ) return false ; int digit@@ Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digit@@ Sum += ( str [ i ] - '0' ) ; return ( digit@@ Sum % 3 == 0 ) ; }
MINIMUM_@@ NUMBER_@@ OF@@ _S@@ QUAR@@ ES_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL@@ S_TO_@@ GI@@ V@@ EN_@@ NUMBER_@@ N | int getMin@@ Squ@@ ares ( unsigned int n ) { if ( sqrt ( n ) - floor ( sqrt ( n ) ) == 0 ) return 1 ; if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = min ( res , 1 + getMin@@ Squ@@ ares ( n - temp ) ) ; } return res ; }
OVER@@ L@@ APP@@ ING_S@@ UM_@@ TWO_@@ ARRAY | int find@@ Sum ( int A [ ] , int B [ ] , int n ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < n ; i ++ ) { hash [ A [ i ] ] ++ ; hash [ B [ i ] ] ++ ; } int sum = 0 ; for ( auto x : hash ) if ( x . second == 1 ) sum += x . first ; return sum ; }
MOBI@@ LE_@@ NUMERIC_@@ KEY@@ PAD_@@ PRO@@ BLE@@ M | int getCount ( char keyp@@ ad [ ] [ 3 ] , int n ) { if ( keyp@@ ad == NULL || n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; int odd [ 10 ] , even [ 10 ] ; int i = 0 , j = 0 , use@@ Odd = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) odd [ i ] = 1 ; for ( j = 2 ; j <= n ; j ++ ) { use@@ Odd = 1 - use@@ Odd ; if ( use@@ Odd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 8 ] ; even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] ; even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] ; even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] ; even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] ; even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] ; even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] ; even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ; even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ; even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] ; } else { odd [ 0 ] = even [ 0 ] + even [ 8 ] ; odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] ; odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] ; odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] ; odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] ; odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] ; odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] ; odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] ; odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] ; odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] ; } } totalCount = 0 ; if ( use@@ Odd == 1 ) { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += even [ i ] ; } else { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += odd [ i ] ; } return totalCount ; }
FIND_@@ ELEMEN@@ TS_@@ L@@ ARG@@ ER_@@ HALF_@@ ELEMEN@@ TS_@@ ARRAY | void find@@ Lar@@ ger ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = n - 1 ; i >= n / 2 ; i -- ) cout << arr [ i ] << " ▁ " ; }
S@@ UM_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENTS | int bin@@ omi@@ al@@ Coeff@@ Sum ( int n ) { int C [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += C [ n ] [ i ] ; return sum ; }
FIND_@@ COMMON_@@ ELEMENT_@@ RO@@ WS_@@ ROW_@@ WI@@ SE_@@ SOR@@ TED_@@ MATRIX_@@ 1 | int find@@ Common ( int mat [ M ] [ N ] ) { unordered_map < int , int > cnt ; int i , j ; for ( i = 0 ; i < M ; i ++ ) { cnt [ mat [ i ] [ 0 ] ] ++ ; for ( j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) cnt [ mat [ i ] [ j ] ] ++ ; } } for ( auto ele : cnt ) { if ( ele . second == M ) return ele . first ; } return - 1 ; }
SI@@ EV@@ E_@@ ER@@ ATO@@ ST@@ HE@@ NE@@ S_@@ 0@@ N_@@ TIME_@@ COMPLE@@ X@@ ITY | void manipul@@ ated_@@ se@@ ive ( int N ) { i@@ spri@@ me [ 0 ] = i@@ spri@@ me [ 1 ] = false ; for ( long long int i = 2 ; i < N ; i ++ ) { if ( i@@ spri@@ me [ i ] ) { prime . push_back ( i ) ; SP@@ F [ i ] = i ; } for ( long long int j = 0 ; j < ( int ) prime . size ( ) && i * prime [ j ] < N && prime [ j ] <= SP@@ F [ i ] ; j ++ ) { i@@ spri@@ me [ i * prime [ j ] ] = false ; SP@@ F [ i * prime [ j ] ] = prime [ j ] ; } } }
COUNT_@@ SOR@@ TED_@@ RO@@ WS_@@ MATRIX | int sorted@@ Count ( int mat [ ] [ MAX ] , int r , int c ) { int result = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = 0 ; j < c - 1 ; j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ; if ( j == c - 1 ) result ++ ; } for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = c - 1 ; j > 0 ; j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ; if ( c > 1 && j == 0 ) result ++ ; } return result ; }
NUMBER_@@ WAY@@ S_@@ NODE_@@ MAKE_@@ LOOP@@ _SIZE_@@ K_@@ UN@@ DIREC@@ TED_@@ COMPLETE_@@ CONNEC@@ TED_@@ GRAPH_@@ N_@@ NODES | int numOf@@ ways ( int n , int k ) { int p = 1 ; if ( k % 2 ) p = - 1 ; return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; }
DI@@ CE_@@ THROW_@@ PRO@@ BLE@@ M | int find@@ W@@ ays ( int m , int n , int x ) { int table [ n + 1 ] [ x + 1 ] ; memset ( table , 0 , sizeof ( table ) ) ; for ( int j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) for ( int j = 1 ; j <= x ; j ++ ) for ( int k = 1 ; k <= m && k < j ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; return table [ n ] [ x ] ; }
MINIMUM_@@ NUMBER_@@ DELE@@ TIONS_@@ MAKE_@@ STRING_@@ PA@@ LIN@@ DRO@@ ME_@@ SET_@@ 2 | int get@@ Lev@@ en@@ stein ( string const & input ) { string rev@@ Input ( input . rbegin ( ) , input . rend ( ) ) ; int n = input . size ( ) ; vector < vector < int > > dp ( n + 1 , vector < int > ( n + 1 , - 1 ) ) ; for ( int i = 0 ; i <= n ; ++ i ) { dp [ 0 ] [ i ] = i ; dp [ i ] [ 0 ] = i ; } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { if ( input [ i - 1 ] == rev@@ Input [ j - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( { dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] } ) ; } } int res = numeric_limits < int > :: max ( ) ; for ( int i = n , j = 0 ; i >= 0 ; -- i , ++ j ) { res = min ( res , dp [ i ] [ j ] ) ; if ( i < n ) res = min ( res , dp [ i + 1 ] [ j ] ) ; if ( i > 0 ) res = min ( res , dp [ i - 1 ] [ j ] ) ; } return res ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 37@@ _@@ BOOLEAN_@@ PARENTHE@@ SIZ@@ ATION_@@ PRO@@ BLE@@ M | int count@@ Paren@@ th ( char sym@@ b [ ] , char oper [ ] , int n ) { int F [ n ] [ n ] , T [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { F [ i ] [ i ] = ( sym@@ b [ i ] == ' F ' ) ? 1 : 0 ; T [ i ] [ i ] = ( sym@@ b [ i ] == ' T ' ) ? 1 : 0 ; } for ( int gap = 1 ; gap < n ; ++ gap ) { for ( int i = 0 , j = gap ; j < n ; ++ i , ++ j ) { T [ i ] [ j ] = F [ i ] [ j ] = 0 ; for ( int g = 0 ; g < gap ; g ++ ) { int k = i + g ; int ti@@ k = T [ i ] [ k ] + F [ i ] [ k ] ; int tk@@ j = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ; if ( oper [ k ] == ' & ' ) { T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ; F [ i ] [ j ] += ( ti@@ k * tk@@ j - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == ' | ' ) { F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] ; T [ i ] [ j ] += ( ti@@ k * tk@@ j - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == ' ^ ' ) { T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ; F [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ; } } } } return T [ 0 ] [ n - 1 ] ; }
PYTHON_@@ PROGRAM_@@ FIND_@@ PER@@ I@@ ME@@ TER_@@ CIRCUM@@ FER@@ ENCE_@@ SQU@@ ARE_@@ REC@@ TAN@@ GLE_@@ 1 | int Cir@@ cum@@ ference ( int l , int w ) { return ( 2 * ( l + w ) ) ; }
THIR@@ D_@@ LAR@@ GE@@ ST_@@ ELEMENT_@@ ARRAY_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ 1 | void third@@ Lar@@ gest ( int arr [ ] , int arr_@@ size ) { if ( arr_@@ size < 3 ) { printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] , second = INT_@@ MIN , third = INT_@@ MIN ; for ( int i = 1 ; i < arr_@@ size ; i ++ ) { if ( arr [ i ] > first ) { third = second ; second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { third = second ; second = arr [ i ] ; } else if ( arr [ i ] > third ) third = arr [ i ] ; } printf ( " The ▁ third ▁ Lar@@ gest ▁ element ▁ is ▁ % d \n " , third ) ; }
MINIMUM_@@ ROO@@ MS_@@ FOR_@@ M_@@ EV@@ ENTS_@@ OF_@@ N_@@ BAT@@ CHE@@ S_@@ WITH_@@ GI@@ VEN@@ _SCH@@ EDUL@@ E | int find@@ Min@@ Roo@@ ms ( string slots [ ] , int n , int m ) { int counts [ m ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ; return * max_@@ element ( counts , counts + m ) ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SUB@@ SET_@@ S@@ UM_@@ PRO@@ BLE@@ M | bool isSub@@ set@@ Sum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSub@@ set@@ Sum ( set , n - 1 , sum ) ; return isSub@@ set@@ Sum ( set , n - 1 , sum ) || isSub@@ set@@ Sum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
COUNT_@@ WAY@@ S_@@ DI@@ VI@@ DE_@@ CI@@ R@@ CLE_@@ USING_@@ N_@@ NON_@@ INTER@@ SEC@@ TING_@@ CH@@ OR@@ DS | int ch@@ ord@@ Cnt ( int A ) { int n = 2 * A ; int dp@@ Array [ n + 1 ] = { 0 } ; dp@@ Array [ 0 ] = 1 ; dp@@ Array [ 2 ] = 1 ; for ( int i = 4 ; i <= n ; i += 2 ) { for ( int j = 0 ; j < i - 1 ; j += 2 ) { dp@@ Array [ i ] += ( dp@@ Array [ j ] * dp@@ Array [ i - 2 - j ] ) ; } } return dp@@ Array [ n ] ; }
BREAK_@@ NUMBER_@@ THRE@@ E_@@ PAR@@ TS_@@ 1 | ll count_@@ of_@@ ways ( ll n ) { ll count ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
PRINT_@@ DIG@@ IT@@ S_@@ POSITION_@@ REMO@@ VED_@@ MAKE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 6 | void gre@@ atest ( string s ) { int n = s . length ( ) ; int a [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = s [ i ] - '0' ; sum += a [ i ] ; } if ( a [ n - 1 ] % 2 ) { if ( a [ n - 2 ] % 2 != 0 or ( sum - a [ n - 1 ] ) % 3 != 0 ) { cout << " - 1" << endl ; } else { cout << n << endl ; } } else { int re = sum % 3 ; int del = - 1 ; int flag = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] ) % 3 == re ) { if ( a [ i + 1 ] > a [ i ] ) { del = i ; flag = 1 ; break ; } else { del = i ; } } } if ( flag == 0 ) { if ( a [ n - 2 ] % 2 == 0 and re == a [ n - 1 ] % 3 ) del = n - 1 ; } if ( del == - 1 ) cout << - 1 << endl ; else { cout << del + 1 << endl ; } } }
MAXIMUM_@@ HEIGHT_@@ OF_@@ TRIANG@@ ULAR_@@ AR@@ RANGE@@ MENT_@@ OF_@@ ARRAY_@@ VALUES | int Maximum@@ Height ( int a [ ] , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { long long y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; }
SQU@@ AR@@ ED_@@ TRIANG@@ ULAR_@@ NUMBER@@ _S@@ UM_@@ CU@@ B@@ ES | int find@@ S ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return - 1 ; }
EVALU@@ ATE_@@ A_@@ BOOLEAN_@@ EXPRES@@ SION_@@ RE@@ PRESEN@@ TED_@@ AS_@@ STRING | int evaluate@@ Bool@@ Expr ( string s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i += 2 ) { if ( s [ i + 1 ] == ' A ' ) { if ( s [ i + 2 ] == '0' || s [ i ] == '0' ) s [ i + 2 ] = '0' ; else s [ i + 2 ] = '1' ; } else if ( s [ i + 1 ] == ' B ' ) { if ( s [ i + 2 ] == '1' || s [ i ] == '1' ) s [ i + 2 ] = '1' ; else s [ i + 2 ] = '0' ; } else { if ( s [ i + 2 ] == s [ i ] ) s [ i + 2 ] = '0' ; else s [ i + 2 ] = '1' ; } } return s [ n - 1 ] - '0' ; }
PROGR@@ AM@@ M@@ ING_@@ PU@@ ZZ@@ LE_@@ ASSIGN_@@ VALUE_@@ WITH@@ OUT_@@ CONTROL_@@ STATEMENT | int assign@@ Value ( int a , int b , bool x ) { int arr [ ] = { a , b } ; return ( arr [ x ] ) ; }
MIN@@ IM@@ UM@@ _S@@ UM@@ _S@@ QUAR@@ ES_@@ CHARAC@@ TER@@ S_@@ COUN@@ TS_@@ GI@@ V@@ EN_@@ STRING_@@ REMO@@ V@@ ING_@@ K_@@ CHARAC@@ TERS | int min@@ StringValue ( string str , int k ) { int l = str . length ( ) ; if ( k >= l ) return 0 ; int frequency [ MAX_@@ CHAR ] = { 0 } ; for ( int i = 0 ; i < l ; i ++ ) frequency [ str [ i ] - ' a ' ] ++ ; priority_@@ queue < int > q ; for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) q . push ( frequency [ i ] ) ; while ( k -- ) { int temp = q . top ( ) ; q . pop ( ) ; temp = temp - 1 ; q . push ( temp ) ; } int result = 0 ; while ( ! q . empty ( ) ) { int temp = q . top ( ) ; result += temp * temp ; q . pop ( ) ; } return result ; }
MAJ@@ ORI@@ TY_@@ ELEMENT_@@ 1 | void find@@ Maj@@ ority ( int arr [ ] , int size ) { unordered_map < int , int > m ; for ( int i = 0 ; i < size ; i ++ ) m [ arr [ i ] ] ++ ; int count = 0 ; for ( auto i : m ) { if ( i . second > size / 2 ) { count = 1 ; cout << " Maj@@ ority ▁ found ▁ : - ▁ " << i . first << endl ; break ; } } if ( count == 0 ) cout << " No ▁ Maj@@ ority ▁ element " << endl ; }
LAR@@ GE@@ ST@@ _SUB@@ SET_@@ GRAPH_@@ VER@@ TIC@@ ES_@@ ED@@ GE@@ S_@@ 2_@@ COLORS | int sub@@ set@@ Graph ( int C [ ] [ N ] ) { set < int > vertices ; for ( int i = 0 ; i < N ; ++ i ) vertices . insert ( i ) ; while ( ! vertices . empty ( ) ) { if ( vertices . size ( ) == 1 ) return 1 ; bool some@@ one_@@ removed = false ; for ( int x : vertices ) { set < int > values ; for ( int y : vertices ) if ( y != x ) values . insert ( C [ x ] [ y ] ) ; if ( values . size ( ) == 1 ) { vertices . erase ( x ) ; some@@ one_@@ removed = true ; break ; } } if ( ! some@@ one_@@ removed ) break ; } return ( vertices . size ( ) ) ; }
FLO@@ OR_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY_@@ 1 | int floor@@ Search ( int arr [ ] , int low , int high , int x ) { if ( low > high ) return - 1 ; if ( x >= arr [ high ] ) return high ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > 0 && arr [ mid - 1 ] <= x && x < arr [ mid ] ) return mid - 1 ; if ( x < arr [ mid ] ) return floor@@ Search ( arr , low , mid - 1 , x ) ; return floor@@ Search ( arr , mid + 1 , high , x ) ; }
LON@@ GE@@ ST_@@ PREFIX_@@ AL@@ SO@@ _SU@@ F@@ FIX_@@ 1 | int lon@@ gest@@ Prefix@@ Suffix ( string s ) { int n = s . length ( ) ; int l@@ ps [ n ] ; l@@ ps [ 0 ] = 0 ; int len = 0 ; int i = 1 ; while ( i < n ) { if ( s [ i ] == s [ len ] ) { len ++ ; l@@ ps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = l@@ ps [ len - 1 ] ; } else { l@@ ps [ i ] = 0 ; i ++ ; } } } int res = l@@ ps [ n - 1 ] ; return ( res > n / 2 ) ? n / 2 : res ; }
COUNT_@@ NUMBER_OF_@@ WAY@@ S_TO_@@ PARTITION_@@ A@@ _SET_@@ IN@@ TO_@@ K@@ _SUB@@ SETS | int count@@ P ( int n , int k ) { if ( n == 0 || k == 0 || k > n ) return 0 ; if ( k == 1 || k == n ) return 1 ; return k * count@@ P ( n - 1 , k ) + count@@ P ( n - 1 , k - 1 ) ; }
C_@@ PROGRAM_@@ FAC@@ TOR@@ I@@ AL_@@ NUMBER_@@ 2 | int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
FIND_@@ REPE@@ ATED_@@ CHARACTER_@@ PRES@@ ENT_@@ FIRST_@@ STRING_@@ 1 | int find@@ Repeat@@ First ( char * s ) { int p = - 1 , i , k ; int hash [ MAX_@@ CHAR ] = { 0 } ; int pos [ MAX_@@ CHAR ] ; for ( i = 0 ; i < strlen ( s ) ; i ++ ) { k = ( int ) s [ i ] ; if ( hash [ k ] == 0 ) { hash [ k ] ++ ; pos [ k ] = i ; } else if ( hash [ k ] == 1 ) hash [ k ] ++ ; } for ( i = 0 ; i < MAX_@@ CHAR ; i ++ ) { if ( hash [ i ] == 2 ) { if ( p == - 1 ) p = pos [ i ] ; else if ( p > pos [ i ] ) p = pos [ i ] ; } } return p ; }
NUMBER_OF_@@ PER@@ MU@@ TATION_@@ WITH_@@ K_@@ IN@@ VERSIONS | int numberOf@@ Perm@@ With@@ K@@ In@@ version ( int N , int K ) { if ( N == 0 ) return 0 ; if ( K == 0 ) return 1 ; if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ; int sum = 0 ; for ( int i = 0 ; i <= K ; i ++ ) { if ( i <= N - 1 ) sum += numberOf@@ Perm@@ With@@ K@@ In@@ version ( N - 1 , K - i ) ; } memo [ N ] [ K ] = sum ; return sum ; }
K_@@ TH_@@ LAR@@ GE@@ ST@@ _S@@ UM_@@ CON@@ TI@@ GU@@ OU@@ S@@ _SUB@@ ARRAY | int k@@ th@@ Largest@@ Sum ( int arr [ ] , int n , int k ) { int sum [ n + 1 ] ; sum [ 0 ] = 0 ; sum [ 1 ] = arr [ 0 ] ; for ( int i = 2 ; i <= n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] ; priority_@@ queue < int , vector < int > , greater < int > > Q ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { int x = sum [ j ] - sum [ i - 1 ] ; if ( Q . size ( ) < k ) Q . push ( x ) ; else { if ( Q . top ( ) < x ) { Q . pop ( ) ; Q . push ( x ) ; } } } } return Q . top ( ) ; }
FIND_@@ THE_@@ LAR@@ GE@@ ST_@@ THRE@@ E_@@ ELEMEN@@ TS_@@ IN_@@ AN_@@ ARRAY | void find@@ 3@@ largest ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int check = 0 , count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( count < 4 ) { if ( check != arr [ n - i ] ) { cout << arr [ n - i ] << " ▁ " ; check = arr [ n - i ] ; count ++ ; } } else break ; } }
MAXIMUM_@@ DISTIN@@ CT_@@ LOW@@ ER@@ CASE_@@ ALPH@@ AB@@ E@@ TS_@@ TWO_@@ UP@@ PER@@ CASE | int max@@ Lower ( string str ) { int n = str . length ( ) ; int i = 0 ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { i ++ ; break ; } } int maxCount = 0 ; int count [ MAX_@@ CHAR ] = { 0 } ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { int curr@@ Count = 0 ; for ( int j = 0 ; j < MAX_@@ CHAR ; j ++ ) if ( count [ j ] > 0 ) curr@@ Count ++ ; maxCount = max ( maxCount , curr@@ Count ) ; memset ( count , 0 , sizeof ( count ) ) ; } if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) count [ str [ i ] - ' a ' ] ++ ; } return maxCount ; }
CHECK_@@ IF_@@ A_@@ STRING_@@ HAS_@@ ALL_@@ CHARAC@@ TER@@ S_@@ WITH@@ _S@@ AME_@@ FREQU@@ ENCY_@@ WITH_@@ ONE_@@ VARI@@ ATION_@@ ALLOWED | bool isValid@@ String ( string str ) { int freq [ CHARS ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; int i , fre@@ q1 = 0 , count_@@ fre@@ q1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { fre@@ q1 = freq [ i ] ; count_@@ fre@@ q1 = 1 ; break ; } } int j , fre@@ q2 = 0 , count_@@ fre@@ q2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == fre@@ q1 ) count_@@ fre@@ q1 ++ ; else { count_@@ fre@@ q2 = 1 ; fre@@ q2 = freq [ j ] ; break ; } } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == fre@@ q1 ) count_@@ fre@@ q1 ++ ; if ( freq [ k ] == fre@@ q2 ) count_@@ fre@@ q2 ++ ; else return false ; } if ( count_@@ fre@@ q1 > 1 && count_@@ fre@@ q2 > 1 ) return false ; } return true ; }
MAXIMUM_@@ AVER@@ AGE_@@ S@@ UM_@@ PARTITION_@@ ARRAY | double lar@@ gest@@ Sum@@ Of@@ Aver@@ ages ( vector < int > & A , int K ) { int n = A . size ( ) ; double pre_@@ sum [ n + 1 ] ; pre_@@ sum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) pre_@@ sum [ i + 1 ] = pre_@@ sum [ i ] + A [ i ] ; double dp [ n ] = { 0 } ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = ( pre_@@ sum [ n ] - pre_@@ sum [ i ] ) / ( n - i ) ; for ( int k = 0 ; k < K - 1 ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) dp [ i ] = max ( dp [ i ] , ( pre_@@ sum [ j ] - pre_@@ sum [ i ] ) / ( j - i ) + dp [ j ] ) ; return dp [ 0 ] ; }
FIN@@ D@@ _SUB@@ ARRAY_@@ WITH_@@ GI@@ VEN@@ _S@@ UM_@@ IN_@@ ARRAY_@@ OF_@@ INTEG@@ ERS | void sub@@ Array@@ Sum ( int arr [ ] , int n , int sum ) { unordered_map < int , int > map ; int curr_@@ sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_@@ sum = curr_@@ sum + arr [ i ] ; if ( curr_@@ sum == sum ) { cout << " Sum ▁ found ▁ between ▁ indexes ▁ " << 0 << " ▁ to ▁ " << i << endl ; return ; } if ( map . find ( curr_@@ sum - sum ) != map . end ( ) ) { cout << " Sum ▁ found ▁ between ▁ indexes ▁ " << map [ curr_@@ sum - sum ] + 1 << " ▁ to ▁ " << i << endl ; return ; } map [ curr_@@ sum ] = i ; } cout << " No ▁ sub@@ array ▁ with ▁ given ▁ sum ▁ exists " ; }
REMOVE_@@ MINIMUM_@@ ELEMEN@@ TS_@@ EI@@ THER@@ _SI@@ DE_@@ 2@@ MIN_@@ MAX | int min@@ Removal@@ s@@ DP ( int arr [ ] , int n ) { int lon@@ gest_@@ start = - 1 , lon@@ gest_@@ end = 0 ; for ( int start = 0 ; start < n ; start ++ ) { int min = INT_MAX , max = INT_@@ MIN ; for ( int end = start ; end < n ; end ++ ) { int val = arr [ end ] ; if ( val < min ) min = val ; if ( val > max ) max = val ; if ( 2 * min <= max ) break ; if ( end - start > lon@@ gest_@@ end - lon@@ gest_@@ start || lon@@ gest_@@ start == - 1 ) { lon@@ gest_@@ start = start ; lon@@ gest_@@ end = end ; } } } if ( lon@@ gest_@@ start == - 1 ) return n ; return ( n - ( lon@@ gest_@@ end - lon@@ gest_@@ start + 1 ) ) ; }
FIND_@@ THE_@@ MISSING_@@ NUMBER_@@ 1 | int get@@ Missing@@ No ( int a [ ] , int n ) { int i , total = 1 ; for ( i = 2 ; i <= ( n + 1 ) ; i ++ ) { total += i ; total -= a [ i - 2 ] ; } return total ; }
SI@@ EV@@ E_@@ SUN@@ DAR@@ AM_@@ PRINT_@@ PRI@@ ME@@ S_S@@ MAL@@ LER_@@ N | int Si@@ eve@@ OfS@@ und@@ ar@@ am ( int n ) { int n@@ New = ( n - 2 ) / 2 ; bool marked [ n@@ New + 1 ] ; memset ( marked , false , sizeof ( marked ) ) ; for ( int i = 1 ; i <= n@@ New ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= n@@ New ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) cout << 2 << " ▁ " ; for ( int i = 1 ; i <= n@@ New ; i ++ ) if ( marked [ i ] == false ) cout << 2 * i + 1 << " ▁ " ; }
MAXIMUM_@@ PRODUCT_@@ SUB@@ SET_@@ ARRAY | int max@@ Product@@ Subset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int max_@@ neg = INT_@@ MIN ; int count_@@ neg = 0 , count_@@ zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_@@ zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_@@ neg ++ ; max_@@ neg = max ( max_@@ neg , a [ i ] ) ; } prod = prod * a [ i ] ; } if ( count_@@ zero == n ) return 0 ; if ( count_@@ neg & 1 ) { if ( count_@@ neg == 1 && count_@@ zero > 0 && count_@@ zero + count_@@ neg == n ) return 0 ; prod = prod / max_@@ neg ; } return prod ; }
FIND_@@ THE_@@ NEARE@@ ST@@ _S@@ MAL@@ LER_@@ NUMB@@ ERS_@@ ON_@@ LEFT_@@ SIDE_@@ IN_@@ AN_@@ ARRAY | void print@@ Prev@@ S@@ mal@@ ler ( int arr [ ] , int n ) { cout << " _ , ▁ " ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ j ] < arr [ i ] ) { cout << arr [ j ] << " , ▁ " ; break ; } } if ( j == - 1 ) cout << " _ , ▁ " ; } }
FIND_@@ NUMBER_@@ PAIR@@ S_@@ ARRAY_@@ X@@ OR_@@ 0_@@ 1 | int calculate ( int a [ ] , int n ) { int * maximum = max_@@ element ( a , a + 5 ) ; int frequency [ * maximum + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ a [ i ] ] += 1 ; } int answer = 0 ; for ( int i = 0 ; i < ( * maximum ) + 1 ; i ++ ) { answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) ; } return answer / 2 ; }
S@@ UM_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENTS_@@ 1 | int bin@@ omi@@ al@@ Coeff@@ Sum ( int n ) { return ( 1 << n ) ; }
MAX@@ IM@@ UM@@ _S@@ UM_@@ PAIR@@ S@@ _SPECI@@ FIC_@@ DIFF@@ ER@@ ENCE_@@ 1 | int max@@ Sum@@ Pair@@ With@@ Difference@@ LessThan@@ K ( int arr [ ] , int N , int k ) { int max@@ Sum = 0 ; sort ( arr , arr + N ) ; for ( int i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { max@@ Sum += arr [ i ] ; max@@ Sum += arr [ i - 1 ] ; -- i ; } } return max@@ Sum ; }
K@@ TH_@@ AD@@ J@@ AC@@ ENT_@@ NODE_@@ GRAPH_@@ VERTEX_@@ WEIGHT | void print@@ k@@ th@@ node ( vector < pair < int , int > > adj [ ] , int wt [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) sort ( adj [ i ] . begin ( ) , adj [ i ] . end ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( adj [ i ] . size ( ) >= k ) cout << adj [ i ] [ adj [ i ] . size ( ) - k ] . second ; else cout << " - 1" ; } }
SPACE_@@ OPTIMIZ@@ ED_@@ D@@ P_S@@ OL@@ U@@ TION_@@ 0_@@ 1_@@ KN@@ AP@@ S@@ ACK_@@ PRO@@ BLE@@ M | int K@@ nap@@ S@@ ack ( int val [ ] , int wt [ ] , int n , int W ) { int mat [ 2 ] [ W + 1 ] ; memset ( mat , 0 , sizeof ( mat ) ) ; int i = 0 ; while ( i < n ) { int j = 0 ; if ( i % 2 != 0 ) { while ( ++ j <= W ) { if ( wt [ i ] <= j ) mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) ; else mat [ 1 ] [ j ] = mat [ 0 ] [ j ] ; } } else { while ( ++ j <= W ) { if ( wt [ i ] <= j ) mat [ 0 ] [ j ] = max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) ; else mat [ 0 ] [ j ] = mat [ 1 ] [ j ] ; } } i ++ ; } return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ] ; }
BINARY_@@ RE@@ PRESEN@@ TATION_@@ OF_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ 1 | void bin ( unsigned n ) { if ( n > 1 ) bin ( n >> 1 ) ; printf ( " % d " , n & 1 ) ; }
PRI@@ ME_@@ FAC@@ TOR@@ S_@@ BIG_@@ NUMBER | void factor@@ ize ( long long n ) { int count = 0 ; while ( ! ( n % 2 ) ) { n >>= 1 ; count ++ ; } if ( count ) cout << 2 << " ▁ ▁ " << count << endl ; for ( long long i = 3 ; i <= sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n = n / i ; } if ( count ) cout << i << " ▁ ▁ " << count << endl ; } if ( n > 2 ) cout << n << " ▁ ▁ " << 1 << endl ; }
COUNT_@@ SUB@@ STRING@@ S_@@ WITH@@ _S@@ AME_@@ FIRST_@@ AND_@@ LAST_@@ CHARAC@@ TER@@ S_@@ 1 | int count@@ Sub@@ string@@ With@@ Equal@@ Ends ( string s ) { int result = 0 ; int n = s . length ( ) ; int count [ MAX_@@ CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ s [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }
LON@@ GE@@ ST_@@ PA@@ LIN@@ DRO@@ ME_@@ SUB@@ STRING@@ _SET_@@ 1 | void print@@ Sub@@ Str ( string str , int low , int high ) { for ( int i = low ; i <= high ; ++ i ) cout << str [ i ] ; }
FIND_@@ THE_@@ SM@@ ALLE@@ ST_@@ WINDOW_@@ IN_@@ A_@@ STRING_@@ CONTAIN@@ ING_@@ ALL_@@ CHARAC@@ TER@@ S_@@ OF_@@ AN@@ OTHER_@@ STRING | string find@@ Sub@@ String ( string str , string pat ) { int len1 = str . length ( ) ; int len2 = pat . length ( ) ; if ( len1 < len2 ) { cout << " No ▁ such ▁ window ▁ exists " ; return " " ; } int hash@@ _p@@ at [ no_@@ of_@@ chars ] = { 0 } ; int hash_@@ str [ no_@@ of_@@ chars ] = { 0 } ; for ( int i = 0 ; i < len2 ; i ++ ) hash@@ _p@@ at [ pat [ i ] ] ++ ; int start = 0 , start_index = - 1 , min_@@ len = INT_MAX ; int count = 0 ; for ( int j = 0 ; j < len1 ; j ++ ) { hash_@@ str [ str [ j ] ] ++ ; if ( hash@@ _p@@ at [ str [ j ] ] != 0 && hash_@@ str [ str [ j ] ] <= hash@@ _p@@ at [ str [ j ] ] ) count ++ ; if ( count == len2 ) { while ( hash_@@ str [ str [ start ] ] > hash@@ _p@@ at [ str [ start ] ] || hash@@ _p@@ at [ str [ start ] ] == 0 ) { if ( hash_@@ str [ str [ start ] ] > hash@@ _p@@ at [ str [ start ] ] ) hash_@@ str [ str [ start ] ] -- ; start ++ ; } int len_@@ window = j - start + 1 ; if ( min_@@ len > len_@@ window ) { min_@@ len = len_@@ window ; start_index = start ; } } } if ( start_index == - 1 ) { cout << " No ▁ such ▁ window ▁ exists " ; return " " ; } return str . substr ( start_index , min_@@ len ) ; }
MAR@@ KO@@ V_@@ MATRIX | bool check@@ Mark@@ ov ( double m [ ] [ n ] ) { for ( int i = 0 ; i < n ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }
LE@@ AF_@@ NODE@@ S_@@ PRE@@ ORDER_@@ BIN@@ AR@@ Y@@ _SEARCH_@@ TREE | void leaf@@ Node ( int pre@@ order [ ] , int n ) { stack < int > s ; for ( int i = 0 , j = 1 ; j < n ; i ++ , j ++ ) { bool found = false ; if ( pre@@ order [ i ] > pre@@ order [ j ] ) s . push ( pre@@ order [ i ] ) ; else { while ( ! s . empty ( ) ) { if ( pre@@ order [ j ] > s . top ( ) ) { s . pop ( ) ; found = true ; } else break ; } } if ( found ) cout << pre@@ order [ i ] << " ▁ " ; } cout << pre@@ order [ n - 1 ] ; }
SM@@ ALLE@@ ST_@@ POWER_@@ OF_@@ 2_@@ GREATER_@@ TH@@ AN_@@ OR_@@ EQUAL_@@ TO_@@ N | unsigned int next@@ PowerOf@@ 2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
PROGRAM_@@ CHECK_@@ WAT@@ ER_@@ TAN@@ K_@@ OVER@@ FLO@@ WS_@@ N@@ _SO@@ LI@@ D_@@ BAL@@ LS_@@ DIP@@ PED_@@ WAT@@ ER_@@ TAN@@ K | void overflow ( int H , int r , int h , int N , int R ) { float tan@@ k_@@ cap = 3.14 * r * r * H ; float wat@@ er_@@ vol = 3.14 * r * r * h ; float ball@@ s_@@ vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; float vol = wat@@ er_@@ vol + ball@@ s_@@ vol ; if ( vol > tan@@ k_@@ cap ) { cout << " Overflow " << endl ; } else { cout << " Not ▁ in ▁ overflow ▁ state " << endl ; } }
SM@@ ALLE@@ ST_@@ DE@@ RANGE@@ MENT_@@ SEQUENCE | void generate_@@ der@@ ange@@ ment ( int N ) { int S [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) S [ i ] = i ; int D [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 2 ) { if ( i == N && i % N != 0 ) { int temp = D [ N ] D [ N ] = D [ N - 1 ] ; D [ N - 1 ] = temp ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( int i = 1 ; i <= N ; i ++ ) printf ( " % d ▁ " , D [ i ] ) ; printf ( " \n " ) ; }
MAXIMUM_@@ PRODUCT_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQUENCE | ll lis ( ll arr [ ] , ll n ) { ll mp@@ is [ n ] ; for ( int i = 0 ; i < n ; i ++ ) mp@@ is [ i ] = arr [ i ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && mp@@ is [ i ] < ( mp@@ is [ j ] * arr [ i ] ) ) mp@@ is [ i ] = mp@@ is [ j ] * arr [ i ] ; return * max_@@ element ( mp@@ is , mp@@ is + n ) ; }
CHANGE_@@ BITS_@@ CAN_@@ MA@@ DE_@@ ONE_@@ FLI@@ P | bool can@@ Make@@ All@@ Same ( string str ) { int zeros = 0 , ones = 0 ; for ( char ch : str ) ( ch == '0' ) ? ++ zeros : ++ ones ; return ( zeros == 1 || ones == 1 ) ; }
FIND_@@ NUMBER_@@ PAIR@@ S_@@ ARRAY_@@ X@@ OR_@@ 0 | int calculate ( int a [ ] , int n ) { sort ( a , a + n ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; }
FIND_@@ ROOT_@@ TREE_@@ CHIL@@ DR@@ EN_@@ ID@@ _S@@ UM_@@ EVER@@ Y_@@ NODE_@@ GI@@ VEN | int find@@ Root ( pair < int , int > arr [ ] , int n ) { int root = 0 ; for ( int i = 0 ; i < n ; i ++ ) root += ( arr [ i ] . first - arr [ i ] . second ) ; return root ; }
BIN@@ AR@@ Y@@ _SEARCH | int binary@@ Search ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binary@@ Search ( arr , l , mid - 1 , x ) ; return binary@@ Search ( arr , mid + 1 , r , x ) ; } return - 1 ; }
FI@@ BON@@ ACC@@ I_@@ MODUL@@ O_@@ P | int find@@ Min@@ Zero ( int p ) { int first = 1 , second = 1 , number = 2 , next = 1 ; while ( next ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }
K_@@ LAR@@ GE@@ STOR@@ _S@@ MAL@@ LE@@ ST_@@ ELEMEN@@ TS_@@ IN_@@ AN_@@ ARRAY | void k@@ Lar@@ gest ( int arr [ ] , int n , int k ) { sort ( arr , arr + n , greater < int > ( ) ) ; for ( int i = 0 ; i < k ; i ++ ) cout << arr [ i ] << " ▁ " ; }
C_@@ PROGRAM_@@ FIND_@@ AREA_@@ CIRC@@ LE | float find@@ Area ( float r ) { return ( pi * r * r ) ; }
S@@ UM_@@ TWO_@@ LARGE_@@ NUMB@@ ERS | string find@@ Sum ( string str1 , string str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) swap ( str1 , str2 ) ; string str = " " ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; reverse ( str1 . begin ( ) , str1 . end ( ) ) ; reverse ( str2 . begin ( ) , str2 . end ( ) ) ; int carry = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { int sum = ( ( str1 [ i ] - '0' ) + ( str2 [ i ] - '0' ) + carry ) ; str . push_back ( sum % 10 + '0' ) ; carry = sum / 10 ; } for ( int i = n1 ; i < n2 ; i ++ ) { int sum = ( ( str2 [ i ] - '0' ) + carry ) ; str . push_back ( sum % 10 + '0' ) ; carry = sum / 10 ; } if ( carry ) str . push_back ( carry + '0' ) ; reverse ( str . begin ( ) , str . end ( ) ) ; return str ; }
ARRAY_@@ RANGE_@@ QUER@@ I@@ ES_@@ ELEMEN@@ TS_@@ FREQU@@ ENCY_@@ VALUE | int solve@@ Query ( int start , int end , int arr [ ] ) { unordered_map < int , int > frequency ; for ( int i = start ; i <= end ; i ++ ) frequency [ arr [ i ] ] ++ ; int count = 0 ; for ( auto x : frequency ) if ( x . first == x . second ) count ++ ; return count ; }
COUNT_@@ SUB@@ STRING@@ S_@@ WITH@@ _S@@ AME_@@ FIRST_@@ AND_@@ LAST_@@ CHARAC@@ TERS | int count@@ Sub@@ string@@ With@@ Equal@@ Ends ( string s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( s [ i ] == s [ j ] ) result ++ ; return result ; }
DYNAMIC_@@ PROGR@@ AM@@ M@@ ING_@@ HIGH_@@ EFF@@ ORT_@@ VS_@@ LOW_@@ EFF@@ ORT_@@ TASK@@ S_@@ PRO@@ BLE@@ M | int max@@ Tasks ( int high [ ] , int low [ ] , int n ) { if ( n <= 0 ) return 0 ; return max ( high [ n - 1 ] + max@@ Tasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + max@@ Tasks ( high , low , ( n - 1 ) ) ) ; }
MAXIMUM_@@ DIFF@@ ER@@ ENCE_@@ S@@ UM_@@ ELEMEN@@ TS_@@ TWO_@@ RO@@ WS_@@ MATRIX | int max@@ Row@@ Diff ( int mat [ ] [ MAX ] , int m , int n ) { int row@@ Sum [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] ; row@@ Sum [ i ] = sum ; } int max_@@ diff = row@@ Sum [ 1 ] - row@@ Sum [ 0 ] ; int min_@@ element = row@@ Sum [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) { if ( row@@ Sum [ i ] - min_@@ element > max_@@ diff ) max_@@ diff = row@@ Sum [ i ] - min_@@ element ; if ( row@@ Sum [ i ] < min_@@ element ) min_@@ element = row@@ Sum [ i ] ; } return max_@@ diff ; }
PAP@@ ER_@@ CU@@ T_@@ MINIMUM_@@ NUMBER@@ _S@@ QUAR@@ ES | int minimum@@ Square ( int a , int b ) { long long result = 0 , rem = 0 ; if ( a < b ) swap ( a , b ) ; while ( b > 0 ) { result += a / b ; long long rem = a % b ; a = b ; b = rem ; } return result ; }
SEARCH_@@ AN_@@ ELEMENT_@@ IN_@@ AN_@@ ARRAY_@@ W@@ HER@@ E_@@ DIFF@@ ER@@ ENCE_@@ BETWE@@ EN_@@ AD@@ J@@ AC@@ ENT_@@ ELEMEN@@ TS_@@ IS_@@ 1 | int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + abs ( arr [ i ] - x ) ; } cout << " number ▁ is ▁ not ▁ present ! " ; return - 1 ; }
PAN@@ GR@@ AM_@@ CHECK@@ ING | bool check@@ P@@ ang@@ ram ( string & str ) { vector < bool > mark ( 26 , false ) ; int index ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ' A ' <= str [ i ] && str [ i ] <= ' Z ' ) index = str [ i ] - ' A ' ; else if ( ' a ' <= str [ i ] && str [ i ] <= ' z ' ) index = str [ i ] - ' a ' ; mark [ index ] = true ; } for ( int i = 0 ; i <= 25 ; i ++ ) if ( mark [ i ] == false ) return ( false ) ; return ( true ) ; }
PRINT_@@ SHOR@@ TEST_@@ COMM@@ ON@@ _SUP@@ ER@@ SEQUENCE | string print@@ Shor@@ test@@ Super@@ Seq ( string X , string Y ) { int m = X . length ( ) ; int n = Y . length ( ) ; int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } int index = dp [ m ] [ n ] ; string str ; int i = m , j = n ; while ( i > 0 && j > 0 ) { if ( X [ i - 1 ] == Y [ j - 1 ] ) { str . push_back ( X [ i - 1 ] ) ; i -- , j -- , index -- ; } else if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] ) { str . push_back ( Y [ j - 1 ] ) ; j -- , index -- ; } else { str . push_back ( X [ i - 1 ] ) ; i -- , index -- ; } } while ( i > 0 ) { str . push_back ( X [ i - 1 ] ) ; i -- , index -- ; } while ( j > 0 ) { str . push_back ( Y [ j - 1 ] ) ; j -- , index -- ; } reverse ( str . begin ( ) , str . end ( ) ) ; return str ; }
FIND_@@ PA@@ IR_@@ MAXIMUM_@@ GC@@ D_@@ ARRAY_@@ 1 | int find@@ Max@@ GC@@ D ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = max ( high , arr [ i ] ) ; int count [ high + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; int counter = 0 ; for ( int i = high ; i >= 1 ; i -- ) { int j = i ; counter = 0 ; while ( j <= high ) { if ( count [ j ] >= 2 ) return j ; else if ( count [ j ] == 1 ) counter ++ ; j += i ; if ( counter == 2 ) return i ; } } }
PROGRAM_@@ CAL@@ CUL@@ ATE_@@ AREA_@@ OC@@ TAG@@ ON | double area@@ Oct@@ ag@@ on ( double side ) { return ( float ) ( 2 * ( 1 + sqrt ( 2 ) ) * side * side ) ; }
FIND_@@ INDEX_@@ OF_@@ AN_@@ EXTRA_@@ ELEMENT_@@ PRES@@ ENT_@@ IN_@@ ONE@@ _S@@ OR@@ TED_@@ ARRAY_@@ 1 | int find@@ Extra ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int n ) { int index = n ; int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( ar@@ r2 [ mid ] == ar@@ r1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }
NO@@ BLE_@@ INTEG@@ ERS_@@ IN_@@ AN_@@ ARRAY_@@ COUNT_@@ OF_@@ GREATER_@@ ELEMEN@@ TS_@@ IS_@@ EQUAL_@@ TO_@@ VALUE_@@ 1 | int no@@ ble@@ Integer ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return - 1 ; }
MAXIMUM_@@ NUMBER_@@ OF@@ _S@@ QUAR@@ ES_@@ TH@@ AT_@@ CAN_@@ BE_@@ FI@@ T_@@ IN_@@ A_@@ RIGHT_@@ ANGLE_@@ ISO@@ SCE@@ LES_@@ TRI@@ ANGLE | int max@@ Square ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; }
HO@@ W_@@ TO_@@ COMP@@ UTE_@@ MOD_@@ OF_@@ A_@@ BIG_@@ NUMBER | int mod ( string num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num [ i ] - '0' ) % a ; return res ; }
LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ STRING_@@ 1 | int l@@ cs ( int i , int j , int count ) { if ( i == 0 || j == 0 ) return count ; if ( X [ i - 1 ] == Y [ j - 1 ] ) { count = l@@ cs ( i - 1 , j - 1 , count + 1 ) ; } count = max ( count , max ( l@@ cs ( i , j - 1 , 0 ) , l@@ cs ( i - 1 , j , 0 ) ) ) ; return count ; }
FIND_@@ PATTER@@ NS_@@ 101@@ _@@ GI@@ V@@ EN_@@ STRING | int pattern@@ Count ( string str ) { char last = str [ 0 ] ; int i = 1 , counter = 0 ; while ( i < str . size ( ) ) { if ( str [ i ] == '0' && last == '1' ) { while ( str [ i ] == '0' ) i ++ ; if ( str [ i ] == '1' ) counter ++ ; } last = str [ i ] ; i ++ ; } return counter ; }
LON@@ GE@@ ST_@@ INCRE@@ AS@@ ING_@@ OD@@ D_@@ EV@@ EN@@ _SUB@@ SEQUENCE | int long@@ O@@ dd@@ Even@@ Inc@@ Seq ( int arr [ ] , int n ) { int li@@ o@@ es [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) li@@ o@@ es [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && li@@ o@@ es [ i ] < li@@ o@@ es [ j ] + 1 ) li@@ o@@ es [ i ] = li@@ o@@ es [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < li@@ o@@ es [ i ] ) maxLen = li@@ o@@ es [ i ] ; return maxLen ; }
COUNT_@@ NUMBER_@@ OF@@ _SUB@@ STRING@@ S_@@ WITH_@@ EXAC@@ TL@@ Y_@@ K_@@ DISTIN@@ CT_@@ CHARAC@@ TERS | int count@@ k@@ Dist ( string str , int k ) { int n = str . length ( ) ; int res = 0 ; int cnt [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int dist@@ _count = 0 ; memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int j = i ; j < n ; j ++ ) { if ( cnt [ str [ j ] - ' a ' ] == 0 ) dist@@ _count ++ ; cnt [ str [ j ] - ' a ' ] ++ ; if ( dist@@ _count == k ) res ++ ; if ( dist@@ _count > k ) break ; } } return res ; }
C_@@ PROGRAM_@@ FAC@@ TOR@@ I@@ AL_@@ NUMBER_@@ 1 | unsigned int factorial ( unsigned int n ) { int res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
K_@@ MAX@@ IM@@ UM@@ _S@@ UM@@ S_@@ NON_@@ OVER@@ L@@ APP@@ ING_@@ CON@@ TI@@ GU@@ OU@@ S@@ _SUB_@@ ARRAY@@ S | void k@@ max ( int arr [ ] , int k , int n ) { for ( int c = 0 ; c < k ; c ++ ) { int max_@@ so@@ _f@@ ar = numeric_limits < int > :: min ( ) ; int max_@@ here = 0 ; int start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_@@ here += arr [ i ] ; if ( max_@@ so@@ _f@@ ar < max_@@ here ) { max_@@ so@@ _f@@ ar = max_@@ here ; start = s ; end = i ; } if ( max_@@ here < 0 ) { max_@@ here = 0 ; s = i + 1 ; } } cout << " Maximum ▁ non - overlapping ▁ sub - array ▁ sum " << ( c + 1 ) << " : ▁ " << max_@@ so@@ _f@@ ar << " , ▁ starting ▁ index : ▁ " << start << " , ▁ ending ▁ index : ▁ " << end << " . " << endl ; for ( int l = start ; l <= end ; l ++ ) arr [ l ] = numeric_limits < int > :: min ( ) ; } cout << endl ; }
DISTAN@@ CE_@@ NEARE@@ ST_@@ CELL_@@ 1_@@ BINARY_@@ MATRIX | void print@@ Distance ( int mat [ N ] [ M ] ) { int ans [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) ans [ i ] [ j ] = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) for ( int l = 0 ; l < M ; l ++ ) { if ( mat [ k ] [ l ] == 1 ) ans [ i ] [ j ] = min ( ans [ i ] [ j ] , abs ( i - k ) + abs ( j - l ) ) ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) cout << ans [ i ] [ j ] << " ▁ " ; cout << endl ; } }
MINIMUM_@@ NUMBER_OF_@@ BRAC@@ KET_@@ REVER@@ S@@ AL@@ S_@@ NE@@ E@@ DED_@@ TO_@@ MAKE_@@ AN_@@ EXPRES@@ SION_@@ BAL@@ ANCE@@ D | int count@@ Min@@ Re@@ vers@@ als ( string expr ) { int len = expr . length ( ) ; if ( len % 2 ) return - 1 ; stack < char > s ; for ( int i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' } ' && ! s . empty ( ) ) { if ( s . top ( ) == ' { ' ) s . pop ( ) ; else s . push ( expr [ i ] ) ; } else s . push ( expr [ i ] ) ; } int red_@@ len = s . size ( ) ; int n = 0 ; while ( ! s . empty ( ) && s . top ( ) == ' { ' ) { s . pop ( ) ; n ++ ; } return ( red_@@ len / 2 + n % 2 ) ; }
FIRST_@@ NEGATIVE_@@ INTEGER_@@ EVER@@ Y_@@ WINDOW@@ _SIZE_@@ K_@@ 1 | void print@@ First@@ Negative@@ Integer ( int arr [ ] , int n , int k ) { deque < int > D@@ i ; int i ; for ( i = 0 ; i < k ; i ++ ) if ( arr [ i ] < 0 ) D@@ i . push_back ( i ) ; for ( ; i < n ; i ++ ) { if ( ! D@@ i . empty ( ) ) cout << arr [ D@@ i . front ( ) ] << " ▁ " ; else cout << "0" << " ▁ " ; while ( ( ! D@@ i . empty ( ) ) && D@@ i . front ( ) < ( i - k + 1 ) ) D@@ i . pop_front ( ) ; if ( arr [ i ] < 0 ) D@@ i . push_back ( i ) ; } if ( ! D@@ i . empty ( ) ) cout << arr [ D@@ i . front ( ) ] << " ▁ " ; else cout << "0" << " ▁ " ; }
MAG@@ IC@@ _S@@ QU@@ ARE | void generate@@ Square ( int n ) { int magic@@ Square [ n ] [ n ] ; memset ( magic@@ Square , 0 , sizeof ( magic@@ Square ) ) ; int i = n / 2 ; int j = n - 1 ; for ( int num = 1 ; num <= n * n ; ) { if ( i == - 1 && j == n ) { j = n - 2 ; i = 0 ; } else { if ( j == n ) j = 0 ; if ( i < 0 ) i = n - 1 ; } if ( magic@@ Square [ i ] [ j ] ) { j -= 2 ; i ++ ; continue ; } else magic@@ Square [ i ] [ j ] = num ++ ; j ++ ; i -- ; } cout << " The ▁ Magic ▁ Square ▁ for ▁ n = " << n << " : \n Sum ▁ of ▁ " " each ▁ row ▁ or ▁ column ▁ " << n * ( n * n + 1 ) / 2 << " : \n \n " ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) cout << magic@@ Square [ i ] [ j ] << " ▁ " ; cout << endl ; } }
PROGRAM_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENTS_@@ TABLE | int print@@ binomial ( int max ) { for ( int m = 0 ; m <= max ; m ++ ) { printf ( " % 2d " , m ) ; int bin@@ om = 1 ; for ( int x = 0 ; x <= m ; x ++ ) { if ( m != 0 && x != 0 ) bin@@ om = bin@@ om * ( m - x + 1 ) / x ; printf ( " % 4d " , bin@@ om ) ; } printf ( " \n " ) ; } }
CH@@ INE@@ SE_@@ RE@@ MA@@ INDE@@ R_@@ THE@@ O@@ RE@@ M@@ _SET_@@ 1_@@ INTRO@@ DUC@@ TION | int find@@ Min@@ X ( int num [ ] , int rem [ ] , int k ) { int x = 1 ; while ( true ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } return x ; }
MINIMUM_@@ NUMBER_@@ POINT@@ S_@@ REMO@@ VED_@@ GET_@@ RE@@ MAIN@@ ING_@@ POINT@@ S_@@ ONE@@ _SI@@ DE_@@ AXIS | int find@@ min ( Point p [ ] , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] . x <= 0 ) a ++ ; else if ( p [ i ] . x >= 0 ) b ++ ; if ( p [ i ] . y >= 0 ) c ++ ; else if ( p [ i ] . y <= 0 ) d ++ ; } return min ( { a , b , c , d } ) ; }
REPL@@ ACE_@@ OC@@ CURR@@ EN@@ CES_@@ STRING_@@ AB_@@ C_@@ WITH@@ OUT_@@ USING_@@ EX@@ TRA@@ _SPACE | void translate ( char * str ) { if ( str [ 0 ] == '' ) return ; for ( int i = 1 ; str [ i ] != '' ; i ++ ) { if ( str [ i - 1 ] == ' A ' && str [ i ] == ' B ' ) { str [ i - 1 ] = ' C ' ; for ( int j = i ; str [ j ] != '' ; j ++ ) str [ j ] = str [ j + 1 ] ; } } return ; }
PAIR@@ S_@@ OF_@@ POSITIVE_@@ NEGATIVE_@@ VALU@@ ES_@@ IN_@@ AN_@@ ARRAY | void print@@ Pairs ( int arr [ ] , int n ) { vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) v . push_back ( abs ( arr [ i ] ) ) ; if ( v . size ( ) == 0 ) return ; sort ( v . begin ( ) , v . end ( ) ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << - v [ i ] << " ▁ " << v [ i ] ; }
NON_@@ REPE@@ ATING_@@ ELEMENT_@@ 1 | int first@@ Non@@ Repe@@ ating ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; for ( int i = 0 ; i < n ; i ++ ) if ( mp [ arr [ i ] ] == 1 ) return arr [ i ] ; return - 1 ; }
PRINT_@@ FI@@ BON@@ AC@@ CI@@ _SERI@@ ES_@@ REVERSE_@@ ORDER | void reverse@@ Fi@@ bon@@ ac@@ ci ( int n ) { int a [ n ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { cout << a [ i ] << " ▁ " ; } }
FIND_@@ MINIMUM_@@ DIFF@@ ER@@ ENCE_@@ PA@@ IR_@@ 1 | int find@@ Min@@ Diff ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int diff = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }
MINIMUM_@@ NUMBER_@@ PLAT@@ FOR@@ MS_@@ REQUIRED_@@ RA@@ IL@@ WAY@@ BUS_@@ ST@@ ATION | int find@@ Platform ( int arr [ ] , int dep [ ] , int n ) { sort ( arr , arr + n ) ; sort ( dep , dep + n ) ; int plat@@ _@@ needed = 1 , result = 1 ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arr [ i ] <= dep [ j ] ) { plat@@ _@@ needed ++ ; i ++ ; if ( plat@@ _@@ needed > result ) result = plat@@ _@@ needed ; } else { plat@@ _@@ needed -- ; j ++ ; } } return result ; }
MULTIP@@ LIC@@ ATI@@ VE_@@ INVER@@ SE_@@ UN@@ DER_@@ MODUL@@ O_@@ M_@@ 1 | int mod@@ Inverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m , a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; }
NUMBER_@@ N_@@ DIG@@ IT_@@ STE@@ PP@@ ING_@@ NUMB@@ ERS | long long answer ( int n ) { int dp [ n + 1 ] [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } long long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; }
CREATE_@@ A_@@ MATRIX_@@ WITH_@@ ALTER@@ N@@ ATING_@@ REC@@ TA@@ NG@@ LES_@@ OF_@@ 0_@@ AND_@@ X | void fill@@ 0@@ X ( int m , int n ) { int i , k = 0 , l = 0 ; int r = m , c = n ; char a [ m ] [ n ] ; char x = ' X ' ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) a [ k ] [ i ] = x ; k ++ ; for ( i = k ; i < m ; ++ i ) a [ i ] [ n - 1 ] = x ; n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) a [ m - 1 ] [ i ] = x ; m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) a [ i ] [ l ] = x ; l ++ ; } x = ( x == '0' ) ? ' X ' : '0' ; } for ( i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) printf ( " % c ▁ " , a [ i ] [ j ] ) ; printf ( " \n " ) ; } }
FIN@@ D_S@@ UM_@@ UNI@@ QUE_@@ SUB_@@ ARRA@@ Y_S@@ UM_@@ GI@@ V@@ EN_@@ ARRAY | long long int find@@ Sub@@ array@@ Sum ( int arr [ ] , int n ) { int res = 0 ; unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ j ] ; m [ sum ] ++ ; } } for ( auto x : m ) if ( x . second == 1 ) res += x . first ; return res ; }
REVERSE_@@ A_@@ STRING_@@ USING_@@ RECUR@@ SION | void reverse ( string str ) { if ( str . size ( ) == 0 ) { return ; } reverse ( str . substr ( 1 ) ) ; cout << str [ 0 ] ; }
PRINT@@ ING_@@ ITE@@ MS_@@ 01_@@ KN@@ AP@@ S@@ ACK | void print@@ kn@@ ap@@ S@@ ack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } int res = K [ n ] [ W ] ; printf ( " % d \n " , res ) ; w = W ; for ( i = n ; i > 0 && res > 0 ; i -- ) { if ( res == K [ i - 1 ] [ w ] ) continue ; else { printf ( " % d ▁ " , wt [ i - 1 ] ) ; res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } }
FIND_@@ LAR@@ GE@@ ST_@@ PRI@@ ME_@@ FAC@@ TOR_@@ NUMBER | long long max@@ Prime@@ Factors ( long long n ) { long long max@@ Prime = - 1 ; while ( n % 2 == 0 ) { max@@ Prime = 2 ; n >>= 1 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { max@@ Prime = i ; n = n / i ; } } if ( n > 2 ) max@@ Prime = n ; return max@@ Prime ; }
FIND_@@ THE_@@ ELEMENT_@@ BEFORE_@@ WHI@@ CH_@@ ALL_@@ THE_@@ ELEMEN@@ TS_@@ ARE_@@ SM@@ ALL@@ ER_@@ TH@@ AN_@@ IT_@@ AND_@@ AFTER_@@ WHI@@ CH_@@ ALL_@@ ARE_@@ GREATER_@@ TH@@ AN_@@ IT | int findElement ( int arr [ ] , int n ) { int left@@ Max [ n ] ; left@@ Max [ 0 ] = INT_@@ MIN ; for ( int i = 1 ; i < n ; i ++ ) left@@ Max [ i ] = max ( left@@ Max [ i - 1 ] , arr [ i - 1 ] ) ; int right@@ Min = INT_MAX ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( left@@ Max [ i ] < arr [ i ] && right@@ Min > arr [ i ] ) return i ; right@@ Min = min ( right@@ Min , arr [ i ] ) ; } return - 1 ; }
COMMON_@@ CHARAC@@ TER@@ S_@@ N_@@ STRINGS | void common@@ Characters ( string str [ ] , int n ) { bool prim [ MAX_@@ CHAR ] ; memset ( prim , true , sizeof ( prim ) ) ; for ( int i = 0 ; i < n ; i ++ ) { bool sec [ MAX_@@ CHAR ] = { false } ; for ( int j = 0 ; str [ i ] [ j ] ; j ++ ) { if ( prim [ str [ i ] [ j ] - ' a ' ] ) sec [ str [ i ] [ j ] - ' a ' ] = true ; } memcpy ( prim , sec , MAX_@@ CHAR ) ; } for ( int i = 0 ; i < 26 ; i ++ ) if ( prim [ i ] ) printf ( " % c ▁ " , i + ' a ' ) ; }
MIN@@ IM@@ AL_@@ MOVE@@ S_@@ FORM_@@ STRING_@@ ADD@@ ING_@@ CHARAC@@ TER@@ S_@@ APP@@ END@@ ING_@@ STRING | int minim@@ al@@ Steps ( string s , int n ) { int dp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = INT_MAX ; string s1 = " " , s2 = " " ; dp [ 0 ] = 1 ; s1 += s [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s1 += s [ i ] ; s2 = s . substr ( i + 1 , i + 1 ) ; dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; if ( s1 == s2 ) dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) ; } return dp [ n - 1 ] ; }
S@@ UM_@@ MATRIX_@@ ELEMENT_@@ ABSOL@@ UTE_@@ DIFF@@ ER@@ ENCE_@@ ROW_@@ COLUMN_@@ NUMB@@ ERS_@@ 1 | int find@@ Sum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
FIND_@@ FREQU@@ ENCY_@@ EV@@ EN_@@ OD@@ D_@@ NUMB@@ ERS_@@ MATRIX | void freq ( int ar [ ] [ MAX ] , int m , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } printf ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = ▁ % d ▁ \n " , odd ) ; printf ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = ▁ % d ▁ \n " , even ) ; }
COUNT_@@ SUB@@ ARRAY@@ S_@@ WITH@@ _S@@ AME_@@ EV@@ EN_@@ AND_@@ OD@@ D_@@ ELEMENTS | int count@@ Sub@@ arrays ( int arr [ ] , int n ) { int difference = 0 ; int ans = 0 ; int hash_@@ positive [ n + 1 ] , hash_@@ negative [ n + 1 ] ; fill_@@ n ( hash_@@ positive , n + 1 , 0 ) ; fill_@@ n ( hash_@@ negative , n + 1 , 0 ) ; hash_@@ positive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 == 1 ) difference ++ ; else difference -- ; if ( difference < 0 ) { ans += hash_@@ negative [ - difference ] ; hash_@@ negative [ - difference ] ++ ; } else { ans += hash_@@ positive [ difference ] ; hash_@@ positive [ difference ] ++ ; } } return ans ; }
PAS@@ CAL_@@ TRIANGLE_@@ 1 | void print@@ Pas@@ cal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { cout << C << " ▁ " ; C = C * ( line - i ) / i ; } cout << " \n " ; } }
NUMBER_OF_@@ TRIANG@@ LES_@@ IN_@@ A_@@ PLA@@ NE_@@ IF_@@ NO_@@ MORE_@@ TH@@ AN_@@ TWO_@@ POINT@@ S_@@ ARE_@@ COL@@ LINEAR | int count@@ NumberOf@@ Triangles ( int n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }
MERGE_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S_@@ O@@ 1_@@ EX@@ TRA@@ _SPACE | void merge ( int ar@@ 1 [ ] , int ar@@ 2 [ ] , int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j , last = ar@@ 1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && ar@@ 1 [ j ] > ar@@ 2 [ i ] ; j -- ) ar@@ 1 [ j + 1 ] = ar@@ 1 [ j ] ; if ( j != m - 2 || last > ar@@ 2 [ i ] ) { ar@@ 1 [ j + 1 ] = ar@@ 2 [ i ] ; ar@@ 2 [ i ] = last ; } } }
NEW@@ MAN@@ _SH@@ AN@@ KS_@@ WI@@ LLI@@ AM@@ S_@@ PRI@@ ME | int n@@ sw@@ p ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return 2 * n@@ sw@@ p ( n - 1 ) + n@@ sw@@ p ( n - 2 ) ; }
SM@@ ALLE@@ ST_@@ OF_@@ THRE@@ E_@@ INTEG@@ ERS_@@ WITH@@ OUT_@@ COMP@@ ARIS@@ ON_@@ OPER@@ ATORS | int smallest ( int x , int y , int z ) { int c = 0 ; while ( x && y && z ) { x -- ; y -- ; z -- ; c ++ ; } return c ; }
COUNT_@@ PAIR@@ S_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL_@@ GI@@ V@@ EN_@@ VALUE_@@ X | int count@@ Pairs ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( ar@@ r1 [ i ] + ar@@ r2 [ j ] ) == x ) count ++ ; return count ; }
SORT_@@ ARRAY_@@ AP@@ PL@@ Y@@ ING_@@ GI@@ V@@ EN_@@ EQU@@ ATION | void sort@@ Array ( int arr [ ] , int n , int A , int B , int C ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ] + C ; int index , maximum = INT_@@ MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( maximum < arr [ i ] ) { index = i ; maximum = arr [ i ] ; } } int i = 0 , j = n - 1 ; int new_@@ arr [ n ] , k = 0 ; while ( i < index && j > index ) { if ( arr [ i ] < arr [ j ] ) new_@@ arr [ k ++ ] = arr [ i ++ ] ; else new_@@ arr [ k ++ ] = arr [ j -- ] ; } while ( i < index ) new_@@ arr [ k ++ ] = arr [ i ++ ] ; while ( j > index ) new_@@ arr [ k ++ ] = arr [ j -- ] ; new_@@ arr [ n - 1 ] = maximum ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = new_@@ arr [ i ] ; }
PROGRAM_@@ TO_@@ FIND_@@ THE_@@ AREA_@@ OF_@@ PEN@@ TAG@@ ON | float find@@ Area ( float a ) { float area ; area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) ) * a * a ) / 4 ; return area ; }
MAXI@@ MI@@ ZE_@@ S@@ UM_@@ CON@@ SEC@@ UTI@@ VE_@@ DIFF@@ ER@@ EN@@ CES_@@ CIRC@@ ULAR_@@ ARRAY | int max@@ Sum ( int arr [ ] , int n ) { int sum = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { sum -= ( 2 * arr [ i ] ) ; sum += ( 2 * arr [ n - i - 1 ] ) ; } return sum ; }
COUNT_@@ ARRAY@@ S_@@ CON@@ SEC@@ UTI@@ VE_@@ ELEMENT_@@ DIFF@@ ER@@ ENT_@@ VALUES | int coun@@ tar@@ ray ( int n , int k , int x ) { int dp [ MAX@@ N ] = { 0 } ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; }
SUM@@ _SERI@@ ES_@@ 12_@@ 32_@@ 5@@ 2_@@ 2@@ N_@@ 12 | int sum@@ Of@@ Series ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
FIND_@@ THE_@@ NEARE@@ ST@@ _S@@ MAL@@ LER_@@ NUMB@@ ERS_@@ ON_@@ LEFT_@@ SIDE_@@ IN_@@ AN_@@ ARRAY_@@ 1 | void print@@ Prev@@ S@@ mal@@ ler ( int arr [ ] , int n ) { stack < int > S ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! S . empty ( ) && S . top ( ) >= arr [ i ] ) S . pop ( ) ; if ( S . empty ( ) ) cout << " _ , ▁ " ; else cout << S . top ( ) << " , ▁ " ; S . push ( arr [ i ] ) ; } }
FIND_@@ NUMBER_OF_@@ TRIANG@@ LES_@@ POSSI@@ BLE_@@ 1 | void Count@@ Triangles ( vector < int > A ) { int n = A . size ( ) ; sort ( A . begin ( ) , A . end ( ) ) ; int count = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else l ++ ; } } cout << " No ▁ of ▁ possible ▁ solutions : ▁ " << count ; }
MAXIMUM_@@ GAME@@ S_@@ PLAY@@ ED_@@ WIN@@ NER | int max@@ Game@@ By@@ Win@@ ner ( int N ) { int dp [ N ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; int i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; }
NUMBER_@@ OF@@ _SUB@@ STRING@@ S_@@ WITH_@@ OD@@ D_@@ DECIMAL_@@ VALUE_@@ IN_@@ A_@@ BINARY_@@ STRING | int count@@ Sub@@ str ( string s ) { int n = s . length ( ) ; int aux@@ Arr [ n ] = { 0 } ; if ( s [ 0 ] == '1' ) aux@@ Arr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) aux@@ Arr [ i ] = aux@@ Arr [ i - 1 ] + 1 ; else aux@@ Arr [ i ] = aux@@ Arr [ i - 1 ] ; } int count = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) if ( s [ i ] == '1' ) count += aux@@ Arr [ i ] ; return count ; }
ELEMEN@@ TS_@@ TO_@@ BE_@@ AD@@ DE@@ D_S@@ O_@@ TH@@ AT_@@ ALL_@@ ELEMEN@@ TS_@@ OF_@@ A_@@ RANGE_@@ ARE_@@ PRES@@ ENT_@@ IN_@@ ARRAY_@@ 1 | int count@@ Num ( int arr [ ] , int n ) { unordered_@@ set < int > s ; int count = 0 , max@@ m = INT_@@ MIN , min@@ m = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { s . insert ( arr [ i ] ) ; if ( arr [ i ] < min@@ m ) min@@ m = arr [ i ] ; if ( arr [ i ] > max@@ m ) max@@ m = arr [ i ] ; } for ( int i = min@@ m ; i <= max@@ m ; i ++ ) if ( s . find ( arr [ i ] ) == s . end ( ) ) count ++ ; return count ; }
WRITE_@@ A_@@ C_@@ PROGRAM_@@ TO_@@ CAL@@ CUL@@ ATE_@@ PO@@ WX@@ N_@@ 1 | float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }
N_@@ TH_@@ TER@@ M@@ _SERI@@ ES_@@ 2_@@ 12_@@ 36@@ _@@ 8@@ 0_@@ 150 | int n@@ th@@ Term ( int n ) { return ( n * n ) + ( n * n * n ) ; }
FIND_@@ THE_@@ NUMBER_@@ OC@@ CURR@@ ING_@@ OD@@ D_@@ NUMBER_OF_@@ TIMES | int getO@@ dd@@ Occurren@@ ce ( int arr [ ] , int arr_@@ size ) { for ( int i = 0 ; i < arr_@@ size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_@@ size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; }
EF@@ FI@@ CI@@ ENT_@@ METHOD_@@ 2@@ S_@@ COMPLE@@ MENT_@@ BINARY_@@ STRING | string find@@ Tw@@ os@@ complement ( string str ) { int n = str . length ( ) ; int i ; for ( i = n - 1 ; i >= 0 ; i -- ) if ( str [ i ] == '1' ) break ; if ( i == - 1 ) return '1' + str ; for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( str [ k ] == '1' ) str [ k ] = '0' ; else str [ k ] = '1' ; } return str ; ; }
PAP@@ ER_@@ CU@@ T_@@ MINIMUM_@@ NUMBER@@ _S@@ QUAR@@ ES@@ _SET_@@ 2 | int minimum@@ Square ( int m , int n ) { int vertical@@ _min = INT_MAX ; int horizont@@ al_@@ min = INT_MAX ; if ( m == n ) return 1 ; if ( dp [ m ] [ n ] ) return dp [ m ] [ n ] ; for ( int i = 1 ; i <= m / 2 ; i ++ ) { horizont@@ al_@@ min = min ( minimum@@ Square ( i , n ) + minimum@@ Square ( m - i , n ) , horizont@@ al_@@ min ) ; } for ( int j = 1 ; j <= n / 2 ; j ++ ) { vertical@@ _min = min ( minimum@@ Square ( m , j ) + minimum@@ Square ( m , n - j ) , vertical@@ _min ) ; } dp [ m ] [ n ] = min ( vertical@@ _min , horizont@@ al_@@ min ) ; return dp [ m ] [ n ] ; }
MINI@@ MI@@ ZE_@@ ABSOL@@ UTE_@@ DIFF@@ ER@@ ENCE_@@ S@@ UM_@@ TW@@ O@@ _SUB@@ SETS | void sub@@ set@@ Difference ( int n ) { int s = n * ( n + 1 ) / 2 ; if ( n % 4 == 0 ) { cout << " First ▁ subset ▁ sum ▁ = ▁ " << s / 2 ; cout << " \n Second ▁ subset ▁ sum ▁ = ▁ " << s / 2 ; cout << " \n Difference ▁ = ▁ " << 0 ; } else { if ( n % 4 == 1 || n % 4 == 2 ) { cout << " First ▁ subset ▁ sum ▁ = ▁ " << s / 2 ; cout << " \n Second ▁ subset ▁ sum ▁ = ▁ " << s / 2 + 1 ; cout << " \n Difference ▁ = ▁ " << 1 ; } else { cout << " First ▁ subset ▁ sum ▁ = ▁ " << s / 2 ; cout << " \n Second ▁ subset ▁ sum ▁ = ▁ " << s / 2 ; cout << " \n Difference ▁ = ▁ " << 0 ; } } }
PROGRAM_@@ CAL@@ CUL@@ ATE_@@ VOLUME_@@ ELLIP@@ SO@@ ID | float volume@@ Of@@ Ellip@@ soid ( float r1 , float r2 , float r3 ) { float pi = 3.14 ; return 1.@@ 33 * pi * r1 * r2 * r3 ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 13@@ _C@@ UT@@ TING_@@ A_@@ RO@@ D | int cut@@ Ro@@ d ( int price [ ] , int n ) { int val [ n + 1 ] ; val [ 0 ] = 0 ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { int max_@@ val = INT_@@ MIN ; for ( j = 0 ; j < i ; j ++ ) max_@@ val = max ( max_@@ val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_@@ val ; } return val [ n ] ; }
RECUR@@ SIVE_@@ INSER@@ TION@@ _S@@ ORT | void insertion@@ Sort@@ Recursive ( int arr [ ] , int n ) { if ( n <= 1 ) return ; insertion@@ Sort@@ Recursive ( arr , n - 1 ) ; int last = arr [ n - 1 ] ; int j = n - 2 ; while ( j >= 0 && arr [ j ] > last ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = last ; }
FIND_@@ EXPRES@@ SION_@@ DUPLIC@@ ATE_@@ PARENTHE@@ SI@@ S_@@ NOT | bool find@@ Duplicate@@ parenthesis ( string str ) { stack < char > Stack ; for ( char ch : str ) { if ( ch == ' ) ' ) { char top = Stack . top ( ) ; Stack . pop ( ) ; int element@@ sIn@@ side = 0 ; while ( top != ' ( ' ) { element@@ sIn@@ side ++ ; top = Stack . top ( ) ; Stack . pop ( ) ; } if ( element@@ sIn@@ side < 1 ) { return 1 ; } } else Stack . push ( ch ) ; } return false ; }
FIND_@@ REPE@@ TI@@ TIVE_@@ ELEMENT_@@ 1_@@ N_@@ 1 | int find@@ Repe@@ ating ( int arr [ ] , int n ) { return accumulate ( arr , arr + n , 0 ) - ( ( n - 1 ) * n / 2 ) ; }
CHECK_@@ ARRAY_@@ CONTAIN@@ S_@@ CON@@ TI@@ GU@@ OUS_@@ INTEG@@ ERS_@@ DUPLIC@@ ATE@@ S_@@ ALLOWED | bool are@@ Elements@@ Contigu@@ ous ( int arr [ ] , int n ) { int max = * max_@@ element ( arr , arr + n ) ; int min = * min_@@ element ( arr , arr + n ) ; int m = max - min + 1 ; if ( m > n ) return false ; bool visited [ m ] ; memset ( visited , false , sizeof ( visited ) ) ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; }
LENGTH_@@ LON@@ GE@@ ST_@@ BAL@@ ANCE@@ D@@ _SUB@@ SEQU@@ ENCE_@@ 1 | int maxLength ( char s [ ] , int n ) { int invalid@@ Open@@ Br@@ aces = 0 ; int invalid@@ Close@@ Br@@ aces = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ( ' ) { invalid@@ Open@@ Br@@ aces ++ ; } else { if ( invalid@@ Open@@ Br@@ aces == 0 ) { invalid@@ Close@@ Br@@ aces ++ ; } else { invalid@@ Open@@ Br@@ aces -- ; } } } return ( n - ( invalid@@ Open@@ Br@@ aces + invalid@@ Close@@ Br@@ aces ) ) ; }
SUM@@ _SERI@@ ES_@@ ALTER@@ N@@ ATE_@@ SIGNE@@ D_S@@ QUAR@@ ES_@@ AP_@@ 1 | int se@@ i@@ res@@ Sum ( int n , int a [ ] ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }
EQU@@ ILI@@ BRI@@ UM_@@ INDEX_@@ OF_@@ AN_@@ ARRAY | int equi@@ lib@@ ri@@ um ( int arr [ ] , int n ) { int i , j ; int left@@ sum , right@@ sum ; for ( i = 0 ; i < n ; ++ i ) { left@@ sum = 0 ; for ( j = 0 ; j < i ; j ++ ) left@@ sum += arr [ j ] ; right@@ sum = 0 ; for ( j = i + 1 ; j < n ; j ++ ) right@@ sum += arr [ j ] ; if ( left@@ sum == right@@ sum ) return i ; } return - 1 ; }
COUNT_@@ WAY@@ S_@@ REACH_@@ N@@ TH_@@ ST@@ AI@@ R_@@ USING_@@ STEP_@@ 1_2_@@ 3 | public : int find@@ Step ( int n ) { if ( n == 1 || n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return find@@ Step ( n - 3 ) + find@@ Step ( n - 2 ) + find@@ Step ( n - 1 ) ; }
FIND_@@ MINIMUM_@@ NUMBER_OF_@@ CO@@ INS_@@ TH@@ AT_@@ MAKE_@@ A_@@ CHANGE | int min@@ Coins ( int coins [ ] , int m , int V ) { if ( V == 0 ) return 0 ; int res = INT_MAX ; for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { int sub_@@ res = min@@ Coins ( coins , m , V - coins [ i ] ) ; if ( sub_@@ res != INT_MAX && sub_@@ res + 1 < res ) res = sub_@@ res + 1 ; } } return res ; }
B@@ ELL_@@ NUMB@@ ERS_@@ NUMBER_OF_@@ WAY@@ S_TO_@@ PARTITION_@@ A@@ _SET | int b@@ ell@@ Number ( int n ) { int b@@ ell [ n + 1 ] [ n + 1 ] ; b@@ ell [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { b@@ ell [ i ] [ 0 ] = b@@ ell [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j <= i ; j ++ ) b@@ ell [ i ] [ j ] = b@@ ell [ i - 1 ] [ j - 1 ] + b@@ ell [ i ] [ j - 1 ] ; } return b@@ ell [ n ] [ 0 ] ; }
FIND_@@ ELEMENT_@@ GI@@ V@@ EN_@@ INDEX_@@ NUMBER_@@ ROTA@@ TIONS | int findElement ( int arr [ ] , int ranges [ ] [ 2 ] , int rot@@ ations , int index ) { for ( int i = rot@@ ations - 1 ; i >= 0 ; i -- ) { int left = ranges [ i ] [ 0 ] ; int right = ranges [ i ] [ 1 ] ; if ( left <= index && right >= index ) { if ( index == left ) index = right ; else index -- ; } } return arr [ index ] ; }
DY@@ CK_@@ PATH | int count@@ Dy@@ ck@@ Paths ( unsigned int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }
COUN@@ TING_@@ PAIR@@ S_@@ PERS@@ ON_@@ CAN_@@ FORM_@@ PA@@ IR_@@ ONE | int numberOf@@ W@@ ays ( int x ) { if ( x == 0 || x == 1 ) return 1 ; else return numberOf@@ W@@ ays ( x - 1 ) + ( x - 1 ) * numberOf@@ W@@ ays ( x - 2 ) ; }
PROGRAM_@@ DISPLAY_@@ A@@ STRO@@ LOG@@ IC@@ AL@@ _SIGN@@ _@@ ZO@@ DI@@ AC@@ _SIGN@@ _@@ GI@@ V@@ EN_@@ DATE_@@ B@@ IR@@ TH | void zo@@ di@@ ac_@@ sign ( int day , string month ) { string ast@@ ro_@@ sign = " " ; if ( month == " de@@ ce@@ mber " ) { if ( day < 22 ) ast@@ ro_@@ sign = " S@@ ag@@ it@@ t@@ ari@@ us " ; else ast@@ ro_@@ sign = " cap@@ ri@@ cor@@ n " ; } else if ( month == " j@@ anuary " ) { if ( day < 20 ) ast@@ ro_@@ sign = " Cap@@ ri@@ cor@@ n " ; else ast@@ ro_@@ sign = " a@@ qu@@ ari@@ us " ; } else if ( month == " fe@@ bruary " ) { if ( day < 19 ) ast@@ ro_@@ sign = " A@@ qu@@ ari@@ us " ; else ast@@ ro_@@ sign = " p@@ is@@ ces " ; } else if ( month == " mar@@ ch " ) { if ( day < 21 ) ast@@ ro_@@ sign = " P@@ is@@ ces " ; else ast@@ ro_@@ sign = " aries " ; } else if ( month == " ap@@ ri@@ l " ) { if ( day < 20 ) ast@@ ro_@@ sign = " Ari@@ es " ; else ast@@ ro_@@ sign = " ta@@ ur@@ us " ; } else if ( month == " may " ) { if ( day < 21 ) ast@@ ro_@@ sign = " Ta@@ ur@@ us " ; else ast@@ ro_@@ sign = " ge@@ mini " ; } else if ( month == " jun@@ e " ) { if ( day < 21 ) ast@@ ro_@@ sign = " Ge@@ mini " ; else ast@@ ro_@@ sign = " can@@ cer " ; } else if ( month == " j@@ uly " ) { if ( day < 23 ) ast@@ ro_@@ sign = " Can@@ cer " ; else ast@@ ro_@@ sign = " le@@ o " ; } else if ( month == " au@@ gu@@ st " ) { if ( day < 23 ) ast@@ ro_@@ sign = " Le@@ o " ; else ast@@ ro_@@ sign = " vir@@ go " ; } else if ( month == " sep@@ tember " ) { if ( day < 23 ) ast@@ ro_@@ sign = " Vi@@ r@@ go " ; else ast@@ ro_@@ sign = " libr@@ a " ; } else if ( month == " oc@@ to@@ ber " ) { if ( day < 23 ) ast@@ ro_@@ sign = " Libr@@ a " ; else ast@@ ro_@@ sign = " scor@@ p@@ io " ; } else if ( month == " no@@ vember " ) { if ( day < 22 ) ast@@ ro_@@ sign = " scor@@ p@@ io " ; else ast@@ ro_@@ sign = " sag@@ it@@ t@@ ari@@ us " ; } cout << ast@@ ro_@@ sign ; }
PROGRAM_@@ REVERSE_@@ STRING_@@ ITER@@ ATI@@ VE_@@ RECUR@@ SIVE_@@ 2 | void recursive@@ Reverse ( string & str , int i = 0 ) { int n = str . length ( ) ; if ( i == n / 2 ) return ; swap ( str [ i ] , str [ n - i - 1 ] ) ; recursive@@ Reverse ( str , i + 1 ) ; }
K_@@ TH_@@ DIG@@ IT_@@ RAI@@ SED_@@ POWER_@@ B | int k@@ th@@ digit ( int a , int b , int k ) { int p = pow ( a , b ) ; int count = 0 ; while ( p > 0 && count < k ) { int rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; }
SM@@ ALLE@@ ST_@@ DIFF@@ ER@@ ENCE_@@ PA@@ IR_@@ VALU@@ ES_@@ TWO_@@ UN@@ SOR@@ TED_@@ ARRAY@@ S | int find@@ S@@ malle@@ st@@ Difference ( int A [ ] , int B [ ] , int m , int n ) { sort ( A , A + m ) ; sort ( B , B + n ) ; int a = 0 , b = 0 ; int result = INT_MAX ; while ( a < m && b < n ) { if ( abs ( A [ a ] - B [ b ] ) < result ) result = abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
MAXIMUM_@@ AREA_@@ REC@@ TAN@@ GLE_@@ PIC@@ KING_@@ FOUR@@ _SI@@ DES_@@ ARRAY_@@ 1 | int find@@ Area ( int arr [ ] , int n ) { unordered_@@ set < int > s ; int first = 0 , second = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( arr [ i ] ) == s . end ( ) ) { s . insert ( arr [ i ] ) ; continue ; } if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } return ( first * second ) ; }
PROGRAM_@@ PAGE_@@ REPLACE@@ MENT_@@ ALGORITH@@ MS@@ _SET_@@ 2_@@ FIFO | int page@@ Fa@@ ults ( int pages [ ] , int n , int capacity ) { unordered_@@ set < int > s ; queue < int > indexes ; int page_@@ fa@@ ults = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . size ( ) < capacity ) { if ( s . find ( pages [ i ] ) == s . end ( ) ) { s . insert ( pages [ i ] ) ; page_@@ fa@@ ults ++ ; indexes . push ( pages [ i ] ) ; } } else { if ( s . find ( pages [ i ] ) == s . end ( ) ) { int val = indexes . front ( ) ; indexes . pop ( ) ; s . erase ( val ) ; s . insert ( pages [ i ] ) ; indexes . push ( pages [ i ] ) ; page_@@ fa@@ ults ++ ; } } } return page_@@ fa@@ ults ; }
FIND_@@ LAR@@ GE@@ ST_@@ D_@@ IN_@@ ARRAY@@ _SU@@ CH_@@ TH@@ AT_@@ A_@@ B_@@ C_@@ D_@@ 1 | int find@@ Four@@ Elements ( int arr [ ] , int n ) { unordered_map < int , pair < int , int > > mp ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) mp [ arr [ i ] + arr [ j ] ] = { i , j } ; int d = INT_@@ MIN ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_@@ diff = abs ( arr [ i ] - arr [ j ] ) ; if ( mp . find ( abs_@@ diff ) != mp . end ( ) ) { pair < int , int > p = mp [ abs_@@ diff ] ; if ( p . first != i && p . first != j && p . second != i && p . second != j ) d = max ( d , max ( arr [ i ] , arr [ j ] ) ) ; } } } return d ; }
PRINT_@@ GI@@ V@@ EN_@@ MATRIX_@@ REVERSE_@@ SPIR@@ AL_@@ FORM | void Reverse@@ spir@@ al@@ Print ( int m , int n , int a [ R ] [ C ] ) { long int b [ 100 ] ; int i , k = 0 , l = 0 ; int z = 0 ; int size = m * n ; while ( k < m && l < n ) { int val ; for ( i = l ; i < n ; ++ i ) { val = a [ k ] [ i ] ; b [ z ] = val ; ++ z ; } k ++ ; for ( i = k ; i < m ; ++ i ) { val = a [ i ] [ n - 1 ] ; b [ z ] = val ; ++ z ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { val = a [ m - 1 ] [ i ] ; b [ z ] = val ; ++ z ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { val = a [ i ] [ l ] ; b [ z ] = val ; ++ z ; } l ++ ; } } for ( int i = size - 1 ; i >= 0 ; -- i ) { cout << b [ i ] << " ▁ " ; } }
NUMBER_@@ N_@@ DIG@@ IT@@ S_@@ NON_@@ DECRE@@ AS@@ ING_@@ INTEG@@ ERS | int non@@ Dec@@ Num@@ s ( int n ) { int a [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; }
LON@@ GE@@ ST_@@ EV@@ EN_@@ LENGTH@@ _SUB@@ STRING@@ _S@@ UM_@@ FIR@@ ST@@ _SECON@@ D_@@ HALF | int find@@ Length ( char * str ) { int n = strlen ( str ) ; int maxlen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j += 2 ) { int length = j - i + 1 ; int left@@ sum = 0 , right@@ sum = 0 ; for ( int k = 0 ; k < length / 2 ; k ++ ) { left@@ sum += ( str [ i + k ] - '0' ) ; right@@ sum += ( str [ i + k + length / 2 ] - '0' ) ; } if ( left@@ sum == right@@ sum && maxlen < length ) maxlen = length ; } } return maxlen ; }
PROGRAM_@@ WOR@@ ST_@@ FI@@ T_@@ ALGORITH@@ M_@@ MEMORY_@@ MAN@@ A@@ GEMENT | void wor@@ st@@ Fit ( int blockSize [ ] , int m , int process@@ Size [ ] , int n ) { int allocation [ n ] ; memset ( allocation , - 1 , sizeof ( allocation ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int w@@ st@@ Idx = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= process@@ Size [ i ] ) { if ( w@@ st@@ Idx == - 1 ) w@@ st@@ Idx = j ; else if ( blockSize [ w@@ st@@ Idx ] < blockSize [ j ] ) w@@ st@@ Idx = j ; } } if ( w@@ st@@ Idx != - 1 ) { allocation [ i ] = w@@ st@@ Idx ; blockSize [ w@@ st@@ Idx ] -= process@@ Size [ i ] ; } } cout << " \n Process ▁ No . \t@@ Process ▁ Size@@ \t@@ Block ▁ no . \n " ; for ( int i = 0 ; i < n ; i ++ ) { cout << " ▁ ▁ ▁ " << i + 1 << " \t\t " << process@@ Size [ i ] << " \t\t " ; if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 1 ; else cout << " Not ▁ Allocated " ; cout << endl ; } }
SUM@@ _SUB@@ SET@@ S@@ _SET_@@ FOR@@ MED_@@ FIRST_@@ N_@@ N@@ ATUR@@ AL_@@ NUMB@@ ERS | unsigned long long find@@ Sum@@ Sub@@ sets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
ADD_@@ TWO_@@ NUMB@@ ERS_@@ WITH@@ OUT_@@ USING_@@ ARI@@ TH@@ ME@@ TIC_@@ OPER@@ ATORS | int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }
MAXIMUM_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENT_@@ TER@@ M_@@ VALUE | int max@@ coeffici@@ ent@@ value ( int n ) { int C [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int max@@ value = 0 ; for ( int i = 0 ; i <= n ; i ++ ) max@@ value = max ( max@@ value , C [ n ] [ i ] ) ; return max@@ value ; }
E@@ UL@@ ERI@@ AN_@@ PATH_@@ UN@@ DIREC@@ TED_@@ GRAP@@ H | void find@@ path ( int graph [ ] [ 5 ] , int n ) { vector < int > nu@@ mo@@ f@@ adj ; for ( int i = 0 ; i < n ; i ++ ) nu@@ mo@@ f@@ adj . push_back ( accumulate ( graph [ i ] , graph [ i ] + 5 , 0 ) ) ; int start@@ point = 0 , nu@@ mo@@ fo@@ dd = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( nu@@ mo@@ f@@ adj [ i ] % 2 == 1 ) { nu@@ mo@@ fo@@ dd ++ ; start@@ point = i ; } } if ( nu@@ mo@@ fo@@ dd > 2 ) { cout << " No ▁ Solution " << endl ; return ; } stack < int > stack ; vector < int > path ; int cur = start@@ point ; while ( ! stack . empty ( ) or accumulate ( graph [ cur ] , graph [ cur ] + 5 , 0 ) != 0 ) { if ( accumulate ( graph [ cur ] , graph [ cur ] + 5 , 0 ) == 0 ) { path . push_back ( cur ) ; cur = stack . top ( ) ; stack . pop ( ) ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( graph [ cur ] [ i ] == 1 ) { stack . push ( cur ) ; graph [ cur ] [ i ] = 0 ; graph [ i ] [ cur ] = 0 ; cur = i ; break ; } } } } for ( auto ele : path ) cout << ele << " ▁ - > ▁ " ; cout << cur << endl ; }
RECUR@@ SIVE_@@ SOLU@@ TION_@@ COUNT_@@ SUB@@ STRING@@ S_@@ FIRST_@@ LAST_@@ CHARAC@@ TERS | int count@@ Sub@@ strs ( string str , int i , int j , int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; int res = count@@ Sub@@ strs ( str , i + 1 , j , n - 1 ) + count@@ Sub@@ strs ( str , i , j - 1 , n - 1 ) - count@@ Sub@@ strs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str [ i ] == str [ j ] ) res ++ ; return res ; }
FIND_@@ NUMBER_@@ TIME@@ S_@@ STRING_@@ OC@@ CUR@@ S_@@ GI@@ V@@ EN_@@ STRING_@@ 1 | int count ( string a , string b ) { int m = a . length ( ) ; int n = b . length ( ) ; int lookup [ m + 1 ] [ n + 1 ] = { { 0 } } ; for ( int i = 0 ; i <= n ; ++ i ) lookup [ 0 ] [ i ] = 0 ; for ( int i = 0 ; i <= m ; ++ i ) lookup [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ; else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ; } } return lookup [ m ] [ n ] ; }
AREA_@@ OF_@@ A_@@ POLYG@@ ON_@@ WITH_@@ GI@@ V@@ EN_@@ N_@@ ORDE@@ RED_@@ VER@@ TIC@@ ES | double polygon@@ Area ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return abs ( area / 2.0 ) ; }
PRINT_@@ POSSI@@ BLE_@@ SUM@@ S_@@ CON@@ SEC@@ UTI@@ VE_@@ NUMBER@@ S_S@@ UM_@@ N | void find@@ Con@@ sec@@ utive ( int N ) { int start = 1 , end = ( N + 1 ) / 2 ; while ( start < end ) { int sum = 0 ; for ( int i = start ; i <= end ; i ++ ) { sum = sum + i ; if ( sum == N ) { for ( int j = start ; j <= i ; j ++ ) printf ( " % d ▁ " , j ) ; printf ( " \n " ) ; break ; } if ( sum > N ) break ; } sum = 0 ; start ++ ; } }
BAL@@ AN@@ CED_@@ EXPRES@@ SION@@ S@@ _SU@@ CH_@@ TH@@ AT_@@ GI@@ V@@ EN_@@ POSI@@ TIONS_@@ HAVE_@@ OPEN@@ ING_@@ BRAC@@ KETS | long long arrange@@ Br@@ aces ( int n , int pos [ ] , int k ) { bool h [ N ] ; int dp [ N ] [ N ] ; memset ( h , 0 , sizeof h ) ; memset ( dp , 0 , sizeof dp ) ; for ( int i = 0 ; i < k ; i ++ ) h [ pos [ i ] ] = 1 ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { for ( int j = 0 ; j <= 2 * n ; j ++ ) { if ( h [ i ] ) { if ( j != 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 0 ; } else { if ( j != 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } } } return dp [ 2 * n ] [ 0 ] ; }
GI@@ V@@ EN_@@ 1@@ S_@@ 2@@ S_@@ 3@@ S_@@ KS_@@ PRINT_@@ ZI@@ G_@@ Z@@ A@@ G_@@ WAY | void Z@@ ig@@ Z@@ ag ( int rows , int columns , int numbers [ ] ) { int k = 0 ; int arr [ rows ] [ columns ] ; for ( int i = 0 ; i < rows ; i ++ ) { if ( i % 2 == 0 ) { for ( int j = 0 ; j < columns and numbers [ k ] > 0 ; j ++ ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) k ++ ; } } else { for ( int j = columns - 1 ; j >= 0 and numbers [ k ] > 0 ; j -- ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) k ++ ; } } } for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns ; j ++ ) cout << arr [ i ] [ j ] << " ▁ " ; cout << endl ; } }
CONVERT_@@ STRING_@@ BIN@@ AR@@ Y@@ _SEQU@@ ENCE | void str@@ To@@ Binary ( string s ) { int n = s . length ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { int val = int ( s [ i ] ) ; string bin = " " ; while ( val > 0 ) { ( val % 2 ) ? bin . push_back ( '1' ) : bin . push_back ( '0' ) ; val /= 2 ; } reverse ( bin . begin ( ) , bin . end ( ) ) ; cout << bin << " ▁ " ; } }
L@@ UC@@ K@@ Y_@@ NUMB@@ ERS | int bool is@@ Lu@@ ck@@ y ( int n ) { static int counter = 2 ; int next_@@ position = n ; if ( counter > n ) return 1 ; if ( n % counter == 0 ) return 0 ; next_@@ position -= next_@@ position / counter ; counter ++ ; return is@@ Lu@@ ck@@ y ( next_@@ position ) ; }
SM@@ ALLE@@ ST@@ _S@@ UM_@@ CON@@ TI@@ GU@@ OU@@ S@@ _SUB@@ ARRAY | int smalle@@ st@@ Sum@@ Sub@@ arr ( int arr [ ] , int n ) { int min_@@ ending_@@ here = INT_MAX ; int min_@@ so@@ _f@@ ar = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_@@ ending_@@ here > 0 ) min_@@ ending_@@ here = arr [ i ] ; else min_@@ ending_@@ here += arr [ i ] ; min_@@ so@@ _f@@ ar = min ( min_@@ so@@ _f@@ ar , min_@@ ending_@@ here ) ; } return min_@@ so@@ _f@@ ar ; }
PRINT_@@ N_@@ TER@@ MS_@@ NEW@@ MAN_@@ CON@@ WAY@@ _SEQU@@ ENCE | void sequence ( int n ) { int f [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; cout << f [ 1 ] << " ▁ " << f [ 2 ] << " ▁ " ; for ( int i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; cout << f [ i ] << " ▁ " ; } }
MASTER_@@ THE@@ O@@ RE@@ M@@ _SUB@@ TRAC@@ T_@@ CON@@ QU@@ ER_@@ RE@@ CURR@@ EN@@ CES | int fi@@ b ( int n ) { if ( n <= 1 ) return n ; return fi@@ b ( n - 1 ) + fi@@ b ( n - 2 ) ; }
MINIMUM_@@ CO@@ ST_@@ MAKE_@@ ARRAY@@ _SIZE_@@ 1_@@ REMO@@ V@@ ING_@@ L@@ ARG@@ ER_@@ PAIR@@ S | int cost ( int a [ ] , int n ) { return ( n - 1 ) * ( * min_@@ element ( a , a + n ) ) ; }
CHO@@ COL@@ ATE_@@ DISTRIBU@@ TION_@@ PRO@@ BLE@@ M | int find@@ Min@@ Diff ( int arr [ ] , int n , int m ) { if ( m == 0 || n == 0 ) return 0 ; sort ( arr , arr + n ) ; if ( n < m ) return - 1 ; int min_@@ diff = INT_MAX ; int first = 0 , last = 0 ; for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_@@ diff ) { min_@@ diff = diff ; first = i ; last = i + m - 1 ; } } return ( arr [ last ] - arr [ first ] ) ; }
FIND_@@ ONE_@@ EXTRA_@@ CHARACTER_@@ STRING_@@ 1 | char find@@ Extra@@ Char@@ c@@ ter ( string str@@ A , string str@@ B ) { int res = 0 , i ; for ( i = 0 ; i < str@@ A . length ( ) ; i ++ ) { res ^= str@@ A [ i ] ; } for ( i = 0 ; i < str@@ B . length ( ) ; i ++ ) { res ^= str@@ B [ i ] ; } return ( ( char ) ( res ) ) ; }
CHECK_@@ WHE@@ THER_@@ TWO_@@ STRING@@ S_@@ ARE_@@ AN@@ AG@@ RAM_@@ OF_@@ E@@ ACH@@ _@@ OTHER | bool are@@ An@@ agram ( string str1 , string str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; if ( n1 != n2 ) return false ; sort ( str1 . begin ( ) , str1 . end ( ) ) ; sort ( str2 . begin ( ) , str2 . end ( ) ) ; for ( int i = 0 ; i < n1 ; i ++ ) if ( str1 [ i ] != str2 [ i ] ) return false ; return true ; }
CAL@@ CUL@@ ATE_@@ MAXIMUM_@@ VALUE_@@ US@@ ING@@ _SIGN@@ _@@ TWO_@@ NUMB@@ ERS_@@ STRING | int calc@@ Max@@ Value ( string str ) { int res = str [ 0 ] - '0' ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == '0' || str [ i ] == '1' || res < 2 ) res += ( str [ i ] - '0' ) ; else res *= ( str [ i ] - '0' ) ; } return res ; }
FIN@@ D_S@@ UM_@@ MODUL@@ O_@@ K_@@ FIRST_@@ N_@@ N@@ ATUR@@ AL_@@ NUMBER | int find@@ Sum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }
DISTRIBU@@ TING_@@ ITE@@ MS_@@ PERS@@ ON_@@ CANNOT_@@ TA@@ KE_@@ TWO_@@ ITE@@ MS_@@ TYPE_@@ 1 | bool check@@ Count ( int arr [ ] , int n , int k ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < n ; i ++ ) hash [ arr [ i ] ] ++ ; for ( auto x : hash ) if ( x . second > 2 * k ) return false ; return true ; }
SEARCH_@@ IN_@@ ROW_@@ WI@@ SE_@@ AND_@@ COLUMN_@@ WI@@ SE_@@ SOR@@ TED_@@ MATRIX | int search ( int mat [ 4 ] [ 4 ] , int n , int x ) { if ( n == 0 ) return - 1 ; int smallest = a [ 0 ] [ 0 ] , largest = a [ n - 1 ] [ n - 1 ] ; if ( x < smallest || x > largest ) return - 1 ; int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { cout << " n ▁ Found ▁ at ▁ " << i << " , ▁ " << j ; return 1 ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } cout << " n ▁ Element ▁ not ▁ found " ; return 0 ; }
RETURN_@@ PREVI@@ OUS_@@ ELEMENT_@@ IN_@@ AN_@@ EXP@@ AND@@ ING_@@ MATRIX | string find@@ Left ( string str ) { int n = str . length ( ) ; while ( n -- ) { if ( str [ n ] == ' d ' ) { str [ n ] = ' c ' ; break ; } if ( str [ n ] == ' b ' ) { str [ n ] = ' a ' ; break ; } if ( str [ n ] == ' a ' ) str [ n ] = ' b ' ; else if ( str [ n ] == ' c ' ) str [ n ] = ' d ' ; } return str ; }
S@@ UM_@@ FAC@@ TOR@@ S_@@ NUMBER | int div@@ Sum ( int n ) { int result = 0 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } } return ( result + n + 1 ) ; }
HO@@ W_@@ CAN_@@ W@@ E_@@ S@@ UM_@@ THE_@@ DIG@@ IT@@ S_@@ OF_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ IN@@ _SIN@@ GLE_@@ STATE@@ MENT_@@ 2 | public : int sum@@ Digits ( int no ) { return no == 0 ? 0 : no % 10 + sum@@ Digits ( no / 10 ) ; }
CHECK_@@ POSSI@@ BLE_@@ SORT_@@ ARRAY_@@ CONDITION@@ AL@@ _SW@@ APP@@ ING_@@ AD@@ J@@ AC@@ ENT_@@ ALLOWED | bool checkFor@@ Sorting ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) swap ( arr [ i ] , arr [ i + 1 ] ) ; else return false ; } } return true ; }
SUP@@ ER_@@ PRI@@ ME | bool Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( int n , bool is@@ Prime [ ] ) { is@@ Prime [ 0 ] = is@@ Prime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) is@@ Prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( is@@ Prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) is@@ Prime [ i ] = false ; } } }
PROGRAM_@@ BINARY_@@ DECIMAL_@@ CON@@ VERSION_@@ 1 | int binary@@ To@@ Decimal ( string n ) { string num = n ; int dec_@@ value = 0 ; int base = 1 ; int len = num . length ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( num [ i ] == '1' ) dec_@@ value += base ; base = base * 2 ; } return dec_@@ value ; }
LE@@ ON@@ AR@@ DO_@@ NUMBER | int le@@ on@@ ar@@ do ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return le@@ on@@ ar@@ do ( n - 1 ) + le@@ on@@ ar@@ do ( n - 2 ) + 1 ; }
CHECK_@@ ARRAY_@@ CONTAIN@@ S_@@ CON@@ TI@@ GU@@ OUS_@@ INTEG@@ ERS_@@ DUPLIC@@ ATE@@ S_@@ ALLOWED_@@ 1 | bool are@@ Elements@@ Contigu@@ ous ( int arr [ ] , int n ) { unordered_@@ set < int > us ; for ( int i = 0 ; i < n ; i ++ ) us . insert ( arr [ i ] ) ; int count = 1 ; int curr_@@ ele = arr [ 0 ] - 1 ; while ( us . find ( curr_@@ ele ) != us . end ( ) ) { count ++ ; curr_@@ ele -- ; } curr_@@ ele = arr [ 0 ] + 1 ; while ( us . find ( curr_@@ ele ) != us . end ( ) ) { count ++ ; curr_@@ ele ++ ; } return ( count == ( int ) ( us . size ( ) ) ) ; }
SQU@@ ARE_@@ ROOT_@@ OF_@@ AN_@@ INTEGER | int floor@@ Sqrt ( int x ) { if ( x == 0 || x == 1 ) return x ; int i = 1 , result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; }
LE@@ XI@@ CO@@ GRAPHIC@@ AL@@ LY_@@ LAR@@ GE@@ ST@@ _SUB@@ SEQU@@ ENCE_@@ EVER@@ Y_@@ CHARACTER_@@ OC@@ CUR@@ S_@@ LEA@@ ST_@@ K_@@ TIMES | void sub@@ sequence ( char s [ ] , char t [ ] , int n , int k ) { int last = 0 , cnt = 0 , new_@@ last = 0 , size = 0 ; for ( char ch = ' z ' ; ch >= ' a ' ; ch -- ) { cnt = 0 ; for ( int i = last ; i < n ; i ++ ) { if ( s [ i ] == ch ) cnt ++ ; } if ( cnt >= k ) { for ( int i = last ; i < n ; i ++ ) { if ( s [ i ] == ch ) { t [ size ++ ] = ch ; new_@@ last = i ; } } last = new_@@ last ; } } t [ size ] = ' \0' ; }
RECUR@@ SI@@ VEL@@ Y_@@ BREAK_@@ NUMBER_@@ 3_@@ PAR@@ TS_@@ GET_@@ MAX@@ IM@@ UM@@ _S@@ UM | int break@@ Sum ( int n ) { if ( n == 0 || n == 1 ) return n ; return max ( ( break@@ Sum ( n / 2 ) + break@@ Sum ( n / 3 ) + break@@ Sum ( n / 4 ) ) , n ) ; }
MINIMUM_@@ NUMBER@@ _SW@@ AP@@ S_@@ REQUI@@ RE@@ D_S@@ ORT_@@ ARRAY | int min@@ Sw@@ aps ( int arr [ ] , int n ) { pair < int , int > arr@@ Pos [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr@@ Pos [ i ] . first = arr [ i ] ; arr@@ Pos [ i ] . second = i ; } sort ( arr@@ Pos , arr@@ Pos + n ) ; vector < bool > vis ( n , false ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || arr@@ Pos [ i ] . second == i ) continue ; int cycle@@ _size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = 1 ; j = arr@@ Pos [ j ] . second ; cycle@@ _size ++ ; } if ( cycle@@ _size > 0 ) { ans += ( cycle@@ _size - 1 ) ; } } return ans ; }
DIAG@@ ON@@ AL@@ LY_@@ DO@@ MIN@@ ANT_@@ MATRIX | bool is@@ DD@@ M ( int m [ N ] [ N ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += abs ( m [ i ] [ j ] ) ; sum -= abs ( m [ i ] [ i ] ) ; if ( abs ( m [ i ] [ i ] ) < sum ) return false ; } return true ; }
SP@@ LIT_@@ N_@@ MAXIMUM_@@ COMPOSI@@ TE_@@ NUMB@@ ERS | int count ( int n ) { if ( n < 4 ) return - 1 ; int rem = n % 4 ; if ( rem == 0 ) return n / 4 ; if ( rem == 1 ) { if ( n < 9 ) return - 1 ; return ( n - 9 ) / 4 + 1 ; } if ( rem == 2 ) return ( n - 6 ) / 4 + 1 ; if ( rem == 3 ) { if ( n < 15 ) return - 1 ; return ( n - 15 ) / 4 + 2 ; } }
FIND_@@ DIMEN@@ SION@@ S_@@ RIGHT_@@ ANG@@ LED_@@ TRI@@ ANGLE | void find@@ Di@@ men ( int H , int A ) { if ( H * H < 4 * A ) { cout << " Not ▁ Possible \n " ; return ; } double ap@@ b = sqrt ( H * H + 4 * A ) ; double as@@ b = sqrt ( H * H - 4 * A ) ; cout . precision ( 2 ) ; cout << " P ▁ = ▁ " << fixed << ( ap@@ b - as@@ b ) / 2.0 << " \n " ; cout << " B ▁ = ▁ " << ( ap@@ b + as@@ b ) / 2.0 ; }
PRODUCT_@@ MAXIMUM_@@ FIRST_@@ ARRAY_@@ MIN@@ IM@@ UM@@ _SECON@@ D_@@ 1 | int min@@ Max@@ Product ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int n1 , int n2 ) { int max = ar@@ r1 [ 0 ] ; int min = ar@@ r2 [ 0 ] ; int i ; for ( i = 1 ; i < n1 && i < n2 ; ++ i ) { if ( ar@@ r1 [ i ] > max ) max = ar@@ r1 [ i ] ; if ( ar@@ r2 [ i ] < min ) min = ar@@ r2 [ i ] ; } while ( i < n1 ) { if ( ar@@ r1 [ i ] > max ) max = ar@@ r1 [ i ] ; i ++ ; } while ( i < n2 ) { if ( ar@@ r2 [ i ] < min ) min = ar@@ r2 [ i ] ; i ++ ; } return max * min ; }
PROGRAM_@@ CAL@@ CUL@@ ATE_@@ VOLUME_@@ OC@@ TA@@ HE@@ DRO@@ N | double vol_@@ of_@@ oc@@ ta@@ hedron ( double side ) { return ( ( side * side * side ) * ( sqrt ( 2 ) / 3 ) ) ; }
SORT_@@ STRING_@@ CHARAC@@ TER@@ S_@@ 1 | void sort@@ String ( string & str ) { int char@@ Count [ MAX_@@ CHAR ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) char@@ Count [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) for ( int j = 0 ; j < char@@ Count [ i ] ; j ++ ) cout << ( char ) ( ' a ' + i ) ; }
MOVE_@@ SPAC@@ ES_@@ FRONT_@@ STRING@@ _SIN@@ GLE_@@ TRA@@ VERS@@ AL | void move@@ Space@@ In@@ Front ( char str [ ] ) { int i = strlen ( str ) ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ▁ ' ) str [ i -- ] = str [ j ] ; while ( i >= 0 ) str [ i -- ] = ' ▁ ' ; }
MINIMUM_@@ INCRE@@ MENT_@@ K_@@ OPER@@ ATION@@ S_@@ MAKE_@@ ELEMEN@@ TS_@@ EQUAL | int min@@ Ops ( int arr [ ] , int n , int k ) { int max = * max_@@ element ( arr , arr + n ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }
PROGRAM_@@ FOR_@@ FAC@@ TOR@@ I@@ AL_@@ OF_@@ A_@@ NUMBER_@@ 1 | unsigned int factorial ( unsigned int n ) { int res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
MINIMUM_@@ TIME_@@ TO_@@ FINI@@ SH_@@ TASK@@ S_@@ WITH@@ OUT_@@ SKIP@@ P@@ ING_@@ TWO_@@ CON@@ SEC@@ UTI@@ VE | int min@@ Time ( int arr [ ] , int n ) { if ( n <= 0 ) return 0 ; int in@@ cl = arr [ 0 ] ; int ex@@ cl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int in@@ cl_@@ new = arr [ i ] + min ( ex@@ cl , in@@ cl ) ; int ex@@ cl_@@ new = in@@ cl ; in@@ cl = in@@ cl_@@ new ; ex@@ cl = ex@@ cl_@@ new ; } return min ( in@@ cl , ex@@ cl ) ; }
CHECK_@@ IF_@@ TWO_@@ ARRAY@@ S_@@ ARE_@@ EQUAL_@@ OR_@@ NOT | bool are@@ Equal ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int n , int m ) { if ( n != m ) return false ; sort ( ar@@ r1 , ar@@ r1 + n ) ; sort ( ar@@ r2 , ar@@ r2 + m ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ar@@ r1 [ i ] != ar@@ r2 [ i ] ) return false ; return true ; }
MINIMUM_@@ DIFF@@ ER@@ ENCE_@@ MAX_@@ MIN_@@ K@@ _SIZE_@@ SUB@@ SETS | int min@@ Difference@@ A@@ mon@@ g@@ Max@@ Min ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int res = INT_MAX ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { int cur@@ Seq@@ Diff = arr [ i + K - 1 ] - arr [ i ] ; res = min ( res , cur@@ Seq@@ Diff ) ; } return res ; }
SW@@ AP_@@ BITS_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ NUMBER | int swap@@ Bits ( unsigned int x , unsigned int p1 , unsigned int p2 , unsigned int n ) { unsigned int set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 ) ; unsigned int set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 ) ; unsigned int Xor = ( set1 ^ set2 ) ; Xor = ( Xor << p1 ) | ( Xor << p2 ) ; unsigned int result = x ^ Xor ; return result ; }
COUNT_@@ NUMBER_OF_@@ WAY@@ S_TO_@@ FILL_@@ A_@@ N_@@ X_@@ 4_@@ GRID_@@ USING_@@ 1_@@ X_@@ 4_@@ TI@@ LES | int count ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } return dp [ n ] ; }
MAXIMUM_@@ CON@@ SEC@@ UTI@@ VE_@@ REPE@@ ATING_@@ CHARACTER_@@ STRING_@@ 1 | char max@@ Repe@@ ating ( string str ) { int n = str . length ( ) ; int count = 0 ; char res = str [ 0 ] ; int cur_@@ count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_@@ count ++ ; else { if ( cur_@@ count > count ) { count = cur_@@ count ; res = str [ i ] ; } cur_@@ count = 1 ; } } return res ; }
PAS@@ CAL_@@ TRI@@ ANGLE | void print@@ Pas@@ cal ( int n ) { int arr [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i || i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; cout << arr [ line ] [ i ] << " ▁ " ; } cout << " \n " ; } }
TURN_@@ OFF_@@ THE_@@ RIGHT@@ MO@@ ST@@ _SET_@@ BIT | int fun ( unsigned int n ) { return n & ( n - 1 ) ; }
RE@@ AR@@ RANGE_@@ ARRAY_@@ MAXIMUM_@@ MINIMUM_@@ FORM@@ _SET_@@ 2_@@ O@@ 1_@@ EX@@ TRA@@ _SPACE | void re@@ arrange ( int arr [ ] , int n ) { int max_@@ idx = n - 1 , min_@@ idx = 0 ; int max_@@ elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_@@ idx ] % max_@@ elem ) * max_@@ elem ; max_@@ idx -- ; } else { arr [ i ] += ( arr [ min_@@ idx ] % max_@@ elem ) * max_@@ elem ; min_@@ idx ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] / max_@@ elem ; }
COUNT_@@ ZER@@ OS_@@ IN_@@ A_@@ ROW_@@ WI@@ SE_@@ AND_@@ COLUMN_@@ WI@@ SE_@@ SOR@@ TED_@@ MATRIX | int count@@ Zero@@ es ( int mat [ N ] [ N ] ) { int row = N - 1 , col = 0 ; int count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; }
MINIMUM_@@ CO@@ ST_@@ FOR_@@ AC@@ QUIR@@ ING_@@ ALL_@@ CO@@ INS_@@ WITH_@@ K_@@ EXTRA_@@ CO@@ INS_@@ ALLOWED_@@ WITH_@@ EVER@@ Y_@@ COIN | int min@@ Cost ( int coin [ ] , int n , int k ) { sort ( coin , coin + n ) ; int coin@@ s_@@ needed = ceil ( 1.0 * n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i <= coin@@ s_@@ needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }
COUNT_@@ SUB@@ ARRAY@@ S_@@ TOTAL_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ ORIGIN@@ AL_@@ ARRAY | int count@@ Di@@ stic@@ t@@ Sub@@ array ( int arr [ ] , int n ) { unordered_map < int , int > vis ; for ( int i = 0 ; i < n ; ++ i ) vis [ arr [ i ] ] = 1 ; int k = vis . size ( ) ; vis . clear ( ) ; int ans = 0 , right = 0 , window = 0 ; for ( int left = 0 ; left < n ; ++ left ) { while ( right < n && window < k ) { ++ vis [ arr [ right ] ] ; if ( vis [ arr [ right ] ] == 1 ) ++ window ; ++ right ; } if ( window == k ) ans += ( n - right + 1 ) ; -- vis [ arr [ left ] ] ; if ( vis [ arr [ left ] ] == 0 ) -- window ; } return ans ; }
FIND_@@ POSSI@@ BLE_@@ ROTA@@ TE_@@ PAGE_@@ ANGLE_@@ NOT | void possible@@ Or@@ Not ( long long a1 , long long a2 , long long b1 , long long b2 , long long c1 , long long c2 ) { long long dis@@ 1 = pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) ; long long dis@@ 2 = pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) ; if ( dis@@ 1 != dis@@ 2 ) cout << " No " ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) cout << " No " ; else cout << " Yes " ; }
TIME_@@ ME@@ ET_@@ ANIM@@ ALS | void timeTo@@ Me@@ et ( double s , double v ) { double V = 3 * v / 2 ; double time = s / V ; cout << time ; }
B@@ RES@@ EN@@ HAM@@ S_@@ LINE_@@ GENERA@@ TION_@@ ALGORITH@@ M | void b@@ res@@ enh@@ am ( int x1 , int y1 , int x2 , int y2 ) { int m_@@ new = 2 * ( y2 - y1 ) ; int slo@@ pe_@@ error_@@ new = m_@@ new - ( x2 - x1 ) ; for ( int x = x1 , y = y1 ; x <= x2 ; x ++ ) { cout << " ( " << x << " , " << y << " ) \n " ; slo@@ pe_@@ error_@@ new += m_@@ new ; if ( slo@@ pe_@@ error_@@ new >= 0 ) { y ++ ; slo@@ pe_@@ error_@@ new -= 2 * ( x2 - x1 ) ; } } }
MAXIMUM_@@ NUMBER_@@ CHO@@ CO@@ LA@@ TES_@@ DISTRIBU@@ TED_@@ EQUAL@@ LY_@@ AM@@ ONG_@@ K_@@ STUD@@ ENTS | int maxNum@@ Of@@ Cho@@ col@@ ates ( int arr [ ] , int n , int k ) { unordered_map < int , int > um ; int sum [ n ] , curr_@@ rem ; int max@@ Sum = 0 ; sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { curr_@@ rem = sum [ i ] % k ; if ( curr_@@ rem == 0 ) { if ( max@@ Sum < sum [ i ] ) max@@ Sum = sum [ i ] ; } else if ( um . find ( curr_@@ rem ) == um . end ( ) ) um [ curr_@@ rem ] = i ; else if ( max@@ Sum < ( sum [ i ] - sum [ um [ curr_@@ rem ] ] ) ) max@@ Sum = sum [ i ] - sum [ um [ curr_@@ rem ] ] ; } return ( max@@ Sum / k ) ; }
CHECK_@@ TWO_@@ STRING@@ S_@@ K_@@ AN@@ AG@@ RAM@@ S_@@ NOT_@@ 1 | bool are@@ K@@ An@@ agram@@ s ( string str1 , string str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int hash_@@ str1 [ MAX_@@ CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) hash_@@ str1 [ str1 [ i ] - ' a ' ] ++ ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash_@@ str1 [ str2 [ i ] - ' a ' ] > 0 ) hash_@@ str1 [ str2 [ i ] - ' a ' ] -- ; else count ++ ; if ( count > k ) return false ; } return true ; }
DI@@ VISIBILITY_@@ CHECK | void di@@ visibility@@ Check ( int arr [ ] , int n ) { unordered_@@ set < int > s ; int max_@@ ele = INT_@@ MIN ; for ( int i = 0 ; i < n ; i ++ ) { s . insert ( arr [ i ] ) ; max_@@ ele = max ( max_@@ ele , arr [ i ] ) ; } unordered_@@ set < int > res ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 0 ) { for ( int j = arr [ i ] * 2 ; j <= max_@@ ele ; j += arr [ i ] ) { if ( s . find ( j ) != s . end ( ) ) res . insert ( j ) ; } } } unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; unordered_map < int , int > :: iterator it ; vector < int > ans ; for ( it = mp . begin ( ) ; it != mp . end ( ) ; it ++ ) { if ( it -> second >= 2 ) { if ( res . find ( it -> first ) == res . end ( ) ) { int val = it -> second ; while ( val -- ) ans . push_back ( it -> first ) ; } } if ( res . find ( it -> first ) != res . end ( ) ) { int val = it -> second ; while ( val -- ) ans . push_back ( it -> first ) ; } } for ( auto x : ans ) cout << x << " ▁ " ; }
MAXIMUM_@@ LENGTH_@@ PREFIX_@@ ONE_@@ STRING_@@ OC@@ CURS@@ _SUB@@ SEQU@@ ENCE_@@ AN@@ OTHER | int max@@ Prefix ( char s [ ] , char t [ ] ) { int count = 0 ; for ( int i = 0 ; i < strlen ( t ) ; i ++ ) { if ( count == strlen ( s ) ) break ; if ( t [ i ] == s [ count ] ) count ++ ; } return count ; }
COUNT_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ IN_@@ EVER@@ Y_@@ WINDOW_@@ OF@@ _SIZE_@@ K | void count@@ Distin@@ ct ( int arr [ ] , int k , int n ) { map < int , int > hm ; int dist@@ _count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( hm [ arr [ i ] ] == 0 ) { dist@@ _count ++ ; } hm [ arr [ i ] ] += 1 ; } cout << dist@@ _count << endl ; for ( int i = k ; i < n ; i ++ ) { if ( hm [ arr [ i - k ] ] == 1 ) { dist@@ _count -- ; } hm [ arr [ i - k ] ] -= 1 ; if ( hm [ arr [ i ] ] == 0 ) { dist@@ _count ++ ; } hm [ arr [ i ] ] += 1 ; cout << dist@@ _count << endl ; } }
LC@@ S_@@ FOR@@ MED_@@ CON@@ SEC@@ UTI@@ VE_@@ SEG@@ MEN@@ TS_@@ LEA@@ ST_@@ LENGTH_@@ K | int lon@@ gest@@ Sub@@ sequence@@ Common@@ Segment ( int k , string s1 , string s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; int l@@ cs [ n + 1 ] [ m + 1 ] ; int cnt [ n + 1 ] [ m + 1 ] ; memset ( l@@ cs , 0 , sizeof ( l@@ cs ) ) ; memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { l@@ cs [ i ] [ j ] = max ( l@@ cs [ i - 1 ] [ j ] , l@@ cs [ i ] [ j - 1 ] ) ; if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; if ( cnt [ i ] [ j ] >= k ) { for ( int a = k ; a <= cnt [ i ] [ j ] ; a ++ ) l@@ cs [ i ] [ j ] = max ( l@@ cs [ i ] [ j ] , l@@ cs [ i - a ] [ j - a ] + a ) ; } } } return l@@ cs [ n ] [ m ] ; }
PRINT_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ GI@@ V@@ EN_@@ INTEGER_@@ ARRAY_@@ 1 | void print@@ Distin@@ ct ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++ ; cout << arr [ i ] << " ▁ " ; } }
PRI@@ MALI@@ TY_@@ TEST@@ _SET_@@ 5@@ USING_@@ L@@ UC@@ AS_@@ LE@@ H@@ MER@@ _SERI@@ ES | bool is@@ Prime ( int p ) { long long check@@ Number = pow ( 2 , p ) - 1 ; long long next@@ val = 4 % check@@ Number ; for ( int i = 1 ; i < p - 1 ; i ++ ) next@@ val = ( next@@ val * next@@ val - 2 ) % check@@ Number ; return ( next@@ val == 0 ) ; }
K@@ TH_@@ NON_@@ REPE@@ ATING_@@ CHARACTER | int k@@ th@@ Non@@ Repe@@ ating ( string str , int k ) { int n = str . length ( ) ; int count [ MAX_@@ CHAR ] ; int index [ MAX_@@ CHAR ] ; for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) { count [ i ] = 0 ; index [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { char x = str [ i ] ; ++ count [ x ] ; if ( count [ x ] == 1 ) index [ x ] = i ; if ( count [ x ] == 2 ) index [ x ] = n ; } sort ( index , index + MAX_@@ CHAR ) ; return ( index [ k - 1 ] != n ) ? index [ k - 1 ] : - 1 ; }
FIRST_@@ UP@@ PER@@ CASE_@@ LET@@ TER_@@ IN_@@ A_@@ STRING_@@ ITER@@ ATI@@ VE_@@ AND_@@ RECUR@@ SIVE | char first ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( is@@ upper ( str [ i ] ) ) return str [ i ] ; return 0 ; }
GI@@ V@@ EN_@@ TWO_@@ STRING@@ S_@@ FIND_@@ FIRST_@@ STRING@@ _SUB@@ SEQU@@ ENCE_@@ SECOND | bool isSub@@ Sequence ( char str1 [ ] , char str2 [ ] , int m , int n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) return isSub@@ Sequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSub@@ Sequence ( str1 , str2 , m , n - 1 ) ; }
C_@@ PROGRAM_@@ FIND_@@ LAR@@ GE@@ ST_@@ ELEMENT_@@ ARRAY_@@ 1 | int largest ( int arr [ ] , int n ) { return * max_@@ element ( arr , arr + n ) ; }
DIFF@@ ER@@ ENCE_@@ BETWE@@ EN_@@ HIGH@@ EST_@@ AND_@@ LEA@@ ST_@@ FREQU@@ ENCI@@ ES_@@ IN_@@ AN_@@ ARRAY | int find@@ Diff ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int count = 0 , max_@@ count = 0 , min_@@ count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_@@ count = max ( max_@@ count , count ) ; min_@@ count = min ( min_@@ count , count ) ; count = 0 ; } } return ( max_@@ count - min_@@ count ) ; }
PROGRAM_@@ FOR_@@ FAC@@ TOR@@ I@@ AL_@@ OF_@@ A_@@ NUMBER | unsigned int factorial ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
