PRINT_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ GI@@ V@@ EN_@@ INTEGER_@@ ARRAY_@@ 2 | def print@@ Distin@@ ct ( arr , n ) : NEW_LINE INDENT s = dict ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in s . keys ( ) ) : NEW_LINE INDENT s [ arr [ i ] ] = arr [ i ] ; NEW_LINE print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
CHECK_@@ RO@@ WS_@@ MATRIX_@@ CIRC@@ ULAR_@@ ROTA@@ TIONS | def is@@ Per@@ mu@@ ted@@ Matrix ( mat , n ) : NEW_LINE INDENT str_@@ cat = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT str_@@ cat = str_@@ cat + " - " + str ( mat [ 0 ] [ i ] ) NEW_LINE DEDENT str_@@ cat = str_@@ cat + str_@@ cat NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_@@ str = " " NEW_LINE for j in range ( n ) : NEW_LINE INDENT curr_@@ str = curr_@@ str + " - " + str ( mat [ i ] [ j ] ) NEW_LINE DEDENT if ( str_@@ cat . find ( curr_@@ str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
S@@ UM_@@ PAIR@@ WI@@ SE_@@ PRODUC@@ TS | def find@@ Sum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT sm = sm + i * j NEW_LINE DEDENT DEDENT return sm NEW_LINE DEDENT
SORT_@@ 3_@@ INTEG@@ ERS_@@ WITH@@ OUT_@@ USING_@@ CONDITION_@@ USING_@@ MAX_@@ FUNCTION | def print@@ Sorted ( a , b , c ) : NEW_LINE INDENT get_@@ max = max ( a , max ( b , c ) ) NEW_LINE get_@@ min = - max ( - a , max ( - b , - c ) ) NEW_LINE get_@@ mid = ( a + b + c ) - ( get_@@ max + get_@@ min ) NEW_LINE print ( get_@@ min , " ▁ " , get_@@ mid , " ▁ " , get_@@ max ) NEW_LINE DEDENT
PROGRAM_@@ FOR_@@ FAC@@ TOR@@ I@@ AL_@@ OF_@@ A_@@ NUMBER_@@ 2 | def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT
FIND_@@ INDEX_@@ OF_@@ AN_@@ EXTRA_@@ ELEMENT_@@ PRES@@ ENT_@@ IN_@@ ONE@@ _S@@ OR@@ TED_@@ ARRAY_@@ 2 | def find_@@ extra_@@ element@@ _index ( arr@@ A , arr@@ B ) : NEW_LINE INDENT extra_@@ element = sum ( arr@@ A ) - sum ( arr@@ B ) NEW_LINE return arr@@ A . index ( extra_@@ element ) NEW_LINE DEDENT
SUB@@ ARRAY@@ SUB@@ STRING_@@ VS@@ _SUB@@ SEQU@@ ENCE_@@ AND_@@ PROGR@@ AM@@ S_TO_@@ GENERATE_@@ THE@@ M_@@ 1 | def print@@ Sub@@ sequences ( arr , n ) : NEW_LINE INDENT op@@ size = math . pow ( 2 , n ) NEW_LINE for counter in range ( 1 , ( int ) ( op@@ size ) ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( counter & ( 1 << j ) ) : NEW_LINE INDENT print ( arr [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
N_@@ BON@@ ACC@@ I_@@ NUMB@@ ERS | def bon@@ ac@@ ci@@ series ( n , m ) : NEW_LINE INDENT a = [ 0 ] * m NEW_LINE a [ n - 1 ] = 1 NEW_LINE for i in range ( n , m ) : NEW_LINE INDENT for j in range ( i - n , i ) : NEW_LINE INDENT a [ i ] = a [ i ] + a [ j ] NEW_LINE DEDENT DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
LOWER_@@ CASE_@@ UPPER_@@ CASE_@@ INTER@@ EST@@ ING_@@ FAC@@ T | def to_@@ upper ( string ) : NEW_LINE INDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if ( ' a ' <= string [ i ] <= ' z ' ) : NEW_LINE INDENT string = ( string [ 0 : i ] + chr ( ord ( string [ i ] ) - ord ( ' a ' ) + ord ( ' A ' ) ) + string [ i + 1 : ] ) NEW_LINE DEDENT DEDENT return string ; NEW_LINE DEDENT
PRINT_@@ BRAC@@ KET_@@ NUMBER | def print@@ Bracket@@ Number ( exp , n ) : NEW_LINE INDENT left_@@ b@@ num = 1 NEW_LINE right_@@ b@@ num = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if exp [ i ] == ' ( ' : NEW_LINE INDENT print ( left_@@ b@@ num , end = " ▁ " ) NEW_LINE right_@@ b@@ num . append ( left_@@ b@@ num ) NEW_LINE left_@@ b@@ num += 1 NEW_LINE DEDENT elif exp [ i ] == ' ) ' : NEW_LINE INDENT print ( right_@@ b@@ num [ - 1 ] , end = " ▁ " ) NEW_LINE right_@@ b@@ num . pop ( ) NEW_LINE DEDENT DEDENT DEDENT
MAXIMUM_@@ PRODUCT_@@ OF_@@ 4_@@ AD@@ J@@ AC@@ ENT_@@ ELEMEN@@ TS_@@ IN_@@ MATRIX | def Find@@ Max@@ Product ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( j - 3 ) >= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 and ( j - 3 ) >= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT DEDENT DEDENT return max NEW_LINE DEDENT
LON@@ GE@@ ST@@ _SUB@@ ARRA@@ Y_S@@ UM_@@ DI@@ VISI@@ BLE_@@ K | def long@@ Sub@@ arr@@ W@@ th@@ Sum@@ Div@@ By@@ K ( arr , n , k ) : NEW_LINE INDENT um = { i : 0 for i in range ( 8 ) } NEW_LINE mod_@@ arr = [ 0 for i in range ( n ) ] NEW_LINE max = 0 NEW_LINE curr_@@ sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_@@ sum += arr [ i ] NEW_LINE mod_@@ arr [ i ] = ( ( curr_@@ sum % k ) + k ) % k NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mod_@@ arr [ i ] == 0 ) : NEW_LINE INDENT max = i + 1 NEW_LINE DEDENT elif ( mod_@@ arr [ i ] in um ) : NEW_LINE INDENT um [ mod_@@ arr [ i ] ] = i NEW_LINE DEDENT else : NEW_LINE INDENT if ( max < ( i - um [ mod_@@ arr [ i ] ] ) ) : NEW_LINE INDENT max = i - um [ mod_@@ arr [ i ] ] NEW_LINE DEDENT DEDENT DEDENT return max NEW_LINE DEDENT
CA@@ ES@@ AR_@@ CIPH@@ ER | def encrypt ( text , s ) : NEW_LINE INDENT result = " " NEW_LINE for i in range ( len ( text ) ) : NEW_LINE INDENT char = text [ i ] NEW_LINE if ( char . is@@ upper ( ) ) : NEW_LINE INDENT result += chr ( ( ord ( char ) + s - 65 ) % 26 + 65 ) NEW_LINE DEDENT else : NEW_LINE INDENT result += chr ( ( ord ( char ) + s - 97 ) % 26 + 97 ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
SUB@@ ARRAY@@ S_@@ DISTIN@@ CT_@@ ELEMENTS | def su@@ mo@@ f@@ length ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < n and ( arr [ j ] not in s ) ) : NEW_LINE INDENT s . append ( arr [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT ans += ( ( j - i ) * ( j - i + 1 ) ) // 2 NEW_LINE s . remove ( arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
K_@@ TH_@@ ELEMENT_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S | def k@@ th ( ar@@ r1 , ar@@ r2 , m , n , k ) : NEW_LINE INDENT sorted@@ 1 = [ 0 ] * ( m + n ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE d = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( ar@@ r1 [ i ] < ar@@ r2 [ j ] ) : NEW_LINE INDENT sorted@@ 1 [ d ] = ar@@ r1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sorted@@ 1 [ d ] = ar@@ r2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT d += 1 NEW_LINE DEDENT while ( i < m ) : NEW_LINE INDENT sorted@@ 1 [ d ] = ar@@ r1 [ i ] NEW_LINE d += 1 NEW_LINE i += 1 NEW_LINE DEDENT while ( j < n ) : NEW_LINE INDENT sorted@@ 1 [ d ] = ar@@ r2 [ j ] NEW_LINE d += 1 NEW_LINE j += 1 NEW_LINE DEDENT return sorted@@ 1 [ k - 1 ] NEW_LINE DEDENT
REMOVE_@@ CON@@ SEC@@ UTI@@ VE_@@ DUPLIC@@ ATE@@ S_@@ STRING | def remove@@ Duplicates ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE if ( n < 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( S [ j ] != S [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE S [ j ] = S [ i ] NEW_LINE DEDENT DEDENT j += 1 NEW_LINE S = S [ : j ] NEW_LINE return S NEW_LINE DEDENT
MAJ@@ ORI@@ TY_@@ ELEMENT | def find@@ Maj@@ ority ( arr , n ) : NEW_LINE INDENT maxCount = 0 ; NEW_LINE index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count > maxCount ) : NEW_LINE INDENT maxCount = count NEW_LINE index = i NEW_LINE DEDENT DEDENT if ( maxCount > n // 2 ) : NEW_LINE INDENT print ( arr [ index ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Maj@@ ority ▁ Element " ) NEW_LINE DEDENT DEDENT
FUNCTION_@@ COPY_@@ STRING_@@ ITER@@ ATI@@ VE_@@ RECUR@@ SIVE_@@ 1 | def my@@ Copy ( s1 , s2 , index ) : NEW_LINE INDENT s2 [ index ] = s1 [ index ] ; NEW_LINE if ( index == len ( s1 ) - 1 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT my@@ Copy ( s1 , s2 , index + 1 ) ; NEW_LINE DEDENT
COUNT_@@ NUMBER_OF_@@ WAY@@ S_TO_@@ CO@@ VER_@@ A_@@ DISTAN@@ CE_@@ 1 | def print@@ Count@@ DP ( dist ) : NEW_LINE INDENT count = [ 0 ] * ( dist + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE count [ 1 ] = 1 NEW_LINE count [ 2 ] = 2 NEW_LINE for i in range ( 3 , dist + 1 ) : NEW_LINE INDENT count [ i ] = ( count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ) NEW_LINE DEDENT return count [ dist ] ; NEW_LINE DEDENT
DISC@@ RE@@ TE_@@ LOG@@ ARI@@ TH@@ M_@@ FIND_@@ INTEGER_@@ K_@@ A@@ K_@@ CON@@ GR@@ U@@ ENT_@@ MODUL@@ O_@@ B | def discre@@ te@@ Log@@ arith@@ m ( a , b , m ) : NEW_LINE INDENT n = int ( math . sqrt ( m ) + 1 ) ; NEW_LINE an = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT an = ( an * a ) % m ; NEW_LINE DEDENT value = [ 0 ] * m ; NEW_LINE cur = an ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( value [ cur ] == 0 ) : NEW_LINE INDENT value [ cur ] = i ; NEW_LINE DEDENT cur = ( cur * an ) % m ; NEW_LINE DEDENT cur = b ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( value [ cur ] > 0 ) : NEW_LINE INDENT ans = value [ cur ] * n - i ; NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT DEDENT cur = ( cur * a ) % m ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT
CHANGE_@@ BITS_@@ CAN_@@ MA@@ DE_@@ ONE_@@ FLI@@ P_@@ 1 | def is@@ One@@ Flip ( str ) : NEW_LINE INDENT sum = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += int ( str [ i ] ) - int ( '0' ) NEW_LINE DEDENT return ( sum == n - 1 or sum == 1 ) NEW_LINE DEDENT
FIND_@@ PAIR@@ S_IN_@@ ARRAY_@@ WHO@@ SE_@@ SUM@@ S_@@ ALREADY_@@ EXI@@ ST_@@ IN_@@ ARRAY | def find@@ Pair ( arr , n ) : NEW_LINE INDENT found = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] == arr [ k ] ) : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " Not ▁ exist " ) NEW_LINE DEDENT DEDENT
MODUL@@ AR_@@ MULTIP@@ LIC@@ ATI@@ VE_@@ INVER@@ SE_@@ 1_@@ N | def mod@@ ular@@ Inverse ( n , prime ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ prime % i ] * ( prime - prime // i ) % prime NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( dp [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
SHUFF@@ LE_@@ 2@@ N_@@ INTEG@@ ERS_@@ FORMAT_@@ A@@ 1_@@ B@@ 1_@@ A@@ 2_@@ B@@ 2_@@ A@@ 3_@@ B@@ 3_@@ BN_@@ WITH@@ OUT_@@ USING_@@ EX@@ TRA@@ _SPACE_@@ 1 | def shu@@ fle@@ Array ( a , f , l ) : NEW_LINE INDENT if ( l > f ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( l - f == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT mid = int ( ( f + l ) / 2 ) NEW_LINE temp = mid + 1 NEW_LINE mm@@ id = int ( ( f + mid ) / 2 ) NEW_LINE for i in range ( mm@@ id + 1 , mid + 1 ) : NEW_LINE INDENT ( a [ i ] , a [ temp ] ) = ( a [ temp ] , a [ i ] ) NEW_LINE temp += 1 NEW_LINE DEDENT shu@@ fle@@ Array ( a , f , mid ) NEW_LINE shu@@ fle@@ Array ( a , mid + 1 , l ) NEW_LINE DEDENT
N_@@ TH_@@ ROOT_@@ NUMBER | def n@@ th@@ Root ( A , N ) : NEW_LINE INDENT x@@ Pre = random . randint ( 1 , 101 ) % 10 NEW_LINE eps = 0.001 NEW_LINE del@@ X = 2147483647 NEW_LINE x@@ K = 0.0 NEW_LINE while ( del@@ X > eps ) : NEW_LINE INDENT x@@ K = ( ( N - 1.0 ) * x@@ Pre + A / pow ( x@@ Pre , N - 1 ) ) / N NEW_LINE del@@ X = abs ( x@@ K - x@@ Pre ) NEW_LINE x@@ Pre = x@@ K ; NEW_LINE DEDENT return x@@ K NEW_LINE DEDENT
NUMBER_OF_@@ WAY@@ S_TO_@@ AR@@ RANGE_@@ N_@@ ITE@@ MS_@@ UN@@ DER_@@ GI@@ V@@ EN_@@ CONSTRA@@ INTS | def way@@ sTo@@ Ar@@ range ( N , K , k ) : NEW_LINE INDENT C = np . zeros ( ( N + 1 , N + 1 ) ) NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT dp = np . zeros ( ( K + 1 ) ) NEW_LINE count = 0 NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( K ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) NEW_LINE count += k [ i ] NEW_LINE DEDENT return dp [ K ] NEW_LINE DEDENT
TEMP@@ LE_@@ OFF@@ ER@@ INGS | def offer@@ ing@@ Number ( n , temp@@ le@@ Height ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT left = 0 NEW_LINE right = 0 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( temp@@ le@@ Height [ j ] < temp@@ le@@ Height [ j + 1 ] ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( temp@@ le@@ Height [ j ] < temp@@ le@@ Height [ j - 1 ] ) : NEW_LINE INDENT right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT sum += max ( right , left ) + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
CENTER_@@ ELEMENT_@@ OF_@@ MATRIX_@@ EQUAL@@ S_S@@ UM@@ S_@@ OF_@@ HALF_@@ DIAG@@ ON@@ ALS | def Half@@ Diag@@ onal@@ Sum@@ s ( mat , n ) : NEW_LINE INDENT diag@@ 1_@@ left = 0 NEW_LINE diag@@ 1_@@ right = 0 NEW_LINE diag@@ 2_@@ left = 0 NEW_LINE diag@@ 2_@@ right = 0 NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while i < n : NEW_LINE INDENT if ( i < n // 2 ) : NEW_LINE INDENT diag@@ 1_@@ left += mat [ i ] [ i ] NEW_LINE diag@@ 2_@@ left += mat [ j ] [ i ] NEW_LINE DEDENT elif ( i > n // 2 ) : NEW_LINE INDENT diag@@ 1_@@ right += mat [ i ] [ i ] NEW_LINE diag@@ 2_@@ right += mat [ j ] [ i ] NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return ( diag@@ 1_@@ left == diag@@ 2_@@ right and diag@@ 2_@@ right == diag@@ 2_@@ left and diag@@ 1_@@ right == diag@@ 2_@@ left and diag@@ 2_@@ right == mat [ n // 2 ] [ n // 2 ] ) NEW_LINE DEDENT
COUNT_@@ FAC@@ TOR@@ I@@ AL_@@ NUMB@@ ERS_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ RANGE | def count@@ Fact ( low , high ) : NEW_LINE INDENT fact = 1 NEW_LINE x = 1 NEW_LINE while ( fact < low ) : NEW_LINE INDENT fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT res = 0 NEW_LINE while ( fact <= high ) : NEW_LINE INDENT res += 1 NEW_LINE fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
PROGRAM_@@ REVERSE_@@ STRING_@@ ITER@@ ATI@@ VE_@@ RECUR@@ SIVE_@@ 1 | def reverse@@ Str ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i , j = 0 , n - 1 NEW_LINE while i < j : NEW_LINE INDENT str [ i ] , str [ j ] = str [ j ] , str [ i ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT
FIND_@@ MINIMUM_@@ AD@@ JU@@ ST@@ MENT_@@ CO@@ ST_@@ OF_@@ AN_@@ ARRAY | def min@@ Adjustment@@ Cost ( A , n , target ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n ) ] NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( M + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1@@ 00000000 NEW_LINE for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) NEW_LINE DEDENT DEDENT DEDENT res = 10000000 NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT res = min ( res , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
COUNT_@@ FREQU@@ ENCY_@@ K_@@ MATRI@@ X@@ _SIZE_@@ N_@@ MATRI@@ X@@ I_@@ J_@@ I@@ J | def find ( n , k ) : NEW_LINE INDENT if ( n + 1 >= k ) : NEW_LINE INDENT return ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * n + 1 - k ) NEW_LINE DEDENT DEDENT
MINIMUM_@@ FLI@@ P_@@ REQUIRED_@@ MAKE_@@ BINARY_@@ MATRIX_@@ SYM@@ METRIC_@@ 1 | def minimum@@ flip ( mat , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if mat [ i ] [ j ] != mat [ j ] [ i ] : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return flip NEW_LINE DEDENT
N@@ TH_@@ PA@@ LIN@@ DRO@@ ME_@@ K_@@ DIGITS | def n@@ th@@ Pal@@ ind@@ ro@@ me ( n , k ) : NEW_LINE INDENT if ( k & 1 ) : NEW_LINE INDENT temp = k // 2 NEW_LINE DEDENT else : NEW_LINE INDENT temp = k // 2 - 1 NEW_LINE DEDENT pal@@ ind@@ ro@@ me = 10 ** temp NEW_LINE pal@@ ind@@ ro@@ me = pal@@ ind@@ ro@@ me + n - 1 NEW_LINE print ( pal@@ ind@@ ro@@ me , end = " " ) NEW_LINE if ( k & 1 ) : NEW_LINE INDENT pal@@ ind@@ ro@@ me = pal@@ ind@@ ro@@ me // 10 NEW_LINE DEDENT while ( pal@@ ind@@ ro@@ me ) : NEW_LINE INDENT print ( pal@@ ind@@ ro@@ me % 10 , end = " " ) NEW_LINE pal@@ ind@@ ro@@ me = pal@@ ind@@ ro@@ me // 10 NEW_LINE DEDENT DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 3_@@ LON@@ GE@@ ST_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQU@@ ENCE_@@ 1 | def lis ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE lis = [ 1 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT maximum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maximum = max ( maximum , lis [ i ] ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT
PATH_@@ MAXIMUM_@@ AVER@@ AGE_@@ VALUE | def max@@ Average@@ Of@@ Path ( cost , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) NEW_LINE DEDENT
PROGRAM_@@ COUNT_@@ OC@@ CURR@@ ENCE_@@ GI@@ V@@ EN_@@ CHARACTER_@@ STRING | def count ( s , c ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == c ) : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
K@@ TH@@ _S@@ MAL@@ LE@@ ST@@ LAR@@ GE@@ ST_@@ ELEMENT_@@ UN@@ SOR@@ TED_@@ ARRAY | def k@@ th@@ S@@ malle@@ st ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT
CONVERT_@@ ALTER@@ N@@ ATE_@@ CHARAC@@ TER@@ S_@@ STRING_@@ UPPER_@@ CASE | def convert@@ Op@@ posi@@ te ( str ) : NEW_LINE INDENT ln = len ( str ) NEW_LINE for i in range ( ln ) : NEW_LINE INDENT if str [ i ] >= ' a ' and str [ i ] <= ' z ' : NEW_LINE INDENT str [ i ] = chr ( ord ( str [ i ] ) - 32 ) NEW_LINE DEDENT elif str [ i ] >= ' A ' and str [ i ] <= ' Z ' : NEW_LINE INDENT str [ i ] = chr ( ord ( str [ i ] ) + 32 ) NEW_LINE DEDENT DEDENT DEDENT
SUM@@ _SERI@@ ES_@@ 5555@@ 55@@ _@@ N_@@ TER@@ MS | def sum@@ Of@@ Series ( n ) : NEW_LINE INDENT return ( int ) ( 0.6@@ 172 * ( pow ( 10 , n ) - 1 ) - 0.5@@ 5 * n ) NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 8_@@ MATRIX_@@ CHAIN_@@ MULTIP@@ LIC@@ ATION | def Matrix@@ Chain@@ Order ( p , i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return 0 NEW_LINE DEDENT _min = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT count = ( Matrix@@ Chain@@ Order ( p , i , k ) + Matrix@@ Chain@@ Order ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE if count < _min : NEW_LINE INDENT _min = count ; NEW_LINE DEDENT DEDENT return _min ; NEW_LINE DEDENT
COUNT_@@ SET_@@ BITS_@@ IN_@@ AN_@@ INTEGER_@@ 3 | def count@@ Set@@ Bits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + count@@ Set@@ Bits ( n & ( n - 1 ) ) NEW_LINE DEDENT DEDENT
MINIMUM_@@ LENGTH_@@ UN@@ SOR@@ TED@@ _SUB@@ ARRA@@ Y_S@@ OR@@ TING_@@ WHI@@ CH_@@ MAKE@@ S_@@ THE_@@ COMPLETE_@@ ARRA@@ Y_S@@ OR@@ TED | def print@@ Un@@ sorted ( arr , n ) : NEW_LINE INDENT e = n - 1 NEW_LINE for s in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ s ] > arr [ s + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if s == n - 1 : NEW_LINE INDENT print ( " The ▁ complete ▁ array ▁ is ▁ sorted " ) NEW_LINE exit ( ) NEW_LINE DEDENT e = n - 1 NEW_LINE while e > 0 : NEW_LINE INDENT if arr [ e ] < arr [ e - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT e -= 1 NEW_LINE DEDENT max = arr [ s ] NEW_LINE min = arr [ s ] NEW_LINE for i in range ( s + 1 , e + 1 ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT if arr [ i ] < min : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( s ) : NEW_LINE INDENT if arr [ i ] > min : NEW_LINE INDENT s = i NEW_LINE break NEW_LINE DEDENT DEDENT i = n - 1 NEW_LINE while i >= e + 1 : NEW_LINE INDENT if arr [ i ] < max : NEW_LINE INDENT e = i NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( " The ▁ un@@ sorted ▁ sub@@ array ▁ which ▁ makes ▁ the ▁ given ▁ array " ) NEW_LINE print ( " sorted ▁ lies ▁ between ▁ the ▁ indexes ▁ % d ▁ and ▁ % d " % ( s , e ) ) NEW_LINE DEDENT
STE@@ INS_@@ ALGORITH@@ M_@@ FOR_@@ FIN@@ DING_@@ GC@@ D | def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT k = 0 NEW_LINE while ( ( ( a | b ) & 1 ) == 0 ) : NEW_LINE INDENT a = a >> 1 NEW_LINE b = b >> 1 NEW_LINE k = k + 1 NEW_LINE DEDENT while ( ( a & 1 ) == 0 ) : NEW_LINE INDENT a = a >> 1 NEW_LINE DEDENT while ( b != 0 ) : NEW_LINE INDENT while ( ( b & 1 ) == 0 ) : NEW_LINE INDENT b = b >> 1 NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT b = ( b - a ) NEW_LINE DEDENT return ( a << k ) NEW_LINE DEDENT
HEX@@ AG@@ ON@@ AL_@@ NUMBER | def hex@@ ag@@ onal@@ Num ( n ) : NEW_LINE INDENT return n * ( 2 * n - 1 ) NEW_LINE DEDENT
GOO@@ GLE_@@ CASE_@@ GI@@ VEN@@ _S@@ ENT@@ ENCE | def convert ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE s1 = " " NEW_LINE s1 = s1 + s [ 0 ] . lower ( ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if ( s [ i ] == ' ▁ ' and i <= n ) : NEW_LINE INDENT s1 = s1 + " ▁ " + ( s [ i + 1 ] ) . lower ( ) NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT s1 = s1 + ( s [ i ] ) . upper ( ) NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return s1 NEW_LINE DEDENT
FIND_@@ A_@@ ROTATION_@@ WITH_@@ MAXIMUM_@@ HAM@@ M@@ ING_@@ DISTANCE | def max@@ Ham@@ ming ( arr , n ) : NEW_LINE INDENT br@@ r = [ 0 ] * ( 2 * n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT br@@ r [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT br@@ r [ n + i ] = arr [ i ] NEW_LINE DEDENT max@@ H@@ am = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr@@ H@@ am = 0 NEW_LINE k = 0 NEW_LINE for j in range ( i , i + n ) : NEW_LINE INDENT if br@@ r [ j ] != arr [ k ] : NEW_LINE INDENT curr@@ H@@ am += 1 NEW_LINE k = k + 1 NEW_LINE DEDENT DEDENT if curr@@ H@@ am == n : NEW_LINE INDENT return n NEW_LINE DEDENT max@@ H@@ am = max ( max@@ H@@ am , curr@@ H@@ am ) NEW_LINE DEDENT return max@@ H@@ am NEW_LINE DEDENT
GI@@ V@@ EN_@@ A_@@ NUMBER_@@ N_@@ GENERATE_@@ BIT_@@ PATTER@@ NS_@@ FROM_@@ 0_@@ TO_@@ 2@@ N_@@ 1@@ _S@@ O_@@ TH@@ AT_@@ SUCCE@@ SSI@@ VE_@@ PATTER@@ NS_@@ DIFF@@ ER_@@ BY_@@ ONE_@@ BIT | def generate@@ Gray@@ arr ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT arr = list ( ) NEW_LINE arr . append ( "0" ) NEW_LINE arr . append ( "1" ) NEW_LINE i = 2 NEW_LINE j = 0 NEW_LINE while ( True ) : NEW_LINE INDENT if i >= 1 << n : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT arr . append ( arr [ j ] ) NEW_LINE DEDENT for j in range ( i ) : NEW_LINE INDENT arr [ j ] = "0" + arr [ j ] NEW_LINE DEDENT for j in range ( i , 2 * i ) : NEW_LINE INDENT arr [ j ] = "1" + arr [ j ] NEW_LINE DEDENT i = i << 1 NEW_LINE DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT
MIN@@ IM@@ UM@@ _SW@@ AP@@ S_@@ REQUIRED_@@ BR@@ ING_@@ ELEMEN@@ TS_@@ LESS_@@ EQUAL_@@ K_@@ TO@@ GE@@ THER | def min@@ Swap ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] <= k ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT bad = 0 NEW_LINE for i in range ( 0 , count ) : NEW_LINE INDENT if ( arr [ i ] > k ) : NEW_LINE INDENT bad = bad + 1 NEW_LINE DEDENT DEDENT ans = bad NEW_LINE j = count NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( j == n ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ i ] > k ) : NEW_LINE INDENT bad = bad - 1 NEW_LINE DEDENT if ( arr [ j ] > k ) : NEW_LINE INDENT bad = bad + 1 NEW_LINE DEDENT ans = min ( ans , bad ) NEW_LINE j = j + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
FIND_@@ N@@ TH_@@ FI@@ BON@@ ACC@@ I_@@ NUMBER_@@ USING_@@ GO@@ LD@@ EN_@@ RATIO | def fi@@ b ( n ) : NEW_LINE INDENT if n < 6 : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT t = 5 NEW_LINE fn = 5 NEW_LINE while t < n : NEW_LINE INDENT fn = round ( fn * PHI ) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT
SOR@@ TING_@@ ARRAY_@@ REVERSE_@@ AR@@ OUND_@@ MIDDLE | def if@@ Possible ( arr , n ) : NEW_LINE INDENT cp = [ 0 ] * n NEW_LINE cp = arr NEW_LINE cp . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( not ( arr [ i ] == cp [ i ] ) and not ( arr [ n - 1 - i ] == cp [ i ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
COUNT_@@ ROTA@@ TIONS_@@ DI@@ VISI@@ BLE_@@ 4 | def count@@ Rot@@ ations ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE if ( l == 1 ) : NEW_LINE INDENT one@@ Digit = ( int ) ( n [ 0 ] ) NEW_LINE if ( one@@ Digit % 4 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT two@@ Digit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i + 1 ] ) NEW_LINE if ( two@@ Digit % 4 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT two@@ Digit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] ) NEW_LINE if ( two@@ Digit % 4 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
N_@@ TH_@@ NUMBER_@@ WHO@@ SE_@@ S@@ UM_@@ OF_@@ DIG@@ IT@@ S_@@ IS_@@ T@@ EN_@@ 2 | def find@@ N@@ th ( n ) : NEW_LINE INDENT n@@ th@@ Element = 19 + ( n - 1 ) * 9 NEW_LINE out@@ lier@@ sCount = int ( math . log10 ( n@@ th@@ Element ) ) - 1 NEW_LINE n@@ th@@ Element += 9 * out@@ lier@@ sCount NEW_LINE return n@@ th@@ Element NEW_LINE DEDENT
PRI@@ MALI@@ TY_@@ TEST@@ _SET_@@ 1_@@ INTRO@@ DUC@@ TION_@@ AND@@ _S@@ CHOOL_@@ METHOD_@@ 1 | def is@@ Prime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
MINIMUM_@@ NUMBER@@ _SUB@@ SE@@ TS_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ 1 | def subset ( arr , n ) : NEW_LINE INDENT mp = { i : 0 for i in range ( 10 ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT res = max ( res , value ) NEW_LINE DEDENT return res NEW_LINE DEDENT
RE@@ CAM@@ AN@@ S@@ _SEQU@@ ENCE_@@ 1 | def rec@@ am@@ an ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( 0 , " , " , end = ' ' ) NEW_LINE s = set ( [ ] ) NEW_LINE s . add ( 0 ) NEW_LINE prev = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = prev - i NEW_LINE if ( curr < 0 or curr in s ) : NEW_LINE INDENT curr = prev + i NEW_LINE DEDENT s . add ( curr ) NEW_LINE print ( curr , " , " , end = ' ' ) NEW_LINE prev = curr NEW_LINE DEDENT DEDENT
GENERATE_@@ ROTA@@ TIONS_@@ GI@@ V@@ EN_@@ STRING_@@ 1 | def print@@ Rot@@ ated@@ String ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE temp = string + string NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( temp [ i + j ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
FIT@@ T@@ ING@@ _SH@@ EL@@ VE@@ S_@@ PRO@@ BLE@@ M | def min@@ Space@@ Pre@@ fer@@ Large ( w , m , n ) : NEW_LINE INDENT num_@@ m = 0 NEW_LINE num_@@ n = 0 NEW_LINE rem = w NEW_LINE p = 0 NEW_LINE q = 0 NEW_LINE r = 0 NEW_LINE while ( w >= n ) : NEW_LINE INDENT p = w / m NEW_LINE r = w % m NEW_LINE if ( r <= rem ) : NEW_LINE INDENT num_@@ m = p NEW_LINE num_@@ n = q NEW_LINE rem = r NEW_LINE DEDENT q += 1 NEW_LINE w -= n NEW_LINE DEDENT print ( str ( int ( num_@@ m ) ) + " ▁ " + str ( num_@@ n ) + " ▁ " + str ( rem ) ) NEW_LINE DEDENT
COUNT_@@ STRING@@ S_@@ CAN_@@ FOR@@ MED_@@ USING_@@ B_@@ C_@@ GI@@ V@@ EN_@@ CONSTRA@@ INT@@ S_@@ 1 | def count@@ Str ( n ) : NEW_LINE INDENT return ( 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) // 2 ) ) NEW_LINE DEDENT
DI@@ VISIBILITY_@@ BY_@@ 12_@@ FOR_@@ A_@@ LARGE_@@ NUMBER | def is@@ D@@ visible@@ By@@ 12 ( num ) : NEW_LINE INDENT if ( len ( num ) >= 3 ) : NEW_LINE INDENT d1 = int ( num [ len ( num ) - 1 ] ) ; NEW_LINE if ( d1 % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d2 = int ( num [ len ( num ) - 2 ] ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT sum += int ( num [ i ] ) NEW_LINE DEDENT return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT number = int ( num ) NEW_LINE return ( number % 12 == 0 ) NEW_LINE DEDENT DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 36@@ _@@ CU@@ T_@@ A_@@ RO@@ PE_@@ TO_@@ MAXI@@ MI@@ ZE_@@ PRODUCT_@@ 1 | def max@@ Prod ( n ) : NEW_LINE INDENT if ( n == 2 or n == 3 ) : NEW_LINE INDENT return ( n - 1 ) NEW_LINE DEDENT res = 1 NEW_LINE while ( n > 4 ) : NEW_LINE INDENT n -= 3 ; NEW_LINE res *= 3 ; NEW_LINE DEDENT return ( n * res ) NEW_LINE DEDENT
RETURN_@@ A_@@ PA@@ IR_@@ WITH_@@ MAXIMUM_@@ PRODUCT_@@ IN_@@ ARRAY_@@ OF_@@ INTEG@@ ERS | def max@@ Product ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " No ▁ pairs ▁ exists " ) NEW_LINE return NEW_LINE DEDENT a = arr [ 0 ] ; b = arr [ 1 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] > a * b ) : NEW_LINE INDENT a = arr [ i ] ; b = arr [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( " Max ▁ product ▁ pair ▁ is ▁ { " , a , " , " , b , " } " , sep = " " ) NEW_LINE DEDENT
S@@ UM_@@ MATRIX_@@ ELEMENT_@@ ABSOL@@ UTE_@@ DIFF@@ ER@@ ENCE_@@ ROW_@@ COLUMN_@@ NUMB@@ ERS_@@ 2 | def find@@ Sum ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += ( n * ( n + 1 ) ) / 2 NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE return int ( sum ) NEW_LINE DEDENT
PRINT_@@ MATRIX_@@ ANTI@@ SPIR@@ AL_@@ FORM | def anti@@ Sp@@ ir@@ al@@ Traversal ( m , n , a ) : NEW_LINE INDENT k = 0 NEW_LINE l = 0 NEW_LINE stk = [ ] NEW_LINE while ( k <= m and l <= n ) : NEW_LINE INDENT for i in range ( l , n + 1 ) : NEW_LINE INDENT stk . append ( a [ k ] [ i ] ) NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m + 1 ) : NEW_LINE INDENT stk . append ( a [ i ] [ n ] ) NEW_LINE DEDENT n -= 1 NEW_LINE if ( k <= m ) : NEW_LINE INDENT for i in range ( n , l - 1 , - 1 ) : NEW_LINE INDENT stk . append ( a [ m ] [ i ] ) NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if ( l <= n ) : NEW_LINE INDENT for i in range ( m , k - 1 , - 1 ) : NEW_LINE INDENT stk . append ( a [ i ] [ l ] ) NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT while len ( stk ) != 0 : NEW_LINE INDENT print ( str ( stk [ - 1 ] ) , end = " ▁ " ) NEW_LINE stk . pop ( ) NEW_LINE DEDENT DEDENT
DI@@ CE_@@ THROW_@@ PRO@@ BLE@@ M_@@ 1 | def find@@ W@@ ays ( f , d , s ) : NEW_LINE INDENT mem = [ [ 0 for i in range ( s + 1 ) ] for j in range ( d + 1 ) ] NEW_LINE mem [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT for j in range ( 1 , s + 1 ) : NEW_LINE INDENT mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] NEW_LINE if j - f - 1 >= 0 : NEW_LINE INDENT mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] NEW_LINE DEDENT DEDENT DEDENT return mem [ d ] [ s ] NEW_LINE DEDENT
WRITE_@@ A_@@ C_@@ PROGRAM_@@ TO_@@ CAL@@ CUL@@ ATE_@@ PO@@ WX@@ N | def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : return 1 NEW_LINE elif ( int ( y % 2 ) == 0 ) : NEW_LINE INDENT return ( power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) ) NEW_LINE DEDENT DEDENT
SM@@ ALLE@@ ST_@@ WINDOW_@@ CONTAIN@@ S_@@ CHARAC@@ TER@@ S_@@ STRING | def find@@ Sub@@ String ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dist@@ _count = len ( set ( [ x for x in str ] ) ) NEW_LINE count , start , start_index , min_@@ len = 0 , 0 , - 1 , 99999999@@ 99 NEW_LINE curr_@@ count = defaultdict ( lambda : 0 ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT curr_@@ count [ str [ j ] ] += 1 NEW_LINE if curr_@@ count [ str [ j ] ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == dist@@ _count : NEW_LINE INDENT while curr_@@ count [ str [ start ] ] > 1 : NEW_LINE INDENT if curr_@@ count [ str [ start ] ] > 1 : NEW_LINE INDENT curr_@@ count [ str [ start ] ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_@@ window = j - start + 1 NEW_LINE if min_@@ len > len_@@ window : NEW_LINE INDENT min_@@ len = len_@@ window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT return str [ start_index : start_index + min_@@ len ] NEW_LINE DEDENT
CLU@@ STER@@ ING@@ PARTI@@ TION@@ ING_@@ AN_@@ ARRAY@@ _SU@@ CH_@@ TH@@ AT_@@ S@@ UM_@@ OF@@ _S@@ QU@@ ARE_@@ DIFF@@ ER@@ EN@@ CES_@@ IS_@@ MIN@@ IMUM | def solve ( i , par , a , n , k , current_@@ ans ) : NEW_LINE INDENT if ( par > k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT global ans NEW_LINE if ( par == k and i == n - 1 ) : NEW_LINE INDENT ans = min ( ans , current_@@ ans ) NEW_LINE return 0 NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT solve ( j , par + 1 , a , n , k , current_@@ ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) NEW_LINE DEDENT DEDENT
PROGRAM_@@ FIN@@ D_S@@ MAL@@ LE@@ ST_@@ LAR@@ GE@@ ST_@@ WORD_@@ STRING | def min@@ Max@@ Length@@ Words ( inp ) : NEW_LINE INDENT length = len ( inp ) NEW_LINE si = ei = 0 NEW_LINE min_@@ length = length NEW_LINE min_@@ start_index = max_length = max_@@ start_index = 0 NEW_LINE while ei <= length : NEW_LINE INDENT if ( ei < length ) and ( inp [ ei ] != " ▁ " ) : NEW_LINE INDENT ei += 1 NEW_LINE DEDENT else : NEW_LINE INDENT curr_@@ length = ei - si NEW_LINE if curr_@@ length < min_@@ length : NEW_LINE INDENT min_@@ length = curr_@@ length NEW_LINE min_@@ start_index = si NEW_LINE DEDENT if curr_@@ length > max_length : NEW_LINE INDENT max_length = curr_@@ length NEW_LINE max_@@ start_index = si NEW_LINE DEDENT ei += 1 NEW_LINE si = ei NEW_LINE DEDENT DEDENT min@@ Word = inp [ min_@@ start_index : min_@@ start_index + min_@@ length ] NEW_LINE max@@ Word = inp [ max_@@ start_index : max_length ] NEW_LINE print ( " Minimum ▁ length ▁ word : ▁ " , min@@ Word ) NEW_LINE print ( " Maximum ▁ length ▁ word : ▁ " , max@@ Word ) NEW_LINE DEDENT
CHECK_@@ VALI@@ D@@ _SEQU@@ ENCE_@@ DI@@ VISI@@ BLE_@@ M_@@ 1 | def is@@ Possible ( n , index , modulo , M , arr , dp ) : NEW_LINE INDENT modulo = ( ( modulo % M ) + M ) % M NEW_LINE if ( index == n ) : NEW_LINE INDENT if ( modulo == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ index ] [ modulo ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ modulo ] NEW_LINE DEDENT place@@ Add = is@@ Possible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) NEW_LINE place@@ Minus = is@@ Possible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) NEW_LINE res = bool ( place@@ Add or place@@ Minus ) NEW_LINE dp [ index ] [ modulo ] = res NEW_LINE return res NEW_LINE DEDENT
MINIMUM_@@ OPERATION_@@ MAKE_@@ ELEMEN@@ TS_@@ EQUAL_@@ ARRAY | def min@@ Operation ( arr , n ) : NEW_LINE INDENT Hash = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Hash [ arr [ i ] ] += 1 NEW_LINE DEDENT max_@@ count = 0 NEW_LINE for i in Hash : NEW_LINE INDENT if max_@@ count < Hash [ i ] : NEW_LINE INDENT max_@@ count = Hash [ i ] NEW_LINE DEDENT DEDENT return n - max_@@ count NEW_LINE DEDENT
HYPER@@ CUBE_@@ GRAP@@ H | def power ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 2 * power ( n - 1 ) NEW_LINE DEDENT
PROGRAM_@@ FIND_@@ COR@@ RELA@@ TION_@@ CO@@ EF@@ FI@@ CI@@ ENT | def correlation@@ Coefficient ( X , Y , n ) : NEW_LINE INDENT sum_@@ X = 0 NEW_LINE sum_@@ Y = 0 NEW_LINE sum_@@ XY = 0 NEW_LINE square@@ Sum@@ _@@ X = 0 NEW_LINE square@@ Sum@@ _@@ Y = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum_@@ X = sum_@@ X + X [ i ] NEW_LINE sum_@@ Y = sum_@@ Y + Y [ i ] NEW_LINE sum_@@ XY = sum_@@ XY + X [ i ] * Y [ i ] NEW_LINE square@@ Sum@@ _@@ X = square@@ Sum@@ _@@ X + X [ i ] * X [ i ] NEW_LINE square@@ Sum@@ _@@ Y = square@@ Sum@@ _@@ Y + Y [ i ] * Y [ i ] NEW_LINE i = i + 1 NEW_LINE DEDENT corr = ( float ) ( n * sum_@@ XY - sum_@@ X * sum_@@ Y ) / NEW_LINE INDENT ( float ) ( math . sqrt ( ( n * square@@ Sum@@ _@@ X - sum_@@ X * sum_@@ X ) * ( n * square@@ Sum@@ _@@ Y - sum_@@ Y * sum_@@ Y ) ) ) NEW_LINE DEDENT return corr NEW_LINE DEDENT
COUNT_@@ PA@@ LIN@@ DRO@@ MI@@ C@@ _SUB@@ SEQU@@ ENCE_@@ GI@@ V@@ EN_@@ STRING | def count@@ PS ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE c@@ ps = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N + 2 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT c@@ ps [ i ] [ i ] = 1 NEW_LINE DEDENT for L in range ( 2 , N + 1 ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT k = L + i - 1 NEW_LINE if ( k < N ) : NEW_LINE INDENT if ( str [ i ] == str [ k ] ) : NEW_LINE INDENT c@@ ps [ i ] [ k ] = ( c@@ ps [ i ] [ k - 1 ] + c@@ ps [ i + 1 ] [ k ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT c@@ ps [ i ] [ k ] = ( c@@ ps [ i ] [ k - 1 ] + c@@ ps [ i + 1 ] [ k ] - c@@ ps [ i + 1 ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return c@@ ps [ 0 ] [ N - 1 ] NEW_LINE DEDENT
SM@@ ALLE@@ ST_@@ POWER_@@ OF_@@ 2_@@ GREATER_@@ TH@@ AN_@@ OR_@@ EQUAL_@@ TO_@@ N_@@ 1 | def next@@ PowerOf@@ 2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p ; NEW_LINE DEDENT
FIND_@@ LAST_@@ DIG@@ IT_@@ FAC@@ TOR@@ I@@ AL_@@ DI@@ VIDE@@ S_@@ FAC@@ TOR@@ I@@ AL_@@ B | def compute@@ Last@@ Digit ( A , B ) : NEW_LINE INDENT variable = 1 NEW_LINE if ( A == B ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( ( B - A ) >= 5 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( A + 1 , B + 1 ) : NEW_LINE INDENT variable = ( variable * ( i % 10 ) ) % 10 NEW_LINE DEDENT return variable % 10 NEW_LINE DEDENT DEDENT
NUMBER@@ _SUB@@ STRING@@ S_@@ DI@@ VISI@@ BLE_@@ 4_@@ STRING_@@ INTEG@@ ERS | def count@@ Di@@ vis@@ ble@@ by@@ 4 ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 ; NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( s [ i ] == '4' or s [ i ] == '8' or s [ i ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n - 1 , 1 ) : NEW_LINE INDENT h = ( ord ( s [ i ] ) - ord ( '0' ) ) * 10 + ( ord ( s [ i + 1 ] ) - ord ( '0' ) ) NEW_LINE if ( h % 4 == 0 ) : NEW_LINE INDENT count = count + i + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
DECODE_@@ MEDI@@ AN_@@ STRING_@@ ORIGIN@@ AL_@@ STRING | def decode@@ Median@@ String ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE s1 = " " NEW_LINE if ( l % 2 == 0 ) : NEW_LINE INDENT is@@ Even = True NEW_LINE DEDENT else : NEW_LINE INDENT is@@ Even = False NEW_LINE DEDENT for i in range ( 0 , l , 2 ) : NEW_LINE INDENT if ( is@@ Even ) : NEW_LINE INDENT s1 = s [ i ] + s1 NEW_LINE s1 += s [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( l - i > 1 ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s1 = s [ i + 1 ] + s1 NEW_LINE DEDENT else : NEW_LINE INDENT s1 += s [ i ] NEW_LINE DEDENT DEDENT DEDENT return s1 NEW_LINE DEDENT
NUMBER_@@ WHI@@ CH_@@ HAS_@@ THE_@@ MAXIMUM_@@ NUMBER_OF_@@ DISTIN@@ CT_@@ PRI@@ ME_@@ FAC@@ TOR@@ S_IN_@@ RANGE_@@ M_@@ TO_@@ N | def maximum@@ Number@@ Distinct@@ Prime@@ Range ( m , n ) : NEW_LINE INDENT factor@@ Count = [ 0 ] * ( n + 1 ) NEW_LINE prime = [ False ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT factor@@ Count [ i ] = 0 NEW_LINE prime [ i ] = True NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT factor@@ Count [ i ] = 1 NEW_LINE for j in range ( i * 2 , n + 1 , i ) : NEW_LINE INDENT factor@@ Count [ j ] += 1 NEW_LINE prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT max = factor@@ Count [ m ] NEW_LINE num = m NEW_LINE for i in range ( m , n + 1 ) : NEW_LINE INDENT if ( factor@@ Count [ i ] > max ) : NEW_LINE INDENT max = factor@@ Count [ i ] NEW_LINE num = i NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT
NUMBER_@@ EQUAL_@@ PAIR@@ S_@@ STRING | def count@@ Pairs ( s ) : NEW_LINE INDENT cnt = [ 0 for i in range ( 0 , MAX ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT cnt [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT ans += cnt [ i ] * cnt [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
COUNT_@@ NUMBER_@@ WAY@@ S_@@ REACH_@@ DESTIN@@ ATION_@@ MA@@ ZE | def count@@ Paths ( ma@@ ze ) : NEW_LINE INDENT if ( ma@@ ze [ 0 ] [ 0 ] == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( R ) : NEW_LINE INDENT if ( ma@@ ze [ i ] [ 0 ] == 0 ) : NEW_LINE INDENT ma@@ ze [ i ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , C , 1 ) : NEW_LINE INDENT if ( ma@@ ze [ 0 ] [ i ] == 0 ) : NEW_LINE INDENT ma@@ ze [ 0 ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , R , 1 ) : NEW_LINE INDENT for j in range ( 1 , C , 1 ) : NEW_LINE INDENT if ( ma@@ ze [ i ] [ j ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( ma@@ ze [ i - 1 ] [ j ] > 0 ) : NEW_LINE INDENT ma@@ ze [ i ] [ j ] = ( ma@@ ze [ i ] [ j ] + ma@@ ze [ i - 1 ] [ j ] ) NEW_LINE DEDENT if ( ma@@ ze [ i ] [ j - 1 ] > 0 ) : NEW_LINE INDENT ma@@ ze [ i ] [ j ] = ( ma@@ ze [ i ] [ j ] + ma@@ ze [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if ( ma@@ ze [ R - 1 ] [ C - 1 ] > 0 ) : NEW_LINE INDENT return ma@@ ze [ R - 1 ] [ C - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
FIND_@@ MAX@@ IM@@ UM@@ _S@@ UM_@@ POSSI@@ BLE_@@ EQUAL@@ _S@@ UM_@@ THRE@@ E_@@ ST@@ AC@@ KS | def max@@ Sum ( stack@@ 1 , stack@@ 2 , stack@@ 3 , n1 , n2 , n3 ) : NEW_LINE INDENT sum@@ 1 , sum@@ 2 , sum@@ 3 = 0 , 0 , 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT sum@@ 1 += stack@@ 1 [ i ] NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT sum@@ 2 += stack@@ 2 [ i ] NEW_LINE DEDENT for i in range ( n3 ) : NEW_LINE INDENT sum@@ 3 += stack@@ 3 [ i ] NEW_LINE DEDENT top@@ 1 , top@@ 2 , top@@ 3 = 0 , 0 , 0 NEW_LINE ans = 0 NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( top@@ 1 == n1 or top@@ 2 == n2 or top@@ 3 == n3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( sum@@ 1 == sum@@ 2 and sum@@ 2 == sum@@ 3 ) : NEW_LINE INDENT return sum@@ 1 NEW_LINE DEDENT if ( sum@@ 1 >= sum@@ 2 and sum@@ 1 >= sum@@ 3 ) : NEW_LINE INDENT sum@@ 1 -= stack@@ 1 [ top@@ 1 ] NEW_LINE top@@ 1 = top@@ 1 + 1 NEW_LINE DEDENT elif ( sum@@ 2 >= sum@@ 3 and sum@@ 2 >= sum@@ 3 ) : NEW_LINE INDENT sum@@ 2 -= stack@@ 2 [ top@@ 2 ] NEW_LINE top@@ 2 = top@@ 2 + 1 NEW_LINE DEDENT elif ( sum@@ 3 >= sum@@ 2 and sum@@ 3 >= sum@@ 1 ) : NEW_LINE INDENT sum@@ 3 -= stack@@ 3 [ top@@ 3 ] NEW_LINE top@@ 3 = top@@ 3 + 1 NEW_LINE DEDENT DEDENT DEDENT
MAX@@ IM@@ UM@@ _S@@ UM@@ _SUB@@ SEQU@@ ENCE_@@ LEA@@ ST_@@ K_@@ DISTAN@@ T_@@ ELEMENTS | def max@@ Sum ( arr , N , k ) : NEW_LINE INDENT MS = [ 0 for i in range ( N ) ] NEW_LINE MS [ N - 1 ] = arr [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( i + k + 1 >= N ) : NEW_LINE INDENT MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) NEW_LINE DEDENT DEDENT return MS [ 0 ] NEW_LINE DEDENT
CHECK_@@ WHE@@ THER_@@ GI@@ V@@ EN_@@ NUMBER_@@ EV@@ EN_@@ OD@@ D_@@ 1 | def is@@ Even ( n ) : NEW_LINE INDENT return ( not ( n & 1 ) ) NEW_LINE DEDENT
SORT_@@ ARRAY_@@ TWO_@@ HAL@@ VE@@ S_S@@ OR@@ TED | def merge@@ Two@@ Half ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE DEDENT
PYTH@@ AG@@ O@@ RE@@ AN_@@ QUAD@@ RUP@@ LE | def py@@ th@@ ag@@ ore@@ an_@@ quad@@ r@@ uple ( a , b , c , d ) : NEW_LINE INDENT sum = a * a + b * b + c * c ; NEW_LINE if ( d * d == sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
FIND_@@ THE_@@ MAXIMUM_@@ OF_@@ MIN@@ IM@@ UM@@ S_@@ FOR_@@ EVER@@ Y_@@ WINDOW@@ _SIZE_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY | def print@@ Max@@ Of@@ Min ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT max@@ Of@@ Min = INT_@@ MIN ; NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( arr [ i + j ] < min ) : NEW_LINE INDENT min = arr [ i + j ] NEW_LINE DEDENT DEDENT if ( min > max@@ Of@@ Min ) : NEW_LINE INDENT max@@ Of@@ Min = min NEW_LINE DEDENT DEDENT print ( max@@ Of@@ Min , end = " ▁ " ) NEW_LINE DEDENT DEDENT
COUNT_@@ S@@ UM_@@ OF_@@ DIG@@ IT@@ S_IN_@@ NUMB@@ ERS_@@ FROM_@@ 1_@@ TO_@@ N | def sum@@ Of@@ Digit@@ sFrom@@ 1@@ To@@ N ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT d = ( int ) ( math . log10 ( n ) ) NEW_LINE a = [ 0 ] * ( d + 1 ) NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 45 NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( math . ceil ( math . pow ( 10 , i - 1 ) ) ) NEW_LINE DEDENT p = ( int ) ( math . ceil ( math . pow ( 10 , d ) ) ) NEW_LINE ms@@ d = n // p NEW_LINE return ( int ) ( ms@@ d * a [ d ] + ( ms@@ d * ( ms@@ d - 1 ) // 2 ) * p + ms@@ d * ( 1 + n % p ) + sum@@ Of@@ Digit@@ sFrom@@ 1@@ To@@ N ( n % p ) ) NEW_LINE DEDENT
RECUR@@ SI@@ VEL@@ Y_@@ BREAK_@@ NUMBER_@@ 3_@@ PAR@@ TS_@@ GET_@@ MAX@@ IM@@ UM@@ _S@@ UM@@ _1 | def break@@ Sum ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i / 3 ) ] + dp [ int ( i / 4 ) ] , i ) ; NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
FIND_@@ REPE@@ ATING_@@ ELEMENT_@@ SOR@@ TED_@@ ARRAY@@ _SIZE_@@ N | def find@@ Repe@@ ating@@ Element ( arr , low , high ) : NEW_LINE INDENT if low > high : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE if ( arr [ mid ] != mid + 1 ) : NEW_LINE INDENT if ( mid > 0 and arr [ mid ] == arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT return find@@ Repe@@ ating@@ Element ( arr , low , mid - 1 ) NEW_LINE DEDENT return find@@ Repe@@ ating@@ Element ( arr , mid + 1 , high ) NEW_LINE DEDENT
COUNT_@@ SUB@@ ARRAY@@ S_@@ EQUAL_@@ NUMBER_@@ 1@@ S_@@ 0@@ S_@@ 1 | def count@@ Sub@@ arr@@ With@@ Equal@@ Zero@@ And@@ One ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE Sum = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT Sum += arr [ i ] NEW_LINE if ( Sum == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( Sum in mp . keys ( ) ) : NEW_LINE INDENT count += mp [ Sum ] NEW_LINE DEDENT mp [ Sum ] = mp . get ( Sum , 0 ) + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
UNI@@ ON_@@ AND_@@ INTER@@ SECTION_@@ OF_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S_@@ 2_1 | def print@@ Intersection ( ar@@ r1 , ar@@ r2 , m , n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if ar@@ r1 [ i ] < ar@@ r2 [ j ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ar@@ r2 [ j ] < ar@@ r1 [ i ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( ar@@ r2 [ j ] ) NEW_LINE j += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT
COUNT_@@ ALL_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQU@@ EN@@ CES | def count@@ Sub ( arr , n ) : NEW_LINE INDENT count = [ 0 for i in range ( 10 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( arr [ i ] - 1 , - 1 , - 1 ) : NEW_LINE INDENT count [ arr [ i ] ] += count [ j ] NEW_LINE DEDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT result += count [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
SM@@ ALLE@@ ST_@@ NUMBER@@ _S@@ UM_@@ DIG@@ IT@@ S_@@ N_@@ DI@@ VISI@@ BLE_@@ 10@@ N | def digit@@ s@@ Num ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT if ( N % 9 != 0 ) : NEW_LINE INDENT print ( N % 9 , end = " " ) NEW_LINE DEDENT for i in range ( 1 , int ( N / 9 ) + 1 ) : NEW_LINE INDENT print ( "@@ 9" , end = " " ) NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
FIND_@@ THE_@@ NUMBER_@@ OC@@ CURR@@ ING_@@ OD@@ D_@@ NUMBER_OF_@@ TIME@@ S_@@ 1 | def getO@@ dd@@ Occurren@@ ce ( arr , size ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT Hash [ arr [ i ] ] = Hash . get ( arr [ i ] , 0 ) + 1 ; NEW_LINE DEDENT for i in Hash : NEW_LINE INDENT if ( Hash [ i ] % 2 != 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
CHECK_@@ IF_@@ X_@@ CAN_@@ GI@@ VE_@@ CHANGE_@@ TO_@@ EVER@@ Y_@@ PERS@@ ON_@@ IN_@@ THE_@@ QUEUE | def is@@ Change@@ able ( notes , n ) : NEW_LINE INDENT fi@@ ve@@ Count = 0 NEW_LINE ten@@ Count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( notes [ i ] == 5 ) : NEW_LINE INDENT fi@@ ve@@ Count += 1 NEW_LINE DEDENT elif ( notes [ i ] == 10 ) : NEW_LINE INDENT if ( fi@@ ve@@ Count > 0 ) : NEW_LINE INDENT fi@@ ve@@ Count -= 1 NEW_LINE ten@@ Count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( fi@@ ve@@ Count > 0 and ten@@ Count > 0 ) : NEW_LINE INDENT fi@@ ve@@ Count -= 1 NEW_LINE ten@@ Count -= 1 NEW_LINE DEDENT elif ( fi@@ ve@@ Count >= 3 ) : NEW_LINE INDENT fi@@ ve@@ Count -= 3 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT return 1 NEW_LINE DEDENT
MAXIMUM_@@ MINIMUM_@@ VALU@@ ES_@@ AL@@ GE@@ BRA@@ IC_@@ EXPRESSION | def min@@ Max@@ Values ( arr , n , m ) : NEW_LINE INDENT sum = 0 NEW_LINE INF = 1000000000 NEW_LINE MAX = 50 NEW_LINE for i in range ( 0 , ( n + m ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE arr [ i ] += 50 NEW_LINE DEDENT dp = [ [ 0 for x in range ( MAX * MAX + 1 ) ] for y in range ( MAX + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 0 , ( n + m ) ) : NEW_LINE INDENT for k in range ( min ( n , i + 1 ) , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , MAX * MAX + 1 ) : NEW_LINE INDENT if ( dp [ k - 1 ] [ j ] ) : NEW_LINE INDENT dp [ k ] [ j + arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT max_value = - 1 * INF NEW_LINE min_value = INF NEW_LINE for i in range ( 0 , MAX * MAX + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ i ] ) : NEW_LINE INDENT temp = i - 50 * n NEW_LINE max_value = max ( max_value , temp * ( sum - temp ) ) NEW_LINE min_value = min ( min_value , temp * ( sum - temp ) ) NEW_LINE DEDENT DEDENT print ( " Maximum ▁ Value : ▁ { } \n Minimum ▁ Value : ▁ { } " . format ( max_value , min_value ) ) NEW_LINE DEDENT
MULTI@@ PLY_@@ AN_@@ INTEGER_@@ WITH_@@ 3_@@ 5 | def multiply@@ With@@ 3@@ Point@@ 5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT
MINIMUM_@@ CEL@@ LS_@@ REQUIRED_@@ REACH_@@ DESTIN@@ ATION_@@ JUM@@ PS_@@ EQUAL_@@ CELL_@@ VALUES | def min@@ Cells ( mat , m , n ) : NEW_LINE INDENT dp = [ [ MAX for i in range ( n ) ] for i in range ( m ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( dp [ i ] [ j ] != MAX and ( j + mat [ i ] [ j ] ) < n and ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) : NEW_LINE INDENT dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT if ( dp [ i ] [ j ] != MAX and ( i + mat [ i ] [ j ] ) < m and ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) : NEW_LINE INDENT dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT if ( dp [ m - 1 ] [ n - 1 ] != MAX ) : NEW_LINE INDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
FIND_@@ INDEX_@@ OF_@@ AN_@@ EXTRA_@@ ELEMENT_@@ PRES@@ ENT_@@ IN_@@ ONE@@ _S@@ OR@@ TED_@@ ARRAY | def find@@ Extra ( ar@@ r1 , ar@@ r2 , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( ar@@ r1 [ i ] != ar@@ r2 [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
CAL@@ CUL@@ ATE_@@ S@@ UM_@@ OF_@@ ALL_@@ NUMB@@ ERS_@@ PRES@@ ENT_@@ IN_@@ A_@@ STRING | def find@@ Sum ( str1 ) : NEW_LINE INDENT temp = " " NEW_LINE Sum = 0 NEW_LINE for ch in str1 : NEW_LINE INDENT if ( ch . isdigit ( ) ) : NEW_LINE INDENT temp += ch NEW_LINE DEDENT else : NEW_LINE INDENT Sum += int ( temp ) NEW_LINE temp = "0" NEW_LINE DEDENT DEDENT return Sum + int ( temp ) NEW_LINE DEDENT
CHECK_@@ REVER@@ SING@@ _SUB_@@ ARRAY_@@ MAKE_@@ ARRA@@ Y_S@@ OR@@ TED | def check@@ Reverse ( arr , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp [ i ] = arr [ i ] NEW_LINE DEDENT temp . sort ( ) NEW_LINE for front in range ( n ) : NEW_LINE INDENT if temp [ front ] != arr [ front ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for back in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if temp [ back ] != arr [ back ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if front >= back : NEW_LINE INDENT return True NEW_LINE DEDENT while front != back : NEW_LINE INDENT front += 1 NEW_LINE if arr [ front - 1 ] < arr [ front ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
GENERATE_@@ PYTH@@ AG@@ OR@@ AS_@@ TR@@ IP@@ LET_@@ SINGLE_@@ INTEGER | def evaluate ( n ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT print ( " No ▁ Py@@ th@@ ag@@ or@@ as " + " ▁ Trip@@ let ▁ exists " ) ; NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT var = n * n / 4 ; NEW_LINE print ( " Py@@ th@@ ag@@ or@@ as ▁ Trip@@ lets " + " ▁ exist ▁ i . e . ▁ " , end = " " ) ; NEW_LINE print ( int ( n ) , " ▁ " , int ( var - 1 ) , " ▁ " , int ( var + 1 ) ) ; NEW_LINE DEDENT elif ( n % 2 != 0 ) : NEW_LINE INDENT var = n * n + 1 ; NEW_LINE print ( " Py@@ th@@ ag@@ or@@ as ▁ Trip@@ lets ▁ " + " exist ▁ i . e . ▁ " , end = " " ) ; NEW_LINE print ( int ( n ) , " ▁ " , int ( var / 2 - 1 ) , " ▁ " , int ( var / 2 ) ) ; NEW_LINE DEDENT DEDENT
PE@@ TER@@ S@@ ON_@@ GRAP@@ H | def find@@ the@@ path ( S , v ) : NEW_LINE INDENT result [ 0 ] = v NEW_LINE for i in range ( 1 , len ( S ) ) : NEW_LINE INDENT if ( adj [ v ] [ ord ( S [ i ] ) - ord ( ' A ' ) ] or adj [ ord ( S [ i ] ) - ord ( ' A ' ) ] [ v ] ) : NEW_LINE INDENT v = ord ( S [ i ] ) - ord ( ' A ' ) NEW_LINE DEDENT elif ( adj [ v ] [ ord ( S [ i ] ) - ord ( ' A ' ) + 5 ] or adj [ ord ( S [ i ] ) - ord ( ' A ' ) + 5 ] [ v ] ) : NEW_LINE INDENT v = ord ( S [ i ] ) - ord ( ' A ' ) + 5 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT result . append ( v ) NEW_LINE DEDENT return True NEW_LINE DEDENT
COUNT_@@ NUMBER_@@ OF@@ _S@@ OL@@ U@@ TIONS_@@ OF_@@ X@@ 2_@@ 1_@@ MOD_@@ P_@@ IN_@@ GI@@ V@@ EN_@@ RANGE | def find@@ Count@@ Of@@ Solutions ( n , p ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for x in range ( 1 , p ) : NEW_LINE INDENT if ( ( x * x ) % p == 1 ) : NEW_LINE INDENT last = x + p * ( n / p ) ; NEW_LINE if ( last > n ) : NEW_LINE INDENT last -= p ; NEW_LINE DEDENT ans += ( ( last - x ) / p + 1 ) ; NEW_LINE DEDENT DEDENT return int ( ans ) ; NEW_LINE DEDENT
JUM@@ P@@ _SEARCH | def jump@@ Search ( arr , x , n ) : NEW_LINE INDENT step = math . sqrt ( n ) NEW_LINE prev = 0 NEW_LINE while arr [ int ( min ( step , n ) - 1 ) ] < x : NEW_LINE INDENT prev = step NEW_LINE step += math . sqrt ( n ) NEW_LINE if prev >= n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT while arr [ int ( prev ) ] < x : NEW_LINE INDENT prev += 1 NEW_LINE if prev == min ( step , n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if arr [ int ( prev ) ] == x : NEW_LINE INDENT return prev NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
FORM_@@ MINIMUM_@@ NUMBER_@@ FROM_@@ GI@@ VEN@@ _SEQU@@ ENCE | def Print@@ Min@@ Number@@ For@@ Pattern ( arr ) : NEW_LINE INDENT curr_@@ max = 0 NEW_LINE last_@@ entry = 0 NEW_LINE i = 0 NEW_LINE while i < len ( arr ) : NEW_LINE INDENT noOf@@ Next@@ D = 0 NEW_LINE if arr [ i ] == " I " : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == " D " : NEW_LINE INDENT noOf@@ Next@@ D += 1 NEW_LINE j += 1 NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT curr_@@ max = noOf@@ Next@@ D + 2 NEW_LINE last_@@ entry += 1 NEW_LINE print ( " " , last_@@ entry , end = " " ) NEW_LINE print ( " " , curr_@@ max , end = " " ) NEW_LINE last_@@ entry = curr_@@ max NEW_LINE DEDENT else : NEW_LINE INDENT curr_@@ max += noOf@@ Next@@ D + 1 NEW_LINE last_@@ entry = curr_@@ max NEW_LINE print ( " " , last_@@ entry , end = " " ) NEW_LINE DEDENT for k in range ( noOf@@ Next@@ D ) : NEW_LINE INDENT last_@@ entry -= 1 NEW_LINE print ( " " , last_@@ entry , end = " " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT elif arr [ i ] == " D " : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == " D " : NEW_LINE INDENT noOf@@ Next@@ D += 1 NEW_LINE j += 1 NEW_LINE DEDENT curr_@@ max = noOf@@ Next@@ D + 2 NEW_LINE print ( " " , curr_@@ max , curr_@@ max - 1 , end = " " ) NEW_LINE last_@@ entry = curr_@@ max - 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " " , last_@@ entry - 1 , end = " " ) NEW_LINE last_@@ entry -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
GI@@ V@@ EN_@@ LARGE_@@ NUMBER_@@ CHECK@@ _SUB@@ SEQU@@ ENCE_@@ DIG@@ IT@@ S_@@ DI@@ VISI@@ BLE_@@ 8 | def isSub@@ Seq@@ Di@@ visible ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE arr = [ 0 ] * l NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT for j in range ( i , l ) : NEW_LINE INDENT for k in range ( j , l ) : NEW_LINE INDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
PRINT_@@ FI@@ BON@@ AC@@ CI@@ _SEQU@@ ENCE_@@ USING_@@ 2_@@ VARIABLES | def fi@@ b ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n >= 0 ) : NEW_LINE INDENT print ( a , end = ' ▁ ' ) NEW_LINE DEDENT if ( n >= 1 ) : NEW_LINE INDENT print ( b , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE print ( c , end = ' ▁ ' ) NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT DEDENT
INTER@@ CHANGE_@@ ELEMEN@@ TS_@@ OF_@@ FIRST_@@ AND_@@ LAST_@@ RO@@ WS_@@ IN_@@ MATRIX | def inter@@ change@@ First@@ Last ( mat , n , m ) : NEW_LINE INDENT rows = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = mat [ 0 ] [ i ] NEW_LINE mat [ 0 ] [ i ] = mat [ rows - 1 ] [ i ] NEW_LINE mat [ rows - 1 ] [ i ] = t NEW_LINE DEDENT DEDENT
S@@ UM_@@ MATRIX_@@ ELEMENT_@@ ABSOL@@ UTE_@@ DIFF@@ ER@@ ENCE_@@ ROW_@@ COLUMN_@@ NUMB@@ ERS | def find@@ Sum ( n ) : NEW_LINE INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = abs ( i - j ) NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
FIND_@@ THE_@@ MAXIMUM_@@ ELEMENT_@@ IN_@@ AN_@@ ARRAY_@@ WHI@@ CH_@@ IS_@@ FIRST_@@ INCRE@@ AS@@ ING_@@ AND_@@ TH@@ EN_@@ DECRE@@ AS@@ ING | def find@@ Maximum ( arr , low , high ) : NEW_LINE INDENT max = arr [ low ] NEW_LINE i = low NEW_LINE for i in range ( high + 1 ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
PROGRAM_@@ CHECK_@@ DIAG@@ ON@@ AL_@@ MATRI@@ X@@ _SCAL@@ AR_@@ MATRIX_@@ 1 | def is@@ Scalar@@ Matrix ( mat ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , N - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
ST@@ OO@@ GE_@@ S@@ ORT | def st@@ oo@@ ge@@ sort ( arr , l , h ) : NEW_LINE INDENT if l >= h : NEW_LINE INDENT return NEW_LINE DEDENT if arr [ l ] > arr [ h ] : NEW_LINE INDENT t = arr [ l ] NEW_LINE arr [ l ] = arr [ h ] NEW_LINE arr [ h ] = t NEW_LINE DEDENT if h - l + 1 > 2 : NEW_LINE INDENT t = ( int ) ( ( h - l + 1 ) / 3 ) NEW_LINE st@@ oo@@ ge@@ sort ( arr , l , ( h - t ) ) NEW_LINE st@@ oo@@ ge@@ sort ( arr , l + t , ( h ) ) NEW_LINE st@@ oo@@ ge@@ sort ( arr , l , ( h - t ) ) NEW_LINE DEDENT DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 11_@@ EG@@ G_@@ DRO@@ PP@@ ING_@@ PU@@ ZZ@@ LE | def egg@@ Drop ( n , k ) : NEW_LINE INDENT if ( k == 1 or k == 0 ) : NEW_LINE INDENT return k NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return k NEW_LINE DEDENT min = sys . maxsize NEW_LINE for x in range ( 1 , k + 1 ) : NEW_LINE INDENT res = max ( egg@@ Drop ( n - 1 , x - 1 ) , egg@@ Drop ( n , k - x ) ) NEW_LINE if ( res < min ) : NEW_LINE INDENT min = res NEW_LINE DEDENT DEDENT return min + 1 NEW_LINE DEDENT
DIFF@@ ER@@ ENT_@@ WAY@@ S_S@@ UM_@@ N_@@ USING_@@ NUMB@@ ERS_@@ GREATER_@@ EQUAL_@@ M | def number@@ of@@ ways ( n , m ) : NEW_LINE INDENT dp = np . zeros ( ( n + 2 , n + 2 ) ) NEW_LINE dp [ 0 ] [ n + 1 ] = 1 NEW_LINE for k in range ( n , m - 1 , - 1 ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ k ] = dp [ i ] [ k + 1 ] NEW_LINE if ( i - k >= 0 ) : NEW_LINE INDENT dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
BU@@ BB@@ LE_@@ S@@ ORT | def bu@@ bble@@ Sort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 0 , n - i - 1 ) : NEW_LINE INDENT if arr [ j ] > arr [ j + 1 ] : NEW_LINE INDENT arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
GENERATE_@@ ROTA@@ TIONS_@@ GI@@ V@@ EN_@@ STRING | def print@@ Rot@@ ated@@ String ( str ) : NEW_LINE INDENT len@@ n = len ( str ) NEW_LINE temp = [ 0 ] * ( len@@ n ) NEW_LINE for i in range ( len@@ n ) : NEW_LINE INDENT j = i NEW_LINE k = 0 NEW_LINE while ( j < len ( str ) ) : NEW_LINE INDENT temp [ k ] = str [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT j = 0 NEW_LINE while ( j < i ) : NEW_LINE INDENT temp [ k ] = str [ j ] NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE DEDENT print ( * temp , sep = " " ) NEW_LINE DEDENT DEDENT
M@@ ID_@@ POINT_@@ LINE_@@ GENERA@@ TION_@@ ALGORITH@@ M | def mid@@ Point ( X1 , Y1 , X2 , Y2 ) : NEW_LINE INDENT dx = X2 - X1 NEW_LINE dy = Y2 - Y1 NEW_LINE d = dy - ( dx / 2 ) NEW_LINE x = X1 NEW_LINE y = Y1 NEW_LINE print ( x , " , " , y , " \n " ) NEW_LINE while ( x < X2 ) : NEW_LINE INDENT x = x + 1 NEW_LINE if ( d < 0 ) : NEW_LINE INDENT d = d + dy NEW_LINE DEDENT else : NEW_LINE INDENT d = d + ( dy - dx ) NEW_LINE y = y + 1 NEW_LINE DEDENT print ( x , " , " , y , " \n " ) NEW_LINE DEDENT DEDENT
FIN@@ DING_@@ VERTEX_@@ FOCUS_@@ DIREC@@ TRI@@ X_@@ PAR@@ ABO@@ LA | def par@@ ab@@ ola ( a , b , c ) : NEW_LINE INDENT print ( " Vertex : ▁ ( " , ( - b / ( 2 * a ) ) , " , ▁ " , ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) , " ) " , sep = " " ) NEW_LINE print ( " Focus : ▁ ( " , ( - b / ( 2 * a ) ) , " , ▁ " , ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) , " ) " , sep = " " ) NEW_LINE print ( " Direc@@ tri@@ x : ▁ y = " , c - ( ( b * b ) + 1 ) * 4 * a , sep = " " ) NEW_LINE DEDENT
TRIANG@@ ULAR_@@ NUMB@@ ERS | def is@@ Tri@@ angular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum , n = 0 , 1 NEW_LINE while ( sum <= num ) : NEW_LINE INDENT sum = sum + n NEW_LINE if ( sum == num ) : NEW_LINE INDENT return True NEW_LINE DEDENT n += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
PI@@ ZZ@@ A_@@ CU@@ T_@@ PRO@@ BLE@@ M_@@ CI@@ R@@ CLE_@@ DI@@ VISI@@ ON_@@ LINES | def find@@ Maximum@@ Pieces ( n ) : NEW_LINE INDENT return int ( 1 + n * ( n + 1 ) / 2 ) NEW_LINE DEDENT
MINIMUM_@@ TIME_@@ WRITE_@@ CHARAC@@ TER@@ S_@@ USING_@@ INSERT_@@ DELETE_@@ COPY_@@ OPERATION | def min@@ Time@@ For@@ Writing@@ Chars ( N , in@@ srt , remo@@ v , cpy ) : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if N == 1 : NEW_LINE INDENT return in@@ srt NEW_LINE DEDENT dp = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + in@@ srt , dp [ i // 2 ] + cpy ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + in@@ srt , dp [ ( i + 1 ) // 2 ] + cpy + remo@@ v ) NEW_LINE DEDENT DEDENT return dp [ N ] NEW_LINE DEDENT
SE@@ ARCH@@ ING_@@ ARRAY_@@ AD@@ J@@ AC@@ ENT_@@ DIFF@@ ER_@@ K | def search ( arr , n , x , k ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + max ( 1 , int ( abs ( arr [ i ] - x ) / k ) ) NEW_LINE DEDENT print ( " number ▁ is ▁ not ▁ present ! " ) NEW_LINE return - 1 NEW_LINE DEDENT
FIND_@@ MAXIMUM_@@ PRODUCT_@@ OF_@@ A_@@ TR@@ IP@@ LET_@@ IN_@@ ARRAY | def max@@ Product ( arr , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_@@ product = - ( sys . maxsize - 1 ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT max_@@ product = max ( max_@@ product , arr [ i ] * arr [ j ] * arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return max_@@ product NEW_LINE DEDENT
LON@@ GE@@ ST_@@ PA@@ LIN@@ DRO@@ ME_@@ SUB@@ SEQU@@ ENCE_@@ SPACE | def l@@ ps ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE a = [ 0 ] * n NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT back_@@ up = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if j == i : NEW_LINE INDENT a [ j ] = 1 NEW_LINE DEDENT elif s [ i ] == s [ j ] : NEW_LINE INDENT temp = a [ j ] NEW_LINE a [ j ] = back_@@ up + 2 NEW_LINE back_@@ up = temp NEW_LINE DEDENT else : NEW_LINE INDENT back_@@ up = a [ j ] NEW_LINE a [ j ] = max ( a [ j - 1 ] , a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return a [ n - 1 ] NEW_LINE DEDENT
CHECK_@@ HALF_@@ STRING_@@ CHARACTER_@@ FREQU@@ ENCY_@@ CHARACTER_@@ 1 | def check@@ Correct@@ Or@@ Not ( s ) : NEW_LINE INDENT global MAX_@@ CHAR NEW_LINE count = [ 0 ] * MAX_@@ CHAR NEW_LINE n = len ( s ) NEW_LINE if n == 1 : NEW_LINE INDENT return true NEW_LINE DEDENT i = 0 ; j = n - 1 NEW_LINE while i < j : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE count [ ord ( s [ j ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE i += 1 ; j -= 1 NEW_LINE DEDENT for i in range ( MAX_@@ CHAR ) : NEW_LINE INDENT if count [ i ] != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
EXPO@@ NE@@ N@@ TI@@ AL_S@@ QUAR@@ ING_@@ FAST_@@ MODUL@@ O_@@ MULTIP@@ LIC@@ ATION | def expon@@ enti@@ ation ( b@@ as , exp ) : NEW_LINE INDENT if ( exp == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( exp == 1 ) : NEW_LINE INDENT return b@@ as % N ; NEW_LINE DEDENT t = expon@@ enti@@ ation ( b@@ as , int ( exp / 2 ) ) ; NEW_LINE t = ( t * t ) % N ; NEW_LINE if ( exp % 2 == 0 ) : NEW_LINE INDENT return t ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( b@@ as % N ) * t ) % N ; NEW_LINE DEDENT DEDENT
REMOVE_@@ MINIMUM_@@ NUMBER_@@ ELEMEN@@ TS_@@ NO_@@ COMMON_@@ ELEMENT_@@ EXI@@ ST_@@ ARRAY | def min@@ Remove ( a , b , n , m ) : NEW_LINE INDENT count@@ A = dict ( ) NEW_LINE count@@ B = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count@@ A [ a [ i ] ] = count@@ A . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT count@@ B [ b [ i ] ] = count@@ B . get ( b [ i ] , 0 ) + 1 NEW_LINE DEDENT res = 0 NEW_LINE for x in count@@ A : NEW_LINE INDENT if x in count@@ B . keys ( ) : NEW_LINE INDENT res += min ( count@@ A [ x ] , count@@ B [ x ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
FIND_@@ A_@@ FIXED_@@ POINT_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY | def linear@@ Search ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] is i : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
ADD_@@ 1_@@ TO_@@ A_@@ GI@@ V@@ EN_@@ NUMBER | def add@@ One ( x ) : NEW_LINE INDENT m = 1 ; NEW_LINE while ( x & m ) : NEW_LINE INDENT x = x ^ m NEW_LINE m <<= 1 NEW_LINE DEDENT x = x ^ m NEW_LINE return x NEW_LINE DEDENT
HEIGHT_@@ COMPLETE_@@ BINARY_@@ TREE_@@ HEAP_@@ N_@@ NODES | def height ( N ) : NEW_LINE INDENT return math . ceil ( math . log2 ( N + 1 ) ) - 1 NEW_LINE DEDENT
MINIMUM_@@ NUMBER_OF_@@ JUM@@ PS_@@ TO_@@ REACH_@@ END_OF_@@ A_@@ GI@@ V@@ EN_@@ ARRAY | def min@@ Jump@@ s ( arr , l , h ) : NEW_LINE INDENT if ( h == l ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ l ] == 0 ) : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT min = float ( ' inf ' ) NEW_LINE for i in range ( l + 1 , h + 1 ) : NEW_LINE INDENT if ( i < l + arr [ l ] + 1 ) : NEW_LINE INDENT jumps = min@@ Jump@@ s ( arr , i , h ) NEW_LINE if ( jumps != float ( ' inf ' ) and jumps + 1 < min ) : NEW_LINE INDENT min = jumps + 1 NEW_LINE DEDENT DEDENT DEDENT return min NEW_LINE DEDENT
PROGRAM_@@ FOR_@@ N@@ TH_@@ FI@@ BON@@ ACC@@ I_@@ NUMBER_@@ 2 | def fi@@ b ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 NEW_LINE return ( f [ n ] ) NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT if ( n & 1 ) : NEW_LINE INDENT k = ( n + 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT k = n // 2 NEW_LINE DEDENT if ( ( n & 1 ) ) : NEW_LINE INDENT f [ n ] = ( fi@@ b ( k ) * fi@@ b ( k ) + fi@@ b ( k - 1 ) * fi@@ b ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fi@@ b ( k - 1 ) + fi@@ b ( k ) ) * fi@@ b ( k ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT
DECODE_@@ STRING_@@ RECUR@@ SI@@ VEL@@ Y_@@ EN@@ CODE@@ D_@@ COUNT_@@ FOL@@ LO@@ WE@@ D@@ _SUB@@ STRING | def decode ( Str ) : NEW_LINE INDENT integer@@ stack = [ ] NEW_LINE string@@ stack = [ ] NEW_LINE temp = " " NEW_LINE result = " " NEW_LINE for i in range ( len ( Str ) ) : NEW_LINE INDENT count = 0 NEW_LINE if ( Str [ i ] >= '0' and Str [ i ] <= '9' ) : NEW_LINE INDENT while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) : NEW_LINE INDENT count = count * 10 + ord ( Str [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE integer@@ stack . append ( count ) NEW_LINE DEDENT elif ( Str [ i ] == ' ] ' ) : NEW_LINE INDENT temp = " " NEW_LINE count = 0 NEW_LINE if ( len ( integer@@ stack ) != 0 ) : NEW_LINE INDENT count = integer@@ stack [ - 1 ] NEW_LINE integer@@ stack . pop ( ) NEW_LINE DEDENT while ( len ( string@@ stack ) != 0 and string@@ stack [ - 1 ] != ' [ ' ) : NEW_LINE INDENT temp = string@@ stack [ - 1 ] + temp NEW_LINE string@@ stack . pop ( ) NEW_LINE DEDENT if ( len ( string@@ stack ) != 0 and string@@ stack [ - 1 ] == ' [ ' ) : NEW_LINE INDENT string@@ stack . pop ( ) NEW_LINE DEDENT for j in range ( count ) : NEW_LINE INDENT result = result + temp NEW_LINE DEDENT for j in range ( len ( result ) ) : NEW_LINE INDENT string@@ stack . append ( result [ j ] ) NEW_LINE DEDENT result = " " NEW_LINE DEDENT elif ( Str [ i ] == ' [ ' ) : NEW_LINE INDENT if ( Str [ i - 1 ] >= '0' and Str [ i - 1 ] <= '9' ) : NEW_LINE INDENT string@@ stack . append ( Str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT string@@ stack . append ( Str [ i ] ) NEW_LINE integer@@ stack . append ( 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT string@@ stack . append ( Str [ i ] ) NEW_LINE DEDENT DEDENT while len ( string@@ stack ) != 0 : NEW_LINE INDENT result = string@@ stack [ - 1 ] + result NEW_LINE string@@ stack . pop ( ) NEW_LINE DEDENT return result NEW_LINE DEDENT
HO@@ W_@@ TO_@@ CHECK_@@ IF_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ RE@@ PRESEN@@ TS_@@ A_@@ BINARY_@@ HEA@@ P | def is@@ Heap ( arr , i , n ) : NEW_LINE INDENT if i > int ( ( n - 2 ) / 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and is@@ Heap ( arr , 2 * i + 1 , n ) and is@@ Heap ( arr , 2 * i + 2 , n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
HO@@ W_@@ TO_@@ CHECK_@@ IF_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ RE@@ PRESEN@@ TS_@@ A_@@ BINARY_@@ HEAP_@@ 1 | def is@@ Heap ( arr , n ) : NEW_LINE INDENT for i in range ( int ( ( n - 2 ) / 2 ) + 1 ) : NEW_LINE INDENT if arr [ 2 * i + 1 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
CAL@@ CUL@@ ATE_@@ ANGLE_@@ HOUR_@@ H@@ AND_@@ MIN@@ UTE_@@ HAND | def calc@@ Angle ( h , m ) : NEW_LINE INDENT if ( h < 0 or m < 0 or h > 12 or m > 60 ) : NEW_LINE INDENT print ( ' Wrong ▁ input ' ) NEW_LINE DEDENT if ( h == 12 ) : NEW_LINE INDENT h = 0 NEW_LINE DEDENT if ( m == 60 ) : NEW_LINE INDENT m = 0 NEW_LINE DEDENT hour@@ _@@ angle = 0.5 * ( h * 60 + m ) NEW_LINE minu@@ te_@@ angle = 6 * m NEW_LINE angle = abs ( hour@@ _@@ angle - minu@@ te_@@ angle ) NEW_LINE angle = min ( 360 - angle , angle ) NEW_LINE return angle NEW_LINE DEDENT
CONVER@@ TING_@@ DECIMAL_@@ NUMBER_@@ LY@@ ING_@@ BETWE@@ EN_@@ 1_@@ TO_@@ 399@@ 9_@@ TO_@@ RO@@ MAN_@@ NUMER@@ ALS | def print@@ Roman ( number ) : NEW_LINE INDENT num = [ 1 , 4 , 5 , 9 , 10 , 40 , 50 , 90 , 100 , 400 , 500 , 900 , 1000 ] NEW_LINE sym = [ " I " , " IV " , " V " , " IX " , " X " , " X@@ L " , " L " , " X@@ C " , " C " , " CD " , " D " , " CM " , " M " ] NEW_LINE i = 12 NEW_LINE while number : NEW_LINE INDENT div = number // num [ i ] NEW_LINE number %= num [ i ] NEW_LINE while div : NEW_LINE INDENT print ( sym [ i ] , end = " " ) NEW_LINE div -= 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT
SOR@@ TING_@@ USING_@@ TRI@@ VI@@ AL_@@ HASH_@@ FUNCTION | def sort@@ Using@@ Hash ( a , n ) : NEW_LINE INDENT Max = max ( a ) NEW_LINE Hash = [ 0 ] * ( Max + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Hash [ a [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 0 , Max + 1 ) : NEW_LINE INDENT if Hash [ i ] != 0 : NEW_LINE INDENT for j in range ( 0 , Hash [ i ] ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
S@@ UM_@@ PAIR@@ WI@@ SE_@@ PRODUC@@ TS_@@ 2 | def find@@ Sum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 NEW_LINE DEDENT
ENTR@@ ING@@ ER_@@ NUMBER | def zig@@ z@@ ag ( n , k ) : NEW_LINE INDENT if ( n == 0 and k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return zig@@ z@@ ag ( n , k - 1 ) + zig@@ z@@ ag ( n - 1 , n - k ) ; NEW_LINE DEDENT
MIN@@ IM@@ UM@@ _S@@ UM_@@ TWO_@@ NUMB@@ ERS_@@ FOR@@ MED_@@ DIG@@ IT@@ S_@@ ARRAY_@@ 2 | def min@@ Sum ( a , n ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE num1 , num2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT num1 = num1 * 10 + a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT num2 = num2 * 10 + a [ i ] NEW_LINE DEDENT DEDENT return num2 + num1 NEW_LINE DEDENT
SUB@@ ARRAY_@@ NO_@@ PAIR@@ _S@@ UM_@@ DI@@ VISI@@ BLE_@@ K | def sub@@ array@@ Di@@ visible@@ By@@ K ( arr , n , k ) : NEW_LINE INDENT mp = [ 0 ] * 1000 NEW_LINE s = 0 ; e = 0 ; maxs = 0 ; max@@ e = 0 ; NEW_LINE mp [ arr [ 0 ] % k ] = mp [ arr [ 0 ] % k ] + 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT mod = arr [ i ] % k NEW_LINE while ( mp [ k - mod ] != 0 or ( mod == 0 and mp [ mod ] != 0 ) ) : NEW_LINE INDENT mp [ arr [ s ] % k ] = mp [ arr [ s ] % k ] - 1 NEW_LINE s = s + 1 NEW_LINE DEDENT mp [ mod ] = mp [ mod ] + 1 NEW_LINE e = e + 1 NEW_LINE if ( ( e - s ) > ( max@@ e - maxs ) ) : NEW_LINE INDENT max@@ e = e NEW_LINE maxs = s NEW_LINE DEDENT DEDENT print ( " The ▁ maximum ▁ size ▁ is ▁ { } ▁ and ▁ the ▁ " . format ( ( max@@ e - maxs + 1 ) ) ) for i in range ( maxs , max@@ e + 1 ) : NEW_LINE INDENT print ( " { } ▁ " . format ( arr [ i ] ) , end = " " ) NEW_LINE DEDENT DEDENT
MAXIMUM_@@ PROFI@@ T_@@ BY_@@ BU@@ Y@@ ING_@@ AND@@ _S@@ EL@@ LING_@@ A@@ _SH@@ ARE_@@ AT_@@ MO@@ ST_@@ K_@@ TIMES | def max@@ Pro@@ fit ( prices , n , k ) : NEW_LINE INDENT pro@@ fit = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT max_@@ so@@ _f@@ ar = 0 NEW_LINE for l in range ( i ) : NEW_LINE INDENT max_@@ so@@ _f@@ ar = max ( max_@@ so@@ _f@@ ar , prices [ i ] - prices [ l ] + pro@@ fit [ l ] [ j - 1 ] ) NEW_LINE DEDENT pro@@ fit [ i ] [ j ] = max ( pro@@ fit [ i - 1 ] [ j ] , max_@@ so@@ _f@@ ar ) NEW_LINE DEDENT DEDENT return pro@@ fit [ n - 1 ] [ k ] NEW_LINE DEDENT
MINI@@ MI@@ ZE_@@ S@@ UM_@@ PRODUCT_@@ TWO_@@ ARRAY@@ S_PER@@ MU@@ TA@@ TIONS_@@ ALLOWED | def minValue ( A , B , n ) : NEW_LINE INDENT sorted ( A ) NEW_LINE sorted ( B ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += ( A [ i ] * B [ n - i - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
FIND_@@ MAXIMUM_@@ ELEMENT_@@ ROW_@@ MATRIX | def max@@ element ( arr ) : NEW_LINE INDENT no_@@ of_@@ rows = len ( arr ) NEW_LINE no_@@ of_@@ column = len ( arr [ 0 ] ) NEW_LINE for i in range ( no_@@ of_@@ rows ) : NEW_LINE INDENT max@@ 1 = 0 NEW_LINE for j in range ( no_@@ of_@@ column ) : NEW_LINE INDENT if arr [ i ] [ j ] > max@@ 1 : NEW_LINE INDENT max@@ 1 = arr [ i ] [ j ] NEW_LINE DEDENT DEDENT print ( max@@ 1 ) NEW_LINE DEDENT DEDENT
ROUND_@@ OFF_@@ NUMBER_@@ GI@@ V@@ EN_@@ NUMBER@@ _SIGN@@ I@@ FI@@ CANT_@@ DIGITS | def Ro@@ und_@@ off ( N , n ) : NEW_LINE INDENT b = N NEW_LINE c = floor ( N ) NEW_LINE i = 0 ; NEW_LINE while ( b >= 1 ) : NEW_LINE INDENT b = b / 10 NEW_LINE i = i + 1 NEW_LINE DEDENT d = n - i NEW_LINE b = N NEW_LINE b = b * pow ( 10 , d ) NEW_LINE e = b + 0.5 NEW_LINE if ( float ( e ) == float ( ceil ( b ) ) ) : NEW_LINE INDENT f = ( ceil ( b ) ) NEW_LINE h = f - 2 NEW_LINE if ( h % 2 != 0 ) : NEW_LINE INDENT e = e - 1 NEW_LINE DEDENT DEDENT j = floor ( e ) NEW_LINE m = pow ( 10 , d ) NEW_LINE j = j / m NEW_LINE print ( " The ▁ number ▁ after ▁ rounding - off ▁ is " , j ) NEW_LINE DEDENT
CHECK_@@ WHE@@ THER_@@ POINT_@@ EXI@@ ST@@ S_@@ CI@@ R@@ CLE_@@ SEC@@ TOR_@@ NOT | def check@@ Point ( radius , x , y , percent , start@@ Angle ) : NEW_LINE INDENT end@@ Angle = 360 / percent + start@@ Angle NEW_LINE polar@@ radius = math . sqrt ( x * x + y * y ) NEW_LINE Angle = math . atan ( y / x ) NEW_LINE if ( Angle >= start@@ Angle and Angle <= end@@ Angle and polar@@ radius < radius ) : NEW_LINE INDENT print ( " Point ▁ ( " , x , " , " , y , " ) ▁ " " exist ▁ in ▁ the ▁ circle ▁ sector " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Point ▁ ( " , x , " , " , y , " ) ▁ " " does ▁ not ▁ exist ▁ in ▁ the ▁ circle ▁ sector " ) NEW_LINE DEDENT DEDENT
NUMBER_@@ IS_@@ DI@@ VISI@@ BLE_@@ BY_@@ 29@@ _@@ OR_@@ NOT | def is@@ Di@@ visible ( n ) : NEW_LINE INDENT while ( int ( n / 100 ) ) : NEW_LINE INDENT last_@@ digit = int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE n += last_@@ digit * 3 NEW_LINE DEDENT return ( n % 29 == 0 ) NEW_LINE DEDENT
PRINT_@@ ALL_@@ DISTIN@@ CT_@@ CHARAC@@ TER@@ S_@@ OF_@@ A_@@ STRING_@@ IN_@@ ORDER_@@ 3_@@ METHODS | def print@@ Distin@@ ct ( str ) : NEW_LINE INDENT count = [ 0 ] * NO_@@ OF_@@ CHARS NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] != ' ▁ ' ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT n = i NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( count [ ord ( str [ i ] ) ] == 1 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
PROGRAM_@@ REVERSE_@@ STRING_@@ ITER@@ ATI@@ VE_@@ RECUR@@ SIVE | def recursive@@ Reverse ( str ) : NEW_LINE INDENT stack = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT stack . append ( str [ i ] ) NEW_LINE DEDENT for i in range ( len ( str ) ) : NEW_LINE INDENT str [ i ] = stack . pop ( ) NEW_LINE DEDENT DEDENT
PA@@ INT@@ ING_@@ F@@ ENCE_@@ ALGORITH@@ M | def count@@ W@@ ays ( n , k ) : NEW_LINE INDENT total = k NEW_LINE mod = 100000000@@ 7 NEW_LINE same , diff = 0 , k NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT same = diff NEW_LINE diff = total * ( k - 1 ) NEW_LINE diff = diff % mod NEW_LINE total = ( same + diff ) % mod NEW_LINE DEDENT return total NEW_LINE DEDENT
COUNT_@@ OF@@ _SUB_@@ STRING@@ S_@@ TH@@ AT_@@ DO_@@ NOT_@@ CONTA@@ IN_@@ ALL_@@ THE_@@ CHARAC@@ TER@@ S_@@ FROM_@@ THE_@@ SET_@@ A_@@ B_@@ C_@@ AT_@@ THE_@@ S@@ AME_@@ TIME | def Count@@ Sub@@ String ( Str , n ) : NEW_LINE INDENT ans = ( n * ( n + 1 ) ) // 2 NEW_LINE a_@@ index = 0 NEW_LINE b_@@ index = 0 NEW_LINE c_@@ index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Str [ i ] == ' a ' ) : NEW_LINE INDENT a_@@ index = i + 1 NEW_LINE ans -= min ( b_@@ index , c_@@ index ) NEW_LINE DEDENT elif ( Str [ i ] == ' b ' ) : NEW_LINE INDENT b_@@ index = i + 1 NEW_LINE ans -= min ( a_@@ index , c_@@ index ) NEW_LINE DEDENT else : NEW_LINE INDENT c_@@ index = i + 1 NEW_LINE ans -= min ( a_@@ index , b_@@ index ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
CAL@@ CUL@@ ATING_@@ FAC@@ TOR@@ I@@ AL@@ S_@@ USING_@@ ST@@ IR@@ LING_@@ APPRO@@ XI@@ MATION | def st@@ ir@@ ling@@ Fac@@ tori@@ al ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT e = 2.@@ 71 ; NEW_LINE z = ( math . sqrt ( 2 * 3.14 * n ) * math . pow ( ( n / e ) , n ) ) ; NEW_LINE return math . floor ( z ) ; NEW_LINE DEDENT
LE@@ XI@@ CO@@ GRAPHIC@@ AL@@ LY@@ _S@@ MAL@@ LE@@ ST_@@ STRING_@@ OB@@ TA@@ IN@@ ED_@@ CON@@ CAT@@ EN@@ ATING_@@ ARRAY | def lex@@ S@@ malle@@ st ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE answer = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer += a [ i ] NEW_LINE DEDENT return answer NEW_LINE DEDENT
PRODUCT_@@ MAXIMUM_@@ FIRST_@@ ARRAY_@@ MIN@@ IM@@ UM@@ _SECOND | def min@@ max@@ Product ( ar@@ r1 , ar@@ r2 , n1 , n2 ) : NEW_LINE INDENT ar@@ r1 . sort ( ) NEW_LINE ar@@ r2 . sort ( ) NEW_LINE return ar@@ r1 [ n1 - 1 ] * ar@@ r2 [ 0 ] NEW_LINE DEDENT
FIND_@@ IF_@@ THER@@ E_@@ IS_@@ A@@ _SUB@@ ARRAY_@@ WITH_@@ 0@@ _S@@ UM | def sub@@ Array@@ Exists ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if sum == 0 or sum in s : NEW_LINE INDENT return True NEW_LINE DEDENT s . add ( sum ) NEW_LINE DEDENT return False NEW_LINE DEDENT
MINIMUM_@@ PRODUCT_@@ SUB@@ SET_@@ ARRAY | def min@@ Product@@ Subset ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT max_@@ neg = float ( ' - inf ' ) NEW_LINE min_@@ pos = float ( ' inf ' ) NEW_LINE count_@@ neg = 0 NEW_LINE count_@@ zero = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count_@@ zero = count_@@ zero + 1 NEW_LINE continue NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT count_@@ neg = count_@@ neg + 1 NEW_LINE max_@@ neg = max ( max_@@ neg , a [ i ] ) NEW_LINE DEDENT if ( a [ i ] > 0 ) : NEW_LINE INDENT min_@@ pos = min ( min_@@ pos , a [ i ] ) NEW_LINE DEDENT prod = prod * a [ i ] NEW_LINE DEDENT if ( count_@@ zero == n or ( count_@@ neg == 0 and count_@@ zero > 0 ) ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( count_@@ neg == 0 ) : NEW_LINE INDENT return min_@@ pos NEW_LINE DEDENT if ( ( count_@@ neg & 1 ) == 0 and count_@@ neg != 0 ) : NEW_LINE INDENT prod = int ( prod / max_@@ neg ) NEW_LINE DEDENT return prod ; NEW_LINE DEDENT
NUMBER_@@ NODE@@ S_@@ TWO_@@ VER@@ TIC@@ ES_@@ AC@@ Y@@ CLI@@ C_@@ GRAPH_@@ DIS@@ JO@@ INT_@@ UNI@@ ON_@@ METHOD | def total@@ Nodes ( ad@@ jac , n , x , y ) : NEW_LINE INDENT visited = [ 0 ] * ( n + 1 ) NEW_LINE p = [ None ] * n NEW_LINE q = queue . Queue ( ) NEW_LINE q . put ( x ) NEW_LINE visited [ x ] = True NEW_LINE m = None NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT m = q . get ( ) NEW_LINE for i in range ( len ( ad@@ jac [ m ] ) ) : NEW_LINE INDENT h = ad@@ jac [ m ] [ i ] NEW_LINE if ( not visited [ h ] ) : NEW_LINE INDENT visited [ h ] = True NEW_LINE p [ h ] = m NEW_LINE q . put ( h ) NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE i = p [ y ] NEW_LINE while ( i != x ) : NEW_LINE INDENT count += 1 NEW_LINE i = p [ i ] NEW_LINE DEDENT return count NEW_LINE DEDENT
PRINT@@ ING_@@ STRING_@@ PL@@ US_@@ PATTERN_@@ MATRIX | def car@@ ve@@ Cross ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Not ▁ possible . ▁ Please ▁ enter ▁ " , " odd ▁ length ▁ string . \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT arr = [ [ False for x in range ( max ) ] for y in range ( max ) ] NEW_LINE m = n // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = ' X ' NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] [ m ] = str [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ m ] [ i ] = str [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT
NEXT_@@ GREATER_@@ FREQU@@ ENCY_@@ ELEMENT | def NF@@ G ( a , n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT print ( " List ▁ empty " ) NEW_LINE return [ ] NEW_LINE DEDENT stack = [ 0 ] * n NEW_LINE freq = { } NEW_LINE for i in a : NEW_LINE INDENT freq [ a [ i ] ] = 0 NEW_LINE DEDENT for i in a : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT res = [ 0 ] * n NEW_LINE top = - 1 NEW_LINE top += 1 NEW_LINE stack [ top ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( freq [ a [ stack [ top ] ] ] > freq [ a [ i ] ] ) : NEW_LINE INDENT top += 1 NEW_LINE stack [ top ] = i NEW_LINE DEDENT else : NEW_LINE INDENT while ( top > - 1 and freq [ a [ stack [ top ] ] ] < freq [ a [ i ] ] ) : NEW_LINE INDENT res [ stack [ top ] ] = a [ i ] NEW_LINE top -= 1 NEW_LINE DEDENT top += 1 NEW_LINE stack [ top ] = i NEW_LINE DEDENT DEDENT while ( top > - 1 ) : NEW_LINE INDENT res [ stack [ top ] ] = - 1 NEW_LINE top -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
CHECK_@@ REVER@@ SING@@ _SUB_@@ ARRAY_@@ MAKE_@@ ARRA@@ Y_S@@ OR@@ TED_@@ 1 | def check@@ Reverse ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i - 1 ] < arr [ i ] : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT j = i NEW_LINE while ( arr [ j ] < arr [ j - 1 ] ) : NEW_LINE INDENT if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT k = j NEW_LINE if ( arr [ k ] < arr [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( k > 1 and k < n ) : NEW_LINE INDENT if ( arr [ k ] < arr [ k - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT k += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
FIND_@@ TR@@ IP@@ LET@@ S_@@ ARRAY_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL_@@ ZERO_@@ 2 | def find@@ Trip@@ lets ( arr , n ) : NEW_LINE INDENT found = False NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT l = i + 1 NEW_LINE r = n - 1 NEW_LINE x = arr [ i ] NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( x + arr [ l ] + arr [ r ] == 0 ) : NEW_LINE INDENT print ( x , arr [ l ] , arr [ r ] ) NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE found = True NEW_LINE DEDENT elif ( x + arr [ l ] + arr [ r ] < 0 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " ▁ No ▁ Trip@@ let ▁ Found " ) NEW_LINE DEDENT DEDENT
FIND_@@ ELEMEN@@ TS_@@ ARRAY_@@ LEA@@ ST_@@ TWO_@@ GREATER_@@ ELEMENTS | def find@@ Elements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
POSITIVE_@@ ELEMEN@@ TS_@@ EV@@ EN_@@ NEGATIVE_@@ OD@@ D_@@ POSI@@ TIONS_@@ 1 | def print@@ Array ( a , n ) : NEW_LINE INDENT for i in a : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
FIND_@@ MINIMUM_@@ RADI@@ US_@@ AT@@ LEA@@ ST_@@ K_@@ POINT_@@ LI@@ E_@@ IN@@ SIDE_@@ CIRC@@ LE | def min@@ Radius ( k , x , y , n ) : NEW_LINE INDENT dis = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] NEW_LINE DEDENT dis . sort ( ) NEW_LINE return dis [ k - 1 ] NEW_LINE DEDENT
COUNT_@@ SUB@@ ARRAY@@ S_@@ EQUAL_@@ NUMBER_@@ 1@@ S_@@ 0@@ S | def count@@ Sub@@ arr@@ With@@ Equal@@ Zero@@ And@@ One ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE curr_@@ sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_@@ sum += ( - 1 if ( arr [ i ] == 0 ) else arr [ i ] ) NEW_LINE if um . get ( curr_@@ sum ) : NEW_LINE INDENT um [ curr_@@ sum ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT um [ curr_@@ sum ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for itr in um : NEW_LINE INDENT if um [ itr ] > 1 : NEW_LINE INDENT count += ( ( um [ itr ] * int ( um [ itr ] - 1 ) ) / 2 ) NEW_LINE DEDENT DEDENT if um . get ( 0 ) : NEW_LINE INDENT count += um [ 0 ] NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT
MINIMUM_@@ INDEX@@ _S@@ UM_@@ COMMON_@@ ELEMEN@@ TS_@@ TWO_@@ LI@@ STS | def find ( list1 , list2 ) : NEW_LINE INDENT res = [ ] NEW_LINE max_@@ possible_@@ sum = len ( list1 ) + len ( list2 ) - 2 NEW_LINE for sum in range ( max_@@ possible_@@ sum + 1 ) : NEW_LINE INDENT for i in range ( sum + 1 ) : NEW_LINE INDENT if ( i < len ( list1 ) and ( sum - i ) < len ( list2 ) and list1 [ i ] == list2 [ sum - i ] ) : NEW_LINE INDENT res . append ( list1 [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( res ) > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
CHECK_@@ IF_@@ A_@@ NUMBER_@@ IS_@@ JUM@@ B@@ LED_@@ OR_@@ NOT | def check@@ J@@ umb@@ led ( num ) : NEW_LINE INDENT if ( num / 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT while ( num != 0 ) : NEW_LINE INDENT if ( num / 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT digit@@ 1 = num % 10 NEW_LINE digit@@ 2 = ( num / 10 ) % 10 NEW_LINE if ( abs ( digit@@ 2 - digit@@ 1 ) > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT num = num / 10 NEW_LINE DEDENT return True NEW_LINE DEDENT
CEI@@ LING_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY_@@ 1 | def ceil@@ Search ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT if x > arr [ high ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 ; NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < x : NEW_LINE INDENT if mid + 1 <= high and x <= arr [ mid + 1 ] : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ceil@@ Search ( arr , mid + 1 , high , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if mid - 1 >= low and x > arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT return ceil@@ Search ( arr , low , mid - 1 , x ) NEW_LINE DEDENT DEDENT DEDENT
GI@@ V@@ EN_@@ P_@@ AND_@@ N_@@ FIND_@@ THE_@@ LAR@@ GE@@ ST_@@ X@@ _SU@@ CH_@@ TH@@ AT_@@ P@@ X_@@ DI@@ VIDE@@ S_@@ N_@@ 2 | def lar@@ gest@@ Power ( n , p ) : NEW_LINE INDENT x = 0 NEW_LINE while n : NEW_LINE INDENT n /= p NEW_LINE x += n NEW_LINE DEDENT return x NEW_LINE DEDENT
MAX@@ IM@@ UM@@ _S@@ UM_@@ I@@ AR@@ RI@@ _@@ AM@@ ONG_@@ ROTA@@ TIONS_@@ GI@@ V@@ EN_@@ ARRAY | def max@@ Sum ( arr , n ) : NEW_LINE INDENT res = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_@@ sum = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT index = int ( ( i + j ) % n ) NEW_LINE curr_@@ sum += j * arr [ index ] NEW_LINE DEDENT res = max ( res , curr_@@ sum ) NEW_LINE DEDENT return res NEW_LINE DEDENT
MINIMUM_@@ LENGTH@@ _SUB@@ ARRA@@ Y_S@@ UM_@@ GREATER_@@ GI@@ V@@ EN_@@ VALUE_@@ 1 | def smalle@@ st@@ Sub@@ With@@ Sum ( arr , n , x ) : NEW_LINE INDENT curr_@@ sum = 0 ; NEW_LINE min_@@ len = n + 1 ; NEW_LINE start = 0 ; NEW_LINE end = 0 ; NEW_LINE while ( end < n ) : NEW_LINE INDENT while ( curr_@@ sum <= x and end < n ) : NEW_LINE INDENT if ( curr_@@ sum <= 0 and x > 0 ) : NEW_LINE INDENT start = end ; NEW_LINE curr_@@ sum = 0 ; NEW_LINE DEDENT curr_@@ sum += arr [ end ] ; NEW_LINE end += 1 ; NEW_LINE DEDENT while ( curr_@@ sum > x and start < n ) : NEW_LINE INDENT if ( end - start < min_@@ len ) : NEW_LINE INDENT min_@@ len = end - start ; NEW_LINE DEDENT curr_@@ sum -= arr [ start ] ; NEW_LINE start += 1 ; NEW_LINE DEDENT DEDENT return min_@@ len ; NEW_LINE DEDENT
LE@@ XI@@ CO@@ GRAPHIC@@ AL@@ LY@@ _S@@ MAL@@ LE@@ ST_@@ STRING_@@ WHO@@ SE_@@ HAM@@ M@@ ING_@@ DISTAN@@ CE_@@ GI@@ V@@ EN_@@ STRING_@@ EXAC@@ TL@@ Y_@@ K | def find@@ String ( str , n , k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT print ( str ) NEW_LINE return NEW_LINE DEDENT str2 = str NEW_LINE p = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( str2 [ i ] != ' a ' ) : NEW_LINE INDENT str2 = str2 . replace ( str2 [ i ] , ' a ' ) NEW_LINE p += 1 NEW_LINE if ( p == k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if ( p < k ) : NEW_LINE INDENT i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( str [ i ] == ' a ' ) : NEW_LINE INDENT str2 = str2 . replace ( str2 [ i ] , ' b ' ) NEW_LINE p += 1 NEW_LINE DEDENT if ( p == k ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT print ( str2 ) NEW_LINE DEDENT
SUB@@ SET_@@ S@@ UM_@@ DI@@ VISI@@ BLE_@@ M | def mod@@ ular@@ Sum ( arr , n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return True NEW_LINE DEDENT DP = [ False for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( DP [ 0 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT temp = [ False for i in range ( m ) ] NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( DP [ j ] == True ) : NEW_LINE INDENT if ( DP [ ( j + arr [ i ] ) % m ] == False ) : NEW_LINE INDENT temp [ ( j + arr [ i ] ) % m ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( m ) : NEW_LINE INDENT if ( temp [ j ] ) : NEW_LINE INDENT DP [ j ] = True NEW_LINE DEDENT DEDENT DP [ arr [ i ] % m ] = True NEW_LINE DEDENT return DP [ 0 ] NEW_LINE DEDENT
FIN@@ D_S@@ UM_@@ EV@@ EN_@@ INDEX_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENTS_@@ 1 | def even@@ bin@@ omi@@ al@@ Coeff@@ Sum ( n ) : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) NEW_LINE DEDENT
EV@@ EN_@@ FI@@ BON@@ ACC@@ I_@@ NUMBER@@ S_S@@ UM | def even@@ Fi@@ b@@ Sum ( limit ) : NEW_LINE INDENT if ( limit < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ef@@ 1 = 0 NEW_LINE ef@@ 2 = 2 NEW_LINE sm = ef@@ 1 + ef@@ 2 NEW_LINE while ( ef@@ 2 <= limit ) : NEW_LINE INDENT ef@@ 3 = 4 * ef@@ 2 + ef@@ 1 NEW_LINE if ( ef@@ 3 > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT ef@@ 1 = ef@@ 2 NEW_LINE ef@@ 2 = ef@@ 3 NEW_LINE sm = sm + ef@@ 2 NEW_LINE DEDENT return sm NEW_LINE DEDENT
MA@@ KING_@@ ELEMEN@@ TS_@@ OF_@@ TWO_@@ ARRAY@@ S_S@@ AME_@@ WITH_@@ MINIMUM_@@ INCRE@@ MENT@@ DECRE@@ MENT | def Min@@ Operation ( a , b , n ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE b . sort ( reverse = False ) NEW_LINE result = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( a [ i ] > b [ i ] ) : NEW_LINE INDENT result = result + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT elif ( a [ i ] < b [ i ] ) : NEW_LINE INDENT result = result + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
REQUIRED_@@ MINIMUM_@@ DIG@@ IT@@ S_@@ REMOVE_@@ NUMBER_@@ MAKE_@@ PER@@ F@@ ECT_@@ SQUARE | def perfec@@ t@@ Square ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = - 1 NEW_LINE num = " " NEW_LINE for i in range ( 1 , ( 1 << n ) ) : NEW_LINE INDENT str = " " NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( i >> j ) & 1 ) : NEW_LINE INDENT str = str + s [ j ] NEW_LINE DEDENT DEDENT if ( str [ 0 ] != '0' ) : NEW_LINE INDENT temp = 0 ; NEW_LINE for j in range ( 0 , len ( str ) ) : NEW_LINE INDENT temp = ( temp * 10 + ( ord ( str [ j ] ) - ord ( '0' ) ) ) NEW_LINE DEDENT k = int ( math . sqrt ( temp ) ) NEW_LINE if ( k * k == temp ) : NEW_LINE INDENT if ( ans < len ( str ) ) : NEW_LINE INDENT ans = len ( str ) NEW_LINE num = str NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( ans == - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT print ( " { } ▁ " . format ( num ) , end = " " ) NEW_LINE return n - ans NEW_LINE DEDENT DEDENT
COUNT_@@ WOR@@ DS_@@ AP@@ PE@@ AR_@@ EXAC@@ TL@@ Y_@@ TWO_@@ TIME@@ S_@@ ARRAY_@@ WORDS | def count@@ Words ( str@@ i , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ str@@ i [ i ] ] = m . get ( str@@ i [ i ] , 0 ) + 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in m . values ( ) : NEW_LINE INDENT if i == 2 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
COUNT_@@ SET_@@ BITS_@@ IN_@@ AN_@@ INTEGER_@@ 4 | def count@@ Set@@ Bits@@ Rec ( num ) : NEW_LINE INDENT ni@@ bble = 0 ; NEW_LINE if ( 0 == num ) : NEW_LINE INDENT return num_@@ to_@@ bits [ 0 ] ; NEW_LINE DEDENT ni@@ bble = num & 0xf ; NEW_LINE return num_@@ to_@@ bits [ ni@@ bble ] + count@@ Set@@ Bits@@ Rec ( num >> 4 ) ; NEW_LINE DEDENT
MAXIMUM_@@ WEIGHT_@@ PATH_@@ END@@ ING_@@ ELEMENT_@@ LAST_@@ ROW_@@ MATRIX | def max@@ Cost ( mat , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , min ( i + 1 , N ) ) : NEW_LINE INDENT dp [ i ] [ j ] = mat [ i ] [ j ] + \ NEW_LINE INDENT max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT result = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( result < dp [ N - 1 ] [ i ] ) : NEW_LINE INDENT result = dp [ N - 1 ] [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
PER@@ F@@ ECT_@@ RE@@ VERSI@@ BLE_@@ STRING | def is@@ Rever@@ sible ( str ) : NEW_LINE INDENT i = 0 ; j = len ( str ) - 1 ; NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( str [ i ] != str [ j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT
FIN@@ D_S@@ UM_@@ OD@@ D_@@ FAC@@ TOR@@ S_@@ NUMBER | def su@@ mo@@ fo@@ dd@@ Factors ( n ) : NEW_LINE INDENT res = 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT count = 0 NEW_LINE curr_@@ sum = 1 NEW_LINE curr_@@ term = 1 NEW_LINE while n % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE n = n // i NEW_LINE curr_@@ term *= i NEW_LINE curr_@@ sum += curr_@@ term NEW_LINE DEDENT res *= curr_@@ sum NEW_LINE DEDENT if n >= 2 : NEW_LINE INDENT res *= ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT
MAX@@ IM@@ UM@@ _S@@ UM_@@ PATH_@@ MATRIX_@@ TOP_@@ BOTTOM | def max@@ Sum ( mat , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return mat [ 0 ] [ 0 ] NEW_LINE DEDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE max@@ Sum = INT_@@ MIN NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT max@@ i = INT_@@ MIN NEW_LINE if ( ( ( ( j - 1 ) >= 0 ) and ( max@@ i < dp [ i + 1 ] [ j - 1 ] ) ) ) : NEW_LINE INDENT max@@ i = dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT if ( ( ( ( j + 1 ) < n ) and ( max@@ i < dp [ i + 1 ] [ j + 1 ] ) ) ) : NEW_LINE INDENT max@@ i = dp [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT dp [ i ] [ j ] = mat [ i ] [ j ] + max@@ i NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT if ( max@@ Sum < dp [ 0 ] [ j ] ) : NEW_LINE INDENT max@@ Sum = dp [ 0 ] [ j ] NEW_LINE DEDENT DEDENT return max@@ Sum NEW_LINE DEDENT
COUNT_@@ DIG@@ IT@@ S_@@ FAC@@ TOR@@ I@@ AL@@ _SET_@@ 1 | def find@@ Digits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT digits = 0 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT digits += math . log10 ( i ) ; NEW_LINE DEDENT return math . floor ( digits ) + 1 ; NEW_LINE DEDENT
FIND_@@ UN@@ COMMON_@@ CHARAC@@ TER@@ S_@@ TWO_@@ STRINGS | def find@@ And@@ Print@@ Un@@ common@@ Chars ( str1 , str2 ) : NEW_LINE INDENT present = [ 0 ] * MAX_@@ CHAR NEW_LINE for i in range ( 0 , MAX_@@ CHAR ) : NEW_LINE INDENT present [ i ] = 0 NEW_LINE DEDENT l1 = len ( str1 ) NEW_LINE l2 = len ( str2 ) NEW_LINE for i in range ( 0 , l1 ) : NEW_LINE INDENT present [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT for i in range ( 0 , l2 ) : NEW_LINE INDENT if ( present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == 1 or present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] == - 1 ) : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT present [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] = 2 NEW_LINE DEDENT DEDENT for i in range ( 0 , MAX_@@ CHAR ) : NEW_LINE INDENT if ( present [ i ] == 1 or present [ i ] == 2 ) : NEW_LINE INDENT print ( chr ( i + ord ( ' a ' ) ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
SQU@@ ARE_@@ ROOT_@@ OF_@@ AN_@@ INTEGER_@@ 1 | def floor@@ Sqrt ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT start = 1 NEW_LINE end = x NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if ( mid * mid == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid * mid < x ) : NEW_LINE INDENT start = mid + 1 NEW_LINE ans = mid NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
CHECK_@@ POSSI@@ BLE_@@ PATH_@@ 2D_@@ MATRIX | def is@@ Path ( arr ) : NEW_LINE INDENT arr [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , row ) : NEW_LINE INDENT if ( arr [ i ] [ 0 ] != - 1 ) : NEW_LINE INDENT arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for j in range ( 1 , col ) : NEW_LINE INDENT if ( arr [ 0 ] [ j ] != - 1 ) : NEW_LINE INDENT arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , row ) : NEW_LINE INDENT for j in range ( 1 , col ) : NEW_LINE INDENT if ( arr [ i ] [ j ] != - 1 ) : NEW_LINE INDENT arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ( arr [ row - 1 ] [ col - 1 ] == 1 ) NEW_LINE DEDENT
NEW@@ MAN_@@ CON@@ WAY@@ _SEQU@@ ENCE_@@ 1 | def sequence ( n ) : NEW_LINE INDENT f = array . array ( ' i ' , [ 0 , 1 , 1 ] ) NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] NEW_LINE f . append ( r ) ; NEW_LINE DEDENT return r NEW_LINE DEDENT
PRINT_@@ WOR@@ DS_@@ STRING_@@ REVERSE_@@ ORDER | def word@@ Reverse ( str ) : NEW_LINE INDENT i = len ( str ) - 1 NEW_LINE start = end = i + 1 NEW_LINE result = ' ' NEW_LINE while i >= 0 : NEW_LINE INDENT if str [ i ] == ' ▁ ' : NEW_LINE INDENT start = i + 1 NEW_LINE while start != end : NEW_LINE INDENT result += str [ start ] NEW_LINE start += 1 NEW_LINE DEDENT result += ' ▁ ' NEW_LINE end = i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT start = 0 NEW_LINE while start != end : NEW_LINE INDENT result += str [ start ] NEW_LINE start += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT
FIND_@@ NUMBER_@@ END@@ LESS_@@ POINTS | def count@@ End@@ less ( input_@@ mat , n ) : NEW_LINE INDENT row = np . zeros ( ( n , n ) ) NEW_LINE col = np . zeros ( ( n , n ) ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT is@@ End@@ less = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( input_@@ mat [ i ] [ j ] == 0 ) : NEW_LINE INDENT is@@ End@@ less = 0 NEW_LINE DEDENT col [ i ] [ j ] = is@@ End@@ less NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT is@@ End@@ less = 1 NEW_LINE for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( input_@@ mat [ i ] [ j ] == 0 ) : NEW_LINE INDENT is@@ End@@ less = 0 NEW_LINE DEDENT row [ i ] [ j ] = is@@ End@@ less NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( row [ i ] [ j ] and col [ i ] [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
CHECK_@@ POSSI@@ BLE_@@ TRANSFORM_@@ ONE_@@ STRING_@@ AN@@ OTHER | def check ( s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE dp = ( [ [ False for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] ) NEW_LINE dp [ 0 ] [ 0 ] = True NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT for j in range ( len ( s2 ) + 1 ) : NEW_LINE INDENT if ( dp [ i ] [ j ] ) : NEW_LINE INDENT if ( ( j < len ( s2 ) and ( s1 [ i ] . upper ( ) == s2 [ j ] ) ) ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = True NEW_LINE DEDENT if ( s1 [ i ] . is@@ upper ( ) == False ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT return ( dp [ n ] [ m ] ) NEW_LINE DEDENT
CAL@@ CUL@@ ATE_@@ VOLUME_@@ DO@@ DE@@ CA@@ HE@@ DRO@@ N | def vol_@@ of_@@ do@@ deca@@ hedron ( side ) : NEW_LINE INDENT return ( ( ( 15 + ( 7 * ( math . sqrt ( 5 ) ) ) ) / 4 ) * ( math . pow ( side , 3 ) ) ) NEW_LINE DEDENT
PROGRAM_@@ FIND_@@ RE@@ MA@@ INDE@@ R_@@ LARGE_@@ NUMBER_@@ DI@@ VIDE@@ D_@@ 11 | def remainder ( st ) : NEW_LINE INDENT ln = len ( st ) NEW_LINE rem = 0 NEW_LINE for i in range ( 0 , ln ) : NEW_LINE INDENT num = rem * 10 + ( int ) ( st [ i ] ) NEW_LINE rem = num % 11 NEW_LINE DEDENT return rem NEW_LINE DEDENT
SORT_@@ STRING_@@ CHARAC@@ TERS | def sort@@ String ( str ) : NEW_LINE INDENT str = ' ' . join ( sorted ( str ) ) NEW_LINE print ( str ) NEW_LINE DEDENT
B@@ IR@@ TH@@ DAY_@@ PAR@@ ADO@@ X | def find ( p ) : NEW_LINE INDENT return math . ceil ( math . sqrt ( 2 * 365 * math . log ( 1 / ( 1 - p ) ) ) ) ; NEW_LINE DEDENT
CHECK_@@ LINE_@@ PAS@@ SES_@@ ORIGIN | def check@@ Origin ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) NEW_LINE DEDENT
FIND_@@ ELEMEN@@ TS_@@ ARRAY_@@ LEA@@ ST_@@ TWO_@@ GREATER_@@ ELEMEN@@ TS_@@ 2 | def find@@ Elements ( arr , n ) : NEW_LINE INDENT first = - sys . maxsize NEW_LINE second = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < second ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
MIN@@ IM@@ UM@@ _S@@ UM@@ _SUB@@ SEQU@@ ENCE_@@ LEA@@ ST_@@ ONE_@@ EVER@@ Y_@@ FOUR_@@ CON@@ SEC@@ UTI@@ VE_@@ ELEMEN@@ TS_@@ PIC@@ KED_@@ 1 | def min@@ Sum ( ar , n ) : NEW_LINE INDENT if ( n <= 4 ) : NEW_LINE INDENT return min ( ar ) NEW_LINE DEDENT sum = [ 0 for i in range ( n ) ] NEW_LINE sum [ 0 ] = ar [ 0 ] NEW_LINE sum [ 1 ] = ar [ 1 ] NEW_LINE sum [ 2 ] = ar [ 2 ] NEW_LINE sum [ 3 ] = ar [ 3 ] NEW_LINE for i in range ( 4 , n ) : NEW_LINE INDENT sum [ i ] = ar [ i ] + min ( sum [ i - 4 : i ] ) NEW_LINE DEDENT return min ( sum [ n - 4 : n ] ) NEW_LINE DEDENT
CEI@@ LING_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY | def ceil@@ Search ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT i = low NEW_LINE for i in range ( high ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT if arr [ i ] < x and arr [ i + 1 ] >= x : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
SW@@ AP_@@ TWO_@@ NUMB@@ ERS_@@ WITH@@ OUT_@@ USING_@@ TEMPOR@@ ARY_@@ VARIABLE_@@ 1 | def swap ( xp , yp ) : NEW_LINE INDENT if ( xp [ 0 ] == yp [ 0 ] ) : NEW_LINE INDENT return NEW_LINE DEDENT xp [ 0 ] = xp [ 0 ] + yp [ 0 ] NEW_LINE yp [ 0 ] = xp [ 0 ] - yp [ 0 ] NEW_LINE xp [ 0 ] = xp [ 0 ] - yp [ 0 ] NEW_LINE DEDENT
MINIMUM_@@ NUMBER_OF_@@ MAN@@ IP@@ UL@@ ATION@@ S_@@ REQUIRED_@@ TO_@@ MAKE_@@ TWO_@@ STRING@@ S_@@ AN@@ AG@@ RAM_@@ WITH@@ OUT_@@ DELE@@ TION_@@ OF_@@ CHARACTER | def count@@ Manip@@ ul@@ ations ( s1 , s2 ) : NEW_LINE INDENT count = 0 NEW_LINE char@@ _count = [ 0 ] * 26 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT char@@ _count [ i ] = 0 NEW_LINE DEDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT char@@ _count [ ord ( s1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT char@@ _count [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE if ( char@@ _count [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] < 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
CHECK_@@ IF_@@ ALL_@@ THE_@@ ELEMEN@@ TS_@@ CAN_@@ BE_@@ MA@@ DE_@@ OF@@ _S@@ AME_@@ PAR@@ ITY_@@ BY_@@ INVER@@ TING_@@ AD@@ J@@ AC@@ ENT_@@ ELEMENTS | def fli@@ ps@@ Possible ( a , n ) : NEW_LINE INDENT count_@@ odd = 0 ; count_@@ even = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] & 1 ) : NEW_LINE INDENT count_@@ odd += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count_@@ even += 1 ; NEW_LINE DEDENT DEDENT if ( count_@@ odd % 2 and count_@@ even % 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT
CONVERT_@@ SUB@@ STRING@@ S_@@ LENGTH_@@ K_@@ BASE_@@ B_@@ DECIMAL | def sub@@ string@@ Conversions ( s , k , b ) : NEW_LINE INDENT l = len ( s ) ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( ( i + k ) < l + 1 ) : NEW_LINE INDENT sub = s [ i : i + k ] ; NEW_LINE sum , counter = 0 , 0 ; NEW_LINE for i in range ( len ( sub ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) ; NEW_LINE counter += 1 ; NEW_LINE DEDENT print ( sum , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
FIND_@@ K@@ _SU@@ CH_@@ TH@@ AT_@@ ALL_@@ ELEMEN@@ TS_@@ IN_@@ K@@ TH_@@ ROW_@@ ARE_@@ 0_@@ AND_@@ K@@ TH_@@ COLUMN_@@ ARE_@@ 1_@@ IN_@@ A_@@ BOOLEAN_@@ MATRIX | def find ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE res = - 1 NEW_LINE while i < n and j >= 0 : NEW_LINE INDENT if arr [ i ] [ j ] == 0 : NEW_LINE INDENT while j >= 0 and ( arr [ i ] [ j ] == 0 or i == j ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if j == - 1 : NEW_LINE INDENT res = i NEW_LINE break NEW_LINE DEDENT else : i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT while i < n and ( arr [ i ] [ j ] == 1 or i == j ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i == n : NEW_LINE INDENT res = j NEW_LINE break NEW_LINE DEDENT else : j -= 1 NEW_LINE DEDENT DEDENT if res == - 1 : NEW_LINE INDENT return res NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if res != i and arr [ i ] [ res ] != 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT for j in range ( 0 , j ) : NEW_LINE INDENT if res != j and arr [ res ] [ j ] != 0 : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT
NUMBER_@@ ORDE@@ RED_@@ PAIR@@ S_@@ AI_@@ A@@ J@@ _0 | def count@@ Pairs ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ i ] & a [ j ] ) == 0 : NEW_LINE INDENT count += 2 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
CI@@ R@@ CLE_@@ LAT@@ TIC@@ E_@@ POINTS | def count@@ Lat@@ tice ( r ) : NEW_LINE INDENT if ( r <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = 4 NEW_LINE for x in range ( 1 , r ) : NEW_LINE INDENT y@@ Square = r * r - x * x NEW_LINE y = int ( math . sqrt ( y@@ Square ) ) NEW_LINE if ( y * y == y@@ Square ) : NEW_LINE INDENT result += 4 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
MINIMUM_@@ CHARAC@@ TER@@ S_@@ AD@@ DED_@@ FRONT_@@ MAKE_@@ STRING_@@ PA@@ LIN@@ DRO@@ ME | def isp@@ al@@ ind@@ ro@@ me ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE j = l - 1 NEW_LINE while i <= j : NEW_LINE INDENT if ( s [ i ] != s [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
K_@@ TH_@@ MISSING_@@ ELEMENT_@@ INCRE@@ AS@@ ING@@ _SEQU@@ ENCE_@@ NOT_@@ PRES@@ ENT_@@ GI@@ VEN@@ _SEQU@@ ENCE | def find ( a , b , k , n1 , n2 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT missing = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if a [ i ] not in s : NEW_LINE INDENT missing += 1 NEW_LINE DEDENT if missing == k : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
PROGRAM_@@ CHECK_@@ IS@@ BN | def isValid@@ IS@@ BN ( is@@ bn ) : NEW_LINE INDENT if len ( is@@ bn ) != 10 : NEW_LINE INDENT return False NEW_LINE DEDENT _@@ sum = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if 0 <= int ( is@@ bn [ i ] ) <= 9 : NEW_LINE INDENT _@@ sum += int ( is@@ bn [ i ] ) * ( 10 - i ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( is@@ bn [ 9 ] != ' X ' and 0 <= int ( is@@ bn [ 9 ] ) <= 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT _@@ sum += 10 if is@@ bn [ 9 ] == ' X ' else int ( is@@ bn [ 9 ] ) NEW_LINE return ( _@@ sum % 11 == 0 ) NEW_LINE DEDENT
COUNT_@@ WAY@@ S_@@ INCRE@@ ASE_@@ LC@@ S_@@ LENGTH_@@ TWO_@@ STRING@@ S_@@ ONE | def way@@ sTo@@ Increase@@ L@@ CS@@ By@@ 1 ( str1 , str2 ) : NEW_LINE INDENT m = len ( str1 ) NEW_LINE n = len ( str2 ) NEW_LINE position = [ [ ] for i in range ( M ) ] NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT position [ ord ( str2 [ i - 1 ] ) - 97 ] . append ( i ) NEW_LINE DEDENT l@@ cs@@ l = [ [ 0 for i in range ( n + 2 ) ] for j in range ( m + 2 ) ] NEW_LINE l@@ csr = [ [ 0 for i in range ( n + 2 ) ] for j in range ( m + 2 ) ] NEW_LINE for i in range ( 1 , m + 1 , 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT l@@ cs@@ l [ i ] [ j ] = 1 + l@@ cs@@ l [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT l@@ cs@@ l [ i ] [ j ] = max ( l@@ cs@@ l [ i - 1 ] [ j ] , l@@ cs@@ l [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( m , 0 , - 1 ) : NEW_LINE INDENT for j in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT l@@ csr [ i ] [ j ] = 1 + l@@ csr [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT l@@ csr [ i ] [ j ] = max ( l@@ csr [ i + 1 ] [ j ] , l@@ csr [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ways = 0 NEW_LINE for i in range ( 0 , m + 1 , 1 ) : NEW_LINE INDENT for C in range ( 0 , 26 , 1 ) : NEW_LINE INDENT for j in range ( 0 , len ( position [ C ] ) , 1 ) : NEW_LINE INDENT p = position [ C ] [ j ] NEW_LINE if ( l@@ cs@@ l [ i ] [ p - 1 ] + l@@ csr [ i + 1 ] [ p + 1 ] == l@@ cs@@ l [ m ] [ n ] ) : NEW_LINE INDENT ways += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ways NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 11_@@ EG@@ G_@@ DRO@@ PP@@ ING_@@ PU@@ ZZ@@ LE_@@ 1 | def egg@@ Drop ( n , k ) : NEW_LINE INDENT egg@@ Floor = [ [ 0 for x in range ( k + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT egg@@ Floor [ i ] [ 1 ] = 1 NEW_LINE egg@@ Floor [ i ] [ 0 ] = 0 NEW_LINE DEDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT egg@@ Floor [ 1 ] [ j ] = j NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 2 , k + 1 ) : NEW_LINE INDENT egg@@ Floor [ i ] [ j ] = INT_MAX NEW_LINE for x in range ( 1 , j + 1 ) : NEW_LINE INDENT res = 1 + max ( egg@@ Floor [ i - 1 ] [ x - 1 ] , egg@@ Floor [ i ] [ j - x ] ) NEW_LINE if res < egg@@ Floor [ i ] [ j ] : NEW_LINE INDENT egg@@ Floor [ i ] [ j ] = res NEW_LINE DEDENT DEDENT DEDENT DEDENT return egg@@ Floor [ n ] [ k ] NEW_LINE DEDENT
WAY@@ S_TO_@@ WRITE_@@ N_@@ AS@@ _S@@ UM_@@ OF_@@ TWO_@@ OR_@@ MORE_@@ POSITIVE_@@ INTEG@@ ERS | def Count@@ W@@ ays ( n ) : NEW_LINE INDENT table = [ 0 ] * ( n + 1 ) NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT table [ j ] += table [ j - i ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE DEDENT
PROGR@@ AM@@ _S@@ UM_@@ COS@@ X@@ _SERI@@ ES | def cos@@ X@@ Ser@@ ties@@ Sum ( x , n ) : NEW_LINE INDENT x = x * ( PI / 180.0 ) ; NEW_LINE res = 1 ; NEW_LINE sign = 1 ; NEW_LINE fact = 1 ; NEW_LINE pow = 1 ; NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT sign = sign * - 1 ; NEW_LINE fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; NEW_LINE pow = pow * x * x ; NEW_LINE res = res + sign * pow / fact ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
UNI@@ QUE_@@ CEL@@ LS_@@ BINARY_@@ MATRIX | def count@@ Unique ( mat , n , m ) : NEW_LINE INDENT row@@ sum = [ 0 ] * n ; NEW_LINE col@@ sum = [ 0 ] * m ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != 0 ) : NEW_LINE INDENT row@@ sum [ i ] += 1 ; NEW_LINE col@@ sum [ j ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT unique@@ count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != 0 and row@@ sum [ i ] == 1 and col@@ sum [ j ] == 1 ) : NEW_LINE INDENT unique@@ count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return unique@@ count ; NEW_LINE DEDENT
GRE@@ ED@@ Y_@@ ALGORITH@@ M_@@ TO_@@ FIND_@@ MINIMUM_@@ NUMBER_OF_@@ CO@@ INS | def find@@ Min ( V ) : NEW_LINE INDENT den@@ o = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 ] NEW_LINE n = len ( den@@ o ) NEW_LINE ans = [ ] NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT while ( V >= den@@ o [ i ] ) : NEW_LINE INDENT V -= den@@ o [ i ] NEW_LINE ans . append ( den@@ o [ i ] ) NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
CHECK_@@ INTEGER_@@ OVERFLOW_@@ MULTIP@@ LIC@@ ATION | def is@@ Overflow ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT result = a * b NEW_LINE if ( result >= 92233720368547758@@ 07 or result <= - 92233720368547758@@ 08 ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT if ( a == ( result // b ) ) : NEW_LINE INDENT print ( result // b ) NEW_LINE return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
DIFF@@ ER@@ ENCE_@@ BETWE@@ EN_@@ HIGH@@ EST_@@ AND_@@ LEA@@ ST_@@ FREQU@@ ENCI@@ ES_@@ IN_@@ AN_@@ ARRAY_@@ 1 | def find@@ Diff ( arr , n ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT max_@@ count = 0 ; min_@@ count = n NEW_LINE for key , values in mp . items ( ) : NEW_LINE INDENT max_@@ count = max ( max_@@ count , values ) NEW_LINE min_@@ count = min ( min_@@ count , values ) NEW_LINE DEDENT return max_@@ count - min_@@ count NEW_LINE DEDENT
COMPOSI@@ TE_@@ NUMBER | def is@@ Composite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT
LAR@@ GE@@ ST_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQU@@ ENCE_@@ OF_@@ CON@@ SEC@@ UTI@@ VE_@@ INTEG@@ ERS | def find@@ LI@@ S ( A , n ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE LI@@ S_@@ size , LI@@ S_@@ index = 1 , 0 NEW_LINE hash [ A [ 0 ] ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if A [ i ] - 1 not in hash : NEW_LINE INDENT hash [ A [ i ] - 1 ] = 0 NEW_LINE DEDENT hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1 NEW_LINE if LI@@ S_@@ size < hash [ A [ i ] ] : NEW_LINE INDENT LI@@ S_@@ size = hash [ A [ i ] ] NEW_LINE LI@@ S_@@ index = A [ i ] NEW_LINE DEDENT DEDENT print ( " LI@@ S _ size ▁ = " , LI@@ S_@@ size ) NEW_LINE print ( " LI@@ S ▁ : ▁ " , end = " " ) NEW_LINE start = LI@@ S_@@ index - LI@@ S_@@ size + 1 NEW_LINE while start <= LI@@ S_@@ index : NEW_LINE INDENT print ( start , end = " ▁ " ) NEW_LINE start += 1 NEW_LINE DEDENT DEDENT
COUNT_@@ SET_@@ BITS_@@ IN_@@ AN_@@ INTEGER_@@ 2 | def count@@ Set@@ Bits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
FIND_@@ FOUR_@@ ELEMEN@@ TS_@@ A_@@ B_@@ C_@@ AND_@@ D_@@ IN_@@ AN_@@ ARRAY@@ _SU@@ CH_@@ TH@@ AT_@@ AB_@@ CD | def find@@ Pairs ( arr , n ) : NEW_LINE Hash = { } NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE sum = arr [ i ] + arr [ j ] NEW_LINE if sum in Hash . keys ( ) : NEW_LINE INDENT prev = Hash . get ( sum ) NEW_LINE print ( str ( prev ) + " ▁ and ▁ ( % d , ▁ % d ) " % ( arr [ i ] , arr [ j ] ) ) NEW_LINE return True NEW_LINE DEDENT else : NEW_LINE INDENT Hash [ sum ] = ( arr [ i ] , arr [ j ] ) NEW_LINE DEDENT DEDENT
COUNT_@@ OB@@ T@@ USE_@@ ANG@@ LES_@@ CI@@ R@@ CLE_@@ K_@@ EQU@@ ID@@ I@@ STAN@@ T_@@ POINT@@ S_@@ 2_@@ GI@@ V@@ EN_@@ POINTS | def count@@ Ob@@ t@@ use@@ Angles ( a , b , k ) : NEW_LINE INDENT c1 = ( b - a ) - 1 NEW_LINE c2 = ( k - b ) + ( a - 1 ) NEW_LINE if ( c1 == c2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return min ( c1 , c2 ) NEW_LINE DEDENT
NUMBER_@@ TRIANG@@ LES_@@ N_@@ MOVE@@ S_@@ 1 | def numberOf@@ Triangles ( n ) : NEW_LINE INDENT ans = 2 * ( pow ( 3 , n ) ) - 1 ; NEW_LINE return ans ; NEW_LINE DEDENT
FIND_@@ A_@@ REPE@@ ATING_@@ AND_@@ A_@@ MISSING_@@ NUMBER | def print@@ Two@@ Elements ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT if arr [ abs ( arr [ i ] ) - 1 ] > 0 : NEW_LINE INDENT arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ repe@@ ating ▁ element ▁ is " , abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT print ( " and ▁ the ▁ missing ▁ element ▁ is " , i + 1 ) NEW_LINE DEDENT DEDENT DEDENT
MINIMUM_@@ DIFF@@ ER@@ ENCE_@@ BETWE@@ EN_@@ GROUP@@ S_@@ OF@@ _SIZE_@@ TWO | def calculate ( a , n ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE s = [ ] ; NEW_LINE i = 0 ; NEW_LINE j = n - 1 ; NEW_LINE while ( i < j ) : NEW_LINE INDENT s . append ( ( a [ i ] + a [ j ] ) ) ; NEW_LINE i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT mini = min ( s ) ; NEW_LINE max@@ i = max ( s ) ; NEW_LINE return abs ( max@@ i - mini ) ; NEW_LINE DEDENT
FIND_@@ PER@@ I@@ ME@@ TER_@@ CY@@ LIN@@ DER | def per@@ imeter ( diameter , height ) : NEW_LINE INDENT return 2 * ( diameter + height ) NEW_LINE DEDENT
MAG@@ ICAL_@@ INDI@@ CES_@@ ARRAY | def solve ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE parent = [ None ] * ( n + 1 ) NEW_LINE vis = [ None ] * ( n + 1 ) NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT parent [ i ] = - 1 NEW_LINE vis [ i ] = 0 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT j = i NEW_LINE if ( parent [ j ] == - 1 ) : NEW_LINE INDENT while ( parent [ j ] == - 1 ) : NEW_LINE INDENT parent [ j ] = i NEW_LINE j = ( j + A [ j ] + 1 ) % n NEW_LINE DEDENT if ( parent [ j ] == i ) : NEW_LINE INDENT while ( vis [ j ] == 0 ) : NEW_LINE INDENT vis [ j ] = 1 NEW_LINE cnt = cnt + 1 NEW_LINE j = ( j + A [ j ] + 1 ) % n NEW_LINE DEDENT DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
FIND_@@ A_@@ FIXED_@@ POINT_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ 1 | def binary@@ Search ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE DEDENT if mid is arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if mid > arr [ mid ] : NEW_LINE INDENT return binary@@ Search ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT else : NEW_LINE INDENT return binary@@ Search ( arr , low , ( mid - 1 ) ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
FIN@@ D@@ _SIZE_@@ OF_THE_@@ LAR@@ GE@@ ST_@@ FOR@@ MED_@@ BY_@@ ALL_@@ ONE@@ S_IN_@@ A_@@ BINARY_@@ MATRIX | def find@@ Largest@@ Plus ( mat ) : NEW_LINE INDENT left = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE right = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE top = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE bottom = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT top [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] NEW_LINE left [ i ] [ 0 ] = mat [ i ] [ 0 ] NEW_LINE right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ i ] [ j ] = 0 NEW_LINE DEDENT if ( mat [ j ] [ i ] == 1 ) : NEW_LINE INDENT top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT top [ j ] [ i ] = 0 NEW_LINE DEDENT j = N - 1 - j NEW_LINE if ( mat [ j ] [ i ] == 1 ) : NEW_LINE INDENT bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT bottom [ j ] [ i ] = 0 NEW_LINE DEDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ i ] [ j ] = 0 NEW_LINE DEDENT j = N - 1 - j NEW_LINE DEDENT DEDENT n = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT l = min ( min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) NEW_LINE if ( l > n ) : NEW_LINE INDENT n = l NEW_LINE DEDENT DEDENT DEDENT if ( n ) : NEW_LINE INDENT return 4 * ( n - 1 ) + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
LEVEL_@@ NODE_@@ TREE_@@ SOURCE_@@ NODE_@@ USING_@@ B@@ FS | def print@@ Levels ( graph , V , x ) : NEW_LINE INDENT level = [ None ] * V NEW_LINE marked = [ False ] * V NEW_LINE que = queue . Queue ( ) NEW_LINE que . put ( x ) NEW_LINE level [ x ] = 0 NEW_LINE marked [ x ] = True NEW_LINE while ( not que . empty ( ) ) : NEW_LINE INDENT x = que . get ( ) NEW_LINE for i in range ( len ( graph [ x ] ) ) : NEW_LINE INDENT b = graph [ x ] [ i ] NEW_LINE if ( not marked [ b ] ) : NEW_LINE INDENT que . put ( b ) NEW_LINE level [ b ] = level [ x ] + 1 NEW_LINE marked [ b ] = True NEW_LINE DEDENT DEDENT DEDENT print ( " Nodes " , " ▁ " , " Level " ) NEW_LINE for i in range ( V ) : NEW_LINE INDENT print ( " ▁ " , i , " ▁ - - > ▁ " , level [ i ] ) NEW_LINE DEDENT DEDENT
FIN@@ D_S@@ QU@@ ARE_@@ ROOT_@@ UN@@ DER_@@ MODUL@@ O_@@ P@@ _SET_@@ 1_@@ WH@@ EN_@@ P_@@ IS_@@ IN_@@ FORM_@@ OF_@@ 4@@ I_@@ 3 | def square@@ Root ( n , p ) : NEW_LINE INDENT n = n % p NEW_LINE for x in range ( 2 , p ) : NEW_LINE INDENT if ( ( x * x ) % p == n ) : NEW_LINE INDENT print ( " Square ▁ root ▁ is ▁ " , x ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " Square ▁ root ▁ doesn ' t ▁ exist " ) NEW_LINE DEDENT
CHECK_@@ IF_@@ ARRAY_@@ ELEMEN@@ TS_@@ ARE_@@ CON@@ SEC@@ UTI@@ VE | def are@@ Con@@ sec@@ utive ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT Min = min ( arr ) NEW_LINE Max = max ( arr ) NEW_LINE if ( Max - Min + 1 == n ) : NEW_LINE INDENT visited = [ False for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( visited [ arr [ i ] - Min ] != False ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited [ arr [ i ] - Min ] = True NEW_LINE DEDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
SM@@ ALLE@@ ST@@ _SUB@@ SET_@@ S@@ UM_@@ GREATER_@@ ELEMENTS | def min@@ Elements ( arr , n ) : NEW_LINE INDENT half@@ Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT half@@ Sum = half@@ Sum + arr [ i ] NEW_LINE DEDENT half@@ Sum = int ( half@@ Sum / 2 ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE res = 0 NEW_LINE curr_@@ sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_@@ sum += arr [ i ] NEW_LINE res += 1 NEW_LINE if curr_@@ sum > half@@ Sum : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
S@@ UM_@@ OF_@@ ALL_@@ ELEMEN@@ TS_@@ UP_@@ TO_@@ N@@ TH_@@ ROW_@@ IN_@@ A_@@ PAS@@ CAL@@ S_@@ TRIANGLE_@@ 1 | def calculate@@ Sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE sum = 1 << n ; NEW_LINE return ( sum - 1 ) NEW_LINE DEDENT
SW@@ AP_@@ TWO_@@ NI@@ BB@@ LES_@@ BYTE | def swap@@ Ni@@ bb@@ les ( x ) : NEW_LINE INDENT return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) NEW_LINE DEDENT
CHECK_@@ CHARAC@@ TER@@ S_@@ GI@@ V@@ EN_@@ STRING_@@ CAN_@@ RE@@ AR@@ RANGE@@ D_@@ FORM_@@ PA@@ LIN@@ DRO@@ ME_@@ 1 | def can@@ Form@@ Pal@@ ind@@ ro@@ me ( str@@ r ) : NEW_LINE INDENT list@@ t = [ ] NEW_LINE for i in range ( len ( str@@ r ) ) : NEW_LINE INDENT if ( str@@ r [ i ] in list@@ t ) : NEW_LINE INDENT list@@ t . remove ( str@@ r [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT list@@ t . append ( str@@ r [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( str@@ r ) % 2 == 0 and len ( list@@ t ) == 0 or \ ( len ( str@@ r ) % 2 == 1 and len ( list@@ t ) == 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
WAY@@ S@@ _SP@@ LIT_@@ STRING_@@ PARTITION_@@ STAR@@ TS_@@ DISTIN@@ CT_@@ CHARACTER | def count@@ W@@ ays ( s ) : NEW_LINE INDENT count = [ 0 ] * 26 ; NEW_LINE for x in s : NEW_LINE INDENT count [ ord ( x ) - ord ( ' a ' ) ] = ( count [ ord ( x ) - ord ( ' a ' ) ] ) + 1 ; NEW_LINE DEDENT count [ ord ( s [ 0 ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE ans = 1 ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT ans *= count [ i ] ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
ENTR@@ ING@@ ER_@@ NUMBER_@@ 1 | def zig@@ z@@ ag ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
COUNT_@@ PAIR@@ S_@@ DIFF@@ ER@@ ENCE_@@ EQUAL_@@ K | def count@@ Pai@@ rs@@ With@@ Diff@@ K ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
EXPEC@@ TATION_@@ EXPECTED_@@ VALUE_@@ ARRAY | def calc_@@ Expect@@ ation ( a , n ) : NEW_LINE INDENT pr@@ b = 1 / n NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += ( a [ i ] * pr@@ b ) NEW_LINE DEDENT return float ( sum ) NEW_LINE DEDENT
GROUP_@@ OC@@ CURR@@ EN@@ CES_@@ CHARAC@@ TER@@ S_@@ AC@@ COR@@ DING_@@ FIRST_@@ AP@@ PE@@ AR@@ ANCE | def print@@ Group@@ ed ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE count = [ 0 ] * MAX_@@ CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( string [ i ] ) - ord ( " a " ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT while count [ ord ( string [ i ] ) - ord ( " a " ) ] : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE count [ ord ( string [ i ] ) - ord ( " a " ) ] -= 1 NEW_LINE DEDENT count [ ord ( string [ i ] ) - ord ( " a " ) ] = 0 NEW_LINE DEDENT DEDENT
MAXIMUM_@@ PATH@@ _S@@ UM_@@ POSITION_@@ JUM@@ PS_@@ DI@@ VISIBILITY_@@ CONDITION | def print@@ Max@@ Sum ( arr , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = arr [ i ] NEW_LINE max@@ i = 0 NEW_LINE for j in range ( 1 , int ( ( i + 1 ) ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( ( i + 1 ) % j == 0 and ( i + 1 ) != j ) : NEW_LINE INDENT if ( dp [ j - 1 ] > max@@ i ) : NEW_LINE INDENT max@@ i = dp [ j - 1 ] NEW_LINE DEDENT if ( dp [ ( i + 1 ) // j - 1 ] > max@@ i and j != 1 ) : NEW_LINE INDENT max@@ i = dp [ ( i + 1 ) // j - 1 ] NEW_LINE DEDENT DEDENT DEDENT dp [ i ] += max@@ i NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( dp [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
PROGRAM_@@ CIRCUM@@ FER@@ ENCE_@@ PARALLE@@ LOG@@ RAM | def circum@@ ference@@ paralle@@ log@@ ram ( a , b ) : NEW_LINE INDENT return ( ( 2 * a ) + ( 2 * b ) ) NEW_LINE DEDENT
COUNT_@@ POSSI@@ BLE_@@ PATH@@ S_@@ TOP_@@ LEFT_@@ BOTTOM_@@ RIGHT_@@ NX@@ M_@@ MATRIX_@@ 2 | def numberOf@@ Paths ( p , q ) : NEW_LINE INDENT dp = [ 1 for i in range ( q ) ] NEW_LINE for i in range ( p - 1 ) : NEW_LINE INDENT for j in range ( 1 , q ) : NEW_LINE INDENT dp [ j ] += dp [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ q - 1 ] NEW_LINE DEDENT
REMOVE_@@ MINIMUM_@@ NUMBER_@@ CHARAC@@ TER@@ S_@@ TWO_@@ STRING@@ S_@@ BE@@ COM@@ E_@@ AN@@ AG@@ RAM | def rem@@ An@@ agram ( str1 , str2 ) : NEW_LINE INDENT count@@ 1 = [ 0 ] * CHARS NEW_LINE count2 = [ 0 ] * CHARS NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) : NEW_LINE INDENT count@@ 1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( str2 ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count@@ 1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
S@@ UM_@@ DI@@ VI@@ SOR@@ S_@@ 1_@@ N_@@ 1 | def di@@ visor@@ Sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += int ( n / i ) * i NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT
FIND_@@ LENGTH_@@ LON@@ GE@@ ST@@ _SUB@@ SEQU@@ ENCE_@@ ONE_@@ STRING@@ _SUB@@ STRING_@@ AN@@ OTHER_@@ STRING | def max@@ Sub@@ sequence@@ Sub@@ string ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
S@@ UM_@@ FA@@ I_@@ A@@ J_@@ PAIR@@ S_@@ ARRAY_@@ N_@@ INTEG@@ ERS | def sum ( a , n ) : NEW_LINE INDENT cnt = dict ( ) NEW_LINE ans = 0 NEW_LINE pre_@@ sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += ( i * a [ i ] ) - pre_@@ sum NEW_LINE pre_@@ sum += a [ i ] NEW_LINE if ( a [ i ] - 1 ) in cnt : NEW_LINE INDENT ans -= cnt [ a [ i ] - 1 ] NEW_LINE DEDENT if ( a [ i ] + 1 ) in cnt : NEW_LINE INDENT ans += cnt [ a [ i ] + 1 ] NEW_LINE DEDENT if a [ i ] not in cnt : NEW_LINE INDENT cnt [ a [ i ] ] = 0 NEW_LINE DEDENT cnt [ a [ i ] ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
BINARY_@@ RE@@ PRESEN@@ TATION_@@ OF_@@ A_@@ GI@@ V@@ EN_@@ NUMBER | def bin ( n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT bin ( n // 2 ) NEW_LINE DEDENT print ( n % 2 , end = " " ) NEW_LINE DEDENT
KN@@ AP@@ S@@ ACK_@@ PRO@@ BLE@@ M | def kn@@ ap@@ S@@ ack ( W , wt , val , n ) : NEW_LINE INDENT if n == 0 or W == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt [ n - 1 ] > W ) : NEW_LINE INDENT return kn@@ ap@@ S@@ ack ( W , wt , val , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( val [ n - 1 ] + kn@@ ap@@ S@@ ack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , kn@@ ap@@ S@@ ack ( W , wt , val , n - 1 ) ) NEW_LINE DEDENT DEDENT
DOUBLE_@@ FAC@@ TOR@@ I@@ AL_@@ 1 | def double@@ factorial ( n ) : NEW_LINE INDENT res = 1 ; NEW_LINE for i in range ( n , - 1 , - 2 ) : NEW_LINE INDENT if ( i == 0 or i == 1 ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT else : NEW_LINE INDENT res *= i ; NEW_LINE DEDENT DEDENT DEDENT
COUNT_@@ DIG@@ IT@@ S_@@ FAC@@ TOR@@ I@@ AL@@ _SET_@@ 2 | def find@@ Digits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT x = ( ( n * math . log10 ( n / math . e ) + math . log10 ( 2 * math . pi * n ) / 2.0 ) ) ; NEW_LINE return math . floor ( x ) + 1 ; NEW_LINE DEDENT
DE@@ LAN@@ NO@@ Y_@@ NUMBER_@@ 1 | def de@@ al@@ n@@ no@@ y ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
FIND_@@ THE_@@ MISSING_@@ NUMBER_@@ 2 | def get@@ Missing@@ No ( a , n ) : NEW_LINE INDENT x1 = a [ 0 ] NEW_LINE x2 = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT x1 = x1 ^ a [ i ] NEW_LINE DEDENT for i in range ( 2 , n + 2 ) : NEW_LINE INDENT x2 = x2 ^ i NEW_LINE DEDENT return x1 ^ x2 NEW_LINE DEDENT
FIND_@@ NUMBER_OF_@@ TRIANG@@ LES_@@ POSSI@@ BLE | def find@@ number@@ of@@ Triangles ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arr . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT k = i + 2 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT while ( k < n and arr [ i ] + arr [ j ] > arr [ k ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT if ( k > j ) : NEW_LINE INDENT count += k - j - 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
NUMBER_@@ TRIANG@@ LES_@@ N_@@ MOV@@ ES | def numberOf@@ Triangles ( n ) : NEW_LINE INDENT answer = [ None ] * ( n + 1 ) ; NEW_LINE answer [ 0 ] = 1 ; NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT answer [ i ] = answer [ i - 1 ] * 3 + 2 ; NEW_LINE i = i + 1 NEW_LINE DEDENT return answer [ n ] ; NEW_LINE DEDENT
CHECK@@ _S@@ UM@@ S_@@ TH_@@ ROW_@@ TH_@@ COLUMN_@@ MATRIX | def are@@ Sum@@ Same ( a , n , m ) : NEW_LINE INDENT sum@@ 1 = 0 NEW_LINE sum@@ 2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum@@ 1 = 0 NEW_LINE sum@@ 2 = 0 NEW_LINE for j in range ( 0 , m ) : NEW_LINE INDENT sum@@ 1 += a [ i ] [ j ] NEW_LINE sum@@ 2 += a [ j ] [ i ] NEW_LINE DEDENT if ( sum@@ 1 == sum@@ 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
WRITE_@@ ONE_@@ LINE_@@ C_@@ FUNCTION_@@ TO_@@ FIND_@@ WHE@@ THER_@@ A_@@ NO_@@ IS_@@ POWER_@@ OF_@@ TWO | def is@@ PowerOf@@ Two ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 2 NEW_LINE DEDENT return True NEW_LINE DEDENT
PUT_@@ SPAC@@ ES_@@ WOR@@ DS_@@ START@@ ING_@@ CAPI@@ TAL_@@ LET@@ TERS | def am@@ end@@ Sentence ( string ) : NEW_LINE INDENT string = list ( string ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if string [ i ] >= ' A ' and string [ i ] <= ' Z ' : NEW_LINE INDENT string [ i ] = chr ( ord ( string [ i ] ) + 32 ) NEW_LINE if i != 0 : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
CHECK_@@ DI@@ VISIBILITY_@@ BINARY_@@ STRING_@@ 2@@ K | def is@@ Di@@ visible ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE c = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT if ( str [ n - i - 1 ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return ( c == k ) NEW_LINE DEDENT
SUB@@ SEQU@@ EN@@ CE@@ S@@ _SIZE_@@ THRE@@ E_@@ ARRAY_@@ WHO@@ SE_@@ S@@ UM_@@ DI@@ VISI@@ BLE_@@ M | def co@@ ut@@ Sub@@ Seq ( A , N , M ) : NEW_LINE INDENT sum = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT for k in range ( j + 1 , N ) : NEW_LINE INDENT sum = A [ i ] + A [ j ] + A [ k ] NEW_LINE if ( sum % M == 0 ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
LON@@ GE@@ ST_@@ CON@@ SEC@@ UTI@@ VE_@@ SUB@@ SEQUENCE | def find@@ Lon@@ gest@@ Con@@ seq@@ Sub@@ seq ( arr , n ) : NEW_LINE INDENT s = Set ( ) NEW_LINE ans = 0 NEW_LINE for ele in arr : NEW_LINE INDENT s . add ( ele ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] - 1 ) not in s : NEW_LINE INDENT j = arr [ i ] NEW_LINE while ( j in s ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT ans = max ( ans , j - arr [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
FIND_@@ INDEX_@@ GI@@ V@@ EN_@@ FI@@ BON@@ ACC@@ I_@@ NUMBER_@@ CONSTANT_@@ TIME_@@ 1 | def find@@ Index ( n ) : NEW_LINE INDENT fi@@ bo = 2.@@ 07@@ 808@@ 7 * math . log ( n ) + 1.@@ 67@@ 22@@ 76 NEW_LINE return round ( fi@@ bo ) NEW_LINE DEDENT
LAR@@ GE@@ ST_@@ DI@@ VISI@@ BLE_@@ PAIR@@ S@@ _SUB@@ SET | def lar@@ gest@@ Subset ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE dp = [ 0 for i in range ( n ) ] NEW_LINE dp [ n - 1 ] = 1 ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT mx@@ m = 0 ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ j ] % a [ i ] == 0 : NEW_LINE INDENT mx@@ m = max ( mx@@ m , dp [ j ] ) NEW_LINE DEDENT DEDENT dp [ i ] = 1 + mx@@ m NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT
FIND_@@ WHE@@ THER_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ IS_@@ A_@@ POWER_@@ OF_@@ 4_@@ OR_@@ NOT_@@ 2 | def is@@ PowerOf@@ Four ( n ) : NEW_LINE INDENT return ( n != 0 and ( ( n & ( n - 1 ) ) == 0 ) and not ( n & 0x@@ AAAA@@ AAAA ) ) ; NEW_LINE DEDENT
COMP@@ UTE_@@ NC@@ R_@@ P@@ _SET_@@ 1_@@ INTRO@@ DUC@@ TION_@@ AND_@@ DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G_S@@ OL@@ U@@ TION | def n@@ Cr@@ Mod@@ p ( n , r , p ) : NEW_LINE INDENT C = [ 0 for i in range ( r + 1 ) ] NEW_LINE C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , r ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p NEW_LINE DEDENT DEDENT return C [ r ] NEW_LINE DEDENT
ROUND_@@ THE_@@ GI@@ V@@ EN_@@ NUMBER_@@ TO_@@ NEARE@@ ST_@@ MULTIPLE_@@ OF_@@ 10 | def round ( n ) : NEW_LINE INDENT a = ( n // 10 ) * 10 NEW_LINE b = a + 10 NEW_LINE return ( b if n - a > b - n else a ) NEW_LINE DEDENT
SORT_@@ EV@@ EN_@@ NUMB@@ ERS_@@ ASC@@ END@@ ING_@@ ORDER@@ _S@@ ORT_@@ OD@@ D_@@ NUMB@@ ERS_@@ DESC@@ END@@ ING_@@ ORDER_@@ 1 | def two@@ Way@@ Sort ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE DEDENT DEDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE DEDENT DEDENT DEDENT
POINT_@@ CLI@@ PP@@ ING_@@ ALGORITH@@ M_@@ COMP@@ UT@@ ER_@@ GRAPHIC@@ S | def point@@ Clip ( XY , n , X@@ min , Y@@ min , X@@ max , Y@@ max ) : NEW_LINE INDENT print ( " Point ▁ inside ▁ the ▁ view@@ ing ▁ pane : " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( XY [ i ] [ 0 ] >= X@@ min ) and ( XY [ i ] [ 0 ] <= X@@ max ) ) : NEW_LINE INDENT if ( ( XY [ i ] [ 1 ] >= Y@@ min ) and ( XY [ i ] [ 1 ] <= Y@@ max ) ) : NEW_LINE INDENT print ( " [ " , XY [ i ] [ 0 ] , " , ▁ " , XY [ i ] [ 1 ] , " ] " , sep = " " , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT print ( " \n \n Point ▁ outside ▁ the ▁ view@@ ing ▁ pane : " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( XY [ i ] [ 0 ] < X@@ min ) or ( XY [ i ] [ 0 ] > X@@ max ) ) : NEW_LINE INDENT print ( " [ " , XY [ i ] [ 0 ] , " , ▁ " , XY [ i ] [ 1 ] , " ] " , sep = " " , end = " ▁ " ) NEW_LINE DEDENT if ( ( XY [ i ] [ 1 ] < Y@@ min ) or ( XY [ i ] [ 1 ] > Y@@ max ) ) : NEW_LINE INDENT print ( " [ " , XY [ i ] [ 0 ] , " , ▁ " , XY [ i ] [ 1 ] , " ] " , sep = " " , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
WAY@@ S_@@ TRANS@@ FORM@@ ING_@@ ONE_@@ STRING_@@ REMO@@ V@@ ING_@@ 0_@@ CHARAC@@ TERS | def count@@ Transformation ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if m == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT if a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT elif a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT
FIND_@@ RELATIVE_@@ COMPLE@@ MENT_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S | def relative@@ Comp@@ lement ( ar@@ r1 , ar@@ r2 , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( ar@@ r1 [ i ] < ar@@ r2 [ j ] ) : NEW_LINE INDENT print ( ar@@ r1 [ i ] , " ▁ " , end = " " ) NEW_LINE i += 1 NEW_LINE DEDENT elif ( ar@@ r1 [ i ] > ar@@ r2 [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif ( ar@@ r1 [ i ] == ar@@ r2 [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < n ) : NEW_LINE INDENT print ( ar@@ r1 [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT
COUNT_@@ INDEX_@@ PAIR@@ S_@@ EQUAL_@@ ELEMEN@@ TS_@@ ARRAY | def count@@ Pairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
GI@@ V@@ EN_@@ AN_@@ ARRAY_@@ OF_@@ PAIR@@ S_@@ FIND_@@ ALL_@@ SYM@@ METRIC_@@ PAIR@@ S_IN_@@ IT | def find@@ Sym@@ Pairs ( arr , row ) : NEW_LINE INDENT h@@ M = dict ( ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT first = arr [ i ] [ 0 ] NEW_LINE sec = arr [ i ] [ 1 ] NEW_LINE if ( sec in h@@ M . keys ( ) and h@@ M [ sec ] == first ) : NEW_LINE INDENT print ( " ( " , sec , " , " , first , " ) " ) NEW_LINE DEDENT else : NEW_LINE INDENT h@@ M [ first ] = sec NEW_LINE DEDENT DEDENT DEDENT
COUNT_@@ SUB@@ SEQU@@ EN@@ CES_@@ PRODUCT_@@ LESS_@@ K | def product@@ Sub@@ Seq@@ Count ( arr , k ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE if arr [ j - 1 ] <= i and arr [ j - 1 ] > 0 : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i // arr [ j - 1 ] ] [ j - 1 ] + 1 NEW_LINE DEDENT DEDENT DEDENT return dp [ k ] [ n ] NEW_LINE DEDENT
RE@@ AR@@ RANGE_@@ ARRAY_@@ AR@@ RI@@ _@@ ARR@@ J_@@ EV@@ EN_@@ AR@@ RI | def re@@ arrange@@ Arr ( arr , n ) : NEW_LINE INDENT even@@ Pos = int ( n / 2 ) NEW_LINE odd@@ Pos = n - even@@ Pos NEW_LINE temp@@ Arr = np . empty ( n , dtype = object ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp@@ Arr [ i ] = arr [ i ] NEW_LINE DEDENT temp@@ Arr . sort ( ) NEW_LINE j = odd@@ Pos - 1 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT arr [ i ] = temp@@ Arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT j = odd@@ Pos NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT arr [ i ] = temp@@ Arr [ j ] NEW_LINE j = j + 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
MINIMUM_@@ ROTA@@ TIONS_@@ UN@@ LOCK_@@ CIRC@@ ULAR_@@ LOCK | def min@@ Rotation ( input , un@@ lock_@@ code ) : NEW_LINE INDENT rotation = 0 ; NEW_LINE while ( input > 0 or un@@ lock_@@ code > 0 ) : NEW_LINE INDENT input_@@ digit = input % 10 ; NEW_LINE code_@@ digit = un@@ lock_@@ code % 10 ; NEW_LINE rotation += min ( abs ( input_@@ digit - code_@@ digit ) , 10 - abs ( input_@@ digit - code_@@ digit ) ) ; NEW_LINE input = int ( input / 10 ) ; NEW_LINE un@@ lock_@@ code = int ( un@@ lock_@@ code / 10 ) ; NEW_LINE DEDENT return rotation ; NEW_LINE DEDENT
RE@@ AR@@ RANGE_@@ BINARY_@@ STRING_@@ ALTER@@ N@@ ATE_@@ X_@@ Y_@@ OC@@ CURR@@ EN@@ CES | def arrange@@ String ( str1 , x , y ) : NEW_LINE INDENT count_@@ 0 = 0 NEW_LINE count_@@ 1 = 0 NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str1 [ i ] == '0' : NEW_LINE INDENT count_@@ 0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_@@ 1 += 1 NEW_LINE DEDENT DEDENT while count_@@ 0 > 0 or count_@@ 1 > 0 : NEW_LINE INDENT for i in range ( 0 , x ) : NEW_LINE INDENT if count_@@ 0 > 0 : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE count_@@ 0 -= 1 NEW_LINE DEDENT DEDENT for j in range ( 0 , y ) : NEW_LINE INDENT if count_@@ 1 > 0 : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE count_@@ 1 -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 14_@@ MAX@@ IM@@ UM@@ _S@@ UM_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQUENCE | def max@@ Sum@@ IS ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE m@@ sis = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT m@@ sis [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and m@@ sis [ i ] < m@@ sis [ j ] + arr [ i ] ) : NEW_LINE INDENT m@@ sis [ i ] = m@@ sis [ j ] + arr [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if max < m@@ sis [ i ] : NEW_LINE INDENT max = m@@ sis [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
NUMBER_@@ UNI@@ QUE_@@ REC@@ TA@@ NG@@ LES_@@ FOR@@ MED_@@ USING_@@ N_@@ UNIT_@@ SQU@@ AR@@ ES | def count@@ Rect ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for length in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT height = length NEW_LINE while ( height * length <= n ) : NEW_LINE INDENT ans += 1 NEW_LINE height += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
PROGRAM_@@ TO_@@ PRINT_@@ TE@@ TRA@@ HE@@ DR@@ AL_@@ NUMB@@ ERS_@@ UP@@ TO_@@ N@@ TH_@@ TERM | def print@@ Series ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = i * ( i + 1 ) * ( i + 2 ) // 6 NEW_LINE print ( num , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
PROGRAM_@@ TO_@@ FIND_@@ TRANSP@@ OS@@ E_@@ OF_@@ A_@@ MATRIX | def transpose ( A , B ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT B [ i ] [ j ] = A [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT
PROGRAM_@@ DECIMAL_@@ BINARY_@@ CON@@ VERSION_@@ 1 | def dec@@ To@@ Binary ( n ) : NEW_LINE INDENT for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT k = n >> i ; NEW_LINE if ( k & 1 ) : NEW_LINE INDENT print ( "1" , end = " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT
RE@@ AR@@ RANGE_@@ ARRAY_@@ ORDER@@ _S@@ MAL@@ LE@@ ST_@@ LAR@@ GE@@ ST_@@ 2@@ N@@ D_S@@ MAL@@ LE@@ ST_@@ 2@@ N@@ D_@@ LAR@@ GE@@ ST | def re@@ arrange@@ Array ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE temp@@ Arr = [ 0 ] * ( n + 1 ) NEW_LINE Arr@@ Index = 0 NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i <= n // 2 or j > n // 2 ) : NEW_LINE INDENT temp@@ Arr [ Arr@@ Index ] = arr [ i ] NEW_LINE Arr@@ Index = Arr@@ Index + 1 NEW_LINE temp@@ Arr [ Arr@@ Index ] = arr [ j ] NEW_LINE Arr@@ Index = Arr@@ Index + 1 NEW_LINE i = i + 1 NEW_LINE j = j - 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = temp@@ Arr [ i ] NEW_LINE DEDENT DEDENT
S@@ UM_@@ AREA_@@ REC@@ TA@@ NG@@ LES_@@ POSSI@@ BLE_@@ ARRAY | def Max@@ Total@@ Rectangle@@ Area ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE sum = 0 NEW_LINE flag = False NEW_LINE len = 0 NEW_LINE i = 0 NEW_LINE while ( i < n - 1 ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == False ) : NEW_LINE INDENT flag = True NEW_LINE len = a [ i + 1 ] NEW_LINE i = i + 1 NEW_LINE DEDENT elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == True ) : NEW_LINE INDENT sum = sum + a [ i + 1 ] * len NEW_LINE flag = False NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
GI@@ V@@ EN_@@ BINARY_@@ STRING_@@ COUNT_@@ NUMBER@@ _SUB@@ STRING@@ S_@@ START_@@ END_@@ 1 | def count@@ Sub@@ Str ( st , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == '1' ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( st [ j ] == '1' ) : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 3@@ 1_@@ OP@@ TIM@@ AL_@@ STRATEG@@ Y_@@ FOR_@@ A_@@ GAME | def optim@@ al@@ Strategy@@ Of@@ Game ( arr , n ) : NEW_LINE INDENT table = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for gap in range ( n ) : NEW_LINE INDENT for j in range ( gap , n ) : NEW_LINE INDENT i = j - gap NEW_LINE x = 0 NEW_LINE if ( ( i + 2 ) <= j ) : NEW_LINE INDENT x = table [ i + 2 ] [ j ] NEW_LINE DEDENT y = 0 NEW_LINE if ( ( i + 1 ) <= ( j - 1 ) ) : NEW_LINE INDENT y = table [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT z = 0 NEW_LINE if ( i <= ( j - 2 ) ) : NEW_LINE INDENT z = table [ i ] [ j - 2 ] NEW_LINE DEDENT table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) NEW_LINE DEDENT DEDENT return table [ 0 ] [ n - 1 ] NEW_LINE DEDENT
REPL@@ ACE_@@ CHARACTER_@@ C@@ 1_@@ C@@ 2_@@ C@@ 2_@@ C@@ 1_@@ STRING_@@ S | def replace ( s , c1 , c2 ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] == c1 ) : NEW_LINE INDENT s = s [ 0 : i ] + c2 + s [ i + 1 : ] NEW_LINE DEDENT elif ( s [ i ] == c2 ) : NEW_LINE INDENT s = s [ 0 : i ] + c1 + s [ i + 1 : ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
FIND_@@ THE_@@ LAR@@ GE@@ ST@@ _SUB@@ ARRAY_@@ WITH_@@ 0@@ _S@@ UM@@ _1 | def maxLen ( arr ) : NEW_LINE INDENT hash_@@ map = { } NEW_LINE max_len = 0 NEW_LINE curr_@@ sum = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT curr_@@ sum += arr [ i ] NEW_LINE if arr [ i ] is 0 and max_len is 0 : NEW_LINE INDENT max_len = 1 NEW_LINE DEDENT if curr_@@ sum is 0 : NEW_LINE INDENT max_len = i + 1 NEW_LINE DEDENT if curr_@@ sum in hash_@@ map : NEW_LINE INDENT max_len = max ( max_len , i - hash_@@ map [ curr_@@ sum ] ) NEW_LINE DEDENT else : NEW_LINE INDENT hash_@@ map [ curr_@@ sum ] = i NEW_LINE DEDENT DEDENT return max_len NEW_LINE DEDENT
PROGRAM_@@ PRINT_@@ S@@ UM_@@ GI@@ V@@ EN_@@ N@@ TH_@@ TER@@ M_@@ 1 | def summ@@ ing@@ Series ( n ) : NEW_LINE INDENT return math . pow ( n , 2 ) NEW_LINE DEDENT
RECUR@@ SIVE_@@ C_@@ PROGRAM_@@ LINE@@ AR@@ LY@@ _SEARCH_@@ ELEMENT_@@ GI@@ V@@ EN_@@ ARRAY | def rec@@ Search ( arr , l , r , x ) : NEW_LINE INDENT if r < l : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if arr [ l ] == x : NEW_LINE INDENT return l NEW_LINE DEDENT if arr [ r ] == x : NEW_LINE INDENT return r NEW_LINE DEDENT return rec@@ Search ( arr , l + 1 , r - 1 , x ) NEW_LINE DEDENT
PRINT_@@ SHOR@@ TEST_@@ PATH_@@ PRINT_@@ STRING@@ _S@@ CRE@@ EN | def print@@ Path ( str ) : NEW_LINE INDENT i = 0 NEW_LINE cur@@ X = 0 NEW_LINE cur@@ Y = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT next@@ X = int ( ( ord ( str [ i ] ) - ord ( ' A ' ) ) / 5 ) NEW_LINE next@@ Y = ( ord ( str [ i ] ) - ord ( ' B ' ) + 1 ) % 5 NEW_LINE while ( cur@@ X > next@@ X ) : NEW_LINE INDENT print ( " Move ▁ Up " ) NEW_LINE cur@@ X -= 1 NEW_LINE DEDENT while ( cur@@ Y > next@@ Y ) : NEW_LINE INDENT print ( " Move ▁ Left " ) NEW_LINE cur@@ Y -= 1 NEW_LINE DEDENT while ( cur@@ X < next@@ X ) : NEW_LINE INDENT print ( " Move ▁ Down " ) NEW_LINE cur@@ X += 1 NEW_LINE DEDENT while ( cur@@ Y < next@@ Y ) : NEW_LINE INDENT print ( " Move ▁ Right " ) NEW_LINE cur@@ Y += 1 NEW_LINE DEDENT print ( " Press ▁ OK " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
COUNT_@@ EN@@ TRI@@ ES_@@ EQUAL_@@ TO_@@ X_@@ IN_@@ A@@ _SPECI@@ AL_@@ MATRIX | def count ( n , x ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i <= x : NEW_LINE INDENT if x // i <= n and x % i == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
PROGRAM_@@ FIND_@@ LINE_@@ PASS@@ ING_@@ 2_@@ POINTS | def line@@ From@@ Points ( P , Q ) : NEW_LINE INDENT a = Q [ 1 ] - P [ 1 ] NEW_LINE b = P [ 0 ] - Q [ 0 ] NEW_LINE c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) NEW_LINE if ( b < 0 ) : NEW_LINE INDENT print ( " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : " , a , " x ▁ " , b , " y ▁ = ▁ " , c , " \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ " , a , " x ▁ + ▁ " , b , " y ▁ = ▁ " , c , " \n " ) NEW_LINE DEDENT DEDENT
REMOVE_@@ ARRAY_@@ END_@@ ELEMENT_@@ MAXI@@ MI@@ ZE_@@ S@@ UM_@@ PRODUCT | def solve ( dp , a , low , high , turn ) : NEW_LINE INDENT if ( low == high ) : NEW_LINE INDENT return a [ low ] * turn NEW_LINE DEDENT if ( dp [ low ] [ high ] != 0 ) : NEW_LINE INDENT return dp [ low ] [ high ] NEW_LINE DEDENT dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; NEW_LINE return dp [ low ] [ high ] NEW_LINE DEDENT
CHECK_@@ GRAP@@ H@@ S_@@ CY@@ CLE_@@ OD@@ D_@@ LENGTH | def contains@@ Odd ( G , src ) : NEW_LINE INDENT global V NEW_LINE color@@ Arr = [ - 1 ] * V NEW_LINE color@@ Arr [ src ] = 1 NEW_LINE q = queue . Queue ( ) NEW_LINE q . put ( src ) NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT u = q . get ( ) NEW_LINE if ( G [ u ] [ u ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for v in range ( V ) : NEW_LINE INDENT if ( G [ u ] [ v ] and color@@ Arr [ v ] == - 1 ) : NEW_LINE INDENT color@@ Arr [ v ] = 1 - color@@ Arr [ u ] NEW_LINE q . put ( v ) NEW_LINE DEDENT elif ( G [ u ] [ v ] and color@@ Arr [ v ] == color@@ Arr [ u ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
SUM@@ _SERI@@ ES_@@ ALTER@@ N@@ ATE_@@ SIGNE@@ D_S@@ QUAR@@ ES_@@ AP | def se@@ i@@ res@@ Sum ( n , a ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , 2 * n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res += a [ i ] * a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT res -= a [ i ] * a [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
PROGRAM_@@ DECIMAL_@@ BINARY_@@ CONVERSION | def dec@@ To@@ Binary ( n ) : NEW_LINE INDENT binary@@ Num = [ 0 ] * n ; NEW_LINE i = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binary@@ Num [ i ] = n % 2 ; NEW_LINE n = int ( n / 2 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( binary@@ Num [ j ] , end = " " ) ; NEW_LINE DEDENT DEDENT
LON@@ GE@@ ST_@@ ALTER@@ N@@ ATING_@@ POSITIVE_@@ NEGATIVE_@@ SUB@@ ARRAY_@@ START@@ ING_@@ EVER@@ Y_@@ INDEX | def lon@@ gest@@ Altern@@ ating ( arr , n ) : NEW_LINE INDENT count = [ None ] * n NEW_LINE count [ n - 1 ] = 1 NEW_LINE i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( arr [ i ] * arr [ i + 1 ] < 0 ) : NEW_LINE INDENT count [ i ] = count [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 1 ; NEW_LINE DEDENT i = i - 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT print ( count [ i ] , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT
FIND_@@ STRING_@@ LE@@ XI@@ CO@@ GRAP@@ HI@@ C_@@ ORDER_@@ GI@@ V@@ EN_@@ TWO_@@ STRINGS | def lex@@ Next ( s , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] != ' z ' : NEW_LINE INDENT k = ord ( s [ i ] ) NEW_LINE s [ i ] = chr ( k + 1 ) NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT s [ i ] = ' a ' NEW_LINE DEDENT DEDENT
NUMBER_@@ DECIMAL_@@ NUMB@@ ERS_@@ LENGTH_@@ K_@@ STRICT_@@ MON@@ OT@@ ONE | def getNum@@ Strict@@ Mon@@ ot@@ one ( ln ) : NEW_LINE INDENT DP = [ [ 0 ] * D@@ P_@@ s for _ in range ( ln ) ] NEW_LINE for i in range ( D@@ P_@@ s ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i + 1 NEW_LINE DEDENT for i in range ( 1 , ln ) : NEW_LINE INDENT for j in range ( 1 , D@@ P_@@ s ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return DP [ ln - 1 ] [ D@@ P_@@ s - 1 ] NEW_LINE DEDENT
PRINT_@@ POSSI@@ BLE_@@ ED@@ GE@@ S_@@ TREE_@@ GI@@ V@@ EN_@@ DI@@ AME@@ TER_@@ HEIGHT_@@ VER@@ TIC@@ ES | def construct@@ Tree ( n , d , h ) : NEW_LINE INDENT if d == 1 : NEW_LINE INDENT if n == 2 and h == 1 : NEW_LINE INDENT print ( "1 ▁ 2" ) NEW_LINE return 0 NEW_LINE DEDENT print ( " - 1" ) NEW_LINE return 0 NEW_LINE DEDENT if d > 2 * h : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return 0 NEW_LINE DEDENT for i in range ( 1 , h + 1 ) : NEW_LINE INDENT print ( i , " ▁ " , i + 1 ) NEW_LINE DEDENT if d > h : NEW_LINE INDENT print ( 1 , " ▁ ▁ " , h + 2 ) NEW_LINE for i in range ( h + 2 , d + 1 ) : NEW_LINE INDENT print ( i , " ▁ " , i + 1 ) NEW_LINE DEDENT DEDENT for i in range ( d + 1 , n ) : NEW_LINE INDENT k = 1 NEW_LINE if d == h : NEW_LINE INDENT k = 2 NEW_LINE DEDENT print ( k , " ▁ " , i + 1 ) NEW_LINE DEDENT DEDENT
MIN@@ IM@@ AL_@@ OPER@@ ATION@@ S_@@ MAKE_@@ NUMBER_@@ MAG@@ ICAL | def calculate ( s ) : NEW_LINE INDENT ans = 6 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT for k in range ( 10 ) : NEW_LINE INDENT for l in range ( 10 ) : NEW_LINE INDENT for m in range ( 10 ) : NEW_LINE INDENT for n in range ( 10 ) : NEW_LINE INDENT if ( i + j + k == l + m + n ) : NEW_LINE INDENT c = 0 NEW_LINE if ( i != ord ( s [ 0 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( j != ord ( s [ 1 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( k != ord ( s [ 2 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( l != ord ( s [ 3 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( m != ord ( s [ 4 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( n != ord ( s [ 5 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( c < ans ) : NEW_LINE INDENT ans = c NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
FIND_@@ A_@@ TR@@ IP@@ LET_@@ TH@@ AT_@@ S@@ UM_@@ TO_@@ A_@@ GI@@ V@@ EN_@@ VALUE | def find@@ 3@@ Numbers ( A , arr_@@ size , sum ) : NEW_LINE INDENT for i in range ( 0 , arr_@@ size - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , arr_@@ size - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , arr_@@ size ) : NEW_LINE INDENT if A [ i ] + A [ j ] + A [ k ] == sum : NEW_LINE INDENT print ( " Trip@@ let ▁ is " , A [ i ] , " , ▁ " , A [ j ] , " , ▁ " , A [ k ] ) NEW_LINE return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
AREA_@@ OF_THE_@@ CI@@ R@@ CLE_@@ TH@@ AT_@@ HAS_@@ A@@ _S@@ QU@@ ARE_@@ AND_@@ A_@@ CI@@ R@@ CLE_@@ IN@@ SCRI@@ BED_@@ IN_@@ IT | def get@@ Area ( a ) : NEW_LINE INDENT area = ( math . pi * a * a ) / 4 NEW_LINE return area NEW_LINE DEDENT
GI@@ V@@ EN_@@ TWO_@@ UN@@ SOR@@ TED_@@ ARRAY@@ S_@@ FIND_@@ PAIR@@ S_@@ WHO@@ SE_@@ S@@ UM_@@ X_@@ 1 | def find@@ Pairs ( ar@@ r1 , ar@@ r2 , n , m , x ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s . add ( ar@@ r1 [ i ] ) NEW_LINE DEDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( ( x - ar@@ r2 [ j ] ) in s ) : NEW_LINE INDENT print ( ( x - ar@@ r2 [ j ] ) , ' ' , ar@@ r2 [ j ] ) NEW_LINE DEDENT DEDENT DEDENT
QU@@ IC@@ K_@@ WA@@ Y_@@ CHECK_@@ CHARAC@@ TER@@ S_@@ STRING | def all@@ Characters@@ Same ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] != s [ 0 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
RE@@ AR@@ RANGE_@@ ARRAY_@@ AR@@ RI | def fix ( A , len ) : NEW_LINE INDENT for i in range ( 0 , len ) : NEW_LINE INDENT if ( A [ i ] != - 1 and A [ i ] != i ) : NEW_LINE INDENT x = A [ i ] ; NEW_LINE while ( A [ x ] != - 1 and A [ x ] != x ) : NEW_LINE INDENT y = A [ x ] NEW_LINE A [ x ] = x NEW_LINE x = y NEW_LINE DEDENT A [ x ] = x ; NEW_LINE if ( A [ i ] != i ) : NEW_LINE INDENT A [ i ] = - 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT
PA@@ IR_@@ WITH_@@ GI@@ V@@ EN_@@ PRODUCT_@@ SET_@@ 1_@@ FIND_@@ IF_@@ ANY_@@ PA@@ IR_@@ EXISTS | def is@@ Product ( arr , n , x ) : NEW_LINE INDENT for i in arr : NEW_LINE INDENT for j in arr : NEW_LINE INDENT if i * j == x : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
SORT_@@ GI@@ V@@ EN_@@ STRING_@@ USING_@@ CHARAC@@ TER@@ _SEARCH | def sort@@ String ( str , n ) : NEW_LINE INDENT new_@@ str = " " NEW_LINE for i in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( str [ j ] == chr ( i ) ) : NEW_LINE INDENT new_@@ str += str [ j ] NEW_LINE DEDENT DEDENT DEDENT return new_@@ str NEW_LINE DEDENT
COUNT_@@ OF_@@ OC@@ CURR@@ EN@@ CES_@@ OF_@@ A_@@ 101@@ _@@ PATTERN_@@ IN_@@ A_@@ STRING | def count@@ Pattern ( s ) : NEW_LINE INDENT length = len ( s ) NEW_LINE one@@ Seen = False NEW_LINE count = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( s [ i ] == '1' and one@@ Seen ) : NEW_LINE INDENT if ( s [ i - 1 ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( s [ i ] == '1' and one@@ Seen == 0 ) : NEW_LINE INDENT one@@ Seen = True NEW_LINE DEDENT if ( s [ i ] != '0' and s [ i ] != '1' ) : NEW_LINE INDENT one@@ Seen = False NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
C_@@ PROGRAM_@@ CY@@ CLIC@@ AL@@ LY_@@ ROTA@@ TE_@@ ARRAY_@@ ONE | def rotate ( arr , n ) : NEW_LINE INDENT x = arr [ n - 1 ] NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] ; NEW_LINE DEDENT arr [ 0 ] = x ; NEW_LINE DEDENT
QUEUE_@@ BAS@@ ED_@@ APPRO@@ ACH@@ _@@ FOR_@@ FIRST_@@ NON_@@ REPE@@ ATING_@@ CHARACTER_@@ IN_@@ A_@@ STREAM | def first@@ non@@ repe@@ ating ( Str ) : NEW_LINE INDENT global MAX_@@ CHAR NEW_LINE q = Queue ( ) NEW_LINE char@@ Count = [ 0 ] * MAX_@@ CHAR NEW_LINE for i in range ( len ( Str ) ) : NEW_LINE INDENT q . put ( Str [ i ] ) NEW_LINE char@@ Count [ ord ( Str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT if ( char@@ Count [ ord ( q . queue [ 0 ] ) - ord ( ' a ' ) ] > 1 ) : NEW_LINE INDENT q . get ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( q . queue [ 0 ] , end = " ▁ " ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( q . empty ( ) ) : NEW_LINE INDENT print ( - 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
CHECK_@@ LARGE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 6_@@ NOT | def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( ( ( int ) ( st [ n - 1 ] ) % 2 ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT digit@@ Sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digit@@ Sum = digit@@ Sum + ( int ) ( st [ i ] ) NEW_LINE DEDENT return ( digit@@ Sum % 3 == 0 ) NEW_LINE DEDENT
MINIMUM_@@ NUMBER_@@ OF@@ _S@@ QUAR@@ ES_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL@@ S_TO_@@ GI@@ V@@ EN_@@ NUMBER_@@ N | def getMin@@ Squ@@ ares ( n ) : NEW_LINE INDENT if n <= 3 : NEW_LINE INDENT return n ; NEW_LINE DEDENT res = n NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = x * x ; NEW_LINE if temp > n : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = min ( res , 1 + getMin@@ Squ@@ ares ( n - temp ) ) NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT
OVER@@ L@@ APP@@ ING_S@@ UM_@@ TWO_@@ ARRAY | def find@@ Sum ( A , B , n ) : NEW_LINE INDENT Hash = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Hash [ A [ i ] ] += 1 NEW_LINE Hash [ B [ i ] ] += 1 NEW_LINE DEDENT Sum = 0 NEW_LINE for x in Hash : NEW_LINE INDENT if Hash [ x ] == 1 : NEW_LINE INDENT Sum += x NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT
MOBI@@ LE_@@ NUMERIC_@@ KEY@@ PAD_@@ PRO@@ BLE@@ M | def getCount ( keyp@@ ad , n ) : NEW_LINE INDENT if ( not keyp@@ ad or n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT odd = [ 0 ] * 10 NEW_LINE even = [ 0 ] * 10 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE use@@ Odd = 0 NEW_LINE totalCount = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT odd [ i ] = 1 NEW_LINE DEDENT for j in range ( 2 , n + 1 ) : NEW_LINE INDENT use@@ Odd = 1 - use@@ Odd NEW_LINE if ( use@@ Odd == 1 ) : NEW_LINE INDENT even [ 0 ] = odd [ 0 ] + odd [ 8 ] NEW_LINE even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] NEW_LINE even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] NEW_LINE even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] NEW_LINE even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] NEW_LINE even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] NEW_LINE even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] NEW_LINE even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] NEW_LINE even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] NEW_LINE even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] NEW_LINE DEDENT else : NEW_LINE INDENT odd [ 0 ] = even [ 0 ] + even [ 8 ] NEW_LINE odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] NEW_LINE odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] NEW_LINE odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] NEW_LINE odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] NEW_LINE odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] NEW_LINE odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] NEW_LINE odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] NEW_LINE odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] NEW_LINE odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] NEW_LINE DEDENT DEDENT totalCount = 0 NEW_LINE if ( use@@ Odd == 1 ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT totalCount += even [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT totalCount += odd [ i ] NEW_LINE DEDENT DEDENT return totalCount NEW_LINE DEDENT
FIND_@@ ELEMEN@@ TS_@@ L@@ ARG@@ ER_@@ HALF_@@ ELEMEN@@ TS_@@ ARRAY | def find@@ Lar@@ ger ( arr , n ) : NEW_LINE INDENT x = sorted ( arr ) NEW_LINE for i in range ( n / 2 , n ) : NEW_LINE INDENT print ( x [ i ] ) , NEW_LINE DEDENT DEDENT
S@@ UM_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENTS | def bin@@ omi@@ al@@ Coeff@@ Sum ( n ) : NEW_LINE INDENT C = [ [ 0 ] * ( n + 2 ) for i in range ( 0 , n + 2 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT sum += C [ n ] [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
FIND_@@ COMMON_@@ ELEMENT_@@ RO@@ WS_@@ ROW_@@ WI@@ SE_@@ SOR@@ TED_@@ MATRIX_@@ 1 | def find@@ Common ( mat ) : NEW_LINE INDENT global M NEW_LINE global N NEW_LINE cnt = dict ( ) NEW_LINE cnt = defaultdict ( lambda : 0 , cnt ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < M ) : NEW_LINE INDENT cnt [ mat [ i ] [ 0 ] ] = cnt [ mat [ i ] [ 0 ] ] + 1 NEW_LINE j = 1 NEW_LINE while ( j < N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) : NEW_LINE INDENT cnt [ mat [ i ] [ j ] ] = cnt [ mat [ i ] [ j ] ] + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT for ele in cnt : NEW_LINE INDENT if ( cnt [ ele ] == M ) : NEW_LINE INDENT return ele NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
SI@@ EV@@ E_@@ ER@@ ATO@@ ST@@ HE@@ NE@@ S_@@ 0@@ N_@@ TIME_@@ COMPLE@@ X@@ ITY | def manipul@@ ated_@@ se@@ ive ( N ) : NEW_LINE INDENT i@@ spri@@ me [ 0 ] = i@@ spri@@ me [ 1 ] = False NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if i@@ spri@@ me [ i ] == True : NEW_LINE INDENT prime . append ( i ) NEW_LINE SP@@ F [ i ] = i NEW_LINE DEDENT j = 0 NEW_LINE while ( j < len ( prime ) and i * prime [ j ] < N and prime [ j ] <= SP@@ F [ i ] ) : NEW_LINE INDENT i@@ spri@@ me [ i * prime [ j ] ] = False NEW_LINE SP@@ F [ i * prime [ j ] ] = prime [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT
COUNT_@@ SOR@@ TED_@@ RO@@ WS_@@ MATRIX | def sorted@@ Count ( mat , r , c ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( c - 1 ) : NEW_LINE INDENT if mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == c - 2 : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , r ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( c - 1 , 0 , - 1 ) : NEW_LINE INDENT if mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if c > 1 and j == 1 : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
NUMBER_@@ WAY@@ S_@@ NODE_@@ MAKE_@@ LOOP@@ _SIZE_@@ K_@@ UN@@ DIREC@@ TED_@@ COMPLETE_@@ CONNEC@@ TED_@@ GRAPH_@@ N_@@ NODES | def numOf@@ ways ( n , k ) : NEW_LINE INDENT p = 1 NEW_LINE if ( k % 2 ) : NEW_LINE INDENT p = - 1 NEW_LINE DEDENT return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n NEW_LINE DEDENT
DI@@ CE_@@ THROW_@@ PRO@@ BLE@@ M | def find@@ W@@ ays ( m , n , x ) : NEW_LINE INDENT table = [ [ 0 ] * ( x + 1 ) for i in range ( n + 1 ) ] NEW_LINE for j in range ( 1 , min ( m + 1 , x + 1 ) ) : NEW_LINE INDENT table [ 1 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , x + 1 ) : NEW_LINE INDENT for k in range ( 1 , min ( m + 1 , j ) ) : NEW_LINE INDENT table [ i ] [ j ] += table [ i - 1 ] [ j - k ] NEW_LINE DEDENT DEDENT DEDENT return table [ - 1 ] [ - 1 ] NEW_LINE DEDENT
MINIMUM_@@ NUMBER_@@ DELE@@ TIONS_@@ MAKE_@@ STRING_@@ PA@@ LIN@@ DRO@@ ME_@@ SET_@@ 2 | def get@@ Lev@@ en@@ stein ( in@@ pt ) : NEW_LINE INDENT rev@@ Input = in@@ pt [ : : - 1 ] NEW_LINE n = len ( in@@ pt ) NEW_LINE dp = [ [ - 1 for _ in range ( n + 1 ) ] for __ in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = i NEW_LINE dp [ i ] [ 0 ] = i NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if in@@ pt [ i - 1 ] == rev@@ Input [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT res = INT_MAX NEW_LINE i , j = n , 0 NEW_LINE while i >= 0 : NEW_LINE INDENT res = min ( res , dp [ i ] [ j ] ) NEW_LINE if i < n : NEW_LINE INDENT res = min ( res , dp [ i + 1 ] [ j ] ) NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT res = min ( res , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT i -= 1 NEW_LINE j += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 37@@ _@@ BOOLEAN_@@ PARENTHE@@ SIZ@@ ATION_@@ PRO@@ BLE@@ M | def count@@ Paren@@ th ( sym@@ b , oper , n ) : NEW_LINE INDENT F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if sym@@ b [ i ] == ' F ' : NEW_LINE INDENT F [ i ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT F [ i ] [ i ] = 0 NEW_LINE DEDENT if sym@@ b [ i ] == ' T ' : NEW_LINE INDENT T [ i ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT T [ i ] [ i ] = 0 NEW_LINE DEDENT DEDENT for gap in range ( 1 , n ) : NEW_LINE INDENT i = 0 NEW_LINE for j in range ( gap , n ) : NEW_LINE INDENT T [ i ] [ j ] = F [ i ] [ j ] = 0 NEW_LINE for g in range ( gap ) : NEW_LINE INDENT k = i + g NEW_LINE ti@@ k = T [ i ] [ k ] + F [ i ] [ k ] ; NEW_LINE tk@@ j = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ; NEW_LINE if oper [ k ] == ' & ' : NEW_LINE INDENT T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] NEW_LINE F [ i ] [ j ] += ( ti@@ k * tk@@ j - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) NEW_LINE DEDENT if oper [ k ] == ' | ' : NEW_LINE INDENT F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] NEW_LINE T [ i ] [ j ] += ( ti@@ k * tk@@ j - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) NEW_LINE DEDENT if oper [ k ] == ' ^ ' : NEW_LINE INDENT T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ) NEW_LINE F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT return T [ 0 ] [ n - 1 ] NEW_LINE DEDENT
PYTHON_@@ PROGRAM_@@ FIND_@@ PER@@ I@@ ME@@ TER_@@ CIRCUM@@ FER@@ ENCE_@@ SQU@@ ARE_@@ REC@@ TAN@@ GLE_@@ 1 | def Cir@@ cum@@ ference ( l , w ) : NEW_LINE INDENT return ( 2 * ( l + w ) ) NEW_LINE DEDENT
THIR@@ D_@@ LAR@@ GE@@ ST_@@ ELEMENT_@@ ARRAY_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ 1 | def third@@ Lar@@ gest ( arr , arr_@@ size ) : NEW_LINE INDENT if ( arr_@@ size < 3 ) : NEW_LINE INDENT print ( " ▁ Invalid ▁ Input ▁ " ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE second = - sys . maxsize NEW_LINE third = - sys . maxsize NEW_LINE for i in range ( 1 , arr_@@ size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT third = second NEW_LINE second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT third = second NEW_LINE second = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > third ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ third ▁ Lar@@ gest " , " element ▁ is " , third ) NEW_LINE DEDENT
MINIMUM_@@ ROO@@ MS_@@ FOR_@@ M_@@ EV@@ ENTS_@@ OF_@@ N_@@ BAT@@ CHE@@ S_@@ WITH_@@ GI@@ VEN@@ _SCH@@ EDUL@@ E | def find@@ Min@@ Roo@@ ms ( slots , n , m ) : NEW_LINE INDENT counts = [ 0 ] * m ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( slots [ i ] [ j ] == '1' ) : NEW_LINE INDENT counts [ j ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT return max ( counts ) ; NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SUB@@ SET_@@ S@@ UM_@@ PRO@@ BLE@@ M | def isSub@@ set@@ Sum ( set , n , sum ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 0 and sum != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( set [ n - 1 ] > sum ) : NEW_LINE INDENT return isSub@@ set@@ Sum ( set , n - 1 , sum ) ; NEW_LINE DEDENT return isSub@@ set@@ Sum ( set , n - 1 , sum ) or isSub@@ set@@ Sum ( set , n - 1 , sum - set [ n - 1 ] ) NEW_LINE DEDENT
COUNT_@@ WAY@@ S_@@ DI@@ VI@@ DE_@@ CI@@ R@@ CLE_@@ USING_@@ N_@@ NON_@@ INTER@@ SEC@@ TING_@@ CH@@ OR@@ DS | def ch@@ ord@@ Cnt ( A ) : NEW_LINE INDENT n = 2 * A NEW_LINE dp@@ Array = [ 0 ] * ( n + 1 ) NEW_LINE dp@@ Array [ 0 ] = 1 NEW_LINE dp@@ Array [ 2 ] = 1 NEW_LINE for i in range ( 4 , n + 1 , 2 ) : NEW_LINE INDENT for j in range ( 0 , i - 1 , 2 ) : NEW_LINE INDENT dp@@ Array [ i ] += ( dp@@ Array [ j ] * dp@@ Array [ i - 2 - j ] ) NEW_LINE DEDENT DEDENT return int ( dp@@ Array [ n ] ) NEW_LINE DEDENT
BREAK_@@ NUMBER_@@ THRE@@ E_@@ PAR@@ TS_@@ 1 | def count_@@ of_@@ ways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE count = ( n + 1 ) * ( n + 2 ) // 2 NEW_LINE return count NEW_LINE DEDENT
PRINT_@@ DIG@@ IT@@ S_@@ POSITION_@@ REMO@@ VED_@@ MAKE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 6 | def gre@@ atest ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE a = [ 0 for i in range ( n ) ] NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE Sum += a [ i ] NEW_LINE DEDENT if ( a [ n - 1 ] % 2 ) : NEW_LINE INDENT if ( a [ n - 2 ] % 2 != 0 or ( Sum - a [ n - 1 ] ) % 3 != 0 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT re = Sum % 3 NEW_LINE del@@ l = - 1 NEW_LINE flag = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( ( a [ i ] ) % 3 == re ) : NEW_LINE INDENT if ( a [ i + 1 ] > a [ i ] ) : NEW_LINE INDENT del@@ l = i NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT del@@ l = i NEW_LINE DEDENT DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT if ( a [ n - 2 ] % 2 == 0 and re == a [ n - 1 ] % 3 ) : NEW_LINE INDENT del@@ l = n - 1 NEW_LINE DEDENT DEDENT if ( del@@ l == - 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( del@@ l + 1 ) NEW_LINE DEDENT DEDENT DEDENT
MAXIMUM_@@ HEIGHT_@@ OF_@@ TRIANG@@ ULAR_@@ AR@@ RANGE@@ MENT_@@ OF_@@ ARRAY_@@ VALUES | def Maximum@@ Height ( a , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT y = ( i * ( i + 1 ) ) / 2 NEW_LINE if ( y < n ) : NEW_LINE INDENT result = i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
SQU@@ AR@@ ED_@@ TRIANG@@ ULAR_@@ NUMBER@@ _S@@ UM_@@ CU@@ B@@ ES | def find@@ S ( s ) : NEW_LINE INDENT _@@ sum = 0 NEW_LINE n = 1 NEW_LINE while ( _@@ sum < s ) : NEW_LINE INDENT _@@ sum += n * n * n NEW_LINE n += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if _@@ sum == s : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
EVALU@@ ATE_@@ A_@@ BOOLEAN_@@ EXPRES@@ SION_@@ RE@@ PRESEN@@ TED_@@ AS_@@ STRING | def evaluate@@ Bool@@ Expr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 0 , n - 2 , 2 ) : NEW_LINE INDENT if ( s [ i + 1 ] == " A " ) : NEW_LINE INDENT if ( s [ i + 2 ] == "0" or s [ i ] == "0" ) : NEW_LINE INDENT s [ i + 2 ] = "0" NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = "1" NEW_LINE DEDENT DEDENT elif ( s [ i + 1 ] == " B " ) : NEW_LINE INDENT if ( s [ i + 2 ] == "1" or s [ i ] == "1" ) : NEW_LINE INDENT s [ i + 2 ] = "1" NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = "0" NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( s [ i + 2 ] == s [ i ] ) : NEW_LINE INDENT s [ i + 2 ] = "0" NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = "1" NEW_LINE DEDENT DEDENT DEDENT return ord ( s [ n - 1 ] ) - ord ( "0" ) NEW_LINE DEDENT
PROGR@@ AM@@ M@@ ING_@@ PU@@ ZZ@@ LE_@@ ASSIGN_@@ VALUE_@@ WITH@@ OUT_@@ CONTROL_@@ STATEMENT | def assign@@ Value ( a , b , x ) : NEW_LINE INDENT arr = [ a , b ] NEW_LINE return ( arr [ x ] ) NEW_LINE DEDENT
MIN@@ IM@@ UM@@ _S@@ UM@@ _S@@ QUAR@@ ES_@@ CHARAC@@ TER@@ S_@@ COUN@@ TS_@@ GI@@ V@@ EN_@@ STRING_@@ REMO@@ V@@ ING_@@ K_@@ CHARAC@@ TERS | def min@@ StringValue ( str , k ) : NEW_LINE INDENT l = len ( str ) NEW_LINE if ( k >= l ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT frequency = [ 0 ] * MAX_@@ CHAR NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT frequency [ ord ( str [ i ] ) - 97 ] += 1 NEW_LINE DEDENT q = PriorityQueue ( ) NEW_LINE for i in range ( 0 , MAX_@@ CHAR ) : NEW_LINE INDENT q . put ( - frequency [ i ] ) NEW_LINE DEDENT while ( k > 0 ) : NEW_LINE INDENT temp = q . get ( ) NEW_LINE temp = temp + 1 NEW_LINE q . put ( temp , temp ) NEW_LINE k = k - 1 NEW_LINE DEDENT result = 0 ; NEW_LINE while not q . empty ( ) : NEW_LINE INDENT temp = q . get ( ) NEW_LINE temp = temp * ( - 1 ) NEW_LINE result += temp * temp NEW_LINE DEDENT return result NEW_LINE DEDENT
MAJ@@ ORI@@ TY_@@ ELEMENT_@@ 1 | def find@@ Maj@@ ority ( arr , size ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] in m : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for key in m : NEW_LINE INDENT if m [ key ] > size / 2 : NEW_LINE INDENT count = 1 NEW_LINE print ( " Maj@@ ority ▁ found ▁ : - " , key ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT print ( " No ▁ Maj@@ ority ▁ element " ) NEW_LINE DEDENT DEDENT
LAR@@ GE@@ ST@@ _SUB@@ SET_@@ GRAPH_@@ VER@@ TIC@@ ES_@@ ED@@ GE@@ S_@@ 2_@@ COLORS | def sub@@ set@@ Graph ( C ) : NEW_LINE INDENT global N NEW_LINE vertices = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT vertices . add ( i ) NEW_LINE DEDENT while ( len ( vertices ) != 0 ) : NEW_LINE INDENT if ( len ( vertices ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT some@@ one_@@ removed = False NEW_LINE for x in vertices : NEW_LINE INDENT values = set ( ) NEW_LINE for y in vertices : NEW_LINE INDENT if ( y != x ) : NEW_LINE INDENT values . add ( C [ x ] [ y ] ) NEW_LINE DEDENT DEDENT if ( len ( values ) == 1 ) : NEW_LINE INDENT vertices . remove ( x ) NEW_LINE some@@ one_@@ removed = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not some@@ one_@@ removed ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return len ( vertices ) NEW_LINE DEDENT
FLO@@ OR_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY_@@ 1 | def floor@@ Search ( arr , low , high , x ) : NEW_LINE INDENT if ( low > high ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( x >= arr [ high ] ) : NEW_LINE INDENT return high NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] ) : NEW_LINE INDENT return mid - 1 NEW_LINE DEDENT if ( x < arr [ mid ] ) : NEW_LINE INDENT return floor@@ Search ( arr , low , mid - 1 , x ) NEW_LINE DEDENT return floor@@ Search ( arr , mid + 1 , high , x ) NEW_LINE DEDENT
LON@@ GE@@ ST_@@ PREFIX_@@ AL@@ SO@@ _SU@@ F@@ FIX_@@ 1 | def lon@@ gest@@ Prefix@@ Suffix ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE l@@ ps = [ 0 ] * n NEW_LINE l = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ l ] ) : NEW_LINE INDENT l = l + 1 NEW_LINE l@@ ps [ i ] = l NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( l != 0 ) : NEW_LINE INDENT l = l@@ ps [ l - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT l@@ ps [ i ] = 0 NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT DEDENT res = l@@ ps [ n - 1 ] NEW_LINE if ( res > n / 2 ) : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT
COUNT_@@ NUMBER_OF_@@ WAY@@ S_TO_@@ PARTITION_@@ A@@ _SET_@@ IN@@ TO_@@ K@@ _SUB@@ SETS | def count@@ P ( n , k ) : NEW_LINE INDENT if ( n == 0 or k == 0 or k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 1 or k == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( k * count@@ P ( n - 1 , k ) + count@@ P ( n - 1 , k - 1 ) ) NEW_LINE DEDENT
C_@@ PROGRAM_@@ FAC@@ TOR@@ I@@ AL_@@ NUMBER_@@ 2 | def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT
FIND_@@ REPE@@ ATED_@@ CHARACTER_@@ PRES@@ ENT_@@ FIRST_@@ STRING_@@ 1 | def find@@ Repeat@@ First ( s ) : NEW_LINE INDENT p = - 1 NEW_LINE hash = [ 0 for i in range ( MAX_@@ CHAR ) ] NEW_LINE pos = [ 0 for i in range ( MAX_@@ CHAR ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT k = ord ( s [ i ] ) NEW_LINE if ( hash [ k ] == 0 ) : NEW_LINE INDENT hash [ k ] += 1 NEW_LINE pos [ k ] = i NEW_LINE DEDENT elif ( hash [ k ] == 1 ) : NEW_LINE INDENT hash [ k ] += 1 NEW_LINE DEDENT DEDENT for i in range ( MAX_@@ CHAR ) : NEW_LINE INDENT if ( hash [ i ] == 2 ) : NEW_LINE INDENT if ( p == - 1 ) : NEW_LINE INDENT p = pos [ i ] NEW_LINE DEDENT elif ( p > pos [ i ] ) : NEW_LINE INDENT p = pos [ i ] NEW_LINE DEDENT DEDENT DEDENT return p NEW_LINE DEDENT
NUMBER_OF_@@ PER@@ MU@@ TATION_@@ WITH_@@ K_@@ IN@@ VERSIONS | def numberOf@@ Perm@@ With@@ K@@ In@@ version ( N , K ) : NEW_LINE INDENT if ( N == 0 ) : return 0 NEW_LINE if ( K == 0 ) : return 1 NEW_LINE if ( memo [ N ] [ K ] != 0 ) : NEW_LINE INDENT return memo [ N ] [ K ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT if ( i <= N - 1 ) : NEW_LINE INDENT sum += numberOf@@ Perm@@ With@@ K@@ In@@ version ( N - 1 , K - i ) NEW_LINE DEDENT DEDENT memo [ N ] [ K ] = sum NEW_LINE return sum NEW_LINE DEDENT
K_@@ TH_@@ LAR@@ GE@@ ST@@ _S@@ UM_@@ CON@@ TI@@ GU@@ OU@@ S@@ _SUB@@ ARRAY | def k@@ th@@ Largest@@ Sum ( arr , n , k ) : NEW_LINE INDENT sum = [ ] NEW_LINE sum . append ( 0 ) NEW_LINE sum . append ( arr [ 0 ] ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT sum . append ( sum [ i - 1 ] + arr [ i - 1 ] ) NEW_LINE DEDENT Q = [ ] NEW_LINE heap@@ q . heap@@ ify ( Q ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT x = sum [ j ] - sum [ i - 1 ] NEW_LINE if len ( Q ) < k : NEW_LINE INDENT heap@@ q . heap@@ push ( Q , x ) NEW_LINE DEDENT else : NEW_LINE INDENT if Q [ 0 ] < x : NEW_LINE INDENT heap@@ q . heap@@ pop ( Q ) NEW_LINE heap@@ q . heap@@ push ( Q , x ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return Q [ 0 ] NEW_LINE DEDENT
FIND_@@ THE_@@ LAR@@ GE@@ ST_@@ THRE@@ E_@@ ELEMEN@@ TS_@@ IN_@@ AN_@@ ARRAY | def find@@ 3@@ largest ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE check = 0 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( count < 4 ) : NEW_LINE INDENT if ( check != arr [ n - i ] ) : NEW_LINE INDENT print ( arr [ n - i ] , end = " ▁ " ) NEW_LINE check = arr [ n - i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
MAXIMUM_@@ DISTIN@@ CT_@@ LOW@@ ER@@ CASE_@@ ALPH@@ AB@@ E@@ TS_@@ TWO_@@ UP@@ PER@@ CASE | def max@@ Lower ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] >= ' A ' and str [ i ] <= ' Z ' : NEW_LINE INDENT i += 1 NEW_LINE break NEW_LINE DEDENT DEDENT maxCount = 0 NEW_LINE count = [ ] NEW_LINE for j in range ( MAX_@@ CHAR ) : NEW_LINE INDENT count . append ( 0 ) NEW_LINE DEDENT for j in range ( i , n ) : NEW_LINE INDENT if str [ j ] >= ' A ' and str [ j ] <= ' Z ' : NEW_LINE INDENT curr@@ Count = 0 NEW_LINE for k in range ( MAX_@@ CHAR ) : NEW_LINE INDENT if count [ k ] > 0 : NEW_LINE INDENT curr@@ Count += 1 NEW_LINE DEDENT DEDENT maxCount = max ( maxCount , curr@@ Count ) NEW_LINE for y in count : NEW_LINE INDENT y = 0 NEW_LINE DEDENT DEDENT if str [ j ] >= ' a ' and str [ j ] <= ' z ' : NEW_LINE INDENT count [ ord ( str [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT return maxCount NEW_LINE DEDENT
CHECK_@@ IF_@@ A_@@ STRING_@@ HAS_@@ ALL_@@ CHARAC@@ TER@@ S_@@ WITH@@ _S@@ AME_@@ FREQU@@ ENCY_@@ WITH_@@ ONE_@@ VARI@@ ATION_@@ ALLOWED | def isValid@@ String ( str ) : NEW_LINE INDENT freq = [ 0 ] * CHARS NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT fre@@ q1 = 0 NEW_LINE count_@@ fre@@ q1 = 0 NEW_LINE for i in range ( CHARS ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT fre@@ q1 = freq [ i ] NEW_LINE count_@@ fre@@ q1 = 1 NEW_LINE break NEW_LINE DEDENT DEDENT fre@@ q2 = 0 NEW_LINE count_@@ fre@@ q2 = 0 NEW_LINE for j in range ( i + 1 , CHARS ) : NEW_LINE INDENT if ( freq [ j ] != 0 ) : NEW_LINE INDENT if ( freq [ j ] == fre@@ q1 ) : NEW_LINE INDENT count_@@ fre@@ q1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_@@ fre@@ q2 = 1 NEW_LINE fre@@ q2 = freq [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for k in range ( j + 1 , CHARS ) : NEW_LINE INDENT if ( freq [ k ] != 0 ) : NEW_LINE INDENT if ( freq [ k ] == fre@@ q1 ) : NEW_LINE INDENT count_@@ fre@@ q1 += 1 NEW_LINE DEDENT if ( freq [ k ] == fre@@ q2 ) : NEW_LINE INDENT count_@@ fre@@ q2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( count_@@ fre@@ q1 > 1 and count_@@ fre@@ q2 > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
MAXIMUM_@@ AVER@@ AGE_@@ S@@ UM_@@ PARTITION_@@ ARRAY | def lar@@ gest@@ Sum@@ Of@@ Aver@@ ages ( A , K ) : NEW_LINE INDENT n = len ( A ) ; NEW_LINE pre_@@ sum = [ 0 ] * ( n + 1 ) ; NEW_LINE pre_@@ sum [ 0 ] = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT pre_@@ sum [ i + 1 ] = pre_@@ sum [ i ] + A [ i ] ; NEW_LINE DEDENT dp = [ 0 ] * n ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = ( pre_@@ sum [ n ] - pre_@@ sum [ i ] ) / ( n - i ) ; NEW_LINE DEDENT for k in range ( K - 1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , ( pre_@@ sum [ j ] - pre_@@ sum [ i ] ) / ( j - i ) + dp [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT return int ( dp [ 0 ] ) ; NEW_LINE DEDENT
FIN@@ D@@ _SUB@@ ARRAY_@@ WITH_@@ GI@@ VEN@@ _S@@ UM_@@ IN_@@ ARRAY_@@ OF_@@ INTEG@@ ERS | def sub@@ Array@@ Sum ( arr , n , Sum ) : NEW_LINE INDENT Map = { } NEW_LINE curr_@@ sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_@@ sum = curr_@@ sum + arr [ i ] NEW_LINE if curr_@@ sum == Sum : NEW_LINE INDENT print ( " Sum ▁ found ▁ between ▁ indexes ▁ 0 ▁ to " , i ) NEW_LINE return NEW_LINE DEDENT if ( curr_@@ sum - Sum ) in Map : NEW_LINE INDENT print ( " Sum ▁ found ▁ between ▁ indexes " , \ Map [ curr_@@ sum - Sum ] + 1 , " to " , i ) NEW_LINE return NEW_LINE DEDENT Map [ curr_@@ sum ] = i NEW_LINE DEDENT print ( " No ▁ sub@@ array ▁ with ▁ given ▁ sum ▁ exists " ) NEW_LINE DEDENT
REMOVE_@@ MINIMUM_@@ ELEMEN@@ TS_@@ EI@@ THER@@ _SI@@ DE_@@ 2@@ MIN_@@ MAX | def min@@ Removal@@ s@@ DP ( arr , n ) : NEW_LINE INDENT lon@@ gest_@@ start = - 1 ; NEW_LINE lon@@ gest_@@ end = 0 ; NEW_LINE for start in range ( n ) : NEW_LINE INDENT min = sys . maxsize ; NEW_LINE max = - sys . maxsize ; NEW_LINE for end in range ( start , n ) : NEW_LINE INDENT val = arr [ end ] ; NEW_LINE if ( val < min ) : NEW_LINE INDENT min = val ; NEW_LINE DEDENT if ( val > max ) : NEW_LINE INDENT max = val ; NEW_LINE DEDENT if ( 2 * min <= max ) : NEW_LINE INDENT break ; NEW_LINE DEDENT if ( end - start > lon@@ gest_@@ end - lon@@ gest_@@ start or lon@@ gest_@@ start == - 1 ) : NEW_LINE INDENT lon@@ gest_@@ start = start ; NEW_LINE lon@@ gest_@@ end = end ; NEW_LINE DEDENT DEDENT DEDENT if ( lon@@ gest_@@ start == - 1 ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT return ( n - ( lon@@ gest_@@ end - lon@@ gest_@@ start + 1 ) ) ; NEW_LINE DEDENT
FIND_@@ THE_@@ MISSING_@@ NUMBER_@@ 1 | def get@@ Missing@@ No ( a , n ) : NEW_LINE INDENT i , total = 0 , 1 NEW_LINE for i in range ( 2 , n + 2 ) : NEW_LINE INDENT total += i NEW_LINE total -= a [ i - 2 ] NEW_LINE DEDENT return total NEW_LINE DEDENT
SI@@ EV@@ E_@@ SUN@@ DAR@@ AM_@@ PRINT_@@ PRI@@ ME@@ S_S@@ MAL@@ LER_@@ N | def Si@@ eve@@ OfS@@ und@@ ar@@ am ( n ) : NEW_LINE INDENT n@@ New = int ( ( n - 2 ) / 2 ) ; NEW_LINE marked = [ 0 ] * ( n@@ New + 1 ) ; NEW_LINE for i in range ( 1 , n@@ New + 1 ) : NEW_LINE INDENT j = i ; NEW_LINE while ( ( i + j + 2 * i * j ) <= n@@ New ) : NEW_LINE INDENT marked [ i + j + 2 * i * j ] = 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( 2 , end = " ▁ " ) ; NEW_LINE DEDENT for i in range ( 1 , n@@ New + 1 ) : NEW_LINE INDENT if ( marked [ i ] == 0 ) : NEW_LINE INDENT print ( ( 2 * i + 1 ) , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
MAXIMUM_@@ PRODUCT_@@ SUB@@ SET_@@ ARRAY | def max@@ Product@@ Subset ( a , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT max_@@ neg = - 99999999@@ 9999 NEW_LINE count_@@ neg = 0 NEW_LINE count_@@ zero = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT count_@@ zero += 1 NEW_LINE continue NEW_LINE DEDENT if a [ i ] < 0 : NEW_LINE INDENT count_@@ neg += 1 NEW_LINE max_@@ neg = max ( max_@@ neg , a [ i ] ) NEW_LINE DEDENT prod = prod * a [ i ] NEW_LINE DEDENT if count_@@ zero == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if count_@@ neg & 1 : NEW_LINE INDENT if ( count_@@ neg == 1 and count_@@ zero > 0 and count_@@ zero + count_@@ neg == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT prod = int ( prod / max_@@ neg ) NEW_LINE DEDENT return prod NEW_LINE DEDENT
FIND_@@ THE_@@ NEARE@@ ST@@ _S@@ MAL@@ LER_@@ NUMB@@ ERS_@@ ON_@@ LEFT_@@ SIDE_@@ IN_@@ AN_@@ ARRAY | def print@@ Prev@@ S@@ mal@@ ler ( arr , n ) : NEW_LINE INDENT print ( " _ , ▁ " , end = " " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i - 1 , - 2 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] < arr [ i ] ) : NEW_LINE INDENT print ( arr [ j ] , " , ▁ " , end = " " ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == - 1 ) : NEW_LINE INDENT print ( " _ , ▁ " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
FIND_@@ NUMBER_@@ PAIR@@ S_@@ ARRAY_@@ X@@ OR_@@ 0_@@ 1 | def calculate ( a ) : NEW_LINE INDENT maximum = max ( a ) NEW_LINE frequency = [ 0 for x in range ( maximum + 1 ) ] NEW_LINE for i in a : NEW_LINE INDENT frequency [ i ] += 1 NEW_LINE DEDENT answer = 0 NEW_LINE for i in frequency : NEW_LINE INDENT answer = answer + i * ( i - 1 ) // 2 NEW_LINE DEDENT return answer NEW_LINE DEDENT
S@@ UM_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENTS_@@ 1 | def bin@@ omi@@ al@@ Coeff@@ Sum ( n ) : NEW_LINE INDENT return ( 1 << n ) ; NEW_LINE DEDENT
MAX@@ IM@@ UM@@ _S@@ UM_@@ PAIR@@ S@@ _SPECI@@ FIC_@@ DIFF@@ ER@@ ENCE_@@ 1 | def max@@ Sum@@ Pair@@ With@@ Difference@@ LessThan@@ K ( arr , N , k ) : NEW_LINE INDENT max@@ Sum = 0 ; NEW_LINE arr . sort ( ) ; NEW_LINE i = N - 1 ; NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] < k ) : NEW_LINE INDENT max@@ Sum += arr [ i ] ; NEW_LINE max@@ Sum += arr [ i - 1 ] ; NEW_LINE i -= 1 ; NEW_LINE DEDENT i -= 1 ; NEW_LINE DEDENT return max@@ Sum ; NEW_LINE DEDENT
K@@ TH_@@ AD@@ J@@ AC@@ ENT_@@ NODE_@@ GRAPH_@@ VERTEX_@@ WEIGHT | def print@@ k@@ th@@ node ( adj , wt , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT adj [ i ] . sort ( ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( len ( adj [ i ] ) >= k ) : NEW_LINE INDENT print ( adj [ i ] [ len ( adj [ i ] ) - k ] [ 1 ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
SPACE_@@ OPTIMIZ@@ ED_@@ D@@ P_S@@ OL@@ U@@ TION_@@ 0_@@ 1_@@ KN@@ AP@@ S@@ ACK_@@ PRO@@ BLE@@ M | def K@@ nap@@ S@@ ack ( val , wt , n , W ) : NEW_LINE INDENT mat = [ [ 0 for i in range ( W + 1 ) ] for i in range ( 2 ) ] NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT j = 0 NEW_LINE if i % 2 == 0 : NEW_LINE INDENT while j < W : NEW_LINE INDENT j += 1 NEW_LINE if wt [ i ] <= j : NEW_LINE INDENT mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ 1 ] [ j ] = mat [ 0 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT while j < W : NEW_LINE INDENT j += 1 NEW_LINE if wt [ i ] <= j : NEW_LINE INDENT mat [ 0 ] [ j ] = max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ 0 ] [ j ] = mat [ 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return mat [ 0 ] [ W ] NEW_LINE DEDENT else : NEW_LINE INDENT return mat [ 1 ] [ W ] NEW_LINE DEDENT DEDENT
BINARY_@@ RE@@ PRESEN@@ TATION_@@ OF_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ 1 | def bin ( n ) : NEW_LINE INDENT if ( n > 1 ) : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n & 1 , end = " " ) NEW_LINE DEDENT
PRI@@ ME_@@ FAC@@ TOR@@ S_@@ BIG_@@ NUMBER | def factor@@ ize ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( ( n % 2 > 0 ) == False ) : NEW_LINE INDENT n >>= 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT print ( 2 , count ) ; NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n = int ( n / i ) ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT print ( i , count ) ; NEW_LINE DEDENT i += 2 ; NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( n , 1 ) ; NEW_LINE DEDENT DEDENT
COUNT_@@ SUB@@ STRING@@ S_@@ WITH@@ _S@@ AME_@@ FIRST_@@ AND_@@ LAST_@@ CHARAC@@ TER@@ S_@@ 1 | def count@@ Sub@@ string@@ With@@ Equal@@ Ends ( s ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE count = [ 0 ] * MAX_@@ CHAR ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( MAX_@@ CHAR ) : NEW_LINE INDENT result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT
LON@@ GE@@ ST_@@ PA@@ LIN@@ DRO@@ ME_@@ SUB@@ STRING@@ _SET_@@ 1 | def print@@ Sub@@ Str ( st , low , high ) : NEW_LINE INDENT sys . stdout . write ( st [ low : high + 1 ] ) NEW_LINE sys . stdout . flush ( ) NEW_LINE return ' ' NEW_LINE DEDENT
FIND_@@ THE_@@ SM@@ ALLE@@ ST_@@ WINDOW_@@ IN_@@ A_@@ STRING_@@ CONTAIN@@ ING_@@ ALL_@@ CHARAC@@ TER@@ S_@@ OF_@@ AN@@ OTHER_@@ STRING | def find@@ Sub@@ String ( string , pat ) : NEW_LINE INDENT len1 = len ( string ) NEW_LINE len2 = len ( pat ) NEW_LINE if len1 < len2 : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT hash@@ _p@@ at = [ 0 ] * no_@@ of_@@ chars NEW_LINE hash_@@ str = [ 0 ] * no_@@ of_@@ chars NEW_LINE for i in range ( 0 , len2 ) : NEW_LINE INDENT hash@@ _p@@ at [ ord ( pat [ i ] ) ] += 1 NEW_LINE DEDENT start , start_index , min_@@ len = 0 , - 1 , float ( ' inf ' ) NEW_LINE count = 0 NEW_LINE for j in range ( 0 , len1 ) : NEW_LINE INDENT hash_@@ str [ ord ( string [ j ] ) ] += 1 NEW_LINE if ( hash@@ _p@@ at [ ord ( string [ j ] ) ] != 0 and hash_@@ str [ ord ( string [ j ] ) ] <= hash@@ _p@@ at [ ord ( string [ j ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == len2 : NEW_LINE INDENT while ( hash_@@ str [ ord ( string [ start ] ) ] > hash@@ _p@@ at [ ord ( string [ start ] ) ] or hash@@ _p@@ at [ ord ( string [ start ] ) ] == 0 ) : NEW_LINE INDENT if ( hash_@@ str [ ord ( string [ start ] ) ] > hash@@ _p@@ at [ ord ( string [ start ] ) ] ) : NEW_LINE INDENT hash_@@ str [ ord ( string [ start ] ) ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_@@ window = j - start + 1 NEW_LINE if min_@@ len > len_@@ window : NEW_LINE INDENT min_@@ len = len_@@ window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT if start_index == - 1 : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT return string [ start_index : start_index + min_@@ len ] NEW_LINE DEDENT
MAR@@ KO@@ V_@@ MATRIX | def check@@ Mark@@ ov ( m ) : NEW_LINE INDENT for i in range ( 0 , len ( m ) ) : NEW_LINE INDENT sm = 0 NEW_LINE for j in range ( 0 , len ( m [ i ] ) ) : NEW_LINE INDENT sm = sm + m [ i ] [ j ] NEW_LINE DEDENT if ( sm != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
LE@@ AF_@@ NODE@@ S_@@ PRE@@ ORDER_@@ BIN@@ AR@@ Y@@ _SEARCH_@@ TREE | def leaf@@ Node ( pre@@ order , n ) : NEW_LINE INDENT s = [ ] NEW_LINE i = 0 NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT found = False NEW_LINE if pre@@ order [ i ] > pre@@ order [ j ] : NEW_LINE INDENT s . append ( pre@@ order [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT while len ( s ) != 0 : NEW_LINE INDENT if pre@@ order [ j ] > s [ - 1 ] : NEW_LINE INDENT s . pop ( - 1 ) NEW_LINE found = True NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if found : NEW_LINE INDENT print ( pre@@ order [ i ] , end = " ▁ " ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( pre@@ order [ n - 1 ] ) NEW_LINE DEDENT
SM@@ ALLE@@ ST_@@ POWER_@@ OF_@@ 2_@@ GREATER_@@ TH@@ AN_@@ OR_@@ EQUAL_@@ TO_@@ N | def next@@ PowerOf@@ 2 ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count ; NEW_LINE DEDENT
PROGRAM_@@ CHECK_@@ WAT@@ ER_@@ TAN@@ K_@@ OVER@@ FLO@@ WS_@@ N@@ _SO@@ LI@@ D_@@ BAL@@ LS_@@ DIP@@ PED_@@ WAT@@ ER_@@ TAN@@ K | def overflow ( H , r , h , N , R ) : NEW_LINE INDENT tan@@ k_@@ cap = 3.14 * r * r * H NEW_LINE wat@@ er_@@ vol = 3.14 * r * r * h NEW_LINE ball@@ s_@@ vol = N * ( 4 / 3 ) * 3.14 * R * R * R NEW_LINE vol = wat@@ er_@@ vol + ball@@ s_@@ vol NEW_LINE if vol > tan@@ k_@@ cap : NEW_LINE INDENT print ( " Overflow " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ in ▁ overflow ▁ state " ) NEW_LINE DEDENT DEDENT
SM@@ ALLE@@ ST_@@ DE@@ RANGE@@ MENT_@@ SEQUENCE | def generate_@@ der@@ ange@@ ment ( N ) : NEW_LINE INDENT S = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT S [ i ] = i NEW_LINE DEDENT D = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 , 2 ) : NEW_LINE INDENT if i == N : NEW_LINE INDENT D [ N ] = S [ N - 1 ] NEW_LINE D [ N - 1 ] = S [ N ] NEW_LINE DEDENT else : NEW_LINE INDENT D [ i ] = i + 1 NEW_LINE D [ i + 1 ] = i NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( D [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
MAXIMUM_@@ PRODUCT_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQUENCE | def lis ( arr , n ) : NEW_LINE INDENT mp@@ is = [ 0 ] * ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp@@ is [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and mp@@ is [ i ] < ( mp@@ is [ j ] * arr [ i ] ) ) : NEW_LINE INDENT mp@@ is [ i ] = mp@@ is [ j ] * arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return max ( mp@@ is ) NEW_LINE DEDENT
CHANGE_@@ BITS_@@ CAN_@@ MA@@ DE_@@ ONE_@@ FLI@@ P | def can@@ Make@@ All@@ Same ( str ) : NEW_LINE INDENT zeros = 0 NEW_LINE ones = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT ch = str [ i ] ; NEW_LINE if ( ch == '0' ) : NEW_LINE INDENT zeros = zeros + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones = ones + 1 NEW_LINE DEDENT DEDENT return ( zeros == 1 or ones == 1 ) ; NEW_LINE DEDENT
FIND_@@ NUMBER_@@ PAIR@@ S_@@ ARRAY_@@ X@@ OR_@@ 0 | def calculate ( a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE count = 1 NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT answer = answer + count * ( count - 1 ) // 2 NEW_LINE count = 1 NEW_LINE DEDENT DEDENT answer = answer + count * ( count - 1 ) // 2 NEW_LINE return answer NEW_LINE DEDENT
FIND_@@ ROOT_@@ TREE_@@ CHIL@@ DR@@ EN_@@ ID@@ _S@@ UM_@@ EVER@@ Y_@@ NODE_@@ GI@@ VEN | def find@@ Root ( arr , n ) : NEW_LINE INDENT root = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT root += ( arr [ i ] [ 0 ] - arr [ i ] [ 1 ] ) NEW_LINE DEDENT return root NEW_LINE DEDENT
BIN@@ AR@@ Y@@ _SEARCH | def binary@@ Search ( arr , l , r , x ) : NEW_LINE INDENT if r >= l : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] > x : NEW_LINE INDENT return binary@@ Search ( arr , l , mid - 1 , x ) NEW_LINE DEDENT else : NEW_LINE INDENT return binary@@ Search ( arr , mid + 1 , r , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
FI@@ BON@@ ACC@@ I_@@ MODUL@@ O_@@ P | def find@@ Min@@ Zero ( p ) : NEW_LINE INDENT first = 1 NEW_LINE second = 1 NEW_LINE number = 2 NEW_LINE next = 1 NEW_LINE while ( next ) : NEW_LINE INDENT next = ( first + second ) % p NEW_LINE first = second NEW_LINE second = next NEW_LINE number = number + 1 NEW_LINE DEDENT return number NEW_LINE DEDENT
K_@@ LAR@@ GE@@ STOR@@ _S@@ MAL@@ LE@@ ST_@@ ELEMEN@@ TS_@@ IN_@@ AN_@@ ARRAY | def k@@ Lar@@ gest ( arr , k ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
C_@@ PROGRAM_@@ FIND_@@ AREA_@@ CIRC@@ LE | def find@@ Area ( r ) : NEW_LINE INDENT PI = 3.14@@ 2 NEW_LINE return PI * ( r * r ) ; NEW_LINE DEDENT
S@@ UM_@@ TWO_@@ LARGE_@@ NUMB@@ ERS | def find@@ Sum ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) > len ( str2 ) ) : NEW_LINE INDENT t = str1 ; NEW_LINE str1 = str2 ; NEW_LINE str2 = t ; NEW_LINE DEDENT str = " " ; NEW_LINE n1 = len ( str1 ) ; NEW_LINE n2 = len ( str2 ) ; NEW_LINE str1 = str1 [ : : - 1 ] ; NEW_LINE str2 = str2 [ : : - 1 ] ; NEW_LINE carry = 0 ; NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT sum = ( ( ord ( str1 [ i ] ) - 48 ) + ( ( ord ( str2 [ i ] ) - 48 ) + carry ) ) ; NEW_LINE str += chr ( sum % 10 + 48 ) ; NEW_LINE carry = int ( sum / 10 ) ; NEW_LINE DEDENT for i in range ( n1 , n2 ) : NEW_LINE INDENT sum = ( ( ord ( str2 [ i ] ) - 48 ) + carry ) ; NEW_LINE str += chr ( sum % 10 + 48 ) ; NEW_LINE carry = ( int ) ( sum / 10 ) ; NEW_LINE DEDENT if ( carry ) : NEW_LINE INDENT str += chr ( carry + 48 ) ; NEW_LINE DEDENT str = str [ : : - 1 ] ; NEW_LINE return str ; NEW_LINE DEDENT
ARRAY_@@ RANGE_@@ QUER@@ I@@ ES_@@ ELEMEN@@ TS_@@ FREQU@@ ENCY_@@ VALUE | def solve@@ Query ( start , end , arr ) : NEW_LINE INDENT frequency = dict ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if arr [ i ] in frequency . keys ( ) : NEW_LINE INDENT frequency [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT frequency [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for x in frequency : NEW_LINE INDENT if x == frequency [ x ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
COUNT_@@ SUB@@ STRING@@ S_@@ WITH@@ _S@@ AME_@@ FIRST_@@ AND_@@ LAST_@@ CHARAC@@ TERS | def count@@ Sub@@ string@@ With@@ Equal@@ Ends ( s ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ M@@ ING_@@ HIGH_@@ EFF@@ ORT_@@ VS_@@ LOW_@@ EFF@@ ORT_@@ TASK@@ S_@@ PRO@@ BLE@@ M | def max@@ Tasks ( high , low , n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return max ( high [ n - 1 ] + max@@ Tasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + max@@ Tasks ( high , low , ( n - 1 ) ) ) ; NEW_LINE DEDENT
MAXIMUM_@@ DIFF@@ ER@@ ENCE_@@ S@@ UM_@@ ELEMEN@@ TS_@@ TWO_@@ RO@@ WS_@@ MATRIX | def max@@ Row@@ Diff ( mat , m , n ) : NEW_LINE INDENT row@@ Sum = [ 0 ] * m NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT sum += mat [ i ] [ j ] NEW_LINE DEDENT row@@ Sum [ i ] = sum NEW_LINE DEDENT max_@@ diff = row@@ Sum [ 1 ] - row@@ Sum [ 0 ] NEW_LINE min_@@ element = row@@ Sum [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT if ( row@@ Sum [ i ] - min_@@ element > max_@@ diff ) : NEW_LINE INDENT max_@@ diff = row@@ Sum [ i ] - min_@@ element NEW_LINE DEDENT if ( row@@ Sum [ i ] < min_@@ element ) : NEW_LINE INDENT min_@@ element = row@@ Sum [ i ] NEW_LINE DEDENT DEDENT return max_@@ diff NEW_LINE DEDENT
PAP@@ ER_@@ CU@@ T_@@ MINIMUM_@@ NUMBER@@ _S@@ QUAR@@ ES | def minimum@@ Square ( a , b ) : NEW_LINE INDENT result = 0 NEW_LINE rem = 0 NEW_LINE if ( a < b ) : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT while ( b > 0 ) : NEW_LINE INDENT result += int ( a / b ) NEW_LINE rem = int ( a % b ) NEW_LINE a = b NEW_LINE b = rem NEW_LINE DEDENT return result NEW_LINE DEDENT
SEARCH_@@ AN_@@ ELEMENT_@@ IN_@@ AN_@@ ARRAY_@@ W@@ HER@@ E_@@ DIFF@@ ER@@ ENCE_@@ BETWE@@ EN_@@ AD@@ J@@ AC@@ ENT_@@ ELEMEN@@ TS_@@ IS_@@ 1 | def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + abs ( arr [ i ] - x ) NEW_LINE DEDENT print ( " number ▁ is ▁ not ▁ present ! " ) NEW_LINE return - 1 NEW_LINE DEDENT
PAN@@ GR@@ AM_@@ CHECK@@ ING | def check@@ P@@ ang@@ ram ( s ) : NEW_LINE INDENT List = [ ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT List . append ( False ) NEW_LINE DEDENT for c in s . lower ( ) : NEW_LINE INDENT if not c == " ▁ " : NEW_LINE INDENT List [ ord ( c ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT DEDENT for ch in List : NEW_LINE INDENT if ch == False : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
PRINT_@@ SHOR@@ TEST_@@ COMM@@ ON@@ _SUP@@ ER@@ SEQUENCE | def print@@ Shor@@ test@@ Super@@ Seq ( x , y ) : NEW_LINE INDENT m = len ( x ) NEW_LINE n = len ( y ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif x [ i - 1 ] == y [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT index = dp [ m ] [ n ] NEW_LINE string = " " NEW_LINE i = m NEW_LINE j = n NEW_LINE while i > 0 and j > 0 : NEW_LINE INDENT if x [ i - 1 ] == y [ j - 1 ] : NEW_LINE INDENT string += x [ i - 1 ] NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT elif dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] : NEW_LINE INDENT string += y [ j - 1 ] NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT string += x [ i - 1 ] NEW_LINE i -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT while i > 0 : NEW_LINE INDENT string += x [ i - 1 ] NEW_LINE i -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT while j > 0 : NEW_LINE INDENT string += y [ j - 1 ] NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT string = list ( string ) NEW_LINE string . reverse ( ) NEW_LINE return ' ' . join ( string ) NEW_LINE DEDENT
FIND_@@ PA@@ IR_@@ MAXIMUM_@@ GC@@ D_@@ ARRAY_@@ 1 | def find@@ Max@@ GC@@ D ( arr , n ) : NEW_LINE INDENT high = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT high = max ( high , arr [ i ] ) NEW_LINE DEDENT count = [ 0 ] * ( high + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT counter = 0 NEW_LINE for i in range ( high , 0 , - 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( j <= high ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT counter += count [ j ] NEW_LINE DEDENT j += i NEW_LINE if ( counter == 2 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT counter = 0 NEW_LINE DEDENT DEDENT
PROGRAM_@@ CAL@@ CUL@@ ATE_@@ AREA_@@ OC@@ TAG@@ ON | def area@@ Oct@@ ag@@ on ( side ) : NEW_LINE INDENT return ( 2 * ( 1 + ( math . sqrt ( 2 ) ) ) * side * side ) NEW_LINE DEDENT
FIND_@@ INDEX_@@ OF_@@ AN_@@ EXTRA_@@ ELEMENT_@@ PRES@@ ENT_@@ IN_@@ ONE@@ _S@@ OR@@ TED_@@ ARRAY_@@ 1 | def find@@ Extra ( ar@@ r1 , ar@@ r2 , n ) : NEW_LINE INDENT index = n NEW_LINE left = 0 NEW_LINE right = n - 1 NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( int ) ( ( left + right ) / 2 ) NEW_LINE if ( ar@@ r2 [ mid ] == ar@@ r1 [ mid ] ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT index = mid NEW_LINE right = mid - 1 NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
NO@@ BLE_@@ INTEG@@ ERS_@@ IN_@@ AN_@@ ARRAY_@@ COUNT_@@ OF_@@ GREATER_@@ ELEMEN@@ TS_@@ IS_@@ EQUAL_@@ TO_@@ VALUE_@@ 1 | def no@@ ble@@ Integer ( arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT if arr [ i ] == n - i - 1 : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT if arr [ n - 1 ] == 0 : NEW_LINE INDENT return arr [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
MAXIMUM_@@ NUMBER_@@ OF@@ _S@@ QUAR@@ ES_@@ TH@@ AT_@@ CAN_@@ BE_@@ FI@@ T_@@ IN_@@ A_@@ RIGHT_@@ ANGLE_@@ ISO@@ SCE@@ LES_@@ TRI@@ ANGLE | def max@@ Square ( b , m ) : NEW_LINE INDENT return ( b / m - 1 ) * ( b / m ) / 2 NEW_LINE DEDENT
HO@@ W_@@ TO_@@ COMP@@ UTE_@@ MOD_@@ OF_@@ A_@@ BIG_@@ NUMBER | def mod ( num , a ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT res = ( res * 10 + int ( num [ i ] ) ) % a ; NEW_LINE DEDENT return res NEW_LINE DEDENT
LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ STRING_@@ 1 | def l@@ cs ( i , j , count ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT count = l@@ cs ( i - 1 , j - 1 , count + 1 ) NEW_LINE DEDENT count = max ( count , max ( l@@ cs ( i , j - 1 , 0 ) , l@@ cs ( i - 1 , j , 0 ) ) ) NEW_LINE return count NEW_LINE DEDENT
FIND_@@ PATTER@@ NS_@@ 101@@ _@@ GI@@ V@@ EN_@@ STRING | def pattern@@ Count ( str ) : NEW_LINE INDENT last = str [ 0 ] NEW_LINE i = 1 ; counter = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '0' and last == '1' ) : NEW_LINE INDENT while ( str [ i ] == '0' ) : NEW_LINE INDENT i += 1 NEW_LINE if ( str [ i ] == '1' ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT last = str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return counter NEW_LINE DEDENT
LON@@ GE@@ ST_@@ INCRE@@ AS@@ ING_@@ OD@@ D_@@ EV@@ EN@@ _SUB@@ SEQUENCE | def long@@ O@@ dd@@ Even@@ Inc@@ Seq ( arr , n ) : NEW_LINE INDENT li@@ o@@ es = list ( ) NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT li@@ o@@ es . append ( 1 ) NEW_LINE DEDENT i = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr [ j ] ) % 2 != 0 and li@@ o@@ es [ i ] < li@@ o@@ es [ j ] + 1 ) : NEW_LINE INDENT li@@ o@@ es [ i ] = li@@ o@@ es [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if maxLen < li@@ o@@ es [ i ] : NEW_LINE INDENT maxLen = li@@ o@@ es [ i ] NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT
COUNT_@@ NUMBER_@@ OF@@ _SUB@@ STRING@@ S_@@ WITH_@@ EXAC@@ TL@@ Y_@@ K_@@ DISTIN@@ CT_@@ CHARAC@@ TERS | def count@@ k@@ Dist ( str1 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dist@@ _count = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( cnt [ ord ( str1 [ j ] ) - 97 ] == 0 ) : NEW_LINE INDENT dist@@ _count += 1 NEW_LINE DEDENT cnt [ ord ( str1 [ j ] ) - 97 ] += 1 NEW_LINE if ( dist@@ _count == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( dist@@ _count > k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
C_@@ PROGRAM_@@ FAC@@ TOR@@ I@@ AL_@@ NUMBER_@@ 1 | def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) ; NEW_LINE DEDENT
K_@@ MAX@@ IM@@ UM@@ _S@@ UM@@ S_@@ NON_@@ OVER@@ L@@ APP@@ ING_@@ CON@@ TI@@ GU@@ OU@@ S@@ _SUB_@@ ARRAY@@ S | def k@@ max ( arr , k , n ) : NEW_LINE INDENT for c in range ( k ) : NEW_LINE INDENT max_@@ so@@ _f@@ ar = - float ( " inf " ) NEW_LINE max_@@ here = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_@@ here += arr [ i ] NEW_LINE if ( max_@@ so@@ _f@@ ar < max_@@ here ) : NEW_LINE INDENT max_@@ so@@ _f@@ ar = max_@@ here NEW_LINE start = s NEW_LINE end = i NEW_LINE DEDENT if ( max_@@ here < 0 ) : NEW_LINE INDENT max_@@ here = 0 NEW_LINE s = i + 1 NEW_LINE DEDENT DEDENT print ( " Maximum ▁ non - overlapping ▁ sub - array ▁ sum " , c + 1 , " : ▁ " , max_@@ so@@ _f@@ ar , " , ▁ starting ▁ index : ▁ " , start , " , ▁ ending ▁ index : ▁ " , end , " . " , sep = " " ) NEW_LINE for l in range ( start , end + 1 ) : NEW_LINE INDENT arr [ l ] = - float ( " inf " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
DISTAN@@ CE_@@ NEARE@@ ST_@@ CELL_@@ 1_@@ BINARY_@@ MATRIX | def print@@ Distance ( mat ) : NEW_LINE INDENT global N , M NEW_LINE ans = [ [ None ] * M for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT ans [ i ] [ j ] = 99999999@@ 9999 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT for k in range ( N ) : NEW_LINE INDENT for l in range ( M ) : NEW_LINE INDENT if ( mat [ k ] [ l ] == 1 ) : NEW_LINE INDENT ans [ i ] [ j ] = min ( ans [ i ] [ j ] , abs ( i - k ) + abs ( j - l ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT print ( ans [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
MINIMUM_@@ NUMBER_OF_@@ BRAC@@ KET_@@ REVER@@ S@@ AL@@ S_@@ NE@@ E@@ DED_@@ TO_@@ MAKE_@@ AN_@@ EXPRES@@ SION_@@ BAL@@ ANCE@@ D | def count@@ Min@@ Re@@ vers@@ als ( expr ) : NEW_LINE INDENT len@@ n = len ( expr ) NEW_LINE if ( len@@ n % 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT s = [ ] NEW_LINE for i in range ( len@@ n ) : NEW_LINE INDENT if ( expr [ i ] == ' ' and len ( s ) ) : NEW_LINE INDENT if ( s [ 0 ] == ' ' ) : NEW_LINE INDENT s . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT s . insert ( 0 , expr [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT s . insert ( 0 , expr [ i ] ) NEW_LINE DEDENT DEDENT red_@@ len = len ( s ) NEW_LINE n = 0 NEW_LINE while ( len ( s ) and s [ 0 ] == ' ' ) : NEW_LINE INDENT s . pop ( 0 ) NEW_LINE n += 1 NEW_LINE DEDENT return ( red_@@ len // 2 + n % 2 ) NEW_LINE DEDENT
FIRST_@@ NEGATIVE_@@ INTEGER_@@ EVER@@ Y_@@ WINDOW@@ _SIZE_@@ K_@@ 1 | def print@@ First@@ Negative@@ Integer ( arr , n , k ) : NEW_LINE INDENT D@@ i = deque ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT D@@ i . append ( i ) ; NEW_LINE DEDENT DEDENT for i in range ( k , n ) : NEW_LINE INDENT if ( not D@@ i ) : NEW_LINE INDENT print ( 0 , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ D@@ i [ 0 ] ] , end = ' ▁ ' ) ; NEW_LINE DEDENT while D@@ i and D@@ i [ 0 ] <= ( i - k ) : NEW_LINE INDENT D@@ i . pop@@ left ( ) NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT D@@ i . append ( i ) ; NEW_LINE DEDENT DEDENT if not D@@ i : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ D@@ i [ 0 ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
MAG@@ IC@@ _S@@ QU@@ ARE | def generate@@ Square ( n ) : NEW_LINE INDENT magic@@ Square = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE i = n / 2 NEW_LINE j = n - 1 NEW_LINE num = 1 NEW_LINE while num <= ( n * n ) : NEW_LINE INDENT if i == - 1 and j == n : NEW_LINE INDENT j = n - 2 NEW_LINE i = 0 NEW_LINE DEDENT else : NEW_LINE INDENT if j == n : NEW_LINE INDENT j = 0 NEW_LINE DEDENT if i < 0 : NEW_LINE INDENT i = n - 1 NEW_LINE DEDENT DEDENT if magic@@ Square [ int ( i ) ] [ int ( j ) ] : NEW_LINE INDENT j = j - 2 NEW_LINE i = i + 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT magic@@ Square [ int ( i ) ] [ int ( j ) ] = num NEW_LINE num = num + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE i = i - 1 NEW_LINE DEDENT print ( " Magic ▁ Sq@@ ure ▁ for ▁ n ▁ = " , n ) NEW_LINE print ( " Sum ▁ of ▁ each ▁ row ▁ or ▁ column " , n * ( n * n + 1 ) / 2 , " \n " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT print ( ' % 2d ▁ ' % ( magic@@ Square [ i ] [ j ] ) , end = ' ' ) NEW_LINE if j == n - 1 : NEW_LINE INDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
PROGRAM_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENTS_@@ TABLE | def print@@ binomial ( max ) : NEW_LINE INDENT for m in range ( max + 1 ) : NEW_LINE INDENT print ( ' % ▁ 2d ' % m , end = ' ▁ ' ) NEW_LINE bin@@ om = 1 NEW_LINE for x in range ( m + 1 ) : NEW_LINE INDENT if m != 0 and x != 0 : NEW_LINE INDENT bin@@ om = bin@@ om * ( m - x + 1 ) / x NEW_LINE DEDENT print ( ' % ▁ 4d ' % bin@@ om , end = ' ▁ ' ) NEW_LINE DEDENT print ( " \n " , end = ' ' ) NEW_LINE DEDENT DEDENT
CH@@ INE@@ SE_@@ RE@@ MA@@ INDE@@ R_@@ THE@@ O@@ RE@@ M@@ _SET_@@ 1_@@ INTRO@@ DUC@@ TION | def find@@ Min@@ X ( num , rem , k ) : NEW_LINE INDENT x = 1 ; NEW_LINE while ( True ) : NEW_LINE INDENT j = 0 ; NEW_LINE while ( j < k ) : NEW_LINE INDENT if ( x % num [ j ] != rem [ j ] ) : NEW_LINE INDENT break ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT if ( j == k ) : NEW_LINE INDENT return x ; NEW_LINE DEDENT x += 1 ; NEW_LINE DEDENT DEDENT
MINIMUM_@@ NUMBER_@@ POINT@@ S_@@ REMO@@ VED_@@ GET_@@ RE@@ MAIN@@ ING_@@ POINT@@ S_@@ ONE@@ _SI@@ DE_@@ AXIS | def find@@ min ( p , n ) : NEW_LINE INDENT a , b , c , d = 0 , 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] [ 0 ] <= 0 ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif ( p [ i ] [ 0 ] >= 0 ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT if ( p [ i ] [ 1 ] >= 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif ( p [ i ] [ 1 ] <= 0 ) : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT return min ( [ a , b , c , d ] ) NEW_LINE DEDENT
REPL@@ ACE_@@ OC@@ CURR@@ EN@@ CES_@@ STRING_@@ AB_@@ C_@@ WITH@@ OUT_@@ USING_@@ EX@@ TRA@@ _SPACE | def translate ( st ) : NEW_LINE INDENT for i in range ( 1 , len ( st ) ) : NEW_LINE INDENT if ( st [ i - 1 ] == ' A ' and st [ i ] == ' B ' ) : NEW_LINE INDENT st [ i - 1 ] = ' C ' NEW_LINE for j in range ( i , len ( st ) - 1 ) : NEW_LINE INDENT st [ j ] = st [ j + 1 ] NEW_LINE DEDENT st [ len ( st ) - 1 ] = ' ▁ ' NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
PAIR@@ S_@@ OF_@@ POSITIVE_@@ NEGATIVE_@@ VALU@@ ES_@@ IN_@@ AN_@@ ARRAY | def print@@ Pairs ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT v . sort ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT print ( - v [ i ] , " " , v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
NON_@@ REPE@@ ATING_@@ ELEMENT_@@ 1 | def first@@ Non@@ Repe@@ ating ( arr , n ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if mp [ arr [ i ] ] == 1 : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
PRINT_@@ FI@@ BON@@ AC@@ CI@@ _SERI@@ ES_@@ REVERSE_@@ ORDER | def reverse@@ Fi@@ bon@@ ac@@ ci ( n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 2 ] + a [ i - 1 ] NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
FIND_@@ MINIMUM_@@ DIFF@@ ER@@ ENCE_@@ PA@@ IR_@@ 1 | def find@@ Min@@ Diff ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE diff = 10 ** 20 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] - arr [ i ] < diff : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE DEDENT DEDENT return diff NEW_LINE DEDENT
MINIMUM_@@ NUMBER_@@ PLAT@@ FOR@@ MS_@@ REQUIRED_@@ RA@@ IL@@ WAY@@ BUS_@@ ST@@ ATION | def find@@ Platform ( arr , dep , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE dep . sort ( ) NEW_LINE plat@@ _@@ needed = 1 NEW_LINE result = 1 NEW_LINE i = 1 NEW_LINE j = 0 NEW_LINE while ( i < n and j < n ) : NEW_LINE INDENT if ( arr [ i ] < dep [ j ] ) : NEW_LINE INDENT plat@@ _@@ needed += 1 NEW_LINE i += 1 NEW_LINE if ( plat@@ _@@ needed > result ) : NEW_LINE INDENT result = plat@@ _@@ needed NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT plat@@ _@@ needed -= 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
MULTIP@@ LIC@@ ATI@@ VE_@@ INVER@@ SE_@@ UN@@ DER_@@ MODUL@@ O_@@ M_@@ 1 | def mod@@ Inverse ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE y = 0 NEW_LINE x = 1 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = y NEW_LINE y = x - q * y NEW_LINE x = t NEW_LINE DEDENT if ( x < 0 ) : NEW_LINE INDENT x = x + m0 NEW_LINE DEDENT return x NEW_LINE DEDENT
NUMBER_@@ N_@@ DIG@@ IT_@@ STE@@ PP@@ ING_@@ NUMB@@ ERS | def answer ( n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( 10 ) ] for y in range ( n + 1 ) ] ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 10 ; NEW_LINE DEDENT for j in range ( 10 ) : NEW_LINE INDENT dp [ 1 ] [ j ] = 1 ; NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; NEW_LINE DEDENT elif ( j == 9 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT sum = 0 ; NEW_LINE for j in range ( 1 , 10 ) : NEW_LINE INDENT sum = sum + dp [ n ] [ j ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
CREATE_@@ A_@@ MATRIX_@@ WITH_@@ ALTER@@ N@@ ATING_@@ REC@@ TA@@ NG@@ LES_@@ OF_@@ 0_@@ AND_@@ X | def fill@@ 0@@ X ( m , n ) : NEW_LINE INDENT i , k , l = 0 , 0 , 0 NEW_LINE r = m NEW_LINE c = n NEW_LINE a = [ [ None ] * n for i in range ( m ) ] NEW_LINE x = ' X ' NEW_LINE while k < m and l < n : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT a [ k ] [ i ] = x NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT a [ i ] [ n - 1 ] = x NEW_LINE DEDENT n -= 1 NEW_LINE if k < m : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT a [ m - 1 ] [ i ] = x NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if l < n : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ l ] = x NEW_LINE DEDENT l += 1 NEW_LINE DEDENT x = ' X ' if x == '0' else '0' NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT print ( a [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
FIN@@ D_S@@ UM_@@ UNI@@ QUE_@@ SUB_@@ ARRA@@ Y_S@@ UM_@@ GI@@ V@@ EN_@@ ARRAY | def find@@ Sub@@ array@@ Sum ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT Sum += arr [ j ] NEW_LINE m [ Sum ] = m . get ( Sum , 0 ) + 1 NEW_LINE DEDENT DEDENT for x in m : NEW_LINE INDENT if m [ x ] == 1 : NEW_LINE INDENT res += x NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
REVERSE_@@ A_@@ STRING_@@ USING_@@ RECUR@@ SION | def reverse ( string ) : NEW_LINE INDENT if len ( string ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT temp = string [ 0 ] NEW_LINE reverse ( string [ 1 : ] ) NEW_LINE print ( temp , end = ' ' ) NEW_LINE DEDENT
PRINT@@ ING_@@ ITE@@ MS_@@ 01_@@ KN@@ AP@@ S@@ ACK | def print@@ kn@@ ap@@ S@@ ack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for w in range ( W + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT res = K [ n ] [ W ] NEW_LINE print ( res ) NEW_LINE w = W NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if res <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT if res == K [ i - 1 ] [ w ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( wt [ i - 1 ] ) NEW_LINE res = res - val [ i - 1 ] NEW_LINE w = w - wt [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT
FIND_@@ LAR@@ GE@@ ST_@@ PRI@@ ME_@@ FAC@@ TOR_@@ NUMBER | def max@@ Prime@@ Factors ( n ) : NEW_LINE INDENT max@@ Prime = - 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT max@@ Prime = 2 NEW_LINE n >>= 1 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT max@@ Prime = i NEW_LINE n = n / i NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT max@@ Prime = n NEW_LINE DEDENT return int ( max@@ Prime ) NEW_LINE DEDENT
FIND_@@ THE_@@ ELEMENT_@@ BEFORE_@@ WHI@@ CH_@@ ALL_@@ THE_@@ ELEMEN@@ TS_@@ ARE_@@ SM@@ ALL@@ ER_@@ TH@@ AN_@@ IT_@@ AND_@@ AFTER_@@ WHI@@ CH_@@ ALL_@@ ARE_@@ GREATER_@@ TH@@ AN_@@ IT | def findElement ( arr , n ) : NEW_LINE INDENT left@@ Max = [ None ] * n NEW_LINE left@@ Max [ 0 ] = float ( ' - inf ' ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT left@@ Max [ i ] = max ( left@@ Max [ i - 1 ] , arr [ i - 1 ] ) NEW_LINE DEDENT right@@ Min = float ( ' inf ' ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if left@@ Max [ i ] < arr [ i ] and right@@ Min > arr [ i ] : NEW_LINE INDENT return i NEW_LINE DEDENT right@@ Min = min ( right@@ Min , arr [ i ] ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
COMMON_@@ CHARAC@@ TER@@ S_@@ N_@@ STRINGS | def common@@ Characters ( strings , n ) : NEW_LINE INDENT prim = [ True ] * MAX_@@ CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT sec = [ False ] * MAX_@@ CHAR NEW_LINE for j in range ( len ( strings [ i ] ) ) : NEW_LINE INDENT if ( prim [ ord ( strings [ i ] [ j ] ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT sec [ ord ( strings [ i ] [ j ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT DEDENT for i in range ( MAX_@@ CHAR ) : NEW_LINE INDENT prim [ i ] = sec [ i ] NEW_LINE DEDENT DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( prim [ i ] ) : NEW_LINE INDENT print ( " % c ▁ " % ( i + ord ( ' a ' ) ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
MIN@@ IM@@ AL_@@ MOVE@@ S_@@ FORM_@@ STRING_@@ ADD@@ ING_@@ CHARAC@@ TER@@ S_@@ APP@@ END@@ ING_@@ STRING | def minim@@ al@@ Steps ( s , n ) : NEW_LINE INDENT dp = [ INT_MAX for i in range ( n ) ] NEW_LINE s1 = " " NEW_LINE s2 = " " NEW_LINE dp [ 0 ] = 1 NEW_LINE s1 += s [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s2 = s [ i + 1 : i + 1 + i + 1 ] NEW_LINE dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) NEW_LINE if ( s1 == s2 ) : NEW_LINE INDENT dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
S@@ UM_@@ MATRIX_@@ ELEMENT_@@ ABSOL@@ UTE_@@ DIFF@@ ER@@ ENCE_@@ ROW_@@ COLUMN_@@ NUMB@@ ERS_@@ 1 | def find@@ Sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += i * ( n - i ) NEW_LINE DEDENT return 2 * sum NEW_LINE DEDENT
FIND_@@ FREQU@@ ENCY_@@ EV@@ EN_@@ OD@@ D_@@ NUMB@@ ERS_@@ MATRIX | def freq ( ar , m , n ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( ar [ i ] [ j ] % 2 ) == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT DEDENT print ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = " , odd ) NEW_LINE print ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = " , even ) NEW_LINE DEDENT
COUNT_@@ SUB@@ ARRAY@@ S_@@ WITH@@ _S@@ AME_@@ EV@@ EN_@@ AND_@@ OD@@ D_@@ ELEMENTS | def count@@ Sub@@ arrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_@@ positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_@@ negative = [ 0 ] * ( n + 1 ) NEW_LINE hash_@@ positive [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 == 1 ) : NEW_LINE INDENT difference = difference + 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference = difference - 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_@@ negative [ - difference ] NEW_LINE hash_@@ negative [ - difference ] = hash_@@ negative [ - difference ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_@@ positive [ difference ] NEW_LINE hash_@@ positive [ difference ] = hash_@@ positive [ difference ] + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
PAS@@ CAL_@@ TRIANGLE_@@ 1 | def print@@ Pas@@ cal ( n ) : NEW_LINE INDENT for line in range ( 1 , n + 1 ) : NEW_LINE INDENT C = 1 ; NEW_LINE for i in range ( 1 , line + 1 ) : NEW_LINE INDENT print ( C , end = " ▁ " ) ; NEW_LINE C = int ( C * ( line - i ) / i ) ; NEW_LINE DEDENT print ( " " ) ; NEW_LINE DEDENT DEDENT
NUMBER_OF_@@ TRIANG@@ LES_@@ IN_@@ A_@@ PLA@@ NE_@@ IF_@@ NO_@@ MORE_@@ TH@@ AN_@@ TWO_@@ POINT@@ S_@@ ARE_@@ COL@@ LINEAR | def count@@ NumberOf@@ Triangles ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) * ( n - 2 ) // 6 ) NEW_LINE DEDENT
MERGE_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S_@@ O@@ 1_@@ EX@@ TRA@@ _SPACE | def merge ( ar@@ 1 , ar@@ 2 , m , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT last = ar@@ 1 [ m - 1 ] NEW_LINE j = m - 2 NEW_LINE while ( j >= 0 and ar@@ 1 [ j ] > ar@@ 2 [ i ] ) : NEW_LINE INDENT ar@@ 1 [ j + 1 ] = ar@@ 1 [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT if ( j != m - 2 or last > ar@@ 2 [ i ] ) : NEW_LINE INDENT ar@@ 1 [ j + 1 ] = ar@@ 2 [ i ] NEW_LINE ar@@ 2 [ i ] = last NEW_LINE DEDENT DEDENT DEDENT
NEW@@ MAN@@ _SH@@ AN@@ KS_@@ WI@@ LLI@@ AM@@ S_@@ PRI@@ ME | def n@@ sw@@ p ( n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 * n@@ sw@@ p ( n - 1 ) + n@@ sw@@ p ( n - 2 ) NEW_LINE DEDENT
SM@@ ALLE@@ ST_@@ OF_@@ THRE@@ E_@@ INTEG@@ ERS_@@ WITH@@ OUT_@@ COMP@@ ARIS@@ ON_@@ OPER@@ ATORS | def smallest ( x , y , z ) : NEW_LINE INDENT c = 0 NEW_LINE while ( x and y and z ) : NEW_LINE INDENT x = x - 1 NEW_LINE y = y - 1 NEW_LINE z = z - 1 NEW_LINE c = c + 1 NEW_LINE DEDENT return c NEW_LINE DEDENT
COUNT_@@ PAIR@@ S_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL_@@ GI@@ V@@ EN_@@ VALUE_@@ X | def count@@ Pairs ( ar@@ r1 , ar@@ r2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ar@@ r1 [ i ] + ar@@ r2 [ j ] == x : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
SORT_@@ ARRAY_@@ AP@@ PL@@ Y@@ ING_@@ GI@@ V@@ EN_@@ EQU@@ ATION | def sort@@ Array ( arr , n , A , B , C ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = ( A * arr [ i ] * arr [ i ] + B * arr [ i ] + C ) NEW_LINE DEDENT index = - ( sys . maxsize - 1 ) NEW_LINE maximum = - ( sys . maxsize - 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if maximum < arr [ i ] : NEW_LINE INDENT index = i NEW_LINE maximum = arr [ i ] NEW_LINE DEDENT DEDENT i = 0 ; j = n - 1 ; NEW_LINE new_@@ arr = [ 0 ] * n NEW_LINE k = 0 NEW_LINE while i < index and j > index : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT new_@@ arr [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT new_@@ arr [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT while i < index : NEW_LINE INDENT new_@@ arr [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT while j > index : NEW_LINE INDENT new_@@ arr [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j -= 1 NEW_LINE new_@@ arr [ n - 1 ] = maximum NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = new_@@ arr [ i ] NEW_LINE DEDENT DEDENT
PROGRAM_@@ TO_@@ FIND_@@ THE_@@ AREA_@@ OF_@@ PEN@@ TAG@@ ON | def find@@ Area ( a ) : NEW_LINE INDENT area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) ) * a * a ) / 4 NEW_LINE return area NEW_LINE DEDENT
MAXI@@ MI@@ ZE_@@ S@@ UM_@@ CON@@ SEC@@ UTI@@ VE_@@ DIFF@@ ER@@ EN@@ CES_@@ CIRC@@ ULAR_@@ ARRAY | def max@@ Sum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT sum -= ( 2 * arr [ i ] ) NEW_LINE sum += ( 2 * arr [ n - i - 1 ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
COUNT_@@ ARRAY@@ S_@@ CON@@ SEC@@ UTI@@ VE_@@ ELEMENT_@@ DIFF@@ ER@@ ENT_@@ VALUES | def coun@@ tar@@ ray ( n , k , x ) : NEW_LINE INDENT dp = list ( ) NEW_LINE dp . append ( 0 ) NEW_LINE dp . append ( 1 ) NEW_LINE i = 2 NEW_LINE while i < n : NEW_LINE INDENT dp . append ( ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ) NEW_LINE i = i + 1 NEW_LINE DEDENT return ( ( k - 1 ) * dp [ n - 2 ] if x == 1 else dp [ n - 1 ] ) NEW_LINE DEDENT
SUM@@ _SERI@@ ES_@@ 12_@@ 32_@@ 5@@ 2_@@ 2@@ N_@@ 12 | def sum@@ Of@@ Series ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
FIND_@@ THE_@@ NEARE@@ ST@@ _S@@ MAL@@ LER_@@ NUMB@@ ERS_@@ ON_@@ LEFT_@@ SIDE_@@ IN_@@ AN_@@ ARRAY_@@ 1 | def print@@ Prev@@ S@@ mal@@ ler ( arr , n ) : NEW_LINE INDENT S = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( len ( S ) > 0 and S [ - 1 ] >= arr [ i ] ) : NEW_LINE INDENT S . pop ( ) NEW_LINE DEDENT if ( len ( S ) == 0 ) : NEW_LINE INDENT print ( " _ , ▁ " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( S [ - 1 ] , end = " , ▁ " ) NEW_LINE DEDENT S . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT
FIND_@@ NUMBER_OF_@@ TRIANG@@ LES_@@ POSSI@@ BLE_@@ 1 | def Count@@ Triangles ( A ) : NEW_LINE INDENT n = len ( A ) ; NEW_LINE A . sort ( ) ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT l = 0 ; NEW_LINE r = i - 1 ; NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( A [ l ] + A [ r ] > A [ i ] ) : NEW_LINE INDENT count += r - l ; NEW_LINE r -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 ; NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ of ▁ possible ▁ solutions : ▁ " , count ) ; NEW_LINE DEDENT
MAXIMUM_@@ GAME@@ S_@@ PLAY@@ ED_@@ WIN@@ NER | def max@@ Game@@ By@@ Win@@ ner ( N ) : NEW_LINE INDENT dp = [ 0 for i in range ( N ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 2 NEW_LINE i = 1 NEW_LINE while dp [ i ] <= N : NEW_LINE INDENT i = i + 1 NEW_LINE dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] NEW_LINE DEDENT return ( i - 1 ) NEW_LINE DEDENT
NUMBER_@@ OF@@ _SUB@@ STRING@@ S_@@ WITH_@@ OD@@ D_@@ DECIMAL_@@ VALUE_@@ IN_@@ A_@@ BINARY_@@ STRING | def count@@ Sub@@ str ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE aux@@ Arr = [ 0 for i in range ( n ) ] NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT aux@@ Arr [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT aux@@ Arr [ i ] = aux@@ Arr [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT aux@@ Arr [ i ] = aux@@ Arr [ i - 1 ] NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count += aux@@ Arr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
ELEMEN@@ TS_@@ TO_@@ BE_@@ AD@@ DE@@ D_S@@ O_@@ TH@@ AT_@@ ALL_@@ ELEMEN@@ TS_@@ OF_@@ A_@@ RANGE_@@ ARE_@@ PRES@@ ENT_@@ IN_@@ ARRAY_@@ 1 | def count@@ Num ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE count , max@@ m , min@@ m = 0 , - 10 ** 9 , 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE if ( arr [ i ] < min@@ m ) : NEW_LINE INDENT min@@ m = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] > max@@ m ) : NEW_LINE INDENT max@@ m = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( min@@ m , max@@ m + 1 ) : NEW_LINE INDENT if i not in s . keys ( ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
WRITE_@@ A_@@ C_@@ PROGRAM_@@ TO_@@ CAL@@ CUL@@ ATE_@@ PO@@ WX@@ N_@@ 1 | def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : return 1 NEW_LINE temp = power ( x , int ( y / 2 ) ) NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT if ( y > 0 ) : return x * temp * temp NEW_LINE else : return ( temp * temp ) / x NEW_LINE DEDENT DEDENT
N_@@ TH_@@ TER@@ M@@ _SERI@@ ES_@@ 2_@@ 12_@@ 36@@ _@@ 8@@ 0_@@ 150 | def n@@ th@@ Term ( n ) : NEW_LINE INDENT return ( n * n ) + ( n * n * n ) NEW_LINE DEDENT
FIND_@@ THE_@@ NUMBER_@@ OC@@ CURR@@ ING_@@ OD@@ D_@@ NUMBER_OF_@@ TIMES | def getO@@ dd@@ Occurren@@ ce ( arr , arr_@@ size ) : NEW_LINE INDENT for i in range ( 0 , arr_@@ size ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , arr_@@ size ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count % 2 != 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
EF@@ FI@@ CI@@ ENT_@@ METHOD_@@ 2@@ S_@@ COMPLE@@ MENT_@@ BINARY_@@ STRING | def find@@ Tw@@ os@@ complement ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT return '1' + str NEW_LINE DEDENT k = i - 1 NEW_LINE while ( k >= 0 ) : NEW_LINE INDENT if ( str [ k ] == '1' ) : NEW_LINE INDENT str = list ( str ) NEW_LINE str [ k ] = '0' NEW_LINE str = ' ' . join ( str ) NEW_LINE DEDENT else : NEW_LINE INDENT str = list ( str ) NEW_LINE str [ k ] = '1' NEW_LINE str = ' ' . join ( str ) NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT return str NEW_LINE DEDENT
PAP@@ ER_@@ CU@@ T_@@ MINIMUM_@@ NUMBER@@ _S@@ QUAR@@ ES@@ _SET_@@ 2 | def minimum@@ Square ( m , n ) : NEW_LINE INDENT vertical@@ _min = 100000000@@ 00 NEW_LINE horizont@@ al_@@ min = 100000000@@ 00 NEW_LINE if m == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if dp [ m ] [ n ] != 0 : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT for i in range ( 1 , m // 2 + 1 ) : NEW_LINE INDENT horizont@@ al_@@ min = min ( minimum@@ Square ( i , n ) + minimum@@ Square ( m - i , n ) , horizont@@ al_@@ min ) NEW_LINE DEDENT for j in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT vertical@@ _min = min ( minimum@@ Square ( m , j ) + minimum@@ Square ( m , n - j ) , vertical@@ _min ) NEW_LINE DEDENT dp [ m ] [ n ] = min ( vertical@@ _min , horizont@@ al_@@ min ) NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT
MINI@@ MI@@ ZE_@@ ABSOL@@ UTE_@@ DIFF@@ ER@@ ENCE_@@ S@@ UM_@@ TW@@ O@@ _SUB@@ SETS | def sub@@ set@@ Difference ( n ) : NEW_LINE INDENT s = int ( n * ( n + 1 ) / 2 ) NEW_LINE if n % 4 == 0 : NEW_LINE INDENT print ( " First ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) ) NEW_LINE print ( " Second ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) ) NEW_LINE print ( " Difference ▁ = ▁ " , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if n % 4 == 1 or n % 4 == 2 : NEW_LINE INDENT print ( " First ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) ) NEW_LINE print ( " Second ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) + 1 ) NEW_LINE print ( " Difference ▁ = ▁ " , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " First ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) ) NEW_LINE print ( " Second ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) ) NEW_LINE print ( " Difference ▁ = ▁ " , 0 ) NEW_LINE DEDENT DEDENT DEDENT
PROGRAM_@@ CAL@@ CUL@@ ATE_@@ VOLUME_@@ ELLIP@@ SO@@ ID | def volume@@ Of@@ Ellip@@ soid ( r1 , r2 , r3 ) : NEW_LINE INDENT return 1.@@ 33 * math . pi * r1 * r2 * r3 NEW_LINE DEDENT
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 13@@ _C@@ UT@@ TING_@@ A_@@ RO@@ D | def cut@@ Ro@@ d ( price , n ) : NEW_LINE INDENT val = [ 0 for x in range ( n + 1 ) ] NEW_LINE val [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT max_@@ val = INT_@@ MIN NEW_LINE for j in range ( i ) : NEW_LINE INDENT max_@@ val = max ( max_@@ val , price [ j ] + val [ i - j - 1 ] ) NEW_LINE DEDENT val [ i ] = max_@@ val NEW_LINE DEDENT return val [ n ] NEW_LINE DEDENT
RECUR@@ SIVE_@@ INSER@@ TION@@ _S@@ ORT | def insertion@@ Sort@@ Recursive ( arr , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT insertion@@ Sort@@ Recursive ( arr , n - 1 ) NEW_LINE last = arr [ n - 1 ] NEW_LINE j = n - 2 NEW_LINE while ( j >= 0 and arr [ j ] > last ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT arr [ j + 1 ] = last NEW_LINE DEDENT
FIND_@@ EXPRES@@ SION_@@ DUPLIC@@ ATE_@@ PARENTHE@@ SI@@ S_@@ NOT | def find@@ Duplicate@@ parenthesis ( string ) : NEW_LINE INDENT Stack = [ ] NEW_LINE for ch in string : NEW_LINE INDENT if ch == ' ) ' : NEW_LINE INDENT top = Stack . pop ( ) NEW_LINE element@@ sIn@@ side = 0 NEW_LINE while top != ' ( ' : NEW_LINE INDENT element@@ sIn@@ side += 1 NEW_LINE top = Stack . pop ( ) NEW_LINE DEDENT if element@@ sIn@@ side < 1 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT Stack . append ( ch ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
FIND_@@ REPE@@ TI@@ TIVE_@@ ELEMENT_@@ 1_@@ N_@@ 1 | def find@@ Repe@@ ating ( arr , n ) : NEW_LINE INDENT return sum ( arr ) - ( ( ( n - 1 ) * n ) // 2 ) NEW_LINE DEDENT
CHECK_@@ ARRAY_@@ CONTAIN@@ S_@@ CON@@ TI@@ GU@@ OUS_@@ INTEG@@ ERS_@@ DUPLIC@@ ATE@@ S_@@ ALLOWED | def are@@ Elements@@ Contigu@@ ous ( arr , n ) : NEW_LINE INDENT max@@ 1 = max ( arr ) NEW_LINE min@@ 1 = min ( arr ) NEW_LINE m = max@@ 1 - min@@ 1 + 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited = [ 0 ] * m NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT visited [ arr [ i ] - min@@ 1 ] = True NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
LENGTH_@@ LON@@ GE@@ ST_@@ BAL@@ ANCE@@ D@@ _SUB@@ SEQU@@ ENCE_@@ 1 | def maxLength ( s , n ) : NEW_LINE INDENT invalid@@ Open@@ Br@@ aces = 0 ; NEW_LINE invalid@@ Close@@ Br@@ aces = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT invalid@@ Open@@ Br@@ aces += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( invalid@@ Open@@ Br@@ aces == 0 ) : NEW_LINE INDENT invalid@@ Close@@ Br@@ aces += 1 NEW_LINE DEDENT else : NEW_LINE INDENT invalid@@ Open@@ Br@@ aces -= 1 NEW_LINE DEDENT DEDENT DEDENT return ( n - ( invalid@@ Open@@ Br@@ aces + invalid@@ Close@@ Br@@ aces ) ) NEW_LINE DEDENT
SUM@@ _SERI@@ ES_@@ ALTER@@ N@@ ATE_@@ SIGNE@@ D_S@@ QUAR@@ ES_@@ AP_@@ 1 | def se@@ i@@ res@@ Sum ( n , a ) : NEW_LINE INDENT return ( n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ) NEW_LINE DEDENT
EQU@@ ILI@@ BRI@@ UM_@@ INDEX_@@ OF_@@ AN_@@ ARRAY | def equi@@ lib@@ ri@@ um ( arr ) : NEW_LINE INDENT left@@ sum = 0 NEW_LINE right@@ sum = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT left@@ sum = 0 NEW_LINE right@@ sum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT left@@ sum += arr [ j ] NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT right@@ sum += arr [ j ] NEW_LINE DEDENT if left@@ sum == right@@ sum : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
COUNT_@@ WAY@@ S_@@ REACH_@@ N@@ TH_@@ ST@@ AI@@ R_@@ USING_@@ STEP_@@ 1_2_@@ 3 | def find@@ Step ( n ) : NEW_LINE INDENT if ( n == 1 or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n == 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return find@@ Step ( n - 3 ) + find@@ Step ( n - 2 ) + find@@ Step ( n - 1 ) NEW_LINE DEDENT DEDENT
FIND_@@ MINIMUM_@@ NUMBER_OF_@@ CO@@ INS_@@ TH@@ AT_@@ MAKE_@@ A_@@ CHANGE | def min@@ Coins ( coins , m , V ) : NEW_LINE INDENT if ( V == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = sys . maxsize NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT if ( coins [ i ] <= V ) : NEW_LINE INDENT sub_@@ res = min@@ Coins ( coins , m , V - coins [ i ] ) NEW_LINE if ( sub_@@ res != sys . maxsize and sub_@@ res + 1 < res ) : NEW_LINE INDENT res = sub_@@ res + 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
B@@ ELL_@@ NUMB@@ ERS_@@ NUMBER_OF_@@ WAY@@ S_TO_@@ PARTITION_@@ A@@ _SET | def b@@ ell@@ Number ( n ) : NEW_LINE INDENT b@@ ell = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE b@@ ell [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT b@@ ell [ i ] [ 0 ] = b@@ ell [ i - 1 ] [ i - 1 ] NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT b@@ ell [ i ] [ j ] = b@@ ell [ i - 1 ] [ j - 1 ] + b@@ ell [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return b@@ ell [ n ] [ 0 ] NEW_LINE DEDENT
FIND_@@ ELEMENT_@@ GI@@ V@@ EN_@@ INDEX_@@ NUMBER_@@ ROTA@@ TIONS | def findElement ( arr , ranges , rot@@ ations , index ) : NEW_LINE INDENT for i in range ( rot@@ ations - 1 , - 1 , - 1 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if ( left <= index and right >= index ) : NEW_LINE INDENT if ( index == left ) : NEW_LINE INDENT index = right NEW_LINE DEDENT else : NEW_LINE INDENT index = index - 1 NEW_LINE DEDENT DEDENT DEDENT return arr [ index ] NEW_LINE DEDENT
DY@@ CK_@@ PATH | def count@@ Dy@@ ck@@ Paths ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res *= ( 2 * n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE DEDENT return res / ( n + 1 ) NEW_LINE DEDENT
COUN@@ TING_@@ PAIR@@ S_@@ PERS@@ ON_@@ CAN_@@ FORM_@@ PA@@ IR_@@ ONE | def numberOf@@ W@@ ays ( x ) : NEW_LINE INDENT if x == 0 or x == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( numberOf@@ W@@ ays ( x - 1 ) + ( x - 1 ) * numberOf@@ W@@ ays ( x - 2 ) ) NEW_LINE DEDENT DEDENT
PROGRAM_@@ DISPLAY_@@ A@@ STRO@@ LOG@@ IC@@ AL@@ _SIGN@@ _@@ ZO@@ DI@@ AC@@ _SIGN@@ _@@ GI@@ V@@ EN_@@ DATE_@@ B@@ IR@@ TH | def zo@@ di@@ ac_@@ sign ( day , month ) : NEW_LINE INDENT if month == ' de@@ ce@@ mber ' : NEW_LINE INDENT ast@@ ro_@@ sign = ' S@@ ag@@ it@@ t@@ ari@@ us ' if ( day < 22 ) else ' cap@@ ri@@ cor@@ n ' NEW_LINE DEDENT elif month == ' j@@ anuary ' : NEW_LINE INDENT ast@@ ro_@@ sign = ' Cap@@ ri@@ cor@@ n ' if ( day < 20 ) else ' a@@ qu@@ ari@@ us ' NEW_LINE DEDENT elif month == ' fe@@ bruary ' : NEW_LINE INDENT ast@@ ro_@@ sign = ' A@@ qu@@ ari@@ us ' if ( day < 19 ) else ' p@@ is@@ ces ' NEW_LINE DEDENT elif month == ' mar@@ ch ' : NEW_LINE INDENT ast@@ ro_@@ sign = ' P@@ is@@ ces ' if ( day < 21 ) else ' aries ' NEW_LINE DEDENT elif month == ' ap@@ ri@@ l ' : NEW_LINE INDENT ast@@ ro_@@ sign = ' Ari@@ es ' if ( day < 20 ) else ' ta@@ ur@@ us ' NEW_LINE DEDENT elif month == ' may ' : NEW_LINE INDENT ast@@ ro_@@ sign = ' Ta@@ ur@@ us ' if ( day < 21 ) else ' ge@@ mini ' NEW_LINE DEDENT elif month == ' jun@@ e ' : NEW_LINE INDENT ast@@ ro_@@ sign = ' Ge@@ mini ' if ( day < 21 ) else ' can@@ cer ' NEW_LINE DEDENT elif month == ' j@@ uly ' : NEW_LINE INDENT ast@@ ro_@@ sign = ' Can@@ cer ' if ( day < 23 ) else ' le@@ o ' NEW_LINE DEDENT elif month == ' au@@ gu@@ st ' : NEW_LINE INDENT ast@@ ro_@@ sign = ' Le@@ o ' if ( day < 23 ) else ' vir@@ go ' NEW_LINE DEDENT elif month == ' sep@@ tember ' : NEW_LINE INDENT ast@@ ro_@@ sign = ' Vi@@ r@@ go ' if ( day < 23 ) else ' libr@@ a ' NEW_LINE DEDENT elif month == ' oc@@ to@@ ber ' : NEW_LINE INDENT ast@@ ro_@@ sign = ' Libr@@ a ' if ( day < 23 ) else ' scor@@ p@@ io ' NEW_LINE DEDENT elif month == ' no@@ vember ' : NEW_LINE INDENT ast@@ ro_@@ sign = ' scor@@ p@@ io ' if ( day < 22 ) else ' sag@@ it@@ t@@ ari@@ us ' NEW_LINE DEDENT print ( ast@@ ro_@@ sign ) NEW_LINE DEDENT
PROGRAM_@@ REVERSE_@@ STRING_@@ ITER@@ ATI@@ VE_@@ RECUR@@ SIVE_@@ 2 | def recursive@@ Reverse ( str , i = 0 ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if i == n // 2 : NEW_LINE INDENT return NEW_LINE DEDENT str [ i ] , str [ n - i - 1 ] = str [ n - i - 1 ] , str [ i ] NEW_LINE recursive@@ Reverse ( str , i + 1 ) NEW_LINE DEDENT
K_@@ TH_@@ DIG@@ IT_@@ RAI@@ SED_@@ POWER_@@ B | def k@@ th@@ digit ( a , b , k ) : NEW_LINE INDENT p = a ** b NEW_LINE count = 0 NEW_LINE while ( p > 0 and count < k ) : NEW_LINE INDENT rem = p % 10 NEW_LINE count = count + 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT return rem NEW_LINE DEDENT p = p / 10 ; NEW_LINE DEDENT DEDENT
SM@@ ALLE@@ ST_@@ DIFF@@ ER@@ ENCE_@@ PA@@ IR_@@ VALU@@ ES_@@ TWO_@@ UN@@ SOR@@ TED_@@ ARRAY@@ S | def find@@ S@@ malle@@ st@@ Difference ( A , B , m , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE result = sys . maxsize NEW_LINE while ( a < m and b < n ) : NEW_LINE INDENT if ( abs ( A [ a ] - B [ b ] ) < result ) : NEW_LINE INDENT result = abs ( A [ a ] - B [ b ] ) NEW_LINE DEDENT if ( A [ a ] < B [ b ] ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
MAXIMUM_@@ AREA_@@ REC@@ TAN@@ GLE_@@ PIC@@ KING_@@ FOUR@@ _SI@@ DES_@@ ARRAY_@@ 1 | def find@@ Area ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE first = 0 NEW_LINE second = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . append ( arr [ i ] ) NEW_LINE continue NEW_LINE DEDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT return ( first * second ) NEW_LINE DEDENT
PROGRAM_@@ PAGE_@@ REPLACE@@ MENT_@@ ALGORITH@@ MS@@ _SET_@@ 2_@@ FIFO | def page@@ Fa@@ ults ( pages , n , capacity ) : NEW_LINE INDENT s = set ( ) NEW_LINE indexes = Queue ( ) NEW_LINE page_@@ fa@@ ults = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( len ( s ) < capacity ) : NEW_LINE INDENT if ( pages [ i ] not in s ) : NEW_LINE INDENT s . add ( pages [ i ] ) NEW_LINE page_@@ fa@@ ults += 1 NEW_LINE indexes . put ( pages [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( pages [ i ] not in s ) : NEW_LINE INDENT val = indexes . queue [ 0 ] NEW_LINE indexes . get ( ) NEW_LINE s . remove ( val ) NEW_LINE s . add ( pages [ i ] ) NEW_LINE indexes . put ( pages [ i ] ) NEW_LINE page_@@ fa@@ ults += 1 NEW_LINE DEDENT DEDENT DEDENT return page_@@ fa@@ ults NEW_LINE DEDENT
FIND_@@ LAR@@ GE@@ ST_@@ D_@@ IN_@@ ARRAY@@ _SU@@ CH_@@ TH@@ AT_@@ A_@@ B_@@ C_@@ D_@@ 1 | def find@@ Four@@ Elements ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = ( i , j ) NEW_LINE DEDENT DEDENT d = - 10 ** 9 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT abs_@@ diff = abs ( arr [ i ] - arr [ j ] ) NEW_LINE if abs_@@ diff in mp . keys ( ) : NEW_LINE INDENT p = mp [ abs_@@ diff ] NEW_LINE if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) : NEW_LINE INDENT d = max ( d , max ( arr [ i ] , arr [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return d NEW_LINE DEDENT
PRINT_@@ GI@@ V@@ EN_@@ MATRIX_@@ REVERSE_@@ SPIR@@ AL_@@ FORM | def Reverse@@ spir@@ al@@ Print ( m , n , a ) : NEW_LINE INDENT b = [ 0 for i in range ( 100 ) ] NEW_LINE i , k , l = 0 , 0 , 0 NEW_LINE z = 0 NEW_LINE size = m * n NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT val = 0 NEW_LINE for i in range ( l , n ) : NEW_LINE INDENT val = a [ k ] [ i ] NEW_LINE b [ z ] = val NEW_LINE z += 1 NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT val = a [ i ] [ n - 1 ] NEW_LINE b [ z ] = val NEW_LINE z += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if ( k < m ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT val = a [ m - 1 ] [ i ] NEW_LINE b [ z ] = val NEW_LINE z += 1 NEW_LINE DEDENT DEDENT m -= 1 NEW_LINE if ( l < n ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT val = a [ i ] [ l ] NEW_LINE b [ z ] = val NEW_LINE z += 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT for i in range ( size - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
NUMBER_@@ N_@@ DIG@@ IT@@ S_@@ NON_@@ DECRE@@ AS@@ ING_@@ INTEG@@ ERS | def non@@ Dec@@ Num@@ s ( n ) : NEW_LINE INDENT a = np . zeros ( ( n + 1 , 10 ) ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT a [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] [ 9 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 8 , - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT return int ( a [ n ] [ 0 ] ) NEW_LINE DEDENT
LON@@ GE@@ ST_@@ EV@@ EN_@@ LENGTH@@ _SUB@@ STRING@@ _S@@ UM_@@ FIR@@ ST@@ _SECON@@ D_@@ HALF | def find@@ Length ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxlen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 2 ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE left@@ sum = 0 NEW_LINE right@@ sum = 0 NEW_LINE for k in range ( 0 , int ( length / 2 ) ) : NEW_LINE INDENT left@@ sum += ( int ( str [ i + k ] ) - int ( '0' ) ) NEW_LINE right@@ sum += ( int ( str [ i + k + int ( length / 2 ) ] ) - int ( '0' ) ) NEW_LINE DEDENT if ( left@@ sum == right@@ sum and maxlen < length ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT
PROGRAM_@@ WOR@@ ST_@@ FI@@ T_@@ ALGORITH@@ M_@@ MEMORY_@@ MAN@@ A@@ GEMENT | def wor@@ st@@ Fit ( blockSize , m , process@@ Size , n ) : NEW_LINE INDENT allocation = [ - 1 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT w@@ st@@ Idx = - 1 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if blockSize [ j ] >= process@@ Size [ i ] : NEW_LINE INDENT if w@@ st@@ Idx == - 1 : NEW_LINE INDENT w@@ st@@ Idx = j NEW_LINE DEDENT elif blockSize [ w@@ st@@ Idx ] < blockSize [ j ] : NEW_LINE INDENT w@@ st@@ Idx = j NEW_LINE DEDENT DEDENT DEDENT if w@@ st@@ Idx != - 1 : NEW_LINE INDENT allocation [ i ] = w@@ st@@ Idx NEW_LINE blockSize [ w@@ st@@ Idx ] -= process@@ Size [ i ] NEW_LINE DEDENT DEDENT print ( " Process ▁ No . ▁ Process ▁ Size ▁ Block ▁ no . " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( i + 1 , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , process@@ Size [ i ] , end = " ▁ ▁ ▁ ▁ ▁ " ) NEW_LINE if allocation [ i ] != - 1 : NEW_LINE INDENT print ( allocation [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT DEDENT
SUM@@ _SUB@@ SET@@ S@@ _SET_@@ FOR@@ MED_@@ FIRST_@@ N_@@ N@@ ATUR@@ AL_@@ NUMB@@ ERS | def find@@ Sum@@ Sub@@ sets ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) NEW_LINE DEDENT
ADD_@@ TWO_@@ NUMB@@ ERS_@@ WITH@@ OUT_@@ USING_@@ ARI@@ TH@@ ME@@ TIC_@@ OPER@@ ATORS | def Add ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT carry = x & y NEW_LINE x = x ^ y NEW_LINE y = carry << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT
MAXIMUM_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENT_@@ TER@@ M_@@ VALUE | def max@@ coeffici@@ ent@@ value ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT max@@ value = 0 ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT max@@ value = max ( max@@ value , C [ n ] [ i ] ) ; NEW_LINE DEDENT return max@@ value ; NEW_LINE DEDENT
E@@ UL@@ ERI@@ AN_@@ PATH_@@ UN@@ DIREC@@ TED_@@ GRAP@@ H | def find@@ path ( graph ) : NEW_LINE INDENT n = len ( graph ) NEW_LINE nu@@ mo@@ f@@ adj = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT nu@@ mo@@ f@@ adj . append ( sum ( graph [ i ] ) ) NEW_LINE DEDENT start@@ point = 0 NEW_LINE nu@@ mo@@ fo@@ dd = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( nu@@ mo@@ f@@ adj [ i ] % 2 == 1 ) : NEW_LINE INDENT nu@@ mo@@ fo@@ dd += 1 NEW_LINE start@@ point = i NEW_LINE DEDENT DEDENT if ( nu@@ mo@@ fo@@ dd > 2 ) : NEW_LINE INDENT print ( " No ▁ Solution " ) NEW_LINE return NEW_LINE DEDENT stack = list ( ) NEW_LINE path = list ( ) NEW_LINE cur = start@@ point NEW_LINE while ( stack != [ ] or sum ( graph [ cur ] ) != 0 ) : NEW_LINE INDENT if ( sum ( graph [ cur ] ) == 0 ) : NEW_LINE INDENT path . append ( cur + 1 ) NEW_LINE cur = stack . pop ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if graph [ cur ] [ i ] == 1 : NEW_LINE INDENT stack . append ( cur ) NEW_LINE graph [ cur ] [ i ] = 0 NEW_LINE graph [ i ] [ cur ] = 0 NEW_LINE cur = i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT for ele in path : NEW_LINE INDENT print ( ele , " - > ▁ " , end = ' ' ) NEW_LINE DEDENT print ( cur + 1 ) NEW_LINE DEDENT
RECUR@@ SIVE_@@ SOLU@@ TION_@@ COUNT_@@ SUB@@ STRING@@ S_@@ FIRST_@@ LAST_@@ CHARAC@@ TERS | def count@@ Sub@@ strs ( str , i , j , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = ( count@@ Sub@@ strs ( str , i + 1 , j , n - 1 ) + count@@ Sub@@ strs ( str , i , j - 1 , n - 1 ) - count@@ Sub@@ strs ( str , i + 1 , j - 1 , n - 2 ) ) NEW_LINE if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
FIND_@@ NUMBER_@@ TIME@@ S_@@ STRING_@@ OC@@ CUR@@ S_@@ GI@@ V@@ EN_@@ STRING_@@ 1 | def count ( a , b ) : NEW_LINE INDENT m = len ( a ) NEW_LINE n = len ( b ) NEW_LINE lookup = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT lookup [ 0 ] [ i ] = 0 NEW_LINE DEDENT for i in range ( m + 1 ) : NEW_LINE INDENT lookup [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if a [ i - 1 ] == b [ j - 1 ] : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return lookup [ m ] [ n ] NEW_LINE DEDENT
AREA_@@ OF_@@ A_@@ POLYG@@ ON_@@ WITH_@@ GI@@ V@@ EN_@@ N_@@ ORDE@@ RED_@@ VER@@ TIC@@ ES | def polygon@@ Area ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE j = i NEW_LINE DEDENT return int ( abs ( area / 2.0 ) ) NEW_LINE DEDENT
PRINT_@@ POSSI@@ BLE_@@ SUM@@ S_@@ CON@@ SEC@@ UTI@@ VE_@@ NUMBER@@ S_S@@ UM_@@ N | def find@@ Con@@ sec@@ utive ( N ) : NEW_LINE INDENT start = 1 NEW_LINE end = ( N + 1 ) // 2 NEW_LINE while ( start < end ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT Sum = Sum + i NEW_LINE if ( Sum == N ) : NEW_LINE INDENT for j in range ( start , i + 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE break NEW_LINE DEDENT if ( Sum > N ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT Sum = 0 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT
BAL@@ AN@@ CED_@@ EXPRES@@ SION@@ S@@ _SU@@ CH_@@ TH@@ AT_@@ GI@@ V@@ EN_@@ POSI@@ TIONS_@@ HAVE_@@ OPEN@@ ING_@@ BRAC@@ KETS | def arrange@@ Br@@ aces ( n , pos , k ) : NEW_LINE INDENT h = [ False for i in range ( N ) ] NEW_LINE dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT h [ pos [ i ] ] = 1 NEW_LINE DEDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 2 * n + 1 ) : NEW_LINE INDENT for j in range ( 2 * n + 1 ) : NEW_LINE INDENT if ( h [ i ] ) : NEW_LINE INDENT if ( j != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( j != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ 2 * n ] [ 0 ] NEW_LINE DEDENT
GI@@ V@@ EN_@@ 1@@ S_@@ 2@@ S_@@ 3@@ S_@@ KS_@@ PRINT_@@ ZI@@ G_@@ Z@@ A@@ G_@@ WAY | def Z@@ ig@@ Z@@ ag ( rows , columns , numbers ) : NEW_LINE INDENT k = 0 NEW_LINE arr = [ [ 0 for i in range ( columns ) ] for j in range ( rows ) ] NEW_LINE for i in range ( rows ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT j = 0 NEW_LINE while j < columns and numbers [ k ] > 0 : NEW_LINE INDENT arr [ i ] [ j ] = k + 1 NEW_LINE numbers [ k ] -= 1 NEW_LINE if numbers [ k ] == 0 : NEW_LINE INDENT k += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT j = columns - 1 NEW_LINE while j >= 0 and numbers [ k ] > 0 : NEW_LINE INDENT arr [ i ] [ j ] = k + 1 NEW_LINE numbers [ k ] -= 1 NEW_LINE if numbers [ k ] == 0 : NEW_LINE INDENT k += 1 NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT DEDENT DEDENT for i in arr : NEW_LINE INDENT for j in i : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
CONVERT_@@ STRING_@@ BIN@@ AR@@ Y@@ _SEQU@@ ENCE | def str@@ To@@ Binary ( s ) : NEW_LINE INDENT bin_@@ conv = [ ] NEW_LINE for c in s : NEW_LINE INDENT ascii_@@ val = ord ( c ) NEW_LINE binary_@@ val = bin ( ascii_@@ val ) NEW_LINE bin_@@ conv . append ( binary_@@ val [ 2 : ] ) NEW_LINE DEDENT return ( ' ▁ ' . join ( bin_@@ conv ) ) NEW_LINE DEDENT
L@@ UC@@ K@@ Y_@@ NUMB@@ ERS | def is@@ Lu@@ ck@@ y ( n ) : NEW_LINE INDENT next_@@ position = n NEW_LINE if is@@ Lu@@ ck@@ y . counter > n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n % is@@ Lu@@ ck@@ y . counter == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT next_@@ position = next_@@ position - next_@@ position / is@@ Lu@@ ck@@ y . counter NEW_LINE is@@ Lu@@ ck@@ y . counter = is@@ Lu@@ ck@@ y . counter + 1 NEW_LINE return is@@ Lu@@ ck@@ y ( next_@@ position ) NEW_LINE DEDENT
SM@@ ALLE@@ ST@@ _S@@ UM_@@ CON@@ TI@@ GU@@ OU@@ S@@ _SUB@@ ARRAY | def smalle@@ st@@ Sum@@ Sub@@ arr ( arr , n ) : NEW_LINE INDENT min_@@ ending_@@ here = sys . maxsize NEW_LINE min_@@ so@@ _f@@ ar = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( min_@@ ending_@@ here > 0 ) : NEW_LINE INDENT min_@@ ending_@@ here = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT min_@@ ending_@@ here += arr [ i ] NEW_LINE DEDENT min_@@ so@@ _f@@ ar = min ( min_@@ so@@ _f@@ ar , min_@@ ending_@@ here ) NEW_LINE DEDENT return min_@@ so@@ _f@@ ar NEW_LINE DEDENT
PRINT_@@ N_@@ TER@@ MS_@@ NEW@@ MAN_@@ CON@@ WAY@@ _SEQU@@ ENCE | def sequence ( n ) : NEW_LINE INDENT f = [ 0 , 1 , 1 ] NEW_LINE print ( f [ 1 ] , end = " ▁ " ) , NEW_LINE print ( f [ 2 ] , end = " ▁ " ) , NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT f . append ( f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ) NEW_LINE print ( f [ i ] , end = " ▁ " ) , NEW_LINE DEDENT DEDENT
MASTER_@@ THE@@ O@@ RE@@ M@@ _SUB@@ TRAC@@ T_@@ CON@@ QU@@ ER_@@ RE@@ CURR@@ EN@@ CES | def fi@@ b ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return fi@@ b ( n - 1 ) + fi@@ b ( n - 2 ) NEW_LINE DEDENT
MINIMUM_@@ CO@@ ST_@@ MAKE_@@ ARRAY@@ _SIZE_@@ 1_@@ REMO@@ V@@ ING_@@ L@@ ARG@@ ER_@@ PAIR@@ S | def cost ( a , n ) : NEW_LINE INDENT return ( ( n - 1 ) * min ( a ) ) NEW_LINE DEDENT
CHO@@ COL@@ ATE_@@ DISTRIBU@@ TION_@@ PRO@@ BLE@@ M | def find@@ Min@@ Diff ( arr , n , m ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE if ( n < m ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT min_@@ diff = sys . maxsize NEW_LINE first = 0 NEW_LINE last = 0 NEW_LINE i = 0 NEW_LINE while ( i + m - 1 < n ) : NEW_LINE INDENT diff = arr [ i + m - 1 ] - arr [ i ] NEW_LINE if ( diff < min_@@ diff ) : NEW_LINE INDENT min_@@ diff = diff NEW_LINE first = i NEW_LINE last = i + m - 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( arr [ last ] - arr [ first ] ) NEW_LINE DEDENT
FIND_@@ ONE_@@ EXTRA_@@ CHARACTER_@@ STRING_@@ 1 | def find@@ Extra@@ Char@@ c@@ ter ( str@@ A , str@@ B ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , len ( str@@ A ) ) : NEW_LINE INDENT res = res ^ ( ord ) ( str@@ A [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ( str@@ B ) ) : NEW_LINE INDENT res = res ^ ( ord ) ( str@@ B [ i ] ) NEW_LINE DEDENT return ( ( chr ) ( res ) ) ; NEW_LINE DEDENT
CHECK_@@ WHE@@ THER_@@ TWO_@@ STRING@@ S_@@ ARE_@@ AN@@ AG@@ RAM_@@ OF_@@ E@@ ACH@@ _@@ OTHER | def are@@ An@@ agram ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if n1 != n2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT str1 = sorted ( str1 ) NEW_LINE str2 = sorted ( str2 ) NEW_LINE for i in range ( 0 , n1 ) : NEW_LINE INDENT if str1 [ i ] != str2 [ i ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
CAL@@ CUL@@ ATE_@@ MAXIMUM_@@ VALUE_@@ US@@ ING@@ _SIGN@@ _@@ TWO_@@ NUMB@@ ERS_@@ STRING | def calc@@ Max@@ Value ( str ) : NEW_LINE INDENT res = ord ( str [ 0 ] ) - 48 NEW_LINE for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '0' or str [ i ] == '1' or res < 2 ) : NEW_LINE INDENT res += ord ( str [ i ] ) - 48 NEW_LINE DEDENT else : NEW_LINE INDENT res *= ord ( str [ i ] ) - 48 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
FIN@@ D_S@@ UM_@@ MODUL@@ O_@@ K_@@ FIRST_@@ N_@@ N@@ ATUR@@ AL_@@ NUMBER | def find@@ Sum ( N , K ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += ( i % K ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
DISTRIBU@@ TING_@@ ITE@@ MS_@@ PERS@@ ON_@@ CANNOT_@@ TA@@ KE_@@ TWO_@@ ITE@@ MS_@@ TYPE_@@ 1 | def check@@ Count ( arr , n , k ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for key , values in mp . items ( ) : NEW_LINE INDENT if values > 2 * k : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
SEARCH_@@ IN_@@ ROW_@@ WI@@ SE_@@ AND_@@ COLUMN_@@ WI@@ SE_@@ SOR@@ TED_@@ MATRIX | def search ( mat , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < n and j >= 0 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == x ) : NEW_LINE INDENT print ( " n ▁ Found ▁ at ▁ " , i , " , ▁ " , j ) NEW_LINE return 1 NEW_LINE DEDENT if ( mat [ i ] [ j ] > x ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( " Element ▁ not ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT
RETURN_@@ PREVI@@ OUS_@@ ELEMENT_@@ IN_@@ AN_@@ EXP@@ AND@@ ING_@@ MATRIX | def find@@ Left ( str ) : NEW_LINE INDENT n = len ( str ) - 1 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( str [ n ] == ' d ' ) : NEW_LINE INDENT str = str [ 0 : n ] + ' c ' + str [ n + 1 : ] ; NEW_LINE break ; NEW_LINE DEDENT if ( str [ n ] == ' b ' ) : NEW_LINE INDENT str = str [ 0 : n ] + ' a ' + str [ n + 1 : ] ; NEW_LINE break ; NEW_LINE DEDENT if ( str [ n ] == ' a ' ) : NEW_LINE INDENT str = str [ 0 : n ] + ' b ' + str [ n + 1 : ] ; NEW_LINE DEDENT elif ( str [ n ] == ' c ' ) : NEW_LINE INDENT str = str [ 0 : n ] + ' d ' + str [ n + 1 : ] ; NEW_LINE DEDENT n -= 1 ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT
S@@ UM_@@ FAC@@ TOR@@ S_@@ NUMBER | def div@@ Sum ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i == ( n / i ) ) : NEW_LINE INDENT result = result + i NEW_LINE DEDENT else : NEW_LINE INDENT result = result + ( i + n // i ) NEW_LINE DEDENT DEDENT DEDENT return ( result + n + 1 ) NEW_LINE DEDENT
HO@@ W_@@ CAN_@@ W@@ E_@@ S@@ UM_@@ THE_@@ DIG@@ IT@@ S_@@ OF_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ IN@@ _SIN@@ GLE_@@ STATE@@ MENT_@@ 2 | def sum@@ Digits ( no ) : NEW_LINE INDENT return 0 if no == 0 else int ( no % 10 ) + sum@@ Digits ( int ( no / 10 ) ) NEW_LINE DEDENT
CHECK_@@ POSSI@@ BLE_@@ SORT_@@ ARRAY_@@ CONDITION@@ AL@@ _SW@@ APP@@ ING_@@ AD@@ J@@ AC@@ ENT_@@ ALLOWED | def checkFor@@ Sorting ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i + 1 ] == 1 ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
SUP@@ ER_@@ PRI@@ ME | def Si@@ eve@@ Of@@ Er@@ ato@@ sth@@ en@@ es ( n , is@@ Prime ) : NEW_LINE INDENT is@@ Prime [ 0 ] = is@@ Prime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT is@@ Prime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( p * p <= n and is@@ Prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT is@@ Prime [ i ] = False NEW_LINE p += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
PROGRAM_@@ BINARY_@@ DECIMAL_@@ CON@@ VERSION_@@ 1 | def binary@@ To@@ Decimal ( n ) : NEW_LINE INDENT num = n ; NEW_LINE dec_@@ value = 0 ; NEW_LINE base@@ 1 = 1 ; NEW_LINE len1 = len ( num ) ; NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( num [ i ] == '1' ) : NEW_LINE INDENT dec_@@ value += base@@ 1 ; NEW_LINE DEDENT base@@ 1 = base@@ 1 * 2 ; NEW_LINE DEDENT return dec_@@ value ; NEW_LINE DEDENT
LE@@ ON@@ AR@@ DO_@@ NUMBER | def le@@ on@@ ar@@ do ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( le@@ on@@ ar@@ do ( n - 1 ) + le@@ on@@ ar@@ do ( n - 2 ) + 1 ) ; NEW_LINE DEDENT
CHECK_@@ ARRAY_@@ CONTAIN@@ S_@@ CON@@ TI@@ GU@@ OUS_@@ INTEG@@ ERS_@@ DUPLIC@@ ATE@@ S_@@ ALLOWED_@@ 1 | def are@@ Elements@@ Contigu@@ ous ( arr ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in arr : us . add ( i ) NEW_LINE count = 1 NEW_LINE curr_@@ ele = arr [ 0 ] - 1 NEW_LINE while curr_@@ ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_@@ ele -= 1 NEW_LINE DEDENT curr_@@ ele = arr [ 0 ] + 1 NEW_LINE while curr_@@ ele in us : NEW_LINE INDENT count += 1 NEW_LINE curr_@@ ele += 1 NEW_LINE DEDENT return ( count == len ( us ) ) NEW_LINE DEDENT
SQU@@ ARE_@@ ROOT_@@ OF_@@ AN_@@ INTEGER | def floor@@ Sqrt ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT i = 1 ; result = 1 NEW_LINE while ( result <= x ) : NEW_LINE INDENT i += 1 NEW_LINE result = i * i NEW_LINE DEDENT return i - 1 NEW_LINE DEDENT
LE@@ XI@@ CO@@ GRAPHIC@@ AL@@ LY_@@ LAR@@ GE@@ ST@@ _SUB@@ SEQU@@ ENCE_@@ EVER@@ Y_@@ CHARACTER_@@ OC@@ CUR@@ S_@@ LEA@@ ST_@@ K_@@ TIMES | def sub@@ sequence ( s , t , n , k ) : NEW_LINE INDENT last = 0 NEW_LINE cnt = 0 NEW_LINE new_@@ last = 0 NEW_LINE size = 0 NEW_LINE string = ' zy@@ x@@ w@@ v@@ ut@@ sr@@ qp@@ on@@ ml@@ k@@ ji@@ hg@@ fed@@ cb@@ a ' NEW_LINE for ch in string : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( last , n ) : NEW_LINE INDENT if s [ i ] == ch : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if cnt >= k : NEW_LINE INDENT for i in range ( last , n ) : NEW_LINE INDENT if s [ i ] == ch : NEW_LINE INDENT t [ size ] = ch NEW_LINE new_@@ last = i NEW_LINE size += 1 NEW_LINE DEDENT DEDENT last = new_@@ last NEW_LINE DEDENT DEDENT DEDENT
RECUR@@ SI@@ VEL@@ Y_@@ BREAK_@@ NUMBER_@@ 3_@@ PAR@@ TS_@@ GET_@@ MAX@@ IM@@ UM@@ _S@@ UM | def break@@ Sum ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return max ( ( break@@ Sum ( n // 2 ) + break@@ Sum ( n // 3 ) + break@@ Sum ( n // 4 ) ) , n ) NEW_LINE DEDENT
MINIMUM_@@ NUMBER@@ _SW@@ AP@@ S_@@ REQUI@@ RE@@ D_S@@ ORT_@@ ARRAY | def min@@ Sw@@ aps ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arr@@ pos = [ * enumerate ( arr ) ] NEW_LINE arr@@ pos . sort ( key = lambda it : it [ 1 ] ) NEW_LINE vis = { k : False for k in range ( n ) } NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if vis [ i ] or arr@@ pos [ i ] [ 0 ] == i : NEW_LINE INDENT continue NEW_LINE DEDENT cycle@@ _size = 0 NEW_LINE j = i NEW_LINE while not vis [ j ] : NEW_LINE INDENT vis [ j ] = True NEW_LINE j = arr@@ pos [ j ] [ 0 ] NEW_LINE cycle@@ _size += 1 NEW_LINE DEDENT if cycle@@ _size > 0 : NEW_LINE INDENT ans += ( cycle@@ _size - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
DIAG@@ ON@@ AL@@ LY_@@ DO@@ MIN@@ ANT_@@ MATRIX | def is@@ DD@@ M ( m , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT sum = sum + abs ( m [ i ] [ j ] ) NEW_LINE DEDENT sum = sum - abs ( m [ i ] [ i ] ) NEW_LINE if ( abs ( m [ i ] [ i ] ) < sum ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
SP@@ LIT_@@ N_@@ MAXIMUM_@@ COMPOSI@@ TE_@@ NUMB@@ ERS | def count ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT rem = n % 4 NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return n // 4 NEW_LINE DEDENT if ( rem == 1 ) : NEW_LINE INDENT if ( n < 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( n - 9 ) // 4 + 1 NEW_LINE DEDENT if ( rem == 2 ) : NEW_LINE INDENT return ( n - 6 ) // 4 + 1 NEW_LINE DEDENT if ( rem == 3 ) : NEW_LINE INDENT if ( n < 15 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( n - 15 ) // 4 + 2 NEW_LINE DEDENT DEDENT
FIND_@@ DIMEN@@ SION@@ S_@@ RIGHT_@@ ANG@@ LED_@@ TRI@@ ANGLE | def find@@ Di@@ men ( H , A ) : NEW_LINE INDENT if H * H < 4 * A : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE return NEW_LINE DEDENT ap@@ b = sqrt ( H * H + 4 * A ) NEW_LINE as@@ b = sqrt ( H * H - 4 * A ) NEW_LINE print ( " P ▁ = ▁ " , " % .2f " % ( ( ap@@ b - as@@ b ) / 2.0 ) ) NEW_LINE print ( " B ▁ = ▁ " , " % .2f " % ( ( ap@@ b + as@@ b ) / 2.0 ) ) NEW_LINE DEDENT
PRODUCT_@@ MAXIMUM_@@ FIRST_@@ ARRAY_@@ MIN@@ IM@@ UM@@ _SECON@@ D_@@ 1 | def min@@ Max@@ Product ( ar@@ r1 , ar@@ r2 , n1 , n2 ) : NEW_LINE INDENT max = ar@@ r1 [ 0 ] NEW_LINE min = ar@@ r2 [ 0 ] NEW_LINE i = 1 NEW_LINE while ( i < n1 and i < n2 ) : NEW_LINE INDENT if ( ar@@ r1 [ i ] > max ) : NEW_LINE INDENT max = ar@@ r1 [ i ] NEW_LINE DEDENT if ( ar@@ r2 [ i ] < min ) : NEW_LINE INDENT min = ar@@ r2 [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while ( i < n1 ) : NEW_LINE INDENT if ( ar@@ r1 [ i ] > max ) : NEW_LINE INDENT max = ar@@ r1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT while ( i < n2 ) : NEW_LINE INDENT if ( ar@@ r2 [ i ] < min ) : NEW_LINE INDENT min = ar@@ r2 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return max * min NEW_LINE DEDENT
PROGRAM_@@ CAL@@ CUL@@ ATE_@@ VOLUME_@@ OC@@ TA@@ HE@@ DRO@@ N | def vol_@@ of_@@ oc@@ ta@@ hedron ( side ) : NEW_LINE INDENT return ( ( side * side * side ) * ( math . sqrt ( 2 ) / 3 ) ) NEW_LINE DEDENT
SORT_@@ STRING_@@ CHARAC@@ TER@@ S_@@ 1 | def sort@@ String ( str ) : NEW_LINE INDENT char@@ Count = [ 0 for i in range ( MAX_@@ CHAR ) ] NEW_LINE for i in range ( 0 , len ( str ) , 1 ) : NEW_LINE INDENT char@@ Count [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , MAX_@@ CHAR , 1 ) : NEW_LINE INDENT for j in range ( 0 , char@@ Count [ i ] , 1 ) : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
MOVE_@@ SPAC@@ ES_@@ FRONT_@@ STRING@@ _SIN@@ GLE_@@ TRA@@ VERS@@ AL | def move@@ Space@@ In@@ Front ( s ) : NEW_LINE INDENT i = len ( s ) - 1 ; NEW_LINE for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ j ] != ' ▁ ' ) : NEW_LINE INDENT s = s [ : i ] + s [ j ] + s [ i + 1 : ] NEW_LINE i -= 1 ; NEW_LINE DEDENT DEDENT while ( i >= 0 ) : NEW_LINE INDENT s = s [ : i ] + ' ▁ ' + s [ i + 1 : ] NEW_LINE i -= 1 NEW_LINE DEDENT return s ; NEW_LINE DEDENT
MINIMUM_@@ INCRE@@ MENT_@@ K_@@ OPER@@ ATION@@ S_@@ MAKE_@@ ELEMEN@@ TS_@@ EQUAL | def min@@ Ops ( arr , n , k ) : NEW_LINE INDENT max@@ 1 = max ( arr ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( max@@ 1 - arr [ i ] ) % k != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += ( max@@ 1 - arr [ i ] ) / k NEW_LINE DEDENT DEDENT return int ( res ) NEW_LINE DEDENT
PROGRAM_@@ FOR_@@ FAC@@ TOR@@ I@@ AL_@@ OF_@@ A_@@ NUMBER_@@ 1 | def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) ; NEW_LINE DEDENT
MINIMUM_@@ TIME_@@ TO_@@ FINI@@ SH_@@ TASK@@ S_@@ WITH@@ OUT_@@ SKIP@@ P@@ ING_@@ TWO_@@ CON@@ SEC@@ UTI@@ VE | def min@@ Time ( arr , n ) : NEW_LINE INDENT if ( n <= 0 ) : return 0 NEW_LINE in@@ cl = arr [ 0 ] NEW_LINE ex@@ cl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT in@@ cl_@@ new = arr [ i ] + min ( ex@@ cl , in@@ cl ) NEW_LINE ex@@ cl_@@ new = in@@ cl NEW_LINE in@@ cl = in@@ cl_@@ new NEW_LINE ex@@ cl = ex@@ cl_@@ new NEW_LINE DEDENT return min ( in@@ cl , ex@@ cl ) NEW_LINE DEDENT
CHECK_@@ IF_@@ TWO_@@ ARRAY@@ S_@@ ARE_@@ EQUAL_@@ OR_@@ NOT | def are@@ Equal ( ar@@ r1 , ar@@ r2 , n , m ) : NEW_LINE INDENT if ( n != m ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT ar@@ r1 . sort ( ) ; NEW_LINE ar@@ r2 . sort ( ) ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( ar@@ r1 [ i ] != ar@@ r2 [ i ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT
MINIMUM_@@ DIFF@@ ER@@ ENCE_@@ MAX_@@ MIN_@@ K@@ _SIZE_@@ SUB@@ SETS | def min@@ Difference@@ A@@ mon@@ g@@ Max@@ Min ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 2147483647 NEW_LINE for i in range ( ( N - K ) + 1 ) : NEW_LINE INDENT cur@@ Seq@@ Diff = arr [ i + K - 1 ] - arr [ i ] NEW_LINE res = min ( res , cur@@ Seq@@ Diff ) NEW_LINE DEDENT return res NEW_LINE DEDENT
SW@@ AP_@@ BITS_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ NUMBER | def swap@@ Bits ( x , p1 , p2 , n ) : NEW_LINE INDENT set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) NEW_LINE set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) NEW_LINE xor = ( set1 ^ set2 ) NEW_LINE xor = ( xor << p1 ) | ( xor << p2 ) NEW_LINE result = x ^ xor NEW_LINE return result NEW_LINE DEDENT
COUNT_@@ NUMBER_OF_@@ WAY@@ S_TO_@@ FILL_@@ A_@@ N_@@ X_@@ 4_@@ GRID_@@ USING_@@ 1_@@ X_@@ 4_@@ TI@@ LES | def count ( n ) : NEW_LINE INDENT dp = [ 0 for _ in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i <= 3 : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT elif i == 4 : NEW_LINE INDENT dp [ i ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
MAXIMUM_@@ CON@@ SEC@@ UTI@@ VE_@@ REPE@@ ATING_@@ CHARACTER_@@ STRING_@@ 1 | def max@@ Repe@@ ating ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE res = str [ 0 ] NEW_LINE cur_@@ count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT cur_@@ count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if cur_@@ count > count : NEW_LINE INDENT count = cur_@@ count NEW_LINE res = str [ i ] NEW_LINE DEDENT cur_@@ count = 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
PAS@@ CAL_@@ TRI@@ ANGLE | def print@@ Pas@@ cal ( n : int ) : NEW_LINE INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for line in range ( 0 , n ) : NEW_LINE INDENT for i in range ( 0 , line + 1 ) : NEW_LINE INDENT if ( i is 0 or i is line ) : NEW_LINE INDENT arr [ line ] [ i ] = 1 NEW_LINE print ( arr [ line ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ) NEW_LINE print ( arr [ line ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( " \n " , end = " " ) NEW_LINE DEDENT DEDENT
TURN_@@ OFF_@@ THE_@@ RIGHT@@ MO@@ ST@@ _SET_@@ BIT | def fun ( n ) : NEW_LINE INDENT return n & ( n - 1 ) NEW_LINE DEDENT
RE@@ AR@@ RANGE_@@ ARRAY_@@ MAXIMUM_@@ MINIMUM_@@ FORM@@ _SET_@@ 2_@@ O@@ 1_@@ EX@@ TRA@@ _SPACE | def re@@ arrange ( arr , n ) : NEW_LINE INDENT max_@@ idx = n - 1 NEW_LINE min_@@ idx = 0 NEW_LINE max_@@ elem = arr [ n - 1 ] + 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT arr [ i ] += ( arr [ max_@@ idx ] % max_@@ elem ) * max_@@ elem NEW_LINE max_@@ idx -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += ( arr [ min_@@ idx ] % max_@@ elem ) * max_@@ elem NEW_LINE min_@@ idx += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] / max_@@ elem NEW_LINE DEDENT DEDENT
COUNT_@@ ZER@@ OS_@@ IN_@@ A_@@ ROW_@@ WI@@ SE_@@ AND_@@ COLUMN_@@ WI@@ SE_@@ SOR@@ TED_@@ MATRIX | def count@@ Zero@@ es ( mat ) : NEW_LINE INDENT N = 5 ; NEW_LINE row = N - 1 ; NEW_LINE col = 0 ; NEW_LINE count = 0 ; NEW_LINE while ( col < N ) : NEW_LINE INDENT while ( mat [ row ] [ col ] ) : NEW_LINE INDENT if ( row < 0 ) : NEW_LINE INDENT return count ; NEW_LINE DEDENT row = row - 1 ; NEW_LINE DEDENT count = count + ( row + 1 ) ; NEW_LINE col = col + 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT
MINIMUM_@@ CO@@ ST_@@ FOR_@@ AC@@ QUIR@@ ING_@@ ALL_@@ CO@@ INS_@@ WITH_@@ K_@@ EXTRA_@@ CO@@ INS_@@ ALLOWED_@@ WITH_@@ EVER@@ Y_@@ COIN | def min@@ Cost ( coin , n , k ) : NEW_LINE INDENT coin . sort ( ) NEW_LINE coin@@ s_@@ needed = math . ceil ( 1.0 * n // ( k + 1 ) ) ; NEW_LINE ans = 0 NEW_LINE for i in range ( coin@@ s_@@ needed - 1 + 1 ) : NEW_LINE INDENT ans += coin [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
COUNT_@@ SUB@@ ARRAY@@ S_@@ TOTAL_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ ORIGIN@@ AL_@@ ARRAY | def count@@ Di@@ stic@@ t@@ Sub@@ array ( arr , n ) : NEW_LINE INDENT vis = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT vis [ arr [ i ] ] = 1 NEW_LINE DEDENT k = len ( vis ) NEW_LINE vid = dict ( ) NEW_LINE ans = 0 NEW_LINE right = 0 NEW_LINE window = 0 NEW_LINE for left in range ( n ) : NEW_LINE INDENT while ( right < n and window < k ) : NEW_LINE INDENT if arr [ right ] in vid . keys ( ) : NEW_LINE INDENT vid [ arr [ right ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT vid [ arr [ right ] ] = 1 NEW_LINE DEDENT if ( vid [ arr [ right ] ] == 1 ) : NEW_LINE INDENT window += 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT if ( window == k ) : NEW_LINE INDENT ans += ( n - right + 1 ) NEW_LINE DEDENT vid [ arr [ left ] ] -= 1 NEW_LINE if ( vid [ arr [ left ] ] == 0 ) : NEW_LINE INDENT window -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
FIND_@@ POSSI@@ BLE_@@ ROTA@@ TE_@@ PAGE_@@ ANGLE_@@ NOT | def possible@@ Or@@ Not ( a1 , a2 , b1 , b2 , c1 , c2 ) : NEW_LINE INDENT dis@@ 1 = ( pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) ) NEW_LINE dis@@ 2 = ( pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) ) NEW_LINE if ( dis@@ 1 != dis@@ 2 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT elif ( b1 == ( ( a1 + c1 ) // 2.0 ) and b2 == ( ( a2 + c2 ) // 2.0 ) ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT
TIME_@@ ME@@ ET_@@ ANIM@@ ALS | def timeTo@@ Me@@ et ( s , v ) : NEW_LINE INDENT V = 3 * v / 2 ; NEW_LINE time = s / V ; NEW_LINE print ( time ) ; NEW_LINE DEDENT
B@@ RES@@ EN@@ HAM@@ S_@@ LINE_@@ GENERA@@ TION_@@ ALGORITH@@ M | def b@@ res@@ enh@@ am ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT m_@@ new = 2 * ( y2 - y1 ) NEW_LINE slo@@ pe_@@ error_@@ new = m_@@ new - ( x2 - x1 ) NEW_LINE y = y1 NEW_LINE for x in range ( x1 , x2 + 1 ) : NEW_LINE INDENT print ( " ( " , x , " , " , y , " ) \n " ) NEW_LINE slo@@ pe_@@ error_@@ new = slo@@ pe_@@ error_@@ new + m_@@ new NEW_LINE if ( slo@@ pe_@@ error_@@ new >= 0 ) : NEW_LINE INDENT y = y + 1 NEW_LINE slo@@ pe_@@ error_@@ new = slo@@ pe_@@ error_@@ new - 2 * ( x2 - x1 ) NEW_LINE DEDENT DEDENT DEDENT
MAXIMUM_@@ NUMBER_@@ CHO@@ CO@@ LA@@ TES_@@ DISTRIBU@@ TED_@@ EQUAL@@ LY_@@ AM@@ ONG_@@ K_@@ STUD@@ ENTS | def maxNum@@ Of@@ Cho@@ col@@ ates ( arr , n , k ) : NEW_LINE INDENT um , curr_@@ rem , max@@ Sum = { } , 0 , 0 NEW_LINE sm = [ 0 ] * n NEW_LINE sm [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sm [ i ] = sm [ i - 1 ] + arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT curr_@@ rem = sm [ i ] % k NEW_LINE if ( not curr_@@ rem and max@@ Sum < sm [ i ] ) : NEW_LINE INDENT max@@ Sum = sm [ i ] NEW_LINE DEDENT elif ( not curr_@@ rem in um ) : NEW_LINE INDENT um [ curr_@@ rem ] = i NEW_LINE DEDENT elif ( max@@ Sum < ( sm [ i ] - sm [ um [ curr_@@ rem ] ] ) ) : NEW_LINE INDENT max@@ Sum = sm [ i ] - sm [ um [ curr_@@ rem ] ] NEW_LINE DEDENT DEDENT return max@@ Sum // k NEW_LINE DEDENT
CHECK_@@ TWO_@@ STRING@@ S_@@ K_@@ AN@@ AG@@ RAM@@ S_@@ NOT_@@ 1 | def are@@ K@@ An@@ agram@@ s ( str1 , str2 , k ) : NEW_LINE INDENT n = len ( str1 ) ; NEW_LINE if ( len ( str2 ) != n ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT hash_@@ str1 = [ 0 ] * ( MAX_@@ CHAR ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash_@@ str1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash_@@ str1 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] > 0 ) : NEW_LINE INDENT hash_@@ str1 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count > k ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT
DI@@ VISIBILITY_@@ CHECK | def di@@ visibility@@ Check ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE max_@@ ele = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE max_@@ ele = max ( max_@@ ele , arr [ i ] ) NEW_LINE DEDENT res = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT for j in range ( arr [ i ] * 2 , max_@@ ele + 1 , arr [ i ] ) : NEW_LINE INDENT if ( j in s . keys ( ) ) : NEW_LINE INDENT res [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for x in res : NEW_LINE INDENT print ( x , end = " ▁ " ) NEW_LINE DEDENT DEDENT
MAXIMUM_@@ LENGTH_@@ PREFIX_@@ ONE_@@ STRING_@@ OC@@ CURS@@ _SUB@@ SEQU@@ ENCE_@@ AN@@ OTHER | def max@@ Prefix ( s , t ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , len ( t ) ) : NEW_LINE INDENT if ( count == len ( s ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( t [ i ] == s [ count ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
COUNT_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ IN_@@ EVER@@ Y_@@ WINDOW_@@ OF@@ _SIZE_@@ K | def count@@ Distin@@ ct ( arr , k , n ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE dist@@ _count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if mp [ arr [ i ] ] == 0 : NEW_LINE INDENT dist@@ _count += 1 NEW_LINE DEDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT print ( dist@@ _count ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT if mp [ arr [ i - k ] ] == 1 : NEW_LINE INDENT dist@@ _count -= 1 NEW_LINE DEDENT mp [ arr [ i - k ] ] -= 1 NEW_LINE if mp [ arr [ i ] ] == 0 : NEW_LINE INDENT dist@@ _count += 1 NEW_LINE DEDENT mp [ arr [ i ] ] += 1 NEW_LINE print ( dist@@ _count ) NEW_LINE DEDENT DEDENT
LC@@ S_@@ FOR@@ MED_@@ CON@@ SEC@@ UTI@@ VE_@@ SEG@@ MEN@@ TS_@@ LEA@@ ST_@@ LENGTH_@@ K | def lon@@ gest@@ Sub@@ sequence@@ Common@@ Segment ( k , s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE l@@ cs = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE cnt = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT l@@ cs [ i ] [ j ] = max ( l@@ cs [ i - 1 ] [ j ] , l@@ cs [ i ] [ j - 1 ] ) NEW_LINE if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) : NEW_LINE INDENT cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; NEW_LINE DEDENT if ( cnt [ i ] [ j ] >= k ) : NEW_LINE INDENT for a in range ( k , cnt [ i ] [ j ] + 1 ) : NEW_LINE INDENT l@@ cs [ i ] [ j ] = max ( l@@ cs [ i ] [ j ] , l@@ cs [ i - a ] [ j - a ] + a ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return l@@ cs [ n ] [ m ] NEW_LINE DEDENT
PRINT_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ GI@@ V@@ EN_@@ INTEGER_@@ ARRAY_@@ 1 | def print@@ Distin@@ ct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT while ( i < n - 1 and ( arr [ i ] == arr [ i + 1 ] ) ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
PRI@@ MALI@@ TY_@@ TEST@@ _SET_@@ 5@@ USING_@@ L@@ UC@@ AS_@@ LE@@ H@@ MER@@ _SERI@@ ES | def is@@ Prime ( p ) : NEW_LINE INDENT check@@ Number = 2 ** p - 1 NEW_LINE next@@ val = 4 % check@@ Number NEW_LINE for i in range ( 1 , p - 1 ) : NEW_LINE INDENT next@@ val = ( next@@ val * next@@ val - 2 ) % check@@ Number NEW_LINE DEDENT if ( next@@ val == 0 ) : return True NEW_LINE else : return False NEW_LINE DEDENT
K@@ TH_@@ NON_@@ REPE@@ ATING_@@ CHARACTER | def k@@ th@@ Non@@ Repe@@ ating ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 ] * MAX_@@ CHAR NEW_LINE index = [ 0 ] * MAX_@@ CHAR NEW_LINE for i in range ( MAX_@@ CHAR ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE index [ i ] = n NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = str [ i ] NEW_LINE count [ ord ( x ) ] += 1 NEW_LINE if ( count [ ord ( x ) ] == 1 ) : NEW_LINE INDENT index [ ord ( x ) ] = i NEW_LINE DEDENT if ( count [ ord ( x ) ] == 2 ) : NEW_LINE INDENT index [ ord ( x ) ] = n NEW_LINE DEDENT DEDENT index . sort ( ) NEW_LINE return index [ k - 1 ] if ( index [ k - 1 ] != n ) else - 1 NEW_LINE DEDENT
FIRST_@@ UP@@ PER@@ CASE_@@ LET@@ TER_@@ IN_@@ A_@@ STRING_@@ ITER@@ ATI@@ VE_@@ AND_@@ RECUR@@ SIVE | def first ( str ) : NEW_LINE INDENT for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . ist@@ it@@ le ( ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
GI@@ V@@ EN_@@ TWO_@@ STRING@@ S_@@ FIND_@@ FIRST_@@ STRING@@ _SUB@@ SEQU@@ ENCE_@@ SECOND | def isSub@@ Sequence ( string1 , string@@ 2 , m , n ) : NEW_LINE INDENT if m == 0 : return True NEW_LINE if n == 0 : return False NEW_LINE if string1 [ m - 1 ] == string@@ 2 [ n - 1 ] : NEW_LINE INDENT return isSub@@ Sequence ( string1 , string@@ 2 , m - 1 , n - 1 ) NEW_LINE DEDENT return isSub@@ Sequence ( string1 , string@@ 2 , m , n - 1 ) NEW_LINE DEDENT
C_@@ PROGRAM_@@ FIND_@@ LAR@@ GE@@ ST_@@ ELEMENT_@@ ARRAY_@@ 1 | def largest ( arr , n ) : NEW_LINE INDENT return max ( arr ) NEW_LINE DEDENT
DIFF@@ ER@@ ENCE_@@ BETWE@@ EN_@@ HIGH@@ EST_@@ AND_@@ LEA@@ ST_@@ FREQU@@ ENCI@@ ES_@@ IN_@@ AN_@@ ARRAY | def find@@ Diff ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 ; max_@@ count = 0 ; min_@@ count = n NEW_LINE for i in range ( 0 , ( n - 1 ) ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT max_@@ count = max ( max_@@ count , count ) NEW_LINE min_@@ count = min ( min_@@ count , count ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT return max_@@ count - min_@@ count NEW_LINE DEDENT
PROGRAM_@@ FOR_@@ FAC@@ TOR@@ I@@ AL_@@ OF_@@ A_@@ NUMBER | def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) ; NEW_LINE DEDENT
