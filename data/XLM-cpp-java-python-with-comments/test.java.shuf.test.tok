MAXIMUM_@@ NUMBER_@@ CHARAC@@ TER@@ S_@@ TWO_@@ CHARACTER_@@ STRING | static int maximum@@ Chars ( String str ) { int n = str . length ( ) ; int res = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( str . charAt ( i ) == str . charAt ( j ) ) res = Math . max ( res , Math . abs ( j - i - 1 ) ) ; return res ; }
FIND_@@ MIRR@@ OR_@@ IMAGE_@@ POINT_@@ 2_@@ D_@@ PLAN@@ E | static pair mirror@@ Image ( double a , double b , double c , double x1 , double y1 ) { double temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) ; double x = temp * a + x1 ; double y = temp * b + y1 ; return new pair ( x , y ) ; }
EF@@ FI@@ CI@@ EN@@ TL@@ Y_@@ COMP@@ UTE_@@ SUM@@ S_@@ OF_@@ DIAG@@ ON@@ AL@@ S_@@ OF_@@ A_@@ MATRIX | static void print@@ Diag@@ onal@@ Sum@@ s ( int [ ] [ ] mat , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) principal += mat [ i ] [ j ] ; if ( ( i + j ) == ( n - 1 ) ) secondary += mat [ i ] [ j ] ; } } System . out . println ( " Principal ▁ Diagonal : " + principal ) ; System . out . println ( " Secondary ▁ Diagonal : " + secondary ) ; }
COUN@@ TS_@@ PATH@@ S_@@ POINT_@@ REACH_@@ ORIGIN | static int count@@ Paths ( int n , int m ) { if ( n == 0 || m == 0 ) return 1 ; return ( count@@ Paths ( n - 1 , m ) + count@@ Paths ( n , m - 1 ) ) ; }
FIND_@@ A_@@ TR@@ IP@@ LET_@@ TH@@ AT_@@ S@@ UM_@@ TO_@@ A_@@ GI@@ V@@ EN_@@ VALUE_@@ 1 | boolean find@@ 3@@ Numbers ( int A [ ] , int arr_@@ size , int sum ) { int l , r ; quick@@ Sort ( A , 0 , arr_@@ size - 1 ) ; for ( int i = 0 ; i < arr_@@ size - 2 ; i ++ ) { l = i + 1 ; r = arr_@@ size - 1 ; while ( l < r ) { if ( A [ i ] + A [ l ] + A [ r ] == sum ) { System . out . print ( " Trip@@ let ▁ is ▁ " + A [ i ] + " , ▁ " + A [ l ] + " , ▁ " + A [ r ] ) ; return true ; } else if ( A [ i ] + A [ l ] + A [ r ] < sum ) l ++ ; else r -- ; } } return false ; }
CHECK_@@ GI@@ V@@ EN_@@ MATRIX_@@ IS_@@ MAG@@ IC@@ _S@@ QU@@ ARE_@@ OR_@@ NOT | static boolean is@@ Magic@@ Square ( int mat [ ] [ ] ) { int sum = 0 , sum@@ 2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum = sum + mat [ i ] [ i ] ; for ( int i = 0 ; i < N ; i ++ ) sum@@ 2 = sum@@ 2 + mat [ i ] [ N - 1 - i ] ; if ( sum != sum@@ 2 ) return false ; for ( int i = 0 ; i < N ; i ++ ) { int row@@ Sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) row@@ Sum += mat [ i ] [ j ] ; if ( row@@ Sum != sum ) return false ; } for ( int i = 0 ; i < N ; i ++ ) { int col@@ Sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) col@@ Sum += mat [ j ] [ i ] ; if ( sum != col@@ Sum ) return false ; } return true ; }
SEQU@@ EN@@ CES_@@ GI@@ V@@ EN_@@ LENGTH_@@ EVER@@ Y_@@ ELEMENT_@@ EQUAL_@@ TWI@@ CE_@@ PREVI@@ OUS_@@ 1 | static int getTotal@@ NumberOf@@ Sequences ( int m , int n ) { int T [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 || j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] ; } } return T [ m ] [ n ] ; }
FIND_@@ DIFF@@ ER@@ ENCE_@@ BETWE@@ EN@@ _S@@ UM@@ S_@@ OF_@@ TWO_@@ DIAG@@ ON@@ AL@@ S_@@ 1 | public static int difference ( int arr [ ] [ ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return Math . abs ( d1 - d2 ) ; }
MINIMUM_@@ NUMBER@@ _SUB@@ SE@@ TS_@@ DISTIN@@ CT_@@ ELEMENTS | public static int subset ( int ar [ ] , int n ) { int res = 0 ; Arrays . sort ( ar ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; }
DECIMAL_@@ BINARY_@@ CON@@ VERSION_@@ WITH@@ OUT_@@ USING_@@ ARI@@ TH@@ ME@@ TIC_@@ OPER@@ ATORS | static String dec@@ To@@ Bin ( int n ) { if ( n == 0 ) return "0" ; String bin = " " ; while ( n > 0 ) { bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ; n >>= 1 ; } return bin ; }
FIND_@@ N@@ TH_@@ TER@@ M_@@ DRAG@@ ON_@@ CUR@@ VE_@@ SEQUENCE | static String Drag@@ on_@@ Cur@@ ve_@@ Sequence ( int n ) { String s = "1" ; for ( int i = 2 ; i <= n ; i ++ ) { String temp = "1" ; char prev = '1' , zero = '0' , one = '1' ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { temp += s . charAt ( j ) ; if ( prev == '0' ) { temp += one ; prev = one ; } else { temp += zero ; prev = zero ; } } s = temp ; } return s ; }
STACK@@ _SET_@@ 3_@@ REVERSE_@@ STRING_@@ USING_@@ STACK | static void reverse ( char str [ ] ) { int n = str . length , i ; for ( i = 0 ; i < n / 2 ; i ++ ) { swap ( str , i , n - i - 1 ) ; } }
SORT_@@ EV@@ EN_@@ PL@@ AC@@ ED_@@ ELEMEN@@ TS_@@ INCRE@@ AS@@ ING_@@ OD@@ D_@@ PL@@ AC@@ ED_@@ DECRE@@ AS@@ ING_@@ ORDER_@@ 1 | static void bit@@ on@@ ic@@ Generator ( int arr [ ] , int n ) { int i = 1 ; int j = n - 1 ; if ( j % 2 != 0 ) j -- ; while ( i < j ) { arr = swap ( arr , i , j ) ; i += 2 ; j -= 2 ; } Arrays . sort ( arr , 0 , ( n + 1 ) / 2 ) ; Arrays . sort ( arr , ( n + 1 ) / 2 , n ) ; int low = ( n + 1 ) / 2 , high = n - 1 ; while ( low < high ) { Integer temp = arr [ low ] ; arr [ low ] = arr [ high ] ; arr [ high ] = temp ; low ++ ; high -- ; } }
GI@@ V@@ EN_@@ TWO_@@ NUMB@@ ERS_@@ B_@@ FIND_@@ X_@@ X_@@ B | static void mod@@ ular@@ Equation ( int a , int b ) { if ( a < b ) { System . out . println ( " No ▁ solution ▁ possible ▁ " ) ; return ; } if ( a == b ) { System . out . println ( " In@@ finite ▁ Solution ▁ possible ▁ " ) ; return ; } int count = 0 ; int n = a - b ; int y = ( int ) Math . sqrt ( a - b ) ; for ( int i = 1 ; i <= y ; ++ i ) { if ( n % i == 0 ) { if ( n / i > b ) count ++ ; if ( i > b ) count ++ ; } } if ( y * y == n && y > b ) count -- ; System . out . println ( count ) ; }
CHECK_@@ CHARAC@@ TER@@ S_@@ GI@@ V@@ EN_@@ STRING_@@ CAN_@@ RE@@ AR@@ RANGE@@ D_@@ FORM_@@ PA@@ LIN@@ DRO@@ ME | static boolean can@@ Form@@ Pal@@ ind@@ ro@@ me ( String str ) { int count [ ] = new int [ NO_@@ OF_@@ CHARS ] ; Arrays . fill ( count , 0 ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ ( int ) ( str . charAt ( i ) ) ] ++ ; int odd = 0 ; for ( int i = 0 ; i < NO_@@ OF_@@ CHARS ; i ++ ) { if ( ( count [ i ] & 1 ) == 1 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; }
MAXIMUM_@@ TR@@ IP@@ LET_@@ S@@ UM_@@ ARRAY_@@ 1 | static int max@@ Trip@@ let@@ Sum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }
FIND_@@ MEDI@@ AN_@@ ROW_@@ WI@@ SE_@@ SOR@@ TED_@@ MATRIX | static int binary@@ Medi@@ an ( int m [ ] [ ] , int r , int c ) { int max = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < r ; i ++ ) { if ( m [ i ] [ 0 ] < min ) min = m [ i ] [ 0 ] ; if ( m [ i ] [ c - 1 ] > max ) max = m [ i ] [ c - 1 ] ; } int desired = ( r * c + 1 ) / 2 ; while ( min < max ) { int mid = min + ( max - min ) / 2 ; int place = 0 ; int get = 0 ; for ( int i = 0 ; i < r ; ++ i ) { get = Arrays . binary@@ Search ( m [ i ] , mid ) ; if ( get < 0 ) get = Math . abs ( get ) - 1 ; else { while ( get < m [ i ] . length && m [ i ] [ get ] == mid ) get += 1 ; } place = place + get ; } if ( place < desired ) min = mid + 1 ; else max = mid ; } return min ; }
HEIGHT_@@ N_@@ ARY_@@ TREE_@@ PARENT_@@ ARRAY_@@ GI@@ VEN | static int find@@ Height ( int [ ] parent , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int p = i , current = 1 ; while ( parent [ p ] != - 1 ) { current ++ ; p = parent [ p ] ; } res = Math . max ( res , current ) ; } return res ; }
CHECK_@@ LARGE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 20 | static Boolean di@@ visible@@ By@@ 20 ( String num ) { int last@@ Two@@ Digits = Integer . parseInt ( num . substring ( num . length ( ) - 2 , num . length ( ) ) ) ; return ( ( last@@ Two@@ Digits % 5 == 0 ) && ( last@@ Two@@ Digits % 4 == 0 ) ) ; }
MAXIMUM_@@ VALUE_@@ CHO@@ ICE_@@ EI@@ THER_@@ DIV@@ ID@@ ING_@@ CON@@ SI@@ DER@@ ING | static int max@@ DP ( int n ) { int res [ ] = new int [ n + 1 ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res [ i ] = Math . max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) ; return res [ n ] ; }
QUER@@ I@@ ES_@@ ON_@@ ARRAY_@@ WITH_@@ DIS@@ AP@@ PE@@ AR@@ ING_@@ AND_@@ RE@@ AP@@ PE@@ AR@@ ING_@@ ELEMENTS | static void Perform@@ Queries ( int [ ] a , int [ ] [ ] vec ) { Vector < Integer > ans = new Vector < > ( ) ; int n = ( int ) a . length - 1 ; int q = ( int ) vec . length ; for ( int i = 0 ; i < q ; ++ i ) { long t = vec [ i ] [ 0 ] ; int m = vec [ i ] [ 1 ] ; if ( m > n ) { ans . add ( - 1 ) ; continue ; } int turn = ( int ) ( t / n ) ; int rem = ( int ) ( t % n ) ; if ( rem == 0 && turn % 2 == 1 ) { ans . add ( - 1 ) ; continue ; } if ( rem == 0 && turn % 2 == 0 ) { ans . add ( a [ m ] ) ; continue ; } if ( turn % 2 == 0 ) { int cur@@ size = n - rem ; if ( cur@@ size < m ) { ans . add ( - 1 ) ; continue ; } ans . add ( a [ m + rem ] ) ; } else { int cur@@ size = rem ; if ( cur@@ size < m ) { ans . add ( - 1 ) ; continue ; } ans . add ( a [ m ] ) ; } } for ( int i : ans ) System . out . print ( i + " \n " ) ; }
FIND_@@ THE_@@ MINIMUM_@@ DISTAN@@ CE_@@ BETWE@@ EN_@@ TWO_@@ NUMB@@ ERS_@@ 1 | int min@@ Dist ( int arr [ ] , int n , int x , int y ) { int i = 0 ; int min_@@ dist = Integer . MAX_VALUE ; int prev = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x || arr [ i ] == y ) { prev = i ; break ; } } for ( ; i < n ; i ++ ) { if ( arr [ i ] == x || arr [ i ] == y ) { if ( arr [ prev ] != arr [ i ] && ( i - prev ) < min_@@ dist ) { min_@@ dist = i - prev ; prev = i ; } else prev = i ; } } return min_@@ dist ; }
UNI@@ ON_@@ AND_@@ INTER@@ SECTION_@@ OF_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S_@@ 2 | static int print@@ Union ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( ar@@ r1 [ i ] < ar@@ r2 [ j ] ) System . out . print ( ar@@ r1 [ i ++ ] + " ▁ " ) ; else if ( ar@@ r2 [ j ] < ar@@ r1 [ i ] ) System . out . print ( ar@@ r2 [ j ++ ] + " ▁ " ) ; else { System . out . print ( ar@@ r2 [ j ++ ] + " ▁ " ) ; i ++ ; } } while ( i < m ) System . out . print ( ar@@ r1 [ i ++ ] + " ▁ " ) ; while ( j < n ) System . out . print ( ar@@ r2 [ j ++ ] + " ▁ " ) ; return 0 ; }
WORD_@@ WRAP_@@ PRO@@ BLE@@ M@@ _SPACE_@@ OPTIMIZ@@ ED@@ _S@@ OL@@ U@@ TION | static void solve@@ Word@@ Wrap ( int arr [ ] , int n , int k ) { int i , j ; int curr@@ len ; int cost ; int dp [ ] = new int [ n ] ; int ans [ ] = new int [ n ] ; dp [ n - 1 ] = 0 ; ans [ n - 1 ] = n - 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) { curr@@ len = - 1 ; dp [ i ] = Integer . MAX_VALUE ; for ( j = i ; j < n ; j ++ ) { curr@@ len += ( arr [ j ] + 1 ) ; if ( curr@@ len > k ) break ; if ( j == n - 1 ) cost = 0 ; else cost = ( k - curr@@ len ) * ( k - curr@@ len ) + dp [ j + 1 ] ; if ( cost < dp [ i ] ) { dp [ i ] = cost ; ans [ i ] = j ; } } } i = 0 ; while ( i < n ) { System . out . print ( ( i + 1 ) + " ▁ " + ( ans [ i ] + 1 ) + " ▁ " ) ; i = ans [ i ] + 1 ; } }
COUNT_@@ DISTIN@@ CT_@@ SUB@@ SEQU@@ EN@@ CES | static int count@@ Sub ( String str ) { int [ ] last = new int [ MAX_@@ CHAR ] ; Arrays . fill ( last , - 1 ) ; int n = str . length ( ) ; int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] = 2 * dp [ i - 1 ] ; if ( last [ ( int ) str . charAt ( i - 1 ) ] != - 1 ) dp [ i ] = dp [ i ] - dp [ last [ ( int ) str . charAt ( i - 1 ) ] ] ; last [ ( int ) str . charAt ( i - 1 ) ] = ( i - 1 ) ; } return dp [ n ] ; }
LON@@ GE@@ ST_@@ EV@@ EN_@@ LENGTH@@ _SUB@@ STRING@@ _S@@ UM_@@ FIR@@ ST@@ _SECON@@ D_@@ HALF_@@ 3 | static int find@@ Length ( String str , int n ) { int ans = 0 ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { int l = i , r = i + 1 ; int l@@ sum = 0 , r@@ sum = 0 ; while ( r < n && l >= 0 ) { l@@ sum += str . charAt ( l ) - '0' ; r@@ sum += str . charAt ( r ) - '0' ; if ( l@@ sum == r@@ sum ) { ans = Math . max ( ans , r - l + 1 ) ; } l -- ; r ++ ; } } return ans ; }
MAXIMUM_@@ PATH@@ _S@@ UM_@@ MATRIX | static int find@@ Max@@ Path ( int mat [ ] [ ] ) { int res = - 1 ; for ( int i = 0 ; i < M ; i ++ ) res = max ( res , mat [ 0 ] [ i ] ) ; for ( int i = 1 ; i < N ; i ++ ) { res = - 1 ; for ( int j = 0 ; j < M ; j ++ ) { if ( j > 0 && j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) ; else if ( j > 0 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) ; else if ( j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) ; res = max ( mat [ i ] [ j ] , res ) ; } } return res ; }
MAXIMUM_@@ CON@@ SEC@@ UTI@@ VE_@@ REPE@@ ATING_@@ CHARACTER_@@ STRING | static char max@@ Repe@@ ating ( String str ) { int len = str . length ( ) ; int count = 0 ; char res = str . charAt ( 0 ) ; for ( int i = 0 ; i < len ; i ++ ) { int cur_@@ count = 1 ; for ( int j = i + 1 ; j < len ; j ++ ) { if ( str . charAt ( i ) != str . charAt ( j ) ) break ; cur_@@ count ++ ; } if ( cur_@@ count > count ) { count = cur_@@ count ; res = str . charAt ( i ) ; } } return res ; }
MAXIMUM_@@ LENGTH@@ _SUB@@ SEQU@@ ENCE_@@ DIFF@@ ER@@ ENCE_@@ AD@@ J@@ AC@@ ENT_@@ ELEMEN@@ TS_@@ EI@@ THER_@@ 0_@@ 1 | public static int max@@ Len@@ Sub ( int arr [ ] , int n ) { int m@@ ls [ ] = new int [ n ] , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) m@@ ls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && m@@ ls [ i ] < m@@ ls [ j ] + 1 ) m@@ ls [ i ] = m@@ ls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < m@@ ls [ i ] ) max = m@@ ls [ i ] ; return max ; }
BREA@@ KING_@@ NUMBER_@@ FIRST_@@ PART_@@ INTEGR@@ AL_@@ DI@@ VISI@@ ON@@ _SECON@@ D_@@ POWER_@@ 10 | static int calculate ( String N ) { int len = N . length ( ) ; int l = ( len ) / 2 ; int count = 0 ; for ( int i = 1 ; i <= l ; i ++ ) { String s = N . substring ( 0 , i ) ; int l1 = s . length ( ) ; String t = N . substring ( i , l1 + i ) ; if ( s . charAt ( 0 ) == '0' || t . charAt ( 0 ) == '0' ) continue ; if ( s . compareTo ( t ) == 0 ) count ++ ; } return count ; }
PROGRAM_@@ BINARY_@@ DECIMAL_@@ CONVERSION | static int binary@@ To@@ Decimal ( int n ) { int num = n ; int dec_@@ value = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { int last_@@ digit = temp % 10 ; temp = temp / 10 ; dec_@@ value += last_@@ digit * base ; base = base * 2 ; } return dec_@@ value ; }
HO@@ W_@@ CAN_@@ W@@ E_@@ S@@ UM_@@ THE_@@ DIG@@ IT@@ S_@@ OF_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ IN@@ _SIN@@ GLE_@@ STATEMENT | static int getS@@ um ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
FIND_@@ N_@@ TH_@@ ELEMENT_@@ FROM_@@ STER@@ NS_@@ DI@@ ATOMI@@ C@@ _SERI@@ ES | static int find@@ SD@@ S@@ Func ( int n ) { int DP [ ] = new int [ n + 1 ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ; else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ; } return DP [ n ] ; }
NUMBER@@ _SIN@@ K_@@ NODE@@ S_@@ GRAP@@ H | static int count@@ Sink ( int n , int m , int edge@@ From [ ] , int edge@@ To [ ] ) { int [ ] mark = new int [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) mark [ edge@@ From [ i ] ] = 1 ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( mark [ i ] == 0 ) count ++ ; return count ; }
BREAK_@@ NUMBER_@@ THRE@@ E_@@ PAR@@ TS | static long count_@@ of_@@ ways ( long n ) { long count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) for ( int k = 0 ; k <= n ; k ++ ) if ( i + j + k == n ) count ++ ; return count ; }
PRINT_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ GI@@ V@@ EN_@@ INTEGER_@@ ARRAY | static void print@@ Distin@@ ct ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) break ; if ( i == j ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
MAXIMUM_@@ NUMBER@@ _SEG@@ MEN@@ TS_@@ LENGTH@@ S_@@ B_@@ C | static int maximum@@ Segments ( int n , int a , int b , int c ) { int dp [ ] = new int [ n + 10 ] ; Arrays . fill ( dp , - 1 ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { if ( i + a <= n ) dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ; if ( i + b <= n ) dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ; if ( i + c <= n ) dp [ i + c ] = Math . max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }
CHECK_@@ VALI@@ D@@ _SEQU@@ ENCE_@@ DI@@ VISI@@ BLE_@@ M | static boolean is@@ Possible ( int n , int index , int sum , int M , int arr [ ] , int dp [ ] [ ] ) { if ( index == n ) { if ( ( sum % M ) == 0 ) return true ; return false ; } else if ( sum < 0 || sum >= MAX ) return false ; if ( dp [ index ] [ sum ] != - 1 ) { if ( dp [ index ] [ sum ] == 0 ) return false ; return true ; } boolean place@@ Add = is@@ Possible ( n , index + 1 , sum + arr [ index ] , M , arr , dp ) ; boolean place@@ Minus = is@@ Possible ( n , index + 1 , sum - arr [ index ] , M , arr , dp ) ; boolean res = ( place@@ Add || place@@ Minus ) ; dp [ index ] [ sum ] = ( res ) ? 1 : 0 ; return res ; }
FIND_@@ PA@@ IR_@@ WITH_@@ GREA@@ TEST_@@ PRODUCT_@@ IN_@@ ARRAY | static int find@@ Gre@@ atest ( int [ ] arr , int n ) { int result = - 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . max ( result , arr [ i ] ) ; return result ; }
MAX@@ IM@@ UM@@ _SUB@@ ARRA@@ Y_S@@ UM_@@ ARRAY_@@ CRE@@ ATED_@@ REPE@@ ATED_@@ CON@@ CAT@@ EN@@ ATION | static int max@@ Sub@@ Array@@ Sum@@ Repe@@ ated ( int a [ ] , int n , int k ) { int max_@@ so@@ _f@@ ar = 0 ; int INT_@@ MIN , max_@@ ending_@@ here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_@@ ending_@@ here = max_@@ ending_@@ here + a [ i % n ] ; if ( max_@@ so@@ _f@@ ar < max_@@ ending_@@ here ) max_@@ so@@ _f@@ ar = max_@@ ending_@@ here ; if ( max_@@ ending_@@ here < 0 ) max_@@ ending_@@ here = 0 ; } return max_@@ so@@ _f@@ ar ; }
LE@@ ON@@ AR@@ DO_@@ NUMBER_@@ 1 | static int le@@ on@@ ar@@ do ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 ; return dp [ n ] ; }
S@@ UM_@@ OF_@@ ALL@@ _SUB@@ STRING@@ S_@@ OF_@@ A_@@ STRING_@@ RE@@ PRESEN@@ TING_@@ A_@@ NUMBER | public static int sum@@ Of@@ Sub@@ strings ( String num ) { int n = num . length ( ) ; int su@@ mo@@ f@@ digit [ ] = new int [ n ] ; su@@ mo@@ f@@ digit [ 0 ] = num . charAt ( 0 ) - '0' ; int res = su@@ mo@@ f@@ digit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int num@@ i = num . charAt ( i ) - '0' ; su@@ mo@@ f@@ digit [ i ] = ( i + 1 ) * num@@ i + 10 * su@@ mo@@ f@@ digit [ i - 1 ] ; res += su@@ mo@@ f@@ digit [ i ] ; } return res ; }
PR@@ U@@ F@@ ER_@@ CODE_@@ TREE_@@ CRE@@ ATION | static void print@@ Tree@@ Edges ( int pr@@ u@@ fer [ ] , int m ) { int vertices = m + 2 ; int vertex@@ _set [ ] = new int [ vertices ] ; for ( int i = 0 ; i < vertices ; i ++ ) vertex@@ _set [ i ] = 0 ; for ( int i = 0 ; i < vertices - 2 ; i ++ ) vertex@@ _set [ pr@@ u@@ fer [ i ] - 1 ] += 1 ; System . out . print ( " \n The ▁ edge ▁ set ▁ E ( G ) ▁ is ▁ : \n " ) ; int j = 0 ; for ( int i = 0 ; i < vertices - 2 ; i ++ ) { for ( j = 0 ; j < vertices ; j ++ ) { if ( vertex@@ _set [ j ] == 0 ) { vertex@@ _set [ j ] = - 1 ; System . out . print ( " ( " + ( j + 1 ) + " , ▁ " + pr@@ u@@ fer [ i ] + " ) ▁ " ) ; vertex@@ _set [ pr@@ u@@ fer [ i ] - 1 ] -- ; break ; } } } j = 0 ; for ( int i = 0 ; i < vertices ; i ++ ) { if ( vertex@@ _set [ i ] == 0 && j == 0 ) { System . out . print ( " ( " + ( i + 1 ) + " , ▁ " ) ; j ++ ; } else if ( vertex@@ _set [ i ] == 0 && j == 1 ) System . out . print ( ( i + 1 ) + " ) \n " ) ; } }
PROGRAM_@@ FIN@@ D_S@@ MAL@@ LE@@ ST_@@ DIFF@@ ER@@ ENCE_@@ ANG@@ LES_@@ TWO_@@ PAR@@ TS_@@ GI@@ V@@ EN_@@ CIRC@@ LE | public static int find@@ Minimum@@ Angle ( int arr [ ] , int n ) { int l = 0 , sum = 0 , ans = 360 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; while ( sum >= 180 ) { ans = Math . min ( ans , 2 * Math . abs ( 180 - sum ) ) ; sum -= arr [ l ] ; l ++ ; } ans = Math . min ( ans , 2 * Math . abs ( 180 - sum ) ) ; } return ans ; }
FIND_@@ MAXIMUM_@@ AVER@@ AGE_@@ SUB@@ ARRAY_@@ OF_@@ K_@@ LENGTH | static int find@@ Max@@ Average ( int [ ] arr , int n , int k ) { if ( k > n ) return - 1 ; int [ ] c@@ sum = new int [ n ] ; c@@ sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) c@@ sum [ i ] = c@@ sum [ i - 1 ] + arr [ i ] ; int max_@@ sum = c@@ sum [ k - 1 ] , max_@@ end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_@@ sum = c@@ sum [ i ] - c@@ sum [ i - k ] ; if ( curr_@@ sum > max_@@ sum ) { max_@@ sum = curr_@@ sum ; max_@@ end = i ; } } return max_@@ end - k + 1 ; }
SQU@@ ARE_@@ PY@@ RAM@@ ID@@ AL_@@ NUMBER@@ _S@@ UM@@ _S@@ QUAR@@ ES | static int find@@ S ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n ; if ( sum == s ) return n ; } return - 1 ; }
PROGRAM_@@ TO_@@ CAL@@ CUL@@ ATE_@@ AREA_@@ OF_@@ AN_@@ CI@@ R@@ CLE_@@ IN@@ SCRI@@ BED_@@ IN_@@ A@@ _S@@ QU@@ ARE | static double area@@ Of@@ In@@ scri@@ bed@@ Circle ( float a ) { return ( PI / 4 ) * a * a ; }
MINIMUM_@@ NUMBER_@@ CHARAC@@ TER@@ S_@@ REMO@@ VED_@@ MAKE_@@ BINARY_@@ STRING_@@ ALTER@@ N@@ ATE | static int count@@ To@@ Make@@ 0@@ l@@ tern@@ ate ( String s ) { int result = 0 ; for ( int i = 0 ; i < ( s . length ( ) - 1 ) ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) result ++ ; return result ; }
FIND_@@ ELEMEN@@ TS_@@ PRES@@ ENT_@@ FIRST_@@ ARRAY_@@ NOT_@@ SECOND | static void find@@ Missing ( int a [ ] , int b [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) System . out . print ( a [ i ] + " ▁ " ) ; } }
RE@@ AR@@ RANGE_@@ ARRAY_@@ MAXIMUM_@@ MINIMUM_@@ FORM | static void re@@ arrange ( int [ ] arr , int n ) { int temp [ ] = new int [ n ] ; int small = 0 , large = n - 1 ; boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ] ; else temp [ i ] = arr [ small ++ ] ; flag = ! flag ; } arr = temp . clone ( ) ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 15_@@ LON@@ GE@@ ST_@@ BIT@@ ON@@ IC@@ _SUB@@ SEQUENCE | static int l@@ bs ( int arr [ ] , int n ) { int i , j ; int [ ] lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int [ ] lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
COUNT_@@ PAIR@@ S_@@ WHO@@ SE_@@ PRODUC@@ TS_@@ EXI@@ ST_@@ IN_@@ ARRAY | static int count@@ Pairs ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; }
COUNT_@@ SINGLE_@@ NODE_@@ ISO@@ LA@@ TED@@ _SUB_@@ GRAP@@ H@@ S_@@ DIS@@ CONNEC@@ TED_@@ GRAP@@ H | static int compute ( int [ ] graph , int N ) { int count = 0 ; for ( int i = 1 ; i < 7 ; i ++ ) { if ( graph [ i ] == 0 ) count ++ ; } return count ; }
HARD@@ Y_@@ RAM@@ AN@@ U@@ J@@ AN_@@ THE@@ O@@ RE@@ M | static int exact@@ Prime@@ Factor@@ Count ( int n ) { int count = 0 ; if ( n % 2 == 0 ) { count ++ ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { count ++ ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) count ++ ; return count ; }
SHOR@@ TEST_@@ COMM@@ ON@@ _SUP@@ ER@@ SEQU@@ ENCE_@@ 1 | static int super@@ Seq ( String X , String Y , int m , int n ) { int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }
POWER@@ _SET | static void print@@ Power@@ Set ( char [ ] set , int set_size ) { long pow_@@ set_size = ( long ) Math . pow ( 2 , set_size ) ; int counter , j ; for ( counter = 0 ; counter < pow_@@ set_size ; counter ++ ) { for ( j = 0 ; j < set_size ; j ++ ) { if ( ( counter & ( 1 << j ) ) > 0 ) System . out . print ( set [ j ] ) ; } System . out . println ( ) ; } }
CHECK_@@ ARRAY_@@ MAJ@@ ORI@@ TY_@@ ELEMENT | static boolean is@@ Maj@@ ority ( int a [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( a [ i ] ) ) mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; else mp . put ( a [ i ] , 1 ) ; for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) if ( x . getValue ( ) >= n / 2 ) return true ; return false ; }
PRINT_@@ GI@@ V@@ EN_@@ MATRIX_@@ COUNTER_@@ CLOCK_@@ WI@@ SE_@@ SPIR@@ AL_@@ FORM | static void counter@@ Clock@@ spir@@ al@@ Print ( int m , int n , int arr [ ] [ ] ) { int i , k = 0 , l = 0 ; int cnt = 0 ; int total = m * n ; while ( k < m && l < n ) { if ( cnt == total ) break ; for ( i = k ; i < m ; ++ i ) { System . out . print ( arr [ i ] [ l ] + " ▁ " ) ; cnt ++ ; } l ++ ; if ( cnt == total ) break ; for ( i = l ; i < n ; ++ i ) { System . out . print ( arr [ m - 1 ] [ i ] + " ▁ " ) ; cnt ++ ; } m -- ; if ( cnt == total ) break ; if ( k < m ) { for ( i = m - 1 ; i >= k ; -- i ) { System . out . print ( arr [ i ] [ n - 1 ] + " ▁ " ) ; cnt ++ ; } n -- ; } if ( cnt == total ) break ; if ( l < n ) { for ( i = n - 1 ; i >= l ; -- i ) { System . out . print ( arr [ k ] [ i ] + " ▁ " ) ; cnt ++ ; } k ++ ; } } }
PRI@@ MALI@@ TY_@@ TEST@@ _SET_@@ 1_@@ INTRO@@ DUC@@ TION_@@ AND@@ _S@@ CHOOL_@@ METHOD | static boolean is@@ Prime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
FIND_@@ CHARACTER_@@ FIRST_@@ STRING_@@ PRES@@ ENT_@@ MINIMUM_@@ INDEX@@ _SECON@@ D_@@ STRING | static void print@@ Min@@ Index@@ Char ( String str , String pat@@ t ) { int min@@ Index = Integer . MAX_VALUE ; int m = str . length ( ) ; int n = pat@@ t . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( pat@@ t . charAt ( i ) == str . charAt ( j ) && j < min@@ Index ) { min@@ Index = j ; break ; } } } if ( min@@ Index != Integer . MAX_VALUE ) System . out . println ( " Minimum ▁ Index ▁ Character ▁ = ▁ " + str . charAt ( min@@ Index ) ) ; else System . out . println ( " No ▁ character ▁ present " ) ; }
PROGRAM_@@ TO_@@ FIND_@@ TRANSP@@ OS@@ E_@@ OF_@@ A_@@ MATRIX_@@ 1 | static void transpose ( int A [ ] [ ] , int B [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; }
COUNT_@@ N@@ ATUR@@ AL_@@ NUMB@@ ERS_@@ WHO@@ SE_@@ PER@@ MU@@ TATION_@@ GREATER_@@ NUMBER | static int count@@ Number ( int n ) { int result = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) { Stack < Integer > s = new Stack < > ( ) ; if ( i <= n ) { s . push ( i ) ; result ++ ; } while ( ! s . empty ( ) ) { int tp = s . peek ( ) ; s . pop ( ) ; for ( int j = tp % 10 ; j <= 9 ; j ++ ) { int x = tp * 10 + j ; if ( x <= n ) { s . push ( x ) ; result ++ ; } } } } return result ; }
FIND_@@ FIRST_@@ N@@ ATUR@@ AL_@@ NUMBER_@@ WHO@@ SE_@@ FAC@@ TOR@@ I@@ AL_@@ DI@@ VISI@@ BLE_@@ X | static int first@@ Fac@@ tori@@ al@@ Di@@ visible@@ Number ( int x ) { int i = 1 ; int fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }
PRINT_@@ EQUAL@@ _S@@ UM@@ _SE@@ TS_@@ ARRAY_@@ PARTITION_@@ PRO@@ BLE@@ M@@ _SET_@@ 2 | static void print@@ Equal@@ Sum@@ Sets ( int [ ] arr , int n ) { int i , curr@@ Sum , sum = 0 ; for ( i = 0 ; i < arr . length ; i ++ ) sum += arr [ i ] ; if ( ( sum & 1 ) == 1 ) { System . out . print ( " - 1" ) ; return ; } int k = sum > > 1 ; boolean [ ] [ ] dp = new boolean [ n + 1 ] [ k + 1 ] ; for ( i = 1 ; i <= k ; i ++ ) dp [ 0 ] [ i ] = false ; for ( i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( i = 1 ; i <= n ; i ++ ) { for ( curr@@ Sum = 1 ; curr@@ Sum <= k ; curr@@ Sum ++ ) { dp [ i ] [ curr@@ Sum ] = dp [ i - 1 ] [ curr@@ Sum ] ; if ( arr [ i - 1 ] <= curr@@ Sum ) dp [ i ] [ curr@@ Sum ] = dp [ i ] [ curr@@ Sum ] | dp [ i - 1 ] [ curr@@ Sum - arr [ i - 1 ] ] ; } } List < Integer > set1 = new ArrayList < Integer > ( ) ; List < Integer > set2 = new ArrayList < Integer > ( ) ; if ( ! dp [ n ] [ k ] ) { System . out . print ( " - 1 \n " ) ; return ; } i = n ; curr@@ Sum = k ; while ( i > 0 && curr@@ Sum >= 0 ) { if ( dp [ i - 1 ] [ curr@@ Sum ] ) { i -- ; set2 . add ( arr [ i ] ) ; } else if ( dp [ i - 1 ] [ curr@@ Sum - arr [ i - 1 ] ] ) { i -- ; curr@@ Sum -= arr [ i ] ; set1 . add ( arr [ i ] ) ; } } System . out . print ( " Set ▁ 1 ▁ elements : ▁ " ) ; for ( i = 0 ; i < set1 . size ( ) ; i ++ ) System . out . print ( set1 . get ( i ) + " ▁ " ) ; System . out . print ( " \n Set ▁ 2 ▁ elements : ▁ " ) ; for ( i = 0 ; i < set2 . size ( ) ; i ++ ) System . out . print ( set2 . get ( i ) + " ▁ " ) ; }
COUN@@ TING_@@ PAIR@@ S_@@ PERS@@ ON_@@ CAN_@@ FORM_@@ PA@@ IR_@@ ONE@@ _1 | static int numberOf@@ W@@ ays ( int x ) { int dp [ ] = new int [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
COUNT_@@ NEGATIVE_@@ NUMB@@ ERS_@@ IN_@@ A_@@ COLUMN_@@ WI@@ SE_@@ ROW_@@ WI@@ SE_@@ SOR@@ TED_@@ MATRIX | static int count@@ Negative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; }
COUNT_@@ SET_@@ BITS_@@ IN_@@ AN_@@ INTEGER | static int count@@ Set@@ Bits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
MODUL@@ US_@@ TWO_@@ FLOAT_@@ DOUBLE_@@ NUMB@@ ERS | static double find@@ Mod ( double a , double b ) { if ( a < 0 ) a = - a ; if ( b < 0 ) b = - b ; double mod = a ; while ( mod >= b ) mod = mod - b ; if ( a < 0 ) return - mod ; return mod ; }
FIND_@@ A@@ _SPECI@@ FIC_@@ PA@@ IR_@@ IN_@@ MATRIX_@@ 1 | static int find@@ Max@@ Value ( int N , int mat [ ] [ ] ) { int maxValue = Integer . MIN_VALUE ; int max@@ Arr [ ] [ ] = new int [ N ] [ N ] ; max@@ Arr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ; int max@@ v = mat [ N - 1 ] [ N - 1 ] ; for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 ] [ j ] > max@@ v ) max@@ v = mat [ N - 1 ] [ j ] ; max@@ Arr [ N - 1 ] [ j ] = max@@ v ; } max@@ v = mat [ N - 1 ] [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( mat [ i ] [ N - 1 ] > max@@ v ) max@@ v = mat [ i ] [ N - 1 ] ; max@@ Arr [ i ] [ N - 1 ] = max@@ v ; } for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( max@@ Arr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = max@@ Arr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ; max@@ Arr [ i ] [ j ] = Math . max ( mat [ i ] [ j ] , Math . max ( max@@ Arr [ i ] [ j + 1 ] , max@@ Arr [ i + 1 ] [ j ] ) ) ; } } return maxValue ; }
MIN@@ IM@@ UM@@ _S@@ UM_@@ TWO_@@ NUMB@@ ERS_@@ FOR@@ MED_@@ DIG@@ IT@@ S_@@ ARRAY | static int solve ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }
COUNT_@@ DISTIN@@ CT_@@ NON_@@ NEGATIVE_@@ PAIR@@ S_@@ X_@@ Y_S@@ ATI@@ SF@@ Y_@@ IN@@ EQU@@ ALI@@ TY_@@ X@@ X_@@ YY_@@ N_@@ 2_1 | static int count@@ Solutions ( int n ) { int x = 0 , y@@ Count , res = 0 ; for ( y@@ Count = 0 ; y@@ Count * y@@ Count < n ; y@@ Count ++ ) ; while ( y@@ Count != 0 ) { res += y@@ Count ; x ++ ; while ( y@@ Count != 0 && ( x * x + ( y@@ Count - 1 ) * ( y@@ Count - 1 ) >= n ) ) y@@ Count -- ; } return res ; }
FIND_@@ INDEX_@@ GI@@ V@@ EN_@@ FI@@ BON@@ ACC@@ I_@@ NUMBER_@@ CONSTANT_@@ TIME | static int find@@ Index ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }
PROGRAM_@@ OC@@ TAL_@@ DECIMAL_@@ CONVERSION | static int oct@@ al@@ To@@ Decimal ( int n ) { int num = n ; int dec_@@ value = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { int last_@@ digit = temp % 10 ; temp = temp / 10 ; dec_@@ value += last_@@ digit * base ; base = base * 8 ; } return dec_@@ value ; }
FIND_@@ PER@@ MU@@ TED_@@ RO@@ WS_@@ GI@@ V@@ EN_@@ ROW_@@ MATRIX | static void per@@ mut@@ ated@@ Rows ( int mat [ ] [ ] , int m , int n , int r ) { LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) s . add ( mat [ r ] [ j ] ) ; for ( int i = 0 ; i < m ; i ++ ) { if ( i == r ) continue ; int j ; for ( j = 0 ; j < n ; j ++ ) if ( ! s . contains ( mat [ i ] [ j ] ) ) break ; if ( j != n ) continue ; System . out . print ( i + " , ▁ " ) ; } }
PRINT_@@ A_@@ CLO@@ SE@@ ST_@@ STRING_@@ TH@@ AT_@@ DO@@ ES_@@ NOT_@@ CONTA@@ IN_@@ AD@@ J@@ AC@@ ENT_@@ DUPLIC@@ A@@ TES | public static String no@@ Adjac@@ ent@@ D@@ up ( String s1 ) { int n = s1 . length ( ) ; char [ ] s = s1 . toCharArray ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = ' a ' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return ( new String ( s ) ) ; }
S@@ UM_@@ MAN@@ H@@ ATTA@@ N_@@ DISTAN@@ CES_@@ PAIR@@ S_@@ POINTS | static int distance@@ sum ( int x [ ] , int y [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; return sum ; }
PROGRAM_@@ FIND_@@ STRING_@@ START_@@ END_@@ GE@@ E@@ KS | static boolean is@@ Corner@@ Present ( String str , String corner ) { int n = str . length ( ) ; int cl = corner . length ( ) ; if ( n < cl ) return false ; return ( str . substring ( 0 , cl ) . equals ( corner ) && str . substring ( n - cl , n ) . equals ( corner ) ) ; }
LON@@ GE@@ ST@@ _SUB@@ ARRAY_@@ COUNT_@@ 1@@ S_@@ ONE_@@ COUNT_@@ 0@@ S | static int len@@ Of@@ Long@@ Sub@@ arr ( int arr [ ] , int n ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( ! um . containsKey ( sum ) ) um . put ( sum , i ) ; if ( um . containsKey ( sum - 1 ) ) { if ( maxLen < ( i - um . get ( sum - 1 ) ) ) maxLen = i - um . get ( sum - 1 ) ; } } return maxLen ; }
DI@@ VI@@ DE_@@ CON@@ QUER@@ _SET_@@ 6@@ _SEARCH_@@ ROW_@@ WI@@ SE_@@ COLUMN_@@ WI@@ SE_@@ SOR@@ TED_@@ 2D_@@ ARRAY | public static void search ( int [ ] [ ] mat , int from@@ Row , int to@@ Row , int from@@ Col , int to@@ Col , int key ) { int i = from@@ Row + ( to@@ Row - from@@ Row ) / 2 ; int j = from@@ Col + ( to@@ Col - from@@ Col ) / 2 ; if ( mat [ i ] [ j ] == key ) System . out . println ( " Found ▁ " + key + " ▁ at ▁ " + i + " ▁ " + j ) ; else { if ( i != to@@ Row || j != from@@ Col ) search ( mat , from@@ Row , i , j , to@@ Col , key ) ; if ( from@@ Row == to@@ Row && from@@ Col + 1 == to@@ Col ) if ( mat [ from@@ Row ] [ to@@ Col ] == key ) System . out . println ( " Found ▁ " + key + " ▁ at ▁ " + from@@ Row + " ▁ " + to@@ Col ) ; if ( mat [ i ] [ j ] < key ) { if ( i + 1 <= to@@ Row ) search ( mat , i + 1 , to@@ Row , from@@ Col , to@@ Col , key ) ; } else { if ( j - 1 >= from@@ Col ) search ( mat , from@@ Row , to@@ Row , from@@ Col , j - 1 , key ) ; } } }
SHOR@@ TEST_@@ COMM@@ ON@@ _SUP@@ ER@@ SEQUENCE | static int super@@ Seq ( String X , String Y , int m , int n ) { if ( m == 0 ) return n ; if ( n == 0 ) return m ; if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) return 1 + super@@ Seq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . min ( super@@ Seq ( X , Y , m - 1 , n ) , super@@ Seq ( X , Y , m , n - 1 ) ) ; }
UR@@ LI@@ FY_@@ GI@@ V@@ EN_@@ STRING_@@ REPL@@ ACE_@@ SPAC@@ ES | static char [ ] replace@@ Spaces ( char [ ] str ) { int space_@@ count = 0 , i = 0 ; for ( i = 0 ; i < str . length ; i ++ ) if ( str [ i ] == ' ▁ ' ) space_@@ count ++ ; while ( str [ i - 1 ] == ' ▁ ' ) { space_@@ count -- ; i -- ; } int new_@@ length = i + space_@@ count * 2 ; if ( new_@@ length > MAX ) return str ; int index = new_@@ length - 1 ; char [ ] new_@@ str = str ; str = new char [ new_@@ length ] ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( new_@@ str [ j ] == ' ▁ ' ) { str [ index ] = '0' ; str [ index - 1 ] = '2' ; str [ index - 2 ] = ' % ' ; index = index - 3 ; } else { str [ index ] = new_@@ str [ j ] ; index -- ; } } return str ; }
MAXIMUM_@@ PATH@@ _S@@ UM_@@ START@@ ING_@@ CELL_@@ 0_@@ TH_@@ ROW_@@ END@@ ING_@@ CELL_@@ N_@@ 1_@@ TH_@@ ROW | static int Maximum@@ Path ( int Mat [ ] [ ] ) { int result = 0 ; int dp [ ] [ ] = new int [ N ] [ N + 2 ] ; for ( int [ ] rows : dp ) Arrays . fill ( rows , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) result = Math . max ( result , dp [ N - 1 ] [ i ] ) ; return result ; }
COMP@@ UTE_@@ THE_@@ INTEGER_@@ ABSOL@@ UTE_@@ VALUE_@@ AB@@ S_@@ WITH@@ OUT_@@ BRAN@@ CH@@ ING | static int get@@ Abs ( int n ) { int mask = n > > ( SIZE_@@ INT * CHAR_@@ BIT - 1 ) ; return ( ( n + mask ) ^ mask ) ; }
COUNT_@@ PA@@ LIN@@ DRO@@ MI@@ C@@ _SUB@@ SEQU@@ ENCE_@@ GI@@ V@@ EN_@@ STRING_@@ 1 | static int count@@ PS ( int i , int j ) { if ( i >= n || j < 0 ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( ( i - j == 1 ) || ( i - j == - 1 ) ) { if ( str . charAt ( i ) == str . charAt ( j ) ) return dp [ i ] [ j ] = 3 ; else return dp [ i ] [ j ] = 2 ; } if ( i == j ) return dp [ 1 ] [ j ] = 1 ; else if ( str . charAt ( i ) == str . charAt ( j ) ) return dp [ i ] [ j ] = count@@ PS ( i + 1 , j ) + count@@ PS ( i , j - 1 ) + 1 ; else return dp [ i ] [ j ] = count@@ PS ( i + 1 , j ) + count@@ PS ( i , j - 1 ) - count@@ PS ( i + 1 , j - 1 ) ; }
LAR@@ GE@@ ST@@ _S@@ UM_@@ CON@@ TI@@ GU@@ OU@@ S@@ _SUB@@ ARRAY_@@ 2 | static int max@@ Sub@@ Array@@ Sum ( int a [ ] , int size ) { int max_@@ so@@ _f@@ ar = a [ 0 ] ; int curr_@@ max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_@@ max = Math . max ( a [ i ] , curr_@@ max + a [ i ] ) ; max_@@ so@@ _f@@ ar = Math . max ( max_@@ so@@ _f@@ ar , curr_@@ max ) ; } return max_@@ so@@ _f@@ ar ; }
COUNT_@@ MINIMUM_@@ STE@@ PS_@@ GET_@@ GI@@ V@@ EN_@@ DE@@ SI@@ RED_@@ ARRAY | static int count@@ Min@@ Operations ( int n ) { int result = 0 ; while ( true ) { int zero_@@ count = 0 ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) break ; else if ( arr [ i ] == 0 ) zero_@@ count ++ ; } if ( zero_@@ count == n ) return result ; if ( i == n ) { for ( int j = 0 ; j < n ; j ++ ) arr [ j ] = arr [ j ] / 2 ; result ++ ; } for ( int j = i ; j < n ; j ++ ) { if ( arr [ j ] % 2 == 1 ) { arr [ j ] -- ; result ++ ; } } } }
PRINT_@@ FI@@ BON@@ AC@@ CI@@ _SEQU@@ ENCE_@@ USING_@@ 2_@@ VARIAB@@ LES_@@ 1 | static void fi@@ b ( int n ) { int a = 0 , b = 1 ; if ( n >= 0 ) System . out . print ( a + " ▁ " ) ; if ( n >= 1 ) System . out . print ( b + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { System . out . print ( a + b + " ▁ " ) ; b = a + b ; a = b - a ; } }
PROGRAM_@@ CHECK_@@ INPUT_@@ INTEGER_@@ STRING | static boolean is@@ Number ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( Character . is@@ Digit ( s . charAt ( i ) ) == false ) return false ; return true ; }
MINIMUM_@@ HEIGHT_@@ TRIANGLE_@@ GI@@ V@@ EN_@@ BASE_@@ AREA | static double min@@ Height ( double base , double area ) { double d = ( 2 * area ) / base ; return Math . ceil ( d ) ; }
FIND_@@ POSITION_@@ GI@@ V@@ EN_@@ NUMBER_@@ AM@@ ONG_@@ NUMB@@ ERS_@@ MA@@ DE_@@ 4_@@ 7 | static int find@@ pos ( String n ) { int k = 0 , pos = 0 , i = 0 ; while ( k != n . length ( ) ) { switch ( n . charAt ( i ) ) { case '4' : pos = pos * 2 + 1 ; break ; case '7' : pos = pos * 2 + 2 ; break ; } i ++ ; k ++ ; } return pos ; }
MINIMUM_@@ OPER@@ ATION@@ S_@@ REQUI@@ RED@@ _SET_@@ ELEMEN@@ TS_@@ BINARY_@@ MATRIX | static int min@@ Operation ( boolean arr [ ] [ ] ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == false ) { ans ++ ; for ( int k = 0 ; k <= i ; k ++ ) { for ( int h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == true ) { arr [ k ] [ h ] = false ; } else { arr [ k ] [ h ] = true ; } } } } } } return ans ; }
LON@@ GE@@ ST_@@ EV@@ EN_@@ LENGTH@@ _SUB@@ STRING@@ _S@@ UM_@@ FIR@@ ST@@ _SECON@@ D_@@ HALF_@@ 2 | static int find@@ Length ( String str , int n ) { int sum [ ] = new int [ n + 1 ] ; sum [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum [ i ] = ( sum [ i - 1 ] + str . charAt ( i - 1 ) - '0' ) ; int ans = 0 ; for ( int len = 2 ; len <= n ; len += 2 ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; if ( sum [ i + len / 2 ] - sum [ i ] == sum [ i + len ] - sum [ i + len / 2 ] ) ans = Math . max ( ans , len ) ; } } return ans ; }
MULTI@@ PLY_@@ LARGE_@@ NUMB@@ ERS_@@ RE@@ PRESEN@@ TED_@@ AS_@@ STRINGS | static String multiply ( String num1 , String num2 ) { int len1 = num1 . length ( ) ; int len2 = num2 . length ( ) ; if ( len1 == 0 || len2 == 0 ) return "0" ; int result [ ] = new int [ len1 + len2 ] ; int i_@@ n1 = 0 ; int i_@@ n2 = 0 ; for ( int i = len1 - 1 ; i >= 0 ; i -- ) { int carry = 0 ; int n1 = num1 . charAt ( i ) - '0' ; i_@@ n2 = 0 ; for ( int j = len2 - 1 ; j >= 0 ; j -- ) { int n2 = num2 . charAt ( j ) - '0' ; int sum = n1 * n2 + result [ i_@@ n1 + i_@@ n2 ] + carry ; carry = sum / 10 ; result [ i_@@ n1 + i_@@ n2 ] = sum % 10 ; i_@@ n2 ++ ; } if ( carry > 0 ) result [ i_@@ n1 + i_@@ n2 ] += carry ; i_@@ n1 ++ ; } int i = result . length - 1 ; while ( i >= 0 && result [ i ] == 0 ) i -- ; if ( i == - 1 ) return "0" ; String s = " " ; while ( i >= 0 ) s += ( result [ i -- ] ) ; return s ; }
PARTITION_@@ NUMBER_@@ TWO_@@ DI@@ VI@@ S@@ BLE_@@ PAR@@ TS | static void find@@ Division ( String str , int a , int b ) { int len = str . length ( ) ; int [ ] lr = new int [ len + 1 ] ; lr [ 0 ] = ( ( int ) str . charAt ( 0 ) - ( int ) '0' ) % a ; for ( int i = 1 ; i < len ; i ++ ) lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + ( ( int ) str . charAt ( i ) - ( int ) '0' ) ) % a ; int [ ] rl = new int [ len + 1 ] ; rl [ len - 1 ] = ( ( int ) str . charAt ( len - 1 ) - ( int ) '0' ) % b ; int power@@ 10 = 10 ; for ( int i = len - 2 ; i >= 0 ; i -- ) { rl [ i ] = ( rl [ i + 1 ] + ( ( int ) str . charAt ( i ) - ( int ) '0' ) * power@@ 10 ) % b ; power@@ 10 = ( power@@ 10 * 10 ) % b ; } for ( int i = 0 ; i < len - 1 ; i ++ ) { if ( lr [ i ] != 0 ) continue ; if ( rl [ i + 1 ] == 0 ) { System . out . println ( " YES " ) ; for ( int k = 0 ; k <= i ; k ++ ) System . out . print ( str . charAt ( k ) ) ; System . out . print ( " , ▁ " ) ; for ( int k = i + 1 ; k < len ; k ++ ) System . out . print ( str . charAt ( k ) ) ; return ; } } System . out . println ( " NO " ) ; }
PROGRAM_@@ BE@@ ST_@@ FI@@ T_@@ ALGORITH@@ M_@@ MEMORY_@@ MAN@@ A@@ GEMENT | static void best@@ Fit ( int blockSize [ ] , int m , int process@@ Size [ ] , int n ) { int allocation [ ] = new int [ n ] ; for ( int i = 0 ; i < allocation . length ; i ++ ) allocation [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int best@@ Idx = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= process@@ Size [ i ] ) { if ( best@@ Idx == - 1 ) best@@ Idx = j ; else if ( blockSize [ best@@ Idx ] > blockSize [ j ] ) best@@ Idx = j ; } } if ( best@@ Idx != - 1 ) { allocation [ i ] = best@@ Idx ; blockSize [ best@@ Idx ] -= process@@ Size [ i ] ; } } System . out . println ( " \n Process ▁ No . \t@@ Process ▁ Size@@ \t@@ Block ▁ no . " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( " ▁ ▁ ▁ " + ( i + 1 ) + " \t\t " + process@@ Size [ i ] + " \t\t " ) ; if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 ) ; else System . out . print ( " Not ▁ Allocated " ) ; System . out . println ( ) ; } }
FIN@@ DING_@@ THE_@@ MAX@@ IM@@ UM@@ _S@@ QU@@ ARE_@@ SUB_@@ MATRIX_@@ WITH_@@ ALL_@@ EQUAL_@@ ELEMENTS | static int lar@@ gest@@ K@@ Sub@@ matrix ( int [ ] [ ] a ) { int [ ] [ ] dp = new int [ Row ] [ Col ] ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 || j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] && dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i - 1 ] [ j ] : ( dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j ] && dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i ] [ j - 1 ] : dp [ i - 1 ] [ j - 1 ] + 1 ; } else dp [ i ] [ j ] = 1 ; } result = result > dp [ i ] [ j ] ? result : dp [ i ] [ j ] ; } } return result ; }
FRI@@ END@@ S_@@ PAIR@@ ING_@@ PRO@@ BLE@@ M_@@ 1 | static int count@@ Fri@@ ends@@ Pair@@ ings ( int n ) { if ( dp [ n ] != - 1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = count@@ Fri@@ ends@@ Pair@@ ings ( n - 1 ) + ( n - 1 ) * count@@ Fri@@ ends@@ Pair@@ ings ( n - 2 ) ; else return dp [ n ] = n ; }
FIRST_@@ ELEMENT_@@ OC@@ CURR@@ ING_@@ K_@@ TIME@@ S_@@ ARRAY | static int first@@ Element ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > count_@@ map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = 0 ; if ( count_@@ map . get ( arr [ i ] ) != null ) { a = count_@@ map . get ( arr [ i ] ) ; } count_@@ map . put ( arr [ i ] , a + 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( count_@@ map . get ( arr [ i ] ) == k ) { return arr [ i ] ; } } return - 1 ; }
SUM@@ _SERI@@ ES_@@ 0_@@ 6_@@ 0_@@ 06_@@ 0_@@ 00@@ 6_@@ 0_@@ 00@@ 06_@@ N_@@ TER@@ MS | static double sum@@ Of@@ Series ( int n ) { return ( 0.@@ 666 ) * ( 1 - 1 / Math . pow ( 10 , n ) ) ; }
COUNT_@@ WOR@@ DS_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ STRING | static int count@@ Words ( String str ) { int state = OUT ; int wc = 0 ; int i = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) == ' ▁ ' || str . charAt ( i ) == ' \n ' || str . charAt ( i ) == ' \t ' ) state = OUT ; else if ( state == OUT ) { state = IN ; ++ wc ; } ++ i ; } return wc ; }
PARTITION_@@ IN@@ TO_@@ TW@@ O@@ _SUB@@ ARRAY@@ S_@@ OF_@@ LENGTH@@ S_@@ K_@@ AND_@@ N_@@ K@@ _SU@@ CH_@@ TH@@ AT_@@ THE_@@ DIFF@@ ER@@ ENCE_@@ OF@@ _S@@ UM@@ S_@@ IS_@@ MAX@@ IMUM | static int max@@ Difference ( int arr [ ] , int N , int k ) { int M , S = 0 , S1 = 0 , max_@@ difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; int temp ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } M = Math . max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_@@ difference = S1 - ( S - S1 ) ; return max_@@ difference ; }
HO@@ W_@@ WI@@ LL_@@ Y@@ OU@@ _@@ PRINT_@@ NUMB@@ ERS_@@ FROM_@@ 1_@@ TO_@@ 200@@ _@@ WITH@@ OUT_@@ USING_@@ LOOP | static void print@@ No@@ s ( int n ) { if ( n > 0 ) { print@@ No@@ s ( n - 1 ) ; System . out . print ( n + " ▁ " ) ; } return ; }
GI@@ V@@ EN_@@ A@@ _S@@ OR@@ TED_@@ AND_@@ ROTA@@ TED_@@ ARRAY_@@ FIND_@@ IF_@@ THER@@ E_@@ IS_@@ A_@@ PA@@ IR_@@ WITH_@@ A_@@ GI@@ VEN@@ _S@@ UM@@ _1 | static int pair@@ sIn@@ Sorted@@ Rot@@ ated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }
FIND_@@ THE_@@ ELEMENT_@@ TH@@ AT_@@ AP@@ PE@@ AR@@ S_@@ ONCE | static int get@@ Single ( int arr [ ] , int n ) { int ones = 0 , tw@@ os = 0 ; int common_@@ bit@@ _mask ; for ( int i = 0 ; i < n ; i ++ ) { tw@@ os = tw@@ os | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_@@ bit@@ _mask = ~ ( ones & tw@@ os ) ; ones &= common_@@ bit@@ _mask ; tw@@ os &= common_@@ bit@@ _mask ; } return ones ; }
CAS@@ SIN@@ IS_@@ IDENTITY | static int c@@ ass@@ ini ( int n ) { return ( n & 1 ) != 0 ? - 1 : 1 ; }
DISTRIBU@@ TING_@@ ALL_@@ BAL@@ LS_@@ WITH@@ OUT_@@ REPE@@ TI@@ TION | static boolean distribu@@ ting@@ Bal@@ ls ( long k , long n , String str ) { int [ ] a = new int [ MAX_@@ CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ str . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) if ( a [ i ] > k ) return false ; return true ; }
DISTRIBU@@ TING_@@ ITE@@ MS_@@ PERS@@ ON_@@ CANNOT_@@ TA@@ KE_@@ TWO_@@ ITE@@ MS_@@ TYPE | static boolean check@@ Count ( int [ ] arr , int n , int k ) { int count ; for ( int i = 0 ; i < n ; i ++ ) { count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] == arr [ i ] ) count ++ ; if ( count > 2 * k ) return false ; } } return true ; }
MAXI@@ MI@@ ZE_@@ ARR@@ J_@@ AR@@ RI@@ _@@ ARR@@ L_@@ ARR@@ K@@ _SU@@ CH_@@ TH@@ AT_@@ I_@@ J_@@ K_@@ L | static int find@@ Max@@ Value ( int [ ] arr , int n ) { if ( n < 4 ) { System . out . println ( " The ▁ array ▁ should ▁ have " + " ▁ at@@ least ▁ 4 ▁ elements " ) ; } int table1 [ ] = new int [ n + 1 ] ; int table@@ 2 [ ] = new int [ n ] ; int table@@ 3 [ ] = new int [ n - 1 ] ; int table@@ 4 [ ] = new int [ n - 2 ] ; Arrays . fill ( table1 , Integer . MIN_VALUE ) ; Arrays . fill ( table@@ 2 , Integer . MIN_VALUE ) ; Arrays . fill ( table@@ 3 , Integer . MIN_VALUE ) ; Arrays . fill ( table@@ 4 , Integer . MIN_VALUE ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ] ) ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { table@@ 2 [ i ] = Math . max ( table@@ 2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) ; } for ( int i = n - 3 ; i >= 0 ; i -- ) table@@ 3 [ i ] = Math . max ( table@@ 3 [ i + 1 ] , table@@ 2 [ i + 1 ] + arr [ i ] ) ; for ( int i = n - 4 ; i >= 0 ; i -- ) table@@ 4 [ i ] = Math . max ( table@@ 4 [ i + 1 ] , table@@ 3 [ i + 1 ] - arr [ i ] ) ; return table@@ 4 [ 0 ] ; }
COUNT_@@ NEGATIVE_@@ NUMB@@ ERS_@@ IN_@@ A_@@ COLUMN_@@ WI@@ SE_@@ ROW_@@ WI@@ SE_@@ SOR@@ TED_@@ MATRIX_@@ 1 | static int count@@ Negative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; }
SORT_@@ AN_@@ ARRAY_@@ OF_@@ 0@@ S_@@ 1@@ S_@@ AND_@@ 2@@ S | static void sort@@ 012 ( int a [ ] , int arr_@@ size ) { int lo = 0 ; int hi = arr_@@ size - 1 ; int mid = 0 , temp = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : { temp = a [ lo ] ; a [ lo ] = a [ mid ] ; a [ mid ] = temp ; lo ++ ; mid ++ ; break ; } case 1 : mid ++ ; break ; case 2 : { temp = a [ mid ] ; a [ mid ] = a [ hi ] ; a [ hi ] = temp ; hi -- ; break ; } } } }
N@@ TH_@@ EV@@ EN_@@ FI@@ BON@@ ACC@@ I_@@ NUMBER | static long even@@ Fi@@ b ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * even@@ Fi@@ b ( n - 1 ) ) + even@@ Fi@@ b ( n - 2 ) ) ; }
NEXT_@@ GREATER_@@ ELEMENT | static void print@@ N@@ GE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } System . out . println ( arr [ i ] + " ▁ - - ▁ " + next ) ; } }
CHECK_@@ WHE@@ THER_@@ GI@@ V@@ EN_@@ CI@@ R@@ CLE_@@ RE@@ SIDE_@@ BOUN@@ DARY_@@ MAIN@@ TA@@ IN@@ ED_@@ OU@@ TER_@@ CI@@ R@@ CLE_@@ IN@@ NER_@@ CIRC@@ LE | static void fit@@ Or@@ Not@@ Fit ( int R , int r , int x , int y , int rad ) { double val = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) System . out . println ( " F@@ its " ) ; else System . out . println ( " Doesn ' t ▁ Fit " ) ; }
BASIC_@@ AND_@@ EXTENDED_@@ EUC@@ LI@@ DE@@ AN_@@ ALGORITH@@ MS_@@ 1 | public static int g@@ cd@@ Extended ( int a , int b , int x , int y ) { if ( a == 0 ) { x = 0 ; y = 1 ; return b ; } int x1 = 1 , y1 = 1 ; int gcd = g@@ cd@@ Extended ( b % a , a , x1 , y1 ) ; x = y1 - ( b / a ) * x1 ; y = x1 ; return gcd ; }
FIN@@ D_S@@ MAL@@ LE@@ ST_@@ RANGE_@@ CONTAIN@@ ING_@@ ELEMEN@@ TS_@@ FROM_@@ K_@@ LI@@ STS | static void find@@ S@@ malle@@ st@@ Range ( int arr [ ] [ ] , int n , int k ) { int i , min@@ val , maxval , min@@ range , min@@ el = 0 , max@@ el = 0 , flag , min@@ ind ; for ( i = 0 ; i <= k ; i ++ ) { ptr [ i ] = 0 ; } min@@ range = Integer . MAX_VALUE ; while ( true ) { min@@ ind = - 1 ; min@@ val = Integer . MAX_VALUE ; maxval = Integer . MIN_VALUE ; flag = 0 ; for ( i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == n ) { flag = 1 ; break ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < min@@ val ) { min@@ ind = i ; min@@ val = arr [ i ] [ ptr [ i ] ] ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) { maxval = arr [ i ] [ ptr [ i ] ] ; } } if ( flag == 1 ) { break ; } ptr [ min@@ ind ] ++ ; if ( ( maxval - min@@ val ) < min@@ range ) { min@@ el = min@@ val ; max@@ el = maxval ; min@@ range = max@@ el - min@@ el ; } } System . out . printf ( " The ▁ smallest ▁ range ▁ is ▁ [ % d ▁ , ▁ % d ] \n " , min@@ el , max@@ el ) ; }
FIND_@@ THE_@@ MINIMUM_@@ CO@@ ST_@@ TO_@@ REACH_@@ A_@@ DESTIN@@ ATION_@@ W@@ HER@@ E_@@ EVER@@ Y_@@ ST@@ ATION_@@ IS_@@ CONNEC@@ TED_@@ IN_@@ ONE_@@ DIRECTION | static int min@@ Cost ( int cost [ ] [ ] ) { int dist [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; }
MIDD@@ LE_@@ OF_@@ THRE@@ E_@@ USING_@@ MINIMUM_@@ COMP@@ ARIS@@ ONS_@@ 1 | public static int middle@@ Of@@ Three ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }
CHECK_@@ LARGE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 11_@@ NOT | static boolean check ( String str ) { int n = str . length ( ) ; int odd@@ Dig@@ Sum = 0 , even@@ Dig@@ Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) odd@@ Dig@@ Sum += ( str . charAt ( i ) - '0' ) ; else even@@ Dig@@ Sum += ( str . charAt ( i ) - '0' ) ; } return ( ( odd@@ Dig@@ Sum - even@@ Dig@@ Sum ) % 11 == 0 ) ; }
COMP@@ UTE_@@ MODUL@@ US_@@ DI@@ VISI@@ ON_@@ BY_@@ A_@@ POWER_@@ OF_@@ 2_@@ NUMBER | static int get@@ Modul@@ o ( int n , int d ) { return ( n & ( d - 1 ) ) ; }
COUNT_@@ BINARY_@@ STRING@@ S_@@ K_@@ TIME@@ S_@@ AP@@ PE@@ AR@@ ING_@@ AD@@ J@@ AC@@ ENT_@@ TW@@ O@@ _SET_@@ BITS | static int count@@ Strings ( int n , int k ) { int dp [ ] [ ] [ ] = new int [ n + 1 ] [ k + 1 ] [ 2 ] ; dp [ 1 ] [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j < i && j < k + 1 ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) { dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }
FIN@@ DING_@@ K_@@ MODUL@@ US_@@ ARRAY_@@ ELEMENT | static void print@@ Equal@@ Mod@@ Numbers ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int d = arr [ n - 1 ] - arr [ 0 ] ; Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) { v . add ( i ) ; if ( i != d / i ) v . add ( d / i ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int temp = arr [ 0 ] % v . get ( i ) ; int j ; for ( j = 1 ; j < n ; j ++ ) if ( arr [ j ] % v . get ( i ) != temp ) break ; if ( j == n ) System . out . print ( v . get ( i ) + " ▁ " ) ; } }
CIRC@@ ULAR_@@ MATRIX_@@ CONSTRUC@@ T_@@ A_@@ MATRIX_@@ WITH_@@ NUMB@@ ERS_@@ 1_@@ TO_@@ M@@ N_@@ IN@@ _SP@@ IR@@ AL_@@ WAY | static void spir@@ al@@ Fill ( int m , int n , int a [ ] [ ] ) { int val = 1 ; int k = 0 , l = 0 ; while ( k < m && l < n ) { for ( int i = l ; i < n ; ++ i ) { a [ k ] [ i ] = val ++ ; } k ++ ; for ( int i = k ; i < m ; ++ i ) { a [ i ] [ n - 1 ] = val ++ ; } n -- ; if ( k < m ) { for ( int i = n - 1 ; i >= l ; -- i ) { a [ m - 1 ] [ i ] = val ++ ; } m -- ; } if ( l < n ) { for ( int i = m - 1 ; i >= k ; -- i ) { a [ i ] [ l ] = val ++ ; } l ++ ; } } }
FIND_@@ THE_@@ TWO_@@ REPE@@ ATING_@@ ELEMEN@@ TS_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ 2 | void print@@ Repe@@ ating ( int arr [ ] , int size ) { int xor = arr [ 0 ] ; int set_@@ bit_@@ no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor ^= i ; set_@@ bit_@@ no = ( xor & ~ ( xor - 1 ) ) ; for ( i = 0 ; i < size ; i ++ ) { int a = arr [ i ] & set_@@ bit_@@ no ; if ( a != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { int a = i & set_@@ bit_@@ no ; if ( a != 0 ) x = x ^ i ; else y = y ^ i ; } System . out . println ( " The ▁ two ▁ re@@ pp@@ e@@ ated ▁ elements ▁ are ▁ : " ) ; System . out . println ( x + " ▁ " + y ) ; }
COUNT_@@ POSSI@@ BLE_@@ WAY@@ S_TO_@@ CONSTRUC@@ T_@@ BUILD@@ INGS | static int count@@ W@@ ays ( int N ) { if ( N == 1 ) return 4 ; int count@@ B = 1 , count@@ S = 1 , prev_@@ count@@ B , prev_@@ count@@ S ; for ( int i = 2 ; i <= N ; i ++ ) { prev_@@ count@@ B = count@@ B ; prev_@@ count@@ S = count@@ S ; count@@ S = prev_@@ count@@ B + prev_@@ count@@ S ; count@@ B = prev_@@ count@@ S ; } int result = count@@ S + count@@ B ; return ( result * result ) ; }
ONE_@@ LINE_@@ FUNCTION_@@ FOR_@@ FAC@@ TOR@@ I@@ AL_@@ OF_@@ A_@@ NUMBER | static int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
CHECK_@@ GI@@ V@@ EN_@@ MATRI@@ X@@ _S@@ PARSE_@@ NOT | static boolean is@@ Sparse ( int array [ ] [ ] , int m , int n ) { int counter = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( array [ i ] [ j ] == 0 ) ++ counter ; return ( counter > ( ( m * n ) / 2 ) ) ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 10_@@ 0_@@ 1_@@ KN@@ AP@@ S@@ ACK_@@ PRO@@ BLE@@ M | static int kn@@ ap@@ S@@ ack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return kn@@ ap@@ S@@ ack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + kn@@ ap@@ S@@ ack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , kn@@ ap@@ S@@ ack ( W , wt , val , n - 1 ) ) ; }
FIN@@ D@@ _SUB@@ ARRAY_@@ LEA@@ ST_@@ AVER@@ AGE | static void find@@ Min@@ Avg@@ Sub@@ array ( int n , int k ) { if ( n < k ) return ; int res_@@ index = 0 ; int curr_@@ sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_@@ sum += arr [ i ] ; int min_@@ sum = curr_@@ sum ; for ( int i = k ; i < n ; i ++ ) { curr_@@ sum += arr [ i ] - arr [ i - k ] ; if ( curr_@@ sum < min_@@ sum ) { min_@@ sum = curr_@@ sum ; res_@@ index = ( i - k + 1 ) ; } } System . out . println ( " Sub@@ array ▁ between ▁ [ " + res_@@ index + " , ▁ " + ( res_@@ index + k - 1 ) + " ] ▁ has ▁ minimum ▁ average " ) ; }
QUER@@ I@@ ES_@@ FOR_@@ CHARAC@@ TER@@ S_IN_@@ A_@@ REPE@@ ATED_@@ STRING | static void query ( String s , int i , int j ) { int n = s . length ( ) ; i %= n ; j %= n ; if ( s . charAt ( i ) == s . charAt ( j ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
A_@@ PRODUCT_@@ ARRAY_@@ PU@@ ZZ@@ LE_@@ 1 | void product@@ Array ( int arr [ ] , int n ) { if ( n == 1 ) { System . out . print ( "0" ) ; return ; } int i , temp = 1 ; int prod [ ] = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) prod [ j ] = 1 ; for ( i = 0 ; i < n ; i ++ ) { prod [ i ] = temp ; temp *= arr [ i ] ; } temp = 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { prod [ i ] *= temp ; temp *= arr [ i ] ; } for ( i = 0 ; i < n ; i ++ ) System . out . print ( prod [ i ] + " ▁ " ) ; return ; }
FIND_@@ PAIR@@ S_@@ GI@@ VEN@@ _S@@ UM_@@ ELEMEN@@ TS_@@ PA@@ IR_@@ DIFF@@ ER@@ ENT_@@ ROWS | static void pair@@ Sum ( int mat [ ] [ ] , int n , int sum ) { for ( int i = 0 ; i < n ; i ++ ) Arrays . sort ( mat [ i ] ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int left = 0 , right = n - 1 ; while ( left < n && right >= 0 ) { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) { System . out . print ( " ( " + mat [ i ] [ left ] + " , ▁ " + mat [ j ] [ right ] + " ) , ▁ " ) ; left ++ ; right -- ; } else { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) left ++ ; else right -- ; } } } } }
CHECK_@@ STRING_@@ CAN_@@ OB@@ TA@@ IN@@ ED_@@ ROTA@@ TING_@@ AN@@ OTHER_@@ STRING_@@ 2_@@ PL@@ AC@@ ES | static boolean is@@ Rot@@ ated ( String str1 , String str2 ) { if ( str1 . length ( ) != str2 . length ( ) ) return false ; String clock_@@ rot = " " ; String an@@ tic@@ lock_@@ rot = " " ; int len = str2 . length ( ) ; an@@ tic@@ lock_@@ rot = an@@ tic@@ lock_@@ rot + str2 . substring ( len - 2 , len ) + str2 . substring ( 0 , len - 2 ) ; clock_@@ rot = clock_@@ rot + str2 . substring ( 2 ) + str2 . substring ( 0 , 2 ) ; return ( str1 . equals ( clock_@@ rot ) || str1 . equals ( an@@ tic@@ lock_@@ rot ) ) ; }
N_@@ TH_@@ NUMBER_@@ WHO@@ SE_@@ S@@ UM_@@ OF_@@ DIG@@ IT@@ S_@@ IS_@@ TEN | public static int find@@ N@@ th ( int n ) { int count = 0 ; for ( int curr = 1 ; ; curr ++ ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } }
PROGRAM_@@ FIN@@ D_S@@ LO@@ PE_@@ LINE | static float slope ( float x1 , float y1 , float x2 , float y2 ) { return ( y2 - y1 ) / ( x2 - x1 ) ; }
GC@@ D_@@ ELEMEN@@ TS_@@ GI@@ V@@ EN_@@ RANGE | static int range@@ GC@@ D ( int n , int m ) { return ( n == m ) ? n : 1 ; }
LON@@ GE@@ ST_@@ ALTER@@ N@@ AT@@ ING@@ _SUB_@@ ARRAY_@@ START@@ ING_@@ EVER@@ Y_@@ INDEX_@@ BINARY_@@ ARRAY_@@ 1 | static void alternate@@ Sub@@ array ( boolean arr [ ] , int n ) { int count = 1 ; boolean prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { if ( ( arr [ i ] ^ prev ) == false ) { while ( count > 0 ) { System . out . print ( count -- + " ▁ " ) ; } } ++ count ; prev = arr [ i ] ; } while ( count != 0 ) { System . out . print ( count -- + " ▁ " ) ; } }
FIND_@@ UNIT_@@ DIG@@ IT_@@ X_@@ RAI@@ SED_@@ POWER_@@ Y | static int unit@@ Digit@@ X@@ Rai@@ sed@@ Y ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; }
MULTI@@ PLY_@@ LARGE_@@ INTEG@@ ERS_@@ UN@@ DER_@@ LARGE_@@ MODUL@@ O | static long modu@@ lo@@ Multiplic@@ ation ( long a , long b , long mod ) { long res = 0 ; a %= mod ; while ( b > 0 ) { if ( ( b & 1 ) > 0 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; b >>= 1 ; } return res ; }
FIN@@ D_S@@ MAL@@ LE@@ ST_@@ NUMBER_@@ WITH_@@ GI@@ V@@ EN_@@ NUMBER_OF_@@ DIG@@ IT@@ S_@@ AND_@@ DIG@@ IT_@@ SUM | static void find@@ S@@ malle@@ st ( int m , int s ) { if ( s == 0 ) { System . out . print ( m == 1 ? " S@@ malle@@ st ▁ number ▁ is ▁ 0" : " Not ▁ possible " ) ; return ; } if ( s > 9 * m ) { System . out . println ( " Not ▁ possible " ) ; return ; } int [ ] res = new int [ m ] ; s -= 1 ; for ( int i = m - 1 ; i > 0 ; i -- ) { if ( s > 9 ) { res [ i ] = 9 ; s -= 9 ; } else { res [ i ] = s ; s = 0 ; } } res [ 0 ] = s + 1 ; System . out . print ( " S@@ malle@@ st ▁ number ▁ is ▁ " ) ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( res [ i ] ) ; }
C_@@ PROGRAM_@@ FIND_@@ LAR@@ GE@@ ST_@@ ELEMENT_@@ ARRAY | static int largest ( ) { int i ; int max = arr [ 0 ] ; for ( i = 1 ; i < arr . length ; i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ; return max ; }
COUNT_@@ NUMB@@ ERS_@@ CAN_@@ CONSTRUC@@ TED_@@ USING_@@ TWO_@@ NUMB@@ ERS | static int count@@ Num@@ s ( int n , int x , int y ) { boolean [ ] arr = new boolean [ n + 1 ] ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; int result = 0 ; for ( int i = Math . min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }
BU@@ BB@@ LE_@@ SORT_@@ 1 | static void bu@@ bble@@ Sort ( int arr [ ] , int n ) { int i , j , temp ; boolean swapped ; for ( i = 0 ; i < n - 1 ; i ++ ) { swapped = false ; for ( j = 0 ; j < n - i - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; swapped = true ; } } if ( swapped == false ) break ; } }
MAX@@ IM@@ UM@@ _S@@ UM_@@ 2_@@ X_@@ N_@@ GRID_@@ NO_@@ TWO_@@ ELEMEN@@ TS_@@ AD@@ J@@ AC@@ ENT | public static int max@@ Sum ( int grid [ ] [ ] , int n ) { int in@@ cl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; int ex@@ cl = 0 , ex@@ cl_@@ new ; for ( int i = 1 ; i < n ; i ++ ) { ex@@ cl_@@ new = Math . max ( ex@@ cl , in@@ cl ) ; in@@ cl = ex@@ cl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; ex@@ cl = ex@@ cl_@@ new ; } return Math . max ( ex@@ cl , in@@ cl ) ; }
GC@@ D_@@ FAC@@ TOR@@ I@@ AL@@ S_@@ TWO_@@ NUMB@@ ERS | static int g@@ cd@@ Of@@ Fac@@ tori@@ al ( int m , int n ) { int min = m < n ? m : n ; return factorial ( min ) ; }
AREA_@@ OF_@@ A@@ _SEC@@ TOR | static void Sector@@ Area ( double radius , double angle ) { if ( angle >= 360 ) System . out . println ( " Angle ▁ not ▁ possible " ) ; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; System . out . println ( sector ) ; } }
COUNT_@@ EV@@ EN_@@ LENGTH_@@ BIN@@ AR@@ Y@@ _SEQU@@ EN@@ CES_@@ WITH@@ _S@@ AME_@@ S@@ UM_@@ OF_@@ FIRST_@@ AND@@ _SECON@@ D_@@ HALF_@@ BITS_@@ 1 | static int count@@ Seq ( int n ) { int n@@ Cr = 1 , res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) { n@@ Cr = ( n@@ Cr * ( n + 1 - r ) ) / r ; res += n@@ Cr * n@@ Cr ; } return res ; }
LON@@ GE@@ ST_@@ EV@@ EN_@@ LENGTH@@ _SUB@@ STRING@@ _S@@ UM_@@ FIR@@ ST@@ _SECON@@ D_@@ HALF_@@ 1 | static int find@@ Length ( String str ) { int n = str . length ( ) ; int maxlen = 0 ; int sum [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) sum [ i ] [ i ] = str . charAt ( i ) - '0' ; for ( int len = 2 ; len <= n ; len ++ ) { for ( int i = 0 ; i < n - len + 1 ; i ++ ) { int j = i + len - 1 ; int k = len / 2 ; sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 ] [ j ] ; if ( len % 2 == 0 && sum [ i ] [ j - k ] == sum [ ( j - k + 1 ) ] [ j ] && len > maxlen ) maxlen = len ; } } return maxlen ; }
SW@@ AP_@@ ALL_@@ OD@@ D_@@ AND_@@ EV@@ EN_@@ BITS | static int swap@@ Bits ( int x ) { int even@@ _bits = x & 0x@@ AAAA@@ AAAA ; int od@@ d_@@ bits = x & 0x5@@ 5555@@ 555 ; even@@ _bits >>= 1 ; od@@ d_@@ bits <<= 1 ; return ( even@@ _bits | od@@ d_@@ bits ) ; }
SORT_@@ ARRAY_@@ WAVE_@@ FORM_@@ 2 | void sort@@ In@@ Wave ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i += 2 ) swap ( arr , i , i + 1 ) ; }
FIND_@@ HAR@@ MON@@ IC_@@ ME@@ AN_@@ USING_@@ ARI@@ TH@@ ME@@ TIC_@@ ME@@ AN_@@ GEO@@ METRIC_@@ MEAN | static double compute ( int a , int b ) { double AM , GM , H@@ M ; AM = ( a + b ) / 2 ; GM = Math . sqrt ( a * b ) ; H@@ M = ( GM * GM ) / AM ; return H@@ M ; }
COUNT_@@ BAL@@ AN@@ CED_@@ BINARY_@@ TRE@@ ES_@@ HEIGHT_@@ H | public static long count@@ BT ( int h ) { long [ ] dp = new long [ h + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ; return dp [ h ] ; }
MINIMUM_@@ INSER@@ TIONS_@@ TO_@@ FORM_@@ A_@@ PA@@ LIN@@ DRO@@ ME_@@ WITH_@@ PER@@ MU@@ TA@@ TIONS_@@ ALLOWED | static int min@@ Insertion ( String str ) { int n = str . length ( ) ; int res = 0 ; int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] % 2 == 1 ) res ++ ; } return ( res == 0 ) ? 0 : res - 1 ; }
SHUFF@@ LE_@@ A_@@ GI@@ V@@ EN_@@ ARRAY | static void randomize ( int arr [ ] , int n ) { Random r = new Random ( ) ; for ( int i = n - 1 ; i > 0 ; i -- ) { int j = r . nextInt ( i + 1 ) ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } System . out . println ( Arrays . toString ( arr ) ) ; }
U@@ GL@@ Y_@@ NUMB@@ ERS | int getN@@ th@@ U@@ gl@@ y@@ No ( int n ) { int ugly [ ] = new int [ n ] ; int i2 = 0 , i3 = 0 , i@@ 5 = 0 ; int next_@@ multiple_@@ of_@@ 2 = 2 ; int next_@@ multiple_@@ of_@@ 3 = 3 ; int next_@@ multiple_@@ of_@@ 5 = 5 ; int next_@@ u@@ gl@@ y_@@ no = 1 ; ugly [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { next_@@ u@@ gl@@ y_@@ no = Math . min ( next_@@ multiple_@@ of_@@ 2 , Math . min ( next_@@ multiple_@@ of_@@ 3 , next_@@ multiple_@@ of_@@ 5 ) ) ; ugly [ i ] = next_@@ u@@ gl@@ y_@@ no ; if ( next_@@ u@@ gl@@ y_@@ no == next_@@ multiple_@@ of_@@ 2 ) { i2 = i2 + 1 ; next_@@ multiple_@@ of_@@ 2 = ugly [ i2 ] * 2 ; } if ( next_@@ u@@ gl@@ y_@@ no == next_@@ multiple_@@ of_@@ 3 ) { i3 = i3 + 1 ; next_@@ multiple_@@ of_@@ 3 = ugly [ i3 ] * 3 ; } if ( next_@@ u@@ gl@@ y_@@ no == next_@@ multiple_@@ of_@@ 5 ) { i@@ 5 = i@@ 5 + 1 ; next_@@ multiple_@@ of_@@ 5 = ugly [ i@@ 5 ] * 5 ; } } return next_@@ u@@ gl@@ y_@@ no ; }
MINIMUM_@@ CO@@ ST_@@ CU@@ T_@@ BO@@ AR@@ D_S@@ QUAR@@ ES | static int minimum@@ Cost@@ Of@@ Brea@@ king ( Integer X [ ] , Integer Y [ ] , int m , int n ) { int res = 0 ; Arrays . sort ( X , Collections . reverse@@ Order ( ) ) ; Arrays . sort ( Y , Collections . reverse@@ Order ( ) ) ; int h@@ z@@ n@@ tl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; h@@ z@@ n@@ tl ++ ; i ++ ; } else { res += Y [ j ] * h@@ z@@ n@@ tl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * h@@ z@@ n@@ tl ; return res ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 10_@@ 0_@@ 1_@@ KN@@ AP@@ S@@ ACK_@@ PRO@@ BLE@@ M_@@ 1 | static int kn@@ ap@@ S@@ ack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }
STACK_@@ PER@@ MU@@ TA@@ TIONS_@@ CHECK_@@ IF_@@ AN_@@ ARRAY_@@ IS_@@ STACK_@@ PER@@ MU@@ TATION_@@ OF_@@ OTHER | static boolean check@@ Stack@@ Permutation ( int ip [ ] , int op [ ] , int n ) { Queue < Integer > input = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { input . add ( ip [ i ] ) ; } Queue < Integer > output = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { output . add ( op [ i ] ) ; } Stack < Integer > temp@@ Stack = new Stack < > ( ) ; while ( ! input . isEmpty ( ) ) { int ele = input . poll ( ) ; if ( ele == output . peek ( ) ) { output . poll ( ) ; while ( ! temp@@ Stack . isEmpty ( ) ) { if ( temp@@ Stack . peek ( ) == output . peek ( ) ) { temp@@ Stack . pop ( ) ; output . poll ( ) ; } else break ; } } else { temp@@ Stack . push ( ele ) ; } } return ( input . isEmpty ( ) && temp@@ Stack . isEmpty ( ) ) ; }
PRO@@ B@@ AB@@ ILITY_@@ THRE@@ E_@@ RAN@@ DOM@@ LY_@@ CH@@ OS@@ EN_@@ NUMB@@ ERS_@@ AP | static double pro@@ cal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }
REMOVE_@@ BRAC@@ KE@@ TS_@@ AL@@ GE@@ BRA@@ IC_@@ STRING_@@ CONTAIN@@ ING_@@ OPER@@ ATORS | static String simplify ( String str ) { int len = str . length ( ) ; char res [ ] = new char [ len ] ; int index = 0 , i = 0 ; Stack < Integer > s = new Stack < Integer > ( ) ; s . push ( 0 ) ; while ( i < len ) { if ( str . charAt ( i ) == ' + ' ) { if ( s . peek ( ) == 1 ) res [ index ++ ] = ' - ' ; if ( s . peek ( ) == 0 ) res [ index ++ ] = ' + ' ; } else if ( str . charAt ( i ) == ' - ' ) { if ( s . peek ( ) == 1 ) res [ index ++ ] = ' + ' ; else if ( s . peek ( ) == 0 ) res [ index ++ ] = ' - ' ; } else if ( str . charAt ( i ) == ' ( ' && i > 0 ) { if ( str . charAt ( i - 1 ) == ' - ' ) { int x = ( s . peek ( ) == 1 ) ? 0 : 1 ; s . push ( x ) ; } else if ( str . charAt ( i - 1 ) == ' + ' ) s . push ( s . peek ( ) ) ; } else if ( str . charAt ( i ) == ' ) ' ) s . pop ( ) ; else res [ index ++ ] = str . charAt ( i ) ; i ++ ; } return new String ( res ) ; }
FIND_@@ NUMBER_@@ PER@@ F@@ ECT_@@ SQU@@ AR@@ ES_@@ TWO_@@ GI@@ V@@ EN_@@ NUMB@@ ERS | static int count@@ Squ@@ ares ( int a , int b ) { int cnt = 0 ; for ( int i = a ; i <= b ; i ++ ) for ( int j = 1 ; j * j <= i ; j ++ ) if ( j * j == i ) cnt ++ ; return cnt ; }
K_@@ NUMB@@ ERS_@@ DIFF@@ ER@@ ENCE_@@ MAXIMUM_@@ MINIMUM_@@ K_@@ NUMBER_@@ MINI@@ MIZ@@ ED | static int min@@ Diff ( int arr [ ] , int n , int k ) { int result = Integer . MAX_VALUE ; Arrays . sort ( arr ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
CHECK_@@ LARGE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 13_@@ NOT | static boolean check@@ Di@@ visibility ( String num ) { int length = num . length ( ) ; if ( length == 1 && num . charAt ( 0 ) == '0' ) return true ; if ( length % 3 == 1 ) { num += "@@ 00" ; length += 2 ; } else if ( length % 3 == 2 ) { num += "0" ; length += 1 ; } int sum = 0 , p = 1 ; for ( int i = length - 1 ; i >= 0 ; i -- ) { int group = 0 ; group += num . charAt ( i -- ) - '0' ; group += ( num . charAt ( i -- ) - '0' ) * 10 ; group += ( num . charAt ( i ) - '0' ) * 100 ; sum = sum + group * p ; p *= ( - 1 ) ; } sum = Math . abs ( sum ) ; return ( sum % 13 == 0 ) ; }
GI@@ V@@ EN_@@ N_@@ X_@@ N_S@@ QU@@ ARE_@@ MATRIX_@@ FIN@@ D_S@@ UM@@ _SUB@@ _S@@ QUAR@@ ES@@ _SIZE_@@ K_@@ X_@@ K | static void print@@ Sum@@ Simple ( int mat [ ] [ ] , int k ) { if ( k > n ) return ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { for ( int j = 0 ; j < n - k + 1 ; j ++ ) { int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; System . out . print ( sum + " ▁ " ) ; } System . out . println ( ) ; } }
FIND_@@ THE_@@ POINT_@@ W@@ HER@@ E_@@ MAXIMUM_@@ INTER@@ VAL@@ S_@@ OVER@@ L@@ AP_@@ 1 | public static void max@@ Overlap ( int [ ] start , int [ ] end , int n ) { int max@@ a = Arrays . stream ( start ) . max ( ) . getAs@@ Int ( ) ; int max@@ b = Arrays . stream ( end ) . max ( ) . getAs@@ Int ( ) ; int max@@ c = Math . max ( max@@ a , max@@ b ) ; int [ ] x = new int [ max@@ c + 2 ] ; Arrays . fill ( x , 0 ) ; int cur = 0 , idx = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ++ x [ start [ i ] ] ; -- x [ end [ i ] + 1 ] ; } int maxy = Integer . MIN_VALUE ; for ( int i = 0 ; i <= max@@ c ; i ++ ) { cur += x [ i ] ; if ( maxy < cur ) { maxy = cur ; idx = i ; } } System . out . println ( " Maximum ▁ value ▁ is : " + maxy + " ▁ at ▁ position : ▁ " + idx + " " ) ; }
MAX@@ IM@@ UM@@ _SUB@@ SEQU@@ ENCE_@@ SUM@@ _SU@@ CH_@@ TH@@ AT_@@ NO_@@ THRE@@ E_@@ ARE_@@ CON@@ SEC@@ UTI@@ VE_@@ 1 | static int max@@ Sum@@ WO@@ 3@@ Con@@ sec ( int n ) { if ( sum [ n ] != - 1 ) return sum [ n ] ; if ( n == 0 ) return sum [ n ] = 0 ; if ( n == 1 ) return sum [ n ] = arr [ 0 ] ; if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; return sum [ n ] = Math . max ( Math . max ( max@@ Sum@@ WO@@ 3@@ Con@@ sec ( n - 1 ) , max@@ Sum@@ WO@@ 3@@ Con@@ sec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + max@@ Sum@@ WO@@ 3@@ Con@@ sec ( n - 3 ) ) ; }
C_@@ PROGRAM_@@ ADDI@@ TION_@@ TWO_@@ MATRI@@ CES | static void add ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; }
FIND_@@ MAXIMUM_@@ AVER@@ AGE_@@ SUB@@ ARRAY_@@ OF_@@ K_@@ LENGTH_@@ 1 | static int find@@ Max@@ Average ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_@@ sum = sum , max_@@ end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_@@ sum ) { max_@@ sum = sum ; max_@@ end = i ; } } return max_@@ end - k + 1 ; }
FIND_@@ CENTER_@@ CI@@ R@@ CLE_@@ USING_@@ END@@ POINT@@ S_@@ DI@@ AME@@ TER | static void center ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( float ) ( x1 + x2 ) / 2 + " , ▁ " + ( float ) ( y1 + y2 ) / 2 ) ; }
TOTAL_@@ NUMBER_OF_@@ NON_@@ DECRE@@ AS@@ ING_@@ NUMB@@ ERS_@@ WITH_@@ N_@@ DIGITS | static int count@@ Non@@ Decre@@ asing ( int n ) { int dp [ ] [ ] = new int [ 10 ] [ n + 1 ] ; for ( int i = 0 ; i < 10 ; i ++ ) dp [ i ] [ 1 ] = 1 ; for ( int digit = 0 ; digit <= 9 ; digit ++ ) { for ( int len = 2 ; len <= n ; len ++ ) { for ( int x = 0 ; x <= digit ; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ i ] [ n ] ; return count ; }
PRINT_@@ REVERSE_@@ STRING_@@ REMO@@ V@@ ING_@@ VO@@ WEL@@ S | static void replace@@ Original ( String s , int n ) { char r [ ] = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s . charAt ( n - 1 - i ) ; if ( s . charAt ( i ) != ' a ' && s . charAt ( i ) != ' e ' && s . charAt ( i ) != ' i ' && s . charAt ( i ) != ' o ' && s . charAt ( i ) != ' u ' ) { System . out . print ( r [ i ] ) ; } } System . out . println ( " " ) ; }
FIND_@@ ELEMEN@@ TS_@@ PRES@@ ENT_@@ FIRST_@@ ARRAY_@@ NOT_@@ SECON@@ D_@@ 1 | static void find@@ Missing ( int a [ ] , int b [ ] , int n , int m ) { HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < m ; i ++ ) s . add ( b [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ! s . contains ( a [ i ] ) ) System . out . print ( a [ i ] + " ▁ " ) ; }
COUNT_@@ STRING@@ S_@@ CAN_@@ FOR@@ MED_@@ USING_@@ B_@@ C_@@ GI@@ V@@ EN_@@ CONSTRA@@ INTS | static int count@@ Str ( int n , int b@@ Count , int c@@ Count ) { if ( b@@ Count < 0 || c@@ Count < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( b@@ Count == 0 && c@@ Count == 0 ) return 1 ; int res = count@@ Str ( n - 1 , b@@ Count , c@@ Count ) ; res += count@@ Str ( n - 1 , b@@ Count - 1 , c@@ Count ) ; res += count@@ Str ( n - 1 , b@@ Count , c@@ Count - 1 ) ; return res ; }
GO@@ LD_@@ MINE_@@ PRO@@ BLE@@ M | static int getMax@@ G@@ old ( int gold [ ] [ ] , int m , int n ) { int gold@@ Table [ ] [ ] = new int [ m ] [ n ] ; for ( int [ ] rows : gold@@ Table ) Arrays . fill ( rows , 0 ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : gold@@ Table [ row ] [ col + 1 ] ; int right_@@ up = ( row == 0 || col == n - 1 ) ? 0 : gold@@ Table [ row - 1 ] [ col + 1 ] ; int right_@@ down = ( row == m - 1 || col == n - 1 ) ? 0 : gold@@ Table [ row + 1 ] [ col + 1 ] ; gold@@ Table [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_@@ up , right_@@ down ) ) ; ; } } int res = gold@@ Table [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = Math . max ( res , gold@@ Table [ i ] [ 0 ] ) ; return res ; }
COUNT_@@ WAY@@ S_@@ BUILD_@@ STRE@@ ET_@@ GI@@ V@@ EN_@@ CONSTRA@@ INTS | static long count@@ W@@ ays ( int n ) { long dp [ ] [ ] = new long [ 2 ] [ n + 1 ] ; dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }
RETURN_@@ A_@@ PA@@ IR_@@ WITH_@@ MAXIMUM_@@ PRODUCT_@@ IN_@@ ARRAY_@@ OF_@@ INTEG@@ ERS_@@ 1 | static void max@@ Product ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . println ( " No ▁ pairs ▁ exists " ) ; return ; } if ( n == 2 ) { System . out . println ( arr [ 0 ] + " ▁ " + arr [ 1 ] ) ; return ; } int pos@@ a = Integer . MIN_VALUE , pos@@ b = Integer . MIN_VALUE ; int neg@@ a = Integer . MIN_VALUE , neg@@ b = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > pos@@ a ) { pos@@ b = pos@@ a ; pos@@ a = arr [ i ] ; } else if ( arr [ i ] > pos@@ b ) pos@@ b = arr [ i ] ; if ( arr [ i ] < 0 && Math . abs ( arr [ i ] ) > Math . abs ( neg@@ a ) ) { neg@@ b = neg@@ a ; neg@@ a = arr [ i ] ; } else if ( arr [ i ] < 0 && Math . abs ( arr [ i ] ) > Math . abs ( neg@@ b ) ) neg@@ b = arr [ i ] ; } if ( neg@@ a * neg@@ b > pos@@ a * pos@@ b ) System . out . println ( " Max ▁ product ▁ pair ▁ is ▁ { " + neg@@ a + " , ▁ " + neg@@ b + " } " ) ; else System . out . println ( " Max ▁ product ▁ pair ▁ is ▁ { " + pos@@ a + " , ▁ " + pos@@ b + " } " ) ; }
POSITION_@@ OF_@@ RIGHT@@ MO@@ ST@@ _SET_@@ BIT | public static int getFirst@@ Set@@ Bit@@ Pos ( int n ) { return ( int ) ( ( Math . log10 ( n & - n ) ) / Math . log10 ( 2 ) ) + 1 ; }
LON@@ GE@@ ST@@ _SUB@@ SEQU@@ ENCE_@@ W@@ HER@@ E_@@ EVER@@ Y_@@ CHARACTER_@@ AP@@ PE@@ AR@@ S_@@ AT_@@ LEA@@ ST_@@ K_@@ TIMES | static void lon@@ gest@@ Sub@@ seq@@ With@@ K ( String str , int k ) { int n = str . length ( ) ; int freq [ ] = new int [ MAX_@@ CHARS ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str . charAt ( i ) - ' a ' ] >= k ) { System . out . print ( str . charAt ( i ) ) ; } } }
POSSI@@ BLE_@@ TO_@@ MAKE_@@ A_@@ DI@@ VISI@@ BLE_@@ BY_@@ 3_@@ NUMBER_@@ USING_@@ ALL_@@ DIG@@ IT@@ S_IN_@@ AN_@@ ARRAY | public static boolean is@@ Possible@@ To@@ Make@@ Di@@ visible ( int arr [ ] , int n ) { int remainder = 0 ; for ( int i = 0 ; i < n ; i ++ ) remainder = ( remainder + arr [ i ] ) % 3 ; return ( remainder == 0 ) ; }
ARE@@ A@@ _S@@ QU@@ ARE_@@ CIRCUM@@ SCRI@@ BED_@@ CIRC@@ LE | static int find_@@ Area ( int r ) { return ( 2 * r * r ) ; }
FIND_@@ MAXIMUM_@@ DOT_@@ PRODUCT_@@ TWO_@@ ARRAY@@ S_@@ INSER@@ TION_@@ 0@@ S | static int Max@@ DotProduct ( int A [ ] , int B [ ] , int m , int n ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int [ ] row : dp ) Arrays . fill ( row , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= m ; j ++ ) dp [ i ] [ j ] = Math . max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ; return dp [ n ] [ m ] ; }
FIND_@@ DISTIN@@ CT_@@ SUB@@ SET_@@ SUB@@ SEQU@@ ENCE_@@ SUM@@ S_@@ ARRAY | static void print@@ Dist@@ Sum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; boolean [ ] [ ] dp = new boolean [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( int j = 0 ; j <= sum ; j ++ ) if ( dp [ n ] [ j ] == true ) System . out . print ( j + " ▁ " ) ; }
SP@@ LIT_@@ NUMERIC_@@ ALPH@@ AB@@ E@@ TIC_@@ AND@@ _SPECI@@ AL_@@ SYMBO@@ LS_@@ FROM_@@ A_@@ STRING | static void split@@ String ( String str ) { StringBuffer alpha = new StringBuffer ( ) , num = new StringBuffer ( ) , special = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( Character . is@@ Digit ( str . charAt ( i ) ) ) num . append ( str . charAt ( i ) ) ; else if ( Character . is@@ Alphab@@ e@@ tic ( str . charAt ( i ) ) ) alpha . append ( str . charAt ( i ) ) ; else special . append ( str . charAt ( i ) ) ; } System . out . println ( alpha ) ; System . out . println ( num ) ; System . out . println ( special ) ; }
MAX@@ IM@@ UM@@ _S@@ UM_@@ ALTER@@ N@@ AT@@ ING@@ _SUB@@ SEQU@@ ENCE_@@ SUM | static int max@@ Alternate@@ Sum ( int arr [ ] , int n ) { if ( n == 1 ) return arr [ 0 ] ; int dec [ ] = new int [ n ] ; int inc [ ] = new int [ n ] ; dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ; int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i ] = Math . max ( inc [ i ] , dec [ j ] + arr [ i ] ) ; } } int result = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( result < inc [ i ] ) result = inc [ i ] ; if ( result < dec [ i ] ) result = dec [ i ] ; } return result ; }
FIND_@@ PA@@ IR_@@ MAXIMUM_@@ GC@@ D_@@ ARRAY | public static int find@@ Max@@ GC@@ D ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = Math . max ( high , arr [ i ] ) ; int di@@ visors [ ] = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= Math . sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { di@@ visors [ j ] ++ ; if ( j != arr [ i ] / j ) di@@ visors [ arr [ i ] / j ] ++ ; } } } for ( int i = high ; i >= 1 ; i -- ) if ( di@@ visors [ i ] > 1 ) return i ; return 1 ; }
FIND_@@ MINIMUM_@@ NUMBER_OF_@@ CO@@ INS_@@ TH@@ AT_@@ MAKE_@@ A_@@ CHANGE_@@ 1 | static int min@@ Coins ( int coins [ ] , int m , int V ) { int table [ ] = new int [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = Integer . MAX_VALUE ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( coins [ j ] <= i ) { int sub_@@ res = table [ i - coins [ j ] ] ; if ( sub_@@ res != Integer . MAX_VALUE && sub_@@ res + 1 < table [ i ] ) table [ i ] = sub_@@ res + 1 ; } } return table [ V ] ; }
S@@ UM_@@ NODE@@ S_@@ K_@@ TH_@@ LEVEL_@@ TREE_@@ RE@@ PRESEN@@ TED_@@ STRING | static int sum@@ At@@ K@@ th@@ Level ( String tree , int k ) { int level = - 1 ; int sum = 0 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree . charAt ( i ) == ' ( ' ) level ++ ; else if ( tree . charAt ( i ) == ' ) ' ) level -- ; else { if ( level == k ) sum += ( tree . charAt ( i ) - '0' ) ; } } return sum ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 4_@@ LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ SEQUENCE | int l@@ cs ( char [ ] X , char [ ] Y , int m , int n ) { if ( m == 0 || n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + l@@ cs ( X , Y , m - 1 , n - 1 ) ; else return max ( l@@ cs ( X , Y , m , n - 1 ) , l@@ cs ( X , Y , m - 1 , n ) ) ; }
CHECK_@@ GI@@ VEN@@ _S@@ ENT@@ ENCE_@@ GI@@ VEN@@ _SET_@@ SIMPLE_@@ GR@@ AM@@ M@@ ER_@@ RULES | static boolean check@@ Sentence ( char [ ] str ) { int len = str . length ; if ( str [ 0 ] < ' A ' || str [ 0 ] > ' Z ' ) return false ; if ( str [ len - 1 ] != ' . ' ) return false ; int prev_state = 0 , curr_@@ state = 0 ; int index = 1 ; while ( index <= str . length ) { if ( str [ index ] >= ' A ' && str [ index ] <= ' Z ' ) curr_@@ state = 0 ; else if ( str [ index ] == ' ▁ ' ) curr_@@ state = 1 ; else if ( str [ index ] >= ' a ' && str [ index ] <= ' z ' ) curr_@@ state = 2 ; else if ( str [ index ] == ' . ' ) curr_@@ state = 3 ; if ( prev_state == curr_@@ state && curr_@@ state != 2 ) return false ; if ( prev_state == 2 && curr_@@ state == 0 ) return false ; if ( curr_@@ state == 3 && prev_state != 1 ) return ( index + 1 == str . length ) ; index ++ ; prev_state = curr_@@ state ; } return false ; }
CHECK_@@ DI@@ VISIBILITY_@@ LARGE_@@ NUMBER_@@ 999 | static boolean is@@ Di@@ visible@@ 999 ( String num ) { int n = num . length ( ) ; if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ; if ( n % 3 == 1 ) num = "@@ 00" + num ; if ( n % 3 == 2 ) num = "0" + num ; int g@@ Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int group = 0 ; group += ( num . charAt ( i ++ ) - '0' ) * 100 ; group += ( num . charAt ( i ++ ) - '0' ) * 10 ; group += num . charAt ( i ) - '0' ; g@@ Sum += group ; } if ( g@@ Sum > 1000 ) { num = Integer . toString ( g@@ Sum ) ; n = num . length ( ) ; g@@ Sum = is@@ Di@@ visible@@ 999 ( num ) ? 1 : 0 ; } return ( g@@ Sum == 999 ) ; }
CHECK_@@ LARGE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 9_@@ NOT | static boolean check ( String str ) { int n = str . length ( ) ; int digit@@ Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digit@@ Sum += ( str . charAt ( i ) - '0' ) ; return ( digit@@ Sum % 9 == 0 ) ; }
NUMBER_OF_@@ BINARY_@@ TRE@@ ES_@@ FOR_@@ GI@@ V@@ EN_@@ PRE@@ ORDER@@ _SEQU@@ ENCE_@@ LENGTH | static int count@@ Trees ( int n ) { int BT [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) BT [ i ] = 0 ; BT [ 0 ] = BT [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; j ++ ) BT [ i ] += BT [ j ] * BT [ i - j - 1 ] ; return BT [ n ] ; }
PROGR@@ AM@@ _SW@@ AP_@@ UPPER_@@ DIAG@@ ON@@ AL_@@ ELEMEN@@ TS_@@ LOWER_@@ DIAG@@ ON@@ AL_@@ ELEMEN@@ TS_@@ MATRIX | static void swap@@ Upper@@ ToLower ( int arr [ ] [ ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int temp = arr [ i ] [ j ] ; arr [ i ] [ j ] = arr [ j ] [ i ] ; arr [ j ] [ i ] = temp ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( arr [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } }
FIN@@ D_S@@ UM_@@ MODUL@@ O_@@ K_@@ FIRST_@@ N_@@ N@@ ATUR@@ AL_@@ NUMBER_@@ 1 | static int find@@ Sum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
WAY@@ S_@@ REMOVE_@@ ONE_@@ ELEMENT_@@ BINARY_@@ STRING_@@ X@@ OR_@@ BE@@ CO@@ ME@@ S_@@ ZERO | static int xor@@ Zero ( String s ) { int one_@@ count = 0 , zero_@@ count = 0 ; char [ ] str = s . toCharArray ( ) ; int n = str . length ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) one_@@ count ++ ; else zero_@@ count ++ ; if ( one_@@ count % 2 == 0 ) return zero_@@ count ; return one_@@ count ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 7_@@ CO@@ IN_@@ CHANGE | static int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }
MIN@@ IM@@ UM@@ _S@@ UM@@ _SUB@@ SEQU@@ ENCE_@@ LEA@@ ST_@@ ONE_@@ EVER@@ Y_@@ FOUR_@@ CON@@ SEC@@ UTI@@ VE_@@ ELEMEN@@ TS_@@ PIC@@ KED | static int min@@ Sum ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return Math . min ( arr [ 0 ] , arr [ 1 ] ) ; if ( n == 3 ) return Math . min ( arr [ 0 ] , Math . min ( arr [ 1 ] , arr [ 2 ] ) ) ; if ( n == 4 ) return Math . min ( Math . min ( arr [ 0 ] , arr [ 1 ] ) , Math . min ( arr [ 2 ] , arr [ 3 ] ) ) ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = arr [ 1 ] ; dp [ 2 ] = arr [ 2 ] ; dp [ 3 ] = arr [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) dp [ i ] = arr [ i ] + Math . min ( Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) , Math . min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ; return Math . min ( Math . min ( dp [ n - 1 ] , dp [ n - 2 ] ) , Math . min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ; }
MAXIMUM_@@ PATH@@ _S@@ UM_@@ TRI@@ ANGLE | static int max@@ Path@@ Sum ( int tri [ ] [ ] , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; }
FIND_@@ THRE@@ E_@@ ELEMENT_@@ FROM_@@ DIFF@@ ER@@ ENT_@@ THRE@@ E_@@ ARRAY@@ S@@ _SU@@ CH_@@ TH@@ AT_@@ TH@@ AT_@@ A_@@ B_@@ C_@@ K | static boolean find@@ Trip@@ let ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }
TA@@ IL_@@ RECUR@@ SION_@@ FI@@ BON@@ AC@@ CI | static int fi@@ b ( int n , int a , int b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; return fi@@ b ( n - 1 , b , a + b ) ; }
PROGRAM_@@ TO_@@ CHECK_@@ IF_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ IS_@@ L@@ UC@@ K@@ Y_@@ ALL_@@ DIG@@ IT@@ S_@@ ARE_@@ DIFF@@ ER@@ ENT | static boolean is@@ Lu@@ ck@@ y ( int n ) { boolean arr [ ] = new boolean [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; }
GI@@ V@@ EN_@@ N_@@ X_@@ N_S@@ QU@@ ARE_@@ MATRIX_@@ FIN@@ D_S@@ UM@@ _SUB@@ _S@@ QUAR@@ ES@@ _SIZE_@@ K_@@ X_@@ K_@@ 1 | static void print@@ Sum@@ Tri@@ ck@@ y ( int mat [ ] [ ] , int k ) { if ( k > n ) return ; int strip@@ Sum [ ] [ ] = new int [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += mat [ i ] [ j ] ; strip@@ Sum [ 0 ] [ j ] = sum ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ; strip@@ Sum [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += strip@@ Sum [ i ] [ j ] ; System . out . print ( sum + " ▁ " ) ; for ( int j = 1 ; j < n - k + 1 ; j ++ ) { sum += ( strip@@ Sum [ i ] [ j + k - 1 ] - strip@@ Sum [ i ] [ j - 1 ] ) ; System . out . print ( sum + " ▁ " ) ; } System . out . println ( ) ; } }
SCHEDUL@@ E_@@ ELE@@ V@@ ATOR_@@ TO_@@ RED@@ UCE_@@ THE_@@ TOTAL_@@ TIME_@@ TA@@ KEN | static int min@@ Time ( int n , int k , int a [ ] ) { int temp ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] < a [ j ] ) { temp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = temp ; } } } int min@@ Time = 0 ; for ( int i = 0 ; i < n ; i += k ) min@@ Time += ( 2 * a [ i ] ) ; return min@@ Time ; }
OD@@ D_@@ EV@@ EN@@ _S@@ ORT_@@ B@@ RICK@@ _S@@ ORT | public static void odd@@ Even@@ Sort ( int arr [ ] , int n ) { boolean is@@ Sorted = false ; while ( ! is@@ Sorted ) { is@@ Sorted = true ; int temp = 0 ; for ( int i = 1 ; i <= n - 2 ; i = i + 2 ) { if ( arr [ i ] > arr [ i + 1 ] ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; is@@ Sorted = false ; } } for ( int i = 0 ; i <= n - 2 ; i = i + 2 ) { if ( arr [ i ] > arr [ i + 1 ] ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; is@@ Sorted = false ; } } } return ; }
RETURN_@@ MAXIMUM_@@ OC@@ CURR@@ ING_@@ CHARACTER_@@ IN_@@ THE_@@ INPUT_@@ STRING | static char getMax@@ Occur@@ ing@@ Char ( String str ) { int count [ ] = new int [ ASCII@@ _SIZE ] ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) count [ str . charAt ( i ) ] ++ ; int max = - 1 ; char result = ' ▁ ' ; for ( int i = 0 ; i < len ; i ++ ) { if ( max < count [ str . charAt ( i ) ] ) { max = count [ str . charAt ( i ) ] ; result = str . charAt ( i ) ; } } return result ; }
COUNT_@@ NUMBER_@@ PAIR@@ S_@@ N_@@ B_@@ N_@@ GC@@ D_@@ B_@@ B | static int Count@@ Pairs ( int n ) { int k = n ; int im@@ in = 1 ; int ans = 0 ; while ( im@@ in <= n ) { int imax = n / k ; ans += k * ( imax - im@@ in + 1 ) ; im@@ in = imax + 1 ; k = n / im@@ in ; } return ans ; }
K_@@ TH_@@ DISTIN@@ CT_@@ OR_@@ NON_@@ REPE@@ ATING_@@ ELEMENT_@@ IN_@@ AN_@@ ARRAY_@@ 1 | static int print@@ K@@ Distin@@ ct ( int arr [ ] , int n , int k ) { Map < Integer , Integer > h = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( h . containsKey ( arr [ i ] ) ) h . put ( arr [ i ] , h . get ( arr [ i ] ) + 1 ) ; else h . put ( arr [ i ] , 1 ) ; } if ( h . size ( ) < k ) return - 1 ; int dist@@ _count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( h . get ( arr [ i ] ) == 1 ) dist@@ _count ++ ; if ( dist@@ _count == k ) return arr [ i ] ; } return - 1 ; }
GENERATE_@@ BINARY_@@ PER@@ MU@@ TA@@ TIONS_@@ 1@@ S_@@ 0@@ S_@@ EVER@@ Y_@@ POINT_@@ PER@@ MU@@ TA@@ TIONS | static void generate ( int ones , int zeroes , String str , int len ) { if ( len == str . length ( ) ) { System . out . print ( str + " ▁ " ) ; return ; } generate ( ones + 1 , zeroes , str + "1" , len ) ; if ( ones > zeroes ) { generate ( ones , zeroes + 1 , str + "0" , len ) ; } }
SEARCH_@@ INSERT_@@ AND_@@ DELETE_@@ IN_@@ AN_@@ UN@@ SOR@@ TED_@@ ARRAY | static int findElement ( int arr [ ] , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; }
LC@@ S_@@ LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ SEQU@@ ENCE_@@ THRE@@ E_@@ STRINGS | static int l@@ cs@@ Of@@ 3 ( String X , String Y , String Z , int m , int n , int o ) { int [ ] [ ] [ ] L = new int [ m + 1 ] [ n + 1 ] [ o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 || j == 0 || k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) && X . charAt ( i - 1 ) == Z . charAt ( k - 1 ) ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; }
MAX@@ IM@@ UM@@ _S@@ UM@@ _SUB@@ ARRAY_@@ REMO@@ V@@ ING_@@ ONE_@@ ELEMENT | static int max@@ Sum@@ Sub@@ array@@ Remo@@ ving@@ One@@ E@@ le ( int arr [ ] , int n ) { int fw [ ] = new int [ n ] ; int bw [ ] = new int [ n ] ; int cur_@@ max = arr [ 0 ] , max_@@ so@@ _f@@ ar = arr [ 0 ] ; fw [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { cur_@@ max = Math . max ( arr [ i ] , cur_@@ max + arr [ i ] ) ; max_@@ so@@ _f@@ ar = Math . max ( max_@@ so@@ _f@@ ar , cur_@@ max ) ; fw [ i ] = cur_@@ max ; } cur_@@ max = max_@@ so@@ _f@@ ar = bw [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { cur_@@ max = Math . max ( arr [ i ] , cur_@@ max + arr [ i ] ) ; max_@@ so@@ _f@@ ar = Math . max ( max_@@ so@@ _f@@ ar , cur_@@ max ) ; bw [ i ] = cur_@@ max ; } int f@@ ans = max_@@ so@@ _f@@ ar ; for ( int i = 1 ; i < n - 1 ; i ++ ) f@@ ans = Math . max ( f@@ ans , fw [ i - 1 ] + bw [ i + 1 ] ) ; return f@@ ans ; }
COUNT_@@ NUMBER_@@ WAY@@ S_@@ TILE_@@ FLO@@ OR@@ _SIZE_@@ N_@@ X_@@ M_@@ USING_@@ 1_@@ X_@@ M@@ _SIZE_@@ TI@@ LES | static int count@@ W@@ ays ( int n , int m ) { int count [ ] = new int [ n + 1 ] ; count [ 0 ] = 0 ; int i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }
MIDD@@ LE_@@ OF_@@ THRE@@ E_@@ USING_@@ MINIMUM_@@ COMP@@ ARIS@@ ONS | public static int middle@@ Of@@ Three ( int a , int b , int c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; }
LON@@ GE@@ ST_@@ COMMON_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQU@@ ENCE_@@ LC@@ S_@@ LI@@ S | static int LC@@ IS ( int ar@@ r1 [ ] , int n , int ar@@ r2 [ ] , int m ) { int table [ ] = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( ar@@ r1 [ i ] == ar@@ r2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( ar@@ r1 [ i ] > ar@@ r2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }
MAX@@ IM@@ UM@@ _SUB@@ SEQU@@ ENCE_@@ SUM@@ _SU@@ CH_@@ TH@@ AT_@@ NO_@@ THRE@@ E_@@ ARE_@@ CON@@ SEC@@ UTI@@ VE | static int max@@ Sum@@ WO@@ 3@@ Con@@ sec ( int arr [ ] , int n ) { int sum [ ] = new int [ n ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = Math . max ( Math . max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }
E@@ UL@@ ERI@@ AN_@@ NUMBER_@@ 1 | public static int e@@ ul@@ eri@@ an ( int n , int m ) { int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }
DOUBLE_@@ FAC@@ TOR@@ I@@ AL | static long double@@ factorial ( long n ) { if ( n == 0 || n == 1 ) return 1 ; return n * double@@ factorial ( n - 2 ) ; }
RE@@ AR@@ RANGE_@@ POSITIVE_@@ AND_@@ NEGATIVE_@@ NUMB@@ ERS_@@ PUBLI@@ SH | static void re@@ arrange ( int arr [ ] , int n ) { int i = - 1 , temp = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < 0 ) { i ++ ; temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } int pos = i + 1 , neg = 0 ; while ( pos < n && neg < pos && arr [ neg ] < 0 ) { temp = arr [ neg ] ; arr [ neg ] = arr [ pos ] ; arr [ pos ] = temp ; pos ++ ; neg += 2 ; } }
MAXI@@ MI@@ ZE_@@ ARRA@@ Y_S@@ UN_@@ AFTER_@@ K_@@ NEG@@ ATION_@@ OPER@@ ATIONS | static int maximum@@ Sum ( int arr [ ] , int n , int k ) { for ( int i = 1 ; i <= k ; i ++ ) { int min = + 2147483647 ; int index = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
MAX@@ IM@@ UM@@ _S@@ UM_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQU@@ ENCE_@@ FROM_@@ A_@@ PREFIX_@@ AND_@@ A_@@ GI@@ V@@ EN_@@ ELEMENT_@@ AFTER_@@ PREFIX_@@ IS_@@ MUST | static int pre_@@ compute ( int a [ ] , int n , int index , int k ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ; else dp [ 0 ] [ i ] = a [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) { if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } return dp [ index ] [ k ] ; }
FUNCTION_@@ COPY_@@ STRING_@@ ITER@@ ATI@@ VE_@@ RECUR@@ SIVE | static void my@@ Copy ( char s1 [ ] , char s2 [ ] ) { int i = 0 ; for ( i = 0 ; i < s1 . length ; i ++ ) s2 [ i ] = s1 [ i ] ; }
GI@@ V@@ EN_@@ TWO_@@ STRING@@ S_@@ FIND_@@ FIRST_@@ STRING@@ _SUB@@ SEQU@@ ENCE_@@ SECON@@ D_@@ 1 | static boolean isSub@@ Sequence ( String str1 , String str2 , int m , int n ) { int j = 0 ; for ( int i = 0 ; i < n && j < m ; i ++ ) if ( str1 . charAt ( j ) == str2 . charAt ( i ) ) j ++ ; return ( j == m ) ; }
FIND_@@ UNIT_@@ DIG@@ IT_@@ X_@@ RAI@@ SED_@@ POWER_@@ Y_@@ 1 | static int unit@@ number ( int x , int y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( ( int ) ( Math . pow ( x , y ) ) ) % 10 ) ; }
PROGRAM_@@ NEXT_@@ FI@@ T_@@ ALGORITH@@ M_@@ MEMORY_@@ MAN@@ A@@ GEMENT | static void Next@@ Fit ( int blockSize [ ] , int m , int process@@ Size [ ] , int n ) { int allocation [ ] = new int [ n ] , j = 0 ; Arrays . fill ( allocation , - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( blockSize [ j ] >= process@@ Size [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= process@@ Size [ i ] ; break ; } j = ( j + 1 ) % m ; } } System . out . print ( " \n Process ▁ No . \t@@ Process ▁ Size@@ \t@@ Block ▁ no . \n " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( i + 1 + " \t\t " + process@@ Size [ i ] + " \t\t " ) ; if ( allocation [ i ] != - 1 ) { System . out . print ( allocation [ i ] + 1 ) ; } else { System . out . print ( " Not ▁ Allocated " ) ; } System . out . println ( " " ) ; } }
NO@@ BLE_@@ INTEG@@ ERS_@@ IN_@@ AN_@@ ARRAY_@@ COUNT_@@ OF_@@ GREATER_@@ ELEMEN@@ TS_@@ IS_@@ EQUAL_@@ TO_@@ VALUE | public static int no@@ ble@@ Integer ( int arr [ ] ) { int size = arr . length ; for ( int i = 0 ; i < size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ; if ( count == arr [ i ] ) return arr [ i ] ; } return - 1 ; }
MINIMUM_@@ FLI@@ P_@@ REQUIRED_@@ MAKE_@@ BINARY_@@ MATRIX_@@ SYM@@ METRIC | static int minimum@@ flip ( int mat [ ] [ ] , int n ) { int transpose [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ] ; int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++ ; return flip / 2 ; }
SEG@@ REG@@ ATE_@@ EV@@ EN_@@ OD@@ D_@@ NUMBER@@ S@@ _SET_@@ 3 | static void array@@ Even@@ And@@ Odd ( int arr [ ] , int n ) { int i = - 1 , j = 0 ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } for ( int k = 0 ; k < n ; k ++ ) System . out . print ( arr [ k ] + " ▁ " ) ; }
DFS_@@ N_@@ ARY_@@ TREE_@@ AC@@ Y@@ CLI@@ C_@@ GRAPH_@@ RE@@ PRESEN@@ TED_@@ AD@@ J@@ AC@@ ENCY_@@ LIST | public static void dfs ( LinkedList < Integer > list [ ] , int node , int arri@@ val ) { System . out . println ( node ) ; for ( int i = 0 ; i < list [ node ] . size ( ) ; i ++ ) { if ( list [ node ] . get ( i ) != arri@@ val ) dfs ( list , list [ node ] . get ( i ) , node ) ; } }
HO@@ W_@@ TO_@@ TURN_@@ OFF_@@ A_@@ PARTIC@@ ULAR_@@ BIT_@@ IN_@@ A_@@ NUMBER | static int turn@@ Off@@ K ( int n , int k ) { if ( k <= 0 ) return n ; return ( n & ~ ( 1 << ( k - 1 ) ) ) ; }
NUMBER@@ _SUB@@ STRING@@ S_@@ DI@@ VISI@@ BLE_@@ 8_@@ NOT_@@ 3 | static int count ( String s , int len ) { int MAX = 1000 ; int cur = 0 , dig = 0 ; int [ ] sum = new int [ MAX ] ; int [ ] [ ] dp = new int [ MAX ] [ 3 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= len ; i ++ ) { dig = ( int ) ( s . charAt ( i - 1 ) ) - 48 ; cur += dig ; cur %= 3 ; sum [ i ] = cur ; dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] ; dp [ i ] [ sum [ i ] ] ++ ; } int ans = 0 , d@@ prev = 0 , value = 0 , d@@ pre@@ v2 = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { dig = ( int ) ( s . charAt ( i - 1 ) ) - 48 ; if ( dig == 8 ) ans ++ ; if ( i - 2 >= 0 ) { d@@ prev = ( int ) ( s . charAt ( i - 2 ) ) - 48 ; value = d@@ prev * 10 + dig ; if ( ( value % 8 == 0 ) && ( value % 3 != 0 ) ) ans ++ ; } if ( i - 3 >= 0 ) { d@@ pre@@ v2 = ( int ) ( s . charAt ( i - 3 ) ) - 48 ; d@@ prev = ( int ) ( s . charAt ( i - 2 ) ) - 48 ; value = d@@ pre@@ v2 * 100 + d@@ prev * 10 + dig ; if ( value % 8 != 0 ) continue ; ans += ( i - 2 ) ; ans -= ( dp [ i - 3 ] [ sum [ i ] ] ) ; } } return ans ; }
ADD_@@ 1_@@ TO_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ 1 | static int add@@ One ( int x ) { return ( - ( ~ x ) ) ; }
CHECK_@@ STRING_@@ FOL@@ LO@@ WS_@@ AN@@ BN_@@ PATTERN_@@ NOT | public static boolean is@@ An@@ B@@ n ( String s ) { int l = s . length ( ) ; if ( l % 2 == 1 ) { return false ; } int i = 0 ; int j = l - 1 ; while ( i < j ) { if ( s . charAt ( i ) != ' a ' || s . charAt ( j ) != ' b ' ) { return false ; } i ++ ; j -- ; } return true ; }
FIND_@@ FIRST_@@ REPE@@ ATING_@@ ELEMENT_@@ ARRAY_@@ INTEG@@ ERS | static void print@@ First@@ Repe@@ ating ( int arr [ ] ) { int min = - 1 ; HashSet < Integer > set = new HashSet < > ( ) ; for ( int i = arr . length - 1 ; i >= 0 ; i -- ) { if ( set . contains ( arr [ i ] ) ) min = i ; else set . add ( arr [ i ] ) ; } if ( min != - 1 ) System . out . println ( " The ▁ first ▁ repe@@ ating ▁ element ▁ is ▁ " + arr [ min ] ) ; else System . out . println ( " There ▁ are ▁ no ▁ repe@@ ating ▁ elements " ) ; }
CO@@ ST_@@ BAL@@ ANCE_@@ PAR@@ AN@@ THE@@ SES | static int cost@@ To@@ Balance ( String s ) { if ( s . length ( ) == 0 ) System . out . println ( 0 ) ; int ans = 0 ; int o = 0 , c = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) o ++ ; if ( s . charAt ( i ) == ' ) ' ) c ++ ; } if ( o != c ) return - 1 ; int [ ] a = new int [ s . length ( ) ] ; if ( s . charAt ( 0 ) == ' ( ' ) a [ 0 ] = 1 ; else a [ 0 ] = - 1 ; if ( a [ 0 ] < 0 ) ans += Math . abs ( a [ 0 ] ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) a [ i ] = a [ i - 1 ] + 1 ; else a [ i ] = a [ i - 1 ] - 1 ; if ( a [ i ] < 0 ) ans += Math . abs ( a [ i ] ) ; } return ans ; }
CO@@ IN_@@ GAME_@@ WIN@@ NER_@@ EVER@@ Y_@@ PLAYER_@@ THRE@@ E_@@ CHOICES | static boolean find@@ Win@@ ner ( int x , int y , int n ) { boolean [ ] dp = new boolean [ n + 1 ] ; Arrays . fill ( dp , false ) ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 && dp [ i - 1 ] == false ) dp [ i ] = true ; else if ( i - x >= 0 && dp [ i - x ] == false ) dp [ i ] = true ; else if ( i - y >= 0 && dp [ i - y ] == false ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; }
SEQU@@ EN@@ CES_@@ GI@@ V@@ EN_@@ LENGTH_@@ EVER@@ Y_@@ ELEMENT_@@ EQUAL_@@ TWI@@ CE_@@ PREVI@@ OUS | static int getTotal@@ NumberOf@@ Sequences ( int m , int n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotal@@ NumberOf@@ Sequences ( m - 1 , n ) + getTotal@@ NumberOf@@ Sequences ( m / 2 , n - 1 ) ; }
FIND_@@ DUPLIC@@ ATE@@ S_@@ GI@@ V@@ EN_@@ ARRAY_@@ ELEMEN@@ TS_@@ NOT_@@ LIMITED_@@ RANGE | private static void print@@ Duplicates ( int [ ] arr , int n ) { Map < Integer , Integer > map = new HashMap < > ( ) ; int count = 0 ; boolean dup = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . containsKey ( arr [ i ] ) ) { count = map . get ( arr [ i ] ) ; map . put ( arr [ i ] , count + 1 ) ; } else { map . put ( arr [ i ] , 1 ) ; } } for ( Entry < Integer , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) > 1 ) { System . out . print ( entry . getKey ( ) + " ▁ " ) ; dup = true ; } } if ( ! dup ) { System . out . println ( " - 1" ) ; } }
LON@@ GE@@ ST_@@ REPE@@ AT@@ ING@@ _SUB@@ SEQU@@ ENCE_@@ 1 | static int find@@ Lon@@ gest@@ Repe@@ ating@@ Sub@@ Seq ( char X [ ] , int m , int n ) { if ( dp [ m ] [ n ] != - 1 ) { return dp [ m ] [ n ] ; } if ( m == 0 || n == 0 ) { return dp [ m ] [ n ] = 0 ; } if ( X [ m - 1 ] == X [ n - 1 ] && m != n ) { return dp [ m ] [ n ] = find@@ Lon@@ gest@@ Repe@@ ating@@ Sub@@ Seq ( X , m - 1 , n - 1 ) + 1 ; } return dp [ m ] [ n ] = Math . max ( find@@ Lon@@ gest@@ Repe@@ ating@@ Sub@@ Seq ( X , m , n - 1 ) , find@@ Lon@@ gest@@ Repe@@ ating@@ Sub@@ Seq ( X , m - 1 , n ) ) ; }
COUNT_@@ OF_@@ N_@@ DIG@@ IT_@@ NUMB@@ ERS_@@ WHO@@ SE_@@ S@@ UM_@@ OF_@@ DIG@@ IT@@ S_@@ EQUAL@@ S_TO_@@ GI@@ VEN@@ _S@@ UM | private static void find@@ Count ( int n , int sum ) { int start = ( int ) Math . pow ( 10 , n - 1 ) ; int end = ( int ) Math . pow ( 10 , n ) - 1 ; int count = 0 ; int i = start ; while ( i < end ) { int cur = 0 ; int temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = temp / 10 ; } if ( cur == sum ) { count ++ ; i += 9 ; } else i ++ ; } System . out . println ( count ) ; }
MINIMUM_@@ CO@@ ST_@@ CONNECT_@@ WE@@ I@@ GH@@ TED_@@ NODE@@ S_@@ RE@@ PRESEN@@ TED_@@ ARRAY | static int minimum_@@ cost ( int a [ ] , int n ) { int mn = Integer . MAX_VALUE ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mn = Math . min ( a [ i ] , mn ) ; sum += a [ i ] ; } return mn * ( sum - mn ) ; }
FIND_@@ ALL_@@ DI@@ VI@@ SOR@@ S_@@ OF_@@ A_@@ N@@ ATUR@@ AL_@@ NUMBER@@ _SET_@@ 2 | static void print@@ Di@@ visors ( int n ) { Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) System . out . printf ( " % d ▁ " , i ) ; else { System . out . printf ( " % d ▁ " , i ) ; v . add ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) System . out . printf ( " % d ▁ " , v . get ( i ) ) ; }
SQU@@ AR@@ ES_@@ OF_@@ MATRIX_@@ DIAG@@ ON@@ AL_@@ ELEMEN@@ TS_@@ 1 | static void diag@@ onal@@ square ( int mat [ ] [ ] , int row , int column ) { System . out . print ( " ▁ Diagonal ▁ one ▁ : ▁ " ) ; for ( int i = 0 ; i < row ; i ++ ) { System . out . print ( mat [ i ] [ i ] * mat [ i ] [ i ] + " ▁ " ) ; } System . out . println ( ) ; System . out . print ( " ▁ Diagonal ▁ two ▁ : ▁ " ) ; for ( int i = 0 ; i < row ; i ++ ) { System . out . print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] + " ▁ " ) ; } }
C_@@ PROGRAM_@@ FIND_@@ AREA_@@ TRIANGLE_@@ 1 | static double polygon@@ Area ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; }
RANGE_@@ QUER@@ I@@ ES_@@ FOR_@@ FREQU@@ ENCI@@ ES_@@ OF_@@ ARRAY_@@ ELEMENTS | public static int find@@ Frequency ( int arr [ ] , int n , int left , int right , int element ) { int count = 0 ; for ( int i = left - 1 ; i < right ; ++ i ) if ( arr [ i ] == element ) ++ count ; return count ; }
SERI@@ ES_@@ LAR@@ GE@@ ST_@@ G@@ CD@@ _S@@ UM_@@ EQUAL@@ S_@@ N | static void print_@@ sequence ( int n , int k ) { int b = n / ( k * ( k + 1 ) / 2 ) ; if ( b == 0 ) { System . out . println ( " - 1" ) ; } else { int r = 1 ; for ( int x = 1 ; x * x <= n ; x ++ ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; if ( n / x <= b && n / x > r ) r = n / x ; } for ( int i = 1 ; i < k ; i ++ ) System . out . print ( r * i + " ▁ " ) ; int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ; System . out . println ( res ) ; } }
FIND_@@ THRE@@ E_@@ ELEMENT_@@ FROM_@@ DIFF@@ ER@@ ENT_@@ THRE@@ E_@@ ARRAY@@ S@@ _SU@@ CH_@@ TH@@ AT_@@ TH@@ AT_@@ A_@@ B_@@ C_@@ K_@@ 1 | static boolean find@@ Trip@@ let ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n1 ; i ++ ) { s . add ( a1 [ i ] ) ; } ArrayList < Integer > al = new ArrayList < > ( s ) ; for ( int i = 0 ; i < n2 ; i ++ ) { for ( int j = 0 ; j < n3 ; j ++ ) { if ( al . contains ( sum - a2 [ i ] - a3 [ j ] ) & al . indexOf ( sum - a2 [ i ] - a3 [ j ] ) != al . get ( al . size ( ) - 1 ) ) { return true ; } } } return false ; }
FIND_@@ THE_@@ MAXIMUM_@@ ELEMENT_@@ IN_@@ AN_@@ ARRAY_@@ WHI@@ CH_@@ IS_@@ FIRST_@@ INCRE@@ AS@@ ING_@@ AND_@@ TH@@ EN_@@ DECRE@@ AS@@ ING_@@ 1 | static int find@@ Maximum ( int arr [ ] , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return find@@ Maximum ( arr , low , mid - 1 ) ; else return find@@ Maximum ( arr , mid + 1 , high ) ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 1 | int fi@@ b ( int n ) { if ( lookup [ n ] == NIL ) { if ( n <= 1 ) lookup [ n ] = n ; else lookup [ n ] = fi@@ b ( n - 1 ) + fi@@ b ( n - 2 ) ; } return lookup [ n ] ; }
MODUL@@ AR_@@ EXPO@@ NE@@ N@@ TI@@ ATION_@@ POWER_@@ IN_@@ MODUL@@ AR_@@ ARI@@ TH@@ ME@@ TIC | static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y > > 1 ; x = ( x * x ) % p ; } return res ; }
WRITE_@@ ONE_@@ LINE_@@ C_@@ FUNCTION_@@ TO_@@ FIND_@@ WHE@@ THER_@@ A_@@ NO_@@ IS_@@ POWER_@@ OF_@@ TWO_@@ 1 | static boolean is@@ PowerOf@@ Two ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ SEQU@@ ENCE_@@ WITH_@@ PER@@ MU@@ TA@@ TIONS_@@ ALLOWED | static void lon@@ gest@@ String ( String str1 , String str2 ) { int count@@ 1 [ ] = new int [ 26 ] , count2 [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { count@@ 1 [ str1 . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { count2 [ str2 . charAt ( i ) - ' a ' ] ++ ; } String result = " " ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 1 ; j <= Math . min ( count@@ 1 [ i ] , count2 [ i ] ) ; j ++ ) { result += ( char ) ( ' a ' + i ) ; } } System . out . println ( result ) ; }
DIFF@@ ER@@ ENCE_@@ MAX@@ IM@@ UM@@ _S@@ UM_@@ MIN@@ IM@@ UM@@ _S@@ UM_@@ N_@@ M_@@ ELEMEN@@ TS@@ IN_@@ RE@@ VIEW | static int find_@@ difference ( int arr [ ] , int n , int m ) { int max = 0 , min = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 , j = n - 1 ; i < m ; i ++ , j -- ) { min += arr [ i ] ; max += arr [ j ] ; } return ( max - min ) ; }
PRINT_@@ NUMBER_@@ ASC@@ END@@ ING_@@ ORDER_@@ CONTAIN@@ S_@@ 1_2_@@ 3_@@ DIGITS | private static String print@@ Numbers ( int [ ] numbers ) { ArrayList < Integer > array = new ArrayList < > ( ) ; for ( int number : numbers ) { if ( find@@ Contains@@ One@@ Two@@ Three ( number ) ) array . add ( number ) ; } Collections . sort ( array ) ; StringBuffer str@@ buf = new StringBuffer ( ) ; Iterator it = array . iterator ( ) ; while ( it . hasNext ( ) ) { int value = ( int ) it . next ( ) ; if ( str@@ buf . length ( ) > 0 ) str@@ buf . append ( " , ▁ " ) ; str@@ buf . append ( Integer . toString ( value ) ) ; } return ( str@@ buf . length ( ) > 0 ) ? str@@ buf . toString ( ) : " - 1" ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 3_@@ LON@@ GE@@ ST_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQUENCE | static int lis ( int arr [ ] , int n ) { max_@@ ref = 1 ; _@@ lis ( arr , n ) ; return max_@@ ref ; }
MINIMUM_@@ RE@@ VO@@ LU@@ TIONS_@@ MOVE_@@ CENTER_@@ CI@@ R@@ CLE_@@ TARGET | static double min@@ Re@@ volu@@ tions ( double r , int x1 , int y1 , int x2 , int y2 ) { double d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . ceil ( d / ( 2 * r ) ) ; }
CHECK_@@ TWO_@@ GI@@ VEN@@ _SE@@ TS_@@ DIS@@ JOINT | boolean are@@ disjoint ( int set1 [ ] , int set2 [ ] ) { for ( int i = 0 ; i < set1 . length ; i ++ ) { for ( int j = 0 ; j < set2 . length ; j ++ ) { if ( set1 [ i ] == set2 [ j ] ) return false ; } } return true ; }
FIND_@@ MIN@@ IM@@ UM@@ _S@@ UM_@@ FAC@@ TOR@@ S_@@ NUMBER | static int find@@ Min@@ Sum ( int num ) { int sum = 0 ; for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
FREQU@@ ENT_@@ ELEMENT_@@ ARRAY | static int most@@ Frequ@@ ent ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int max_@@ count = 1 , res = arr [ 0 ] ; int curr_@@ count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_@@ count ++ ; else { if ( curr_@@ count > max_@@ count ) { max_@@ count = curr_@@ count ; res = arr [ i - 1 ] ; } curr_@@ count = 1 ; } } if ( curr_@@ count > max_@@ count ) { max_@@ count = curr_@@ count ; res = arr [ n - 1 ] ; } return res ; }
MINIMUM_@@ X@@ OR_@@ VALUE_@@ PA@@ IR_@@ 1 | static int min@@ XOR ( int arr [ ] , int n ) { Arrays . parallel@@ Sort ( arr ) ; int min@@ Xor = Integer . MAX_VALUE ; int val = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; min@@ Xor = Math . min ( min@@ Xor , val ) ; } return min@@ Xor ; }
MIN@@ IM@@ UM@@ _S@@ UM_@@ PRODUCT_@@ TWO_@@ ARRAY@@ S | static int min@@ product ( int a [ ] , int b [ ] , int n , int k ) { int diff = 0 , res = 0 ; int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; int d = Math . abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }
FAST_@@ MULTIP@@ LIC@@ ATION_@@ METHOD_@@ WITH@@ OUT_@@ USING_@@ MULTIP@@ LIC@@ ATION_@@ OPERATOR_@@ R@@ US@@ SI@@ AN_@@ PE@@ AS@@ AN@@ TS_@@ ALGORITH@@ M | static int rus@@ sian@@ Pe@@ as@@ ant ( int a , int b ) { int res = 0 ; while ( b > 0 ) { if ( ( b & 1 ) != 0 ) res = res + a ; a = a << 1 ; b = b > > 1 ; } return res ; }
DI@@ VISIBILITY_@@ 9_@@ USING_@@ BIT@@ WI@@ SE_@@ OPER@@ ATORS | static boolean is@@ Div@@ By@@ 9 ( int n ) { if ( n == 0 || n == 9 ) return true ; if ( n < 9 ) return false ; return is@@ Div@@ By@@ 9 ( ( int ) ( n > > 3 ) - ( int ) ( n & 7 ) ) ; }
CHECK_@@ ARRAY_@@ RE@@ PRESEN@@ TS_@@ IN@@ ORDER_@@ BIN@@ AR@@ Y@@ _SEARCH_@@ TREE_@@ NOT | static boolean isIn@@ order ( int [ ] arr , int n ) { if ( n == 0 || n == 1 ) { return true ; } for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] > arr [ i ] ) { return false ; } } return true ; }
GI@@ V@@ EN_@@ TWO_@@ UN@@ SOR@@ TED_@@ ARRAY@@ S_@@ FIND_@@ PAIR@@ S_@@ WHO@@ SE_@@ S@@ UM_@@ X | static void find@@ Pairs ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int n , int m , int x ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( ar@@ r1 [ i ] + ar@@ r2 [ j ] == x ) System . out . println ( ar@@ r1 [ i ] + " ▁ " + ar@@ r2 [ j ] ) ; }
BINARY_@@ RE@@ PRESEN@@ TATION_@@ OF_@@ NEXT_@@ NUMBER | static String next@@ Greater ( String num ) { int l = num . length ( ) ; int i ; for ( i = l - 1 ; i >= 0 ; i -- ) { if ( num . charAt ( i ) == '0' ) { num = num . substring ( 0 , i ) + '1' + num . substring ( i + 1 ) ; break ; } else { num = num . substring ( 0 , i ) + '0' + num . substring ( i + 1 ) ; } } if ( i < 0 ) { num = "1" + num ; } return num ; }
LAR@@ GE@@ ST@@ _SUB@@ ARRAY_@@ WITH_@@ EQUAL_@@ NUMBER_OF_@@ 0@@ S_@@ AND_@@ 1@@ S | int find@@ Sub@@ Array ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = - 1 , start@@ index = 0 ; int end@@ index = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; start@@ index = i ; } } } end@@ index = start@@ index + maxsize - 1 ; if ( maxsize == - 1 ) System . out . println ( " No ▁ such ▁ sub@@ array " ) ; else System . out . println ( start@@ index + " ▁ to ▁ " + end@@ index ) ; return maxsize ; }
COUNT_@@ PAIR@@ S_@@ WHO@@ SE_@@ PRODUC@@ TS_@@ EXI@@ ST_@@ IN_@@ ARRAY_@@ 1 | static int count@@ Pairs ( int arr [ ] , int n ) { int result = 0 ; HashSet < Integer > Hash = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Hash . add ( arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; if ( Hash . contains ( product ) ) { result ++ ; } } } return result ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 12_@@ LON@@ GE@@ ST_@@ PA@@ LIN@@ DRO@@ MI@@ C@@ _SUB@@ SEQUENCE | static int l@@ ps ( String seq ) { int n = seq . length ( ) ; int i , j , cl ; int L [ ] [ ] = new int [ n ] [ n ] ; for ( i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( cl = 2 ; cl <= n ; cl ++ ) { for ( i = 0 ; i < n - cl + 1 ; i ++ ) { j = i + cl - 1 ; if ( seq . charAt ( i ) == seq . charAt ( j ) && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( seq . charAt ( i ) == seq . charAt ( j ) ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; }
COUNT_@@ IN@@ VERSION@@ S_@@ OF@@ _SIZE_@@ THRE@@ E_@@ IN_@@ A_@@ GI@@ VE_@@ ARRAY_@@ 1 | int getIn@@ v@@ Count ( int arr [ ] , int n ) { int inv@@ count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; inv@@ count += great * small ; } return inv@@ count ; }
DECIMAL_@@ RE@@ PRESEN@@ TATION_@@ GI@@ V@@ EN_@@ BINARY_@@ STRING_@@ DI@@ VISI@@ BLE_@@ 10_@@ NOT | static boolean is@@ Di@@ visible@@ By@@ 10 ( String bin ) { int n = bin . length ( ) ; if ( bin . charAt ( n - 1 ) == '1' ) return false ; int sum = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( bin . charAt ( i ) == '1' ) { int pos@@ From@@ Right = n - i - 1 ; if ( pos@@ From@@ Right % 4 == 1 ) sum = sum + 2 ; else if ( pos@@ From@@ Right % 4 == 2 ) sum = sum + 4 ; else if ( pos@@ From@@ Right % 4 == 3 ) sum = sum + 8 ; else if ( pos@@ From@@ Right % 4 == 0 ) sum = sum + 6 ; } } if ( sum % 10 == 0 ) return true ; return false ; }
FIND_@@ WHE@@ THER_@@ AN_@@ ARRAY_@@ IS@@ _SUB@@ SET_@@ OF_@@ AN@@ OTHER_@@ ARRAY@@ _SET_@@ 1_1 | static boolean is@@ Subset ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int m , int n ) { int i = 0 , j = 0 ; if ( m < n ) return false ; Arrays . sort ( ar@@ r1 ) ; Arrays . sort ( ar@@ r2 ) ; while ( i < n && j < m ) { if ( ar@@ r1 [ j ] < ar@@ r2 [ i ] ) j ++ ; else if ( ar@@ r1 [ j ] == ar@@ r2 [ i ] ) { j ++ ; i ++ ; } else if ( ar@@ r1 [ j ] > ar@@ r2 [ i ] ) return false ; } if ( i < n ) return false ; else return true ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SUB@@ SET_@@ S@@ UM_@@ PRO@@ BLE@@ M_@@ 1 | static boolean isSub@@ set@@ Sum ( int set [ ] , int n , int sum ) { boolean subset [ ] [ ] = new boolean [ sum + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ i ] [ 0 ] = false ; for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; } } return subset [ sum ] [ n ] ; }
S@@ UM_@@ K_@@ TH_@@ GROUP_@@ OD@@ D_@@ POSITIVE_@@ NUMB@@ ERS_@@ 1 | public static int k@@ th@@ group@@ sum ( int k ) { return k * k * k ; }
THIR@@ D_@@ LAR@@ GE@@ ST_@@ ELEMENT_@@ ARRAY_@@ DISTIN@@ CT_@@ ELEMENTS | static void third@@ Lar@@ gest ( int arr [ ] , int arr_@@ size ) { if ( arr_@@ size < 3 ) { System . out . printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_@@ size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; int second = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr_@@ size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; int third = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr_@@ size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; System . out . printf ( " The ▁ third ▁ Lar@@ gest ▁ " + " element ▁ is ▁ % d \n " , third ) ; }
FIN@@ D_S@@ UM_@@ NODE@@ S_@@ GI@@ V@@ EN_@@ PER@@ F@@ ECT_@@ BINARY_@@ TREE_@@ 1 | static double sum@@ Nodes ( int l ) { double leaf@@ Node@@ Count = Math . pow ( 2 , l - 1 ) ; double sum@@ Last@@ Level = 0 ; sum@@ Last@@ Level = ( leaf@@ Node@@ Count * ( leaf@@ Node@@ Count + 1 ) ) / 2 ; double sum = sum@@ Last@@ Level * l ; return sum ; }
MIDD@@ LE_@@ OF_@@ THRE@@ E_@@ USING_@@ MINIMUM_@@ COMP@@ ARIS@@ ONS_@@ 2 | public static int middle@@ Of@@ Three ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return c ; else return a ; }
MAXIMUM_@@ TR@@ IP@@ LET_@@ S@@ UM_@@ ARRAY_@@ 2 | static int max@@ Trip@@ let@@ Sum ( int arr [ ] , int n ) { int max@@ A = - 1@@ 00000000 , max@@ B = - 1@@ 00000000 ; int max@@ C = - 1@@ 00000000 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max@@ A ) { max@@ C = max@@ B ; max@@ B = max@@ A ; max@@ A = arr [ i ] ; } else if ( arr [ i ] > max@@ B ) { max@@ C = max@@ B ; max@@ B = arr [ i ] ; } else if ( arr [ i ] > max@@ C ) max@@ C = arr [ i ] ; } return ( max@@ A + max@@ B + max@@ C ) ; }
COUNT_@@ PAIR@@ S_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL_@@ GI@@ V@@ EN_@@ VALUE_@@ X_@@ 1 | static int count@@ Pairs ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int m , int n , int x ) { int count = 0 ; HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) us . add ( ar@@ r1 [ i ] ) ; for ( int j = 0 ; j < n ; j ++ ) if ( us . contains ( x - ar@@ r2 [ j ] ) ) count ++ ; return count ; }
MINIMUM_@@ STE@@ PS_@@ REACH_@@ END_@@ ARRAY_@@ CONSTRA@@ INTS | static int getMin@@ Step@@ To@@ Reach@@ End ( int arr [ ] , int N ) { boolean [ ] visit = new boolean [ N ] ; int [ ] distance = new int [ N ] ; Vector < Integer > [ ] digit = new Vector [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) digit [ i ] = new Vector < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) visit [ i ] = false ; for ( int i = 1 ; i < N ; i ++ ) digit [ arr [ i ] ] . add ( i ) ; distance [ 0 ] = 0 ; visit [ 0 ] = true ; Queue < Integer > q = new LinkedList < > ( ) ; q . add ( 0 ) ; while ( ! q . isEmpty ( ) ) { int idx = q . peek ( ) ; q . remove ( ) ; if ( idx == N - 1 ) break ; int d = arr [ idx ] ; for ( int i = 0 ; i < digit [ d ] . size ( ) ; i ++ ) { int nex@@ ti@@ dx = digit [ d ] . get ( i ) ; if ( ! visit [ nex@@ ti@@ dx ] ) { visit [ nex@@ ti@@ dx ] = true ; q . add ( nex@@ ti@@ dx ) ; distance [ nex@@ ti@@ dx ] = distance [ idx ] + 1 ; } } digit [ d ] . clear ( ) ; if ( idx - 1 >= 0 && ! visit [ idx - 1 ] ) { visit [ idx - 1 ] = true ; q . add ( idx - 1 ) ; distance [ idx - 1 ] = distance [ idx ] + 1 ; } if ( idx + 1 < N && ! visit [ idx + 1 ] ) { visit [ idx + 1 ] = true ; q . add ( idx + 1 ) ; distance [ idx + 1 ] = distance [ idx ] + 1 ; } } return distance [ N - 1 ] ; }
LE@@ XI@@ CO@@ GRAPHIC@@ AL@@ LY@@ _S@@ MAL@@ LE@@ ST_@@ ARRAY_@@ K_@@ CON@@ SEC@@ UTI@@ VE_@@ SWAP@@ S | static void minim@@ ize@@ With@@ K@@ Sw@@ aps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } int temp ; for ( int j = pos ; j > i ; -- j ) { temp = arr [ j ] ; arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = temp ; } k -= pos - i ; } }
CONVERT_@@ SEN@@ T@@ ENCE_@@ EQU@@ I@@ VAL@@ ENT_@@ MOBI@@ LE_@@ NUMERIC_@@ KEY@@ PAD@@ _SEQU@@ ENCE | static String print@@ Sequence ( String arr [ ] , String input ) { String output = " " ; int n = input . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( input . charAt ( i ) == ' ▁ ' ) output = output + "0" ; else { int position = input . charAt ( i ) - ' A ' ; output = output + arr [ position ] ; } } return output ; }
PROGRAM_@@ CHECK_@@ ARRA@@ Y_S@@ OR@@ TED_@@ NOT_@@ ITER@@ ATI@@ VE_@@ RECUR@@ SIVE | static int array@@ Sorted@@ Or@@ Not ( int arr [ ] , int n ) { if ( n == 1 || n == 0 ) return 1 ; if ( arr [ n - 1 ] < arr [ n - 2 ] ) return 0 ; return array@@ Sorted@@ Or@@ Not ( arr , n - 1 ) ; }
CHECK_@@ TWO_@@ GI@@ V@@ EN_@@ CIRC@@ LES_@@ TOUCH_@@ INTER@@ S@@ ECT | static int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int dist@@ Sq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int rad@@ Sum@@ Sq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( dist@@ Sq == rad@@ Sum@@ Sq ) return 1 ; else if ( dist@@ Sq > rad@@ Sum@@ Sq ) return - 1 ; else return 0 ; }
SM@@ ALLE@@ ST_@@ POWER_@@ OF_@@ 2_@@ GREATER_@@ TH@@ AN_@@ OR_@@ EQUAL_@@ TO_@@ N_@@ 2 | static int next@@ PowerOf@@ 2 ( int n ) { n -- ; n |= n > > 1 ; n |= n > > 2 ; n |= n > > 4 ; n |= n > > 8 ; n |= n > > 16 ; n ++ ; return n ; }
PAD@@ OV@@ AN@@ _SEQU@@ ENCE | static int pad ( int n ) { int p@@ Prev@@ Prev = 1 , p@@ Prev = 1 , pCur@@ r = 1 , pNext = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { pNext = p@@ Prev@@ Prev + p@@ Prev ; p@@ Prev@@ Prev = p@@ Prev ; p@@ Prev = pCur@@ r ; pCur@@ r = pNext ; } return pNext ; }
CHECK_@@ GI@@ V@@ EN_@@ STRING_@@ CAN@@ _SP@@ LIT_@@ FOUR_@@ DISTIN@@ CT_@@ STRINGS | public static boolean check ( String s ) { if ( s . length ( ) >= 10 ) return true ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { for ( int k = j + 1 ; k < s . length ( ) ; k ++ ) { String s1 = " " , s2 = " " , s3 = " " , s4 = " " ; try { s1 = s . substring ( 0 , i ) ; s2 = s . substring ( i , j - i ) ; s3 = s . substring ( j , k - j ) ; s4 = s . substring ( k , s . length ( ) - k ) ; } catch ( String@@ IndexOutOfBoundsException e ) { } if ( str@@ check ( s1 , s2 ) && str@@ check ( s1 , s3 ) && str@@ check ( s1 , s4 ) && str@@ check ( s2 , s3 ) && str@@ check ( s2 , s4 ) && str@@ check ( s3 , s4 ) ) return true ; } } } return false ; }
PER@@ M@@ UTE_@@ TWO_@@ ARRAY@@ S_S@@ UM_@@ EVER@@ Y_@@ PA@@ IR_@@ GREATER_@@ EQUAL_@@ K | static boolean is@@ Possible ( Integer a [ ] , int b [ ] , int n , int k ) { Arrays . sort ( a , Collections . reverse@@ Order ( ) ) ; Arrays . sort ( b ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }
ARRAY_@@ ELEMENT_@@ MOVE@@ D_@@ K_@@ US@@ ING@@ _SIN@@ GLE_@@ MOV@@ ES | static int winner ( int a [ ] , int n , int k ) { if ( k >= n - 1 ) return n ; int best = 0 , times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i == 1 ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; }
DIRECTION_@@ LAST@@ _S@@ QU@@ ARE_@@ BLOCK | static void direction ( int R , int C ) { if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) { System . out . println ( " Left " ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) { System . out . println ( " Up " ) ; return ; } if ( R == C && R % 2 != 0 && C % 2 != 0 ) { System . out . println ( " Right " ) ; return ; } if ( R == C && R % 2 == 0 && C % 2 == 0 ) { System . out . println ( " Left " ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { System . out . println ( " Right " ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) { System . out . println ( " Down " ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) { System . out . println ( " Left " ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) { System . out . println ( " Up " ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) { System . out . println ( " Down " ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) { System . out . println ( " Right " ) ; return ; } }
NUMBER_@@ NON_@@ NEGATIVE_@@ INTEGR@@ AL_S@@ OL@@ U@@ TIONS_@@ B_@@ C_@@ N | static int count@@ Integr@@ al@@ Solutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n - i ; j ++ ) for ( int k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }
SW@@ AP_@@ MAJ@@ OR_@@ MIN@@ OR_@@ DIAG@@ ON@@ AL@@ S_S@@ QU@@ ARE_@@ MATRIX | static void swap@@ Diagonal ( int matrix [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { int temp = matrix [ i ] [ i ] ; matrix [ i ] [ i ] = matrix [ i ] [ N - i - 1 ] ; matrix [ i ] [ N - i - 1 ] = temp ; } }
MINIMUM_@@ OPER@@ ATION@@ S_@@ MAKE_@@ GC@@ D_@@ ARRAY_@@ MULTIPLE_@@ K | static int Min@@ Operation ( int a [ ] , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + Math . min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; }
MAXIMUM_@@ DECIMAL_@@ VALUE_@@ PATH_@@ IN_@@ A_@@ BINARY_@@ MATRIX | static int max@@ Decimal@@ Value ( int mat [ ] [ ] , int i , int j , int p ) { if ( i >= N || j >= N ) { return 0 ; } int result = Math . max ( max@@ Decimal@@ Value ( mat , i , j + 1 , p + 1 ) , max@@ Decimal@@ Value ( mat , i + 1 , j , p + 1 ) ) ; if ( mat [ i ] [ j ] == 1 ) { return ( int ) ( Math . pow ( 2 , p ) + result ) ; } else { return result ; } }
SQU@@ ARE_@@ ROOT_@@ OF_@@ A_@@ PER@@ F@@ ECT_@@ SQU@@ ARE_@@ 1 | static long square@@ Root ( int n ) { int x = n ; int y = 1 ; while ( x > y ) { x = ( x + y ) / 2 ; y = n / x ; } return ( long ) x ; }
FIND_@@ MIN@@ IM@@ UM@@ _SH@@ IFT_@@ LON@@ GE@@ ST_@@ COMMON_@@ PREFIX | static void K@@ MP ( int m , int n , String str2 , String str1 ) { int pos = 0 , len = 0 ; int [ ] p = new int [ m + 1 ] ; int k = 0 ; char [ ] ch@@ 1 = str1 . toCharArray ( ) ; char [ ] ch2 = str2 . toCharArray ( ) ; for ( int i = 2 ; i <= n ; i ++ ) { while ( k > 0 && ch@@ 1 [ k ] != ch@@ 1 [ i - 1 ] ) k = p [ k ] ; if ( ch@@ 1 [ k ] == ch@@ 1 [ i - 1 ] ) ++ k ; p [ i ] = k ; } for ( int j = 0 , i = 0 ; i < m ; i ++ ) { while ( j > 0 && j < n && ch@@ 1 [ j ] != ch2 [ i ] ) j = p [ j ] ; if ( j < n && ch@@ 1 [ j ] == ch2 [ i ] ) j ++ ; if ( j > len ) { len = j ; pos = i - j + 1 ; } } System . out . println ( " Shift ▁ = ▁ " + pos ) ; System . out . println ( " Prefix ▁ = ▁ " + str1 . substring ( 0 , len ) ) ; }
SOR@@ TED_@@ ORDER_@@ PRINT@@ ING_@@ OF_@@ AN_@@ ARRAY_@@ TH@@ AT_@@ RE@@ PRESEN@@ TS_@@ A_@@ B@@ ST | private static void print@@ Sorted ( int [ ] arr , int start , int end ) { if ( start > end ) return ; print@@ Sorted ( arr , start * 2 + 1 , end ) ; System . out . print ( arr [ start ] + " ▁ " ) ; print@@ Sorted ( arr , start * 2 + 2 , end ) ; }
CHECK_@@ WHE@@ THER_@@ GI@@ V@@ EN_@@ DEGRE@@ ES_@@ VER@@ TIC@@ ES_@@ RE@@ PRES@@ ENT_@@ GRAPH_@@ TREE | static boolean check ( int degree [ ] , int n ) { int de@@ g_@@ sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { de@@ g_@@ sum += degree [ i ] ; } return ( 2 * ( n - 1 ) == de@@ g_@@ sum ) ; }
MOVE_@@ ZER@@ O@@ ES_@@ END_@@ ARRAY | static void push@@ Zer@@ os@@ To@@ End ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
COUNT_@@ ELEMEN@@ TS_@@ WHI@@ CH_@@ DI@@ VI@@ DE_@@ ALL_@@ NUMB@@ ERS_@@ IN_@@ RANGE_@@ L_@@ R | static int answer@@ Query ( int a [ ] , int n , int l , int r ) { int count = 0 ; l = l - 1 ; for ( int i = l ; i < r ; i ++ ) { int element = a [ i ] ; int di@@ visors = 0 ; for ( int j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) di@@ visors ++ ; else break ; } if ( di@@ visors == ( r - l ) ) count ++ ; } return count ; }
S@@ UM_@@ LAR@@ GE@@ ST_@@ PRI@@ ME_@@ FAC@@ TOR_@@ NUMBER_@@ LESS_@@ EQUAL_@@ N | static int sum@@ Of@@ Large@@ Prime@@ Factor ( int n ) { int prime [ ] = new int [ n + 1 ] , sum = 0 ; Arrays . fill ( prime , 0 ) ; int max = n / 2 ; for ( int p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = p ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] != 0 ) sum += prime [ p ] ; else sum += p ; } return sum ; }
RE@@ AR@@ RANGE_@@ A_@@ STRING_@@ IN@@ _S@@ OR@@ TED_@@ ORDER_@@ FOL@@ LO@@ WED_@@ BY_@@ THE_@@ INTEG@@ ER@@ _S@@ UM | static String arrange@@ String ( String str ) { int char@@ _count [ ] = new int [ MAX_@@ CHAR ] ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( Character . is@@ UpperCase ( str . charAt ( i ) ) ) char@@ _count [ str . charAt ( i ) - ' A ' ] ++ ; else sum = sum + ( str . charAt ( i ) - '0' ) ; } String res = " " ; for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) { char ch = ( char ) ( ' A ' + i ) ; while ( char@@ _count [ i ] -- != 0 ) res = res + ch ; } if ( sum > 0 ) res = res + sum ; return res ; }
COUNT_@@ POSSI@@ BLE_@@ PATH@@ S_@@ TOP_@@ LEFT_@@ BOTTOM_@@ RIGHT_@@ NX@@ M_@@ MATRIX_@@ 1 | static int numberOf@@ Paths ( int m , int n ) { int count [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ; } return count [ m - 1 ] [ n - 1 ] ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 5_@@ EDIT_@@ DISTAN@@ CE_@@ 1 | static int edit@@ Dist@@ DP ( String str1 , String str2 , int m , int n ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }
FIND_@@ NUMBER_@@ OF@@ _S@@ OL@@ U@@ TIONS_@@ OF_@@ A_@@ LINEAR_@@ EQU@@ ATION_@@ OF_@@ N_@@ VARIABLES | static int count@@ So@@ l ( int coeff [ ] , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += count@@ So@@ l ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }
S@@ UM_@@ ELEMEN@@ TS_@@ K@@ 1@@ TH_@@ K@@ 2@@ TH@@ _S@@ MAL@@ LE@@ ST_@@ ELEMEN@@ TS_@@ 1 | static void min@@ heap@@ ify ( int [ ] a , int index ) { int small = index ; int l = 2 * index + 1 ; int r = 2 * index + 2 ; if ( l < n && a [ l ] < a [ small ] ) small = l ; if ( r < n && a [ r ] < a [ small ] ) small = r ; if ( small != index ) { int t = a [ small ] ; a [ small ] = a [ index ] ; a [ index ] = t ; min@@ heap@@ ify ( a , small ) ; } }
SE@@ ARCH@@ ING_@@ FOR_@@ PATTER@@ NS@@ _SET_@@ 2_@@ K@@ MP_@@ ALGORITH@@ M | void compute@@ LP@@ S@@ Array ( String pat , int M , int l@@ ps [ ] ) { int len = 0 ; int i = 1 ; l@@ ps [ 0 ] = 0 ; while ( i < M ) { if ( pat . charAt ( i ) == pat . charAt ( len ) ) { len ++ ; l@@ ps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = l@@ ps [ len - 1 ] ; } else { l@@ ps [ i ] = len ; i ++ ; } } } }
FIND_@@ MINIMUM_@@ DIFF@@ ER@@ ENCE_@@ PAIR | static int find@@ Min@@ Diff ( int [ ] arr , int n ) { int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . abs ( ( arr [ i ] - arr [ j ] ) ) ; return diff ; }
PRINT_@@ FIRST_@@ K_@@ DIG@@ IT@@ S_@@ 1@@ N_@@ N_@@ POSITIVE_@@ INTEGER | static void print ( int n , int k ) { int rem = 1 ; for ( int i = 0 ; i < k ; i ++ ) { System . out . print ( ( 10 * rem ) / n ) ; rem = ( 10 * rem ) % n ; } }
GROUP_@@ MULTIPLE_@@ OC@@ CURR@@ ENCE_@@ OF_@@ ARRAY_@@ ELEMEN@@ TS_@@ ORDE@@ RED_@@ BY_@@ FIRST_@@ OC@@ CURR@@ ENCE | static void group@@ Elements ( int arr [ ] , int n ) { boolean visited [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { visited [ i ] = false ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ! visited [ i ] ) { System . out . print ( arr [ i ] + " ▁ " ) ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { System . out . print ( arr [ i ] + " ▁ " ) ; visited [ j ] = true ; } } } } }
CHECK_@@ WHE@@ THER_@@ ARI@@ TH@@ ME@@ TIC_@@ PROG@@ RES@@ SION_@@ CAN_@@ FOR@@ MED_@@ GI@@ V@@ EN_@@ ARRAY | static boolean check@@ Is@@ AP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; Arrays . sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
N@@ TH_@@ MULTIPLE_@@ NUMBER_@@ FI@@ BON@@ AC@@ CI@@ _SERI@@ ES | public static int find@@ Position ( int k , int n ) { long f1 = 0 , f2 = 1 , f3 ; int i = 2 ; while ( i != 0 ) { f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; if ( f2 % k == 0 ) { return n * i ; } i ++ ; } return 0 ; }
COUNT_@@ PAIR@@ S_@@ DIFF@@ ER@@ ENCE_@@ EQUAL_@@ K_@@ 1 | static int count@@ Pai@@ rs@@ With@@ Diff@@ K ( int arr [ ] , int n , int k ) { int count = 0 ; Arrays . sort ( arr ) ; int l = 0 ; int r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }
ELEMEN@@ TS_@@ TO_@@ BE_@@ AD@@ DE@@ D_S@@ O_@@ TH@@ AT_@@ ALL_@@ ELEMEN@@ TS_@@ OF_@@ A_@@ RANGE_@@ ARE_@@ PRES@@ ENT_@@ IN_@@ ARRAY | static int count@@ Num ( int [ ] arr , int n ) { int count = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; }
MAKE_@@ LAR@@ GE@@ ST_@@ PA@@ LIN@@ DRO@@ ME_@@ CHAN@@ G@@ ING_@@ K_@@ DIGITS | static String maximum@@ Pal@@ in@@ Using@@ K@@ Changes ( String str , int k ) { char pal@@ in [ ] = str . toCharArray ( ) ; String ans = " " ; int l = 0 ; int r = str . length ( ) - 1 ; while ( l < r ) { if ( str . charAt ( l ) != str . charAt ( r ) ) { pal@@ in [ l ] = pal@@ in [ r ] = ( char ) Math . max ( str . charAt ( l ) , str . charAt ( r ) ) ; k -- ; } l ++ ; r -- ; } if ( k < 0 ) { return " Not ▁ possible " ; } l = 0 ; r = str . length ( ) - 1 ; while ( l <= r ) { if ( l == r ) { if ( k > 0 ) { pal@@ in [ l ] = '9' ; } } if ( pal@@ in [ l ] < '9' ) { if ( k >= 2 && pal@@ in [ l ] == str . charAt ( l ) && pal@@ in [ r ] == str . charAt ( r ) ) { k -= 2 ; pal@@ in [ l ] = pal@@ in [ r ] = '9' ; } else if ( k >= 1 && ( pal@@ in [ l ] != str . charAt ( l ) || pal@@ in [ r ] != str . charAt ( r ) ) ) { k -- ; pal@@ in [ l ] = pal@@ in [ r ] = '9' ; } } l ++ ; r -- ; } for ( int i = 0 ; i < pal@@ in . length ; i ++ ) ans += pal@@ in [ i ] ; return ans ; }
SUB@@ ARRAY@@ SUB@@ STRING_@@ VS@@ _SUB@@ SEQU@@ ENCE_@@ AND_@@ PROGR@@ AM@@ S_TO_@@ GENERATE_@@ THE@@ M | static void sub@@ Array ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) System . out . print ( arr [ k ] + " ▁ " ) ; } } }
MAX@@ IM@@ UM@@ _S@@ UM_@@ INCRE@@ AS@@ ING_@@ ORDER_@@ ELEMEN@@ TS_@@ N_@@ ARRAY@@ S | static int maximum@@ Sum ( int a [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) sort ( a , i , n ) ; int sum = a [ n - 1 ] [ M - 1 ] ; int prev = a [ n - 1 ] [ M - 1 ] ; int i , j ; for ( i = n - 2 ; i >= 0 ; i -- ) { for ( j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i ] [ j ] < prev ) { prev = a [ i ] [ j ] ; sum += prev ; break ; } } if ( j == - 1 ) return 0 ; } return sum ; }
C_@@ PROGRAM_@@ FAC@@ TOR@@ I@@ AL_@@ NUMBER | static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
PRINT_@@ SQU@@ AR@@ ES_@@ FIRST_@@ N_@@ N@@ ATUR@@ AL_@@ NUMB@@ ERS_@@ WITH@@ OUT_@@ USING | static void print@@ Squ@@ ares ( int n ) { int square = 0 , prev_@@ x = 0 ; for ( int x = 0 ; x < n ; x ++ ) { square = ( square + x + prev_@@ x ) ; System . out . print ( square + " ▁ " ) ; prev_@@ x = x ; } }
RO@@ PE@@ S_@@ DATA_@@ STRUC@@ TURE_@@ FAST_@@ STRING_@@ CON@@ CAT@@ EN@@ ATION | static void concatenate ( char a [ ] , char b [ ] , char c [ ] , int n1 , int n2 ) { int i ; for ( i = 0 ; i < n1 ; i ++ ) { c [ i ] = a [ i ] ; } for ( int j = 0 ; j < n2 ; j ++ ) { c [ i ++ ] = b [ j ] ; } }
GI@@ V@@ EN_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S_@@ NUMBER_@@ X_@@ FIND_@@ PA@@ IR_@@ WHO@@ SE_@@ S@@ UM_@@ CLO@@ SE@@ ST_@@ X | void print@@ Close@@ st ( int ar@@ 1 [ ] , int ar@@ 2 [ ] , int m , int n , int x ) { int diff = Integer . MAX_VALUE ; int res_@@ l = 0 , res_@@ r = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . abs ( ar@@ 1 [ l ] + ar@@ 2 [ r ] - x ) < diff ) { res_@@ l = l ; res_@@ r = r ; diff = Math . abs ( ar@@ 1 [ l ] + ar@@ 2 [ r ] - x ) ; } if ( ar@@ 1 [ l ] + ar@@ 2 [ r ] > x ) r -- ; else l ++ ; } System . out . print ( " The ▁ closest ▁ pair ▁ is ▁ [ " + ar@@ 1 [ res_@@ l ] + " , ▁ " + ar@@ 2 [ res_@@ r ] + " ] " ) ; }
CONVERT_@@ STRIC@@ TL@@ Y_@@ INCRE@@ AS@@ ING_@@ ARRAY_@@ MINIMUM_@@ CHAN@@ GES | static int min@@ Remove ( int arr [ ] , int n ) { int LI@@ S [ ] = new int [ n ] ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LI@@ S [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LI@@ S [ i ] = Math . max ( LI@@ S [ i ] , LI@@ S [ j ] + 1 ) ; } len = Math . max ( len , LI@@ S [ i ] ) ; } return n - len ; }
TA@@ IL_@@ RECUR@@ SION | static int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
RECUR@@ SIVE_@@ FUNCTIONS | static void tower ( int n , char source@@ Po@@ le , char destination@@ Po@@ le , char auxili@@ ary@@ Po@@ le ) { if ( 0 == n ) return ; tower ( n - 1 , source@@ Po@@ le , auxili@@ ary@@ Po@@ le , destination@@ Po@@ le ) ; System . out . printf ( " Move ▁ the ▁ disk ▁ % d ▁ from ▁ % c ▁ to ▁ % c \n " , n , source@@ Po@@ le , destination@@ Po@@ le ) ; tower ( n - 1 , auxili@@ ary@@ Po@@ le , destination@@ Po@@ le , source@@ Po@@ le ) ; }
FIND_@@ X_@@ Y_S@@ ATI@@ SF@@ Y@@ ING_@@ A@@ X_@@ N | static void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { System . out . println ( " x ▁ = ▁ " + i + " , ▁ y ▁ = ▁ " + ( n - ( i * a ) ) / b ) ; return ; } } System . out . println ( " No ▁ solution " ) ; }
EXPO@@ NE@@ N@@ TI@@ AL_S@@ QUAR@@ ING_@@ FAST_@@ MODUL@@ O_@@ MULTIP@@ LIC@@ ATION_@@ 1 | static long expon@@ enti@@ ation ( long base , long exp ) { long t = 1L ; while ( exp > 0 ) { if ( exp % 2 != 0 ) t = ( t * base ) % N ; base = ( base * base ) % N ; exp /= 2 ; } return t % N ; }
CHECK_@@ OC@@ CURR@@ EN@@ CES_@@ CHARACTER_@@ AP@@ PE@@ AR_@@ TO@@ GE@@ THER | static boolean check@@ If@@ All@@ To@@ gether ( String s , char c ) { boolean one@@ Seen = false ; int i = 0 , n = s . length ( ) ; while ( i < n ) { if ( s . charAt ( i ) == c ) { if ( one@@ Seen == true ) return false ; while ( i < n && s . charAt ( i ) == c ) i ++ ; one@@ Seen = true ; } else i ++ ; } return true ; }
MAXIMUM_@@ AREA_@@ REC@@ TAN@@ GLE_@@ PIC@@ KING_@@ FOUR@@ _SI@@ DES_@@ ARRAY | static int find@@ Area ( Integer arr [ ] , int n ) { Arrays . sort ( arr , Collections . reverse@@ Order ( ) ) ; int [ ] dimension = { 0 , 0 } ; for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; }
PYTHON_@@ PROGRAM_@@ FIND_@@ PER@@ I@@ ME@@ TER_@@ CIRCUM@@ FER@@ ENCE_@@ SQU@@ ARE_@@ REC@@ TA@@ NG@@ LE | int Cir@@ cum@@ ference ( int a ) { return 4 * a ; }
CY@@ CLE_@@ S@@ ORT | public static void cycle@@ Sort ( int arr [ ] , int n ) { int writes = 0 ; for ( int cycle@@ _start = 0 ; cycle@@ _start <= n - 2 ; cycle@@ _start ++ ) { int item = arr [ cycle@@ _start ] ; int pos = cycle@@ _start ; for ( int i = cycle@@ _start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos ++ ; if ( pos == cycle@@ _start ) continue ; while ( item == arr [ pos ] ) pos += 1 ; if ( pos != cycle@@ _start ) { int temp = item ; item = arr [ pos ] ; arr [ pos ] = temp ; writes ++ ; } while ( pos != cycle@@ _start ) { pos = cycle@@ _start ; for ( int i = cycle@@ _start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos += 1 ; while ( item == arr [ pos ] ) pos += 1 ; if ( item != arr [ pos ] ) { int temp = item ; item = arr [ pos ] ; arr [ pos ] = temp ; writes ++ ; } } } }
SELECT_@@ A_@@ RANDOM_@@ NUMBER_@@ FROM_@@ STREAM_@@ WITH_@@ O@@ 1@@ _SPACE | static int select@@ Random ( int x ) { count ++ ; if ( count == 1 ) res = x ; else { Random r = new Random ( ) ; int i = r . nextInt ( count ) ; if ( i == count - 1 ) res = x ; } return res ; }
HO@@ SO@@ Y@@ AS_@@ TRI@@ ANGLE | static void print@@ Ho@@ so@@ ya ( int n ) { int dp [ ] [ ] = new int [ N ] [ N ] ; dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) System . out . print ( dp [ i ] [ j ] + " ▁ " ) ; System . out . println ( " " ) ; } }
DISTRIBU@@ TING_@@ M_@@ ITE@@ MS_@@ CI@@ R@@ CLE_@@ SIZE_@@ N_@@ START@@ ING_@@ K_@@ TH_@@ POSITION | static int last@@ Position ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; }
PRINT@@ ING_@@ LON@@ GE@@ ST_@@ INCRE@@ AS@@ ING_@@ CON@@ SEC@@ UTI@@ VE_@@ SUB@@ SEQUENCE | public static void lon@@ gest@@ Sub@@ sequence ( int [ ] a , int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; int [ ] dp = new int [ n ] ; int maximum = Integer . MIN_VALUE ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . get ( a [ i ] - 1 ) != null ) { int lastIndex = mp . get ( a [ i ] - 1 ) - 1 ; dp [ i ] = 1 + dp [ lastIndex ] ; } else dp [ i ] = 1 ; mp . put ( a [ i ] , i + 1 ) ; if ( maximum < dp [ i ] ) { maximum = dp [ i ] ; index = i ; } } for ( int curr = a [ index ] - maximum + 1 ; curr <= a [ index ] ; curr ++ ) System . out . print ( curr + " ▁ " ) ; }
NUMBER_OF_@@ TRIANG@@ LES_@@ IN_@@ DIREC@@ TED_@@ AND_@@ UN@@ DIREC@@ TED_@@ GRAP@@ HS | int count@@ Triangle ( int graph [ ] [ ] , boolean is@@ Direc@@ ted ) { int count_@@ Triangle = 0 ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { for ( int k = 0 ; k < V ; k ++ ) { if ( graph [ i ] [ j ] == 1 && graph [ j ] [ k ] == 1 && graph [ k ] [ i ] == 1 ) count_@@ Triangle ++ ; } } } if ( is@@ Direc@@ ted == true ) { count_@@ Triangle /= 3 ; } else { count_@@ Triangle /= 6 ; } return count_@@ Triangle ; }
CHECK_@@ GI@@ V@@ EN_@@ ARRAY_@@ CONTAIN@@ S_@@ DUPLIC@@ ATE_@@ ELEMEN@@ TS_@@ WITH@@ IN_@@ K_@@ DISTANCE | static boolean check@@ Duplicate@@ sWith@@ in@@ K ( int arr [ ] , int k ) { HashSet < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( set . contains ( arr [ i ] ) ) return true ; set . add ( arr [ i ] ) ; if ( i >= k ) set . remove ( arr [ i - k ] ) ; } return false ; }
MINIMUM_@@ INSER@@ TION@@ S_S@@ ORT_@@ ARRAY | static int min@@ Insertion@@ Step@@ To@@ Sort@@ Array ( int arr [ ] , int N ) { int [ ] lis = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int max = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return ( N - max ) ; }
GENERATE_@@ TWO_@@ OUTPUT_@@ STRING@@ S_@@ DEPEND@@ ING_@@ UP@@ ON_@@ OC@@ CURR@@ ENCE_@@ CHARACTER_@@ INPUT_@@ STRING | static void print@@ Du@@ o ( String str ) { int count@@ Char [ ] = new int [ MAX_@@ CHAR ] ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { count@@ Char [ str . charAt ( i ) - ' a ' ] ++ ; } String str1 = " " , str2 = " " ; for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) { if ( count@@ Char [ i ] > 1 ) { str2 = str2 + ( char ) ( i + ' a ' ) ; } else if ( count@@ Char [ i ] == 1 ) { str1 = str1 + ( char ) ( i + ' a ' ) ; } } System . out . print ( " String ▁ with ▁ characters ▁ occur@@ ring ▁ " + " once : \n " ) ; System . out . print ( str1 + " \n " ) ; System . out . print ( " String ▁ with ▁ characters ▁ occur@@ ring ▁ " + " multiple ▁ times : \n " ) ; System . out . print ( str2 + " \n " ) ; System . out . print ( " " ) ; }
NUMBER_@@ DIG@@ IT@@ S_@@ PRODUCT_@@ TWO_@@ NUMB@@ ERS_@@ 1 | public static int count@@ Digits ( int a , int b ) { if ( a == 0 || b == 0 ) return 1 ; return ( int ) Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ; }
TOTAL_@@ NUMBER_OF_@@ NON_@@ DECRE@@ AS@@ ING_@@ NUMB@@ ERS_@@ WITH_@@ N_@@ DIG@@ IT@@ S_@@ 1 | static long count@@ Non@@ Decre@@ asing ( int n ) { int N = 10 ; long count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count /= i ; } return count ; }
COUNT_@@ STRING@@ S_@@ AD@@ J@@ AC@@ ENT_@@ CHARAC@@ TER@@ S_@@ DIFF@@ ER@@ ENCE_@@ ONE | static long count@@ Str@@ s ( int n ) { long [ ] [ ] dp = new long [ n + 1 ] [ 27 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < 27 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i <= 25 ; i ++ ) { dp [ 1 ] [ i ] = 1 ; } for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 25 ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } else { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ; } } } long sum = 0 ; for ( int i = 0 ; i <= 25 ; i ++ ) { sum = ( sum + dp [ n ] [ i ] ) ; } return sum ; }
PROGRAM_@@ TO_@@ EF@@ FI@@ CI@@ EN@@ TL@@ Y_@@ CAL@@ CUL@@ ATE_@@ EX | static float exponential ( int n , float x ) { float sum = 1 ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }
EF@@ FI@@ CI@@ EN@@ TL@@ Y_@@ COMP@@ UTE_@@ SUM@@ S_@@ OF_@@ DIAG@@ ON@@ AL@@ S_@@ OF_@@ A_@@ MATRIX_@@ 1 | static void print@@ Diag@@ onal@@ Sum@@ s ( int [ ] [ ] mat , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { principal += mat [ i ] [ i ] ; secondary += mat [ i ] [ n - i - 1 ] ; } System . out . println ( " Principal ▁ Diagonal : " + principal ) ; System . out . println ( " Secondary ▁ Diagonal : " + secondary ) ; }
PRINT_@@ WAY@@ S_@@ BREAK_@@ STRING_@@ BRAC@@ KET_@@ FORM | static void find@@ Combin@@ ations ( String str , int index , String out ) { if ( index == str . length ( ) ) System . out . println ( out ) ; for ( int i = index ; i < str . length ( ) ; i ++ ) find@@ Combin@@ ations ( str , i + 1 , out + " ( " + str . substring ( index , i + 1 ) + " ) " ) ; }
LINE@@ AR@@ _SEARCH | public static int search ( int arr [ ] , int x ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }
FIND_@@ THE_@@ ELEMENT_@@ TH@@ AT_@@ AP@@ PE@@ AR@@ S_@@ ON@@ CE_@@ 2 | static int single@@ Number ( int a [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i : a ) { s . add ( i ) ; } int arr_@@ sum = 0 ; for ( int i : a ) { arr_@@ sum += i ; } int set_@@ sum = 0 ; for ( int i : s ) { set_@@ sum += i ; } return ( 3 * set_@@ sum - arr_@@ sum ) / 2 ; }
SEARCH_@@ AL@@ MO@@ ST@@ _S@@ OR@@ TED_@@ ARRAY | int binary@@ Search ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 ) ; if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ) ; if ( arr [ mid ] > x ) return binary@@ Search ( arr , l , mid - 2 , x ) ; return binary@@ Search ( arr , mid + 2 , r , x ) ; } return - 1 ; }
E@@ UL@@ ERS_@@ TO@@ TI@@ ENT_@@ FUNCTION_@@ FOR_@@ ALL_@@ NUMBER@@ S_S@@ MAL@@ LER_@@ TH@@ AN_@@ OR_@@ EQUAL_@@ TO_@@ N | static void compute@@ To@@ ti@@ ent ( int n ) { long phi [ ] = new long [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p <= n ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i <= n ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } for ( int i = 1 ; i <= n ; i ++ ) System . out . println ( " To@@ ti@@ ent ▁ of ▁ " + i + " ▁ is ▁ " + phi [ i ] ) ; }
FIND_@@ MINIMUM_@@ NUMBER_@@ DI@@ VIDE@@ D_@@ MAKE_@@ NUMBER_@@ PER@@ F@@ ECT_@@ SQUARE | static int find@@ Min@@ Number ( int n ) { int count = 0 , ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 2 == 1 ) ans *= 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 2 == 1 ) ans *= i ; } if ( n > 2 ) ans *= n ; return ans ; }
COUNT_@@ NUMBER_@@ WAY@@ S_@@ JUM@@ P_@@ REACH_@@ END | static void count@@ Way@@ sTo@@ Jump ( int arr [ ] , int n ) { int count_@@ jump [ ] = new int [ n ] ; Arrays . fill ( count_@@ jump , 0 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_@@ jump [ i ] ++ ; for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_@@ jump [ j ] != - 1 ) count_@@ jump [ i ] += count_@@ jump [ j ] ; if ( count_@@ jump [ i ] == 0 ) count_@@ jump [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( count_@@ jump [ i ] + " ▁ " ) ; }
CONVERT_@@ SUB@@ STRING@@ S_@@ LENGTH_@@ K_@@ BASE_@@ B_@@ DECIMAL_@@ 1 | static void sub@@ string@@ Conversions ( String str , int k , int b ) { int i = 0 , sum = 0 , counter = k - 1 ; for ( i = 0 ; i < k ; i ++ ) { sum = ( int ) ( sum + ( ( str . charAt ( i ) - '0' ) * Math . pow ( b , counter ) ) ) ; counter -- ; } System . out . print ( sum + " ▁ " ) ; int prev = sum ; sum = 0 ; counter = 0 ; for ( ; i < str . length ( ) ; i ++ ) { sum = ( int ) ( prev - ( ( str . charAt ( i - k ) - '0' ) * Math . pow ( b , k - 1 ) ) ) ; sum = sum * b ; sum = sum + ( str . charAt ( i ) - '0' ) ; System . out . print ( sum + " ▁ " ) ; prev = sum ; counter ++ ; } }
TWO_@@ ELEMEN@@ TS_@@ WHO@@ SE_@@ S@@ UM_@@ IS_@@ CLO@@ SE@@ ST_@@ TO_@@ ZERO | static void min@@ Abs@@ Sum@@ Pair ( int arr [ ] , int arr_@@ size ) { int inv_@@ count = 0 ; int l , r , min_@@ sum , sum , min_@@ l , min_@@ r ; if ( arr_@@ size < 2 ) { System . out . println ( " Invalid ▁ Input " ) ; return ; } min_@@ l = 0 ; min_@@ r = 1 ; min_@@ sum = arr [ 0 ] + arr [ 1 ] ; for ( l = 0 ; l < arr_@@ size - 1 ; l ++ ) { for ( r = l + 1 ; r < arr_@@ size ; r ++ ) { sum = arr [ l ] + arr [ r ] ; if ( Math . abs ( min_@@ sum ) > Math . abs ( sum ) ) { min_@@ sum = sum ; min_@@ l = l ; min_@@ r = r ; } } } System . out . println ( " ▁ The ▁ two ▁ elements ▁ whose ▁ " + " sum ▁ is ▁ minimum ▁ are ▁ " + arr [ min_@@ l ] + " ▁ and ▁ " + arr [ min_@@ r ] ) ; }
HO@@ W_@@ TO_@@ PRINT_@@ MAXIMUM_@@ NUMBER_OF_@@ A_@@ USING_@@ GI@@ V@@ EN_@@ FOUR_@@ KEYS | static int find@@ optimal ( int N ) { if ( N <= 6 ) return N ; int [ ] screen = new int [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }
PROGRAM_@@ DECIMAL_@@ BINARY_@@ CON@@ VERSION_@@ 2 | static int decimal@@ To@@ Binary ( int N ) { int B_@@ Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; double c = Math . pow ( 10 , cnt ) ; B_@@ Number += rem * c ; N /= 2 ; cnt ++ ; } return B_@@ Number ; }
COUN@@ TS_@@ PATH@@ S_@@ POINT_@@ REACH_@@ ORIG@@ IN_@@ 1 | static int count@@ Paths ( int n , int m ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }
S@@ UM_@@ ELEMEN@@ TS_@@ K@@ 1@@ TH_@@ K@@ 2@@ TH@@ _S@@ MAL@@ LE@@ ST_@@ ELEMENTS | static int sum@@ Between@@ Two@@ K@@ th ( int arr [ ] , int k1 , int k2 ) { Arrays . sort ( arr ) ; int result = 0 ; for ( int i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; }
SM@@ ALLE@@ ST@@ _SUB@@ ARRAY_@@ K_@@ DISTIN@@ CT_@@ NUMB@@ ERS | static void min@@ Range ( int arr [ ] , int n , int k ) { int l = 0 , r = n ; for ( int i = 0 ; i < n ; i ++ ) { Set < Integer > s = new HashSet < Integer > ( ) ; int j ; for ( j = i ; j < n ; j ++ ) { s . add ( arr [ j ] ) ; if ( s . size ( ) == k ) { if ( ( j - i ) < ( r - l ) ) { r = j ; l = i ; } break ; } } if ( j == n ) break ; } if ( l == 0 && r == n ) System . out . println ( " Invalid ▁ k " ) ; else System . out . println ( l + " ▁ " + r ) ; }
AREA_@@ OF_@@ A_@@ HEX@@ AG@@ ON | public static double hex@@ ag@@ on@@ Area ( double s ) { return ( ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ; }
NEXT_@@ POWER_@@ OF_@@ 2_2 | static int next@@ PowerOf@@ 2 ( int n ) { n -- ; n |= n > > 1 ; n |= n > > 2 ; n |= n > > 4 ; n |= n > > 8 ; n |= n > > 16 ; n ++ ; return n ; }
COUNT_@@ SUB@@ STRING@@ S_@@ BINARY_@@ STRING_@@ CONTAIN@@ ING_@@ K_@@ ONE@@ S | static int count@@ Of@@ Sub@@ string@@ With@@ K@@ Ones ( String s , int K ) { int N = s . length ( ) ; int res = 0 ; int count@@ Of@@ One = 0 ; int [ ] freq = new int [ N + 1 ] ; freq [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { count@@ Of@@ One += ( s . charAt ( i ) - '0' ) ; if ( count@@ Of@@ One >= K ) { res += freq [ count@@ Of@@ One - K ] ; } freq [ count@@ Of@@ One ] ++ ; } return res ; }
NUMBER_@@ INDEX@@ ES_@@ EQUAL_@@ ELEMEN@@ TS_@@ GI@@ V@@ EN_@@ RANGE | static int answer_@@ query ( int a [ ] , int n , int l , int r ) { int count = 0 ; for ( int i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; }
CHECK_@@ WHE@@ THER_@@ NUMBER_@@ DUC@@ K_@@ NUMBER_@@ NOT | static int check_@@ du@@ ck ( String num ) { int len = num . length ( ) ; int count_@@ zero = 0 ; char ch ; for ( int i = 1 ; i < len ; i ++ ) { ch = num . charAt ( i ) ; if ( ch == '0' ) count_@@ zero ++ ; } return count_@@ zero ; }
NUMBER_@@ NON_@@ NEGATIVE_@@ INTEGR@@ AL_S@@ OL@@ U@@ TIONS_@@ B_@@ C_@@ N_@@ 1 | static int count@@ Integr@@ al@@ Solutions ( int n ) { return ( ( n + 1 ) * ( n + 2 ) ) / 2 ; }
MAXIMUM_@@ PROFI@@ T_@@ BY_@@ BU@@ Y@@ ING_@@ AND@@ _S@@ EL@@ LING_@@ A@@ _SH@@ ARE_@@ AT_@@ MO@@ ST_@@ K_@@ TIME@@ S_@@ 1 | static int max@@ Pro@@ fit ( int price [ ] , int n , int k ) { int pro@@ fit [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) pro@@ fit [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) pro@@ fit [ 0 ] [ j ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { int prev@@ Diff = Integer . MIN_VALUE ; for ( int j = 1 ; j < n ; j ++ ) { prev@@ Diff = Math . max ( prev@@ Diff , pro@@ fit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) ; pro@@ fit [ i ] [ j ] = Math . max ( pro@@ fit [ i ] [ j - 1 ] , price [ j ] + prev@@ Diff ) ; } } return pro@@ fit [ k ] [ n - 1 ] ; }
COUNT_@@ CHARAC@@ TER@@ S_@@ POSITION_@@ ENGLI@@ SH_@@ ALPH@@ AB@@ E@@ TS | static int find@@ Count ( String str ) { int result = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( i == ( str . charAt ( i ) - ' a ' ) || i == ( str . charAt ( i ) - ' A ' ) ) { result ++ ; } } return result ; }
COUNT_@@ GF@@ G@@ _SUB@@ SEQU@@ EN@@ CES_@@ GI@@ V@@ EN_@@ STRING | static void count@@ Sub@@ sequence ( String s , int n ) { int cnt@@ G = 0 , cnt@@ F = 0 , result = 0 , C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { switch ( s . charAt ( i ) ) { case ' G ' : cnt@@ G ++ ; result += C ; break ; case ' F ' : cnt@@ F ++ ; C += cnt@@ G ; break ; default : continue ; } } System . out . println ( result ) ; }
FIN@@ D_S@@ MAL@@ LE@@ ST_@@ VALUE_@@ RE@@ PRESEN@@ TE@@ D_S@@ UM@@ _SUB@@ SET_@@ GI@@ V@@ EN_@@ ARRAY | int find@@ S@@ malle@@ st ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 0 ; i < n && arr [ i ] <= res ; i ++ ) res = res + arr [ i ] ; return res ; }
MAXIMUM_@@ POINT@@ S_@@ COLLEC@@ TED_@@ BY_@@ TWO_@@ PER@@ SON@@ S_@@ ALLOWED_@@ TO_@@ ME@@ ET_@@ ONCE | static int find@@ Max@@ Points ( int A [ ] [ ] ) { int [ ] [ ] P1@@ S = new int [ M + 2 ] [ N + 2 ] ; int [ ] [ ] P@@ 1E = new int [ M + 2 ] [ N + 2 ] ; int [ ] [ ] P2@@ S = new int [ M + 2 ] [ N + 2 ] ; int [ ] [ ] P2@@ E = new int [ M + 2 ] [ N + 2 ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 1 ; j <= M ; j ++ ) P1@@ S [ i ] [ j ] = Math . max ( P1@@ S [ i - 1 ] [ j ] , P1@@ S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = M ; j >= 1 ; j -- ) P@@ 1E [ i ] [ j ] = Math . max ( P@@ 1E [ i + 1 ] [ j ] , P@@ 1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = 1 ; j <= M ; j ++ ) P2@@ S [ i ] [ j ] = Math . max ( P2@@ S [ i + 1 ] [ j ] , P2@@ S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = M ; j >= 1 ; j -- ) P2@@ E [ i ] [ j ] = Math . max ( P2@@ E [ i - 1 ] [ j ] , P2@@ E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { for ( int j = 2 ; j < M ; j ++ ) { int op1 = P1@@ S [ i ] [ j - 1 ] + P@@ 1E [ i ] [ j + 1 ] + P2@@ S [ i + 1 ] [ j ] + P2@@ E [ i - 1 ] [ j ] ; int op2 = P1@@ S [ i - 1 ] [ j ] + P@@ 1E [ i + 1 ] [ j ] + P2@@ S [ i ] [ j - 1 ] + P2@@ E [ i ] [ j + 1 ] ; ans = Math . max ( ans , Math . max ( op1 , op2 ) ) ; } } return ans ; }
PROGRAM_@@ FIND_@@ CIRCUM@@ FER@@ ENCE_@@ CIRC@@ LE | static double circum@@ ference ( double r ) { double PI = 3.14@@ 15 ; double ci@@ r = 2 * PI * r ; return ci@@ r ; }
QU@@ ICK@@ LY_@@ FIND_@@ MULTIPLE_@@ LEFT_@@ ROTA@@ TIONS_@@ OF_@@ AN_@@ ARRAY | static void left@@ Rotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) System . out . print ( arr [ i % n ] + " ▁ " ) ; }
MIN@@ IM@@ UM@@ _S@@ UM_@@ CHO@@ OS@@ ING_@@ MINIMUM_@@ PAIR@@ S_@@ ARRAY | static int min@@ Sum ( int [ ] A , int n ) { int min_@@ val = Arrays . stream ( A ) . min ( ) . getAs@@ Int ( ) ; return ( min_@@ val * ( n - 1 ) ) ; }
RECUR@@ SIVE_@@ PROGRAM_@@ PRI@@ ME_@@ NUMBER | static boolean is@@ Prime ( int n , int i ) { if ( n <= 2 ) return ( n == 2 ) ? true : false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return is@@ Prime ( n , i + 1 ) ; }
SPAR@@ SE_@@ SEARCH | static int sparse@@ Search ( String arr [ ] , String x , int n ) { return binary@@ Search ( arr , 0 , n - 1 , x ) ; }
FIND_@@ NUMBER_@@ TIME@@ S_@@ STRING_@@ OC@@ CUR@@ S_@@ GI@@ V@@ EN_@@ STRING | static int count ( String a , String b , int m , int n ) { if ( ( m == 0 && n == 0 ) || n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a . charAt ( m - 1 ) == b . charAt ( n - 1 ) ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
PROGRAM_@@ CHECK_@@ ARRA@@ Y_S@@ OR@@ TED_@@ NOT_@@ ITER@@ ATI@@ VE_@@ RECUR@@ SIVE_@@ 1 | static boolean array@@ Sorted@@ Or@@ Not ( int arr [ ] , int n ) { if ( n == 0 || n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }
FIND_@@ INDEX_@@ 0_@@ REPL@@ AC@@ ED_@@ 1_@@ GET_@@ LON@@ GE@@ ST_@@ CONTINU@@ OU@@ S@@ _SEQU@@ ENCE_@@ 1@@ S_@@ BINARY_@@ ARRAY | static int max@@ One@@ sIndex ( int arr [ ] , int n ) { int max_@@ count = 0 ; int max_@@ index = 0 ; int prev_@@ zero = - 1 ; int prev_@@ prev_@@ zero = - 1 ; for ( int curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_@@ prev_@@ zero > max_@@ count ) { max_@@ count = curr - prev_@@ prev_@@ zero ; max_@@ index = prev_@@ zero ; } prev_@@ prev_@@ zero = prev_@@ zero ; prev_@@ zero = curr ; } } if ( n - prev_@@ prev_@@ zero > max_@@ count ) max_@@ index = prev_@@ zero ; return max_@@ index ; }
FIND_@@ MAXIMUM_@@ PRODUCT_@@ OF_@@ A_@@ TR@@ IP@@ LET_@@ IN_@@ ARRAY_@@ 1 | static int max@@ Product ( int arr [ ] , int n ) { if ( n < 3 ) { return - 1 ; } Arrays . sort ( arr ) ; return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; }
COORDIN@@ ATE@@ S_@@ REC@@ TAN@@ GLE_@@ GI@@ V@@ EN_@@ POINT@@ S_@@ LI@@ E_@@ INS@@ IDE | static void print@@ Rect ( Integer X [ ] , Integer Y [ ] , int n ) { int X@@ max = Collections . max ( Arrays . asList ( X ) ) ; int X@@ min = Collections . min ( Arrays . asList ( X ) ) ; int Y@@ max = Collections . max ( Arrays . asList ( Y ) ) ; int Y@@ min = Collections . min ( Arrays . asList ( Y ) ) ; System . out . println ( " { " + X@@ min + " , ▁ " + Y@@ min + " } " ) ; System . out . println ( " { " + X@@ min + " , ▁ " + Y@@ max + " } " ) ; System . out . println ( " { " + X@@ max + " , ▁ " + Y@@ max + " } " ) ; System . out . println ( " { " + X@@ max + " , ▁ " + Y@@ min + " } " ) ; }
COUNT_@@ BINARY_@@ DIG@@ IT_@@ NUMBER@@ S_S@@ MAL@@ LER_@@ N | static int count@@ Of@@ Binary@@ Number@@ LessThan@@ N ( int N ) { Queue < Integer > q = new LinkedList < > ( ) ; q . add ( 1 ) ; int cnt = 0 ; int t ; while ( q . size ( ) > 0 ) { t = q . peek ( ) ; q . remove ( ) ; if ( t <= N ) { cnt ++ ; q . add ( t * 10 ) ; q . add ( t * 10 + 1 ) ; } } return cnt ; }
CONVERT_@@ DECIMAL_@@ FR@@ ACTION_@@ BINARY_@@ NUMBER | static String decimal@@ To@@ Binary ( double num , int k_@@ prec ) { String binary = " " ; int Integral = ( int ) num ; double fractional = num - Integral ; while ( Integral > 0 ) { int rem = Integral % 2 ; binary += ( ( char ) ( rem + '0' ) ) ; Integral /= 2 ; } binary = reverse ( binary ) ; binary += ( ' . ' ) ; while ( k_@@ prec -- > 0 ) { fractional *= 2 ; int fr@@ act_@@ bit = ( int ) fractional ; if ( fr@@ act_@@ bit == 1 ) { fractional -= fr@@ act_@@ bit ; binary += ( char ) ( 1 + '0' ) ; } else { binary += ( char ) ( 0 + '0' ) ; } } return binary ; }
MAXIMUM_@@ NUMBER_OF_@@ TRAI@@ LING_@@ ZER@@ OS_@@ IN_@@ THE_@@ PRODUCT_@@ OF_THE_@@ SUB@@ SE@@ TS_@@ OF@@ _SIZE_@@ K | static int maximum@@ Zeros ( int arr [ ] , int n , int k ) { int subset [ ] [ ] = new int [ k + 1 ] [ MAX@@ 5 + 5 ] ; for ( int [ ] row : subset ) { Arrays . fill ( row , - 1 ) ; } subset [ 0 ] [ 0 ] = 0 ; for ( int p = 0 ; p < n ; p ++ ) { int pw@@ 2 = 0 , pw@@ 5 = 0 ; while ( arr [ p ] % 2 == 0 ) { pw@@ 2 ++ ; arr [ p ] /= 2 ; } while ( arr [ p ] % 5 == 0 ) { pw@@ 5 ++ ; arr [ p ] /= 5 ; } for ( int i = k - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < MAX@@ 5 ; j ++ ) { if ( subset [ i ] [ j ] != - 1 ) { subset [ i + 1 ] [ j + pw@@ 5 ] = Math . max ( subset [ i + 1 ] [ j + pw@@ 5 ] , subset [ i ] [ j ] + pw@@ 2 ) ; } } } } int ans = 0 ; for ( int i = 0 ; i < MAX@@ 5 ; i ++ ) { ans = Math . max ( ans , Math . min ( i , subset [ k ] [ i ] ) ) ; } return ans ; }
SEARCH_@@ AN_@@ ELEMENT_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ AND_@@ PI@@ VO@@ TED_@@ ARRAY | static int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
PROGRAM_@@ FIND_@@ AREA_@@ CIRC@@ UL@@ AR@@ _SEG@@ MENT | static float area_@@ of_@@ segment ( float radius , float angle ) { float area_@@ of_@@ sector = pi * ( radius * radius ) * ( angle / 360 ) ; float area_@@ of_@@ triangle = ( float ) 1 / 2 * ( radius * radius ) * ( float ) Math . sin ( ( angle * pi ) / 180 ) ; return area_@@ of_@@ sector - area_@@ of_@@ triangle ; }
K@@ _S@@ MAL@@ LE@@ ST_@@ ELEMEN@@ TS_@@ ORDER_@@ USING_@@ O@@ 1_@@ EX@@ TRA@@ _SPACE | public static void print@@ Small ( int arr [ ] , int n , int k ) { for ( int i = k ; i < n ; ++ i ) { int max_@@ var = arr [ k - 1 ] ; int pos = k - 1 ; for ( int j = k - 2 ; j >= 0 ; j -- ) { if ( arr [ j ] > max_@@ var ) { max_@@ var = arr [ j ] ; pos = j ; } } if ( max_@@ var > arr [ i ] ) { int j = pos ; while ( j < k - 1 ) { arr [ j ] = arr [ j + 1 ] ; j ++ ; } arr [ k - 1 ] = arr [ i ] ; } } for ( int i = 0 ; i < k ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
N@@ TH_@@ NON_@@ FI@@ BON@@ ACC@@ I_@@ NUMBER | static int non@@ Fi@@ bon@@ ac@@ ci ( int n ) { int prev@@ Prev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prev@@ Prev = prev ; prev = curr ; curr = prev@@ Prev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; }
ANALY@@ SI@@ S_@@ OF_@@ ALGORITH@@ MS@@ _SET_@@ 2_@@ A@@ SYM@@ P@@ TO@@ TIC_@@ ANALY@@ SIS | static int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) { return i ; } } return - 1 ; }
Z@@ EC@@ K@@ END@@ OR@@ FS_@@ THE@@ O@@ RE@@ M_@@ NON_@@ NEIGH@@ BO@@ UR@@ ING_@@ FI@@ BON@@ ACC@@ I_@@ RE@@ PRESEN@@ TATION | public static int nearest@@ Small@@ er@@ Eq@@ Fi@@ b ( int n ) { if ( n == 0 || n == 1 ) return n ; int f1 = 0 , f2 = 1 , f3 = 1 ; while ( f3 <= n ) { f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return f2 ; }
PRINT_@@ MAX@@ IM@@ UM@@ _SH@@ OR@@ TEST_@@ DISTANCE | static int find_@@ maximum ( int a [ ] , int n , int k ) { HashMap < Integer , Integer > b = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; int d = Math . min ( 1 + i , n - i ) ; if ( ! b . containsKey ( x ) ) b . put ( x , d ) ; else { b . put ( x , Math . min ( d , b . get ( x ) ) ) ; } } int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( x != k - x && b . containsKey ( k - x ) ) ans = Math . min ( Math . max ( b . get ( x ) , b . get ( k - x ) ) , ans ) ; } return ans ; }
GENER@@ ATING_@@ DISTIN@@ CT_@@ SUB@@ SEQU@@ EN@@ CES_@@ OF_@@ A_@@ GI@@ V@@ EN_@@ STRING_@@ IN_@@ LE@@ XI@@ CO@@ GRAP@@ HI@@ C_@@ ORDER | static void generate ( Set < String > st , String s ) { if ( s . length ( ) == 0 ) { return ; } if ( ! st . contains ( s ) ) { st . add ( s ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String t = s ; t = t . substring ( 0 , i ) + t . substring ( i + 1 ) ; generate ( st , t ) ; } } return ; }
WRITE_@@ Y@@ OU@@ _@@ OW@@ N_@@ POWER_@@ WITH@@ OUT_@@ USING_@@ MULTIP@@ LIC@@ ATION_@@ AND_@@ DI@@ VISION | static int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
MAXI@@ MI@@ ZE_@@ VOLUME_@@ CU@@ BO@@ ID_@@ GI@@ VEN@@ _S@@ UM@@ _SI@@ DES_@@ 1 | static int max@@ volume ( int s ) { int length = s / 3 ; s -= length ; int bread@@ th = s / 2 ; int height = s - bread@@ th ; return length * bread@@ th * height ; }
HOR@@ NE@@ RS_@@ METHOD_@@ POLY@@ NO@@ MI@@ AL_@@ EVALU@@ ATION | static int hor@@ ner ( int poly [ ] , int n , int x ) { int result = poly [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; }
MINIMUM_@@ TIME_@@ REQUIRED_@@ PRODUC@@ E_@@ M_@@ ITEMS | static int min@@ Time ( int [ ] arr , int n , int m ) { int t = 0 ; while ( true ) { int items = 0 ; for ( int i = 0 ; i < n ; i ++ ) items += ( t / arr [ i ] ) ; if ( items >= m ) return t ; t ++ ; } }
FIND_@@ DIFF@@ ER@@ ENCE_@@ BETWE@@ EN@@ _S@@ UM@@ S_@@ OF_@@ TWO_@@ DIAG@@ ON@@ ALS | public static int difference ( int arr [ ] [ ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i ] [ j ] ; if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ; } } return Math . abs ( d1 - d2 ) ; }
SHOR@@ TEST_@@ UN@@ COMM@@ ON@@ _SUB@@ SEQUENCE | static int shor@@ test@@ Seq ( char [ ] S , char [ ] T ) { int m = S . length , n = T . length ; int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( int i = 0 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = MAX ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { char ch = S [ i - 1 ] ; int k ; for ( k = j - 1 ; k >= 0 ; k -- ) { if ( T [ k ] == ch ) { break ; } } if ( k == - 1 ) { dp [ i ] [ j ] = 1 ; } else { dp [ i ] [ j ] = Math . min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) ; } } } int ans = dp [ m ] [ n ] ; if ( ans >= MAX ) { ans = - 1 ; } return ans ; }
MIN_@@ FLI@@ PS_@@ OF_@@ CONTINU@@ OUS_@@ CHARAC@@ TER@@ S_TO_@@ MAKE_@@ ALL_@@ CHARAC@@ TER@@ S_S@@ AME_@@ IN_@@ A_@@ STRING | static int find@@ Fli@@ ps ( String str , int n ) { char last = ' ▁ ' ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( last != str . charAt ( i ) ) res ++ ; last = str . charAt ( i ) ; } return res / 2 ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 28@@ _@@ MINIMUM_@@ INSER@@ TIONS_@@ TO_@@ FORM_@@ A_@@ PA@@ LIN@@ DRO@@ ME | static int find@@ Min@@ Inser@@ tions ( char str [ ] , int l , int h ) { if ( l > h ) return Integer . MAX_VALUE ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? find@@ Min@@ Inser@@ tions ( str , l + 1 , h - 1 ) : ( Integer . min ( find@@ Min@@ Inser@@ tions ( str , l , h - 1 ) , find@@ Min@@ Inser@@ tions ( str , l + 1 , h ) ) + 1 ) ; }
COUNT_@@ CHARAC@@ TER@@ S_@@ STRING_@@ DISTAN@@ CE_@@ ENGLI@@ SH_@@ ALPH@@ AB@@ E@@ TS | static int count@@ Pairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( str . charAt ( i ) - str . charAt ( j ) ) == Math . abs ( i - j ) ) result ++ ; return result ; }
MULTI@@ STAGE_@@ GRAP@@ H@@ _SH@@ OR@@ TEST_@@ PATH | public static int shor@@ test@@ Dist ( int [ ] [ ] graph ) { int [ ] dist = new int [ N ] ; dist [ N - 1 ] = 0 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { dist [ i ] = INF ; for ( int j = i ; j < N ; j ++ ) { if ( graph [ i ] [ j ] == INF ) { continue ; } dist [ i ] = Math . min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) ; } } return dist [ 0 ] ; }
MAX@@ IM@@ UM@@ _SIZE_@@ SUB_@@ MATRIX_@@ WITH_@@ ALL_@@ 1@@ S_IN_@@ A_@@ BINARY_@@ MATRIX | static void print@@ Max@@ Sub@@ Square ( int M [ ] [ ] ) { int i , j ; int R = M . length ; int C = M [ 0 ] . length ; int S [ ] [ ] = new int [ R ] [ C ] ; int max_@@ of_@@ s , max_@@ i , max_@@ j ; for ( i = 0 ; i < R ; i ++ ) S [ i ] [ 0 ] = M [ i ] [ 0 ] ; for ( j = 0 ; j < C ; j ++ ) S [ 0 ] [ j ] = M [ 0 ] [ j ] ; for ( i = 1 ; i < R ; i ++ ) { for ( j = 1 ; j < C ; j ++ ) { if ( M [ i ] [ j ] == 1 ) S [ i ] [ j ] = Math . min ( S [ i ] [ j - 1 ] , Math . min ( S [ i - 1 ] [ j ] , S [ i - 1 ] [ j - 1 ] ) ) + 1 ; else S [ i ] [ j ] = 0 ; } } max_@@ of_@@ s = S [ 0 ] [ 0 ] ; max_@@ i = 0 ; max_@@ j = 0 ; for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { if ( max_@@ of_@@ s < S [ i ] [ j ] ) { max_@@ of_@@ s = S [ i ] [ j ] ; max_@@ i = i ; max_@@ j = j ; } } } System . out . println ( " Maximum ▁ size ▁ sub - matrix ▁ is : ▁ " ) ; for ( i = max_@@ i ; i > max_@@ i - max_@@ of_@@ s ; i -- ) { for ( j = max_@@ j ; j > max_@@ j - max_@@ of_@@ s ; j -- ) { System . out . print ( M [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } }
GI@@ VEN@@ _S@@ OR@@ TED_@@ ARRAY_@@ NUMBER_@@ X_@@ FIND_@@ PA@@ IR_@@ ARRAY_@@ WHO@@ SE_@@ S@@ UM_@@ CLO@@ SE@@ ST_@@ X | static void print@@ Close@@ st ( int arr [ ] , int n , int x ) { int res_@@ l = 0 , res_@@ r = 0 ; int l = 0 , r = n - 1 , diff = Integer . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_@@ l = l ; res_@@ r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } System . out . println ( " ▁ The ▁ closest ▁ pair ▁ is ▁ " + arr [ res_@@ l ] + " ▁ and ▁ " + arr [ res_@@ r ] ) ; }
SORT_@@ 1_@@ N@@ _SW@@ APP@@ ING_@@ AD@@ J@@ AC@@ ENT_@@ ELEMEN@@ TS_@@ 1 | static int sorted@@ After@@ Swap ( int [ ] A , int [ ] B , int n ) { int t = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] != 0 ) { if ( A [ i ] != i + 1 ) t = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = t ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return 0 ; } return 1 ; }
TILE_@@ ST@@ AC@@ KING_@@ PRO@@ BLE@@ M | static int possible@@ W@@ ays ( int n , int m , int k ) { int [ ] [ ] dp = new int [ N ] [ N ] ; int [ ] [ ] pres@@ um = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = 0 ; pres@@ um [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i < n + 1 ; i ++ ) { dp [ 0 ] [ i ] = 0 ; pres@@ um [ 0 ] [ i ] = 1 ; } for ( int i = 0 ; i < m + 1 ; i ++ ) { pres@@ um [ i ] [ 0 ] = dp [ i ] [ 0 ] = 1 ; } for ( int i = 1 ; i < m + 1 ; i ++ ) { for ( int j = 1 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = pres@@ um [ i - 1 ] [ j ] ; if ( j > k ) { dp [ i ] [ j ] -= pres@@ um [ i - 1 ] [ j - k - 1 ] ; } } for ( int j = 1 ; j < n + 1 ; j ++ ) { pres@@ um [ i ] [ j ] = dp [ i ] [ j ] + pres@@ um [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; }
NUMBER_OF_@@ PAIR@@ S_IN_@@ AN_@@ ARRAY_@@ H@@ AV@@ ING_S@@ UM_@@ EQUAL_@@ TO_@@ PRODUCT | static int sum@@ Equal@@ Product ( int a [ ] , int n ) { int zero = 0 , two = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { zero ++ ; } if ( a [ i ] == 2 ) { two ++ ; } } int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 ; return cnt ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 17@@ _@@ PA@@ LIN@@ DRO@@ ME_@@ PARTI@@ TION@@ ING | static int min@@ Pal@@ Par@@ tion ( String str ) { int n = str . length ( ) ; int [ ] [ ] C = new int [ n ] [ n ] ; boolean [ ] [ ] P = new boolean [ n ] [ n ] ; int i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; C [ i ] [ i ] = 0 ; } for ( L = 2 ; L <= n ; L ++ ) { for ( i = 0 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( L == 2 ) P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) ; else P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) && P [ i + 1 ] [ j - 1 ] ; if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ; else { C [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) C [ i ] [ j ] = Integer . min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ; } } } return C [ 0 ] [ n - 1 ] ; }
FIND_@@ ONE_@@ MULTIPLE_@@ REPE@@ ATING_@@ ELEMEN@@ TS_@@ READ_@@ ARRAY | static int find@@ Repe@@ ating@@ Number ( int [ ] arr , int n ) { int sq = ( int ) Math . sqrt ( n ) ; int range = ( n / sq ) + 1 ; int [ ] count = new int [ range ] ; for ( int i = 0 ; i <= n ; i ++ ) { count [ ( arr [ i ] - 1 ) / sq ] ++ ; } int selected_@@ block = range - 1 ; for ( int i = 0 ; i < range - 1 ; i ++ ) { if ( count [ i ] > sq ) { selected_@@ block = i ; break ; } } HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( ( selected_@@ block * sq ) < arr [ i ] ) && ( arr [ i ] <= ( ( selected_@@ block + 1 ) * sq ) ) ) { m . put ( arr [ i ] , 1 ) ; if ( m . get ( arr [ i ] ) == 1 ) return arr [ i ] ; } } return - 1 ; }
MIN@@ IM@@ UM@@ _S@@ UM_@@ PATH_@@ TRI@@ ANGLE | static int min@@ Sum@@ Path ( ) { int [ ] memo = new int [ A . length ] ; int n = A . length - 1 ; for ( int i = 0 ; i < A [ n ] . length ; i ++ ) memo [ i ] = A [ n ] [ i ] ; for ( int i = A . length - 2 ; i >= 0 ; i -- ) for ( int j = 0 ; j < A [ i ] . length ; j ++ ) memo [ j ] = A [ i ] [ j ] + ( int ) Math . min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ] ; }
HO@@ W_@@ CAN_@@ W@@ E_@@ S@@ UM_@@ THE_@@ DIG@@ IT@@ S_@@ OF_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ IN@@ _SIN@@ GLE_@@ STATE@@ MENT_@@ 1 | static int getS@@ um ( int n ) { int sum ; for ( sum = 0 ; n > 0 ; sum += n % 10 , n /= 10 ) ; return sum ; }
RECUR@@ SION | static void print@@ Fun ( int test ) { if ( test < 1 ) return ; else { System . out . printf ( " % d ▁ " , test ) ; print@@ Fun ( test - 1 ) ; System . out . printf ( " % d ▁ " , test ) ; return ; } }
MAXIMUM_@@ TR@@ IP@@ LET_@@ S@@ UM_@@ ARRAY | static int max@@ Trip@@ let@@ Sum ( int arr [ ] , int n ) { int sum = - 1000000 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }
MINIMUM_@@ NUMBER_OF_@@ JUM@@ PS_@@ TO_@@ REACH_@@ END_OF_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ 1 | private static int min@@ Jump@@ s ( int [ ] arr , int n ) { int jumps [ ] = new int [ n ] ; int i , j ; if ( n == 0 || arr [ 0 ] == 0 ) return Integer . MAX_VALUE ; jumps [ 0 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) { jumps [ i ] = Integer . MAX_VALUE ; for ( j = 0 ; j < i ; j ++ ) { if ( i <= j + arr [ j ] && jumps [ j ] != Integer . MAX_VALUE ) { jumps [ i ] = Math . min ( jumps [ i ] , jumps [ j ] + 1 ) ; break ; } } } return jumps [ n - 1 ] ; }
MAXI@@ MI@@ ZE_@@ ARRAY_@@ ELEMEN@@ TS_@@ UP@@ TO_@@ GI@@ V@@ EN_@@ NUMBER | static int find@@ Max@@ Val ( int [ ] arr , int n , int num , int max@@ Limit ) { int ind ; int val ; int [ ] [ ] dp = new int [ n ] [ max@@ Limit + 1 ] ; for ( ind = 0 ; ind < n ; ind ++ ) { for ( val = 0 ; val <= max@@ Limit ; val ++ ) { if ( ind == 0 ) { if ( num - arr [ ind ] == val || num + arr [ ind ] == val ) { dp [ ind ] [ val ] = 1 ; } else { dp [ ind ] [ val ] = 0 ; } } else { if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= max@@ Limit ) { if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 || dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) dp [ ind ] [ val ] = 1 ; } else if ( val - arr [ ind ] >= 0 ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] ; } else if ( val + arr [ ind ] <= max@@ Limit ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] ; } else { dp [ ind ] [ val ] = 0 ; } } } } for ( val = max@@ Limit ; val >= 0 ; val -- ) { if ( dp [ n - 1 ] [ val ] == 1 ) { return val ; } } return - 1 ; }
PROGRAM_@@ FOR_@@ DEAD@@ LOCK_@@ FREE_@@ CONDITION_@@ IN_@@ OPER@@ ATING_@@ SYSTEM | static int Resources ( int process , int need ) { int min@@ Resources = 0 ; min@@ Resources = process * ( need - 1 ) + 1 ; return min@@ Resources ; }
NUMBER_@@ DIG@@ IT@@ S_@@ PRODUCT_@@ TWO_@@ NUMB@@ ERS | static int count@@ Digits ( int a , int b ) { int count = 0 ; int p = Math . abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }
FLO@@ OR_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY | static int floor@@ Search ( int arr [ ] , int n , int x ) { if ( x >= arr [ n - 1 ] ) return n - 1 ; if ( x < arr [ 0 ] ) return - 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > x ) return ( i - 1 ) ; return - 1 ; }
CHECK_@@ WHE@@ THER_@@ TRIANGLE_@@ VALID_@@ NOT_@@ SI@@ DES_@@ GI@@ VEN | public static int check@@ Validity ( int a , int b , int c ) { if ( a + b <= c || a + c <= b || b + c <= a ) return 0 ; else return 1 ; }
PRINT_@@ N_@@ X_@@ N@@ _SP@@ IR@@ AL_@@ MATRIX_@@ USING_@@ O@@ 1_@@ EX@@ TRA@@ _SPACE | static void print@@ Sp@@ ir@@ al ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int x ; x = Math . min ( Math . min ( i , j ) , Math . min ( n - 1 - i , n - 1 - j ) ) ; if ( i <= j ) System . out . print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) + " \t " ) ; else System . out . print ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) + " \t " ) ; } System . out . println ( ) ; } }
POSITION_@@ ELEMENT_@@ STABLE_@@ S@@ ORT | static int getIndex@@ In@@ Sorted@@ Array ( int arr [ ] , int n , int idx ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }
MAX@@ IM@@ UM@@ _SEG@@ MENT_@@ VALUE_@@ PUT@@ TING_@@ K_@@ BREAK@@ POINT@@ S_@@ NUMBER | static int find@@ Max@@ Segment ( String s , int k ) { int seg_@@ len = s . length ( ) - k ; int res = 0 ; for ( int i = 0 ; i < seg_@@ len ; i ++ ) res = res * 10 + ( s . charAt ( i ) - '0' ) ; int seg_@@ len_@@ pow = ( int ) Math . pow ( 10 , seg_@@ len - 1 ) ; int curr_@@ val = res ; for ( int i = 1 ; i <= ( s . length ( ) - seg_@@ len ) ; i ++ ) { curr_@@ val = curr_@@ val - ( s . charAt ( i - 1 ) - '0' ) * seg_@@ len_@@ pow ; curr_@@ val = curr_@@ val * 10 + ( s . charAt ( i + seg_@@ len - 1 ) - '0' ) ; res = Math . max ( res , curr_@@ val ) ; } return res ; }
FIN@@ DING_@@ POWER_@@ PRI@@ ME_@@ NUMBER_@@ P_@@ N_@@ 1 | static int Power@@ OFP@@ IN@@ n@@ factorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }
PROGRAM_@@ PR@@ IN@@ T_ID@@ ENTITY_@@ MATRIX | static int identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) System . out . print ( 1 + " ▁ " ) ; else System . out . print ( 0 + " ▁ " ) ; } System . out . println ( ) ; } return 0 ; }
S@@ UM_@@ MATRIX_@@ ELEMENT_@@ ELEMENT_@@ INTEGER_@@ DI@@ VISI@@ ON_@@ ROW_@@ COLUMN | static int find@@ Sum ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) ans += ( i / j ) ; return ans ; }
TI@@ LING_@@ WITH_@@ DO@@ MIN@@ OES | static int count@@ W@@ ays ( int n ) { int [ ] A = new int [ n + 1 ] ; int [ ] B = new int [ n + 1 ] ; A [ 0 ] = 1 ; A [ 1 ] = 0 ; B [ 0 ] = 0 ; B [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ; B [ i ] = A [ i - 1 ] + B [ i - 2 ] ; } return A [ n ] ; }
COUNT_@@ DE@@ RANGE@@ MEN@@ TS_@@ PER@@ MU@@ TA@@ TION@@ _SU@@ CH_@@ TH@@ AT_@@ NO_@@ ELEMENT_@@ AP@@ PE@@ AR@@ S_IN_@@ IT@@ S_@@ ORIGIN@@ AL_@@ POSITION | static int count@@ D@@ er ( int n ) { if ( n == 1 ) return 0 ; if ( n == 0 ) return 1 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( count@@ D@@ er ( n - 1 ) + count@@ D@@ er ( n - 2 ) ) ; }
FREQU@@ ENCY_@@ ELEMENT_@@ UN@@ SOR@@ TED_@@ ARRAY_@@ 1 | static void count@@ Freq ( int a [ ] , int n ) { int hm [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) hm [ a [ i ] ] ++ ; int cum@@ ul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cum@@ ul += hm [ a [ i ] ] ; if ( hm [ a [ i ] ] != 0 ) { System . out . println ( a [ i ] + " - > " + cum@@ ul ) ; } hm [ a [ i ] ] = 0 ; } }
MINI@@ MI@@ ZE_@@ THE_@@ S@@ UM_@@ OF_@@ DIG@@ IT@@ S_@@ OF_@@ A_@@ AND_@@ B@@ _SU@@ CH_@@ TH@@ AT_@@ A_@@ B_@@ N | static int min@@ Sum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } if ( sum == 1 ) return 10 ; return sum ; }
DI@@ VI@@ DE_@@ CU@@ BO@@ ID_@@ CU@@ BE@@ S_S@@ UM_@@ VOLUM@@ ES_@@ MAX@@ IMUM | static void maxim@@ iz@@ ecu@@ be ( int l , int b , int h ) { int side = gcd ( l , gcd ( b , h ) ) ; int num = l / side ; num = ( num * b / side ) ; num = ( num * h / side ) ; System . out . println ( side + " ▁ " + num ) ; }
CHECK_@@ NUMBER_@@ POWER_@@ K_@@ USING_@@ BASE_@@ CHAN@@ G@@ ING_@@ METHOD | static boolean is@@ PowerOf@@ K ( int n , int k ) { boolean one@@ Seen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( one@@ Seen ) return false ; one@@ Seen = true ; } n /= k ; } return true ; }
POSITION_@@ OF_@@ RIGHT@@ MO@@ ST@@ _SET_@@ BIT_@@ 1 | static int Position@@ Right@@ most@@ Set@@ bit ( int n ) { int position = 1 ; int m = 1 ; while ( ( n & m ) == 0 ) { m = m << 1 ; position ++ ; } return position ; }
SEARCH_@@ INSERT_@@ AND_@@ DELETE_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY_@@ 1 | static int insert@@ Sorted ( int arr [ ] , int n , int key , int capacity ) { if ( n >= capacity ) return n ; int i ; for ( i = n - 1 ; ( i >= 0 && arr [ i ] > key ) ; i -- ) arr [ i + 1 ] = arr [ i ] ; arr [ i + 1 ] = key ; return ( n + 1 ) ; }
FIND_@@ THE_@@ MAXIMUM_@@ OF_@@ MIN@@ IM@@ UM@@ S_@@ FOR_@@ EVER@@ Y_@@ WINDOW@@ _SIZE_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ 1 | static void print@@ Max@@ Of@@ Min ( int n ) { Stack < Integer > s = new Stack < > ( ) ; int left [ ] = new int [ n + 1 ] ; int right [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = - 1 ; right [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { while ( ! s . empty ( ) && arr [ s . peek ( ) ] >= arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) left [ i ] = s . peek ( ) ; s . push ( i ) ; } while ( ! s . empty ( ) ) s . pop ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( ! s . empty ( ) && arr [ s . peek ( ) ] >= arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) right [ i ] = s . peek ( ) ; s . push ( i ) ; } int ans [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) ans [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = right [ i ] - left [ i ] - 1 ; ans [ len ] = Math . max ( ans [ len ] , arr [ i ] ) ; } for ( int i = n - 1 ; i >= 1 ; i -- ) ans [ i ] = Math . max ( ans [ i ] , ans [ i + 1 ] ) ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( ans [ i ] + " ▁ " ) ; }
MAXIMUM_@@ DECIMAL_@@ VALUE_@@ PATH_@@ IN_@@ A_@@ BINARY_@@ MATRIX_@@ 1 | static int Maximum@@ Decimal@@ Value ( int mat [ ] [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; if ( mat [ 0 ] [ 0 ] == 1 ) { dp [ 0 ] [ 0 ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ 0 ] [ i ] == 1 ) { dp [ 0 ] [ i ] = ( int ) ( dp [ 0 ] [ i - 1 ] + Math . pow ( 2 , i ) ) ; } else { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ i ] [ 0 ] == 1 ) { dp [ i ] [ 0 ] = ( int ) ( dp [ i - 1 ] [ 0 ] + Math . pow ( 2 , i ) ) ; } else { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { dp [ i ] [ j ] = ( int ) ( Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + Math . pow ( 2 , i + j ) ) ; } else { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } } return dp [ n - 1 ] [ n - 1 ] ; }
COUNT_@@ NUMBER_OF_@@ WAY@@ S_TO_@@ CO@@ VER_@@ A_@@ DISTANCE | static int print@@ Count@@ Rec ( int dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return print@@ Count@@ Rec ( dist - 1 ) + print@@ Count@@ Rec ( dist - 2 ) + print@@ Count@@ Rec ( dist - 3 ) ; }
MOVE_@@ VE_@@ ELEMEN@@ TS_@@ END_@@ ORDER_@@ EX@@ TRA@@ _SPACE_@@ ALLOWED | static void se@@ greg@@ ate@@ Elements ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n || j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
MINIMUM_@@ PER@@ I@@ ME@@ TER_@@ N_@@ BLOCKS | public static long min@@ Per@@ imeter ( int n ) { int l = ( int ) Math . sqrt ( n ) ; int sq = l * l ; if ( sq == n ) return l * 4 ; else { long row = n / l ; long per@@ imeter = 2 * ( l + row ) ; if ( n % l != 0 ) per@@ imeter += 2 ; return per@@ imeter ; } }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 36@@ _@@ CU@@ T_@@ A_@@ RO@@ PE_@@ TO_@@ MAXI@@ MI@@ ZE_@@ PRODUCT | static int max@@ Prod ( int n ) { if ( n == 0 || n == 1 ) return 0 ; int max_@@ val = 0 ; for ( int i = 1 ; i < n ; i ++ ) max_@@ val = Math . max ( max_@@ val , Math . max ( i * ( n - i ) , max@@ Prod ( n - i ) * i ) ) ; return max_@@ val ; }
LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ STRING@@ _SPACE_@@ OPTIMIZ@@ ED_@@ D@@ P_S@@ OL@@ U@@ TION | static int LC@@ Sub@@ Str ( String X , String Y ) { int m = X . length ( ) ; int n = Y . length ( ) ; int result = 0 ; int [ ] [ ] len = new int [ 2 ] [ n ] ; int curr@@ Row = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 || j == 0 ) { len [ curr@@ Row ] [ j ] = 0 ; } else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { len [ curr@@ Row ] [ j ] = len [ ( 1 - curr@@ Row ) ] [ ( j - 1 ) ] + 1 ; result = Math . max ( result , len [ curr@@ Row ] [ j ] ) ; } else { len [ curr@@ Row ] [ j ] = 0 ; } } curr@@ Row = 1 - curr@@ Row ; } return result ; }
CHECK_@@ GI@@ V@@ EN_@@ STRING_@@ ROTATION_@@ PA@@ LIN@@ DRO@@ ME | static boolean is@@ Pal@@ ind@@ ro@@ me ( String str ) { int l = 0 ; int h = str . length ( ) - 1 ; while ( h > l ) if ( str . charAt ( l ++ ) != str . charAt ( h -- ) ) return false ; return true ; }
FIND_@@ NUMBER_@@ OF@@ _S@@ OL@@ U@@ TIONS_@@ OF_@@ A_@@ LINEAR_@@ EQU@@ ATION_@@ OF_@@ N_@@ VARIAB@@ LES_@@ 1 | static int count@@ So@@ l ( int coeff [ ] , int n , int rhs ) { int dp [ ] = new int [ rhs + 1 ] ; Arrays . fill ( dp , 0 ) ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }
FIND_@@ THE_@@ LAR@@ GE@@ ST_@@ PAIR@@ _S@@ UM_@@ IN_@@ AN_@@ UN@@ SOR@@ TED_@@ ARRAY | static int find@@ Largest@@ Sum@@ Pair ( ) { int first , second ; if ( arr [ 0 ] > arr [ 1 ] ) { first = arr [ 0 ] ; second = arr [ 1 ] ; } else { first = arr [ 1 ] ; second = arr [ 0 ] ; } for ( int i = 2 ; i < arr . length ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ] ; } return ( first + second ) ; }
FIND_@@ BIT@@ ON@@ IC_@@ POINT_@@ GI@@ V@@ EN_@@ BIT@@ ON@@ IC@@ _SEQU@@ ENCE | static int binary@@ Search ( int arr [ ] , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binary@@ Search ( arr , mid + 1 , right ) ; else return binary@@ Search ( arr , left , mid - 1 ) ; } return - 1 ; }
PRINT_@@ ALL_@@ DISTIN@@ CT_@@ CHARAC@@ TER@@ S_@@ OF_@@ A_@@ STRING_@@ IN_@@ ORDER_@@ 3_@@ METHO@@ DS_@@ 1 | static void print@@ Distin@@ ct ( String str ) { int n = str . length ( ) ; int [ ] count = new int [ MAX_@@ CHAR ] ; int [ ] index = new int [ MAX_@@ CHAR ] ; for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) { count [ i ] = 0 ; index [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { char x = str . charAt ( i ) ; ++ count [ x ] ; if ( count [ x ] == 1 && x != ' ▁ ' ) index [ x ] = i ; if ( count [ x ] == 2 ) index [ x ] = n ; } Arrays . sort ( index ) ; for ( int i = 0 ; i < MAX_@@ CHAR && index [ i ] != n ; i ++ ) System . out . print ( str . charAt ( index [ i ] ) ) ; }
FIND_@@ TW@@ O@@ _SI@@ DES_@@ RIGHT_@@ ANGLE_@@ TRI@@ ANGLE | static void print@@ Other@@ Si@@ des ( int n ) { if ( n % 2 != 0 ) { if ( n == 1 ) System . out . println ( " - 1" ) ; else { int b = ( n * n - 1 ) / 2 ; int c = ( n * n + 1 ) / 2 ; System . out . println ( " b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } } else { if ( n == 2 ) System . out . println ( " - 1" ) ; else { int b = n * n / 4 - 1 ; int c = n * n / 4 + 1 ; System . out . println ( " b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } } }
COUNT_@@ NUMBER_OF_@@ STRING@@ S_@@ MA@@ DE_@@ OF_@@ R_@@ G_@@ AND_@@ B_@@ USING_@@ GI@@ V@@ EN_@@ COMBIN@@ ATION | static int possible@@ Strings ( int n , int r , int b , int g ) { int fact [ ] = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }
RE@@ AR@@ RANGE_@@ ARRAY_@@ MAXIMUM_@@ MINIMUM_@@ FORM@@ _SET_@@ 2_@@ O@@ 1_@@ EX@@ TRA@@ _SPACE_@@ 1 | public static void re@@ arrange ( int arr [ ] , int n ) { int max_@@ ele = arr [ n - 1 ] ; int min_@@ ele = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_@@ ele ; max_@@ ele -= 1 ; } else { arr [ i ] = min_@@ ele ; min_@@ ele += 1 ; } } }
EVALU@@ ATE_@@ AN_@@ ARRAY_@@ EXPRES@@ SION_@@ WITH_@@ NUMB@@ ERS_@@ AND | public static int calculate@@ Sum ( String arr [ ] , int n ) { if ( n == 0 ) return 0 ; String s = arr [ 0 ] ; int value = Integer . parseInt ( s ) ; int sum = value ; for ( int i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; value = Integer . parseInt ( s ) ; char operation = arr [ i - 1 ] . charAt ( 0 ) ; if ( operation == ' + ' ) sum += value ; else sum -= value ; } return sum ; }
S@@ UM_@@ MATRIX_@@ ELEMENT_@@ ELEMENT_@@ INTEGER_@@ DI@@ VISI@@ ON_@@ ROW_@@ COLUMN_@@ 1 | static int find@@ Sum ( int n ) { int ans = 0 , temp = 0 , num ; for ( int i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; }
SHUFF@@ LE_@@ A_@@ DE@@ CK_@@ OF_@@ CAR@@ DS_@@ 3 | public static void shuffle ( int card [ ] , int n ) { Random rand = new Random ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int r = i + rand . nextInt ( 52 - i ) ; int temp = card [ r ] ; card [ r ] = card [ i ] ; card [ i ] = temp ; } }
DO@@ O@@ LITTLE_@@ ALGORITH@@ M_@@ L@@ U_@@ DE@@ COMPOSI@@ TION | static void lu@@ De@@ composition ( int [ ] [ ] mat , int n ) { int [ ] [ ] lower = new int [ n ] [ n ] ; int [ ] [ ] upper = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int k = i ; k < n ; k ++ ) { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) ; upper [ i ] [ k ] = mat [ i ] [ k ] - sum ; } for ( int k = i ; k < n ; k ++ ) { if ( i == k ) lower [ i ] [ i ] = 1 ; else { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) ; lower [ k ] [ i ] = ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ; } } } System . out . println ( setw ( 2 ) + " ▁ ▁ ▁ ▁ ▁ Lower ▁ Tri@@ angular " + setw ( 10 ) + " Upper ▁ Tri@@ angular " ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( setw ( 4 ) + lower [ i ] [ j ] + " \t " ) ; System . out . print ( " \t " ) ; for ( int j = 0 ; j < n ; j ++ ) System . out . print ( setw ( 4 ) + upper [ i ] [ j ] + " \t " ) ; System . out . print ( " \n " ) ; } }
PROGRAM_@@ N@@ TH_@@ CATA@@ LAN@@ _@@ NUMBER | int catal@@ an ( int n ) { int res = 0 ; if ( n <= 1 ) { return 1 ; } for ( int i = 0 ; i < n ; i ++ ) { res += catal@@ an ( i ) * catal@@ an ( n - i - 1 ) ; } return res ; }
NUMBER_@@ DIG@@ IT@@ S_@@ REMO@@ VED_@@ MAKE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 3 | static int di@@ visible ( String num ) { int n = num . length ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( int ) ( num . charAt ( i ) ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num . charAt ( i ) - '0' ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; }
CHECK_@@ IF_@@ A_@@ NUMBER_@@ IS_@@ POWER_@@ OF_@@ AN@@ OTHER_@@ NUMBER_@@ 1 | static boolean is@@ Power ( int x , int y ) { int res1 = ( int ) Math . log ( y ) / ( int ) Math . log ( x ) ; double res2 = Math . log ( y ) / Math . log ( x ) ; return ( res1 == res2 ) ; }
LAR@@ GE@@ ST@@ _SUB@@ SEQU@@ ENCE_@@ GC@@ D_@@ GREATER_@@ 1 | static int lar@@ gest@@ G@@ CD@@ Sub@@ sequence ( int arr [ ] , int n ) { int ans = 0 ; int max@@ ele = Arrays . stream ( arr ) . max ( ) . getAs@@ Int ( ) ; ; for ( int i = 2 ; i <= max@@ ele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = Math . max ( ans , count ) ; } return ans ; }
FIND_@@ COMMON_@@ ELEMENT_@@ RO@@ WS_@@ ROW_@@ WI@@ SE_@@ SOR@@ TED_@@ MATRIX | static int find@@ Common ( int mat [ ] [ ] ) { int column [ ] = new int [ M ] ; int min_@@ row ; int i ; for ( i = 0 ; i < M ; i ++ ) column [ i ] = N - 1 ; min_@@ row = 0 ; while ( column [ min_@@ row ] >= 0 ) { for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] < mat [ min_@@ row ] [ column [ min_@@ row ] ] ) min_@@ row = i ; } int eq_@@ count = 0 ; for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] > mat [ min_@@ row ] [ column [ min_@@ row ] ] ) { if ( column [ i ] == 0 ) return - 1 ; column [ i ] -= 1 ; } else eq_@@ count ++ ; } if ( eq_@@ count == M ) return mat [ min_@@ row ] [ column [ min_@@ row ] ] ; } return - 1 ; }
CHECK_@@ GI@@ V@@ EN_@@ CI@@ R@@ CLE_@@ LI@@ ES_@@ COMPLE@@ TE@@ LY_@@ IN@@ SIDE_@@ R@@ ING_@@ FOR@@ MED_@@ TWO_@@ CON@@ CEN@@ TRI@@ C_@@ CIRC@@ LES | public static boolean check@@ circle ( int r , int R , int r1 , int x1 , int y1 ) { int dis = ( int ) Math . sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }
COUNT_@@ TO@@ TAL@@ _SET_@@ BITS_@@ IN_@@ ALL_@@ NUMB@@ ERS_@@ FROM_@@ 1_@@ TO_@@ N | static int count@@ Set@@ Bits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { boolean k = false ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { if ( k == true ) ans += 1 ; else ans += 0 ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
LON@@ GE@@ ST_@@ REPE@@ AT@@ ING@@ _SUB@@ SEQUENCE | static int find@@ Lon@@ gest@@ Repe@@ ating@@ Sub@@ Seq ( String str ) { int n = str . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; }
FIND_@@ THE_@@ FIRST_@@ MISSING_@@ NUMBER | int find@@ First@@ Missing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return find@@ First@@ Missing ( array , mid + 1 , end ) ; return find@@ First@@ Missing ( array , start , mid ) ; }
SORT_@@ ARRAY_@@ CONVER@@ TING_@@ ELEMEN@@ TS@@ _S@@ QUAR@@ ES_@@ 1 | public static void sort@@ Squ@@ ares ( int arr [ ] ) { int n = arr . length ; int k ; for ( k = 0 ; k < n ; k ++ ) { if ( arr [ k ] >= 0 ) break ; } int i = k - 1 ; int j = k ; int ind = 0 ; int [ ] temp = new int [ n ] ; while ( i >= 0 && j < n ) { if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) { temp [ ind ] = arr [ i ] * arr [ i ] ; i -- ; } else { temp [ ind ] = arr [ j ] * arr [ j ] ; j ++ ; } ind ++ ; } while ( i >= 0 ) { temp [ ind ++ ] = arr [ i ] * arr [ i ] ; i -- ; } while ( j < n ) { temp [ ind ++ ] = arr [ j ] * arr [ j ] ; j ++ ; } for ( int x = 0 ; x < n ; x ++ ) arr [ x ] = temp [ x ] ; }
PROGRAM_@@ TO_@@ FIND_@@ RE@@ MA@@ INDE@@ R_@@ WITH@@ OUT_@@ USING_@@ MODUL@@ O_@@ OR_@@ OPERATOR | static int getRe@@ main@@ der ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }
MINIMUM_@@ CO@@ ST_@@ TO_@@ FILL_@@ GI@@ V@@ EN_@@ WEIGHT_@@ IN_@@ A_@@ BA@@ G | public static int Minimum@@ Cost ( int cost [ ] , int n , int W ) { Vector < Integer > val = new Vector < Integer > ( ) ; Vector < Integer > wt = new Vector < Integer > ( ) ; int size = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( cost [ i ] != - 1 ) { val . add ( cost [ i ] ) ; wt . add ( i + 1 ) ; size ++ ; } } n = size ; int min_@@ cost [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( int i = 0 ; i <= W ; i ++ ) min_@@ cost [ 0 ] [ i ] = Integer . MAX_VALUE ; for ( int i = 1 ; i <= n ; i ++ ) min_@@ cost [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= W ; j ++ ) { if ( wt . get ( i - 1 ) > j ) min_@@ cost [ i ] [ j ] = min_@@ cost [ i - 1 ] [ j ] ; else min_@@ cost [ i ] [ j ] = Math . min ( min_@@ cost [ i - 1 ] [ j ] , min_@@ cost [ i ] [ j - wt . get ( i - 1 ) ] + val . get ( i - 1 ) ) ; } } return ( min_@@ cost [ n ] [ W ] == Integer . MAX_VALUE ) ? - 1 : min_@@ cost [ n ] [ W ] ; }
COUNT_@@ CHARAC@@ TER@@ S_@@ STRING_@@ DISTAN@@ CE_@@ ENGLI@@ SH_@@ ALPH@@ AB@@ E@@ TS_@@ 1 | static int count@@ Pairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; ( i + j ) < n && j <= MAX_@@ CHAR ; j ++ ) if ( ( Math . abs ( str . charAt ( i + j ) - str . charAt ( i ) ) == j ) ) result ++ ; return result ; }
A_@@ PRODUCT_@@ ARRAY_@@ PU@@ ZZ@@ LE | void product@@ Array ( int arr [ ] , int n ) { if ( n == 1 ) { System . out . print ( 0 ) ; return ; } int left [ ] = new int [ n ] ; int right [ ] = new int [ n ] ; int prod [ ] = new int [ n ] ; int i , j ; left [ 0 ] = 1 ; right [ n - 1 ] = 1 ; for ( i = 1 ; i < n ; i ++ ) left [ i ] = arr [ i - 1 ] * left [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) right [ j ] = arr [ j + 1 ] * right [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) prod [ i ] = left [ i ] * right [ i ] ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( prod [ i ] + " ▁ " ) ; return ; }
FREQU@@ ENT_@@ ELEMENT_@@ ARRAY_@@ 1 | static int most@@ Frequ@@ ent ( int arr [ ] , int n ) { Map < Integer , Integer > hp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int key = arr [ i ] ; if ( hp . containsKey ( key ) ) { int freq = hp . get ( key ) ; freq ++ ; hp . put ( key , freq ) ; } else { hp . put ( key , 1 ) ; } } int max_@@ count = 0 , res = - 1 ; for ( Entry < Integer , Integer > val : hp . entrySet ( ) ) { if ( max_@@ count < val . getValue ( ) ) { res = val . getKey ( ) ; max_@@ count = val . getValue ( ) ; } } return res ; }
PRINT_@@ UNI@@ QUE_@@ ROWS | public static void print@@ Array ( int arr [ ] [ ] , int row , int col ) { HashSet < String > set = new HashSet < String > ( ) ; for ( int i = 0 ; i < row ; i ++ ) { String s = " " ; for ( int j = 0 ; j < col ; j ++ ) s += String . valueOf ( arr [ i ] [ j ] ) ; if ( ! set . contains ( s ) ) { set . add ( s ) ; System . out . println ( s ) ; } } }
COUNT_@@ 1@@ S_S@@ OR@@ TED_@@ BINARY_@@ ARRAY | int count@@ Ones ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return count@@ Ones ( arr , ( mid + 1 ) , high ) ; return count@@ Ones ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
POSSI@@ BLE_@@ MOVE@@ S_@@ KN@@ IGHT | static int find@@ Possible@@ Moves ( int mat [ ] [ ] , int p , int q ) { int X [ ] = { 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 } ; int Y [ ] = { 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 } ; int count = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int x = p + X [ i ] ; int y = q + Y [ i ] ; if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) count ++ ; } return count ; }
ROTA@@ TE_@@ MATRIX_@@ ELEMENTS | static void rotate@@ matrix ( int m , int n , int mat [ ] [ ] ) { int row = 0 , col = 0 ; int prev , curr ; while ( row < m && col < n ) { if ( row + 1 == m || col + 1 == n ) break ; prev = mat [ row + 1 ] [ col ] ; for ( int i = col ; i < n ; i ++ ) { curr = mat [ row ] [ i ] ; mat [ row ] [ i ] = prev ; prev = curr ; } row ++ ; for ( int i = row ; i < m ; i ++ ) { curr = mat [ i ] [ n - 1 ] ; mat [ i ] [ n - 1 ] = prev ; prev = curr ; } n -- ; if ( row < m ) { for ( int i = n - 1 ; i >= col ; i -- ) { curr = mat [ m - 1 ] [ i ] ; mat [ m - 1 ] [ i ] = prev ; prev = curr ; } } m -- ; if ( col < n ) { for ( int i = m - 1 ; i >= row ; i -- ) { curr = mat [ i ] [ col ] ; mat [ i ] [ col ] = prev ; prev = curr ; } } col ++ ; } for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; System . out . print ( " \n " ) ; } }
FIND_@@ K@@ TH_@@ CHARACTER_@@ OF_@@ DE@@ CRYP@@ TED_@@ STRING | static char encoded@@ Char ( String str , int k ) { String expand = " " ; String temp = " " ; int freq = 0 ; for ( int i = 0 ; i < str . length ( ) ; ) { temp = " " ; freq = 0 ; while ( i < str . length ( ) && str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) { temp += str . charAt ( i ) ; i ++ ; } while ( i < str . length ( ) && str . charAt ( i ) >= '1' && str . charAt ( i ) <= '9' ) { freq = freq * 10 + str . charAt ( i ) - '0' ; i ++ ; } for ( int j = 1 ; j <= freq ; j ++ ) expand += temp ; } if ( freq == 0 ) expand += temp ; return expand . charAt ( k - 1 ) ; }
EF@@ FI@@ CI@@ ENT_@@ SEARCH_@@ IN_@@ AN_@@ ARRAY_@@ W@@ HER@@ E_@@ DIFF@@ ER@@ ENCE_@@ BETWE@@ EN_@@ AD@@ J@@ AC@@ ENT_@@ IS_@@ 1 | static int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i <= n - 1 ) { if ( arr [ i ] == x ) return i ; i += Math . abs ( arr [ i ] - x ) ; } return - 1 ; }
MAXIMUM_@@ POSSI@@ BLE_@@ S@@ UM_@@ WINDOW_@@ ARRAY_@@ ELEMEN@@ TS_@@ WINDOW_@@ ARRAY_@@ UNIQUE | static int return@@ Max@@ Sum ( int A [ ] , int B [ ] , int n ) { Set < Integer > mp = new HashSet < Integer > ( ) ; int result = 0 ; int curr_@@ sum = 0 , curr_@@ begin = 0 ; for ( int i = 0 ; i < n ; ++ i ) { while ( mp . contains ( A [ i ] ) ) { mp . remove ( A [ curr_@@ begin ] ) ; curr_@@ sum -= B [ curr_@@ begin ] ; curr_@@ begin ++ ; } mp . add ( A [ i ] ) ; curr_@@ sum += B [ i ] ; result = Integer . max ( result , curr_@@ sum ) ; } return result ; }
WRITE_@@ AN_@@ EF@@ FI@@ CI@@ ENT_@@ METHOD_@@ TO_@@ CHECK_@@ IF_@@ A_@@ NUMBER_@@ IS_@@ MULTIPLE_@@ OF_@@ 3 | static int is@@ Multiple@@ Of@@ 3 ( int n ) { int od@@ d_@@ count = 0 ; int ev@@ en_@@ count = 0 ; if ( n < 0 ) n = - n ; if ( n == 0 ) return 1 ; if ( n == 1 ) return 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 ) od@@ d_@@ count ++ ; if ( ( n & 2 ) != 0 ) ev@@ en_@@ count ++ ; n = n > > 2 ; } return is@@ Multiple@@ Of@@ 3 ( Math . abs ( od@@ d_@@ count - ev@@ en_@@ count ) ) ; }
MAX@@ IM@@ UM@@ _S@@ UM_@@ I@@ AR@@ RI@@ _@@ AM@@ ONG_@@ ROTA@@ TIONS_@@ GI@@ V@@ EN_@@ ARRAY_@@ 1 | static int max@@ Sum ( int arr [ ] , int n ) { int cum@@ _@@ sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) cum@@ _@@ sum += arr [ i ] ; int curr_@@ val = 0 ; for ( int i = 0 ; i < n ; i ++ ) curr_@@ val += i * arr [ i ] ; int res = curr_@@ val ; for ( int i = 1 ; i < n ; i ++ ) { int next_@@ val = curr_@@ val - ( cum@@ _@@ sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ; curr_@@ val = next_@@ val ; res = Math . max ( res , next_@@ val ) ; } return res ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 34@@ _@@ ASSEMB@@ LY_@@ LINE_@@ SCH@@ ED@@ U@@ LING | static int car@@ Assembly ( int a [ ] [ ] , int t [ ] [ ] , int e [ ] , int x [ ] ) { int T1 [ ] = new int [ NUM_@@ ST@@ ATION ] ; int T2 [ ] = new int [ NUM_@@ ST@@ ATION ] ; int i ; T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ; T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ; for ( i = 1 ; i < NUM_@@ ST@@ ATION ; ++ i ) { T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) ; T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ; } return min ( T1 [ NUM_@@ ST@@ ATION - 1 ] + x [ 0 ] , T2 [ NUM_@@ ST@@ ATION - 1 ] + x [ 1 ] ) ; }
PRINT_@@ MATRI@@ X@@ _SP@@ IR@@ AL_@@ FORM_@@ START@@ ING_@@ POINT | static void print@@ Sp@@ ir@@ al ( int [ ] [ ] mat , int r , int c ) { int i , a = 0 , b = 2 ; int low_@@ row = ( 0 > a ) ? 0 : a ; int low_@@ column = ( 0 > b ) ? 0 : b - 1 ; int high_@@ row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ; int high_@@ column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ; while ( ( low_@@ row > 0 - r && low_@@ column > 0 - c ) ) { for ( i = low_@@ column + 1 ; i <= high_@@ column && i < c && low_@@ row >= 0 ; ++ i ) System . out . print ( mat [ low_@@ row ] [ i ] + " ▁ " ) ; low_@@ row -= 1 ; for ( i = low_@@ row + 2 ; i <= high_@@ row && i < r && high_@@ column < c ; ++ i ) System . out . print ( mat [ i ] [ high_@@ column ] + " ▁ " ) ; high_@@ column += 1 ; for ( i = high_@@ column - 2 ; i >= low_@@ column && i >= 0 && high_@@ row < r ; -- i ) System . out . print ( mat [ high_@@ row ] [ i ] + " ▁ " ) ; high_@@ row += 1 ; for ( i = high_@@ row - 2 ; i > low_@@ row && i >= 0 && low_@@ column >= 0 ; -- i ) System . out . print ( mat [ i ] [ low_@@ column ] + " ▁ " ) ; low_@@ column -= 1 ; } System . out . println ( ) ; }
M@@ ID_@@ POINT_@@ CI@@ R@@ CLE_@@ DRAWIN@@ G_@@ ALGORITH@@ M | static void mid@@ Point@@ Circle@@ Draw ( int x_@@ centre , int y_@@ centre , int r ) { int x = r , y = 0 ; System . out . print ( " ( " + ( x + x_@@ centre ) + " , ▁ " + ( y + y_@@ centre ) + " ) " ) ; if ( r > 0 ) { System . out . print ( " ( " + ( x + x_@@ centre ) + " , ▁ " + ( - y + y_@@ centre ) + " ) " ) ; System . out . print ( " ( " + ( y + x_@@ centre ) + " , ▁ " + ( x + y_@@ centre ) + " ) " ) ; System . out . println ( " ( " + ( - y + x_@@ centre ) + " , ▁ " + ( x + y_@@ centre ) + " ) " ) ; } int P = 1 - r ; while ( x > y ) { y ++ ; if ( P <= 0 ) P = P + 2 * y + 1 ; else { x -- ; P = P + 2 * y - 2 * x + 1 ; } if ( x < y ) break ; System . out . print ( " ( " + ( x + x_@@ centre ) + " , ▁ " + ( y + y_@@ centre ) + " ) " ) ; System . out . print ( " ( " + ( - x + x_@@ centre ) + " , ▁ " + ( y + y_@@ centre ) + " ) " ) ; System . out . print ( " ( " + ( x + x_@@ centre ) + " , ▁ " + ( - y + y_@@ centre ) + " ) " ) ; System . out . println ( " ( " + ( - x + x_@@ centre ) + " , ▁ " + ( - y + y_@@ centre ) + " ) " ) ; if ( x != y ) { System . out . print ( " ( " + ( y + x_@@ centre ) + " , ▁ " + ( x + y_@@ centre ) + " ) " ) ; System . out . print ( " ( " + ( - y + x_@@ centre ) + " , ▁ " + ( x + y_@@ centre ) + " ) " ) ; System . out . print ( " ( " + ( y + x_@@ centre ) + " , ▁ " + ( - x + y_@@ centre ) + " ) " ) ; System . out . println ( " ( " + ( - y + x_@@ centre ) + " , ▁ " + ( - x + y_@@ centre ) + " ) " ) ; } } }
SM@@ ALLE@@ ST_@@ ELEMENT_@@ REPE@@ ATED_@@ EXAC@@ TL@@ Y_@@ K_@@ TIME@@ S_@@ NOT_@@ LIMI@@ TE@@ D_S@@ M@@ ALL_@@ RANGE | public static int smalle@@ st@@ K@@ Freq ( int a [ ] , int n , int k ) { HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( m . containsKey ( a [ i ] ) ) m . put ( a [ i ] , m . get ( a [ i ] ) + 1 ) ; else m . put ( a [ i ] , 1 ) ; int res = Integer . MAX_VALUE ; Set < Integer > s = m . keySet ( ) ; for ( int temp : s ) if ( m . get ( temp ) == k ) res = Math . min ( res , temp ) ; return ( res != Integer . MAX_VALUE ) ? res : - 1 ; }
MINIMUM_@@ X@@ OR_@@ VALUE_@@ PAIR | static int min@@ XOR ( int arr [ ] , int n ) { int min_@@ xor = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) min_@@ xor = Math . min ( min_@@ xor , arr [ i ] ^ arr [ j ] ) ; return min_@@ xor ; }
MIRR@@ OR_@@ CHARAC@@ TER@@ S_@@ STRING | static String compute ( String str , int n ) { String reverse@@ Alphabet = " zy@@ x@@ w@@ v@@ ut@@ sr@@ qp@@ on@@ ml@@ k@@ ji@@ hg@@ fed@@ cb@@ a " ; int l = str . length ( ) ; String answer = " " ; for ( int i = 0 ; i < n ; i ++ ) answer = answer + str . charAt ( i ) ; for ( int i = n ; i < l ; i ++ ) answer = answer + reverse@@ Alphabet . charAt ( str . charAt ( i ) - ' a ' ) ; return answer ; }
PROGRAM_@@ CHECK_@@ PL@@ US_@@ PER@@ F@@ ECT_@@ NUMBER | static boolean check@@ plu@@ sper@@ f@@ ect ( int x ) { int temp = x ; int n = 0 ; while ( x != 0 ) { x /= 10 ; n ++ ; } x = temp ; int sum = 0 ; while ( x != 0 ) { sum += Math . pow ( x % 10 , n ) ; x /= 10 ; } return ( sum == temp ) ; }
AR@@ C_@@ LENGTH_@@ ANGLE | static double arc@@ Length ( double diameter , double angle ) { double pi = 2@@ 2.0 / 7.0 ; double arc ; if ( angle >= 360 ) { System . out . println ( " Angle ▁ cannot " + " ▁ be ▁ formed " ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 36@@ 0.0 ) ; return arc ; } }
FIND_@@ LAST_@@ INDEX_@@ CHARACTER_@@ STRING | static int find@@ Last@@ Index ( String str , Character x ) { int index = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) == x ) index = i ; return index ; }
COUNT_@@ TRAI@@ LING_@@ ZER@@ O@@ ES_@@ FAC@@ TOR@@ I@@ AL_@@ NUMBER | static int find@@ Trailing@@ Zeros ( int n ) { int count = 0 ; for ( int i = 5 ; n / i >= 1 ; i *= 5 ) count += n / i ; return count ; }
ROTA@@ TE_@@ MATRIX_@@ 18@@ 0_@@ DEGRE@@ E | static void rotate@@ Matrix ( int mat [ ] [ ] ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = N - 1 ; j >= 0 ; j -- ) System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } }
S@@ UM_@@ FI@@ BON@@ ACC@@ I_@@ NUMB@@ ERS | static int calculate@@ Sum ( int n ) { if ( n <= 0 ) return 0 ; int fi@@ bo [ ] = new int [ n + 1 ] ; fi@@ bo [ 0 ] = 0 ; fi@@ bo [ 1 ] = 1 ; int sum = fi@@ bo [ 0 ] + fi@@ bo [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { fi@@ bo [ i ] = fi@@ bo [ i - 1 ] + fi@@ bo [ i - 2 ] ; sum += fi@@ bo [ i ] ; } return sum ; }
LAR@@ GE@@ ST_@@ LE@@ XI@@ CO@@ GRAP@@ HI@@ C_@@ ARRAY_@@ WITH_@@ AT_@@ MO@@ ST_@@ K_@@ CON@@ SEC@@ UTI@@ VE_@@ SWAP@@ S | static void K@@ Swap@@ Maximum ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int index@@ Position = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( k <= j - i ) break ; if ( arr [ j ] > arr [ index@@ Position ] ) index@@ Position = j ; } for ( int j = index@@ Position ; j > i ; -- j ) Swap@@ Ints ( arr , j , j - 1 ) ; k -= index@@ Position - i ; } }
FIND_@@ WHE@@ THER_@@ GI@@ V@@ EN_@@ INTEGER_@@ POWER_@@ 3_@@ NOT | static boolean check ( int n ) { return 11@@ 6@@ 22@@ 614@@ 67 % n == 0 ; }
FIND_@@ THE_@@ TWO_@@ REPE@@ ATING_@@ ELEMEN@@ TS_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY | void print@@ Repe@@ ating ( int arr [ ] , int size ) { int i , j ; System . out . println ( " Repe@@ ated ▁ Elements ▁ are ▁ : " ) ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) System . out . print ( arr [ i ] + " ▁ " ) ; } } }
C_@@ PROGRAM_@@ FIND_@@ AREA_@@ TRI@@ ANGLE | static float find@@ Area ( float a , float b , float c ) { if ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || a + c <= b || b + c <= a ) { System . out . println ( " Not ▁ a ▁ valid ▁ triangle " ) ; System . exit ( 0 ) ; } float s = ( a + b + c ) / 2 ; return ( float ) Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; }
GI@@ V@@ EN_@@ LARGE_@@ NUMBER_@@ CHECK@@ _SUB@@ SEQU@@ ENCE_@@ DIG@@ IT@@ S_@@ DI@@ VISI@@ BLE_@@ 8_@@ 1 | static boolean isSub@@ Seq@@ Di@@ visible ( String str ) { int n = str . length ( ) ; int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ; int arr [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = ( int ) ( str . charAt ( i - 1 ) - '0' ) ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i ] % 8 ] = 1 ; for ( int j = 0 ; j < 8 ; j ++ ) { if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] ; if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( dp [ i ] [ 0 ] == 1 ) return true ; } return false ; }
DELETE_@@ ARRAY_@@ ELEMEN@@ TS_@@ WHI@@ CH_@@ ARE_@@ SM@@ ALL@@ ER_@@ TH@@ AN_@@ NEXT_@@ OR_@@ BE@@ COM@@ E_@@ SMAL@@ LER | static void delete@@ Elements ( int arr [ ] , int n , int k ) { Stack < Integer > s = new Stack < > ( ) ; s . push ( arr [ 0 ] ) ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { while ( ! s . empty ( ) && s . peek ( ) < arr [ i ] && count < k ) { s . pop ( ) ; count ++ ; } s . push ( arr [ i ] ) ; } int m = s . size ( ) ; Integer [ ] v = new Integer [ m ] ; while ( ! s . empty ( ) ) { v [ -- m ] = s . peek ( ) ; s . pop ( ) ; } for ( Integer x : v ) { System . out . print ( x + " ▁ " ) ; } ; System . out . println ( " " ) ; }
MINIMUM_@@ LENGTH@@ _SUB@@ ARRA@@ Y_S@@ UM_@@ GREATER_@@ GI@@ V@@ EN_@@ VALUE | static int smalle@@ st@@ Sub@@ With@@ Sum ( int arr [ ] , int n , int x ) { int curr_@@ sum = 0 , min_@@ len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_@@ sum <= x && end < n ) curr_@@ sum += arr [ end ++ ] ; while ( curr_@@ sum > x && start < n ) { if ( end - start < min_@@ len ) min_@@ len = end - start ; curr_@@ sum -= arr [ start ++ ] ; } } return min_@@ len ; }
FIND_@@ PAIR@@ S_IN_@@ ARRAY_@@ WHO@@ SE_@@ SUM@@ S_@@ ALREADY_@@ EXI@@ ST_@@ IN_@@ ARRAY_@@ 1 | public static void find@@ Pair ( int [ ] arr , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( Integer i : arr ) { s . add ( i ) ; } boolean found = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( s . contains ( sum ) ) { found = true ; System . out . println ( arr [ i ] + " ▁ " + arr [ j ] ) ; } } } if ( found == false ) System . out . println ( " Not ▁ Exist ▁ " ) ; }
COUNT_@@ ARI@@ TH@@ ME@@ TIC_@@ PROG@@ RES@@ SION@@ _SUB@@ SEQU@@ EN@@ CES_@@ ARRAY | static int nu@@ mo@@ f@@ AP ( int a [ ] , int n ) { int min@@ arr = + 2147483647 ; int max@@ arr = - 214748364@@ 8 ; for ( int i = 0 ; i < n ; i ++ ) { min@@ arr = Math . min ( min@@ arr , a [ i ] ) ; max@@ arr = Math . max ( max@@ arr , a [ i ] ) ; } int dp [ ] = new int [ n ] ; int sum [ ] = new int [ MAX ] ; int ans = n + 1 ; for ( int d = ( min@@ arr - max@@ arr ) ; d <= ( max@@ arr - min@@ arr ) ; d ++ ) { Arrays . fill ( sum , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 1 ; if ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) dp [ i ] += sum [ a [ i ] - d ] ; ans += dp [ i ] - 1 ; sum [ a [ i ] ] += dp [ i ] ; } } return ans ; }
COUNT_@@ NUMB@@ ERS_@@ TH@@ AT_@@ DONT_@@ CONTA@@ IN_@@ 3 | static int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int ms@@ d = n / po ; if ( ms@@ d != 3 ) return count ( ms@@ d ) * count ( po - 1 ) + count ( ms@@ d ) + count ( n % po ) ; else return count ( ms@@ d * po - 1 ) ; }
PROGRAM_@@ TO_@@ FIND_@@ TRANSP@@ OS@@ E_@@ OF_@@ A_@@ MATRIX_@@ 2 | static void transpose ( int A [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) { int temp = A [ i ] [ j ] ; A [ i ] [ j ] = A [ j ] [ i ] ; A [ j ] [ i ] = temp ; } }
S@@ UM_@@ DIAG@@ ON@@ AL@@ S@@ _SP@@ IR@@ AL_@@ OD@@ D_@@ ORDER@@ _S@@ QU@@ ARE_@@ MATRIX | static int spir@@ al@@ Di@@ a@@ Sum ( int n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spir@@ al@@ Di@@ a@@ Sum ( n - 2 ) ) ; }
COUNT_@@ IN@@ VERSION@@ S_@@ OF@@ _SIZE_@@ THRE@@ E_@@ IN_@@ A_@@ GI@@ VE_@@ ARRAY | int getIn@@ v@@ Count ( int arr [ ] , int n ) { int inv@@ count = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ j ] > arr [ k ] ) inv@@ count ++ ; } } } } return inv@@ count ; }
FIN@@ D_S@@ UM_@@ NODE@@ S_@@ GI@@ V@@ EN_@@ PER@@ F@@ ECT_@@ BINARY_@@ TREE | static int sum@@ Nodes ( int l ) { int leaf@@ Node@@ Count = ( int ) Math . pow ( 2 , l - 1 ) ; Vector < Vector < Integer > > vec = new Vector < Vector < Integer > > ( ) ; for ( int i = 1 ; i <= l ; i ++ ) vec . add ( new Vector < Integer > ( ) ) ; for ( int i = 1 ; i <= leaf@@ Node@@ Count ; i ++ ) vec . get ( l - 1 ) . add ( i ) ; for ( int i = l - 2 ; i >= 0 ; i -- ) { int k = 0 ; while ( k < vec . get ( i + 1 ) . size ( ) - 1 ) { vec . get ( i ) . add ( vec . get ( i + 1 ) . get ( k ) + vec . get ( i + 1 ) . get ( k + 1 ) ) ; k += 2 ; } } int sum = 0 ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = 0 ; j < vec . get ( i ) . size ( ) ; j ++ ) sum += vec . get ( i ) . get ( j ) ; } return sum ; }
S@@ UM_@@ OF_@@ ALL_@@ PRO@@ PER_@@ DI@@ VI@@ SOR@@ S_@@ OF_@@ A_@@ N@@ ATUR@@ AL_@@ NUMBER | static int div@@ Sum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; }
FIND_@@ A_@@ TR@@ IP@@ LET_@@ TH@@ AT_@@ S@@ UM_@@ TO_@@ A_@@ GI@@ V@@ EN_@@ VALUE_@@ 2 | static boolean find@@ 3@@ Numbers ( int A [ ] , int arr_@@ size , int sum ) { for ( int i = 0 ; i < arr_@@ size - 2 ; i ++ ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; int curr_@@ sum = sum - A [ i ] ; for ( int j = i + 1 ; j < arr_@@ size ; j ++ ) { if ( s . contains ( curr_@@ sum - A [ j ] ) && curr_@@ sum - A [ j ] != ( int ) s . toArray ( ) [ s . size ( ) - 1 ] ) { System . out . printf ( " Trip@@ let ▁ is ▁ % d , ▁ % d , ▁ % d " , A [ i ] , A [ j ] , curr_@@ sum - A [ j ] ) ; return true ; } s . add ( A [ j ] ) ; } } return false ; }
N@@ TH_@@ EV@@ EN_@@ LENGTH_@@ PA@@ LIN@@ DRO@@ ME | static String even@@ length ( String n ) { String res = n ; for ( int j = n . length ( ) - 1 ; j >= 0 ; -- j ) res += n . charAt ( j ) ; return res ; }
FIN@@ DING_@@ POWER_@@ PRI@@ ME_@@ NUMBER_@@ P_@@ N | static int Power@@ OFP@@ IN@@ n@@ factorial ( int n , int p ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int count = 0 , temp = i ; while ( temp % p == 0 ) { count ++ ; temp = temp / p ; } ans += count ; } return ans ; }
MINIMUM_@@ CO@@ ST_@@ MAKE_@@ LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ SEQU@@ ENCE_@@ LENGTH_@@ K | static int solve ( char X [ ] , char Y [ ] , int l , int r , int k , int dp [ ] [ ] [ ] ) { if ( k == 0 ) { return 0 ; } if ( l < 0 | r < 0 ) { return ( int ) 1e@@ 9 ; } if ( dp [ l ] [ r ] [ k ] != - 1 ) { return dp [ l ] [ r ] [ k ] ; } int cost = ( X [ l ] - ' a ' ) ^ ( Y [ r ] - ' a ' ) ; return dp [ l ] [ r ] [ k ] = Math . min ( Math . min ( cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) ) , solve ( X , Y , l , r - 1 , k , dp ) ) ; }
PRINT_@@ STRING@@ _SPECI@@ FI@@ ED_@@ CHARACTER_@@ OC@@ CUR@@ RED_@@ GI@@ V@@ EN_@@ NO_@@ TIMES | static void print@@ String ( String str , char ch , int count ) { int oc@@ c = 0 , i ; if ( count == 0 ) { System . out . println ( str ) ; return ; } for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ch ) oc@@ c ++ ; if ( oc@@ c == count ) break ; } if ( i < str . length ( ) - 1 ) System . out . println ( str . substring ( i + 1 ) ) ; else System . out . println ( " Empty ▁ string " ) ; }
SORT_@@ 1_@@ N@@ _SW@@ APP@@ ING_@@ AD@@ J@@ AC@@ ENT_@@ ELEMENTS | static boolean sorted@@ After@@ Swap ( int A [ ] , boolean B [ ] , int n ) { int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { j = i ; while ( B [ j ] ) { j ++ ; } Arrays . sort ( A , i , 1 + j ) ; i = j ; } } for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) { return false ; } } return true ; }
GENERATE_@@ PYTH@@ AG@@ O@@ RE@@ AN_@@ TR@@ IP@@ LET@@ S | static void py@@ th@@ ag@@ ore@@ an@@ Trip@@ lets ( int limit ) { int a , b , c = 0 ; int m = 2 ; while ( c < limit ) { for ( int n = 1 ; n < m ; ++ n ) { a = m * m - n * n ; b = 2 * m * n ; c = m * m + n * n ; if ( c > limit ) break ; System . out . println ( a + " ▁ " + b + " ▁ " + c ) ; } m ++ ; } }
COUNT_@@ EV@@ EN_@@ LENGTH_@@ BIN@@ AR@@ Y@@ _SEQU@@ EN@@ CES_@@ WITH@@ _S@@ AME_@@ S@@ UM_@@ OF_@@ FIRST_@@ AND@@ _SECON@@ D_@@ HALF_@@ BITS | static int count@@ Seq ( int n , int diff ) { if ( Math . abs ( diff ) > n ) return 0 ; if ( n == 1 && diff == 0 ) return 2 ; if ( n == 1 && Math . abs ( diff ) == 1 ) return 1 ; int res = count@@ Seq ( n - 1 , diff + 1 ) + 2 * count@@ Seq ( n - 1 , diff ) + count@@ Seq ( n - 1 , diff - 1 ) ; return res ; }
POSSI@@ BLE_@@ FORM_@@ TRIANGLE_@@ ARRAY_@@ VALUES | static boolean is@@ Possible@@ Triangle ( int [ ] arr , int N ) { if ( N < 3 ) return false ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < N - 2 ; i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) return true ; return false ; }
PRINT_@@ ARRAY_@@ STRING@@ S_S@@ OR@@ TED_@@ ORDER_@@ WITH@@ OUT_@@ COPY@@ ING_@@ ONE_@@ STRING_@@ AN@@ OTHER | static void print@@ In@@ Sorted@@ Order ( String arr [ ] , int n ) { int index [ ] = new int [ n ] ; int i , j , min ; for ( i = 0 ; i < n ; i ++ ) { index [ i ] = i ; } for ( i = 0 ; i < n - 1 ; i ++ ) { min = i ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ index [ min ] ] . compareTo ( arr [ index [ j ] ] ) > 0 ) { min = j ; } } if ( min != i ) { int temp = index [ min ] ; index [ min ] = index [ i ] ; index [ i ] = temp ; } } for ( i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ index [ i ] ] + " ▁ " ) ; } }
GAME_@@ REPL@@ AC@@ ING_@@ ARRAY_@@ ELEMENTS | public static int play@@ Game ( int arr [ ] ) { HashSet < Integer > set = new HashSet < > ( ) ; for ( int i : arr ) set . add ( i ) ; return ( set . size ( ) % 2 == 0 ) ? 1 : 2 ; }
BASIC_@@ AND_@@ EXTENDED_@@ EUC@@ LI@@ DE@@ AN_@@ ALGORITH@@ MS | public static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
SORT_@@ ARRAY_@@ WAVE_@@ FORM_@@ 2_1 | void sort@@ In@@ Wave ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i += 2 ) { if ( i > 0 && arr [ i - 1 ] > arr [ i ] ) swap ( arr , i - 1 , i ) ; if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) swap ( arr , i , i + 1 ) ; } }
MAX@@ IM@@ UM@@ _SUB@@ ARRA@@ Y_S@@ UM_@@ USING_@@ PRE@@ FIX@@ _S@@ UM | static int maximum@@ Sum@@ Sub@@ array ( int arr [ ] , int n ) { int min_@@ prefix_@@ sum = 0 ; int res = Integer . MIN_VALUE ; int prefix_@@ sum [ ] = new int [ n ] ; prefix_@@ sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_@@ sum [ i ] = prefix_@@ sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { res = Math . max ( res , prefix_@@ sum [ i ] - min_@@ prefix_@@ sum ) ; min_@@ prefix_@@ sum = Math . min ( min_@@ prefix_@@ sum , prefix_@@ sum [ i ] ) ; } return res ; }
STRING_@@ CONTAIN@@ ING_@@ FIRST_@@ LET@@ TER_@@ EVER@@ Y_@@ WORD_@@ GI@@ V@@ EN_@@ STRING@@ _SPAC@@ ES | static String first@@ Letter@@ Word ( String str ) { String result = " " ; boolean v = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' ▁ ' ) { v = true ; } else if ( str . charAt ( i ) != ' ▁ ' && v == true ) { result += ( str . charAt ( i ) ) ; v = false ; } } return result ; }
S@@ UM_@@ PAIR@@ WI@@ SE_@@ PRODUC@@ TS_@@ 1 | static int find@@ Sum ( int n ) { int multi@@ Terms = n * ( n + 1 ) / 2 ; int sum = multi@@ Terms ; for ( int i = 2 ; i <= n ; i ++ ) { multi@@ Terms = multi@@ Terms - ( i - 1 ) ; sum = sum + multi@@ Terms * i ; } return sum ; }
CLU@@ STER@@ ING@@ PARTI@@ TION@@ ING_@@ AN_@@ ARRAY@@ _SU@@ CH_@@ TH@@ AT_@@ S@@ UM_@@ OF@@ _S@@ QU@@ ARE_@@ DIFF@@ ER@@ EN@@ CES_@@ IS_@@ MIN@@ IM@@ UM@@ _1 | static int min@@ Cost ( int a [ ] , int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= k ; j ++ ) dp [ i ] [ j ] = inf ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) for ( int m = i - 1 ; m >= 0 ; m -- ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; return dp [ n ] [ k ] ; }
LE@@ IB@@ NI@@ Z_@@ HAR@@ MON@@ IC_@@ TRI@@ ANGLE | static void Le@@ ib@@ n@@ iz@@ Harmon@@ ic@@ Triangle ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) System . out . print ( "1 / " + i * C [ i - 1 ] [ j - 1 ] + " ▁ " ) ; System . out . println ( ) ; } }
CHECK_@@ WHE@@ THER@@ _SECON@@ D_@@ STRING_@@ CAN_@@ FOR@@ MED_@@ FIRST_@@ STRING_@@ USING_@@ COUNT_@@ ARRAY | static boolean can@@ Make@@ Str@@ 2 ( String str1 , String str2 ) { int [ ] count = new int [ MAX ] ; char [ ] str@@ 3 = str1 . toCharArray ( ) ; for ( int i = 0 ; i < str@@ 3 . length ; i ++ ) count [ str@@ 3 [ i ] ] ++ ; char [ ] str@@ 4 = str2 . toCharArray ( ) ; for ( int i = 0 ; i < str@@ 4 . length ; i ++ ) { if ( count [ str@@ 4 [ i ] ] == 0 ) return false ; count [ str@@ 4 [ i ] ] -- ; } return true ; }
S@@ UM_@@ MINIMUM_@@ MAXIMUM_@@ ELEMEN@@ TS@@ _SUB@@ ARRAY@@ S@@ _SIZE_@@ K | public static int Sum@@ Of@@ K@@ sub@@ Array ( int arr [ ] , int k ) { int sum = 0 ; Deque < Integer > S = new LinkedList < > ( ) , G = new LinkedList < > ( ) ; int i = 0 ; for ( i = 0 ; i < k ; i ++ ) { while ( ! S . isEmpty ( ) && arr [ S . peek@@ Last ( ) ] >= arr [ i ] ) S . remove@@ Last ( ) ; while ( ! G . isEmpty ( ) && arr [ G . peek@@ Last ( ) ] <= arr [ i ] ) G . remove@@ Last ( ) ; G . addLast ( i ) ; S . addLast ( i ) ; } for ( ; i < arr . length ; i ++ ) { sum += arr [ S . peek@@ First ( ) ] + arr [ G . peek@@ First ( ) ] ; while ( ! S . isEmpty ( ) && S . peek@@ First ( ) <= i - k ) S . remove@@ First ( ) ; while ( ! G . isEmpty ( ) && G . peek@@ First ( ) <= i - k ) G . remove@@ First ( ) ; while ( ! S . isEmpty ( ) && arr [ S . peek@@ Last ( ) ] >= arr [ i ] ) S . remove@@ Last ( ) ; while ( ! G . isEmpty ( ) && arr [ G . peek@@ Last ( ) ] <= arr [ i ] ) G . remove@@ Last ( ) ; G . addLast ( i ) ; S . addLast ( i ) ; } sum += arr [ S . peek@@ First ( ) ] + arr [ G . peek@@ First ( ) ] ; return sum ; }
LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ SEQUENCE | int l@@ cs ( char [ ] X , char [ ] Y , int m , int n ) { if ( m == 0 || n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + l@@ cs ( X , Y , m - 1 , n - 1 ) ; else return max ( l@@ cs ( X , Y , m , n - 1 ) , l@@ cs ( X , Y , m - 1 , n ) ) ; }
MIN@@ IM@@ UM@@ _S@@ UM_@@ ABSOL@@ UTE_@@ DIFF@@ ER@@ ENCE_@@ PAIR@@ S_@@ TWO_@@ ARRAY@@ S | static long find@@ Min@@ Sum ( long a [ ] , long b [ ] , long n ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + Math . abs ( a [ i ] - b [ i ] ) ; return sum ; }
COUNT_@@ DISTIN@@ CT_@@ NON_@@ NEGATIVE_@@ PAIR@@ S_@@ X_@@ Y_S@@ ATI@@ SF@@ Y_@@ IN@@ EQU@@ ALI@@ TY_@@ X@@ X_@@ YY_@@ N_@@ 2 | static int count@@ Solutions ( int n ) { int res = 0 ; for ( int x = 0 ; x * x < n ; x ++ ) for ( int y = 0 ; x * x + y * y < n ; y ++ ) res ++ ; return res ; }
FIND_@@ NUMBER_@@ TRANS@@ FORMA@@ TION_@@ MAKE_@@ TWO_@@ MATRIX_@@ EQUAL | static int count@@ Ops ( int A [ ] [ ] , int B [ ] [ ] , int m , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) A [ i ] [ j ] -= B [ i ] [ j ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 1 ; j < m ; j ++ ) if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) return - 1 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += Math . abs ( A [ i ] [ 0 ] ) ; for ( int j = 0 ; j < m ; j ++ ) result += Math . abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) ; return ( result ) ; }
EF@@ FI@@ CI@@ EN@@ TL@@ Y_@@ FIND_@@ FIRST_@@ REPE@@ ATED_@@ CHARACTER_@@ STRING_@@ WITH@@ OUT_@@ USING_@@ ADDI@@ TIONAL_@@ DATA_@@ STRUC@@ TURE_@@ ONE_@@ TRA@@ VERS@@ AL | static int First@@ Repe@@ ated ( String str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str . charAt ( i ) - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; }
MAXIMUM_@@ UNI@@ QUE_@@ ELEMENT_@@ EVER@@ Y@@ _SUB@@ ARRAY@@ _SIZE_@@ K | static void find_@@ max ( int [ ] A , int N , int K ) { HashMap < Integer , Integer > Count = new HashMap < > ( ) ; for ( int i = 0 ; i < K - 1 ; i ++ ) if ( Count . containsKey ( A [ i ] ) ) Count . put ( A [ i ] , 1 + Count . get ( A [ i ] ) ) ; else Count . put ( A [ i ] , 1 ) ; TreeSet < Integer > My@@ set = new TreeSet < Integer > ( ) ; for ( Map . Entry x : Count . entrySet ( ) ) { if ( Integer . parseInt ( String . valueOf ( x . getValue ( ) ) ) == 1 ) My@@ set . add ( Integer . parseInt ( String . valueOf ( x . getKey ( ) ) ) ) ; } for ( int i = K - 1 ; i < N ; i ++ ) { if ( Count . containsKey ( A [ i ] ) ) Count . put ( A [ i ] , 1 + Count . get ( A [ i ] ) ) ; else Count . put ( A [ i ] , 1 ) ; if ( Integer . parseInt ( String . valueOf ( Count . get ( A [ i ] ) ) ) == 1 ) My@@ set . add ( A [ i ] ) ; else My@@ set . remove ( A [ i ] ) ; if ( My@@ set . size ( ) == 0 ) System . out . println ( " Nothing " ) ; else System . out . println ( My@@ set . last ( ) ) ; int x = A [ i - K + 1 ] ; Count . put ( x , Count . get ( x ) - 1 ) ; if ( Integer . parseInt ( String . valueOf ( Count . get ( x ) ) ) == 1 ) My@@ set . add ( x ) ; if ( Integer . parseInt ( String . valueOf ( Count . get ( x ) ) ) == 0 ) My@@ set . remove ( x ) ; } }
MINIMUM_@@ CO@@ ST@@ _S@@ ORT_@@ MATRIX_@@ NUMB@@ ERS_@@ 0_@@ N@@ 2_1 | public static int calculate@@ Energy ( int mat [ ] [ ] , int n ) { int i_@@ des , j_@@ des , q ; int tot_@@ energy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { q = mat [ i ] [ j ] / n ; i_@@ des = q ; j_@@ des = mat [ i ] [ j ] - ( n * q ) ; tot_@@ energy += Math . abs ( i_@@ des - i ) + Math . abs ( j_@@ des - j ) ; } } return tot_@@ energy ; }
LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ STRING | static int LC@@ Sub@@ Str ( char X [ ] , char Y [ ] , int m , int n ) { int LC@@ Stuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) LC@@ Stuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LC@@ Stuff [ i ] [ j ] = LC@@ Stuff [ i - 1 ] [ j - 1 ] + 1 ; result = Integer . max ( result , LC@@ Stuff [ i ] [ j ] ) ; } else LC@@ Stuff [ i ] [ j ] = 0 ; } } return result ; }
MAX@@ IM@@ UM@@ _S@@ UM_@@ BIT@@ ON@@ IC@@ _SUB@@ ARRAY | static int max@@ Sum@@ Bit@@ on@@ ic@@ Sub@@ Arr ( int arr [ ] , int n ) { int [ ] m@@ sis = new int [ n ] ; int [ ] ms@@ ds = new int [ n ] ; int max_@@ sum = Integer . MIN_VALUE ; m@@ sis [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) m@@ sis [ i ] = m@@ sis [ i - 1 ] + arr [ i ] ; else m@@ sis [ i ] = arr [ i ] ; ms@@ ds [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) ms@@ ds [ i ] = ms@@ ds [ i + 1 ] + arr [ i ] ; else ms@@ ds [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( max_@@ sum < ( m@@ sis [ i ] + ms@@ ds [ i ] - arr [ i ] ) ) max_@@ sum = m@@ sis [ i ] + ms@@ ds [ i ] - arr [ i ] ; return max_@@ sum ; }
NEW@@ MAN_@@ CON@@ WAY@@ _SEQU@@ ENCE | static int sequence ( int n ) { if ( n == 1 || n == 2 ) return 1 ; else return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ; }
PRINT_@@ TR@@ IP@@ LET@@ S_S@@ OR@@ TED_@@ ARRAY_@@ FORM_@@ AP | static void print@@ All@@ AP@@ Trip@@ lets ( int [ ] arr , int n ) { ArrayList < Integer > s = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; boolean exists = s . contains ( arr [ i ] - diff ) ; if ( exists ) System . out . println ( arr [ i ] - diff + " ▁ " + arr [ i ] + " ▁ " + arr [ j ] ) ; } s . add ( arr [ i ] ) ; } }
QUER@@ I@@ ES_@@ COUN@@ TS_@@ ARRAY_@@ ELEMEN@@ TS_@@ VALU@@ ES_@@ GI@@ V@@ EN_@@ RANGE | static int count@@ InRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; }
HIGH@@ WA@@ Y_@@ B@@ IL@@ L@@ BOARD_@@ PRO@@ BLE@@ M | static int max@@ Re@@ venue ( int m , int [ ] x , int [ ] re@@ venue , int n , int t ) { int [ ] max@@ Rev = new int [ m + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) max@@ Rev [ i ] = 0 ; int nx@@ tbb = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( nx@@ tbb < n ) { if ( x [ nx@@ tbb ] != i ) max@@ Rev [ i ] = max@@ Rev [ i - 1 ] ; else { if ( i <= t ) max@@ Rev [ i ] = Math . max ( max@@ Rev [ i - 1 ] , re@@ venue [ nx@@ tbb ] ) ; else max@@ Rev [ i ] = Math . max ( max@@ Rev [ i - t - 1 ] + re@@ venue [ nx@@ tbb ] , max@@ Rev [ i - 1 ] ) ; nx@@ tbb ++ ; } } else max@@ Rev [ i ] = max@@ Rev [ i - 1 ] ; } return max@@ Rev [ m ] ; }
CONSTRUC@@ T_@@ GRAPH_@@ GI@@ V@@ EN_@@ DEGRE@@ ES_@@ VER@@ TIC@@ ES | static void print@@ Mat ( int deg@@ seq [ ] , int n ) { int [ ] [ ] mat = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( deg@@ seq [ i ] > 0 && deg@@ seq [ j ] > 0 ) { deg@@ seq [ i ] -- ; deg@@ seq [ j ] -- ; mat [ i ] [ j ] = 1 ; mat [ j ] [ i ] = 1 ; } } } System . out . print ( " \n " + setw ( 3 ) + " ▁ ▁ ▁ ▁ ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( setw ( 3 ) + " ( " + i + " ) " ) ; System . out . print ( " \n \n " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( setw ( 4 ) + " ( " + i + " ) " ) ; for ( int j = 0 ; j < n ; j ++ ) System . out . print ( setw ( 5 ) + mat [ i ] [ j ] ) ; System . out . print ( " \n " ) ; } }
DETE@@ CT_@@ IF_@@ TWO_@@ INTEG@@ ERS_@@ HAVE_@@ OP@@ POSI@@ TE_@@ SIGN@@ S | static boolean opposi@@ te@@ Sig@@ ns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; }
TRIANG@@ ULAR_@@ NUMB@@ ERS_@@ 1 | static boolean is@@ Tri@@ angular ( int num ) { if ( num < 0 ) return false ; int c = ( - 2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; float roo@@ t1 = ( - b + ( float ) Math . sqrt ( d ) ) / ( 2 * a ) ; float root@@ 2 = ( - b - ( float ) Math . sqrt ( d ) ) / ( 2 * a ) ; if ( roo@@ t1 > 0 && Math . floor ( roo@@ t1 ) == roo@@ t1 ) return true ; if ( root@@ 2 > 0 && Math . floor ( root@@ 2 ) == root@@ 2 ) return true ; return false ; }
FIND_@@ WHE@@ THER_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ IS_@@ A_@@ POWER_@@ OF_@@ 4_@@ OR_@@ NOT | static int is@@ PowerOf@@ Four ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 4 != 0 ) return 0 ; n = n / 4 ; } return 1 ; }
LAST_@@ NON_@@ ZERO_@@ DIG@@ IT_@@ FAC@@ TOR@@ I@@ AL | static int last@@ Non@@ 0@@ Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * last@@ Non@@ 0@@ Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * last@@ Non@@ 0@@ Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; }
SORT_@@ STRING_@@ AC@@ COR@@ DING_@@ ORDER_@@ DEFINED_@@ AN@@ OTHER_@@ STRING | static void sort@@ By@@ Pattern ( char [ ] str , char [ ] pat ) { int count [ ] = new int [ MAX_@@ CHAR ] ; for ( int i = 0 ; i < str . length ; i ++ ) { count [ str [ i ] - ' a ' ] ++ ; } int index = 0 ; for ( int i = 0 ; i < pat . length ; i ++ ) { for ( int j = 0 ; j < count [ pat [ i ] - ' a ' ] ; j ++ ) { str [ index ++ ] = pat [ i ] ; } } }
NUMBER_@@ VISI@@ BLE_@@ BOX@@ ES_@@ PUT@@ TING_@@ ONE_@@ IN@@ SIDE_@@ AN@@ OTHER | static int minimum@@ Box ( int [ ] arr , int n ) { Queue < Integer > q = new LinkedList < > ( ) ; Arrays . sort ( arr ) ; q . add ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q . element ( ) ; if ( arr [ i ] >= 2 * now ) q . remove ( ) ; q . add ( arr [ i ] ) ; } return q . size ( ) ; }
SEARCH_@@ INSERT_@@ AND_@@ DELETE_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY | static int binary@@ Search ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binary@@ Search ( arr , ( mid + 1 ) , high , key ) ; return binary@@ Search ( arr , low , ( mid - 1 ) , key ) ; }
FIND_@@ THE_@@ TWO_@@ REPE@@ ATING_@@ ELEMEN@@ TS_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ 3 | void print@@ Repe@@ ating ( int arr [ ] , int size ) { int i ; System . out . println ( " The ▁ repe@@ ating ▁ elements ▁ are ▁ : ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ Math . abs ( arr [ i ] ) ] > 0 ) arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ; else System . out . print ( Math . abs ( arr [ i ] ) + " ▁ " ) ; } }
COUNT_@@ POSSI@@ BLE_@@ GROUP@@ S@@ _SIZE_@@ 2_@@ 3@@ _S@@ UM_@@ MULTIPLE_@@ 3 | int find@@ groups ( int arr [ ] , int n ) { int c [ ] = new int [ ] { 0 , 0 , 0 } ; int i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) > > 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }
PRINT_@@ STRING_@@ IGNOR@@ ING_@@ ALTER@@ N@@ ATE_@@ OC@@ CURR@@ EN@@ CES_@@ CHARACTER | static void print@@ String@@ Altern@@ ate ( String str ) { int [ ] oc@@ c = new int [ 122 ] ; String s = str . toLowerCase ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char temp = s . charAt ( i ) ; oc@@ c [ temp ] ++ ; if ( oc@@ c [ temp ] % 2 != 0 ) System . out . print ( str . charAt ( i ) ) ; } System . out . println ( ) ; }
NUMBER_@@ DAY@@ S_@@ TAN@@ K_@@ WI@@ LL_@@ BE@@ COM@@ E_@@ EMPTY | static int min@@ Day@@ sTo@@ Empty ( int C , int l ) { if ( l >= C ) return C ; double eq_@@ root = ( Math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return ( int ) ( Math . ceil ( eq_@@ root ) + l ) ; }
REVERSE_@@ STRING_@@ WITH@@ OUT_@@ USING_@@ ANY_@@ TEMPOR@@ ARY_@@ VARIABLE | static String rever@@ sing@@ String ( char [ ] str , int start , int end ) { while ( start < end ) { str [ start ] ^= str [ end ] ; str [ end ] ^= str [ start ] ; str [ start ] ^= str [ end ] ; ++ start ; -- end ; } return String . valueOf ( str ) ; }
FREQU@@ ENCY_@@ ELEMENT_@@ UN@@ SOR@@ TED_@@ ARRAY | static void count@@ Freq ( int [ ] a , int n ) { HashMap < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) hm . put ( a [ i ] , hm . get ( a [ i ] ) == null ? 1 : hm . get ( a [ i ] ) + 1 ) ; SortedMap < Integer , Integer > st = new TreeMap < > ( ) ; for ( HashMap . Entry < Integer , Integer > x : hm . entrySet ( ) ) { st . put ( x . getKey ( ) , x . getValue ( ) ) ; } int cum@@ ul = 0 ; for ( SortedMap . Entry < Integer , Integer > x : st . entrySet ( ) ) { cum@@ ul += x . getValue ( ) ; System . out . println ( x . getKey ( ) + " ▁ " + cum@@ ul ) ; } }
FIND_@@ ROTATION_@@ COUNT_@@ ROTA@@ TE@@ D_S@@ OR@@ TED_@@ ARRAY | static int count@@ Rot@@ ations ( int arr [ ] , int n ) { int min = arr [ 0 ] , min_@@ index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_@@ index = i ; } } return min_@@ index ; }
LON@@ GE@@ ST_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQU@@ ENCE_@@ 1 | static int lis ( int arr [ ] , int n ) { int lis [ ] = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return max ; }
MEDI@@ AN_@@ OF_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S | static int get@@ Medi@@ an ( int ar@@ 1 [ ] , int ar@@ 2 [ ] , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = - 1 , m2 = - 1 ; for ( count = 0 ; count <= n ; count ++ ) { if ( i == n ) { m1 = m2 ; m2 = ar@@ 2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar@@ 1 [ 0 ] ; break ; } if ( ar@@ 1 [ i ] < ar@@ 2 [ j ] ) { m1 = m2 ; m2 = ar@@ 1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = ar@@ 2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; }
LE@@ XI@@ CO@@ GRAPHIC@@ AL@@ LY_@@ MINIMUM_@@ STRING_@@ RO@@ TATION | static String min@@ Lex@@ Rotation ( String str ) { int n = str . length ( ) ; String arr [ ] = new String [ n ] ; String concat = str + str ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = concat . substring ( i , i + n ) ; } Arrays . sort ( arr ) ; return arr [ 0 ] ; }
INTER@@ PO@@ LA@@ TION@@ _SEARCH | static int interpol@@ ation@@ Search ( int x ) { int lo = 0 , hi = ( arr . length - 1 ) ; while ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { if ( lo == hi ) { if ( arr [ lo ] == x ) return lo ; return - 1 ; } int pos = lo + ( ( ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; if ( arr [ pos ] == x ) return pos ; if ( arr [ pos ] < x ) lo = pos + 1 ; else hi = pos - 1 ; } return - 1 ; }
COUNT_@@ PAIR@@ S_@@ TW@@ O@@ _S@@ OR@@ TED_@@ ARRAY@@ S_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL_@@ GI@@ V@@ EN_@@ VALUE_@@ X_@@ 2 | static int count@@ Pairs ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( ar@@ r1 [ l ] + ar@@ r2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( ar@@ r1 [ l ] + ar@@ r2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }
COUNT_@@ SUB@@ SE@@ TS_@@ DISTIN@@ CT_@@ EV@@ EN_@@ NUMB@@ ERS | static int count@@ Sub@@ sets ( int arr [ ] , int n ) { HashSet < Integer > us = new HashSet < > ( ) ; int ev@@ en_@@ count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) us . add ( arr [ i ] ) ; ev@@ en_@@ count = us . size ( ) ; return ( int ) ( Math . pow ( 2 , ev@@ en_@@ count ) - 1 ) ; }
COUNT_@@ NUMBER_OF_@@ OC@@ CURR@@ EN@@ CES_@@ OR_@@ FREQU@@ ENCY_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY | static int count@@ Occurren@@ ces ( int arr [ ] , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; }
CONSTRUC@@ T_@@ THE_@@ ROO@@ TED_@@ TREE_@@ BY_@@ USING_@@ START_@@ AND_@@ FINI@@ SH_@@ TIME_@@ OF_@@ IT@@ S_@@ DFS_@@ TRA@@ VERS@@ AL | static int [ ] Re@@ store_@@ Tree ( int [ ] S , int [ ] End ) { int [ ] Identity = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) Identity [ S [ i ] ] = i ; int [ ] parent = new int [ N ] ; Arrays . fill ( parent , - 1 ) ; int curr_@@ parent = Identity [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) { int child = Identity [ j ] ; if ( End [ child ] - j > 1 ) { parent [ child ] = curr_@@ parent ; curr_@@ parent = child ; } else { parent [ child ] = curr_@@ parent ; while ( parent [ child ] > - 1 && End [ child ] == End [ parent [ child ] ] ) { child = parent [ child ] ; curr_@@ parent = parent [ child ] ; if ( curr_@@ parent == Identity [ 0 ] ) break ; } } } for ( int i = 0 ; i < N ; i ++ ) parent [ i ] += 1 ; return parent ; }
NUMBER@@ _SUB@@ SEQU@@ EN@@ CES_@@ AB_@@ STRING_@@ REPE@@ ATED_@@ K_@@ TIMES | static int count@@ Occurren@@ ces ( String s , int K ) { int n = s . length ( ) ; int C = 0 , c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' a ' ) c1 ++ ; if ( s . charAt ( i ) == ' b ' ) { c2 ++ ; C += c1 ; } } return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ; }
NUMBER@@ _SUB@@ STRING@@ S_@@ STRING | static int count@@ Non@@ Empty@@ Sub@@ str ( String str ) { int n = str . length ( ) ; return n * ( n + 1 ) / 2 ; }
MAXIMUM_@@ NUMBER_@@ CHARAC@@ TER@@ S_@@ TWO_@@ CHARACTER_@@ STRING_@@ 1 | static int maximum@@ Chars ( String str ) { int n = str . length ( ) ; int res = - 1 ; int [ ] first@@ Ind = new int [ MAX_@@ CHAR ] ; for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) first@@ Ind [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_@@ ind = first@@ Ind [ str . charAt ( i ) ] ; if ( first_@@ ind == - 1 ) first@@ Ind [ str . charAt ( i ) ] = i ; else res = Math . max ( res , Math . abs ( i - first_@@ ind - 1 ) ) ; } return res ; }
SUM@@ _S@@ QUAR@@ ES_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENTS | static int su@@ mo@@ f@@ square ( int n ) { int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ; return sum ; }
PRINT_@@ POSSI@@ BLE_@@ STRING@@ S_@@ CAN_@@ MA@@ DE_@@ PL@@ AC@@ ING@@ _SPAC@@ ES_@@ 2 | static void print@@ Sub@@ sequences ( String s ) { char [ ] str = s . toCharArray ( ) ; int n = str . length ; int op@@ size = ( int ) ( Math . pow ( 2 , n - 1 ) ) ; for ( int counter = 0 ; counter < op@@ size ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( str [ j ] ) ; if ( ( counter & ( 1 << j ) ) > 0 ) System . out . print ( " ▁ " ) ; } System . out . println ( ) ; } }
NON_@@ REPE@@ ATING_@@ ELEMENT | static int first@@ Non@@ Repe@@ ating ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ; if ( j == n ) return arr [ i ] ; } return - 1 ; }
S@@ UM_@@ OF_@@ ALL_@@ ELEMEN@@ TS_@@ UP_@@ TO_@@ N@@ TH_@@ ROW_@@ IN_@@ A_@@ PAS@@ CAL@@ S_@@ TRI@@ ANGLE | static long calculate@@ Sum ( int n ) { long sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
CHECK_@@ TWO_@@ STRING@@ S_@@ K_@@ AN@@ AG@@ RAM@@ S_@@ NOT | static boolean are@@ k@@ An@@ agram@@ s ( String str1 , String str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int [ ] count@@ 1 = new int [ MAX_@@ CHAR ] ; int [ ] count2 = new int [ MAX_@@ CHAR ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) count@@ 1 [ str1 . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) count2 [ str2 . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) if ( count@@ 1 [ i ] > count2 [ i ] ) count = count + Math . abs ( count@@ 1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; }
LON@@ GE@@ ST@@ _SP@@ AN@@ _S@@ UM_@@ TWO_@@ BINARY_@@ ARRAY@@ S | static int lon@@ gest@@ Common@@ Sum ( int n ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum@@ 1 = 0 , sum@@ 2 = 0 ; for ( int j = i ; j < n ; j ++ ) { sum@@ 1 += ar@@ r1 [ j ] ; sum@@ 2 += ar@@ r2 [ j ] ; if ( sum@@ 1 == sum@@ 2 ) { int len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; }
RE@@ MA@@ INDE@@ R_@@ 7_@@ LARGE_@@ NUMB@@ ERS | static int remain@@ der@@ With@@ 7 ( String num ) { int series [ ] = { 1 , 3 , 2 , - 1 , - 3 , - 2 } ; int series_@@ index = 0 ; int result = 0 ; for ( int i = num . length ( ) - 1 ; i >= 0 ; i -- ) { int digit = num . charAt ( i ) - '0' ; result += digit * series [ series_@@ index ] ; series_@@ index = ( series_@@ index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; }
LE@@ XI@@ CO@@ GRAPHIC@@ AL@@ LY_@@ PREVI@@ OUS_@@ PER@@ MU@@ TATION_@@ IN_@@ C | static boolean prev@@ Permutation ( char [ ] str ) { int n = str . length - 1 ; int i = n ; while ( i > 0 && str [ i - 1 ] <= str [ i ] ) { i -- ; } if ( i <= 0 ) { return false ; } int j = i - 1 ; while ( j + 1 <= n && str [ j + 1 ] <= str [ i - 1 ] ) { j ++ ; } swap ( str , i - 1 , j ) ; StringBuilder sb = new StringBuilder ( String . valueOf ( str ) ) ; sb . reverse ( ) ; str = sb . toString ( ) . toCharArray ( ) ; return true ; }
NUMBER@@ _SUB@@ SEQU@@ EN@@ CES_@@ FORM_@@ AI_@@ B@@ J_@@ CK | static int count@@ Sub@@ sequences ( String s ) { int a@@ Count = 0 ; int b@@ Count = 0 ; int c@@ Count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' a ' ) a@@ Count = ( 1 + 2 * a@@ Count ) ; else if ( s . charAt ( i ) == ' b ' ) b@@ Count = ( a@@ Count + 2 * b@@ Count ) ; else if ( s . charAt ( i ) == ' c ' ) c@@ Count = ( b@@ Count + 2 * c@@ Count ) ; } return c@@ Count ; }
PROGRAM_@@ PR@@ IN@@ T_ID@@ ENTITY_@@ MATRIX_@@ 1 | static boolean is@@ Identity ( int mat [ ] [ ] , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }
MAXIMUM_@@ POSSI@@ BLE_@@ DIFF@@ ER@@ ENCE_@@ TW@@ O@@ _SUB@@ SE@@ TS_@@ ARRAY_@@ 1 | static int max@@ Diff ( int [ ] arr , int n ) { int result = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += Math . abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs ( arr [ n - 1 ] ) ; return result ; }
PROGRAM_@@ PRINT_@@ S@@ UM_@@ GI@@ V@@ EN_@@ N@@ TH_@@ TERM | static int summ@@ ing@@ Series ( long n ) { int S = 0 ; for ( i = 1 ; i <= n ; i ++ ) S += i * i - ( i - 1 ) * ( i - 1 ) ; return S ; }
PRE@@ FIX@@ _S@@ UM_@@ 2D_@@ ARRAY | public static void prefix@@ Sum@@ 2D ( int a [ ] [ ] ) { int R = a . length ; int C = a [ 0 ] . length ; int ps@@ a [ ] [ ] = new int [ R ] [ C ] ; ps@@ a [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] ; for ( int i = 1 ; i < C ; i ++ ) ps@@ a [ 0 ] [ i ] = ps@@ a [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] ; for ( int i = 1 ; i < R ; i ++ ) ps@@ a [ i ] [ 0 ] = ps@@ a [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) ps@@ a [ i ] [ j ] = ps@@ a [ i - 1 ] [ j ] + ps@@ a [ i ] [ j - 1 ] - ps@@ a [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) System . out . print ( ps@@ a [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } }
MAXIMUM_@@ NUMBER_@@ 2@@ X@@ 2@@ _S@@ QUAR@@ ES_@@ CAN_@@ FI@@ T_@@ IN@@ SIDE_@@ RIGHT_@@ ISO@@ SCE@@ LES_@@ TRI@@ ANGLE | public static int numberOf@@ Squ@@ ares ( int base ) { base = ( base - 2 ) ; base = base / 2 ; return base * ( base + 1 ) / 2 ; }
GI@@ V@@ EN_@@ BINARY_@@ STRING_@@ COUNT_@@ NUMBER@@ _SUB@@ STRING@@ S_@@ START_@@ END_@@ 1_1 | int count@@ Sub@@ Str ( char str [ ] , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) m ++ ; } return m * ( m - 1 ) / 2 ; }
CONVER@@ TING_@@ ONE_@@ STRING_@@ USING_@@ APP@@ END_@@ DELETE_@@ LAST_@@ OPER@@ ATIONS | static boolean is@@ Conver@@ tible ( String str1 , String str2 , int k ) { if ( ( str1 . length ( ) + str2 . length ( ) ) < k ) return true ; int common@@ Length = 0 ; for ( int i = 0 ; i < Math . min ( str1 . length ( ) , str2 . length ( ) ) ; i ++ ) { if ( str1 == str2 ) common@@ Length ++ ; else break ; } if ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * common@@ Length ) % 2 == 0 ) return true ; return false ; }
FIND_@@ THE_@@ NUMBER_@@ OC@@ CURR@@ ING_@@ OD@@ D_@@ NUMBER_OF_@@ TIME@@ S_@@ 2 | int getO@@ dd@@ Occurren@@ ce ( int ar [ ] , int ar@@ _size ) { int i ; int res = 0 ; for ( i = 0 ; i < ar@@ _size ; i ++ ) { res = res ^ ar [ i ] ; } return res ; }
S@@ UM_@@ MIDD@@ LE_@@ ROW_@@ COLUMN_@@ MATRIX | static void middle@@ sum ( int mat [ ] [ ] , int n ) { int row_@@ sum = 0 , col_@@ sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) row_@@ sum += mat [ n / 2 ] [ i ] ; System . out . println ( " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " + row_@@ sum ) ; for ( int i = 0 ; i < n ; i ++ ) col_@@ sum += mat [ i ] [ n / 2 ] ; System . out . println ( " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " + col_@@ sum ) ; }
K_@@ TH_@@ DISTIN@@ CT_@@ OR_@@ NON_@@ REPE@@ ATING_@@ ELEMENT_@@ IN_@@ AN_@@ ARRAY | static int print@@ K@@ Distin@@ ct ( int arr [ ] , int n , int k ) { int dist@@ _count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist@@ _count ++ ; if ( dist@@ _count == k ) return arr [ i ] ; } return - 1 ; }
MER@@ G@@ ING_@@ INTER@@ VAL@@ S | public static void merge@@ Intervals ( Interval arr [ ] ) { Arrays . sort ( arr , new Comparator < Interval > ( ) { public int compare ( Interval i1 , Interval i2 ) { return i2 . start - i1 . start ; } } ) ; int index = 0 ; for ( int i = 1 ; i < arr . length ; i ++ ) { if ( arr [ index ] . end >= arr [ i ] . start ) { arr [ index ] . end = Math . max ( arr [ index ] . end , arr [ i ] . end ) ; arr [ index ] . start = Math . min ( arr [ index ] . start , arr [ i ] . start ) ; } else { arr [ index ] = arr [ i ] ; index ++ ; } } System . out . print ( " The ▁ Mer@@ ged ▁ Intervals ▁ are : ▁ " ) ; for ( int i = 0 ; i <= index ; i ++ ) { System . out . print ( " [ " + arr [ i ] . start + " , " + arr [ i ] . end + " ] " ) ; } }
FIND_@@ NUMBER_@@ PER@@ F@@ ECT_@@ SQU@@ AR@@ ES_@@ TWO_@@ GI@@ V@@ EN_@@ NUMB@@ ERS_@@ 1 | double count@@ Squ@@ ares ( int a , int b ) { return ( Math . floor ( Math . sqrt ( b ) ) - Math . ceil ( Math . sqrt ( a ) ) + 1 ) ; }
LAR@@ GE@@ ST@@ _SUB@@ SET_@@ WHO@@ SE_@@ ALL_@@ ELEMEN@@ TS_@@ ARE_@@ FI@@ BON@@ ACC@@ I_@@ NUMB@@ ERS | public static void find@@ Fi@@ b@@ Subset ( Integer [ ] x ) { Integer max = Collections . max ( Arrays . asList ( x ) ) ; List < Integer > fi@@ b = new ArrayList < Integer > ( ) ; List < Integer > result = new ArrayList < Integer > ( ) ; Integer a = 0 ; Integer b = 1 ; while ( b < max ) { Integer c = a + b ; a = b ; b = c ; fi@@ b . add ( c ) ; } for ( Integer i = 0 ; i < x . length ; i ++ ) { if ( fi@@ b . contains ( x [ i ] ) ) { result . add ( x [ i ] ) ; } } System . out . println ( result ) ; }
LE@@ XI@@ CO@@ GRAPHIC@@ AL_@@ CON@@ CAT@@ EN@@ ATION@@ _SUB@@ STRING@@ S_@@ STRING | static String lex@@ ico@@ graphic@@ Sub@@ Concat ( String s ) { int n = s . length ( ) ; int sub@@ _count = n * ( n + 1 ) / 2 ; String [ ] arr = new String [ sub@@ _count ] ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int len = 1 ; len <= n - i ; len ++ ) { arr [ index ++ ] = s . substring ( i , i + len ) ; } Arrays . sort ( arr ) ; String res = " " ; for ( int i = 0 ; i < sub@@ _count ; i ++ ) res += arr [ i ] ; return res ; }
COUNT_@@ OPER@@ ATION@@ S_@@ MAKE_@@ STRING@@ AB_@@ FREE | static int ab@@ Free ( char [ ] s ) { int b_@@ count = 0 ; int res = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( s [ s . length - i - 1 ] == ' a ' ) { res = ( res + b_@@ count ) ; b_@@ count = ( b_@@ count * 2 ) ; } else { b_@@ count += 1 ; } } return res ; }
MAXIMUM_@@ HEIGHT_@@ OF_@@ TRIANG@@ ULAR_@@ AR@@ RANGE@@ MENT_@@ OF_@@ ARRAY_@@ VALU@@ ES_@@ 1 | static int Maximum@@ Height ( int a [ ] , int n ) { return ( int ) Math . floor ( ( - 1 + Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; }
MAXI@@ MI@@ ZE_@@ VOLUME_@@ CU@@ BO@@ ID_@@ GI@@ VEN@@ _S@@ UM@@ _SI@@ DES | static int max@@ volume ( int s ) { int max@@ value = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; max@@ value = Math . max ( max@@ value , i * j * k ) ; } } return max@@ value ; }
PROGRAM_@@ DECIMAL_@@ HEX@@ A@@ DECIMAL_@@ CONVERSION | static void dec@@ To@@ Hex@@ a ( int n ) { char [ ] hexa@@ Deci@@ Num = new char [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexa@@ Deci@@ Num [ i ] = ( char ) ( temp + 48 ) ; i ++ ; } else { hexa@@ Deci@@ Num [ i ] = ( char ) ( temp + 55 ) ; i ++ ; } n = n / 16 ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( hexa@@ Deci@@ Num [ j ] ) ; }
SM@@ ALLE@@ ST@@ _SUB@@ ARRAY_@@ WITH_@@ ALL_@@ OC@@ CURR@@ EN@@ CES_@@ OF_@@ A_@@ MO@@ ST_@@ FREQU@@ ENT_@@ ELEMENT | static void smalle@@ st@@ Sub@@ segment ( int a [ ] , int n ) { HashMap < Integer , Integer > left = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ; int mx = 0 ; int mn = - 1 , str@@ index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( count . get ( x ) == null ) { left . put ( x , i ) ; count . put ( x , 1 ) ; } else count . put ( x , count . get ( x ) + 1 ) ; if ( count . get ( x ) > mx ) { mx = count . get ( x ) ; mn = i - left . get ( x ) + 1 ; str@@ index = left . get ( x ) ; } else if ( ( count . get ( x ) == mx ) && ( i - left . get ( x ) + 1 < mn ) ) { mn = i - left . get ( x ) + 1 ; str@@ index = left . get ( x ) ; } } for ( int i = str@@ index ; i < str@@ index + mn ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; }
FIND_@@ LAST_@@ INDEX_@@ CHARACTER_@@ STRING_@@ 1 | static int find@@ Last@@ Index ( String str , Character x ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == x ) return i ; return - 1 ; }
RE@@ CAM@@ AN@@ S@@ _SEQU@@ ENCE | static void rec@@ am@@ an ( int n ) { int arr [ ] = new int [ n ] ; arr [ 0 ] = 0 ; System . out . print ( arr [ 0 ] + " ▁ , " ) ; for ( int i = 1 ; i < n ; i ++ ) { int curr = arr [ i - 1 ] - i ; int j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) || curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; System . out . print ( arr [ i ] + " , ▁ " ) ; } }
C_@@ PROGRAM_@@ FIN@@ D@@ _SECON@@ D_@@ FREQU@@ ENT_@@ CHARACTER | static char get@@ Second@@ Most@@ Freq ( String str ) { int [ ] count = new int [ NO_@@ OF_@@ CHARS ] ; int i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) ( count [ str . charAt ( i ) ] ) ++ ; int first = 0 , second = 0 ; for ( i = 0 ; i < NO_@@ OF_@@ CHARS ; i ++ ) { if ( count [ i ] > count [ first ] ) { second = first ; first = i ; } else if ( count [ i ] > count [ second ] && count [ i ] != count [ first ] ) second = i ; } return ( char ) second ; }
FIND_@@ MAXIMUM_@@ HEIGHT_@@ PY@@ RAM@@ ID_@@ FROM_@@ THE_@@ GI@@ V@@ EN_@@ ARRAY_@@ OF_@@ OBJECTS | static int max@@ Level ( int [ ] boxes , int n ) { Arrays . sort ( boxes ) ; int ans = 1 ; int prev_@@ width = boxes [ 0 ] ; int prev_@@ count = 1 ; int curr_@@ count = 0 ; int curr_@@ width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_@@ width += boxes [ i ] ; curr_@@ count += 1 ; if ( curr_@@ width > prev_@@ width && curr_@@ count > prev_@@ count ) { prev_@@ width = curr_@@ width ; prev_@@ count = curr_@@ count ; curr_@@ count = 0 ; curr_@@ width = 0 ; ans ++ ; } } return ans ; }
COUN@@ TING_@@ IN@@ VERSIONS | static int getIn@@ v@@ Count ( int n ) { int inv_@@ count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_@@ count ++ ; return inv_@@ count ; }
SQU@@ AR@@ ES_@@ OF_@@ MATRIX_@@ DIAG@@ ON@@ AL_@@ ELEMENTS | static void diag@@ onal@@ square ( int mat [ ] [ ] , int row , int column ) { System . out . print ( " Diagonal ▁ one ▁ : ▁ " ) ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < column ; j ++ ) if ( i == j ) System . out . print ( mat [ i ] [ j ] * mat [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; System . out . print ( " Diagonal ▁ two ▁ : ▁ " ) ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < column ; j ++ ) if ( i + j == column - 1 ) System . out . print ( mat [ i ] [ j ] * mat [ i ] [ j ] + " ▁ " ) ; } }
ROW_@@ WI@@ SE_@@ COMMON_@@ ELEMEN@@ TS_@@ TWO_@@ DIAG@@ ON@@ AL@@ S_S@@ QU@@ ARE_@@ MATRIX | static int count@@ Common ( int mat [ ] [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }
E@@ UL@@ ERI@@ AN_@@ NUMBER | public static int e@@ ul@@ eri@@ an ( int n , int m ) { if ( m >= n || n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * e@@ ul@@ eri@@ an ( n - 1 , m - 1 ) + ( m + 1 ) * e@@ ul@@ eri@@ an ( n - 1 , m ) ; }
E@@ UL@@ ERS_@@ CRITERI@@ ON_@@ CHECK_@@ IF@@ _S@@ QU@@ ARE_@@ ROOT_@@ UN@@ DER_@@ MODUL@@ O_@@ P_@@ EXISTS | static boolean square@@ Root@@ Exists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }
COUNT_@@ POSSI@@ BLE_@@ PATH@@ S_@@ TOP_@@ LEFT_@@ BOTTOM_@@ RIGHT_@@ NX@@ M_@@ MATRIX_@@ 3 | static int numberOf@@ Paths ( int m , int n ) { int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; }
MODI@@ FY_@@ ARRAY_@@ TO_@@ MAXI@@ MI@@ ZE_@@ S@@ UM_@@ OF_@@ AD@@ J@@ AC@@ ENT_@@ DIFF@@ ER@@ EN@@ CES | static int maximum@@ Difference@@ Sum ( int arr [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }
STER@@ N_@@ BRO@@ CO@@ T_@@ SEQUENCE | static void St@@ er@@ n@@ Sequence@@ Func ( Vector < Integer > Bro@@ co@@ t@@ Sequence , int n ) { for ( int i = 1 ; Bro@@ co@@ t@@ Sequence . size ( ) < n ; i ++ ) { int consi@@ dered_@@ element = Bro@@ co@@ t@@ Sequence . get ( i ) ; int pre@@ ced@@ ent = Bro@@ co@@ t@@ Sequence . get ( i - 1 ) ; Bro@@ co@@ t@@ Sequence . add ( consi@@ dered_@@ element + pre@@ ced@@ ent ) ; Bro@@ co@@ t@@ Sequence . add ( consi@@ dered_@@ element ) ; } for ( int i = 0 ; i < 15 ; ++ i ) System . out . print ( Bro@@ co@@ t@@ Sequence . get ( i ) + " ▁ " ) ; }
NUMBER@@ _SUB@@ SEQU@@ EN@@ CES_@@ STRING_@@ DI@@ VISI@@ BLE_@@ N | static int count@@ Di@@ visible@@ Sub@@ seq ( String str , int n ) { int len = str . length ( ) ; int dp [ ] [ ] = new int [ len ] [ n ] ; dp [ 0 ] [ ( str . charAt ( 0 ) - '0' ) % n ] ++ ; for ( int i = 1 ; i < len ; i ++ ) { dp [ i ] [ ( str . charAt ( i ) - '0' ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( str . charAt ( i ) - '0' ) ) % n ] += dp [ i - 1 ] [ j ] ; } } return dp [ len - 1 ] [ 0 ] ; }
HO@@ W_@@ TO_@@ BEGIN_@@ WITH_@@ COMP@@ E@@ TI@@ TIVE_@@ PROGR@@ AM@@ M@@ ING | static int search ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }
COUNT_@@ PAIR@@ S_@@ WITH_@@ GI@@ VEN@@ _S@@ UM@@ _1 | static int get@@ Pai@@ rs@@ Count ( int n , int sum ) { HashMap < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! hm . containsKey ( arr [ i ] ) ) hm . put ( arr [ i ] , 0 ) ; hm . put ( arr [ i ] , hm . get ( arr [ i ] ) + 1 ) ; } int tw@@ ice_@@ count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hm . get ( sum - arr [ i ] ) != null ) tw@@ ice_@@ count += hm . get ( sum - arr [ i ] ) ; if ( sum - arr [ i ] == arr [ i ] ) tw@@ ice_@@ count -- ; } return tw@@ ice_@@ count / 2 ; }
FIND_@@ THE_@@ MINIMUM_@@ DISTAN@@ CE_@@ BETWE@@ EN_@@ TWO_@@ NUMB@@ ERS | int min@@ Dist ( int arr [ ] , int n , int x , int y ) { int i , j ; int min_@@ dist = Integer . MAX_VALUE ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( x == arr [ i ] && y == arr [ j ] || y == arr [ i ] && x == arr [ j ] ) && min_@@ dist > Math . abs ( i - j ) ) min_@@ dist = Math . abs ( i - j ) ; } } return min_@@ dist ; }
FIND_@@ REPE@@ TI@@ TIVE_@@ ELEMENT_@@ 1_@@ N_@@ 1_2 | static int find@@ Repe@@ ating ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) res = res ^ ( i + 1 ) ^ arr [ i ] ; res = res ^ arr [ n - 1 ] ; return res ; }
SHOR@@ TEST_@@ PATH_@@ EXAC@@ TL@@ Y_@@ K_@@ ED@@ GE@@ S_@@ DIREC@@ TED_@@ WE@@ I@@ GH@@ TED_@@ GRAPH_@@ 1 | int shor@@ test@@ Path ( int graph [ ] [ ] , int u , int v , int k ) { int sp [ ] [ ] [ ] = new int [ V ] [ V ] [ k + 1 ] ; for ( int e = 0 ; e <= k ; e ++ ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { sp [ i ] [ j ] [ e ] = INF ; if ( e == 0 && i == j ) sp [ i ] [ j ] [ e ] = 0 ; if ( e == 1 && graph [ i ] [ j ] != INF ) sp [ i ] [ j ] [ e ] = graph [ i ] [ j ] ; if ( e > 1 ) { for ( int a = 0 ; a < V ; a ++ ) { if ( graph [ i ] [ a ] != INF && i != a && j != a && sp [ a ] [ j ] [ e - 1 ] != INF ) sp [ i ] [ j ] [ e ] = Math . min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] ) ; } } } } } return sp [ u ] [ v ] [ k ] ; }
LON@@ GE@@ ST@@ _SUB@@ ARRAY_@@ NOT_@@ K_@@ DISTIN@@ CT_@@ ELEMENTS | static void longest ( int a [ ] , int n , int k ) { int [ ] freq = new int [ 7 ] ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) { end = i ; start = l ; } } for ( int i = start ; i <= end ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; }
MAXIMUM_@@ X@@ OR_@@ VALUE_@@ MATRIX | static int max@@ XOR ( int mat [ ] [ ] , int N ) { int r_@@ xor , c_@@ xor ; int max_@@ xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { r_@@ xor = 0 ; c_@@ xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) { r_@@ xor = r_@@ xor ^ mat [ i ] [ j ] ; c_@@ xor = c_@@ xor ^ mat [ j ] [ i ] ; } if ( max_@@ xor < Math . max ( r_@@ xor , c_@@ xor ) ) max_@@ xor = Math . max ( r_@@ xor , c_@@ xor ) ; } return max_@@ xor ; }
LENGTH_@@ LON@@ GE@@ ST@@ _SUB_@@ STRING_@@ CAN_@@ MAKE_@@ REMOVED | static int lon@@ gest@@ Null ( String str ) { ArrayList < Pair > arr = new ArrayList < > ( ) ; arr . add ( new Pair ( ' @ ' , - 1 ) ) ; int maxlen = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { arr . add ( new Pair ( str . charAt ( i ) , i ) ) ; while ( arr . size ( ) >= 3 && arr . get ( arr . size ( ) - 3 ) . first == '1' && arr . get ( arr . size ( ) - 2 ) . first == '0' && arr . get ( arr . size ( ) - 1 ) . first == '0' ) { arr . remove ( arr . size ( ) - 3 ) ; arr . remove ( arr . size ( ) - 2 ) ; arr . remove ( arr . size ( ) - 1 ) ; } int tmp = arr . get ( arr . size ( ) - 1 ) . second ; maxlen = Math . max ( maxlen , i - tmp ) ; } return maxlen ; }
LON@@ GE@@ ST_@@ ALTER@@ N@@ AT@@ ING@@ _SUB_@@ ARRAY_@@ START@@ ING_@@ EVER@@ Y_@@ INDEX_@@ BINARY_@@ ARRAY | static void alternate@@ Sub@@ array ( boolean arr [ ] , int n ) { int len [ ] = new int [ n ] ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; ++ i ) System . out . print ( len [ i ] + " ▁ " ) ; }
WI@@ LD@@ CARD_@@ CHARACTER_@@ MATCH@@ ING | static boolean match ( String first , String second ) { if ( first . length ( ) == 0 && second . length ( ) == 0 ) return true ; if ( first . length ( ) > 1 && first . charAt ( 0 ) == ' * ' && second . length ( ) == 0 ) return false ; if ( ( first . length ( ) > 1 && first . charAt ( 0 ) == ' ? ' ) || ( first . length ( ) != 0 && second . length ( ) != 0 && first . charAt ( 0 ) == second . charAt ( 0 ) ) ) return match ( first . substring ( 1 ) , second . substring ( 1 ) ) ; if ( first . length ( ) > 0 && first . charAt ( 0 ) == ' * ' ) return match ( first . substring ( 1 ) , second ) || match ( first , second . substring ( 1 ) ) ; return false ; }
FIND_@@ FAC@@ TOR@@ I@@ AL_@@ NUMB@@ ERS_@@ LESS_@@ EQUAL_@@ N | static void print@@ Fac@@ tori@@ al@@ Num@@ s ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { System . out . print ( fact + " ▁ " ) ; fact = fact * x ; x ++ ; } }
FRI@@ END@@ S_@@ PAIR@@ ING_@@ PRO@@ BLE@@ M_@@ 2 | static int count@@ Fri@@ ends@@ Pair@@ ings ( int n ) { int a = 1 , b = 2 , c = 0 ; if ( n <= 2 ) { return n ; } for ( int i = 3 ; i <= n ; i ++ ) { c = b + ( i - 1 ) * a ; a = b ; b = c ; } return c ; }
FIND_@@ THE_@@ LAR@@ GE@@ ST_@@ REC@@ TAN@@ GLE_@@ OF_@@ 1@@ S_@@ WITH@@ _SW@@ APP@@ ING_@@ OF_@@ COLUM@@ NS_@@ ALLOWED | static int max@@ Area ( int mat [ ] [ ] ) { int hist [ ] [ ] = new int [ R + 1 ] [ C + 1 ] ; for ( int i = 0 ; i < C ; i ++ ) { hist [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( int j = 1 ; j < R ; j ++ ) { hist [ j ] [ i ] = ( mat [ j ] [ i ] == 0 ) ? 0 : hist [ j - 1 ] [ i ] + 1 ; } } for ( int i = 0 ; i < R ; i ++ ) { int count [ ] = new int [ R + 1 ] ; for ( int j = 0 ; j < C ; j ++ ) { count [ hist [ i ] [ j ] ] ++ ; } int col_@@ no = 0 ; for ( int j = R ; j >= 0 ; j -- ) { if ( count [ j ] > 0 ) { for ( int k = 0 ; k < count [ j ] ; k ++ ) { hist [ i ] [ col_@@ no ] = j ; col_@@ no ++ ; } } } } int curr_@@ area , max_@@ area = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { curr_@@ area = ( j + 1 ) * hist [ i ] [ j ] ; if ( curr_@@ area > max_@@ area ) { max_@@ area = curr_@@ area ; } } } return max_@@ area ; }
SUM@@ _SEQU@@ ENCE_@@ 2_@@ 22_@@ 222 | static double sum@@ Of@@ Series ( int n ) { return 0.02@@ 46 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }
PROGRAM_@@ FIRST_@@ FI@@ T_@@ ALGORITH@@ M_@@ MEMORY_@@ MAN@@ A@@ GEMENT | static void first@@ Fit ( int blockSize [ ] , int m , int process@@ Size [ ] , int n ) { int allocation [ ] = new int [ n ] ; for ( int i = 0 ; i < allocation . length ; i ++ ) allocation [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= process@@ Size [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= process@@ Size [ i ] ; break ; } } } System . out . println ( " \n Process ▁ No . \t@@ Process ▁ Size@@ \t@@ Block ▁ no . " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( " ▁ " + ( i + 1 ) + " \t\t " + process@@ Size [ i ] + " \t\t " ) ; if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 ) ; else System . out . print ( " Not ▁ Allocated " ) ; System . out . println ( ) ; } }
CHECK_@@ IF_@@ A_@@ NUMBER_@@ IS_@@ POWER_@@ OF_@@ AN@@ OTHER_@@ NUMBER | public static boolean is@@ Power ( int x , int y ) { if ( x == 1 ) return ( y == 1 ) ; int pow = 1 ; while ( pow < y ) pow = pow * x ; return ( pow == y ) ; }
DI@@ VI@@ DE_@@ LARGE_@@ NUMBER_@@ RE@@ PRESEN@@ TED_@@ STRING | static String long@@ Division ( String number , int divisor ) { String ans = " " ; int idx = 0 ; char [ ] num = number . toCharArray ( ) ; int temp = num [ idx ] - '0' ; while ( temp < divisor ) temp = temp * 10 + ( num [ ++ idx ] - '0' ) ; idx += 1 ; while ( num . length > idx ) { ans += ( temp / divisor ) ; temp = ( temp % divisor ) * 10 + num [ idx ++ ] - '0' ; } if ( ans . length ( ) == 0 ) return "0" ; return ans ; }
FIND_@@ ROW_@@ NUMBER_@@ BINARY_@@ MATRIX_@@ MAXIMUM_@@ NUMBER_@@ 1@@ S | static void find@@ Max ( int arr [ ] [ ] ) { int row = 0 , i , j ; for ( i = 0 , j = N - 1 ; i < N ; i ++ ) { while ( j >= 0 && arr [ i ] [ j ] == 1 ) { row = i ; j -- ; } } System . out . print ( " Row ▁ number ▁ = ▁ " + ( row + 1 ) ) ; System . out . print ( " , ▁ Max@@ Count ▁ = ▁ " + ( N - 1 - j ) ) ; }
MINIMUM_@@ ROTA@@ TIONS_@@ REQUIRED_@@ GET_@@ STRING | static int find@@ Rot@@ ations ( String str ) { String tmp = str + str ; int n = str . length ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { String substring = tmp . substring ( i , str . length ( ) ) ; if ( str == substring ) return i ; } return n ; }
COUNT_@@ POSSI@@ BLE_@@ PATH@@ S_@@ TOP_@@ LEFT_@@ BOTTOM_@@ RIGHT_@@ NX@@ M_@@ MATRIX | static int numberOf@@ Paths ( int m , int n ) { if ( m == 1 || n == 1 ) return 1 ; return numberOf@@ Paths ( m - 1 , n ) + numberOf@@ Paths ( m , n - 1 ) ; }
N_@@ TH_@@ NUMBER_@@ WHO@@ SE_@@ S@@ UM_@@ OF_@@ DIG@@ IT@@ S_@@ IS_@@ T@@ EN_@@ 1 | public static int find@@ N@@ th ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } }
S@@ UM_@@ NODE@@ S_@@ K_@@ TH_@@ LEVEL_@@ TREE_@@ RE@@ PRESEN@@ TED_@@ STRING_@@ 1 | static int sum@@ At@@ K@@ th@@ Level ( String tree , int k , int level ) { if ( tree . charAt ( i ++ ) == ' ( ' ) { if ( tree . charAt ( i ) == ' ) ' ) return 0 ; int sum = 0 ; if ( level == k ) sum = tree . charAt ( i ) - '0' ; ++ i ; int left@@ sum = sum@@ At@@ K@@ th@@ Level ( tree , k , level + 1 ) ; ++ i ; int right@@ sum = sum@@ At@@ K@@ th@@ Level ( tree , k , level + 1 ) ; ++ i ; return sum + left@@ sum + right@@ sum ; } return Integer . MIN_VALUE ; }
COUNT_@@ OF@@ DIFF@@ ER@@ ENT_@@ WAY@@ S_@@ EXP@@ RESS_@@ N_S@@ UM_@@ 1_@@ 3_@@ 4 | static int count@@ W@@ ays ( int n ) { int DP [ ] = new int [ n + 1 ] ; DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1 ; DP [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ] ; return DP [ n ] ; }
MAXIMUM_@@ EQU@@ LIB@@ RI@@ UM@@ _S@@ UM_@@ ARRAY | static int find@@ Max@@ Sum ( int [ ] arr , int n ) { int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int prefix_@@ sum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) prefix_@@ sum += arr [ j ] ; int suffix_@@ sum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) suffix_@@ sum += arr [ j ] ; if ( prefix_@@ sum == suffix_@@ sum ) res = Math . max ( res , prefix_@@ sum ) ; } return res ; }
STE@@ INS_@@ ALGORITH@@ M_@@ FOR_@@ FIN@@ DING_@@ GC@@ D_@@ 1 | static int gcd ( int a , int b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( ( ~ a & 1 ) == 1 ) { if ( ( b & 1 ) == 1 ) return gcd ( a > > 1 , b ) ; else return gcd ( a > > 1 , b > > 1 ) << 1 ; } if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b > > 1 ) ; if ( a > b ) return gcd ( ( a - b ) > > 1 , b ) ; return gcd ( ( b - a ) > > 1 , a ) ; }
PROGRAM_@@ TO_@@ FIND_@@ THE_@@ VOLUME_@@ OF_@@ A_@@ TRIANG@@ ULAR_@@ PRI@@ SM | static float find@@ Volume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; }
FIND_@@ REC@@ TAN@@ GLE_@@ BINARY_@@ MATRIX_@@ COR@@ NE@@ RS_@@ 1 | static boolean is@@ Rectangle ( int m [ ] [ ] ) { int rows = m . length ; if ( rows == 0 ) return false ; int columns = m [ 0 ] . length ; for ( int y1 = 0 ; y1 < rows ; y1 ++ ) for ( int x1 = 0 ; x1 < columns ; x1 ++ ) if ( m [ y1 ] [ x1 ] == 1 ) for ( int y2 = y1 + 1 ; y2 < rows ; y2 ++ ) for ( int x2 = x1 + 1 ; x2 < columns ; x2 ++ ) if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 && m [ y2 ] [ x2 ] == 1 ) return true ; return false ; }
CHECK_@@ IF_@@ STRING_@@ RE@@ MA@@ INS_@@ PA@@ LIN@@ DRO@@ ME_@@ AFTER_@@ REMO@@ V@@ ING_@@ GI@@ V@@ EN_@@ NUMBER_OF_@@ CHARAC@@ TERS | static boolean is@@ Possible ( String str , int n ) { int len = str . length ( ) ; if ( len >= n ) return true ; return false ; }
CHECK_@@ STAR@@ _@@ GRAP@@ H | static boolean check@@ Star ( int mat [ ] [ ] ) { int vertex@@ D1 = 0 , vertex@@ D@@ n_@@ 1 = 0 ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; for ( int i = 0 ; i < size ; i ++ ) { int degree@@ I = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] == 1 ) degree@@ I ++ ; if ( degree@@ I == 1 ) vertex@@ D1 ++ ; else if ( degree@@ I == size - 1 ) vertex@@ D@@ n_@@ 1 ++ ; } return ( vertex@@ D1 == ( size - 1 ) && vertex@@ D@@ n_@@ 1 == 1 ) ; }
ROO@@ TS_@@ OF_@@ UNI@@ TY | static void print@@ Roots ( int n ) { double theta = 3.14 * 2 / n ; for ( int k = 0 ; k < n ; k ++ ) { double real = Math . cos ( k * theta ) ; double img = Math . sin ( k * theta ) ; System . out . println ( real ) ; if ( img >= 0 ) System . out . println ( " ▁ + ▁ i ▁ " ) ; else System . out . println ( " ▁ - ▁ i ▁ " ) ; System . out . println ( Math . abs ( img ) ) ; } }
FIND_@@ LAR@@ GE@@ ST_@@ D_@@ IN_@@ ARRAY@@ _SU@@ CH_@@ TH@@ AT_@@ A_@@ B_@@ C_@@ D | static int find@@ Large@@ std ( int [ ] S , int n ) { boolean found = false ; Arrays . sort ( S ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return Integer . MAX_VALUE ; return - 1 ; }
GI@@ V@@ EN_@@ NUMBER_@@ STRING_@@ FIND_@@ NUMBER_@@ CON@@ TI@@ GU@@ OU@@ S@@ _SUB@@ SEQU@@ EN@@ CES_@@ RECUR@@ SI@@ VEL@@ Y_@@ ADD_@@ 9@@ _SET_@@ 2 | static int count@@ 9@@ s ( char number [ ] ) { int n = number . length ; int d [ ] = new int [ 9 ] ; d [ 0 ] = 1 ; int result = 0 ; int mod_@@ sum = 0 , continu@@ ous_@@ zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( number [ i ] - '0' ) == 0 ) { continu@@ ous_@@ zero ++ ; } else { continu@@ ous_@@ zero = 0 ; } mod_@@ sum += ( number [ i ] - '0' ) ; mod_@@ sum %= 9 ; result += d [ mod_@@ sum ] ; d [ mod_@@ sum ] ++ ; result -= continu@@ ous_@@ zero ; } return result ; }
LE@@ XI@@ CO@@ GRAPHIC@@ AL_@@ MAX@@ IM@@ UM@@ _SUB@@ STRING_@@ STRING | static String Lex@@ ico@@ graphic@@ al@@ Max@@ String ( String str ) { String mx = " " ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { if ( mx . compareTo ( str . substring ( i ) ) <= 0 ) { mx = str . substring ( i ) ; } } return mx ; }
CHECK_@@ TWO_@@ GI@@ VEN@@ _SE@@ TS_@@ DIS@@ JO@@ INT_@@ 1 | boolean are@@ disjoint ( int set1 [ ] , int set2 [ ] ) { int i = 0 , j = 0 ; Arrays . sort ( set1 ) ; Arrays . sort ( set2 ) ; while ( i < set1 . length && j < set2 . length ) { if ( set1 [ i ] < set2 [ j ] ) i ++ ; else if ( set1 [ i ] > set2 [ j ] ) j ++ ; else return false ; } return true ; }
EQU@@ ILI@@ BRI@@ UM_@@ INDEX_@@ OF_@@ AN_@@ ARRAY_@@ 1 | int equi@@ lib@@ ri@@ um ( int arr [ ] , int n ) { int sum = 0 ; int left@@ sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( left@@ sum == sum ) return i ; left@@ sum += arr [ i ] ; } return - 1 ; }
AREA_@@ CIRCUM@@ SCRI@@ BED_@@ CI@@ R@@ CLE_@@ SQUARE | static float are@@ ac@@ ir@@ cum@@ scri@@ bed ( float a ) { float PI = 3.1415@@ 9265@@ f ; return ( a * a * ( PI / 2 ) ) ; }
LON@@ GE@@ ST_@@ REPE@@ ATING_@@ AND_@@ NON_@@ OVER@@ L@@ APP@@ ING@@ _SUB@@ STRING | static String lon@@ gest@@ Repeated@@ Sub@@ string ( String str ) { int n = str . length ( ) ; int L@@ CS@@ Re [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; String res = " " ; int res_@@ length = 0 ; int i , index = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && L@@ CS@@ Re [ i - 1 ] [ j - 1 ] < ( j - i ) ) { L@@ CS@@ Re [ i ] [ j ] = L@@ CS@@ Re [ i - 1 ] [ j - 1 ] + 1 ; if ( L@@ CS@@ Re [ i ] [ j ] > res_@@ length ) { res_@@ length = L@@ CS@@ Re [ i ] [ j ] ; index = Math . max ( i , index ) ; } } else { L@@ CS@@ Re [ i ] [ j ] = 0 ; } } } if ( res_@@ length > 0 ) { for ( i = index - res_@@ length + 1 ; i <= index ; i ++ ) { res += str . charAt ( i - 1 ) ; } } return res ; }
HO@@ W_@@ TO_@@ AV@@ OID_@@ OVERFLOW_@@ IN_@@ MODUL@@ AR_@@ MULTIP@@ LIC@@ ATION | static long mul@@ mod ( long a , long b , long mod ) { long res = 0 ; a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) { res = ( res + a ) % mod ; } a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; }
PA@@ IR_@@ WITH_@@ GI@@ V@@ EN_@@ PRODUCT_@@ SET_@@ 1_@@ FIND_@@ IF_@@ ANY_@@ PA@@ IR_@@ EXI@@ ST@@ S_@@ 1 | static boolean is@@ Product ( int arr [ ] , int n , int x ) { HashSet < Integer > h@@ set = new HashSet < > ( ) ; if ( n < 2 ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { if ( x == 0 ) return true ; else continue ; } if ( x % arr [ i ] == 0 ) { if ( h@@ set . contains ( x / arr [ i ] ) ) return true ; h@@ set . add ( arr [ i ] ) ; } } return false ; }
S@@ UM_@@ K_@@ TH_@@ GROUP_@@ OD@@ D_@@ POSITIVE_@@ NUMB@@ ERS | public static int k@@ th@@ group@@ sum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; while ( k -- > 0 ) { sum += cur ; cur += 2 ; } return sum ; }
FIND_@@ ELEMEN@@ TS_@@ ARRAY_@@ LEA@@ ST_@@ TWO_@@ GREATER_@@ ELEMEN@@ TS_@@ 1 | static void find@@ Elements ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
MINIMUM_@@ STE@@ PS_@@ TO_@@ DELETE_@@ A_@@ STRING_@@ AFTER_@@ REPE@@ ATED_@@ DELE@@ TION_@@ OF_@@ PA@@ LIN@@ DRO@@ ME_@@ SUB@@ STRINGS | static int min@@ Step@@ To@@ Delete@@ String ( String str ) { int N = str . length ( ) ; int [ ] [ ] dp = new int [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= N ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int len = 1 ; len <= N ; len ++ ) { for ( int i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) { if ( len == 1 ) dp [ i ] [ j ] = 1 ; else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( str . charAt ( i ) == str . charAt ( i + 1 ) ) dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; for ( int K = i + 2 ; K <= j ; K ++ ) if ( str . charAt ( i ) == str . charAt ( K ) ) dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } return dp [ 0 ] [ N - 1 ] ; }
CAL@@ CUL@@ ATE_@@ AREA_@@ TE@@ TRA@@ HE@@ DRO@@ N | static double vol_@@ te@@ tra ( int side ) { double volume = ( Math . pow ( side , 3 ) / ( 6 * Math . sqrt ( 2 ) ) ) ; return volume ; }
SI@@ EV@@ E_@@ OF_@@ AT@@ K@@ IN | static int Si@@ eve@@ Of@@ At@@ kin ( int limit ) { if ( limit > 2 ) System . out . print ( 2 + " ▁ " ) ; if ( limit > 3 ) System . out . print ( 3 + " ▁ " ) ; boolean si@@ eve [ ] = new boolean [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) si@@ eve [ i ] = false ; for ( int x = 1 ; x * x < limit ; x ++ ) { for ( int y = 1 ; y * y < limit ; y ++ ) { int n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 || n % 12 == 5 ) ) si@@ eve [ n ] ^= true ; n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) si@@ eve [ n ] ^= true ; n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) si@@ eve [ n ] ^= true ; } } for ( int r = 5 ; r * r < limit ; r ++ ) { if ( si@@ eve [ r ] ) { for ( int i = r * r ; i < limit ; i += r * r ) si@@ eve [ i ] = false ; } } for ( int a = 5 ; a < limit ; a ++ ) if ( si@@ eve [ a ] ) System . out . print ( a + " ▁ " ) ; return 0 ; }
LENGTH_@@ OF_THE_@@ LON@@ GE@@ ST_@@ ARI@@ TH@@ MA@@ TIC_@@ PROG@@ RES@@ SION_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY | static int l@@ eng@@ ht@@ Of@@ Lon@@ gest@@ AP ( int set [ ] , int n ) { if ( n <= 2 ) return n ; int L [ ] [ ] = new int [ n ] [ n ] ; int l@@ lap = 2 ; for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ n - 1 ] = 2 ; for ( int j = n - 2 ; j >= 1 ; j -- ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ; else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) { L [ i ] [ j ] = 2 ; i -- ; } else { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; l@@ lap = Math . max ( l@@ lap , L [ i ] [ j ] ) ; i -- ; k ++ ; } } while ( i >= 0 ) { L [ i ] [ j ] = 2 ; i -- ; } } return l@@ lap ; }
COUNT_@@ GROUP@@ INGS_@@ NUMBER@@ _S@@ UM_@@ DIG@@ IT@@ S_@@ EVER@@ Y@@ _SUB_@@ GROUP_@@ LESS_@@ EQUAL@@ S_@@ IM@@ MEDI@@ ATE_@@ RIGHT_@@ SUB_@@ GROUP_@@ 1 | static int count@@ Groups ( int position , int previous_@@ sum , int length , char [ ] num ) { if ( position == length ) return 1 ; if ( dp [ position ] [ previous_@@ sum ] != - 1 ) return dp [ position ] [ previous_@@ sum ] ; dp [ position ] [ previous_@@ sum ] = 0 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_@@ sum ) res += count@@ Groups ( i + 1 , sum , length , num ) ; } dp [ position ] [ previous_@@ sum ] = res ; return res ; }
LON@@ GE@@ ST@@ _SP@@ AN@@ _S@@ UM_@@ TWO_@@ BINARY_@@ ARRAY@@ S_@@ 1 | static int lon@@ gest@@ Common@@ Sum ( int n ) { int maxLen = 0 ; int pre@@ Sum@@ 1 = 0 , pre@@ Sum@@ 2 = 0 ; int diff [ ] = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < diff . length ; i ++ ) { diff [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { pre@@ Sum@@ 1 += ar@@ r1 [ i ] ; pre@@ Sum@@ 2 += ar@@ r2 [ i ] ; int curr_@@ diff = pre@@ Sum@@ 1 - pre@@ Sum@@ 2 ; int diff@@ Index = n + curr_@@ diff ; if ( curr_@@ diff == 0 ) maxLen = i + 1 ; else if ( diff [ diff@@ Index ] == - 1 ) diff [ diff@@ Index ] = i ; else { int len = i - diff [ diff@@ Index ] ; if ( len > maxLen ) maxLen = len ; } } return maxLen ; }
PROGRAM_@@ TO_@@ PRINT_@@ FIRST_@@ N_@@ FI@@ BON@@ ACC@@ I_@@ NUMB@@ ERS | static void print@@ Fi@@ bon@@ ac@@ ci@@ Numbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; for ( i = 1 ; i <= n ; i ++ ) { System . out . print ( f2 + " ▁ " ) ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } }
LAR@@ GE@@ ST@@ _S@@ UM_@@ CON@@ TI@@ GU@@ OU@@ S@@ _SUB@@ ARRAY_@@ 3 | static void max@@ Sub@@ Array@@ Sum ( int a [ ] , int size ) { int max_@@ so@@ _f@@ ar = Integer . MIN_VALUE , max_@@ ending_@@ here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_@@ ending_@@ here += a [ i ] ; if ( max_@@ so@@ _f@@ ar < max_@@ ending_@@ here ) { max_@@ so@@ _f@@ ar = max_@@ ending_@@ here ; start = s ; end = i ; } if ( max_@@ ending_@@ here < 0 ) { max_@@ ending_@@ here = 0 ; s = i + 1 ; } } System . out . println ( " Maximum ▁ contiguous ▁ sum ▁ is ▁ " + max_@@ so@@ _f@@ ar ) ; System . out . println ( " Starting ▁ index ▁ " + start ) ; System . out . println ( " Ending ▁ index ▁ " + end ) ; }
FIND_@@ EQUAL_@@ POINT_@@ STRING_@@ BRAC@@ KETS | static int find@@ Index ( String str ) { int len = str . length ( ) ; int open [ ] = new int [ len + 1 ] ; int close [ ] = new int [ len + 1 ] ; int index = - 1 ; open [ 0 ] = 0 ; close [ len ] = 0 ; if ( str . charAt ( 0 ) == ' ( ' ) open [ 1 ] = 1 ; if ( str . charAt ( len - 1 ) == ' ) ' ) close [ len - 1 ] = 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( str . charAt ( i ) == ' ( ' ) open [ i + 1 ] = open [ i ] + 1 ; else open [ i + 1 ] = open [ i ] ; } for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == ' ) ' ) close [ i ] = close [ i + 1 ] + 1 ; else close [ i ] = close [ i + 1 ] ; } if ( open [ len ] == 0 ) return len ; if ( close [ 0 ] == 0 ) return 0 ; for ( int i = 0 ; i <= len ; i ++ ) if ( open [ i ] == close [ i ] ) index = i ; return index ; }
COUNT_@@ NUMBER_OF_@@ WAY@@ S_TO_@@ PARTITION_@@ A@@ _SET_@@ IN@@ TO_@@ K@@ _SUB@@ SE@@ TS_@@ 1 | static int count@@ P ( int n , int k ) { int [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) if ( j == 1 || i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; }
LON@@ GE@@ ST_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQUENCE | static int lis ( int arr [ ] , int n ) { max_@@ ref = 1 ; _@@ lis ( arr , n ) ; return max_@@ ref ; }
FIND_@@ REPE@@ ATED_@@ CHARACTER_@@ PRES@@ ENT_@@ FIRST_@@ STRING | static int find@@ Repeat@@ First@@ N2 ( String s ) { int p = - 1 , i , j ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { for ( j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }
K_@@ TH@@ _S@@ MAL@@ LE@@ ST_@@ ELEMENT_@@ REMO@@ V@@ ING_@@ INTEG@@ ERS_@@ N@@ ATUR@@ AL_@@ NUMB@@ ERS | static int k@@ smallest ( int arr [ ] , int n , int k ) { int b [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( int j = 1 ; j < MAX ; j ++ ) { if ( b [ j ] != 1 ) { k -- ; } if ( k != 1 ) { return j ; } } return Integer . MAX_VALUE ; }
CHECK_@@ IF_@@ STACK_@@ ELEMEN@@ TS_@@ ARE_@@ PAIR@@ WI@@ SE_@@ CON@@ SEC@@ UTI@@ VE | static boolean pair@@ Wi@@ se@@ Con@@ sec@@ utive ( Stack < Integer > s ) { Stack < Integer > aux = new Stack < Integer > ( ) ; while ( ! s . isEmpty ( ) ) { aux . push ( s . peek ( ) ) ; s . pop ( ) ; } boolean result = true ; while ( aux . size ( ) > 1 ) { int x = aux . peek ( ) ; aux . pop ( ) ; int y = aux . peek ( ) ; aux . pop ( ) ; if ( Math . abs ( x - y ) != 1 ) result = false ; s . push ( x ) ; s . push ( y ) ; } if ( aux . size ( ) == 1 ) s . push ( aux . peek ( ) ) ; return result ; }
BIN@@ AR@@ Y@@ _SEARCH_@@ 1 | int binary@@ Search ( int arr [ ] , int x ) { int l = 0 , r = arr . length - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] == x ) return m ; if ( arr [ m ] < x ) l = m + 1 ; else r = m - 1 ; } return - 1 ; }
COUNT_@@ DISTIN@@ CT_@@ OC@@ CURR@@ EN@@ CES_@@ AS_@@ A@@ _SUB@@ SEQUENCE | static int find@@ Sub@@ sequence@@ Count ( String S , String T ) { int m = T . length ( ) ; int n = S . length ( ) ; if ( m > n ) return 0 ; int mat [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( T . charAt ( i - 1 ) != S . charAt ( j - 1 ) ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; }
SW@@ AP_@@ TWO_@@ NUMB@@ ERS_@@ WITH@@ OUT_@@ USING_@@ TEMPOR@@ ARY_@@ VARIABLE | static void swap ( int [ ] xp , int [ ] yp ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; }
POLIC@@ E@@ MEN@@ _C@@ ATCH_@@ TH@@ I@@ EV@@ ES | static int poli@@ ce@@ Th@@ ie@@ f ( char arr [ ] , int n , int k ) { int res = 0 ; ArrayList < Integer > th@@ i = new ArrayList < Integer > ( ) ; ArrayList < Integer > pol = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == ' P ' ) pol . add ( i ) ; else if ( arr [ i ] == ' T ' ) th@@ i . add ( i ) ; } int l = 0 , r = 0 ; while ( l < th@@ i . size ( ) && r < pol . size ( ) ) { if ( Math . abs ( th@@ i . get ( l ) - pol . get ( r ) ) <= k ) { res ++ ; l ++ ; r ++ ; } else if ( th@@ i . get ( l ) < pol . get ( r ) ) l ++ ; else r ++ ; } return res ; }
LAR@@ GE@@ ST@@ _SUB@@ ARRAY_@@ WITH_@@ EQUAL_@@ NUMBER_OF_@@ 0@@ S_@@ AND_@@ 1@@ S_@@ 1 | int maxLen ( int arr [ ] , int n ) { HashMap < Integer , Integer > h@@ M = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; int max_len = 0 ; int ending_@@ index = - 1 ; int start_index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = ( arr [ i ] == 0 ) ? - 1 : 1 ; } for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == 0 ) { max_len = i + 1 ; ending_@@ index = i ; } if ( h@@ M . containsKey ( sum + n ) ) { if ( max_len < i - h@@ M . get ( sum + n ) ) { max_len = i - h@@ M . get ( sum + n ) ; ending_@@ index = i ; } } else h@@ M . put ( sum + n , i ) ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = ( arr [ i ] == - 1 ) ? 0 : 1 ; } int end = ending_@@ index - max_len + 1 ; System . out . println ( end + " ▁ to ▁ " + ending_@@ index ) ; return max_len ; }
MAXIMUM_@@ DIFF@@ ER@@ ENCE_@@ ZER@@ OS_@@ ONE@@ S_@@ BINARY_@@ STRING@@ _SET_@@ 2_@@ TIME | public static int find@@ Length ( String str , int n ) { int current_@@ sum = 0 ; int max_@@ sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_@@ sum += ( str . charAt ( i ) == '0' ? 1 : - 1 ) ; if ( current_@@ sum < 0 ) current_@@ sum = 0 ; max_@@ sum = Math . max ( current_@@ sum , max_@@ sum ) ; } return max_@@ sum == 0 ? - 1 : max_@@ sum ; }
MAXIMUM_@@ CON@@ SEC@@ UTI@@ VE_@@ NUMB@@ ERS_@@ PRES@@ ENT_@@ ARRAY | static int find@@ Lon@@ gest@@ Con@@ seq@@ Sub@@ seq ( int arr [ ] , int n ) { HashSet < Integer > S = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) S . add ( arr [ i ] ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( S . contains ( arr [ i ] ) ) { int j = arr [ i ] ; while ( S . contains ( j ) ) j ++ ; ans = Math . max ( ans , j - arr [ i ] ) ; } } return ans ; }
LE@@ XI@@ CO@@ GRAPHIC@@ AL@@ LY_@@ NEXT_@@ STRING | public static String next@@ Word ( String str ) { if ( str == " " ) return " a " ; int i = str . length ( ) - 1 ; while ( str . charAt ( i ) == ' z ' && i >= 0 ) i -- ; if ( i == - 1 ) str = str + ' a ' ; else str = str . substring ( 0 , i ) + ( char ) ( ( int ) ( str . charAt ( i ) ) + 1 ) + str . substring ( i + 1 ) ; return str ; }
SCHEDUL@@ E_@@ J@@ OBS@@ _SERVER_@@ GE@@ TS_@@ EQUAL_@@ LOAD | static int solve ( int a [ ] , int b [ ] , int n ) { int i ; int s = 0 ; for ( i = 0 ; i < n ; i ++ ) s += ( a [ i ] + b [ i ] ) ; if ( n == 1 ) return a [ 0 ] + b [ 0 ] ; if ( s % n != 0 ) return - 1 ; int x = s / n ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) return - 1 ; if ( i > 0 ) { a [ i ] += b [ i - 1 ] ; b [ i - 1 ] = 0 ; } if ( a [ i ] == x ) continue ; int y = a [ i ] + b [ i ] ; if ( i + 1 < n ) y += b [ i + 1 ] ; if ( y == x ) { a [ i ] = y ; b [ i ] = 0 ; continue ; } if ( a [ i ] + b [ i ] == x ) { a [ i ] += b [ i ] ; b [ i ] = 0 ; continue ; } if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) { a [ i ] += b [ i + 1 ] ; b [ i + 1 ] = 0 ; continue ; } return - 1 ; } for ( i = 0 ; i < n ; i ++ ) if ( b [ i ] != 0 ) return - 1 ; return x ; }
FORM_@@ MINIMUM_@@ NUMBER_@@ FROM_@@ GI@@ VEN@@ _SEQU@@ ENCE_@@ 1 | static String getMin@@ Number@@ For@@ Pattern ( String seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return " - 1" ; char result [ ] = new char [ n + 1 ] ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n || seq . charAt ( i ) == ' I ' ) { for ( int j = i - 1 ; j >= - 1 ; j -- ) { result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++ ) ; if ( j >= 0 && seq . charAt ( j ) == ' I ' ) break ; } } } return new String ( result ) ; }
SHUFF@@ LE_@@ 2@@ N_@@ INTEG@@ ERS_@@ FORMAT_@@ A@@ 1_@@ B@@ 1_@@ A@@ 2_@@ B@@ 2_@@ A@@ 3_@@ B@@ 3_@@ BN_@@ WITH@@ OUT_@@ USING_@@ EX@@ TRA@@ _SPACE | static void shuffle@@ Array ( int a [ ] , int n ) { for ( int i = 0 , q = 1 , k = n ; i < n ; i ++ , k ++ , q ++ ) for ( int j = k ; j > i + q ; j -- ) { int temp = a [ j - 1 ] ; a [ j - 1 ] = a [ j ] ; a [ j ] = temp ; } }
FIND_@@ REPE@@ TI@@ TIVE_@@ ELEMENT_@@ 1_@@ N_@@ 1_1 | static int find@@ Repe@@ ating ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . contains ( arr [ i ] ) ) return arr [ i ] ; s . add ( arr [ i ] ) ; } return - 1 ; }
C_@@ PROGR@@ AM@@ _SUB@@ TRAC@@ TION_@@ MA@@ TIC@@ ES | static void multiply ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; }
FIRST_@@ NEGATIVE_@@ INTEGER_@@ EVER@@ Y_@@ WINDOW@@ _SIZE_@@ K | static void print@@ First@@ Negative@@ Integer ( int arr [ ] , int n , int k ) { boolean flag ; for ( int i = 0 ; i < ( n - k + 1 ) ; i ++ ) { flag = false ; for ( int j = 0 ; j < k ; j ++ ) { if ( arr [ i + j ] < 0 ) { System . out . print ( ( arr [ i + j ] ) + " ▁ " ) ; flag = true ; break ; } } if ( ! flag ) System . out . print ( "0" + " ▁ " ) ; } }
NUMBER_@@ FULL_@@ BINARY_@@ TRE@@ ES_@@ NODE_@@ PRODUCT_@@ CHILDREN | static int nu@@ mo@@ ff@@ bt ( int arr [ ] , int n ) { int max@@ value = - 2147483647 ; int min@@ value = 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { max@@ value = Math . max ( max@@ value , arr [ i ] ) ; min@@ value = Math . min ( min@@ value , arr [ i ] ) ; } int mark [ ] = new int [ max@@ value + 2 ] ; int value [ ] = new int [ max@@ value + 2 ] ; Arrays . fill ( mark , 0 ) ; Arrays . fill ( value , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { mark [ arr [ i ] ] = 1 ; value [ arr [ i ] ] = 1 ; } int ans = 0 ; for ( int i = min@@ value ; i <= max@@ value ; i ++ ) { if ( mark [ i ] != 0 ) { for ( int j = i + i ; j <= max@@ value && j / i <= i ; j += i ) { if ( mark [ j ] == 0 ) continue ; value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ; if ( i != j / i ) value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ; } } ans += value [ i ] ; } return ans ; }
TRIANG@@ ULAR_@@ MATCH@@ STICK_@@ NUMBER | public static int numberOf@@ S@@ ticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
K_@@ MAX@@ IM@@ UM@@ _S@@ UM_@@ COMBIN@@ ATION@@ S_@@ TWO_@@ ARRAY@@ S | static void K@@ Max@@ Combin@@ ations ( int A [ ] , int B [ ] , int N , int K ) { PriorityQueue < Integer > pq = new PriorityQueue < Integer > ( Collections . reverse@@ Order ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) pq . add ( A [ i ] + B [ j ] ) ; int count = 0 ; while ( count < K ) { System . out . println ( pq . peek ( ) ) ; pq . remove ( ) ; count ++ ; } }
CONSTRUC@@ T_@@ ARRAY_@@ PAIR@@ _S@@ UM_@@ ARRAY | static void construct@@ Arr ( int arr [ ] , int pair [ ] , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }
CHECK_@@ HALF_@@ STRING_@@ CHARACTER_@@ FREQU@@ ENCY_@@ CHARACTER | static boolean check@@ Correct@@ Or@@ Not ( String s ) { int [ ] count@@ 1 = new int [ MAX_@@ CHAR ] ; int [ ] count2 = new int [ MAX_@@ CHAR ] ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count@@ 1 [ s . charAt ( i ) - ' a ' ] ++ ; count2 [ s . charAt ( j ) - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_@@ CHAR ; i ++ ) if ( count@@ 1 [ i ] != count2 [ i ] ) return false ; return true ; }
MINI@@ MI@@ ZE_@@ THE_@@ MAXIMUM_@@ DIFF@@ ER@@ ENCE_@@ BETWE@@ EN_@@ THE_@@ HE@@ IGHT@@ S | static int getMin@@ Diff ( int arr [ ] , int n , int k ) { if ( n == 1 ) return 0 ; Arrays . sort ( arr ) ; int ans = arr [ n - 1 ] - arr [ 0 ] ; int small = arr [ 0 ] + k ; int big = arr [ n - 1 ] - k ; int temp = 0 ; if ( small > big ) { temp = small ; small = big ; big = temp ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { int subtract = arr [ i ] - k ; int add = arr [ i ] + k ; if ( subtract >= small || add <= big ) continue ; if ( big - subtract <= add - small ) small = subtract ; else big = add ; } return Math . min ( ans , big - small ) ; }
MINIMUM_@@ POSSI@@ BLE_@@ VALUE_@@ AI_@@ A@@ J_@@ K_@@ GI@@ V@@ EN_@@ ARRAY_@@ K | static void pairs ( int arr [ ] , int n , int k ) { int smallest = Integer . MAX_VALUE ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } System . out . println ( " Min@@ imal ▁ Value ▁ = ▁ " + smallest ) ; System . out . println ( " Total ▁ Pairs ▁ = ▁ " + count ) ; }
SIZE_@@ SUB@@ ARRAY_@@ MAX@@ IM@@ UM@@ _S@@ UM | static int max@@ Sub@@ Array@@ Sum ( int a [ ] , int size ) { int max_@@ so@@ _f@@ ar = Integer . MIN_VALUE , max_@@ ending_@@ here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_@@ ending_@@ here += a [ i ] ; if ( max_@@ so@@ _f@@ ar < max_@@ ending_@@ here ) { max_@@ so@@ _f@@ ar = max_@@ ending_@@ here ; start = s ; end = i ; } if ( max_@@ ending_@@ here < 0 ) { max_@@ ending_@@ here = 0 ; s = i + 1 ; } } return ( end - start + 1 ) ; }
MINIMUM_@@ NUMBER_@@ OF@@ _S@@ QUAR@@ ES_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL@@ S_TO_@@ GI@@ V@@ EN_@@ NUMBER_@@ N_@@ 1 | static int getMin@@ Squ@@ ares ( int n ) { if ( n <= 3 ) return n ; int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( int x = 1 ; x <= Math . ceil ( Math . sqrt ( i ) ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } int res = dp [ n ] ; return res ; }
DI@@ VISIBILITY_@@ BY_@@ 7 | static boolean is@@ Di@@ visible@@ By@@ 7 ( int num ) { if ( num < 0 ) return is@@ Di@@ visible@@ By@@ 7 ( - num ) ; if ( num == 0 || num == 7 ) return true ; if ( num < 10 ) return false ; return is@@ Di@@ visible@@ By@@ 7 ( num / 10 - 2 * ( num - num / 10 * 10 ) ) ; }
POSITION_@@ OF_@@ RIGHT@@ MO@@ ST@@ _SET_@@ BIT_@@ 2 | static int R@@ ight_@@ most_@@ set@@ bit ( int num ) { int pos = 1 ; for ( int i = 0 ; i < INT_@@ SIZE ; i ++ ) { if ( ( num & ( 1 << i ) ) == 0 ) pos ++ ; else break ; } return pos ; }
EF@@ FI@@ CI@@ ENT_@@ WA@@ Y_@@ TO_@@ MULTI@@ PLY_@@ WITH_@@ 7 | static int multiply@@ By@@ Se@@ ven ( int n ) { return ( ( n << 3 ) - n ) ; }
NEXT_@@ HIGH@@ ER_@@ NUMBER_@@ WITH@@ _S@@ AME_@@ NUMBER_@@ OF@@ _SET_@@ BITS | static int sno@@ ob ( int x ) { int right@@ One , next@@ High@@ er@@ One@@ Bit , right@@ One@@ s@@ Pattern , next = 0 ; if ( x > 0 ) { right@@ One = x & - x ; next@@ High@@ er@@ One@@ Bit = x + right@@ One ; right@@ One@@ s@@ Pattern = x ^ next@@ High@@ er@@ One@@ Bit ; right@@ One@@ s@@ Pattern = ( right@@ One@@ s@@ Pattern ) / right@@ One ; right@@ One@@ s@@ Pattern >>= 2 ; next = next@@ High@@ er@@ One@@ Bit | right@@ One@@ s@@ Pattern ; } return next ; }
CHANGE_@@ ARRAY_@@ PER@@ MU@@ TATION_@@ NUMB@@ ERS_@@ 1_@@ N | static void make@@ Permutation ( int [ ] a , int n ) { HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( a [ i ] ) ) { count . put ( a [ i ] , count . get ( a [ i ] ) + 1 ) ; } else { count . put ( a [ i ] , 1 ) ; } } int next_@@ missing = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( a [ i ] ) && count . get ( a [ i ] ) != 1 || a [ i ] > n || a [ i ] < 1 ) { count . put ( a [ i ] , count . get ( a [ i ] ) - 1 ) ; while ( count . containsKey ( next_@@ missing ) ) next_@@ missing ++ ; a [ i ] = next_@@ missing ; count . put ( next_@@ missing , 1 ) ; } } }
MAXIMUM_@@ AREA_@@ QUAD@@ RI@@ LAT@@ ER@@ AL | static double max@@ Area ( double a , double b , double c , double d ) { double semi@@ per@@ imeter = ( a + b + c + d ) / 2 ; return Math . sqrt ( ( semi@@ per@@ imeter - a ) * ( semi@@ per@@ imeter - b ) * ( semi@@ per@@ imeter - c ) * ( semi@@ per@@ imeter - d ) ) ; }
REPL@@ ACE_@@ OC@@ CURR@@ EN@@ CES_@@ STRING_@@ AB_@@ C_@@ WITH@@ OUT_@@ USING_@@ EX@@ TRA@@ _SPACE_@@ 1 | static void translate ( char str [ ] ) { int len = str . length ; if ( len < 2 ) return ; int i = 0 ; int j = 0 ; while ( j < len - 1 ) { if ( str [ j ] == ' A ' && str [ j + 1 ] == ' B ' ) { j = j + 2 ; str [ i ++ ] = ' C ' ; continue ; } str [ i ++ ] = str [ j ++ ] ; } if ( j == len - 1 ) str [ i ++ ] = str [ j ] ; str [ i ] = ' ▁ ' ; str [ len - 1 ] = ' ▁ ' ; }
FIND_@@ POWER_@@ POWER_@@ MOD_@@ PRI@@ ME | static int Calculate ( int A , int B , int C , int M ) { int res , ans ; res = power ( B , C , M - 1 ) ; ans = power ( A , res , M ) ; return ans ; }
CHECK_@@ EXI@@ ST_@@ TWO_@@ ELEMEN@@ TS_@@ ARRAY_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL@@ _S@@ UM_@@ REST_@@ ARRAY | static boolean check@@ Pair ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } if ( sum % 2 != 0 ) { return false ; } sum = sum / 2 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int val = sum - arr [ i ] ; if ( s . contains ( val ) && val == ( int ) s . toArray ( ) [ s . size ( ) - 1 ] ) { System . out . printf ( " Pair ▁ elements ▁ are ▁ % d ▁ and ▁ % d \n " , arr [ i ] , val ) ; return true ; } s . add ( arr [ i ] ) ; } return false ; }
PROGRAM_@@ FOR@@ _SUR@@ FACE_@@ AREA_@@ OF_@@ OC@@ TA@@ HE@@ DRO@@ N | static double surface_@@ area_@@ oc@@ ta@@ hedron ( double side ) { return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ; }
FIND_@@ A@@ _SPECI@@ FIC_@@ PA@@ IR_@@ IN_@@ MATRIX | static int find@@ Max@@ Value ( int N , int mat [ ] [ ] ) { int maxValue = Integer . MIN_VALUE ; for ( int a = 0 ; a < N - 1 ; a ++ ) for ( int b = 0 ; b < N - 1 ; b ++ ) for ( int d = a + 1 ; d < N ; d ++ ) for ( int e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; }
MULTI@@ PLY_@@ TWO_@@ NUMB@@ ERS_@@ WITH@@ OUT_@@ USING_@@ MULTI@@ PLY_@@ DI@@ VISI@@ ON_@@ BIT@@ WI@@ SE_@@ OPER@@ ATOR@@ S_@@ AND_@@ NO_@@ LOOP@@ S | static int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; return - 1 ; }
FIND_@@ TR@@ IP@@ LET@@ S_@@ ARRAY_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL_@@ ZERO_@@ 1 | static void find@@ Trip@@ lets ( int arr [ ] , int n ) { boolean found = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int j = i + 1 ; j < n ; j ++ ) { int x = - ( arr [ i ] + arr [ j ] ) ; if ( s . contains ( x ) ) { System . out . printf ( " % d ▁ % d ▁ % d \n " , x , arr [ i ] , arr [ j ] ) ; found = true ; } else { s . add ( arr [ j ] ) ; } } } if ( found == false ) { System . out . printf ( " ▁ No ▁ Trip@@ let ▁ Found \n " ) ; } }
FIND_@@ MAXIMUM_@@ VALUE_@@ OF@@ _S@@ UM_@@ I@@ AR@@ RI@@ _@@ WITH_@@ ONLY_@@ ROTA@@ TIONS_@@ ON_@@ GI@@ V@@ EN_@@ ARRAY_@@ ALLOWED | static int max@@ Sum ( ) { int arr@@ Sum = 0 ; int curr@@ Val = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr@@ Sum = arr@@ Sum + arr [ i ] ; curr@@ Val = curr@@ Val + ( i * arr [ i ] ) ; } int maxVal = curr@@ Val ; for ( int j = 1 ; j < arr . length ; j ++ ) { curr@@ Val = curr@@ Val + arr@@ Sum - arr . length * arr [ arr . length - j ] ; if ( curr@@ Val > maxVal ) maxVal = curr@@ Val ; } return maxVal ; }
PROGRAM_@@ FOR@@ _SCAL@@ AR_@@ MULTIP@@ LIC@@ ATION_@@ OF_@@ A_@@ MATRIX | static void scalar@@ Product@@ Mat ( int mat [ ] [ ] , int k ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) mat [ i ] [ j ] = mat [ i ] [ j ] * k ; }
PRINT_@@ SQU@@ AR@@ ES_@@ FIRST_@@ N_@@ N@@ ATUR@@ AL_@@ NUMB@@ ERS_@@ WITH@@ OUT_@@ USING_@@ 1 | static void print@@ Squ@@ ares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { System . out . print ( square + " ▁ " ) ; square = square + odd ; odd = odd + 2 ; } }
N@@ TH_@@ PEN@@ TAG@@ ON@@ AL_@@ NUMBER | int pent@@ ag@@ onal@@ Num ( int n ) { return ( 3 * n * n - n ) / 2 ; }
COUNT_@@ ARRAY@@ S_@@ AD@@ J@@ AC@@ ENT_@@ ELEMEN@@ TS_@@ ONE_@@ DI@@ VI@@ DE_@@ AN@@ OTHER | static int nu@@ mo@@ f@@ Array ( int n , int m ) { int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; Vector < Integer > [ ] di = new Vector [ MAX ] ; Vector < Integer > [ ] mu = new Vector [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < MAX ; i ++ ) { di [ i ] = new Vector < > ( ) ; mu [ i ] = new Vector < > ( ) ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 2 * i ; j <= m ; j += i ) { di [ j ] . add ( i ) ; mu [ i ] . add ( j ) ; } di [ i ] . add ( i ) ; } for ( int i = 1 ; i <= m ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; for ( Integer x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; for ( Integer x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { ans += dp [ n ] [ i ] ; di [ i ] . clear ( ) ; mu [ i ] . clear ( ) ; } return ans ; }
0_@@ 1_@@ KN@@ AP@@ S@@ ACK_@@ PRO@@ BLE@@ M_@@ D@@ P_@@ 10 | static int kn@@ ap@@ S@@ ack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return kn@@ ap@@ S@@ ack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + kn@@ ap@@ S@@ ack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , kn@@ ap@@ S@@ ack ( W , wt , val , n - 1 ) ) ; }
FIND_@@ TR@@ IP@@ LET@@ S_@@ ARRAY_@@ WHO@@ SE_@@ S@@ UM_@@ EQUAL_@@ ZERO | static void find@@ Trip@@ lets ( int [ ] arr , int n ) { boolean found = true ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) { System . out . print ( arr [ i ] ) ; System . out . print ( " ▁ " ) ; System . out . print ( arr [ j ] ) ; System . out . print ( " ▁ " ) ; System . out . print ( arr [ k ] ) ; System . out . print ( " \n " ) ; found = true ; } } } } if ( found == false ) System . out . println ( " ▁ not ▁ exist ▁ " ) ; }
COUNT_@@ NUMBER_@@ WAY@@ S_@@ REACH_@@ GI@@ VEN@@ _S@@ CORE_@@ GAME | static int count ( int n ) { int table [ ] = new int [ n + 1 ] , i ; Arrays . fill ( table , 0 ) ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }
MAX@@ IM@@ UM@@ _S@@ UM_@@ ABSOL@@ UTE_@@ DIFF@@ ER@@ ENCE_@@ ARRAY | static int Max@@ Sum@@ Difference ( Integer [ ] a , int n ) { List < Integer > final@@ Sequence = new ArrayList < Integer > ( ) ; Arrays . sort ( a ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { final@@ Sequence . add ( a [ i ] ) ; final@@ Sequence . add ( a [ n - i - 1 ] ) ; } int Maximum@@ Sum = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { Maximum@@ Sum = Maximum@@ Sum + Math . abs ( final@@ Sequence . get ( i ) - final@@ Sequence . get ( i + 1 ) ) ; } Maximum@@ Sum = Maximum@@ Sum + Math . abs ( final@@ Sequence . get ( n - 1 ) - final@@ Sequence . get ( 0 ) ) ; return Maximum@@ Sum ; }
PROGRAM_@@ FIND_@@ M@@ ID_@@ POINT_@@ LINE | static void midpoint ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( x1 + x2 ) / 2 + " ▁ , ▁ " + ( y1 + y2 ) / 2 ) ; }
ALTER@@ NATIVE_@@ SOR@@ TING | static void alternate@@ Sort ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int i = 0 , j = n - 1 ; while ( i < j ) { System . out . print ( arr [ j -- ] + " ▁ " ) ; System . out . print ( arr [ i ++ ] + " ▁ " ) ; } if ( n % 2 != 0 ) System . out . print ( arr [ i ] ) ; }
NUMBER@@ _SUB@@ ARRAY@@ S_S@@ UM_@@ EXAC@@ TL@@ Y_@@ EQUAL_@@ K | static int find@@ Sub@@ array@@ Sum ( int arr [ ] , int n , int sum ) { HashMap < Integer , Integer > prev@@ Sum = new HashMap < > ( ) ; int res = 0 ; int curr@@ sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr@@ sum += arr [ i ] ; if ( curr@@ sum == sum ) res ++ ; if ( prev@@ Sum . containsKey ( curr@@ sum - sum ) ) res += prev@@ Sum . get ( curr@@ sum - sum ) ; Integer count = prev@@ Sum . get ( curr@@ sum ) ; if ( count == null ) prev@@ Sum . put ( curr@@ sum , 1 ) ; else prev@@ Sum . put ( curr@@ sum , count + 1 ) ; } return res ; }
FIND_@@ THE_@@ ELEMENT_@@ TH@@ AT_@@ AP@@ PE@@ AR@@ S_@@ ON@@ CE_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ ARRAY | public static void search ( int [ ] arr , int low , int high ) { if ( low > high ) return ; if ( low == high ) { System . out . println ( " The ▁ required ▁ element ▁ is ▁ " + arr [ low ] ) ; return ; } int mid = ( low + high ) / 2 ; if ( mid % 2 == 0 ) { if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr , mid + 2 , high ) ; else search ( arr , low , mid ) ; } else if ( mid % 2 == 1 ) { if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr , mid + 1 , high ) ; else search ( arr , low , mid - 1 ) ; } }
FORM_S@@ MAL@@ LE@@ ST_@@ NUMBER_@@ USING_@@ ONE@@ _SW@@ AP_@@ OPERATION | public static String smalle@@ st@@ Number ( String str ) { char [ ] num = str . toCharArray ( ) ; int n = str . length ( ) ; int [ ] right@@ Min = new int [ n ] ; right@@ Min [ n - 1 ] = - 1 ; int right = n - 1 ; for ( int i = n - 2 ; i >= 1 ; i -- ) { if ( num [ i ] > num [ right ] ) right@@ Min [ i ] = right ; else { right@@ Min [ i ] = - 1 ; right = i ; } } int small = - 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( num [ i ] != '0' ) { if ( small == - 1 ) { if ( num [ i ] < num [ 0 ] ) small = i ; } else if ( num [ i ] < num [ small ] ) small = i ; } if ( small != - 1 ) { char temp ; temp = num [ 0 ] ; num [ 0 ] = num [ small ] ; num [ small ] = temp ; } else { for ( int i = 1 ; i < n ; i ++ ) { if ( right@@ Min [ i ] != - 1 ) { char temp ; temp = num [ i ] ; num [ i ] = num [ right@@ Min [ i ] ] ; num [ right@@ Min [ i ] ] = temp ; break ; } } } return ( new String ( num ) ) ; }
PROGRAM_@@ ARE@@ A@@ _S@@ QU@@ ARE | static int area@@ Square ( int side ) { int area = side * side ; return area ; }
FIND_@@ DAY_OF_@@ THE_@@ WEEK_@@ FOR_@@ A_@@ GI@@ V@@ EN_@@ DATE | static int day@@ of@@ week ( int d , int m , int y ) { int t [ ] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ; y -= ( m < 3 ) ? 1 : 0 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; }
CHECK_@@ QUEUE_@@ CAN@@ _S@@ OR@@ TED_@@ AN@@ OTHER_@@ QUEUE_@@ USING_@@ STACK | static boolean check@@ Sorted ( int n ) { Stack < Integer > st = new Stack < Integer > ( ) ; int expected = 1 ; int f@@ nt ; while ( q . size ( ) != 0 ) { f@@ nt = q . peek ( ) ; q . poll ( ) ; if ( f@@ nt == expected ) expected ++ ; else { if ( st . size ( ) == 0 ) { st . push ( f@@ nt ) ; } else if ( st . size ( ) != 0 && st . peek ( ) < f@@ nt ) { return false ; } else st . push ( f@@ nt ) ; } while ( st . size ( ) != 0 && st . peek ( ) == expected ) { st . pop ( ) ; expected ++ ; } } if ( expected - 1 == n && st . size ( ) == 0 ) return true ; return false ; }
SORT_@@ ARRAY_@@ CONTA@@ IN_@@ 1_@@ N_@@ VALUES | static void sor@@ tit ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = i + 1 ; } }
LC@@ S_@@ LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ SEQU@@ ENCE_@@ THRE@@ E_@@ STRING@@ S_@@ 1 | static int l@@ cs@@ Of@@ 3 ( int i , int j , int k ) { if ( i == - 1 || j == - 1 || k == - 1 ) { return 0 ; } if ( dp [ i ] [ j ] [ k ] != - 1 ) { return dp [ i ] [ j ] [ k ] ; } if ( X . charAt ( i ) == Y . charAt ( j ) && Y . charAt ( j ) == Z . charAt ( k ) ) { return dp [ i ] [ j ] [ k ] = 1 + l@@ cs@@ Of@@ 3 ( i - 1 , j - 1 , k - 1 ) ; } else { return dp [ i ] [ j ] [ k ] = Math . max ( Math . max ( l@@ cs@@ Of@@ 3 ( i - 1 , j , k ) , l@@ cs@@ Of@@ 3 ( i , j - 1 , k ) ) , l@@ cs@@ Of@@ 3 ( i , j , k - 1 ) ) ; } }
LOWER_@@ INSER@@ TION_@@ POINT | static int Lower@@ Insertion@@ Point ( int arr [ ] , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lower@@ Pnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lower@@ Pnt = i ; i = i * 2 ; } while ( lower@@ Pnt < n && arr [ lower@@ Pnt ] < X ) lower@@ Pnt ++ ; return lower@@ Pnt ; }
CONSTRUC@@ T_@@ LE@@ XI@@ CO@@ GRAPHIC@@ AL@@ LY@@ _S@@ MAL@@ LE@@ ST_@@ PA@@ LIN@@ DRO@@ ME | static String construct@@ Pal@@ in ( char [ ] str , int len ) { int i = 0 , j = len - 1 ; for ( ; i < j ; i ++ , j -- ) { if ( str [ i ] == str [ j ] && str [ i ] != ' * ' ) continue ; else if ( str [ i ] == str [ j ] && str [ i ] == ' * ' ) { str [ i ] = ' a ' ; str [ j ] = ' a ' ; continue ; } else if ( str [ i ] == ' * ' ) { str [ i ] = str [ j ] ; continue ; } else if ( str [ j ] == ' * ' ) { str [ j ] = str [ i ] ; continue ; } System . out . println ( " Not ▁ Possible " ) ; return " " ; } return String . valueOf ( str ) ; }
SECTION_@@ FOR@@ MUL@@ A_@@ POINT_@@ DI@@ VIDE@@ S_@@ LINE_@@ GI@@ V@@ EN_@@ RATIO | static void section ( double x1 , double x2 , double y1 , double y2 , double m , double n ) { double x = ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ) ; double y = ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) ; System . out . println ( " ( " + x + " , ▁ " + y + " ) " ) ; }
SQU@@ ARE_@@ ROOT_@@ NUMBER_@@ USING_@@ LOG | static double square@@ Root ( double n ) { return Math . pow ( 2 , 0.5 * ( Math . log ( n ) / Math . log ( 2 ) ) ) ; }
MAXI@@ MI@@ ZE_@@ S@@ UM_@@ AR@@ RI@@ I | static int max@@ Sum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; }
STRING_@@ K_@@ DISTIN@@ CT_@@ CHARAC@@ TER@@ S_@@ NO_@@ CHARAC@@ TER@@ S_@@ AD@@ J@@ AC@@ ENT | static String find@@ String ( int n , int k ) { String res = " " ; for ( int i = 0 ; i < k ; i ++ ) res = res + ( char ) ( ' a ' + i ) ; int count = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { res = res + ( char ) ( ' a ' + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; }
COUNT_@@ WOR@@ DS_@@ WHO@@ SE_@@ TH_@@ LET@@ TER_@@ EI@@ THER_@@ 1_@@ TH_@@ TH_@@ I@@ 1_@@ TH_@@ LET@@ TER_@@ GI@@ V@@ EN_@@ WORD | static int count@@ Words ( String str , int len ) { int count = 1 ; if ( len == 1 ) return count ; if ( str . charAt ( 0 ) == str . charAt ( 1 ) ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < len - 1 ; j ++ ) { if ( str . charAt ( j ) == str . charAt ( j - 1 ) && str . charAt ( j ) == str . charAt ( j + 1 ) ) count *= 1 ; else if ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) count *= 2 ; else count *= 3 ; } if ( str . charAt ( len - 1 ) == str . charAt ( len - 2 ) ) count *= 1 ; else count *= 2 ; return count ; }
NUMBER_@@ JUM@@ P_@@ REQUIRED_@@ GI@@ V@@ EN_@@ LENGTH_@@ REACH_@@ POINT_@@ FORM_@@ D_@@ 0_@@ ORIG@@ IN_@@ 2D_@@ PLAN@@ E | static int min@@ Jump@@ s ( int a , int b , int d ) { int temp = a ; a = Math . min ( a , b ) ; b = Math . max ( temp , b ) ; if ( d >= b ) return ( d + b - 1 ) / b ; if ( d == 0 ) return 0 ; if ( d == a ) return 1 ; return 2 ; }
S@@ UM_@@ FAC@@ TOR@@ S_@@ NUMBER_@@ 1 | static int su@@ mo@@ f@@ Factors ( int n ) { int res = 1 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { int curr_@@ sum = 1 ; int curr_@@ term = 1 ; while ( n % i == 0 ) { n = n / i ; curr_@@ term *= i ; curr_@@ sum += curr_@@ term ; } res *= curr_@@ sum ; } if ( n > 2 ) res *= ( 1 + n ) ; return res ; }
DELETE_@@ CON@@ SEC@@ UTI@@ VE_@@ WOR@@ DS@@ _SEQU@@ ENCE | static int remove@@ Con@@ sec@@ uti@@ ve@@ Same ( Vector < String > v ) { int n = v . size ( ) ; for ( int i = 0 ; i < n - 1 ; ) { if ( v . get ( i ) . equals ( v . get ( i + 1 ) ) ) { v . remove ( i ) ; v . remove ( i ) ; if ( i > 0 ) i -- ; n = n - 2 ; } else i ++ ; } return v . size ( ) ; }
COUNT_@@ NUMBER_@@ BINARY_@@ STRING@@ S_@@ WITH@@ OUT_@@ CON@@ SEC@@ UTI@@ VE_@@ 1@@ S | static int count@@ Strings ( int n ) { int a [ ] = new int [ n ] ; int b [ ] = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return a [ n - 1 ] + b [ n - 1 ] ; }
FIND_@@ THE_@@ MISSING_@@ NUMBER | static int get@@ Missing@@ No ( int a [ ] , int n ) { int i , total ; total = ( n + 1 ) * ( n + 2 ) / 2 ; for ( i = 0 ; i < n ; i ++ ) total -= a [ i ] ; return total ; }
SQU@@ ARE_@@ ROOT_@@ OF_@@ A_@@ PER@@ F@@ ECT_@@ SQUARE | static float square@@ Root ( float n ) { float x = n ; float y = 1 ; double e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }
SUB@@ SET_@@ S@@ UM_@@ PRO@@ BLE@@ M_@@ OS@@ UM@@ _SPACE | static boolean isSub@@ set@@ Sum ( int arr [ ] , int n , int sum ) { boolean subset [ ] [ ] = new boolean [ 2 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }
MULTIP@@ LIC@@ ATI@@ VE_@@ INVER@@ SE_@@ UN@@ DER_@@ MODUL@@ O_@@ M | static int mod@@ Inverse ( int a , int m ) { a = a % m ; for ( int x = 1 ; x < m ; x ++ ) if ( ( a * x ) % m == 1 ) return x ; return 1 ; }
COMP@@ UTE_@@ AVER@@ AGE_@@ TWO_@@ NUMB@@ ERS_@@ WITH@@ OUT_@@ OVERFLOW | static int compute_@@ average ( int a , int b ) { return ( a + b ) / 2 ; }
RE@@ PRES@@ ENT_@@ GI@@ VEN@@ _SET_@@ POINT@@ S_@@ BE@@ ST_@@ POSSI@@ BLE_@@ STR@@ AI@@ GHT_@@ LINE | static void best@@ Approxim@@ ate ( int x [ ] , int y [ ] ) { int n = x . length ; double m , c , sum@@ _x = 0 , sum_@@ y = 0 , sum_@@ xy = 0 , sum_@@ x2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum@@ _x += x [ i ] ; sum_@@ y += y [ i ] ; sum_@@ xy += x [ i ] * y [ i ] ; sum_@@ x2 += pow ( x [ i ] , 2 ) ; } m = ( n * sum_@@ xy - sum@@ _x * sum_@@ y ) / ( n * sum_@@ x2 - pow ( sum@@ _x , 2 ) ) ; c = ( sum_@@ y - m * sum@@ _x ) / n ; System . out . println ( " m ▁ = ▁ " + m ) ; System . out . println ( " c ▁ = ▁ " + c ) ; }
SP@@ LIT_@@ ARRAY_@@ ADD_@@ FIRST_@@ PART_@@ END | public static void split@@ Arr ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }
MAXIMUM_@@ POSSI@@ BLE_@@ DIFF@@ ER@@ ENCE_@@ TW@@ O@@ _SUB@@ SE@@ TS_@@ ARRAY | static int max@@ Diff ( int [ ] arr , int n ) { int Subset@@ Sum@@ _1 = 0 , Subset@@ Sum@@ _2 = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { boolean is@@ Single@@ Occur@@ ance = true ; for ( int j = i + 1 ; j <= n - 1 ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { is@@ Single@@ Occur@@ ance = false ; arr [ i ] = arr [ j ] = 0 ; break ; } } if ( is@@ Single@@ Occur@@ ance ) { if ( arr [ i ] > 0 ) Subset@@ Sum@@ _1 += arr [ i ] ; else Subset@@ Sum@@ _2 += arr [ i ] ; } } return Math . abs ( Subset@@ Sum@@ _1 - Subset@@ Sum@@ _2 ) ; }
LON@@ GE@@ ST@@ _SUB@@ SEQU@@ ENCE_@@ DIFF@@ ER@@ ENCE_@@ AD@@ J@@ AC@@ ENTS_@@ ONE@@ _SET_@@ 2 | static int long@@ Len@@ Sub ( int [ ] arr , int n ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int long@@ Len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( um . containsKey ( arr [ i ] - 1 ) && len < um . get ( arr [ i ] - 1 ) ) len = um . get ( arr [ i ] - 1 ) ; if ( um . containsKey ( arr [ i ] + 1 ) && len < um . get ( arr [ i ] + 1 ) ) len = um . get ( arr [ i ] + 1 ) ; um . put ( arr [ i ] , len + 1 ) ; if ( long@@ Len < um . get ( arr [ i ] ) ) long@@ Len = um . get ( arr [ i ] ) ; } return long@@ Len ; }
LON@@ GE@@ ST_@@ REPE@@ ATE@@ D@@ _SUB@@ SEQU@@ ENCE_@@ 1 | static String lon@@ gest@@ Repeated@@ Sub@@ Seq ( String str ) { int n = str . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; String res = " " ; int i = n , j = n ; while ( i > 0 && j > 0 ) { if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) { res = res + str . charAt ( i - 1 ) ; i -- ; j -- ; } else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ; else j -- ; } String reverse = " " ; for ( int k = res . length ( ) - 1 ; k >= 0 ; k -- ) { reverse = reverse + res . charAt ( k ) ; } return reverse ; }
FIND_@@ INDEX_@@ MAXIMUM_@@ OC@@ CURR@@ ING_@@ ELEMENT_@@ EQUAL_@@ PRO@@ B@@ ABILITY | static void find@@ Random@@ Index@@ Of@@ Max ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } int max_@@ element = Integer . MIN_VALUE ; int max_@@ so@@ _f@@ ar = Integer . MIN_VALUE ; for ( Map . Entry < Integer , Integer > p : mp . entrySet ( ) ) { if ( p . getValue ( ) > max_@@ so@@ _f@@ ar ) { max_@@ so@@ _f@@ ar = p . getValue ( ) ; max_@@ element = p . getKey ( ) ; } } int r = ( int ) ( ( new Random ( ) . nextInt ( max_@@ so@@ _f@@ ar ) % max_@@ so@@ _f@@ ar ) + 1 ) ; for ( int i = 0 , count = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max_@@ element ) count ++ ; if ( count == r ) { System . out . print ( " Element ▁ with ▁ maximum ▁ frequency ▁ present ▁ " + " at ▁ index ▁ " + i + " \n " ) ; break ; } } }
CHECK_@@ NUMBER_@@ IS_@@ PER@@ F@@ ECT_@@ SQU@@ ARE_@@ USING_@@ ADDI@@ TION@@ SUB@@ TRAC@@ TION | static boolean is@@ Per@@ fec@@ t@@ Square ( int n ) { for ( int sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; }
N_@@ BON@@ ACC@@ I_@@ NUMB@@ ERS_@@ 1 | static void bon@@ ac@@ ci@@ series ( int n , int m ) { int a [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) a [ i ] = 0 ; a [ n - 1 ] = 1 ; a [ n ] = 1 ; for ( int i = n + 1 ; i < m ; i ++ ) a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; }
COUNT_@@ INDEX_@@ PAIR@@ S_@@ EQUAL_@@ ELEMEN@@ TS_@@ ARRAY_@@ 1 | public static int count@@ Pairs ( int arr [ ] , int n ) { HashMap < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hm . containsKey ( arr [ i ] ) ) hm . put ( arr [ i ] , hm . get ( arr [ i ] ) + 1 ) ; else hm . put ( arr [ i ] , 1 ) ; } int ans = 0 ; for ( Map . Entry < Integer , Integer > it : hm . entrySet ( ) ) { int count = it . getValue ( ) ; ans += ( count * ( count - 1 ) ) / 2 ; } return ans ; }
SORT_@@ EV@@ EN_@@ PL@@ AC@@ ED_@@ ELEMEN@@ TS_@@ INCRE@@ AS@@ ING_@@ OD@@ D_@@ PL@@ AC@@ ED_@@ DECRE@@ AS@@ ING_@@ ORDER | static void bit@@ on@@ ic@@ Generator ( int arr [ ] , int n ) { Vector < Integer > even@@ Arr = new Vector < Integer > ( ) ; Vector < Integer > odd@@ Arr = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 1 ) { even@@ Arr . add ( arr [ i ] ) ; } else { odd@@ Arr . add ( arr [ i ] ) ; } } Collections . sort ( even@@ Arr ) ; Collections . sort ( odd@@ Arr , Collections . reverse@@ Order ( ) ) ; int i = 0 ; for ( int j = 0 ; j < even@@ Arr . size ( ) ; j ++ ) { arr [ i ++ ] = even@@ Arr . get ( j ) ; } for ( int j = 0 ; j < odd@@ Arr . size ( ) ; j ++ ) { arr [ i ++ ] = odd@@ Arr . get ( j ) ; } }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 9_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENT | static int bin@@ omi@@ al@@ Coeff ( int n , int k ) { if ( k == 0 || k == n ) return 1 ; return bin@@ omi@@ al@@ Coeff ( n - 1 , k - 1 ) + bin@@ omi@@ al@@ Coeff ( n - 1 , k ) ; }
WRITE_@@ A_@@ C_@@ PROGRAM_@@ TO_@@ FIND_@@ THE_@@ PAR@@ ITY_@@ OF_@@ AN_@@ UNSIGNED_@@ INTEGER | static boolean get@@ Par@@ ity ( int n ) { boolean parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
CHECK_@@ WHE@@ THER_@@ LARGE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 7 | static boolean is@@ Di@@ visible@@ 7 ( String num ) { int n = num . length ( ) ; if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ; if ( n % 3 == 1 ) num = "@@ 00" + num ; if ( n % 3 == 2 ) num = "0" + num ; n = num . length ( ) ; int g@@ Sum = 0 , p = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int group = 0 ; group += num . charAt ( i -- ) - '0' ; group += ( num . charAt ( i -- ) - '0' ) * 10 ; group += ( num . charAt ( i ) - '0' ) * 100 ; g@@ Sum = g@@ Sum + group * p ; p = p * - 1 ; } return ( g@@ Sum % 7 == 0 ) ; }
PRODUCT_@@ NODE@@ S_@@ K_@@ TH_@@ LEVEL_@@ TREE_@@ RE@@ PRESEN@@ TED_@@ STRING | static int product@@ At@@ K@@ th@@ Level ( String tree , int k ) { int level = - 1 ; int product = 1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree . charAt ( i ) == ' ( ' ) level ++ ; else if ( tree . charAt ( i ) == ' ) ' ) level -- ; else { if ( level == k ) product *= ( tree . charAt ( i ) - '0' ) ; } } return product ; }
CHECK_@@ WHE@@ THER_@@ GI@@ V@@ EN_@@ NUMBER_@@ EV@@ EN_@@ O@@ DD | public static boolean is@@ Even ( int n ) { return ( n % 2 == 0 ) ; }
COUNT_@@ GROUP@@ INGS_@@ NUMBER@@ _S@@ UM_@@ DIG@@ IT@@ S_@@ EVER@@ Y@@ _SUB_@@ GROUP_@@ LESS_@@ EQUAL@@ S_@@ IM@@ MEDI@@ ATE_@@ RIGHT_@@ SUB_@@ GROUP | static int count@@ Groups ( int position , int previous_@@ sum , int length , String num ) { if ( position == length ) return 1 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num . charAt ( i ) - '0' ) ; if ( sum >= previous_@@ sum ) res += count@@ Groups ( i + 1 , sum , length , num ) ; } return res ; }
FIND_@@ THE_@@ ELEMENT_@@ TH@@ AT_@@ OD@@ D_@@ NUMBER_OF_@@ TIME@@ S_IN_@@ O@@ LOG_@@ N_@@ TIME | static void search ( int arr [ ] , int low , int high ) { if ( low > high ) return ; if ( low == high ) { System . out . printf ( " The ▁ required ▁ element ▁ is ▁ % d ▁ " , arr [ low ] ) ; return ; } int mid = ( low + high ) / 2 ; if ( mid % 2 == 0 ) { if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr , mid + 2 , high ) ; else search ( arr , low , mid ) ; } else { if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr , mid + 1 , high ) ; else search ( arr , low , mid - 1 ) ; } }
DELETE_@@ CON@@ SEC@@ UTI@@ VE_@@ WOR@@ DS@@ _SEQU@@ ENCE_@@ 1 | static int remove@@ Con@@ sec@@ uti@@ ve@@ Same ( Vector < String > v ) { Stack < String > st = new Stack < > ( ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( st . empty ( ) ) st . push ( v . get ( i ) ) ; else { String str = st . peek ( ) ; if ( str . equals ( v . get ( i ) ) ) st . pop ( ) ; else st . push ( v . get ( i ) ) ; } } return st . size ( ) ; }
MINIMUM_@@ NUMBER_OF_@@ JUM@@ PS_@@ TO_@@ REACH_@@ END_OF_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ 2 | static int min@@ Jump@@ s ( int arr [ ] , int n ) { int [ ] jumps = new int [ n ] ; int min ; jumps [ n - 1 ] = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == 0 ) jumps [ i ] = Integer . MAX_VALUE ; else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ; else { min = Integer . MAX_VALUE ; for ( int j = i + 1 ; j < n && j <= arr [ i ] + i ; j ++ ) { if ( min > jumps [ j ] ) min = jumps [ j ] ; } if ( min != Integer . MAX_VALUE ) jumps [ i ] = min + 1 ; else jumps [ i ] = min ; } } return jumps [ 0 ] ; }
PROGRAM_@@ FIND_@@ GC@@ D_@@ FLOAT@@ ING_@@ POINT_@@ NUMB@@ ERS | static double gcd ( double a , double b ) { if ( a < b ) return gcd ( b , a ) ; if ( Math . abs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - Math . floor ( a / b ) * b ) ) ; }
MAXIMUM_@@ PROFI@@ T_@@ BY_@@ BU@@ Y@@ ING_@@ AND@@ _S@@ EL@@ LING_@@ A@@ _SH@@ ARE_@@ AT_@@ MO@@ ST_@@ TWI@@ CE | static int max@@ Pro@@ fit ( int price [ ] , int n ) { int pro@@ fit [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) pro@@ fit [ i ] = 0 ; int max_@@ price = price [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( price [ i ] > max_@@ price ) max_@@ price = price [ i ] ; pro@@ fit [ i ] = Math . max ( pro@@ fit [ i + 1 ] , max_@@ price - price [ i ] ) ; } int min_@@ price = price [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( price [ i ] < min_@@ price ) min_@@ price = price [ i ] ; pro@@ fit [ i ] = Math . max ( pro@@ fit [ i - 1 ] , pro@@ fit [ i ] + ( price [ i ] - min_@@ price ) ) ; } int result = pro@@ fit [ n - 1 ] ; return result ; }
COUNT_@@ SET_@@ BITS_@@ IN_@@ AN_@@ INTEGER_@@ 1 | public static int count@@ Set@@ Bits ( int n ) { if ( n == 0 ) return 0 ; else return ( n & 1 ) + count@@ Set@@ Bits ( n > > 1 ) ; }
RE@@ ORDER_@@ A_@@ ARRAY_@@ AC@@ COR@@ DING_@@ TO_@@ GI@@ V@@ EN_@@ INDEX@@ ES | static void reorder ( ) { int temp [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } }
CHECK_@@ IF_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ CAN_@@ RE@@ PRES@@ ENT_@@ PRE@@ ORDER_@@ TRA@@ VERS@@ AL_@@ OF_@@ BIN@@ AR@@ Y@@ _SEARCH_@@ TREE | boolean can@@ Represent@@ B@@ ST ( int pre [ ] , int n ) { Stack < Integer > s = new Stack < Integer > ( ) ; int root = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( pre [ i ] < root ) { return false ; } while ( ! s . empty ( ) && s . peek ( ) < pre [ i ] ) { root = s . peek ( ) ; s . pop ( ) ; } s . push ( pre [ i ] ) ; } return true ; }
FIND_@@ REPE@@ TI@@ TIVE_@@ ELEMENT_@@ 1_@@ N_@@ 1_@@ 3 | static int find@@ Repe@@ ating ( int arr [ ] , int n ) { int missing@@ Element = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int element = arr [ Math . abs ( arr [ i ] ) ] ; if ( element < 0 ) { missing@@ Element = arr [ i ] ; break ; } arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ; } return Math . abs ( missing@@ Element ) ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 8_@@ MATRIX_@@ CHAIN_@@ MULTIP@@ LIC@@ ATION_@@ 1 | static int Matrix@@ Chain@@ Order ( int p [ ] , int n ) { int m [ ] [ ] = new int [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; }
COUNT_@@ NUMBER_@@ IS@@ LAND@@ S_@@ EVER@@ Y_@@ IS@@ LAND@@ _SE@@ PAR@@ ATED_@@ LINE | static int count@@ Is@@ lands ( int mat [ ] [ ] , int m , int n ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == ' X ' ) { if ( ( i == 0 || mat [ i - 1 ] [ j ] == ' O ' ) && ( j == 0 || mat [ i ] [ j - 1 ] == ' O ' ) ) count ++ ; } } } return count ; }
MINI@@ MI@@ ZE_@@ MAX@@ AI_@@ B@@ J_@@ CK_@@ MIN@@ AI_@@ B@@ J_@@ CK_@@ THRE@@ E_@@ DIFF@@ ER@@ ENT_@@ SOR@@ TED_@@ ARRAY@@ S | static int solve ( int [ ] A , int [ ] B , int [ ] C ) { int i , j , k ; i = A . length - 1 ; j = B . length - 1 ; k = C . length - 1 ; int min_@@ diff , current_@@ diff , max_@@ term ; min_@@ diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; while ( i != - 1 && j != - 1 && k != - 1 ) { current_@@ diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; if ( current_@@ diff < min_@@ diff ) min_@@ diff = current_@@ diff ; max_@@ term = Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) ; if ( A [ i ] == max_@@ term ) i -= 1 ; else if ( B [ j ] == max_@@ term ) j -= 1 ; else k -= 1 ; } return min_@@ diff ; }
ROO@@ TS_@@ QUAD@@ RATI@@ C_@@ EQU@@ ATION | void find@@ Roots ( int a , int b , int c ) { if ( a == 0 ) { System . out . println ( " Invalid " ) ; return ; } int d = b * b - 4 * a * c ; double sq@@ rt_@@ val = sqrt ( abs ( d ) ) ; if ( d > 0 ) { System . out . println ( " Roots ▁ are ▁ real ▁ and ▁ different ▁ \n " ) ; System . out . println ( ( double ) ( - b + sq@@ rt_@@ val ) / ( 2 * a ) + " \n " + ( double ) ( - b - sq@@ rt_@@ val ) / ( 2 * a ) ) ; } else { System . out . println ( " Roots ▁ are ▁ complex ▁ \n " ) ; System . out . println ( - ( double ) b / ( 2 * a ) + " ▁ + ▁ i " + sq@@ rt_@@ val + " \n " + - ( double ) b / ( 2 * a ) + " ▁ - ▁ i " + sq@@ rt_@@ val ) ; } }
GI@@ V@@ EN_@@ LEVEL_@@ ORDER_@@ TRA@@ VERS@@ AL_@@ BINARY_@@ TREE_@@ CHECK_@@ TREE_@@ MIN_@@ HEA@@ P | static boolean is@@ Min@@ Heap ( int [ ] level ) { int n = level . length - 1 ; for ( int i = ( n / 2 - 1 ) ; i >= 0 ; i -- ) { if ( level [ i ] > level [ 2 * i + 1 ] ) return false ; if ( 2 * i + 2 < n ) { if ( level [ i ] > level [ 2 * i + 2 ] ) return false ; } } return true ; }
FIND_@@ MINIMUM_@@ ELEMENT_@@ IN_@@ A@@ _S@@ OR@@ TED_@@ AND_@@ ROTA@@ TED_@@ ARRAY | static int find@@ Min ( int arr [ ] , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return find@@ Min ( arr , low , mid - 1 ) ; return find@@ Min ( arr , mid + 1 , high ) ; }
SM@@ ALLE@@ ST_@@ LENGTH_@@ STRING_@@ WITH_@@ REPE@@ ATED_@@ REPLACE@@ MENT_@@ OF_@@ TWO_@@ DISTIN@@ CT_@@ AD@@ J@@ AC@@ ENT | static int string@@ Reduction ( String str ) { int n = str . length ( ) ; int count [ ] = new int [ 3 ] ; for ( int i = 0 ; i < n ; ++ i ) { count [ str . charAt ( i ) - ' a ' ] ++ ; } if ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ] == n ) { return n ; } if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) { return 2 ; } return 1 ; }
CHECK_@@ LARGE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 3_@@ NOT | static boolean check ( String str ) { int n = str . length ( ) ; int digit@@ Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digit@@ Sum += ( str . charAt ( i ) - '0' ) ; return ( digit@@ Sum % 3 == 0 ) ; }
COMP@@ UTE_@@ N_@@ UN@@ DER_@@ MODUL@@ O_@@ P | static int mod@@ Fact ( int n , int p ) { if ( n >= p ) return 0 ; int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = ( result * i ) % p ; return result ; }
POSSI@@ BILITY_@@ OF_@@ A_@@ WORD_@@ FROM_@@ A_@@ GI@@ VEN@@ _SET_@@ OF_@@ CHARAC@@ TERS | static boolean isPresent ( String s , String q ) { int [ ] freq = new int [ MAX_@@ CHAR ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) freq [ s . charAt ( i ) ] ++ ; for ( int i = 0 ; i < q . length ( ) ; i ++ ) { freq [ q . charAt ( i ) ] -- ; if ( freq [ q . charAt ( i ) ] < 0 ) return false ; } return true ; }
NEXT_@@ POWER_@@ OF_@@ 2_1 | static int next@@ PowerOf@@ 2 ( int n ) { int p = 1 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( p < n ) p <<= 1 ; return p ; }
RE@@ ORDER_@@ A_@@ ARRAY_@@ AC@@ COR@@ DING_@@ TO_@@ GI@@ V@@ EN_@@ INDEX@@ ES_@@ 1 | static void reorder ( ) { for ( int i = 0 ; i < arr . length ; i ++ ) { while ( index [ i ] != i ) { int old@@ Target@@ I = index [ index [ i ] ] ; char old@@ Target@@ E = ( char ) arr [ index [ i ] ] ; arr [ index [ i ] ] = arr [ i ] ; index [ index [ i ] ] = index [ i ] ; index [ i ] = old@@ Target@@ I ; arr [ i ] = old@@ Target@@ E ; } } }
UN@@ BOUN@@ DED_@@ KN@@ AP@@ S@@ ACK_@@ REPE@@ TI@@ TION_@@ ITE@@ MS_@@ ALLOWED | private static int un@@ bounded@@ K@@ nap@@ s@@ ack ( int W , int n , int [ ] val , int [ ] wt ) { int dp [ ] = new int [ W + 1 ] ; for ( int i = 0 ; i <= W ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( wt [ j ] <= i ) { dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) ; } } } return dp [ W ] ; }
PROGRAM_@@ CHECK_@@ DIAG@@ ON@@ AL_@@ MATRI@@ X@@ _SCAL@@ AR_@@ MATRIX | static boolean is@@ Diag@@ onal@@ Matrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; return true ; }
MAXIMUM_@@ REMO@@ VAL_@@ FROM_@@ ARRAY_@@ WH@@ EN_@@ REMO@@ VAL_@@ TIME_@@ WAIT@@ ING_@@ TIME | static int max@@ Removal ( int arr [ ] , int n ) { int count = 0 ; int cum@@ mul@@ ative@@ _@@ sum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= cum@@ mul@@ ative@@ _@@ sum ) { count ++ ; cum@@ mul@@ ative@@ _@@ sum += arr [ i ] ; } } return count ; }
PROGRAM_@@ CEN@@ S@@ OR_@@ WORD_@@ AST@@ ER@@ IS@@ K@@ S_S@@ ENT@@ ENCE | static String cen@@ sor ( String text , String word ) { String [ ] word_@@ list = text . split ( " \\s + " ) ; String result = " " ; String stars = " " ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) stars += ' * ' ; int index = 0 ; for ( String i : word_@@ list ) { if ( i . compareTo ( word ) == 0 ) word_@@ list [ index ] = stars ; index ++ ; } for ( String i : word_@@ list ) result += i + ' ▁ ' ; return result ; }
COUNT_@@ STRING@@ S_@@ WITH_@@ CON@@ SEC@@ UTI@@ VE_@@ 1@@ S | static int count@@ Strings ( int n ) { int a [ ] = new int [ n ] , b [ ] = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } from 2 ^ n return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }
LENGTH_@@ LON@@ GE@@ ST_@@ BAL@@ ANCE@@ D@@ _SUB@@ SEQUENCE | static int maxLength ( String s , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( s . charAt ( i ) == ' ( ' && s . charAt ( i + 1 ) == ' ) ' ) dp [ i ] [ i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s . charAt ( i ) == ' ( ' && s . charAt ( j ) == ' ) ' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( int k = i ; k < j ; k ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; }
FIND_@@ THE_@@ POINT_@@ W@@ HER@@ E_@@ MAXIMUM_@@ INTER@@ VAL@@ S_@@ OVER@@ LA@@ P | static void find@@ Max@@ Gue@@ sts ( int ar@@ rl [ ] , int exit [ ] , int n ) { Arrays . sort ( ar@@ rl ) ; Arrays . sort ( exit ) ; int guest@@ s_@@ in = 1 , max_@@ gue@@ sts = 1 , time = ar@@ rl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( ar@@ rl [ i ] <= exit [ j ] ) { guest@@ s_@@ in ++ ; if ( guest@@ s_@@ in > max_@@ gue@@ sts ) { max_@@ gue@@ sts = guest@@ s_@@ in ; time = ar@@ rl [ i ] ; } i ++ ; } else { guest@@ s_@@ in -- ; j ++ ; } } System . out . println ( " Maximum ▁ Number ▁ of ▁ Gue@@ sts ▁ = ▁ " + max_@@ gue@@ sts + " ▁ at ▁ time ▁ " + time ) ; }
EF@@ FI@@ CI@@ ENT_@@ WA@@ Y_@@ CHECK_@@ WHE@@ THER_@@ N_@@ TH_@@ FI@@ BON@@ ACC@@ I_@@ NUMBER_@@ MULTIPLE_@@ 10 | static boolean is@@ Multiple@@ Of@@ 10 ( int n ) { if ( n % 15 == 0 ) return true ; return false ; }
MAX@@ IM@@ UM@@ _S@@ UM_@@ PAIR@@ S@@ _SPECI@@ FIC_@@ DIFF@@ ER@@ ENCE | static int max@@ Sum@@ Pair@@ With@@ Difference@@ LessThan@@ K ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int dp [ ] = new int [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; }
FIND_@@ K_@@ PAIR@@ S_S@@ MAL@@ LE@@ ST@@ _S@@ UM@@ S_@@ TWO_@@ ARRAY@@ S | static void k@@ S@@ malle@@ st@@ Pair ( int ar@@ r1 [ ] , int n1 , int ar@@ r2 [ ] , int n2 , int k ) { if ( k > n1 * n2 ) { System . out . print ( " k ▁ pairs ▁ don ' t ▁ exist " ) ; return ; } int index2 [ ] = new int [ n1 ] ; while ( k > 0 ) { int min_@@ sum = Integer . MAX_VALUE ; int min_@@ index = 0 ; for ( int i1 = 0 ; i1 < n1 ; i1 ++ ) { if ( index2 [ i1 ] < n2 && ar@@ r1 [ i1 ] + ar@@ r2 [ index2 [ i1 ] ] < min_@@ sum ) { min_@@ index = i1 ; min_@@ sum = ar@@ r1 [ i1 ] + ar@@ r2 [ index2 [ i1 ] ] ; } } System . out . print ( " ( " + ar@@ r1 [ min_@@ index ] + " , ▁ " + ar@@ r2 [ index2 [ min_@@ index ] ] + " ) ▁ " ) ; index2 [ min_@@ index ] ++ ; k -- ; } }
FIRST_@@ UP@@ PER@@ CASE_@@ LET@@ TER_@@ IN_@@ A_@@ STRING_@@ ITER@@ ATI@@ VE_@@ AND_@@ RECUR@@ SIVE_@@ 1 | static char first ( String str , int i ) { if ( str . charAt ( i ) == ' \0' ) return 0 ; if ( Character . is@@ UpperCase ( str . charAt ( i ) ) ) return str . charAt ( i ) ; return first ( str , i + 1 ) ; }
FIND_@@ PAIR@@ S_@@ B_@@ ARRAY_@@ B_@@ K | static boolean print@@ Pairs ( int arr [ ] , int n , int k ) { boolean is@@ Pair@@ Found = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { System . out . print ( " ( " + arr [ i ] + " , ▁ " + arr [ j ] + " ) " + " ▁ " ) ; is@@ Pair@@ Found = true ; } } } return is@@ Pair@@ Found ; }
FIND_@@ AR@@ RANGE@@ MENT_@@ QUEUE_@@ GI@@ V@@ EN_@@ TIME | static void solve ( int n , int t , char s [ ] ) { for ( int i = 0 ; i < t ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) if ( s [ j ] == ' B ' && s [ j + 1 ] == ' G ' ) { char temp = s [ j ] ; s [ j ] = s [ j + 1 ] ; s [ j + 1 ] = temp ; j ++ ; } System . out . print ( s ) ; }
SHOR@@ TEST_@@ POSSI@@ BLE_@@ COMBIN@@ ATION_@@ TWO_@@ STRINGS | static void print@@ Super@@ Seq ( String a , String b ) { int m = a . length ( ) , n = b . length ( ) ; int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } String res = " " ; int i = m , j = n ; while ( i > 0 && j > 0 ) { if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) { res = a . charAt ( i - 1 ) + res ; i -- ; j -- ; } else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) { res = a . charAt ( i - 1 ) + res ; i -- ; } else { res = b . charAt ( j - 1 ) + res ; j -- ; } } while ( i > 0 ) { res = a . charAt ( i - 1 ) + res ; i -- ; } while ( j > 0 ) { res = b . charAt ( j - 1 ) + res ; j -- ; } System . out . println ( res ) ; }
COUNT_@@ ROTA@@ TIONS_@@ DI@@ VISI@@ BLE_@@ 8 | static int count@@ Rotation@@ s@@ Div@@ By@@ 8 ( String n ) { int len = n . length ( ) ; int count = 0 ; if ( len == 1 ) { int one@@ Digit = n . charAt ( 0 ) - '0' ; if ( one@@ Digit % 8 == 0 ) return 1 ; return 0 ; } if ( len == 2 ) { int first = ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ; int second = ( n . charAt ( 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( first % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; return count ; } int three@@ Digit ; for ( int i = 0 ; i < ( len - 2 ) ; i ++ ) { three@@ Digit = ( n . charAt ( i ) - '0' ) * 100 + ( n . charAt ( i + 1 ) - '0' ) * 10 + ( n . charAt ( i + 2 ) - '0' ) ; if ( three@@ Digit % 8 == 0 ) count ++ ; } three@@ Digit = ( n . charAt ( len - 1 ) - '0' ) * 100 + ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ; if ( three@@ Digit % 8 == 0 ) count ++ ; three@@ Digit = ( n . charAt ( len - 2 ) - '0' ) * 100 + ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( three@@ Digit % 8 == 0 ) count ++ ; return count ; }
LON@@ GE@@ ST_@@ COMM@@ ON@@ _SUB@@ SEQU@@ ENCE_@@ WITH_@@ AT_@@ MO@@ ST_@@ K_@@ CHANGE@@ S_@@ ALLOWED | static int l@@ cs ( int [ ] [ ] [ ] dp , int [ ] ar@@ r1 , int n , int [ ] ar@@ r2 , int m , int k ) { if ( k < 0 ) return - 10000000 ; if ( n < 0 || m < 0 ) return 0 ; int ans = dp [ n ] [ m ] [ k ] ; if ( ans != - 1 ) return ans ; try { ans = Math . max ( l@@ cs ( dp , ar@@ r1 , n - 1 , ar@@ r2 , m , k ) , l@@ cs ( dp , ar@@ r1 , n , ar@@ r2 , m - 1 , k ) ) ; if ( ar@@ r1 [ n - 1 ] == ar@@ r2 [ m - 1 ] ) ans = Math . max ( ans , 1 + l@@ cs ( dp , ar@@ r1 , n - 1 , ar@@ r2 , m - 1 , k ) ) ; ans = Math . max ( ans , 1 + l@@ cs ( dp , ar@@ r1 , n - 1 , ar@@ r2 , m - 1 , k - 1 ) ) ; } catch ( Exception e ) { } return ans ; }
CHECK_@@ LINE_@@ TOU@@ CHE@@ S_@@ INTER@@ SEC@@ TS_@@ CIRC@@ LE | static void check@@ Collision ( int a , int b , int c , int x , int y , int radius ) { double dist = ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ; if ( radius == dist ) System . out . println ( " Touch " ) ; else if ( radius > dist ) System . out . println ( " Intersect " ) ; else System . out . println ( " Outside " ) ; }
FIND_@@ THE_@@ MAX@@ IM@@ UM@@ _SUB@@ ARRAY_@@ X@@ OR_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY | static int max@@ Sub@@ array@@ XOR ( int arr [ ] , int n ) { int ans = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_@@ xor = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_@@ xor = curr_@@ xor ^ arr [ j ] ; ans = Math . max ( ans , curr_@@ xor ) ; } } return ans ; }
SHOR@@ TEST_@@ PATH_@@ EXAC@@ TL@@ Y_@@ K_@@ ED@@ GE@@ S_@@ DIREC@@ TED_@@ WE@@ I@@ GH@@ TED_@@ GRAP@@ H | int shor@@ test@@ Path ( int graph [ ] [ ] , int u , int v , int k ) { if ( k == 0 && u == v ) return 0 ; if ( k == 1 && graph [ u ] [ v ] != INF ) return graph [ u ] [ v ] ; if ( k <= 0 ) return INF ; int res = INF ; for ( int i = 0 ; i < V ; i ++ ) { if ( graph [ u ] [ i ] != INF && u != i && v != i ) { int rec_@@ res = shor@@ test@@ Path ( graph , i , v , k - 1 ) ; if ( rec_@@ res != INF ) res = Math . min ( res , graph [ u ] [ i ] + rec_@@ res ) ; } } return res ; }
FIN@@ D@@ _SUB@@ ARRAY_@@ WITH_@@ GI@@ VEN@@ _S@@ UM | int sub@@ Array@@ Sum ( int arr [ ] , int n , int sum ) { int curr_@@ sum , i , j ; for ( i = 0 ; i < n ; i ++ ) { curr_@@ sum = arr [ i ] ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_@@ sum == sum ) { int p = j - 1 ; System . out . println ( " Sum ▁ found ▁ between ▁ indexes ▁ " + i + " ▁ and ▁ " + p ) ; return 1 ; } if ( curr_@@ sum > sum || j == n ) break ; curr_@@ sum = curr_@@ sum + arr [ j ] ; } } System . out . println ( " No ▁ sub@@ array ▁ found " ) ; return 0 ; }
K_@@ TH_@@ PRI@@ ME_@@ FAC@@ TOR_@@ GI@@ V@@ EN_@@ NUMBER | static int k@@ Prime@@ Factor ( int n , int k ) { while ( n % 2 == 0 ) { k -- ; n = n / 2 ; if ( k == 0 ) return 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( k == 1 ) return i ; k -- ; n = n / i ; } } if ( n > 2 && k == 1 ) return n ; return - 1 ; }
FIND_@@ ROTATION_@@ COUNT_@@ ROTA@@ TE@@ D_S@@ OR@@ TED_@@ ARRAY_@@ 1 | static int count@@ Rot@@ ations ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return count@@ Rot@@ ations ( arr , low , mid - 1 ) ; return count@@ Rot@@ ations ( arr , mid + 1 , high ) ; }
COMP@@ UTE_@@ AVER@@ AGE_@@ TWO_@@ NUMB@@ ERS_@@ WITH@@ OUT_@@ OVERFLOW_@@ 1 | static int compute_@@ average ( int a , int b ) { return ( a / 2 ) + ( b / 2 ) + ( ( a % 2 + b % 2 ) / 2 ) ; }
SOR@@ TING_@@ USING_@@ TRI@@ VI@@ AL_@@ HASH_@@ FUNCTION_@@ 1 | static void sort@@ Using@@ Hash ( int a [ ] , int n ) { int max = Arrays . stream ( a ) . max ( ) . getAs@@ Int ( ) ; int min = Math . abs ( Arrays . stream ( a ) . min ( ) . getAs@@ Int ( ) ) ; int hash@@ pos [ ] = new int [ max + 1 ] ; int hash@@ neg [ ] = new int [ min + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) hash@@ pos [ a [ i ] ] += 1 ; else hash@@ neg [ Math . abs ( a [ i ] ) ] += 1 ; } for ( int i = min ; i > 0 ; i -- ) { if ( hash@@ neg [ i ] > 0 ) { for ( int j = 0 ; j < hash@@ neg [ i ] ; j ++ ) { System . out . print ( ( - 1 ) * i + " ▁ " ) ; } } } for ( int i = 0 ; i <= max ; i ++ ) { if ( hash@@ pos [ i ] > 0 ) { for ( int j = 0 ; j < hash@@ pos [ i ] ; j ++ ) { System . out . print ( i + " ▁ " ) ; } } } }
FIND_@@ THE_@@ TWO_@@ REPE@@ ATING_@@ ELEMEN@@ TS_@@ IN_@@ A_@@ GI@@ V@@ EN_@@ ARRAY_@@ 1 | void print@@ Repe@@ ating ( int arr [ ] , int size ) { int count [ ] = new int [ size ] ; int i ; System . out . println ( " Repe@@ ated ▁ elements ▁ are ▁ : ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) System . out . print ( arr [ i ] + " ▁ " ) ; else count [ arr [ i ] ] ++ ; } }
MINIMUM_@@ STE@@ PS_@@ MINI@@ MI@@ ZE_@@ N_@@ PER_@@ GI@@ V@@ EN_@@ CONDITION | static int getMin@@ Steps ( int n ) { int table [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) table [ i ] = n - i ; for ( int i = n ; i >= 1 ; i -- ) { if ( ! ( i % 2 > 0 ) ) table [ i / 2 ] = Math . min ( table [ i ] + 1 , table [ i / 2 ] ) ; if ( ! ( i % 3 > 0 ) ) table [ i / 3 ] = Math . min ( table [ i ] + 1 , table [ i / 3 ] ) ; } return table [ 1 ] ; 
COUNT_@@ POSSI@@ BLE_@@ DE@@ COD@@ INGS_@@ GI@@ V@@ EN_@@ DIG@@ IT_@@ SEQU@@ ENCE_@@ 1 | static int count@@ Decoding@@ DP ( char digits [ ] , int n ) { int count [ ] = new int [ n + 1 ] ; count [ 0 ] = 1 ; count [ 1 ] = 1 ; if ( digits [ 0 ] == '0' ) return 0 ; for ( int i = 2 ; i <= n ; i ++ ) { count [ i ] = 0 ; if ( digits [ i - 1 ] > '0' ) count [ i ] = count [ i - 1 ] ; if ( digits [ i - 2 ] == '1' || ( digits [ i - 2 ] == '2' && digits [ i - 1 ] < '7' ) ) count [ i ] += count [ i - 2 ] ; } return count [ n ] ; }
E@@ UL@@ ERS_@@ FOUR@@ _S@@ QU@@ ARE_@@ IDENTI@@ TY_@@ 1 | public static void check@@ Euler@@ Four@@ Square@@ Identity ( int a , int b ) { int ab = a * b ; boolean flag = false ; int i = 0 ; while ( i * i <= ab ) { int j = i ; while ( i * i + j * j <= ab ) { int k = j ; while ( i * i + j * j + k * k <= ab ) { double l = Math . sqrt ( ab - ( i * i + j * j + k * k ) ) ; if ( Math . floor ( l ) == Math . ceil ( l ) && l >= k ) { flag = true ; System . out . print ( " i ▁ = ▁ " + i + " \n " ) ; System . out . print ( " j ▁ = ▁ " + j + " \n " ) ; System . out . print ( " k ▁ = ▁ " + k + " \n " ) ; System . out . print ( " l ▁ = ▁ " + ( int ) l + " \n " ) ; System . out . print ( " Product ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ can ▁ be ▁ written ▁ as ▁ sum ▁ of ▁ squares " + " ▁ of ▁ i , ▁ j , ▁ k , ▁ l ▁ \n " ) ; System . out . print ( ab + " ▁ = ▁ " + i + " * " + i + " ▁ + ▁ " + j + " * " + j + " ▁ + ▁ " + k + " * " + k + " ▁ + ▁ " + ( int ) l + " * " + ( int ) l + " \n " ) ; } k += 1 ; } j += 1 ; } i += 1 ; } if ( flag == false ) { System . out . println ( " Solution ▁ doesn ' t ▁ exist ! " ) ; return ; } }
COUNT_@@ NUMBER_@@ INCRE@@ AS@@ ING@@ _SUB@@ SEQU@@ EN@@ CE@@ S@@ _SIZE_@@ K | static int numOf@@ Inc@@ Sub@@ seq@@ Of@@ Size@@ K ( int arr [ ] , int n , int k ) { int dp [ ] [ ] = new int [ k ] [ n ] , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ 0 ] [ i ] = 1 ; } for ( int l = 1 ; l < k ; l ++ ) { for ( int i = l ; i < n ; i ++ ) { dp [ l ] [ i ] = 0 ; for ( int j = l - 1 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { dp [ l ] [ i ] += dp [ l - 1 ] [ j ] ; } } } } for ( int i = k - 1 ; i < n ; i ++ ) { sum += dp [ k - 1 ] [ i ] ; } return sum ; }
KN@@ AP@@ S@@ ACK_@@ PRO@@ BLE@@ M_@@ 1 | static int kn@@ ap@@ S@@ ack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }
PROGRAM_@@ TO_@@ PRINT_@@ DOUBLE_@@ HEA@@ DED_@@ ARROW_@@ PATTERN | static void draw@@ Pattern ( int N ) { int n = N ; int row = 1 ; int n@@ st = 1 ; int n@@ sp@@ 1 = n - 1 ; int n@@ sp@@ 2 = - 1 ; int val1 = row ; int val2 = 1 ; while ( row <= n ) { int c@@ sp@@ 1 = 1 ; while ( c@@ sp@@ 1 <= n@@ sp@@ 1 ) { System . out . print ( " ▁ ▁ " ) ; c@@ sp@@ 1 = c@@ sp@@ 1 + 1 ; } int c@@ st1 = 1 ; while ( c@@ st1 <= n@@ st ) { System . out . print ( val1 + " ▁ " ) ; val1 = val1 - 1 ; c@@ st1 = c@@ st1 + 1 ; } int c@@ sp@@ 2 = 1 ; while ( c@@ sp@@ 2 <= n@@ sp@@ 2 ) { System . out . print ( " ▁ ▁ " ) ; c@@ sp@@ 2 = c@@ sp@@ 2 + 1 ; } if ( row != 1 && row != n ) { int c@@ st2 = 1 ; while ( c@@ st2 <= n@@ st ) { System . out . print ( val2 + " ▁ " ) ; val2 = val2 + 1 ; c@@ st2 = c@@ st2 + 1 ; } } System . out . println ( ) ; if ( row <= n / 2 ) { n@@ st = n@@ st + 1 ; n@@ sp@@ 1 = n@@ sp@@ 1 - 2 ; n@@ sp@@ 2 = n@@ sp@@ 2 + 2 ; val1 = row + 1 ; val2 = 1 ; } else { n@@ st = n@@ st - 1 ; n@@ sp@@ 1 = n@@ sp@@ 1 + 2 ; n@@ sp@@ 2 = n@@ sp@@ 2 - 2 ; val1 = n - row ; val2 = 1 ; } row = row + 1 ; } }
INTEGER_@@ POSITIVE_@@ VALUE_@@ POSITIVE_@@ NEGATIVE_@@ VALUE_@@ ARRAY | static int find@@ Integer ( int arr [ ] , int n ) { HashMap < Integer , Integer > hash = new HashMap < > ( ) ; int maximum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) hash . put ( Math . abs ( arr [ i ] ) , ( hash . get ( Math . abs ( arr [ i ] ) ) == null ? 0 : hash . get ( Math . abs ( arr [ i ] ) ) ) - 1 ) ; else hash . put ( Math . abs ( arr [ i ] ) , ( hash . get ( Math . abs ( arr [ i ] ) ) == null ? 0 : hash . get ( Math . abs ( arr [ i ] ) ) ) + 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) if ( hash . get ( arr [ i ] ) > 0 ) return arr [ i ] ; return - 1 ; }
SPACE_@@ OPTIMIZ@@ ED@@ _S@@ OL@@ U@@ TION_@@ L@@ CS | public static int l@@ cs ( String X , String Y ) { int m = X . length ( ) , n = Y . length ( ) ; int L [ ] [ ] = new int [ 2 ] [ n + 1 ] ; int bi = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = Math . max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; }
RE@@ PRES@@ ENT_@@ NUMBER@@ _S@@ UM_@@ MINIMUM_@@ POSSI@@ BLE_@@ P@@ SU@@ E@@ DO@@ BINARY_@@ NUMB@@ ERS | public static void p@@ su@@ e@@ do@@ Binary ( int n ) { while ( n != 0 ) { int temp = n , m = 0 , p = 1 ; while ( temp != 0 ) { int rem = temp % 10 ; temp = temp / 10 ; if ( rem != 0 ) m += p ; p *= 10 ; } System . out . print ( m + " ▁ " ) ; n = n - m ; } System . out . println ( " ▁ " ) ; }
FIND_@@ NUMBER_@@ CURRENCY_@@ NOTE@@ S_S@@ UM_@@ UP@@ TO_@@ GI@@ V@@ EN_@@ AMOUNT | public static void count@@ Currency ( int amount ) { int [ ] notes = new int [ ] { 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 } ; int [ ] note@@ Counter = new int [ 9 ] ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( amount >= notes [ i ] ) { note@@ Counter [ i ] = amount / notes [ i ] ; amount = amount - note@@ Counter [ i ] * notes [ i ] ; } } System . out . println ( " Currency ▁ Count ▁ - > " ) ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( note@@ Counter [ i ] != 0 ) { System . out . println ( notes [ i ] + " ▁ : ▁ " + note@@ Counter [ i ] ) ; } } }
POSITIVE_@@ ELEMEN@@ TS_@@ EV@@ EN_@@ NEGATIVE_@@ OD@@ D_@@ POSI@@ TIONS | static void re@@ arrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 , temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } }
FIND_@@ WHE@@ THER_@@ AN_@@ ARRAY_@@ IS@@ _SUB@@ SET_@@ OF_@@ AN@@ OTHER_@@ ARRAY@@ _SET_@@ 1 | static boolean is@@ Subset ( int ar@@ r1 [ ] , int ar@@ r2 [ ] , int m , int n ) { int i = 0 ; int j = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) if ( ar@@ r2 [ i ] == ar@@ r1 [ j ] ) break ; if ( j == m ) return false ; } return true ; }
GI@@ V@@ EN_@@ A@@ _S@@ OR@@ TED_@@ AND_@@ ROTA@@ TED_@@ ARRAY_@@ FIND_@@ IF_@@ THER@@ E_@@ IS_@@ A_@@ PA@@ IR_@@ WITH_@@ A_@@ GI@@ VEN@@ _S@@ UM | static boolean pair@@ In@@ Sorted@@ Rot@@ ated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; }
PROGRAM_@@ TO_@@ FIND_@@ RE@@ MA@@ INDE@@ R_@@ WITH@@ OUT_@@ USING_@@ MODUL@@ O_@@ OR_@@ OPERATOR_@@ 1 | static int getRe@@ main@@ der ( int num , int divisor ) { if ( divisor == 0 ) { System . out . println ( " Error : ▁ divisor ▁ " + " can ' t ▁ be ▁ zero ▁ \n " ) ; return - 1 ; } if ( divisor < 0 ) divisor = - divisor ; if ( num < 0 ) num = - num ; int i = 1 ; int product = 0 ; while ( product <= num ) { product = divisor * i ; i ++ ; } return num - ( product - divisor ) ; }
G@@ NO@@ ME_@@ SORT_@@ A_@@ ST@@ UP@@ ID_@@ ONE | static void g@@ nome@@ Sort ( int arr [ ] , int n ) { int index = 0 ; while ( index < n ) { if ( index == 0 ) index ++ ; if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ; else { int temp = 0 ; temp = arr [ index ] ; arr [ index ] = arr [ index - 1 ] ; arr [ index - 1 ] = temp ; index -- ; } } return ; }
NUMBER_@@ WAY@@ S_@@ INSERT_@@ CHARACTER_@@ INCRE@@ ASE_@@ LC@@ S_@@ ONE | static int number@@ of@@ ways ( String A , String B , int N , int M ) { Vector < Integer > [ ] pos = new Vector [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) pos [ i ] = new Vector < > ( ) ; for ( int i = 0 ; i < M ; i ++ ) pos [ B . charAt ( i ) ] . add ( i + 1 ) ; int [ ] [ ] d@@ pl = new int [ N + 2 ] [ M + 2 ] ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 ) ) d@@ pl [ i ] [ j ] = d@@ pl [ i - 1 ] [ j - 1 ] + 1 ; else d@@ pl [ i ] [ j ] = Math . max ( d@@ pl [ i - 1 ] [ j ] , d@@ pl [ i ] [ j - 1 ] ) ; } } int L@@ CS = d@@ pl [ N ] [ M ] ; int [ ] [ ] d@@ pr = new int [ N + 2 ] [ M + 2 ] ; for ( int i = N ; i >= 1 ; i -- ) { for ( int j = M ; j >= 1 ; j -- ) { if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 ) ) d@@ pr [ i ] [ j ] = d@@ pr [ i + 1 ] [ j + 1 ] + 1 ; else d@@ pr [ i ] [ j ] = Math . max ( d@@ pr [ i + 1 ] [ j ] , d@@ pr [ i ] [ j + 1 ] ) ; } } int ans = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { for ( int x : pos [ j ] ) { if ( d@@ pl [ i ] [ x - 1 ] + d@@ pr [ i + 1 ] [ x + 1 ] == L@@ CS ) { ans ++ ; break ; } } } } return ans ; }
MINIMUM_@@ PRODUCT_@@ K_@@ INTEG@@ ERS_@@ ARRAY_@@ POSITIVE_@@ INTEG@@ ERS | public static int min@@ Product ( int [ ] arr , int n , int k ) { PriorityQueue < Integer > pq = new PriorityQueue < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) pq . add ( arr [ i ] ) ; int count = 0 , ans = 1 ; while ( pq . isEmpty ( ) == false && count < k ) { ans = ans * pq . element ( ) ; pq . remove ( ) ; count ++ ; } return ans ; }
FIND_@@ UNI@@ QUE_@@ ELEMEN@@ TS_@@ MATRIX | static void unique ( int mat [ ] [ ] , int n , int m ) { int maximum = 0 , flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( maximum < mat [ i ] [ j ] ) maximum = mat [ i ] [ j ] ; int b [ ] = new int [ maximum + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) b [ mat [ i ] [ j ] ] ++ ; for ( int i = 1 ; i <= maximum ; i ++ ) if ( b [ i ] == 1 ) System . out . print ( i + " ▁ " ) ; flag = 1 ; if ( flag == 0 ) { System . out . println ( " No ▁ unique ▁ element ▁ " + " in ▁ the ▁ matrix " ) ; } }
LON@@ GE@@ ST@@ _SUB@@ SEQU@@ ENCE_@@ SU@@ CH_@@ TH@@ AT_@@ DIFF@@ ER@@ ENCE_@@ BETWE@@ EN_@@ AD@@ J@@ AC@@ ENTS_@@ IS_@@ ONE | static int lon@@ gest@@ Sub@@ seq@@ With@@ Diff@@ One ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }
C_@@ PROGRAM_@@ CON@@ CAT@@ EN@@ ATE_@@ STRING_@@ GI@@ V@@ EN_@@ NUMBER_@@ TIMES | static String repeat ( String s , int n ) { String s1 = s ; for ( int i = 1 ; i < n ; i ++ ) s += s1 ; return s ; }
SE@@ ARCH@@ ING_@@ FOR_@@ PATTER@@ NS@@ _SET_@@ 1_@@ N@@ AI@@ VE_@@ PATTER@@ N@@ _SE@@ ARCH@@ ING | public static void search ( String txt , String pat ) { int M = pat . length ( ) ; int N = txt . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; if ( j == M ) System . out . println ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; } }
COUNT_@@ POSSI@@ BLE_@@ PATH@@ S@@ _SOURCE_@@ DESTIN@@ ATION_@@ EXAC@@ TL@@ Y_@@ K_@@ ED@@ GES | int coun@@ tw@@ al@@ ks ( int graph [ ] [ ] , int u , int v , int k ) { if ( k == 0 && u == v ) return 1 ; if ( k == 1 && graph [ u ] [ v ] == 1 ) return 1 ; if ( k <= 0 ) return 0 ; int count = 0 ; for ( int i = 0 ; i < V ; i ++ ) if ( graph [ u ] [ i ] == 1 ) count += coun@@ tw@@ al@@ ks ( graph , i , v , k - 1 ) ; return count ; }
COUNT_@@ DI@@ VISI@@ BLE_@@ PAIR@@ S_@@ ARRAY | static int count@@ Di@@ visi@@ bles ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ i ] == 0 ) res ++ ; return res ; }
PROGRAM_@@ TO_@@ CHECK_@@ IF_@@ A_@@ MATRIX_@@ IS_@@ SYM@@ METRIC | static boolean is@@ Symmetri@@ c ( int mat [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }
COUNT_@@ PA@@ LIN@@ DRO@@ ME_@@ SUB_@@ STRING@@ S_@@ STRING | static int Count@@ PS ( char str [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; boolean P [ ] [ ] = new boolean [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) P [ i ] [ i ] = true ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] == str [ i + 1 ] ) { P [ i ] [ i + 1 ] = true ; dp [ i ] [ i + 1 ] = 1 ; } } for ( int gap = 2 ; gap < n ; gap ++ ) { for ( int i = 0 ; i < n - gap ; i ++ ) { int j = gap + i ; if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ; if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ; } } return dp [ 0 ] [ n - 1 ] ; }
WAY@@ S_S@@ UM_@@ N_@@ USING_@@ ARRAY_@@ ELEMEN@@ TS_@@ REPE@@ TI@@ TION_@@ ALLOWED | static int count@@ W@@ ays ( int N ) { int count [ ] = new int [ N + 1 ] ; count [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 0 ; j < arr . length ; j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ; return count [ N ] ; }
MINIMUM_@@ NUMBER_OF_@@ OPER@@ ATION@@ S_TO_@@ MOVE_@@ ALL_@@ UP@@ PER@@ CASE_@@ CHARAC@@ TER@@ S_@@ BEFORE_@@ ALL_@@ LOWER_@@ CASE_@@ CHARAC@@ TERS | static int min@@ Operations ( String str , int n ) { int i , last@@ Upper = - 1 , first@@ Lower = - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( Character . is@@ UpperCase ( str . charAt ( i ) ) ) { last@@ Upper = i ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( Character . is@@ LowerCase ( str . charAt ( i ) ) ) { first@@ Lower = i ; break ; } } if ( last@@ Upper == - 1 || first@@ Lower == - 1 ) return 0 ; int count@@ Upper = 0 ; for ( i = first@@ Lower ; i < n ; i ++ ) { if ( Character . is@@ UpperCase ( str . charAt ( i ) ) ) { count@@ Upper ++ ; } } int count@@ Lower = 0 ; for ( i = 0 ; i < last@@ Upper ; i ++ ) { if ( Character . is@@ LowerCase ( str . charAt ( i ) ) ) { count@@ Lower ++ ; } } return Math . min ( count@@ Lower , count@@ Upper ) ; }
PRINT_@@ A_@@ GI@@ V@@ EN_@@ MATRIX_@@ IN@@ _SP@@ IR@@ AL_@@ FORM | static void spir@@ al@@ Print ( int m , int n , int a [ ] [ ] ) { int i , k = 0 , l = 0 ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) { System . out . print ( a [ k ] [ i ] + " ▁ " ) ; } k ++ ; for ( i = k ; i < m ; ++ i ) { System . out . print ( a [ i ] [ n - 1 ] + " ▁ " ) ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { System . out . print ( a [ m - 1 ] [ i ] + " ▁ " ) ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { System . out . print ( a [ i ] [ l ] + " ▁ " ) ; } l ++ ; } } }
FIND_@@ DISTIN@@ CT_@@ INTEG@@ ERS_@@ FOR_@@ A_@@ TR@@ IP@@ LET_@@ WITH_@@ GI@@ V@@ EN_@@ PRODUCT | static void find@@ Trip@@ lets ( int x ) { Vector < Integer > fact = new Vector < Integer > ( ) ; HashSet < Integer > factors = new HashSet < Integer > ( ) ; for ( int i = 2 ; i <= Math . sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { fact . add ( i ) ; if ( x / i != i ) fact . add ( x / i ) ; factors . add ( i ) ; factors . add ( x / i ) ; } } boolean found = false ; int k = fact . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { int a = fact . get ( i ) ; for ( int j = 0 ; j < k ; j ++ ) { int b = fact . get ( j ) ; if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) { System . out . print ( a + " ▁ " + b + " ▁ " + ( x / ( a * b ) ) ) ; found = true ; break ; } } if ( found ) break ; } if ( ! found ) System . out . print ( " - 1" ) ; }
S@@ UM_@@ TWO_@@ LARGE_@@ NUMB@@ ERS_@@ 1 | static String find@@ Sum ( String str1 , String str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) { String t = str1 ; str1 = str2 ; str2 = t ; } String str = " " ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; int diff = n2 - n1 ; int carry = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { int sum = ( ( int ) ( str1 . charAt ( i ) - '0' ) + ( int ) ( str2 . charAt ( i + diff ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } for ( int i = n2 - n1 - 1 ; i >= 0 ; i -- ) { int sum = ( ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } if ( carry > 0 ) str += ( char ) ( carry + '0' ) ; return new StringBuilder ( str ) . reverse ( ) . toString ( ) ; }
CO@@ CK@@ TA@@ IL@@ _S@@ ORT | void co@@ ck@@ tail@@ Sort ( int a [ ] ) { boolean swapped = true ; int start = 0 ; int end = a . length ; while ( swapped == true ) { swapped = false ; for ( int i = start ; i < end - 1 ; ++ i ) { if ( a [ i ] > a [ i + 1 ] ) { int temp = a [ i ] ; a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = temp ; swapped = true ; } } if ( swapped == false ) break ; swapped = false ; end = end - 1 ; for ( int i = end - 1 ; i >= start ; i -- ) { if ( a [ i ] > a [ i + 1 ] ) { int temp = a [ i ] ; a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = temp ; swapped = true ; } } start = start + 1 ; } }
COUNT_@@ DE@@ RANGE@@ MEN@@ TS_@@ PER@@ MU@@ TA@@ TION@@ _SU@@ CH_@@ TH@@ AT_@@ NO_@@ ELEMENT_@@ AP@@ PE@@ AR@@ S_IN_@@ IT@@ S_@@ ORIGIN@@ AL_@@ POSITION_@@ 1 | static int count@@ D@@ er ( int n ) { int der [ ] = new int [ n + 1 ] ; der [ 0 ] = 1 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
MAXIMUM_@@ PRODUCT_@@ SUB@@ ARRAY_@@ AD@@ DED_@@ NEGATIVE_@@ PRODUCT_@@ CASE | static int find@@ Max@@ Product ( int arr [ ] , int n ) { int i ; int ans = Integer . MIN_VALUE ; int maxval = 1 ; int min@@ val = 1 ; int prev@@ Max ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { maxval = maxval * arr [ i ] ; min@@ val = Math . min ( 1 , min@@ val * arr [ i ] ) ; } else if ( arr [ i ] == 0 ) { min@@ val = 1 ; maxval = 0 ; } else if ( arr [ i ] < 0 ) { prev@@ Max = maxval ; maxval = min@@ val * arr [ i ] ; min@@ val = prev@@ Max * arr [ i ] ; } ans = Math . max ( ans , maxval ) ; if ( maxval <= 0 ) { maxval = 1 ; } } return ans ; }
RE@@ AR@@ RANGE_@@ ARRAY@@ _SU@@ CH_@@ TH@@ AT_@@ EV@@ EN_@@ POSI@@ TI@@ ONED_@@ ARE_@@ GREATER_@@ TH@@ AN_@@ O@@ DD | static void assign ( int a [ ] , int n ) { Arrays . sort ( a ) ; int ans [ ] = new int [ n ] ; int p = 0 , q = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i + 1 ) % 2 == 0 ) ans [ i ] = a [ q -- ] ; else ans [ i ] = a [ p ++ ] ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans [ i ] + " ▁ " ) ; }
FRI@@ END@@ S_@@ PAIR@@ ING_@@ PRO@@ BLE@@ M | static int count@@ Fri@@ ends@@ Pair@@ ings ( int n ) { int dp [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }
PRI@@ ME_@@ NUMB@@ ERS | static boolean is@@ Prime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
PRO@@ B@@ AB@@ ILITY_@@ REACH@@ ING_@@ POINT_@@ 2_@@ 3_@@ STE@@ PS_@@ TIME | static float find_@@ prob ( int N , float P ) { double dp [ ] = new double [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return ( ( float ) ( dp [ N ] ) ) ; }
SM@@ ALLE@@ ST_@@ OF_@@ THRE@@ E_@@ INTEG@@ ERS_@@ WITH@@ OUT_@@ COMP@@ ARIS@@ ON_@@ OPER@@ ATOR@@ S_@@ 1 | static int smallest ( int x , int y , int z ) { if ( ( y / x ) != 1 ) return ( ( y / z ) != 1 ) ? y : z ; return ( ( x / z ) != 1 ) ? x : z ; }
COMMON_@@ ELEMEN@@ TS_@@ IN_@@ ALL_@@ RO@@ WS_@@ OF_@@ A_@@ GI@@ V@@ EN_@@ MATRIX | static void print@@ Common@@ Elements ( int mat [ ] [ ] ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int j = 0 ; j < N ; j ++ ) mp . put ( mat [ 0 ] [ j ] , 1 ) ; for ( int i = 1 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mp . get ( mat [ i ] [ j ] ) != null && mp . get ( mat [ i ] [ j ] ) == i ) { mp . put ( mat [ i ] [ j ] , i + 1 ) ; if ( i == M - 1 ) System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; } } } }
DETE@@ CT@@ ING_@@ NEGATIVE_@@ CY@@ CLE_@@ USING_@@ FLO@@ Y@@ D_@@ WAR@@ SHALL | static boolean neg@@ Cycle@@ flo@@ y@@ d@@ War@@ shall ( int graph [ ] [ ] ) { int dist [ ] [ ] = new int [ V ] [ V ] , i , j , k ; for ( i = 0 ; i < V ; i ++ ) for ( j = 0 ; j < V ; j ++ ) dist [ i ] [ j ] = graph [ i ] [ j ] ; for ( k = 0 ; k < V ; k ++ ) { for ( i = 0 ; i < V ; i ++ ) { for ( j = 0 ; j < V ; j ++ ) { if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; } } } for ( i = 0 ; i < V ; i ++ ) if ( dist [ i ] [ i ] < 0 ) return true ; return false ; }
PROGR@@ AM@@ _S@@ ORT_@@ STRING_@@ DESC@@ END@@ ING_@@ ORDER | static void sort@@ String ( String str ) { int char@@ Count [ ] = new int [ MAX_@@ CHAR ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char@@ Count [ str . charAt ( i ) - ' a ' ] ++ ; } for ( int i = MAX_@@ CHAR - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < char@@ Count [ i ] ; j ++ ) { System . out . print ( ( char ) ( ' a ' + i ) ) ; } } }
COUNT_@@ PAIR@@ S_@@ WITH_@@ GI@@ VEN@@ _S@@ UM | public static void get@@ Pai@@ rs@@ Count ( int [ ] arr , int sum ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) for ( int j = i + 1 ; j < arr . length ; j ++ ) if ( ( arr [ i ] + arr [ j ] ) == sum ) count ++ ; System . out . printf ( " Count ▁ of ▁ pairs ▁ is ▁ % d " , count ) ; }
SUM@@ _SERI@@ ES_@@ 12_@@ 32_@@ 5@@ 2_@@ 2@@ N_@@ 12@@ _1 | static int sum@@ Of@@ Series ( int n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }
MAXIMUM_@@ DIFF@@ ER@@ ENCE_@@ BETWE@@ EN_@@ FREQU@@ ENCY_@@ OF_@@ TWO_@@ ELEMEN@@ TS@@ _SU@@ CH_@@ TH@@ AT_@@ ELEMENT_@@ H@@ AV@@ ING_@@ GREATER_@@ FREQU@@ ENCY_@@ IS_@@ AL@@ SO_@@ GREATER | static int max@@ diff ( int arr [ ] , int n ) { Map < Integer , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) freq . put ( arr [ i ] , freq . get ( arr [ i ] ) == null ? 1 : freq . get ( arr [ i ] ) + 1 ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( freq . get ( arr [ i ] ) > freq . get ( arr [ j ] ) && arr [ i ] > arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ i ] ) - freq . get ( arr [ j ] ) ) ; else if ( freq . get ( arr [ i ] ) < freq . get ( arr [ j ] ) && arr [ i ] < arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ j ] ) - freq . get ( arr [ i ] ) ) ; } } return ans ; }
SHIFT_@@ MATRIX_@@ ELEMEN@@ TS_@@ K | static void shift@@ Matrix@@ By@@ K ( int [ ] [ ] mat , int k ) { if ( k > N ) { System . out . print ( " Shift@@ ing ▁ is " + " ▁ not ▁ possible " ) ; return ; } int j = 0 ; while ( j < N ) { for ( int i = k ; i < N ; i ++ ) System . out . print ( mat [ j ] [ i ] + " ▁ " ) ; for ( int i = 0 ; i < k ; i ++ ) System . out . print ( mat [ j ] [ i ] + " ▁ " ) ; System . out . println ( ) ; j ++ ; } }
MAXIMUM_@@ AND_@@ MINIMUM_@@ IN_@@ A@@ _S@@ QU@@ ARE_@@ MATRIX | static void max@@ Min ( int arr [ ] [ ] , int n ) { int min = + 2147483647 ; int max = - 214748364@@ 8 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= n / 2 ; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ; if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ; } else { if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ; if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ] ; } } } System . out . print ( " Maximum ▁ = ▁ " + max + " , ▁ Minimum ▁ = ▁ " + min ) ; }
FIND_@@ PA@@ IR_@@ WITH_@@ GREA@@ TEST_@@ PRODUCT_@@ IN_@@ ARRAY_@@ 1 | static int find@@ Gre@@ atest ( int arr [ ] , int n ) { Map < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , m . get ( arr [ i ] ) ) ; } } Arrays . sort ( arr ) ; for ( int i = n - 1 ; i > 1 ; i -- ) { for ( int j = 0 ; j < i && arr [ j ] <= Math . sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 ) { int result = arr [ i ] / arr [ j ] ; if ( result != arr [ j ] && m . get ( result ) == null || m . get ( result ) > 0 ) { return arr [ i ] ; } else if ( result == arr [ j ] && m . get ( result ) > 1 ) { return arr [ i ] ; } } } } return - 1 ; }
0_@@ 1_@@ KN@@ AP@@ S@@ ACK_@@ PRO@@ BLE@@ M_@@ D@@ P_@@ 10@@ _1 | static int kn@@ ap@@ S@@ ack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }
PROGRAM_@@ DECIMAL_@@ OC@@ TAL_@@ CONVERSION | static void dec@@ To@@ Oct@@ al ( int n ) { int [ ] oct@@ al@@ Num = new int [ 100 ] ; int i = 0 ; while ( n != 0 ) { oct@@ al@@ Num [ i ] = n % 8 ; n = n / 8 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( oct@@ al@@ Num [ j ] ) ; }
SUB@@ SEQU@@ EN@@ CE@@ S@@ _SIZE_@@ THRE@@ E_@@ ARRAY_@@ WHO@@ SE_@@ S@@ UM_@@ DI@@ VISI@@ BLE_@@ M_@@ 1 | static int count@@ Sub@@ Seq ( int A [ ] , int N , int M ) { int ans = 0 ; int h [ ] = new int [ M ] ; Arrays . fill ( h , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = A [ i ] % M ; h [ A [ i ] ] ++ ; } for ( int i = 0 ; i < M ; i ++ ) { for ( int j = i ; j < M ; j ++ ) { int rem = ( M - ( i + j ) % M ) % M ; if ( rem < j ) continue ; if ( i == j && rem == j ) ans += h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 ; else if ( i == j ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ; else if ( i == rem ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ; else if ( rem == j ) ans += h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 ; else ans = ans + h [ i ] * h [ j ] * h [ rem ] ; } } return ans ; }
COUNT_@@ FI@@ BON@@ ACC@@ I_@@ NUMB@@ ERS_@@ GI@@ V@@ EN_@@ RANGE_@@ LOG_@@ TIME | static int count@@ Fi@@ bs ( int low , int high ) { int f1 = 0 , f2 = 1 , f3 = 1 ; int result = 0 ; while ( f1 <= high ) { if ( f1 >= low ) result ++ ; f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return result ; }
FIND_@@ WHE@@ THER_@@ A_@@ GI@@ V@@ EN_@@ NUMBER_@@ IS_@@ A_@@ POWER_@@ OF_@@ 4_@@ OR_@@ NOT_@@ 1 | static int is@@ PowerOf@@ Four ( int n ) { int count = 0 ; int x = n & ( n - 1 ) ; if ( n > 0 && x == 0 ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; }
FIN@@ D_S@@ UM_@@ EV@@ EN_@@ FAC@@ TOR@@ S_@@ NUMBER | public static int su@@ mo@@ f@@ Factors ( int n ) { if ( n % 2 != 0 ) return 0 ; int res = 1 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_@@ sum = 1 ; int curr_@@ term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_@@ sum = 0 ; curr_@@ term *= i ; curr_@@ sum += curr_@@ term ; } res *= curr_@@ sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
FIN@@ D_S@@ UM_@@ NON_@@ REPE@@ ATING_@@ DISTIN@@ CT_@@ ELEMEN@@ TS_@@ ARRAY | static int find@@ Sum ( int arr [ ] , int n ) { int sum = 0 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . contains ( arr [ i ] ) ) { sum += arr [ i ] ; s . add ( arr [ i ] ) ; } } return sum ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 17@@ _@@ PA@@ LIN@@ DRO@@ ME_@@ PARTI@@ TION@@ ING_@@ 1 | static int min@@ Pal@@ Par@@ tion ( String str ) { int n = str . length ( ) ; int [ ] C = new int [ n ] ; boolean [ ] [ ] P = new boolean [ n ] [ n ] ; int i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; } for ( L = 2 ; L <= n ; L ++ ) { for ( i = 0 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( L == 2 ) P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) ; else P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) && P [ i + 1 ] [ j - 1 ] ; } } for ( i = 0 ; i < n ; i ++ ) { if ( P [ 0 ] [ i ] == true ) C [ i ] = 0 ; else { C [ i ] = Integer . MAX_VALUE ; for ( j = 0 ; j < i ; j ++ ) { if ( P [ j + 1 ] [ i ] == true && 1 + C [ j ] < C [ i ] ) C [ i ] = 1 + C [ j ] ; } } } return C [ n - 1 ] ; }
MINIMUM_@@ POSITIVE_@@ POINT@@ S_TO_@@ REACH_@@ DESTIN@@ ATION | static int min@@ Initial@@ Points ( int points [ ] [ ] , int R , int C ) { int dp [ ] [ ] = new int [ R ] [ C ] ; int m = R , n = C ; dp [ m - 1 ] [ n - 1 ] = points [ m - 1 ] [ n - 1 ] > 0 ? 1 : Math . abs ( points [ m - 1 ] [ n - 1 ] ) + 1 ; for ( int i = m - 2 ; i >= 0 ; i -- ) dp [ i ] [ n - 1 ] = Math . max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) ; for ( int j = n - 2 ; j >= 0 ; j -- ) dp [ m - 1 ] [ j ] = Math . max ( dp [ m - 1 ] [ j + 1 ] - points [ m - 1 ] [ j ] , 1 ) ; for ( int i = m - 2 ; i >= 0 ; i -- ) { for ( int j = n - 2 ; j >= 0 ; j -- ) { int min_@@ points_@@ on_@@ exit = Math . min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) ; dp [ i ] [ j ] = Math . max ( min_@@ points_@@ on_@@ exit - points [ i ] [ j ] , 1 ) ; } } return dp [ 0 ] [ 0 ] ; }
COUNT_@@ OF_@@ PAIR@@ S_S@@ ATI@@ SF@@ Y@@ ING_@@ THE_@@ GI@@ V@@ EN_@@ CONDITION | static int count@@ Pair ( int a , int b ) { String s = String . valueOf ( b ) ; int i ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != '9' ) break ; } int result ; if ( i == s . length ( ) ) result = a * s . length ( ) ; else result = a * ( s . length ( ) - 1 ) ; return result ; }
SUR@@ VI@@ VAL | static void survi@@ val ( int S , int N , int M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) || M > N ) System . out . println ( " No " ) ; else { int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; System . out . println ( " Yes ▁ " + days ) ; } }
INTER@@ LE@@ AVE_@@ FIRST_@@ HALF_@@ QUEUE_@@ SECON@@ D_@@ HALF | static void inter@@ Leave@@ Queue ( Queue < Integer > q ) { if ( q . size ( ) % 2 != 0 ) System . out . println ( " Input ▁ even ▁ number ▁ of ▁ integers . " ) ; Stack < Integer > s = new Stack < > ( ) ; int half@@ Size = q . size ( ) / 2 ; for ( int i = 0 ; i < half@@ Size ; i ++ ) { s . push ( q . peek ( ) ) ; q . poll ( ) ; } while ( ! s . empty ( ) ) { q . add ( s . peek ( ) ) ; s . pop ( ) ; } for ( int i = 0 ; i < half@@ Size ; i ++ ) { q . add ( q . peek ( ) ) ; q . poll ( ) ; } for ( int i = 0 ; i < half@@ Size ; i ++ ) { s . push ( q . peek ( ) ) ; q . poll ( ) ; } while ( ! s . empty ( ) ) { q . add ( s . peek ( ) ) ; s . pop ( ) ; q . add ( q . peek ( ) ) ; q . poll ( ) ; } }
INTEGER_@@ POSITIVE_@@ VALUE_@@ POSITIVE_@@ NEGATIVE_@@ VALUE_@@ ARRAY_@@ 1 | static int find@@ Integer ( int arr [ ] , int n ) { int neg = 0 , pos = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] < 0 ) neg ++ ; else pos ++ ; } return ( sum / Math . abs ( neg - pos ) ) ; }
FIN@@ D_S@@ UM_@@ EV@@ EN_@@ INDEX_@@ BIN@@ O@@ MI@@ AL_@@ CO@@ EF@@ FI@@ CI@@ ENTS | static int even@@ Sum ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; }
DE@@ LAN@@ NO@@ Y_@@ NUMBER | public static int de@@ al@@ n@@ no@@ y ( int n , int m ) { if ( m == 0 || n == 0 ) return 1 ; return de@@ al@@ n@@ no@@ y ( m - 1 , n ) + de@@ al@@ n@@ no@@ y ( m - 1 , n - 1 ) + de@@ al@@ n@@ no@@ y ( m , n - 1 ) ; }
FIND_@@ THE_@@ LAR@@ GE@@ ST@@ _SUB@@ ARRAY_@@ WITH_@@ 0@@ _S@@ UM | static int maxLen ( int arr [ ] , int n ) { int max_len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_@@ sum = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_@@ sum += arr [ j ] ; if ( curr_@@ sum == 0 ) max_len = Math . max ( max_len , j - i + 1 ) ; } } return max_len ; }
NEXT_@@ POWER_@@ OF_@@ 2 | static int next@@ PowerOf@@ 2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
LON@@ GE@@ ST_@@ GEO@@ METRIC_@@ PROG@@ RES@@ SION | static int len@@ Of@@ Lon@@ gest@@ GP ( int set [ ] , int n ) { if ( n < 2 ) { return n ; } if ( n == 2 ) { return ( set [ 1 ] % set [ 0 ] == 0 ? 1 : 0 ) ; } Arrays . sort ( set ) ; int L [ ] [ ] = new int [ n ] [ n ] ; int ll@@ gp = 1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( set [ n - 1 ] % set [ i ] == 0 ) { L [ i ] [ n - 1 ] = 2 ; } else { L [ i ] [ n - 1 ] = 1 ; } } for ( int j = n - 2 ; j >= 1 ; -- j ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) { ++ k ; } else if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] ) { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = 2 ; } else { L [ i ] [ j ] = 1 ; } -- i ; } else { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; if ( L [ i ] [ j ] > ll@@ gp ) { ll@@ gp = L [ i ] [ j ] ; } -- i ; ++ k ; } } while ( i >= 0 ) { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = 2 ; } else { L [ i ] [ j ] = 1 ; } -- i ; } } return ll@@ gp ; }
DYNAMIC_@@ PROGR@@ AM@@ MIN@@ G@@ _SET_@@ 6_@@ MIN_@@ CO@@ ST_@@ PATH | private static int min@@ Cost ( int cost [ ] [ ] , int m , int n ) { int i , j ; int tc [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return tc [ m ] [ n ] ; }
PROGRAM_@@ DISTAN@@ CE_@@ TWO_@@ POINT@@ S_@@ EAR@@ TH | public static double distance ( double lat@@ 1 , double lat@@ 2 , double lon@@ 1 , double lon@@ 2 ) { lon@@ 1 = Math . to@@ Radians ( lon@@ 1 ) ; lon@@ 2 = Math . to@@ Radians ( lon@@ 2 ) ; lat@@ 1 = Math . to@@ Radians ( lat@@ 1 ) ; lat@@ 2 = Math . to@@ Radians ( lat@@ 2 ) ; double dl@@ on = lon@@ 2 - lon@@ 1 ; double dl@@ at = lat@@ 2 - lat@@ 1 ; double a = Math . pow ( Math . sin ( dl@@ at / 2 ) , 2 ) + Math . cos ( lat@@ 1 ) * Math . cos ( lat@@ 2 ) * Math . pow ( Math . sin ( dl@@ on / 2 ) , 2 ) ; double c = 2 * Math . asin ( Math . sqrt ( a ) ) ; double r = 637@@ 1 ; return ( c * r ) ; }
B@@ IN_@@ PAC@@ KING_@@ PRO@@ BLE@@ M_@@ MINI@@ MI@@ ZE_@@ NUMBER_OF_@@ USED_@@ BIN@@ S | static int next@@ Fit ( int weight [ ] , int n , int c ) { int res = 0 , bin@@ _re@@ m = c ; for ( int i = 0 ; i < n ; i ++ ) { if ( weight [ i ] > bin@@ _re@@ m ) { res ++ ; bin@@ _re@@ m = c - weight [ i ] ; } else bin@@ _re@@ m -= weight [ i ] ; } return res ; }
FIN@@ D@@ _SUB@@ ARRAY_@@ WITH_@@ GI@@ VEN@@ _S@@ UM@@ _1 | int sub@@ Array@@ Sum ( int arr [ ] , int n , int sum ) { int curr_@@ sum = arr [ 0 ] , start = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { while ( curr_@@ sum > sum && start < i - 1 ) { curr_@@ sum = curr_@@ sum - arr [ start ] ; start ++ ; } if ( curr_@@ sum == sum ) { int p = i - 1 ; System . out . println ( " Sum ▁ found ▁ between ▁ indexes ▁ " + start + " ▁ and ▁ " + p ) ; return 1 ; } if ( i < n ) curr_@@ sum = curr_@@ sum + arr [ i ] ; } System . out . println ( " No ▁ sub@@ array ▁ found " ) ; return 0 ; }
SPACE_@@ OPTIMIZ@@ ED_@@ D@@ P_S@@ OL@@ U@@ TION_@@ 0_@@ 1_@@ KN@@ AP@@ S@@ ACK_@@ PRO@@ BLE@@ M_@@ 1 | static int K@@ nap@@ S@@ ack ( int val [ ] , int wt [ ] , int n , int W ) { int [ ] dp = new int [ W + 1 ] ; Arrays . fill ( dp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; }
FIND_@@ VALUE_@@ OF_@@ Y_@@ MOD_@@ 2_@@ RAI@@ SED_@@ TO_@@ POWER_@@ X | static long y@@ Mod ( long y , long x ) { if ( ( Math . log ( y ) / Math . log ( 2 ) ) < x ) return y ; if ( x > 63 ) return y ; return ( y % ( 1 << ( int ) x ) ) ; }
SUM@@ _SERI@@ ES_@@ 23@@ _@@ 45@@ _@@ 67@@ _@@ 89@@ _@@ UP@@ TO_@@ N_@@ TER@@ MS | static double series@@ Sum ( int n ) { int i = 1 ; double res = 0.0 ; boolean sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ( double ) ++ i / ++ i ; } else { sign = ! sign ; res = res - ( double ) ++ i / ++ i ; } } return res ; }
LENGTH_@@ LON@@ GE@@ ST_@@ STRICT_@@ BIT@@ ON@@ IC@@ _SUB@@ SEQUENCE | static int long@@ Len@@ Strict@@ Bit@@ on@@ ic@@ Sub ( int arr [ ] , int n ) { HashMap < Integer , Integer > inc = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > d@@ cr = new HashMap < Integer , Integer > ( ) ; int len_@@ inc [ ] = new int [ n ] ; int len@@ _d@@ cr [ ] = new int [ n ] ; int long@@ Len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( inc . containsKey ( arr [ i ] - 1 ) ) len = inc . get ( arr [ i ] - 1 ) ; len_@@ inc [ i ] = len + 1 ; inc . put ( arr [ i ] , len_@@ inc [ i ] ) ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { int len = 0 ; if ( d@@ cr . containsKey ( arr [ i ] - 1 ) ) len = d@@ cr . get ( arr [ i ] - 1 ) ; len@@ _d@@ cr [ i ] = len + 1 ; d@@ cr . put ( arr [ i ] , len@@ _d@@ cr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) if ( long@@ Len < ( len_@@ inc [ i ] + len@@ _d@@ cr [ i ] - 1 ) ) long@@ Len = len_@@ inc [ i ] + len@@ _d@@ cr [ i ] - 1 ; return long@@ Len ; }
MAXIMUM_@@ DISTAN@@ CE_@@ TWO_@@ OC@@ CURR@@ EN@@ CES_@@ ELEMENT_@@ ARRAY | static int max@@ Distance ( int [ ] arr , int n ) { HashMap < Integer , Integer > map = new HashMap < > ( ) ; int max_@@ dist = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! map . containsKey ( arr [ i ] ) ) map . put ( arr [ i ] , i ) ; else max_@@ dist = Math . max ( max_@@ dist , i - map . get ( arr [ i ] ) ) ; } return max_@@ dist ; }
FIND_@@ REC@@ TAN@@ GLE_@@ BINARY_@@ MATRIX_@@ COR@@ NE@@ RS_@@ 1_1 | static boolean is@@ Rectangle ( int matrix [ ] [ ] ) { int rows = matrix . length ; if ( rows == 0 ) return false ; int columns = matrix [ 0 ] . length ; HashMap < Integer , HashSet < Integer > > table = new HashMap < > ( ) ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns - 1 ; j ++ ) { for ( int k = j + 1 ; k < columns ; k ++ ) { if ( matrix [ i ] [ j ] == 1 && matrix [ i ] [ k ] == 1 ) { if ( table . containsKey ( j ) && table . get ( j ) . contains ( k ) ) { return true ; } if ( table . containsKey ( k ) && table . get ( k ) . contains ( j ) ) { return true ; } if ( ! table . containsKey ( j ) ) { HashSet < Integer > x = new HashSet < > ( ) ; x . add ( k ) ; table . put ( j , x ) ; } else { table . get ( j ) . add ( k ) ; } if ( ! table . containsKey ( k ) ) { HashSet < Integer > x = new HashSet < > ( ) ; x . add ( j ) ; table . put ( k , x ) ; } else { table . get ( k ) . add ( j ) ; } } } } } return false ; }
COUNT_@@ MINIMUM_@@ NUMBER@@ _SUB@@ SET@@ S@@ _SUB@@ SEQU@@ EN@@ CES_@@ CON@@ SEC@@ UTI@@ VE_@@ NUMB@@ ERS | static int nu@@ mo@@ f@@ subset ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; } return count ; }
LAR@@ GE@@ ST@@ _S@@ UM_@@ CON@@ TI@@ GU@@ OU@@ S@@ _SUB@@ ARRAY | static int max@@ Sub@@ Array@@ Sum ( int a [ ] ) { int size = a . length ; int max_@@ so@@ _f@@ ar = Integer . MIN_VALUE , max_@@ ending_@@ here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_@@ ending_@@ here = max_@@ ending_@@ here + a [ i ] ; if ( max_@@ so@@ _f@@ ar < max_@@ ending_@@ here ) max_@@ so@@ _f@@ ar = max_@@ ending_@@ here ; if ( max_@@ ending_@@ here < 0 ) max_@@ ending_@@ here = 0 ; } return max_@@ so@@ _f@@ ar ; }
PROGRAM_@@ TO_@@ FIND_@@ RE@@ MA@@ INDE@@ R_@@ WITH@@ OUT_@@ USING_@@ MODUL@@ O_@@ OR_@@ OPERATOR_@@ 2 | static int getRe@@ main@@ der ( int num , int divisor ) { while ( num >= divisor ) num -= divisor ; return num ; }
CHECK_@@ LARGE_@@ NUMBER_@@ DI@@ VISI@@ BLE_@@ 4_@@ NOT | static boolean check ( String str ) { int n = str . length ( ) ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str . charAt ( 0 ) - '0' ) % 4 == 0 ) ; int last = str . charAt ( n - 1 ) - '0' ; int second_@@ last = str . charAt ( n - 2 ) - '0' ; return ( ( second_@@ last * 10 + last ) % 4 == 0 ) ; }
FIND_@@ THE_@@ ELEMENT_@@ TH@@ AT_@@ AP@@ PE@@ AR@@ S_@@ ON@@ CE_@@ 1 | static int get@@ Single ( int arr [ ] , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_@@ SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & x ) == 0 ) sum ++ ; } if ( ( sum % 3 ) == 0 ) result |= x ; } return result ; }
NUMBER_@@ REC@@ TA@@ NG@@ LES_@@ NM_@@ GRID | public static long rect@@ Count ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; }
MAXIMUM_@@ POINT@@ S_@@ INTER@@ SECTION_@@ N_@@ CIRC@@ LES | static int intersection ( int n ) { return n * ( n - 1 ) ; }
