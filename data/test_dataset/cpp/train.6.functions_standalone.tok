int main ( ) { string s ; cin >> s ; map < string , int > m ; vector < string > ar ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { string sstr = s . substr ( i , s . size ( ) - i ) ; m [ sstr ] = i ; ar . push_back ( sstr ) ; } sort ( ar . begin ( ) , ar . end ( ) ) ; for ( int i = 0 ; i < ar . size ( ) ; i ++ ) { cout << m [ ar [ i ] ] << endl ; } return 0 ; }
void printError ( const char * msg ) { QFile file ; file . open ( stderr , QIODevice :: WriteOnly ) ; file . write ( msg , qstrlen ( msg ) ) ; file . close ( ) ; }
template < class List > void BM_ListPushBack ( bm :: State & st ) { List li ; using T = typename List :: value_type ; T v { } ; size_t count = 0 ; while ( st . KeepRunning ( ) ) { for ( int i = 0 , e = st . range ( 0 ) ; i < e ; ++ i ) { if ( li . size ( ) == li . max_size ( ) ) li . clear ( ) ; li . push_back ( v ) ; ++ count ; } li . clear ( ) ; } st . SetComplexityN ( st . range ( 0 ) ) ; st . SetItemsProcessed ( count ) ; st . SetBytesProcessed ( count * sizeof ( T ) ) ; }
boss_nerubenkanAI ( Creature * creature ) : ScriptedAI ( creature ) { instance = me -> GetInstanceScript ( ) ; }
void Reset ( ) { CryptScarabs_Timer = 3000 ; EncasingWebs_Timer = 7000 ; PierceArmor_Timer = 19000 ; RaiseUndeadScarab_Timer = 3000 ; }
void JustDied ( Unit * ) { if ( instance ) instance -> SetData ( TYPE_NERUB , IN_PROGRESS ) ; }
void RaiseUndeadScarab ( Unit * victim ) { if ( Creature * pUndeadScarab = DoSpawnCreature ( 10876 , float ( irand ( - 9 , 9 ) ) , float ( irand ( - 9 , 9 ) ) , 0 , 0 , TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN , 180000 ) ) if ( pUndeadScarab -> AI ( ) ) pUndeadScarab -> AI ( ) -> AttackStart ( victim ) ; }
void UpdateAI ( const uint32 diff ) { if ( ! UpdateVictim ( ) ) return ; if ( EncasingWebs_Timer <= diff ) { DoCast ( me -> getVictim ( ) , SPELL_ENCASINGWEBS ) ; EncasingWebs_Timer = 30000 ; } else EncasingWebs_Timer -= diff ; if ( PierceArmor_Timer <= diff ) { if ( urand ( 0 , 3 ) < 2 ) DoCast ( me -> getVictim ( ) , SPELL_PIERCEARMOR ) ; PierceArmor_Timer = 35000 ; } else PierceArmor_Timer -= diff ; if ( CryptScarabs_Timer <= diff ) { DoCast ( me -> getVictim ( ) , SPELL_CRYPT_SCARABS ) ; CryptScarabs_Timer = 20000 ; } else CryptScarabs_Timer -= diff ; if ( RaiseUndeadScarab_Timer <= diff ) { RaiseUndeadScarab ( me -> getVictim ( ) ) ; RaiseUndeadScarab_Timer = 16000 ; } else RaiseUndeadScarab_Timer -= diff ; DoMeleeAttackIfReady ( ) ; }
void AddSC_boss_nerubenkan ( ) { new boss_nerubenkan ( ) ; }
void mexFunction ( int nlhs , mxArray * plhs [ ] , int nrhs , const mxArray * prhs [ ] ) { nargchk ( nrhs >= 1 && ( nrhs % 2 ) == 1 && nlhs <= 1 ) ; vector < MxArray > rhs ( prhs , prhs + nrhs ) ; int blockSize = 5 ; int ksize = 3 ; double k = 0.04 ; int borderType = cv :: BORDER_DEFAULT ; for ( int i = 1 ; i < nrhs ; i += 2 ) { string key ( rhs [ i ] . toString ( ) ) ; if ( key == " BlockSize " ) blockSize = rhs [ i + 1 ] . toInt ( ) ; else if ( key == " KSize " ) ksize = rhs [ i + 1 ] . toInt ( ) ; else if ( key == " K " ) k = rhs [ i + 1 ] . toDouble ( ) ; else if ( key == " BorderType " ) borderType = BorderType [ rhs [ i + 1 ] . toString ( ) ] ; else mexErrMsgIdAndTxt ( " mexopencv : error " , " Unrecognized ▁ option " ) ; } Mat src ( rhs [ 0 ] . toMat ( rhs [ 0 ] . isUint8 ( ) ? CV_8U : CV_32F ) ) , dst ; cornerHarris ( src , dst , blockSize , ksize , k , borderType ) ; plhs [ 0 ] = MxArray ( dst ) ; }
public : bool load ( const std :: string & , const boost :: optional < std :: string > & , const std :: vector < std :: string > & ) { return load_status ; }
Data ( size_t data_identifier = 0 ) : data_identifier ( data_identifier ) { is_connected_to_rabbitmq = false ; }
~ Data ( ) { Data :: destructor_called = true ; }
fixture ( ) { Data :: load_status = true ; Data :: destructor_called = false ; }
BOOST_FIXTURE_TEST_SUITE ( s , fixture ) BOOST_AUTO_TEST_CASE ( get_data ) { DataManager < Data > data_manager ; auto data = data_manager . get_data ( ) ; BOOST_REQUIRE ( data ) ; BOOST_CHECK_EQUAL ( Data :: destructor_called , false ) ; }
BOOST_AUTO_TEST_CASE ( load_success ) { DataManager < Data > data_manager ; auto first_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , data_manager . get_data ( ) ) ; BOOST_CHECK ( data_manager . load ( " " ) ) ; auto second_data = data_manager . get_data ( ) ; BOOST_CHECK_NE ( first_data , second_data ) ; BOOST_CHECK_EQUAL ( Data :: destructor_called , false ) ; }
BOOST_AUTO_TEST_CASE ( load_fail ) { DataManager < Data > data_manager ; auto first_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , data_manager . get_data ( ) ) ; Data :: load_status = false ; BOOST_CHECK ( ! data_manager . load ( " " ) ) ; Data :: load_status = true ; auto second_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , second_data ) ; }
BOOST_AUTO_TEST_CASE ( destructor_called ) { DataManager < Data > data_manager ; { auto first_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , data_manager . get_data ( ) ) ; BOOST_CHECK ( data_manager . load ( " " ) ) ; auto second_data = data_manager . get_data ( ) ; BOOST_CHECK_NE ( first_data , second_data ) ; BOOST_CHECK_EQUAL ( Data :: destructor_called , false ) ; first_data = boost :: shared_ptr < Data > ( ) ; } BOOST_CHECK_EQUAL ( Data :: destructor_called , true ) ; BOOST_CHECK ( data_manager . get_data ( ) ) ; }
int System_GetPropertyInt ( SystemProperty prop ) { return - 1 ; }
float fastasin ( double x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; float sqrtthing = sqrt ( 1.0f - x * x ) ; float y = - .3572142480f + .1087063463f * x ; y = y * x + 1.062519236f ; y = y * x + - 2.511278506f ; y = y * x + .191900116f ; y = y * x + 1.807607311f ; y /= ( 1.807607311f - 1.615195094 * x ) ; return sign * ( y - sqrtthing ) ; }
double atan_66s ( double x ) { const double c1 = 1.6867629106 ; const double c2 = 0.4378497304 ; const double c3 = 1.6867633134 ; double x2 ; x2 = x * x ; return ( x * ( c1 + x2 * c2 ) / ( c3 + x2 ) ) ; }
double fastasin2 ( double x ) { return atan_66s ( x / sqrt ( 1 - x * x ) ) ; }
float fastasin3 ( float x ) { return x + x * x * x * x * x * 0.4971 ; }
float fastasin4 ( float x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; x = M_PI / 2 - sqrtf ( 1.0f - x ) * ( 1.5707288 + - 0.2121144 * x + 0.0742610 * x * x + - 0.0187293 * x * x * x ) ; return sign * x ; }
float fastasin5 ( float x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; float fRoot = sqrtf ( 1.0f - x ) ; float fResult = 0.0742610f + - 0.0187293f * x ; fResult = - 0.2121144f + fResult * x ; fResult = 1.5707288f + fResult * x ; fResult = M_PI / 2 - fRoot * fResult ; return sign * fResult ; }
static ImVec4 RGBAToImVec4 ( const u32 rgba ) { return ImVec4 ( static_cast < float > ( ( rgba >> 16 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 8 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 0 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 24 ) & 0xFF ) / 255.0f ) ; }
static float DrawMessage ( int index , const Message & msg , const ImVec2 & position , int time_left ) { const std :: string window_name = fmt :: format ( " osd _ { } " , index ) ; ImGui :: SetNextWindowPos ( position ) ; ImGui :: SetNextWindowSize ( ImVec2 ( 0.0f , 0.0f ) ) ; const float alpha = std :: min ( 1.0f , std :: max ( 0.0f , time_left / 1024.0f ) ) ; ImGui :: PushStyleVar ( ImGuiStyleVar_Alpha , alpha ) ; float window_height = 0.0f ; if ( ImGui :: Begin ( window_name . c_str ( ) , nullptr , ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoFocusOnAppearing ) ) { ImGui :: TextColored ( RGBAToImVec4 ( msg . color ) , " % s " , msg . text . c_str ( ) ) ; window_height = ImGui :: GetWindowSize ( ) . y + ( WINDOW_PADDING * ImGui :: GetIO ( ) . DisplayFramebufferScale . y ) ; } ImGui :: End ( ) ; ImGui :: PopStyleVar ( ) ; return window_height ; }
void AddTypedMessage ( MessageType type , std :: string message , u32 ms , u32 rgba ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . erase ( type ) ; s_messages . emplace ( type , Message ( std :: move ( message ) , Common :: Timer :: GetTimeMs ( ) + ms , rgba ) ) ; }
void AddMessage ( std :: string message , u32 ms , u32 rgba ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . emplace ( MessageType :: Typeless , Message ( std :: move ( message ) , Common :: Timer :: GetTimeMs ( ) + ms , rgba ) ) ; }
void DrawMessages ( ) { if ( ! SConfig :: GetInstance ( ) . bOnScreenDisplayMessages ) return ; { std :: lock_guard lock { s_messages_mutex } ; const u32 now = Common :: Timer :: GetTimeMs ( ) ; float current_x = LEFT_MARGIN * ImGui :: GetIO ( ) . DisplayFramebufferScale . x ; float current_y = TOP_MARGIN * ImGui :: GetIO ( ) . DisplayFramebufferScale . y ; int index = 0 ; auto it = s_messages . begin ( ) ; while ( it != s_messages . end ( ) ) { const Message & msg = it -> second ; const int time_left = static_cast < int > ( msg . timestamp - now ) ; current_y += DrawMessage ( index ++ , msg , ImVec2 ( current_x , current_y ) , time_left ) ; if ( time_left <= 0 ) it = s_messages . erase ( it ) ; else ++ it ; } } }
void ClearMessages ( ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . clear ( ) ; }
static AvailableValsTy & getAvailableVals ( void * AV ) { return * static_cast < AvailableValsTy * > ( AV ) ; }
static unsigned LookForIdenticalPHI ( MachineBasicBlock * BB , SmallVectorImpl < std :: pair < MachineBasicBlock * , unsigned > > & PredValues ) { if ( BB -> empty ( ) ) return 0 ; MachineBasicBlock :: iterator I = BB -> begin ( ) ; if ( ! I -> isPHI ( ) ) return 0 ; AvailableValsTy AVals ; for ( unsigned i = 0 , e = PredValues . size ( ) ; i != e ; ++ i ) AVals [ PredValues [ i ] . first ] = PredValues [ i ] . second ; while ( I != BB -> end ( ) && I -> isPHI ( ) ) { bool Same = true ; for ( unsigned i = 1 , e = I -> getNumOperands ( ) ; i != e ; i += 2 ) { unsigned SrcReg = I -> getOperand ( i ) . getReg ( ) ; MachineBasicBlock * SrcBB = I -> getOperand ( i + 1 ) . getMBB ( ) ; if ( AVals [ SrcBB ] != SrcReg ) { Same = false ; break ; } } if ( Same ) return I -> getOperand ( 0 ) . getReg ( ) ; ++ I ; } return 0 ; }
static MachineInstrBuilder InsertNewDef ( unsigned Opcode , MachineBasicBlock * BB , MachineBasicBlock :: iterator I , const TargetRegisterClass * RC , MachineRegisterInfo * MRI , const TargetInstrInfo * TII ) { unsigned NewVR = MRI -> createVirtualRegister ( RC ) ; return BuildMI ( * BB , I , DebugLoc ( ) , TII -> get ( Opcode ) , NewVR ) ; }
static MachineBasicBlock * findCorrespondingPred ( const MachineInstr * MI , MachineOperand * U ) { for ( unsigned i = 1 , e = MI -> getNumOperands ( ) ; i != e ; i += 2 ) { if ( & MI -> getOperand ( i ) == U ) return MI -> getOperand ( i + 1 ) . getMBB ( ) ; } llvm_unreachable ( " MachineOperand : : getParent ( ) ▁ failure ? " ) ; }
static BlkSucc_iterator BlkSucc_begin ( BlkT * BB ) { return BB -> succ_begin ( ) ; }
static BlkSucc_iterator BlkSucc_end ( BlkT * BB ) { return BB -> succ_end ( ) ; }
unsigned getIncomingValue ( ) { return PHI -> getOperand ( idx ) . getReg ( ) ; }
MachineBasicBlock * getIncomingBlock ( ) { return PHI -> getOperand ( idx + 1 ) . getMBB ( ) ; }
static inline PHI_iterator PHI_begin ( PhiT * PHI ) { return PHI_iterator ( PHI ) ; }
static inline PHI_iterator PHI_end ( PhiT * PHI ) { return PHI_iterator ( PHI , true ) ; }
static void FindPredecessorBlocks ( MachineBasicBlock * BB , SmallVectorImpl < MachineBasicBlock * > * Preds ) { for ( MachineBasicBlock :: pred_iterator PI = BB -> pred_begin ( ) , E = BB -> pred_end ( ) ; PI != E ; ++ PI ) Preds -> push_back ( * PI ) ; }
static unsigned GetUndefVal ( MachineBasicBlock * BB , MachineSSAUpdater * Updater ) { MachineInstr * NewDef = InsertNewDef ( TargetOpcode :: IMPLICIT_DEF , BB , BB -> getFirstTerminator ( ) , Updater -> VRC , Updater -> MRI , Updater -> TII ) ; return NewDef -> getOperand ( 0 ) . getReg ( ) ; }
static unsigned CreateEmptyPHI ( MachineBasicBlock * BB , unsigned NumPreds , MachineSSAUpdater * Updater ) { MachineBasicBlock :: iterator Loc = BB -> empty ( ) ? BB -> end ( ) : BB -> begin ( ) ; MachineInstr * PHI = InsertNewDef ( TargetOpcode :: PHI , BB , Loc , Updater -> VRC , Updater -> MRI , Updater -> TII ) ; return PHI -> getOperand ( 0 ) . getReg ( ) ; }
static void AddPHIOperand ( MachineInstr * PHI , unsigned Val , MachineBasicBlock * Pred ) { MachineInstrBuilder ( * Pred -> getParent ( ) , PHI ) . addReg ( Val ) . addMBB ( Pred ) ; }
static MachineInstr * InstrIsPHI ( MachineInstr * I ) { if ( I && I -> isPHI ( ) ) return I ; return nullptr ; }
static MachineInstr * ValueIsPHI ( unsigned Val , MachineSSAUpdater * Updater ) { return InstrIsPHI ( Updater -> MRI -> getVRegDef ( Val ) ) ; }
static MachineInstr * ValueIsNewPHI ( unsigned Val , MachineSSAUpdater * Updater ) { MachineInstr * PHI = ValueIsPHI ( Val , Updater ) ; if ( PHI && PHI -> getNumOperands ( ) <= 1 ) return PHI ; return nullptr ; }
static unsigned GetPHIValue ( MachineInstr * PHI ) { return PHI -> getOperand ( 0 ) . getReg ( ) ; }
void reset ( ) { fSyllableCount += 1 ; }
void writeChar ( LEUnicode ch , le_uint32 charIndex , FeatureMask featureMask ) { LEErrorCode success = LE_NO_ERROR ; fOutChars [ fOutIndex ] = ch ; fGlyphStorage . setCharIndex ( fOutIndex , charIndex , success ) ; fGlyphStorage . setAuxData ( fOutIndex , featureMask , success ) ; fOutIndex += 1 ; }
le_int32 getOutputIndex ( ) { return fOutIndex ; }
void getUserInfo ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMUsersInfoReq msg ; IM :: Buddy :: IMUsersInfoRsp msgResp ; if ( msg . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { CImPdu * pPduRes = new CImPdu ; uint32_t from_user_id = msg . user_id ( ) ; uint32_t userCount = msg . user_id_list_size ( ) ; std :: list < uint32_t > idList ; for ( uint32_t i = 0 ; i < userCount ; ++ i ) { idList . push_back ( msg . user_id_list ( i ) ) ; } std :: list < IM :: BaseDefine :: UserInfo > lsUser ; CUserModel :: getInstance ( ) -> getUsers ( idList , lsUser ) ; msgResp . set_user_id ( from_user_id ) ; for ( list < IM :: BaseDefine :: UserInfo > :: iterator it = lsUser . begin ( ) ; it != lsUser . end ( ) ; ++ it ) { IM :: BaseDefine :: UserInfo * pUser = msgResp . add_user_info_list ( ) ; pUser -> set_user_id ( it -> user_id ( ) ) ; pUser -> set_user_gender ( it -> user_gender ( ) ) ; pUser -> set_user_nick_name ( it -> user_nick_name ( ) ) ; pUser -> set_avatar_url ( it -> avatar_url ( ) ) ; pUser -> set_sign_info ( it -> sign_info ( ) ) ; pUser -> set_department_id ( it -> department_id ( ) ) ; pUser -> set_email ( it -> email ( ) ) ; pUser -> set_user_real_name ( it -> user_real_name ( ) ) ; pUser -> set_user_tel ( it -> user_tel ( ) ) ; pUser -> set_user_domain ( it -> user_domain ( ) ) ; pUser -> set_status ( it -> status ( ) ) ; } log ( " userId = % u , ▁ userCnt = % u " , from_user_id , userCount ) ; msgResp . set_attach_data ( msg . attach_data ( ) ) ; pPduRes -> SetPBMsg ( & msgResp ) ; pPduRes -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pPduRes -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pPduRes -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_USER_INFO_RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pPduRes ) ; } else { log ( " parse ▁ pb ▁ failed " ) ; } }
void getChangedUser ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMAllUserReq msg ; IM :: Buddy :: IMAllUserRsp msgResp ; if ( msg . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { CImPdu * pPduRes = new CImPdu ; uint32_t nReqId = msg . user_id ( ) ; uint32_t nLastTime = msg . latest_update_time ( ) ; uint32_t nLastUpdate = CSyncCenter :: getInstance ( ) -> getLastUpdate ( ) ; list < IM :: BaseDefine :: UserInfo > lsUsers ; if ( nLastUpdate > nLastTime ) { list < uint32_t > lsIds ; CUserModel :: getInstance ( ) -> getChangedId ( nLastTime , lsIds ) ; CUserModel :: getInstance ( ) -> getUsers ( lsIds , lsUsers ) ; } msgResp . set_user_id ( nReqId ) ; msgResp . set_latest_update_time ( nLastTime ) ; for ( list < IM :: BaseDefine :: UserInfo > :: iterator it = lsUsers . begin ( ) ; it != lsUsers . end ( ) ; ++ it ) { IM :: BaseDefine :: UserInfo * pUser = msgResp . add_user_list ( ) ; pUser -> set_user_id ( it -> user_id ( ) ) ; pUser -> set_user_gender ( it -> user_gender ( ) ) ; pUser -> set_user_nick_name ( it -> user_nick_name ( ) ) ; pUser -> set_avatar_url ( it -> avatar_url ( ) ) ; pUser -> set_sign_info ( it -> sign_info ( ) ) ; pUser -> set_department_id ( it -> department_id ( ) ) ; pUser -> set_email ( it -> email ( ) ) ; pUser -> set_user_real_name ( it -> user_real_name ( ) ) ; pUser -> set_user_tel ( it -> user_tel ( ) ) ; pUser -> set_user_domain ( it -> user_domain ( ) ) ; pUser -> set_status ( it -> status ( ) ) ; } log ( " userId = % u , nLastUpdate = % u , ▁ last _ time = % u , ▁ userCnt = % u " , nReqId , nLastUpdate , nLastTime , msgResp . user_list_size ( ) ) ; msgResp . set_attach_data ( msg . attach_data ( ) ) ; pPduRes -> SetPBMsg ( & msgResp ) ; pPduRes -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pPduRes -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pPduRes -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_ALL_USER_RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pPduRes ) ; } else { log ( " parse ▁ pb ▁ failed " ) ; } }
void changeUserSignInfo ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMChangeSignInfoReq req ; IM :: Buddy :: IMChangeSignInfoRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; const string & sign_info = req . sign_info ( ) ; bool result = CUserModel :: getInstance ( ) -> updateUserSignInfo ( user_id , sign_info ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_sign_info ( sign_info ) ; log ( " changeUserSignInfo ▁ sucess , ▁ user _ id = % u , ▁ sign _ info = % s " , user_id , sign_info . c_str ( ) ) ; } else { log ( " changeUserSignInfo ▁ false , ▁ user _ id = % u , ▁ sign _ info = % s " , user_id , sign_info . c_str ( ) ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " changeUserSignInfo : ▁ IMChangeSignInfoReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } }
void doPushShield ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Login :: IMPushShieldReq req ; IM :: Login :: IMPushShieldRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; uint32_t shield_status = req . shield_status ( ) ; bool result = CUserModel :: getInstance ( ) -> updatePushShield ( user_id , shield_status ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_shield_status ( shield_status ) ; log ( " doPushShield ▁ sucess , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } else { log ( " doPushShield ▁ false , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_LOGIN ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_LOGIN_RES_PUSH_SHIELD ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " doPushShield : ▁ IMPushShieldReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } }
void doQueryPushShield ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Login :: IMQueryPushShieldReq req ; IM :: Login :: IMQueryPushShieldRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; uint32_t shield_status = 0 ; bool result = CUserModel :: getInstance ( ) -> getPushShield ( user_id , & shield_status ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_shield_status ( shield_status ) ; log ( " doQueryPushShield ▁ sucess , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } else { log ( " doQueryPushShield ▁ false , ▁ user _ id = % u " , user_id ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_LOGIN ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_LOGIN_RES_QUERY_PUSH_SHIELD ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " doQueryPushShield : ▁ IMQueryPushShieldReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } }
clipHandle_t SV_ClipHandleForEntity ( const sharedEntity_t * ent ) { if ( ent -> r . bmodel ) { return CM_InlineModel ( ent -> s . modelindex ) ; } if ( ent -> r . svFlags & SVF_CAPSULE ) { return CM_TempBoxModel ( ent -> r . mins , ent -> r . maxs , qtrue ) ; } return CM_TempBoxModel ( ent -> r . mins , ent -> r . maxs , qfalse ) ; }
void SV_SectorList_f ( void ) { int i , c ; worldSector_t * sec ; svEntity_t * ent ; for ( i = 0 ; i < AREA_NODES ; i ++ ) { sec = & sv_worldSectors [ i ] ; c = 0 ; for ( ent = sec -> entities ; ent ; ent = ent -> nextEntityInWorldSector ) { c ++ ; } Com_Printf ( " sector ▁ % i : ▁ % i ▁ entities \n " , i , c ) ; } }
worldSector_t * SV_CreateworldSector ( int depth , vec3_t mins , vec3_t maxs ) { worldSector_t * anode ; vec3_t size ; vec3_t mins1 , maxs1 , mins2 , maxs2 ; anode = & sv_worldSectors [ sv_numworldSectors ] ; sv_numworldSectors ++ ; if ( depth == AREA_DEPTH ) { anode -> axis = - 1 ; anode -> children [ 0 ] = anode -> children [ 1 ] = NULL ; return anode ; } VectorSubtract ( maxs , mins , size ) ; if ( size [ 0 ] > size [ 1 ] ) { anode -> axis = 0 ; } else { anode -> axis = 1 ; } anode -> dist = 0.5 * ( maxs [ anode -> axis ] + mins [ anode -> axis ] ) ; VectorCopy ( mins , mins1 ) ; VectorCopy ( mins , mins2 ) ; VectorCopy ( maxs , maxs1 ) ; VectorCopy ( maxs , maxs2 ) ; maxs1 [ anode -> axis ] = mins2 [ anode -> axis ] = anode -> dist ; anode -> children [ 0 ] = SV_CreateworldSector ( depth + 1 , mins2 , maxs2 ) ; anode -> children [ 1 ] = SV_CreateworldSector ( depth + 1 , mins1 , maxs1 ) ; return anode ; }
void SV_ClearWorld ( void ) { clipHandle_t h ; vec3_t mins , maxs ; Com_Memset ( sv_worldSectors , 0 , sizeof ( sv_worldSectors ) ) ; sv_numworldSectors = 0 ; h = CM_InlineModel ( 0 ) ; CM_ModelBounds ( h , mins , maxs ) ; SV_CreateworldSector ( 0 , mins , maxs ) ; }
void SV_UnlinkEntity ( sharedEntity_t * gEnt ) { svEntity_t * ent ; svEntity_t * scan ; worldSector_t * ws ; ent = SV_SvEntityForGentity ( gEnt ) ; gEnt -> r . linked = qfalse ; ws = ent -> worldSector ; if ( ! ws ) { return ; } ent -> worldSector = NULL ; if ( ws -> entities == ent ) { ws -> entities = ent -> nextEntityInWorldSector ; return ; } for ( scan = ws -> entities ; scan ; scan = scan -> nextEntityInWorldSector ) { if ( scan -> nextEntityInWorldSector == ent ) { scan -> nextEntityInWorldSector = ent -> nextEntityInWorldSector ; return ; } } Com_Printf ( " WARNING : ▁ SV _ UnlinkEntity : ▁ not ▁ found ▁ in ▁ worldSector \n " ) ; }
void SV_LinkEntity ( sharedEntity_t * gEnt ) { worldSector_t * node ; int leafs [ MAX_TOTAL_ENT_LEAFS ] ; int cluster ; int num_leafs ; int i , j , k ; int area ; int lastLeaf ; float * origin , * angles ; svEntity_t * ent ; ent = SV_SvEntityForGentity ( gEnt ) ; if ( ent -> worldSector ) { SV_UnlinkEntity ( gEnt ) ; } if ( gEnt -> r . bmodel ) { gEnt -> s . solid = SOLID_BMODEL ; } else if ( gEnt -> r . contents & ( CONTENTS_SOLID | CONTENTS_BODY ) ) { i = gEnt -> r . maxs [ 0 ] ; if ( i < 1 ) i = 1 ; if ( i > 255 ) i = 255 ; j = ( - gEnt -> r . mins [ 2 ] ) ; if ( j < 1 ) j = 1 ; if ( j > 255 ) j = 255 ; k = ( gEnt -> r . maxs [ 2 ] + 32 ) ; if ( k < 1 ) k = 1 ; if ( k > 255 ) k = 255 ; gEnt -> s . solid = ( k << 16 ) | ( j << 8 ) | i ; } else { gEnt -> s . solid = 0 ; } origin = gEnt -> r . currentOrigin ; angles = gEnt -> r . currentAngles ; if ( gEnt -> r . bmodel && ( angles [ 0 ] || angles [ 1 ] || angles [ 2 ] ) ) { float max ; int i ; max = RadiusFromBounds ( gEnt -> r . mins , gEnt -> r . maxs ) ; for ( i = 0 ; i < 3 ; i ++ ) { gEnt -> r . absmin [ i ] = origin [ i ] - max ; gEnt -> r . absmax [ i ] = origin [ i ] + max ; } } else { VectorAdd ( origin , gEnt -> r . mins , gEnt -> r . absmin ) ; VectorAdd ( origin , gEnt -> r . maxs , gEnt -> r . absmax ) ; } gEnt -> r . absmin [ 0 ] -= 1 ; gEnt -> r . absmin [ 1 ] -= 1 ; gEnt -> r . absmin [ 2 ] -= 1 ; gEnt -> r . absmax [ 0 ] += 1 ; gEnt -> r . absmax [ 1 ] += 1 ; gEnt -> r . absmax [ 2 ] += 1 ; ent -> numClusters = 0 ; ent -> lastCluster = 0 ; ent -> areanum = - 1 ; ent -> areanum2 = - 1 ; num_leafs = CM_BoxLeafnums ( gEnt -> r . absmin , gEnt -> r . absmax , leafs , MAX_TOTAL_ENT_LEAFS , & lastLeaf ) ; if ( ! num_leafs ) { return ; } for ( i = 0 ; i < num_leafs ; i ++ ) { area = CM_LeafArea ( leafs [ i ] ) ; if ( area != - 1 ) { if ( ent -> areanum != - 1 && ent -> areanum != area ) { if ( ent -> areanum2 != - 1 && ent -> areanum2 != area && sv . state == SS_LOADING ) { Com_DPrintf ( " Object ▁ % i ▁ touching ▁ 3 ▁ areas ▁ at ▁ % f ▁ % f ▁ % f \n " , gEnt -> s . number , gEnt -> r . absmin [ 0 ] , gEnt -> r . absmin [ 1 ] , gEnt -> r . absmin [ 2 ] ) ; } ent -> areanum2 = area ; } else { ent -> areanum = area ; } } } ent -> numClusters = 0 ; for ( i = 0 ; i < num_leafs ; i ++ ) { cluster = CM_LeafCluster ( leafs [ i ] ) ; if ( cluster != - 1 ) { ent -> clusternums [ ent -> numClusters ++ ] = cluster ; if ( ent -> numClusters == MAX_ENT_CLUSTERS ) { break ; } } } if ( i != num_leafs ) { ent -> lastCluster = CM_LeafCluster ( lastLeaf ) ; } gEnt -> r . linkcount ++ ; node = sv_worldSectors ; while ( 1 ) { if ( node -> axis == - 1 ) break ; if ( gEnt -> r . absmin [ node -> axis ] > node -> dist ) node = node -> children [ 0 ] ; else if ( gEnt -> r . absmax [ node -> axis ] < node -> dist ) node = node -> children [ 1 ] ; else break ; } ent -> worldSector = node ; ent -> nextEntityInWorldSector = node -> entities ; node -> entities = ent ; gEnt -> r . linked = qtrue ; }
void SV_AreaEntities_r ( worldSector_t * node , areaParms_t * ap ) { svEntity_t * check , * next ; sharedEntity_t * gcheck ; int count ; count = 0 ; for ( check = node -> entities ; check ; check = next ) { next = check -> nextEntityInWorldSector ; gcheck = SV_GEntityForSvEntity ( check ) ; if ( gcheck -> r . absmin [ 0 ] > ap -> maxs [ 0 ] || gcheck -> r . absmin [ 1 ] > ap -> maxs [ 1 ] || gcheck -> r . absmin [ 2 ] > ap -> maxs [ 2 ] || gcheck -> r . absmax [ 0 ] < ap -> mins [ 0 ] || gcheck -> r . absmax [ 1 ] < ap -> mins [ 1 ] || gcheck -> r . absmax [ 2 ] < ap -> mins [ 2 ] ) { continue ; } if ( ap -> count == ap -> maxcount ) { Com_Printf ( " SV _ AreaEntities : ▁ MAXCOUNT \n " ) ; return ; } ap -> list [ ap -> count ] = check - sv . svEntities ; ap -> count ++ ; } if ( node -> axis == - 1 ) { return ; } if ( ap -> maxs [ node -> axis ] > node -> dist ) { SV_AreaEntities_r ( node -> children [ 0 ] , ap ) ; } if ( ap -> mins [ node -> axis ] < node -> dist ) { SV_AreaEntities_r ( node -> children [ 1 ] , ap ) ; } }
int SV_AreaEntities ( const vec3_t mins , const vec3_t maxs , int * entityList , int maxcount ) { areaParms_t ap ; ap . mins = mins ; ap . maxs = maxs ; ap . list = entityList ; ap . count = 0 ; ap . maxcount = maxcount ; SV_AreaEntities_r ( sv_worldSectors , & ap ) ; return ap . count ; }
void SV_ClipToEntity ( trace_t * trace , const vec3_t start , const vec3_t mins , const vec3_t maxs , const vec3_t end , int entityNum , int contentmask , int capsule ) { sharedEntity_t * touch ; clipHandle_t clipHandle ; float * origin , * angles ; touch = SV_GentityNum ( entityNum ) ; Com_Memset ( trace , 0 , sizeof ( trace_t ) ) ; if ( ! ( contentmask & touch -> r . contents ) ) { trace -> fraction = 1.0 ; return ; } clipHandle = SV_ClipHandleForEntity ( touch ) ; origin = touch -> r . currentOrigin ; angles = touch -> r . currentAngles ; if ( ! touch -> r . bmodel ) { angles = vec3_origin ; } CM_TransformedBoxTrace ( trace , ( float * ) start , ( float * ) end , ( float * ) mins , ( float * ) maxs , clipHandle , contentmask , origin , angles , capsule ) ; if ( trace -> fraction < 1 ) { trace -> entityNum = touch -> s . number ; } }
void SV_ClipMoveToEntities ( moveclip_t * clip ) { int i , num ; int touchlist [ MAX_GENTITIES ] ; sharedEntity_t * touch ; int passOwnerNum ; trace_t trace , oldTrace ; clipHandle_t clipHandle ; float * origin , * angles ; int thisOwnerShared = 1 ; num = SV_AreaEntities ( clip -> boxmins , clip -> boxmaxs , touchlist , MAX_GENTITIES ) ; if ( clip -> passEntityNum != ENTITYNUM_NONE ) { passOwnerNum = ( SV_GentityNum ( clip -> passEntityNum ) ) -> r . ownerNum ; if ( passOwnerNum == ENTITYNUM_NONE ) { passOwnerNum = - 1 ; } } else { passOwnerNum = - 1 ; } if ( SV_GentityNum ( clip -> passEntityNum ) -> r . svFlags & SVF_OWNERNOTSHARED ) { thisOwnerShared = 0 ; } for ( i = 0 ; i < num ; i ++ ) { if ( clip -> trace . allsolid ) { return ; } touch = SV_GentityNum ( touchlist [ i ] ) ; if ( clip -> passEntityNum != ENTITYNUM_NONE ) { if ( touchlist [ i ] == clip -> passEntityNum ) { continue ; } if ( touch -> r . ownerNum == clip -> passEntityNum ) { if ( touch -> r . svFlags & SVF_OWNERNOTSHARED ) { if ( clip -> contentmask != ( MASK_SHOT | CONTENTS_LIGHTSABER ) && clip -> contentmask != ( MASK_SHOT ) ) { continue ; } } else { continue ; } } if ( touch -> r . ownerNum == passOwnerNum && ! ( touch -> r . svFlags & SVF_OWNERNOTSHARED ) && ! thisOwnerShared ) { continue ; } } if ( ! ( clip -> contentmask & touch -> r . contents ) ) { continue ; } if ( ( clip -> contentmask == ( MASK_SHOT | CONTENTS_LIGHTSABER ) || clip -> contentmask == MASK_SHOT ) && ( touch -> r . contents > 0 && ( touch -> r . contents & CONTENTS_NOSHOT ) ) ) { continue ; } clipHandle = SV_ClipHandleForEntity ( touch ) ; origin = touch -> r . currentOrigin ; angles = touch -> r . currentAngles ; if ( ! touch -> r . bmodel ) { angles = vec3_origin ; } CM_TransformedBoxTrace ( & trace , ( float * ) clip -> start , ( float * ) clip -> end , ( float * ) clip -> mins , ( float * ) clip -> maxs , clipHandle , clip -> contentmask , origin , angles , clip -> capsule ) ; oldTrace = clip -> trace ; if ( trace . allsolid ) { clip -> trace . allsolid = qtrue ; trace . entityNum = touch -> s . number ; } else if ( trace . startsolid ) { clip -> trace . startsolid = qtrue ; trace . entityNum = touch -> s . number ; } if ( trace . fraction < clip -> trace . fraction ) { qboolean oldStart ; oldStart = clip -> trace . startsolid ; trace . entityNum = touch -> s . number ; clip -> trace = trace ; clip -> trace . startsolid = ( qboolean ) ( ( unsigned ) clip -> trace . startsolid | ( unsigned ) oldStart ) ; } if ( ( trace . entityNum == touch -> s . number ) && ( clip -> traceFlags ) ) { if ( touch -> s . ghoul2 ) { int oldTraceRecSize = 0 ; int newTraceRecSize = 0 ; int z ; for ( z = 0 ; z < MAX_G2_COLLISIONS ; z ++ ) { if ( clip -> trace . G2CollisionMap [ z ] . mEntityNum != - 1 ) { oldTraceRecSize ++ ; } } G2API_CollisionDetect ( & clip -> trace . G2CollisionMap [ 0 ] , * ( ( CGhoul2Info_v * ) touch -> s . ghoul2 ) , touch -> s . angles , touch -> s . origin , svs . time , touch -> s . number , clip -> start , clip -> end , touch -> s . modelScale , G2VertSpaceServer , clip -> traceFlags , clip -> useLod ) ; for ( z = 0 ; z < MAX_G2_COLLISIONS ; z ++ ) { if ( clip -> trace . G2CollisionMap [ z ] . mEntityNum != - 1 ) { newTraceRecSize ++ ; } } if ( newTraceRecSize == oldTraceRecSize ) { clip -> trace = oldTrace ; } } } } }
void SV_Trace ( trace_t * results , const vec3_t start , const vec3_t mins , const vec3_t maxs , const vec3_t end , int passEntityNum , int contentmask , int capsule , int traceFlags , int useLod ) { moveclip_t clip ; int i ; if ( ! mins ) { mins = vec3_origin ; } if ( ! maxs ) { maxs = vec3_origin ; } Com_Memset ( & clip , 0 , sizeof ( moveclip_t ) ) ; CM_BoxTrace ( & clip . trace , start , end , mins , maxs , 0 , contentmask , capsule ) ; clip . trace . entityNum = clip . trace . fraction != 1.0 ? ENTITYNUM_WORLD : ENTITYNUM_NONE ; if ( clip . trace . fraction == 0 ) { * results = clip . trace ; return ; } clip . contentmask = contentmask ; VectorCopy ( start , clip . start ) ; clip . traceFlags = traceFlags ; clip . useLod = useLod ; VectorCopy ( end , clip . end ) ; clip . mins = mins ; clip . maxs = maxs ; clip . passEntityNum = passEntityNum ; clip . capsule = capsule ; for ( i = 0 ; i < 3 ; i ++ ) { if ( end [ i ] > start [ i ] ) { clip . boxmins [ i ] = clip . start [ i ] + clip . mins [ i ] - 1 ; clip . boxmaxs [ i ] = clip . end [ i ] + clip . maxs [ i ] + 1 ; } else { clip . boxmins [ i ] = clip . end [ i ] + clip . mins [ i ] - 1 ; clip . boxmaxs [ i ] = clip . start [ i ] + clip . maxs [ i ] + 1 ; } } SV_ClipMoveToEntities ( & clip ) ; * results = clip . trace ; }
int SV_PointContents ( const vec3_t p , int passEntityNum ) { int touch [ MAX_GENTITIES ] ; sharedEntity_t * hit ; int i , num ; int contents , c2 ; clipHandle_t clipHandle ; float * angles ; contents = CM_PointContents ( p , 0 ) ; num = SV_AreaEntities ( p , p , touch , MAX_GENTITIES ) ; for ( i = 0 ; i < num ; i ++ ) { if ( touch [ i ] == passEntityNum ) { continue ; } hit = SV_GentityNum ( touch [ i ] ) ; clipHandle = SV_ClipHandleForEntity ( hit ) ; angles = hit -> s . angles ; if ( ! hit -> r . bmodel ) { angles = vec3_origin ; } c2 = CM_TransformedPointContents ( p , clipHandle , hit -> s . origin , hit -> s . angles ) ; contents |= c2 ; } return contents ; }
Q_OBJECT public : explicit GLWidget ( QMainWindow * parent = NULL ) : QGLWidget ( QGLFormat ( QGL :: SampleBuffers ) , parent ) , primary_edges_only_ ( false ) , internal_edges_only_ ( false ) { startTimer ( 40 ) ; }
void build ( const QString & file_path ) { clear ( ) ; read_data ( file_path ) ; if ( ! brect_initialized_ ) { return ; } construct_brect ( ) ; construct_voronoi ( point_data_ . begin ( ) , point_data_ . end ( ) , segment_data_ . begin ( ) , segment_data_ . end ( ) , & vd_ ) ; for ( const_edge_iterator it = vd_ . edges ( ) . begin ( ) ; it != vd_ . edges ( ) . end ( ) ; ++ it ) { if ( ! it -> is_finite ( ) ) { color_exterior ( & ( * it ) ) ; } } update_view_port ( ) ; }
void show_primary_edges_only ( ) { primary_edges_only_ ^= true ; }
void show_internal_edges_only ( ) { internal_edges_only_ ^= true ; }
protected : void initializeGL ( ) { glHint ( GL_POINT_SMOOTH_HINT , GL_NICEST ) ; glBlendFunc ( GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA ) ; glEnable ( GL_BLEND ) ; glEnable ( GL_POINT_SMOOTH ) ; }
void paintGL ( ) { qglClearColor ( QColor :: fromRgb ( 255 , 255 , 255 ) ) ; glClear ( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT ) ; draw_points ( ) ; draw_segments ( ) ; draw_vertices ( ) ; draw_edges ( ) ; }
void resizeGL ( int width , int height ) { int side = qMin ( width , height ) ; glViewport ( ( width - side ) / 2 , ( height - side ) / 2 , side , side ) ; }
void timerEvent ( QTimerEvent * e ) { update ( ) ; }
void clear ( ) { brect_initialized_ = false ; point_data_ . clear ( ) ; segment_data_ . clear ( ) ; vd_ . clear ( ) ; }
void read_data ( const QString & file_path ) { QFile data ( file_path ) ; if ( ! data . open ( QFile :: ReadOnly ) ) { QMessageBox :: warning ( this , tr ( " Voronoi ▁ Visualizer " ) , tr ( " Disable ▁ to ▁ open ▁ file ▁ " ) + file_path ) ; } QTextStream in_stream ( & data ) ; std :: size_t num_points , num_segments ; int x1 , y1 , x2 , y2 ; in_stream >> num_points ; for ( std :: size_t i = 0 ; i < num_points ; ++ i ) { in_stream >> x1 >> y1 ; point_type p ( x1 , y1 ) ; update_brect ( p ) ; point_data_ . push_back ( p ) ; } in_stream >> num_segments ; for ( std :: size_t i = 0 ; i < num_segments ; ++ i ) { in_stream >> x1 >> y1 >> x2 >> y2 ; point_type lp ( x1 , y1 ) ; point_type hp ( x2 , y2 ) ; update_brect ( lp ) ; update_brect ( hp ) ; segment_data_ . push_back ( segment_type ( lp , hp ) ) ; } in_stream . flush ( ) ; }
void update_brect ( const point_type & point ) { if ( brect_initialized_ ) { encompass ( brect_ , point ) ; } else { set_points ( brect_ , point , point ) ; brect_initialized_ = true ; } }
void construct_brect ( ) { double side = ( std :: max ) ( xh ( brect_ ) - xl ( brect_ ) , yh ( brect_ ) - yl ( brect_ ) ) ; center ( shift_ , brect_ ) ; set_points ( brect_ , shift_ , shift_ ) ; bloat ( brect_ , side * 1.2 ) ; }
void color_exterior ( const VD :: edge_type * edge ) { if ( edge -> color ( ) == EXTERNAL_COLOR ) { return ; } edge -> color ( EXTERNAL_COLOR ) ; edge -> twin ( ) -> color ( EXTERNAL_COLOR ) ; const VD :: vertex_type * v = edge -> vertex1 ( ) ; if ( v == NULL || ! edge -> is_primary ( ) ) { return ; } v -> color ( EXTERNAL_COLOR ) ; const VD :: edge_type * e = v -> incident_edge ( ) ; do { color_exterior ( e ) ; e = e -> rot_next ( ) ; } while ( e != v -> incident_edge ( ) ) ; }
void update_view_port ( ) { glMatrixMode ( GL_PROJECTION ) ; glLoadIdentity ( ) ; rect_type view_rect = brect_ ; deconvolve ( view_rect , shift_ ) ; glOrtho ( xl ( view_rect ) , xh ( view_rect ) , yl ( view_rect ) , yh ( view_rect ) , - 1.0 , 1.0 ) ; glMatrixMode ( GL_MODELVIEW ) ; }
void draw_points ( ) { glColor3f ( 0.0f , 0.5f , 1.0f ) ; glPointSize ( 9 ) ; glBegin ( GL_POINTS ) ; for ( std :: size_t i = 0 ; i < point_data_ . size ( ) ; ++ i ) { point_type point = point_data_ [ i ] ; deconvolve ( point , shift_ ) ; glVertex2f ( point . x ( ) , point . y ( ) ) ; } for ( std :: size_t i = 0 ; i < segment_data_ . size ( ) ; ++ i ) { point_type lp = low ( segment_data_ [ i ] ) ; lp = deconvolve ( lp , shift_ ) ; glVertex2f ( lp . x ( ) , lp . y ( ) ) ; point_type hp = high ( segment_data_ [ i ] ) ; hp = deconvolve ( hp , shift_ ) ; glVertex2f ( hp . x ( ) , hp . y ( ) ) ; } glEnd ( ) ; }
void draw_segments ( ) { glColor3f ( 0.0f , 0.5f , 1.0f ) ; glLineWidth ( 2.7f ) ; glBegin ( GL_LINES ) ; for ( std :: size_t i = 0 ; i < segment_data_ . size ( ) ; ++ i ) { point_type lp = low ( segment_data_ [ i ] ) ; lp = deconvolve ( lp , shift_ ) ; glVertex2f ( lp . x ( ) , lp . y ( ) ) ; point_type hp = high ( segment_data_ [ i ] ) ; hp = deconvolve ( hp , shift_ ) ; glVertex2f ( hp . x ( ) , hp . y ( ) ) ; } glEnd ( ) ; }
void draw_vertices ( ) { glColor3f ( 0.0f , 0.0f , 0.0f ) ; glPointSize ( 6 ) ; glBegin ( GL_POINTS ) ; for ( const_vertex_iterator it = vd_ . vertices ( ) . begin ( ) ; it != vd_ . vertices ( ) . end ( ) ; ++ it ) { if ( internal_edges_only_ && ( it -> color ( ) == EXTERNAL_COLOR ) ) { continue ; } point_type vertex ( it -> x ( ) , it -> y ( ) ) ; vertex = deconvolve ( vertex , shift_ ) ; glVertex2f ( vertex . x ( ) , vertex . y ( ) ) ; } glEnd ( ) ; }
void draw_edges ( ) { glColor3f ( 0.0f , 0.0f , 0.0f ) ; glLineWidth ( 1.7f ) ; for ( const_edge_iterator it = vd_ . edges ( ) . begin ( ) ; it != vd_ . edges ( ) . end ( ) ; ++ it ) { if ( primary_edges_only_ && ! it -> is_primary ( ) ) { continue ; } if ( internal_edges_only_ && ( it -> color ( ) == EXTERNAL_COLOR ) ) { continue ; } std :: vector < point_type > samples ; if ( ! it -> is_finite ( ) ) { clip_infinite_edge ( * it , & samples ) ; } else { point_type vertex0 ( it -> vertex0 ( ) -> x ( ) , it -> vertex0 ( ) -> y ( ) ) ; samples . push_back ( vertex0 ) ; point_type vertex1 ( it -> vertex1 ( ) -> x ( ) , it -> vertex1 ( ) -> y ( ) ) ; samples . push_back ( vertex1 ) ; if ( it -> is_curved ( ) ) { sample_curved_edge ( * it , & samples ) ; } } glBegin ( GL_LINE_STRIP ) ; for ( std :: size_t i = 0 ; i < samples . size ( ) ; ++ i ) { point_type vertex = deconvolve ( samples [ i ] , shift_ ) ; glVertex2f ( vertex . x ( ) , vertex . y ( ) ) ; } glEnd ( ) ; } }
void clip_infinite_edge ( const edge_type & edge , std :: vector < point_type > * clipped_edge ) { const cell_type & cell1 = * edge . cell ( ) ; const cell_type & cell2 = * edge . twin ( ) -> cell ( ) ; point_type origin , direction ; if ( cell1 . contains_point ( ) && cell2 . contains_point ( ) ) { point_type p1 = retrieve_point ( cell1 ) ; point_type p2 = retrieve_point ( cell2 ) ; origin . x ( ( p1 . x ( ) + p2 . x ( ) ) * 0.5 ) ; origin . y ( ( p1 . y ( ) + p2 . y ( ) ) * 0.5 ) ; direction . x ( p1 . y ( ) - p2 . y ( ) ) ; direction . y ( p2 . x ( ) - p1 . x ( ) ) ; } else { origin = cell1 . contains_segment ( ) ? retrieve_point ( cell2 ) : retrieve_point ( cell1 ) ; segment_type segment = cell1 . contains_segment ( ) ? retrieve_segment ( cell1 ) : retrieve_segment ( cell2 ) ; coordinate_type dx = high ( segment ) . x ( ) - low ( segment ) . x ( ) ; coordinate_type dy = high ( segment ) . y ( ) - low ( segment ) . y ( ) ; if ( ( low ( segment ) == origin ) ^ cell1 . contains_point ( ) ) { direction . x ( dy ) ; direction . y ( - dx ) ; } else { direction . x ( - dy ) ; direction . y ( dx ) ; } } coordinate_type side = xh ( brect_ ) - xl ( brect_ ) ; coordinate_type koef = side / ( std :: max ) ( fabs ( direction . x ( ) ) , fabs ( direction . y ( ) ) ) ; if ( edge . vertex0 ( ) == NULL ) { clipped_edge -> push_back ( point_type ( origin . x ( ) - direction . x ( ) * koef , origin . y ( ) - direction . y ( ) * koef ) ) ; } else { clipped_edge -> push_back ( point_type ( edge . vertex0 ( ) -> x ( ) , edge . vertex0 ( ) -> y ( ) ) ) ; } if ( edge . vertex1 ( ) == NULL ) { clipped_edge -> push_back ( point_type ( origin . x ( ) + direction . x ( ) * koef , origin . y ( ) + direction . y ( ) * koef ) ) ; } else { clipped_edge -> push_back ( point_type ( edge . vertex1 ( ) -> x ( ) , edge . vertex1 ( ) -> y ( ) ) ) ; } }
void sample_curved_edge ( const edge_type & edge , std :: vector < point_type > * sampled_edge ) { coordinate_type max_dist = 1E - 3 * ( xh ( brect_ ) - xl ( brect_ ) ) ; point_type point = edge . cell ( ) -> contains_point ( ) ? retrieve_point ( * edge . cell ( ) ) : retrieve_point ( * edge . twin ( ) -> cell ( ) ) ; segment_type segment = edge . cell ( ) -> contains_point ( ) ? retrieve_segment ( * edge . twin ( ) -> cell ( ) ) : retrieve_segment ( * edge . cell ( ) ) ; voronoi_visual_utils < coordinate_type > :: discretize ( point , segment , max_dist , sampled_edge ) ; }
point_type retrieve_point ( const cell_type & cell ) { source_index_type index = cell . source_index ( ) ; source_category_type category = cell . source_category ( ) ; if ( category == SOURCE_CATEGORY_SINGLE_POINT ) { return point_data_ [ index ] ; } index -= point_data_ . size ( ) ; if ( category == SOURCE_CATEGORY_SEGMENT_START_POINT ) { return low ( segment_data_ [ index ] ) ; } else { return high ( segment_data_ [ index ] ) ; } }
segment_type retrieve_segment ( const cell_type & cell ) { source_index_type index = cell . source_index ( ) - point_data_ . size ( ) ; return segment_data_ [ index ] ; }
Q_OBJECT public : MainWindow ( ) { glWidget_ = new GLWidget ( ) ; file_dir_ = QDir ( QDir :: currentPath ( ) , tr ( " * . txt " ) ) ; file_name_ = tr ( " " ) ; QHBoxLayout * centralLayout = new QHBoxLayout ; centralLayout -> addWidget ( glWidget_ ) ; centralLayout -> addLayout ( create_file_layout ( ) ) ; setLayout ( centralLayout ) ; update_file_list ( ) ; setWindowTitle ( tr ( " Voronoi ▁ Visualizer " ) ) ; layout ( ) -> setSizeConstraint ( QLayout :: SetFixedSize ) ; }
private slots : void primary_edges_only ( ) { glWidget_ -> show_primary_edges_only ( ) ; }
void internal_edges_only ( ) { glWidget_ -> show_internal_edges_only ( ) ; }
void browse ( ) { QString new_path = QFileDialog :: getExistingDirectory ( 0 , tr ( " Choose ▁ Directory " ) , file_dir_ . absolutePath ( ) ) ; if ( new_path . isEmpty ( ) ) { return ; } file_dir_ . setPath ( new_path ) ; update_file_list ( ) ; }
void build ( ) { file_name_ = file_list_ -> currentItem ( ) -> text ( ) ; QString file_path = file_dir_ . filePath ( file_name_ ) ; message_label_ -> setText ( " Building . . . " ) ; glWidget_ -> build ( file_path ) ; message_label_ -> setText ( " Double ▁ click ▁ the ▁ item ▁ to ▁ build ▁ voronoi ▁ diagram : " ) ; setWindowTitle ( tr ( " Voronoi ▁ Visualizer ▁ - ▁ " ) + file_path ) ; }
void print_scr ( ) { if ( ! file_name_ . isEmpty ( ) ) { QImage screenshot = glWidget_ -> grabFrameBuffer ( true ) ; QString output_file = file_dir_ . absolutePath ( ) + tr ( " / " ) + file_name_ . left ( file_name_ . indexOf ( ' . ' ) ) + tr ( " . png " ) ; screenshot . save ( output_file , 0 , - 1 ) ; } }
private : QGridLayout * create_file_layout ( ) { QGridLayout * file_layout = new QGridLayout ; message_label_ = new QLabel ( " Double ▁ click ▁ item ▁ to ▁ build ▁ voronoi ▁ diagram : " ) ; file_list_ = new QListWidget ( ) ; file_list_ -> connect ( file_list_ , SIGNAL ( itemDoubleClicked ( QListWidgetItem * ) ) , this , SLOT ( build ( ) ) ) ; QCheckBox * primary_checkbox = new QCheckBox ( " Show ▁ primary ▁ edges ▁ only . " ) ; connect ( primary_checkbox , SIGNAL ( clicked ( ) ) , this , SLOT ( primary_edges_only ( ) ) ) ; QCheckBox * internal_checkbox = new QCheckBox ( " Show ▁ internal ▁ edges ▁ only . " ) ; connect ( internal_checkbox , SIGNAL ( clicked ( ) ) , this , SLOT ( internal_edges_only ( ) ) ) ; QPushButton * browse_button = new QPushButton ( tr ( " Browse ▁ Input ▁ Directory " ) ) ; connect ( browse_button , SIGNAL ( clicked ( ) ) , this , SLOT ( browse ( ) ) ) ; browse_button -> setMinimumHeight ( 50 ) ; QPushButton * print_scr_button = new QPushButton ( tr ( " Make ▁ Screenshot " ) ) ; connect ( print_scr_button , SIGNAL ( clicked ( ) ) , this , SLOT ( print_scr ( ) ) ) ; print_scr_button -> setMinimumHeight ( 50 ) ; file_layout -> addWidget ( message_label_ , 0 , 0 ) ; file_layout -> addWidget ( file_list_ , 1 , 0 ) ; file_layout -> addWidget ( primary_checkbox , 2 , 0 ) ; file_layout -> addWidget ( internal_checkbox , 3 , 0 ) ; file_layout -> addWidget ( browse_button , 4 , 0 ) ; file_layout -> addWidget ( print_scr_button , 5 , 0 ) ; return file_layout ; }
void update_file_list ( ) { QFileInfoList list = file_dir_ . entryInfoList ( ) ; file_list_ -> clear ( ) ; if ( file_dir_ . count ( ) == 0 ) { return ; } QFileInfoList :: const_iterator it ; for ( it = list . begin ( ) ; it != list . end ( ) ; it ++ ) { file_list_ -> addItem ( it -> fileName ( ) ) ; } file_list_ -> setCurrentRow ( 0 ) ; }
int main ( int argc , char * argv [ ] ) { QApplication app ( argc , argv ) ; MainWindow window ; window . show ( ) ; return app . exec ( ) ; }
