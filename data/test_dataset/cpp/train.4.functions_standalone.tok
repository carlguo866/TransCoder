int main ( int argc , char * * argv ) { LightBulb :: App * app = new LightBulb :: App ( ) ; app -> addTrainingPlan ( new PigChaseEvolution ( ) ) ; app -> addExporter ( new TensorflowExporter ( ) ) ; wxApp :: SetInstance ( app ) ; wxEntry ( argc , argv ) ; return 0 ; }
int readPageMetadata ( uint8_t * buf , uint32_t * len , int compact , struct PageMetadata_4C * * ppageMetdata ) { * ppageMetdata = ( struct PageMetadata_4C * ) palloc0 ( sizeof ( struct PageMetadata_4C ) ) ; bool compactBool = ( compact == 1 ) ? true : false ; int iret = MetadataUtil :: readPageMetadata ( buf , len , compactBool , * ppageMetdata ) ; return iret ; }
int writePageMetadata ( uint8_t * * buf , uint32_t * len , struct PageMetadata_4C * ppageMetadata ) { int iret = MetadataUtil :: writePageMetadata ( buf , len , ppageMetadata ) ; return iret ; }
int writeColumnChunkMetadata ( uint8_t * * buf , uint32_t * len , struct ColumnChunkMetadata_4C * blockMetadata ) { int iret = MetadataUtil :: writeColumnChunkMetadata ( buf , len , blockMetadata ) ; return iret ; }
JSValue toJS ( ExecState * exec , JSDOMGlobalObject * globalObject , Document * document ) { if ( ! document ) return jsNull ( ) ; JSDOMWrapper * wrapper = getCachedWrapper ( currentWorld ( exec ) , document ) ; if ( wrapper ) return wrapper ; if ( DOMWindow * domWindow = document -> domWindow ( ) ) { globalObject = toJSDOMWindow ( toJS ( exec , domWindow ) ) ; wrapper = getCachedWrapper ( currentWorld ( exec ) , document ) ; if ( wrapper ) return wrapper ; } if ( document -> isHTMLDocument ( ) ) wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , HTMLDocument , document ) ; ( SVG ) else if ( document -> isSVGDocument ( ) ) wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , SVGDocument , document ) ; else wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , Document , document ) ; if ( ! document -> frame ( ) ) { size_t nodeCount = 0 ; for ( Node * n = document ; n ; n = n -> traverseNextNode ( ) ) nodeCount ++ ; exec -> heap ( ) -> reportExtraMemoryCost ( nodeCount * sizeof ( Node ) ) ; } return wrapper ; }
int main ( int argc , const char * argv [ ] ) { try { lb app ( argc , argv ) ; return app . run ( ) ; } catch ( lb_error e ) { cerr << e . what ( ) << endl ; return EXIT_FAILURE ; } catch ( runtime_error e ) { cerr << e . what ( ) << endl ; return EXIT_FAILURE ; } catch ( ... ) { cerr << " Unhandled ▁ exception ▁ in ▁ lb . " << endl ; return EXIT_FAILURE ; } }
public : void testInsert ( ) { Map < String , int > m ; m . insert ( " foo " , 3 ) ; CPPUNIT_ASSERT_EQUAL ( 3 , m [ " foo " ] ) ; m . insert ( " foo " , 7 ) ; CPPUNIT_ASSERT_EQUAL ( 7 , m [ " foo " ] ) ; }
void worker_thread ( ) { std :: unique_lock < std :: mutex > lk ( m ) ; cv . wait ( lk , [ ] { return ready ; } ) ; std :: cout << " Worker ▁ thread ▁ is ▁ processing ▁ data \n " ; data += " ▁ after ▁ processing " ; processed = true ; std :: cout << " Worker ▁ thread ▁ signals ▁ data ▁ processing ▁ completed \n " ; lk . unlock ( ) ; cv . notify_one ( ) ; }
int main ( int argc , char * argv [ ] ) { std :: thread worker ( worker_thread ) ; data = " Example ▁ data " ; { std :: lock_guard < std :: mutex > lk ( m ) ; ready = true ; std :: cout << " main ( ) ▁ signals ▁ data ▁ ready ▁ for ▁ processing \n " ; } cv . notify_one ( ) ; { std :: unique_lock < std :: mutex > lk ( m ) ; cv . wait ( lk , [ ] { return processed ; } ) ; } std :: cout << " Back ▁ in ▁ main ( ) , ▁ data ▁ = ▁ " << data << ' \n ' ; worker . join ( ) ; }
public : hal ( ) { I :: init ( ) ; }
virtual void write ( const unsigned char data ) { RW :: write ( data ) ; }
virtual unsigned char read ( ) { return RW :: read ( ) ; }
static void init ( const long baudRate ) { long ubrr = F_CPU / 16 / baudRate - 1 ; UBRR0H = ubrr >> 8 ; UBRR0L = ubrr ; UCSR0B = ( 1 << RXEN0 ) | ( 1 << TXEN0 ) ; UCSR0C = ( 3 << UCSZ00 ) ; }
public : static void write ( const unsigned char data ) { while ( ! ( UCSR0A & ( 1 << UDRE0 ) ) ) ; UDR0 = data ; }
static unsigned char read ( ) { while ( ! ( UCSR0A & ( 1 << RXC0 ) ) ) ; return UDR0 ; }
static void write ( unsigned char data ) { SPDR = data ; while ( ! ( SPSR & ( 1 << SPIF ) ) ) ; }
static unsigned char read ( ) { while ( ! ( SPSR & ( 1 << SPIF ) ) ) ; return SPDR ; }
static void init ( ) { DDRB |= ( 1 << PB3 ) | ( 1 << PB5 ) | ( 1 << PB2 ) ; SPCR = ( 1 << SPE ) | ( 1 << MSTR ) | ( 1 << SPR0 ) ; }
static void init ( ) { DDRB |= ( 1 << PB4 ) ; SPCR = ( 1 << SPE ) ; }
public : USART ( const long Rate ) { T :: init ( Rate ) ; }
void ImHere ( ) { DEBUG_LOG ( CPU , " JIT ▁ Here : ▁ % 08x " , currentMIPS -> pc ) ; }
void __cdecl validate ( double numerator , double denominator , double expected , double variance ) { double result = fmod ( numerator , denominator ) ; double delta = fabs ( result - expected ) ; if ( delta > variance ) { Fail ( " fmod ( % g , ▁ % g ) ▁ returned ▁ % 20.17g ▁ when ▁ it ▁ should ▁ have ▁ returned ▁ % 20.17g " , numerator , denominator , result , expected ) ; } }
void __cdecl validate_isnan ( double numerator , double denominator ) { double result = fmod ( numerator , denominator ) ; if ( ! _isnan ( result ) ) { Fail ( " fmod ( % g , ▁ % g ) ▁ returned ▁ % 20.17g ▁ when ▁ it ▁ should ▁ have ▁ returned ▁ % 20.17g " , numerator , denominator , result , PAL_NAN ) ; } }
INT __cdecl main ( INT argc , CHAR * * argv ) { struct test tests [ ] = { { 0 , PAL_POSINF , 0 , PAL_EPSILON } , { 0.31296179620778659 , 0.94976571538163866 , 0.31296179620778658 , PAL_EPSILON } , { 0.42077048331375735 , 0.90716712923909839 , 0.42077048331375733 , PAL_EPSILON } , { 0.59448076852482208 , 0.80410982822879171 , 0.59448076852482212 , PAL_EPSILON } , { 0.63896127631363480 , 0.76923890136397213 , 0.63896127631363475 , PAL_EPSILON } , { 0.64963693908006244 , 0.76024459707563015 , 0.64963693908006248 , PAL_EPSILON } , { 0.70710678118654752 , 0.70710678118654752 , 0 , PAL_EPSILON } , { 1 , 1 , 0 , PAL_EPSILON } , { 0.84147098480789651 , 0.54030230586813972 , 0.30116867893975674 , PAL_EPSILON } , { 0.90371945743584630 , 0.42812514788535792 , 0.047469161665130377 , PAL_EPSILON / 10 } , { 0.98776594599273553 , 0.15594369476537447 , 0.052103777400488605 , PAL_EPSILON / 10 } , { 0.99180624439366372 , 0.12775121753523991 , 0.097547721646984359 , PAL_EPSILON / 10 } , { 0.74398033695749319 , - 0.66820151019031295 , 0.075778826767180285 , PAL_EPSILON / 10 } , { 0.41078129050290870 , - 0.91173391478696510 , 0.41078129050290868 , PAL_EPSILON } , { 0 , - 1 , 0 , PAL_EPSILON } , { 1 , PAL_POSINF , 1 , PAL_EPSILON * 10 } , } ; if ( PAL_Initialize ( argc , argv ) != 0 ) { return FAIL ; } for ( int i = 0 ; i < ( sizeof ( tests ) / sizeof ( struct test ) ) ; i ++ ) { validate ( tests [ i ] . numerator , tests [ i ] . denominator , tests [ i ] . expected , tests [ i ] . variance ) ; validate ( - tests [ i ] . numerator , tests [ i ] . denominator , - tests [ i ] . expected , tests [ i ] . variance ) ; validate ( tests [ i ] . numerator , - tests [ i ] . denominator , tests [ i ] . expected , tests [ i ] . variance ) ; validate ( - tests [ i ] . numerator , - tests [ i ] . denominator , - tests [ i ] . expected , tests [ i ] . variance ) ; } validate_isnan ( 0 , 0 ) ; validate_isnan ( - 0.0 , 0 ) ; validate_isnan ( 0 , - 0.0 ) ; validate_isnan ( - 0.0 , - 0.0 ) ; validate_isnan ( 1 , 0 ) ; validate_isnan ( - 1.0 , 0 ) ; validate_isnan ( 1 , - 0.0 ) ; validate_isnan ( - 1.0 , - 0.0 ) ; validate_isnan ( PAL_POSINF , PAL_POSINF ) ; validate_isnan ( PAL_NEGINF , PAL_POSINF ) ; validate_isnan ( PAL_POSINF , PAL_NEGINF ) ; validate_isnan ( PAL_NEGINF , PAL_NEGINF ) ; validate_isnan ( PAL_POSINF , 0 ) ; validate_isnan ( PAL_NEGINF , 0 ) ; validate_isnan ( PAL_POSINF , - 0.0 ) ; validate_isnan ( PAL_NEGINF , - 0.0 ) ; validate_isnan ( PAL_POSINF , 1 ) ; validate_isnan ( PAL_NEGINF , 1 ) ; validate_isnan ( PAL_POSINF , - 1.0 ) ; validate_isnan ( PAL_NEGINF , - 1.0 ) ; PAL_Terminate ( ) ; return PASS ; }
BOOST_AUTO_TEST_SUITE ( multisig_tests ) CScript sign_multisig ( CScript scriptPubKey , vector < CKey > keys , CTransaction transaction , int whichIn ) { uint256 hash = SignatureHash ( scriptPubKey , transaction , whichIn , SIGHASH_ALL ) ; CScript result ; result << OP_0 ; BOOST_FOREACH ( const CKey & key , keys ) { vector < unsigned char > vchSig ; BOOST_CHECK ( key . Sign ( hash , vchSig ) ) ; vchSig . push_back ( ( unsigned char ) SIGHASH_ALL ) ; result << vchSig ; } return result ; }
BOOST_AUTO_TEST_CASE ( multisig_verify ) { unsigned int flags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) key [ i ] . MakeNewKey ( true ) ; CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; CTransaction txFrom ; txFrom . vout . resize ( 3 ) ; txFrom . vout [ 0 ] . scriptPubKey = a_and_b ; txFrom . vout [ 1 ] . scriptPubKey = a_or_b ; txFrom . vout [ 2 ] . scriptPubKey = escrow ; CTransaction txTo [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { txTo [ i ] . vin . resize ( 1 ) ; txTo [ i ] . vout . resize ( 1 ) ; txTo [ i ] . vin [ 0 ] . prevout . n = i ; txTo [ i ] . vin [ 0 ] . prevout . hash = txFrom . GetHash ( ) ; txTo [ i ] . vout [ 0 ] . nValue = 1 ; } vector < CKey > keys ; CScript s ; keys . clear ( ) ; keys += key [ 0 ] , key [ 1 ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK ( VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) { keys . clear ( ) ; keys += key [ i ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) , strprintf ( " a & b ▁ 1 : ▁ % d " , i ) ) ; keys . clear ( ) ; keys += key [ 1 ] , key [ i ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) , strprintf ( " a & b ▁ 2 : ▁ % d " , i ) ) ; } for ( int i = 0 ; i < 4 ; i ++ ) { keys . clear ( ) ; keys += key [ i ] ; s = sign_multisig ( a_or_b , keys , txTo [ 1 ] , 0 ) ; if ( i == 0 || i == 1 ) BOOST_CHECK_MESSAGE ( VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) , strprintf ( " a | b : ▁ % d " , i ) ) ; else BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) , strprintf ( " a | b : ▁ % d " , i ) ) ; } s . clear ( ) ; s << OP_0 << OP_0 ; BOOST_CHECK ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) ) ; s . clear ( ) ; s << OP_0 << OP_1 ; BOOST_CHECK ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) { keys . clear ( ) ; keys += key [ i ] , key [ j ] ; s = sign_multisig ( escrow , keys , txTo [ 2 ] , 0 ) ; if ( i < j && i < 3 && j < 3 ) BOOST_CHECK_MESSAGE ( VerifyScript ( s , escrow , txTo [ 2 ] , 0 , flags , 0 ) , strprintf ( " escrow ▁ 1 : ▁ % d ▁ % d " , i , j ) ) ; else BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , escrow , txTo [ 2 ] , 0 , flags , 0 ) , strprintf ( " escrow ▁ 2 : ▁ % d ▁ % d " , i , j ) ) ; } }
BOOST_AUTO_TEST_CASE ( multisig_IsStandard ) { CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) key [ i ] . MakeNewKey ( true ) ; CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( a_and_b ) ) ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( a_or_b ) ) ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( escrow ) ) ; CScript one_of_four ; one_of_four << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << key [ 3 ] . GetPubKey ( ) << OP_4 << OP_CHECKMULTISIG ; BOOST_CHECK ( ! :: IsStandard ( one_of_four ) ) ; CScript malformed [ 6 ] ; malformed [ 0 ] << OP_3 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; malformed [ 1 ] << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; malformed [ 2 ] << OP_0 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; malformed [ 3 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_0 << OP_CHECKMULTISIG ; malformed [ 4 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_CHECKMULTISIG ; malformed [ 5 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) ; for ( int i = 0 ; i < 6 ; i ++ ) BOOST_CHECK ( ! :: IsStandard ( malformed [ i ] ) ) ; }
BOOST_AUTO_TEST_CASE ( multisig_Solver1 ) { CBasicKeyStore keystore , emptykeystore , partialkeystore ; CKey key [ 3 ] ; CTxDestination keyaddr [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { key [ i ] . MakeNewKey ( true ) ; keystore . AddKey ( key [ i ] ) ; keyaddr [ i ] = key [ i ] . GetPubKey ( ) . GetID ( ) ; } partialkeystore . AddKey ( key [ 0 ] ) ; { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << key [ 0 ] . GetPubKey ( ) << OP_CHECKSIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 1 ) ; CTxDestination addr ; BOOST_CHECK ( ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( addr == keyaddr [ 0 ] ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_DUP << OP_HASH160 << key [ 0 ] . GetPubKey ( ) . GetID ( ) << OP_EQUALVERIFY << OP_CHECKSIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 1 ) ; CTxDestination addr ; BOOST_CHECK ( ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( addr == keyaddr [ 0 ] ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK_EQUAL ( solutions . size ( ) , 4U ) ; CTxDestination addr ; BOOST_CHECK ( ! ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; BOOST_CHECK ( ! IsMine ( partialkeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK_EQUAL ( solutions . size ( ) , 4U ) ; vector < CTxDestination > addrs ; int nRequired ; BOOST_CHECK ( ExtractDestinations ( s , whichType , addrs , nRequired ) ) ; BOOST_CHECK ( addrs [ 0 ] == keyaddr [ 0 ] ) ; BOOST_CHECK ( addrs [ 1 ] == keyaddr [ 1 ] ) ; BOOST_CHECK ( nRequired == 1 ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; BOOST_CHECK ( ! IsMine ( partialkeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 5 ) ; } }
BOOST_AUTO_TEST_CASE ( multisig_Sign ) { CBasicKeyStore keystore ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { key [ i ] . MakeNewKey ( true ) ; keystore . AddKey ( key [ i ] ) ; } CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; CTransaction txFrom ; txFrom . vout . resize ( 3 ) ; txFrom . vout [ 0 ] . scriptPubKey = a_and_b ; txFrom . vout [ 1 ] . scriptPubKey = a_or_b ; txFrom . vout [ 2 ] . scriptPubKey = escrow ; CTransaction txTo [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { txTo [ i ] . vin . resize ( 1 ) ; txTo [ i ] . vout . resize ( 1 ) ; txTo [ i ] . vin [ 0 ] . prevout . n = i ; txTo [ i ] . vin [ 0 ] . prevout . hash = txFrom . GetHash ( ) ; txTo [ i ] . vout [ 0 ] . nValue = 1 ; } for ( int i = 0 ; i < 3 ; i ++ ) { BOOST_CHECK_MESSAGE ( SignSignature ( keystore , txFrom , txTo [ i ] , 0 ) , strprintf ( " SignSignature ▁ % d " , i ) ) ; } }
static inline int32_t Interp ( int32_t x0 , int32_t x1 , uint32_t f ) { return x0 + ( ( ( x1 - x0 ) * ( int32_t ) ( f >> kPreInterpShift ) ) >> kNumInterpBits ) ; }
static inline void Advance ( size_t * index , uint32_t * frac , uint32_t inc ) { * frac += inc ; * index += ( size_t ) ( * frac >> kNumPhaseBits ) ; * frac &= kPhaseMask ; }
unsigned int ParseScriptFlags ( string strFlags ) { if ( strFlags . empty ( ) ) { return 0 ; } unsigned int flags = 0 ; vector < string > words ; split ( words , strFlags , is_any_of ( " , " ) ) ; BOOST_FOREACH ( string word , words ) { if ( ! mapFlagNames . count ( word ) ) BOOST_ERROR ( " Bad ▁ test : ▁ unknown ▁ verification ▁ flag ▁ ' " << word << " ' " ) ; flags |= mapFlagNames [ word ] ; } return flags ; }
string FormatScriptFlags ( unsigned int flags ) { if ( flags == 0 ) { return " " ; } string ret ; std :: map < string , unsigned int > :: const_iterator it = mapFlagNames . begin ( ) ; while ( it != mapFlagNames . end ( ) ) { if ( flags & it -> second ) { ret += it -> first + " , " ; } it ++ ; } return ret . substr ( 0 , ret . size ( ) - 1 ) ; }
BOOST_AUTO_TEST_SUITE ( transaction_tests ) BOOST_AUTO_TEST_CASE ( tx_valid ) { Array tests = read_json ( std :: string ( json_tests :: tx_valid , json_tests :: tx_valid + sizeof ( json_tests :: tx_valid ) ) ) ; ScriptError err ; BOOST_FOREACH ( Value & tv , tests ) { Array test = tv . get_array ( ) ; string strTest = write_string ( tv , false ) ; if ( test [ 0 ] . type ( ) == array_type ) { if ( test . size ( ) != 3 || test [ 1 ] . type ( ) != str_type || test [ 2 ] . type ( ) != str_type ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } map < COutPoint , CScript > mapprevOutScriptPubKeys ; Array inputs = test [ 0 ] . get_array ( ) ; bool fValid = true ; BOOST_FOREACH ( Value & input , inputs ) { if ( input . type ( ) != array_type ) { fValid = false ; break ; } Array vinput = input . get_array ( ) ; if ( vinput . size ( ) != 3 ) { fValid = false ; break ; } mapprevOutScriptPubKeys [ COutPoint ( uint256 ( vinput [ 0 ] . get_str ( ) ) , vinput [ 1 ] . get_int ( ) ) ] = ParseScript ( vinput [ 2 ] . get_str ( ) ) ; } if ( ! fValid ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } string transaction = test [ 1 ] . get_str ( ) ; CDataStream stream ( ParseHex ( transaction ) , SER_NETWORK , PROTOCOL_VERSION ) ; CTransaction tx ; stream >> tx ; CValidationState state ; BOOST_CHECK_MESSAGE ( CheckTransaction ( tx , state ) , strTest ) ; BOOST_CHECK ( state . IsValid ( ) ) ; for ( unsigned int i = 0 ; i < tx . vin . size ( ) ; i ++ ) { if ( ! mapprevOutScriptPubKeys . count ( tx . vin [ i ] . prevout ) ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; break ; } unsigned int verify_flags = ParseScriptFlags ( test [ 2 ] . get_str ( ) ) ; BOOST_CHECK_MESSAGE ( VerifyScript ( tx . vin [ i ] . scriptSig , mapprevOutScriptPubKeys [ tx . vin [ i ] . prevout ] , verify_flags , TransactionSignatureChecker ( & tx , i ) , & err ) , strTest ) ; BOOST_CHECK_MESSAGE ( err == SCRIPT_ERR_OK , ScriptErrorString ( err ) ) ; } } } }
BOOST_AUTO_TEST_CASE ( tx_invalid ) { Array tests = read_json ( std :: string ( json_tests :: tx_invalid , json_tests :: tx_invalid + sizeof ( json_tests :: tx_invalid ) ) ) ; ScriptError err ; BOOST_FOREACH ( Value & tv , tests ) { Array test = tv . get_array ( ) ; string strTest = write_string ( tv , false ) ; if ( test [ 0 ] . type ( ) == array_type ) { if ( test . size ( ) != 3 || test [ 1 ] . type ( ) != str_type || test [ 2 ] . type ( ) != str_type ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } map < COutPoint , CScript > mapprevOutScriptPubKeys ; Array inputs = test [ 0 ] . get_array ( ) ; bool fValid = true ; BOOST_FOREACH ( Value & input , inputs ) { if ( input . type ( ) != array_type ) { fValid = false ; break ; } Array vinput = input . get_array ( ) ; if ( vinput . size ( ) != 3 ) { fValid = false ; break ; } mapprevOutScriptPubKeys [ COutPoint ( uint256 ( vinput [ 0 ] . get_str ( ) ) , vinput [ 1 ] . get_int ( ) ) ] = ParseScript ( vinput [ 2 ] . get_str ( ) ) ; } if ( ! fValid ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } string transaction = test [ 1 ] . get_str ( ) ; CDataStream stream ( ParseHex ( transaction ) , SER_NETWORK , PROTOCOL_VERSION ) ; CTransaction tx ; stream >> tx ; CValidationState state ; fValid = CheckTransaction ( tx , state ) && state . IsValid ( ) ; for ( unsigned int i = 0 ; i < tx . vin . size ( ) && fValid ; i ++ ) { if ( ! mapprevOutScriptPubKeys . count ( tx . vin [ i ] . prevout ) ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; break ; } unsigned int verify_flags = ParseScriptFlags ( test [ 2 ] . get_str ( ) ) ; fValid = VerifyScript ( tx . vin [ i ] . scriptSig , mapprevOutScriptPubKeys [ tx . vin [ i ] . prevout ] , verify_flags , TransactionSignatureChecker ( & tx , i ) , & err ) ; } BOOST_CHECK_MESSAGE ( ! fValid , strTest ) ; BOOST_CHECK_MESSAGE ( err != SCRIPT_ERR_OK , ScriptErrorString ( err ) ) ; } } }
BOOST_AUTO_TEST_CASE ( basic_transaction_tests ) { unsigned char ch [ ] = { 0x01 , 0x00 , 0x00 , 0x00 , 0x01 , 0x6b , 0xff , 0x7f , 0xcd , 0x4f , 0x85 , 0x65 , 0xef , 0x40 , 0x6d , 0xd5 , 0xd6 , 0x3d , 0x4f , 0xf9 , 0x4f , 0x31 , 0x8f , 0xe8 , 0x20 , 0x27 , 0xfd , 0x4d , 0xc4 , 0x51 , 0xb0 , 0x44 , 0x74 , 0x01 , 0x9f , 0x74 , 0xb4 , 0x00 , 0x00 , 0x00 , 0x00 , 0x8c , 0x49 , 0x30 , 0x46 , 0x02 , 0x21 , 0x00 , 0xda , 0x0d , 0xc6 , 0xae , 0xce , 0xfe , 0x1e , 0x06 , 0xef , 0xdf , 0x05 , 0x77 , 0x37 , 0x57 , 0xde , 0xb1 , 0x68 , 0x82 , 0x09 , 0x30 , 0xe3 , 0xb0 , 0xd0 , 0x3f , 0x46 , 0xf5 , 0xfc , 0xf1 , 0x50 , 0xbf , 0x99 , 0x0c , 0x02 , 0x21 , 0x00 , 0xd2 , 0x5b , 0x5c , 0x87 , 0x04 , 0x00 , 0x76 , 0xe4 , 0xf2 , 0x53 , 0xf8 , 0x26 , 0x2e , 0x76 , 0x3e , 0x2d , 0xd5 , 0x1e , 0x7f , 0xf0 , 0xbe , 0x15 , 0x77 , 0x27 , 0xc4 , 0xbc , 0x42 , 0x80 , 0x7f , 0x17 , 0xbd , 0x39 , 0x01 , 0x41 , 0x04 , 0xe6 , 0xc2 , 0x6e , 0xf6 , 0x7d , 0xc6 , 0x10 , 0xd2 , 0xcd , 0x19 , 0x24 , 0x84 , 0x78 , 0x9a , 0x6c , 0xf9 , 0xae , 0xa9 , 0x93 , 0x0b , 0x94 , 0x4b , 0x7e , 0x2d , 0xb5 , 0x34 , 0x2b , 0x9d , 0x9e , 0x5b , 0x9f , 0xf7 , 0x9a , 0xff , 0x9a , 0x2e , 0xe1 , 0x97 , 0x8d , 0xd7 , 0xfd , 0x01 , 0xdf , 0xc5 , 0x22 , 0xee , 0x02 , 0x28 , 0x3d , 0x3b , 0x06 , 0xa9 , 0xd0 , 0x3a , 0xcf , 0x80 , 0x96 , 0x96 , 0x8d , 0x7d , 0xbb , 0x0f , 0x91 , 0x78 , 0xff , 0xff , 0xff , 0xff , 0x02 , 0x8b , 0xa7 , 0x94 , 0x0e , 0x00 , 0x00 , 0x00 , 0x00 , 0x19 , 0x76 , 0xa9 , 0x14 , 0xba , 0xde , 0xec , 0xfd , 0xef , 0x05 , 0x07 , 0x24 , 0x7f , 0xc8 , 0xf7 , 0x42 , 0x41 , 0xd7 , 0x3b , 0xc0 , 0x39 , 0x97 , 0x2d , 0x7b , 0x88 , 0xac , 0x40 , 0x94 , 0xa8 , 0x02 , 0x00 , 0x00 , 0x00 , 0x00 , 0x19 , 0x76 , 0xa9 , 0x14 , 0xc1 , 0x09 , 0x32 , 0x48 , 0x3f , 0xec , 0x93 , 0xed , 0x51 , 0xf5 , 0xfe , 0x95 , 0xe7 , 0x25 , 0x59 , 0xf2 , 0xcc , 0x70 , 0x43 , 0xf9 , 0x88 , 0xac , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 } ; vector < unsigned char > vch ( ch , ch + sizeof ( ch ) - 1 ) ; CDataStream stream ( vch , SER_DISK , CLIENT_VERSION ) ; CMutableTransaction tx ; stream >> tx ; CValidationState state ; BOOST_CHECK_MESSAGE ( CheckTransaction ( tx , state ) && state . IsValid ( ) , " Simple ▁ deserialized ▁ transaction ▁ should ▁ be ▁ valid . " ) ; tx . vin . push_back ( tx . vin [ 0 ] ) ; BOOST_CHECK_MESSAGE ( ! CheckTransaction ( tx , state ) || ! state . IsValid ( ) , " Transaction ▁ with ▁ duplicate ▁ txins ▁ should ▁ be ▁ invalid . " ) ; }
static std :: vector < CMutableTransaction > SetupDummyInputs ( CBasicKeyStore & keystoreRet , CCoinsViewCache & coinsRet ) { std :: vector < CMutableTransaction > dummyTransactions ; dummyTransactions . resize ( 2 ) ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { key [ i ] . MakeNewKey ( i % 2 ) ; keystoreRet . AddKey ( key [ i ] ) ; } dummyTransactions [ 0 ] . vout . resize ( 2 ) ; dummyTransactions [ 0 ] . vout [ 0 ] . nValue = 11 * CENT ; dummyTransactions [ 0 ] . vout [ 0 ] . scriptPubKey << ToByteVector ( key [ 0 ] . GetPubKey ( ) ) << OP_CHECKSIG ; dummyTransactions [ 0 ] . vout [ 1 ] . nValue = 50 * CENT ; dummyTransactions [ 0 ] . vout [ 1 ] . scriptPubKey << ToByteVector ( key [ 1 ] . GetPubKey ( ) ) << OP_CHECKSIG ; coinsRet . ModifyCoins ( dummyTransactions [ 0 ] . GetHash ( ) ) -> FromTx ( dummyTransactions [ 0 ] , 0 ) ; dummyTransactions [ 1 ] . vout . resize ( 2 ) ; dummyTransactions [ 1 ] . vout [ 0 ] . nValue = 21 * CENT ; dummyTransactions [ 1 ] . vout [ 0 ] . scriptPubKey = GetScriptForDestination ( key [ 2 ] . GetPubKey ( ) . GetID ( ) ) ; dummyTransactions [ 1 ] . vout [ 1 ] . nValue = 22 * CENT ; dummyTransactions [ 1 ] . vout [ 1 ] . scriptPubKey = GetScriptForDestination ( key [ 3 ] . GetPubKey ( ) . GetID ( ) ) ; coinsRet . ModifyCoins ( dummyTransactions [ 1 ] . GetHash ( ) ) -> FromTx ( dummyTransactions [ 1 ] , 0 ) ; return dummyTransactions ; }
BOOST_AUTO_TEST_CASE ( test_Get ) { CBasicKeyStore keystore ; CCoinsView coinsDummy ; CCoinsViewCache coins ( & coinsDummy ) ; std :: vector < CMutableTransaction > dummyTransactions = SetupDummyInputs ( keystore , coins ) ; CMutableTransaction t1 ; t1 . vin . resize ( 3 ) ; t1 . vin [ 0 ] . prevout . hash = dummyTransactions [ 0 ] . GetHash ( ) ; t1 . vin [ 0 ] . prevout . n = 1 ; t1 . vin [ 0 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) ; t1 . vin [ 1 ] . prevout . hash = dummyTransactions [ 1 ] . GetHash ( ) ; t1 . vin [ 1 ] . prevout . n = 0 ; t1 . vin [ 1 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) << std :: vector < unsigned char > ( 33 , 4 ) ; t1 . vin [ 2 ] . prevout . hash = dummyTransactions [ 1 ] . GetHash ( ) ; t1 . vin [ 2 ] . prevout . n = 1 ; t1 . vin [ 2 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) << std :: vector < unsigned char > ( 33 , 4 ) ; t1 . vout . resize ( 2 ) ; t1 . vout [ 0 ] . nValue = 90 * CENT ; t1 . vout [ 0 ] . scriptPubKey << OP_1 ; BOOST_CHECK ( AreInputsStandard ( t1 , coins ) ) ; BOOST_CHECK_EQUAL ( coins . GetValueIn ( t1 ) , ( 50 + 21 + 22 ) * CENT ) ; t1 . vin [ 0 ] . scriptSig << OP_11 ; BOOST_CHECK ( ! AreInputsStandard ( t1 , coins ) ) ; t1 . vin [ 0 ] . scriptSig = CScript ( ) ; BOOST_CHECK ( ! AreInputsStandard ( t1 , coins ) ) ; }
BOOST_AUTO_TEST_CASE ( test_IsStandard ) { LOCK ( cs_main ) ; CBasicKeyStore keystore ; CCoinsView coinsDummy ; CCoinsViewCache coins ( & coinsDummy ) ; std :: vector < CMutableTransaction > dummyTransactions = SetupDummyInputs ( keystore , coins ) ; CMutableTransaction t ; t . vin . resize ( 1 ) ; t . vin [ 0 ] . prevout . hash = dummyTransactions [ 0 ] . GetHash ( ) ; t . vin [ 0 ] . prevout . n = 1 ; t . vin [ 0 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) ; t . vout . resize ( 1 ) ; t . vout [ 0 ] . nValue = 90 * CENT ; CKey key ; key . MakeNewKey ( true ) ; t . vout [ 0 ] . scriptPubKey = GetScriptForDestination ( key . GetPubKey ( ) . GetID ( ) ) ; string reason ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . nValue = 501 ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . nValue = 601 ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_1 ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3800" ) ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout . resize ( 1 ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout . resize ( 2 ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; t . vout [ 1 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; t . vout [ 1 ] . scriptPubKey = CScript ( ) << OP_RETURN ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN ; t . vout [ 1 ] . scriptPubKey = CScript ( ) << OP_RETURN ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; }
LIBSEDML_EXTERN SedDocument_t * SedDocument_create ( unsigned int level , unsigned int version ) { return new SedDocument ( level , version ) ; }
LIBSEDML_EXTERN void SedDocument_free ( SedDocument_t * sd ) { if ( sd != NULL ) delete sd ; }
LIBSEDML_EXTERN SedDocument_t * SedDocument_clone ( SedDocument_t * sd ) { if ( sd != NULL ) { return static_cast < SedDocument_t * > ( sd -> clone ( ) ) ; } else { return NULL ; } }
LIBSEDML_EXTERN int SedDocument_getLevel ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getLevel ( ) : SEDML_INT_MAX ; }
LIBSEDML_EXTERN int SedDocument_getVersion ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getVersion ( ) : SEDML_INT_MAX ; }
LIBSEDML_EXTERN int SedDocument_isSetLevel ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> isSetLevel ( ) ) : 0 ; }
LIBSEDML_EXTERN int SedDocument_isSetVersion ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> isSetVersion ( ) ) : 0 ; }
LIBSEDML_EXTERN int SedDocument_setLevel ( SedDocument_t * sd , int level ) { return ( sd != NULL ) ? sd -> setLevel ( level ) : LIBSEDML_INVALID_OBJECT ; }
LIBSEDML_EXTERN int SedDocument_setVersion ( SedDocument_t * sd , int version ) { return ( sd != NULL ) ? sd -> setVersion ( version ) : LIBSEDML_INVALID_OBJECT ; }
LIBSEDML_EXTERN int SedDocument_unsetLevel ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> unsetLevel ( ) : LIBSEDML_INVALID_OBJECT ; }
LIBSEDML_EXTERN int SedDocument_unsetVersion ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> unsetVersion ( ) : LIBSEDML_INVALID_OBJECT ; }
LIBSEDML_EXTERN int SedDocument_addDataDescription ( SedDocument_t * sd , SedDataDescription_t * sdd ) { return ( sd != NULL ) ? sd -> addDataDescription ( sdd ) : LIBSBML_INVALID_OBJECT ; }
LIBSEDML_EXTERN SedDataDescription_t * SedDocument_createDataDescription ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createDataDescription ( ) : NULL ; }
LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfDataDescriptions ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfDataDescriptions ( ) : NULL ; }
LIBSEDML_EXTERN SedDataDescription_t * SedDocument_getDataDescription ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getDataDescription ( n ) : NULL ; }
LIBSEDML_EXTERN SedDataDescription_t * SedDocument_getDataDescriptionById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getDataDescription ( sid ) : NULL ; }
LIBSEDML_EXTERN unsigned int SedDocument_getNumDataDescriptions ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumDataDescriptions ( ) : SEDML_INT_MAX ; }
LIBSEDML_EXTERN SedDataDescription_t * SedDocument_removeDataDescription ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeDataDescription ( n ) : NULL ; }
LIBSEDML_EXTERN SedDataDescription_t * SedDocument_removeDataDescriptionById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeDataDescription ( sid ) : NULL ; }
LIBSEDML_EXTERN int SedDocument_addSimulation ( SedDocument_t * sd , SedSimulation_t * ss ) { return ( sd != NULL ) ? sd -> addSimulation ( ss ) : LIBSBML_INVALID_OBJECT ; }
LIBSEDML_EXTERN SedUniformTimeCourse_t * SedDocument_createUniformTimeCourse ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createUniformTimeCourse ( ) : NULL ; }
LIBSEDML_EXTERN SedOneStep_t * SedDocument_createOneStep ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createOneStep ( ) : NULL ; }
LIBSEDML_EXTERN SedSteadyState_t * SedDocument_createSteadyState ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createSteadyState ( ) : NULL ; }
LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfSimulations ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfSimulations ( ) : NULL ; }
LIBSEDML_EXTERN SedSimulation_t * SedDocument_getSimulation ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getSimulation ( n ) : NULL ; }
LIBSEDML_EXTERN SedSimulation_t * SedDocument_getSimulationById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getSimulation ( sid ) : NULL ; }
LIBSEDML_EXTERN unsigned int SedDocument_getNumSimulations ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumSimulations ( ) : SEDML_INT_MAX ; }
LIBSEDML_EXTERN SedSimulation_t * SedDocument_removeSimulation ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeSimulation ( n ) : NULL ; }
LIBSEDML_EXTERN SedSimulation_t * SedDocument_removeSimulationById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeSimulation ( sid ) : NULL ; }
LIBSEDML_EXTERN int SedDocument_addModel ( SedDocument_t * sd , SedModel_t * sm ) { return ( sd != NULL ) ? sd -> addModel ( sm ) : LIBSBML_INVALID_OBJECT ; }
LIBSEDML_EXTERN SedModel_t * SedDocument_createModel ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createModel ( ) : NULL ; }
LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfModels ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfModels ( ) : NULL ; }
LIBSEDML_EXTERN SedModel_t * SedDocument_getModel ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getModel ( n ) : NULL ; }
LIBSEDML_EXTERN SedModel_t * SedDocument_getModelById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getModel ( sid ) : NULL ; }
LIBSEDML_EXTERN unsigned int SedDocument_getNumModels ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumModels ( ) : SEDML_INT_MAX ; }
LIBSEDML_EXTERN SedModel_t * SedDocument_removeModel ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeModel ( n ) : NULL ; }
LIBSEDML_EXTERN SedModel_t * SedDocument_removeModelById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeModel ( sid ) : NULL ; }
LIBSEDML_EXTERN int SedDocument_addTask ( SedDocument_t * sd , SedTask_t * st ) { return ( sd != NULL ) ? sd -> addTask ( st ) : LIBSBML_INVALID_OBJECT ; }
LIBSEDML_EXTERN SedTask_t * SedDocument_createTask ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createTask ( ) : NULL ; }
LIBSEDML_EXTERN SedRepeatedTask_t * SedDocument_createRepeatedTask ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createRepeatedTask ( ) : NULL ; }
LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfTasks ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfTasks ( ) : NULL ; }
LIBSEDML_EXTERN SedTask_t * SedDocument_getTask ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getTask ( n ) : NULL ; }
LIBSEDML_EXTERN SedTask_t * SedDocument_getTaskById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getTask ( sid ) : NULL ; }
LIBSEDML_EXTERN unsigned int SedDocument_getNumTasks ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumTasks ( ) : SEDML_INT_MAX ; }
LIBSEDML_EXTERN SedTask_t * SedDocument_removeTask ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeTask ( n ) : NULL ; }
LIBSEDML_EXTERN SedTask_t * SedDocument_removeTaskById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeTask ( sid ) : NULL ; }
LIBSEDML_EXTERN int SedDocument_addDataGenerator ( SedDocument_t * sd , SedDataGenerator_t * sdg ) { return ( sd != NULL ) ? sd -> addDataGenerator ( sdg ) : LIBSBML_INVALID_OBJECT ; }
LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_createDataGenerator ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createDataGenerator ( ) : NULL ; }
LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfDataGenerators ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfDataGenerators ( ) : NULL ; }
LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_getDataGenerator ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getDataGenerator ( n ) : NULL ; }
LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_getDataGeneratorById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getDataGenerator ( sid ) : NULL ; }
LIBSEDML_EXTERN unsigned int SedDocument_getNumDataGenerators ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumDataGenerators ( ) : SEDML_INT_MAX ; }
LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_removeDataGenerator ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeDataGenerator ( n ) : NULL ; }
LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_removeDataGeneratorById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeDataGenerator ( sid ) : NULL ; }
LIBSEDML_EXTERN int SedDocument_addOutput ( SedDocument_t * sd , SedOutput_t * so ) { return ( sd != NULL ) ? sd -> addOutput ( so ) : LIBSBML_INVALID_OBJECT ; }
LIBSEDML_EXTERN SedReport_t * SedDocument_createReport ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createReport ( ) : NULL ; }
LIBSEDML_EXTERN SedPlot2D_t * SedDocument_createPlot2D ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createPlot2D ( ) : NULL ; }
LIBSEDML_EXTERN SedPlot3D_t * SedDocument_createPlot3D ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createPlot3D ( ) : NULL ; }
LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfOutputs ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfOutputs ( ) : NULL ; }
LIBSEDML_EXTERN SedOutput_t * SedDocument_getOutput ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getOutput ( n ) : NULL ; }
LIBSEDML_EXTERN SedOutput_t * SedDocument_getOutputById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getOutput ( sid ) : NULL ; }
LIBSEDML_EXTERN unsigned int SedDocument_getNumOutputs ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumOutputs ( ) : SEDML_INT_MAX ; }
LIBSEDML_EXTERN SedOutput_t * SedDocument_removeOutput ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeOutput ( n ) : NULL ; }
LIBSEDML_EXTERN SedOutput_t * SedDocument_removeOutputById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeOutput ( sid ) : NULL ; }
LIBSEDML_EXTERN int SedDocument_hasRequiredAttributes ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> hasRequiredAttributes ( ) ) : 0 ; }
LIBSEDML_EXTERN int SedDocument_hasRequiredElements ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> hasRequiredElements ( ) ) : 0 ; }
static std :: pair < unsigned , unsigned > getMFHiLoOpc ( unsigned Src ) { if ( Mips :: ACC64RegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: PseudoMFHI , ( unsigned ) Mips :: PseudoMFLO ) ; if ( Mips :: ACC64DSPRegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: MFHI_DSP , ( unsigned ) Mips :: MFLO_DSP ) ; if ( Mips :: ACC128RegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: PseudoMFHI64 , ( unsigned ) Mips :: PseudoMFLO64 ) ; return std :: make_pair ( 0 , 0 ) ; }
inline int hashPos2 ( int x , int y , int n ) { return ( ( x * 73856093 ) ^ ( y * 19349663 ) ) & ( n - 1 ) ; }
void EnsureWalletIsUnlocked ( ) { if ( pwalletMain -> IsLocked ( ) ) throw JSONRPCError ( RPC_WALLET_UNLOCK_NEEDED , " Error : ▁ Please ▁ enter ▁ the ▁ wallet ▁ passphrase ▁ with ▁ walletpassphrase ▁ first . " ) ; if ( fWalletUnlockStakingOnly ) throw JSONRPCError ( RPC_WALLET_ALREADY_UNLOCKED_STAKING_ONLY , " Error : ▁ Wallet ▁ is ▁ unlocked ▁ for ▁ staking ▁ only . " ) ; }
void WalletTxToJSON ( const CWalletTx & wtx , Object & entry ) { int confirms = wtx . GetDepthInMainChain ( ) ; entry . push_back ( Pair ( " confirmations " , confirms ) ) ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) ) entry . push_back ( Pair ( " generated " , true ) ) ; if ( confirms > 0 ) { entry . push_back ( Pair ( " blockhash " , wtx . hashBlock . GetHex ( ) ) ) ; entry . push_back ( Pair ( " blockindex " , wtx . nIndex ) ) ; entry . push_back ( Pair ( " blocktime " , ( boost :: int64_t ) ( mapBlockIndex [ wtx . hashBlock ] -> nTime ) ) ) ; } entry . push_back ( Pair ( " txid " , wtx . GetHash ( ) . GetHex ( ) ) ) ; entry . push_back ( Pair ( " normtxid " , wtx . GetNormalizedHash ( ) . GetHex ( ) ) ) ; entry . push_back ( Pair ( " time " , ( boost :: int64_t ) wtx . GetTxTime ( ) ) ) ; entry . push_back ( Pair ( " timereceived " , ( boost :: int64_t ) wtx . nTimeReceived ) ) ; BOOST_FOREACH ( const PAIRTYPE ( string , string ) & item , wtx . mapValue ) entry . push_back ( Pair ( item . first , item . second ) ) ; }
string AccountFromValue ( const Value & value ) { string strAccount = value . get_str ( ) ; if ( strAccount == " * " ) throw JSONRPCError ( RPC_WALLET_INVALID_ACCOUNT_NAME , " Invalid ▁ account ▁ name " ) ; return strAccount ; }
Value getinfo ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 0 ) throw runtime_error ( " getinfo \n " " Returns ▁ an ▁ object ▁ containing ▁ various ▁ state ▁ info . " ) ; proxyType proxy ; GetProxy ( NET_IPV4 , proxy ) ; Object obj ; obj . push_back ( Pair ( " version " , ( int ) CLIENT_VERSION ) ) ; obj . push_back ( Pair ( " protocolversion " , ( int ) PROTOCOL_VERSION ) ) ; if ( pwalletMain ) { obj . push_back ( Pair ( " walletversion " , pwalletMain -> GetVersion ( ) ) ) ; obj . push_back ( Pair ( " balance " , ValueFromAmount ( pwalletMain -> GetBalance ( ) ) ) ) ; obj . push_back ( Pair ( " unconfirmedbalance " , ValueFromAmount ( pwalletMain -> GetUnconfirmedBalance ( ) ) ) ) ; obj . push_back ( Pair ( " stake " , ValueFromAmount ( pwalletMain -> GetStake ( ) ) ) ) ; obj . push_back ( Pair ( " locked " , pwalletMain -> IsLocked ( ) ) ) ; obj . push_back ( Pair ( " encrypted " , pwalletMain -> IsCrypted ( ) ) ) ; } obj . push_back ( Pair ( " blocks " , ( int ) nBestHeight ) ) ; obj . push_back ( Pair ( " timeoffset " , ( boost :: int64_t ) GetTimeOffset ( ) ) ) ; obj . push_back ( Pair ( " moneysupply " , ValueFromAmount ( pindexBest -> nMoneySupply ) ) ) ; obj . push_back ( Pair ( " connections " , ( int ) vNodes . size ( ) ) ) ; obj . push_back ( Pair ( " proxy " , ( proxy . first . IsValid ( ) ? proxy . first . ToStringIPPort ( ) : string ( ) ) ) ) ; obj . push_back ( Pair ( " difficulty " , ( double ) GetDifficulty ( ) ) ) ; obj . push_back ( Pair ( " testnet " , fTestNet ) ) ; if ( pwalletMain ) { obj . push_back ( Pair ( " keypoololdest " , ( boost :: int64_t ) pwalletMain -> GetOldestKeyPoolTime ( ) ) ) ; obj . push_back ( Pair ( " keypoolsize " , ( int ) pwalletMain -> GetKeyPoolSize ( ) ) ) ; } obj . push_back ( Pair ( " paytxfee " , ValueFromAmount ( nTransactionFee ) ) ) ; obj . push_back ( Pair ( " mininput " , ValueFromAmount ( nMinimumInputValue ) ) ) ; if ( pwalletMain && pwalletMain -> IsCrypted ( ) ) obj . push_back ( Pair ( " unlocked _ until " , ( boost :: int64_t ) nWalletUnlockTime ) ) ; obj . push_back ( Pair ( " errors " , GetWarnings ( " statusbar " ) ) ) ; return obj ; }
Value getnewaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 1 ) throw runtime_error ( " getnewaddress ▁ [ account ] \n " " Returns ▁ a ▁ new ▁ ILoveYouCoins ▁ address ▁ for ▁ receiving ▁ payments . ▁ ▁ " " If ▁ [ account ] ▁ is ▁ specified ▁ ( recommended ) , ▁ it ▁ is ▁ added ▁ to ▁ the ▁ address ▁ book ▁ " " so ▁ payments ▁ received ▁ with ▁ the ▁ address ▁ will ▁ be ▁ credited ▁ to ▁ [ account ] . " ) ; string strAccount ; if ( params . size ( ) > 0 ) strAccount = AccountFromValue ( params [ 0 ] ) ; if ( ! pwalletMain -> IsLocked ( ) ) pwalletMain -> TopUpKeyPool ( ) ; CPubKey newKey ; if ( ! pwalletMain -> GetKeyFromPool ( newKey , false ) ) throw JSONRPCError ( RPC_WALLET_KEYPOOL_RAN_OUT , " Error : ▁ Keypool ▁ ran ▁ out , ▁ please ▁ call ▁ keypoolrefill ▁ first " ) ; CKeyID keyID = newKey . GetID ( ) ; pwalletMain -> SetAddressBookName ( keyID , strAccount ) ; return CBitcoinAddress ( keyID ) . ToString ( ) ; }
CBitcoinAddress GetAccountAddress ( string strAccount , bool bForceNew = false ) { CWalletDB walletdb ( pwalletMain -> strWalletFile ) ; CAccount account ; walletdb . ReadAccount ( strAccount , account ) ; bool bKeyUsed = false ; if ( account . vchPubKey . IsValid ( ) ) { CScript scriptPubKey ; scriptPubKey . SetDestination ( account . vchPubKey . GetID ( ) ) ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) && account . vchPubKey . IsValid ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) if ( txout . scriptPubKey == scriptPubKey ) bKeyUsed = true ; } } if ( ! account . vchPubKey . IsValid ( ) || bForceNew || bKeyUsed ) { if ( ! pwalletMain -> GetKeyFromPool ( account . vchPubKey , false ) ) throw JSONRPCError ( RPC_WALLET_KEYPOOL_RAN_OUT , " Error : ▁ Keypool ▁ ran ▁ out , ▁ please ▁ call ▁ keypoolrefill ▁ first " ) ; pwalletMain -> SetAddressBookName ( account . vchPubKey . GetID ( ) , strAccount ) ; walletdb . WriteAccount ( strAccount , account ) ; } return CBitcoinAddress ( account . vchPubKey . GetID ( ) ) ; }
Value getaccountaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " getaccountaddress ▁ < account > \n " " Returns ▁ the ▁ current ▁ ILoveYouCoins ▁ address ▁ for ▁ receiving ▁ payments ▁ to ▁ this ▁ account . " ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; Value ret ; ret = GetAccountAddress ( strAccount ) . ToString ( ) ; return ret ; }
Value setaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " setaccount ▁ < iloveyoucoinsaddress > ▁ < account > \n " " Sets ▁ the ▁ account ▁ associated ▁ with ▁ the ▁ given ▁ address . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; string strAccount ; if ( params . size ( ) > 1 ) strAccount = AccountFromValue ( params [ 1 ] ) ; if ( pwalletMain -> mapAddressBook . count ( address . Get ( ) ) ) { string strOldAccount = pwalletMain -> mapAddressBook [ address . Get ( ) ] ; if ( address == GetAccountAddress ( strOldAccount ) ) GetAccountAddress ( strOldAccount , true ) ; } pwalletMain -> SetAddressBookName ( address . Get ( ) , strAccount ) ; return Value :: null ; }
Value getaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " getaccount ▁ < iloveyoucoinsaddress > \n " " Returns ▁ the ▁ account ▁ associated ▁ with ▁ the ▁ given ▁ address . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; string strAccount ; map < CTxDestination , string > :: iterator mi = pwalletMain -> mapAddressBook . find ( address . Get ( ) ) ; if ( mi != pwalletMain -> mapAddressBook . end ( ) && ! ( * mi ) . second . empty ( ) ) strAccount = ( * mi ) . second ; return strAccount ; }
Value getaddressesbyaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " getaddressesbyaccount ▁ < account > \n " " Returns ▁ the ▁ list ▁ of ▁ addresses ▁ for ▁ the ▁ given ▁ account . " ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; Array ret ; BOOST_FOREACH ( const PAIRTYPE ( CBitcoinAddress , string ) & item , pwalletMain -> mapAddressBook ) { const CBitcoinAddress & address = item . first ; const string & strName = item . second ; if ( strName == strAccount ) ret . push_back ( address . ToString ( ) ) ; } return ret ; }
Value setmininput ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 1 ) throw runtime_error ( " setmininput ▁ < amount > \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ rounded ▁ to ▁ the ▁ nearest ▁ 0.00000001" ) ; int64 nAmount = 0 ; if ( params [ 0 ] . get_real ( ) != 0.0 ) nAmount = AmountFromValue ( params [ 0 ] ) ; nMinimumInputValue = nAmount ; return true ; }
Value sendtoaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 4 ) throw runtime_error ( " sendtoaddress ▁ < iloveyoucoinsaddress > ▁ < amount > ▁ [ comment ] ▁ [ comment - to ] \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ rounded ▁ to ▁ the ▁ nearest ▁ 0.00000001" + HelpRequiringPassphrase ( ) ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; int64 nAmount = AmountFromValue ( params [ 1 ] ) ; CWalletTx wtx ; if ( params . size ( ) > 2 && params [ 2 ] . type ( ) != null_type && ! params [ 2 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " comment " ] = params [ 2 ] . get_str ( ) ; if ( params . size ( ) > 3 && params [ 3 ] . type ( ) != null_type && ! params [ 3 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " to " ] = params [ 3 ] . get_str ( ) ; EnsureWalletIsUnlocked ( ) ; string strError = pwalletMain -> SendMoneyToDestination ( address . Get ( ) , nAmount , wtx ) ; if ( strError != " " ) throw JSONRPCError ( RPC_WALLET_ERROR , strError ) ; return wtx . GetHash ( ) . GetHex ( ) ; }
Value listaddressgroupings ( const Array & params , bool fHelp ) { if ( fHelp ) throw runtime_error ( " listaddressgroupings \n " " Lists ▁ groups ▁ of ▁ addresses ▁ which ▁ have ▁ had ▁ their ▁ common ▁ ownership \n " " made ▁ public ▁ by ▁ common ▁ use ▁ as ▁ inputs ▁ or ▁ as ▁ the ▁ resulting ▁ change \n " " in ▁ past ▁ transactions " ) ; Array jsonGroupings ; map < CTxDestination , int64 > balances = pwalletMain -> GetAddressBalances ( ) ; BOOST_FOREACH ( set < CTxDestination > grouping , pwalletMain -> GetAddressGroupings ( ) ) { Array jsonGrouping ; BOOST_FOREACH ( CTxDestination address , grouping ) { Array addressInfo ; addressInfo . push_back ( CBitcoinAddress ( address ) . ToString ( ) ) ; addressInfo . push_back ( ValueFromAmount ( balances [ address ] ) ) ; { LOCK ( pwalletMain -> cs_wallet ) ; if ( pwalletMain -> mapAddressBook . find ( CBitcoinAddress ( address ) . Get ( ) ) != pwalletMain -> mapAddressBook . end ( ) ) addressInfo . push_back ( pwalletMain -> mapAddressBook . find ( CBitcoinAddress ( address ) . Get ( ) ) -> second ) ; } jsonGrouping . push_back ( addressInfo ) ; } jsonGroupings . push_back ( jsonGrouping ) ; } return jsonGroupings ; }
Value signmessage ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 2 ) throw runtime_error ( " signmessage ▁ < iloveyoucoinsaddress > ▁ < message > \n " " Sign ▁ a ▁ message ▁ with ▁ the ▁ private ▁ key ▁ of ▁ an ▁ address " ) ; EnsureWalletIsUnlocked ( ) ; string strAddress = params [ 0 ] . get_str ( ) ; string strMessage = params [ 1 ] . get_str ( ) ; CBitcoinAddress addr ( strAddress ) ; if ( ! addr . IsValid ( ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Invalid ▁ address " ) ; CKeyID keyID ; if ( ! addr . GetKeyID ( keyID ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Address ▁ does ▁ not ▁ refer ▁ to ▁ key " ) ; CKey key ; if ( ! pwalletMain -> GetKey ( keyID , key ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Private ▁ key ▁ not ▁ available " ) ; CHashWriter ss ( SER_GETHASH , 0 ) ; ss << strMessageMagic ; ss << strMessage ; vector < unsigned char > vchSig ; if ( ! key . SignCompact ( ss . GetHash ( ) , vchSig ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Sign ▁ failed " ) ; return EncodeBase64 ( & vchSig [ 0 ] , vchSig . size ( ) ) ; }
Value verifymessage ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 3 ) throw runtime_error ( " verifymessage ▁ < iloveyoucoinsaddress > ▁ < signature > ▁ < message > \n " " Verify ▁ a ▁ signed ▁ message " ) ; string strAddress = params [ 0 ] . get_str ( ) ; string strSign = params [ 1 ] . get_str ( ) ; string strMessage = params [ 2 ] . get_str ( ) ; CBitcoinAddress addr ( strAddress ) ; if ( ! addr . IsValid ( ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Invalid ▁ address " ) ; CKeyID keyID ; if ( ! addr . GetKeyID ( keyID ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Address ▁ does ▁ not ▁ refer ▁ to ▁ key " ) ; bool fInvalid = false ; vector < unsigned char > vchSig = DecodeBase64 ( strSign . c_str ( ) , & fInvalid ) ; if ( fInvalid ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Malformed ▁ base64 ▁ encoding " ) ; CHashWriter ss ( SER_GETHASH , 0 ) ; ss << strMessageMagic ; ss << strMessage ; CPubKey pubkey ; if ( ! pubkey . RecoverCompact ( ss . GetHash ( ) , vchSig ) ) return false ; return ( pubkey . GetID ( ) == keyID ) ; }
Value getreceivedbyaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " getreceivedbyaddress ▁ < iloveyoucoinsaddress > ▁ [ minconf = 1 ] \n " " Returns ▁ the ▁ total ▁ amount ▁ received ▁ by ▁ < iloveyoucoinsaddress > ▁ in ▁ transactions ▁ with ▁ at ▁ least ▁ [ minconf ] ▁ confirmations . " ) ; CBitcoinAddress address = CBitcoinAddress ( params [ 0 ] . get_str ( ) ) ; CScript scriptPubKey ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; scriptPubKey . SetDestination ( address . Get ( ) ) ; if ( ! IsMine ( * pwalletMain , scriptPubKey ) ) return ( double ) 0.0 ; int nMinDepth = 1 ; if ( params . size ( ) > 1 ) nMinDepth = params [ 1 ] . get_int ( ) ; int64 nAmount = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) || ! wtx . IsFinal ( ) ) continue ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) if ( txout . scriptPubKey == scriptPubKey ) if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) nAmount += txout . nValue ; } return ValueFromAmount ( nAmount ) ; }
void GetAccountAddresses ( string strAccount , set < CTxDestination > & setAddress ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , string ) & item , pwalletMain -> mapAddressBook ) { const CTxDestination & address = item . first ; const string & strName = item . second ; if ( strName == strAccount ) setAddress . insert ( address ) ; } }
Value getreceivedbyaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " getreceivedbyaccount ▁ < account > ▁ [ minconf = 1 ] \n " " Returns ▁ the ▁ total ▁ amount ▁ received ▁ by ▁ addresses ▁ with ▁ < account > ▁ in ▁ transactions ▁ with ▁ at ▁ least ▁ [ minconf ] ▁ confirmations . " ) ; int nMinDepth = 1 ; if ( params . size ( ) > 1 ) nMinDepth = params [ 1 ] . get_int ( ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; set < CTxDestination > setAddress ; GetAccountAddresses ( strAccount , setAddress ) ; int64 nAmount = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) || ! wtx . IsFinal ( ) ) continue ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) { CTxDestination address ; if ( ExtractDestination ( txout . scriptPubKey , address ) && IsMine ( * pwalletMain , address ) && setAddress . count ( address ) ) if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) nAmount += txout . nValue ; } } return ( double ) nAmount / ( double ) COIN ; }
int64 GetAccountBalance ( CWalletDB & walletdb , const string & strAccount , int nMinDepth ) { int64 nBalance = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . IsFinal ( ) ) continue ; int64 nReceived , nSent , nFee ; wtx . GetAccountAmounts ( strAccount , nReceived , nSent , nFee ) ; if ( nReceived != 0 && wtx . GetDepthInMainChain ( ) >= nMinDepth ) nBalance += nReceived ; nBalance -= nSent + nFee ; } nBalance += walletdb . GetAccountCreditDebit ( strAccount ) ; return nBalance ; }
int64 GetAccountBalance ( const string & strAccount , int nMinDepth ) { CWalletDB walletdb ( pwalletMain -> strWalletFile ) ; return GetAccountBalance ( walletdb , strAccount , nMinDepth ) ; }
Value getbalance ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " getbalance ▁ [ account ] ▁ [ minconf = 1 ] \n " " If ▁ [ account ] ▁ is ▁ not ▁ specified , ▁ returns ▁ the ▁ server ' s ▁ total ▁ available ▁ balance . \n " " If ▁ [ account ] ▁ is ▁ specified , ▁ returns ▁ the ▁ balance ▁ in ▁ the ▁ account . " ) ; if ( params . size ( ) == 0 ) return ValueFromAmount ( pwalletMain -> GetBalance ( ) ) ; int nMinDepth = 1 ; if ( params . size ( ) > 1 ) nMinDepth = params [ 1 ] . get_int ( ) ; if ( params [ 0 ] . get_str ( ) == " * " ) { int64 nBalance = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . IsConfirmed ( ) ) continue ; int64 allFee ; string strSentAccount ; list < pair < CTxDestination , int64 > > listReceived ; list < pair < CTxDestination , int64 > > listSent ; wtx . GetAmounts ( listReceived , listSent , allFee , strSentAccount ) ; if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listReceived ) nBalance += r . second ; } BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listSent ) nBalance -= r . second ; nBalance -= allFee ; } return ValueFromAmount ( nBalance ) ; } string strAccount = AccountFromValue ( params [ 0 ] ) ; int64 nBalance = GetAccountBalance ( strAccount , nMinDepth ) ; return ValueFromAmount ( nBalance ) ; }
Value getunconfirmedbalance ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 0 ) throw runtime_error ( " getunconfirmedbalance \n " " Returns ▁ the ▁ server ' s ▁ total ▁ unconfirmed ▁ balance \n " ) ; return ValueFromAmount ( pwalletMain -> GetUnconfirmedBalance ( ) ) ; }
Value movecmd ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 3 || params . size ( ) > 5 ) throw runtime_error ( " move ▁ < fromaccount > ▁ < toaccount > ▁ < amount > ▁ [ minconf = 1 ] ▁ [ comment ] \n " " Move ▁ from ▁ one ▁ account ▁ in ▁ your ▁ wallet ▁ to ▁ another . " ) ; string strFrom = AccountFromValue ( params [ 0 ] ) ; string strTo = AccountFromValue ( params [ 1 ] ) ; int64 nAmount = AmountFromValue ( params [ 2 ] ) ; if ( params . size ( ) > 3 ) ( void ) params [ 3 ] . get_int ( ) ; string strComment ; if ( params . size ( ) > 4 ) strComment = params [ 4 ] . get_str ( ) ; CWalletDB walletdb ( pwalletMain -> strWalletFile ) ; if ( ! walletdb . TxnBegin ( ) ) throw JSONRPCError ( RPC_DATABASE_ERROR , " database ▁ error " ) ; int64 nNow = GetAdjustedTime ( ) ; CAccountingEntry debit ; debit . nOrderPos = pwalletMain -> IncOrderPosNext ( & walletdb ) ; debit . strAccount = strFrom ; debit . nCreditDebit = - nAmount ; debit . nTime = nNow ; debit . strOtherAccount = strTo ; debit . strComment = strComment ; walletdb . WriteAccountingEntry ( debit ) ; CAccountingEntry credit ; credit . nOrderPos = pwalletMain -> IncOrderPosNext ( & walletdb ) ; credit . strAccount = strTo ; credit . nCreditDebit = nAmount ; credit . nTime = nNow ; credit . strOtherAccount = strFrom ; credit . strComment = strComment ; walletdb . WriteAccountingEntry ( credit ) ; if ( ! walletdb . TxnCommit ( ) ) throw JSONRPCError ( RPC_DATABASE_ERROR , " database ▁ error " ) ; return true ; }
Value sendfrom ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 3 || params . size ( ) > 6 ) throw runtime_error ( " sendfrom ▁ < fromaccount > ▁ < toiloveyoucoinsaddress > ▁ < amount > ▁ [ minconf = 1 ] ▁ [ comment ] ▁ [ comment - to ] \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ rounded ▁ to ▁ the ▁ nearest ▁ 0.00000001" + HelpRequiringPassphrase ( ) ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; CBitcoinAddress address ( params [ 1 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; int64 nAmount = AmountFromValue ( params [ 2 ] ) ; int nMinDepth = 1 ; if ( params . size ( ) > 3 ) nMinDepth = params [ 3 ] . get_int ( ) ; CWalletTx wtx ; wtx . strFromAccount = strAccount ; if ( params . size ( ) > 4 && params [ 4 ] . type ( ) != null_type && ! params [ 4 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " comment " ] = params [ 4 ] . get_str ( ) ; if ( params . size ( ) > 5 && params [ 5 ] . type ( ) != null_type && ! params [ 5 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " to " ] = params [ 5 ] . get_str ( ) ; EnsureWalletIsUnlocked ( ) ; int64 nBalance = GetAccountBalance ( strAccount , nMinDepth ) ; if ( nAmount > nBalance ) throw JSONRPCError ( RPC_WALLET_INSUFFICIENT_FUNDS , " Account ▁ has ▁ insufficient ▁ funds " ) ; string strError = pwalletMain -> SendMoneyToDestination ( address . Get ( ) , nAmount , wtx ) ; if ( strError != " " ) throw JSONRPCError ( RPC_WALLET_ERROR , strError ) ; return wtx . GetHash ( ) . GetHex ( ) ; }
Value sendmany ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 4 ) throw runtime_error ( " sendmany ▁ < fromaccount > ▁ { address : amount , . . . } ▁ [ minconf = 1 ] ▁ [ comment ] \n " " amounts ▁ are ▁ double - precision ▁ floating ▁ point ▁ numbers " + HelpRequiringPassphrase ( ) ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; Object sendTo = params [ 1 ] . get_obj ( ) ; int nMinDepth = 1 ; if ( params . size ( ) > 2 ) nMinDepth = params [ 2 ] . get_int ( ) ; CWalletTx wtx ; wtx . strFromAccount = strAccount ; if ( params . size ( ) > 3 && params [ 3 ] . type ( ) != null_type && ! params [ 3 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " comment " ] = params [ 3 ] . get_str ( ) ; set < CBitcoinAddress > setAddress ; vector < pair < CScript , int64 > > vecSend ; int64 totalAmount = 0 ; BOOST_FOREACH ( const Pair & s , sendTo ) { CBitcoinAddress address ( s . name_ ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , string ( " Invalid ▁ ILoveYouCoins ▁ address : ▁ " ) + s . name_ ) ; if ( setAddress . count ( address ) ) throw JSONRPCError ( RPC_INVALID_PARAMETER , string ( " Invalid ▁ parameter , ▁ duplicated ▁ address : ▁ " ) + s . name_ ) ; setAddress . insert ( address ) ; CScript scriptPubKey ; scriptPubKey . SetDestination ( address . Get ( ) ) ; int64 nAmount = AmountFromValue ( s . value_ ) ; totalAmount += nAmount ; vecSend . push_back ( make_pair ( scriptPubKey , nAmount ) ) ; } EnsureWalletIsUnlocked ( ) ; int64 nBalance = GetAccountBalance ( strAccount , nMinDepth ) ; if ( totalAmount > nBalance ) throw JSONRPCError ( RPC_WALLET_INSUFFICIENT_FUNDS , " Account ▁ has ▁ insufficient ▁ funds " ) ; CReserveKey keyChange ( pwalletMain ) ; int64 nFeeRequired = 0 ; string strFailReason ; bool fCreated = pwalletMain -> CreateTransaction ( vecSend , wtx , keyChange , nFeeRequired , strFailReason ) ; if ( ! fCreated ) throw JSONRPCError ( RPC_WALLET_INSUFFICIENT_FUNDS , strFailReason ) ; if ( ! pwalletMain -> CommitTransaction ( wtx , keyChange ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Transaction ▁ commit ▁ failed " ) ; return wtx . GetHash ( ) . GetHex ( ) ; }
static CScript _createmultisig ( const Array & params ) { int nRequired = params [ 0 ] . get_int ( ) ; const Array & keys = params [ 1 ] . get_array ( ) ; if ( nRequired < 1 ) throw runtime_error ( " a ▁ multisignature ▁ address ▁ must ▁ require ▁ at ▁ least ▁ one ▁ key ▁ to ▁ redeem " ) ; if ( ( int ) keys . size ( ) < nRequired ) throw runtime_error ( strprintf ( " not ▁ enough ▁ keys ▁ supplied ▁ " " ( got ▁ % " PRIszu " ▁ keys , ▁ but ▁ need ▁ at ▁ least ▁ % d ▁ to ▁ redeem ) " , keys . size ( ) , nRequired ) ) ; std :: vector < CPubKey > pubkeys ; pubkeys . resize ( keys . size ( ) ) ; for ( unsigned int i = 0 ; i < keys . size ( ) ; i ++ ) { const std :: string & ks = keys [ i ] . get_str ( ) ; CBitcoinAddress address ( ks ) ; if ( pwalletMain && address . IsValid ( ) ) { CKeyID keyID ; if ( ! address . GetKeyID ( keyID ) ) throw runtime_error ( strprintf ( " % s ▁ does ▁ not ▁ refer ▁ to ▁ a ▁ key " , ks . c_str ( ) ) ) ; CPubKey vchPubKey ; if ( ! pwalletMain -> GetPubKey ( keyID , vchPubKey ) ) throw runtime_error ( strprintf ( " no ▁ full ▁ public ▁ key ▁ for ▁ address ▁ % s " , ks . c_str ( ) ) ) ; if ( ! vchPubKey . IsFullyValid ( ) ) throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; pubkeys [ i ] = vchPubKey ; } else if ( IsHex ( ks ) ) { CPubKey vchPubKey ( ParseHex ( ks ) ) ; if ( ! vchPubKey . IsFullyValid ( ) ) throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; pubkeys [ i ] = vchPubKey ; } else { throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; } } CScript result ; result . SetMultisig ( nRequired , pubkeys ) ; return result ; }
Value addmultisigaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 3 ) { string msg = " addmultisigaddress ▁ < nrequired > ▁ < ' [ \ " key \ " , \ " key \ " ] ' > ▁ [ account ] \n " " Add ▁ a ▁ nrequired - to - sign ▁ multisignature ▁ address ▁ to ▁ the ▁ wallet\ " \ n " " each ▁ key ▁ is ▁ a ▁ ILoveYouCoins ▁ address ▁ or ▁ hex - encoded ▁ public ▁ key \ n " " If ▁ [ account ] ▁ is ▁ specified , ▁ assign ▁ address ▁ to ▁ [ account ] . " ; throw runtime_error ( msg ) ; } string strAccount ; if ( params . size ( ) > 2 ) strAccount = AccountFromValue ( params [ 2 ] ) ; CScript inner = _createmultisig ( params ) ; CScriptID innerID = inner . GetID ( ) ; pwalletMain -> AddCScript ( inner ) ; pwalletMain -> SetAddressBookName ( innerID , strAccount ) ; return CBitcoinAddress ( innerID ) . ToString ( ) ; } Value createmultisig ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 2 ) { string msg = " createmultisig ▁ < nrequired > ▁ < ' [ \ " key\ " , \ " key\ " ] ' > \ n " " Creates ▁ a ▁ multi - signature ▁ address ▁ and ▁ returns ▁ a ▁ json ▁ object \ n " " with ▁ keys : \ n " " address ▁ : ▁ iloveyoucoins ▁ address \ n " " redeemScript ▁ : ▁ hex - encoded ▁ redemption ▁ script " ; throw runtime_error ( msg ) ; } CScript inner = _createmultisig ( params ) ; CScriptID innerID = inner . GetID ( ) ; CBitcoinAddress address ( innerID ) ; Object result ; result . push_back ( Pair ( " address " , address . ToString ( ) ) ) ; result . push_back ( Pair ( " redeemScript " , HexStr ( inner . begin ( ) , inner . end ( ) ) ) ) ; return result ; } struct tallyitem { int64 nAmount ; int nConf ; vector < uint256 > txids ; tallyitem ( ) { nAmount = 0 ; nConf = std :: numeric_limits < int > :: max ( ) ; } } ; Value ListReceived ( const Array & params , bool fByAccounts ) { int nMinDepth = 1 ; if ( params . size ( ) > 0 ) nMinDepth = params [ 0 ] . get_int ( ) ; bool fIncludeEmpty = false ; if ( params . size ( ) > 1 ) fIncludeEmpty = params [ 1 ] . get_bool ( ) ; map < CBitcoinAddress , tallyitem > mapTally ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) || ! wtx . IsFinal ( ) ) continue ; int nDepth = wtx . GetDepthInMainChain ( ) ; if ( nDepth < nMinDepth ) continue ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) { CTxDestination address ; if ( ! ExtractDestination ( txout . scriptPubKey , address ) || ! IsMine ( * pwalletMain , address ) ) continue ; tallyitem & item = mapTally [ address ] ; item . nAmount += txout . nValue ; item . nConf = min ( item . nConf , nDepth ) ; item . txids . push_back ( wtx . GetHash ( ) ) ; } } Array ret ; map < string , tallyitem > mapAccountTally ; BOOST_FOREACH ( const PAIRTYPE ( CBitcoinAddress , string ) & item , pwalletMain -> mapAddressBook ) { const CBitcoinAddress & address = item . first ; const string & strAccount = item . second ; map < CBitcoinAddress , tallyitem > :: iterator it = mapTally . find ( address ) ; if ( it == mapTally . end ( ) && ! fIncludeEmpty ) continue ; int64 nAmount = 0 ; int nConf = std :: numeric_limits < int > :: max ( ) ; if ( it != mapTally . end ( ) ) { nAmount = ( * it ) . second . nAmount ; nConf = ( * it ) . second . nConf ; } if ( fByAccounts ) { tallyitem & item = mapAccountTally [ strAccount ] ; item . nAmount += nAmount ; item . nConf = min ( item . nConf , nConf ) ; } else { Object obj ; obj . push_back ( Pair ( " address " , address . ToString ( ) ) ) ; obj . push_back ( Pair ( " account " , strAccount ) ) ; obj . push_back ( Pair ( " amount " , ValueFromAmount ( nAmount ) ) ) ; obj . push_back ( Pair ( " confirmations " , ( nConf == std :: numeric_limits < int > :: max ( ) ? 0 : nConf ) ) ) ; Array transactions ; if ( it != mapTally . end ( ) ) { BOOST_FOREACH ( const uint256 & item , ( * it ) . second . txids ) { transactions . push_back ( item . GetHex ( ) ) ; } } obj . push_back ( Pair ( " txids " , transactions ) ) ; ret . push_back ( obj ) ; } } if ( fByAccounts ) { for ( map < string , tallyitem > :: iterator it = mapAccountTally . begin ( ) ; it != mapAccountTally . end ( ) ; ++ it ) { int64 nAmount = ( * it ) . second . nAmount ; int nConf = ( * it ) . second . nConf ; Object obj ; obj . push_back ( Pair ( " account " , ( * it ) . first ) ) ; obj . push_back ( Pair ( " amount " , ValueFromAmount ( nAmount ) ) ) ; obj . push_back ( Pair ( " confirmations " , ( nConf == std :: numeric_limits < int > :: max ( ) ? 0 : nConf ) ) ) ; ret . push_back ( obj ) ; } } return ret ; } Value listreceivedbyaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " listreceivedbyaddress ▁ [ minconf = 1 ] ▁ [ includeempty = false ] \ n " " [ minconf ] ▁ is ▁ the ▁ minimum ▁ number ▁ of ▁ confirmations ▁ before ▁ payments ▁ are ▁ included . \ n " " [ includeempty ] ▁ whether ▁ to ▁ include ▁ addresses ▁ that ▁ haven ' t ▁ received ▁ any ▁ payments . \n " " Returns ▁ an ▁ array ▁ of ▁ objects ▁ containing : \n " " ▁ ▁ \ " address\ " ▁ : ▁ receiving ▁ address \n " " ▁ ▁ \ " account\ " ▁ : ▁ the ▁ account ▁ of ▁ the ▁ receiving ▁ address \n " " ▁ ▁ \ " amount\ " ▁ : ▁ total ▁ amount ▁ received ▁ by ▁ the ▁ address \n " " ▁ ▁ \ " confirmations\ " ▁ : ▁ number ▁ of ▁ confirmations ▁ of ▁ the ▁ most ▁ recent ▁ transaction ▁ included \n " " ▁ ▁ \ " txids\ " ▁ : ▁ list ▁ of ▁ transactions ▁ with ▁ outputs ▁ to ▁ the ▁ address \n " ) ; return ListReceived ( params , false ) ; } Value listreceivedbyaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " listreceivedbyaccount ▁ [ minconf = 1 ] ▁ [ includeempty = false ] \n " " [ minconf ] ▁ is ▁ the ▁ minimum ▁ number ▁ of ▁ confirmations ▁ before ▁ payments ▁ are ▁ included . \n " " [ includeempty ] ▁ whether ▁ to ▁ include ▁ accounts ▁ that ▁ haven ' t ▁ received ▁ any ▁ payments . \ n " " Returns ▁ an ▁ array ▁ of ▁ objects ▁ containing : \ n " " ▁ ▁ \ " account\ " ▁ : ▁ the ▁ account ▁ of ▁ the ▁ receiving ▁ addresses \ n " " ▁ ▁ \ " amount\ " ▁ : ▁ total ▁ amount ▁ received ▁ by ▁ addresses ▁ with ▁ this ▁ account \ n " " ▁ ▁ \ " confirmations\ " ▁ : ▁ number ▁ of ▁ confirmations ▁ of ▁ the ▁ most ▁ recent ▁ transaction ▁ included " ) ; return ListReceived ( params , true ) ; } static void MaybePushAddress ( Object & entry , const CTxDestination & dest ) { CBitcoinAddress addr ; if ( addr . Set ( dest ) ) entry . push_back ( Pair ( " address " , addr . ToString ( ) ) ) ; } void ListTransactions ( const CWalletTx & wtx , const string & strAccount , int nMinDepth , bool fLong , Array & ret ) { int64 nFee ; string strSentAccount ; list < pair < CTxDestination , int64 > > listReceived ; list < pair < CTxDestination , int64 > > listSent ; wtx . GetAmounts ( listReceived , listSent , nFee , strSentAccount ) ; bool fAllAccounts = ( strAccount == string ( " * " ) ) ; if ( ! wtx . IsCoinStake ( ) && ( ! listSent . empty ( ) || nFee != 0 ) && ( fAllAccounts || strAccount == strSentAccount ) ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & s , listSent ) { Object entry ; entry . push_back ( Pair ( " account " , strSentAccount ) ) ; MaybePushAddress ( entry , s . first ) ; entry . push_back ( Pair ( " category " , " send " ) ) ; entry . push_back ( Pair ( " amount " , ValueFromAmount ( - s . second ) ) ) ; entry . push_back ( Pair ( " fee " , ValueFromAmount ( - nFee ) ) ) ; if ( fLong ) WalletTxToJSON ( wtx , entry ) ; ret . push_back ( entry ) ; } } if ( listReceived . size ( ) > 0 && wtx . GetDepthInMainChain ( ) >= nMinDepth ) { bool stop = false ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listReceived ) { string account ; if ( pwalletMain -> mapAddressBook . count ( r . first ) ) account = pwalletMain -> mapAddressBook [ r . first ] ; if ( fAllAccounts || ( account == strAccount ) ) { Object entry ; entry . push_back ( Pair ( " account " , account ) ) ; MaybePushAddress ( entry , r . first ) ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) ) { if ( wtx . GetDepthInMainChain ( ) < 1 ) entry . push_back ( Pair ( " category " , " orphan " ) ) ; else if ( wtx . GetBlocksToMaturity ( ) > 0 ) entry . push_back ( Pair ( " category " , " immature " ) ) ; else if ( wtx . IsCoinStake ( ) ) entry . push_back ( Pair ( " category " , " stake " ) ) ; else entry . push_back ( Pair ( " category " , " generate " ) ) ; } else { entry . push_back ( Pair ( " category " , " receive " ) ) ; } if ( ! wtx . IsCoinStake ( ) ) entry . push_back ( Pair ( " amount " , ValueFromAmount ( r . second ) ) ) ; else { entry . push_back ( Pair ( " amount " , ValueFromAmount ( - nFee ) ) ) ; stop = true ; } if ( fLong ) WalletTxToJSON ( wtx , entry ) ; ret . push_back ( entry ) ; } if ( stop ) break ; } } } void AcentryToJSON ( const CAccountingEntry & acentry , const string & strAccount , Array & ret ) { bool fAllAccounts = ( strAccount == string ( " * " ) ) ; if ( fAllAccounts || acentry . strAccount == strAccount ) { Object entry ; entry . push_back ( Pair ( " account " , acentry . strAccount ) ) ; entry . push_back ( Pair ( " category " , " move " ) ) ; entry . push_back ( Pair ( " time " , ( boost :: int64_t ) acentry . nTime ) ) ; entry . push_back ( Pair ( " amount " , ValueFromAmount ( acentry . nCreditDebit ) ) ) ; entry . push_back ( Pair ( " otheraccount " , acentry . strOtherAccount ) ) ; entry . push_back ( Pair ( " comment " , acentry . strComment ) ) ; ret . push_back ( entry ) ; } } Value listtransactions ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 3 ) throw runtime_error ( " listtransactions ▁ [ account ] ▁ [ count = 10 ] ▁ [ from = 0 ] \ n " " Returns ▁ up ▁ to ▁ [ count ] ▁ most ▁ recent ▁ transactions ▁ skipping ▁ the ▁ first ▁ [ from ] ▁ transactions ▁ for ▁ account ▁ [ account ] . " ) ; string strAccount = " * " ; if ( params . size ( ) > 0 ) strAccount = params [ 0 ] . get_str ( ) ; int nCount = 10 ; if ( params . size ( ) > 1 ) nCount = params [ 1 ] . get_int ( ) ; int nFrom = 0 ; if ( params . size ( ) > 2 ) nFrom = params [ 2 ] . get_int ( ) ; if ( nCount < 0 ) throw JSONRPCError ( RPC_INVALID_PARAMETER , " Negative ▁ count " ) ; if ( nFrom < 0 ) throw JSONRPCError ( RPC_INVALID_PARAMETER , " Negative ▁ from " ) ; Array ret ; std :: list < CAccountingEntry > acentries ; CWallet :: TxItems txOrdered = pwalletMain -> OrderedTxItems ( acentries , strAccount ) ; for ( CWallet :: TxItems :: reverse_iterator it = txOrdered . rbegin ( ) ; it != txOrdered . rend ( ) ; ++ it ) { CWalletTx * const pwtx = ( * it ) . second . first ; if ( pwtx != 0 ) ListTransactions ( * pwtx , strAccount , 0 , true , ret ) ; CAccountingEntry * const pacentry = ( * it ) . second . second ; if ( pacentry != 0 ) AcentryToJSON ( * pacentry , strAccount , ret ) ; if ( ( int ) ret . size ( ) >= ( nCount + nFrom ) ) break ; } if ( nFrom > ( int ) ret . size ( ) ) nFrom = ret . size ( ) ; if ( ( nFrom + nCount ) > ( int ) ret . size ( ) ) nCount = ret . size ( ) - nFrom ; Array :: iterator first = ret . begin ( ) ; std :: advance ( first , nFrom ) ; Array :: iterator last = ret . begin ( ) ; std :: advance ( last , nFrom + nCount ) ; if ( last != ret . end ( ) ) ret . erase ( last , ret . end ( ) ) ; if ( first != ret . begin ( ) ) ret . erase ( ret . begin ( ) , first ) ; std :: reverse ( ret . begin ( ) , ret . end ( ) ) ; return ret ; } Value listaccounts ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 1 ) throw runtime_error ( " listaccounts ▁ [ minconf = 1 ] \ n " " Returns ▁ Object ▁ that ▁ has ▁ account ▁ names ▁ as ▁ keys , ▁ account ▁ balances ▁ as ▁ values . " ) ; int nMinDepth = 1 ; if ( params . size ( ) > 0 ) nMinDepth = params [ 0 ] . get_int ( ) ; map < string , int64 > mapAccountBalances ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , string ) & entry , pwalletMain -> mapAddressBook ) { if ( IsMine ( * pwalletMain , entry . first ) ) mapAccountBalances [ entry . second ] = 0 ; } for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; int64 nFee ; string strSentAccount ; list < pair < CTxDestination , int64 > > listReceived ; list < pair < CTxDestination , int64 > > listSent ; wtx . GetAmounts ( listReceived , listSent , nFee , strSentAccount ) ; mapAccountBalances [ strSentAccount ] -= nFee ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & s , listSent ) mapAccountBalances [ strSentAccount ] -= s . second ; if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listReceived ) if ( pwalletMain -> mapAddressBook . count ( r . first ) ) mapAccountBalances [ pwalletMain -> mapAddressBook [ r . first ] ] += r . second ; else mapAccountBalances [ " " ] += r . second ; } } list < CAccountingEntry > acentries ; CWalletDB ( pwalletMain -> strWalletFile ) . ListAccountCreditDebit ( " * " , acentries ) ; BOOST_FOREACH ( const CAccountingEntry & entry , acentries ) mapAccountBalances [ entry . strAccount ] += entry . nCreditDebit ; Object ret ; BOOST_FOREACH ( const PAIRTYPE ( string , int64 ) & accountBalance , mapAccountBalances ) { ret . push_back ( Pair ( accountBalance . first , ValueFromAmount ( accountBalance . second ) ) ) ; } return ret ; } Value listsinceblock ( const Array & params , bool fHelp ) { if ( fHelp ) throw runtime_error ( " listsinceblock ▁ [ blockhash ] ▁ [ target - confirmations ] \ n " " Get ▁ all ▁ transactions ▁ in ▁ blocks ▁ since ▁ block ▁ [ blockhash ] , ▁ or ▁ all ▁ transactions ▁ if ▁ omitted " ) ; CBlockIndex * pindex = NULL ; int target_confirms = 1 ; if ( params . size ( ) > 0 ) { uint256 blockId = 0 ; blockId . SetHex ( params [ 0 ] . get_str ( ) ) ; pindex = CBlockLocator ( blockId ) . GetBlockIndex ( ) ; } if ( params . size ( ) > 1 ) { target_confirms = params [ 1 ] . get_int ( ) ; if ( target_confirms < 1 ) throw JSONRPCError ( RPC_INVALID_PARAMETER , " Invalid ▁ parameter " ) ; } int depth = pindex ? ( 1 + nBestHeight - pindex -> nHeight ) : - 1 ; Array transactions ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; it ++ ) { CWalletTx tx = ( * it ) . second ; if ( depth == - 1 || tx . GetDepthInMainChain ( ) < depth ) ListTransactions ( tx , " * " , 0 , true , transactions ) ; } uint256 lastblock ; if ( target_confirms == 1 ) { lastblock = hashBestChain ; } else { int target_height = pindexBest -> nHeight + 1 - target_confirms ; CBlockIndex * block ; for ( block = pindexBest ; block && block -> nHeight > target_height ; block = block -> pprev ) { } lastblock = block ? block -> GetBlockHash ( ) : 0 ; } Object ret ; ret . push_back ( Pair ( " transactions " , transactions ) ) ; ret . push_back ( Pair ( " lastblock " , lastblock . GetHex ( ) ) ) ; return ret ; } Value gettransaction ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " gettransaction ▁ < txid > \ n " " Get ▁ detailed ▁ information ▁ about ▁ in - wallet ▁ transaction ▁ < txid > " ) ; uint256 hash ; hash . SetHex ( params [ 0 ] . get_str ( ) ) ; Object entry ; if ( ! pwalletMain -> mapWallet . count ( hash ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ or ▁ non - wallet ▁ transaction ▁ id " ) ; const CWalletTx & wtx = pwalletMain -> mapWallet [ hash ] ; int64 nCredit = wtx . GetCredit ( ) ; int64 nDebit = wtx . GetDebit ( ) ; int64 nNet = nCredit - nDebit ; int64 nFee = ( wtx . IsFromMe ( ) ? wtx . GetValueOut ( ) - nDebit : 0 ) ; entry . push_back ( Pair ( " amount " , ValueFromAmount ( nNet - nFee ) ) ) ; if ( wtx . IsFromMe ( ) ) entry . push_back ( Pair ( " fee " , ValueFromAmount ( nFee ) ) ) ; WalletTxToJSON ( wtx , entry ) ; Array details ; ListTransactions ( wtx , " * " , 0 , false , details ) ; entry . push_back ( Pair ( " details " , details ) ) ; return entry ; } Value backupwallet ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " backupwallet ▁ < destination > \ n " " Safely ▁ copies ▁ wallet . dat ▁ to ▁ destination , ▁ which ▁ can ▁ be ▁ a ▁ directory ▁ or ▁ a ▁ path ▁ with ▁ filename . " ) ; string strDest = params [ 0 ] . get_str ( ) ; if ( ! BackupWallet ( * pwalletMain , strDest ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Error : ▁ Wallet ▁ backup ▁ failed ! " ) ; return Value :: null ; } Value keypoolrefill ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 0 ) throw runtime_error ( " keypoolrefill \ n " " Fills ▁ the ▁ keypool . " + HelpRequiringPassphrase ( ) ) ; EnsureWalletIsUnlocked ( ) ; pwalletMain -> TopUpKeyPool ( ) ; if ( pwalletMain -> GetKeyPoolSize ( ) < GetArg ( " - keypool " , 100 ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Error ▁ refreshing ▁ keypool . " ) ; return Value :: null ; } void ThreadTopUpKeyPool ( void * parg ) { RenameThread ( " iloveyoucoins - key - top " ) ; pwalletMain -> TopUpKeyPool ( ) ; } void ThreadCleanWalletPassphrase ( void * parg ) { RenameThread ( " iloveyoucoins - lock - wa " ) ; int64 nMyWakeTime = GetTimeMillis ( ) + * ( ( int64 * ) parg ) * 1000 ; ENTER_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; if ( nWalletUnlockTime == 0 ) { nWalletUnlockTime = nMyWakeTime ; do { if ( nWalletUnlockTime == 0 ) break ; int64 nToSleep = nWalletUnlockTime - GetTimeMillis ( ) ; if ( nToSleep <= 0 ) break ; LEAVE_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; MilliSleep ( nToSleep ) ; ENTER_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; } while ( 1 ) ; if ( nWalletUnlockTime ) { nWalletUnlockTime = 0 ; pwalletMain -> Lock ( ) ; } } else { if ( nWalletUnlockTime < nMyWakeTime ) nWalletUnlockTime = nMyWakeTime ; } LEAVE_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; delete ( int64 * ) parg ; } Value walletpassphrase ( const Array & params , bool fHelp ) { if ( pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) < 2 || params . size ( ) > 3 ) ) throw runtime_error ( " walletpassphrase ▁ < passphrase > ▁ < timeout > ▁ [ stakingonly ] \ n " " Stores ▁ the ▁ wallet ▁ decryption ▁ key ▁ in ▁ memory ▁ for ▁ < timeout > ▁ seconds . \ n " " if ▁ [ stakingonly ] ▁ is ▁ true ▁ sending ▁ functions ▁ are ▁ disabled . " ) ; if ( fHelp ) return true ; if ( ! pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ unencrypted ▁ wallet , ▁ but ▁ walletpassphrase ▁ was ▁ called . " ) ; if ( ! pwalletMain -> IsLocked ( ) ) throw JSONRPCError ( RPC_WALLET_ALREADY_UNLOCKED , " Error : ▁ Wallet ▁ is ▁ already ▁ unlocked . " ) ; SecureString strWalletPass ; strWalletPass . reserve ( 100 ) ; strWalletPass = params [ 0 ] . get_str ( ) . c_str ( ) ; if ( strWalletPass . length ( ) > 0 ) { if ( ! pwalletMain -> Unlock ( strWalletPass ) ) throw JSONRPCError ( RPC_WALLET_PASSPHRASE_INCORRECT , " Error : ▁ The ▁ wallet ▁ passphrase ▁ entered ▁ was ▁ incorrect . " ) ; } else throw runtime_error ( " walletpassphrase ▁ < passphrase > ▁ < timeout > \ n " " Stores ▁ the ▁ wallet ▁ decryption ▁ key ▁ in ▁ memory ▁ for ▁ < timeout > ▁ seconds . " ) ; NewThread ( ThreadTopUpKeyPool , NULL ) ; int64 * pnSleepTime = new int64 ( params [ 1 ] . get_int64 ( ) ) ; NewThread ( ThreadCleanWalletPassphrase , pnSleepTime ) ; if ( params . size ( ) > 2 ) fWalletUnlockStakingOnly = params [ 2 ] . get_bool ( ) ; else fWalletUnlockStakingOnly = false ; return Value :: null ; } Value walletpassphrasechange ( const Array & params , bool fHelp ) { if ( pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) != 2 ) ) throw runtime_error ( " walletpassphrasechange ▁ < oldpassphrase > ▁ < newpassphrase > \ n " " Changes ▁ the ▁ wallet ▁ passphrase ▁ from ▁ < oldpassphrase > ▁ to ▁ < newpassphrase > . " ) ; if ( fHelp ) return true ; if ( ! pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ unencrypted ▁ wallet , ▁ but ▁ walletpassphrasechange ▁ was ▁ called . " ) ; SecureString strOldWalletPass ; strOldWalletPass . reserve ( 100 ) ; strOldWalletPass = params [ 0 ] . get_str ( ) . c_str ( ) ; SecureString strNewWalletPass ; strNewWalletPass . reserve ( 100 ) ; strNewWalletPass = params [ 1 ] . get_str ( ) . c_str ( ) ; if ( strOldWalletPass . length ( ) < 1 || strNewWalletPass . length ( ) < 1 ) throw runtime_error ( " walletpassphrasechange ▁ < oldpassphrase > ▁ < newpassphrase > \ n " " Changes ▁ the ▁ wallet ▁ passphrase ▁ from ▁ < oldpassphrase > ▁ to ▁ < newpassphrase > . " ) ; if ( ! pwalletMain -> ChangeWalletPassphrase ( strOldWalletPass , strNewWalletPass ) ) throw JSONRPCError ( RPC_WALLET_PASSPHRASE_INCORRECT , " Error : ▁ The ▁ wallet ▁ passphrase ▁ entered ▁ was ▁ incorrect . " ) ; return Value :: null ; } Value walletlock ( const Array & params , bool fHelp ) { if ( pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) != 0 ) ) throw runtime_error ( " walletlock \ n " " Removes ▁ the ▁ wallet ▁ encryption ▁ key ▁ from ▁ memory , ▁ locking ▁ the ▁ wallet . \ n " " After ▁ calling ▁ this ▁ method , ▁ you ▁ will ▁ need ▁ to ▁ call ▁ walletpassphrase ▁ again \ n " " before ▁ being ▁ able ▁ to ▁ call ▁ any ▁ methods ▁ which ▁ require ▁ the ▁ wallet ▁ to ▁ be ▁ unlocked . " ) ; if ( fHelp ) return true ; if ( ! pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ unencrypted ▁ wallet , ▁ but ▁ walletlock ▁ was ▁ called . " ) ; { LOCK ( cs_nWalletUnlockTime ) ; pwalletMain -> Lock ( ) ; nWalletUnlockTime = 0 ; } return Value :: null ; } Value encryptwallet ( const Array & params , bool fHelp ) { if ( ! pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) != 1 ) ) throw runtime_error ( " encryptwallet ▁ < passphrase > \ n " " Encrypts ▁ the ▁ wallet ▁ with ▁ < passphrase > . " ) ; if ( fHelp ) return true ; if ( pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ encrypted ▁ wallet , ▁ but ▁ encryptwallet ▁ was ▁ called . " ) ; SecureString strWalletPass ; strWalletPass . reserve ( 100 ) ; strWalletPass = params [ 0 ] . get_str ( ) . c_str ( ) ; if ( strWalletPass . length ( ) < 1 ) throw runtime_error ( " encryptwallet ▁ < passphrase > \ n " " Encrypts ▁ the ▁ wallet ▁ with ▁ < passphrase > . " ) ; if ( ! pwalletMain -> EncryptWallet ( strWalletPass ) ) throw JSONRPCError ( RPC_WALLET_ENCRYPTION_FAILED , " Error : ▁ Failed ▁ to ▁ encrypt ▁ the ▁ wallet . " ) ; StartShutdown ( ) ; return " wallet ▁ encrypted ; ▁ ILoveYouCoins ▁ server ▁ stopping , ▁ restart ▁ to ▁ run ▁ with ▁ encrypted ▁ wallet . ▁ The ▁ keypool ▁ has ▁ been ▁ flushed , ▁ you ▁ need ▁ to ▁ make ▁ a ▁ new ▁ backup . " ; } class DescribeAddressVisitor : public boost :: static_visitor < Object > { public : Object operator ( ) ( const CNoDestination & dest ) const { return Object ( ) ; } Object operator ( ) ( const CKeyID & keyID ) const { Object obj ; CPubKey vchPubKey ; pwalletMain -> GetPubKey ( keyID , vchPubKey ) ; obj . push_back ( Pair ( " isscript " , false ) ) ; obj . push_back ( Pair ( " pubkey " , HexStr ( vchPubKey ) ) ) ; obj . push_back ( Pair ( " iscompressed " , vchPubKey . IsCompressed ( ) ) ) ; return obj ; } Object operator ( ) ( const CScriptID & scriptID ) const { Object obj ; obj . push_back ( Pair ( " isscript " , true ) ) ; CScript subscript ; pwalletMain -> GetCScript ( scriptID , subscript ) ; std :: vector < CTxDestination > addresses ; txnouttype whichType ; int nRequired ; ExtractDestinations ( subscript , whichType , addresses , nRequired ) ; obj . push_back ( Pair ( " script " , GetTxnOutputType ( whichType ) ) ) ; Array a ; BOOST_FOREACH ( const CTxDestination & addr , addresses ) a . push_back ( CBitcoinAddress ( addr ) . ToString ( ) ) ; obj . push_back ( Pair ( " addresses " , a ) ) ; if ( whichType == TX_MULTISIG ) obj . push_back ( Pair ( " sigsrequired " , nRequired ) ) ; return obj ; } } ; Value validateaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " validateaddress ▁ < iloveyoucoinsaddress > \ n " " Return ▁ information ▁ about ▁ < iloveyoucoinsaddress > . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; bool isValid = address . IsValid ( ) ; Object ret ; ret . push_back ( Pair ( " isvalid " , isValid ) ) ; if ( isValid ) { CTxDestination dest = address . Get ( ) ; string currentAddress = address . ToString ( ) ; ret . push_back ( Pair ( " address " , currentAddress ) ) ; bool fMine = pwalletMain ? IsMine ( * pwalletMain , dest ) : false ; ret . push_back ( Pair ( " ismine " , fMine ) ) ; if ( fMine ) { Object detail = boost :: apply_visitor ( DescribeAddressVisitor ( ) , dest ) ; ret . insert ( ret . end ( ) , detail . begin ( ) , detail . end ( ) ) ; } if ( pwalletMain && pwalletMain -> mapAddressBook . count ( dest ) ) ret . push_back ( Pair ( " account " , pwalletMain -> mapAddressBook [ dest ] ) ) ; } return ret ; } Value reservebalance ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " reservebalance ▁ [ < reserve > ▁ [ amount ] ] \ n " " < reserve > ▁ is ▁ true ▁ or ▁ false ▁ to ▁ turn ▁ balance ▁ reserve ▁ on ▁ or ▁ off . \ n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ rounded ▁ to ▁ cent . \ n " " Set ▁ reserve ▁ amount ▁ not ▁ participating ▁ in ▁ network ▁ protection . \ n " " If ▁ no ▁ parameters ▁ provided ▁ current ▁ setting ▁ is ▁ printed . \ n " ) ; if ( params . size ( ) > 0 ) { bool fReserve = params [ 0 ] . get_bool ( ) ; if ( fReserve ) { if ( params . size ( ) == 1 ) throw runtime_error ( " must ▁ provide ▁ amount ▁ to ▁ reserve ▁ balance . \ n " ) ; int64 nAmount = AmountFromValue ( params [ 1 ] ) ; nAmount = ( nAmount / CENT ) * CENT ; if ( nAmount < 0 ) throw runtime_error ( " amount ▁ cannot ▁ be ▁ negative . \ n " ) ; nReserveBalance = nAmount ; } else { if ( params . size ( ) > 1 ) throw runtime_error ( " cannot ▁ specify ▁ amount ▁ to ▁ turn ▁ off ▁ reserve . \ n " ) ; nReserveBalance = 0 ; } } Object result ; result . push_back ( Pair ( " reserve " , ( nReserveBalance > 0 ) ) ) ; result . push_back ( Pair ( " amount " , ValueFromAmount ( nReserveBalance ) ) ) ; return result ; } Value getinterest ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " getinterest ▁ [ start ] ▁ [ end ] \ n " " Both ▁ [ start ] ▁ and ▁ [ end ] ▁ are ▁ inclusive ▁ and ▁ in ▁ the ▁ form ▁ of ▁ UNIX ▁ timestamps . " ) ; unsigned int nTimeStart = 0 ; unsigned int nTimeEnd = - 1 ; if ( params . size ( ) >= 1 ) nTimeStart = ( unsigned int ) ( params [ 0 ] . get_int ( ) ) ; if ( params . size ( ) == 2 ) nTimeEnd = ( unsigned int ) ( params [ 1 ] . get_int ( ) ) ; int64 nInterest = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . IsCoinStake ( ) || wtx . nTime < nTimeStart || wtx . nTime > nTimeEnd ) continue ; int64 nDebit = wtx . GetDebit ( ) ; int64 nCredit = wtx . GetCredit ( ) ; if ( nDebit <= 0 || nCredit <= 0 || nDebit >= nCredit ) continue ; else nInterest += nCredit - nDebit ; } return ValueFromAmount ( nInterest ) ; } Value lockunspent ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " lockunspent ▁ unlock ? ▁ [ array - of - Objects ] \ n " " Updates ▁ list ▁ of ▁ temporarily ▁ unspendable ▁ outputs . " ) ; if ( params . size ( ) == 1 ) RPCTypeCheck ( params , list_of ( bool_type ) ) ; else RPCTypeCheck ( params , list_of ( bool_type ) ( array_type ) ) ; bool fUnlock = params [ 0 ] . get_bool ( ) ; if ( params . size ( ) == 1 ) { if ( fUnlock ) pwalletMain -> UnlockAllCoins ( ) ; return true ; } Array outputs = params [ 1 ] . get_array ( ) ; BOOST_FOREACH ( Value & output , outputs ) { if ( output . type ( ) != obj_type ) throw JSONRPCError ( - 8 , " Invalid ▁ parameter , ▁ expected ▁ object " ) ; const Object & o = output . get_obj ( ) ; RPCTypeCheck ( o , map_list_of ( " txid " , str_type ) ( " vout " , int_type ) ) ; string txid = find_value ( o , " txid " ) . get_str ( ) ; if ( ! IsHex ( txid ) ) throw JSONRPCError ( - 8 , " Invalid ▁ parameter , ▁ expected ▁ hex ▁ txid " ) ; int nOutput = find_value ( o , " vout " ) . get_int ( ) ; if ( nOutput < 0 ) throw JSONRPCError ( - 8 , " Invalid ▁ parameter , ▁ vout ▁ must ▁ be ▁ positive " ) ; COutPoint outpt ( uint256 ( txid ) , nOutput ) ; if ( fUnlock ) pwalletMain -> UnlockCoin ( outpt ) ; else pwalletMain -> LockCoin ( outpt ) ; } return true ; } Value listlockunspent ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 0 ) throw runtime_error ( " listlockunspent \ n " " Returns ▁ list ▁ of ▁ temporarily ▁ unspendable ▁ outputs . " ) ; vector < COutPoint > vOutpts ; pwalletMain -> ListLockedCoins ( vOutpts ) ; Array ret ; BOOST_FOREACH ( COutPoint & outpt , vOutpts ) { Object o ; o . push_back ( Pair ( " txid " , outpt . hash . GetHex ( ) ) ) ; o . push_back ( Pair ( " vout " , ( int ) outpt . n ) ) ; ret . push_back ( o ) ; } return ret ; } </DOCUMENT>
