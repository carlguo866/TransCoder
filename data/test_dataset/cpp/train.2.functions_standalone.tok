int main ( ) { :: input_event buf [ 32 ] ; ( void ) buf ; return 0 ; }
static bool shouldUseCoreText ( UChar * buffer , unsigned bufferLength , const SimpleFontData * fontData ) { if ( fontData -> platformData ( ) . widthVariant ( ) != RegularWidth || fontData -> hasVerticalGlyphs ( ) ) { for ( unsigned i = 0 ; i < bufferLength ; ++ i ) { if ( ! Font :: isCJKIdeograph ( buffer [ i ] ) ) return true ; } } return false ; }
void saveFile ( std :: string filename , std :: vector < std :: string > lines ) { std :: ofstream save ; save . open ( filename . c_str ( ) ) ; for ( int i = 0 ; i < lines . size ( ) ; i ++ ) { save << lines [ i ] << std :: endl ; } save . close ( ) ; }
int main ( ) { ofstream fout ( " ride . out " ) ; ifstream fin ( " ride . in " ) ; string a , b ; fin >> a >> b ; int anum = 1 , bnum = 1 ; for ( char c : a ) anum *= c - ' A ' + 1 ; for ( char c : b ) bnum *= c - ' A ' + 1 ; if ( anum % 47 == bnum % 47 ) fout << " GO " << endl ; else fout << " STAY " << endl ; return 0 ; }
void heapsort ( Comparable * A [ ] , int n ) { std :: cout << " Getting ▁ started ▁ with ▁ array : " << std :: endl ; for ( int j = 0 ; j < n ; j ++ ) std :: cout << * A [ j ] << " ▁ " ; std :: cout << std :: endl ; MaxHeap H ( A , n , n ) ; std :: cout << " Now , ▁ ready ▁ to ▁ unpack ▁ the ▁ heap " << std :: endl ; for ( int i = 0 ; i < n ; i ++ ) H . removemax ( ) ; }
bool sorttest ( int array [ ] , int n , int threshold ) { Comparable * A [ n ] ; int i ; cout << " We ▁ came ▁ in ▁ with ▁ array : " << endl ; for ( i = 0 ; i < n ; i ++ ) std :: cout << array [ i ] << " ▁ " ; std :: cout << std :: endl ; for ( i = 0 ; i < n ; ++ i ) { A [ i ] = new Int ( array [ i ] ) ; } cout << " We ▁ are ▁ going ▁ to ▁ call ▁ Heapsort ▁ with ▁ this ▁ array : " << endl ; for ( i = 0 ; i < n ; i ++ ) std :: cout << A [ i ] << " ▁ " ; std :: cout << std :: endl ; heapsort ( A , n ) ; if ( ! checkorder ( A , n ) ) return false ; for ( i = 0 ; i < n ; ++ i ) { delete A [ i ] ; } for ( i = 0 ; i < n ; ++ i ) { A [ i ] = new KVPair ( array [ i ] , & array [ i ] ) ; } if ( ! checkorder ( A , n ) ) return false ; for ( i = 0 ; i < n ; ++ i ) { delete A [ i ] ; } delete [ ] array ; return true ; }
DEFINE_TRACE ( HTMLContentElement ) { visitor -> trace ( m_filter ) ; InsertionPoint :: trace ( visitor ) ; }
static inline bool includesDisallowedPseudoClass ( const CSSSelector & selector ) { if ( selector . pseudoType ( ) == CSSSelector :: PseudoNot ) { const CSSSelector * subSelector = selector . selectorList ( ) -> first ( ) ; return subSelector -> match ( ) == CSSSelector :: PseudoClass ; } return selector . match ( ) == CSSSelector :: PseudoClass ; }
selector = m_selectorList . next ( * selector ) ) { if ( ! selector -> isCompound ( ) ) return false ; for ( const CSSSelector * subSelector = selector ; subSelector ; subSelector = subSelector -> tagHistory ( ) ) { if ( includesDisallowedPseudoClass ( * subSelector ) ) return false ; } }
protected : void testInit ( ) { CPPUNIT_ASSERT ( iValue :: hasTypeString ( Values :: Bool :: id ) ) ; }
void testAssign ( ) { oValue b ( true ) ; CPPUNIT_ASSERT ( b -> getID ( ) == Values :: Bool :: id ) ; }
void testGet ( ) { CPPUNIT_ASSERT ( oValue ( true ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ! ( ( Values :: Bool * ) oValue ( false ) . get ( ) ) -> output ( ) ) ; }
void testSetClear ( ) { oValue v ( true ) ; v -> clear ( ) ; CPPUNIT_ASSERT ( ! ( v >> bool ( ) ) ) ; Values :: Bool * b = ( Values :: Bool * ) v . get ( ) ; b -> set ( true ) ; CPPUNIT_ASSERT ( v >> bool ( ) ) ; }
void testOperators ( ) { CPPUNIT_ASSERT ( ( oValue ( true ) == oValue ( true ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( true ) != oValue ( false ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( true ) && oValue ( true ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( false ) || oValue ( true ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( ! oValue ( true ) == oValue ( false ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( ) << true ) -> getID ( ) == Values :: Bool :: id ) ; CPPUNIT_ASSERT ( ( oValue ( false ) >> bool ( ) ) == false ) ; }
template < class Iter , class Sent = Iter > void test_iter ( Iter first , Sent last ) { RANGES_ENSURE ( first != last ) ; auto rng = ranges :: make_iterator_range ( first , last ) ; auto res = ranges :: minmax ( rng ) ; for ( Iter i = first ; i != last ; ++ i ) { CHECK ( ! ( * i < res . first ) ) ; CHECK ( ! ( res . second < * i ) ) ; } }
template < class Iter , class Sent = Iter > void test_iter ( unsigned N ) { RANGES_ENSURE ( N > 0 ) ; std :: unique_ptr < int [ ] > a { new int [ N ] } ; std :: iota ( a . get ( ) , a . get ( ) + N , 0 ) ; std :: shuffle ( a . get ( ) , a . get ( ) + N , gen ) ; test_iter ( Iter ( a . get ( ) ) , Sent ( a . get ( ) + N ) ) ; }
template < class Iter , class Sent = Iter > void test_iter ( ) { test_iter < Iter , Sent > ( 1 ) ; test_iter < Iter , Sent > ( 2 ) ; test_iter < Iter , Sent > ( 3 ) ; test_iter < Iter , Sent > ( 10 ) ; test_iter < Iter , Sent > ( 1000 ) ; }
template < class Iter , class Sent = Iter > void test_iter_comp ( Iter first , Sent last ) { RANGES_ENSURE ( first != last ) ; typedef std :: greater < int > Compare ; Compare comp ; auto rng = ranges :: make_iterator_range ( first , last ) ; auto res = ranges :: minmax ( rng , comp ) ; for ( Iter i = first ; i != last ; ++ i ) { CHECK ( ! comp ( * i , res . first ) ) ; CHECK ( ! comp ( res . second , * i ) ) ; } }
template < class Iter , class Sent = Iter > void test_iter_comp ( unsigned N ) { RANGES_ENSURE ( N > 0 ) ; std :: unique_ptr < int [ ] > a { new int [ N ] } ; std :: iota ( a . get ( ) , a . get ( ) + N , 0 ) ; std :: shuffle ( a . get ( ) , a . get ( ) + N , gen ) ; test_iter_comp ( Iter ( a . get ( ) ) , Sent ( a . get ( ) + N ) ) ; }
template < class Iter , class Sent = Iter > void test_iter_comp ( ) { test_iter_comp < Iter , Sent > ( 1 ) ; test_iter_comp < Iter , Sent > ( 2 ) ; test_iter_comp < Iter , Sent > ( 3 ) ; test_iter_comp < Iter , Sent > ( 10 ) ; test_iter_comp < Iter , Sent > ( 1000 ) ; }
int main ( ) { test_iter < input_iterator < const int * > > ( ) ; test_iter < forward_iterator < const int * > > ( ) ; test_iter < bidirectional_iterator < const int * > > ( ) ; test_iter < random_access_iterator < const int * > > ( ) ; test_iter < const int * > ( ) ; test_iter < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < input_iterator < const int * > > ( ) ; test_iter < forward_iterator < const int * > > ( ) ; test_iter < bidirectional_iterator < const int * > > ( ) ; test_iter < random_access_iterator < const int * > > ( ) ; test_iter < const int * > ( ) ; test_iter < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < input_iterator < const int * > > ( ) ; test_iter_comp < forward_iterator < const int * > > ( ) ; test_iter_comp < bidirectional_iterator < const int * > > ( ) ; test_iter_comp < random_access_iterator < const int * > > ( ) ; test_iter_comp < const int * > ( ) ; test_iter_comp < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < input_iterator < const int * > > ( ) ; test_iter_comp < forward_iterator < const int * > > ( ) ; test_iter_comp < bidirectional_iterator < const int * > > ( ) ; test_iter_comp < random_access_iterator < const int * > > ( ) ; test_iter_comp < const int * > ( ) ; test_iter_comp < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; S s [ ] = { S { 1 , 0 } , S { 2 , 1 } , S { 3 , 2 } , S { 4 , 3 } , S { - 4 , 4 } , S { 40 , 5 } , S { - 4 , 6 } , S { 40 , 7 } , S { 7 , 8 } , S { 8 , 9 } , S { 9 , 10 } } ; auto res = ranges :: minmax ( s , std :: less < int > { } , & S :: value ) ; CHECK ( res . first . value == - 4 ) ; CHECK ( res . first . index == 4 ) ; CHECK ( res . second . value == 40 ) ; CHECK ( res . second . index == 7 ) ; return test_result ( ) ; }
template < class RngT > void do_test_iterator_range_impl ( const RngT & rng ) { BOOST_CHECK_EQUAL ( lexical_cast < int > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < int > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned int > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned int > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < short > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < short > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned short > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned short > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < long int > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < long int > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned long int > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned long int > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng . begin ( ) , rng . size ( ) ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng ) , 1.0 ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng . begin ( ) , rng . size ( ) ) , 1.0 ) ; BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng ) , 1.0L ) ; BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng . begin ( ) , rng . size ( ) ) , 1.0L ) ; BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: ulong_long_type > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: ulong_long_type > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: long_long_type > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: long_long_type > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; # elif defined ( BOOST_HAS_MS_INT64 ) BOOST_CHECK_EQUAL ( lexical_cast < unsigned __int64 > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned __int64 > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < __int64 > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < __int64 > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; }
template < class CharT > void test_it_range_using_any_chars ( CharT * one , CharT * eleven ) { typedef CharT test_char_type ; iterator_range < test_char_type * > rng1 ( one , one + 1 ) ; do_test_iterator_range_impl ( rng1 ) ; iterator_range < const test_char_type * > crng1 ( one , one + 1 ) ; do_test_iterator_range_impl ( crng1 ) ; iterator_range < test_char_type * > rng2 ( eleven , eleven + 1 ) ; do_test_iterator_range_impl ( rng2 ) ; iterator_range < const test_char_type * > crng2 ( eleven , eleven + 1 ) ; do_test_iterator_range_impl ( crng2 ) ; }
template < class CharT > void test_it_range_using_char ( CharT * one , CharT * eleven ) { typedef CharT test_char_type ; iterator_range < test_char_type * > rng1 ( one , one + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( rng1 ) , "1" ) ; iterator_range < const test_char_type * > crng1 ( one , one + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( crng1 ) , "1" ) ; iterator_range < test_char_type * > rng2 ( eleven , eleven + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( rng2 ) , "1" ) ; iterator_range < const test_char_type * > crng2 ( eleven , eleven + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( crng2 ) , "1" ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng1 ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng1 ) , 1.0 ) ; BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng1 ) , 1.0L ) ; BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( rng1 ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( crng2 ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( crng2 ) , 1.0 ) ; BOOST_CHECK_EQUAL ( lexical_cast < long double > ( crng2 ) , 1.0L ) ; BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( crng2 ) , 1 ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( rng1 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( crng1 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( rng2 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( crng2 ) == L " 1" ) ; && defined ( BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES ) typedef std :: basic_string < char16_t > my_char16_string ; BOOST_CHECK ( lexical_cast < my_char16_string > ( rng1 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( crng1 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( rng2 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( crng2 ) == u " 1" ) ; && defined ( BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES ) typedef std :: basic_string < char32_t > my_char32_string ; BOOST_CHECK ( lexical_cast < my_char32_string > ( rng1 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( crng1 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( rng2 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( crng2 ) == U " 1" ) ; }
void test_char_iterator_ranges ( ) { typedef char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; }
void test_unsigned_char_iterator_ranges ( ) { typedef unsigned char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; }
void test_signed_char_iterator_ranges ( ) { typedef signed char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; }
void test_wchar_iterator_ranges ( ) { typedef wchar_t test_char_type ; test_char_type data1 [ ] = L " 1" ; test_char_type data2 [ ] = L " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; BOOST_CHECK ( true ) ; }
void test_char16_iterator_ranges ( ) { typedef char16_t test_char_type ; test_char_type data1 [ ] = u " 1" ; test_char_type data2 [ ] = u " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; BOOST_CHECK ( true ) ; }
void test_char32_iterator_ranges ( ) { typedef char32_t test_char_type ; test_char_type data1 [ ] = U " 1" ; test_char_type data2 [ ] = U " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; BOOST_CHECK ( true ) ; }
bool LoadFile ( WbConfig config , KeyId cameraPosition , IplImage * * camImg , QString fileName , CvPoint2D32f * offset , bool unWarp ) { bool successful = true ; Collection camerasCollection ( CamerasCollection ( ) ) ; Collection cameraPositionsCollection ( CameraPositionsCollection ( ) ) ; camerasCollection . SetConfig ( config ) ; cameraPositionsCollection . SetConfig ( config ) ; const KeyId camPosId = cameraPosition ; LOG_INFO ( QObject :: tr ( " Camera ▁ position ▁ id : ▁ % 1" ) . arg ( camPosId ) ) ; const WbConfig camPosConfig = cameraPositionsCollection . ElementById ( camPosId ) ; if ( camPosConfig . IsNull ( ) ) successful = false ; CvMat * cameraMtx = cvCreateMat ( 3 , 3 , CV_32F ) ; CvMat * distortionCoeffs = cvCreateMat ( 5 , 1 , CV_32F ) ; CvMat * inverseCoeffs = cvCreateMat ( 5 , 1 , CV_32F ) ; CvMat * rot = cvCreateMat ( 3 , 3 , CV_32F ) ; CvMat * trans = cvCreateMat ( 1 , 3 , CV_32F ) ; if ( successful ) { const KeyId camId = camPosConfig . GetKeyValue ( CameraPositionSchema :: cameraIdKey ) . ToKeyId ( ) ; LOG_INFO ( QObject :: tr ( " Camera ▁ id : ▁ % 1" ) . arg ( camId ) ) ; WbConfig cameraConfig = camerasCollection . ElementById ( camId ) ; if ( cameraConfig . IsNull ( ) ) successful = false ; if ( successful ) { const WbConfig cameraIntrisicConfig ( cameraConfig . GetSubConfig ( CalibrationSchema :: schemaName ) ) ; if ( cameraIntrisicConfig . IsNull ( ) ) successful = false ; if ( successful ) { const bool calibrationWasSuccessful = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: calibrationSuccessfulKey ) . ToBool ( ) ; const bool cameraMtxValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: cameraMatrixKey ) . ToCvMat ( * cameraMtx ) ; const bool distortionCoeffsValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: distortionCoefficientsKey ) . ToCvMat ( * distortionCoeffs ) ; const bool inverseCoeffsValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: invDistortionCoefficientsKey ) . ToCvMat ( * inverseCoeffs ) ; successful = calibrationWasSuccessful && cameraMtxValid && distortionCoeffsValid && inverseCoeffsValid ; } const WbConfig cameraExtrisicConfig ( camPosConfig . GetSubConfig ( ExtrinsicCalibrationSchema :: schemaName ) ) ; if ( cameraExtrisicConfig . IsNull ( ) ) successful = false ; if ( successful ) { const bool rotMatValid = cameraExtrisicConfig . GetKeyValue ( ExtrinsicCalibrationSchema :: rotationMatrixKey ) . ToCvMat ( * rot ) ; const bool transValid = cameraExtrisicConfig . GetKeyValue ( ExtrinsicCalibrationSchema :: translationKey ) . ToCvMat ( * trans ) ; successful = rotMatValid && transValid ; } } } if ( successful ) { IplImage * imgGrey = cvLoadImage ( fileName . toAscii ( ) , CV_LOAD_IMAGE_GRAYSCALE ) ; if ( unWarp ) { * camImg = GroundPlaneUtility :: unwarpGroundPlane ( imgGrey , cameraMtx , distortionCoeffs , inverseCoeffs , rot , trans , offset ) ; } else { * camImg = cvCloneImage ( imgGrey ) ; } cvReleaseImage ( & imgGrey ) ; } cvReleaseMat ( & cameraMtx ) ; cvReleaseMat ( & distortionCoeffs ) ; cvReleaseMat ( & inverseCoeffs ) ; cvReleaseMat ( & rot ) ; cvReleaseMat ( & trans ) ; return successful ; }
bool CheckMappingIsComplete ( WbConfig config ) { bool allMapped = true ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; bool found = false ; LOG_INFO ( QObject :: tr ( " Checking ▁ mapping ▁ for ▁ % 1 . " ) . arg ( camPosId ) ) ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( ( camPosId == camera1Id ) || ( camPosId == camera2Id ) ) { found = true ; break ; } } if ( ! found ) { allMapped = false ; break ; } } return allMapped ; }
bool IsBase ( WbConfig config , KeyId camId ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; bool base = false ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camId == camera1Id ) { base = true ; break ; } } return base ; }
bool IsRef ( WbConfig config , KeyId camId ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; bool ref = false ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camId == camera2Id ) { ref = true ; break ; } } return ref ; }
bool CheckRootMapping ( WbConfig config , KeyId rootId ) { bool allMapped = true ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; if ( ( camPosId != rootId ) && IsRef ( config , camPosId ) ) { LOG_INFO ( QObject :: tr ( " Find ▁ chain ▁ for ▁ % 1 ▁ - ▁ % 2 . " ) . arg ( camPosId ) . arg ( rootId ) ) ; std :: vector < KeyId > chain = FindChain ( config , camPosId , rootId , std :: vector < KeyId > ( ) ) ; if ( chain . size ( ) == 0 ) { LOG_INFO ( " Not ▁ found . " ) ; allMapped = false ; break ; } } } return allMapped ; }
void ComputeTransform ( WbConfig config , KeyId refId , std :: vector < KeyId > chain , CvMat * transform ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( std :: vector < KeyId > :: iterator elt = chain . begin ( ) ; elt != chain . end ( ) ; ++ elt ) { for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( ( camera1Id == * elt ) && ( camera2Id == refId ) ) { CvMat * homography = cvCreateMat ( 3 , 3 , CV_32F ) ; const bool homographyValid = config . GetKeyValue ( FloorPlanSchema :: homographyKey , it -> id ) . ToCvMat ( * homography ) ; Q_UNUSED ( homographyValid ) ; CvMat * tmp = cvCreateMat ( 3 , 3 , CV_32F ) ; cvMatMul ( homography , transform , tmp ) ; cvmSet ( transform , 0 , 0 , cvmGet ( tmp , 0 , 0 ) ) ; cvmSet ( transform , 0 , 1 , cvmGet ( tmp , 0 , 1 ) ) ; cvmSet ( transform , 0 , 2 , cvmGet ( tmp , 0 , 2 ) ) ; cvmSet ( transform , 1 , 0 , cvmGet ( tmp , 1 , 0 ) ) ; cvmSet ( transform , 1 , 1 , cvmGet ( tmp , 1 , 1 ) ) ; cvmSet ( transform , 1 , 2 , cvmGet ( tmp , 1 , 2 ) ) ; cvmSet ( transform , 2 , 0 , cvmGet ( tmp , 2 , 0 ) ) ; cvmSet ( transform , 2 , 1 , cvmGet ( tmp , 2 , 1 ) ) ; cvmSet ( transform , 2 , 2 , cvmGet ( tmp , 2 , 2 ) ) ; cvReleaseMat ( & tmp ) ; cvReleaseMat ( & homography ) ; refId = * elt ; } } } }
~ CDBInit ( ) { if ( fDbEnvInit ) { dbenv . close ( 0 ) ; fDbEnvInit = false ; } }
void static CloseDb ( const string & strFile ) { CRITICAL_BLOCK ( cs_db ) { if ( mapDb [ strFile ] != NULL ) { Db * pdb = mapDb [ strFile ] ; pdb -> close ( 0 ) ; delete pdb ; mapDb [ strFile ] = NULL ; } } }
void DBFlush ( bool fShutdown ) { printf ( " DBFlush ( % s ) % s \n " , fShutdown ? " true " : " false " , fDbEnvInit ? " " : " ▁ db ▁ not ▁ started " ) ; if ( ! fDbEnvInit ) return ; CRITICAL_BLOCK ( cs_db ) { map < string , int > :: iterator mi = mapFileUseCount . begin ( ) ; while ( mi != mapFileUseCount . end ( ) ) { string strFile = ( * mi ) . first ; int nRefCount = ( * mi ) . second ; printf ( " % s ▁ refcount = % d \n " , strFile . c_str ( ) , nRefCount ) ; if ( nRefCount == 0 ) { CloseDb ( strFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; printf ( " % s ▁ flush \n " , strFile . c_str ( ) ) ; dbenv . lsn_reset ( strFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( mi ++ ) ; } else mi ++ ; } if ( fShutdown ) { char * * listp ; if ( mapFileUseCount . empty ( ) ) dbenv . log_archive ( & listp , DB_ARCH_REMOVE ) ; dbenv . close ( 0 ) ; fDbEnvInit = false ; } } }
CBlockIndex static * InsertBlockIndex ( uint256 hash ) { if ( hash == 0 ) return NULL ; map < uint256 , CBlockIndex * > :: iterator mi = mapBlockIndex . find ( hash ) ; if ( mi != mapBlockIndex . end ( ) ) return ( * mi ) . second ; CBlockIndex * pindexNew = new CBlockIndex ( ) ; if ( ! pindexNew ) throw runtime_error ( " LoadBlockIndex ( ) ▁ : ▁ new ▁ CBlockIndex ▁ failed " ) ; mi = mapBlockIndex . insert ( make_pair ( hash , pindexNew ) ) . first ; pindexNew -> phashBlock = & ( ( * mi ) . first ) ; return pindexNew ; }
bool LoadAddresses ( ) { return CAddrDB ( " cr + " ) . LoadAddresses ( ) ; }
void ThreadFlushWalletDB ( void * parg ) { const string & strFile = ( ( const string * ) parg ) [ 0 ] ; static bool fOneThread ; if ( fOneThread ) return ; fOneThread = true ; if ( mapArgs . count ( " - noflushwallet " ) ) return ; unsigned int nLastSeen = nWalletDBUpdated ; unsigned int nLastFlushed = nWalletDBUpdated ; int64 nLastWalletUpdate = GetTime ( ) ; while ( ! fShutdown ) { Sleep ( 500 ) ; if ( nLastSeen != nWalletDBUpdated ) { nLastSeen = nWalletDBUpdated ; nLastWalletUpdate = GetTime ( ) ; } if ( nLastFlushed != nWalletDBUpdated && GetTime ( ) - nLastWalletUpdate >= 2 ) { TRY_CRITICAL_BLOCK ( cs_db ) { int nRefCount = 0 ; map < string , int > :: iterator mi = mapFileUseCount . begin ( ) ; while ( mi != mapFileUseCount . end ( ) ) { nRefCount += ( * mi ) . second ; mi ++ ; } if ( nRefCount == 0 && ! fShutdown ) { map < string , int > :: iterator mi = mapFileUseCount . find ( strFile ) ; if ( mi != mapFileUseCount . end ( ) ) { printf ( " % s ▁ " , DateTimeStrFormat ( " % x ▁ % H : % M : % S " , GetTime ( ) ) . c_str ( ) ) ; printf ( " Flushing ▁ wallet . dat \n " ) ; nLastFlushed = nWalletDBUpdated ; int64 nStart = GetTimeMillis ( ) ; CloseDb ( strFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; dbenv . lsn_reset ( strFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( mi ++ ) ; printf ( " Flushed ▁ wallet . dat ▁ % " PRI64d " ms \n " , GetTimeMillis ( ) - nStart ) ; } } } } } }
bool BackupWallet ( const CWallet & wallet , const string & strDest ) { if ( ! wallet . fFileBacked ) return false ; while ( ! fShutdown ) { CRITICAL_BLOCK ( cs_db ) { if ( ! mapFileUseCount . count ( wallet . strWalletFile ) || mapFileUseCount [ wallet . strWalletFile ] == 0 ) { CloseDb ( wallet . strWalletFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; dbenv . lsn_reset ( wallet . strWalletFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( wallet . strWalletFile ) ; filesystem :: path pathSrc ( GetDataDir ( ) + " / " + wallet . strWalletFile ) ; filesystem :: path pathDest ( strDest ) ; if ( filesystem :: is_directory ( pathDest ) ) pathDest = pathDest / wallet . strWalletFile ; >= 104000 filesystem :: copy_file ( pathSrc , pathDest , filesystem :: copy_option :: overwrite_if_exists ) ; filesystem :: copy_file ( pathSrc , pathDest ) ; printf ( " copied ▁ wallet . dat ▁ to ▁ % s \n " , pathDest . string ( ) . c_str ( ) ) ; return true ; } } Sleep ( 100 ) ; } return false ; }
template < typename T > Matrix < T , 2 , 1 > angleToVec ( T a ) { return Matrix < T , 2 , 1 > ( std :: cos ( a ) , std :: sin ( a ) ) ; }
template < typename T > EIGEN_DONT_INLINE void dont_over_optimize ( T & x ) { volatile typename T :: Scalar tmp = x ( 0 ) ; x ( 0 ) = tmp ; }
template < typename Scalar , int Mode , int Options > void non_projective_only ( ) { typedef Matrix < Scalar , 3 , 1 > Vector3 ; typedef Quaternion < Scalar > Quaternionx ; typedef AngleAxis < Scalar > AngleAxisx ; typedef Transform < Scalar , 3 , Mode , Options > Transform3 ; typedef DiagonalMatrix < Scalar , 3 > AlignedScaling3 ; typedef Translation < Scalar , 3 > Translation3 ; Vector3 v0 = Vector3 :: Random ( ) , v1 = Vector3 :: Random ( ) ; Transform3 t0 , t1 , t2 ; Scalar a = internal :: random < Scalar > ( - Scalar ( EIGEN_PI ) , Scalar ( EIGEN_PI ) ) ; Quaternionx q1 , q2 ; q1 = AngleAxisx ( a , v0 . normalized ( ) ) ; t0 = Transform3 :: Identity ( ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , Transform3 :: MatrixType :: Identity ( ) ) ; t0 . linear ( ) = q1 . toRotationMatrix ( ) ; v0 << 50 , 2 , 1 ; t0 . scale ( v0 ) ; VERIFY_IS_APPROX ( ( t0 * Vector3 ( 1 , 0 , 0 ) ) . template head < 3 > ( ) . norm ( ) , v0 . x ( ) ) ; t0 . setIdentity ( ) ; t1 . setIdentity ( ) ; v1 << 1 , 2 , 3 ; t0 . linear ( ) = q1 . toRotationMatrix ( ) ; t0 . pretranslate ( v0 ) ; t0 . scale ( v1 ) ; t1 . linear ( ) = q1 . conjugate ( ) . toRotationMatrix ( ) ; t1 . prescale ( v1 . cwiseInverse ( ) ) ; t1 . translate ( - v0 ) ; VERIFY ( ( t0 * t1 ) . matrix ( ) . isIdentity ( test_precision < Scalar > ( ) ) ) ; t1 . fromPositionOrientationScale ( v0 , q1 , v1 ) ; VERIFY_IS_APPROX ( t1 . matrix ( ) , t0 . matrix ( ) ) ; VERIFY_IS_APPROX ( t1 * v1 , t0 * v1 ) ; t0 . setIdentity ( ) ; t0 . translate ( v0 ) ; VERIFY_IS_APPROX ( ( t0 * v1 ) . template head < 3 > ( ) , Translation3 ( v0 ) * v1 ) ; t0 . setIdentity ( ) ; t0 . scale ( v0 ) ; VERIFY_IS_APPROX ( ( t0 * v1 ) . template head < 3 > ( ) , AlignedScaling3 ( v0 ) * v1 ) ; }
template < typename Scalar , int Mode , int Options > void transformations ( ) { using std :: cos ; using std :: abs ; typedef Matrix < Scalar , 3 , 3 > Matrix3 ; typedef Matrix < Scalar , 4 , 4 > Matrix4 ; typedef Matrix < Scalar , 2 , 1 > Vector2 ; typedef Matrix < Scalar , 3 , 1 > Vector3 ; typedef Matrix < Scalar , 4 , 1 > Vector4 ; typedef Quaternion < Scalar > Quaternionx ; typedef AngleAxis < Scalar > AngleAxisx ; typedef Transform < Scalar , 2 , Mode , Options > Transform2 ; typedef Transform < Scalar , 3 , Mode , Options > Transform3 ; typedef typename Transform3 :: MatrixType MatrixType ; typedef DiagonalMatrix < Scalar , 3 > AlignedScaling3 ; typedef Translation < Scalar , 2 > Translation2 ; typedef Translation < Scalar , 3 > Translation3 ; Vector3 v0 = Vector3 :: Random ( ) , v1 = Vector3 :: Random ( ) ; Matrix3 matrot1 , m ; Scalar a = internal :: random < Scalar > ( - Scalar ( EIGEN_PI ) , Scalar ( EIGEN_PI ) ) ; Scalar s0 = internal :: random < Scalar > ( ) , s1 = internal :: random < Scalar > ( ) ; while ( v0 . norm ( ) < test_precision < Scalar > ( ) ) v0 = Vector3 :: Random ( ) ; while ( v1 . norm ( ) < test_precision < Scalar > ( ) ) v1 = Vector3 :: Random ( ) ; VERIFY_IS_APPROX ( v0 , AngleAxisx ( a , v0 . normalized ( ) ) * v0 ) ; VERIFY_IS_APPROX ( - v0 , AngleAxisx ( Scalar ( EIGEN_PI ) , v0 . unitOrthogonal ( ) ) * v0 ) ; if ( abs ( cos ( a ) ) > test_precision < Scalar > ( ) ) { VERIFY_IS_APPROX ( cos ( a ) * v0 . squaredNorm ( ) , v0 . dot ( AngleAxisx ( a , v0 . unitOrthogonal ( ) ) * v0 ) ) ; } m = AngleAxisx ( a , v0 . normalized ( ) ) . toRotationMatrix ( ) . adjoint ( ) ; VERIFY_IS_APPROX ( Matrix3 :: Identity ( ) , m * AngleAxisx ( a , v0 . normalized ( ) ) ) ; VERIFY_IS_APPROX ( Matrix3 :: Identity ( ) , AngleAxisx ( a , v0 . normalized ( ) ) * m ) ; Quaternionx q1 , q2 ; q1 = AngleAxisx ( a , v0 . normalized ( ) ) ; q2 = AngleAxisx ( a , v1 . normalized ( ) ) ; matrot1 = AngleAxisx ( Scalar ( 0.1 ) , Vector3 :: UnitX ( ) ) * AngleAxisx ( Scalar ( 0.2 ) , Vector3 :: UnitY ( ) ) * AngleAxisx ( Scalar ( 0.3 ) , Vector3 :: UnitZ ( ) ) ; VERIFY_IS_APPROX ( matrot1 * v1 , AngleAxisx ( Scalar ( 0.1 ) , Vector3 ( 1 , 0 , 0 ) ) . toRotationMatrix ( ) * ( AngleAxisx ( Scalar ( 0.2 ) , Vector3 ( 0 , 1 , 0 ) ) . toRotationMatrix ( ) * ( AngleAxisx ( Scalar ( 0.3 ) , Vector3 ( 0 , 0 , 1 ) ) . toRotationMatrix ( ) * v1 ) ) ) ; AngleAxisx aa = AngleAxisx ( q1 ) ; VERIFY_IS_APPROX ( q1 * v1 , Quaternionx ( aa ) * v1 ) ; if ( ( abs ( aa . angle ( ) ) > test_precision < Scalar > ( ) ) && ( abs ( aa . axis ( ) . dot ( v1 . normalized ( ) ) ) < ( Scalar ( 1 ) - Scalar ( 4 ) * test_precision < Scalar > ( ) ) ) ) { VERIFY ( ! ( q1 * v1 ) . isApprox ( Quaternionx ( AngleAxisx ( aa . angle ( ) * 2 , aa . axis ( ) ) ) * v1 ) ) ; } aa . fromRotationMatrix ( aa . toRotationMatrix ( ) ) ; VERIFY_IS_APPROX ( q1 * v1 , Quaternionx ( aa ) * v1 ) ; if ( ( abs ( aa . angle ( ) ) > test_precision < Scalar > ( ) ) && ( abs ( aa . axis ( ) . dot ( v1 . normalized ( ) ) ) < ( Scalar ( 1 ) - Scalar ( 4 ) * test_precision < Scalar > ( ) ) ) ) { VERIFY ( ! ( q1 * v1 ) . isApprox ( Quaternionx ( AngleAxisx ( aa . angle ( ) * 2 , aa . axis ( ) ) ) * v1 ) ) ; } VERIFY_IS_APPROX ( AngleAxisx ( a , v1 . normalized ( ) ) . toRotationMatrix ( ) , Quaternionx ( AngleAxisx ( a , v1 . normalized ( ) ) ) . toRotationMatrix ( ) ) ; AngleAxisx aa1 ; m = q1 . toRotationMatrix ( ) ; aa1 = m ; VERIFY_IS_APPROX ( AngleAxisx ( m ) . toRotationMatrix ( ) , Quaternionx ( m ) . toRotationMatrix ( ) ) ; a = 0 ; while ( abs ( a ) < Scalar ( 0.1 ) ) a = internal :: random < Scalar > ( - Scalar ( 0.4 ) * Scalar ( EIGEN_PI ) , Scalar ( 0.4 ) * Scalar ( EIGEN_PI ) ) ; q1 = AngleAxisx ( a , v0 . normalized ( ) ) ; Transform3 t0 , t1 , t2 ; t0 . setIdentity ( ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , Transform3 :: MatrixType :: Identity ( ) ) ; t0 . matrix ( ) . setZero ( ) ; t0 = Transform3 :: Identity ( ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , Transform3 :: MatrixType :: Identity ( ) ) ; t0 . setIdentity ( ) ; t1 . setIdentity ( ) ; v1 << 1 , 2 , 3 ; t0 . linear ( ) = q1 . toRotationMatrix ( ) ; t0 . pretranslate ( v0 ) ; t0 . scale ( v1 ) ; t1 . linear ( ) = q1 . conjugate ( ) . toRotationMatrix ( ) ; t1 . prescale ( v1 . cwiseInverse ( ) ) ; t1 . translate ( - v0 ) ; VERIFY ( ( t0 * t1 ) . matrix ( ) . isIdentity ( test_precision < Scalar > ( ) ) ) ; t1 . fromPositionOrientationScale ( v0 , q1 , v1 ) ; VERIFY_IS_APPROX ( t1 . matrix ( ) , t0 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . scale ( v0 ) . rotate ( q1 . toRotationMatrix ( ) ) ; t1 . setIdentity ( ) ; t1 . scale ( v0 ) . rotate ( q1 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . scale ( v0 ) . rotate ( AngleAxisx ( q1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; VERIFY_IS_APPROX ( t0 . scale ( a ) . matrix ( ) , t1 . scale ( Vector3 :: Constant ( a ) ) . matrix ( ) ) ; VERIFY_IS_APPROX ( t0 . prescale ( a ) . matrix ( ) , t1 . prescale ( Vector3 :: Constant ( a ) ) . matrix ( ) ) ; Matrix3 mat3 = Matrix3 :: Random ( ) ; Matrix4 mat4 ; mat4 << mat3 , Vector3 :: Zero ( ) , Vector4 :: Zero ( ) . transpose ( ) ; Transform3 tmat3 ( mat3 ) , tmat4 ( mat4 ) ; if ( Mode != int ( AffineCompact ) ) tmat4 . matrix ( ) ( 3 , 3 ) = Scalar ( 1 ) ; VERIFY_IS_APPROX ( tmat3 . matrix ( ) , tmat4 . matrix ( ) ) ; Scalar a3 = internal :: random < Scalar > ( - Scalar ( EIGEN_PI ) , Scalar ( EIGEN_PI ) ) ; Vector3 v3 = Vector3 :: Random ( ) . normalized ( ) ; AngleAxisx aa3 ( a3 , v3 ) ; Transform3 t3 ( aa3 ) ; Transform3 t4 ; t4 = aa3 ; VERIFY_IS_APPROX ( t3 . matrix ( ) , t4 . matrix ( ) ) ; t4 . rotate ( AngleAxisx ( - a3 , v3 ) ) ; VERIFY_IS_APPROX ( t4 . matrix ( ) , MatrixType :: Identity ( ) ) ; t4 *= aa3 ; VERIFY_IS_APPROX ( t3 . matrix ( ) , t4 . matrix ( ) ) ; do { v3 = Vector3 :: Random ( ) ; dont_over_optimize ( v3 ) ; } while ( v3 . cwiseAbs ( ) . minCoeff ( ) < NumTraits < Scalar > :: epsilon ( ) ) ; Translation3 tv3 ( v3 ) ; Transform3 t5 ( tv3 ) ; t4 = tv3 ; VERIFY_IS_APPROX ( t5 . matrix ( ) , t4 . matrix ( ) ) ; t4 . translate ( ( - v3 ) . eval ( ) ) ; VERIFY_IS_APPROX ( t4 . matrix ( ) , MatrixType :: Identity ( ) ) ; t4 *= tv3 ; VERIFY_IS_APPROX ( t5 . matrix ( ) , t4 . matrix ( ) ) ; AlignedScaling3 sv3 ( v3 ) ; Transform3 t6 ( sv3 ) ; t4 = sv3 ; VERIFY_IS_APPROX ( t6 . matrix ( ) , t4 . matrix ( ) ) ; t4 . scale ( v3 . cwiseInverse ( ) ) ; VERIFY_IS_APPROX ( t4 . matrix ( ) , MatrixType :: Identity ( ) ) ; t4 *= sv3 ; VERIFY_IS_APPROX ( t6 . matrix ( ) , t4 . matrix ( ) ) ; VERIFY_IS_APPROX ( ( t3 . matrix ( ) * t4 ) . matrix ( ) , ( t3 * t4 ) . matrix ( ) ) ; VERIFY_IS_APPROX ( ( ( t3 * t4 ) * t5 ) . matrix ( ) , ( t3 * ( t4 * t5 ) ) . matrix ( ) ) ; t5 = t4 ; t5 = t5 * t5 ; VERIFY_IS_APPROX ( t5 , t4 * t4 ) ; Transform2 t20 , t21 ; Vector2 v20 = Vector2 :: Random ( ) ; Vector2 v21 = Vector2 :: Random ( ) ; for ( int k = 0 ; k < 2 ; ++ k ) if ( abs ( v21 [ k ] ) < Scalar ( 1e - 3 ) ) v21 [ k ] = Scalar ( 1e - 3 ) ; t21 . setIdentity ( ) ; t21 . linear ( ) = Rotation2D < Scalar > ( a ) . toRotationMatrix ( ) ; VERIFY_IS_APPROX ( t20 . fromPositionOrientationScale ( v20 , a , v21 ) . matrix ( ) , t21 . pretranslate ( v20 ) . scale ( v21 ) . matrix ( ) ) ; t21 . setIdentity ( ) ; t21 . linear ( ) = Rotation2D < Scalar > ( - a ) . toRotationMatrix ( ) ; VERIFY ( ( t20 . fromPositionOrientationScale ( v20 , a , v21 ) * ( t21 . prescale ( v21 . cwiseInverse ( ) ) . translate ( - v20 ) ) ) . matrix ( ) . isIdentity ( test_precision < Scalar > ( ) ) ) ; t0 . setIdentity ( ) ; t0 . rotate ( q1 ) . scale ( v0 ) . translate ( v0 ) ; t1 = ( Matrix3 ( q1 ) * AlignedScaling3 ( v0 ) ) * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = ( Matrix3 ( q1 ) * Eigen :: Scaling ( v0 ) ) * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = ( q1 * Eigen :: Scaling ( v0 ) ) * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = Matrix3 ( q1 ) * ( AlignedScaling3 ( v0 ) * Translation3 ( v0 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . scale ( s0 ) . translate ( v0 ) ; t1 = Eigen :: Scaling ( s0 ) * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . prescale ( s0 ) ; t1 = Eigen :: Scaling ( s0 ) * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 = t3 ; t0 . scale ( s0 ) ; t1 = t3 * Eigen :: Scaling ( s0 , s0 , s0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . prescale ( s0 ) ; t1 = Eigen :: Scaling ( s0 , s0 , s0 ) * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 = t3 ; t0 . scale ( s0 ) ; t1 = t3 * Eigen :: Scaling ( s0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . prescale ( s0 ) ; t1 = Eigen :: Scaling ( s0 ) * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . prerotate ( q1 ) . prescale ( v0 ) . pretranslate ( v0 ) ; t1 = ( Translation3 ( v0 ) * AlignedScaling3 ( v0 ) ) * Transform3 ( q1 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = Translation3 ( v0 ) * ( AlignedScaling3 ( v0 ) * Transform3 ( q1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . scale ( v0 ) . translate ( v0 ) . rotate ( q1 ) ; t1 = AlignedScaling3 ( v0 ) * ( Translation3 ( v0 ) * Transform3 ( q1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . scale ( v0 ) ; t1 *= AlignedScaling3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = AlignedScaling3 ( v0 ) * ( Translation3 ( v0 ) * Transform3 ( q1 ) ) ; t1 = t1 * v0 . asDiagonal ( ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . translate ( v0 ) ; t1 = t1 * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . pretranslate ( v0 ) ; t1 = Translation3 ( v0 ) * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . rotate ( q1 ) ; t1 = t1 * q1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . translate ( v1 ) . rotate ( q1 ) ; t1 = t1 * ( Translation3 ( v1 ) * q1 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . scale ( v1 ) . rotate ( q1 ) ; t1 = t1 * ( AlignedScaling3 ( v1 ) * q1 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . prerotate ( q1 ) ; t1 = q1 * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . rotate ( q1 ) . translate ( v1 ) ; t1 = t1 * ( q1 * Translation3 ( v1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . rotate ( q1 ) . scale ( v1 ) ; t1 = t1 * ( q1 * AlignedScaling3 ( v1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . translate ( v0 ) ; do { t0 . linear ( ) . setRandom ( ) ; } while ( t0 . linear ( ) . jacobiSvd ( ) . singularValues ( ) ( 2 ) < test_precision < Scalar > ( ) ) ; Matrix4 t044 = Matrix4 :: Zero ( ) ; t044 ( 3 , 3 ) = 1 ; t044 . block ( 0 , 0 , t0 . matrix ( ) . rows ( ) , 4 ) = t0 . matrix ( ) ; VERIFY_IS_APPROX ( t0 . inverse ( Affine ) . matrix ( ) , t044 . inverse ( ) . block ( 0 , 0 , t0 . matrix ( ) . rows ( ) , 4 ) ) ; t0 . setIdentity ( ) ; t0 . translate ( v0 ) . rotate ( q1 ) ; t044 = Matrix4 :: Zero ( ) ; t044 ( 3 , 3 ) = 1 ; t044 . block ( 0 , 0 , t0 . matrix ( ) . rows ( ) , 4 ) = t0 . matrix ( ) ; VERIFY_IS_APPROX ( t0 . inverse ( Isometry ) . matrix ( ) , t044 . inverse ( ) . block ( 0 , 0 , t0 . matrix ( ) . rows ( ) , 4 ) ) ; Matrix3 mat_rotation , mat_scaling ; t0 . setIdentity ( ) ; t0 . translate ( v0 ) . rotate ( q1 ) . scale ( v1 ) ; t0 . computeRotationScaling ( & mat_rotation , & mat_scaling ) ; VERIFY_IS_APPROX ( t0 . linear ( ) , mat_rotation * mat_scaling ) ; VERIFY_IS_APPROX ( mat_rotation * mat_rotation . adjoint ( ) , Matrix3 :: Identity ( ) ) ; VERIFY_IS_APPROX ( mat_rotation . determinant ( ) , Scalar ( 1 ) ) ; t0 . computeScalingRotation ( & mat_scaling , & mat_rotation ) ; VERIFY_IS_APPROX ( t0 . linear ( ) , mat_scaling * mat_rotation ) ; VERIFY_IS_APPROX ( mat_rotation * mat_rotation . adjoint ( ) , Matrix3 :: Identity ( ) ) ; VERIFY_IS_APPROX ( mat_rotation . determinant ( ) , Scalar ( 1 ) ) ; Transform < float , 3 , Mode > t1f = t1 . template cast < float > ( ) ; VERIFY_IS_APPROX ( t1f . template cast < Scalar > ( ) , t1 ) ; Transform < double , 3 , Mode > t1d = t1 . template cast < double > ( ) ; VERIFY_IS_APPROX ( t1d . template cast < Scalar > ( ) , t1 ) ; Translation3 tr1 ( v0 ) ; Translation < float , 3 > tr1f = tr1 . template cast < float > ( ) ; VERIFY_IS_APPROX ( tr1f . template cast < Scalar > ( ) , tr1 ) ; Translation < double , 3 > tr1d = tr1 . template cast < double > ( ) ; VERIFY_IS_APPROX ( tr1d . template cast < Scalar > ( ) , tr1 ) ; AngleAxis < float > aa1f = aa1 . template cast < float > ( ) ; VERIFY_IS_APPROX ( aa1f . template cast < Scalar > ( ) , aa1 ) ; AngleAxis < double > aa1d = aa1 . template cast < double > ( ) ; VERIFY_IS_APPROX ( aa1d . template cast < Scalar > ( ) , aa1 ) ; Rotation2D < Scalar > r2d1 ( internal :: random < Scalar > ( ) ) ; Rotation2D < float > r2d1f = r2d1 . template cast < float > ( ) ; VERIFY_IS_APPROX ( r2d1f . template cast < Scalar > ( ) , r2d1 ) ; Rotation2D < double > r2d1d = r2d1 . template cast < double > ( ) ; VERIFY_IS_APPROX ( r2d1d . template cast < Scalar > ( ) , r2d1 ) ; for ( int k = 0 ; k < 100 ; ++ k ) { Scalar angle = internal :: random < Scalar > ( - 100 , 100 ) ; Rotation2D < Scalar > rot2 ( angle ) ; VERIFY ( rot2 . smallestPositiveAngle ( ) >= 0 ) ; VERIFY ( rot2 . smallestPositiveAngle ( ) <= Scalar ( 2 ) * Scalar ( EIGEN_PI ) ) ; VERIFY_IS_APPROX ( angleToVec ( rot2 . smallestPositiveAngle ( ) ) , angleToVec ( rot2 . angle ( ) ) ) ; VERIFY ( rot2 . smallestAngle ( ) >= - Scalar ( EIGEN_PI ) ) ; VERIFY ( rot2 . smallestAngle ( ) <= Scalar ( EIGEN_PI ) ) ; VERIFY_IS_APPROX ( angleToVec ( rot2 . smallestAngle ( ) ) , angleToVec ( rot2 . angle ( ) ) ) ; Matrix < Scalar , 2 , 2 > rot2_as_mat ( rot2 ) ; Rotation2D < Scalar > rot3 ( rot2_as_mat ) ; VERIFY_IS_APPROX ( angleToVec ( rot2 . smallestAngle ( ) ) , angleToVec ( rot3 . angle ( ) ) ) ; } s0 = internal :: random < Scalar > ( - 100 , 100 ) ; s1 = internal :: random < Scalar > ( - 100 , 100 ) ; Rotation2D < Scalar > R0 ( s0 ) , R1 ( s1 ) ; t20 = Translation2 ( v20 ) * ( R0 * Eigen :: Scaling ( s0 ) ) ; t21 = Translation2 ( v20 ) * R0 * Eigen :: Scaling ( s0 ) ; VERIFY_IS_APPROX ( t20 , t21 ) ; t20 = Translation2 ( v20 ) * ( R0 * R0 . inverse ( ) * Eigen :: Scaling ( s0 ) ) ; t21 = Translation2 ( v20 ) * Eigen :: Scaling ( s0 ) ; VERIFY_IS_APPROX ( t20 , t21 ) ; VERIFY_IS_APPROX ( s0 , ( R0 . slerp ( 0 , R1 ) ) . angle ( ) ) ; VERIFY_IS_APPROX ( angleToVec ( R1 . smallestPositiveAngle ( ) ) , angleToVec ( ( R0 . slerp ( 1 , R1 ) ) . smallestPositiveAngle ( ) ) ) ; VERIFY_IS_APPROX ( R0 . smallestPositiveAngle ( ) , ( R0 . slerp ( 0.5 , R0 ) ) . smallestPositiveAngle ( ) ) ; if ( std :: cos ( s0 ) > 0 ) VERIFY_IS_MUCH_SMALLER_THAN ( ( R0 . slerp ( 0.5 , R0 . inverse ( ) ) ) . smallestAngle ( ) , Scalar ( 1 ) ) ; else VERIFY_IS_APPROX ( Scalar ( EIGEN_PI ) , ( R0 . slerp ( 0.5 , R0 . inverse ( ) ) ) . smallestPositiveAngle ( ) ) ; Scalar l = 0 ; int path_steps = 100 ; for ( int k = 0 ; k < path_steps ; ++ k ) { Scalar a1 = R0 . slerp ( Scalar ( k ) / Scalar ( path_steps ) , R1 ) . angle ( ) ; Scalar a2 = R0 . slerp ( Scalar ( k + 1 ) / Scalar ( path_steps ) , R1 ) . angle ( ) ; l += std :: abs ( a2 - a1 ) ; } VERIFY ( l <= Scalar ( EIGEN_PI ) * ( Scalar ( 1 ) + NumTraits < Scalar > :: epsilon ( ) * Scalar ( path_steps / 2 ) ) ) ; { Rotation2D < Scalar > r1 ; r1 = Rotation2D < Scalar > ( s0 ) ; VERIFY_IS_APPROX ( r1 . angle ( ) , s0 ) ; Rotation2D < Scalar > r2 ( r1 ) ; VERIFY_IS_APPROX ( r2 . angle ( ) , s0 ) ; } { Transform3 t32 ( Matrix4 :: Random ( ) ) , t33 , t34 ; t34 = t33 = t32 ; t32 . scale ( v0 ) ; t33 *= AlignedScaling3 ( v0 ) ; VERIFY_IS_APPROX ( t32 . matrix ( ) , t33 . matrix ( ) ) ; t33 = t34 * AlignedScaling3 ( v0 ) ; VERIFY_IS_APPROX ( t32 . matrix ( ) , t33 . matrix ( ) ) ; } }
template < typename A1 , typename A2 , typename P , typename Q , typename V , typename H > void transform_associativity_left ( const A1 & a1 , const A2 & a2 , const P & p , const Q & q , const V & v , const H & h ) { VERIFY_IS_APPROX ( q * ( a1 * v ) , ( q * a1 ) * v ) ; VERIFY_IS_APPROX ( q * ( a2 * v ) , ( q * a2 ) * v ) ; VERIFY_IS_APPROX ( q * ( p * h ) . hnormalized ( ) , ( ( q * p ) * h ) . hnormalized ( ) ) ; }
template < typename A1 , typename A2 , typename P , typename Q , typename V , typename H > void transform_associativity2 ( const A1 & a1 , const A2 & a2 , const P & p , const Q & q , const V & v , const H & h ) { VERIFY_IS_APPROX ( a1 * ( q * v ) , ( a1 * q ) * v ) ; VERIFY_IS_APPROX ( a2 * ( q * v ) , ( a2 * q ) * v ) ; VERIFY_IS_APPROX ( p * ( q * v ) . homogeneous ( ) , ( p * q ) * v . homogeneous ( ) ) ; transform_associativity_left ( a1 , a2 , p , q , v , h ) ; }
template < typename Scalar , int Dim , int Options , typename RotationType > void transform_associativity ( const RotationType & R ) { typedef Matrix < Scalar , Dim , 1 > VectorType ; typedef Matrix < Scalar , Dim + 1 , 1 > HVectorType ; typedef Matrix < Scalar , Dim , Dim > LinearType ; typedef Matrix < Scalar , Dim + 1 , Dim + 1 > MatrixType ; typedef Transform < Scalar , Dim , AffineCompact , Options > AffineCompactType ; typedef Transform < Scalar , Dim , Affine , Options > AffineType ; typedef Transform < Scalar , Dim , Projective , Options > ProjectiveType ; typedef DiagonalMatrix < Scalar , Dim > ScalingType ; typedef Translation < Scalar , Dim > TranslationType ; AffineCompactType A1c ; A1c . matrix ( ) . setRandom ( ) ; AffineCompactType A2c ; A2c . matrix ( ) . setRandom ( ) ; AffineType A1 ( A1c ) ; AffineType A2 ( A2c ) ; ProjectiveType P1 ; P1 . matrix ( ) . setRandom ( ) ; VectorType v1 = VectorType :: Random ( ) ; VectorType v2 = VectorType :: Random ( ) ; HVectorType h1 = HVectorType :: Random ( ) ; Scalar s1 = internal :: random < Scalar > ( ) ; LinearType L = LinearType :: Random ( ) ; MatrixType M = MatrixType :: Random ( ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , A2 , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , A2c , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , v1 . asDiagonal ( ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , ScalingType ( v1 ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , Scaling ( v1 ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , Scaling ( s1 ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , TranslationType ( v1 ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity_left ( A1c , A1 , P1 , L , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , R , v2 , h1 ) ) ; VERIFY_IS_APPROX ( A1 * ( M * h1 ) , ( A1 * M ) * h1 ) ; VERIFY_IS_APPROX ( A1c * ( M * h1 ) , ( A1c * M ) * h1 ) ; VERIFY_IS_APPROX ( P1 * ( M * h1 ) , ( P1 * M ) * h1 ) ; VERIFY_IS_APPROX ( M * ( A1 * h1 ) , ( M * A1 ) * h1 ) ; VERIFY_IS_APPROX ( M * ( A1c * h1 ) , ( M * A1c ) * h1 ) ; VERIFY_IS_APPROX ( M * ( P1 * h1 ) , ( ( M * P1 ) * h1 ) ) ; }
template < typename Scalar > void transform_alignment ( ) { typedef Transform < Scalar , 3 , Projective , AutoAlign > Projective3a ; typedef Transform < Scalar , 3 , Projective , DontAlign > Projective3u ; EIGEN_ALIGN_MAX Scalar array1 [ 16 ] ; EIGEN_ALIGN_MAX Scalar array2 [ 16 ] ; EIGEN_ALIGN_MAX Scalar array3 [ 16 + 1 ] ; Scalar * array3u = array3 + 1 ; Projective3a * p1 = :: new ( reinterpret_cast < void * > ( array1 ) ) Projective3a ; Projective3u * p2 = :: new ( reinterpret_cast < void * > ( array2 ) ) Projective3u ; Projective3u * p3 = :: new ( reinterpret_cast < void * > ( array3u ) ) Projective3u ; p1 -> matrix ( ) . setRandom ( ) ; * p2 = * p1 ; * p3 = * p1 ; VERIFY_IS_APPROX ( p1 -> matrix ( ) , p2 -> matrix ( ) ) ; VERIFY_IS_APPROX ( p1 -> matrix ( ) , p3 -> matrix ( ) ) ; VERIFY_IS_APPROX ( ( * p1 ) * ( * p1 ) , ( * p2 ) * ( * p3 ) ) ; && EIGEN_MAX_STATIC_ALIGN_BYTES > 0 if ( internal :: packet_traits < Scalar > :: Vectorizable ) VERIFY_RAISES_ASSERT ( ( :: new ( reinterpret_cast < void * > ( array3u ) ) Projective3a ) ) ; }
template < typename Scalar , int Dim , int Options > void transform_products ( ) { typedef Matrix < Scalar , Dim + 1 , Dim + 1 > Mat ; typedef Transform < Scalar , Dim , Projective , Options > Proj ; typedef Transform < Scalar , Dim , Affine , Options > Aff ; typedef Transform < Scalar , Dim , AffineCompact , Options > AffC ; Proj p ; p . matrix ( ) . setRandom ( ) ; Aff a ; a . linear ( ) . setRandom ( ) ; a . translation ( ) . setRandom ( ) ; AffC ac = a ; Mat p_m ( p . matrix ( ) ) , a_m ( a . matrix ( ) ) ; VERIFY_IS_APPROX ( ( p * p ) . matrix ( ) , p_m * p_m ) ; VERIFY_IS_APPROX ( ( a * a ) . matrix ( ) , a_m * a_m ) ; VERIFY_IS_APPROX ( ( p * a ) . matrix ( ) , p_m * a_m ) ; VERIFY_IS_APPROX ( ( a * p ) . matrix ( ) , a_m * p_m ) ; VERIFY_IS_APPROX ( ( ac * a ) . matrix ( ) , a_m * a_m ) ; VERIFY_IS_APPROX ( ( a * ac ) . matrix ( ) , a_m * a_m ) ; VERIFY_IS_APPROX ( ( p * ac ) . matrix ( ) , p_m * a_m ) ; VERIFY_IS_APPROX ( ( ac * p ) . matrix ( ) , a_m * p_m ) ; }
void test_geo_transformations ( ) { for ( int i = 0 ; i < g_repeat ; i ++ ) { CALL_SUBTEST_1 ( ( transformations < double , Affine , AutoAlign > ( ) ) ) ; CALL_SUBTEST_1 ( ( non_projective_only < double , Affine , AutoAlign > ( ) ) ) ; CALL_SUBTEST_2 ( ( transformations < float , AffineCompact , AutoAlign > ( ) ) ) ; CALL_SUBTEST_2 ( ( non_projective_only < float , AffineCompact , AutoAlign > ( ) ) ) ; CALL_SUBTEST_2 ( ( transform_alignment < float > ( ) ) ) ; CALL_SUBTEST_3 ( ( transformations < double , Projective , AutoAlign > ( ) ) ) ; CALL_SUBTEST_3 ( ( transformations < double , Projective , DontAlign > ( ) ) ) ; CALL_SUBTEST_3 ( ( transform_alignment < double > ( ) ) ) ; CALL_SUBTEST_4 ( ( transformations < float , Affine , RowMajor | AutoAlign > ( ) ) ) ; CALL_SUBTEST_4 ( ( non_projective_only < float , Affine , RowMajor > ( ) ) ) ; CALL_SUBTEST_5 ( ( transformations < double , AffineCompact , RowMajor | AutoAlign > ( ) ) ) ; CALL_SUBTEST_5 ( ( non_projective_only < double , AffineCompact , RowMajor > ( ) ) ) ; CALL_SUBTEST_6 ( ( transformations < double , Projective , RowMajor | AutoAlign > ( ) ) ) ; CALL_SUBTEST_6 ( ( transformations < double , Projective , RowMajor | DontAlign > ( ) ) ) ; CALL_SUBTEST_7 ( ( transform_products < double , 3 , RowMajor | AutoAlign > ( ) ) ) ; CALL_SUBTEST_7 ( ( transform_products < float , 2 , AutoAlign > ( ) ) ) ; CALL_SUBTEST_8 ( ( transform_associativity < double , 2 , ColMajor > ( Rotation2D < double > ( internal :: random < double > ( ) * double ( EIGEN_PI ) ) ) ) ) ; CALL_SUBTEST_8 ( ( transform_associativity < double , 3 , ColMajor > ( Quaterniond :: UnitRandom ( ) ) ) ) ; } }
BEGIN_MESSAGE_MAP ( CFormDialog , CDialog ) ON_WM_SIZE ( ) ON_WM_LBUTTONDOWN ( ) ON_WM_SETFOCUS ( ) ON_WM_KILLFOCUS ( ) END_MESSAGE_MAP ( ) void CFormDialog :: OnSize ( UINT nType , int cx , int cy ) { CBaseDialog :: OnSize ( nType , cx , cy ) ; }
void update ( rational const & k , expr * t ) { m_coeff = k ; m_term = t ; }
void pp ( std :: ostream & out , app * x ) { ast_manager & m = m_term . get_manager ( ) ; out << " ( < = ▁ ( + ▁ ( * ▁ " << coeff ( ) << " ▁ " << mk_pp ( x , m ) << " ) ▁ " << mk_pp ( term ( ) , m ) << " ) ▁ 0 ) " ; }
numeral & a_ref ( ) { return m_a ; }
numeral & k_ref ( ) { return m_k ; }
expr * & t_ref ( ) { return m_term ; }
ast_manager & get_manager ( ) { return m ; }
bool get_coeff ( contains_app & contains_x , expr * p , rational & k , expr_ref & rest ) { app * x = contains_x . x ( ) ; ptr_vector < expr > restl , todo ; todo . push_back ( p ) ; bool found = false ; expr * e1 , * e2 ; while ( ! todo . empty ( ) ) { expr * e = todo . back ( ) ; todo . pop_back ( ) ; if ( m_arith . is_add ( e ) ) { for ( unsigned i = 0 ; i < to_app ( e ) -> get_num_args ( ) ; ++ i ) { todo . push_back ( to_app ( e ) -> get_arg ( i ) ) ; } } else if ( e == x ) { k = numeral ( 1 ) ; found = true ; break ; } else if ( m_arith . is_mul ( e , e1 , e2 ) && e1 == x && m_arith . is_numeral ( e2 , k ) ) { found = true ; break ; } else if ( m_arith . is_mul ( e , e1 , e2 ) && e2 == x && m_arith . is_numeral ( e1 , k ) ) { found = true ; break ; } else { restl . push_back ( e ) ; } } if ( ! found ) { TRACE ( " qe _ verbose " , tout << " Did ▁ not ▁ find : ▁ " << mk_pp ( x , m ) << " ▁ in ▁ " << mk_pp ( p , m ) << " \n " ; ) ; return false ; } while ( ! todo . empty ( ) ) { restl . push_back ( todo . back ( ) ) ; todo . pop_back ( ) ; } if ( restl . empty ( ) ) { rest = mk_zero ( x ) ; } else { rest = m_arith . mk_add ( restl . size ( ) , restl . c_ptr ( ) ) ; } if ( contains_x ( rest ) ) { return false ; } TRACE ( " qe _ verbose " , tout << mk_pp ( p , m ) << " ▁ = ▁ " << " ( + ▁ ( * ▁ " << k << " ▁ " << mk_pp ( x , m ) << " ) ▁ " << mk_pp ( rest , m ) << " ) \n " ; ) ; return true ; }
void get_const ( expr * p , rational & k , expr_ref & rest ) { ptr_vector < expr > todo , restl ; todo . push_back ( p ) ; k = numeral ( 0 ) ; while ( ! todo . empty ( ) ) { p = todo . back ( ) ; todo . pop_back ( ) ; if ( m_arith . is_add ( p ) ) { for ( unsigned i = 0 ; i < to_app ( p ) -> get_num_args ( ) ; ++ i ) { todo . push_back ( to_app ( p ) -> get_arg ( i ) ) ; } } else if ( m_arith . is_numeral ( p , k ) ) { break ; } else { restl . push_back ( p ) ; } } while ( ! todo . empty ( ) ) { restl . push_back ( todo . back ( ) ) ; todo . pop_back ( ) ; } if ( restl . empty ( ) ) { rest = mk_zero ( p ) ; } else { rest = m_arith . mk_add ( restl . size ( ) , restl . c_ptr ( ) ) ; } }
bool is_neg ( app * e , expr_ref & ne ) { if ( m . is_not ( e ) ) { ne = to_app ( e ) -> get_arg ( 0 ) ; return true ; } return false ; }
bool is_le ( app * e , expr_ref & p ) { return is_le_ge_core < 1 > ( e , p ) ; }
bool is_ge ( app * e , expr_ref & p ) { return is_le_ge_core < 0 > ( e , p ) ; }
bool is_lt ( app * e , expr_ref & p ) { numeral k ; expr * a1 , * a2 ; if ( m_arith . is_lt ( e , a1 , a2 ) || m_arith . is_gt ( e , a2 , a1 ) ) { p = a1 ; if ( m_arith . is_numeral ( a2 , k ) && k . is_zero ( ) ) { return true ; } } else { return false ; } p = mk_sub ( p , a2 ) ; simplify ( p ) ; return true ; }
bool is_divides ( app * e , numeral & k , expr_ref & p ) { expr * e1 , * e2 ; if ( ! m . is_eq ( e , e1 , e2 ) ) { return false ; } return is_divides ( e1 , e2 , k , p ) || is_divides ( e2 , e1 , k , p ) ; }
bool is_divides ( expr * e1 , expr * e2 , numeral & k , expr_ref & p ) { if ( m_arith . is_mod ( e2 ) && m_arith . is_numeral ( e1 , k ) && k . is_zero ( ) && m_arith . is_numeral ( to_app ( e2 ) -> get_arg ( 1 ) , k ) ) { p = to_app ( e2 ) -> get_arg ( 0 ) ; return true ; } return false ; }
bool is_not_divides ( app * e , app_ref & n , numeral & k , expr_ref & p ) { if ( ! m . is_not ( e ) ) { return false ; } if ( ! is_app ( to_app ( e ) -> get_arg ( 0 ) ) ) { return false ; } n = to_app ( to_app ( e ) -> get_arg ( 0 ) ) ; return is_divides ( n , k , p ) ; }
template < bool is_strict > void mk_bound_aux ( rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { SASSERT ( a . is_neg ( ) == b . is_neg ( ) ) ; expr_ref tt ( t , m ) , ss ( s , m ) , e ( m ) ; rational abs_a ( a ) ; rational abs_b ( b ) ; if ( abs_a . is_neg ( ) ) abs_a . neg ( ) ; if ( abs_b . is_neg ( ) ) abs_b . neg ( ) ; ss = mk_mul ( abs_a , ss ) ; tt = mk_mul ( abs_b , tt ) ; if ( a . is_neg ( ) ) { e = mk_sub ( tt , ss ) ; if ( is_strict ) { if ( m_arith . is_int ( e ) ) { e = mk_add ( e , m_one_i ) ; mk_le ( e , result ) ; } else { mk_lt ( e , result ) ; } } else { mk_le ( e , result ) ; } } else { e = mk_sub ( ss , tt ) ; if ( is_strict ) { if ( m_arith . is_int ( e ) ) { e = mk_add ( e , m_one_i ) ; mk_le ( e , result ) ; } else { mk_lt ( e , result ) ; } } else { mk_le ( e , result ) ; } } }
void mk_bound ( rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { mk_bound_aux < false > ( a , t , b , s , result ) ; }
void mk_strict_bound ( rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { mk_bound_aux < true > ( a , t , b , s , result ) ; }
void mk_divides ( numeral n , expr * e , expr_ref & result ) { SASSERT ( n . is_int ( ) ) ; expr_ref tmp1 ( e , m ) , tmp2 ( m ) ; simplify ( tmp1 ) ; m_arith_rewriter . mk_mod ( tmp1 , mk_numeral ( n ) , tmp2 ) ; m_bool_rewriter . mk_eq ( m_zero_i , tmp2 , result ) ; }
void mk_div ( expr * a , numeral const & k , expr_ref & result ) { result = m_arith . mk_div ( a , m_arith . mk_numeral ( k , false ) ) ; simplify ( result ) ; }
expr * mk_numeral ( numeral const & k , bool is_int = true ) { return m_arith . mk_numeral ( k , is_int ) ; }
expr * mk_numeral ( int k , bool is_int ) { return mk_numeral ( numeral ( k ) , is_int ) ; }
expr * mk_uminus ( expr * e ) { return m_arith . mk_uminus ( e ) ; }
expr * mk_abs ( expr * e ) { rational val ; if ( m_arith . is_numeral ( e , val ) ) { if ( val . is_neg ( ) ) { return m_arith . mk_uminus ( e ) ; } else { return e ; } } else { return m . mk_ite ( m_arith . mk_le ( mk_zero ( e ) , e ) , e , m_arith . mk_uminus ( e ) ) ; } }
template < bool is_max > expr_ref mk_min_max ( unsigned num_args , expr * const * args ) { SASSERT ( num_args > 0 ) ; if ( num_args == 1 ) { return expr_ref ( args [ 0 ] , m ) ; } else { expr_ref e2 = mk_min_max < is_max > ( num_args - 1 , args + 1 ) ; expr * e1 = args [ 0 ] ; expr * cmp = is_max ? m_arith . mk_le ( e1 , e2 ) : m_arith . mk_le ( e2 , e1 ) ; return expr_ref ( m . mk_ite ( cmp , e2 , e1 ) , m ) ; } }
expr_ref mk_max ( unsigned num_args , expr * const * args ) { return mk_min_max < true > ( num_args , args ) ; }
expr_ref mk_min ( unsigned num_args , expr * const * args ) { return mk_min_max < false > ( num_args , args ) ; }
expr * mk_mul ( expr * a , expr * b ) { return m_arith . mk_mul ( a , b ) ; }
expr * mk_add ( expr * a , expr * b ) { return m_arith . mk_add ( a , b ) ; }
expr * mk_sub ( expr * a , expr * b ) { return m_arith . mk_sub ( a , b ) ; }
expr * mk_mul ( numeral const & a , expr * b ) { if ( a . is_one ( ) ) return b ; return m_arith . mk_mul ( mk_numeral ( a , m_arith . is_int ( b ) ) , b ) ; }
expr * mk_zero ( sort * s ) { return m_arith . is_int ( s ) ? m_zero_i : m_zero_r ; }
expr * mk_zero ( expr * e ) { return m_arith . is_int ( e ) ? m_zero_i : m_zero_r ; }
expr * mk_one ( sort * s ) { return m_arith . is_int ( s ) ? m_one_i : m_one_r ; }
expr * mk_one ( expr * e ) { return m_arith . is_int ( e ) ? m_one_i : m_one_r ; }
void mk_le ( expr * e , expr_ref & result ) { expr_ref tmp ( e , m ) ; simplify ( tmp ) ; m_arith_rewriter . mk_le ( tmp , mk_zero ( e ) , result ) ; }
void mk_lt ( expr * e , expr_ref & result ) { rational r ; if ( m_arith . is_numeral ( e , r ) ) { if ( r . is_neg ( ) ) { result = m . mk_true ( ) ; } else { result = m . mk_false ( ) ; } } else if ( m_arith . is_int ( e ) ) { result = m_arith . mk_le ( e , m_minus_one_i ) ; } else { result = m . mk_not ( m_arith . mk_le ( mk_zero ( e ) , e ) ) ; } simplify ( result ) ; TRACE ( " qe _ verbose " , tout << " mk _ lt ▁ " << mk_pp ( result , m ) << " \n " ; ) ; }
void mk_eq ( rational const & a , app * x , expr * t , expr_ref & result ) { result = m_arith . mk_eq ( mk_add ( mk_mul ( a , x ) , t ) , mk_zero ( x ) ) ; }
void mk_and ( unsigned sz , expr * const * args , expr_ref & result ) { m_bool_rewriter . mk_and ( sz , args , result ) ; }
void mk_and ( expr * e1 , expr * e2 , expr_ref & result ) { m_bool_rewriter . mk_and ( e1 , e2 , result ) ; }
void add_and ( expr * e , ptr_vector < expr > & conjs ) { if ( m . is_and ( e ) ) { conjs . append ( to_app ( e ) -> get_num_args ( ) , to_app ( e ) -> get_args ( ) ) ; } else { conjs . push_back ( e ) ; } }
void mk_flat_and ( expr * e1 , expr * e2 , expr_ref & result ) { ptr_vector < expr > conjs ; add_and ( e1 , conjs ) ; add_and ( e2 , conjs ) ; m_bool_rewriter . mk_and ( conjs . size ( ) , conjs . c_ptr ( ) , result ) ; }
void mk_or ( unsigned sz , expr * const * args , expr_ref & result ) { m_bool_rewriter . mk_or ( sz , args , result ) ; }
void mk_or ( expr * e1 , expr * e2 , expr_ref & result ) { m_bool_rewriter . mk_or ( e1 , e2 , result ) ; }
void mk_resolve ( app * x , bool is_strict , rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { rational abs_a ( abs ( a ) ) , abs_b ( abs ( b ) ) ; SASSERT ( a . is_neg ( ) == b . is_pos ( ) ) ; SASSERT ( ! is_strict || ( abs_a . is_one ( ) && abs_b . is_one ( ) ) ) ; expr_ref bt ( mk_mul ( abs_b , t ) , m ) ; expr_ref as ( mk_mul ( abs_a , s ) , m ) ; expr_ref as_bt ( mk_add ( as , bt ) , m ) ; if ( is_strict ) { mk_lt ( as_bt , result ) ; } else { mk_le ( as_bt , result ) ; } if ( ! abs_a . is_one ( ) && ! abs_b . is_one ( ) ) { SASSERT ( ! is_strict ) ; SASSERT ( abs_a > rational :: one ( ) && abs_b > rational :: one ( ) ) ; expr_ref slack ( mk_numeral ( ( abs_a - numeral ( 1 ) ) * ( abs_b - numeral ( 1 ) ) , true ) , m ) ; expr_ref result1 ( m ) , result2 ( m ) ; expr_ref as_bt_le_0 ( result , m ) , tmp2 ( m ) , asz_bt_le_0 ( m ) , tmp3 ( m ) , tmp4 ( m ) ; expr_ref b_divides_sz ( m ) ; tmp2 = m_arith . mk_add ( as_bt , slack ) ; mk_le ( tmp2 , result1 ) ; rational a1 = a , b1 = b ; if ( abs_a < abs_b ) { std :: swap ( abs_a , abs_b ) ; std :: swap ( a1 , b1 ) ; std :: swap ( s , t ) ; std :: swap ( as , bt ) ; } SASSERT ( abs_a >= abs_b ) ; expr_ref sz ( mk_add ( s , x ) , m ) ; if ( b1 . is_pos ( ) ) { sz = m_arith . mk_uminus ( sz ) ; } tmp4 = mk_add ( mk_mul ( a1 , sz ) , bt ) ; mk_le ( tmp4 , asz_bt_le_0 ) ; if ( to_app ( asz_bt_le_0 ) -> get_arg ( 0 ) == x && m_arith . is_zero ( to_app ( asz_bt_le_0 ) -> get_arg ( 1 ) ) ) { mk_divides ( abs_b , s , tmp2 ) ; } else { mk_divides ( abs_b , sz , b_divides_sz ) ; mk_and ( b_divides_sz , asz_bt_le_0 , tmp4 ) ; mk_big_or ( abs_b - numeral ( 2 ) , x , tmp4 , tmp2 ) ; TRACE ( " qe " , tout << " b ▁ | ▁ s ▁ + ▁ z : ▁ " << mk_pp ( b_divides_sz , m ) << " \n " ; tout << " a ( s + z ) ▁ + ▁ bt ▁ < = ▁ 0 : ▁ " << mk_pp ( asz_bt_le_0 , m ) << " \n " ; ) ; } mk_flat_and ( as_bt_le_0 , tmp2 , result2 ) ; mk_or ( result1 , result2 , result ) ; simplify ( result ) ; } TRACE ( " qe " , { tout << ( is_strict ? " strict " : " non - strict " ) << " \n " ; bound ( m , a , t , false ) . pp ( tout , x ) ; tout << " \n " ; bound ( m , b , s , false ) . pp ( tout , x ) ; tout << " \n " ; tout << mk_pp ( result , m ) << " \n " ; } ) ; }
void normalize_sum ( expr_ref & p ) { simplify ( p ) ; if ( ! m_arith . is_add ( p ) ) { return ; } unsigned sz = to_app ( p ) -> get_num_args ( ) ; ptr_buffer < expr > args ; for ( unsigned i = 0 ; i < sz ; ++ i ) { args . push_back ( to_app ( p ) -> get_arg ( i ) ) ; } std :: sort ( args . begin ( ) , args . end ( ) , mul_lt ( * this ) ) ; p = m_arith . mk_add ( args . size ( ) , args . c_ptr ( ) ) ; }
void pp_div ( std :: ostream & out , app * x , div_constraint const & div ) { out << div . k ( ) << " ▁ | ▁ ( " << div . a ( ) << " * " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( div . t ( ) , m ) << " ) ▁ " ; }
void pp_divs ( std :: ostream & out , app * x , div_constraints const & divs ) { for ( unsigned i = 0 ; i < divs . size ( ) ; ++ i ) { pp_div ( out , x , divs [ i ] ) ; out << " ▁ " ; } }
bool mk_atom ( expr * e , bool p , expr_ref & result ) { if ( ! is_app ( e ) ) { return false ; } app * a = to_app ( e ) ; expr_ref t1 ( m ) , t2 ( m ) ; expr_ref tmp1 ( m ) , tmp2 ( m ) ; rational k ; expr * a0 , * a1 ; if ( p && is_divides ( a , k , tmp1 ) ) { result = e ; } else if ( ! p && is_divides ( a , k , tmp1 ) ) { m_bool_rewriter . mk_not ( e , result ) ; } else if ( p && m . is_eq ( e , a0 , a1 ) && is_arith ( a0 ) ) { t1 = mk_sub ( a0 , a1 ) ; simplify ( t1 ) ; t2 = mk_sub ( a1 , a0 ) ; simplify ( t2 ) ; mk_le ( t1 , tmp1 ) ; mk_le ( t2 , tmp2 ) ; mk_and ( tmp1 , tmp2 , result ) ; } else if ( ! p && m . is_eq ( e , a0 , a1 ) && m_arith . is_int ( a0 ) ) { tmp1 = mk_sub ( a0 , a1 ) ; t1 = mk_add ( mk_one ( a0 ) , tmp1 ) ; simplify ( t1 ) ; t2 = mk_sub ( mk_one ( a0 ) , tmp1 ) ; simplify ( t2 ) ; mk_le ( t1 , tmp1 ) ; mk_le ( t2 , tmp2 ) ; mk_or ( tmp1 , tmp2 , result ) ; } else if ( ! p && m . is_eq ( e , a0 , a1 ) && m_arith . is_real ( a0 ) ) { t1 = mk_sub ( a0 , a1 ) ; simplify ( t1 ) ; t2 = mk_sub ( a1 , a0 ) ; simplify ( t2 ) ; mk_lt ( t1 , tmp1 ) ; mk_lt ( t2 , tmp2 ) ; mk_or ( tmp1 , tmp2 , result ) ; } else if ( ! p && ( m_arith . is_le ( e , a0 , a1 ) || m_arith . is_ge ( e , a1 , a0 ) ) ) { tmp1 = mk_sub ( a1 , a0 ) ; mk_lt ( tmp1 , result ) ; } else if ( p && ( m_arith . is_le ( e ) || m_arith . is_ge ( e ) ) ) { result = e ; } else if ( p && ( m_arith . is_lt ( e , a0 , a1 ) || m_arith . is_gt ( e , a1 , a0 ) ) ) { tmp1 = mk_sub ( a0 , a1 ) ; mk_lt ( tmp1 , result ) ; } else if ( ! p && ( m_arith . is_lt ( e , a0 , a1 ) || m_arith . is_gt ( e , a1 , a0 ) ) ) { tmp1 = mk_sub ( a1 , a0 ) ; mk_le ( tmp1 , result ) ; } else { return false ; } TRACE ( " qe _ verbose " , tout << " Atom : ▁ " << mk_pp ( result , m ) << " \n " ; ) ; return true ; }
void mk_bounded_var ( rational const & n , app_ref & z_bv , app_ref & z ) { rational two ( 2 ) , b ( n ) ; unsigned sz = 0 ; do { ++ sz ; b = div ( b , two ) ; } while ( b . is_pos ( ) ) ; sort * s = m_bv . mk_sort ( sz ) ; z_bv = m . mk_fresh_const ( " z " , s ) ; expr_ref tmp ( m ) ; z = m_bv . mk_bv2int ( z_bv ) ; }
bool solve ( conj_enum & conjs , expr * fml ) { expr_ref_vector eqs ( m ) ; extract_equalities ( conjs , eqs ) ; return reduce_equations ( eqs . size ( ) , eqs . c_ptr ( ) , fml ) ; }
void extract_equalities ( conj_enum & conjs , expr_ref_vector & eqs ) { obj_hashtable < expr > leqs ; expr_ref_vector trail ( m ) ; expr_ref tmp1 ( m ) , tmp2 ( m ) ; expr * a0 , * a1 ; eqs . reset ( ) ; conj_enum :: iterator it = conjs . begin ( ) , end = conjs . end ( ) ; for ( ; it != end ; ++ it ) { expr * e = * it ; bool is_leq = false ; if ( m . is_eq ( e , a0 , a1 ) && is_arith ( a0 ) ) { m_arith_rewriter . mk_sub ( a0 , a1 , tmp1 ) ; simplify ( tmp1 ) ; eqs . push_back ( tmp1 ) ; } else if ( m_arith . is_le ( e , a0 , a1 ) || m_arith . is_ge ( e , a1 , a0 ) ) { m_arith_rewriter . mk_sub ( a0 , a1 , tmp1 ) ; is_leq = true ; } else { } if ( is_leq ) { normalize_sum ( tmp1 ) ; tmp2 = m_arith . mk_uminus ( tmp1 ) ; normalize_sum ( tmp2 ) ; if ( leqs . contains ( tmp2 ) ) { eqs . push_back ( tmp1 ) ; TRACE ( " qe " , tout << " found : ▁ ▁ " << mk_pp ( tmp1 , m ) << " \n " ; ) ; } else { trail . push_back ( tmp1 ) ; leqs . insert ( tmp1 ) ; TRACE ( " qe _ verbose " , tout << " insert : ▁ " << mk_pp ( tmp1 , m ) << " \n " ; ) ; } } } }
private : template < unsigned IS_LE > bool is_le_ge_core ( app * e , expr_ref & p ) { numeral k ; expr_ref tmp ( m ) ; expr * a2 ; if ( m_arith . is_le ( e ) ) { p = e -> get_arg ( 1 - IS_LE ) ; a2 = e -> get_arg ( IS_LE ) ; if ( m_arith . is_numeral ( a2 , k ) && k . is_zero ( ) ) { return true ; } } else if ( m_arith . is_ge ( e ) ) { p = e -> get_arg ( IS_LE ) ; a2 = e -> get_arg ( 1 - IS_LE ) ; if ( m_arith . is_numeral ( a2 , k ) && k . is_zero ( ) ) { return true ; } } else { return false ; } p = mk_sub ( p , a2 ) ; simplify ( p ) ; return true ; }
bool is_arith ( expr * e ) { return m_arith . is_int ( e ) || m_arith . is_real ( e ) ; }
void mk_big_or ( numeral up , app * x , expr * body , expr_ref & result ) { TRACE ( " qe " , tout << mk_pp ( x , m ) << " ▁ " << mk_pp ( body , m ) << " \n " ; ) ; if ( numeral ( 1 ) >= up ) { mk_big_or_blast ( up , x , body , result ) ; } else { mk_big_or_symbolic_blast ( up , x , body , result ) ; } }
void mk_big_or_blast ( numeral up , app * x , expr * body , expr_ref & result ) { expr_ref_vector ors ( m ) ; numeral index ( 0 ) ; while ( index <= up ) { expr * n = mk_numeral ( index ) ; result = body ; m_replace . apply_substitution ( x , n , result ) ; ors . push_back ( result ) ; ++ index ; } mk_or ( ors . size ( ) , ors . c_ptr ( ) , result ) ; TRACE ( " qe " , tout << " [ 0 ▁ " << up << " ] ▁ " << mk_pp ( x , m ) << " \n " << mk_pp ( body , m ) << " \n " << mk_pp ( result , m ) << " \n " ; ) ; }
void mk_big_or_symbolic ( numeral up , app * x , expr * body , expr_ref & result ) { app_ref z_bv ( m ) ; mk_big_or_symbolic ( up , x , body , z_bv , result ) ; m_ctx . add_var ( z_bv ) ; }
void mk_big_or_symbolic_blast ( numeral up , app * x , expr * body , expr_ref & result ) { app_ref z_bv ( m ) ; mk_big_or_symbolic ( up , x , body , z_bv , result ) ; m_ctx . blast_or ( z_bv , result ) ; }
void mk_big_or_symbolic ( numeral up , app * x , expr * body , app_ref & z_bv , expr_ref & result ) { expr * e1 = m_arith . mk_le ( x , m_arith . mk_numeral ( up , true ) ) ; mk_flat_and ( e1 , body , result ) ; app_ref z ( m ) ; mk_bounded_var ( up , z_bv , z ) ; m_replace . apply_substitution ( x , z , result ) ; }
bool isolate_x ( expr * p , app * x , contains_app & contains_x , numeral & coeff ) { numeral k ; while ( m_arith . is_add ( p ) ) { bool found_x = false ; expr * next_p = 0 ; for ( unsigned i = 0 ; i < to_app ( p ) -> get_num_args ( ) ; ++ i ) { expr * arg = to_app ( p ) -> get_arg ( i ) ; if ( contains_x ( arg ) ) { if ( found_x ) { return false ; } found_x = true ; next_p = arg ; } } if ( ! next_p ) { return false ; } p = next_p ; } expr * e1 , * e2 ; if ( p == x ) { coeff = numeral ( 1 ) ; return true ; } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e1 , k ) && e2 == x ) { coeff = k ; return true ; } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e2 , k ) && e1 == x ) { coeff = k ; return true ; } return false ; }
bool reduce_equations ( unsigned num_eqs , expr * const * eqs , expr * fml ) { for ( unsigned i = 0 ; i < num_eqs ; ++ i ) { if ( reduce_equation ( eqs [ i ] , fml ) ) { return true ; } } return false ; }
bool solve_singular ( unsigned var_idx , expr * p , expr * fml ) { rational k ; expr_ref e ( m ) , tmp ( m ) ; app * x = m_ctx . get_var ( var_idx ) ; if ( ! isolate_x ( p , x , m_ctx . contains ( var_idx ) , k ) ) { return false ; } if ( m_arith . is_int ( x ) && ! ( abs ( k ) . is_one ( ) ) ) { return false ; } if ( abs ( k ) . is_one ( ) ) { if ( k . is_neg ( ) ) { e = m_arith . mk_add ( p , x ) ; } else { e = m_arith . mk_sub ( x , p ) ; } } else { SASSERT ( ! m_arith . is_int ( x ) ) ; expr * ke = m_arith . mk_numeral ( - k , false ) ; tmp = m_arith . mk_mul ( ke , x ) ; tmp = m_arith . mk_add ( p , tmp ) ; e = m_arith . mk_div ( tmp , ke ) ; } TRACE ( " qe " , tout << " is ▁ singular : \n " << mk_pp ( p , m ) << " \n " << mk_pp ( fml , m ) << " \n " << mk_pp ( x , m ) << " ▁ = ▁ " << mk_pp ( e , m ) << " \n " ; ) ; expr_ref result ( fml , m ) ; m_replace . apply_substitution ( x , e , result ) ; simplify ( result ) ; TRACE ( " qe " , tout << " singular ▁ solved : \n " << mk_pp ( result , m ) << " \n " ; ) ; m_ctx . elim_var ( var_idx , result , e ) ; return true ; }
bool solve_singular ( expr * p , expr * fml ) { unsigned num_vars = m_ctx . get_num_vars ( ) ; for ( unsigned i = 0 ; i < num_vars ; ++ i ) { if ( solve_singular ( i , p , fml ) ) { return true ; } } return false ; }
bool solve_linear ( expr * p , expr * fml ) { vector < numeral > values ; unsigned num_vars = m_ctx . get_num_vars ( ) ; app * const * vars_ptr = m_ctx . get_vars ( ) ; if ( ! is_linear ( p , num_vars , vars_ptr , values ) ) { return false ; } TRACE ( " qe " , tout << " is ▁ linear : ▁ " << mk_pp ( p , m ) << " \n " ; ) ; SASSERT ( values . size ( ) == num_vars + 1 ) ; SASSERT ( num_vars > 0 ) ; unsigned index ; bool is_aux ; VERIFY ( m_arith_solver . solve_integer_equation ( values , index , is_aux ) ) ; SASSERT ( 1 <= index && index <= num_vars ) ; app_ref x ( m_ctx . get_var ( index - 1 ) , m ) ; app_ref z ( m ) ; expr_ref p1 ( m ) ; if ( is_aux ) { SASSERT ( values [ index ] >= rational ( 3 ) ) ; z = m . mk_fresh_const ( " x " , m_arith . mk_int ( ) ) ; m_ctx . add_var ( z ) ; p1 = m_arith . mk_mul ( m_arith . mk_numeral ( values [ index ] , true ) , z ) ; } else { p1 = m_arith . mk_numeral ( numeral ( 0 ) , true ) ; } for ( unsigned i = 1 ; i <= num_vars ; ++ i ) { numeral k = values [ i ] ; if ( ! k . is_zero ( ) && i != index ) { p1 = m_arith . mk_add ( p1 , m_arith . mk_mul ( m_arith . mk_numeral ( k , true ) , m_ctx . get_var ( i - 1 ) ) ) ; } } p1 = m_arith . mk_add ( p1 , m_arith . mk_numeral ( values [ 0 ] , true ) ) ; TRACE ( " qe " , tout << " is ▁ linear : \n " << mk_pp ( fml , m ) << " \n " << mk_pp ( p , m ) << " \n " << mk_pp ( x , m ) << " ▁ = ▁ " << mk_pp ( p1 , m ) << " \n " ; tout << values [ 0 ] << " ▁ + ▁ " ; for ( unsigned i = 0 ; i < num_vars ; ++ i ) { tout << " ▁ + ▁ " << values [ i + 1 ] << " ▁ * ▁ " << mk_pp ( m_ctx . get_var ( i ) , m ) << " ▁ " ; } tout << " ▁ = ▁ 0 \n " ; ) ; expr_ref result ( fml , m ) ; m_replace . apply_substitution ( x , p1 , result ) ; simplify ( result ) ; m_ctx . elim_var ( index - 1 , result , p1 ) ; TRACE ( " qe " , tout << " Reduced : ▁ " << mk_pp ( result , m ) << " \n " ; ) ; return true ; }
bool reduce_equation ( expr * p , expr * fml ) { numeral k ; if ( m_arith . is_numeral ( p , k ) && k . is_zero ( ) ) { return false ; } return solve_singular ( p , fml ) || solve_linear ( p , fml ) ; }
bool find_variable ( expr * p , unsigned num_vars , app * const * vars , numeral * values , numeral const & k ) { if ( ! is_app ( p ) || to_app ( p ) -> get_num_args ( ) > 0 ) { return false ; } for ( unsigned i = 0 ; i < num_vars ; ++ i ) { if ( p == vars [ i ] ) { values [ i ] += k ; return true ; } } return false ; }
bool is_linear ( expr * p , unsigned num_vars , app * const * vars , vector < numeral > & values ) { if ( num_vars == 0 ) { return false ; } values . reset ( ) ; for ( unsigned i = 0 ; i <= num_vars ; ++ i ) { values . push_back ( numeral ( 0 ) ) ; } numeral * vars_ptr = values . c_ptr ( ) + 1 ; ptr_vector < expr > todo ; numeral k ; expr * e1 , * e2 ; todo . push_back ( p ) ; while ( ! todo . empty ( ) ) { p = todo . back ( ) ; todo . pop_back ( ) ; if ( m_arith . is_add ( p ) ) { for ( unsigned i = 0 ; i < to_app ( p ) -> get_num_args ( ) ; ++ i ) { todo . push_back ( to_app ( p ) -> get_arg ( i ) ) ; } } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e1 , k ) && find_variable ( e2 , num_vars , vars , vars_ptr , k ) ) { } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e2 , k ) && find_variable ( e1 , num_vars , vars , vars_ptr , k ) ) { } else if ( find_variable ( p , num_vars , vars , vars_ptr , k ) ) { } else if ( m_arith . is_numeral ( p , k ) ) { values [ 0 ] += k ; } else { TRACE ( " qe _ verbose " , tout << " non - linear ▁ " << mk_pp ( p , m ) << " \n " ; ) ; return false ; } } return true ; }
public : bounds_proc ( arith_qe_util & u ) : m_util ( u ) , m_le_terms ( u . get_manager ( ) ) , m_ge_terms ( u . get_manager ( ) ) , m_lt_terms ( u . get_manager ( ) ) , m_gt_terms ( u . get_manager ( ) ) , m_le_atoms ( u . get_manager ( ) ) , m_ge_atoms ( u . get_manager ( ) ) , m_lt_atoms ( u . get_manager ( ) ) , m_gt_atoms ( u . get_manager ( ) ) , m_div_terms ( u . get_manager ( ) ) , m_div_atoms ( u . get_manager ( ) ) , m_div_z ( u . get_manager ( ) ) , m_nested_div_terms ( u . get_manager ( ) ) , m_nested_div_atoms ( u . get_manager ( ) ) , m_nested_div_z ( u . get_manager ( ) ) { reset ( ) ; }
bool get_bound ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; app * x = contains_x . x ( ) ; if ( m_mark . is_marked ( a ) || get_le_bound ( contains_x , a ) || get_lt_bound ( contains_x , a ) || get_divides ( contains_x , a ) || get_nested_divs ( contains_x , a ) ) { TRACE ( " qe _ verbose " , tout << " Bound ▁ for ▁ " << mk_pp ( x , m ) << " ▁ within ▁ " << mk_pp ( a , m ) << " \n " ; ) ; m_mark . mark ( a , true ) ; return true ; } else { TRACE ( " qe " , tout << " No ▁ bound ▁ for ▁ " << mk_pp ( x , m ) << " ▁ within ▁ " << mk_pp ( a , m ) << " \n " ; ) ; return false ; } }
unsigned lt_size ( ) { return m_lt_terms . size ( ) ; }
unsigned le_size ( ) { return m_le_terms . size ( ) ; }
unsigned gt_size ( ) { return m_gt_terms . size ( ) ; }
unsigned ge_size ( ) { return m_ge_terms . size ( ) ; }
unsigned t_size ( bool is_l ) { return is_l ? lt_size ( ) : gt_size ( ) ; }
unsigned e_size ( bool is_l ) { return is_l ? le_size ( ) : ge_size ( ) ; }
unsigned size ( bool is_strict , bool is_l ) { return is_strict ? t_size ( is_l ) : e_size ( is_l ) ; }
expr * const * lt ( ) { return m_lt_terms . c_ptr ( ) ; }
expr * const * le ( ) { return m_le_terms . c_ptr ( ) ; }
expr * const * gt ( ) { return m_gt_terms . c_ptr ( ) ; }
expr * const * ge ( ) { return m_ge_terms . c_ptr ( ) ; }
expr * const * t ( bool is_l ) { return is_l ? lt ( ) : gt ( ) ; }
expr * const * e ( bool is_l ) { return is_l ? le ( ) : ge ( ) ; }
expr * const * exprs ( bool is_strict , bool is_l ) { return is_strict ? t ( is_l ) : e ( is_l ) ; }
rational const * lt_coeffs ( ) { return m_lt_coeffs . c_ptr ( ) ; }
rational const * le_coeffs ( ) { return m_le_coeffs . c_ptr ( ) ; }
rational const * gt_coeffs ( ) { return m_gt_coeffs . c_ptr ( ) ; }
rational const * ge_coeffs ( ) { return m_ge_coeffs . c_ptr ( ) ; }
rational const * t_coeffs ( bool is_l ) { return is_l ? lt_coeffs ( ) : gt_coeffs ( ) ; }
rational const * e_coeffs ( bool is_l ) { return is_l ? le_coeffs ( ) : ge_coeffs ( ) ; }
rational const * coeffs ( bool is_strict , bool is_l ) { return is_strict ? t_coeffs ( is_l ) : e_coeffs ( is_l ) ; }
app * const * lt_atoms ( ) { return m_lt_atoms . c_ptr ( ) ; }
app * const * le_atoms ( ) { return m_le_atoms . c_ptr ( ) ; }
app * const * gt_atoms ( ) { return m_gt_atoms . c_ptr ( ) ; }
app * const * ge_atoms ( ) { return m_ge_atoms . c_ptr ( ) ; }
app * const * t_atoms ( bool is_l ) { return is_l ? lt_atoms ( ) : gt_atoms ( ) ; }
app * const * e_atoms ( bool is_l ) { return is_l ? le_atoms ( ) : ge_atoms ( ) ; }
app * const * atoms ( bool is_strict , bool is_l ) { return is_strict ? t_atoms ( is_l ) : e_atoms ( is_l ) ; }
app * const * div_atoms ( ) { return m_div_atoms . c_ptr ( ) ; }
rational const * div_coeffs ( ) { return m_div_coeffs . c_ptr ( ) ; }
expr * const * div_terms ( ) { return m_div_terms . c_ptr ( ) ; }
rational const * divisors ( ) { return m_div_divisors . c_ptr ( ) ; }
bool div_z ( rational & d , app_ref & z_bv , app_ref & z ) { if ( m_div_z . get ( ) ) { z = m_div_z ; z_bv = to_app ( z -> get_arg ( 0 ) ) ; d = m_d ; return true ; } if ( m_div_terms . empty ( ) && m_nested_div_terms . empty ( ) ) { return false ; } m_d = rational ( 1 ) ; for ( unsigned i = 0 ; i < m_div_divisors . size ( ) ; ++ i ) { m_d = lcm ( m_div_divisors [ i ] , m_d ) ; } for ( unsigned i = 0 ; i < m_nested_div_divisors . size ( ) ; ++ i ) { m_d = lcm ( m_nested_div_divisors [ i ] , m_d ) ; } if ( abs ( m_d ) . is_one ( ) ) { return false ; } m_util . mk_bounded_var ( m_d , z_bv , m_div_z ) ; z = m_div_z ; d = m_d ; return true ; }
app * nested_div_atom ( unsigned idx ) { return m_nested_div_atoms [ idx ] . get ( ) ; }
rational const & nested_div_coeff ( unsigned idx ) { return m_nested_div_coeffs [ idx ] ; }
expr * nested_div_term ( unsigned idx ) { return m_nested_div_terms [ idx ] . get ( ) ; }
rational const & nested_divisor ( unsigned idx ) { return m_nested_div_divisors [ idx ] ; }
app * nested_div_z ( unsigned idx ) { return m_nested_div_z [ idx ] . get ( ) ; }
app * nested_div_z_bv ( unsigned idx ) { return to_app ( m_nested_div_z [ idx ] -> get_arg ( 0 ) ) ; }
void reset ( ) { m_lt_terms . reset ( ) ; m_gt_terms . reset ( ) ; m_ge_terms . reset ( ) ; m_le_terms . reset ( ) ; m_gt_coeffs . reset ( ) ; m_lt_coeffs . reset ( ) ; m_ge_coeffs . reset ( ) ; m_le_coeffs . reset ( ) ; m_lt_atoms . reset ( ) ; m_gt_atoms . reset ( ) ; m_le_atoms . reset ( ) ; m_ge_atoms . reset ( ) ; m_div_terms . reset ( ) ; m_div_coeffs . reset ( ) ; m_div_divisors . reset ( ) ; m_div_atoms . reset ( ) ; m_div_z = 0 ; m_nested_div_terms . reset ( ) ; m_nested_div_coeffs . reset ( ) ; m_nested_div_divisors . reset ( ) ; m_nested_div_atoms . reset ( ) ; m_nested_div_z . reset ( ) ; }
private : bool get_nested_divs ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; ptr_vector < expr > todo ; todo . push_back ( a ) ; rational k1 , k2 ; expr_ref rest ( m ) ; while ( ! todo . empty ( ) ) { expr * e = todo . back ( ) ; todo . pop_back ( ) ; if ( m_mark . is_marked ( e ) ) { continue ; } m_mark . mark ( e , true ) ; if ( ! contains_x ( e ) ) { continue ; } if ( contains_x . x ( ) == e ) { return false ; } if ( ! is_app ( e ) ) { return false ; } a = to_app ( e ) ; if ( m_util . m_arith . is_mod ( e ) && m_util . m_arith . is_numeral ( to_app ( e ) -> get_arg ( 1 ) , k1 ) && m_util . get_coeff ( contains_x , to_app ( e ) -> get_arg ( 0 ) , k2 , rest ) ) { app_ref z ( m ) , z_bv ( m ) ; m_util . mk_bounded_var ( k1 , z_bv , z ) ; m_nested_div_terms . push_back ( rest ) ; m_nested_div_divisors . push_back ( k1 ) ; m_nested_div_coeffs . push_back ( k2 ) ; m_nested_div_atoms . push_back ( a ) ; m_nested_div_z . push_back ( z ) ; continue ; } unsigned num_args = a -> get_num_args ( ) ; for ( unsigned i = 0 ; i < num_args ; ++ i ) { todo . push_back ( a -> get_arg ( i ) ) ; } } return true ; }
bool get_le_bound ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; expr_ref p ( m ) , rest ( m ) ; rational k ; if ( m_util . is_le ( a , p ) && m_util . get_coeff ( contains_x , p , k , rest ) ) { if ( m_util . is_real ( contains_x . x ( ) ) ) { m_util . mk_div ( rest , abs ( k ) , rest ) ; k = k . is_pos ( ) ? rational :: one ( ) : rational :: minus_one ( ) ; } if ( k . is_neg ( ) ) { m_le_terms . push_back ( rest ) ; m_le_coeffs . push_back ( k ) ; m_le_atoms . push_back ( a ) ; } else { m_ge_terms . push_back ( rest ) ; m_ge_coeffs . push_back ( k ) ; m_ge_atoms . push_back ( a ) ; } return true ; } return false ; }
bool get_lt_bound ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; expr_ref p ( m ) , rest ( m ) , na ( m ) ; rational k ; if ( m_util . is_lt ( a , p ) && m_util . get_coeff ( contains_x , p , k , rest ) ) { } else if ( m_util . is_neg ( a , na ) && is_app ( na ) && m_util . is_ge ( to_app ( na ) , p ) && m_util . get_coeff ( contains_x , p , k , rest ) ) { } else { return false ; } SASSERT ( m_util . is_real ( contains_x . x ( ) ) ) ; m_util . mk_div ( rest , abs ( k ) , rest ) ; if ( k . is_neg ( ) ) { m_lt_terms . push_back ( rest ) ; m_lt_coeffs . push_back ( rational :: minus_one ( ) ) ; m_lt_atoms . push_back ( a ) ; } else { m_gt_terms . push_back ( rest ) ; m_gt_coeffs . push_back ( rational :: one ( ) ) ; m_gt_atoms . push_back ( a ) ; } return true ; }
bool get_divides ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; expr_ref p ( m ) , rest ( m ) ; app_ref a2 ( m ) ; numeral k , k2 ; if ( m_util . is_divides ( a , k , p ) && m_util . get_coeff ( contains_x , p , k2 , rest ) ) { m_div_terms . push_back ( rest ) ; m_div_divisors . push_back ( k ) ; m_div_coeffs . push_back ( k2 ) ; m_div_atoms . push_back ( a ) ; return true ; } if ( m_util . is_not_divides ( a , a2 , k , p ) && m_util . get_coeff ( contains_x , p , k2 , rest ) ) { m_div_terms . push_back ( rest ) ; m_div_divisors . push_back ( k ) ; m_div_coeffs . push_back ( k2 ) ; m_div_atoms . push_back ( a2 ) ; return true ; } return false ; }
public : void display ( std :: ostream & out ) { ast_manager & m = m_util . get_manager ( ) ; for ( unsigned i = 0 ; i < lt_size ( ) ; ++ i ) { out << mk_pp ( lt ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } for ( unsigned i = 0 ; i < le_size ( ) ; ++ i ) { out << mk_pp ( le ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } for ( unsigned i = 0 ; i < gt_size ( ) ; ++ i ) { out << mk_pp ( gt ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } for ( unsigned i = 0 ; i < ge_size ( ) ; ++ i ) { out << mk_pp ( ge ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } }
void set_term ( expr * t ) { m_t = t ; }
void set_coeff ( rational const & k ) { m_coeff = k ; }
expr_ref mk_term ( rational const & c , expr * t ) { ast_manager & m = m_super . get_manager ( ) ; if ( m_t . get ( ) ) { return expr_ref ( m_super . mk_add ( m_super . mk_mul ( c , m_t ) , t ) , m ) ; } else { return expr_ref ( t , m ) ; } }
rational mk_coeff ( rational const & k ) { return k * m_coeff ; }
~ arith_plugin ( ) { bounds_cache :: iterator it = m_bounds_cache . begin ( ) , end = m_bounds_cache . end ( ) ; for ( ; it != end ; ++ it ) { dealloc ( it -> get_value ( ) ) ; } }
virtual void assign ( contains_app & contains_x , expr * fml , rational const & vl ) { SASSERT ( vl . is_unsigned ( ) ) ; app * x = contains_x . x ( ) ; unsigned v = vl . get_unsigned ( ) ; expr_ref result ( fml , m ) ; unsigned t_size , e_size ; x_subst x_t ( m_util ) ; if ( get_cache ( x , fml , v , result ) ) { return ; } bounds_proc & bounds = get_bounds ( x , fml ) ; bool is_lower = get_bound_sizes ( bounds , x , t_size , e_size ) ; assign_nested_divs ( contains_x , bounds , result ) ; assign_divs ( contains_x , bounds , x_t , result ) ; if ( v == 0 ) { mk_non_bounds ( bounds , true , is_lower , result ) ; mk_non_bounds ( bounds , false , is_lower , result ) ; mk_non_resolve ( bounds , true , is_lower , result ) ; mk_non_resolve ( bounds , false , is_lower , result ) ; m_util . simplify ( result ) ; add_cache ( x , fml , v , result , x_t . get_coeff ( ) , x_t . get_term ( ) ) ; TRACE ( " qe " , tout << vl << " ▁ " << mk_pp ( x , m ) << " ▁ infinite ▁ case \n " ; tout << mk_pp ( fml , m ) << " \n " ; tout << mk_pp ( result , m ) << " \n " ; ) ; return ; } unsigned index = v - 1 ; bool is_strict = e_size <= index ; bool is_eq = false ; SASSERT ( index < t_size + e_size ) ; if ( is_strict ) { index -= e_size ; TRACE ( " qe _ verbose " , bounds . display ( tout ) ; ) ; } else if ( m_util . is_real ( x ) ) { SASSERT ( 0 == ( e_size & 0x1 ) ) ; is_eq = ( 0 == ( index & 0x1 ) ) ; index /= 2 ; e_size /= 2 ; } SASSERT ( is_strict || index < e_size ) ; SASSERT ( ! is_strict || index < t_size ) ; SASSERT ( index < bounds . size ( is_strict , is_lower ) ) ; expr_ref t ( bounds . exprs ( is_strict , is_lower ) [ index ] , m ) ; rational a = bounds . coeffs ( is_strict , is_lower ) [ index ] ; mk_bounds ( bounds , x , true , is_eq , is_strict , is_lower , index , a , t , result ) ; mk_bounds ( bounds , x , false , is_eq , is_strict , is_lower , index , a , t , result ) ; t = x_t . mk_term ( a , t ) ; a = x_t . mk_coeff ( a ) ; mk_resolve ( bounds , x , x_t , true , is_eq , is_strict , is_lower , index , a , t , result ) ; mk_resolve ( bounds , x , x_t , false , is_eq , is_strict , is_lower , index , a , t , result ) ; m_util . simplify ( result ) ; add_cache ( x , fml , v , result , x_t . get_coeff ( ) , x_t . get_term ( ) ) ; TRACE ( " qe " , { tout << vl << " ▁ " << mk_pp ( bounds . atoms ( is_strict , is_lower ) [ index ] , m ) << " \n " ; tout << mk_pp ( fml , m ) << " \n " ; tout << mk_pp ( result , m ) << " \n " ; } ) ; }
virtual bool get_num_branches ( contains_app & contains_x , expr * fml , rational & nb ) { app * x = contains_x . x ( ) ; if ( ! update_bounds ( contains_x , fml ) ) { return false ; } bounds_proc & bounds = get_bounds ( x , fml ) ; unsigned t_size , e_size ; get_bound_sizes ( bounds , x , t_size , e_size ) ; nb = rational ( t_size + e_size + 1 ) ; return true ; }
virtual void subst ( contains_app & contains_x , rational const & vl , expr_ref & fml , expr_ref * def ) { SASSERT ( vl . is_unsigned ( ) ) ; if ( def ) { get_def ( contains_x , vl . get_unsigned ( ) , fml , * def ) ; } VERIFY ( get_cache ( contains_x . x ( ) , fml , vl . get_unsigned ( ) , fml ) ) ; TRACE ( " qe " , tout << mk_pp ( contains_x . x ( ) , m ) << " ▁ " << vl << " \n " << mk_pp ( fml , m ) << " \n " ; ) ; }
virtual bool project ( contains_app & x , model_ref & model , expr_ref & fml ) { if ( ! update_bounds ( x , fml ) ) { TRACE ( " qe " , tout << mk_pp ( x . x ( ) , m ) << " ▁ failed ▁ to ▁ update ▁ bounds \n " ; ) ; return false ; } if ( m_util . m_arith . is_real ( x . x ( ) ) ) { return project_real ( x , model , fml ) ; } else { return project_int ( x , model , fml ) ; } }
virtual unsigned get_weight ( contains_app & contains_x , expr * fml ) { return 2 ; }
virtual bool solve ( conj_enum & conjs , expr * fml ) { return m_util . solve ( conjs , fml ) ; }
virtual bool mk_atom ( expr * e , bool p , expr_ref & result ) { return m_util . mk_atom ( e , p , result ) ; }
virtual bool is_uninterpreted ( app * f ) { switch ( f -> get_decl_kind ( ) ) { case OP_NUM : case OP_LE : case OP_LT : case OP_GE : case OP_GT : case OP_ADD : case OP_SUB : case OP_UMINUS : return false ; case OP_MOD : if ( m_util . m_arith . is_numeral ( f -> get_arg ( 1 ) ) ) { return false ; } return true ; case OP_MUL : { arith_util & a = m_util . m_arith ; expr * m , * n ; if ( a . is_mul ( f , m , n ) && ( a . is_numeral ( m ) || a . is_numeral ( n ) ) ) { return false ; } return true ; } default : return true ; } }
private : expr_ref mk_idiv ( expr * e , numeral k ) { SASSERT ( ! k . is_zero ( ) ) ; arith_util & a = m_util . m_arith ; if ( k . is_one ( ) ) { return expr_ref ( e , m ) ; } if ( k . is_minus_one ( ) ) { return expr_ref ( a . mk_uminus ( e ) , m ) ; } SASSERT ( a . is_int ( e ) ) ; return expr_ref ( a . mk_idiv ( e , a . mk_numeral ( k , true ) ) , m ) ; }
void get_def ( contains_app & contains_x , unsigned v , expr * fml , expr_ref & def ) { app * x = contains_x . x ( ) ; x_subst x_t ( m_util ) ; bounds_proc & bounds = get_bounds ( x , fml ) ; branch_formula bf ; VERIFY ( m_subst . find ( branch_formula ( fml , x , v , 0 , rational :: zero ( ) , 0 ) , bf ) ) ; x_t . set_term ( bf . m_term ) ; x_t . set_coeff ( bf . m_coeff ) ; CTRACE ( " qe " , x_t . get_term ( ) , tout << x_t . get_coeff ( ) << " ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; unsigned t_size , e_size , sz ; bool is_lower = get_bound_sizes ( bounds , x , t_size , e_size ) ; bool is_strict ; if ( v == 0 ) { is_strict = false ; sz = bounds . size ( is_strict , ! is_lower ) ; expr_ref_vector terms ( m ) ; if ( sz == 0 ) { terms . push_back ( m_util . mk_zero ( x ) ) ; } for ( unsigned i = 0 ; i < sz ; ++ i ) { expr_ref term ( bounds . exprs ( is_strict , ! is_lower ) [ i ] , m ) ; rational a = bounds . coeffs ( is_strict , ! is_lower ) [ i ] ; if ( x_t . get_term ( ) ) { TRACE ( " qe " , tout << x_t . get_coeff ( ) << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; SASSERT ( x_t . get_coeff ( ) . is_pos ( ) ) ; term = m_util . mk_add ( term , m_util . mk_mul ( a , x_t . get_term ( ) ) ) ; a = a * x_t . get_coeff ( ) ; } TRACE ( " qe " , tout << a << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( term , m ) << " ▁ < = ▁ 0 \n " ; ) ; SASSERT ( a . is_int ( ) ) ; SASSERT ( is_lower == a . is_pos ( ) ) ; term = m_util . mk_uminus ( term ) ; term = mk_idiv ( term , a ) ; terms . push_back ( term ) ; TRACE ( " qe " , tout << " a : ▁ " << a << " ▁ term : ▁ " << mk_pp ( term , m ) << " \n " ; ) ; } is_strict = true ; sz = bounds . size ( is_strict , ! is_lower ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { expr_ref term ( bounds . exprs ( is_strict , ! is_lower ) [ i ] , m ) ; SASSERT ( abs ( bounds . coeffs ( is_strict , ! is_lower ) [ i ] ) . is_one ( ) ) ; if ( is_lower ) { term = m_util . mk_uminus ( m_util . mk_add ( term , m_util . mk_one ( x ) ) ) ; } else { term = m_util . mk_add ( term , m_util . mk_one ( x ) ) ; } terms . push_back ( term ) ; } if ( is_lower ) { def = m_util . mk_min ( terms . size ( ) , terms . c_ptr ( ) ) ; } else { def = m_util . mk_max ( terms . size ( ) , terms . c_ptr ( ) ) ; } if ( x_t . get_term ( ) ) { TRACE ( " qe " , tout << x_t . get_coeff ( ) << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; def = m_util . mk_add ( m_util . mk_mul ( x_t . get_coeff ( ) , def ) , x_t . get_term ( ) ) ; } m_util . simplify ( def ) ; return ; } -- v ; is_strict = e_size <= v ; SASSERT ( v < t_size + e_size ) ; if ( is_strict ) { v -= e_size ; TRACE ( " qe _ verbose " , bounds . display ( tout ) ; ) ; } else if ( m_util . is_real ( x ) ) { SASSERT ( 0 == ( e_size & 0x1 ) ) ; v /= 2 ; e_size /= 2 ; } SASSERT ( is_strict || v < e_size ) ; SASSERT ( ! is_strict || v < t_size ) ; SASSERT ( v < bounds . size ( is_strict , is_lower ) ) ; def = bounds . exprs ( is_strict , is_lower ) [ v ] ; rational a = bounds . coeffs ( is_strict , is_lower ) [ v ] ; if ( x_t . get_term ( ) ) { TRACE ( " qe " , tout << x_t . get_coeff ( ) << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; SASSERT ( x_t . get_coeff ( ) . is_pos ( ) ) ; def = m_util . mk_add ( def , m_util . mk_mul ( a , x_t . get_term ( ) ) ) ; a = a * x_t . get_coeff ( ) ; } SASSERT ( a . is_int ( ) ) ; SASSERT ( is_lower != a . is_pos ( ) ) ; def = m_util . mk_uminus ( def ) ; def = mk_idiv ( def , a ) ; if ( x_t . get_term ( ) ) { def = m_util . mk_add ( m_util . mk_mul ( x_t . get_coeff ( ) , def ) , x_t . get_term ( ) ) ; } if ( is_strict ) { SASSERT ( m_util . m_arith . is_real ( x ) ) ; def = m_util . mk_sub ( def , m_util . mk_one ( x ) ) ; } m_util . simplify ( def ) ; TRACE ( " qe " , tout << " TBD ▁ ( for ▁ Real ) : ▁ " << a << " ▁ " << mk_pp ( def , m ) << " \n " ; ) ; }
expr_ref mk_not ( expr * e ) { expr * r ; if ( m . is_not ( e , r ) ) { return expr_ref ( r , m ) ; } return expr_ref ( m . mk_not ( e ) , m ) ; }
bool project_real ( contains_app & x , model_ref & model , expr_ref & fml ) { SASSERT ( m_util . m_arith . is_real ( x . x ( ) ) ) ; model_evaluator model_eval ( * model ) ; bounds_proc & bounds = get_bounds ( x . x ( ) , fml ) ; bool is_lower = bounds . le_size ( ) + bounds . lt_size ( ) < bounds . ge_size ( ) + bounds . gt_size ( ) ; unsigned e_size = bounds . e_size ( is_lower ) ; numeral bound1 , bound2 , vl , x_val ; unsigned idx1 , idx2 ; bool found1 = find_min_max ( is_lower , false , bounds , model_eval , bound1 , idx1 ) ; bool found2 = find_min_max ( is_lower , true , bounds , model_eval , bound2 , idx2 ) ; if ( ! found1 && ! found2 ) { vl = numeral ( 0 ) ; } else if ( found2 && ( ! found1 || bound2 <= bound1 ) ) { vl = numeral ( 1 + 2 * e_size + idx2 ) ; } else if ( found1 && ( ! found2 || bound1 < bound2 ) ) { expr_ref val_x ( m ) ; model_eval ( x . x ( ) , val_x ) ; VERIFY ( m_util . m_arith . is_numeral ( val_x , x_val ) ) ; if ( x_val == bound1 ) { vl = numeral ( 1 + 2 * idx1 ) ; } else { vl = numeral ( 1 + 2 * idx1 + 1 ) ; } } assign ( x , fml , vl ) ; subst ( x , vl , fml , 0 ) ; TRACE ( " qe " , tout << mk_pp ( fml , m ) << " \n " ; ) ; return true ; }
bool project_int ( contains_app & x , model_ref & model , expr_ref & fml ) { model_evaluator model_eval ( * model ) ; bounds_proc & bounds = get_bounds ( x . x ( ) , fml ) ; SASSERT ( m_util . m_arith . is_int ( x . x ( ) ) ) ; SASSERT ( bounds . lt_size ( ) == 0 && bounds . gt_size ( ) == 0 ) ; bool is_lower = bounds . le_size ( ) < bounds . ge_size ( ) ; numeral bound , vl , x_val ; unsigned idx = bounds . le_size ( ) + bounds . ge_size ( ) ; bool found = find_min_max ( is_lower , false , bounds , model_eval , bound , idx ) ; if ( found ) { SASSERT ( idx < bounds . size ( false , is_lower ) ) ; vl = numeral ( 1 + idx ) ; } else { vl = numeral ( 0 ) ; } assign ( x , fml , vl ) ; subst ( x , vl , fml , 0 ) ; TRACE ( " qe " , tout << mk_pp ( fml , m ) << " \n " ; ) ; return true ; }
bool find_min_max ( bool is_lower , bool is_strict , bounds_proc & bounds , model_evaluator & eval , rational & bound , unsigned & idx ) { bool found = false ; unsigned num_bounds = bounds . size ( is_strict , is_lower ) ; rational num ; for ( unsigned i = 0 ; i < num_bounds ; ++ i ) { expr_ref vl ( m ) ; eval ( bounds . atoms ( is_strict , is_lower ) [ i ] , vl ) ; if ( ! m . is_true ( vl ) ) { continue ; } eval ( bounds . exprs ( is_strict , is_lower ) [ i ] , vl ) ; VERIFY ( m_util . m_arith . is_numeral ( vl , num ) ) ; num /= abs ( bounds . coeffs ( is_strict , is_lower ) [ i ] ) ; if ( found ) { if ( is_lower ? ( num < bound ) : ( num > bound ) ) { bound = num ; idx = i ; } } else { found = true ; idx = i ; bound = num ; } } return found ; }
bool get_bound_sizes ( bounds_proc & bounds , app * x , unsigned & t_size , unsigned & e_size ) { unsigned le_size = bounds . le_size ( ) ; unsigned ge_size = bounds . ge_size ( ) ; if ( m_util . is_real ( x ) ) { le_size *= 2 ; ge_size *= 2 ; } if ( le_size + bounds . lt_size ( ) < ge_size + bounds . gt_size ( ) ) { e_size = le_size ; t_size = bounds . lt_size ( ) ; return true ; } else { e_size = ge_size ; t_size = bounds . gt_size ( ) ; return false ; } }
void add_cache ( app * x , expr * fml , unsigned v , expr * result , rational coeff , expr * term ) { m_trail . push_back ( x ) ; m_trail . push_back ( fml ) ; m_trail . push_back ( result ) ; if ( term ) m_trail . push_back ( term ) ; m_subst . insert ( branch_formula ( fml , x , v , result , coeff , term ) ) ; }
bool get_cache ( app * x , expr * fml , unsigned v , expr_ref & result ) { branch_formula bf ; if ( ! m_subst . find ( branch_formula ( fml , x , v , 0 , rational :: zero ( ) , 0 ) , bf ) ) { return false ; } SASSERT ( bf . m_result ) ; result = bf . m_result ; return true ; }
void assign_divs ( contains_app & contains_x , bounds_proc & bounds , x_subst & x_t , expr_ref & result ) { app * x = contains_x . x ( ) ; app_ref z ( m ) , z_bv ( m ) ; rational d ; if ( ! bounds . div_z ( d , z_bv , z ) ) { return ; } m_ctx . add_var ( z_bv ) ; expr * z_lt_d = m_util . m_arith . mk_le ( z , m_util . m_arith . mk_numeral ( d - rational ( 1 ) , true ) ) ; m_ctx . add_constraint ( false , z_lt_d ) ; SASSERT ( ! abs ( d ) . is_one ( ) ) ; rational d1 = d - rational ( 1 ) ; expr_ref tmp ( m ) ; m_util . m_arith_rewriter . mk_le ( z , m_util . m_arith . mk_numeral ( d1 , true ) , tmp ) ; m_util . m_bool_rewriter . mk_and ( result , tmp , result ) ; expr_ref t1 ( m ) , new_atom ( m ) ; t1 = m_util . mk_sub ( x , z ) ; m_util . mk_divides ( d , t1 , new_atom ) ; m_ctx . add_constraint ( false , new_atom ) ; mk_div_equivs ( bounds , z , result ) ; x_t . set_term ( z ) ; x_t . set_coeff ( d ) ; }
void mk_div_equivs ( bounds_proc & bounds , expr * z , expr_ref & result ) { unsigned sz = bounds . div_size ( ) ; app * const * atoms = bounds . div_atoms ( ) ; rational const * coeffs = bounds . div_coeffs ( ) ; expr * const * terms = bounds . div_terms ( ) ; rational const * divisors = bounds . divisors ( ) ; expr_ref new_atom ( m ) , t1 ( m ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * atm = atoms [ i ] ; t1 = m_util . mk_add ( m_util . mk_mul ( coeffs [ i ] , z ) , terms [ i ] ) ; m_util . mk_divides ( divisors [ i ] , t1 , new_atom ) ; m_util . m_replace . apply_substitution ( atm , new_atom . get ( ) , result ) ; m_ctx . add_constraint ( false , mk_not ( atm ) , new_atom ) ; m_ctx . add_constraint ( false , mk_not ( new_atom ) , atm ) ; } }
void assign_nested_divs ( contains_app & contains_x , bounds_proc & bounds , expr_ref & result ) { unsigned num_nested_divs = bounds . nested_div_size ( ) ; if ( num_nested_divs == 0 ) { return ; } app_ref z ( m ) , z_bv ( m ) ; rational d ; VERIFY ( bounds . div_z ( d , z_bv , z ) ) ; for ( unsigned i = 0 ; i < num_nested_divs ; ++ i ) { app * atm = bounds . nested_div_atom ( i ) ; rational const & k = bounds . nested_divisor ( i ) ; app * z1_bv = bounds . nested_div_z_bv ( i ) ; app * z1 = bounds . nested_div_z ( i ) ; m_ctx . add_var ( z1_bv ) ; expr * z_lt_k = m_util . m_arith . mk_le ( z1 , m_util . m_arith . mk_numeral ( k - rational ( 1 ) , true ) ) ; m_ctx . add_constraint ( false , z_lt_k ) ; expr * e1 = m_util . m_arith . mk_sub ( atm -> get_arg ( 0 ) , z1 ) ; expr * e2 = atm -> get_arg ( 1 ) ; expr_ref mod_term2 ( m_util . m_arith . mk_mod ( e1 , e2 ) , m ) ; m_util . simplify ( mod_term2 ) ; m_ctx . add_constraint ( false , m . mk_eq ( mod_term2 , m_util . mk_zero ( mod_term2 ) ) ) ; m_util . m_replace . apply_substitution ( atm , z1 , result ) ; expr_ref mod_eq ( m ) , tmp1 ( m ) , tmp2 ( m ) ; tmp2 = m_util . mk_numeral ( bounds . nested_div_coeff ( i ) , true ) ; tmp1 = m_util . m_arith . mk_mul ( tmp2 , z1 ) ; tmp2 = m_util . m_arith . mk_sub ( bounds . nested_div_term ( i ) , z ) ; tmp2 = m_util . m_arith . mk_add ( tmp1 , tmp2 ) ; tmp1 = m_util . m_arith . mk_mod ( tmp2 , bounds . nested_div_atom ( i ) -> get_arg ( 1 ) ) ; mod_eq = m . mk_eq ( tmp1 , m_util . mk_zero ( z ) ) ; m_util . simplify ( mod_eq ) ; result = m . mk_and ( result , mod_eq ) ; TRACE ( " qe " , tout << mk_pp ( mod_eq , m ) << " \n " ; ) ; } }
bounds_proc & get_bounds ( app * x , expr * fml ) { bounds_proc * result = 0 ; VERIFY ( m_bounds_cache . find ( x , fml , result ) ) ; return * result ; }
void mk_non_bounds ( bounds_proc & bounds , bool is_strict , bool is_lower , expr_ref & result ) { unsigned sz = bounds . size ( is_strict , is_lower ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , is_lower ) [ i ] ; m_ctx . add_constraint ( true , mk_not ( e ) ) ; m_util . m_replace . apply_substitution ( e , m . mk_false ( ) , result ) ; } }
void mk_non_resolve ( bounds_proc & bounds , bool is_strict , bool is_lower , expr_ref & result ) { unsigned sz = bounds . size ( is_strict , ! is_lower ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , ! is_lower ) [ i ] ; m_ctx . add_constraint ( true , e ) ; m_util . m_replace . apply_substitution ( e , m . mk_true ( ) , result ) ; } }
void mk_bound ( bool is_strict , bool is_lower , rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { if ( is_strict ) { if ( is_lower ) { m_util . mk_strict_bound ( b , s , a , t , result ) ; } else { m_util . mk_strict_bound ( a , t , b , s , result ) ; } } else { if ( is_lower ) { m_util . mk_bound ( b , s , a , t , result ) ; } else { m_util . mk_bound ( a , t , b , s , result ) ; } } m_util . simplify ( result ) ; TRACE ( " qe " , tout << ( is_strict ? " strict " : " non - strict " ) << " \n " ; tout << ( is_lower ? " is - lower " : " is - upper " ) << " \n " ; tout << " a : ▁ " << a << " ▁ " << mk_pp ( t , m ) << " \n " ; tout << " b : ▁ " << b << " ▁ " << mk_pp ( s , m ) << " \n " ; tout << mk_pp ( result , m ) << " \n " ; ) ; }
void mk_bounds ( bounds_proc & bounds , app * x , bool is_strict , bool is_eq_ctx , bool is_strict_ctx , bool is_lower , unsigned index , rational const & a , expr * t , expr_ref & result ) { TRACE ( " qe " , tout << mk_pp ( t , m ) << " \n " ; ) ; SASSERT ( ! is_eq_ctx || ! is_strict_ctx ) ; unsigned sz = bounds . size ( is_strict , is_lower ) ; expr_ref tmp ( m ) , eq ( m ) ; bool same_strict = ( is_strict == is_strict_ctx ) ; bool non_strict_real = m_util . is_real ( x ) && ! is_strict_ctx ; app * atm = bounds . atoms ( is_strict_ctx , is_lower ) [ index ] ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , is_lower ) [ i ] ; expr_ref s ( bounds . exprs ( is_strict , is_lower ) [ i ] , m ) ; rational b = bounds . coeffs ( is_strict , is_lower ) [ i ] ; if ( same_strict && i == index ) { if ( non_strict_real ) { m_util . mk_eq ( a , x , t , eq ) ; TRACE ( " qe " , tout << " a : " << a << " ▁ x : ▁ " << mk_pp ( x , m ) << " t : ▁ " << mk_pp ( t , m ) << " ▁ eq : ▁ " << mk_pp ( eq , m ) << " \n " ; ) ; if ( is_eq_ctx ) { m_ctx . add_constraint ( true , eq ) ; } else { m_ctx . add_constraint ( true , mk_not ( eq ) ) ; m_ctx . add_constraint ( true , e ) ; } } else { m_ctx . add_constraint ( true , e ) ; } m_util . m_replace . apply_substitution ( atm , m . mk_true ( ) , result ) ; continue ; } bool result_is_strict = ( non_strict_real && is_eq_ctx && is_strict ) || ( same_strict && i < index ) ; mk_bound ( result_is_strict , is_lower , a , t , b , s , tmp ) ; m_util . m_replace . apply_substitution ( e , tmp . get ( ) , result ) ; TRACE ( " qe " , tout << ( result_is_strict ? " strict ▁ result " : " non - strict ▁ result " ) << " \n " ; tout << ( is_strict ? " strict " : " non - strict " ) << " \n " ; tout << mk_pp ( atm , m ) << " ▁ & ▁ " ; tout << mk_pp ( e , m ) << " ▁ - - > ▁ " ; tout << mk_pp ( tmp . get ( ) , m ) << " \n " ; ) ; m_ctx . add_constraint ( true , mk_not ( e ) , tmp ) ; } }
void mk_resolve ( bounds_proc & bounds , app * x , x_subst & x_t , bool is_strict , bool is_eq_ctx , bool is_strict_ctx , bool is_lower , unsigned index , rational const & a , expr * t , expr_ref & result ) { expr_ref tmp ( m ) ; unsigned sz = bounds . size ( is_strict , ! is_lower ) ; bool is_strict_real = ! is_eq_ctx && m_util . is_real ( x ) && ! is_strict_ctx ; bool strict_resolve = is_strict || is_strict_ctx || is_strict_real ; app * atm = bounds . atoms ( is_strict_ctx , is_lower ) [ index ] ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , ! is_lower ) [ i ] ; expr_ref s ( bounds . exprs ( is_strict , ! is_lower ) [ i ] , m ) ; rational b = bounds . coeffs ( is_strict , ! is_lower ) [ i ] ; SASSERT ( ! b . is_zero ( ) ) ; SASSERT ( b . is_pos ( ) != a . is_pos ( ) ) ; s = x_t . mk_term ( b , s ) ; b = x_t . mk_coeff ( b ) ; m_util . mk_resolve ( x , strict_resolve , a , t , b , s , tmp ) ; expr_ref save_result ( result ) ; m_util . m_replace . apply_substitution ( e , tmp . get ( ) , result ) ; m_ctx . add_constraint ( true , mk_not ( e ) , tmp ) ; TRACE ( " qe _ verbose " , tout << mk_pp ( atm , m ) << " ▁ " ; tout << mk_pp ( e , m ) << " ▁ = = > \n " ; tout << mk_pp ( tmp , m ) << " \n " ; tout << " old ▁ fml : ▁ " << mk_pp ( save_result , m ) << " \n " ; tout << " new ▁ fml : ▁ " << mk_pp ( result , m ) << " \n " ; ) ; } }
bool update_bounds ( bounds_proc & bounds , contains_app & contains_x , expr * fml , atom_set const & tbl , bool is_pos ) { app_ref tmp ( m ) ; atom_set :: iterator it = tbl . begin ( ) , end = tbl . end ( ) ; for ( ; it != end ; ++ it ) { app * e = * it ; if ( ! contains_x ( e ) ) { continue ; } if ( ! is_pos ) { SASSERT ( ! m . is_not ( e ) ) ; tmp = m . mk_not ( e ) ; e = tmp ; } if ( ! bounds . get_bound ( contains_x , e ) ) { return false ; } } return true ; }
bool update_bounds ( contains_app & contains_x , expr * fml ) { bounds_proc * bounds = 0 ; if ( m_bounds_cache . find ( contains_x . x ( ) , fml , bounds ) ) { return true ; } bounds = alloc ( bounds_proc , m_util ) ; if ( ! update_bounds ( * bounds , contains_x , fml , m_ctx . pos_atoms ( ) , true ) ) { dealloc ( bounds ) ; return false ; } if ( ! update_bounds ( * bounds , contains_x , fml , m_ctx . neg_atoms ( ) , false ) ) { dealloc ( bounds ) ; return false ; } m_trail . push_back ( contains_x . x ( ) ) ; m_trail . push_back ( fml ) ; m_bounds_cache . insert ( contains_x . x ( ) , fml , bounds ) ; return true ; }
public : nlarith_plugin ( i_solver_context & ctx , ast_manager & m , bool produce_models ) : qe_solver_plugin ( m , m . mk_family_id ( " arith " ) , ctx ) , m_rewriter ( m ) , m_util ( m ) , m_replace ( m ) , m_trail ( m ) , m_factor_rw ( m ) , m_produce_models ( produce_models ) { TRACE ( " qe " , tout << " produce ▁ models : ▁ " << produce_models << " \n " ; ) ; m_util . set_enable_linear ( true ) ; }
virtual ~ nlarith_plugin ( ) { bcs_t :: iterator it = m_cache . begin ( ) , end = m_cache . end ( ) ; for ( ; it != end ; ++ it ) { dealloc ( it -> get_value ( ) ) ; } weights_t :: iterator it2 = m_weights . begin ( ) , e2 = m_weights . end ( ) ; for ( ; it2 != e2 ; ++ it2 ) { dealloc ( it2 -> get_value ( ) ) ; } }
virtual bool simplify ( expr_ref & fml ) { expr_ref tmp ( m ) , tmp2 ( m ) ; m_factor_rw ( fml , tmp ) ; m_rewriter ( tmp , tmp2 ) ; if ( fml . get ( ) != tmp2 . get ( ) ) { fml = tmp2 ; return true ; } return false ; }
virtual void assign ( contains_app & x , expr * fml , rational const & vl ) { nlarith :: branch_conditions * brs ; VERIFY ( m_cache . find ( x . x ( ) , fml , brs ) ) ; SASSERT ( vl . is_unsigned ( ) ) ; SASSERT ( vl . get_unsigned ( ) < brs -> size ( ) ) ; expr * branch_fml = brs -> branches ( vl . get_unsigned ( ) ) ; expr_ref result ( m ) , tmp ( m ) ; m_factor_rw ( branch_fml , tmp ) ; m_rewriter ( tmp , result ) ; TRACE ( " qe " , tout << vl << " ▁ " << mk_pp ( result . get ( ) , m ) << " \n " ; ) ; m_ctx . add_constraint ( true , result ) ; }
virtual bool get_num_branches ( contains_app & x , expr * fml , rational & num_branches ) { nlarith :: branch_conditions * brs ; if ( m_cache . find ( x . x ( ) , fml , brs ) ) { num_branches = rational ( brs -> size ( ) ) ; return true ; } expr_ref_vector lits ( m ) ; update_bounds ( lits , m_ctx . pos_atoms ( ) , true ) ; update_bounds ( lits , m_ctx . neg_atoms ( ) , false ) ; brs = alloc ( nlarith :: branch_conditions , m ) ; TRACE ( " nlarith " , tout << mk_pp ( fml , m ) << " \n " ; ) ; if ( ! m_util . create_branches ( x . x ( ) , lits . size ( ) , lits . c_ptr ( ) , * brs ) ) { TRACE ( " nlarith " , tout << " no ▁ branches ▁ for ▁ " << mk_pp ( x . x ( ) , m ) << " \n " ; ) ; dealloc ( brs ) ; return false ; } num_branches = rational ( brs -> size ( ) ) ; insert_cache ( x . x ( ) , fml , brs ) ; return true ; }
virtual void subst ( contains_app & x , rational const & vl , expr_ref & fml , expr_ref * def ) { nlarith :: branch_conditions * brs ; VERIFY ( m_cache . find ( x . x ( ) , fml , brs ) ) ; SASSERT ( vl . is_unsigned ( ) ) ; SASSERT ( vl . get_unsigned ( ) < brs -> size ( ) ) ; unsigned j = vl . get_unsigned ( ) ; m_replace . reset ( ) ; for ( unsigned i = 0 ; i < brs -> preds ( ) . size ( ) ; ++ i ) { m_replace . insert ( brs -> preds ( i ) , brs -> subst ( j ) [ i ] ) ; } m_replace ( fml ) ; expr_ref tmp ( m . mk_and ( brs -> constraints ( j ) , fml ) , m ) ; m_factor_rw ( tmp , fml ) ; if ( def ) { m_factor_rw ( brs -> def ( j ) , * def ) ; } }
virtual unsigned get_weight ( contains_app & x , expr * fml ) { obj_map < app , unsigned > * weights = 0 ; unsigned weight = 0 ; if ( ! m_weights . find ( fml , weights ) ) { weights = alloc ( weight_m ) ; m_weights . insert ( fml , weights ) ; m_trail . push_back ( fml ) ; ptr_vector < app > nl_vars ; m_util . extract_non_linear ( to_app ( fml ) , nl_vars ) ; for ( unsigned i = 0 ; i < nl_vars . size ( ) ; ++ i ) { weights -> insert ( nl_vars [ i ] , 100 ) ; } } if ( weights -> find ( x . x ( ) , weight ) ) { return weight ; } return UINT_MAX ; }
virtual bool solve ( conj_enum & conjs , expr * fml ) { return false ; }
virtual bool mk_atom ( expr * e , bool p , expr_ref & result ) { return false ; }
virtual bool is_uninterpreted ( app * f ) { if ( m_produce_models ) { return true ; } switch ( f -> get_decl_kind ( ) ) { case OP_NUM : case OP_LE : case OP_LT : case OP_GE : case OP_GT : case OP_ADD : case OP_SUB : case OP_UMINUS : return false ; case OP_MUL : { arith_util a ( m ) ; expr * m , * n ; if ( a . is_mul ( f , m , n ) && ( a . is_numeral ( m ) || a . is_numeral ( n ) ) ) { return false ; } return true ; } default : return true ; } return true ; }
private : void insert_cache ( app * x , expr * e , nlarith :: branch_conditions * brs ) { m_trail . push_back ( x ) ; m_trail . push_back ( e ) ; m_cache . insert ( x , e , brs ) ; }
void update_bounds ( expr_ref_vector & lits , atom_set const & tbl , bool is_pos ) { atom_set :: iterator it = tbl . begin ( ) , end = tbl . end ( ) ; for ( ; it != end ; ++ it ) { app * e = * it ; lits . push_back ( is_pos ? e : m . mk_not ( e ) ) ; } }
qe_solver_plugin * mk_arith_plugin ( i_solver_context & ctx , bool produce_models , smt_params & p ) { if ( p . m_nlquant_elim ) { return alloc ( nlarith_plugin , ctx , ctx . get_manager ( ) , produce_models ) ; } else { return alloc ( arith_plugin , ctx , ctx . get_manager ( ) , p ) ; } }
AS_API const char * asGetLibraryVersion ( ) { return ANGELSCRIPT_VERSION_STRING " ▁ DEBUG " ; return ANGELSCRIPT_VERSION_STRING ; }
AS_API const char * asGetLibraryOptions ( ) { const char * string = " ▁ " " AS _ MAX _ PORTABILITY ▁ " " AS _ DEBUG ▁ " " AS _ NO _ CLASS _ METHODS ▁ " " AS _ USE _ DOUBLE _ AS _ FLOAT ▁ " " AS _ 64BIT _ PTR ▁ " " AS _ NO _ THREADS ▁ " " AS _ NO _ ATOMIC ▁ " " AS _ WIN ▁ " " AS _ LINUX ▁ " " AS _ MAC ▁ " " AS _ BSD ▁ " " AS _ XBOX ▁ " " AS _ XBOX360 ▁ " " AS _ PSP ▁ " " AS _ PS2 ▁ " " AS _ PS3 ▁ " " AS _ DC ▁ " " AS _ GC ▁ " " AS _ WII ▁ " " AS _ IPHONE ▁ " " AS _ ANDROID ▁ " " AS _ PPC ▁ " " AS _ PPC _ 64 ▁ " " AS _ X86 ▁ " " AS _ MIPS ▁ " " AS _ SH4 ▁ " " AS _ XENON ▁ " " AS _ ARM ▁ " ; return string ; }
AS_API asIScriptEngine * asCreateScriptEngine ( asDWORD version ) { if ( ( version / 10000 ) != ( ANGELSCRIPT_VERSION / 10000 ) ) return 0 ; if ( ( version / 100 ) % 100 != ( ANGELSCRIPT_VERSION / 100 ) % 100 ) return 0 ; if ( ( version % 100 ) > ( ANGELSCRIPT_VERSION % 100 ) ) return 0 ; asASSERT ( sizeof ( asBYTE ) == 1 ) ; asASSERT ( sizeof ( asWORD ) == 2 ) ; asASSERT ( sizeof ( asDWORD ) == 4 ) ; asASSERT ( sizeof ( asQWORD ) == 8 ) ; asASSERT ( sizeof ( asPWORD ) == sizeof ( void * ) ) ; asASSERT ( sizeof ( bool ) == AS_SIZEOF_BOOL ) ; asASSERT ( true == VALUE_OF_BOOLEAN_TRUE ) ; asASSERT ( * ( asDWORD * ) " \x00\x01\x02\x03" == 0x00010203 ) ; asASSERT ( * ( asQWORD * ) " \x00\x01\x02\x03\x04\x05\x06\x07" == I64 ( 0x0001020304050607 ) ) ; asASSERT ( * ( asDWORD * ) " \x00\x01\x02\x03" == 0x03020100 ) ; asASSERT ( * ( asQWORD * ) " \x00\x01\x02\x03\x04\x05\x06\x07" == I64 ( 0x0706050403020100 ) ) ; return asNEW ( asCScriptEngine ) ( ) ; }
