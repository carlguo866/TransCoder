<DOCUMENT_ID="StevenBlack/phantomjs/tree/master/src/qt/qtwebkit/Source/WebCore/platform/audio/AudioFIFO.cpp"> # include " config . h " # if ENABLE ( WEB_AUDIO ) # include " AudioFIFO . h " namespace WebCore { AudioFIFO :: AudioFIFO ( unsigned numberOfChannels , size_t fifoLength ) : m_fifoAudioBus ( AudioBus :: create ( numberOfChannels , fifoLength ) ) , m_fifoLength ( fifoLength ) , m_framesInFifo ( 0 ) , m_readIndex ( 0 ) , m_writeIndex ( 0 ) { } void AudioFIFO :: consume ( AudioBus * destination , size_t framesToConsume ) { bool isGood = destination && ( framesToConsume <= m_fifoLength ) && ( framesToConsume <= m_framesInFifo ) && ( destination -> length ( ) >= framesToConsume ) ; ASSERT ( isGood ) ; if ( ! isGood ) return ; size_t part1Length ; size_t part2Length ; findWrapLengths ( m_readIndex , framesToConsume , part1Length , part2Length ) ; size_t numberOfChannels = m_fifoAudioBus -> numberOfChannels ( ) ; for ( size_t channelIndex = 0 ; channelIndex < numberOfChannels ; ++ channelIndex ) { float * destinationData = destination -> channel ( channelIndex ) -> mutableData ( ) ; const float * sourceData = m_fifoAudioBus -> channel ( channelIndex ) -> data ( ) ; bool isCopyGood = ( ( m_readIndex < m_fifoLength ) && ( m_readIndex + part1Length ) <= m_fifoLength && ( part1Length <= destination -> length ( ) ) && ( part1Length + part2Length ) <= destination -> length ( ) ) ; ASSERT ( isCopyGood ) ; if ( ! isCopyGood ) return ; memcpy ( destinationData , sourceData + m_readIndex , part1Length * sizeof ( * sourceData ) ) ; if ( part2Length ) memcpy ( destinationData + part1Length , sourceData , part2Length * sizeof ( * sourceData ) ) ; } m_readIndex = updateIndex ( m_readIndex , framesToConsume ) ; ASSERT ( m_framesInFifo >= framesToConsume ) ; m_framesInFifo -= framesToConsume ; } void AudioFIFO :: push ( const AudioBus * sourceBus ) { bool isGood = sourceBus && ( m_framesInFifo + sourceBus -> length ( ) <= m_fifoLength ) ; if ( ! isGood ) return ; size_t sourceLength = sourceBus -> length ( ) ; size_t part1Length ; size_t part2Length ; findWrapLengths ( m_writeIndex , sourceLength , part1Length , part2Length ) ; size_t numberOfChannels = m_fifoAudioBus -> numberOfChannels ( ) ; for ( size_t channelIndex = 0 ; channelIndex < numberOfChannels ; ++ channelIndex ) { float * destination = m_fifoAudioBus -> channel ( channelIndex ) -> mutableData ( ) ; const float * source = sourceBus -> channel ( channelIndex ) -> data ( ) ; bool isCopyGood = ( ( m_writeIndex < m_fifoLength ) && ( m_writeIndex + part1Length ) <= m_fifoLength && part2Length < m_fifoLength && part1Length + part2Length <= sourceLength ) ; ASSERT ( isCopyGood ) ; if ( ! isCopyGood ) return ; memcpy ( destination + m_writeIndex , source , part1Length * sizeof ( * destination ) ) ; if ( part2Length ) memcpy ( destination , source + part1Length , part2Length * sizeof ( * destination ) ) ; } m_framesInFifo += sourceLength ; ASSERT ( m_framesInFifo <= m_fifoLength ) ; m_writeIndex = updateIndex ( m_writeIndex , sourceLength ) ; } void AudioFIFO :: findWrapLengths ( size_t index , size_t size , size_t & part1Length , size_t & part2Length ) { ASSERT_WITH_SECURITY_IMPLICATION ( index < m_fifoLength && size <= m_fifoLength ) ; if ( index < m_fifoLength && size <= m_fifoLength ) { if ( index + size > m_fifoLength ) { part1Length = m_fifoLength - index ; part2Length = size - part1Length ; } else { part1Length = size ; part2Length = 0 ; } } else { part1Length = 0 ; part2Length = 0 ; } } } # endif </DOCUMENT>
<DOCUMENT_ID="nextgis/NextGIS_QGIS_open/tree/master/src/gui/qgsfieldvalidator.cpp"> # include " qgsfieldvalidator . h " # include < QValidator > # include < QRegExpValidator > # include < QDate > # include < QVariant > # include < QSettings > # include " qgslogger . h " # include " qgslonglongvalidator . h " # include " qgsfield . h " QgsFieldValidator :: QgsFieldValidator ( QObject * parent , const QgsField & field , QString dateFormat ) : QValidator ( parent ) , mField ( field ) , mDateFormat ( dateFormat ) { switch ( mField . type ( ) ) { case QVariant :: Int : { if ( mField . length ( ) > 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } " ) . arg ( mField . length ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else { mValidator = new QIntValidator ( parent ) ; } } break ; case QVariant :: Double : { if ( mField . length ( ) > 0 && mField . precision ( ) > 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } ( \\ . \\d { 0 , % 2 } ) ? " ) . arg ( mField . length ( ) - mField . precision ( ) ) . arg ( mField . precision ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else if ( mField . length ( ) > 0 && mField . precision ( ) == 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } " ) . arg ( mField . length ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else if ( mField . precision ( ) > 0 ) { QString re = QString ( " - ? \\d * ( \\ . \\d { 0 , % 1 } ) ? " ) . arg ( mField . precision ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else { mValidator = new QDoubleValidator ( parent ) ; } } break ; case QVariant :: LongLong : mValidator = new QgsLongLongValidator ( parent ) ; break ; default : mValidator = 0 ; } QSettings settings ; mNullValue = settings . value ( " qgis / nullValue " , " NULL " ) . toString ( ) ; } QgsFieldValidator :: ~ QgsFieldValidator ( ) { delete mValidator ; } QValidator :: State QgsFieldValidator :: validate ( QString & s , int & i ) const { if ( s . isEmpty ( ) && ( mField . type ( ) == QVariant :: Double || mField . type ( ) == QVariant :: Int || mField . type ( ) == QVariant :: LongLong || mField . type ( ) == QVariant :: Date ) ) { return Acceptable ; } if ( mValidator ) { QValidator :: State result = mValidator -> validate ( s , i ) ; return result ; } else if ( mField . type ( ) == QVariant :: String ) { if ( mNullValue . size ( ) > 0 && s . size ( ) > 0 && s . size ( ) < mNullValue . size ( ) && s == mNullValue . left ( s . size ( ) ) ) return Intermediate ; if ( s == mNullValue ) return Acceptable ; if ( mField . length ( ) > 0 && s . size ( ) > mField . length ( ) ) return Invalid ; } else if ( mField . type ( ) == QVariant :: Date ) { return QDate :: fromString ( s , mDateFormat ) . isValid ( ) ? Acceptable : Intermediate ; } else { QgsDebugMsg ( QString ( " unsupported ▁ type ▁ % 1 ▁ for ▁ validation " ) . arg ( mField . type ( ) ) ) ; return Invalid ; } return Acceptable ; } void QgsFieldValidator :: fixup ( QString & s ) const { if ( mValidator ) { mValidator -> fixup ( s ) ; } else if ( mField . type ( ) == QVariant :: String && mField . length ( ) > 0 && s . size ( ) > mField . length ( ) ) { s = mNullValue ; } else if ( mField . type ( ) == QVariant :: Date ) { s = " " ; } } </DOCUMENT>
<DOCUMENT_ID="Hual/SA-MP-Plus/tree/master/Common/RakNet/VariableDeltaSerializer.cpp"> # include " VariableDeltaSerializer . h " using namespace RakNet ; VariableDeltaSerializer :: VariableDeltaSerializer ( ) { didComparisonThisTick = false ; } VariableDeltaSerializer :: ~ VariableDeltaSerializer ( ) { RemoveRemoteSystemVariableHistory ( ) ; } VariableDeltaSerializer :: SerializationContext :: SerializationContext ( ) { variableHistoryIdentical = 0 ; variableHistoryUnique = 0 ; } VariableDeltaSerializer :: SerializationContext :: ~ SerializationContext ( ) { } void VariableDeltaSerializer :: OnMessageReceipt ( RakNetGUID guid , uint32_t receiptId , bool messageArrived ) { if ( messageArrived ) FreeVarsAssociatedWithReceipt ( guid , receiptId ) ; else DirtyAndFreeVarsAssociatedWithReceipt ( guid , receiptId ) ; } void VariableDeltaSerializer :: BeginUnreliableAckedSerialize ( SerializationContext * context , RakNetGUID _guid , BitStream * _bitStream , uint32_t _sendReceipt ) { RakAssert ( _guid != UNASSIGNED_RAKNET_GUID ) ; context -> anyVariablesWritten = false ; context -> guid = _guid ; context -> bitStream = _bitStream ; if ( context -> variableHistoryUnique == 0 ) context -> variableHistoryUnique = StartVariableHistoryWrite ( _guid ) ; context -> variableHistory = context -> variableHistoryUnique ; context -> sendReceipt = _sendReceipt ; context -> changedVariables = AllocChangedVariablesList ( ) ; context -> newSystemSend = false ; context -> serializationMode = UNRELIABLE_WITH_ACK_RECEIPT ; } void VariableDeltaSerializer :: BeginUniqueSerialize ( SerializationContext * context , RakNetGUID _guid , BitStream * _bitStream ) { RakAssert ( _guid != UNASSIGNED_RAKNET_GUID ) ; context -> anyVariablesWritten = false ; context -> guid = _guid ; context -> bitStream = _bitStream ; if ( context -> variableHistoryUnique == 0 ) context -> variableHistoryUnique = StartVariableHistoryWrite ( _guid ) ; context -> variableHistory = context -> variableHistoryUnique ; context -> newSystemSend = false ; context -> serializationMode = RELIABLE ; } void VariableDeltaSerializer :: BeginIdenticalSerialize ( SerializationContext * context , bool _isFirstSendToRemoteSystem , BitStream * _bitStream ) { context -> anyVariablesWritten = false ; context -> guid = UNASSIGNED_RAKNET_GUID ; context -> bitStream = _bitStream ; context -> serializationMode = RELIABLE ; if ( context -> variableHistoryIdentical == 0 ) context -> variableHistoryIdentical = StartVariableHistoryWrite ( UNASSIGNED_RAKNET_GUID ) ; context -> variableHistory = context -> variableHistoryIdentical ; context -> newSystemSend = _isFirstSendToRemoteSystem ; } void VariableDeltaSerializer :: EndSerialize ( SerializationContext * context ) { if ( context -> serializationMode == UNRELIABLE_WITH_ACK_RECEIPT ) { if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; FreeChangedVariablesList ( context -> changedVariables ) ; return ; } StoreChangedVariablesList ( context -> variableHistory , context -> changedVariables , context -> sendReceipt ) ; } else { if ( context -> variableHistoryIdentical ) { if ( didComparisonThisTick == false ) { didComparisonThisTick = true ; identicalSerializationBs . Reset ( ) ; if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; return ; } identicalSerializationBs . Write ( context -> bitStream ) ; context -> bitStream -> ResetReadPointer ( ) ; } else { context -> bitStream -> Write ( & identicalSerializationBs ) ; identicalSerializationBs . ResetReadPointer ( ) ; } } else if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; return ; } } } void VariableDeltaSerializer :: BeginDeserialize ( DeserializationContext * context , BitStream * _bitStream ) { context -> bitStream = _bitStream ; } void VariableDeltaSerializer :: EndDeserialize ( DeserializationContext * context ) { ( void ) context ; } void VariableDeltaSerializer :: AddRemoteSystemVariableHistory ( RakNetGUID guid ) { ( void ) guid ; } void VariableDeltaSerializer :: RemoveRemoteSystemVariableHistory ( RakNetGUID guid ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) { for ( idx2 = 0 ; idx2 < remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory . Size ( ) ; idx2 ++ ) { FreeChangedVariablesList ( remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory [ idx2 ] ) ; } delete remoteSystemVariableHistoryList [ idx ] ; remoteSystemVariableHistoryList . RemoveAtIndexFast ( idx ) ; return ; } } int RakNet :: VariableDeltaSerializer :: UpdatedVariablesListPtrComp ( const uint32_t & key , ChangedVariablesList * const & data ) { if ( key < data -> sendReceipt ) return - 1 ; if ( key == data -> sendReceipt ) return 0 ; return 1 ; } void VariableDeltaSerializer :: FreeVarsAssociatedWithReceipt ( RakNetGUID guid , uint32_t receiptId ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; RemoteSystemVariableHistory * vprs = remoteSystemVariableHistoryList [ idx ] ; bool objectExists ; idx2 = vprs -> updatedVariablesHistory . GetIndexFromKey ( receiptId , & objectExists ) ; if ( objectExists ) { FreeChangedVariablesList ( vprs -> updatedVariablesHistory [ idx2 ] ) ; vprs -> updatedVariablesHistory . RemoveAtIndex ( idx2 ) ; } } void VariableDeltaSerializer :: DirtyAndFreeVarsAssociatedWithReceipt ( RakNetGUID guid , uint32_t receiptId ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; RemoteSystemVariableHistory * vprs = remoteSystemVariableHistoryList [ idx ] ; bool objectExists ; idx2 = vprs -> updatedVariablesHistory . GetIndexFromKey ( receiptId , & objectExists ) ; if ( objectExists ) { vprs -> variableListDeltaTracker . FlagDirtyFromBitArray ( vprs -> updatedVariablesHistory [ idx2 ] -> bitField ) ; FreeChangedVariablesList ( vprs -> updatedVariablesHistory [ idx2 ] ) ; vprs -> updatedVariablesHistory . RemoveAtIndex ( idx2 ) ; } } unsigned int VariableDeltaSerializer :: GetVarsWrittenPerRemoteSystemListIndex ( RakNetGUID guid ) { unsigned int idx ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) return idx ; } return ( unsigned int ) - 1 ; } void VariableDeltaSerializer :: RemoveRemoteSystemVariableHistory ( void ) { unsigned int idx , idx2 ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { for ( idx2 = 0 ; idx2 < remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory . Size ( ) ; idx2 ++ ) { FreeChangedVariablesList ( remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory [ idx2 ] ) ; } delete remoteSystemVariableHistoryList [ idx ] ; } remoteSystemVariableHistoryList . Clear ( false , _FILE_AND_LINE_ ) ; } VariableDeltaSerializer :: RemoteSystemVariableHistory * VariableDeltaSerializer :: GetRemoteSystemVariableHistory ( RakNetGUID guid ) { unsigned int rshli = GetRemoteSystemHistoryListIndex ( guid ) ; return remoteSystemVariableHistoryList [ rshli ] ; } VariableDeltaSerializer :: ChangedVariablesList * VariableDeltaSerializer :: AllocChangedVariablesList ( void ) { VariableDeltaSerializer :: ChangedVariablesList * p = updatedVariablesMemoryPool . Allocate ( _FILE_AND_LINE_ ) ; p -> bitWriteIndex = 0 ; p -> bitField [ 0 ] = 0 ; return p ; } void VariableDeltaSerializer :: FreeChangedVariablesList ( ChangedVariablesList * changedVariables ) { updatedVariablesMemoryPool . Release ( changedVariables , _FILE_AND_LINE_ ) ; } void VariableDeltaSerializer :: StoreChangedVariablesList ( RemoteSystemVariableHistory * variableHistory , ChangedVariablesList * changedVariables , uint32_t sendReceipt ) { changedVariables -> sendReceipt = sendReceipt ; variableHistory -> updatedVariablesHistory . Insert ( changedVariables -> sendReceipt , changedVariables , true , _FILE_AND_LINE_ ) ; } VariableDeltaSerializer :: RemoteSystemVariableHistory * VariableDeltaSerializer :: StartVariableHistoryWrite ( RakNetGUID guid ) { RemoteSystemVariableHistory * variableHistory ; unsigned int rshli = GetRemoteSystemHistoryListIndex ( guid ) ; if ( rshli == ( unsigned int ) - 1 ) { variableHistory = new RemoteSystemVariableHistory ; variableHistory -> guid = guid ; remoteSystemVariableHistoryList . Push ( variableHistory , _FILE_AND_LINE_ ) ; } else { variableHistory = remoteSystemVariableHistoryList [ rshli ] ; } variableHistory -> variableListDeltaTracker . StartWrite ( ) ; return variableHistory ; } unsigned int VariableDeltaSerializer :: GetRemoteSystemHistoryListIndex ( RakNetGUID guid ) { unsigned int idx ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) { return idx ; } } return ( unsigned int ) - 1 ; } void VariableDeltaSerializer :: OnPreSerializeTick ( void ) { didComparisonThisTick = false ; } </DOCUMENT>
<DOCUMENT_ID="jeppeter/mysql56/tree/master/storage/ndb/src/cw/cpcd/Monitor.cpp"> # include < ndb_global . h > # include < NdbThread . h > # include < NdbOut . hpp > # include < NdbSleep . h > # include " CPCD . hpp " # include " common . hpp " static void * monitor_thread_create_wrapper ( void * arg ) { CPCD :: Monitor * mon = ( CPCD :: Monitor * ) arg ; mon -> run ( ) ; return NULL ; } CPCD :: Monitor :: Monitor ( CPCD * cpcd , int poll ) { m_cpcd = cpcd ; m_pollingInterval = poll ; m_changeCondition = NdbCondition_Create ( ) ; m_changeMutex = NdbMutex_Create ( ) ; m_monitorThread = NdbThread_Create ( monitor_thread_create_wrapper , ( NDB_THREAD_ARG * ) this , 0 , " ndb _ cpcd _ monitor " , NDB_THREAD_PRIO_MEAN ) ; m_monitorThreadQuitFlag = false ; } CPCD :: Monitor :: ~ Monitor ( ) { NdbThread_Destroy ( & m_monitorThread ) ; NdbCondition_Destroy ( m_changeCondition ) ; NdbMutex_Destroy ( m_changeMutex ) ; } void CPCD :: Monitor :: run ( ) { while ( 1 ) { NdbMutex_Lock ( m_changeMutex ) ; NdbCondition_WaitTimeout ( m_changeCondition , m_changeMutex , m_pollingInterval * 1000 ) ; MutexVector < CPCD :: Process * > & proc = * m_cpcd -> getProcessList ( ) ; proc . lock ( ) ; for ( size_t i = 0 ; i < proc . size ( ) ; i ++ ) { proc [ i ] -> monitor ( ) ; } proc . unlock ( ) ; NdbMutex_Unlock ( m_changeMutex ) ; } } void CPCD :: Monitor :: signal ( ) { NdbCondition_Signal ( m_changeCondition ) ; } template class MutexVector < CPCD :: Process * > ; </DOCUMENT>
<DOCUMENT_ID="Shutok/OregonCustom/tree/master/dep/g3dlite/source/Color3.cpp"> # include " G3D / platform . h " # include < stdlib . h > # include " G3D / Color3 . h " # include " G3D / Vector3 . h " # include " G3D / format . h " # include " G3D / BinaryInput . h " # include " G3D / BinaryOutput . h " # include " G3D / Color3uint8 . h " # include " G3D / Any . h " # include " G3D / stringutils . h " namespace G3D { Color3 :: Color3 ( const Any & any ) { * this = Color3 :: zero ( ) ; any . verifyName ( " Color3" ) ; std :: string name = toLower ( any . name ( ) ) ; switch ( any . type ( ) ) { case Any :: TABLE : for ( Any :: AnyTable :: Iterator it = any . table ( ) . begin ( ) ; it . hasMore ( ) ; ++ it ) { const std :: string & key = toLower ( it -> key ) ; if ( key == " r " ) { r = it -> value ; } else if ( key == " g " ) { g = it -> value ; } else if ( key == " b " ) { b = it -> value ; } else { any . verify ( false , " Illegal ▁ key : ▁ " + it -> key ) ; } } break ; case Any :: ARRAY : if ( name == " color3" ) { any . verifySize ( 3 ) ; r = any [ 0 ] ; g = any [ 1 ] ; b = any [ 2 ] ; } else if ( name == " color3 : : one " ) { any . verifySize ( 0 ) ; * this = one ( ) ; } else if ( name == " color3 : : zero " ) { any . verifySize ( 0 ) ; * this = zero ( ) ; } else if ( name == " color3 : : fromargb " ) { * this = Color3 :: fromARGB ( ( int ) any [ 0 ] . number ( ) ) ; } else { any . verify ( false , " Expected ▁ Color3 ▁ constructor " ) ; } break ; default : any . verify ( false , " Bad ▁ Color3 ▁ constructor " ) ; } } Color3 :: operator Any ( ) const { Any a ( Any :: ARRAY , " Color3" ) ; a . append ( r , g , b ) ; return a ; } Color3 Color3 :: ansiMap ( uint32 i ) { static const Color3 map [ ] = { Color3 :: black ( ) , Color3 :: red ( ) * 0.75f , Color3 :: green ( ) * 0.75f , Color3 :: yellow ( ) * 0.75f , Color3 :: blue ( ) * 0.75f , Color3 :: purple ( ) * 0.75f , Color3 :: cyan ( ) * 0.75f , Color3 :: white ( ) * 0.75f , Color3 :: white ( ) * 0.90f , Color3 :: red ( ) , Color3 :: green ( ) , Color3 :: yellow ( ) , Color3 :: blue ( ) , Color3 :: purple ( ) , Color3 :: cyan ( ) , Color3 :: white ( ) } ; return map [ i & 15 ] ; } Color3 Color3 :: pastelMap ( uint32 i ) { uint32 x = Crypto :: crc32 ( & i , sizeof ( uint32 ) ) ; Vector3 v ( ( ( x >> 22 ) & 1023 ) / 1023.0f , ( ( ( x >> 11 ) & 2047 ) / 2047.0f ) * 0.5f + 0.25f , ( ( x & 2047 ) / 2047.0f ) * 0.75f + 0.25f ) ; return Color3 :: fromHSV ( v ) ; } const Color3 & Color3 :: red ( ) { static Color3 c ( 1.0f , 0.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: green ( ) { static Color3 c ( 0.0f , 1.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: blue ( ) { static Color3 c ( 0.0f , 0.0f , 1.0f ) ; return c ; } const Color3 & Color3 :: purple ( ) { static Color3 c ( 0.7f , 0.0f , 1.0f ) ; return c ; } const Color3 & Color3 :: cyan ( ) { static Color3 c ( 0.0f , 0.7f , 1.0f ) ; return c ; } const Color3 & Color3 :: yellow ( ) { static Color3 c ( 1.0f , 1.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: brown ( ) { static Color3 c ( 0.5f , 0.5f , 0.0f ) ; return c ; } const Color3 & Color3 :: orange ( ) { static Color3 c ( 1.0f , 0.5f , 0.0f ) ; return c ; } const Color3 & Color3 :: black ( ) { static Color3 c ( 0.0f , 0.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: zero ( ) { static Color3 c ( 0.0f , 0.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: one ( ) { static Color3 c ( 1.0f , 1.0f , 1.0f ) ; return c ; } const Color3 & Color3 :: gray ( ) { static Color3 c ( 0.7f , 0.7f , 0.7f ) ; return c ; } const Color3 & Color3 :: white ( ) { static Color3 c ( 1 , 1 , 1 ) ; return c ; } bool Color3 :: isFinite ( ) const { return G3D :: isFinite ( r ) && G3D :: isFinite ( g ) && G3D :: isFinite ( b ) ; } Color3 :: Color3 ( BinaryInput & bi ) { deserialize ( bi ) ; } void Color3 :: deserialize ( BinaryInput & bi ) { r = bi . readFloat32 ( ) ; g = bi . readFloat32 ( ) ; b = bi . readFloat32 ( ) ; } void Color3 :: serialize ( BinaryOutput & bo ) const { bo . writeFloat32 ( r ) ; bo . writeFloat32 ( g ) ; bo . writeFloat32 ( b ) ; } const Color3 & Color3 :: wheelRandom ( ) { static const Color3 colorArray [ 8 ] = { Color3 :: blue ( ) , Color3 :: red ( ) , Color3 :: green ( ) , Color3 :: orange ( ) , Color3 :: yellow ( ) , Color3 :: cyan ( ) , Color3 :: purple ( ) , Color3 :: brown ( ) } ; return colorArray [ iRandom ( 0 , 7 ) ] ; } size_t Color3 :: hashCode ( ) const { unsigned int rhash = ( * ( int * ) ( void * ) ( & r ) ) ; unsigned int ghash = ( * ( int * ) ( void * ) ( & g ) ) ; unsigned int bhash = ( * ( int * ) ( void * ) ( & b ) ) ; return rhash + ( ghash * 37 ) + ( bhash * 101 ) ; } Color3 :: Color3 ( const Vector3 & v ) { r = v . x ; g = v . y ; b = v . z ; } Color3 :: Color3 ( const class Color3uint8 & other ) { r = other . r / 255.0f ; g = other . g / 255.0f ; b = other . b / 255.0f ; } Color3 Color3 :: fromARGB ( uint32 x ) { return Color3 ( ( float ) ( ( x >> 16 ) & 0xFF ) , ( float ) ( ( x >> 8 ) & 0xFF ) , ( float ) ( x & 0xFF ) ) / 255.0f ; } Color3 Color3 :: random ( ) { return Color3 ( uniformRandom ( ) , uniformRandom ( ) , uniformRandom ( ) ) . direction ( ) ; } Color3 & Color3 :: operator /= ( float fScalar ) { if ( fScalar != 0.0f ) { float fInvScalar = 1.0f / fScalar ; r *= fInvScalar ; g *= fInvScalar ; b *= fInvScalar ; } else { r = ( float ) G3D :: finf ( ) ; g = ( float ) G3D :: finf ( ) ; b = ( float ) G3D :: finf ( ) ; } return * this ; } float Color3 :: unitize ( float fTolerance ) { float fLength = length ( ) ; if ( fLength > fTolerance ) { float fInvLength = 1.0f / fLength ; r *= fInvLength ; g *= fInvLength ; b *= fInvLength ; } else { fLength = 0.0f ; } return fLength ; } Color3 Color3 :: fromHSV ( const Vector3 & _hsv ) { debugAssertM ( ( _hsv . x <= 1.0f && _hsv . x >= 0.0f ) && ( _hsv . y <= 1.0f && _hsv . y >= 0.0f ) && ( _hsv . z <= 1.0f && _hsv . z >= 0.0f ) , " H , S , V ▁ must ▁ be ▁ between ▁ [ 0,1 ] " ) ; const int i = iMin ( 5 , G3D :: iFloor ( 6.0 * _hsv . x ) ) ; const float f = 6.0f * _hsv . x - i ; const float m = _hsv . z * ( 1.0f - ( _hsv . y ) ) ; const float n = _hsv . z * ( 1.0f - ( _hsv . y * f ) ) ; const float k = _hsv . z * ( 1.0f - ( _hsv . y * ( 1 - f ) ) ) ; switch ( i ) { case 0 : return Color3 ( _hsv . z , k , m ) ; case 1 : return Color3 ( n , _hsv . z , m ) ; case 2 : return Color3 ( m , _hsv . z , k ) ; case 3 : return Color3 ( m , n , _hsv . z ) ; case 4 : return Color3 ( k , m , _hsv . z ) ; case 5 : return Color3 ( _hsv . z , m , n ) ; default : debugAssertM ( false , " fell ▁ through ▁ switch . . " ) ; } return Color3 :: black ( ) ; } Vector3 Color3 :: toHSV ( const Color3 & _rgb ) { debugAssertM ( ( _rgb . r <= 1.0f && _rgb . r >= 0.0f ) && ( _rgb . g <= 1.0f && _rgb . g >= 0.0f ) && ( _rgb . b <= 1.0f && _rgb . b >= 0.0f ) , " R , G , B ▁ must ▁ be ▁ between ▁ [ 0,1 ] " ) ; Vector3 hsv = Vector3 :: zero ( ) ; hsv . z = G3D :: max ( G3D :: max ( _rgb . r , _rgb . g ) , _rgb . b ) ; if ( G3D :: fuzzyEq ( hsv . z , 0.0f ) ) { return hsv ; } const float x = G3D :: min ( G3D :: min ( _rgb . r , _rgb . g ) , _rgb . b ) ; hsv . y = ( hsv . z - x ) / hsv . z ; if ( G3D :: fuzzyEq ( hsv . y , 0.0f ) ) { return hsv ; } Vector3 rgbN ; rgbN . x = ( hsv . z - _rgb . r ) / ( hsv . z - x ) ; rgbN . y = ( hsv . z - _rgb . g ) / ( hsv . z - x ) ; rgbN . z = ( hsv . z - _rgb . b ) / ( hsv . z - x ) ; if ( _rgb . r == hsv . z ) { hsv . x = ( _rgb . g == x ) ? 5.0f + rgbN . z : 1.0f - rgbN . y ; } else if ( _rgb . g == hsv . z ) { hsv . x = ( _rgb . b == x ) ? 1.0f + rgbN . x : 3.0f - rgbN . z ; } else { hsv . x = ( _rgb . r == x ) ? 3.0f + rgbN . y : 5.0f - rgbN . x ; } hsv . x /= 6.0f ; return hsv ; } Color3 Color3 :: jetColorMap ( const float & val ) { debugAssertM ( val <= 1.0f && val >= 0.0f , " value ▁ should ▁ be ▁ in ▁ [ 0,1 ] " ) ; Color3 jet ; jet . r = G3D :: min ( 4.0f * val - 1.5f , - 4.0f * val + 4.5f ) ; jet . g = G3D :: min ( 4.0f * val - 0.5f , - 4.0f * val + 3.5f ) ; jet . b = G3D :: min ( 4.0f * val + 0.5f , - 4.0f * val + 2.5f ) ; jet . r = G3D :: clamp ( jet . r , 0.0f , 1.0f ) ; jet . g = G3D :: clamp ( jet . g , 0.0f , 1.0f ) ; jet . b = G3D :: clamp ( jet . b , 0.0f , 1.0f ) ; return jet ; } std :: string Color3 :: toString ( ) const { return G3D :: format ( " ( % g , ▁ % g , ▁ % g ) " , r , g , b ) ; } Color3 Color3 :: rainbowColorMap ( float hue ) { return fromHSV ( Vector3 ( hue , 1.0f , 1.0f ) ) ; } } ; </DOCUMENT>
<DOCUMENT_ID="SlavaRa/coreclr/tree/master/src/binder/variables.cpp"> # include " variables . hpp " # include " ex . h " namespace BINDER_SPACE { # ifdef FEATURE_VERSIONING_LOG namespace { HRESULT CheckFileExistence ( LPCWSTR pwzFile , LPDWORD pdwAttrib ) { HRESULT hr = S_FALSE ; DWORD dwRet = 0 ; _ASSERTE ( pwzFile && pdwAttrib ) ; * pdwAttrib = 0 ; dwRet = WszGetFileAttributes ( pwzFile ) ; if ( dwRet == INVALID_FILE_ATTRIBUTES ) { hr = HRESULT_FROM_GetLastError ( ) ; if ( ( hr == HRESULT_FROM_WIN32 ( ERROR_FILE_NOT_FOUND ) ) || ( hr == HRESULT_FROM_WIN32 ( ERROR_PATH_NOT_FOUND ) ) ) { GO_WITH_HRESULT ( S_FALSE ) ; } } else { * pdwAttrib = dwRet ; GO_WITH_HRESULT ( S_OK ) ; } Exit : return hr ; } } ; # endif Variables * g_BinderVariables = NULL ; Variables :: Variables ( ) { } Variables :: ~ Variables ( ) { } HRESULT Variables :: Init ( ) { HRESULT hr = S_OK ; EX_TRY { httpURLPrefix . SetLiteral ( W ( " http : // " ) ) ; architectureMSIL . SetLiteral ( W ( " MSIL " ) ) ; architectureX86 . SetLiteral ( W ( " x86" ) ) ; architectureAMD64 . SetLiteral ( W ( " AMD64" ) ) ; architectureARM . SetLiteral ( W ( " ARM " ) ) ; architectureARM64 . SetLiteral ( W ( " ARM64" ) ) ; cultureNeutral . SetLiteral ( W ( " neutral " ) ) ; mscorlib . SetLiteral ( W ( " mscorlib " ) ) ; emptyString . Clear ( ) ; # ifdef FEATURE_VERSIONING_LOG REGUTIL :: CORConfigLevel kCorConfigLevel = static_cast < REGUTIL :: CORConfigLevel > ( REGUTIL :: COR_CONFIG_ENV | REGUTIL :: COR_CONFIG_FUSION ) ; DWORD dwLoggingNeeded = REGUTIL :: GetConfigDWORD_DontUse_ ( CLRConfig :: EXTERNAL_ForceLog , 0 , kCorConfigLevel , TRUE ) ; fLoggingNeeded = ( dwLoggingNeeded ? TRUE : FALSE ) ; NewArrayHolder < WCHAR > pwzLogDirectory = REGUTIL :: GetConfigString_DontUse_ ( CLRConfig :: INTERNAL_LogPath , TRUE , kCorConfigLevel , FALSE ) ; if ( pwzLogDirectory == NULL ) { fLoggingNeeded = FALSE ; } else { DWORD dwAttr = 0 ; hr = CheckFileExistence ( pwzLogDirectory , & dwAttr ) ; if ( ( hr == S_OK ) && ( ( dwAttr & FILE_ATTRIBUTE_DIRECTORY ) != 0 ) ) { logPath . Set ( pwzLogDirectory ) ; } else { hr = S_OK ; fLoggingNeeded = FALSE ; } } # endif } EX_CATCH_HRESULT ( hr ) ; return hr ; } } ; </DOCUMENT>
<DOCUMENT_ID="native-m/slmath/tree/master/source/intersect_util.cpp"> # include < slm / intersect_util . h > SLMATH_BEGIN ( ) intersectLineBox_Line :: intersectLineBox_Line ( const vec3 & origin , const vec3 & direction ) : o ( origin ) , d ( direction ) , inv_d ( fabsf ( direction . x ) > FLT_MIN ? 1 . f / direction . x : FLT_MAX , fabsf ( direction . y ) > FLT_MIN ? 1 . f / direction . y : FLT_MAX , fabsf ( direction . z ) > FLT_MIN ? 1 . f / direction . z : FLT_MAX ) , signx ( direction . x < 0 . f ) , signy ( direction . y < 0 . f ) , signz ( direction . z < 0 . f ) { } bool intersectLineTri ( const vec3 & o , const vec3 & d , const vec3 & v0 , const vec3 & v1 , const vec3 & v2 , float * t ) { const vec3 e1 = v1 - v0 ; const vec3 e2 = v2 - v0 ; const vec3 pvec = cross ( d , e2 ) ; const float det = dot ( e1 , pvec ) ; if ( fabsf ( det ) <= FLT_MIN ) return false ; const float invdet = 1 . f / det ; const vec3 tvec = o - v0 ; const float u = dot ( tvec , pvec ) * invdet ; if ( 0 . f > u || 1 . f < u ) return false ; const vec3 qvec = cross ( tvec , e1 ) ; const float v = dot ( d , qvec ) * invdet ; if ( 0 . f > v || 1 . f < u + v ) return false ; const float s = dot ( e2 , qvec ) * invdet ; if ( s < 0 . f || s >= 1 . f ) return false ; if ( t ) * t = s ; assert ( s >= 0 . f && s <= 1 . f ) ; return true ; } bool intersectLineBox ( const intersectLineBox_Line & r , const vec3 * boxminmax ) { const float t0 = 0.0f ; const float t1 = 1.0f ; const int * const sign = & r . signx ; register float tmin , tmax , tymin , tymax , tzmin , tzmax ; tmin = ( boxminmax [ sign [ 0 ] ] . x - r . o . x ) * r . inv_d . x ; tmax = ( boxminmax [ 1 - sign [ 0 ] ] . x - r . o . x ) * r . inv_d . x ; tymin = ( boxminmax [ sign [ 1 ] ] . y - r . o . y ) * r . inv_d . y ; tymax = ( boxminmax [ 1 - sign [ 1 ] ] . y - r . o . y ) * r . inv_d . y ; if ( ( tmin > tymax ) || ( tymin > tmax ) ) return false ; if ( tymin > tmin ) tmin = tymin ; if ( tymax < tmax ) tmax = tymax ; tzmin = ( boxminmax [ sign [ 2 ] ] . z - r . o . z ) * r . inv_d . z ; tzmax = ( boxminmax [ 1 - sign [ 2 ] ] . z - r . o . z ) * r . inv_d . z ; if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false ; if ( tzmin > tmin ) tmin = tzmin ; if ( tzmax < tmax ) tmax = tzmax ; return ( ( tmin < t1 ) && ( tmax > t0 ) ) ; } bool intersectLineBox ( const vec3 & o , const vec3 & d , const vec3 & boxmin , const vec3 & boxmax ) { intersectLineBox_Line line ( o , d ) ; const vec3 boxminmax [ 2 ] = { boxmin , boxmax } ; return intersectLineBox ( line , boxminmax ) ; } SLMATH_END ( ) </DOCUMENT>
<DOCUMENT_ID="basic60/ARCUS/tree/master/source/kernel/interruption/idt.cpp"> # include " types . h " # include " idt . h " # include " string . h " # include " print _ charmode . h " # include " port . h " # include " keyboard . h " idtEntry idtEntries [ 256 ] ; interruptHandler_t interruptHandler [ 256 ] ; idtPtr iptr ; extern " C " void idtFlush ( uint64 addr ) ; void initIDT ( ) { memset ( ( uint8 * ) idtEntries , 0 , sizeof ( idtEntries ) ) ; iptr . limit = sizeof ( idtEntries ) - 1 ; iptr . base = ( uint64 ) & idtEntries ; writePort ( 0x20 , 0x11 ) ; writePort ( 0xA0 , 0x11 ) ; writePort ( 0x21 , 0x20 ) ; writePort ( 0xA1 , 0x28 ) ; writePort ( 0x21 , 0x01 ) ; writePort ( 0xA1 , 0x01 ) ; writePort ( 0x21 , 0x00 ) ; writePort ( 0xA1 , 0x00 ) ; idtSetEntity ( 0 , ( uint64 ) isr0 , 0x08 , 0x8E ) ; idtSetEntity ( 1 , ( uint64 ) isr1 , 0x08 , 0x8E ) ; idtSetEntity ( 2 , ( uint64 ) isr2 , 0x08 , 0x8E ) ; idtSetEntity ( 3 , ( uint64 ) isr3 , 0x08 , 0x8E ) ; idtSetEntity ( 4 , ( uint64 ) isr4 , 0x08 , 0x8E ) ; idtSetEntity ( 5 , ( uint64 ) isr5 , 0x08 , 0x8E ) ; idtSetEntity ( 6 , ( uint64 ) isr6 , 0x08 , 0x8E ) ; idtSetEntity ( 7 , ( uint64 ) isr7 , 0x08 , 0x8E ) ; idtSetEntity ( 8 , ( uint64 ) isr8 , 0x08 , 0x8E ) ; idtSetEntity ( 9 , ( uint64 ) isr9 , 0x08 , 0x8E ) ; idtSetEntity ( 10 , ( uint64 ) isr10 , 0x08 , 0x8E ) ; idtSetEntity ( 11 , ( uint64 ) isr11 , 0x08 , 0x8E ) ; idtSetEntity ( 12 , ( uint64 ) isr12 , 0x08 , 0x8E ) ; idtSetEntity ( 13 , ( uint64 ) isr13 , 0x08 , 0x8E ) ; idtSetEntity ( 14 , ( uint64 ) isr14 , 0x08 , 0x8E ) ; idtSetEntity ( 15 , ( uint64 ) isr15 , 0x08 , 0x8E ) ; idtSetEntity ( 16 , ( uint64 ) isr16 , 0x08 , 0x8E ) ; idtSetEntity ( 17 , ( uint64 ) isr17 , 0x08 , 0x8E ) ; idtSetEntity ( 18 , ( uint64 ) isr18 , 0x08 , 0x8E ) ; idtSetEntity ( 19 , ( uint64 ) isr19 , 0x08 , 0x8E ) ; idtSetEntity ( 20 , ( uint64 ) isr20 , 0x08 , 0x8E ) ; idtSetEntity ( 21 , ( uint64 ) isr21 , 0x08 , 0x8E ) ; idtSetEntity ( 22 , ( uint64 ) isr22 , 0x08 , 0x8E ) ; idtSetEntity ( 23 , ( uint64 ) isr23 , 0x08 , 0x8E ) ; idtSetEntity ( 24 , ( uint64 ) isr24 , 0x08 , 0x8E ) ; idtSetEntity ( 25 , ( uint64 ) isr25 , 0x08 , 0x8E ) ; idtSetEntity ( 26 , ( uint64 ) isr26 , 0x08 , 0x8E ) ; idtSetEntity ( 27 , ( uint64 ) isr27 , 0x08 , 0x8E ) ; idtSetEntity ( 28 , ( uint64 ) isr27 , 0x08 , 0x8E ) ; idtSetEntity ( 29 , ( uint64 ) isr29 , 0x08 , 0x8E ) ; idtSetEntity ( 30 , ( uint64 ) isr30 , 0x08 , 0x8E ) ; idtSetEntity ( 31 , ( uint64 ) isr31 , 0x08 , 0x8E ) ; idtSetEntity ( 32 , ( uint64 ) irq0 , 0x08 , 0x8E ) ; idtSetEntity ( 33 , ( uint64 ) irq1 , 0x08 , 0x8E ) ; idtSetEntity ( 34 , ( uint64 ) irq2 , 0x08 , 0x8E ) ; idtSetEntity ( 35 , ( uint64 ) irq3 , 0x08 , 0x8E ) ; idtSetEntity ( 36 , ( uint64 ) irq4 , 0x08 , 0x8E ) ; idtSetEntity ( 37 , ( uint64 ) irq5 , 0x08 , 0x8E ) ; idtSetEntity ( 38 , ( uint64 ) irq6 , 0x08 , 0x8E ) ; idtSetEntity ( 39 , ( uint64 ) irq7 , 0x08 , 0x8E ) ; idtSetEntity ( 40 , ( uint64 ) irq8 , 0x08 , 0x8E ) ; idtSetEntity ( 41 , ( uint64 ) irq9 , 0x08 , 0x8E ) ; idtSetEntity ( 42 , ( uint64 ) irq10 , 0x08 , 0x8E ) ; idtSetEntity ( 43 , ( uint64 ) irq11 , 0x08 , 0x8E ) ; idtSetEntity ( 44 , ( uint64 ) irq12 , 0x08 , 0x8E ) ; idtSetEntity ( 45 , ( uint64 ) irq13 , 0x08 , 0x8E ) ; idtSetEntity ( 46 , ( uint64 ) irq14 , 0x08 , 0x8E ) ; idtSetEntity ( 47 , ( uint64 ) irq15 , 0x08 , 0x8E ) ; idtFlush ( ( uint64 ) & iptr ) ; printStr ( " Initializing ▁ interruption ▁ finished . \n " , color_white ) ; } void isrHandler ( ptRegs * regs ) { if ( interruptHandler [ regs -> intNum ] ) interruptHandler [ regs -> intNum ] ( regs ) ; else { } } void irqHandler ( ptRegs * regs ) { if ( regs -> intNum > 40 ) { writePort ( 0xA0 , 0x20 ) ; } writePort ( 0x20 , 0x20 ) ; if ( interruptHandler [ regs -> intNum ] ) { interruptHandler [ regs -> intNum ] ( regs ) ; } } void registerInterruptHandler ( uint8 n , interruptHandler_t h ) { interruptHandler [ n ] = h ; } void idtSetEntity ( uint8 num , uint64 base , uint16 selector , uint8 flags ) { idtEntries [ num ] . offset1 = base & 0xffff ; idtEntries [ num ] . offset2 = ( base >> 16 ) & 0xffff ; idtEntries [ num ] . offset3 = ( base >> 32 ) & 0xffffffff ; idtEntries [ num ] . selector = selector ; idtEntries [ num ] . typeAttr = flags ; } </DOCUMENT>
<DOCUMENT_ID="ricardogsilva/QGIS/tree/master/src/core/qgsproxyprogresstask.cpp"> # include " qgsproxyprogresstask . h " QgsProxyProgressTask :: QgsProxyProgressTask ( const QString & description ) : QgsTask ( description , QgsTask :: Flags ( ) ) { } void QgsProxyProgressTask :: finalize ( bool result ) { mResult = result ; mNotFinishedWaitCondition . wakeAll ( ) ; } bool QgsProxyProgressTask :: run ( ) { mNotFinishedMutex . lock ( ) ; mNotFinishedWaitCondition . wait ( & mNotFinishedMutex ) ; mNotFinishedMutex . unlock ( ) ; return mResult ; } void QgsProxyProgressTask :: setProxyProgress ( double progress ) { QMetaObject :: invokeMethod ( this , " setProgress " , Qt :: AutoConnection , Q_ARG ( double , progress ) ) ; } QgsScopedProxyProgressTask :: QgsScopedProxyProgressTask ( const QString & description ) : mTask ( new QgsProxyProgressTask ( description ) ) { QgsApplication :: taskManager ( ) -> addTask ( mTask ) ; } QgsScopedProxyProgressTask :: ~ QgsScopedProxyProgressTask ( ) { mTask -> finalize ( true ) ; } void QgsScopedProxyProgressTask :: setProgress ( double progress ) { mTask -> setProxyProgress ( progress ) ; } </DOCUMENT>
<DOCUMENT_ID="h0tw1r3/mame/tree/master/src/mame/video/mikromik.cpp"> # include " includes / mikromik . h " # define HORIZONTAL_CHARACTER_PIXELS 10 I8275_DRAW_CHARACTER_MEMBER ( mm1_state :: crtc_display_pixels ) { UINT8 romdata = m_char_rom -> base ( ) [ ( charcode << 4 ) | linecount ] ; int gpa0 = BIT ( gpa , 0 ) ; int llen = m_llen ; int compl_in = rvv ; int hlt_in = hlgt ; int color ; int i , qh , video_in ; int d7 = BIT ( romdata , 7 ) ; int d6 = BIT ( romdata , 6 ) ; int d0 = BIT ( romdata , 0 ) ; UINT8 data = ( romdata << 1 ) | ( d7 & d0 ) ; if ( y < 360 || x >= HORIZONTAL_CHARACTER_PIXELS || compl_in == 0 ) { if ( HORIZONTAL_CHARACTER_PIXELS == 10 ) { qh = d7 & d6 ; video_in = ( ( ( ( d7 & llen ) | ( vsp ? 0 : 1 ) ) & ( gpa0 ? 0 : 1 ) ) & qh ) | lten ; color = ( hlt_in ? 1 : 2 ) * ( video_in ^ compl_in ) ; bitmap . pix32 ( y , x + 8 ) = m_palette -> pen ( color ) ; bitmap . pix32 ( y , x + 9 ) = m_palette -> pen ( color ) ; } for ( i = 0 ; i < 8 ; ++ i ) { qh = BIT ( data , i ) ; video_in = ( ( ( ( d7 & llen ) | ( vsp ? 0 : 1 ) ) & ( gpa0 ? 0 : 1 ) ) & qh ) | lten ; color = ( hlt_in ? 1 : 2 ) * ( video_in ^ compl_in ) ; bitmap . pix32 ( y , x + i ) = m_palette -> pen ( color ) ; } } } static ADDRESS_MAP_START ( mm1_upd7220_map , AS_0 , 16 , mm1_state ) ADDRESS_MAP_GLOBAL_MASK ( 0x7fff ) AM_RANGE ( 0x0000 , 0x7fff ) AM_RAM AM_SHARE ( " video _ ram " ) ADDRESS_MAP_END UPD7220_DISPLAY_PIXELS_MEMBER ( mm1_state :: hgdc_display_pixels ) { UINT16 data = m_video_ram [ address >> 1 ] ; for ( int i = 0 ; i < 16 ; i ++ ) { if ( BIT ( data , i ) ) bitmap . pix32 ( y , x + i ) = m_palette -> pen ( 2 ) ; } } UINT32 mm1_state :: screen_update ( screen_device & screen , bitmap_rgb32 & bitmap , const rectangle & cliprect ) { m_crtc -> screen_update ( screen , bitmap , cliprect ) ; m_hgdc -> screen_update ( screen , bitmap , cliprect ) ; return 0 ; } static const gfx_layout charlayout = { 8 , 16 , RGN_FRAC ( 1 , 1 ) , 1 , { 0 } , { 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 } , { 0 * 8 , 1 * 8 , 2 * 8 , 3 * 8 , 4 * 8 , 5 * 8 , 6 * 8 , 7 * 8 , 8 * 8 , 9 * 8 , 10 * 8 , 11 * 8 , 12 * 8 , 13 * 8 , 14 * 8 , 15 * 8 } , 8 * 16 } ; static GFXDECODE_START ( mm1 ) GFXDECODE_ENTRY ( " chargen " , 0 , charlayout , 0 , 1 ) GFXDECODE_END PALETTE_INIT_MEMBER ( mm1_state , mm1 ) { palette . set_pen_color ( 0 , rgb_t ( 0x00 , 0x00 , 0x00 ) ) ; palette . set_pen_color ( 1 , rgb_t ( 0x00 , 0x7F , 0x0A ) ) ; palette . set_pen_color ( 2 , rgb_t ( 0x08 , 0xD0 , 0x1A ) ) ; } MACHINE_CONFIG_FRAGMENT ( mm1m6_video ) MCFG_SCREEN_ADD ( SCREEN_TAG , RASTER ) MCFG_SCREEN_REFRESH_RATE ( 50 ) MCFG_SCREEN_UPDATE_DRIVER ( mm1_state , screen_update ) MCFG_SCREEN_SIZE ( 800 , 375 ) MCFG_SCREEN_VISIBLE_AREA ( 0 , 800 - 1 , 0 , 375 - 1 ) MCFG_GFXDECODE_ADD ( " gfxdecode " , " palette " , mm1 ) MCFG_PALETTE_ADD ( " palette " , 3 ) MCFG_PALETTE_INIT_OWNER ( mm1_state , mm1 ) MCFG_DEVICE_ADD ( I8275_TAG , I8275 , XTAL_18_720MHz / 8 ) MCFG_I8275_CHARACTER_WIDTH ( HORIZONTAL_CHARACTER_PIXELS ) MCFG_I8275_DRAW_CHARACTER_CALLBACK_OWNER ( mm1_state , crtc_display_pixels ) MCFG_I8275_DRQ_CALLBACK ( DEVWRITELINE ( I8237_TAG , am9517a_device , dreq0_w ) ) MCFG_I8275_VRTC_CALLBACK ( DEVWRITELINE ( UPD7220_TAG , upd7220_device , ext_sync_w ) ) MCFG_VIDEO_SET_SCREEN ( SCREEN_TAG ) MCFG_DEVICE_ADD ( UPD7220_TAG , UPD7220 , XTAL_18_720MHz / 8 ) MCFG_DEVICE_ADDRESS_MAP ( AS_0 , mm1_upd7220_map ) MCFG_UPD7220_DISPLAY_PIXELS_CALLBACK_OWNER ( mm1_state , hgdc_display_pixels ) MCFG_VIDEO_SET_SCREEN ( SCREEN_TAG ) MACHINE_CONFIG_END </DOCUMENT>
<DOCUMENT_ID="Chilledheart/vbox/tree/master/src/libs/xpcom18a4/nsprpub/pr/src/cplus/rcinrval.cpp"> # include " rcinrval . h " RCInterval :: ~ RCInterval ( ) { } RCInterval :: RCInterval ( RCInterval :: RCReservedInterval special ) : RCBase ( ) { switch ( special ) { case RCInterval :: now : interval = PR_IntervalNow ( ) ; break ; case RCInterval :: no_timeout : interval = PR_INTERVAL_NO_TIMEOUT ; break ; case RCInterval :: no_wait : interval = PR_INTERVAL_NO_WAIT ; break ; default : break ; } } </DOCUMENT>
<DOCUMENT_ID="jerrys123111/pcsx2/tree/master/plugins/GSdx_legacy/linux_replay.cpp"> # include " stdafx . h " # include < dlfcn . h > static void * handle ; void help ( ) { fprintf ( stderr , " Loader ▁ gs ▁ file \n " ) ; fprintf ( stderr , " ARG1 ▁ GSdx ▁ plugin \n " ) ; fprintf ( stderr , " ARG2 ▁ . gs ▁ file \n " ) ; fprintf ( stderr , " ARG3 ▁ Ini ▁ directory \n " ) ; if ( handle ) { dlclose ( handle ) ; } exit ( 1 ) ; } char * read_env ( const char * var ) { char * v = getenv ( var ) ; if ( ! v ) { fprintf ( stderr , " Failed ▁ to ▁ get ▁ % s \n " , var ) ; help ( ) ; } return v ; } int main ( int argc , char * argv [ ] ) { if ( argc < 1 ) help ( ) ; char * plugin ; char * gs ; if ( argc > 2 ) { plugin = argv [ 1 ] ; gs = argv [ 2 ] ; } else { plugin = read_env ( " GSDUMP _ SO " ) ; gs = argv [ 1 ] ; } handle = dlopen ( plugin , RTLD_LAZY | RTLD_GLOBAL ) ; if ( handle == NULL ) { fprintf ( stderr , " Failed ▁ to ▁ dlopen ▁ plugin ▁ % s \n " , plugin ) ; help ( ) ; } __attribute__ ( ( stdcall ) ) void ( * GSsetSettingsDir_ptr ) ( const char * ) ; __attribute__ ( ( stdcall ) ) void ( * GSReplay_ptr ) ( char * , int ) ; * ( void * * ) ( & GSsetSettingsDir_ptr ) = dlsym ( handle , " GSsetSettingsDir " ) ; * ( void * * ) ( & GSReplay_ptr ) = dlsym ( handle , " GSReplay " ) ; if ( argc == 2 ) { char * ini = read_env ( " GSDUMP _ CONF " ) ; GSsetSettingsDir_ptr ( ini ) ; } else if ( argc == 4 ) { ( void ) GSsetSettingsDir_ptr ( argv [ 3 ] ) ; } else if ( argc == 3 ) { # ifdef XDG_STD char * val = read_env ( " HOME " ) ; std :: string ini_dir ( val ) ; ini_dir += " / . config / pcsx2 / inis " ; GSsetSettingsDir_ptr ( ini_dir . c_str ( ) ) ; # else fprintf ( stderr , " default ▁ ini ▁ dir ▁ only ▁ supported ▁ on ▁ XDG \n " ) ; help ( ) ; # endif } GSReplay_ptr ( gs , 12 ) ; if ( handle ) { dlclose ( handle ) ; } } </DOCUMENT>
<DOCUMENT_ID="SuslikV/obs-studio/tree/master/plugins/win-capture/graphics-hook/d3d9-capture.cpp"> # define _CRT_SECURE_NO_WARNINGS # include < d3d9 . h > # include < d3d11 . h > # include < dxgi . h > # include " graphics - hook . h " # include " . . / funchook . h " # include " d3d9 - patches . hpp " typedef HRESULT ( STDMETHODCALLTYPE * present_t ) ( IDirect3DDevice9 * , CONST RECT * , CONST RECT * , HWND , CONST RGNDATA * ) ; typedef HRESULT ( STDMETHODCALLTYPE * present_ex_t ) ( IDirect3DDevice9 * , CONST RECT * , CONST RECT * , HWND , CONST RGNDATA * , DWORD ) ; typedef HRESULT ( STDMETHODCALLTYPE * present_swap_t ) ( IDirect3DSwapChain9 * , CONST RECT * , CONST RECT * , HWND , CONST RGNDATA * , DWORD ) ; typedef HRESULT ( STDMETHODCALLTYPE * reset_t ) ( IDirect3DDevice9 * , D3DPRESENT_PARAMETERS * ) ; typedef HRESULT ( STDMETHODCALLTYPE * reset_ex_t ) ( IDirect3DDevice9 * , D3DPRESENT_PARAMETERS * , D3DDISPLAYMODEEX * ) ; typedef HRESULT ( WINAPI * createfactory1_t ) ( REFIID , void * * ) ; static struct func_hook present ; static struct func_hook present_ex ; static struct func_hook present_swap ; static struct func_hook reset ; static struct func_hook reset_ex ; struct d3d9_data { HMODULE d3d9 ; IDirect3DDevice9 * device ; uint32_t cx ; uint32_t cy ; D3DFORMAT d3d9_format ; DXGI_FORMAT dxgi_format ; bool using_shtex : 1 ; bool using_scale : 1 ; volatile bool issued_queries [ NUM_BUFFERS ] ; union { struct { IDirect3DSurface9 * d3d9_copytex ; ID3D11Device * d3d11_device ; ID3D11DeviceContext * d3d11_context ; ID3D11Resource * d3d11_tex ; struct shtex_data * shtex_info ; HANDLE handle ; int patch ; } ; struct { IDirect3DSurface9 * copy_surfaces [ NUM_BUFFERS ] ; IDirect3DSurface9 * render_targets [ NUM_BUFFERS ] ; IDirect3DQuery9 * queries [ NUM_BUFFERS ] ; struct shmem_data * shmem_info ; bool texture_mapped [ NUM_BUFFERS ] ; uint32_t pitch ; int cur_tex ; int copy_wait ; } ; } ; } ; static struct d3d9_data data = { } ; static void d3d9_free ( ) { capture_free ( ) ; if ( data . using_shtex ) { if ( data . d3d11_tex ) data . d3d11_tex -> Release ( ) ; if ( data . d3d11_context ) data . d3d11_context -> Release ( ) ; if ( data . d3d11_device ) data . d3d11_device -> Release ( ) ; if ( data . d3d9_copytex ) data . d3d9_copytex -> Release ( ) ; } else { for ( size_t i = 0 ; i < NUM_BUFFERS ; i ++ ) { if ( data . copy_surfaces [ i ] ) { if ( data . texture_mapped [ i ] ) data . copy_surfaces [ i ] -> UnlockRect ( ) ; data . copy_surfaces [ i ] -> Release ( ) ; } if ( data . render_targets [ i ] ) data . render_targets [ i ] -> Release ( ) ; if ( data . queries [ i ] ) data . queries [ i ] -> Release ( ) ; } } memset ( & data , 0 , sizeof ( data ) ) ; hlog ( " - - - - - - - - - - - - - - - - - ▁ d3d9 ▁ capture ▁ freed ▁ - - - - - - - - - - - - - - - - - " ) ; } static DXGI_FORMAT d3d9_to_dxgi_format ( D3DFORMAT format ) { switch ( ( unsigned long ) format ) { case D3DFMT_A2B10G10R10 : return DXGI_FORMAT_R10G10B10A2_UNORM ; case D3DFMT_A8R8G8B8 : return DXGI_FORMAT_B8G8R8A8_UNORM ; case D3DFMT_X8R8G8B8 : return DXGI_FORMAT_B8G8R8X8_UNORM ; } return DXGI_FORMAT_UNKNOWN ; } const static D3D_FEATURE_LEVEL feature_levels [ ] = { D3D_FEATURE_LEVEL_11_0 , D3D_FEATURE_LEVEL_10_1 , D3D_FEATURE_LEVEL_10_0 , D3D_FEATURE_LEVEL_9_3 , } ; static inline bool shex_init_d3d11 ( ) { PFN_D3D11_CREATE_DEVICE create_device ; createfactory1_t create_factory ; D3D_FEATURE_LEVEL level_used ; IDXGIFactory * factory ; IDXGIAdapter * adapter ; HMODULE d3d11 ; HMODULE dxgi ; HRESULT hr ; d3d11 = load_system_library ( " d3d11 . dll " ) ; if ( ! d3d11 ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ load ▁ D3D11" ) ; return false ; } dxgi = load_system_library ( " dxgi . dll " ) ; if ( ! dxgi ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ load ▁ DXGI " ) ; return false ; } create_factory = ( createfactory1_t ) GetProcAddress ( dxgi , " CreateDXGIFactory1" ) ; if ( ! create_factory ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ get ▁ CreateDXGIFactory1 ▁ address " ) ; return false ; } create_device = ( PFN_D3D11_CREATE_DEVICE ) GetProcAddress ( d3d11 , " D3D11CreateDevice " ) ; if ( ! create_device ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ get ▁ D3D11CreateDevice ▁ address " ) ; return false ; } hr = create_factory ( __uuidof ( IDXGIFactory1 ) , ( void * * ) & factory ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init : ▁ Failed ▁ to ▁ create ▁ factory ▁ object " , hr ) ; return false ; } hr = factory -> EnumAdapters ( 0 , & adapter ) ; factory -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init : ▁ Failed ▁ to ▁ get ▁ adapter " , hr ) ; return false ; } hr = create_device ( adapter , D3D_DRIVER_TYPE_UNKNOWN , nullptr , 0 , feature_levels , sizeof ( feature_levels ) / sizeof ( D3D_FEATURE_LEVEL ) , D3D11_SDK_VERSION , & data . d3d11_device , & level_used , & data . d3d11_context ) ; adapter -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init : ▁ Failed ▁ to ▁ create ▁ D3D11 ▁ device " , hr ) ; return false ; } return true ; } static inline bool d3d9_shtex_init_shtex ( ) { IDXGIResource * res ; HRESULT hr ; D3D11_TEXTURE2D_DESC desc = { } ; desc . Width = data . cx ; desc . Height = data . cy ; desc . Format = data . dxgi_format ; desc . MipLevels = 1 ; desc . ArraySize = 1 ; desc . SampleDesc . Count = 1 ; desc . Usage = D3D11_USAGE_DEFAULT ; desc . MiscFlags = D3D11_RESOURCE_MISC_SHARED ; desc . BindFlags = D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE ; hr = data . d3d11_device -> CreateTexture2D ( & desc , nullptr , ( ID3D11Texture2D * * ) & data . d3d11_tex ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ shtex : ▁ Failed ▁ to ▁ create ▁ D3D11 ▁ texture " , hr ) ; return false ; } hr = data . d3d11_tex -> QueryInterface ( __uuidof ( IDXGIResource ) , ( void * * ) & res ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ shtex : ▁ Failed ▁ to ▁ query ▁ IDXGIResource " , hr ) ; return false ; } hr = res -> GetSharedHandle ( & data . handle ) ; res -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ shtex : ▁ Failed ▁ to ▁ get ▁ shared ▁ handle " , hr ) ; return false ; } return true ; } static inline bool d3d9_shtex_init_copytex ( ) { uint8_t * patch_addr = get_d3d9_patch_addr ( data . d3d9 , data . patch ) ; uint8_t saved_data [ MAX_PATCH_SIZE ] ; size_t patch_size = 0 ; IDirect3DTexture9 * tex ; DWORD protect_val ; HRESULT hr ; if ( patch_addr ) { patch_size = patch [ data . patch ] . size ; VirtualProtect ( patch_addr , patch_size , PAGE_EXECUTE_READWRITE , & protect_val ) ; memcpy ( saved_data , patch_addr , patch_size ) ; memcpy ( patch_addr , patch [ data . patch ] . data , patch_size ) ; } hr = data . device -> CreateTexture ( data . cx , data . cy , 1 , D3DUSAGE_RENDERTARGET , data . d3d9_format , D3DPOOL_DEFAULT , & tex , & data . handle ) ; if ( patch_addr && patch_size ) { memcpy ( patch_addr , saved_data , patch_size ) ; VirtualProtect ( patch_addr , patch_size , protect_val , & protect_val ) ; } if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ copytex : ▁ Failed ▁ to ▁ create ▁ shared ▁ texture " , hr ) ; return false ; } hr = tex -> GetSurfaceLevel ( 0 , & data . d3d9_copytex ) ; tex -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ copytex : ▁ Failed ▁ to ▁ get ▁ surface ▁ level " , hr ) ; return false ; } return true ; } static bool d3d9_shtex_init ( uint32_t cx , uint32_t cy , HWND window ) { data . using_shtex = true ; if ( ! shex_init_d3d11 ( ) ) { return false ; } if ( ! d3d9_shtex_init_shtex ( ) ) { return false ; } if ( ! d3d9_shtex_init_copytex ( ) ) { return false ; } if ( ! capture_init_shtex ( & data . shtex_info , window , cx , cy , data . cx , data . cy , data . dxgi_format , false , ( uintptr_t ) data . handle ) ) { return false ; } hlog ( " d3d9 ▁ shared ▁ texture ▁ capture ▁ successful " ) ; return true ; } static bool d3d9_shmem_init_buffers ( size_t buffer ) { HRESULT hr ; hr = data . device -> CreateOffscreenPlainSurface ( data . cx , data . cy , data . d3d9_format , D3DPOOL_SYSTEMMEM , & data . copy_surfaces [ buffer ] , nullptr ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ create ▁ surface " , hr ) ; return false ; } if ( buffer == 0 ) { D3DLOCKED_RECT rect ; hr = data . copy_surfaces [ buffer ] -> LockRect ( & rect , nullptr , D3DLOCK_READONLY ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ lock ▁ " " buffer " , hr ) ; return false ; } data . pitch = rect . Pitch ; data . copy_surfaces [ buffer ] -> UnlockRect ( ) ; } hr = data . device -> CreateRenderTarget ( data . cx , data . cy , data . d3d9_format , D3DMULTISAMPLE_NONE , 0 , false , & data . render_targets [ buffer ] , nullptr ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ create ▁ render ▁ " " target " , hr ) ; return false ; } hr = data . device -> CreateQuery ( D3DQUERYTYPE_EVENT , & data . queries [ buffer ] ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ create ▁ query " , hr ) ; return false ; } return true ; } static bool d3d9_shmem_init ( uint32_t cx , uint32_t cy , HWND window ) { data . using_shtex = false ; for ( size_t i = 0 ; i < NUM_BUFFERS ; i ++ ) { if ( ! d3d9_shmem_init_buffers ( i ) ) { return false ; } } if ( ! capture_init_shmem ( & data . shmem_info , window , cx , cy , data . cx , data . cy , data . pitch , data . dxgi_format , false ) ) { return false ; } hlog ( " d3d9 ▁ memory ▁ capture ▁ successful " ) ; return true ; } static bool d3d9_get_swap_desc ( D3DPRESENT_PARAMETERS & pp ) { IDirect3DSwapChain9 * swap = nullptr ; HRESULT hr ; hr = data . device -> GetSwapChain ( 0 , & swap ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ get _ swap _ desc : ▁ Failed ▁ to ▁ get ▁ swap ▁ chain " , hr ) ; return false ; } hr = swap -> GetPresentParameters ( & pp ) ; swap -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ get _ swap _ desc : ▁ Failed ▁ to ▁ get ▁ " " presentation ▁ parameters " , hr ) ; return false ; } return true ; } static bool d3d9_init_format_backbuffer ( uint32_t & cx , uint32_t & cy , HWND & window ) { IDirect3DSurface9 * back_buffer = nullptr ; D3DPRESENT_PARAMETERS pp ; D3DSURFACE_DESC desc ; HRESULT hr ; if ( ! d3d9_get_swap_desc ( pp ) ) { return false ; } hr = data . device -> GetRenderTarget ( 0 , & back_buffer ) ; if ( FAILED ( hr ) ) { return false ; } hr = back_buffer -> GetDesc ( & desc ) ; back_buffer -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init _ format _ backbuffer : ▁ Failed ▁ to ▁ get ▁ " " backbuffer ▁ descriptor " , hr ) ; return false ; } data . d3d9_format = desc . Format ; data . dxgi_format = d3d9_to_dxgi_format ( desc . Format ) ; data . using_scale = global_hook_info -> use_scale ; window = pp . hDeviceWindow ; cx = desc . Width ; cy = desc . Height ; if ( data . using_scale ) { data . cx = global_hook_info -> cx ; data . cy = global_hook_info -> cy ; } else { data . cx = desc . Width ; data . cy = desc . Height ; } return true ; } static bool d3d9_init_format_swapchain ( uint32_t & cx , uint32_t & cy , HWND & window ) { D3DPRESENT_PARAMETERS pp ; if ( ! d3d9_get_swap_desc ( pp ) ) { return false ; } data . dxgi_format = d3d9_to_dxgi_format ( pp . BackBufferFormat ) ; data . d3d9_format = pp . BackBufferFormat ; data . using_scale = global_hook_info -> use_scale ; window = pp . hDeviceWindow ; cx = pp . BackBufferWidth ; cy = pp . BackBufferHeight ; if ( data . using_scale ) { data . cx = global_hook_info -> cx ; data . cy = global_hook_info -> cy ; } else { data . cx = pp . BackBufferWidth ; data . cy = pp . BackBufferHeight ; } return true ; } static void d3d9_init ( IDirect3DDevice9 * device ) { IDirect3DDevice9Ex * d3d9ex = nullptr ; bool success ; uint32_t cx = 0 ; uint32_t cy = 0 ; HWND window = nullptr ; HRESULT hr ; data . d3d9 = get_system_module ( " d3d9 . dll " ) ; data . device = device ; hr = device -> QueryInterface ( __uuidof ( IDirect3DDevice9Ex ) , ( void * * ) & d3d9ex ) ; if ( SUCCEEDED ( hr ) ) { d3d9ex -> Release ( ) ; data . patch = - 1 ; } else { data . patch = get_d3d9_patch ( data . d3d9 ) ; } if ( ! d3d9_init_format_backbuffer ( cx , cy , window ) ) { if ( ! d3d9_init_format_swapchain ( cx , cy , window ) ) { return ; } } if ( global_hook_info -> force_shmem || ( ! d3d9ex && data . patch == - 1 ) ) { success = d3d9_shmem_init ( cx , cy , window ) ; } else { success = d3d9_shtex_init ( cx , cy , window ) ; } if ( ! success ) d3d9_free ( ) ; } static inline HRESULT get_backbuffer ( IDirect3DDevice9 * device , IDirect3DSurface9 * * surface ) { static bool use_backbuffer = false ; static bool checked_exceptions = false ; if ( ! checked_exceptions ) { if ( _strcmpi ( get_process_name ( ) , " hotd _ ng . exe " ) == 0 ) use_backbuffer = true ; checked_exceptions = true ; } if ( use_backbuffer ) { return device -> GetBackBuffer ( 0 , 0 , D3DBACKBUFFER_TYPE_MONO , surface ) ; } else { return device -> GetRenderTarget ( 0 , surface ) ; } } static inline void d3d9_shtex_capture ( IDirect3DSurface9 * backbuffer ) { D3DTEXTUREFILTERTYPE filter ; HRESULT hr ; filter = data . using_scale ? D3DTEXF_LINEAR : D3DTEXF_NONE ; hr = data . device -> StretchRect ( backbuffer , nullptr , data . d3d9_copytex , nullptr , filter ) ; if ( FAILED ( hr ) ) hlog_hr ( " d3d9 _ shtex _ capture : ▁ StretchRect ▁ failed " , hr ) ; } static inline void d3d9_shmem_capture_queue_copy ( ) { for ( int i = 0 ; i < NUM_BUFFERS ; i ++ ) { IDirect3DSurface9 * target = data . copy_surfaces [ i ] ; D3DLOCKED_RECT rect ; HRESULT hr ; if ( ! data . issued_queries [ i ] ) { continue ; } if ( data . queries [ i ] -> GetData ( 0 , 0 , 0 ) != S_OK ) { continue ; } data . issued_queries [ i ] = false ; hr = target -> LockRect ( & rect , nullptr , D3DLOCK_READONLY ) ; if ( SUCCEEDED ( hr ) ) { data . texture_mapped [ i ] = true ; shmem_copy_data ( i , rect . pBits ) ; } break ; } } static inline void d3d9_shmem_capture ( IDirect3DSurface9 * backbuffer ) { D3DTEXTUREFILTERTYPE filter ; IDirect3DSurface9 * copy ; int next_tex ; HRESULT hr ; d3d9_shmem_capture_queue_copy ( ) ; next_tex = ( data . cur_tex == NUM_BUFFERS - 1 ) ? 0 : data . cur_tex + 1 ; filter = data . using_scale ? D3DTEXF_LINEAR : D3DTEXF_NONE ; copy = data . render_targets [ data . cur_tex ] ; hr = data . device -> StretchRect ( backbuffer , nullptr , copy , nullptr , filter ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ capture : ▁ StretchRect ▁ failed " , hr ) ; return ; } if ( data . copy_wait < NUM_BUFFERS - 1 ) { data . copy_wait ++ ; } else { IDirect3DSurface9 * src = data . render_targets [ next_tex ] ; IDirect3DSurface9 * dst = data . copy_surfaces [ next_tex ] ; if ( shmem_texture_data_lock ( next_tex ) ) { dst -> UnlockRect ( ) ; data . texture_mapped [ next_tex ] = false ; shmem_texture_data_unlock ( next_tex ) ; } hr = data . device -> GetRenderTargetData ( src , dst ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ capture : ▁ GetRenderTargetData ▁ " " failed " , hr ) ; } data . queries [ next_tex ] -> Issue ( D3DISSUE_END ) ; data . issued_queries [ next_tex ] = true ; } data . cur_tex = next_tex ; } static void d3d9_capture ( IDirect3DDevice9 * device , IDirect3DSurface9 * backbuffer ) { if ( capture_should_stop ( ) ) { d3d9_free ( ) ; } if ( capture_should_init ( ) ) { d3d9_init ( device ) ; } if ( capture_ready ( ) ) { if ( data . using_shtex ) d3d9_shtex_capture ( backbuffer ) ; else d3d9_shmem_capture ( backbuffer ) ; } } static int present_recurse = 0 ; static inline void present_begin ( IDirect3DDevice9 * device , IDirect3DSurface9 * & backbuffer ) { HRESULT hr ; if ( ! present_recurse ) { hr = get_backbuffer ( device , & backbuffer ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ capture : ▁ Failed ▁ to ▁ get ▁ " " backbuffer " , hr ) ; } if ( ! global_hook_info -> capture_overlay ) { d3d9_capture ( device , backbuffer ) ; } } present_recurse ++ ; } static inline void present_end ( IDirect3DDevice9 * device , IDirect3DSurface9 * backbuffer ) { present_recurse -- ; if ( ! present_recurse ) { if ( global_hook_info -> capture_overlay ) { if ( ! present_recurse ) d3d9_capture ( device , backbuffer ) ; } if ( backbuffer ) backbuffer -> Release ( ) ; } } static bool hooked_reset = false ; static void setup_reset_hooks ( IDirect3DDevice9 * device ) ; static HRESULT STDMETHODCALLTYPE hook_present ( IDirect3DDevice9 * device , CONST RECT * src_rect , CONST RECT * dst_rect , HWND override_window , CONST RGNDATA * dirty_region ) { IDirect3DSurface9 * backbuffer = nullptr ; HRESULT hr ; if ( ! hooked_reset ) setup_reset_hooks ( device ) ; present_begin ( device , backbuffer ) ; unhook ( & present ) ; present_t call = ( present_t ) present . call_addr ; hr = call ( device , src_rect , dst_rect , override_window , dirty_region ) ; rehook ( & present ) ; present_end ( device , backbuffer ) ; return hr ; } static HRESULT STDMETHODCALLTYPE hook_present_ex ( IDirect3DDevice9 * device , CONST RECT * src_rect , CONST RECT * dst_rect , HWND override_window , CONST RGNDATA * dirty_region , DWORD flags ) { IDirect3DSurface9 * backbuffer = nullptr ; HRESULT hr ; if ( ! hooked_reset ) setup_reset_hooks ( device ) ; present_begin ( device , backbuffer ) ; unhook ( & present_ex ) ; present_ex_t call = ( present_ex_t ) present_ex . call_addr ; hr = call ( device , src_rect , dst_rect , override_window , dirty_region , flags ) ; rehook ( & present_ex ) ; present_end ( device , backbuffer ) ; return hr ; } static HRESULT STDMETHODCALLTYPE hook_present_swap ( IDirect3DSwapChain9 * swap , CONST RECT * src_rect , CONST RECT * dst_rect , HWND override_window , CONST RGNDATA * dirty_region , DWORD flags ) { IDirect3DSurface9 * backbuffer = nullptr ; IDirect3DDevice9 * device = nullptr ; HRESULT hr ; if ( ! present_recurse ) { hr = swap -> GetDevice ( & device ) ; if ( SUCCEEDED ( hr ) ) { device -> Release ( ) ; } } if ( device ) { if ( ! hooked_reset ) setup_reset_hooks ( device ) ; present_begin ( device , backbuffer ) ; } unhook ( & present_swap ) ; present_swap_t call = ( present_swap_t ) present_swap . call_addr ; hr = call ( swap , src_rect , dst_rect , override_window , dirty_region , flags ) ; rehook ( & present_swap ) ; if ( device ) present_end ( device , backbuffer ) ; return hr ; } static HRESULT STDMETHODCALLTYPE hook_reset ( IDirect3DDevice9 * device , D3DPRESENT_PARAMETERS * params ) { HRESULT hr ; if ( capture_active ( ) ) d3d9_free ( ) ; unhook ( & reset ) ; reset_t call = ( reset_t ) reset . call_addr ; hr = call ( device , params ) ; rehook ( & reset ) ; return hr ; } static HRESULT STDMETHODCALLTYPE hook_reset_ex ( IDirect3DDevice9 * device , D3DPRESENT_PARAMETERS * params , D3DDISPLAYMODEEX * dmex ) { HRESULT hr ; if ( capture_active ( ) ) d3d9_free ( ) ; unhook ( & reset_ex ) ; reset_ex_t call = ( reset_ex_t ) reset_ex . call_addr ; hr = call ( device , params , dmex ) ; rehook ( & reset_ex ) ; return hr ; } static void setup_reset_hooks ( IDirect3DDevice9 * device ) { IDirect3DDevice9Ex * d3d9ex = nullptr ; uintptr_t * vtable = * ( uintptr_t * * ) device ; HRESULT hr ; hook_init ( & reset , ( void * ) vtable [ 16 ] , ( void * ) hook_reset , " IDirect3DDevice9 : : Reset " ) ; rehook ( & reset ) ; hr = device -> QueryInterface ( __uuidof ( IDirect3DDevice9Ex ) , ( void * * ) & d3d9ex ) ; if ( SUCCEEDED ( hr ) ) { hook_init ( & reset_ex , ( void * ) vtable [ 132 ] , ( void * ) hook_reset_ex , " IDirect3DDevice9Ex : : ResetEx " ) ; rehook ( & reset_ex ) ; d3d9ex -> Release ( ) ; } hooked_reset = true ; } typedef HRESULT ( WINAPI * d3d9create_ex_t ) ( UINT , IDirect3D9Ex * * ) ; static bool manually_get_d3d9_addrs ( HMODULE d3d9_module , void * * present_addr , void * * present_ex_addr , void * * present_swap_addr ) { d3d9create_ex_t create_ex ; D3DPRESENT_PARAMETERS pp ; HRESULT hr ; IDirect3DDevice9Ex * device ; IDirect3D9Ex * d3d9ex ; hlog ( " D3D9 ▁ values ▁ invalid , ▁ manually ▁ obtaining " ) ; create_ex = ( d3d9create_ex_t ) GetProcAddress ( d3d9_module , " Direct3DCreate9Ex " ) ; if ( ! create_ex ) { hlog ( " Failed ▁ to ▁ load ▁ Direct3DCreate9Ex " ) ; return false ; } if ( FAILED ( create_ex ( D3D_SDK_VERSION , & d3d9ex ) ) ) { hlog ( " Failed ▁ to ▁ create ▁ D3D9 ▁ context " ) ; return false ; } memset ( & pp , 0 , sizeof ( pp ) ) ; pp . Windowed = 1 ; pp . SwapEffect = D3DSWAPEFFECT_FLIP ; pp . BackBufferFormat = D3DFMT_A8R8G8B8 ; pp . BackBufferCount = 1 ; pp . hDeviceWindow = ( HWND ) dummy_window ; pp . PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE ; hr = d3d9ex -> CreateDeviceEx ( D3DADAPTER_DEFAULT , D3DDEVTYPE_HAL , dummy_window , D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_NOWINDOWCHANGES , & pp , NULL , & device ) ; d3d9ex -> Release ( ) ; if ( SUCCEEDED ( hr ) ) { uintptr_t * vtable = * ( uintptr_t * * ) device ; IDirect3DSwapChain9 * swap ; * present_addr = ( void * ) vtable [ 17 ] ; * present_ex_addr = ( void * ) vtable [ 121 ] ; hr = device -> GetSwapChain ( 0 , & swap ) ; if ( SUCCEEDED ( hr ) ) { vtable = * ( uintptr_t * * ) swap ; * present_swap_addr = ( void * ) vtable [ 3 ] ; swap -> Release ( ) ; } device -> Release ( ) ; } else { hlog ( " Failed ▁ to ▁ create ▁ D3D9 ▁ device " ) ; return false ; } return true ; } bool hook_d3d9 ( void ) { HMODULE d3d9_module = get_system_module ( " d3d9 . dll " ) ; uint32_t d3d9_size ; void * present_addr = nullptr ; void * present_ex_addr = nullptr ; void * present_swap_addr = nullptr ; if ( ! d3d9_module ) { return false ; } d3d9_size = module_size ( d3d9_module ) ; if ( global_hook_info -> offsets . d3d9 . present < d3d9_size && global_hook_info -> offsets . d3d9 . present_ex < d3d9_size && global_hook_info -> offsets . d3d9 . present_swap < d3d9_size ) { present_addr = get_offset_addr ( d3d9_module , global_hook_info -> offsets . d3d9 . present ) ; present_ex_addr = get_offset_addr ( d3d9_module , global_hook_info -> offsets . d3d9 . present_ex ) ; present_swap_addr = get_offset_addr ( d3d9_module , global_hook_info -> offsets . d3d9 . present_swap ) ; } else { if ( ! dummy_window ) { return false ; } if ( ! manually_get_d3d9_addrs ( d3d9_module , & present_addr , & present_ex_addr , & present_swap_addr ) ) { hlog ( " Failed ▁ to ▁ get ▁ D3D9 ▁ values " ) ; return true ; } } if ( ! present_addr && ! present_ex_addr && ! present_swap_addr ) { hlog ( " Invalid ▁ D3D9 ▁ values " ) ; return true ; } if ( present_swap_addr ) { hook_init ( & present_swap , present_swap_addr , ( void * ) hook_present_swap , " IDirect3DSwapChain9 : : Present " ) ; rehook ( & present_swap ) ; } if ( present_ex_addr ) { hook_init ( & present_ex , present_ex_addr , ( void * ) hook_present_ex , " IDirect3DDevice9Ex : : PresentEx " ) ; rehook ( & present_ex ) ; } if ( present_addr ) { hook_init ( & present , present_addr , ( void * ) hook_present , " IDirect3DDevice9 : : Present " ) ; rehook ( & present ) ; } hlog ( " Hooked ▁ D3D9" ) ; return true ; } </DOCUMENT>
<DOCUMENT_ID="poixen/Cockatrice/tree/master/cockatrice/src/dlg_edit_user.cpp"> # include < QSettings > # include < QLabel > # include < QGridLayout > # include < QHBoxLayout > # include < QDialogButtonBox > # include < QDebug > # include " dlg _ edit _ user . h " # include " settingscache . h " DlgEditUser :: DlgEditUser ( QWidget * parent , QString email , int gender , QString country , QString realName ) : QDialog ( parent ) { emailLabel = new QLabel ( tr ( " Email : " ) ) ; emailEdit = new QLineEdit ( ) ; emailLabel -> setBuddy ( emailEdit ) ; emailEdit -> setText ( email ) ; genderLabel = new QLabel ( tr ( " Pronouns : " ) ) ; genderEdit = new QComboBox ( ) ; genderLabel -> setBuddy ( genderEdit ) ; genderEdit -> insertItem ( 0 , QIcon ( " : / resources / genders / unknown . svg " ) , tr ( " Neutral " ) ) ; genderEdit -> insertItem ( 1 , QIcon ( " : / resources / genders / male . svg " ) , tr ( " Masculine " ) ) ; genderEdit -> insertItem ( 2 , QIcon ( " : / resources / genders / female . svg " ) , tr ( " Feminine " ) ) ; genderEdit -> setCurrentIndex ( gender + 1 ) ; countryLabel = new QLabel ( tr ( " Country : " ) ) ; countryEdit = new QComboBox ( ) ; countryLabel -> setBuddy ( countryEdit ) ; countryEdit -> insertItem ( 0 , tr ( " Undefined " ) ) ; countryEdit -> setCurrentIndex ( 0 ) ; QStringList countries = settingsCache -> getCountries ( ) ; int i = 1 ; foreach ( QString c , countries ) { countryEdit -> addItem ( QPixmap ( " : / resources / countries / " + c + " . svg " ) , c ) ; if ( c == country ) countryEdit -> setCurrentIndex ( i ) ; ++ i ; } realnameLabel = new QLabel ( tr ( " Real ▁ name : " ) ) ; realnameEdit = new QLineEdit ( ) ; realnameLabel -> setBuddy ( realnameEdit ) ; realnameEdit -> setText ( realName ) ; QGridLayout * grid = new QGridLayout ; grid -> addWidget ( emailLabel , 0 , 0 ) ; grid -> addWidget ( emailEdit , 0 , 1 ) ; grid -> addWidget ( genderLabel , 1 , 0 ) ; grid -> addWidget ( genderEdit , 1 , 1 ) ; grid -> addWidget ( countryLabel , 2 , 0 ) ; grid -> addWidget ( countryEdit , 2 , 1 ) ; grid -> addWidget ( realnameLabel , 3 , 0 ) ; grid -> addWidget ( realnameEdit , 3 , 1 ) ; QDialogButtonBox * buttonBox = new QDialogButtonBox ( QDialogButtonBox :: Ok | QDialogButtonBox :: Cancel ) ; connect ( buttonBox , SIGNAL ( accepted ( ) ) , this , SLOT ( actOk ( ) ) ) ; connect ( buttonBox , SIGNAL ( rejected ( ) ) , this , SLOT ( actCancel ( ) ) ) ; QVBoxLayout * mainLayout = new QVBoxLayout ; mainLayout -> addLayout ( grid ) ; mainLayout -> addWidget ( buttonBox ) ; setLayout ( mainLayout ) ; setWindowTitle ( tr ( " Edit ▁ user ▁ profile " ) ) ; setFixedHeight ( sizeHint ( ) . height ( ) ) ; setMinimumWidth ( 300 ) ; } void DlgEditUser :: actOk ( ) { accept ( ) ; } void DlgEditUser :: actCancel ( ) { reject ( ) ; } </DOCUMENT>
<DOCUMENT_ID="paulfitz/phantomjs/tree/master/src/qt/qtwebkit/Tools/DumpRenderTree/TestNetscapePlugIn/Tests/GetURLWithJavaScriptURLDestroyingPlugin.cpp"> # include " PluginTest . h " using namespace std ; class GetURLWithJavaScriptURLDestroyingPlugin : public PluginTest { public : GetURLWithJavaScriptURLDestroyingPlugin ( NPP npp , const string & identifier ) : PluginTest ( npp , identifier ) { } private : virtual NPError NPP_New ( NPMIMEType pluginType , uint16_t mode , int16_t argc , char * argn [ ] , char * argv [ ] , NPSavedData * saved ) { NPN_GetURL ( " javascript : removePlugin ( ) " , 0 ) ; return NPERR_NO_ERROR ; } } ; static PluginTest :: Register < GetURLWithJavaScriptURLDestroyingPlugin > getURLWithJavaScriptURLDestroyingPlugin ( " get - url - with - javascript - url - destroying - plugin " ) ; </DOCUMENT>
<DOCUMENT_ID="cristal/Patch/tree/master/dep/acelite/ace/Parse_Node.cpp"> # include " ace / Parse _ Node . h " # if ( ACE_USES_CLASSIC_SVC_CONF == 1 ) # include " ace / Service _ Config . h " # include " ace / Service _ Repository . h " # include " ace / Service _ Types . h " # include " ace / Task . h " # include " ace / DLL . h " # include " ace / ACE . h " # include " ace / OS _ NS _ string . h " # include " ace / ARGV . h " # include < list > ACE_BEGIN_VERSIONED_NAMESPACE_DECL ACE_ALLOC_HOOK_DEFINE ( ACE_Stream_Node ) void ACE_Stream_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Stream _ Node : : dump " ) ; # endif } void ACE_Stream_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Stream _ Node : : apply " ) ; const ACE_Service_Type * sst = this -> node_ -> record ( config ) ; if ( sst == 0 ) const_cast < ACE_Static_Node * > ( this -> node_ ) -> apply ( config , yyerrno ) ; if ( yyerrno != 0 ) return ; sst = this -> node_ -> record ( config ) ; ACE_Stream_Type * st = dynamic_cast < ACE_Stream_Type * > ( const_cast < ACE_Service_Type_Impl * > ( sst -> type ( ) ) ) ; std :: list < const ACE_Static_Node * > mod_list ; const ACE_Static_Node * module ; for ( module = dynamic_cast < const ACE_Static_Node * > ( this -> mods_ ) ; module != 0 ; module = dynamic_cast < ACE_Static_Node * > ( module -> link ( ) ) ) mod_list . push_front ( module ) ; std :: list < const ACE_Static_Node * > :: const_iterator iter ; for ( iter = mod_list . begin ( ) ; iter != mod_list . end ( ) ; ++ iter ) { module = * iter ; ACE_ARGV args ( module -> parameters ( ) ) ; const ACE_Service_Type * mst = module -> record ( config ) ; if ( mst == 0 ) const_cast < ACE_Static_Node * > ( module ) -> apply ( config , yyerrno ) ; if ( yyerrno != 0 ) { if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " dynamic ▁ initialization ▁ failed ▁ for ▁ Module ▁ % s \n " ) , module -> name ( ) ) ) ; } ++ yyerrno ; continue ; } ACE_Module_Type const * const mt1 = static_cast < ACE_Module_Type const * > ( module -> record ( config ) -> type ( ) ) ; ACE_Module_Type * mt = const_cast < ACE_Module_Type * > ( mt1 ) ; if ( st -> push ( mt ) == - 1 ) { if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " dynamic ▁ initialization ▁ failed ▁ for ▁ Stream ▁ % s \n " ) , this -> node_ -> name ( ) ) ) ; } ++ yyerrno ; } } # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ( % P | % t ) ▁ Did ▁ stream ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> node_ -> name ( ) , yyerrno ) ) ; # endif } ACE_ALLOC_HOOK_DEFINE ( ACE_Parse_Node ) void ACE_Parse_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Parse _ Node : : dump " ) ; # endif } const ACE_TCHAR * ACE_Parse_Node :: name ( void ) const { ACE_TRACE ( " ACE _ Parse _ Node : : name " ) ; return this -> name_ ; } ACE_Parse_Node * ACE_Parse_Node :: link ( void ) const { ACE_TRACE ( " ACE _ Parse _ Node : : link " ) ; return this -> next_ ; } void ACE_Parse_Node :: link ( ACE_Parse_Node * n ) { ACE_TRACE ( " ACE _ Parse _ Node : : link " ) ; ACE_Parse_Node * t = this ; while ( t -> next_ != 0 ) t = t -> next_ ; t -> next_ = n ; } ACE_Stream_Node :: ACE_Stream_Node ( const ACE_Static_Node * str_ops , const ACE_Parse_Node * str_mods ) : ACE_Parse_Node ( ( str_ops == 0 ? ACE_TEXT ( " < unknown > " ) : str_ops -> name ( ) ) ) , node_ ( str_ops ) , mods_ ( str_mods ) { ACE_TRACE ( " ACE _ Stream _ Node : : ACE _ Stream _ Node " ) ; } ACE_Stream_Node :: ~ ACE_Stream_Node ( void ) { ACE_TRACE ( " ACE _ Stream _ Node : : ~ ACE _ Stream _ Node " ) ; ACE_Static_Node * n = const_cast < ACE_Static_Node * > ( this -> node_ ) ; delete n ; ACE_Parse_Node * m = const_cast < ACE_Parse_Node * > ( this -> mods_ ) ; delete m ; } ACE_Parse_Node :: ACE_Parse_Node ( void ) : name_ ( 0 ) , next_ ( 0 ) { ACE_TRACE ( " ACE _ Parse _ Node : : ACE _ Parse _ Node " ) ; } ACE_Parse_Node :: ACE_Parse_Node ( const ACE_TCHAR * nm ) : name_ ( ACE :: strnew ( nm ) ) , next_ ( 0 ) { ACE_TRACE ( " ACE _ Parse _ Node : : ACE _ Parse _ Node " ) ; } void ACE_Parse_Node :: print ( void ) const { ACE_TRACE ( " ACE _ Parse _ Node : : print " ) ; ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " svc ▁ = ▁ % s \n " ) , this -> name ( ) ) ) ; if ( this -> next_ ) this -> next_ -> print ( ) ; } ACE_Parse_Node :: ~ ACE_Parse_Node ( void ) { ACE_TRACE ( " ACE _ Parse _ Node : : ~ ACE _ Parse _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> name_ ) ; delete this -> next_ ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Suspend_Node ) void ACE_Suspend_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Suspend _ Node : : dump " ) ; # endif } ACE_Suspend_Node :: ACE_Suspend_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Suspend _ Node : : ACE _ Suspend _ Node " ) ; } ACE_Suspend_Node :: ~ ACE_Suspend_Node ( void ) { } ACE_ALLOC_HOOK_DEFINE ( ACE_Resume_Node ) void ACE_Resume_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Resume _ Node : : dump " ) ; # endif } ACE_Resume_Node :: ACE_Resume_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Resume _ Node : : ACE _ Resume _ Node " ) ; } ACE_Resume_Node :: ~ ACE_Resume_Node ( void ) { } void ACE_Suspend_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Suspend _ Node : : apply " ) ; if ( config -> suspend ( this -> name ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ suspend ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; # endif } void ACE_Resume_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Resume _ Node : : apply " ) ; if ( config -> resume ( this -> name ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ resume ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; # endif } ACE_ALLOC_HOOK_DEFINE ( ACE_Remove_Node ) void ACE_Remove_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Remove _ Node : : dump " ) ; # endif } ACE_Remove_Node :: ACE_Remove_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Remove _ Node : : ACE _ Remove _ Node " ) ; } ACE_Remove_Node :: ~ ACE_Remove_Node ( void ) { } void ACE_Remove_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Remove _ Node : : apply " ) ; if ( config -> remove ( this -> name ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Remove _ Node : : apply " ) ACE_TEXT ( " ▁ - ▁ did ▁ remove ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; # endif } ACE_Dynamic_Node :: ACE_Dynamic_Node ( ACE_Service_Type_Factory const * stf , ACE_TCHAR * parms ) : ACE_Static_Node ( stf -> name ( ) , parms ) , factory_ ( stf ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : ACE _ Dynamic _ Node " ) ; } void ACE_Dynamic_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : apply " ) ; if ( config -> initialize ( this -> factory_ . get ( ) , this -> parameters ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Dynamic _ Node : : apply " ) ACE_TEXT ( " ▁ - ▁ Did ▁ dynamic ▁ on ▁ % s ▁ ( yyerrno = % d ) \n " ) , this -> name ( ) , yyerrno ) ) ; # endif } ACE_ALLOC_HOOK_DEFINE ( ACE_Dynamic_Node ) void ACE_Dynamic_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Dynamic _ Node : : dump " ) ; # endif } ACE_Dynamic_Node :: ~ ACE_Dynamic_Node ( void ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : ~ ACE _ Dynamic _ Node " ) ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Static_Node ) void ACE_Static_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Static _ Node : : dump " ) ; # endif } ACE_Static_Node :: ACE_Static_Node ( const ACE_TCHAR * nm , ACE_TCHAR * params ) : ACE_Parse_Node ( nm ) , parameters_ ( ACE :: strnew ( params ) ) { ACE_TRACE ( " ACE _ Static _ Node : : ACE _ Static _ Node " ) ; } const ACE_Service_Type * ACE_Static_Node :: record ( const ACE_Service_Gestalt * config ) const { ACE_TRACE ( " ACE _ Static _ Node : : record " ) ; ACE_Service_Type * sr = 0 ; if ( config -> find ( this -> name ( ) , ( const ACE_Service_Type * * ) & sr ) == - 1 ) return 0 ; return sr ; } ACE_TCHAR * ACE_Static_Node :: parameters ( void ) const { ACE_TRACE ( " ACE _ Static _ Node : : parameters " ) ; return this -> parameters_ ; } void ACE_Static_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Static _ Node : : apply " ) ; if ( config -> initialize ( this -> name ( ) , this -> parameters ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Static _ Node : : apply ▁ - " ) ACE_TEXT ( " ▁ Did ▁ static ▁ on ▁ % s ▁ ( yyerrno = % d ) \n " ) , this -> name ( ) , yyerrno ) ) ; # endif } ACE_Static_Node :: ~ ACE_Static_Node ( void ) { ACE_TRACE ( " ACE _ Static _ Node : : ~ ACE _ Static _ Node " ) ; delete [ ] this -> parameters_ ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Location_Node ) void ACE_Location_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Location _ Node : : dump " ) ; # endif } ACE_Location_Node :: ACE_Location_Node ( void ) : pathname_ ( 0 ) , dll_ ( ) , symbol_ ( 0 ) { ACE_TRACE ( " ACE _ Location _ Node : : ACE _ Location _ Node " ) ; } ACE_Location_Node :: ~ ACE_Location_Node ( void ) { ACE_TRACE ( " ACE _ Location _ Node : : ~ ACE _ Location _ Node " ) ; } const ACE_DLL & ACE_Location_Node :: dll ( void ) { return this -> dll_ ; } const ACE_TCHAR * ACE_Location_Node :: pathname ( void ) const { ACE_TRACE ( " ACE _ Location _ Node : : pathname " ) ; return this -> pathname_ ; } void ACE_Location_Node :: pathname ( const ACE_TCHAR * p ) { ACE_TRACE ( " ACE _ Location _ Node : : pathname " ) ; this -> pathname_ = p ; } int ACE_Location_Node :: dispose ( void ) const { ACE_TRACE ( " ACE _ Location _ Node : : dispose " ) ; return this -> must_delete_ ; } int ACE_Location_Node :: open_dll ( int & yyerrno ) { ACE_TRACE ( " ACE _ Location _ Node : : open _ dll " ) ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ LN : : open _ dll ▁ - ▁ path = % s \n " ) , this -> pathname ( ) ) ) ; # endif if ( - 1 == this -> dll_ . open ( this -> pathname ( ) ) ) { ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) { ACE_TCHAR * errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ LN : : open _ dll ▁ - ▁ Failed ▁ to ▁ open ▁ % s : ▁ % s \n " ) , this -> pathname ( ) , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } # endif return - 1 ; } return 0 ; } void ACE_Location_Node :: set_symbol ( void * s ) { ACE_TRACE ( " ACE _ Location _ Node : : set _ symbol " ) ; this -> symbol_ = s ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Object_Node ) void ACE_Object_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Object _ Node : : dump " ) ; # endif } ACE_Object_Node :: ACE_Object_Node ( const ACE_TCHAR * path , const ACE_TCHAR * obj_name ) : object_name_ ( ACE :: strnew ( obj_name ) ) { ACE_TRACE ( " ACE _ Object _ Node : : ACE _ Object _ Node " ) ; this -> pathname ( ACE :: strnew ( path ) ) ; this -> must_delete_ = 0 ; } void * ACE_Object_Node :: symbol ( ACE_Service_Gestalt * , int & yyerrno , ACE_Service_Object_Exterminator * ) { ACE_TRACE ( " ACE _ Object _ Node : : symbol " ) ; if ( this -> open_dll ( yyerrno ) == 0 ) { ACE_TCHAR * object_name = const_cast < ACE_TCHAR * > ( this -> object_name_ ) ; this -> symbol_ = this -> dll_ . symbol ( object_name ) ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) { ACE_TCHAR * errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ DLL : : symbol ▁ - " ) ACE_TEXT ( " ▁ Failed ▁ for ▁ object ▁ % s : ▁ % s \n " ) , object_name , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } # endif return 0 ; } return this -> symbol_ ; } return 0 ; } ACE_Object_Node :: ~ ACE_Object_Node ( void ) { ACE_TRACE ( " ACE _ Object _ Node : : ~ ACE _ Object _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> object_name_ ) ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Function_Node ) void ACE_Function_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Function _ Node : : dump " ) ; # endif } ACE_Function_Node :: ACE_Function_Node ( const ACE_TCHAR * path , const ACE_TCHAR * func_name ) : function_name_ ( make_func_name ( func_name ) ) { ACE_TRACE ( " ACE _ Function _ Node : : ACE _ Function _ Node " ) ; this -> pathname ( ACE :: strnew ( path ) ) ; this -> must_delete_ = 1 ; } ACE_TCHAR * ACE_Function_Node :: make_func_name ( ACE_TCHAR const * func_name ) { # if defined ( ACE_HAS_VERSIONED_NAMESPACE ) && ACE_HAS_VERSIONED_NAMESPACE == 1 # define ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING_IMPL ( NAME ) # NAME # define ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING ( NAME ) ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING_IMPL ( NAME ) # define ACE_VERSIONED_NAMESPACE_NAME_STRING ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING ( ACE_VERSIONED_NAMESPACE_NAME ) static ACE_TCHAR const make_prefix [ ] = ACE_TEXT ( " _ make _ " ) ; static size_t const make_prefix_len = sizeof ( make_prefix ) / sizeof ( make_prefix [ 0 ] ) - 1 ; if ( ACE_OS :: strncmp ( make_prefix , func_name , make_prefix_len ) == 0 ) { static ACE_TCHAR const versioned_namespace_name [ ] = ACE_TEXT ( ACE_VERSIONED_NAMESPACE_NAME_STRING ) ACE_TEXT ( " _ " ) ; static size_t const versioned_namespace_name_len = sizeof ( versioned_namespace_name ) / sizeof ( versioned_namespace_name [ 0 ] ) ; size_t const len = ACE_OS :: strlen ( func_name ) + versioned_namespace_name_len ; ACE_TCHAR * mangled_func_name ; ACE_NEW_RETURN ( mangled_func_name , ACE_TCHAR [ len ] , 0 ) ; ACE_Auto_Basic_Array_Ptr < ACE_TCHAR > safe ( mangled_func_name ) ; ACE_OS :: snprintf ( mangled_func_name , len , ACE_TEXT ( " % s % s % s " ) , make_prefix , versioned_namespace_name , func_name + make_prefix_len ) ; return safe . release ( ) ; } # endif return ACE :: strnew ( func_name ) ; } void * ACE_Function_Node :: symbol ( ACE_Service_Gestalt * , int & yyerrno , ACE_Service_Object_Exterminator * gobbler ) { typedef ACE_Service_Object * ( * ACE_Service_Factory_Ptr ) ( ACE_Service_Object_Exterminator * ) ; ACE_TRACE ( " ACE _ Function _ Node : : symbol " ) ; if ( this -> open_dll ( yyerrno ) == 0 ) { this -> symbol_ = 0 ; ACE_TCHAR * const function_name = const_cast < ACE_TCHAR * > ( this -> function_name_ ) ; void * const func_p = this -> dll_ . symbol ( function_name ) ; if ( func_p == 0 ) { ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) { ACE_TCHAR * const errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " DLL : : symbol ▁ failed ▁ for ▁ function ▁ % s : ▁ " ) ACE_TEXT ( " % s \n " ) , function_name , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } # endif return 0 ; } # if defined ( ACE_OPENVMS ) && ( ! defined ( __INITIAL_POINTER_SIZE ) || ( __INITIAL_POINTER_SIZE < 64 ) ) int const temp_p = reinterpret_cast < int > ( func_p ) ; # else intptr_t const temp_p = reinterpret_cast < intptr_t > ( func_p ) ; # endif ACE_Service_Factory_Ptr func = reinterpret_cast < ACE_Service_Factory_Ptr > ( temp_p ) ; this -> symbol_ = ( * func ) ( gobbler ) ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " % p \n " ) , this -> function_name_ ) ) ; } return 0 ; } } return this -> symbol_ ; } ACE_Function_Node :: ~ ACE_Function_Node ( void ) { ACE_TRACE ( " ACE _ Function _ Node : : ~ ACE _ Function _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( function_name_ ) ; delete [ ] const_cast < ACE_TCHAR * > ( pathname_ ) ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Dummy_Node ) void ACE_Dummy_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Dummy _ Node : : dump " ) ; # endif } ACE_Dummy_Node :: ACE_Dummy_Node ( const ACE_Static_Node * static_node , const ACE_Parse_Node * str_mods ) : ACE_Parse_Node ( static_node -> name ( ) ) , node_ ( static_node ) , mods_ ( str_mods ) { ACE_TRACE ( " ACE _ Dummy _ Node : : ACE _ Dummy _ Node " ) ; } void ACE_Dummy_Node :: apply ( ACE_Service_Gestalt * , int & yyerrno ) { ACE_TRACE ( " ACE _ Dummy _ Node : : apply " ) ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ operations ▁ on ▁ stream ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; # else ACE_UNUSED_ARG ( yyerrno ) ; # endif } ACE_Dummy_Node :: ~ ACE_Dummy_Node ( void ) { ACE_TRACE ( " ACE _ Dummy _ Node : : ~ ACE _ Dummy _ Node " ) ; ACE_Static_Node * n = const_cast < ACE_Static_Node * > ( this -> node_ ) ; delete n ; ACE_Parse_Node * m = const_cast < ACE_Parse_Node * > ( this -> mods_ ) ; delete m ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Static_Function_Node ) void ACE_Static_Function_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Static _ Function _ Node : : dump " ) ; # endif } ACE_Static_Function_Node :: ACE_Static_Function_Node ( const ACE_TCHAR * func_name ) : function_name_ ( ACE :: strnew ( func_name ) ) { ACE_TRACE ( " ACE _ Static _ Function _ Node : : ACE _ Static _ Function _ Node " ) ; this -> must_delete_ = 1 ; } void * ACE_Static_Function_Node :: symbol ( ACE_Service_Gestalt * config , int & yyerrno , ACE_Service_Object_Exterminator * gobbler ) { ACE_TRACE ( " ACE _ Static _ Function _ Node : : symbol " ) ; this -> symbol_ = 0 ; ACE_Static_Svc_Descriptor * ssd = 0 ; if ( config -> find_static_svc_descriptor ( this -> function_name_ , & ssd ) == - 1 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ( % P | % t ) ▁ No ▁ static ▁ service ▁ " ) ACE_TEXT ( " registered ▁ for ▁ function ▁ % s \n " ) , this -> function_name_ ) ) ; } return 0 ; } if ( ssd -> alloc_ == 0 ) { ++ yyerrno ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ( % P | % t ) ▁ No ▁ static ▁ service ▁ factory ▁ " ) ACE_TEXT ( " function ▁ registered ▁ for ▁ function ▁ % s \n " ) , this -> function_name_ ) ) ; } return 0 ; } } this -> symbol_ = ( * ssd -> alloc_ ) ( gobbler ) ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " % p \n " ) , this -> function_name_ ) ) ; } return 0 ; } return this -> symbol_ ; } ACE_Static_Function_Node :: ~ ACE_Static_Function_Node ( void ) { ACE_TRACE ( " ACE _ Static _ Function _ Node : : ~ ACE _ Static _ Function _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> function_name_ ) ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Service_Type_Factory ) ACE_Service_Type_Factory :: ACE_Service_Type_Factory ( ACE_TCHAR const * name , int type , ACE_Location_Node * location , int active ) : name_ ( name ) , type_ ( type ) , location_ ( location ) , is_active_ ( active ) { } ACE_Service_Type_Factory :: ~ ACE_Service_Type_Factory ( void ) { } ACE_Service_Type * ACE_Service_Type_Factory :: make_service_type ( ACE_Service_Gestalt * cfg ) const { ACE_TRACE ( " ACE _ Service _ Type _ Factory : : make _ service _ type " ) ; u_int const flags = ACE_Service_Type :: DELETE_THIS | ( this -> location_ -> dispose ( ) == 0 ? 0 : ACE_Service_Type :: DELETE_OBJ ) ; int yyerrno = 0 ; ACE_Service_Object_Exterminator gobbler = 0 ; void * sym = this -> location_ -> symbol ( cfg , yyerrno , & gobbler ) ; if ( sym != 0 ) { ACE_Service_Type_Impl * stp = ACE_Service_Config :: create_service_type_impl ( this -> name ( ) , this -> type_ , sym , flags , gobbler ) ; if ( stp == 0 ) ++ yyerrno ; ACE_Service_Type * tmp = 0 ; ACE_NEW_RETURN ( tmp , ACE_Service_Type ( this -> name ( ) , stp , this -> location_ -> dll ( ) , this -> is_active_ ) , 0 ) ; return tmp ; } # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Unable ▁ to ▁ create ▁ " ) ACE_TEXT ( " service ▁ object ▁ for ▁ % s \n " ) , this -> name ( ) ) ) ; } # endif ++ yyerrno ; return 0 ; } ACE_TCHAR const * ACE_Service_Type_Factory :: name ( void ) const { return name_ . c_str ( ) ; } ACE_END_VERSIONED_NAMESPACE_DECL # endif </DOCUMENT>
<DOCUMENT_ID="aybassiouny/wincaffe-cmake/tree/master/src/caffe/test/test_power_layer.cpp"> # include < algorithm > # include < vector > # include " cuda _ runtime . h " # include " gtest / gtest . h " # include " caffe / blob . hpp " # include " caffe / common . hpp " # include " caffe / filler . hpp " # include " caffe / vision _ layers . hpp " # include " caffe / test / test _ gradient _ check _ util . hpp " # include " caffe / test / test _ caffe _ main . hpp " using std :: isnan ; namespace caffe { extern cudaDeviceProp CAFFE_TEST_CUDA_PROP ; template < typename Dtype > class PowerLayerTest : public :: testing :: Test { protected : PowerLayerTest ( ) : blob_bottom_ ( new Blob < Dtype > ( 2 , 3 , 4 , 5 ) ) , blob_top_ ( new Blob < Dtype > ( ) ) { Caffe :: set_random_seed ( 1701 ) ; FillerParameter filler_param ; GaussianFiller < Dtype > filler ( filler_param ) ; filler . Fill ( this -> blob_bottom_ ) ; blob_bottom_vec_ . push_back ( blob_bottom_ ) ; blob_top_vec_ . push_back ( blob_top_ ) ; } virtual ~ PowerLayerTest ( ) { delete blob_bottom_ ; delete blob_top_ ; } void TestForward ( Dtype power , Dtype scale , Dtype shift ) { LayerParameter layer_param ; layer_param . mutable_power_param ( ) -> set_power ( power ) ; layer_param . mutable_power_param ( ) -> set_scale ( scale ) ; layer_param . mutable_power_param ( ) -> set_shift ( shift ) ; PowerLayer < Dtype > layer ( layer_param ) ; layer . SetUp ( this -> blob_bottom_vec_ , & ( this -> blob_top_vec_ ) ) ; layer . Forward ( this -> blob_bottom_vec_ , & ( this -> blob_top_vec_ ) ) ; const Dtype * bottom_data = this -> blob_bottom_ -> cpu_data ( ) ; const Dtype * top_data = this -> blob_top_ -> cpu_data ( ) ; const Dtype min_precision = 1e - 5 ; for ( int i = 0 ; i < this -> blob_bottom_ -> count ( ) ; ++ i ) { Dtype expected_value = pow ( shift + scale * bottom_data [ i ] , power ) ; if ( power == Dtype ( 0 ) || power == Dtype ( 1 ) || power == Dtype ( 2 ) ) { EXPECT_FALSE ( isnan ( top_data [ i ] ) ) ; } if ( isnan ( expected_value ) ) { EXPECT_TRUE ( isnan ( top_data [ i ] ) ) ; } else { Dtype precision = max ( Dtype ( abs ( expected_value * 0.0001 ) ) , min_precision ) ; EXPECT_NEAR ( expected_value , top_data [ i ] , precision ) ; } } } void TestBackward ( Dtype power , Dtype scale , Dtype shift ) { LayerParameter layer_param ; layer_param . mutable_power_param ( ) -> set_power ( power ) ; layer_param . mutable_power_param ( ) -> set_scale ( scale ) ; layer_param . mutable_power_param ( ) -> set_shift ( shift ) ; PowerLayer < Dtype > layer ( layer_param ) ; if ( power != Dtype ( 0 ) && power != Dtype ( 1 ) && power != Dtype ( 2 ) ) { Dtype * bottom_data = this -> blob_bottom_ -> mutable_cpu_data ( ) ; Dtype min_value = - shift / scale ; for ( int i = 0 ; i < this -> blob_bottom_ -> count ( ) ; ++ i ) { if ( bottom_data [ i ] < min_value ) { bottom_data [ i ] = min_value + ( min_value - bottom_data [ i ] ) ; } } } GradientChecker < Dtype > checker ( 1e - 2 , 1e - 2 , 1701 , 0. , 0.01 ) ; checker . CheckGradientEltwise ( & layer , & ( this -> blob_bottom_vec_ ) , & ( this -> blob_top_vec_ ) ) ; } Blob < Dtype > * const blob_bottom_ ; Blob < Dtype > * const blob_top_ ; vector < Blob < Dtype > * > blob_bottom_vec_ ; vector < Blob < Dtype > * > blob_top_vec_ ; } ; typedef :: testing :: Types < float , double > Dtypes ; TYPED_TEST_CASE ( PowerLayerTest , Dtypes ) ; TYPED_TEST ( PowerLayerTest , TestPowerCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGradientShiftZeroCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = 0.0 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerZeroCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerZeroGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerOneCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerOneGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.34 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoScaleHalfGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.5 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGradientShiftZeroGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = 0.0 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerZeroGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerZeroGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerOneGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerOneGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.34 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoScaleHalfGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.5 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } } </DOCUMENT>
<DOCUMENT_ID="geocool/libtmx-parser/tree/master/src/tmxparser.cpp"> # include " tmxparser . h " # include " base64 . h " # if ( defined ( _WIN32 ) ) # include < string . h > # endif # if ( ( defined ( ANDROID ) ) ) # include < android / log . h > # include < string . h > # else # include < cstdlib > # include < cstdio > # endif # include < algorithm > # include < string > # include < sstream > # ifndef LOG_TAG # define LOG_TAG " libtmxparser " # endif # if defined ( WIN32 ) || defined ( _WIN32 ) # define PATH_SEPARATOR " \\ " # define PATH_SEPARATOR_ALT " / " # else # define PATH_SEPARATOR " / " # define PATH_SEPARATOR_ALT " / " # endif # define QUOTEME_ ( x ) # x # define QUOTEME ( x ) QUOTEME_ ( x ) # define WHERESTR " [ file ▁ % s , ▁ line ▁ % d ] : ▁ " # define WHEREARG __FILE__ , __LINE__ # if ( ( defined ( ANDROID ) ) ) # ifdef DEBUG # define LOGD ( ... ) __android_log_print ( ANDROID_LOG_DEBUG , LOG_TAG , " ▁ ( " __FILE__ " : " QUOTEME ( __LINE__ ) " ) ▁ " __VA_ARGS__ ) # else # define LOGD ( ... ) # endif # define LOGI ( ... ) __android_log_print ( ANDROID_LOG_INFO , LOG_TAG , " " __VA_ARGS__ ) # define LOGE ( ... ) __android_log_print ( ANDROID_LOG_ERROR , LOG_TAG , __VA_ARGS__ ) # define LOGW ( ... ) __android_log_print ( ANDROID_LOG_WARN , LOG_TAG , __VA_ARGS__ ) # else # ifdef DEBUG # define LOGD ( ... ) fprintf ( stderr , " D / " LOG_TAG " ▁ ( " __FILE__ " : " QUOTEME ( __LINE__ ) " ) : ▁ " __VA_ARGS__ ) ; fprintf ( stderr , " \n " ) ; # else # define LOGD ( ... ) # endif # define LOGI ( ... ) fprintf ( stdout , " I / " QUOTEME ( LOG_TAG ) " ( " " ) " __VA_ARGS__ ) ; fprintf ( stdout , " \n " ) ; # define LOGE ( ... ) fprintf ( stderr , " E / " QUOTEME ( LOG_TAG ) " ( " " ) " __VA_ARGS__ ) ; fprintf ( stderr , " \n " ) ; # define LOGW ( ... ) fprintf ( stderr , " W / " QUOTEME ( LOG_TAG ) " ( " " ) " __VA_ARGS__ ) ; fprintf ( stderr , " \n " ) ; # endif namespace tmxparser { # define CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( XMLELEMENT , ATTRIBNAME , LHS ) if ( XMLELEMENT -> Attribute ( ATTRIBNAME ) != NULL ) { LHS = XMLELEMENT -> Attribute ( ATTRIBNAME ) ; } else { LHS = ' \0' ; } # define CHECK_AND_RETRIEVE_REQ_ATTRIBUTE_STRING ( XMLELEMENT , ATTRIBNAME , LHS ) LHS = XMLELEMENT -> Attribute ( ATTRIBNAME ) ; if ( LHS . size ( ) == 0 ) { LOGE ( " Missing ▁ required ▁ attribute ▁ [ % s ] " , ATTRIBNAME ) ; return TmxReturn :: kMissingRequiredAttribute ; } # define CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( FUNC , ATTRIBNAME , OUT ) if ( FUNC ( ATTRIBNAME , OUT ) == tinyxml2 :: XML_NO_ATTRIBUTE ) { LOGE ( " Missing ▁ required ▁ attribute ▁ [ % s ] " , ATTRIBNAME ) ; return kMissingRequiredAttribute ; } TmxReturn _parseStart ( tinyxml2 :: XMLElement * element , TmxMap * outMap , const std :: string & tilesetPath ) ; TmxReturn _parseEnd ( TmxMap * outMap , const std :: string & tilesetPath ) ; void _parseEndHelper ( TmxImage & image , const std :: string & tilesetPath ) ; TmxReturn _parseMapNode ( tinyxml2 :: XMLElement * element , TmxMap * outMap ) ; TmxReturn _parsePropertyNode ( tinyxml2 :: XMLElement * element , TmxPropertyMap_t * outPropertyMap ) ; TmxReturn _parseImageNode ( tinyxml2 :: XMLElement * element , TmxImage * outImage ) ; TmxReturn _parseTilesetNode ( tinyxml2 :: XMLElement * element , TmxTileset * outTileset ) ; TmxReturn _parseTileDefinitionNode ( tinyxml2 :: XMLElement * element , TmxTileDefinition * outTileDefinition ) ; TmxReturn _parseTileAnimationNode ( tinyxml2 :: XMLElement * element , TmxAnimationFrameCollection_t * outAnimationCollection ) ; TmxReturn _parseLayerNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayer * outLayer ) ; TmxReturn _parseLayerDataNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayerTileCollection_t * outTileCollection ) ; TmxReturn _parseLayerXmlTileNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayerTile * outTile ) ; TmxReturn _calculateTileIndices ( const TmxTilesetCollection_t & tilesets , TmxLayerTile * outTile ) ; TmxReturn _parseObjectGroupNode ( tinyxml2 :: XMLElement * element , TmxObjectGroup * outObjectGroup ) ; TmxReturn _parseObjectNode ( tinyxml2 :: XMLElement * element , TmxObject * outObj ) ; TmxReturn _parseOffsetNode ( tinyxml2 :: XMLElement * element , TmxOffset * offset ) ; TmxReturn _parseImageLayerNode ( tinyxml2 :: XMLElement * element , TmxImageLayer * outImageLayer ) ; TmxReturn parseFromFile ( const std :: string & fileName , TmxMap * outMap , const std :: string & tilesetPath ) { tinyxml2 :: XMLDocument doc ; if ( doc . LoadFile ( fileName . c_str ( ) ) != tinyxml2 :: XML_SUCCESS ) { LOGE ( " Cannot ▁ read ▁ xml ▁ file " ) ; return TmxReturn :: kErrorParsing ; } return _parseStart ( doc . FirstChildElement ( " map " ) , outMap , tilesetPath ) ; } TmxReturn parseFromMemory ( void * data , size_t length , TmxMap * outMap , const std :: string & tilesetPath ) { tinyxml2 :: XMLDocument doc ; if ( doc . Parse ( ( char * ) data , length ) ) { LOGE ( " Cannot ▁ parse ▁ xml ▁ memory ▁ file . . . " ) ; return TmxReturn :: kErrorParsing ; } return _parseStart ( doc . FirstChildElement ( " map " ) , outMap , tilesetPath ) ; } TmxReturn _parseStart ( tinyxml2 :: XMLElement * element , TmxMap * outMap , const std :: string & tilesetPath ) { TmxReturn retVal = _parseMapNode ( element , outMap ) ; return ( retVal == TmxReturn :: kSuccess ) ? _parseEnd ( outMap , tilesetPath ) : retVal ; } TmxReturn _parseEnd ( TmxMap * outMap , const std :: string & tilesetPath ) { for ( auto tileIt = outMap -> tilesetCollection . begin ( ) ; tileIt != outMap -> tilesetCollection . end ( ) ; ++ tileIt ) _parseEndHelper ( tileIt -> image , tilesetPath ) ; for ( auto tileIt = outMap -> imageLayerCollection . begin ( ) ; tileIt != outMap -> imageLayerCollection . end ( ) ; ++ tileIt ) _parseEndHelper ( tileIt -> image , tilesetPath ) ; return TmxReturn :: kSuccess ; } void _parseEndHelper ( TmxImage & image , const std :: string & tilesetPath ) { auto pathSeperatorMissing = ( image . source . find ( PATH_SEPARATOR ) == std :: string :: npos ) ; auto pathSeperatorAltMissing = ( image . source . find ( PATH_SEPARATOR_ALT ) == std :: string :: npos ) ; if ( pathSeperatorMissing && pathSeperatorAltMissing ) { std :: string baseFilename = image . source . substr ( image . source . find_last_of ( PATH_SEPARATOR ) + 1 ) ; auto seperatorThere = ( tilesetPath . find ( PATH_SEPARATOR ) != std :: string :: npos ) ; auto seperatorAltThere = ( tilesetPath . find ( PATH_SEPARATOR_ALT ) != std :: string :: npos ) ; auto tileSetPathSeparator = PATH_SEPARATOR ; if ( ! seperatorThere && seperatorAltThere ) tileSetPathSeparator = PATH_SEPARATOR_ALT ; image . source = tilesetPath + tileSetPathSeparator + baseFilename ; } } TmxReturn _parseMapNode ( tinyxml2 :: XMLElement * element , TmxMap * outMap ) { if ( element == NULL ) { return TmxReturn :: kMissingMapNode ; } outMap -> version = element -> Attribute ( " version " ) ; const char * orientation = element -> Attribute ( " orientation " ) ; if ( orientation != NULL ) { if ( strcmp ( orientation , " orthogonal " ) == 0 ) { outMap -> orientation = TmxOrientation :: kOrthogonal ; } else if ( strcmp ( orientation , " isometric " ) == 0 ) { outMap -> orientation = TmxOrientation :: kIsometric ; } else if ( strcmp ( orientation , " staggered " ) == 0 ) { outMap -> orientation = TmxOrientation :: kStaggered ; } } else { LOGW ( " Missing ▁ orientation ▁ attribute " ) ; } CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " width " , & outMap -> width ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " height " , & outMap -> height ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " tilewidth " , & outMap -> tileWidth ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " tileheight " , & outMap -> tileHeight ) ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " backgroundcolor " , outMap -> backgroundColor ) ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " renderorder " , outMap -> renderOrder ) ; TmxReturn error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outMap -> propertyMap ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ map ▁ properties . . . " ) ; return error ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " tileset " ) ; child != NULL ; child = child -> NextSiblingElement ( " tileset " ) ) { TmxTileset set ; error = _parseTilesetNode ( child , & set ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ tileset ▁ node . . . " ) ; return error ; } outMap -> tilesetCollection . push_back ( set ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " layer " ) ; child != NULL ; child = child -> NextSiblingElement ( " layer " ) ) { TmxLayer layer ; error = _parseLayerNode ( child , outMap -> tilesetCollection , & layer ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ layer ▁ node . . . " ) ; return error ; } outMap -> layerCollection . push_back ( layer ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " objectgroup " ) ; child != NULL ; child = child -> NextSiblingElement ( " objectgroup " ) ) { TmxObjectGroup group ; error = _parseObjectGroupNode ( child , & group ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ objectgroup ▁ node . . . " ) ; return error ; } outMap -> objectGroupCollection . push_back ( group ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " imagelayer " ) ; child != NULL ; child = child -> NextSiblingElement ( " imagelayer " ) ) { TmxImageLayer imageLayer ; error = _parseImageLayerNode ( child , & imageLayer ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ imagelayer ▁ node . . . " ) ; return error ; } outMap -> imageLayerCollection . push_back ( imageLayer ) ; } return error ; } TmxReturn _parsePropertyNode ( tinyxml2 :: XMLElement * element , TmxPropertyMap_t * outPropertyMap ) { if ( element == NULL ) { return TmxReturn :: kSuccess ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " property " ) ; child != NULL ; child = child -> NextSiblingElement ( " property " ) ) { if ( strcmp ( child -> Name ( ) , " property " ) == 0 ) { if ( child -> Attribute ( " name " ) != NULL && child -> Attribute ( " value " ) != NULL ) { ( * outPropertyMap ) [ child -> Attribute ( " name " ) ] = child -> Attribute ( " value " ) ; } else { return TmxReturn :: kMalformedPropertyNode ; } } } return TmxReturn :: kSuccess ; } TmxReturn _parseImageNode ( tinyxml2 :: XMLElement * element , TmxImage * outImage ) { CHECK_AND_RETRIEVE_REQ_ATTRIBUTE_STRING ( element , " source " , outImage -> source ) ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " format " , outImage -> format ) ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " trans " , outImage -> transparentColor ) ; outImage -> width = element -> UnsignedAttribute ( " width " ) ; outImage -> height = element -> UnsignedAttribute ( " height " ) ; return TmxReturn :: kSuccess ; } TmxReturn _parseTilesetNode ( tinyxml2 :: XMLElement * element , TmxTileset * outTileset ) { if ( strcmp ( element -> Name ( ) , " tileset " ) == 0 ) { CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " firstgid " , & outTileset -> firstgid ) ; outTileset -> name = element -> Attribute ( " name " ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " tilewidth " , & outTileset -> tileWidth ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " tileheight " , & outTileset -> tileHeight ) ; outTileset -> tileSpacingInImage = element -> UnsignedAttribute ( " spacing " ) ; outTileset -> tileMarginInImage = element -> UnsignedAttribute ( " margin " ) ; if ( element -> FirstChildElement ( " image " ) == NULL ) { LOGE ( " We ▁ do ▁ not ▁ support ▁ maps ▁ with ▁ tilesets ▁ that ▁ have ▁ no ▁ image ▁ associated ▁ currently . . . " ) ; return kErrorParsing ; } TmxImage image ; TmxReturn error = _parseImageNode ( element -> FirstChildElement ( " image " ) , & outTileset -> image ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ image ▁ node . . . " ) ; return error ; } outTileset -> offset . x = 0 ; outTileset -> offset . y = 0 ; if ( element -> FirstChildElement ( " tileoffset " ) != NULL ) { error = _parseOffsetNode ( element -> FirstChildElement ( " tileoffset " ) , & outTileset -> offset ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " tile " ) ; child != NULL ; child = child -> NextSiblingElement ( " tile " ) ) { TmxTileDefinition tileDef ; tileDef . id = 0 ; error = _parseTileDefinitionNode ( child , & tileDef ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ tile ▁ definition " ) ; return error ; } outTileset -> tileDefinitions [ tileDef . id ] = tileDef ; } outTileset -> colCount = ( outTileset -> image . width - outTileset -> tileMarginInImage ) / ( outTileset -> tileWidth + outTileset -> tileSpacingInImage ) ; outTileset -> rowCount = ( outTileset -> image . height - outTileset -> tileMarginInImage ) / ( outTileset -> tileHeight + outTileset -> tileSpacingInImage ) ; } return TmxReturn :: kSuccess ; } TmxReturn _parseTileDefinitionNode ( tinyxml2 :: XMLElement * element , TmxTileDefinition * outTileDefinition ) { TmxReturn error = TmxReturn :: kSuccess ; outTileDefinition -> id = element -> UnsignedAttribute ( " id " ) ; error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outTileDefinition -> propertyMap ) ; if ( error ) { return error ; } if ( element -> FirstChildElement ( " animation " ) != NULL ) { error = _parseTileAnimationNode ( element -> FirstChildElement ( " animation " ) , & outTileDefinition -> animations ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " objectgroup " ) ; child != NULL ; child = child -> NextSiblingElement ( " objectgroup " ) ) { TmxObjectGroup group ; error = _parseObjectGroupNode ( child , & group ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ objectgroup ▁ node . . . " ) ; return error ; } outTileDefinition -> objectgroups . push_back ( group ) ; } return error ; } TmxReturn _parseTileAnimationNode ( tinyxml2 :: XMLElement * element , TmxAnimationFrameCollection_t * outAnimationCollection ) { for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " frame " ) ; child != NULL ; child = child -> NextSiblingElement ( " frame " ) ) { TmxAnimationFrame frame ; frame . duration = child -> FloatAttribute ( " duration " ) ; frame . tileId = child -> UnsignedAttribute ( " tileid " ) ; outAnimationCollection -> push_back ( frame ) ; } return kSuccess ; } TmxReturn _parseLayerNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayer * outLayer ) { TmxReturn error = TmxReturn :: kSuccess ; outLayer -> name = element -> Attribute ( " name " ) ; if ( element -> Attribute ( " opacity " ) ) outLayer -> opacity = element -> FloatAttribute ( " opacity " ) ; else outLayer -> opacity = 1 . f ; if ( element -> Attribute ( " visible " ) ) outLayer -> visible = ( element -> IntAttribute ( " visible " ) == 1 ? true : false ) ; else outLayer -> visible = true ; outLayer -> width = element -> UnsignedAttribute ( " width " ) ; outLayer -> height = element -> UnsignedAttribute ( " height " ) ; error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outLayer -> propertyMap ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ layer ▁ property ▁ node . . . " ) ; return error ; } tinyxml2 :: XMLElement * dataElement = element -> FirstChildElement ( " data " ) ; if ( dataElement != NULL ) { error = _parseLayerDataNode ( dataElement , tilesets , & outLayer -> tiles ) ; } else { LOGE ( " Layer ▁ missing ▁ data ▁ node . . . " ) ; return TmxReturn :: kMissingDataNode ; } return error ; } TmxReturn _parseLayerDataNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayerTileCollection_t * outTileCollection ) { TmxReturn error = TmxReturn :: kSuccess ; const char * encoding = element -> Attribute ( " encoding " ) ; const char * compression = element -> Attribute ( " compression " ) ; if ( compression != NULL ) { LOGE ( " Does ▁ not ▁ support ▁ compression ▁ yet . . . " ) ; return TmxReturn :: kErrorParsing ; } if ( encoding == NULL ) { for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " tile " ) ; child != NULL ; child = child -> NextSiblingElement ( " tile " ) ) { TmxLayerTile tile ; error = _parseLayerXmlTileNode ( child , tilesets , & tile ) ; outTileCollection -> push_back ( tile ) ; } } else if ( strcmp ( encoding , " csv " ) == 0 ) { std :: stringstream csvss ( element -> FirstChild ( ) -> Value ( ) ) ; unsigned int gid = 0 ; while ( csvss >> gid ) { if ( csvss . peek ( ) == ' , ' || csvss . peek ( ) == ' \n ' ) { csvss . ignore ( ) ; } TmxLayerTile tile ; tile . gid = gid ; error = _calculateTileIndices ( tilesets , & tile ) ; if ( error == TmxReturn :: kErrorParsing ) { return error ; } outTileCollection -> push_back ( tile ) ; } } else if ( strcmp ( encoding , " base64" ) == 0 ) { std :: string csvbase64 = element -> FirstChild ( ) -> Value ( ) ; csvbase64 . erase ( std :: remove ( csvbase64 . begin ( ) , csvbase64 . end ( ) , ' \n ' ) , csvbase64 . end ( ) ) ; csvbase64 . erase ( std :: remove ( csvbase64 . begin ( ) , csvbase64 . end ( ) , '' ) , csvbase64 . end ( ) ) ; csvbase64 . erase ( std :: remove ( csvbase64 . begin ( ) , csvbase64 . end ( ) , ' ▁ ' ) , csvbase64 . end ( ) ) ; std :: string csv = base64_decode ( csvbase64 ) ; unsigned int length = csv . size ( ) / sizeof ( unsigned int ) ; unsigned int * p = ( unsigned int * ) csv . c_str ( ) ; for ( unsigned int i = 0 ; i < length ; i ++ ) { TmxLayerTile tile ; tile . gid = p [ i ] ; error = _calculateTileIndices ( tilesets , & tile ) ; if ( error == TmxReturn :: kErrorParsing ) { return error ; } outTileCollection -> push_back ( tile ) ; } } else { LOGE ( " Unsupported ▁ layer ▁ compression ▁ [ % s ] . . . ▁ coming ▁ soon . . . " , encoding ) ; return TmxReturn :: kErrorParsing ; } return error ; } TmxReturn _parseLayerXmlTileNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayerTile * outTile ) { TmxReturn error = TmxReturn :: kSuccess ; unsigned int gid = element -> UnsignedAttribute ( " gid " ) ; unsigned int flipXFlag = 0x80000000 ; unsigned int flipYFlag = 0x40000000 ; unsigned int flipDiagonalFlag = 0x20000000 ; outTile -> flipX = ( gid & flipXFlag ? true : false ) ; outTile -> flipY = ( gid & flipYFlag ? true : false ) ; outTile -> flipDiagonal = ( gid & flipDiagonalFlag ? true : false ) ; outTile -> gid = ( gid & ~ ( flipXFlag | flipYFlag | flipDiagonalFlag ) ) ; return _calculateTileIndices ( tilesets , outTile ) ; } TmxReturn _calculateTileIndices ( const TmxTilesetCollection_t & tilesets , TmxLayerTile * outTile ) { outTile -> tilesetIndex = 0 ; outTile -> tileFlatIndex = 0 ; if ( outTile -> gid == 0 ) { return TmxReturn :: kSuccess ; } unsigned int index = 0 ; unsigned int lastEndIndex = 1 ; for ( auto it = tilesets . begin ( ) ; it != tilesets . end ( ) ; ++ it ) { unsigned int colCount = it -> colCount ; unsigned int rowCount = it -> rowCount ; unsigned int startIndex = it -> firstgid ; unsigned int endIndex = it -> firstgid + ( colCount * rowCount ) ; if ( outTile -> gid >= startIndex && outTile -> gid < endIndex ) { outTile -> tilesetIndex = index ; outTile -> tileFlatIndex = ( outTile -> gid ) - lastEndIndex ; return TmxReturn :: kSuccess ; } lastEndIndex = endIndex ; index ++ ; } return TmxReturn :: kUnknownTileIndices ; } TmxReturn _parseObjectGroupNode ( tinyxml2 :: XMLElement * element , TmxObjectGroup * outObjectGroup ) { TmxReturn error = TmxReturn :: kSuccess ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " name " , outObjectGroup -> name ) ; if ( element -> Attribute ( " opacity " ) != NULL ) { outObjectGroup -> opacity = element -> FloatAttribute ( " opacity " ) ; } else { outObjectGroup -> opacity = 1.0f ; } if ( element -> Attribute ( " visible " ) != NULL ) { outObjectGroup -> visible = element -> BoolAttribute ( " visible " ) ; } else { outObjectGroup -> visible = true ; } error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outObjectGroup -> propertyMap ) ; if ( error ) { return error ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " object " ) ; child != NULL ; child = child -> NextSiblingElement ( " object " ) ) { TmxObject obj ; error = _parseObjectNode ( child , & obj ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ object ▁ node . . . " ) ; return TmxReturn :: kErrorParsing ; } outObjectGroup -> objects . push_back ( obj ) ; } return error ; } TmxReturn _parseObjectNode ( tinyxml2 :: XMLElement * element , TmxObject * outObj ) { TmxReturn error = TmxReturn :: kSuccess ; if ( element -> Attribute ( " name " ) ) { outObj -> name = element -> Attribute ( " name " ) ; } if ( element -> Attribute ( " type " ) ) { outObj -> type = element -> Attribute ( " type " ) ; } outObj -> x = element -> FloatAttribute ( " x " ) ; outObj -> y = element -> FloatAttribute ( " y " ) ; outObj -> width = element -> FloatAttribute ( " width " ) ; outObj -> height = element -> FloatAttribute ( " height " ) ; outObj -> rotation = element -> FloatAttribute ( " rotation " ) ; outObj -> referenceGid = element -> UnsignedAttribute ( " gid " ) ; outObj -> visible = element -> BoolAttribute ( " visible " ) ; error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outObj -> propertyMap ) ; if ( error ) { return error ; } tinyxml2 :: XMLElement * shapeElement = NULL ; if ( ( shapeElement = element -> FirstChildElement ( " ellipse " ) ) != NULL ) { outObj -> shapeType = kEllipse ; } else if ( ( shapeElement = element -> FirstChildElement ( " polygon " ) ) != NULL ) { outObj -> shapeType = kPolygon ; } else if ( ( shapeElement = element -> FirstChildElement ( " polyline " ) ) != NULL ) { outObj -> shapeType = kPolyline ; } else { outObj -> shapeType = kSquare ; } if ( ( outObj -> shapeType == kPolygon || outObj -> shapeType == kPolyline ) && shapeElement != NULL ) { if ( shapeElement -> Attribute ( " points " ) == NULL ) { LOGE ( " Missing ▁ points ▁ attribute ▁ for ▁ shape ▁ requiring ▁ one . . . " ) ; return TmxReturn :: kErrorParsing ; } std :: string pointString = shapeElement -> Attribute ( " points " ) ; std :: istringstream pairStringStream ( pointString ) ; std :: string pairToken ; while ( std :: getline ( pairStringStream , pairToken , ' ▁ ' ) ) { TmxShapePoint pair ; std :: istringstream pointStringString ( pairToken ) ; std :: string pointToken ; std :: getline ( pointStringString , pointToken , ' , ' ) ; pair . first = ( float ) atof ( pointToken . c_str ( ) ) ; std :: getline ( pointStringString , pointToken , ' , ' ) ; pair . second = ( float ) atof ( pointToken . c_str ( ) ) ; outObj -> shapePoints . push_back ( pair ) ; } } return error ; } TmxReturn calculateTileCoordinatesUV ( const TmxTileset & tileset , unsigned int tileFlatIndex , float pixelCorrection , bool flipY , TmxRect & outRect ) { if ( tileFlatIndex >= tileset . colCount * tileset . rowCount ) { return TmxReturn :: kInvalidTileIndex ; } TileId_t xIndex = tileFlatIndex % tileset . colCount ; TileId_t yIndex = tileFlatIndex / tileset . colCount ; unsigned int widthDelta = tileset . tileSpacingInImage + tileset . tileMarginInImage * xIndex ; unsigned int heightDelta = tileset . tileSpacingInImage + tileset . tileMarginInImage * yIndex ; float u = ( float ) ( ( xIndex * tileset . tileWidth ) + widthDelta + pixelCorrection ) / ( float ) tileset . image . width ; float v = ( float ) ( ( yIndex * tileset . tileHeight ) + heightDelta + pixelCorrection ) / ( float ) tileset . image . height ; float u2 = ( float ) ( ( ( ( xIndex + 1 ) * tileset . tileWidth ) + widthDelta ) - pixelCorrection ) / ( float ) tileset . image . width ; float v2 = ( float ) ( ( ( ( yIndex + 1 ) * tileset . tileHeight ) + heightDelta ) - pixelCorrection ) / ( float ) tileset . image . height ; if ( flipY ) { float tmpV = v ; v = 1 . f - v2 ; v2 = 1 . f - tmpV ; } outRect . u = u ; outRect . v = v ; outRect . u2 = u2 ; outRect . v2 = v2 ; return kSuccess ; } tmxparser :: TmxReturn _parseOffsetNode ( tinyxml2 :: XMLElement * element , TmxOffset * offset ) { TmxReturn error = TmxReturn :: kSuccess ; offset -> x = 0 ; offset -> y = 0 ; if ( element -> Attribute ( " x " ) ) { offset -> x = element -> IntAttribute ( " x " ) ; } if ( element -> Attribute ( " y " ) ) { offset -> y = element -> IntAttribute ( " y " ) ; } return error ; } tmxparser :: TmxReturn _parseImageLayerNode ( tinyxml2 :: XMLElement * element , TmxImageLayer * outImageLayer ) { TmxReturn error = TmxReturn :: kSuccess ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE_STRING ( element , " name " , outImageLayer -> name ) ; if ( element -> QueryUnsignedAttribute ( " x " , & outImageLayer -> x ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> x = 0U ; if ( element -> QueryUnsignedAttribute ( " y " , & outImageLayer -> y ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> y = 0U ; if ( element -> QueryUnsignedAttribute ( " width " , & outImageLayer -> widthInTiles ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> widthInTiles = 0U ; if ( element -> QueryUnsignedAttribute ( " height " , & outImageLayer -> heightInTiles ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> heightInTiles = 0U ; if ( element -> QueryFloatAttribute ( " opacity " , & outImageLayer -> opacity ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> opacity = 1 . f ; if ( element -> QueryBoolAttribute ( " visible " , & outImageLayer -> visible ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> visible = true ; if ( element -> FirstChildElement ( " properties " ) != NULL ) { error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outImageLayer -> propertyMap ) ; if ( error != kSuccess ) { LOGE ( " Error ▁ parsing ▁ image ▁ layer ▁ property ▁ node . . . " ) ; return error ; } } if ( element -> FirstChildElement ( " image " ) != NULL ) { error = _parseImageNode ( element -> FirstChildElement ( " image " ) , & outImageLayer -> image ) ; if ( error != kSuccess ) return error ; } return error ; } } </DOCUMENT>
<DOCUMENT_ID="fahhem/mbed-os/tree/master/targets/TARGET_NUVOTON/TARGET_M451/device/TOOLCHAIN_ARM_STD/sys.cpp"> # ifdef __cplusplus extern " C " { # endif # include < rt_misc . h > # include < stdint . h > extern char Image$$ARM_LIB_STACK$$ZI$$Limit [ ] ; extern char Image$$ARM_LIB_HEAP$$Base [ ] ; extern char Image$$ARM_LIB_HEAP$$ZI$$Limit [ ] ; extern __value_in_regs struct __initial_stackheap __user_setup_stackheap ( uint32_t R0 , uint32_t R1 , uint32_t R2 , uint32_t R3 ) { struct __initial_stackheap r ; r . heap_base = ( uint32_t ) Image$$ARM_LIB_HEAP$$Base ; r . heap_limit = ( uint32_t ) Image$$ARM_LIB_HEAP$$ZI$$Limit ; return r ; } # ifdef __cplusplus } # endif </DOCUMENT>
<DOCUMENT_ID="m039/Void/tree/master/third-party/void-boost/libs/config/test/has_part_alloc_fail.cpp"> # ifdef BOOST_ASSERT_CONFIG # undef BOOST_ASSERT_CONFIG # endif # include < boost / config . hpp > # include " test . hpp " # ifndef BOOST_HAS_PARTIAL_STD_ALLOCATOR # include " boost _ has _ part _ alloc . ipp " # else # error " this ▁ file ▁ should ▁ not ▁ compile " # endif int main ( int , char * [ ] ) { return boost_has_partial_std_allocator :: test ( ) ; } </DOCUMENT>
<DOCUMENT_ID="lassoan/CTK/tree/master/Libs/Core/ctkWorkflowStep.cpp"> # include < QDebug > # include < QMetaType > # include < QObject > # include < QState > # include " ctkWorkflowStep . h " # include " ctkWorkflowStep _ p . h " # include " ctkWorkflow . h " # include " ctkLogger . h " # include < iostream > static ctkLogger logger ( " org . commontk . core . ctkWorkflowStep " ) ; ctkWorkflowStepPrivate :: ctkWorkflowStepPrivate ( ctkWorkflowStep & object ) : q_ptr ( & object ) { qRegisterMetaType < ctkWorkflowStep * > ( " ctkWorkflowStep * " ) ; this -> Workflow = 0 ; this -> WidgetType = false ; this -> HasValidateCommand = false ; this -> HasOnEntryCommand = false ; this -> HasOnExitCommand = false ; this -> ProcessingState = new QState ( ) ; this -> ValidationState = new QState ( ) ; this -> ValidationTransition = new ctkWorkflowIntrastepTransition ( ctkWorkflowIntrastepTransition :: ValidationTransition ) ; this -> ValidationTransition -> setTargetState ( this -> ValidationState ) ; this -> ProcessingState -> addTransition ( this -> ValidationTransition ) ; this -> ValidationFailedTransition = 0 ; this -> ValidationFailedTransition = new ctkWorkflowIntrastepTransition ( ctkWorkflowIntrastepTransition :: ValidationFailedTransition ) ; this -> ValidationFailedTransition -> setTargetState ( this -> ProcessingState ) ; this -> ValidationState -> addTransition ( this -> ValidationFailedTransition ) ; } ctkWorkflowStepPrivate :: ~ ctkWorkflowStepPrivate ( ) { if ( ! this -> ValidationState . isNull ( ) ) { delete this -> ValidationState ; } if ( ! this -> ProcessingState . isNull ( ) ) { delete this -> ProcessingState ; } } void ctkWorkflowStepPrivate :: validationCompleteInternal ( bool validationResults , const QString & branchId ) const { emit validationComplete ( validationResults , branchId ) ; } void ctkWorkflowStepPrivate :: onEntryCompleteInternal ( ) const { emit onEntryComplete ( ) ; } void ctkWorkflowStepPrivate :: onExitCompleteInternal ( ) const { emit onExitComplete ( ) ; } void ctkWorkflowStepPrivate :: invokeValidateCommandInternal ( const QString & desiredBranchId ) const { emit invokeValidateCommand ( desiredBranchId ) ; } void ctkWorkflowStepPrivate :: invokeOnEntryCommandInternal ( const ctkWorkflowStep * comingFrom , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) const { emit invokeOnEntryCommand ( comingFrom , transitionType ) ; } void ctkWorkflowStepPrivate :: invokeOnExitCommandInternal ( const ctkWorkflowStep * goingTo , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) const { emit invokeOnExitCommand ( goingTo , transitionType ) ; } ctkWorkflowStep :: ctkWorkflowStep ( ) : d_ptr ( new ctkWorkflowStepPrivate ( * this ) ) { } ctkWorkflowStep :: ctkWorkflowStep ( const QString & newId ) : d_ptr ( new ctkWorkflowStepPrivate ( * this ) ) { Q_D ( ctkWorkflowStep ) ; d -> Id = newId ; } ctkWorkflowStep :: ctkWorkflowStep ( ctkWorkflowStepPrivate * pimpl , const QString & newId ) : d_ptr ( pimpl ) { Q_D ( ctkWorkflowStep ) ; d -> Id = newId ; } ctkWorkflowStep :: ~ ctkWorkflowStep ( ) { } CTK_GET_CPP ( ctkWorkflowStep , ctkWorkflow * , workflow , Workflow ) ; CTK_SET_CPP ( ctkWorkflowStep , ctkWorkflow * , setWorkflow , Workflow ) ; CTK_GET_CPP ( ctkWorkflowStep , QString , id , Id ) ; void ctkWorkflowStep :: setId ( const QString & newId ) { Q_D ( ctkWorkflowStep ) ; if ( d -> Workflow && d -> Workflow -> hasStep ( newId ) && ! this -> id ( ) . isEmpty ( ) ) { logger . error ( QString ( " ctkWorkflowStep ▁ - ▁ Failed ▁ to ▁ change ▁ id ▁ from ▁ ' %1 ' ▁ to ▁ ' %2 ' ▁ - ▁ " " Step ▁ already ▁ added ▁ to ▁ a ▁ workflow ▁ ! " ) . arg ( this -> id ( ) ) . arg ( newId ) ) ; return ; } d -> Id = newId ; } CTK_GET_CPP ( ctkWorkflowStep , QString , name , Name ) ; CTK_SET_CPP ( ctkWorkflowStep , const QString & , setName , Name ) ; CTK_GET_CPP ( ctkWorkflowStep , QString , description , Description ) ; CTK_SET_CPP ( ctkWorkflowStep , const QString & , setDescription , Description ) ; CTK_GET_CPP ( ctkWorkflowStep , QString , statusText , StatusText ) ; CTK_SET_CPP ( ctkWorkflowStep , const QString & , setStatusText , StatusText ) ; CTK_GET_CPP ( ctkWorkflowStep , bool , hasValidateCommand , HasValidateCommand ) ; CTK_SET_CPP ( ctkWorkflowStep , bool , setHasValidateCommand , HasValidateCommand ) ; CTK_GET_CPP ( ctkWorkflowStep , bool , hasOnEntryCommand , HasOnEntryCommand ) ; CTK_SET_CPP ( ctkWorkflowStep , bool , setHasOnEntryCommand , HasOnEntryCommand ) ; CTK_GET_CPP ( ctkWorkflowStep , bool , hasOnExitCommand , HasOnExitCommand ) ; CTK_SET_CPP ( ctkWorkflowStep , bool , setHasOnExitCommand , HasOnExitCommand ) ; CTK_GET_CPP ( ctkWorkflowStep , QState * , processingState , ProcessingState ) ; CTK_GET_CPP ( ctkWorkflowStep , QState * , validationState , ValidationState ) ; CTK_GET_CPP ( ctkWorkflowStep , ctkWorkflowIntrastepTransition * , validationTransition , ValidationTransition ) ; CTK_GET_CPP ( ctkWorkflowStep , ctkWorkflowIntrastepTransition * , validationFailedTransition , ValidationFailedTransition ) ; CTK_GET_CPP ( ctkWorkflowStep , bool , isWidgetType , WidgetType ) ; QObject * ctkWorkflowStep :: ctkWorkflowStepQObject ( ) { Q_D ( ctkWorkflowStep ) ; return d ; } void ctkWorkflowStep :: validationComplete ( bool validationResults , const QString & branchId ) const { Q_D ( const ctkWorkflowStep ) ; d -> validationCompleteInternal ( validationResults , branchId ) ; } void ctkWorkflowStep :: onEntryComplete ( ) const { Q_D ( const ctkWorkflowStep ) ; d -> onEntryCompleteInternal ( ) ; } void ctkWorkflowStep :: onExitComplete ( ) const { Q_D ( const ctkWorkflowStep ) ; d -> onExitCompleteInternal ( ) ; } void ctkWorkflowStep :: invokeValidateCommand ( const QString & desiredBranchId ) const { Q_D ( const ctkWorkflowStep ) ; d -> invokeValidateCommandInternal ( desiredBranchId ) ; } void ctkWorkflowStep :: invokeOnEntryCommand ( const ctkWorkflowStep * comingFrom , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) const { Q_D ( const ctkWorkflowStep ) ; d -> invokeOnEntryCommandInternal ( comingFrom , transitionType ) ; } void ctkWorkflowStep :: invokeOnExitCommand ( const ctkWorkflowStep * goingTo , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) const { Q_D ( const ctkWorkflowStep ) ; d -> invokeOnExitCommandInternal ( goingTo , transitionType ) ; } void ctkWorkflowStep :: validate ( const QString & desiredBranchId ) { Q_D ( ctkWorkflowStep ) ; logger . info ( QString ( " validate ▁ - ▁ validating ▁ the ▁ input ▁ from ▁ % 1" ) . arg ( d -> Name ) ) ; this -> validationComplete ( true , desiredBranchId ) ; } void ctkWorkflowStep :: onEntry ( const ctkWorkflowStep * comingFrom , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) { Q_UNUSED ( comingFrom ) ; Q_UNUSED ( transitionType ) ; this -> onEntryComplete ( ) ; } void ctkWorkflowStep :: onExit ( const ctkWorkflowStep * goingTo , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) { Q_UNUSED ( goingTo ) ; Q_UNUSED ( transitionType ) ; this -> onExitComplete ( ) ; } </DOCUMENT>
<DOCUMENT_ID="chirilo/phantomjs/tree/master/src/qt/qtbase/src/gui/doc/snippets/code/src_gui_painting_qpainter.cpp"> void SimpleExampleWidget :: paintEvent ( QPaintEvent * ) { QPainter painter ( this ) ; painter . setPen ( Qt :: blue ) ; painter . setFont ( QFont ( " Arial " , 30 ) ) ; painter . drawText ( rect ( ) , Qt :: AlignCenter , " Qt " ) ; } void MyWidget :: paintEvent ( QPaintEvent * ) { QPainter p ; p . begin ( this ) ; p . drawLine ( ... ) ; p . end ( ) ; } void MyWidget :: paintEvent ( QPaintEvent * ) { QPainter p ( this ) ; p . drawLine ( ... ) ; } painter -> begin ( 0 ) ; QPixmap image ( 0 , 0 ) ; painter -> begin ( & image ) ; painter -> begin ( myWidget ) ; painter2 -> begin ( myWidget ) ; void QPainter :: rotate ( qreal angle ) { QMatrix matrix ; matrix . rotate ( angle ) ; setWorldMatrix ( matrix , true ) ; } QPainterPath path ; path . moveTo ( 20 , 80 ) ; path . lineTo ( 20 , 30 ) ; path . cubicTo ( 80 , 0 , 50 , 50 , 80 , 80 ) ; QPainter painter ( this ) ; painter . drawPath ( path ) ; QLineF line ( 10.0 , 80.0 , 90.0 , 20.0 ) ; QPainter ( this ) ; painter . drawLine ( line ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QPainter painter ( this ) ; painter . drawRect ( rectangle ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QPainter painter ( this ) ; painter . drawRoundedRect ( rectangle , 20.0 , 15.0 ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QPainter painter ( this ) ; painter . drawEllipse ( rectangle ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; int startAngle = 30 * 16 ; int spanAngle = 120 * 16 ; QPainter painter ( this ) ; painter . drawArc ( rectangle , startAngle , spanAngle ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; int startAngle = 30 * 16 ; int spanAngle = 120 * 16 ; QPainter painter ( this ) ; painter . drawPie ( rectangle , startAngle , spanAngle ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; int startAngle = 30 * 16 ; int spanAngle = 120 * 16 ; QPainter painter ( this ) ; painter . drawChord ( rect , startAngle , spanAngle ) ; static const QPointF points [ 3 ] = { QPointF ( 10.0 , 80.0 ) , QPointF ( 20.0 , 10.0 ) , QPointF ( 80.0 , 30.0 ) , } ; QPainter painter ( this ) ; painter . drawPolyline ( points , 3 ) ; static const QPointF points [ 4 ] = { QPointF ( 10.0 , 80.0 ) , QPointF ( 20.0 , 10.0 ) , QPointF ( 80.0 , 30.0 ) , QPointF ( 90.0 , 70.0 ) } ; QPainter painter ( this ) ; painter . drawPolygon ( points , 4 ) ; static const QPointF points [ 4 ] = { QPointF ( 10.0 , 80.0 ) , QPointF ( 20.0 , 10.0 ) , QPointF ( 80.0 , 30.0 ) , QPointF ( 90.0 , 70.0 ) } ; QPainter painter ( this ) ; painter . drawConvexPolygon ( points , 4 ) ; QRectF target ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QRectF source ( 0.0 , 0.0 , 70.0 , 40.0 ) ; QPixmap pixmap ( " : myPixmap . png " ) ; QPainter ( this ) ; painter . drawPixmap ( target , pixmap , source ) ; QPainter painter ( this ) ; painter . drawText ( rect , Qt :: AlignCenter , tr ( " Qt \n Project " ) ) ; QPicture picture ; QPointF point ( 10.0 , 20.0 ) picture . load ( " drawing . pic " ) ; QPainter painter ( this ) ; painter . drawPicture ( 0 , 0 , picture ) ; fillRect ( rectangle , background ( ) ) . QRectF target ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QRectF source ( 0.0 , 0.0 , 70.0 , 40.0 ) ; QImage image ( " : / images / myImage . png " ) ; QPainter painter ( this ) ; painter . drawImage ( target , image , source ) ; QPainter painter ( this ) ; painter . fillRect ( 0 , 0 , 128 , 128 , Qt :: green ) ; painter . beginNativePainting ( ) ; glEnable ( GL_SCISSOR_TEST ) ; glScissor ( 0 , 0 , 64 , 64 ) ; glClearColor ( 1 , 0 , 0 , 1 ) ; glClear ( GL_COLOR_BUFFER_BIT ) ; glDisable ( GL_SCISSOR_TEST ) ; painter . endNativePainting ( ) ; </DOCUMENT>
<DOCUMENT_ID="kyoungchinseo/aws-sdk-cpp/tree/master/aws-cpp-sdk-s3/source/model/Delete.cpp"> # include < aws / s3 / model / Delete . h > # include < aws / core / utils / xml / XmlSerializer . h > # include < aws / core / utils / StringUtils . h > # include < aws / core / utils / memory / stl / AWSStringStream . h > # include < utility > using namespace Aws :: S3 :: Model ; using namespace Aws :: Utils :: Xml ; using namespace Aws :: Utils ; Delete :: Delete ( ) : m_objectsHasBeenSet ( false ) , m_quiet ( false ) , m_quietHasBeenSet ( false ) { } Delete :: Delete ( const XmlNode & xmlNode ) : m_objectsHasBeenSet ( false ) , m_quiet ( false ) , m_quietHasBeenSet ( false ) { * this = xmlNode ; } Delete & Delete :: operator = ( const XmlNode & xmlNode ) { XmlNode resultNode = xmlNode ; if ( ! resultNode . IsNull ( ) ) { XmlNode objectsNode = resultNode . FirstChild ( " Objects " ) ; if ( ! objectsNode . IsNull ( ) ) { XmlNode objectsMember = objectsNode ; while ( ! objectsMember . IsNull ( ) ) { m_objects . push_back ( objectsMember ) ; objectsMember = objectsMember . NextNode ( " Object " ) ; } m_objectsHasBeenSet = true ; } XmlNode quietNode = resultNode . FirstChild ( " Quiet " ) ; if ( quietNode . IsNull ( ) ) { quietNode = resultNode ; } if ( ! quietNode . IsNull ( ) ) { m_quiet = StringUtils :: ConvertToBool ( StringUtils :: Trim ( quietNode . GetText ( ) . c_str ( ) ) . c_str ( ) ) ; m_quietHasBeenSet = true ; } } return * this ; } void Delete :: AddToNode ( XmlNode & parentNode ) const { Aws :: StringStream ss ; if ( m_objectsHasBeenSet ) { for ( const auto & item : m_objects ) { XmlNode objectsNode = parentNode . CreateChildElement ( " Object " ) ; item . AddToNode ( objectsNode ) ; } } if ( m_quietHasBeenSet ) { XmlNode quietNode = parentNode . CreateChildElement ( " Object " ) ; ss << m_quiet ; quietNode . SetText ( ss . str ( ) ) ; ss . str ( " " ) ; } } </DOCUMENT>
<DOCUMENT_ID="keichan100yen/ode-ext/tree/master/boost/libs/config/test/no_std_allocator_fail.cpp"> # ifdef BOOST_ASSERT_CONFIG # undef BOOST_ASSERT_CONFIG # endif # include < boost / config . hpp > # include " test . hpp " # ifdef BOOST_NO_STD_ALLOCATOR # include " boost _ no _ std _ allocator . ipp " # else # error " this ▁ file ▁ should ▁ not ▁ compile " # endif int main ( int , char * [ ] ) { return boost_no_std_allocator :: test ( ) ; } </DOCUMENT>
<DOCUMENT_ID="fedech/ldpc_sim/tree/master/src/Simulation.cpp"> # include < iostream > # include < fstream > # include < string > # include < boost / numeric / ublas / matrix . hpp > # include < boost / random . hpp > # include < boost / random / normal_distribution . hpp > # include " LDPCEncoder . h " # include " LDPCDecoder . h " int main ( ) { int n = 648 ; int k = 432 ; int p = n - k ; std :: string file = " n648r23" ; int passes = 50 ; bool qam = true ; int symbols = 4 ; double step = 0.25 ; int minsnr = 0 ; double maxsnr = 4.1 ; int maxPackets = 1E6 ; int minErrors = 100 ; int printInterval = maxPackets / 1000 ; std :: string matrixFolder = " . / matrices / " ; std :: string extIn = " . csv " ; std :: string resultsFolder = " . / results / " ; std :: string extOut = " . dat " ; std :: string encoding = matrixFolder + " enc " + file + extIn ; std :: string decoding = matrixFolder + " dec " + file + extIn ; std :: stringstream ss ; if ( qam ) { ss << " qam " << symbols ; } ss << " _ " << passes ; std :: string output = resultsFolder + file + ss . str ( ) + extOut ; std :: ifstream enc ; enc . open ( encoding . c_str ( ) ) ; std :: ifstream dec ; dec . open ( decoding . c_str ( ) ) ; std :: ofstream out ; out . open ( output . c_str ( ) ) ; out << " # LDPC , ▁ n ▁ = ▁ " << n << " , ▁ k ▁ = ▁ " << k << " \n " ; out << " # SNR ▁ ( dB ) ▁ - ▁ BER ▁ - ▁ PER \n " ; std :: vector < double > snrdb ; std :: vector < int > errors ; std :: vector < int > pktErrors ; std :: vector < int > packets ; boost :: numeric :: ublas :: matrix < int > parityMatrix ( p , n ) ; boost :: numeric :: ublas :: matrix < int > encodingMatrix ( n , k ) ; for ( int i = 0 ; i < p ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dec >> parityMatrix ( i , j ) ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < k ; j ++ ) { enc >> encodingMatrix ( i , j ) ; } } for ( double snr = minsnr ; snr < maxsnr ; snr += step ) { snrdb . push_back ( snr ) ; errors . push_back ( 0 ) ; pktErrors . push_back ( 0 ) ; packets . push_back ( 0 ) ; } boost :: mt19937 rng = boost :: mt19937 ( time ( 0 ) ) ; boost :: variate_generator < boost :: mt19937 & , boost :: normal_distribution < > > generator ( rng , boost :: normal_distribution < > ( ) ) ; LDPCEncoder * encoder = new LDPCEncoder ( k , n , encodingMatrix , symbols ) ; LDPCDecoder * decoder = new LDPCDecoder ( k , n , parityMatrix , passes , symbols ) ; std :: cout << std :: time ( NULL ) << " Created ! \n " ; boost :: numeric :: ublas :: matrix < double > results ( snrdb . size ( ) , 26 ) ; for ( int i = 0 ; i < snrdb . size ( ) ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { results ( i , j ) = 0 ; } } for ( int packet = 0 ; packet < maxPackets ; packet ++ ) { if ( packet % printInterval == 0 ) { std :: cout << packet << " ▁ " << std :: time ( NULL ) << " \n " ; } std :: vector < int > uncoded ; std :: vector < double > w ; std :: vector < double > w_q ; for ( int i = 0 ; i < n ; i ++ ) { w . push_back ( generator ( ) ) ; if ( qam ) { w_q . push_back ( generator ( ) ) ; } } for ( int i = 0 ; i < k ; i ++ ) { uncoded . push_back ( rand ( ) % 2 ) ; } std :: vector < int > coded = encoder -> encode ( uncoded ) ; int counter = 0 ; for ( double snr = minsnr ; snr < maxsnr ; snr += step ) { if ( packets . at ( counter ) == 0 ) { double n0 = 1 / pow ( 10 , snr / 10 ) / log2 ( symbols ) / 2 ; std :: vector < double > received ; std :: vector < LDPCEncoder :: symbol > modulated ; if ( ! qam ) { for ( int i = 0 ; i < n ; i ++ ) { double rec = 2 * coded . at ( i ) - 1 + w . at ( i ) * sqrt ( n0 ) ; received . push_back ( rec ) ; } for ( int i = 0 ; i < n ; i ++ ) { double llr = - 2 * received . at ( i ) / n0 ; received . at ( i ) = llr ; } } else { modulated = encoder -> modulate ( coded ) ; std :: vector < double > phase ; std :: vector < double > quad ; for ( int i = 0 ; i < modulated . size ( ) ; i ++ ) { phase . push_back ( modulated . at ( i ) . phase + w . at ( i ) * sqrt ( n0 ) ) ; quad . push_back ( modulated . at ( i ) . quad + w_q . at ( i ) * sqrt ( n0 ) ) ; } received = decoder -> deModLlr ( phase , quad , n0 ) ; } while ( received . size ( ) > n ) { received . pop_back ( ) ; } std :: vector < int > decoded = decoder -> decode ( received ) ; int error = 0 ; bool correct = true ; for ( int i = 0 ; i < k ; i ++ ) { if ( decoded . at ( i ) != coded . at ( i ) ) { if ( correct ) { correct = false ; pktErrors . at ( counter ) ++ ; } error ++ ; } } errors . at ( counter ) += error ; if ( pktErrors . at ( counter ) > minErrors ) { packets . at ( counter ) = packet + 1 ; } } counter ++ ; } } std :: cout << std :: time ( NULL ) << " Finished ! \n " ; int counter = 0 ; for ( double snr = minsnr ; snr < maxsnr ; snr += step ) { double nPackets = maxPackets ; if ( packets . at ( counter ) != 0 ) { nPackets = packets . at ( counter ) ; } double per = pktErrors . at ( counter ) / nPackets ; double ber = errors . at ( counter ) / ( nPackets * k ) ; out << snr << " ▁ " << ber << " ▁ " << per << " \n " ; counter ++ ; } enc . close ( ) ; dec . close ( ) ; out . close ( ) ; delete encoder ; delete decoder ; } </DOCUMENT>
<DOCUMENT_ID="weolar/miniblink49/tree/master/gen/blink/bindings/core/v8/V8VideoTrackList.cpp"> # include " config . h " # include " V8VideoTrackList . h " # include " bindings / core / v8 / ExceptionState . h " # include " bindings / core / v8 / V8AbstractEventListener . h " # include " bindings / core / v8 / V8DOMConfiguration . h " # include " bindings / core / v8 / V8EventListenerList . h " # include " bindings / core / v8 / V8GCController . h " # include " bindings / core / v8 / V8ObjectConstructor . h " # include " bindings / core / v8 / V8VideoTrack . h " # include " core / dom / ContextFeatures . h " # include " core / dom / Document . h " # include " core / dom / Element . h " # include " platform / RuntimeEnabledFeatures . h " # include " platform / TraceEvent . h " # include " wtf / GetPtr . h " # include " wtf / RefPtr . h " namespace blink { # if defined ( COMPONENT_BUILD ) && defined ( WIN32 ) && COMPILER ( CLANG ) # pragma clang diagnostic push # pragma clang diagnostic ignored " - Wglobal - constructors " # endif const WrapperTypeInfo V8VideoTrackList :: wrapperTypeInfo = { gin :: kEmbedderBlink , V8VideoTrackList :: domTemplate , V8VideoTrackList :: refObject , V8VideoTrackList :: derefObject , V8VideoTrackList :: trace , 0 , V8VideoTrackList :: visitDOMWrapper , V8VideoTrackList :: preparePrototypeObject , V8VideoTrackList :: installConditionallyEnabledProperties , " VideoTrackList " , & V8EventTarget :: wrapperTypeInfo , WrapperTypeInfo :: WrapperTypeObjectPrototype , WrapperTypeInfo :: ObjectClassId , WrapperTypeInfo :: InheritFromEventTarget , WrapperTypeInfo :: Dependent , WrapperTypeInfo :: WillBeGarbageCollectedObject } ; # if defined ( COMPONENT_BUILD ) && defined ( WIN32 ) && COMPILER ( CLANG ) # pragma clang diagnostic pop # endif const WrapperTypeInfo & VideoTrackList :: s_wrapperTypeInfo = V8VideoTrackList :: wrapperTypeInfo ; namespace VideoTrackListV8Internal { static void lengthAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; v8SetReturnValueUnsigned ( info , impl -> length ( ) ) ; } static void lengthAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: lengthAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void selectedIndexAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; v8SetReturnValueInt ( info , impl -> selectedIndex ( ) ) ; } static void selectedIndexAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: selectedIndexAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onchangeAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; EventListener * cppValue ( impl -> onchange ( ) ) ; v8SetReturnValue ( info , cppValue ? v8 :: Local < v8 :: Value > ( V8AbstractEventListener :: cast ( cppValue ) -> getListenerObject ( impl -> executionContext ( ) ) ) : v8 :: Local < v8 :: Value > ( v8 :: Null ( info . GetIsolate ( ) ) ) ) ; } static void onchangeAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: onchangeAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onchangeAttributeSetter ( v8 :: Local < v8 :: Value > v8Value , const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; moveEventListenerToNewWrapper ( info . GetIsolate ( ) , holder , impl -> onchange ( ) , v8Value , V8VideoTrackList :: eventListenerCacheIndex ) ; impl -> setOnchange ( V8EventListenerList :: getEventListener ( ScriptState :: current ( info . GetIsolate ( ) ) , v8Value , true , ListenerFindOrCreate ) ) ; } static void onchangeAttributeSetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Value > v8Value = info [ 0 ] ; TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMSetter " ) ; VideoTrackListV8Internal :: onchangeAttributeSetter ( v8Value , info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onaddtrackAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; EventListener * cppValue ( impl -> onaddtrack ( ) ) ; v8SetReturnValue ( info , cppValue ? v8 :: Local < v8 :: Value > ( V8AbstractEventListener :: cast ( cppValue ) -> getListenerObject ( impl -> executionContext ( ) ) ) : v8 :: Local < v8 :: Value > ( v8 :: Null ( info . GetIsolate ( ) ) ) ) ; } static void onaddtrackAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: onaddtrackAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onaddtrackAttributeSetter ( v8 :: Local < v8 :: Value > v8Value , const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; moveEventListenerToNewWrapper ( info . GetIsolate ( ) , holder , impl -> onaddtrack ( ) , v8Value , V8VideoTrackList :: eventListenerCacheIndex ) ; impl -> setOnaddtrack ( V8EventListenerList :: getEventListener ( ScriptState :: current ( info . GetIsolate ( ) ) , v8Value , true , ListenerFindOrCreate ) ) ; } static void onaddtrackAttributeSetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Value > v8Value = info [ 0 ] ; TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMSetter " ) ; VideoTrackListV8Internal :: onaddtrackAttributeSetter ( v8Value , info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onremovetrackAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; EventListener * cppValue ( impl -> onremovetrack ( ) ) ; v8SetReturnValue ( info , cppValue ? v8 :: Local < v8 :: Value > ( V8AbstractEventListener :: cast ( cppValue ) -> getListenerObject ( impl -> executionContext ( ) ) ) : v8 :: Local < v8 :: Value > ( v8 :: Null ( info . GetIsolate ( ) ) ) ) ; } static void onremovetrackAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: onremovetrackAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onremovetrackAttributeSetter ( v8 :: Local < v8 :: Value > v8Value , const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; moveEventListenerToNewWrapper ( info . GetIsolate ( ) , holder , impl -> onremovetrack ( ) , v8Value , V8VideoTrackList :: eventListenerCacheIndex ) ; impl -> setOnremovetrack ( V8EventListenerList :: getEventListener ( ScriptState :: current ( info . GetIsolate ( ) ) , v8Value , true , ListenerFindOrCreate ) ) ; } static void onremovetrackAttributeSetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Value > v8Value = info [ 0 ] ; TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMSetter " ) ; VideoTrackListV8Internal :: onremovetrackAttributeSetter ( v8Value , info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void getTrackByIdMethod ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { if ( UNLIKELY ( info . Length ( ) < 1 ) ) { V8ThrowException :: throwException ( createMinimumArityTypeErrorForMethod ( info . GetIsolate ( ) , " getTrackById " , " VideoTrackList " , 1 , info . Length ( ) ) , info . GetIsolate ( ) ) ; return ; } VideoTrackList * impl = V8VideoTrackList :: toImpl ( info . Holder ( ) ) ; V8StringResource < > id ; { id = info [ 0 ] ; if ( ! id . prepare ( ) ) return ; } v8SetReturnValue ( info , impl -> getTrackById ( id ) ) ; } static void getTrackByIdMethodCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMMethod " ) ; VideoTrackListV8Internal :: getTrackByIdMethod ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void indexedPropertyGetter ( uint32_t index , const v8 :: PropertyCallbackInfo < v8 :: Value > & info ) { VideoTrackList * impl = V8VideoTrackList :: toImpl ( info . Holder ( ) ) ; RefPtrWillBeRawPtr < VideoTrack > result = impl -> anonymousIndexedGetter ( index ) ; if ( ! result ) return ; v8SetReturnValueFast ( info , WTF :: getPtr ( result . release ( ) ) , impl ) ; } static void indexedPropertyGetterCallback ( uint32_t index , const v8 :: PropertyCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMIndexedProperty " ) ; VideoTrackListV8Internal :: indexedPropertyGetter ( index , info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } } void V8VideoTrackList :: visitDOMWrapper ( v8 :: Isolate * isolate , ScriptWrappable * scriptWrappable , const v8 :: Persistent < v8 :: Object > & wrapper ) { VideoTrackList * impl = scriptWrappable -> toImpl < VideoTrackList > ( ) ; if ( Node * owner = WTF :: getPtr ( impl -> owner ( ) ) ) { Node * root = V8GCController :: opaqueRootForGC ( isolate , owner ) ; isolate -> SetReferenceFromGroup ( v8 :: UniqueId ( reinterpret_cast < intptr_t > ( root ) ) , wrapper ) ; return ; } } static const V8DOMConfiguration :: AccessorConfiguration V8VideoTrackListAccessors [ ] = { { " length " , VideoTrackListV8Internal :: lengthAttributeGetterCallback , 0 , 0 , 0 , 0 , static_cast < v8 :: AccessControl > ( v8 :: DEFAULT ) , static_cast < v8 :: PropertyAttribute > ( v8 :: None ) , V8DOMConfiguration :: ExposedToAllScripts , V8DOMConfiguration :: OnPrototype , V8DOMConfiguration :: CheckHolder } , { " selectedIndex " , VideoTrackListV8Internal :: selectedIndexAttributeGetterCallback , 0 , 0 , 0 , 0 , static_cast < v8 :: AccessControl > ( v8 :: DEFAULT ) , static_cast < v8 :: PropertyAttribute > ( v8 :: None ) , V8DOMConfiguration :: ExposedToAllScripts , V8DOMConfiguration :: OnPrototype , V8DOMConfiguration :: CheckHolder } , { " onchange " , VideoTrackListV8Internal :: onchangeAttributeGetterCallback , VideoTrackListV8Internal :: onchangeAttributeSetterCallback , 0 , 0 , 0 , static_cast < v8 :: AccessControl > ( v8 :: DEFAULT ) , static_cast < v8 :: PropertyAttribute > ( v8 :: None ) , V8DOMConfiguration :: ExposedToAllScripts , V8DOMConfiguration :: OnPrototype , V8DOMConfiguration :: CheckHolder } , { " onaddtrack " , VideoTrackListV8Internal :: onaddtrackAttributeGetterCallback , VideoTrackListV8Internal :: onaddtrackAttributeSetterCallback , 0 , 0 , 0 , static_cast < v8 :: AccessControl > ( v8 :: DEFAULT ) , static_cast < v8 :: PropertyAttribute > ( v8 :: None ) , V8DOMConfiguration :: ExposedToAllScripts , V8DOMConfiguration :: OnPrototype , V8DOMConfiguration :: CheckHolder } , { " onremovetrack " , VideoTrackListV8Internal :: onremovetrackAttributeGetterCallback , VideoTrackListV8Internal :: onremovetrackAttributeSetterCallback , 0 , 0 , 0 , static_cast < v8 :: AccessControl > ( v8 :: DEFAULT ) , static_cast < v8 :: PropertyAttribute > ( v8 :: None ) , V8DOMConfiguration :: ExposedToAllScripts , V8DOMConfiguration :: OnPrototype , V8DOMConfiguration :: CheckHolder } , } ; static const V8DOMConfiguration :: MethodConfiguration V8VideoTrackListMethods [ ] = { { " getTrackById " , VideoTrackListV8Internal :: getTrackByIdMethodCallback , 0 , 1 , V8DOMConfiguration :: ExposedToAllScripts } , } ; static void installV8VideoTrackListTemplate ( v8 :: Local < v8 :: FunctionTemplate > functionTemplate , v8 :: Isolate * isolate ) { functionTemplate -> ReadOnlyPrototype ( ) ; v8 :: Local < v8 :: Signature > defaultSignature ; if ( ! RuntimeEnabledFeatures :: audioVideoTracksEnabled ( ) ) defaultSignature = V8DOMConfiguration :: installDOMClassTemplate ( isolate , functionTemplate , " VideoTrackList " , V8EventTarget :: domTemplate ( isolate ) , V8VideoTrackList :: internalFieldCount , 0 , 0 , 0 , 0 , 0 , 0 ) ; else defaultSignature = V8DOMConfiguration :: installDOMClassTemplate ( isolate , functionTemplate , " VideoTrackList " , V8EventTarget :: domTemplate ( isolate ) , V8VideoTrackList :: internalFieldCount , 0 , 0 , V8VideoTrackListAccessors , WTF_ARRAY_LENGTH ( V8VideoTrackListAccessors ) , V8VideoTrackListMethods , WTF_ARRAY_LENGTH ( V8VideoTrackListMethods ) ) ; v8 :: Local < v8 :: ObjectTemplate > instanceTemplate = functionTemplate -> InstanceTemplate ( ) ; ALLOW_UNUSED_LOCAL ( instanceTemplate ) ; v8 :: Local < v8 :: ObjectTemplate > prototypeTemplate = functionTemplate -> PrototypeTemplate ( ) ; ALLOW_UNUSED_LOCAL ( prototypeTemplate ) ; { v8 :: IndexedPropertyHandlerConfiguration config ( VideoTrackListV8Internal :: indexedPropertyGetterCallback , 0 , 0 , 0 , indexedPropertyEnumerator < VideoTrackList > ) ; functionTemplate -> InstanceTemplate ( ) -> SetHandler ( config ) ; } functionTemplate -> Set ( v8AtomicString ( isolate , " toString " ) , V8PerIsolateData :: from ( isolate ) -> toStringTemplate ( ) ) ; } v8 :: Local < v8 :: FunctionTemplate > V8VideoTrackList :: domTemplate ( v8 :: Isolate * isolate ) { return V8DOMConfiguration :: domClassTemplate ( isolate , const_cast < WrapperTypeInfo * > ( & wrapperTypeInfo ) , installV8VideoTrackListTemplate ) ; } bool V8VideoTrackList :: hasInstance ( v8 :: Local < v8 :: Value > v8Value , v8 :: Isolate * isolate ) { return V8PerIsolateData :: from ( isolate ) -> hasInstance ( & wrapperTypeInfo , v8Value ) ; } v8 :: Local < v8 :: Object > V8VideoTrackList :: findInstanceInPrototypeChain ( v8 :: Local < v8 :: Value > v8Value , v8 :: Isolate * isolate ) { return V8PerIsolateData :: from ( isolate ) -> findInstanceInPrototypeChain ( & wrapperTypeInfo , v8Value ) ; } VideoTrackList * V8VideoTrackList :: toImplWithTypeCheck ( v8 :: Isolate * isolate , v8 :: Local < v8 :: Value > value ) { return hasInstance ( value , isolate ) ? toImpl ( v8 :: Local < v8 :: Object > :: Cast ( value ) ) : 0 ; } void V8VideoTrackList :: refObject ( ScriptWrappable * scriptWrappable ) { # if ! ENABLE ( OILPAN ) scriptWrappable -> toImpl < VideoTrackList > ( ) -> ref ( ) ; # endif } void V8VideoTrackList :: derefObject ( ScriptWrappable * scriptWrappable ) { # if ! ENABLE ( OILPAN ) scriptWrappable -> toImpl < VideoTrackList > ( ) -> deref ( ) ; # endif } } </DOCUMENT>
<DOCUMENT_ID="imAArtist/simIr/tree/master/Data/singleFile/code_721.cpp"> int candy ( vector < int > & ratings ) { int size = ratings . size ( ) ; if ( size <= 1 ) return size ; vector < int > num ( size , 1 ) ; for ( int i = 1 ; i < size ; i ++ ) { if ( ratings [ i ] > ratings [ i - 1 ] ) num [ i ] = num [ i - 1 ] + 1 ; } for ( int i = size - 1 ; i > 0 ; i -- ) { if ( ratings [ i - 1 ] > ratings [ i ] ) num [ i - 1 ] = max ( num [ i ] + 1 , num [ i - 1 ] ) ; } int result = 0 ; for ( int i = 0 ; i < size ; i ++ ) { result += num [ i ] ; } return result ; } 1 , 3 , 3 , 3 , 21 , 2 , 1 , 2 , 1public int candy ( int [ ] ratings ) { int len = ratings . length ; int [ ] candy = new int [ len ] ; candy [ 0 ] = 1 ; for ( int i = 1 ; i < len ; ++ i ) { if ( ratings [ i ] > ratings [ i - 1 ] ) { candy [ i ] = candy [ i - 1 ] + 1 ; } else { candy [ i ] = 1 ; } } int total = candy [ len - 1 ] ; for ( int i = len - 2 ; i >= 0 ; -- i ) { if ( ratings [ i ] > ratings [ i + 1 ] && candy [ i ] <= candy [ i + 1 ] ) { candy [ i ] = candy [ i + 1 ] + 1 ; } total += candy [ i ] ; } return total ; } </DOCUMENT>
<DOCUMENT_ID="JoseBarrales/mlnc/tree/master/src/test/rpc_tests.cpp"> # include < boost / test / unit_test . hpp > # include < boost / foreach . hpp > # include " base58 . h " # include " util . h " # include " bitcoinrpc . h " using namespace std ; using namespace json_spirit ; BOOST_AUTO_TEST_SUITE ( rpc_tests ) static Array createArgs ( int nRequired , const char * address1 = NULL , const char * address2 = NULL ) { Array result ; result . push_back ( nRequired ) ; Array addresses ; if ( address1 ) addresses . push_back ( address1 ) ; if ( address2 ) addresses . push_back ( address1 ) ; result . push_back ( addresses ) ; return result ; } struct TestNetFixture { TestNetFixture ( ) { fTestNet = true ; } ~ TestNetFixture ( ) { fTestNet = false ; } } ; BOOST_FIXTURE_TEST_CASE ( rpc_addmultisig , TestNetFixture ) { rpcfn_type addmultisig = tableRPC [ " addmultisigaddress " ] -> actor ; const char * address1Hex = "0434e3e09f49ea168c5bbf53f877ff4206923858aab7c7e1df25bc263978107c95e35065a27ef6f1b27222db0ec97e0e895eaca603d3ee0d4c060ce3d8a00286c8" ; const char * address2Hex = "0388c2037017c62240b6b72ac1a2a5f94da790596ebd06177c8572752922165cb4" ; Value v ; CBitcoinAddress address ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 1 , address1Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 1 , address1Hex , address2Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 2 , address1Hex , address2Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 0 ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , address1Hex ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 , " " ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 , " NotAValidPubkey " ) , false ) , runtime_error ) ; string short1 ( address1Hex , address1Hex + sizeof ( address1Hex ) - 2 ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , short1 . c_str ( ) ) , false ) , runtime_error ) ; string short2 ( address1Hex + 2 , address1Hex + sizeof ( address1Hex ) ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , short2 . c_str ( ) ) , false ) , runtime_error ) ; } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
