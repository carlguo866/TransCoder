<DOCUMENT_ID="ShiftMediaProject/game-music-emu/tree/master/gme/Ay_Apu.cpp"> # include " Ay _ Apu . h " # include " blargg _ source . h " unsigned const inaudible_freq = 16384 ; int const period_factor = 16 ; static byte const amp_table [ 16 ] = { # define ENTRY ( n ) byte ( n * Ay_Apu :: amp_range + 0.5 ) ENTRY ( 0.000000 ) , ENTRY ( 0.007813 ) , ENTRY ( 0.011049 ) , ENTRY ( 0.015625 ) , ENTRY ( 0.022097 ) , ENTRY ( 0.031250 ) , ENTRY ( 0.044194 ) , ENTRY ( 0.062500 ) , ENTRY ( 0.088388 ) , ENTRY ( 0.125000 ) , ENTRY ( 0.176777 ) , ENTRY ( 0.250000 ) , ENTRY ( 0.353553 ) , ENTRY ( 0.500000 ) , ENTRY ( 0.707107 ) , ENTRY ( 1.000000 ) , # undef ENTRY } ; static byte const modes [ 8 ] = { # define MODE ( a0 , a1 , b0 , b1 , c0 , c1 ) ( a0 | a1 << 1 | b0 << 2 | b1 << 3 | c0 << 4 | c1 << 5 ) MODE ( 1 , 0 , 1 , 0 , 1 , 0 ) , MODE ( 1 , 0 , 0 , 0 , 0 , 0 ) , MODE ( 1 , 0 , 0 , 1 , 1 , 0 ) , MODE ( 1 , 0 , 1 , 1 , 1 , 1 ) , MODE ( 0 , 1 , 0 , 1 , 0 , 1 ) , MODE ( 0 , 1 , 1 , 1 , 1 , 1 ) , MODE ( 0 , 1 , 1 , 0 , 0 , 1 ) , MODE ( 0 , 1 , 0 , 0 , 0 , 0 ) , } ; Ay_Apu :: Ay_Apu ( ) { for ( int m = 8 ; m -- ; ) { byte * out = env . modes [ m ] ; int flags = modes [ m ] ; for ( int x = 3 ; -- x >= 0 ; ) { int amp = flags & 1 ; int end = flags >> 1 & 1 ; int step = end - amp ; amp *= 15 ; for ( int y = 16 ; -- y >= 0 ; ) { * out ++ = amp_table [ amp ] ; amp += step ; } flags >>= 2 ; } } output ( 0 ) ; volume ( 1.0 ) ; reset ( ) ; } void Ay_Apu :: reset ( ) { last_time = 0 ; noise . delay = 0 ; noise . lfsr = 1 ; osc_t * osc = & oscs [ osc_count ] ; do { osc -- ; osc -> period = period_factor ; osc -> delay = 0 ; osc -> last_amp = 0 ; osc -> phase = 0 ; } while ( osc != oscs ) ; for ( int i = sizeof regs ; -- i >= 0 ; ) regs [ i ] = 0 ; regs [ 7 ] = 0xFF ; write_data_ ( 13 , 0 ) ; } void Ay_Apu :: write_data_ ( int addr , int data ) { assert ( ( unsigned ) addr < reg_count ) ; if ( ( unsigned ) addr >= 14 ) { # ifdef debug_printf debug_printf ( " Wrote ▁ to ▁ I / O ▁ port ▁ % 02X \n " , ( int ) addr ) ; # endif } if ( addr == 13 ) { if ( ! ( data & 8 ) ) data = ( data & 4 ) ? 15 : 9 ; env . wave = env . modes [ data - 7 ] ; env . pos = - 48 ; env . delay = 0 ; } regs [ addr ] = data ; int i = addr >> 1 ; if ( i < osc_count ) { blip_time_t period = ( regs [ i * 2 + 1 ] & 0x0F ) * ( 0x100L * period_factor ) + regs [ i * 2 ] * period_factor ; if ( ! period ) period = period_factor ; osc_t & osc = oscs [ i ] ; if ( ( osc . delay += period - osc . period ) < 0 ) osc . delay = 0 ; osc . period = period ; } } int const noise_off = 0x08 ; int const tone_off = 0x01 ; void Ay_Apu :: run_until ( blip_time_t final_end_time ) { require ( final_end_time >= last_time ) ; blip_time_t const noise_period_factor = period_factor * 2 ; blip_time_t noise_period = ( regs [ 6 ] & 0x1F ) * noise_period_factor ; if ( ! noise_period ) noise_period = noise_period_factor ; blip_time_t const old_noise_delay = noise . delay ; blargg_ulong const old_noise_lfsr = noise . lfsr ; blip_time_t const env_period_factor = period_factor * 2 ; blip_time_t env_period = ( regs [ 12 ] * 0x100L + regs [ 11 ] ) * env_period_factor ; if ( ! env_period ) env_period = env_period_factor ; if ( ! env . delay ) env . delay = env_period ; for ( int index = 0 ; index < osc_count ; index ++ ) { osc_t * const osc = & oscs [ index ] ; int osc_mode = regs [ 7 ] >> index ; Blip_Buffer * const osc_output = osc -> output ; if ( ! osc_output ) continue ; osc_output -> set_modified ( ) ; int half_vol = 0 ; blip_time_t inaudible_period = ( blargg_ulong ) ( osc_output -> clock_rate ( ) + inaudible_freq ) / ( inaudible_freq * 2 ) ; if ( osc -> period <= inaudible_period && ! ( osc_mode & tone_off ) ) { half_vol = 1 ; osc_mode |= tone_off ; } blip_time_t start_time = last_time ; blip_time_t end_time = final_end_time ; int const vol_mode = regs [ 0x08 + index ] ; int volume = amp_table [ vol_mode & 0x0F ] >> half_vol ; int osc_env_pos = env . pos ; if ( vol_mode & 0x10 ) { volume = env . wave [ osc_env_pos ] >> half_vol ; if ( ! ( regs [ 13 ] & 1 ) || osc_env_pos < - 32 ) { end_time = start_time + env . delay ; if ( end_time >= final_end_time ) end_time = final_end_time ; } else if ( ! volume ) { osc_mode = noise_off | tone_off ; } } else if ( ! volume ) { osc_mode = noise_off | tone_off ; } blip_time_t const period = osc -> period ; blip_time_t time = start_time + osc -> delay ; if ( osc_mode & tone_off ) { blargg_long count = ( final_end_time - time + period - 1 ) / period ; time += count * period ; osc -> phase ^= count & 1 ; } blip_time_t ntime = final_end_time ; blargg_ulong noise_lfsr = 1 ; if ( ! ( osc_mode & noise_off ) ) { ntime = start_time + old_noise_delay ; noise_lfsr = old_noise_lfsr ; } while ( 1 ) { int amp = 0 ; if ( ( osc_mode | osc -> phase ) & 1 & ( osc_mode >> 3 | noise_lfsr ) ) amp = volume ; { int delta = amp - osc -> last_amp ; if ( delta ) { osc -> last_amp = amp ; synth_ . offset ( start_time , delta , osc_output ) ; } } if ( ntime < end_time || time < end_time ) { int delta = amp * 2 - volume ; int delta_non_zero = delta != 0 ; int phase = osc -> phase | ( osc_mode & tone_off ) ; assert ( tone_off == 0x01 ) ; do { blip_time_t end = end_time ; if ( end_time > time ) end = time ; if ( phase & delta_non_zero ) { while ( ntime <= end ) { int changed = noise_lfsr + 1 ; noise_lfsr = ( - ( noise_lfsr & 1 ) & 0x12000 ) ^ ( noise_lfsr >> 1 ) ; if ( changed & 2 ) { delta = - delta ; synth_ . offset ( ntime , delta , osc_output ) ; } ntime += noise_period ; } } else { blargg_long remain = end - ntime ; blargg_long count = remain / noise_period ; if ( remain >= 0 ) ntime += noise_period + count * noise_period ; } end = end_time ; if ( end_time > ntime ) end = ntime ; if ( noise_lfsr & delta_non_zero ) { while ( time < end ) { delta = - delta ; synth_ . offset ( time , delta , osc_output ) ; time += period ; } phase = unsigned ( - delta ) >> ( CHAR_BIT * sizeof ( unsigned ) - 1 ) ; } else { while ( time < end ) { time += period ; phase ^= 1 ; } } } while ( time < end_time || ntime < end_time ) ; osc -> last_amp = ( delta + volume ) >> 1 ; if ( ! ( osc_mode & tone_off ) ) osc -> phase = phase ; } if ( end_time >= final_end_time ) break ; if ( ++ osc_env_pos >= 0 ) osc_env_pos -= 32 ; volume = env . wave [ osc_env_pos ] >> half_vol ; start_time = end_time ; end_time += env_period ; if ( end_time > final_end_time ) end_time = final_end_time ; } osc -> delay = time - final_end_time ; if ( ! ( osc_mode & noise_off ) ) { noise . delay = ntime - final_end_time ; noise . lfsr = noise_lfsr ; } } blip_time_t remain = final_end_time - last_time - env . delay ; if ( remain >= 0 ) { blargg_long count = ( remain + env_period ) / env_period ; env . pos += count ; if ( env . pos >= 0 ) env . pos = ( env . pos & 31 ) - 32 ; remain -= count * env_period ; assert ( - remain <= env_period ) ; } env . delay = - remain ; assert ( env . delay > 0 ) ; assert ( env . pos < 0 ) ; last_time = final_end_time ; } </DOCUMENT>
<DOCUMENT_ID="whc10002/study/tree/master/libcds/test/unit/striped-map/map_boost_flat_map.cpp"> # ifdef CDSUNIT_ENABLE_BOOST_CONTAINER # include < boost / version . hpp > # include < cds / details / defs . h > # if CDS_COMPILER == CDS_COMPILER_MSVC && CDS_COMPILER_VERSION == CDS_COMPILER_MSVC12 && BOOST_VERSION < 105500 # elif BOOST_VERSION >= 104800 # include < cds / container / striped_map / boost_flat_map . h > # include " test _ striped _ map . h " namespace { struct test_traits { typedef boost :: container :: flat_map < cds_test :: striped_map_fixture :: key_type , cds_test :: striped_map_fixture :: value_type , cds_test :: striped_map_fixture :: less > container_type ; struct copy_policy { typedef container_type :: iterator iterator ; void operator ( ) ( container_type & m , iterator , iterator itWhat ) { m . insert ( * itWhat ) ; } } ; static bool const c_hasFindWith = false ; static bool const c_hasEraseWith = false ; } ; INSTANTIATE_TYPED_TEST_CASE_P ( BoostFlatMap , StripedMap , test_traits ) ; INSTANTIATE_TYPED_TEST_CASE_P ( BoostFlatMap , RefinableMap , test_traits ) ; } # else # endif # endif </DOCUMENT>
<DOCUMENT_ID="NickelMedia/phantomjs/tree/master/src/qt/qtbase/config.tests/unix/evdev/evdev.cpp"> # include < linux / input . h > # include < linux / kd . h > enum { e1 = ABS_PRESSURE , e2 = ABS_X , e3 = REL_X , e4 = SYN_REPORT , } ; int main ( ) { :: input_event buf [ 32 ] ; ( void ) buf ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="sacarlson/MultiCoin-exp/tree/master/src/db.cpp"> # include " headers . h " # include " db . h " # include " net . h " # include " auxpow . h " # include < boost / filesystem . hpp > # include < boost / filesystem / fstream . hpp > using namespace std ; using namespace boost ; unsigned int nWalletDBUpdated ; uint64 nAccountingEntryNumber = 0 ; static CCriticalSection cs_db ; static bool fDbEnvInit = false ; DbEnv dbenv ( 0 ) ; static map < string , int > mapFileUseCount ; static map < string , Db * > mapDb ; class CDBInit { public : CDBInit ( ) { } ~ CDBInit ( ) { if ( fDbEnvInit ) { dbenv . close ( 0 ) ; fDbEnvInit = false ; } } } instance_of_cdbinit ; CDB :: CDB ( const char * pszFile , const char * pszMode ) : pdb ( NULL ) { int ret ; if ( pszFile == NULL ) return ; fReadOnly = ( ! strchr ( pszMode , ' + ' ) && ! strchr ( pszMode , ' w ' ) ) ; bool fCreate = strchr ( pszMode , ' c ' ) ; unsigned int nFlags = DB_THREAD ; if ( fCreate ) nFlags |= DB_CREATE ; CRITICAL_BLOCK ( cs_db ) { if ( ! fDbEnvInit ) { if ( fShutdown ) return ; string strDataDir = GetDataDir ( ) ; string strLogDir = strDataDir + " / database " ; filesystem :: create_directory ( strLogDir . c_str ( ) ) ; string strErrorFile = strDataDir + " / db . log " ; printf ( " dbenv . open ▁ strLogDir = % s ▁ strErrorFile = % s \n " , strLogDir . c_str ( ) , strErrorFile . c_str ( ) ) ; dbenv . set_lg_dir ( strLogDir . c_str ( ) ) ; dbenv . set_lg_max ( 10000000 ) ; dbenv . set_lk_max_locks ( 10000 ) ; dbenv . set_lk_max_objects ( 10000 ) ; dbenv . set_errfile ( fopen ( strErrorFile . c_str ( ) , " a " ) ) ; dbenv . set_flags ( DB_AUTO_COMMIT , 1 ) ; ret = dbenv . open ( strDataDir . c_str ( ) , DB_CREATE | DB_INIT_LOCK | DB_INIT_LOG | DB_INIT_MPOOL | DB_INIT_TXN | DB_THREAD | DB_RECOVER , S_IRUSR | S_IWUSR ) ; if ( ret > 0 ) throw runtime_error ( strprintf ( " CDB ( ) ▁ : ▁ error ▁ % d ▁ opening ▁ database ▁ environment " , ret ) ) ; fDbEnvInit = true ; } strFile = pszFile ; ++ mapFileUseCount [ strFile ] ; pdb = mapDb [ strFile ] ; if ( pdb == NULL ) { pdb = new Db ( & dbenv , 0 ) ; ret = pdb -> open ( NULL , pszFile , " main " , DB_BTREE , nFlags , 0 ) ; if ( ret > 0 ) { delete pdb ; pdb = NULL ; CRITICAL_BLOCK ( cs_db ) -- mapFileUseCount [ strFile ] ; strFile = " " ; throw runtime_error ( strprintf ( " CDB ( ) ▁ : ▁ can ' t ▁ open ▁ database ▁ file ▁ % s , ▁ error ▁ % d " , pszFile , ret ) ) ; } if ( fCreate && ! Exists ( string ( " version " ) ) ) { bool fTmp = fReadOnly ; fReadOnly = false ; WriteVersion ( VERSION ) ; fReadOnly = fTmp ; } mapDb [ strFile ] = pdb ; } } } void CDB :: Close ( ) { if ( ! pdb ) return ; if ( ! vTxn . empty ( ) ) vTxn . front ( ) -> abort ( ) ; vTxn . clear ( ) ; pdb = NULL ; unsigned int nMinutes = 0 ; if ( fReadOnly ) nMinutes = 1 ; if ( strFile == " addr . dat " ) nMinutes = 2 ; if ( strFile == " blkindex . dat " && IsInitialBlockDownload ( ) && nBestHeight % 500 != 0 ) nMinutes = 1 ; dbenv . txn_checkpoint ( 0 , nMinutes , 0 ) ; CRITICAL_BLOCK ( cs_db ) -- mapFileUseCount [ strFile ] ; } void static CloseDb ( const string & strFile ) { CRITICAL_BLOCK ( cs_db ) { if ( mapDb [ strFile ] != NULL ) { Db * pdb = mapDb [ strFile ] ; pdb -> close ( 0 ) ; delete pdb ; mapDb [ strFile ] = NULL ; } } } void DBFlush ( bool fShutdown ) { printf ( " DBFlush ( % s ) % s \n " , fShutdown ? " true " : " false " , fDbEnvInit ? " " : " ▁ db ▁ not ▁ started " ) ; if ( ! fDbEnvInit ) return ; CRITICAL_BLOCK ( cs_db ) { map < string , int > :: iterator mi = mapFileUseCount . begin ( ) ; while ( mi != mapFileUseCount . end ( ) ) { string strFile = ( * mi ) . first ; int nRefCount = ( * mi ) . second ; printf ( " % s ▁ refcount = % d \n " , strFile . c_str ( ) , nRefCount ) ; if ( nRefCount == 0 ) { CloseDb ( strFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; printf ( " % s ▁ flush \n " , strFile . c_str ( ) ) ; dbenv . lsn_reset ( strFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( mi ++ ) ; } else mi ++ ; } if ( fShutdown ) { char * * listp ; if ( mapFileUseCount . empty ( ) ) dbenv . log_archive ( & listp , DB_ARCH_REMOVE ) ; dbenv . close ( 0 ) ; fDbEnvInit = false ; } } } bool CTxDB :: ReadTxIndex ( uint256 hash , CTxIndex & txindex ) { assert ( ! fClient ) ; txindex . SetNull ( ) ; return Read ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; } bool CTxDB :: UpdateTxIndex ( uint256 hash , const CTxIndex & txindex ) { assert ( ! fClient ) ; return Write ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; } bool CTxDB :: AddTxIndex ( const CTransaction & tx , const CDiskTxPos & pos , int nHeight ) { assert ( ! fClient ) ; uint256 hash = tx . GetHash ( ) ; CTxIndex txindex ( pos , tx . vout . size ( ) ) ; return Write ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; } bool CTxDB :: EraseTxIndex ( const CTransaction & tx ) { assert ( ! fClient ) ; uint256 hash = tx . GetHash ( ) ; return Erase ( make_pair ( string ( " tx " ) , hash ) ) ; } bool CTxDB :: ContainsTx ( uint256 hash ) { assert ( ! fClient ) ; return Exists ( make_pair ( string ( " tx " ) , hash ) ) ; } bool CTxDB :: ReadOwnerTxes ( uint160 hash160 , int nMinHeight , vector < CTransaction > & vtx ) { assert ( ! fClient ) ; vtx . clear ( ) ; Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; unsigned int fFlags = DB_SET_RANGE ; loop { CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << string ( " owner " ) << hash160 << CDiskTxPos ( 0 , 0 , 0 ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) { pcursor -> close ( ) ; return false ; } string strType ; uint160 hashItem ; CDiskTxPos pos ; ssKey >> strType >> hashItem >> pos ; int nItemHeight ; ssValue >> nItemHeight ; if ( strType != " owner " || hashItem != hash160 ) break ; if ( nItemHeight >= nMinHeight ) { vtx . resize ( vtx . size ( ) + 1 ) ; if ( ! vtx . back ( ) . ReadFromDisk ( pos ) ) { pcursor -> close ( ) ; return false ; } } } pcursor -> close ( ) ; return true ; } bool CTxDB :: ReadDiskTx ( uint256 hash , CTransaction & tx , CTxIndex & txindex ) { assert ( ! fClient ) ; tx . SetNull ( ) ; if ( ! ReadTxIndex ( hash , txindex ) ) return false ; return ( tx . ReadFromDisk ( txindex . pos ) ) ; } bool CTxDB :: ReadDiskTx ( uint256 hash , CTransaction & tx ) { CTxIndex txindex ; return ReadDiskTx ( hash , tx , txindex ) ; } bool CTxDB :: ReadDiskTx ( COutPoint outpoint , CTransaction & tx , CTxIndex & txindex ) { return ReadDiskTx ( outpoint . hash , tx , txindex ) ; } bool CTxDB :: ReadDiskTx ( COutPoint outpoint , CTransaction & tx ) { CTxIndex txindex ; return ReadDiskTx ( outpoint . hash , tx , txindex ) ; } bool CTxDB :: WriteBlockIndex ( const CDiskBlockIndex & blockindex ) { return Write ( make_pair ( string ( " blockindex " ) , blockindex . GetBlockHash ( ) ) , blockindex ) ; } bool CTxDB :: EraseBlockIndex ( uint256 hash ) { return Erase ( make_pair ( string ( " blockindex " ) , hash ) ) ; } bool CTxDB :: ReadHashBestChain ( uint256 & hashBestChain ) { return Read ( string ( " hashBestChain " ) , hashBestChain ) ; } bool CTxDB :: WriteHashBestChain ( uint256 hashBestChain ) { return Write ( string ( " hashBestChain " ) , hashBestChain ) ; } bool CTxDB :: ReadBestInvalidWork ( CBigNum & bnBestInvalidWork ) { return Read ( string ( " bnBestInvalidWork " ) , bnBestInvalidWork ) ; } bool CTxDB :: WriteBestInvalidWork ( CBigNum bnBestInvalidWork ) { return Write ( string ( " bnBestInvalidWork " ) , bnBestInvalidWork ) ; } CBlockIndex static * InsertBlockIndex ( uint256 hash ) { if ( hash == 0 ) return NULL ; map < uint256 , CBlockIndex * > :: iterator mi = mapBlockIndex . find ( hash ) ; if ( mi != mapBlockIndex . end ( ) ) return ( * mi ) . second ; CBlockIndex * pindexNew = new CBlockIndex ( ) ; if ( ! pindexNew ) throw runtime_error ( " LoadBlockIndex ( ) ▁ : ▁ new ▁ CBlockIndex ▁ failed " ) ; mi = mapBlockIndex . insert ( make_pair ( hash , pindexNew ) ) . first ; pindexNew -> phashBlock = & ( ( * mi ) . first ) ; return pindexNew ; } bool CTxDB :: LoadBlockIndex ( ) { Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; unsigned int fFlags = DB_SET_RANGE ; loop { CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << make_pair ( string ( " blockindex " ) , uint256 ( 0 ) ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; string strType ; ssKey >> strType ; if ( strType == " blockindex " ) { CDiskBlockIndex diskindex ; ssValue >> diskindex ; CBlockIndex * pindexNew = InsertBlockIndex ( diskindex . GetBlockHash ( ) ) ; pindexNew -> pprev = InsertBlockIndex ( diskindex . hashPrev ) ; pindexNew -> pnext = InsertBlockIndex ( diskindex . hashNext ) ; pindexNew -> nFile = diskindex . nFile ; pindexNew -> nBlockPos = diskindex . nBlockPos ; pindexNew -> nHeight = diskindex . nHeight ; pindexNew -> nVersion = diskindex . nVersion ; pindexNew -> hashMerkleRoot = diskindex . hashMerkleRoot ; pindexNew -> nTime = diskindex . nTime ; pindexNew -> nBits = diskindex . nBits ; pindexNew -> nNonce = diskindex . nNonce ; pindexNew -> auxpow = diskindex . auxpow ; if ( pindexGenesisBlock == NULL && diskindex . GetBlockHash ( ) == hashGenesisBlock ) pindexGenesisBlock = pindexNew ; if ( ! pindexNew -> CheckIndex ( ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ CheckIndex ▁ failed ▁ at ▁ % d " , pindexNew -> nHeight ) ; } else { break ; } } pcursor -> close ( ) ; vector < pair < int , CBlockIndex * > > vSortedByHeight ; vSortedByHeight . reserve ( mapBlockIndex . size ( ) ) ; BOOST_FOREACH ( const PAIRTYPE ( uint256 , CBlockIndex * ) & item , mapBlockIndex ) { CBlockIndex * pindex = item . second ; vSortedByHeight . push_back ( make_pair ( pindex -> nHeight , pindex ) ) ; } sort ( vSortedByHeight . begin ( ) , vSortedByHeight . end ( ) ) ; BOOST_FOREACH ( const PAIRTYPE ( int , CBlockIndex * ) & item , vSortedByHeight ) { CBlockIndex * pindex = item . second ; pindex -> bnChainWork = ( pindex -> pprev ? pindex -> pprev -> bnChainWork : 0 ) + pindex -> GetBlockWork ( ) ; } if ( ! ReadHashBestChain ( hashBestChain ) ) { if ( pindexGenesisBlock == NULL ) return true ; return error ( " CTxDB : : LoadBlockIndex ( ) ▁ : ▁ hashBestChain ▁ not ▁ loaded " ) ; } if ( ! mapBlockIndex . count ( hashBestChain ) ) return error ( " CTxDB : : LoadBlockIndex ( ) ▁ : ▁ hashBestChain ▁ not ▁ found ▁ in ▁ the ▁ block ▁ index " ) ; pindexBest = mapBlockIndex [ hashBestChain ] ; nBestHeight = pindexBest -> nHeight ; bnBestChainWork = pindexBest -> bnChainWork ; printf ( " LoadBlockIndex ( ) : ▁ hashBestChain = % s ▁ ▁ height = % d \n " , hashBestChain . ToString ( ) . substr ( 0 , 20 ) . c_str ( ) , nBestHeight ) ; ReadBestInvalidWork ( bnBestInvalidWork ) ; CBlockIndex * pindexFork = NULL ; for ( CBlockIndex * pindex = pindexBest ; pindex && pindex -> pprev ; pindex = pindex -> pprev ) { if ( pindex -> nHeight < nBestHeight - 2500 && ! mapArgs . count ( " - checkblocks " ) ) break ; CBlock block ; if ( ! block . ReadFromDisk ( pindex ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ block . ReadFromDisk ▁ failed " ) ; if ( ! block . CheckBlock ( pindex -> nHeight ) ) { printf ( " LoadBlockIndex ( ) ▁ : ▁ * * * ▁ found ▁ bad ▁ block ▁ at ▁ % d , ▁ hash = % s \n " , pindex -> nHeight , pindex -> GetBlockHash ( ) . ToString ( ) . c_str ( ) ) ; pindexFork = pindex -> pprev ; } } if ( pindexFork ) { printf ( " LoadBlockIndex ( ) ▁ : ▁ * * * ▁ moving ▁ best ▁ chain ▁ pointer ▁ back ▁ to ▁ block ▁ % d \n " , pindexFork -> nHeight ) ; CBlock block ; if ( ! block . ReadFromDisk ( pindexFork ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ block . ReadFromDisk ▁ failed " ) ; CTxDB txdb ; block . SetBestChain ( txdb , pindexFork ) ; } return true ; } bool CAddrDB :: WriteAddress ( const CAddress & addr ) { return Write ( make_pair ( string ( " addr " ) , addr . GetKey ( ) ) , addr ) ; } bool CAddrDB :: EraseAddress ( const CAddress & addr ) { return Erase ( make_pair ( string ( " addr " ) , addr . GetKey ( ) ) ) ; } bool CAddrDB :: LoadAddresses ( ) { CRITICAL_BLOCK ( cs_mapAddresses ) { CAutoFile filein = fopen ( ( GetDataDir ( ) + " / addr . txt " ) . c_str ( ) , " rt " ) ; if ( filein ) { try { char psz [ 1000 ] ; while ( fgets ( psz , sizeof ( psz ) , filein ) ) { CAddress addr ( psz , NODE_NETWORK ) ; addr . nTime = 0 ; if ( addr . IsValid ( ) ) AddAddress ( addr ) ; } } catch ( ... ) { } } Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; loop { CDataStream ssKey ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue ) ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; string strType ; ssKey >> strType ; if ( strType == " addr " ) { CAddress addr ; ssValue >> addr ; mapAddresses . insert ( make_pair ( addr . GetKey ( ) , addr ) ) ; } } pcursor -> close ( ) ; printf ( " Loaded ▁ % d ▁ addresses \n " , mapAddresses . size ( ) ) ; } return true ; } bool LoadAddresses ( ) { return CAddrDB ( " cr + " ) . LoadAddresses ( ) ; } bool CWalletDB :: WriteName ( const string & strAddress , const string & strName ) { nWalletDBUpdated ++ ; return Write ( make_pair ( string ( " name " ) , strAddress ) , strName ) ; } bool CWalletDB :: EraseName ( const string & strAddress ) { nWalletDBUpdated ++ ; return Erase ( make_pair ( string ( " name " ) , strAddress ) ) ; } bool CWalletDB :: ReadAccount ( const string & strAccount , CAccount & account ) { account . SetNull ( ) ; return Read ( make_pair ( string ( " acc " ) , strAccount ) , account ) ; } bool CWalletDB :: WriteAccount ( const string & strAccount , const CAccount & account ) { return Write ( make_pair ( string ( " acc " ) , strAccount ) , account ) ; } bool CWalletDB :: WriteAccountingEntry ( const CAccountingEntry & acentry ) { return Write ( make_tuple ( string ( " acentry " ) , acentry . strAccount , ++ nAccountingEntryNumber ) , acentry ) ; } int64 CWalletDB :: GetAccountCreditDebit ( const string & strAccount ) { list < CAccountingEntry > entries ; ListAccountCreditDebit ( strAccount , entries ) ; int64 nCreditDebit = 0 ; BOOST_FOREACH ( const CAccountingEntry & entry , entries ) nCreditDebit += entry . nCreditDebit ; return nCreditDebit ; } void CWalletDB :: ListAccountCreditDebit ( const string & strAccount , list < CAccountingEntry > & entries ) { int64 nCreditDebit = 0 ; bool fAllAccounts = ( strAccount == " * " ) ; Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) throw runtime_error ( " CWalletDB : : ListAccountCreditDebit ( ) ▁ : ▁ cannot ▁ create ▁ DB ▁ cursor " ) ; unsigned int fFlags = DB_SET_RANGE ; loop { CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << make_tuple ( string ( " acentry " ) , ( fAllAccounts ? string ( " " ) : strAccount ) , uint64 ( 0 ) ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) { pcursor -> close ( ) ; throw runtime_error ( " CWalletDB : : ListAccountCreditDebit ( ) ▁ : ▁ error ▁ scanning ▁ DB " ) ; } string strType ; ssKey >> strType ; if ( strType != " acentry " ) break ; CAccountingEntry acentry ; ssKey >> acentry . strAccount ; if ( ! fAllAccounts && acentry . strAccount != strAccount ) break ; ssValue >> acentry ; entries . push_back ( acentry ) ; } pcursor -> close ( ) ; } bool CWalletDB :: LoadWallet ( CWallet * pwallet ) { pwallet -> vchDefaultKey . clear ( ) ; int nFileVersion = 0 ; vector < uint256 > vWalletUpgrade ; # ifndef __WXMSW__ fMinimizeToTray = false ; fMinimizeOnClose = false ; # endif CRITICAL_BLOCK ( pwallet -> cs_mapWallet ) CRITICAL_BLOCK ( pwallet -> cs_mapKeys ) { Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; loop { CDataStream ssKey ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue ) ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; string strType ; ssKey >> strType ; if ( strType == " name " ) { string strAddress ; ssKey >> strAddress ; ssValue >> pwallet -> mapAddressBook [ strAddress ] ; } else if ( strType == " tx " ) { uint256 hash ; ssKey >> hash ; CWalletTx & wtx = pwallet -> mapWallet [ hash ] ; ssValue >> wtx ; wtx . pwallet = pwallet ; if ( wtx . GetHash ( ) != hash ) printf ( " Error ▁ in ▁ wallet . dat , ▁ hash ▁ mismatch \n " ) ; if ( 31404 <= wtx . fTimeReceivedIsTxTime && wtx . fTimeReceivedIsTxTime <= 31703 ) { if ( ! ssValue . empty ( ) ) { char fTmp ; char fUnused ; ssValue >> fTmp >> fUnused >> wtx . strFromAccount ; printf ( " LoadWallet ( ) ▁ upgrading ▁ tx ▁ ver = % d ▁ % d ▁ ' % s ' ▁ % s \n " , wtx . fTimeReceivedIsTxTime , fTmp , wtx . strFromAccount . c_str ( ) , hash . ToString ( ) . c_str ( ) ) ; wtx . fTimeReceivedIsTxTime = fTmp ; } else { printf ( " LoadWallet ( ) ▁ repairing ▁ tx ▁ ver = % d ▁ % s \n " , wtx . fTimeReceivedIsTxTime , hash . ToString ( ) . c_str ( ) ) ; wtx . fTimeReceivedIsTxTime = 0 ; } vWalletUpgrade . push_back ( hash ) ; } } else if ( strType == " acentry " ) { string strAccount ; ssKey >> strAccount ; uint64 nNumber ; ssKey >> nNumber ; if ( nNumber > nAccountingEntryNumber ) nAccountingEntryNumber = nNumber ; } else if ( strType == " key " || strType == " wkey " ) { vector < unsigned char > vchPubKey ; ssKey >> vchPubKey ; CWalletKey wkey ; if ( strType == " key " ) ssValue >> wkey . vchPrivKey ; else ssValue >> wkey ; pwallet -> mapKeys [ vchPubKey ] = wkey . vchPrivKey ; mapPubKeys [ Hash160 ( vchPubKey ) ] = vchPubKey ; } else if ( strType == " defaultkey " ) { ssValue >> pwallet -> vchDefaultKey ; } else if ( strType == " pool " ) { int64 nIndex ; ssKey >> nIndex ; pwallet -> setKeyPool . insert ( nIndex ) ; } else if ( strType == " version " ) { ssValue >> nFileVersion ; if ( nFileVersion == 10300 ) nFileVersion = 300 ; } else if ( strType == " setting " ) { string strKey ; ssKey >> strKey ; # ifndef GUI if ( strKey == " fGenerateBitcoins " ) ssValue >> fGenerateBitcoins ; # endif if ( strKey == " nTransactionFee " ) ssValue >> nTransactionFee ; if ( strKey == " addrIncoming " ) ssValue >> addrIncoming ; if ( strKey == " fLimitProcessors " ) ssValue >> fLimitProcessors ; if ( strKey == " nLimitProcessors " ) ssValue >> nLimitProcessors ; if ( strKey == " fMinimizeToTray " ) ssValue >> fMinimizeToTray ; if ( strKey == " fMinimizeOnClose " ) ssValue >> fMinimizeOnClose ; if ( strKey == " fUseProxy " ) ssValue >> fUseProxy ; if ( strKey == " addrProxy " ) ssValue >> addrProxy ; if ( fHaveUPnP && strKey == " fUseUPnP " ) ssValue >> fUseUPnP ; } } pcursor -> close ( ) ; } BOOST_FOREACH ( uint256 hash , vWalletUpgrade ) WriteTx ( hash , pwallet -> mapWallet [ hash ] ) ; printf ( " nFileVersion ▁ = ▁ % d \n " , nFileVersion ) ; printf ( " fGenerateBitcoins ▁ = ▁ % d \n " , fGenerateBitcoins ) ; printf ( " nTransactionFee ▁ = ▁ % " PRI64d " \n " , nTransactionFee ) ; printf ( " addrIncoming ▁ = ▁ % s \n " , addrIncoming . ToString ( ) . c_str ( ) ) ; printf ( " fMinimizeToTray ▁ = ▁ % d \n " , fMinimizeToTray ) ; printf ( " fMinimizeOnClose ▁ = ▁ % d \n " , fMinimizeOnClose ) ; printf ( " fUseProxy ▁ = ▁ % d \n " , fUseProxy ) ; printf ( " addrProxy ▁ = ▁ % s \n " , addrProxy . ToString ( ) . c_str ( ) ) ; if ( fHaveUPnP ) printf ( " fUseUPnP ▁ = ▁ % d \n " , fUseUPnP ) ; if ( nFileVersion < VERSION ) { if ( nFileVersion <= 105 && ! pszSetDataDir [ 0 ] ) unlink ( " debug . log " ) ; WriteVersion ( VERSION ) ; } return true ; } void ThreadFlushWalletDB ( void * parg ) { const string & strFile = ( ( const string * ) parg ) [ 0 ] ; static bool fOneThread ; if ( fOneThread ) return ; fOneThread = true ; if ( mapArgs . count ( " - noflushwallet " ) ) return ; unsigned int nLastSeen = nWalletDBUpdated ; unsigned int nLastFlushed = nWalletDBUpdated ; int64 nLastWalletUpdate = GetTime ( ) ; while ( ! fShutdown ) { Sleep ( 500 ) ; if ( nLastSeen != nWalletDBUpdated ) { nLastSeen = nWalletDBUpdated ; nLastWalletUpdate = GetTime ( ) ; } if ( nLastFlushed != nWalletDBUpdated && GetTime ( ) - nLastWalletUpdate >= 2 ) { TRY_CRITICAL_BLOCK ( cs_db ) { int nRefCount = 0 ; map < string , int > :: iterator mi = mapFileUseCount . begin ( ) ; while ( mi != mapFileUseCount . end ( ) ) { nRefCount += ( * mi ) . second ; mi ++ ; } if ( nRefCount == 0 && ! fShutdown ) { map < string , int > :: iterator mi = mapFileUseCount . find ( strFile ) ; if ( mi != mapFileUseCount . end ( ) ) { printf ( " % s ▁ " , DateTimeStrFormat ( " % x ▁ % H : % M : % S " , GetTime ( ) ) . c_str ( ) ) ; printf ( " Flushing ▁ wallet . dat \n " ) ; nLastFlushed = nWalletDBUpdated ; int64 nStart = GetTimeMillis ( ) ; CloseDb ( strFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; dbenv . lsn_reset ( strFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( mi ++ ) ; printf ( " Flushed ▁ wallet . dat ▁ % " PRI64d " ms \n " , GetTimeMillis ( ) - nStart ) ; } } } } } } bool BackupWallet ( const CWallet & wallet , const string & strDest ) { if ( ! wallet . fFileBacked ) return false ; while ( ! fShutdown ) { CRITICAL_BLOCK ( cs_db ) { if ( ! mapFileUseCount . count ( wallet . strWalletFile ) || mapFileUseCount [ wallet . strWalletFile ] == 0 ) { CloseDb ( wallet . strWalletFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; dbenv . lsn_reset ( wallet . strWalletFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( wallet . strWalletFile ) ; filesystem :: path pathSrc ( GetDataDir ( ) + " / " + wallet . strWalletFile ) ; filesystem :: path pathDest ( strDest ) ; if ( filesystem :: is_directory ( pathDest ) ) pathDest = pathDest / wallet . strWalletFile ; # if BOOST_VERSION >= 104000 filesystem :: copy_file ( pathSrc , pathDest , filesystem :: copy_option :: overwrite_if_exists ) ; # else filesystem :: copy_file ( pathSrc , pathDest ) ; # endif printf ( " copied ▁ wallet . dat ▁ to ▁ % s \n " , pathDest . string ( ) . c_str ( ) ) ; return true ; } } Sleep ( 100 ) ; } return false ; } </DOCUMENT>
<DOCUMENT_ID="station7/xbmc/tree/master/xbmc/platform/android/jni/System.cpp"> # include " System . h " # include " jutils / jutils - details . hpp " using namespace jni ; std :: string CJNISystem :: getProperty ( const std :: string & property ) { return jcast < std :: string > ( call_static_method < jhstring > ( " java / lang / System " , " getProperty " , " ( Ljava / lang / String ; ) Ljava / lang / String ; " , jcast < jhstring > ( property ) ) ) ; } std :: string CJNISystem :: getProperty ( const std :: string & property , const std :: string & defaultValue ) { return jcast < std :: string > ( call_static_method < jhstring > ( " java / lang / System " , " getProperty " , " ( Ljava / lang / String ; Ljava / lang / String ; ) Ljava / lang / String ; " , jcast < jhstring > ( property ) , jcast < jhstring > ( defaultValue ) ) ) ; } std :: string CJNISystem :: setProperty ( const std :: string & property , const std :: string & defaultValue ) { return jcast < std :: string > ( call_static_method < jhstring > ( " java / lang / System " , " setProperty " , " ( Ljava / lang / String ; Ljava / lang / String ; ) Ljava / lang / String ; " , jcast < jhstring > ( property ) , jcast < jhstring > ( defaultValue ) ) ) ; } std :: string CJNISystem :: clearProperty ( const std :: string & property ) { return jcast < std :: string > ( call_static_method < jhstring > ( " java / lang / System " , " clearProperty " , " ( Ljava / lang / String ; ) Ljava / lang / String ; " , jcast < jhstring > ( property ) ) ) ; } int64_t CJNISystem :: nanoTime ( ) { return call_static_method < jlong > ( " java / lang / System " , " nanoTime " , " ( ) J " ) ; } </DOCUMENT>
<DOCUMENT_ID="regneq/TrinityCore/tree/master/src/server/game/Miscellaneous/CommonPredicates.cpp"> # include " CommonPredicates . h " # include " Common . h " # include " Unit . h " # include " SharedDefines . h " Trinity :: Predicates :: IsVictimOf :: IsVictimOf ( Unit const * attacker ) : _victim ( attacker ? attacker -> GetVictim ( ) : nullptr ) { } </DOCUMENT>
<DOCUMENT_ID="kzhong1991/Flight-AR.Drone-2/tree/master/src/3rdparty/Qt4.8.4/src/3rdparty/webkit/Source/WebCore/platform/graphics/mac/GlyphPageTreeNodeMac.cpp"> # include " config . h " # include " GlyphPageTreeNode . h " # include " Font . h " # include " SimpleFontData . h " # include " WebCoreSystemInterface . h " # include < ApplicationServices / ApplicationServices . h > namespace WebCore { static bool shouldUseCoreText ( UChar * buffer , unsigned bufferLength , const SimpleFontData * fontData ) { if ( fontData -> platformData ( ) . widthVariant ( ) != RegularWidth || fontData -> hasVerticalGlyphs ( ) ) { for ( unsigned i = 0 ; i < bufferLength ; ++ i ) { if ( ! Font :: isCJKIdeograph ( buffer [ i ] ) ) return true ; } } return false ; } bool GlyphPage :: fill ( unsigned offset , unsigned length , UChar * buffer , unsigned bufferLength , const SimpleFontData * fontData ) { bool haveGlyphs = false ; if ( ! shouldUseCoreText ( buffer , bufferLength , fontData ) ) { Vector < CGGlyph , 512 > glyphs ( bufferLength ) ; wkGetGlyphsForCharacters ( fontData -> platformData ( ) . cgFont ( ) , buffer , glyphs . data ( ) , bufferLength ) ; for ( unsigned i = 0 ; i < length ; ++ i ) { if ( ! glyphs [ i ] ) setGlyphDataForIndex ( offset + i , 0 , 0 ) ; else { setGlyphDataForIndex ( offset + i , glyphs [ i ] , fontData ) ; haveGlyphs = true ; } } } else { RetainPtr < CFStringRef > string ( AdoptCF , CFStringCreateWithCharactersNoCopy ( kCFAllocatorDefault , buffer , bufferLength , kCFAllocatorNull ) ) ; RetainPtr < CFAttributedStringRef > attributedString ( AdoptCF , CFAttributedStringCreate ( kCFAllocatorDefault , string . get ( ) , fontData -> getCFStringAttributes ( 0 , fontData -> hasVerticalGlyphs ( ) ? Vertical : Horizontal ) ) ) ; RetainPtr < CTLineRef > line ( AdoptCF , CTLineCreateWithAttributedString ( attributedString . get ( ) ) ) ; CFArrayRef runArray = CTLineGetGlyphRuns ( line . get ( ) ) ; CFIndex runCount = CFArrayGetCount ( runArray ) ; for ( unsigned index = 0 ; index < length ; ++ index ) setGlyphDataForIndex ( offset + index , 0 , 0 ) ; Vector < CGGlyph , 512 > glyphVector ; Vector < CFIndex , 512 > indexVector ; bool done = false ; RetainPtr < CGFontRef > cgFont ( AdoptCF , CTFontCopyGraphicsFont ( fontData -> platformData ( ) . ctFont ( ) , 0 ) ) ; for ( CFIndex r = 0 ; r < runCount && ! done ; ++ r ) { CTRunRef ctRun = static_cast < CTRunRef > ( CFArrayGetValueAtIndex ( runArray , r ) ) ; ASSERT ( CFGetTypeID ( ctRun ) == CTRunGetTypeID ( ) ) ; CFDictionaryRef attributes = CTRunGetAttributes ( ctRun ) ; CTFontRef runFont = static_cast < CTFontRef > ( CFDictionaryGetValue ( attributes , kCTFontAttributeName ) ) ; RetainPtr < CGFontRef > runCGFont ( AdoptCF , CTFontCopyGraphicsFont ( runFont , 0 ) ) ; if ( CFEqual ( cgFont . get ( ) , runCGFont . get ( ) ) ) { CFIndex glyphCount = CTRunGetGlyphCount ( ctRun ) ; const CGGlyph * glyphs = CTRunGetGlyphsPtr ( ctRun ) ; if ( ! glyphs ) { glyphVector . resize ( glyphCount ) ; CTRunGetGlyphs ( ctRun , CFRangeMake ( 0 , 0 ) , glyphVector . data ( ) ) ; glyphs = glyphVector . data ( ) ; } const CFIndex * stringIndices = CTRunGetStringIndicesPtr ( ctRun ) ; if ( ! stringIndices ) { indexVector . resize ( glyphCount ) ; CTRunGetStringIndices ( ctRun , CFRangeMake ( 0 , 0 ) , indexVector . data ( ) ) ; stringIndices = indexVector . data ( ) ; } for ( CFIndex i = 0 ; i < glyphCount ; ++ i ) { if ( stringIndices [ i ] >= static_cast < CFIndex > ( length ) ) { done = true ; break ; } if ( glyphs [ i ] ) { setGlyphDataForIndex ( offset + stringIndices [ i ] , glyphs [ i ] , fontData ) ; haveGlyphs = true ; } } } } } return haveGlyphs ; } } </DOCUMENT>
<DOCUMENT_ID="grzegorz2047/HotelReservation/tree/master/fileio.cpp"> # include < stdio . h > # include < string > # include < stdlib . h > # include < time . h > # include < sstream > # include < fstream > # include < vector > # include < iostream > std :: vector < std :: string > readFile ( std :: string filename ) { std :: vector < std :: string > lines ; std :: ifstream read ; std :: string line ; read . open ( filename . c_str ( ) ) ; if ( ! read . good ( ) ) { read . close ( ) ; std :: ofstream create ; create . open ( filename . c_str ( ) ) ; return lines ; } while ( ! read . eof ( ) ) { getline ( read , line ) ; if ( line != " " ) { lines . push_back ( line ) ; } } read . close ( ) ; return lines ; } void saveFile ( std :: string filename , std :: vector < std :: string > lines ) { std :: ofstream save ; save . open ( filename . c_str ( ) ) ; for ( int i = 0 ; i < lines . size ( ) ; i ++ ) { save << lines [ i ] << std :: endl ; } save . close ( ) ; } </DOCUMENT>
<DOCUMENT_ID="pcarrier-packaging/deb-phantomjs/tree/master/src/qt/src/3rdparty/webkit/Source/WebCore/generated/JSSVGPathSegLinetoHorizontalRel.cpp"> # include " config . h " # if ENABLE ( SVG ) # include " JSSVGPathSegLinetoHorizontalRel . h " # include " SVGPathSegLinetoHorizontal . h " # include < runtime / Error . h > # include < wtf / GetPtr . h > using namespace JSC ; namespace WebCore { ASSERT_CLASS_FITS_IN_CELL ( JSSVGPathSegLinetoHorizontalRel ) ; # if ENABLE ( JIT ) # define THUNK_GENERATOR ( generator ) , generator # else # define THUNK_GENERATOR ( generator ) # endif static const HashTableValue JSSVGPathSegLinetoHorizontalRelTableValues [ 3 ] = { { " x " , DontDelete , ( intptr_t ) static_cast < PropertySlot :: GetValueFunc > ( jsSVGPathSegLinetoHorizontalRelX ) , ( intptr_t ) setJSSVGPathSegLinetoHorizontalRelX THUNK_GENERATOR ( 0 ) } , { " constructor " , DontEnum | ReadOnly , ( intptr_t ) static_cast < PropertySlot :: GetValueFunc > ( jsSVGPathSegLinetoHorizontalRelConstructor ) , ( intptr_t ) 0 THUNK_GENERATOR ( 0 ) } , { 0 , 0 , 0 , 0 THUNK_GENERATOR ( 0 ) } } ; # undef THUNK_GENERATOR static JSC_CONST_HASHTABLE HashTable JSSVGPathSegLinetoHorizontalRelTable = { 5 , 3 , JSSVGPathSegLinetoHorizontalRelTableValues , 0 } ; # if ENABLE ( JIT ) # define THUNK_GENERATOR ( generator ) , generator # else # define THUNK_GENERATOR ( generator ) # endif static const HashTableValue JSSVGPathSegLinetoHorizontalRelConstructorTableValues [ 1 ] = { { 0 , 0 , 0 , 0 THUNK_GENERATOR ( 0 ) } } ; # undef THUNK_GENERATOR static JSC_CONST_HASHTABLE HashTable JSSVGPathSegLinetoHorizontalRelConstructorTable = { 1 , 0 , JSSVGPathSegLinetoHorizontalRelConstructorTableValues , 0 } ; class JSSVGPathSegLinetoHorizontalRelConstructor : public DOMConstructorObject { public : JSSVGPathSegLinetoHorizontalRelConstructor ( JSC :: ExecState * , JSC :: Structure * , JSDOMGlobalObject * ) ; virtual bool getOwnPropertySlot ( JSC :: ExecState * , const JSC :: Identifier & , JSC :: PropertySlot & ) ; virtual bool getOwnPropertyDescriptor ( JSC :: ExecState * , const JSC :: Identifier & , JSC :: PropertyDescriptor & ) ; static const JSC :: ClassInfo s_info ; static JSC :: Structure * createStructure ( JSC :: JSGlobalData & globalData , JSC :: JSValue prototype ) { return JSC :: Structure :: create ( globalData , prototype , JSC :: TypeInfo ( JSC :: ObjectType , StructureFlags ) , AnonymousSlotCount , & s_info ) ; } protected : static const unsigned StructureFlags = JSC :: OverridesGetOwnPropertySlot | JSC :: ImplementsHasInstance | DOMConstructorObject :: StructureFlags ; } ; const ClassInfo JSSVGPathSegLinetoHorizontalRelConstructor :: s_info = { " SVGPathSegLinetoHorizontalRelConstructor " , & DOMConstructorObject :: s_info , & JSSVGPathSegLinetoHorizontalRelConstructorTable , 0 } ; JSSVGPathSegLinetoHorizontalRelConstructor :: JSSVGPathSegLinetoHorizontalRelConstructor ( ExecState * exec , Structure * structure , JSDOMGlobalObject * globalObject ) : DOMConstructorObject ( structure , globalObject ) { ASSERT ( inherits ( & s_info ) ) ; putDirect ( exec -> globalData ( ) , exec -> propertyNames ( ) . prototype , JSSVGPathSegLinetoHorizontalRelPrototype :: self ( exec , globalObject ) , DontDelete | ReadOnly ) ; } bool JSSVGPathSegLinetoHorizontalRelConstructor :: getOwnPropertySlot ( ExecState * exec , const Identifier & propertyName , PropertySlot & slot ) { return getStaticValueSlot < JSSVGPathSegLinetoHorizontalRelConstructor , JSDOMWrapper > ( exec , & JSSVGPathSegLinetoHorizontalRelConstructorTable , this , propertyName , slot ) ; } bool JSSVGPathSegLinetoHorizontalRelConstructor :: getOwnPropertyDescriptor ( ExecState * exec , const Identifier & propertyName , PropertyDescriptor & descriptor ) { return getStaticValueDescriptor < JSSVGPathSegLinetoHorizontalRelConstructor , JSDOMWrapper > ( exec , & JSSVGPathSegLinetoHorizontalRelConstructorTable , this , propertyName , descriptor ) ; } # if ENABLE ( JIT ) # define THUNK_GENERATOR ( generator ) , generator # else # define THUNK_GENERATOR ( generator ) # endif static const HashTableValue JSSVGPathSegLinetoHorizontalRelPrototypeTableValues [ 1 ] = { { 0 , 0 , 0 , 0 THUNK_GENERATOR ( 0 ) } } ; # undef THUNK_GENERATOR static JSC_CONST_HASHTABLE HashTable JSSVGPathSegLinetoHorizontalRelPrototypeTable = { 1 , 0 , JSSVGPathSegLinetoHorizontalRelPrototypeTableValues , 0 } ; const ClassInfo JSSVGPathSegLinetoHorizontalRelPrototype :: s_info = { " SVGPathSegLinetoHorizontalRelPrototype " , & JSC :: JSObjectWithGlobalObject :: s_info , & JSSVGPathSegLinetoHorizontalRelPrototypeTable , 0 } ; JSObject * JSSVGPathSegLinetoHorizontalRelPrototype :: self ( ExecState * exec , JSGlobalObject * globalObject ) { return getDOMPrototype < JSSVGPathSegLinetoHorizontalRel > ( exec , globalObject ) ; } const ClassInfo JSSVGPathSegLinetoHorizontalRel :: s_info = { " SVGPathSegLinetoHorizontalRel " , & JSSVGPathSeg :: s_info , & JSSVGPathSegLinetoHorizontalRelTable , 0 } ; JSSVGPathSegLinetoHorizontalRel :: JSSVGPathSegLinetoHorizontalRel ( Structure * structure , JSDOMGlobalObject * globalObject , PassRefPtr < SVGPathSegLinetoHorizontalRel > impl ) : JSSVGPathSeg ( structure , globalObject , impl ) { ASSERT ( inherits ( & s_info ) ) ; } JSObject * JSSVGPathSegLinetoHorizontalRel :: createPrototype ( ExecState * exec , JSGlobalObject * globalObject ) { return new ( exec ) JSSVGPathSegLinetoHorizontalRelPrototype ( exec -> globalData ( ) , globalObject , JSSVGPathSegLinetoHorizontalRelPrototype :: createStructure ( exec -> globalData ( ) , JSSVGPathSegPrototype :: self ( exec , globalObject ) ) ) ; } bool JSSVGPathSegLinetoHorizontalRel :: getOwnPropertySlot ( ExecState * exec , const Identifier & propertyName , PropertySlot & slot ) { return getStaticValueSlot < JSSVGPathSegLinetoHorizontalRel , Base > ( exec , & JSSVGPathSegLinetoHorizontalRelTable , this , propertyName , slot ) ; } bool JSSVGPathSegLinetoHorizontalRel :: getOwnPropertyDescriptor ( ExecState * exec , const Identifier & propertyName , PropertyDescriptor & descriptor ) { return getStaticValueDescriptor < JSSVGPathSegLinetoHorizontalRel , Base > ( exec , & JSSVGPathSegLinetoHorizontalRelTable , this , propertyName , descriptor ) ; } JSValue jsSVGPathSegLinetoHorizontalRelX ( ExecState * exec , JSValue slotBase , const Identifier & ) { JSSVGPathSegLinetoHorizontalRel * castedThis = static_cast < JSSVGPathSegLinetoHorizontalRel * > ( asObject ( slotBase ) ) ; UNUSED_PARAM ( exec ) ; SVGPathSegLinetoHorizontalRel * imp = static_cast < SVGPathSegLinetoHorizontalRel * > ( castedThis -> impl ( ) ) ; JSValue result = jsNumber ( imp -> x ( ) ) ; return result ; } JSValue jsSVGPathSegLinetoHorizontalRelConstructor ( ExecState * exec , JSValue slotBase , const Identifier & ) { JSSVGPathSegLinetoHorizontalRel * domObject = static_cast < JSSVGPathSegLinetoHorizontalRel * > ( asObject ( slotBase ) ) ; return JSSVGPathSegLinetoHorizontalRel :: getConstructor ( exec , domObject -> globalObject ( ) ) ; } void JSSVGPathSegLinetoHorizontalRel :: put ( ExecState * exec , const Identifier & propertyName , JSValue value , PutPropertySlot & slot ) { lookupPut < JSSVGPathSegLinetoHorizontalRel , Base > ( exec , propertyName , value , & JSSVGPathSegLinetoHorizontalRelTable , this , slot ) ; } void setJSSVGPathSegLinetoHorizontalRelX ( ExecState * exec , JSObject * thisObject , JSValue value ) { JSSVGPathSegLinetoHorizontalRel * castedThis = static_cast < JSSVGPathSegLinetoHorizontalRel * > ( thisObject ) ; SVGPathSegLinetoHorizontalRel * imp = static_cast < SVGPathSegLinetoHorizontalRel * > ( castedThis -> impl ( ) ) ; imp -> setX ( value . toFloat ( exec ) ) ; } JSValue JSSVGPathSegLinetoHorizontalRel :: getConstructor ( ExecState * exec , JSGlobalObject * globalObject ) { return getDOMConstructor < JSSVGPathSegLinetoHorizontalRelConstructor > ( exec , static_cast < JSDOMGlobalObject * > ( globalObject ) ) ; } } # endif </DOCUMENT>
<DOCUMENT_ID="verybadsoldier/xbmc/tree/master/xbmc/visualizations/Vortex/angelscript/angelscript/source/as_scriptengine.cpp"> # include < stdlib . h > # include " as _ config . h " # include " as _ scriptengine . h " # include " as _ builder . h " # include " as _ context . h " # include " as _ string _ util . h " # include " as _ tokenizer . h " # include " as _ texts . h " # include " as _ module . h " # include " as _ callfunc . h " # include " as _ arrayobject . h " # include " as _ generic . h " # include " as _ scriptobject . h " # include " as _ compiler . h " BEGIN_AS_NAMESPACE extern " C " { AS_API const char * asGetLibraryVersion ( ) { # ifdef _DEBUG return ANGELSCRIPT_VERSION_STRING " ▁ DEBUG " ; # else return ANGELSCRIPT_VERSION_STRING ; # endif } AS_API const char * asGetLibraryOptions ( ) { const char * string = " ▁ " # ifdef AS_MAX_PORTABILITY " AS _ MAX _ PORTABILITY ▁ " # endif # ifdef AS_DEBUG " AS _ DEBUG ▁ " # endif # ifdef AS_NO_CLASS_METHODS " AS _ NO _ CLASS _ METHODS ▁ " # endif # ifdef AS_USE_DOUBLE_AS_FLOAT " AS _ USE _ DOUBLE _ AS _ FLOAT ▁ " # endif # ifdef AS_64BIT_PTR " AS _ 64BIT _ PTR ▁ " # endif # ifdef AS_NO_THREADS " AS _ NO _ THREADS ▁ " # endif # ifdef AS_NO_ATOMIC " AS _ NO _ ATOMIC ▁ " # endif # ifdef AS_WIN " AS _ WIN ▁ " # endif # ifdef AS_LINUX " AS _ LINUX ▁ " # endif # ifdef AS_MAC " AS _ MAC ▁ " # endif # ifdef AS_BSD " AS _ BSD ▁ " # endif # ifdef AS_XBOX " AS _ XBOX ▁ " # endif # ifdef AS_XBOX360 " AS _ XBOX360 ▁ " # endif # ifdef AS_PSP " AS _ PSP ▁ " # endif # ifdef AS_PS2 " AS _ PS2 ▁ " # endif # ifdef AS_PS3 " AS _ PS3 ▁ " # endif # ifdef AS_DC " AS _ DC ▁ " # endif # ifdef AS_GC " AS _ GC ▁ " # endif # ifdef AS_WII " AS _ WII ▁ " # endif # ifdef AS_IPHONE " AS _ IPHONE ▁ " # endif # ifdef AS_ANDROID " AS _ ANDROID ▁ " # endif # ifdef AS_PPC " AS _ PPC ▁ " # endif # ifdef AS_PPC_64 " AS _ PPC _ 64 ▁ " # endif # ifdef AS_X86 " AS _ X86 ▁ " # endif # ifdef AS_MIPS " AS _ MIPS ▁ " # endif # ifdef AS_SH4 " AS _ SH4 ▁ " # endif # ifdef AS_XENON " AS _ XENON ▁ " # endif # ifdef AS_ARM " AS _ ARM ▁ " # endif ; return string ; } AS_API asIScriptEngine * asCreateScriptEngine ( asDWORD version ) { if ( ( version / 10000 ) != ( ANGELSCRIPT_VERSION / 10000 ) ) return 0 ; if ( ( version / 100 ) % 100 != ( ANGELSCRIPT_VERSION / 100 ) % 100 ) return 0 ; if ( ( version % 100 ) > ( ANGELSCRIPT_VERSION % 100 ) ) return 0 ; asASSERT ( sizeof ( asBYTE ) == 1 ) ; asASSERT ( sizeof ( asWORD ) == 2 ) ; asASSERT ( sizeof ( asDWORD ) == 4 ) ; asASSERT ( sizeof ( asQWORD ) == 8 ) ; asASSERT ( sizeof ( asPWORD ) == sizeof ( void * ) ) ; asASSERT ( sizeof ( bool ) == AS_SIZEOF_BOOL ) ; asASSERT ( true == VALUE_OF_BOOLEAN_TRUE ) ; # ifdef AS_BIG_ENDIAN asASSERT ( * ( asDWORD * ) " \x00\x01\x02\x03" == 0x00010203 ) ; asASSERT ( * ( asQWORD * ) " \x00\x01\x02\x03\x04\x05\x06\x07" == I64 ( 0x0001020304050607 ) ) ; # else asASSERT ( * ( asDWORD * ) " \x00\x01\x02\x03" == 0x03020100 ) ; asASSERT ( * ( asQWORD * ) " \x00\x01\x02\x03\x04\x05\x06\x07" == I64 ( 0x0706050403020100 ) ) ; # endif return asNEW ( asCScriptEngine ) ( ) ; } int asCScriptEngine :: SetEngineProperty ( asEEngineProp property , asPWORD value ) { switch ( property ) { case asEP_ALLOW_UNSAFE_REFERENCES : ep . allowUnsafeReferences = value ? true : false ; break ; case asEP_OPTIMIZE_BYTECODE : ep . optimizeByteCode = value ? true : false ; break ; case asEP_COPY_SCRIPT_SECTIONS : ep . copyScriptSections = value ? true : false ; break ; case asEP_MAX_STACK_SIZE : ep . maximumContextStackSize = ( int ) value / 4 ; if ( initialContextStackSize > ep . maximumContextStackSize ) initialContextStackSize = ep . maximumContextStackSize ; break ; case asEP_USE_CHARACTER_LITERALS : ep . useCharacterLiterals = value ? true : false ; break ; case asEP_ALLOW_MULTILINE_STRINGS : ep . allowMultilineStrings = value ? true : false ; break ; case asEP_ALLOW_IMPLICIT_HANDLE_TYPES : ep . allowImplicitHandleTypes = value ? true : false ; break ; case asEP_BUILD_WITHOUT_LINE_CUES : ep . buildWithoutLineCues = value ? true : false ; break ; case asEP_INIT_GLOBAL_VARS_AFTER_BUILD : ep . initGlobalVarsAfterBuild = value ? true : false ; break ; case asEP_REQUIRE_ENUM_SCOPE : ep . requireEnumScope = value ? true : false ; break ; case asEP_SCRIPT_SCANNER : if ( value <= 1 ) ep . scanner = ( int ) value ; else return asINVALID_ARG ; break ; case asEP_INCLUDE_JIT_INSTRUCTIONS : ep . includeJitInstructions = value ? true : false ; break ; case asEP_STRING_ENCODING : if ( value <= 1 ) ep . stringEncoding = ( int ) value ; else return asINVALID_ARG ; break ; default : return asINVALID_ARG ; } return asSUCCESS ; } asPWORD asCScriptEngine :: GetEngineProperty ( asEEngineProp property ) { switch ( property ) { case asEP_ALLOW_UNSAFE_REFERENCES : return ep . allowUnsafeReferences ; case asEP_OPTIMIZE_BYTECODE : return ep . optimizeByteCode ; case asEP_COPY_SCRIPT_SECTIONS : return ep . copyScriptSections ; case asEP_MAX_STACK_SIZE : return ep . maximumContextStackSize * 4 ; case asEP_USE_CHARACTER_LITERALS : return ep . useCharacterLiterals ; case asEP_ALLOW_MULTILINE_STRINGS : return ep . allowMultilineStrings ; case asEP_ALLOW_IMPLICIT_HANDLE_TYPES : return ep . allowImplicitHandleTypes ; case asEP_BUILD_WITHOUT_LINE_CUES : return ep . buildWithoutLineCues ; case asEP_INIT_GLOBAL_VARS_AFTER_BUILD : return ep . initGlobalVarsAfterBuild ; case asEP_REQUIRE_ENUM_SCOPE : return ep . requireEnumScope ; case asEP_SCRIPT_SCANNER : return ep . scanner ; case asEP_INCLUDE_JIT_INSTRUCTIONS : return ep . includeJitInstructions ; case asEP_STRING_ENCODING : return ep . stringEncoding ; } return 0 ; } } asCScriptEngine :: asCScriptEngine ( ) { if ( threadManager == 0 ) threadManager = asNEW ( asCThreadManager ) ; else threadManager -> AddRef ( ) ; ep . allowUnsafeReferences = false ; ep . optimizeByteCode = true ; ep . copyScriptSections = true ; ep . maximumContextStackSize = 0 ; ep . useCharacterLiterals = false ; ep . allowMultilineStrings = false ; ep . allowImplicitHandleTypes = false ; ep . buildWithoutLineCues = false ; ep . initGlobalVarsAfterBuild = true ; ep . requireEnumScope = false ; ep . scanner = 1 ; ep . includeJitInstructions = false ; ep . stringEncoding = 0 ; gc . engine = this ; refCount . set ( 1 ) ; stringFactory = 0 ; configFailed = false ; isPrepared = false ; isBuilding = false ; lastModule = 0 ; userData = 0 ; initialContextStackSize = 1024 ; typeIdSeqNbr = 0 ; currentGroup = & defaultGroup ; msgCallback = 0 ; jitCompiler = 0 ; scriptFunctions . PushLast ( 0 ) ; int id ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttVoid , false ) ) ; asASSERT ( id == asTYPEID_VOID ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttBool , false ) ) ; asASSERT ( id == asTYPEID_BOOL ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt8 , false ) ) ; asASSERT ( id == asTYPEID_INT8 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt16 , false ) ) ; asASSERT ( id == asTYPEID_INT16 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt , false ) ) ; asASSERT ( id == asTYPEID_INT32 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt64 , false ) ) ; asASSERT ( id == asTYPEID_INT64 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt8 , false ) ) ; asASSERT ( id == asTYPEID_UINT8 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt16 , false ) ) ; asASSERT ( id == asTYPEID_UINT16 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt , false ) ) ; asASSERT ( id == asTYPEID_UINT32 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt64 , false ) ) ; asASSERT ( id == asTYPEID_UINT64 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttFloat , false ) ) ; asASSERT ( id == asTYPEID_FLOAT ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttDouble , false ) ) ; asASSERT ( id == asTYPEID_DOUBLE ) ; defaultArrayObjectType = 0 ; RegisterArrayObject ( this ) ; RegisterScriptObject ( this ) ; RegisterScriptFunction ( this ) ; RegisterObjectTypeGCBehaviours ( this ) ; } asCScriptEngine :: ~ asCScriptEngine ( ) { asASSERT ( refCount . get ( ) == 0 ) ; asUINT n ; for ( n = ( asUINT ) scriptModules . GetLength ( ) ; n -- > 0 ; ) { if ( scriptModules [ n ] ) { asDELETE ( scriptModules [ n ] , asCModule ) ; } } scriptModules . SetLength ( 0 ) ; GarbageCollect ( asGC_FULL_CYCLE ) ; for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] ) { asUINT f ; for ( f = 0 ; f < templateTypes [ n ] -> beh . factories . GetLength ( ) ; f ++ ) { scriptFunctions [ templateTypes [ n ] -> beh . factories [ f ] ] -> Release ( ) ; } templateTypes [ n ] -> beh . factories . Allocate ( 0 , false ) ; for ( f = 1 ; f < templateTypes [ n ] -> beh . operators . GetLength ( ) ; f += 2 ) { if ( scriptFunctions [ templateTypes [ n ] -> beh . operators [ f ] ] -> objectType == templateTypes [ n ] ) { scriptFunctions [ templateTypes [ n ] -> beh . operators [ f ] ] -> Release ( ) ; templateTypes [ n ] -> beh . operators [ f ] = 0 ; } } } } GarbageCollect ( asGC_FULL_CYCLE ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; for ( n = 0 ; n < classTypes . GetLength ( ) ; n ++ ) { if ( classTypes [ n ] ) classTypes [ n ] -> ReleaseAllFunctions ( ) ; if ( classTypes [ n ] -> derivedFrom ) { classTypes [ n ] -> derivedFrom -> Release ( ) ; classTypes [ n ] -> derivedFrom = 0 ; } } GarbageCollect ( asGC_FULL_CYCLE ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; asSMapNode < int , asCDataType * > * cursor = 0 ; while ( mapTypeIdToDataType . MoveFirst ( & cursor ) ) { asDELETE ( mapTypeIdToDataType . GetValue ( cursor ) , asCDataType ) ; mapTypeIdToDataType . Erase ( cursor ) ; } defaultGroup . RemoveConfiguration ( this ) ; while ( configGroups . GetLength ( ) ) { asCConfigGroup * grp = configGroups . PopLast ( ) ; if ( grp ) { asDELETE ( grp , asCConfigGroup ) ; } } for ( n = 0 ; n < registeredGlobalProps . GetLength ( ) ; n ++ ) { if ( registeredGlobalProps [ n ] ) { asDELETE ( registeredGlobalProps [ n ] , asCGlobalProperty ) ; } } registeredGlobalProps . SetLength ( 0 ) ; FreeUnusedGlobalProperties ( ) ; for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] ) { templateTypes [ n ] -> templateSubType = asCDataType :: CreateNullHandle ( ) ; asDELETE ( templateTypes [ n ] , asCObjectType ) ; } } templateTypes . SetLength ( 0 ) ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] ) { objectTypes [ n ] -> templateSubType = asCDataType :: CreateNullHandle ( ) ; asDELETE ( objectTypes [ n ] , asCObjectType ) ; } } objectTypes . SetLength ( 0 ) ; for ( n = 0 ; n < templateSubTypes . GetLength ( ) ; n ++ ) { if ( templateSubTypes [ n ] ) { asDELETE ( templateSubTypes [ n ] , asCObjectType ) ; } } templateSubTypes . SetLength ( 0 ) ; registeredTypeDefs . SetLength ( 0 ) ; registeredEnums . SetLength ( 0 ) ; registeredObjTypes . SetLength ( 0 ) ; for ( n = 0 ; n < registeredGlobalFuncs . GetLength ( ) ; n ++ ) { if ( registeredGlobalFuncs [ n ] ) registeredGlobalFuncs [ n ] -> Release ( ) ; } registeredGlobalFuncs . SetLength ( 0 ) ; scriptTypeBehaviours . ReleaseAllFunctions ( ) ; functionBehaviours . ReleaseAllFunctions ( ) ; objectTypeBehaviours . ReleaseAllFunctions ( ) ; for ( n = 0 ; n < stringConstants . GetLength ( ) ; n ++ ) { asDELETE ( stringConstants [ n ] , asCString ) ; } stringConstants . SetLength ( 0 ) ; for ( n = 0 ; n < scriptSectionNames . GetLength ( ) ; n ++ ) { asDELETE ( scriptSectionNames [ n ] , asCString ) ; } scriptSectionNames . SetLength ( 0 ) ; threadManager -> Release ( ) ; } int asCScriptEngine :: AddRef ( ) { return refCount . atomicInc ( ) ; } int asCScriptEngine :: Release ( ) { int r = refCount . atomicDec ( ) ; if ( r == 0 ) { asDELETE ( this , asCScriptEngine ) ; return 0 ; } return r ; } void * asCScriptEngine :: SetUserData ( void * data ) { void * old = userData ; userData = data ; return old ; } void * asCScriptEngine :: GetUserData ( ) { return userData ; } int asCScriptEngine :: SetMessageCallback ( const asSFuncPtr & callback , void * obj , asDWORD callConv ) { msgCallback = true ; msgCallbackObj = obj ; bool isObj = false ; if ( ( unsigned ) callConv == asCALL_GENERIC ) { msgCallback = false ; return asNOT_SUPPORTED ; } if ( ( unsigned ) callConv >= asCALL_THISCALL ) { isObj = true ; if ( obj == 0 ) { msgCallback = false ; return asINVALID_ARG ; } } int r = DetectCallingConvention ( isObj , callback , callConv , & msgCallbackFunc ) ; if ( r < 0 ) msgCallback = false ; return r ; } int asCScriptEngine :: ClearMessageCallback ( ) { msgCallback = false ; return 0 ; } int asCScriptEngine :: WriteMessage ( const char * section , int row , int col , asEMsgType type , const char * message ) { if ( section == 0 || message == 0 ) return asINVALID_ARG ; if ( ! msgCallback ) return 0 ; asSMessageInfo msg ; msg . section = section ; msg . row = row ; msg . col = col ; msg . type = type ; msg . message = message ; if ( msgCallbackFunc . callConv < ICC_THISCALL ) CallGlobalFunction ( & msg , msgCallbackObj , & msgCallbackFunc , 0 ) ; else CallObjectMethod ( msgCallbackObj , & msg , & msgCallbackFunc , 0 ) ; return 0 ; } int asCScriptEngine :: SetJITCompiler ( asIJITCompiler * compiler ) { jitCompiler = compiler ; return asSUCCESS ; } asIJITCompiler * asCScriptEngine :: GetJITCompiler ( ) { return jitCompiler ; } asETokenClass asCScriptEngine :: ParseToken ( const char * string , size_t stringLength , int * tokenLength ) { if ( stringLength == 0 ) stringLength = strlen ( string ) ; size_t len ; asCTokenizer t ; asETokenClass tc ; t . GetToken ( string , stringLength , & len , & tc ) ; if ( tokenLength ) * tokenLength = ( int ) len ; return tc ; } asIScriptModule * asCScriptEngine :: GetModule ( const char * module , asEGMFlags flag ) { asCModule * mod = GetModule ( module , false ) ; if ( flag == asGM_ALWAYS_CREATE ) { if ( mod != 0 ) { asDELETE ( mod , asCModule ) ; } return GetModule ( module , true ) ; } if ( mod == 0 && flag == asGM_CREATE_IF_NOT_EXISTS ) { return GetModule ( module , true ) ; } return mod ; } int asCScriptEngine :: DiscardModule ( const char * module ) { asCModule * mod = GetModule ( module , false ) ; if ( mod == 0 ) return asNO_MODULE ; asDELETE ( mod , asCModule ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; return 0 ; } void asCScriptEngine :: ClearUnusedTypes ( ) { asCArray < asCObjectType * > types ; types = classTypes ; types . Concatenate ( templateInstanceTypes ) ; asUINT n ; for ( n = 0 ; n < scriptModules . GetLength ( ) && types . GetLength ( ) ; n ++ ) { asCModule * mod = scriptModules [ n ] ; if ( mod ) { asUINT m ; for ( m = 0 ; m < mod -> classTypes . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> classTypes [ m ] ) ; for ( m = 0 ; m < mod -> enumTypes . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> enumTypes [ m ] ) ; for ( m = 0 ; m < mod -> typeDefs . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> typeDefs [ m ] ) ; } } for ( n = 0 ; n < scriptFunctions . GetLength ( ) && types . GetLength ( ) ; n ++ ) { asCScriptFunction * func = scriptFunctions [ n ] ; if ( func ) { if ( func -> name == " factstub " ) continue ; asCObjectType * ot = func -> returnType . GetObjectType ( ) ; if ( ot != 0 && ot != func -> objectType ) if ( func -> name != ot -> name ) RemoveTypeAndRelatedFromList ( types , ot ) ; for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { ot = func -> parameterTypes [ p ] . GetObjectType ( ) ; if ( ot != 0 && ot != func -> objectType ) if ( func -> name != ot -> name ) RemoveTypeAndRelatedFromList ( types , ot ) ; } } } for ( n = 0 ; n < globalProperties . GetLength ( ) && types . GetLength ( ) ; n ++ ) { if ( globalProperties [ n ] && globalProperties [ n ] -> type . GetObjectType ( ) ) RemoveTypeAndRelatedFromList ( types , globalProperties [ n ] -> type . GetObjectType ( ) ) ; } for ( ; ; ) { bool didClearTemplateInstanceType = false ; for ( n = 0 ; n < types . GetLength ( ) ; n ++ ) { int refCount = ( ( types [ n ] -> flags & asOBJ_TEMPLATE ) || ( types [ n ] -> flags & asOBJ_SCRIPT_OBJECT ) ) ? 2 * ( int ) types [ n ] -> beh . factories . GetLength ( ) : 0 ; if ( types [ n ] -> GetRefCount ( ) == refCount ) { if ( types [ n ] -> flags & asOBJ_TEMPLATE ) { didClearTemplateInstanceType = true ; RemoveTemplateInstanceType ( types [ n ] ) ; } else { RemoveFromTypeIdMap ( types [ n ] ) ; asDELETE ( types [ n ] , asCObjectType ) ; int i = classTypes . IndexOf ( types [ n ] ) ; if ( i == ( signed ) classTypes . GetLength ( ) - 1 ) classTypes . PopLast ( ) ; else classTypes [ i ] = classTypes . PopLast ( ) ; } if ( n < types . GetLength ( ) - 1 ) types [ n ] = types . PopLast ( ) ; else types . PopLast ( ) ; n -- ; } } if ( didClearTemplateInstanceType == false ) break ; } } void asCScriptEngine :: RemoveTypeAndRelatedFromList ( asCArray < asCObjectType * > & types , asCObjectType * ot ) { int i = types . IndexOf ( ot ) ; if ( i == - 1 ) return ; if ( i == ( signed ) types . GetLength ( ) - 1 ) types . PopLast ( ) ; else types [ i ] = types . PopLast ( ) ; if ( ot -> templateSubType . GetObjectType ( ) ) { while ( ot -> templateSubType . GetObjectType ( ) ) { ot = ot -> templateSubType . GetObjectType ( ) ; RemoveTypeAndRelatedFromList ( types , ot ) ; } return ; } if ( ot -> properties . GetLength ( ) ) { for ( asUINT n = 0 ; n < ot -> properties . GetLength ( ) ; n ++ ) RemoveTypeAndRelatedFromList ( types , ot -> properties [ n ] -> type . GetObjectType ( ) ) ; } } int asCScriptEngine :: GetFactoryIdByDecl ( const asCObjectType * ot , const char * decl ) { asCModule * mod = 0 ; if ( ot -> flags & asOBJ_SCRIPT_OBJECT && ot -> size > 0 ) mod = scriptFunctions [ ot -> beh . factory ] -> module ; asCBuilder bld ( this , mod ) ; asCScriptFunction func ( this , mod , - 1 ) ; int r = bld . ParseFunctionDeclaration ( 0 , decl , & func , false ) ; if ( r < 0 ) return asINVALID_DECLARATION ; int id = - 1 ; for ( size_t n = 0 ; n < ot -> beh . factories . GetLength ( ) ; n ++ ) { asCScriptFunction * f = scriptFunctions [ ot -> beh . factories [ n ] ] ; if ( f -> IsSignatureEqual ( & func ) ) { id = ot -> beh . factories [ n ] ; break ; } } if ( id == - 1 ) return asNO_FUNCTION ; return id ; } int asCScriptEngine :: GetMethodIdByDecl ( const asCObjectType * ot , const char * decl , asCModule * mod ) { asCBuilder bld ( this , mod ) ; asCScriptFunction func ( this , mod , - 1 ) ; int r = bld . ParseFunctionDeclaration ( 0 , decl , & func , false ) ; if ( r < 0 ) return asINVALID_DECLARATION ; func . objectType = const_cast < asCObjectType * > ( ot ) ; int id = - 1 ; for ( size_t n = 0 ; n < ot -> methods . GetLength ( ) ; ++ n ) { if ( func . IsSignatureEqual ( scriptFunctions [ ot -> methods [ n ] ] ) ) { if ( id == - 1 ) id = ot -> methods [ n ] ; else return asMULTIPLE_FUNCTIONS ; } } if ( id == - 1 ) return asNO_FUNCTION ; return id ; } asCString asCScriptEngine :: GetFunctionDeclaration ( int funcID ) { asCString str ; asCScriptFunction * func = GetScriptFunction ( funcID ) ; if ( func ) str = func -> GetDeclarationStr ( ) ; return str ; } asCScriptFunction * asCScriptEngine :: GetScriptFunction ( int funcId ) { if ( funcId < 0 || funcId >= ( int ) scriptFunctions . GetLength ( ) ) return 0 ; return scriptFunctions [ funcId ] ; } asIScriptContext * asCScriptEngine :: CreateContext ( ) { asIScriptContext * ctx = 0 ; CreateContext ( & ctx , false ) ; return ctx ; } int asCScriptEngine :: CreateContext ( asIScriptContext * * context , bool isInternal ) { * context = asNEW ( asCContext ) ( this , ! isInternal ) ; PrepareEngine ( ) ; return 0 ; } int asCScriptEngine :: RegisterObjectProperty ( const char * obj , const char * declaration , int byteOffset ) { int r ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; r = bld . ParseDataType ( obj , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( currentGroup -> FindType ( dt . GetObjectType ( ) -> name . AddressOf ( ) ) == 0 ) return ConfigError ( asWRONG_CONFIG_GROUP ) ; asCDataType type ; asCString name ; if ( ( r = bld . VerifyProperty ( & dt , declaration , name , type ) ) < 0 ) return ConfigError ( r ) ; if ( dt . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_OBJECT ) ; asCObjectProperty * prop = asNEW ( asCObjectProperty ) ; prop -> name = name ; prop -> type = type ; prop -> byteOffset = byteOffset ; dt . GetObjectType ( ) -> properties . PushLast ( prop ) ; currentGroup -> RefConfigGroup ( FindConfigGroupForObjectType ( type . GetObjectType ( ) ) ) ; return asSUCCESS ; } int asCScriptEngine :: RegisterInterface ( const char * name ) { if ( name == 0 ) return ConfigError ( asINVALID_NAME ) ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) return asALREADY_REGISTERED ; } asCDataType dt ; asCBuilder bld ( this , 0 ) ; bool oldMsgCallback = msgCallback ; msgCallback = false ; int r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; if ( r >= 0 ) return ConfigError ( asERROR ) ; asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , strlen ( name ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( name ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * st = asNEW ( asCObjectType ) ( this ) ; st -> flags = asOBJ_REF | asOBJ_SCRIPT_OBJECT ; st -> size = 0 ; st -> name = name ; st -> beh . factory = 0 ; st -> beh . addref = scriptTypeBehaviours . beh . addref ; scriptFunctions [ st -> beh . addref ] -> AddRef ( ) ; st -> beh . release = scriptTypeBehaviours . beh . release ; scriptFunctions [ st -> beh . release ] -> AddRef ( ) ; st -> beh . copy = 0 ; objectTypes . PushLast ( st ) ; registeredObjTypes . PushLast ( st ) ; currentGroup -> objTypes . PushLast ( st ) ; return asSUCCESS ; } int asCScriptEngine :: RegisterInterfaceMethod ( const char * intf , const char * declaration ) { if ( currentGroup -> FindType ( intf ) == 0 ) return ConfigError ( asWRONG_CONFIG_GROUP ) ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( intf , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_INTERFACE ) ; func -> objectType = dt . GetObjectType ( ) ; r = bld . ParseFunctionDeclaration ( func -> objectType , declaration , func , false ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } r = bld . CheckNameConflictMember ( dt , func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; func -> objectType -> methods . PushLast ( func -> id ) ; func -> ComputeSignatureId ( ) ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } return func -> id ; } int asCScriptEngine :: RegisterObjectType ( const char * name , int byteSize , asDWORD flags ) { int r ; isPrepared = false ; if ( flags & asOBJ_REF ) { if ( flags & ~ ( asOBJ_REF | asOBJ_GC | asOBJ_NOHANDLE | asOBJ_SCOPED | asOBJ_TEMPLATE ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_GC ) && ( flags & ( asOBJ_NOHANDLE | asOBJ_SCOPED ) ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_NOHANDLE ) && ( flags & ( asOBJ_GC | asOBJ_SCOPED ) ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_SCOPED ) && ( flags & ( asOBJ_GC | asOBJ_NOHANDLE ) ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_VALUE ) { if ( flags & ( asOBJ_REF | asOBJ_GC | asOBJ_SCOPED ) ) return ConfigError ( asINVALID_ARG ) ; if ( flags & asOBJ_APP_CLASS ) { if ( flags & ( asOBJ_APP_PRIMITIVE | asOBJ_APP_FLOAT ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_APP_PRIMITIVE ) { if ( flags & ( asOBJ_APP_CLASS | asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT | asOBJ_APP_FLOAT ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_APP_FLOAT ) { if ( flags & ( asOBJ_APP_CLASS | asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT | asOBJ_APP_PRIMITIVE ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & ( asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT ) ) { return ConfigError ( asINVALID_ARG ) ; } } else return ConfigError ( asINVALID_ARG ) ; if ( flags - ( flags & asOBJ_MASK_VALID_FLAGS ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_VALUE ) && byteSize == 0 ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_VALUE_TYPE_MUST_HAVE_SIZE ) ; return ConfigError ( asINVALID_ARG ) ; } if ( name == 0 ) return ConfigError ( asINVALID_NAME ) ; asCString typeName ; asCBuilder bld ( this , 0 ) ; if ( flags & asOBJ_TEMPLATE ) { asCString subtypeName ; r = bld . ParseTemplateDecl ( name , & typeName , & subtypeName ) ; if ( r < 0 ) return r ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = typeName ; type -> size = byteSize ; type -> flags = flags ; objectTypes . PushLast ( type ) ; asCObjectType * subtype = 0 ; for ( n = 0 ; n < templateSubTypes . GetLength ( ) ; n ++ ) { if ( templateSubTypes [ n ] -> name == subtypeName ) { subtype = templateSubTypes [ n ] ; break ; } } if ( subtype == 0 ) { subtype = asNEW ( asCObjectType ) ( this ) ; subtype -> name = subtypeName ; subtype -> size = 0 ; subtype -> flags = asOBJ_TEMPLATE_SUBTYPE ; templateSubTypes . PushLast ( subtype ) ; subtype -> AddRef ( ) ; } type -> templateSubType = asCDataType :: CreateObject ( subtype , false ) ; subtype -> AddRef ( ) ; currentGroup -> objTypes . PushLast ( type ) ; if ( defaultArrayObjectType == 0 ) { defaultArrayObjectType = type ; type -> AddRef ( ) ; } else { registeredObjTypes . PushLast ( type ) ; } } else { typeName = name ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] && templateTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } asCObjectType * mostRecentTemplateInstanceType = 0 ; if ( templateInstanceTypes . GetLength ( ) ) mostRecentTemplateInstanceType = templateInstanceTypes [ templateInstanceTypes . GetLength ( ) - 1 ] ; asCDataType dt ; bool oldMsgCallback = msgCallback ; msgCallback = false ; r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; if ( r < 0 ) { asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , typeName . GetLength ( ) , & tokenLen ) ; if ( token != ttIdentifier || typeName . GetLength ( ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; int r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = typeName ; type -> size = byteSize ; type -> flags = flags ; objectTypes . PushLast ( type ) ; registeredObjTypes . PushLast ( type ) ; currentGroup -> objTypes . PushLast ( type ) ; } else { if ( dt . GetSubType ( ) . IsTemplate ( ) ) return ConfigError ( asLOWER_ARRAY_DIMENSION_NOT_REGISTERED ) ; if ( dt . IsReadOnly ( ) || dt . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; if ( templateInstanceTypes [ templateInstanceTypes . GetLength ( ) - 1 ] == mostRecentTemplateInstanceType || mostRecentTemplateInstanceType == dt . GetObjectType ( ) ) return ConfigError ( asNOT_SUPPORTED ) ; asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = dt . GetObjectType ( ) -> name ; type -> templateSubType = dt . GetSubType ( ) ; if ( type -> templateSubType . GetObjectType ( ) ) type -> templateSubType . GetObjectType ( ) -> AddRef ( ) ; type -> size = byteSize ; type -> flags = flags ; templateTypes . PushLast ( type ) ; currentGroup -> objTypes . PushLast ( type ) ; RemoveTemplateInstanceType ( dt . GetObjectType ( ) ) ; } } return asSUCCESS ; } int asCScriptEngine :: RegisterObjectBehaviour ( const char * datatype , asEBehaviours behaviour , const char * decl , const asSFuncPtr & funcPointer , asDWORD callConv ) { if ( datatype == 0 ) return ConfigError ( asINVALID_ARG ) ; asCBuilder bld ( this , 0 ) ; asCDataType type ; int r = bld . ParseDataType ( datatype , & type ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( type . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_TYPE ) ; if ( type . IsReadOnly ( ) || type . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; return RegisterBehaviourToObjectType ( type . GetObjectType ( ) , behaviour , decl , funcPointer , callConv ) ; } int asCScriptEngine :: RegisterBehaviourToObjectType ( asCObjectType * objectType , asEBehaviours behaviour , const char * decl , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; if ( behaviour == asBEHAVE_FACTORY || behaviour == asBEHAVE_TEMPLATE_CALLBACK ) { # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; } else { # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # else if ( callConv != asCALL_THISCALL && callConv != asCALL_CDECL_OBJLAST && callConv != asCALL_CDECL_OBJFIRST && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif int r = DetectCallingConvention ( true , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; } isPrepared = false ; asSTypeBehaviour * beh = & objectType -> beh ; asCScriptFunction func ( this , 0 , - 1 ) ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseFunctionDeclaration ( objectType , decl , & func , true , & internal . paramAutoHandles , & internal . returnAutoHandle ) ; if ( r < 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . name . Format ( " _ beh _ % d _ " , behaviour ) ; if ( behaviour != asBEHAVE_FACTORY ) func . objectType = objectType ; if ( objectType -> flags & asOBJ_TEMPLATE ) { if ( func . returnType . GetObjectType ( ) == objectType -> templateSubType . GetObjectType ( ) ) { if ( func . returnType . IsObjectHandle ( ) ) objectType -> acceptValueSubType = false ; else if ( ! func . returnType . IsReference ( ) ) objectType -> acceptRefSubType = false ; } for ( asUINT n = 0 ; n < func . parameterTypes . GetLength ( ) ; n ++ ) { if ( func . parameterTypes [ n ] . GetObjectType ( ) == objectType -> templateSubType . GetObjectType ( ) ) { if ( func . parameterTypes [ n ] . IsObjectHandle ( ) || ( func . parameterTypes [ n ] . IsReference ( ) && func . inOutFlags [ n ] == asTM_INOUTREF ) ) objectType -> acceptValueSubType = false ; else if ( ! func . parameterTypes [ n ] . IsReference ( ) ) objectType -> acceptRefSubType = false ; } } } if ( behaviour == asBEHAVE_CONSTRUCT ) { if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( objectType -> flags & asOBJ_SCRIPT_OBJECT ) { asASSERT ( func . parameterTypes . GetLength ( ) == 1 ) ; beh -> construct = AddBehaviourFunction ( func , internal ) ; beh -> factory = beh -> construct ; scriptFunctions [ beh -> factory ] -> AddRef ( ) ; beh -> constructors . PushLast ( beh -> construct ) ; beh -> factories . PushLast ( beh -> factory ) ; func . id = beh -> construct ; } else { if ( ! ( func . objectType -> flags & asOBJ_VALUE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( func . parameterTypes . GetLength ( ) == 0 ) { func . id = beh -> construct = AddBehaviourFunction ( func , internal ) ; beh -> constructors . PushLast ( beh -> construct ) ; } else { func . id = AddBehaviourFunction ( func , internal ) ; beh -> constructors . PushLast ( func . id ) ; } } } else if ( behaviour == asBEHAVE_DESTRUCT ) { if ( ! ( func . objectType -> flags & asOBJ_VALUE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> destruct ) return ConfigError ( asALREADY_REGISTERED ) ; if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> destruct = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_FACTORY ) { if ( ! ( objectType -> flags & asOBJ_REF ) || ( objectType -> flags & asOBJ_NOHANDLE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( func . returnType != asCDataType :: CreateObjectHandle ( objectType , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ( objectType -> flags & asOBJ_TEMPLATE ) && ( func . parameterTypes . GetLength ( ) == 0 || ! func . parameterTypes [ 0 ] . IsReference ( ) ) ) { return ConfigError ( asINVALID_DECLARATION ) ; } if ( ( func . parameterTypes . GetLength ( ) == 0 ) || ( func . parameterTypes . GetLength ( ) == 1 && ( objectType -> flags & asOBJ_TEMPLATE ) ) ) { func . id = beh -> factory = AddBehaviourFunction ( func , internal ) ; beh -> factories . PushLast ( beh -> factory ) ; } else { func . id = AddBehaviourFunction ( func , internal ) ; beh -> factories . PushLast ( func . id ) ; } } else if ( behaviour == asBEHAVE_ADDREF ) { if ( ! ( func . objectType -> flags & asOBJ_REF ) || ( func . objectType -> flags & asOBJ_NOHANDLE ) || ( func . objectType -> flags & asOBJ_SCOPED ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> addref ) return ConfigError ( asALREADY_REGISTERED ) ; if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> addref = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_RELEASE ) { if ( ! ( func . objectType -> flags & asOBJ_REF ) || ( func . objectType -> flags & asOBJ_NOHANDLE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> release ) return ConfigError ( asALREADY_REGISTERED ) ; if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> release = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_TEMPLATE_CALLBACK ) { if ( ! ( func . objectType -> flags & asOBJ_TEMPLATE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> templateCallback ) return ConfigError ( asALREADY_REGISTERED ) ; if ( func . returnType != asCDataType :: CreatePrimitive ( ttBool , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> templateCallback = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_INDEX ) { if ( VerifyVarTypeNotInFunction ( & func ) < 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . returnType . GetTokenType ( ) == ttVoid ) return ConfigError ( asINVALID_DECLARATION ) ; beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else if ( behaviour >= asBEHAVE_FIRST_GC && behaviour <= asBEHAVE_LAST_GC ) { if ( ! ( func . objectType -> flags & asOBJ_GC ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( ( behaviour == asBEHAVE_GETREFCOUNT || behaviour == asBEHAVE_SETGCFLAG || behaviour == asBEHAVE_GETGCFLAG ) && func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ( behaviour == asBEHAVE_ENUMREFS || behaviour == asBEHAVE_RELEASEREFS ) && func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( behaviour == asBEHAVE_GETREFCOUNT && func . returnType != asCDataType :: CreatePrimitive ( ttInt , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( behaviour == asBEHAVE_GETGCFLAG && func . returnType != asCDataType :: CreatePrimitive ( ttBool , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ( behaviour == asBEHAVE_SETGCFLAG || behaviour == asBEHAVE_ENUMREFS || behaviour == asBEHAVE_RELEASEREFS ) && func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( behaviour == asBEHAVE_GETREFCOUNT ) func . id = beh -> gcGetRefCount = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_SETGCFLAG ) func . id = beh -> gcSetFlag = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_GETGCFLAG ) func . id = beh -> gcGetFlag = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_ENUMREFS ) func . id = beh -> gcEnumReferences = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_RELEASEREFS ) func . id = beh -> gcReleaseAllReferences = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_IMPLICIT_VALUE_CAST || behaviour == asBEHAVE_VALUE_CAST ) { if ( func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . returnType . IsEqualExceptRefAndConst ( asCDataType :: CreatePrimitive ( ttBool , false ) ) ) return ConfigError ( asNOT_SUPPORTED ) ; if ( func . returnType . IsEqualExceptRefAndConst ( asCDataType :: CreatePrimitive ( ttVoid , false ) ) ) return ConfigError ( asINVALID_DECLARATION ) ; beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else if ( behaviour == asBEHAVE_REF_CAST || behaviour == asBEHAVE_IMPLICIT_REF_CAST ) { if ( func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ! func . returnType . IsObjectHandle ( ) ) return ConfigError ( asINVALID_DECLARATION ) ; beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else { asASSERT ( false ) ; return ConfigError ( asINVALID_ARG ) ; } return func . id ; } int asCScriptEngine :: VerifyVarTypeNotInFunction ( asCScriptFunction * func ) { if ( func -> returnType . GetTokenType ( ) == ttQuestion ) return asINVALID_DECLARATION ; for ( unsigned int n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) if ( func -> parameterTypes [ n ] . GetTokenType ( ) == ttQuestion ) return asINVALID_DECLARATION ; return 0 ; } int asCScriptEngine :: AddBehaviourFunction ( asCScriptFunction & func , asSSystemFunctionInterface & internal ) { asUINT n ; int id = GetNextScriptFunctionId ( ) ; asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ; newInterface -> func = internal . func ; newInterface -> baseOffset = internal . baseOffset ; newInterface -> callConv = internal . callConv ; newInterface -> scriptReturnSize = internal . scriptReturnSize ; newInterface -> hostReturnInMemory = internal . hostReturnInMemory ; newInterface -> hostReturnFloat = internal . hostReturnFloat ; newInterface -> hostReturnSize = internal . hostReturnSize ; newInterface -> paramSize = internal . paramSize ; newInterface -> takesObjByVal = internal . takesObjByVal ; newInterface -> paramAutoHandles = internal . paramAutoHandles ; newInterface -> returnAutoHandle = internal . returnAutoHandle ; newInterface -> hasAutoHandles = internal . hasAutoHandles ; asCScriptFunction * f = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; asASSERT ( func . name != " " && func . name != " f " ) ; f -> name = func . name ; f -> sysFuncIntf = newInterface ; f -> returnType = func . returnType ; f -> objectType = func . objectType ; f -> id = id ; f -> isReadOnly = func . isReadOnly ; for ( n = 0 ; n < func . parameterTypes . GetLength ( ) ; n ++ ) { f -> parameterTypes . PushLast ( func . parameterTypes [ n ] ) ; f -> inOutFlags . PushLast ( func . inOutFlags [ n ] ) ; } SetScriptFunction ( f ) ; if ( f -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( f -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( n = 0 ; n < f -> parameterTypes . GetLength ( ) ; n ++ ) { if ( f -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( f -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } return id ; } int asCScriptEngine :: RegisterGlobalProperty ( const char * declaration , void * pointer ) { asCDataType type ; asCString name ; int r ; asCBuilder bld ( this , 0 ) ; if ( ( r = bld . VerifyProperty ( 0 , declaration , name , type ) ) < 0 ) return ConfigError ( r ) ; if ( type . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; asCGlobalProperty * prop = AllocateGlobalProperty ( ) ; prop -> name = name ; prop -> type = type ; prop -> SetRegisteredAddress ( pointer ) ; registeredGlobalProps . PushLast ( prop ) ; currentGroup -> globalProps . PushLast ( prop ) ; if ( type . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( type . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } return asSUCCESS ; } asCGlobalProperty * asCScriptEngine :: AllocateGlobalProperty ( ) { asCGlobalProperty * prop = asNEW ( asCGlobalProperty ) ; if ( freeGlobalPropertyIds . GetLength ( ) ) { prop -> id = freeGlobalPropertyIds . PopLast ( ) ; globalProperties [ prop -> id ] = prop ; return prop ; } prop -> id = ( asUINT ) globalProperties . GetLength ( ) ; globalProperties . PushLast ( prop ) ; return prop ; } void asCScriptEngine :: FreeUnusedGlobalProperties ( ) { for ( asUINT n = 0 ; n < globalProperties . GetLength ( ) ; n ++ ) { if ( globalProperties [ n ] && globalProperties [ n ] -> refCount . get ( ) == 0 ) { freeGlobalPropertyIds . PushLast ( n ) ; asDELETE ( globalProperties [ n ] , asCGlobalProperty ) ; globalProperties [ n ] = 0 ; } } } int asCScriptEngine :: GetGlobalPropertyCount ( ) { return ( int ) registeredGlobalProps . GetLength ( ) ; } int asCScriptEngine :: GetGlobalPropertyByIndex ( asUINT index , const char * * name , int * typeId , bool * isConst , const char * * configGroup , void * * pointer ) { if ( index >= registeredGlobalProps . GetLength ( ) ) return asINVALID_ARG ; if ( name ) * name = registeredGlobalProps [ index ] -> name . AddressOf ( ) ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForGlobalVar ( index ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } if ( typeId ) * typeId = GetTypeIdFromDataType ( registeredGlobalProps [ index ] -> type ) ; if ( isConst ) * isConst = registeredGlobalProps [ index ] -> type . IsReadOnly ( ) ; if ( pointer ) * pointer = registeredGlobalProps [ index ] -> realAddress ; return asSUCCESS ; } int asCScriptEngine :: RegisterObjectMethod ( const char * obj , const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { if ( obj == 0 ) return ConfigError ( asINVALID_ARG ) ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( obj , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( dt . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_ARG ) ; return RegisterMethodToObjectType ( dt . GetObjectType ( ) , declaration , funcPointer , callConv ) ; } int asCScriptEngine :: RegisterMethodToObjectType ( asCObjectType * objectType , const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( true , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # else if ( callConv != asCALL_THISCALL && callConv != asCALL_CDECL_OBJLAST && callConv != asCALL_CDECL_OBJFIRST && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif isPrepared = false ; asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> sysFuncIntf = newInterface ; func -> objectType = objectType ; asCBuilder bld ( this , 0 ) ; r = bld . ParseFunctionDeclaration ( func -> objectType , declaration , func , true , & newInterface -> paramAutoHandles , & newInterface -> returnAutoHandle ) ; if ( r < 0 ) { func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } asCDataType x = asCDataType :: CreateObject ( objectType , false ) ; r = bld . CheckNameConflictMember ( x , func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; func -> objectType -> methods . PushLast ( func -> id ) ; SetScriptFunction ( func ) ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } if ( func -> objectType -> flags & asOBJ_TEMPLATE ) { if ( func -> returnType . GetObjectType ( ) == func -> objectType -> templateSubType . GetObjectType ( ) ) { if ( func -> returnType . IsObjectHandle ( ) ) func -> objectType -> acceptValueSubType = false ; else if ( ! func -> returnType . IsReference ( ) ) func -> objectType -> acceptRefSubType = false ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) == func -> objectType -> templateSubType . GetObjectType ( ) ) { if ( func -> parameterTypes [ n ] . IsObjectHandle ( ) || ( func -> parameterTypes [ n ] . IsReference ( ) && func -> inOutFlags [ n ] == asTM_INOUTREF ) ) func -> objectType -> acceptValueSubType = false ; else if ( ! func -> parameterTypes [ n ] . IsReference ( ) ) func -> objectType -> acceptRefSubType = false ; } } } if ( func -> name == " opAssign " && func -> parameterTypes . GetLength ( ) == 1 && func -> isReadOnly == false && ( objectType -> flags & asOBJ_SCRIPT_OBJECT || func -> parameterTypes [ 0 ] . IsEqualExceptRefAndConst ( asCDataType :: CreateObject ( func -> objectType , false ) ) ) ) { func -> objectType -> beh . copy = func -> id ; func -> AddRef ( ) ; } return func -> id ; } int asCScriptEngine :: RegisterGlobalFunction ( const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # else if ( callConv != asCALL_CDECL && callConv != asCALL_STDCALL && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif isPrepared = false ; asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> sysFuncIntf = newInterface ; asCBuilder bld ( this , 0 ) ; r = bld . ParseFunctionDeclaration ( 0 , declaration , func , true , & newInterface -> paramAutoHandles , & newInterface -> returnAutoHandle ) ; if ( r < 0 ) { func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } r = bld . CheckNameConflict ( func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; currentGroup -> scriptFunctions . PushLast ( func ) ; registeredGlobalFuncs . PushLast ( func ) ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } return func -> id ; } int asCScriptEngine :: GetGlobalFunctionCount ( ) { return ( int ) registeredGlobalFuncs . GetLength ( ) ; } int asCScriptEngine :: GetGlobalFunctionIdByIndex ( asUINT index ) { if ( index >= registeredGlobalFuncs . GetLength ( ) ) return asINVALID_ARG ; return registeredGlobalFuncs [ index ] -> id ; } asCObjectType * asCScriptEngine :: GetObjectType ( const char * type ) { for ( asUINT n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) if ( objectTypes [ n ] && objectTypes [ n ] -> name == type ) return objectTypes [ n ] ; return 0 ; } void asCScriptEngine :: PrepareEngine ( ) { if ( isPrepared ) return ; if ( configFailed ) return ; asUINT n ; for ( n = 0 ; n < scriptFunctions . GetLength ( ) ; n ++ ) { if ( scriptFunctions [ n ] && scriptFunctions [ n ] -> funcType == asFUNC_SYSTEM ) { if ( scriptFunctions [ n ] -> sysFuncIntf -> callConv == ICC_GENERIC_FUNC || scriptFunctions [ n ] -> sysFuncIntf -> callConv == ICC_GENERIC_METHOD ) PrepareSystemFunctionGeneric ( scriptFunctions [ n ] , scriptFunctions [ n ] -> sysFuncIntf , this ) ; else PrepareSystemFunction ( scriptFunctions [ n ] , scriptFunctions [ n ] -> sysFuncIntf , this ) ; } } for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && ! ( objectTypes [ n ] -> flags & asOBJ_SCRIPT_OBJECT ) ) { bool missingBehaviour = false ; const char * infoMsg = 0 ; if ( objectTypes [ n ] -> flags & asOBJ_GC ) { if ( objectTypes [ n ] -> beh . addref == 0 || objectTypes [ n ] -> beh . release == 0 || objectTypes [ n ] -> beh . gcGetRefCount == 0 || objectTypes [ n ] -> beh . gcSetFlag == 0 || objectTypes [ n ] -> beh . gcGetFlag == 0 || objectTypes [ n ] -> beh . gcEnumReferences == 0 || objectTypes [ n ] -> beh . gcReleaseAllReferences == 0 ) { infoMsg = TXT_GC_REQUIRE_ADD_REL_GC_BEHAVIOUR ; missingBehaviour = true ; } } else if ( objectTypes [ n ] -> flags & asOBJ_SCOPED ) { if ( objectTypes [ n ] -> beh . release == 0 ) { infoMsg = TXT_SCOPE_REQUIRE_REL_BEHAVIOUR ; missingBehaviour = true ; } } else if ( ( objectTypes [ n ] -> flags & asOBJ_REF ) && ! ( objectTypes [ n ] -> flags & asOBJ_NOHANDLE ) ) { if ( objectTypes [ n ] -> beh . addref == 0 || objectTypes [ n ] -> beh . release == 0 ) { infoMsg = TXT_REF_REQUIRE_ADD_REL_BEHAVIOUR ; missingBehaviour = true ; } } else if ( ( objectTypes [ n ] -> flags & asOBJ_VALUE ) && ! ( objectTypes [ n ] -> flags & asOBJ_POD ) ) { if ( objectTypes [ n ] -> beh . construct == 0 || objectTypes [ n ] -> beh . destruct == 0 ) { infoMsg = TXT_NON_POD_REQUIRE_CONSTR_DESTR_BEHAVIOUR ; missingBehaviour = true ; } } if ( missingBehaviour ) { asCString str ; str . Format ( TXT_TYPE_s_IS_MISSING_BEHAVIOURS , objectTypes [ n ] -> name . AddressOf ( ) ) ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , str . AddressOf ( ) ) ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_INFORMATION , infoMsg ) ; ConfigError ( asINVALID_CONFIGURATION ) ; } } } isPrepared = true ; } int asCScriptEngine :: ConfigError ( int err ) { configFailed = true ; return err ; } int asCScriptEngine :: RegisterStringFactory ( const char * datatype , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # else if ( callConv != asCALL_CDECL && callConv != asCALL_STDCALL && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> name = " _ string _ factory _ " ; func -> sysFuncIntf = newInterface ; asCBuilder bld ( this , 0 ) ; asCDataType dt ; r = bld . ParseDataType ( datatype , & dt ) ; if ( r < 0 ) { func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_TYPE ) ; } func -> returnType = dt ; func -> parameterTypes . PushLast ( asCDataType :: CreatePrimitive ( ttInt , true ) ) ; asCDataType parm1 = asCDataType :: CreatePrimitive ( ttUInt8 , true ) ; parm1 . MakeReference ( true ) ; func -> parameterTypes . PushLast ( parm1 ) ; func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; stringFactory = func ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; if ( group == 0 ) group = & defaultGroup ; group -> scriptFunctions . PushLast ( func ) ; } return func -> id ; } int asCScriptEngine :: GetStringFactoryReturnTypeId ( ) { if ( stringFactory == 0 ) return asNO_FUNCTION ; return GetTypeIdFromDataType ( stringFactory -> returnType ) ; } asCModule * asCScriptEngine :: GetModule ( const char * _name , bool create ) { const char * name = " " ; if ( _name != 0 ) name = _name ; if ( lastModule && lastModule -> name == name ) return lastModule ; for ( asUINT n = 0 ; n < scriptModules . GetLength ( ) ; ++ n ) if ( scriptModules [ n ] && scriptModules [ n ] -> name == name ) { lastModule = scriptModules [ n ] ; return lastModule ; } if ( create ) { asCModule * module = asNEW ( asCModule ) ( name , this ) ; scriptModules . PushLast ( module ) ; lastModule = module ; return lastModule ; } return 0 ; } asCModule * asCScriptEngine :: GetModuleFromFuncId ( int id ) { if ( id < 0 ) return 0 ; if ( id >= ( int ) scriptFunctions . GetLength ( ) ) return 0 ; asCScriptFunction * func = scriptFunctions [ id ] ; if ( func == 0 ) return 0 ; return func -> module ; } int asCScriptEngine :: RequestBuild ( ) { ENTERCRITICALSECTION ( engineCritical ) ; if ( isBuilding ) { LEAVECRITICALSECTION ( engineCritical ) ; return asBUILD_IN_PROGRESS ; } isBuilding = true ; LEAVECRITICALSECTION ( engineCritical ) ; return 0 ; } void asCScriptEngine :: BuildCompleted ( ) { memoryMgr . FreeUnusedMemory ( ) ; isBuilding = false ; } # ifdef AS_DEPRECATED int asCScriptEngine :: ExecuteString ( const char * module , const char * script , asIScriptContext * * ctx , asDWORD flags ) { int r ; if ( ( r = RequestBuild ( ) ) < 0 ) return r ; PrepareEngine ( ) ; if ( configFailed ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) * ctx = 0 ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_INVALID_CONFIGURATION ) ; isBuilding = false ; return asINVALID_CONFIGURATION ; } asIScriptContext * exec = 0 ; if ( ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { int r = CreateContext ( & exec , false ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) * ctx = 0 ; isBuilding = false ; return r ; } if ( ctx ) { * ctx = exec ; exec -> AddRef ( ) ; } } else { if ( * ctx == 0 ) { isBuilding = false ; return asINVALID_ARG ; } exec = * ctx ; exec -> AddRef ( ) ; } exec -> Unprepare ( ) ; asCModule * mod = GetModule ( module , true ) ; asCBuilder builder ( this , mod ) ; asCString str = script ; str = " void ▁ ExecuteString ( ) { \n " + str + " \n ; } " ; r = builder . BuildString ( str . AddressOf ( ) , ( asCContext * ) exec ) ; BuildCompleted ( ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { ( * ctx ) -> Release ( ) ; * ctx = 0 ; } exec -> Release ( ) ; return asERROR ; } r = ( ( asCContext * ) exec ) -> Prepare ( ( ( asCContext * ) exec ) -> stringFunction -> id ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { ( * ctx ) -> Release ( ) ; * ctx = 0 ; } exec -> Release ( ) ; return r ; } if ( flags & asEXECSTRING_ONLY_PREPARE ) r = asEXECUTION_PREPARED ; else r = exec -> Execute ( ) ; exec -> Release ( ) ; return r ; } # endif void asCScriptEngine :: RemoveTemplateInstanceType ( asCObjectType * t ) { int n ; for ( n = 0 ; n < ( int ) t -> beh . factories . GetLength ( ) ; n ++ ) { scriptFunctions [ t -> beh . factories [ n ] ] -> ReleaseAllHandles ( this ) ; scriptFunctions [ t -> beh . factories [ n ] ] -> Release ( ) ; } t -> beh . factories . SetLength ( 0 ) ; for ( n = 1 ; n < ( int ) t -> beh . operators . GetLength ( ) ; n += 2 ) { if ( t -> beh . operators [ n ] && scriptFunctions [ t -> beh . operators [ n ] ] -> objectType == t ) { scriptFunctions [ t -> beh . operators [ n ] ] -> Release ( ) ; } } t -> beh . operators . SetLength ( 0 ) ; for ( n = ( int ) templateTypes . GetLength ( ) - 1 ; n >= 0 ; n -- ) { if ( templateTypes [ n ] == t ) { if ( n == ( signed ) templateTypes . GetLength ( ) - 1 ) templateTypes . PopLast ( ) ; else templateTypes [ n ] = templateTypes . PopLast ( ) ; } } for ( n = ( int ) templateInstanceTypes . GetLength ( ) - 1 ; n >= 0 ; n -- ) { if ( templateInstanceTypes [ n ] == t ) { if ( n == ( signed ) templateInstanceTypes . GetLength ( ) - 1 ) templateInstanceTypes . PopLast ( ) ; else templateInstanceTypes [ n ] = templateInstanceTypes . PopLast ( ) ; } } asDELETE ( t , asCObjectType ) ; } asCObjectType * asCScriptEngine :: GetTemplateInstanceType ( asCObjectType * templateType , asCDataType & subType ) { asUINT n ; for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] && templateTypes [ n ] -> name == templateType -> name && templateTypes [ n ] -> templateSubType == subType ) return templateTypes [ n ] ; } if ( ! templateType -> acceptValueSubType && ( subType . IsPrimitive ( ) || ( subType . GetObjectType ( ) -> flags & asOBJ_VALUE ) ) ) return 0 ; if ( ! templateType -> acceptRefSubType && ( subType . IsObject ( ) && ( subType . GetObjectType ( ) -> flags & asOBJ_REF ) ) ) return 0 ; asCObjectType * ot = asNEW ( asCObjectType ) ( this ) ; ot -> templateSubType = subType ; ot -> flags = templateType -> flags ; ot -> size = templateType -> size ; ot -> name = templateType -> name ; if ( templateType -> beh . templateCallback ) { asCScriptFunction * callback = scriptFunctions [ templateType -> beh . templateCallback ] ; if ( ! CallGlobalFunctionRetBool ( ot , 0 , callback -> sysFuncIntf , callback ) ) { ot -> templateSubType = asCDataType ( ) ; asDELETE ( ot , asCObjectType ) ; return 0 ; } } ot -> methods = templateType -> methods ; for ( n = 0 ; n < ot -> methods . GetLength ( ) ; n ++ ) scriptFunctions [ ot -> methods [ n ] ] -> AddRef ( ) ; ot -> beh . construct = templateType -> beh . factory ; ot -> beh . constructors = templateType -> beh . factories ; for ( n = 0 ; n < ot -> beh . constructors . GetLength ( ) ; n ++ ) scriptFunctions [ ot -> beh . constructors [ n ] ] -> AddRef ( ) ; for ( n = 0 ; n < templateType -> beh . factories . GetLength ( ) ; n ++ ) { int factoryId = templateType -> beh . factories [ n ] ; asCScriptFunction * factory = scriptFunctions [ factoryId ] ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SCRIPT ) ; func -> name = " factstub " ; func -> id = GetNextScriptFunctionId ( ) ; func -> returnType = asCDataType :: CreateObjectHandle ( ot , false ) ; for ( asUINT p = 1 ; p < factory -> parameterTypes . GetLength ( ) ; p ++ ) { func -> parameterTypes . PushLast ( factory -> parameterTypes [ p ] ) ; func -> inOutFlags . PushLast ( factory -> inOutFlags [ p ] ) ; } SetScriptFunction ( func ) ; asCBuilder builder ( this , 0 ) ; asCCompiler compiler ( this ) ; compiler . CompileTemplateFactoryStub ( & builder , factoryId , ot , func ) ; ot -> beh . factories . PushLast ( func -> id ) ; } if ( ot -> beh . factories . GetLength ( ) ) ot -> beh . factory = ot -> beh . factories [ 0 ] ; else { asASSERT ( false ) ; ot -> beh . factory = templateType -> beh . factory ; } ot -> beh . addref = templateType -> beh . addref ; if ( scriptFunctions [ ot -> beh . addref ] ) scriptFunctions [ ot -> beh . addref ] -> AddRef ( ) ; ot -> beh . release = templateType -> beh . release ; if ( scriptFunctions [ ot -> beh . release ] ) scriptFunctions [ ot -> beh . release ] -> AddRef ( ) ; ot -> beh . copy = templateType -> beh . copy ; if ( scriptFunctions [ ot -> beh . copy ] ) scriptFunctions [ ot -> beh . copy ] -> AddRef ( ) ; ot -> beh . operators = templateType -> beh . operators ; for ( n = 1 ; n < ot -> beh . operators . GetLength ( ) ; n += 2 ) { scriptFunctions [ ot -> beh . operators [ n ] ] -> AddRef ( ) ; } ot -> beh . gcGetRefCount = templateType -> beh . gcGetRefCount ; if ( scriptFunctions [ ot -> beh . gcGetRefCount ] ) scriptFunctions [ ot -> beh . gcGetRefCount ] -> AddRef ( ) ; ot -> beh . gcSetFlag = templateType -> beh . gcSetFlag ; if ( scriptFunctions [ ot -> beh . gcSetFlag ] ) scriptFunctions [ ot -> beh . gcSetFlag ] -> AddRef ( ) ; ot -> beh . gcGetFlag = templateType -> beh . gcGetFlag ; if ( scriptFunctions [ ot -> beh . gcGetFlag ] ) scriptFunctions [ ot -> beh . gcGetFlag ] -> AddRef ( ) ; ot -> beh . gcEnumReferences = templateType -> beh . gcEnumReferences ; if ( scriptFunctions [ ot -> beh . gcEnumReferences ] ) scriptFunctions [ ot -> beh . gcEnumReferences ] -> AddRef ( ) ; ot -> beh . gcReleaseAllReferences = templateType -> beh . gcReleaseAllReferences ; if ( scriptFunctions [ ot -> beh . gcReleaseAllReferences ] ) scriptFunctions [ ot -> beh . gcReleaseAllReferences ] -> AddRef ( ) ; for ( n = 1 ; n < ot -> beh . operators . GetLength ( ) ; n += 2 ) { int funcId = ot -> beh . operators [ n ] ; asCScriptFunction * func = scriptFunctions [ funcId ] ; if ( GenerateNewTemplateFunction ( templateType , ot , subType , func , & func ) ) { scriptFunctions [ ot -> beh . operators [ n ] ] -> Release ( ) ; ot -> beh . operators [ n ] = func -> id ; } } for ( n = 0 ; n < ot -> methods . GetLength ( ) ; n ++ ) { int funcId = ot -> methods [ n ] ; asCScriptFunction * func = scriptFunctions [ funcId ] ; if ( GenerateNewTemplateFunction ( templateType , ot , subType , func , & func ) ) { scriptFunctions [ ot -> methods [ n ] ] -> Release ( ) ; ot -> methods [ n ] = func -> id ; } } if ( ot -> templateSubType . GetObjectType ( ) ) ot -> templateSubType . GetObjectType ( ) -> AddRef ( ) ; if ( ot -> templateSubType . GetObjectType ( ) && ( ot -> templateSubType . GetObjectType ( ) -> flags & asOBJ_GC ) ) ot -> flags |= asOBJ_GC ; else if ( ot -> name == defaultArrayObjectType -> name ) ot -> flags &= ~ asOBJ_GC ; templateTypes . PushLast ( ot ) ; templateInstanceTypes . PushLast ( ot ) ; return ot ; } bool asCScriptEngine :: GenerateNewTemplateFunction ( asCObjectType * templateType , asCObjectType * ot , asCDataType & subType , asCScriptFunction * func , asCScriptFunction * * newFunc ) { bool needNewFunc = false ; if ( func -> returnType . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) || func -> returnType . GetObjectType ( ) == templateType ) needNewFunc = true ; else { for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) || func -> parameterTypes [ p ] . GetObjectType ( ) == templateType ) { needNewFunc = true ; break ; } } } if ( needNewFunc ) { asCScriptFunction * func2 = asNEW ( asCScriptFunction ) ( this , 0 , func -> funcType ) ; func2 -> name = func -> name ; func2 -> id = GetNextScriptFunctionId ( ) ; if ( func -> returnType . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) ) { func2 -> returnType = subType ; if ( func -> returnType . IsObjectHandle ( ) ) func2 -> returnType . MakeHandle ( true , true ) ; func2 -> returnType . MakeReference ( func -> returnType . IsReference ( ) ) ; func2 -> returnType . MakeReadOnly ( func -> returnType . IsReadOnly ( ) ) ; } else if ( func -> returnType . GetObjectType ( ) == templateType ) { if ( func2 -> returnType . IsObjectHandle ( ) ) func2 -> returnType = asCDataType :: CreateObjectHandle ( ot , false ) ; else func2 -> returnType = asCDataType :: CreateObject ( ot , false ) ; func2 -> returnType . MakeReference ( func -> returnType . IsReference ( ) ) ; func2 -> returnType . MakeReadOnly ( func -> returnType . IsReadOnly ( ) ) ; } else func2 -> returnType = func -> returnType ; func2 -> parameterTypes . SetLength ( func -> parameterTypes . GetLength ( ) ) ; for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) ) { func2 -> parameterTypes [ p ] = subType ; if ( func -> parameterTypes [ p ] . IsObjectHandle ( ) ) func2 -> parameterTypes [ p ] . MakeHandle ( true ) ; func2 -> parameterTypes [ p ] . MakeReference ( func -> parameterTypes [ p ] . IsReference ( ) ) ; func2 -> parameterTypes [ p ] . MakeReadOnly ( func -> parameterTypes [ p ] . IsReference ( ) ) ; } else if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType ) { if ( func2 -> parameterTypes [ p ] . IsObjectHandle ( ) ) func2 -> parameterTypes [ p ] = asCDataType :: CreateObjectHandle ( ot , false ) ; else func2 -> parameterTypes [ p ] = asCDataType :: CreateObject ( ot , false ) ; func2 -> parameterTypes [ p ] . MakeReference ( func -> parameterTypes [ p ] . IsReference ( ) ) ; func2 -> parameterTypes [ p ] . MakeReadOnly ( func -> parameterTypes [ p ] . IsReadOnly ( ) ) ; } else func2 -> parameterTypes [ p ] = func -> parameterTypes [ p ] ; } func2 -> inOutFlags = func -> inOutFlags ; func2 -> isReadOnly = func -> isReadOnly ; func2 -> objectType = ot ; func2 -> stackNeeded = func -> stackNeeded ; func2 -> sysFuncIntf = asNEW ( asSSystemFunctionInterface ) ( * func -> sysFuncIntf ) ; SetScriptFunction ( func2 ) ; * newFunc = func2 ; } return needNewFunc ; } void asCScriptEngine :: CallObjectMethod ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; CallObjectMethod ( obj , s -> sysFuncIntf , s ) ; } void asCScriptEngine :: CallObjectMethod ( void * obj , asSSystemFunctionInterface * i , asCScriptFunction * s ) { # ifdef __GNUC__ if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asPWORD baseOffset ; } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = asPWORD ( i -> baseOffset ) ; void ( asCSimpleDummy :: * f ) ( ) = p . mthd ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else { void ( * f ) ( void * ) = ( void ( * ) ( void * ) ) ( i -> func ) ; f ( obj ) ; } # else # ifndef AS_NO_CLASS_METHODS if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; void ( asCSimpleDummy :: * f ) ( ) = p . mthd ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else # endif if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else { void ( * f ) ( void * ) = ( void ( * ) ( void * ) ) ( i -> func ) ; f ( obj ) ; } # endif } bool asCScriptEngine :: CallObjectMethodRetBool ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; asSSystemFunctionInterface * i = s -> sysFuncIntf ; # ifdef __GNUC__ if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asDWORD baseOffset ; } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = i -> baseOffset ; bool ( asCSimpleDummy :: * f ) ( ) = ( bool ( asCSimpleDummy :: * ) ( ) ) ( p . mthd ) ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else { bool ( * f ) ( void * ) = ( bool ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } # else # ifndef AS_NO_CLASS_METHODS if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; bool ( asCSimpleDummy :: * f ) ( ) = ( bool ( asCSimpleDummy :: * ) ( ) ) p . mthd ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else # endif if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } else { bool ( * f ) ( void * ) = ( bool ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } # endif } int asCScriptEngine :: CallObjectMethodRetInt ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; asSSystemFunctionInterface * i = s -> sysFuncIntf ; # ifdef __GNUC__ if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( int * ) gen . GetReturnPointer ( ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asDWORD baseOffset ; } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = i -> baseOffset ; int ( asCSimpleDummy :: * f ) ( ) = ( int ( asCSimpleDummy :: * ) ( ) ) ( p . mthd ) ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else { int ( * f ) ( void * ) = ( int ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } # else # ifndef AS_NO_CLASS_METHODS if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; int ( asCSimpleDummy :: * f ) ( ) = ( int ( asCSimpleDummy :: * ) ( ) ) p . mthd ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else # endif if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( int * ) gen . GetReturnPointer ( ) ; } else { int ( * f ) ( void * ) = ( int ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } # endif } void * asCScriptEngine :: CallGlobalFunctionRetPtr ( int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; return CallGlobalFunctionRetPtr ( s -> sysFuncIntf , s ) ; } void * asCScriptEngine :: CallGlobalFunctionRetPtr ( int func , void * param1 ) { asCScriptFunction * s = scriptFunctions [ func ] ; return CallGlobalFunctionRetPtr ( s -> sysFuncIntf , s , param1 ) ; } void * asCScriptEngine :: CallGlobalFunctionRetPtr ( asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { void * ( * f ) ( ) = ( void * ( * ) ( ) ) ( i -> func ) ; return f ( ) ; } else if ( i -> callConv == ICC_STDCALL ) { void * ( STDCALL * f ) ( ) = ( void * ( STDCALL * ) ( ) ) ( i -> func ) ; return f ( ) ; } else { asCGeneric gen ( this , s , 0 , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( void * * ) gen . GetReturnPointer ( ) ; } } void * asCScriptEngine :: CallGlobalFunctionRetPtr ( asSSystemFunctionInterface * i , asCScriptFunction * s , void * param1 ) { if ( i -> callConv == ICC_CDECL ) { void * ( * f ) ( void * ) = ( void * ( * ) ( void * ) ) ( i -> func ) ; return f ( param1 ) ; } else if ( i -> callConv == ICC_STDCALL ) { void * ( STDCALL * f ) ( void * ) = ( void * ( STDCALL * ) ( void * ) ) ( i -> func ) ; return f ( param1 ) ; } else { asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( void * * ) gen . GetReturnPointer ( ) ; } } void asCScriptEngine :: CallObjectMethod ( void * obj , void * param , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; CallObjectMethod ( obj , param , s -> sysFuncIntf , s ) ; } void asCScriptEngine :: CallObjectMethod ( void * obj , void * param , asSSystemFunctionInterface * i , asCScriptFunction * s ) { # ifdef __GNUC__ if ( i -> callConv == ICC_CDECL_OBJLAST ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param , obj ) ; } else if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , ( asDWORD * ) & param ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( obj , param ) ; } # else # ifndef AS_NO_CLASS_METHODS if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; void ( asCSimpleDummy :: * f ) ( void * ) = ( void ( asCSimpleDummy :: * ) ( void * ) ) ( p . mthd ) ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( param ) ; } else # endif if ( i -> callConv == ICC_CDECL_OBJLAST ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param , obj ) ; } else if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , ( asDWORD * ) & param ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( obj , param ) ; } # endif } void asCScriptEngine :: CallGlobalFunction ( void * param1 , void * param2 , asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param1 , param2 ) ; } else if ( i -> callConv == ICC_STDCALL ) { void ( STDCALL * f ) ( void * , void * ) = ( void ( STDCALL * ) ( void * , void * ) ) ( i -> func ) ; f ( param1 , param2 ) ; } else { asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } } bool asCScriptEngine :: CallGlobalFunctionRetBool ( void * param1 , void * param2 , asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { bool ( * f ) ( void * , void * ) = ( bool ( * ) ( void * , void * ) ) ( i -> func ) ; return f ( param1 , param2 ) ; } else if ( i -> callConv == ICC_STDCALL ) { bool ( STDCALL * f ) ( void * , void * ) = ( bool ( STDCALL * ) ( void * , void * ) ) ( i -> func ) ; return f ( param1 , param2 ) ; } else { asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } } void * asCScriptEngine :: CallAlloc ( asCObjectType * type ) { # if defined ( AS_DEBUG ) return ( ( asALLOCFUNCDEBUG_t ) ( userAlloc ) ) ( type -> size < 4 ? 4 : type -> size , __FILE__ , __LINE__ ) ; # else return userAlloc ( type -> size < 4 ? 4 : type -> size ) ; # endif } void asCScriptEngine :: CallFree ( void * obj ) { userFree ( obj ) ; } void asCScriptEngine :: NotifyGarbageCollectorOfNewObject ( void * obj , int typeId ) { asCObjectType * objType = GetObjectTypeFromTypeId ( typeId ) ; gc . AddScriptObjectToGC ( obj , objType ) ; } int asCScriptEngine :: GarbageCollect ( asDWORD flags ) { return gc . GarbageCollect ( flags ) ; } void asCScriptEngine :: GetGCStatistics ( asUINT * currentSize , asUINT * totalDestroyed , asUINT * totalDetected ) { gc . GetStatistics ( currentSize , totalDestroyed , totalDetected ) ; } void asCScriptEngine :: GCEnumCallback ( void * reference ) { gc . GCEnumCallback ( reference ) ; } int asCScriptEngine :: GetTypeIdFromDataType ( const asCDataType & dt ) { if ( dt . IsNullHandle ( ) ) return 0 ; asSMapNode < int , asCDataType * > * cursor = 0 ; mapTypeIdToDataType . MoveFirst ( & cursor ) ; while ( cursor ) { if ( mapTypeIdToDataType . GetValue ( cursor ) -> IsEqualExceptRefAndConst ( dt ) ) return mapTypeIdToDataType . GetKey ( cursor ) ; mapTypeIdToDataType . MoveNext ( & cursor , cursor ) ; } int typeId = typeIdSeqNbr ++ ; if ( dt . GetObjectType ( ) ) { if ( dt . GetObjectType ( ) -> flags & asOBJ_SCRIPT_OBJECT ) typeId |= asTYPEID_SCRIPTOBJECT ; else if ( dt . GetObjectType ( ) -> flags & asOBJ_TEMPLATE ) typeId |= asTYPEID_SCRIPTARRAY ; else if ( dt . GetObjectType ( ) -> flags & asOBJ_ENUM ) ; else typeId |= asTYPEID_APPOBJECT ; } asCDataType * newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( false ) ; mapTypeIdToDataType . Insert ( typeId , newDt ) ; if ( dt . IsObject ( ) && dt . GetObjectType ( ) -> beh . release ) { newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( true ) ; newDt -> MakeHandleToConst ( false ) ; mapTypeIdToDataType . Insert ( typeId | asTYPEID_OBJHANDLE , newDt ) ; newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( true ) ; newDt -> MakeHandleToConst ( true ) ; mapTypeIdToDataType . Insert ( typeId | asTYPEID_OBJHANDLE | asTYPEID_HANDLETOCONST , newDt ) ; } return GetTypeIdFromDataType ( dt ) ; } const asCDataType * asCScriptEngine :: GetDataTypeFromTypeId ( int typeId ) { asSMapNode < int , asCDataType * > * cursor = 0 ; if ( mapTypeIdToDataType . MoveTo ( & cursor , typeId ) ) return mapTypeIdToDataType . GetValue ( cursor ) ; return 0 ; } asCObjectType * asCScriptEngine :: GetObjectTypeFromTypeId ( int typeId ) { asSMapNode < int , asCDataType * > * cursor = 0 ; if ( mapTypeIdToDataType . MoveTo ( & cursor , typeId ) ) return mapTypeIdToDataType . GetValue ( cursor ) -> GetObjectType ( ) ; return 0 ; } void asCScriptEngine :: RemoveFromTypeIdMap ( asCObjectType * type ) { asSMapNode < int , asCDataType * > * cursor = 0 ; mapTypeIdToDataType . MoveFirst ( & cursor ) ; while ( cursor ) { asCDataType * dt = mapTypeIdToDataType . GetValue ( cursor ) ; asSMapNode < int , asCDataType * > * old = cursor ; mapTypeIdToDataType . MoveNext ( & cursor , cursor ) ; if ( dt -> GetObjectType ( ) == type ) { asDELETE ( dt , asCDataType ) ; mapTypeIdToDataType . Erase ( old ) ; } } } int asCScriptEngine :: GetTypeIdByDecl ( const char * decl ) { asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( decl , & dt ) ; if ( r < 0 ) return asINVALID_TYPE ; return GetTypeIdFromDataType ( dt ) ; } const char * asCScriptEngine :: GetTypeDeclaration ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( dt == 0 ) return 0 ; asASSERT ( threadManager ) ; asCString * tempString = & threadManager -> GetLocalData ( ) -> string ; * tempString = dt -> Format ( ) ; return tempString -> AddressOf ( ) ; } int asCScriptEngine :: GetSizeOfPrimitiveType ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( dt == 0 ) return 0 ; if ( ! dt -> IsPrimitive ( ) ) return 0 ; return dt -> GetSizeInMemoryBytes ( ) ; } void * asCScriptEngine :: CreateScriptObject ( int typeId ) { if ( ( typeId & ( asTYPEID_MASK_OBJECT | asTYPEID_MASK_SEQNBR ) ) != typeId ) return 0 ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return 0 ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return 0 ; asCObjectType * objType = dt -> GetObjectType ( ) ; void * ptr = 0 ; if ( objType -> flags & asOBJ_SCRIPT_OBJECT ) ptr = ScriptObjectFactory ( objType , this ) ; else if ( objType -> flags & asOBJ_TEMPLATE ) ptr = CallGlobalFunctionRetPtr ( objType -> beh . construct , objType ) ; else if ( objType -> flags & asOBJ_REF ) ptr = CallGlobalFunctionRetPtr ( objType -> beh . factory ) ; else { ptr = CallAlloc ( objType ) ; int funcIndex = objType -> beh . construct ; if ( funcIndex ) CallObjectMethod ( ptr , funcIndex ) ; } return ptr ; } void * asCScriptEngine :: CreateScriptObjectCopy ( void * origObj , int typeId ) { void * newObj = CreateScriptObject ( typeId ) ; if ( newObj == 0 ) return 0 ; CopyScriptObject ( newObj , origObj , typeId ) ; return newObj ; } void asCScriptEngine :: CopyScriptObject ( void * dstObj , void * srcObj , int typeId ) { if ( ( typeId & ( asTYPEID_MASK_OBJECT | asTYPEID_MASK_SEQNBR ) ) != typeId ) return ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; if ( objType -> beh . copy ) { CallObjectMethod ( dstObj , srcObj , objType -> beh . copy ) ; } else if ( objType -> size ) { memcpy ( dstObj , srcObj , objType -> size ) ; } } void asCScriptEngine :: AddRefScriptObject ( void * obj , int typeId ) { if ( obj == 0 ) return ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; if ( objType -> beh . addref ) { CallObjectMethod ( obj , objType -> beh . addref ) ; } } void asCScriptEngine :: ReleaseScriptObject ( void * obj , int typeId ) { if ( obj == 0 ) return ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; if ( objType -> beh . release ) { CallObjectMethod ( obj , objType -> beh . release ) ; } else { if ( objType -> beh . destruct ) CallObjectMethod ( obj , objType -> beh . destruct ) ; CallFree ( obj ) ; } } bool asCScriptEngine :: IsHandleCompatibleWithObject ( void * obj , int objTypeId , int handleTypeId ) { if ( objTypeId == handleTypeId ) return true ; const asCDataType * objDt = GetDataTypeFromTypeId ( objTypeId ) ; const asCDataType * hdlDt = GetDataTypeFromTypeId ( handleTypeId ) ; if ( objDt -> IsHandleToConst ( ) && ! hdlDt -> IsHandleToConst ( ) ) return false ; if ( objDt -> GetObjectType ( ) == hdlDt -> GetObjectType ( ) ) { return true ; } else if ( objDt -> IsScriptObject ( ) && obj ) { asCObjectType * objType = ( ( asCScriptObject * ) obj ) -> objType ; if ( objType -> Implements ( hdlDt -> GetObjectType ( ) ) ) return true ; } return false ; } int asCScriptEngine :: BeginConfigGroup ( const char * groupName ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) return asNAME_TAKEN ; } if ( currentGroup != & defaultGroup ) return asNOT_SUPPORTED ; asCConfigGroup * group = asNEW ( asCConfigGroup ) ( ) ; group -> groupName = groupName ; configGroups . PushLast ( group ) ; currentGroup = group ; return 0 ; } int asCScriptEngine :: EndConfigGroup ( ) { if ( currentGroup == & defaultGroup ) return asNOT_SUPPORTED ; currentGroup = & defaultGroup ; return 0 ; } int asCScriptEngine :: RemoveConfigGroup ( const char * groupName ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) { asCConfigGroup * group = configGroups [ n ] ; if ( group -> refCount > 0 ) return asCONFIG_GROUP_IS_IN_USE ; if ( group -> HasLiveObjects ( ) ) return asCONFIG_GROUP_IS_IN_USE ; if ( n == configGroups . GetLength ( ) - 1 ) configGroups . PopLast ( ) ; else configGroups [ n ] = configGroups . PopLast ( ) ; group -> RemoveConfiguration ( this ) ; asDELETE ( group , asCConfigGroup ) ; } } return 0 ; } asCConfigGroup * asCScriptEngine :: FindConfigGroupForFunction ( int funcId ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { asUINT m ; for ( m = 0 ; m < configGroups [ n ] -> scriptFunctions . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> scriptFunctions [ m ] -> id == funcId ) return configGroups [ n ] ; } } return 0 ; } asCConfigGroup * asCScriptEngine :: FindConfigGroupForGlobalVar ( int gvarId ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { for ( asUINT m = 0 ; m < configGroups [ n ] -> globalProps . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> globalProps [ m ] -> id == gvarId ) return configGroups [ n ] ; } } return 0 ; } asCConfigGroup * asCScriptEngine :: FindConfigGroupForObjectType ( const asCObjectType * objType ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { for ( asUINT m = 0 ; m < configGroups [ n ] -> objTypes . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> objTypes [ m ] == objType ) return configGroups [ n ] ; } } return 0 ; } int asCScriptEngine :: SetConfigGroupModuleAccess ( const char * groupName , const char * module , bool hasAccess ) { asCConfigGroup * group = 0 ; for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) { group = configGroups [ n ] ; break ; } } if ( group == 0 ) return asWRONG_CONFIG_GROUP ; return group -> SetModuleAccess ( module , hasAccess ) ; } int asCScriptEngine :: GetNextScriptFunctionId ( ) { if ( freeScriptFunctionIds . GetLength ( ) ) return freeScriptFunctionIds . PopLast ( ) ; int id = ( int ) scriptFunctions . GetLength ( ) ; scriptFunctions . PushLast ( 0 ) ; return id ; } void asCScriptEngine :: SetScriptFunction ( asCScriptFunction * func ) { scriptFunctions [ func -> id ] = func ; } void asCScriptEngine :: FreeScriptFunctionId ( int id ) { if ( id < 0 ) return ; id &= 0xFFFF ; if ( id >= ( int ) scriptFunctions . GetLength ( ) ) return ; if ( scriptFunctions [ id ] ) { asCScriptFunction * func = scriptFunctions [ id ] ; if ( id == ( int ) scriptFunctions . GetLength ( ) - 1 ) { scriptFunctions . PopLast ( ) ; } else { scriptFunctions [ id ] = 0 ; freeScriptFunctionIds . PushLast ( id ) ; } if ( func -> signatureId == id ) { signatureIds . RemoveValue ( func ) ; int newSigId = 0 ; for ( asUINT n = 0 ; n < scriptFunctions . GetLength ( ) ; n ++ ) { if ( scriptFunctions [ n ] && scriptFunctions [ n ] -> signatureId == id ) { if ( newSigId == 0 ) { newSigId = scriptFunctions [ n ] -> id ; signatureIds . PushLast ( scriptFunctions [ n ] ) ; } scriptFunctions [ n ] -> signatureId = newSigId ; } } } } } int asCScriptEngine :: RegisterTypedef ( const char * type , const char * decl ) { if ( type == 0 ) return ConfigError ( asINVALID_NAME ) ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == type ) return asALREADY_REGISTERED ; } asCTokenizer t ; size_t tokenLen ; eTokenType token ; asCDataType dataType ; token = t . GetToken ( decl , strlen ( decl ) , & tokenLen ) ; switch ( token ) { case ttBool : case ttInt : case ttInt8 : case ttInt16 : case ttInt64 : case ttUInt : case ttUInt8 : case ttUInt16 : case ttUInt64 : case ttFloat : case ttDouble : if ( strlen ( decl ) != tokenLen ) { return ConfigError ( asINVALID_TYPE ) ; } break ; default : return ConfigError ( asINVALID_TYPE ) ; } dataType = asCDataType :: CreatePrimitive ( token , false ) ; token = t . GetToken ( type , strlen ( type ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( type ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; asCBuilder bld ( this , 0 ) ; int r = bld . CheckNameConflict ( type , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * object = asNEW ( asCObjectType ) ( this ) ; object -> flags = asOBJ_TYPEDEF ; object -> size = dataType . GetSizeInMemoryBytes ( ) ; object -> name = type ; object -> templateSubType = dataType ; objectTypes . PushLast ( object ) ; registeredTypeDefs . PushLast ( object ) ; currentGroup -> objTypes . PushLast ( object ) ; return asSUCCESS ; } int asCScriptEngine :: GetTypedefCount ( ) { return ( int ) registeredTypeDefs . GetLength ( ) ; } const char * asCScriptEngine :: GetTypedefByIndex ( asUINT index , int * typeId , const char * * configGroup ) { if ( index >= registeredTypeDefs . GetLength ( ) ) return 0 ; if ( typeId ) * typeId = GetTypeIdByDecl ( registeredTypeDefs [ index ] -> name . AddressOf ( ) ) ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForObjectType ( registeredTypeDefs [ index ] ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } return registeredTypeDefs [ index ] -> name . AddressOf ( ) ; } int asCScriptEngine :: RegisterEnum ( const char * name ) { if ( NULL == name ) return ConfigError ( asINVALID_NAME ) ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) return asALREADY_REGISTERED ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; bool oldMsgCallback = msgCallback ; msgCallback = false ; int r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; if ( r >= 0 ) return ConfigError ( asERROR ) ; asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , strlen ( name ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( name ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * st = asNEW ( asCObjectType ) ( this ) ; asCDataType dataType ; dataType . CreatePrimitive ( ttInt , false ) ; st -> flags = asOBJ_ENUM ; st -> size = dataType . GetSizeInMemoryBytes ( ) ; st -> name = name ; objectTypes . PushLast ( st ) ; registeredEnums . PushLast ( st ) ; currentGroup -> objTypes . PushLast ( st ) ; return asSUCCESS ; } int asCScriptEngine :: RegisterEnumValue ( const char * typeName , const char * valueName , int value ) { if ( currentGroup -> FindType ( typeName ) == 0 ) return asWRONG_CONFIG_GROUP ; asCDataType dt ; int r ; asCBuilder bld ( this , 0 ) ; r = bld . ParseDataType ( typeName , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; asCObjectType * ot = dt . GetObjectType ( ) ; if ( ot == 0 || ! ( ot -> flags & asOBJ_ENUM ) ) return ConfigError ( asINVALID_TYPE ) ; if ( NULL == valueName ) return ConfigError ( asINVALID_NAME ) ; for ( unsigned int n = 0 ; n < ot -> enumValues . GetLength ( ) ; n ++ ) { if ( ot -> enumValues [ n ] -> name == valueName ) return ConfigError ( asALREADY_REGISTERED ) ; } asSEnumValue * e = asNEW ( asSEnumValue ) ; e -> name = valueName ; e -> value = value ; ot -> enumValues . PushLast ( e ) ; return asSUCCESS ; } int asCScriptEngine :: GetEnumCount ( ) { return ( int ) registeredEnums . GetLength ( ) ; } const char * asCScriptEngine :: GetEnumByIndex ( asUINT index , int * enumTypeId , const char * * configGroup ) { if ( index >= registeredEnums . GetLength ( ) ) return 0 ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForObjectType ( registeredEnums [ index ] ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } if ( enumTypeId ) * enumTypeId = GetTypeIdByDecl ( registeredEnums [ index ] -> name . AddressOf ( ) ) ; return registeredEnums [ index ] -> name . AddressOf ( ) ; } int asCScriptEngine :: GetEnumValueCount ( int enumTypeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( enumTypeId ) ; asCObjectType * t = dt -> GetObjectType ( ) ; if ( t == 0 || ! ( t -> GetFlags ( ) & asOBJ_ENUM ) ) return asINVALID_TYPE ; return ( int ) t -> enumValues . GetLength ( ) ; } const char * asCScriptEngine :: GetEnumValueByIndex ( int enumTypeId , asUINT index , int * outValue ) { const asCDataType * dt = GetDataTypeFromTypeId ( enumTypeId ) ; asCObjectType * t = dt -> GetObjectType ( ) ; if ( t == 0 || ! ( t -> GetFlags ( ) & asOBJ_ENUM ) ) return 0 ; if ( index >= t -> enumValues . GetLength ( ) ) return 0 ; if ( outValue ) * outValue = t -> enumValues [ index ] -> value ; return t -> enumValues [ index ] -> name . AddressOf ( ) ; } int asCScriptEngine :: GetObjectTypeCount ( ) { return ( int ) registeredObjTypes . GetLength ( ) ; } asIObjectType * asCScriptEngine :: GetObjectTypeByIndex ( asUINT index ) { if ( index >= registeredObjTypes . GetLength ( ) ) return 0 ; return registeredObjTypes [ index ] ; } asIObjectType * asCScriptEngine :: GetObjectTypeById ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return 0 ; if ( dt -> GetObjectType ( ) && dt -> GetObjectType ( ) -> GetFlags ( ) & asOBJ_ENUM ) return 0 ; return dt -> GetObjectType ( ) ; } asIScriptFunction * asCScriptEngine :: GetFunctionDescriptorById ( int funcId ) { return GetScriptFunction ( funcId ) ; } bool asCScriptEngine :: IsTemplateType ( const char * name ) { for ( unsigned int n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) { return objectTypes [ n ] -> flags & asOBJ_TEMPLATE ? true : false ; } } return false ; } int asCScriptEngine :: AddConstantString ( const char * str , size_t len ) { for ( size_t n = 0 ; n < stringConstants . GetLength ( ) ; n ++ ) { if ( stringConstants [ n ] -> Compare ( str , len ) == 0 ) { return ( int ) n ; } } asCString * cstr = asNEW ( asCString ) ( str , len ) ; stringConstants . PushLast ( cstr ) ; asASSERT ( stringConstants . GetLength ( ) <= 65536 ) ; return ( int ) stringConstants . GetLength ( ) - 1 ; } const asCString & asCScriptEngine :: GetConstantString ( int id ) { return * stringConstants [ id ] ; } int asCScriptEngine :: GetScriptSectionNameIndex ( const char * name ) { for ( asUINT n = 0 ; n < scriptSectionNames . GetLength ( ) ; n ++ ) { if ( scriptSectionNames [ n ] -> Compare ( name ) == 0 ) return n ; } scriptSectionNames . PushLast ( asNEW ( asCString ) ( name ) ) ; return int ( scriptSectionNames . GetLength ( ) - 1 ) ; } END_AS_NAMESPACE </DOCUMENT>
<DOCUMENT_ID="cryptometh/cryptometh_1/tree/master/src/cryptopp/vmac.cpp"> # include " pch . h " # include " vmac . h " # include " argnames . h " # include " cpu . h " NAMESPACE_BEGIN ( CryptoPP ) # if defined ( _MSC_VER ) && ! CRYPTOPP_BOOL_SLOW_WORD64 # include < intrin . h > # endif # define VMAC_BOOL_WORD128 ( defined ( CRYPTOPP_WORD128_AVAILABLE ) && ! defined ( CRYPTOPP_X64_ASM_AVAILABLE ) ) # ifdef __BORLANDC__ # define const # endif static const word64 p64 = W64LIT ( 0xfffffffffffffeff ) ; static const word64 m62 = W64LIT ( 0x3fffffffffffffff ) ; static const word64 m63 = W64LIT ( 0x7fffffffffffffff ) ; static const word64 m64 = W64LIT ( 0xffffffffffffffff ) ; static const word64 mpoly = W64LIT ( 0x1fffffff1fffffff ) ; # ifdef __BORLANDC__ # undef const # endif # if VMAC_BOOL_WORD128 # ifdef __powerpc__ # define m126 ( ( word128 ( m62 ) << 64 ) | m64 ) # else static const word128 m126 = ( word128 ( m62 ) << 64 ) | m64 ; # endif # endif void VMAC_Base :: UncheckedSetKey ( const byte * userKey , unsigned int keylength , const NameValuePairs & params ) { int digestLength = params . GetIntValueWithDefault ( Name :: DigestSize ( ) , DefaultDigestSize ( ) ) ; if ( digestLength != 8 && digestLength != 16 ) throw InvalidArgument ( " VMAC : ▁ DigestSize ▁ must ▁ be ▁ 8 ▁ or ▁ 16" ) ; m_is128 = digestLength == 16 ; m_L1KeyLength = params . GetIntValueWithDefault ( Name :: L1KeyLength ( ) , 128 ) ; if ( m_L1KeyLength <= 0 || m_L1KeyLength % 128 != 0 ) throw InvalidArgument ( " VMAC : ▁ L1KeyLength ▁ must ▁ be ▁ a ▁ positive ▁ multiple ▁ of ▁ 128" ) ; AllocateBlocks ( ) ; BlockCipher & cipher = AccessCipher ( ) ; cipher . SetKey ( userKey , keylength , params ) ; unsigned int blockSize = cipher . BlockSize ( ) ; unsigned int blockSizeInWords = blockSize / sizeof ( word64 ) ; SecBlock < word64 > out ( blockSizeInWords ) ; SecByteBlock in ; in . CleanNew ( blockSize ) ; size_t i ; in [ 0 ] = 0x80 ; cipher . AdvancedProcessBlocks ( in , NULL , ( byte * ) m_nhKey ( ) , m_nhKeySize ( ) * sizeof ( word64 ) , cipher . BT_InBlockIsCounter ) ; ConditionalByteReverse < word64 > ( BIG_ENDIAN_ORDER , m_nhKey ( ) , m_nhKey ( ) , m_nhKeySize ( ) * sizeof ( word64 ) ) ; in [ 0 ] = 0xC0 ; in [ 15 ] = 0 ; for ( i = 0 ; i <= ( size_t ) m_is128 ; i ++ ) { cipher . ProcessBlock ( in , out . BytePtr ( ) ) ; m_polyState ( ) [ i * 4 + 2 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) ) & mpoly ; m_polyState ( ) [ i * 4 + 3 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) + 8 ) & mpoly ; in [ 15 ] ++ ; } in [ 0 ] = 0xE0 ; in [ 15 ] = 0 ; word64 * l3Key = m_l3Key ( ) ; for ( i = 0 ; i <= ( size_t ) m_is128 ; i ++ ) do { cipher . ProcessBlock ( in , out . BytePtr ( ) ) ; l3Key [ i * 2 + 0 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) ) ; l3Key [ i * 2 + 1 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) + 8 ) ; in [ 15 ] ++ ; } while ( ( l3Key [ i * 2 + 0 ] >= p64 ) || ( l3Key [ i * 2 + 1 ] >= p64 ) ) ; m_padCached = false ; size_t nonceLength ; const byte * nonce = GetIVAndThrowIfInvalid ( params , nonceLength ) ; Resynchronize ( nonce , ( int ) nonceLength ) ; } void VMAC_Base :: GetNextIV ( RandomNumberGenerator & rng , byte * IV ) { SimpleKeyingInterface :: GetNextIV ( rng , IV ) ; IV [ 0 ] &= 0x7f ; } void VMAC_Base :: Resynchronize ( const byte * nonce , int len ) { size_t length = ThrowIfInvalidIVLength ( len ) ; size_t s = IVSize ( ) ; byte * storedNonce = m_nonce ( ) ; if ( m_is128 ) { memset ( storedNonce , 0 , s - length ) ; memcpy ( storedNonce + s - length , nonce , length ) ; AccessCipher ( ) . ProcessBlock ( storedNonce , m_pad ( ) ) ; } else { if ( m_padCached && ( storedNonce [ s - 1 ] | 1 ) == ( nonce [ length - 1 ] | 1 ) ) { m_padCached = VerifyBufsEqual ( storedNonce + s - length , nonce , length - 1 ) ; for ( size_t i = 0 ; m_padCached && i < s - length ; i ++ ) m_padCached = ( storedNonce [ i ] == 0 ) ; } if ( ! m_padCached ) { memset ( storedNonce , 0 , s - length ) ; memcpy ( storedNonce + s - length , nonce , length - 1 ) ; storedNonce [ s - 1 ] = nonce [ length - 1 ] & 0xfe ; AccessCipher ( ) . ProcessBlock ( storedNonce , m_pad ( ) ) ; m_padCached = true ; } storedNonce [ s - 1 ] = nonce [ length - 1 ] ; } m_isFirstBlock = true ; Restart ( ) ; } void VMAC_Base :: HashEndianCorrectedBlock ( const word64 * data ) { assert ( false ) ; throw 0 ; } # if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86 # pragma warning ( disable : 4731 ) void # ifdef __GNUC__ __attribute__ ( ( noinline ) ) # endif VMAC_Base :: VHASH_Update_SSE2 ( const word64 * data , size_t blocksRemainingInWord64 , int tagPart ) { const word64 * nhK = m_nhKey ( ) ; word64 * polyS = m_polyState ( ) ; word32 L1KeyLength = m_L1KeyLength ; # ifdef __GNUC__ word32 temp ; __asm__ __volatile__ ( AS2 ( mov % % ebx , % 0 ) AS2 ( mov % 1 , % % ebx ) " . intel _ syntax ▁ noprefix ; " # else # if _MSC_VER < 1300 || defined ( __INTEL_COMPILER ) char isFirstBlock = m_isFirstBlock ; AS2 ( mov ebx , [ L1KeyLength ] ) AS2 ( mov dl , [ isFirstBlock ] ) # else AS2 ( mov ecx , this ) AS2 ( mov ebx , [ ecx + m_L1KeyLength ] ) AS2 ( mov dl , [ ecx + m_isFirstBlock ] ) # endif AS2 ( mov eax , tagPart ) AS2 ( shl eax , 4 ) AS2 ( mov edi , nhK ) AS2 ( add edi , eax ) AS2 ( add eax , eax ) AS2 ( add eax , polyS ) AS2 ( mov esi , data ) AS2 ( mov ecx , blocksRemainingInWord64 ) # endif AS2 ( shr ebx , 3 ) AS1 ( push ebp ) AS2 ( sub esp , 12 ) ASL ( 4 ) AS2 ( mov ebp , ebx ) AS2 ( cmp ecx , ebx ) AS2 ( cmovl ebp , ecx ) AS2 ( sub ecx , ebp ) AS2 ( lea ebp , [ edi + 8 * ebp ] ) AS2 ( movq mm6 , [ esi ] ) AS2 ( paddq mm6 , [ edi ] ) AS2 ( movq mm5 , [ esi + 8 ] ) AS2 ( paddq mm5 , [ edi + 8 ] ) AS2 ( add esi , 16 ) AS2 ( add edi , 16 ) AS2 ( movq mm4 , mm6 ) ASS ( pshufw mm2 , mm6 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm6 , mm5 ) ASS ( pshufw mm3 , mm5 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm5 , mm2 ) AS2 ( pmuludq mm2 , mm3 ) AS2 ( pmuludq mm3 , mm4 ) AS2 ( pxor mm7 , mm7 ) AS2 ( movd [ esp ] , mm6 ) AS2 ( psrlq mm6 , 32 ) AS2 ( movd [ esp + 4 ] , mm5 ) AS2 ( psrlq mm5 , 32 ) AS2 ( cmp edi , ebp ) ASJ ( je , 1 , f ) ASL ( 0 ) AS2 ( movq mm0 , [ esi ] ) AS2 ( paddq mm0 , [ edi ] ) AS2 ( movq mm1 , [ esi + 8 ] ) AS2 ( paddq mm1 , [ edi + 8 ] ) AS2 ( add esi , 16 ) AS2 ( add edi , 16 ) AS2 ( movq mm4 , mm0 ) AS2 ( paddq mm5 , mm2 ) ASS ( pshufw mm2 , mm0 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm0 , mm1 ) AS2 ( movd [ esp + 8 ] , mm3 ) AS2 ( psrlq mm3 , 32 ) AS2 ( paddq mm5 , mm3 ) ASS ( pshufw mm3 , mm1 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm1 , mm2 ) AS2 ( pmuludq mm2 , mm3 ) AS2 ( pmuludq mm3 , mm4 ) AS2 ( movd mm4 , [ esp ] ) AS2 ( paddq mm7 , mm4 ) AS2 ( movd mm4 , [ esp + 4 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( movd mm4 , [ esp + 8 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( movd [ esp ] , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( paddq mm6 , mm0 ) AS2 ( movd [ esp + 4 ] , mm1 ) AS2 ( psrlq mm1 , 32 ) AS2 ( paddq mm5 , mm1 ) AS2 ( cmp edi , ebp ) ASJ ( jne , 0 , b ) ASL ( 1 ) AS2 ( paddq mm5 , mm2 ) AS2 ( movd [ esp + 8 ] , mm3 ) AS2 ( psrlq mm3 , 32 ) AS2 ( paddq mm5 , mm3 ) AS2 ( movd mm4 , [ esp ] ) AS2 ( paddq mm7 , mm4 ) AS2 ( movd mm4 , [ esp + 4 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( movd mm4 , [ esp + 8 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( lea ebp , [ 8 * ebx ] ) AS2 ( sub edi , ebp ) AS2 ( movd [ esp ] , mm7 ) AS2 ( psrlq mm7 , 32 ) AS2 ( paddq mm6 , mm7 ) AS2 ( movd [ esp + 4 ] , mm6 ) AS2 ( psrlq mm6 , 32 ) AS2 ( paddq mm5 , mm6 ) AS2 ( psllq mm5 , 2 ) AS2 ( psrlq mm5 , 2 ) # define a0 [ eax + 2 * 4 ] # define a1 [ eax + 3 * 4 ] # define a2 [ eax + 0 * 4 ] # define a3 [ eax + 1 * 4 ] # define k0 [ eax + 2 * 8 + 2 * 4 ] # define k1 [ eax + 2 * 8 + 3 * 4 ] # define k2 [ eax + 2 * 8 + 0 * 4 ] # define k3 [ eax + 2 * 8 + 1 * 4 ] AS2 ( test dl , dl ) ASJ ( jz , 2 , f ) AS2 ( movd mm1 , k0 ) AS2 ( movd mm0 , [ esp ] ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd a0 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( movd mm1 , k1 ) AS2 ( movd mm2 , [ esp + 4 ] ) AS2 ( paddq mm1 , mm2 ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd a1 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( paddq mm5 , k2 ) AS2 ( paddq mm0 , mm5 ) AS2 ( movq a2 , mm0 ) AS2 ( xor edx , edx ) ASJ ( jmp , 3 , f ) ASL ( 2 ) AS2 ( movd mm0 , a3 ) AS2 ( movq mm4 , mm0 ) AS2 ( pmuludq mm0 , k3 ) AS2 ( movd mm1 , a0 ) AS2 ( pmuludq mm1 , k2 ) AS2 ( movd mm2 , a1 ) AS2 ( movd mm6 , k1 ) AS2 ( pmuludq mm2 , mm6 ) AS2 ( movd mm3 , a2 ) AS2 ( psllq mm0 , 1 ) AS2 ( paddq mm0 , mm5 ) AS2 ( movq mm5 , mm3 ) AS2 ( movd mm7 , k0 ) AS2 ( pmuludq mm3 , mm7 ) AS2 ( pmuludq mm4 , mm7 ) AS2 ( pmuludq mm5 , mm6 ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd mm1 , a1 ) AS2 ( paddq mm4 , mm5 ) AS2 ( movq mm5 , mm1 ) AS2 ( pmuludq mm1 , k2 ) AS2 ( paddq mm0 , mm2 ) AS2 ( movd mm2 , a0 ) AS2 ( paddq mm0 , mm3 ) AS2 ( movq mm3 , mm2 ) AS2 ( pmuludq mm2 , k3 ) AS2 ( pmuludq mm3 , mm7 ) AS2 ( movd [ esp + 8 ] , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( pmuludq mm7 , mm5 ) AS2 ( pmuludq mm5 , k3 ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd mm1 , a2 ) AS2 ( pmuludq mm1 , k2 ) AS2 ( paddq mm0 , mm2 ) AS2 ( paddq mm0 , mm4 ) AS2 ( movq mm4 , mm0 ) AS2 ( movd mm2 , a3 ) AS2 ( pmuludq mm2 , mm6 ) AS2 ( pmuludq mm6 , a0 ) AS2 ( psrlq mm0 , 31 ) AS2 ( paddq mm0 , mm3 ) AS2 ( movd mm3 , [ esp ] ) AS2 ( paddq mm0 , mm3 ) AS2 ( movd mm3 , a2 ) AS2 ( pmuludq mm3 , k3 ) AS2 ( paddq mm5 , mm1 ) AS2 ( movd mm1 , a3 ) AS2 ( pmuludq mm1 , k2 ) AS2 ( paddq mm5 , mm2 ) AS2 ( movd mm2 , [ esp + 4 ] ) AS2 ( psllq mm5 , 1 ) AS2 ( paddq mm0 , mm5 ) AS2 ( psllq mm4 , 33 ) AS2 ( movd a0 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( paddq mm6 , mm7 ) AS2 ( movd mm7 , [ esp + 8 ] ) AS2 ( paddq mm0 , mm6 ) AS2 ( paddq mm0 , mm2 ) AS2 ( paddq mm3 , mm1 ) AS2 ( psllq mm3 , 1 ) AS2 ( paddq mm0 , mm3 ) AS2 ( psrlq mm4 , 1 ) AS2 ( movd a1 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( por mm4 , mm7 ) AS2 ( paddq mm0 , mm4 ) AS2 ( movq a2 , mm0 ) # undef a0 # undef a1 # undef a2 # undef a3 # undef k0 # undef k1 # undef k2 # undef k3 ASL ( 3 ) AS2 ( test ecx , ecx ) ASJ ( jnz , 4 , b ) AS2 ( add esp , 12 ) AS1 ( pop ebp ) AS1 ( emms ) # ifdef __GNUC__ " . att _ syntax ▁ prefix ; " AS2 ( mov % 0 , % % ebx ) : " = m " ( temp ) : " m " ( L1KeyLength ) , " c " ( blocksRemainingInWord64 ) , " S " ( data ) , " D " ( nhK + tagPart * 2 ) , " d " ( m_isFirstBlock ) , " a " ( polyS + tagPart * 4 ) : " memory " , " cc " ) ; # endif } # endif # if VMAC_BOOL_WORD128 # define DeclareNH ( a ) word128 a = 0 # define MUL64 ( rh , rl , i1 , i2 ) { word128 p = word128 ( i1 ) * ( i2 ) ; rh = word64 ( p >> 64 ) ; rl = word64 ( p ) ; } # define AccumulateNH ( a , b , c ) a += word128 ( b ) * ( c ) # define Multiply128 ( r , i1 , i2 ) r = word128 ( word64 ( i1 ) ) * word64 ( i2 ) # else # if _MSC_VER >= 1400 && ! defined ( __INTEL_COMPILER ) # define MUL32 ( a , b ) __emulu ( word32 ( a ) , word32 ( b ) ) # else # define MUL32 ( a , b ) ( ( word64 ) ( ( word32 ) ( a ) ) * ( word32 ) ( b ) ) # endif # if defined ( CRYPTOPP_X64_ASM_AVAILABLE ) # define DeclareNH ( a ) word64 a ## 0 = 0 , a ## 1 = 0 # define MUL64 ( rh , rl , i1 , i2 ) asm ( " mulq ▁ % 3" : " = a " ( rl ) , " = d " ( rh ) : " a " ( i1 ) , " g " ( i2 ) : " cc " ) ; # define AccumulateNH ( a , b , c ) asm ( " mulq ▁ % 3 ; ▁ addq ▁ % % rax , ▁ % 0 ; ▁ adcq ▁ % % rdx , ▁ % 1" : " + r " ( a ## 0 ) , " + r " ( a ## 1 ) : " a " ( b ) , " g " ( c ) : " % rdx " , " cc " ) ; # define ADD128 ( rh , rl , ih , il ) asm ( " addq ▁ % 3 , ▁ % 1 ; ▁ adcq ▁ % 2 , ▁ % 0" : " + r " ( rh ) , " + r " ( rl ) : " r " ( ih ) , " r " ( il ) : " cc " ) ; # elif defined ( _MSC_VER ) && ! CRYPTOPP_BOOL_SLOW_WORD64 # define DeclareNH ( a ) word64 a ## 0 = 0 , a ## 1 = 0 # define MUL64 ( rh , rl , i1 , i2 ) ( rl ) = _umul128 ( i1 , i2 , & ( rh ) ) ; # define AccumulateNH ( a , b , c ) { word64 ph , pl ; pl = _umul128 ( b , c , & ph ) ; a ## 0 += pl ; a ## 1 += ph + ( a ## 0 < pl ) ; } # else # define VMAC_BOOL_32BIT 1 # define DeclareNH ( a ) word64 a ## 0 = 0 , a ## 1 = 0 , a ## 2 = 0 # define MUL64 ( rh , rl , i1 , i2 ) { word64 _i1 = ( i1 ) , _i2 = ( i2 ) ; word64 m1 = MUL32 ( _i1 , _i2 >> 32 ) ; word64 m2 = MUL32 ( _i1 >> 32 , _i2 ) ; rh = MUL32 ( _i1 >> 32 , _i2 >> 32 ) ; rl = MUL32 ( _i1 , _i2 ) ; ADD128 ( rh , rl , ( m1 >> 32 ) , ( m1 << 32 ) ) ; ADD128 ( rh , rl , ( m2 >> 32 ) , ( m2 << 32 ) ) ; } # define AccumulateNH ( a , b , c ) { word64 p = MUL32 ( b , c ) ; a ## 1 += word32 ( ( p ) >> 32 ) ; a ## 0 += word32 ( p ) ; p = MUL32 ( ( b ) >> 32 , c ) ; a ## 2 += word32 ( ( p ) >> 32 ) ; a ## 1 += word32 ( p ) ; p = MUL32 ( ( b ) >> 32 , ( c ) >> 32 ) ; a ## 2 += p ; p = MUL32 ( b , ( c ) >> 32 ) ; a ## 1 += word32 ( p ) ; a ## 2 += word32 ( p >> 32 ) ; } # endif # endif # ifndef VMAC_BOOL_32BIT # define VMAC_BOOL_32BIT 0 # endif # ifndef ADD128 # define ADD128 ( rh , rl , ih , il ) { word64 _il = ( il ) ; ( rl ) += ( _il ) ; ( rh ) += ( ih ) + ( ( rl ) < ( _il ) ) ; } # endif # if ! ( defined ( _MSC_VER ) && _MSC_VER < 1300 ) template < bool T_128BitTag > # endif void VMAC_Base :: VHASH_Update_Template ( const word64 * data , size_t blocksRemainingInWord64 ) { # define INNER_LOOP_ITERATION ( j ) { word64 d0 = ConditionalByteReverse ( LITTLE_ENDIAN_ORDER , data [ i + 2 * j + 0 ] ) ; word64 d1 = ConditionalByteReverse ( LITTLE_ENDIAN_ORDER , data [ i + 2 * j + 1 ] ) ; AccumulateNH ( nhA , d0 + nhK [ i + 2 * j + 0 ] , d1 + nhK [ i + 2 * j + 1 ] ) ; if ( T_128BitTag ) AccumulateNH ( nhB , d0 + nhK [ i + 2 * j + 2 ] , d1 + nhK [ i + 2 * j + 3 ] ) ; } # if ( defined ( _MSC_VER ) && _MSC_VER < 1300 ) bool T_128BitTag = m_is128 ; # endif size_t L1KeyLengthInWord64 = m_L1KeyLength / 8 ; size_t innerLoopEnd = L1KeyLengthInWord64 ; const word64 * nhK = m_nhKey ( ) ; word64 * polyS = m_polyState ( ) ; bool isFirstBlock = true ; size_t i ; # if ! VMAC_BOOL_32BIT # if VMAC_BOOL_WORD128 word128 a1 , a2 ; # else word64 ah1 , al1 , ah2 , al2 ; # endif word64 kh1 , kl1 , kh2 , kl2 ; kh1 = ( polyS + 0 * 4 + 2 ) [ 0 ] ; kl1 = ( polyS + 0 * 4 + 2 ) [ 1 ] ; if ( T_128BitTag ) { kh2 = ( polyS + 1 * 4 + 2 ) [ 0 ] ; kl2 = ( polyS + 1 * 4 + 2 ) [ 1 ] ; } # endif do { DeclareNH ( nhA ) ; DeclareNH ( nhB ) ; i = 0 ; if ( blocksRemainingInWord64 < L1KeyLengthInWord64 ) { if ( blocksRemainingInWord64 % 8 ) { innerLoopEnd = blocksRemainingInWord64 % 8 ; for ( ; i < innerLoopEnd ; i += 2 ) INNER_LOOP_ITERATION ( 0 ) ; } innerLoopEnd = blocksRemainingInWord64 ; } for ( ; i < innerLoopEnd ; i += 8 ) { INNER_LOOP_ITERATION ( 0 ) ; INNER_LOOP_ITERATION ( 1 ) ; INNER_LOOP_ITERATION ( 2 ) ; INNER_LOOP_ITERATION ( 3 ) ; } blocksRemainingInWord64 -= innerLoopEnd ; data += innerLoopEnd ; # if VMAC_BOOL_32BIT word32 nh0 [ 2 ] , nh1 [ 2 ] ; word64 nh2 [ 2 ] ; nh0 [ 0 ] = word32 ( nhA0 ) ; nhA1 += ( nhA0 >> 32 ) ; nh1 [ 0 ] = word32 ( nhA1 ) ; nh2 [ 0 ] = ( nhA2 + ( nhA1 >> 32 ) ) & m62 ; if ( T_128BitTag ) { nh0 [ 1 ] = word32 ( nhB0 ) ; nhB1 += ( nhB0 >> 32 ) ; nh1 [ 1 ] = word32 ( nhB1 ) ; nh2 [ 1 ] = ( nhB2 + ( nhB1 >> 32 ) ) & m62 ; } # define a0 ( ( ( word32 * ) ( polyS + i * 4 ) ) [ 2 + NativeByteOrder :: ToEnum ( ) ] ) # define a1 ( * ( ( ( word32 * ) ( polyS + i * 4 ) ) + 3 - NativeByteOrder :: ToEnum ( ) ) ) # define a2 ( ( ( word32 * ) ( polyS + i * 4 ) ) [ 0 + NativeByteOrder :: ToEnum ( ) ] ) # define a3 ( * ( ( ( word32 * ) ( polyS + i * 4 ) ) + 1 - NativeByteOrder :: ToEnum ( ) ) ) # define aHi ( ( polyS + i * 4 ) [ 0 ] ) # define k0 ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) [ 2 + NativeByteOrder :: ToEnum ( ) ] ) # define k1 ( * ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) + 3 - NativeByteOrder :: ToEnum ( ) ) ) # define k2 ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) [ 0 + NativeByteOrder :: ToEnum ( ) ] ) # define k3 ( * ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) + 1 - NativeByteOrder :: ToEnum ( ) ) ) # define kHi ( ( polyS + i * 4 + 2 ) [ 0 ] ) if ( isFirstBlock ) { isFirstBlock = false ; if ( m_isFirstBlock ) { m_isFirstBlock = false ; for ( i = 0 ; i <= ( size_t ) T_128BitTag ; i ++ ) { word64 t = ( word64 ) nh0 [ i ] + k0 ; a0 = ( word32 ) t ; t = ( t >> 32 ) + nh1 [ i ] + k1 ; a1 = ( word32 ) t ; aHi = ( t >> 32 ) + nh2 [ i ] + kHi ; } continue ; } } for ( i = 0 ; i <= ( size_t ) T_128BitTag ; i ++ ) { word64 p , t ; word32 t2 ; p = MUL32 ( a3 , 2 * k3 ) ; p += nh2 [ i ] ; p += MUL32 ( a0 , k2 ) ; p += MUL32 ( a1 , k1 ) ; p += MUL32 ( a2 , k0 ) ; t2 = ( word32 ) p ; p >>= 32 ; p += MUL32 ( a0 , k3 ) ; p += MUL32 ( a1 , k2 ) ; p += MUL32 ( a2 , k1 ) ; p += MUL32 ( a3 , k0 ) ; t = ( word64 ( word32 ( p ) & 0x7fffffff ) << 32 ) | t2 ; p >>= 31 ; p += nh0 [ i ] ; p += MUL32 ( a0 , k0 ) ; p += MUL32 ( a1 , 2 * k3 ) ; p += MUL32 ( a2 , 2 * k2 ) ; p += MUL32 ( a3 , 2 * k1 ) ; t2 = ( word32 ) p ; p >>= 32 ; p += nh1 [ i ] ; p += MUL32 ( a0 , k1 ) ; p += MUL32 ( a1 , k0 ) ; p += MUL32 ( a2 , 2 * k3 ) ; p += MUL32 ( a3 , 2 * k2 ) ; a0 = t2 ; a1 = ( word32 ) p ; aHi = ( p >> 32 ) + t ; } # undef a0 # undef a1 # undef a2 # undef a3 # undef aHi # undef k0 # undef k1 # undef k2 # undef k3 # undef kHi # else if ( isFirstBlock ) { isFirstBlock = false ; if ( m_isFirstBlock ) { m_isFirstBlock = false ; # if VMAC_BOOL_WORD128 # define first_poly_step ( a , kh , kl , m ) a = ( m & m126 ) + ( ( word128 ( kh ) << 64 ) | kl ) first_poly_step ( a1 , kh1 , kl1 , nhA ) ; if ( T_128BitTag ) first_poly_step ( a2 , kh2 , kl2 , nhB ) ; # else # define first_poly_step ( ah , al , kh , kl , mh , ml ) { mh &= m62 ; ADD128 ( mh , ml , kh , kl ) ; ah = mh ; al = ml ; } first_poly_step ( ah1 , al1 , kh1 , kl1 , nhA1 , nhA0 ) ; if ( T_128BitTag ) first_poly_step ( ah2 , al2 , kh2 , kl2 , nhB1 , nhB0 ) ; # endif continue ; } else { # if VMAC_BOOL_WORD128 a1 = ( word128 ( ( polyS + 0 * 4 ) [ 0 ] ) << 64 ) | ( polyS + 0 * 4 ) [ 1 ] ; # else ah1 = ( polyS + 0 * 4 ) [ 0 ] ; al1 = ( polyS + 0 * 4 ) [ 1 ] ; # endif if ( T_128BitTag ) { # if VMAC_BOOL_WORD128 a2 = ( word128 ( ( polyS + 1 * 4 ) [ 0 ] ) << 64 ) | ( polyS + 1 * 4 ) [ 1 ] ; # else ah2 = ( polyS + 1 * 4 ) [ 0 ] ; al2 = ( polyS + 1 * 4 ) [ 1 ] ; # endif } } } # if VMAC_BOOL_WORD128 # define poly_step ( a , kh , kl , m ) { word128 t1 , t2 , t3 , t4 ; Multiply128 ( t2 , a >> 64 , kl ) ; Multiply128 ( t3 , a , kh ) ; Multiply128 ( t1 , a , kl ) ; Multiply128 ( t4 , a >> 64 , 2 * kh ) ; t2 += t3 ; t4 += t1 ; t2 += t4 >> 64 ; a = ( word128 ( word64 ( t2 ) & m63 ) << 64 ) | word64 ( t4 ) ; t2 *= 2 ; a += m & m126 ; a += t2 >> 64 ; } poly_step ( a1 , kh1 , kl1 , nhA ) ; if ( T_128BitTag ) poly_step ( a2 , kh2 , kl2 , nhB ) ; # else # define poly_step ( ah , al , kh , kl , mh , ml ) { word64 t1h , t1l , t2h , t2l , t3h , t3l , z = 0 ; MUL64 ( t2h , t2l , ah , kl ) ; MUL64 ( t3h , t3l , al , kh ) ; MUL64 ( t1h , t1l , ah , 2 * kh ) ; MUL64 ( ah , al , al , kl ) ; ADD128 ( t2h , t2l , t3h , t3l ) ; ADD128 ( ah , al , t1h , t1l ) ; ADD128 ( t2h , ah , z , t2l ) ; t2h += t2h + ( ah >> 63 ) ; ah &= m63 ; mh &= m62 ; ADD128 ( ah , al , mh , ml ) ; ADD128 ( ah , al , z , t2h ) ; } poly_step ( ah1 , al1 , kh1 , kl1 , nhA1 , nhA0 ) ; if ( T_128BitTag ) poly_step ( ah2 , al2 , kh2 , kl2 , nhB1 , nhB0 ) ; # endif # endif } while ( blocksRemainingInWord64 ) ; # if VMAC_BOOL_WORD128 ( polyS + 0 * 4 ) [ 0 ] = word64 ( a1 >> 64 ) ; ( polyS + 0 * 4 ) [ 1 ] = word64 ( a1 ) ; if ( T_128BitTag ) { ( polyS + 1 * 4 ) [ 0 ] = word64 ( a2 >> 64 ) ; ( polyS + 1 * 4 ) [ 1 ] = word64 ( a2 ) ; } # elif ! VMAC_BOOL_32BIT ( polyS + 0 * 4 ) [ 0 ] = ah1 ; ( polyS + 0 * 4 ) [ 1 ] = al1 ; if ( T_128BitTag ) { ( polyS + 1 * 4 ) [ 0 ] = ah2 ; ( polyS + 1 * 4 ) [ 1 ] = al2 ; } # endif } inline void VMAC_Base :: VHASH_Update ( const word64 * data , size_t blocksRemainingInWord64 ) { # if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86 if ( HasSSE2 ( ) ) { VHASH_Update_SSE2 ( data , blocksRemainingInWord64 , 0 ) ; if ( m_is128 ) VHASH_Update_SSE2 ( data , blocksRemainingInWord64 , 1 ) ; m_isFirstBlock = false ; } else # endif { # if defined ( _MSC_VER ) && _MSC_VER < 1300 VHASH_Update_Template ( data , blocksRemainingInWord64 ) ; # else if ( m_is128 ) VHASH_Update_Template < true > ( data , blocksRemainingInWord64 ) ; else VHASH_Update_Template < false > ( data , blocksRemainingInWord64 ) ; # endif } } size_t VMAC_Base :: HashMultipleBlocks ( const word64 * data , size_t length ) { size_t remaining = ModPowerOf2 ( length , m_L1KeyLength ) ; VHASH_Update ( data , ( length - remaining ) / 8 ) ; return remaining ; } static word64 L3Hash ( const word64 * input , const word64 * l3Key , size_t len ) { word64 rh , rl , t , z = 0 ; word64 p1 = input [ 0 ] , p2 = input [ 1 ] ; word64 k1 = l3Key [ 0 ] , k2 = l3Key [ 1 ] ; t = p1 >> 63 ; p1 &= m63 ; ADD128 ( p1 , p2 , len , t ) ; t = ( p1 > m63 ) + ( ( p1 == m63 ) & ( p2 == m64 ) ) ; ADD128 ( p1 , p2 , z , t ) ; p1 &= m63 ; t = p1 + ( p2 >> 32 ) ; t += ( t >> 32 ) ; t += ( word32 ) t > 0xfffffffeU ; p1 += ( t >> 32 ) ; p2 += ( p1 << 32 ) ; p1 += k1 ; p1 += ( 0 - ( p1 < k1 ) ) & 257 ; p2 += k2 ; p2 += ( 0 - ( p2 < k2 ) ) & 257 ; MUL64 ( rh , rl , p1 , p2 ) ; t = rh >> 56 ; ADD128 ( t , rl , z , rh ) ; rh <<= 8 ; ADD128 ( t , rl , z , rh ) ; t += t << 8 ; rl += t ; rl += ( 0 - ( rl < t ) ) & 257 ; rl += ( 0 - ( rl > p64 - 1 ) ) & 257 ; return rl ; } void VMAC_Base :: TruncatedFinal ( byte * mac , size_t size ) { size_t len = ModPowerOf2 ( GetBitCountLo ( ) / 8 , m_L1KeyLength ) ; if ( len ) { memset ( m_data ( ) + len , 0 , ( 0 - len ) % 16 ) ; VHASH_Update ( DataBuf ( ) , ( ( len + 15 ) / 16 ) * 2 ) ; len *= 8 ; } else if ( m_isFirstBlock ) { m_polyState ( ) [ 0 ] = m_polyState ( ) [ 2 ] ; m_polyState ( ) [ 1 ] = m_polyState ( ) [ 3 ] ; if ( m_is128 ) { m_polyState ( ) [ 4 ] = m_polyState ( ) [ 6 ] ; m_polyState ( ) [ 5 ] = m_polyState ( ) [ 7 ] ; } } if ( m_is128 ) { word64 t [ 2 ] ; t [ 0 ] = L3Hash ( m_polyState ( ) , m_l3Key ( ) , len ) + GetWord < word64 > ( true , BIG_ENDIAN_ORDER , m_pad ( ) ) ; t [ 1 ] = L3Hash ( m_polyState ( ) + 4 , m_l3Key ( ) + 2 , len ) + GetWord < word64 > ( true , BIG_ENDIAN_ORDER , m_pad ( ) + 8 ) ; if ( size == 16 ) { PutWord ( false , BIG_ENDIAN_ORDER , mac , t [ 0 ] ) ; PutWord ( false , BIG_ENDIAN_ORDER , mac + 8 , t [ 1 ] ) ; } else { t [ 0 ] = ConditionalByteReverse ( BIG_ENDIAN_ORDER , t [ 0 ] ) ; t [ 1 ] = ConditionalByteReverse ( BIG_ENDIAN_ORDER , t [ 1 ] ) ; memcpy ( mac , t , size ) ; } } else { word64 t = L3Hash ( m_polyState ( ) , m_l3Key ( ) , len ) ; t += GetWord < word64 > ( true , BIG_ENDIAN_ORDER , m_pad ( ) + ( m_nonce ( ) [ IVSize ( ) - 1 ] & 1 ) * 8 ) ; if ( size == 8 ) PutWord ( false , BIG_ENDIAN_ORDER , mac , t ) ; else { t = ConditionalByteReverse ( BIG_ENDIAN_ORDER , t ) ; memcpy ( mac , & t , size ) ; } } } NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="dysonltd/gts/tree/master/app/src/tools/core/components/FloorPlanning.cpp"> # include " RoomsCollection . h " # include " CamerasCollection . h " # include " CameraPositionsCollection . h " # include " CalibrationSchema . h " # include " ExtrinsicCalibrationSchema . h " # include " CameraPositionSchema . h " # include " RoomLayoutSchema . h " # include " FloorPlanSchema . h " # include " CalibrationAlgorithm . h " # include " WbConfigTools . h " # include " WbConfig . h " # include " GroundPlaneUtility . h " # include " OpenCvUtility . h " # include " RobotMetrics . h " # include " CameraCalibration . h " # include " FileUtilities . h " # include " FileDialogs . h " # include " Message . h " # include " Logging . h " # include < QFileDialog > # include < QtGlobal > # include < opencv / cv . h > # include < opencv / highgui . h > # include < iostream > # include < algorithm > namespace FloorPlanning { bool LoadFile ( WbConfig config , KeyId cameraPosition , IplImage * * camImg , QString fileName , CvPoint2D32f * offset , bool unWarp ) { bool successful = true ; Collection camerasCollection ( CamerasCollection ( ) ) ; Collection cameraPositionsCollection ( CameraPositionsCollection ( ) ) ; camerasCollection . SetConfig ( config ) ; cameraPositionsCollection . SetConfig ( config ) ; const KeyId camPosId = cameraPosition ; LOG_INFO ( QObject :: tr ( " Camera ▁ position ▁ id : ▁ % 1" ) . arg ( camPosId ) ) ; const WbConfig camPosConfig = cameraPositionsCollection . ElementById ( camPosId ) ; if ( camPosConfig . IsNull ( ) ) successful = false ; CvMat * cameraMtx = cvCreateMat ( 3 , 3 , CV_32F ) ; CvMat * distortionCoeffs = cvCreateMat ( 5 , 1 , CV_32F ) ; CvMat * inverseCoeffs = cvCreateMat ( 5 , 1 , CV_32F ) ; CvMat * rot = cvCreateMat ( 3 , 3 , CV_32F ) ; CvMat * trans = cvCreateMat ( 1 , 3 , CV_32F ) ; if ( successful ) { const KeyId camId = camPosConfig . GetKeyValue ( CameraPositionSchema :: cameraIdKey ) . ToKeyId ( ) ; LOG_INFO ( QObject :: tr ( " Camera ▁ id : ▁ % 1" ) . arg ( camId ) ) ; WbConfig cameraConfig = camerasCollection . ElementById ( camId ) ; if ( cameraConfig . IsNull ( ) ) successful = false ; if ( successful ) { const WbConfig cameraIntrisicConfig ( cameraConfig . GetSubConfig ( CalibrationSchema :: schemaName ) ) ; if ( cameraIntrisicConfig . IsNull ( ) ) successful = false ; if ( successful ) { const bool calibrationWasSuccessful = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: calibrationSuccessfulKey ) . ToBool ( ) ; const bool cameraMtxValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: cameraMatrixKey ) . ToCvMat ( * cameraMtx ) ; const bool distortionCoeffsValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: distortionCoefficientsKey ) . ToCvMat ( * distortionCoeffs ) ; const bool inverseCoeffsValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: invDistortionCoefficientsKey ) . ToCvMat ( * inverseCoeffs ) ; successful = calibrationWasSuccessful && cameraMtxValid && distortionCoeffsValid && inverseCoeffsValid ; } const WbConfig cameraExtrisicConfig ( camPosConfig . GetSubConfig ( ExtrinsicCalibrationSchema :: schemaName ) ) ; if ( cameraExtrisicConfig . IsNull ( ) ) successful = false ; if ( successful ) { const bool rotMatValid = cameraExtrisicConfig . GetKeyValue ( ExtrinsicCalibrationSchema :: rotationMatrixKey ) . ToCvMat ( * rot ) ; const bool transValid = cameraExtrisicConfig . GetKeyValue ( ExtrinsicCalibrationSchema :: translationKey ) . ToCvMat ( * trans ) ; successful = rotMatValid && transValid ; } } } if ( successful ) { IplImage * imgGrey = cvLoadImage ( fileName . toAscii ( ) , CV_LOAD_IMAGE_GRAYSCALE ) ; if ( unWarp ) { * camImg = GroundPlaneUtility :: unwarpGroundPlane ( imgGrey , cameraMtx , distortionCoeffs , inverseCoeffs , rot , trans , offset ) ; } else { * camImg = cvCloneImage ( imgGrey ) ; } cvReleaseImage ( & imgGrey ) ; } cvReleaseMat ( & cameraMtx ) ; cvReleaseMat ( & distortionCoeffs ) ; cvReleaseMat ( & inverseCoeffs ) ; cvReleaseMat ( & rot ) ; cvReleaseMat ( & trans ) ; return successful ; } bool CheckMappingIsComplete ( WbConfig config ) { bool allMapped = true ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; bool found = false ; LOG_INFO ( QObject :: tr ( " Checking ▁ mapping ▁ for ▁ % 1 . " ) . arg ( camPosId ) ) ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( ( camPosId == camera1Id ) || ( camPosId == camera2Id ) ) { found = true ; break ; } } if ( ! found ) { allMapped = false ; break ; } } return allMapped ; } bool IsBase ( WbConfig config , KeyId camId ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; bool base = false ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camId == camera1Id ) { base = true ; break ; } } return base ; } bool IsRef ( WbConfig config , KeyId camId ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; bool ref = false ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camId == camera2Id ) { ref = true ; break ; } } return ref ; } std :: vector < KeyId > FindRoot ( WbConfig config ) { std :: vector < KeyId > rootCamera ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; bool root = true ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camPosId == camera2Id ) { root = false ; break ; } } if ( root && IsBase ( config , camPosId ) ) { rootCamera . push_back ( camPosId ) ; } } return rootCamera ; } std :: vector < KeyId > FindChain ( WbConfig config , KeyId camId , KeyId rootId , std :: vector < KeyId > mappingChain ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; LOG_INFO ( QObject :: tr ( " Camera1 ▁ id ▁ = ▁ % 1 . " ) . arg ( camera1Id ) ) ; LOG_INFO ( QObject :: tr ( " Camera2 ▁ id ▁ = ▁ % 1 . " ) . arg ( camera2Id ) ) ; if ( camId == camera2Id ) { if ( std :: find ( mappingChain . begin ( ) , mappingChain . end ( ) , camera1Id ) == mappingChain . end ( ) ) { mappingChain . push_back ( camera1Id ) ; if ( camera1Id != rootId ) { LOG_INFO ( QObject :: tr ( " Find ▁ chain ▁ for ▁ % 1 ▁ - ▁ % 2 . " ) . arg ( camera1Id ) . arg ( rootId ) ) ; mappingChain = FindChain ( config , camera1Id , rootId , mappingChain ) ; } if ( mappingChain . back ( ) == rootId ) { LOG_INFO ( " Found . " ) ; break ; } else { mappingChain . pop_back ( ) ; } } } } return mappingChain ; } bool CheckRootMapping ( WbConfig config , KeyId rootId ) { bool allMapped = true ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; if ( ( camPosId != rootId ) && IsRef ( config , camPosId ) ) { LOG_INFO ( QObject :: tr ( " Find ▁ chain ▁ for ▁ % 1 ▁ - ▁ % 2 . " ) . arg ( camPosId ) . arg ( rootId ) ) ; std :: vector < KeyId > chain = FindChain ( config , camPosId , rootId , std :: vector < KeyId > ( ) ) ; if ( chain . size ( ) == 0 ) { LOG_INFO ( " Not ▁ found . " ) ; allMapped = false ; break ; } } } return allMapped ; } void ComputeTransform ( WbConfig config , KeyId refId , std :: vector < KeyId > chain , CvMat * transform ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( std :: vector < KeyId > :: iterator elt = chain . begin ( ) ; elt != chain . end ( ) ; ++ elt ) { for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( ( camera1Id == * elt ) && ( camera2Id == refId ) ) { CvMat * homography = cvCreateMat ( 3 , 3 , CV_32F ) ; const bool homographyValid = config . GetKeyValue ( FloorPlanSchema :: homographyKey , it -> id ) . ToCvMat ( * homography ) ; Q_UNUSED ( homographyValid ) ; CvMat * tmp = cvCreateMat ( 3 , 3 , CV_32F ) ; cvMatMul ( homography , transform , tmp ) ; cvmSet ( transform , 0 , 0 , cvmGet ( tmp , 0 , 0 ) ) ; cvmSet ( transform , 0 , 1 , cvmGet ( tmp , 0 , 1 ) ) ; cvmSet ( transform , 0 , 2 , cvmGet ( tmp , 0 , 2 ) ) ; cvmSet ( transform , 1 , 0 , cvmGet ( tmp , 1 , 0 ) ) ; cvmSet ( transform , 1 , 1 , cvmGet ( tmp , 1 , 1 ) ) ; cvmSet ( transform , 1 , 2 , cvmGet ( tmp , 1 , 2 ) ) ; cvmSet ( transform , 2 , 0 , cvmGet ( tmp , 2 , 0 ) ) ; cvmSet ( transform , 2 , 1 , cvmGet ( tmp , 2 , 1 ) ) ; cvmSet ( transform , 2 , 2 , cvmGet ( tmp , 2 , 2 ) ) ; cvReleaseMat ( & tmp ) ; cvReleaseMat ( & homography ) ; refId = * elt ; } } } } } </DOCUMENT>
<DOCUMENT_ID="Roxtedy/SkyFire_6xx/tree/master/src/server/game/Handlers/TicketHandler.cpp"> # include " zlib . h " # include " Common . h " # include " Language . h " # include " ObjectMgr . h " # include " Opcodes . h " # include " Player . h " # include " TicketMgr . h " # include " Util . h " # include " World . h " # include " WorldPacket . h " # include " WorldSession . h " void WorldSession :: HandleGMTicketCreateOpcode ( WorldPacket & recvData ) { if ( sTicketMgr -> GetStatus ( ) == GMTICKET_QUEUE_STATUS_DISABLED ) return ; if ( GetPlayer ( ) -> getLevel ( ) < sWorld -> getIntConfig ( CONFIG_TICKET_LEVEL_REQ ) ) { SendNotification ( GetTrinityString ( LANG_TICKET_REQ ) , sWorld -> getIntConfig ( CONFIG_TICKET_LEVEL_REQ ) ) ; return ; } GMTicketResponse response = GMTICKET_RESPONSE_CREATE_ERROR ; GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ; if ( ticket && ticket -> IsCompleted ( ) ) sTicketMgr -> CloseTicket ( ticket -> GetId ( ) , GetPlayer ( ) -> GetGUID ( ) ) ; ; if ( ! ticket || ticket -> IsClosed ( ) ) { ticket = new GmTicket ( GetPlayer ( ) , recvData ) ; uint32 count ; std :: list < uint32 > times ; uint32 decompressedSize ; std :: string chatLog ; recvData >> count ; for ( uint32 i = 0 ; i < count ; i ++ ) { uint32 time ; recvData >> time ; times . push_back ( time ) ; } recvData >> decompressedSize ; if ( count && decompressedSize && decompressedSize < 0xFFFF ) { uint32 pos = recvData . rpos ( ) ; ByteBuffer dest ; dest . resize ( decompressedSize ) ; uLongf realSize = decompressedSize ; if ( uncompress ( dest . contents ( ) , & realSize , recvData . contents ( ) + pos , recvData . size ( ) - pos ) == Z_OK ) { dest >> chatLog ; ticket -> SetChatLog ( times , chatLog ) ; } else { TC_LOG_ERROR ( " network " , " CMSG _ GMTICKET _ CREATE ▁ possibly ▁ corrupt . ▁ Uncompression ▁ failed . " ) ; recvData . rfinish ( ) ; delete ticket ; return ; } recvData . rfinish ( ) ; } sTicketMgr -> AddTicket ( ticket ) ; sTicketMgr -> UpdateLastChange ( ) ; sWorld -> SendGMText ( LANG_COMMAND_TICKETNEW , GetPlayer ( ) -> GetName ( ) . c_str ( ) , ticket -> GetId ( ) ) ; response = GMTICKET_RESPONSE_CREATE_SUCCESS ; } WorldPacket data ( SMSG_GMTICKET_CREATE , 4 ) ; data << uint32 ( response ) ; SendPacket ( & data ) ; } void WorldSession :: HandleGMTicketUpdateOpcode ( WorldPacket & recvData ) { std :: string message ; recvData >> message ; GMTicketResponse response = GMTICKET_RESPONSE_UPDATE_ERROR ; if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { SQLTransaction trans = SQLTransaction ( NULL ) ; ticket -> SetMessage ( message ) ; ticket -> SaveToDB ( trans ) ; sWorld -> SendGMText ( LANG_COMMAND_TICKETUPDATED , GetPlayer ( ) -> GetName ( ) . c_str ( ) , ticket -> GetId ( ) ) ; response = GMTICKET_RESPONSE_UPDATE_SUCCESS ; } WorldPacket data ( SMSG_GMTICKET_UPDATETEXT , 4 ) ; data << uint32 ( response ) ; SendPacket ( & data ) ; } void WorldSession :: HandleGMTicketDeleteOpcode ( WorldPacket & ) { if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { WorldPacket data ( SMSG_GMTICKET_DELETETICKET , 4 ) ; data << uint32 ( GMTICKET_RESPONSE_TICKET_DELETED ) ; SendPacket ( & data ) ; sWorld -> SendGMText ( LANG_COMMAND_TICKETPLAYERABANDON , GetPlayer ( ) -> GetName ( ) . c_str ( ) , ticket -> GetId ( ) ) ; sTicketMgr -> CloseTicket ( ticket -> GetId ( ) , GetPlayer ( ) -> GetGUID ( ) ) ; sTicketMgr -> SendTicket ( this , NULL ) ; } } void WorldSession :: HandleGMTicketGetTicketOpcode ( WorldPacket & ) { SendQueryTimeResponse ( ) ; if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { if ( ticket -> IsCompleted ( ) ) ticket -> SendResponse ( this ) ; else sTicketMgr -> SendTicket ( this , ticket ) ; } else sTicketMgr -> SendTicket ( this , NULL ) ; } void WorldSession :: HandleGMTicketSystemStatusOpcode ( WorldPacket & ) { WorldPacket data ( SMSG_GMTICKET_SYSTEMSTATUS , 4 ) ; data << uint32 ( sTicketMgr -> GetStatus ( ) ? GMTICKET_QUEUE_STATUS_ENABLED : GMTICKET_QUEUE_STATUS_DISABLED ) ; SendPacket ( & data ) ; } void WorldSession :: HandleGMSurveySubmit ( WorldPacket & recvData ) { uint32 nextSurveyID = sTicketMgr -> GetNextSurveyID ( ) ; uint32 mainSurvey ; recvData >> mainSurvey ; for ( uint8 i = 0 ; i < 15 ; i ++ ) { uint32 subSurveyId ; recvData >> subSurveyId ; if ( ! subSurveyId ) break ; uint8 rank ; recvData >> rank ; std :: string comment ; recvData >> comment ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_GM_SUBSURVEY ) ; stmt -> setUInt32 ( 0 , nextSurveyID ) ; stmt -> setUInt32 ( 1 , subSurveyId ) ; stmt -> setUInt32 ( 2 , rank ) ; stmt -> setString ( 3 , comment ) ; CharacterDatabase . Execute ( stmt ) ; } std :: string comment ; recvData >> comment ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_GM_SURVEY ) ; stmt -> setUInt32 ( 0 , GUID_LOPART ( GetPlayer ( ) -> GetGUID ( ) ) ) ; stmt -> setUInt32 ( 1 , nextSurveyID ) ; stmt -> setUInt32 ( 2 , mainSurvey ) ; stmt -> setString ( 3 , comment ) ; CharacterDatabase . Execute ( stmt ) ; } void WorldSession :: HandleReportLag ( WorldPacket & recvData ) { uint32 lagType , mapId ; recvData >> lagType ; recvData >> mapId ; float x , y , z ; recvData >> x ; recvData >> y ; recvData >> z ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_LAG_REPORT ) ; stmt -> setUInt32 ( 0 , GUID_LOPART ( GetPlayer ( ) -> GetGUID ( ) ) ) ; stmt -> setUInt8 ( 1 , lagType ) ; stmt -> setUInt16 ( 2 , mapId ) ; stmt -> setFloat ( 3 , x ) ; stmt -> setFloat ( 4 , y ) ; stmt -> setFloat ( 5 , z ) ; stmt -> setUInt32 ( 6 , GetLatency ( ) ) ; stmt -> setUInt32 ( 7 , time ( NULL ) ) ; CharacterDatabase . Execute ( stmt ) ; } void WorldSession :: HandleGMResponseResolve ( WorldPacket & ) { if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { uint8 getSurvey = 0 ; if ( float ( rand_chance ( ) ) < sWorld -> getFloatConfig ( CONFIG_CHANCE_OF_GM_SURVEY ) ) getSurvey = 1 ; WorldPacket data ( SMSG_GMRESPONSE_STATUS_UPDATE , 4 ) ; data << uint8 ( getSurvey ) ; SendPacket ( & data ) ; WorldPacket data2 ( SMSG_GMTICKET_DELETETICKET , 4 ) ; data2 << uint32 ( GMTICKET_RESPONSE_TICKET_DELETED ) ; SendPacket ( & data2 ) ; sTicketMgr -> CloseTicket ( ticket -> GetId ( ) , GetPlayer ( ) -> GetGUID ( ) ) ; sTicketMgr -> SendTicket ( this , NULL ) ; } } </DOCUMENT>
<DOCUMENT_ID="deadcoda/arg3db/tree/master/src/sqlite/resultset.cpp"> # include " resultset . h " # include " . . / exception . h " # include " row . h " # include " session . h " using namespace std ; namespace coda { namespace db { namespace sqlite { resultset :: resultset ( const std :: shared_ptr < sqlite :: session > & sess , const shared_ptr < sqlite3_stmt > & stmt ) : stmt_ ( stmt ) , sess_ ( sess ) , status_ ( - 1 ) { if ( sess_ == nullptr ) { throw database_exception ( " No ▁ database ▁ provided ▁ to ▁ sqlite3 ▁ resultset " ) ; } if ( stmt_ == nullptr ) { throw database_exception ( " no ▁ statement ▁ provided ▁ to ▁ sqlite3 ▁ resultset " ) ; } } resultset :: resultset ( resultset && other ) : stmt_ ( std :: move ( other . stmt_ ) ) , sess_ ( std :: move ( other . sess_ ) ) , status_ ( other . status_ ) { other . sess_ = nullptr ; other . stmt_ = nullptr ; } resultset :: ~ resultset ( ) { } resultset & resultset :: operator = ( resultset && other ) { stmt_ = std :: move ( other . stmt_ ) ; sess_ = std :: move ( other . sess_ ) ; status_ = other . status_ ; other . sess_ = nullptr ; other . stmt_ = nullptr ; return * this ; } bool resultset :: is_valid ( ) const noexcept { return stmt_ != nullptr && stmt_ ; } bool resultset :: next ( ) { if ( ! is_valid ( ) ) { return false ; } if ( status_ == SQLITE_DONE ) { return false ; } status_ = sqlite3_step ( stmt_ . get ( ) ) ; return status_ == SQLITE_ROW ; } void resultset :: reset ( ) { if ( ! is_valid ( ) ) { return ; } if ( sqlite3_reset ( stmt_ . get ( ) ) != SQLITE_OK ) { throw database_exception ( sess_ -> last_error ( ) ) ; } status_ = - 1 ; } resultset :: row_type resultset :: current_row ( ) { return row_type ( make_shared < row > ( sess_ , stmt_ ) ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="pduuubs/render3D/tree/master/libs/eigen/test/geo_transformations.cpp"> # include " main . h " # include < Eigen / Geometry > # include < Eigen / LU > # include < Eigen / SVD > template < typename T > Matrix < T , 2 , 1 > angleToVec ( T a ) { return Matrix < T , 2 , 1 > ( std :: cos ( a ) , std :: sin ( a ) ) ; } template < typename T > EIGEN_DONT_INLINE void dont_over_optimize ( T & x ) { volatile typename T :: Scalar tmp = x ( 0 ) ; x ( 0 ) = tmp ; } template < typename Scalar , int Mode , int Options > void non_projective_only ( ) { typedef Matrix < Scalar , 3 , 1 > Vector3 ; typedef Quaternion < Scalar > Quaternionx ; typedef AngleAxis < Scalar > AngleAxisx ; typedef Transform < Scalar , 3 , Mode , Options > Transform3 ; typedef DiagonalMatrix < Scalar , 3 > AlignedScaling3 ; typedef Translation < Scalar , 3 > Translation3 ; Vector3 v0 = Vector3 :: Random ( ) , v1 = Vector3 :: Random ( ) ; Transform3 t0 , t1 , t2 ; Scalar a = internal :: random < Scalar > ( - Scalar ( EIGEN_PI ) , Scalar ( EIGEN_PI ) ) ; Quaternionx q1 , q2 ; q1 = AngleAxisx ( a , v0 . normalized ( ) ) ; t0 = Transform3 :: Identity ( ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , Transform3 :: MatrixType :: Identity ( ) ) ; t0 . linear ( ) = q1 . toRotationMatrix ( ) ; v0 << 50 , 2 , 1 ; t0 . scale ( v0 ) ; VERIFY_IS_APPROX ( ( t0 * Vector3 ( 1 , 0 , 0 ) ) . template head < 3 > ( ) . norm ( ) , v0 . x ( ) ) ; t0 . setIdentity ( ) ; t1 . setIdentity ( ) ; v1 << 1 , 2 , 3 ; t0 . linear ( ) = q1 . toRotationMatrix ( ) ; t0 . pretranslate ( v0 ) ; t0 . scale ( v1 ) ; t1 . linear ( ) = q1 . conjugate ( ) . toRotationMatrix ( ) ; t1 . prescale ( v1 . cwiseInverse ( ) ) ; t1 . translate ( - v0 ) ; VERIFY ( ( t0 * t1 ) . matrix ( ) . isIdentity ( test_precision < Scalar > ( ) ) ) ; t1 . fromPositionOrientationScale ( v0 , q1 , v1 ) ; VERIFY_IS_APPROX ( t1 . matrix ( ) , t0 . matrix ( ) ) ; VERIFY_IS_APPROX ( t1 * v1 , t0 * v1 ) ; t0 . setIdentity ( ) ; t0 . translate ( v0 ) ; VERIFY_IS_APPROX ( ( t0 * v1 ) . template head < 3 > ( ) , Translation3 ( v0 ) * v1 ) ; t0 . setIdentity ( ) ; t0 . scale ( v0 ) ; VERIFY_IS_APPROX ( ( t0 * v1 ) . template head < 3 > ( ) , AlignedScaling3 ( v0 ) * v1 ) ; } template < typename Scalar , int Mode , int Options > void transformations ( ) { using std :: cos ; using std :: abs ; typedef Matrix < Scalar , 3 , 3 > Matrix3 ; typedef Matrix < Scalar , 4 , 4 > Matrix4 ; typedef Matrix < Scalar , 2 , 1 > Vector2 ; typedef Matrix < Scalar , 3 , 1 > Vector3 ; typedef Matrix < Scalar , 4 , 1 > Vector4 ; typedef Quaternion < Scalar > Quaternionx ; typedef AngleAxis < Scalar > AngleAxisx ; typedef Transform < Scalar , 2 , Mode , Options > Transform2 ; typedef Transform < Scalar , 3 , Mode , Options > Transform3 ; typedef typename Transform3 :: MatrixType MatrixType ; typedef DiagonalMatrix < Scalar , 3 > AlignedScaling3 ; typedef Translation < Scalar , 2 > Translation2 ; typedef Translation < Scalar , 3 > Translation3 ; Vector3 v0 = Vector3 :: Random ( ) , v1 = Vector3 :: Random ( ) ; Matrix3 matrot1 , m ; Scalar a = internal :: random < Scalar > ( - Scalar ( EIGEN_PI ) , Scalar ( EIGEN_PI ) ) ; Scalar s0 = internal :: random < Scalar > ( ) , s1 = internal :: random < Scalar > ( ) ; while ( v0 . norm ( ) < test_precision < Scalar > ( ) ) v0 = Vector3 :: Random ( ) ; while ( v1 . norm ( ) < test_precision < Scalar > ( ) ) v1 = Vector3 :: Random ( ) ; VERIFY_IS_APPROX ( v0 , AngleAxisx ( a , v0 . normalized ( ) ) * v0 ) ; VERIFY_IS_APPROX ( - v0 , AngleAxisx ( Scalar ( EIGEN_PI ) , v0 . unitOrthogonal ( ) ) * v0 ) ; if ( abs ( cos ( a ) ) > test_precision < Scalar > ( ) ) { VERIFY_IS_APPROX ( cos ( a ) * v0 . squaredNorm ( ) , v0 . dot ( AngleAxisx ( a , v0 . unitOrthogonal ( ) ) * v0 ) ) ; } m = AngleAxisx ( a , v0 . normalized ( ) ) . toRotationMatrix ( ) . adjoint ( ) ; VERIFY_IS_APPROX ( Matrix3 :: Identity ( ) , m * AngleAxisx ( a , v0 . normalized ( ) ) ) ; VERIFY_IS_APPROX ( Matrix3 :: Identity ( ) , AngleAxisx ( a , v0 . normalized ( ) ) * m ) ; Quaternionx q1 , q2 ; q1 = AngleAxisx ( a , v0 . normalized ( ) ) ; q2 = AngleAxisx ( a , v1 . normalized ( ) ) ; matrot1 = AngleAxisx ( Scalar ( 0.1 ) , Vector3 :: UnitX ( ) ) * AngleAxisx ( Scalar ( 0.2 ) , Vector3 :: UnitY ( ) ) * AngleAxisx ( Scalar ( 0.3 ) , Vector3 :: UnitZ ( ) ) ; VERIFY_IS_APPROX ( matrot1 * v1 , AngleAxisx ( Scalar ( 0.1 ) , Vector3 ( 1 , 0 , 0 ) ) . toRotationMatrix ( ) * ( AngleAxisx ( Scalar ( 0.2 ) , Vector3 ( 0 , 1 , 0 ) ) . toRotationMatrix ( ) * ( AngleAxisx ( Scalar ( 0.3 ) , Vector3 ( 0 , 0 , 1 ) ) . toRotationMatrix ( ) * v1 ) ) ) ; AngleAxisx aa = AngleAxisx ( q1 ) ; VERIFY_IS_APPROX ( q1 * v1 , Quaternionx ( aa ) * v1 ) ; if ( ( abs ( aa . angle ( ) ) > test_precision < Scalar > ( ) ) && ( abs ( aa . axis ( ) . dot ( v1 . normalized ( ) ) ) < ( Scalar ( 1 ) - Scalar ( 4 ) * test_precision < Scalar > ( ) ) ) ) { VERIFY ( ! ( q1 * v1 ) . isApprox ( Quaternionx ( AngleAxisx ( aa . angle ( ) * 2 , aa . axis ( ) ) ) * v1 ) ) ; } aa . fromRotationMatrix ( aa . toRotationMatrix ( ) ) ; VERIFY_IS_APPROX ( q1 * v1 , Quaternionx ( aa ) * v1 ) ; if ( ( abs ( aa . angle ( ) ) > test_precision < Scalar > ( ) ) && ( abs ( aa . axis ( ) . dot ( v1 . normalized ( ) ) ) < ( Scalar ( 1 ) - Scalar ( 4 ) * test_precision < Scalar > ( ) ) ) ) { VERIFY ( ! ( q1 * v1 ) . isApprox ( Quaternionx ( AngleAxisx ( aa . angle ( ) * 2 , aa . axis ( ) ) ) * v1 ) ) ; } VERIFY_IS_APPROX ( AngleAxisx ( a , v1 . normalized ( ) ) . toRotationMatrix ( ) , Quaternionx ( AngleAxisx ( a , v1 . normalized ( ) ) ) . toRotationMatrix ( ) ) ; AngleAxisx aa1 ; m = q1 . toRotationMatrix ( ) ; aa1 = m ; VERIFY_IS_APPROX ( AngleAxisx ( m ) . toRotationMatrix ( ) , Quaternionx ( m ) . toRotationMatrix ( ) ) ; a = 0 ; while ( abs ( a ) < Scalar ( 0.1 ) ) a = internal :: random < Scalar > ( - Scalar ( 0.4 ) * Scalar ( EIGEN_PI ) , Scalar ( 0.4 ) * Scalar ( EIGEN_PI ) ) ; q1 = AngleAxisx ( a , v0 . normalized ( ) ) ; Transform3 t0 , t1 , t2 ; t0 . setIdentity ( ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , Transform3 :: MatrixType :: Identity ( ) ) ; t0 . matrix ( ) . setZero ( ) ; t0 = Transform3 :: Identity ( ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , Transform3 :: MatrixType :: Identity ( ) ) ; t0 . setIdentity ( ) ; t1 . setIdentity ( ) ; v1 << 1 , 2 , 3 ; t0 . linear ( ) = q1 . toRotationMatrix ( ) ; t0 . pretranslate ( v0 ) ; t0 . scale ( v1 ) ; t1 . linear ( ) = q1 . conjugate ( ) . toRotationMatrix ( ) ; t1 . prescale ( v1 . cwiseInverse ( ) ) ; t1 . translate ( - v0 ) ; VERIFY ( ( t0 * t1 ) . matrix ( ) . isIdentity ( test_precision < Scalar > ( ) ) ) ; t1 . fromPositionOrientationScale ( v0 , q1 , v1 ) ; VERIFY_IS_APPROX ( t1 . matrix ( ) , t0 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . scale ( v0 ) . rotate ( q1 . toRotationMatrix ( ) ) ; t1 . setIdentity ( ) ; t1 . scale ( v0 ) . rotate ( q1 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . scale ( v0 ) . rotate ( AngleAxisx ( q1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; VERIFY_IS_APPROX ( t0 . scale ( a ) . matrix ( ) , t1 . scale ( Vector3 :: Constant ( a ) ) . matrix ( ) ) ; VERIFY_IS_APPROX ( t0 . prescale ( a ) . matrix ( ) , t1 . prescale ( Vector3 :: Constant ( a ) ) . matrix ( ) ) ; Matrix3 mat3 = Matrix3 :: Random ( ) ; Matrix4 mat4 ; mat4 << mat3 , Vector3 :: Zero ( ) , Vector4 :: Zero ( ) . transpose ( ) ; Transform3 tmat3 ( mat3 ) , tmat4 ( mat4 ) ; if ( Mode != int ( AffineCompact ) ) tmat4 . matrix ( ) ( 3 , 3 ) = Scalar ( 1 ) ; VERIFY_IS_APPROX ( tmat3 . matrix ( ) , tmat4 . matrix ( ) ) ; Scalar a3 = internal :: random < Scalar > ( - Scalar ( EIGEN_PI ) , Scalar ( EIGEN_PI ) ) ; Vector3 v3 = Vector3 :: Random ( ) . normalized ( ) ; AngleAxisx aa3 ( a3 , v3 ) ; Transform3 t3 ( aa3 ) ; Transform3 t4 ; t4 = aa3 ; VERIFY_IS_APPROX ( t3 . matrix ( ) , t4 . matrix ( ) ) ; t4 . rotate ( AngleAxisx ( - a3 , v3 ) ) ; VERIFY_IS_APPROX ( t4 . matrix ( ) , MatrixType :: Identity ( ) ) ; t4 *= aa3 ; VERIFY_IS_APPROX ( t3 . matrix ( ) , t4 . matrix ( ) ) ; do { v3 = Vector3 :: Random ( ) ; dont_over_optimize ( v3 ) ; } while ( v3 . cwiseAbs ( ) . minCoeff ( ) < NumTraits < Scalar > :: epsilon ( ) ) ; Translation3 tv3 ( v3 ) ; Transform3 t5 ( tv3 ) ; t4 = tv3 ; VERIFY_IS_APPROX ( t5 . matrix ( ) , t4 . matrix ( ) ) ; t4 . translate ( ( - v3 ) . eval ( ) ) ; VERIFY_IS_APPROX ( t4 . matrix ( ) , MatrixType :: Identity ( ) ) ; t4 *= tv3 ; VERIFY_IS_APPROX ( t5 . matrix ( ) , t4 . matrix ( ) ) ; AlignedScaling3 sv3 ( v3 ) ; Transform3 t6 ( sv3 ) ; t4 = sv3 ; VERIFY_IS_APPROX ( t6 . matrix ( ) , t4 . matrix ( ) ) ; t4 . scale ( v3 . cwiseInverse ( ) ) ; VERIFY_IS_APPROX ( t4 . matrix ( ) , MatrixType :: Identity ( ) ) ; t4 *= sv3 ; VERIFY_IS_APPROX ( t6 . matrix ( ) , t4 . matrix ( ) ) ; VERIFY_IS_APPROX ( ( t3 . matrix ( ) * t4 ) . matrix ( ) , ( t3 * t4 ) . matrix ( ) ) ; VERIFY_IS_APPROX ( ( ( t3 * t4 ) * t5 ) . matrix ( ) , ( t3 * ( t4 * t5 ) ) . matrix ( ) ) ; t5 = t4 ; t5 = t5 * t5 ; VERIFY_IS_APPROX ( t5 , t4 * t4 ) ; Transform2 t20 , t21 ; Vector2 v20 = Vector2 :: Random ( ) ; Vector2 v21 = Vector2 :: Random ( ) ; for ( int k = 0 ; k < 2 ; ++ k ) if ( abs ( v21 [ k ] ) < Scalar ( 1e - 3 ) ) v21 [ k ] = Scalar ( 1e - 3 ) ; t21 . setIdentity ( ) ; t21 . linear ( ) = Rotation2D < Scalar > ( a ) . toRotationMatrix ( ) ; VERIFY_IS_APPROX ( t20 . fromPositionOrientationScale ( v20 , a , v21 ) . matrix ( ) , t21 . pretranslate ( v20 ) . scale ( v21 ) . matrix ( ) ) ; t21 . setIdentity ( ) ; t21 . linear ( ) = Rotation2D < Scalar > ( - a ) . toRotationMatrix ( ) ; VERIFY ( ( t20 . fromPositionOrientationScale ( v20 , a , v21 ) * ( t21 . prescale ( v21 . cwiseInverse ( ) ) . translate ( - v20 ) ) ) . matrix ( ) . isIdentity ( test_precision < Scalar > ( ) ) ) ; t0 . setIdentity ( ) ; t0 . rotate ( q1 ) . scale ( v0 ) . translate ( v0 ) ; t1 = ( Matrix3 ( q1 ) * AlignedScaling3 ( v0 ) ) * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = ( Matrix3 ( q1 ) * Eigen :: Scaling ( v0 ) ) * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = ( q1 * Eigen :: Scaling ( v0 ) ) * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = Matrix3 ( q1 ) * ( AlignedScaling3 ( v0 ) * Translation3 ( v0 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . scale ( s0 ) . translate ( v0 ) ; t1 = Eigen :: Scaling ( s0 ) * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . prescale ( s0 ) ; t1 = Eigen :: Scaling ( s0 ) * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 = t3 ; t0 . scale ( s0 ) ; t1 = t3 * Eigen :: Scaling ( s0 , s0 , s0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . prescale ( s0 ) ; t1 = Eigen :: Scaling ( s0 , s0 , s0 ) * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 = t3 ; t0 . scale ( s0 ) ; t1 = t3 * Eigen :: Scaling ( s0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . prescale ( s0 ) ; t1 = Eigen :: Scaling ( s0 ) * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . prerotate ( q1 ) . prescale ( v0 ) . pretranslate ( v0 ) ; t1 = ( Translation3 ( v0 ) * AlignedScaling3 ( v0 ) ) * Transform3 ( q1 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = Translation3 ( v0 ) * ( AlignedScaling3 ( v0 ) * Transform3 ( q1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . scale ( v0 ) . translate ( v0 ) . rotate ( q1 ) ; t1 = AlignedScaling3 ( v0 ) * ( Translation3 ( v0 ) * Transform3 ( q1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . scale ( v0 ) ; t1 *= AlignedScaling3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = AlignedScaling3 ( v0 ) * ( Translation3 ( v0 ) * Transform3 ( q1 ) ) ; t1 = t1 * v0 . asDiagonal ( ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . translate ( v0 ) ; t1 = t1 * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . pretranslate ( v0 ) ; t1 = Translation3 ( v0 ) * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . rotate ( q1 ) ; t1 = t1 * q1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . translate ( v1 ) . rotate ( q1 ) ; t1 = t1 * ( Translation3 ( v1 ) * q1 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . scale ( v1 ) . rotate ( q1 ) ; t1 = t1 * ( AlignedScaling3 ( v1 ) * q1 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . prerotate ( q1 ) ; t1 = q1 * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . rotate ( q1 ) . translate ( v1 ) ; t1 = t1 * ( q1 * Translation3 ( v1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . rotate ( q1 ) . scale ( v1 ) ; t1 = t1 * ( q1 * AlignedScaling3 ( v1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . translate ( v0 ) ; do { t0 . linear ( ) . setRandom ( ) ; } while ( t0 . linear ( ) . jacobiSvd ( ) . singularValues ( ) ( 2 ) < test_precision < Scalar > ( ) ) ; Matrix4 t044 = Matrix4 :: Zero ( ) ; t044 ( 3 , 3 ) = 1 ; t044 . block ( 0 , 0 , t0 . matrix ( ) . rows ( ) , 4 ) = t0 . matrix ( ) ; VERIFY_IS_APPROX ( t0 . inverse ( Affine ) . matrix ( ) , t044 . inverse ( ) . block ( 0 , 0 , t0 . matrix ( ) . rows ( ) , 4 ) ) ; t0 . setIdentity ( ) ; t0 . translate ( v0 ) . rotate ( q1 ) ; t044 = Matrix4 :: Zero ( ) ; t044 ( 3 , 3 ) = 1 ; t044 . block ( 0 , 0 , t0 . matrix ( ) . rows ( ) , 4 ) = t0 . matrix ( ) ; VERIFY_IS_APPROX ( t0 . inverse ( Isometry ) . matrix ( ) , t044 . inverse ( ) . block ( 0 , 0 , t0 . matrix ( ) . rows ( ) , 4 ) ) ; Matrix3 mat_rotation , mat_scaling ; t0 . setIdentity ( ) ; t0 . translate ( v0 ) . rotate ( q1 ) . scale ( v1 ) ; t0 . computeRotationScaling ( & mat_rotation , & mat_scaling ) ; VERIFY_IS_APPROX ( t0 . linear ( ) , mat_rotation * mat_scaling ) ; VERIFY_IS_APPROX ( mat_rotation * mat_rotation . adjoint ( ) , Matrix3 :: Identity ( ) ) ; VERIFY_IS_APPROX ( mat_rotation . determinant ( ) , Scalar ( 1 ) ) ; t0 . computeScalingRotation ( & mat_scaling , & mat_rotation ) ; VERIFY_IS_APPROX ( t0 . linear ( ) , mat_scaling * mat_rotation ) ; VERIFY_IS_APPROX ( mat_rotation * mat_rotation . adjoint ( ) , Matrix3 :: Identity ( ) ) ; VERIFY_IS_APPROX ( mat_rotation . determinant ( ) , Scalar ( 1 ) ) ; Transform < float , 3 , Mode > t1f = t1 . template cast < float > ( ) ; VERIFY_IS_APPROX ( t1f . template cast < Scalar > ( ) , t1 ) ; Transform < double , 3 , Mode > t1d = t1 . template cast < double > ( ) ; VERIFY_IS_APPROX ( t1d . template cast < Scalar > ( ) , t1 ) ; Translation3 tr1 ( v0 ) ; Translation < float , 3 > tr1f = tr1 . template cast < float > ( ) ; VERIFY_IS_APPROX ( tr1f . template cast < Scalar > ( ) , tr1 ) ; Translation < double , 3 > tr1d = tr1 . template cast < double > ( ) ; VERIFY_IS_APPROX ( tr1d . template cast < Scalar > ( ) , tr1 ) ; AngleAxis < float > aa1f = aa1 . template cast < float > ( ) ; VERIFY_IS_APPROX ( aa1f . template cast < Scalar > ( ) , aa1 ) ; AngleAxis < double > aa1d = aa1 . template cast < double > ( ) ; VERIFY_IS_APPROX ( aa1d . template cast < Scalar > ( ) , aa1 ) ; Rotation2D < Scalar > r2d1 ( internal :: random < Scalar > ( ) ) ; Rotation2D < float > r2d1f = r2d1 . template cast < float > ( ) ; VERIFY_IS_APPROX ( r2d1f . template cast < Scalar > ( ) , r2d1 ) ; Rotation2D < double > r2d1d = r2d1 . template cast < double > ( ) ; VERIFY_IS_APPROX ( r2d1d . template cast < Scalar > ( ) , r2d1 ) ; for ( int k = 0 ; k < 100 ; ++ k ) { Scalar angle = internal :: random < Scalar > ( - 100 , 100 ) ; Rotation2D < Scalar > rot2 ( angle ) ; VERIFY ( rot2 . smallestPositiveAngle ( ) >= 0 ) ; VERIFY ( rot2 . smallestPositiveAngle ( ) <= Scalar ( 2 ) * Scalar ( EIGEN_PI ) ) ; VERIFY_IS_APPROX ( angleToVec ( rot2 . smallestPositiveAngle ( ) ) , angleToVec ( rot2 . angle ( ) ) ) ; VERIFY ( rot2 . smallestAngle ( ) >= - Scalar ( EIGEN_PI ) ) ; VERIFY ( rot2 . smallestAngle ( ) <= Scalar ( EIGEN_PI ) ) ; VERIFY_IS_APPROX ( angleToVec ( rot2 . smallestAngle ( ) ) , angleToVec ( rot2 . angle ( ) ) ) ; Matrix < Scalar , 2 , 2 > rot2_as_mat ( rot2 ) ; Rotation2D < Scalar > rot3 ( rot2_as_mat ) ; VERIFY_IS_APPROX ( angleToVec ( rot2 . smallestAngle ( ) ) , angleToVec ( rot3 . angle ( ) ) ) ; } s0 = internal :: random < Scalar > ( - 100 , 100 ) ; s1 = internal :: random < Scalar > ( - 100 , 100 ) ; Rotation2D < Scalar > R0 ( s0 ) , R1 ( s1 ) ; t20 = Translation2 ( v20 ) * ( R0 * Eigen :: Scaling ( s0 ) ) ; t21 = Translation2 ( v20 ) * R0 * Eigen :: Scaling ( s0 ) ; VERIFY_IS_APPROX ( t20 , t21 ) ; t20 = Translation2 ( v20 ) * ( R0 * R0 . inverse ( ) * Eigen :: Scaling ( s0 ) ) ; t21 = Translation2 ( v20 ) * Eigen :: Scaling ( s0 ) ; VERIFY_IS_APPROX ( t20 , t21 ) ; VERIFY_IS_APPROX ( s0 , ( R0 . slerp ( 0 , R1 ) ) . angle ( ) ) ; VERIFY_IS_APPROX ( angleToVec ( R1 . smallestPositiveAngle ( ) ) , angleToVec ( ( R0 . slerp ( 1 , R1 ) ) . smallestPositiveAngle ( ) ) ) ; VERIFY_IS_APPROX ( R0 . smallestPositiveAngle ( ) , ( R0 . slerp ( 0.5 , R0 ) ) . smallestPositiveAngle ( ) ) ; if ( std :: cos ( s0 ) > 0 ) VERIFY_IS_MUCH_SMALLER_THAN ( ( R0 . slerp ( 0.5 , R0 . inverse ( ) ) ) . smallestAngle ( ) , Scalar ( 1 ) ) ; else VERIFY_IS_APPROX ( Scalar ( EIGEN_PI ) , ( R0 . slerp ( 0.5 , R0 . inverse ( ) ) ) . smallestPositiveAngle ( ) ) ; Scalar l = 0 ; int path_steps = 100 ; for ( int k = 0 ; k < path_steps ; ++ k ) { Scalar a1 = R0 . slerp ( Scalar ( k ) / Scalar ( path_steps ) , R1 ) . angle ( ) ; Scalar a2 = R0 . slerp ( Scalar ( k + 1 ) / Scalar ( path_steps ) , R1 ) . angle ( ) ; l += std :: abs ( a2 - a1 ) ; } VERIFY ( l <= Scalar ( EIGEN_PI ) * ( Scalar ( 1 ) + NumTraits < Scalar > :: epsilon ( ) * Scalar ( path_steps / 2 ) ) ) ; { Rotation2D < Scalar > r1 ; r1 = Rotation2D < Scalar > ( s0 ) ; VERIFY_IS_APPROX ( r1 . angle ( ) , s0 ) ; Rotation2D < Scalar > r2 ( r1 ) ; VERIFY_IS_APPROX ( r2 . angle ( ) , s0 ) ; } { Transform3 t32 ( Matrix4 :: Random ( ) ) , t33 , t34 ; t34 = t33 = t32 ; t32 . scale ( v0 ) ; t33 *= AlignedScaling3 ( v0 ) ; VERIFY_IS_APPROX ( t32 . matrix ( ) , t33 . matrix ( ) ) ; t33 = t34 * AlignedScaling3 ( v0 ) ; VERIFY_IS_APPROX ( t32 . matrix ( ) , t33 . matrix ( ) ) ; } } template < typename A1 , typename A2 , typename P , typename Q , typename V , typename H > void transform_associativity_left ( const A1 & a1 , const A2 & a2 , const P & p , const Q & q , const V & v , const H & h ) { VERIFY_IS_APPROX ( q * ( a1 * v ) , ( q * a1 ) * v ) ; VERIFY_IS_APPROX ( q * ( a2 * v ) , ( q * a2 ) * v ) ; VERIFY_IS_APPROX ( q * ( p * h ) . hnormalized ( ) , ( ( q * p ) * h ) . hnormalized ( ) ) ; } template < typename A1 , typename A2 , typename P , typename Q , typename V , typename H > void transform_associativity2 ( const A1 & a1 , const A2 & a2 , const P & p , const Q & q , const V & v , const H & h ) { VERIFY_IS_APPROX ( a1 * ( q * v ) , ( a1 * q ) * v ) ; VERIFY_IS_APPROX ( a2 * ( q * v ) , ( a2 * q ) * v ) ; VERIFY_IS_APPROX ( p * ( q * v ) . homogeneous ( ) , ( p * q ) * v . homogeneous ( ) ) ; transform_associativity_left ( a1 , a2 , p , q , v , h ) ; } template < typename Scalar , int Dim , int Options , typename RotationType > void transform_associativity ( const RotationType & R ) { typedef Matrix < Scalar , Dim , 1 > VectorType ; typedef Matrix < Scalar , Dim + 1 , 1 > HVectorType ; typedef Matrix < Scalar , Dim , Dim > LinearType ; typedef Matrix < Scalar , Dim + 1 , Dim + 1 > MatrixType ; typedef Transform < Scalar , Dim , AffineCompact , Options > AffineCompactType ; typedef Transform < Scalar , Dim , Affine , Options > AffineType ; typedef Transform < Scalar , Dim , Projective , Options > ProjectiveType ; typedef DiagonalMatrix < Scalar , Dim > ScalingType ; typedef Translation < Scalar , Dim > TranslationType ; AffineCompactType A1c ; A1c . matrix ( ) . setRandom ( ) ; AffineCompactType A2c ; A2c . matrix ( ) . setRandom ( ) ; AffineType A1 ( A1c ) ; AffineType A2 ( A2c ) ; ProjectiveType P1 ; P1 . matrix ( ) . setRandom ( ) ; VectorType v1 = VectorType :: Random ( ) ; VectorType v2 = VectorType :: Random ( ) ; HVectorType h1 = HVectorType :: Random ( ) ; Scalar s1 = internal :: random < Scalar > ( ) ; LinearType L = LinearType :: Random ( ) ; MatrixType M = MatrixType :: Random ( ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , A2 , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , A2c , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , v1 . asDiagonal ( ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , ScalingType ( v1 ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , Scaling ( v1 ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , Scaling ( s1 ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , TranslationType ( v1 ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity_left ( A1c , A1 , P1 , L , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , R , v2 , h1 ) ) ; VERIFY_IS_APPROX ( A1 * ( M * h1 ) , ( A1 * M ) * h1 ) ; VERIFY_IS_APPROX ( A1c * ( M * h1 ) , ( A1c * M ) * h1 ) ; VERIFY_IS_APPROX ( P1 * ( M * h1 ) , ( P1 * M ) * h1 ) ; VERIFY_IS_APPROX ( M * ( A1 * h1 ) , ( M * A1 ) * h1 ) ; VERIFY_IS_APPROX ( M * ( A1c * h1 ) , ( M * A1c ) * h1 ) ; VERIFY_IS_APPROX ( M * ( P1 * h1 ) , ( ( M * P1 ) * h1 ) ) ; } template < typename Scalar > void transform_alignment ( ) { typedef Transform < Scalar , 3 , Projective , AutoAlign > Projective3a ; typedef Transform < Scalar , 3 , Projective , DontAlign > Projective3u ; EIGEN_ALIGN_MAX Scalar array1 [ 16 ] ; EIGEN_ALIGN_MAX Scalar array2 [ 16 ] ; EIGEN_ALIGN_MAX Scalar array3 [ 16 + 1 ] ; Scalar * array3u = array3 + 1 ; Projective3a * p1 = :: new ( reinterpret_cast < void * > ( array1 ) ) Projective3a ; Projective3u * p2 = :: new ( reinterpret_cast < void * > ( array2 ) ) Projective3u ; Projective3u * p3 = :: new ( reinterpret_cast < void * > ( array3u ) ) Projective3u ; p1 -> matrix ( ) . setRandom ( ) ; * p2 = * p1 ; * p3 = * p1 ; VERIFY_IS_APPROX ( p1 -> matrix ( ) , p2 -> matrix ( ) ) ; VERIFY_IS_APPROX ( p1 -> matrix ( ) , p3 -> matrix ( ) ) ; VERIFY_IS_APPROX ( ( * p1 ) * ( * p1 ) , ( * p2 ) * ( * p3 ) ) ; # if defined ( EIGEN_VECTORIZE ) && EIGEN_MAX_STATIC_ALIGN_BYTES > 0 if ( internal :: packet_traits < Scalar > :: Vectorizable ) VERIFY_RAISES_ASSERT ( ( :: new ( reinterpret_cast < void * > ( array3u ) ) Projective3a ) ) ; # endif } template < typename Scalar , int Dim , int Options > void transform_products ( ) { typedef Matrix < Scalar , Dim + 1 , Dim + 1 > Mat ; typedef Transform < Scalar , Dim , Projective , Options > Proj ; typedef Transform < Scalar , Dim , Affine , Options > Aff ; typedef Transform < Scalar , Dim , AffineCompact , Options > AffC ; Proj p ; p . matrix ( ) . setRandom ( ) ; Aff a ; a . linear ( ) . setRandom ( ) ; a . translation ( ) . setRandom ( ) ; AffC ac = a ; Mat p_m ( p . matrix ( ) ) , a_m ( a . matrix ( ) ) ; VERIFY_IS_APPROX ( ( p * p ) . matrix ( ) , p_m * p_m ) ; VERIFY_IS_APPROX ( ( a * a ) . matrix ( ) , a_m * a_m ) ; VERIFY_IS_APPROX ( ( p * a ) . matrix ( ) , p_m * a_m ) ; VERIFY_IS_APPROX ( ( a * p ) . matrix ( ) , a_m * p_m ) ; VERIFY_IS_APPROX ( ( ac * a ) . matrix ( ) , a_m * a_m ) ; VERIFY_IS_APPROX ( ( a * ac ) . matrix ( ) , a_m * a_m ) ; VERIFY_IS_APPROX ( ( p * ac ) . matrix ( ) , p_m * a_m ) ; VERIFY_IS_APPROX ( ( ac * p ) . matrix ( ) , a_m * p_m ) ; } void test_geo_transformations ( ) { for ( int i = 0 ; i < g_repeat ; i ++ ) { CALL_SUBTEST_1 ( ( transformations < double , Affine , AutoAlign > ( ) ) ) ; CALL_SUBTEST_1 ( ( non_projective_only < double , Affine , AutoAlign > ( ) ) ) ; CALL_SUBTEST_2 ( ( transformations < float , AffineCompact , AutoAlign > ( ) ) ) ; CALL_SUBTEST_2 ( ( non_projective_only < float , AffineCompact , AutoAlign > ( ) ) ) ; CALL_SUBTEST_2 ( ( transform_alignment < float > ( ) ) ) ; CALL_SUBTEST_3 ( ( transformations < double , Projective , AutoAlign > ( ) ) ) ; CALL_SUBTEST_3 ( ( transformations < double , Projective , DontAlign > ( ) ) ) ; CALL_SUBTEST_3 ( ( transform_alignment < double > ( ) ) ) ; CALL_SUBTEST_4 ( ( transformations < float , Affine , RowMajor | AutoAlign > ( ) ) ) ; CALL_SUBTEST_4 ( ( non_projective_only < float , Affine , RowMajor > ( ) ) ) ; CALL_SUBTEST_5 ( ( transformations < double , AffineCompact , RowMajor | AutoAlign > ( ) ) ) ; CALL_SUBTEST_5 ( ( non_projective_only < double , AffineCompact , RowMajor > ( ) ) ) ; CALL_SUBTEST_6 ( ( transformations < double , Projective , RowMajor | AutoAlign > ( ) ) ) ; CALL_SUBTEST_6 ( ( transformations < double , Projective , RowMajor | DontAlign > ( ) ) ) ; CALL_SUBTEST_7 ( ( transform_products < double , 3 , RowMajor | AutoAlign > ( ) ) ) ; CALL_SUBTEST_7 ( ( transform_products < float , 2 , AutoAlign > ( ) ) ) ; CALL_SUBTEST_8 ( ( transform_associativity < double , 2 , ColMajor > ( Rotation2D < double > ( internal :: random < double > ( ) * double ( EIGEN_PI ) ) ) ) ) ; CALL_SUBTEST_8 ( ( transform_associativity < double , 3 , ColMajor > ( Quaterniond :: UnitRandom ( ) ) ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="jamesfowkes/DataLogger/tree/master/libraries/DLDataField/DLDataField.Manager.cpp"> # ifdef ARDUINO # include < Arduino . h > # else # include < stdint . h > # include < stdio . h > # include < string . h > # endif # ifdef TEST # include < iostream > # endif # include " DLUtility . Averager . h " # include " DLDataField . Types . h " # include " DLDataField . h " # include " DLDataField . Manager . h " # include " DLSettings . Reader . Errors . h " # include " DLSettings . DataChannels . h " # include " DLUtility . h " # include " DLUtility . ArrayFunctions . h " # include " DLPlatform . h " DataFieldManager :: DataFieldManager ( uint32_t dataSize , uint32_t averagerSize ) { m_dataSize = dataSize ; m_averagerSize = averagerSize ; m_fieldCount = 0 ; m_dataCount = 0 ; uint8_t i = 0 ; for ( i = 0 ; i < MAX_FIELDS ; i ++ ) { m_fields [ i ] = NULL ; } } uint8_t DataFieldManager :: fieldCount ( ) { return m_fieldCount ; } bool DataFieldManager :: addField ( NumericDataField * field ) { if ( ! field ) { return false ; } if ( m_fieldCount == MAX_FIELDS ) { return false ; } PLATFORM_specialFieldSetup ( field ) ; field -> setDataSizes ( m_dataSize , m_averagerSize ) ; m_fields [ m_fieldCount ] = field ; m_channelNumbers [ m_fieldCount ] = field -> getChannelNumber ( ) ; m_fieldCount ++ ; return true ; } bool DataFieldManager :: addField ( StringDataField * field ) { if ( ! field ) { return false ; } if ( m_fieldCount == MAX_FIELDS ) { return false ; } m_fields [ m_fieldCount ] = field ; m_channelNumbers [ m_fieldCount ] = field -> getChannelNumber ( ) ; m_fieldCount ++ ; return true ; } void DataFieldManager :: storeDataArray ( int32_t * data ) { uint16_t field = 0 ; uint16_t dataIndex ; bool newAverageStored = false ; for ( field = 0 ; field < m_fieldCount ; field ++ ) { NumericDataField * pField = ( NumericDataField * ) m_fields [ field ] ; if ( pField ) { dataIndex = m_channelNumbers [ field ] - 1 ; newAverageStored |= pField -> storeData ( data [ dataIndex ] ) ; } } if ( newAverageStored ) { m_dataCount ++ ; } } void DataFieldManager :: getDataArray ( float * buffer , bool converted , bool alsoRemove ) { uint16_t field ; for ( field = 0 ; field < m_fieldCount ; ++ field ) { if ( converted ) { buffer [ field ] = ( ( NumericDataField * ) m_fields [ field ] ) -> getConvData ( alsoRemove ) ; } else { buffer [ field ] = ( ( NumericDataField * ) m_fields [ field ] ) -> getRawData ( alsoRemove ) ; } } if ( alsoRemove ) { m_dataCount -- ; } } DataField * DataFieldManager :: getChannel ( uint8_t channel ) { int32_t actualIndex = indexOf ( m_channelNumbers , ( uint32_t ) channel , m_fieldCount ) ; return actualIndex >= 0 ? m_fields [ actualIndex ] : NULL ; } DataField * DataFieldManager :: getField ( uint8_t index ) { return m_fields [ index ] ; } DataField * * DataFieldManager :: getFields ( void ) { return m_fields ; } uint32_t DataFieldManager :: writeHeadersToBuffer ( char * buffer , uint8_t bufferLength ) { if ( ! buffer ) { return 0 ; } uint8_t i ; FixedLengthAccumulator headerAccumulator ( buffer , bufferLength ) ; for ( i = 0 ; i < m_fieldCount ; ++ i ) { headerAccumulator . writeString ( m_fields [ i ] -> getTypeString ( ) ) ; if ( ! lastinloop ( i , m_fieldCount ) ) { headerAccumulator . writeString ( " , ▁ " ) ; } } headerAccumulator . writeString ( " \n " ) ; return headerAccumulator . length ( ) ; } void DataFieldManager :: setupAllValidChannels ( void ) { uint8_t ch ; NumericDataField * field ; FIELD_TYPE type ; void * data ; uint32_t maxChannels = Settings_GetMaxChannels ( ) ; for ( ch = 1 ; ch < maxChannels ; ch ++ ) { if ( Settings_ChannelSettingIsValid ( ch ) ) { type = Settings_GetChannelType ( ch ) ; data = Settings_GetData ( ch ) ; switch ( type ) { case VOLTAGE : case CURRENT : case TEMPERATURE_C : case TEMPERATURE_K : case TEMPERATURE_F : field = new NumericDataField ( type , data , ch ) ; # ifdef TEST std :: cout << " Adding ▁ channel ▁ " << ( int ) ch << " , ▁ type ▁ " << field -> getTypeString ( ) << std :: endl ; # endif addField ( field ) ; break ; default : break ; } } } } bool DataFieldManager :: hasData ( void ) { uint8_t i = 0 ; bool atLeastOneFieldHasData = false ; for ( i = 0 ; i < m_fieldCount ; i ++ ) { atLeastOneFieldHasData |= m_fields [ i ] -> hasData ( ) ; } return atLeastOneFieldHasData ; } uint32_t DataFieldManager :: count ( void ) { return m_dataCount ; } uint32_t * DataFieldManager :: getChannelNumbers ( void ) { return m_channelNumbers ; } </DOCUMENT>
<DOCUMENT_ID="asuradaimao/dolphin/tree/master/Source/Core/Core/PowerPC/Interpreter/Interpreter_Integer.cpp"> # include " Core / PowerPC / Interpreter / Interpreter . h " void Interpreter :: Helper_UpdateCR0 ( u32 value ) { s64 sign_extended = ( s64 ) ( s32 ) value ; u64 cr_val = ( u64 ) sign_extended ; cr_val = ( cr_val & ~ ( 1ull << 61 ) ) | ( ( u64 ) GetXER_SO ( ) << 61 ) ; PowerPC :: ppcState . cr_val [ 0 ] = cr_val ; } void Interpreter :: Helper_UpdateCRx ( int idx , u32 value ) { s64 sign_extended = ( s64 ) ( s32 ) value ; u64 cr_val = ( u64 ) sign_extended ; cr_val = ( cr_val & ~ ( 1ull << 61 ) ) | ( ( u64 ) GetXER_SO ( ) << 61 ) ; PowerPC :: ppcState . cr_val [ idx ] = cr_val ; } u32 Interpreter :: Helper_Carry ( u32 _uValue1 , u32 _uValue2 ) { return _uValue2 > ( ~ _uValue1 ) ; } u32 Interpreter :: Helper_Mask ( int mb , int me ) { u32 begin = 0xFFFFFFFF >> mb ; u32 end = me < 31 ? ( 0xFFFFFFFF >> ( me + 1 ) ) : 0 ; u32 mask = begin ^ end ; if ( me < mb ) return ~ mask ; else return mask ; } void Interpreter :: addi ( UGeckoInstruction _inst ) { if ( _inst . RA ) rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + _inst . SIMM_16 ; else rGPR [ _inst . RD ] = _inst . SIMM_16 ; } void Interpreter :: addic ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 imm = ( u32 ) ( s32 ) _inst . SIMM_16 ; rGPR [ _inst . RD ] = a + imm ; SetCarry ( Helper_Carry ( a , imm ) ) ; } void Interpreter :: addic_rc ( UGeckoInstruction _inst ) { addic ( _inst ) ; Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addis ( UGeckoInstruction _inst ) { if ( _inst . RA ) rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + ( _inst . SIMM_16 << 16 ) ; else rGPR [ _inst . RD ] = ( _inst . SIMM_16 << 16 ) ; } void Interpreter :: andi_rc ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & _inst . UIMM ; Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: andis_rc ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & ( ( u32 ) _inst . UIMM << 16 ) ; Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: cmpi ( UGeckoInstruction _inst ) { Helper_UpdateCRx ( _inst . CRFD , rGPR [ _inst . RA ] - _inst . SIMM_16 ) ; } void Interpreter :: cmpli ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = _inst . UIMM ; int f ; if ( a < b ) f = 0x8 ; else if ( a > b ) f = 0x4 ; else f = 0x2 ; if ( GetXER_SO ( ) ) f |= 0x1 ; SetCRField ( _inst . CRFD , f ) ; } void Interpreter :: mulli ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = ( s32 ) rGPR [ _inst . RA ] * _inst . SIMM_16 ; } void Interpreter :: ori ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | _inst . UIMM ; } void Interpreter :: oris ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | ( _inst . UIMM << 16 ) ; } void Interpreter :: subfic ( UGeckoInstruction _inst ) { s32 immediate = _inst . SIMM_16 ; rGPR [ _inst . RD ] = immediate - ( int ) rGPR [ _inst . RA ] ; SetCarry ( ( rGPR [ _inst . RA ] == 0 ) || ( Helper_Carry ( 0 - rGPR [ _inst . RA ] , immediate ) ) ) ; } void Interpreter :: twi ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = _inst . SIMM_16 ; s32 TO = _inst . TO ; DEBUG_LOG ( POWERPC , " twi ▁ rA ▁ % x ▁ SIMM ▁ % x ▁ TO ▁ % 0x " , a , b , TO ) ; if ( ( ( a < b ) && ( TO & 0x10 ) ) || ( ( a > b ) && ( TO & 0x08 ) ) || ( ( a == b ) && ( TO & 0x04 ) ) || ( ( ( u32 ) a < ( u32 ) b ) && ( TO & 0x02 ) ) || ( ( ( u32 ) a > ( u32 ) b ) && ( TO & 0x01 ) ) ) { PowerPC :: ppcState . Exceptions |= EXCEPTION_PROGRAM ; PowerPC :: CheckExceptions ( ) ; m_EndBlock = true ; } } void Interpreter :: xori ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ _inst . UIMM ; } void Interpreter :: xoris ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ ( _inst . UIMM << 16 ) ; } void Interpreter :: rlwimix ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = ( rGPR [ _inst . RA ] & ~ mask ) | ( _rotl ( rGPR [ _inst . RS ] , _inst . SH ) & mask ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: rlwinmx ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = _rotl ( rGPR [ _inst . RS ] , _inst . SH ) & mask ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: rlwnmx ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = _rotl ( rGPR [ _inst . RS ] , rGPR [ _inst . RB ] & 0x1F ) & mask ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: andx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: andcx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & ~ rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: cmp ( UGeckoInstruction _inst ) { s32 a = ( s32 ) rGPR [ _inst . RA ] ; s32 b = ( s32 ) rGPR [ _inst . RB ] ; int fTemp ; if ( a < b ) fTemp = 0x8 ; else if ( a > b ) fTemp = 0x4 ; else fTemp = 0x2 ; if ( GetXER_SO ( ) ) fTemp |= 0x1 ; SetCRField ( _inst . CRFD , fTemp ) ; } void Interpreter :: cmpl ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 fTemp ; if ( a < b ) fTemp = 0x8 ; else if ( a > b ) fTemp = 0x4 ; else fTemp = 0x2 ; if ( GetXER_SO ( ) ) fTemp |= 0x1 ; SetCRField ( _inst . CRFD , fTemp ) ; } void Interpreter :: cntlzwx ( UGeckoInstruction _inst ) { u32 val = rGPR [ _inst . RS ] ; u32 mask = 0x80000000 ; int i = 0 ; for ( ; i < 32 ; i ++ , mask >>= 1 ) { if ( val & mask ) break ; } rGPR [ _inst . RA ] = i ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: eqvx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] ^ rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: extsbx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ( u32 ) ( s32 ) ( s8 ) rGPR [ _inst . RS ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: extshx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ( u32 ) ( s32 ) ( s16 ) rGPR [ _inst . RS ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: nandx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] & rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: norx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] | rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: orx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: orcx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | ( ~ rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: slwx ( UGeckoInstruction _inst ) { u32 amount = rGPR [ _inst . RB ] ; rGPR [ _inst . RA ] = ( amount & 0x20 ) ? 0 : rGPR [ _inst . RS ] << ( amount & 0x1f ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: srawx ( UGeckoInstruction _inst ) { int rb = rGPR [ _inst . RB ] ; if ( rb & 0x20 ) { if ( rGPR [ _inst . RS ] & 0x80000000 ) { rGPR [ _inst . RA ] = 0xFFFFFFFF ; SetCarry ( 1 ) ; } else { rGPR [ _inst . RA ] = 0x00000000 ; SetCarry ( 0 ) ; } } else { int amount = rb & 0x1f ; if ( amount == 0 ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ; SetCarry ( 0 ) ; } else { s32 rrs = rGPR [ _inst . RS ] ; rGPR [ _inst . RA ] = rrs >> amount ; if ( ( rrs < 0 ) && ( rrs << ( 32 - amount ) ) ) SetCarry ( 1 ) ; else SetCarry ( 0 ) ; } } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: srawix ( UGeckoInstruction _inst ) { int amount = _inst . SH ; if ( amount != 0 ) { s32 rrs = rGPR [ _inst . RS ] ; rGPR [ _inst . RA ] = rrs >> amount ; if ( ( rrs < 0 ) && ( rrs << ( 32 - amount ) ) ) SetCarry ( 1 ) ; else SetCarry ( 0 ) ; } else { SetCarry ( 0 ) ; rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: srwx ( UGeckoInstruction _inst ) { u32 amount = rGPR [ _inst . RB ] ; rGPR [ _inst . RA ] = ( amount & 0x20 ) ? 0 : ( rGPR [ _inst . RS ] >> ( amount & 0x1f ) ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: tw ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = rGPR [ _inst . RB ] ; s32 TO = _inst . TO ; DEBUG_LOG ( POWERPC , " tw ▁ rA ▁ % 0x ▁ rB ▁ % 0x ▁ TO ▁ % 0x " , a , b , TO ) ; if ( ( ( a < b ) && ( TO & 0x10 ) ) || ( ( a > b ) && ( TO & 0x08 ) ) || ( ( a == b ) && ( TO & 0x04 ) ) || ( ( ( u32 ) a < ( u32 ) b ) && ( TO & 0x02 ) ) || ( ( ( u32 ) a > ( u32 ) b ) && ( TO & 0x01 ) ) ) { PowerPC :: ppcState . Exceptions |= EXCEPTION_PROGRAM ; PowerPC :: CheckExceptions ( ) ; m_EndBlock = true ; } } void Interpreter :: xorx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: addx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + rGPR [ _inst . RB ] ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addcx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = a + b ; SetCarry ( Helper_Carry ( a , b ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addcx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; int b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = a + b + carry ; SetCarry ( Helper_Carry ( a , b ) || ( carry != 0 && Helper_Carry ( a + b , carry ) ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addmex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; rGPR [ _inst . RD ] = a + carry - 1 ; SetCarry ( Helper_Carry ( a , carry - 1 ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addmex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addzex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; rGPR [ _inst . RD ] = a + carry ; SetCarry ( Helper_Carry ( a , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addzex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: divwx ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = rGPR [ _inst . RB ] ; if ( b == 0 || ( ( u32 ) a == 0x80000000 && b == - 1 ) ) { if ( _inst . OE ) { PanicAlert ( " OE : ▁ divwx " ) ; } if ( ( ( u32 ) a & 0x80000000 ) && b == 0 ) rGPR [ _inst . RD ] = - 1 ; else rGPR [ _inst . RD ] = 0 ; } else { rGPR [ _inst . RD ] = ( u32 ) ( a / b ) ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: divwux ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; if ( b == 0 ) { if ( _inst . OE ) { PanicAlert ( " OE : ▁ divwux " ) ; } rGPR [ _inst . RD ] = 0 ; } else { rGPR [ _inst . RD ] = a / b ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: mulhwx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( u64 ) ( ( ( s64 ) ( s32 ) a * ( s64 ) ( s32 ) b ) ) >> 32 ) ; rGPR [ _inst . RD ] = d ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: mulhwux ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( ( u64 ) a * ( u64 ) b ) >> 32 ) ; rGPR [ _inst . RD ] = d ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: mullwx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( s32 ) a * ( s32 ) b ) ; rGPR [ _inst . RD ] = d ; if ( _inst . OE ) PanicAlert ( " OE : ▁ mullwx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: negx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = ( ~ rGPR [ _inst . RA ] ) + 1 ; if ( rGPR [ _inst . RD ] == 0x80000000 ) { if ( _inst . OE ) PanicAlert ( " OE : ▁ negx " ) ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = rGPR [ _inst . RB ] - rGPR [ _inst . RA ] ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfcx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = b - a ; SetCarry ( a == 0 || Helper_Carry ( b , 0 - a ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfcx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + b + carry ; SetCarry ( Helper_Carry ( ~ a , b ) || Helper_Carry ( ( ~ a ) + b , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfmex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + carry - 1 ; SetCarry ( Helper_Carry ( ~ a , carry - 1 ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfmex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfzex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + carry ; SetCarry ( Helper_Carry ( ~ a , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfzex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } </DOCUMENT>
<DOCUMENT_ID="Baha/z3/tree/master/src/qe/qe_arith_plugin.cpp"> # include " qe . h " # include " ast _ pp . h " # include " expr _ safe _ replace . h " # include " bool _ rewriter . h " # include " bv _ decl _ plugin . h " # include " arith _ decl _ plugin . h " # include " arith _ eq _ solver . h " # include " arith _ rewriter . h " # include " th _ rewriter . h " # include " factor _ rewriter . h " # include " obj _ pair _ hashtable . h " # include " nlarith _ util . h " # include " model _ evaluator . h " # include " smt _ kernel . h " namespace qe { class bound { rational m_coeff ; expr_ref m_term ; bool m_is_strict ; public : bound ( ast_manager & m , rational const & n , expr * t , bool is_strict ) : m_coeff ( n ) , m_term ( t , m ) , m_is_strict ( is_strict ) { } bool is_strict ( ) const { return m_is_strict ; } expr * term ( ) const { return m_term . get ( ) ; } rational const & coeff ( ) const { return m_coeff ; } void update ( rational const & k , expr * t ) { m_coeff = k ; m_term = t ; } void pp ( std :: ostream & out , app * x ) { ast_manager & m = m_term . get_manager ( ) ; out << " ( < = ▁ ( + ▁ ( * ▁ " << coeff ( ) << " ▁ " << mk_pp ( x , m ) << " ) ▁ " << mk_pp ( term ( ) , m ) << " ) ▁ 0 ) " ; } } ; typedef rational numeral ; class div_constraint { numeral m_k ; numeral m_a ; expr * m_term ; public : div_constraint ( numeral const & k , numeral const & a , expr * t ) : m_k ( k ) , m_a ( a ) , m_term ( t ) { } numeral const & a ( ) const { return m_a ; } numeral const & k ( ) const { return m_k ; } expr * t ( ) const { return m_term ; } numeral & a_ref ( ) { return m_a ; } numeral & k_ref ( ) { return m_k ; } expr * & t_ref ( ) { return m_term ; } } ; typedef vector < div_constraint > div_constraints ; class arith_qe_util { ast_manager & m ; i_solver_context & m_ctx ; public : arith_util m_arith ; th_rewriter simplify ; private : arith_eq_solver m_arith_solver ; bv_util m_bv ; expr_ref m_zero_i ; expr_ref m_one_i ; expr_ref m_minus_one_i ; expr_ref m_zero_r ; expr_ref m_one_r ; expr_ref m_tmp ; public : expr_safe_replace m_replace ; bool_rewriter m_bool_rewriter ; arith_rewriter m_arith_rewriter ; arith_qe_util ( ast_manager & m , smt_params & p , i_solver_context & ctx ) : m ( m ) , m_ctx ( ctx ) , m_arith ( m ) , simplify ( m ) , m_arith_solver ( m ) , m_bv ( m ) , m_zero_i ( m_arith . mk_numeral ( numeral ( 0 ) , true ) , m ) , m_one_i ( m_arith . mk_numeral ( numeral ( 1 ) , true ) , m ) , m_minus_one_i ( m_arith . mk_numeral ( numeral ( - 1 ) , true ) , m ) , m_zero_r ( m_arith . mk_numeral ( numeral ( 0 ) , false ) , m ) , m_one_r ( m_arith . mk_numeral ( numeral ( 1 ) , false ) , m ) , m_tmp ( m ) , m_replace ( m ) , m_bool_rewriter ( m ) , m_arith_rewriter ( m ) { } ast_manager & get_manager ( ) { return m ; } bool get_coeff ( contains_app & contains_x , expr * p , rational & k , expr_ref & rest ) { app * x = contains_x . x ( ) ; ptr_vector < expr > restl , todo ; todo . push_back ( p ) ; bool found = false ; expr * e1 , * e2 ; while ( ! todo . empty ( ) ) { expr * e = todo . back ( ) ; todo . pop_back ( ) ; if ( m_arith . is_add ( e ) ) { for ( unsigned i = 0 ; i < to_app ( e ) -> get_num_args ( ) ; ++ i ) { todo . push_back ( to_app ( e ) -> get_arg ( i ) ) ; } } else if ( e == x ) { k = numeral ( 1 ) ; found = true ; break ; } else if ( m_arith . is_mul ( e , e1 , e2 ) && e1 == x && m_arith . is_numeral ( e2 , k ) ) { found = true ; break ; } else if ( m_arith . is_mul ( e , e1 , e2 ) && e2 == x && m_arith . is_numeral ( e1 , k ) ) { found = true ; break ; } else { restl . push_back ( e ) ; } } if ( ! found ) { TRACE ( " qe _ verbose " , tout << " Did ▁ not ▁ find : ▁ " << mk_pp ( x , m ) << " ▁ in ▁ " << mk_pp ( p , m ) << " \n " ; ) ; return false ; } while ( ! todo . empty ( ) ) { restl . push_back ( todo . back ( ) ) ; todo . pop_back ( ) ; } if ( restl . empty ( ) ) { rest = mk_zero ( x ) ; } else { rest = m_arith . mk_add ( restl . size ( ) , restl . c_ptr ( ) ) ; } if ( contains_x ( rest ) ) { return false ; } TRACE ( " qe _ verbose " , tout << mk_pp ( p , m ) << " ▁ = ▁ " << " ( + ▁ ( * ▁ " << k << " ▁ " << mk_pp ( x , m ) << " ) ▁ " << mk_pp ( rest , m ) << " ) \n " ; ) ; return true ; } void get_const ( expr * p , rational & k , expr_ref & rest ) { ptr_vector < expr > todo , restl ; todo . push_back ( p ) ; k = numeral ( 0 ) ; while ( ! todo . empty ( ) ) { p = todo . back ( ) ; todo . pop_back ( ) ; if ( m_arith . is_add ( p ) ) { for ( unsigned i = 0 ; i < to_app ( p ) -> get_num_args ( ) ; ++ i ) { todo . push_back ( to_app ( p ) -> get_arg ( i ) ) ; } } else if ( m_arith . is_numeral ( p , k ) ) { break ; } else { restl . push_back ( p ) ; } } while ( ! todo . empty ( ) ) { restl . push_back ( todo . back ( ) ) ; todo . pop_back ( ) ; } if ( restl . empty ( ) ) { rest = mk_zero ( p ) ; } else { rest = m_arith . mk_add ( restl . size ( ) , restl . c_ptr ( ) ) ; } } bool is_neg ( app * e , expr_ref & ne ) { if ( m . is_not ( e ) ) { ne = to_app ( e ) -> get_arg ( 0 ) ; return true ; } return false ; } bool is_le ( app * e , expr_ref & p ) { return is_le_ge_core < 1 > ( e , p ) ; } bool is_ge ( app * e , expr_ref & p ) { return is_le_ge_core < 0 > ( e , p ) ; } bool is_lt ( app * e , expr_ref & p ) { numeral k ; expr * a1 , * a2 ; if ( m_arith . is_lt ( e , a1 , a2 ) || m_arith . is_gt ( e , a2 , a1 ) ) { p = a1 ; if ( m_arith . is_numeral ( a2 , k ) && k . is_zero ( ) ) { return true ; } } else { return false ; } p = mk_sub ( p , a2 ) ; simplify ( p ) ; return true ; } bool is_divides ( app * e , numeral & k , expr_ref & p ) { expr * e1 , * e2 ; if ( ! m . is_eq ( e , e1 , e2 ) ) { return false ; } return is_divides ( e1 , e2 , k , p ) || is_divides ( e2 , e1 , k , p ) ; } bool is_divides ( expr * e1 , expr * e2 , numeral & k , expr_ref & p ) { if ( m_arith . is_mod ( e2 ) && m_arith . is_numeral ( e1 , k ) && k . is_zero ( ) && m_arith . is_numeral ( to_app ( e2 ) -> get_arg ( 1 ) , k ) ) { p = to_app ( e2 ) -> get_arg ( 0 ) ; return true ; } return false ; } bool is_not_divides ( app * e , app_ref & n , numeral & k , expr_ref & p ) { if ( ! m . is_not ( e ) ) { return false ; } if ( ! is_app ( to_app ( e ) -> get_arg ( 0 ) ) ) { return false ; } n = to_app ( to_app ( e ) -> get_arg ( 0 ) ) ; return is_divides ( n , k , p ) ; } bool is_real ( app * x ) const { return m_arith . is_real ( x ) ; } template < bool is_strict > void mk_bound_aux ( rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { SASSERT ( a . is_neg ( ) == b . is_neg ( ) ) ; expr_ref tt ( t , m ) , ss ( s , m ) , e ( m ) ; rational abs_a ( a ) ; rational abs_b ( b ) ; if ( abs_a . is_neg ( ) ) abs_a . neg ( ) ; if ( abs_b . is_neg ( ) ) abs_b . neg ( ) ; ss = mk_mul ( abs_a , ss ) ; tt = mk_mul ( abs_b , tt ) ; if ( a . is_neg ( ) ) { e = mk_sub ( tt , ss ) ; if ( is_strict ) { if ( m_arith . is_int ( e ) ) { e = mk_add ( e , m_one_i ) ; mk_le ( e , result ) ; } else { mk_lt ( e , result ) ; } } else { mk_le ( e , result ) ; } } else { e = mk_sub ( ss , tt ) ; if ( is_strict ) { if ( m_arith . is_int ( e ) ) { e = mk_add ( e , m_one_i ) ; mk_le ( e , result ) ; } else { mk_lt ( e , result ) ; } } else { mk_le ( e , result ) ; } } } void mk_bound ( rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { mk_bound_aux < false > ( a , t , b , s , result ) ; } void mk_strict_bound ( rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { mk_bound_aux < true > ( a , t , b , s , result ) ; } void mk_divides ( numeral n , expr * e , expr_ref & result ) { SASSERT ( n . is_int ( ) ) ; expr_ref tmp1 ( e , m ) , tmp2 ( m ) ; simplify ( tmp1 ) ; m_arith_rewriter . mk_mod ( tmp1 , mk_numeral ( n ) , tmp2 ) ; m_bool_rewriter . mk_eq ( m_zero_i , tmp2 , result ) ; } void mk_div ( expr * a , numeral const & k , expr_ref & result ) { result = m_arith . mk_div ( a , m_arith . mk_numeral ( k , false ) ) ; simplify ( result ) ; } expr * mk_numeral ( numeral const & k , bool is_int = true ) { return m_arith . mk_numeral ( k , is_int ) ; } expr * mk_numeral ( int k , bool is_int ) { return mk_numeral ( numeral ( k ) , is_int ) ; } expr * mk_uminus ( expr * e ) { return m_arith . mk_uminus ( e ) ; } expr * mk_abs ( expr * e ) { rational val ; if ( m_arith . is_numeral ( e , val ) ) { if ( val . is_neg ( ) ) { return m_arith . mk_uminus ( e ) ; } else { return e ; } } else { return m . mk_ite ( m_arith . mk_le ( mk_zero ( e ) , e ) , e , m_arith . mk_uminus ( e ) ) ; } } template < bool is_max > expr_ref mk_min_max ( unsigned num_args , expr * const * args ) { SASSERT ( num_args > 0 ) ; if ( num_args == 1 ) { return expr_ref ( args [ 0 ] , m ) ; } else { expr_ref e2 = mk_min_max < is_max > ( num_args - 1 , args + 1 ) ; expr * e1 = args [ 0 ] ; expr * cmp = is_max ? m_arith . mk_le ( e1 , e2 ) : m_arith . mk_le ( e2 , e1 ) ; return expr_ref ( m . mk_ite ( cmp , e2 , e1 ) , m ) ; } } expr_ref mk_max ( unsigned num_args , expr * const * args ) { return mk_min_max < true > ( num_args , args ) ; } expr_ref mk_min ( unsigned num_args , expr * const * args ) { return mk_min_max < false > ( num_args , args ) ; } expr * mk_mul ( expr * a , expr * b ) { return m_arith . mk_mul ( a , b ) ; } expr * mk_add ( expr * a , expr * b ) { return m_arith . mk_add ( a , b ) ; } expr * mk_sub ( expr * a , expr * b ) { return m_arith . mk_sub ( a , b ) ; } expr * mk_mul ( numeral const & a , expr * b ) { if ( a . is_one ( ) ) return b ; return m_arith . mk_mul ( mk_numeral ( a , m_arith . is_int ( b ) ) , b ) ; } expr * mk_zero ( sort * s ) { return m_arith . is_int ( s ) ? m_zero_i : m_zero_r ; } expr * mk_zero ( expr * e ) { return m_arith . is_int ( e ) ? m_zero_i : m_zero_r ; } expr * mk_one ( sort * s ) { return m_arith . is_int ( s ) ? m_one_i : m_one_r ; } expr * mk_one ( expr * e ) { return m_arith . is_int ( e ) ? m_one_i : m_one_r ; } void mk_le ( expr * e , expr_ref & result ) { expr_ref tmp ( e , m ) ; simplify ( tmp ) ; m_arith_rewriter . mk_le ( tmp , mk_zero ( e ) , result ) ; } void mk_lt ( expr * e , expr_ref & result ) { rational r ; if ( m_arith . is_numeral ( e , r ) ) { if ( r . is_neg ( ) ) { result = m . mk_true ( ) ; } else { result = m . mk_false ( ) ; } } else if ( m_arith . is_int ( e ) ) { result = m_arith . mk_le ( e , m_minus_one_i ) ; } else { result = m . mk_not ( m_arith . mk_le ( mk_zero ( e ) , e ) ) ; } simplify ( result ) ; TRACE ( " qe _ verbose " , tout << " mk _ lt ▁ " << mk_pp ( result , m ) << " \n " ; ) ; } void mk_eq ( rational const & a , app * x , expr * t , expr_ref & result ) { result = m_arith . mk_eq ( mk_add ( mk_mul ( a , x ) , t ) , mk_zero ( x ) ) ; } void mk_and ( unsigned sz , expr * const * args , expr_ref & result ) { m_bool_rewriter . mk_and ( sz , args , result ) ; } void mk_and ( expr * e1 , expr * e2 , expr_ref & result ) { m_bool_rewriter . mk_and ( e1 , e2 , result ) ; } void add_and ( expr * e , ptr_vector < expr > & conjs ) { if ( m . is_and ( e ) ) { conjs . append ( to_app ( e ) -> get_num_args ( ) , to_app ( e ) -> get_args ( ) ) ; } else { conjs . push_back ( e ) ; } } void mk_flat_and ( expr * e1 , expr * e2 , expr_ref & result ) { ptr_vector < expr > conjs ; add_and ( e1 , conjs ) ; add_and ( e2 , conjs ) ; m_bool_rewriter . mk_and ( conjs . size ( ) , conjs . c_ptr ( ) , result ) ; } void mk_or ( unsigned sz , expr * const * args , expr_ref & result ) { m_bool_rewriter . mk_or ( sz , args , result ) ; } void mk_or ( expr * e1 , expr * e2 , expr_ref & result ) { m_bool_rewriter . mk_or ( e1 , e2 , result ) ; } void mk_resolve ( app * x , bool is_strict , rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { rational abs_a ( abs ( a ) ) , abs_b ( abs ( b ) ) ; SASSERT ( a . is_neg ( ) == b . is_pos ( ) ) ; SASSERT ( ! is_strict || ( abs_a . is_one ( ) && abs_b . is_one ( ) ) ) ; expr_ref bt ( mk_mul ( abs_b , t ) , m ) ; expr_ref as ( mk_mul ( abs_a , s ) , m ) ; expr_ref as_bt ( mk_add ( as , bt ) , m ) ; if ( is_strict ) { mk_lt ( as_bt , result ) ; } else { mk_le ( as_bt , result ) ; } if ( ! abs_a . is_one ( ) && ! abs_b . is_one ( ) ) { SASSERT ( ! is_strict ) ; SASSERT ( abs_a > rational :: one ( ) && abs_b > rational :: one ( ) ) ; expr_ref slack ( mk_numeral ( ( abs_a - numeral ( 1 ) ) * ( abs_b - numeral ( 1 ) ) , true ) , m ) ; expr_ref result1 ( m ) , result2 ( m ) ; expr_ref as_bt_le_0 ( result , m ) , tmp2 ( m ) , asz_bt_le_0 ( m ) , tmp3 ( m ) , tmp4 ( m ) ; expr_ref b_divides_sz ( m ) ; tmp2 = m_arith . mk_add ( as_bt , slack ) ; mk_le ( tmp2 , result1 ) ; rational a1 = a , b1 = b ; if ( abs_a < abs_b ) { std :: swap ( abs_a , abs_b ) ; std :: swap ( a1 , b1 ) ; std :: swap ( s , t ) ; std :: swap ( as , bt ) ; } SASSERT ( abs_a >= abs_b ) ; expr_ref sz ( mk_add ( s , x ) , m ) ; if ( b1 . is_pos ( ) ) { sz = m_arith . mk_uminus ( sz ) ; } tmp4 = mk_add ( mk_mul ( a1 , sz ) , bt ) ; mk_le ( tmp4 , asz_bt_le_0 ) ; if ( to_app ( asz_bt_le_0 ) -> get_arg ( 0 ) == x && m_arith . is_zero ( to_app ( asz_bt_le_0 ) -> get_arg ( 1 ) ) ) { mk_divides ( abs_b , s , tmp2 ) ; } else { mk_divides ( abs_b , sz , b_divides_sz ) ; mk_and ( b_divides_sz , asz_bt_le_0 , tmp4 ) ; mk_big_or ( abs_b - numeral ( 2 ) , x , tmp4 , tmp2 ) ; TRACE ( " qe " , tout << " b ▁ | ▁ s ▁ + ▁ z : ▁ " << mk_pp ( b_divides_sz , m ) << " \n " ; tout << " a ( s + z ) ▁ + ▁ bt ▁ < = ▁ 0 : ▁ " << mk_pp ( asz_bt_le_0 , m ) << " \n " ; ) ; } mk_flat_and ( as_bt_le_0 , tmp2 , result2 ) ; mk_or ( result1 , result2 , result ) ; simplify ( result ) ; } TRACE ( " qe " , { tout << ( is_strict ? " strict " : " non - strict " ) << " \n " ; bound ( m , a , t , false ) . pp ( tout , x ) ; tout << " \n " ; bound ( m , b , s , false ) . pp ( tout , x ) ; tout << " \n " ; tout << mk_pp ( result , m ) << " \n " ; } ) ; } struct mul_lt { arith_util & u ; mul_lt ( arith_qe_util & u ) : u ( u . m_arith ) { } bool operator ( ) ( expr * n1 , expr * n2 ) const { expr * x , * y ; if ( u . is_mul ( n1 , x , y ) && u . is_numeral ( x ) ) { n1 = y ; } if ( u . is_mul ( n2 , x , y ) && u . is_numeral ( x ) ) { n2 = y ; } return n1 -> get_id ( ) < n2 -> get_id ( ) ; } } ; void normalize_sum ( expr_ref & p ) { simplify ( p ) ; if ( ! m_arith . is_add ( p ) ) { return ; } unsigned sz = to_app ( p ) -> get_num_args ( ) ; ptr_buffer < expr > args ; for ( unsigned i = 0 ; i < sz ; ++ i ) { args . push_back ( to_app ( p ) -> get_arg ( i ) ) ; } std :: sort ( args . begin ( ) , args . end ( ) , mul_lt ( * this ) ) ; p = m_arith . mk_add ( args . size ( ) , args . c_ptr ( ) ) ; } void pp_div ( std :: ostream & out , app * x , div_constraint const & div ) { out << div . k ( ) << " ▁ | ▁ ( " << div . a ( ) << " * " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( div . t ( ) , m ) << " ) ▁ " ; } void pp_divs ( std :: ostream & out , app * x , div_constraints const & divs ) { for ( unsigned i = 0 ; i < divs . size ( ) ; ++ i ) { pp_div ( out , x , divs [ i ] ) ; out << " ▁ " ; } } bool mk_atom ( expr * e , bool p , expr_ref & result ) { if ( ! is_app ( e ) ) { return false ; } app * a = to_app ( e ) ; expr_ref t1 ( m ) , t2 ( m ) ; expr_ref tmp1 ( m ) , tmp2 ( m ) ; rational k ; expr * a0 , * a1 ; if ( p && is_divides ( a , k , tmp1 ) ) { result = e ; } else if ( ! p && is_divides ( a , k , tmp1 ) ) { m_bool_rewriter . mk_not ( e , result ) ; } else if ( p && m . is_eq ( e , a0 , a1 ) && is_arith ( a0 ) ) { t1 = mk_sub ( a0 , a1 ) ; simplify ( t1 ) ; t2 = mk_sub ( a1 , a0 ) ; simplify ( t2 ) ; mk_le ( t1 , tmp1 ) ; mk_le ( t2 , tmp2 ) ; mk_and ( tmp1 , tmp2 , result ) ; } else if ( ! p && m . is_eq ( e , a0 , a1 ) && m_arith . is_int ( a0 ) ) { tmp1 = mk_sub ( a0 , a1 ) ; t1 = mk_add ( mk_one ( a0 ) , tmp1 ) ; simplify ( t1 ) ; t2 = mk_sub ( mk_one ( a0 ) , tmp1 ) ; simplify ( t2 ) ; mk_le ( t1 , tmp1 ) ; mk_le ( t2 , tmp2 ) ; mk_or ( tmp1 , tmp2 , result ) ; } else if ( ! p && m . is_eq ( e , a0 , a1 ) && m_arith . is_real ( a0 ) ) { t1 = mk_sub ( a0 , a1 ) ; simplify ( t1 ) ; t2 = mk_sub ( a1 , a0 ) ; simplify ( t2 ) ; mk_lt ( t1 , tmp1 ) ; mk_lt ( t2 , tmp2 ) ; mk_or ( tmp1 , tmp2 , result ) ; } else if ( ! p && ( m_arith . is_le ( e , a0 , a1 ) || m_arith . is_ge ( e , a1 , a0 ) ) ) { tmp1 = mk_sub ( a1 , a0 ) ; mk_lt ( tmp1 , result ) ; } else if ( p && ( m_arith . is_le ( e ) || m_arith . is_ge ( e ) ) ) { result = e ; } else if ( p && ( m_arith . is_lt ( e , a0 , a1 ) || m_arith . is_gt ( e , a1 , a0 ) ) ) { tmp1 = mk_sub ( a0 , a1 ) ; mk_lt ( tmp1 , result ) ; } else if ( ! p && ( m_arith . is_lt ( e , a0 , a1 ) || m_arith . is_gt ( e , a1 , a0 ) ) ) { tmp1 = mk_sub ( a1 , a0 ) ; mk_le ( tmp1 , result ) ; } else { return false ; } TRACE ( " qe _ verbose " , tout << " Atom : ▁ " << mk_pp ( result , m ) << " \n " ; ) ; return true ; } void mk_bounded_var ( rational const & n , app_ref & z_bv , app_ref & z ) { rational two ( 2 ) , b ( n ) ; unsigned sz = 0 ; do { ++ sz ; b = div ( b , two ) ; } while ( b . is_pos ( ) ) ; sort * s = m_bv . mk_sort ( sz ) ; z_bv = m . mk_fresh_const ( " z " , s ) ; expr_ref tmp ( m ) ; z = m_bv . mk_bv2int ( z_bv ) ; } bool solve ( conj_enum & conjs , expr * fml ) { expr_ref_vector eqs ( m ) ; extract_equalities ( conjs , eqs ) ; return reduce_equations ( eqs . size ( ) , eqs . c_ptr ( ) , fml ) ; } void extract_equalities ( conj_enum & conjs , expr_ref_vector & eqs ) { obj_hashtable < expr > leqs ; expr_ref_vector trail ( m ) ; expr_ref tmp1 ( m ) , tmp2 ( m ) ; expr * a0 , * a1 ; eqs . reset ( ) ; conj_enum :: iterator it = conjs . begin ( ) , end = conjs . end ( ) ; for ( ; it != end ; ++ it ) { expr * e = * it ; bool is_leq = false ; if ( m . is_eq ( e , a0 , a1 ) && is_arith ( a0 ) ) { m_arith_rewriter . mk_sub ( a0 , a1 , tmp1 ) ; simplify ( tmp1 ) ; eqs . push_back ( tmp1 ) ; } else if ( m_arith . is_le ( e , a0 , a1 ) || m_arith . is_ge ( e , a1 , a0 ) ) { m_arith_rewriter . mk_sub ( a0 , a1 , tmp1 ) ; is_leq = true ; } else { } if ( is_leq ) { normalize_sum ( tmp1 ) ; tmp2 = m_arith . mk_uminus ( tmp1 ) ; normalize_sum ( tmp2 ) ; if ( leqs . contains ( tmp2 ) ) { eqs . push_back ( tmp1 ) ; TRACE ( " qe " , tout << " found : ▁ ▁ " << mk_pp ( tmp1 , m ) << " \n " ; ) ; } else { trail . push_back ( tmp1 ) ; leqs . insert ( tmp1 ) ; TRACE ( " qe _ verbose " , tout << " insert : ▁ " << mk_pp ( tmp1 , m ) << " \n " ; ) ; } } } } private : template < unsigned IS_LE > bool is_le_ge_core ( app * e , expr_ref & p ) { numeral k ; expr_ref tmp ( m ) ; expr * a2 ; if ( m_arith . is_le ( e ) ) { p = e -> get_arg ( 1 - IS_LE ) ; a2 = e -> get_arg ( IS_LE ) ; if ( m_arith . is_numeral ( a2 , k ) && k . is_zero ( ) ) { return true ; } } else if ( m_arith . is_ge ( e ) ) { p = e -> get_arg ( IS_LE ) ; a2 = e -> get_arg ( 1 - IS_LE ) ; if ( m_arith . is_numeral ( a2 , k ) && k . is_zero ( ) ) { return true ; } } else { return false ; } p = mk_sub ( p , a2 ) ; simplify ( p ) ; return true ; } bool is_arith ( expr * e ) { return m_arith . is_int ( e ) || m_arith . is_real ( e ) ; } void mk_big_or ( numeral up , app * x , expr * body , expr_ref & result ) { TRACE ( " qe " , tout << mk_pp ( x , m ) << " ▁ " << mk_pp ( body , m ) << " \n " ; ) ; if ( numeral ( 1 ) >= up ) { mk_big_or_blast ( up , x , body , result ) ; } else { mk_big_or_symbolic_blast ( up , x , body , result ) ; } } void mk_big_or_blast ( numeral up , app * x , expr * body , expr_ref & result ) { expr_ref_vector ors ( m ) ; numeral index ( 0 ) ; while ( index <= up ) { expr * n = mk_numeral ( index ) ; result = body ; m_replace . apply_substitution ( x , n , result ) ; ors . push_back ( result ) ; ++ index ; } mk_or ( ors . size ( ) , ors . c_ptr ( ) , result ) ; TRACE ( " qe " , tout << " [ 0 ▁ " << up << " ] ▁ " << mk_pp ( x , m ) << " \n " << mk_pp ( body , m ) << " \n " << mk_pp ( result , m ) << " \n " ; ) ; } void mk_big_or_symbolic ( numeral up , app * x , expr * body , expr_ref & result ) { app_ref z_bv ( m ) ; mk_big_or_symbolic ( up , x , body , z_bv , result ) ; m_ctx . add_var ( z_bv ) ; } void mk_big_or_symbolic_blast ( numeral up , app * x , expr * body , expr_ref & result ) { app_ref z_bv ( m ) ; mk_big_or_symbolic ( up , x , body , z_bv , result ) ; m_ctx . blast_or ( z_bv , result ) ; } void mk_big_or_symbolic ( numeral up , app * x , expr * body , app_ref & z_bv , expr_ref & result ) { expr * e1 = m_arith . mk_le ( x , m_arith . mk_numeral ( up , true ) ) ; mk_flat_and ( e1 , body , result ) ; app_ref z ( m ) ; mk_bounded_var ( up , z_bv , z ) ; m_replace . apply_substitution ( x , z , result ) ; } bool isolate_x ( expr * p , app * x , contains_app & contains_x , numeral & coeff ) { numeral k ; while ( m_arith . is_add ( p ) ) { bool found_x = false ; expr * next_p = 0 ; for ( unsigned i = 0 ; i < to_app ( p ) -> get_num_args ( ) ; ++ i ) { expr * arg = to_app ( p ) -> get_arg ( i ) ; if ( contains_x ( arg ) ) { if ( found_x ) { return false ; } found_x = true ; next_p = arg ; } } if ( ! next_p ) { return false ; } p = next_p ; } expr * e1 , * e2 ; if ( p == x ) { coeff = numeral ( 1 ) ; return true ; } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e1 , k ) && e2 == x ) { coeff = k ; return true ; } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e2 , k ) && e1 == x ) { coeff = k ; return true ; } return false ; } bool reduce_equations ( unsigned num_eqs , expr * const * eqs , expr * fml ) { for ( unsigned i = 0 ; i < num_eqs ; ++ i ) { if ( reduce_equation ( eqs [ i ] , fml ) ) { return true ; } } return false ; } bool solve_singular ( unsigned var_idx , expr * p , expr * fml ) { rational k ; expr_ref e ( m ) , tmp ( m ) ; app * x = m_ctx . get_var ( var_idx ) ; if ( ! isolate_x ( p , x , m_ctx . contains ( var_idx ) , k ) ) { return false ; } if ( m_arith . is_int ( x ) && ! ( abs ( k ) . is_one ( ) ) ) { return false ; } if ( abs ( k ) . is_one ( ) ) { if ( k . is_neg ( ) ) { e = m_arith . mk_add ( p , x ) ; } else { e = m_arith . mk_sub ( x , p ) ; } } else { SASSERT ( ! m_arith . is_int ( x ) ) ; expr * ke = m_arith . mk_numeral ( - k , false ) ; tmp = m_arith . mk_mul ( ke , x ) ; tmp = m_arith . mk_add ( p , tmp ) ; e = m_arith . mk_div ( tmp , ke ) ; } TRACE ( " qe " , tout << " is ▁ singular : \n " << mk_pp ( p , m ) << " \n " << mk_pp ( fml , m ) << " \n " << mk_pp ( x , m ) << " ▁ = ▁ " << mk_pp ( e , m ) << " \n " ; ) ; expr_ref result ( fml , m ) ; m_replace . apply_substitution ( x , e , result ) ; simplify ( result ) ; TRACE ( " qe " , tout << " singular ▁ solved : \n " << mk_pp ( result , m ) << " \n " ; ) ; m_ctx . elim_var ( var_idx , result , e ) ; return true ; } bool solve_singular ( expr * p , expr * fml ) { unsigned num_vars = m_ctx . get_num_vars ( ) ; for ( unsigned i = 0 ; i < num_vars ; ++ i ) { if ( solve_singular ( i , p , fml ) ) { return true ; } } return false ; } bool solve_linear ( expr * p , expr * fml ) { vector < numeral > values ; unsigned num_vars = m_ctx . get_num_vars ( ) ; app * const * vars_ptr = m_ctx . get_vars ( ) ; if ( ! is_linear ( p , num_vars , vars_ptr , values ) ) { return false ; } TRACE ( " qe " , tout << " is ▁ linear : ▁ " << mk_pp ( p , m ) << " \n " ; ) ; SASSERT ( values . size ( ) == num_vars + 1 ) ; SASSERT ( num_vars > 0 ) ; unsigned index ; bool is_aux ; VERIFY ( m_arith_solver . solve_integer_equation ( values , index , is_aux ) ) ; SASSERT ( 1 <= index && index <= num_vars ) ; app_ref x ( m_ctx . get_var ( index - 1 ) , m ) ; app_ref z ( m ) ; expr_ref p1 ( m ) ; if ( is_aux ) { SASSERT ( values [ index ] >= rational ( 3 ) ) ; z = m . mk_fresh_const ( " x " , m_arith . mk_int ( ) ) ; m_ctx . add_var ( z ) ; p1 = m_arith . mk_mul ( m_arith . mk_numeral ( values [ index ] , true ) , z ) ; } else { p1 = m_arith . mk_numeral ( numeral ( 0 ) , true ) ; } for ( unsigned i = 1 ; i <= num_vars ; ++ i ) { numeral k = values [ i ] ; if ( ! k . is_zero ( ) && i != index ) { p1 = m_arith . mk_add ( p1 , m_arith . mk_mul ( m_arith . mk_numeral ( k , true ) , m_ctx . get_var ( i - 1 ) ) ) ; } } p1 = m_arith . mk_add ( p1 , m_arith . mk_numeral ( values [ 0 ] , true ) ) ; TRACE ( " qe " , tout << " is ▁ linear : \n " << mk_pp ( fml , m ) << " \n " << mk_pp ( p , m ) << " \n " << mk_pp ( x , m ) << " ▁ = ▁ " << mk_pp ( p1 , m ) << " \n " ; tout << values [ 0 ] << " ▁ + ▁ " ; for ( unsigned i = 0 ; i < num_vars ; ++ i ) { tout << " ▁ + ▁ " << values [ i + 1 ] << " ▁ * ▁ " << mk_pp ( m_ctx . get_var ( i ) , m ) << " ▁ " ; } tout << " ▁ = ▁ 0 \n " ; ) ; expr_ref result ( fml , m ) ; m_replace . apply_substitution ( x , p1 , result ) ; simplify ( result ) ; m_ctx . elim_var ( index - 1 , result , p1 ) ; TRACE ( " qe " , tout << " Reduced : ▁ " << mk_pp ( result , m ) << " \n " ; ) ; return true ; } bool reduce_equation ( expr * p , expr * fml ) { numeral k ; if ( m_arith . is_numeral ( p , k ) && k . is_zero ( ) ) { return false ; } return solve_singular ( p , fml ) || solve_linear ( p , fml ) ; } bool find_variable ( expr * p , unsigned num_vars , app * const * vars , numeral * values , numeral const & k ) { if ( ! is_app ( p ) || to_app ( p ) -> get_num_args ( ) > 0 ) { return false ; } for ( unsigned i = 0 ; i < num_vars ; ++ i ) { if ( p == vars [ i ] ) { values [ i ] += k ; return true ; } } return false ; } bool is_linear ( expr * p , unsigned num_vars , app * const * vars , vector < numeral > & values ) { if ( num_vars == 0 ) { return false ; } values . reset ( ) ; for ( unsigned i = 0 ; i <= num_vars ; ++ i ) { values . push_back ( numeral ( 0 ) ) ; } numeral * vars_ptr = values . c_ptr ( ) + 1 ; ptr_vector < expr > todo ; numeral k ; expr * e1 , * e2 ; todo . push_back ( p ) ; while ( ! todo . empty ( ) ) { p = todo . back ( ) ; todo . pop_back ( ) ; if ( m_arith . is_add ( p ) ) { for ( unsigned i = 0 ; i < to_app ( p ) -> get_num_args ( ) ; ++ i ) { todo . push_back ( to_app ( p ) -> get_arg ( i ) ) ; } } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e1 , k ) && find_variable ( e2 , num_vars , vars , vars_ptr , k ) ) { } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e2 , k ) && find_variable ( e1 , num_vars , vars , vars_ptr , k ) ) { } else if ( find_variable ( p , num_vars , vars , vars_ptr , k ) ) { } else if ( m_arith . is_numeral ( p , k ) ) { values [ 0 ] += k ; } else { TRACE ( " qe _ verbose " , tout << " non - linear ▁ " << mk_pp ( p , m ) << " \n " ; ) ; return false ; } } return true ; } } ; class bounds_proc { arith_qe_util & m_util ; ast_mark m_mark ; expr_ref_vector m_le_terms , m_ge_terms , m_lt_terms , m_gt_terms ; vector < rational > m_le_coeffs , m_ge_coeffs , m_lt_coeffs , m_gt_coeffs ; app_ref_vector m_le_atoms , m_ge_atoms , m_lt_atoms , m_gt_atoms ; expr_ref_vector m_div_terms ; vector < rational > m_div_coeffs , m_div_divisors ; app_ref_vector m_div_atoms ; app_ref m_div_z ; expr_ref_vector m_nested_div_terms ; vector < rational > m_nested_div_coeffs , m_nested_div_divisors ; app_ref_vector m_nested_div_atoms ; app_ref_vector m_nested_div_z ; rational m_d ; public : bounds_proc ( arith_qe_util & u ) : m_util ( u ) , m_le_terms ( u . get_manager ( ) ) , m_ge_terms ( u . get_manager ( ) ) , m_lt_terms ( u . get_manager ( ) ) , m_gt_terms ( u . get_manager ( ) ) , m_le_atoms ( u . get_manager ( ) ) , m_ge_atoms ( u . get_manager ( ) ) , m_lt_atoms ( u . get_manager ( ) ) , m_gt_atoms ( u . get_manager ( ) ) , m_div_terms ( u . get_manager ( ) ) , m_div_atoms ( u . get_manager ( ) ) , m_div_z ( u . get_manager ( ) ) , m_nested_div_terms ( u . get_manager ( ) ) , m_nested_div_atoms ( u . get_manager ( ) ) , m_nested_div_z ( u . get_manager ( ) ) { reset ( ) ; } bool get_bound ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; app * x = contains_x . x ( ) ; if ( m_mark . is_marked ( a ) || get_le_bound ( contains_x , a ) || get_lt_bound ( contains_x , a ) || get_divides ( contains_x , a ) || get_nested_divs ( contains_x , a ) ) { TRACE ( " qe _ verbose " , tout << " Bound ▁ for ▁ " << mk_pp ( x , m ) << " ▁ within ▁ " << mk_pp ( a , m ) << " \n " ; ) ; m_mark . mark ( a , true ) ; return true ; } else { TRACE ( " qe " , tout << " No ▁ bound ▁ for ▁ " << mk_pp ( x , m ) << " ▁ within ▁ " << mk_pp ( a , m ) << " \n " ; ) ; return false ; } } unsigned lt_size ( ) { return m_lt_terms . size ( ) ; } unsigned le_size ( ) { return m_le_terms . size ( ) ; } unsigned gt_size ( ) { return m_gt_terms . size ( ) ; } unsigned ge_size ( ) { return m_ge_terms . size ( ) ; } unsigned t_size ( bool is_l ) { return is_l ? lt_size ( ) : gt_size ( ) ; } unsigned e_size ( bool is_l ) { return is_l ? le_size ( ) : ge_size ( ) ; } unsigned size ( bool is_strict , bool is_l ) { return is_strict ? t_size ( is_l ) : e_size ( is_l ) ; } expr * const * lt ( ) { return m_lt_terms . c_ptr ( ) ; } expr * const * le ( ) { return m_le_terms . c_ptr ( ) ; } expr * const * gt ( ) { return m_gt_terms . c_ptr ( ) ; } expr * const * ge ( ) { return m_ge_terms . c_ptr ( ) ; } expr * const * t ( bool is_l ) { return is_l ? lt ( ) : gt ( ) ; } expr * const * e ( bool is_l ) { return is_l ? le ( ) : ge ( ) ; } expr * const * exprs ( bool is_strict , bool is_l ) { return is_strict ? t ( is_l ) : e ( is_l ) ; } rational const * lt_coeffs ( ) { return m_lt_coeffs . c_ptr ( ) ; } rational const * le_coeffs ( ) { return m_le_coeffs . c_ptr ( ) ; } rational const * gt_coeffs ( ) { return m_gt_coeffs . c_ptr ( ) ; } rational const * ge_coeffs ( ) { return m_ge_coeffs . c_ptr ( ) ; } rational const * t_coeffs ( bool is_l ) { return is_l ? lt_coeffs ( ) : gt_coeffs ( ) ; } rational const * e_coeffs ( bool is_l ) { return is_l ? le_coeffs ( ) : ge_coeffs ( ) ; } rational const * coeffs ( bool is_strict , bool is_l ) { return is_strict ? t_coeffs ( is_l ) : e_coeffs ( is_l ) ; } app * const * lt_atoms ( ) { return m_lt_atoms . c_ptr ( ) ; } app * const * le_atoms ( ) { return m_le_atoms . c_ptr ( ) ; } app * const * gt_atoms ( ) { return m_gt_atoms . c_ptr ( ) ; } app * const * ge_atoms ( ) { return m_ge_atoms . c_ptr ( ) ; } app * const * t_atoms ( bool is_l ) { return is_l ? lt_atoms ( ) : gt_atoms ( ) ; } app * const * e_atoms ( bool is_l ) { return is_l ? le_atoms ( ) : ge_atoms ( ) ; } app * const * atoms ( bool is_strict , bool is_l ) { return is_strict ? t_atoms ( is_l ) : e_atoms ( is_l ) ; } unsigned div_size ( ) const { return m_div_terms . size ( ) ; } app * const * div_atoms ( ) { return m_div_atoms . c_ptr ( ) ; } rational const * div_coeffs ( ) { return m_div_coeffs . c_ptr ( ) ; } expr * const * div_terms ( ) { return m_div_terms . c_ptr ( ) ; } rational const * divisors ( ) { return m_div_divisors . c_ptr ( ) ; } bool div_z ( rational & d , app_ref & z_bv , app_ref & z ) { if ( m_div_z . get ( ) ) { z = m_div_z ; z_bv = to_app ( z -> get_arg ( 0 ) ) ; d = m_d ; return true ; } if ( m_div_terms . empty ( ) && m_nested_div_terms . empty ( ) ) { return false ; } m_d = rational ( 1 ) ; for ( unsigned i = 0 ; i < m_div_divisors . size ( ) ; ++ i ) { m_d = lcm ( m_div_divisors [ i ] , m_d ) ; } for ( unsigned i = 0 ; i < m_nested_div_divisors . size ( ) ; ++ i ) { m_d = lcm ( m_nested_div_divisors [ i ] , m_d ) ; } if ( abs ( m_d ) . is_one ( ) ) { return false ; } m_util . mk_bounded_var ( m_d , z_bv , m_div_z ) ; z = m_div_z ; d = m_d ; return true ; } unsigned nested_div_size ( ) const { return m_nested_div_terms . size ( ) ; } app * nested_div_atom ( unsigned idx ) { return m_nested_div_atoms [ idx ] . get ( ) ; } rational const & nested_div_coeff ( unsigned idx ) { return m_nested_div_coeffs [ idx ] ; } expr * nested_div_term ( unsigned idx ) { return m_nested_div_terms [ idx ] . get ( ) ; } rational const & nested_divisor ( unsigned idx ) { return m_nested_div_divisors [ idx ] ; } app * nested_div_z ( unsigned idx ) { return m_nested_div_z [ idx ] . get ( ) ; } app * nested_div_z_bv ( unsigned idx ) { return to_app ( m_nested_div_z [ idx ] -> get_arg ( 0 ) ) ; } void reset ( ) { m_lt_terms . reset ( ) ; m_gt_terms . reset ( ) ; m_ge_terms . reset ( ) ; m_le_terms . reset ( ) ; m_gt_coeffs . reset ( ) ; m_lt_coeffs . reset ( ) ; m_ge_coeffs . reset ( ) ; m_le_coeffs . reset ( ) ; m_lt_atoms . reset ( ) ; m_gt_atoms . reset ( ) ; m_le_atoms . reset ( ) ; m_ge_atoms . reset ( ) ; m_div_terms . reset ( ) ; m_div_coeffs . reset ( ) ; m_div_divisors . reset ( ) ; m_div_atoms . reset ( ) ; m_div_z = 0 ; m_nested_div_terms . reset ( ) ; m_nested_div_coeffs . reset ( ) ; m_nested_div_divisors . reset ( ) ; m_nested_div_atoms . reset ( ) ; m_nested_div_z . reset ( ) ; } private : bool get_nested_divs ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; ptr_vector < expr > todo ; todo . push_back ( a ) ; rational k1 , k2 ; expr_ref rest ( m ) ; while ( ! todo . empty ( ) ) { expr * e = todo . back ( ) ; todo . pop_back ( ) ; if ( m_mark . is_marked ( e ) ) { continue ; } m_mark . mark ( e , true ) ; if ( ! contains_x ( e ) ) { continue ; } if ( contains_x . x ( ) == e ) { return false ; } if ( ! is_app ( e ) ) { return false ; } a = to_app ( e ) ; if ( m_util . m_arith . is_mod ( e ) && m_util . m_arith . is_numeral ( to_app ( e ) -> get_arg ( 1 ) , k1 ) && m_util . get_coeff ( contains_x , to_app ( e ) -> get_arg ( 0 ) , k2 , rest ) ) { app_ref z ( m ) , z_bv ( m ) ; m_util . mk_bounded_var ( k1 , z_bv , z ) ; m_nested_div_terms . push_back ( rest ) ; m_nested_div_divisors . push_back ( k1 ) ; m_nested_div_coeffs . push_back ( k2 ) ; m_nested_div_atoms . push_back ( a ) ; m_nested_div_z . push_back ( z ) ; continue ; } unsigned num_args = a -> get_num_args ( ) ; for ( unsigned i = 0 ; i < num_args ; ++ i ) { todo . push_back ( a -> get_arg ( i ) ) ; } } return true ; } bool get_le_bound ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; expr_ref p ( m ) , rest ( m ) ; rational k ; if ( m_util . is_le ( a , p ) && m_util . get_coeff ( contains_x , p , k , rest ) ) { if ( m_util . is_real ( contains_x . x ( ) ) ) { m_util . mk_div ( rest , abs ( k ) , rest ) ; k = k . is_pos ( ) ? rational :: one ( ) : rational :: minus_one ( ) ; } if ( k . is_neg ( ) ) { m_le_terms . push_back ( rest ) ; m_le_coeffs . push_back ( k ) ; m_le_atoms . push_back ( a ) ; } else { m_ge_terms . push_back ( rest ) ; m_ge_coeffs . push_back ( k ) ; m_ge_atoms . push_back ( a ) ; } return true ; } return false ; } bool get_lt_bound ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; expr_ref p ( m ) , rest ( m ) , na ( m ) ; rational k ; if ( m_util . is_lt ( a , p ) && m_util . get_coeff ( contains_x , p , k , rest ) ) { } else if ( m_util . is_neg ( a , na ) && is_app ( na ) && m_util . is_ge ( to_app ( na ) , p ) && m_util . get_coeff ( contains_x , p , k , rest ) ) { } else { return false ; } SASSERT ( m_util . is_real ( contains_x . x ( ) ) ) ; m_util . mk_div ( rest , abs ( k ) , rest ) ; if ( k . is_neg ( ) ) { m_lt_terms . push_back ( rest ) ; m_lt_coeffs . push_back ( rational :: minus_one ( ) ) ; m_lt_atoms . push_back ( a ) ; } else { m_gt_terms . push_back ( rest ) ; m_gt_coeffs . push_back ( rational :: one ( ) ) ; m_gt_atoms . push_back ( a ) ; } return true ; } bool get_divides ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; expr_ref p ( m ) , rest ( m ) ; app_ref a2 ( m ) ; numeral k , k2 ; if ( m_util . is_divides ( a , k , p ) && m_util . get_coeff ( contains_x , p , k2 , rest ) ) { m_div_terms . push_back ( rest ) ; m_div_divisors . push_back ( k ) ; m_div_coeffs . push_back ( k2 ) ; m_div_atoms . push_back ( a ) ; return true ; } if ( m_util . is_not_divides ( a , a2 , k , p ) && m_util . get_coeff ( contains_x , p , k2 , rest ) ) { m_div_terms . push_back ( rest ) ; m_div_divisors . push_back ( k ) ; m_div_coeffs . push_back ( k2 ) ; m_div_atoms . push_back ( a2 ) ; return true ; } return false ; } public : void display ( std :: ostream & out ) { ast_manager & m = m_util . get_manager ( ) ; for ( unsigned i = 0 ; i < lt_size ( ) ; ++ i ) { out << mk_pp ( lt ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } for ( unsigned i = 0 ; i < le_size ( ) ; ++ i ) { out << mk_pp ( le ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } for ( unsigned i = 0 ; i < gt_size ( ) ; ++ i ) { out << mk_pp ( gt ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } for ( unsigned i = 0 ; i < ge_size ( ) ; ++ i ) { out << mk_pp ( ge ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } } } ; class x_subst { arith_qe_util & m_super ; expr_ref m_t ; rational m_coeff ; public : x_subst ( arith_qe_util & s ) : m_super ( s ) , m_t ( s . get_manager ( ) ) , m_coeff ( rational :: one ( ) ) { } void set_term ( expr * t ) { m_t = t ; } void set_coeff ( rational const & k ) { m_coeff = k ; } expr * get_term ( ) const { return m_t ; } rational get_coeff ( ) const { return m_coeff ; } expr_ref mk_term ( rational const & c , expr * t ) { ast_manager & m = m_super . get_manager ( ) ; if ( m_t . get ( ) ) { return expr_ref ( m_super . mk_add ( m_super . mk_mul ( c , m_t ) , t ) , m ) ; } else { return expr_ref ( t , m ) ; } } rational mk_coeff ( rational const & k ) { return k * m_coeff ; } } ; struct branch_formula { expr * m_fml ; app * m_var ; unsigned m_branch ; expr * m_result ; rational m_coeff ; expr * m_term ; branch_formula ( ) : m_fml ( 0 ) , m_var ( 0 ) , m_branch ( 0 ) , m_result ( 0 ) , m_term ( 0 ) { } branch_formula ( expr * fml , app * var , unsigned b , expr * r , rational coeff , expr * term ) : m_fml ( fml ) , m_var ( var ) , m_branch ( b ) , m_result ( r ) , m_coeff ( coeff ) , m_term ( term ) { } unsigned mk_hash ( ) const { return mk_mix ( m_fml ? m_fml -> hash ( ) : 0 , m_var ? m_var -> hash ( ) : 0 , m_branch ) ; } bool mk_eq ( branch_formula const & other ) const { return m_fml == other . m_fml && m_var == other . m_var && m_branch == other . m_branch ; } struct hash { typedef branch_formula data ; unsigned operator ( ) ( data const & d ) const { return d . mk_hash ( ) ; } } ; struct eq { typedef branch_formula data ; bool operator ( ) ( data const & x , data const & y ) const { return x . mk_eq ( y ) ; } } ; } ; class arith_plugin : public qe_solver_plugin { typedef obj_pair_map < app , expr , bounds_proc * > bounds_cache ; typedef obj_pair_map < expr , expr , expr * > resolve_cache ; typedef hashtable < branch_formula , branch_formula :: hash , branch_formula :: eq > subst_cache ; arith_qe_util m_util ; expr_ref_vector m_trail ; bounds_cache m_bounds_cache ; subst_cache m_subst ; public : arith_plugin ( i_solver_context & ctx , ast_manager & m , smt_params & p ) : qe_solver_plugin ( m , m . mk_family_id ( " arith " ) , ctx ) , m_util ( m , p , ctx ) , m_trail ( m ) { } ~ arith_plugin ( ) { bounds_cache :: iterator it = m_bounds_cache . begin ( ) , end = m_bounds_cache . end ( ) ; for ( ; it != end ; ++ it ) { dealloc ( it -> get_value ( ) ) ; } } virtual void assign ( contains_app & contains_x , expr * fml , rational const & vl ) { SASSERT ( vl . is_unsigned ( ) ) ; app * x = contains_x . x ( ) ; unsigned v = vl . get_unsigned ( ) ; expr_ref result ( fml , m ) ; unsigned t_size , e_size ; x_subst x_t ( m_util ) ; if ( get_cache ( x , fml , v , result ) ) { return ; } bounds_proc & bounds = get_bounds ( x , fml ) ; bool is_lower = get_bound_sizes ( bounds , x , t_size , e_size ) ; assign_nested_divs ( contains_x , bounds , result ) ; assign_divs ( contains_x , bounds , x_t , result ) ; if ( v == 0 ) { mk_non_bounds ( bounds , true , is_lower , result ) ; mk_non_bounds ( bounds , false , is_lower , result ) ; mk_non_resolve ( bounds , true , is_lower , result ) ; mk_non_resolve ( bounds , false , is_lower , result ) ; m_util . simplify ( result ) ; add_cache ( x , fml , v , result , x_t . get_coeff ( ) , x_t . get_term ( ) ) ; TRACE ( " qe " , tout << vl << " ▁ " << mk_pp ( x , m ) << " ▁ infinite ▁ case \n " ; tout << mk_pp ( fml , m ) << " \n " ; tout << mk_pp ( result , m ) << " \n " ; ) ; return ; } unsigned index = v - 1 ; bool is_strict = e_size <= index ; bool is_eq = false ; SASSERT ( index < t_size + e_size ) ; if ( is_strict ) { index -= e_size ; TRACE ( " qe _ verbose " , bounds . display ( tout ) ; ) ; } else if ( m_util . is_real ( x ) ) { SASSERT ( 0 == ( e_size & 0x1 ) ) ; is_eq = ( 0 == ( index & 0x1 ) ) ; index /= 2 ; e_size /= 2 ; } SASSERT ( is_strict || index < e_size ) ; SASSERT ( ! is_strict || index < t_size ) ; SASSERT ( index < bounds . size ( is_strict , is_lower ) ) ; expr_ref t ( bounds . exprs ( is_strict , is_lower ) [ index ] , m ) ; rational a = bounds . coeffs ( is_strict , is_lower ) [ index ] ; mk_bounds ( bounds , x , true , is_eq , is_strict , is_lower , index , a , t , result ) ; mk_bounds ( bounds , x , false , is_eq , is_strict , is_lower , index , a , t , result ) ; t = x_t . mk_term ( a , t ) ; a = x_t . mk_coeff ( a ) ; mk_resolve ( bounds , x , x_t , true , is_eq , is_strict , is_lower , index , a , t , result ) ; mk_resolve ( bounds , x , x_t , false , is_eq , is_strict , is_lower , index , a , t , result ) ; m_util . simplify ( result ) ; add_cache ( x , fml , v , result , x_t . get_coeff ( ) , x_t . get_term ( ) ) ; TRACE ( " qe " , { tout << vl << " ▁ " << mk_pp ( bounds . atoms ( is_strict , is_lower ) [ index ] , m ) << " \n " ; tout << mk_pp ( fml , m ) << " \n " ; tout << mk_pp ( result , m ) << " \n " ; } ) ; } virtual bool get_num_branches ( contains_app & contains_x , expr * fml , rational & nb ) { app * x = contains_x . x ( ) ; if ( ! update_bounds ( contains_x , fml ) ) { return false ; } bounds_proc & bounds = get_bounds ( x , fml ) ; unsigned t_size , e_size ; get_bound_sizes ( bounds , x , t_size , e_size ) ; nb = rational ( t_size + e_size + 1 ) ; return true ; } virtual void subst ( contains_app & contains_x , rational const & vl , expr_ref & fml , expr_ref * def ) { SASSERT ( vl . is_unsigned ( ) ) ; if ( def ) { get_def ( contains_x , vl . get_unsigned ( ) , fml , * def ) ; } VERIFY ( get_cache ( contains_x . x ( ) , fml , vl . get_unsigned ( ) , fml ) ) ; TRACE ( " qe " , tout << mk_pp ( contains_x . x ( ) , m ) << " ▁ " << vl << " \n " << mk_pp ( fml , m ) << " \n " ; ) ; } virtual bool project ( contains_app & x , model_ref & model , expr_ref & fml ) { if ( ! update_bounds ( x , fml ) ) { TRACE ( " qe " , tout << mk_pp ( x . x ( ) , m ) << " ▁ failed ▁ to ▁ update ▁ bounds \n " ; ) ; return false ; } if ( m_util . m_arith . is_real ( x . x ( ) ) ) { return project_real ( x , model , fml ) ; } else { return project_int ( x , model , fml ) ; } } virtual unsigned get_weight ( contains_app & contains_x , expr * fml ) { return 2 ; } virtual bool solve ( conj_enum & conjs , expr * fml ) { return m_util . solve ( conjs , fml ) ; } virtual bool mk_atom ( expr * e , bool p , expr_ref & result ) { return m_util . mk_atom ( e , p , result ) ; } virtual bool is_uninterpreted ( app * f ) { switch ( f -> get_decl_kind ( ) ) { case OP_NUM : case OP_LE : case OP_LT : case OP_GE : case OP_GT : case OP_ADD : case OP_SUB : case OP_UMINUS : return false ; case OP_MOD : if ( m_util . m_arith . is_numeral ( f -> get_arg ( 1 ) ) ) { return false ; } return true ; case OP_MUL : { arith_util & a = m_util . m_arith ; expr * m , * n ; if ( a . is_mul ( f , m , n ) && ( a . is_numeral ( m ) || a . is_numeral ( n ) ) ) { return false ; } return true ; } default : return true ; } } private : expr_ref mk_idiv ( expr * e , numeral k ) { SASSERT ( ! k . is_zero ( ) ) ; arith_util & a = m_util . m_arith ; if ( k . is_one ( ) ) { return expr_ref ( e , m ) ; } if ( k . is_minus_one ( ) ) { return expr_ref ( a . mk_uminus ( e ) , m ) ; } SASSERT ( a . is_int ( e ) ) ; return expr_ref ( a . mk_idiv ( e , a . mk_numeral ( k , true ) ) , m ) ; } void get_def ( contains_app & contains_x , unsigned v , expr * fml , expr_ref & def ) { app * x = contains_x . x ( ) ; x_subst x_t ( m_util ) ; bounds_proc & bounds = get_bounds ( x , fml ) ; branch_formula bf ; VERIFY ( m_subst . find ( branch_formula ( fml , x , v , 0 , rational :: zero ( ) , 0 ) , bf ) ) ; x_t . set_term ( bf . m_term ) ; x_t . set_coeff ( bf . m_coeff ) ; CTRACE ( " qe " , x_t . get_term ( ) , tout << x_t . get_coeff ( ) << " ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; unsigned t_size , e_size , sz ; bool is_lower = get_bound_sizes ( bounds , x , t_size , e_size ) ; bool is_strict ; if ( v == 0 ) { is_strict = false ; sz = bounds . size ( is_strict , ! is_lower ) ; expr_ref_vector terms ( m ) ; if ( sz == 0 ) { terms . push_back ( m_util . mk_zero ( x ) ) ; } for ( unsigned i = 0 ; i < sz ; ++ i ) { expr_ref term ( bounds . exprs ( is_strict , ! is_lower ) [ i ] , m ) ; rational a = bounds . coeffs ( is_strict , ! is_lower ) [ i ] ; if ( x_t . get_term ( ) ) { TRACE ( " qe " , tout << x_t . get_coeff ( ) << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; SASSERT ( x_t . get_coeff ( ) . is_pos ( ) ) ; term = m_util . mk_add ( term , m_util . mk_mul ( a , x_t . get_term ( ) ) ) ; a = a * x_t . get_coeff ( ) ; } TRACE ( " qe " , tout << a << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( term , m ) << " ▁ < = ▁ 0 \n " ; ) ; SASSERT ( a . is_int ( ) ) ; SASSERT ( is_lower == a . is_pos ( ) ) ; term = m_util . mk_uminus ( term ) ; term = mk_idiv ( term , a ) ; terms . push_back ( term ) ; TRACE ( " qe " , tout << " a : ▁ " << a << " ▁ term : ▁ " << mk_pp ( term , m ) << " \n " ; ) ; } is_strict = true ; sz = bounds . size ( is_strict , ! is_lower ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { expr_ref term ( bounds . exprs ( is_strict , ! is_lower ) [ i ] , m ) ; SASSERT ( abs ( bounds . coeffs ( is_strict , ! is_lower ) [ i ] ) . is_one ( ) ) ; if ( is_lower ) { term = m_util . mk_uminus ( m_util . mk_add ( term , m_util . mk_one ( x ) ) ) ; } else { term = m_util . mk_add ( term , m_util . mk_one ( x ) ) ; } terms . push_back ( term ) ; } if ( is_lower ) { def = m_util . mk_min ( terms . size ( ) , terms . c_ptr ( ) ) ; } else { def = m_util . mk_max ( terms . size ( ) , terms . c_ptr ( ) ) ; } if ( x_t . get_term ( ) ) { TRACE ( " qe " , tout << x_t . get_coeff ( ) << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; def = m_util . mk_add ( m_util . mk_mul ( x_t . get_coeff ( ) , def ) , x_t . get_term ( ) ) ; } m_util . simplify ( def ) ; return ; } -- v ; is_strict = e_size <= v ; SASSERT ( v < t_size + e_size ) ; if ( is_strict ) { v -= e_size ; TRACE ( " qe _ verbose " , bounds . display ( tout ) ; ) ; } else if ( m_util . is_real ( x ) ) { SASSERT ( 0 == ( e_size & 0x1 ) ) ; v /= 2 ; e_size /= 2 ; } SASSERT ( is_strict || v < e_size ) ; SASSERT ( ! is_strict || v < t_size ) ; SASSERT ( v < bounds . size ( is_strict , is_lower ) ) ; def = bounds . exprs ( is_strict , is_lower ) [ v ] ; rational a = bounds . coeffs ( is_strict , is_lower ) [ v ] ; if ( x_t . get_term ( ) ) { TRACE ( " qe " , tout << x_t . get_coeff ( ) << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; SASSERT ( x_t . get_coeff ( ) . is_pos ( ) ) ; def = m_util . mk_add ( def , m_util . mk_mul ( a , x_t . get_term ( ) ) ) ; a = a * x_t . get_coeff ( ) ; } SASSERT ( a . is_int ( ) ) ; SASSERT ( is_lower != a . is_pos ( ) ) ; def = m_util . mk_uminus ( def ) ; def = mk_idiv ( def , a ) ; if ( x_t . get_term ( ) ) { def = m_util . mk_add ( m_util . mk_mul ( x_t . get_coeff ( ) , def ) , x_t . get_term ( ) ) ; } if ( is_strict ) { SASSERT ( m_util . m_arith . is_real ( x ) ) ; def = m_util . mk_sub ( def , m_util . mk_one ( x ) ) ; } m_util . simplify ( def ) ; TRACE ( " qe " , tout << " TBD ▁ ( for ▁ Real ) : ▁ " << a << " ▁ " << mk_pp ( def , m ) << " \n " ; ) ; } expr_ref mk_not ( expr * e ) { expr * r ; if ( m . is_not ( e , r ) ) { return expr_ref ( r , m ) ; } return expr_ref ( m . mk_not ( e ) , m ) ; } bool project_real ( contains_app & x , model_ref & model , expr_ref & fml ) { SASSERT ( m_util . m_arith . is_real ( x . x ( ) ) ) ; model_evaluator model_eval ( * model ) ; bounds_proc & bounds = get_bounds ( x . x ( ) , fml ) ; bool is_lower = bounds . le_size ( ) + bounds . lt_size ( ) < bounds . ge_size ( ) + bounds . gt_size ( ) ; unsigned e_size = bounds . e_size ( is_lower ) ; numeral bound1 , bound2 , vl , x_val ; unsigned idx1 , idx2 ; bool found1 = find_min_max ( is_lower , false , bounds , model_eval , bound1 , idx1 ) ; bool found2 = find_min_max ( is_lower , true , bounds , model_eval , bound2 , idx2 ) ; if ( ! found1 && ! found2 ) { vl = numeral ( 0 ) ; } else if ( found2 && ( ! found1 || bound2 <= bound1 ) ) { vl = numeral ( 1 + 2 * e_size + idx2 ) ; } else if ( found1 && ( ! found2 || bound1 < bound2 ) ) { expr_ref val_x ( m ) ; model_eval ( x . x ( ) , val_x ) ; VERIFY ( m_util . m_arith . is_numeral ( val_x , x_val ) ) ; if ( x_val == bound1 ) { vl = numeral ( 1 + 2 * idx1 ) ; } else { vl = numeral ( 1 + 2 * idx1 + 1 ) ; } } assign ( x , fml , vl ) ; subst ( x , vl , fml , 0 ) ; TRACE ( " qe " , tout << mk_pp ( fml , m ) << " \n " ; ) ; return true ; } bool project_int ( contains_app & x , model_ref & model , expr_ref & fml ) { model_evaluator model_eval ( * model ) ; bounds_proc & bounds = get_bounds ( x . x ( ) , fml ) ; SASSERT ( m_util . m_arith . is_int ( x . x ( ) ) ) ; SASSERT ( bounds . lt_size ( ) == 0 && bounds . gt_size ( ) == 0 ) ; bool is_lower = bounds . le_size ( ) < bounds . ge_size ( ) ; numeral bound , vl , x_val ; unsigned idx = bounds . le_size ( ) + bounds . ge_size ( ) ; bool found = find_min_max ( is_lower , false , bounds , model_eval , bound , idx ) ; if ( found ) { SASSERT ( idx < bounds . size ( false , is_lower ) ) ; vl = numeral ( 1 + idx ) ; } else { vl = numeral ( 0 ) ; } assign ( x , fml , vl ) ; subst ( x , vl , fml , 0 ) ; TRACE ( " qe " , tout << mk_pp ( fml , m ) << " \n " ; ) ; return true ; } bool find_min_max ( bool is_lower , bool is_strict , bounds_proc & bounds , model_evaluator & eval , rational & bound , unsigned & idx ) { bool found = false ; unsigned num_bounds = bounds . size ( is_strict , is_lower ) ; rational num ; for ( unsigned i = 0 ; i < num_bounds ; ++ i ) { expr_ref vl ( m ) ; eval ( bounds . atoms ( is_strict , is_lower ) [ i ] , vl ) ; if ( ! m . is_true ( vl ) ) { continue ; } eval ( bounds . exprs ( is_strict , is_lower ) [ i ] , vl ) ; VERIFY ( m_util . m_arith . is_numeral ( vl , num ) ) ; num /= abs ( bounds . coeffs ( is_strict , is_lower ) [ i ] ) ; if ( found ) { if ( is_lower ? ( num < bound ) : ( num > bound ) ) { bound = num ; idx = i ; } } else { found = true ; idx = i ; bound = num ; } } return found ; } bool get_bound_sizes ( bounds_proc & bounds , app * x , unsigned & t_size , unsigned & e_size ) { unsigned le_size = bounds . le_size ( ) ; unsigned ge_size = bounds . ge_size ( ) ; if ( m_util . is_real ( x ) ) { le_size *= 2 ; ge_size *= 2 ; } if ( le_size + bounds . lt_size ( ) < ge_size + bounds . gt_size ( ) ) { e_size = le_size ; t_size = bounds . lt_size ( ) ; return true ; } else { e_size = ge_size ; t_size = bounds . gt_size ( ) ; return false ; } } void add_cache ( app * x , expr * fml , unsigned v , expr * result , rational coeff , expr * term ) { m_trail . push_back ( x ) ; m_trail . push_back ( fml ) ; m_trail . push_back ( result ) ; if ( term ) m_trail . push_back ( term ) ; m_subst . insert ( branch_formula ( fml , x , v , result , coeff , term ) ) ; } bool get_cache ( app * x , expr * fml , unsigned v , expr_ref & result ) { branch_formula bf ; if ( ! m_subst . find ( branch_formula ( fml , x , v , 0 , rational :: zero ( ) , 0 ) , bf ) ) { return false ; } SASSERT ( bf . m_result ) ; result = bf . m_result ; return true ; } void assign_divs ( contains_app & contains_x , bounds_proc & bounds , x_subst & x_t , expr_ref & result ) { app * x = contains_x . x ( ) ; app_ref z ( m ) , z_bv ( m ) ; rational d ; if ( ! bounds . div_z ( d , z_bv , z ) ) { return ; } m_ctx . add_var ( z_bv ) ; expr * z_lt_d = m_util . m_arith . mk_le ( z , m_util . m_arith . mk_numeral ( d - rational ( 1 ) , true ) ) ; m_ctx . add_constraint ( false , z_lt_d ) ; SASSERT ( ! abs ( d ) . is_one ( ) ) ; rational d1 = d - rational ( 1 ) ; expr_ref tmp ( m ) ; m_util . m_arith_rewriter . mk_le ( z , m_util . m_arith . mk_numeral ( d1 , true ) , tmp ) ; m_util . m_bool_rewriter . mk_and ( result , tmp , result ) ; expr_ref t1 ( m ) , new_atom ( m ) ; t1 = m_util . mk_sub ( x , z ) ; m_util . mk_divides ( d , t1 , new_atom ) ; m_ctx . add_constraint ( false , new_atom ) ; mk_div_equivs ( bounds , z , result ) ; x_t . set_term ( z ) ; x_t . set_coeff ( d ) ; } void mk_div_equivs ( bounds_proc & bounds , expr * z , expr_ref & result ) { unsigned sz = bounds . div_size ( ) ; app * const * atoms = bounds . div_atoms ( ) ; rational const * coeffs = bounds . div_coeffs ( ) ; expr * const * terms = bounds . div_terms ( ) ; rational const * divisors = bounds . divisors ( ) ; expr_ref new_atom ( m ) , t1 ( m ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * atm = atoms [ i ] ; t1 = m_util . mk_add ( m_util . mk_mul ( coeffs [ i ] , z ) , terms [ i ] ) ; m_util . mk_divides ( divisors [ i ] , t1 , new_atom ) ; m_util . m_replace . apply_substitution ( atm , new_atom . get ( ) , result ) ; m_ctx . add_constraint ( false , mk_not ( atm ) , new_atom ) ; m_ctx . add_constraint ( false , mk_not ( new_atom ) , atm ) ; } } void assign_nested_divs ( contains_app & contains_x , bounds_proc & bounds , expr_ref & result ) { unsigned num_nested_divs = bounds . nested_div_size ( ) ; if ( num_nested_divs == 0 ) { return ; } app_ref z ( m ) , z_bv ( m ) ; rational d ; VERIFY ( bounds . div_z ( d , z_bv , z ) ) ; for ( unsigned i = 0 ; i < num_nested_divs ; ++ i ) { app * atm = bounds . nested_div_atom ( i ) ; rational const & k = bounds . nested_divisor ( i ) ; app * z1_bv = bounds . nested_div_z_bv ( i ) ; app * z1 = bounds . nested_div_z ( i ) ; m_ctx . add_var ( z1_bv ) ; expr * z_lt_k = m_util . m_arith . mk_le ( z1 , m_util . m_arith . mk_numeral ( k - rational ( 1 ) , true ) ) ; m_ctx . add_constraint ( false , z_lt_k ) ; expr * e1 = m_util . m_arith . mk_sub ( atm -> get_arg ( 0 ) , z1 ) ; expr * e2 = atm -> get_arg ( 1 ) ; expr_ref mod_term2 ( m_util . m_arith . mk_mod ( e1 , e2 ) , m ) ; m_util . simplify ( mod_term2 ) ; m_ctx . add_constraint ( false , m . mk_eq ( mod_term2 , m_util . mk_zero ( mod_term2 ) ) ) ; m_util . m_replace . apply_substitution ( atm , z1 , result ) ; expr_ref mod_eq ( m ) , tmp1 ( m ) , tmp2 ( m ) ; tmp2 = m_util . mk_numeral ( bounds . nested_div_coeff ( i ) , true ) ; tmp1 = m_util . m_arith . mk_mul ( tmp2 , z1 ) ; tmp2 = m_util . m_arith . mk_sub ( bounds . nested_div_term ( i ) , z ) ; tmp2 = m_util . m_arith . mk_add ( tmp1 , tmp2 ) ; tmp1 = m_util . m_arith . mk_mod ( tmp2 , bounds . nested_div_atom ( i ) -> get_arg ( 1 ) ) ; mod_eq = m . mk_eq ( tmp1 , m_util . mk_zero ( z ) ) ; m_util . simplify ( mod_eq ) ; result = m . mk_and ( result , mod_eq ) ; TRACE ( " qe " , tout << mk_pp ( mod_eq , m ) << " \n " ; ) ; } } bounds_proc & get_bounds ( app * x , expr * fml ) { bounds_proc * result = 0 ; VERIFY ( m_bounds_cache . find ( x , fml , result ) ) ; return * result ; } void mk_non_bounds ( bounds_proc & bounds , bool is_strict , bool is_lower , expr_ref & result ) { unsigned sz = bounds . size ( is_strict , is_lower ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , is_lower ) [ i ] ; m_ctx . add_constraint ( true , mk_not ( e ) ) ; m_util . m_replace . apply_substitution ( e , m . mk_false ( ) , result ) ; } } void mk_non_resolve ( bounds_proc & bounds , bool is_strict , bool is_lower , expr_ref & result ) { unsigned sz = bounds . size ( is_strict , ! is_lower ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , ! is_lower ) [ i ] ; m_ctx . add_constraint ( true , e ) ; m_util . m_replace . apply_substitution ( e , m . mk_true ( ) , result ) ; } } void mk_bound ( bool is_strict , bool is_lower , rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { if ( is_strict ) { if ( is_lower ) { m_util . mk_strict_bound ( b , s , a , t , result ) ; } else { m_util . mk_strict_bound ( a , t , b , s , result ) ; } } else { if ( is_lower ) { m_util . mk_bound ( b , s , a , t , result ) ; } else { m_util . mk_bound ( a , t , b , s , result ) ; } } m_util . simplify ( result ) ; TRACE ( " qe " , tout << ( is_strict ? " strict " : " non - strict " ) << " \n " ; tout << ( is_lower ? " is - lower " : " is - upper " ) << " \n " ; tout << " a : ▁ " << a << " ▁ " << mk_pp ( t , m ) << " \n " ; tout << " b : ▁ " << b << " ▁ " << mk_pp ( s , m ) << " \n " ; tout << mk_pp ( result , m ) << " \n " ; ) ; } void mk_bounds ( bounds_proc & bounds , app * x , bool is_strict , bool is_eq_ctx , bool is_strict_ctx , bool is_lower , unsigned index , rational const & a , expr * t , expr_ref & result ) { TRACE ( " qe " , tout << mk_pp ( t , m ) << " \n " ; ) ; SASSERT ( ! is_eq_ctx || ! is_strict_ctx ) ; unsigned sz = bounds . size ( is_strict , is_lower ) ; expr_ref tmp ( m ) , eq ( m ) ; bool same_strict = ( is_strict == is_strict_ctx ) ; bool non_strict_real = m_util . is_real ( x ) && ! is_strict_ctx ; app * atm = bounds . atoms ( is_strict_ctx , is_lower ) [ index ] ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , is_lower ) [ i ] ; expr_ref s ( bounds . exprs ( is_strict , is_lower ) [ i ] , m ) ; rational b = bounds . coeffs ( is_strict , is_lower ) [ i ] ; if ( same_strict && i == index ) { if ( non_strict_real ) { m_util . mk_eq ( a , x , t , eq ) ; TRACE ( " qe " , tout << " a : " << a << " ▁ x : ▁ " << mk_pp ( x , m ) << " t : ▁ " << mk_pp ( t , m ) << " ▁ eq : ▁ " << mk_pp ( eq , m ) << " \n " ; ) ; if ( is_eq_ctx ) { m_ctx . add_constraint ( true , eq ) ; } else { m_ctx . add_constraint ( true , mk_not ( eq ) ) ; m_ctx . add_constraint ( true , e ) ; } } else { m_ctx . add_constraint ( true , e ) ; } m_util . m_replace . apply_substitution ( atm , m . mk_true ( ) , result ) ; continue ; } bool result_is_strict = ( non_strict_real && is_eq_ctx && is_strict ) || ( same_strict && i < index ) ; mk_bound ( result_is_strict , is_lower , a , t , b , s , tmp ) ; m_util . m_replace . apply_substitution ( e , tmp . get ( ) , result ) ; TRACE ( " qe " , tout << ( result_is_strict ? " strict ▁ result " : " non - strict ▁ result " ) << " \n " ; tout << ( is_strict ? " strict " : " non - strict " ) << " \n " ; tout << mk_pp ( atm , m ) << " ▁ & ▁ " ; tout << mk_pp ( e , m ) << " ▁ - - > ▁ " ; tout << mk_pp ( tmp . get ( ) , m ) << " \n " ; ) ; m_ctx . add_constraint ( true , mk_not ( e ) , tmp ) ; } } void mk_resolve ( bounds_proc & bounds , app * x , x_subst & x_t , bool is_strict , bool is_eq_ctx , bool is_strict_ctx , bool is_lower , unsigned index , rational const & a , expr * t , expr_ref & result ) { expr_ref tmp ( m ) ; unsigned sz = bounds . size ( is_strict , ! is_lower ) ; bool is_strict_real = ! is_eq_ctx && m_util . is_real ( x ) && ! is_strict_ctx ; bool strict_resolve = is_strict || is_strict_ctx || is_strict_real ; app * atm = bounds . atoms ( is_strict_ctx , is_lower ) [ index ] ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , ! is_lower ) [ i ] ; expr_ref s ( bounds . exprs ( is_strict , ! is_lower ) [ i ] , m ) ; rational b = bounds . coeffs ( is_strict , ! is_lower ) [ i ] ; SASSERT ( ! b . is_zero ( ) ) ; SASSERT ( b . is_pos ( ) != a . is_pos ( ) ) ; s = x_t . mk_term ( b , s ) ; b = x_t . mk_coeff ( b ) ; m_util . mk_resolve ( x , strict_resolve , a , t , b , s , tmp ) ; expr_ref save_result ( result ) ; m_util . m_replace . apply_substitution ( e , tmp . get ( ) , result ) ; m_ctx . add_constraint ( true , mk_not ( e ) , tmp ) ; TRACE ( " qe _ verbose " , tout << mk_pp ( atm , m ) << " ▁ " ; tout << mk_pp ( e , m ) << " ▁ = = > \n " ; tout << mk_pp ( tmp , m ) << " \n " ; tout << " old ▁ fml : ▁ " << mk_pp ( save_result , m ) << " \n " ; tout << " new ▁ fml : ▁ " << mk_pp ( result , m ) << " \n " ; ) ; } } bool update_bounds ( bounds_proc & bounds , contains_app & contains_x , expr * fml , atom_set const & tbl , bool is_pos ) { app_ref tmp ( m ) ; atom_set :: iterator it = tbl . begin ( ) , end = tbl . end ( ) ; for ( ; it != end ; ++ it ) { app * e = * it ; if ( ! contains_x ( e ) ) { continue ; } if ( ! is_pos ) { SASSERT ( ! m . is_not ( e ) ) ; tmp = m . mk_not ( e ) ; e = tmp ; } if ( ! bounds . get_bound ( contains_x , e ) ) { return false ; } } return true ; } bool update_bounds ( contains_app & contains_x , expr * fml ) { bounds_proc * bounds = 0 ; if ( m_bounds_cache . find ( contains_x . x ( ) , fml , bounds ) ) { return true ; } bounds = alloc ( bounds_proc , m_util ) ; if ( ! update_bounds ( * bounds , contains_x , fml , m_ctx . pos_atoms ( ) , true ) ) { dealloc ( bounds ) ; return false ; } if ( ! update_bounds ( * bounds , contains_x , fml , m_ctx . neg_atoms ( ) , false ) ) { dealloc ( bounds ) ; return false ; } m_trail . push_back ( contains_x . x ( ) ) ; m_trail . push_back ( fml ) ; m_bounds_cache . insert ( contains_x . x ( ) , fml , bounds ) ; return true ; } } ; class nlarith_plugin : public qe_solver_plugin { typedef obj_map < app , unsigned > weight_m ; typedef obj_pair_map < expr , expr , nlarith :: branch_conditions * > bcs_t ; typedef obj_map < expr , weight_m * > weights_t ; bcs_t m_cache ; weights_t m_weights ; th_rewriter m_rewriter ; nlarith :: util m_util ; expr_safe_replace m_replace ; expr_ref_vector m_trail ; factor_rewriter_star m_factor_rw ; bool m_produce_models ; public : nlarith_plugin ( i_solver_context & ctx , ast_manager & m , bool produce_models ) : qe_solver_plugin ( m , m . mk_family_id ( " arith " ) , ctx ) , m_rewriter ( m ) , m_util ( m ) , m_replace ( m ) , m_trail ( m ) , m_factor_rw ( m ) , m_produce_models ( produce_models ) { TRACE ( " qe " , tout << " produce ▁ models : ▁ " << produce_models << " \n " ; ) ; m_util . set_enable_linear ( true ) ; } virtual ~ nlarith_plugin ( ) { bcs_t :: iterator it = m_cache . begin ( ) , end = m_cache . end ( ) ; for ( ; it != end ; ++ it ) { dealloc ( it -> get_value ( ) ) ; } weights_t :: iterator it2 = m_weights . begin ( ) , e2 = m_weights . end ( ) ; for ( ; it2 != e2 ; ++ it2 ) { dealloc ( it2 -> get_value ( ) ) ; } } virtual bool simplify ( expr_ref & fml ) { expr_ref tmp ( m ) , tmp2 ( m ) ; m_factor_rw ( fml , tmp ) ; m_rewriter ( tmp , tmp2 ) ; if ( fml . get ( ) != tmp2 . get ( ) ) { fml = tmp2 ; return true ; } return false ; } virtual void assign ( contains_app & x , expr * fml , rational const & vl ) { nlarith :: branch_conditions * brs ; VERIFY ( m_cache . find ( x . x ( ) , fml , brs ) ) ; SASSERT ( vl . is_unsigned ( ) ) ; SASSERT ( vl . get_unsigned ( ) < brs -> size ( ) ) ; expr * branch_fml = brs -> branches ( vl . get_unsigned ( ) ) ; expr_ref result ( m ) , tmp ( m ) ; m_factor_rw ( branch_fml , tmp ) ; m_rewriter ( tmp , result ) ; TRACE ( " qe " , tout << vl << " ▁ " << mk_pp ( result . get ( ) , m ) << " \n " ; ) ; m_ctx . add_constraint ( true , result ) ; } virtual bool get_num_branches ( contains_app & x , expr * fml , rational & num_branches ) { nlarith :: branch_conditions * brs ; if ( m_cache . find ( x . x ( ) , fml , brs ) ) { num_branches = rational ( brs -> size ( ) ) ; return true ; } expr_ref_vector lits ( m ) ; update_bounds ( lits , m_ctx . pos_atoms ( ) , true ) ; update_bounds ( lits , m_ctx . neg_atoms ( ) , false ) ; brs = alloc ( nlarith :: branch_conditions , m ) ; TRACE ( " nlarith " , tout << mk_pp ( fml , m ) << " \n " ; ) ; if ( ! m_util . create_branches ( x . x ( ) , lits . size ( ) , lits . c_ptr ( ) , * brs ) ) { TRACE ( " nlarith " , tout << " no ▁ branches ▁ for ▁ " << mk_pp ( x . x ( ) , m ) << " \n " ; ) ; dealloc ( brs ) ; return false ; } num_branches = rational ( brs -> size ( ) ) ; insert_cache ( x . x ( ) , fml , brs ) ; return true ; } virtual void subst ( contains_app & x , rational const & vl , expr_ref & fml , expr_ref * def ) { nlarith :: branch_conditions * brs ; VERIFY ( m_cache . find ( x . x ( ) , fml , brs ) ) ; SASSERT ( vl . is_unsigned ( ) ) ; SASSERT ( vl . get_unsigned ( ) < brs -> size ( ) ) ; unsigned j = vl . get_unsigned ( ) ; m_replace . reset ( ) ; for ( unsigned i = 0 ; i < brs -> preds ( ) . size ( ) ; ++ i ) { m_replace . insert ( brs -> preds ( i ) , brs -> subst ( j ) [ i ] ) ; } m_replace ( fml ) ; expr_ref tmp ( m . mk_and ( brs -> constraints ( j ) , fml ) , m ) ; m_factor_rw ( tmp , fml ) ; if ( def ) { m_factor_rw ( brs -> def ( j ) , * def ) ; } } virtual unsigned get_weight ( contains_app & x , expr * fml ) { obj_map < app , unsigned > * weights = 0 ; unsigned weight = 0 ; if ( ! m_weights . find ( fml , weights ) ) { weights = alloc ( weight_m ) ; m_weights . insert ( fml , weights ) ; m_trail . push_back ( fml ) ; ptr_vector < app > nl_vars ; m_util . extract_non_linear ( to_app ( fml ) , nl_vars ) ; for ( unsigned i = 0 ; i < nl_vars . size ( ) ; ++ i ) { weights -> insert ( nl_vars [ i ] , 100 ) ; } } if ( weights -> find ( x . x ( ) , weight ) ) { return weight ; } return UINT_MAX ; } virtual bool solve ( conj_enum & conjs , expr * fml ) { return false ; } virtual bool mk_atom ( expr * e , bool p , expr_ref & result ) { return false ; } virtual bool is_uninterpreted ( app * f ) { if ( m_produce_models ) { return true ; } switch ( f -> get_decl_kind ( ) ) { case OP_NUM : case OP_LE : case OP_LT : case OP_GE : case OP_GT : case OP_ADD : case OP_SUB : case OP_UMINUS : return false ; case OP_MUL : { arith_util a ( m ) ; expr * m , * n ; if ( a . is_mul ( f , m , n ) && ( a . is_numeral ( m ) || a . is_numeral ( n ) ) ) { return false ; } return true ; } default : return true ; } return true ; } private : void insert_cache ( app * x , expr * e , nlarith :: branch_conditions * brs ) { m_trail . push_back ( x ) ; m_trail . push_back ( e ) ; m_cache . insert ( x , e , brs ) ; } void update_bounds ( expr_ref_vector & lits , atom_set const & tbl , bool is_pos ) { atom_set :: iterator it = tbl . begin ( ) , end = tbl . end ( ) ; for ( ; it != end ; ++ it ) { app * e = * it ; lits . push_back ( is_pos ? e : m . mk_not ( e ) ) ; } } } ; qe_solver_plugin * mk_arith_plugin ( i_solver_context & ctx , bool produce_models , smt_params & p ) { if ( p . m_nlquant_elim ) { return alloc ( nlarith_plugin , ctx , ctx . get_manager ( ) , produce_models ) ; } else { return alloc ( arith_plugin , ctx , ctx . get_manager ( ) , p ) ; } } } </DOCUMENT>
<DOCUMENT_ID="Horizon-Blue/playground/tree/master/Solutions-to-OJs/USACO/Chapter1/1.1/02_your-ride-is-here.cpp"> # include < iostream > # include < fstream > # include < string > using namespace std ; int main ( ) { ofstream fout ( " ride . out " ) ; ifstream fin ( " ride . in " ) ; string a , b ; fin >> a >> b ; int anum = 1 , bnum = 1 ; for ( char c : a ) anum *= c - ' A ' + 1 ; for ( char c : b ) bnum *= c - ' A ' + 1 ; if ( anum % 47 == bnum % 47 ) fout << " GO " << endl ; else fout << " STAY " << endl ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="slicer4ever/Lightwave/tree/master/Engine/Source/C++11/LWEProtocols/LWEProtocolWebSocketSecure.cpp"> # include " LWEProtocols / LWEProtocolWebSocketSecure . h " # include " LWEProtocols / LWEProtocolHTTP . h " # include < LWNetwork / LWSocket . h > # include < LWNetwork / LWProtocolManager . h > # include < LWCore / LWAllocator . h > # include < LWCore / LWCrypto . h > # include < LWCore / LWText . h > # include < LWCore / LWByteBuffer . h > # include < iostream > bool LWEProtocolWebSocketSecure :: ProcessRead ( LWSocket & Socket , const char * Buffer , uint32_t BufferLen ) { char Buf [ 256 ] ; char BufB [ 256 ] ; LWEWebSocket * WebSocket = ( LWEWebSocket * ) Socket . GetProtocolData ( m_wProtocolID ) ; if ( ! WebSocket ) { LWEHttpRequest Request ; uint32_t Error = 0 ; Error = Request . Deserialize ( Buffer , BufferLen ) ? 0 : 1 ; Error = Error ? Error : ( * Request . m_SecWebSockKey && Request . m_WebSockVersion == LWEWEBSOCKET_SUPPVER && Request . UpgradeConnection ( ) ) ? 0 : 2 ; if ( ! Error && * Request . m_SecWebSockProto ) { bool ValidProtocol = false ; if ( * m_SubProtocol ) { uint32_t ProtocolLen = ( uint32_t ) strlen ( m_SubProtocol ) ; for ( const char * C = Request . m_SecWebSockProto ; C && ! ValidProtocol ; C = LWText :: FirstToken ( C , ' , ' ) ) { C = LWText :: NextWord ( * C == ' , ' ? C + 1 : C , true ) ; ValidProtocol = LWText :: Compare ( C , m_SubProtocol , ProtocolLen ) ; } } if ( ! ValidProtocol ) Error = 3 ; } if ( Error ) { std :: cout << " Buffer : " << std :: endl << Buffer << std :: endl ; if ( Error == 1 ) std :: cout << " Error ▁ deserializing ▁ websocket ▁ request . " << std :: endl ; else if ( Error == 2 ) std :: cout << " Error ▁ Headers ▁ did ▁ not ▁ include ▁ correct ▁ websocket ▁ data . " << std :: endl ; else if ( Error == 3 ) std :: cout << " Error ▁ protocol ▁ asked ▁ for ▁ is ▁ not ▁ supported . " << std :: endl ; Socket . MarkClosable ( ) ; return false ; } WebSocket = m_Allocator . Allocate < LWEWebSocket > ( nullptr , nullptr ) ; WebSocket -> m_Socket = & Socket ; * Buf = ' \0' ; strncat ( Buf , Request . m_SecWebSockKey , sizeof ( Buf ) ) ; strncat ( Buf , LWEWEBSOCKET_GUID , sizeof ( Buf ) ) ; LWCrypto :: HashSHA1 ( Buf , ( uint32_t ) strlen ( Buf ) , BufB ) ; uint32_t * uBuf = ( uint32_t * ) BufB ; for ( uint32_t i = 0 ; i < 5 ; i ++ ) uBuf [ i ] = ( uBuf [ i ] & 0xFF ) << 24 | ( uBuf [ i ] & 0xFF00 ) << 8 | ( uBuf [ i ] & 0xFF0000 ) >> 8 | ( uBuf [ i ] & 0xFF000000 ) >> 24 ; uint32_t Len = LWCrypto :: Base64Encode ( BufB , 20 , WebSocket -> m_SecKey , sizeof ( WebSocket -> m_SecKey ) ) ; WebSocket -> m_SecKey [ Len ] = ' \0' ; WebSocket -> SetSecProtocols ( m_SubProtocol ) ; WebSocket -> SetHost ( Request . m_Host ) ; WebSocket -> SetPath ( Request . m_Path ) ; WebSocket -> SetOrigin ( Request . m_Origin ) ; WebSocket -> m_Flag |= LWEWebSocket :: CONNECTING_SERVER ; Socket . SetProtocolData ( m_wProtocolID , WebSocket ) ; PushOutPacket ( nullptr , 0 , WebSocket , LWEWebPacket :: CONTROL_CONNECT ) ; return true ; } if ( ! WebSocket -> IsConnected ( ) ) { if ( WebSocket -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_CLIENT ) { LWEHttpRequest Request ; uint32_t Error = 0 ; Error = Request . Deserialize ( Buffer , BufferLen ) ? 0 : 1 ; Error = Error ? Error : ( ( * Request . m_SecWebSockKey && Request . m_Status == LWEHttpRequest :: SwitchingProtocols ) ? 0 : 2 ) ; if ( Error ) { std :: cout << " Buffer : " << std :: endl << Buffer << std :: endl ; if ( Error == 1 ) std :: cout << " Error ▁ deserializing ▁ websocket ▁ request . " << std :: endl ; else if ( Error == 2 ) std :: cout << " Error ▁ headers ▁ did ▁ not ▁ include ▁ correct ▁ websocket ▁ data . " << std :: endl ; Socket . MarkClosable ( ) ; return false ; } WebSocket -> m_Flag = ( WebSocket -> m_Flag & ~ LWEWebSocket :: CONNECTING_CLIENT ) | LWEWebSocket :: CONNECTED_CLIENT ; } return true ; } char IPBuf [ 32 ] ; LWSocket :: MakeAddress ( Socket . GetRemoteIP ( ) , IPBuf , sizeof ( IPBuf ) ) ; if ( BufferLen > 100 ) { } LWEWebPacket * OPack ; uint32_t Target ; uint32_t ReservePos ; uint32_t o = 0 ; while ( o != BufferLen ) { uint32_t Res = WebSocket -> m_ActivePacket . Deserialize ( Buffer + o , BufferLen - o , m_Allocator ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ deserializing ▁ data . " << std :: endl ; return false ; } o += Res ; if ( ! WebSocket -> m_ActivePacket . Finished ( ) ) continue ; if ( WebSocket -> m_ActivePacket . m_DataLen != WebSocket -> m_ActivePacket . m_DataPos ) continue ; if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_CLOSED ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; Socket . MarkClosable ( ) ; return true ; } else if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_PING ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; PushOutPacket ( nullptr , 0 , WebSocket , LWEWebPacket :: CONTROL_PONG ) ; continue ; } else if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_PONG ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; continue ; } WebSocket -> m_ActivePacket . m_WebSocket = WebSocket ; if ( ! m_InPackets . PushStart ( & OPack , Target , ReservePos ) ) return false ; * OPack = std :: move ( WebSocket -> m_ActivePacket ) ; m_InPackets . PushFinished ( Target , ReservePos ) ; } return true ; } LWProtocol & LWEProtocolWebSocketSecure :: SocketClosed ( LWSocket & Socket , LWProtocolManager * Manager ) { LWEProtocolTLS :: SocketClosed ( Socket , Manager ) ; LWEWebSocket * WebSock = ( LWEWebSocket * ) Socket . GetProtocolData ( m_wProtocolID ) ; bool Del = true ; if ( m_WebSocketClosedCallback ) Del = m_WebSocketClosedCallback ( Socket , WebSock , Manager ) ; if ( WebSock ) WebSock -> m_Socket = nullptr ; if ( Del ) LWAllocator :: Destroy ( WebSock ) ; return * this ; } LWProtocol & LWEProtocolWebSocketSecure :: SocketChanged ( LWSocket & Prev , LWSocket & New , LWProtocolManager * Manager ) { LWEProtocolTLS :: SocketChanged ( Prev , New , Manager ) ; LWEWebSocket * WebSocket = ( LWEWebSocket * ) Prev . GetProtocolData ( m_wProtocolID ) ; New . SetProtocolData ( m_wProtocolID , Prev . GetProtocolData ( m_wProtocolID ) ) ; if ( WebSocket ) WebSocket -> m_Socket = & New ; if ( m_WebSocketChangedCallback ) m_WebSocketChangedCallback ( Prev , New , WebSocket , Manager ) ; return * this ; } LWProtocol & LWEProtocolWebSocketSecure :: ProcessTLSData ( LWSocket & Socket , const char * Data , uint32_t DataLen ) { ProcessRead ( Socket , Data , DataLen ) ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: ProcessOutPackets ( void ) { char Buffer [ 1024 * 64 ] ; LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; while ( m_OutPackets . PopStart ( & Pack , Target , ReservePos ) ) { LWEWebPacket RPack = std :: move ( * Pack ) ; m_OutPackets . PopFinshed ( Target , ReservePos ) ; LWEWebSocket * Sock = RPack . m_WebSocket ; if ( ! Sock -> IsConnected ( ) && ( RPack . m_ControlFlag & LWEWebPacket :: CONTROL_CONNECT ) ) { if ( ! Sock -> m_Socket ) return * this ; LWEHttpRequest Request ; Request . SetWebSockKey ( Sock -> m_SecKey ) ; Request . SetWebSockProto ( m_SubProtocol ) ; Request . m_Flag |= LWEHttpRequest :: ConnectionUpgrade | LWEHttpRequest :: UpgradeWebSock ; Request . m_Status = Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_SERVER ? LWEHttpRequest :: SwitchingProtocols : 0 ; if ( Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_CLIENT ) { Request . SetHost ( Sock -> m_Host ) . SetPath ( Sock -> m_Path ) . SetOrigin ( Sock -> m_Origin ) ; Request . m_WebSockVersion = LWEWEBSOCKET_SUPPVER ; } else Sock -> m_Flag = ( Sock -> m_Flag & ~ LWEWebSocket :: CONNECTING_SERVER ) | LWEWebSocket :: CONNECTED_SERVER ; uint32_t Len = Request . Serialize ( Buffer , sizeof ( Buffer ) , Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_CLIENT ? m_UserAgent : m_Server ) ; std :: cout << " Sending ▁ headers ! " << std :: endl ; uint32_t Res = Send ( * Sock -> m_Socket , Buffer , Len ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ sending ▁ data . " << std :: endl ; return * this ; } if ( ! Res ) { if ( Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_SERVER ) Sock -> m_Flag = ( Sock -> m_Flag & ~ LWEWebSocket :: CONNECTING_SERVER ) | LWEWebSocket :: CONNECTING_SERVER ; PushOutPacket ( nullptr , 0 , Sock , LWEWebPacket :: CONTROL_CONNECT ) ; return * this ; } } if ( RPack . m_ControlFlag & LWEWebPacket :: CONTROL_CONNECT ) continue ; if ( ! Sock -> IsConnected ( ) ) { if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) { std :: cout << " Error ▁ re - inserting ▁ packet . " << std :: endl ; return * this ; } * Pack = std :: move ( RPack ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; return * this ; } std :: cout << " Sending ▁ data : ▁ " << RPack . GetOp ( ) << " ▁ Len : ▁ " << RPack . m_DataLen << " ▁ Fin : ▁ " << RPack . m_ControlFlag << std :: endl ; LWSocket * rSock = RPack . m_WebSocket -> m_Socket ; if ( ! rSock ) continue ; uint32_t Len = RPack . Serialize ( Buffer , sizeof ( Buffer ) , Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_CLIENT ) ; std :: cout << " Serialized : ▁ " << Len << std :: endl ; uint32_t Res = Send ( * rSock , Buffer , Len ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ sending ▁ data . " << std :: endl ; return * this ; } if ( ! Res ) { if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) { std :: cout << " Error ▁ re - inserting ▁ packet . " << std :: endl ; return * this ; } * Pack = std :: move ( RPack ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; } } return * this ; } LWEWebSocket * LWEProtocolWebSocketSecure :: OpenSocket ( const char * URI , uint32_t ProtocolID , const char * Origin ) { char Host [ 256 ] ; char Path [ 256 ] ; char Protocol [ 256 ] ; uint16_t Port = LWEHttpRequest :: ParseURI ( URI , Host , sizeof ( Host ) , nullptr , Path , sizeof ( Path ) , nullptr , Protocol , sizeof ( Protocol ) , nullptr ) ; LWSocket Sock ; uint32_t Err = LWSocket :: CreateSocket ( Sock , Host , Port , LWSocket :: Tcp , ProtocolID ) ; if ( Err ) { std :: cout << " Error ▁ creating ▁ socket : ▁ " << Err << std :: endl ; return nullptr ; } LWSocket * S = m_Manager -> PushSocket ( Sock ) ; LWEWebSocket * WebSock = m_Allocator . Allocate < LWEWebSocket > ( URI , Origin ) ; WebSock -> m_Flag |= LWEWebSocket :: CONNECTING_CLIENT ; WebSock -> GenerateKey ( m_KeySeed ++ ) ; S -> SetProtocolData ( m_wProtocolID , WebSock ) ; WebSock -> m_Socket = S ; PushOutPacket ( nullptr , 0 , WebSock , LWEWebPacket :: CONTROL_CONNECT ) ; return WebSock ; } bool LWEProtocolWebSocketSecure :: PushOutPacket ( const char * Buffer , uint32_t BufferLen , LWEWebSocket * Socket , uint32_t ControlFlag ) { LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) return false ; * Pack = LWEWebPacket ( Buffer , BufferLen , m_Allocator , ControlFlag | LWEWebPacket :: CONTROL_FINISHED , Socket ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; return true ; } bool LWEProtocolWebSocketSecure :: GetNextPacket ( LWEWebPacket & Packet ) { LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; if ( ! m_InPackets . PopStart ( & Pack , Target , ReservePos ) ) return false ; Packet = std :: move ( * Pack ) ; m_InPackets . PopFinshed ( Target , ReservePos ) ; return true ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetServer ( const char * Server ) { * m_Server = ' \0' ; strncat ( m_Server , Server , sizeof ( m_Server ) ) ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetUserAgent ( const char * Agent ) { * m_UserAgent = ' \0' ; strncat ( m_UserAgent , Agent , sizeof ( m_UserAgent ) ) ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetSubProtocol ( const char * SubProtocol ) { * m_SubProtocol = ' \0' ; strncat ( m_SubProtocol , SubProtocol , sizeof ( m_SubProtocol ) ) ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetWebSocketClosedCallback ( std :: function < bool ( LWSocket & , LWEWebSocket * , LWProtocolManager * ) > WebSocketClosedCallback ) { m_WebSocketClosedCallback = WebSocketClosedCallback ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetWebSocketChangedCallback ( std :: function < void ( LWSocket & , LWSocket & , LWEWebSocket * , LWProtocolManager * ) > WebSocketChangedCallback ) { m_WebSocketChangedCallback = WebSocketChangedCallback ; return * this ; } LWEProtocolWebSocketSecure :: LWEProtocolWebSocketSecure ( uint32_t ProtocolID , uint32_t TLSProtocolID , LWAllocator & Allocator , LWProtocolManager * Manager , const char * CertFile , const char * KeyFile ) : LWEProtocolTLS ( TLSProtocolID , Allocator , CertFile , KeyFile ) , m_wProtocolID ( ProtocolID ) , m_Allocator ( Allocator ) , m_Manager ( Manager ) , m_KeySeed ( 0 ) { * m_Server = * m_UserAgent = * m_SubProtocol = ' \0' ; m_WebSocketClosedCallback = nullptr ; m_WebSocketChangedCallback = nullptr ; } </DOCUMENT>
<DOCUMENT_ID="OpenDSA/OpenDSA-stable/tree/master/SourceCode/C++/Sorting/Heapsort.cpp"> # include " Maxheap . cpp " void heapsort ( Comparable * A [ ] , int n ) { std :: cout << " Getting ▁ started ▁ with ▁ array : " << std :: endl ; for ( int j = 0 ; j < n ; j ++ ) std :: cout << * A [ j ] << " ▁ " ; std :: cout << std :: endl ; MaxHeap H ( A , n , n ) ; std :: cout << " Now , ▁ ready ▁ to ▁ unpack ▁ the ▁ heap " << std :: endl ; for ( int i = 0 ; i < n ; i ++ ) H . removemax ( ) ; } bool sorttest ( int array [ ] , int n , int threshold ) { Comparable * A [ n ] ; int i ; cout << " We ▁ came ▁ in ▁ with ▁ array : " << endl ; for ( i = 0 ; i < n ; i ++ ) std :: cout << array [ i ] << " ▁ " ; std :: cout << std :: endl ; for ( i = 0 ; i < n ; ++ i ) { A [ i ] = new Int ( array [ i ] ) ; } cout << " We ▁ are ▁ going ▁ to ▁ call ▁ Heapsort ▁ with ▁ this ▁ array : " << endl ; for ( i = 0 ; i < n ; i ++ ) std :: cout << A [ i ] << " ▁ " ; std :: cout << std :: endl ; heapsort ( A , n ) ; if ( ! checkorder ( A , n ) ) return false ; for ( i = 0 ; i < n ; ++ i ) { delete A [ i ] ; } for ( i = 0 ; i < n ; ++ i ) { A [ i ] = new KVPair ( array [ i ] , & array [ i ] ) ; } if ( ! checkorder ( A , n ) ) return false ; for ( i = 0 ; i < n ; ++ i ) { delete A [ i ] ; } delete [ ] array ; return true ; } # include " SortTest . cpp " </DOCUMENT>
<DOCUMENT_ID="dandan94/OpenGLTest/tree/master/finalOpenGL/HelloGLFW/lib/boost_1_59_0/libs/lexical_cast/test/lexical_cast_iterator_range_test.cpp"> # include < boost / config . hpp > # if defined ( __INTEL_COMPILER ) # pragma warning ( disable : 193 383 488 981 1418 1419 ) # elif defined ( BOOST_MSVC ) # pragma warning ( disable : 4097 4100 4121 4127 4146 4244 4245 4511 4512 4701 4800 ) # endif # include < boost / lexical_cast . hpp > # include < boost / test / unit_test . hpp > # include < boost / range / iterator_range . hpp > using namespace boost ; # if defined ( BOOST_NO_STRINGSTREAM ) || defined ( BOOST_NO_STD_WSTRING ) # define BOOST_LCAST_NO_WCHAR_T # endif # if ! defined ( BOOST_NO_CXX11_CHAR16_T ) && ! defined ( BOOST_NO_CXX11_UNICODE_LITERALS ) && ! defined ( _LIBCPP_VERSION ) # define BOOST_LC_RUNU16 # endif # if ! defined ( BOOST_NO_CXX11_CHAR32_T ) && ! defined ( BOOST_NO_CXX11_UNICODE_LITERALS ) && ! defined ( _LIBCPP_VERSION ) # define BOOST_LC_RUNU32 # endif struct class_with_user_defined_sream_operators { int i ; operator int ( ) const { return i ; } } ; template < class CharT > inline std :: basic_istream < CharT > & operator >> ( std :: basic_istream < CharT > & istr , class_with_user_defined_sream_operators & rhs ) { return istr >> rhs . i ; } template < class RngT > void do_test_iterator_range_impl ( const RngT & rng ) { BOOST_CHECK_EQUAL ( lexical_cast < int > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < int > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned int > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned int > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < short > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < short > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned short > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned short > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < long int > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < long int > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned long int > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned long int > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; # ifdef BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng . begin ( ) , rng . size ( ) ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng ) , 1.0 ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng . begin ( ) , rng . size ( ) ) , 1.0 ) ; # ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng ) , 1.0L ) ; BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng . begin ( ) , rng . size ( ) ) , 1.0L ) ; # endif BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( rng ) , 1 ) ; # endif # if defined ( BOOST_HAS_LONG_LONG ) BOOST_CHECK_EQUAL ( lexical_cast < boost :: ulong_long_type > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: ulong_long_type > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: long_long_type > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: long_long_type > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; # elif defined ( BOOST_HAS_MS_INT64 ) BOOST_CHECK_EQUAL ( lexical_cast < unsigned __int64 > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned __int64 > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < __int64 > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < __int64 > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; # endif } template < class CharT > void test_it_range_using_any_chars ( CharT * one , CharT * eleven ) { typedef CharT test_char_type ; iterator_range < test_char_type * > rng1 ( one , one + 1 ) ; do_test_iterator_range_impl ( rng1 ) ; iterator_range < const test_char_type * > crng1 ( one , one + 1 ) ; do_test_iterator_range_impl ( crng1 ) ; iterator_range < test_char_type * > rng2 ( eleven , eleven + 1 ) ; do_test_iterator_range_impl ( rng2 ) ; iterator_range < const test_char_type * > crng2 ( eleven , eleven + 1 ) ; do_test_iterator_range_impl ( crng2 ) ; } template < class CharT > void test_it_range_using_char ( CharT * one , CharT * eleven ) { typedef CharT test_char_type ; iterator_range < test_char_type * > rng1 ( one , one + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( rng1 ) , "1" ) ; iterator_range < const test_char_type * > crng1 ( one , one + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( crng1 ) , "1" ) ; iterator_range < test_char_type * > rng2 ( eleven , eleven + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( rng2 ) , "1" ) ; iterator_range < const test_char_type * > crng2 ( eleven , eleven + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( crng2 ) , "1" ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng1 ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng1 ) , 1.0 ) ; # ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng1 ) , 1.0L ) ; # endif BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( rng1 ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( crng2 ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( crng2 ) , 1.0 ) ; # ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS BOOST_CHECK_EQUAL ( lexical_cast < long double > ( crng2 ) , 1.0L ) ; # endif BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( crng2 ) , 1 ) ; # ifndef BOOST_LCAST_NO_WCHAR_T BOOST_CHECK ( lexical_cast < std :: wstring > ( rng1 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( crng1 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( rng2 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( crng2 ) == L " 1" ) ; # endif # if defined ( BOOST_LC_RUNU16 ) && defined ( BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES ) typedef std :: basic_string < char16_t > my_char16_string ; BOOST_CHECK ( lexical_cast < my_char16_string > ( rng1 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( crng1 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( rng2 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( crng2 ) == u " 1" ) ; # endif # if defined ( BOOST_LC_RUNU32 ) && defined ( BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES ) typedef std :: basic_string < char32_t > my_char32_string ; BOOST_CHECK ( lexical_cast < my_char32_string > ( rng1 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( crng1 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( rng2 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( crng2 ) == U " 1" ) ; # endif } void test_char_iterator_ranges ( ) { typedef char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; } void test_unsigned_char_iterator_ranges ( ) { typedef unsigned char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; } void test_signed_char_iterator_ranges ( ) { typedef signed char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; } void test_wchar_iterator_ranges ( ) { # ifndef BOOST_LCAST_NO_WCHAR_T typedef wchar_t test_char_type ; test_char_type data1 [ ] = L " 1" ; test_char_type data2 [ ] = L " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; # endif BOOST_CHECK ( true ) ; } void test_char16_iterator_ranges ( ) { # if defined ( BOOST_LC_RUNU16 ) typedef char16_t test_char_type ; test_char_type data1 [ ] = u " 1" ; test_char_type data2 [ ] = u " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; # endif BOOST_CHECK ( true ) ; } void test_char32_iterator_ranges ( ) { # if defined ( BOOST_LC_RUNU32 ) typedef char32_t test_char_type ; test_char_type data1 [ ] = U " 1" ; test_char_type data2 [ ] = U " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; # endif BOOST_CHECK ( true ) ; } unit_test :: test_suite * init_unit_test_suite ( int , char * [ ] ) { unit_test :: test_suite * suite = BOOST_TEST_SUITE ( " lexical _ cast . ▁ Testing ▁ conversions ▁ using ▁ iterator _ range < > " ) ; suite -> add ( BOOST_TEST_CASE ( & test_char_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_unsigned_char_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_signed_char_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_wchar_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_char16_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_char32_iterator_ranges ) ) ; return suite ; } </DOCUMENT>
<DOCUMENT_ID="osgcc/ryzom/tree/master/ryzom/tools/leveldesign/georges_dll/form_dialog.cpp"> # include " stdafx . h " # include " georges _ edit . h " # include " georges _ edit _ view . h " # include " georges _ edit _ doc . h " # include " form _ dialog . h " # include " action . h " # include " left _ view . h " # include " nel / misc / path . h " # include " nel / georges / type . h " # include " nel / georges / form _ elm . h " using namespace std ; using namespace NLMISC ; using namespace NLGEORGES ; CFormDialog :: CFormDialog ( ) : CBaseDialog ( IDR_MAINFRAME ) { View = NULL ; WidgetIndexCount = 0 ; WidgetFocused = 0xffffffff ; } CFormDialog :: ~ CFormDialog ( ) { clear ( ) ; } void CFormDialog :: clear ( ) { unRegisterLastControl ( ) ; for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) delete Widgets [ i ] ; Widgets . clear ( ) ; WidgetFocused = 0xffffffff ; WidgetIndexCount = 0 ; } void CFormDialog :: DoDataExchange ( CDataExchange * pDX ) { CDialog :: DoDataExchange ( pDX ) ; } BEGIN_MESSAGE_MAP ( CFormDialog , CDialog ) ON_WM_SIZE ( ) ON_WM_LBUTTONDOWN ( ) ON_WM_SETFOCUS ( ) ON_WM_KILLFOCUS ( ) END_MESSAGE_MAP ( ) void CFormDialog :: OnSize ( UINT nType , int cx , int cy ) { CBaseDialog :: OnSize ( nType , cx , cy ) ; } BOOL CFormDialog :: OnInitDialog ( ) { CBaseDialog :: OnInitDialog ( ) ; SetDefID ( 0xffffffff ) ; UpdateData ( FALSE ) ; return TRUE ; } void CFormDialog :: OnOK ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateData ( ) ; if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onOk ( ) ; } } } void CFormDialog :: OnCancel ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateData ( ) ; if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onCancel ( ) ; return ; } } CBaseDialog :: OnCancel ( ) ; } CWnd * CFormDialog :: addTypeWidget ( const NLGEORGES :: CType & type , uint elmIndex , const char * title , const char * atomName , const char * typeFilename , RECT & currentPos , CForm & form , IFormWidget :: TTypeSrc typeWidget , const char * filenameExt , uint slot ) { switch ( type . UIType ) { case CType :: FileBrowser : case CType :: Edit : case CType :: EditSpin : { CFormMemCombo * memCombo = new CFormMemCombo ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; string tfn = typeFilename ; string key = GEORGES_EDIT_BASE_REG_KEY " \\ " + strlwr ( typeFilename ) + " ▁ MemCombo " ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title , key . c_str ( ) , type . UIType == CType :: EditSpin , type . UIType == CType :: FileBrowser , filenameExt ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Combo ; } break ; case CType :: NonEditableCombo : { CFormCombo * memCombo = new CFormCombo ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Combo ; } break ; case CType :: BigEdit : { CFormBigEdit * memCombo = new CFormBigEdit ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Edit ; } break ; case CType :: ColorEdit : { CColorEdit * memCombo = new CColorEdit ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Color ; } break ; } return NULL ; } void CFormDialog :: getVirtualDfnFromDocument ( const NLGEORGES :: CFormDfn * _dfn , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; CFormMemCombo * memCombo = new CFormMemCombo ( this , 0xffffffff , structName , IFormWidget :: TypeVirtualDfn , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Dfn : " , GEORGES_EDIT_BASE_REG_KEY " \\Virtual ▁ Dfn ▁ MemCombo " , false , true , " * . dfn " ) ; memCombo -> getFromDocument ( * doc -> getFormPtr ( ) ) ; if ( _dfn ) { std :: vector < const CFormDfn * > arrayDfn ; arrayDfn . reserve ( _dfn -> countParentDfn ( ) ) ; _dfn -> getParentDfn ( arrayDfn ) ; uint elmIndex = 0 ; for ( uint dfnIndex = 0 ; dfnIndex < arrayDfn . size ( ) ; dfnIndex ++ ) { nlassert ( arrayDfn [ dfnIndex ] ) ; const CFormDfn & dfn = * arrayDfn [ dfnIndex ] ; for ( uint i = 0 ; i < dfn . getNumEntry ( ) ; i ++ ) { const CFormDfn :: CEntry & entry = dfn . getEntry ( i ) ; if ( entry . getType ( ) == UFormDfn :: EntryType && ! entry . getArrayFlag ( ) ) { string title = entry . getName ( ) + " : " ; string atomName = string ( structName ) + " . " + entry . getName ( ) ; addTypeWidget ( * entry . getTypePtr ( ) , elmIndex , title . c_str ( ) , atomName . c_str ( ) , entry . getFilename ( ) . c_str ( ) , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeForm , entry . getFilenameExt ( ) . c_str ( ) , slot ) ; } elmIndex ++ ; } } } registerLastControl ( ) ; } } } void CFormDialog :: getDfnFromDocument ( const NLGEORGES :: CFormDfn & _dfn , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; std :: vector < const CFormDfn * > arrayDfn ; arrayDfn . reserve ( _dfn . countParentDfn ( ) ) ; _dfn . getParentDfn ( arrayDfn ) ; if ( strcmp ( structName , " " ) == 0 ) { CListWidget * listWidget = new CListWidget ( this , 0xffffffff , " " , IFormWidget :: TypeFormParent , slot ) ; Widgets . push_back ( listWidget ) ; listWidget -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Parent ▁ Form : " , GEORGES_EDIT_BASE_REG_KEY " \\Parent ▁ Form ▁ MemCombo " , 1 ) ; listWidget -> addColumn ( " Parent ▁ filename " ) ; listWidget -> getFromDocument ( * doc -> getFormPtr ( ) ) ; } CWnd * pWnd = NULL ; CWnd * pWndIcon = NULL ; CWnd * pWndIconColor = NULL ; CWnd * pWndIconBack = NULL ; CWnd * pWndIconBackColor = NULL ; CWnd * pWndIconOver = NULL ; CWnd * pWndIconOverColor = NULL ; CWnd * pWndIconOver2 = NULL ; CWnd * pWndIconOver2Color = NULL ; uint elmIndex = 0 ; for ( uint dfnIndex = 0 ; dfnIndex < arrayDfn . size ( ) ; dfnIndex ++ ) { nlassert ( arrayDfn [ dfnIndex ] ) ; const CFormDfn & dfn = * arrayDfn [ dfnIndex ] ; for ( uint i = 0 ; i < dfn . getNumEntry ( ) ; i ++ ) { const CFormDfn :: CEntry & entry = dfn . getEntry ( i ) ; if ( entry . getType ( ) == UFormDfn :: EntryType && ! entry . getArrayFlag ( ) ) { string title = entry . getName ( ) + " : " ; string atomName = string ( structName ) + " . " + entry . getName ( ) ; pWnd = addTypeWidget ( * entry . getTypePtr ( ) , elmIndex , title . c_str ( ) , atomName . c_str ( ) , entry . getFilename ( ) . c_str ( ) , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeForm , entry . getFilenameExt ( ) . c_str ( ) , slot ) ; if ( entry . getName ( ) == " Icon " || entry . getName ( ) == " icon " ) pWndIcon = pWnd ; else if ( entry . getName ( ) == " IconColor " ) pWndIconColor = pWnd ; else if ( entry . getName ( ) == " IconBack " || entry . getName ( ) == " icon ▁ background " ) pWndIconBack = pWnd ; else if ( entry . getName ( ) == " IconBackColor " ) pWndIconBackColor = pWnd ; else if ( entry . getName ( ) == " IconOver " || entry . getName ( ) == " icon ▁ overlay " ) pWndIconOver = pWnd ; else if ( entry . getName ( ) == " IconOverColor " ) pWndIconOverColor = pWnd ; else if ( entry . getName ( ) == " IconOver2" || entry . getName ( ) == " icon ▁ overlay2" ) pWndIconOver2 = pWnd ; else if ( entry . getName ( ) == " IconOver2Color " ) pWndIconOver2Color = pWnd ; } elmIndex ++ ; } } if ( ( string ( structName ) == " . Client " ) || ( string ( structName ) == " . 3d " ) ) { string title = " Icon ▁ bitmap : " ; CIconWidget * w = new CIconWidget ( this , elmIndex , " " , IFormWidget :: TypeFormParent , slot ) ; Widgets . push_back ( w ) ; w -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title . c_str ( ) ) ; w -> Icon . pWndIcon = pWndIcon ; w -> Icon . pWndIconColor = pWndIconColor ; w -> Icon . pWndIconBack = pWndIconBack ; w -> Icon . pWndIconBackColor = pWndIconBackColor ; w -> Icon . pWndIconOver = pWndIconOver ; w -> Icon . pWndIconOverColor = pWndIconOverColor ; w -> Icon . pWndIconOver2 = pWndIconOver2 ; w -> Icon . pWndIconOver2Color = pWndIconOver2Color ; } registerLastControl ( ) ; } } } void CFormDialog :: getArrayFromDocument ( const char * structName , uint structId , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; CFormMemCombo * memCombo = new CFormMemCombo ( this , structId , structName , IFormWidget :: TypeArray , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Array ▁ size : " , GEORGES_EDIT_BASE_REG_KEY " \\Array ▁ Size ▁ MemCombo " , true , false , NULL ) ; memCombo -> getFromDocument ( * doc -> getFormPtr ( ) ) ; registerLastControl ( ) ; } } } void CFormDialog :: getTypeFromDocument ( const NLGEORGES :: CType & _type , const char * name , const char * typeFilename , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; addTypeWidget ( _type , 0xffffffff , name , structName , typeFilename , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeType , NULL , slot ) ; registerLastControl ( ) ; } } } void CFormDialog :: updateLabels ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateLabel ( ) ; } } void CFormDialog :: updateValues ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateLabel ( ) ; Widgets [ i ] -> getFromDocument ( * ( View -> GetDocument ( ) -> getFormPtr ( ) ) ) ; } } void CFormDialog :: setToDocument ( uint widget ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { CIconWidget * iconWidget = dynamic_cast < CIconWidget * > ( Widgets [ widget ] ) ; if ( iconWidget ) return ; if ( Widgets [ widget ] -> getFormName ( ) != " NULL " ) { const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( Widgets [ widget ] -> getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( Widgets [ widget ] -> getFormName ( ) . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; if ( parentVDfnArray ) { if ( ! theApp . yesNo ( " Warning , ▁ this ▁ action ▁ will ▁ create ▁ an ▁ array / virtual ▁ dfn ▁ over ▁ an ▁ inherited ▁ array / virtual ▁ dfn . \n Do ▁ you ▁ want ▁ to ▁ continue ▁ ? " ) ) return ; } } IFormWidget :: TTypeSrc typeSrc = Widgets [ widget ] -> getSrcType ( ) ; if ( typeSrc == IFormWidget :: TypeForm ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionString ( IAction :: FormValue , result . c_str ( ) , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeFormParent ) { CForm * form = doc -> getFormPtr ( ) ; uint count = Widgets [ widget ] -> getNumValue ( ) ; vector < string > stringVector ( count ) ; for ( uint value = 0 ; value < count ; value ++ ) { Widgets [ widget ] -> getValue ( stringVector [ value ] , value ) ; } doc -> modify ( new CActionStringVector ( IAction :: FormParents , stringVector , * doc , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeArray ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionBuffer ( IAction :: FormArraySize , NULL , 0 , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , result . c_str ( ) , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeType ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionString ( IAction :: FormTypeValue , result . c_str ( ) , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeVirtualDfn ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionBuffer ( IAction :: FormVirtualDfnName , NULL , 0 , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , result . c_str ( ) , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } } if ( ! Widgets [ widget ] -> getFormName ( ) . empty ( ) ) doc -> notifyPlugins ( Widgets [ widget ] -> getFormName ( ) . c_str ( ) ) ; } LRESULT CFormDialog :: WindowProc ( UINT message , WPARAM wParam , LPARAM lParam ) { switch ( message ) { case CL_CHANGED : { uint widgetId = getWidget ( wParam ) ; CColorEdit * colorEdit = safe_cast < CColorEdit * > ( Widgets [ widgetId ] ) ; colorEdit -> Empty = false ; setToDocument ( getWidget ( wParam ) ) ; } break ; case MC_STRINGCHANGE : { setToDocument ( getWidget ( wParam ) ) ; } break ; case CBN_CHANGED : { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { CIconWidget * iconWidget = dynamic_cast < CIconWidget * > ( Widgets [ i ] ) ; if ( iconWidget ) iconWidget -> Icon . Invalidate ( ) ; } } break ; } return CDialog :: WindowProc ( message , wParam , lParam ) ; } void CFormDialog :: onOpenSelected ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onOpenSelected ( ) ; } } } CWnd * CFormDialog :: GetNextDlgTabItem ( CWnd * pWndCtl , BOOL bPrevious ) const { return NULL ; } void CFormDialog :: onFirstFocus ( ) { View -> SetFocus ( ) ; WidgetFocused = 0xffffffff ; } void CFormDialog :: onLastFocus ( ) { View -> setFocusLeftView ( ) ; WidgetFocused = 0xffffffff ; } int CFormDialog :: getWidget ( uint dialogId ) const { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { if ( Widgets [ i ] -> isDialog ( dialogId ) ) return i ; } return - 1 ; } BOOL CFormDialog :: OnCommand ( WPARAM wParam , LPARAM lParam ) { switch ( HIWORD ( wParam ) ) { case CBN_SETFOCUS : { onGetSubFocus ( LOWORD ( wParam ) ) ; } return TRUE ; case EN_SETFOCUS : { onGetSubFocus ( LOWORD ( wParam ) ) ; } return TRUE ; case CBN_SELCHANGE : { int widgetId = getWidget ( LOWORD ( wParam ) ) ; if ( widgetId != - 1 ) setToDocument ( widgetId ) ; } return TRUE ; case EN_CHANGE : { int widgetId = getWidget ( LOWORD ( wParam ) ) ; if ( widgetId != - 1 ) { CColorEdit * colorEdit = dynamic_cast < CColorEdit * > ( Widgets [ widgetId ] ) ; if ( colorEdit ) { CString str ; colorEdit -> Edit . GetWindowText ( str ) ; sint r , g , b ; if ( sscanf ( str , " % d , % d , % d " , & r , & g , & b ) == 3 ) { clamp ( r , 0 , 255 ) ; clamp ( g , 0 , 255 ) ; clamp ( b , 0 , 255 ) ; CRGBA color ( r , g , b ) ; colorEdit -> Color . setColor ( color ) ; if ( r != 255 && g != 255 && b != 255 ) colorEdit -> Empty = false ; } } } } return TRUE ; case BN_CLICKED : { int widgetId = getWidget ( LOWORD ( wParam ) ) ; if ( widgetId != - 1 ) { if ( ( Widgets [ widgetId ] -> getSrcType ( ) == IFormWidget :: TypeForm ) || ( Widgets [ widgetId ] -> getSrcType ( ) == IFormWidget :: TypeType ) ) { CFormMemCombo * combo = dynamic_cast < CFormMemCombo * > ( Widgets [ widgetId ] ) ; if ( combo && IsWindow ( combo -> Browse ) ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( Widgets [ widgetId ] -> getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( Widgets [ widgetId ] -> getFormName ( ) . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; nlassert ( parentDfn ) ; string ext = parentDfn -> getEntry ( indexDfn ) . getFilenameExt ( ) ; char typeName [ 512 ] ; smprintf ( typeName , 512 , " % s " , strlwr ( ext ) . c_str ( ) ) ; uint i = 0 ; while ( ( typeName [ i ] == ' . ' ) || ( typeName [ i ] == ' * ' ) ) i ++ ; if ( typeName [ i ] ) typeName [ i ] = toupper ( typeName [ i ] ) ; char filter [ 512 ] ; smprintf ( filter , 512 , " % s ▁ Files ▁ ( % s ) | % s | All ▁ Files ( * . * ) | * . * | " , typeName + i , ext . c_str ( ) , ext . c_str ( ) ) ; CFileDialog dlgFile ( TRUE , ext . c_str ( ) , ext . c_str ( ) , OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT , filter , theApp . m_pMainWnd ) ; if ( dlgFile . DoModal ( ) == IDOK ) { combo -> Combo . UpdateData ( ) ; combo -> Combo . SetWindowText ( dlgFile . GetFileName ( ) ) ; combo -> Combo . UpdateData ( FALSE ) ; setToDocument ( widgetId ) ; PostMessage ( CBN_CHANGED , 0 , 0 ) ; } } } else { CColorEdit * colorEdit = dynamic_cast < CColorEdit * > ( Widgets [ widgetId ] ) ; if ( colorEdit && IsWindow ( colorEdit -> Color ) ) { colorEdit -> Empty = true ; colorEdit -> Edit . SetWindowText ( " " ) ; setToDocument ( getWidget ( wParam ) ) ; updateValues ( ) ; } } } else if ( Widgets [ widgetId ] -> getSrcType ( ) == IFormWidget :: TypeVirtualDfn ) { CFormMemCombo * combo = dynamic_cast < CFormMemCombo * > ( Widgets [ widgetId ] ) ; if ( combo && IsWindow ( combo -> Browse ) ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { char filter [ 512 ] ; smprintf ( filter , 512 , " Dfn ▁ Files ▁ ( * . dfn ) | * . dfn | All ▁ Files ( * . * ) | * . * | " ) ; CFileDialog dlgFile ( TRUE , " * . dfn " , " * . dfn " , OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT , filter , theApp . m_pMainWnd ) ; if ( dlgFile . DoModal ( ) == IDOK ) { combo -> Combo . UpdateData ( ) ; combo -> Combo . SetWindowText ( dlgFile . GetFileName ( ) ) ; combo -> Combo . UpdateData ( FALSE ) ; setToDocument ( widgetId ) ; } } } } else if ( Widgets [ widgetId ] -> getSrcType ( ) == IFormWidget :: TypeFormParent ) { setToDocument ( widgetId ) ; } } } return TRUE ; } return CWnd :: OnCommand ( wParam , lParam ) ; } BOOL CFormDialog :: OnNotify ( WPARAM wParam , LPARAM lParam , LRESULT * pResult ) { LPNMHDR pnmh = ( LPNMHDR ) lParam ; int idCtrl = ( int ) wParam ; switch ( pnmh -> code ) { case NM_SETFOCUS : { onGetSubFocus ( idCtrl ) ; } break ; case UDN_DELTAPOS : { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { if ( Widgets [ i ] -> isDialog ( idCtrl ) ) { Widgets [ i ] -> getFormName ( ) ; LPNMUPDOWN lpnmud = ( LPNMUPDOWN ) lParam ; CFormMemCombo * combo = ( CFormMemCombo * ) Widgets [ i ] ; float value ; CString str ; combo -> Combo . UpdateData ( ) ; combo -> Combo . GetWindowText ( str ) ; if ( sscanf ( str , " % f " , & value ) == 1 ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { const CFormDfn * parentDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; uint lastElement ; bool array ; bool parentVDfnArray ; UFormDfn :: TEntryType type ; nlverify ( ( const CFormElm * ) ( doc -> getRootNode ( Widgets [ i ] -> getSlot ( ) ) ) -> getNodeByName ( Widgets [ i ] -> getFormName ( ) . c_str ( ) , & parentDfn , lastElement , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; float increment = 1 ; if ( nodeType ) sscanf ( nodeType -> Increment . c_str ( ) , " % f " , & increment ) ; value -= ( float ) ( lpnmud -> iDelta ) * increment ; char result [ 512 ] ; sprintf ( result , " % g " , value ) ; combo -> Combo . SetWindowText ( result ) ; combo -> Combo . UpdateData ( FALSE ) ; setToDocument ( i ) ; } } break ; } } } break ; } return CDialog :: OnNotify ( wParam , lParam , pResult ) ; } void CFormDialog :: resizeWidgets ( ) { if ( Widgets . size ( ) ) { RECT viewRect ; View -> GetClientRect ( & viewRect ) ; uint virtualWidth = std :: max ( ( uint ) MinViewWidth , ( uint ) ( viewRect . right - viewRect . left ) ) ; CBaseDialog :: resizeWidgets ( virtualWidth , 0 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; uint bigWidgetCount [ 2 ] = { 0 , 0 } ; uint i ; uint biggestBottom [ 2 ] = { 0 , 0 } ; uint nextSplit = Widgets . size ( ) / 2 ; for ( i = 0 ; i < Widgets . size ( ) ; i ++ ) { uint column = ( i > nextSplit ) ? 1 : 0 ; Widgets [ i ] -> resizeScan ( currentPos , bigWidgetCount [ column ] , 0 , false ) ; if ( currentPos . bottom > ( int ) biggestBottom [ column ] ) { biggestBottom [ column ] = currentPos . bottom ; } if ( nextSplit == i ) { getNextColumn ( currentPos ) ; currentPos . top = 0 ; } } uint adjust [ 2 ] ; CBaseDialog :: resizeWidgets ( virtualWidth , biggestBottom [ 0 ] ) ; adjust [ 0 ] = AdjusteHeight ; CBaseDialog :: resizeWidgets ( virtualWidth , biggestBottom [ 1 ] ) ; adjust [ 1 ] = AdjusteHeight ; currentPos ; getFirstItemPos ( currentPos ) ; uint adjustSum [ 2 ] = { bigWidgetCount [ 0 ] ? adjust [ 0 ] / bigWidgetCount [ 0 ] : 0 , bigWidgetCount [ 1 ] ? adjust [ 1 ] / bigWidgetCount [ 1 ] : 0 } ; biggestBottom [ 0 ] = 0 ; biggestBottom [ 1 ] = 0 ; for ( i = 0 ; i < Widgets . size ( ) - 1 ; i ++ ) { uint column = ( i > nextSplit ) ? 1 : 0 ; if ( Widgets [ i ] -> extendableHeight ( ) ) { Widgets [ i ] -> resizeScan ( currentPos , bigWidgetCount [ column ] , adjustSum [ column ] , true ) ; adjust [ column ] -= adjustSum [ column ] ; } else Widgets [ i ] -> resizeScan ( currentPos , bigWidgetCount [ column ] , 0 , true ) ; if ( currentPos . bottom > ( int ) biggestBottom [ column ] ) { biggestBottom [ column ] = currentPos . bottom ; } if ( nextSplit == i ) { getNextColumn ( currentPos ) ; currentPos . top = 0 ; } } uint column = ( i > nextSplit ) ? 1 : 0 ; Widgets [ i ] -> resizeScan ( currentPos , bigWidgetCount [ column ] , adjust [ column ] , true ) ; if ( currentPos . bottom > ( int ) biggestBottom [ column ] ) { biggestBottom [ column ] = currentPos . bottom ; } View -> setViewSize ( virtualWidth , std :: max ( biggestBottom [ 0 ] , biggestBottom [ 1 ] ) + CGeorgesEditView :: WidgetTopMargin + CGeorgesEditView :: WidgetBottomMargin ) ; } } void CFormDialog :: getFromDocument ( ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { uint widgetFocus ; for ( widgetFocus = 0 ; widgetFocus < Widgets . size ( ) ; widgetFocus ++ ) { if ( Widgets [ widgetFocus ] -> haveFocus ( ) ) break ; } CGeorgesEditDocSub * subObject = doc -> getSelectedObject ( ) ; const CFormDfn * parentDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; uint lastElement ; bool array ; bool parentVDfnArray ; UFormDfn :: TEntryType type ; nlverify ( ( ( const CFormElm * ) ( doc -> getRootNode ( subObject -> getSlot ( ) ) ) ) -> getNodeByName ( subObject -> getFormName ( ) . c_str ( ) , & parentDfn , lastElement , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; if ( parentDfn ) { if ( array ) { nlassert ( ( type == UFormDfn :: EntryDfn ) || ( type == UFormDfn :: EntryType ) ) ; getArrayFromDocument ( subObject -> getFormName ( ) . c_str ( ) , lastElement , subObject -> getSlot ( ) ) ; } else { switch ( parentDfn -> getEntry ( lastElement ) . getType ( ) ) { case UFormDfn :: EntryType : nlassert ( ! array ) ; nlassert ( nodeType ) ; nlassert ( parentDfn ) ; nlassert ( type == UFormDfn :: EntryType ) ; getTypeFromDocument ( * nodeType , ( parentDfn -> getEntry ( lastElement ) . getName ( ) + " : " ) . c_str ( ) , parentDfn -> getEntry ( lastElement ) . getFilename ( ) . c_str ( ) , subObject -> getFormName ( ) . c_str ( ) , subObject -> getSlot ( ) ) ; break ; case UFormDfn :: EntryDfn : nlassert ( ! array ) ; nlassert ( ( nodeDfn ) && ( type == UFormDfn :: EntryDfn ) ) ; getDfnFromDocument ( * nodeDfn , subObject -> getFormName ( ) . c_str ( ) , subObject -> getSlot ( ) ) ; break ; case UFormDfn :: EntryVirtualDfn : nlassert ( ! array ) ; getVirtualDfnFromDocument ( nodeDfn , subObject -> getFormName ( ) . c_str ( ) , subObject -> getSlot ( ) ) ; break ; } } } else { nlassert ( ! array ) ; nlassert ( ( nodeDfn ) && ( type == UFormDfn :: EntryDfn ) ) ; getDfnFromDocument ( * nodeDfn , subObject -> getFormName ( ) . c_str ( ) , subObject -> getSlot ( ) ) ; } for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateLabel ( ) ; } if ( widgetFocus < Widgets . size ( ) ) { Widgets [ widgetFocus ] -> setFocus ( ) ; } resizeWidgets ( ) ; } } void CFormDialog :: getDfnName ( string & result ) const { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { CString str = doc -> GetPathName ( ) ; char extension [ 512 ] ; _splitpath ( str , NULL , NULL , NULL , extension ) ; result = ( * extension == ' . ' ) ? extension + 1 : extension ; } else result = " " ; } void CFormDialog :: OnLButtonDown ( UINT nFlags , CPoint point ) { View -> TabCtrl . SetFocus ( ) ; CDialog :: OnLButtonDown ( nFlags , point ) ; } void CFormDialog :: onGetSubFocus ( uint id ) { int widget = getWidget ( id ) ; WidgetFocused = widget ; RECT widgetRect ; if ( Widgets [ widget ] -> getWindowRect ( widgetRect ) ) { View -> ScreenToClient ( & widgetRect ) ; RECT viewRect ; View -> GetClientRect ( & viewRect ) ; int bottom = viewRect . bottom - viewRect . top ; if ( widgetRect . bottom > bottom ) { CPoint pt = View -> GetScrollPosition ( ) ; View -> ScrollToPosition ( CPoint ( pt . x , pt . y + widgetRect . bottom - bottom + 10 ) ) ; } if ( widgetRect . top < 0 ) { CPoint pt = View -> GetScrollPosition ( ) ; View -> ScrollToPosition ( CPoint ( pt . x , pt . y + widgetRect . top - 10 ) ) ; } } } void CFormDialog :: OnSetFocus ( CWnd * pNewWnd ) { CDialog :: OnSetFocus ( pNewWnd ) ; if ( WidgetFocused != 0xffffffff ) Widgets [ WidgetFocused ] -> setFocus ( ) ; } void CFormDialog :: OnKillFocus ( CWnd * pNewWnd ) { CDialog :: OnKillFocus ( pNewWnd ) ; } IFormWidget :: IFormWidget ( CFormDialog * dialog , uint structId , const char * atomName , TTypeSrc typeSrc , uint slot ) { FormName = atomName ; Dialog = dialog ; StructId = structId ; SrcType = typeSrc ; Slot = slot ; } bool IFormWidget :: isDialog ( uint id ) const { return ( id >= FirstId ) && ( id <= LastId ) ; } ; uint IFormWidget :: getSlot ( ) const { return Slot ; } ; uint IFormWidget :: getStructId ( ) const { return StructId ; } void IFormWidget :: updateLabel ( ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; if ( doc ) { if ( IsWindow ( Label ) ) { if ( SrcType != TypeFormParent ) { if ( ( SrcType == TypeForm ) || ( SrcType == TypeType ) ) { std :: string result ; UFormElm :: TWhereIsValue where ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; nlverify ( elm -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , & where ) ) ; std :: string resultEvaluated ; # ifdef TEST_EVAL_FORMULA bool error = ! elm -> getValueByName ( resultEvaluated , FormName . c_str ( ) , UFormElm :: Formula , & where ) ; # else bool error = ! elm -> getValueByName ( resultEvaluated , FormName . c_str ( ) , UFormElm :: Eval , & where ) ; # endif string comp ; if ( error ) comp = " ▁ ( Value ▁ = ▁ Error ) " ; else { if ( resultEvaluated != result ) comp = " ▁ ( Value ▁ = ▁ \ " " + resultEvaluated + " \ " ) " ; } switch ( where ) { case UFormElm :: ValueForm : Label . SetWindowText ( ( SavedLabel + comp ) . c_str ( ) ) ; break ; case UFormElm :: ValueParentForm : Label . SetWindowText ( ( SavedLabel + " ▁ ( in ▁ parent ▁ form ) " + comp ) . c_str ( ) ) ; break ; case UFormElm :: ValueDefaultDfn : Label . SetWindowText ( ( SavedLabel + " ▁ ( default ▁ DFN ▁ value ) " + comp ) . c_str ( ) ) ; break ; case UFormElm :: ValueDefaultType : Label . SetWindowText ( ( SavedLabel + " ▁ ( default ▁ TYPE ▁ value ) " + comp ) . c_str ( ) ) ; break ; } } else { const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( FormName . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; if ( node ) { if ( node -> getForm ( ) == doc -> getFormPtr ( ) ) { Label . SetWindowText ( SavedLabel . c_str ( ) ) ; } else { Label . SetWindowText ( ( SavedLabel + " ▁ ( in ▁ parent ▁ form ) " ) . c_str ( ) ) ; } } else { Label . SetWindowText ( ( SavedLabel + " ▁ ( undefined ) " ) . c_str ( ) ) ; } } Label . UpdateData ( FALSE ) ; } } } } IFormWidget :: TTypeSrc IFormWidget :: getSrcType ( ) const { return SrcType ; } bool IFormWidget :: extendableHeight ( ) const { return false ; } bool IFormWidget :: getNode ( const CFormDfn * * parentDfn , uint & lastElement , const CFormDfn * * nodeDfn , const CType * * nodeType , CFormElm * * node , UFormDfn :: TEntryType & type , bool & array ) const { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; if ( doc ) { bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; return ( elm -> getNodeByName ( FormName . c_str ( ) , parentDfn , lastElement , nodeDfn , nodeType , node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; } return false ; } CFormElm * IFormWidget :: getFormElmNode ( ) const { const CFormDfn * parentDfn ; uint parentDfnIndex ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; if ( getNode ( & parentDfn , parentDfnIndex , & nodeDfn , & nodeType , & node , type , array ) ) { return node ; } return NULL ; } CFormElmStruct * IFormWidget :: getFormElmStructNode ( ) const { CFormElm * elm = getFormElmNode ( ) ; return elm ? safe_cast < CFormElmStruct * > ( elm ) : NULL ; } CFormElmVirtualStruct * IFormWidget :: getFormElmVirtualStructNode ( ) const { CFormElm * elm = getFormElmNode ( ) ; return elm ? safe_cast < CFormElmVirtualStruct * > ( elm ) : NULL ; } CFormElmArray * IFormWidget :: getFormElmArrayNode ( ) const { CFormElm * elm = getFormElmNode ( ) ; return elm ? safe_cast < CFormElmArray * > ( elm ) : NULL ; } CFormElmAtom * IFormWidget :: getFormElmAtomNode ( ) const { CFormElm * elm = getFormElmNode ( ) ; return elm ? safe_cast < CFormElmAtom * > ( elm ) : NULL ; } const string & IFormWidget :: getFormName ( ) const { return FormName ; } uint IFormWidget :: getNumValue ( ) { nlstop ; return 0 ; } void IFormWidget :: getValue ( std :: string & result ) { nlstop ; } void IFormWidget :: getValue ( std :: string & result , uint value ) { nlstop ; } bool IFormWidget :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Label ) ) { Label . GetWindowRect ( & rect ) ; return true ; } else return false ; } void IFormWidget :: onOpenSelected ( ) { string str ; getValue ( str ) ; std :: string str2 = CPath :: lookup ( str . c_str ( ) , false , false ) ; if ( str2 . empty ( ) ) str2 = str . c_str ( ) ; theApp . OpenDocumentFile ( str2 . c_str ( ) ) ; } CFormMemCombo :: CFormMemCombo ( CFormDialog * dialog , uint structId , const char * atomName , TTypeSrc typeSrc , uint slot ) : IFormWidget ( dialog , structId , atomName , typeSrc , slot ) { UseSpinner = false ; FileBrowser = false ; } CFormMemCombo :: ~ CFormMemCombo ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( Combo ) ) Combo . DestroyWindow ( ) ; if ( IsWindow ( Spin ) ) Spin . DestroyWindow ( ) ; if ( IsWindow ( Browse ) ) Browse . DestroyWindow ( ) ; } void CFormMemCombo :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label , const char * reg , bool useSpinner , bool fileBrowser , const char * filenameExt ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType = NULL ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( FormName . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; FirstId = dialog_index ; LastId = FirstId + 1 ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; UseSpinner = useSpinner ; FileBrowser = fileBrowser ; if ( useSpinner ) { parent -> setComboSpinSize ( currentPos ) ; Combo . create ( WS_CHILD | WS_TABSTOP , currentPos , parent , dialog_index , reg , theApp . RememberListSize ) ; parent -> initWidget ( Combo ) ; RECT spinPos = currentPos ; parent -> getNextSpinPos ( spinPos ) ; parent -> setSpinSize ( spinPos ) ; Spin . Create ( WS_CHILD | WS_VISIBLE , spinPos , parent , dialog_index + 1 ) ; parent -> getNextPos ( currentPos ) ; } else if ( fileBrowser ) { parent -> setComboBrowseSize ( currentPos ) ; Combo . create ( WS_CHILD | WS_TABSTOP , currentPos , parent , dialog_index , reg , theApp . RememberListSize ) ; parent -> initWidget ( Combo ) ; RECT spinPos = currentPos ; parent -> getNextBrowsePos ( spinPos ) ; parent -> setBrowseSize ( spinPos ) ; Browse . Create ( " . . . " , WS_CHILD | WS_VISIBLE | WS_TABSTOP , spinPos , parent , dialog_index + 1 ) ; parent -> initWidget ( Browse ) ; parent -> getNextPos ( currentPos ) ; if ( filenameExt ) { if ( strcmp ( filenameExt , " * . * " ) != 0 ) Combo . enableAutoCompleteExtension ( true , filenameExt ) ; } } else { parent -> setComboSize ( currentPos , parent -> SmallWidget ) ; Combo . create ( WS_CHILD | WS_TABSTOP , currentPos , parent , dialog_index , reg , theApp . RememberListSize ) ; parent -> initWidget ( Combo ) ; parent -> getNextPos ( currentPos ) ; } if ( nodeType ) { for ( uint predef = 0 ; predef < nodeType -> Definitions . size ( ) ; predef ++ ) { Combo . addStaticStrings ( nodeType -> Definitions [ predef ] . Label . c_str ( ) ) ; } } dialog_index += 2 ; } void CFormMemCombo :: updateData ( bool update ) { Combo . UpdateData ( update ? TRUE : FALSE ) ; } bool CFormMemCombo :: haveFocus ( ) { return ( Combo . haveFocus ( ) ) ; } void CFormMemCombo :: setFocus ( ) { Combo . SetFocus ( ) ; } void CFormMemCombo :: onOk ( ) { Combo . onOK ( ) ; } void CFormMemCombo :: getValue ( std :: string & result ) { Combo . UpdateData ( ) ; CString str ; Combo . GetWindowText ( str ) ; Combo . UpdateData ( FALSE ) ; result = ( const char * ) str ; } void CFormMemCombo :: getFromDocument ( CForm & form ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; if ( ( SrcType == TypeForm ) || ( SrcType == TypeType ) ) { string result ; if ( doc -> getRootNode ( getSlot ( ) ) -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , NULL ) ) { Combo . UpdateData ( ) ; Combo . SetWindowText ( result . c_str ( ) ) ; Combo . UpdateData ( FALSE ) ; updateLabel ( ) ; } else { nlstop ; } } else if ( SrcType == TypeArray ) { const CFormDfn * parentDfn ; uint lastElement ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; nlverify ( ( ( const CFormElm * ) doc -> getRootNode ( getSlot ( ) ) ) -> getNodeByName ( FormName . c_str ( ) , & parentDfn , lastElement , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; nlassert ( array ) ; Combo . UpdateData ( ) ; if ( node ) { CFormElmArray * arrayNode = safe_cast < CFormElmArray * > ( node ) ; char label [ 512 ] ; smprintf ( label , 512 , " % d " , arrayNode -> Elements . size ( ) ) ; Combo . SetWindowText ( label ) ; if ( arrayNode -> getForm ( ) == & form ) Label . SetWindowText ( " Array ▁ size : " ) ; else Label . SetWindowText ( " Array ▁ size : ▁ ( in ▁ parent ▁ form ) " ) ; } else { Combo . SetWindowText ( "0" ) ; } Combo . UpdateData ( FALSE ) ; } else if ( SrcType == TypeVirtualDfn ) { const CFormDfn * parentDfn ; uint lastElement ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; nlverify ( ( ( const CFormElm * ) doc -> getRootNode ( getSlot ( ) ) ) -> getNodeByName ( FormName . c_str ( ) , & parentDfn , lastElement , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; nlassert ( ! array ) ; Combo . UpdateData ( ) ; if ( node ) { CFormElmVirtualStruct * virtualNode = safe_cast < CFormElmVirtualStruct * > ( node ) ; Combo . SetWindowText ( virtualNode -> DfnFilename . c_str ( ) ) ; } else { Combo . SetWindowText ( " " ) ; } Combo . UpdateData ( FALSE ) ; } } bool CFormMemCombo :: isWnd ( const CWnd * wnd ) const { return Combo . isWnd ( wnd ) ; } void CFormMemCombo :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; if ( UseSpinner ) { Dialog -> setComboSpinSize ( currentPos ) ; if ( resize ) { Combo . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } RECT spinPos = currentPos ; Dialog -> getNextSpinPos ( spinPos ) ; Dialog -> setSpinSize ( spinPos ) ; if ( resize ) { Spin . SetWindowPos ( NULL , spinPos . left , spinPos . top , spinPos . right - spinPos . left , spinPos . bottom - spinPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } } else if ( FileBrowser ) { Dialog -> setComboBrowseSize ( currentPos ) ; if ( resize ) { Combo . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } RECT spinPos = currentPos ; Dialog -> getNextBrowsePos ( spinPos ) ; Dialog -> setBrowseSize ( spinPos ) ; if ( resize ) { Browse . SetWindowPos ( NULL , spinPos . left , spinPos . top , spinPos . right - spinPos . left , spinPos . bottom - spinPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } } else { Dialog -> setComboSize ( currentPos , Dialog -> SmallWidget ) ; if ( resize ) { Combo . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } } Dialog -> getNextPos ( currentPos ) ; } bool CFormMemCombo :: getWindowRect ( RECT & rect ) const { if ( Combo ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; Combo . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } CFormCombo :: CFormCombo ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { } CFormCombo :: ~ CFormCombo ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( Combo ) ) Combo . DestroyWindow ( ) ; } void CFormCombo :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; FirstId = dialog_index ; LastId = FirstId ; const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( FormName . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setComboSize ( currentPos , parent -> SmallWidget ) ; RECT comboPos = currentPos ; parent -> adjusteComboSize ( comboPos ) ; Combo . Create ( WS_CHILD | WS_VSCROLL | WS_VISIBLE | CBS_DROPDOWNLIST | CBS_HASSTRINGS | WS_CHILD | WS_TABSTOP , comboPos , parent , dialog_index ) ; parent -> initWidget ( Combo ) ; parent -> getNextPos ( currentPos ) ; if ( nodeType ) { Combo . InsertString ( 0 , " " ) ; for ( uint predef = 0 ; predef < nodeType -> Definitions . size ( ) ; predef ++ ) { Combo . InsertString ( predef + 1 , nodeType -> Definitions [ predef ] . Label . c_str ( ) ) ; } } dialog_index += 1 ; } void CFormCombo :: updateData ( bool update ) { Combo . UpdateData ( update ? TRUE : FALSE ) ; } bool CFormCombo :: haveFocus ( ) { CWnd * focus = CWnd :: GetFocus ( ) ; if ( focus ) { return ( focus == & Combo ) ; } return false ; } void CFormCombo :: setFocus ( ) { Combo . SetFocus ( ) ; } void CFormCombo :: onOk ( ) { } void CFormCombo :: getValue ( std :: string & result ) { Combo . UpdateData ( ) ; CString str ; Combo . GetWindowText ( str ) ; Combo . UpdateData ( FALSE ) ; result = ( const char * ) str ; } void CFormCombo :: getFromDocument ( CForm & form ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; string result ; if ( doc -> getRootNode ( getSlot ( ) ) -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , NULL ) ) { Combo . UpdateData ( ) ; uint itemCount = Combo . GetCount ( ) ; for ( uint i = 0 ; i < itemCount ; i ++ ) { CString item ; Combo . GetLBText ( i , item ) ; if ( item == result . c_str ( ) ) { Combo . SetCurSel ( i ) ; break ; } } Combo . UpdateData ( FALSE ) ; updateLabel ( ) ; } else { nlstop ; } } bool CFormCombo :: isWnd ( const CWnd * wnd ) const { return & Combo == ( const CWnd * ) wnd ; } void CFormCombo :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setComboSize ( currentPos , Dialog -> SmallWidget ) ; if ( resize ) { RECT comboPos = currentPos ; Dialog -> adjusteComboSize ( comboPos ) ; Combo . SetWindowPos ( NULL , comboPos . left , comboPos . top , comboPos . right - comboPos . left , comboPos . bottom - comboPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CFormCombo :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Combo ) ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; Combo . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } CFormBigEdit :: CFormBigEdit ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { } CFormBigEdit :: ~ CFormBigEdit ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( Edit ) ) Edit . DestroyWindow ( ) ; } void CFormBigEdit :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label ) { FirstId = dialog_index ; LastId = FirstId ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setBigEditSize ( currentPos , parent -> SmallWidget ) ; Edit . CreateEx ( WS_EX_CLIENTEDGE , _T ( " EDIT " ) , " " , WS_VSCROLL | ES_OEMCONVERT | ES_MULTILINE | ES_WANTRETURN | WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_AUTOHSCROLL | ES_AUTOVSCROLL , currentPos , parent , dialog_index ) ; parent -> initWidget ( Edit ) ; parent -> getNextPos ( currentPos ) ; dialog_index += 1 ; } void CFormBigEdit :: updateData ( bool update ) { Edit . UpdateData ( update ? TRUE : FALSE ) ; } bool CFormBigEdit :: haveFocus ( ) { CWnd * focus = CWnd :: GetFocus ( ) ; if ( focus ) { return ( focus == & Edit ) ; } return false ; } void CFormBigEdit :: setFocus ( ) { Edit . SetFocus ( ) ; } void CFormBigEdit :: onOk ( ) { } void CFormBigEdit :: getValue ( std :: string & result ) { Edit . UpdateData ( ) ; CString str ; Edit . GetWindowText ( str ) ; Edit . UpdateData ( FALSE ) ; result = ( const char * ) str ; } void CFormBigEdit :: getFromDocument ( CForm & form ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; string result ; if ( doc -> getRootNode ( getSlot ( ) ) -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , NULL ) ) { Edit . UpdateData ( ) ; Dialog -> setEditTextMultiLine ( Edit , result . c_str ( ) ) ; Edit . UpdateData ( FALSE ) ; updateLabel ( ) ; } else { nlstop ; } } bool CFormBigEdit :: isWnd ( const CWnd * wnd ) const { return & Edit == wnd ; } void CFormBigEdit :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { if ( ! resize ) widgetCount ++ ; Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setBigEditSize ( currentPos , Dialog -> SmallWidgetNotLimited , Dialog -> BigEditHeight + adjust ) ; if ( resize ) { Edit . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CFormBigEdit :: extendableHeight ( ) const { return true ; } bool CFormBigEdit :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Edit ) ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; Edit . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } CColorEdit :: CColorEdit ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { Empty = true ; } CColorEdit :: ~ CColorEdit ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( Color ) ) Color . DestroyWindow ( ) ; if ( IsWindow ( Edit ) ) Edit . DestroyWindow ( ) ; } void CColorEdit :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label ) { FirstId = dialog_index ; LastId = FirstId + 2 ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setColorSize ( currentPos , parent -> SmallWidget ) ; Color . create ( WS_CHILD | WS_VISIBLE | WS_TABSTOP , currentPos , parent , dialog_index ) ; parent -> initWidget ( Color ) ; RECT resetPos = currentPos ; parent -> getNextColorPos ( resetPos ) ; parent -> setResetColorSize ( resetPos ) ; Reset . Create ( " Reset " , WS_CHILD | WS_VISIBLE | WS_TABSTOP , resetPos , parent , dialog_index + 1 ) ; parent -> initWidget ( Reset ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setBigEditSize ( currentPos , parent -> SmallWidget ) ; Edit . CreateEx ( WS_EX_CLIENTEDGE , _T ( " EDIT " ) , " " , ES_OEMCONVERT | ES_WANTRETURN | WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_AUTOHSCROLL , currentPos , parent , dialog_index + 2 ) ; parent -> initWidget ( Edit ) ; parent -> getNextPos ( currentPos ) ; Color . setEdit ( & Edit ) ; dialog_index += 3 ; } void CColorEdit :: updateData ( bool update ) { Color . UpdateData ( update ? TRUE : FALSE ) ; Edit . UpdateData ( update ? TRUE : FALSE ) ; } bool CColorEdit :: haveFocus ( ) { CWnd * focus = CWnd :: GetFocus ( ) ; if ( focus ) { return ( focus == & Color ) ; } return false ; } void CColorEdit :: setFocus ( ) { Color . SetFocus ( ) ; } void CColorEdit :: onOk ( ) { } void CColorEdit :: getValue ( std :: string & result ) { if ( ! Empty ) { Color . UpdateData ( ) ; CRGBA color = Color . getColor ( ) ; char colorName [ 512 ] ; smprintf ( colorName , 512 , " % d , % d , % d " , color . R , color . G , color . B ) ; result = colorName ; } else { result = " " ; } } void CColorEdit :: getFromDocument ( CForm & form ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; string result ; if ( doc -> getRootNode ( getSlot ( ) ) -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , NULL ) ) { Color . UpdateData ( ) ; sint r , g , b ; if ( sscanf ( result . c_str ( ) , " % d , % d , % d " , & r , & g , & b ) == 3 ) { clamp ( r , 0 , 255 ) ; clamp ( g , 0 , 255 ) ; clamp ( b , 0 , 255 ) ; CRGBA color ( r , g , b ) ; Color . setColor ( color ) ; if ( r != 255 && g != 255 && b != 255 ) Color . updateEdit ( ) ; } else { Color . setColor ( CRGBA :: Black ) ; Color . updateEdit ( ) ; } Color . UpdateData ( FALSE ) ; updateLabel ( ) ; } else { nlstop ; } } bool CColorEdit :: isWnd ( const CWnd * wnd ) const { return & Color == wnd ; } void CColorEdit :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setColorSize ( currentPos , Dialog -> SmallWidget ) ; if ( resize ) { Color . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } RECT resetPos = currentPos ; Dialog -> getNextColorPos ( resetPos ) ; Dialog -> setResetColorSize ( resetPos ) ; if ( resize ) { Reset . SetWindowPos ( NULL , resetPos . left , resetPos . top , resetPos . right - resetPos . left , resetPos . bottom - resetPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setEditSize ( currentPos , Dialog -> SmallWidget , Dialog -> EditHeight ) ; if ( resize ) { Edit . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CColorEdit :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Color ) ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; Color . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } CListWidget :: CListWidget ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { ListCtrl . Ctrl = this ; } CListWidget :: ~ CListWidget ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( ListCtrl ) ) ListCtrl . DestroyWindow ( ) ; if ( IsWindow ( Button ) ) Button . DestroyWindow ( ) ; } void CListWidget :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label , const char * reg , uint divid ) { FirstId = dialog_index ; LastId = FirstId + 1 ; Divid = divid ; RegAdr = reg ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setListSize ( currentPos , parent -> SmallWidget ) ; ListCtrl . create ( WS_CHILD | WS_VISIBLE | WS_TABSTOP , currentPos , parent , dialog_index ) ; parent -> initWidget ( ListCtrl ) ; parent -> getNextPos ( currentPos ) ; parent -> setButtonSize ( currentPos , parent -> SmallWidget ) ; Button . Create ( " Assign ▁ parents " , WS_CHILD | WS_VISIBLE | WS_TABSTOP , currentPos , parent , dialog_index + 1 ) ; parent -> initWidget ( Button ) ; parent -> getNextPos ( currentPos ) ; dialog_index += 2 ; } void CListWidget :: addColumn ( const char * name ) { ListCtrl . insertColumn ( 0 , name ) ; ListCtrl . recalcColumn ( ) ; } void CListWidget :: onOk ( ) { ListCtrl . onOK ( ) ; } void CListWidget :: updateData ( bool update ) { ListCtrl . UpdateData ( update ) ; } bool CListWidget :: haveFocus ( ) { CWnd * wnd = Dialog -> GetFocus ( ) ; if ( wnd ) { return ( wnd -> GetParent ( ) == & ListCtrl ) ; } return false ; } void CListWidget :: setFocus ( ) { ListCtrl . SetFocus ( ) ; } void CListWidget :: getFromDocument ( NLGEORGES :: CForm & form ) { ListCtrl . ListCtrl . DeleteAllItems ( ) ; for ( uint parent = 0 ; parent < form . getParentCount ( ) ; parent ++ ) { string filename = form . getParentFilename ( parent ) ; ListCtrl . ListCtrl . InsertItem ( parent , filename . c_str ( ) ) ; ListCtrl . ListCtrl . UpdateData ( FALSE ) ; updateLabel ( ) ; } } uint CListWidget :: getNumValue ( ) { return ListCtrl . ListCtrl . GetItemCount ( ) ; } void CListWidget :: getValue ( std :: string & result , uint value ) { CString str = ListCtrl . ListCtrl . GetItemText ( value , 0 ) ; result = str ; } bool CListWidget :: isWnd ( const CWnd * wnd ) const { return ( ( ( & ListCtrl ) == wnd ) || ( ( & ListCtrl . ListCtrl ) == wnd ) ) ; } void CListWidget :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { if ( ! resize ) widgetCount ++ ; Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setListSize ( currentPos , Dialog -> SmallWidgetNotLimited / Divid , Dialog -> ListHeight + adjust ) ; if ( resize ) { ListCtrl . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; ListCtrl . recalcColumn ( ) ; } Dialog -> getNextPos ( currentPos ) ; Dialog -> setButtonSize ( currentPos , Dialog -> SmallWidget ) ; if ( resize ) { Button . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CListWidget :: extendableHeight ( ) const { return true ; } CEditListCtrl :: TItemEdit CListWidget :: CMyEditListCtrl :: getItemEditMode ( uint item , uint subItem ) { return CEditListCtrl :: EditMemCombo ; } void CListWidget :: CMyEditListCtrl :: getMemComboBoxProp ( uint item , uint subItem , std :: string & regAdr , bool & browse ) { regAdr = Ctrl -> RegAdr ; browse = true ; } void CListWidget :: CMyEditListCtrl :: getNewItemText ( uint item , uint subItem , std :: string & ret ) { Ctrl -> Dialog -> getDfnName ( ret ) ; ret = " default . " + ret ; } void CListWidget :: CMyEditListCtrl :: getBrowseInfo ( uint item , uint subItem , std :: string & defExt , std :: string & defFilename , std :: string & defDir , std :: string & filter ) { string ret ; Ctrl -> Dialog -> getDfnName ( ret ) ; defExt = " * . " + ret ; defFilename = defExt ; filter = " Form ▁ Files ▁ ( * . " + ret + " ) | * . " + ret + " | All ▁ Files ▁ ( * . * ) | * . * | | " ; defDir = theApp . RootSearchPath ; } bool CListWidget :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( ListCtrl ) ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; ListCtrl . ListCtrl . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } void CListWidget :: onOpenSelected ( ) { POSITION pos = ListCtrl . ListCtrl . GetFirstSelectedItemPosition ( ) ; while ( pos ) { int nItem = ListCtrl . ListCtrl . GetNextSelectedItem ( pos ) ; CString str = ListCtrl . ListCtrl . GetItemText ( nItem , 0 ) ; if ( str != " " ) { string name = CPath :: lookup ( ( const char * ) str , false , false ) ; if ( name . empty ( ) ) name = str ; theApp . OpenDocumentFile ( name . c_str ( ) ) ; } } } CIconWidget :: CIconWidget ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { } CIconWidget :: ~ CIconWidget ( ) { if ( IsWindow ( Icon ) ) Icon . DestroyWindow ( ) ; } void CIconWidget :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label ) { FirstId = dialog_index ; LastId = FirstId ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setEditSize ( currentPos , parent -> IconHeight , parent -> IconHeight ) ; Icon . create ( WS_CHILD | WS_VISIBLE | WS_TABSTOP , currentPos , parent , dialog_index ) ; parent -> initWidget ( Icon ) ; parent -> getNextPos ( currentPos ) ; dialog_index += 1 ; } void CIconWidget :: updateData ( bool update ) { Icon . UpdateData ( update ? TRUE : FALSE ) ; } bool CIconWidget :: haveFocus ( ) { CWnd * focus = CWnd :: GetFocus ( ) ; if ( focus ) { return ( focus == & Icon ) ; } return false ; } void CIconWidget :: setFocus ( ) { Icon . SetFocus ( ) ; } void CIconWidget :: onOk ( ) { } void CIconWidget :: getValue ( std :: string & result ) { result = " " ; } void CIconWidget :: getFromDocument ( CForm & form ) { } bool CIconWidget :: isWnd ( const CWnd * wnd ) const { return & Icon == wnd ; } void CIconWidget :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setEditSize ( currentPos , Dialog -> IconHeight , Dialog -> IconHeight ) ; if ( resize ) { Icon . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CIconWidget :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Icon ) ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; Icon . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } </DOCUMENT>
<DOCUMENT_ID="hkarim/JUCE-Graph-Component/tree/master/JuceLibraryCode/modules/juce_gui_basics/filebrowser/juce_ImagePreviewComponent.cpp"> ImagePreviewComponent :: ImagePreviewComponent ( ) { } ImagePreviewComponent :: ~ ImagePreviewComponent ( ) { } void ImagePreviewComponent :: getThumbSize ( int & w , int & h ) const { const int availableW = proportionOfWidth ( 0.97f ) ; const int availableH = getHeight ( ) - 13 * 4 ; const double scale = jmin ( 1.0 , availableW / ( double ) w , availableH / ( double ) h ) ; w = roundToInt ( scale * w ) ; h = roundToInt ( scale * h ) ; } void ImagePreviewComponent :: selectedFileChanged ( const File & file ) { if ( fileToLoad != file ) { fileToLoad = file ; startTimer ( 100 ) ; } } void ImagePreviewComponent :: timerCallback ( ) { stopTimer ( ) ; currentThumbnail = Image ( ) ; currentDetails . clear ( ) ; repaint ( ) ; ScopedPointer < FileInputStream > in ( fileToLoad . createInputStream ( ) ) ; if ( in != nullptr ) { if ( ImageFileFormat * const format = ImageFileFormat :: findImageFormatForStream ( * in ) ) { currentThumbnail = format -> decodeImage ( * in ) ; if ( currentThumbnail . isValid ( ) ) { int w = currentThumbnail . getWidth ( ) ; int h = currentThumbnail . getHeight ( ) ; currentDetails << fileToLoad . getFileName ( ) << " \n " << format -> getFormatName ( ) << " \n " << w << " ▁ x ▁ " << h << " ▁ pixels \n " << File :: descriptionOfSizeInBytes ( fileToLoad . getSize ( ) ) ; getThumbSize ( w , h ) ; currentThumbnail = currentThumbnail . rescaled ( w , h ) ; } } } } void ImagePreviewComponent :: paint ( Graphics & g ) { if ( currentThumbnail . isValid ( ) ) { g . setFont ( 13.0f ) ; int w = currentThumbnail . getWidth ( ) ; int h = currentThumbnail . getHeight ( ) ; getThumbSize ( w , h ) ; const int numLines = 4 ; const int totalH = 13 * numLines + h + 4 ; const int y = ( getHeight ( ) - totalH ) / 2 ; g . drawImageWithin ( currentThumbnail , ( getWidth ( ) - w ) / 2 , y , w , h , RectanglePlacement :: centred | RectanglePlacement :: onlyReduceInSize , false ) ; g . drawFittedText ( currentDetails , 0 , y + h + 4 , getWidth ( ) , 100 , Justification :: centredTop , numLines ) ; } } </DOCUMENT>
<DOCUMENT_ID="ChameleonOS/android_external_skia/tree/master/tests/PathOpsAngleTest.cpp"> # include " PathOpsTestCommon . h " # include " SkOpSegment . h " # include " SkTArray . h " # include " Test . h " static const SkPoint cubics [ ] [ 4 ] = { { { 0 , 1 } , { 2 , 6 } , { 4 , 2 } , { 5 , 3 } } , { { 10 , 234 } , { 10 , 229.581726f } , { 13.5817204f , 226 } , { 18 , 226 } } , { { 132 , 11419 } , { 130.89543151855469f , 11419 } , { 130 , 11418.1044921875f } , { 130 , 11417 } } , { { 130.04275512695312f , 11417.4130859375f } , { 130.23307800292969f , 11418.3193359375f } , { 131.03709411621094f , 11419 } , { 132 , 11419 } } , { { 0 , 1 } , { 0 , 5 } , { 4 , 1 } , { 6 , 4 } } , { { 1 , 5 } , { 4 , 6 } , { 1 , 0 } , { 4 , 0 } } , { { 0 , 1 } , { 0 , 4 } , { 5 , 1 } , { 6 , 4 } } , { { 0 , 1 } , { 1 , 2 } , { 1 , 0 } , { 6 , 1 } } , { { 0 , 3 } , { 0 , 1 } , { 2 , 0 } , { 1 , 0 } } , { { 189 , 7 } , { 189 , 5.3431458473205566f } , { 190.3431396484375f , 4 } , { 192 , 4 } } , { { 0 , 1 } , { 1 , 3 } , { 1 , 0 } , { 6 , 4 } } , { { 0 , 1 } , { 2 , 3 } , { 2 , 1 } , { 4 , 3 } } , { { 1 , 2 } , { 3 , 4 } , { 1 , 0 } , { 3 , 2 } } , { { 0 , 1 } , { 4 , 6 } , { 4 , 3 } , { 5 , 4 } } , { { 806 , 11419 } , { 806.962890625f , 11419 } , { 807.76690673828125f , 11418.3193359375f } , { 807.957275390625f , 11417.4130859375f } } , { { 808 , 11417 } , { 808 , 11418.1044921875f } , { 807.10455322265625f , 11419 } , { 806 , 11419 } } , { { 132 , 11419 } , { 130.89543151855469f , 11419 } , { 130 , 11418.1044921875f } , { 130 , 11417 } } , { { 130.04275512695312f , 11417.4130859375f } , { 130.23312377929687f , 11418.3193359375f } , { 131.03707885742187f , 11419 } , { 132 , 11419 } } , { { 1006.6951293945312f , 291 } , { 1023.263671875f , 291 } , { 1033.8402099609375f , 304.43145751953125f } , { 1030.318359375f , 321 } } , } ; static const SkPoint quads [ ] [ 3 ] = { { { 12.3423996f , 228.342407f } , { 10 , 230.686295f } , { 10 , 234 } } , { { 304.24319458007812f , 591.75677490234375f } , { 306 , 593.51470947265625f } , { 306 , 596 } } , { { 0 , 0 } , { 3 , 1 } , { 0 , 3 } } , { { 0 , 1 } , { 3 , 1 } , { 0 , 2 } } , } ; static const SkPoint lines [ ] [ 2 ] = { { { 6 , 2 } , { 2 , 4 } } , { { 306 , 617 } , { 306 , 590 } } , { { 306 , 596 } , { 306 , 617 } } , { { 6 , 4 } , { 0 , 1 } } , { { 6 , 1 } , { 0 , 1 } } , { { 1 , 0 } , { 0 , 3 } } , { { 246 , 4 } , { 189 , 4 } } , { { 192 , 4 } , { 243 , 4 } } , { { 4 , 3 } , { 0 , 1 } } , { { 3 , 2 } , { 1 , 2 } } , { { 6 , 4 } , { 3 , 4 } } , { { 979.30487060546875f , 561 } , { 1036.695068359375f , 291 } } , } ; struct SortSet { const SkPoint * ptData ; int ptCount ; double tStart ; double tEnd ; SkPoint endPt ; } ; static const SortSet set1 [ ] = { { cubics [ 0 ] , 4 , 0.66666987081928919 , 0.875 , { 0 , 0 } } , { lines [ 0 ] , 2 , 0.574070336 , 0.388888889 , { 0 , 0 } } , { cubics [ 0 ] , 4 , 0.66666987081928919 , 0.4050371120499307 , { 0 , 0 } } , { lines [ 0 ] , 2 , 0.574070336 , 0.9140625 , { 0 , 0 } } , } ; static const SortSet set1a [ ] = { { cubics [ 0 ] , 4 , 0.666666667 , 0.405037112 , { 4.58007812f , 2.83203125f } } , { lines [ 0 ] , 2 , 0.574074074 , 0.9140625 , { 4.44444466f , 2.77777767f } } , } ; static const SortSet set2 [ ] = { { cubics [ 0 ] , 4 , 0.666666667 , 0.875 , { 0 , 0 } } , { lines [ 0 ] , 2 , 0.574074074 , 0.388888889 , { 0 , 0 } } , { cubics [ 0 ] , 4 , 0.666666667 , 0.405037112 , { 0 , 0 } } , { lines [ 0 ] , 2 , 0.574074074 , 0.9140625 , { 0 , 0 } } , } ; static const SortSet set3 [ ] = { { cubics [ 1 ] , 4 , 0 , 1 , { 0 , 0 } } , { quads [ 0 ] , 3 , 1 , 0 , { 0 , 0 } } , } ; static const SortSet set4 [ ] = { { cubics [ 2 ] , 4 , 0.812114222 , 1 , { 0 , 0 } } , { cubics [ 3 ] , 4 , 0.0684734759 , 0 , { 0 , 0 } } , } ; static const SortSet set5 [ ] = { { lines [ 1 ] , 2 , 0.777777778 , 1 , { 0 , 0 } } , { quads [ 1 ] , 3 , 1 , 4.34137342e - 06 , { 0 , 0 } } , { lines [ 2 ] , 2 , 0 , 1 , { 0 , 0 } } , } ; static const SortSet set5a [ ] = { { lines [ 1 ] , 2 , 0.777777778 , 1 , { 306 , 590 } } , { quads [ 1 ] , 3 , 1 , 4.34137342e - 06 , { 304.243195f , 591.756775f } } , { lines [ 2 ] , 2 , 0 , 1 , { 306 , 617 } } , } ; static const SortSet set6 [ ] = { { lines [ 3 ] , 2 , 0.407407407 , 0.554627832 , { 0 , 0 } } , { cubics [ 4 ] , 4 , 0.666666667 , 0.548022446 , { 0 , 0 } } , { lines [ 3 ] , 2 , 0.407407407 , 0 , { 0 , 0 } } , { cubics [ 4 ] , 4 , 0.666666667 , 1 , { 0 , 0 } } , } ; static const SortSet set6a [ ] = { { lines [ 3 ] , 2 , 0.407407407 , 0.554627832 , { 2.6722331f , 2.33611655f } } , { cubics [ 4 ] , 4 , 0.666666667 , 0.548022446 , { 2.61642241f , 2.83718514f } } , { lines [ 3 ] , 2 , 0.407407407 , 0 , { 6 , 4 } } , { cubics [ 4 ] , 4 , 0.666666667 , 1 , { 6 , 4 } } , } ; static const SortSet set7 [ ] = { { cubics [ 5 ] , 4 , 0.545233342 , 0.545454545 , { 0 , 0 } } , { cubics [ 6 ] , 4 , 0.484938134 , 0.484805744 , { 0 , 0 } } , { cubics [ 5 ] , 4 , 0.545233342 , 0 , { 0 , 0 } } , { cubics [ 6 ] , 4 , 0.484938134 , 0.545454545 , { 0 , 0 } } , } ; static const SortSet set8 [ ] = { { cubics [ 7 ] , 4 , 0.5 , 0.522986744 , { 0 , 0 } } , { lines [ 4 ] , 2 , 0.75 , 1 , { 0 , 0 } } , { cubics [ 7 ] , 4 , 0.5 , 0 , { 0 , 0 } } , { lines [ 4 ] , 2 , 0.75 , 0.737654321 , { 0 , 0 } } , } ; static const SortSet set8a [ ] = { { cubics [ 7 ] , 4 , 0.5 , 0.522986744 , { 1.60668361f , 0.965592742f } } , { lines [ 4 ] , 2 , 0.75 , 1 , { 0 , 1 } } , { cubics [ 7 ] , 4 , 0.5 , 0 , { 0 , 1 } } , { lines [ 4 ] , 2 , 0.75 , 0.737654321 , { 1.57407403f , 1 } } , } ; static const SortSet set9 [ ] = { { cubics [ 8 ] , 4 , 0.4 , 1 , { 0 , 0 } } , { lines [ 5 ] , 2 , 0.36 , 0 , { 0 , 0 } } , { cubics [ 8 ] , 4 , 0.4 , 0.394675838 , { 0 , 0 } } , { lines [ 5 ] , 2 , 0.36 , 0.363999782 , { 0 , 0 } } , } ; static const SortSet set10 [ ] = { { lines [ 6 ] , 2 , 0.947368421 , 1 , { 0 , 0 } } , { cubics [ 9 ] , 4 , 1 , 0.500000357 , { 0 , 0 } } , { lines [ 7 ] , 2 , 0 , 1 , { 0 , 0 } } , } ; static const SortSet set11 [ ] = { { lines [ 3 ] , 2 , 0.75 , 1 , { 0 , 0 } } , { cubics [ 10 ] , 4 , 0.5 , 0.228744269 , { 0 , 0 } } , { lines [ 3 ] , 2 , 0.75 , 0.627112191 , { 0 , 0 } } , { cubics [ 10 ] , 4 , 0.5 , 0.6339746 , { 0 , 0 } } , } ; static const SortSet set12 [ ] = { { cubics [ 12 ] , 4 , 0.5 , 1 , { 0 , 0 } } , { lines [ 8 ] , 2 , 0.5 , 1 , { 0 , 0 } } , { cubics [ 11 ] , 4 , 0.5 , 0 , { 0 , 0 } } , { lines [ 9 ] , 2 , 0.5 , 1 , { 0 , 0 } } , { cubics [ 12 ] , 4 , 0.5 , 0 , { 0 , 0 } } , { lines [ 8 ] , 2 , 0.5 , 0 , { 0 , 0 } } , { cubics [ 11 ] , 4 , 0.5 , 1 , { 0 , 0 } } , { lines [ 9 ] , 2 , 0.5 , 0 , { 0 , 0 } } , } ; static const SortSet set13 [ ] = { { cubics [ 13 ] , 4 , 0.5 , 0.400631046 , { 0 , 0 } } , { lines [ 10 ] , 2 , 0.791666667 , 0.928 , { 0 , 0 } } , { lines [ 10 ] , 2 , 0.791666667 , 0.333333333 , { 0 , 0 } } , { cubics [ 13 ] , 4 , 0.5 , 0.866666667 , { 0 , 0 } } , } ; static const SortSet set14 [ ] = { { quads [ 2 ] , 3 , 0.5 , 0.310102051 , { 0 , 0 } } , { quads [ 3 ] , 3 , 0.5 , 0.2 , { 0 , 0 } } , { quads [ 3 ] , 3 , 0.5 , 0.770156212 , { 0 , 0 } } , { quads [ 2 ] , 3 , 0.5 , 0.7 , { 0 , 0 } } , } ; static const SortSet set15 [ ] = { { cubics [ 14 ] , 4 , 0.93081374 , 1 , { 0 , 0 } } , { cubics [ 15 ] , 4 , 0.188518131 , 0 , { 0 , 0 } } , { cubics [ 14 ] , 4 , 0.93081374 , 0 , { 0 , 0 } } , } ; static const SortSet set16 [ ] = { { cubics [ 17 ] , 4 , 0.0682619216 , 0 , { 130.042755f , 11417.4131f } } , { cubics [ 16 ] , 4 , 0.812302088 , 1 , { 130 , 11417 } } , { cubics [ 17 ] , 4 , 0.0682619216 , 1 , { 132 , 11419 } } , } ; static const SortSet set17 [ ] = { { lines [ 11 ] , 2 , 0.888889581 , 1 , { 0 , 0 } } , { cubics [ 18 ] , 4 , 0.999996241 , 0 , { 0 , 0 } } , { lines [ 11 ] , 2 , 0.888889581 , 0 , { 0 , 0 } } , { cubics [ 18 ] , 4 , 0.999996241 , 1 , { 0 , 0 } } , } ; struct SortSetTests { const char * name ; const SortSet * set ; size_t count ; SkPoint startPt ; } ; # define TEST_ENTRY ( name ) # name , name , SK_ARRAY_COUNT ( name ) static const SortSetTests tests [ ] = { { TEST_ENTRY ( set17 ) , { 0 , 0 } } , { TEST_ENTRY ( set16 ) , { 130.090179f , 11417.5957f } } , { TEST_ENTRY ( set14 ) , { 0 , 0 } } , { TEST_ENTRY ( set13 ) , { 0 , 0 } } , { TEST_ENTRY ( set12 ) , { 0 , 0 } } , { TEST_ENTRY ( set11 ) , { 0 , 0 } } , { TEST_ENTRY ( set10 ) , { 0 , 0 } } , { TEST_ENTRY ( set9 ) , { 0 , 0 } } , { TEST_ENTRY ( set6a ) , { 3.55555558f , 2.77777767f } } , { TEST_ENTRY ( set8a ) , { 1.5f , 1 } } , { TEST_ENTRY ( set8 ) , { 0 , 0 } } , { TEST_ENTRY ( set7 ) , { 0 , 0 } } , { TEST_ENTRY ( set6a ) , { 3.55555558f , 2.77777767f } } , { TEST_ENTRY ( set6 ) , { 0 , 0 } } , { TEST_ENTRY ( set5a ) , { 306 , 596 } } , { TEST_ENTRY ( set5 ) , { 0 , 0 } } , { TEST_ENTRY ( set3 ) , { 0 , 0 } } , { TEST_ENTRY ( set2 ) , { 0 , 0 } } , { TEST_ENTRY ( set1 ) , { 0 , 0 } } , } ; # undef TEST_ENTRY static void setup ( const SortSet * set , const size_t idx , SkOpSegment * seg , int * ts , const SkPoint & startPt ) { SkPoint start , end ; const SkPoint * data = set [ idx ] . ptData ; bool useIntersectPt = startPt . fX != 0 || startPt . fY != 0 ; if ( useIntersectPt ) { start = startPt ; end = set [ idx ] . endPt ; } switch ( set [ idx ] . ptCount ) { case 2 : { SkASSERT ( ValidPoints ( data , 2 ) ) ; seg -> addLine ( data , false , false ) ; SkDLine dLine ; dLine . set ( set [ idx ] . ptData ) ; SkASSERT ( ValidLine ( dLine ) ) ; if ( useIntersectPt ) { break ; } start = dLine . ptAtT ( set [ idx ] . tStart ) . asSkPoint ( ) ; end = dLine . ptAtT ( set [ idx ] . tEnd ) . asSkPoint ( ) ; } break ; case 3 : { SkASSERT ( ValidPoints ( data , 3 ) ) ; seg -> addQuad ( data , false , false ) ; SkDQuad dQuad ; dQuad . set ( set [ idx ] . ptData ) ; SkASSERT ( ValidQuad ( dQuad ) ) ; if ( useIntersectPt ) { break ; } start = dQuad . ptAtT ( set [ idx ] . tStart ) . asSkPoint ( ) ; end = dQuad . ptAtT ( set [ idx ] . tEnd ) . asSkPoint ( ) ; } break ; case 4 : { SkASSERT ( ValidPoints ( data , 4 ) ) ; seg -> addCubic ( data , false , false ) ; SkDCubic dCubic ; dCubic . set ( set [ idx ] . ptData ) ; SkASSERT ( ValidCubic ( dCubic ) ) ; if ( useIntersectPt ) { break ; } start = dCubic . ptAtT ( set [ idx ] . tStart ) . asSkPoint ( ) ; end = dCubic . ptAtT ( set [ idx ] . tEnd ) . asSkPoint ( ) ; } break ; } double tStart = set [ idx ] . tStart ; double tEnd = set [ idx ] . tEnd ; seg -> addT ( NULL , start , tStart ) ; seg -> addT ( NULL , end , tEnd ) ; if ( tStart != 0 && tEnd != 0 ) { seg -> addT ( NULL , set [ idx ] . ptData [ 0 ] , 0 ) ; } if ( tStart != 1 && tEnd != 1 ) { seg -> addT ( NULL , set [ idx ] . ptData [ set [ idx ] . ptCount - 1 ] , 1 ) ; } int tIndex = 0 ; ts [ 0 ] = 0 ; ts [ 1 ] = 1 ; do { if ( seg -> t ( tIndex ) == set [ idx ] . tStart ) { ts [ 0 ] = tIndex ; } if ( seg -> t ( tIndex ) == set [ idx ] . tEnd ) { ts [ 1 ] = tIndex ; } if ( seg -> t ( tIndex ) >= 1 ) { break ; } } while ( ++ tIndex ) ; } static void testOne ( skiatest :: Reporter * reporter , const SortSetTests & test ) { SkTDArray < SkOpAngle > angles ; bool unsortable = false ; bool unorderable = false ; SkTArray < SkOpSegment > segs ; for ( size_t idx = 0 ; idx < test . count ; ++ idx ) { int ts [ 2 ] ; const SortSet * set = test . set ; SkOpSegment & seg = segs . push_back ( ) ; setup ( set , idx , & seg , ts , test . startPt ) ; SkOpAngle * angle = angles . append ( ) ; angle -> set ( & seg , ts [ 0 ] , ts [ 1 ] ) ; # if DEBUG_ANGLE angle -> setID ( idx ) ; # endif if ( angle -> unsortable ( ) ) { # if DEBUG_ANGLE SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ angle [ % d ] ▁ unsortable \n " , __FUNCTION__ , test . name , idx ) ; # endif unsortable = true ; } if ( angle -> unorderable ( ) ) { # if DEBUG_ANGLE SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ angle [ % d ] ▁ unorderable \n " , __FUNCTION__ , test . name , idx ) ; # endif unorderable = true ; } reporter -> bumpTestCount ( ) ; } if ( unsortable || unorderable ) { return ; } # if DEBUG_ANGLE SkDebugf ( " % s ▁ test [ % s ] \n " , __FUNCTION__ , test . name ) ; # endif for ( size_t idxL = 0 ; idxL < test . count ; ++ idxL ) { const SkOpAngle & first = angles [ idxL ] ; for ( size_t idxG = 0 ; idxG < test . count ; ++ idxG ) { if ( idxL == idxG ) { continue ; } const SkOpAngle & second = angles [ idxG ] ; bool compare = first < second ; if ( idxL < idxG ) { if ( ! compare ) { SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ first [ % d ] ▁ > ▁ second [ % d ] \n " , __FUNCTION__ , test . name , idxL , idxG ) ; compare = first < second ; } REPORTER_ASSERT ( reporter , compare ) ; } else { SkASSERT ( idxL > idxG ) ; if ( compare ) { SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ first [ % d ] ▁ < ▁ second [ % d ] \n " , __FUNCTION__ , test . name , idxL , idxG ) ; compare = first < second ; } REPORTER_ASSERT ( reporter , ! compare ) ; } compare = second < first ; if ( idxL < idxG ) { if ( compare ) { SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ second [ % d ] ▁ < ▁ first [ % d ] \n " , __FUNCTION__ , test . name , idxL , idxG ) ; compare = second < first ; } REPORTER_ASSERT ( reporter , ! compare ) ; } else { SkASSERT ( idxL > idxG ) ; if ( ! compare ) { SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ second [ % d ] ▁ > ▁ first [ % d ] \n " , __FUNCTION__ , test . name , idxL , idxG ) ; compare = second < first ; } REPORTER_ASSERT ( reporter , compare ) ; } } } } static void PathOpsAngleTest ( skiatest :: Reporter * reporter ) { for ( size_t index = 0 ; index < SK_ARRAY_COUNT ( tests ) ; ++ index ) { const SortSetTests & test = tests [ index ] ; testOne ( reporter , test ) ; reporter -> bumpTestCount ( ) ; } } static void PathOpsAngleTestOne ( skiatest :: Reporter * reporter ) { size_t index = 0 ; const SortSetTests & test = tests [ index ] ; testOne ( reporter , test ) ; } # if 0 static int find_slop ( double x , double y , double rx , double ry ) { int slopBits = 0 ; bool less1 , less2 ; double absX = fabs ( x ) ; double absY = fabs ( y ) ; double length = absX < absY ? absX / 2 + absY : absX + absY / 2 ; int exponent ; ( void ) frexp ( length , & exponent ) ; double epsilon = ldexp ( FLT_EPSILON , exponent ) ; do { double xSlop = epsilon * slopBits ; double ySlop = x * y < 0 ? - xSlop : xSlop ; double x1 = x - xSlop ; double y1 = y + ySlop ; double x_ry1 = x1 * ry ; double rx_y1 = rx * y1 ; less1 = x_ry1 < rx_y1 ; double x2 = x + xSlop ; double y2 = y - ySlop ; double x_ry2 = x2 * ry ; double rx_y2 = rx * y2 ; less2 = x_ry2 < rx_y2 ; } while ( less1 == less2 && ++ slopBits ) ; return slopBits ; } static double diamond_angle ( double y , double x ) { if ( y >= 0 ) return ( x >= 0 ? y / ( x + y ) : 1 - x / ( - x + y ) ) ; else return ( x < 0 ? 2 - y / ( - x - y ) : 3 + x / ( x - y ) ) ; } static const double slopTests [ ] [ 4 ] = { { - 0.058554756452593892 , - 0.18804585843827226 , - 0.018568569646021160 , - 0.059615294434479438 } , { - 0.0013717412948608398 , 0.0041152238845825195 , - 0.00045837944195925573 , 0.0013753175735478074 } , { - 2.1033774145221198 , - 1.4046019261273715e - 008 , - 0.70062688352066704 , - 1.2706324683777995e - 008 } , } ; static void PathOpsAngleFindSlop ( skiatest :: Reporter * reporter ) { for ( size_t index = 0 ; index < SK_ARRAY_COUNT ( slopTests ) ; ++ index ) { const double * slopTest = slopTests [ index ] ; double x = slopTest [ 0 ] ; double y = slopTest [ 1 ] ; double rx = slopTest [ 2 ] ; double ry = slopTest [ 3 ] ; SkDebugf ( " % s ▁ ▁ xy ▁ % d = % d \n " , __FUNCTION__ , ( int ) index , find_slop ( x , y , rx , ry ) ) ; SkDebugf ( " % s ▁ rxy ▁ % d = % d \n " , __FUNCTION__ , ( int ) index , find_slop ( rx , ry , x , y ) ) ; double angle = diamond_angle ( y , x ) ; double rAngle = diamond_angle ( ry , rx ) ; double diff = fabs ( angle - rAngle ) ; SkDebugf ( " % s ▁ diamond ▁ xy = % 1.9g ▁ rxy = % 1.9g ▁ diff = % 1.9g ▁ factor = % d \n " , __FUNCTION__ , angle , rAngle , diff , ( int ) ( diff / FLT_EPSILON ) ) ; } } # endif # include " TestClassDef . h " DEFINE_TESTCLASS_SHORT ( PathOpsAngleTest ) DEFINE_TESTCLASS_SHORT ( PathOpsAngleTestOne ) </DOCUMENT>
<DOCUMENT_ID="bredelings/BAli-Phy/tree/master/external/range-v3/0.4.0/test/algorithm/minmax.cpp"> # include < range / v3 / algorithm / minmax . hpp > # include < memory > # include < numeric > # include < random > # include < algorithm > # include " . . / simple _ test . hpp " # include " . . / test _ utils . hpp " # include " . . / test _ iterators . hpp " RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS namespace { std :: mt19937 gen ; template < class Iter , class Sent = Iter > void test_iter ( Iter first , Sent last ) { RANGES_ENSURE ( first != last ) ; auto rng = ranges :: make_iterator_range ( first , last ) ; auto res = ranges :: minmax ( rng ) ; for ( Iter i = first ; i != last ; ++ i ) { CHECK ( ! ( * i < res . first ) ) ; CHECK ( ! ( res . second < * i ) ) ; } } template < class Iter , class Sent = Iter > void test_iter ( unsigned N ) { RANGES_ENSURE ( N > 0 ) ; std :: unique_ptr < int [ ] > a { new int [ N ] } ; std :: iota ( a . get ( ) , a . get ( ) + N , 0 ) ; std :: shuffle ( a . get ( ) , a . get ( ) + N , gen ) ; test_iter ( Iter ( a . get ( ) ) , Sent ( a . get ( ) + N ) ) ; } template < class Iter , class Sent = Iter > void test_iter ( ) { test_iter < Iter , Sent > ( 1 ) ; test_iter < Iter , Sent > ( 2 ) ; test_iter < Iter , Sent > ( 3 ) ; test_iter < Iter , Sent > ( 10 ) ; test_iter < Iter , Sent > ( 1000 ) ; } template < class Iter , class Sent = Iter > void test_iter_comp ( Iter first , Sent last ) { RANGES_ENSURE ( first != last ) ; typedef std :: greater < int > Compare ; Compare comp ; auto rng = ranges :: make_iterator_range ( first , last ) ; auto res = ranges :: minmax ( rng , comp ) ; for ( Iter i = first ; i != last ; ++ i ) { CHECK ( ! comp ( * i , res . first ) ) ; CHECK ( ! comp ( res . second , * i ) ) ; } } template < class Iter , class Sent = Iter > void test_iter_comp ( unsigned N ) { RANGES_ENSURE ( N > 0 ) ; std :: unique_ptr < int [ ] > a { new int [ N ] } ; std :: iota ( a . get ( ) , a . get ( ) + N , 0 ) ; std :: shuffle ( a . get ( ) , a . get ( ) + N , gen ) ; test_iter_comp ( Iter ( a . get ( ) ) , Sent ( a . get ( ) + N ) ) ; } template < class Iter , class Sent = Iter > void test_iter_comp ( ) { test_iter_comp < Iter , Sent > ( 1 ) ; test_iter_comp < Iter , Sent > ( 2 ) ; test_iter_comp < Iter , Sent > ( 3 ) ; test_iter_comp < Iter , Sent > ( 10 ) ; test_iter_comp < Iter , Sent > ( 1000 ) ; } struct S { int value ; int index ; } ; } int main ( ) { test_iter < input_iterator < const int * > > ( ) ; test_iter < forward_iterator < const int * > > ( ) ; test_iter < bidirectional_iterator < const int * > > ( ) ; test_iter < random_access_iterator < const int * > > ( ) ; test_iter < const int * > ( ) ; test_iter < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < input_iterator < const int * > > ( ) ; test_iter < forward_iterator < const int * > > ( ) ; test_iter < bidirectional_iterator < const int * > > ( ) ; test_iter < random_access_iterator < const int * > > ( ) ; test_iter < const int * > ( ) ; test_iter < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < input_iterator < const int * > > ( ) ; test_iter_comp < forward_iterator < const int * > > ( ) ; test_iter_comp < bidirectional_iterator < const int * > > ( ) ; test_iter_comp < random_access_iterator < const int * > > ( ) ; test_iter_comp < const int * > ( ) ; test_iter_comp < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < input_iterator < const int * > > ( ) ; test_iter_comp < forward_iterator < const int * > > ( ) ; test_iter_comp < bidirectional_iterator < const int * > > ( ) ; test_iter_comp < random_access_iterator < const int * > > ( ) ; test_iter_comp < const int * > ( ) ; test_iter_comp < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; S s [ ] = { S { 1 , 0 } , S { 2 , 1 } , S { 3 , 2 } , S { 4 , 3 } , S { - 4 , 4 } , S { 40 , 5 } , S { - 4 , 6 } , S { 40 , 7 } , S { 7 , 8 } , S { 8 , 9 } , S { 9 , 10 } } ; auto res = ranges :: minmax ( s , std :: less < int > { } , & S :: value ) ; CHECK ( res . first . value == - 4 ) ; CHECK ( res . first . index == 4 ) ; CHECK ( res . second . value == 40 ) ; CHECK ( res . second . index == 7 ) ; return test_result ( ) ; } </DOCUMENT>
<DOCUMENT_ID="Sija/swift/tree/master/Tests/Source/TestValueBool.cpp"> # include " stdafx . h " # include < cppunit / extensions / HelperMacros . h > # include " . . / . . / Source / stdafx . h " # include " . . / . . / Source / values / Bool . h " using namespace Swift ; class TestValueBool : public CPPUNIT_NS :: TestFixture { public : CPPUNIT_TEST_SUITE ( TestValueBool ) ; CPPUNIT_TEST ( testInit ) ; CPPUNIT_TEST ( testAssign ) ; CPPUNIT_TEST ( testGet ) ; CPPUNIT_TEST ( testSetClear ) ; CPPUNIT_TEST ( testOperators ) ; CPPUNIT_TEST_SUITE_END ( ) ; public : void setUp ( ) { } void tearDown ( ) { } protected : void testInit ( ) { CPPUNIT_ASSERT ( iValue :: hasTypeString ( Values :: Bool :: id ) ) ; } void testAssign ( ) { oValue b ( true ) ; CPPUNIT_ASSERT ( b -> getID ( ) == Values :: Bool :: id ) ; } void testGet ( ) { CPPUNIT_ASSERT ( oValue ( true ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ! ( ( Values :: Bool * ) oValue ( false ) . get ( ) ) -> output ( ) ) ; } void testSetClear ( ) { oValue v ( true ) ; v -> clear ( ) ; CPPUNIT_ASSERT ( ! ( v >> bool ( ) ) ) ; Values :: Bool * b = ( Values :: Bool * ) v . get ( ) ; b -> set ( true ) ; CPPUNIT_ASSERT ( v >> bool ( ) ) ; } void testOperators ( ) { CPPUNIT_ASSERT ( ( oValue ( true ) == oValue ( true ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( true ) != oValue ( false ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( true ) && oValue ( true ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( false ) || oValue ( true ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( ! oValue ( true ) == oValue ( false ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( ) << true ) -> getID ( ) == Values :: Bool :: id ) ; CPPUNIT_ASSERT ( ( oValue ( false ) >> bool ( ) ) == false ) ; } } ; CPPUNIT_TEST_SUITE_REGISTRATION ( TestValueBool ) ; </DOCUMENT>
<DOCUMENT_ID="victorzhao/miniblink49/tree/master/third_party/WebKit/Source/core/html/HTMLContentElement.cpp"> # include " config . h " # include " core / html / HTMLContentElement . h " # include " core / HTMLNames . h " # include " core / css / SelectorChecker . h " # include " core / css / parser / CSSParser . h " # include " core / dom / QualifiedName . h " # include " core / dom / shadow / ElementShadow . h " # include " core / dom / shadow / ShadowRoot . h " # include " platform / RuntimeEnabledFeatures . h " namespace blink { using namespace HTMLNames ; PassRefPtrWillBeRawPtr < HTMLContentElement > HTMLContentElement :: create ( Document & document , PassOwnPtrWillBeRawPtr < HTMLContentSelectFilter > filter ) { return adoptRefWillBeNoop ( new HTMLContentElement ( document , filter ) ) ; } inline HTMLContentElement :: HTMLContentElement ( Document & document , PassOwnPtrWillBeRawPtr < HTMLContentSelectFilter > filter ) : InsertionPoint ( contentTag , document ) , m_shouldParseSelect ( false ) , m_isValidSelector ( true ) , m_filter ( filter ) { } HTMLContentElement :: ~ HTMLContentElement ( ) { } DEFINE_TRACE ( HTMLContentElement ) { visitor -> trace ( m_filter ) ; InsertionPoint :: trace ( visitor ) ; } void HTMLContentElement :: parseSelect ( ) { ASSERT ( m_shouldParseSelect ) ; CSSParser :: parseSelector ( CSSParserContext ( document ( ) , 0 ) , m_select , m_selectorList ) ; m_shouldParseSelect = false ; m_isValidSelector = validateSelect ( ) ; if ( ! m_isValidSelector ) { CSSSelectorList emptyList ; m_selectorList . adopt ( emptyList ) ; } } void HTMLContentElement :: parseAttribute ( const QualifiedName & name , const AtomicString & value ) { if ( name == selectAttr ) { if ( ShadowRoot * root = containingShadowRoot ( ) ) root -> owner ( ) -> willAffectSelector ( ) ; m_shouldParseSelect = true ; m_select = value ; } else { InsertionPoint :: parseAttribute ( name , value ) ; } } static inline bool includesDisallowedPseudoClass ( const CSSSelector & selector ) { if ( selector . pseudoType ( ) == CSSSelector :: PseudoNot ) { const CSSSelector * subSelector = selector . selectorList ( ) -> first ( ) ; return subSelector -> match ( ) == CSSSelector :: PseudoClass ; } return selector . match ( ) == CSSSelector :: PseudoClass ; } bool HTMLContentElement :: validateSelect ( ) const { ASSERT ( ! m_shouldParseSelect ) ; if ( m_select . isNull ( ) || m_select . isEmpty ( ) ) return true ; if ( ! m_selectorList . isValid ( ) ) return false ; for ( const CSSSelector * selector = m_selectorList . first ( ) ; selector ; selector = m_selectorList . next ( * selector ) ) { if ( ! selector -> isCompound ( ) ) return false ; for ( const CSSSelector * subSelector = selector ; subSelector ; subSelector = subSelector -> tagHistory ( ) ) { if ( includesDisallowedPseudoClass ( * subSelector ) ) return false ; } } return true ; } bool HTMLContentElement :: matchSelector ( Element & element ) const { SelectorChecker selectorChecker ( SelectorChecker :: QueryingRules ) ; SelectorChecker :: SelectorCheckingContext context ( & element , SelectorChecker :: VisitedMatchDisabled ) ; for ( const CSSSelector * selector = selectorList ( ) . first ( ) ; selector ; selector = CSSSelectorList :: next ( * selector ) ) { context . selector = selector ; if ( selectorChecker . match ( context ) ) return true ; } return false ; } } </DOCUMENT>
