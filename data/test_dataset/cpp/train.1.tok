<DOCUMENT_ID="leighleighleigh/smol-pong/tree/master/smol_pong/DNSServer.cpp"> # include " . / DNSServer . h " # include < lwip / def . h > # include < Arduino . h > # define DEBUG # define DEBUG_OUTPUT Serial DNSServer :: DNSServer ( ) { _ttl = htonl ( 60 ) ; _errorReplyCode = DNSReplyCode :: NonExistentDomain ; } bool DNSServer :: start ( const uint16_t & port , const String & domainName , const IPAddress & resolvedIP ) { _port = port ; _domainName = domainName ; _resolvedIP [ 0 ] = resolvedIP [ 0 ] ; _resolvedIP [ 1 ] = resolvedIP [ 1 ] ; _resolvedIP [ 2 ] = resolvedIP [ 2 ] ; _resolvedIP [ 3 ] = resolvedIP [ 3 ] ; downcaseAndRemoveWwwPrefix ( _domainName ) ; return _udp . begin ( _port ) == 1 ; } void DNSServer :: setErrorReplyCode ( const DNSReplyCode & replyCode ) { _errorReplyCode = replyCode ; } void DNSServer :: setTTL ( const uint32_t & ttl ) { _ttl = htonl ( ttl ) ; } void DNSServer :: stop ( ) { _udp . stop ( ) ; } void DNSServer :: downcaseAndRemoveWwwPrefix ( String & domainName ) { domainName . toLowerCase ( ) ; domainName . replace ( " www . " , " " ) ; } void DNSServer :: processNextRequest ( ) { _currentPacketSize = _udp . parsePacket ( ) ; if ( _currentPacketSize ) { _buffer = ( unsigned char * ) malloc ( _currentPacketSize * sizeof ( char ) ) ; _udp . read ( _buffer , _currentPacketSize ) ; _dnsHeader = ( DNSHeader * ) _buffer ; if ( _dnsHeader -> QR == DNS_QR_QUERY && _dnsHeader -> OPCode == DNS_OPCODE_QUERY && requestIncludesOnlyOneQuestion ( ) && ( _domainName == " * " || getDomainNameWithoutWwwPrefix ( ) == _domainName ) ) { replyWithIP ( ) ; } else if ( _dnsHeader -> QR == DNS_QR_QUERY ) { replyWithCustomCode ( ) ; } free ( _buffer ) ; } } bool DNSServer :: requestIncludesOnlyOneQuestion ( ) { return ntohs ( _dnsHeader -> QDCount ) == 1 && _dnsHeader -> ANCount == 0 && _dnsHeader -> NSCount == 0 && _dnsHeader -> ARCount == 0 ; } String DNSServer :: getDomainNameWithoutWwwPrefix ( ) { String parsedDomainName = " " ; unsigned char * start = _buffer + 12 ; if ( * start == 0 ) { return parsedDomainName ; } int pos = 0 ; while ( true ) { unsigned char labelLength = * ( start + pos ) ; for ( int i = 0 ; i < labelLength ; i ++ ) { pos ++ ; parsedDomainName += ( char ) * ( start + pos ) ; } pos ++ ; if ( * ( start + pos ) == 0 ) { downcaseAndRemoveWwwPrefix ( parsedDomainName ) ; return parsedDomainName ; } else { parsedDomainName += " . " ; } } } void DNSServer :: replyWithIP ( ) { _dnsHeader -> QR = DNS_QR_RESPONSE ; _dnsHeader -> ANCount = _dnsHeader -> QDCount ; _dnsHeader -> QDCount = _dnsHeader -> QDCount ; _udp . beginPacket ( _udp . remoteIP ( ) , _udp . remotePort ( ) ) ; _udp . write ( _buffer , _currentPacketSize ) ; _udp . write ( ( uint8_t ) 192 ) ; _udp . write ( ( uint8_t ) 12 ) ; _udp . write ( ( uint8_t ) 0 ) ; _udp . write ( ( uint8_t ) 1 ) ; _udp . write ( ( uint8_t ) 0 ) ; _udp . write ( ( uint8_t ) 1 ) ; _udp . write ( ( unsigned char * ) & _ttl , 4 ) ; _udp . write ( ( uint8_t ) 0 ) ; _udp . write ( ( uint8_t ) 4 ) ; _udp . write ( _resolvedIP , sizeof ( _resolvedIP ) ) ; _udp . endPacket ( ) ; # ifdef DEBUG DEBUG_OUTPUT . print ( " DNS ▁ responds : ▁ " ) ; DEBUG_OUTPUT . print ( _resolvedIP [ 0 ] ) ; DEBUG_OUTPUT . print ( " . " ) ; DEBUG_OUTPUT . print ( _resolvedIP [ 1 ] ) ; DEBUG_OUTPUT . print ( " . " ) ; DEBUG_OUTPUT . print ( _resolvedIP [ 2 ] ) ; DEBUG_OUTPUT . print ( " . " ) ; DEBUG_OUTPUT . print ( _resolvedIP [ 3 ] ) ; DEBUG_OUTPUT . print ( " ▁ for ▁ " ) ; DEBUG_OUTPUT . println ( getDomainNameWithoutWwwPrefix ( ) ) ; # endif } void DNSServer :: replyWithCustomCode ( ) { _dnsHeader -> QR = DNS_QR_RESPONSE ; _dnsHeader -> RCode = ( unsigned char ) _errorReplyCode ; _dnsHeader -> QDCount = 0 ; _udp . beginPacket ( _udp . remoteIP ( ) , _udp . remotePort ( ) ) ; _udp . write ( _buffer , sizeof ( DNSHeader ) ) ; _udp . endPacket ( ) ; } </DOCUMENT>
<DOCUMENT_ID="pete318/TrinityCore/tree/master/src/server/scripts/Northrend/FrozenHalls/HallsOfReflection/halls_of_reflection.cpp"> # include " halls _ of _ reflection . h " # include " Creature . h " # include " EventProcessor . h " # include " InstanceScript . h " # include " MotionMaster . h " # include " MoveSplineInit . h " # include " ObjectAccessor . h " # include " ObjectGuid . h " # include " Player . h " # include " ScriptedCreature . h " # include " ScriptedGossip . h " # include " ScriptMgr . h " # include " Spell . h " # include " SpellInfo . h " # include " SpellScript . h " # include " TemporarySummon . h " # include " Transport . h " # include " Unit . h " enum Text { SAY_JAINA_INTRO_1 = 0 , SAY_JAINA_INTRO_2 = 1 , SAY_JAINA_INTRO_3 = 2 , SAY_JAINA_INTRO_4 = 3 , SAY_JAINA_INTRO_5 = 4 , SAY_JAINA_INTRO_6 = 5 , SAY_JAINA_INTRO_7 = 6 , SAY_JAINA_INTRO_8 = 7 , SAY_JAINA_INTRO_9 = 8 , SAY_JAINA_INTRO_10 = 9 , SAY_JAINA_INTRO_11 = 10 , SAY_JAINA_INTRO_END = 11 , SAY_SYLVANAS_INTRO_1 = 0 , SAY_SYLVANAS_INTRO_2 = 1 , SAY_SYLVANAS_INTRO_3 = 2 , SAY_SYLVANAS_INTRO_4 = 3 , SAY_SYLVANAS_INTRO_5 = 4 , SAY_SYLVANAS_INTRO_6 = 5 , SAY_SYLVANAS_INTRO_7 = 6 , SAY_SYLVANAS_INTRO_8 = 7 , SAY_SYLVANAS_INTRO_END = 8 , SAY_UTHER_INTRO_A2_1 = 0 , SAY_UTHER_INTRO_A2_2 = 1 , SAY_UTHER_INTRO_A2_3 = 2 , SAY_UTHER_INTRO_A2_4 = 3 , SAY_UTHER_INTRO_A2_5 = 4 , SAY_UTHER_INTRO_A2_6 = 5 , SAY_UTHER_INTRO_A2_7 = 6 , SAY_UTHER_INTRO_A2_8 = 7 , SAY_UTHER_INTRO_A2_9 = 8 , SAY_UTHER_INTRO_H2_1 = 9 , SAY_UTHER_INTRO_H2_2 = 10 , SAY_UTHER_INTRO_H2_3 = 11 , SAY_UTHER_INTRO_H2_4 = 12 , SAY_UTHER_INTRO_H2_5 = 13 , SAY_UTHER_INTRO_H2_6 = 14 , SAY_UTHER_INTRO_H2_7 = 15 , SAY_LK_INTRO_1 = 0 , SAY_LK_INTRO_2 = 1 , SAY_LK_INTRO_3 = 2 , SAY_LK_JAINA_INTRO_END = 3 , SAY_LK_SYLVANAS_INTRO_END = 4 , SAY_JAINA_SYLVANAS_ESCAPE_1 = 0 , SAY_JAINA_SYLVANAS_ESCAPE_2 = 1 , SAY_JAINA_SYLVANAS_ESCAPE_3 = 2 , SAY_JAINA_SYLVANAS_ESCAPE_4 = 3 , SAY_JAINA_SYLVANAS_ESCAPE_5 = 4 , SAY_JAINA_SYLVANAS_ESCAPE_6 = 5 , SAY_JAINA_SYLVANAS_ESCAPE_7 = 6 , SAY_JAINA_SYLVANAS_ESCAPE_8 = 7 , SAY_JAINA_ESCAPE_9 = 8 , SAY_JAINA_ESCAPE_10 = 9 , SAY_SYLVANAS_ESCAPE_9 = 8 , SAY_LK_ESCAPE_1 = 0 , SAY_LK_ESCAPE_2 = 1 , SAY_LK_ESCAPE_ICEWALL_SUMMONED_1 = 2 , SAY_LK_ESCAPE_ICEWALL_SUMMONED_2 = 3 , SAY_LK_ESCAPE_ICEWALL_SUMMONED_3 = 4 , SAY_LK_ESCAPE_ICEWALL_SUMMONED_4 = 5 , SAY_LK_ESCAPE_GHOULS = 6 , SAY_LK_ESCAPE_ABOMINATION = 7 , SAY_LK_ESCAPE_WINTER = 8 , SAY_LK_ESCAPE_HARVEST_SOUL = 9 , SAY_FALRIC_INTRO_1 = 5 , SAY_FALRIC_INTRO_2 = 6 , SAY_MARWYN_INTRO_1 = 4 } ; enum Events { EVENT_WALK_INTRO1 = 1 , EVENT_WALK_INTRO2 , EVENT_START_INTRO , EVENT_SKIP_INTRO , EVENT_INTRO_A2_1 , EVENT_INTRO_A2_2 , EVENT_INTRO_A2_3 , EVENT_INTRO_A2_4 , EVENT_INTRO_A2_5 , EVENT_INTRO_A2_6 , EVENT_INTRO_A2_7 , EVENT_INTRO_A2_8 , EVENT_INTRO_A2_9 , EVENT_INTRO_A2_10 , EVENT_INTRO_A2_11 , EVENT_INTRO_A2_12 , EVENT_INTRO_A2_13 , EVENT_INTRO_A2_14 , EVENT_INTRO_A2_15 , EVENT_INTRO_A2_16 , EVENT_INTRO_A2_17 , EVENT_INTRO_A2_18 , EVENT_INTRO_A2_19 , EVENT_INTRO_H2_1 , EVENT_INTRO_H2_2 , EVENT_INTRO_H2_3 , EVENT_INTRO_H2_4 , EVENT_INTRO_H2_5 , EVENT_INTRO_H2_6 , EVENT_INTRO_H2_7 , EVENT_INTRO_H2_8 , EVENT_INTRO_H2_9 , EVENT_INTRO_H2_10 , EVENT_INTRO_H2_11 , EVENT_INTRO_H2_12 , EVENT_INTRO_H2_13 , EVENT_INTRO_H2_14 , EVENT_INTRO_H2_15 , EVENT_INTRO_LK_1 , EVENT_INTRO_LK_2 , EVENT_INTRO_LK_3 , EVENT_INTRO_LK_4 , EVENT_INTRO_LK_5 , EVENT_INTRO_LK_6 , EVENT_INTRO_LK_7 , EVENT_INTRO_LK_8 , EVENT_INTRO_LK_9 , EVENT_INTRO_LK_10 , EVENT_INTRO_LK_11 , EVENT_INTRO_END , EVENT_ESCAPE , EVENT_ESCAPE_1 , EVENT_ESCAPE_2 , EVENT_ESCAPE_3 , EVENT_ESCAPE_4 , EVENT_ESCAPE_5 , EVENT_ESCAPE_6 , EVENT_ESCAPE_7 , EVENT_ESCAPE_8 , EVENT_ESCAPE_9 , EVENT_ESCAPE_10 , EVENT_ESCAPE_11 , EVENT_ESCAPE_12 , EVENT_ESCAPE_13 , EVENT_ESCAPE_14 , EVENT_ESCAPE_15 , EVENT_ESCAPE_16 , EVENT_ESCAPE_17 , EVENT_REMORSELESS_WINTER , EVENT_ESCAPE_SUMMON_GHOULS , EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , EVENT_OPEN_IMPENETRABLE_DOOR , EVENT_CLOSE_IMPENETRABLE_DOOR , EVENT_KORELN_LORALEN_DEATH } ; enum Misc { ACTION_START_INTRO , ACTION_SKIP_INTRO , JAINA_SYLVANAS_MAX_HEALTH = 252000 , POINT_SHADOW_THRONE_DOOR = 1 , POINT_ATTACK_ICEWALL = 2 , POINT_TRAP = 3 , SOUND_LK_SLAY_1 = 17214 , SOUND_LK_SLAY_2 = 17215 , SOUND_LK_FURY_OF_FROSTMOURNE = 17224 } ; enum Spells { SPELL_TAKE_FROSTMOURNE = 72729 , SPELL_FROSTMOURNE_DESPAWN = 72726 , SPELL_FROSTMOURNE_VISUAL = 73220 , SPELL_FROSTMOURNE_SOUNDS = 70667 , SPELL_BOSS_SPAWN_AURA = 72712 , SPELL_UTHER_DESPAWN = 70693 , SPELL_CAST_VISUAL = 65633 , SPELL_SUMMON_SOULS = 72711 , SPELL_TAUNT_ARTHAS = 69857 , SPELL_JAINA_ICE_BARRIER = 69787 , SPELL_JAINA_ICE_PRISON = 69708 , SPELL_JAINA_DESTROY_ICE_WALL = 69784 , SPELL_SYLVANAS_CLOAK_OF_DARKNESS = 70188 , SPELL_SYLVANAS_DARK_BINDING = 70194 , SPELL_SYLVANAS_DESTROY_ICE_WALL = 70224 , SPELL_SYLVANAS_BLINDING_RETREAT = 70199 , SPELL_REMORSELESS_WINTER = 69780 , SPELL_SOUL_REAPER = 69409 , SPELL_FURY_OF_FROSTMOURNE = 70063 , SPELL_RAISE_DEAD = 69818 , SPELL_SUMMON_RISEN_WITCH_DOCTOR = 69836 , SPELL_SUMMON_LUMBERING_ABOMINATION = 69835 , SPELL_SUMMON_ICE_WALL = 69768 , SPELL_PAIN_AND_SUFFERING = 74115 , SPELL_STUN_BREAK_JAINA = 69764 , SPELL_STUN_BREAK_SYLVANAS = 70200 , SPELL_HARVEST_SOUL = 69866 , SPELL_FEIGN_DEATH = 29266 , SPELL_GHOUL_JUMP = 70150 , SPELL_RAGING_GHOUL_SPAWN = 69636 , SPELL_CURSE_OF_DOOM = 70144 , SPELL_SHADOW_BOLT_VOLLEY = 70145 , SPELL_SHADOW_BOLT = 70080 , SPELL_RISEN_WITCH_DOCTOR_SPAWN = 69639 , SPELL_CLEAVE = 40505 , SPELL_VOMIT_SPRAY = 70176 } ; enum HorGossipMenu { GOSSIP_MENU_JAINA_FINAL = 10930 , GOSSIP_MENU_SYLVANAS_FINAL = 10931 } ; Position const NpcJainaOrSylvanasEscapeRoute [ ] = { { 5601.217285f , 2207.652832f , 731.541931f , 5.223304f } , { 5607.224375f , 2173.913330f , 731.126038f , 2.608723f } , { 5583.427246f , 2138.784180f , 731.150391f , 4.260901f } , { 5560.281738f , 2104.025635f , 731.410889f , 4.058383f } , { 5510.990723f , 2000.772217f , 734.716064f , 3.973213f } , { 5452.641113f , 1905.762329f , 746.530579f , 4.118834f } , { 5338.126953f , 1768.429810f , 767.237244f , 3.855189f } , { 5259.06f , 1669.27f , 784.3008f , 0.0f } , { 5265.53f , 1681.6f , 784.2947f , 4.13643f } } ; Position const LichKingMoveAwayPos = { 5400.069824f , 2102.7131689f , 707.69525f , 0.843803f } ; Position const LichKingFirstSummon = { 5600.076172f , 2192.270996f , 731.750488f , 4.330935f } ; Position const JainaSylvanasShadowThroneDoor = { 5577.243f , 2235.852f , 733.0128f , 2.209562f } ; Position const LichKingFinalPos = { 5283.742188f , 1706.335693f , 783.293518f , 4.138510f } ; Position const KorelnOrLoralenPos [ ] = { { 5253.061f , 1953.616f , 707.6948f , 0.8377581f } , { 5283.226f , 1992.300f , 707.7445f , 0.8377581f } , { 5360.711f , 2064.797f , 707.6948f , 0.0f } } ; Position const SylvanasIntroPosition [ ] = { { 0.0f , 0.0f , 0.0f , 0.0f } , { 5263.2f , 1950.96f , 707.6948f , 0.8028514f } , { 5306.82f , 1998.17f , 709.341f , 1.239184f } , } ; Position const JainaIntroPosition [ ] = { { 0.0f , 0.0f , 0.0f , 0.0f } , { 5265.89f , 1952.98f , 707.6978f , 0.0f } , { 5306.95f , 1998.49f , 709.3414f , 1.277278f } } ; Position const UtherSpawnPos = { 5307.814f , 2003.168f , 709.4244f , 4.537856f } ; Position const LichKingIntroPosition [ ] = { { 5362.463f , 2062.693f , 707.7781f , 3.944444f } , { 5332.83f , 2031.24f , 707.6948f , 0.0f } , { 5312.93f , 2010.24f , 709.34f , 0.0f } , { 5319.028f , 2016.662f , 707.6948f , 0.0f } , { 5332.285f , 2030.832f , 707.6948f , 0.0f } , { 5355.488f , 2055.149f , 707.6907f , 0.0f } } ; Position const FalricPosition [ ] = { { 5276.583f , 2037.45f , 709.4025f , 5.532694f } , { 5283.95f , 2030.53f , 709.3191f , 0.0f } } ; Position const MarwynPosition [ ] = { { 5342.232f , 1975.696f , 709.4025f , 2.391101f } , { 5335.01f , 1982.37f , 709.3191f , 0.0f } } ; Position const SylvanasShadowThroneDoorPosition = { 5576.79f , 2235.73f , 733.0029f , 2.687807f } ; Position const IceWallTargetPosition [ ] = { { 5547.833f , 2083.701f , 731.4332f , 1.029744f } , { 5503.213f , 1969.547f , 737.0245f , 1.27409f } , { 5439.976f , 1879.005f , 752.7048f , 1.064651f } , { 5318.289f , 1749.184f , 771.9423f , 0.8726646f } } ; class npc_jaina_or_sylvanas_intro_hor : public CreatureScript { public : npc_jaina_or_sylvanas_intro_hor ( ) : CreatureScript ( " npc _ jaina _ or _ sylvanas _ intro _ hor " ) { } struct npc_jaina_or_sylvanas_intro_horAI : public ScriptedAI { npc_jaina_or_sylvanas_intro_horAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; } bool GossipHello ( Player * player ) override { if ( _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) == IN_PROGRESS || _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) == SPECIAL ) { ClearGossipMenuFor ( player ) ; return true ; } return false ; } bool GossipSelect ( Player * player , uint32 , uint32 gossipListId ) override { ClearGossipMenuFor ( player ) ; switch ( gossipListId ) { case 0 : player -> PlayerTalkClass -> SendCloseGossip ( ) ; _events . ScheduleEvent ( EVENT_START_INTRO , 1s ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; case 1 : player -> PlayerTalkClass -> SendCloseGossip ( ) ; _events . ScheduleEvent ( EVENT_SKIP_INTRO , 1s ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; default : break ; } return false ; } void Reset ( ) override { _events . Reset ( ) ; _utherGUID . Clear ( ) ; _lichkingGUID . Clear ( ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; me -> SetStandState ( UNIT_STAND_STATE_STAND ) ; _events . ScheduleEvent ( EVENT_WALK_INTRO1 , 3000 ) ; } void UpdateAI ( uint32 diff ) override { _events . Update ( diff ) ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_WALK_INTRO1 : if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> GetMotionMaster ( ) -> MovePoint ( 0 , KorelnOrLoralenPos [ 0 ] ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) { me -> GetMotionMaster ( ) -> MovePoint ( 0 , JainaIntroPosition [ 1 ] ) ; Talk ( SAY_JAINA_INTRO_1 ) ; _events . ScheduleEvent ( EVENT_WALK_INTRO2 , 7000 ) ; } else { me -> GetMotionMaster ( ) -> MovePoint ( 0 , SylvanasIntroPosition [ 1 ] ) ; Talk ( SAY_SYLVANAS_INTRO_1 ) ; _events . ScheduleEvent ( EVENT_WALK_INTRO2 , 9000 ) ; } break ; case EVENT_WALK_INTRO2 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) Talk ( SAY_JAINA_INTRO_2 ) ; else Talk ( SAY_SYLVANAS_INTRO_2 ) ; me -> SetFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; case EVENT_START_INTRO : if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> GetMotionMaster ( ) -> MovePoint ( 0 , KorelnOrLoralenPos [ 1 ] ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) { me -> GetMotionMaster ( ) -> MovePoint ( 0 , JainaIntroPosition [ 2 ] ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_1 , 0 ) ; } else { me -> GetMotionMaster ( ) -> MovePoint ( 0 , SylvanasIntroPosition [ 2 ] ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_1 , 0 ) ; } break ; case EVENT_INTRO_A2_1 : Talk ( SAY_JAINA_INTRO_3 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_2 , 7000 ) ; break ; case EVENT_INTRO_A2_2 : Talk ( SAY_JAINA_INTRO_4 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_3 , 10000 ) ; break ; case EVENT_INTRO_A2_3 : me -> CastSpell ( me , SPELL_CAST_VISUAL , false ) ; me -> CastSpell ( me , SPELL_FROSTMOURNE_SOUNDS , true ) ; _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_FROSTMOURNE ) , true ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_4 , 10000 ) ; break ; case EVENT_INTRO_A2_4 : if ( Creature * uther = me -> SummonCreature ( NPC_UTHER , UtherSpawnPos , TEMPSUMMON_MANUAL_DESPAWN ) ) _utherGUID = uther -> GetGUID ( ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_5 , 2000 ) ; break ; case EVENT_INTRO_A2_5 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_1 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_6 , 3000 ) ; break ; case EVENT_INTRO_A2_6 : Talk ( SAY_JAINA_INTRO_5 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_7 , 7000 ) ; break ; case EVENT_INTRO_A2_7 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_2 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_8 , 7000 ) ; break ; case EVENT_INTRO_A2_8 : Talk ( SAY_JAINA_INTRO_6 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_9 , 1200 ) ; break ; case EVENT_INTRO_A2_9 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_3 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_10 , 11000 ) ; break ; case EVENT_INTRO_A2_10 : Talk ( SAY_JAINA_INTRO_7 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_11 , 6000 ) ; break ; case EVENT_INTRO_A2_11 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_4 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_12 , 12000 ) ; break ; case EVENT_INTRO_A2_12 : Talk ( SAY_JAINA_INTRO_8 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_13 , 6000 ) ; break ; case EVENT_INTRO_A2_13 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_5 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_14 , 13000 ) ; break ; case EVENT_INTRO_A2_14 : Talk ( SAY_JAINA_INTRO_9 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_15 , 12000 ) ; break ; case EVENT_INTRO_A2_15 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_6 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_16 , 25000 ) ; break ; case EVENT_INTRO_A2_16 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_7 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_17 , 6000 ) ; break ; case EVENT_INTRO_A2_17 : Talk ( SAY_JAINA_INTRO_10 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_18 , 5000 ) ; break ; case EVENT_INTRO_A2_18 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) { uther -> HandleEmoteCommand ( EMOTE_ONESHOT_NO ) ; uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_8 ) ; } _events . ScheduleEvent ( EVENT_INTRO_A2_19 , 12000 ) ; break ; case EVENT_INTRO_A2_19 : Talk ( SAY_JAINA_INTRO_11 ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_1 , 3000 ) ; break ; case EVENT_INTRO_H2_1 : Talk ( SAY_SYLVANAS_INTRO_1 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_2 , 8000 ) ; break ; case EVENT_INTRO_H2_2 : Talk ( SAY_SYLVANAS_INTRO_2 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_3 , 6000 ) ; break ; case EVENT_INTRO_H2_3 : Talk ( SAY_SYLVANAS_INTRO_3 ) ; me -> CastSpell ( me , SPELL_CAST_VISUAL , false ) ; me -> CastSpell ( me , SPELL_FROSTMOURNE_SOUNDS , true ) ; _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_FROSTMOURNE ) , true ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_4 , 6000 ) ; break ; case EVENT_INTRO_H2_4 : if ( Creature * uther = me -> SummonCreature ( NPC_UTHER , UtherSpawnPos , TEMPSUMMON_MANUAL_DESPAWN ) ) _utherGUID = uther -> GetGUID ( ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_5 , 2000 ) ; break ; case EVENT_INTRO_H2_5 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_1 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_6 , 11000 ) ; break ; case EVENT_INTRO_H2_6 : Talk ( SAY_SYLVANAS_INTRO_4 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_7 , 3000 ) ; break ; case EVENT_INTRO_H2_7 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_2 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_8 , 6000 ) ; break ; case EVENT_INTRO_H2_8 : Talk ( SAY_SYLVANAS_INTRO_5 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_9 , 5000 ) ; break ; case EVENT_INTRO_H2_9 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_3 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_10 , 19000 ) ; break ; case EVENT_INTRO_H2_10 : Talk ( SAY_SYLVANAS_INTRO_6 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_11 , 1500 ) ; break ; case EVENT_INTRO_H2_11 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_4 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_12 , 19500 ) ; break ; case EVENT_INTRO_H2_12 : Talk ( SAY_SYLVANAS_INTRO_7 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_13 , 2000 ) ; break ; case EVENT_INTRO_H2_13 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) { uther -> HandleEmoteCommand ( EMOTE_ONESHOT_NO ) ; uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_5 ) ; } _events . ScheduleEvent ( EVENT_INTRO_H2_14 , 12000 ) ; break ; case EVENT_INTRO_H2_14 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_6 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_15 , 8000 ) ; break ; case EVENT_INTRO_H2_15 : Talk ( SAY_SYLVANAS_INTRO_8 ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_1 , 2000 ) ; break ; case EVENT_INTRO_LK_1 : if ( Creature * lichking = me -> SummonCreature ( NPC_THE_LICH_KING_INTRO , LichKingIntroPosition [ 0 ] , TEMPSUMMON_MANUAL_DESPAWN ) ) { lichking -> SetWalk ( true ) ; lichking -> GetMotionMaster ( ) -> MovePoint ( 0 , LichKingIntroPosition [ 2 ] ) ; _lichkingGUID = lichking -> GetGUID ( ) ; _events . ScheduleEvent ( EVENT_OPEN_IMPENETRABLE_DOOR , 0 ) ; _events . ScheduleEvent ( EVENT_CLOSE_IMPENETRABLE_DOOR , 4s ) ; } if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) { uther -> SetUInt32Value ( UNIT_NPC_EMOTESTATE , EMOTE_STATE_COWER ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_9 ) ; else uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_7 ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_2 , 10000 ) ; break ; case EVENT_INTRO_LK_2 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) lichking -> AI ( ) -> Talk ( SAY_LK_INTRO_1 ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_3 , 1000 ) ; break ; case EVENT_INTRO_LK_3 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) { uther -> CastSpell ( uther , SPELL_UTHER_DESPAWN , true ) ; uther -> DespawnOrUnsummon ( 5000 ) ; _utherGUID . Clear ( ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_4 , 9000 ) ; break ; case EVENT_INTRO_LK_4 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) { if ( GameObject * frostmourne = ObjectAccessor :: GetGameObject ( * me , _instance -> GetGuidData ( DATA_FROSTMOURNE ) ) ) frostmourne -> SetPhaseMask ( 2 , true ) ; lichking -> CastSpell ( lichking , SPELL_TAKE_FROSTMOURNE , true ) ; lichking -> CastSpell ( lichking , SPELL_FROSTMOURNE_VISUAL , true ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_5 , 8000 ) ; break ; case EVENT_INTRO_LK_5 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) lichking -> AI ( ) -> Talk ( SAY_LK_INTRO_2 ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_6 , 10000 ) ; break ; case EVENT_INTRO_LK_6 : if ( Creature * falric = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FALRIC ) ) ) { falric -> CastSpell ( falric , SPELL_BOSS_SPAWN_AURA , true ) ; falric -> SetVisible ( true ) ; } if ( Creature * marwyn = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_MARWYN ) ) ) { marwyn -> CastSpell ( marwyn , SPELL_BOSS_SPAWN_AURA , true ) ; marwyn -> SetVisible ( true ) ; } if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) { lichking -> AI ( ) -> Talk ( SAY_LK_INTRO_3 ) ; lichking -> SetWalk ( true ) ; lichking -> GetMotionMaster ( ) -> MovePoint ( 0 , LichKingMoveAwayPos ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_7 , 10000 ) ; _events . ScheduleEvent ( EVENT_OPEN_IMPENETRABLE_DOOR , 5s ) ; break ; case EVENT_INTRO_LK_7 : if ( Creature * marwyn = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_MARWYN ) ) ) { marwyn -> AI ( ) -> Talk ( SAY_MARWYN_INTRO_1 ) ; marwyn -> SetWalk ( true ) ; marwyn -> GetMotionMaster ( ) -> MovePoint ( 0 , MarwynPosition [ 1 ] ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_8 , 1000 ) ; break ; case EVENT_INTRO_LK_8 : if ( Creature * falric = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FALRIC ) ) ) { falric -> AI ( ) -> Talk ( SAY_FALRIC_INTRO_1 ) ; falric -> SetWalk ( true ) ; falric -> GetMotionMaster ( ) -> MovePoint ( 0 , FalricPosition [ 1 ] ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_9 , 5000 ) ; break ; case EVENT_INTRO_LK_9 : if ( Creature * falric = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FALRIC ) ) ) falric -> AI ( ) -> Talk ( SAY_FALRIC_INTRO_2 ) ; _instance -> ProcessEvent ( 0 , EVENT_SPAWN_WAVES ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_10 , 4000 ) ; break ; case EVENT_INTRO_LK_10 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) Talk ( SAY_JAINA_INTRO_END ) ; else Talk ( SAY_SYLVANAS_INTRO_END ) ; me -> GetMotionMaster ( ) -> MovePoint ( 0 , LichKingMoveAwayPos ) ; if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> GetMotionMaster ( ) -> MovePoint ( 1 , KorelnOrLoralenPos [ 2 ] ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_11 , 5000 ) ; break ; case EVENT_INTRO_LK_11 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) { if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) lichking -> AI ( ) -> Talk ( SAY_LK_JAINA_INTRO_END ) ; else lichking -> AI ( ) -> Talk ( SAY_LK_SYLVANAS_INTRO_END ) ; } _events . ScheduleEvent ( EVENT_INTRO_END , 5s ) ; break ; case EVENT_INTRO_END : _instance -> SetData ( DATA_INTRO_EVENT , DONE ) ; _events . ScheduleEvent ( EVENT_KORELN_LORALEN_DEATH , 8s ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) { lichking -> DespawnOrUnsummon ( 5000 ) ; _lichkingGUID . Clear ( ) ; } me -> DespawnOrUnsummon ( 10000 ) ; _events . ScheduleEvent ( EVENT_CLOSE_IMPENETRABLE_DOOR , 7s ) ; break ; case EVENT_SKIP_INTRO : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) me -> GetMotionMaster ( ) -> MovePoint ( 0 , JainaIntroPosition [ 2 ] ) ; else me -> GetMotionMaster ( ) -> MovePoint ( 0 , SylvanasIntroPosition [ 2 ] ) ; if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> GetMotionMaster ( ) -> MovePoint ( 0 , KorelnOrLoralenPos [ 1 ] ) ; if ( Creature * lichking = me -> SummonCreature ( NPC_THE_LICH_KING_INTRO , LichKingIntroPosition [ 0 ] , TEMPSUMMON_MANUAL_DESPAWN ) ) { lichking -> SetWalk ( true ) ; lichking -> GetMotionMaster ( ) -> MovePoint ( 0 , LichKingIntroPosition [ 2 ] ) ; lichking -> SetReactState ( REACT_PASSIVE ) ; _lichkingGUID = lichking -> GetGUID ( ) ; _events . ScheduleEvent ( EVENT_OPEN_IMPENETRABLE_DOOR , 0 ) ; _events . ScheduleEvent ( EVENT_CLOSE_IMPENETRABLE_DOOR , 4s ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_4 , 15000 ) ; break ; case EVENT_OPEN_IMPENETRABLE_DOOR : _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_IMPENETRABLE_DOOR ) , true ) ; break ; case EVENT_CLOSE_IMPENETRABLE_DOOR : _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_IMPENETRABLE_DOOR ) , false ) ; break ; case EVENT_KORELN_LORALEN_DEATH : if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> CastSpell ( korelnOrLoralen , SPELL_FEIGN_DEATH ) ; break ; default : break ; } } private : InstanceScript * _instance ; EventMap _events ; ObjectGuid _utherGUID ; ObjectGuid _lichkingGUID ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_jaina_or_sylvanas_intro_horAI > ( creature ) ; } } ; class HoRGameObjectDeleteDelayEvent : public BasicEvent { public : explicit HoRGameObjectDeleteDelayEvent ( Unit * owner , ObjectGuid gameObjectGUID ) : _owner ( owner ) , _gameObjectGUID ( gameObjectGUID ) { } void DeleteGameObject ( ) { if ( GameObject * go = ObjectAccessor :: GetGameObject ( * _owner , _gameObjectGUID ) ) go -> Delete ( ) ; } bool Execute ( uint64 , uint32 ) override { DeleteGameObject ( ) ; return true ; } void Abort ( uint64 ) override { DeleteGameObject ( ) ; } private : Unit * _owner ; ObjectGuid _gameObjectGUID ; } ; class npc_jaina_or_sylvanas_escape_hor : public CreatureScript { public : npc_jaina_or_sylvanas_escape_hor ( ) : CreatureScript ( " npc _ jaina _ or _ sylvanas _ escape _ hor " ) { } struct npc_jaina_or_sylvanas_escape_horAI : public ScriptedAI { npc_jaina_or_sylvanas_escape_horAI ( Creature * creature ) : ScriptedAI ( creature ) , _instance ( creature -> GetInstanceScript ( ) ) , _icewall ( 0 ) , _prefight ( false ) , _invincibility ( true ) { } void Reset ( ) override { _events . Reset ( ) ; _icewall = 0 ; _events . ScheduleEvent ( EVENT_ESCAPE , 1s ) ; _instance -> DoStopTimedAchievement ( ACHIEVEMENT_TIMED_TYPE_EVENT , ACHIEV_NOT_RETREATING_EVENT ) ; } void JustDied ( Unit * ) override { if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> AI ( ) -> EnterEvadeMode ( ) ; } void DamageTaken ( Unit * , uint32 & damage ) override { if ( damage >= me -> GetHealth ( ) && _invincibility ) damage = me -> GetHealth ( ) - 1 ; } void DoAction ( int32 actionId ) override { switch ( actionId ) { case ACTION_START_PREFIGHT : if ( _prefight ) return ; _prefight = true ; _events . ScheduleEvent ( EVENT_ESCAPE_1 , 1000 ) ; break ; case ACTION_WALL_BROKEN : ++ _icewall ; if ( _icewall < 4 ) _events . ScheduleEvent ( EVENT_ESCAPE_13 , 3000 ) ; else _events . ScheduleEvent ( EVENT_ESCAPE_15 , 3000 ) ; break ; case ACTION_GUNSHIP_ARRIVAL : _events . ScheduleEvent ( EVENT_ESCAPE_16 , 5000 ) ; break ; case ACTION_GUNSHIP_ARRIVAL_2 : _events . ScheduleEvent ( EVENT_ESCAPE_17 , 5000 ) ; break ; default : break ; } } bool GossipHello ( Player * player ) override { if ( _instance -> GetBossState ( DATA_THE_LICH_KING_ESCAPE ) == DONE ) { player -> PrepareGossipMenu ( me , me -> GetEntry ( ) == NPC_JAINA_ESCAPE ? GOSSIP_MENU_JAINA_FINAL : GOSSIP_MENU_SYLVANAS_FINAL , true ) ; player -> SendPreparedGossip ( me ) ; return true ; } return false ; } bool GossipSelect ( Player * player , uint32 , uint32 gossipListId ) override { ClearGossipMenuFor ( player ) ; switch ( gossipListId ) { case 0 : player -> PlayerTalkClass -> SendCloseGossip ( ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP ) ; _events . ScheduleEvent ( EVENT_ESCAPE_6 , 0 ) ; break ; default : break ; } return false ; } void DestroyIceWall ( ) { if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) me -> RemoveAurasDueToSpell ( SPELL_JAINA_DESTROY_ICE_WALL ) ; else me -> RemoveAurasDueToSpell ( SPELL_SYLVANAS_DESTROY_ICE_WALL ) ; _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_ICEWALL ) , true ) ; me -> m_Events . AddEvent ( new HoRGameObjectDeleteDelayEvent ( me , _instance -> GetGuidData ( DATA_ICEWALL ) ) , me -> m_Events . CalculateTime ( 5000 ) ) ; if ( Creature * wallTarget = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ICEWALL_TARGET ) ) ) wallTarget -> DespawnOrUnsummon ( ) ; } void SummonIceWall ( ) { if ( _icewall < 4 ) { if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> StopMoving ( ) ; if ( Creature * wallTarget = me -> SummonCreature ( NPC_ICE_WALL_TARGET , IceWallTargetPosition [ _icewall ] , TEMPSUMMON_MANUAL_DESPAWN , 720000 ) ) lichking -> CastSpell ( wallTarget , SPELL_SUMMON_ICE_WALL ) ; lichking -> AI ( ) -> SetData ( DATA_ICEWALL , _icewall ) ; } } } void AttackIceWall ( ) { if ( _icewall < 4 ) Talk ( SAY_JAINA_SYLVANAS_ESCAPE_2 + _icewall ) ; if ( Creature * wallTarget = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ICEWALL_TARGET ) ) ) me -> SetFacingToObject ( wallTarget ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_JAINA_DESTROY_ICE_WALL , true ) ; else DoCast ( me , SPELL_SYLVANAS_DESTROY_ICE_WALL , true ) ; } void MovementInform ( uint32 type , uint32 pointId ) override { if ( type != POINT_MOTION_TYPE ) return ; switch ( pointId ) { case POINT_SHADOW_THRONE_DOOR : if ( me -> GetEntry ( ) == NPC_JAINA_ESCAPE ) me -> RemoveAurasDueToSpell ( SPELL_JAINA_ICE_BARRIER ) ; else me -> RemoveAurasDueToSpell ( SPELL_SYLVANAS_CLOAK_OF_DARKNESS ) ; me -> SetFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP ) ; me -> SetHealth ( JAINA_SYLVANAS_MAX_HEALTH ) ; me -> SetFacingTo ( SylvanasShadowThroneDoorPosition . GetOrientation ( ) ) ; break ; case POINT_ATTACK_ICEWALL : AttackIceWall ( ) ; break ; case POINT_TRAP : Talk ( SAY_JAINA_SYLVANAS_ESCAPE_8 ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) me -> SetFacingToObject ( lichking ) ; break ; default : break ; } } void DeleteAllFromThreatList ( Unit * target , ObjectGuid except ) { for ( ThreatReference * ref : target -> GetThreatManager ( ) . GetModifiableThreatList ( ) ) if ( ref -> GetVictim ( ) -> GetGUID ( ) != except ) ref -> ClearThreat ( ) ; } void UpdateAI ( uint32 diff ) override { _events . Update ( diff ) ; while ( uint32 event = _events . ExecuteEvent ( ) ) { switch ( event ) { case EVENT_ESCAPE : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_JAINA_ICE_BARRIER ) ; else DoCast ( me , SPELL_SYLVANAS_CLOAK_OF_DARKNESS ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { me -> CastSpell ( lichking , SPELL_TAUNT_ARTHAS , true ) ; lichking -> ApplySpellImmune ( 0 , IMMUNITY_STATE , SPELL_AURA_MOD_TAUNT , true ) ; lichking -> ApplySpellImmune ( 0 , IMMUNITY_EFFECT , SPELL_EFFECT_ATTACK_ME , true ) ; AttackStart ( lichking ) ; lichking -> AI ( ) -> AttackStart ( me ) ; } me -> SetHealth ( JAINA_SYLVANAS_MAX_HEALTH ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; case EVENT_ESCAPE_1 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) lichking -> AI ( ) -> Talk ( SAY_LK_ESCAPE_1 ) ; else lichking -> AI ( ) -> Talk ( SAY_LK_ESCAPE_2 ) ; _events . ScheduleEvent ( EVENT_ESCAPE_2 , 8000 ) ; } break ; case EVENT_ESCAPE_2 : me -> AttackStop ( ) ; me -> StopMoving ( ) ; me -> SetReactState ( REACT_PASSIVE ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_JAINA_ICE_PRISON , false ) ; else DoCast ( me , SPELL_SYLVANAS_BLINDING_RETREAT , true ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> SetReactState ( REACT_PASSIVE ) ; lichking -> SetFlag ( UNIT_FIELD_FLAGS , UNIT_FLAG_PACIFIED ) ; } _events . ScheduleEvent ( EVENT_ESCAPE_3 , 1500 ) ; break ; case EVENT_ESCAPE_3 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == HORDE ) DoCastAOE ( SPELL_SYLVANAS_DARK_BINDING , true ) ; _events . ScheduleEvent ( EVENT_ESCAPE_4 , 1000 ) ; break ; case EVENT_ESCAPE_4 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_CREDIT_FINDING_JAINA ) ; else DoCast ( me , SPELL_CREDIT_FINDING_SYLVANAS ) ; Talk ( SAY_JAINA_SYLVANAS_ESCAPE_1 ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> SetImmuneToPC ( true ) ; lichking -> RemoveAllAttackers ( ) ; DeleteAllFromThreatList ( lichking , me -> GetGUID ( ) ) ; } _events . ScheduleEvent ( EVENT_ESCAPE_5 , 2000 ) ; break ; case EVENT_ESCAPE_5 : me -> GetMotionMaster ( ) -> MovePoint ( POINT_SHADOW_THRONE_DOOR , SylvanasShadowThroneDoorPosition ) ; break ; case EVENT_ESCAPE_6 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> RemoveFlag ( UNIT_FIELD_FLAGS , UNIT_FLAG_PACIFIED ) ; lichking -> SetImmuneToPC ( false ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) { lichking -> CastSpell ( lichking , SPELL_STUN_BREAK_JAINA ) ; lichking -> RemoveAurasDueToSpell ( SPELL_JAINA_ICE_PRISON ) ; } else { lichking -> CastSpell ( lichking , SPELL_STUN_BREAK_SYLVANAS ) ; lichking -> RemoveAurasDueToSpell ( SPELL_SYLVANAS_DARK_BINDING ) ; } } _invincibility = false ; _instance -> DoStartTimedAchievement ( ACHIEVEMENT_TIMED_TYPE_EVENT , ACHIEV_NOT_RETREATING_EVENT ) ; _events . ScheduleEvent ( EVENT_ESCAPE_7 , 1000 ) ; break ; case EVENT_ESCAPE_7 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> HandleEmoteCommand ( TEXT_EMOTE_ROAR ) ; me -> GetMotionMaster ( ) -> MovePoint ( 0 , NpcJainaOrSylvanasEscapeRoute [ 0 ] ) ; _events . ScheduleEvent ( EVENT_ESCAPE_8 , 3000 ) ; break ; case EVENT_ESCAPE_8 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> GetMotionMaster ( ) -> MovePoint ( 0 , NpcJainaOrSylvanasEscapeRoute [ 0 ] ) ; _events . ScheduleEvent ( EVENT_ESCAPE_9 , 1000 ) ; break ; case EVENT_ESCAPE_9 : me -> GetMotionMaster ( ) -> MovePoint ( 0 , NpcJainaOrSylvanasEscapeRoute [ 1 ] ) ; _events . ScheduleEvent ( EVENT_ESCAPE_10 , 5000 ) ; break ; case EVENT_ESCAPE_10 : me -> GetMotionMaster ( ) -> MovePoint ( 0 , NpcJainaOrSylvanasEscapeRoute [ 2 ] ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> GetMotionMaster ( ) -> MovePoint ( 1 , LichKingFirstSummon ) ; _events . ScheduleEvent ( EVENT_ESCAPE_11 , 6000 ) ; break ; case EVENT_ESCAPE_11 : SummonIceWall ( ) ; _events . ScheduleEvent ( EVENT_ESCAPE_12 , 4000 ) ; break ; case EVENT_ESCAPE_12 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> CastSpell ( lichking , SPELL_PAIN_AND_SUFFERING , true ) ; me -> GetMotionMaster ( ) -> MovePoint ( POINT_ATTACK_ICEWALL , NpcJainaOrSylvanasEscapeRoute [ 3 ] ) ; break ; case EVENT_ESCAPE_13 : DestroyIceWall ( ) ; if ( _icewall && _icewall < 4 ) me -> GetMotionMaster ( ) -> MovePoint ( POINT_ATTACK_ICEWALL , NpcJainaOrSylvanasEscapeRoute [ _icewall + 3 ] ) ; _events . ScheduleEvent ( EVENT_ESCAPE_14 , 8000 ) ; break ; case EVENT_ESCAPE_14 : SummonIceWall ( ) ; break ; case EVENT_ESCAPE_15 : DestroyIceWall ( ) ; Talk ( SAY_JAINA_SYLVANAS_ESCAPE_6 ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> GetMotionMaster ( ) -> MovePoint ( 2 , LichKingFinalPos ) ; lichking -> RemoveAurasDueToSpell ( SPELL_REMORSELESS_WINTER ) ; } me -> GetMotionMaster ( ) -> MovePoint ( POINT_TRAP , NpcJainaOrSylvanasEscapeRoute [ 7 ] ) ; break ; case EVENT_ESCAPE_16 : me -> RemoveAurasDueToSpell ( SPELL_HARVEST_SOUL ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) Talk ( SAY_JAINA_ESCAPE_9 ) ; if ( Transport * gunship = ObjectAccessor :: GetTransport ( * me , _instance -> GetGuidData ( DATA_GUNSHIP ) ) ) gunship -> EnableMovement ( true ) ; _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , DONE ) ; break ; case EVENT_ESCAPE_17 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) Talk ( SAY_JAINA_ESCAPE_10 ) ; else Talk ( SAY_SYLVANAS_ESCAPE_9 ) ; DoCast ( me , SPELL_CREDIT_ESCAPING_ARTHAS ) ; me -> SetFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } private : InstanceScript * _instance ; EventMap _events ; uint32 _icewall ; bool _prefight ; bool _invincibility ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_jaina_or_sylvanas_escape_horAI > ( creature ) ; } } ; class npc_the_lich_king_escape_hor : public CreatureScript { public : npc_the_lich_king_escape_hor ( ) : CreatureScript ( " npc _ the _ lich _ king _ escape _ hor " ) { } struct npc_the_lich_king_escape_horAI : public ScriptedAI { npc_the_lich_king_escape_horAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , NOT_STARTED ) ; _summonsCount = 0 ; _icewall = 0 ; _despawn = false ; } void DamageTaken ( Unit * , uint32 & damage ) override { if ( damage >= me -> GetHealth ( ) ) damage = me -> GetHealth ( ) - 1 ; } void MovementInform ( uint32 type , uint32 pointId ) override { if ( type == POINT_MOTION_TYPE ) { switch ( pointId ) { case 1 : if ( Creature * target = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ESCAPE_LEADER ) ) ) me -> GetMotionMaster ( ) -> MoveChase ( target ) ; break ; case 2 : Talk ( SAY_LK_ESCAPE_HARVEST_SOUL ) ; if ( Creature * target = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ESCAPE_LEADER ) ) ) DoCast ( target , SPELL_HARVEST_SOUL ) ; if ( Transport * gunship = ObjectAccessor :: GetTransport ( * me , _instance -> GetGuidData ( DATA_GUNSHIP ) ) ) gunship -> EnableMovement ( true ) ; break ; default : break ; } } } void JustSummoned ( Creature * ) override { ++ _summonsCount ; } void SummonedCreatureDies ( Creature * , Unit * ) override { if ( ! _summonsCount ) return ; -- _summonsCount ; if ( ! _summonsCount && _events . Empty ( ) ) { if ( Creature * jainaOrSylvanas = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ESCAPE_LEADER ) ) ) jainaOrSylvanas -> AI ( ) -> DoAction ( ACTION_WALL_BROKEN ) ; } } void KilledUnit ( Unit * who ) override { if ( who -> GetTypeId ( ) == TYPEID_PLAYER ) DoPlaySoundToSet ( me , RAND ( SOUND_LK_SLAY_1 , SOUND_LK_SLAY_2 ) ) ; } void SetData ( uint32 type , uint32 data ) override { if ( type != DATA_ICEWALL ) return ; _icewall = data ; switch ( _icewall ) { case 0 : DoZoneInCombat ( ) ; _events . ScheduleEvent ( EVENT_REMORSELESS_WINTER , 0 ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 8s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 14s ) ; Talk ( SAY_LK_ESCAPE_ICEWALL_SUMMONED_1 ) ; break ; case 1 : _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 8s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 13s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 15s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 18s ) ; Talk ( SAY_LK_ESCAPE_ICEWALL_SUMMONED_2 ) ; break ; case 2 : _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 9s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 14s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 15s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 19s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 39s ) ; Talk ( SAY_LK_ESCAPE_ICEWALL_SUMMONED_3 ) ; break ; case 3 : _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 9s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 15s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 19s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 40s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 45s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 55s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 62s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 65s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 14s ) ; Talk ( SAY_LK_ESCAPE_ICEWALL_SUMMONED_4 ) ; break ; default : break ; } } void EnterEvadeMode ( EvadeReason ) override { if ( _despawn ) return ; _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , FAIL ) ; me -> StopMoving ( ) ; DoPlaySoundToSet ( me , SOUND_LK_FURY_OF_FROSTMOURNE ) ; DoCastAOE ( SPELL_FURY_OF_FROSTMOURNE ) ; me -> DespawnOrUnsummon ( 12000 ) ; _despawn = true ; } void UpdateAI ( uint32 diff ) override { if ( ! SelectVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; while ( uint32 event = _events . ExecuteEvent ( ) ) { switch ( event ) { case EVENT_REMORSELESS_WINTER : me -> StopMoving ( ) ; Talk ( SAY_LK_ESCAPE_WINTER ) ; DoCast ( me , SPELL_REMORSELESS_WINTER ) ; break ; case EVENT_ESCAPE_SUMMON_GHOULS : me -> StopMoving ( ) ; Talk ( SAY_LK_ESCAPE_GHOULS ) ; DoCast ( me , SPELL_RAISE_DEAD ) ; break ; case EVENT_ESCAPE_SUMMON_WITCH_DOCTOR : DoCast ( me , SPELL_SUMMON_RISEN_WITCH_DOCTOR ) ; break ; case EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION : Talk ( SAY_LK_ESCAPE_ABOMINATION ) ; DoCast ( me , SPELL_SUMMON_LUMBERING_ABOMINATION ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } private : bool SelectVictim ( ) { if ( ! me -> IsInCombat ( ) ) return false ; if ( ! me -> HasReactState ( REACT_PASSIVE ) ) { if ( Unit * victim = me -> SelectVictim ( ) ) if ( ! me -> HasSpellFocus ( ) && victim != me -> GetVictim ( ) ) AttackStart ( victim ) ; return me -> GetVictim ( ) != nullptr ; } else if ( me -> GetCombatManager ( ) . GetPvECombatRefs ( ) . size ( ) < 2 && me -> HasAura ( SPELL_REMORSELESS_WINTER ) ) { EnterEvadeMode ( EVADE_REASON_OTHER ) ; return false ; } return true ; } InstanceScript * _instance ; EventMap _events ; uint8 _icewall ; uint32 _summonsCount ; bool _despawn ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_the_lich_king_escape_horAI > ( creature ) ; } } ; enum TrashSpells { SPELL_SHADOW_WORD_PAIN = 72318 , SPELL_CIRCLE_OF_DESTRUCTION = 72320 , SPELL_COWER_IN_FEAR = 72321 , SPELL_DARK_MENDING = 72322 , SPELL_FIREBALL = 72163 , SPELL_FLAMESTRIKE = 72169 , SPELL_FROSTBOLT = 72166 , SPELL_CHAINS_OF_ICE = 72121 , SPELL_HALLUCINATION = 72342 , AURA_HALLUCINATION = 72343 , SPELL_HALLUCINATION_2 = 72344 , SPELL_SHADOW_STEP = 72326 , SPELL_DEADLY_POISON = 72329 , SPELL_ENVENOMED_DAGGER_THROW = 72333 , SPELL_KIDNEY_SHOT = 72335 , SPELL_SPECTRAL_STRIKE = 72198 , SPELL_SHIELD_BASH = 72194 , SPELL_TORTURED_ENRAGE = 72203 , SPELL_SHOOT = 72208 , SPELL_CURSED_ARROW = 72222 , SPELL_FROST_TRAP = 72215 , SPELL_ICE_SHOT = 72268 } ; enum TrashEvents { EVENT_TRASH_NONE , EVENT_SHADOW_WORD_PAIN , EVENT_CIRCLE_OF_DESTRUCTION , EVENT_COWER_IN_FEAR , EVENT_DARK_MENDING , EVENT_FIREBALL , EVENT_FLAMESTRIKE , EVENT_FROSTBOLT , EVENT_CHAINS_OF_ICE , EVENT_HALLUCINATION , EVENT_SHADOW_STEP , EVENT_DEADLY_POISON , EVENT_ENVENOMED_DAGGER_THROW , EVENT_KIDNEY_SHOT , EVENT_SPECTRAL_STRIKE , EVENT_SHIELD_BASH , EVENT_TORTURED_ENRAGE , EVENT_SHOOT , EVENT_CURSED_ARROW , EVENT_FROST_TRAP , EVENT_ICE_SHOT } ; struct npc_gauntlet_trash : public ScriptedAI { npc_gauntlet_trash ( Creature * creature ) : ScriptedAI ( creature ) , _instance ( creature -> GetInstanceScript ( ) ) , InternalWaveId ( 0 ) { } void Reset ( ) override { me -> CastSpell ( me , SPELL_WELL_OF_SOULS , true ) ; _events . Reset ( ) ; } void EnterEvadeMode ( EvadeReason ) override { if ( _instance -> GetData ( DATA_WAVE_COUNT ) != NOT_STARTED ) _instance -> SetData ( DATA_WAVE_COUNT , NOT_STARTED ) ; } void SetData ( uint32 type , uint32 value ) override { if ( type ) return ; InternalWaveId = value ; } uint32 GetData ( uint32 type ) const override { if ( type ) return 0 ; return InternalWaveId ; } protected : EventMap _events ; InstanceScript * _instance ; uint32 InternalWaveId ; } ; class npc_ghostly_priest : public CreatureScript { public : npc_ghostly_priest ( ) : CreatureScript ( " npc _ ghostly _ priest " ) { } struct npc_ghostly_priestAI : public npc_gauntlet_trash { npc_ghostly_priestAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_SHADOW_WORD_PAIN , 6s , 15s ) ; _events . ScheduleEvent ( EVENT_CIRCLE_OF_DESTRUCTION , 12s ) ; _events . ScheduleEvent ( EVENT_COWER_IN_FEAR , 10s ) ; _events . ScheduleEvent ( EVENT_DARK_MENDING , 20s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_SHADOW_WORD_PAIN : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_SHADOW_WORD_PAIN ) ; _events . ScheduleEvent ( EVENT_SHADOW_WORD_PAIN , 6s , 15s ) ; break ; case EVENT_CIRCLE_OF_DESTRUCTION : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 10.0f , true ) ) DoCast ( target , SPELL_CIRCLE_OF_DESTRUCTION ) ; _events . ScheduleEvent ( EVENT_CIRCLE_OF_DESTRUCTION , 12s ) ; break ; case EVENT_COWER_IN_FEAR : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 20.0f , true ) ) DoCast ( target , SPELL_COWER_IN_FEAR ) ; _events . ScheduleEvent ( EVENT_COWER_IN_FEAR , 10s ) ; break ; case EVENT_DARK_MENDING : if ( Unit * target = DoSelectLowestHpFriendly ( 40 , DUNGEON_MODE ( 30000 , 50000 ) ) ) { DoCast ( target , SPELL_DARK_MENDING ) ; _events . ScheduleEvent ( EVENT_DARK_MENDING , 20s ) ; } else { _events . ScheduleEvent ( EVENT_DARK_MENDING , 5s ) ; } break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_ghostly_priestAI > ( creature ) ; } } ; class npc_phantom_mage : public CreatureScript { public : npc_phantom_mage ( ) : CreatureScript ( " npc _ phantom _ mage " ) { } struct npc_phantom_mageAI : public npc_gauntlet_trash { npc_phantom_mageAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void EnterEvadeMode ( EvadeReason why ) override { if ( ! me -> HasAura ( AURA_HALLUCINATION ) ) npc_gauntlet_trash :: EnterEvadeMode ( why ) ; } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_FIREBALL , 3s ) ; _events . ScheduleEvent ( EVENT_FLAMESTRIKE , 6s ) ; _events . ScheduleEvent ( EVENT_FROSTBOLT , 9s ) ; _events . ScheduleEvent ( EVENT_CHAINS_OF_ICE , 12s ) ; _events . ScheduleEvent ( EVENT_HALLUCINATION , 40s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_FIREBALL : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_FIREBALL ) ; _events . ScheduleEvent ( EVENT_FIREBALL , 15s ) ; break ; case EVENT_FLAMESTRIKE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_FLAMESTRIKE ) ; _events . ScheduleEvent ( EVENT_FLAMESTRIKE , 15s ) ; break ; case EVENT_FROSTBOLT : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_FROSTBOLT ) ; _events . ScheduleEvent ( EVENT_FROSTBOLT , 15s ) ; break ; case EVENT_CHAINS_OF_ICE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM ) ) DoCast ( target , SPELL_CHAINS_OF_ICE ) ; _events . ScheduleEvent ( EVENT_CHAINS_OF_ICE , 15s ) ; break ; case EVENT_HALLUCINATION : me -> RemoveAllAuras ( ) ; DoCast ( me , SPELL_HALLUCINATION ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_phantom_mageAI > ( creature ) ; } } ; class npc_phantom_hallucination : public CreatureScript { public : npc_phantom_hallucination ( ) : CreatureScript ( " npc _ phantom _ hallucination " ) { } struct npc_phantom_hallucinationAI : public npc_phantom_mage :: npc_phantom_mageAI { npc_phantom_hallucinationAI ( Creature * creature ) : npc_phantom_mage :: npc_phantom_mageAI ( creature ) { } void Reset ( ) override { DoZoneInCombat ( me ) ; } void EnterEvadeMode ( EvadeReason why ) override { if ( me -> GetOwner ( ) && ! me -> GetOwner ( ) -> HasAura ( AURA_HALLUCINATION ) ) npc_phantom_mage :: npc_phantom_mageAI :: EnterEvadeMode ( why ) ; } void JustDied ( Unit * ) override { DoCastAOE ( SPELL_HALLUCINATION_2 ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_phantom_hallucinationAI > ( creature ) ; } } ; class npc_shadowy_mercenary : public CreatureScript { public : npc_shadowy_mercenary ( ) : CreatureScript ( " npc _ shadowy _ mercenary " ) { } struct npc_shadowy_mercenaryAI : public npc_gauntlet_trash { npc_shadowy_mercenaryAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_SHADOW_STEP , 23s ) ; _events . ScheduleEvent ( EVENT_DEADLY_POISON , 5s ) ; _events . ScheduleEvent ( EVENT_ENVENOMED_DAGGER_THROW , 10s ) ; _events . ScheduleEvent ( EVENT_KIDNEY_SHOT , 12s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_SHADOW_STEP : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 100.0f , true ) ) DoCast ( target , SPELL_SHADOW_STEP ) ; _events . ScheduleEvent ( EVENT_SHADOW_STEP , 8s ) ; break ; case EVENT_DEADLY_POISON : DoCastVictim ( SPELL_DEADLY_POISON ) ; _events . ScheduleEvent ( EVENT_DEADLY_POISON , 10s ) ; break ; case EVENT_ENVENOMED_DAGGER_THROW : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_ENVENOMED_DAGGER_THROW ) ; _events . ScheduleEvent ( EVENT_ENVENOMED_DAGGER_THROW , 10s ) ; break ; case EVENT_KIDNEY_SHOT : DoCastVictim ( SPELL_KIDNEY_SHOT ) ; _events . ScheduleEvent ( EVENT_KIDNEY_SHOT , 10s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_shadowy_mercenaryAI > ( creature ) ; } } ; class npc_spectral_footman : public CreatureScript { public : npc_spectral_footman ( ) : CreatureScript ( " npc _ spectral _ footman " ) { } struct npc_spectral_footmanAI : public npc_gauntlet_trash { npc_spectral_footmanAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_SPECTRAL_STRIKE , 14s ) ; _events . ScheduleEvent ( EVENT_SHIELD_BASH , 10s ) ; _events . ScheduleEvent ( EVENT_TORTURED_ENRAGE , 15s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_SPECTRAL_STRIKE : DoCastVictim ( SPELL_SPECTRAL_STRIKE ) ; _events . ScheduleEvent ( EVENT_SPECTRAL_STRIKE , 5s ) ; break ; case EVENT_SHIELD_BASH : DoCastVictim ( SPELL_SHIELD_BASH ) ; _events . ScheduleEvent ( EVENT_SHIELD_BASH , 5s ) ; break ; case EVENT_TORTURED_ENRAGE : DoCast ( me , SPELL_TORTURED_ENRAGE ) ; _events . ScheduleEvent ( EVENT_TORTURED_ENRAGE , 15s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_spectral_footmanAI > ( creature ) ; } } ; class npc_tortured_rifleman : public CreatureScript { public : npc_tortured_rifleman ( ) : CreatureScript ( " npc _ tortured _ rifleman " ) { } struct npc_tortured_riflemanAI : public npc_gauntlet_trash { npc_tortured_riflemanAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_SHOOT , 1 ) ; _events . ScheduleEvent ( EVENT_CURSED_ARROW , 7s ) ; _events . ScheduleEvent ( EVENT_FROST_TRAP , 10s ) ; _events . ScheduleEvent ( EVENT_ICE_SHOT , 15s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_SHOOT : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_SHOOT ) ; _events . ScheduleEvent ( EVENT_SHOOT , 2s ) ; break ; case EVENT_CURSED_ARROW : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_CURSED_ARROW ) ; _events . ScheduleEvent ( EVENT_CURSED_ARROW , 10s ) ; break ; case EVENT_FROST_TRAP : DoCast ( me , SPELL_FROST_TRAP ) ; _events . ScheduleEvent ( EVENT_FROST_TRAP , 30s ) ; break ; case EVENT_ICE_SHOT : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_ICE_SHOT ) ; _events . ScheduleEvent ( EVENT_ICE_SHOT , 15s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_tortured_riflemanAI > ( creature ) ; } } ; enum FrostswornGeneral { EVENT_SHIELD = 1 , EVENT_SPIKE = 2 , EVENT_CLONE = 3 , SAY_AGGRO = 0 , SAY_DEATH = 1 , SPELL_SHIELD_THROWN = 69222 , SPELL_SPIKE = 69184 , SPELL_CLONE = 69828 , SPELL_GHOST_VISUAL = 69861 , EVENT_BALEFUL_STRIKE = 1 , SPELL_BALEFUL_STRIKE = 69933 , SPELL_SPIRIT_BURST = 69900 } ; class npc_frostsworn_general : public CreatureScript { public : npc_frostsworn_general ( ) : CreatureScript ( " npc _ frostsworn _ general " ) { } struct npc_frostsworn_generalAI : public ScriptedAI { npc_frostsworn_generalAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = creature -> GetInstanceScript ( ) ; } void Reset ( ) override { _events . Reset ( ) ; _instance -> SetData ( DATA_FROSTSWORN_GENERAL , NOT_STARTED ) ; } void JustDied ( Unit * ) override { Talk ( SAY_DEATH ) ; _events . Reset ( ) ; _instance -> SetData ( DATA_FROSTSWORN_GENERAL , DONE ) ; } void JustEngagedWith ( Unit * ) override { Talk ( SAY_AGGRO ) ; DoZoneInCombat ( ) ; _events . ScheduleEvent ( EVENT_SHIELD , 5s ) ; _events . ScheduleEvent ( EVENT_SPIKE , 14s ) ; _events . ScheduleEvent ( EVENT_CLONE , 22s ) ; _instance -> SetData ( DATA_FROSTSWORN_GENERAL , IN_PROGRESS ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; while ( uint32 event = _events . ExecuteEvent ( ) ) { switch ( event ) { case EVENT_SHIELD : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 45.0f , true ) ) DoCast ( target , SPELL_SHIELD_THROWN ) ; _events . ScheduleEvent ( EVENT_SHIELD , 8s , 12s ) ; break ; case EVENT_SPIKE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 45.0f , true ) ) DoCast ( target , SPELL_SPIKE ) ; _events . ScheduleEvent ( EVENT_SPIKE , 15s , 20s ) ; break ; case EVENT_CLONE : SummonClones ( ) ; _events . ScheduleEvent ( EVENT_CLONE , 1min ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } void SummonClones ( ) { std :: list < Unit * > playerList ; SelectTargetList ( playerList , 5 , SELECT_TARGET_MAXTHREAT , 0 , 0.0f , true ) ; for ( Unit * target : playerList ) { if ( Creature * reflection = me -> SummonCreature ( NPC_REFLECTION , * target , TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT , 3000 ) ) { reflection -> SetImmuneToPC ( false ) ; target -> CastSpell ( reflection , SPELL_CLONE , true ) ; target -> CastSpell ( reflection , SPELL_GHOST_VISUAL , true ) ; reflection -> AI ( ) -> AttackStart ( target ) ; } } } private : InstanceScript * _instance ; EventMap _events ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_frostsworn_generalAI > ( creature ) ; } } ; class npc_spiritual_reflection : public CreatureScript { public : npc_spiritual_reflection ( ) : CreatureScript ( " npc _ spiritual _ reflection " ) { } struct npc_spiritual_reflectionAI : public ScriptedAI { npc_spiritual_reflectionAI ( Creature * creature ) : ScriptedAI ( creature ) { } void Reset ( ) override { _events . Reset ( ) ; } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_BALEFUL_STRIKE , 3s ) ; } void JustDied ( Unit * ) override { DoCastAOE ( SPELL_SPIRIT_BURST ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_BALEFUL_STRIKE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 8.0f , true ) ) DoCast ( target , SPELL_BALEFUL_STRIKE ) ; _events . ScheduleEvent ( EVENT_BALEFUL_STRIKE , 3s , 8s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } private : EventMap _events ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_spiritual_reflectionAI > ( creature ) ; } } ; class at_hor_intro_start : public AreaTriggerScript { public : at_hor_intro_start ( ) : AreaTriggerScript ( " at _ hor _ intro _ start " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetData ( DATA_INTRO_EVENT ) == NOT_STARTED ) _instance -> SetData ( DATA_INTRO_EVENT , IN_PROGRESS ) ; if ( player -> HasAura ( SPELL_QUEL_DELAR_COMPULSION ) && ( player -> GetQuestStatus ( QUEST_HALLS_OF_REFLECTION_ALLIANCE ) == QUEST_STATUS_INCOMPLETE || player -> GetQuestStatus ( QUEST_HALLS_OF_REFLECTION_HORDE ) == QUEST_STATUS_INCOMPLETE ) && _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) == NOT_STARTED ) { _instance -> SetData ( DATA_QUEL_DELAR_EVENT , IN_PROGRESS ) ; _instance -> SetGuidData ( DATA_QUEL_DELAR_INVOKER , player -> GetGUID ( ) ) ; } return true ; } } ; class at_hor_waves_restarter : public AreaTriggerScript { public : at_hor_waves_restarter ( ) : AreaTriggerScript ( " at _ hor _ waves _ restarter " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetData ( DATA_WAVE_COUNT ) ) return true ; if ( _instance -> GetData ( DATA_INTRO_EVENT ) == DONE && _instance -> GetBossState ( DATA_MARWYN ) != DONE ) { _instance -> ProcessEvent ( 0 , EVENT_SPAWN_WAVES ) ; if ( Creature * falric = ObjectAccessor :: GetCreature ( * player , _instance -> GetGuidData ( DATA_FALRIC ) ) ) { falric -> CastSpell ( falric , SPELL_BOSS_SPAWN_AURA , true ) ; falric -> SetVisible ( true ) ; } if ( Creature * marwyn = ObjectAccessor :: GetCreature ( * player , _instance -> GetGuidData ( DATA_MARWYN ) ) ) { marwyn -> CastSpell ( marwyn , SPELL_BOSS_SPAWN_AURA , true ) ; marwyn -> SetVisible ( true ) ; } } return true ; } } ; class at_hor_impenetrable_door : public AreaTriggerScript { public : at_hor_impenetrable_door ( ) : AreaTriggerScript ( " at _ hor _ impenetrable _ door " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetBossState ( DATA_MARWYN ) == DONE ) return true ; return false ; } } ; class at_hor_shadow_throne : public AreaTriggerScript { public : at_hor_shadow_throne ( ) : AreaTriggerScript ( " at _ hor _ shadow _ throne " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetBossState ( DATA_THE_LICH_KING_ESCAPE ) == NOT_STARTED ) _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , IN_PROGRESS ) ; return true ; } } ; enum EscapeEvents { EVENT_RAGING_GHOUL_JUMP = 1 , EVENT_RISEN_WITCH_DOCTOR_CURSE , EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT , EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY , EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY , EVENT_LUMBERING_ABOMINATION_CLEAVE } ; class HoRStartMovementEvent : public BasicEvent { public : explicit HoRStartMovementEvent ( Creature * owner ) : _owner ( owner ) { } bool Execute ( uint64 , uint32 ) override { _owner -> SetReactState ( REACT_AGGRESSIVE ) ; if ( Unit * target = _owner -> AI ( ) -> SelectTarget ( SELECT_TARGET_RANDOM , 0 , 0.0f , true ) ) _owner -> AI ( ) -> AttackStart ( target ) ; return true ; } private : Creature * _owner ; } ; struct npc_escape_event_trash : public ScriptedAI { npc_escape_event_trash ( Creature * creature ) : ScriptedAI ( creature ) , _instance ( creature -> GetInstanceScript ( ) ) { } void Reset ( ) override { _events . Reset ( ) ; } void UpdateAI ( uint32 ) override { if ( _instance -> GetBossState ( DATA_THE_LICH_KING_ESCAPE ) == FAIL || _instance -> GetBossState ( DATA_THE_LICH_KING_ESCAPE ) == NOT_STARTED ) me -> DespawnOrUnsummon ( ) ; } void IsSummonedBy ( WorldObject * ) override { DoZoneInCombat ( me ) ; if ( Creature * leader = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ESCAPE_LEADER ) ) ) { me -> SetImmuneToPC ( false ) ; me -> SetInCombatWith ( leader ) ; leader -> SetInCombatWith ( me ) ; AddThreat ( leader , 0.0f ) ; } } protected : EventMap _events ; InstanceScript * _instance ; } ; class npc_raging_ghoul : public CreatureScript { public : npc_raging_ghoul ( ) : CreatureScript ( " npc _ raging _ ghoul " ) { } struct npc_raging_ghoulAI : public npc_escape_event_trash { npc_raging_ghoulAI ( Creature * creature ) : npc_escape_event_trash ( creature ) { } void Reset ( ) override { npc_escape_event_trash :: Reset ( ) ; _events . ScheduleEvent ( EVENT_RAGING_GHOUL_JUMP , 5s ) ; } void IsSummonedBy ( WorldObject * summoner ) override { me -> CastSpell ( me , SPELL_RAGING_GHOUL_SPAWN , true ) ; me -> SetReactState ( REACT_PASSIVE ) ; me -> HandleEmoteCommand ( EMOTE_ONESHOT_EMERGE ) ; me -> m_Events . AddEvent ( new HoRStartMovementEvent ( me ) , me -> m_Events . CalculateTime ( 5000 ) ) ; npc_escape_event_trash :: IsSummonedBy ( summoner ) ; } void UpdateAI ( uint32 diff ) override { npc_escape_event_trash :: UpdateAI ( diff ) ; if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_RAGING_GHOUL_JUMP : if ( Unit * victim = me -> GetVictim ( ) ) { if ( me -> IsInRange ( victim , 5.0f , 30.0f ) ) { DoCast ( victim , SPELL_GHOUL_JUMP ) ; return ; } } _events . ScheduleEvent ( EVENT_RAGING_GHOUL_JUMP , 500ms ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_raging_ghoulAI > ( creature ) ; } } ; class npc_risen_witch_doctor : public CreatureScript { public : npc_risen_witch_doctor ( ) : CreatureScript ( " npc _ risen _ witch _ doctor " ) { } struct npc_risen_witch_doctorAI : public npc_escape_event_trash { npc_risen_witch_doctorAI ( Creature * creature ) : npc_escape_event_trash ( creature ) { } void Reset ( ) override { npc_escape_event_trash :: Reset ( ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT , 6s ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY , 15s ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_CURSE , 7s ) ; } void IsSummonedBy ( WorldObject * summoner ) override { me -> CastSpell ( me , SPELL_RISEN_WITCH_DOCTOR_SPAWN , true ) ; me -> SetReactState ( REACT_PASSIVE ) ; me -> HandleEmoteCommand ( EMOTE_ONESHOT_EMERGE ) ; me -> m_Events . AddEvent ( new HoRStartMovementEvent ( me ) , me -> m_Events . CalculateTime ( 5000 ) ) ; npc_escape_event_trash :: IsSummonedBy ( summoner ) ; } void UpdateAI ( uint32 diff ) override { npc_escape_event_trash :: UpdateAI ( diff ) ; if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_RISEN_WITCH_DOCTOR_CURSE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 30.0f , true ) ) DoCast ( target , SPELL_CURSE_OF_DOOM ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_CURSE , 10s , 15s ) ; break ; case EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT : if ( Unit * target = SelectTarget ( SELECT_TARGET_MAXTHREAT , 0 , 20.0f , true ) ) DoCast ( target , SPELL_SHADOW_BOLT ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT , 2s , 3s ) ; break ; case EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY : if ( SelectTarget ( SELECT_TARGET_RANDOM , 0 , 30.0f , true ) ) DoCastAOE ( SPELL_SHADOW_BOLT_VOLLEY ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY , 15s , 22s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_risen_witch_doctorAI > ( creature ) ; } } ; class npc_lumbering_abomination : public CreatureScript { public : npc_lumbering_abomination ( ) : CreatureScript ( " npc _ lumbering _ abomination " ) { } struct npc_lumbering_abominationAI : public npc_escape_event_trash { npc_lumbering_abominationAI ( Creature * creature ) : npc_escape_event_trash ( creature ) { } void Reset ( ) override { npc_escape_event_trash :: Reset ( ) ; _events . ScheduleEvent ( EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY , 15s ) ; _events . ScheduleEvent ( EVENT_LUMBERING_ABOMINATION_CLEAVE , 6s ) ; } void UpdateAI ( uint32 diff ) override { npc_escape_event_trash :: UpdateAI ( diff ) ; if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY : DoCastVictim ( SPELL_VOMIT_SPRAY ) ; _events . ScheduleEvent ( EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY , 15s , 20s ) ; break ; case EVENT_LUMBERING_ABOMINATION_CLEAVE : DoCastVictim ( SPELL_CLEAVE ) ; _events . ScheduleEvent ( EVENT_LUMBERING_ABOMINATION_CLEAVE , 7s , 9s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_lumbering_abominationAI > ( creature ) ; } } ; enum QuelDelarUther { ACTION_UTHER_START_SCREAM = 1 , ACTION_UTHER_OUTRO = 2 , EVENT_UTHER_1 = 1 , EVENT_UTHER_2 = 2 , EVENT_UTHER_3 = 3 , EVENT_UTHER_4 = 4 , EVENT_UTHER_5 = 5 , EVENT_UTHER_6 = 6 , EVENT_UTHER_7 = 7 , EVENT_UTHER_8 = 8 , EVENT_UTHER_9 = 9 , EVENT_UTHER_10 = 10 , EVENT_UTHER_11 = 11 , EVENT_UTHER_FACING = 12 , EVENT_UTHER_KNEEL = 13 , SAY_UTHER_QUEL_DELAR_1 = 16 , SAY_UTHER_QUEL_DELAR_2 = 17 , SAY_UTHER_QUEL_DELAR_3 = 18 , SAY_UTHER_QUEL_DELAR_4 = 19 , SAY_UTHER_QUEL_DELAR_5 = 20 , SAY_UTHER_QUEL_DELAR_6 = 21 , SPELL_ESSENCE_OF_CAPTURED_1 = 73036 } ; enum QuelDelarSword { SPELL_WHIRLWIND_VISUAL = 70300 , SPELL_HEROIC_STRIKE = 29426 , SPELL_WHIRLWIND = 67716 , SPELL_BLADESTORM = 67541 , NPC_QUEL_DELAR = 37158 , POINT_TAKE_OFF = 1 , EVENT_QUEL_DELAR_INIT = 1 , EVENT_QUEL_DELAR_FLIGHT_INIT = 2 , EVENT_QUEL_DELAR_FLIGHT = 3 , EVENT_QUEL_DELAR_LAND = 4 , EVENT_QUEL_DELAR_FIGHT = 5 , EVENT_QUEL_DELAR_BLADESTORM = 6 , EVENT_QUEL_DELAR_HEROIC_STRIKE = 7 , EVENT_QUEL_DELAR_WHIRLWIND = 8 , SAY_QUEL_DELAR_SWORD = 0 } ; enum QuelDelarMisc { SAY_FROSTMOURNE_BUNNY = 0 , SPELL_QUEL_DELAR_WILL = 70698 } ; Position const QuelDelarCenterPos = { 5309.259f , 2006.390f , 718.046f , 0.0f } ; Position const QuelDelarSummonPos = { 5298.473f , 1994.852f , 709.424f , 3.979351f } ; Position const QuelDelarMovement [ ] = { { 5292.870f , 1998.950f , 718.046f , 0.0f } , { 5295.819f , 1991.912f , 707.707f , 0.0f } , { 5295.301f , 1989.782f , 708.696f , 0.0f } } ; Position const UtherQuelDelarMovement [ ] = { { 5336.830f , 1981.700f , 709.319f , 0.0f } , { 5314.350f , 1993.440f , 707.726f , 0.0f } } ; class npc_uther_quel_delar : public CreatureScript { public : npc_uther_quel_delar ( ) : CreatureScript ( " npc _ uther _ quel _ delar " ) { } struct npc_uther_quel_delarAI : public ScriptedAI { npc_uther_quel_delarAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; } void Reset ( ) override { if ( _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) != IN_PROGRESS && _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) != SPECIAL ) return ; _events . Reset ( ) ; _events . ScheduleEvent ( EVENT_UTHER_1 , 1 ) ; } void DamageTaken ( Unit * , uint32 & damage ) override { if ( damage >= me -> GetHealth ( ) ) damage = me -> GetHealth ( ) - 1 ; } void DoAction ( int32 action ) override { switch ( action ) { case ACTION_UTHER_START_SCREAM : _instance -> SetData ( DATA_QUEL_DELAR_EVENT , SPECIAL ) ; _events . ScheduleEvent ( EVENT_UTHER_2 , 0 ) ; break ; case ACTION_UTHER_OUTRO : _events . ScheduleEvent ( EVENT_UTHER_6 , 0 ) ; break ; default : break ; } } void MovementInform ( uint32 , uint32 pointId ) override { switch ( pointId ) { case 1 : _events . ScheduleEvent ( EVENT_UTHER_FACING , 1s ) ; break ; default : break ; } } void UpdateAI ( uint32 diff ) override { if ( _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) != IN_PROGRESS && _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) != SPECIAL ) return ; _events . Update ( diff ) ; while ( uint32 eventId = _events . ExecuteEvent ( ) ) { switch ( eventId ) { case EVENT_UTHER_1 : Talk ( SAY_UTHER_QUEL_DELAR_1 ) ; break ; case EVENT_UTHER_2 : if ( Creature * bunny = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FROSTMOURNE_ALTAR_BUNNY ) ) ) if ( Unit * target = ObjectAccessor :: GetPlayer ( * me , _instance -> GetGuidData ( DATA_QUEL_DELAR_INVOKER ) ) ) bunny -> CastSpell ( target , SPELL_QUEL_DELAR_WILL , true ) ; _events . ScheduleEvent ( EVENT_UTHER_3 , 2000 ) ; break ; case EVENT_UTHER_3 : me -> SummonCreature ( NPC_QUEL_DELAR , QuelDelarSummonPos ) ; _events . ScheduleEvent ( EVENT_UTHER_4 , 2000 ) ; break ; case EVENT_UTHER_4 : Talk ( SAY_UTHER_QUEL_DELAR_2 ) ; _events . ScheduleEvent ( EVENT_UTHER_5 , 8000 ) ; break ; case EVENT_UTHER_5 : me -> GetMotionMaster ( ) -> MovePoint ( 1 , UtherQuelDelarMovement [ 0 ] ) ; break ; case EVENT_UTHER_6 : me -> SetWalk ( true ) ; me -> GetMotionMaster ( ) -> MovePoint ( 0 , UtherQuelDelarMovement [ 1 ] ) ; _events . ScheduleEvent ( EVENT_UTHER_7 , 5000 ) ; break ; case EVENT_UTHER_7 : Talk ( SAY_UTHER_QUEL_DELAR_3 ) ; _events . ScheduleEvent ( EVENT_UTHER_8 , 12000 ) ; break ; case EVENT_UTHER_8 : Talk ( SAY_UTHER_QUEL_DELAR_4 ) ; _events . ScheduleEvent ( EVENT_UTHER_9 , 7000 ) ; break ; case EVENT_UTHER_9 : Talk ( SAY_UTHER_QUEL_DELAR_5 ) ; _events . ScheduleEvent ( EVENT_UTHER_10 , 10000 ) ; break ; case EVENT_UTHER_10 : Talk ( SAY_UTHER_QUEL_DELAR_6 ) ; _events . ScheduleEvent ( EVENT_UTHER_11 , 5000 ) ; break ; case EVENT_UTHER_11 : DoCast ( me , SPELL_ESSENCE_OF_CAPTURED_1 , true ) ; me -> DespawnOrUnsummon ( 3000 ) ; _instance -> SetData ( DATA_QUEL_DELAR_EVENT , DONE ) ; break ; case EVENT_UTHER_FACING : if ( Creature * bunny = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FROSTMOURNE_ALTAR_BUNNY ) ) ) me -> SetFacingToObject ( bunny ) ; _events . ScheduleEvent ( EVENT_UTHER_KNEEL , 1s ) ; break ; case EVENT_UTHER_KNEEL : me -> HandleEmoteCommand ( EMOTE_STATE_KNEEL ) ; break ; default : break ; } } } private : EventMap _events ; InstanceScript * _instance ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_uther_quel_delarAI > ( creature ) ; } } ; class npc_quel_delar_sword : public CreatureScript { public : npc_quel_delar_sword ( ) : CreatureScript ( " npc _ quel _ delar _ sword " ) { } struct npc_quel_delar_swordAI : public ScriptedAI { npc_quel_delar_swordAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; me -> SetDisplayId ( me -> GetCreatureTemplate ( ) -> Modelid2 ) ; _intro = true ; } void Reset ( ) override { _events . Reset ( ) ; me -> SetSpeedRate ( MOVE_FLIGHT , 4.5f ) ; DoCast ( SPELL_WHIRLWIND_VISUAL ) ; if ( _intro ) _events . ScheduleEvent ( EVENT_QUEL_DELAR_INIT , 0 ) ; else me -> SetImmuneToAll ( false ) ; } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_QUEL_DELAR_HEROIC_STRIKE , 4s ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_BLADESTORM , 6s ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_WHIRLWIND , 6s ) ; } void JustDied ( Unit * ) override { if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_UTHER_QUEL_DELAR ) ) ) uther -> AI ( ) -> DoAction ( ACTION_UTHER_OUTRO ) ; } void MovementInform ( uint32 type , uint32 pointId ) override { if ( type != EFFECT_MOTION_TYPE ) return ; switch ( pointId ) { case POINT_TAKE_OFF : _events . ScheduleEvent ( EVENT_QUEL_DELAR_FLIGHT , 0 ) ; break ; default : break ; } } void UpdateAI ( uint32 diff ) override { _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; if ( ! UpdateVictim ( ) ) { while ( uint32 eventId = _events . ExecuteEvent ( ) ) { switch ( eventId ) { case EVENT_QUEL_DELAR_INIT : if ( Creature * bunny = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FROSTMOURNE_ALTAR_BUNNY ) ) ) bunny -> AI ( ) -> Talk ( SAY_FROSTMOURNE_BUNNY ) ; _intro = false ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_FLIGHT_INIT , 2500ms ) ; break ; case EVENT_QUEL_DELAR_FLIGHT_INIT : me -> GetMotionMaster ( ) -> MoveTakeoff ( POINT_TAKE_OFF , QuelDelarMovement [ 0 ] ) ; break ; case EVENT_QUEL_DELAR_FLIGHT : { me -> GetMotionMaster ( ) -> MoveCirclePath ( QuelDelarCenterPos . GetPositionX ( ) , QuelDelarCenterPos . GetPositionY ( ) , 718.046f , 18.0f , true , 16 ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_LAND , 15s ) ; break ; } case EVENT_QUEL_DELAR_LAND : me -> StopMoving ( ) ; me -> GetMotionMaster ( ) -> Clear ( ) ; me -> GetMotionMaster ( ) -> MoveLand ( 0 , QuelDelarMovement [ 1 ] ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_FIGHT , 6s ) ; break ; case EVENT_QUEL_DELAR_FIGHT : Talk ( SAY_QUEL_DELAR_SWORD ) ; me -> GetMotionMaster ( ) -> MovePoint ( 0 , QuelDelarMovement [ 2 ] ) ; me -> SetImmuneToAll ( false ) ; break ; default : break ; } } } else { while ( uint32 eventId = _events . ExecuteEvent ( ) ) { switch ( eventId ) { case EVENT_QUEL_DELAR_BLADESTORM : DoCast ( me , SPELL_BLADESTORM ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_BLADESTORM , 10s ) ; break ; case EVENT_QUEL_DELAR_HEROIC_STRIKE : DoCastVictim ( SPELL_HEROIC_STRIKE ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_HEROIC_STRIKE , 6s ) ; break ; case EVENT_QUEL_DELAR_WHIRLWIND : DoCastAOE ( SPELL_WHIRLWIND ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_WHIRLWIND , 1s ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } } private : EventMap _events ; InstanceScript * _instance ; bool _intro ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_quel_delar_swordAI > ( creature ) ; } } ; class at_hor_uther_quel_delar_start : public AreaTriggerScript { public : at_hor_uther_quel_delar_start ( ) : AreaTriggerScript ( " at _ hor _ uther _ quel _ delar _ start " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) == IN_PROGRESS ) if ( Creature * uther = ObjectAccessor :: GetCreature ( * player , _instance -> GetGuidData ( DATA_UTHER_QUEL_DELAR ) ) ) uther -> AI ( ) -> DoAction ( ACTION_UTHER_START_SCREAM ) ; return true ; } } ; class spell_hor_start_halls_of_reflection_quest_ae : public SpellScriptLoader { public : spell_hor_start_halls_of_reflection_quest_ae ( ) : SpellScriptLoader ( " spell _ hor _ start _ halls _ of _ reflection _ quest _ ae " ) { } class spell_hor_start_halls_of_reflection_quest_ae_SpellScript : public SpellScript { PrepareSpellScript ( spell_hor_start_halls_of_reflection_quest_ae_SpellScript ) ; void StartQuests ( SpellEffIndex ) { if ( Player * target = GetHitPlayer ( ) ) { if ( target -> GetTeam ( ) == ALLIANCE ) target -> CastSpell ( target , SPELL_START_HALLS_OF_REFLECTION_QUEST_A , true ) ; else target -> CastSpell ( target , SPELL_START_HALLS_OF_REFLECTION_QUEST_H , true ) ; } } void Register ( ) override { OnEffectHitTarget += SpellEffectFn ( spell_hor_start_halls_of_reflection_quest_ae_SpellScript :: StartQuests , EFFECT_0 , SPELL_EFFECT_SCRIPT_EFFECT ) ; } } ; SpellScript * GetSpellScript ( ) const override { return new spell_hor_start_halls_of_reflection_quest_ae_SpellScript ( ) ; } } ; class spell_hor_evasion : public SpellScriptLoader { public : spell_hor_evasion ( ) : SpellScriptLoader ( " spell _ hor _ evasion " ) { } class spell_hor_evasion_SpellScript : public SpellScript { PrepareSpellScript ( spell_hor_evasion_SpellScript ) ; bool Load ( ) override { return GetCaster ( ) -> GetTypeId ( ) == TYPEID_UNIT ; } void SetDest ( SpellDestination & dest ) { WorldObject * target = GetExplTargetWorldObject ( ) ; Position pos ( * target ) ; Position home = GetCaster ( ) -> ToCreature ( ) -> GetHomePosition ( ) ; if ( pos . IsInDist2d ( & home , 15.0f ) ) return ; float angle = pos . GetAbsoluteAngle ( & home ) ; float dist = GetSpellInfo ( ) -> Effects [ EFFECT_0 ] . CalcRadius ( GetCaster ( ) ) ; target -> MovePosition ( pos , dist , angle ) ; dest . Relocate ( pos ) ; } void Register ( ) override { OnDestinationTargetSelect += SpellDestinationTargetSelectFn ( spell_hor_evasion_SpellScript :: SetDest , EFFECT_0 , TARGET_DEST_TARGET_RADIUS ) ; } } ; SpellScript * GetSpellScript ( ) const override { return new spell_hor_evasion_SpellScript ( ) ; } } ; class spell_hor_gunship_cannon_fire : public SpellScriptLoader { public : spell_hor_gunship_cannon_fire ( ) : SpellScriptLoader ( " spell _ hor _ gunship _ cannon _ fire " ) { } class spell_hor_gunship_cannon_fire_AuraScript : public AuraScript { PrepareAuraScript ( spell_hor_gunship_cannon_fire_AuraScript ) ; void HandlePeriodic ( AuraEffect const * ) { if ( ! urand ( 0 , 2 ) ) { if ( GetTarget ( ) -> GetEntry ( ) == NPC_GUNSHIP_CANNON_HORDE ) GetTarget ( ) -> CastSpell ( nullptr , SPELL_GUNSHIP_CANNON_FIRE_MISSILE_HORDE , true ) ; else GetTarget ( ) -> CastSpell ( nullptr , SPELL_GUNSHIP_CANNON_FIRE_MISSILE_ALLIANCE , true ) ; } } void Register ( ) override { OnEffectPeriodic += AuraEffectPeriodicFn ( spell_hor_gunship_cannon_fire_AuraScript :: HandlePeriodic , EFFECT_0 , SPELL_AURA_PERIODIC_TRIGGER_SPELL ) ; } } ; AuraScript * GetAuraScript ( ) const override { return new spell_hor_gunship_cannon_fire_AuraScript ( ) ; } } ; class spell_hor_quel_delars_will : public SpellScript { PrepareSpellScript ( spell_hor_quel_delars_will ) ; bool Validate ( SpellInfo const * spellInfo ) override { return ValidateSpellInfo ( { spellInfo -> Effects [ EFFECT_0 ] . TriggerSpell } ) ; } void HandleReagent ( SpellEffIndex effIndex ) { PreventHitDefaultEffect ( effIndex ) ; GetHitUnit ( ) -> CastSpell ( GetCaster ( ) , GetSpellInfo ( ) -> Effects [ effIndex ] . TriggerSpell , TriggerCastFlags ( TRIGGERED_FULL_MASK & ~ TRIGGERED_IGNORE_POWER_AND_REAGENT_COST ) ) ; } void Register ( ) override { OnEffectHitTarget += SpellEffectFn ( spell_hor_quel_delars_will :: HandleReagent , EFFECT_0 , SPELL_EFFECT_FORCE_CAST ) ; } } ; void AddSC_halls_of_reflection ( ) { new at_hor_intro_start ( ) ; new at_hor_waves_restarter ( ) ; new at_hor_impenetrable_door ( ) ; new at_hor_shadow_throne ( ) ; new at_hor_uther_quel_delar_start ( ) ; new npc_jaina_or_sylvanas_intro_hor ( ) ; new npc_jaina_or_sylvanas_escape_hor ( ) ; new npc_the_lich_king_escape_hor ( ) ; new npc_ghostly_priest ( ) ; new npc_phantom_mage ( ) ; new npc_phantom_hallucination ( ) ; new npc_shadowy_mercenary ( ) ; new npc_spectral_footman ( ) ; new npc_tortured_rifleman ( ) ; new npc_frostsworn_general ( ) ; new npc_spiritual_reflection ( ) ; new npc_raging_ghoul ( ) ; new npc_risen_witch_doctor ( ) ; new npc_lumbering_abomination ( ) ; new npc_uther_quel_delar ( ) ; new npc_quel_delar_sword ( ) ; new spell_hor_start_halls_of_reflection_quest_ae ( ) ; new spell_hor_evasion ( ) ; new spell_hor_gunship_cannon_fire ( ) ; RegisterSpellScript ( spell_hor_quel_delars_will ) ; } </DOCUMENT>
<DOCUMENT_ID="naucoin/CTK/tree/master/Libs/Widgets/Testing/Cpp/ctkExampleUseOfWorkflowWidgetUsingSignalsAndSlots.cpp"> # include < QApplication > # include < QTimer > # include " ctkWorkflow . h " # include " ctkWorkflowTabWidget . h " # include " ctkWorkflowWidgetStep . h " # include " ctkWorkflowGroupBox . h " # include " ctkExampleWorkflowWidgetStepUsingSignalsAndSlots . h " # include < cstdlib > # include < iostream > int ctkExampleUseOfWorkflowWidgetUsingSignalsAndSlots ( int argc , char * argv [ ] ) { QApplication app ( argc , argv ) ; bool hideWidgets = false ; ctkWorkflow * workflow = new ctkWorkflow ; ctkWorkflowTabWidget * workflowWidget = new ctkWorkflowTabWidget ; workflowWidget -> setWorkflow ( workflow ) ; ctkWorkflowGroupBox * groupBox = workflowWidget -> workflowGroupBox ( ) ; groupBox -> setPreText ( " I ▁ am ▁ some ▁ pre - text " ) ; groupBox -> setPostText ( " I ▁ am ▁ some ▁ post - text " ) ; groupBox -> setHideWidgetsOfNonCurrentSteps ( hideWidgets ) ; ctkWorkflowWidgetStep * testStep1 = new ctkWorkflowWidgetStep ( " Step ▁ 1" ) ; testStep1 -> setName ( " Step ▁ 1" ) ; testStep1 -> setDescription ( " I ▁ am ▁ in ▁ step ▁ 1" ) ; workflowWidget -> associateStepWithLabel ( testStep1 , " name ▁ 1" ) ; ctkWorkflowWidgetStep * testStep2 = new ctkWorkflowWidgetStep ( " Step ▁ 2" ) ; testStep2 -> setName ( " Step ▁ 2" ) ; testStep2 -> setDescription ( " I ▁ am ▁ in ▁ step ▁ 2" ) ; workflowWidget -> associateStepWithLabel ( testStep2 , " name ▁ 2" ) ; ctkWorkflowWidgetStep * testStep3 = new ctkWorkflowWidgetStep ( " Step ▁ 3" ) ; testStep3 -> setName ( " Step ▁ 3" ) ; testStep3 -> setDescription ( " I ▁ am ▁ in ▁ step ▁ 3" ) ; workflowWidget -> associateStepWithPage ( testStep3 , 1 , " name ▁ 3" ) ; workflow -> addTransition ( testStep1 , testStep2 ) ; workflow -> addTransition ( testStep2 , testStep3 ) ; ctkExampleWorkflowWidgetStepUsingSignalsAndSlots * qObject1 = new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots ( testStep1 ) ; ctkExampleWorkflowWidgetStepUsingSignalsAndSlots * qObject2 = new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots ( testStep2 ) ; ctkExampleWorkflowWidgetStepUsingSignalsAndSlots * qObject3 = new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots ( testStep3 ) ; qObject1 -> setWidget ( testStep1 -> stepArea ( ) ) ; qObject2 -> setWidget ( testStep2 -> stepArea ( ) ) ; qObject3 -> setWidget ( testStep3 -> stepArea ( ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeValidateCommand ( QString ) ) , qObject1 , SLOT ( validate ( QString ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeValidateCommand ( QString ) ) , qObject2 , SLOT ( validate ( QString ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeValidateCommand ( QString ) ) , qObject3 , SLOT ( validate ( QString ) ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnEntryCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject1 , SLOT ( onEntry ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnEntryCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject2 , SLOT ( onEntry ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnEntryCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject3 , SLOT ( onEntry ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnExitCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject1 , SLOT ( onExit ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnExitCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject2 , SLOT ( onExit ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnExitCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject3 , SLOT ( onExit ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeCreateUserInterfaceCommand ( ) ) , qObject1 , SLOT ( createUserInterface ( ) ) ) ; QObject :: connect ( qObject1 , SIGNAL ( createUserInterfaceComplete ( ) ) , testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( showUserInterfaceComplete ( ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeCreateUserInterfaceCommand ( ) ) , qObject2 , SLOT ( createUserInterface ( ) ) ) ; QObject :: connect ( qObject2 , SIGNAL ( createUserInterfaceComplete ( ) ) , testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( showUserInterfaceComplete ( ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeCreateUserInterfaceCommand ( ) ) , qObject3 , SLOT ( createUserInterface ( ) ) ) ; QObject :: connect ( qObject3 , SIGNAL ( createUserInterfaceComplete ( ) ) , testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( showUserInterfaceComplete ( ) ) ) ; testStep1 -> setHasValidateCommand ( 1 ) ; testStep1 -> setHasOnEntryCommand ( 1 ) ; testStep1 -> setHasOnExitCommand ( 1 ) ; testStep1 -> setHasCreateUserInterfaceCommand ( 1 ) ; testStep2 -> setHasValidateCommand ( 1 ) ; testStep2 -> setHasOnEntryCommand ( 1 ) ; testStep2 -> setHasOnExitCommand ( 1 ) ; testStep2 -> setHasCreateUserInterfaceCommand ( 1 ) ; testStep3 -> setHasValidateCommand ( 1 ) ; testStep3 -> setHasOnEntryCommand ( 1 ) ; testStep3 -> setHasOnExitCommand ( 1 ) ; testStep3 -> setHasCreateUserInterfaceCommand ( 1 ) ; workflow -> setInitialStep ( testStep1 ) ; workflow -> start ( ) ; workflowWidget -> show ( ) ; QTimer :: singleShot ( 500 , & app , SLOT ( quit ( ) ) ) ; app . exec ( ) ; workflow -> stop ( ) ; QTimer :: singleShot ( 100 , & app , SLOT ( quit ( ) ) ) ; app . exec ( ) ; delete workflowWidget ; return EXIT_SUCCESS ; } </DOCUMENT>
<DOCUMENT_ID="kingvuplus/enigma2/tree/master/lib/gui/einputstring.cpp"> # include < lib / gui / einputstring . h > DEFINE_REF ( eInputContentString ) ; eInputContentString :: eInputContentString ( ) { m_string = " bla " ; m_cursor = 0 ; m_input = 0 ; m_len = m_string . size ( ) ; } void eInputContentString :: getDisplay ( std :: string & res , int & cursor ) { res = m_string ; cursor = m_cursor ; } void eInputContentString :: moveCursor ( int dir ) { int old_cursor = m_cursor ; switch ( dir ) { case dirLeft : -- m_cursor ; break ; case dirRight : ++ m_cursor ; break ; case dirHome : m_cursor = 0 ; break ; case dirEnd : m_cursor = m_len ; break ; } if ( m_cursor < 0 ) m_cursor = 0 ; if ( m_cursor > m_len ) m_cursor = m_len ; if ( m_cursor != old_cursor ) if ( m_input ) m_input -> invalidate ( ) ; } int eInputContentString :: haveKey ( int code , int overwrite ) { int have_char = - 1 ; if ( code >= 0x8020 ) have_char = code & ~ 0x8000 ; if ( have_char != - 1 ) { if ( overwrite && m_cursor < m_len ) m_string [ m_cursor ] = have_char ; else { m_string . insert ( m_cursor , 1 , have_char ) ; ++ m_len ; } m_cursor ++ ; ASSERT ( m_cursor <= m_len ) ; if ( m_input ) m_input -> invalidate ( ) ; return 1 ; } return 0 ; } void eInputContentString :: deleteChar ( int dir ) { if ( dir == deleteForward ) { eDebug ( " forward " ) ; if ( m_cursor != m_len ) ++ m_cursor ; else return ; } if ( ! m_cursor ) return ; if ( ! m_len ) return ; m_string . erase ( m_cursor - 1 , m_cursor ) ; m_len -- ; m_cursor -- ; if ( m_input ) m_input -> invalidate ( ) ; } int eInputContentString :: isValid ( ) { return 1 ; } void eInputContentString :: validate ( ) { } void eInputContentString :: setText ( const std :: string & str ) { m_string = str ; m_len = m_string . size ( ) ; if ( m_cursor > m_len ) m_cursor = m_len ; if ( m_input ) m_input -> invalidate ( ) ; } std :: string eInputContentString :: getText ( ) { return m_string ; } </DOCUMENT>
<DOCUMENT_ID="ThomasXBMC/XCSoar/tree/master/src/Engine/Task/Computer/DistanceStatComputer.cpp"> # include " DistanceStatComputer . hpp " # include " Task / Stats / DistanceStat . hpp " void DistanceStatComputer :: CalcSpeed ( DistanceStat & data , fixed time ) { if ( positive ( time ) && data . IsDefined ( ) ) data . speed = data . GetDistance ( ) / time ; else data . speed = fixed ( 0 ) ; } </DOCUMENT>
<DOCUMENT_ID="RazZziel/sc_pong/tree/master/src/scfont.cpp"> # include < stdlib . h > # include < string . h > # include " SDL / SDL . h " # include " SDL / SDL _ image . h " # include " scfont . h " ScFont * ScLoadFont ( const char * filename ) { ScFont * font = ( ScFont * ) malloc ( sizeof ( ScFont ) ) ; FILE * file = fopen ( filename , " r " ) ; fread ( ( void * ) & font -> header , sizeof ( ScFontHeader ) , 1 , file ) ; int n_offsets = font -> header . highIndex - font -> header . lowIndex ; Uint32 * offsets = ( Uint32 * ) malloc ( sizeof ( Uint32 ) * ( n_offsets + 1 ) ) ; fseek ( file , sizeof ( ScFontHeader ) , SEEK_SET ) ; fread ( ( void * ) offsets , sizeof ( Uint32 ) , n_offsets , file ) ; fseek ( file , 0 , SEEK_END ) ; offsets [ n_offsets ] = ftell ( file ) ; font -> letters = ( ScLetter * ) malloc ( sizeof ( ScLetter ) * ( n_offsets + 1 ) ) ; for ( int i = 1 ; i <= n_offsets ; i ++ ) { if ( offsets [ i - 1 ] ) { fseek ( file , offsets [ i - 1 ] , SEEK_SET ) ; fread ( ( void * ) & font -> letters [ i ] . header , sizeof ( ScLetterHeader ) , 1 , file ) ; int next_offset = offsets [ i ] ; for ( int o = 0 ; ! next_offset ; o ++ ) { next_offset = offsets [ i + o ] ; } font -> letters [ i ] . n_pixels = next_offset - ( offsets [ i - 1 ] + sizeof ( ScLetterHeader ) ) - 1 ; font -> letters [ i ] . pixels = ( Uint8 * ) malloc ( sizeof ( Uint8 ) * font -> letters [ i ] . n_pixels ) ; fseek ( file , ( offsets [ i - 1 ] + sizeof ( ScLetterHeader ) ) , SEEK_SET ) ; fread ( ( void * ) font -> letters [ i ] . pixels , sizeof ( Uint8 ) , font -> letters [ i ] . n_pixels , file ) ; } else font -> letters [ i ] . n_pixels = - 1 ; } font -> letters [ 0 ] . n_pixels = 0 ; font -> letters [ 0 ] . header . x = 0 ; font -> letters [ 0 ] . header . y = 0 ; font -> letters [ 0 ] . header . h = 0 ; font -> letters [ 0 ] . header . w = font -> header . maxWidth / 2 ; free ( offsets ) ; fclose ( file ) ; return font ; } ScPalette * ScLoadPalette ( const char * filename ) { ScPalette * palette = ( ScPalette * ) malloc ( sizeof ( ScPalette ) ) ; SDL_Surface * s_palette ; if ( ( s_palette = SDL_DisplayFormat ( IMG_Load ( filename ) ) ) == NULL ) { fprintf ( stderr , " ERROR : ▁ Cannot ▁ load ▁ palette ▁ ' % s ' " , filename ) ; exit ( 1 ) ; } memcpy ( * palette , s_palette -> pixels , s_palette -> format -> BytesPerPixel * s_palette -> w ) ; SDL_FreeSurface ( s_palette ) ; return palette ; } SDL_Surface * ScRenderChar ( unsigned const char car , ScFont * font , ScColor * color ) { SDL_Surface * screen = SDL_GetVideoSurface ( ) ; int index = car - font -> header . lowIndex ; if ( ( car < font -> header . lowIndex ) || ( car > font -> header . highIndex ) || ( font -> letters [ index ] . n_pixels < 0 ) ) { fprintf ( stderr , " ERROR ▁ ( ScRenderChar ) : ▁ Invalid ▁ character ▁ index ▁ % d \n " , car ) ; return NULL ; } SDL_Surface * letter = SDL_CreateRGBSurface ( SDL_SWSURFACE , font -> letters [ index ] . header . w , font -> letters [ index ] . header . h , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; if ( font -> letters [ index ] . header . h > 0 ) { char * pixels = ( char * ) letter -> pixels - letter -> format -> BytesPerPixel ; for ( int p = 0 ; p < font -> letters [ index ] . n_pixels ; p ++ ) { Uint8 skip = font -> letters [ index ] . pixels [ p ] >> 3 ; Uint8 gamma = font -> letters [ index ] . pixels [ p ] & 7 ; pixels += skip * letter -> format -> BytesPerPixel + letter -> format -> BytesPerPixel ; memcpy ( pixels , * color + gamma , letter -> format -> BytesPerPixel ) ; } SDL_SetColorKey ( letter , SDL_SRCCOLORKEY | SDL_RLEACCEL , 0 ) ; } SDL_Surface * final_letter = SDL_CreateRGBSurface ( SDL_SWSURFACE , font -> letters [ index ] . header . w , font -> header . maxHeight , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; SDL_Rect offset = { font -> letters [ index ] . header . x , font -> letters [ index ] . header . y , 0 , 0 } ; SDL_BlitSurface ( letter , NULL , final_letter , & offset ) ; SDL_FreeSurface ( letter ) ; SDL_SetColorKey ( final_letter , SDL_SRCCOLORKEY | SDL_RLEACCEL , 0 ) ; return final_letter ; } int calculateWidth ( const unsigned char * text , ScFont * font , char delim ) { int width = 0 ; while ( * text ) { if ( * text != delim ) width += font -> letters [ * text - font -> header . lowIndex ] . header . w + 1 ; text ++ ; } return width - 1 ; } SDL_Surface * ScRenderText ( const char * text , ScFont * font , ScColor * color , ScColor * color_hi , char delim ) { SDL_Surface * screen = SDL_GetVideoSurface ( ) ; SDL_Surface * s_text = SDL_CreateRGBSurface ( SDL_SWSURFACE , calculateWidth ( ( unsigned char * ) text , font , delim ) , font -> header . maxHeight , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; SDL_SetColorKey ( s_text , SDL_SRCCOLORKEY | SDL_RLEACCEL , 0 ) ; SDL_Surface * s_char ; SDL_Rect offset = { 0 , 0 , 0 , 0 } ; if ( color_hi ) { ScColor * actual_color = color ; while ( * text ) { if ( * text == delim ) { if ( actual_color == color ) actual_color = color_hi ; else actual_color = color ; } else { if ( ( s_char = ScRenderChar ( * text , font , actual_color ) ) ) { SDL_BlitSurface ( s_char , NULL , s_text , & offset ) ; offset . x += s_char -> w + 1 ; SDL_FreeSurface ( s_char ) ; } } text ++ ; } } else { while ( * text ) { if ( * text != delim ) { if ( ( s_char = ScRenderChar ( * text , font , color ) ) ) { SDL_BlitSurface ( s_char , NULL , s_text , & offset ) ; offset . x += s_char -> w + 1 ; SDL_FreeSurface ( s_char ) ; } } text ++ ; } } return s_text ; } ScColor * ScGetColor ( const ScPalette * palette , int index ) { ScColor * color = ( ScColor * ) malloc ( sizeof ( ScColor ) ) ; memcpy ( * color , * palette + ( index * MAX_GAMMA ) , sizeof ( ScColor ) ) ; return color ; } void ScTestFont ( ScFont * font , ScPalette * palette ) { # define TEST_SDL SDL_Surface * screen = SDL_GetVideoSurface ( ) ; SDL_FillRect ( screen , NULL , SDL_MapRGB ( SDL_GetVideoSurface ( ) -> format , 255 , 255 , 255 ) ) ; SDL_Flip ( screen ) ; # ifdef TEST_SDL SDL_Rect offset = { 10 , 10 , 0 , 0 } ; SDL_BlitSurface ( ScRenderText ( " El ▁ veloz ▁ murci � ago ▁ hind " , font , ScGetColor ( palette , 1 ) ) , NULL , screen , & offset ) ; offset . y += font -> header . maxHeight + 2 ; SDL_BlitSurface ( ScRenderText ( " Juiporentenderlas " , font , ScGetColor ( palette , 5 ) ) , NULL , screen , & offset ) ; offset . y += font -> header . maxHeight + 2 ; SDL_BlitSurface ( ScRenderText ( " _ S _ ingle ▁ Player " , font , ScGetColor ( palette , 1 ) , ScGetColor ( palette , 2 ) , ' _ ' ) , NULL , screen , & offset ) ; offset . y += font -> header . maxHeight + 2 ; # endif for ( int i = font -> header . lowIndex ; i <= font -> header . highIndex ; i ++ ) { # ifdef TEST_SDL SDL_Surface * s_char = ScRenderChar ( i , font , ScGetColor ( palette , 2 ) ) ; if ( s_char ) { SDL_BlitSurface ( s_char , NULL , screen , & offset ) ; SDL_FreeSurface ( s_char ) ; } if ( ( offset . x += font -> header . maxWidth + 2 ) > ( screen -> w - font -> header . maxWidth - 10 ) ) { offset . x = 10 ; offset . y += font -> header . maxHeight + 2 ; } # else int index = i - font -> header . lowIndex ; int x = 1 ; for ( int p = 0 ; p < font -> letters [ index ] . n_pixels ; p ++ ) printf ( " % d ▁ " , ( font -> letters [ i ] . pixels [ p ] >> 3 ) ) ; printf ( " \n " ) ; for ( int p = 0 ; p < font -> letters [ index ] . n_pixels ; p ++ ) { Uint8 skip = font -> letters [ index ] . pixels [ p ] >> 3 ; Uint8 color = font -> letters [ index ] . pixels [ p ] & 7 ; for ( int j = 0 ; j < skip ; j ++ ) { printf ( " ▁ " ) ; if ( x ++ == font -> letters [ index ] . header . w ) { printf ( " \n " ) ; x = 1 ; } } printf ( " % d " , color ) ; if ( x ++ == font -> letters [ index ] . header . w ) { printf ( " \n " ) ; x = 1 ; } } printf ( " \n test ▁ end \n " ) ; getchar ( ) ; # endif } SDL_Flip ( screen ) ; * screen = * SDL_CreateRGBSurface ( SDL_SWSURFACE , screen -> w , screen -> h , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; getchar ( ) ; } </DOCUMENT>
<DOCUMENT_ID="zeliard/aws-sdk-cpp/tree/master/aws-cpp-sdk-iam/source/model/ListGroupsRequest.cpp"> # include < aws / iam / model / ListGroupsRequest . h > # include < aws / core / utils / StringUtils . h > # include < aws / core / utils / memory / stl / AWSStringStream . h > using namespace Aws :: IAM :: Model ; using namespace Aws :: Utils ; ListGroupsRequest :: ListGroupsRequest ( ) : m_pathPrefixHasBeenSet ( false ) , m_markerHasBeenSet ( false ) , m_maxItems ( 0 ) , m_maxItemsHasBeenSet ( false ) { } Aws :: String ListGroupsRequest :: SerializePayload ( ) const { Aws :: StringStream ss ; ss << " Action = ListGroups & " ; if ( m_pathPrefixHasBeenSet ) { ss << " PathPrefix = " << StringUtils :: URLEncode ( m_pathPrefix . c_str ( ) ) << " & " ; } if ( m_markerHasBeenSet ) { ss << " Marker = " << StringUtils :: URLEncode ( m_marker . c_str ( ) ) << " & " ; } if ( m_maxItemsHasBeenSet ) { ss << " MaxItems = " << m_maxItems << " & " ; } ss << " Version = 2010-05-08" ; return ss . str ( ) ; } </DOCUMENT>
<DOCUMENT_ID="Sumahitha/samples/tree/master/AllJoyn/Samples/BACnetAdapter/HeadlessAdapterApp/pch.cpp"> # include " pch . h " </DOCUMENT>
<DOCUMENT_ID="sofa-framework/sofa/tree/master/applications/plugins/SofaPython/PythonScriptController.cpp"> # include " PythonMacros . h " # include " PythonScriptController . h " # include < sofa / core / ObjectFactory . h > # include < sofa / helper / AdvancedTimer . h > using sofa :: helper :: AdvancedTimer ; using sofa :: core :: objectmodel :: Base ; using sofa :: simulation :: Node ; # include " Binding _ PythonScriptController . h " using sofa :: simulation :: PythonEnvironment ; # include " PythonScriptEvent . h " using sofa :: core :: objectmodel :: PythonScriptEvent ; # include < sofa / helper / system / FileMonitor . h > using sofa :: helper :: system :: FileMonitor ; using sofa :: helper :: system :: FileEventListener ; # include < sofa / core / objectmodel / IdleEvent . h > using sofa :: core :: objectmodel :: IdleEvent ; # include " PythonFactory . h " struct ActivableScopedAdvancedTimer { const char * message ; bool m_active ; Base * m_base ; ActivableScopedAdvancedTimer ( bool active , const char * message , Base * base ) : message ( message ) , m_active ( active ) , m_base ( base ) { if ( m_active ) AdvancedTimer :: stepBegin ( message , m_base ) ; } ~ ActivableScopedAdvancedTimer ( ) { if ( m_active ) AdvancedTimer :: stepEnd ( message , m_base ) ; } } ; namespace sofa { namespace component { namespace controller { class MyFileEventListener : public FileEventListener { PythonScriptController * m_controller ; public : MyFileEventListener ( PythonScriptController * psc ) { m_controller = psc ; } ~ MyFileEventListener ( ) override { } virtual void fileHasChanged ( const std :: string & filepath ) override { PythonEnvironment :: gil lock { __func__ } ; if ( ! m_controller -> scriptControllerInstance ( ) ) { m_controller -> doLoadScript ( ) ; } else { PythonEnvironment :: gil state { __func__ } ; std :: string file = filepath ; SP_CALL_FILEFUNC ( const_cast < char * > ( " onReimpAFile " ) , const_cast < char * > ( " s " ) , const_cast < char * > ( file . data ( ) ) ) ; m_controller -> refreshBinding ( ) ; } } } ; int PythonScriptControllerClass = core :: RegisterObject ( " A ▁ Sofa ▁ controller ▁ scripted ▁ in ▁ python " ) . add < PythonScriptController > ( ) ; PythonScriptController :: PythonScriptController ( ) : ScriptController ( ) , m_filename ( initData ( & m_filename , " filename " , " Python ▁ script ▁ filename " ) ) , m_classname ( initData ( & m_classname , " classname " , " Python ▁ class ▁ implemented ▁ in ▁ the ▁ script ▁ to ▁ instanciate ▁ for ▁ the ▁ controller " ) ) , m_variables ( initData ( & m_variables , " variables " , " Array ▁ of ▁ string ▁ variables ▁ ( equivalent ▁ to ▁ a ▁ c - like ▁ argv ) " ) ) , m_timingEnabled ( initData ( & m_timingEnabled , true , " timingEnabled " , " Set ▁ this ▁ attribute ▁ to ▁ true ▁ or ▁ false ▁ to ▁ activate / deactivate ▁ the ▁ gathering " " ▁ of ▁ timing ▁ statistics ▁ on ▁ the ▁ python ▁ execution ▁ time . ▁ Default ▁ value ▁ is ▁ set " " to ▁ true . " ) ) , m_doAutoReload ( initData ( & m_doAutoReload , false , " autoreload " , " Automatically ▁ reload ▁ the ▁ file ▁ when ▁ the ▁ source ▁ code ▁ is ▁ changed . ▁ " " Default ▁ value ▁ is ▁ set ▁ to ▁ false " ) ) , m_ScriptControllerClass ( nullptr ) , m_ScriptControllerInstance ( nullptr ) { m_filelistener = new MyFileEventListener ( this ) ; } PythonScriptController :: ~ PythonScriptController ( ) { if ( m_filelistener ) { FileMonitor :: removeListener ( m_filelistener ) ; delete m_filelistener ; } } void PythonScriptController :: setInstance ( PyObject * instance ) { PythonEnvironment :: gil lock ( __func__ ) ; if ( m_ScriptControllerInstance ) { Py_DECREF ( m_ScriptControllerInstance ) ; } m_ScriptControllerInstance = instance ; m_ScriptControllerClass = ( PyObject * ) instance -> ob_type ; Py_INCREF ( instance ) ; refreshBinding ( ) ; } void PythonScriptController :: refreshBinding ( ) { BIND_OBJECT_METHOD ( onLoaded ) BIND_OBJECT_METHOD ( createGraph ) BIND_OBJECT_METHOD ( initGraph ) BIND_OBJECT_METHOD ( bwdInitGraph ) BIND_OBJECT_METHOD ( onKeyPressed ) BIND_OBJECT_METHOD ( onKeyReleased ) BIND_OBJECT_METHOD ( onMouseMove ) BIND_OBJECT_METHOD ( onMouseButtonLeft ) BIND_OBJECT_METHOD ( onMouseButtonRight ) BIND_OBJECT_METHOD ( onMouseButtonMiddle ) BIND_OBJECT_METHOD ( onMouseWheel ) BIND_OBJECT_METHOD ( onBeginAnimationStep ) BIND_OBJECT_METHOD ( onEndAnimationStep ) BIND_OBJECT_METHOD ( storeResetState ) BIND_OBJECT_METHOD ( reset ) BIND_OBJECT_METHOD ( cleanup ) BIND_OBJECT_METHOD ( onGUIEvent ) BIND_OBJECT_METHOD ( onScriptEvent ) BIND_OBJECT_METHOD ( draw ) BIND_OBJECT_METHOD ( onIdle ) } bool PythonScriptController :: isDerivedFrom ( const std :: string & name , const std :: string & module ) { PythonEnvironment :: gil lock ( __func__ ) ; PyObject * moduleDict = PyModule_GetDict ( PyImport_AddModule ( module . c_str ( ) ) ) ; PyObject * controllerClass = PyDict_GetItemString ( moduleDict , name . c_str ( ) ) ; return 1 == PyObject_IsInstance ( m_ScriptControllerInstance , controllerClass ) ; } void PythonScriptController :: loadScript ( ) { PythonEnvironment :: gil lock ( __func__ ) ; if ( m_doAutoReload . getValue ( ) ) { FileMonitor :: addFile ( m_filename . getFullPath ( ) , m_filelistener ) ; } if ( m_filename . isSet ( ) && ! m_filename . getRelativePath ( ) . empty ( ) && ! PythonEnvironment :: runFile ( m_filename . getFullPath ( ) . c_str ( ) ) ) { msg_error ( ) << " ▁ load ▁ error ▁ ( file ▁ ' " << m_filename . getFullPath ( ) . c_str ( ) << " ' ▁ not ▁ parsable ) " ; return ; } PyObject * pDict = PyModule_GetDict ( PyImport_AddModule ( " _ _ main _ _ " ) ) ; m_ScriptControllerClass = PyDict_GetItemString ( pDict , m_classname . getValueString ( ) . c_str ( ) ) ; if ( ! m_ScriptControllerClass ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ not ▁ found ) . " ; return ; } if ( 1 != PyObject_IsSubclass ( m_ScriptControllerClass , ( PyObject * ) & SP_SOFAPYTYPEOBJECT ( PythonScriptController ) ) ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ does ▁ not ▁ inherit ▁ from ▁ ' Sofa . PythonScriptController ' ) . " ; return ; } m_ScriptControllerInstance = BuildPySPtr < Base > ( this , ( PyTypeObject * ) m_ScriptControllerClass ) ; if ( ! m_ScriptControllerInstance ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ instanciation ▁ error ) . " ; return ; } refreshBinding ( ) ; } void PythonScriptController :: doLoadScript ( ) { loadScript ( ) ; } void PythonScriptController :: script_onIdleEvent ( const IdleEvent * ) { FileMonitor :: updates ( 0 ) ; { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_onIdle ) ; } std :: cout . flush ( ) ; std :: cerr . flush ( ) ; } void PythonScriptController :: script_onLoaded ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onLoaded , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) } void PythonScriptController :: script_createGraph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_createGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) } void PythonScriptController :: script_initGraph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_initGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) } void PythonScriptController :: script_bwdInitGraph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_bwdInitGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) } bool PythonScriptController :: script_onKeyPressed ( const char c ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onKeyPressed " , this ) ; bool b = false ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEBOOLFUNC ( m_Func_onKeyPressed , " ( c ) " , c ) ; return b ; } bool PythonScriptController :: script_onKeyReleased ( const char c ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onKeyReleased " , this ) ; bool b = false ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEBOOLFUNC ( m_Func_onKeyReleased , " ( c ) " , c ) ; return b ; } void PythonScriptController :: script_onMouseMove ( const int posX , const int posY ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseMove " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onMouseMove , " ( ii ) " , posX , posY ) ; } void PythonScriptController :: script_onMouseButtonLeft ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonLeft " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonLeft , " ( iiO ) " , posX , posY , pyPressed ) } void PythonScriptController :: script_onMouseButtonRight ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonRight " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonRight , " ( iiO ) " , posX , posY , pyPressed ) } void PythonScriptController :: script_onMouseButtonMiddle ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonMiddle " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonMiddle , " ( iiO ) " , posX , posY , pyPressed ) } void PythonScriptController :: script_onMouseWheel ( const int posX , const int posY , const int delta ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseWheel " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onMouseWheel , " ( iii ) " , posX , posY , delta ) } void PythonScriptController :: script_onBeginAnimationStep ( const double dt ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onBeginAnimationStep " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onBeginAnimationStep , " ( d ) " , dt ) } void PythonScriptController :: script_onEndAnimationStep ( const double dt ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onEndAnimationStep " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onEndAnimationStep , " ( d ) " , dt ) } void PythonScriptController :: script_storeResetState ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_storeResetState ) } void PythonScriptController :: script_reset ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_reset ) } void PythonScriptController :: script_cleanup ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_cleanup ) } void PythonScriptController :: script_onGUIEvent ( const char * controlID , const char * valueName , const char * value ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onGUIEvent " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onGUIEvent , " ( sss ) " , controlID , valueName , value ) ; } void PythonScriptController :: script_onScriptEvent ( core :: objectmodel :: ScriptEvent * event ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onScriptEvent " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PythonScriptEvent * pyEvent = static_cast < PythonScriptEvent * > ( event ) ; SP_CALL_MODULEFUNC ( m_Func_onScriptEvent , " ( OsO ) " , sofa :: PythonFactory :: toPython ( pyEvent -> getSender ( ) . get ( ) ) , pyEvent -> getEventName ( ) . c_str ( ) , pyEvent -> getUserData ( ) ) ; } void PythonScriptController :: script_draw ( const core :: visual :: VisualParams * ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ draw " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_draw ) ; } void PythonScriptController :: handleEvent ( core :: objectmodel :: Event * event ) { if ( PythonScriptEvent :: checkEventType ( event ) ) { script_onScriptEvent ( static_cast < PythonScriptEvent * > ( event ) ) ; } else { ScriptController :: handleEvent ( event ) ; } } } } } </DOCUMENT>
<DOCUMENT_ID="PKRoma/poedit/tree/master/deps/boost/libs/phoenix/test/container/container_tests8a.cpp"> # include " container _ tests . hpp " # include < boost / static_assert . hpp > std :: set < int > const build_set ( ) { typedef std :: set < int > int_set ; typedef std :: vector < int > int_vector ; int_set result ; int_vector const data = build_vector ( ) ; int_vector :: const_iterator it = data . begin ( ) ; int_vector :: const_iterator const end = data . end ( ) ; result . insert ( it , end ) ; return result ; } std :: multiset < int > const build_multiset ( ) { typedef std :: set < int > int_set ; typedef std :: multiset < int > int_multiset ; int_set const data = build_set ( ) ; return int_multiset ( data . begin ( ) , data . end ( ) ) ; } std :: vector < int > const init_vector ( ) { typedef std :: vector < int > int_vector ; int const data [ ] = { - 4 , - 3 , - 2 , - 1 , 0 } ; int_vector :: size_type const data_size = sizeof ( data ) / sizeof ( data [ 0 ] ) ; return int_vector ( data , data + data_size ) ; } std :: vector < int > const build_vector ( ) { typedef std :: vector < int > int_vector ; static int_vector data = init_vector ( ) ; int_vector :: size_type const size = data . size ( ) ; int_vector :: iterator it = data . begin ( ) ; int_vector :: iterator const end = data . end ( ) ; for ( ; it != end ; ++ it ) * it += size ; return data ; } int main ( ) { BOOST_STATIC_ASSERT ( ( ! phx :: stl :: has_mapped_type < std :: multiset < int > > :: value ) ) ; BOOST_STATIC_ASSERT ( ( phx :: stl :: has_key_type < std :: multiset < int > > :: value ) ) ; std :: multiset < int > const data = build_multiset ( ) ; test_begin ( data ) ; test_clear ( data ) ; test_empty ( data ) ; test_end ( data ) ; test_set_erase ( data ) ; test_get_allocator ( data ) ; return boost :: report_errors ( ) ; } </DOCUMENT>
<DOCUMENT_ID="rlewis1988/lean/tree/master/src/library/tactic/smt/util.cpp"> # include " library / annotation . h " # include " library / util . h " # include " library / replace _ visitor . h " # include " library / vm / vm . h " # include " library / tactic / smt / congruence _ closure . h " namespace lean { static name * g_cc_proof_name = nullptr ; static macro_definition * g_cc_proof_macro = nullptr ; class cc_proof_macro_cell : public macro_definition_cell { public : virtual name get_name ( ) const { return * g_cc_proof_name ; } virtual expr check_type ( expr const & e , abstract_type_context & ctx , bool ) const { return mk_eq ( ctx , macro_arg ( e , 0 ) , macro_arg ( e , 1 ) ) ; } virtual optional < expr > expand ( expr const & , abstract_type_context & ) const { lean_unreachable ( ) ; } virtual void write ( serializer & ) const { lean_unreachable ( ) ; } virtual bool operator == ( macro_definition_cell const & other ) const { cc_proof_macro_cell const * other_ptr = dynamic_cast < cc_proof_macro_cell const * > ( & other ) ; return other_ptr ; } virtual unsigned hash ( ) const { return 23 ; } } ; expr mk_delayed_cc_eq_proof ( expr const & e1 , expr const & e2 ) { expr args [ 2 ] = { e1 , e2 } ; return mk_macro ( * g_cc_proof_macro , 2 , args ) ; } bool is_delayed_cc_eq_proof ( expr const & e ) { return is_macro ( e ) && dynamic_cast < cc_proof_macro_cell const * > ( macro_def ( e ) . raw ( ) ) ; } static name * g_theory_proof = nullptr ; expr mark_cc_theory_proof ( expr const & pr ) { return mk_annotation ( * g_theory_proof , pr ) ; } bool is_cc_theory_proof ( expr const & e ) { return is_annotation ( e , * g_theory_proof ) ; } expr get_cc_theory_proof_arg ( expr const & pr ) { lean_assert ( is_cc_theory_proof ( pr ) ) ; return get_annotation_arg ( pr ) ; } class expand_delayed_cc_proofs_fn : public replace_visitor { congruence_closure const & m_cc ; expr visit_macro ( expr const & e ) { if ( is_delayed_cc_eq_proof ( e ) ) { expr const & lhs = macro_arg ( e , 0 ) ; expr const & rhs = macro_arg ( e , 1 ) ; return * m_cc . get_eq_proof ( lhs , rhs ) ; } else { return replace_visitor :: visit_macro ( e ) ; } } public : expand_delayed_cc_proofs_fn ( congruence_closure const & cc ) : m_cc ( cc ) { } } ; expr expand_delayed_cc_proofs ( congruence_closure const & cc , expr const & e ) { return expand_delayed_cc_proofs_fn ( cc ) ( e ) ; } void initialize_smt_util ( ) { g_cc_proof_name = new name ( " cc _ proof " ) ; g_cc_proof_macro = new macro_definition ( new cc_proof_macro_cell ( ) ) ; g_theory_proof = new name ( " th _ proof " ) ; register_annotation ( * g_theory_proof ) ; } void finalize_smt_util ( ) { delete g_cc_proof_macro ; delete g_cc_proof_name ; delete g_theory_proof ; } } </DOCUMENT>
<DOCUMENT_ID="EdisonCodeKeeper/hacker-rank/tree/master/practice/mathematics/geometry/meeting-point/meeting-point.cpp"> # include < iostream > # include < vector > # include < algorithm > using namespace std ; # define M 100 bool pair_compare ( const pair < int , long long > & a , const pair < int , long long > & b ) { return a . second == b . second ? a . first < b . first : a . second < b . second ; } int main ( ) { int N ; cin >> N ; vector < pair < long long , long long > > pos ; long long avg_x = 0 , avg_y = 0 ; for ( int i = 0 ; i < N ; ++ i ) { int x , y ; cin >> x >> y ; pos . push_back ( make_pair ( x , y ) ) ; avg_x += x ; avg_y += y ; } avg_x /= N , avg_y /= N ; vector < pair < int , long long > > ans ; for ( int i = 0 ; i < N ; ++ i ) { long long dis = max ( abs ( pos [ i ] . first - avg_x ) , abs ( pos [ i ] . second - avg_y ) ) ; ans . push_back ( make_pair ( i , dis ) ) ; } sort ( ans . begin ( ) , ans . end ( ) , pair_compare ) ; long long ret = 1e16 ; for ( int i = 0 ; i < min ( M , int ( ans . size ( ) ) ) ; ++ i ) { long long tmp = 0 ; for ( int j = 0 ; j < N ; ++ j ) tmp += max ( abs ( pos [ j ] . first - pos [ ans [ i ] . first ] . first ) , abs ( pos [ j ] . second - pos [ ans [ i ] . first ] . second ) ) ; ret = min ( ret , tmp ) ; } cout << ret << endl ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="tony--/WinObjC/tree/master/deps/3rdparty/iculegacy/source/i18n/rbtz.cpp"> # include < typeinfo > # include " unicode / utypes . h " # if ! UCONFIG_NO_FORMATTING # include " unicode / rbtz . h " # include " unicode / gregocal . h " # include " uvector . h " # include " gregoimp . h " # include " cmemory . h " U_NAMESPACE_BEGIN struct Transition { UDate time ; TimeZoneRule * from ; TimeZoneRule * to ; } ; static UBool compareRules ( UVector * rules1 , UVector * rules2 ) { if ( rules1 == NULL && rules2 == NULL ) { return TRUE ; } else if ( rules1 == NULL || rules2 == NULL ) { return FALSE ; } int32_t size = rules1 -> size ( ) ; if ( size != rules2 -> size ( ) ) { return FALSE ; } for ( int32_t i = 0 ; i < size ; i ++ ) { TimeZoneRule * r1 = ( TimeZoneRule * ) rules1 -> elementAt ( i ) ; TimeZoneRule * r2 = ( TimeZoneRule * ) rules2 -> elementAt ( i ) ; if ( * r1 != * r2 ) { return FALSE ; } } return TRUE ; } UOBJECT_DEFINE_RTTI_IMPLEMENTATION ( RuleBasedTimeZone ) RuleBasedTimeZone :: RuleBasedTimeZone ( const UnicodeString & id , InitialTimeZoneRule * initialRule ) : BasicTimeZone ( id ) , fInitialRule ( initialRule ) , fHistoricRules ( NULL ) , fFinalRules ( NULL ) , fHistoricTransitions ( NULL ) , fUpToDate ( FALSE ) { } RuleBasedTimeZone :: RuleBasedTimeZone ( const RuleBasedTimeZone & source ) : BasicTimeZone ( source ) , fInitialRule ( source . fInitialRule -> clone ( ) ) , fHistoricTransitions ( NULL ) , fUpToDate ( FALSE ) { fHistoricRules = copyRules ( source . fHistoricRules ) ; fFinalRules = copyRules ( source . fFinalRules ) ; if ( source . fUpToDate ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; } } RuleBasedTimeZone :: ~ RuleBasedTimeZone ( ) { deleteTransitions ( ) ; deleteRules ( ) ; } RuleBasedTimeZone & RuleBasedTimeZone :: operator = ( const RuleBasedTimeZone & right ) { if ( * this != right ) { BasicTimeZone :: operator = ( right ) ; deleteRules ( ) ; fInitialRule = right . fInitialRule -> clone ( ) ; fHistoricRules = copyRules ( right . fHistoricRules ) ; fFinalRules = copyRules ( right . fFinalRules ) ; deleteTransitions ( ) ; fUpToDate = FALSE ; } return * this ; } UBool RuleBasedTimeZone :: operator == ( const TimeZone & that ) const { if ( this == & that ) { return TRUE ; } if ( typeid ( * this ) != typeid ( that ) || BasicTimeZone :: operator == ( that ) == FALSE ) { return FALSE ; } RuleBasedTimeZone * rbtz = ( RuleBasedTimeZone * ) & that ; if ( * fInitialRule != * ( rbtz -> fInitialRule ) ) { return FALSE ; } if ( compareRules ( fHistoricRules , rbtz -> fHistoricRules ) && compareRules ( fFinalRules , rbtz -> fFinalRules ) ) { return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: operator != ( const TimeZone & that ) const { return ! operator == ( that ) ; } void RuleBasedTimeZone :: addTransitionRule ( TimeZoneRule * rule , UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } AnnualTimeZoneRule * atzrule = dynamic_cast < AnnualTimeZoneRule * > ( rule ) ; if ( atzrule != NULL && atzrule -> getEndYear ( ) == AnnualTimeZoneRule :: MAX_YEAR ) { if ( fFinalRules == NULL ) { fFinalRules = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { return ; } } else if ( fFinalRules -> size ( ) >= 2 ) { status = U_INVALID_STATE_ERROR ; return ; } fFinalRules -> addElement ( ( void * ) rule , status ) ; } else { if ( fHistoricRules == NULL ) { fHistoricRules = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { return ; } } fHistoricRules -> addElement ( ( void * ) rule , status ) ; } fUpToDate = FALSE ; } void RuleBasedTimeZone :: complete ( UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } if ( fUpToDate ) { return ; } if ( fFinalRules != NULL && fFinalRules -> size ( ) != 2 ) { status = U_INVALID_STATE_ERROR ; return ; } UBool * done = NULL ; if ( fHistoricRules != NULL || fFinalRules != NULL ) { TimeZoneRule * curRule = fInitialRule ; UDate lastTransitionTime = MIN_MILLIS ; if ( fHistoricRules != NULL && fHistoricRules -> size ( ) > 0 ) { int32_t i ; int32_t historicCount = fHistoricRules -> size ( ) ; done = ( UBool * ) uprv_malloc ( sizeof ( UBool ) * historicCount ) ; if ( done == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } for ( i = 0 ; i < historicCount ; i ++ ) { done [ i ] = FALSE ; } while ( TRUE ) { int32_t curStdOffset = curRule -> getRawOffset ( ) ; int32_t curDstSavings = curRule -> getDSTSavings ( ) ; UDate nextTransitionTime = MAX_MILLIS ; TimeZoneRule * nextRule = NULL ; TimeZoneRule * r = NULL ; UBool avail ; UDate tt ; UnicodeString curName , name ; curRule -> getName ( curName ) ; for ( i = 0 ; i < historicCount ; i ++ ) { if ( done [ i ] ) { continue ; } r = ( TimeZoneRule * ) fHistoricRules -> elementAt ( i ) ; avail = r -> getNextStart ( lastTransitionTime , curStdOffset , curDstSavings , false , tt ) ; if ( ! avail ) { done [ i ] = TRUE ; } else { r -> getName ( name ) ; if ( * r == * curRule || ( name == curName && r -> getRawOffset ( ) == curRule -> getRawOffset ( ) && r -> getDSTSavings ( ) == curRule -> getDSTSavings ( ) ) ) { continue ; } if ( tt < nextTransitionTime ) { nextTransitionTime = tt ; nextRule = r ; } } } if ( nextRule == NULL ) { UBool bDoneAll = TRUE ; for ( int32_t j = 0 ; j < historicCount ; j ++ ) { if ( ! done [ j ] ) { bDoneAll = FALSE ; break ; } } if ( bDoneAll ) { break ; } } if ( fFinalRules != NULL ) { for ( i = 0 ; i < 2 ; i ++ ) { TimeZoneRule * fr = ( TimeZoneRule * ) fFinalRules -> elementAt ( i ) ; if ( * fr == * curRule ) { continue ; } r = ( TimeZoneRule * ) fFinalRules -> elementAt ( i ) ; avail = r -> getNextStart ( lastTransitionTime , curStdOffset , curDstSavings , false , tt ) ; if ( avail ) { if ( tt < nextTransitionTime ) { nextTransitionTime = tt ; nextRule = r ; } } } } if ( nextRule == NULL ) { break ; } if ( fHistoricTransitions == NULL ) { fHistoricTransitions = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } Transition * trst = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( trst == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } trst -> time = nextTransitionTime ; trst -> from = curRule ; trst -> to = nextRule ; fHistoricTransitions -> addElement ( trst , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } lastTransitionTime = nextTransitionTime ; curRule = nextRule ; } } if ( fFinalRules != NULL ) { if ( fHistoricTransitions == NULL ) { fHistoricTransitions = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } TimeZoneRule * rule0 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; TimeZoneRule * rule1 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; UDate tt0 , tt1 ; UBool avail0 = rule0 -> getNextStart ( lastTransitionTime , curRule -> getRawOffset ( ) , curRule -> getDSTSavings ( ) , false , tt0 ) ; UBool avail1 = rule1 -> getNextStart ( lastTransitionTime , curRule -> getRawOffset ( ) , curRule -> getDSTSavings ( ) , false , tt1 ) ; if ( ! avail0 || ! avail1 ) { status = U_INVALID_STATE_ERROR ; goto cleanup ; } Transition * final0 = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( final0 == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } Transition * final1 = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( final1 == NULL ) { uprv_free ( final0 ) ; status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } if ( tt0 < tt1 ) { final0 -> time = tt0 ; final0 -> from = curRule ; final0 -> to = rule0 ; rule1 -> getNextStart ( tt0 , rule0 -> getRawOffset ( ) , rule0 -> getDSTSavings ( ) , false , final1 -> time ) ; final1 -> from = rule0 ; final1 -> to = rule1 ; } else { final0 -> time = tt1 ; final0 -> from = curRule ; final0 -> to = rule1 ; rule0 -> getNextStart ( tt1 , rule1 -> getRawOffset ( ) , rule1 -> getDSTSavings ( ) , false , final1 -> time ) ; final1 -> from = rule1 ; final1 -> to = rule0 ; } fHistoricTransitions -> addElement ( final0 , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } fHistoricTransitions -> addElement ( final1 , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } } fUpToDate = TRUE ; if ( done != NULL ) { uprv_free ( done ) ; } return ; cleanup : deleteTransitions ( ) ; if ( done != NULL ) { uprv_free ( done ) ; } fUpToDate = FALSE ; } TimeZone * RuleBasedTimeZone :: clone ( void ) const { return new RuleBasedTimeZone ( * this ) ; } int32_t RuleBasedTimeZone :: getOffset ( uint8_t era , int32_t year , int32_t month , int32_t day , uint8_t dayOfWeek , int32_t millis , UErrorCode & status ) const { if ( U_FAILURE ( status ) ) { return 0 ; } if ( month < UCAL_JANUARY || month > UCAL_DECEMBER ) { status = U_ILLEGAL_ARGUMENT_ERROR ; return 0 ; } else { return getOffset ( era , year , month , day , dayOfWeek , millis , Grego :: monthLength ( year , month ) , status ) ; } } int32_t RuleBasedTimeZone :: getOffset ( uint8_t era , int32_t year , int32_t month , int32_t day , uint8_t , int32_t millis , int32_t , UErrorCode & status ) const { if ( U_FAILURE ( status ) ) { return 0 ; } if ( era == GregorianCalendar :: BC ) { year = 1 - year ; } int32_t rawOffset , dstOffset ; UDate time = ( UDate ) Grego :: fieldsToDay ( year , month , day ) * U_MILLIS_PER_DAY + millis ; getOffsetInternal ( time , TRUE , kDaylight , kStandard , rawOffset , dstOffset , status ) ; if ( U_FAILURE ( status ) ) { return 0 ; } return ( rawOffset + dstOffset ) ; } void RuleBasedTimeZone :: getOffset ( UDate date , UBool local , int32_t & rawOffset , int32_t & dstOffset , UErrorCode & status ) const { getOffsetInternal ( date , local , kFormer , kLatter , rawOffset , dstOffset , status ) ; } void RuleBasedTimeZone :: getOffsetFromLocal ( UDate date , int32_t nonExistingTimeOpt , int32_t duplicatedTimeOpt , int32_t & rawOffset , int32_t & dstOffset , UErrorCode & status ) { getOffsetInternal ( date , TRUE , nonExistingTimeOpt , duplicatedTimeOpt , rawOffset , dstOffset , status ) ; } void RuleBasedTimeZone :: getOffsetInternal ( UDate date , UBool local , int32_t NonExistingTimeOpt , int32_t DuplicatedTimeOpt , int32_t & rawOffset , int32_t & dstOffset , UErrorCode & status ) const { rawOffset = 0 ; dstOffset = 0 ; if ( U_FAILURE ( status ) ) { return ; } if ( ! fUpToDate ) { status = U_INVALID_STATE_ERROR ; return ; } const TimeZoneRule * rule = NULL ; if ( fHistoricTransitions == NULL ) { rule = fInitialRule ; } else { UDate tstart = getTransitionTime ( ( Transition * ) fHistoricTransitions -> elementAt ( 0 ) , local , NonExistingTimeOpt , DuplicatedTimeOpt ) ; if ( date < tstart ) { rule = fInitialRule ; } else { int32_t idx = fHistoricTransitions -> size ( ) - 1 ; UDate tend = getTransitionTime ( ( Transition * ) fHistoricTransitions -> elementAt ( idx ) , local , NonExistingTimeOpt , DuplicatedTimeOpt ) ; if ( date > tend ) { if ( fFinalRules != NULL ) { rule = findRuleInFinal ( date , local , NonExistingTimeOpt , DuplicatedTimeOpt ) ; } else { rule = ( ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ) -> to ; } } else { while ( idx >= 0 ) { if ( date >= getTransitionTime ( ( Transition * ) fHistoricTransitions -> elementAt ( idx ) , local , NonExistingTimeOpt , DuplicatedTimeOpt ) ) { break ; } idx -- ; } rule = ( ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ) -> to ; } } } if ( rule != NULL ) { rawOffset = rule -> getRawOffset ( ) ; dstOffset = rule -> getDSTSavings ( ) ; } } void RuleBasedTimeZone :: setRawOffset ( int32_t ) { } int32_t RuleBasedTimeZone :: getRawOffset ( void ) const { UErrorCode status = U_ZERO_ERROR ; int32_t raw , dst ; getOffset ( uprv_getUTCtime ( ) * U_MILLIS_PER_SECOND , FALSE , raw , dst , status ) ; return raw ; } UBool RuleBasedTimeZone :: useDaylightTime ( void ) const { UErrorCode status = U_ZERO_ERROR ; UDate now = uprv_getUTCtime ( ) * U_MILLIS_PER_SECOND ; int32_t raw , dst ; getOffset ( now , FALSE , raw , dst , status ) ; if ( dst != 0 ) { return TRUE ; } UDate time ; TimeZoneRule * from , * to ; UBool avail = findNext ( now , FALSE , time , from , to ) ; if ( avail && to -> getDSTSavings ( ) != 0 ) { return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: inDaylightTime ( UDate date , UErrorCode & status ) const { if ( U_FAILURE ( status ) ) { return FALSE ; } int32_t raw , dst ; getOffset ( date , FALSE , raw , dst , status ) ; if ( dst != 0 ) { return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: hasSameRules ( const TimeZone & other ) const { if ( this == & other ) { return TRUE ; } if ( typeid ( * this ) != typeid ( other ) ) { return FALSE ; } const RuleBasedTimeZone & that = ( const RuleBasedTimeZone & ) other ; if ( * fInitialRule != * ( that . fInitialRule ) ) { return FALSE ; } if ( compareRules ( fHistoricRules , that . fHistoricRules ) && compareRules ( fFinalRules , that . fFinalRules ) ) { return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: getNextTransition ( UDate base , UBool inclusive , TimeZoneTransition & result ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; if ( U_FAILURE ( status ) ) { return FALSE ; } UDate transitionTime ; TimeZoneRule * fromRule , * toRule ; UBool found = findNext ( base , inclusive , transitionTime , fromRule , toRule ) ; if ( found ) { result . setTime ( transitionTime ) ; result . setFrom ( ( const TimeZoneRule & ) * fromRule ) ; result . setTo ( ( const TimeZoneRule & ) * toRule ) ; return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: getPreviousTransition ( UDate base , UBool inclusive , TimeZoneTransition & result ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; if ( U_FAILURE ( status ) ) { return FALSE ; } UDate transitionTime ; TimeZoneRule * fromRule , * toRule ; UBool found = findPrev ( base , inclusive , transitionTime , fromRule , toRule ) ; if ( found ) { result . setTime ( transitionTime ) ; result . setFrom ( ( const TimeZoneRule & ) * fromRule ) ; result . setTo ( ( const TimeZoneRule & ) * toRule ) ; return TRUE ; } return FALSE ; } int32_t RuleBasedTimeZone :: countTransitionRules ( UErrorCode & ) { int32_t count = 0 ; if ( fHistoricRules != NULL ) { count += fHistoricRules -> size ( ) ; } if ( fFinalRules != NULL ) { count += fFinalRules -> size ( ) ; } return count ; } void RuleBasedTimeZone :: getTimeZoneRules ( const InitialTimeZoneRule * & initial , const TimeZoneRule * trsrules [ ] , int32_t & trscount , UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } initial = fInitialRule ; int32_t cnt = 0 ; int32_t idx ; if ( fHistoricRules != NULL && cnt < trscount ) { int32_t historicCount = fHistoricRules -> size ( ) ; idx = 0 ; while ( cnt < trscount && idx < historicCount ) { trsrules [ cnt ++ ] = ( const TimeZoneRule * ) fHistoricRules -> elementAt ( idx ++ ) ; } } if ( fFinalRules != NULL && cnt < trscount ) { int32_t finalCount = fFinalRules -> size ( ) ; idx = 0 ; while ( cnt < trscount && idx < finalCount ) { trsrules [ cnt ++ ] = ( const TimeZoneRule * ) fFinalRules -> elementAt ( idx ++ ) ; } } trscount = cnt ; } void RuleBasedTimeZone :: deleteRules ( void ) { delete fInitialRule ; fInitialRule = NULL ; if ( fHistoricRules != NULL ) { while ( ! fHistoricRules -> isEmpty ( ) ) { delete ( TimeZoneRule * ) ( fHistoricRules -> orphanElementAt ( 0 ) ) ; } delete fHistoricRules ; fHistoricRules = NULL ; } if ( fFinalRules != NULL ) { while ( ! fFinalRules -> isEmpty ( ) ) { delete ( AnnualTimeZoneRule * ) ( fFinalRules -> orphanElementAt ( 0 ) ) ; } delete fFinalRules ; fFinalRules = NULL ; } } void RuleBasedTimeZone :: deleteTransitions ( void ) { if ( fHistoricTransitions != NULL ) { while ( ! fHistoricTransitions -> isEmpty ( ) ) { Transition * trs = ( Transition * ) fHistoricTransitions -> orphanElementAt ( 0 ) ; uprv_free ( trs ) ; } delete fHistoricTransitions ; } fHistoricTransitions = NULL ; } UVector * RuleBasedTimeZone :: copyRules ( UVector * source ) { if ( source == NULL ) { return NULL ; } UErrorCode ec = U_ZERO_ERROR ; int32_t size = source -> size ( ) ; UVector * rules = new UVector ( size , ec ) ; if ( U_FAILURE ( ec ) ) { return NULL ; } int32_t i ; for ( i = 0 ; i < size ; i ++ ) { rules -> addElement ( ( ( TimeZoneRule * ) source -> elementAt ( i ) ) -> clone ( ) , ec ) ; if ( U_FAILURE ( ec ) ) { break ; } } if ( U_FAILURE ( ec ) ) { for ( i = 0 ; i < rules -> size ( ) ; i ++ ) { TimeZoneRule * rule = ( TimeZoneRule * ) rules -> orphanElementAt ( i ) ; delete rule ; } delete rules ; return NULL ; } return rules ; } TimeZoneRule * RuleBasedTimeZone :: findRuleInFinal ( UDate date , UBool local , int32_t NonExistingTimeOpt , int32_t DuplicatedTimeOpt ) const { if ( fFinalRules == NULL ) { return NULL ; } AnnualTimeZoneRule * fr0 = ( AnnualTimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; AnnualTimeZoneRule * fr1 = ( AnnualTimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; if ( fr0 == NULL || fr1 == NULL ) { return NULL ; } UDate start0 , start1 ; UDate base ; int32_t localDelta ; base = date ; if ( local ) { localDelta = getLocalDelta ( fr1 -> getRawOffset ( ) , fr1 -> getDSTSavings ( ) , fr0 -> getRawOffset ( ) , fr0 -> getDSTSavings ( ) , NonExistingTimeOpt , DuplicatedTimeOpt ) ; base -= localDelta ; } UBool avail0 = fr0 -> getPreviousStart ( base , fr1 -> getRawOffset ( ) , fr1 -> getDSTSavings ( ) , TRUE , start0 ) ; base = date ; if ( local ) { localDelta = getLocalDelta ( fr0 -> getRawOffset ( ) , fr0 -> getDSTSavings ( ) , fr1 -> getRawOffset ( ) , fr1 -> getDSTSavings ( ) , NonExistingTimeOpt , DuplicatedTimeOpt ) ; base -= localDelta ; } UBool avail1 = fr1 -> getPreviousStart ( base , fr0 -> getRawOffset ( ) , fr0 -> getDSTSavings ( ) , TRUE , start1 ) ; if ( avail0 && ( ! avail1 || start0 > start1 ) ) { return fr0 ; } else if ( avail1 ) { return fr1 ; } return NULL ; } UBool RuleBasedTimeZone :: findNext ( UDate base , UBool inclusive , UDate & transitionTime , TimeZoneRule * & fromRule , TimeZoneRule * & toRule ) const { if ( fHistoricTransitions == NULL ) { return FALSE ; } UBool isFinal = FALSE ; UBool found = FALSE ; Transition result ; Transition * tzt = ( Transition * ) fHistoricTransitions -> elementAt ( 0 ) ; UDate tt = tzt -> time ; if ( tt > base || ( inclusive && tt == base ) ) { result = * tzt ; found = TRUE ; } else { int32_t idx = fHistoricTransitions -> size ( ) - 1 ; tzt = ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ; tt = tzt -> time ; if ( inclusive && tt == base ) { result = * tzt ; found = TRUE ; } else if ( tt <= base ) { if ( fFinalRules != NULL ) { TimeZoneRule * r0 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; TimeZoneRule * r1 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; UDate start0 , start1 ; UBool avail0 = r0 -> getNextStart ( base , r1 -> getRawOffset ( ) , r1 -> getDSTSavings ( ) , inclusive , start0 ) ; UBool avail1 = r1 -> getNextStart ( base , r0 -> getRawOffset ( ) , r0 -> getDSTSavings ( ) , inclusive , start1 ) ; if ( ! avail0 && ! avail1 ) { return FALSE ; } if ( ! avail1 || start0 < start1 ) { result . time = start0 ; result . from = r1 ; result . to = r0 ; } else { result . time = start1 ; result . from = r0 ; result . to = r1 ; } isFinal = TRUE ; found = TRUE ; } } else { idx -- ; Transition * prev = tzt ; while ( idx > 0 ) { tzt = ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ; tt = tzt -> time ; if ( tt < base || ( ! inclusive && tt == base ) ) { break ; } idx -- ; prev = tzt ; } result . time = prev -> time ; result . from = prev -> from ; result . to = prev -> to ; found = TRUE ; } } if ( found ) { if ( result . from -> getRawOffset ( ) == result . to -> getRawOffset ( ) && result . from -> getDSTSavings ( ) == result . to -> getDSTSavings ( ) ) { if ( isFinal ) { return FALSE ; } else { return findNext ( result . time , FALSE , transitionTime , fromRule , toRule ) ; } } transitionTime = result . time ; fromRule = result . from ; toRule = result . to ; return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: findPrev ( UDate base , UBool inclusive , UDate & transitionTime , TimeZoneRule * & fromRule , TimeZoneRule * & toRule ) const { if ( fHistoricTransitions == NULL ) { return FALSE ; } UBool found = FALSE ; Transition result ; Transition * tzt = ( Transition * ) fHistoricTransitions -> elementAt ( 0 ) ; UDate tt = tzt -> time ; if ( inclusive && tt == base ) { result = * tzt ; found = TRUE ; } else if ( tt < base ) { int32_t idx = fHistoricTransitions -> size ( ) - 1 ; tzt = ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ; tt = tzt -> time ; if ( inclusive && tt == base ) { result = * tzt ; found = TRUE ; } else if ( tt < base ) { if ( fFinalRules != NULL ) { TimeZoneRule * r0 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; TimeZoneRule * r1 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; UDate start0 , start1 ; UBool avail0 = r0 -> getPreviousStart ( base , r1 -> getRawOffset ( ) , r1 -> getDSTSavings ( ) , inclusive , start0 ) ; UBool avail1 = r1 -> getPreviousStart ( base , r0 -> getRawOffset ( ) , r0 -> getDSTSavings ( ) , inclusive , start1 ) ; if ( ! avail0 && ! avail1 ) { return FALSE ; } if ( ! avail1 || start0 > start1 ) { result . time = start0 ; result . from = r1 ; result . to = r0 ; } else { result . time = start1 ; result . from = r0 ; result . to = r1 ; } } else { result = * tzt ; } found = TRUE ; } else { idx -- ; while ( idx >= 0 ) { tzt = ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ; tt = tzt -> time ; if ( tt < base || ( inclusive && tt == base ) ) { break ; } idx -- ; } result = * tzt ; found = TRUE ; } } if ( found ) { if ( result . from -> getRawOffset ( ) == result . to -> getRawOffset ( ) && result . from -> getDSTSavings ( ) == result . to -> getDSTSavings ( ) ) { return findPrev ( result . time , FALSE , transitionTime , fromRule , toRule ) ; } transitionTime = result . time ; fromRule = result . from ; toRule = result . to ; return TRUE ; } return FALSE ; } UDate RuleBasedTimeZone :: getTransitionTime ( Transition * transition , UBool local , int32_t NonExistingTimeOpt , int32_t DuplicatedTimeOpt ) const { UDate time = transition -> time ; if ( local ) { time += getLocalDelta ( transition -> from -> getRawOffset ( ) , transition -> from -> getDSTSavings ( ) , transition -> to -> getRawOffset ( ) , transition -> to -> getDSTSavings ( ) , NonExistingTimeOpt , DuplicatedTimeOpt ) ; } return time ; } int32_t RuleBasedTimeZone :: getLocalDelta ( int32_t rawBefore , int32_t dstBefore , int32_t rawAfter , int32_t dstAfter , int32_t NonExistingTimeOpt , int32_t DuplicatedTimeOpt ) const { int32_t delta = 0 ; int32_t offsetBefore = rawBefore + dstBefore ; int32_t offsetAfter = rawAfter + dstAfter ; UBool dstToStd = ( dstBefore != 0 ) && ( dstAfter == 0 ) ; UBool stdToDst = ( dstBefore == 0 ) && ( dstAfter != 0 ) ; if ( offsetAfter - offsetBefore >= 0 ) { if ( ( ( NonExistingTimeOpt & kStdDstMask ) == kStandard && dstToStd ) || ( ( NonExistingTimeOpt & kStdDstMask ) == kDaylight && stdToDst ) ) { delta = offsetBefore ; } else if ( ( ( NonExistingTimeOpt & kStdDstMask ) == kStandard && stdToDst ) || ( ( NonExistingTimeOpt & kStdDstMask ) == kDaylight && dstToStd ) ) { delta = offsetAfter ; } else if ( ( NonExistingTimeOpt & kFormerLatterMask ) == kLatter ) { delta = offsetBefore ; } else { delta = offsetAfter ; } } else { if ( ( ( DuplicatedTimeOpt & kStdDstMask ) == kStandard && dstToStd ) || ( ( DuplicatedTimeOpt & kStdDstMask ) == kDaylight && stdToDst ) ) { delta = offsetAfter ; } else if ( ( ( DuplicatedTimeOpt & kStdDstMask ) == kStandard && stdToDst ) || ( ( DuplicatedTimeOpt & kStdDstMask ) == kDaylight && dstToStd ) ) { delta = offsetBefore ; } else if ( ( DuplicatedTimeOpt & kFormerLatterMask ) == kFormer ) { delta = offsetBefore ; } else { delta = offsetAfter ; } } return delta ; } U_NAMESPACE_END # endif </DOCUMENT>
<DOCUMENT_ID="cndpost/cppidioms/tree/master/bft/bft.cpp"> # include < iostream > # include < vector > # include < queue > using namespace std ; class Tree ; class Tree { public : char data ; bool visited ; std :: vector < Tree * > children ; } ; void bft ( Tree * root ) { if ( root == NULL ) return ; if ( root -> visited ) return ; root -> visited = true ; printf ( " % c ▁ \n " , root -> data ) ; std :: queue < Tree * > * newQue = new std :: queue < Tree * > ( ) ; int Size = root -> children . size ( ) ; for ( int i = 0 ; i < Size ; i ++ ) { Tree * child = root -> children [ i ] ; if ( child != NULL ) newQue -> push ( child ) ; } for ( int i = 0 ; i < Size ; i ++ ) { Tree * child = newQue -> front ( ) ; if ( child != NULL ) bft ( child ) ; newQue -> pop ( ) ; } return ; } ; void insert ( Tree * root , char data ) { Tree * newTree = new Tree ( ) ; newTree -> data = data ; newTree -> visited = false ; root -> children . push_back ( newTree ) ; return ; } ; int main ( ) { Tree * root = new Tree ( ) ; root -> data = ' a ' ; Tree * leftChild = new Tree { } ; leftChild -> data = ' b ' ; Tree * rightChild = new Tree ( ) ; rightChild -> data = ' c ' ; root -> children . push_back ( leftChild ) ; root -> children . push_back ( rightChild ) ; cout << " start ▁ doing ▁ BFT ▁ in ▁ one ▁ way ▁ " << endl ; bft ( root ) ; delete root ; root = new Tree ( ) ; root -> data = ' a ' ; insert ( root , ' d ' ) ; insert ( root , ' e ' ) ; cout << " start ▁ doing ▁ BFT ▁ in ▁ 2nd ▁ way " << endl ; bft ( root ) ; cout << " done ▁ DFT ▁ " << endl ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="rfloca/MITK/tree/master/Plugins/org.mitk.gui.qt.diffusionimagingapp/src/internal/Perspectives/QmitkDIAppConnectomicsPerspective.cpp"> # include " QmitkDIAppConnectomicsPerspective . h " # include " berryIViewLayout . h " void QmitkDIAppConnectomicsPerspective :: CreateInitialLayout ( berry :: IPageLayout :: Pointer layout ) { std :: string editorArea = layout -> GetEditorArea ( ) ; layout -> AddStandaloneView ( " org . mitk . views . datamanager " , false , berry :: IPageLayout :: LEFT , 0.3f , editorArea ) ; layout -> AddStandaloneView ( " org . mitk . views . controlvisualizationpropertiesview " , false , berry :: IPageLayout :: BOTTOM , .15f , " org . mitk . views . datamanager " ) ; berry :: IFolderLayout :: Pointer left = layout -> CreateFolder ( " org . mbi . diffusionimaginginternal . leftcontrols " , berry :: IPageLayout :: BOTTOM , 0.1f , " org . mitk . views . controlvisualizationpropertiesview " ) ; layout -> AddStandaloneViewPlaceholder ( " org . mitk . views . imagenavigator " , berry :: IPageLayout :: BOTTOM , .4f , " org . mbi . diffusionimaginginternal . leftcontrols " , false ) ; left -> AddView ( " org . mitk . views . connectomicsstatistics " ) ; berry :: IViewLayout :: Pointer lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsstatistics " ) ; lo -> SetCloseable ( false ) ; left -> AddView ( " org . mitk . views . connectomicsnetworkoperations " ) ; lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsnetworkoperations " ) ; lo -> SetCloseable ( false ) ; left -> AddView ( " org . mitk . views . connectomicsdata " ) ; lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsdata " ) ; lo -> SetCloseable ( false ) ; } </DOCUMENT>
<DOCUMENT_ID="HofiOne/xbmc/tree/master/xbmc/settings/dialogs/GUIDialogLibExportSettings.cpp"> # include < map > # include < memory > # include < string > # include < utility > # include < vector > # include < limits . h > # include " GUIDialogLibExportSettings . h " # include " dialogs / GUIDialogFileBrowser . h " # include " guilib / GUIComponent . h " # include " guilib / GUIWindowManager . h " # include " guilib / LocalizeStrings . h " # include " messaging / helpers / DialogHelper . h " # include " messaging / helpers / DialogOKHelper . h " # include " ServiceBroker . h " # include " settings / SettingUtils . h " # include " settings / lib / Setting . h " # include " settings / Settings . h " # include " settings / windows / GUIControlSettings . h " # include " storage / MediaManager . h " # include " Util . h " # include " utils / log . h " # include " utils / URIUtils . h " # include " filesystem / Directory . h " using namespace ADDON ; using namespace KODI :: MESSAGING ; using KODI :: MESSAGING :: HELPERS :: DialogResponse ; CGUIDialogLibExportSettings :: CGUIDialogLibExportSettings ( ) : CGUIDialogSettingsManualBase ( WINDOW_DIALOG_LIBEXPORT_SETTINGS , " DialogSettings . xml " ) , m_destinationChecked ( false ) { } bool CGUIDialogLibExportSettings :: Show ( CLibExportSettings & settings ) { CGUIDialogLibExportSettings * dialog = CServiceBroker :: GetGUI ( ) -> GetWindowManager ( ) . GetWindow < CGUIDialogLibExportSettings > ( WINDOW_DIALOG_LIBEXPORT_SETTINGS ) ; if ( ! dialog ) return false ; dialog -> m_settings . SetExportType ( CServiceBroker :: GetSettings ( ) . GetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) ) ; dialog -> m_settings . m_strPath = CServiceBroker :: GetSettings ( ) . GetString ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; dialog -> m_settings . SetItemsToExport ( CServiceBroker :: GetSettings ( ) . GetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS ) ) ; dialog -> m_settings . m_unscraped = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED ) ; dialog -> m_settings . m_artwork = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK ) ; dialog -> m_settings . m_skipnfo = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO ) ; dialog -> m_settings . m_overwrite = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE ) ; dialog -> m_destinationChecked = false ; dialog -> Open ( ) ; bool confirmed = dialog -> IsConfirmed ( ) ; if ( confirmed ) { settings = dialog -> m_settings ; } return confirmed ; } void CGUIDialogLibExportSettings :: OnInitWindow ( ) { CGUIDialogSettingsManualBase :: OnInitWindow ( ) ; } void CGUIDialogLibExportSettings :: OnSettingChanged ( std :: shared_ptr < const CSetting > setting ) { if ( ! setting ) return ; CGUIDialogSettingsManualBase :: OnSettingChanged ( setting ) ; const std :: string & settingId = setting -> GetId ( ) ; if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) { m_settings . SetExportType ( std :: static_pointer_cast < const CSettingInt > ( setting ) -> GetValue ( ) ) ; SetupView ( ) ; SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) { m_settings . m_strPath = std :: static_pointer_cast < const CSettingString > ( setting ) -> GetValue ( ) ; UpdateButtons ( ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE ) m_settings . m_overwrite = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS ) m_settings . SetItemsToExport ( GetExportItemsFromSetting ( setting ) ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK ) { m_settings . m_artwork = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED ) m_settings . m_unscraped = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO ) m_settings . m_skipnfo = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; } void CGUIDialogLibExportSettings :: OnSettingAction ( std :: shared_ptr < const CSetting > setting ) { if ( setting == NULL ) return ; CGUIDialogSettingsManualBase :: OnSettingAction ( setting ) ; const std :: string & settingId = setting -> GetId ( ) ; if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) { VECSOURCES shares ; g_mediaManager . GetLocalDrives ( shares ) ; g_mediaManager . GetNetworkLocations ( shares ) ; g_mediaManager . GetRemovableDrives ( shares ) ; std :: string strDirectory = m_settings . m_strPath ; if ( ! strDirectory . empty ( ) ) { URIUtils :: AddSlashAtEnd ( strDirectory ) ; bool bIsSource ; if ( CUtil :: GetMatchingSource ( strDirectory , shares , bIsSource ) < 0 ) { CMediaSource share ; share . strName = g_localizeStrings . Get ( 13278 ) ; share . strPath = strDirectory ; shares . push_back ( share ) ; } } else strDirectory = " default ▁ location " ; if ( CGUIDialogFileBrowser :: ShowAndGetDirectory ( shares , g_localizeStrings . Get ( 661 ) , strDirectory , true ) ) { if ( ! strDirectory . empty ( ) ) { m_destinationChecked = true ; m_settings . m_strPath = strDirectory ; SetLabel2 ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , strDirectory ) ; SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; } } UpdateButtons ( ) ; } } bool CGUIDialogLibExportSettings :: OnMessage ( CGUIMessage & message ) { switch ( message . GetMessage ( ) ) { case GUI_MSG_CLICKED : { int iControl = message . GetSenderId ( ) ; if ( iControl == CONTROL_SETTINGS_OKAY_BUTTON ) { OnOK ( ) ; return true ; } } break ; } return CGUIDialogSettingsManualBase :: OnMessage ( message ) ; } void CGUIDialogLibExportSettings :: OnOK ( ) { if ( m_settings . IsToLibFolders ( ) ) { std :: string path = CServiceBroker :: GetSettings ( ) . GetString ( CSettings :: SETTING_MUSICLIBRARY_ARTISTSFOLDER ) ; if ( path . empty ( ) ) { if ( HELPERS :: ShowYesNoDialogText ( 20223 , 38317 , 186 , 10004 ) == DialogResponse :: YES ) { m_confirmed = false ; Close ( ) ; CServiceBroker :: GetGUI ( ) -> GetWindowManager ( ) . ActivateWindow ( WINDOW_SETTINGS_MEDIA , CSettings :: SETTING_MUSICLIBRARY_ARTISTSFOLDER ) ; } return ; } } else if ( ! m_destinationChecked ) { if ( ! XFILE :: CDirectory :: Exists ( m_settings . m_strPath ) ) { HELPERS :: ShowOKDialogText ( CVariant { 38300 } , CVariant { 38318 } ) ; return ; } } m_confirmed = true ; Save ( ) ; Close ( ) ; } void CGUIDialogLibExportSettings :: Save ( ) { CLog :: Log ( LOGINFO , " CGUIDialogMusicExportSettings : ▁ Save ( ) ▁ called " ) ; CServiceBroker :: GetSettings ( ) . SetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE , m_settings . GetExportType ( ) ) ; CServiceBroker :: GetSettings ( ) . SetString ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , m_settings . m_strPath ) ; CServiceBroker :: GetSettings ( ) . SetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS , m_settings . GetItemsToExport ( ) ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED , m_settings . m_unscraped ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , m_settings . m_overwrite ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , m_settings . m_artwork ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_skipnfo ) ; CServiceBroker :: GetSettings ( ) . Save ( ) ; } void CGUIDialogLibExportSettings :: SetupView ( ) { CGUIDialogSettingsManualBase :: SetupView ( ) ; SetHeading ( 38300 ) ; SET_CONTROL_HIDDEN ( CONTROL_SETTINGS_CUSTOM_BUTTON ) ; SET_CONTROL_LABEL ( CONTROL_SETTINGS_OKAY_BUTTON , 38319 ) ; SET_CONTROL_LABEL ( CONTROL_SETTINGS_CANCEL_BUTTON , 222 ) ; SetLabel2 ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , m_settings . m_strPath ) ; if ( m_settings . IsSingleFile ( ) ) { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , false ) ; } else if ( m_settings . IsSeparateFiles ( ) ) { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } else { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } UpdateButtons ( ) ; } void CGUIDialogLibExportSettings :: UpdateButtons ( ) { bool enableExport ( true ) ; if ( m_settings . IsSingleFile ( ) || m_settings . IsSeparateFiles ( ) ) enableExport = ! m_settings . m_strPath . empty ( ) ; CONTROL_ENABLE_ON_CONDITION ( CONTROL_SETTINGS_OKAY_BUTTON , enableExport ) ; if ( ! enableExport ) SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; } void CGUIDialogLibExportSettings :: InitializeSettings ( ) { CGUIDialogSettingsManualBase :: InitializeSettings ( ) ; std :: shared_ptr < CSettingCategory > category = AddCategory ( " exportsettings " , - 1 ) ; if ( ! category ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : ▁ unable ▁ to ▁ setup ▁ settings " ) ; return ; } std :: shared_ptr < CSettingGroup > groupDetails = AddGroup ( category ) ; if ( ! groupDetails ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : ▁ unable ▁ to ▁ setup ▁ settings " ) ; return ; } TranslatableIntegerSettingOptions entries ; entries . push_back ( std :: make_pair ( 38301 , ELIBEXPORT_SINGLEFILE ) ) ; entries . push_back ( std :: make_pair ( 38302 , ELIBEXPORT_SEPARATEFILES ) ) ; entries . push_back ( std :: make_pair ( 38303 , ELIBEXPORT_TOLIBRARYFOLDER ) ) ; AddList ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE , 38304 , SettingLevel :: Basic , m_settings . GetExportType ( ) , entries , 38304 ) ; AddButton ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , 38305 , SettingLevel :: Basic ) ; entries . clear ( ) ; entries . push_back ( std :: make_pair ( 132 , ELIBEXPORT_ALBUMS ) ) ; entries . push_back ( std :: make_pair ( 38043 , ELIBEXPORT_ALBUMARTISTS ) ) ; entries . push_back ( std :: make_pair ( 38312 , ELIBEXPORT_SONGARTISTS ) ) ; entries . push_back ( std :: make_pair ( 38313 , ELIBEXPORT_OTHERARTISTS ) ) ; AddList ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS , 38306 , SettingLevel :: Basic , m_settings . GetExportItems ( ) , entries , 133 , 1 ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED , 38308 , SettingLevel :: Basic , m_settings . m_unscraped ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , 38307 , SettingLevel :: Basic , m_settings . m_artwork ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , 38309 , SettingLevel :: Basic , m_settings . m_skipnfo ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , 38310 , SettingLevel :: Basic , m_settings . m_overwrite ) ; } void CGUIDialogLibExportSettings :: SetLabel2 ( const std :: string & settingid , const std :: string & label ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) SET_CONTROL_LABEL2 ( settingControl -> GetID ( ) , label ) ; } void CGUIDialogLibExportSettings :: ToggleState ( const std :: string & settingid , bool enabled ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) { if ( enabled ) CONTROL_ENABLE ( settingControl -> GetID ( ) ) ; else CONTROL_DISABLE ( settingControl -> GetID ( ) ) ; } } void CGUIDialogLibExportSettings :: SetFocus ( const std :: string & settingid ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) SET_CONTROL_FOCUS ( settingControl -> GetID ( ) , 0 ) ; } int CGUIDialogLibExportSettings :: GetExportItemsFromSetting ( SettingConstPtr setting ) { std :: shared_ptr < const CSettingList > settingList = std :: static_pointer_cast < const CSettingList > ( setting ) ; if ( settingList -> GetElementType ( ) != SettingType :: Integer ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : : % s ▁ - ▁ wrong ▁ items ▁ element ▁ type " , __FUNCTION__ ) ; return 0 ; } int exportitems = 0 ; std :: vector < CVariant > list = CSettingUtils :: GetList ( settingList ) ; for ( const auto & value : list ) { if ( ! value . isInteger ( ) ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : : % s ▁ - ▁ wrong ▁ items ▁ value ▁ type " , __FUNCTION__ ) ; return 0 ; } exportitems += value . asInteger ( ) ; } return exportitems ; } </DOCUMENT>
<DOCUMENT_ID="boiled-sugar/mkvtoolnix/tree/master/src/output/p_mpeg4_p2.cpp"> # include " common / common _ pch . h " # include " avilib . h " # include " common / codec . h " # include " common / endian . h " # include " common / hacks . h " # include " common / math . h " # include " common / strings / formatting . h " # include " merge / generic _ reader . h " # include " merge / output _ control . h " # include " output / p _ mpeg4 _ p2 . h " mpeg4_p2_video_packetizer_c :: mpeg4_p2_video_packetizer_c ( generic_reader_c * p_reader , track_info_c & p_ti , double fps , int width , int height , bool input_is_native ) : video_for_windows_packetizer_c ( p_reader , p_ti , fps , width , height ) , m_timecodes_generated ( 0 ) , m_previous_timecode ( 0 ) , m_aspect_ratio_extracted ( false ) , m_input_is_native ( input_is_native ) , m_output_is_native ( hack_engaged ( ENGAGE_NATIVE_MPEG4 ) || input_is_native ) , m_size_extracted ( false ) { if ( ! m_output_is_native ) m_timestamp_factory_application_mode = TFA_SHORT_QUEUEING ; else { set_codec_id ( MKV_V_MPEG4_ASP ) ; if ( ! m_input_is_native ) m_ti . m_private_data . reset ( ) ; if ( m_ti . m_ext_timecodes . empty ( ) ) m_timestamp_factory . reset ( ) ; if ( m_default_duration_forced ) m_fps = 1000000000.0 / m_htrack_default_duration ; else if ( 0.0 != m_fps ) m_htrack_default_duration = static_cast < int64_t > ( 1000000000ll / m_fps ) ; m_timestamp_factory_application_mode = TFA_FULL_QUEUEING ; } } mpeg4_p2_video_packetizer_c :: ~ mpeg4_p2_video_packetizer_c ( ) { if ( ! debugging_c :: requested ( " mpeg4 _ p2 _ statistics " ) ) return ; mxinfo ( boost :: format ( " mpeg4 _ p2 _ video _ packetizer _ c ▁ statistics : \n " " ▁ ▁ # ▁ I ▁ frames : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 1 % \n " " ▁ ▁ # ▁ P ▁ frames : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 2 % \n " " ▁ ▁ # ▁ B ▁ frames : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 3 % \n " " ▁ ▁ # ▁ NVOPs : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 4 % \n " " ▁ ▁ # ▁ generated ▁ timecodes : ▁ % 5 % \n " " ▁ ▁ # ▁ dropped ▁ timecodes : ▁ ▁ ▁ % 6 % \n " ) % m_statistics . m_num_i_frames % m_statistics . m_num_p_frames % m_statistics . m_num_b_frames % m_statistics . m_num_n_vops % m_statistics . m_num_generated_timecodes % m_statistics . m_num_dropped_timecodes ) ; } int mpeg4_p2_video_packetizer_c :: process ( packet_cptr packet ) { extract_size ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) ) ; extract_aspect_ratio ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) ) ; int result = m_input_is_native == m_output_is_native ? video_for_windows_packetizer_c :: process ( packet ) : m_input_is_native ? process_native ( packet ) : process_non_native ( packet ) ; ++ m_frames_output ; return result ; } int mpeg4_p2_video_packetizer_c :: process_non_native ( packet_cptr packet ) { extract_config_data ( packet ) ; if ( - 1 != packet -> timecode ) { if ( ! m_default_duration_forced ) m_available_timecodes . push_back ( timecode_duration_t ( packet -> timecode , packet -> duration ) ) ; else { m_available_timecodes . push_back ( timecode_duration_t ( m_timecodes_generated * m_htrack_default_duration , m_htrack_default_duration ) ) ; ++ m_timecodes_generated ; } } else if ( 0.0 == m_fps ) mxerror_tid ( m_ti . m_fname , m_ti . m_id , Y ( " Cannot ▁ convert ▁ non - native ▁ MPEG4 ▁ video ▁ frames ▁ into ▁ native ▁ ones ▁ if ▁ the ▁ source ▁ container ▁ " " provides ▁ neither ▁ timecodes ▁ nor ▁ a ▁ number ▁ of ▁ frames ▁ per ▁ second . \n " ) ) ; std :: vector < video_frame_t > frames ; mpeg4 :: p2 :: find_frame_types ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) , frames , m_config_data ) ; for ( auto & frame : frames ) { if ( ! frame . is_coded ) { ++ m_statistics . m_num_n_vops ; int num_surplus_timecodes = static_cast < int > ( m_available_timecodes . size ( ) ) - static_cast < int > ( m_ref_frames . size ( ) + m_b_frames . size ( ) ) ; if ( 0 < num_surplus_timecodes ) { std :: deque < timecode_duration_t > :: iterator start = m_available_timecodes . begin ( ) + m_ref_frames . size ( ) + m_b_frames . size ( ) ; std :: deque < timecode_duration_t > :: iterator end = start + num_surplus_timecodes ; if ( 0 != ( m_ref_frames . size ( ) + m_b_frames . size ( ) ) ) { std :: deque < timecode_duration_t > :: iterator last = m_available_timecodes . begin ( ) + m_ref_frames . size ( ) + m_b_frames . size ( ) - 1 ; std :: deque < timecode_duration_t > :: iterator cur = start ; while ( cur != end ) { last -> m_duration = std :: max ( last -> m_duration , static_cast < int64_t > ( 0 ) ) + std :: max ( cur -> m_duration , static_cast < int64_t > ( 0 ) ) ; ++ cur ; } } m_available_timecodes . erase ( start , end ) ; m_statistics . m_num_dropped_timecodes += num_surplus_timecodes ; } continue ; } if ( FRAME_TYPE_I == frame . type ) ++ m_statistics . m_num_i_frames ; else if ( FRAME_TYPE_P == frame . type ) ++ m_statistics . m_num_p_frames ; else ++ m_statistics . m_num_b_frames ; if ( FRAME_TYPE_B != frame . type ) flush_frames ( false ) ; frame . data = ( unsigned char * ) safememdup ( packet -> data -> get_buffer ( ) + frame . pos , frame . size ) ; frame . timecode = - 1 ; if ( FRAME_TYPE_B == frame . type ) m_b_frames . push_back ( frame ) ; else m_ref_frames . push_back ( frame ) ; } m_previous_timecode = m_available_timecodes . back ( ) . m_timecode ; return FILE_STATUS_MOREDATA ; } void mpeg4_p2_video_packetizer_c :: extract_config_data ( packet_cptr & packet ) { if ( m_ti . m_private_data ) return ; m_ti . m_private_data = memory_cptr { mpeg4 :: p2 :: parse_config_data ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) , m_config_data ) } ; if ( ! m_ti . m_private_data ) mxerror_tid ( m_ti . m_fname , m_ti . m_id , Y ( " Could ▁ not ▁ find ▁ the ▁ codec ▁ configuration ▁ data ▁ in ▁ the ▁ first ▁ MPEG - 4 ▁ part ▁ 2 ▁ video ▁ frame . ▁ This ▁ track ▁ cannot ▁ be ▁ stored ▁ in ▁ native ▁ mode . \n " ) ) ; fix_codec_string ( ) ; set_codec_private ( m_ti . m_private_data ) ; rerender_track_headers ( ) ; } void mpeg4_p2_video_packetizer_c :: fix_codec_string ( ) { static const unsigned char start_code [ 4 ] = { 0x00 , 0x00 , 0x01 , 0xb2 } ; if ( ! m_ti . m_private_data || ( 0 == m_ti . m_private_data -> get_size ( ) ) ) return ; auto private_data = m_ti . m_private_data -> get_buffer ( ) ; int size = m_ti . m_private_data -> get_size ( ) ; int i ; for ( i = 0 ; 9 < size ; ) { if ( memcmp ( & private_data [ i ] , start_code , 4 ) != 0 ) { ++ i ; -- size ; continue ; } i += 8 ; size -= 8 ; if ( strncasecmp ( ( const char * ) & private_data [ i - 4 ] , " divx " , 4 ) != 0 ) continue ; unsigned char * end_pos = ( unsigned char * ) memchr ( & private_data [ i ] , 0 , size ) ; if ( ! end_pos ) end_pos = & private_data [ i + size ] ; -- end_pos ; if ( ' p ' == * end_pos ) * end_pos = ' n ' ; return ; } } int mpeg4_p2_video_packetizer_c :: process_native ( packet_cptr ) { return FILE_STATUS_MOREDATA ; } void mpeg4_p2_video_packetizer_c :: generate_timecode_and_duration ( ) { if ( 0.0 >= m_fps ) { mxexit ( 1 ) ; } if ( m_available_timecodes . empty ( ) ) { m_previous_timecode = ( int64_t ) ( m_previous_timecode + 1000000000.0 / m_fps ) ; m_available_timecodes . push_back ( timecode_duration_t ( m_previous_timecode , ( int64_t ) ( 1000000000.0 / m_fps ) ) ) ; mxverb ( 3 , boost :: format ( " mpeg4 _ p2 : : flush _ frames ( ) : ▁ Needed ▁ new ▁ timecode ▁ % 1 % \n " ) % m_previous_timecode ) ; ++ m_statistics . m_num_generated_timecodes ; } } void mpeg4_p2_video_packetizer_c :: get_next_timecode_and_duration ( int64_t & timecode , int64_t & duration ) { if ( m_available_timecodes . empty ( ) ) generate_timecode_and_duration ( ) ; timecode = m_available_timecodes . front ( ) . m_timecode ; duration = m_available_timecodes . front ( ) . m_duration ; m_available_timecodes . pop_front ( ) ; } void mpeg4_p2_video_packetizer_c :: flush_frames ( bool end_of_file ) { if ( m_ref_frames . empty ( ) ) return ; if ( m_ref_frames . size ( ) == 1 ) { video_frame_t & frame = m_ref_frames . front ( ) ; if ( - 1 == frame . timecode ) { get_next_timecode_and_duration ( frame . timecode , frame . duration ) ; add_packet ( new packet_t ( new memory_c ( frame . data , frame . size , true ) , frame . timecode , frame . duration ) ) ; } return ; } video_frame_t & bref_frame = m_ref_frames . front ( ) ; video_frame_t & fref_frame = m_ref_frames . back ( ) ; for ( auto & frame : m_b_frames ) get_next_timecode_and_duration ( frame . timecode , frame . duration ) ; get_next_timecode_and_duration ( fref_frame . timecode , fref_frame . duration ) ; add_packet ( new packet_t ( new memory_c ( fref_frame . data , fref_frame . size , true ) , fref_frame . timecode , fref_frame . duration , FRAME_TYPE_P == fref_frame . type ? bref_frame . timecode : VFT_IFRAME ) ) ; for ( auto & frame : m_b_frames ) add_packet ( new packet_t ( new memory_c ( frame . data , frame . size , true ) , frame . timecode , frame . duration , bref_frame . timecode , fref_frame . timecode ) ) ; m_ref_frames . pop_front ( ) ; m_b_frames . clear ( ) ; if ( end_of_file ) m_ref_frames . clear ( ) ; } void mpeg4_p2_video_packetizer_c :: flush_impl ( ) { flush_frames ( true ) ; } void mpeg4_p2_video_packetizer_c :: extract_aspect_ratio ( const unsigned char * buffer , int size ) { if ( m_aspect_ratio_extracted ) return ; if ( ( 0 != m_connected_to ) || display_dimensions_or_aspect_ratio_set ( ) ) { m_aspect_ratio_extracted = true ; return ; } uint32_t num , den ; if ( mpeg4 :: p2 :: extract_par ( buffer , size , num , den ) ) { m_aspect_ratio_extracted = true ; set_video_aspect_ratio ( ( double ) m_hvideo_pixel_width / ( double ) m_hvideo_pixel_height * ( double ) num / ( double ) den , false , OPTION_SOURCE_BITSTREAM ) ; generic_packetizer_c :: set_headers ( ) ; rerender_track_headers ( ) ; mxinfo_tid ( m_ti . m_fname , m_ti . m_id , boost :: format ( Y ( " Extracted ▁ the ▁ aspect ▁ ratio ▁ information ▁ from ▁ the ▁ MPEG4 ▁ layer ▁ 2 ▁ video ▁ data ▁ and ▁ set ▁ the ▁ display ▁ dimensions ▁ to ▁ % 1 % / %2 % . \n " ) ) % m_hvideo_display_width % m_hvideo_display_height ) ; } else if ( 50 <= m_frames_output ) m_aspect_ratio_extracted = true ; } void mpeg4_p2_video_packetizer_c :: extract_size ( const unsigned char * buffer , int size ) { if ( m_size_extracted ) return ; if ( 0 != m_connected_to ) { m_size_extracted = true ; return ; } uint32_t xtr_width , xtr_height ; if ( mpeg4 :: p2 :: extract_size ( buffer , size , xtr_width , xtr_height ) ) { m_size_extracted = true ; if ( ! m_reader -> m_appending && ( ( xtr_width != static_cast < uint32_t > ( m_hvideo_pixel_width ) ) || ( xtr_height != static_cast < uint32_t > ( m_hvideo_pixel_height ) ) ) ) { set_video_pixel_width ( xtr_width ) ; set_video_pixel_height ( xtr_height ) ; if ( ! m_output_is_native && m_ti . m_private_data && ( sizeof ( alBITMAPINFOHEADER ) <= m_ti . m_private_data -> get_size ( ) ) ) { auto bih = reinterpret_cast < alBITMAPINFOHEADER * > ( m_ti . m_private_data -> get_buffer ( ) ) ; put_uint32_le ( & bih -> bi_width , xtr_width ) ; put_uint32_le ( & bih -> bi_height , xtr_height ) ; set_codec_private ( m_ti . m_private_data ) ; } m_hvideo_display_width = - 1 ; m_hvideo_display_height = - 1 ; generic_packetizer_c :: set_headers ( ) ; rerender_track_headers ( ) ; mxinfo_tid ( m_ti . m_fname , m_ti . m_id , boost :: format ( Y ( " The ▁ extracted ▁ values ▁ for ▁ video ▁ width ▁ and ▁ height ▁ from ▁ the ▁ MPEG4 ▁ layer ▁ 2 ▁ video ▁ data ▁ bitstream ▁ differ ▁ from ▁ what ▁ the ▁ values ▁ " " in ▁ the ▁ source ▁ container . ▁ The ▁ ones ▁ from ▁ the ▁ video ▁ data ▁ bitstream ▁ ( %1 % x % 2 % ) ▁ will ▁ be ▁ used . \n " ) ) % xtr_width % xtr_height ) ; } } else if ( 50 <= m_frames_output ) m_aspect_ratio_extracted = true ; } </DOCUMENT>
<DOCUMENT_ID="hyuk-kim-tmax/OFASM-test/tree/master/Mtest/UNKNOWN/MVI01/main.cpp"> # include < stdlib . h > # include < string . h > extern int MVI01 ( char * p_0 , char * p_1 , char * p_2 ) ; int main ( ) { char * p_0 = ( char * ) malloc ( sizeof ( char ) * 7 ) ; char * p_1_0 = ( char * ) malloc ( sizeof ( char ) * 7 ) ; char * p_1 = ( char * ) & p_1_0 ; char * p_2 = ( char * ) malloc ( sizeof ( char ) * 3 ) ; strcpy ( p_0 , " HELLO ▁ " ) ; strcpy ( p_1_0 , " WORLD ▁ " ) ; strcpy ( p_2 , " ! ! " ) ; MVI01 ( p_0 , p_1 , p_2 ) ; MVI01 ( p_0 , p_1 , p_2 ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="Microsoft/PTVS/tree/master/Python/Tests/GlassTests/PythonTests/Python/StepPythonToNative_IterNext/cpp_mod.cpp"> # pragma optimize ( " " , off ) # include < python . h > struct CppObj { PyObject_HEAD } ; PyObject * CppObj_iternext ( PyObject * self ) { Py_RETURN_NONE ; } PyTypeObject * CppObj_type ( ) { static PyTypeObject t = { PyVarObject_HEAD_INIT ( NULL , 0 ) } ; t . tp_name = " cpp _ mod . CppObj " ; t . tp_basicsize = sizeof CppObj ; t . tp_flags = Py_TPFLAGS_DEFAULT ; t . tp_iternext = CppObj_iternext ; return & t ; } PyMethodDef methods [ ] = { NULL } ; PyTypeObject * types [ ] = { CppObj_type ( ) , NULL } ; </DOCUMENT>
<DOCUMENT_ID="einon/affymetrix-power-tools/tree/master/sdk/calvin_files/parameter/test/ParameterFileDataTest.cpp"> # include " calvin _ files / parameter / src / ParameterFileData . h " # include < cppunit / extensions / HelperMacros . h > using namespace affymetrix_calvin_parameter ; class ParameterFileDataTest : public CPPUNIT_NS :: TestFixture { CPPUNIT_TEST_SUITE ( ParameterFileDataTest ) ; CPPUNIT_TEST ( testAccess ) ; CPPUNIT_TEST_SUITE_END ( ) ; public : void setUp ( ) ; void tearDown ( ) ; void testAccess ( ) ; } ; CPPUNIT_TEST_SUITE_REGISTRATION ( ParameterFileDataTest ) ; void ParameterFileDataTest :: setUp ( ) { } void ParameterFileDataTest :: tearDown ( ) { } void ParameterFileDataTest :: testAccess ( ) { ParameterFileData d ; d . ImplementationAttributes ( ) . description = L " d " ; d . ImplementationAttributes ( ) . executableFileName = L " e " ; d . ImplementationAttributes ( ) . name = L " n " ; d . ImplementationAttributes ( ) . version = L " v " ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . description == L " d " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . executableFileName == L " e " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . name == L " n " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . version == L " v " ) ; d . ParameterFileAttributes ( ) . company = L " c " ; d . ParameterFileAttributes ( ) . userName = L " u " ; d . ParameterFileAttributes ( ) . contentVersion = L " cv " ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . company == L " c " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . userName == L " u " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . contentVersion == L " cv " ) ; ParameterType p ; p . name = L " n " ; p . index = L " i " ; p . displayName = L " d " ; p . category = L " c " ; p . isEditable = L " is " ; p . type = L " t " ; p . currentValue = L " cv " ; p . minValue = L " mv " ; p . maxValue = L " xv " ; p . defaultValue = L " dv " ; p . precision = L " p " ; p . maxLength = L " l " ; p . description = L " de " ; CPPUNIT_ASSERT ( p . name == L " n " ) ; CPPUNIT_ASSERT ( p . index == L " i " ) ; CPPUNIT_ASSERT ( p . displayName == L " d " ) ; CPPUNIT_ASSERT ( p . category == L " c " ) ; CPPUNIT_ASSERT ( p . isEditable == L " is " ) ; CPPUNIT_ASSERT ( p . type == L " t " ) ; CPPUNIT_ASSERT ( p . currentValue == L " cv " ) ; CPPUNIT_ASSERT ( p . minValue == L " mv " ) ; CPPUNIT_ASSERT ( p . maxValue == L " xv " ) ; CPPUNIT_ASSERT ( p . defaultValue == L " dv " ) ; CPPUNIT_ASSERT ( p . precision == L " p " ) ; CPPUNIT_ASSERT ( p . maxLength == L " l " ) ; CPPUNIT_ASSERT ( p . description == L " de " ) ; d . Parameters ( ) . push_back ( p ) ; p . name . clear ( ) ; p . index . clear ( ) ; CPPUNIT_ASSERT ( d . Parameters ( ) . size ( ) == 1 ) ; d . Clear ( ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . description == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . executableFileName == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . name == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . version == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . company == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . userName == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . contentVersion == L " " ) ; CPPUNIT_ASSERT ( d . Parameters ( ) . size ( ) == 0 ) ; } </DOCUMENT>
<DOCUMENT_ID="android-ia/platform_external_chromium_org_third_party_WebKit/tree/master/Source/core/dom/PseudoElement.cpp"> # include " config . h " # include " core / dom / PseudoElement . h " # include " core / inspector / InspectorInstrumentation . h " # include " core / rendering / RenderObject . h " # include " core / rendering / RenderQuote . h " # include " core / rendering / style / ContentData . h " namespace blink { const QualifiedName & pseudoElementTagName ( PseudoId pseudoId ) { switch ( pseudoId ) { case AFTER : { DEFINE_STATIC_LOCAL ( QualifiedName , after , ( nullAtom , " < pseudo : after > " , nullAtom ) ) ; return after ; } case BEFORE : { DEFINE_STATIC_LOCAL ( QualifiedName , before , ( nullAtom , " < pseudo : before > " , nullAtom ) ) ; return before ; } case BACKDROP : { DEFINE_STATIC_LOCAL ( QualifiedName , backdrop , ( nullAtom , " < pseudo : backdrop > " , nullAtom ) ) ; return backdrop ; } default : { ASSERT_NOT_REACHED ( ) ; } } DEFINE_STATIC_LOCAL ( QualifiedName , name , ( nullAtom , " < pseudo > " , nullAtom ) ) ; return name ; } String PseudoElement :: pseudoElementNameForEvents ( PseudoId pseudoId ) { DEFINE_STATIC_LOCAL ( const String , after , ( " : : after " ) ) ; DEFINE_STATIC_LOCAL ( const String , before , ( " : : before " ) ) ; switch ( pseudoId ) { case AFTER : return after ; case BEFORE : return before ; default : return emptyString ( ) ; } } PseudoElement :: PseudoElement ( Element * parent , PseudoId pseudoId ) : Element ( pseudoElementTagName ( pseudoId ) , & parent -> document ( ) , CreateElement ) , m_pseudoId ( pseudoId ) { ASSERT ( pseudoId != NOPSEUDO ) ; setParentOrShadowHostNode ( parent ) ; setHasCustomStyleCallbacks ( ) ; } PassRefPtr < RenderStyle > PseudoElement :: customStyleForRenderer ( ) { return parentOrShadowHostElement ( ) -> renderer ( ) -> getCachedPseudoStyle ( m_pseudoId ) ; } void PseudoElement :: dispose ( ) { ASSERT ( parentOrShadowHostElement ( ) ) ; InspectorInstrumentation :: pseudoElementDestroyed ( this ) ; ASSERT ( ! nextSibling ( ) ) ; ASSERT ( ! previousSibling ( ) ) ; detach ( ) ; RefPtrWillBeRawPtr < Element > parent = parentOrShadowHostElement ( ) ; setParentOrShadowHostNode ( 0 ) ; removedFrom ( parent . get ( ) ) ; } void PseudoElement :: attach ( const AttachContext & context ) { ASSERT ( ! renderer ( ) ) ; Element :: attach ( context ) ; RenderObject * renderer = this -> renderer ( ) ; if ( ! renderer ) return ; RenderStyle * style = renderer -> style ( ) ; if ( style -> styleType ( ) != BEFORE && style -> styleType ( ) != AFTER ) return ; ASSERT ( style -> contentData ( ) ) ; for ( const ContentData * content = style -> contentData ( ) ; content ; content = content -> next ( ) ) { RenderObject * child = content -> createRenderer ( document ( ) , style ) ; if ( renderer -> isChildAllowed ( child , style ) ) { renderer -> addChild ( child ) ; if ( child -> isQuote ( ) ) toRenderQuote ( child ) -> attachQuote ( ) ; } else child -> destroy ( ) ; } } bool PseudoElement :: rendererIsNeeded ( const RenderStyle & style ) { return pseudoElementRendererIsNeeded ( & style ) ; } void PseudoElement :: didRecalcStyle ( StyleRecalcChange ) { if ( ! renderer ( ) ) return ; RenderObject * renderer = this -> renderer ( ) ; for ( RenderObject * child = renderer -> nextInPreOrder ( renderer ) ; child ; child = child -> nextInPreOrder ( renderer ) ) { if ( ! child -> isText ( ) && ! child -> isQuote ( ) && ! child -> isImage ( ) ) continue ; if ( child -> style ( ) -> styleType ( ) == FIRST_LETTER ) continue ; child -> setPseudoStyle ( renderer -> style ( ) ) ; } } } </DOCUMENT>
<DOCUMENT_ID="patmarion/PCL/tree/master/sample_consensus/src/ransac.cpp"> # include < pcl / impl / instantiate . hpp > # include < pcl / point_types . h > # include < pcl / sample_consensus / ransac . h > # include < pcl / sample_consensus / impl / ransac . hpp > # ifdef PCL_ONLY_CORE_POINT_TYPES PCL_INSTANTIATE ( RandomSampleConsensus , ( pcl :: PointXYZ ) ( pcl :: PointXYZI ) ( pcl :: PointXYZRGBA ) ( pcl :: PointXYZRGB ) ) # else PCL_INSTANTIATE ( RandomSampleConsensus , PCL_XYZ_POINT_TYPES ) # endif </DOCUMENT>
<DOCUMENT_ID="ondra-novak/blink/tree/master/Source/core/svg/SVGFontFaceUriElement.cpp"> # include " config . h " # if ENABLE ( SVG_FONTS ) # include " core / svg / SVGFontFaceUriElement . h " # include " core / XLinkNames . h " # include " core / css / CSSFontFaceSrcValue . h " # include " core / dom / Document . h " # include " core / fetch / FetchRequest . h " # include " core / fetch / ResourceFetcher . h " # include " core / svg / SVGFontFaceElement . h " namespace blink { using namespace SVGNames ; inline SVGFontFaceUriElement :: SVGFontFaceUriElement ( Document & document ) : SVGElement ( font_face_uriTag , document ) { ScriptWrappable :: init ( this ) ; } DEFINE_NODE_FACTORY ( SVGFontFaceUriElement ) SVGFontFaceUriElement :: ~ SVGFontFaceUriElement ( ) { if ( m_resource ) m_resource -> removeClient ( this ) ; } PassRefPtrWillBeRawPtr < CSSFontFaceSrcValue > SVGFontFaceUriElement :: srcValue ( ) const { RefPtrWillBeRawPtr < CSSFontFaceSrcValue > src = CSSFontFaceSrcValue :: create ( getAttribute ( XLinkNames :: hrefAttr ) ) ; AtomicString value ( fastGetAttribute ( formatAttr ) ) ; src -> setFormat ( value . isEmpty ( ) ? " svg " : value ) ; return src . release ( ) ; } void SVGFontFaceUriElement :: parseAttribute ( const QualifiedName & name , const AtomicString & value ) { if ( name . matches ( XLinkNames :: hrefAttr ) ) loadFont ( ) ; else SVGElement :: parseAttribute ( name , value ) ; } void SVGFontFaceUriElement :: childrenChanged ( const ChildrenChange & change ) { SVGElement :: childrenChanged ( change ) ; if ( ! isSVGFontFaceSrcElement ( parentNode ( ) ) ) return ; ContainerNode * grandparent = parentNode ( ) -> parentNode ( ) ; if ( isSVGFontFaceElement ( grandparent ) ) toSVGFontFaceElement ( * grandparent ) . rebuildFontFace ( ) ; } Node :: InsertionNotificationRequest SVGFontFaceUriElement :: insertedInto ( ContainerNode * rootParent ) { loadFont ( ) ; return SVGElement :: insertedInto ( rootParent ) ; } void SVGFontFaceUriElement :: loadFont ( ) { if ( m_resource ) m_resource -> removeClient ( this ) ; const AtomicString & href = getAttribute ( XLinkNames :: hrefAttr ) ; if ( ! href . isNull ( ) ) { ResourceFetcher * fetcher = document ( ) . fetcher ( ) ; FetchRequest request ( ResourceRequest ( document ( ) . completeURL ( href ) ) , localName ( ) ) ; m_resource = fetcher -> fetchFont ( request ) ; if ( m_resource ) { m_resource -> addClient ( this ) ; m_resource -> beginLoadIfNeeded ( fetcher ) ; } } else { m_resource = 0 ; } } } # endif </DOCUMENT>
<DOCUMENT_ID="punker76/Windows-universal-samples/tree/master/Samples/XamlCloudFontIntegration/cpp/Scenario_Document1.xaml.cpp"> # include " pch . h " # include " Scenario _ Document1 . xaml . h " using namespace SDKTemplate ; using namespace Platform ; using namespace Windows :: Foundation ; using namespace Windows :: Foundation :: Collections ; using namespace Windows :: UI :: Xaml ; using namespace Windows :: UI :: Xaml :: Controls ; using namespace Windows :: UI :: Xaml :: Controls :: Primitives ; using namespace Windows :: UI :: Xaml :: Data ; using namespace Windows :: UI :: Xaml :: Input ; using namespace Windows :: UI :: Xaml :: Media ; using namespace Windows :: UI :: Xaml :: Navigation ; Scenario_Document1 :: Scenario_Document1 ( ) { InitializeComponent ( ) ; } void Scenario_Document1 :: Page_Loaded ( Platform :: Object ^ sender , Windows :: UI :: Xaml :: RoutedEventArgs ^ e ) { this -> FontFamily = ref new Windows :: UI :: Xaml :: Media :: FontFamily ( " Neue ▁ Haas ▁ Grotesk ▁ Text ▁ Pro " ) ; } </DOCUMENT>
<DOCUMENT_ID="alejocb/rgbdtam/tree/master/ThirdParty/g2o/g2o/core/marginal_covariance_cholesky.cpp"> # include " marginal _ covariance _ cholesky . h " # include < algorithm > # include < cassert > using namespace std ; namespace g2o { struct MatrixElem { int r , c ; MatrixElem ( int r_ , int c_ ) : r ( r_ ) , c ( c_ ) { } bool operator < ( const MatrixElem & other ) const { return c > other . c || ( c == other . c && r > other . r ) ; } } ; MarginalCovarianceCholesky :: MarginalCovarianceCholesky ( ) : _n ( 0 ) , _Ap ( 0 ) , _Ai ( 0 ) , _Ax ( 0 ) , _perm ( 0 ) { } MarginalCovarianceCholesky :: ~ MarginalCovarianceCholesky ( ) { } void MarginalCovarianceCholesky :: setCholeskyFactor ( int n , int * Lp , int * Li , double * Lx , int * permInv ) { _n = n ; _Ap = Lp ; _Ai = Li ; _Ax = Lx ; _perm = permInv ; _diag . resize ( n ) ; for ( int r = 0 ; r < n ; ++ r ) { const int & sc = _Ap [ r ] ; assert ( r == _Ai [ sc ] && " Error ▁ in ▁ CCS ▁ storage ▁ of ▁ L " ) ; _diag [ r ] = 1.0 / _Ax [ sc ] ; } } double MarginalCovarianceCholesky :: computeEntry ( int r , int c ) { assert ( r <= c ) ; int idx = computeIndex ( r , c ) ; LookupMap :: const_iterator foundIt = _map . find ( idx ) ; if ( foundIt != _map . end ( ) ) { return foundIt -> second ; } double s = 0. ; const int & sc = _Ap [ r ] ; const int & ec = _Ap [ r + 1 ] ; for ( int j = sc + 1 ; j < ec ; ++ j ) { const int & rr = _Ai [ j ] ; double val = rr < c ? computeEntry ( rr , c ) : computeEntry ( c , rr ) ; s += val * _Ax [ j ] ; } double result ; if ( r == c ) { const double & diagElem = _diag [ r ] ; result = diagElem * ( diagElem - s ) ; } else { result = - s * _diag [ r ] ; } _map [ idx ] = result ; return result ; } void MarginalCovarianceCholesky :: computeCovariance ( double * * covBlocks , const std :: vector < int > & blockIndices ) { _map . clear ( ) ; int base = 0 ; vector < MatrixElem > elemsToCompute ; for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int nbase = blockIndices [ i ] ; int vdim = nbase - base ; for ( int rr = 0 ; rr < vdim ; ++ rr ) for ( int cc = rr ; cc < vdim ; ++ cc ) { int r = _perm ? _perm [ rr + base ] : rr + base ; int c = _perm ? _perm [ cc + base ] : cc + base ; if ( r > c ) swap ( r , c ) ; elemsToCompute . push_back ( MatrixElem ( r , c ) ) ; } base = nbase ; } sort ( elemsToCompute . begin ( ) , elemsToCompute . end ( ) ) ; for ( size_t i = 0 ; i < elemsToCompute . size ( ) ; ++ i ) { const MatrixElem & me = elemsToCompute [ i ] ; computeEntry ( me . r , me . c ) ; } base = 0 ; for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int nbase = blockIndices [ i ] ; int vdim = nbase - base ; double * cov = covBlocks [ i ] ; for ( int rr = 0 ; rr < vdim ; ++ rr ) for ( int cc = rr ; cc < vdim ; ++ cc ) { int r = _perm ? _perm [ rr + base ] : rr + base ; int c = _perm ? _perm [ cc + base ] : cc + base ; if ( r > c ) swap ( r , c ) ; int idx = computeIndex ( r , c ) ; LookupMap :: const_iterator foundIt = _map . find ( idx ) ; assert ( foundIt != _map . end ( ) ) ; cov [ rr * vdim + cc ] = foundIt -> second ; if ( rr != cc ) cov [ cc * vdim + rr ] = foundIt -> second ; } base = nbase ; } } void MarginalCovarianceCholesky :: computeCovariance ( SparseBlockMatrix < MatrixXd > & spinv , const std :: vector < int > & rowBlockIndices , const std :: vector < std :: pair < int , int > > & blockIndices ) { spinv = SparseBlockMatrix < MatrixXd > ( & rowBlockIndices [ 0 ] , & rowBlockIndices [ 0 ] , rowBlockIndices . size ( ) , rowBlockIndices . size ( ) , true ) ; _map . clear ( ) ; vector < MatrixElem > elemsToCompute ; for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int blockRow = blockIndices [ i ] . first ; int blockCol = blockIndices [ i ] . second ; assert ( blockRow >= 0 ) ; assert ( blockRow < ( int ) rowBlockIndices . size ( ) ) ; assert ( blockCol >= 0 ) ; assert ( blockCol < ( int ) rowBlockIndices . size ( ) ) ; int rowBase = spinv . rowBaseOfBlock ( blockRow ) ; int colBase = spinv . colBaseOfBlock ( blockCol ) ; MatrixXd * block = spinv . block ( blockRow , blockCol , true ) ; assert ( block ) ; for ( int iRow = 0 ; iRow < block -> rows ( ) ; ++ iRow ) for ( int iCol = 0 ; iCol < block -> cols ( ) ; ++ iCol ) { int rr = rowBase + iRow ; int cc = colBase + iCol ; int r = _perm ? _perm [ rr ] : rr ; int c = _perm ? _perm [ cc ] : cc ; if ( r > c ) swap ( r , c ) ; elemsToCompute . push_back ( MatrixElem ( r , c ) ) ; } } sort ( elemsToCompute . begin ( ) , elemsToCompute . end ( ) ) ; for ( size_t i = 0 ; i < elemsToCompute . size ( ) ; ++ i ) { const MatrixElem & me = elemsToCompute [ i ] ; computeEntry ( me . r , me . c ) ; } for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int blockRow = blockIndices [ i ] . first ; int blockCol = blockIndices [ i ] . second ; int rowBase = spinv . rowBaseOfBlock ( blockRow ) ; int colBase = spinv . colBaseOfBlock ( blockCol ) ; MatrixXd * block = spinv . block ( blockRow , blockCol ) ; assert ( block ) ; for ( int iRow = 0 ; iRow < block -> rows ( ) ; ++ iRow ) for ( int iCol = 0 ; iCol < block -> cols ( ) ; ++ iCol ) { int rr = rowBase + iRow ; int cc = colBase + iCol ; int r = _perm ? _perm [ rr ] : rr ; int c = _perm ? _perm [ cc ] : cc ; if ( r > c ) swap ( r , c ) ; int idx = computeIndex ( r , c ) ; LookupMap :: const_iterator foundIt = _map . find ( idx ) ; assert ( foundIt != _map . end ( ) ) ; ( * block ) ( iRow , iCol ) = foundIt -> second ; } } } } </DOCUMENT>
<DOCUMENT_ID="attilahorvath/phantomjs/tree/master/src/qt/qtwebkit/Source/JavaScriptCore/llint/LLIntEntrypoints.cpp"> # include " config . h " # include " LLIntEntrypoints . h " # if ENABLE ( LLINT ) # include " JITCode . h " # include " VM . h " # include " JSObject . h " # include " LLIntThunks . h " # include " LowLevelInterpreter . h " namespace JSC { namespace LLInt { void getFunctionEntrypoint ( VM & vm , CodeSpecializationKind kind , JITCode & jitCode , MacroAssemblerCodePtr & arityCheck ) { if ( ! vm . canUseJIT ( ) ) { if ( kind == CodeForCall ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_function_for_call_prologue ) , JITCode :: InterpreterThunk ) ; arityCheck = MacroAssemblerCodePtr :: createLLIntCodePtr ( llint_function_for_call_arity_check ) ; return ; } ASSERT ( kind == CodeForConstruct ) ; jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_function_for_construct_prologue ) , JITCode :: InterpreterThunk ) ; arityCheck = MacroAssemblerCodePtr :: createLLIntCodePtr ( llint_function_for_construct_arity_check ) ; return ; } # if ENABLE ( JIT ) if ( kind == CodeForCall ) { jitCode = JITCode ( vm . getCTIStub ( functionForCallEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; arityCheck = vm . getCTIStub ( functionForCallArityCheckThunkGenerator ) . code ( ) ; return ; } ASSERT ( kind == CodeForConstruct ) ; jitCode = JITCode ( vm . getCTIStub ( functionForConstructEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; arityCheck = vm . getCTIStub ( functionForConstructArityCheckThunkGenerator ) . code ( ) ; # endif } void getEvalEntrypoint ( VM & vm , JITCode & jitCode ) { if ( ! vm . canUseJIT ( ) ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_eval_prologue ) , JITCode :: InterpreterThunk ) ; return ; } # if ENABLE ( JIT ) jitCode = JITCode ( vm . getCTIStub ( evalEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; # endif } void getProgramEntrypoint ( VM & vm , JITCode & jitCode ) { if ( ! vm . canUseJIT ( ) ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_program_prologue ) , JITCode :: InterpreterThunk ) ; return ; } # if ENABLE ( JIT ) jitCode = JITCode ( vm . getCTIStub ( programEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; # endif } } } # endif </DOCUMENT>
<DOCUMENT_ID="braindx/scummvm/tree/master/engines/titanic/gfx/icon_nav_receive.cpp"> # include " titanic / gfx / icon _ nav _ receive . h " namespace Titanic { EMPTY_MESSAGE_MAP ( CIconNavReceive , CPetGraphic ) ; void CIconNavReceive :: save ( SimpleFile * file , int indent ) { file -> writeNumberLine ( 1 , indent ) ; CPetGraphic :: save ( file , indent ) ; } void CIconNavReceive :: load ( SimpleFile * file ) { file -> readNumber ( ) ; CPetGraphic :: load ( file ) ; } } </DOCUMENT>
<DOCUMENT_ID="Greymane/SkyFireEMU/tree/master/dep/acelite/ace/OS_NS_errno.cpp"> # include " ace / OS _ NS _ errno . h " # if ! defined ( ACE_HAS_INLINED_OSCALLS ) # include " ace / OS _ NS _ errno . inl " # endif </DOCUMENT>
