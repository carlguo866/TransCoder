<DOCUMENT_ID="qtproject/qtwebkit/tree/master/Source/WebCore/html/HTMLFrameSetElement.cpp"> # include " config . h " # include " HTMLFrameSetElement . h " # include " CSSPropertyNames . h " # include " Document . h " # include " ElementIterator . h " # include " Event . h " # include " EventNames . h " # include " Frame . h " # include " FrameLoader . h " # include " FrameLoaderClient . h " # include " HTMLBodyElement . h " # include " HTMLNames . h " # include " Length . h " # include " MouseEvent . h " # include " RenderFrameSet . h " # include " Text . h " namespace WebCore { using namespace HTMLNames ; HTMLFrameSetElement :: HTMLFrameSetElement ( const QualifiedName & tagName , Document & document ) : HTMLElement ( tagName , document ) , m_totalRows ( 1 ) , m_totalCols ( 1 ) , m_border ( 6 ) , m_borderSet ( false ) , m_borderColorSet ( false ) , m_frameborder ( true ) , m_frameborderSet ( false ) , m_noresize ( false ) { ASSERT ( hasTagName ( framesetTag ) ) ; setHasCustomStyleResolveCallbacks ( ) ; } Ref < HTMLFrameSetElement > HTMLFrameSetElement :: create ( const QualifiedName & tagName , Document & document ) { return adoptRef ( * new HTMLFrameSetElement ( tagName , document ) ) ; } bool HTMLFrameSetElement :: isPresentationAttribute ( const QualifiedName & name ) const { if ( name == bordercolorAttr ) return true ; return HTMLElement :: isPresentationAttribute ( name ) ; } void HTMLFrameSetElement :: collectStyleForPresentationAttribute ( const QualifiedName & name , const AtomicString & value , MutableStyleProperties & style ) { if ( name == bordercolorAttr ) addHTMLColorToStyle ( style , CSSPropertyBorderColor , value ) ; else HTMLElement :: collectStyleForPresentationAttribute ( name , value , style ) ; } void HTMLFrameSetElement :: parseAttribute ( const QualifiedName & name , const AtomicString & value ) { if ( name == rowsAttr ) { if ( ! value . isNull ( ) ) { m_rowLengths = newLengthArray ( value . string ( ) , m_totalRows ) ; setNeedsStyleRecalc ( ) ; } return ; } if ( name == colsAttr ) { if ( ! value . isNull ( ) ) { m_colLengths = newLengthArray ( value . string ( ) , m_totalCols ) ; setNeedsStyleRecalc ( ) ; } return ; } if ( name == frameborderAttr ) { if ( ! value . isNull ( ) ) { if ( equalLettersIgnoringASCIICase ( value , " no " ) || value == "0" ) { m_frameborder = false ; m_frameborderSet = true ; } else if ( equalLettersIgnoringASCIICase ( value , " yes " ) || value == "1" ) { m_frameborderSet = true ; } } else { m_frameborder = false ; m_frameborderSet = false ; } return ; } if ( name == noresizeAttr ) { m_noresize = true ; return ; } if ( name == borderAttr ) { if ( ! value . isNull ( ) ) { m_border = value . toInt ( ) ; m_borderSet = true ; } else m_borderSet = false ; return ; } if ( name == bordercolorAttr ) { m_borderColorSet = ! value . isEmpty ( ) ; return ; } auto & eventName = HTMLBodyElement :: eventNameForWindowEventHandlerAttribute ( name ) ; if ( ! eventName . isNull ( ) ) { document ( ) . setWindowAttributeEventListener ( eventName , name , value ) ; return ; } HTMLElement :: parseAttribute ( name , value ) ; } bool HTMLFrameSetElement :: rendererIsNeeded ( const RenderStyle & style ) { return style . isStyleAvailable ( ) ; } RenderPtr < RenderElement > HTMLFrameSetElement :: createElementRenderer ( Ref < RenderStyle > && style , const RenderTreePosition & ) { if ( style . get ( ) . hasContent ( ) ) return RenderElement :: createFor ( * this , WTFMove ( style ) ) ; return createRenderer < RenderFrameSet > ( * this , WTFMove ( style ) ) ; } HTMLFrameSetElement * HTMLFrameSetElement :: findContaining ( Element * descendant ) { return ancestorsOfType < HTMLFrameSetElement > ( * descendant ) . first ( ) ; } void HTMLFrameSetElement :: willAttachRenderers ( ) { const HTMLFrameSetElement * containingFrameSet = findContaining ( this ) ; if ( ! containingFrameSet ) return ; if ( ! m_frameborderSet ) m_frameborder = containingFrameSet -> hasFrameBorder ( ) ; if ( m_frameborder ) { if ( ! m_borderSet ) m_border = containingFrameSet -> border ( ) ; if ( ! m_borderColorSet ) m_borderColorSet = containingFrameSet -> hasBorderColor ( ) ; } if ( ! m_noresize ) m_noresize = containingFrameSet -> noResize ( ) ; } void HTMLFrameSetElement :: defaultEventHandler ( Event * event ) { ASSERT ( event ) ; if ( is < MouseEvent > ( * event ) && ! m_noresize && is < RenderFrameSet > ( renderer ( ) ) ) { if ( downcast < RenderFrameSet > ( * renderer ( ) ) . userResize ( downcast < MouseEvent > ( event ) ) ) { event -> setDefaultHandled ( ) ; return ; } } HTMLElement :: defaultEventHandler ( event ) ; } bool HTMLFrameSetElement :: willRecalcStyle ( Style :: Change ) { if ( needsStyleRecalc ( ) && renderer ( ) ) { renderer ( ) -> setNeedsLayout ( ) ; clearNeedsStyleRecalc ( ) ; } return true ; } Node :: InsertionNotificationRequest HTMLFrameSetElement :: insertedInto ( ContainerNode & insertionPoint ) { HTMLElement :: insertedInto ( insertionPoint ) ; if ( insertionPoint . inDocument ( ) ) { if ( Frame * frame = document ( ) . frame ( ) ) frame -> loader ( ) . client ( ) . dispatchDidBecomeFrameset ( document ( ) . isFrameSet ( ) ) ; } return InsertionDone ; } void HTMLFrameSetElement :: removedFrom ( ContainerNode & insertionPoint ) { HTMLElement :: removedFrom ( insertionPoint ) ; if ( insertionPoint . inDocument ( ) ) { if ( Frame * frame = document ( ) . frame ( ) ) frame -> loader ( ) . client ( ) . dispatchDidBecomeFrameset ( document ( ) . isFrameSet ( ) ) ; } } } </DOCUMENT>
<DOCUMENT_ID="NeuroRoboticTech/AnimatLabPublicSource/tree/master/Libraries/AnimatCarlSimCUDA/CsClassFactory.cpp"> # include " StdAfx . h " # include " CsNeuralModule . h " # include " CsNeuronGroup . h " # include " CsSpikeGeneratorGroup . h " # include " CsSynapseGroup . h " # include " CsSynapseOneToOne . h " # include " CsSynapseFull . h " # include " CsSynapseRandom . h " # include " CsSynapseIndividual . h " # include " CsSpikingCurrentSynapse . h " # include " CsFiringRateStimulus . h " # include " CsNeuronDataColumn . h " # include " CsAdapter . h " # include " CsClassFactory . h " namespace AnimatCarlSim { CsClassFactory :: CsClassFactory ( ) { } CsClassFactory :: ~ CsClassFactory ( ) { } Node * CsClassFactory :: CreateNeuron ( std :: string strType , bool bThrowError ) { Node * lpNeuron = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NEURONGROUP " ) lpNeuron = new CsNeuronGroup ; else if ( strType == " SPIKEGENERATORGROUP " ) lpNeuron = new CsSpikeGeneratorGroup ; else { lpNeuron = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Cs_Err_lInvalidNeuronType , Cs_Err_strInvalidNeuronType , " NeuronType " , strType ) ; } return lpNeuron ; } catch ( CStdErrorInfo oError ) { if ( lpNeuron ) delete lpNeuron ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpNeuron ) delete lpNeuron ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } AnimatSim :: Link * CsClassFactory :: CreateSynapse ( std :: string strType , bool bThrowError ) { AnimatSim :: Link * lpSynapse = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " ONETOONESYNAPSE " ) lpSynapse = new CsSynapseOneToOne ; else if ( strType == " FULLSYNAPSE " ) lpSynapse = new CsSynapseFull ; else if ( strType == " RANDOMSYNAPSE " ) lpSynapse = new CsSynapseRandom ; else if ( strType == " INDIVIDUALSYNAPSE " ) lpSynapse = new CsSynapseIndividual ; else if ( strType == " SPIKINGCURRENTSYNAPSE " ) lpSynapse = new CsSpikingCurrentSynapse ; else { lpSynapse = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Cs_Err_lInvalidSynapseType , Cs_Err_strInvalidSynapseType , " SynapseType " , strType ) ; } return lpSynapse ; } catch ( CStdErrorInfo oError ) { if ( lpSynapse ) delete lpSynapse ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpSynapse ) delete lpSynapse ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } NeuralModule * CsClassFactory :: CreateNeuralModule ( std :: string strType , bool bThrowError ) { NeuralModule * lpModule = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " CARLSIMNEURALMODULE " ) lpModule = new CsNeuralModule ; else { lpModule = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalidNeuralModuleType , Al_Err_strInvalidNeuralModuleType , " NeuralModule " , strType ) ; } return lpModule ; } catch ( CStdErrorInfo oError ) { if ( lpModule ) delete lpModule ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpModule ) delete lpModule ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } ExternalStimulus * CsClassFactory :: CreateExternalStimulus ( std :: string strType , bool bThrowError ) { ExternalStimulus * lpStimulus = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " FIRINGRATE " ) lpStimulus = new CsFiringRateStimulus ; else { lpStimulus = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalidExternalStimulusType , Al_Err_strInvalidExternalStimulusType , " ExternalStimulusType " , strType ) ; } return lpStimulus ; } catch ( CStdErrorInfo oError ) { if ( lpStimulus ) delete lpStimulus ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpStimulus ) delete lpStimulus ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } DataColumn * CsClassFactory :: CreateDataColumn ( std :: string strType , bool bThrowError ) { DataColumn * lpColumn = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NEURONDATACOLUMN " ) lpColumn = new CsNeuronDataColumn ; else { lpColumn = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalidDataColumnType , Al_Err_strInvalidDataColumnType , " DataColumnType " , strType ) ; } return lpColumn ; } catch ( CStdErrorInfo oError ) { if ( lpColumn ) delete lpColumn ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpColumn ) delete lpColumn ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } Adapter * CsClassFactory :: CreateAdapter ( std :: string strType , bool bThrowError ) { Adapter * lpAdapter = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NODETONODE " ) lpAdapter = new CsAdapter ; else if ( strType == " PHYSICALTONODE " ) lpAdapter = new CsAdapter ; else { lpAdapter = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalidAdapterType , Al_Err_strInvalidAdapterType , " AdapterType " , strType ) ; } return lpAdapter ; } catch ( CStdErrorInfo oError ) { if ( lpAdapter ) delete lpAdapter ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpAdapter ) delete lpAdapter ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } CStdSerialize * CsClassFactory :: CreateObject ( std :: string strClassType , std :: string strObjectType , bool bThrowError ) { CStdSerialize * lpObject = NULL ; strClassType = Std_ToUpper ( Std_Trim ( strClassType ) ) ; if ( strClassType == " NEURON " ) lpObject = CreateNeuron ( strObjectType , bThrowError ) ; else if ( strClassType == " SYNAPSE " ) lpObject = CreateSynapse ( strObjectType , bThrowError ) ; else if ( strClassType == " NEURALMODULE " ) lpObject = CreateNeuralModule ( strObjectType , bThrowError ) ; else if ( strClassType == " EXTERNALSTIMULUS " ) lpObject = CreateExternalStimulus ( strObjectType , bThrowError ) ; else if ( strClassType == " DATACOLUMN " ) lpObject = CreateDataColumn ( strObjectType , bThrowError ) ; else if ( strClassType == " ADAPTER " ) lpObject = CreateAdapter ( strObjectType , bThrowError ) ; else { lpObject = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Std_Err_lInvalidClassType , Std_Err_strInvalidClassType , " ClassType " , strClassType ) ; } return lpObject ; } } # ifdef WIN32 extern " C " __declspec ( dllexport ) IStdClassFactory * __cdecl GetStdClassFactory ( ) # else extern " C " IStdClassFactory * GetStdClassFactory ( ) # endif { IStdClassFactory * lpFactory = new CsClassFactory ; return lpFactory ; } </DOCUMENT>
<DOCUMENT_ID="mur47x111/JDK8-concurrent-tagging/tree/master/src/share/vm/gc_implementation/concurrentMarkSweep/vmCMSOperations.cpp"> # include " precompiled . hpp " # include " gc _ implementation / concurrentMarkSweep / concurrentMarkSweepGeneration . inline . hpp " # include " gc _ implementation / concurrentMarkSweep / concurrentMarkSweepThread . hpp " # include " gc _ implementation / concurrentMarkSweep / vmCMSOperations . hpp " # include " gc _ implementation / shared / gcTimer . hpp " # include " gc _ implementation / shared / gcTraceTime . hpp " # include " gc _ implementation / shared / isGCActiveMark . hpp " # include " memory / gcLocker . inline . hpp " # include " runtime / interfaceSupport . hpp " # include " runtime / os . hpp " # include " utilities / dtrace . hpp " # ifndef USDT2 HS_DTRACE_PROBE_DECL ( hs_private , cms__initmark__begin ) ; HS_DTRACE_PROBE_DECL ( hs_private , cms__initmark__end ) ; HS_DTRACE_PROBE_DECL ( hs_private , cms__remark__begin ) ; HS_DTRACE_PROBE_DECL ( hs_private , cms__remark__end ) ; # endif void VM_CMS_Operation :: acquire_pending_list_lock ( ) { ConcurrentMarkSweepThread :: slt ( ) -> manipulatePLL ( SurrogateLockerThread :: acquirePLL ) ; } void VM_CMS_Operation :: release_and_notify_pending_list_lock ( ) { ConcurrentMarkSweepThread :: slt ( ) -> manipulatePLL ( SurrogateLockerThread :: releaseAndNotifyPLL ) ; } void VM_CMS_Operation :: verify_before_gc ( ) { if ( VerifyBeforeGC && GenCollectedHeap :: heap ( ) -> total_collections ( ) >= VerifyGCStartAt ) { GCTraceTime tm ( " Verify ▁ Before " , false , false , _collector -> _gc_timer_cm ) ; HandleMark hm ; FreelistLocker x ( _collector ) ; MutexLockerEx y ( _collector -> bitMapLock ( ) , Mutex :: _no_safepoint_check_flag ) ; Universe :: heap ( ) -> prepare_for_verify ( ) ; Universe :: verify ( ) ; } } void VM_CMS_Operation :: verify_after_gc ( ) { if ( VerifyAfterGC && GenCollectedHeap :: heap ( ) -> total_collections ( ) >= VerifyGCStartAt ) { GCTraceTime tm ( " Verify ▁ After " , false , false , _collector -> _gc_timer_cm ) ; HandleMark hm ; FreelistLocker x ( _collector ) ; MutexLockerEx y ( _collector -> bitMapLock ( ) , Mutex :: _no_safepoint_check_flag ) ; Universe :: verify ( ) ; } } bool VM_CMS_Operation :: lost_race ( ) const { if ( CMSCollector :: abstract_state ( ) == CMSCollector :: Idling ) { return true ; } assert ( CMSCollector :: abstract_state ( ) == legal_state ( ) , " Inconsistent ▁ collector ▁ state ? " ) ; return false ; } bool VM_CMS_Operation :: doit_prologue ( ) { assert ( Thread :: current ( ) -> is_ConcurrentGC_thread ( ) , " just ▁ checking " ) ; assert ( ! CMSCollector :: foregroundGCShouldWait ( ) , " Possible ▁ deadlock " ) ; assert ( ! ConcurrentMarkSweepThread :: cms_thread_has_cms_token ( ) , " Possible ▁ deadlock " ) ; if ( needs_pll ( ) ) { acquire_pending_list_lock ( ) ; } Heap_lock -> lock ( ) ; if ( lost_race ( ) ) { assert ( _prologue_succeeded == false , " Initialized ▁ in ▁ c ' tor " ) ; Heap_lock -> unlock ( ) ; if ( needs_pll ( ) ) { release_and_notify_pending_list_lock ( ) ; } } else { _prologue_succeeded = true ; } return _prologue_succeeded ; } void VM_CMS_Operation :: doit_epilogue ( ) { assert ( Thread :: current ( ) -> is_ConcurrentGC_thread ( ) , " just ▁ checking " ) ; assert ( ! CMSCollector :: foregroundGCShouldWait ( ) , " Possible ▁ deadlock " ) ; assert ( ! ConcurrentMarkSweepThread :: cms_thread_has_cms_token ( ) , " Possible ▁ deadlock " ) ; Heap_lock -> unlock ( ) ; if ( needs_pll ( ) ) { release_and_notify_pending_list_lock ( ) ; } } void VM_CMS_Initial_Mark :: doit ( ) { if ( lost_race ( ) ) { return ; } # ifndef USDT2 HS_DTRACE_PROBE ( hs_private , cms__initmark__begin ) ; # else HS_PRIVATE_CMS_INITMARK_BEGIN ( ) ; # endif _collector -> _gc_timer_cm -> register_gc_pause_start ( " Initial ▁ Mark " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; GCCauseSetter gccs ( gch , GCCause :: _cms_initial_mark ) ; VM_CMS_Operation :: verify_before_gc ( ) ; IsGCActiveMark x ; _collector -> do_CMS_operation ( CMSCollector :: CMS_op_checkpointRootsInitial , gch -> gc_cause ( ) ) ; VM_CMS_Operation :: verify_after_gc ( ) ; _collector -> _gc_timer_cm -> register_gc_pause_end ( ) ; # ifndef USDT2 HS_DTRACE_PROBE ( hs_private , cms__initmark__end ) ; # else HS_PRIVATE_CMS_INITMARK_END ( ) ; # endif } void VM_CMS_Final_Remark :: doit ( ) { if ( lost_race ( ) ) { return ; } # ifndef USDT2 HS_DTRACE_PROBE ( hs_private , cms__remark__begin ) ; # else HS_PRIVATE_CMS_REMARK_BEGIN ( ) ; # endif _collector -> _gc_timer_cm -> register_gc_pause_start ( " Final ▁ Mark " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; GCCauseSetter gccs ( gch , GCCause :: _cms_final_remark ) ; VM_CMS_Operation :: verify_before_gc ( ) ; IsGCActiveMark x ; _collector -> do_CMS_operation ( CMSCollector :: CMS_op_checkpointRootsFinal , gch -> gc_cause ( ) ) ; VM_CMS_Operation :: verify_after_gc ( ) ; _collector -> save_heap_summary ( ) ; _collector -> _gc_timer_cm -> register_gc_pause_end ( ) ; # ifndef USDT2 HS_DTRACE_PROBE ( hs_private , cms__remark__end ) ; # else HS_PRIVATE_CMS_REMARK_END ( ) ; # endif } void VM_GenCollectFullConcurrent :: doit ( ) { assert ( Thread :: current ( ) -> is_VM_thread ( ) , " Should ▁ be ▁ VM ▁ thread " ) ; assert ( GCLockerInvokesConcurrent || ExplicitGCInvokesConcurrent , " Unexpected " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; if ( _gc_count_before == gch -> total_collections ( ) ) { assert ( SafepointSynchronize :: is_at_safepoint ( ) , " We ▁ can ▁ only ▁ be ▁ executing ▁ this ▁ arm ▁ of ▁ if ▁ at ▁ a ▁ safepoint " ) ; GCCauseSetter gccs ( gch , _gc_cause ) ; gch -> do_full_collection ( gch -> must_clear_all_soft_refs ( ) , 0 ) ; } assert ( ( _gc_count_before < gch -> total_collections ( ) ) || ( GC_locker :: is_active ( ) && ( _gc_count_before == gch -> total_collections ( ) ) ) , " total _ collections ( ) ▁ should ▁ be ▁ monotonically ▁ increasing " ) ; MutexLockerEx x ( FullGCCount_lock , Mutex :: _no_safepoint_check_flag ) ; assert ( _full_gc_count_before <= gch -> total_full_collections ( ) , " Error " ) ; if ( gch -> total_full_collections ( ) == _full_gc_count_before ) { CMSCollector :: disable_icms ( ) ; _disabled_icms = true ; CMSCollector :: start_icms ( ) ; CMSCollector :: request_full_gc ( _full_gc_count_before , _gc_cause ) ; } else { assert ( _full_gc_count_before < gch -> total_full_collections ( ) , " Error " ) ; FullGCCount_lock -> notify_all ( ) ; } } bool VM_GenCollectFullConcurrent :: evaluate_at_safepoint ( ) const { Thread * thr = Thread :: current ( ) ; assert ( thr != NULL , " Unexpected ▁ tid " ) ; if ( ! thr -> is_Java_thread ( ) ) { assert ( thr -> is_VM_thread ( ) , " Expected ▁ to ▁ be ▁ evaluated ▁ by ▁ VM ▁ thread " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; if ( _gc_count_before != gch -> total_collections ( ) ) { assert ( _gc_count_before < gch -> total_collections ( ) , " total _ collections ( ) ▁ should ▁ be ▁ monotnically ▁ increasing " ) ; return false ; } } return true ; } void VM_GenCollectFullConcurrent :: doit_epilogue ( ) { Thread * thr = Thread :: current ( ) ; assert ( thr -> is_Java_thread ( ) , " just ▁ checking " ) ; JavaThread * jt = ( JavaThread * ) thr ; Heap_lock -> unlock ( ) ; release_and_notify_pending_list_lock ( ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; if ( _gc_cause != GCCause :: _gc_locker && gch -> total_full_collections_completed ( ) <= _full_gc_count_before ) { assert ( _gc_cause == GCCause :: _java_lang_system_gc , " the ▁ only ▁ way ▁ to ▁ get ▁ here ▁ if ▁ this ▁ was ▁ a ▁ System . gc ( ) - induced ▁ GC " ) ; assert ( ExplicitGCInvokesConcurrent , " Error " ) ; ThreadToNativeFromVM native ( jt ) ; MutexLockerEx ml ( FullGCCount_lock , Mutex :: _no_safepoint_check_flag ) ; while ( gch -> total_full_collections_completed ( ) <= _full_gc_count_before ) { FullGCCount_lock -> wait ( Mutex :: _no_safepoint_check_flag ) ; } } if ( _disabled_icms ) { CMSCollector :: enable_icms ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="hkernbach/arangodb/tree/master/3rdParty/boost/1.62.0/libs/phoenix/test/include/core/visit_each.cpp"> # include < boost / phoenix / core / visit_each . hpp > int main ( ) { } </DOCUMENT>
<DOCUMENT_ID="eugene1g/phantomjs/tree/master/src/qt/qtwebkit/Source/WebCore/css/CSSSupportsRule.cpp"> # include " config . h " # include " CSSSupportsRule . h " # include " CSSParser . h " # include " CSSRule . h " # include " CSSRuleList . h " # include " CSSStyleSheet . h " # include " ExceptionCode . h " # include " StyleRule . h " # include < wtf / text / StringBuilder . h > # if ENABLE ( CSS3_CONDITIONAL_RULES ) namespace WebCore { CSSSupportsRule :: CSSSupportsRule ( StyleRuleSupports * supportsRule , CSSStyleSheet * parent ) : CSSGroupingRule ( supportsRule , parent ) { } String CSSSupportsRule :: cssText ( ) const { StringBuilder result ; result . append ( " @ supports ▁ " ) ; result . append ( conditionText ( ) ) ; result . append ( " ▁ { \n " ) ; appendCssTextForItems ( result ) ; result . append ( ' } ' ) ; return result . toString ( ) ; } String CSSSupportsRule :: conditionText ( ) const { return toStyleRuleSupports ( m_groupRule . get ( ) ) -> conditionText ( ) ; } } # endif </DOCUMENT>
<DOCUMENT_ID="mat12/mytest/tree/master/lib/gdi/sdl.cpp"> # include < lib / gdi / sdl . h > # include < lib / actions / action . h > # include < lib / base / init . h > # include < lib / base / init_num . h > # include < lib / driver / input_fake . h > # include < lib / driver / rcsdl . h > # include < SDL . h > gSDLDC :: gSDLDC ( ) : m_pump ( eApp , 1 ) { if ( SDL_Init ( SDL_INIT_VIDEO ) < 0 ) { eWarning ( " [ gSDLDC ] ▁ Could ▁ not ▁ initialize ▁ SDL : ▁ % s " , SDL_GetError ( ) ) ; return ; } setResolution ( 720 , 576 ) ; CONNECT ( m_pump . recv_msg , gSDLDC :: pumpEvent ) ; m_surface . type = 0 ; m_surface . clut . colors = 256 ; m_surface . clut . data = new gRGB [ m_surface . clut . colors ] ; m_pixmap = new gPixmap ( & m_surface ) ; memset ( m_surface . clut . data , 0 , sizeof ( * m_surface . clut . data ) * m_surface . clut . colors ) ; run ( ) ; } gSDLDC :: ~ gSDLDC ( ) { pushEvent ( EV_QUIT ) ; kill ( ) ; SDL_Quit ( ) ; } void gSDLDC :: keyEvent ( const SDL_Event & event ) { eSDLInputDriver * driver = eSDLInputDriver :: getInstance ( ) ; eDebug ( " [ gSDLDC ] ▁ Key ▁ % s : ▁ key = % d " , ( event . type == SDL_KEYDOWN ) ? " Down " : " Up " , event . key . keysym . sym ) ; if ( driver ) driver -> keyPressed ( & event . key ) ; } void gSDLDC :: pumpEvent ( const SDL_Event & event ) { switch ( event . type ) { case SDL_KEYDOWN : case SDL_KEYUP : keyEvent ( event ) ; break ; case SDL_QUIT : eDebug ( " [ gSDLDC ] ▁ Quit " ) ; extern void quitMainloop ( int exit_code ) ; quitMainloop ( 0 ) ; break ; } } void gSDLDC :: pushEvent ( enum event code , void * data1 , void * data2 ) { SDL_Event event ; event . type = SDL_USEREVENT ; event . user . code = code ; event . user . data1 = data1 ; event . user . data2 = data2 ; SDL_PushEvent ( & event ) ; } void gSDLDC :: exec ( const gOpcode * o ) { switch ( o -> opcode ) { case gOpcode :: flush : pushEvent ( EV_FLIP ) ; eDebug ( " [ gSDLDC ] ▁ FLUSH " ) ; break ; default : gDC :: exec ( o ) ; break ; } } void gSDLDC :: setResolution ( int xres , int yres ) { pushEvent ( EV_SET_VIDEO_MODE , ( void * ) xres , ( void * ) yres ) ; } void gSDLDC :: evSetVideoMode ( unsigned long xres , unsigned long yres ) { m_screen = SDL_SetVideoMode ( xres , yres , 32 , SDL_HWSURFACE ) ; if ( ! m_screen ) { eFatal ( " [ gSDLDC ] ▁ Could ▁ not ▁ create ▁ SDL ▁ surface : ▁ % s " , SDL_GetError ( ) ) ; return ; } m_surface . x = m_screen -> w ; m_surface . y = m_screen -> h ; m_surface . bpp = m_screen -> format -> BitsPerPixel ; m_surface . bypp = m_screen -> format -> BytesPerPixel ; m_surface . stride = m_screen -> pitch ; m_surface . data = m_screen -> pixels ; SDL_EnableUNICODE ( 1 ) ; } void gSDLDC :: evFlip ( ) { SDL_Flip ( m_screen ) ; } void gSDLDC :: thread ( ) { hasStarted ( ) ; bool stop = false ; while ( ! stop ) { SDL_Event event ; if ( SDL_WaitEvent ( & event ) ) { switch ( event . type ) { case SDL_KEYDOWN : case SDL_KEYUP : case SDL_QUIT : m_pump . send ( event ) ; break ; case SDL_USEREVENT : switch ( event . user . code ) { case EV_SET_VIDEO_MODE : evSetVideoMode ( ( unsigned long ) event . user . data1 , ( unsigned long ) event . user . data2 ) ; break ; case EV_FLIP : evFlip ( ) ; break ; case EV_QUIT : stop = true ; break ; } break ; } } } } eAutoInitPtr < gSDLDC > init_gSDLDC ( eAutoInitNumbers :: graphic - 1 , " gSDLDC " ) ; </DOCUMENT>
<DOCUMENT_ID="carvalhomb/tsmells/tree/master/sample/poco/poco/Foundation/testsuite/src/UniqueExpireCacheTest.cpp"> # include " UniqueExpireCacheTest . h " # include " CppUnit / TestCaller . h " # include " CppUnit / TestSuite . h " # include " Poco / Exception . h " # include " Poco / UniqueExpireCache . h " # include " Poco / UniqueAccessExpireCache . h " # include " Poco / ExpirationDecorator . h " # include " Poco / AccessExpirationDecorator . h " # include " Poco / Bugcheck . h " # include " Poco / Thread . h " using namespace Poco ; struct IntVal { int value ; Poco :: Timestamp validUntil ; IntVal ( int val , Poco :: Timestamp :: TimeDiff v ) : value ( val ) , validUntil ( ) { validUntil += ( v * 1000 ) ; } const Poco :: Timestamp & getExpiration ( ) const { return validUntil ; } } ; typedef AccessExpirationDecorator < int > DIntVal ; # define DURSLEEP 250 # define DURHALFSLEEP DURSLEEP / 2 # define DURWAIT 300 UniqueExpireCacheTest :: UniqueExpireCacheTest ( const std :: string & name ) : CppUnit :: TestCase ( name ) { } UniqueExpireCacheTest :: ~ UniqueExpireCacheTest ( ) { } void UniqueExpireCacheTest :: testClear ( ) { UniqueExpireCache < int , IntVal > aCache ; aCache . add ( 1 , IntVal ( 2 , DURSLEEP ) ) ; aCache . add ( 3 , IntVal ( 4 , DURSLEEP ) ) ; aCache . add ( 5 , IntVal ( 6 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; assert ( aCache . has ( 5 ) ) ; assert ( aCache . get ( 1 ) -> value == 2 ) ; assert ( aCache . get ( 3 ) -> value == 4 ) ; assert ( aCache . get ( 5 ) -> value == 6 ) ; aCache . clear ( ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( ! aCache . has ( 5 ) ) ; } void UniqueExpireCacheTest :: testAccessClear ( ) { UniqueAccessExpireCache < int , DIntVal > aCache ; aCache . add ( 1 , DIntVal ( 2 , DURSLEEP ) ) ; aCache . add ( 3 , DIntVal ( 4 , DURSLEEP ) ) ; aCache . add ( 5 , DIntVal ( 6 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; assert ( aCache . has ( 5 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; assert ( aCache . get ( 3 ) -> value ( ) == 4 ) ; assert ( aCache . get ( 5 ) -> value ( ) == 6 ) ; aCache . clear ( ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( ! aCache . has ( 5 ) ) ; } void UniqueExpireCacheTest :: testAccessUpdate ( ) { UniqueAccessExpireCache < int , DIntVal > aCache ; aCache . add ( 1 , DIntVal ( 2 , DURSLEEP ) ) ; aCache . add ( 3 , DIntVal ( 4 , DURSLEEP ) ) ; aCache . add ( 5 , DIntVal ( 6 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; assert ( aCache . has ( 5 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; Thread :: sleep ( DURSLEEP / 2 ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; Thread :: sleep ( DURSLEEP / 2 ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; Thread :: sleep ( DURSLEEP / 2 ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( ! aCache . has ( 5 ) ) ; Thread :: sleep ( DURSLEEP * 2 ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( ! aCache . has ( 5 ) ) ; aCache . remove ( 666 ) ; } void UniqueExpireCacheTest :: testExpire0 ( ) { UniqueExpireCache < int , IntVal > aCache ; aCache . add ( 1 , IntVal ( 2 , 0 ) ) ; assert ( ! aCache . has ( 1 ) ) ; } void UniqueExpireCacheTest :: testAccessExpire0 ( ) { UniqueAccessExpireCache < int , DIntVal > aCache ; aCache . add ( 1 , DIntVal ( 2 , Timespan ( 0 , 0 ) ) ) ; assert ( ! aCache . has ( 1 ) ) ; } void UniqueExpireCacheTest :: testExpireN ( ) { UniqueExpireCache < int , IntVal > aCache ; aCache . add ( 1 , IntVal ( 2 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; SharedPtr < IntVal > tmp = aCache . get ( 1 ) ; assert ( ! tmp . isNull ( ) ) ; assert ( tmp -> value == 2 ) ; Thread :: sleep ( DURWAIT ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( tmp -> value == 2 ) ; tmp = aCache . get ( 1 ) ; assert ( tmp . isNull ( ) ) ; aCache . add ( 1 , IntVal ( 2 , DURSLEEP ) ) ; Thread :: sleep ( DURHALFSLEEP ) ; aCache . add ( 3 , IntVal ( 4 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; tmp = aCache . get ( 1 ) ; SharedPtr < IntVal > tmp2 = aCache . get ( 3 ) ; assert ( tmp -> value == 2 ) ; assert ( tmp2 -> value == 4 ) ; Thread :: sleep ( DURHALFSLEEP + 25 ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; assert ( tmp -> value == 2 ) ; assert ( tmp2 -> value == 4 ) ; tmp2 = aCache . get ( 3 ) ; assert ( tmp2 -> value == 4 ) ; Thread :: sleep ( DURHALFSLEEP + 25 ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( tmp2 -> value == 4 ) ; tmp = aCache . get ( 1 ) ; tmp2 = aCache . get ( 3 ) ; assert ( ! tmp ) ; assert ( ! tmp2 ) ; aCache . remove ( 666 ) ; aCache . clear ( ) ; assert ( ! aCache . has ( 5 ) ) ; assert ( ! aCache . has ( 3 ) ) ; } void UniqueExpireCacheTest :: testDuplicateAdd ( ) { UniqueExpireCache < int , IntVal > aCache ; aCache . add ( 1 , IntVal ( 2 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value == 2 ) ; aCache . add ( 1 , IntVal ( 3 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value == 3 ) ; } void UniqueExpireCacheTest :: testAccessDuplicateAdd ( ) { UniqueAccessExpireCache < int , DIntVal > aCache ; aCache . add ( 1 , DIntVal ( 2 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; aCache . add ( 1 , DIntVal ( 3 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 3 ) ; } void UniqueExpireCacheTest :: testExpirationDecorator ( ) { typedef ExpirationDecorator < int > ExpireInt ; UniqueExpireCache < int , ExpireInt > aCache ; aCache . add ( 1 , ExpireInt ( 2 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; aCache . add ( 1 , ExpireInt ( 3 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 3 ) ; } void UniqueExpireCacheTest :: setUp ( ) { } void UniqueExpireCacheTest :: tearDown ( ) { } CppUnit :: Test * UniqueExpireCacheTest :: suite ( ) { CppUnit :: TestSuite * pSuite = new CppUnit :: TestSuite ( " UniqueExpireCacheTest " ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testClear ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testAccessClear ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testAccessUpdate ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testExpire0 ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testAccessExpire0 ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testExpireN ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testDuplicateAdd ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testAccessDuplicateAdd ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testExpirationDecorator ) ; return pSuite ; } </DOCUMENT>
<DOCUMENT_ID="SatoshiMabuchi/Crystal/tree/master/ThirdParty/glm-0.9.8.5/test/core/core_type_length.cpp"> # include < glm / glm . hpp > int test_length_mat_non_squared ( ) { int Error = 0 ; Error += glm :: mat2x3 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: mat2x4 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: mat3x2 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: mat3x4 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: mat4x2 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: mat4x3 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: dmat2x3 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: dmat2x4 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: dmat3x2 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: dmat3x4 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: dmat4x2 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: dmat4x3 ( ) . length ( ) == 4 ? 0 : 1 ; return Error ; } int test_length_mat ( ) { int Error = 0 ; Error += glm :: mat2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: mat3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: mat4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: mat2x2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: mat3x3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: mat4x4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: dmat2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: dmat3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: dmat4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: dmat2x2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: dmat3x3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: dmat4x4 ( ) . length ( ) == 4 ? 0 : 1 ; return Error ; } int test_length_vec ( ) { int Error = 0 ; Error += glm :: vec2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: vec3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: vec4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: ivec2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: ivec3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: ivec4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: uvec2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: uvec3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: uvec4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: dvec2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: dvec3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: dvec4 ( ) . length ( ) == 4 ? 0 : 1 ; return Error ; } int main ( ) { int Error = 0 ; Error += test_length_vec ( ) ; Error += test_length_mat ( ) ; Error += test_length_mat_non_squared ( ) ; return Error ; } </DOCUMENT>
<DOCUMENT_ID="tjaffri/msiot-samples/tree/master/AllJoyn/Samples/ZWaveAdapter/open-zwave/cpp/src/command_classes/UserCode.cpp"> # include " tinyxml . h " # include " command _ classes / CommandClasses . h " # include " command _ classes / UserCode . h " # include " Node . h " # include " Options . h " # include " platform / Log . h " # include " value _ classes / ValueByte . h " # include " value _ classes / ValueRaw . h " using namespace OpenZWave ; enum UserCodeCmd { UserCodeCmd_Set = 0x01 , UserCodeCmd_Get = 0x02 , UserCodeCmd_Report = 0x03 , UserNumberCmd_Get = 0x04 , UserNumberCmd_Report = 0x05 } ; enum { UserCodeIndex_Refresh = 254 , UserCodeIndex_Count = 255 } ; const uint8 UserCodeLength = 10 ; UserCode :: UserCode ( uint32 const _homeId , uint8 const _nodeId ) : CommandClass ( _homeId , _nodeId ) , m_queryAll ( false ) , m_currentCode ( 0 ) , m_userCodeCount ( 0 ) , m_refreshUserCodes ( false ) { SetStaticRequest ( StaticRequest_Values ) ; memset ( m_userCodesStatus , 0xff , sizeof ( m_userCodesStatus ) ) ; Options :: Get ( ) -> GetOptionAsBool ( " RefreshAllUserCodes " , & m_refreshUserCodes ) ; } void UserCode :: ReadXML ( TiXmlElement const * _ccElement ) { int32 intVal ; CommandClass :: ReadXML ( _ccElement ) ; if ( TIXML_SUCCESS == _ccElement -> QueryIntAttribute ( " codes " , & intVal ) ) { m_userCodeCount = intVal ; } } void UserCode :: WriteXML ( TiXmlElement * _ccElement ) { char str [ 32 ] ; CommandClass :: WriteXML ( _ccElement ) ; snprintf ( str , sizeof ( str ) , " % d " , m_userCodeCount ) ; _ccElement -> SetAttribute ( " codes " , str ) ; } bool UserCode :: RequestState ( uint32 const _requestFlags , uint8 const _instance , Driver :: MsgQueue const _queue ) { bool requests = false ; if ( ( _requestFlags & RequestFlag_Static ) && HasStaticRequest ( StaticRequest_Values ) ) { requests |= RequestValue ( _requestFlags , UserCodeIndex_Count , _instance , _queue ) ; } if ( _requestFlags & RequestFlag_Session ) { if ( m_userCodeCount > 0 ) { m_queryAll = true ; m_currentCode = 1 ; requests |= RequestValue ( _requestFlags , m_currentCode , _instance , _queue ) ; } } return requests ; } bool UserCode :: RequestValue ( uint32 const _requestFlags , uint8 const _userCodeIdx , uint8 const _instance , Driver :: MsgQueue const _queue ) { if ( _instance != 1 ) { return false ; } if ( ! IsGetSupported ( ) ) { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " UserNumberCmd _ Get ▁ Not ▁ Supported ▁ on ▁ this ▁ node " ) ; return false ; } if ( _userCodeIdx == UserCodeIndex_Count ) { Msg * msg = new Msg ( " UserNumberCmd _ Get " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true , true , FUNC_ID_APPLICATION_COMMAND_HANDLER , GetCommandClassId ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 2 ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserNumberCmd_Get ) ; msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , _queue ) ; return true ; } if ( _userCodeIdx == 0 ) { Log :: Write ( LogLevel_Warning , GetNodeId ( ) , " UserCodeCmd _ Get ▁ with ▁ Index ▁ 0 ▁ not ▁ Supported " ) ; return false ; } Msg * msg = new Msg ( " UserCodeCmd _ Get " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true , true , FUNC_ID_APPLICATION_COMMAND_HANDLER , GetCommandClassId ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 3 ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserCodeCmd_Get ) ; msg -> Append ( _userCodeIdx ) ; msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , _queue ) ; return true ; } bool UserCode :: HandleMsg ( uint8 const * _data , uint32 const _length , uint32 const _instance ) { if ( UserNumberCmd_Report == ( UserCodeCmd ) _data [ 0 ] ) { m_userCodeCount = _data [ 1 ] ; if ( m_userCodeCount > 254 ) { m_userCodeCount = 254 ; } ClearStaticRequest ( StaticRequest_Values ) ; if ( m_userCodeCount == 0 ) { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Number ▁ report ▁ from ▁ node ▁ % d : ▁ Not ▁ supported " , GetNodeId ( ) ) ; } else { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Number ▁ report ▁ from ▁ node ▁ % d : ▁ Supported ▁ Codes ▁ % d ▁ ( % d ) " , GetNodeId ( ) , m_userCodeCount , _data [ 1 ] ) ; } if ( ValueByte * value = static_cast < ValueByte * > ( GetValue ( _instance , UserCodeIndex_Count ) ) ) { value -> OnValueRefreshed ( m_userCodeCount ) ; value -> Release ( ) ; } if ( Node * node = GetNodeUnsafe ( ) ) { uint8 data [ UserCodeLength ] ; memset ( data , 0 , UserCodeLength ) ; for ( uint8 i = 0 ; i <= m_userCodeCount ; i ++ ) { char str [ 16 ] ; if ( i == 0 ) { snprintf ( str , sizeof ( str ) , " Enrollment ▁ Code " ) ; node -> CreateValueRaw ( ValueID :: ValueGenre_User , GetCommandClassId ( ) , _instance , i , str , " " , true , false , data , UserCodeLength , 0 ) ; } else { snprintf ( str , sizeof ( str ) , " Code ▁ % d : " , i ) ; node -> CreateValueRaw ( ValueID :: ValueGenre_User , GetCommandClassId ( ) , _instance , i , str , " " , false , false , data , UserCodeLength , 0 ) ; } } } return true ; } else if ( UserCodeCmd_Report == ( UserCodeCmd ) _data [ 0 ] ) { int i = _data [ 1 ] ; if ( ValueRaw * value = static_cast < ValueRaw * > ( GetValue ( _instance , i ) ) ) { uint8 data [ UserCodeLength ] ; uint8 size = _length - 4 ; if ( size > UserCodeLength ) { Log :: Write ( LogLevel_Warning , GetNodeId ( ) , " User ▁ Code ▁ length ▁ % d ▁ is ▁ larger ▁ then ▁ maximum ▁ % d " , size , UserCodeLength ) ; size = UserCodeLength ; } m_userCodesStatus [ i ] = _data [ 2 ] ; memcpy ( data , & _data [ 3 ] , size ) ; value -> OnValueRefreshed ( data , size ) ; value -> Release ( ) ; } Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Code ▁ Report ▁ from ▁ node ▁ % d ▁ for ▁ User ▁ Code ▁ % d ▁ ( % s ) " , GetNodeId ( ) , i , CodeStatus ( _data [ 2 ] ) . c_str ( ) ) ; if ( m_queryAll && i == m_currentCode ) { if ( m_refreshUserCodes || ( _data [ 2 ] != UserCode_Available ) ) { if ( ++ i <= m_userCodeCount ) { m_currentCode = i ; RequestValue ( 0 , m_currentCode , _instance , Driver :: MsgQueue_Query ) ; } else { m_queryAll = false ; Options :: Get ( ) -> GetOptionAsBool ( " RefreshAllUserCodes " , & m_refreshUserCodes ) ; } } else { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Not ▁ Requesting ▁ additional ▁ UserCode ▁ Slots ▁ as ▁ RefreshAllUserCodes ▁ is ▁ false , ▁ and ▁ slot ▁ % d ▁ is ▁ available " , i ) ; m_queryAll = false ; } } return true ; } return false ; } bool UserCode :: SetValue ( Value const & _value ) { if ( ( ValueID :: ValueType_Raw == _value . GetID ( ) . GetType ( ) ) && ( _value . GetID ( ) . GetIndex ( ) < UserCodeIndex_Refresh ) ) { ValueRaw const * value = static_cast < ValueRaw const * > ( & _value ) ; uint8 * s = value -> GetValue ( ) ; uint8 len = value -> GetLength ( ) ; if ( len > UserCodeLength ) { return false ; } m_userCodesStatus [ value -> GetID ( ) . GetIndex ( ) ] = UserCode_Occupied ; Msg * msg = new Msg ( " UserCodeCmd _ Set " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true ) ; msg -> SetInstance ( this , _value . GetID ( ) . GetInstance ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 4 + len ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserCodeCmd_Set ) ; msg -> Append ( value -> GetID ( ) . GetIndex ( ) ) ; msg -> Append ( UserCode_Occupied ) ; for ( uint8 i = 0 ; i < len ; i ++ ) { msg -> Append ( s [ i ] ) ; } msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , Driver :: MsgQueue_Send ) ; return true ; } if ( ( ValueID :: ValueType_Button == _value . GetID ( ) . GetType ( ) ) && ( _value . GetID ( ) . GetIndex ( ) == UserCodeIndex_Refresh ) ) { m_refreshUserCodes = true ; m_currentCode = 1 ; m_queryAll = true ; RequestValue ( 0 , m_currentCode , _value . GetID ( ) . GetInstance ( ) , Driver :: MsgQueue_Query ) ; return true ; } return false ; } void UserCode :: CreateVars ( uint8 const _instance ) { if ( Node * node = GetNodeUnsafe ( ) ) { node -> CreateValueByte ( ValueID :: ValueGenre_System , GetCommandClassId ( ) , _instance , UserCodeIndex_Count , " Code ▁ Count " , " " , true , false , 0 , 0 ) ; node -> CreateValueButton ( ValueID :: ValueGenre_System , GetCommandClassId ( ) , _instance , UserCodeIndex_Refresh , " Refresh ▁ All ▁ UserCodes " , 0 ) ; } } </DOCUMENT>
<DOCUMENT_ID="dodamn/pkg-dosbox/tree/master/src/hardware/mixer.cpp"> # include < string . h > # include < sys / types . h > # include < math . h > # if defined ( WIN32 ) # ifndef WIN32_LEAN_AND_MEAN # define WIN32_LEAN_AND_MEAN # endif # include < windows . h > # include < mmsystem . h > # endif # include " SDL . h " # include " mem . h " # include " pic . h " # include " dosbox . h " # include " mixer . h " # include " timer . h " # include " setup . h " # include " cross . h " # include " support . h " # include " mapper . h " # include " hardware . h " # include " programs . h " # define MIXER_SSIZE 4 # define MIXER_SHIFT 14 # define MIXER_REMAIN ( ( 1 << MIXER_SHIFT ) - 1 ) # define MIXER_VOLSHIFT 13 static INLINE Bit16s MIXER_CLIP ( Bits SAMP ) { if ( SAMP < MAX_AUDIO ) { if ( SAMP > MIN_AUDIO ) return SAMP ; else return MIN_AUDIO ; } else return MAX_AUDIO ; } static struct { Bit32s work [ MIXER_BUFSIZE ] [ 2 ] ; Bitu pos , done ; Bitu needed , min_needed , max_needed ; Bit32u tick_add , tick_remain ; float mastervol [ 2 ] ; MixerChannel * channels ; bool nosound ; Bit32u freq ; Bit32u blocksize ; } mixer ; Bit8u MixTemp [ MIXER_BUFSIZE ] ; MixerChannel * MIXER_AddChannel ( MIXER_Handler handler , Bitu freq , const char * name ) { MixerChannel * chan = new MixerChannel ( ) ; chan -> scale = 1.0 ; chan -> handler = handler ; chan -> name = name ; chan -> SetFreq ( freq ) ; chan -> next = mixer . channels ; chan -> SetVolume ( 1 , 1 ) ; chan -> enabled = false ; mixer . channels = chan ; return chan ; } MixerChannel * MIXER_FindChannel ( const char * name ) { MixerChannel * chan = mixer . channels ; while ( chan ) { if ( ! strcasecmp ( chan -> name , name ) ) break ; chan = chan -> next ; } return chan ; } void MIXER_DelChannel ( MixerChannel * delchan ) { MixerChannel * chan = mixer . channels ; MixerChannel * * where = & mixer . channels ; while ( chan ) { if ( chan == delchan ) { * where = chan -> next ; delete delchan ; return ; } where = & chan -> next ; chan = chan -> next ; } } void MixerChannel :: UpdateVolume ( void ) { volmul [ 0 ] = ( Bits ) ( ( 1 << MIXER_VOLSHIFT ) * scale * volmain [ 0 ] * mixer . mastervol [ 0 ] ) ; volmul [ 1 ] = ( Bits ) ( ( 1 << MIXER_VOLSHIFT ) * scale * volmain [ 1 ] * mixer . mastervol [ 1 ] ) ; } void MixerChannel :: SetVolume ( float _left , float _right ) { volmain [ 0 ] = _left ; volmain [ 1 ] = _right ; UpdateVolume ( ) ; } void MixerChannel :: SetScale ( float f ) { scale = f ; UpdateVolume ( ) ; } void MixerChannel :: Enable ( bool _yesno ) { if ( _yesno == enabled ) return ; enabled = _yesno ; if ( enabled ) { freq_index = MIXER_REMAIN ; SDL_LockAudio ( ) ; if ( done < mixer . done ) done = mixer . done ; SDL_UnlockAudio ( ) ; } } void MixerChannel :: SetFreq ( Bitu _freq ) { freq_add = ( _freq << MIXER_SHIFT ) / mixer . freq ; } void MixerChannel :: Mix ( Bitu _needed ) { needed = _needed ; while ( enabled && needed > done ) { Bitu todo = needed - done ; todo *= freq_add ; if ( todo & MIXER_REMAIN ) { todo = ( todo >> MIXER_SHIFT ) + 1 ; } else { todo = ( todo >> MIXER_SHIFT ) ; } handler ( todo ) ; } } void MixerChannel :: AddSilence ( void ) { if ( done < needed ) { done = needed ; last [ 0 ] = last [ 1 ] = 0 ; freq_index = MIXER_REMAIN ; } } template < class Type , bool stereo , bool signeddata , bool nativeorder > inline void MixerChannel :: AddSamples ( Bitu len , const Type * data ) { Bits diff [ 2 ] ; Bitu mixpos = mixer . pos + done ; freq_index &= MIXER_REMAIN ; Bitu pos = 0 ; Bitu new_pos ; goto thestart ; for ( ; ; ) { new_pos = freq_index >> MIXER_SHIFT ; if ( pos < new_pos ) { last [ 0 ] += diff [ 0 ] ; if ( stereo ) last [ 1 ] += diff [ 1 ] ; pos = new_pos ; thestart : if ( pos >= len ) return ; if ( sizeof ( Type ) == 1 ) { if ( ! signeddata ) { if ( stereo ) { diff [ 0 ] = ( ( ( Bit8s ) ( data [ pos * 2 + 0 ] ^ 0x80 ) ) << 8 ) - last [ 0 ] ; diff [ 1 ] = ( ( ( Bit8s ) ( data [ pos * 2 + 1 ] ^ 0x80 ) ) << 8 ) - last [ 1 ] ; } else { diff [ 0 ] = ( ( ( Bit8s ) ( data [ pos ] ^ 0x80 ) ) << 8 ) - last [ 0 ] ; } } else { if ( stereo ) { diff [ 0 ] = ( data [ pos * 2 + 0 ] << 8 ) - last [ 0 ] ; diff [ 1 ] = ( data [ pos * 2 + 1 ] << 8 ) - last [ 1 ] ; } else { diff [ 0 ] = ( data [ pos ] << 8 ) - last [ 0 ] ; } } } else { if ( signeddata ) { if ( stereo ) { if ( nativeorder ) { diff [ 0 ] = data [ pos * 2 + 0 ] - last [ 0 ] ; diff [ 1 ] = data [ pos * 2 + 1 ] - last [ 1 ] ; } else { if ( sizeof ( Type ) == 2 ) { diff [ 0 ] = ( Bit16s ) host_readw ( ( HostPt ) & data [ pos * 2 + 0 ] ) - last [ 0 ] ; diff [ 1 ] = ( Bit16s ) host_readw ( ( HostPt ) & data [ pos * 2 + 1 ] ) - last [ 1 ] ; } else { diff [ 0 ] = ( Bit32s ) host_readd ( ( HostPt ) & data [ pos * 2 + 0 ] ) - last [ 0 ] ; diff [ 1 ] = ( Bit32s ) host_readd ( ( HostPt ) & data [ pos * 2 + 1 ] ) - last [ 1 ] ; } } } else { if ( nativeorder ) { diff [ 0 ] = data [ pos ] - last [ 0 ] ; } else { if ( sizeof ( Type ) == 2 ) { diff [ 0 ] = ( Bit16s ) host_readw ( ( HostPt ) & data [ pos ] ) - last [ 0 ] ; } else { diff [ 0 ] = ( Bit32s ) host_readd ( ( HostPt ) & data [ pos ] ) - last [ 0 ] ; } } } } else { if ( stereo ) { if ( nativeorder ) { diff [ 0 ] = ( Bits ) data [ pos * 2 + 0 ] - 32768 - last [ 0 ] ; diff [ 1 ] = ( Bits ) data [ pos * 2 + 1 ] - 32768 - last [ 1 ] ; } else { if ( sizeof ( Type ) == 2 ) { diff [ 0 ] = ( Bits ) host_readw ( ( HostPt ) & data [ pos * 2 + 0 ] ) - 32768 - last [ 0 ] ; diff [ 1 ] = ( Bits ) host_readw ( ( HostPt ) & data [ pos * 2 + 1 ] ) - 32768 - last [ 1 ] ; } else { diff [ 0 ] = ( Bits ) host_readd ( ( HostPt ) & data [ pos * 2 + 0 ] ) - 32768 - last [ 0 ] ; diff [ 1 ] = ( Bits ) host_readd ( ( HostPt ) & data [ pos * 2 + 1 ] ) - 32768 - last [ 1 ] ; } } } else { if ( nativeorder ) { diff [ 0 ] = ( Bits ) data [ pos ] - 32768 - last [ 0 ] ; } else { if ( sizeof ( Type ) == 2 ) { diff [ 0 ] = ( Bits ) host_readw ( ( HostPt ) & data [ pos ] ) - 32768 - last [ 0 ] ; } else { diff [ 0 ] = ( Bits ) host_readd ( ( HostPt ) & data [ pos ] ) - 32768 - last [ 0 ] ; } } } } } } Bits diff_mul = freq_index & MIXER_REMAIN ; freq_index += freq_add ; mixpos &= MIXER_BUFMASK ; Bits sample = last [ 0 ] + ( ( diff [ 0 ] * diff_mul ) >> MIXER_SHIFT ) ; mixer . work [ mixpos ] [ 0 ] += sample * volmul [ 0 ] ; if ( stereo ) sample = last [ 1 ] + ( ( diff [ 1 ] * diff_mul ) >> MIXER_SHIFT ) ; mixer . work [ mixpos ] [ 1 ] += sample * volmul [ 1 ] ; mixpos ++ ; done ++ ; } } void MixerChannel :: AddStretched ( Bitu len , Bit16s * data ) { if ( done >= needed ) { LOG_MSG ( " Can ' t ▁ add , ▁ buffer ▁ full " ) ; return ; } Bitu outlen = needed - done ; Bits diff ; freq_index = 0 ; Bitu temp_add = ( len << MIXER_SHIFT ) / outlen ; Bitu mixpos = mixer . pos + done ; done = needed ; Bitu pos = 0 ; diff = data [ 0 ] - last [ 0 ] ; while ( outlen -- ) { Bitu new_pos = freq_index >> MIXER_SHIFT ; if ( pos < new_pos ) { pos = new_pos ; last [ 0 ] += diff ; diff = data [ pos ] - last [ 0 ] ; } Bits diff_mul = freq_index & MIXER_REMAIN ; freq_index += temp_add ; mixpos &= MIXER_BUFMASK ; Bits sample = last [ 0 ] + ( ( diff * diff_mul ) >> MIXER_SHIFT ) ; mixer . work [ mixpos ] [ 0 ] += sample * volmul [ 0 ] ; mixer . work [ mixpos ] [ 1 ] += sample * volmul [ 1 ] ; mixpos ++ ; } } void MixerChannel :: AddSamples_m8 ( Bitu len , const Bit8u * data ) { AddSamples < Bit8u , false , false , true > ( len , data ) ; } void MixerChannel :: AddSamples_s8 ( Bitu len , const Bit8u * data ) { AddSamples < Bit8u , true , false , true > ( len , data ) ; } void MixerChannel :: AddSamples_m8s ( Bitu len , const Bit8s * data ) { AddSamples < Bit8s , false , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_s8s ( Bitu len , const Bit8s * data ) { AddSamples < Bit8s , true , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_m16 ( Bitu len , const Bit16s * data ) { AddSamples < Bit16s , false , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_s16 ( Bitu len , const Bit16s * data ) { AddSamples < Bit16s , true , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_m16u ( Bitu len , const Bit16u * data ) { AddSamples < Bit16u , false , false , true > ( len , data ) ; } void MixerChannel :: AddSamples_s16u ( Bitu len , const Bit16u * data ) { AddSamples < Bit16u , true , false , true > ( len , data ) ; } void MixerChannel :: AddSamples_m32 ( Bitu len , const Bit32s * data ) { AddSamples < Bit32s , false , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_s32 ( Bitu len , const Bit32s * data ) { AddSamples < Bit32s , true , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_m16_nonnative ( Bitu len , const Bit16s * data ) { AddSamples < Bit16s , false , true , false > ( len , data ) ; } void MixerChannel :: AddSamples_s16_nonnative ( Bitu len , const Bit16s * data ) { AddSamples < Bit16s , true , true , false > ( len , data ) ; } void MixerChannel :: AddSamples_m16u_nonnative ( Bitu len , const Bit16u * data ) { AddSamples < Bit16u , false , false , false > ( len , data ) ; } void MixerChannel :: AddSamples_s16u_nonnative ( Bitu len , const Bit16u * data ) { AddSamples < Bit16u , true , false , false > ( len , data ) ; } void MixerChannel :: AddSamples_m32_nonnative ( Bitu len , const Bit32s * data ) { AddSamples < Bit32s , false , true , false > ( len , data ) ; } void MixerChannel :: AddSamples_s32_nonnative ( Bitu len , const Bit32s * data ) { AddSamples < Bit32s , true , true , false > ( len , data ) ; } void MixerChannel :: FillUp ( void ) { SDL_LockAudio ( ) ; if ( ! enabled || done < mixer . done ) { SDL_UnlockAudio ( ) ; return ; } float index = PIC_TickIndex ( ) ; Mix ( ( Bitu ) ( index * mixer . needed ) ) ; SDL_UnlockAudio ( ) ; } extern bool ticksLocked ; static inline bool Mixer_irq_important ( void ) { return ( ticksLocked || ( CaptureState & ( CAPTURE_WAVE | CAPTURE_VIDEO ) ) ) ; } static void MIXER_MixData ( Bitu needed ) { MixerChannel * chan = mixer . channels ; while ( chan ) { chan -> Mix ( needed ) ; chan = chan -> next ; } if ( CaptureState & ( CAPTURE_WAVE | CAPTURE_VIDEO ) ) { Bit16s convert [ 1024 ] [ 2 ] ; Bitu added = needed - mixer . done ; if ( added > 1024 ) added = 1024 ; Bitu readpos = ( mixer . pos + mixer . done ) & MIXER_BUFMASK ; for ( Bitu i = 0 ; i < added ; i ++ ) { Bits sample = mixer . work [ readpos ] [ 0 ] >> MIXER_VOLSHIFT ; convert [ i ] [ 0 ] = MIXER_CLIP ( sample ) ; sample = mixer . work [ readpos ] [ 1 ] >> MIXER_VOLSHIFT ; convert [ i ] [ 1 ] = MIXER_CLIP ( sample ) ; readpos = ( readpos + 1 ) & MIXER_BUFMASK ; } CAPTURE_AddWave ( mixer . freq , added , ( Bit16s * ) convert ) ; } if ( Mixer_irq_important ( ) ) mixer . tick_add = ( ( mixer . freq ) << MIXER_SHIFT ) / 1000 ; mixer . done = needed ; } static void MIXER_Mix ( void ) { SDL_LockAudio ( ) ; MIXER_MixData ( mixer . needed ) ; mixer . tick_remain += mixer . tick_add ; mixer . needed += ( mixer . tick_remain >> MIXER_SHIFT ) ; mixer . tick_remain &= MIXER_REMAIN ; SDL_UnlockAudio ( ) ; } static void MIXER_Mix_NoSound ( void ) { MIXER_MixData ( mixer . needed ) ; for ( Bitu i = 0 ; i < mixer . needed ; i ++ ) { mixer . work [ mixer . pos ] [ 0 ] = 0 ; mixer . work [ mixer . pos ] [ 1 ] = 0 ; mixer . pos = ( mixer . pos + 1 ) & MIXER_BUFMASK ; } for ( MixerChannel * chan = mixer . channels ; chan ; chan = chan -> next ) { if ( chan -> done > mixer . needed ) chan -> done -= mixer . needed ; else chan -> done = 0 ; } mixer . tick_remain += mixer . tick_add ; mixer . needed = mixer . tick_remain >> MIXER_SHIFT ; mixer . tick_remain &= MIXER_REMAIN ; mixer . done = 0 ; } static void MIXER_CallBack ( void * userdata , Uint8 * stream , int len ) { Bitu need = ( Bitu ) len / MIXER_SSIZE ; Bit16s * output = ( Bit16s * ) stream ; Bitu reduce ; Bitu pos , index , index_add ; Bits sample ; if ( mixer . done < need ) { if ( ( need - mixer . done ) > ( need >> 7 ) ) return ; reduce = mixer . done ; index_add = ( reduce << MIXER_SHIFT ) / need ; mixer . tick_add = ( ( mixer . freq + mixer . min_needed ) << MIXER_SHIFT ) / 1000 ; } else if ( mixer . done < mixer . max_needed ) { Bitu left = mixer . done - need ; if ( left < mixer . min_needed ) { if ( ! Mixer_irq_important ( ) ) { Bitu needed = mixer . needed - need ; Bitu diff = ( mixer . min_needed > needed ? mixer . min_needed : needed ) - left ; mixer . tick_add = ( ( mixer . freq + ( diff * 3 ) ) << MIXER_SHIFT ) / 1000 ; left = 0 ; } else { left = ( mixer . min_needed - left ) ; left = 1 + ( 2 * left ) / mixer . min_needed ; } reduce = need - left ; index_add = ( reduce << MIXER_SHIFT ) / need ; } else { reduce = need ; index_add = ( 1 << MIXER_SHIFT ) ; Bitu diff = left - mixer . min_needed ; if ( diff > ( mixer . min_needed << 1 ) ) diff = mixer . min_needed << 1 ; if ( diff > ( mixer . min_needed >> 1 ) ) mixer . tick_add = ( ( mixer . freq - ( diff / 5 ) ) << MIXER_SHIFT ) / 1000 ; else if ( diff > ( mixer . min_needed >> 4 ) ) mixer . tick_add = ( ( mixer . freq - ( diff >> 3 ) ) << MIXER_SHIFT ) / 1000 ; else mixer . tick_add = ( mixer . freq << MIXER_SHIFT ) / 1000 ; } } else { if ( mixer . done > MIXER_BUFSIZE ) index_add = MIXER_BUFSIZE - 2 * mixer . min_needed ; else index_add = mixer . done - 2 * mixer . min_needed ; index_add = ( index_add << MIXER_SHIFT ) / need ; reduce = mixer . done - 2 * mixer . min_needed ; mixer . tick_add = ( ( mixer . freq - ( mixer . min_needed / 5 ) ) << MIXER_SHIFT ) / 1000 ; } for ( MixerChannel * chan = mixer . channels ; chan ; chan = chan -> next ) { if ( chan -> done > reduce ) chan -> done -= reduce ; else chan -> done = 0 ; } if ( Mixer_irq_important ( ) ) mixer . tick_add = ( mixer . freq << MIXER_SHIFT ) / 1000 ; mixer . done -= reduce ; mixer . needed -= reduce ; pos = mixer . pos ; mixer . pos = ( mixer . pos + reduce ) & MIXER_BUFMASK ; index = 0 ; if ( need != reduce ) { while ( need -- ) { Bitu i = ( pos + ( index >> MIXER_SHIFT ) ) & MIXER_BUFMASK ; index += index_add ; sample = mixer . work [ i ] [ 0 ] >> MIXER_VOLSHIFT ; * output ++ = MIXER_CLIP ( sample ) ; sample = mixer . work [ i ] [ 1 ] >> MIXER_VOLSHIFT ; * output ++ = MIXER_CLIP ( sample ) ; } while ( reduce -- ) { pos &= MIXER_BUFMASK ; mixer . work [ pos ] [ 0 ] = 0 ; mixer . work [ pos ] [ 1 ] = 0 ; pos ++ ; } } else { while ( reduce -- ) { pos &= MIXER_BUFMASK ; sample = mixer . work [ pos ] [ 0 ] >> MIXER_VOLSHIFT ; * output ++ = MIXER_CLIP ( sample ) ; sample = mixer . work [ pos ] [ 1 ] >> MIXER_VOLSHIFT ; * output ++ = MIXER_CLIP ( sample ) ; mixer . work [ pos ] [ 0 ] = 0 ; mixer . work [ pos ] [ 1 ] = 0 ; pos ++ ; } } } static void MIXER_Stop ( Section * sec ) { } class MIXER : public Program { public : void MakeVolume ( char * scan , float & vol0 , float & vol1 ) { Bitu w = 0 ; bool db = ( toupper ( * scan ) == ' D ' ) ; if ( db ) scan ++ ; while ( * scan ) { if ( * scan == ' : ' ) { ++ scan ; w = 1 ; } char * before = scan ; float val = ( float ) strtod ( scan , & scan ) ; if ( before == scan ) { ++ scan ; continue ; } if ( ! db ) val /= 100 ; else val = powf ( 10.0f , ( float ) val / 20.0f ) ; if ( val < 0 ) val = 1.0f ; if ( ! w ) { vol0 = val ; } else { vol1 = val ; } } if ( ! w ) vol1 = vol0 ; } void Run ( void ) { if ( cmd -> FindExist ( " / LISTMIDI " ) ) { ListMidi ( ) ; return ; } if ( cmd -> FindString ( " MASTER " , temp_line , false ) ) { MakeVolume ( ( char * ) temp_line . c_str ( ) , mixer . mastervol [ 0 ] , mixer . mastervol [ 1 ] ) ; } MixerChannel * chan = mixer . channels ; while ( chan ) { if ( cmd -> FindString ( chan -> name , temp_line , false ) ) { MakeVolume ( ( char * ) temp_line . c_str ( ) , chan -> volmain [ 0 ] , chan -> volmain [ 1 ] ) ; } chan -> UpdateVolume ( ) ; chan = chan -> next ; } if ( cmd -> FindExist ( " / NOSHOW " ) ) return ; chan = mixer . channels ; WriteOut ( " Channel ▁ ▁ Main ▁ ▁ ▁ ▁ Main ( dB ) \n " ) ; ShowVolume ( " MASTER " , mixer . mastervol [ 0 ] , mixer . mastervol [ 1 ] ) ; for ( chan = mixer . channels ; chan ; chan = chan -> next ) ShowVolume ( chan -> name , chan -> volmain [ 0 ] , chan -> volmain [ 1 ] ) ; } private : void ShowVolume ( const char * name , float vol0 , float vol1 ) { WriteOut ( " % -8s ▁ % 3.0f : % - 3.0f ▁ ▁ % + 3.2f : % - + 3.2f ▁ \n " , name , vol0 * 100 , vol1 * 100 , 20 * log ( vol0 ) / log ( 10.0f ) , 20 * log ( vol1 ) / log ( 10.0f ) ) ; } void ListMidi ( ) { # if defined ( WIN32 ) unsigned int total = midiOutGetNumDevs ( ) ; for ( unsigned int i = 0 ; i < total ; i ++ ) { MIDIOUTCAPS mididev ; midiOutGetDevCaps ( i , & mididev , sizeof ( MIDIOUTCAPS ) ) ; WriteOut ( " % 2d\t ▁ \ " % s\ " \n " , i , mididev . szPname ) ; } # endif return ; } ; } ; static void MIXER_ProgramStart ( Program * * make ) { * make = new MIXER ; } MixerChannel * MixerObject :: Install ( MIXER_Handler handler , Bitu freq , const char * name ) { if ( ! installed ) { if ( strlen ( name ) > 31 ) E_Exit ( " Too ▁ long ▁ mixer ▁ channel ▁ name " ) ; safe_strncpy ( m_name , name , 32 ) ; installed = true ; return MIXER_AddChannel ( handler , freq , name ) ; } else { E_Exit ( " allready ▁ added ▁ mixer ▁ channel . " ) ; return 0 ; } } MixerObject :: ~ MixerObject ( ) { if ( ! installed ) return ; MIXER_DelChannel ( MIXER_FindChannel ( m_name ) ) ; } void MIXER_Init ( Section * sec ) { sec -> AddDestroyFunction ( & MIXER_Stop ) ; Section_prop * section = static_cast < Section_prop * > ( sec ) ; mixer . freq = section -> Get_int ( " rate " ) ; mixer . nosound = section -> Get_bool ( " nosound " ) ; mixer . blocksize = section -> Get_int ( " blocksize " ) ; mixer . channels = 0 ; mixer . pos = 0 ; mixer . done = 0 ; memset ( mixer . work , 0 , sizeof ( mixer . work ) ) ; mixer . mastervol [ 0 ] = 1.0f ; mixer . mastervol [ 1 ] = 1.0f ; SDL_AudioSpec spec ; SDL_AudioSpec obtained ; spec . freq = mixer . freq ; spec . format = AUDIO_S16SYS ; spec . channels = 2 ; spec . callback = MIXER_CallBack ; spec . userdata = NULL ; spec . samples = ( Uint16 ) mixer . blocksize ; mixer . tick_remain = 0 ; if ( mixer . nosound ) { LOG_MSG ( " MIXER : No ▁ Sound ▁ Mode ▁ Selected . " ) ; mixer . tick_add = ( ( mixer . freq ) << MIXER_SHIFT ) / 1000 ; TIMER_AddTickHandler ( MIXER_Mix_NoSound ) ; } else if ( SDL_OpenAudio ( & spec , & obtained ) < 0 ) { mixer . nosound = true ; LOG_MSG ( " MIXER : Can ' t ▁ open ▁ audio : ▁ % s ▁ , ▁ running ▁ in ▁ nosound ▁ mode . " , SDL_GetError ( ) ) ; mixer . tick_add = ( ( mixer . freq ) << MIXER_SHIFT ) / 1000 ; TIMER_AddTickHandler ( MIXER_Mix_NoSound ) ; } else { mixer . freq = obtained . freq ; mixer . blocksize = obtained . samples ; mixer . tick_add = ( mixer . freq << MIXER_SHIFT ) / 1000 ; TIMER_AddTickHandler ( MIXER_Mix ) ; SDL_PauseAudio ( 0 ) ; } mixer . min_needed = section -> Get_int ( " prebuffer " ) ; if ( mixer . min_needed > 100 ) mixer . min_needed = 100 ; mixer . min_needed = ( mixer . freq * mixer . min_needed ) / 1000 ; mixer . max_needed = mixer . blocksize * 2 + 2 * mixer . min_needed ; mixer . needed = mixer . min_needed + 1 ; PROGRAMS_MakeFile ( " MIXER . COM " , MIXER_ProgramStart ) ; } </DOCUMENT>
<DOCUMENT_ID="hbwhlklive/color-emoji.skia/tree/master/src/ports/SkGlobalInitialization_chromium.cpp"> # include " SkBitmapProcShader . h " # include " SkBlurImageFilter . h " # include " SkBlurMaskFilter . h " # include " SkColorFilter . h " # include " SkCornerPathEffect . h " # include " SkDashPathEffect . h " # include " SkGradientShader . h " # include " SkLayerDrawLooper . h " # include " SkMallocPixelRef . h " # include " SkXfermode . h " # include " SkMagnifierImageFilter . h " void SkFlattenable :: InitializeFlattenables ( ) { SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkBitmapProcShader ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkBlurImageFilter ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkCornerPathEffect ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkDashPathEffect ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkLayerDrawLooper ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkMallocPixelRef ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkMagnifierImageFilter ) SkBlurMaskFilter :: InitializeFlattenables ( ) ; SkColorFilter :: InitializeFlattenables ( ) ; SkGradientShader :: InitializeFlattenables ( ) ; SkXfermode :: InitializeFlattenables ( ) ; } </DOCUMENT>
<DOCUMENT_ID="Residentik/TestingRepo/tree/master/src/server/scripts/EasternKingdoms/BlackrockMountain/BlackrockDepths/boss_high_interrogator_gerstahn.cpp"> # include " ScriptMgr . h " # include " ScriptedCreature . h " enum Spells { SPELL_SHADOWWORDPAIN = 10894 , SPELL_MANABURN = 10876 , SPELL_PSYCHICSCREAM = 8122 , SPELL_SHADOWSHIELD = 22417 } ; class boss_high_interrogator_gerstahn : public CreatureScript { public : boss_high_interrogator_gerstahn ( ) : CreatureScript ( " boss _ high _ interrogator _ gerstahn " ) { } CreatureAI * GetAI ( Creature * creature ) const OVERRIDE { return new boss_high_interrogator_gerstahnAI ( creature ) ; } struct boss_high_interrogator_gerstahnAI : public ScriptedAI { boss_high_interrogator_gerstahnAI ( Creature * creature ) : ScriptedAI ( creature ) { } uint32 ShadowWordPain_Timer ; uint32 ManaBurn_Timer ; uint32 PsychicScream_Timer ; uint32 ShadowShield_Timer ; void Reset ( ) OVERRIDE { ShadowWordPain_Timer = 4000 ; ManaBurn_Timer = 14000 ; PsychicScream_Timer = 32000 ; ShadowShield_Timer = 8000 ; } void EnterCombat ( Unit * ) OVERRIDE { } void UpdateAI ( uint32 diff ) OVERRIDE { if ( ! UpdateVictim ( ) ) return ; if ( ShadowWordPain_Timer <= diff ) { if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 100 , true ) ) DoCast ( target , SPELL_SHADOWWORDPAIN ) ; ShadowWordPain_Timer = 7000 ; } else ShadowWordPain_Timer -= diff ; if ( ManaBurn_Timer <= diff ) { if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 100 , true ) ) DoCast ( target , SPELL_MANABURN ) ; ManaBurn_Timer = 10000 ; } else ManaBurn_Timer -= diff ; if ( PsychicScream_Timer <= diff ) { DoCastVictim ( SPELL_PSYCHICSCREAM ) ; PsychicScream_Timer = 30000 ; } else PsychicScream_Timer -= diff ; if ( ShadowShield_Timer <= diff ) { DoCast ( me , SPELL_SHADOWSHIELD ) ; ShadowShield_Timer = 25000 ; } else ShadowShield_Timer -= diff ; DoMeleeAttackIfReady ( ) ; } } ; } ; void AddSC_boss_high_interrogator_gerstahn ( ) { new boss_high_interrogator_gerstahn ( ) ; } </DOCUMENT>
<DOCUMENT_ID="circa-one/OpenJK-Alt/tree/master/code/cgame/cg_marks.cpp"> # include " cg _ headers . h " # include " cg _ media . h " markPoly_t cg_activeMarkPolys ; markPoly_t * cg_freeMarkPolys ; markPoly_t cg_markPolys [ MAX_MARK_POLYS ] ; void CG_InitMarkPolys ( void ) { int i ; memset ( cg_markPolys , 0 , sizeof ( cg_markPolys ) ) ; cg_activeMarkPolys . nextMark = & cg_activeMarkPolys ; cg_activeMarkPolys . prevMark = & cg_activeMarkPolys ; cg_freeMarkPolys = cg_markPolys ; for ( i = 0 ; i < MAX_MARK_POLYS - 1 ; i ++ ) { cg_markPolys [ i ] . nextMark = & cg_markPolys [ i + 1 ] ; } } void CG_FreeMarkPoly ( markPoly_t * le ) { if ( ! le -> prevMark ) { CG_Error ( " CG _ FreeLocalEntity : ▁ not ▁ active " ) ; } le -> prevMark -> nextMark = le -> nextMark ; le -> nextMark -> prevMark = le -> prevMark ; le -> nextMark = cg_freeMarkPolys ; cg_freeMarkPolys = le ; } markPoly_t * CG_AllocMark ( void ) { markPoly_t * le ; int time ; if ( ! cg_freeMarkPolys ) { time = cg_activeMarkPolys . prevMark -> time ; while ( cg_activeMarkPolys . prevMark && time == cg_activeMarkPolys . prevMark -> time ) { CG_FreeMarkPoly ( cg_activeMarkPolys . prevMark ) ; } } le = cg_freeMarkPolys ; cg_freeMarkPolys = cg_freeMarkPolys -> nextMark ; memset ( le , 0 , sizeof ( * le ) ) ; le -> nextMark = cg_activeMarkPolys . nextMark ; le -> prevMark = & cg_activeMarkPolys ; cg_activeMarkPolys . nextMark -> prevMark = le ; cg_activeMarkPolys . nextMark = le ; return le ; } # define MAX_MARK_FRAGMENTS 128 # define MAX_MARK_POINTS 384 void CG_ImpactMark ( qhandle_t markShader , const vec3_t origin , const vec3_t dir , float orientation , float red , float green , float blue , float alpha , qboolean alphaFade , float radius , qboolean temporary ) { vec3_t axis [ 3 ] ; float texCoordScale ; vec3_t originalPoints [ 4 ] ; byte colors [ 4 ] ; int i , j ; int numFragments ; markFragment_t markFragments [ MAX_MARK_FRAGMENTS ] , * mf ; vec3_t markPoints [ MAX_MARK_POINTS ] ; vec3_t projection ; if ( ! cg_addMarks . integer ) { return ; } if ( radius <= 0 ) { CG_Error ( " CG _ ImpactMark ▁ called ▁ with ▁ < = ▁ 0 ▁ radius " ) ; } VectorNormalize2 ( dir , axis [ 0 ] ) ; PerpendicularVector ( axis [ 1 ] , axis [ 0 ] ) ; RotatePointAroundVector ( axis [ 2 ] , axis [ 0 ] , axis [ 1 ] , orientation ) ; CrossProduct ( axis [ 0 ] , axis [ 2 ] , axis [ 1 ] ) ; texCoordScale = 0.5 * 1.0 / radius ; for ( i = 0 ; i < 3 ; i ++ ) { originalPoints [ 0 ] [ i ] = origin [ i ] - radius * axis [ 1 ] [ i ] - radius * axis [ 2 ] [ i ] ; originalPoints [ 1 ] [ i ] = origin [ i ] + radius * axis [ 1 ] [ i ] - radius * axis [ 2 ] [ i ] ; originalPoints [ 2 ] [ i ] = origin [ i ] + radius * axis [ 1 ] [ i ] + radius * axis [ 2 ] [ i ] ; originalPoints [ 3 ] [ i ] = origin [ i ] - radius * axis [ 1 ] [ i ] + radius * axis [ 2 ] [ i ] ; } VectorScale ( dir , - 20 , projection ) ; numFragments = cgi_CM_MarkFragments ( 4 , ( const float ( * ) [ 3 ] ) originalPoints , projection , MAX_MARK_POINTS , markPoints [ 0 ] , MAX_MARK_FRAGMENTS , markFragments ) ; colors [ 0 ] = red * 255 ; colors [ 1 ] = green * 255 ; colors [ 2 ] = blue * 255 ; colors [ 3 ] = alpha * 255 ; for ( i = 0 , mf = markFragments ; i < numFragments ; i ++ , mf ++ ) { polyVert_t * v ; polyVert_t verts [ MAX_VERTS_ON_POLY ] ; markPoly_t * mark ; if ( mf -> numPoints > MAX_VERTS_ON_POLY ) { mf -> numPoints = MAX_VERTS_ON_POLY ; } for ( j = 0 , v = verts ; j < mf -> numPoints ; j ++ , v ++ ) { vec3_t delta ; VectorCopy ( markPoints [ mf -> firstPoint + j ] , v -> xyz ) ; VectorSubtract ( v -> xyz , origin , delta ) ; v -> st [ 0 ] = 0.5f + DotProduct ( delta , axis [ 1 ] ) * texCoordScale ; v -> st [ 1 ] = 0.5f + DotProduct ( delta , axis [ 2 ] ) * texCoordScale ; for ( int k = 0 ; k < 4 ; k ++ ) { v -> modulate [ k ] = colors [ k ] ; } } if ( temporary ) { cgi_R_AddPolyToScene ( markShader , mf -> numPoints , verts ) ; continue ; } mark = CG_AllocMark ( ) ; mark -> time = cg . time ; mark -> alphaFade = alphaFade ; mark -> markShader = markShader ; mark -> poly . numVerts = mf -> numPoints ; mark -> color [ 0 ] = colors [ 0 ] ; mark -> color [ 1 ] = colors [ 1 ] ; mark -> color [ 2 ] = colors [ 2 ] ; mark -> color [ 3 ] = colors [ 3 ] ; memcpy ( mark -> verts , verts , mf -> numPoints * sizeof ( verts [ 0 ] ) ) ; } } # define MARK_TOTAL_TIME 10000 # define MARK_FADE_TIME 1000 void CG_AddMarks ( void ) { int j ; markPoly_t * mp , * next ; int t ; int fade ; if ( ! cg_addMarks . integer ) { return ; } mp = cg_activeMarkPolys . nextMark ; for ( ; mp != & cg_activeMarkPolys ; mp = next ) { next = mp -> nextMark ; if ( cg . time > mp -> time + MARK_TOTAL_TIME ) { CG_FreeMarkPoly ( mp ) ; continue ; } t = mp -> time + MARK_TOTAL_TIME - cg . time ; if ( t < MARK_FADE_TIME ) { fade = 255 * t / MARK_FADE_TIME ; if ( mp -> alphaFade ) { for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 3 ] = fade ; } } else { float f = ( float ) t / MARK_FADE_TIME ; for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 0 ] = mp -> color [ 0 ] * f ; mp -> verts [ j ] . modulate [ 1 ] = mp -> color [ 1 ] * f ; mp -> verts [ j ] . modulate [ 2 ] = mp -> color [ 2 ] * f ; } } } else { for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 0 ] = mp -> color [ 0 ] ; mp -> verts [ j ] . modulate [ 1 ] = mp -> color [ 1 ] ; mp -> verts [ j ] . modulate [ 2 ] = mp -> color [ 2 ] ; } } cgi_R_AddPolyToScene ( mp -> markShader , mp -> poly . numVerts , mp -> verts ) ; } } </DOCUMENT>
<DOCUMENT_ID="AshamaneProject/AshamaneCore/tree/master/dep/CascLib/src/CascDecompress.cpp"> # define __CASCLIB_SELF__ # include " CascLib . h " # include " CascCommon . h " DWORD CascDecompress ( LPBYTE pbOutBuffer , PDWORD pcbOutBuffer , LPBYTE pbInBuffer , DWORD cbInBuffer ) { z_stream z ; DWORD dwErrCode = ERROR_FILE_CORRUPT ; uInt cbOutBuffer = * pcbOutBuffer ; int nResult ; z . next_in = pbInBuffer ; z . avail_in = cbInBuffer ; z . total_in = cbInBuffer ; z . next_out = pbOutBuffer ; z . avail_out = cbOutBuffer ; z . total_out = 0 ; z . zalloc = NULL ; z . zfree = NULL ; cbOutBuffer = 0 ; if ( ( nResult = inflateInit ( & z ) ) == Z_OK ) { nResult = inflate ( & z , Z_NO_FLUSH ) ; if ( nResult == Z_OK || nResult == Z_STREAM_END ) { cbOutBuffer = z . total_out ; dwErrCode = ERROR_SUCCESS ; } inflateEnd ( & z ) ; } pcbOutBuffer [ 0 ] = cbOutBuffer ; return dwErrCode ; } </DOCUMENT>
<DOCUMENT_ID="MattMulhern/OpenMamaCassandra/tree/master/mamda/c_cpp/src/examples/parsecmd.cpp"> # include < mama / mama . h > # include < mama / mamacpp . h > # include < mama / MamaTransport . h > # include " parsecmd . h " # include < fstream > # include < iostream > # include < string > # include < map > # include < string . h > # include < mamda / MamdaVersion . h > using std :: ifstream ; using std :: cerr ; using std :: string ; using std :: map ; using namespace Wombat ; typedef map < string , const char * > OptionMap ; extern void usage ( int ) ; ExampleLogLevel gExampleLogLevel = EXAMPLE_LOG_LEVEL_NORMAL ; struct CommonCommandLineParser :: CommonCommandLineParserImpl { CommonCommandLineParserImpl ( int argc , const char * argv [ ] ) ; const char * mSourceName ; const char * mTportName ; MamaSource * mSource ; const char * mDictSourceName ; const char * mDictTportName ; const char * mDictFileName ; MamaSource * mDictSource ; const char * mOptionSourceName ; const char * mOptionTportName ; MamaSource * mOptionSource ; const char * mSymbolMapFile ; vector < const char * > mSymbolList ; double mThrottleRate ; int mThreads ; double mTimeout ; MamaLogLevel mSubscLogLevel ; OptionMap mOptions ; bool mLogReqResp ; bool mUseWorldView ; const char * mSymbology ; int mChurnRate ; double mTimerInterval ; const char * mLogFileName ; const char * mMiddleware ; int mPrecision ; int mShutdownTime ; bool mShowDeltas ; mamaBridge mBridge ; bool mSnapShot ; const char * mQueryArg1 ; const char * mQueryArg2 ; const char * mQueryArg3 ; const char * mQueryArg4 ; int mQuery ; int mQueryType ; int mQueryCycles ; bool mPublishRecaps ; } ; CommonCommandLineParser :: CommonCommandLineParser ( int argc , const char * argv [ ] ) : mImpl ( * new CommonCommandLineParserImpl ( argc , argv ) ) { } CommonCommandLineParser :: ~ CommonCommandLineParser ( ) { delete & mImpl ; } bool CommonCommandLineParser :: getPublishRecaps ( ) { return mImpl . mPublishRecaps ; } MamaSource * CommonCommandLineParser :: getSource ( ) { if ( ! mImpl . mSource ) { mImpl . mSource = new MamaSource ( " default " , mImpl . mTportName , mImpl . mSourceName , mImpl . mBridge ) ; mImpl . mSource -> getTransport ( ) -> setOutboundThrottle ( mImpl . mThrottleRate , MAMA_THROTTLE_DEFAULT ) ; } return mImpl . mSource ; } MamaSource * CommonCommandLineParser :: getDictSource ( ) { if ( ! mImpl . mDictSource ) { mImpl . mDictSource = new MamaSource ( " dict " , mImpl . mDictTportName ? mImpl . mDictTportName : mImpl . mTportName , mImpl . mDictSourceName , mImpl . mBridge ) ; } return mImpl . mDictSource ; } MamaSource * CommonCommandLineParser :: getOptionSource ( ) { if ( ! mImpl . mOptionSource ) { mImpl . mOptionSource = new MamaSource ( " options " , mImpl . mOptionTportName ? mImpl . mOptionTportName : mImpl . mTportName , mImpl . mOptionSourceName , mImpl . mBridge ) ; mImpl . mOptionSource -> getTransport ( ) -> setOutboundThrottle ( mImpl . mThrottleRate , MAMA_THROTTLE_DEFAULT ) ; } return mImpl . mOptionSource ; } const char * CommonCommandLineParser :: getSymbolMapFile ( ) { return mImpl . mSymbolMapFile ; } const vector < const char * > & CommonCommandLineParser :: getSymbolList ( ) { return mImpl . mSymbolList ; } double CommonCommandLineParser :: getThrottleRate ( ) { return mImpl . mThrottleRate ; } int CommonCommandLineParser :: getNumThreads ( ) { return mImpl . mThreads ; } double CommonCommandLineParser :: getTimeout ( ) { return mImpl . mTimeout ; } MamaLogLevel CommonCommandLineParser :: getSubscLogLevel ( ) { return mImpl . mSubscLogLevel ; } bool CommonCommandLineParser :: getUseWorldview ( ) { return mImpl . mUseWorldView ; } bool CommonCommandLineParser :: getLogReqResp ( ) { return mImpl . mLogReqResp ; } const char * CommonCommandLineParser :: getSymbology ( ) { return mImpl . mSymbology ; } const char * CommonCommandLineParser :: getMiddleware ( ) { return mImpl . mMiddleware ; } int CommonCommandLineParser :: getPrecision ( ) { return mImpl . mPrecision ; } int CommonCommandLineParser :: getShutdownTime ( ) { return mImpl . mShutdownTime ; } bool CommonCommandLineParser :: showDeltas ( ) { return mImpl . mShowDeltas ; } mamaBridge CommonCommandLineParser :: getBridge ( ) { return mImpl . mBridge ; } bool CommonCommandLineParser :: getSnapshot ( ) { return mImpl . mSnapShot ; } bool CommonCommandLineParser :: getOptBool ( char option0 ) { string option ( & option0 , 0 , 1 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; return ( found != mImpl . mOptions . end ( ) ) ; } bool CommonCommandLineParser :: getOptBool ( const char * option0 ) { string option ( option0 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; return ( found != mImpl . mOptions . end ( ) ) ; } int CommonCommandLineParser :: getOptInt ( char option0 , int defaultValue ) { string option ( & option0 , 0 , 1 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; if ( found != mImpl . mOptions . end ( ) ) { const char * value = found -> second ; if ( value ) return strtol ( value , NULL , 10 ) ; } return defaultValue ; } int CommonCommandLineParser :: getOptInt ( const char * option0 , int defaultValue ) { string option ( option0 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; if ( found != mImpl . mOptions . end ( ) ) { const char * value = found -> second ; if ( value ) return strtol ( value , NULL , 10 ) ; } return defaultValue ; } const char * CommonCommandLineParser :: getOptString ( char option0 ) { string option ( & option0 , 0 , 1 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; if ( found != mImpl . mOptions . end ( ) ) { return found -> second ; } return NULL ; } const char * CommonCommandLineParser :: getOptString ( const char * option0 ) { string option ( option0 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; if ( found != mImpl . mOptions . end ( ) ) { return found -> second ; } return NULL ; } int CommonCommandLineParser :: getChurnRate ( ) { return mImpl . mChurnRate ; } double CommonCommandLineParser :: getTimerInterval ( ) { return mImpl . mTimerInterval ; } const char * CommonCommandLineParser :: getLogFileName ( ) { return mImpl . mLogFileName ; } const char * CommonCommandLineParser :: getQueryArg1 ( ) { return mImpl . mQueryArg1 ; } const char * CommonCommandLineParser :: getQueryArg2 ( ) { return mImpl . mQueryArg2 ; } const char * CommonCommandLineParser :: getQueryArg3 ( ) { return mImpl . mQueryArg3 ; } const char * CommonCommandLineParser :: getQueryArg4 ( ) { return mImpl . mQueryArg4 ; } int CommonCommandLineParser :: getQuery ( ) { return mImpl . mQuery ; } int CommonCommandLineParser :: getQueryType ( ) { return mImpl . mQueryType ; } int CommonCommandLineParser :: getQueries ( ) { return mImpl . mQueryCycles ; } CommonCommandLineParser :: CommonCommandLineParserImpl :: CommonCommandLineParserImpl ( int argc , const char * argv [ ] ) { mSource = NULL ; mDictSource = NULL ; mOptionSource = NULL ; mSymbolMapFile = NULL ; mThrottleRate = 500.0 ; mThreads = 0 ; mTimeout = 1.0 ; mChurnRate = 0 ; mTimerInterval = 1.0 ; mLogFileName = NULL ; mMiddleware = " wmw " ; mPrecision = 2 ; mShutdownTime = 0 ; mShowDeltas = false ; mBridge = NULL ; int i = 1 ; mUseWorldView = false ; mTportName = NULL ; mDictTportName = NULL ; mOptionTportName = NULL ; mSourceName = " WOMBAT " ; mDictSourceName = " WOMBAT " ; mOptionSourceName = " OPRA " ; mSnapShot = false ; mPublishRecaps = false ; mQueryArg1 = NULL ; mQueryArg2 = NULL ; mQueryArg3 = NULL ; mQueryArg4 = NULL ; mQuery = 0 ; mQueryType = 0 ; mQueryCycles = 1 ; while ( i < argc ) { bool handled = false ; if ( ( strcmp ( argv [ i ] , " - OS " ) == 0 ) || ( strcmp ( argv [ i ] , " - optionSource " ) == 0 ) || ( strcmp ( argv [ i ] , " - option - source " ) == 0 ) ) { mOptionSourceName = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - S " ) == 0 ) || ( strcmp ( argv [ i ] , " - source " ) == 0 ) ) { mSourceName = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - use _ dict _ file " ) == 0 ) ) { mDictFileName = argv [ i + 1 ] ; } else if ( ( strcmp ( argv [ i ] , " - DS " ) == 0 ) || ( strcmp ( argv [ i ] , " - dict - source " ) == 0 ) || ( strcmp ( argv [ i ] , " - dictSource " ) == 0 ) || ( strcmp ( argv [ i ] , " - d " ) == 0 ) ) { mDictSourceName = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - T " ) == 0 ) || ( strcmp ( argv [ i ] , " - tport " ) == 0 ) ) { mTportName = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - DT " ) == 0 ) || ( strcmp ( argv [ i ] , " - dictTport " ) == 0 ) || ( strcmp ( argv [ i ] , " - dict - tport " ) == 0 ) || ( strcmp ( argv [ i ] , " - dict _ tport " ) == 0 ) ) { mDictTportName = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - OT " ) == 0 ) || ( strcmp ( argv [ i ] , " - optionTport " ) == 0 ) || ( strcmp ( argv [ i ] , " - option - tport " ) == 0 ) ) { mOptionTportName = argv [ i + 1 ] ; handled = true ; } else if ( strcmp ( argv [ i ] , " - s " ) == 0 ) { mSymbolList . push_back ( argv [ i + 1 ] ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - threads " ) == 0 ) { mThreads = strtol ( argv [ i + 1 ] , NULL , 10 ) ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - r " ) == 0 ) || ( strcmp ( argv [ i ] , " - rate " ) == 0 ) ) { mThrottleRate = strtod ( argv [ i + 1 ] , NULL ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - t " ) == 0 ) { mTimeout = strtod ( argv [ i + 1 ] , NULL ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - mp " ) == 0 ) { mSymbolMapFile = argv [ i + 1 ] ; handled = true ; } else if ( strcmp ( argv [ i ] , " - m " ) == 0 ) { mMiddleware = argv [ i + 1 ] ; handled = true ; } else if ( strcmp ( argv [ i ] , " - precision " ) == 0 ) { mPrecision = strtol ( argv [ i + 1 ] , NULL , 10 ) ; if ( ! mPrecision ) { mPrecision = 2 ; } if ( mPrecision > 6 ) { mPrecision = 6 ; } handled = true ; } else if ( strcmp ( " - shutdown " , argv [ i ] ) == 0 ) { mShutdownTime = atoi ( argv [ i + 1 ] ) ; } else if ( strcmp ( argv [ i ] , " - deltas " ) == 0 ) { mShowDeltas = true ; } else if ( strcmp ( argv [ i ] , " - churn " ) == 0 ) { mChurnRate = strtol ( argv [ i + 1 ] , NULL , 10 ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - timerInterval " ) == 0 ) { mTimerInterval = strtod ( argv [ i + 1 ] , NULL ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - logfile " ) == 0 ) { mLogFileName = argv [ i + 1 ] ; handled = true ; } else if ( strcmp ( argv [ i ] , " - f " ) == 0 ) { const char * filename = argv [ i + 1 ] ; ifstream input ( filename ) ; if ( ! input ) { cerr << " Cannot ▁ open ▁ file : ▁ " << filename << " \n " ; exit ( 1 ) ; } string symbol ; input >> symbol ; while ( ! input . eof ( ) ) { if ( ! symbol . empty ( ) ) { mSymbolList . push_back ( strdup ( symbol . c_str ( ) ) ) ; } input >> symbol ; } handled = true ; } else if ( strcmp ( argv [ i ] , " - v " ) == 0 ) { if ( mama_getLogLevel ( ) == MAMA_LOG_LEVEL_NORMAL ) { mama_enableLogging ( stderr , MAMA_LOG_LEVEL_FINE ) ; } else if ( mama_getLogLevel ( ) == MAMA_LOG_LEVEL_FINE ) { mama_enableLogging ( stderr , MAMA_LOG_LEVEL_FINER ) ; } else { mama_enableLogging ( stderr , MAMA_LOG_LEVEL_FINEST ) ; } handled = true ; } else if ( strcmp ( argv [ i ] , " - q " ) == 0 ) { if ( gExampleLogLevel == EXAMPLE_LOG_LEVEL_NORMAL ) { gExampleLogLevel = EXAMPLE_LOG_LEVEL_QUIET ; } else if ( gExampleLogLevel == EXAMPLE_LOG_LEVEL_QUIET ) { gExampleLogLevel = EXAMPLE_LOG_LEVEL_QUIETER ; } else if ( gExampleLogLevel == EXAMPLE_LOG_LEVEL_QUIETER ) { gExampleLogLevel = EXAMPLE_LOG_LEVEL_QUIETEST ; } handled = true ; } else if ( strcmp ( argv [ i ] , " - V " ) == 0 ) { if ( mSubscLogLevel == MAMA_LOG_LEVEL_NORMAL ) { mSubscLogLevel = MAMA_LOG_LEVEL_FINE ; } else if ( mSubscLogLevel == MAMA_LOG_LEVEL_FINE ) { mSubscLogLevel = MAMA_LOG_LEVEL_FINER ; } else { mSubscLogLevel = MAMA_LOG_LEVEL_FINEST ; } handled = true ; } else if ( strcmp ( argv [ i ] , " - W " ) == 0 ) { mUseWorldView = true ; handled = true ; } else if ( strcmp ( argv [ i ] , " - L " ) == 0 ) { mLogReqResp = true ; handled = true ; } else if ( strcmp ( argv [ i ] , " - Y " ) == 0 ) { mSymbology = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - ? " ) == 0 ) || ( strcmp ( argv [ i ] , " - - help " ) == 0 ) ) { usage ( 1 ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - PR " ) == 0 ) { mPublishRecaps = true ; } else if ( strcmp ( argv [ i ] , " - 1" ) == 0 ) { mSnapShot = true ; handled = true ; } else if ( strcmp ( argv [ i ] , " - Q " ) == 0 ) { mQuery = strtol ( argv [ i + 1 ] , NULL , 10 ) ; } else if ( strcmp ( argv [ i ] , " - QT " ) == 0 ) { mQueryType = strtol ( argv [ i + 1 ] , NULL , 10 ) ; } else if ( strcmp ( argv [ i ] , " - A1" ) == 0 ) { mQueryArg1 = argv [ i + 1 ] ; } else if ( strcmp ( argv [ i ] , " - A2" ) == 0 ) { mQueryArg2 = argv [ i + 1 ] ; } else if ( strcmp ( argv [ i ] , " - A3" ) == 0 ) { mQueryArg3 = argv [ i + 1 ] ; } else if ( strcmp ( argv [ i ] , " - A4" ) == 0 ) { mQueryArg4 = argv [ i + 1 ] ; } else if ( strcmp ( argv [ i ] , " - QC " ) == 0 ) { mQueryCycles = strtol ( argv [ i + 1 ] , NULL , 10 ) ; } if ( argv [ i ] [ 0 ] == ' - ' ) { const char * opt = argv [ i ] + 1 ; if ( strlen ( opt ) > 0 ) { if ( ( i + 1 < argc ) && ( argv [ i + 1 ] [ 0 ] != ' - ' ) ) { mOptions [ opt ] = argv [ i + 1 ] ; i += 2 ; } else { mOptions [ opt ] = "1" ; i ++ ; } } handled = true ; } if ( ! handled ) { usage ( 1 ) ; } } mBridge = Mama :: loadBridge ( mMiddleware ) ; } </DOCUMENT>
<DOCUMENT_ID="Dmitry-Me/coreclr/tree/master/src/jit/lowerarm.cpp"> # include " jitpch . h " # ifdef _MSC_VER # pragma hdrstop # endif # ifndef LEGACY_BACKEND # ifdef _TARGET_ARM_ # include " jit . h " # include " sideeffects . h " # include " lower . h " # include " lsra . h " void Lowering :: LowerCast ( GenTree * tree ) { NYI_ARM ( " ARM ▁ Lowering ▁ for ▁ cast " ) ; } void Lowering :: LowerRotate ( GenTreePtr tree ) { NYI_ARM ( " ARM ▁ Lowering ▁ for ▁ ROL ▁ and ▁ ROR " ) ; } void Lowering :: TreeNodeInfoInit ( GenTree * stmt ) { NYI ( " ARM ▁ TreeNodInfoInit " ) ; } bool Lowering :: isRMWRegOper ( GenTreePtr tree ) { return false ; } bool Lowering :: IsCallTargetInRange ( void * addr ) { return comp -> codeGen -> validImmForBL ( ( ssize_t ) addr ) ; } bool Lowering :: IsContainableImmed ( GenTree * parentNode , GenTree * childNode ) { NYI_ARM ( " ARM ▁ IsContainableImmed " ) ; return false ; } # endif # endif </DOCUMENT>
<DOCUMENT_ID="fritsvanveen/QGIS/tree/master/src/gui/qgsnewhttpconnection.cpp"> # include " qgsnewhttpconnection . h " # include " qgscontexthelp . h " # include " qgsauthconfigselect . h " # include < QSettings > # include < QMessageBox > # include < QUrl > # include < QPushButton > # include < QRegExpValidator > QgsNewHttpConnection :: QgsNewHttpConnection ( QWidget * parent , const QString & baseKey , const QString & connName , Qt :: WindowFlags fl ) : QDialog ( parent , fl ) , mBaseKey ( baseKey ) , mOriginalConnName ( connName ) , mAuthConfigSelect ( nullptr ) { setupUi ( this ) ; QString service = baseKey . mid ( 18 , 3 ) . toUpper ( ) ; setWindowTitle ( tr ( " Create ▁ a ▁ new ▁ % 1 ▁ connection " ) . arg ( service ) ) ; mCredentialsBaseKey = mBaseKey . split ( ' - ' ) . last ( ) . toUpper ( ) ; txtName -> setValidator ( new QRegExpValidator ( QRegExp ( " [ ^ \\ / ] + " ) , txtName ) ) ; cmbDpiMode -> clear ( ) ; cmbDpiMode -> addItem ( tr ( " all " ) ) ; cmbDpiMode -> addItem ( tr ( " off " ) ) ; cmbDpiMode -> addItem ( tr ( " QGIS " ) ) ; cmbDpiMode -> addItem ( tr ( " UMN " ) ) ; cmbDpiMode -> addItem ( tr ( " GeoServer " ) ) ; cmbVersion -> clear ( ) ; cmbVersion -> addItem ( tr ( " Auto - detect " ) ) ; cmbVersion -> addItem ( tr ( "1.0" ) ) ; cmbVersion -> addItem ( tr ( "1.1" ) ) ; cmbVersion -> addItem ( tr ( "2.0" ) ) ; mAuthConfigSelect = new QgsAuthConfigSelect ( this ) ; tabAuth -> insertTab ( 1 , mAuthConfigSelect , tr ( " Configurations " ) ) ; if ( ! connName . isEmpty ( ) ) { QSettings settings ; QString key = mBaseKey + connName ; QString credentialsKey = " / Qgis / " + mCredentialsBaseKey + ' / ' + connName ; txtName -> setText ( connName ) ; txtUrl -> setText ( settings . value ( key + " / url " ) . toString ( ) ) ; cbxIgnoreGetMapURI -> setChecked ( settings . value ( key + " / ignoreGetMapURI " , false ) . toBool ( ) ) ; cbxIgnoreAxisOrientation -> setChecked ( settings . value ( key + " / ignoreAxisOrientation " , false ) . toBool ( ) ) ; cbxInvertAxisOrientation -> setChecked ( settings . value ( key + " / invertAxisOrientation " , false ) . toBool ( ) ) ; cbxIgnoreGetFeatureInfoURI -> setChecked ( settings . value ( key + " / ignoreGetFeatureInfoURI " , false ) . toBool ( ) ) ; cbxSmoothPixmapTransform -> setChecked ( settings . value ( key + " / smoothPixmapTransform " , false ) . toBool ( ) ) ; int dpiIdx ; switch ( settings . value ( key + " / dpiMode " , 7 ) . toInt ( ) ) { case 0 : dpiIdx = 1 ; break ; case 1 : dpiIdx = 2 ; break ; case 2 : dpiIdx = 3 ; break ; case 4 : dpiIdx = 4 ; break ; default : dpiIdx = 0 ; break ; } cmbDpiMode -> setCurrentIndex ( dpiIdx ) ; QString version = settings . value ( key + " / version " ) . toString ( ) ; int versionIdx = 0 ; if ( version == "1.0.0" ) versionIdx = 1 ; else if ( version == "1.1.0" ) versionIdx = 2 ; else if ( version == "2.0.0" ) versionIdx = 3 ; cmbVersion -> setCurrentIndex ( versionIdx ) ; txtReferer -> setText ( settings . value ( key + " / referer " ) . toString ( ) ) ; txtMaxNumFeatures -> setText ( settings . value ( key + " / maxnumfeatures " ) . toString ( ) ) ; txtUserName -> setText ( settings . value ( credentialsKey + " / username " ) . toString ( ) ) ; txtPassword -> setText ( settings . value ( credentialsKey + " / password " ) . toString ( ) ) ; QString authcfg = settings . value ( credentialsKey + " / authcfg " ) . toString ( ) ; mAuthConfigSelect -> setConfigId ( authcfg ) ; if ( ! authcfg . isEmpty ( ) ) { tabAuth -> setCurrentIndex ( tabAuth -> indexOf ( mAuthConfigSelect ) ) ; } } if ( mBaseKey != " / Qgis / connections - wms / " ) { if ( mBaseKey != " / Qgis / connections - wcs / " && mBaseKey != " / Qgis / connections - wfs / " ) { cbxIgnoreAxisOrientation -> setVisible ( false ) ; cbxInvertAxisOrientation -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxIgnoreAxisOrientation ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxInvertAxisOrientation ) ; } if ( mBaseKey == " / Qgis / connections - wfs / " ) { cbxIgnoreAxisOrientation -> setText ( tr ( " Ignore ▁ axis ▁ orientation ▁ ( WFS ▁ 1.1 / WFS ▁ 2.0 ) " ) ) ; } if ( mBaseKey == " / Qgis / connections - wcs / " ) { cbxIgnoreGetMapURI -> setText ( tr ( " Ignore ▁ GetCoverage ▁ URI ▁ reported ▁ in ▁ capabilities " ) ) ; cbxIgnoreAxisOrientation -> setText ( tr ( " Ignore ▁ axis ▁ orientation " ) ) ; } else { cbxIgnoreGetMapURI -> setVisible ( false ) ; cbxSmoothPixmapTransform -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxIgnoreGetMapURI ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxSmoothPixmapTransform ) ; } cbxIgnoreGetFeatureInfoURI -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxIgnoreGetFeatureInfoURI ) ; cmbDpiMode -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cmbDpiMode ) ; lblDpiMode -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( lblDpiMode ) ; txtReferer -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( txtReferer ) ; lblReferer -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( lblReferer ) ; } if ( mBaseKey != " / Qgis / connections - wfs / " ) { cmbVersion -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cmbVersion ) ; lblMaxNumFeatures -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( lblMaxNumFeatures ) ; txtMaxNumFeatures -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( txtMaxNumFeatures ) ; } int w = width ( ) ; adjustSize ( ) ; resize ( w , height ( ) ) ; on_txtName_textChanged ( connName ) ; } QgsNewHttpConnection :: ~ QgsNewHttpConnection ( ) { } void QgsNewHttpConnection :: on_txtName_textChanged ( const QString & text ) { Q_UNUSED ( text ) ; buttonBox -> button ( QDialogButtonBox :: Ok ) -> setDisabled ( txtName -> text ( ) . isEmpty ( ) || txtUrl -> text ( ) . isEmpty ( ) ) ; } void QgsNewHttpConnection :: on_txtUrl_textChanged ( const QString & text ) { Q_UNUSED ( text ) ; buttonBox -> button ( QDialogButtonBox :: Ok ) -> setDisabled ( txtName -> text ( ) . isEmpty ( ) || txtUrl -> text ( ) . isEmpty ( ) ) ; } void QgsNewHttpConnection :: accept ( ) { QSettings settings ; QString key = mBaseKey + txtName -> text ( ) ; QString credentialsKey = " / Qgis / " + mCredentialsBaseKey + ' / ' + txtName -> text ( ) ; if ( ( mOriginalConnName . isNull ( ) || mOriginalConnName . compare ( txtName -> text ( ) , Qt :: CaseInsensitive ) != 0 ) && settings . contains ( key + " / url " ) && QMessageBox :: question ( this , tr ( " Save ▁ connection " ) , tr ( " Should ▁ the ▁ existing ▁ connection ▁ % 1 ▁ be ▁ overwritten ? " ) . arg ( txtName -> text ( ) ) , QMessageBox :: Ok | QMessageBox :: Cancel ) == QMessageBox :: Cancel ) { return ; } if ( ! txtPassword -> text ( ) . isEmpty ( ) && QMessageBox :: question ( this , tr ( " Saving ▁ passwords " ) , tr ( " WARNING : ▁ You ▁ have ▁ entered ▁ a ▁ password . ▁ It ▁ will ▁ be ▁ stored ▁ in ▁ plain ▁ text ▁ in ▁ your ▁ project ▁ files ▁ and ▁ in ▁ your ▁ home ▁ directory ▁ on ▁ Unix - like ▁ systems , ▁ or ▁ in ▁ your ▁ user ▁ profile ▁ on ▁ Windows . ▁ If ▁ you ▁ do ▁ not ▁ want ▁ this ▁ to ▁ happen , ▁ please ▁ press ▁ the ▁ Cancel ▁ button . \n Note : ▁ giving ▁ the ▁ password ▁ is ▁ optional . ▁ It ▁ will ▁ be ▁ requested ▁ interactivly , ▁ when ▁ needed . " ) , QMessageBox :: Ok | QMessageBox :: Cancel ) == QMessageBox :: Cancel ) { return ; } if ( ! mOriginalConnName . isNull ( ) && mOriginalConnName != key ) { settings . remove ( mBaseKey + mOriginalConnName ) ; settings . remove ( " / Qgis / " + mCredentialsBaseKey + ' / ' + mOriginalConnName ) ; settings . sync ( ) ; } QUrl url ( txtUrl -> text ( ) . trimmed ( ) ) ; const QList < QPair < QByteArray , QByteArray > > & items = url . encodedQueryItems ( ) ; QHash < QString , QPair < QByteArray , QByteArray > > params ; for ( QList < QPair < QByteArray , QByteArray > > :: const_iterator it = items . constBegin ( ) ; it != items . constEnd ( ) ; ++ it ) { params . insert ( QString ( it -> first ) . toUpper ( ) , * it ) ; } if ( params [ " SERVICE " ] . second . toUpper ( ) == " WMS " || params [ " SERVICE " ] . second . toUpper ( ) == " WFS " || params [ " SERVICE " ] . second . toUpper ( ) == " WCS " ) { url . removeEncodedQueryItem ( params [ " SERVICE " ] . first ) ; url . removeEncodedQueryItem ( params [ " REQUEST " ] . first ) ; url . removeEncodedQueryItem ( params [ " FORMAT " ] . first ) ; } if ( url . encodedPath ( ) . isEmpty ( ) ) { url . setEncodedPath ( " / " ) ; } settings . setValue ( key + " / url " , url . toString ( ) ) ; if ( mBaseKey == " / Qgis / connections - wms / " || mBaseKey == " / Qgis / connections - wcs / " || mBaseKey == " / Qgis / connections - wfs / " ) { settings . setValue ( key + " / ignoreAxisOrientation " , cbxIgnoreAxisOrientation -> isChecked ( ) ) ; settings . setValue ( key + " / invertAxisOrientation " , cbxInvertAxisOrientation -> isChecked ( ) ) ; } if ( mBaseKey == " / Qgis / connections - wms / " || mBaseKey == " / Qgis / connections - wcs / " ) { settings . setValue ( key + " / ignoreGetMapURI " , cbxIgnoreGetMapURI -> isChecked ( ) ) ; settings . setValue ( key + " / smoothPixmapTransform " , cbxSmoothPixmapTransform -> isChecked ( ) ) ; int dpiMode = 0 ; switch ( cmbDpiMode -> currentIndex ( ) ) { case 0 : dpiMode = 7 ; break ; case 1 : dpiMode = 0 ; break ; case 2 : dpiMode = 1 ; break ; case 3 : dpiMode = 2 ; break ; case 4 : dpiMode = 4 ; break ; } settings . setValue ( key + " / dpiMode " , dpiMode ) ; } if ( mBaseKey == " / Qgis / connections - wms / " ) { settings . setValue ( key + " / ignoreGetFeatureInfoURI " , cbxIgnoreGetFeatureInfoURI -> isChecked ( ) ) ; } if ( mBaseKey == " / Qgis / connections - wfs / " ) { QString version = " auto " ; switch ( cmbVersion -> currentIndex ( ) ) { case 0 : version = " auto " ; break ; case 1 : version = "1.0.0" ; break ; case 2 : version = "1.1.0" ; break ; case 3 : version = "2.0.0" ; break ; } settings . setValue ( key + " / version " , version ) ; settings . setValue ( key + " / maxnumfeatures " , txtMaxNumFeatures -> text ( ) ) ; } settings . setValue ( key + " / referer " , txtReferer -> text ( ) ) ; settings . setValue ( credentialsKey + " / username " , txtUserName -> text ( ) ) ; settings . setValue ( credentialsKey + " / password " , txtPassword -> text ( ) ) ; settings . setValue ( credentialsKey + " / authcfg " , mAuthConfigSelect -> configId ( ) ) ; settings . setValue ( mBaseKey + " / selected " , txtName -> text ( ) ) ; QDialog :: accept ( ) ; } </DOCUMENT>
<DOCUMENT_ID="phamelin/ardupilot/tree/master/libraries/AP_Frsky_Telem/AP_Frsky_Telem.cpp"> # include " AP _ Frsky _ Telem . h " # include < AP_InertialSensor / AP_InertialSensor . h > # include < GCS_MAVLink / GCS . h > # include < stdio . h > extern const AP_HAL :: HAL & hal ; ObjectArray < mavlink_statustext_t > AP_Frsky_Telem :: _statustext_queue ( FRSKY_TELEM_PAYLOAD_STATUS_CAPACITY ) ; AP_Frsky_Telem :: AP_Frsky_Telem ( AP_AHRS & ahrs , const AP_BattMonitor & battery , const RangeFinder & rng ) : _ahrs ( ahrs ) , _battery ( battery ) , _rng ( rng ) { } void AP_Frsky_Telem :: init ( const AP_SerialManager & serial_manager , const uint8_t mav_type , const uint32_t * ap_valuep ) { if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_D , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_D ; } else if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_SPort , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_SPort ; } else if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough ; gcs ( ) . register_frsky_telemetry_callback ( this ) ; if ( _frame_string == nullptr ) { queue_message ( MAV_SEVERITY_INFO , AP :: fwversion ( ) . fw_string ) ; } else { char firmware_buf [ MAVLINK_MSG_STATUSTEXT_FIELD_TEXT_LEN + 1 ] ; snprintf ( firmware_buf , sizeof ( firmware_buf ) , " % s ▁ % s " , AP :: fwversion ( ) . fw_string , _frame_string ) ; queue_message ( MAV_SEVERITY_INFO , firmware_buf ) ; } _params . mav_type = mav_type ; if ( ap_valuep == nullptr ) { _ap . value = 0x2000 ; _ap . valuep = & _ap . value ; } else { _ap . valuep = ap_valuep ; } } if ( _port != nullptr ) { hal . scheduler -> register_io_process ( FUNCTOR_BIND_MEMBER ( & AP_Frsky_Telem :: tick , void ) ) ; _port -> set_flow_control ( AP_HAL :: UARTDriver :: FLOW_CONTROL_DISABLE ) ; } } void AP_Frsky_Telem :: send_SPort_Passthrough ( void ) { int16_t numc ; numc = _port -> available ( ) ; if ( numc < 0 ) { return ; } if ( _port -> txspace ( ) < 19 ) { return ; } uint8_t prev_byte = 0 ; for ( int16_t i = 0 ; i < numc ; i ++ ) { prev_byte = _passthrough . new_byte ; _passthrough . new_byte = _port -> read ( ) ; } if ( ( prev_byte == START_STOP_SPORT ) && ( _passthrough . new_byte == SENSOR_ID_28 ) ) { if ( _passthrough . send_attiandrng ) { _passthrough . send_attiandrng = false ; } else { _passthrough . send_attiandrng = true ; uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - _passthrough . params_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 7 , calc_param ( ) ) ; _passthrough . params_timer = AP_HAL :: millis ( ) ; return ; } check_sensor_status_flags ( ) ; check_ekf_status ( ) ; if ( get_next_msg_chunk ( ) ) { send_uint32 ( DIY_FIRST_ID , _msg_chunk . chunk ) ; return ; } if ( ( now - _passthrough . ap_status_timer ) >= 500 ) { if ( ( ( * _ap . valuep ) & AP_INITIALIZED_FLAG ) > 0 ) { send_uint32 ( DIY_FIRST_ID + 1 , calc_ap_status ( ) ) ; _passthrough . ap_status_timer = AP_HAL :: millis ( ) ; } return ; } if ( ( now - _passthrough . batt_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 3 , calc_batt ( 0 ) ) ; _passthrough . batt_timer = AP_HAL :: millis ( ) ; return ; } if ( _battery . num_instances ( ) > 1 ) { if ( ( now - _passthrough . batt_timer2 ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 8 , calc_batt ( 1 ) ) ; _passthrough . batt_timer2 = AP_HAL :: millis ( ) ; return ; } } if ( ( now - _passthrough . gps_status_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 2 , calc_gps_status ( ) ) ; _passthrough . gps_status_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . home_timer ) >= 500 ) { send_uint32 ( DIY_FIRST_ID + 4 , calc_home ( ) ) ; _passthrough . home_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . velandyaw_timer ) >= 500 ) { send_uint32 ( DIY_FIRST_ID + 5 , calc_velandyaw ( ) ) ; _passthrough . velandyaw_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . gps_latlng_timer ) >= 1000 ) { send_uint32 ( GPS_LONG_LATI_FIRST_ID , calc_gps_latlng ( & _passthrough . send_latitude ) ) ; if ( ! _passthrough . send_latitude ) { _passthrough . gps_latlng_timer = AP_HAL :: millis ( ) ; } return ; } } send_uint32 ( DIY_FIRST_ID + 6 , calc_attiandrng ( ) ) ; } } void AP_Frsky_Telem :: send_SPort ( void ) { int16_t numc ; numc = _port -> available ( ) ; if ( numc < 0 ) { return ; } if ( _port -> txspace ( ) < 19 ) { return ; } for ( int16_t i = 0 ; i < numc ; i ++ ) { int16_t readbyte = _port -> read ( ) ; if ( _SPort . sport_status == false ) { if ( readbyte == START_STOP_SPORT ) { _SPort . sport_status = true ; } } else { switch ( readbyte ) { case SENSOR_ID_FAS : switch ( _SPort . fas_call ) { case 0 : send_uint32 ( DATA_ID_FUEL , ( uint16_t ) roundf ( _battery . capacity_remaining_pct ( ) ) ) ; break ; case 1 : send_uint32 ( DATA_ID_VFAS , ( uint16_t ) roundf ( _battery . voltage ( ) * 10.0f ) ) ; break ; case 2 : send_uint32 ( DATA_ID_CURRENT , ( uint16_t ) roundf ( _battery . current_amps ( ) * 10.0f ) ) ; break ; } if ( _SPort . fas_call ++ > 2 ) _SPort . fas_call = 0 ; break ; case SENSOR_ID_GPS : switch ( _SPort . gps_call ) { case 0 : calc_gps_position ( ) ; send_uint32 ( DATA_ID_GPS_LAT_BP , _gps . latdddmm ) ; break ; case 1 : send_uint32 ( DATA_ID_GPS_LAT_AP , _gps . latmmmm ) ; break ; case 2 : send_uint32 ( DATA_ID_GPS_LAT_NS , _gps . lat_ns ) ; break ; case 3 : send_uint32 ( DATA_ID_GPS_LONG_BP , _gps . londddmm ) ; break ; case 4 : send_uint32 ( DATA_ID_GPS_LONG_AP , _gps . lonmmmm ) ; break ; case 5 : send_uint32 ( DATA_ID_GPS_LONG_EW , _gps . lon_ew ) ; break ; case 6 : send_uint32 ( DATA_ID_GPS_SPEED_BP , _gps . speed_in_meter ) ; break ; case 7 : send_uint32 ( DATA_ID_GPS_SPEED_AP , _gps . speed_in_centimeter ) ; break ; case 8 : send_uint32 ( DATA_ID_GPS_ALT_BP , _gps . alt_gps_meters ) ; break ; case 9 : send_uint32 ( DATA_ID_GPS_ALT_AP , _gps . alt_gps_cm ) ; break ; case 10 : send_uint32 ( DATA_ID_GPS_COURS_BP , ( uint16_t ) ( ( _ahrs . yaw_sensor / 100 ) % 360 ) ) ; break ; } if ( _SPort . gps_call ++ > 10 ) _SPort . gps_call = 0 ; break ; case SENSOR_ID_VARIO : switch ( _SPort . vario_call ) { case 0 : calc_nav_alt ( ) ; send_uint32 ( DATA_ID_BARO_ALT_BP , _gps . alt_nav_meters ) ; break ; case 1 : send_uint32 ( DATA_ID_BARO_ALT_AP , _gps . alt_nav_cm ) ; break ; } if ( _SPort . vario_call ++ > 1 ) _SPort . vario_call = 0 ; break ; case SENSOR_ID_SP2UR : switch ( _SPort . various_call ) { case 0 : send_uint32 ( DATA_ID_TEMP2 , ( uint16_t ) ( AP :: gps ( ) . num_sats ( ) * 10 + AP :: gps ( ) . status ( ) ) ) ; break ; case 1 : send_uint32 ( DATA_ID_TEMP1 , _ap . control_mode ) ; break ; } if ( _SPort . various_call ++ > 1 ) _SPort . various_call = 0 ; break ; } _SPort . sport_status = false ; } } } void AP_Frsky_Telem :: send_D ( void ) { uint32_t now = AP_HAL :: millis ( ) ; if ( now - _D . last_200ms_frame >= 200 ) { _D . last_200ms_frame = now ; send_uint16 ( DATA_ID_TEMP2 , ( uint16_t ) ( AP :: gps ( ) . num_sats ( ) * 10 + AP :: gps ( ) . status ( ) ) ) ; send_uint16 ( DATA_ID_TEMP1 , _ap . control_mode ) ; send_uint16 ( DATA_ID_FUEL , ( uint16_t ) roundf ( _battery . capacity_remaining_pct ( ) ) ) ; send_uint16 ( DATA_ID_VFAS , ( uint16_t ) roundf ( _battery . voltage ( ) * 10.0f ) ) ; send_uint16 ( DATA_ID_CURRENT , ( uint16_t ) roundf ( _battery . current_amps ( ) * 10.0f ) ) ; calc_nav_alt ( ) ; send_uint16 ( DATA_ID_BARO_ALT_BP , _gps . alt_nav_meters ) ; send_uint16 ( DATA_ID_BARO_ALT_AP , _gps . alt_nav_cm ) ; } if ( now - _D . last_1000ms_frame >= 1000 ) { _D . last_1000ms_frame = now ; send_uint16 ( DATA_ID_GPS_COURS_BP , ( uint16_t ) ( ( _ahrs . yaw_sensor / 100 ) % 360 ) ) ; calc_gps_position ( ) ; if ( AP :: gps ( ) . status ( ) >= 3 ) { send_uint16 ( DATA_ID_GPS_LAT_BP , _gps . latdddmm ) ; send_uint16 ( DATA_ID_GPS_LAT_AP , _gps . latmmmm ) ; send_uint16 ( DATA_ID_GPS_LAT_NS , _gps . lat_ns ) ; send_uint16 ( DATA_ID_GPS_LONG_BP , _gps . londddmm ) ; send_uint16 ( DATA_ID_GPS_LONG_AP , _gps . lonmmmm ) ; send_uint16 ( DATA_ID_GPS_LONG_EW , _gps . lon_ew ) ; send_uint16 ( DATA_ID_GPS_SPEED_BP , _gps . speed_in_meter ) ; send_uint16 ( DATA_ID_GPS_SPEED_AP , _gps . speed_in_centimeter ) ; send_uint16 ( DATA_ID_GPS_ALT_BP , _gps . alt_gps_meters ) ; send_uint16 ( DATA_ID_GPS_ALT_AP , _gps . alt_gps_cm ) ; } } } void AP_Frsky_Telem :: tick ( void ) { if ( ! _initialised_uart ) { if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { _port -> begin ( AP_SERIALMANAGER_FRSKY_D_BAUD , AP_SERIALMANAGER_FRSKY_BUFSIZE_RX , AP_SERIALMANAGER_FRSKY_BUFSIZE_TX ) ; } else { _port -> begin ( AP_SERIALMANAGER_FRSKY_SPORT_BAUD , AP_SERIALMANAGER_FRSKY_BUFSIZE_RX , AP_SERIALMANAGER_FRSKY_BUFSIZE_TX ) ; } _initialised_uart = true ; } if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { send_D ( ) ; } else if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_SPort ) { send_SPort ( ) ; } else if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough ) { send_SPort_Passthrough ( ) ; } } void AP_Frsky_Telem :: calc_crc ( uint8_t byte ) { _crc += byte ; _crc += _crc >> 8 ; _crc &= 0xFF ; } void AP_Frsky_Telem :: send_crc ( void ) { send_byte ( 0xFF - _crc ) ; _crc = 0 ; } void AP_Frsky_Telem :: send_byte ( uint8_t byte ) { if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { if ( byte == START_STOP_D ) { _port -> write ( 0x5D ) ; _port -> write ( 0x3E ) ; } else if ( byte == BYTESTUFF_D ) { _port -> write ( 0x5D ) ; _port -> write ( 0x3D ) ; } else { _port -> write ( byte ) ; } } else { if ( byte == START_STOP_SPORT ) { _port -> write ( 0x7D ) ; _port -> write ( 0x5E ) ; } else if ( byte == BYTESTUFF_SPORT ) { _port -> write ( 0x7D ) ; _port -> write ( 0x5D ) ; } else { _port -> write ( byte ) ; } calc_crc ( byte ) ; } } void AP_Frsky_Telem :: send_uint32 ( uint16_t id , uint32_t data ) { send_byte ( 0x10 ) ; uint8_t * bytes = ( uint8_t * ) & id ; send_byte ( bytes [ 0 ] ) ; send_byte ( bytes [ 1 ] ) ; bytes = ( uint8_t * ) & data ; send_byte ( bytes [ 0 ] ) ; send_byte ( bytes [ 1 ] ) ; send_byte ( bytes [ 2 ] ) ; send_byte ( bytes [ 3 ] ) ; send_crc ( ) ; } void AP_Frsky_Telem :: send_uint16 ( uint16_t id , uint16_t data ) { _port -> write ( START_STOP_D ) ; uint8_t * bytes = ( uint8_t * ) & id ; send_byte ( bytes [ 0 ] ) ; bytes = ( uint8_t * ) & data ; send_byte ( bytes [ 0 ] ) ; send_byte ( bytes [ 1 ] ) ; } bool AP_Frsky_Telem :: get_next_msg_chunk ( void ) { if ( _statustext_queue . empty ( ) ) { return false ; } if ( _msg_chunk . repeats == 0 ) { uint8_t character = 0 ; _msg_chunk . chunk = 0 ; for ( int i = 3 ; i > - 1 && _msg_chunk . char_index < sizeof ( _statustext_queue [ 0 ] -> text ) ; i -- ) { character = _statustext_queue [ 0 ] -> text [ _msg_chunk . char_index ++ ] ; if ( ! character ) { break ; } _msg_chunk . chunk |= character << i * 8 ; } if ( ! character || ( _msg_chunk . char_index == sizeof ( _statustext_queue [ 0 ] -> text ) ) ) { _msg_chunk . char_index = 0 ; _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x4 ) << 21 ; _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x2 ) << 14 ; _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x1 ) << 7 ; } } if ( _msg_chunk . repeats ++ > 2 ) { _msg_chunk . repeats = 0 ; if ( _msg_chunk . char_index == 0 ) { _statustext_queue . remove ( 0 ) ; } } return true ; } void AP_Frsky_Telem :: queue_message ( MAV_SEVERITY severity , const char * text ) { mavlink_statustext_t statustext { } ; statustext . severity = severity ; strncpy ( statustext . text , text , sizeof ( statustext . text ) ) ; _statustext_queue . push_force ( statustext ) ; } void AP_Frsky_Telem :: check_sensor_status_flags ( void ) { uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - check_sensor_status_timer ) >= 5000 ) { if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_GPS ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ GPS ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_GYRO ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Gyro ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_ACCEL ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Accel ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_MAG ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Compass ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Baro ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_LASER_POSITION ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ LiDAR ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ OptFlow ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_TERRAIN ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ or ▁ No ▁ Terrain ▁ Data " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_GEOFENCE ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Geofence ▁ Breach " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_AHRS ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ AHRS " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_RC_RECEIVER ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " No ▁ RC ▁ Receiver " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_LOGGING ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Logging " ) ; check_sensor_status_timer = now ; } } } void AP_Frsky_Telem :: check_ekf_status ( void ) { float velVar , posVar , hgtVar , tasVar ; Vector3f magVar ; Vector2f offset ; if ( _ahrs . get_variances ( velVar , posVar , hgtVar , magVar , tasVar , offset ) ) { uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - check_ekf_status_timer ) >= 10000 ) { if ( velVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ velocity ▁ variance " ) ; check_ekf_status_timer = now ; } if ( posVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ pos ▁ horiz ▁ variance " ) ; check_ekf_status_timer = now ; } if ( hgtVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ pos ▁ vert ▁ variance " ) ; check_ekf_status_timer = now ; } if ( magVar . length ( ) >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ compass ▁ variance " ) ; check_ekf_status_timer = now ; } if ( tasVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ terrain ▁ alt ▁ variance " ) ; check_ekf_status_timer = now ; } } } } uint32_t AP_Frsky_Telem :: calc_param ( void ) { uint32_t param = 0 ; if ( _paramID >= 5 ) { _paramID = 0 ; } _paramID ++ ; switch ( _paramID ) { case 1 : param = _params . mav_type ; break ; case 2 : case 3 : break ; case 4 : param = ( uint32_t ) roundf ( _battery . pack_capacity_mah ( 0 ) ) ; break ; case 5 : param = ( uint32_t ) roundf ( _battery . pack_capacity_mah ( 1 ) ) ; break ; } param = ( _paramID << PARAM_ID_OFFSET ) | ( param & PARAM_VALUE_LIMIT ) ; return param ; } uint32_t AP_Frsky_Telem :: calc_gps_latlng ( bool * send_latitude ) { uint32_t latlng ; const Location & loc = AP :: gps ( ) . location ( 0 ) ; if ( ( * send_latitude ) == true ) { if ( loc . lat < 0 ) { latlng = ( ( labs ( loc . lat ) / 100 ) * 6 ) | 0x40000000 ; } else { latlng = ( ( labs ( loc . lat ) / 100 ) * 6 ) ; } ( * send_latitude ) = false ; } else { if ( loc . lng < 0 ) { latlng = ( ( labs ( loc . lng ) / 100 ) * 6 ) | 0xC0000000 ; } else { latlng = ( ( labs ( loc . lng ) / 100 ) * 6 ) | 0x80000000 ; } ( * send_latitude ) = true ; } return latlng ; } uint32_t AP_Frsky_Telem :: calc_gps_status ( void ) { const AP_GPS & gps = AP :: gps ( ) ; uint32_t gps_status ; gps_status = ( gps . num_sats ( ) < GPS_SATS_LIMIT ) ? gps . num_sats ( ) : GPS_SATS_LIMIT ; gps_status |= ( ( gps . status ( ) < GPS_STATUS_LIMIT ) ? gps . status ( ) : GPS_STATUS_LIMIT ) << GPS_STATUS_OFFSET ; gps_status |= prep_number ( roundf ( gps . get_hdop ( ) * 0.1f ) , 2 , 1 ) << GPS_HDOP_OFFSET ; gps_status |= ( ( gps . status ( ) > GPS_STATUS_LIMIT ) ? gps . status ( ) - GPS_STATUS_LIMIT : 0 ) << GPS_ADVSTATUS_OFFSET ; const Location & loc = gps . location ( ) ; gps_status |= prep_number ( roundf ( loc . alt * 0.1f ) , 2 , 2 ) << GPS_ALTMSL_OFFSET ; return gps_status ; } uint32_t AP_Frsky_Telem :: calc_batt ( uint8_t instance ) { uint32_t batt ; batt = ( ( ( uint16_t ) roundf ( _battery . voltage ( instance ) * 10.0f ) ) & BATT_VOLTAGE_LIMIT ) ; batt |= prep_number ( roundf ( _battery . current_amps ( instance ) * 10.0f ) , 2 , 1 ) << BATT_CURRENT_OFFSET ; batt |= ( ( _battery . consumed_mah ( instance ) < BATT_TOTALMAH_LIMIT ) ? ( ( uint16_t ) roundf ( _battery . consumed_mah ( instance ) ) & BATT_TOTALMAH_LIMIT ) : BATT_TOTALMAH_LIMIT ) << BATT_TOTALMAH_OFFSET ; return batt ; } uint32_t AP_Frsky_Telem :: calc_ap_status ( void ) { uint32_t ap_status ; uint8_t imu_temp = ( uint8_t ) roundf ( constrain_float ( AP :: ins ( ) . get_temperature ( 0 ) , AP_IMU_TEMP_MIN , AP_IMU_TEMP_MAX ) - AP_IMU_TEMP_MIN ) ; ap_status = ( uint8_t ) ( ( _ap . control_mode + 1 ) & AP_CONTROL_MODE_LIMIT ) ; ap_status |= ( uint8_t ) ( ( * _ap . valuep ) & AP_SSIMPLE_FLAGS ) << AP_SSIMPLE_OFFSET ; ap_status |= ( uint8_t ) ( ( ( * _ap . valuep ) & AP_LANDCOMPLETE_FLAG ) ^ AP_LANDCOMPLETE_FLAG ) ; ap_status |= ( uint8_t ) ( AP_Notify :: flags . armed ) << AP_ARMED_OFFSET ; ap_status |= ( uint8_t ) ( AP_Notify :: flags . failsafe_battery ) << AP_BATT_FS_OFFSET ; ap_status |= ( uint8_t ) ( AP_Notify :: flags . ekf_bad ) << AP_EKF_FS_OFFSET ; ap_status |= imu_temp << AP_IMU_TEMP_OFFSET ; return ap_status ; } uint32_t AP_Frsky_Telem :: calc_home ( void ) { uint32_t home = 0 ; Location loc ; float _relative_home_altitude = 0 ; if ( _ahrs . get_position ( loc ) ) { const Location & home_loc = _ahrs . get_home ( ) ; if ( home_loc . lat != 0 || home_loc . lng != 0 ) { home = prep_number ( roundf ( get_distance ( home_loc , loc ) ) , 3 , 2 ) ; home |= ( ( ( uint8_t ) roundf ( get_bearing_cd ( loc , home_loc ) * 0.00333f ) ) & HOME_BEARING_LIMIT ) << HOME_BEARING_OFFSET ; } _relative_home_altitude = loc . alt ; if ( ! loc . flags . relative_alt ) { _relative_home_altitude -= _ahrs . get_home ( ) . alt ; } } home |= prep_number ( roundf ( _relative_home_altitude * 0.1f ) , 3 , 2 ) << HOME_ALT_OFFSET ; return home ; } uint32_t AP_Frsky_Telem :: calc_velandyaw ( void ) { uint32_t velandyaw ; Vector3f velNED { } ; _ahrs . get_velocity_NED ( velNED ) ; velandyaw = prep_number ( roundf ( - velNED . z * 10 ) , 2 , 1 ) ; const AP_Airspeed * aspeed = _ahrs . get_airspeed ( ) ; if ( aspeed && aspeed -> enabled ( ) ) { velandyaw |= prep_number ( roundf ( aspeed -> get_airspeed ( ) * 10 ) , 2 , 1 ) << VELANDYAW_XYVEL_OFFSET ; } else { velandyaw |= prep_number ( roundf ( _ahrs . groundspeed ( ) * 10 ) , 2 , 1 ) << VELANDYAW_XYVEL_OFFSET ; } velandyaw |= ( ( uint16_t ) roundf ( _ahrs . yaw_sensor * 0.05f ) & VELANDYAW_YAW_LIMIT ) << VELANDYAW_YAW_OFFSET ; return velandyaw ; } uint32_t AP_Frsky_Telem :: calc_attiandrng ( void ) { uint32_t attiandrng ; attiandrng = ( ( uint16_t ) roundf ( ( _ahrs . roll_sensor + 18000 ) * 0.05f ) & ATTIANDRNG_ROLL_LIMIT ) ; attiandrng |= ( ( uint16_t ) roundf ( ( _ahrs . pitch_sensor + 9000 ) * 0.05f ) & ATTIANDRNG_PITCH_LIMIT ) << ATTIANDRNG_PITCH_OFFSET ; attiandrng |= prep_number ( _rng . distance_cm_orient ( ROTATION_PITCH_270 ) , 3 , 1 ) << ATTIANDRNG_RNGFND_OFFSET ; return attiandrng ; } uint16_t AP_Frsky_Telem :: prep_number ( int32_t number , uint8_t digits , uint8_t power ) { uint16_t res = 0 ; uint32_t abs_number = abs ( number ) ; if ( ( digits == 2 ) && ( power == 1 ) ) { if ( abs_number < 100 ) { res = abs_number << 1 ; } else if ( abs_number < 1270 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.1f ) << 1 ) | 0x1 ; } else { res = 0xFF ; } if ( number < 0 ) { res |= 0x1 << 8 ; } } else if ( ( digits == 2 ) && ( power == 2 ) ) { if ( abs_number < 100 ) { res = abs_number << 2 ; } else if ( abs_number < 1000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.1f ) << 2 ) | 0x1 ; } else if ( abs_number < 10000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.01f ) << 2 ) | 0x2 ; } else if ( abs_number < 127000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.001f ) << 2 ) | 0x3 ; } else { res = 0x1FF ; } if ( number < 0 ) { res |= 0x1 << 9 ; } } else if ( ( digits == 3 ) && ( power == 1 ) ) { if ( abs_number < 1000 ) { res = abs_number << 1 ; } else if ( abs_number < 10240 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.1f ) << 1 ) | 0x1 ; } else { res = 0x7FF ; } if ( number < 0 ) { res |= 0x1 << 11 ; } } else if ( ( digits == 3 ) && ( power == 2 ) ) { if ( abs_number < 1000 ) { res = abs_number << 2 ; } else if ( abs_number < 10000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.1f ) << 2 ) | 0x1 ; } else if ( abs_number < 100000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.01f ) << 2 ) | 0x2 ; } else if ( abs_number < 1024000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.001f ) << 2 ) | 0x3 ; } else { res = 0xFFF ; } if ( number < 0 ) { res |= 0x1 << 12 ; } } return res ; } void AP_Frsky_Telem :: calc_nav_alt ( void ) { Location loc ; float current_height = 0 ; if ( _ahrs . get_position ( loc ) ) { current_height = loc . alt * 0.01f ; if ( ! loc . flags . relative_alt ) { current_height -= _ahrs . get_home ( ) . alt * 0.01f ; } } _gps . alt_nav_meters = ( int16_t ) current_height ; _gps . alt_nav_cm = ( current_height - _gps . alt_nav_meters ) * 100 ; } float AP_Frsky_Telem :: format_gps ( float dec ) { uint8_t dm_deg = ( uint8_t ) dec ; return ( dm_deg * 100.0f ) + ( dec - dm_deg ) * 60 ; } void AP_Frsky_Telem :: calc_gps_position ( void ) { float lat ; float lon ; float alt ; float speed ; if ( AP :: gps ( ) . status ( ) >= 3 ) { const Location & loc = AP :: gps ( ) . location ( ) ; lat = format_gps ( fabsf ( loc . lat / 10000000.0f ) ) ; _gps . latdddmm = lat ; _gps . latmmmm = ( lat - _gps . latdddmm ) * 10000 ; _gps . lat_ns = ( loc . lat < 0 ) ? ' S ' : ' N ' ; lon = format_gps ( fabsf ( loc . lng / 10000000.0f ) ) ; _gps . londddmm = lon ; _gps . lonmmmm = ( lon - _gps . londddmm ) * 10000 ; _gps . lon_ew = ( loc . lng < 0 ) ? ' W ' : ' E ' ; alt = loc . alt * 0.01f ; _gps . alt_gps_meters = ( int16_t ) alt ; _gps . alt_gps_cm = ( alt - _gps . alt_gps_meters ) * 100 ; speed = AP :: gps ( ) . ground_speed ( ) ; _gps . speed_in_meter = speed ; _gps . speed_in_centimeter = ( speed - _gps . speed_in_meter ) * 100 ; } else { _gps . latdddmm = 0 ; _gps . latmmmm = 0 ; _gps . lat_ns = 0 ; _gps . londddmm = 0 ; _gps . lonmmmm = 0 ; _gps . alt_gps_meters = 0 ; _gps . alt_gps_cm = 0 ; _gps . speed_in_meter = 0 ; _gps . speed_in_centimeter = 0 ; } } </DOCUMENT>
<DOCUMENT_ID="tectronics/mysql-parallel-replication/tree/master/extra/yassl/taocrypt/src/hash.cpp"> # include " runtime . hpp " # include < string . h > # include < assert . h > # include " hash . hpp " namespace TaoCrypt { HASHwithTransform :: HASHwithTransform ( word32 digSz , word32 buffSz ) { assert ( digSz <= MaxDigestSz ) ; assert ( buffSz <= MaxBufferSz ) ; } void HASHwithTransform :: AddLength ( word32 len ) { HashLengthType tmp = loLen_ ; if ( ( loLen_ += len ) < tmp ) hiLen_ ++ ; hiLen_ += SafeRightShift < 8 * sizeof ( HashLengthType ) > ( len ) ; } void HASHwithTransform :: Update ( const byte * data , word32 len ) { word32 blockSz = getBlockSize ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; while ( len ) { word32 add = min ( len , blockSz - buffLen_ ) ; memcpy ( & local [ buffLen_ ] , data , add ) ; buffLen_ += add ; data += add ; len -= add ; if ( buffLen_ == blockSz ) { ByteReverseIf ( local , local , blockSz , getByteOrder ( ) ) ; Transform ( ) ; AddLength ( blockSz ) ; buffLen_ = 0 ; } } } void HASHwithTransform :: Final ( byte * hash ) { word32 blockSz = getBlockSize ( ) ; word32 digestSz = getDigestSize ( ) ; word32 padSz = getPadSize ( ) ; ByteOrder order = getByteOrder ( ) ; AddLength ( buffLen_ ) ; HashLengthType preLoLen = GetBitCountLo ( ) ; HashLengthType preHiLen = GetBitCountHi ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; local [ buffLen_ ++ ] = 0x80 ; if ( buffLen_ > padSz ) { memset ( & local [ buffLen_ ] , 0 , blockSz - buffLen_ ) ; buffLen_ += blockSz - buffLen_ ; ByteReverseIf ( local , local , blockSz , order ) ; Transform ( ) ; buffLen_ = 0 ; } memset ( & local [ buffLen_ ] , 0 , padSz - buffLen_ ) ; ByteReverseIf ( local , local , blockSz , order ) ; memcpy ( & local [ padSz ] , order ? & preHiLen : & preLoLen , sizeof ( preLoLen ) ) ; memcpy ( & local [ padSz + 4 ] , order ? & preLoLen : & preHiLen , sizeof ( preLoLen ) ) ; Transform ( ) ; ByteReverseIf ( digest_ , digest_ , digestSz , order ) ; memcpy ( hash , digest_ , digestSz ) ; Init ( ) ; } # ifdef WORD64_AVAILABLE HASH64withTransform :: HASH64withTransform ( word32 digSz , word32 buffSz ) { assert ( digSz <= MaxDigestSz ) ; assert ( buffSz <= MaxBufferSz ) ; } void HASH64withTransform :: AddLength ( word32 len ) { HashLengthType tmp = loLen_ ; if ( ( loLen_ += len ) < tmp ) hiLen_ ++ ; hiLen_ += SafeRightShift < 8 * sizeof ( HashLengthType ) > ( len ) ; } void HASH64withTransform :: Update ( const byte * data , word32 len ) { word32 blockSz = getBlockSize ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; while ( len ) { word32 add = min ( len , blockSz - buffLen_ ) ; memcpy ( & local [ buffLen_ ] , data , add ) ; buffLen_ += add ; data += add ; len -= add ; if ( buffLen_ == blockSz ) { ByteReverseIf ( buffer_ , buffer_ , blockSz , getByteOrder ( ) ) ; Transform ( ) ; AddLength ( blockSz ) ; buffLen_ = 0 ; } } } void HASH64withTransform :: Final ( byte * hash ) { word32 blockSz = getBlockSize ( ) ; word32 digestSz = getDigestSize ( ) ; word32 padSz = getPadSize ( ) ; ByteOrder order = getByteOrder ( ) ; AddLength ( buffLen_ ) ; HashLengthType preLoLen = GetBitCountLo ( ) ; HashLengthType preHiLen = GetBitCountHi ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; local [ buffLen_ ++ ] = 0x80 ; if ( buffLen_ > padSz ) { memset ( & local [ buffLen_ ] , 0 , blockSz - buffLen_ ) ; buffLen_ += blockSz - buffLen_ ; ByteReverseIf ( buffer_ , buffer_ , blockSz , order ) ; Transform ( ) ; buffLen_ = 0 ; } memset ( & local [ buffLen_ ] , 0 , padSz - buffLen_ ) ; ByteReverseIf ( buffer_ , buffer_ , padSz , order ) ; buffer_ [ blockSz / sizeof ( word64 ) - 2 ] = order ? preHiLen : preLoLen ; buffer_ [ blockSz / sizeof ( word64 ) - 1 ] = order ? preLoLen : preHiLen ; Transform ( ) ; ByteReverseIf ( digest_ , digest_ , digestSz , order ) ; memcpy ( hash , digest_ , digestSz ) ; Init ( ) ; } # endif } </DOCUMENT>
<DOCUMENT_ID="ElvishArtisan/rivendell/tree/master/ripcd/btsrc8iii.cpp"> # include < stdlib . h > # include < qtimer . h > # include < rdapplication . h > # include " btsrc8iii . h " # include " globals . h " BtSrc8Iii :: BtSrc8Iii ( RDMatrix * matrix , QObject * parent ) : Switcher ( matrix , parent ) { bt_istate = 0 ; for ( int i = 0 ; i < BTSRC8III_GPIO_PINS ; i ++ ) { bt_gpi_state [ i ] = false ; bt_gpi_mask [ i ] = false ; } bt_matrix = matrix -> matrix ( ) ; bt_gpis = matrix -> gpis ( ) ; bt_gpos = matrix -> gpos ( ) ; RDTty * tty = new RDTty ( rda -> station ( ) -> name ( ) , matrix -> port ( RDMatrix :: Primary ) ) ; bt_device = new RDTTYDevice ( ) ; if ( tty -> active ( ) ) { bt_device -> setName ( tty -> port ( ) ) ; bt_device -> setSpeed ( tty -> baudRate ( ) ) ; bt_device -> setWordLength ( tty -> dataBits ( ) ) ; bt_device -> setParity ( tty -> parity ( ) ) ; bt_device -> open ( QIODevice :: Unbuffered | QIODevice :: ReadWrite ) ; } delete tty ; bt_gpi_oneshot = new RDOneShot ( this ) ; connect ( bt_gpi_oneshot , SIGNAL ( timeout ( int ) ) , this , SLOT ( gpiOneshotData ( int ) ) ) ; bt_gpo_oneshot = new RDOneShot ( this ) ; connect ( bt_gpo_oneshot , SIGNAL ( timeout ( int ) ) , this , SLOT ( gpoOneshotData ( int ) ) ) ; QTimer * timer = new QTimer ( this , " poll _ timer " ) ; connect ( timer , SIGNAL ( timeout ( ) ) , this , SLOT ( processStatus ( ) ) ) ; timer -> start ( BTSRC8III_POLL_INTERVAL ) ; } BtSrc8Iii :: ~ BtSrc8Iii ( ) { delete bt_device ; delete bt_gpi_oneshot ; delete bt_gpo_oneshot ; } RDMatrix :: Type BtSrc8Iii :: type ( ) { return RDMatrix :: BtSrc8III ; } unsigned BtSrc8Iii :: gpiQuantity ( ) { return bt_gpis ; } unsigned BtSrc8Iii :: gpoQuantity ( ) { return bt_gpos ; } bool BtSrc8Iii :: primaryTtyActive ( ) { return true ; } bool BtSrc8Iii :: secondaryTtyActive ( ) { return false ; } void BtSrc8Iii :: processCommand ( RDMacro * cmd ) { char str [ 9 ] ; switch ( cmd -> command ( ) ) { case RDMacro :: GO : if ( ( cmd -> argQuantity ( ) != 5 ) || ( ( cmd -> arg ( 1 ) . lower ( ) != " i " ) && ( cmd -> arg ( 1 ) . lower ( ) != " o " ) ) || ( cmd -> arg ( 2 ) . toInt ( ) < 1 ) || ( cmd -> arg ( 3 ) . toInt ( ) > bt_gpos ) || ( cmd -> arg ( 2 ) . toInt ( ) > bt_gpos ) || ( ( cmd -> arg ( 3 ) . toInt ( ) != 1 ) && ( cmd -> arg ( 3 ) . toInt ( ) != 0 ) && ( cmd -> arg ( 1 ) . lower ( ) != " i " ) ) || ( ( cmd -> arg ( 3 ) . toInt ( ) != 1 ) && ( cmd -> arg ( 3 ) . toInt ( ) != 0 ) && ( cmd -> arg ( 3 ) . toInt ( ) != - 1 ) && ( cmd -> arg ( 1 ) . lower ( ) == " i " ) ) || ( cmd -> arg ( 4 ) . toInt ( ) < 0 ) ) { cmd -> acknowledge ( false ) ; emit rmlEcho ( cmd ) ; return ; } if ( cmd -> arg ( 3 ) . toInt ( ) == 0 ) { if ( cmd -> arg ( 4 ) . toInt ( ) == 0 ) { if ( cmd -> arg ( 1 ) . lower ( ) == " i " ) { if ( bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] ) { emit gpiChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , false ) ; bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = false ; } bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } if ( cmd -> arg ( 1 ) . lower ( ) == " o " ) { sprintf ( str , " * % dOR % dF \n " , BTSRC8III_UNIT_ID , cmd -> arg ( 2 ) . toInt ( ) ) ; bt_device -> write ( str , 8 ) ; emit gpoChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , false ) ; } } else { if ( cmd -> echoRequested ( ) ) { cmd -> acknowledge ( false ) ; emit rmlEcho ( cmd ) ; } return ; } } else { if ( cmd -> arg ( 3 ) . toInt ( ) == - 1 ) { bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = false ; bt_device -> write ( " * 0SPA \n " , 7 ) ; } else { if ( cmd -> arg ( 4 ) . toInt ( ) == 0 ) { if ( cmd -> arg ( 1 ) . lower ( ) == " i " ) { if ( ! bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] ) { emit gpiChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } if ( cmd -> arg ( 1 ) . lower ( ) == " o " ) { sprintf ( str , " * % dOR % dL \n " , BTSRC8III_UNIT_ID , cmd -> arg ( 2 ) . toInt ( ) ) ; bt_device -> write ( str , 8 ) ; emit gpoChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; } } else { if ( cmd -> arg ( 1 ) . lower ( ) == " i " ) { if ( ! bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] ) { emit gpiChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; bt_gpi_oneshot -> start ( cmd -> arg ( 2 ) . toInt ( ) - 1 , 500 ) ; } if ( cmd -> arg ( 1 ) . lower ( ) == " o " ) { sprintf ( str , " * % dOR % dP % 02d \n " , BTSRC8III_UNIT_ID , cmd -> arg ( 2 ) . toInt ( ) , cmd -> arg ( 4 ) . toInt ( ) / 100 + 1 ) ; bt_device -> write ( str , 10 ) ; emit gpoChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; bt_gpo_oneshot -> start ( cmd -> arg ( 2 ) . toInt ( ) - 1 , 500 ) ; } } } } if ( cmd -> echoRequested ( ) ) { cmd -> acknowledge ( true ) ; emit rmlEcho ( cmd ) ; } break ; default : cmd -> acknowledge ( false ) ; emit rmlEcho ( cmd ) ; break ; } } void BtSrc8Iii :: processStatus ( ) { char buffer [ 256 ] ; int n ; int gpi ; while ( ( n = bt_device -> read ( buffer , 255 ) ) > 0 ) { for ( int i = 0 ; i < n ; i ++ ) { switch ( bt_istate ) { case 0 : if ( buffer [ i ] == ' S ' ) { bt_istate = 1 ; } break ; case 1 : if ( buffer [ i ] == ( BTSRC8III_UNIT_ID + '0' ) ) { bt_istate = 2 ; } else { bt_istate = 0 ; } break ; case 2 : if ( buffer [ i ] == ' P ' ) { bt_istate = 3 ; } else { bt_istate = 0 ; } break ; case 3 : if ( buffer [ i ] == ' , ' ) { bt_istate = 4 ; } else { bt_istate = 0 ; } break ; case 4 : if ( buffer [ i ] == ' A ' ) { bt_istate = 5 ; } else { bt_istate = 0 ; } break ; case 5 : case 7 : case 9 : case 11 : case 13 : case 15 : case 17 : case 19 : if ( buffer [ i ] == ' , ' ) { bt_istate ++ ; } else { bt_istate = 0 ; } break ; case 6 : case 8 : case 10 : case 12 : case 14 : case 16 : case 18 : case 20 : if ( buffer [ i ] == '0' ) { gpi = ( bt_istate - 6 ) / 2 ; if ( bt_gpi_state [ gpi ] && ( ! bt_gpi_mask [ gpi ] ) ) { emit gpiChanged ( bt_matrix , gpi , false ) ; bt_gpi_state [ gpi ] = false ; } bt_istate ++ ; } if ( buffer [ i ] == '1' ) { gpi = ( bt_istate - 6 ) / 2 ; if ( ( ! bt_gpi_state [ gpi ] ) && ( ! bt_gpi_mask [ gpi ] ) ) { emit gpiChanged ( bt_matrix , gpi , true ) ; bt_gpi_state [ gpi ] = true ; } bt_istate ++ ; } break ; default : bt_istate = 0 ; } } } } void BtSrc8Iii :: gpiOneshotData ( int value ) { bt_gpi_mask [ value ] = false ; bt_device -> write ( " * 0SPA " , 5 ) ; } void BtSrc8Iii :: gpoOneshotData ( int value ) { emit gpoChanged ( bt_matrix , value , false ) ; } </DOCUMENT>
<DOCUMENT_ID="mgsergio/omim/tree/master/base/osm_id.cpp"> # include " base / osm _ id . hpp " # include " base / assert . hpp " # include < sstream > namespace osm { static const uint64_t NODE = 0x4000000000000000ULL ; static const uint64_t WAY = 0x8000000000000000ULL ; static const uint64_t RELATION = 0xC000000000000000ULL ; static const uint64_t RESET = ~ ( NODE | WAY | RELATION ) ; Id :: Id ( uint64_t encodedId ) : m_encodedId ( encodedId ) { } Id Id :: Node ( uint64_t id ) { return Id ( id | NODE ) ; } Id Id :: Way ( uint64_t id ) { return Id ( id | WAY ) ; } Id Id :: Relation ( uint64_t id ) { return Id ( id | RELATION ) ; } uint64_t Id :: OsmId ( ) const { return m_encodedId & RESET ; } uint64_t Id :: EncodedId ( ) const { return m_encodedId ; } bool Id :: IsNode ( ) const { return ( ( m_encodedId & NODE ) == NODE ) ; } bool Id :: IsWay ( ) const { return ( ( m_encodedId & WAY ) == WAY ) ; } bool Id :: IsRelation ( ) const { return ( ( m_encodedId & RELATION ) == RELATION ) ; } std :: string Id :: Type ( ) const { if ( ( m_encodedId & RELATION ) == RELATION ) return " relation " ; else if ( ( m_encodedId & NODE ) == NODE ) return " node " ; else if ( ( m_encodedId & WAY ) == WAY ) return " way " ; else return " ERROR : ▁ Not ▁ initialized ▁ Osm ▁ ID " ; } std :: string DebugPrint ( osm :: Id const & id ) { std :: ostringstream stream ; stream << id . Type ( ) << " ▁ " << id . OsmId ( ) ; return stream . str ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="Eagle-X/folly/tree/master/folly/test/IPAddressBenchmark.cpp"> # include < folly / IPAddress . h > # include < glog / logging . h > # include < folly / Benchmark . h > using namespace folly ; using std :: string ; BENCHMARK ( ipv4_to_string_inet_ntop , iters ) { folly :: IPAddressV4 ipv4Addr ( "127.0.0.1" ) ; in_addr ip = ipv4Addr . toAddr ( ) ; char outputString [ INET_ADDRSTRLEN ] = { 0 } ; while ( iters -- ) { const char * val = inet_ntop ( AF_INET , & ip , outputString , sizeof ( outputString ) ) ; } } BENCHMARK_RELATIVE ( ipv4_to_fully_qualified , iters ) { IPAddressV4 ip ( "127.0.0.1" ) ; while ( iters -- ) { string outputString = ip . toFullyQualified ( ) ; } } BENCHMARK_DRAW_LINE ( ) BENCHMARK ( ipv6_to_string_inet_ntop , iters ) { IPAddressV6 ipv6Addr ( " F1E0:0ACE : FB94:7ADF : 22E8:6DE6:9672:3725" ) ; in6_addr ip = ipv6Addr . toAddr ( ) ; char outputString [ INET6_ADDRSTRLEN ] = { 0 } ; bool checkResult = ( iters == 1 ) ; while ( iters -- ) { const char * val = inet_ntop ( AF_INET6 , & ip , outputString , sizeof ( outputString ) ) ; } } BENCHMARK_RELATIVE ( ipv6_to_fully_qualified , iters ) { IPAddressV6 ip ( " F1E0:0ACE : FB94:7ADF : 22E8:6DE6:9672:3725" ) ; string outputString ; while ( iters -- ) { outputString = ip . toFullyQualified ( ) ; } } int main ( int argc , char * argv [ ] ) { gflags :: ParseCommandLineFlags ( & argc , & argv , true ) ; runBenchmarks ( ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="Pumpuli/multitheftauto/tree/master/vendor/cegui-0.4.0-custom/WidgetSets/Falagard/src/FalCheckbox.cpp"> # include " StdInc . h " # include " FalCheckbox . h " # include " falagard / CEGUIFalWidgetLookManager . h " # include " falagard / CEGUIFalWidgetLookFeel . h " namespace CEGUI { const utf8 FalagardCheckbox :: WidgetTypeName [ ] = " Falagard / Checkbox " ; FalagardCheckbox :: FalagardCheckbox ( const String & type , const String & name ) : Checkbox ( type , name ) { } FalagardCheckbox :: ~ FalagardCheckbox ( ) { } void FalagardCheckbox :: drawSelf ( float z ) { Checkbox :: drawSelf ( z ) ; Window :: drawSelf ( z ) ; } void FalagardCheckbox :: drawNormal ( float z ) { doButtonRender ( d_selected ? " SelectedNormal " : " Normal " ) ; } void FalagardCheckbox :: drawHover ( float z ) { doButtonRender ( d_selected ? " SelectedHover " : " Hover " ) ; } void FalagardCheckbox :: drawPushed ( float z ) { doButtonRender ( d_selected ? " SelectedPushed " : " Pushed " ) ; } void FalagardCheckbox :: drawDisabled ( float z ) { doButtonRender ( d_selected ? " SelectedDisabled " : " Disabled " ) ; } void FalagardCheckbox :: doButtonRender ( const String & state ) { if ( d_needsRedraw ) { const StateImagery * imagery ; d_renderCache . clearCachedImagery ( ) ; d_needsRedraw = false ; try { const WidgetLookFeel & wlf = WidgetLookManager :: getSingleton ( ) . getWidgetLook ( d_lookName ) ; imagery = wlf . isStateImageryPresent ( state ) ? & wlf . getStateImagery ( state ) : d_selected ? & wlf . getStateImagery ( " SelectedNormal " ) : & wlf . getStateImagery ( " Normal " ) ; } catch ( UnknownObjectException ) { return ; } imagery -> render ( * this ) ; } } Window * FalagardCheckboxFactory :: createWindow ( const String & name ) { return new FalagardCheckbox ( d_type , name ) ; } void FalagardCheckboxFactory :: destroyWindow ( Window * window ) { delete window ; } } </DOCUMENT>
<DOCUMENT_ID="bombehub/PPR_PPV/tree/master/Snap-3.0/snap-exp/test-dev/ExplicitStringTableTest2.cpp"> # include " Snap . h " # include < cstring > # include " BenchmarkUtilities . h " int main ( int argc , char * * argv ) { TBool debug = false ; TStr TagsFnm = " / lfs / madmax4/0 / yonathan / tags " ; if ( debug ) { TagsFnm = " / lfs / madmax4/0 / yonathan / tags _ small " ; } Schema TagS ; TagS . Add ( TPair < TStr , TAttrType > ( " UserId " , atInt ) ) ; TagS . Add ( TPair < TStr , TAttrType > ( " Tag " , atStr ) ) ; float ft_max ; float mu_max ; timeval timer4 ; gettimeofday ( & timer4 , NULL ) ; double t1 = timer4 . tv_sec + ( timer4 . tv_usec / 1000000.0 ) ; PExplicitStringTable ES_Tags = ExplicitStringTable :: LoadSS ( TagS , TagsFnm + " . tsv " ) ; gettimeofday ( & timer4 , NULL ) ; double t2 = timer4 . tv_sec + ( timer4 . tv_usec / 1000000.0 ) ; printf ( " Time ▁ to ▁ load ▁ tags ▁ table : ▁ % f \n " , t2 - t1 ) ; printf ( " Table ▁ Size : \n " ) ; ES_Tags -> PrintSize ( ) ; getmaxcpumem ( & ft_max , & mu_max ) ; printf ( " time : ▁ % 0.3f ▁ seconds , ▁ memory : ▁ % 0.3f ▁ MB \n " , ft_max , mu_max ) ; printf ( " \n " ) ; timeval timer6 ; gettimeofday ( & timer6 , NULL ) ; t1 = timer6 . tv_sec + ( timer6 . tv_usec / 1000000.0 ) ; PExplicitStringTable ES_TagsJoinUser = ES_Tags -> SelfJoin ( " UserId " ) ; gettimeofday ( & timer6 , NULL ) ; t2 = timer6 . tv_sec + ( timer6 . tv_usec / 1000000.0 ) ; printf ( " Time ▁ to ▁ join ▁ on ▁ user ▁ id ▁ column : ▁ % f \n " , t2 - t1 ) ; printf ( " Table ▁ Size : \n " ) ; ES_TagsJoinUser -> PrintSize ( ) ; if ( debug ) { ES_TagsJoinUser -> SaveSS ( TagsFnm + " _ join _ user _ es . tsv " ) ; } getmaxcpumem ( & ft_max , & mu_max ) ; printf ( " time : ▁ % 0.3f ▁ seconds , ▁ memory : ▁ % 0.3f ▁ MB \n " , ft_max , mu_max ) ; printf ( " \n " ) ; timeval timer7 ; gettimeofday ( & timer7 , NULL ) ; t1 = timer7 . tv_sec + ( timer7 . tv_usec / 1000000.0 ) ; PExplicitStringTable ES_JavaTags = ExplicitStringTable :: New ( TagS ) ; TIntV SelectedRows1 ; if ( debug ) { ES_Tags -> SelectAtomicConst ( TStr ( " Tag " ) , TStr ( " c # " ) , EQ , SelectedRows1 , ES_JavaTags , false , true ) ; } else { ES_Tags -> SelectAtomicConst ( TStr ( " Tag " ) , TStr ( " java " ) , EQ , SelectedRows1 , ES_JavaTags , false , true ) ; } gettimeofday ( & timer7 , NULL ) ; t2 = timer7 . tv_sec + ( timer7 . tv_usec / 1000000.0 ) ; printf ( " Time ▁ to ▁ select ▁ java ▁ users : ▁ % f \n " , t2 - t1 ) ; printf ( " Table ▁ Size : \n " ) ; ES_JavaTags -> PrintSize ( ) ; if ( debug ) { ES_JavaTags -> SaveSS ( TagsFnm + " _ select _ es . tsv " ) ; } getmaxcpumem ( & ft_max , & mu_max ) ; printf ( " time : ▁ % 0.3f ▁ seconds , ▁ memory : ▁ % 0.3f ▁ MB \n " , ft_max , mu_max ) ; printf ( " \n " ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="Poxleit/s-core/tree/master/src/scriptdev2/scripts/eastern_kingdoms/shadowfang_keep/instance_shadowfang_keep.cpp"> # include " precompiled . h " # include " shadowfang _ keep . h " instance_shadowfang_keep :: instance_shadowfang_keep ( Map * pMap ) : ScriptedInstance ( pMap ) { Initialize ( ) ; } void instance_shadowfang_keep :: Initialize ( ) { memset ( & m_auiEncounter , 0 , sizeof ( m_auiEncounter ) ) ; } void instance_shadowfang_keep :: OnCreatureCreate ( Creature * pCreature ) { switch ( pCreature -> GetEntry ( ) ) { case NPC_ASH : case NPC_ADA : case NPC_FENRUS : break ; case NPC_VINCENT : if ( m_auiEncounter [ 4 ] == DONE ) pCreature -> SetStandState ( UNIT_STAND_STATE_DEAD ) ; break ; default : return ; } m_mNpcEntryGuidStore [ pCreature -> GetEntry ( ) ] = pCreature -> GetObjectGuid ( ) ; } void instance_shadowfang_keep :: OnObjectCreate ( GameObject * pGo ) { switch ( pGo -> GetEntry ( ) ) { case GO_COURTYARD_DOOR : if ( m_auiEncounter [ 0 ] == DONE ) pGo -> SetGoState ( GO_STATE_ACTIVE ) ; break ; case GO_SORCERER_DOOR : if ( m_auiEncounter [ 2 ] == DONE ) pGo -> SetGoState ( GO_STATE_ACTIVE ) ; break ; case GO_ARUGAL_DOOR : if ( m_auiEncounter [ 3 ] == DONE ) pGo -> SetGoState ( GO_STATE_ACTIVE ) ; break ; case GO_ARUGAL_FOCUS : break ; default : return ; } m_mGoEntryGuidStore [ pGo -> GetEntry ( ) ] = pGo -> GetObjectGuid ( ) ; } void instance_shadowfang_keep :: DoSpeech ( ) { Creature * pAda = GetSingleCreatureFromStorage ( NPC_ADA ) ; Creature * pAsh = GetSingleCreatureFromStorage ( NPC_ASH ) ; if ( pAda && pAda -> isAlive ( ) && pAsh && pAsh -> isAlive ( ) ) { DoScriptText ( SAY_BOSS_DIE_AD , pAda ) ; DoScriptText ( SAY_BOSS_DIE_AS , pAsh ) ; } } void instance_shadowfang_keep :: SetData ( uint32 uiType , uint32 uiData ) { switch ( uiType ) { case TYPE_FREE_NPC : if ( uiData == DONE ) DoUseDoorOrButton ( GO_COURTYARD_DOOR ) ; m_auiEncounter [ 0 ] = uiData ; break ; case TYPE_RETHILGORE : if ( uiData == DONE ) DoSpeech ( ) ; m_auiEncounter [ 1 ] = uiData ; break ; case TYPE_FENRUS : if ( uiData == DONE ) { if ( Creature * pFenrus = GetSingleCreatureFromStorage ( NPC_FENRUS ) ) pFenrus -> SummonCreature ( NPC_ARCHMAGE_ARUGAL , - 136.89f , 2169.17f , 136.58f , 2.794f , TEMPSUMMON_TIMED_DESPAWN , 30000 ) ; } m_auiEncounter [ 2 ] = uiData ; break ; case TYPE_NANDOS : if ( uiData == DONE ) DoUseDoorOrButton ( GO_ARUGAL_DOOR ) ; m_auiEncounter [ 3 ] = uiData ; break ; case TYPE_INTRO : m_auiEncounter [ 4 ] = uiData ; break ; case TYPE_VOIDWALKER : if ( uiData == DONE ) { m_auiEncounter [ 5 ] ++ ; if ( m_auiEncounter [ 5 ] > 3 ) DoUseDoorOrButton ( GO_SORCERER_DOOR ) ; } break ; } if ( uiData == DONE ) { OUT_SAVE_INST_DATA ; std :: ostringstream saveStream ; saveStream << m_auiEncounter [ 0 ] << " ▁ " << m_auiEncounter [ 1 ] << " ▁ " << m_auiEncounter [ 2 ] << " ▁ " << m_auiEncounter [ 3 ] << " ▁ " << m_auiEncounter [ 4 ] << " ▁ " << m_auiEncounter [ 5 ] ; m_strInstData = saveStream . str ( ) ; SaveToDB ( ) ; OUT_SAVE_INST_DATA_COMPLETE ; } } uint32 instance_shadowfang_keep :: GetData ( uint32 uiType ) const { switch ( uiType ) { case TYPE_FREE_NPC : return m_auiEncounter [ 0 ] ; case TYPE_RETHILGORE : return m_auiEncounter [ 1 ] ; case TYPE_FENRUS : return m_auiEncounter [ 2 ] ; case TYPE_NANDOS : return m_auiEncounter [ 3 ] ; case TYPE_INTRO : return m_auiEncounter [ 4 ] ; default : return 0 ; } } void instance_shadowfang_keep :: Load ( const char * chrIn ) { if ( ! chrIn ) { OUT_LOAD_INST_DATA_FAIL ; return ; } OUT_LOAD_INST_DATA ( chrIn ) ; std :: istringstream loadStream ( chrIn ) ; loadStream >> m_auiEncounter [ 0 ] >> m_auiEncounter [ 1 ] >> m_auiEncounter [ 2 ] >> m_auiEncounter [ 3 ] >> m_auiEncounter [ 4 ] >> m_auiEncounter [ 5 ] ; for ( uint8 i = 0 ; i < MAX_ENCOUNTER ; ++ i ) { if ( m_auiEncounter [ i ] == IN_PROGRESS ) m_auiEncounter [ i ] = NOT_STARTED ; } OUT_LOAD_INST_DATA_COMPLETE ; } InstanceData * GetInstanceData_instance_shadowfang_keep ( Map * pMap ) { return new instance_shadowfang_keep ( pMap ) ; } void AddSC_instance_shadowfang_keep ( ) { Script * pNewScript ; pNewScript = new Script ; pNewScript -> Name = " instance _ shadowfang _ keep " ; pNewScript -> GetInstanceData = & GetInstanceData_instance_shadowfang_keep ; pNewScript -> RegisterSelf ( ) ; } </DOCUMENT>
<DOCUMENT_ID="relipse/onethfour-chess-client/tree/master/src/quazip/JlCompress.cpp"> # include " JlCompress . h " # include < QDebug > static bool copyData ( QIODevice & inFile , QIODevice & outFile ) { while ( ! inFile . atEnd ( ) ) { char buf [ 4096 ] ; qint64 readLen = inFile . read ( buf , 4096 ) ; if ( readLen <= 0 ) return false ; if ( outFile . write ( buf , readLen ) != readLen ) return false ; } return true ; } bool JlCompress :: compressFile ( QuaZip * zip , QString fileName , QString fileDest ) { if ( ! zip ) return false ; if ( zip -> getMode ( ) != QuaZip :: mdCreate && zip -> getMode ( ) != QuaZip :: mdAppend && zip -> getMode ( ) != QuaZip :: mdAdd ) return false ; QFile inFile ; inFile . setFileName ( fileName ) ; if ( ! inFile . open ( QIODevice :: ReadOnly ) ) return false ; QuaZipFile outFile ( zip ) ; if ( ! outFile . open ( QIODevice :: WriteOnly , QuaZipNewInfo ( fileDest , inFile . fileName ( ) ) ) ) return false ; if ( ! copyData ( inFile , outFile ) || outFile . getZipError ( ) != UNZ_OK ) { return false ; } outFile . close ( ) ; if ( outFile . getZipError ( ) != UNZ_OK ) return false ; inFile . close ( ) ; return true ; } bool JlCompress :: compressSubDir ( QuaZip * zip , QString dir , QString origDir , bool recursive ) { if ( ! zip ) return false ; if ( zip -> getMode ( ) != QuaZip :: mdCreate && zip -> getMode ( ) != QuaZip :: mdAppend && zip -> getMode ( ) != QuaZip :: mdAdd ) return false ; QDir directory ( dir ) ; if ( ! directory . exists ( ) ) return false ; if ( recursive ) { QFileInfoList files = directory . entryInfoList ( QDir :: AllDirs | QDir :: NoDotAndDotDot ) ; Q_FOREACH ( QFileInfo file , files ) { if ( ! compressSubDir ( zip , file . absoluteFilePath ( ) , origDir , recursive ) ) return false ; } } QFileInfoList files = directory . entryInfoList ( QDir :: Files ) ; QDir origDirectory ( origDir ) ; Q_FOREACH ( QFileInfo file , files ) { if ( ! file . isFile ( ) || file . absoluteFilePath ( ) == zip -> getZipName ( ) ) continue ; QString filename = origDirectory . relativeFilePath ( file . absoluteFilePath ( ) ) ; if ( ! compressFile ( zip , file . absoluteFilePath ( ) , filename ) ) return false ; } return true ; } bool JlCompress :: extractFile ( QuaZip * zip , QString fileName , QString fileDest ) { if ( ! zip ) return false ; if ( zip -> getMode ( ) != QuaZip :: mdUnzip ) return false ; if ( ! fileName . isEmpty ( ) ) zip -> setCurrentFile ( fileName ) ; QuaZipFile inFile ( zip ) ; if ( ! inFile . open ( QIODevice :: ReadOnly ) || inFile . getZipError ( ) != UNZ_OK ) return false ; QDir curDir ; if ( ! curDir . mkpath ( QFileInfo ( fileDest ) . absolutePath ( ) ) ) { return false ; } if ( QFileInfo ( fileDest ) . isDir ( ) ) return true ; QFile outFile ; outFile . setFileName ( fileDest ) ; if ( ! outFile . open ( QIODevice :: WriteOnly ) ) return false ; if ( ! copyData ( inFile , outFile ) || inFile . getZipError ( ) != UNZ_OK ) { outFile . close ( ) ; removeFile ( QStringList ( fileDest ) ) ; return false ; } outFile . close ( ) ; inFile . close ( ) ; if ( inFile . getZipError ( ) != UNZ_OK ) { removeFile ( QStringList ( fileDest ) ) ; return false ; } return true ; } bool JlCompress :: removeFile ( QStringList listFile ) { bool ret = true ; for ( int i = 0 ; i < listFile . count ( ) ; i ++ ) { ret = ret && QFile :: remove ( listFile . at ( i ) ) ; } return ret ; } bool JlCompress :: compressFile ( QString fileCompressed , QString file ) { QuaZip zip ( fileCompressed ) ; QDir ( ) . mkpath ( QFileInfo ( fileCompressed ) . absolutePath ( ) ) ; if ( ! zip . open ( QuaZip :: mdCreate ) ) { QFile :: remove ( fileCompressed ) ; return false ; } if ( ! compressFile ( & zip , file , QFileInfo ( file ) . fileName ( ) ) ) { QFile :: remove ( fileCompressed ) ; return false ; } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { QFile :: remove ( fileCompressed ) ; return false ; } return true ; } bool JlCompress :: compressFiles ( QString fileCompressed , QStringList files ) { QuaZip zip ( fileCompressed ) ; QDir ( ) . mkpath ( QFileInfo ( fileCompressed ) . absolutePath ( ) ) ; if ( ! zip . open ( QuaZip :: mdCreate ) ) { QFile :: remove ( fileCompressed ) ; return false ; } QFileInfo info ; Q_FOREACH ( QString file , files ) { info . setFile ( file ) ; if ( ! info . exists ( ) || ! compressFile ( & zip , file , info . fileName ( ) ) ) { QFile :: remove ( fileCompressed ) ; return false ; } } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { QFile :: remove ( fileCompressed ) ; return false ; } return true ; } bool JlCompress :: compressDir ( QString fileCompressed , QString dir , bool recursive ) { QuaZip zip ( fileCompressed ) ; QDir ( ) . mkpath ( QFileInfo ( fileCompressed ) . absolutePath ( ) ) ; if ( ! zip . open ( QuaZip :: mdCreate ) ) { QFile :: remove ( fileCompressed ) ; return false ; } if ( ! compressSubDir ( & zip , dir , dir , recursive ) ) { QFile :: remove ( fileCompressed ) ; return false ; } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { QFile :: remove ( fileCompressed ) ; return false ; } return true ; } QString JlCompress :: extractFile ( QString fileCompressed , QString fileName , QString fileDest ) { QuaZip zip ( fileCompressed ) ; if ( ! zip . open ( QuaZip :: mdUnzip ) ) { return QString ( ) ; } if ( fileDest . isEmpty ( ) ) fileDest = fileName ; if ( ! extractFile ( & zip , fileName , fileDest ) ) { return QString ( ) ; } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { removeFile ( QStringList ( fileDest ) ) ; return QString ( ) ; } return QFileInfo ( fileDest ) . absoluteFilePath ( ) ; } QStringList JlCompress :: extractFiles ( QString fileCompressed , QStringList files , QString dir ) { QuaZip zip ( fileCompressed ) ; if ( ! zip . open ( QuaZip :: mdUnzip ) ) { return QStringList ( ) ; } QStringList extracted ; for ( int i = 0 ; i < files . count ( ) ; i ++ ) { QString absPath = QDir ( dir ) . absoluteFilePath ( files . at ( i ) ) ; if ( ! extractFile ( & zip , files . at ( i ) , absPath ) ) { removeFile ( extracted ) ; return QStringList ( ) ; } extracted . append ( absPath ) ; } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { removeFile ( extracted ) ; return QStringList ( ) ; } return extracted ; } QStringList JlCompress :: extractDir ( QString fileCompressed , QString dir ) { QuaZip zip ( fileCompressed ) ; if ( ! zip . open ( QuaZip :: mdUnzip ) ) { return QStringList ( ) ; } QDir directory ( dir ) ; QStringList extracted ; if ( ! zip . goToFirstFile ( ) ) { return QStringList ( ) ; } do { QString name = zip . getCurrentFileName ( ) ; QString absFilePath = directory . absoluteFilePath ( name ) ; if ( ! extractFile ( & zip , " " , absFilePath ) ) { removeFile ( extracted ) ; return QStringList ( ) ; } extracted . append ( absFilePath ) ; } while ( zip . goToNextFile ( ) ) ; zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { removeFile ( extracted ) ; return QStringList ( ) ; } return extracted ; } QStringList JlCompress :: getFileList ( QString fileCompressed ) { QuaZip * zip = new QuaZip ( QFileInfo ( fileCompressed ) . absoluteFilePath ( ) ) ; if ( ! zip -> open ( QuaZip :: mdUnzip ) ) { delete zip ; return QStringList ( ) ; } QStringList lst ; QuaZipFileInfo info ; for ( bool more = zip -> goToFirstFile ( ) ; more ; more = zip -> goToNextFile ( ) ) { if ( ! zip -> getCurrentFileInfo ( & info ) ) { delete zip ; return QStringList ( ) ; } lst << info . name ; } zip -> close ( ) ; if ( zip -> getZipError ( ) != 0 ) { delete zip ; return QStringList ( ) ; } delete zip ; return lst ; } </DOCUMENT>
<DOCUMENT_ID="plexinc/plex-home-theater-public/tree/master/plex/Update-Installer/external/win32cpp/tutorials/Tutorial8/View.cpp"> # include " view . h " # include " GDI . h " # include " file . h " # include " resource . h " using namespace std ; CView :: CView ( ) : m_PenColor ( RGB ( 0 , 0 , 0 ) ) { m_Brush . CreateSolidBrush ( RGB ( 255 , 255 , 230 ) ) ; } CView :: ~ CView ( ) { } void CView :: ClearPoints ( ) { m_points . clear ( ) ; Invalidate ( ) ; } void CView :: DrawLine ( int x , int y ) { CClientDC dcClient ( this ) ; dcClient . CreatePen ( PS_SOLID , 1 , m_points . back ( ) . color ) ; dcClient . MoveTo ( m_points . back ( ) . x , m_points . back ( ) . y ) ; dcClient . LineTo ( x , y ) ; } void CView :: OnDraw ( CDC * pDC ) { if ( m_points . size ( ) > 0 ) { bool bDraw = false ; for ( unsigned int i = 0 ; i < m_points . size ( ) ; i ++ ) { pDC -> CreatePen ( PS_SOLID , 1 , m_points [ i ] . color ) ; if ( bDraw ) pDC -> LineTo ( m_points [ i ] . x , m_points [ i ] . y ) ; else pDC -> MoveTo ( m_points [ i ] . x , m_points [ i ] . y ) ; bDraw = m_points [ i ] . PenDown ; } } } void CView :: PreCreate ( CREATESTRUCT & cs ) { cs . dwExStyle = WS_EX_CLIENTEDGE ; } void CView :: PreRegisterClass ( WNDCLASS & wc ) { wc . hbrBackground = m_Brush ; wc . lpszClassName = _T ( " Scribble ▁ Window " ) ; wc . hCursor = :: LoadCursor ( GetApp ( ) -> GetInstanceHandle ( ) , MAKEINTRESOURCE ( IDC_CURSOR1 ) ) ; } BOOL CView :: FileOpen ( LPCTSTR szFilename ) { m_points . clear ( ) ; DWORD nBytesRead ; BOOL bResult = FALSE ; CFile File ; if ( File . Open ( szFilename , OPEN_EXISTING ) ) { do { PlotPoint pp ; nBytesRead = File . Read ( & pp , sizeof ( PlotPoint ) ) ; if ( nBytesRead == sizeof ( PlotPoint ) ) m_points . push_back ( pp ) ; } while ( nBytesRead == sizeof ( PlotPoint ) ) ; if ( ( 0 != nBytesRead ) || ( m_points . empty ( ) ) ) { m_points . clear ( ) ; :: MessageBox ( 0 , _T ( " Invalid ▁ data ▁ in ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; } else bResult = TRUE ; } else { tString tsErrMsg = _T ( " Failed ▁ to ▁ open ▁ file ▁ " ) ; tsErrMsg += szFilename ; :: MessageBox ( 0 , tsErrMsg . c_str ( ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; } Invalidate ( ) ; return bResult ; } BOOL CView :: FileSave ( LPCTSTR szFilename ) { BOOL bResult = TRUE ; CFile hFile ; if ( ! hFile . Open ( szFilename , CREATE_ALWAYS ) ) { :: MessageBox ( 0 , _T ( " Failed ▁ to ▁ open ▁ file ▁ for ▁ writing " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; } if ( bResult ) { for ( size_t i = 0 ; i < m_points . size ( ) ; ++ i ) { if ( ! hFile . Write ( & m_points [ i ] , sizeof ( PlotPoint ) ) ) { :: MessageBox ( 0 , _T ( " Error ▁ while ▁ writing ▁ to ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; break ; } } if ( hFile . GetLength ( ) != m_points . size ( ) * sizeof ( PlotPoint ) ) { :: MessageBox ( 0 , _T ( " Error ▁ while ▁ writing ▁ to ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; } } return bResult ; } void CView :: SetPen ( COLORREF color ) { m_PenColor = color ; } void CView :: StorePoint ( int x , int y , bool PenDown ) { PlotPoint P1 ; P1 . x = x ; P1 . y = y ; P1 . PenDown = PenDown ; P1 . color = m_PenColor ; m_points . push_back ( P1 ) ; } void CView :: OnLButtonDown ( LPARAM lParam ) { SetCapture ( ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , true ) ; } void CView :: OnLButtonUp ( LPARAM lParam ) { { ReleaseCapture ( ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , false ) ; } } void CView :: OnMouseMove ( WPARAM wParam , LPARAM lParam ) { if ( ( wParam & MK_LBUTTON ) && ( GetCapture ( ) == this ) ) { DrawLine ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , true ) ; } } LRESULT CView :: WndProc ( UINT uMsg , WPARAM wParam , LPARAM lParam ) { switch ( uMsg ) { case WM_LBUTTONDOWN : OnLButtonDown ( lParam ) ; break ; case WM_MOUSEMOVE : OnMouseMove ( wParam , lParam ) ; break ; case WM_LBUTTONUP : OnLButtonUp ( lParam ) ; break ; } return WndProcDefault ( uMsg , wParam , lParam ) ; } </DOCUMENT>
<DOCUMENT_ID="ddark/ecl/tree/master/src/server/scripts/Northrend/zone_wintergrasp.cpp"> # include " BattlefieldMgr . h " # include " BattlefieldWG . h " # include " Battlefield . h " # include " ScriptSystem . h " # include " WorldSession . h " # include " ObjectMgr . h " # include " Vehicle . h " # include " GameObjectAI . h " # include " ScriptedCreature . h " # include " ScriptedGossip . h " # include " SpellScript . h " # include " Player . h " # define GOSSIP_HELLO_DEMO1 " Build ▁ catapult . " # define GOSSIP_HELLO_DEMO2 " Build ▁ demolisher . " # define GOSSIP_HELLO_DEMO3 " Build ▁ siege ▁ engine . " # define GOSSIP_HELLO_DEMO4 " I ▁ cannot ▁ build ▁ more ! " enum WGqueuenpctext { WG_NPCQUEUE_TEXT_H_NOWAR = 14775 , WG_NPCQUEUE_TEXT_H_QUEUE = 14790 , WG_NPCQUEUE_TEXT_H_WAR = 14777 , WG_NPCQUEUE_TEXT_A_NOWAR = 14782 , WG_NPCQUEUE_TEXT_A_QUEUE = 14791 , WG_NPCQUEUE_TEXT_A_WAR = 14781 , WG_NPCQUEUE_TEXTOPTION_JOIN = 20077 , } ; enum Spells { SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE = 61409 , SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE = 56662 , SPELL_BUILD_CATAPULT_FORCE = 56664 , SPELL_BUILD_DEMOLISHER_FORCE = 56659 , SPELL_ACTIVATE_CONTROL_ARMS = 49899 , SPELL_RIDE_WG_VEHICLE = 60968 , SPELL_VEHICLE_TELEPORT = 49759 , SPELL_CHANNEL_SPIRIT_HEAL = 22011 , } ; enum CreatureIds { NPC_GOBLIN_MECHANIC = 30400 , NPC_GNOMISH_ENGINEER = 30499 , NPC_WINTERGRASP_CONTROL_ARMS = 27852 , NPC_WORLD_TRIGGER_LARGE_AOI_NOT_IMMUNE_PC_NPC = 23472 , } ; enum QuestIds { QUEST_BONES_AND_ARROWS_HORDE_ATT = 13193 , QUEST_JINXING_THE_WALLS_HORDE_ATT = 13202 , QUEST_SLAY_THEM_ALL_HORDE_ATT = 13180 , QUEST_FUELING_THE_DEMOLISHERS_HORDE_ATT = 13200 , QUEST_HEALING_WITH_ROSES_HORDE_ATT = 13201 , QUEST_DEFEND_THE_SIEGE_HORDE_ATT = 13223 , QUEST_BONES_AND_ARROWS_HORDE_DEF = 13199 , QUEST_WARDING_THE_WALLS_HORDE_DEF = 13192 , QUEST_SLAY_THEM_ALL_HORDE_DEF = 13178 , QUEST_FUELING_THE_DEMOLISHERS_HORDE_DEF = 13191 , QUEST_HEALING_WITH_ROSES_HORDE_DEF = 13194 , QUEST_TOPPLING_THE_TOWERS_HORDE_DEF = 13539 , QUEST_STOP_THE_SIEGE_HORDE_DEF = 13185 , QUEST_BONES_AND_ARROWS_ALLIANCE_ATT = 13196 , QUEST_WARDING_THE_WARRIORS_ALLIANCE_ATT = 13198 , QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_ATT = 13179 , QUEST_DEFEND_THE_SIEGE_ALLIANCE_ATT = 13222 , QUEST_A_RARE_HERB_ALLIANCE_ATT = 13195 , QUEST_BONES_AND_ARROWS_ALLIANCE_DEF = 13154 , QUEST_WARDING_THE_WARRIORS_ALLIANCE_DEF = 13153 , QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_DEF = 13177 , QUEST_SHOUTHERN_SABOTAGE_ALLIANCE_DEF = 13538 , QUEST_STOP_THE_SIEGE_ALLIANCE_DEF = 13186 , QUEST_A_RARE_HERB_ALLIANCE_DEF = 13156 , } ; uint8 const MAX_WINTERGRASP_VEHICLES = 4 ; uint32 const vehiclesList [ MAX_WINTERGRASP_VEHICLES ] = { NPC_WINTERGRASP_CATAPULT , NPC_WINTERGRASP_DEMOLISHER , NPC_WINTERGRASP_SIEGE_ENGINE_ALLIANCE , NPC_WINTERGRASP_SIEGE_ENGINE_HORDE } ; class npc_wg_demolisher_engineer : public CreatureScript { public : npc_wg_demolisher_engineer ( ) : CreatureScript ( " npc _ wg _ demolisher _ engineer " ) { } bool OnGossipHello ( Player * player , Creature * creature ) OVERRIDE { if ( creature -> IsQuestGiver ( ) ) player -> PrepareQuestMenu ( creature -> GetGUID ( ) ) ; if ( CanBuild ( creature ) ) { if ( player -> HasAura ( SPELL_CORPORAL ) ) player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO1 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF ) ; else if ( player -> HasAura ( SPELL_LIEUTENANT ) ) { player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO1 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF ) ; player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO2 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF + 1 ) ; player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO3 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF + 2 ) ; } } else player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO4 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF + 9 ) ; player -> SEND_GOSSIP_MENU ( player -> GetGossipTextId ( creature ) , creature -> GetGUID ( ) ) ; return true ; } bool OnGossipSelect ( Player * player , Creature * creature , uint32 , uint32 action ) OVERRIDE { player -> CLOSE_GOSSIP_MENU ( ) ; if ( CanBuild ( creature ) ) { switch ( action - GOSSIP_ACTION_INFO_DEF ) { case 0 : creature -> CastSpell ( player , SPELL_BUILD_CATAPULT_FORCE , true ) ; break ; case 1 : creature -> CastSpell ( player , SPELL_BUILD_DEMOLISHER_FORCE , true ) ; break ; case 2 : creature -> CastSpell ( player , player -> GetTeamId ( ) == TEAM_ALLIANCE ? SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE : SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE , true ) ; break ; } if ( Creature * controlArms = creature -> FindNearestCreature ( NPC_WINTERGRASP_CONTROL_ARMS , 30.0f , true ) ) creature -> CastSpell ( controlArms , SPELL_ACTIVATE_CONTROL_ARMS , true ) ; } return true ; } private : bool CanBuild ( Creature * creature ) { Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return false ; switch ( creature -> GetEntry ( ) ) { case NPC_GOBLIN_MECHANIC : return ( wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_MAX_VEHICLE_H ) > wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_VEHICLE_H ) ) ; case NPC_GNOMISH_ENGINEER : return ( wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_MAX_VEHICLE_A ) > wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_VEHICLE_A ) ) ; default : return false ; } } } ; class npc_wg_spirit_guide : public CreatureScript { public : npc_wg_spirit_guide ( ) : CreatureScript ( " npc _ wg _ spirit _ guide " ) { } bool OnGossipHello ( Player * player , Creature * creature ) OVERRIDE { if ( creature -> IsQuestGiver ( ) ) player -> PrepareQuestMenu ( creature -> GetGUID ( ) ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return true ; GraveyardVect graveyard = wintergrasp -> GetGraveyardVector ( ) ; for ( uint8 i = 0 ; i < graveyard . size ( ) ; i ++ ) if ( graveyard [ i ] -> GetControlTeamId ( ) == player -> GetTeamId ( ) ) player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , sObjectMgr -> GetTrinityStringForDBCLocale ( ( ( BfGraveyardWG * ) graveyard [ i ] ) -> GetTextId ( ) ) , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF + i ) ; player -> SEND_GOSSIP_MENU ( player -> GetGossipTextId ( creature ) , creature -> GetGUID ( ) ) ; return true ; } bool OnGossipSelect ( Player * player , Creature * , uint32 , uint32 action ) OVERRIDE { player -> CLOSE_GOSSIP_MENU ( ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( wintergrasp ) { GraveyardVect gy = wintergrasp -> GetGraveyardVector ( ) ; for ( uint8 i = 0 ; i < gy . size ( ) ; i ++ ) if ( action - GOSSIP_ACTION_INFO_DEF == i && gy [ i ] -> GetControlTeamId ( ) == player -> GetTeamId ( ) ) if ( WorldSafeLocsEntry const * safeLoc = sWorldSafeLocsStore . LookupEntry ( gy [ i ] -> GetGraveyardId ( ) ) ) player -> TeleportTo ( safeLoc -> map_id , safeLoc -> x , safeLoc -> y , safeLoc -> z , 0 ) ; } return true ; } struct npc_wg_spirit_guideAI : public ScriptedAI { npc_wg_spirit_guideAI ( Creature * creature ) : ScriptedAI ( creature ) { } void UpdateAI ( uint32 ) OVERRIDE { if ( ! me -> HasUnitState ( UNIT_STATE_CASTING ) ) DoCast ( me , SPELL_CHANNEL_SPIRIT_HEAL ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const OVERRIDE { return new npc_wg_spirit_guideAI ( creature ) ; } } ; class npc_wg_queue : public CreatureScript { public : npc_wg_queue ( ) : CreatureScript ( " npc _ wg _ queue " ) { } bool OnGossipHello ( Player * player , Creature * creature ) OVERRIDE { if ( creature -> IsQuestGiver ( ) ) player -> PrepareQuestMenu ( creature -> GetGUID ( ) ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return true ; if ( wintergrasp -> IsWarTime ( ) ) { player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , sObjectMgr -> GetTrinityStringForDBCLocale ( WG_NPCQUEUE_TEXTOPTION_JOIN ) , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF ) ; player -> SEND_GOSSIP_MENU ( wintergrasp -> GetDefenderTeam ( ) ? WG_NPCQUEUE_TEXT_H_WAR : WG_NPCQUEUE_TEXT_A_WAR , creature -> GetGUID ( ) ) ; } else { uint32 timer = wintergrasp -> GetTimer ( ) / 1000 ; player -> SendUpdateWorldState ( 4354 , time ( NULL ) + timer ) ; if ( timer < 15 * MINUTE ) { player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , sObjectMgr -> GetTrinityStringForDBCLocale ( WG_NPCQUEUE_TEXTOPTION_JOIN ) , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF ) ; player -> SEND_GOSSIP_MENU ( wintergrasp -> GetDefenderTeam ( ) ? WG_NPCQUEUE_TEXT_H_QUEUE : WG_NPCQUEUE_TEXT_A_QUEUE , creature -> GetGUID ( ) ) ; } else player -> SEND_GOSSIP_MENU ( wintergrasp -> GetDefenderTeam ( ) ? WG_NPCQUEUE_TEXT_H_NOWAR : WG_NPCQUEUE_TEXT_A_NOWAR , creature -> GetGUID ( ) ) ; } return true ; } bool OnGossipSelect ( Player * player , Creature * , uint32 , uint32 ) OVERRIDE { player -> CLOSE_GOSSIP_MENU ( ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return true ; if ( wintergrasp -> IsWarTime ( ) ) wintergrasp -> InvitePlayerToWar ( player ) ; else { uint32 timer = wintergrasp -> GetTimer ( ) / 1000 ; if ( timer < 15 * MINUTE ) wintergrasp -> InvitePlayerToQueue ( player ) ; } return true ; } } ; class go_wg_vehicle_teleporter : public GameObjectScript { public : go_wg_vehicle_teleporter ( ) : GameObjectScript ( " go _ wg _ vehicle _ teleporter " ) { } struct go_wg_vehicle_teleporterAI : public GameObjectAI { go_wg_vehicle_teleporterAI ( GameObject * gameObject ) : GameObjectAI ( gameObject ) , _checkTimer ( 1000 ) { } void UpdateAI ( uint32 diff ) OVERRIDE { if ( _checkTimer <= diff ) { if ( Battlefield * wg = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ) for ( uint8 i = 0 ; i < MAX_WINTERGRASP_VEHICLES ; i ++ ) if ( Creature * vehicleCreature = go -> FindNearestCreature ( vehiclesList [ i ] , 3.0f , true ) ) if ( ! vehicleCreature -> HasAura ( SPELL_VEHICLE_TELEPORT ) && vehicleCreature -> getFaction ( ) == WintergraspFaction [ wg -> GetDefenderTeam ( ) ] ) if ( Creature * teleportTrigger = vehicleCreature -> FindNearestCreature ( NPC_WORLD_TRIGGER_LARGE_AOI_NOT_IMMUNE_PC_NPC , 100.0f , true ) ) teleportTrigger -> CastSpell ( vehicleCreature , SPELL_VEHICLE_TELEPORT , true ) ; _checkTimer = 1000 ; } else _checkTimer -= diff ; } private : uint32 _checkTimer ; } ; GameObjectAI * GetAI ( GameObject * go ) const OVERRIDE { return new go_wg_vehicle_teleporterAI ( go ) ; } } ; class npc_wg_quest_giver : public CreatureScript { public : npc_wg_quest_giver ( ) : CreatureScript ( " npc _ wg _ quest _ giver " ) { } bool OnGossipHello ( Player * player , Creature * creature ) OVERRIDE { if ( creature -> IsQuestGiver ( ) ) player -> PrepareQuestMenu ( creature -> GetGUID ( ) ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return true ; if ( creature -> IsQuestGiver ( ) ) { QuestRelationBounds objectQR = sObjectMgr -> GetCreatureQuestRelationBounds ( creature -> GetEntry ( ) ) ; QuestRelationBounds objectQIR = sObjectMgr -> GetCreatureQuestInvolvedRelationBounds ( creature -> GetEntry ( ) ) ; QuestMenu & qm = player -> PlayerTalkClass -> GetQuestMenu ( ) ; qm . ClearMenu ( ) ; for ( QuestRelations :: const_iterator i = objectQIR . first ; i != objectQIR . second ; ++ i ) { uint32 questId = i -> second ; QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( status == QUEST_STATUS_COMPLETE ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_INCOMPLETE ) qm . AddMenuItem ( questId , 4 ) ; } for ( QuestRelations :: const_iterator i = objectQR . first ; i != objectQR . second ; ++ i ) { uint32 questId = i -> second ; Quest const * quest = sObjectMgr -> GetQuestTemplate ( questId ) ; if ( ! quest ) continue ; switch ( questId ) { case QUEST_BONES_AND_ARROWS_HORDE_ATT : case QUEST_JINXING_THE_WALLS_HORDE_ATT : case QUEST_SLAY_THEM_ALL_HORDE_ATT : case QUEST_FUELING_THE_DEMOLISHERS_HORDE_ATT : case QUEST_HEALING_WITH_ROSES_HORDE_ATT : case QUEST_DEFEND_THE_SIEGE_HORDE_ATT : if ( wintergrasp -> GetAttackerTeam ( ) == TEAM_HORDE ) { QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; } break ; case QUEST_BONES_AND_ARROWS_HORDE_DEF : case QUEST_WARDING_THE_WALLS_HORDE_DEF : case QUEST_SLAY_THEM_ALL_HORDE_DEF : case QUEST_FUELING_THE_DEMOLISHERS_HORDE_DEF : case QUEST_HEALING_WITH_ROSES_HORDE_DEF : case QUEST_TOPPLING_THE_TOWERS_HORDE_DEF : case QUEST_STOP_THE_SIEGE_HORDE_DEF : if ( wintergrasp -> GetDefenderTeam ( ) == TEAM_HORDE ) { QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; } break ; case QUEST_BONES_AND_ARROWS_ALLIANCE_ATT : case QUEST_WARDING_THE_WARRIORS_ALLIANCE_ATT : case QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_ATT : case QUEST_DEFEND_THE_SIEGE_ALLIANCE_ATT : case QUEST_A_RARE_HERB_ALLIANCE_ATT : if ( wintergrasp -> GetAttackerTeam ( ) == TEAM_ALLIANCE ) { QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; } break ; case QUEST_BONES_AND_ARROWS_ALLIANCE_DEF : case QUEST_WARDING_THE_WARRIORS_ALLIANCE_DEF : case QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_DEF : case QUEST_SHOUTHERN_SABOTAGE_ALLIANCE_DEF : case QUEST_STOP_THE_SIEGE_ALLIANCE_DEF : case QUEST_A_RARE_HERB_ALLIANCE_DEF : if ( wintergrasp -> GetDefenderTeam ( ) == TEAM_ALLIANCE ) { QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; } break ; default : QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; break ; } } } player -> SEND_GOSSIP_MENU ( player -> GetGossipTextId ( creature ) , creature -> GetGUID ( ) ) ; return true ; } } ; class spell_wintergrasp_force_building : public SpellScriptLoader { public : spell_wintergrasp_force_building ( ) : SpellScriptLoader ( " spell _ wintergrasp _ force _ building " ) { } class spell_wintergrasp_force_building_SpellScript : public SpellScript { PrepareSpellScript ( spell_wintergrasp_force_building_SpellScript ) ; bool Validate ( SpellInfo const * ) OVERRIDE { if ( ! sSpellMgr -> GetSpellInfo ( SPELL_BUILD_CATAPULT_FORCE ) || ! sSpellMgr -> GetSpellInfo ( SPELL_BUILD_DEMOLISHER_FORCE ) || ! sSpellMgr -> GetSpellInfo ( SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE ) || ! sSpellMgr -> GetSpellInfo ( SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE ) ) return false ; return true ; } void HandleScript ( SpellEffIndex effIndex ) { PreventHitDefaultEffect ( effIndex ) ; GetHitUnit ( ) -> CastSpell ( GetHitUnit ( ) , GetEffectValue ( ) , false ) ; } void Register ( ) OVERRIDE { OnEffectHitTarget += SpellEffectFn ( spell_wintergrasp_force_building_SpellScript :: HandleScript , EFFECT_0 , SPELL_EFFECT_SCRIPT_EFFECT ) ; } } ; SpellScript * GetSpellScript ( ) const OVERRIDE { return new spell_wintergrasp_force_building_SpellScript ( ) ; } } ; class spell_wintergrasp_grab_passenger : public SpellScriptLoader { public : spell_wintergrasp_grab_passenger ( ) : SpellScriptLoader ( " spell _ wintergrasp _ grab _ passenger " ) { } class spell_wintergrasp_grab_passenger_SpellScript : public SpellScript { PrepareSpellScript ( spell_wintergrasp_grab_passenger_SpellScript ) ; void HandleScript ( SpellEffIndex ) { if ( Player * target = GetHitPlayer ( ) ) target -> CastSpell ( GetCaster ( ) , SPELL_RIDE_WG_VEHICLE , false ) ; } void Register ( ) OVERRIDE { OnEffectHitTarget += SpellEffectFn ( spell_wintergrasp_grab_passenger_SpellScript :: HandleScript , EFFECT_0 , SPELL_EFFECT_SCRIPT_EFFECT ) ; } } ; SpellScript * GetSpellScript ( ) const OVERRIDE { return new spell_wintergrasp_grab_passenger_SpellScript ( ) ; } } ; class achievement_wg_didnt_stand_a_chance : public AchievementCriteriaScript { public : achievement_wg_didnt_stand_a_chance ( ) : AchievementCriteriaScript ( " achievement _ wg _ didnt _ stand _ a _ chance " ) { } bool OnCheck ( Player * source , Unit * target ) OVERRIDE { if ( ! target ) return false ; if ( Player * victim = target -> ToPlayer ( ) ) { if ( ! victim -> IsMounted ( ) ) return false ; if ( Vehicle * vehicle = source -> GetVehicle ( ) ) if ( vehicle -> GetVehicleInfo ( ) -> m_ID == 244 ) return true ; } return false ; } } ; enum WgTeleport { SPELL_WINTERGRASP_TELEPORT_TRIGGER = 54643 , } ; class spell_wintergrasp_defender_teleport : public SpellScriptLoader { public : spell_wintergrasp_defender_teleport ( ) : SpellScriptLoader ( " spell _ wintergrasp _ defender _ teleport " ) { } class spell_wintergrasp_defender_teleport_SpellScript : public SpellScript { PrepareSpellScript ( spell_wintergrasp_defender_teleport_SpellScript ) ; SpellCastResult CheckCast ( ) { if ( Battlefield * wg = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ) if ( Player * target = GetExplTargetUnit ( ) -> ToPlayer ( ) ) if ( ( target -> GetZoneId ( ) == 4197 && target -> GetTeamId ( ) != wg -> GetDefenderTeam ( ) ) || target -> HasAura ( SPELL_WINTERGRASP_TELEPORT_TRIGGER ) ) return SPELL_FAILED_BAD_TARGETS ; return SPELL_CAST_OK ; } void Register ( ) OVERRIDE { OnCheckCast += SpellCheckCastFn ( spell_wintergrasp_defender_teleport_SpellScript :: CheckCast ) ; } } ; SpellScript * GetSpellScript ( ) const OVERRIDE { return new spell_wintergrasp_defender_teleport_SpellScript ( ) ; } } ; class spell_wintergrasp_defender_teleport_trigger : public SpellScriptLoader { public : spell_wintergrasp_defender_teleport_trigger ( ) : SpellScriptLoader ( " spell _ wintergrasp _ defender _ teleport _ trigger " ) { } class spell_wintergrasp_defender_teleport_trigger_SpellScript : public SpellScript { PrepareSpellScript ( spell_wintergrasp_defender_teleport_trigger_SpellScript ) ; void HandleDummy ( SpellEffIndex ) { if ( Unit * target = GetHitUnit ( ) ) { WorldLocation loc ; target -> GetPosition ( & loc ) ; SetExplTargetDest ( loc ) ; } } void Register ( ) OVERRIDE { OnEffectHitTarget += SpellEffectFn ( spell_wintergrasp_defender_teleport_trigger_SpellScript :: HandleDummy , EFFECT_0 , SPELL_EFFECT_DUMMY ) ; } } ; SpellScript * GetSpellScript ( ) const OVERRIDE { return new spell_wintergrasp_defender_teleport_trigger_SpellScript ( ) ; } } ; void AddSC_wintergrasp ( ) { new npc_wg_queue ( ) ; new npc_wg_spirit_guide ( ) ; new npc_wg_demolisher_engineer ( ) ; new go_wg_vehicle_teleporter ( ) ; new npc_wg_quest_giver ( ) ; new spell_wintergrasp_force_building ( ) ; new spell_wintergrasp_grab_passenger ( ) ; new achievement_wg_didnt_stand_a_chance ( ) ; new spell_wintergrasp_defender_teleport ( ) ; new spell_wintergrasp_defender_teleport_trigger ( ) ; } </DOCUMENT>
