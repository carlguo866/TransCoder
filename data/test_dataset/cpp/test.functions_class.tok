MP4DmaxAtom :: MP4DmaxAtom ( ) : MP4Atom ( " dmax " ) { AddProperty ( new MP4Integer32Property ( " milliSecs " ) ) ; }
SDThread :: SDThread ( DatasetDWI * ds , int id ) : m_dataset ( ds ) , m_id ( id ) { m_dwi = ds -> getData ( ) ; m_bvals = ds -> getBvals ( ) ; m_bvecs = ds -> getBvecs ( ) ; int nx = ds -> properties ( " maingl " ) . get ( Fn :: Property :: D_NX ) . toInt ( ) ; int ny = ds -> properties ( " maingl " ) . get ( Fn :: Property :: D_NY ) . toInt ( ) ; int nz = ds -> properties ( " maingl " ) . get ( Fn :: Property :: D_NZ ) . toInt ( ) ; m_blockSize = nx * ny * nz ; }
void SDThread :: run ( ) { int numThreads = GLFunctions :: idealThreadCount ; int progressCounter = 0 ; for ( int i = m_id ; i < m_blockSize ; i += numThreads ) { calcSD ( i ) ; ++ progressCounter ; if ( progressCounter == 100 ) { emit ( progress ( ) ) ; progressCounter = 0 ; } } emit ( finished ( ) ) ; }
ColumnVector SDThread :: calcSD ( int id ) { return ColumnVector ( 20 ) ; }
void Accumulator :: addOperand ( const intrusive_ptr < Expression > & pExpression ) { uassert ( 15943 , str :: stream ( ) << " group ▁ accumulator ▁ " << getOpName ( ) << " ▁ only ▁ accepts ▁ one ▁ operand " , vpOperand . size ( ) < 1 ) ; ExpressionNary :: addOperand ( pExpression ) ; }
void ANNkd_tree :: annkPriSearch ( ANNpoint q , int k , ANNidxArray nn_idx , ANNdistArray dd , double eps ) { ANNprMaxErr = ANN_POW ( 1.0 + eps ) ; ANN_FLOP ( 2 ) ANNprDim = dim ; ANNprQ = q ; ANNprPts = pts ; ANNptsVisited = 0 ; ANNprPointMK = new ANNmin_k ( k ) ; ANNdist box_dist = annBoxDistance ( q , bnd_box_lo , bnd_box_hi , dim ) ; ANNprBoxPQ = new ANNpr_queue ( n_pts ) ; ANNprBoxPQ -> insert ( box_dist , root ) ; while ( ANNprBoxPQ -> non_empty ( ) && ( ! ( ANNmaxPtsVisited != 0 && ANNptsVisited > ANNmaxPtsVisited ) ) ) { ANNkd_ptr np ; ANNprBoxPQ -> extr_min ( box_dist , ( void * & ) np ) ; ANN_FLOP ( 2 ) if ( box_dist * ANNprMaxErr >= ANNprPointMK -> max_key ( ) ) break ; np -> ann_pri_search ( box_dist ) ; } for ( int i = 0 ; i < k ; i ++ ) { dd [ i ] = ANNprPointMK -> ith_smallest_key ( i ) ; nn_idx [ i ] = ANNprPointMK -> ith_smallest_info ( i ) ; } delete ANNprPointMK ; delete ANNprBoxPQ ; }
void ANNkd_split :: ann_pri_search ( ANNdist box_dist ) { ANNdist new_dist ; ANNcoord cut_diff = ANNprQ [ cut_dim ] - cut_val ; if ( cut_diff < 0 ) { ANNcoord box_diff = cd_bnds [ ANN_LO ] - ANNprQ [ cut_dim ] ; if ( box_diff < 0 ) box_diff = 0 ; new_dist = ( ANNdist ) ANN_SUM ( box_dist , ANN_DIFF ( ANN_POW ( box_diff ) , ANN_POW ( cut_diff ) ) ) ; if ( child [ ANN_HI ] != KD_TRIVIAL ) ANNprBoxPQ -> insert ( new_dist , child [ ANN_HI ] ) ; child [ ANN_LO ] -> ann_pri_search ( box_dist ) ; } else { ANNcoord box_diff = ANNprQ [ cut_dim ] - cd_bnds [ ANN_HI ] ; if ( box_diff < 0 ) box_diff = 0 ; new_dist = ( ANNdist ) ANN_SUM ( box_dist , ANN_DIFF ( ANN_POW ( box_diff ) , ANN_POW ( cut_diff ) ) ) ; if ( child [ ANN_LO ] != KD_TRIVIAL ) ANNprBoxPQ -> insert ( new_dist , child [ ANN_LO ] ) ; child [ ANN_HI ] -> ann_pri_search ( box_dist ) ; } ANN_SPL ( 1 ) ANN_FLOP ( 8 ) }
void ANNkd_leaf :: ann_pri_search ( ANNdist box_dist ) { register ANNdist dist ; register ANNcoord * pp ; register ANNcoord * qq ; register ANNdist min_dist ; register ANNcoord t ; register int d ; min_dist = ANNprPointMK -> max_key ( ) ; for ( int i = 0 ; i < n_pts ; i ++ ) { pp = ANNprPts [ bkt [ i ] ] ; qq = ANNprQ ; dist = 0 ; for ( d = 0 ; d < ANNprDim ; d ++ ) { ANN_COORD ( 1 ) ANN_FLOP ( 4 ) t = * ( qq ++ ) - * ( pp ++ ) ; if ( ( dist = ANN_SUM ( dist , ANN_POW ( t ) ) ) > min_dist ) { break ; } } if ( d >= ANNprDim && ( ANN_ALLOW_SELF_MATCH || dist != 0 ) ) { ANNprPointMK -> insert ( dist , bkt [ i ] ) ; min_dist = ANNprPointMK -> max_key ( ) ; } } ANN_LEAF ( 1 ) ANN_PTS ( n_pts ) ANNptsVisited += n_pts ; }
void CDVDSubtitleTagMicroDVD :: ConvertLine ( CDVDOverlayText * pOverlay , const char * line , int len ) { CStdString strUTF8 ; strUTF8 . assign ( line , len ) ; m_flag [ FLAG_BOLD ] = 0 ; m_flag [ FLAG_ITALIC ] = 0 ; m_flag [ FLAG_COLOR ] = 0 ; int machine_status = 1 ; size_t pos = 0 ; while ( machine_status > 0 ) { if ( machine_status == 1 ) { if ( strUTF8 [ pos ] == ' { ' ) { size_t pos2 , pos3 ; if ( ( ( pos2 = strUTF8 . find ( ' : ' , pos ) ) != CStdString :: npos ) && ( ( pos3 = strUTF8 . find ( ' } ' , pos2 ) ) != CStdString :: npos ) ) { CStdString tagName = strUTF8 . substr ( pos + 1 , pos2 - pos - 1 ) ; CStdString tagValue = strUTF8 . substr ( pos2 + 1 , pos3 - pos2 - 1 ) ; StringUtils :: ToLower ( tagValue ) ; strUTF8 . erase ( pos , pos3 - pos + 1 ) ; if ( ( tagName == " Y " ) || ( tagName == " y " ) ) { if ( ( tagValue == " b " ) && ( m_flag [ FLAG_BOLD ] == 0 ) ) { m_flag [ FLAG_BOLD ] = ( tagName == " Y " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , " [ B ] " ) ; pos += 3 ; } else if ( ( tagValue == " i " ) && ( m_flag [ FLAG_ITALIC ] == 0 ) ) { m_flag [ FLAG_ITALIC ] = ( tagName == " Y " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , " [ I ] " ) ; pos += 3 ; } } else if ( ( tagName == " C " ) || ( tagName == " c " ) ) { if ( ( tagValue [ 0 ] == ' $ ' ) && ( tagValue . size ( ) == 7 ) ) { bool bHex = true ; for ( int i = 1 ; i < 7 ; i ++ ) { char temp = tagValue [ i ] ; if ( ! ( ( '0' <= temp && temp <= '9' ) || ( ' a ' <= temp && temp <= ' f ' ) || ( ' A ' <= temp && temp <= ' F ' ) ) ) { bHex = false ; break ; } } if ( bHex && ( m_flag [ FLAG_COLOR ] == 0 ) ) { CStdString tempColorTag = " [ COLOR ▁ " ; tempColorTag += " FF " ; tempColorTag += tagValue . substr ( 1 , 6 ) ; tempColorTag += " ] " ; m_flag [ FLAG_COLOR ] = ( tagName == " C " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , tempColorTag ) ; pos += tempColorTag . length ( ) ; } } } } else machine_status = 2 ; } else if ( strUTF8 [ pos ] == ' / ' ) { if ( m_flag [ FLAG_ITALIC ] == 0 ) { m_flag [ FLAG_ITALIC ] = TAG_ONE_LINE ; strUTF8 . replace ( pos , 1 , " [ I ] " ) ; pos += 3 ; } else strUTF8 . erase ( pos , 1 ) ; } else machine_status = 2 ; } else if ( machine_status == 2 ) { size_t pos4 ; if ( ( pos4 = strUTF8 . find ( ' | ' , pos ) ) != CStdString :: npos ) { pos = pos4 ; if ( m_flag [ FLAG_BOLD ] == TAG_ONE_LINE ) { m_flag [ FLAG_BOLD ] = 0 ; strUTF8 . insert ( pos , " [ / B ] " ) ; pos += 4 ; } if ( m_flag [ FLAG_ITALIC ] == TAG_ONE_LINE ) { m_flag [ FLAG_ITALIC ] = 0 ; strUTF8 . insert ( pos , " [ / I ] " ) ; pos += 4 ; } if ( m_flag [ FLAG_COLOR ] == TAG_ONE_LINE ) { m_flag [ FLAG_COLOR ] = 0 ; strUTF8 . insert ( pos , " [ / COLOR ] " ) ; pos += 8 ; } strUTF8 . replace ( pos , 1 , " [ CR ] " ) ; pos += 4 ; machine_status = 1 ; } else { if ( m_flag [ FLAG_BOLD ] != 0 ) strUTF8 . append ( " [ / B ] " ) ; if ( m_flag [ FLAG_ITALIC ] != 0 ) strUTF8 . append ( " [ / I ] " ) ; if ( m_flag [ FLAG_COLOR ] != 0 ) strUTF8 . append ( " [ / COLOR ] " ) ; machine_status = 0 ; } } } if ( strUTF8 . empty ( ) ) return ; if ( strUTF8 [ strUTF8 . size ( ) - 1 ] == ' \n ' ) strUTF8 . erase ( strUTF8 . size ( ) - 1 ) ; pOverlay -> AddElement ( new CDVDOverlayText :: CElementText ( strUTF8 . c_str ( ) ) ) ; }
Highlighter :: Highlighter ( Editor * text , Dictionary * dictionary ) : QSyntaxHighlighter ( text -> document ( ) ) , m_dictionary ( dictionary ) , m_text ( text ) , m_enabled ( true ) , m_misspelled ( " # ff0000" ) { connect ( m_text , SIGNAL ( cursorPositionChanged ( ) ) , this , SLOT ( cursorPositionChanged ( ) ) ) ; m_text -> viewport ( ) -> installEventFilter ( this ) ; m_add_action = new QAction ( tr ( " Add " ) , this ) ; m_check_action = new QAction ( tr ( " Check ▁ Spelling . . . " ) , this ) ; }
void Highlighter :: setEnabled ( bool enabled ) { m_enabled = enabled ; rehighlight ( ) ; }
void Highlighter :: setMisspelledColor ( const QColor & color ) { m_misspelled = color ; rehighlight ( ) ; }
bool Highlighter :: eventFilter ( QObject * watched , QEvent * event ) { if ( watched != m_text -> viewport ( ) || event -> type ( ) != QEvent :: ContextMenu || ! m_enabled ) { return QSyntaxHighlighter :: eventFilter ( watched , event ) ; } else { QContextMenuEvent * context_event = static_cast < QContextMenuEvent * > ( event ) ; m_start_cursor = m_text -> cursorForPosition ( context_event -> pos ( ) ) ; QTextBlock block = m_start_cursor . block ( ) ; int cursor = m_start_cursor . position ( ) - block . position ( ) ; bool under_mouse = false ; QStringRef word ; QVector < QStringRef > words = static_cast < BlockStats * > ( block . userData ( ) ) -> misspelled ( ) ; for ( int i = 0 ; i < words . count ( ) ; ++ i ) { word = words . at ( i ) ; int delta = cursor - word . position ( ) ; if ( delta >= 0 && delta <= word . length ( ) ) { under_mouse = true ; break ; } } if ( ! under_mouse ) { return false ; } else { m_cursor = m_start_cursor ; m_cursor . setPosition ( word . position ( ) + block . position ( ) ) ; m_cursor . setPosition ( m_cursor . position ( ) + word . length ( ) , QTextCursor :: KeepAnchor ) ; m_word = m_cursor . selectedText ( ) ; m_text -> setTextCursor ( m_cursor ) ; QMenu * menu = new QMenu ; QStringList guesses = m_dictionary -> suggestions ( m_word ) ; if ( ! guesses . isEmpty ( ) ) { foreach ( const QString & guess , guesses ) { menu -> addAction ( guess ) ; } } else { QAction * none_action = menu -> addAction ( tr ( " ( No ▁ suggestions ▁ found ) " ) ) ; none_action -> setEnabled ( false ) ; } menu -> addSeparator ( ) ; menu -> addAction ( m_add_action ) ; menu -> addSeparator ( ) ; menu -> addAction ( m_check_action ) ; connect ( menu , SIGNAL ( triggered ( QAction * ) ) , this , SLOT ( suggestion ( QAction * ) ) ) ; menu -> exec ( context_event -> globalPos ( ) ) ; delete menu ; return true ; } } }
void Highlighter :: highlightBlock ( const QString & text ) { QTextCharFormat hformat ; QTextBlockFormat blockformat = currentBlock ( ) . blockFormat ( ) ; if ( blockformat . hasProperty ( QTextFormat :: UserProperty ) ) { hformat . setProperty ( QTextFormat :: FontWeight , blockformat . property ( QTextFormat :: FontWeight ) ) ; hformat . setProperty ( QTextFormat :: FontItalic , blockformat . property ( QTextFormat :: FontItalic ) ) ; hformat . setProperty ( QTextFormat :: FontSizeAdjustment , blockformat . property ( QTextFormat :: FontSizeAdjustment ) ) ; setFormat ( 0 , text . length ( ) , hformat ) ; } if ( ! m_enabled ) { return ; } int cursor = m_text -> textCursor ( ) . position ( ) - currentBlock ( ) . position ( ) ; BlockStats * stats = static_cast < BlockStats * > ( currentBlockUserData ( ) ) ; if ( ! stats ) { stats = new BlockStats ( text , m_dictionary ) ; setCurrentBlockUserData ( stats ) ; } QTextCharFormat error ; error . setUnderlineColor ( m_misspelled ) ; error . setUnderlineStyle ( QTextCharFormat :: SpellCheckUnderline ) ; error . merge ( hformat ) ; QVector < QStringRef > words = stats -> misspelled ( ) ; for ( int i = 0 ; i < words . count ( ) ; ++ i ) { const QStringRef & word = words . at ( i ) ; int delta = cursor - word . position ( ) ; if ( delta < 0 || delta > word . length ( ) ) { setFormat ( word . position ( ) , word . length ( ) , error ) ; } } }
void Highlighter :: cursorPositionChanged ( ) { QTextBlock current = m_text -> textCursor ( ) . block ( ) ; if ( m_current != current ) { if ( m_current . isValid ( ) && m_text -> document ( ) -> blockCount ( ) > m_current . blockNumber ( ) ) { rehighlightBlock ( m_current ) ; } m_current = current ; } rehighlightBlock ( m_current ) ; }
void Highlighter :: suggestion ( QAction * action ) { if ( action == m_add_action ) { m_text -> setTextCursor ( m_start_cursor ) ; m_dictionary -> add ( m_word ) ; } else if ( action == m_check_action ) { m_text -> setTextCursor ( m_start_cursor ) ; SpellChecker :: checkDocument ( m_text ) ; } else { m_cursor . insertText ( action -> text ( ) ) ; } }
