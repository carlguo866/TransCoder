String XMLSerializer :: serializeToString ( Node * node , ExceptionCode & ec ) { if ( ! node ) return String ( ) ; if ( ! node -> document ( ) ) { ASSERT ( node -> nodeType ( ) == Node :: DOCUMENT_TYPE_NODE ) ; ec = INVALID_ACCESS_ERR ; return String ( ) ; } return createMarkup ( node ) ; }
DescribeInstancePatchStatesResponse :: DescribeInstancePatchStatesResponse ( const DescribeInstancePatchStatesRequest & request , QNetworkReply * const reply , QObject * const parent ) : SsmResponse ( new DescribeInstancePatchStatesResponsePrivate ( this ) , parent ) { setRequest ( new DescribeInstancePatchStatesRequest ( request ) ) ; setReply ( reply ) ; }
void DescribeInstancePatchStatesResponse :: parseSuccess ( QIODevice & response ) { QXmlStreamReader xml ( & response ) ; }
void DescribeInstancePatchStatesResponsePrivate :: parseDescribeInstancePatchStatesResponse ( QXmlStreamReader & xml ) { Q_ASSERT ( xml . name ( ) == QLatin1String ( " DescribeInstancePatchStatesResponse " ) ) ; Q_UNUSED ( xml ) }
AP4_Result AP4 :: Initialize ( ) { AP4_Result result = AP4_SUCCESS ; if ( ! AP4_DefaultAtomFactory :: Instance . m_Initialized ) { result = AP4_DefaultAtomFactory :: Instance . Initialize ( ) ; if ( AP4_FAILED ( result ) ) return result ; } if ( ! AP4_DefaultBlockCipherFactory :: Instance . m_Initialized ) { result = AP4_DefaultBlockCipherFactory :: Instance . Initialize ( ) ; if ( AP4_FAILED ( result ) ) return result ; } if ( ! AP4_MetaData :: Initialized ( ) ) { AP4_MetaData :: Initialize ( ) ; } return result ; }
AP4_Result AP4 :: Terminate ( ) { if ( ! AP4_LoaderCheck . m_ConstructedByLoader ) { if ( AP4_DefaultAtomFactory :: Instance . m_Initialized ) { AP4_DefaultAtomFactory :: Instance . ~ AP4_DefaultAtomFactory ( ) ; } if ( AP4_DefaultBlockCipherFactory :: Instance . m_Initialized ) { AP4_DefaultBlockCipherFactory :: Instance . ~ AP4_DefaultBlockCipherFactory ( ) ; } if ( AP4_MetaData :: Initialized ( ) ) { AP4_MetaData :: UnInitialize ( ) ; } } return AP4_SUCCESS ; }
AboutDialog :: AboutDialog ( QWidget * parent ) : QDialog ( parent ) , ui ( new Ui :: AboutDialog ) { ui -> setupUi ( this ) ; ui -> copyrightLabel -> setText ( tr ( " Copyright " ) + QString ( " ▁ & copy ; ▁ 2009 - % 1 ▁ " ) . arg ( COPYRIGHT_YEAR ) + tr ( " The ▁ Bitcoin ▁ developers " ) + QString ( " < br > " ) + tr ( " Copyright " ) + QString ( " ▁ & copy ; ▁ " ) + tr ( " % 1 ▁ StartJOIN " ) . arg ( ABOUTDIALOG_COPYRIGHT_YEAR ) ) ; }
void AboutDialog :: setModel ( ClientModel * model ) { if ( model ) { ui -> versionLabel -> setText ( model -> formatFullVersion ( ) ) ; } }
AboutDialog :: ~ AboutDialog ( ) { delete ui ; }
void AboutDialog :: on_buttonBox_accepted ( ) { close ( ) ; }
void Util :: init ( int argc , char * const * argv ) { saved_argc = argc ; saved_argv = argv ; == HAL_LINUX_HEAT_PWM _heat = new Linux :: HeatPwm ( HAL_LINUX_HEAT_PWM_NUM , HAL_LINUX_HEAT_KP , HAL_LINUX_HEAT_KI , HAL_LINUX_HEAT_PERIOD_NS , HAL_LINUX_HEAT_TARGET_TEMP ) ; # error Unrecognized Heat _heat = new Linux :: Heat ( ) ; }
void Util :: set_imu_temp ( float current ) { _heat -> set_imu_temp ( current ) ; }
void Util :: commandline_arguments ( uint8_t & argc , char * const * & argv ) { argc = saved_argc ; argv = saved_argv ; }
bool Util :: toneAlarm_init ( ) { return _toneAlarm . init ( ) ; }
void Util :: toneAlarm_set_tune ( uint8_t tone ) { _toneAlarm . set_tune ( tone ) ; }
void Util :: _toneAlarm_timer_tick ( ) { if ( state == 0 ) { state = state + _toneAlarm . init_tune ( ) ; } else if ( state == 1 ) { state = state + _toneAlarm . set_note ( ) ; } if ( state == 2 ) { state = state + _toneAlarm . play ( ) ; } else if ( state == 3 ) { state = 1 ; } if ( _toneAlarm . is_tune_comp ( ) ) { state = 0 ; } }
void Util :: set_system_clock ( uint64_t time_utc_usec ) { != HAL_BOARD_SUBTYPE_LINUX_NONE timespec ts ; ts . tv_sec = time_utc_usec / 1.0e6 ; ts . tv_nsec = ( time_utc_usec % 1000000 ) * 1000 ; clock_settime ( CLOCK_REALTIME , & ts ) ; }
bool Util :: is_chardev_node ( const char * path ) { struct stat st ; if ( ! path || lstat ( path , & st ) < 0 ) return false ; return S_ISCHR ( st . st_mode ) ; }
uint32_t Util :: available_memory ( void ) { return 256 * 1024 ; }
int Util :: write_file ( const char * path , const char * fmt , ... ) { errno = 0 ; int fd = :: open ( path , O_WRONLY | O_CLOEXEC ) ; if ( fd == - 1 ) { return - errno ; } va_list args ; va_start ( args , fmt ) ; int ret = :: vdprintf ( fd , fmt , args ) ; int errno_bkp = errno ; :: close ( fd ) ; va_end ( args ) ; if ( ret < 1 ) { return - errno_bkp ; } return ret ; }
int Util :: read_file ( const char * path , const char * fmt , ... ) { errno = 0 ; FILE * file = :: fopen ( path , " re " ) ; if ( ! file ) return - errno ; va_list args ; va_start ( args , fmt ) ; int ret = :: vfscanf ( file , fmt , args ) ; int errno_bkp = errno ; :: fclose ( file ) ; va_end ( args ) ; if ( ret < 1 ) return - errno_bkp ; return ret ; }
int Util :: get_hw_arm32 ( ) { int ret = - ENOENT ; char buffer [ MAX_SIZE_LINE ] ; const char * hardware_description_entry = " Hardware " ; char * flag ; FILE * f ; f = fopen ( " / proc / cpuinfo " , " r " ) ; if ( f == NULL ) { ret = - errno ; goto end ; } while ( fgets ( buffer , MAX_SIZE_LINE , f ) != NULL ) { flag = strstr ( buffer , hardware_description_entry ) ; if ( flag != NULL ) { for ( uint8_t i = 0 ; i < UTIL_NUM_HARDWARES ; i ++ ) { if ( strstr ( buffer , _hw_names [ i ] ) != 0 ) { ret = i ; goto close_end ; } } } } close_end : fclose ( f ) ; end : return ret ; }
ComputeTempAsphere :: ComputeTempAsphere ( LAMMPS * lmp , int narg , char * * arg ) : Compute ( lmp , narg , arg ) { if ( narg < 3 ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; scalar_flag = vector_flag = 1 ; size_vector = 6 ; extscalar = 0 ; extvector = 1 ; tempflag = 1 ; tempbias = 0 ; id_bias = NULL ; mode = ALL ; int iarg = 3 ; while ( iarg < narg ) { if ( strcmp ( arg [ iarg ] , " bias " ) == 0 ) { if ( iarg + 2 > narg ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; tempbias = 1 ; int n = strlen ( arg [ iarg + 1 ] ) + 1 ; id_bias = new char [ n ] ; strcpy ( id_bias , arg [ iarg + 1 ] ) ; iarg += 2 ; } else if ( strcmp ( arg [ iarg ] , " dof " ) == 0 ) { if ( iarg + 2 > narg ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; if ( strcmp ( arg [ iarg + 1 ] , " rotate " ) == 0 ) mode = ROTATE ; else if ( strcmp ( arg [ iarg + 1 ] , " all " ) == 0 ) mode = ALL ; else error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; iarg += 2 ; } else error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; } vector = new double [ 6 ] ; }
ComputeTempAsphere :: ~ ComputeTempAsphere ( ) { delete [ ] id_bias ; delete [ ] vector ; }
void ComputeTempAsphere :: init ( ) { avec = ( AtomVecEllipsoid * ) atom -> style_match ( " ellipsoid " ) ; if ( ! avec ) error -> all ( FLERR , " Compute ▁ temp / asphere ▁ requires ▁ atom ▁ style ▁ ellipsoid " ) ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) if ( ellipsoid [ i ] < 0 ) error -> one ( FLERR , " Compute ▁ temp / asphere ▁ requires ▁ extended ▁ particles " ) ; if ( tempbias ) { int i = modify -> find_compute ( id_bias ) ; if ( i < 0 ) error -> all ( FLERR , " Could ▁ not ▁ find ▁ compute ▁ ID ▁ for ▁ temperature ▁ bias " ) ; tbias = modify -> compute [ i ] ; if ( tbias -> tempflag == 0 ) error -> all ( FLERR , " Bias ▁ compute ▁ does ▁ not ▁ calculate ▁ temperature " ) ; if ( tbias -> tempbias == 0 ) error -> all ( FLERR , " Bias ▁ compute ▁ does ▁ not ▁ calculate ▁ a ▁ velocity ▁ bias " ) ; if ( tbias -> igroup != igroup ) error -> all ( FLERR , " Bias ▁ compute ▁ group ▁ does ▁ not ▁ match ▁ compute ▁ group " ) ; tbias -> init ( ) ; tbias -> setup ( ) ; if ( strcmp ( tbias -> style , " temp / region " ) == 0 ) tempbias = 2 ; else tempbias = 1 ; } }
void ComputeTempAsphere :: setup ( ) { fix_dof = - 1 ; dof_compute ( ) ; }
void ComputeTempAsphere :: dof_compute ( ) { if ( fix_dof ) adjust_dof_fix ( ) ; double natoms = group -> count ( igroup ) ; int nper ; if ( domain -> dimension == 3 ) { if ( mode == ALL ) nper = 6 ; else nper = 3 ; } else { if ( mode == ALL ) nper = 3 ; else nper = 1 ; } dof = nper * natoms ; if ( tempbias == 1 ) { if ( mode == ALL ) dof -= tbias -> dof_remove ( - 1 ) * natoms ; } else if ( tempbias == 2 ) { int * mask = atom -> mask ; int nlocal = atom -> nlocal ; tbias -> dof_remove_pre ( ) ; int count = 0 ; for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) if ( tbias -> dof_remove ( i ) ) count ++ ; int count_all ; MPI_Allreduce ( & count , & count_all , 1 , MPI_INT , MPI_SUM , world ) ; dof -= nper * count_all ; } dof -= extra_dof + fix_dof ; if ( dof > 0 ) tfactor = force -> mvv2e / ( dof * force -> boltz ) ; else tfactor = 0.0 ; }
double ComputeTempAsphere :: compute_scalar ( ) { invoked_scalar = update -> ntimestep ; if ( tempbias ) { if ( tbias -> invoked_scalar != update -> ntimestep ) tbias -> compute_scalar ( ) ; tbias -> remove_bias_all ( ) ; } AtomVecEllipsoid :: Bonus * bonus = avec -> bonus ; double * * v = atom -> v ; double * * angmom = atom -> angmom ; double * rmass = atom -> rmass ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; double * shape , * quat ; double wbody [ 3 ] , inertia [ 3 ] ; double rot [ 3 ] [ 3 ] ; double t = 0.0 ; if ( mode == ALL ) { for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { t += ( v [ i ] [ 0 ] * v [ i ] [ 0 ] + v [ i ] [ 1 ] * v [ i ] [ 1 ] + v [ i ] [ 2 ] * v [ i ] [ 2 ] ) * rmass [ i ] ; shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * rmass [ i ] * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] + inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] + inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; } } else { for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * rmass [ i ] * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] + inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] + inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; } } if ( tempbias ) tbias -> restore_bias_all ( ) ; MPI_Allreduce ( & t , & scalar , 1 , MPI_DOUBLE , MPI_SUM , world ) ; if ( dynamic || tempbias == 2 ) dof_compute ( ) ; scalar *= tfactor ; return scalar ; }
void ComputeTempAsphere :: compute_vector ( ) { int i ; invoked_vector = update -> ntimestep ; if ( tempbias ) { if ( tbias -> invoked_vector != update -> ntimestep ) tbias -> compute_vector ( ) ; tbias -> remove_bias_all ( ) ; } AtomVecEllipsoid :: Bonus * bonus = avec -> bonus ; double * * v = atom -> v ; double * * angmom = atom -> angmom ; double * rmass = atom -> rmass ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; double * shape , * quat ; double wbody [ 3 ] , inertia [ 3 ] , t [ 6 ] ; double rot [ 3 ] [ 3 ] ; double massone ; for ( i = 0 ; i < 6 ; i ++ ) t [ i ] = 0.0 ; if ( mode == ALL ) { for ( i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { massone = rmass [ i ] ; t [ 0 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 0 ] ; t [ 1 ] += massone * v [ i ] [ 1 ] * v [ i ] [ 1 ] ; t [ 2 ] += massone * v [ i ] [ 2 ] * v [ i ] [ 2 ] ; t [ 3 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 1 ] ; t [ 4 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 2 ] ; t [ 5 ] += massone * v [ i ] [ 1 ] * v [ i ] [ 2 ] ; shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * massone * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t [ 0 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] ; t [ 1 ] += inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] ; t [ 2 ] += inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; t [ 3 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 1 ] ; t [ 4 ] += inertia [ 1 ] * wbody [ 0 ] * wbody [ 2 ] ; t [ 5 ] += inertia [ 2 ] * wbody [ 1 ] * wbody [ 2 ] ; } } else { for ( i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; massone = rmass [ i ] ; inertia [ 0 ] = INERTIA * massone * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t [ 0 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] ; t [ 1 ] += inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] ; t [ 2 ] += inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; t [ 3 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 1 ] ; t [ 4 ] += inertia [ 1 ] * wbody [ 0 ] * wbody [ 2 ] ; t [ 5 ] += inertia [ 2 ] * wbody [ 1 ] * wbody [ 2 ] ; } } if ( tempbias ) tbias -> restore_bias_all ( ) ; MPI_Allreduce ( t , vector , 6 , MPI_DOUBLE , MPI_SUM , world ) ; for ( i = 0 ; i < 6 ; i ++ ) vector [ i ] *= force -> mvv2e ; }
void ComputeTempAsphere :: remove_bias ( int i , double * v ) { if ( tbias ) tbias -> remove_bias ( i , v ) ; }
void ComputeTempAsphere :: restore_bias ( int i , double * v ) { if ( tbias ) tbias -> restore_bias ( i , v ) ; }
>= 0x040400 QT_BEGIN_NAMESPACE QtCursorDatabase :: QtCursorDatabase ( ) { appendCursor ( Qt :: ArrowCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Arrow " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - arrow . png " ) ) ) ; appendCursor ( Qt :: UpArrowCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Up ▁ Arrow " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - uparrow . png " ) ) ) ; appendCursor ( Qt :: CrossCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Cross " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - cross . png " ) ) ) ; appendCursor ( Qt :: WaitCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Wait " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - wait . png " ) ) ) ; appendCursor ( Qt :: IBeamCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " IBeam " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - ibeam . png " ) ) ) ; appendCursor ( Qt :: SizeVerCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Vertical " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizev . png " ) ) ) ; appendCursor ( Qt :: SizeHorCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Horizontal " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeh . png " ) ) ) ; appendCursor ( Qt :: SizeFDiagCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Backslash " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizef . png " ) ) ) ; appendCursor ( Qt :: SizeBDiagCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Slash " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeb . png " ) ) ) ; appendCursor ( Qt :: SizeAllCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ All " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeall . png " ) ) ) ; appendCursor ( Qt :: BlankCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Blank " ) , QIcon ( ) ) ; appendCursor ( Qt :: SplitVCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Split ▁ Vertical " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - vsplit . png " ) ) ) ; appendCursor ( Qt :: SplitHCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Split ▁ Horizontal " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - hsplit . png " ) ) ) ; appendCursor ( Qt :: PointingHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Pointing ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - hand . png " ) ) ) ; appendCursor ( Qt :: ForbiddenCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Forbidden " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - forbidden . png " ) ) ) ; appendCursor ( Qt :: OpenHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Open ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - openhand . png " ) ) ) ; appendCursor ( Qt :: ClosedHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Closed ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - closedhand . png " ) ) ) ; appendCursor ( Qt :: WhatsThisCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " What ' s ▁ This " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - whatsthis . png " ) ) ) ; appendCursor ( Qt :: BusyCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Busy " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - busy . png " ) ) ) ; }
void QtCursorDatabase :: clear ( ) { m_cursorNames . clear ( ) ; m_cursorIcons . clear ( ) ; m_valueToCursorShape . clear ( ) ; m_cursorShapeToValue . clear ( ) ; }
void QtCursorDatabase :: appendCursor ( Qt :: CursorShape shape , const QString & name , const QIcon & icon ) { if ( m_cursorShapeToValue . contains ( shape ) ) return ; const int value = m_cursorNames . count ( ) ; m_cursorNames . append ( name ) ; m_cursorIcons . insert ( value , icon ) ; m_valueToCursorShape . insert ( value , shape ) ; m_cursorShapeToValue . insert ( shape , value ) ; }
QPixmap QtPropertyBrowserUtils :: brushValuePixmap ( const QBrush & b ) { QImage img ( 16 , 16 , QImage :: Format_ARGB32_Premultiplied ) ; img . fill ( 0 ) ; QPainter painter ( & img ) ; painter . setCompositionMode ( QPainter :: CompositionMode_Source ) ; painter . fillRect ( 0 , 0 , img . width ( ) , img . height ( ) , b ) ; QColor color = b . color ( ) ; if ( color . alpha ( ) != 255 ) { QBrush opaqueBrush = b ; color . setAlpha ( 255 ) ; opaqueBrush . setColor ( color ) ; painter . fillRect ( img . width ( ) / 4 , img . height ( ) / 4 , img . width ( ) / 2 , img . height ( ) / 2 , opaqueBrush ) ; } painter . end ( ) ; return QPixmap :: fromImage ( img ) ; }
QIcon QtPropertyBrowserUtils :: brushValueIcon ( const QBrush & b ) { return QIcon ( brushValuePixmap ( b ) ) ; }
QString QtPropertyBrowserUtils :: colorValueText ( const QColor & c ) { return QCoreApplication :: translate ( " QtPropertyBrowserUtils " , " [ %1 , ▁ % 2 , ▁ % 3 ] ▁ ( %4 ) " ) . arg ( c . red ( ) ) . arg ( c . green ( ) ) . arg ( c . blue ( ) ) . arg ( c . alpha ( ) ) ; }
QPixmap QtPropertyBrowserUtils :: fontValuePixmap ( const QFont & font ) { QFont f = font ; QImage img ( 16 , 16 , QImage :: Format_ARGB32_Premultiplied ) ; img . fill ( 0 ) ; QPainter p ( & img ) ; p . setRenderHint ( QPainter :: TextAntialiasing , true ) ; p . setRenderHint ( QPainter :: Antialiasing , true ) ; f . setPointSize ( 13 ) ; p . setFont ( f ) ; QTextOption t ; t . setAlignment ( Qt :: AlignCenter ) ; p . drawText ( QRect ( 0 , 0 , 16 , 16 ) , QString ( QLatin1Char ( ' A ' ) ) , t ) ; return QPixmap :: fromImage ( img ) ; }
QIcon QtPropertyBrowserUtils :: fontValueIcon ( const QFont & f ) { return QIcon ( fontValuePixmap ( f ) ) ; }
QString QtPropertyBrowserUtils :: fontValueText ( const QFont & f ) { return QCoreApplication :: translate ( " QtPropertyBrowserUtils " , " [ %1 , ▁ % 2 ] " ) . arg ( f . family ( ) ) . arg ( f . pointSize ( ) ) ; }
QtBoolEdit :: QtBoolEdit ( QWidget * parent ) : QWidget ( parent ) , m_checkBox ( new QCheckBox ( this ) ) , m_textVisible ( true ) { QHBoxLayout * lt = new QHBoxLayout ; if ( QApplication :: layoutDirection ( ) == Qt :: LeftToRight ) lt -> setContentsMargins ( 4 , 0 , 0 , 0 ) ; else lt -> setContentsMargins ( 0 , 0 , 4 , 0 ) ; lt -> addWidget ( m_checkBox ) ; setLayout ( lt ) ; connect ( m_checkBox , SIGNAL ( toggled ( bool ) ) , this , SIGNAL ( toggled ( bool ) ) ) ; setFocusProxy ( m_checkBox ) ; m_checkBox -> setText ( tr ( " True " ) ) ; }
void QtBoolEdit :: setTextVisible ( bool textVisible ) { if ( m_textVisible == textVisible ) return ; m_textVisible = textVisible ; if ( m_textVisible ) m_checkBox -> setText ( isChecked ( ) ? tr ( " True " ) : tr ( " False " ) ) ; else m_checkBox -> setText ( QString ( ) ) ; }
void QtBoolEdit :: setCheckState ( Qt :: CheckState state ) { m_checkBox -> setCheckState ( state ) ; }
void QtBoolEdit :: setChecked ( bool c ) { m_checkBox -> setChecked ( c ) ; if ( ! m_textVisible ) return ; m_checkBox -> setText ( isChecked ( ) ? tr ( " True " ) : tr ( " False " ) ) ; }
bool QtBoolEdit :: blockCheckBoxSignals ( bool block ) { return m_checkBox -> blockSignals ( block ) ; }
void QtBoolEdit :: mousePressEvent ( QMouseEvent * event ) { if ( event -> buttons ( ) == Qt :: LeftButton ) { m_checkBox -> click ( ) ; event -> accept ( ) ; } else { QWidget :: mousePressEvent ( event ) ; } }
void QtBoolEdit :: paintEvent ( QPaintEvent * ) { QStyleOption opt ; opt . init ( this ) ; QPainter p ( this ) ; style ( ) -> drawPrimitive ( QStyle :: PE_Widget , & opt , & p , this ) ; }
QtKeySequenceEdit :: QtKeySequenceEdit ( QWidget * parent ) : QWidget ( parent ) , m_num ( 0 ) , m_lineEdit ( new QLineEdit ( this ) ) { QHBoxLayout * layout = new QHBoxLayout ( this ) ; layout -> addWidget ( m_lineEdit ) ; layout -> setMargin ( 0 ) ; m_lineEdit -> installEventFilter ( this ) ; m_lineEdit -> setReadOnly ( true ) ; m_lineEdit -> setFocusProxy ( this ) ; setFocusPolicy ( m_lineEdit -> focusPolicy ( ) ) ; setAttribute ( Qt :: WA_InputMethodEnabled ) ; }
bool QtKeySequenceEdit :: eventFilter ( QObject * o , QEvent * e ) { if ( o == m_lineEdit && e -> type ( ) == QEvent :: ContextMenu ) { QContextMenuEvent * c = static_cast < QContextMenuEvent * > ( e ) ; QMenu * menu = m_lineEdit -> createStandardContextMenu ( ) ; const QList < QAction * > actions = menu -> actions ( ) ; QListIterator < QAction * > itAction ( actions ) ; while ( itAction . hasNext ( ) ) { QAction * action = itAction . next ( ) ; action -> setShortcut ( QKeySequence ( ) ) ; QString actionString = action -> text ( ) ; const int pos = actionString . lastIndexOf ( QLatin1Char ( ' \t ' ) ) ; if ( pos > 0 ) actionString . remove ( pos , actionString . length ( ) - pos ) ; action -> setText ( actionString ) ; } QAction * actionBefore = 0 ; if ( actions . count ( ) > 0 ) actionBefore = actions [ 0 ] ; QAction * clearAction = new QAction ( tr ( " Clear ▁ Shortcut " ) , menu ) ; menu -> insertAction ( actionBefore , clearAction ) ; menu -> insertSeparator ( actionBefore ) ; clearAction -> setEnabled ( ! m_keySequence . isEmpty ( ) ) ; connect ( clearAction , SIGNAL ( triggered ( ) ) , this , SLOT ( slotClearShortcut ( ) ) ) ; menu -> exec ( c -> globalPos ( ) ) ; delete menu ; e -> accept ( ) ; return true ; } return QWidget :: eventFilter ( o , e ) ; }
void QtKeySequenceEdit :: slotClearShortcut ( ) { if ( m_keySequence . isEmpty ( ) ) return ; setKeySequence ( QKeySequence ( ) ) ; emit keySequenceChanged ( m_keySequence ) ; }
void QtKeySequenceEdit :: handleKeyEvent ( QKeyEvent * e ) { int nextKey = e -> key ( ) ; if ( nextKey == Qt :: Key_Control || nextKey == Qt :: Key_Shift || nextKey == Qt :: Key_Meta || nextKey == Qt :: Key_Alt || nextKey == Qt :: Key_Super_L || nextKey == Qt :: Key_AltGr ) return ; nextKey |= translateModifiers ( e -> modifiers ( ) , e -> text ( ) ) ; int k0 = m_keySequence [ 0 ] ; int k1 = m_keySequence [ 1 ] ; int k2 = m_keySequence [ 2 ] ; int k3 = m_keySequence [ 3 ] ; switch ( m_num ) { case 0 : k0 = nextKey ; k1 = 0 ; k2 = 0 ; k3 = 0 ; break ; case 1 : k1 = nextKey ; k2 = 0 ; k3 = 0 ; break ; case 2 : k2 = nextKey ; k3 = 0 ; break ; case 3 : k3 = nextKey ; break ; default : break ; } ++ m_num ; if ( m_num > 3 ) m_num = 0 ; m_keySequence = QKeySequence ( k0 , k1 , k2 , k3 ) ; m_lineEdit -> setText ( m_keySequence . toString ( QKeySequence :: NativeText ) ) ; e -> accept ( ) ; emit keySequenceChanged ( m_keySequence ) ; }
void QtKeySequenceEdit :: setKeySequence ( const QKeySequence & sequence ) { if ( sequence == m_keySequence ) return ; m_num = 0 ; m_keySequence = sequence ; m_lineEdit -> setText ( m_keySequence . toString ( QKeySequence :: NativeText ) ) ; }
void QtKeySequenceEdit :: focusInEvent ( QFocusEvent * e ) { m_lineEdit -> event ( e ) ; m_lineEdit -> selectAll ( ) ; QWidget :: focusInEvent ( e ) ; }
void QtKeySequenceEdit :: focusOutEvent ( QFocusEvent * e ) { m_num = 0 ; m_lineEdit -> event ( e ) ; QWidget :: focusOutEvent ( e ) ; }
void QtKeySequenceEdit :: keyPressEvent ( QKeyEvent * e ) { handleKeyEvent ( e ) ; e -> accept ( ) ; }
void QtKeySequenceEdit :: keyReleaseEvent ( QKeyEvent * e ) { m_lineEdit -> event ( e ) ; }
void QtKeySequenceEdit :: paintEvent ( QPaintEvent * ) { QStyleOption opt ; opt . init ( this ) ; QPainter p ( this ) ; style ( ) -> drawPrimitive ( QStyle :: PE_Widget , & opt , & p , this ) ; }
bool QtKeySequenceEdit :: event ( QEvent * e ) { if ( e -> type ( ) == QEvent :: Shortcut || e -> type ( ) == QEvent :: ShortcutOverride || e -> type ( ) == QEvent :: KeyRelease ) { e -> accept ( ) ; return true ; } return QWidget :: event ( e ) ; }
void LetPropertiesOpt :: optimizeLetPropertyAccess ( VarDecl * Property , const InitSequence & init ) { assert ( init . isValid ( ) ) ; if ( SkipProcessing . count ( Property ) ) return ; auto * Ty = dyn_cast < NominalTypeDecl > ( Property -> getDeclContext ( ) ) ; if ( SkipTypeProcessing . count ( Ty ) ) return ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Replacing ▁ access ▁ to ▁ property ▁ ' " << * Property << " ' ▁ by ▁ its ▁ constant ▁ initializer \n " ) ; auto PropertyAccess = Property -> getEffectiveAccess ( ) ; auto TypeAccess = Ty -> getEffectiveAccess ( ) ; auto CanRemove = false ; if ( TypeAccess <= AccessLevel :: FilePrivate || PropertyAccess <= AccessLevel :: FilePrivate || ( ( TypeAccess <= AccessLevel :: Internal || PropertyAccess <= AccessLevel :: Internal ) && Module -> isWholeModule ( ) ) ) { CanRemove = true ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Storage ▁ for ▁ property ▁ ' " << * Property << " ' ▁ can ▁ be ▁ eliminated \n " ) ; } if ( CannotRemove . count ( Property ) ) CanRemove = false ; if ( ! AccessMap . count ( Property ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ is ▁ never ▁ read \n " ) ; if ( CanRemove ) { } return ; } auto & Loads = AccessMap [ Property ] ; unsigned NumReplaced = 0 ; for ( auto Load : Loads ) { SILFunction * F = Load -> getFunction ( ) ; auto cloneInitAt = [ & ] ( SILInstruction * insertionPoint ) -> SILValue { InitSequenceCloner cloner ( init , insertionPoint ) ; return cloner . clone ( ) ; } ; if ( isa < RefElementAddrInst > ( Load ) || isa < StructElementAddrInst > ( Load ) || isa < BeginAccessInst > ( Load ) ) { auto proj = cast < SingleValueInstruction > ( Load ) ; SILValue clonedInit = cloneInitAt ( proj ) ; SILBuilderWithScope B ( proj ) ; for ( auto UI = proj -> use_begin ( ) , E = proj -> use_end ( ) ; UI != E ; ) { auto * User = UI -> getUser ( ) ; ++ UI ; if ( isIncidentalUse ( User ) ) continue ; if ( isa < BeginAccessInst > ( User ) ) continue ; if ( isa < StoreInst > ( User ) ) continue ; replaceLoadSequence ( User , clonedInit , B ) ; eraseUsesOfInstruction ( User ) ; User -> eraseFromParent ( ) ; ++ NumReplaced ; } ChangedFunctions . insert ( F ) ; } else if ( auto proj = dyn_cast < StructExtractInst > ( Load ) ) { SILValue clonedInit = cloneInitAt ( proj ) ; proj -> replaceAllUsesWith ( clonedInit ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Access ▁ to ▁ " << * Property << " ▁ was ▁ replaced : \n " ; clonedInit -> dumpInContext ( ) ) ; proj -> eraseFromParent ( ) ; ++ NumReplaced ; ChangedFunctions . insert ( F ) ; } } LLVM_DEBUG ( llvm :: dbgs ( ) << " Access ▁ to ▁ " << * Property << " ▁ was ▁ replaced ▁ " << NumReplaced << " ▁ time ( s ) \n " ) ; if ( CanRemove ) { } }
bool LetPropertiesOpt :: isConstantLetProperty ( VarDecl * Property ) { if ( ! Property -> isLet ( ) || Property -> isStatic ( ) ) return false ; if ( SkipProcessing . count ( Property ) ) return false ; if ( PotentialConstantLetProperty . count ( Property ) ) return true ; if ( mayHaveUnknownUses ( Property , Module ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ may ▁ have ▁ unknown ▁ uses \n " ) ; SkipProcessing . insert ( Property ) ; return false ; } LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ has ▁ no ▁ unknown ▁ uses \n " ) ; if ( ! isSimpleType ( Module -> Types . getLoweredType ( Property -> getType ( ) ) , * Module ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ is ▁ not ▁ of ▁ trivial ▁ type \n " ) ; SkipProcessing . insert ( Property ) ; return false ; } PotentialConstantLetProperty . insert ( Property ) ; return true ; }
bool LetPropertiesOpt :: analyzeInitValue ( SILInstruction * I , VarDecl * Property ) { SILValue value ; if ( auto SI = dyn_cast < StructInst > ( I ) ) { value = SI -> getFieldValue ( Property ) ; } else if ( auto SI = dyn_cast < StoreInst > ( I ) ) { auto Dest = stripAddressAccess ( SI -> getDest ( ) ) ; assert ( isProjectionOfProperty ( stripAddressAccess ( SI -> getDest ( ) ) , Property ) && " Store ▁ instruction ▁ should ▁ store ▁ into ▁ a ▁ proper ▁ let ▁ property " ) ; ( void ) Dest ; value = SI -> getSrc ( ) ; } if ( auto * LI = dyn_cast < LoadInst > ( value ) ) { SILValue addr = LI -> getOperand ( ) ; if ( isProjectionOfProperty ( addr , Property ) ) return true ; } InitSequence sequence ; sequence . Result = value ; if ( ! analyzeStaticInitializer ( value , sequence . Instructions ) ) return false ; auto & cachedSequence = InitMap [ Property ] ; if ( cachedSequence . isValid ( ) && ! isSameInitSequence ( cachedSequence , sequence ) ) { return false ; } else { LLVM_DEBUG ( llvm :: dbgs ( ) << " The ▁ value ▁ of ▁ property ▁ ' " << * Property << " ' ▁ is ▁ statically ▁ known ▁ so ▁ far \n " ) ; cachedSequence = std :: move ( sequence ) ; return true ; } }
void LetPropertiesOpt :: collectStructPropertiesAccess ( StructInst * SI , bool NonRemovable ) { auto structDecl = SI -> getStructDecl ( ) ; if ( SkipTypeProcessing . count ( structDecl ) ) return ; if ( ! NominalTypeLetProperties . count ( structDecl ) ) { SmallVector < VarDecl * , 4 > LetProps ; for ( auto Prop : structDecl -> getStoredProperties ( ) ) { if ( ! isConstantLetProperty ( Prop ) ) continue ; LetProps . push_back ( Prop ) ; } if ( LetProps . empty ( ) ) { SkipTypeProcessing . insert ( structDecl ) ; return ; } NominalTypeLetProperties [ structDecl ] = LetProps ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Computed ▁ set ▁ of ▁ let ▁ properties ▁ for ▁ struct ▁ ' " << structDecl -> getName ( ) << " ' \n " ) ; } auto & Props = NominalTypeLetProperties [ structDecl ] ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Found ▁ a ▁ struct ▁ instruction ▁ initializing ▁ some ▁ " " let ▁ properties : ▁ " ; SI -> dumpInContext ( ) ) ; for ( auto Prop : Props ) { if ( SkipProcessing . count ( Prop ) ) continue ; SILValue PropValue = SI -> getOperandForField ( Prop ) -> get ( ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Check ▁ the ▁ value ▁ of ▁ property ▁ ' " << * Prop << " ' ▁ : " << PropValue << " \n " ) ; if ( ! analyzeInitValue ( SI , Prop ) ) { SkipProcessing . insert ( Prop ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " The ▁ value ▁ of ▁ a ▁ let ▁ property ▁ ' " << * Prop << " ' ▁ is ▁ not ▁ statically ▁ known \n " ) ; } ( void ) PropValue ; } }
void LetPropertiesOpt :: collectPropertyAccess ( SILInstruction * I , VarDecl * Property , bool NonRemovable ) { if ( ! isConstantLetProperty ( Property ) ) return ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Collecting ▁ property ▁ access ▁ for ▁ property ▁ ' " << * Property << " ' : \n " ; llvm :: dbgs ( ) << " The ▁ instructions ▁ are : \n " ; I -> dumpInContext ( ) ) ; if ( isa < RefElementAddrInst > ( I ) || isa < StructElementAddrInst > ( I ) || isa < BeginAccessInst > ( I ) ) { auto projection = cast < SingleValueInstruction > ( I ) ; for ( auto Use : getNonDebugUses ( projection ) ) { auto * User = Use -> getUser ( ) ; if ( isIncidentalUse ( User ) ) continue ; if ( isa < BeginAccessInst > ( User ) ) continue ; if ( auto * SI = dyn_cast < StoreInst > ( User ) ) { if ( SI -> getDest ( ) != projection || ! analyzeInitValue ( SI , Property ) ) { SkipProcessing . insert ( Property ) ; return ; } continue ; } if ( ! isValidPropertyLoad ( User ) ) { SkipProcessing . insert ( Property ) ; return ; } } } AccessMap [ Property ] . push_back ( I ) ; if ( NonRemovable ) CannotRemove . insert ( Property ) ; }
void LetPropertiesOpt :: run ( SILModuleTransform * T ) { for ( auto & F : * Module ) { bool NonRemovable = ! F . shouldOptimize ( ) ; for ( auto & BB : F ) { for ( auto & I : BB ) if ( auto * BAI = dyn_cast < BeginAccessInst > ( & I ) ) { if ( auto * REAI = dyn_cast < RefElementAddrInst > ( stripAddressAccess ( BAI ) ) ) { collectPropertyAccess ( BAI , REAI -> getField ( ) , NonRemovable ) ; } } else if ( auto * REAI = dyn_cast < RefElementAddrInst > ( & I ) ) { collectPropertyAccess ( REAI , REAI -> getField ( ) , NonRemovable ) ; } else if ( auto * SEI = dyn_cast < StructExtractInst > ( & I ) ) { collectPropertyAccess ( SEI , SEI -> getField ( ) , NonRemovable ) ; } else if ( auto * SEAI = dyn_cast < StructElementAddrInst > ( & I ) ) { collectPropertyAccess ( SEAI , SEAI -> getField ( ) , NonRemovable ) ; } else if ( auto * SI = dyn_cast < StructInst > ( & I ) ) { collectStructPropertiesAccess ( SI , NonRemovable ) ; } } } for ( auto & Init : InitMap ) { optimizeLetPropertyAccess ( Init . first , Init . second ) ; } for ( SILFunction * ChangedFn : ChangedFunctions ) { T -> invalidateAnalysis ( ChangedFn , SILAnalysis :: InvalidationKind :: Instructions ) ; } }
SILTransform * swift :: createLetPropertiesOpt ( ) { return new LetPropertiesOptPass ( ) ; }
bool CBOINCGUIApp :: OnInit ( ) { g_use_sandbox = true ; g_use_sandbox = false ; s_bSkipExitConfirmation = false ; m_bFilterEvents = false ; m_pLocale = NULL ; m_pSkinManager = NULL ; m_pFrame = NULL ; m_pDocument = NULL ; m_pTaskBarIcon = NULL ; m_pEventLog = NULL ; m_pMacSystemMenu = NULL ; m_strBOINCMGRExecutableName = wxEmptyString ; m_strBOINCMGRRootDirectory = wxEmptyString ; m_strBOINCMGRDataDirectory = wxEmptyString ; m_strHostNameArg = wxEmptyString ; m_strPasswordArg = wxEmptyString ; m_iRPCPortArg = GUI_RPC_PORT ; m_strBOINCArguments = wxEmptyString ; m_bGUIVisible = true ; m_bDebugSkins = false ; m_bMultipleInstancesOK = false ; m_bBOINCMGRAutoStarted = false ; m_iBOINCMGRDisableAutoStart = 0 ; m_iShutdownCoreClient = 0 ; m_iDisplayExitDialog = 1 ; m_iGUISelected = BOINC_SIMPLEGUI ; m_bSafeMessageBoxDisplayed = 0 ; m_hClientLibraryDll = NULL ; int iErrorCode = 0 ; int iSelectedLanguage = 0 ; bool bOpenEventLog = false ; wxString strDesiredSkinName = wxEmptyString ; wxString strDialogMessage = wxEmptyString ; bool success = false ; wxSystemOptions :: SetOption ( wxT ( " msw . staticbox . optimized - paint " ) , 0 ) ; wxSystemOptions :: SetOption ( wxT ( " mac . listctrl . always _ use _ generic " ) , 1 ) ; AEInstallEventHandler ( kCoreEventClass , kAEQuitApplication , NewAEEventHandlerUPP ( ( AEEventHandlerProcPtr ) QuitAppleEventHandler ) , 0 , false ) ; GetCurrentProcess ( & m_psnCurrentProcess ) ; if ( ! wxApp :: OnInit ( ) ) { return false ; } if ( g_use_sandbox ) { wxCHANGE_UMASK ( 2 ) ; } SetAppName ( wxT ( " BOINC ▁ Manager " ) ) ; SetVendorName ( wxT ( " Space ▁ Sciences ▁ Laboratory , ▁ U . C . ▁ Berkeley " ) ) ; m_pConfig = new wxConfig ( GetAppName ( ) ) ; wxConfigBase :: Set ( m_pConfig ) ; wxASSERT ( m_pConfig ) ; m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Read ( wxT ( " AutomaticallyShutdownClient " ) , & m_iShutdownCoreClient , 0L ) ; m_pConfig -> Read ( wxT ( " DisplayShutdownClientDialog " ) , & m_iDisplayExitDialog , 1L ) ; m_pConfig -> Read ( wxT ( " DisableAutoStart " ) , & m_iBOINCMGRDisableAutoStart , 0L ) ; m_pConfig -> Read ( wxT ( " Language " ) , & iSelectedLanguage , 0L ) ; m_pConfig -> Read ( wxT ( " GUISelection " ) , & m_iGUISelected , BOINC_SIMPLEGUI ) ; m_pConfig -> Read ( wxT ( " EventLogOpen " ) , & bOpenEventLog ) ; if ( m_bBOINCMGRAutoStarted && m_iBOINCMGRDisableAutoStart ) { return false ; } DetectExecutableName ( ) ; DetectRootDirectory ( ) ; DetectDataDirectory ( ) ; if ( ! GetDataDirectory ( ) . IsEmpty ( ) ) { success = wxSetWorkingDirectory ( GetDataDirectory ( ) ) ; if ( ! success ) { if ( ! g_use_sandbox ) { if ( ! wxDirExists ( GetDataDirectory ( ) ) ) { success = wxMkdir ( GetDataDirectory ( ) , 0777 ) ; } } } } if ( ! success ) iErrorCode = - 1016 ; int dwDiagnosticsFlags = BOINC_DIAG_DUMPCALLSTACKENABLED | BOINC_DIAG_HEAPCHECKENABLED | BOINC_DIAG_MEMORYLEAKCHECKENABLED | || defined ( __WXMAC__ ) BOINC_DIAG_REDIRECTSTDERR | BOINC_DIAG_REDIRECTSTDOUT | BOINC_DIAG_TRACETOSTDOUT ; diagnostics_init ( dwDiagnosticsFlags , " stdoutgui " , " stderrgui " ) ; m_pLog = new wxLogBOINC ( ) ; wxLog :: SetActiveTarget ( m_pLog ) ; m_pLog -> AddTraceMask ( wxT ( " Function ▁ Start / End " ) ) ; m_pLog -> AddTraceMask ( wxT ( " Function ▁ Status " ) ) ; _configthreadlocale ( _ENABLE_PER_THREAD_LOCALE ) ; m_pLocale = new wxLocale ( ) ; wxASSERT ( m_pLocale ) ; m_pLocale -> Init ( iSelectedLanguage ) ; if ( ! m_strBOINCMGRRootDirectory . IsEmpty ( ) ) { m_pLocale -> AddCatalogLookupPathPrefix ( wxString ( m_strBOINCMGRRootDirectory + wxT ( " locale " ) ) ) ; } m_pLocale -> AddCatalogLookupPathPrefix ( wxT ( " locale " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Manager " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Client " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Web " ) ) ; InitSupportedLanguages ( ) ; wxHelpProvider :: Set ( new wxHelpControllerHelpProvider ( ) ) ; wxInitAllImageHandlers ( ) ; wxFileSystem :: AddHandler ( new wxMemoryFSHandler ) ; m_pInternetFSHandler = new CBOINCInternetFSHandler ; wxFileSystem :: AddHandler ( m_pInternetFSHandler ) ; m_pSkinManager = new CSkinManager ( m_bDebugSkins ) ; wxASSERT ( m_pSkinManager ) ; m_pConfig -> Read ( wxT ( " Skin " ) , & strDesiredSkinName , m_pSkinManager -> GetDefaultSkinName ( ) ) ; m_pSkinManager -> ReloadSkin ( strDesiredSkinName ) ; char path_to_error [ MAXPATHLEN ] ; path_to_error [ 0 ] = ' \0' ; if ( ! iErrorCode ) { defined ( __WXMAC__ ) && defined ( _DEBUG ) ) if ( check_security ( g_use_sandbox , true ) ) { CreateBOINCUsersAndGroups ( ) ; SetBOINCDataOwnersGroupsAndPermissions ( ) ; SetBOINCAppOwnersGroupsAndPermissions ( NULL ) ; } iErrorCode = check_security ( g_use_sandbox , true , path_to_error ) ; } if ( iErrorCode ) { ShowApplication ( true ) ; if ( iErrorCode == - 1099 ) { strDialogMessage . Printf ( _ ( " You ▁ currently ▁ are ▁ not ▁ authorized ▁ to ▁ manage ▁ the ▁ client . \n \n To ▁ run ▁ % s ▁ as ▁ this ▁ user , ▁ please : \n ▁ ▁ - ▁ reinstall ▁ % s ▁ answering ▁ \ " Yes \ " ▁ to ▁ the ▁ question ▁ about \n ▁ ▁ ▁ ▁ ▁ non - administrative ▁ users \n ▁ or \n ▁ ▁ - ▁ contact ▁ your ▁ administrator ▁ to ▁ add ▁ you ▁ to ▁ the ▁ ' boinc _ master ' \n ▁ ▁ ▁ ▁ ▁ user ▁ group . " ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) ) ; } else { strDialogMessage . Printf ( _ ( " % s ▁ ownership ▁ or ▁ permissions ▁ are ▁ not ▁ set ▁ properly ; ▁ please ▁ reinstall ▁ % s . \n ( Error ▁ code ▁ % d " ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , iErrorCode ) ; if ( path_to_error [ 0 ] ) { strDialogMessage += _ ( " ▁ at ▁ " ) ; strDialogMessage += wxString :: FromUTF8 ( path_to_error ) ; } strDialogMessage += _ ( " ) " ) ; fprintf ( stderr , " % ls ▁ ownership ▁ or ▁ permissions ▁ are ▁ not ▁ set ▁ properly ; ▁ please ▁ reinstall ▁ % ls . \n ( Error ▁ code ▁ % d ▁ at ▁ % s ) " , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , iErrorCode , path_to_error ) ; } wxMessageDialog * pDlg = new wxMessageDialog ( NULL , strDialogMessage , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , wxOK ) ; pDlg -> ShowModal ( ) ; if ( pDlg ) pDlg -> Destroy ( ) ; return false ; } wxString strRebootPendingFile = GetRootDirectory ( ) + wxFileName :: GetPathSeparator ( ) + wxT ( " RebootPending . txt " ) ; if ( wxFile :: Exists ( strRebootPendingFile ) ) { wxMessageDialog dialog ( NULL , _ ( " A ▁ reboot ▁ is ▁ required ▁ in ▁ order ▁ for ▁ BOINC ▁ to ▁ run ▁ properly . \n Please ▁ reboot ▁ your ▁ computer ▁ and ▁ try ▁ again . " ) , _ ( " BOINC ▁ Manager " ) , wxOK | wxICON_ERROR ) ; dialog . ShowModal ( ) ; return false ; } if ( ! m_bMultipleInstancesOK ) { if ( DetectDuplicateInstance ( ) ) { return false ; } } m_pDocument = new CMainDocument ( ) ; wxASSERT ( m_pDocument ) ; m_pDocument -> OnInit ( ) ; if ( BOINC_SIMPLEGUI == m_iGUISelected ) { if ( wxGetDisplaySize ( ) . GetHeight ( ) < 600 ) { m_iGUISelected = BOINC_ADVANCEDGUI ; } } m_pTaskBarIcon = new CTaskBarIcon ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationDisconnectedIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationSnoozeIcon ( ) ) ; wxASSERT ( m_pTaskBarIcon ) ; m_pMacSystemMenu = new CMacSystemMenu ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationDisconnectedIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationSnoozeIcon ( ) ) ; wxASSERT ( m_pMacSystemMenu ) ; IdleTrackerAttach ( ) ; ProcessSerialNumber psn ; ProcessInfoRec pInfo ; OSStatus err ; memset ( & pInfo , 0 , sizeof ( pInfo ) ) ; pInfo . processInfoLength = sizeof ( ProcessInfoRec ) ; err = GetProcessInformation ( & m_psnCurrentProcess , & pInfo ) ; if ( ! err ) { psn = pInfo . processLauncher ; memset ( & pInfo , 0 , sizeof ( pInfo ) ) ; pInfo . processInfoLength = sizeof ( ProcessInfoRec ) ; err = GetProcessInformation ( & psn , & pInfo ) ; } if ( pInfo . processSignature == ' lgnw ' ) { m_bGUIVisible = false ; sleep ( 10 ) ; } SetActiveGUI ( m_iGUISelected , false ) ; if ( m_bGUIVisible ) { SetActiveGUI ( m_iGUISelected ) ; } else { ShowApplication ( false ) ; } if ( bOpenEventLog ) { DisplayEventLog ( m_bGUIVisible ) ; m_pFrame -> Raise ( ) ; } return true ; }
int CBOINCGUIApp :: OnExit ( ) { IdleTrackerDetach ( ) ; if ( m_pDocument ) { m_pDocument -> OnExit ( ) ; delete m_pDocument ; m_pDocument = NULL ; } m_pConfig -> SetPath ( wxT ( " / " ) ) ; if ( m_pSkinManager ) { m_pConfig -> Write ( wxT ( " Skin " ) , m_pSkinManager -> GetSelectedSkin ( ) ) ; delete m_pSkinManager ; } if ( m_pLocale ) { delete m_pLocale ; m_pLocale = NULL ; } if ( m_pEventLog ) { m_pEventLog -> Destroy ( ) ; m_pEventLog = NULL ; } m_pConfig -> Write ( wxT ( " AutomaticallyShutdownClient " ) , m_iShutdownCoreClient ) ; m_pConfig -> Write ( wxT ( " DisplayShutdownClientDialog " ) , m_iDisplayExitDialog ) ; m_pConfig -> Write ( wxT ( " DisableAutoStart " ) , m_iBOINCMGRDisableAutoStart ) ; diagnostics_finish ( ) ; return wxApp :: OnExit ( ) ; }
void CBOINCGUIApp :: OnInitCmdLine ( wxCmdLineParser & parser ) { wxApp :: OnInitCmdLine ( parser ) ; static const wxCmdLineEntryDesc cmdLineDesc [ ] = { { wxCMD_LINE_SWITCH , wxT ( " a " ) , wxT ( " autostart " ) , _ ( " BOINC ▁ Manager ▁ was ▁ started ▁ by ▁ the ▁ operating ▁ system ▁ automatically " ) } , || defined ( __WXMAC__ ) { wxCMD_LINE_SWITCH , wxT ( " s " ) , wxT ( " systray " ) , _ ( " Startup ▁ BOINC ▁ so ▁ only ▁ the ▁ system ▁ tray ▁ icon ▁ is ▁ visible " ) } , { wxCMD_LINE_OPTION , wxT ( " e " ) , wxT ( " clientdir " ) , _ ( " Directory ▁ containing ▁ the ▁ BOINC ▁ Client ▁ executable " ) } , { wxCMD_LINE_OPTION , wxT ( " d " ) , wxT ( " datadir " ) , _ ( " BOINC ▁ data ▁ directory " ) } , { wxCMD_LINE_OPTION , wxT ( " n " ) , wxT ( " namehost " ) , _ ( " Host ▁ name ▁ or ▁ IP ▁ address " ) } , { wxCMD_LINE_OPTION , wxT ( " g " ) , wxT ( " gui _ rpc _ port " ) , _ ( " GUI ▁ RPC ▁ port ▁ number " ) } , { wxCMD_LINE_OPTION , wxT ( " p " ) , wxT ( " password " ) , _ ( " Password " ) } , { wxCMD_LINE_OPTION , wxT ( " b " ) , wxT ( " boincargs " ) , _ ( " Startup ▁ BOINC ▁ with ▁ these ▁ optional ▁ arguments " ) } , { wxCMD_LINE_SWITCH , wxT ( " i " ) , wxT ( " insecure " ) , _ ( " disable ▁ BOINC ▁ security ▁ users ▁ and ▁ permissions " ) } , { wxCMD_LINE_SWITCH , wxT ( " c " ) , wxT ( " checkskins " ) , _ ( " set ▁ skin ▁ debugging ▁ mode ▁ to ▁ enable ▁ skin ▁ manager ▁ error ▁ messages " ) } , { wxCMD_LINE_SWITCH , wxT ( " m " ) , wxT ( " multiple " ) , _ ( " multiple ▁ instances ▁ of ▁ BOINC ▁ Manager ▁ allowed " ) } , defined ( __WXMAC__ ) && defined ( _DEBUG ) ) { wxCMD_LINE_OPTION , wxT ( " NSDocumentRevisionsDebugMode " ) , NULL , _ ( " Not ▁ used : ▁ workaround ▁ for ▁ bug ▁ in ▁ XCode ▁ 4.2" ) } , { wxCMD_LINE_NONE } } ; parser . SetDesc ( cmdLineDesc ) ; }
bool CBOINCGUIApp :: OnCmdLineParsed ( wxCmdLineParser & parser ) { wxApp :: OnCmdLineParsed ( parser ) ; wxString portNum = wxEmptyString ; long longPort ; bool hostNameSpecified = false ; bool passwordSpecified = false ; parser . Found ( wxT ( " boincargs " ) , & m_strBOINCArguments ) ; if ( parser . Found ( wxT ( " autostart " ) ) ) { m_bBOINCMGRAutoStarted = true ; } || defined ( __WXMAC__ ) if ( parser . Found ( wxT ( " systray " ) ) ) { m_bGUIVisible = false ; } if ( parser . Found ( wxT ( " insecure " ) ) ) { g_use_sandbox = false ; } if ( parser . Found ( wxT ( " checkskins " ) ) ) { m_bDebugSkins = true ; } if ( parser . Found ( wxT ( " multiple " ) ) ) { m_bMultipleInstancesOK = true ; } ( defined ( __WXMSW__ ) || defined ( __WXMAC__ ) ) if ( ! parser . Found ( wxT ( " clientdir " ) , & m_strBOINCMGRRootDirectory ) ) { m_strBOINCMGRRootDirectory = :: wxGetCwd ( ) ; } if ( m_strBOINCMGRRootDirectory . Last ( ) != ' / ' ) { m_strBOINCMGRRootDirectory . Append ( ' / ' ) ; } if ( ! parser . Found ( wxT ( " datadir " ) , & m_strBOINCMGRDataDirectory ) ) { m_strBOINCMGRDataDirectory = m_strBOINCMGRRootDirectory ; } if ( m_strBOINCMGRDataDirectory . Last ( ) != ' / ' ) { m_strBOINCMGRDataDirectory . Append ( ' / ' ) ; } if ( parser . Found ( wxT ( " namehost " ) , & m_strHostNameArg ) ) { hostNameSpecified = true ; } else { m_strHostNameArg = wxT ( " localhost " ) ; } if ( parser . Found ( wxT ( " gui _ rpc _ port " ) , & portNum ) ) { if ( portNum . ToLong ( & longPort ) ) { m_iRPCPortArg = longPort ; } else { m_iRPCPortArg = GUI_RPC_PORT ; } } else { m_iRPCPortArg = GUI_RPC_PORT ; } if ( parser . Found ( wxT ( " password " ) , & m_strPasswordArg ) ) { passwordSpecified = true ; } else { m_strPasswordArg = wxEmptyString ; } if ( hostNameSpecified && passwordSpecified ) { m_bMultipleInstancesOK = true ; } return true ; }
bool CBOINCGUIApp :: DetectDuplicateInstance ( ) { if ( CTaskBarIcon :: FireAppRestore ( ) ) { return true ; } ProcessSerialNumber PSN ; int iInstanceID = wxGetApp ( ) . IsAnotherInstanceRunning ( ) ; if ( iInstanceID ) { OSStatus err = GetProcessForPID ( iInstanceID , & PSN ) ; if ( ! err ) SetFrontProcess ( & PSN ) ; return true ; } return false ; }
void CBOINCGUIApp :: DetectExecutableName ( ) { TCHAR szPath [ MAX_PATH - 1 ] ; GetModuleFileName ( NULL , szPath , ( sizeof ( szPath ) / sizeof ( TCHAR ) ) ) ; TCHAR * pszProg = _tcsrchr ( szPath , ' \\ ' ) ; if ( pszProg ) { pszProg ++ ; } m_strBOINCMGRExecutableName = pszProg ; }
void CBOINCGUIApp :: DetectRootDirectory ( ) { TCHAR szPath [ MAX_PATH - 1 ] ; GetModuleFileName ( NULL , szPath , ( sizeof ( szPath ) / sizeof ( TCHAR ) ) ) ; TCHAR * pszProg = _tcsrchr ( szPath , ' \\ ' ) ; if ( pszProg ) { szPath [ pszProg - szPath + 1 ] = 0 ; } m_strBOINCMGRRootDirectory = szPath ; }
void CBOINCGUIApp :: DetectDataDirectory ( ) { LONG lReturnValue ; HKEY hkSetupHive ; LPTSTR lpszRegistryValue = NULL ; DWORD dwSize = 0 ; lReturnValue = RegOpenKeyEx ( HKEY_LOCAL_MACHINE , _T ( " SOFTWARE\\Space ▁ Sciences ▁ Laboratory , ▁ U . C . ▁ Berkeley\\BOINC ▁ Setup " ) , 0 , KEY_READ , & hkSetupHive ) ; if ( lReturnValue == ERROR_SUCCESS ) { lReturnValue = RegQueryValueEx ( hkSetupHive , _T ( " DATADIR " ) , NULL , NULL , NULL , & dwSize ) ; if ( lReturnValue != ERROR_FILE_NOT_FOUND ) { lpszRegistryValue = ( LPTSTR ) malloc ( dwSize ) ; ( * lpszRegistryValue ) = NULL ; lReturnValue = RegQueryValueEx ( hkSetupHive , _T ( " DATADIR " ) , NULL , NULL , ( LPBYTE ) lpszRegistryValue , & dwSize ) ; m_strBOINCMGRDataDirectory = lpszRegistryValue ; } } if ( hkSetupHive ) RegCloseKey ( hkSetupHive ) ; if ( lpszRegistryValue ) free ( lpszRegistryValue ) ; m_strBOINCMGRDataDirectory = wxT ( " / Library / Application ▁ Support / BOINC ▁ Data " ) ; }
void CBOINCGUIApp :: InitSupportedLanguages ( ) { wxInt32 iIndex = 0 ; const wxLanguageInfo * liLanguage = NULL ; m_astrLanguages . Insert ( wxEmptyString , 0 , wxLANGUAGE_USER_DEFINED + 1 ) ; m_astrLanguages [ wxLANGUAGE_DEFAULT ] = _ ( " ( Automatic ▁ Detection ) " ) ; m_astrLanguages [ wxLANGUAGE_UNKNOWN ] = _ ( " ( Unknown ) " ) ; m_astrLanguages [ wxLANGUAGE_USER_DEFINED ] = _ ( " ( User ▁ Defined ) " ) ; for ( iIndex = 0 ; iIndex <= wxLANGUAGE_USER_DEFINED ; iIndex ++ ) { liLanguage = wxLocale :: GetLanguageInfo ( iIndex ) ; if ( liLanguage ) { m_astrLanguages [ iIndex ] = liLanguage -> Description ; } } }
int CBOINCGUIApp :: IdleTrackerAttach ( ) { :: attach_idle_monitor ( ) ; return 0 ; }
int CBOINCGUIApp :: IdleTrackerDetach ( ) { :: detach_idle_monitor ( ) ; return 0 ; }
void CBOINCGUIApp :: OnActivateApp ( wxActivateEvent & event ) { if ( IsModalDialogDisplayed ( ) ) { event . Skip ( ) ; return ; } if ( event . GetActive ( ) ) { if ( m_pEventLog && ! m_pEventLog -> IsIconized ( ) ) { m_pEventLog -> Raise ( ) ; } if ( m_pFrame ) m_pFrame -> Raise ( ) ; } event . Skip ( ) ; }
void CBOINCGUIApp :: OnRPCFinished ( CRPCFinishedEvent & event ) { CMainDocument * pDoc = wxGetApp ( ) . GetDocument ( ) ; wxASSERT ( pDoc ) ; wxASSERT ( wxDynamicCast ( pDoc , CMainDocument ) ) ; pDoc -> OnRPCComplete ( event ) ; }
int CBOINCGUIApp :: UpdateSystemIdleDetection ( ) { return get_idle_tick_count ( ) ; return TRUE ; }
int CBOINCGUIApp :: StartBOINCScreensaverTest ( ) { wxString strExecute = wxEmptyString ; wxChar szExecutableDirectory [ 4096 ] ; memset ( szExecutableDirectory , 0 , sizeof ( szExecutableDirectory ) ) ; GetWindowsDirectory ( szExecutableDirectory , ( sizeof ( szExecutableDirectory ) / sizeof ( wxChar ) ) ) ; strExecute = wxT ( " \ " " ) + wxString ( szExecutableDirectory ) + wxT ( " \ \ boinc . scr \ " ▁ / t " ) ; :: wxExecute ( strExecute ) ; return 0 ; }
int CBOINCGUIApp :: StartBOINCDefaultScreensaverTest ( ) { wxString strExecute = wxEmptyString ; strExecute = wxT ( " \ " " ) + m_strBOINCMGRRootDirectory + wxT ( " \ \ boincscr . exe \ " ▁ - - test " ) ; :: wxExecute ( strExecute ) ; return 0 ; }
void CBOINCGUIApp :: DisplayEventLog ( bool bShowWindow ) { if ( m_pEventLog ) { if ( bShowWindow ) { if ( m_pEventLog -> IsIconized ( ) ) { m_pEventLog -> Iconize ( false ) ; } m_pEventLog -> Raise ( ) ; } } else { m_pEventLog = new CDlgEventLog ( ) ; if ( m_pEventLog ) { m_pEventLog -> Show ( bShowWindow ) ; if ( bShowWindow ) { m_pEventLog -> Raise ( ) ; } if ( m_pFrame ) { m_pFrame -> UpdateRefreshTimerInterval ( ) ; } } } }
void CBOINCGUIApp :: OnEventLogClose ( ) { m_pEventLog = NULL ; if ( m_pFrame ) { m_pFrame -> UpdateRefreshTimerInterval ( ) ; } }
void CBOINCGUIApp :: FireReloadSkin ( ) { if ( m_pFrame ) { m_pFrame -> FireReloadSkin ( ) ; } if ( m_pTaskBarIcon ) { m_pTaskBarIcon -> FireReloadSkin ( ) ; } }
bool CBOINCGUIApp :: SetActiveGUI ( int iGUISelection , bool bShowWindow ) { wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ Function ▁ Begin " ) ) ; wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ GUI ▁ Selection : ▁ ' % d ' , ▁ Show : ▁ % d ' " ) , iGUISelection , ( int ) bShowWindow ) ; CBOINCBaseFrame * pNewFrame = NULL ; CBOINCBaseFrame * pOldFrame = m_pFrame ; wxInt32 iTop = 0 ; wxInt32 iLeft = 0 ; wxInt32 iHeight = 0 ; wxInt32 iWidth = 0 ; if ( ( iGUISelection != m_iGUISelected ) || ! m_pFrame ) { if ( BOINC_ADVANCEDGUI == iGUISelection ) { m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Read ( wxT ( " YPos " ) , & iTop , 30 ) ; m_pConfig -> Read ( wxT ( " XPos " ) , & iLeft , 30 ) ; m_pConfig -> Read ( wxT ( " Width " ) , & iWidth , 800 ) ; m_pConfig -> Read ( wxT ( " Height " ) , & iHeight , 600 ) ; } else { m_pConfig -> SetPath ( wxT ( " / Simple " ) ) ; m_pConfig -> Read ( wxT ( " YPos " ) , & iTop , 30 ) ; m_pConfig -> Read ( wxT ( " XPos " ) , & iLeft , 30 ) ; iWidth = 409 ; iHeight = 561 ; iWidth = 416 ; iHeight = 570 ; } if ( ! IsWindowOnScreen ( iLeft , iTop , iWidth , iHeight ) ) { iTop = iLeft = 30 ; } if ( iLeft < 0 ) iLeft = 30 ; if ( iTop < 0 ) iTop = 30 ; wxInt32 iMaxWidth = wxSystemSettings :: GetMetric ( wxSYS_SCREEN_X ) ; wxInt32 iMaxHeight = wxSystemSettings :: GetMetric ( wxSYS_SCREEN_Y ) ; if ( iLeft + iWidth > iMaxWidth ) iLeft = iMaxWidth - iWidth ; if ( iTop + iHeight > iMaxHeight ) iTop = iMaxHeight - iHeight ; if ( BOINC_ADVANCEDGUI == iGUISelection ) { pNewFrame = new CAdvancedFrame ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon32 ( ) , wxPoint ( iLeft , iTop ) , wxSize ( iWidth , iHeight ) ) ; } else { pNewFrame = new CSimpleFrame ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon32 ( ) , wxPoint ( iLeft , iTop ) , wxSize ( iWidth , iHeight ) ) ; } wxASSERT ( pNewFrame ) ; if ( pNewFrame ) { SetTopWindow ( pNewFrame ) ; m_pFrame = pNewFrame ; if ( pOldFrame ) pOldFrame -> Hide ( ) ; if ( pOldFrame ) pOldFrame -> Destroy ( ) ; } } if ( m_pFrame && bShowWindow ) { if ( m_pEventLog ) { m_pEventLog -> Show ( ) ; m_pEventLog -> Raise ( ) ; :: SetForegroundWindow ( ( HWND ) m_pEventLog -> GetHWND ( ) ) ; } if ( ! m_pFrame -> IsShown ( ) ) { m_pFrame -> Show ( ) ; } if ( m_pFrame -> IsIconized ( ) ) { m_pFrame -> Maximize ( false ) ; } m_pFrame -> Raise ( ) ; :: SetForegroundWindow ( ( HWND ) m_pFrame -> GetHWND ( ) ) ; } m_iGUISelected = iGUISelection ; m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Write ( wxT ( " GUISelection " ) , iGUISelection ) ; wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ Function ▁ End " ) ) ; return true ; }
int CBOINCGUIApp :: ConfirmExit ( ) { CSkinAdvanced * pSkinAdvanced = wxGetApp ( ) . GetSkinManager ( ) -> GetAdvanced ( ) ; CMainDocument * pDoc = wxGetApp ( ) . GetDocument ( ) ; wxString strConnectedCompter = wxEmptyString ; bool bWasVisible ; int retval = 0 ; wxASSERT ( pDoc ) ; wxASSERT ( pSkinAdvanced ) ; wxASSERT ( wxDynamicCast ( pDoc , CMainDocument ) ) ; wxASSERT ( wxDynamicCast ( pSkinAdvanced , CSkinAdvanced ) ) ; pDoc -> GetConnectedComputerName ( strConnectedCompter ) ; if ( ! pDoc -> IsComputerNameLocal ( strConnectedCompter ) ) { return 1 ; } if ( s_bSkipExitConfirmation ) return 1 ; if ( IsMgrMultipleInstance ( ) ) return 1 ; if ( ! m_iDisplayExitDialog ) { return 1 ; } bWasVisible = IsApplicationVisible ( ) ; ShowApplication ( true ) ; CDlgExitMessage dlg ( NULL ) ; if ( ! pSkinAdvanced -> GetExitMessage ( ) . IsEmpty ( ) ) { dlg . m_DialogExitMessage -> SetLabel ( pSkinAdvanced -> GetExitMessage ( ) ) ; } if ( m_iShutdownCoreClient ) { dlg . m_DialogShutdownCoreClient -> SetValue ( TRUE ) ; } if ( m_iDisplayExitDialog ) { dlg . m_DialogDisplay -> SetValue ( FALSE ) ; } dlg . Fit ( ) ; dlg . Centre ( ) ; if ( wxID_OK == dlg . ShowModal ( ) ) { s_bSkipExitConfirmation = true ; m_iShutdownCoreClient = dlg . m_DialogShutdownCoreClient -> GetValue ( ) ; m_iDisplayExitDialog = ! dlg . m_DialogDisplay -> GetValue ( ) ; retval = true ; } if ( ! bWasVisible ) { ShowApplication ( false ) ; } return retval ; }
int CBOINCGUIApp :: SafeMessageBox ( const wxString & message , const wxString & caption , long style , wxWindow * parent , int x , int y ) { int retval ; m_bSafeMessageBoxDisplayed ++ ; retval = wxMessageBox ( message , caption , style , parent , x , y ) ; m_bSafeMessageBoxDisplayed -- ; return retval ; }
int CBOINCGUIApp :: IsAnotherInstanceRunning ( ) { PROC_MAP pm ; int retval ; char myName [ 256 ] ; int otherInstanceID = 0 ; int myPid ; retval = procinfo_setup ( pm ) ; if ( retval ) return false ; myPid = ( int ) GetCurrentProcessId ( ) ; myPid = getpid ( ) ; myName [ 0 ] = 0 ; PROC_MAP :: iterator i ; for ( i = pm . begin ( ) ; i != pm . end ( ) ; i ++ ) { PROCINFO & pi = i -> second ; if ( pi . id == myPid ) { strncpy ( myName , pi . command , sizeof ( myName ) ) ; break ; } } if ( myName [ 0 ] == 0 ) { return false ; } for ( i = pm . begin ( ) ; i != pm . end ( ) ; i ++ ) { PROCINFO & pi = i -> second ; if ( pi . id == myPid ) continue ; if ( ! strcmp ( pi . command , myName ) ) { otherInstanceID = pi . id ; break ; } } return otherInstanceID ; }
bool CBOINCGUIApp :: IsApplicationVisible ( ) { if ( IsProcessVisible ( & m_psnCurrentProcess ) ) { return true ; } return false ; }
void CBOINCGUIApp :: ShowApplication ( bool bShow ) { if ( bShow ) { SetFrontProcess ( & m_psnCurrentProcess ) ; } else { ShowHideProcess ( & m_psnCurrentProcess , false ) ; } }
bool CBOINCGUIApp :: ShowInterface ( ) { return SetActiveGUI ( m_iGUISelected , true ) ; }
bool CBOINCGUIApp :: ShowNotifications ( ) { bool retval = false ; retval = SetActiveGUI ( m_iGUISelected , true ) ; if ( retval ) { GetFrame ( ) -> FireNotification ( ) ; GetDocument ( ) -> UpdateUnreadNoticeState ( ) ; } return retval ; }
bool CBOINCGUIApp :: IsModalDialogDisplayed ( ) { if ( m_bSafeMessageBoxDisplayed ) return true ; if ( wxDynamicCast ( wxWindow :: FindWindowById ( ID_ANYDIALOG ) , wxDialog ) ) { return true ; } if ( m_pDocument ) { if ( m_pDocument -> WaitingForRPC ( ) ) { return true ; } } return false ; }
void CBOINCGUIApp :: DeleteTaskBarIcon ( ) { if ( m_pTaskBarIcon ) { delete m_pTaskBarIcon ; } m_pTaskBarIcon = NULL ; }
void CBOINCGUIApp :: DeleteMacSystemMenu ( ) { if ( m_pMacSystemMenu ) { delete m_pMacSystemMenu ; } m_pMacSystemMenu = NULL ; }
int CBOINCGUIApp :: FilterEvent ( wxEvent & event ) { int theEventType ; wxDialog * theRPCWaitDialog ; wxObject * theObject ; if ( ! m_pDocument ) return - 1 ; theEventType = event . GetEventType ( ) ; if ( m_pDocument -> WaitingForRPC ( ) ) { if ( ( theEventType == wxEVT_COMMAND_MENU_SELECTED ) && ( event . GetId ( ) == wxID_OPEN ) ) { return - 1 ; } theRPCWaitDialog = m_pDocument -> GetRPCWaitDialog ( ) ; theObject = event . GetEventObject ( ) ; while ( theObject ) { if ( ! theObject -> IsKindOf ( CLASSINFO ( wxWindow ) ) ) break ; if ( theObject == theRPCWaitDialog ) return - 1 ; theObject = ( ( wxWindow * ) theObject ) -> GetParent ( ) ; } } else { if ( ! m_bFilterEvents ) return - 1 ; } if ( event . IsCommandEvent ( ) ) { return false ; } if ( theEventType == wxEVT_TIMER ) { return false ; } if ( theEventType == wxEVT_TASKBAR_MOVE ) { return false ; } return - 1 ; }
Items :: Items ( ) { items . reserve ( 20000 ) ; }
Items :: ~ Items ( ) { clear ( ) ; }
void Items :: clear ( ) { items . clear ( ) ; }
bool Items :: reload ( ) { clear ( ) ; loadFromOtb ( " data / items / items . otb " ) ; if ( ! loadFromXml ( ) ) { return false ; } g_moveEvents -> reload ( ) ; g_weapons -> reload ( ) ; g_weapons -> loadDefaults ( ) ; return true ; }
FILELOADER_ERRORS Items :: loadFromOtb ( const std :: string & file ) { FileLoader f ; if ( ! f . openFile ( file . c_str ( ) , " OTBI " ) ) { return f . getError ( ) ; } uint32_t type ; NODE node = f . getChildNode ( NO_NODE , type ) ; PropStream props ; if ( f . getProps ( node , props ) ) { uint32_t flags ; if ( ! props . read < uint32_t > ( flags ) ) { return ERROR_INVALID_FORMAT ; } uint8_t attr ; if ( ! props . read < uint8_t > ( attr ) ) { return ERROR_INVALID_FORMAT ; } if ( attr == ROOT_ATTR_VERSION ) { uint16_t datalen ; if ( ! props . read < uint16_t > ( datalen ) ) { return ERROR_INVALID_FORMAT ; } if ( datalen != sizeof ( VERSIONINFO ) ) { return ERROR_INVALID_FORMAT ; } VERSIONINFO vi ; if ( ! props . read ( vi ) ) { return ERROR_INVALID_FORMAT ; } Items :: dwMajorVersion = vi . dwMajorVersion ; Items :: dwMinorVersion = vi . dwMinorVersion ; Items :: dwBuildNumber = vi . dwBuildNumber ; } } if ( Items :: dwMajorVersion == 0xFFFFFFFF ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromOtb ] ▁ items . otb ▁ using ▁ generic ▁ client ▁ version . " << std :: endl ; } else if ( Items :: dwMajorVersion > 2 ) { std :: cout << " New ▁ version ▁ detected , ▁ an ▁ older ▁ version ▁ of ▁ items . otb ▁ is ▁ required . " << std :: endl ; return ERROR_INVALID_FORMAT ; } else if ( Items :: dwMinorVersion < CLIENT_VERSION_740 ) { std :: cout << " A ▁ newer ▁ version ▁ of ▁ items . otb ▁ is ▁ required . " << std :: endl ; return ERROR_INVALID_FORMAT ; } node = f . getChildNode ( node , type ) ; while ( node != NO_NODE ) { PropStream stream ; if ( ! f . getProps ( node , stream ) ) { return f . getError ( ) ; } uint32_t flags ; if ( ! stream . read < uint32_t > ( flags ) ) { return ERROR_INVALID_FORMAT ; } uint16_t serverId = 0 ; uint16_t clientId = 0 ; uint16_t speed = 0 ; uint16_t wareId = 0 ; uint8_t lightLevel = 0 ; uint8_t lightColor = 0 ; uint8_t alwaysOnTopOrder = 0 ; uint8_t attrib ; while ( stream . read < uint8_t > ( attrib ) ) { uint16_t datalen ; if ( ! stream . read < uint16_t > ( datalen ) ) { return ERROR_INVALID_FORMAT ; } switch ( attrib ) { case ITEM_ATTR_SERVERID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( serverId ) ) { return ERROR_INVALID_FORMAT ; } if ( serverId > 20000 && serverId < 20100 ) { serverId -= 20000 ; } break ; } case ITEM_ATTR_CLIENTID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( clientId ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_SPEED : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( speed ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_LIGHT2 : { if ( datalen != sizeof ( lightBlock2 ) ) { return ERROR_INVALID_FORMAT ; } lightBlock2 lb2 ; if ( ! stream . read ( lb2 ) ) { return ERROR_INVALID_FORMAT ; } lightLevel = static_cast < uint8_t > ( lb2 . lightLevel ) ; lightColor = static_cast < uint8_t > ( lb2 . lightColor ) ; break ; } case ITEM_ATTR_TOPORDER : { if ( datalen != sizeof ( uint8_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint8_t > ( alwaysOnTopOrder ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_WAREID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( wareId ) ) { return ERROR_INVALID_FORMAT ; } break ; } default : { if ( ! stream . skip ( datalen ) ) { return ERROR_INVALID_FORMAT ; } break ; } } } reverseItemMap . emplace ( clientId , serverId ) ; if ( serverId >= items . size ( ) ) { items . resize ( serverId + 1 ) ; } ItemType & iType = items [ serverId ] ; iType . group = static_cast < itemgroup_t > ( type ) ; switch ( type ) { case ITEM_GROUP_CONTAINER : iType . type = ITEM_TYPE_CONTAINER ; break ; case ITEM_GROUP_DOOR : iType . type = ITEM_TYPE_DOOR ; break ; case ITEM_GROUP_MAGICFIELD : iType . type = ITEM_TYPE_MAGICFIELD ; break ; case ITEM_GROUP_TELEPORT : iType . type = ITEM_TYPE_TELEPORT ; break ; case ITEM_GROUP_NONE : case ITEM_GROUP_GROUND : case ITEM_GROUP_SPLASH : case ITEM_GROUP_FLUID : case ITEM_GROUP_CHARGES : case ITEM_GROUP_DEPRECATED : break ; default : return ERROR_INVALID_FORMAT ; } iType . blockSolid = hasBitSet ( FLAG_BLOCK_SOLID , flags ) ; iType . blockProjectile = hasBitSet ( FLAG_BLOCK_PROJECTILE , flags ) ; iType . blockPathFind = hasBitSet ( FLAG_BLOCK_PATHFIND , flags ) ; iType . hasHeight = hasBitSet ( FLAG_HAS_HEIGHT , flags ) ; iType . useable = hasBitSet ( FLAG_USEABLE , flags ) ; iType . pickupable = hasBitSet ( FLAG_PICKUPABLE , flags ) ; iType . moveable = hasBitSet ( FLAG_MOVEABLE , flags ) ; iType . stackable = hasBitSet ( FLAG_STACKABLE , flags ) ; iType . alwaysOnTop = hasBitSet ( FLAG_ALWAYSONTOP , flags ) ; iType . isVertical = hasBitSet ( FLAG_VERTICAL , flags ) ; iType . isHorizontal = hasBitSet ( FLAG_HORIZONTAL , flags ) ; iType . isHangable = hasBitSet ( FLAG_HANGABLE , flags ) ; iType . allowDistRead = hasBitSet ( FLAG_ALLOWDISTREAD , flags ) ; iType . rotatable = hasBitSet ( FLAG_ROTATABLE , flags ) ; iType . canReadText = hasBitSet ( FLAG_READABLE , flags ) ; iType . lookThrough = hasBitSet ( FLAG_LOOKTHROUGH , flags ) ; iType . forceUse = hasBitSet ( FLAG_FORCEUSE , flags ) ; iType . id = serverId ; iType . clientId = clientId ; iType . speed = speed ; iType . lightLevel = lightLevel ; iType . lightColor = lightColor ; iType . wareId = wareId ; iType . alwaysOnTopOrder = alwaysOnTopOrder ; node = f . getNextNode ( node , type ) ; } items . shrink_to_fit ( ) ; return ERROR_NONE ; }
bool Items :: loadFromXml ( ) { pugi :: xml_document doc ; pugi :: xml_parse_result result = doc . load_file ( " data / items / items . xml " ) ; if ( ! result ) { printXMLError ( " Error ▁ - ▁ Items : : loadFromXml " , " data / items / items . xml " , result ) ; return false ; } for ( auto itemNode : doc . child ( " items " ) . children ( ) ) { pugi :: xml_attribute idAttribute = itemNode . attribute ( " id " ) ; if ( idAttribute ) { parseItemNode ( itemNode , pugi :: cast < uint16_t > ( idAttribute . value ( ) ) ) ; continue ; } pugi :: xml_attribute fromIdAttribute = itemNode . attribute ( " fromid " ) ; if ( ! fromIdAttribute ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromXml ] ▁ No ▁ item ▁ id ▁ found " << std :: endl ; continue ; } pugi :: xml_attribute toIdAttribute = itemNode . attribute ( " toid " ) ; if ( ! toIdAttribute ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromXml ] ▁ fromid ▁ ( " << fromIdAttribute . value ( ) << " ) ▁ without ▁ toid " << std :: endl ; continue ; } uint16_t id = pugi :: cast < uint16_t > ( fromIdAttribute . value ( ) ) ; uint16_t toId = pugi :: cast < uint16_t > ( toIdAttribute . value ( ) ) ; while ( id <= toId ) { parseItemNode ( itemNode , id ++ ) ; } } return true ; }
void Items :: parseItemNode ( const pugi :: xml_node & itemNode , uint16_t id ) { if ( id > 20000 && id < 20100 ) { id -= 20000 ; if ( id >= items . size ( ) ) { items . resize ( id + 1 ) ; } ItemType & iType = items [ id ] ; iType . id = id ; } ItemType & it = getItemType ( id ) ; if ( it . id == 0 ) { return ; } it . name = itemNode . attribute ( " name " ) . as_string ( ) ; pugi :: xml_attribute articleAttribute = itemNode . attribute ( " article " ) ; if ( articleAttribute ) { it . article = articleAttribute . as_string ( ) ; } pugi :: xml_attribute pluralAttribute = itemNode . attribute ( " plural " ) ; if ( pluralAttribute ) { it . pluralName = pluralAttribute . as_string ( ) ; } for ( auto attributeNode : itemNode . children ( ) ) { pugi :: xml_attribute keyAttribute = attributeNode . attribute ( " key " ) ; if ( ! keyAttribute ) { continue ; } pugi :: xml_attribute valueAttribute = attributeNode . attribute ( " value " ) ; if ( ! valueAttribute ) { continue ; } std :: string tmpStrValue = asLowerCaseString ( keyAttribute . as_string ( ) ) ; if ( tmpStrValue == " type " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " key " ) { it . type = ITEM_TYPE_KEY ; } else if ( tmpStrValue == " magicfield " ) { it . type = ITEM_TYPE_MAGICFIELD ; } else if ( tmpStrValue == " container " ) { it . group = ITEM_GROUP_CONTAINER ; it . type = ITEM_TYPE_CONTAINER ; } else if ( tmpStrValue == " depot " ) { it . type = ITEM_TYPE_DEPOT ; } else if ( tmpStrValue == " mailbox " ) { it . type = ITEM_TYPE_MAILBOX ; } else if ( tmpStrValue == " trashholder " ) { it . type = ITEM_TYPE_TRASHHOLDER ; } else if ( tmpStrValue == " teleport " ) { it . type = ITEM_TYPE_TELEPORT ; } else if ( tmpStrValue == " door " ) { it . type = ITEM_TYPE_DOOR ; } else if ( tmpStrValue == " bed " ) { it . type = ITEM_TYPE_BED ; } else if ( tmpStrValue == " rune " ) { it . type = ITEM_TYPE_RUNE ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ type : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " description " ) { it . description = valueAttribute . as_string ( ) ; } else if ( tmpStrValue == " runespellname " ) { it . runeSpellName = valueAttribute . as_string ( ) ; } else if ( tmpStrValue == " weight " ) { it . weight = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showcount " ) { it . showCount = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " armor " ) { it . armor = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " defense " ) { it . defense = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " extradef " ) { it . extraDefense = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " attack " ) { it . attack = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " rotateto " ) { it . rotateTo = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " moveable " || tmpStrValue == " movable " ) { it . moveable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " blockprojectile " ) { it . blockProjectile = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " allowpickupable " || tmpStrValue == " pickupable " ) { it . allowPickupable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " floorchange " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " down " ) { it . floorChange = TILESTATE_FLOORCHANGE_DOWN ; } else if ( tmpStrValue == " north " ) { it . floorChange = TILESTATE_FLOORCHANGE_NORTH ; } else if ( tmpStrValue == " south " ) { it . floorChange = TILESTATE_FLOORCHANGE_SOUTH ; } else if ( tmpStrValue == " southalt " ) { it . floorChange = TILESTATE_FLOORCHANGE_SOUTH_ALT ; } else if ( tmpStrValue == " west " ) { it . floorChange = TILESTATE_FLOORCHANGE_WEST ; } else if ( tmpStrValue == " east " ) { it . floorChange = TILESTATE_FLOORCHANGE_EAST ; } else if ( tmpStrValue == " eastalt " ) { it . floorChange = TILESTATE_FLOORCHANGE_EAST_ALT ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ floorChange : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " corpsetype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " venom " ) { it . corpseType = RACE_VENOM ; } else if ( tmpStrValue == " blood " ) { it . corpseType = RACE_BLOOD ; } else if ( tmpStrValue == " undead " ) { it . corpseType = RACE_UNDEAD ; } else if ( tmpStrValue == " fire " ) { it . corpseType = RACE_FIRE ; } else if ( tmpStrValue == " energy " ) { it . corpseType = RACE_ENERGY ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ corpseType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " containersize " ) { it . maxItems = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fluidsource " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " water " ) { it . fluidSource = FLUID_WATER ; } else if ( tmpStrValue == " blood " ) { it . fluidSource = FLUID_BLOOD ; } else if ( tmpStrValue == " beer " ) { it . fluidSource = FLUID_BEER ; } else if ( tmpStrValue == " slime " ) { it . fluidSource = FLUID_SLIME ; } else if ( tmpStrValue == " lemonade " ) { it . fluidSource = FLUID_LEMONADE ; } else if ( tmpStrValue == " milk " ) { it . fluidSource = FLUID_MILK ; } else if ( tmpStrValue == " mana " ) { it . fluidSource = FLUID_MANA ; } else if ( tmpStrValue == " life " ) { it . fluidSource = FLUID_LIFE ; } else if ( tmpStrValue == " oil " ) { it . fluidSource = FLUID_OIL ; } else if ( tmpStrValue == " urine " ) { it . fluidSource = FLUID_URINE ; } else if ( tmpStrValue == " coconut " ) { it . fluidSource = FLUID_COCONUTMILK ; } else if ( tmpStrValue == " wine " ) { it . fluidSource = FLUID_WINE ; } else if ( tmpStrValue == " mud " ) { it . fluidSource = FLUID_MUD ; } else if ( tmpStrValue == " fruitjuice " ) { it . fluidSource = FLUID_FRUITJUICE ; } else if ( tmpStrValue == " lava " ) { it . fluidSource = FLUID_LAVA ; } else if ( tmpStrValue == " rum " ) { it . fluidSource = FLUID_RUM ; } else if ( tmpStrValue == " swamp " ) { it . fluidSource = FLUID_SWAMP ; } else if ( tmpStrValue == " tea " ) { it . fluidSource = FLUID_TEA ; } else if ( tmpStrValue == " mead " ) { it . fluidSource = FLUID_MEAD ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ fluidSource : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " readable " ) { it . canReadText = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " writeable " ) { it . canWriteText = valueAttribute . as_bool ( ) ; it . canReadText = it . canWriteText ; } else if ( tmpStrValue == " maxtextlen " ) { it . maxTextLen = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " writeonceitemid " ) { it . writeOnceItemId = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " weapontype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " sword " ) { it . weaponType = WEAPON_SWORD ; } else if ( tmpStrValue == " club " ) { it . weaponType = WEAPON_CLUB ; } else if ( tmpStrValue == " axe " ) { it . weaponType = WEAPON_AXE ; } else if ( tmpStrValue == " shield " ) { it . weaponType = WEAPON_SHIELD ; } else if ( tmpStrValue == " distance " ) { it . weaponType = WEAPON_DISTANCE ; } else if ( tmpStrValue == " wand " ) { it . weaponType = WEAPON_WAND ; } else if ( tmpStrValue == " ammunition " ) { it . weaponType = WEAPON_AMMO ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ weaponType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " slottype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " head " ) { it . slotPosition |= SLOTP_HEAD ; } else if ( tmpStrValue == " body " ) { it . slotPosition |= SLOTP_ARMOR ; } else if ( tmpStrValue == " legs " ) { it . slotPosition |= SLOTP_LEGS ; } else if ( tmpStrValue == " feet " ) { it . slotPosition |= SLOTP_FEET ; } else if ( tmpStrValue == " backpack " ) { it . slotPosition |= SLOTP_BACKPACK ; } else if ( tmpStrValue == " two - handed " ) { it . slotPosition |= SLOTP_TWO_HAND ; } else if ( tmpStrValue == " right - hand " ) { it . slotPosition &= ~ SLOTP_LEFT ; } else if ( tmpStrValue == " left - hand " ) { it . slotPosition &= ~ SLOTP_RIGHT ; } else if ( tmpStrValue == " necklace " ) { it . slotPosition |= SLOTP_NECKLACE ; } else if ( tmpStrValue == " ring " ) { it . slotPosition |= SLOTP_RING ; } else if ( tmpStrValue == " ammo " ) { it . slotPosition |= SLOTP_AMMO ; } else if ( tmpStrValue == " hand " ) { it . slotPosition |= SLOTP_HAND ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ slotType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " ammotype " ) { it . ammoType = getAmmoType ( valueAttribute . as_string ( ) ) ; if ( it . ammoType == AMMO_NONE ) { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ ammoType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " shoottype " ) { ShootType_t shoot = getShootType ( valueAttribute . as_string ( ) ) ; if ( shoot != CONST_ANI_NONE ) { it . shootType = shoot ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ shootType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " effect " ) { MagicEffectClasses effect = getMagicEffect ( valueAttribute . as_string ( ) ) ; if ( effect != CONST_ME_NONE ) { it . magicEffect = effect ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ effect : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " range " ) { it . shootRange = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " stopduration " ) { it . stopTime = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " decayto " ) { it . decayTo = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " transformequipto " ) { it . transformEquipTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " transformdeequipto " ) { it . transformDeEquipTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " duration " ) { it . decayTime = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showduration " ) { it . showDuration = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " charges " ) { it . charges = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showcharges " ) { it . showCharges = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " showattributes " ) { it . showAttributes = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " hitchance " ) { it . hitChance = std :: min < int8_t > ( 100 , std :: max < int8_t > ( - 100 , pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ) ) ; } else if ( tmpStrValue == " maxhitchance " ) { it . maxHitChance = std :: min < uint32_t > ( 100 , pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " invisible " ) { it . getAbilities ( ) . invisible = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " speed " ) { it . getAbilities ( ) . speed = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " healthgain " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . healthGain = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " healthticks " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . healthTicks = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " managain " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . manaGain = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " manaticks " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . manaTicks = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " manashield " ) { it . getAbilities ( ) . manaShield = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " skillsword " ) { it . getAbilities ( ) . skills [ SKILL_SWORD ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillaxe " ) { it . getAbilities ( ) . skills [ SKILL_AXE ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillclub " ) { it . getAbilities ( ) . skills [ SKILL_CLUB ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skilldist " ) { it . getAbilities ( ) . skills [ SKILL_DISTANCE ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillfish " ) { it . getAbilities ( ) . skills [ SKILL_FISHING ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillshield " ) { it . getAbilities ( ) . skills [ SKILL_SHIELD ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillfist " ) { it . getAbilities ( ) . skills [ SKILL_FIST ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxhitpoints " ) { it . getAbilities ( ) . stats [ STAT_MAXHITPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxhitpointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAXHITPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxmanapoints " ) { it . getAbilities ( ) . stats [ STAT_MAXMANAPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxmanapointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAXMANAPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " magicpoints " || tmpStrValue == " magiclevelpoints " ) { it . getAbilities ( ) . stats [ STAT_MAGICPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " magicpointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAGICPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercentenergy " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercentfire " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercentpoison " || tmpStrValue == " fieldabsorpercentearth " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentall " || tmpStrValue == " absorbpercentallelements " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; for ( size_t i = 0 ; i < COMBAT_COUNT ; ++ i ) { abilities . absorbPercent [ i ] += value ; } } else if ( tmpStrValue == " absorbpercentelements " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += value ; } else if ( tmpStrValue == " absorbpercentmagic " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += value ; } else if ( tmpStrValue == " absorbpercentenergy " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentfire " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentpoison " || tmpStrValue == " absorbpercentearth " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentlifedrain " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_LIFEDRAIN ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentmanadrain " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_MANADRAIN ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentphysical " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_PHYSICALDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercenthealing " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_HEALING ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentundefined " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_UNDEFINEDDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " suppressdrunk " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_DRUNK ; } } else if ( tmpStrValue == " suppressenergy " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_ENERGY ; } } else if ( tmpStrValue == " suppressfire " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_FIRE ; } } else if ( tmpStrValue == " suppresspoison " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_POISON ; } } else if ( tmpStrValue == " suppressphysical " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_BLEEDING ; } } else if ( tmpStrValue == " field " ) { it . group = ITEM_GROUP_MAGICFIELD ; it . type = ITEM_TYPE_MAGICFIELD ; CombatType_t combatType = COMBAT_NONE ; ConditionDamage * conditionDamage = nullptr ; tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " fire " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_FIRE ) ; combatType = COMBAT_FIREDAMAGE ; } else if ( tmpStrValue == " energy " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_ENERGY ) ; combatType = COMBAT_ENERGYDAMAGE ; } else if ( tmpStrValue == " poison " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_POISON ) ; combatType = COMBAT_EARTHDAMAGE ; } else if ( tmpStrValue == " physical " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_BLEEDING ) ; combatType = COMBAT_PHYSICALDAMAGE ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ field ▁ value : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } if ( combatType != COMBAT_NONE ) { it . combatType = combatType ; it . conditionDamage . reset ( conditionDamage ) ; uint32_t ticks = 0 ; int32_t damage = 0 ; int32_t start = 0 ; int32_t count = 1 ; for ( auto subAttributeNode : attributeNode . children ( ) ) { pugi :: xml_attribute subKeyAttribute = subAttributeNode . attribute ( " key " ) ; if ( ! subKeyAttribute ) { continue ; } pugi :: xml_attribute subValueAttribute = subAttributeNode . attribute ( " value " ) ; if ( ! subValueAttribute ) { continue ; } tmpStrValue = asLowerCaseString ( subKeyAttribute . as_string ( ) ) ; if ( tmpStrValue == " ticks " ) { ticks = pugi :: cast < uint32_t > ( subValueAttribute . value ( ) ) ; } else if ( tmpStrValue == " count " ) { count = std :: max < int32_t > ( 1 , pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " start " ) { start = std :: max < int32_t > ( 0 , pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " damage " ) { damage = - pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ; if ( start > 0 ) { std :: list < int32_t > damageList ; ConditionDamage :: generateDamageList ( damage , start , damageList ) ; for ( int32_t damageValue : damageList ) { conditionDamage -> addDamage ( 1 , ticks , - damageValue ) ; } start = 0 ; } else { conditionDamage -> addDamage ( count , ticks , damage ) ; } } } conditionDamage -> setParam ( CONDITION_PARAM_FIELD , 1 ) ; if ( conditionDamage -> getTotalDamage ( ) > 0 ) { conditionDamage -> setParam ( CONDITION_PARAM_FORCEUPDATE , 1 ) ; } } } else if ( tmpStrValue == " replaceable " ) { it . replaceable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " partnerdirection " ) { it . bedPartnerDir = getDirection ( valueAttribute . as_string ( ) ) ; } else if ( tmpStrValue == " leveldoor " ) { it . levelDoor = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " sleeper " ) { uint16_t value = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; it . transformToOnUse = value ; ItemType & other = getItemType ( value ) ; if ( other . transformToFree == 0 ) { other . transformToFree = it . id ; } if ( it . transformToOnUse == 0 ) { it . transformToOnUse = value ; } } else if ( tmpStrValue == " transformto " ) { it . transformToFree = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " destroyto " ) { it . destroyTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " elementearth " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_EARTHDAMAGE ; } else if ( tmpStrValue == " elementfire " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_FIREDAMAGE ; } else if ( tmpStrValue == " elementenergy " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_ENERGYDAMAGE ; } else if ( tmpStrValue == " walkstack " ) { it . walkStack = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " blocking " ) { it . blockSolid = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " allowdistread " ) { it . allowDistRead = booleanString ( valueAttribute . as_string ( ) ) ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ key ▁ value : ▁ " << keyAttribute . as_string ( ) << std :: endl ; } } if ( ( it . transformToFree != 0 || it . transformToOnUse != 0 || it . transformToOnUse != 0 ) && it . type != ITEM_TYPE_BED ) { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Item ▁ " << it . id << " ▁ is ▁ not ▁ set ▁ as ▁ a ▁ bed - type " << std :: endl ; } }
ItemType & Items :: getItemType ( size_t id ) { if ( id < items . size ( ) ) { return items [ id ] ; } return items . front ( ) ; }
uint16_t Items :: getItemIdByName ( const std :: string & name ) { if ( name . empty ( ) ) { return 0 ; } const char * itemName = name . c_str ( ) ; for ( size_t i = 100 , size = items . size ( ) ; i < size ; ++ i ) { if ( strcasecmp ( itemName , items [ i ] . name . c_str ( ) ) == 0 ) { return i ; } } return 0 ; }
Eigen :: Matrix4d dquatConjugate ( ) { Matrix4d dq_conj = Matrix4d :: Identity ( ) ; dq_conj ( 1 , 1 ) = - 1.0 ; dq_conj ( 2 , 2 ) = - 1.0 ; dq_conj ( 3 , 3 ) = - 1.0 ; return dq_conj ; }
Eigen :: Vector4d quatProduct ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 ) { double w1 = q1 ( 0 ) ; double w2 = q2 ( 0 ) ; const auto & v1 = q1 . tail < 3 > ( ) ; const auto & v2 = q2 . tail < 3 > ( ) ; Vector4d r ; r << w1 * w2 - v1 . dot ( v2 ) , v1 . cross ( v2 ) + w1 * v2 + w2 * v1 ; return r ; }
Eigen :: Matrix < double , 4 , 8 > dquatProduct ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 ) { double w1 = q1 ( 0 ) ; double w2 = q2 ( 0 ) ; const auto & v1 = q1 . tail < 3 > ( ) ; const auto & v2 = q2 . tail < 3 > ( ) ; Matrix < double , 4 , 8 > dr ; dr . row ( 0 ) << w2 , - v2 . transpose ( ) , w1 , - v1 . transpose ( ) ; dr . row ( 1 ) << q2 ( 1 ) , q2 ( 0 ) , q2 ( 3 ) , - q2 ( 2 ) , q1 ( 1 ) , q1 ( 0 ) , - q1 ( 3 ) , q1 ( 2 ) ; dr . row ( 2 ) << q2 ( 2 ) , - q2 ( 3 ) , q2 ( 0 ) , q2 ( 1 ) , q1 ( 2 ) , q1 ( 3 ) , q1 ( 0 ) , - q1 ( 1 ) ; dr . row ( 3 ) << q2 ( 3 ) , q2 ( 2 ) , - q2 ( 1 ) , q2 ( 0 ) , q1 ( 3 ) , - q1 ( 2 ) , q1 ( 1 ) , q1 ( 0 ) ; return dr ; }
Eigen :: Vector3d quatRotateVec ( const Eigen :: Vector4d & q , const Eigen :: Vector3d & v ) { Vector4d v_quat ; v_quat << 0 , v ; Vector4d q_times_v = quatProduct ( q , v_quat ) ; Vector4d q_conj = quatConjugate ( q ) ; Vector4d v_rot = quatProduct ( q_times_v , q_conj ) ; Vector3d r = v_rot . bottomRows < 3 > ( ) ; return r ; }
Eigen :: Matrix < double , 3 , 7 > dquatRotateVec ( const Eigen :: Vector4d & q , const Eigen :: Vector3d & v ) { Matrix < double , 4 , 7 > dq ; dq << Matrix4d :: Identity ( ) , MatrixXd :: Zero ( 4 , 3 ) ; Matrix < double , 4 , 7 > dv = Matrix < double , 4 , 7 > :: Zero ( ) ; dv . bottomRightCorner < 3 , 3 > ( ) = Matrix3d :: Identity ( ) ; Matrix < double , 8 , 7 > dqdv ; dqdv << dq , dv ; Vector4d v_quat ; v_quat << 0 , v ; Vector4d q_times_v = quatProduct ( q , v_quat ) ; Matrix < double , 4 , 8 > dq_times_v_tmp = dquatProduct ( q , v_quat ) ; Matrix < double , 4 , 7 > dq_times_v = dq_times_v_tmp * dqdv ; Matrix < double , 4 , 7 > dq_conj = dquatConjugate ( ) * dq ; Matrix < double , 8 , 7 > dq_times_v_dq_conj ; dq_times_v_dq_conj << dq_times_v , dq_conj ; Matrix < double , 4 , 8 > dv_rot_tmp = dquatProduct ( q_times_v , quatConjugate ( q ) ) ; Matrix < double , 4 , 7 > dv_rot = dv_rot_tmp * dq_times_v_dq_conj ; Eigen :: Matrix < double , 3 , 7 > dr = dv_rot . bottomRows ( 3 ) ; return dr ; }
Eigen :: Vector4d quatDiff ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 ) { return quatProduct ( quatConjugate ( q1 ) , q2 ) ; }
Eigen :: Matrix < double , 4 , 8 > dquatDiff ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 ) { auto dr = dquatProduct ( quatConjugate ( q1 ) , q2 ) ; dr . block < 4 , 3 > ( 0 , 1 ) = - dr . block < 4 , 3 > ( 0 , 1 ) ; return dr ; }
Eigen :: Matrix < double , 1 , 11 > dquatDiffAxisInvar ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 , const Eigen :: Vector3d & u ) { Vector4d r = quatDiff ( q1 , q2 ) ; Matrix < double , 4 , 8 > dr = dquatDiff ( q1 , q2 ) ; Matrix < double , 1 , 11 > de ; const auto & rvec = r . tail < 3 > ( ) ; de << 4.0 * r ( 0 ) * dr . row ( 0 ) + 4.0 * u . transpose ( ) * rvec * u . transpose ( ) * dr . block < 3 , 8 > ( 1 , 0 ) , 4.0 * u . transpose ( ) * rvec * rvec . transpose ( ) ; return de ; }
Eigen :: Vector4d slerp ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 , double interpolation_parameter ) { double lambda = ( q1 . transpose ( ) * q2 ) . value ( ) ; int q2_sign ; if ( lambda < 0.0 ) { lambda = - lambda ; q2_sign = - 1 ; } else { q2_sign = 1 ; } double r , s ; if ( std :: abs ( 1.0 - lambda ) < std :: numeric_limits < double > :: epsilon ( ) ) { r = 1.0 - interpolation_parameter ; s = interpolation_parameter ; } else { double alpha = std :: acos ( lambda ) ; double gamma = 1.0 / std :: sin ( alpha ) ; r = std :: sin ( ( 1.0 - interpolation_parameter ) * alpha ) * gamma ; s = std :: sin ( interpolation_parameter * alpha ) * gamma ; } Vector4d ret = q1 * r ; ret += q2_sign * q2 * s ; return ret ; }
Eigen :: Matrix3d uniformlyRandomRotmat ( std :: default_random_engine & generator ) { return axis2rotmat ( uniformlyRandomAxisAngle ( generator ) ) ; }
Eigen :: Vector3d uniformlyRandomRPY ( std :: default_random_engine & generator ) { return axis2rpy ( uniformlyRandomAxisAngle ( generator ) ) ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > quat2rpy ( const Eigen :: MatrixBase < Derived > & q ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; auto q_normalized = q . normalized ( ) ; auto w = q_normalized ( 0 ) ; auto x = q_normalized ( 1 ) ; auto y = q_normalized ( 2 ) ; auto z = q_normalized ( 3 ) ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > ret ; ret << std :: atan2 ( 2.0 * ( w * x + y * z ) , w * w + z * z - ( x * x + y * y ) ) , std :: asin ( 2.0 * ( w * y - z * x ) ) , std :: atan2 ( 2.0 * ( w * z + x * y ) , w * w + x * x - ( y * y + z * z ) ) ; return ret ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > quat2rotmat ( const Eigen :: MatrixBase < Derived > & q ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; auto q_normalized = q . normalized ( ) ; auto w = q_normalized ( 0 ) ; auto x = q_normalized ( 1 ) ; auto y = q_normalized ( 2 ) ; auto z = q_normalized ( 3 ) ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > M ; M . row ( 0 ) << w * w + x * x - y * y - z * z , 2.0 * x * y - 2.0 * w * z , 2.0 * x * z + 2.0 * w * y ; M . row ( 1 ) << 2.0 * x * y + 2.0 * w * z , w * w + y * y - x * x - z * z , 2.0 * y * z - 2.0 * w * x ; M . row ( 2 ) << 2.0 * x * z - 2.0 * w * y , 2.0 * y * z + 2.0 * w * x , w * w + z * z - x * x - y * y ; return M ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > quat2axis ( const Eigen :: MatrixBase < Derived > & q ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; auto q_normalized = q . normalized ( ) ; auto s = std :: sqrt ( 1.0 - q_normalized ( 0 ) * q_normalized ( 0 ) ) + std :: numeric_limits < typename Derived :: Scalar > :: epsilon ( ) ; Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > a ; a << q_normalized . template tail < 3 > ( ) / s , 2.0 * std :: acos ( q_normalized ( 0 ) ) ; return a ; }
template < typename Derived > Eigen :: Vector4d axis2quat ( const Eigen :: MatrixBase < Derived > & a ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; auto axis = a . template head < 3 > ( ) ; auto angle = a ( 3 ) ; auto arg = 0.5 * angle ; auto c = std :: cos ( arg ) ; auto s = std :: sin ( arg ) ; Eigen :: Vector4d ret ; ret << c , s * axis ; return ret ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > axis2rotmat ( const Eigen :: MatrixBase < Derived > & a ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; const auto & axis = ( a . template head < 3 > ( ) ) / ( a . template head < 3 > ( ) ) . norm ( ) ; const auto & theta = a ( 3 ) ; auto x = axis ( 0 ) ; auto y = axis ( 1 ) ; auto z = axis ( 2 ) ; auto ctheta = std :: cos ( theta ) ; auto stheta = std :: sin ( theta ) ; auto c = 1 - ctheta ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > R ; R << ctheta + x * x * c , x * y * c - z * stheta , x * z * c + y * stheta , y * x * c + z * stheta , ctheta + y * y * c , y * z * c - x * stheta , z * x * c - y * stheta , z * y * c + x * stheta , ctheta + z * z * c ; return R ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > axis2rpy ( const Eigen :: MatrixBase < Derived > & a ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; return quat2rpy ( axis2quat ( a ) ) ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > rotmat2axis ( const Eigen :: MatrixBase < Derived > & R ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 , 3 ) ; typename Derived :: Scalar theta = std :: acos ( ( R . trace ( ) - 1.0 ) / 2.0 ) ; Vector4d a ; if ( theta > std :: numeric_limits < typename Derived :: Scalar > :: epsilon ( ) ) { a << R ( 2 , 1 ) - R ( 1 , 2 ) , R ( 0 , 2 ) - R ( 2 , 0 ) , R ( 1 , 0 ) - R ( 0 , 1 ) , theta ; a . head < 3 > ( ) *= 1.0 / ( 2.0 * std :: sin ( theta ) ) ; } else { a << 1.0 , 0.0 , 0.0 , 0.0 ; } return a ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > rotmat2quat ( const Eigen :: MatrixBase < Derived > & M ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 , 3 ) ; using namespace std ; Matrix < typename Derived :: Scalar , 4 , 3 > A ; A . row ( 0 ) << 1.0 , 1.0 , 1.0 ; A . row ( 1 ) << 1.0 , - 1.0 , - 1.0 ; A . row ( 2 ) << - 1.0 , 1.0 , - 1.0 ; A . row ( 3 ) << - 1.0 , - 1.0 , 1.0 ; Matrix < typename Derived :: Scalar , 4 , 1 > B = A * M . diagonal ( ) ; typename Matrix < typename Derived :: Scalar , 4 , 1 > :: Index ind , max_col ; typename Derived :: Scalar val = B . maxCoeff ( & ind , & max_col ) ; typename Derived :: Scalar w , x , y , z ; switch ( ind ) { case 0 : { w = sqrt ( 1.0 + val ) / 2.0 ; typename Derived :: Scalar w4 = w * 4.0 ; x = ( M ( 2 , 1 ) - M ( 1 , 2 ) ) / w4 ; y = ( M ( 0 , 2 ) - M ( 2 , 0 ) ) / w4 ; z = ( M ( 1 , 0 ) - M ( 0 , 1 ) ) / w4 ; break ; } case 1 : { double s = 2.0 * sqrt ( 1.0 + val ) ; w = ( M ( 2 , 1 ) - M ( 1 , 2 ) ) / s ; x = 0.25 * s ; y = ( M ( 0 , 1 ) + M ( 1 , 0 ) ) / s ; z = ( M ( 0 , 2 ) + M ( 2 , 0 ) ) / s ; break ; } case 2 : { double s = 2.0 * ( sqrt ( 1.0 + val ) ) ; w = ( M ( 0 , 2 ) - M ( 2 , 0 ) ) / s ; x = ( M ( 0 , 1 ) + M ( 1 , 0 ) ) / s ; y = 0.25 * s ; z = ( M ( 1 , 2 ) + M ( 2 , 1 ) ) / s ; break ; } default : { double s = 2.0 * ( sqrt ( 1.0 + val ) ) ; w = ( M ( 1 , 0 ) - M ( 0 , 1 ) ) / s ; x = ( M ( 0 , 2 ) + M ( 2 , 0 ) ) / s ; y = ( M ( 1 , 2 ) + M ( 2 , 1 ) ) / s ; z = 0.25 * s ; break ; } } Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > q ; q << w , x , y , z ; return q ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > rotmat2rpy ( const Eigen :: MatrixBase < Derived > & R ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 , 3 ) ; using namespace std ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > rpy ; rpy << atan2 ( R ( 2 , 1 ) , R ( 2 , 2 ) ) , atan2 ( - R ( 2 , 0 ) , sqrt ( pow ( R ( 2 , 1 ) , 2.0 ) + pow ( R ( 2 , 2 ) , 2.0 ) ) ) , atan2 ( R ( 1 , 0 ) , R ( 0 , 0 ) ) ; return rpy ; }
template < typename Derived > DLLEXPORT Eigen :: Matrix < typename Derived :: Scalar , Eigen :: Dynamic , 1 > rotmat2Representation ( const Eigen :: MatrixBase < Derived > & R , int rotation_type ) { typedef typename Derived :: Scalar Scalar ; Eigen :: Matrix < Scalar , Eigen :: Dynamic , 1 > ret ; switch ( rotation_type ) { case 0 : return Eigen :: Matrix < Scalar , Eigen :: Dynamic , 1 > ( 0 , 1 ) ; case 1 : return rotmat2rpy ( R ) ; case 2 : return rotmat2quat ( R ) ; default : throw std :: runtime_error ( " rotation ▁ representation ▁ type ▁ not ▁ recognized " ) ; } }
template < typename Scalar > DLLEXPORT GradientVar < Scalar , Eigen :: Dynamic , 1 > rotmat2Representation ( const GradientVar < Scalar , SPACE_DIMENSION , SPACE_DIMENSION > & R , int rotation_type ) { GradientVar < Scalar , Eigen :: Dynamic , 1 > ret ( rotationRepresentationSize ( rotation_type ) , 1 , R . getNumVariables ( ) , R . maxOrder ( ) ) ; switch ( rotation_type ) { case 0 : break ; case 1 : ret . value ( ) = rotmat2rpy ( R . value ( ) ) ; if ( R . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = drotmat2rpy ( R . value ( ) , R . gradient ( ) . value ( ) ) ; } break ; case 2 : ret . value ( ) = rotmat2quat ( R . value ( ) ) ; if ( R . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = drotmat2quat ( R . value ( ) , R . gradient ( ) . value ( ) ) ; } break ; default : throw std :: runtime_error ( " rotation ▁ representation ▁ type ▁ not ▁ recognized " ) ; } return ret ; }
template < typename Derived > GradientVar < typename Derived :: Scalar , QUAT_SIZE , 1 > expmap2quat ( const Eigen :: MatrixBase < Derived > & v , const int gradient_order ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 ) ; GradientVar < typename Derived :: Scalar , QUAT_SIZE , 1 > ret ( QUAT_SIZE , 1 , EXPMAP_SIZE , gradient_order ) ; auto theta = v . norm ( ) ; if ( theta < pow ( std :: numeric_limits < typename Derived :: Scalar > :: epsilon ( ) , 0.25 ) ) { ret . value ( ) = expmap2quatDegenerate ( v , theta ) ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = dexpmap2quatDegenerate ( v , theta ) ; if ( gradient_order > 1 ) { ret . gradient ( ) . gradient ( ) . value ( ) = ddexpmap2quatDegenerate ( v , theta ) ; if ( gradient_order > 2 ) { throw std :: runtime_error ( " expmap2quat ▁ does ▁ not ▁ support ▁ gradient ▁ order ▁ larger ▁ than ▁ 2" ) ; } } } } else { ret . value ( ) = expmap2quatNonDegenerate ( v , theta ) ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = dexpmap2quatNonDegenerate ( v , theta ) ; if ( gradient_order > 1 ) { ret . gradient ( ) . gradient ( ) . value ( ) = ddexpmap2quatNonDegenerate ( v , theta ) ; if ( gradient_order > 2 ) { throw std :: runtime_error ( " expmap2quat ▁ does ▁ not ▁ support ▁ gradient ▁ order ▁ larger ▁ than ▁ 2" ) ; } } } } return ret ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > rpy2axis ( const Eigen :: MatrixBase < Derived > & rpy ) { return quat2axis ( rpy2quat ( rpy ) ) ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > rpy2quat ( const Eigen :: MatrixBase < Derived > & rpy ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 ) ; auto rpy_2 = ( rpy / 2.0 ) . array ( ) ; auto s = rpy_2 . sin ( ) ; auto c = rpy_2 . cos ( ) ; Vector4d q ; q << c ( 0 ) * c ( 1 ) * c ( 2 ) + s ( 0 ) * s ( 1 ) * s ( 2 ) , s ( 0 ) * c ( 1 ) * c ( 2 ) - c ( 0 ) * s ( 1 ) * s ( 2 ) , c ( 0 ) * s ( 1 ) * c ( 2 ) + s ( 0 ) * c ( 1 ) * s ( 2 ) , c ( 0 ) * c ( 1 ) * s ( 2 ) - s ( 0 ) * s ( 1 ) * c ( 2 ) ; q /= q . norm ( ) + std :: numeric_limits < typename Derived :: Scalar > :: epsilon ( ) ; return q ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > rpy2rotmat ( const Eigen :: MatrixBase < Derived > & rpy ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 ) ; auto rpy_array = rpy . array ( ) ; auto s = rpy_array . sin ( ) ; auto c = rpy_array . cos ( ) ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > R ; R . row ( 0 ) << c ( 2 ) * c ( 1 ) , c ( 2 ) * s ( 1 ) * s ( 0 ) - s ( 2 ) * c ( 0 ) , c ( 2 ) * s ( 1 ) * c ( 0 ) + s ( 2 ) * s ( 0 ) ; R . row ( 1 ) << s ( 2 ) * c ( 1 ) , s ( 2 ) * s ( 1 ) * s ( 0 ) + c ( 2 ) * c ( 0 ) , s ( 2 ) * s ( 1 ) * c ( 0 ) - c ( 2 ) * s ( 0 ) ; R . row ( 2 ) << - s ( 1 ) , c ( 1 ) * s ( 0 ) , c ( 1 ) * c ( 0 ) ; return R ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 9 , 3 > drpy2rotmat ( const Eigen :: MatrixBase < Derived > & rpy ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 ) ; auto rpy_array = rpy . array ( ) ; auto s = rpy_array . sin ( ) ; auto c = rpy_array . cos ( ) ; Eigen :: Matrix < typename Derived :: Scalar , 9 , 3 > dR ; dR . row ( 0 ) << 0 , c ( 2 ) * - s ( 1 ) , c ( 1 ) * - s ( 2 ) ; dR . row ( 1 ) << 0 , - s ( 1 ) * s ( 2 ) , c ( 2 ) * c ( 1 ) ; dR . row ( 2 ) << 0 , - c ( 1 ) , 0 ; dR . row ( 3 ) << c ( 2 ) * s ( 1 ) * c ( 0 ) - s ( 2 ) * - s ( 0 ) , c ( 2 ) * c ( 1 ) * s ( 0 ) , - s ( 2 ) * s ( 1 ) * s ( 0 ) - c ( 2 ) * c ( 0 ) ; dR . row ( 4 ) << s ( 2 ) * s ( 1 ) * c ( 0 ) + c ( 2 ) * - s ( 0 ) , s ( 2 ) * c ( 1 ) * s ( 0 ) , c ( 2 ) * s ( 1 ) * s ( 0 ) - s ( 2 ) * c ( 0 ) ; dR . row ( 5 ) << c ( 1 ) * c ( 0 ) , - s ( 1 ) * s ( 0 ) , 0 ; dR . row ( 6 ) << c ( 2 ) * s ( 1 ) * - s ( 0 ) + s ( 2 ) * c ( 0 ) , c ( 2 ) * c ( 1 ) * c ( 0 ) , - s ( 2 ) * s ( 1 ) * c ( 0 ) + c ( 2 ) * s ( 0 ) ; dR . row ( 7 ) << s ( 2 ) * s ( 1 ) * - s ( 0 ) - c ( 2 ) * c ( 0 ) , s ( 2 ) * c ( 1 ) * c ( 0 ) , c ( 2 ) * s ( 1 ) * c ( 0 ) + s ( 2 ) * s ( 0 ) ; dR . row ( 8 ) << c ( 1 ) * - s ( 0 ) , - s ( 1 ) * c ( 0 ) , 0 ; return dR ; }
template < typename Derived > typename Gradient < Matrix < typename Derived :: Scalar , 3 , 3 > , QUAT_SIZE > :: type dquat2rotmat ( const Eigen :: MatrixBase < Derived > & q ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , QUAT_SIZE ) ; typename Gradient < Matrix < typename Derived :: Scalar , 3 , 3 > , QUAT_SIZE > :: type ret ; typename Eigen :: MatrixBase < Derived > :: PlainObject qtilde ; typename Gradient < Derived , QUAT_SIZE > :: type dqtilde ; normalizeVec ( q , qtilde , & dqtilde ) ; typedef typename Derived :: Scalar Scalar ; Scalar w = qtilde ( 0 ) ; Scalar x = qtilde ( 1 ) ; Scalar y = qtilde ( 2 ) ; Scalar z = qtilde ( 3 ) ; ret << w , x , - y , - z , z , y , x , w , - y , z , - w , x , - z , y , x , - w , w , - x , y , - z , x , w , z , y , y , z , w , x , - x , - w , z , y , w , - x , - y , z ; ret *= 2.0 ; ret *= dqtilde ; return ret ; }
template < typename DerivedR , typename DerivedDR > typename Gradient < Eigen :: Matrix < typename DerivedR :: Scalar , RPY_SIZE , 1 > , DerivedDR :: ColsAtCompileTime > :: type drotmat2rpy ( const Eigen :: MatrixBase < DerivedR > & R , const Eigen :: MatrixBase < DerivedDR > & dR ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedR > , SPACE_DIMENSION , SPACE_DIMENSION ) ; EIGEN_STATIC_ASSERT ( Eigen :: MatrixBase < DerivedDR > :: RowsAtCompileTime == RotmatSize , THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE ) ; typename DerivedDR :: Index nq = dR . cols ( ) ; typedef typename DerivedR :: Scalar Scalar ; typedef typename Gradient < Eigen :: Matrix < Scalar , RPY_SIZE , 1 > , DerivedDR :: ColsAtCompileTime > :: type ReturnType ; ReturnType drpy ( RPY_SIZE , nq ) ; auto dR11_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 0 , 0 , R . rows ( ) ) ; auto dR21_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 1 , 0 , R . rows ( ) ) ; auto dR31_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 0 , R . rows ( ) ) ; auto dR32_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 1 , R . rows ( ) ) ; auto dR33_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 2 , R . rows ( ) ) ; Scalar sqterm = R ( 2 , 1 ) * R ( 2 , 1 ) + R ( 2 , 2 ) * R ( 2 , 2 ) ; using namespace std ; drpy . row ( 0 ) = ( R ( 2 , 2 ) * dR32_dq - R ( 2 , 1 ) * dR33_dq ) / sqterm ; Scalar sqrt_sqterm = sqrt ( sqterm ) ; drpy . row ( 1 ) = ( - sqrt_sqterm * dR31_dq + R ( 2 , 0 ) / sqrt_sqterm * ( R ( 2 , 1 ) * dR32_dq + R ( 2 , 2 ) * dR33_dq ) ) / ( R ( 2 , 0 ) * R ( 2 , 0 ) + R ( 2 , 1 ) * R ( 2 , 1 ) + R ( 2 , 2 ) * R ( 2 , 2 ) ) ; sqterm = R ( 0 , 0 ) * R ( 0 , 0 ) + R ( 1 , 0 ) * R ( 1 , 0 ) ; drpy . row ( 2 ) = ( R ( 0 , 0 ) * dR21_dq - R ( 1 , 0 ) * dR11_dq ) / sqterm ; return drpy ; }
template < typename DerivedR , typename DerivedDR > typename Gradient < Eigen :: Matrix < typename DerivedR :: Scalar , QUAT_SIZE , 1 > , DerivedDR :: ColsAtCompileTime > :: type drotmat2quat ( const Eigen :: MatrixBase < DerivedR > & R , const Eigen :: MatrixBase < DerivedDR > & dR ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedR > , SPACE_DIMENSION , SPACE_DIMENSION ) ; EIGEN_STATIC_ASSERT ( Eigen :: MatrixBase < DerivedDR > :: RowsAtCompileTime == RotmatSize , THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE ) ; typedef typename DerivedR :: Scalar Scalar ; typedef typename Gradient < Eigen :: Matrix < Scalar , QUAT_SIZE , 1 > , DerivedDR :: ColsAtCompileTime > :: type ReturnType ; typename DerivedDR :: Index nq = dR . cols ( ) ; auto dR11_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 0 , 0 , R . rows ( ) ) ; auto dR12_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 0 , 1 , R . rows ( ) ) ; auto dR13_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 0 , 2 , R . rows ( ) ) ; auto dR21_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 1 , 0 , R . rows ( ) ) ; auto dR22_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 1 , 1 , R . rows ( ) ) ; auto dR23_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 1 , 2 , R . rows ( ) ) ; auto dR31_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 0 , R . rows ( ) ) ; auto dR32_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 1 , R . rows ( ) ) ; auto dR33_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 2 , R . rows ( ) ) ; Matrix < Scalar , 4 , 3 > A ; A . row ( 0 ) << 1.0 , 1.0 , 1.0 ; A . row ( 1 ) << 1.0 , - 1.0 , - 1.0 ; A . row ( 2 ) << - 1.0 , 1.0 , - 1.0 ; A . row ( 3 ) << - 1.0 , - 1.0 , 1.0 ; Matrix < Scalar , 4 , 1 > B = A * R . diagonal ( ) ; typename Matrix < Scalar , 4 , 1 > :: Index ind , max_col ; Scalar val = B . maxCoeff ( & ind , & max_col ) ; ReturnType dq ( QUAT_SIZE , nq ) ; using namespace std ; switch ( ind ) { case 0 : { auto dvaldq = dR11_dq + dR22_dq + dR33_dq ; auto dwdq = dvaldq / ( 4.0 * sqrt ( 1.0 + val ) ) ; auto w = sqrt ( 1.0 + val ) / 2.0 ; auto wsquare4 = 4.0 * w * w ; dq . row ( 0 ) = dwdq ; dq . row ( 1 ) = ( ( dR32_dq - dR23_dq ) * w - ( R ( 2 , 1 ) - R ( 1 , 2 ) ) * dwdq ) / wsquare4 ; dq . row ( 2 ) = ( ( dR13_dq - dR31_dq ) * w - ( R ( 0 , 2 ) - R ( 2 , 0 ) ) * dwdq ) / wsquare4 ; dq . row ( 3 ) = ( ( dR21_dq - dR12_dq ) * w - ( R ( 1 , 0 ) - R ( 0 , 1 ) ) * dwdq ) / wsquare4 ; break ; } case 1 : { auto dvaldq = dR11_dq - dR22_dq - dR33_dq ; auto s = 2.0 * sqrt ( 1.0 + val ) ; auto ssquare = s * s ; auto dsdq = dvaldq / sqrt ( 1.0 + val ) ; dq . row ( 0 ) = ( ( dR32_dq - dR23_dq ) * s - ( R ( 2 , 1 ) - R ( 1 , 2 ) ) * dsdq ) / ssquare ; dq . row ( 1 ) = .25 * dsdq ; dq . row ( 2 ) = ( ( dR12_dq + dR21_dq ) * s - ( R ( 0 , 1 ) + R ( 1 , 0 ) ) * dsdq ) / ssquare ; dq . row ( 3 ) = ( ( dR13_dq + dR31_dq ) * s - ( R ( 0 , 2 ) + R ( 2 , 0 ) ) * dsdq ) / ssquare ; break ; } case 2 : { auto dvaldq = - dR11_dq + dR22_dq - dR33_dq ; auto s = 2.0 * ( sqrt ( 1.0 + val ) ) ; auto ssquare = s * s ; auto dsdq = dvaldq / sqrt ( 1.0 + val ) ; dq . row ( 0 ) = ( ( dR13_dq - dR31_dq ) * s - ( R ( 0 , 2 ) - R ( 2 , 0 ) ) * dsdq ) / ssquare ; dq . row ( 1 ) = ( ( dR12_dq + dR21_dq ) * s - ( R ( 0 , 1 ) + R ( 1 , 0 ) ) * dsdq ) / ssquare ; dq . row ( 2 ) = .25 * dsdq ; dq . row ( 3 ) = ( ( dR23_dq + dR32_dq ) * s - ( R ( 1 , 2 ) + R ( 2 , 1 ) ) * dsdq ) / ssquare ; break ; } default : { auto dvaldq = - dR11_dq - dR22_dq + dR33_dq ; auto s = 2.0 * ( sqrt ( 1.0 + val ) ) ; auto ssquare = s * s ; auto dsdq = dvaldq / sqrt ( 1.0 + val ) ; dq . row ( 0 ) = ( ( dR21_dq - dR12_dq ) * s - ( R ( 1 , 0 ) - R ( 0 , 1 ) ) * dsdq ) / ssquare ; dq . row ( 1 ) = ( ( dR13_dq + dR31_dq ) * s - ( R ( 0 , 2 ) + R ( 2 , 0 ) ) * dsdq ) / ssquare ; dq . row ( 2 ) = ( ( dR23_dq + dR32_dq ) * s - ( R ( 1 , 2 ) + R ( 2 , 1 ) ) * dsdq ) / ssquare ; dq . row ( 3 ) = .25 * dsdq ; break ; } } return dq ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > vectorToSkewSymmetric ( const Eigen :: MatrixBase < Derived > & p ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , SPACE_DIMENSION ) ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > ret ; ret << 0.0 , - p ( 2 ) , p ( 1 ) , p ( 2 ) , 0.0 , - p ( 0 ) , - p ( 1 ) , p ( 0 ) , 0.0 ; return ret ; }
template < typename DerivedA , typename DerivedB > Eigen :: Matrix < typename DerivedA :: Scalar , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b , const typename Gradient < DerivedA , Eigen :: Dynamic > :: type & da , const typename Gradient < DerivedB , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename DerivedA :: Scalar , 3 , Eigen :: Dynamic > ret ( 3 , da . cols ( ) ) ; ret . noalias ( ) = da . colwise ( ) . cross ( b ) ; ret . noalias ( ) -= db . colwise ( ) . cross ( a ) ; return ret ; }
template < typename Derived > DLLEXPORT GradientVar < typename Derived :: Scalar , Eigen :: Dynamic , SPACE_DIMENSION > angularvel2RepresentationDotMatrix ( int rotation_type , const Eigen :: MatrixBase < Derived > & qrot , int gradient_order ) { GradientVar < typename Derived :: Scalar , Eigen :: Dynamic , SPACE_DIMENSION > ret ( qrot . rows ( ) , SPACE_DIMENSION , qrot . rows ( ) , gradient_order ) ; switch ( rotation_type ) { case 0 : break ; case 1 : { if ( gradient_order > 1 ) { angularvel2rpydotMatrix ( qrot , ret . value ( ) , & ret . gradient ( ) . value ( ) , & ret . gradient ( ) . gradient ( ) . value ( ) ) ; } else if ( gradient_order > 0 ) { angularvel2rpydotMatrix ( qrot , ret . value ( ) , & ret . gradient ( ) . value ( ) , ( MatrixXd * ) nullptr ) ; } else { angularvel2rpydotMatrix ( qrot , ret . value ( ) , ( MatrixXd * ) nullptr , ( MatrixXd * ) nullptr ) ; } break ; } case 2 : { if ( gradient_order > 1 ) { ret . gradient ( ) . gradient ( ) . value ( ) . setZero ( ) ; } if ( gradient_order > 0 ) { angularvel2quatdotMatrix ( qrot , ret . value ( ) , & ret . gradient ( ) . value ( ) ) ; } else { angularvel2quatdotMatrix ( qrot , ret . value ( ) , ( MatrixXd * ) nullptr ) ; } break ; } default : throw std :: runtime_error ( " rotation ▁ representation ▁ type ▁ not ▁ recognized " ) ; } return ret ; }
template < typename DerivedM > typename TransformSpatial < DerivedM > :: type transformSpatialMotion ( const Eigen :: Transform < typename DerivedM :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedM > & M ) { Eigen :: Matrix < typename DerivedM :: Scalar , TWIST_SIZE , DerivedM :: ColsAtCompileTime > ret ( TWIST_SIZE , M . cols ( ) ) ; ret . template topRows < 3 > ( ) . noalias ( ) = T . linear ( ) * M . template topRows < 3 > ( ) ; ret . template bottomRows < 3 > ( ) . noalias ( ) = - ret . template topRows < 3 > ( ) . colwise ( ) . cross ( T . translation ( ) ) ; ret . template bottomRows < 3 > ( ) . noalias ( ) += T . linear ( ) * M . template bottomRows < 3 > ( ) ; return ret ; }
template < typename DerivedF > typename TransformSpatial < DerivedF > :: type transformSpatialForce ( const Eigen :: Transform < typename DerivedF :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedF > & F ) { Eigen :: Matrix < typename DerivedF :: Scalar , TWIST_SIZE , DerivedF :: ColsAtCompileTime > ret ( TWIST_SIZE , F . cols ( ) ) ; ret . template bottomRows < 3 > ( ) . noalias ( ) = T . linear ( ) * F . template bottomRows < 3 > ( ) . eval ( ) ; ret . template topRows < 3 > ( ) = - ret . template bottomRows < 3 > ( ) . colwise ( ) . cross ( T . translation ( ) ) ; ret . template topRows < 3 > ( ) . noalias ( ) += T . linear ( ) * F . template topRows < 3 > ( ) ; return ret ; }
template < typename DerivedI > GradientVar < typename DerivedI :: Scalar , TWIST_SIZE , TWIST_SIZE > transformSpatialInertia ( const Eigen :: Transform < typename DerivedI :: Scalar , SPACE_DIMENSION , Eigen :: Isometry > & T_current_to_new , const typename Gradient < typename Eigen :: Transform < typename DerivedI :: Scalar , SPACE_DIMENSION , Eigen :: Isometry > :: MatrixType , Eigen :: Dynamic > :: type * dT_current_to_new , const Eigen :: MatrixBase < DerivedI > & I ) { int gradient_order ; typename DerivedI :: Index nq ; if ( dT_current_to_new ) { gradient_order = 1 ; nq = dT_current_to_new -> cols ( ) ; } else { nq = 0 ; gradient_order = 0 ; } GradientVar < typename DerivedI :: Scalar , TWIST_SIZE , TWIST_SIZE > ret ( TWIST_SIZE , TWIST_SIZE , nq , gradient_order ) ; auto I_half_transformed = transformSpatialForce ( T_current_to_new , I ) ; ret . value ( ) = transformSpatialForce ( T_current_to_new , I_half_transformed . transpose ( ) ) ; if ( gradient_order > 0 ) { auto dI = Eigen :: Matrix < typename DerivedI :: Scalar , DerivedI :: SizeAtCompileTime , Eigen :: Dynamic > :: Zero ( I . size ( ) , nq ) . eval ( ) ; auto dI_half_transformed = dTransformSpatialForce ( T_current_to_new , I , * dT_current_to_new , dI ) ; auto dI_half_transformed_transpose = transposeGrad ( dI_half_transformed , I_half_transformed . rows ( ) ) ; ret . gradient ( ) . value ( ) = dTransformSpatialForce ( T_current_to_new , I_half_transformed . transpose ( ) , * dT_current_to_new , dI_half_transformed_transpose ) ; } return ret ; }
template < typename DerivedA , typename DerivedB > typename TransformSpatial < DerivedB > :: type crossSpatialMotion ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b ) { typename TransformSpatial < DerivedB > :: type ret ( TWIST_SIZE , b . cols ( ) ) ; ret . template topRows < 3 > ( ) = - b . template topRows < 3 > ( ) . colwise ( ) . cross ( a . template topRows < 3 > ( ) ) ; ret . template bottomRows < 3 > ( ) = - b . template topRows < 3 > ( ) . colwise ( ) . cross ( a . template bottomRows < 3 > ( ) ) ; ret . template bottomRows < 3 > ( ) -= b . template bottomRows < 3 > ( ) . colwise ( ) . cross ( a . template topRows < 3 > ( ) ) ; return ret ; }
template < typename DerivedA , typename DerivedB > typename TransformSpatial < DerivedB > :: type crossSpatialForce ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b ) { typename TransformSpatial < DerivedB > :: type ret ( TWIST_SIZE , b . cols ( ) ) ; ret . template topRows < 3 > ( ) = - b . template topRows < 3 > ( ) . colwise ( ) . cross ( a . template topRows < 3 > ( ) ) ; ret . template topRows < 3 > ( ) -= b . template bottomRows < 3 > ( ) . colwise ( ) . cross ( a . template bottomRows < 3 > ( ) ) ; ret . template bottomRows < 3 > ( ) = - b . template bottomRows < 3 > ( ) . colwise ( ) . cross ( a . template topRows < 3 > ( ) ) ; return ret ; }
template < typename DerivedA , typename DerivedB > Eigen :: Matrix < typename DerivedA :: Scalar , TWIST_SIZE , Eigen :: Dynamic > dCrossSpatialMotion ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b , const typename Gradient < DerivedA , Eigen :: Dynamic > :: type & da , const typename Gradient < DerivedB , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename DerivedA :: Scalar , TWIST_SIZE , Eigen :: Dynamic > ret ( TWIST_SIZE , da . cols ( ) ) ; ret . row ( 0 ) = - da . row ( 2 ) * b [ 1 ] + da . row ( 1 ) * b [ 2 ] - a [ 2 ] * db . row ( 1 ) + a [ 1 ] * db . row ( 2 ) ; ret . row ( 1 ) = da . row ( 2 ) * b [ 0 ] - da . row ( 0 ) * b [ 2 ] + a [ 2 ] * db . row ( 0 ) - a [ 0 ] * db . row ( 2 ) ; ret . row ( 2 ) = - da . row ( 1 ) * b [ 0 ] + da . row ( 0 ) * b [ 1 ] - a [ 1 ] * db . row ( 0 ) + a [ 0 ] * db . row ( 1 ) ; ret . row ( 3 ) = - da . row ( 5 ) * b [ 1 ] + da . row ( 4 ) * b [ 2 ] - da . row ( 2 ) * b [ 4 ] + da . row ( 1 ) * b [ 5 ] - a [ 5 ] * db . row ( 1 ) + a [ 4 ] * db . row ( 2 ) - a [ 2 ] * db . row ( 4 ) + a [ 1 ] * db . row ( 5 ) ; ret . row ( 4 ) = da . row ( 5 ) * b [ 0 ] - da . row ( 3 ) * b [ 2 ] + da . row ( 2 ) * b [ 3 ] - da . row ( 0 ) * b [ 5 ] + a [ 5 ] * db . row ( 0 ) - a [ 3 ] * db . row ( 2 ) + a [ 2 ] * db . row ( 3 ) - a [ 0 ] * db . row ( 5 ) ; ret . row ( 5 ) = - da . row ( 4 ) * b [ 0 ] + da . row ( 3 ) * b [ 1 ] - da . row ( 1 ) * b [ 3 ] + da . row ( 0 ) * b [ 4 ] - a [ 4 ] * db . row ( 0 ) + a [ 3 ] * db . row ( 1 ) - a [ 1 ] * db . row ( 3 ) + a [ 0 ] * db . row ( 4 ) ; return ret ; }
template < typename DerivedA , typename DerivedB > Eigen :: Matrix < typename DerivedA :: Scalar , TWIST_SIZE , Eigen :: Dynamic > dCrossSpatialForce ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b , const typename Gradient < DerivedA , Eigen :: Dynamic > :: type & da , const typename Gradient < DerivedB , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename DerivedA :: Scalar , TWIST_SIZE , Eigen :: Dynamic > ret ( TWIST_SIZE , da . cols ( ) ) ; ret . row ( 0 ) = da . row ( 2 ) * b [ 1 ] - da . row ( 1 ) * b [ 2 ] + da . row ( 5 ) * b [ 4 ] - da . row ( 4 ) * b [ 5 ] + a [ 2 ] * db . row ( 1 ) - a [ 1 ] * db . row ( 2 ) + a [ 5 ] * db . row ( 4 ) - a [ 4 ] * db . row ( 5 ) ; ret . row ( 1 ) = - da . row ( 2 ) * b [ 0 ] + da . row ( 0 ) * b [ 2 ] - da . row ( 5 ) * b [ 3 ] + da . row ( 3 ) * b [ 5 ] - a [ 2 ] * db . row ( 0 ) + a [ 0 ] * db . row ( 2 ) - a [ 5 ] * db . row ( 3 ) + a [ 3 ] * db . row ( 5 ) ; ret . row ( 2 ) = da . row ( 1 ) * b [ 0 ] - da . row ( 0 ) * b [ 1 ] + da . row ( 4 ) * b [ 3 ] - da . row ( 3 ) * b [ 4 ] + a [ 1 ] * db . row ( 0 ) - a [ 0 ] * db . row ( 1 ) + a [ 4 ] * db . row ( 3 ) - a [ 3 ] * db . row ( 4 ) ; ret . row ( 3 ) = da . row ( 2 ) * b [ 4 ] - da . row ( 1 ) * b [ 5 ] + a [ 2 ] * db . row ( 4 ) - a [ 1 ] * db . row ( 5 ) ; ret . row ( 4 ) = - da . row ( 2 ) * b [ 3 ] + da . row ( 0 ) * b [ 5 ] - a [ 2 ] * db . row ( 3 ) + a [ 0 ] * db . row ( 5 ) ; ret . row ( 5 ) = da . row ( 1 ) * b [ 3 ] - da . row ( 0 ) * b [ 4 ] + a [ 1 ] * db . row ( 3 ) - a [ 0 ] * db . row ( 4 ) ; ret = - ret ; return ret ; }
template < typename DerivedS , typename DerivedQdotToV > typename DHomogTrans < DerivedQdotToV > :: type dHomogTrans ( const Eigen :: Transform < typename DerivedQdotToV :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedS > & S , const Eigen :: MatrixBase < DerivedQdotToV > & qdot_to_v ) { const int nq_at_compile_time = DerivedQdotToV :: ColsAtCompileTime ; typename DerivedQdotToV :: Index nq = qdot_to_v . cols ( ) ; auto qdot_to_twist = ( S * qdot_to_v ) . eval ( ) ; const int numel = HOMOGENEOUS_TRANSFORM_SIZE ; Eigen :: Matrix < typename DerivedQdotToV :: Scalar , numel , nq_at_compile_time > ret ( numel , nq ) ; const auto & Rx = T . linear ( ) . col ( 0 ) ; const auto & Ry = T . linear ( ) . col ( 1 ) ; const auto & Rz = T . linear ( ) . col ( 2 ) ; const auto & qdot_to_omega_x = qdot_to_twist . row ( 0 ) ; const auto & qdot_to_omega_y = qdot_to_twist . row ( 1 ) ; const auto & qdot_to_omega_z = qdot_to_twist . row ( 2 ) ; ret . template middleRows < 3 > ( 0 ) = - Rz * qdot_to_omega_y + Ry * qdot_to_omega_z ; ret . row ( 3 ) . setZero ( ) ; ret . template middleRows < 3 > ( 4 ) = Rz * qdot_to_omega_x - Rx * qdot_to_omega_z ; ret . row ( 7 ) . setZero ( ) ; ret . template middleRows < 3 > ( 8 ) = - Ry * qdot_to_omega_x + Rx * qdot_to_omega_y ; ret . row ( 11 ) . setZero ( ) ; ret . template middleRows < 3 > ( 12 ) = T . linear ( ) * qdot_to_twist . bottomRows ( 3 ) ; ret . row ( 15 ) . setZero ( ) ; return ret ; }
template < typename DerivedDT > typename DHomogTrans < DerivedDT > :: type dHomogTransInv ( const Eigen :: Transform < typename DerivedDT :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedDT > & dT ) { typename DerivedDT :: Index nq = dT . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_cols = { 3 } ; auto dR = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , R_cols , T . Rows ) ; auto dp = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , p_cols , T . Rows ) ; auto dinvT_R = transposeGrad ( dR , R . rows ( ) ) ; auto dinvT_p = ( - R . transpose ( ) * dp - matGradMult ( dinvT_R , p ) ) . eval ( ) ; const int numel = HOMOGENEOUS_TRANSFORM_SIZE ; Eigen :: Matrix < typename DerivedDT :: Scalar , numel , DerivedDT :: ColsAtCompileTime > ret ( numel , nq ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , dinvT_R , rows , R_cols , T . Rows ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , dinvT_p , rows , p_cols , T . Rows ) ; const int last_row = 3 ; for ( int col = 0 ; col < T . HDim ; col ++ ) { ret . row ( last_row + col * T . Rows ) . setZero ( ) ; } return ret ; }
template < typename Scalar , typename DerivedX , typename DerivedDT , typename DerivedDX > typename Gradient < DerivedX , DerivedDX :: ColsAtCompileTime , 1 > :: type dTransformSpatialMotion ( const Eigen :: Transform < Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedX > & X , const Eigen :: MatrixBase < DerivedDT > & dT , const Eigen :: MatrixBase < DerivedDX > & dX ) { assert ( dT . cols ( ) == dX . cols ( ) ) ; typename DerivedDT :: Index nq = dT . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_cols = { 3 } ; auto dR = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , R_cols , T . Rows ) ; auto dp = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , p_cols , T . Rows ) ; typename Gradient < DerivedX , DerivedDX :: ColsAtCompileTime , 1 > :: type ret ( X . size ( ) , nq ) ; std :: array < int , 3 > Xomega_rows = { 0 , 1 , 2 } ; std :: array < int , 3 > Xv_rows = { 3 , 4 , 5 } ; for ( int col = 0 ; col < X . cols ( ) ; col ++ ) { auto Xomega_col = X . template block < 3 , 1 > ( 0 , col ) ; auto Xv_col = X . template block < 3 , 1 > ( 3 , col ) ; auto RXomega_col = ( R * Xomega_col ) . eval ( ) ; std :: array < int , 1 > col_array = { col } ; auto dXomega_col = getSubMatrixGradient < Eigen :: Dynamic > ( dX , Xomega_rows , col_array , X . rows ( ) ) ; auto dXv_col = getSubMatrixGradient < Eigen :: Dynamic > ( dX , Xv_rows , col_array , X . rows ( ) ) ; auto domega_part_col = ( R * dXomega_col + matGradMult ( dR , Xomega_col ) ) . eval ( ) ; auto dv_part_col = ( R * dXv_col + matGradMult ( dR , Xv_col ) ) . eval ( ) ; dv_part_col += dp . colwise ( ) . cross ( RXomega_col ) ; dv_part_col -= domega_part_col . colwise ( ) . cross ( p ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , domega_part_col , Xomega_rows , col_array , X . rows ( ) ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , dv_part_col , Xv_rows , col_array , X . rows ( ) ) ; } return ret ; }
template < typename Scalar , typename DerivedX , typename DerivedDT , typename DerivedDX > typename Gradient < DerivedX , DerivedDX :: ColsAtCompileTime > :: type dTransformSpatialForce ( const Eigen :: Transform < Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedX > & X , const Eigen :: MatrixBase < DerivedDT > & dT , const Eigen :: MatrixBase < DerivedDX > & dX ) { assert ( dT . cols ( ) == dX . cols ( ) ) ; typename DerivedDT :: Index nq = dT . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_cols = { 3 } ; auto dR = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , R_cols , T . Rows ) ; auto dp = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , p_cols , T . Rows ) ; typename Gradient < DerivedX , DerivedDX :: ColsAtCompileTime > :: type ret ( X . size ( ) , nq ) ; std :: array < int , 3 > Xomega_rows = { 0 , 1 , 2 } ; std :: array < int , 3 > Xv_rows = { 3 , 4 , 5 } ; for ( int col = 0 ; col < X . cols ( ) ; col ++ ) { auto Xomega_col = X . template block < 3 , 1 > ( 0 , col ) ; auto Xv_col = X . template block < 3 , 1 > ( 3 , col ) ; auto RXv_col = ( R * Xv_col ) . eval ( ) ; std :: array < int , 1 > col_array = { col } ; auto dXomega_col = getSubMatrixGradient < Eigen :: Dynamic > ( dX , Xomega_rows , col_array , X . rows ( ) ) ; auto dXv_col = getSubMatrixGradient < Eigen :: Dynamic > ( dX , Xv_rows , col_array , X . rows ( ) ) ; auto domega_part_col = ( R * dXomega_col ) . eval ( ) ; domega_part_col += matGradMult ( dR , Xomega_col ) ; auto dv_part_col = ( R * dXv_col ) . eval ( ) ; dv_part_col += matGradMult ( dR , Xv_col ) ; domega_part_col += dp . colwise ( ) . cross ( RXv_col ) ; domega_part_col -= dv_part_col . colwise ( ) . cross ( p ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , domega_part_col , Xomega_rows , col_array , X . rows ( ) ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , dv_part_col , Xv_rows , col_array , X . rows ( ) ) ; } return ret ; }
