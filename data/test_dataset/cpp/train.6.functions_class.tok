b2StackAllocator :: b2StackAllocator ( ) { m_index = 0 ; m_allocation = 0 ; m_maxAllocation = 0 ; m_entryCount = 0 ; }
b2StackAllocator :: ~ b2StackAllocator ( ) { b2Assert ( m_index == 0 ) ; b2Assert ( m_entryCount == 0 ) ; }
void * b2StackAllocator :: Allocate ( int32 size ) { b2Assert ( m_entryCount < b2_maxStackEntries ) ; b2StackEntry * entry = m_entries + m_entryCount ; entry -> size = size ; if ( m_index + size > b2_stackSize ) { entry -> data = ( char * ) b2Alloc ( size ) ; entry -> usedMalloc = true ; } else { entry -> data = m_data + m_index ; entry -> usedMalloc = false ; m_index += size ; } m_allocation += size ; m_maxAllocation = b2Max ( m_maxAllocation , m_allocation ) ; ++ m_entryCount ; return entry -> data ; }
void b2StackAllocator :: Free ( void * p ) { b2Assert ( m_entryCount > 0 ) ; b2StackEntry * entry = m_entries + m_entryCount - 1 ; b2Assert ( p == entry -> data ) ; if ( entry -> usedMalloc ) { b2Free ( p ) ; } else { m_index -= entry -> size ; } m_allocation -= entry -> size ; -- m_entryCount ; p = NULL ; }
void ctkPluginGeneratorUiPlugin :: start ( ctkPluginContext * context ) { mainExtension = new ctkPluginGeneratorMainExtension ( ) ; ctkDictionary props ; props . insert ( ctkPluginConstants :: SERVICE_RANKING , 0 ) ; context -> registerService ( QStringList ( " ctkPluginGeneratorAbstractUiExtension " ) , mainExtension , props ) ; qDebug ( ) << " Registered ▁ Main ▁ Extension " ; }
void ctkPluginGeneratorUiPlugin :: stop ( ctkPluginContext * context ) { Q_UNUSED ( context ) delete mainExtension ; }
CGLContextEGL :: ~ CGLContextEGL ( ) { Destroy ( ) ; }
bool CGLContextEGL :: CreateDisplay ( EGLDisplay display , EGLint renderable_type , EGLint rendering_api ) { EGLint neglconfigs = 0 ; int major , minor ; EGLint surface_type = EGL_WINDOW_BIT ; if ( g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION || g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION ) surface_type |= EGL_SWAP_BEHAVIOR_PRESERVED_BIT ; EGLint attribs [ ] = { EGL_RED_SIZE , 8 , EGL_GREEN_SIZE , 8 , EGL_BLUE_SIZE , 8 , EGL_ALPHA_SIZE , 8 , EGL_DEPTH_SIZE , 16 , EGL_STENCIL_SIZE , 0 , EGL_SAMPLE_BUFFERS , 0 , EGL_SAMPLES , 0 , EGL_SURFACE_TYPE , surface_type , EGL_RENDERABLE_TYPE , renderable_type , EGL_NONE } ; if ( m_eglDisplay == EGL_NO_DISPLAY ) { m_eglDisplay = eglGetDisplay ( ( EGLNativeDisplayType ) display ) ; } if ( m_eglDisplay == EGL_NO_DISPLAY ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ get ▁ EGL ▁ display " ) ; return false ; } if ( ! eglInitialize ( m_eglDisplay , & major , & minor ) ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ initialize ▁ EGL ▁ display " ) ; return false ; } eglBindAPI ( rendering_api ) ; if ( ! eglChooseConfig ( m_eglDisplay , attribs , & m_eglConfig , 1 , & neglconfigs ) ) { CLog :: Log ( LOGERROR , " Failed ▁ to ▁ query ▁ number ▁ of ▁ EGL ▁ configs " ) ; return false ; } if ( neglconfigs <= 0 ) { CLog :: Log ( LOGERROR , " No ▁ suitable ▁ EGL ▁ configs ▁ found " ) ; return false ; } return true ; }
bool CGLContextEGL :: CreateContext ( ) { int client_version = 2 ; const EGLint context_attribs [ ] = { EGL_CONTEXT_CLIENT_VERSION , client_version , EGL_NONE } ; if ( m_eglContext == EGL_NO_CONTEXT ) { m_eglContext = eglCreateContext ( m_eglDisplay , m_eglConfig , EGL_NO_CONTEXT , context_attribs ) ; } if ( m_eglContext == EGL_NO_CONTEXT ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ create ▁ EGL ▁ context " ) ; return false ; } return true ; }
bool CGLContextEGL :: BindContext ( ) { if ( ! eglMakeCurrent ( m_eglDisplay , m_eglSurface , m_eglSurface , m_eglContext ) ) { CLog :: Log ( LOGERROR , " Failed ▁ to ▁ make ▁ context ▁ current ▁ % p ▁ % p ▁ % p " , m_eglDisplay , m_eglSurface , m_eglContext ) ; return false ; } return true ; }
bool CGLContextEGL :: SurfaceAttrib ( ) { if ( g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION || g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION ) { if ( ( m_eglDisplay == EGL_NO_DISPLAY ) || ( m_eglSurface == EGL_NO_SURFACE ) ) { return false ; } if ( ! eglSurfaceAttrib ( m_eglDisplay , m_eglSurface , EGL_SWAP_BEHAVIOR , EGL_BUFFER_PRESERVED ) ) { CLog :: Log ( LOGDEBUG , " % s : ▁ Could ▁ not ▁ set ▁ EGL _ SWAP _ BEHAVIOR " , __FUNCTION__ ) ; } } return true ; }
bool CGLContextEGL :: CreateSurface ( EGLNativeWindowType surface ) { m_eglSurface = eglCreateWindowSurface ( m_eglDisplay , m_eglConfig , surface , nullptr ) ; if ( m_eglSurface == EGL_NO_SURFACE ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ create ▁ EGL ▁ window ▁ surface ▁ % d " , eglGetError ( ) ) ; return false ; } return true ; }
void CGLContextEGL :: Destroy ( ) { if ( m_eglContext != EGL_NO_CONTEXT ) { eglDestroyContext ( m_eglDisplay , m_eglContext ) ; eglMakeCurrent ( m_eglDisplay , EGL_NO_SURFACE , EGL_NO_SURFACE , EGL_NO_CONTEXT ) ; m_eglContext = EGL_NO_CONTEXT ; } if ( m_eglSurface != EGL_NO_SURFACE ) { eglDestroySurface ( m_eglDisplay , m_eglSurface ) ; m_eglSurface = EGL_NO_SURFACE ; } if ( m_eglDisplay != EGL_NO_DISPLAY ) { eglTerminate ( m_eglDisplay ) ; m_eglDisplay = EGL_NO_DISPLAY ; } }
void CGLContextEGL :: Detach ( ) { if ( m_eglContext != EGL_NO_CONTEXT ) { eglMakeCurrent ( m_eglDisplay , EGL_NO_SURFACE , EGL_NO_SURFACE , EGL_NO_CONTEXT ) ; } if ( m_eglSurface != EGL_NO_SURFACE ) { eglDestroySurface ( m_eglDisplay , m_eglSurface ) ; m_eglSurface = EGL_NO_SURFACE ; } }
bool CGLContextEGL :: SetVSync ( bool enable ) { if ( ! eglSwapInterval ( m_eglDisplay , enable ) ) { return false ; } return true ; }
void CGLContextEGL :: SwapBuffers ( ) { if ( m_eglDisplay == EGL_NO_DISPLAY || m_eglSurface == EGL_NO_SURFACE ) { return ; } eglSwapBuffers ( m_eglDisplay , m_eglSurface ) ; }
AAnnihilator :: AAnnihilator ( const FObjectInitializer & ObjectInitializer ) : Super ( ObjectInitializer ) { static ConstructorHelpers :: FObjectFinder < USkeletalMesh > SkeletalMeshObject ( TEXT ( " SkeletalMesh ' / Game / VFX / sphere _ skeletal . sphere _ skeletal ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UStaticMesh > StaticMeshObject ( TEXT ( " StaticMesh ' / Game / Weapons / Ranged / Anni . Anni ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UStaticMesh > OffhandMeshObject ( TEXT ( " StaticMesh ' / Game / VFX / sphere . sphere ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UTexture2D > LargeIconObject ( TEXT ( " Texture2D ' / Game / Blueprints / Widgets / UI - Images / Icons _ Gear / WeaponIcon _ Annihilator . WeaponIcon _ Annihilator ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UTexture2D > SmallIconObject ( TEXT ( " Texture2D ' / Game / Blueprints / Widgets / UI - Images / Icons _ Gear / WeaponIcon _ Annihilator - small . WeaponIcon _ Annihilator - small ' " ) ) ; Name = EMasterGearList :: GL_Annihilator ; NameText = LOCTEXT ( " AnnihilatorName " , " Annihilator " ) ; Type = EMasterGearTypes :: GT_Ranged ; TypeText = LOCTEXT ( " AnnihilatorType " , " Ranged " ) ; Description = " An ▁ embodiment ▁ of ▁ the ▁ Ethereal ▁ Virtue : ▁ Wrath . " ; Price = 40000 ; MPCost = 0.0f ; ATK = 50.0f ; DEF = 40.0f ; SPD = 20.0f ; HP = 500.0f ; MP = 250.0f ; LargeIcon = LargeIconObject . Object ; SmallIcon = SmallIconObject . Object ; SK_WeaponSkeletalMesh = SkeletalMeshObject . Object ; SM_WeaponStaticMesh = StaticMeshObject . Object ; SM_WeaponOffhandMesh = StaticMeshObject . Object ; WeaponSkeletalMesh -> SetSkeletalMesh ( SK_WeaponSkeletalMesh ) ; WeaponSkeletalMesh -> SetHiddenInGame ( true ) ; WeaponStaticMesh -> SetStaticMesh ( SM_WeaponStaticMesh ) ; WeaponStaticMesh -> SetWorldScale3D ( FVector ( 0.15f , 0.15f , 0.15f ) ) ; WeaponStaticMesh -> SetRelativeLocation ( FVector ( 20 , - 2 , - 2 ) ) ; WeaponStaticMesh -> SetRelativeRotation ( FRotator ( - 12 , - 90 , - 75 ) ) ; WeaponOffhandMesh -> SetStaticMesh ( SM_WeaponOffhandMesh ) ; WeaponOffhandMesh -> SetHiddenInGame ( true ) ; }
void AAnnihilator :: BeginPlay ( ) { Super :: BeginPlay ( ) ; OnBindGear . AddDynamic ( this , & AAnnihilator :: BindWeapon ) ; }
void AAnnihilator :: BindWeapon ( ) { if ( IsShown ) { ShowWeapon ( false , true , false ) ; } }
void CPACSFarField :: ReadCPACS ( const TixiDocumentHandle & tixiHandle , const std :: string & xpath ) { if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / type " ) ) { m_type = stringToTiglFarFieldType ( tixi :: TixiGetElement < std :: string > ( tixiHandle , xpath + " / type " ) ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ type ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / referenceLength " ) ) { m_referenceLength = tixi :: TixiGetElement < double > ( tixiHandle , xpath + " / referenceLength " ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ referenceLength ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / multiplier " ) ) { m_multiplier = tixi :: TixiGetElement < double > ( tixiHandle , xpath + " / multiplier " ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ multiplier ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } }
void CPACSFarField :: SetType ( const TiglFarFieldType & value ) { m_type = value ; }
void CPACSFarField :: SetReferenceLength ( const double & value ) { m_referenceLength = value ; }
void CPACSFarField :: SetMultiplier ( const double & value ) { m_multiplier = value ; }
std :: string System_GetProperty ( SystemProperty prop ) { return " " ; }
template < class T > void PointMovementGenerator < T > :: DoInitialize ( T * unit ) { if ( ! unit -> IsStopped ( ) ) unit -> StopMoving ( ) ; unit -> AddUnitState ( UNIT_STATE_ROAMING | UNIT_STATE_ROAMING_MOVE ) ; if ( id == EVENT_CHARGE_PREPATH ) return ; Movement :: MoveSplineInit init ( unit ) ; init . MoveTo ( i_x , i_y , i_z , m_generatePath ) ; if ( speed > 0.0f ) init . SetVelocity ( speed ) ; init . Launch ( ) ; }
template < class T > bool PointMovementGenerator < T > :: DoUpdate ( T * unit , uint32 ) { if ( ! unit ) return false ; if ( unit -> HasUnitState ( UNIT_STATE_ROOT | UNIT_STATE_STUNNED ) ) { unit -> ClearUnitState ( UNIT_STATE_ROAMING_MOVE ) ; return true ; } unit -> AddUnitState ( UNIT_STATE_ROAMING_MOVE ) ; if ( id != EVENT_CHARGE_PREPATH && i_recalculateSpeed && ! unit -> movespline -> Finalized ( ) ) { i_recalculateSpeed = false ; Movement :: MoveSplineInit init ( unit ) ; init . MoveTo ( i_x , i_y , i_z , m_generatePath ) ; if ( speed > 0.0f ) init . SetVelocity ( speed ) ; init . Launch ( ) ; } return ! unit -> movespline -> Finalized ( ) ; }
template < class T > void PointMovementGenerator < T > :: DoFinalize ( T * unit ) { if ( unit -> HasUnitState ( UNIT_STATE_CHARGING ) ) unit -> ClearUnitState ( UNIT_STATE_ROAMING | UNIT_STATE_ROAMING_MOVE ) ; if ( unit -> movespline -> Finalized ( ) ) MovementInform ( unit ) ; }
template < class T > void PointMovementGenerator < T > :: DoReset ( T * unit ) { if ( ! unit -> IsStopped ( ) ) unit -> StopMoving ( ) ; unit -> AddUnitState ( UNIT_STATE_ROAMING | UNIT_STATE_ROAMING_MOVE ) ; }
template < > void PointMovementGenerator < Creature > :: MovementInform ( Creature * unit ) { if ( unit -> AI ( ) ) unit -> AI ( ) -> MovementInform ( POINT_MOTION_TYPE , id ) ; }
void AssistanceMovementGenerator :: Finalize ( Unit * unit ) { unit -> ToCreature ( ) -> SetNoCallAssistance ( false ) ; unit -> ToCreature ( ) -> CallAssistance ( ) ; if ( unit -> isAlive ( ) ) unit -> GetMotionMaster ( ) -> MoveSeekAssistanceDistract ( sWorld -> getIntConfig ( CONFIG_CREATURE_FAMILY_ASSISTANCE_DELAY ) ) ; }
bool EffectMovementGenerator :: Update ( Unit * unit , uint32 ) { return ! unit -> movespline -> Finalized ( ) ; }
void EffectMovementGenerator :: Finalize ( Unit * unit ) { if ( unit -> GetTypeId ( ) != TYPEID_UNIT ) return ; if ( unit -> isAlive ( ) && ! unit -> HasUnitState ( UNIT_STATE_CONFUSED | UNIT_STATE_FLEEING ) ) { if ( Unit * victim = unit -> getVictim ( ) ) unit -> GetMotionMaster ( ) -> MoveChase ( victim ) ; else unit -> GetMotionMaster ( ) -> Initialize ( ) ; } if ( unit -> ToCreature ( ) -> AI ( ) ) unit -> ToCreature ( ) -> AI ( ) -> MovementInform ( EFFECT_MOTION_TYPE , m_Id ) ; }
void LocalCapture :: createAPCDirectory ( char * target_path ) { gSessionData -> mAPCDir = createUniqueDirectory ( target_path , " . apc " ) ; if ( ( removeDirAndAllContents ( gSessionData -> mAPCDir ) != 0 || mkdir ( gSessionData -> mAPCDir , S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH ) != 0 ) ) { logg -> logError ( __FILE__ , __LINE__ , " Unable ▁ to ▁ create ▁ directory ▁ % s " , gSessionData -> mAPCDir ) ; handleException ( ) ; } }
void LocalCapture :: write ( char * string ) { char file [ PATH_MAX ] ; snprintf ( file , PATH_MAX , " % s / session . xml " , gSessionData -> mAPCDir ) ; if ( util -> writeToDisk ( file , string ) < 0 ) { logg -> logError ( __FILE__ , __LINE__ , " Error ▁ writing ▁ % s \n Please ▁ verify ▁ the ▁ path . " , file ) ; handleException ( ) ; } EventsXML eventsXML ; eventsXML . write ( gSessionData -> mAPCDir ) ; }
char * LocalCapture :: createUniqueDirectory ( const char * initialPath , const char * ending ) { char * output ; char path [ PATH_MAX ] ; if ( initialPath == 0 || strlen ( initialPath ) == 0 ) { logg -> logError ( __FILE__ , __LINE__ , " Missing ▁ - o ▁ command ▁ line ▁ option ▁ required ▁ for ▁ a ▁ local ▁ capture . " ) ; handleException ( ) ; } else if ( initialPath [ 0 ] != ' / ' ) { if ( getcwd ( path , PATH_MAX ) == 0 ) { logg -> logMessage ( " Unable ▁ to ▁ retrieve ▁ the ▁ current ▁ working ▁ directory " ) ; } strncat ( path , " / " , PATH_MAX - strlen ( path ) - 1 ) ; strncat ( path , initialPath , PATH_MAX - strlen ( path ) - 1 ) ; } else { strncpy ( path , initialPath , PATH_MAX ) ; path [ PATH_MAX - 1 ] = 0 ; } if ( strcmp ( & path [ strlen ( path ) - strlen ( ending ) ] , ending ) != 0 ) { strncat ( path , ending , PATH_MAX - strlen ( path ) - 1 ) ; } output = strdup ( path ) ; return output ; }
int LocalCapture :: removeDirAndAllContents ( char * path ) { int error = 0 ; struct stat mFileInfo ; if ( stat ( path , & mFileInfo ) == 0 ) { if ( mFileInfo . st_mode & S_IFDIR ) { DIR * dir = opendir ( path ) ; dirent * entry = readdir ( dir ) ; while ( entry ) { if ( strcmp ( entry -> d_name , " . " ) != 0 && strcmp ( entry -> d_name , " . . " ) != 0 ) { char * newpath = ( char * ) malloc ( strlen ( path ) + strlen ( entry -> d_name ) + 2 ) ; sprintf ( newpath , " % s / % s " , path , entry -> d_name ) ; error = removeDirAndAllContents ( newpath ) ; free ( newpath ) ; if ( error ) { break ; } } entry = readdir ( dir ) ; } closedir ( dir ) ; if ( error == 0 ) { error = rmdir ( path ) ; } } else { error = remove ( path ) ; } } return error ; }
void LocalCapture :: copyImages ( ImageLinkList * ptr ) { char dstfilename [ PATH_MAX ] ; while ( ptr ) { strncpy ( dstfilename , gSessionData -> mAPCDir , PATH_MAX ) ; dstfilename [ PATH_MAX - 1 ] = 0 ; if ( gSessionData -> mAPCDir [ strlen ( gSessionData -> mAPCDir ) - 1 ] != ' / ' ) { strncat ( dstfilename , " / " , PATH_MAX - strlen ( dstfilename ) - 1 ) ; } strncat ( dstfilename , util -> getFilePart ( ptr -> path ) , PATH_MAX - strlen ( dstfilename ) - 1 ) ; if ( util -> copyFile ( ptr -> path , dstfilename ) ) { logg -> logMessage ( " copied ▁ file ▁ % s ▁ to ▁ % s " , ptr -> path , dstfilename ) ; } else { logg -> logMessage ( " copy ▁ of ▁ file ▁ % s ▁ to ▁ % s ▁ failed " , ptr -> path , dstfilename ) ; } ptr = ptr -> next ; } }
SendCoinsDialog :: SendCoinsDialog ( QWidget * parent ) : QDialog ( parent ) , ui ( new Ui :: SendCoinsDialog ) , model ( 0 ) { ui -> setupUi ( this ) ; ui -> addButton -> setIcon ( QIcon ( ) ) ; ui -> clearButton -> setIcon ( QIcon ( ) ) ; ui -> sendButton -> setIcon ( QIcon ( ) ) ; addEntry ( ) ; connect ( ui -> addButton , SIGNAL ( clicked ( ) ) , this , SLOT ( addEntry ( ) ) ) ; connect ( ui -> clearButton , SIGNAL ( clicked ( ) ) , this , SLOT ( clear ( ) ) ) ; fNewRecipientAllowed = true ; }
void SendCoinsDialog :: setModel ( WalletModel * model ) { this -> model = model ; for ( int i = 0 ; i < ui -> entries -> count ( ) ; ++ i ) { SendCoinsEntry * entry = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( i ) -> widget ( ) ) ; if ( entry ) { entry -> setModel ( model ) ; } } if ( model && model -> getOptionsModel ( ) ) { setBalance ( model -> getBalance ( ) , model -> getUnconfirmedBalance ( ) , model -> getImmatureBalance ( ) ) ; connect ( model , SIGNAL ( balanceChanged ( qint64 , qint64 , qint64 ) ) , this , SLOT ( setBalance ( qint64 , qint64 , qint64 ) ) ) ; connect ( model -> getOptionsModel ( ) , SIGNAL ( displayUnitChanged ( int ) ) , this , SLOT ( updateDisplayUnit ( ) ) ) ; } }
SendCoinsDialog :: ~ SendCoinsDialog ( ) { delete ui ; }
void SendCoinsDialog :: on_sendButton_clicked ( ) { QList < SendCoinsRecipient > recipients ; bool valid = true ; if ( ! model ) return ; for ( int i = 0 ; i < ui -> entries -> count ( ) ; ++ i ) { SendCoinsEntry * entry = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( i ) -> widget ( ) ) ; if ( entry ) { if ( entry -> validate ( ) ) { recipients . append ( entry -> getValue ( ) ) ; } else { valid = false ; } } } if ( ! valid || recipients . isEmpty ( ) ) { return ; } QStringList formatted ; foreach ( const SendCoinsRecipient & rcp , recipients ) { formatted . append ( tr ( " < b > % 1 < / b > ▁ to ▁ % 2 ▁ ( %3 ) " ) . arg ( BitcoinUnits :: formatWithUnit ( BitcoinUnits :: BTC , rcp . amount ) , Qt :: escape ( rcp . label ) , rcp . address ) ) ; } fNewRecipientAllowed = false ; QMessageBox :: StandardButton retval = QMessageBox :: question ( this , tr ( " Confirm ▁ send ▁ coins " ) , tr ( " Are ▁ you ▁ sure ▁ you ▁ want ▁ to ▁ send ▁ % 1 ? " ) . arg ( formatted . join ( tr ( " ▁ and ▁ " ) ) ) , QMessageBox :: Yes | QMessageBox :: Cancel , QMessageBox :: Cancel ) ; if ( retval != QMessageBox :: Yes ) { fNewRecipientAllowed = true ; return ; } WalletModel :: UnlockContext ctx ( model -> requestUnlock ( ) ) ; if ( ! ctx . isValid ( ) ) { fNewRecipientAllowed = true ; return ; } WalletModel :: SendCoinsReturn sendstatus = model -> sendCoins ( recipients ) ; switch ( sendstatus . status ) { case WalletModel :: InvalidAddress : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " The ▁ recepient ▁ address ▁ is ▁ not ▁ valid , ▁ please ▁ recheck . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: InvalidAmount : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " The ▁ amount ▁ to ▁ pay ▁ must ▁ be ▁ larger ▁ than ▁ 0 . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: AmountExceedsBalance : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " The ▁ amount ▁ exceeds ▁ your ▁ balance . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: AmountWithFeeExceedsBalance : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " The ▁ total ▁ exceeds ▁ your ▁ balance ▁ when ▁ the ▁ % 1 ▁ transaction ▁ fee ▁ is ▁ included . " ) . arg ( BitcoinUnits :: formatWithUnit ( BitcoinUnits :: BTC , sendstatus . fee ) ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: DuplicateAddress : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " Duplicate ▁ address ▁ found , ▁ can ▁ only ▁ send ▁ to ▁ each ▁ address ▁ once ▁ per ▁ send ▁ operation . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: TransactionCreationFailed : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " Error : ▁ Transaction ▁ creation ▁ failed . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: TransactionCommitFailed : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " Error : ▁ The ▁ transaction ▁ was ▁ rejected . ▁ This ▁ might ▁ happen ▁ if ▁ some ▁ of ▁ the ▁ coins ▁ in ▁ your ▁ wallet ▁ were ▁ already ▁ spent , ▁ such ▁ as ▁ if ▁ you ▁ used ▁ a ▁ copy ▁ of ▁ wallet . dat ▁ and ▁ coins ▁ were ▁ spent ▁ in ▁ the ▁ copy ▁ but ▁ not ▁ marked ▁ as ▁ spent ▁ here . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: Aborted : break ; case WalletModel :: OK : accept ( ) ; break ; } fNewRecipientAllowed = true ; }
void SendCoinsDialog :: clear ( ) { while ( ui -> entries -> count ( ) ) { delete ui -> entries -> takeAt ( 0 ) -> widget ( ) ; } addEntry ( ) ; updateRemoveEnabled ( ) ; ui -> sendButton -> setDefault ( true ) ; }
void SendCoinsDialog :: reject ( ) { clear ( ) ; }
void SendCoinsDialog :: accept ( ) { clear ( ) ; }
SendCoinsEntry * SendCoinsDialog :: addEntry ( ) { SendCoinsEntry * entry = new SendCoinsEntry ( this ) ; entry -> setModel ( model ) ; ui -> entries -> addWidget ( entry ) ; connect ( entry , SIGNAL ( removeEntry ( SendCoinsEntry * ) ) , this , SLOT ( removeEntry ( SendCoinsEntry * ) ) ) ; updateRemoveEnabled ( ) ; entry -> clear ( ) ; entry -> setFocus ( ) ; ui -> scrollAreaWidgetContents -> resize ( ui -> scrollAreaWidgetContents -> sizeHint ( ) ) ; QCoreApplication :: instance ( ) -> processEvents ( ) ; QScrollBar * bar = ui -> scrollArea -> verticalScrollBar ( ) ; if ( bar ) bar -> setSliderPosition ( bar -> maximum ( ) ) ; return entry ; }
void SendCoinsDialog :: updateRemoveEnabled ( ) { bool enabled = ( ui -> entries -> count ( ) > 1 ) ; for ( int i = 0 ; i < ui -> entries -> count ( ) ; ++ i ) { SendCoinsEntry * entry = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( i ) -> widget ( ) ) ; if ( entry ) { entry -> setRemoveEnabled ( enabled ) ; } } setupTabChain ( 0 ) ; }
void SendCoinsDialog :: removeEntry ( SendCoinsEntry * entry ) { delete entry ; updateRemoveEnabled ( ) ; }
QWidget * SendCoinsDialog :: setupTabChain ( QWidget * prev ) { for ( int i = 0 ; i < ui -> entries -> count ( ) ; ++ i ) { SendCoinsEntry * entry = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( i ) -> widget ( ) ) ; if ( entry ) { prev = entry -> setupTabChain ( prev ) ; } } QWidget :: setTabOrder ( prev , ui -> addButton ) ; QWidget :: setTabOrder ( ui -> addButton , ui -> sendButton ) ; return ui -> sendButton ; }
void SendCoinsDialog :: pasteEntry ( const SendCoinsRecipient & rv ) { if ( ! fNewRecipientAllowed ) return ; SendCoinsEntry * entry = 0 ; if ( ui -> entries -> count ( ) == 1 ) { SendCoinsEntry * first = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( 0 ) -> widget ( ) ) ; if ( first -> isClear ( ) ) { entry = first ; } } if ( ! entry ) { entry = addEntry ( ) ; } entry -> setValue ( rv ) ; }
bool SendCoinsDialog :: handleURI ( const QString & uri ) { SendCoinsRecipient rv ; if ( GUIUtil :: parseBitcoinURI ( uri , & rv ) ) { pasteEntry ( rv ) ; return true ; } return false ; }
void SendCoinsDialog :: setBalance ( qint64 balance , qint64 unconfirmedBalance , qint64 immatureBalance ) { Q_UNUSED ( unconfirmedBalance ) ; Q_UNUSED ( immatureBalance ) ; if ( ! model || ! model -> getOptionsModel ( ) ) return ; int unit = model -> getOptionsModel ( ) -> getDisplayUnit ( ) ; ui -> labelBalance -> setText ( BitcoinUnits :: formatWithUnit ( unit , balance ) ) ; }
void SendCoinsDialog :: updateDisplayUnit ( ) { if ( model && model -> getOptionsModel ( ) ) { ui -> labelBalance -> setText ( BitcoinUnits :: formatWithUnit ( model -> getOptionsModel ( ) -> getDisplayUnit ( ) , model -> getBalance ( ) ) ) ; } }
TestTracker :: TestTracker ( ) { if ( ! _created ) { initialize ( ) ; setListener ( 0 ) ; _created = true ; } }
TestTracker & TestTracker :: tracker ( ) { static TestTracker theTracker ; return theTracker ; }
void TestTracker :: initialize ( ) { _warnings = 0 ; _skippedTests = 0 ; _testSkipped = false ; _failedTests = 0 ; _testFailedAsserts = 0 ; _suiteFailedTests = 0 ; _failedSuites = 0 ; _world = 0 ; _suite = 0 ; _test = 0 ; }
void TestTracker :: setListener ( TestListener * l ) { _l = l ? l : & _dummyListener ; }
void TestTracker :: enterWorld ( const WorldDescription & wd ) { setWorld ( & wd ) ; _warnings = _skippedTests = _failedTests = _testFailedAsserts = _suiteFailedTests = _failedSuites = 0 ; _testSkipped = false ; _l -> enterWorld ( wd ) ; }
void TestTracker :: enterSuite ( const SuiteDescription & sd ) { setSuite ( & sd ) ; _testFailedAsserts = _suiteFailedTests = 0 ; _testSkipped = false ; _l -> enterSuite ( sd ) ; }
void TestTracker :: enterTest ( const TestDescription & td ) { setTest ( & td ) ; _testFailedAsserts = false ; _testSkipped = false ; _l -> enterTest ( td ) ; }
void TestTracker :: leaveTest ( const TestDescription & td ) { _l -> leaveTest ( td ) ; setTest ( 0 ) ; }
void TestTracker :: leaveSuite ( const SuiteDescription & sd ) { _l -> leaveSuite ( sd ) ; setSuite ( 0 ) ; }
void TestTracker :: leaveWorld ( const WorldDescription & wd ) { _l -> leaveWorld ( wd ) ; setWorld ( 0 ) ; }
void TestTracker :: trace ( const char * file , int line , const char * expression ) { _l -> trace ( file , line , expression ) ; }
void TestTracker :: warning ( const char * file , int line , const char * expression ) { countWarning ( ) ; _l -> warning ( file , line , expression ) ; }
void TestTracker :: skippedTest ( const char * file , int line , const char * expression ) { countSkipped ( ) ; _testSkipped = true ; _l -> skippedTest ( file , line , expression ) ; }
void TestTracker :: failedTest ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedTest ( file , line , expression ) ; }
void TestTracker :: failedAssert ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedAssert ( file , line , expression ) ; }
void TestTracker :: failedAssertEquals ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertEquals ( file , line , xStr , yStr , x , y ) ; }
void TestTracker :: failedAssertSameData ( const char * file , int line , const char * xStr , const char * yStr , const char * sizeStr , const void * x , const void * y , unsigned size ) { countFailure ( ) ; _l -> failedAssertSameData ( file , line , xStr , yStr , sizeStr , x , y , size ) ; }
void TestTracker :: failedAssertDelta ( const char * file , int line , const char * xStr , const char * yStr , const char * dStr , const char * x , const char * y , const char * d ) { countFailure ( ) ; _l -> failedAssertDelta ( file , line , xStr , yStr , dStr , x , y , d ) ; }
void TestTracker :: failedAssertDiffers ( const char * file , int line , const char * xStr , const char * yStr , const char * value ) { countFailure ( ) ; _l -> failedAssertDiffers ( file , line , xStr , yStr , value ) ; }
void TestTracker :: failedAssertLessThan ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertLessThan ( file , line , xStr , yStr , x , y ) ; }
void TestTracker :: failedAssertLessThanEquals ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertLessThanEquals ( file , line , xStr , yStr , x , y ) ; }
void TestTracker :: failedAssertPredicate ( const char * file , int line , const char * predicate , const char * xStr , const char * x ) { countFailure ( ) ; _l -> failedAssertPredicate ( file , line , predicate , xStr , x ) ; }
void TestTracker :: failedAssertRelation ( const char * file , int line , const char * relation , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertRelation ( file , line , relation , xStr , yStr , x , y ) ; }
void TestTracker :: failedAssertThrows ( const char * file , int line , const char * expression , const char * type , bool otherThrown ) { countFailure ( ) ; _l -> failedAssertThrows ( file , line , expression , type , otherThrown ) ; }
void TestTracker :: failedAssertThrowsNot ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedAssertThrowsNot ( file , line , expression ) ; }
void TestTracker :: failedAssertSameFiles ( const char * file , int line , const char * file1 , const char * file2 , const char * explanation ) { countFailure ( ) ; _l -> failedAssertSameFiles ( file , line , file1 , file2 , explanation ) ; }
void TestTracker :: setWorld ( const WorldDescription * w ) { _world = fixWorld ( w ) ; setSuite ( 0 ) ; }
void TestTracker :: setSuite ( const SuiteDescription * s ) { _suite = fixSuite ( s ) ; setTest ( 0 ) ; }
void TestTracker :: setTest ( const TestDescription * t ) { _test = fixTest ( t ) ; }
void TestTracker :: countWarning ( ) { ++ _warnings ; }
void TestTracker :: countSkipped ( ) { ++ _skippedTests ; }
void TestTracker :: countFailure ( ) { if ( ++ _testFailedAsserts == 1 ) { ++ _failedTests ; if ( ++ _suiteFailedTests == 1 ) { ++ _failedSuites ; } } }
MachineSSAUpdater :: MachineSSAUpdater ( MachineFunction & MF , SmallVectorImpl < MachineInstr * > * NewPHI ) : AV ( nullptr ) , InsertedPHIs ( NewPHI ) { TII = MF . getSubtarget ( ) . getInstrInfo ( ) ; MRI = & MF . getRegInfo ( ) ; }
MachineSSAUpdater :: ~ MachineSSAUpdater ( ) { delete static_cast < AvailableValsTy * > ( AV ) ; }
void MachineSSAUpdater :: Initialize ( unsigned V ) { if ( ! AV ) AV = new AvailableValsTy ( ) ; else getAvailableVals ( AV ) . clear ( ) ; VR = V ; VRC = MRI -> getRegClass ( VR ) ; }
void MachineSSAUpdater :: AddAvailableValue ( MachineBasicBlock * BB , unsigned V ) { getAvailableVals ( AV ) [ BB ] = V ; }
unsigned MachineSSAUpdater :: GetValueAtEndOfBlock ( MachineBasicBlock * BB ) { return GetValueAtEndOfBlockInternal ( BB ) ; }
unsigned MachineSSAUpdater :: GetValueInMiddleOfBlock ( MachineBasicBlock * BB ) { if ( ! HasValueForBlock ( BB ) ) return GetValueAtEndOfBlockInternal ( BB ) ; if ( BB -> pred_empty ( ) ) { MachineInstr * NewDef = InsertNewDef ( TargetOpcode :: IMPLICIT_DEF , BB , BB -> getFirstTerminator ( ) , VRC , MRI , TII ) ; return NewDef -> getOperand ( 0 ) . getReg ( ) ; } SmallVector < std :: pair < MachineBasicBlock * , unsigned > , 8 > PredValues ; unsigned SingularValue = 0 ; bool isFirstPred = true ; for ( MachineBasicBlock :: pred_iterator PI = BB -> pred_begin ( ) , E = BB -> pred_end ( ) ; PI != E ; ++ PI ) { MachineBasicBlock * PredBB = * PI ; unsigned PredVal = GetValueAtEndOfBlockInternal ( PredBB ) ; PredValues . push_back ( std :: make_pair ( PredBB , PredVal ) ) ; if ( isFirstPred ) { SingularValue = PredVal ; isFirstPred = false ; } else if ( PredVal != SingularValue ) SingularValue = 0 ; } if ( SingularValue != 0 ) return SingularValue ; unsigned DupPHI = LookForIdenticalPHI ( BB , PredValues ) ; if ( DupPHI ) return DupPHI ; MachineBasicBlock :: iterator Loc = BB -> empty ( ) ? BB -> end ( ) : BB -> begin ( ) ; MachineInstrBuilder InsertedPHI = InsertNewDef ( TargetOpcode :: PHI , BB , Loc , VRC , MRI , TII ) ; for ( unsigned i = 0 , e = PredValues . size ( ) ; i != e ; ++ i ) InsertedPHI . addReg ( PredValues [ i ] . second ) . addMBB ( PredValues [ i ] . first ) ; if ( unsigned ConstVal = InsertedPHI -> isConstantValuePHI ( ) ) { InsertedPHI -> eraseFromParent ( ) ; return ConstVal ; } if ( InsertedPHIs ) InsertedPHIs -> push_back ( InsertedPHI ) ; DEBUG ( dbgs ( ) << " ▁ ▁ Inserted ▁ PHI : ▁ " << * InsertedPHI << " \n " ) ; return InsertedPHI -> getOperand ( 0 ) . getReg ( ) ; }
void MachineSSAUpdater :: RewriteUse ( MachineOperand & U ) { MachineInstr * UseMI = U . getParent ( ) ; unsigned NewVR = 0 ; if ( UseMI -> isPHI ( ) ) { MachineBasicBlock * SourceBB = findCorrespondingPred ( UseMI , & U ) ; NewVR = GetValueAtEndOfBlockInternal ( SourceBB ) ; } else { NewVR = GetValueInMiddleOfBlock ( UseMI -> getParent ( ) ) ; } U . setReg ( NewVR ) ; }
unsigned MachineSSAUpdater :: GetValueAtEndOfBlockInternal ( MachineBasicBlock * BB ) { AvailableValsTy & AvailableVals = getAvailableVals ( AV ) ; if ( unsigned V = AvailableVals [ BB ] ) return V ; SSAUpdaterImpl < MachineSSAUpdater > Impl ( this , & AvailableVals , InsertedPHIs ) ; return Impl . GetValue ( BB ) ; }
const TibetanClassTable * TibetanClassTable :: getTibetanClassTable ( ) { return & tibetanClassTable ; }
MaterialDocManager :: ~ MaterialDocManager ( void ) { UnRegisterAllMaterialViews ( ) ; ClearUndo ( ) ; ClearRedo ( ) ; }
void MaterialDocManager :: RegisterMaterialView ( MaterialView * view ) { ASSERT ( view ) ; UnRegisterMaterialView ( view ) ; materialViews . Append ( view ) ; view -> SetMaterialDocManager ( this ) ; }
void MaterialDocManager :: UnRegisterMaterialView ( MaterialView * view ) { ASSERT ( view ) ; materialViews . Remove ( view ) ; view -> SetMaterialDocManager ( NULL ) ; }
void MaterialDocManager :: UnRegisterAllMaterialViews ( ) { int c = materialViews . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { materialViews [ i ] -> SetMaterialDocManager ( NULL ) ; } materialViews . Clear ( ) ; }
void MaterialDocManager :: SetSelectedMaterial ( idMaterial * material ) { bool change = false ; if ( material ) { if ( currentMaterial ) { if ( strcmp ( material -> GetName ( ) , currentMaterial -> renderMaterial -> GetName ( ) ) ) { change = true ; } } else { change = true ; } } else { if ( currentMaterial ) { change = true ; } } if ( change ) { if ( currentMaterial ) { if ( ! inProgressMaterials . Get ( currentMaterial -> name . c_str ( ) ) ) { delete currentMaterial ; currentMaterial = NULL ; } } MaterialDoc * * tempDoc ; if ( material && inProgressMaterials . Get ( material -> GetName ( ) , & tempDoc ) ) { currentMaterial = * tempDoc ; } else { currentMaterial = CreateMaterialDoc ( material ) ; } NotifyViews ( currentMaterial , SELECTION_CHANGE ) ; } }
bool MaterialDocManager :: DoesFileNeedApply ( const char * filename ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) && ( * pDoc ) -> applyWaiting ) return true ; } return false ; }
bool MaterialDocManager :: DoesAnyNeedApply ( ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ( * pDoc ) -> applyWaiting ) return true ; } return false ; }
bool MaterialDocManager :: IsFileModified ( const char * filename ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) return true ; } return false ; }
bool MaterialDocManager :: IsAnyModified ( ) { return ( inProgressMaterials . Num ( ) > 0 ) ; }
void MaterialDocManager :: AddMaterial ( const char * name , const char * filename , const char * sourceText , bool addUndo ) { if ( addUndo ) { AddMaterialModifier * mod = new AddMaterialModifier ( this , name , filename ) ; AddMaterialUndoModifier ( mod ) ; } MaterialDoc * newDoc = new MaterialDoc ( ) ; newDoc -> manager = this ; newDoc -> modified = true ; idMaterial * rendMat = ( idMaterial * ) declManager -> CreateNewDecl ( DECL_MATERIAL , name , filename ) ; if ( sourceText ) { rendMat -> SetText ( sourceText ) ; } newDoc -> SetRenderMaterial ( rendMat , true , sourceText ? true : false ) ; inProgressMaterials . Set ( newDoc -> name . c_str ( ) , newDoc ) ; NotifyViews ( newDoc , MATERIAL_ADD ) ; newDoc -> applyWaiting = true ; newDoc -> ApplyMaterialChanges ( ) ; }
void MaterialDocManager :: RedoAddMaterial ( const char * name , bool clearData ) { MaterialDoc * newDoc = new MaterialDoc ( ) ; newDoc -> manager = this ; newDoc -> modified = true ; idMaterial * rendMat = const_cast < idMaterial * > ( declManager -> FindMaterial ( name , false ) ) ; if ( clearData ) { rendMat -> SetText ( rendMat -> DefaultDefinition ( ) ) ; } newDoc -> SetRenderMaterial ( rendMat , true , true ) ; inProgressMaterials . Set ( newDoc -> name . c_str ( ) , newDoc ) ; NotifyViews ( newDoc , MATERIAL_ADD ) ; newDoc -> applyWaiting = true ; newDoc -> ApplyMaterialChanges ( ) ; }
void MaterialDocManager :: DeleteMaterial ( MaterialDoc * material , bool addUndo ) { assert ( material ) ; material -> Delete ( ) ; if ( addUndo ) { DeleteMaterialModifier * mod = new DeleteMaterialModifier ( this , material -> name ) ; AddMaterialUndoModifier ( mod ) ; } NotifyViews ( material , MATERIAL_DELETE ) ; }
void MaterialDocManager :: ApplyMaterial ( MaterialDoc * materialDoc ) { assert ( materialDoc ) ; materialDoc -> ApplyMaterialChanges ( ) ; }
void MaterialDocManager :: ApplyFile ( const char * filename ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) ( * pDoc ) -> ApplyMaterialChanges ( ) ; } }
void MaterialDocManager :: ApplyAll ( ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; ( * pDoc ) -> ApplyMaterialChanges ( ) ; } }
void MaterialDocManager :: SaveMaterial ( MaterialDoc * material ) { assert ( material ) ; material -> Save ( ) ; }
void MaterialDocManager :: SaveFile ( const char * filename ) { for ( int i = inProgressMaterials . Num ( ) - 1 ; i >= 0 ; i -- ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) ( * pDoc ) -> Save ( ) ; } NotifyViews ( NULL , MATERIAL_SAVE_FILE , filename ) ; }
void MaterialDocManager :: SaveAllMaterials ( ) { for ( int i = inProgressMaterials . Num ( ) - 1 ; i >= 0 ; i -- ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; ( * pDoc ) -> Save ( ) ; } }
void MaterialDocManager :: ReloadFile ( const char * filename ) { declManager -> ReloadFile ( filename , true ) ; for ( int j = inProgressMaterials . Num ( ) - 1 ; j >= 0 ; j -- ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( j ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) { ( * pDoc ) -> SetRenderMaterial ( ( * pDoc ) -> renderMaterial ) ; inProgressMaterials . Remove ( ( * pDoc ) -> name ) ; } } if ( currentMaterial ) { currentMaterial -> SetRenderMaterial ( currentMaterial -> renderMaterial ) ; NotifyViews ( currentMaterial , SELECTION_CHANGE ) ; } NotifyViews ( NULL , FILE_RELOAD , filename ) ; }
MaterialDoc * MaterialDocManager :: CreateMaterialDoc ( const char * materialName ) { const idMaterial * material = declManager -> FindMaterial ( materialName ) ; return CreateMaterialDoc ( const_cast < idMaterial * > ( material ) ) ; }
MaterialDoc * MaterialDocManager :: CreateMaterialDoc ( idMaterial * material ) { MaterialDoc * existingDoc = GetInProgressDoc ( material ) ; if ( existingDoc ) { return existingDoc ; } if ( currentMaterial && material && ! currentMaterial -> name . Icmp ( material -> GetName ( ) ) ) { return currentMaterial ; } if ( material ) { MaterialDoc * newDoc = new MaterialDoc ( ) ; newDoc -> manager = this ; newDoc -> SetRenderMaterial ( material ) ; return newDoc ; } return NULL ; }
MaterialDoc * MaterialDocManager :: GetInProgressDoc ( idMaterial * material ) { if ( material ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! ( * pDoc ) -> name . Icmp ( material -> GetName ( ) ) ) return * pDoc ; } } return NULL ; }
void MaterialDocManager :: CopyMaterial ( MaterialDoc * materialDoc , bool cut ) { cutMaterial = cut ; if ( materialDoc ) copyMaterial = materialDoc -> name ; else ClearCopy ( ) ; }
void MaterialDocManager :: ClearCopy ( ) { copyMaterial . Empty ( ) ; }
bool MaterialDocManager :: IsCopyMaterial ( ) { return ( copyMaterial . Length ( ) ) ? true : false ; }
idStr MaterialDocManager :: GetCopyMaterialName ( ) { return copyMaterial ; }
void MaterialDocManager :: PasteMaterial ( const char * name , const char * filename ) { if ( ! IsCopyMaterial ( ) ) { return ; } MaterialDoc * copyMat = CreateMaterialDoc ( copyMaterial ) ; if ( copyMat -> applyWaiting ) { copyMat -> ApplyMaterialChanges ( ) ; } idMaterial * material = copyMat -> renderMaterial ; char * declText = ( char * ) _alloca ( material -> GetTextLength ( ) + 1 ) ; material -> GetText ( declText ) ; AddMaterial ( name , filename , declText , ! cutMaterial ) ; if ( cutMaterial ) { MaterialDoc * cutMaterial = CreateMaterialDoc ( material ) ; DeleteMaterial ( cutMaterial , false ) ; MoveMaterialModifier * mod = new MoveMaterialModifier ( this , name , filename , copyMaterial ) ; AddMaterialUndoModifier ( mod ) ; ClearCopy ( ) ; } }
void MaterialDocManager :: CopyStage ( MaterialDoc * materialDoc , int stageNum ) { assert ( materialDoc ) ; copyStageMaterial = materialDoc -> name ; copyStage = materialDoc -> GetStage ( stageNum ) ; idStr stageName = copyStage . stageData . GetString ( " name " ) ; }
void MaterialDocManager :: ClearCopyStage ( ) { copyStageMaterial . Empty ( ) ; copyStage . stageData . Clear ( ) ; }
bool MaterialDocManager :: IsCopyStage ( ) { return ( copyStageMaterial . Length ( ) ) ? true : false ; }
void MaterialDocManager :: PasteStage ( MaterialDoc * materialDoc ) { assert ( materialDoc ) ; int stageType = copyStage . stageData . GetInt ( " stagetype " ) ; materialDoc -> AddStage ( stageType , copyStage . stageData . GetString ( " name " ) ) ; materialDoc -> SetData ( materialDoc -> GetStageCount ( ) - 1 , & copyStage . stageData ) ; }
void MaterialDocManager :: GetCopyStageInfo ( int & type , idStr & name ) { if ( IsCopyStage ( ) ) { type = copyStage . stageData . GetInt ( " stagetype " ) ; name = copyStage . stageData . GetString ( " name " ) ; } }
void MaterialDocManager :: Undo ( ) { if ( IsUndoAvailable ( ) ) { MaterialModifier * mod = undoModifiers [ undoModifiers . Num ( ) - 1 ] ; undoModifiers . RemoveIndex ( undoModifiers . Num ( ) - 1 ) ; mod -> Undo ( ) ; AddMaterialRedoModifier ( mod ) ; } }
bool MaterialDocManager :: IsUndoAvailable ( ) { return ( undoModifiers . Num ( ) > 0 ) ; }
void MaterialDocManager :: ClearUndo ( ) { int c = undoModifiers . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { delete undoModifiers [ i ] ; } undoModifiers . Clear ( ) ; }
void MaterialDocManager :: Redo ( ) { if ( IsRedoAvailable ( ) ) { MaterialModifier * mod = redoModifiers [ redoModifiers . Num ( ) - 1 ] ; redoModifiers . RemoveIndex ( redoModifiers . Num ( ) - 1 ) ; mod -> Redo ( ) ; AddMaterialUndoModifier ( mod , false ) ; } }
bool MaterialDocManager :: IsRedoAvailable ( ) { return ( redoModifiers . Num ( ) > 0 ) ; }
void MaterialDocManager :: ClearRedo ( ) { int c = redoModifiers . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { delete redoModifiers [ i ] ; } redoModifiers . Clear ( ) ; }
void MaterialDocManager :: AddMaterialUndoModifier ( MaterialModifier * mod , bool clearRedo ) { undoModifiers . Append ( mod ) ; while ( undoModifiers . Num ( ) > MAX_UNDOREDO ) { undoModifiers . RemoveIndex ( 0 ) ; } if ( clearRedo ) { ClearRedo ( ) ; } }
void MaterialDocManager :: AddMaterialRedoModifier ( MaterialModifier * mod ) { redoModifiers . Append ( mod ) ; while ( redoModifiers . Num ( ) > MAX_UNDOREDO ) { redoModifiers . RemoveIndex ( 0 ) ; } }
bool MaterialDocManager :: FindMaterial ( const char * name , MaterialSearchData_t * searchData , bool checkName ) { const idMaterial * material = static_cast < const idMaterial * > ( declManager -> FindDeclWithoutParsing ( DECL_MATERIAL , name , false ) ) ; if ( material ) { int findPos ; if ( checkName ) { idStr name = material -> GetName ( ) ; findPos = name . Find ( searchData -> searchText , false ) ; if ( findPos != - 1 ) { return true ; } } char * declText = ( char * ) _alloca ( material -> GetTextLength ( ) + 1 ) ; material -> GetText ( declText ) ; idStr text = declText ; int start = text . Find ( " { " ) ; if ( start != - 1 ) { text = text . Right ( text . Length ( ) - start ) ; } findPos = text . Find ( searchData -> searchText , false ) ; if ( findPos != - 1 ) { return true ; } } return false ; }
idStr MaterialDocManager :: GetUniqueMaterialName ( idStr name ) { int num = 0 ; while ( 1 ) { idStr testName ; if ( num == 0 ) testName = name ; else testName = va ( " % s % d " , name . c_str ( ) , num ) ; const idMaterial * mat = declManager -> FindMaterial ( testName . c_str ( ) , false ) ; if ( ! mat ) { return testName ; } else { if ( mat -> GetTextLength ( ) < 1 ) return testName ; } num ++ ; } }
void MaterialDocManager :: NotifyViews ( MaterialDoc * materialDoc , int notifyType , ... ) { va_list argptr ; int c = materialViews . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { va_start ( argptr , notifyType ) ; switch ( notifyType ) { case SELECTION_CHANGE : materialViews [ i ] -> MV_OnMaterialSelectionChange ( materialDoc ) ; break ; case MATERIAL_CHANGE : materialViews [ i ] -> MV_OnMaterialChange ( materialDoc ) ; break ; case MATERIAL_APPLY : materialViews [ i ] -> MV_OnMaterialApply ( materialDoc ) ; break ; case MATERIAL_SAVE : materialViews [ i ] -> MV_OnMaterialSaved ( materialDoc ) ; break ; case MATERIAL_SAVE_FILE : materialViews [ i ] -> MV_OnMaterialSaveFile ( va_arg ( argptr , const char * ) ) ; break ; case MATERIAL_ADD : materialViews [ i ] -> MV_OnMaterialAdd ( materialDoc ) ; break ; case MATERIAL_DELETE : materialViews [ i ] -> MV_OnMaterialDelete ( materialDoc ) ; break ; case MATERIAL_ADD_STAGE : materialViews [ i ] -> MV_OnMaterialStageAdd ( materialDoc , va_arg ( argptr , int ) ) ; break ; case MATERIAL_DELETE_STAGE : materialViews [ i ] -> MV_OnMaterialStageDelete ( materialDoc , va_arg ( argptr , int ) ) ; break ; case MATERIAL_MOVE_STAGE : { int from = va_arg ( argptr , int ) ; int to = va_arg ( argptr , int ) ; materialViews [ i ] -> MV_OnMaterialStageMove ( materialDoc , from , to ) ; } break ; case MATERIAL_ATTRIBUTE_CHANGE : { int stage = va_arg ( argptr , int ) ; const char * attribName = va_arg ( argptr , const char * ) ; materialViews [ i ] -> MV_OnMaterialAttributeChanged ( materialDoc , stage , attribName ) ; } break ; case MATERIAL_NAME_CHANGE : { const char * oldName = va_arg ( argptr , const char * ) ; materialViews [ i ] -> MV_OnMaterialNameChanged ( materialDoc , oldName ) ; } break ; case FILE_RELOAD : { const char * filename = va_arg ( argptr , const char * ) ; materialViews [ i ] -> MV_OnFileReload ( filename ) ; } break ; } va_end ( argptr ) ; } }
void MaterialDocManager :: MaterialChanged ( MaterialDoc * materialDoc ) { if ( ! inProgressMaterials . Get ( materialDoc -> name . c_str ( ) ) ) { inProgressMaterials . Set ( materialDoc -> name . c_str ( ) , materialDoc ) ; } NotifyViews ( materialDoc , MATERIAL_CHANGE ) ; }
void MaterialDocManager :: MaterialApplied ( MaterialDoc * materialDoc ) { NotifyViews ( materialDoc , MATERIAL_APPLY ) ; }
void MaterialDocManager :: MaterialSaved ( MaterialDoc * materialDoc ) { MaterialDoc * * tempDoc ; if ( inProgressMaterials . Get ( materialDoc -> name . c_str ( ) , & tempDoc ) ) { idStr name = materialDoc -> name . c_str ( ) ; inProgressMaterials . Remove ( name . c_str ( ) ) ; NotifyViews ( materialDoc , MATERIAL_SAVE ) ; if ( materialDoc != currentMaterial ) delete materialDoc ; } }
void MaterialDocManager :: MaterialNameChanged ( const char * oldName , MaterialDoc * materialDoc ) { MaterialDoc * * tempDoc ; if ( inProgressMaterials . Get ( oldName , & tempDoc ) ) { inProgressMaterials . Set ( materialDoc -> name , * tempDoc ) ; inProgressMaterials . Remove ( oldName ) ; } NotifyViews ( materialDoc , MATERIAL_NAME_CHANGE , oldName ) ; }
void MaterialDocManager :: StageAdded ( MaterialDoc * materialDoc , int stageNum ) { NotifyViews ( materialDoc , MATERIAL_ADD_STAGE , stageNum ) ; }
void MaterialDocManager :: StageDeleted ( MaterialDoc * materialDoc , int stageNum ) { NotifyViews ( materialDoc , MATERIAL_DELETE_STAGE , stageNum ) ; }
void MaterialDocManager :: StageMoved ( MaterialDoc * materialDoc , int from , int to ) { NotifyViews ( materialDoc , MATERIAL_MOVE_STAGE , from , to ) ; }
void MaterialDocManager :: AttributeChanged ( MaterialDoc * materialDoc , int stage , const char * attribName ) { NotifyViews ( materialDoc , MATERIAL_ATTRIBUTE_CHANGE , stage , attribName ) ; }
BattlegroundAB :: BattlegroundAB ( ) { m_IsInformedNearVictory = false ; m_BuffChange = true ; BgObjects . resize ( BG_AB_OBJECT_MAX ) ; BgCreatures . resize ( BG_AB_ALL_NODES_COUNT + 5 ) ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { m_Nodes [ i ] = 0 ; m_prevNodes [ i ] = 0 ; m_NodeTimers [ i ] = 0 ; m_BannerTimers [ i ] . timer = 0 ; m_BannerTimers [ i ] . type = 0 ; m_BannerTimers [ i ] . teamIndex = 0 ; } for ( uint8 i = 0 ; i < BG_TEAMS_COUNT ; ++ i ) { m_lastTick [ i ] = 0 ; m_HonorScoreTics [ i ] = 0 ; m_ReputationScoreTics [ i ] = 0 ; m_TeamScores500Disadvantage [ i ] = false ; } m_HonorTics = 0 ; m_ReputationTics = 0 ; StartMessageIds [ BG_STARTING_EVENT_FIRST ] = LANG_BG_AB_START_TWO_MINUTES ; StartMessageIds [ BG_STARTING_EVENT_SECOND ] = LANG_BG_AB_START_ONE_MINUTE ; StartMessageIds [ BG_STARTING_EVENT_THIRD ] = LANG_BG_AB_START_HALF_MINUTE ; StartMessageIds [ BG_STARTING_EVENT_FOURTH ] = LANG_BG_AB_HAS_BEGUN ; }
void BattlegroundAB :: PostUpdateImpl ( uint32 diff ) { if ( GetStatus ( ) == STATUS_IN_PROGRESS ) { int team_points [ BG_TEAMS_COUNT ] = { 0 , 0 } ; for ( int node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) { if ( m_BannerTimers [ node ] . timer ) { if ( m_BannerTimers [ node ] . timer > diff ) m_BannerTimers [ node ] . timer -= diff ; else { m_BannerTimers [ node ] . timer = 0 ; _CreateBanner ( node , m_BannerTimers [ node ] . type , m_BannerTimers [ node ] . teamIndex , false ) ; } } if ( m_NodeTimers [ node ] ) { if ( m_NodeTimers [ node ] > diff ) m_NodeTimers [ node ] -= diff ; else { m_NodeTimers [ node ] = 0 ; uint8 teamIndex = m_Nodes [ node ] - 1 ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] += 2 ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; _NodeOccupied ( node , ( teamIndex == 0 ) ? ALLIANCE : HORDE ) ; if ( teamIndex == 0 ) { SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_ALLIANCE , NULL , LANG_BG_AB_ALLY , _GetNodeNameId ( node ) ) ; PlaySoundToAll ( BG_AB_SOUND_NODE_CAPTURED_ALLIANCE ) ; } else { SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_HORDE , NULL , LANG_BG_AB_HORDE , _GetNodeNameId ( node ) ) ; PlaySoundToAll ( BG_AB_SOUND_NODE_CAPTURED_HORDE ) ; } } } for ( int team = 0 ; team < BG_TEAMS_COUNT ; ++ team ) if ( m_Nodes [ node ] == team + BG_AB_NODE_TYPE_OCCUPIED ) ++ team_points [ team ] ; } for ( int team = 0 ; team < BG_TEAMS_COUNT ; ++ team ) { int points = team_points [ team ] ; if ( ! points ) continue ; m_lastTick [ team ] += diff ; if ( m_lastTick [ team ] > BG_AB_TickIntervals [ points ] ) { m_lastTick [ team ] -= BG_AB_TickIntervals [ points ] ; m_TeamScores [ team ] += BG_AB_TickPoints [ points ] ; m_HonorScoreTics [ team ] += BG_AB_TickPoints [ points ] ; m_ReputationScoreTics [ team ] += BG_AB_TickPoints [ points ] ; if ( m_ReputationScoreTics [ team ] >= m_ReputationTics ) { ( team == TEAM_ALLIANCE ) ? RewardReputationToTeam ( 509 , 10 , ALLIANCE ) : RewardReputationToTeam ( 510 , 10 , HORDE ) ; m_ReputationScoreTics [ team ] -= m_ReputationTics ; } if ( m_HonorScoreTics [ team ] >= m_HonorTics ) { RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ( team == TEAM_ALLIANCE ) ? ALLIANCE : HORDE ) ; m_HonorScoreTics [ team ] -= m_HonorTics ; } if ( ! m_IsInformedNearVictory && m_TeamScores [ team ] > BG_AB_WARNING_NEAR_VICTORY_SCORE ) { if ( team == TEAM_ALLIANCE ) SendMessageToAll ( LANG_BG_AB_A_NEAR_VICTORY , CHAT_MSG_BG_SYSTEM_NEUTRAL ) ; else SendMessageToAll ( LANG_BG_AB_H_NEAR_VICTORY , CHAT_MSG_BG_SYSTEM_NEUTRAL ) ; PlaySoundToAll ( BG_AB_SOUND_NEAR_VICTORY ) ; m_IsInformedNearVictory = true ; } if ( m_TeamScores [ team ] > BG_AB_MAX_TEAM_SCORE ) m_TeamScores [ team ] = BG_AB_MAX_TEAM_SCORE ; if ( team == TEAM_ALLIANCE ) UpdateWorldState ( BG_AB_OP_RESOURCES_ALLY , m_TeamScores [ team ] ) ; else if ( team == TEAM_HORDE ) UpdateWorldState ( BG_AB_OP_RESOURCES_HORDE , m_TeamScores [ team ] ) ; uint8 otherTeam = ( team + 1 ) % BG_TEAMS_COUNT ; if ( m_TeamScores [ team ] > m_TeamScores [ otherTeam ] + 500 ) m_TeamScores500Disadvantage [ otherTeam ] = true ; } } if ( m_TeamScores [ TEAM_ALLIANCE ] >= BG_AB_MAX_TEAM_SCORE ) EndBattleground ( ALLIANCE ) ; else if ( m_TeamScores [ TEAM_HORDE ] >= BG_AB_MAX_TEAM_SCORE ) EndBattleground ( HORDE ) ; } }
void BattlegroundAB :: StartingEventCloseDoors ( ) { for ( int obj = BG_AB_OBJECT_BANNER_NEUTRAL ; obj < BG_AB_DYNAMIC_NODES_COUNT * 8 ; ++ obj ) SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT * 3 ; ++ i ) SpawnBGObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + i , RESPAWN_ONE_DAY ) ; DoorClose ( BG_AB_OBJECT_GATE_A ) ; DoorClose ( BG_AB_OBJECT_GATE_H ) ; SpawnBGObject ( BG_AB_OBJECT_GATE_A , RESPAWN_IMMEDIATELY ) ; SpawnBGObject ( BG_AB_OBJECT_GATE_H , RESPAWN_IMMEDIATELY ) ; _NodeOccupied ( BG_AB_SPIRIT_ALIANCE , ALLIANCE ) ; _NodeOccupied ( BG_AB_SPIRIT_HORDE , HORDE ) ; }
void BattlegroundAB :: StartingEventOpenDoors ( ) { for ( int banner = BG_AB_OBJECT_BANNER_NEUTRAL , i = 0 ; i < 5 ; banner += 8 , ++ i ) SpawnBGObject ( banner , RESPAWN_IMMEDIATELY ) ; for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { uint8 buff = urand ( 0 , 2 ) ; SpawnBGObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + buff + i * 3 , RESPAWN_IMMEDIATELY ) ; } DoorOpen ( BG_AB_OBJECT_GATE_A ) ; DoorOpen ( BG_AB_OBJECT_GATE_H ) ; StartTimedAchievement ( ACHIEVEMENT_TIMED_TYPE_EVENT , AB_EVENT_START_BATTLE ) ; }
void BattlegroundAB :: AddPlayer ( Player * player ) { Battleground :: AddPlayer ( player ) ; PlayerScores [ player -> GetGUID ( ) ] = new BattlegroundABScore ( player -> GetGUID ( ) , player -> GetBGTeam ( ) ) ; }
void BattlegroundAB :: HandleAreaTrigger ( Player * player , uint32 trigger , bool entered ) { if ( GetStatus ( ) != STATUS_IN_PROGRESS ) return ; switch ( trigger ) { case 3948 : if ( player -> GetTeam ( ) != ALLIANCE ) player -> GetSession ( ) -> SendNotification ( " Only ▁ The ▁ Alliance ▁ can ▁ use ▁ that ▁ portal " ) ; else player -> LeaveBattleground ( ) ; break ; case 3949 : if ( player -> GetTeam ( ) != HORDE ) player -> GetSession ( ) -> SendNotification ( " Only ▁ The ▁ Horde ▁ can ▁ use ▁ that ▁ portal " ) ; else player -> LeaveBattleground ( ) ; break ; case 3866 : case 3869 : case 3867 : case 3868 : case 3870 : case 4020 : case 4021 : case 4674 : default : Battleground :: HandleAreaTrigger ( player , trigger , entered ) ; break ; } }
void BattlegroundAB :: _CreateBanner ( uint8 node , uint8 type , uint8 teamIndex , bool delay ) { if ( delay ) { m_BannerTimers [ node ] . timer = 2000 ; m_BannerTimers [ node ] . type = type ; m_BannerTimers [ node ] . teamIndex = teamIndex ; return ; } uint8 obj = node * 8 + type + teamIndex ; SpawnBGObject ( obj , RESPAWN_IMMEDIATELY ) ; if ( ! type ) return ; obj = node * 8 + ( ( type == BG_AB_NODE_TYPE_OCCUPIED ) ? ( 5 + teamIndex ) : 7 ) ; SpawnBGObject ( obj , RESPAWN_IMMEDIATELY ) ; }
void BattlegroundAB :: _DelBanner ( uint8 node , uint8 type , uint8 teamIndex ) { uint8 obj = node * 8 + type + teamIndex ; SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; if ( ! type ) return ; obj = node * 8 + ( ( type == BG_AB_NODE_TYPE_OCCUPIED ) ? ( 5 + teamIndex ) : 7 ) ; SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; }
int32 BattlegroundAB :: _GetNodeNameId ( uint8 node ) { switch ( node ) { case BG_AB_NODE_STABLES : return LANG_BG_AB_NODE_STABLES ; case BG_AB_NODE_BLACKSMITH : return LANG_BG_AB_NODE_BLACKSMITH ; case BG_AB_NODE_FARM : return LANG_BG_AB_NODE_FARM ; case BG_AB_NODE_LUMBER_MILL : return LANG_BG_AB_NODE_LUMBER_MILL ; case BG_AB_NODE_GOLD_MINE : return LANG_BG_AB_NODE_GOLD_MINE ; default : ABORT ( ) ; } return 0 ; }
void BattlegroundAB :: FillInitialWorldStates ( WorldPackets :: WorldState :: InitWorldStates & packet ) { const uint8 plusArray [ ] = { 0 , 2 , 3 , 0 , 1 } ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_NODEICONS [ node ] ) , int32 ( ( m_Nodes [ node ] == 0 ) ? 1 : 0 ) ) ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) for ( uint8 i = 1 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_NODESTATES [ node ] + plusArray [ i ] ) , int32 ( ( m_Nodes [ node ] == i ) ? 1 : 0 ) ) ; uint8 ally = 0 , horde = 0 ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) if ( m_Nodes [ node ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ node ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_OCCUPIED_BASES_ALLY ) , int32 ( ally ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_OCCUPIED_BASES_HORDE ) , int32 ( horde ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_MAX ) , int32 ( BG_AB_MAX_TEAM_SCORE ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_WARNING ) , int32 ( BG_AB_WARNING_NEAR_VICTORY_SCORE ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_ALLY ) , int32 ( m_TeamScores [ TEAM_ALLIANCE ] ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_HORDE ) , int32 ( m_TeamScores [ TEAM_HORDE ] ) ) ; packet . Worldstates . emplace_back ( uint32 ( 0x745 ) , 0x2 ) ; }
void BattlegroundAB :: _SendNodeUpdate ( uint8 node ) { const uint8 plusArray [ ] = { 0 , 2 , 3 , 0 , 1 } ; if ( m_prevNodes [ node ] ) UpdateWorldState ( BG_AB_OP_NODESTATES [ node ] + plusArray [ m_prevNodes [ node ] ] , 0 ) ; else UpdateWorldState ( BG_AB_OP_NODEICONS [ node ] , 0 ) ; UpdateWorldState ( BG_AB_OP_NODESTATES [ node ] + plusArray [ m_Nodes [ node ] ] , 1 ) ; uint8 ally = 0 , horde = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; UpdateWorldState ( BG_AB_OP_OCCUPIED_BASES_ALLY , ally ) ; UpdateWorldState ( BG_AB_OP_OCCUPIED_BASES_HORDE , horde ) ; }
void BattlegroundAB :: _NodeOccupied ( uint8 node , Team team ) { if ( ! AddSpiritGuide ( node , BG_AB_SpiritGuidePos [ node ] , GetTeamIndexByTeamId ( team ) ) ) TC_LOG_ERROR ( " bg . battleground " , " Failed ▁ to ▁ spawn ▁ spirit ▁ guide ! ▁ point : ▁ % u , ▁ team : ▁ % u , ▁ " , node , team ) ; if ( node >= BG_AB_DYNAMIC_NODES_COUNT ) return ; uint8 capturedNodes = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == GetTeamIndexByTeamId ( team ) + BG_AB_NODE_TYPE_OCCUPIED && ! m_NodeTimers [ i ] ) ++ capturedNodes ; if ( capturedNodes >= 5 ) CastSpellOnTeam ( SPELL_AB_QUEST_REWARD_5_BASES , team ) ; if ( capturedNodes >= 4 ) CastSpellOnTeam ( SPELL_AB_QUEST_REWARD_4_BASES , team ) ; Creature * trigger = ! BgCreatures [ node + 7 ] ? GetBGCreature ( node + 7 ) : NULL ; if ( ! trigger ) trigger = AddCreature ( WORLD_TRIGGER , node + 7 , BG_AB_NodePositions [ node ] , GetTeamIndexByTeamId ( team ) ) ; if ( trigger ) { trigger -> setFaction ( team == ALLIANCE ? 84 : 83 ) ; trigger -> CastSpell ( trigger , SPELL_HONORABLE_DEFENDER_25Y , false ) ; } }
void BattlegroundAB :: _NodeDeOccupied ( uint8 node ) { if ( node >= BG_AB_DYNAMIC_NODES_COUNT ) return ; if ( node < BG_AB_DYNAMIC_NODES_COUNT ) DelCreature ( node + 7 ) ; RelocateDeadPlayers ( BgCreatures [ node ] ) ; DelCreature ( node ) ; }
void BattlegroundAB :: EventPlayerClickedOnFlag ( Player * source , GameObject * ) { if ( GetStatus ( ) != STATUS_IN_PROGRESS ) return ; uint8 node = BG_AB_NODE_STABLES ; GameObject * obj = GetBgMap ( ) -> GetGameObject ( BgObjects [ node * 8 + 7 ] ) ; while ( ( node < BG_AB_DYNAMIC_NODES_COUNT ) && ( ( ! obj ) || ( ! source -> IsWithinDistInMap ( obj , 10 ) ) ) ) { ++ node ; obj = GetBgMap ( ) -> GetGameObject ( BgObjects [ node * 8 + BG_AB_OBJECT_AURA_CONTESTED ] ) ; } if ( node == BG_AB_DYNAMIC_NODES_COUNT ) { return ; } TeamId teamIndex = GetTeamIndexByTeamId ( source -> GetTeam ( ) ) ; if ( ! ( m_Nodes [ node ] == 0 || teamIndex == m_Nodes [ node ] % 2 ) ) return ; source -> RemoveAurasWithInterruptFlags ( AURA_INTERRUPT_FLAG_ENTER_PVP_COMBAT ) ; uint32 sound = 0 ; if ( m_Nodes [ node ] == BG_AB_NODE_TYPE_NEUTRAL ) { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + 1 ; _DelBanner ( node , BG_AB_NODE_TYPE_NEUTRAL , 0 ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == 0 ) SendMessage2ToAll ( LANG_BG_AB_NODE_CLAIMED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) , LANG_BG_AB_ALLY ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_CLAIMED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) , LANG_BG_AB_HORDE ) ; sound = BG_AB_SOUND_NODE_CLAIMED ; } else if ( ( m_Nodes [ node ] == BG_AB_NODE_STATUS_ALLY_CONTESTED ) || ( m_Nodes [ node ] == BG_AB_NODE_STATUS_HORDE_CONTESTED ) ) { if ( m_prevNodes [ node ] < BG_AB_NODE_TYPE_OCCUPIED ) { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_CONTESTED ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; } else { UpdatePlayerScore ( source , SCORE_BASES_DEFENDED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_OCCUPIED ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = 0 ; _NodeOccupied ( node , ( teamIndex == TEAM_ALLIANCE ) ? ALLIANCE : HORDE ) ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_DEFENDED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_DEFENDED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; } sound = ( teamIndex == TEAM_ALLIANCE ) ? BG_AB_SOUND_NODE_ASSAULTED_ALLIANCE : BG_AB_SOUND_NODE_ASSAULTED_HORDE ; } else { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_CONTESTED ; _DelBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; _NodeDeOccupied ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; sound = ( teamIndex == TEAM_ALLIANCE ) ? BG_AB_SOUND_NODE_ASSAULTED_ALLIANCE : BG_AB_SOUND_NODE_ASSAULTED_HORDE ; } if ( m_Nodes [ node ] >= BG_AB_NODE_TYPE_OCCUPIED ) { if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_ALLIANCE , NULL , LANG_BG_AB_ALLY , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_HORDE , NULL , LANG_BG_AB_HORDE , _GetNodeNameId ( node ) ) ; } PlaySoundToAll ( sound ) ; }
uint32 BattlegroundAB :: GetPrematureWinner ( ) { uint8 ally = 0 , horde = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; if ( ally > horde ) return ALLIANCE ; else if ( horde > ally ) return HORDE ; return Battleground :: GetPrematureWinner ( ) ; }
bool BattlegroundAB :: SetupBattleground ( ) { for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { if ( ! AddObject ( BG_AB_OBJECT_BANNER_NEUTRAL + 8 * i , BG_AB_OBJECTID_NODE_BANNER_0 + i , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_CONT_A + 8 * i , BG_AB_OBJECTID_BANNER_CONT_A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_CONT_H + 8 * i , BG_AB_OBJECTID_BANNER_CONT_H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_ALLY + 8 * i , BG_AB_OBJECTID_BANNER_A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_HORDE + 8 * i , BG_AB_OBJECTID_BANNER_H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_ALLY + 8 * i , BG_AB_OBJECTID_AURA_A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_HORDE + 8 * i , BG_AB_OBJECTID_AURA_H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_CONTESTED + 8 * i , BG_AB_OBJECTID_AURA_C , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) ) { TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ some ▁ object ▁ Battleground ▁ not ▁ created ! " ) ; return false ; } } if ( ! AddObject ( BG_AB_OBJECT_GATE_A , BG_AB_OBJECTID_GATE_A , BG_AB_DoorPositions [ 0 ] [ 0 ] , BG_AB_DoorPositions [ 0 ] [ 1 ] , BG_AB_DoorPositions [ 0 ] [ 2 ] , BG_AB_DoorPositions [ 0 ] [ 3 ] , BG_AB_DoorPositions [ 0 ] [ 4 ] , BG_AB_DoorPositions [ 0 ] [ 5 ] , BG_AB_DoorPositions [ 0 ] [ 6 ] , BG_AB_DoorPositions [ 0 ] [ 7 ] , RESPAWN_IMMEDIATELY ) || ! AddObject ( BG_AB_OBJECT_GATE_H , BG_AB_OBJECTID_GATE_H , BG_AB_DoorPositions [ 1 ] [ 0 ] , BG_AB_DoorPositions [ 1 ] [ 1 ] , BG_AB_DoorPositions [ 1 ] [ 2 ] , BG_AB_DoorPositions [ 1 ] [ 3 ] , BG_AB_DoorPositions [ 1 ] [ 4 ] , BG_AB_DoorPositions [ 1 ] [ 5 ] , BG_AB_DoorPositions [ 1 ] [ 6 ] , BG_AB_DoorPositions [ 1 ] [ 7 ] , RESPAWN_IMMEDIATELY ) ) { TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ door ▁ object ▁ Battleground ▁ not ▁ created ! " ) ; return false ; } for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { if ( ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i , Buff_Entries [ 0 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i + 1 , Buff_Entries [ 1 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i + 2 , Buff_Entries [ 2 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) ) TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ buff ▁ object ! " ) ; } return true ; }
void BattlegroundAB :: Reset ( ) { Battleground :: Reset ( ) ; m_TeamScores [ TEAM_ALLIANCE ] = 0 ; m_TeamScores [ TEAM_HORDE ] = 0 ; m_lastTick [ TEAM_ALLIANCE ] = 0 ; m_lastTick [ TEAM_HORDE ] = 0 ; m_HonorScoreTics [ TEAM_ALLIANCE ] = 0 ; m_HonorScoreTics [ TEAM_HORDE ] = 0 ; m_ReputationScoreTics [ TEAM_ALLIANCE ] = 0 ; m_ReputationScoreTics [ TEAM_HORDE ] = 0 ; m_IsInformedNearVictory = false ; bool isBGWeekend = sBattlegroundMgr -> IsBGWeekend ( GetTypeID ( ) ) ; m_HonorTics = ( isBGWeekend ) ? BG_AB_ABBGWeekendHonorTicks : BG_AB_NotABBGWeekendHonorTicks ; m_ReputationTics = ( isBGWeekend ) ? BG_AB_ABBGWeekendReputationTicks : BG_AB_NotABBGWeekendReputationTicks ; m_TeamScores500Disadvantage [ TEAM_ALLIANCE ] = false ; m_TeamScores500Disadvantage [ TEAM_HORDE ] = false ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { m_Nodes [ i ] = 0 ; m_prevNodes [ i ] = 0 ; m_NodeTimers [ i ] = 0 ; m_BannerTimers [ i ] . timer = 0 ; } for ( uint8 i = 0 ; i < BG_AB_ALL_NODES_COUNT + 5 ; ++ i ) if ( ! BgCreatures [ i ] . IsEmpty ( ) ) DelCreature ( i ) ; }
void BattlegroundAB :: EndBattleground ( uint32 winner ) { if ( winner == ALLIANCE ) RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ALLIANCE ) ; if ( winner == HORDE ) RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , HORDE ) ; RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , HORDE ) ; RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ALLIANCE ) ; Battleground :: EndBattleground ( winner ) ; }
WorldSafeLocsEntry const * BattlegroundAB :: GetClosestGraveYard ( Player * player ) { TeamId teamIndex = GetTeamIndexByTeamId ( player -> GetTeam ( ) ) ; std :: vector < uint8 > nodes ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == teamIndex + 3 ) nodes . push_back ( i ) ; WorldSafeLocsEntry const * good_entry = NULL ; if ( ! nodes . empty ( ) ) { float plr_x = player -> GetPositionX ( ) ; float plr_y = player -> GetPositionY ( ) ; float mindist = 999999.0f ; for ( uint8 i = 0 ; i < nodes . size ( ) ; ++ i ) { WorldSafeLocsEntry const * entry = sWorldSafeLocsStore . LookupEntry ( BG_AB_GraveyardIds [ nodes [ i ] ] ) ; if ( ! entry ) continue ; float dist = ( entry -> Loc . X - plr_x ) * ( entry -> Loc . X - plr_x ) + ( entry -> Loc . Y - plr_y ) * ( entry -> Loc . Y - plr_y ) ; if ( mindist > dist ) { mindist = dist ; good_entry = entry ; } } nodes . clear ( ) ; } if ( ! good_entry ) good_entry = sWorldSafeLocsStore . LookupEntry ( BG_AB_GraveyardIds [ teamIndex + 5 ] ) ; return good_entry ; }
bool BattlegroundAB :: UpdatePlayerScore ( Player * player , uint32 type , uint32 value , bool doAddHonor ) { if ( ! Battleground :: UpdatePlayerScore ( player , type , value , doAddHonor ) ) return false ; switch ( type ) { case SCORE_BASES_ASSAULTED : player -> UpdateAchievementCriteria ( ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE , AB_OBJECTIVE_ASSAULT_BASE ) ; break ; case SCORE_BASES_DEFENDED : player -> UpdateAchievementCriteria ( ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE , AB_OBJECTIVE_DEFEND_BASE ) ; break ; default : break ; } return true ; }
bool BattlegroundAB :: CheckAchievementCriteriaMeet ( uint32 criteriaId , Player const * player , Unit const * target , uint32 miscvalue ) { switch ( criteriaId ) { case BG_CRITERIA_CHECK_RESILIENT_VICTORY : return m_TeamScores500Disadvantage [ GetTeamIndexByTeamId ( player -> GetTeam ( ) ) ] ; } return Battleground :: CheckAchievementCriteriaMeet ( criteriaId , player , target , miscvalue ) ; }
void AbstractState :: beginBasicBlock ( BasicBlock * basicBlock ) { ASSERT ( ! m_block ) ; ASSERT ( basicBlock -> variablesAtHead . numberOfLocals ( ) == basicBlock -> valuesAtHead . numberOfLocals ( ) ) ; ASSERT ( basicBlock -> variablesAtTail . numberOfLocals ( ) == basicBlock -> valuesAtTail . numberOfLocals ( ) ) ; ASSERT ( basicBlock -> variablesAtHead . numberOfLocals ( ) == basicBlock -> variablesAtTail . numberOfLocals ( ) ) ; for ( size_t i = 0 ; i < basicBlock -> size ( ) ; i ++ ) forNode ( basicBlock -> at ( i ) ) . clear ( ) ; m_variables = basicBlock -> valuesAtHead ; m_haveStructures = false ; for ( size_t i = 0 ; i < m_variables . numberOfArguments ( ) ; ++ i ) { if ( m_variables . argument ( i ) . m_currentKnownStructure . isNeitherClearNorTop ( ) ) { m_haveStructures = true ; break ; } } for ( size_t i = 0 ; i < m_variables . numberOfLocals ( ) ; ++ i ) { if ( m_variables . local ( i ) . m_currentKnownStructure . isNeitherClearNorTop ( ) ) { m_haveStructures = true ; break ; } } basicBlock -> cfaShouldRevisit = false ; basicBlock -> cfaHasVisited = true ; m_block = basicBlock ; m_isValid = true ; m_foundConstants = false ; m_branchDirection = InvalidBranchDirection ; }
void AbstractState :: initialize ( Graph & graph ) { BasicBlock * root = graph . m_blocks [ 0 ] . get ( ) ; root -> cfaShouldRevisit = true ; root -> cfaHasVisited = false ; root -> cfaFoundConstants = false ; for ( size_t i = 0 ; i < root -> valuesAtHead . numberOfArguments ( ) ; ++ i ) { Node * node = root -> variablesAtHead . argument ( i ) ; ASSERT ( node -> op ( ) == SetArgument ) ; if ( ! node -> variableAccessData ( ) -> shouldUnboxIfPossible ( ) ) { root -> valuesAtHead . argument ( i ) . makeTop ( ) ; continue ; } SpeculatedType prediction = node -> variableAccessData ( ) -> prediction ( ) ; if ( isInt32Speculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecInt32 ) ; else if ( isBooleanSpeculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecBoolean ) ; else if ( isCellSpeculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecCell ) ; else root -> valuesAtHead . argument ( i ) . makeTop ( ) ; root -> valuesAtTail . argument ( i ) . clear ( ) ; } for ( size_t i = 0 ; i < root -> valuesAtHead . numberOfLocals ( ) ; ++ i ) { Node * node = root -> variablesAtHead . local ( i ) ; if ( node && node -> variableAccessData ( ) -> isCaptured ( ) ) root -> valuesAtHead . local ( i ) . makeTop ( ) ; else root -> valuesAtHead . local ( i ) . clear ( ) ; root -> valuesAtTail . local ( i ) . clear ( ) ; } for ( BlockIndex blockIndex = 1 ; blockIndex < graph . m_blocks . size ( ) ; ++ blockIndex ) { BasicBlock * block = graph . m_blocks [ blockIndex ] . get ( ) ; if ( ! block ) continue ; if ( ! block -> isReachable ) continue ; block -> cfaShouldRevisit = false ; block -> cfaHasVisited = false ; block -> cfaFoundConstants = false ; for ( size_t i = 0 ; i < block -> valuesAtHead . numberOfArguments ( ) ; ++ i ) { block -> valuesAtHead . argument ( i ) . clear ( ) ; block -> valuesAtTail . argument ( i ) . clear ( ) ; } for ( size_t i = 0 ; i < block -> valuesAtHead . numberOfLocals ( ) ; ++ i ) { block -> valuesAtHead . local ( i ) . clear ( ) ; block -> valuesAtTail . local ( i ) . clear ( ) ; } if ( ! block -> isOSRTarget ) continue ; if ( block -> bytecodeBegin != graph . m_osrEntryBytecodeIndex ) continue ; for ( size_t i = 0 ; i < graph . m_mustHandleValues . size ( ) ; ++ i ) { AbstractValue value ; value . setMostSpecific ( graph . m_mustHandleValues [ i ] ) ; int operand = graph . m_mustHandleValues . operandForIndex ( i ) ; block -> valuesAtHead . operand ( operand ) . merge ( value ) ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ Initializing ▁ Block ▁ # % u , ▁ operand ▁ r % d , ▁ to ▁ " , blockIndex , operand ) ; block -> valuesAtHead . operand ( operand ) . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; } block -> cfaShouldRevisit = true ; } }
bool AbstractState :: endBasicBlock ( MergeMode mergeMode ) { ASSERT ( m_block ) ; BasicBlock * block = m_block ; block -> cfaFoundConstants = m_foundConstants ; block -> cfaDidFinish = m_isValid ; block -> cfaBranchDirection = m_branchDirection ; if ( ! m_isValid ) { reset ( ) ; return false ; } bool changed = false ; if ( mergeMode != DontMerge || ! ASSERT_DISABLED ) { for ( size_t argument = 0 ; argument < block -> variablesAtTail . numberOfArguments ( ) ; ++ argument ) { ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ state ▁ for ▁ argument ▁ % zu . \n " , argument ) ; AbstractValue & destination = block -> valuesAtTail . argument ( argument ) ; changed |= mergeStateAtTail ( destination , m_variables . argument ( argument ) , block -> variablesAtTail . argument ( argument ) ) ; } for ( size_t local = 0 ; local < block -> variablesAtTail . numberOfLocals ( ) ; ++ local ) { ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ state ▁ for ▁ local ▁ % zu . \n " , local ) ; AbstractValue & destination = block -> valuesAtTail . local ( local ) ; changed |= mergeStateAtTail ( destination , m_variables . local ( local ) , block -> variablesAtTail . local ( local ) ) ; } } ASSERT ( mergeMode != DontMerge || ! changed ) ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Branch ▁ direction ▁ = ▁ % s \n " , branchDirectionToString ( m_branchDirection ) ) ; reset ( ) ; if ( mergeMode != MergeToSuccessors ) return changed ; return mergeToSuccessors ( m_graph , block ) ; }
void AbstractState :: reset ( ) { m_block = 0 ; m_isValid = false ; m_branchDirection = InvalidBranchDirection ; }
AbstractState :: BooleanResult AbstractState :: booleanResult ( Node * node , AbstractValue & value ) { JSValue childConst = value . value ( ) ; if ( childConst ) { if ( childConst . toBoolean ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> globalExec ( ) ) ) return DefinitelyTrue ; return DefinitelyFalse ; } if ( isCellSpeculation ( value . m_type ) && value . m_currentKnownStructure . hasSingleton ( ) ) { Structure * structure = value . m_currentKnownStructure . singleton ( ) ; if ( ! structure -> masqueradesAsUndefined ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) ) && structure -> typeInfo ( ) . type ( ) != StringType ) return DefinitelyTrue ; } return UnknownBooleanResult ; }
bool AbstractState :: startExecuting ( Node * node ) { ASSERT ( m_block ) ; ASSERT ( m_isValid ) ; m_didClobber = false ; node -> setCanExit ( false ) ; if ( ! node -> shouldGenerate ( ) ) return false ; return true ; }
bool AbstractState :: startExecuting ( unsigned indexInBlock ) { return startExecuting ( m_block -> at ( indexInBlock ) ) ; }
void AbstractState :: executeEdges ( Node * node ) { DFG_NODE_DO_TO_CHILDREN ( m_graph , node , filterEdgeByUse ) ; }
void AbstractState :: executeEdges ( unsigned indexInBlock ) { executeEdges ( m_block -> at ( indexInBlock ) ) ; }
void AbstractState :: verifyEdge ( Node * , Edge edge ) { RELEASE_ASSERT ( ! ( forNode ( edge ) . m_type & ~ typeFilterFor ( edge . useKind ( ) ) ) ) ; }
void AbstractState :: verifyEdges ( Node * node ) { DFG_NODE_DO_TO_CHILDREN ( m_graph , node , verifyEdge ) ; }
bool AbstractState :: executeEffects ( unsigned indexInBlock , Node * node ) { if ( ! ASSERT_DISABLED ) verifyEdges ( node ) ; switch ( node -> op ( ) ) { case JSConstant : case WeakJSConstant : case PhantomArguments : { forNode ( node ) . set ( m_graph . valueOfJSConstant ( node ) ) ; break ; } case Identity : { forNode ( node ) = forNode ( node -> child1 ( ) ) ; break ; } case GetLocal : { VariableAccessData * variableAccessData = node -> variableAccessData ( ) ; if ( variableAccessData -> prediction ( ) == SpecNone ) { m_isValid = false ; break ; } AbstractValue value = m_variables . operand ( variableAccessData -> local ( ) ) ; if ( ! variableAccessData -> isCaptured ( ) ) { if ( value . isClear ( ) ) node -> setCanExit ( true ) ; } if ( value . value ( ) ) m_foundConstants = true ; forNode ( node ) = value ; break ; } case GetLocalUnlinked : { AbstractValue value = m_variables . operand ( node -> unlinkedLocal ( ) ) ; if ( value . value ( ) ) m_foundConstants = true ; forNode ( node ) = value ; break ; } case SetLocal : { m_variables . operand ( node -> local ( ) ) = forNode ( node -> child1 ( ) ) ; break ; } case MovHintAndCheck : { break ; } case MovHint : case ZombieHint : { RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } case SetArgument : ASSERT ( ! m_block -> valuesAtHead . operand ( node -> local ( ) ) . isClear ( ) ) ; break ; case BitAnd : case BitOr : case BitXor : case BitRShift : case BitLShift : case BitURShift : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isInt32 ( ) && right . isInt32 ( ) ) { int32_t a = left . asInt32 ( ) ; int32_t b = right . asInt32 ( ) ; bool constantWasSet ; switch ( node -> op ( ) ) { case BitAnd : constantWasSet = trySetConstant ( node , JSValue ( a & b ) ) ; break ; case BitOr : constantWasSet = trySetConstant ( node , JSValue ( a | b ) ) ; break ; case BitXor : constantWasSet = trySetConstant ( node , JSValue ( a ^ b ) ) ; break ; case BitRShift : constantWasSet = trySetConstant ( node , JSValue ( a >> static_cast < uint32_t > ( b ) ) ) ; break ; case BitLShift : constantWasSet = trySetConstant ( node , JSValue ( a << static_cast < uint32_t > ( b ) ) ) ; break ; case BitURShift : constantWasSet = trySetConstant ( node , JSValue ( static_cast < uint32_t > ( a ) >> static_cast < uint32_t > ( b ) ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecInt32 ) ; break ; } case UInt32ToNumber : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { ASSERT ( child . isInt32 ( ) ) ; if ( trySetConstant ( node , JSValue ( child . asUInt32 ( ) ) ) ) { m_foundConstants = true ; break ; } } if ( ! node -> canSpeculateInteger ( ) ) forNode ( node ) . set ( SpecDouble ) ; else { forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; } break ; } case DoubleAsInt32 : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { double asDouble = child . asNumber ( ) ; int32_t asInt = JSC :: toInt32 ( asDouble ) ; if ( bitwise_cast < int64_t > ( static_cast < double > ( asInt ) ) == bitwise_cast < int64_t > ( asDouble ) && trySetConstant ( node , JSValue ( asInt ) ) ) { m_foundConstants = true ; break ; } } node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecInt32 ) ; break ; } case ValueToInt32 : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { bool constantWasSet ; if ( child . isInt32 ( ) ) constantWasSet = trySetConstant ( node , child ) ; else constantWasSet = trySetConstant ( node , JSValue ( JSC :: toInt32 ( child . asDouble ( ) ) ) ) ; if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecInt32 ) ; break ; } case Int32ToDouble : case ForwardInt32ToDouble : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( JSValue :: EncodeAsDouble , child . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } if ( isInt32Speculation ( forNode ( node -> child1 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; } case ValueAdd : case ArithAdd : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) + right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : if ( isRealNumberSpeculation ( forNode ( node -> child1 ( ) ) . m_type ) && isRealNumberSpeculation ( forNode ( node -> child2 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT ( node -> op ( ) == ValueAdd ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . set ( SpecString | SpecInt32 | SpecNumber ) ; break ; } break ; } case MakeRope : { forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case ArithSub : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) - right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithNegate : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( - child . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithMul : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) * right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) || ! nodeCanIgnoreNegativeZero ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : if ( isRealNumberSpeculation ( forNode ( node -> child1 ( ) ) . m_type ) || isRealNumberSpeculation ( forNode ( node -> child2 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithIMul : { forNode ( node ) . set ( SpecInt32 ) ; break ; } case ArithDiv : case ArithMin : case ArithMax : case ArithMod : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) ) { double a = left . asNumber ( ) ; double b = right . asNumber ( ) ; bool constantWasSet ; switch ( node -> op ( ) ) { case ArithDiv : constantWasSet = trySetConstant ( node , JSValue ( a / b ) ) ; break ; case ArithMin : constantWasSet = trySetConstant ( node , JSValue ( a < b ? a : ( b <= a ? b : a + b ) ) ) ; break ; case ArithMax : constantWasSet = trySetConstant ( node , JSValue ( a > b ? a : ( b >= a ? b : a + b ) ) ) ; break ; case ArithMod : constantWasSet = trySetConstant ( node , JSValue ( fmod ( a , b ) ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; break ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithAbs : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( fabs ( child . asNumber ( ) ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithSqrt : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( sqrt ( child . asNumber ( ) ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecDouble ) ; break ; } case LogicalNot : { bool didSetConstant = false ; switch ( booleanResult ( node , forNode ( node -> child1 ( ) ) ) ) { case DefinitelyTrue : didSetConstant = trySetConstant ( node , jsBoolean ( false ) ) ; break ; case DefinitelyFalse : didSetConstant = trySetConstant ( node , jsBoolean ( true ) ) ; break ; default : break ; } if ( didSetConstant ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case BooleanUse : case Int32Use : case NumberUse : case UntypedUse : break ; case ObjectOrOtherUse : node -> setCanExit ( true ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( SpecBoolean ) ; break ; } case IsUndefined : case IsBoolean : case IsNumber : case IsString : case IsObject : case IsFunction : { node -> setCanExit ( node -> op ( ) == IsUndefined && m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> masqueradesAsUndefinedWatchpoint ( ) -> isStillValid ( ) ) ; JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child ) { bool constantWasSet ; switch ( node -> op ( ) ) { case IsUndefined : if ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> masqueradesAsUndefinedWatchpoint ( ) -> isStillValid ( ) ) { constantWasSet = trySetConstant ( node , jsBoolean ( child . isCell ( ) ? false : child . isUndefined ( ) ) ) ; } else { constantWasSet = trySetConstant ( node , jsBoolean ( child . isCell ( ) ? child . asCell ( ) -> structure ( ) -> masqueradesAsUndefined ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) ) : child . isUndefined ( ) ) ) ; } break ; case IsBoolean : constantWasSet = trySetConstant ( node , jsBoolean ( child . isBoolean ( ) ) ) ; break ; case IsNumber : constantWasSet = trySetConstant ( node , jsBoolean ( child . isNumber ( ) ) ) ; break ; case IsString : constantWasSet = trySetConstant ( node , jsBoolean ( isJSString ( child ) ) ) ; break ; case IsObject : if ( child . isNull ( ) || ! child . isObject ( ) ) { constantWasSet = trySetConstant ( node , jsBoolean ( child . isNull ( ) ) ) ; break ; } default : constantWasSet = false ; break ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecBoolean ) ; break ; } case TypeOf : { VM * vm = m_codeBlock -> vm ( ) ; JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; AbstractValue & abstractChild = forNode ( node -> child1 ( ) ) ; if ( child ) { JSValue typeString = jsTypeStringForValue ( * vm , m_codeBlock -> globalObjectFor ( node -> codeOrigin ) , child ) ; if ( trySetConstant ( node , typeString ) ) { m_foundConstants = true ; break ; } } else if ( isNumberSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . numberString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecNumber ) ; m_foundConstants = true ; break ; } } else if ( isStringSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . stringString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecString ) ; m_foundConstants = true ; break ; } } else if ( isFinalObjectSpeculation ( abstractChild . m_type ) || isArraySpeculation ( abstractChild . m_type ) || isArgumentsSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . objectString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecFinalObject | SpecArray | SpecArguments ) ; m_foundConstants = true ; break ; } } else if ( isFunctionSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . functionString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecFunction ) ; m_foundConstants = true ; break ; } } else if ( isBooleanSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . booleanString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecBoolean ) ; m_foundConstants = true ; break ; } } switch ( node -> child1 ( ) . useKind ( ) ) { case StringUse : case CellUse : node -> setCanExit ( true ) ; break ; case UntypedUse : break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case CompareLess : case CompareLessEq : case CompareGreater : case CompareGreaterEq : case CompareEq : case CompareEqConstant : { bool constantWasSet = false ; JSValue leftConst = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue rightConst = forNode ( node -> child2 ( ) ) . value ( ) ; if ( leftConst && rightConst && leftConst . isNumber ( ) && rightConst . isNumber ( ) ) { double a = leftConst . asNumber ( ) ; double b = rightConst . asNumber ( ) ; switch ( node -> op ( ) ) { case CompareLess : constantWasSet = trySetConstant ( node , jsBoolean ( a < b ) ) ; break ; case CompareLessEq : constantWasSet = trySetConstant ( node , jsBoolean ( a <= b ) ) ; break ; case CompareGreater : constantWasSet = trySetConstant ( node , jsBoolean ( a > b ) ) ; break ; case CompareGreaterEq : constantWasSet = trySetConstant ( node , jsBoolean ( a >= b ) ) ; break ; case CompareEq : constantWasSet = trySetConstant ( node , jsBoolean ( a == b ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; break ; } } if ( ! constantWasSet && ( node -> op ( ) == CompareEqConstant || node -> op ( ) == CompareEq ) ) { SpeculatedType leftType = forNode ( node -> child1 ( ) ) . m_type ; SpeculatedType rightType = forNode ( node -> child2 ( ) ) . m_type ; if ( ( isInt32Speculation ( leftType ) && isOtherSpeculation ( rightType ) ) || ( isOtherSpeculation ( leftType ) && isInt32Speculation ( rightType ) ) ) constantWasSet = trySetConstant ( node , jsBoolean ( false ) ) ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecBoolean ) ; node -> setCanExit ( true ) ; break ; } case CompareStrictEq : case CompareStrictEqConstant : { Node * leftNode = node -> child1 ( ) . node ( ) ; Node * rightNode = node -> child2 ( ) . node ( ) ; JSValue left = forNode ( leftNode ) . value ( ) ; JSValue right = forNode ( rightNode ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , jsBoolean ( left . asNumber ( ) == right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecBoolean ) ; node -> setCanExit ( true ) ; break ; } case StringCharCodeAt : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecInt32 ) ; break ; case StringFromCharCode : forNode ( node ) . set ( SpecString ) ; break ; case StringCharAt : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; case GetByVal : { node -> setCanExit ( true ) ; switch ( node -> arrayMode ( ) . type ( ) ) { case Array :: SelectUsingPredictions : case Array :: Unprofiled : case Array :: Undecided : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; case Array :: ForceExit : m_isValid = false ; break ; case Array :: Generic : clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case Array :: String : forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; case Array :: Arguments : forNode ( node ) . makeTop ( ) ; break ; case Array :: Int32 : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) { clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; } else forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Double : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) { clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; } else if ( node -> arrayMode ( ) . isSaneChain ( ) ) forNode ( node ) . set ( SpecDouble ) ; else forNode ( node ) . set ( SpecDoubleReal ) ; break ; case Array :: Contiguous : case Array :: ArrayStorage : case Array :: SlowPutArrayStorage : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case Array :: Int8Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Int16Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Int32Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint8Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint8ClampedArray : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint16Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint32Array : if ( node -> shouldSpeculateInteger ( ) ) forNode ( node ) . set ( SpecInt32 ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; case Array :: Float32Array : forNode ( node ) . set ( SpecDouble ) ; break ; case Array :: Float64Array : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case PutByVal : case PutByValAlias : { node -> setCanExit ( true ) ; switch ( node -> arrayMode ( ) . modeForPut ( ) . type ( ) ) { case Array :: ForceExit : m_isValid = false ; break ; case Array :: Generic : clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Int32 : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Double : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Contiguous : case Array :: ArrayStorage : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: SlowPutArrayStorage : if ( node -> arrayMode ( ) . mayStoreToHole ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; default : break ; } break ; } case ArrayPush : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . set ( SpecNumber ) ; break ; case ArrayPop : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case RegExpExec : forNode ( node ) . makeTop ( ) ; break ; case RegExpTest : forNode ( node ) . set ( SpecBoolean ) ; break ; case Jump : break ; case Branch : { Node * child = node -> child1 ( ) . node ( ) ; BooleanResult result = booleanResult ( node , forNode ( child ) ) ; if ( result == DefinitelyTrue ) { m_branchDirection = TakeTrue ; break ; } if ( result == DefinitelyFalse ) { m_branchDirection = TakeFalse ; break ; } node -> setCanExit ( true ) ; m_branchDirection = TakeBoth ; break ; } case Return : m_isValid = false ; break ; case Throw : case ThrowReferenceError : m_isValid = false ; node -> setCanExit ( true ) ; break ; case ToPrimitive : { JSValue childConst = forNode ( node -> child1 ( ) ) . value ( ) ; if ( childConst && childConst . isNumber ( ) && trySetConstant ( node , childConst ) ) { m_foundConstants = true ; break ; } ASSERT ( node -> child1 ( ) . useKind ( ) == UntypedUse ) ; AbstractValue & source = forNode ( node -> child1 ( ) ) ; AbstractValue & destination = forNode ( node ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; SpeculatedType type = source . m_type ; if ( type & ~ ( SpecNumber | SpecString | SpecBoolean ) ) { type &= ( SpecNumber | SpecString | SpecBoolean ) ; type |= SpecString ; } destination . set ( type ) ; break ; } case ToString : { switch ( node -> child1 ( ) . useKind ( ) ) { case StringObjectUse : forNode ( node -> child1 ( ) ) . filter ( m_graph . globalObjectFor ( node -> codeOrigin ) -> stringObjectStructure ( ) ) ; node -> setCanExit ( true ) ; break ; case StringOrStringObjectUse : node -> setCanExit ( true ) ; break ; case CellUse : case UntypedUse : clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case NewStringObject : { ASSERT ( node -> structure ( ) -> classInfo ( ) == & StringObject :: s_info ) ; forNode ( node ) . set ( node -> structure ( ) ) ; break ; } case NewArray : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> arrayStructureForIndexingTypeDuringAllocation ( node -> indexingType ( ) ) ) ; m_haveStructures = true ; break ; case NewArrayBuffer : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> arrayStructureForIndexingTypeDuringAllocation ( node -> indexingType ( ) ) ) ; m_haveStructures = true ; break ; case NewArrayWithSize : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecArray ) ; m_haveStructures = true ; break ; case NewRegexp : forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> regExpStructure ( ) ) ; m_haveStructures = true ; break ; case ConvertThis : { AbstractValue & source = forNode ( node -> child1 ( ) ) ; AbstractValue & destination = forNode ( node ) ; destination = source ; destination . merge ( SpecObjectOther ) ; break ; } case CreateThis : { forNode ( node ) . set ( SpecFinalObject ) ; break ; } case AllocationProfileWatchpoint : node -> setCanExit ( true ) ; break ; case NewObject : forNode ( node ) . set ( node -> structure ( ) ) ; m_haveStructures = true ; break ; case CreateActivation : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> activationStructure ( ) ) ; m_haveStructures = true ; break ; case CreateArguments : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> argumentsStructure ( ) ) ; m_haveStructures = true ; break ; case TearOffActivation : case TearOffArguments : break ; case CheckArgumentsNotCreated : if ( isEmptySpeculation ( m_variables . operand ( m_graph . argumentsRegisterFor ( node -> codeOrigin ) ) . m_type ) ) m_foundConstants = true ; else node -> setCanExit ( true ) ; break ; case GetMyArgumentsLength : if ( node -> codeOrigin . inlineCallFrame ) forNode ( node ) . set ( jsNumber ( node -> codeOrigin . inlineCallFrame -> arguments . size ( ) - 1 ) ) ; else forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( ! isEmptySpeculation ( m_variables . operand ( m_graph . argumentsRegisterFor ( node -> codeOrigin ) ) . m_type ) ) ; break ; case GetMyArgumentsLengthSafe : clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case GetMyArgumentByVal : node -> setCanExit ( true ) ; forNode ( node ) . makeTop ( ) ; break ; case GetMyArgumentByValSafe : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case NewFunction : { AbstractValue & value = forNode ( node ) ; value = forNode ( node -> child1 ( ) ) ; if ( ! ( value . m_type & SpecEmpty ) ) { m_foundConstants = true ; break ; } value . set ( ( value . m_type & ~ SpecEmpty ) | SpecFunction ) ; break ; } case NewFunctionExpression : case NewFunctionNoCheck : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> functionStructure ( ) ) ; break ; case GetCallee : forNode ( node ) . set ( SpecFunction ) ; break ; case SetCallee : case SetMyScope : break ; case GetScope : case GetMyScope : case SkipTopScope : forNode ( node ) . set ( SpecCellOther ) ; break ; case SkipScope : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && trySetConstant ( node , JSValue ( jsCast < JSScope * > ( child . asCell ( ) ) -> next ( ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecCellOther ) ; break ; } case GetScopeRegisters : forNode ( node ) . clear ( ) ; break ; case GetScopedVar : forNode ( node ) . makeTop ( ) ; break ; case PutScopedVar : clobberCapturedVars ( node -> codeOrigin ) ; break ; case GetById : case GetByIdFlush : node -> setCanExit ( true ) ; if ( ! node -> prediction ( ) ) { m_isValid = false ; break ; } if ( isCellSpeculation ( node -> child1 ( ) -> prediction ( ) ) ) { if ( Structure * structure = forNode ( node -> child1 ( ) ) . bestProvenStructure ( ) ) { GetByIdStatus status = GetByIdStatus :: computeFor ( m_graph . m_vm , structure , m_graph . m_codeBlock -> identifier ( node -> identifierNumber ( ) ) ) ; if ( status . isSimple ( ) ) { ASSERT ( status . structureSet ( ) . size ( ) == 1 ) ; ASSERT ( status . chain ( ) . isEmpty ( ) ) ; if ( status . specificValue ( ) ) forNode ( node ) . set ( status . specificValue ( ) ) ; else forNode ( node ) . makeTop ( ) ; forNode ( node -> child1 ( ) ) . filter ( status . structureSet ( ) ) ; m_foundConstants = true ; break ; } } } clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case GetArrayLength : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecInt32 ) ; break ; case CheckExecutable : { node -> setCanExit ( true ) ; break ; } case CheckStructure : case ForwardCheckStructure : { AbstractValue & value = forNode ( node -> child1 ( ) ) ; ASSERT ( ! ( value . m_type & ~ SpecCell ) ) ; StructureSet & set = node -> structureSet ( ) ; if ( value . m_futurePossibleStructure . isSubsetOf ( set ) || value . m_currentKnownStructure . isSubsetOf ( set ) ) m_foundConstants = true ; if ( ! value . m_currentKnownStructure . isSubsetOf ( set ) ) node -> setCanExit ( true ) ; value . filter ( set ) ; m_haveStructures = true ; break ; } case StructureTransitionWatchpoint : case ForwardStructureTransitionWatchpoint : { AbstractValue & value = forNode ( node -> child1 ( ) ) ; ASSERT ( value . m_futurePossibleStructure . isSubsetOf ( StructureSet ( node -> structure ( ) ) ) ) ; value . filter ( node -> structure ( ) ) ; m_haveStructures = true ; node -> setCanExit ( true ) ; break ; } case PutStructure : case PhantomPutStructure : if ( ! forNode ( node -> child1 ( ) ) . m_currentKnownStructure . isClear ( ) ) { clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . set ( node -> structureTransitionData ( ) . newStructure ) ; m_haveStructures = true ; } break ; case GetButterfly : case AllocatePropertyStorage : case ReallocatePropertyStorage : forNode ( node ) . clear ( ) ; break ; case CheckArray : { if ( node -> arrayMode ( ) . alreadyChecked ( m_graph , node , forNode ( node -> child1 ( ) ) ) ) { m_foundConstants = true ; break ; } node -> setCanExit ( true ) ; switch ( node -> arrayMode ( ) . type ( ) ) { case Array :: String : forNode ( node -> child1 ( ) ) . filter ( SpecString ) ; break ; case Array :: Int32 : case Array :: Double : case Array :: Contiguous : case Array :: ArrayStorage : case Array :: SlowPutArrayStorage : break ; case Array :: Arguments : forNode ( node -> child1 ( ) ) . filter ( SpecArguments ) ; break ; case Array :: Int8Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt8Array ) ; break ; case Array :: Int16Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt16Array ) ; break ; case Array :: Int32Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt32Array ) ; break ; case Array :: Uint8Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint8Array ) ; break ; case Array :: Uint8ClampedArray : forNode ( node -> child1 ( ) ) . filter ( SpecUint8ClampedArray ) ; break ; case Array :: Uint16Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint16Array ) ; break ; case Array :: Uint32Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint32Array ) ; break ; case Array :: Float32Array : forNode ( node -> child1 ( ) ) . filter ( SpecFloat32Array ) ; break ; case Array :: Float64Array : forNode ( node -> child1 ( ) ) . filter ( SpecFloat64Array ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node -> child1 ( ) ) . filterArrayModes ( node -> arrayMode ( ) . arrayModesThatPassFiltering ( ) ) ; m_haveStructures = true ; break ; } case Arrayify : { if ( node -> arrayMode ( ) . alreadyChecked ( m_graph , node , forNode ( node -> child1 ( ) ) ) ) { m_foundConstants = true ; break ; } ASSERT ( node -> arrayMode ( ) . conversion ( ) == Array :: Convert || node -> arrayMode ( ) . conversion ( ) == Array :: RageConvert ) ; node -> setCanExit ( true ) ; clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . filterArrayModes ( node -> arrayMode ( ) . arrayModesThatPassFiltering ( ) ) ; m_haveStructures = true ; break ; } case ArrayifyToStructure : { AbstractValue & value = forNode ( node -> child1 ( ) ) ; StructureSet set = node -> structure ( ) ; if ( value . m_futurePossibleStructure . isSubsetOf ( set ) || value . m_currentKnownStructure . isSubsetOf ( set ) ) m_foundConstants = true ; node -> setCanExit ( true ) ; clobberStructures ( indexInBlock ) ; value . filter ( set ) ; m_haveStructures = true ; break ; } case GetIndexedPropertyStorage : { forNode ( node ) . clear ( ) ; break ; } case GetByOffset : { forNode ( node ) . makeTop ( ) ; break ; } case PutByOffset : { break ; } case CheckFunction : { JSValue value = forNode ( node -> child1 ( ) ) . value ( ) ; if ( value == node -> function ( ) ) { m_foundConstants = true ; ASSERT ( value ) ; break ; } node -> setCanExit ( true ) ; forNode ( node -> child1 ( ) ) . filterByValue ( node -> function ( ) ) ; break ; } case PutById : case PutByIdDirect : node -> setCanExit ( true ) ; if ( Structure * structure = forNode ( node -> child1 ( ) ) . bestProvenStructure ( ) ) { PutByIdStatus status = PutByIdStatus :: computeFor ( m_graph . m_vm , m_graph . globalObjectFor ( node -> codeOrigin ) , structure , m_graph . m_codeBlock -> identifier ( node -> identifierNumber ( ) ) , node -> op ( ) == PutByIdDirect ) ; if ( status . isSimpleReplace ( ) ) { forNode ( node -> child1 ( ) ) . filter ( structure ) ; m_foundConstants = true ; break ; } if ( status . isSimpleTransition ( ) ) { clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . set ( status . newStructure ( ) ) ; m_haveStructures = true ; m_foundConstants = true ; break ; } } clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case GetGlobalVar : forNode ( node ) . makeTop ( ) ; break ; case GlobalVarWatchpoint : node -> setCanExit ( true ) ; break ; case PutGlobalVar : case PutGlobalVarCheck : break ; case CheckHasInstance : node -> setCanExit ( true ) ; break ; case InstanceOf : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecBoolean ) ; break ; case Phi : case Flush : case PhantomLocal : case Breakpoint : break ; case Call : case Construct : case Resolve : case ResolveBase : case ResolveBaseStrictPut : case ResolveGlobal : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case GarbageValue : clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case ForceOSRExit : node -> setCanExit ( true ) ; m_isValid = false ; break ; case CheckWatchdogTimer : node -> setCanExit ( true ) ; break ; case Phantom : case InlineStart : case Nop : case CountExecution : break ; case LastNodeType : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } return m_isValid ; }
bool AbstractState :: executeEffects ( unsigned indexInBlock ) { return executeEffects ( indexInBlock , m_block -> at ( indexInBlock ) ) ; }
bool AbstractState :: execute ( unsigned indexInBlock ) { Node * node = m_block -> at ( indexInBlock ) ; if ( ! startExecuting ( node ) ) return true ; executeEdges ( node ) ; return executeEffects ( indexInBlock , node ) ; }
inline void AbstractState :: clobberWorld ( const CodeOrigin & codeOrigin , unsigned indexInBlock ) { clobberCapturedVars ( codeOrigin ) ; clobberStructures ( indexInBlock ) ; }
inline void AbstractState :: clobberCapturedVars ( const CodeOrigin & codeOrigin ) { if ( codeOrigin . inlineCallFrame ) { const BitVector & capturedVars = codeOrigin . inlineCallFrame -> capturedVars ; for ( size_t i = capturedVars . size ( ) ; i -- ; ) { if ( ! capturedVars . quickGet ( i ) ) continue ; m_variables . local ( i ) . makeTop ( ) ; } } else { for ( size_t i = m_codeBlock -> m_numVars ; i -- ; ) { if ( m_codeBlock -> isCaptured ( i ) ) m_variables . local ( i ) . makeTop ( ) ; } } for ( size_t i = m_variables . numberOfArguments ( ) ; i -- ; ) { if ( m_codeBlock -> isCaptured ( argumentToOperand ( i ) ) ) m_variables . argument ( i ) . makeTop ( ) ; } }
inline void AbstractState :: clobberStructures ( unsigned indexInBlock ) { if ( ! m_haveStructures ) return ; for ( size_t i = indexInBlock + 1 ; i -- ; ) forNode ( m_block -> at ( i ) ) . clobberStructures ( ) ; for ( size_t i = m_variables . numberOfArguments ( ) ; i -- ; ) m_variables . argument ( i ) . clobberStructures ( ) ; for ( size_t i = m_variables . numberOfLocals ( ) ; i -- ; ) m_variables . local ( i ) . clobberStructures ( ) ; m_haveStructures = false ; m_didClobber = true ; }
inline bool AbstractState :: mergeStateAtTail ( AbstractValue & destination , AbstractValue & inVariable , Node * node ) { if ( ! node ) return false ; AbstractValue source ; if ( node -> variableAccessData ( ) -> isCaptured ( ) ) { source = inVariable ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Transfering ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " ▁ from ▁ last ▁ access ▁ due ▁ to ▁ captured ▁ variable . \n " ) ; } else { ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ It ' s ▁ live , ▁ node ▁ @ % u . \n " , node -> index ( ) ) ; switch ( node -> op ( ) ) { case Phi : case SetArgument : case PhantomLocal : case Flush : source = inVariable ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Transfering ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " ▁ from ▁ head ▁ to ▁ tail . \n " ) ; break ; case GetLocal : source = forNode ( node ) ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Refining ▁ to ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; break ; case SetLocal : if ( node -> variableAccessData ( ) -> shouldUseDoubleFormat ( ) ) { source . set ( SpecDouble ) ; } else source = forNode ( node -> child1 ( ) ) ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Setting ▁ to ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } } if ( destination == source ) { ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Not ▁ changed ! \n " ) ; return false ; } destination = source ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Changed ! \n " ) ; return true ; }
inline bool AbstractState :: merge ( BasicBlock * from , BasicBlock * to ) { ASSERT ( from -> variablesAtTail . numberOfArguments ( ) == to -> variablesAtHead . numberOfArguments ( ) ) ; ASSERT ( from -> variablesAtTail . numberOfLocals ( ) == to -> variablesAtHead . numberOfLocals ( ) ) ; bool changed = false ; for ( size_t argument = 0 ; argument < from -> variablesAtTail . numberOfArguments ( ) ; ++ argument ) { AbstractValue & destination = to -> valuesAtHead . argument ( argument ) ; changed |= mergeVariableBetweenBlocks ( destination , from -> valuesAtTail . argument ( argument ) , to -> variablesAtHead . argument ( argument ) , from -> variablesAtTail . argument ( argument ) ) ; } for ( size_t local = 0 ; local < from -> variablesAtTail . numberOfLocals ( ) ; ++ local ) { AbstractValue & destination = to -> valuesAtHead . local ( local ) ; changed |= mergeVariableBetweenBlocks ( destination , from -> valuesAtTail . local ( local ) , to -> variablesAtHead . local ( local ) , from -> variablesAtTail . local ( local ) ) ; } if ( ! to -> cfaHasVisited ) changed = true ; to -> cfaShouldRevisit |= changed ; return changed ; }
inline bool AbstractState :: mergeToSuccessors ( Graph & graph , BasicBlock * basicBlock ) { Node * terminal = basicBlock -> last ( ) ; ASSERT ( terminal -> isTerminal ( ) ) ; switch ( terminal -> op ( ) ) { case Jump : { ASSERT ( basicBlock -> cfaBranchDirection == InvalidBranchDirection ) ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> takenBlockIndex ( ) ) ; return merge ( basicBlock , graph . m_blocks [ terminal -> takenBlockIndex ( ) ] . get ( ) ) ; } case Branch : { ASSERT ( basicBlock -> cfaBranchDirection != InvalidBranchDirection ) ; bool changed = false ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> takenBlockIndex ( ) ) ; if ( basicBlock -> cfaBranchDirection != TakeFalse ) changed |= merge ( basicBlock , graph . m_blocks [ terminal -> takenBlockIndex ( ) ] . get ( ) ) ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> notTakenBlockIndex ( ) ) ; if ( basicBlock -> cfaBranchDirection != TakeTrue ) changed |= merge ( basicBlock , graph . m_blocks [ terminal -> notTakenBlockIndex ( ) ] . get ( ) ) ; return changed ; } case Return : case Throw : case ThrowReferenceError : ASSERT ( basicBlock -> cfaBranchDirection == InvalidBranchDirection ) ; return false ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; return false ; } }
inline bool AbstractState :: mergeVariableBetweenBlocks ( AbstractValue & destination , AbstractValue & source , Node * destinationNode , Node * sourceNode ) { if ( ! destinationNode ) return false ; ASSERT_UNUSED ( sourceNode , sourceNode ) ; return destination . merge ( source ) ; }
void AbstractState :: dump ( PrintStream & out ) { bool first = true ; for ( size_t i = 0 ; i < m_block -> size ( ) ; ++ i ) { Node * node = m_block -> at ( i ) ; AbstractValue & value = forNode ( node ) ; if ( value . isClear ( ) ) continue ; if ( first ) first = false ; else out . printf ( " ▁ " ) ; out . printf ( " @ % lu : " , static_cast < unsigned long > ( node -> index ( ) ) ) ; value . dump ( out ) ; } }
