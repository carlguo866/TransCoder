void CJNIBaseColumns :: PopulateStaticFields ( ) { jhclass clazz = find_class ( " android / provider / BaseColumns " ) ; _ID = ( jcast < std :: string > ( get_static_field < jhstring > ( clazz , " _ ID " ) ) ) ; _COUNT = ( jcast < std :: string > ( get_static_field < jhstring > ( clazz , " _ COUNT " ) ) ) ; }
void MaximizeWindowCommandHandler :: ExecuteInternal ( const IECommandExecutor & executor , const ParametersMap & command_parameters , Response * response ) { int status_code = WD_SUCCESS ; BrowserHandle browser_wrapper ; status_code = executor . GetCurrentBrowser ( & browser_wrapper ) ; if ( status_code != WD_SUCCESS ) { response -> SetErrorResponse ( ERROR_NO_SUCH_WINDOW , " Error ▁ retrieving ▁ window " ) ; return ; } HWND window_handle = browser_wrapper -> GetTopLevelWindowHandle ( ) ; if ( ! :: IsZoomed ( window_handle ) ) { browser_wrapper -> Restore ( ) ; :: ShowWindow ( window_handle , SW_MAXIMIZE ) ; } RECT window_rect ; :: GetWindowRect ( window_handle , & window_rect ) ; Json :: Value response_value ; response_value [ " width " ] = window_rect . right - window_rect . left ; response_value [ " height " ] = window_rect . bottom - window_rect . top ; response_value [ " x " ] = window_rect . left ; response_value [ " y " ] = window_rect . top ; response -> SetSuccessResponse ( response_value ) ; }
bool DictionaryPopupInfo :: decode ( CoreIPC :: ArgumentDecoder * decoder , DictionaryPopupInfo & result ) { if ( ! decoder -> decode ( result . origin ) ) return false ; if ( ! decoder -> decode ( result . fontInfo ) ) return false ; if ( ! decoder -> decodeEnum ( result . type ) ) return false ; ( MAC ) && ! defined ( BUILDING_ON_SNOW_LEOPARD ) if ( ! CoreIPC :: decode ( decoder , result . options ) ) return false ; return true ; }
ViewProviderTrajectory :: ~ ViewProviderTrajectory ( ) { pcTrajectoryRoot -> unref ( ) ; pcCoords -> unref ( ) ; pcDrawStyle -> unref ( ) ; pcLines -> unref ( ) ; }
void ViewProviderTrajectory :: attach ( App :: DocumentObject * pcObj ) { ViewProviderDocumentObject :: attach ( pcObj ) ; SoSeparator * linesep = new SoSeparator ; SoBaseColor * basecol = new SoBaseColor ; basecol -> rgb . setValue ( 1.0f , 0.5f , 0.0f ) ; linesep -> addChild ( basecol ) ; linesep -> addChild ( pcCoords ) ; linesep -> addChild ( pcLines ) ; SoBaseColor * markcol = new SoBaseColor ; markcol -> rgb . setValue ( 1.0f , 1.0f , 0.0f ) ; SoMarkerSet * marker = new SoMarkerSet ; marker -> markerIndex = SoMarkerSet :: CROSS_5_5 ; linesep -> addChild ( markcol ) ; linesep -> addChild ( marker ) ; pcTrajectoryRoot -> addChild ( linesep ) ; addDisplayMaskMode ( pcTrajectoryRoot , " Waypoints " ) ; pcTrajectoryRoot -> objectName = pcObj -> getNameInDocument ( ) ; pcTrajectoryRoot -> documentName = pcObj -> getDocument ( ) -> getName ( ) ; pcTrajectoryRoot -> subElementName = " Main " ; }
void ViewProviderTrajectory :: setDisplayMode ( const char * ModeName ) { if ( strcmp ( " Waypoints " , ModeName ) == 0 ) setDisplayMaskMode ( " Waypoints " ) ; ViewProviderGeometryObject :: setDisplayMode ( ModeName ) ; }
void ViewProviderTrajectory :: updateData ( const App :: Property * prop ) { Robot :: TrajectoryObject * pcTracObj = static_cast < Robot :: TrajectoryObject * > ( pcObject ) ; if ( prop == & pcTracObj -> Trajectory ) { const Trajectory & trak = pcTracObj -> Trajectory . getValue ( ) ; pcCoords -> point . deleteValues ( 0 ) ; pcCoords -> point . setNum ( trak . getSize ( ) ) ; for ( unsigned int i = 0 ; i < trak . getSize ( ) ; ++ i ) { Base :: Vector3d pos = trak . getWaypoint ( i ) . EndPos . getPosition ( ) ; pcCoords -> point . set1Value ( i , pos . x , pos . y , pos . z ) ; } pcLines -> numVertices . set1Value ( 0 , trak . getSize ( ) ) ; } else if ( prop == & pcTracObj -> Base ) { Base :: Placement loc = * ( & pcTracObj -> Base . getValue ( ) ) ; } }
ICMPPacket :: ICMPPacket ( IPAddress :: Family family , int dataSize ) : _pImpl ( 0 ) { if ( family == IPAddress :: IPv4 ) _pImpl = new ICMPv4PacketImpl ( dataSize ) ; else if ( family == IPAddress :: IPv6 ) throw NotImplementedException ( " ICMPv6 ▁ packets ▁ not ▁ implemented . " ) ; else throw InvalidArgumentException ( " Invalid ▁ or ▁ unsupported ▁ address ▁ family ▁ passed ▁ to ▁ ICMPPacket " ) ; }
ICMPPacket :: ~ ICMPPacket ( ) { delete _pImpl ; }
void ICMPPacket :: setDataSize ( int dataSize ) { _pImpl -> setDataSize ( dataSize ) ; }
const Poco :: UInt8 * ICMPPacket :: packet ( ) { return _pImpl -> packet ( ) ; }
std :: string ICMPPacket :: errorDescription ( Poco :: UInt8 * buffer , int length ) { return _pImpl -> errorDescription ( buffer , length ) ; }
std :: string ICMPPacket :: typeDescription ( int typeId ) { return _pImpl -> typeDescription ( typeId ) ; }
void NavEKF_core_common :: fill_scratch_variables ( void ) { == HAL_BOARD_SITL fill_nanf ( & KH [ 0 ] [ 0 ] , sizeof ( KH ) / sizeof ( float ) ) ; fill_nanf ( & KHP [ 0 ] [ 0 ] , sizeof ( KHP ) / sizeof ( float ) ) ; fill_nanf ( & nextP [ 0 ] [ 0 ] , sizeof ( nextP ) / sizeof ( float ) ) ; fill_nanf ( & Kfusion [ 0 ] , sizeof ( Kfusion ) / sizeof ( float ) ) ; }
GeneralParamReceiver :: ~ GeneralParamReceiver ( ) { m_guiProtHandler -> DeregisterReceiver ( this , isab :: GuiProtEnums :: SET_GENERAL_PARAMETER ) ; m_guiProtHandler -> DeregisterReceiver ( this , isab :: GuiProtEnums :: GET_GENERAL_PARAMETER ) ; }
void GeneralParamReceiver :: init ( ) { m_guiProtHandler -> RegisterReceiver ( this , isab :: GuiProtEnums :: SET_GENERAL_PARAMETER ) ; m_guiProtHandler -> RegisterReceiver ( this , isab :: GuiProtEnums :: GET_GENERAL_PARAMETER ) ; }
bool GeneralParamReceiver :: decodedParamNoValue ( uint32 paramId ) { return false ; }
bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const float * data , int32 numEntries ) { return false ; }
bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const uint8 * data , int32 numEntries ) { return false ; }
bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const char * * data , int32 numEntries ) { return false ; }
bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const int32 * data , int32 numEntries ) { switch ( paramId ) { case GuiProtEnums :: paramAutoReroute : { m_settingsData -> m_autoReroute = data [ 0 ] ; } break ; case GuiProtEnums :: paramBacklightStrategy : { m_settingsData -> m_backlightStrategy = data [ 0 ] ; } break ; case GuiProtEnums :: paramAutoTracking : { m_settingsData -> m_autoTracking = data [ 0 ] ; } break ; case GuiProtEnums :: paramDistanceMode : { m_settingsData -> m_distanceMode = data [ 0 ] ; } break ; case GuiProtEnums :: paramFavoriteShow : { m_settingsData -> m_favoriteShowInMap = data [ 0 ] ; } break ; case GuiProtEnums :: paramHighways : { m_settingsData -> m_routeHighways = data [ 0 ] ; } break ; case GuiProtEnums :: paramTollRoads : { m_settingsData -> m_routeTollRoads = data [ 0 ] ; } break ; case GuiProtEnums :: paramTimeDist : { m_settingsData -> m_routeCostType = data [ 0 ] ; } break ; case GuiProtEnums :: paramTrackingLevel : { m_settingsData -> m_trackingLevel = data [ 0 ] ; } break ; case GuiProtEnums :: paramTransportationType : { m_settingsData -> m_transportationType = data [ 0 ] ; } break ; case GuiProtEnums :: paramTurnSoundsLevel : { m_settingsData -> m_turnSoundsLevel = data [ 0 ] ; } break ; case GuiProtEnums :: userTrafficUpdatePeriod : { int32 val = data [ 0 ] ; m_settingsData -> m_trafficUpdatePeriod = 0xbfffffff & val ; m_settingsData -> m_trafficOldUpdatePeriod = 0xbfffffff & val ; m_settingsData -> m_trafficUpdate = 0x40000000 & val ? 0 : 1 ; m_settingsData -> m_trafficOldUpdate = 0x40000000 & val ? 0 : 1 ; } break ; case GuiProtEnums :: paramAutomaticRouteOnSMSDest : { m_settingsData -> m_autoRouteOnSMSDest = data [ 0 ] ; } break ; case GuiProtEnums :: paramKeepSMSDestInInbox : { m_settingsData -> m_keepSMSDestInInbox = data [ 0 ] ; } break ; case GuiProtEnums :: paramStoreSMSDestInMyDest : { m_settingsData -> m_storeSMSDestInFavorites = data [ 0 ] ; } break ; case GuiProtEnums :: paramPositionSymbol : { m_settingsData -> m_positionSymbol = data [ 0 ] ; } break ; case GuiProtEnums :: paramCheckForUpdates : { m_settingsData -> m_checkForUpdates = data [ 0 ] ; } break ; default : return false ; break ; } return true ; }
bool GeneralParamReceiver :: GuiProtReceiveMessage ( class GuiProtMess * mess ) { GuiProtEnums :: MessageType type = mess -> getMessageType ( ) ; if ( type == GuiProtEnums :: GET_GENERAL_PARAMETER ) { isab :: GeneralParameterMess * gpm = ( isab :: GeneralParameterMess * ) mess ; return decodedParamNoValue ( gpm -> getParamId ( ) ) ; } else if ( type == GuiProtEnums :: SET_GENERAL_PARAMETER ) { isab :: GeneralParameterMess * gpm = ( isab :: GeneralParameterMess * ) mess ; switch ( gpm -> getParamType ( ) ) { case isab :: GuiProtEnums :: paramTypeInt32 : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getIntegerData ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramTypeFloat : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getFloatData ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramTypeBinary : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getBinaryData ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramTypeString : return decodedParamValue ( gpm -> getParamId ( ) , ( const char * * ) gpm -> getStringData ( ) , gpm -> getNumEntries ( ) ) ; break ; default : case isab :: GuiProtEnums :: paramTypeInvalid : return false ; break ; } } return false ; }
QQuickAnimatorController :: ~ QQuickAnimatorController ( ) { foreach ( QAbstractAnimationJob * job , m_deleting ) { m_starting . take ( job ) ; m_stopping . take ( job ) ; m_animatorRoots . take ( job ) ; delete job ; } foreach ( QQuickAnimatorProxyJob * proxy , m_animatorRoots ) proxy -> controllerWasDeleted ( ) ; qDeleteAll ( m_animatorRoots . keys ( ) ) ; foreach ( QAbstractAnimationJob * job , m_starting . keys ( ) ) { if ( ! m_animatorRoots . contains ( job ) ) delete job ; } }
void QQuickAnimatorController :: itemDestroyed ( QObject * o ) { m_deletedSinceLastFrame << ( QQuickItem * ) o ; }
void QQuickAnimatorController :: advance ( ) { bool running = false ; for ( QHash < QAbstractAnimationJob * , QQuickAnimatorProxyJob * > :: const_iterator it = m_animatorRoots . constBegin ( ) ; ! running && it != m_animatorRoots . constEnd ( ) ; ++ it ) { if ( it . key ( ) -> isRunning ( ) ) running = true ; } lock ( ) ; for ( QHash < QQuickItem * , QQuickTransformAnimatorJob :: Helper * > :: const_iterator it = m_transforms . constBegin ( ) ; it != m_transforms . constEnd ( ) ; ++ it ) { QQuickTransformAnimatorJob :: Helper * xform = * it ; if ( ! xform -> item ) continue ; ( * it ) -> apply ( ) ; } unlock ( ) ; if ( running ) m_window -> update ( ) ; }
void QQuickAnimatorController :: beforeNodeSync ( ) { foreach ( QAbstractAnimationJob * job , m_deleting ) { m_starting . take ( job ) ; m_stopping . take ( job ) ; m_animatorRoots . take ( job ) ; job -> stop ( ) ; delete job ; } m_deleting . clear ( ) ; if ( m_starting . size ( ) ) m_window -> update ( ) ; foreach ( QQuickAnimatorProxyJob * proxy , m_starting ) { QAbstractAnimationJob * job = proxy -> job ( ) ; job -> addAnimationChangeListener ( this , QAbstractAnimationJob :: Completion ) ; qquick_initialize_helper ( job , this ) ; m_animatorRoots [ job ] = proxy ; job -> start ( ) ; proxy -> startedByController ( ) ; } m_starting . clear ( ) ; foreach ( QQuickAnimatorProxyJob * proxy , m_stopping ) { QAbstractAnimationJob * job = proxy -> job ( ) ; job -> stop ( ) ; } m_stopping . clear ( ) ; foreach ( QQuickAnimatorJob * job , m_activeLeafAnimations ) { if ( ! job -> target ( ) ) continue ; else if ( m_deletedSinceLastFrame . contains ( job -> target ( ) ) ) job -> targetWasDeleted ( ) ; else if ( job -> isTransform ( ) ) { QQuickTransformAnimatorJob * xform = static_cast < QQuickTransformAnimatorJob * > ( job ) ; xform -> transformHelper ( ) -> sync ( ) ; } } foreach ( QQuickItem * wiped , m_deletedSinceLastFrame ) { QQuickTransformAnimatorJob :: Helper * helper = m_transforms . value ( wiped ) ; if ( helper ) helper -> item = 0 ; } m_deletedSinceLastFrame . clear ( ) ; }
void QQuickAnimatorController :: afterNodeSync ( ) { foreach ( QQuickAnimatorJob * job , m_activeLeafAnimations ) { if ( job -> isUniform ( ) && job -> target ( ) ) static_cast < QQuickUniformAnimatorJob * > ( job ) -> afterNodeSync ( ) ; } }
void QQuickAnimatorController :: animationFinished ( QAbstractAnimationJob * job ) { if ( ! m_deleting . contains ( job ) ) { QQuickAnimatorProxyJob * proxy = m_animatorRoots [ job ] ; if ( proxy ) QCoreApplication :: postEvent ( proxy , new QEvent ( QEvent :: User ) ) ; } }
void QQuickAnimatorController :: animationStateChanged ( QAbstractAnimationJob * job , QAbstractAnimationJob :: State newState , QAbstractAnimationJob :: State oldState ) { Q_ASSERT ( job -> isRenderThreadJob ( ) ) ; QQuickAnimatorJob * animator = static_cast < QQuickAnimatorJob * > ( job ) ; if ( newState == QAbstractAnimationJob :: Running ) { m_activeLeafAnimations << animator ; animator -> setHasBeenRunning ( true ) ; } else if ( oldState == QAbstractAnimationJob :: Running ) { m_activeLeafAnimations . remove ( animator ) ; } }
void QQuickAnimatorController :: requestSync ( ) { m_window -> maybeUpdate ( ) ; }
void QQuickAnimatorController :: startJob ( QQuickAnimatorProxyJob * proxy , QAbstractAnimationJob * job ) { m_starting [ job ] = proxy ; requestSync ( ) ; }
void QQuickAnimatorController :: stopJob ( QQuickAnimatorProxyJob * proxy , QAbstractAnimationJob * job ) { m_stopping [ job ] = proxy ; requestSync ( ) ; }
void QQuickAnimatorController :: deleteJob ( QAbstractAnimationJob * job ) { lock ( ) ; m_deleting << job ; requestSync ( ) ; unlock ( ) ; }
GameLobbyStage :: GameLobbyStage ( ) { networkconnection = nullptr ; currentinfo = new GameInfo ( true ) ; selection = 0 ; selectionteamisblue = true ; }
GameLobbyStage :: GameLobbyStage ( Network * Connection ) { selection = 0 ; networkconnection = Connection ; currentinfo = new GameInfo ( Connection -> IsServer ( ) ) ; if ( ! Connection -> IsServer ( ) ) { } }
void GameLobbyStage :: Begin ( ) { optionfont = FontCache :: LoadFont ( " resources / armalite . ttf " , 32 ) ; helpfont = FontCache :: LoadFont ( " resources / armalite . ttf " , 16 ) ; }
void GameLobbyStage :: Finish ( ) { AUDIO -> StopMusic ( ) ; if ( networkconnection != nullptr ) { delete networkconnection ; networkconnection = nullptr ; } }
void GameLobbyStage :: EventOccurred ( Event * e ) { InputItems :: ItemSet inputevent = InputItems :: NONE ; if ( e -> Type == EVENT_KEY_DOWN ) { if ( e -> Data . Keyboard . KeyCode == ALLEGRO_KEY_ESCAPE ) { delete FRAMEWORK -> ProgramStages -> Pop ( ) ; return ; } inputevent = Input :: GetItemFromEvent ( e ) ; } if ( e -> Type == EVENT_JOYSTICK_BUTTON_DOWN && inputevent == InputItems :: NONE ) { inputevent = Input :: GetItemFromEvent ( e ) ; } if ( inputevent != InputItems :: NONE ) { InputEvent ( inputevent ) ; } NetworkEvent ( e ) ; }
void GameLobbyStage :: InputEvent ( InputItems :: ItemSet inputevent ) { switch ( inputevent ) { case InputItems :: UP : if ( selection > 0 ) { selection -- ; } break ; case InputItems :: DOWN : if ( selection < 2 ) { selection ++ ; } break ; case InputItems :: LEFT : selectionteamisblue = true ; break ; case InputItems :: RIGHT : selectionteamisblue = false ; break ; case InputItems :: SELECT : delete FRAMEWORK -> ProgramStages -> Pop ( ) ; return ; break ; case InputItems :: X : if ( networkconnection == nullptr ) { PlayerInfo * p = nullptr ; if ( selectionteamisblue ) { if ( currentinfo -> BlueTeam [ selection ] == nullptr ) { currentinfo -> BlueTeam [ selection ] = new PlayerInfo ( " " , true , false ) ; } p = currentinfo -> BlueTeam [ selection ] ; } else { if ( currentinfo -> RedTeam [ selection ] == nullptr ) { currentinfo -> RedTeam [ selection ] = new PlayerInfo ( " " , true , false ) ; } p = currentinfo -> RedTeam [ selection ] ; } p -> BlueTeam = selectionteamisblue ; p -> TeamIndex = selection ; p -> GameData = currentinfo ; FRAMEWORK -> ProgramStages -> Push ( new GameLobbyAddLocalStage ( p ) ) ; } break ; case InputItems :: B : if ( networkconnection == nullptr ) { PlayerInfo * p = nullptr ; if ( selectionteamisblue ) { if ( currentinfo -> BlueTeam [ selection ] == nullptr ) { p = new PlayerInfo ( " CPU " , true , true ) ; currentinfo -> BlueTeam [ selection ] = p ; } } else { if ( currentinfo -> RedTeam [ selection ] == nullptr ) { p = new PlayerInfo ( " CPU " , true , true ) ; currentinfo -> RedTeam [ selection ] = p ; } } if ( p != nullptr ) { p -> BlueTeam = selectionteamisblue ; p -> TeamIndex = selection ; p -> GameData = currentinfo ; } } break ; case InputItems :: Y : if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { PlayerInfo * p = nullptr ; if ( selectionteamisblue ) { p = currentinfo -> BlueTeam [ selection ] ; currentinfo -> BlueTeam [ selection ] = nullptr ; } else { p = currentinfo -> RedTeam [ selection ] ; currentinfo -> RedTeam [ selection ] = nullptr ; } if ( p != nullptr ) { if ( ! p -> Local ) { } delete p ; } } break ; case InputItems :: START : if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { GameStage * g = new GameStage ( currentinfo ) ; delete FRAMEWORK -> ProgramStages -> Pop ( ) ; FRAMEWORK -> ProgramStages -> Push ( g ) ; } break ; } }
void GameLobbyStage :: NetworkEvent ( Event * e ) { if ( e -> Type == EVENT_NETWORK_CONNECTION_REQUEST ) { bool freeslot = false ; for ( int i = 0 ; i < 3 ; i ++ ) { freeslot = ( currentinfo -> BlueTeam [ i ] == nullptr ? true : freeslot ) ; freeslot = ( currentinfo -> RedTeam [ i ] == nullptr ? true : freeslot ) ; } if ( freeslot ) { } } if ( e -> Type == EVENT_NETWORK_CONNECTED ) { } if ( e -> Type == EVENT_NETWORK_DISCONNECTED ) { } if ( e -> Type == EVENT_NETWORK_PACKET_RECEIVED ) { } }
void GameLobbyStage :: Render ( ) { al_clear_to_color ( al_map_rgb ( 255 , 220 , 128 ) ) ; optionfont -> DrawString ( ( DISPLAY -> GetWidth ( ) / 2 ) + 2 , 12 , " Lobby " , FontHAlign :: CENTRE , al_map_rgb ( 0 , 0 , 0 ) ) ; optionfont -> DrawString ( ( DISPLAY -> GetWidth ( ) / 2 ) , 10 , " Lobby " , FontHAlign :: CENTRE , al_map_rgb ( 255 , 255 , 0 ) ) ; GameResources :: DrawPanel ( GameResources :: BluePanel , 5 , 80 , 13 , 8 , 8 ) ; optionfont -> DrawString ( 15 , 85 , " Blue ▁ Team " , FontHAlign :: LEFT , al_map_rgb ( 255 , 255 , 255 ) ) ; RenderPlayerSlot ( true , 0 , 15 , 140 ) ; RenderPlayerSlot ( true , 1 , 15 , 192 ) ; RenderPlayerSlot ( true , 2 , 15 , 244 ) ; GameResources :: DrawPanel ( GameResources :: RedPanel , 405 , 80 , 13 , 8 , 8 ) ; optionfont -> DrawString ( 415 , 85 , " Red ▁ Team " , FontHAlign :: LEFT , al_map_rgb ( 255 , 255 , 255 ) ) ; RenderPlayerSlot ( false , 0 , 415 , 140 ) ; RenderPlayerSlot ( false , 1 , 415 , 192 ) ; RenderPlayerSlot ( false , 2 , 415 , 244 ) ; int textoff = ( 50 - helpfont -> GetFontHeight ( ) ) / 2 ; if ( networkconnection == nullptr ) { al_draw_bitmap ( Input :: GetIcon ( InputItems :: X ) , 10 , 320 , 0 ) ; helpfont -> DrawString ( 64 , 320 + textoff , " Add ▁ Local ▁ Player " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; al_draw_bitmap ( Input :: GetIcon ( InputItems :: B ) , 10 , 370 , 0 ) ; helpfont -> DrawString ( 64 , 370 + textoff , " Add ▁ CPU ▁ Player " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; } if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { al_draw_bitmap ( Input :: GetIcon ( InputItems :: Y ) , 10 , 420 , 0 ) ; helpfont -> DrawString ( 64 , 420 + textoff , " Kick ▁ Player " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; al_draw_bitmap ( Input :: GetIcon ( InputItems :: START ) , 500 , 370 , 0 ) ; helpfont -> DrawString ( 554 , 370 + textoff , " Start " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; } al_draw_bitmap ( Input :: GetIcon ( InputItems :: SELECT ) , 500 , 420 , 0 ) ; helpfont -> DrawString ( 554 , 420 + textoff , " Quit " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; }
bool GameLobbyStage :: IsTransition ( ) { return false ; }
void GameLobbyStage :: RenderPlayerSlot ( bool BlueTeam , int Index , int X , int Y ) { ButtonColours :: Colours colour = ButtonColours :: WHITE ; bool btnup = false ; PlayerInfo * p = ( BlueTeam ? currentinfo -> BlueTeam [ Index ] : currentinfo -> RedTeam [ Index ] ) ; if ( p != nullptr ) { colour = ( BlueTeam ? ButtonColours :: BLUE : ButtonColours :: RED ) ; } if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { if ( selection == Index && selectionteamisblue == BlueTeam ) { colour = ButtonColours :: YELLOW ; btnup = true ; } } GameResources :: DrawButton ( colour , btnup , X , Y , 23 , 3 ) ; if ( p != nullptr ) { helpfont -> DrawString ( X + 184 , Y + 24 - ( helpfont -> GetFontHeight ( ) / 2 ) + ( ! btnup ? 4 : 0 ) , p -> Name , FontHAlign :: CENTRE , al_map_rgb ( 0 , 0 , 0 ) ) ; } }
StyleManagerDialog :: StyleManagerDialog ( QWidget * parent , Selection * selection , KCStyleManager * manager ) : KDialog ( parent ) , m_selection ( selection ) , m_styleManager ( manager ) { setButtons ( Apply | User1 | User2 | User3 | Close ) ; setButtonText ( User3 , i18n ( " & New . . . " ) ) ; setButtonText ( User2 , i18n ( " & Modify . . . " ) ) ; setButtonText ( User1 , i18n ( " & Delete . . . " ) ) ; setButtonsOrientation ( Qt :: Vertical ) ; setCaption ( i18n ( " Style ▁ Manager " ) ) ; QWidget * widget = new QWidget ( this ) ; setMainWidget ( widget ) ; QVBoxLayout * layout = new QVBoxLayout ( widget ) ; m_styleList = new QTreeWidget ( this ) ; m_styleList -> setHeaderLabel ( i18n ( " Style " ) ) ; layout -> addWidget ( m_styleList ) ; m_displayBox = new KComboBox ( false , this ) ; m_displayBox -> insertItem ( 0 , i18n ( " All ▁ Styles " ) ) ; m_displayBox -> insertItem ( 1 , i18n ( " Custom ▁ Styles " ) ) ; m_displayBox -> insertItem ( 2 , i18n ( " Hierarchical " ) ) ; layout -> addWidget ( m_displayBox ) ; slotDisplayMode ( 0 ) ; enableButton ( KDialog :: User3 , true ) ; enableButton ( KDialog :: User2 , true ) ; enableButton ( KDialog :: User1 , false ) ; connect ( m_displayBox , SIGNAL ( activated ( int ) ) , this , SLOT ( slotDisplayMode ( int ) ) ) ; connect ( this , SIGNAL ( applyClicked ( ) ) , this , SLOT ( slotOk ( ) ) ) ; connect ( this , SIGNAL ( user3Clicked ( ) ) , this , SLOT ( slotNew ( ) ) ) ; connect ( this , SIGNAL ( user2Clicked ( ) ) , this , SLOT ( slotEdit ( ) ) ) ; connect ( this , SIGNAL ( user1Clicked ( ) ) , this , SLOT ( slotRemove ( ) ) ) ; connect ( m_styleList , SIGNAL ( itemDoubleClicked ( QTreeWidgetItem * , int ) ) , this , SLOT ( slotEdit ( ) ) ) ; connect ( m_styleList , SIGNAL ( currentItemChanged ( QTreeWidgetItem * , QTreeWidgetItem * ) ) , this , SLOT ( selectionChanged ( QTreeWidgetItem * ) ) ) ; }
void StyleManagerDialog :: fillComboBox ( ) { typedef QMap < KCCustomStyle * , QTreeWidgetItem * > KCMap ; KCMap entries ; entries . clear ( ) ; entries [ m_styleManager -> defaultStyle ( ) ] = new QTreeWidgetItem ( m_styleList , QStringList ( i18n ( " Default " ) ) ) ; CustomStyles :: const_iterator iter = m_styleManager -> m_styles . constBegin ( ) ; CustomStyles :: const_iterator end = m_styleManager -> m_styles . constEnd ( ) ; while ( entries . count ( ) != m_styleManager -> m_styles . count ( ) + 1 ) { if ( entries . find ( iter . value ( ) ) == entries . end ( ) ) { if ( iter . value ( ) -> parentName ( ) . isNull ( ) ) entries [ iter . value ( ) ] = new QTreeWidgetItem ( entries [ m_styleManager -> defaultStyle ( ) ] , QStringList ( iter . value ( ) -> name ( ) ) ) ; else { KCCustomStyle * parentStyle = m_styleManager -> style ( iter . value ( ) -> parentName ( ) ) ; if ( parentStyle ) { KCMap :: const_iterator i = entries . constFind ( parentStyle ) ; if ( i != entries . constEnd ( ) ) entries [ iter . value ( ) ] = new QTreeWidgetItem ( i . value ( ) , QStringList ( iter . value ( ) -> name ( ) ) ) ; } } } ++ iter ; if ( iter == end ) iter = m_styleManager -> m_styles . constBegin ( ) ; } entries . clear ( ) ; }
void StyleManagerDialog :: slotDisplayMode ( int mode ) { m_styleList -> clear ( ) ; if ( mode != 2 ) m_styleList -> setRootIsDecorated ( false ) ; else { m_styleList -> setRootIsDecorated ( true ) ; fillComboBox ( ) ; return ; } if ( mode != 1 ) new QTreeWidgetItem ( m_styleList , QStringList ( i18n ( " Default " ) ) ) ; CustomStyles :: iterator iter = m_styleManager -> m_styles . begin ( ) ; CustomStyles :: iterator end = m_styleManager -> m_styles . end ( ) ; while ( iter != end ) { KCCustomStyle * styleData = iter . value ( ) ; if ( ! styleData || styleData -> name ( ) . isEmpty ( ) ) { ++ iter ; continue ; } if ( mode == 1 ) { if ( styleData -> type ( ) == KCStyle :: CUSTOM ) new QTreeWidgetItem ( m_styleList , QStringList ( styleData -> name ( ) ) ) ; } else new QTreeWidgetItem ( m_styleList , QStringList ( styleData -> name ( ) ) ) ; ++ iter ; } }
void StyleManagerDialog :: slotOk ( ) { kDebug ( ) ; QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) { accept ( ) ; return ; } QString name ( item -> text ( 0 ) ) ; if ( name == i18n ( " Default " ) ) { KCStyleCommand * command = new KCStyleCommand ( ) ; command -> setSheet ( m_selection -> activeSheet ( ) ) ; command -> setDefault ( ) ; command -> add ( * m_selection ) ; command -> execute ( m_selection -> canvas ( ) ) ; } else { KCStyleCommand * command = new KCStyleCommand ( ) ; command -> setSheet ( m_selection -> activeSheet ( ) ) ; command -> setParentName ( name ) ; command -> add ( * m_selection ) ; command -> execute ( m_selection -> canvas ( ) ) ; } accept ( ) ; }
void StyleManagerDialog :: slotNew ( ) { KCCustomStyle * parentStyle = 0 ; QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( item ) { const QString name = item -> text ( 0 ) ; if ( name == i18n ( " Default " ) ) parentStyle = m_styleManager -> defaultStyle ( ) ; else parentStyle = m_styleManager -> style ( name ) ; } else parentStyle = m_styleManager -> defaultStyle ( ) ; int i = 1 ; QString newName ( i18n ( " style % 1" , m_styleManager -> count ( ) + i ) ) ; while ( m_styleManager -> style ( newName ) != 0 ) { ++ i ; newName = i18n ( " style % 1" , m_styleManager -> count ( ) + i ) ; } KCCustomStyle * style = new KCCustomStyle ( newName , parentStyle ) ; style -> setType ( KCStyle :: TENTATIVE ) ; QPointer < CellFormatDialog > dialog = new CellFormatDialog ( this , m_selection , style , m_styleManager ) ; dialog -> exec ( ) ; delete dialog ; if ( style -> type ( ) == KCStyle :: TENTATIVE ) { delete style ; return ; } m_styleManager -> m_styles [ style -> name ( ) ] = style ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; }
void StyleManagerDialog :: slotEdit ( ) { QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) return ; KCCustomStyle * style = 0 ; QString name ( item -> text ( 0 ) ) ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) return ; QPointer < CellFormatDialog > dialog = new CellFormatDialog ( this , m_selection , style , m_styleManager ) ; dialog -> exec ( ) ; if ( dialog -> result ( ) == Accepted ) m_selection -> emitRefreshSheetViews ( ) ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; delete dialog ; }
void StyleManagerDialog :: slotRemove ( ) { QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) return ; const QString name = item -> text ( 0 ) ; KCCustomStyle * style = 0 ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) return ; if ( style -> type ( ) != KCStyle :: CUSTOM ) return ; m_styleManager -> takeStyle ( style ) ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; }
void StyleManagerDialog :: selectionChanged ( QTreeWidgetItem * item ) { if ( ! item ) return ; const QString name = item -> text ( 0 ) ; KCCustomStyle * style = 0 ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) { enableButton ( KDialog :: User1 , false ) ; return ; } if ( style -> type ( ) == KCStyle :: BUILTIN ) enableButton ( KDialog :: User1 , false ) ; else enableButton ( KDialog :: User1 , true ) ; }
CMaze :: CMaze ( int nWidth , int nHeight , int nCellWidth , int nCellHeight , bool bCopyScreen ) { m_nCounter = 0 ; m_nWidth = nWidth ; m_nHeight = nHeight ; m_nCellWidth = nCellWidth ; m_nCellHeight = nCellHeight ; m_nCols = m_nWidth / m_nCellWidth - 1 ; m_nRows = m_nHeight / m_nCellHeight - 1 ; m_nOffsetX = ( m_nWidth - m_nCols * m_nCellWidth ) / 2 ; m_nOffsetY = ( m_nHeight - m_nRows * m_nCellHeight ) / 2 ; m_bReDrawBeforeGenerate = FALSE ; m_bAllowNonSolution = FALSE ; m_bFlashPath = TRUE ; HDC hScreenDc = GetDC ( NULL ) ; m_hWorkDc = CreateCompatibleDC ( NULL ) ; m_hWorkBmp = CreateCompatibleBitmap ( hScreenDc , m_nWidth , m_nHeight ) ; m_hOldBmp = SelectObject ( m_hWorkDc , ( HGDIOBJ ) m_hWorkBmp ) ; m_hOldPen = SelectObject ( m_hWorkDc , m_mazeColor . GetPen ( clWall ) ) ; if ( bCopyScreen ) { BitBlt ( m_hWorkDc , 0 , 0 , m_nWidth , m_nHeight , hScreenDc , 0 , 0 , SRCCOPY ) ; } ReleaseDC ( NULL , hScreenDc ) ; RECT rect = { 0 , 0 , m_nWidth , m_nHeight } ; FillRect ( m_hWorkDc , & rect , m_mazeColor . GetBrush ( clBackGround ) ) ; if ( m_nCols > 0 && m_nRows > 0 ) { m_cells = new CMazeCell [ m_nCols * m_nRows ] ; InitializeCells ( ) ; ResetAndReDrawAllCells ( ) ; m_state = MS_INITIALIZED ; } else { m_state = MS_ERROR ; m_cells = NULL ; } }
CMaze :: ~ CMaze ( void ) { SelectObject ( m_hWorkDc , m_hOldPen ) ; SelectObject ( m_hWorkDc , m_hOldBmp ) ; DeleteDC ( m_hWorkDc ) ; DeleteObject ( m_hWorkBmp ) ; if ( m_cells != NULL ) { delete [ ] m_cells ; } }
CMazeCell * CMaze :: GetCell ( int i , int j ) { if ( i < 0 || j < 0 || i >= m_nCols || j >= m_nRows ) { return NULL ; } return & m_cells [ j * m_nCols + i ] ; }
void CMaze :: InitializeCells ( ) { for ( int i = 0 ; i < m_nCols ; ++ i ) { for ( int j = 0 ; j < m_nRows ; ++ j ) { CMazeCell * pCell = GetCell ( i , j ) ; pCell -> SetParent ( this , i , j ) ; } } }
void CMaze :: ReDrawSides ( ) { int nPicWidth = m_nCols * m_nCellWidth ; int nPicHeight = m_nRows * m_nCellHeight ; MoveToEx ( m_hWorkDc , m_nOffsetX , m_nOffsetY , NULL ) ; LineTo ( m_hWorkDc , m_nOffsetX + nPicWidth , m_nOffsetY ) ; LineTo ( m_hWorkDc , m_nOffsetX + nPicWidth , m_nOffsetY + nPicHeight ) ; LineTo ( m_hWorkDc , m_nOffsetX , m_nOffsetY + nPicHeight ) ; LineTo ( m_hWorkDc , m_nOffsetX , m_nOffsetY ) ; }
void CMaze :: ResetAllCells ( ) { for ( int i = 0 ; i < m_nCols ; ++ i ) { for ( int j = 0 ; j < m_nRows ; ++ j ) { CMazeCell * pCell = GetCell ( i , j ) ; pCell -> Reset ( ) ; } } }
void CMaze :: ResetAndReDrawAllCells ( ) { for ( int i = 0 ; i < m_nCols ; ++ i ) { for ( int j = 0 ; j < m_nRows ; ++ j ) { CMazeCell * pCell = GetCell ( i , j ) ; pCell -> Reset ( ) ; pCell -> ReDraw ( ) ; } } ReDrawSides ( ) ; }
void CMaze :: ReDrawAllCells ( ) { for ( int i = 0 ; i < m_nCols ; ++ i ) { for ( int j = 0 ; j < m_nRows ; ++ j ) { CMazeCell * pCell = GetCell ( i , j ) ; pCell -> ReDraw ( ) ; } } ReDrawSides ( ) ; }
void CMaze :: Next ( BOOL bDelay ) { DWORD dwDelayValue = 0 ; switch ( m_state ) { case MS_INITIALIZED : m_cellGenerating = GetRandomCell ( ) ; m_cellStack . Init ( ) ; m_cellStack . Push ( m_cellGenerating ) ; m_cellGenerating -> m_bGenerated = true ; ChangeState ( MS_GENERATING ) ; break ; case MS_GENERATING : if ( m_cellStack . IsEmpty ( ) ) { ChangeState ( MS_GENERATED ) ; } else { bool bGetNewCell = false ; CMazeCell * pTopCell = m_cellStack . Top ( ) ; pTopCell -> ReDraw ( ) ; pTopCell -> GoGenerate ( & bGetNewCell ) ; if ( bGetNewCell ) { } } break ; case MS_GENERATED : if ( m_bAllowNonSolution && m_nRows * m_nCols >= 10 && m_nCols > 1 && m_nRows > 1 ) { int nRightWallsCount = ( m_nCols - 1 ) * m_nRows ; int nBottomWallsCount = ( m_nRows - 1 ) * m_nCols ; int nWallsCount = nRightWallsCount + nBottomWallsCount ; int nChangedWallsCount = nWallsCount * 2 / 100 ; set < int > setChangedWalls ; vector < int > vectorChangedWalls ; if ( nChangedWallsCount > 100 ) { nChangedWallsCount = 100 ; } while ( ( int ) setChangedWalls . size ( ) < nChangedWallsCount ) { setChangedWalls . insert ( BigRand ( ) % nWallsCount ) ; } vectorChangedWalls . assign ( setChangedWalls . begin ( ) , setChangedWalls . end ( ) ) ; random_shuffle ( vectorChangedWalls . begin ( ) , vectorChangedWalls . end ( ) ) ; for ( int i = 0 ; i < nChangedWallsCount ; ++ i ) { int nOffset = vectorChangedWalls . at ( i ) ; if ( nOffset < nRightWallsCount ) { int nRow = nOffset / ( m_nCols - 1 ) ; int nCol = nOffset % ( m_nCols - 1 ) ; CMazeCell * pCell = GetCell ( nCol , nRow ) ; pCell -> SetWall ( DIR_RIGHT , ! pCell -> GetWall ( DIR_RIGHT ) ) ; } else { nOffset -= nRightWallsCount ; int nRow = nOffset / m_nCols ; int nCol = nOffset % m_nCols ; CMazeCell * pCell = GetCell ( nCol , nRow ) ; pCell -> SetWall ( DIR_BOTTOM , ! pCell -> GetWall ( DIR_BOTTOM ) ) ; } } } ReDrawAllCells ( ) ; ChangeState ( MS_SETTING ) ; break ; case MS_SETTING : if ( true ) { int nCounter = GetCounter ( ) ; if ( nCounter == 0 ) { if ( rand ( ) % 5 == 0 ) { int bx [ ] = { 0 , 0 , 1 , 1 } ; int by [ ] = { 0 , 1 , 0 , 1 } ; int ex [ ] = { 1 , 1 , 0 , 0 } ; int ey [ ] = { 1 , 0 , 1 , 0 } ; int offset = rand ( ) % 4 ; m_cellBegin = GetCell ( ( GetCols ( ) - 1 ) * bx [ offset ] , ( GetRows ( ) - 1 ) * by [ offset ] ) ; m_cellEnd = GetCell ( ( GetCols ( ) - 1 ) * ex [ offset ] , ( GetRows ( ) - 1 ) * ey [ offset ] ) ; } else { m_cellBegin = GetRandomCell ( ) ; do { m_cellEnd = GetRandomCell ( ) ; } while ( m_cellEnd == m_cellBegin ) ; } m_cellBegin -> m_bIsBegin = true ; m_cellEnd -> m_bIsEnd = true ; } else if ( nCounter < 19 ) { m_cellBegin -> m_bIsBegin = ! m_cellBegin -> m_bIsBegin ; m_cellBegin -> ReDraw ( ) ; dwDelayValue = 55 ; } else if ( nCounter < 37 ) { m_cellEnd -> m_bIsEnd = ! m_cellEnd -> m_bIsEnd ; m_cellEnd -> ReDraw ( ) ; dwDelayValue = 55 ; } else { ChangeState ( MS_SET ) ; } } break ; case MS_SET : m_cellStack . Init ( ) ; m_cellStack . Push ( m_cellBegin ) ; m_cellBegin -> m_bVisited = true ; ChangeState ( MS_RESOLVING ) ; break ; case MS_RESOLVING : if ( m_cellStack . IsEmpty ( ) ) { ChangeState ( MS_RESOLVEFAILED ) ; } else { bool bGetNewCell = false ; CMazeCell * pTopCell = m_cellStack . Top ( ) ; pTopCell -> ReDraw ( ) ; if ( pTopCell == m_cellEnd ) { ChangeState ( MS_RESOLVED ) ; break ; } pTopCell -> GoResolve ( & bGetNewCell ) ; if ( bGetNewCell ) { } } dwDelayValue = 10 ; break ; case MS_RESOLVED : { int nCounter = GetCounter ( ) ; if ( nCounter > 5 ) { if ( m_bReDrawBeforeGenerate ) { ResetAndReDrawAllCells ( ) ; } else { ResetAllCells ( ) ; } ChangeState ( MS_INITIALIZED ) ; } else { if ( m_bFlashPath ) { COLORREF cl = m_mazeColor . GetColor ( clVisited ) ; m_mazeColor . SetColor ( clVisited , GetReverseColor ( cl ) ) ; ReDrawAllCells ( ) ; } dwDelayValue = 500 ; } } break ; case MS_RESOLVEFAILED : dwDelayValue = 3000 ; if ( m_bReDrawBeforeGenerate ) { ResetAndReDrawAllCells ( ) ; } else { ResetAllCells ( ) ; } ChangeState ( MS_INITIALIZED ) ; case MS_PAUSED : break ; case MS_ERROR : break ; default : break ; } if ( bDelay && dwDelayValue > 0 ) { Sleep ( dwDelayValue ) ; } }
CMazeColor & CMaze :: GetColorManager ( ) { return m_mazeColor ; }
CMazeCell * CMaze :: GetRandomCell ( ) { return GetCell ( rand ( ) % m_nCols , rand ( ) % m_nRows ) ; }
void CMaze :: MakeRandomBeginAndEndCell ( ) { m_cellBegin = GetRandomCell ( ) ; m_cellEnd = GetRandomCell ( ) ; while ( m_cellEnd == m_cellBegin ) { m_cellEnd = GetRandomCell ( ) ; } }
CMazeCellStack & CMaze :: GetCellStack ( ) { return m_cellStack ; }
void CMaze :: ChangeState ( MazeState state ) { if ( m_state != state ) { m_state = state ; m_nCounter = 0 ; } }
int CMaze :: GetCounter ( ) { return m_nCounter ++ ; }
int CMaze :: BigRand ( ) { return ( ( ( rand ( ) % 0x100 ) << 0 ) | ( ( rand ( ) % 0x100 ) << 8 ) | ( ( rand ( ) % 0x100 ) << 16 ) | ( ( rand ( ) % 0x100 ) << 24 ) ) & ( ( unsigned ) - 1 >> 1 ) ; }
COLORREF CMaze :: GetReverseColor ( COLORREF cl ) { return RGB ( ~ GetRValue ( cl ) , ~ GetGValue ( cl ) , ~ GetBValue ( cl ) ) ; }
void CMaze :: SetReDrawBeforeGenerate ( BOOL bReDrawBeforeGenerate ) { m_bReDrawBeforeGenerate = bReDrawBeforeGenerate ; }
void CMaze :: SetAllowNonSolution ( BOOL bAllowNonSolution ) { m_bAllowNonSolution = bAllowNonSolution ; }
void CMaze :: SetFlashPath ( BOOL bFlashPath ) { m_bFlashPath = bFlashPath ; }
void CMaze :: UpdateColors ( ) { SelectObject ( m_hWorkDc , m_mazeColor . GetPen ( clWall ) ) ; }
void CMaze :: Restart ( ) { if ( m_bReDrawBeforeGenerate ) { ResetAndReDrawAllCells ( ) ; } else { ResetAllCells ( ) ; } ChangeState ( MS_INITIALIZED ) ; }
CCFreeTypeFont :: ~ CCFreeTypeFont ( ) { reset ( ) ; }
void CCFreeTypeFont :: reset ( ) { for ( auto line : m_lines ) { line -> glyphs . clear ( ) ; delete line ; } m_lines . clear ( ) ; if ( m_face ) { FT_Done_Face ( m_face ) ; m_face = nullptr ; } }
unsigned char * CCFreeTypeFont :: initWithString ( const char * text , const FontDefinition & textDefinition , Device :: TextAlign align , int & width , int & height , ssize_t & dataLength ) { FT_Error error = 0 ; ssize_t size = 0 ; unsigned char * pBuffer = nullptr ; unsigned char * data = nullptr ; Size winSize = Director :: getInstance ( ) -> getWinSizeInPixels ( ) ; m_windowWidth = ( int ) winSize . width ; m_inWidth = textDefinition . _dimensions . width ; m_inHeight = textDefinition . _dimensions . height ; m_fontFillColorR = textDefinition . _fontFillColor . r ; m_fontFillColorG = textDefinition . _fontFillColor . g ; m_fontFillColorB = textDefinition . _fontFillColor . b ; auto ittFontNames = s_fontsNames . find ( textDefinition . _fontName ) ; if ( ittFontNames != s_fontsNames . end ( ) ) { pBuffer = ittFontNames -> second . pBuffer ; size = ittFontNames -> second . size ; } if ( ! pBuffer ) { pBuffer = loadFont ( textDefinition . _fontName . c_str ( ) , & size ) ; if ( ! pBuffer ) { pBuffer = loadSystemFont ( textDefinition . _fontName . c_str ( ) , & size ) ; } if ( ! pBuffer ) { pBuffer = loadFont ( " Arial " , & size ) ; } if ( ! pBuffer ) { pBuffer = loadSystemFont ( " Arial " , & size ) ; } if ( ! pBuffer ) { return false ; } FontBufferInfo info ; info . pBuffer = pBuffer ; info . size = size ; s_fontsNames [ textDefinition . _fontName ] = info ; } m_fontName = textDefinition . _fontName ; m_text = text ; if ( ! s_FreeTypeLibrary ) { error = FT_Init_FreeType ( & s_FreeTypeLibrary ) ; } if ( ! error && ! m_face ) { error = FT_New_Memory_Face ( s_FreeTypeLibrary , pBuffer , size , 0 , & m_face ) ; } if ( ! error ) { error = FT_Select_Charmap ( m_face , FT_ENCODING_UNICODE ) ; } if ( ! error ) { error = FT_Set_Char_Size ( m_face , textDefinition . _fontSize << 6 , textDefinition . _fontSize << 6 , 72 , 72 ) ; } if ( ! error ) { error = initGlyphs ( text ) ; } if ( ! error ) { data = getBitmap ( align , width , height , dataLength ) ; } delete [ ] pBuffer ; reset ( ) ; return data ; }
unsigned char * CCFreeTypeFont :: getBitmap ( Device :: TextAlign eAlignMask , int & width , int & height , ssize_t & dataLength ) { int lineNumber = 0 ; int totalLines = m_lines . size ( ) ; m_width = m_inWidth ? m_inWidth : m_textWidth ; m_height = m_inHeight ? m_inHeight : m_textHeight ; unsigned int size = m_width * m_height * 4 ; unsigned char * pBuffer = new unsigned char [ size ] ; dataLength = size ; if ( ! pBuffer ) { dataLength = 0 ; return nullptr ; } memset ( pBuffer , 0 , size ) ; for ( auto line = m_lines . begin ( ) ; line != m_lines . end ( ) ; ++ line ) { FT_Vector pen = getPenForAlignment ( * line , eAlignMask , lineNumber , totalLines ) ; drawText ( * line , pBuffer , & pen ) ; lineNumber ++ ; } width = m_width ; height = m_height ; return pBuffer ; }
FT_Vector CCFreeTypeFont :: getPenForAlignment ( FTLineInfo * pInfo , Device :: TextAlign eAlignMask , int lineNumber , int totalLines ) { FT_Error error = 0 ; FT_Vector pen ; int top ; int stringWidth = pInfo -> bbox . xMax - pInfo -> bbox . xMin ; int maxLineNumber = totalLines - 1 ; pen . x = 0 ; pen . y = 0 ; switch ( eAlignMask ) { case Device :: TextAlign :: TOP : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: TOP_LEFT : pen . x -= pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: TOP_RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM_RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM_LEFT : pen . x -= pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: CENTER : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; case Device :: TextAlign :: RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; case Device :: TextAlign :: LEFT : default : pen . x -= pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; } return pen ; }
void CCFreeTypeFont :: drawText ( FTLineInfo * pInfo , unsigned char * pBuffer , FT_Vector * pen ) { auto glyphs = pInfo -> glyphs ; for ( auto glyph = glyphs . begin ( ) ; glyph != glyphs . end ( ) ; ++ glyph ) { FT_Glyph image = glyph -> image ; FT_Error error = FT_Glyph_To_Bitmap ( & image , FT_RENDER_MODE_NORMAL , 0 , 1 ) ; if ( ! error ) { FT_BitmapGlyph bit = ( FT_BitmapGlyph ) image ; draw_bitmap ( pBuffer , & bit -> bitmap , pen -> x + glyph -> pos . x + bit -> left , pen -> y - bit -> top ) ; FT_Done_Glyph ( image ) ; } } }
void CCFreeTypeFont :: draw_bitmap ( unsigned char * pBuffer , FT_Bitmap * bitmap , FT_Int x , FT_Int y ) { FT_Int i , j , p , q ; FT_Int x_max = x + bitmap -> width ; FT_Int y_max = y + bitmap -> rows ; for ( i = x , p = 0 ; i < x_max ; i ++ , p ++ ) { for ( j = y , q = 0 ; j < y_max ; j ++ , q ++ ) { if ( i < 0 || j < 0 || i >= m_width || j >= m_height ) continue ; unsigned char value = bitmap -> buffer [ q * bitmap -> width + p ] ; if ( value > 0 ) { FT_Int index = ( j * m_width * 4 ) + ( i * 4 ) ; pBuffer [ index ++ ] = m_fontFillColorR ; pBuffer [ index ++ ] = m_fontFillColorG ; pBuffer [ index ++ ] = m_fontFillColorB ; pBuffer [ index ++ ] = value ; } } } }
void CCFreeTypeFont :: endLine ( ) { if ( m_currentLine ) { m_lines . push_back ( m_currentLine ) ; m_textWidth = std :: max ( ( long ) m_textWidth , m_currentLine -> bbox . xMax - m_currentLine -> bbox . xMin ) ; m_textHeight += m_lineHeight ; } }
void CCFreeTypeFont :: newLine ( ) { m_currentLine = new FTLineInfo ( ) ; m_currentLine -> width = 0 ; m_currentLine -> pen . x = 0 ; m_currentLine -> pen . y = 0 ; }
FT_Error CCFreeTypeFont :: addWord ( const std :: string & word ) { std :: vector < TGlyph > glyphs ; FT_BBox bbox ; int maxWidth = m_inWidth ? m_inWidth : m_windowWidth ; std :: string newWord ; if ( m_currentLine -> width > 0 ) { newWord = ' ▁ ' + word ; } else { newWord = word ; } FT_Error error = initWordGlyphs ( glyphs , newWord , m_currentLine -> pen ) ; if ( ! error ) { compute_bbox ( glyphs , & bbox ) ; if ( m_currentLine -> width == 0 || bbox . xMax <= maxWidth ) { m_currentLine -> glyphs . insert ( m_currentLine -> glyphs . end ( ) , glyphs . begin ( ) , glyphs . end ( ) ) ; if ( m_currentLine -> width == 0 ) { m_currentLine -> bbox = bbox ; } else { m_currentLine -> bbox . xMax = bbox . xMax ; } m_currentLine -> width = m_currentLine -> bbox . xMax - m_currentLine -> bbox . xMin ; } else { endLine ( ) ; newLine ( ) ; addWord ( word ) ; } } return error ; }
FT_Error CCFreeTypeFont :: initGlyphs ( const char * text ) { FT_Error error = 0 ; std :: stringstream stringStream ( text ) ; std :: string line ; vector < std :: string > lines ; vector < std :: string > words ; m_textWidth = 0 ; m_textHeight = 0 ; m_lineHeight = ( ( m_face -> size -> metrics . ascender ) >> 6 ) - ( ( m_face -> size -> metrics . descender ) >> 6 ) ; m_lines . clear ( ) ; while ( std :: getline ( stringStream , line ) && ! error ) { newLine ( ) ; std :: size_t prev = 0 , pos ; while ( ( pos = line . find_first_of ( " ▁ " , prev ) ) != std :: string :: npos ) { if ( pos > prev ) { addWord ( line . substr ( prev , pos - prev ) ) ; } prev = pos + 1 ; } if ( prev < line . length ( ) ) { addWord ( line . substr ( prev , std :: string :: npos ) ) ; } endLine ( ) ; } return error ; }
void CCFreeTypeFont :: initWords ( const char * text ) { std :: stringstream stringStream ( text ) ; std :: string line ; vector < std :: string > lines ; vector < std :: string > words ; while ( std :: getline ( stringStream , line ) ) { lines . push_back ( line ) ; } for ( auto it = lines . begin ( ) ; it != lines . end ( ) ; ++ it ) { std :: size_t prev = 0 , pos ; while ( ( pos = it -> find_first_of ( " ▁ ' ; " , prev ) ) != std :: string :: npos ) { if ( pos > prev ) words . push_back ( it -> substr ( prev , pos - prev ) ) ; prev = pos + 1 ; } if ( prev < it -> length ( ) ) words . push_back ( it -> substr ( prev , std :: string :: npos ) ) ; } for ( auto it = words . begin ( ) ; it != words . end ( ) ; ++ it ) { std :: string foo ( * it ) ; } }
FT_Error CCFreeTypeFont :: initWordGlyphs ( std :: vector < TGlyph > & glyphs , const std :: string & text , FT_Vector & pen ) { FT_GlyphSlot slot = m_face -> glyph ; FT_UInt glyph_index ; FT_UInt previous = 0 ; FT_Error error = 0 ; PGlyph glyph ; unsigned int numGlyphs = 0 ; wchar_t * pwszBuffer = nullptr ; int num_chars = text . size ( ) ; int nBufLen = num_chars + 1 ; pwszBuffer = new wchar_t [ nBufLen ] ; if ( ! pwszBuffer ) { return - 1 ; } memset ( pwszBuffer , 0 , nBufLen ) ; num_chars = MultiByteToWideChar ( CP_UTF8 , 0 , text . c_str ( ) , num_chars , pwszBuffer , nBufLen ) ; pwszBuffer [ num_chars ] = ' \0' ; glyphs . clear ( ) ; glyphs . resize ( num_chars ) ; FT_Bool useKerning = FT_HAS_KERNING ( m_face ) ; for ( int n = 0 ; n < num_chars ; n ++ ) { glyph = & glyphs [ numGlyphs ] ; FT_ULong c = pwszBuffer [ n ] ; glyph_index = FT_Get_Char_Index ( m_face , c ) ; if ( useKerning && previous && glyph_index ) { FT_Vector delta ; FT_Get_Kerning ( m_face , previous , glyph_index , FT_KERNING_DEFAULT , & delta ) ; pen . x += delta . x >> 6 ; } glyph -> pos = pen ; glyph -> index = glyph_index ; error = FT_Load_Glyph ( m_face , glyph_index , FT_LOAD_DEFAULT ) ; if ( error ) continue ; error = FT_Get_Glyph ( m_face -> glyph , & glyph -> image ) ; if ( error ) continue ; FT_Glyph_Transform ( glyph -> image , 0 , & glyph -> pos ) ; pen . x += slot -> advance . x >> 6 ; previous = glyph_index ; numGlyphs ++ ; } CC_SAFE_DELETE_ARRAY ( pwszBuffer ) ; return error ; }
void CCFreeTypeFont :: compute_bbox ( std :: vector < TGlyph > & glyphs , FT_BBox * abbox ) { FT_BBox bbox ; FT_BBox glyph_bbox ; bbox . xMin = 32000 ; bbox . xMax = - 32000 ; bbox . yMin = ( m_face -> size -> metrics . descender ) >> 6 ; bbox . yMax = ( m_face -> size -> metrics . ascender ) >> 6 ; for ( auto glyph = glyphs . begin ( ) ; glyph != glyphs . end ( ) ; ++ glyph ) { FT_Glyph_Get_CBox ( glyph -> image , ft_glyph_bbox_pixels , & glyph_bbox ) ; glyph_bbox . xMin += glyph -> pos . x ; glyph_bbox . xMax += glyph -> pos . x ; glyph_bbox . yMin += glyph -> pos . y ; glyph_bbox . yMax += glyph -> pos . y ; if ( glyph_bbox . xMin < bbox . xMin ) bbox . xMin = glyph_bbox . xMin ; if ( glyph_bbox . yMin < bbox . yMin ) bbox . yMin = glyph_bbox . yMin ; if ( glyph_bbox . xMax > bbox . xMax ) bbox . xMax = glyph_bbox . xMax ; if ( glyph_bbox . yMax > bbox . yMax ) bbox . yMax = glyph_bbox . yMax ; } if ( bbox . xMin > bbox . xMax ) { bbox . xMin = 0 ; bbox . yMin = 0 ; bbox . xMax = 0 ; bbox . yMax = 0 ; } * abbox = bbox ; }
unsigned char * CCFreeTypeFont :: loadFont ( const char * pFontName , ssize_t * size ) { std :: string lowerCase ( pFontName ) ; std :: string path ( pFontName ) ; for ( unsigned int i = 0 ; i < lowerCase . length ( ) ; ++ i ) { lowerCase [ i ] = tolower ( lowerCase [ i ] ) ; } if ( std :: string :: npos == lowerCase . find ( " fonts / " ) ) { path = " fonts / " ; path += pFontName ; } if ( std :: string :: npos == lowerCase . find ( " . ttf " ) ) { path += " . ttf " ; } std :: string fullpath = FileUtils :: getInstance ( ) -> fullPathForFilename ( path . c_str ( ) ) ; return FileUtils :: sharedFileUtils ( ) -> getFileData ( fullpath . c_str ( ) , " rb " , size ) ; }
unsigned char * CCFreeTypeFont :: loadSystemFont ( const char * pFontName , ssize_t * size ) { CC_TARGET_PLATFORM == CC_PLATFORM_WP8 ) return nullptr ; std :: string aName ( pFontName ) ; unsigned char * pBuffer = nullptr ; HRESULT hr = S_OK ; IDWriteFactory * writeFactory = nullptr ; IDWriteFontCollection * fontCollection = nullptr ; IDWriteFontFamily * fontFamily = nullptr ; IDWriteFont * matchingFont = nullptr ; IDWriteFontFace * fontFace = nullptr ; IDWriteFontFile * fontFile = nullptr ; IDWriteFontFileLoader * fontFileLoader = nullptr ; IDWriteFontFileStream * fontFileStream = nullptr ; UINT32 index ; BOOL exists ; std :: wstring fontNameW ; const void * fontFileReferenceKey = nullptr ; UINT32 fontFileReferenceKeySize ; void * fragmentContext = nullptr ; for ( unsigned int i = 0 ; i < aName . length ( ) ; ++ i ) { aName [ i ] = tolower ( aName [ i ] ) ; } fontNameW . assign ( aName . begin ( ) , aName . end ( ) ) ; hr = DWriteCreateFactory ( DWRITE_FACTORY_TYPE_SHARED , __uuidof ( IDWriteFactory ) , reinterpret_cast < IUnknown * * > ( & writeFactory ) ) ; if ( SUCCEEDED ( hr ) ) { hr = writeFactory -> GetSystemFontCollection ( & fontCollection , TRUE ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontCollection -> FindFamilyName ( fontNameW . c_str ( ) , & index , & exists ) ; if ( SUCCEEDED ( hr ) && exists ) { hr = fontCollection -> GetFontFamily ( index , & fontFamily ) ; if ( SUCCEEDED ( hr ) ) { hr = fontFamily -> GetFirstMatchingFont ( DWRITE_FONT_WEIGHT_REGULAR , DWRITE_FONT_STRETCH_NORMAL , DWRITE_FONT_STYLE_NORMAL , & matchingFont ) ; } if ( SUCCEEDED ( hr ) ) { hr = matchingFont -> CreateFontFace ( & fontFace ) ; } if ( SUCCEEDED ( hr ) ) { UINT32 numberOfFiles = 1 ; hr = fontFace -> GetFiles ( & numberOfFiles , & fontFile ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFile -> GetReferenceKey ( & fontFileReferenceKey , & fontFileReferenceKeySize ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFile -> GetLoader ( & fontFileLoader ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFileLoader -> CreateStreamFromKey ( fontFileReferenceKey , fontFileReferenceKeySize , & fontFileStream ) ; } if ( SUCCEEDED ( hr ) ) { UINT64 fileSize ; const void * fragmentStart = nullptr ; hr = fontFileStream -> GetFileSize ( & fileSize ) ; if ( SUCCEEDED ( hr ) ) { hr = fontFileStream -> ReadFileFragment ( & fragmentStart , 0 , fileSize , & fragmentContext ) ; } if ( SUCCEEDED ( hr ) ) { pBuffer = ( unsigned char * ) malloc ( ( size_t ) fileSize ) ; memcpy ( pBuffer , fragmentStart , ( size_t ) fileSize ) ; * size = ( unsigned long ) fileSize ; } } } } if ( fontFileStream ) { fontFileStream -> ReleaseFileFragment ( fragmentContext ) ; fontFileStream -> Release ( ) ; } if ( fontFileLoader ) { fontFileLoader -> Release ( ) ; } if ( fontFile ) { fontFile -> Release ( ) ; } if ( fontFace ) { fontFace -> Release ( ) ; } if ( matchingFont ) { matchingFont -> Release ( ) ; } if ( fontFamily ) { fontFamily -> Release ( ) ; } if ( fontCollection ) { fontCollection -> Release ( ) ; } if ( writeFactory ) { writeFactory -> Release ( ) ; } return pBuffer ; }
void WorldSession :: HandleRepopRequestOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ REPOP _ REQUEST ▁ Message " ) ; recvData . read_skip < uint8 > ( ) ; if ( GetPlayer ( ) -> IsAlive ( ) || GetPlayer ( ) -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_GHOST ) ) return ; if ( GetPlayer ( ) -> HasAuraType ( SPELL_AURA_PREVENT_RESURRECTION ) ) return ; if ( GetPlayer ( ) -> getDeathState ( ) == JUST_DIED ) { TC_LOG_DEBUG ( " network " , " HandleRepopRequestOpcode : ▁ got ▁ request ▁ after ▁ player ▁ % s ( % d ) ▁ was ▁ killed ▁ and ▁ before ▁ he ▁ was ▁ updated " , GetPlayer ( ) -> GetName ( ) . c_str ( ) , GetPlayer ( ) -> GetGUID ( ) . GetCounter ( ) ) ; GetPlayer ( ) -> KillPlayer ( ) ; } GetPlayer ( ) -> RemoveGhoul ( ) ; GetPlayer ( ) -> RemovePet ( NULL , PET_SAVE_NOT_IN_SLOT , true ) ; GetPlayer ( ) -> BuildPlayerRepop ( ) ; GetPlayer ( ) -> RepopAtGraveyard ( ) ; }
void WorldSession :: HandleGossipSelectOptionOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ GOSSIP _ SELECT _ OPTION " ) ; uint32 gossipListId ; uint32 menuId ; ObjectGuid guid ; std :: string code = " " ; recvData >> guid >> menuId >> gossipListId ; if ( ! _player -> PlayerTalkClass -> GetGossipMenu ( ) . GetItem ( gossipListId ) ) { recvData . rfinish ( ) ; return ; } if ( _player -> PlayerTalkClass -> IsGossipOptionCoded ( gossipListId ) ) recvData >> code ; if ( _player -> PlayerTalkClass -> GetGossipMenu ( ) . GetSenderGUID ( ) != guid ) return ; Creature * unit = NULL ; GameObject * go = NULL ; if ( guid . IsCreatureOrVehicle ( ) ) { unit = GetPlayer ( ) -> GetNPCIfCanInteractWith ( guid , UNIT_NPC_FLAG_GOSSIP ) ; if ( ! unit ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ HandleGossipSelectOptionOpcode ▁ - ▁ % s ▁ not ▁ found ▁ or ▁ you ▁ can ' t ▁ interact ▁ with ▁ him . " , guid . ToString ( ) . c_str ( ) ) ; return ; } } else if ( guid . IsGameObject ( ) ) { go = _player -> GetGameObjectIfCanInteractWith ( guid ) ; if ( ! go ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ HandleGossipSelectOptionOpcode ▁ - ▁ % s ▁ not ▁ found ▁ or ▁ you ▁ can ' t ▁ interact ▁ with ▁ it . " , guid . ToString ( ) . c_str ( ) ) ; return ; } } else { TC_LOG_DEBUG ( " network " , " WORLD : ▁ HandleGossipSelectOptionOpcode ▁ - ▁ unsupported ▁ % s . " , guid . ToString ( ) . c_str ( ) ) ; return ; } if ( GetPlayer ( ) -> HasUnitState ( UNIT_STATE_DIED ) ) GetPlayer ( ) -> RemoveAurasByType ( SPELL_AURA_FEIGN_DEATH ) ; if ( ( unit && unit -> GetScriptId ( ) != unit -> LastUsedScriptID ) || ( go && go -> GetScriptId ( ) != go -> LastUsedScriptID ) ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ HandleGossipSelectOptionOpcode ▁ - ▁ Script ▁ reloaded ▁ while ▁ in ▁ use , ▁ ignoring ▁ and ▁ set ▁ new ▁ scipt ▁ id " ) ; if ( unit ) unit -> LastUsedScriptID = unit -> GetScriptId ( ) ; if ( go ) go -> LastUsedScriptID = go -> GetScriptId ( ) ; _player -> PlayerTalkClass -> SendCloseGossip ( ) ; return ; } if ( ! code . empty ( ) ) { if ( unit ) { unit -> AI ( ) -> sGossipSelectCode ( _player , menuId , gossipListId , code . c_str ( ) ) ; if ( ! sScriptMgr -> OnGossipSelectCode ( _player , unit , _player -> PlayerTalkClass -> GetGossipOptionSender ( gossipListId ) , _player -> PlayerTalkClass -> GetGossipOptionAction ( gossipListId ) , code . c_str ( ) ) ) _player -> OnGossipSelect ( unit , gossipListId , menuId ) ; } else { go -> AI ( ) -> GossipSelectCode ( _player , menuId , gossipListId , code . c_str ( ) ) ; if ( ! sScriptMgr -> OnGossipSelectCode ( _player , go , _player -> PlayerTalkClass -> GetGossipOptionSender ( gossipListId ) , _player -> PlayerTalkClass -> GetGossipOptionAction ( gossipListId ) , code . c_str ( ) ) ) _player -> OnGossipSelect ( go , gossipListId , menuId ) ; } } else { if ( unit ) { unit -> AI ( ) -> sGossipSelect ( _player , menuId , gossipListId ) ; if ( ! sScriptMgr -> OnGossipSelect ( _player , unit , _player -> PlayerTalkClass -> GetGossipOptionSender ( gossipListId ) , _player -> PlayerTalkClass -> GetGossipOptionAction ( gossipListId ) ) ) _player -> OnGossipSelect ( unit , gossipListId , menuId ) ; } else { go -> AI ( ) -> GossipSelect ( _player , menuId , gossipListId ) ; if ( ! sScriptMgr -> OnGossipSelect ( _player , go , _player -> PlayerTalkClass -> GetGossipOptionSender ( gossipListId ) , _player -> PlayerTalkClass -> GetGossipOptionAction ( gossipListId ) ) ) _player -> OnGossipSelect ( go , gossipListId , menuId ) ; } } }
void WorldSession :: HandleWhoOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ WHO ▁ Message " ) ; uint32 matchCount = 0 ; uint32 levelMin , levelMax , racemask , classmask , zonesCount , strCount ; uint32 zoneids [ 10 ] ; std :: string packetPlayerName , packetGuildName ; recvData >> levelMin ; recvData >> levelMax ; recvData >> packetPlayerName ; recvData >> packetGuildName ; recvData >> racemask ; recvData >> classmask ; recvData >> zonesCount ; if ( zonesCount > 10 ) return ; for ( uint32 i = 0 ; i < zonesCount ; ++ i ) { uint32 temp ; recvData >> temp ; zoneids [ i ] = temp ; TC_LOG_DEBUG ( " network " , " Zone ▁ % u : ▁ % u " , i , zoneids [ i ] ) ; } recvData >> strCount ; if ( strCount > 4 ) return ; TC_LOG_DEBUG ( " network " , " Minlvl ▁ % u , ▁ maxlvl ▁ % u , ▁ name ▁ % s , ▁ guild ▁ % s , ▁ racemask ▁ % u , ▁ classmask ▁ % u , ▁ zones ▁ % u , ▁ strings ▁ % u " , levelMin , levelMax , packetPlayerName . c_str ( ) , packetGuildName . c_str ( ) , racemask , classmask , zonesCount , strCount ) ; std :: wstring str [ 4 ] ; for ( uint32 i = 0 ; i < strCount ; ++ i ) { std :: string temp ; recvData >> temp ; if ( ! Utf8toWStr ( temp , str [ i ] ) ) continue ; wstrToLower ( str [ i ] ) ; TC_LOG_DEBUG ( " network " , " String ▁ % u : ▁ % s " , i , temp . c_str ( ) ) ; } std :: wstring wpacketPlayerName ; std :: wstring wpacketGuildName ; if ( ! ( Utf8toWStr ( packetPlayerName , wpacketPlayerName ) && Utf8toWStr ( packetGuildName , wpacketGuildName ) ) ) return ; wstrToLower ( wpacketPlayerName ) ; wstrToLower ( wpacketGuildName ) ; if ( levelMax >= MAX_LEVEL ) levelMax = STRONG_MAX_LEVEL ; uint32 team = _player -> GetTeam ( ) ; uint32 gmLevelInWhoList = sWorld -> getIntConfig ( CONFIG_GM_LEVEL_IN_WHO_LIST ) ; uint32 displayCount = 0 ; WorldPacket data ( SMSG_WHO , 500 ) ; data << uint32 ( matchCount ) ; data << uint32 ( displayCount ) ; WhoListInfoVector const & whoList = sWhoListStorageMgr -> GetWhoList ( ) ; for ( WhoListPlayerInfo const & target : whoList ) { if ( target . GetTeam ( ) != team && ! HasPermission ( rbac :: RBAC_PERM_TWO_SIDE_WHO_LIST ) ) continue ; if ( ! HasPermission ( rbac :: RBAC_PERM_WHO_SEE_ALL_SEC_LEVELS ) && target . GetSecurity ( ) > AccountTypes ( gmLevelInWhoList ) ) continue ; if ( _player -> GetGUID ( ) != target . GetGuid ( ) && ! target . IsVisible ( ) ) if ( AccountMgr :: IsPlayerAccount ( _player -> GetSession ( ) -> GetSecurity ( ) ) || target . GetSecurity ( ) > _player -> GetSession ( ) -> GetSecurity ( ) ) continue ; uint8 lvl = target . GetLevel ( ) ; if ( lvl < levelMin || lvl > levelMax ) continue ; uint8 class_ = target . GetClass ( ) ; if ( ! ( classmask & ( 1 << class_ ) ) ) continue ; uint32 race = target . GetRace ( ) ; if ( ! ( racemask & ( 1 << race ) ) ) continue ; uint32 playerZoneId = target . GetZoneId ( ) ; uint8 gender = target . GetGender ( ) ; bool showZones = true ; for ( uint32 i = 0 ; i < zonesCount ; ++ i ) { if ( zoneids [ i ] == playerZoneId ) { showZones = true ; break ; } showZones = false ; } if ( ! showZones ) continue ; std :: wstring const & wideplayername = target . GetWidePlayerName ( ) ; if ( ! ( wpacketPlayerName . empty ( ) || wideplayername . find ( wpacketPlayerName ) != std :: wstring :: npos ) ) continue ; std :: wstring const & wideguildname = target . GetWideGuildName ( ) ; if ( ! ( wpacketGuildName . empty ( ) || wideguildname . find ( wpacketGuildName ) != std :: wstring :: npos ) ) continue ; std :: string aname ; if ( AreaTableEntry const * areaEntry = sAreaTableStore . LookupEntry ( playerZoneId ) ) aname = areaEntry -> area_name [ GetSessionDbcLocale ( ) ] ; bool s_show = true ; for ( uint32 i = 0 ; i < strCount ; ++ i ) { if ( ! str [ i ] . empty ( ) ) { if ( wideguildname . find ( str [ i ] ) != std :: wstring :: npos || wideplayername . find ( str [ i ] ) != std :: wstring :: npos || Utf8FitTo ( aname , str [ i ] ) ) { s_show = true ; break ; } s_show = false ; } } if ( ! s_show ) continue ; if ( ( matchCount ++ ) >= sWorld -> getIntConfig ( CONFIG_MAX_WHO ) ) continue ; data << target . GetPlayerName ( ) ; data << target . GetGuildName ( ) ; data << uint32 ( lvl ) ; data << uint32 ( class_ ) ; data << uint32 ( race ) ; data << uint8 ( gender ) ; data << uint32 ( playerZoneId ) ; ++ displayCount ; } data . put ( 0 , displayCount ) ; data . put ( 4 , matchCount ) ; SendPacket ( & data ) ; TC_LOG_DEBUG ( " network " , " WORLD : ▁ Send ▁ SMSG _ WHO ▁ Message " ) ; }
void WorldSession :: HandleLogoutRequestOpcode ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ LOGOUT _ REQUEST ▁ Message , ▁ security ▁ - ▁ % u " , GetSecurity ( ) ) ; if ( ObjectGuid lguid = GetPlayer ( ) -> GetLootGUID ( ) ) DoLootRelease ( lguid ) ; bool instantLogout = ( GetPlayer ( ) -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_RESTING ) && ! GetPlayer ( ) -> IsInCombat ( ) ) || GetPlayer ( ) -> IsInFlight ( ) || HasPermission ( rbac :: RBAC_PERM_INSTANT_LOGOUT ) ; bool canLogoutInCombat = GetPlayer ( ) -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_RESTING ) ; uint32 reason = 0 ; if ( GetPlayer ( ) -> IsInCombat ( ) && ! canLogoutInCombat ) reason = 1 ; else if ( GetPlayer ( ) -> m_movementInfo . HasMovementFlag ( MOVEMENTFLAG_FALLING | MOVEMENTFLAG_FALLING_FAR ) ) reason = 3 ; else if ( GetPlayer ( ) -> duel || GetPlayer ( ) -> HasAura ( 9454 ) ) reason = 2 ; WorldPacket data ( SMSG_LOGOUT_RESPONSE , 1 + 4 ) ; data << uint32 ( reason ) ; data << uint8 ( instantLogout ) ; SendPacket ( & data ) ; if ( reason ) { LogoutRequest ( 0 ) ; return ; } if ( instantLogout ) { LogoutPlayer ( true ) ; return ; } if ( GetPlayer ( ) -> CanFreeMove ( ) ) { if ( GetPlayer ( ) -> GetStandState ( ) == UNIT_STAND_STATE_STAND ) GetPlayer ( ) -> SetStandState ( UNIT_STAND_STATE_SIT ) ; WorldPacket data ( SMSG_FORCE_MOVE_ROOT , ( 8 + 4 ) ) ; data << GetPlayer ( ) -> GetPackGUID ( ) ; data << ( uint32 ) 2 ; SendPacket ( & data ) ; GetPlayer ( ) -> SetFlag ( UNIT_FIELD_FLAGS , UNIT_FLAG_STUNNED ) ; } LogoutRequest ( time ( NULL ) ) ; }
void WorldSession :: HandlePlayerLogoutOpcode ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ PLAYER _ LOGOUT ▁ Message " ) ; }
void WorldSession :: HandleLogoutCancelOpcode ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ LOGOUT _ CANCEL ▁ Message " ) ; if ( ! GetPlayer ( ) ) return ; LogoutRequest ( 0 ) ; WorldPacket data ( SMSG_LOGOUT_CANCEL_ACK , 0 ) ; SendPacket ( & data ) ; if ( GetPlayer ( ) -> CanFreeMove ( ) ) { data . Initialize ( SMSG_FORCE_MOVE_UNROOT , 8 ) ; data << GetPlayer ( ) -> GetPackGUID ( ) ; data << uint32 ( 0 ) ; SendPacket ( & data ) ; GetPlayer ( ) -> SetStandState ( UNIT_STAND_STATE_STAND ) ; GetPlayer ( ) -> RemoveFlag ( UNIT_FIELD_FLAGS , UNIT_FLAG_STUNNED ) ; } }
void WorldSession :: HandleTogglePvP ( WorldPacket & recvData ) { if ( recvData . size ( ) == 1 ) { bool newPvPStatus ; recvData >> newPvPStatus ; GetPlayer ( ) -> ApplyModFlag ( PLAYER_FLAGS , PLAYER_FLAGS_IN_PVP , newPvPStatus ) ; GetPlayer ( ) -> ApplyModFlag ( PLAYER_FLAGS , PLAYER_FLAGS_PVP_TIMER , ! newPvPStatus ) ; } else { GetPlayer ( ) -> ToggleFlag ( PLAYER_FLAGS , PLAYER_FLAGS_IN_PVP ) ; GetPlayer ( ) -> ToggleFlag ( PLAYER_FLAGS , PLAYER_FLAGS_PVP_TIMER ) ; } if ( GetPlayer ( ) -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_IN_PVP ) ) { if ( ! GetPlayer ( ) -> IsPvP ( ) || GetPlayer ( ) -> pvpInfo . EndTimer ) GetPlayer ( ) -> UpdatePvP ( true , true ) ; } else { if ( ! GetPlayer ( ) -> pvpInfo . IsHostile && GetPlayer ( ) -> IsPvP ( ) ) GetPlayer ( ) -> pvpInfo . EndTimer = time ( NULL ) ; } }
void WorldSession :: HandleZoneUpdateOpcode ( WorldPacket & recvData ) { uint32 newZone ; recvData >> newZone ; TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ ZONE _ UPDATE : ▁ % u " , newZone ) ; GetPlayer ( ) -> SetNeedsZoneUpdate ( true ) ; }
void WorldSession :: HandleSetSelectionOpcode ( WorldPacket & recvData ) { ObjectGuid guid ; recvData >> guid ; _player -> SetSelection ( guid ) ; }
void WorldSession :: HandleStandStateChangeOpcode ( WorldPacket & recvData ) { uint32 animstate ; recvData >> animstate ; _player -> SetStandState ( animstate ) ; }
void WorldSession :: HandleBugOpcode ( WorldPacket & recvData ) { uint32 suggestion , contentlen , typelen ; std :: string content , type ; recvData >> suggestion >> contentlen >> content ; recvData >> typelen >> type ; if ( suggestion == 0 ) TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ BUG ▁ [ Bug ▁ Report ] " ) ; else TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ BUG ▁ [ Suggestion ] " ) ; TC_LOG_DEBUG ( " network " , " % s " , type . c_str ( ) ) ; TC_LOG_DEBUG ( " network " , " % s " , content . c_str ( ) ) ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_BUG_REPORT ) ; stmt -> setString ( 0 , type ) ; stmt -> setString ( 1 , content ) ; CharacterDatabase . Execute ( stmt ) ; }
void WorldSession :: HandleReclaimCorpseOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ RECLAIM _ CORPSE " ) ; ObjectGuid guid ; recvData >> guid ; if ( _player -> IsAlive ( ) ) return ; if ( _player -> InArena ( ) ) return ; if ( ! _player -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_GHOST ) ) return ; Corpse * corpse = _player -> GetCorpse ( ) ; if ( ! corpse ) return ; if ( time_t ( corpse -> GetGhostTime ( ) + _player -> GetCorpseReclaimDelay ( corpse -> GetType ( ) == CORPSE_RESURRECTABLE_PVP ) ) > time_t ( time ( NULL ) ) ) return ; if ( ! corpse -> IsWithinDistInMap ( _player , CORPSE_RECLAIM_RADIUS , true ) ) return ; _player -> ResurrectPlayer ( _player -> InBattleground ( ) ? 1.0f : 0.5f ) ; _player -> SpawnCorpseBones ( ) ; }
void WorldSession :: HandleResurrectResponseOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ RESURRECT _ RESPONSE " ) ; ObjectGuid guid ; uint8 status ; recvData >> guid ; recvData >> status ; if ( GetPlayer ( ) -> IsAlive ( ) ) return ; if ( status == 0 ) { GetPlayer ( ) -> ClearResurrectRequestData ( ) ; return ; } if ( ! GetPlayer ( ) -> IsResurrectRequestedBy ( guid ) ) return ; GetPlayer ( ) -> ResurrectUsingRequestData ( ) ; }
void WorldSession :: SendAreaTriggerMessage ( const char * Text , ... ) { va_list ap ; char szStr [ 1024 ] ; szStr [ 0 ] = ' \0' ; va_start ( ap , Text ) ; vsnprintf ( szStr , 1024 , Text , ap ) ; va_end ( ap ) ; uint32 length = strlen ( szStr ) + 1 ; WorldPacket data ( SMSG_AREA_TRIGGER_MESSAGE , 4 + length ) ; data << length ; data << szStr ; SendPacket ( & data ) ; }
void WorldSession :: HandleAreaTriggerOpcode ( WorldPacket & recvData ) { uint32 triggerId ; recvData >> triggerId ; TC_LOG_DEBUG ( " network " , " CMSG _ AREATRIGGER . ▁ Trigger ▁ ID : ▁ % u " , triggerId ) ; Player * player = GetPlayer ( ) ; if ( player -> IsInFlight ( ) ) { TC_LOG_DEBUG ( " network " , " HandleAreaTriggerOpcode : ▁ Player ▁ ' % s ' ▁ ( GUID : ▁ % u ) ▁ in ▁ flight , ▁ ignore ▁ Area ▁ Trigger ▁ ID : % u " , player -> GetName ( ) . c_str ( ) , player -> GetGUID ( ) . GetCounter ( ) , triggerId ) ; return ; } AreaTriggerEntry const * atEntry = sAreaTriggerStore . LookupEntry ( triggerId ) ; if ( ! atEntry ) { TC_LOG_DEBUG ( " network " , " HandleAreaTriggerOpcode : ▁ Player ▁ ' % s ' ▁ ( GUID : ▁ % u ) ▁ send ▁ unknown ▁ ( by ▁ DBC ) ▁ Area ▁ Trigger ▁ ID : % u " , player -> GetName ( ) . c_str ( ) , player -> GetGUID ( ) . GetCounter ( ) , triggerId ) ; return ; } if ( ! player -> IsInAreaTriggerRadius ( atEntry ) ) { TC_LOG_DEBUG ( " network " , " HandleAreaTriggerOpcode : ▁ Player ▁ ' % s ' ▁ ( GUID : ▁ % u ) ▁ too ▁ far , ▁ ignore ▁ Area ▁ Trigger ▁ ID : ▁ % u " , player -> GetName ( ) . c_str ( ) , player -> GetGUID ( ) . GetCounter ( ) , triggerId ) ; return ; } if ( player -> isDebugAreaTriggers ) ChatHandler ( player -> GetSession ( ) ) . PSendSysMessage ( LANG_DEBUG_AREATRIGGER_REACHED , triggerId ) ; if ( sScriptMgr -> OnAreaTrigger ( player , atEntry ) ) return ; if ( player -> IsAlive ( ) ) if ( uint32 questId = sObjectMgr -> GetQuestForAreaTrigger ( triggerId ) ) if ( player -> GetQuestStatus ( questId ) == QUEST_STATUS_INCOMPLETE ) player -> AreaExploredOrEventHappens ( questId ) ; if ( sObjectMgr -> IsTavernAreaTrigger ( triggerId ) ) { player -> SetRestFlag ( REST_FLAG_IN_TAVERN , atEntry -> id ) ; if ( sWorld -> IsFFAPvPRealm ( ) ) player -> RemoveByteFlag ( UNIT_FIELD_BYTES_2 , UNIT_BYTES_2_OFFSET_PVP_FLAG , UNIT_BYTE2_FLAG_FFA_PVP ) ; return ; } if ( Battleground * bg = player -> GetBattleground ( ) ) if ( bg -> GetStatus ( ) == STATUS_IN_PROGRESS ) bg -> HandleAreaTrigger ( player , triggerId ) ; if ( OutdoorPvP * pvp = player -> GetOutdoorPvP ( ) ) if ( pvp -> HandleAreaTrigger ( _player , triggerId ) ) return ; AreaTrigger const * at = sObjectMgr -> GetAreaTrigger ( triggerId ) ; if ( ! at ) return ; bool teleported = false ; if ( player -> GetMapId ( ) != at -> target_mapId ) { if ( Map :: EnterState denyReason = sMapMgr -> PlayerCannotEnter ( at -> target_mapId , player , false ) ) { bool reviveAtTrigger = false ; switch ( denyReason ) { case Map :: CANNOT_ENTER_NO_ENTRY : TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ attempted ▁ to ▁ enter ▁ map ▁ with ▁ id ▁ % d ▁ which ▁ has ▁ no ▁ entry " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; break ; case Map :: CANNOT_ENTER_UNINSTANCED_DUNGEON : TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ attempted ▁ to ▁ enter ▁ dungeon ▁ map ▁ % d ▁ but ▁ no ▁ instance ▁ template ▁ was ▁ found " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; break ; case Map :: CANNOT_ENTER_DIFFICULTY_UNAVAILABLE : TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ attempted ▁ to ▁ enter ▁ instance ▁ map ▁ % d ▁ but ▁ the ▁ requested ▁ difficulty ▁ was ▁ not ▁ found " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; if ( MapEntry const * entry = sMapStore . LookupEntry ( at -> target_mapId ) ) player -> SendTransferAborted ( entry -> MapID , TRANSFER_ABORT_DIFFICULTY , player -> GetDifficulty ( entry -> IsRaid ( ) ) ) ; break ; case Map :: CANNOT_ENTER_NOT_IN_RAID : { WorldPacket data ( SMSG_RAID_GROUP_ONLY , 4 + 4 ) ; data << uint32 ( 0 ) ; data << uint32 ( 2 ) ; player -> GetSession ( ) -> SendPacket ( & data ) ; TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ must ▁ be ▁ in ▁ a ▁ raid ▁ group ▁ to ▁ enter ▁ instance ▁ map ▁ % d " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; reviveAtTrigger = true ; break ; } case Map :: CANNOT_ENTER_CORPSE_IN_DIFFERENT_INSTANCE : { WorldPacket data ( SMSG_CORPSE_NOT_IN_INSTANCE ) ; player -> GetSession ( ) -> SendPacket ( & data ) ; TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ does ▁ not ▁ have ▁ a ▁ corpse ▁ in ▁ instance ▁ map ▁ % d ▁ and ▁ cannot ▁ enter " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; break ; } case Map :: CANNOT_ENTER_INSTANCE_BIND_MISMATCH : if ( MapEntry const * entry = sMapStore . LookupEntry ( at -> target_mapId ) ) { char const * mapName = entry -> name [ player -> GetSession ( ) -> GetSessionDbcLocale ( ) ] ; TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ cannot ▁ enter ▁ instance ▁ map ▁ ' % s ' ▁ because ▁ their ▁ permanent ▁ bind ▁ is ▁ incompatible ▁ with ▁ their ▁ group ' s " , player -> GetName ( ) . c_str ( ) , mapName ) ; ChatHandler ( player -> GetSession ( ) ) . PSendSysMessage ( player -> GetSession ( ) -> GetTrinityString ( LANG_INSTANCE_BIND_MISMATCH ) , mapName ) ; } reviveAtTrigger = true ; break ; case Map :: CANNOT_ENTER_TOO_MANY_INSTANCES : player -> SendTransferAborted ( at -> target_mapId , TRANSFER_ABORT_TOO_MANY_INSTANCES ) ; TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ cannot ▁ enter ▁ instance ▁ map ▁ % d ▁ because ▁ he ▁ has ▁ exceeded ▁ the ▁ maximum ▁ number ▁ of ▁ instances ▁ per ▁ hour . " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; reviveAtTrigger = true ; break ; case Map :: CANNOT_ENTER_MAX_PLAYERS : player -> SendTransferAborted ( at -> target_mapId , TRANSFER_ABORT_MAX_PLAYERS ) ; reviveAtTrigger = true ; break ; case Map :: CANNOT_ENTER_ZONE_IN_COMBAT : player -> SendTransferAborted ( at -> target_mapId , TRANSFER_ABORT_ZONE_IN_COMBAT ) ; reviveAtTrigger = true ; break ; default : break ; } if ( reviveAtTrigger ) if ( ! player -> IsAlive ( ) && player -> HasCorpse ( ) ) if ( player -> GetCorpseLocation ( ) . GetMapId ( ) == at -> target_mapId ) { player -> ResurrectPlayer ( 0.5f ) ; player -> SpawnCorpseBones ( ) ; } return ; } if ( Group * group = player -> GetGroup ( ) ) if ( group -> isLFGGroup ( ) && player -> GetMap ( ) -> IsDungeon ( ) ) teleported = player -> TeleportToBGEntryPoint ( ) ; } if ( ! teleported ) player -> TeleportTo ( at -> target_mapId , at -> target_X , at -> target_Y , at -> target_Z , at -> target_Orientation , TELE_TO_NOT_LEAVE_TRANSPORT ) ; }
void WorldSession :: HandleUpdateAccountData ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ UPDATE _ ACCOUNT _ DATA " ) ; uint32 type , timestamp , decompressedSize ; recvData >> type >> timestamp >> decompressedSize ; TC_LOG_DEBUG ( " network " , " UAD : ▁ type ▁ % u , ▁ time ▁ % u , ▁ decompressedSize ▁ % u " , type , timestamp , decompressedSize ) ; if ( type > NUM_ACCOUNT_DATA_TYPES ) return ; if ( decompressedSize == 0 ) { SetAccountData ( AccountDataType ( type ) , 0 , " " ) ; WorldPacket data ( SMSG_UPDATE_ACCOUNT_DATA_COMPLETE , 4 + 4 ) ; data << uint32 ( type ) ; data << uint32 ( 0 ) ; SendPacket ( & data ) ; return ; } if ( decompressedSize > 0xFFFF ) { recvData . rfinish ( ) ; TC_LOG_ERROR ( " network " , " UAD : ▁ Account ▁ data ▁ packet ▁ too ▁ big , ▁ size ▁ % u " , decompressedSize ) ; return ; } ByteBuffer dest ; dest . resize ( decompressedSize ) ; uLongf realSize = decompressedSize ; if ( uncompress ( dest . contents ( ) , & realSize , recvData . contents ( ) + recvData . rpos ( ) , recvData . size ( ) - recvData . rpos ( ) ) != Z_OK ) { recvData . rfinish ( ) ; TC_LOG_ERROR ( " network " , " UAD : ▁ Failed ▁ to ▁ decompress ▁ account ▁ data " ) ; return ; } recvData . rfinish ( ) ; std :: string adata ; dest >> adata ; SetAccountData ( AccountDataType ( type ) , timestamp , adata ) ; WorldPacket data ( SMSG_UPDATE_ACCOUNT_DATA_COMPLETE , 4 + 4 ) ; data << uint32 ( type ) ; data << uint32 ( 0 ) ; SendPacket ( & data ) ; }
void WorldSession :: HandleRequestAccountData ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ REQUEST _ ACCOUNT _ DATA " ) ; uint32 type ; recvData >> type ; TC_LOG_DEBUG ( " network " , " RAD : ▁ type ▁ % u " , type ) ; if ( type >= NUM_ACCOUNT_DATA_TYPES ) return ; AccountData * adata = GetAccountData ( AccountDataType ( type ) ) ; uint32 size = adata -> Data . size ( ) ; uLongf destSize = compressBound ( size ) ; ByteBuffer dest ; dest . resize ( destSize ) ; if ( size && compress ( dest . contents ( ) , & destSize , ( uint8 const * ) adata -> Data . c_str ( ) , size ) != Z_OK ) { TC_LOG_DEBUG ( " network " , " RAD : ▁ Failed ▁ to ▁ compress ▁ account ▁ data " ) ; return ; } dest . resize ( destSize ) ; WorldPacket data ( SMSG_UPDATE_ACCOUNT_DATA , 8 + 4 + 4 + 4 + destSize ) ; data << uint64 ( _player ? _player -> GetGUID ( ) : ObjectGuid :: Empty ) ; data << uint32 ( type ) ; data << uint32 ( adata -> Time ) ; data << uint32 ( size ) ; data . append ( dest ) ; SendPacket ( & data ) ; }
void WorldSession :: HandleSetActionButtonOpcode ( WorldPacket & recvData ) { uint8 button ; uint32 packetData ; recvData >> button >> packetData ; TC_LOG_DEBUG ( " network " , " CMSG _ SET _ ACTION _ BUTTON ▁ Button : ▁ % u ▁ Data : ▁ % u " , button , packetData ) ; if ( ! packetData ) GetPlayer ( ) -> removeActionButton ( button ) ; else GetPlayer ( ) -> addActionButton ( button , ACTION_BUTTON_ACTION ( packetData ) , ACTION_BUTTON_TYPE ( packetData ) ) ; }
void WorldSession :: HandleCompleteCinematic ( WorldPacket & ) { GetPlayer ( ) -> GetCinematicMgr ( ) -> EndCinematic ( ) ; }
void WorldSession :: HandleNextCinematicCamera ( WorldPacket & ) { GetPlayer ( ) -> GetCinematicMgr ( ) -> BeginCinematic ( ) ; }
void WorldSession :: HandleMoveTimeSkippedOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ MOVE _ TIME _ SKIPPED " ) ; ObjectGuid guid ; recvData >> guid . ReadAsPacked ( ) ; recvData . read_skip < uint32 > ( ) ; }
void WorldSession :: HandleFeatherFallAck ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ MOVE _ FEATHER _ FALL _ ACK " ) ; recvData . rfinish ( ) ; }
void WorldSession :: HandleMoveUnRootAck ( WorldPacket & recvData ) { recvData . rfinish ( ) ; }
void WorldSession :: HandleMoveRootAck ( WorldPacket & recvData ) { recvData . rfinish ( ) ; }
void WorldSession :: HandleSetActionBarToggles ( WorldPacket & recvData ) { uint8 actionBar ; recvData >> actionBar ; if ( ! GetPlayer ( ) ) { if ( actionBar != 0 ) TC_LOG_ERROR ( " network " , " WorldSession : : HandleSetActionBarToggles ▁ in ▁ not ▁ logged ▁ state ▁ with ▁ value : ▁ % u , ▁ ignored " , uint32 ( actionBar ) ) ; return ; } GetPlayer ( ) -> SetByteValue ( PLAYER_FIELD_BYTES , PLAYER_FIELD_BYTES_OFFSET_ACTION_BAR_TOGGLES , actionBar ) ; }
void WorldSession :: HandlePlayedTime ( WorldPacket & recvData ) { uint8 unk1 ; recvData >> unk1 ; WorldPacket data ( SMSG_PLAYED_TIME , 4 + 4 + 1 ) ; data << uint32 ( _player -> GetTotalPlayedTime ( ) ) ; data << uint32 ( _player -> GetLevelPlayedTime ( ) ) ; data << uint8 ( unk1 ) ; SendPacket ( & data ) ; }
void WorldSession :: HandleInspectOpcode ( WorldPacket & recvData ) { ObjectGuid guid ; recvData >> guid ; TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ INSPECT " ) ; Player * player = ObjectAccessor :: GetPlayer ( * _player , guid ) ; if ( ! player ) { TC_LOG_DEBUG ( " network " , " CMSG _ INSPECT : ▁ No ▁ player ▁ found ▁ from ▁ % s " , guid . ToString ( ) . c_str ( ) ) ; return ; } if ( ! GetPlayer ( ) -> IsWithinDistInMap ( player , INSPECT_DISTANCE , false ) ) return ; if ( GetPlayer ( ) -> IsValidAttackTarget ( player ) ) return ; uint32 talent_points = 0x47 ; uint32 guid_size = player -> GetPackGUID ( ) . size ( ) ; WorldPacket data ( SMSG_INSPECT_TALENT , guid_size + 4 + talent_points ) ; data << player -> GetPackGUID ( ) ; if ( GetPlayer ( ) -> CanBeGameMaster ( ) || sWorld -> getIntConfig ( CONFIG_TALENTS_INSPECTING ) + ( GetPlayer ( ) -> GetTeamId ( ) == player -> GetTeamId ( ) ) > 1 ) player -> BuildPlayerTalentsInfoData ( & data ) ; else { data << uint32 ( 0 ) ; data << uint8 ( 0 ) ; data << uint8 ( 0 ) ; } player -> BuildEnchantmentsInfoData ( & data ) ; SendPacket ( & data ) ; }
void WorldSession :: HandleInspectHonorStatsOpcode ( WorldPacket & recvData ) { ObjectGuid guid ; recvData >> guid ; Player * player = ObjectAccessor :: GetPlayer ( * _player , guid ) ; if ( ! player ) { TC_LOG_DEBUG ( " network " , " MSG _ INSPECT _ HONOR _ STATS : ▁ No ▁ player ▁ found ▁ from ▁ % s " , guid . ToString ( ) . c_str ( ) ) ; return ; } if ( ! GetPlayer ( ) -> IsWithinDistInMap ( player , INSPECT_DISTANCE , false ) ) return ; if ( GetPlayer ( ) -> IsValidAttackTarget ( player ) ) return ; WorldPacket data ( MSG_INSPECT_HONOR_STATS , 8 + 1 + 4 * 4 ) ; data << uint64 ( player -> GetGUID ( ) ) ; data << uint8 ( player -> GetHonorPoints ( ) ) ; data << uint32 ( player -> GetUInt32Value ( PLAYER_FIELD_KILLS ) ) ; data << uint32 ( player -> GetUInt32Value ( PLAYER_FIELD_TODAY_CONTRIBUTION ) ) ; data << uint32 ( player -> GetUInt32Value ( PLAYER_FIELD_YESTERDAY_CONTRIBUTION ) ) ; data << uint32 ( player -> GetUInt32Value ( PLAYER_FIELD_LIFETIME_HONORABLE_KILLS ) ) ; SendPacket ( & data ) ; }
void WorldSession :: HandleWorldTeleportOpcode ( WorldPacket & recvData ) { uint32 time ; uint32 mapid ; float PositionX ; float PositionY ; float PositionZ ; float Orientation ; recvData >> time ; recvData >> mapid ; recvData >> PositionX ; recvData >> PositionY ; recvData >> PositionZ ; recvData >> Orientation ; TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ WORLD _ TELEPORT " ) ; if ( GetPlayer ( ) -> IsInFlight ( ) ) { TC_LOG_DEBUG ( " network " , " Player ▁ ' % s ' ▁ ( GUID : ▁ % u ) ▁ in ▁ flight , ▁ ignore ▁ worldport ▁ command . " , GetPlayer ( ) -> GetName ( ) . c_str ( ) , GetPlayer ( ) -> GetGUID ( ) . GetCounter ( ) ) ; return ; } TC_LOG_DEBUG ( " network " , " CMSG _ WORLD _ TELEPORT : ▁ Player ▁ = ▁ % s , ▁ Time ▁ = ▁ % u , ▁ map ▁ = ▁ % u , ▁ x ▁ = ▁ % f , ▁ y ▁ = ▁ % f , ▁ z ▁ = ▁ % f , ▁ o ▁ = ▁ % f " , GetPlayer ( ) -> GetName ( ) . c_str ( ) , time , mapid , PositionX , PositionY , PositionZ , Orientation ) ; if ( HasPermission ( rbac :: RBAC_PERM_OPCODE_WORLD_TELEPORT ) ) GetPlayer ( ) -> TeleportTo ( mapid , PositionX , PositionY , PositionZ , Orientation ) ; else SendNotification ( LANG_YOU_NOT_HAVE_PERMISSION ) ; }
void WorldSession :: HandleWhoisOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " Received ▁ opcode ▁ CMSG _ WHOIS " ) ; std :: string charname ; recvData >> charname ; if ( ! HasPermission ( rbac :: RBAC_PERM_OPCODE_WHOIS ) ) { SendNotification ( LANG_YOU_NOT_HAVE_PERMISSION ) ; return ; } if ( charname . empty ( ) || ! normalizePlayerName ( charname ) ) { SendNotification ( LANG_NEED_CHARACTER_NAME ) ; return ; } Player * player = ObjectAccessor :: FindConnectedPlayerByName ( charname ) ; if ( ! player ) { SendNotification ( LANG_PLAYER_NOT_EXIST_OR_OFFLINE , charname . c_str ( ) ) ; return ; } uint32 accid = player -> GetSession ( ) -> GetAccountId ( ) ; PreparedStatement * stmt = LoginDatabase . GetPreparedStatement ( LOGIN_SEL_ACCOUNT_WHOIS ) ; stmt -> setUInt32 ( 0 , accid ) ; PreparedQueryResult result = LoginDatabase . Query ( stmt ) ; if ( ! result ) { SendNotification ( LANG_ACCOUNT_FOR_PLAYER_NOT_FOUND , charname . c_str ( ) ) ; return ; } Field * fields = result -> Fetch ( ) ; std :: string acc = fields [ 0 ] . GetString ( ) ; if ( acc . empty ( ) ) acc = " Unknown " ; std :: string email = fields [ 1 ] . GetString ( ) ; if ( email . empty ( ) ) email = " Unknown " ; std :: string lastip = fields [ 2 ] . GetString ( ) ; if ( lastip . empty ( ) ) lastip = " Unknown " ; std :: string msg = charname + " ' s ▁ " + " account ▁ is ▁ " + acc + " , ▁ e - mail : ▁ " + email + " , ▁ last ▁ ip : ▁ " + lastip ; WorldPacket data ( SMSG_WHOIS , msg . size ( ) + 1 ) ; data << msg ; SendPacket ( & data ) ; TC_LOG_DEBUG ( " network " , " Received ▁ whois ▁ command ▁ from ▁ player ▁ % s ▁ for ▁ character ▁ % s " , GetPlayer ( ) -> GetName ( ) . c_str ( ) , charname . c_str ( ) ) ; }
void WorldSession :: HandleComplainOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ COMPLAIN " ) ; uint8 spam_type ; ObjectGuid spammer_guid ; uint32 unk1 = 0 ; uint32 unk2 = 0 ; uint32 unk3 = 0 ; uint32 unk4 = 0 ; std :: string description = " " ; recvData >> spam_type ; recvData >> spammer_guid ; switch ( spam_type ) { case 0 : recvData >> unk1 ; recvData >> unk2 ; recvData >> unk3 ; break ; case 1 : recvData >> unk1 ; recvData >> unk2 ; recvData >> unk3 ; recvData >> unk4 ; recvData >> description ; break ; } WorldPacket data ( SMSG_COMPLAIN_RESULT , 1 ) ; data << uint8 ( 0 ) ; SendPacket ( & data ) ; TC_LOG_DEBUG ( " network " , " REPORT ▁ SPAM : ▁ type ▁ % u , ▁ % s , ▁ unk1 ▁ % u , ▁ unk2 ▁ % u , ▁ unk3 ▁ % u , ▁ unk4 ▁ % u , ▁ message ▁ % s " , spam_type , spammer_guid . ToString ( ) . c_str ( ) , unk1 , unk2 , unk3 , unk4 , description . c_str ( ) ) ; }
void WorldSession :: HandleRealmSplitOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " CMSG _ REALM _ SPLIT " ) ; uint32 unk ; std :: string split_date = "01/01/01" ; recvData >> unk ; WorldPacket data ( SMSG_REALM_SPLIT , 4 + 4 + split_date . size ( ) + 1 ) ; data << unk ; data << uint32 ( 0x00000000 ) ; data << split_date ; SendPacket ( & data ) ; }
void WorldSession :: HandleFarSightOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ FAR _ SIGHT " ) ; bool apply ; recvData >> apply ; if ( apply ) { TC_LOG_DEBUG ( " network " , " Added ▁ FarSight ▁ % s ▁ to ▁ player ▁ % u " , _player -> GetGuidValue ( PLAYER_FARSIGHT ) . ToString ( ) . c_str ( ) , _player -> GetGUID ( ) . GetCounter ( ) ) ; if ( WorldObject * target = _player -> GetViewpoint ( ) ) _player -> SetSeer ( target ) ; else TC_LOG_DEBUG ( " network " , " Player ▁ % s ▁ ( % s ) ▁ requests ▁ non - existing ▁ seer ▁ % s " , _player -> GetName ( ) . c_str ( ) , _player -> GetGUID ( ) . ToString ( ) . c_str ( ) , _player -> GetGuidValue ( PLAYER_FARSIGHT ) . ToString ( ) . c_str ( ) ) ; } else { TC_LOG_DEBUG ( " network " , " Player ▁ % u ▁ set ▁ vision ▁ to ▁ self " , _player -> GetGUID ( ) . GetCounter ( ) ) ; _player -> SetSeer ( _player ) ; } GetPlayer ( ) -> UpdateVisibilityForPlayer ( ) ; }
void WorldSession :: HandleSetTitleOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " CMSG _ SET _ TITLE " ) ; int32 title ; recvData >> title ; if ( title > 0 && title < MAX_TITLE_INDEX ) { if ( ! GetPlayer ( ) -> HasTitle ( title ) ) return ; } else title = 0 ; GetPlayer ( ) -> SetUInt32Value ( PLAYER_CHOSEN_TITLE , title ) ; }
void WorldSession :: HandleTimeSyncResp ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " CMSG _ TIME _ SYNC _ RESP " ) ; uint32 counter , clientTicks ; recvData >> counter >> clientTicks ; if ( counter != _player -> m_timeSyncCounter - 1 ) TC_LOG_DEBUG ( " network " , " Wrong ▁ time ▁ sync ▁ counter ▁ from ▁ player ▁ % s ▁ ( cheater ? ) " , _player -> GetName ( ) . c_str ( ) ) ; TC_LOG_DEBUG ( " network " , " Time ▁ sync ▁ received : ▁ counter ▁ % u , ▁ client ▁ ticks ▁ % u , ▁ time ▁ since ▁ last ▁ sync ▁ % u " , counter , clientTicks , clientTicks - _player -> m_timeSyncClient ) ; uint32 ourTicks = clientTicks + ( GameTime :: GetGameTimeMS ( ) - _player -> m_timeSyncServer ) ; TC_LOG_DEBUG ( " network " , " Our ▁ ticks : ▁ % u , ▁ diff ▁ % u , ▁ latency ▁ % u " , ourTicks , ourTicks - clientTicks , GetLatency ( ) ) ; _player -> m_timeSyncClient = clientTicks ; }
void WorldSession :: HandleResetInstancesOpcode ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ RESET _ INSTANCES " ) ; if ( Group * group = _player -> GetGroup ( ) ) { if ( group -> IsLeader ( _player -> GetGUID ( ) ) ) group -> ResetInstances ( INSTANCE_RESET_ALL , false , _player ) ; } else _player -> ResetInstances ( INSTANCE_RESET_ALL , false ) ; }
void WorldSession :: HandleSetDungeonDifficultyOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " MSG _ SET _ DUNGEON _ DIFFICULTY " ) ; uint32 mode ; recvData >> mode ; if ( mode >= MAX_DUNGEON_DIFFICULTY ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetDungeonDifficultyOpcode : ▁ player ▁ % d ▁ sent ▁ an ▁ invalid ▁ instance ▁ mode ▁ % d ! " , _player -> GetGUID ( ) . GetCounter ( ) , mode ) ; return ; } if ( Difficulty ( mode ) == _player -> GetDungeonDifficulty ( ) ) return ; Map * map = _player -> FindMap ( ) ; if ( map && map -> IsDungeon ( ) ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetDungeonDifficultyOpcode : ▁ player ▁ ( Name : ▁ % s , ▁ GUID : ▁ % u ) ▁ tried ▁ to ▁ reset ▁ the ▁ instance ▁ while ▁ player ▁ is ▁ inside ! " , _player -> GetName ( ) . c_str ( ) , _player -> GetGUID ( ) . GetCounter ( ) ) ; return ; } Group * group = _player -> GetGroup ( ) ; if ( group ) { if ( group -> IsLeader ( _player -> GetGUID ( ) ) ) { for ( GroupReference * itr = group -> GetFirstMember ( ) ; itr != NULL ; itr = itr -> next ( ) ) { Player * groupGuy = itr -> GetSource ( ) ; if ( ! groupGuy ) continue ; if ( ! groupGuy -> IsInMap ( groupGuy ) ) return ; if ( groupGuy -> GetMap ( ) -> IsNonRaidDungeon ( ) ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetDungeonDifficultyOpcode : ▁ player ▁ % d ▁ tried ▁ to ▁ reset ▁ the ▁ instance ▁ while ▁ group ▁ member ▁ ( Name : ▁ % s , ▁ GUID : ▁ % u ) ▁ is ▁ inside ! " , _player -> GetGUID ( ) . GetCounter ( ) , groupGuy -> GetName ( ) . c_str ( ) , groupGuy -> GetGUID ( ) . GetCounter ( ) ) ; return ; } } group -> ResetInstances ( INSTANCE_RESET_CHANGE_DIFFICULTY , false , _player ) ; group -> SetDungeonDifficulty ( Difficulty ( mode ) ) ; } } else { _player -> ResetInstances ( INSTANCE_RESET_CHANGE_DIFFICULTY , false ) ; _player -> SetDungeonDifficulty ( Difficulty ( mode ) ) ; } }
void WorldSession :: HandleSetRaidDifficultyOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " MSG _ SET _ RAID _ DIFFICULTY " ) ; uint32 mode ; recvData >> mode ; if ( mode >= MAX_RAID_DIFFICULTY ) { TC_LOG_ERROR ( " network " , " WorldSession : : HandleSetRaidDifficultyOpcode : ▁ player ▁ % d ▁ sent ▁ an ▁ invalid ▁ instance ▁ mode ▁ % d ! " , _player -> GetGUID ( ) . GetCounter ( ) , mode ) ; return ; } Map * map = _player -> FindMap ( ) ; if ( map && map -> IsDungeon ( ) ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetRaidDifficultyOpcode : ▁ player ▁ % d ▁ tried ▁ to ▁ reset ▁ the ▁ instance ▁ while ▁ inside ! " , _player -> GetGUID ( ) . GetCounter ( ) ) ; return ; } if ( Difficulty ( mode ) == _player -> GetRaidDifficulty ( ) ) return ; Group * group = _player -> GetGroup ( ) ; if ( group ) { if ( group -> IsLeader ( _player -> GetGUID ( ) ) ) { for ( GroupReference * itr = group -> GetFirstMember ( ) ; itr != NULL ; itr = itr -> next ( ) ) { Player * groupGuy = itr -> GetSource ( ) ; if ( ! groupGuy ) continue ; if ( ! groupGuy -> IsInMap ( groupGuy ) ) return ; if ( groupGuy -> GetMap ( ) -> IsRaid ( ) ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetRaidDifficultyOpcode : ▁ player ▁ % d ▁ tried ▁ to ▁ reset ▁ the ▁ instance ▁ while ▁ inside ! " , _player -> GetGUID ( ) . GetCounter ( ) ) ; return ; } } group -> ResetInstances ( INSTANCE_RESET_CHANGE_DIFFICULTY , true , _player ) ; group -> SetRaidDifficulty ( Difficulty ( mode ) ) ; } } else { _player -> ResetInstances ( INSTANCE_RESET_CHANGE_DIFFICULTY , true ) ; _player -> SetRaidDifficulty ( Difficulty ( mode ) ) ; } }
void WorldSession :: HandleCancelMountAuraOpcode ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ CANCEL _ MOUNT _ AURA " ) ; if ( ! _player -> IsMounted ( ) ) { ChatHandler ( this ) . SendSysMessage ( LANG_CHAR_NON_MOUNTED ) ; return ; } if ( _player -> IsInFlight ( ) ) { ChatHandler ( this ) . SendSysMessage ( LANG_YOU_IN_FLIGHT ) ; return ; } _player -> RemoveAurasByType ( SPELL_AURA_MOUNTED ) ; }
void WorldSession :: HandleMoveSetCanFlyAckOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ MOVE _ SET _ CAN _ FLY _ ACK " ) ; ObjectGuid guid ; recvData >> guid . ReadAsPacked ( ) ; recvData . read_skip < uint32 > ( ) ; MovementInfo movementInfo ; movementInfo . guid = guid ; ReadMovementInfo ( recvData , & movementInfo ) ; recvData . read_skip < float > ( ) ; _player -> m_unitMovedByMe -> m_movementInfo . flags = movementInfo . GetMovementFlags ( ) ; }
void WorldSession :: HandleSetTaxiBenchmarkOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ SET _ TAXI _ BENCHMARK _ MODE " ) ; uint8 mode ; recvData >> mode ; mode ? _player -> SetFlag ( PLAYER_FLAGS , PLAYER_FLAGS_TAXI_BENCHMARK ) : _player -> RemoveFlag ( PLAYER_FLAGS , PLAYER_FLAGS_TAXI_BENCHMARK ) ; TC_LOG_DEBUG ( " network " , " Client ▁ used ▁ \ " / timetest ▁ % d \ " ▁ command " , mode ) ; }
void WorldSession :: HandleQueryInspectAchievements ( WorldPacket & recvData ) { ObjectGuid guid ; recvData >> guid . ReadAsPacked ( ) ; TC_LOG_DEBUG ( " network " , " CMSG _ QUERY _ INSPECT _ ACHIEVEMENTS ▁ [ % s ] ▁ Inspected ▁ Player ▁ [ % s ] " , _player -> GetGUID ( ) . ToString ( ) . c_str ( ) , guid . ToString ( ) . c_str ( ) ) ; Player * player = ObjectAccessor :: GetPlayer ( * _player , guid ) ; if ( ! player ) return ; if ( ! GetPlayer ( ) -> IsWithinDistInMap ( player , INSPECT_DISTANCE , false ) ) return ; if ( GetPlayer ( ) -> IsValidAttackTarget ( player ) ) return ; player -> SendRespondInspectAchievements ( _player ) ; }
void WorldSession :: HandleWorldStateUITimerUpdate ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ WORLD _ STATE _ UI _ TIMER _ UPDATE " ) ; WorldPacket data ( SMSG_WORLD_STATE_UI_TIMER_UPDATE , 4 ) ; data << uint32 ( time ( NULL ) ) ; SendPacket ( & data ) ; }
void WorldSession :: HandleReadyForAccountDataTimes ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ READY _ FOR _ ACCOUNT _ DATA _ TIMES " ) ; SendAccountDataTimes ( GLOBAL_CACHE_MASK ) ; }
void WorldSession :: SendSetPhaseShift ( uint32 PhaseShift ) { WorldPacket data ( SMSG_SET_PHASE_SHIFT , 4 ) ; data << uint32 ( PhaseShift ) ; SendPacket ( & data ) ; }
void WorldSession :: HandleAreaSpiritHealerQueryOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ AREA _ SPIRIT _ HEALER _ QUERY " ) ; Battleground * bg = _player -> GetBattleground ( ) ; ObjectGuid guid ; recvData >> guid ; Creature * unit = GetPlayer ( ) -> GetMap ( ) -> GetCreature ( guid ) ; if ( ! unit ) return ; if ( ! unit -> IsSpiritService ( ) ) return ; if ( bg ) sBattlegroundMgr -> SendAreaSpiritHealerQueryOpcode ( _player , bg , guid ) ; if ( Battlefield * bf = sBattlefieldMgr -> GetBattlefieldToZoneId ( _player -> GetZoneId ( ) ) ) bf -> SendAreaSpiritHealerQueryOpcode ( _player , guid ) ; }
void WorldSession :: HandleAreaSpiritHealerQueueOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ AREA _ SPIRIT _ HEALER _ QUEUE " ) ; Battleground * bg = _player -> GetBattleground ( ) ; ObjectGuid guid ; recvData >> guid ; Creature * unit = GetPlayer ( ) -> GetMap ( ) -> GetCreature ( guid ) ; if ( ! unit ) return ; if ( ! unit -> IsSpiritService ( ) ) return ; if ( bg ) bg -> AddPlayerToResurrectQueue ( guid , _player -> GetGUID ( ) ) ; if ( Battlefield * bf = sBattlefieldMgr -> GetBattlefieldToZoneId ( _player -> GetZoneId ( ) ) ) bf -> AddPlayerToResurrectQueue ( guid , _player -> GetGUID ( ) ) ; }
void WorldSession :: HandleHearthAndResurrect ( WorldPacket & ) { if ( _player -> IsInFlight ( ) ) return ; if ( Battlefield * bf = sBattlefieldMgr -> GetBattlefieldToZoneId ( _player -> GetZoneId ( ) ) ) { bf -> PlayerAskToLeave ( _player ) ; return ; } AreaTableEntry const * atEntry = sAreaTableStore . LookupEntry ( _player -> GetAreaId ( ) ) ; if ( ! atEntry || ! ( atEntry -> flags & AREA_FLAG_WINTERGRASP_2 ) ) return ; _player -> BuildPlayerRepop ( ) ; _player -> ResurrectPlayer ( 1.0f ) ; _player -> TeleportTo ( _player -> m_homebindMapId , _player -> m_homebindX , _player -> m_homebindY , _player -> m_homebindZ , _player -> GetOrientation ( ) ) ; }
void WorldSession :: HandleInstanceLockResponse ( WorldPacket & recvPacket ) { uint8 accept ; recvPacket >> accept ; if ( ! _player -> HasPendingBind ( ) ) { TC_LOG_INFO ( " network " , " InstanceLockResponse : ▁ Player ▁ % s ▁ ( guid ▁ % u ) ▁ tried ▁ to ▁ bind ▁ himself / teleport ▁ to ▁ graveyard ▁ without ▁ a ▁ pending ▁ bind ! " , _player -> GetName ( ) . c_str ( ) , _player -> GetGUID ( ) . GetCounter ( ) ) ; return ; } if ( accept ) _player -> BindToInstance ( ) ; else _player -> RepopAtGraveyard ( ) ; _player -> SetPendingBind ( 0 , 0 ) ; }
void WorldSession :: HandleUpdateMissileTrajectory ( WorldPacket & recvPacket ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ UPDATE _ MISSILE _ TRAJECTORY " ) ; ObjectGuid guid ; uint32 spellId ; float elevation , speed ; float curX , curY , curZ ; float targetX , targetY , targetZ ; uint8 moveStop ; recvPacket >> guid >> spellId >> elevation >> speed ; recvPacket >> curX >> curY >> curZ ; recvPacket >> targetX >> targetY >> targetZ ; recvPacket >> moveStop ; Unit * caster = ObjectAccessor :: GetUnit ( * _player , guid ) ; Spell * spell = caster ? caster -> GetCurrentSpell ( CURRENT_GENERIC_SPELL ) : NULL ; if ( ! spell || spell -> m_spellInfo -> Id != spellId || ! spell -> m_targets . HasDst ( ) || ! spell -> m_targets . HasSrc ( ) ) { recvPacket . rfinish ( ) ; return ; } Position pos = * spell -> m_targets . GetSrcPos ( ) ; pos . Relocate ( curX , curY , curZ ) ; spell -> m_targets . ModSrc ( pos ) ; pos = * spell -> m_targets . GetDstPos ( ) ; pos . Relocate ( targetX , targetY , targetZ ) ; spell -> m_targets . ModDst ( pos ) ; spell -> m_targets . SetElevation ( elevation ) ; spell -> m_targets . SetSpeed ( speed ) ; if ( moveStop ) { uint32 opcode ; recvPacket >> opcode ; recvPacket . SetOpcode ( opcode ) ; HandleMovementOpcodes ( recvPacket ) ; } }
wxMacPortSaver :: wxMacPortSaver ( GrafPtr port ) { :: GetPort ( & m_port ) ; :: SetPort ( port ) ; }
wxMacPortSaver :: ~ wxMacPortSaver ( ) { :: SetPort ( m_port ) ; }
wxMacWindowClipper :: wxMacWindowClipper ( const wxWindow * win ) : wxMacPortSaver ( ( GrafPtr ) GetWindowPort ( ( WindowRef ) win -> MacGetTopLevelWindowRef ( ) ) ) { m_newPort = ( GrafPtr ) GetWindowPort ( ( WindowRef ) win -> MacGetTopLevelWindowRef ( ) ) ; m_formerClip = NewRgn ( ) ; m_newClip = NewRgn ( ) ; GetClip ( m_formerClip ) ; if ( win ) { if ( win -> GetPeer ( ) ) { int x = 0 , y = 0 ; win -> MacWindowToRootWindow ( & x , & y ) ; HIShapeGetAsQDRgn ( ( ( wxWindow * ) win ) -> MacGetVisibleRegion ( true ) . GetWXHRGN ( ) , m_newClip ) ; if ( ! EmptyRgn ( m_newClip ) ) OffsetRgn ( m_newClip , x , y ) ; } SetClip ( m_newClip ) ; } }
wxMacWindowClipper :: ~ wxMacWindowClipper ( ) { SetPort ( m_newPort ) ; SetClip ( m_formerClip ) ; DisposeRgn ( m_newClip ) ; DisposeRgn ( m_formerClip ) ; }
wxWidgetImplType * wxWidgetImpl :: CreateTextControl ( wxTextCtrl * wxpeer , wxWindowMac * WXUNUSED ( parent ) , wxWindowID WXUNUSED ( id ) , const wxString & str , const wxPoint & pos , const wxSize & size , long style , long WXUNUSED ( extraStyle ) ) { return new wxMacMLTEHIViewControl ( wxpeer , str , pos , size , style ) ; }
wxMacUnicodeTextControl :: wxMacUnicodeTextControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) : wxMacControl ( wxPeer ) , wxTextWidgetImpl ( wxPeer ) { m_font = wxPeer -> GetFont ( ) ; m_windowStyle = style ; m_selection . selStart = m_selection . selEnd = 0 ; Rect bounds = wxMacGetBoundsForControl ( wxPeer , pos , size ) ; wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; m_valueTag = kControlEditTextCFStringTag ; Boolean isPassword = ( m_windowStyle & wxTE_PASSWORD ) != 0 ; if ( isPassword ) { m_valueTag = kControlEditTextPasswordCFStringTag ; } OSStatus err = CreateEditUnicodeTextControl ( MAC_WXHWND ( wxPeer -> MacGetTopLevelWindowRef ( ) ) , & bounds , cf , isPassword , NULL , & m_controlRef ) ; verify_noerr ( err ) ; if ( ! ( m_windowStyle & wxTE_MULTILINE ) ) SetData < Boolean > ( kControlEditTextPart , kControlEditTextSingleLineTag , true ) ; InstallEventHandlers ( ) ; }
void wxMacUnicodeTextControl :: InstallEventHandlers ( ) { :: InstallControlEventHandler ( m_controlRef , GetwxMacUnicodeTextControlEventHandlerUPP ( ) , GetEventTypeCount ( unicodeTextControlEventList ) , unicodeTextControlEventList , this , ( EventHandlerRef * ) & m_macTextCtrlEventHandler ) ; }
wxMacUnicodeTextControl :: ~ wxMacUnicodeTextControl ( ) { :: RemoveEventHandler ( ( EventHandlerRef ) m_macTextCtrlEventHandler ) ; }
void wxMacUnicodeTextControl :: VisibilityChanged ( bool shown ) { if ( ! ( m_windowStyle & wxTE_MULTILINE ) && shown ) { ControlEditTextSelectionRec sel ; CFStringRef value = NULL ; verify_noerr ( GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; verify_noerr ( GetData < CFStringRef > ( 0 , m_valueTag , & value ) ) ; verify_noerr ( SetData < CFStringRef > ( 0 , m_valueTag , & value ) ) ; verify_noerr ( SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; CFRelease ( value ) ; } }
void wxMacMLTEControl :: SetStringValue ( const wxString & str ) { wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; { wxMacWindowClipper c ( GetWXPeer ( ) ) ; { wxMacEditHelper help ( m_txn ) ; SetTXNData ( st , kTXNStartOffset , kTXNEndOffset ) ; } TXNSetSelection ( m_txn , 0 , 0 ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; } }
TXNFrameOptions wxMacMLTEControl :: FrameOptionsFromWXStyle ( long wxStyle ) { TXNFrameOptions frameOptions = kTXNDontDrawCaretWhenInactiveMask ; frameOptions |= kTXNDoFontSubstitutionMask ; if ( ! ( wxStyle & wxTE_NOHIDESEL ) ) frameOptions |= kTXNDontDrawSelectionWhenInactiveMask ; if ( wxStyle & ( wxHSCROLL | wxTE_DONTWRAP ) ) frameOptions |= kTXNWantHScrollBarMask ; if ( wxStyle & wxTE_MULTILINE ) { if ( ! ( wxStyle & wxTE_DONTWRAP ) ) frameOptions |= kTXNAlwaysWrapAtViewEdgeMask ; if ( ! ( wxStyle & wxTE_NO_VSCROLL ) ) { frameOptions |= kTXNWantVScrollBarMask ; } } else { frameOptions |= kTXNSingleLineOnlyMask ; } return frameOptions ; }
void wxMacMLTEControl :: AdjustCreationAttributes ( const wxColour & background , bool WXUNUSED ( visible ) ) { TXNControlTag iControlTags [ ] = { kTXNDoFontSubstitution , kTXNWordWrapStateTag , } ; TXNControlData iControlData [ ] = { { true } , { kTXNNoAutoWrap } , } ; int toptag = WXSIZEOF ( iControlTags ) ; if ( m_windowStyle & wxTE_MULTILINE ) { iControlData [ 1 ] . uValue = ( m_windowStyle & wxTE_DONTWRAP ) ? kTXNNoAutoWrap : kTXNAutoWrap ; } OSStatus err = TXNSetTXNObjectControls ( m_txn , false , toptag , iControlTags , iControlData ) ; verify_noerr ( err ) ; Str255 fontName ; SInt16 fontSize ; Style fontStyle ; GetThemeFont ( kThemeSystemFont , GetApplicationScript ( ) , fontName , & fontSize , & fontStyle ) ; TXNTypeAttributes typeAttr [ ] = { { kTXNQDFontNameAttribute , kTXNQDFontNameAttributeSize , { ( void * ) fontName } } , { kTXNQDFontSizeAttribute , kTXNFontSizeAttributeSize , { ( void * ) ( fontSize << 16 ) } } , { kTXNQDFontStyleAttribute , kTXNQDFontStyleAttributeSize , { ( void * ) normal } } , } ; err = TXNSetTypeAttributes ( m_txn , WXSIZEOF ( typeAttr ) , typeAttr , kTXNStartOffset , kTXNEndOffset ) ; verify_noerr ( err ) ; if ( m_windowStyle & wxTE_PASSWORD ) { UniChar c = 0x00A5 ; err = TXNEchoMode ( m_txn , c , 0 , true ) ; verify_noerr ( err ) ; } TXNBackground tback ; tback . bgType = kTXNBackgroundTypeRGB ; background . GetRGBColor ( & tback . bg . color ) ; TXNSetBackground ( m_txn , & tback ) ; TXNCommandEventSupportOptions options ; if ( TXNGetCommandEventSupport ( m_txn , & options ) == noErr ) { options |= kTXNSupportEditCommandProcessing | kTXNSupportEditCommandUpdating | kTXNSupportFontCommandProcessing | kTXNSupportFontCommandUpdating ; bool checkSpelling = false ; if ( ! ( m_windowStyle & wxTE_READONLY ) ) { if ( wxSystemOptions :: HasOption ( wxMAC_TEXTCONTROL_USE_SPELL_CHECKER ) && ( wxSystemOptions :: GetOptionInt ( wxMAC_TEXTCONTROL_USE_SPELL_CHECKER ) == 1 ) ) { checkSpelling = true ; } } if ( checkSpelling ) options |= kTXNSupportSpellCheckCommandProcessing | kTXNSupportSpellCheckCommandUpdating ; TXNSetCommandEventSupport ( m_txn , options ) ; } }
void wxMacMLTEControl :: SetBackgroundColour ( const wxColour & col ) { TXNBackground tback ; tback . bgType = kTXNBackgroundTypeRGB ; col . GetRGBColor ( & tback . bg . color ) ; TXNSetBackground ( m_txn , & tback ) ; }
void wxMacMLTEControl :: TXNSetAttribute ( const wxTextAttr & style , long from , long to ) { TXNTypeAttributes typeAttr [ 4 ] ; RGBColor color ; size_t typeAttrCount = 0 ; TXNMargins margins ; TXNControlTag controlTags [ 4 ] ; TXNControlData controlData [ 4 ] ; size_t controlAttrCount = 0 ; TXNTab * tabs = NULL ; bool relayout = false ; wxFont font ; if ( style . HasFont ( ) ) { wxASSERT ( typeAttrCount < WXSIZEOF ( typeAttr ) ) ; font = style . GetFont ( ) ; typeAttr [ typeAttrCount ] . tag = kTXNATSUIStyle ; typeAttr [ typeAttrCount ] . size = kTXNATSUIStyleSize ; typeAttr [ typeAttrCount ] . data . dataPtr = font . MacGetATSUStyle ( ) ; typeAttrCount ++ ; } if ( style . HasTextColour ( ) ) { wxASSERT ( typeAttrCount < WXSIZEOF ( typeAttr ) ) ; style . GetTextColour ( ) . GetRGBColor ( & color ) ; typeAttr [ typeAttrCount ] . tag = kTXNQDFontColorAttribute ; typeAttr [ typeAttrCount ] . size = kTXNQDFontColorAttributeSize ; typeAttr [ typeAttrCount ] . data . dataPtr = ( void * ) & color ; typeAttrCount ++ ; } if ( style . HasAlignment ( ) ) { wxASSERT ( controlAttrCount < WXSIZEOF ( controlTags ) ) ; SInt32 align ; switch ( style . GetAlignment ( ) ) { case wxTEXT_ALIGNMENT_LEFT : align = kTXNFlushLeft ; break ; case wxTEXT_ALIGNMENT_CENTRE : align = kTXNCenter ; break ; case wxTEXT_ALIGNMENT_RIGHT : align = kTXNFlushRight ; break ; case wxTEXT_ALIGNMENT_JUSTIFIED : align = kTXNFullJust ; break ; default : case wxTEXT_ALIGNMENT_DEFAULT : align = kTXNFlushDefault ; break ; } controlTags [ controlAttrCount ] = kTXNJustificationTag ; controlData [ controlAttrCount ] . sValue = align ; controlAttrCount ++ ; } if ( style . HasLeftIndent ( ) || style . HasRightIndent ( ) ) { wxASSERT ( controlAttrCount < WXSIZEOF ( controlTags ) ) ; controlTags [ controlAttrCount ] = kTXNMarginsTag ; controlData [ controlAttrCount ] . marginsPtr = & margins ; verify_noerr ( TXNGetTXNObjectControls ( m_txn , 1 , & controlTags [ controlAttrCount ] , & controlData [ controlAttrCount ] ) ) ; if ( style . HasLeftIndent ( ) ) { margins . leftMargin = wxConvertToTXN ( style . GetLeftIndent ( ) ) ; } if ( style . HasRightIndent ( ) ) { margins . rightMargin = wxConvertToTXN ( style . GetRightIndent ( ) ) ; } controlAttrCount ++ ; } if ( style . HasTabs ( ) ) { const wxArrayInt & tabarray = style . GetTabs ( ) ; controlTags [ controlAttrCount ] = kTXNTabSettingsTag ; if ( tabarray . size ( ) > 0 ) controlData [ controlAttrCount ] . tabValue . value = wxConvertToTXN ( tabarray [ 0 ] ) ; else controlData [ controlAttrCount ] . tabValue . value = 72 ; controlData [ controlAttrCount ] . tabValue . tabType = kTXNLeftTab ; controlAttrCount ++ ; } if ( controlAttrCount > 0 ) { verify_noerr ( TXNSetTXNObjectControls ( m_txn , false , controlAttrCount , controlTags , controlData ) ) ; relayout = true ; } if ( typeAttrCount > 0 ) { verify_noerr ( TXNSetTypeAttributes ( m_txn , typeAttrCount , typeAttr , from , to ) ) ; if ( from != to ) relayout = true ; } if ( tabs != NULL ) { delete [ ] tabs ; } if ( relayout ) { TXNRecalcTextLayout ( m_txn ) ; } }
void wxMacMLTEControl :: SetFont ( const wxFont & font , const wxColour & foreground , long WXUNUSED ( windowStyle ) , bool WXUNUSED ( ignoreBlack ) ) { wxMacEditHelper help ( m_txn ) ; TXNSetAttribute ( wxTextAttr ( foreground , wxNullColour , font ) , kTXNStartOffset , kTXNEndOffset ) ; }
void wxMacMLTEControl :: SetStyle ( long start , long end , const wxTextAttr & style ) { wxMacEditHelper help ( m_txn ) ; TXNSetAttribute ( style , start , end ) ; }
void wxMacMLTEControl :: Copy ( ) { TXNCopy ( m_txn ) ; }
void wxMacMLTEControl :: Cut ( ) { TXNCut ( m_txn ) ; }
void wxMacMLTEControl :: Paste ( ) { TXNPaste ( m_txn ) ; }
void wxMacMLTEControl :: SetEditable ( bool editable ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; TXNControlData data [ ] = { { editable ? kTXNReadWrite : kTXNReadOnly } } ; TXNSetTXNObjectControls ( m_txn , false , WXSIZEOF ( tag ) , tag , data ) ; }
void wxMacMLTEControl :: Replace ( long from , long to , const wxString & str ) { wxString value = str ; wxMacConvertNewlines10To13 ( & value ) ; wxMacEditHelper help ( m_txn ) ; wxMacWindowClipper c ( GetWXPeer ( ) ) ; TXNSetSelection ( m_txn , from , to == - 1 ? kTXNEndOffset : to ) ; TXNClear ( m_txn ) ; SetTXNData ( value , kTXNUseCurrentSelection , kTXNUseCurrentSelection ) ; }
void wxMacMLTEControl :: Remove ( long from , long to ) { wxMacWindowClipper c ( GetWXPeer ( ) ) ; wxMacEditHelper help ( m_txn ) ; TXNSetSelection ( m_txn , from , to ) ; TXNClear ( m_txn ) ; }
void wxMacMLTEControl :: SetSelection ( long from , long to ) { wxMacWindowClipper c ( GetWXPeer ( ) ) ; if ( ( from == - 1 ) && ( to == - 1 ) ) TXNSelectAll ( m_txn ) ; else TXNSetSelection ( m_txn , from , to == - 1 ? kTXNEndOffset : to ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; }
void wxMacMLTEControl :: WriteText ( const wxString & str ) { if ( ! wxIsMainThread ( ) ) { wxMacMPRemoteGUICall < wxTextCtrl , wxString > ( ( wxTextCtrl * ) GetWXPeer ( ) , & wxTextCtrl :: WriteText , str ) ; return ; } wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; long start , end , dummy ; GetSelection ( & start , & dummy ) ; wxMacWindowClipper c ( GetWXPeer ( ) ) ; { wxMacEditHelper helper ( m_txn ) ; SetTXNData ( st , kTXNUseCurrentSelection , kTXNUseCurrentSelection ) ; } GetSelection ( & dummy , & end ) ; }
void wxMacMLTEControl :: Clear ( ) { wxMacWindowClipper c ( GetWXPeer ( ) ) ; wxMacEditHelper st ( m_txn ) ; TXNSetSelection ( m_txn , kTXNStartOffset , kTXNEndOffset ) ; TXNClear ( m_txn ) ; }
void wxMacMLTEControl :: Undo ( ) { TXNUndo ( m_txn ) ; }
void wxMacMLTEControl :: Redo ( ) { TXNRedo ( m_txn ) ; }
void TestIDNA :: debug ( const UChar * src , int32_t srcLength , int32_t options ) { UParseError parseError ; UErrorCode transStatus = U_ZERO_ERROR ; UErrorCode prepStatus = U_ZERO_ERROR ; NamePrepTransform * trans = NamePrepTransform :: createInstance ( parseError , transStatus ) ; int32_t prepOptions = ( ( ( options & UIDNA_ALLOW_UNASSIGNED ) != 0 ) ? USPREP_ALLOW_UNASSIGNED : 0 ) ; LocalUStringPrepProfilePointer prep ( usprep_openByType ( USPREP_RFC3491_NAMEPREP , & prepStatus ) ) ; UChar * transOut = NULL , * prepOut = NULL ; int32_t transOutLength = 0 , prepOutLength = 0 ; transOutLength = trans -> process ( src , srcLength , transOut , 0 , prepOptions > 0 , & parseError , transStatus ) ; if ( transStatus == U_BUFFER_OVERFLOW_ERROR ) { transStatus = U_ZERO_ERROR ; transOut = ( UChar * ) malloc ( U_SIZEOF_UCHAR * transOutLength ) ; transOutLength = trans -> process ( src , srcLength , transOut , transOutLength , prepOptions > 0 , & parseError , transStatus ) ; } prepOutLength = usprep_prepare ( prep . getAlias ( ) , src , srcLength , prepOut , 0 , prepOptions , & parseError , & prepStatus ) ; if ( prepStatus == U_BUFFER_OVERFLOW_ERROR ) { prepStatus = U_ZERO_ERROR ; prepOut = ( UChar * ) malloc ( U_SIZEOF_UCHAR * prepOutLength ) ; prepOutLength = usprep_prepare ( prep . getAlias ( ) , src , srcLength , prepOut , prepOutLength , prepOptions , & parseError , & prepStatus ) ; } if ( UnicodeString ( transOut , transOutLength ) != UnicodeString ( prepOut , prepOutLength ) ) { errln ( " Failed . ▁ Expected : ▁ " + prettify ( UnicodeString ( transOut , transOutLength ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( prepOut , prepOutLength ) ) ) ; } free ( transOut ) ; free ( prepOut ) ; delete trans ; }
void TestIDNA :: testAPI ( const UChar * src , const UChar * expected , const char * testName , UBool useSTD3ASCIIRules , UErrorCode expectedStatus , UBool doCompare , UBool testUnassigned , TestFunc func , UBool testSTD3ASCIIRules ) { UErrorCode status = U_ZERO_ERROR ; UChar destStack [ MAX_DEST_SIZE ] ; int32_t destLen = 0 ; UChar * dest = NULL ; int32_t expectedLen = ( expected != NULL ) ? u_strlen ( expected ) : 0 ; int32_t options = ( useSTD3ASCIIRules == TRUE ) ? UIDNA_USE_STD3_RULES : UIDNA_DEFAULT ; UParseError parseError ; int32_t tSrcLen = 0 ; UChar * tSrc = NULL ; if ( src != NULL ) { tSrcLen = u_strlen ( src ) ; tSrc = ( UChar * ) malloc ( U_SIZEOF_UCHAR * tSrcLen ) ; memcpy ( tSrc , src , tSrcLen * U_SIZEOF_UCHAR ) ; } destLen = func ( src , - 1 , NULL , 0 , options , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options , & parseError , & status ) ; if ( U_SUCCESS ( status ) && expectedStatus != U_IDNA_STD3_ASCII_RULES_ERROR && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source . ▁ Expected ▁ : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( dest , destLen ) ) ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus ) { errcheckln ( status , " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; free ( tSrc ) ; return ; } if ( testUnassigned ) { status = U_ZERO_ERROR ; destLen = func ( src , - 1 , NULL , 0 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ " + prettify ( src ) + " ▁ with ▁ both ▁ options ▁ set . ▁ Expected : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) + " Got : ▁ " + prettify ( UnicodeString ( dest , destLen ) ) ) ; debug ( src , - 1 , options | UIDNA_ALLOW_UNASSIGNED ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } status = U_ZERO_ERROR ; destLen = func ( tSrc , tSrcLen , NULL , 0 , options , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } if ( testUnassigned ) { status = U_ZERO_ERROR ; destLen = func ( tSrc , tSrcLen , NULL , 0 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length ▁ and ▁ both ▁ options ▁ set . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } status = U_ZERO_ERROR ; if ( testSTD3ASCIIRules == TRUE ) { destLen = func ( src , - 1 , NULL , 0 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ both ▁ options ▁ set . ▁ Expected : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } status = U_ZERO_ERROR ; destLen = func ( tSrc , tSrcLen , NULL , 0 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length ▁ and ▁ both ▁ options ▁ set . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } free ( tSrc ) ; }
void TestIDNA :: testCompare ( const UChar * s1 , int32_t s1Len , const UChar * s2 , int32_t s2Len , const char * testName , CompareFunc func , UBool isEqual ) { UErrorCode status = U_ZERO_ERROR ; int32_t retVal = func ( s1 , - 1 , s2 , - 1 , UIDNA_DEFAULT , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ null ▁ termniated ▁ strings . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , - 1 , s2 , - 1 , UIDNA_ALLOW_UNASSIGNED , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ null ▁ termniated ▁ strings ▁ with ▁ options ▁ set . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ and ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , s1Len , s2 , s2Len , UIDNA_DEFAULT , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ string ▁ length . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ with ▁ string ▁ length . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , s1Len , s2 , s2Len , UIDNA_ALLOW_UNASSIGNED , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ string ▁ length ▁ and ▁ options ▁ set . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ with ▁ string ▁ length ▁ and ▁ options ▁ set . ▁ Error : ▁ % s " , u_errorName ( status ) , testName ) ; } }
void TestIDNA :: testToASCII ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testAPI ( unicodeIn [ i ] , buf , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; } }
void TestIDNA :: testToUnicode ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( asciiIn ) / sizeof ( asciiIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testAPI ( buf , unicodeIn [ i ] , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; } }
void TestIDNA :: testIDNToUnicode ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; UErrorCode status = U_ZERO_ERROR ; int32_t bufLen = 0 ; UParseError parseError ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( domainNames ) / sizeof ( domainNames [ 0 ] ) ) ; i ++ ) { bufLen = ( int32_t ) strlen ( domainNames [ i ] ) ; bufLen = u_unescape ( domainNames [ i ] , buf , bufLen + 1 ) ; func ( buf , bufLen , expected , MAX_DEST_SIZE , UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s " , testName , i , u_errorName ( status ) ) ; break ; } testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s ▁ \n " , testName , i , u_errorName ( status ) ) ; break ; } } }
void TestIDNA :: testIDNToASCII ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; UErrorCode status = U_ZERO_ERROR ; int32_t bufLen = 0 ; UParseError parseError ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( domainNames ) / sizeof ( domainNames [ 0 ] ) ) ; i ++ ) { bufLen = ( int32_t ) strlen ( domainNames [ i ] ) ; bufLen = u_unescape ( domainNames [ i ] , buf , bufLen + 1 ) ; func ( buf , bufLen , expected , MAX_DEST_SIZE , UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s " , testName , i , u_errorName ( status ) ) ; break ; } testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , FALSE , TRUE , func ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s ▁ \n " , testName , i , u_errorName ( status ) ) ; break ; } } }
void TestIDNA :: testCompare ( const char * testName , CompareFunc func ) { int32_t i ; UChar www [ ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UChar com [ ] = { 0x002E , 0x0043 , 0x004F , 0x004D , 0x0000 } ; UChar buf [ MAX_DEST_SIZE ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UnicodeString source ( www ) , uni0 ( www ) , uni1 ( www ) , ascii0 ( www ) , ascii1 ( www ) ; uni0 . append ( unicodeIn [ 0 ] ) ; uni0 . append ( com ) ; uni0 . append ( ( UChar ) 0x0000 ) ; uni1 . append ( unicodeIn [ 1 ] ) ; uni1 . append ( com ) ; uni1 . append ( ( UChar ) 0x0000 ) ; ascii0 . append ( asciiIn [ 0 ] ) ; ascii0 . append ( com ) ; ascii0 . append ( ( UChar ) 0x0000 ) ; ascii1 . append ( asciiIn [ 1 ] ) ; ascii1 . append ( com ) ; ascii1 . append ( ( UChar ) 0x0000 ) ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf + 4 , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; u_strcat ( buf , com ) ; source . truncate ( 4 ) ; source . append ( unicodeIn [ i ] ) ; source . append ( com ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; int32_t srcLen = u_strlen ( src ) ; testCompare ( src , srcLen , src , srcLen , testName , func , TRUE ) ; testCompare ( src , srcLen , buf , u_strlen ( buf ) , testName , func , TRUE ) ; if ( i == 0 ) { testCompare ( src , srcLen , uni1 . getBuffer ( ) , uni1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , uni0 . getBuffer ( ) , uni0 . length ( ) - 1 , testName , func , FALSE ) ; } if ( i == 0 ) { testCompare ( src , srcLen , ascii1 . getBuffer ( ) , ascii1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , ascii0 . getBuffer ( ) , ascii0 . length ( ) - 1 , testName , func , FALSE ) ; } } }
void TestIDNA :: testErrorCases ( const char * IDNToASCIIName , TestFunc IDNToASCII , const char * IDNToUnicodeName , TestFunc IDNToUnicode ) { UChar buf [ MAX_DEST_SIZE ] ; int32_t bufLen = 0 ; for ( int32_t i = 0 ; i < ( int32_t ) ( sizeof ( errorCases ) / sizeof ( errorCases [ 0 ] ) ) ; i ++ ) { ErrorCases errorCase = errorCases [ i ] ; UChar * src = NULL ; if ( errorCase . ascii != NULL ) { bufLen = ( int32_t ) strlen ( errorCase . ascii ) ; u_charsToUChars ( errorCase . ascii , buf , bufLen + 1 ) ; } else { bufLen = 1 ; memset ( buf , 0 , U_SIZEOF_UCHAR * MAX_DEST_SIZE ) ; } if ( errorCase . unicode [ 0 ] != 0 ) { src = errorCase . unicode ; } testAPI ( src , buf , IDNToASCIIName , errorCase . useSTD3ASCIIRules , errorCase . expected , TRUE , TRUE , IDNToASCII ) ; if ( errorCase . testLabel == TRUE ) { testAPI ( src , buf , IDNToASCIIName , errorCase . useSTD3ASCIIRules , errorCase . expected , FALSE , TRUE , IDNToASCII ) ; } if ( errorCase . testToUnicode == TRUE ) { testAPI ( ( src == NULL ) ? NULL : buf , src , IDNToUnicodeName , errorCase . useSTD3ASCIIRules , errorCase . expected , TRUE , TRUE , IDNToUnicode ) ; } } }
void TestIDNA :: testChaining ( const UChar * src , int32_t numIterations , const char * testName , UBool useSTD3ASCIIRules , UBool caseInsensitive , TestFunc func ) { UChar even [ MAX_DEST_SIZE ] ; UChar odd [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; int32_t i = 0 , evenLen = 0 , oddLen = 0 , expectedLen = 0 ; UErrorCode status = U_ZERO_ERROR ; int32_t srcLen = u_strlen ( src ) ; int32_t options = ( useSTD3ASCIIRules == TRUE ) ? UIDNA_USE_STD3_RULES : UIDNA_DEFAULT ; UParseError parseError ; expectedLen = func ( src , - 1 , expected , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , - 1 , even , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , - 1 , odd , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; } } status = U_ZERO_ERROR ; expectedLen = func ( src , - 1 , expected , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , - 1 , even , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , - 1 , odd , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; } } status = U_ZERO_ERROR ; expectedLen = func ( src , srcLen , expected , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , oddLen , even , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , evenLen , odd , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ source ▁ with ▁ source ▁ length ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ source ▁ with ▁ source ▁ length ▁ failed \n " , testName ) ; } } status = U_ZERO_ERROR ; expectedLen = func ( src , srcLen , expected , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , oddLen , even , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , evenLen , odd , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed \n " , testName ) ; } } }
void TestIDNA :: testChaining ( const char * toASCIIName , TestFunc toASCII , const char * toUnicodeName , TestFunc toUnicode ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( asciiIn ) / sizeof ( asciiIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testChaining ( buf , 5 , toUnicodeName , FALSE , FALSE , toUnicode ) ; } for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { testChaining ( unicodeIn [ i ] , 5 , toASCIIName , FALSE , TRUE , toASCII ) ; } }
void TestIDNA :: testRootLabelSeparator ( const char * testName , CompareFunc func , const char * IDNToASCIIName , TestFunc IDNToASCII , const char * IDNToUnicodeName , TestFunc IDNToUnicode ) { int32_t i ; UChar www [ ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UChar com [ ] = { 0x002E , 0x0043 , 0x004F , 0x004D , 0x002E , 0x0000 } ; UChar buf [ MAX_DEST_SIZE ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UnicodeString source ( www ) , uni0 ( www ) , uni1 ( www ) , ascii0 ( www ) , ascii1 ( www ) ; uni0 . append ( unicodeIn [ 0 ] ) ; uni0 . append ( com ) ; uni0 . append ( ( UChar ) 0x0000 ) ; uni1 . append ( unicodeIn [ 1 ] ) ; uni1 . append ( com ) ; uni1 . append ( ( UChar ) 0x0000 ) ; ascii0 . append ( asciiIn [ 0 ] ) ; ascii0 . append ( com ) ; ascii0 . append ( ( UChar ) 0x0000 ) ; ascii1 . append ( asciiIn [ 1 ] ) ; ascii1 . append ( com ) ; ascii1 . append ( ( UChar ) 0x0000 ) ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf + 4 , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; u_strcat ( buf , com ) ; source . truncate ( 4 ) ; source . append ( unicodeIn [ i ] ) ; source . append ( com ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; int32_t srcLen = u_strlen ( src ) ; testCompare ( src , srcLen , buf , u_strlen ( buf ) , testName , func , TRUE ) ; testCompare ( src , srcLen , src , srcLen , testName , func , TRUE ) ; testAPI ( src , buf , IDNToASCIIName , FALSE , U_ZERO_ERROR , TRUE , TRUE , IDNToASCII ) ; testAPI ( buf , src , IDNToUnicodeName , FALSE , U_ZERO_ERROR , TRUE , TRUE , IDNToUnicode ) ; if ( i == 0 ) { testCompare ( src , srcLen , uni1 . getBuffer ( ) , uni1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , uni0 . getBuffer ( ) , uni0 . length ( ) - 1 , testName , func , FALSE ) ; } if ( i == 0 ) { testCompare ( src , srcLen , ascii1 . getBuffer ( ) , ascii1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , ascii0 . getBuffer ( ) , ascii0 . length ( ) - 1 , testName , func , FALSE ) ; } } }
void TestIDNA :: runIndexedTest ( int32_t index , UBool exec , const char * & name , char * par ) { if ( exec ) logln ( ( UnicodeString ) " TestSuite ▁ IDNA ▁ API ▁ " ) ; switch ( index ) { case 0 : name = " TestToASCII " ; if ( exec ) TestToASCII ( ) ; break ; case 1 : name = " TestToUnicode " ; if ( exec ) TestToUnicode ( ) ; break ; case 2 : name = " TestIDNToASCII " ; if ( exec ) TestIDNToASCII ( ) ; break ; case 3 : name = " TestIDNToUnicode " ; if ( exec ) TestIDNToUnicode ( ) ; break ; case 4 : name = " TestCompare " ; if ( exec ) TestCompare ( ) ; break ; case 5 : name = " TestErrorCases " ; if ( exec ) TestErrorCases ( ) ; break ; case 6 : name = " TestChaining " ; if ( exec ) TestChaining ( ) ; break ; case 7 : name = " TestRootLabelSeparator " ; if ( exec ) TestRootLabelSeparator ( ) ; break ; case 8 : name = " TestCompareReferenceImpl " ; if ( exec ) TestCompareReferenceImpl ( ) ; break ; case 9 : name = " TestDataFile " ; if ( exec ) TestDataFile ( ) ; break ; UCONFIG_NO_FILE_IO && ! UCONFIG_NO_LEGACY_CONVERSION case 10 : name = " TestRefIDNA " ; if ( exec ) TestRefIDNA ( ) ; break ; case 11 : name = " TestIDNAMonkeyTest " ; if ( exec ) TestIDNAMonkeyTest ( ) ; break ; case 10 : case 11 : name = " skip " ; break ; case 12 : { name = " TestConformanceTestVectors " ; if ( exec ) { logln ( " TestSuite ▁ IDNA ▁ conf - - - - " ) ; logln ( ) ; IdnaConfTest test ; callTest ( test , par ) ; } break ; } case 13 : name = " UTS46Test " ; if ( exec ) { logln ( " TestSuite ▁ UTS46Test - - - " ) ; logln ( ) ; LocalPointer < IntlTest > test ( createUTS46Test ( ) ) ; callTest ( * test , par ) ; } break ; default : name = " " ; break ; } }
void TestIDNA :: TestToASCII ( ) { testToASCII ( " uidna _ toASCII " , uidna_toASCII ) ; }
void TestIDNA :: TestToUnicode ( ) { testToUnicode ( " uidna _ toUnicode " , uidna_toUnicode ) ; }
void TestIDNA :: TestIDNToASCII ( ) { testIDNToASCII ( " uidna _ IDNToASCII " , uidna_IDNToASCII ) ; }
void TestIDNA :: TestIDNToUnicode ( ) { testIDNToUnicode ( " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; }
void TestIDNA :: TestCompare ( ) { testCompare ( " uidna _ compare " , uidna_compare ) ; }
void TestIDNA :: TestErrorCases ( ) { testErrorCases ( " uidna _ IDNToASCII " , uidna_IDNToASCII , " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; }
void TestIDNA :: TestRootLabelSeparator ( ) { testRootLabelSeparator ( " uidna _ compare " , uidna_compare , " uidna _ IDNToASCII " , uidna_IDNToASCII , " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; }
void TestIDNA :: TestChaining ( ) { testChaining ( " uidna _ toASCII " , uidna_toASCII , " uidna _ toUnicode " , uidna_toUnicode ) ; }
UnicodeString TestIDNA :: testCompareReferenceImpl ( UnicodeString & src , TestFunc refIDNA , const char * refIDNAName , TestFunc uIDNA , const char * uIDNAName , int32_t options ) { const UChar * srcUChars = src . getBuffer ( ) ; UChar exp [ MAX_DEST_SIZE ] = { 0 } ; int32_t expCap = MAX_DEST_SIZE , expLen = 0 ; UErrorCode expStatus = U_ZERO_ERROR ; UParseError parseError ; logln ( " Comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ for ▁ input : ▁ " + prettify ( srcUChars ) ) ; expLen = refIDNA ( srcUChars , src . length ( ) - 1 , exp , expCap , options , & parseError , & expStatus ) ; UChar got [ MAX_DEST_SIZE ] = { 0 } ; int32_t gotCap = MAX_DEST_SIZE , gotLen = 0 ; UErrorCode gotStatus = U_ZERO_ERROR ; gotLen = uIDNA ( srcUChars , src . length ( ) - 1 , got , gotCap , options , & parseError , & gotStatus ) ; if ( expStatus != gotStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ status ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( gotStatus ) ) + " ▁ for ▁ Source : ▁ " + prettify ( srcUChars ) + " ▁ Options : ▁ " + options ) ; return UnicodeString ( " " ) ; } if ( U_SUCCESS ( expStatus ) ) { if ( u_strCompare ( exp , expLen , got , gotLen , TRUE ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ output ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ Expected : ▁ " + prettify ( UnicodeString ( exp , expLen ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( got , gotLen ) ) + " ▁ for ▁ Source : ▁ " + prettify ( srcUChars ) + " ▁ Options : ▁ " + options ) ; } return UnicodeString ( exp , expLen ) ; } else { logln ( " Got ▁ the ▁ same ▁ error ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ for ▁ input : ▁ " + prettify ( srcUChars ) ) ; } return UnicodeString ( " " ) ; }
void TestIDNA :: testCompareReferenceImpl ( const UChar * src , int32_t srcLen ) { UnicodeString label ( src , srcLen ) ; label . append ( ( UChar ) 0x0000 ) ; UnicodeString asciiLabel = testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_ALLOW_UNASSIGNED ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_DEFAULT ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_USE_STD3_RULES ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_USE_STD3_RULES | UIDNA_ALLOW_UNASSIGNED ) ; if ( asciiLabel . length ( ) != 0 ) { asciiLabel . append ( ( UChar ) 0x0000 ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_ALLOW_UNASSIGNED ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_DEFAULT ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_USE_STD3_RULES ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_USE_STD3_RULES | UIDNA_ALLOW_UNASSIGNED ) ; } }
void TestIDNA :: TestIDNAMonkeyTest ( ) { UnicodeString source ; UErrorCode status = U_ZERO_ERROR ; int i ; getInstance ( status ) ; if ( U_FAILURE ( status ) ) { dataerrln ( " Test ▁ could ▁ not ▁ initialize . ▁ Got ▁ % s " , u_errorName ( status ) ) ; return ; } for ( i = 0 ; i < loopCount ; i ++ ) { source . truncate ( 0 ) ; getTestSource ( source ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; } for ( i = 0 ; i < ( int ) ( sizeof ( failures ) / sizeof ( failures [ 0 ] ) ) ; i ++ ) { source . truncate ( 0 ) ; source . append ( UnicodeString ( failures [ i ] , - 1 , US_INV ) ) ; source = source . unescape ( ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; } source . truncate ( 0 ) ; source . append ( UNICODE_STRING_SIMPLE ( " \\uCF18\\U00021161\\U000EEF11\\U0002BB82\\U0001D63C " ) ) ; debug ( source . getBuffer ( ) , source . length ( ) , UIDNA_ALLOW_UNASSIGNED ) ; { UnicodeString source ( " \\u043f\\u00AD\\u034f\\u043e\\u0447\\u0435\\u043c\\u0443\\u0436\\u0435\\u043e\\u043d\\u0438\\u043d\\u0435\\u0433\\u043e\\u0432\\u043e\\u0440\\u044f\\u0442\\u043f\\u043e\\u0440\\u0443\\u0441\\u0441\\u043a\\u0438\\u0000" , - 1 , US_INV ) ; source = source . unescape ( ) ; UnicodeString expected ( " \\u043f\\u043e\\u0447\\u0435\\u043c\\u0443\\u0436\\u0435\\u043e\\u043d\\u0438\\u043d\\u0435\\u0433\\u043e\\u0432\\u043e\\u0440\\u044f\\u0442\\u043f\\u043e\\u0440\\u0443\\u0441\\u0441\\u043a\\u0438\\u0000" , - 1 , US_INV ) ; expected = expected . unescape ( ) ; UnicodeString ascii ( " xn - - b1abfaaepdrnnbgefbadotcwatmq2g4l " ) ; ascii . append ( ( UChar ) 0x0000 ) ; testAPI ( source . getBuffer ( ) , ascii . getBuffer ( ) , " uidna _ toASCII " , FALSE , U_ZERO_ERROR , TRUE , TRUE , uidna_toASCII ) ; testAPI ( source . getBuffer ( ) , ascii . getBuffer ( ) , " idnaref _ toASCII " , FALSE , U_ZERO_ERROR , TRUE , TRUE , idnaref_toASCII ) ; testCompareReferenceImpl ( source . getBuffer ( ) , source . length ( ) - 1 ) ; } }
void TestIDNA :: TestCompareReferenceImpl ( ) { UChar src [ 2 ] = { 0 , 0 } ; int32_t srcLen = 0 ; for ( int32_t i = 0x40000 ; i < 0x10ffff ; i ++ ) { if ( quick == TRUE && i > 0x1FFFF ) { return ; } if ( i >= 0x30000 && i <= 0xF0000 ) { i += 0xB0000 ; } if ( i > 0xFFFF ) { src [ 0 ] = U16_LEAD ( i ) ; src [ 1 ] = U16_TRAIL ( i ) ; srcLen = 2 ; } else { src [ 0 ] = ( UChar ) i ; src [ 1 ] = 0 ; srcLen = 1 ; } testCompareReferenceImpl ( src , srcLen ) ; } }
void TestIDNA :: TestRefIDNA ( ) { UErrorCode status = U_ZERO_ERROR ; getInstance ( status ) ; if ( U_FAILURE ( status ) ) { if ( status == U_FILE_ACCESS_ERROR ) { dataerrln ( " Test ▁ could ▁ not ▁ initialize . ▁ Got ▁ % s " , u_errorName ( status ) ) ; } return ; } testToASCII ( " idnaref _ toASCII " , idnaref_toASCII ) ; testToUnicode ( " idnaref _ toUnicode " , idnaref_toUnicode ) ; testIDNToASCII ( " idnaref _ IDNToASCII " , idnaref_IDNToASCII ) ; testIDNToUnicode ( " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testCompare ( " idnaref _ compare " , idnaref_compare ) ; testErrorCases ( " idnaref _ IDNToASCII " , idnaref_IDNToASCII , " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testChaining ( " idnaref _ toASCII " , idnaref_toASCII , " idnaref _ toUnicode " , idnaref_toUnicode ) ; testRootLabelSeparator ( " idnaref _ compare " , idnaref_compare , " idnaref _ IDNToASCII " , idnaref_IDNToASCII , " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testChaining ( " idnaref _ toASCII " , idnaref_toASCII , " idnaref _ toUnicode " , idnaref_toUnicode ) ; }
void TestIDNA :: TestDataFile ( ) { testData ( * this ) ; }
TestIDNA :: ~ TestIDNA ( ) { if ( gPrep != NULL ) { delete gPrep ; gPrep = NULL ; } }
NamePrepTransform * TestIDNA :: getInstance ( UErrorCode & status ) { if ( TestIDNA :: gPrep == NULL ) { UParseError parseError ; TestIDNA :: gPrep = NamePrepTransform :: createInstance ( parseError , status ) ; if ( TestIDNA :: gPrep == NULL ) { return NULL ; } } return TestIDNA :: gPrep ; }
