<DOCUMENT_ID="Soverance/EtherealLegends/tree/master/Ethereal/Private/Gear/Weapons/Ranged/Annihilator.cpp"> # include " Ethereal . h " # include " Annihilator . h " # define LOCTEXT_NAMESPACE " EtherealText " AAnnihilator :: AAnnihilator ( const FObjectInitializer & ObjectInitializer ) : Super ( ObjectInitializer ) { static ConstructorHelpers :: FObjectFinder < USkeletalMesh > SkeletalMeshObject ( TEXT ( " SkeletalMesh ' / Game / VFX / sphere _ skeletal . sphere _ skeletal ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UStaticMesh > StaticMeshObject ( TEXT ( " StaticMesh ' / Game / Weapons / Ranged / Anni . Anni ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UStaticMesh > OffhandMeshObject ( TEXT ( " StaticMesh ' / Game / VFX / sphere . sphere ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UTexture2D > LargeIconObject ( TEXT ( " Texture2D ' / Game / Blueprints / Widgets / UI - Images / Icons _ Gear / WeaponIcon _ Annihilator . WeaponIcon _ Annihilator ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UTexture2D > SmallIconObject ( TEXT ( " Texture2D ' / Game / Blueprints / Widgets / UI - Images / Icons _ Gear / WeaponIcon _ Annihilator - small . WeaponIcon _ Annihilator - small ' " ) ) ; Name = EMasterGearList :: GL_Annihilator ; NameText = LOCTEXT ( " AnnihilatorName " , " Annihilator " ) ; Type = EMasterGearTypes :: GT_Ranged ; TypeText = LOCTEXT ( " AnnihilatorType " , " Ranged " ) ; Description = " An ▁ embodiment ▁ of ▁ the ▁ Ethereal ▁ Virtue : ▁ Wrath . " ; Price = 40000 ; MPCost = 0.0f ; ATK = 50.0f ; DEF = 40.0f ; SPD = 20.0f ; HP = 500.0f ; MP = 250.0f ; LargeIcon = LargeIconObject . Object ; SmallIcon = SmallIconObject . Object ; SK_WeaponSkeletalMesh = SkeletalMeshObject . Object ; SM_WeaponStaticMesh = StaticMeshObject . Object ; SM_WeaponOffhandMesh = StaticMeshObject . Object ; WeaponSkeletalMesh -> SetSkeletalMesh ( SK_WeaponSkeletalMesh ) ; WeaponSkeletalMesh -> SetHiddenInGame ( true ) ; WeaponStaticMesh -> SetStaticMesh ( SM_WeaponStaticMesh ) ; WeaponStaticMesh -> SetWorldScale3D ( FVector ( 0.15f , 0.15f , 0.15f ) ) ; WeaponStaticMesh -> SetRelativeLocation ( FVector ( 20 , - 2 , - 2 ) ) ; WeaponStaticMesh -> SetRelativeRotation ( FRotator ( - 12 , - 90 , - 75 ) ) ; WeaponOffhandMesh -> SetStaticMesh ( SM_WeaponOffhandMesh ) ; WeaponOffhandMesh -> SetHiddenInGame ( true ) ; } void AAnnihilator :: BeginPlay ( ) { Super :: BeginPlay ( ) ; OnBindGear . AddDynamic ( this , & AAnnihilator :: BindWeapon ) ; } void AAnnihilator :: BindWeapon ( ) { if ( IsShown ) { ShowWeapon ( false , true , false ) ; } } # undef LOCTEXT_NAMESPACE </DOCUMENT>
<DOCUMENT_ID="LiquidShockGames/bongobucks/tree/master/src/qt/sendcoinsdialog.cpp"> # include " sendcoinsdialog . h " # include " ui _ sendcoinsdialog . h " # include " walletmodel . h " # include " bitcoinunits . h " # include " addressbookpage . h " # include " optionsmodel . h " # include " sendcoinsentry . h " # include " guiutil . h " # include " askpassphrasedialog . h " # include < QMessageBox > # include < QLocale > # include < QTextDocument > # include < QScrollBar > SendCoinsDialog :: SendCoinsDialog ( QWidget * parent ) : QDialog ( parent ) , ui ( new Ui :: SendCoinsDialog ) , model ( 0 ) { ui -> setupUi ( this ) ; # ifdef Q_WS_MAC ui -> addButton -> setIcon ( QIcon ( ) ) ; ui -> clearButton -> setIcon ( QIcon ( ) ) ; ui -> sendButton -> setIcon ( QIcon ( ) ) ; # endif addEntry ( ) ; connect ( ui -> addButton , SIGNAL ( clicked ( ) ) , this , SLOT ( addEntry ( ) ) ) ; connect ( ui -> clearButton , SIGNAL ( clicked ( ) ) , this , SLOT ( clear ( ) ) ) ; fNewRecipientAllowed = true ; } void SendCoinsDialog :: setModel ( WalletModel * model ) { this -> model = model ; for ( int i = 0 ; i < ui -> entries -> count ( ) ; ++ i ) { SendCoinsEntry * entry = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( i ) -> widget ( ) ) ; if ( entry ) { entry -> setModel ( model ) ; } } if ( model && model -> getOptionsModel ( ) ) { setBalance ( model -> getBalance ( ) , model -> getUnconfirmedBalance ( ) , model -> getImmatureBalance ( ) ) ; connect ( model , SIGNAL ( balanceChanged ( qint64 , qint64 , qint64 ) ) , this , SLOT ( setBalance ( qint64 , qint64 , qint64 ) ) ) ; connect ( model -> getOptionsModel ( ) , SIGNAL ( displayUnitChanged ( int ) ) , this , SLOT ( updateDisplayUnit ( ) ) ) ; } } SendCoinsDialog :: ~ SendCoinsDialog ( ) { delete ui ; } void SendCoinsDialog :: on_sendButton_clicked ( ) { QList < SendCoinsRecipient > recipients ; bool valid = true ; if ( ! model ) return ; for ( int i = 0 ; i < ui -> entries -> count ( ) ; ++ i ) { SendCoinsEntry * entry = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( i ) -> widget ( ) ) ; if ( entry ) { if ( entry -> validate ( ) ) { recipients . append ( entry -> getValue ( ) ) ; } else { valid = false ; } } } if ( ! valid || recipients . isEmpty ( ) ) { return ; } QStringList formatted ; foreach ( const SendCoinsRecipient & rcp , recipients ) { formatted . append ( tr ( " < b > % 1 < / b > ▁ to ▁ % 2 ▁ ( %3 ) " ) . arg ( BitcoinUnits :: formatWithUnit ( BitcoinUnits :: BTC , rcp . amount ) , Qt :: escape ( rcp . label ) , rcp . address ) ) ; } fNewRecipientAllowed = false ; QMessageBox :: StandardButton retval = QMessageBox :: question ( this , tr ( " Confirm ▁ send ▁ coins " ) , tr ( " Are ▁ you ▁ sure ▁ you ▁ want ▁ to ▁ send ▁ % 1 ? " ) . arg ( formatted . join ( tr ( " ▁ and ▁ " ) ) ) , QMessageBox :: Yes | QMessageBox :: Cancel , QMessageBox :: Cancel ) ; if ( retval != QMessageBox :: Yes ) { fNewRecipientAllowed = true ; return ; } WalletModel :: UnlockContext ctx ( model -> requestUnlock ( ) ) ; if ( ! ctx . isValid ( ) ) { fNewRecipientAllowed = true ; return ; } WalletModel :: SendCoinsReturn sendstatus = model -> sendCoins ( recipients ) ; switch ( sendstatus . status ) { case WalletModel :: InvalidAddress : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " The ▁ recepient ▁ address ▁ is ▁ not ▁ valid , ▁ please ▁ recheck . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: InvalidAmount : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " The ▁ amount ▁ to ▁ pay ▁ must ▁ be ▁ larger ▁ than ▁ 0 . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: AmountExceedsBalance : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " The ▁ amount ▁ exceeds ▁ your ▁ balance . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: AmountWithFeeExceedsBalance : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " The ▁ total ▁ exceeds ▁ your ▁ balance ▁ when ▁ the ▁ % 1 ▁ transaction ▁ fee ▁ is ▁ included . " ) . arg ( BitcoinUnits :: formatWithUnit ( BitcoinUnits :: BTC , sendstatus . fee ) ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: DuplicateAddress : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " Duplicate ▁ address ▁ found , ▁ can ▁ only ▁ send ▁ to ▁ each ▁ address ▁ once ▁ per ▁ send ▁ operation . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: TransactionCreationFailed : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " Error : ▁ Transaction ▁ creation ▁ failed . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: TransactionCommitFailed : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " Error : ▁ The ▁ transaction ▁ was ▁ rejected . ▁ This ▁ might ▁ happen ▁ if ▁ some ▁ of ▁ the ▁ coins ▁ in ▁ your ▁ wallet ▁ were ▁ already ▁ spent , ▁ such ▁ as ▁ if ▁ you ▁ used ▁ a ▁ copy ▁ of ▁ wallet . dat ▁ and ▁ coins ▁ were ▁ spent ▁ in ▁ the ▁ copy ▁ but ▁ not ▁ marked ▁ as ▁ spent ▁ here . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: Aborted : break ; case WalletModel :: OK : accept ( ) ; break ; } fNewRecipientAllowed = true ; } void SendCoinsDialog :: clear ( ) { while ( ui -> entries -> count ( ) ) { delete ui -> entries -> takeAt ( 0 ) -> widget ( ) ; } addEntry ( ) ; updateRemoveEnabled ( ) ; ui -> sendButton -> setDefault ( true ) ; } void SendCoinsDialog :: reject ( ) { clear ( ) ; } void SendCoinsDialog :: accept ( ) { clear ( ) ; } SendCoinsEntry * SendCoinsDialog :: addEntry ( ) { SendCoinsEntry * entry = new SendCoinsEntry ( this ) ; entry -> setModel ( model ) ; ui -> entries -> addWidget ( entry ) ; connect ( entry , SIGNAL ( removeEntry ( SendCoinsEntry * ) ) , this , SLOT ( removeEntry ( SendCoinsEntry * ) ) ) ; updateRemoveEnabled ( ) ; entry -> clear ( ) ; entry -> setFocus ( ) ; ui -> scrollAreaWidgetContents -> resize ( ui -> scrollAreaWidgetContents -> sizeHint ( ) ) ; QCoreApplication :: instance ( ) -> processEvents ( ) ; QScrollBar * bar = ui -> scrollArea -> verticalScrollBar ( ) ; if ( bar ) bar -> setSliderPosition ( bar -> maximum ( ) ) ; return entry ; } void SendCoinsDialog :: updateRemoveEnabled ( ) { bool enabled = ( ui -> entries -> count ( ) > 1 ) ; for ( int i = 0 ; i < ui -> entries -> count ( ) ; ++ i ) { SendCoinsEntry * entry = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( i ) -> widget ( ) ) ; if ( entry ) { entry -> setRemoveEnabled ( enabled ) ; } } setupTabChain ( 0 ) ; } void SendCoinsDialog :: removeEntry ( SendCoinsEntry * entry ) { delete entry ; updateRemoveEnabled ( ) ; } QWidget * SendCoinsDialog :: setupTabChain ( QWidget * prev ) { for ( int i = 0 ; i < ui -> entries -> count ( ) ; ++ i ) { SendCoinsEntry * entry = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( i ) -> widget ( ) ) ; if ( entry ) { prev = entry -> setupTabChain ( prev ) ; } } QWidget :: setTabOrder ( prev , ui -> addButton ) ; QWidget :: setTabOrder ( ui -> addButton , ui -> sendButton ) ; return ui -> sendButton ; } void SendCoinsDialog :: pasteEntry ( const SendCoinsRecipient & rv ) { if ( ! fNewRecipientAllowed ) return ; SendCoinsEntry * entry = 0 ; if ( ui -> entries -> count ( ) == 1 ) { SendCoinsEntry * first = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( 0 ) -> widget ( ) ) ; if ( first -> isClear ( ) ) { entry = first ; } } if ( ! entry ) { entry = addEntry ( ) ; } entry -> setValue ( rv ) ; } bool SendCoinsDialog :: handleURI ( const QString & uri ) { SendCoinsRecipient rv ; if ( GUIUtil :: parseBitcoinURI ( uri , & rv ) ) { pasteEntry ( rv ) ; return true ; } return false ; } void SendCoinsDialog :: setBalance ( qint64 balance , qint64 unconfirmedBalance , qint64 immatureBalance ) { Q_UNUSED ( unconfirmedBalance ) ; Q_UNUSED ( immatureBalance ) ; if ( ! model || ! model -> getOptionsModel ( ) ) return ; int unit = model -> getOptionsModel ( ) -> getDisplayUnit ( ) ; ui -> labelBalance -> setText ( BitcoinUnits :: formatWithUnit ( unit , balance ) ) ; } void SendCoinsDialog :: updateDisplayUnit ( ) { if ( model && model -> getOptionsModel ( ) ) { ui -> labelBalance -> setText ( BitcoinUnits :: formatWithUnit ( model -> getOptionsModel ( ) -> getDisplayUnit ( ) , model -> getBalance ( ) ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="zaclimon/android_kernel_samsung_kylepro/tree/master/tools/gator/daemon/LocalCapture.cpp"> # include < sys / stat . h > # include < sys / types . h > # include < dirent . h > # include < string . h > # include < stdlib . h > # include < unistd . h > # include " LocalCapture . h " # include " SessionData . h " # include " Logging . h " # include " OlyUtility . h " # include " EventsXML . h " LocalCapture :: LocalCapture ( ) { } LocalCapture :: ~ LocalCapture ( ) { } void LocalCapture :: createAPCDirectory ( char * target_path ) { gSessionData -> mAPCDir = createUniqueDirectory ( target_path , " . apc " ) ; if ( ( removeDirAndAllContents ( gSessionData -> mAPCDir ) != 0 || mkdir ( gSessionData -> mAPCDir , S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH ) != 0 ) ) { logg -> logError ( __FILE__ , __LINE__ , " Unable ▁ to ▁ create ▁ directory ▁ % s " , gSessionData -> mAPCDir ) ; handleException ( ) ; } } void LocalCapture :: write ( char * string ) { char file [ PATH_MAX ] ; snprintf ( file , PATH_MAX , " % s / session . xml " , gSessionData -> mAPCDir ) ; if ( util -> writeToDisk ( file , string ) < 0 ) { logg -> logError ( __FILE__ , __LINE__ , " Error ▁ writing ▁ % s \n Please ▁ verify ▁ the ▁ path . " , file ) ; handleException ( ) ; } EventsXML eventsXML ; eventsXML . write ( gSessionData -> mAPCDir ) ; } char * LocalCapture :: createUniqueDirectory ( const char * initialPath , const char * ending ) { char * output ; char path [ PATH_MAX ] ; if ( initialPath == 0 || strlen ( initialPath ) == 0 ) { logg -> logError ( __FILE__ , __LINE__ , " Missing ▁ - o ▁ command ▁ line ▁ option ▁ required ▁ for ▁ a ▁ local ▁ capture . " ) ; handleException ( ) ; } else if ( initialPath [ 0 ] != ' / ' ) { if ( getcwd ( path , PATH_MAX ) == 0 ) { logg -> logMessage ( " Unable ▁ to ▁ retrieve ▁ the ▁ current ▁ working ▁ directory " ) ; } strncat ( path , " / " , PATH_MAX - strlen ( path ) - 1 ) ; strncat ( path , initialPath , PATH_MAX - strlen ( path ) - 1 ) ; } else { strncpy ( path , initialPath , PATH_MAX ) ; path [ PATH_MAX - 1 ] = 0 ; } if ( strcmp ( & path [ strlen ( path ) - strlen ( ending ) ] , ending ) != 0 ) { strncat ( path , ending , PATH_MAX - strlen ( path ) - 1 ) ; } output = strdup ( path ) ; return output ; } int LocalCapture :: removeDirAndAllContents ( char * path ) { int error = 0 ; struct stat mFileInfo ; if ( stat ( path , & mFileInfo ) == 0 ) { if ( mFileInfo . st_mode & S_IFDIR ) { DIR * dir = opendir ( path ) ; dirent * entry = readdir ( dir ) ; while ( entry ) { if ( strcmp ( entry -> d_name , " . " ) != 0 && strcmp ( entry -> d_name , " . . " ) != 0 ) { char * newpath = ( char * ) malloc ( strlen ( path ) + strlen ( entry -> d_name ) + 2 ) ; sprintf ( newpath , " % s / % s " , path , entry -> d_name ) ; error = removeDirAndAllContents ( newpath ) ; free ( newpath ) ; if ( error ) { break ; } } entry = readdir ( dir ) ; } closedir ( dir ) ; if ( error == 0 ) { error = rmdir ( path ) ; } } else { error = remove ( path ) ; } } return error ; } void LocalCapture :: copyImages ( ImageLinkList * ptr ) { char dstfilename [ PATH_MAX ] ; while ( ptr ) { strncpy ( dstfilename , gSessionData -> mAPCDir , PATH_MAX ) ; dstfilename [ PATH_MAX - 1 ] = 0 ; if ( gSessionData -> mAPCDir [ strlen ( gSessionData -> mAPCDir ) - 1 ] != ' / ' ) { strncat ( dstfilename , " / " , PATH_MAX - strlen ( dstfilename ) - 1 ) ; } strncat ( dstfilename , util -> getFilePart ( ptr -> path ) , PATH_MAX - strlen ( dstfilename ) - 1 ) ; if ( util -> copyFile ( ptr -> path , dstfilename ) ) { logg -> logMessage ( " copied ▁ file ▁ % s ▁ to ▁ % s " , ptr -> path , dstfilename ) ; } else { logg -> logMessage ( " copy ▁ of ▁ file ▁ % s ▁ to ▁ % s ▁ failed " , ptr -> path , dstfilename ) ; } ptr = ptr -> next ; } } </DOCUMENT>
<DOCUMENT_ID="Riztazz/trinitycore-m4a/tree/master/src/server/scripts/EasternKingdoms/Stratholme/boss_nerubenkan.cpp"> # include " stdafx . hpp " # include " ScriptMgr . h " # include " ScriptedCreature . h " # include " stratholme . h " enum Spells { SPELL_ENCASINGWEBS = 4962 , SPELL_PIERCEARMOR = 6016 , SPELL_CRYPT_SCARABS = 31602 , SPELL_RAISEUNDEADSCARAB = 17235 } ; class boss_nerubenkan : public CreatureScript { public : boss_nerubenkan ( ) : CreatureScript ( " boss _ nerubenkan " ) { } CreatureAI * GetAI ( Creature * creature ) const { return new boss_nerubenkanAI ( creature ) ; } struct boss_nerubenkanAI : public ScriptedAI { boss_nerubenkanAI ( Creature * creature ) : ScriptedAI ( creature ) { instance = me -> GetInstanceScript ( ) ; } InstanceScript * instance ; uint32 EncasingWebs_Timer ; uint32 PierceArmor_Timer ; uint32 CryptScarabs_Timer ; uint32 RaiseUndeadScarab_Timer ; void Reset ( ) { CryptScarabs_Timer = 3000 ; EncasingWebs_Timer = 7000 ; PierceArmor_Timer = 19000 ; RaiseUndeadScarab_Timer = 3000 ; } void EnterCombat ( Unit * ) { } void JustDied ( Unit * ) { if ( instance ) instance -> SetData ( TYPE_NERUB , IN_PROGRESS ) ; } void RaiseUndeadScarab ( Unit * victim ) { if ( Creature * pUndeadScarab = DoSpawnCreature ( 10876 , float ( irand ( - 9 , 9 ) ) , float ( irand ( - 9 , 9 ) ) , 0 , 0 , TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN , 180000 ) ) if ( pUndeadScarab -> AI ( ) ) pUndeadScarab -> AI ( ) -> AttackStart ( victim ) ; } void UpdateAI ( const uint32 diff ) { if ( ! UpdateVictim ( ) ) return ; if ( EncasingWebs_Timer <= diff ) { DoCast ( me -> getVictim ( ) , SPELL_ENCASINGWEBS ) ; EncasingWebs_Timer = 30000 ; } else EncasingWebs_Timer -= diff ; if ( PierceArmor_Timer <= diff ) { if ( urand ( 0 , 3 ) < 2 ) DoCast ( me -> getVictim ( ) , SPELL_PIERCEARMOR ) ; PierceArmor_Timer = 35000 ; } else PierceArmor_Timer -= diff ; if ( CryptScarabs_Timer <= diff ) { DoCast ( me -> getVictim ( ) , SPELL_CRYPT_SCARABS ) ; CryptScarabs_Timer = 20000 ; } else CryptScarabs_Timer -= diff ; if ( RaiseUndeadScarab_Timer <= diff ) { RaiseUndeadScarab ( me -> getVictim ( ) ) ; RaiseUndeadScarab_Timer = 16000 ; } else RaiseUndeadScarab_Timer -= diff ; DoMeleeAttackIfReady ( ) ; } } ; } ; void AddSC_boss_nerubenkan ( ) { new boss_nerubenkan ( ) ; } </DOCUMENT>
<DOCUMENT_ID="eugene1g/phantomjs/tree/master/src/qt/qtbase/src/corelib/doc/snippets/code/src_corelib_io_qfile.cpp"> QFile file ; QDir :: setCurrent ( " / tmp " ) ; file . setFileName ( " readme . txt " ) ; QDir :: setCurrent ( " / home " ) ; file . open ( QIODevice :: ReadOnly ) ; QByteArray myEncoderFunc ( const QString & fileName ) ; QString myDecoderFunc ( const QByteArray & localFileName ) ; # include < stdio . h > void printError ( const char * msg ) { QFile file ; file . open ( stderr , QIODevice :: WriteOnly ) ; file . write ( msg , qstrlen ( msg ) ) ; file . close ( ) ; } CONFIG += console </DOCUMENT>
<DOCUMENT_ID="DLR-SC/tigl/tree/master/src/generated/CPACSFarField.cpp"> # include " CPACSFarField . h " # include " CTiglError . h " # include " CTiglLogging . h " # include " TixiHelper . h " namespace tigl { namespace generated { CPACSFarField :: CPACSFarField ( ) : m_referenceLength ( 0 ) , m_multiplier ( 0 ) { } CPACSFarField :: ~ CPACSFarField ( ) { } void CPACSFarField :: ReadCPACS ( const TixiDocumentHandle & tixiHandle , const std :: string & xpath ) { if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / type " ) ) { m_type = stringToTiglFarFieldType ( tixi :: TixiGetElement < std :: string > ( tixiHandle , xpath + " / type " ) ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ type ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / referenceLength " ) ) { m_referenceLength = tixi :: TixiGetElement < double > ( tixiHandle , xpath + " / referenceLength " ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ referenceLength ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / multiplier " ) ) { m_multiplier = tixi :: TixiGetElement < double > ( tixiHandle , xpath + " / multiplier " ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ multiplier ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } } void CPACSFarField :: WriteCPACS ( const TixiDocumentHandle & tixiHandle , const std :: string & xpath ) const { tixi :: TixiCreateElementIfNotExists ( tixiHandle , xpath + " / type " ) ; tixi :: TixiSaveElement ( tixiHandle , xpath + " / type " , TiglFarFieldTypeToString ( m_type ) ) ; tixi :: TixiCreateElementIfNotExists ( tixiHandle , xpath + " / referenceLength " ) ; tixi :: TixiSaveElement ( tixiHandle , xpath + " / referenceLength " , m_referenceLength ) ; tixi :: TixiCreateElementIfNotExists ( tixiHandle , xpath + " / multiplier " ) ; tixi :: TixiSaveElement ( tixiHandle , xpath + " / multiplier " , m_multiplier ) ; } const TiglFarFieldType & CPACSFarField :: GetType ( ) const { return m_type ; } void CPACSFarField :: SetType ( const TiglFarFieldType & value ) { m_type = value ; } const double & CPACSFarField :: GetReferenceLength ( ) const { return m_referenceLength ; } void CPACSFarField :: SetReferenceLength ( const double & value ) { m_referenceLength = value ; } const double & CPACSFarField :: GetMultiplier ( ) const { return m_multiplier ; } void CPACSFarField :: SetMultiplier ( const double & value ) { m_multiplier = value ; } } } </DOCUMENT>
<DOCUMENT_ID="biojppm/c4stl/tree/master/bm/list/push_back/flat_fwd_list__paged__NumBytes_64___int32_t.cpp"> # include " benchmark / benchmark . h " # include " c4 / log . hpp " # include " c4 / allocator . hpp " # include " . . / list _ types . hpp " namespace bm = benchmark ; namespace c4 { template < class List > void BM_ListPushBack ( bm :: State & st ) { List li ; using T = typename List :: value_type ; T v { } ; size_t count = 0 ; while ( st . KeepRunning ( ) ) { for ( int i = 0 , e = st . range ( 0 ) ; i < e ; ++ i ) { if ( li . size ( ) == li . max_size ( ) ) li . clear ( ) ; li . push_back ( v ) ; ++ count ; } li . clear ( ) ; } st . SetComplexityN ( st . range ( 0 ) ) ; st . SetItemsProcessed ( count ) ; st . SetBytesProcessed ( count * sizeof ( T ) ) ; } BENCHMARK_TEMPLATE ( BM_ListPushBack , flat_fwd_list__paged < NumBytes < 64 > C4_COMMA int32_t > ) -> RangeMultiplier ( 2 ) -> Range ( 4 , 1 << 19 ) -> Complexity ( ) ; } BENCHMARK_MAIN ( ) </DOCUMENT>
<DOCUMENT_ID="SignFinder/FaceCore/tree/master/src/server/game/Movement/MovementGenerators/PointMovementGenerator.cpp"> # include " PointMovementGenerator . h " # include " Errors . h " # include " Creature . h " # include " CreatureAI . h " # include " World . h " # include " MoveSplineInit . h " # include " MoveSpline . h " # include " Player . h " template < class T > void PointMovementGenerator < T > :: DoInitialize ( T * unit ) { if ( ! unit -> IsStopped ( ) ) unit -> StopMoving ( ) ; unit -> AddUnitState ( UNIT_STATE_ROAMING | UNIT_STATE_ROAMING_MOVE ) ; if ( id == EVENT_CHARGE_PREPATH ) return ; Movement :: MoveSplineInit init ( unit ) ; init . MoveTo ( i_x , i_y , i_z , m_generatePath ) ; if ( speed > 0.0f ) init . SetVelocity ( speed ) ; init . Launch ( ) ; } template < class T > bool PointMovementGenerator < T > :: DoUpdate ( T * unit , uint32 ) { if ( ! unit ) return false ; if ( unit -> HasUnitState ( UNIT_STATE_ROOT | UNIT_STATE_STUNNED ) ) { unit -> ClearUnitState ( UNIT_STATE_ROAMING_MOVE ) ; return true ; } unit -> AddUnitState ( UNIT_STATE_ROAMING_MOVE ) ; if ( id != EVENT_CHARGE_PREPATH && i_recalculateSpeed && ! unit -> movespline -> Finalized ( ) ) { i_recalculateSpeed = false ; Movement :: MoveSplineInit init ( unit ) ; init . MoveTo ( i_x , i_y , i_z , m_generatePath ) ; if ( speed > 0.0f ) init . SetVelocity ( speed ) ; init . Launch ( ) ; } return ! unit -> movespline -> Finalized ( ) ; } template < class T > void PointMovementGenerator < T > :: DoFinalize ( T * unit ) { if ( unit -> HasUnitState ( UNIT_STATE_CHARGING ) ) unit -> ClearUnitState ( UNIT_STATE_ROAMING | UNIT_STATE_ROAMING_MOVE ) ; if ( unit -> movespline -> Finalized ( ) ) MovementInform ( unit ) ; } template < class T > void PointMovementGenerator < T > :: DoReset ( T * unit ) { if ( ! unit -> IsStopped ( ) ) unit -> StopMoving ( ) ; unit -> AddUnitState ( UNIT_STATE_ROAMING | UNIT_STATE_ROAMING_MOVE ) ; } template < class T > void PointMovementGenerator < T > :: MovementInform ( T * ) { } template < > void PointMovementGenerator < Creature > :: MovementInform ( Creature * unit ) { if ( unit -> AI ( ) ) unit -> AI ( ) -> MovementInform ( POINT_MOTION_TYPE , id ) ; } template void PointMovementGenerator < Player > :: DoInitialize ( Player * ) ; template void PointMovementGenerator < Creature > :: DoInitialize ( Creature * ) ; template void PointMovementGenerator < Player > :: DoFinalize ( Player * ) ; template void PointMovementGenerator < Creature > :: DoFinalize ( Creature * ) ; template void PointMovementGenerator < Player > :: DoReset ( Player * ) ; template void PointMovementGenerator < Creature > :: DoReset ( Creature * ) ; template bool PointMovementGenerator < Player > :: DoUpdate ( Player * , uint32 ) ; template bool PointMovementGenerator < Creature > :: DoUpdate ( Creature * , uint32 ) ; void AssistanceMovementGenerator :: Finalize ( Unit * unit ) { unit -> ToCreature ( ) -> SetNoCallAssistance ( false ) ; unit -> ToCreature ( ) -> CallAssistance ( ) ; if ( unit -> isAlive ( ) ) unit -> GetMotionMaster ( ) -> MoveSeekAssistanceDistract ( sWorld -> getIntConfig ( CONFIG_CREATURE_FAMILY_ASSISTANCE_DELAY ) ) ; } bool EffectMovementGenerator :: Update ( Unit * unit , uint32 ) { return ! unit -> movespline -> Finalized ( ) ; } void EffectMovementGenerator :: Finalize ( Unit * unit ) { if ( unit -> GetTypeId ( ) != TYPEID_UNIT ) return ; if ( unit -> isAlive ( ) && ! unit -> HasUnitState ( UNIT_STATE_CONFUSED | UNIT_STATE_FLEEING ) ) { if ( Unit * victim = unit -> getVictim ( ) ) unit -> GetMotionMaster ( ) -> MoveChase ( victim ) ; else unit -> GetMotionMaster ( ) -> Initialize ( ) ; } if ( unit -> ToCreature ( ) -> AI ( ) ) unit -> ToCreature ( ) -> AI ( ) -> MovementInform ( EFFECT_MOTION_TYPE , m_Id ) ; } </DOCUMENT>
<DOCUMENT_ID="shliujing/TeamTalk/tree/master/server/src/db_proxy_server/business/UserAction.cpp"> # include < list > # include < map > # include " . . / ProxyConn . h " # include " . . / DBPool . h " # include " . . / SyncCenter . h " # include " public _ define . h " # include " UserModel . h " # include " IM . Login . pb . h " # include " IM . Buddy . pb . h " # include " IM . BaseDefine . pb . h " namespace DB_PROXY { void getUserInfo ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMUsersInfoReq msg ; IM :: Buddy :: IMUsersInfoRsp msgResp ; if ( msg . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { CImPdu * pPduRes = new CImPdu ; uint32_t from_user_id = msg . user_id ( ) ; uint32_t userCount = msg . user_id_list_size ( ) ; std :: list < uint32_t > idList ; for ( uint32_t i = 0 ; i < userCount ; ++ i ) { idList . push_back ( msg . user_id_list ( i ) ) ; } std :: list < IM :: BaseDefine :: UserInfo > lsUser ; CUserModel :: getInstance ( ) -> getUsers ( idList , lsUser ) ; msgResp . set_user_id ( from_user_id ) ; for ( list < IM :: BaseDefine :: UserInfo > :: iterator it = lsUser . begin ( ) ; it != lsUser . end ( ) ; ++ it ) { IM :: BaseDefine :: UserInfo * pUser = msgResp . add_user_info_list ( ) ; pUser -> set_user_id ( it -> user_id ( ) ) ; pUser -> set_user_gender ( it -> user_gender ( ) ) ; pUser -> set_user_nick_name ( it -> user_nick_name ( ) ) ; pUser -> set_avatar_url ( it -> avatar_url ( ) ) ; pUser -> set_sign_info ( it -> sign_info ( ) ) ; pUser -> set_department_id ( it -> department_id ( ) ) ; pUser -> set_email ( it -> email ( ) ) ; pUser -> set_user_real_name ( it -> user_real_name ( ) ) ; pUser -> set_user_tel ( it -> user_tel ( ) ) ; pUser -> set_user_domain ( it -> user_domain ( ) ) ; pUser -> set_status ( it -> status ( ) ) ; } log ( " userId = % u , ▁ userCnt = % u " , from_user_id , userCount ) ; msgResp . set_attach_data ( msg . attach_data ( ) ) ; pPduRes -> SetPBMsg ( & msgResp ) ; pPduRes -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pPduRes -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pPduRes -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_USER_INFO_RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pPduRes ) ; } else { log ( " parse ▁ pb ▁ failed " ) ; } } void getChangedUser ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMAllUserReq msg ; IM :: Buddy :: IMAllUserRsp msgResp ; if ( msg . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { CImPdu * pPduRes = new CImPdu ; uint32_t nReqId = msg . user_id ( ) ; uint32_t nLastTime = msg . latest_update_time ( ) ; uint32_t nLastUpdate = CSyncCenter :: getInstance ( ) -> getLastUpdate ( ) ; list < IM :: BaseDefine :: UserInfo > lsUsers ; if ( nLastUpdate > nLastTime ) { list < uint32_t > lsIds ; CUserModel :: getInstance ( ) -> getChangedId ( nLastTime , lsIds ) ; CUserModel :: getInstance ( ) -> getUsers ( lsIds , lsUsers ) ; } msgResp . set_user_id ( nReqId ) ; msgResp . set_latest_update_time ( nLastTime ) ; for ( list < IM :: BaseDefine :: UserInfo > :: iterator it = lsUsers . begin ( ) ; it != lsUsers . end ( ) ; ++ it ) { IM :: BaseDefine :: UserInfo * pUser = msgResp . add_user_list ( ) ; pUser -> set_user_id ( it -> user_id ( ) ) ; pUser -> set_user_gender ( it -> user_gender ( ) ) ; pUser -> set_user_nick_name ( it -> user_nick_name ( ) ) ; pUser -> set_avatar_url ( it -> avatar_url ( ) ) ; pUser -> set_sign_info ( it -> sign_info ( ) ) ; pUser -> set_department_id ( it -> department_id ( ) ) ; pUser -> set_email ( it -> email ( ) ) ; pUser -> set_user_real_name ( it -> user_real_name ( ) ) ; pUser -> set_user_tel ( it -> user_tel ( ) ) ; pUser -> set_user_domain ( it -> user_domain ( ) ) ; pUser -> set_status ( it -> status ( ) ) ; } log ( " userId = % u , nLastUpdate = % u , ▁ last _ time = % u , ▁ userCnt = % u " , nReqId , nLastUpdate , nLastTime , msgResp . user_list_size ( ) ) ; msgResp . set_attach_data ( msg . attach_data ( ) ) ; pPduRes -> SetPBMsg ( & msgResp ) ; pPduRes -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pPduRes -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pPduRes -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_ALL_USER_RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pPduRes ) ; } else { log ( " parse ▁ pb ▁ failed " ) ; } } void changeUserSignInfo ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMChangeSignInfoReq req ; IM :: Buddy :: IMChangeSignInfoRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; const string & sign_info = req . sign_info ( ) ; bool result = CUserModel :: getInstance ( ) -> updateUserSignInfo ( user_id , sign_info ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_sign_info ( sign_info ) ; log ( " changeUserSignInfo ▁ sucess , ▁ user _ id = % u , ▁ sign _ info = % s " , user_id , sign_info . c_str ( ) ) ; } else { log ( " changeUserSignInfo ▁ false , ▁ user _ id = % u , ▁ sign _ info = % s " , user_id , sign_info . c_str ( ) ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " changeUserSignInfo : ▁ IMChangeSignInfoReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } } void doPushShield ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Login :: IMPushShieldReq req ; IM :: Login :: IMPushShieldRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; uint32_t shield_status = req . shield_status ( ) ; bool result = CUserModel :: getInstance ( ) -> updatePushShield ( user_id , shield_status ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_shield_status ( shield_status ) ; log ( " doPushShield ▁ sucess , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } else { log ( " doPushShield ▁ false , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_LOGIN ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_LOGIN_RES_PUSH_SHIELD ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " doPushShield : ▁ IMPushShieldReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } } void doQueryPushShield ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Login :: IMQueryPushShieldReq req ; IM :: Login :: IMQueryPushShieldRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; uint32_t shield_status = 0 ; bool result = CUserModel :: getInstance ( ) -> getPushShield ( user_id , & shield_status ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_shield_status ( shield_status ) ; log ( " doQueryPushShield ▁ sucess , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } else { log ( " doQueryPushShield ▁ false , ▁ user _ id = % u " , user_id ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_LOGIN ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_LOGIN_RES_QUERY_PUSH_SHIELD ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " doQueryPushShield : ▁ IMQueryPushShieldReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } } } ; </DOCUMENT>
<DOCUMENT_ID="AdmiralCurtiss/ppsspp/tree/master/unittest/UnitTest.cpp"> # include < cstdio > # include < cstdlib > # include < cmath > # include < string > # include < sstream > # include " base / NativeApp . h " # include " base / logging . h " # include " Common / CPUDetect . h " # include " Common / ArmEmitter . h " # include " ext / disarm . h " # include " math / math _ util . h " # include " util / text / parsers . h " # include " Core / Config . h " # include " Core / MIPS / MIPSVFPUUtils . h " # include " Core / FileSystems / ISOFileSystem . h " # include " unittest / JitHarness . h " # include " unittest / TestVertexJit . h " # include " unittest / UnitTest . h " std :: string System_GetProperty ( SystemProperty prop ) { return " " ; } int System_GetPropertyInt ( SystemProperty prop ) { return - 1 ; } void NativeMessageReceived ( const char * message , const char * value ) { } void GL_SwapInterval ( int ) { } # ifndef M_PI_2 # define M_PI_2 1.57079632679489661923 # endif float fastasin ( double x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; float sqrtthing = sqrt ( 1.0f - x * x ) ; float y = - .3572142480f + .1087063463f * x ; y = y * x + 1.062519236f ; y = y * x + - 2.511278506f ; y = y * x + .191900116f ; y = y * x + 1.807607311f ; y /= ( 1.807607311f - 1.615195094 * x ) ; return sign * ( y - sqrtthing ) ; } double atan_66s ( double x ) { const double c1 = 1.6867629106 ; const double c2 = 0.4378497304 ; const double c3 = 1.6867633134 ; double x2 ; x2 = x * x ; return ( x * ( c1 + x2 * c2 ) / ( c3 + x2 ) ) ; } double fastasin2 ( double x ) { return atan_66s ( x / sqrt ( 1 - x * x ) ) ; } float fastasin3 ( float x ) { return x + x * x * x * x * x * 0.4971 ; } float fastasin4 ( float x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; x = M_PI / 2 - sqrtf ( 1.0f - x ) * ( 1.5707288 + - 0.2121144 * x + 0.0742610 * x * x + - 0.0187293 * x * x * x ) ; return sign * x ; } float fastasin5 ( float x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; float fRoot = sqrtf ( 1.0f - x ) ; float fResult = 0.0742610f + - 0.0187293f * x ; fResult = - 0.2121144f + fResult * x ; fResult = 1.5707288f + fResult * x ; fResult = M_PI / 2 - fRoot * fResult ; return sign * fResult ; } # define C 0.70710678118654752440f # define BITSPERQUARTER ( 20 ) void fcs ( float angle , float & sinout , float & cosout ) { int phasein = angle * ( 1 << BITSPERQUARTER ) ; float modphase = ( phasein & ( ( 1 << BITSPERQUARTER ) - 1 ) ) * ( 1.0f / ( 1 << BITSPERQUARTER ) ) ; int quarter = phasein >> BITSPERQUARTER ; if ( ! quarter ) { float x = modphase - 0.5f ; float temp = ( 2 - 4 * C ) * x * x + C ; sinout = temp + x ; cosout = temp - x ; } else if ( quarter == 1 ) { float x = 0.5f - modphase ; float temp = ( 2 - 4 * C ) * x * x + C ; sinout = x + temp ; cosout = x - temp ; } else if ( quarter == 2 ) { float x = modphase - 0.5f ; float temp = ( 4 * C - 2 ) * x * x - C ; sinout = temp - x ; cosout = temp + x ; } else if ( quarter == 3 ) { float x = modphase - 0.5f ; float temp = ( 2 - 4 * C ) * x * x + C ; sinout = x - temp ; cosout = x + temp ; } } # undef C const float PI_SQR = 9.86960440108935861883449099987615114f ; void fcs2 ( float theta , float & outsine , float & outcosine ) { float gamma = theta + 1 ; gamma += 2 ; gamma /= 4 ; theta += 2 ; theta /= 4 ; theta -= floorf ( theta ) ; gamma -= floorf ( gamma ) ; theta *= 4 ; theta -= 2 ; gamma *= 4 ; gamma -= 2 ; float x = 2 * gamma - gamma * fabs ( gamma ) ; float y = 2 * theta - theta * fabs ( theta ) ; const float P = 0.225 ; outsine = P * ( y * fabsf ( y ) - y ) + y ; outcosine = P * ( x * fabsf ( x ) - x ) + x ; } void fastsincos ( float x , float & sine , float & cosine ) { fcs2 ( x , sine , cosine ) ; } bool TestSinCos ( ) { for ( int i = - 100 ; i <= 100 ; i ++ ) { float f = i / 30.0f ; float slowsin = sinf ( f * M_PI_2 ) , slowcos = cosf ( f * M_PI_2 ) ; float fastsin , fastcos ; fastsincos ( f , fastsin , fastcos ) ; printf ( " % f : ▁ slow : ▁ % 0.8f , ▁ % 0.8f ▁ fast : ▁ % 0.8f , ▁ % 0.8f \n " , f , slowsin , slowcos , fastsin , fastcos ) ; } return true ; } bool TestAsin ( ) { for ( int i = - 100 ; i <= 100 ; i ++ ) { float f = i / 100.0f ; float slowval = asinf ( f ) / M_PI_2 ; float fastval = fastasin5 ( f ) / M_PI_2 ; printf ( " slow : ▁ % 0.16f ▁ fast : ▁ % 0.16f \n " , slowval , fastval ) ; float diff = fabsf ( slowval - fastval ) ; } return true ; } bool TestMathUtil ( ) { EXPECT_FALSE ( my_isinf ( 1.0 ) ) ; volatile float zero = 0.0f ; EXPECT_TRUE ( my_isinf ( 1.0f / zero ) ) ; EXPECT_FALSE ( my_isnan ( 1.0f / zero ) ) ; return true ; } bool TestParsers ( ) { const char * macstr = "01:02:03 : ff : fe : fd " ; uint8_t mac [ 6 ] ; ParseMacAddress ( macstr , mac ) ; EXPECT_TRUE ( mac [ 0 ] == 1 ) ; EXPECT_TRUE ( mac [ 1 ] == 2 ) ; EXPECT_TRUE ( mac [ 2 ] == 3 ) ; EXPECT_TRUE ( mac [ 3 ] == 255 ) ; EXPECT_TRUE ( mac [ 4 ] == 254 ) ; EXPECT_TRUE ( mac [ 5 ] == 253 ) ; return true ; } bool TestVFPUSinCos ( ) { float sine , cosine ; vfpu_sincos ( 0.0f , sine , cosine ) ; EXPECT_EQ_FLOAT ( sine , 0.0f ) ; EXPECT_EQ_FLOAT ( cosine , 1.0f ) ; vfpu_sincos ( 1.0f , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , 1.0f ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , 0.0f ) ; vfpu_sincos ( 2.0f , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , 0.0f ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , - 1.0f ) ; vfpu_sincos ( 3.0f , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , - 1.0f ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , 0.0f ) ; vfpu_sincos ( 4.0f , sine , cosine ) ; EXPECT_EQ_FLOAT ( sine , 0.0f ) ; EXPECT_EQ_FLOAT ( cosine , 1.0f ) ; vfpu_sincos ( 5.0f , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , 1.0f ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , 0.0f ) ; for ( float angle = - 10.0f ; angle < 10.0f ; angle ++ ) { vfpu_sincos ( angle , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , sinf ( angle * M_PI_2 ) ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , cosf ( angle * M_PI_2 ) ) ; } return true ; } bool TestMatrixTranspose ( ) { MatrixSize sz = M_4x4 ; int matrix = 0 ; u8 cols [ 4 ] ; u8 rows [ 4 ] ; GetMatrixColumns ( matrix , sz , cols ) ; GetMatrixRows ( matrix , sz , rows ) ; int transposed = Xpose ( matrix ) ; u8 x_cols [ 4 ] ; u8 x_rows [ 4 ] ; GetMatrixColumns ( transposed , sz , x_cols ) ; GetMatrixRows ( transposed , sz , x_rows ) ; for ( int i = 0 ; i < GetMatrixSide ( sz ) ; i ++ ) { EXPECT_EQ_INT ( cols [ i ] , x_rows [ i ] ) ; EXPECT_EQ_INT ( x_cols [ i ] , rows [ i ] ) ; } return true ; } void TestGetMatrix ( int matrix , MatrixSize sz ) { ILOG ( " Testing ▁ matrix ▁ % s " , GetMatrixNotation ( matrix , sz ) ) ; u8 fullMatrix [ 16 ] ; u8 cols [ 4 ] ; u8 rows [ 4 ] ; GetMatrixColumns ( matrix , sz , cols ) ; GetMatrixRows ( matrix , sz , rows ) ; GetMatrixRegs ( fullMatrix , sz , matrix ) ; int n = GetMatrixSide ( sz ) ; VectorSize vsz = GetVectorSize ( sz ) ; for ( int i = 0 ; i < n ; i ++ ) { int colName = cols [ i ] ; int rowName = rows [ i ] ; ILOG ( " Column ▁ % i : ▁ % s " , i , GetVectorNotation ( colName , vsz ) ) ; ILOG ( " Row ▁ % i : ▁ % s " , i , GetVectorNotation ( rowName , vsz ) ) ; u8 colRegs [ 4 ] ; u8 rowRegs [ 4 ] ; GetVectorRegs ( colRegs , vsz , colName ) ; GetVectorRegs ( rowRegs , vsz , rowName ) ; std :: stringstream a , b , c , d ; for ( int j = 0 ; j < n ; j ++ ) { a . clear ( ) ; b . clear ( ) ; a << ( int ) fullMatrix [ i * 4 + j ] << " ▁ " ; b << ( int ) colRegs [ j ] << " ▁ " ; c . clear ( ) ; d . clear ( ) ; c << ( int ) fullMatrix [ j * 4 + i ] << " ▁ " ; d << ( int ) rowRegs [ j ] << " ▁ " ; } ILOG ( " Col : ▁ % s ▁ vs ▁ % s " , a . str ( ) . c_str ( ) , b . str ( ) . c_str ( ) ) ; if ( a . str ( ) != b . str ( ) ) ILOG ( " WRONG ! " ) ; ILOG ( " Row : ▁ % s ▁ vs ▁ % s " , c . str ( ) . c_str ( ) , d . str ( ) . c_str ( ) ) ; if ( c . str ( ) != d . str ( ) ) ILOG ( " WRONG ! " ) ; } } bool TestParseLBN ( ) { const char * validStrings [ ] = { " / sce _ lbn0x5fa0 _ size0x1428" , " / sce _ lbn7050 _ sizeee850" , " / sce _ lbn0x5eeeh _ size0x234x " , " / sce _ lbneee _ _ size434 . " , } ; int expectedResults [ ] [ 2 ] = { { 0x5fa0 , 0x1428 } , { 0x7050 , 0xee850 } , { 0x5eee , 0x234 } , { 0xeee , 0x434 } , } ; const char * invalidStrings [ ] = { " / sce _ lbn0x5fa0 _ sze0x1428" , " " , " // " , } ; for ( int i = 0 ; i < ARRAY_SIZE ( validStrings ) ; i ++ ) { u32 startSector = 0 , readSize = 0 ; EXPECT_TRUE ( parseLBN ( validStrings [ i ] , & startSector , & readSize ) ) ; EXPECT_EQ_INT ( startSector , expectedResults [ i ] [ 0 ] ) ; EXPECT_EQ_INT ( readSize , expectedResults [ i ] [ 1 ] ) ; } for ( int i = 0 ; i < ARRAY_SIZE ( invalidStrings ) ; i ++ ) { u32 startSector , readSize ; EXPECT_FALSE ( parseLBN ( invalidStrings [ i ] , & startSector , & readSize ) ) ; } return true ; } typedef bool ( * TestFunc ) ( ) ; struct TestItem { const char * name ; TestFunc func ; } ; # define TEST_ITEM ( name ) { # name , & Test ## name , } bool TestArmEmitter ( ) ; bool TestArm64Emitter ( ) ; bool TestX64Emitter ( ) ; TestItem availableTests [ ] = { # if defined ( ARM64 ) || defined ( _M_X64 ) || defined ( _M_IX86 ) TEST_ITEM ( Arm64Emitter ) , # endif # if defined ( ARM ) || defined ( _M_X64 ) || defined ( _M_IX86 ) TEST_ITEM ( ArmEmitter ) , # endif # if defined ( _M_X64 ) || defined ( _M_IX86 ) TEST_ITEM ( X64Emitter ) , # endif TEST_ITEM ( VertexJit ) , TEST_ITEM ( Asin ) , TEST_ITEM ( SinCos ) , TEST_ITEM ( VFPUSinCos ) , TEST_ITEM ( MathUtil ) , TEST_ITEM ( Parsers ) , TEST_ITEM ( Jit ) , TEST_ITEM ( MatrixTranspose ) , TEST_ITEM ( ParseLBN ) , } ; int main ( int argc , const char * argv [ ] ) { cpu_info . bNEON = true ; cpu_info . bVFP = true ; cpu_info . bVFPv3 = true ; cpu_info . bVFPv4 = true ; g_Config . bEnableLogging = true ; bool allTests = false ; TestFunc testFunc = nullptr ; if ( argc >= 2 ) { if ( ! strcasecmp ( argv [ 1 ] , " all " ) ) { allTests = true ; } for ( auto f : availableTests ) { if ( ! strcasecmp ( argv [ 1 ] , f . name ) ) { testFunc = f . func ; break ; } } } if ( allTests ) { int passes = 0 ; int fails = 0 ; for ( auto f : availableTests ) { if ( f . func ( ) ) { ++ passes ; } else { printf ( " % s : ▁ FAILED \n " , f . name ) ; ++ fails ; } } if ( passes > 0 ) { printf ( " % d ▁ tests ▁ passed . \n " , passes ) ; } if ( fails > 0 ) { return 2 ; } } else if ( testFunc == nullptr ) { fprintf ( stderr , " You ▁ may ▁ select ▁ a ▁ test ▁ to ▁ run ▁ by ▁ passing ▁ an ▁ argument . \n " ) ; fprintf ( stderr , " \n " ) ; fprintf ( stderr , " Available ▁ tests : \n " ) ; for ( auto f : availableTests ) { fprintf ( stderr , " ▁ ▁ * ▁ % s \n " , f . name ) ; } return 1 ; } else { if ( ! testFunc ( ) ) { return 2 ; } } return 0 ; } </DOCUMENT>
<DOCUMENT_ID="Maximus-/WinObjC/tree/master/deps/3rdparty/icu/icu/source/layout/TibetanReordering.cpp"> # include " LETypes . h " # include " OpenTypeTables . h " # include " TibetanReordering . h " # include " LEGlyphStorage . h " U_NAMESPACE_BEGIN enum { C_DOTTED_CIRCLE = 0x25CC , C_PRE_NUMBER_MARK = 0x0F3F } ; enum { _xx = TibetanClassTable :: CC_RESERVED , _ba = TibetanClassTable :: CC_BASE , _sj = TibetanClassTable :: CC_SUBJOINED | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _tp = TibetanClassTable :: CC_TSA_PHRU | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _ac = TibetanClassTable :: CC_A_CHUNG | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _cs = TibetanClassTable :: CC_COMP_SANSKRIT | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _ha = TibetanClassTable :: CC_HALANTA | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _bv = TibetanClassTable :: CC_BELOW_VOWEL | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _av = TibetanClassTable :: CC_ABOVE_VOWEL | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _an = TibetanClassTable :: CC_ANUSVARA | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _cb = TibetanClassTable :: CC_CANDRABINDU | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _vs = TibetanClassTable :: CC_VISARGA | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_AFTER , _as = TibetanClassTable :: CC_ABOVE_S_MARK | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _bs = TibetanClassTable :: CC_BELOW_S_MARK | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _di = TibetanClassTable :: CC_DIGIT | TibetanClassTable :: CF_DIGIT , _pd = TibetanClassTable :: CC_PRE_DIGIT_MARK | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_PREDIGIT | TibetanClassTable :: CF_POS_BEFORE , _bd = TibetanClassTable :: CC_POST_BELOW_DIGIT_M | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_AFTER } ; static const TibetanClassTable :: CharClass tibetanCharClasses [ ] = { _xx , _ba , _xx , _xx , _ba , _ba , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _bd , _bd , _xx , _xx , _xx , _xx , _xx , _xx , _di , _di , _di , _di , _di , _di , _di , _di , _di , _di , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _bs , _xx , _bs , _xx , _tp , _xx , _xx , _xx , _xx , _bd , _pd , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _xx , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _xx , _xx , _xx , _xx , _xx , _xx , _ac , _av , _cs , _bv , _bv , _cs , _cs , _cs , _cs , _av , _av , _av , _av , _an , _vs , _av , _cs , _cb , _cb , _ha , _xx , _as , _as , _ba , _ba , _ba , _ba , _xx , _xx , _xx , _xx , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _xx , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _xx , _sj , _sj , _xx , _xx , _xx , _xx , _xx , _xx , _bs , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , } ; static const TibetanClassTable tibetanClassTable = { 0x0F00 , 0x0FFF , tibetanCharClasses } ; TibetanClassTable :: CharClass TibetanClassTable :: getCharClass ( LEUnicode ch ) const { if ( ch < firstChar || ch > lastChar ) { return CC_RESERVED ; } return classTable [ ch - firstChar ] ; } const TibetanClassTable * TibetanClassTable :: getTibetanClassTable ( ) { return & tibetanClassTable ; } class TibetanReorderingOutput : public UMemory { private : le_int32 fSyllableCount ; le_int32 fOutIndex ; LEUnicode * fOutChars ; LEGlyphStorage & fGlyphStorage ; public : TibetanReorderingOutput ( LEUnicode * outChars , LEGlyphStorage & glyphStorage ) : fSyllableCount ( 0 ) , fOutIndex ( 0 ) , fOutChars ( outChars ) , fGlyphStorage ( glyphStorage ) { } ~ TibetanReorderingOutput ( ) { } void reset ( ) { fSyllableCount += 1 ; } void writeChar ( LEUnicode ch , le_uint32 charIndex , FeatureMask featureMask ) { LEErrorCode success = LE_NO_ERROR ; fOutChars [ fOutIndex ] = ch ; fGlyphStorage . setCharIndex ( fOutIndex , charIndex , success ) ; fGlyphStorage . setAuxData ( fOutIndex , featureMask , success ) ; fOutIndex += 1 ; } le_int32 getOutputIndex ( ) { return fOutIndex ; } } ; # define ccmpFeatureTag LE_CCMP_FEATURE_TAG # define blwfFeatureTag LE_BLWF_FEATURE_TAG # define pstfFeatureTag LE_PSTF_FEATURE_TAG # define presFeatureTag LE_PRES_FEATURE_TAG # define blwsFeatureTag LE_BLWS_FEATURE_TAG # define abvsFeatureTag LE_ABVS_FEATURE_TAG # define pstsFeatureTag LE_PSTS_FEATURE_TAG # define blwmFeatureTag LE_BLWM_FEATURE_TAG # define abvmFeatureTag LE_ABVM_FEATURE_TAG # define distFeatureTag LE_DIST_FEATURE_TAG # define prefFeatureTag LE_PREF_FEATURE_TAG # define abvfFeatureTag LE_ABVF_FEATURE_TAG # define cligFeatureTag LE_CLIG_FEATURE_TAG # define mkmkFeatureTag LE_MKMK_FEATURE_TAG # define prefFeatureMask 0x80000000UL # define blwfFeatureMask 0x40000000UL # define abvfFeatureMask 0x20000000UL # define pstfFeatureMask 0x10000000UL # define presFeatureMask 0x08000000UL # define blwsFeatureMask 0x04000000UL # define abvsFeatureMask 0x02000000UL # define pstsFeatureMask 0x01000000UL # define cligFeatureMask 0x00800000UL # define ccmpFeatureMask 0x00040000UL # define distFeatureMask 0x00400000UL # define blwmFeatureMask 0x00200000UL # define abvmFeatureMask 0x00100000UL # define mkmkFeatureMask 0x00080000UL # define tagPref ( ccmpFeatureMask | prefFeatureMask | presFeatureMask | cligFeatureMask | distFeatureMask ) # define tagAbvf ( ccmpFeatureMask | abvfFeatureMask | abvsFeatureMask | cligFeatureMask | distFeatureMask | abvmFeatureMask | mkmkFeatureMask ) # define tagPstf ( ccmpFeatureMask | blwfFeatureMask | blwsFeatureMask | prefFeatureMask | presFeatureMask | pstfFeatureMask | pstsFeatureMask | cligFeatureMask | distFeatureMask | blwmFeatureMask ) # define tagBlwf ( ccmpFeatureMask | blwfFeatureMask | blwsFeatureMask | cligFeatureMask | distFeatureMask | blwmFeatureMask | mkmkFeatureMask ) # define tagDefault ( ccmpFeatureMask | prefFeatureMask | blwfFeatureMask | presFeatureMask | blwsFeatureMask | cligFeatureMask | distFeatureMask | abvmFeatureMask | blwmFeatureMask | mkmkFeatureMask ) static const FeatureMap featureMap [ ] = { { ccmpFeatureTag , ccmpFeatureMask } , { prefFeatureTag , prefFeatureMask } , { blwfFeatureTag , blwfFeatureMask } , { abvfFeatureTag , abvfFeatureMask } , { pstfFeatureTag , pstfFeatureMask } , { presFeatureTag , presFeatureMask } , { blwsFeatureTag , blwsFeatureMask } , { abvsFeatureTag , abvsFeatureMask } , { pstsFeatureTag , pstsFeatureMask } , { cligFeatureTag , cligFeatureMask } , { distFeatureTag , distFeatureMask } , { blwmFeatureTag , blwmFeatureMask } , { abvmFeatureTag , abvmFeatureMask } , { mkmkFeatureTag , mkmkFeatureMask } , } ; static const le_int32 featureMapCount = LE_ARRAY_SIZE ( featureMap ) ; static const le_int8 tibetanStateTable [ ] [ TibetanClassTable :: CC_COUNT ] = { { 1 , 2 , 4 , 3 , 8 , 7 , 9 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , 20 , 21 , 21 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , 4 , 3 , 8 , 7 , 9 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , 5 , - 1 , 8 , 7 , - 1 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , 4 , 6 , 8 , 7 , 9 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , 5 , - 1 , 8 , 7 , - 1 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , 8 , 7 , - 1 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 14 , 13 , 17 , - 1 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 11 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 12 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 14 , 17 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 15 , 17 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 16 , 17 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 17 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 21 , 21 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , } , } ; const FeatureMap * TibetanReordering :: getFeatureMap ( le_int32 & count ) { count = featureMapCount ; return featureMap ; } le_int32 TibetanReordering :: findSyllable ( const TibetanClassTable * classTable , const LEUnicode * chars , le_int32 prev , le_int32 charCount ) { le_int32 cursor = prev ; le_int8 state = 0 ; while ( cursor < charCount ) { TibetanClassTable :: CharClass charClass = ( classTable -> getCharClass ( chars [ cursor ] ) & TibetanClassTable :: CF_CLASS_MASK ) ; state = tibetanStateTable [ state ] [ charClass ] ; if ( state < 0 ) { break ; } cursor += 1 ; } return cursor ; } le_int32 TibetanReordering :: reorder ( const LEUnicode * chars , le_int32 charCount , le_int32 , LEUnicode * outChars , LEGlyphStorage & glyphStorage ) { const TibetanClassTable * classTable = TibetanClassTable :: getTibetanClassTable ( ) ; TibetanReorderingOutput output ( outChars , glyphStorage ) ; TibetanClassTable :: CharClass charClass ; le_int32 i , prev = 0 ; while ( prev < charCount ) { le_int32 syllable = findSyllable ( classTable , chars , prev , charCount ) ; output . reset ( ) ; if ( classTable -> getCharClass ( chars [ prev ] ) & TibetanClassTable :: CF_DOTTED_CIRCLE ) { output . writeChar ( C_DOTTED_CIRCLE , prev , tagDefault ) ; } for ( i = prev ; i < syllable ; i += 1 ) { charClass = classTable -> getCharClass ( chars [ i ] ) ; if ( ( TibetanClassTable :: CF_DIGIT & charClass ) && ( classTable -> getCharClass ( chars [ i + 1 ] ) & TibetanClassTable :: CF_PREDIGIT ) ) { output . writeChar ( C_PRE_NUMBER_MARK , i , tagPref ) ; output . writeChar ( chars [ i ] , i + 1 , tagPref ) ; i += 1 ; } else { switch ( charClass & TibetanClassTable :: CF_POS_MASK ) { case TibetanClassTable :: CF_POS_ABOVE : output . writeChar ( chars [ i ] , i , tagAbvf ) ; break ; case TibetanClassTable :: CF_POS_AFTER : output . writeChar ( chars [ i ] , i , tagPstf ) ; break ; case TibetanClassTable :: CF_POS_BELOW : output . writeChar ( chars [ i ] , i , tagBlwf ) ; break ; default : output . writeChar ( chars [ i ] , i , tagDefault ) ; break ; } } } prev = syllable ; } return output . getOutputIndex ( ) ; } U_NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="asmaurya95/My-ACM-ICPC-Handbook/tree/master/Suffix Array/Naive Implementation.cpp"> # include < iostream > # include < string > # include < map > # include < algorithm > # include < vector > using namespace std ; int main ( ) { string s ; cin >> s ; map < string , int > m ; vector < string > ar ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { string sstr = s . substr ( i , s . size ( ) - i ) ; m [ sstr ] = i ; ar . push_back ( sstr ) ; } sort ( ar . begin ( ) , ar . end ( ) ) ; for ( int i = 0 ; i < ar . size ( ) ; i ++ ) { cout << m [ ar [ i ] ] << endl ; } return 0 ; } </DOCUMENT>
<DOCUMENT_ID="ThomasLee969/video_classifier/tree/master/workspace/mexopencv/src/+cv/cornerHarris.cpp"> # include " mexopencv . hpp " using namespace std ; using namespace cv ; void mexFunction ( int nlhs , mxArray * plhs [ ] , int nrhs , const mxArray * prhs [ ] ) { nargchk ( nrhs >= 1 && ( nrhs % 2 ) == 1 && nlhs <= 1 ) ; vector < MxArray > rhs ( prhs , prhs + nrhs ) ; int blockSize = 5 ; int ksize = 3 ; double k = 0.04 ; int borderType = cv :: BORDER_DEFAULT ; for ( int i = 1 ; i < nrhs ; i += 2 ) { string key ( rhs [ i ] . toString ( ) ) ; if ( key == " BlockSize " ) blockSize = rhs [ i + 1 ] . toInt ( ) ; else if ( key == " KSize " ) ksize = rhs [ i + 1 ] . toInt ( ) ; else if ( key == " K " ) k = rhs [ i + 1 ] . toDouble ( ) ; else if ( key == " BorderType " ) borderType = BorderType [ rhs [ i + 1 ] . toString ( ) ] ; else mexErrMsgIdAndTxt ( " mexopencv : error " , " Unrecognized ▁ option " ) ; } Mat src ( rhs [ 0 ] . toMat ( rhs [ 0 ] . isUint8 ( ) ? CV_8U : CV_32F ) ) , dst ; cornerHarris ( src , dst , blockSize , ksize , k , borderType ) ; plhs [ 0 ] = MxArray ( dst ) ; } </DOCUMENT>
<DOCUMENT_ID="omazapa/root-old/tree/master/interpreter/llvm/src/lib/CodeGen/MachineSSAUpdater.cpp"> # include " llvm / CodeGen / MachineSSAUpdater . h " # include " llvm / ADT / DenseMap . h " # include " llvm / ADT / SmallVector . h " # include " llvm / CodeGen / MachineInstr . h " # include " llvm / CodeGen / MachineInstrBuilder . h " # include " llvm / CodeGen / MachineRegisterInfo . h " # include " llvm / Support / AlignOf . h " # include " llvm / Support / Allocator . h " # include " llvm / Support / Debug . h " # include " llvm / Support / ErrorHandling . h " # include " llvm / Support / raw _ ostream . h " # include " llvm / Target / TargetInstrInfo . h " # include " llvm / Target / TargetRegisterInfo . h " # include " llvm / Target / TargetSubtargetInfo . h " # include " llvm / Transforms / Utils / SSAUpdaterImpl . h " using namespace llvm ; # define DEBUG_TYPE " machine - ssaupdater " typedef DenseMap < MachineBasicBlock * , unsigned > AvailableValsTy ; static AvailableValsTy & getAvailableVals ( void * AV ) { return * static_cast < AvailableValsTy * > ( AV ) ; } MachineSSAUpdater :: MachineSSAUpdater ( MachineFunction & MF , SmallVectorImpl < MachineInstr * > * NewPHI ) : AV ( nullptr ) , InsertedPHIs ( NewPHI ) { TII = MF . getSubtarget ( ) . getInstrInfo ( ) ; MRI = & MF . getRegInfo ( ) ; } MachineSSAUpdater :: ~ MachineSSAUpdater ( ) { delete static_cast < AvailableValsTy * > ( AV ) ; } void MachineSSAUpdater :: Initialize ( unsigned V ) { if ( ! AV ) AV = new AvailableValsTy ( ) ; else getAvailableVals ( AV ) . clear ( ) ; VR = V ; VRC = MRI -> getRegClass ( VR ) ; } bool MachineSSAUpdater :: HasValueForBlock ( MachineBasicBlock * BB ) const { return getAvailableVals ( AV ) . count ( BB ) ; } void MachineSSAUpdater :: AddAvailableValue ( MachineBasicBlock * BB , unsigned V ) { getAvailableVals ( AV ) [ BB ] = V ; } unsigned MachineSSAUpdater :: GetValueAtEndOfBlock ( MachineBasicBlock * BB ) { return GetValueAtEndOfBlockInternal ( BB ) ; } static unsigned LookForIdenticalPHI ( MachineBasicBlock * BB , SmallVectorImpl < std :: pair < MachineBasicBlock * , unsigned > > & PredValues ) { if ( BB -> empty ( ) ) return 0 ; MachineBasicBlock :: iterator I = BB -> begin ( ) ; if ( ! I -> isPHI ( ) ) return 0 ; AvailableValsTy AVals ; for ( unsigned i = 0 , e = PredValues . size ( ) ; i != e ; ++ i ) AVals [ PredValues [ i ] . first ] = PredValues [ i ] . second ; while ( I != BB -> end ( ) && I -> isPHI ( ) ) { bool Same = true ; for ( unsigned i = 1 , e = I -> getNumOperands ( ) ; i != e ; i += 2 ) { unsigned SrcReg = I -> getOperand ( i ) . getReg ( ) ; MachineBasicBlock * SrcBB = I -> getOperand ( i + 1 ) . getMBB ( ) ; if ( AVals [ SrcBB ] != SrcReg ) { Same = false ; break ; } } if ( Same ) return I -> getOperand ( 0 ) . getReg ( ) ; ++ I ; } return 0 ; } static MachineInstrBuilder InsertNewDef ( unsigned Opcode , MachineBasicBlock * BB , MachineBasicBlock :: iterator I , const TargetRegisterClass * RC , MachineRegisterInfo * MRI , const TargetInstrInfo * TII ) { unsigned NewVR = MRI -> createVirtualRegister ( RC ) ; return BuildMI ( * BB , I , DebugLoc ( ) , TII -> get ( Opcode ) , NewVR ) ; } unsigned MachineSSAUpdater :: GetValueInMiddleOfBlock ( MachineBasicBlock * BB ) { if ( ! HasValueForBlock ( BB ) ) return GetValueAtEndOfBlockInternal ( BB ) ; if ( BB -> pred_empty ( ) ) { MachineInstr * NewDef = InsertNewDef ( TargetOpcode :: IMPLICIT_DEF , BB , BB -> getFirstTerminator ( ) , VRC , MRI , TII ) ; return NewDef -> getOperand ( 0 ) . getReg ( ) ; } SmallVector < std :: pair < MachineBasicBlock * , unsigned > , 8 > PredValues ; unsigned SingularValue = 0 ; bool isFirstPred = true ; for ( MachineBasicBlock :: pred_iterator PI = BB -> pred_begin ( ) , E = BB -> pred_end ( ) ; PI != E ; ++ PI ) { MachineBasicBlock * PredBB = * PI ; unsigned PredVal = GetValueAtEndOfBlockInternal ( PredBB ) ; PredValues . push_back ( std :: make_pair ( PredBB , PredVal ) ) ; if ( isFirstPred ) { SingularValue = PredVal ; isFirstPred = false ; } else if ( PredVal != SingularValue ) SingularValue = 0 ; } if ( SingularValue != 0 ) return SingularValue ; unsigned DupPHI = LookForIdenticalPHI ( BB , PredValues ) ; if ( DupPHI ) return DupPHI ; MachineBasicBlock :: iterator Loc = BB -> empty ( ) ? BB -> end ( ) : BB -> begin ( ) ; MachineInstrBuilder InsertedPHI = InsertNewDef ( TargetOpcode :: PHI , BB , Loc , VRC , MRI , TII ) ; for ( unsigned i = 0 , e = PredValues . size ( ) ; i != e ; ++ i ) InsertedPHI . addReg ( PredValues [ i ] . second ) . addMBB ( PredValues [ i ] . first ) ; if ( unsigned ConstVal = InsertedPHI -> isConstantValuePHI ( ) ) { InsertedPHI -> eraseFromParent ( ) ; return ConstVal ; } if ( InsertedPHIs ) InsertedPHIs -> push_back ( InsertedPHI ) ; DEBUG ( dbgs ( ) << " ▁ ▁ Inserted ▁ PHI : ▁ " << * InsertedPHI << " \n " ) ; return InsertedPHI -> getOperand ( 0 ) . getReg ( ) ; } static MachineBasicBlock * findCorrespondingPred ( const MachineInstr * MI , MachineOperand * U ) { for ( unsigned i = 1 , e = MI -> getNumOperands ( ) ; i != e ; i += 2 ) { if ( & MI -> getOperand ( i ) == U ) return MI -> getOperand ( i + 1 ) . getMBB ( ) ; } llvm_unreachable ( " MachineOperand : : getParent ( ) ▁ failure ? " ) ; } void MachineSSAUpdater :: RewriteUse ( MachineOperand & U ) { MachineInstr * UseMI = U . getParent ( ) ; unsigned NewVR = 0 ; if ( UseMI -> isPHI ( ) ) { MachineBasicBlock * SourceBB = findCorrespondingPred ( UseMI , & U ) ; NewVR = GetValueAtEndOfBlockInternal ( SourceBB ) ; } else { NewVR = GetValueInMiddleOfBlock ( UseMI -> getParent ( ) ) ; } U . setReg ( NewVR ) ; } namespace llvm { template < > class SSAUpdaterTraits < MachineSSAUpdater > { public : typedef MachineBasicBlock BlkT ; typedef unsigned ValT ; typedef MachineInstr PhiT ; typedef MachineBasicBlock :: succ_iterator BlkSucc_iterator ; static BlkSucc_iterator BlkSucc_begin ( BlkT * BB ) { return BB -> succ_begin ( ) ; } static BlkSucc_iterator BlkSucc_end ( BlkT * BB ) { return BB -> succ_end ( ) ; } class PHI_iterator { private : MachineInstr * PHI ; unsigned idx ; public : explicit PHI_iterator ( MachineInstr * P ) : PHI ( P ) , idx ( 1 ) { } PHI_iterator ( MachineInstr * P , bool ) : PHI ( P ) , idx ( PHI -> getNumOperands ( ) ) { } PHI_iterator & operator ++ ( ) { idx += 2 ; return * this ; } bool operator == ( const PHI_iterator & x ) const { return idx == x . idx ; } bool operator != ( const PHI_iterator & x ) const { return ! operator == ( x ) ; } unsigned getIncomingValue ( ) { return PHI -> getOperand ( idx ) . getReg ( ) ; } MachineBasicBlock * getIncomingBlock ( ) { return PHI -> getOperand ( idx + 1 ) . getMBB ( ) ; } } ; static inline PHI_iterator PHI_begin ( PhiT * PHI ) { return PHI_iterator ( PHI ) ; } static inline PHI_iterator PHI_end ( PhiT * PHI ) { return PHI_iterator ( PHI , true ) ; } static void FindPredecessorBlocks ( MachineBasicBlock * BB , SmallVectorImpl < MachineBasicBlock * > * Preds ) { for ( MachineBasicBlock :: pred_iterator PI = BB -> pred_begin ( ) , E = BB -> pred_end ( ) ; PI != E ; ++ PI ) Preds -> push_back ( * PI ) ; } static unsigned GetUndefVal ( MachineBasicBlock * BB , MachineSSAUpdater * Updater ) { MachineInstr * NewDef = InsertNewDef ( TargetOpcode :: IMPLICIT_DEF , BB , BB -> getFirstTerminator ( ) , Updater -> VRC , Updater -> MRI , Updater -> TII ) ; return NewDef -> getOperand ( 0 ) . getReg ( ) ; } static unsigned CreateEmptyPHI ( MachineBasicBlock * BB , unsigned NumPreds , MachineSSAUpdater * Updater ) { MachineBasicBlock :: iterator Loc = BB -> empty ( ) ? BB -> end ( ) : BB -> begin ( ) ; MachineInstr * PHI = InsertNewDef ( TargetOpcode :: PHI , BB , Loc , Updater -> VRC , Updater -> MRI , Updater -> TII ) ; return PHI -> getOperand ( 0 ) . getReg ( ) ; } static void AddPHIOperand ( MachineInstr * PHI , unsigned Val , MachineBasicBlock * Pred ) { MachineInstrBuilder ( * Pred -> getParent ( ) , PHI ) . addReg ( Val ) . addMBB ( Pred ) ; } static MachineInstr * InstrIsPHI ( MachineInstr * I ) { if ( I && I -> isPHI ( ) ) return I ; return nullptr ; } static MachineInstr * ValueIsPHI ( unsigned Val , MachineSSAUpdater * Updater ) { return InstrIsPHI ( Updater -> MRI -> getVRegDef ( Val ) ) ; } static MachineInstr * ValueIsNewPHI ( unsigned Val , MachineSSAUpdater * Updater ) { MachineInstr * PHI = ValueIsPHI ( Val , Updater ) ; if ( PHI && PHI -> getNumOperands ( ) <= 1 ) return PHI ; return nullptr ; } static unsigned GetPHIValue ( MachineInstr * PHI ) { return PHI -> getOperand ( 0 ) . getReg ( ) ; } } ; } unsigned MachineSSAUpdater :: GetValueAtEndOfBlockInternal ( MachineBasicBlock * BB ) { AvailableValsTy & AvailableVals = getAvailableVals ( AV ) ; if ( unsigned V = AvailableVals [ BB ] ) return V ; SSAUpdaterImpl < MachineSSAUpdater > Impl ( this , & AvailableVals , InsertedPHIs ) ; return Impl . GetValue ( BB ) ; } </DOCUMENT>
<DOCUMENT_ID="alessonrenato/TrinityCore/tree/master/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp"> # include " BattlegroundAB . h " # include " WorldPacket . h " # include " BattlegroundMgr . h " # include " Creature . h " # include " Language . h " # include " Player . h " # include " Util . h " # include " WorldSession . h " BattlegroundAB :: BattlegroundAB ( ) { m_IsInformedNearVictory = false ; m_BuffChange = true ; BgObjects . resize ( BG_AB_OBJECT_MAX ) ; BgCreatures . resize ( BG_AB_ALL_NODES_COUNT + 5 ) ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { m_Nodes [ i ] = 0 ; m_prevNodes [ i ] = 0 ; m_NodeTimers [ i ] = 0 ; m_BannerTimers [ i ] . timer = 0 ; m_BannerTimers [ i ] . type = 0 ; m_BannerTimers [ i ] . teamIndex = 0 ; } for ( uint8 i = 0 ; i < BG_TEAMS_COUNT ; ++ i ) { m_lastTick [ i ] = 0 ; m_HonorScoreTics [ i ] = 0 ; m_ReputationScoreTics [ i ] = 0 ; m_TeamScores500Disadvantage [ i ] = false ; } m_HonorTics = 0 ; m_ReputationTics = 0 ; StartMessageIds [ BG_STARTING_EVENT_FIRST ] = LANG_BG_AB_START_TWO_MINUTES ; StartMessageIds [ BG_STARTING_EVENT_SECOND ] = LANG_BG_AB_START_ONE_MINUTE ; StartMessageIds [ BG_STARTING_EVENT_THIRD ] = LANG_BG_AB_START_HALF_MINUTE ; StartMessageIds [ BG_STARTING_EVENT_FOURTH ] = LANG_BG_AB_HAS_BEGUN ; } BattlegroundAB :: ~ BattlegroundAB ( ) { } void BattlegroundAB :: PostUpdateImpl ( uint32 diff ) { if ( GetStatus ( ) == STATUS_IN_PROGRESS ) { int team_points [ BG_TEAMS_COUNT ] = { 0 , 0 } ; for ( int node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) { if ( m_BannerTimers [ node ] . timer ) { if ( m_BannerTimers [ node ] . timer > diff ) m_BannerTimers [ node ] . timer -= diff ; else { m_BannerTimers [ node ] . timer = 0 ; _CreateBanner ( node , m_BannerTimers [ node ] . type , m_BannerTimers [ node ] . teamIndex , false ) ; } } if ( m_NodeTimers [ node ] ) { if ( m_NodeTimers [ node ] > diff ) m_NodeTimers [ node ] -= diff ; else { m_NodeTimers [ node ] = 0 ; uint8 teamIndex = m_Nodes [ node ] - 1 ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] += 2 ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; _NodeOccupied ( node , ( teamIndex == 0 ) ? ALLIANCE : HORDE ) ; if ( teamIndex == 0 ) { SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_ALLIANCE , NULL , LANG_BG_AB_ALLY , _GetNodeNameId ( node ) ) ; PlaySoundToAll ( BG_AB_SOUND_NODE_CAPTURED_ALLIANCE ) ; } else { SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_HORDE , NULL , LANG_BG_AB_HORDE , _GetNodeNameId ( node ) ) ; PlaySoundToAll ( BG_AB_SOUND_NODE_CAPTURED_HORDE ) ; } } } for ( int team = 0 ; team < BG_TEAMS_COUNT ; ++ team ) if ( m_Nodes [ node ] == team + BG_AB_NODE_TYPE_OCCUPIED ) ++ team_points [ team ] ; } for ( int team = 0 ; team < BG_TEAMS_COUNT ; ++ team ) { int points = team_points [ team ] ; if ( ! points ) continue ; m_lastTick [ team ] += diff ; if ( m_lastTick [ team ] > BG_AB_TickIntervals [ points ] ) { m_lastTick [ team ] -= BG_AB_TickIntervals [ points ] ; m_TeamScores [ team ] += BG_AB_TickPoints [ points ] ; m_HonorScoreTics [ team ] += BG_AB_TickPoints [ points ] ; m_ReputationScoreTics [ team ] += BG_AB_TickPoints [ points ] ; if ( m_ReputationScoreTics [ team ] >= m_ReputationTics ) { ( team == TEAM_ALLIANCE ) ? RewardReputationToTeam ( 509 , 10 , ALLIANCE ) : RewardReputationToTeam ( 510 , 10 , HORDE ) ; m_ReputationScoreTics [ team ] -= m_ReputationTics ; } if ( m_HonorScoreTics [ team ] >= m_HonorTics ) { RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ( team == TEAM_ALLIANCE ) ? ALLIANCE : HORDE ) ; m_HonorScoreTics [ team ] -= m_HonorTics ; } if ( ! m_IsInformedNearVictory && m_TeamScores [ team ] > BG_AB_WARNING_NEAR_VICTORY_SCORE ) { if ( team == TEAM_ALLIANCE ) SendMessageToAll ( LANG_BG_AB_A_NEAR_VICTORY , CHAT_MSG_BG_SYSTEM_NEUTRAL ) ; else SendMessageToAll ( LANG_BG_AB_H_NEAR_VICTORY , CHAT_MSG_BG_SYSTEM_NEUTRAL ) ; PlaySoundToAll ( BG_AB_SOUND_NEAR_VICTORY ) ; m_IsInformedNearVictory = true ; } if ( m_TeamScores [ team ] > BG_AB_MAX_TEAM_SCORE ) m_TeamScores [ team ] = BG_AB_MAX_TEAM_SCORE ; if ( team == TEAM_ALLIANCE ) UpdateWorldState ( BG_AB_OP_RESOURCES_ALLY , m_TeamScores [ team ] ) ; else if ( team == TEAM_HORDE ) UpdateWorldState ( BG_AB_OP_RESOURCES_HORDE , m_TeamScores [ team ] ) ; uint8 otherTeam = ( team + 1 ) % BG_TEAMS_COUNT ; if ( m_TeamScores [ team ] > m_TeamScores [ otherTeam ] + 500 ) m_TeamScores500Disadvantage [ otherTeam ] = true ; } } if ( m_TeamScores [ TEAM_ALLIANCE ] >= BG_AB_MAX_TEAM_SCORE ) EndBattleground ( ALLIANCE ) ; else if ( m_TeamScores [ TEAM_HORDE ] >= BG_AB_MAX_TEAM_SCORE ) EndBattleground ( HORDE ) ; } } void BattlegroundAB :: StartingEventCloseDoors ( ) { for ( int obj = BG_AB_OBJECT_BANNER_NEUTRAL ; obj < BG_AB_DYNAMIC_NODES_COUNT * 8 ; ++ obj ) SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT * 3 ; ++ i ) SpawnBGObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + i , RESPAWN_ONE_DAY ) ; DoorClose ( BG_AB_OBJECT_GATE_A ) ; DoorClose ( BG_AB_OBJECT_GATE_H ) ; SpawnBGObject ( BG_AB_OBJECT_GATE_A , RESPAWN_IMMEDIATELY ) ; SpawnBGObject ( BG_AB_OBJECT_GATE_H , RESPAWN_IMMEDIATELY ) ; _NodeOccupied ( BG_AB_SPIRIT_ALIANCE , ALLIANCE ) ; _NodeOccupied ( BG_AB_SPIRIT_HORDE , HORDE ) ; } void BattlegroundAB :: StartingEventOpenDoors ( ) { for ( int banner = BG_AB_OBJECT_BANNER_NEUTRAL , i = 0 ; i < 5 ; banner += 8 , ++ i ) SpawnBGObject ( banner , RESPAWN_IMMEDIATELY ) ; for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { uint8 buff = urand ( 0 , 2 ) ; SpawnBGObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + buff + i * 3 , RESPAWN_IMMEDIATELY ) ; } DoorOpen ( BG_AB_OBJECT_GATE_A ) ; DoorOpen ( BG_AB_OBJECT_GATE_H ) ; StartTimedAchievement ( ACHIEVEMENT_TIMED_TYPE_EVENT , AB_EVENT_START_BATTLE ) ; } void BattlegroundAB :: AddPlayer ( Player * player ) { Battleground :: AddPlayer ( player ) ; PlayerScores [ player -> GetGUID ( ) ] = new BattlegroundABScore ( player -> GetGUID ( ) , player -> GetBGTeam ( ) ) ; } void BattlegroundAB :: RemovePlayer ( Player * , ObjectGuid , uint32 ) { } void BattlegroundAB :: HandleAreaTrigger ( Player * player , uint32 trigger , bool entered ) { if ( GetStatus ( ) != STATUS_IN_PROGRESS ) return ; switch ( trigger ) { case 3948 : if ( player -> GetTeam ( ) != ALLIANCE ) player -> GetSession ( ) -> SendNotification ( " Only ▁ The ▁ Alliance ▁ can ▁ use ▁ that ▁ portal " ) ; else player -> LeaveBattleground ( ) ; break ; case 3949 : if ( player -> GetTeam ( ) != HORDE ) player -> GetSession ( ) -> SendNotification ( " Only ▁ The ▁ Horde ▁ can ▁ use ▁ that ▁ portal " ) ; else player -> LeaveBattleground ( ) ; break ; case 3866 : case 3869 : case 3867 : case 3868 : case 3870 : case 4020 : case 4021 : case 4674 : default : Battleground :: HandleAreaTrigger ( player , trigger , entered ) ; break ; } } void BattlegroundAB :: _CreateBanner ( uint8 node , uint8 type , uint8 teamIndex , bool delay ) { if ( delay ) { m_BannerTimers [ node ] . timer = 2000 ; m_BannerTimers [ node ] . type = type ; m_BannerTimers [ node ] . teamIndex = teamIndex ; return ; } uint8 obj = node * 8 + type + teamIndex ; SpawnBGObject ( obj , RESPAWN_IMMEDIATELY ) ; if ( ! type ) return ; obj = node * 8 + ( ( type == BG_AB_NODE_TYPE_OCCUPIED ) ? ( 5 + teamIndex ) : 7 ) ; SpawnBGObject ( obj , RESPAWN_IMMEDIATELY ) ; } void BattlegroundAB :: _DelBanner ( uint8 node , uint8 type , uint8 teamIndex ) { uint8 obj = node * 8 + type + teamIndex ; SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; if ( ! type ) return ; obj = node * 8 + ( ( type == BG_AB_NODE_TYPE_OCCUPIED ) ? ( 5 + teamIndex ) : 7 ) ; SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; } int32 BattlegroundAB :: _GetNodeNameId ( uint8 node ) { switch ( node ) { case BG_AB_NODE_STABLES : return LANG_BG_AB_NODE_STABLES ; case BG_AB_NODE_BLACKSMITH : return LANG_BG_AB_NODE_BLACKSMITH ; case BG_AB_NODE_FARM : return LANG_BG_AB_NODE_FARM ; case BG_AB_NODE_LUMBER_MILL : return LANG_BG_AB_NODE_LUMBER_MILL ; case BG_AB_NODE_GOLD_MINE : return LANG_BG_AB_NODE_GOLD_MINE ; default : ABORT ( ) ; } return 0 ; } void BattlegroundAB :: FillInitialWorldStates ( WorldPackets :: WorldState :: InitWorldStates & packet ) { const uint8 plusArray [ ] = { 0 , 2 , 3 , 0 , 1 } ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_NODEICONS [ node ] ) , int32 ( ( m_Nodes [ node ] == 0 ) ? 1 : 0 ) ) ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) for ( uint8 i = 1 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_NODESTATES [ node ] + plusArray [ i ] ) , int32 ( ( m_Nodes [ node ] == i ) ? 1 : 0 ) ) ; uint8 ally = 0 , horde = 0 ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) if ( m_Nodes [ node ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ node ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_OCCUPIED_BASES_ALLY ) , int32 ( ally ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_OCCUPIED_BASES_HORDE ) , int32 ( horde ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_MAX ) , int32 ( BG_AB_MAX_TEAM_SCORE ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_WARNING ) , int32 ( BG_AB_WARNING_NEAR_VICTORY_SCORE ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_ALLY ) , int32 ( m_TeamScores [ TEAM_ALLIANCE ] ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_HORDE ) , int32 ( m_TeamScores [ TEAM_HORDE ] ) ) ; packet . Worldstates . emplace_back ( uint32 ( 0x745 ) , 0x2 ) ; } void BattlegroundAB :: _SendNodeUpdate ( uint8 node ) { const uint8 plusArray [ ] = { 0 , 2 , 3 , 0 , 1 } ; if ( m_prevNodes [ node ] ) UpdateWorldState ( BG_AB_OP_NODESTATES [ node ] + plusArray [ m_prevNodes [ node ] ] , 0 ) ; else UpdateWorldState ( BG_AB_OP_NODEICONS [ node ] , 0 ) ; UpdateWorldState ( BG_AB_OP_NODESTATES [ node ] + plusArray [ m_Nodes [ node ] ] , 1 ) ; uint8 ally = 0 , horde = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; UpdateWorldState ( BG_AB_OP_OCCUPIED_BASES_ALLY , ally ) ; UpdateWorldState ( BG_AB_OP_OCCUPIED_BASES_HORDE , horde ) ; } void BattlegroundAB :: _NodeOccupied ( uint8 node , Team team ) { if ( ! AddSpiritGuide ( node , BG_AB_SpiritGuidePos [ node ] , GetTeamIndexByTeamId ( team ) ) ) TC_LOG_ERROR ( " bg . battleground " , " Failed ▁ to ▁ spawn ▁ spirit ▁ guide ! ▁ point : ▁ % u , ▁ team : ▁ % u , ▁ " , node , team ) ; if ( node >= BG_AB_DYNAMIC_NODES_COUNT ) return ; uint8 capturedNodes = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == GetTeamIndexByTeamId ( team ) + BG_AB_NODE_TYPE_OCCUPIED && ! m_NodeTimers [ i ] ) ++ capturedNodes ; if ( capturedNodes >= 5 ) CastSpellOnTeam ( SPELL_AB_QUEST_REWARD_5_BASES , team ) ; if ( capturedNodes >= 4 ) CastSpellOnTeam ( SPELL_AB_QUEST_REWARD_4_BASES , team ) ; Creature * trigger = ! BgCreatures [ node + 7 ] ? GetBGCreature ( node + 7 ) : NULL ; if ( ! trigger ) trigger = AddCreature ( WORLD_TRIGGER , node + 7 , BG_AB_NodePositions [ node ] , GetTeamIndexByTeamId ( team ) ) ; if ( trigger ) { trigger -> setFaction ( team == ALLIANCE ? 84 : 83 ) ; trigger -> CastSpell ( trigger , SPELL_HONORABLE_DEFENDER_25Y , false ) ; } } void BattlegroundAB :: _NodeDeOccupied ( uint8 node ) { if ( node >= BG_AB_DYNAMIC_NODES_COUNT ) return ; if ( node < BG_AB_DYNAMIC_NODES_COUNT ) DelCreature ( node + 7 ) ; RelocateDeadPlayers ( BgCreatures [ node ] ) ; DelCreature ( node ) ; } void BattlegroundAB :: EventPlayerClickedOnFlag ( Player * source , GameObject * ) { if ( GetStatus ( ) != STATUS_IN_PROGRESS ) return ; uint8 node = BG_AB_NODE_STABLES ; GameObject * obj = GetBgMap ( ) -> GetGameObject ( BgObjects [ node * 8 + 7 ] ) ; while ( ( node < BG_AB_DYNAMIC_NODES_COUNT ) && ( ( ! obj ) || ( ! source -> IsWithinDistInMap ( obj , 10 ) ) ) ) { ++ node ; obj = GetBgMap ( ) -> GetGameObject ( BgObjects [ node * 8 + BG_AB_OBJECT_AURA_CONTESTED ] ) ; } if ( node == BG_AB_DYNAMIC_NODES_COUNT ) { return ; } TeamId teamIndex = GetTeamIndexByTeamId ( source -> GetTeam ( ) ) ; if ( ! ( m_Nodes [ node ] == 0 || teamIndex == m_Nodes [ node ] % 2 ) ) return ; source -> RemoveAurasWithInterruptFlags ( AURA_INTERRUPT_FLAG_ENTER_PVP_COMBAT ) ; uint32 sound = 0 ; if ( m_Nodes [ node ] == BG_AB_NODE_TYPE_NEUTRAL ) { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + 1 ; _DelBanner ( node , BG_AB_NODE_TYPE_NEUTRAL , 0 ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == 0 ) SendMessage2ToAll ( LANG_BG_AB_NODE_CLAIMED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) , LANG_BG_AB_ALLY ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_CLAIMED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) , LANG_BG_AB_HORDE ) ; sound = BG_AB_SOUND_NODE_CLAIMED ; } else if ( ( m_Nodes [ node ] == BG_AB_NODE_STATUS_ALLY_CONTESTED ) || ( m_Nodes [ node ] == BG_AB_NODE_STATUS_HORDE_CONTESTED ) ) { if ( m_prevNodes [ node ] < BG_AB_NODE_TYPE_OCCUPIED ) { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_CONTESTED ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; } else { UpdatePlayerScore ( source , SCORE_BASES_DEFENDED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_OCCUPIED ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = 0 ; _NodeOccupied ( node , ( teamIndex == TEAM_ALLIANCE ) ? ALLIANCE : HORDE ) ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_DEFENDED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_DEFENDED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; } sound = ( teamIndex == TEAM_ALLIANCE ) ? BG_AB_SOUND_NODE_ASSAULTED_ALLIANCE : BG_AB_SOUND_NODE_ASSAULTED_HORDE ; } else { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_CONTESTED ; _DelBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; _NodeDeOccupied ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; sound = ( teamIndex == TEAM_ALLIANCE ) ? BG_AB_SOUND_NODE_ASSAULTED_ALLIANCE : BG_AB_SOUND_NODE_ASSAULTED_HORDE ; } if ( m_Nodes [ node ] >= BG_AB_NODE_TYPE_OCCUPIED ) { if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_ALLIANCE , NULL , LANG_BG_AB_ALLY , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_HORDE , NULL , LANG_BG_AB_HORDE , _GetNodeNameId ( node ) ) ; } PlaySoundToAll ( sound ) ; } uint32 BattlegroundAB :: GetPrematureWinner ( ) { uint8 ally = 0 , horde = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; if ( ally > horde ) return ALLIANCE ; else if ( horde > ally ) return HORDE ; return Battleground :: GetPrematureWinner ( ) ; } bool BattlegroundAB :: SetupBattleground ( ) { for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { if ( ! AddObject ( BG_AB_OBJECT_BANNER_NEUTRAL + 8 * i , BG_AB_OBJECTID_NODE_BANNER_0 + i , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_CONT_A + 8 * i , BG_AB_OBJECTID_BANNER_CONT_A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_CONT_H + 8 * i , BG_AB_OBJECTID_BANNER_CONT_H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_ALLY + 8 * i , BG_AB_OBJECTID_BANNER_A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_HORDE + 8 * i , BG_AB_OBJECTID_BANNER_H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_ALLY + 8 * i , BG_AB_OBJECTID_AURA_A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_HORDE + 8 * i , BG_AB_OBJECTID_AURA_H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_CONTESTED + 8 * i , BG_AB_OBJECTID_AURA_C , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) ) { TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ some ▁ object ▁ Battleground ▁ not ▁ created ! " ) ; return false ; } } if ( ! AddObject ( BG_AB_OBJECT_GATE_A , BG_AB_OBJECTID_GATE_A , BG_AB_DoorPositions [ 0 ] [ 0 ] , BG_AB_DoorPositions [ 0 ] [ 1 ] , BG_AB_DoorPositions [ 0 ] [ 2 ] , BG_AB_DoorPositions [ 0 ] [ 3 ] , BG_AB_DoorPositions [ 0 ] [ 4 ] , BG_AB_DoorPositions [ 0 ] [ 5 ] , BG_AB_DoorPositions [ 0 ] [ 6 ] , BG_AB_DoorPositions [ 0 ] [ 7 ] , RESPAWN_IMMEDIATELY ) || ! AddObject ( BG_AB_OBJECT_GATE_H , BG_AB_OBJECTID_GATE_H , BG_AB_DoorPositions [ 1 ] [ 0 ] , BG_AB_DoorPositions [ 1 ] [ 1 ] , BG_AB_DoorPositions [ 1 ] [ 2 ] , BG_AB_DoorPositions [ 1 ] [ 3 ] , BG_AB_DoorPositions [ 1 ] [ 4 ] , BG_AB_DoorPositions [ 1 ] [ 5 ] , BG_AB_DoorPositions [ 1 ] [ 6 ] , BG_AB_DoorPositions [ 1 ] [ 7 ] , RESPAWN_IMMEDIATELY ) ) { TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ door ▁ object ▁ Battleground ▁ not ▁ created ! " ) ; return false ; } for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { if ( ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i , Buff_Entries [ 0 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i + 1 , Buff_Entries [ 1 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i + 2 , Buff_Entries [ 2 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) ) TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ buff ▁ object ! " ) ; } return true ; } void BattlegroundAB :: Reset ( ) { Battleground :: Reset ( ) ; m_TeamScores [ TEAM_ALLIANCE ] = 0 ; m_TeamScores [ TEAM_HORDE ] = 0 ; m_lastTick [ TEAM_ALLIANCE ] = 0 ; m_lastTick [ TEAM_HORDE ] = 0 ; m_HonorScoreTics [ TEAM_ALLIANCE ] = 0 ; m_HonorScoreTics [ TEAM_HORDE ] = 0 ; m_ReputationScoreTics [ TEAM_ALLIANCE ] = 0 ; m_ReputationScoreTics [ TEAM_HORDE ] = 0 ; m_IsInformedNearVictory = false ; bool isBGWeekend = sBattlegroundMgr -> IsBGWeekend ( GetTypeID ( ) ) ; m_HonorTics = ( isBGWeekend ) ? BG_AB_ABBGWeekendHonorTicks : BG_AB_NotABBGWeekendHonorTicks ; m_ReputationTics = ( isBGWeekend ) ? BG_AB_ABBGWeekendReputationTicks : BG_AB_NotABBGWeekendReputationTicks ; m_TeamScores500Disadvantage [ TEAM_ALLIANCE ] = false ; m_TeamScores500Disadvantage [ TEAM_HORDE ] = false ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { m_Nodes [ i ] = 0 ; m_prevNodes [ i ] = 0 ; m_NodeTimers [ i ] = 0 ; m_BannerTimers [ i ] . timer = 0 ; } for ( uint8 i = 0 ; i < BG_AB_ALL_NODES_COUNT + 5 ; ++ i ) if ( ! BgCreatures [ i ] . IsEmpty ( ) ) DelCreature ( i ) ; } void BattlegroundAB :: EndBattleground ( uint32 winner ) { if ( winner == ALLIANCE ) RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ALLIANCE ) ; if ( winner == HORDE ) RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , HORDE ) ; RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , HORDE ) ; RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ALLIANCE ) ; Battleground :: EndBattleground ( winner ) ; } WorldSafeLocsEntry const * BattlegroundAB :: GetClosestGraveYard ( Player * player ) { TeamId teamIndex = GetTeamIndexByTeamId ( player -> GetTeam ( ) ) ; std :: vector < uint8 > nodes ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == teamIndex + 3 ) nodes . push_back ( i ) ; WorldSafeLocsEntry const * good_entry = NULL ; if ( ! nodes . empty ( ) ) { float plr_x = player -> GetPositionX ( ) ; float plr_y = player -> GetPositionY ( ) ; float mindist = 999999.0f ; for ( uint8 i = 0 ; i < nodes . size ( ) ; ++ i ) { WorldSafeLocsEntry const * entry = sWorldSafeLocsStore . LookupEntry ( BG_AB_GraveyardIds [ nodes [ i ] ] ) ; if ( ! entry ) continue ; float dist = ( entry -> Loc . X - plr_x ) * ( entry -> Loc . X - plr_x ) + ( entry -> Loc . Y - plr_y ) * ( entry -> Loc . Y - plr_y ) ; if ( mindist > dist ) { mindist = dist ; good_entry = entry ; } } nodes . clear ( ) ; } if ( ! good_entry ) good_entry = sWorldSafeLocsStore . LookupEntry ( BG_AB_GraveyardIds [ teamIndex + 5 ] ) ; return good_entry ; } bool BattlegroundAB :: UpdatePlayerScore ( Player * player , uint32 type , uint32 value , bool doAddHonor ) { if ( ! Battleground :: UpdatePlayerScore ( player , type , value , doAddHonor ) ) return false ; switch ( type ) { case SCORE_BASES_ASSAULTED : player -> UpdateAchievementCriteria ( ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE , AB_OBJECTIVE_ASSAULT_BASE ) ; break ; case SCORE_BASES_DEFENDED : player -> UpdateAchievementCriteria ( ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE , AB_OBJECTIVE_DEFEND_BASE ) ; break ; default : break ; } return true ; } bool BattlegroundAB :: IsAllNodesControlledByTeam ( uint32 team ) const { uint32 count = 0 ; for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( ( team == ALLIANCE && m_Nodes [ i ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) || ( team == HORDE && m_Nodes [ i ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ) ++ count ; return count == BG_AB_DYNAMIC_NODES_COUNT ; } bool BattlegroundAB :: CheckAchievementCriteriaMeet ( uint32 criteriaId , Player const * player , Unit const * target , uint32 miscvalue ) { switch ( criteriaId ) { case BG_CRITERIA_CHECK_RESILIENT_VICTORY : return m_TeamScores500Disadvantage [ GetTeamIndexByTeamId ( player -> GetTeam ( ) ) ] ; } return Battleground :: CheckAchievementCriteriaMeet ( criteriaId , player , target , miscvalue ) ; } </DOCUMENT>
<DOCUMENT_ID="erdincay/clamav-devel/tree/master/libclamav/c++/llvm/lib/Target/PowerPC/PPCSelectionDAGInfo.cpp"> # define DEBUG_TYPE " powerpc - selectiondag - info " # include " PPCTargetMachine . h " using namespace llvm ; PPCSelectionDAGInfo :: PPCSelectionDAGInfo ( const PPCTargetMachine & TM ) : TargetSelectionDAGInfo ( TM ) { } PPCSelectionDAGInfo :: ~ PPCSelectionDAGInfo ( ) { } </DOCUMENT>
<DOCUMENT_ID="dolphin-emu/dolphin/tree/master/Source/Core/VideoCommon/OnScreenDisplay.cpp"> # include " VideoCommon / OnScreenDisplay . h " # include < algorithm > # include < map > # include < mutex > # include < string > # include < fmt / format . h > # include < imgui . h > # include " Common / CommonTypes . h " # include " Common / Timer . h " # include " Core / ConfigManager . h " namespace OSD { constexpr float LEFT_MARGIN = 10.0f ; constexpr float TOP_MARGIN = 10.0f ; constexpr float WINDOW_PADDING = 4.0f ; struct Message { Message ( ) = default ; Message ( std :: string text_ , u32 timestamp_ , u32 color_ ) : text ( std :: move ( text_ ) ) , timestamp ( timestamp_ ) , color ( color_ ) { } std :: string text ; u32 timestamp = 0 ; u32 color = 0 ; } ; static std :: multimap < MessageType , Message > s_messages ; static std :: mutex s_messages_mutex ; static ImVec4 RGBAToImVec4 ( const u32 rgba ) { return ImVec4 ( static_cast < float > ( ( rgba >> 16 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 8 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 0 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 24 ) & 0xFF ) / 255.0f ) ; } static float DrawMessage ( int index , const Message & msg , const ImVec2 & position , int time_left ) { const std :: string window_name = fmt :: format ( " osd _ { } " , index ) ; ImGui :: SetNextWindowPos ( position ) ; ImGui :: SetNextWindowSize ( ImVec2 ( 0.0f , 0.0f ) ) ; const float alpha = std :: min ( 1.0f , std :: max ( 0.0f , time_left / 1024.0f ) ) ; ImGui :: PushStyleVar ( ImGuiStyleVar_Alpha , alpha ) ; float window_height = 0.0f ; if ( ImGui :: Begin ( window_name . c_str ( ) , nullptr , ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoFocusOnAppearing ) ) { ImGui :: TextColored ( RGBAToImVec4 ( msg . color ) , " % s " , msg . text . c_str ( ) ) ; window_height = ImGui :: GetWindowSize ( ) . y + ( WINDOW_PADDING * ImGui :: GetIO ( ) . DisplayFramebufferScale . y ) ; } ImGui :: End ( ) ; ImGui :: PopStyleVar ( ) ; return window_height ; } void AddTypedMessage ( MessageType type , std :: string message , u32 ms , u32 rgba ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . erase ( type ) ; s_messages . emplace ( type , Message ( std :: move ( message ) , Common :: Timer :: GetTimeMs ( ) + ms , rgba ) ) ; } void AddMessage ( std :: string message , u32 ms , u32 rgba ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . emplace ( MessageType :: Typeless , Message ( std :: move ( message ) , Common :: Timer :: GetTimeMs ( ) + ms , rgba ) ) ; } void DrawMessages ( ) { if ( ! SConfig :: GetInstance ( ) . bOnScreenDisplayMessages ) return ; { std :: lock_guard lock { s_messages_mutex } ; const u32 now = Common :: Timer :: GetTimeMs ( ) ; float current_x = LEFT_MARGIN * ImGui :: GetIO ( ) . DisplayFramebufferScale . x ; float current_y = TOP_MARGIN * ImGui :: GetIO ( ) . DisplayFramebufferScale . y ; int index = 0 ; auto it = s_messages . begin ( ) ; while ( it != s_messages . end ( ) ) { const Message & msg = it -> second ; const int time_left = static_cast < int > ( msg . timestamp - now ) ; current_y += DrawMessage ( index ++ , msg , ImVec2 ( current_x , current_y ) , time_left ) ; if ( time_left <= 0 ) it = s_messages . erase ( it ) ; else ++ it ; } } } void ClearMessages ( ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . clear ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="eriser/Obxd/tree/master/JuceLibraryCode/modules/juce_box2d/box2d/Common/b2StackAllocator.cpp"> # include " b2StackAllocator . h " # include " b2Math . h " b2StackAllocator :: b2StackAllocator ( ) { m_index = 0 ; m_allocation = 0 ; m_maxAllocation = 0 ; m_entryCount = 0 ; } b2StackAllocator :: ~ b2StackAllocator ( ) { b2Assert ( m_index == 0 ) ; b2Assert ( m_entryCount == 0 ) ; } void * b2StackAllocator :: Allocate ( int32 size ) { b2Assert ( m_entryCount < b2_maxStackEntries ) ; b2StackEntry * entry = m_entries + m_entryCount ; entry -> size = size ; if ( m_index + size > b2_stackSize ) { entry -> data = ( char * ) b2Alloc ( size ) ; entry -> usedMalloc = true ; } else { entry -> data = m_data + m_index ; entry -> usedMalloc = false ; m_index += size ; } m_allocation += size ; m_maxAllocation = b2Max ( m_maxAllocation , m_allocation ) ; ++ m_entryCount ; return entry -> data ; } void b2StackAllocator :: Free ( void * p ) { b2Assert ( m_entryCount > 0 ) ; b2StackEntry * entry = m_entries + m_entryCount - 1 ; b2Assert ( p == entry -> data ) ; if ( entry -> usedMalloc ) { b2Free ( p ) ; } else { m_index -= entry -> size ; } m_allocation -= entry -> size ; -- m_entryCount ; p = NULL ; } int32 b2StackAllocator :: GetMaxAllocation ( ) const { return m_maxAllocation ; } </DOCUMENT>
<DOCUMENT_ID="Deepakpatle/phantomjs/tree/master/src/qt/qtwebkit/Source/JavaScriptCore/dfg/DFGAbstractState.cpp"> # include " config . h " # include " DFGAbstractState . h " # if ENABLE ( DFG_JIT ) # include " CodeBlock . h " # include " DFGBasicBlock . h " # include " GetByIdStatus . h " # include " Operations . h " # include " PutByIdStatus . h " # include " StringObject . h " namespace JSC { namespace DFG { AbstractState :: AbstractState ( Graph & graph ) : m_codeBlock ( graph . m_codeBlock ) , m_graph ( graph ) , m_variables ( m_codeBlock -> numParameters ( ) , graph . m_localVars ) , m_block ( 0 ) { } AbstractState :: ~ AbstractState ( ) { } void AbstractState :: beginBasicBlock ( BasicBlock * basicBlock ) { ASSERT ( ! m_block ) ; ASSERT ( basicBlock -> variablesAtHead . numberOfLocals ( ) == basicBlock -> valuesAtHead . numberOfLocals ( ) ) ; ASSERT ( basicBlock -> variablesAtTail . numberOfLocals ( ) == basicBlock -> valuesAtTail . numberOfLocals ( ) ) ; ASSERT ( basicBlock -> variablesAtHead . numberOfLocals ( ) == basicBlock -> variablesAtTail . numberOfLocals ( ) ) ; for ( size_t i = 0 ; i < basicBlock -> size ( ) ; i ++ ) forNode ( basicBlock -> at ( i ) ) . clear ( ) ; m_variables = basicBlock -> valuesAtHead ; m_haveStructures = false ; for ( size_t i = 0 ; i < m_variables . numberOfArguments ( ) ; ++ i ) { if ( m_variables . argument ( i ) . m_currentKnownStructure . isNeitherClearNorTop ( ) ) { m_haveStructures = true ; break ; } } for ( size_t i = 0 ; i < m_variables . numberOfLocals ( ) ; ++ i ) { if ( m_variables . local ( i ) . m_currentKnownStructure . isNeitherClearNorTop ( ) ) { m_haveStructures = true ; break ; } } basicBlock -> cfaShouldRevisit = false ; basicBlock -> cfaHasVisited = true ; m_block = basicBlock ; m_isValid = true ; m_foundConstants = false ; m_branchDirection = InvalidBranchDirection ; } void AbstractState :: initialize ( Graph & graph ) { BasicBlock * root = graph . m_blocks [ 0 ] . get ( ) ; root -> cfaShouldRevisit = true ; root -> cfaHasVisited = false ; root -> cfaFoundConstants = false ; for ( size_t i = 0 ; i < root -> valuesAtHead . numberOfArguments ( ) ; ++ i ) { Node * node = root -> variablesAtHead . argument ( i ) ; ASSERT ( node -> op ( ) == SetArgument ) ; if ( ! node -> variableAccessData ( ) -> shouldUnboxIfPossible ( ) ) { root -> valuesAtHead . argument ( i ) . makeTop ( ) ; continue ; } SpeculatedType prediction = node -> variableAccessData ( ) -> prediction ( ) ; if ( isInt32Speculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecInt32 ) ; else if ( isBooleanSpeculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecBoolean ) ; else if ( isCellSpeculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecCell ) ; else root -> valuesAtHead . argument ( i ) . makeTop ( ) ; root -> valuesAtTail . argument ( i ) . clear ( ) ; } for ( size_t i = 0 ; i < root -> valuesAtHead . numberOfLocals ( ) ; ++ i ) { Node * node = root -> variablesAtHead . local ( i ) ; if ( node && node -> variableAccessData ( ) -> isCaptured ( ) ) root -> valuesAtHead . local ( i ) . makeTop ( ) ; else root -> valuesAtHead . local ( i ) . clear ( ) ; root -> valuesAtTail . local ( i ) . clear ( ) ; } for ( BlockIndex blockIndex = 1 ; blockIndex < graph . m_blocks . size ( ) ; ++ blockIndex ) { BasicBlock * block = graph . m_blocks [ blockIndex ] . get ( ) ; if ( ! block ) continue ; if ( ! block -> isReachable ) continue ; block -> cfaShouldRevisit = false ; block -> cfaHasVisited = false ; block -> cfaFoundConstants = false ; for ( size_t i = 0 ; i < block -> valuesAtHead . numberOfArguments ( ) ; ++ i ) { block -> valuesAtHead . argument ( i ) . clear ( ) ; block -> valuesAtTail . argument ( i ) . clear ( ) ; } for ( size_t i = 0 ; i < block -> valuesAtHead . numberOfLocals ( ) ; ++ i ) { block -> valuesAtHead . local ( i ) . clear ( ) ; block -> valuesAtTail . local ( i ) . clear ( ) ; } if ( ! block -> isOSRTarget ) continue ; if ( block -> bytecodeBegin != graph . m_osrEntryBytecodeIndex ) continue ; for ( size_t i = 0 ; i < graph . m_mustHandleValues . size ( ) ; ++ i ) { AbstractValue value ; value . setMostSpecific ( graph . m_mustHandleValues [ i ] ) ; int operand = graph . m_mustHandleValues . operandForIndex ( i ) ; block -> valuesAtHead . operand ( operand ) . merge ( value ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ Initializing ▁ Block ▁ # % u , ▁ operand ▁ r % d , ▁ to ▁ " , blockIndex , operand ) ; block -> valuesAtHead . operand ( operand ) . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; # endif } block -> cfaShouldRevisit = true ; } } bool AbstractState :: endBasicBlock ( MergeMode mergeMode ) { ASSERT ( m_block ) ; BasicBlock * block = m_block ; block -> cfaFoundConstants = m_foundConstants ; block -> cfaDidFinish = m_isValid ; block -> cfaBranchDirection = m_branchDirection ; if ( ! m_isValid ) { reset ( ) ; return false ; } bool changed = false ; if ( mergeMode != DontMerge || ! ASSERT_DISABLED ) { for ( size_t argument = 0 ; argument < block -> variablesAtTail . numberOfArguments ( ) ; ++ argument ) { # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ state ▁ for ▁ argument ▁ % zu . \n " , argument ) ; # endif AbstractValue & destination = block -> valuesAtTail . argument ( argument ) ; changed |= mergeStateAtTail ( destination , m_variables . argument ( argument ) , block -> variablesAtTail . argument ( argument ) ) ; } for ( size_t local = 0 ; local < block -> variablesAtTail . numberOfLocals ( ) ; ++ local ) { # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ state ▁ for ▁ local ▁ % zu . \n " , local ) ; # endif AbstractValue & destination = block -> valuesAtTail . local ( local ) ; changed |= mergeStateAtTail ( destination , m_variables . local ( local ) , block -> variablesAtTail . local ( local ) ) ; } } ASSERT ( mergeMode != DontMerge || ! changed ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Branch ▁ direction ▁ = ▁ % s \n " , branchDirectionToString ( m_branchDirection ) ) ; # endif reset ( ) ; if ( mergeMode != MergeToSuccessors ) return changed ; return mergeToSuccessors ( m_graph , block ) ; } void AbstractState :: reset ( ) { m_block = 0 ; m_isValid = false ; m_branchDirection = InvalidBranchDirection ; } AbstractState :: BooleanResult AbstractState :: booleanResult ( Node * node , AbstractValue & value ) { JSValue childConst = value . value ( ) ; if ( childConst ) { if ( childConst . toBoolean ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> globalExec ( ) ) ) return DefinitelyTrue ; return DefinitelyFalse ; } if ( isCellSpeculation ( value . m_type ) && value . m_currentKnownStructure . hasSingleton ( ) ) { Structure * structure = value . m_currentKnownStructure . singleton ( ) ; if ( ! structure -> masqueradesAsUndefined ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) ) && structure -> typeInfo ( ) . type ( ) != StringType ) return DefinitelyTrue ; } return UnknownBooleanResult ; } bool AbstractState :: startExecuting ( Node * node ) { ASSERT ( m_block ) ; ASSERT ( m_isValid ) ; m_didClobber = false ; node -> setCanExit ( false ) ; if ( ! node -> shouldGenerate ( ) ) return false ; return true ; } bool AbstractState :: startExecuting ( unsigned indexInBlock ) { return startExecuting ( m_block -> at ( indexInBlock ) ) ; } void AbstractState :: executeEdges ( Node * node ) { DFG_NODE_DO_TO_CHILDREN ( m_graph , node , filterEdgeByUse ) ; } void AbstractState :: executeEdges ( unsigned indexInBlock ) { executeEdges ( m_block -> at ( indexInBlock ) ) ; } void AbstractState :: verifyEdge ( Node * , Edge edge ) { RELEASE_ASSERT ( ! ( forNode ( edge ) . m_type & ~ typeFilterFor ( edge . useKind ( ) ) ) ) ; } void AbstractState :: verifyEdges ( Node * node ) { DFG_NODE_DO_TO_CHILDREN ( m_graph , node , verifyEdge ) ; } bool AbstractState :: executeEffects ( unsigned indexInBlock , Node * node ) { if ( ! ASSERT_DISABLED ) verifyEdges ( node ) ; switch ( node -> op ( ) ) { case JSConstant : case WeakJSConstant : case PhantomArguments : { forNode ( node ) . set ( m_graph . valueOfJSConstant ( node ) ) ; break ; } case Identity : { forNode ( node ) = forNode ( node -> child1 ( ) ) ; break ; } case GetLocal : { VariableAccessData * variableAccessData = node -> variableAccessData ( ) ; if ( variableAccessData -> prediction ( ) == SpecNone ) { m_isValid = false ; break ; } AbstractValue value = m_variables . operand ( variableAccessData -> local ( ) ) ; if ( ! variableAccessData -> isCaptured ( ) ) { if ( value . isClear ( ) ) node -> setCanExit ( true ) ; } if ( value . value ( ) ) m_foundConstants = true ; forNode ( node ) = value ; break ; } case GetLocalUnlinked : { AbstractValue value = m_variables . operand ( node -> unlinkedLocal ( ) ) ; if ( value . value ( ) ) m_foundConstants = true ; forNode ( node ) = value ; break ; } case SetLocal : { m_variables . operand ( node -> local ( ) ) = forNode ( node -> child1 ( ) ) ; break ; } case MovHintAndCheck : { break ; } case MovHint : case ZombieHint : { RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } case SetArgument : ASSERT ( ! m_block -> valuesAtHead . operand ( node -> local ( ) ) . isClear ( ) ) ; break ; case BitAnd : case BitOr : case BitXor : case BitRShift : case BitLShift : case BitURShift : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isInt32 ( ) && right . isInt32 ( ) ) { int32_t a = left . asInt32 ( ) ; int32_t b = right . asInt32 ( ) ; bool constantWasSet ; switch ( node -> op ( ) ) { case BitAnd : constantWasSet = trySetConstant ( node , JSValue ( a & b ) ) ; break ; case BitOr : constantWasSet = trySetConstant ( node , JSValue ( a | b ) ) ; break ; case BitXor : constantWasSet = trySetConstant ( node , JSValue ( a ^ b ) ) ; break ; case BitRShift : constantWasSet = trySetConstant ( node , JSValue ( a >> static_cast < uint32_t > ( b ) ) ) ; break ; case BitLShift : constantWasSet = trySetConstant ( node , JSValue ( a << static_cast < uint32_t > ( b ) ) ) ; break ; case BitURShift : constantWasSet = trySetConstant ( node , JSValue ( static_cast < uint32_t > ( a ) >> static_cast < uint32_t > ( b ) ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecInt32 ) ; break ; } case UInt32ToNumber : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { ASSERT ( child . isInt32 ( ) ) ; if ( trySetConstant ( node , JSValue ( child . asUInt32 ( ) ) ) ) { m_foundConstants = true ; break ; } } if ( ! node -> canSpeculateInteger ( ) ) forNode ( node ) . set ( SpecDouble ) ; else { forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; } break ; } case DoubleAsInt32 : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { double asDouble = child . asNumber ( ) ; int32_t asInt = JSC :: toInt32 ( asDouble ) ; if ( bitwise_cast < int64_t > ( static_cast < double > ( asInt ) ) == bitwise_cast < int64_t > ( asDouble ) && trySetConstant ( node , JSValue ( asInt ) ) ) { m_foundConstants = true ; break ; } } node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecInt32 ) ; break ; } case ValueToInt32 : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { bool constantWasSet ; if ( child . isInt32 ( ) ) constantWasSet = trySetConstant ( node , child ) ; else constantWasSet = trySetConstant ( node , JSValue ( JSC :: toInt32 ( child . asDouble ( ) ) ) ) ; if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecInt32 ) ; break ; } case Int32ToDouble : case ForwardInt32ToDouble : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( JSValue :: EncodeAsDouble , child . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } if ( isInt32Speculation ( forNode ( node -> child1 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; } case ValueAdd : case ArithAdd : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) + right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : if ( isRealNumberSpeculation ( forNode ( node -> child1 ( ) ) . m_type ) && isRealNumberSpeculation ( forNode ( node -> child2 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT ( node -> op ( ) == ValueAdd ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . set ( SpecString | SpecInt32 | SpecNumber ) ; break ; } break ; } case MakeRope : { forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case ArithSub : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) - right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithNegate : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( - child . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithMul : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) * right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) || ! nodeCanIgnoreNegativeZero ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : if ( isRealNumberSpeculation ( forNode ( node -> child1 ( ) ) . m_type ) || isRealNumberSpeculation ( forNode ( node -> child2 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithIMul : { forNode ( node ) . set ( SpecInt32 ) ; break ; } case ArithDiv : case ArithMin : case ArithMax : case ArithMod : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) ) { double a = left . asNumber ( ) ; double b = right . asNumber ( ) ; bool constantWasSet ; switch ( node -> op ( ) ) { case ArithDiv : constantWasSet = trySetConstant ( node , JSValue ( a / b ) ) ; break ; case ArithMin : constantWasSet = trySetConstant ( node , JSValue ( a < b ? a : ( b <= a ? b : a + b ) ) ) ; break ; case ArithMax : constantWasSet = trySetConstant ( node , JSValue ( a > b ? a : ( b >= a ? b : a + b ) ) ) ; break ; case ArithMod : constantWasSet = trySetConstant ( node , JSValue ( fmod ( a , b ) ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; break ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithAbs : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( fabs ( child . asNumber ( ) ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithSqrt : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( sqrt ( child . asNumber ( ) ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecDouble ) ; break ; } case LogicalNot : { bool didSetConstant = false ; switch ( booleanResult ( node , forNode ( node -> child1 ( ) ) ) ) { case DefinitelyTrue : didSetConstant = trySetConstant ( node , jsBoolean ( false ) ) ; break ; case DefinitelyFalse : didSetConstant = trySetConstant ( node , jsBoolean ( true ) ) ; break ; default : break ; } if ( didSetConstant ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case BooleanUse : case Int32Use : case NumberUse : case UntypedUse : break ; case ObjectOrOtherUse : node -> setCanExit ( true ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( SpecBoolean ) ; break ; } case IsUndefined : case IsBoolean : case IsNumber : case IsString : case IsObject : case IsFunction : { node -> setCanExit ( node -> op ( ) == IsUndefined && m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> masqueradesAsUndefinedWatchpoint ( ) -> isStillValid ( ) ) ; JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child ) { bool constantWasSet ; switch ( node -> op ( ) ) { case IsUndefined : if ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> masqueradesAsUndefinedWatchpoint ( ) -> isStillValid ( ) ) { constantWasSet = trySetConstant ( node , jsBoolean ( child . isCell ( ) ? false : child . isUndefined ( ) ) ) ; } else { constantWasSet = trySetConstant ( node , jsBoolean ( child . isCell ( ) ? child . asCell ( ) -> structure ( ) -> masqueradesAsUndefined ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) ) : child . isUndefined ( ) ) ) ; } break ; case IsBoolean : constantWasSet = trySetConstant ( node , jsBoolean ( child . isBoolean ( ) ) ) ; break ; case IsNumber : constantWasSet = trySetConstant ( node , jsBoolean ( child . isNumber ( ) ) ) ; break ; case IsString : constantWasSet = trySetConstant ( node , jsBoolean ( isJSString ( child ) ) ) ; break ; case IsObject : if ( child . isNull ( ) || ! child . isObject ( ) ) { constantWasSet = trySetConstant ( node , jsBoolean ( child . isNull ( ) ) ) ; break ; } default : constantWasSet = false ; break ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecBoolean ) ; break ; } case TypeOf : { VM * vm = m_codeBlock -> vm ( ) ; JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; AbstractValue & abstractChild = forNode ( node -> child1 ( ) ) ; if ( child ) { JSValue typeString = jsTypeStringForValue ( * vm , m_codeBlock -> globalObjectFor ( node -> codeOrigin ) , child ) ; if ( trySetConstant ( node , typeString ) ) { m_foundConstants = true ; break ; } } else if ( isNumberSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . numberString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecNumber ) ; m_foundConstants = true ; break ; } } else if ( isStringSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . stringString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecString ) ; m_foundConstants = true ; break ; } } else if ( isFinalObjectSpeculation ( abstractChild . m_type ) || isArraySpeculation ( abstractChild . m_type ) || isArgumentsSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . objectString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecFinalObject | SpecArray | SpecArguments ) ; m_foundConstants = true ; break ; } } else if ( isFunctionSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . functionString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecFunction ) ; m_foundConstants = true ; break ; } } else if ( isBooleanSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . booleanString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecBoolean ) ; m_foundConstants = true ; break ; } } switch ( node -> child1 ( ) . useKind ( ) ) { case StringUse : case CellUse : node -> setCanExit ( true ) ; break ; case UntypedUse : break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case CompareLess : case CompareLessEq : case CompareGreater : case CompareGreaterEq : case CompareEq : case CompareEqConstant : { bool constantWasSet = false ; JSValue leftConst = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue rightConst = forNode ( node -> child2 ( ) ) . value ( ) ; if ( leftConst && rightConst && leftConst . isNumber ( ) && rightConst . isNumber ( ) ) { double a = leftConst . asNumber ( ) ; double b = rightConst . asNumber ( ) ; switch ( node -> op ( ) ) { case CompareLess : constantWasSet = trySetConstant ( node , jsBoolean ( a < b ) ) ; break ; case CompareLessEq : constantWasSet = trySetConstant ( node , jsBoolean ( a <= b ) ) ; break ; case CompareGreater : constantWasSet = trySetConstant ( node , jsBoolean ( a > b ) ) ; break ; case CompareGreaterEq : constantWasSet = trySetConstant ( node , jsBoolean ( a >= b ) ) ; break ; case CompareEq : constantWasSet = trySetConstant ( node , jsBoolean ( a == b ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; break ; } } if ( ! constantWasSet && ( node -> op ( ) == CompareEqConstant || node -> op ( ) == CompareEq ) ) { SpeculatedType leftType = forNode ( node -> child1 ( ) ) . m_type ; SpeculatedType rightType = forNode ( node -> child2 ( ) ) . m_type ; if ( ( isInt32Speculation ( leftType ) && isOtherSpeculation ( rightType ) ) || ( isOtherSpeculation ( leftType ) && isInt32Speculation ( rightType ) ) ) constantWasSet = trySetConstant ( node , jsBoolean ( false ) ) ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecBoolean ) ; node -> setCanExit ( true ) ; break ; } case CompareStrictEq : case CompareStrictEqConstant : { Node * leftNode = node -> child1 ( ) . node ( ) ; Node * rightNode = node -> child2 ( ) . node ( ) ; JSValue left = forNode ( leftNode ) . value ( ) ; JSValue right = forNode ( rightNode ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , jsBoolean ( left . asNumber ( ) == right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecBoolean ) ; node -> setCanExit ( true ) ; break ; } case StringCharCodeAt : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecInt32 ) ; break ; case StringFromCharCode : forNode ( node ) . set ( SpecString ) ; break ; case StringCharAt : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; case GetByVal : { node -> setCanExit ( true ) ; switch ( node -> arrayMode ( ) . type ( ) ) { case Array :: SelectUsingPredictions : case Array :: Unprofiled : case Array :: Undecided : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; case Array :: ForceExit : m_isValid = false ; break ; case Array :: Generic : clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case Array :: String : forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; case Array :: Arguments : forNode ( node ) . makeTop ( ) ; break ; case Array :: Int32 : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) { clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; } else forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Double : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) { clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; } else if ( node -> arrayMode ( ) . isSaneChain ( ) ) forNode ( node ) . set ( SpecDouble ) ; else forNode ( node ) . set ( SpecDoubleReal ) ; break ; case Array :: Contiguous : case Array :: ArrayStorage : case Array :: SlowPutArrayStorage : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case Array :: Int8Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Int16Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Int32Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint8Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint8ClampedArray : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint16Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint32Array : if ( node -> shouldSpeculateInteger ( ) ) forNode ( node ) . set ( SpecInt32 ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; case Array :: Float32Array : forNode ( node ) . set ( SpecDouble ) ; break ; case Array :: Float64Array : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case PutByVal : case PutByValAlias : { node -> setCanExit ( true ) ; switch ( node -> arrayMode ( ) . modeForPut ( ) . type ( ) ) { case Array :: ForceExit : m_isValid = false ; break ; case Array :: Generic : clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Int32 : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Double : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Contiguous : case Array :: ArrayStorage : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: SlowPutArrayStorage : if ( node -> arrayMode ( ) . mayStoreToHole ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; default : break ; } break ; } case ArrayPush : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . set ( SpecNumber ) ; break ; case ArrayPop : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case RegExpExec : forNode ( node ) . makeTop ( ) ; break ; case RegExpTest : forNode ( node ) . set ( SpecBoolean ) ; break ; case Jump : break ; case Branch : { Node * child = node -> child1 ( ) . node ( ) ; BooleanResult result = booleanResult ( node , forNode ( child ) ) ; if ( result == DefinitelyTrue ) { m_branchDirection = TakeTrue ; break ; } if ( result == DefinitelyFalse ) { m_branchDirection = TakeFalse ; break ; } node -> setCanExit ( true ) ; m_branchDirection = TakeBoth ; break ; } case Return : m_isValid = false ; break ; case Throw : case ThrowReferenceError : m_isValid = false ; node -> setCanExit ( true ) ; break ; case ToPrimitive : { JSValue childConst = forNode ( node -> child1 ( ) ) . value ( ) ; if ( childConst && childConst . isNumber ( ) && trySetConstant ( node , childConst ) ) { m_foundConstants = true ; break ; } ASSERT ( node -> child1 ( ) . useKind ( ) == UntypedUse ) ; AbstractValue & source = forNode ( node -> child1 ( ) ) ; AbstractValue & destination = forNode ( node ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; SpeculatedType type = source . m_type ; if ( type & ~ ( SpecNumber | SpecString | SpecBoolean ) ) { type &= ( SpecNumber | SpecString | SpecBoolean ) ; type |= SpecString ; } destination . set ( type ) ; break ; } case ToString : { switch ( node -> child1 ( ) . useKind ( ) ) { case StringObjectUse : forNode ( node -> child1 ( ) ) . filter ( m_graph . globalObjectFor ( node -> codeOrigin ) -> stringObjectStructure ( ) ) ; node -> setCanExit ( true ) ; break ; case StringOrStringObjectUse : node -> setCanExit ( true ) ; break ; case CellUse : case UntypedUse : clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case NewStringObject : { ASSERT ( node -> structure ( ) -> classInfo ( ) == & StringObject :: s_info ) ; forNode ( node ) . set ( node -> structure ( ) ) ; break ; } case NewArray : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> arrayStructureForIndexingTypeDuringAllocation ( node -> indexingType ( ) ) ) ; m_haveStructures = true ; break ; case NewArrayBuffer : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> arrayStructureForIndexingTypeDuringAllocation ( node -> indexingType ( ) ) ) ; m_haveStructures = true ; break ; case NewArrayWithSize : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecArray ) ; m_haveStructures = true ; break ; case NewRegexp : forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> regExpStructure ( ) ) ; m_haveStructures = true ; break ; case ConvertThis : { AbstractValue & source = forNode ( node -> child1 ( ) ) ; AbstractValue & destination = forNode ( node ) ; destination = source ; destination . merge ( SpecObjectOther ) ; break ; } case CreateThis : { forNode ( node ) . set ( SpecFinalObject ) ; break ; } case AllocationProfileWatchpoint : node -> setCanExit ( true ) ; break ; case NewObject : forNode ( node ) . set ( node -> structure ( ) ) ; m_haveStructures = true ; break ; case CreateActivation : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> activationStructure ( ) ) ; m_haveStructures = true ; break ; case CreateArguments : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> argumentsStructure ( ) ) ; m_haveStructures = true ; break ; case TearOffActivation : case TearOffArguments : break ; case CheckArgumentsNotCreated : if ( isEmptySpeculation ( m_variables . operand ( m_graph . argumentsRegisterFor ( node -> codeOrigin ) ) . m_type ) ) m_foundConstants = true ; else node -> setCanExit ( true ) ; break ; case GetMyArgumentsLength : if ( node -> codeOrigin . inlineCallFrame ) forNode ( node ) . set ( jsNumber ( node -> codeOrigin . inlineCallFrame -> arguments . size ( ) - 1 ) ) ; else forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( ! isEmptySpeculation ( m_variables . operand ( m_graph . argumentsRegisterFor ( node -> codeOrigin ) ) . m_type ) ) ; break ; case GetMyArgumentsLengthSafe : clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case GetMyArgumentByVal : node -> setCanExit ( true ) ; forNode ( node ) . makeTop ( ) ; break ; case GetMyArgumentByValSafe : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case NewFunction : { AbstractValue & value = forNode ( node ) ; value = forNode ( node -> child1 ( ) ) ; if ( ! ( value . m_type & SpecEmpty ) ) { m_foundConstants = true ; break ; } value . set ( ( value . m_type & ~ SpecEmpty ) | SpecFunction ) ; break ; } case NewFunctionExpression : case NewFunctionNoCheck : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> functionStructure ( ) ) ; break ; case GetCallee : forNode ( node ) . set ( SpecFunction ) ; break ; case SetCallee : case SetMyScope : break ; case GetScope : case GetMyScope : case SkipTopScope : forNode ( node ) . set ( SpecCellOther ) ; break ; case SkipScope : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && trySetConstant ( node , JSValue ( jsCast < JSScope * > ( child . asCell ( ) ) -> next ( ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecCellOther ) ; break ; } case GetScopeRegisters : forNode ( node ) . clear ( ) ; break ; case GetScopedVar : forNode ( node ) . makeTop ( ) ; break ; case PutScopedVar : clobberCapturedVars ( node -> codeOrigin ) ; break ; case GetById : case GetByIdFlush : node -> setCanExit ( true ) ; if ( ! node -> prediction ( ) ) { m_isValid = false ; break ; } if ( isCellSpeculation ( node -> child1 ( ) -> prediction ( ) ) ) { if ( Structure * structure = forNode ( node -> child1 ( ) ) . bestProvenStructure ( ) ) { GetByIdStatus status = GetByIdStatus :: computeFor ( m_graph . m_vm , structure , m_graph . m_codeBlock -> identifier ( node -> identifierNumber ( ) ) ) ; if ( status . isSimple ( ) ) { ASSERT ( status . structureSet ( ) . size ( ) == 1 ) ; ASSERT ( status . chain ( ) . isEmpty ( ) ) ; if ( status . specificValue ( ) ) forNode ( node ) . set ( status . specificValue ( ) ) ; else forNode ( node ) . makeTop ( ) ; forNode ( node -> child1 ( ) ) . filter ( status . structureSet ( ) ) ; m_foundConstants = true ; break ; } } } clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case GetArrayLength : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecInt32 ) ; break ; case CheckExecutable : { node -> setCanExit ( true ) ; break ; } case CheckStructure : case ForwardCheckStructure : { AbstractValue & value = forNode ( node -> child1 ( ) ) ; ASSERT ( ! ( value . m_type & ~ SpecCell ) ) ; StructureSet & set = node -> structureSet ( ) ; if ( value . m_futurePossibleStructure . isSubsetOf ( set ) || value . m_currentKnownStructure . isSubsetOf ( set ) ) m_foundConstants = true ; if ( ! value . m_currentKnownStructure . isSubsetOf ( set ) ) node -> setCanExit ( true ) ; value . filter ( set ) ; m_haveStructures = true ; break ; } case StructureTransitionWatchpoint : case ForwardStructureTransitionWatchpoint : { AbstractValue & value = forNode ( node -> child1 ( ) ) ; ASSERT ( value . m_futurePossibleStructure . isSubsetOf ( StructureSet ( node -> structure ( ) ) ) ) ; value . filter ( node -> structure ( ) ) ; m_haveStructures = true ; node -> setCanExit ( true ) ; break ; } case PutStructure : case PhantomPutStructure : if ( ! forNode ( node -> child1 ( ) ) . m_currentKnownStructure . isClear ( ) ) { clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . set ( node -> structureTransitionData ( ) . newStructure ) ; m_haveStructures = true ; } break ; case GetButterfly : case AllocatePropertyStorage : case ReallocatePropertyStorage : forNode ( node ) . clear ( ) ; break ; case CheckArray : { if ( node -> arrayMode ( ) . alreadyChecked ( m_graph , node , forNode ( node -> child1 ( ) ) ) ) { m_foundConstants = true ; break ; } node -> setCanExit ( true ) ; switch ( node -> arrayMode ( ) . type ( ) ) { case Array :: String : forNode ( node -> child1 ( ) ) . filter ( SpecString ) ; break ; case Array :: Int32 : case Array :: Double : case Array :: Contiguous : case Array :: ArrayStorage : case Array :: SlowPutArrayStorage : break ; case Array :: Arguments : forNode ( node -> child1 ( ) ) . filter ( SpecArguments ) ; break ; case Array :: Int8Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt8Array ) ; break ; case Array :: Int16Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt16Array ) ; break ; case Array :: Int32Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt32Array ) ; break ; case Array :: Uint8Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint8Array ) ; break ; case Array :: Uint8ClampedArray : forNode ( node -> child1 ( ) ) . filter ( SpecUint8ClampedArray ) ; break ; case Array :: Uint16Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint16Array ) ; break ; case Array :: Uint32Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint32Array ) ; break ; case Array :: Float32Array : forNode ( node -> child1 ( ) ) . filter ( SpecFloat32Array ) ; break ; case Array :: Float64Array : forNode ( node -> child1 ( ) ) . filter ( SpecFloat64Array ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node -> child1 ( ) ) . filterArrayModes ( node -> arrayMode ( ) . arrayModesThatPassFiltering ( ) ) ; m_haveStructures = true ; break ; } case Arrayify : { if ( node -> arrayMode ( ) . alreadyChecked ( m_graph , node , forNode ( node -> child1 ( ) ) ) ) { m_foundConstants = true ; break ; } ASSERT ( node -> arrayMode ( ) . conversion ( ) == Array :: Convert || node -> arrayMode ( ) . conversion ( ) == Array :: RageConvert ) ; node -> setCanExit ( true ) ; clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . filterArrayModes ( node -> arrayMode ( ) . arrayModesThatPassFiltering ( ) ) ; m_haveStructures = true ; break ; } case ArrayifyToStructure : { AbstractValue & value = forNode ( node -> child1 ( ) ) ; StructureSet set = node -> structure ( ) ; if ( value . m_futurePossibleStructure . isSubsetOf ( set ) || value . m_currentKnownStructure . isSubsetOf ( set ) ) m_foundConstants = true ; node -> setCanExit ( true ) ; clobberStructures ( indexInBlock ) ; value . filter ( set ) ; m_haveStructures = true ; break ; } case GetIndexedPropertyStorage : { forNode ( node ) . clear ( ) ; break ; } case GetByOffset : { forNode ( node ) . makeTop ( ) ; break ; } case PutByOffset : { break ; } case CheckFunction : { JSValue value = forNode ( node -> child1 ( ) ) . value ( ) ; if ( value == node -> function ( ) ) { m_foundConstants = true ; ASSERT ( value ) ; break ; } node -> setCanExit ( true ) ; forNode ( node -> child1 ( ) ) . filterByValue ( node -> function ( ) ) ; break ; } case PutById : case PutByIdDirect : node -> setCanExit ( true ) ; if ( Structure * structure = forNode ( node -> child1 ( ) ) . bestProvenStructure ( ) ) { PutByIdStatus status = PutByIdStatus :: computeFor ( m_graph . m_vm , m_graph . globalObjectFor ( node -> codeOrigin ) , structure , m_graph . m_codeBlock -> identifier ( node -> identifierNumber ( ) ) , node -> op ( ) == PutByIdDirect ) ; if ( status . isSimpleReplace ( ) ) { forNode ( node -> child1 ( ) ) . filter ( structure ) ; m_foundConstants = true ; break ; } if ( status . isSimpleTransition ( ) ) { clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . set ( status . newStructure ( ) ) ; m_haveStructures = true ; m_foundConstants = true ; break ; } } clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case GetGlobalVar : forNode ( node ) . makeTop ( ) ; break ; case GlobalVarWatchpoint : node -> setCanExit ( true ) ; break ; case PutGlobalVar : case PutGlobalVarCheck : break ; case CheckHasInstance : node -> setCanExit ( true ) ; break ; case InstanceOf : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecBoolean ) ; break ; case Phi : case Flush : case PhantomLocal : case Breakpoint : break ; case Call : case Construct : case Resolve : case ResolveBase : case ResolveBaseStrictPut : case ResolveGlobal : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case GarbageValue : clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case ForceOSRExit : node -> setCanExit ( true ) ; m_isValid = false ; break ; case CheckWatchdogTimer : node -> setCanExit ( true ) ; break ; case Phantom : case InlineStart : case Nop : case CountExecution : break ; case LastNodeType : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } return m_isValid ; } bool AbstractState :: executeEffects ( unsigned indexInBlock ) { return executeEffects ( indexInBlock , m_block -> at ( indexInBlock ) ) ; } bool AbstractState :: execute ( unsigned indexInBlock ) { Node * node = m_block -> at ( indexInBlock ) ; if ( ! startExecuting ( node ) ) return true ; executeEdges ( node ) ; return executeEffects ( indexInBlock , node ) ; } inline void AbstractState :: clobberWorld ( const CodeOrigin & codeOrigin , unsigned indexInBlock ) { clobberCapturedVars ( codeOrigin ) ; clobberStructures ( indexInBlock ) ; } inline void AbstractState :: clobberCapturedVars ( const CodeOrigin & codeOrigin ) { if ( codeOrigin . inlineCallFrame ) { const BitVector & capturedVars = codeOrigin . inlineCallFrame -> capturedVars ; for ( size_t i = capturedVars . size ( ) ; i -- ; ) { if ( ! capturedVars . quickGet ( i ) ) continue ; m_variables . local ( i ) . makeTop ( ) ; } } else { for ( size_t i = m_codeBlock -> m_numVars ; i -- ; ) { if ( m_codeBlock -> isCaptured ( i ) ) m_variables . local ( i ) . makeTop ( ) ; } } for ( size_t i = m_variables . numberOfArguments ( ) ; i -- ; ) { if ( m_codeBlock -> isCaptured ( argumentToOperand ( i ) ) ) m_variables . argument ( i ) . makeTop ( ) ; } } inline void AbstractState :: clobberStructures ( unsigned indexInBlock ) { if ( ! m_haveStructures ) return ; for ( size_t i = indexInBlock + 1 ; i -- ; ) forNode ( m_block -> at ( i ) ) . clobberStructures ( ) ; for ( size_t i = m_variables . numberOfArguments ( ) ; i -- ; ) m_variables . argument ( i ) . clobberStructures ( ) ; for ( size_t i = m_variables . numberOfLocals ( ) ; i -- ; ) m_variables . local ( i ) . clobberStructures ( ) ; m_haveStructures = false ; m_didClobber = true ; } inline bool AbstractState :: mergeStateAtTail ( AbstractValue & destination , AbstractValue & inVariable , Node * node ) { if ( ! node ) return false ; AbstractValue source ; if ( node -> variableAccessData ( ) -> isCaptured ( ) ) { source = inVariable ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Transfering ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " ▁ from ▁ last ▁ access ▁ due ▁ to ▁ captured ▁ variable . \n " ) ; # endif } else { # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ It ' s ▁ live , ▁ node ▁ @ % u . \n " , node -> index ( ) ) ; # endif switch ( node -> op ( ) ) { case Phi : case SetArgument : case PhantomLocal : case Flush : source = inVariable ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Transfering ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " ▁ from ▁ head ▁ to ▁ tail . \n " ) ; # endif break ; case GetLocal : source = forNode ( node ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Refining ▁ to ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; # endif break ; case SetLocal : if ( node -> variableAccessData ( ) -> shouldUseDoubleFormat ( ) ) { source . set ( SpecDouble ) ; } else source = forNode ( node -> child1 ( ) ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Setting ▁ to ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; # endif break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } } if ( destination == source ) { # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Not ▁ changed ! \n " ) ; # endif return false ; } destination = source ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Changed ! \n " ) ; # endif return true ; } inline bool AbstractState :: merge ( BasicBlock * from , BasicBlock * to ) { ASSERT ( from -> variablesAtTail . numberOfArguments ( ) == to -> variablesAtHead . numberOfArguments ( ) ) ; ASSERT ( from -> variablesAtTail . numberOfLocals ( ) == to -> variablesAtHead . numberOfLocals ( ) ) ; bool changed = false ; for ( size_t argument = 0 ; argument < from -> variablesAtTail . numberOfArguments ( ) ; ++ argument ) { AbstractValue & destination = to -> valuesAtHead . argument ( argument ) ; changed |= mergeVariableBetweenBlocks ( destination , from -> valuesAtTail . argument ( argument ) , to -> variablesAtHead . argument ( argument ) , from -> variablesAtTail . argument ( argument ) ) ; } for ( size_t local = 0 ; local < from -> variablesAtTail . numberOfLocals ( ) ; ++ local ) { AbstractValue & destination = to -> valuesAtHead . local ( local ) ; changed |= mergeVariableBetweenBlocks ( destination , from -> valuesAtTail . local ( local ) , to -> variablesAtHead . local ( local ) , from -> variablesAtTail . local ( local ) ) ; } if ( ! to -> cfaHasVisited ) changed = true ; to -> cfaShouldRevisit |= changed ; return changed ; } inline bool AbstractState :: mergeToSuccessors ( Graph & graph , BasicBlock * basicBlock ) { Node * terminal = basicBlock -> last ( ) ; ASSERT ( terminal -> isTerminal ( ) ) ; switch ( terminal -> op ( ) ) { case Jump : { ASSERT ( basicBlock -> cfaBranchDirection == InvalidBranchDirection ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> takenBlockIndex ( ) ) ; # endif return merge ( basicBlock , graph . m_blocks [ terminal -> takenBlockIndex ( ) ] . get ( ) ) ; } case Branch : { ASSERT ( basicBlock -> cfaBranchDirection != InvalidBranchDirection ) ; bool changed = false ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> takenBlockIndex ( ) ) ; # endif if ( basicBlock -> cfaBranchDirection != TakeFalse ) changed |= merge ( basicBlock , graph . m_blocks [ terminal -> takenBlockIndex ( ) ] . get ( ) ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> notTakenBlockIndex ( ) ) ; # endif if ( basicBlock -> cfaBranchDirection != TakeTrue ) changed |= merge ( basicBlock , graph . m_blocks [ terminal -> notTakenBlockIndex ( ) ] . get ( ) ) ; return changed ; } case Return : case Throw : case ThrowReferenceError : ASSERT ( basicBlock -> cfaBranchDirection == InvalidBranchDirection ) ; return false ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; return false ; } } inline bool AbstractState :: mergeVariableBetweenBlocks ( AbstractValue & destination , AbstractValue & source , Node * destinationNode , Node * sourceNode ) { if ( ! destinationNode ) return false ; ASSERT_UNUSED ( sourceNode , sourceNode ) ; return destination . merge ( source ) ; } void AbstractState :: dump ( PrintStream & out ) { bool first = true ; for ( size_t i = 0 ; i < m_block -> size ( ) ; ++ i ) { Node * node = m_block -> at ( i ) ; AbstractValue & value = forNode ( node ) ; if ( value . isClear ( ) ) continue ; if ( first ) first = false ; else out . printf ( " ▁ " ) ; out . printf ( " @ % lu : " , static_cast < unsigned long > ( node -> index ( ) ) ) ; value . dump ( out ) ; } } } } # endif </DOCUMENT>
<DOCUMENT_ID="geofl/JK2_1.02Source/tree/master/CODE-mp/server/sv_world.cpp"> # include " server . h " clipHandle_t SV_ClipHandleForEntity ( const sharedEntity_t * ent ) { if ( ent -> r . bmodel ) { return CM_InlineModel ( ent -> s . modelindex ) ; } if ( ent -> r . svFlags & SVF_CAPSULE ) { return CM_TempBoxModel ( ent -> r . mins , ent -> r . maxs , qtrue ) ; } return CM_TempBoxModel ( ent -> r . mins , ent -> r . maxs , qfalse ) ; } typedef struct worldSector_s { int axis ; float dist ; struct worldSector_s * children [ 2 ] ; svEntity_t * entities ; } worldSector_t ; # define AREA_DEPTH 4 # define AREA_NODES 64 worldSector_t sv_worldSectors [ AREA_NODES ] ; int sv_numworldSectors ; void SV_SectorList_f ( void ) { int i , c ; worldSector_t * sec ; svEntity_t * ent ; for ( i = 0 ; i < AREA_NODES ; i ++ ) { sec = & sv_worldSectors [ i ] ; c = 0 ; for ( ent = sec -> entities ; ent ; ent = ent -> nextEntityInWorldSector ) { c ++ ; } Com_Printf ( " sector ▁ % i : ▁ % i ▁ entities \n " , i , c ) ; } } worldSector_t * SV_CreateworldSector ( int depth , vec3_t mins , vec3_t maxs ) { worldSector_t * anode ; vec3_t size ; vec3_t mins1 , maxs1 , mins2 , maxs2 ; anode = & sv_worldSectors [ sv_numworldSectors ] ; sv_numworldSectors ++ ; if ( depth == AREA_DEPTH ) { anode -> axis = - 1 ; anode -> children [ 0 ] = anode -> children [ 1 ] = NULL ; return anode ; } VectorSubtract ( maxs , mins , size ) ; if ( size [ 0 ] > size [ 1 ] ) { anode -> axis = 0 ; } else { anode -> axis = 1 ; } anode -> dist = 0.5 * ( maxs [ anode -> axis ] + mins [ anode -> axis ] ) ; VectorCopy ( mins , mins1 ) ; VectorCopy ( mins , mins2 ) ; VectorCopy ( maxs , maxs1 ) ; VectorCopy ( maxs , maxs2 ) ; maxs1 [ anode -> axis ] = mins2 [ anode -> axis ] = anode -> dist ; anode -> children [ 0 ] = SV_CreateworldSector ( depth + 1 , mins2 , maxs2 ) ; anode -> children [ 1 ] = SV_CreateworldSector ( depth + 1 , mins1 , maxs1 ) ; return anode ; } void SV_ClearWorld ( void ) { clipHandle_t h ; vec3_t mins , maxs ; Com_Memset ( sv_worldSectors , 0 , sizeof ( sv_worldSectors ) ) ; sv_numworldSectors = 0 ; h = CM_InlineModel ( 0 ) ; CM_ModelBounds ( h , mins , maxs ) ; SV_CreateworldSector ( 0 , mins , maxs ) ; } void SV_UnlinkEntity ( sharedEntity_t * gEnt ) { svEntity_t * ent ; svEntity_t * scan ; worldSector_t * ws ; ent = SV_SvEntityForGentity ( gEnt ) ; gEnt -> r . linked = qfalse ; ws = ent -> worldSector ; if ( ! ws ) { return ; } ent -> worldSector = NULL ; if ( ws -> entities == ent ) { ws -> entities = ent -> nextEntityInWorldSector ; return ; } for ( scan = ws -> entities ; scan ; scan = scan -> nextEntityInWorldSector ) { if ( scan -> nextEntityInWorldSector == ent ) { scan -> nextEntityInWorldSector = ent -> nextEntityInWorldSector ; return ; } } Com_Printf ( " WARNING : ▁ SV _ UnlinkEntity : ▁ not ▁ found ▁ in ▁ worldSector \n " ) ; } # define MAX_TOTAL_ENT_LEAFS 128 void SV_LinkEntity ( sharedEntity_t * gEnt ) { worldSector_t * node ; int leafs [ MAX_TOTAL_ENT_LEAFS ] ; int cluster ; int num_leafs ; int i , j , k ; int area ; int lastLeaf ; float * origin , * angles ; svEntity_t * ent ; ent = SV_SvEntityForGentity ( gEnt ) ; if ( ent -> worldSector ) { SV_UnlinkEntity ( gEnt ) ; } if ( gEnt -> r . bmodel ) { gEnt -> s . solid = SOLID_BMODEL ; } else if ( gEnt -> r . contents & ( CONTENTS_SOLID | CONTENTS_BODY ) ) { i = gEnt -> r . maxs [ 0 ] ; if ( i < 1 ) i = 1 ; if ( i > 255 ) i = 255 ; j = ( - gEnt -> r . mins [ 2 ] ) ; if ( j < 1 ) j = 1 ; if ( j > 255 ) j = 255 ; k = ( gEnt -> r . maxs [ 2 ] + 32 ) ; if ( k < 1 ) k = 1 ; if ( k > 255 ) k = 255 ; gEnt -> s . solid = ( k << 16 ) | ( j << 8 ) | i ; } else { gEnt -> s . solid = 0 ; } origin = gEnt -> r . currentOrigin ; angles = gEnt -> r . currentAngles ; if ( gEnt -> r . bmodel && ( angles [ 0 ] || angles [ 1 ] || angles [ 2 ] ) ) { float max ; int i ; max = RadiusFromBounds ( gEnt -> r . mins , gEnt -> r . maxs ) ; for ( i = 0 ; i < 3 ; i ++ ) { gEnt -> r . absmin [ i ] = origin [ i ] - max ; gEnt -> r . absmax [ i ] = origin [ i ] + max ; } } else { VectorAdd ( origin , gEnt -> r . mins , gEnt -> r . absmin ) ; VectorAdd ( origin , gEnt -> r . maxs , gEnt -> r . absmax ) ; } gEnt -> r . absmin [ 0 ] -= 1 ; gEnt -> r . absmin [ 1 ] -= 1 ; gEnt -> r . absmin [ 2 ] -= 1 ; gEnt -> r . absmax [ 0 ] += 1 ; gEnt -> r . absmax [ 1 ] += 1 ; gEnt -> r . absmax [ 2 ] += 1 ; ent -> numClusters = 0 ; ent -> lastCluster = 0 ; ent -> areanum = - 1 ; ent -> areanum2 = - 1 ; num_leafs = CM_BoxLeafnums ( gEnt -> r . absmin , gEnt -> r . absmax , leafs , MAX_TOTAL_ENT_LEAFS , & lastLeaf ) ; if ( ! num_leafs ) { return ; } for ( i = 0 ; i < num_leafs ; i ++ ) { area = CM_LeafArea ( leafs [ i ] ) ; if ( area != - 1 ) { if ( ent -> areanum != - 1 && ent -> areanum != area ) { if ( ent -> areanum2 != - 1 && ent -> areanum2 != area && sv . state == SS_LOADING ) { Com_DPrintf ( " Object ▁ % i ▁ touching ▁ 3 ▁ areas ▁ at ▁ % f ▁ % f ▁ % f \n " , gEnt -> s . number , gEnt -> r . absmin [ 0 ] , gEnt -> r . absmin [ 1 ] , gEnt -> r . absmin [ 2 ] ) ; } ent -> areanum2 = area ; } else { ent -> areanum = area ; } } } ent -> numClusters = 0 ; for ( i = 0 ; i < num_leafs ; i ++ ) { cluster = CM_LeafCluster ( leafs [ i ] ) ; if ( cluster != - 1 ) { ent -> clusternums [ ent -> numClusters ++ ] = cluster ; if ( ent -> numClusters == MAX_ENT_CLUSTERS ) { break ; } } } if ( i != num_leafs ) { ent -> lastCluster = CM_LeafCluster ( lastLeaf ) ; } gEnt -> r . linkcount ++ ; node = sv_worldSectors ; while ( 1 ) { if ( node -> axis == - 1 ) break ; if ( gEnt -> r . absmin [ node -> axis ] > node -> dist ) node = node -> children [ 0 ] ; else if ( gEnt -> r . absmax [ node -> axis ] < node -> dist ) node = node -> children [ 1 ] ; else break ; } ent -> worldSector = node ; ent -> nextEntityInWorldSector = node -> entities ; node -> entities = ent ; gEnt -> r . linked = qtrue ; } typedef struct { const float * mins ; const float * maxs ; int * list ; int count , maxcount ; } areaParms_t ; void SV_AreaEntities_r ( worldSector_t * node , areaParms_t * ap ) { svEntity_t * check , * next ; sharedEntity_t * gcheck ; int count ; count = 0 ; for ( check = node -> entities ; check ; check = next ) { next = check -> nextEntityInWorldSector ; gcheck = SV_GEntityForSvEntity ( check ) ; if ( gcheck -> r . absmin [ 0 ] > ap -> maxs [ 0 ] || gcheck -> r . absmin [ 1 ] > ap -> maxs [ 1 ] || gcheck -> r . absmin [ 2 ] > ap -> maxs [ 2 ] || gcheck -> r . absmax [ 0 ] < ap -> mins [ 0 ] || gcheck -> r . absmax [ 1 ] < ap -> mins [ 1 ] || gcheck -> r . absmax [ 2 ] < ap -> mins [ 2 ] ) { continue ; } if ( ap -> count == ap -> maxcount ) { Com_Printf ( " SV _ AreaEntities : ▁ MAXCOUNT \n " ) ; return ; } ap -> list [ ap -> count ] = check - sv . svEntities ; ap -> count ++ ; } if ( node -> axis == - 1 ) { return ; } if ( ap -> maxs [ node -> axis ] > node -> dist ) { SV_AreaEntities_r ( node -> children [ 0 ] , ap ) ; } if ( ap -> mins [ node -> axis ] < node -> dist ) { SV_AreaEntities_r ( node -> children [ 1 ] , ap ) ; } } int SV_AreaEntities ( const vec3_t mins , const vec3_t maxs , int * entityList , int maxcount ) { areaParms_t ap ; ap . mins = mins ; ap . maxs = maxs ; ap . list = entityList ; ap . count = 0 ; ap . maxcount = maxcount ; SV_AreaEntities_r ( sv_worldSectors , & ap ) ; return ap . count ; } typedef struct { vec3_t boxmins , boxmaxs ; const float * mins ; const float * maxs ; vec3_t start ; vec3_t end ; int passEntityNum ; int contentmask ; int capsule ; int traceFlags ; int useLod ; trace_t trace ; } moveclip_t ; void SV_ClipToEntity ( trace_t * trace , const vec3_t start , const vec3_t mins , const vec3_t maxs , const vec3_t end , int entityNum , int contentmask , int capsule ) { sharedEntity_t * touch ; clipHandle_t clipHandle ; float * origin , * angles ; touch = SV_GentityNum ( entityNum ) ; Com_Memset ( trace , 0 , sizeof ( trace_t ) ) ; if ( ! ( contentmask & touch -> r . contents ) ) { trace -> fraction = 1.0 ; return ; } clipHandle = SV_ClipHandleForEntity ( touch ) ; origin = touch -> r . currentOrigin ; angles = touch -> r . currentAngles ; if ( ! touch -> r . bmodel ) { angles = vec3_origin ; } CM_TransformedBoxTrace ( trace , ( float * ) start , ( float * ) end , ( float * ) mins , ( float * ) maxs , clipHandle , contentmask , origin , angles , capsule ) ; if ( trace -> fraction < 1 ) { trace -> entityNum = touch -> s . number ; } } void SV_ClipMoveToEntities ( moveclip_t * clip ) { int i , num ; int touchlist [ MAX_GENTITIES ] ; sharedEntity_t * touch ; int passOwnerNum ; trace_t trace , oldTrace ; clipHandle_t clipHandle ; float * origin , * angles ; int thisOwnerShared = 1 ; num = SV_AreaEntities ( clip -> boxmins , clip -> boxmaxs , touchlist , MAX_GENTITIES ) ; if ( clip -> passEntityNum != ENTITYNUM_NONE ) { passOwnerNum = ( SV_GentityNum ( clip -> passEntityNum ) ) -> r . ownerNum ; if ( passOwnerNum == ENTITYNUM_NONE ) { passOwnerNum = - 1 ; } } else { passOwnerNum = - 1 ; } if ( SV_GentityNum ( clip -> passEntityNum ) -> r . svFlags & SVF_OWNERNOTSHARED ) { thisOwnerShared = 0 ; } for ( i = 0 ; i < num ; i ++ ) { if ( clip -> trace . allsolid ) { return ; } touch = SV_GentityNum ( touchlist [ i ] ) ; if ( clip -> passEntityNum != ENTITYNUM_NONE ) { if ( touchlist [ i ] == clip -> passEntityNum ) { continue ; } if ( touch -> r . ownerNum == clip -> passEntityNum ) { if ( touch -> r . svFlags & SVF_OWNERNOTSHARED ) { if ( clip -> contentmask != ( MASK_SHOT | CONTENTS_LIGHTSABER ) && clip -> contentmask != ( MASK_SHOT ) ) { continue ; } } else { continue ; } } if ( touch -> r . ownerNum == passOwnerNum && ! ( touch -> r . svFlags & SVF_OWNERNOTSHARED ) && ! thisOwnerShared ) { continue ; } } if ( ! ( clip -> contentmask & touch -> r . contents ) ) { continue ; } if ( ( clip -> contentmask == ( MASK_SHOT | CONTENTS_LIGHTSABER ) || clip -> contentmask == MASK_SHOT ) && ( touch -> r . contents > 0 && ( touch -> r . contents & CONTENTS_NOSHOT ) ) ) { continue ; } clipHandle = SV_ClipHandleForEntity ( touch ) ; origin = touch -> r . currentOrigin ; angles = touch -> r . currentAngles ; if ( ! touch -> r . bmodel ) { angles = vec3_origin ; } CM_TransformedBoxTrace ( & trace , ( float * ) clip -> start , ( float * ) clip -> end , ( float * ) clip -> mins , ( float * ) clip -> maxs , clipHandle , clip -> contentmask , origin , angles , clip -> capsule ) ; oldTrace = clip -> trace ; if ( trace . allsolid ) { clip -> trace . allsolid = qtrue ; trace . entityNum = touch -> s . number ; } else if ( trace . startsolid ) { clip -> trace . startsolid = qtrue ; trace . entityNum = touch -> s . number ; } if ( trace . fraction < clip -> trace . fraction ) { qboolean oldStart ; oldStart = clip -> trace . startsolid ; trace . entityNum = touch -> s . number ; clip -> trace = trace ; clip -> trace . startsolid = ( qboolean ) ( ( unsigned ) clip -> trace . startsolid | ( unsigned ) oldStart ) ; } # if 0 if ( ( trace . entityNum == touch -> s . number ) && ( clip -> traceFlags ) ) { if ( touch -> s . ghoul2 ) { int oldTraceRecSize = 0 ; int newTraceRecSize = 0 ; int z ; for ( z = 0 ; z < MAX_G2_COLLISIONS ; z ++ ) { if ( clip -> trace . G2CollisionMap [ z ] . mEntityNum != - 1 ) { oldTraceRecSize ++ ; } } G2API_CollisionDetect ( & clip -> trace . G2CollisionMap [ 0 ] , * ( ( CGhoul2Info_v * ) touch -> s . ghoul2 ) , touch -> s . angles , touch -> s . origin , svs . time , touch -> s . number , clip -> start , clip -> end , touch -> s . modelScale , G2VertSpaceServer , clip -> traceFlags , clip -> useLod ) ; for ( z = 0 ; z < MAX_G2_COLLISIONS ; z ++ ) { if ( clip -> trace . G2CollisionMap [ z ] . mEntityNum != - 1 ) { newTraceRecSize ++ ; } } if ( newTraceRecSize == oldTraceRecSize ) { clip -> trace = oldTrace ; } } } # endif } } void SV_Trace ( trace_t * results , const vec3_t start , const vec3_t mins , const vec3_t maxs , const vec3_t end , int passEntityNum , int contentmask , int capsule , int traceFlags , int useLod ) { moveclip_t clip ; int i ; if ( ! mins ) { mins = vec3_origin ; } if ( ! maxs ) { maxs = vec3_origin ; } Com_Memset ( & clip , 0 , sizeof ( moveclip_t ) ) ; CM_BoxTrace ( & clip . trace , start , end , mins , maxs , 0 , contentmask , capsule ) ; clip . trace . entityNum = clip . trace . fraction != 1.0 ? ENTITYNUM_WORLD : ENTITYNUM_NONE ; if ( clip . trace . fraction == 0 ) { * results = clip . trace ; return ; } clip . contentmask = contentmask ; VectorCopy ( start , clip . start ) ; clip . traceFlags = traceFlags ; clip . useLod = useLod ; VectorCopy ( end , clip . end ) ; clip . mins = mins ; clip . maxs = maxs ; clip . passEntityNum = passEntityNum ; clip . capsule = capsule ; for ( i = 0 ; i < 3 ; i ++ ) { if ( end [ i ] > start [ i ] ) { clip . boxmins [ i ] = clip . start [ i ] + clip . mins [ i ] - 1 ; clip . boxmaxs [ i ] = clip . end [ i ] + clip . maxs [ i ] + 1 ; } else { clip . boxmins [ i ] = clip . end [ i ] + clip . mins [ i ] - 1 ; clip . boxmaxs [ i ] = clip . start [ i ] + clip . maxs [ i ] + 1 ; } } SV_ClipMoveToEntities ( & clip ) ; * results = clip . trace ; } int SV_PointContents ( const vec3_t p , int passEntityNum ) { int touch [ MAX_GENTITIES ] ; sharedEntity_t * hit ; int i , num ; int contents , c2 ; clipHandle_t clipHandle ; float * angles ; contents = CM_PointContents ( p , 0 ) ; num = SV_AreaEntities ( p , p , touch , MAX_GENTITIES ) ; for ( i = 0 ; i < num ; i ++ ) { if ( touch [ i ] == passEntityNum ) { continue ; } hit = SV_GentityNum ( touch [ i ] ) ; clipHandle = SV_ClipHandleForEntity ( hit ) ; angles = hit -> s . angles ; if ( ! hit -> r . bmodel ) { angles = vec3_origin ; } c2 = CM_TransformedPointContents ( p , clipHandle , hit -> s . origin , hit -> s . angles ) ; contents |= c2 ; } return contents ; } </DOCUMENT>
<DOCUMENT_ID="mantidproject/cxxtest/tree/master/cxxtest/TestTracker.cpp"> # ifndef __cxxtest__TestTracker_cpp__ # define __cxxtest__TestTracker_cpp__ # include < cxxtest / TestTracker . h > namespace CxxTest { bool TestTracker :: _created = false ; bool TestTracker :: print_tracing = false ; TestTracker :: TestTracker ( ) { if ( ! _created ) { initialize ( ) ; setListener ( 0 ) ; _created = true ; } } TestTracker :: ~ TestTracker ( ) { } TestTracker & TestTracker :: tracker ( ) { static TestTracker theTracker ; return theTracker ; } void TestTracker :: initialize ( ) { _warnings = 0 ; _skippedTests = 0 ; _testSkipped = false ; _failedTests = 0 ; _testFailedAsserts = 0 ; _suiteFailedTests = 0 ; _failedSuites = 0 ; _world = 0 ; _suite = 0 ; _test = 0 ; } const TestDescription * TestTracker :: fixTest ( const TestDescription * d ) const { return d ? d : & dummyTest ( ) ; } const SuiteDescription * TestTracker :: fixSuite ( const SuiteDescription * d ) const { return d ? d : & dummySuite ( ) ; } const WorldDescription * TestTracker :: fixWorld ( const WorldDescription * d ) const { return d ? d : & dummyWorld ( ) ; } const TestDescription & TestTracker :: dummyTest ( ) const { return dummySuite ( ) . testDescription ( 0 ) ; } const SuiteDescription & TestTracker :: dummySuite ( ) const { return dummyWorld ( ) . suiteDescription ( 0 ) ; } const WorldDescription & TestTracker :: dummyWorld ( ) const { return _dummyWorld ; } void TestTracker :: setListener ( TestListener * l ) { _l = l ? l : & _dummyListener ; } void TestTracker :: enterWorld ( const WorldDescription & wd ) { setWorld ( & wd ) ; _warnings = _skippedTests = _failedTests = _testFailedAsserts = _suiteFailedTests = _failedSuites = 0 ; _testSkipped = false ; _l -> enterWorld ( wd ) ; } void TestTracker :: enterSuite ( const SuiteDescription & sd ) { setSuite ( & sd ) ; _testFailedAsserts = _suiteFailedTests = 0 ; _testSkipped = false ; _l -> enterSuite ( sd ) ; } void TestTracker :: enterTest ( const TestDescription & td ) { setTest ( & td ) ; _testFailedAsserts = false ; _testSkipped = false ; _l -> enterTest ( td ) ; } void TestTracker :: leaveTest ( const TestDescription & td ) { _l -> leaveTest ( td ) ; setTest ( 0 ) ; } void TestTracker :: leaveSuite ( const SuiteDescription & sd ) { _l -> leaveSuite ( sd ) ; setSuite ( 0 ) ; } void TestTracker :: leaveWorld ( const WorldDescription & wd ) { _l -> leaveWorld ( wd ) ; setWorld ( 0 ) ; } void TestTracker :: trace ( const char * file , int line , const char * expression ) { _l -> trace ( file , line , expression ) ; } void TestTracker :: warning ( const char * file , int line , const char * expression ) { countWarning ( ) ; _l -> warning ( file , line , expression ) ; } void TestTracker :: skippedTest ( const char * file , int line , const char * expression ) { countSkipped ( ) ; _testSkipped = true ; _l -> skippedTest ( file , line , expression ) ; } void TestTracker :: failedTest ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedTest ( file , line , expression ) ; } void TestTracker :: failedAssert ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedAssert ( file , line , expression ) ; } void TestTracker :: failedAssertEquals ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertEquals ( file , line , xStr , yStr , x , y ) ; } void TestTracker :: failedAssertSameData ( const char * file , int line , const char * xStr , const char * yStr , const char * sizeStr , const void * x , const void * y , unsigned size ) { countFailure ( ) ; _l -> failedAssertSameData ( file , line , xStr , yStr , sizeStr , x , y , size ) ; } void TestTracker :: failedAssertDelta ( const char * file , int line , const char * xStr , const char * yStr , const char * dStr , const char * x , const char * y , const char * d ) { countFailure ( ) ; _l -> failedAssertDelta ( file , line , xStr , yStr , dStr , x , y , d ) ; } void TestTracker :: failedAssertDiffers ( const char * file , int line , const char * xStr , const char * yStr , const char * value ) { countFailure ( ) ; _l -> failedAssertDiffers ( file , line , xStr , yStr , value ) ; } void TestTracker :: failedAssertLessThan ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertLessThan ( file , line , xStr , yStr , x , y ) ; } void TestTracker :: failedAssertLessThanEquals ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertLessThanEquals ( file , line , xStr , yStr , x , y ) ; } void TestTracker :: failedAssertPredicate ( const char * file , int line , const char * predicate , const char * xStr , const char * x ) { countFailure ( ) ; _l -> failedAssertPredicate ( file , line , predicate , xStr , x ) ; } void TestTracker :: failedAssertRelation ( const char * file , int line , const char * relation , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertRelation ( file , line , relation , xStr , yStr , x , y ) ; } void TestTracker :: failedAssertThrows ( const char * file , int line , const char * expression , const char * type , bool otherThrown ) { countFailure ( ) ; _l -> failedAssertThrows ( file , line , expression , type , otherThrown ) ; } void TestTracker :: failedAssertThrowsNot ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedAssertThrowsNot ( file , line , expression ) ; } void TestTracker :: failedAssertSameFiles ( const char * file , int line , const char * file1 , const char * file2 , const char * explanation ) { countFailure ( ) ; _l -> failedAssertSameFiles ( file , line , file1 , file2 , explanation ) ; } void TestTracker :: setWorld ( const WorldDescription * w ) { _world = fixWorld ( w ) ; setSuite ( 0 ) ; } void TestTracker :: setSuite ( const SuiteDescription * s ) { _suite = fixSuite ( s ) ; setTest ( 0 ) ; } void TestTracker :: setTest ( const TestDescription * t ) { _test = fixTest ( t ) ; } void TestTracker :: countWarning ( ) { ++ _warnings ; } void TestTracker :: countSkipped ( ) { ++ _skippedTests ; } void TestTracker :: countFailure ( ) { if ( ++ _testFailedAsserts == 1 ) { ++ _failedTests ; if ( ++ _suiteFailedTests == 1 ) { ++ _failedSuites ; } } } } # endif </DOCUMENT>
<DOCUMENT_ID="goldcoin/gldcoin/tree/master/BuildDeps/deps/boost/libs/polygon/example/voronoi_visualizer.cpp"> # include < iostream > # include < vector > # include < QtOpenGL / QGLWidget > # include < QtGui / QtGui > # include < boost / polygon / polygon . hpp > # include < boost / polygon / voronoi . hpp > using namespace boost :: polygon ; # include " voronoi _ visual _ utils . hpp " class GLWidget : public QGLWidget { Q_OBJECT public : explicit GLWidget ( QMainWindow * parent = NULL ) : QGLWidget ( QGLFormat ( QGL :: SampleBuffers ) , parent ) , primary_edges_only_ ( false ) , internal_edges_only_ ( false ) { startTimer ( 40 ) ; } QSize sizeHint ( ) const { return QSize ( 600 , 600 ) ; } void build ( const QString & file_path ) { clear ( ) ; read_data ( file_path ) ; if ( ! brect_initialized_ ) { return ; } construct_brect ( ) ; construct_voronoi ( point_data_ . begin ( ) , point_data_ . end ( ) , segment_data_ . begin ( ) , segment_data_ . end ( ) , & vd_ ) ; for ( const_edge_iterator it = vd_ . edges ( ) . begin ( ) ; it != vd_ . edges ( ) . end ( ) ; ++ it ) { if ( ! it -> is_finite ( ) ) { color_exterior ( & ( * it ) ) ; } } update_view_port ( ) ; } void show_primary_edges_only ( ) { primary_edges_only_ ^= true ; } void show_internal_edges_only ( ) { internal_edges_only_ ^= true ; } protected : void initializeGL ( ) { glHint ( GL_POINT_SMOOTH_HINT , GL_NICEST ) ; glBlendFunc ( GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA ) ; glEnable ( GL_BLEND ) ; glEnable ( GL_POINT_SMOOTH ) ; } void paintGL ( ) { qglClearColor ( QColor :: fromRgb ( 255 , 255 , 255 ) ) ; glClear ( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT ) ; draw_points ( ) ; draw_segments ( ) ; draw_vertices ( ) ; draw_edges ( ) ; } void resizeGL ( int width , int height ) { int side = qMin ( width , height ) ; glViewport ( ( width - side ) / 2 , ( height - side ) / 2 , side , side ) ; } void timerEvent ( QTimerEvent * e ) { update ( ) ; } private : typedef double coordinate_type ; typedef point_data < coordinate_type > point_type ; typedef segment_data < coordinate_type > segment_type ; typedef rectangle_data < coordinate_type > rect_type ; typedef voronoi_builder < int > VB ; typedef voronoi_diagram < coordinate_type > VD ; typedef VD :: cell_type cell_type ; typedef VD :: cell_type :: source_index_type source_index_type ; typedef VD :: cell_type :: source_category_type source_category_type ; typedef VD :: edge_type edge_type ; typedef VD :: cell_container_type cell_container_type ; typedef VD :: cell_container_type vertex_container_type ; typedef VD :: edge_container_type edge_container_type ; typedef VD :: const_cell_iterator const_cell_iterator ; typedef VD :: const_vertex_iterator const_vertex_iterator ; typedef VD :: const_edge_iterator const_edge_iterator ; static const std :: size_t EXTERNAL_COLOR = 1 ; void clear ( ) { brect_initialized_ = false ; point_data_ . clear ( ) ; segment_data_ . clear ( ) ; vd_ . clear ( ) ; } void read_data ( const QString & file_path ) { QFile data ( file_path ) ; if ( ! data . open ( QFile :: ReadOnly ) ) { QMessageBox :: warning ( this , tr ( " Voronoi ▁ Visualizer " ) , tr ( " Disable ▁ to ▁ open ▁ file ▁ " ) + file_path ) ; } QTextStream in_stream ( & data ) ; std :: size_t num_points , num_segments ; int x1 , y1 , x2 , y2 ; in_stream >> num_points ; for ( std :: size_t i = 0 ; i < num_points ; ++ i ) { in_stream >> x1 >> y1 ; point_type p ( x1 , y1 ) ; update_brect ( p ) ; point_data_ . push_back ( p ) ; } in_stream >> num_segments ; for ( std :: size_t i = 0 ; i < num_segments ; ++ i ) { in_stream >> x1 >> y1 >> x2 >> y2 ; point_type lp ( x1 , y1 ) ; point_type hp ( x2 , y2 ) ; update_brect ( lp ) ; update_brect ( hp ) ; segment_data_ . push_back ( segment_type ( lp , hp ) ) ; } in_stream . flush ( ) ; } void update_brect ( const point_type & point ) { if ( brect_initialized_ ) { encompass ( brect_ , point ) ; } else { set_points ( brect_ , point , point ) ; brect_initialized_ = true ; } } void construct_brect ( ) { double side = ( std :: max ) ( xh ( brect_ ) - xl ( brect_ ) , yh ( brect_ ) - yl ( brect_ ) ) ; center ( shift_ , brect_ ) ; set_points ( brect_ , shift_ , shift_ ) ; bloat ( brect_ , side * 1.2 ) ; } void color_exterior ( const VD :: edge_type * edge ) { if ( edge -> color ( ) == EXTERNAL_COLOR ) { return ; } edge -> color ( EXTERNAL_COLOR ) ; edge -> twin ( ) -> color ( EXTERNAL_COLOR ) ; const VD :: vertex_type * v = edge -> vertex1 ( ) ; if ( v == NULL || ! edge -> is_primary ( ) ) { return ; } v -> color ( EXTERNAL_COLOR ) ; const VD :: edge_type * e = v -> incident_edge ( ) ; do { color_exterior ( e ) ; e = e -> rot_next ( ) ; } while ( e != v -> incident_edge ( ) ) ; } void update_view_port ( ) { glMatrixMode ( GL_PROJECTION ) ; glLoadIdentity ( ) ; rect_type view_rect = brect_ ; deconvolve ( view_rect , shift_ ) ; glOrtho ( xl ( view_rect ) , xh ( view_rect ) , yl ( view_rect ) , yh ( view_rect ) , - 1.0 , 1.0 ) ; glMatrixMode ( GL_MODELVIEW ) ; } void draw_points ( ) { glColor3f ( 0.0f , 0.5f , 1.0f ) ; glPointSize ( 9 ) ; glBegin ( GL_POINTS ) ; for ( std :: size_t i = 0 ; i < point_data_ . size ( ) ; ++ i ) { point_type point = point_data_ [ i ] ; deconvolve ( point , shift_ ) ; glVertex2f ( point . x ( ) , point . y ( ) ) ; } for ( std :: size_t i = 0 ; i < segment_data_ . size ( ) ; ++ i ) { point_type lp = low ( segment_data_ [ i ] ) ; lp = deconvolve ( lp , shift_ ) ; glVertex2f ( lp . x ( ) , lp . y ( ) ) ; point_type hp = high ( segment_data_ [ i ] ) ; hp = deconvolve ( hp , shift_ ) ; glVertex2f ( hp . x ( ) , hp . y ( ) ) ; } glEnd ( ) ; } void draw_segments ( ) { glColor3f ( 0.0f , 0.5f , 1.0f ) ; glLineWidth ( 2.7f ) ; glBegin ( GL_LINES ) ; for ( std :: size_t i = 0 ; i < segment_data_ . size ( ) ; ++ i ) { point_type lp = low ( segment_data_ [ i ] ) ; lp = deconvolve ( lp , shift_ ) ; glVertex2f ( lp . x ( ) , lp . y ( ) ) ; point_type hp = high ( segment_data_ [ i ] ) ; hp = deconvolve ( hp , shift_ ) ; glVertex2f ( hp . x ( ) , hp . y ( ) ) ; } glEnd ( ) ; } void draw_vertices ( ) { glColor3f ( 0.0f , 0.0f , 0.0f ) ; glPointSize ( 6 ) ; glBegin ( GL_POINTS ) ; for ( const_vertex_iterator it = vd_ . vertices ( ) . begin ( ) ; it != vd_ . vertices ( ) . end ( ) ; ++ it ) { if ( internal_edges_only_ && ( it -> color ( ) == EXTERNAL_COLOR ) ) { continue ; } point_type vertex ( it -> x ( ) , it -> y ( ) ) ; vertex = deconvolve ( vertex , shift_ ) ; glVertex2f ( vertex . x ( ) , vertex . y ( ) ) ; } glEnd ( ) ; } void draw_edges ( ) { glColor3f ( 0.0f , 0.0f , 0.0f ) ; glLineWidth ( 1.7f ) ; for ( const_edge_iterator it = vd_ . edges ( ) . begin ( ) ; it != vd_ . edges ( ) . end ( ) ; ++ it ) { if ( primary_edges_only_ && ! it -> is_primary ( ) ) { continue ; } if ( internal_edges_only_ && ( it -> color ( ) == EXTERNAL_COLOR ) ) { continue ; } std :: vector < point_type > samples ; if ( ! it -> is_finite ( ) ) { clip_infinite_edge ( * it , & samples ) ; } else { point_type vertex0 ( it -> vertex0 ( ) -> x ( ) , it -> vertex0 ( ) -> y ( ) ) ; samples . push_back ( vertex0 ) ; point_type vertex1 ( it -> vertex1 ( ) -> x ( ) , it -> vertex1 ( ) -> y ( ) ) ; samples . push_back ( vertex1 ) ; if ( it -> is_curved ( ) ) { sample_curved_edge ( * it , & samples ) ; } } glBegin ( GL_LINE_STRIP ) ; for ( std :: size_t i = 0 ; i < samples . size ( ) ; ++ i ) { point_type vertex = deconvolve ( samples [ i ] , shift_ ) ; glVertex2f ( vertex . x ( ) , vertex . y ( ) ) ; } glEnd ( ) ; } } void clip_infinite_edge ( const edge_type & edge , std :: vector < point_type > * clipped_edge ) { const cell_type & cell1 = * edge . cell ( ) ; const cell_type & cell2 = * edge . twin ( ) -> cell ( ) ; point_type origin , direction ; if ( cell1 . contains_point ( ) && cell2 . contains_point ( ) ) { point_type p1 = retrieve_point ( cell1 ) ; point_type p2 = retrieve_point ( cell2 ) ; origin . x ( ( p1 . x ( ) + p2 . x ( ) ) * 0.5 ) ; origin . y ( ( p1 . y ( ) + p2 . y ( ) ) * 0.5 ) ; direction . x ( p1 . y ( ) - p2 . y ( ) ) ; direction . y ( p2 . x ( ) - p1 . x ( ) ) ; } else { origin = cell1 . contains_segment ( ) ? retrieve_point ( cell2 ) : retrieve_point ( cell1 ) ; segment_type segment = cell1 . contains_segment ( ) ? retrieve_segment ( cell1 ) : retrieve_segment ( cell2 ) ; coordinate_type dx = high ( segment ) . x ( ) - low ( segment ) . x ( ) ; coordinate_type dy = high ( segment ) . y ( ) - low ( segment ) . y ( ) ; if ( ( low ( segment ) == origin ) ^ cell1 . contains_point ( ) ) { direction . x ( dy ) ; direction . y ( - dx ) ; } else { direction . x ( - dy ) ; direction . y ( dx ) ; } } coordinate_type side = xh ( brect_ ) - xl ( brect_ ) ; coordinate_type koef = side / ( std :: max ) ( fabs ( direction . x ( ) ) , fabs ( direction . y ( ) ) ) ; if ( edge . vertex0 ( ) == NULL ) { clipped_edge -> push_back ( point_type ( origin . x ( ) - direction . x ( ) * koef , origin . y ( ) - direction . y ( ) * koef ) ) ; } else { clipped_edge -> push_back ( point_type ( edge . vertex0 ( ) -> x ( ) , edge . vertex0 ( ) -> y ( ) ) ) ; } if ( edge . vertex1 ( ) == NULL ) { clipped_edge -> push_back ( point_type ( origin . x ( ) + direction . x ( ) * koef , origin . y ( ) + direction . y ( ) * koef ) ) ; } else { clipped_edge -> push_back ( point_type ( edge . vertex1 ( ) -> x ( ) , edge . vertex1 ( ) -> y ( ) ) ) ; } } void sample_curved_edge ( const edge_type & edge , std :: vector < point_type > * sampled_edge ) { coordinate_type max_dist = 1E - 3 * ( xh ( brect_ ) - xl ( brect_ ) ) ; point_type point = edge . cell ( ) -> contains_point ( ) ? retrieve_point ( * edge . cell ( ) ) : retrieve_point ( * edge . twin ( ) -> cell ( ) ) ; segment_type segment = edge . cell ( ) -> contains_point ( ) ? retrieve_segment ( * edge . twin ( ) -> cell ( ) ) : retrieve_segment ( * edge . cell ( ) ) ; voronoi_visual_utils < coordinate_type > :: discretize ( point , segment , max_dist , sampled_edge ) ; } point_type retrieve_point ( const cell_type & cell ) { source_index_type index = cell . source_index ( ) ; source_category_type category = cell . source_category ( ) ; if ( category == SOURCE_CATEGORY_SINGLE_POINT ) { return point_data_ [ index ] ; } index -= point_data_ . size ( ) ; if ( category == SOURCE_CATEGORY_SEGMENT_START_POINT ) { return low ( segment_data_ [ index ] ) ; } else { return high ( segment_data_ [ index ] ) ; } } segment_type retrieve_segment ( const cell_type & cell ) { source_index_type index = cell . source_index ( ) - point_data_ . size ( ) ; return segment_data_ [ index ] ; } point_type shift_ ; std :: vector < point_type > point_data_ ; std :: vector < segment_type > segment_data_ ; rect_type brect_ ; VB vb_ ; VD vd_ ; bool brect_initialized_ ; bool primary_edges_only_ ; bool internal_edges_only_ ; } ; class MainWindow : public QWidget { Q_OBJECT public : MainWindow ( ) { glWidget_ = new GLWidget ( ) ; file_dir_ = QDir ( QDir :: currentPath ( ) , tr ( " * . txt " ) ) ; file_name_ = tr ( " " ) ; QHBoxLayout * centralLayout = new QHBoxLayout ; centralLayout -> addWidget ( glWidget_ ) ; centralLayout -> addLayout ( create_file_layout ( ) ) ; setLayout ( centralLayout ) ; update_file_list ( ) ; setWindowTitle ( tr ( " Voronoi ▁ Visualizer " ) ) ; layout ( ) -> setSizeConstraint ( QLayout :: SetFixedSize ) ; } private slots : void primary_edges_only ( ) { glWidget_ -> show_primary_edges_only ( ) ; } void internal_edges_only ( ) { glWidget_ -> show_internal_edges_only ( ) ; } void browse ( ) { QString new_path = QFileDialog :: getExistingDirectory ( 0 , tr ( " Choose ▁ Directory " ) , file_dir_ . absolutePath ( ) ) ; if ( new_path . isEmpty ( ) ) { return ; } file_dir_ . setPath ( new_path ) ; update_file_list ( ) ; } void build ( ) { file_name_ = file_list_ -> currentItem ( ) -> text ( ) ; QString file_path = file_dir_ . filePath ( file_name_ ) ; message_label_ -> setText ( " Building . . . " ) ; glWidget_ -> build ( file_path ) ; message_label_ -> setText ( " Double ▁ click ▁ the ▁ item ▁ to ▁ build ▁ voronoi ▁ diagram : " ) ; setWindowTitle ( tr ( " Voronoi ▁ Visualizer ▁ - ▁ " ) + file_path ) ; } void print_scr ( ) { if ( ! file_name_ . isEmpty ( ) ) { QImage screenshot = glWidget_ -> grabFrameBuffer ( true ) ; QString output_file = file_dir_ . absolutePath ( ) + tr ( " / " ) + file_name_ . left ( file_name_ . indexOf ( ' . ' ) ) + tr ( " . png " ) ; screenshot . save ( output_file , 0 , - 1 ) ; } } private : QGridLayout * create_file_layout ( ) { QGridLayout * file_layout = new QGridLayout ; message_label_ = new QLabel ( " Double ▁ click ▁ item ▁ to ▁ build ▁ voronoi ▁ diagram : " ) ; file_list_ = new QListWidget ( ) ; file_list_ -> connect ( file_list_ , SIGNAL ( itemDoubleClicked ( QListWidgetItem * ) ) , this , SLOT ( build ( ) ) ) ; QCheckBox * primary_checkbox = new QCheckBox ( " Show ▁ primary ▁ edges ▁ only . " ) ; connect ( primary_checkbox , SIGNAL ( clicked ( ) ) , this , SLOT ( primary_edges_only ( ) ) ) ; QCheckBox * internal_checkbox = new QCheckBox ( " Show ▁ internal ▁ edges ▁ only . " ) ; connect ( internal_checkbox , SIGNAL ( clicked ( ) ) , this , SLOT ( internal_edges_only ( ) ) ) ; QPushButton * browse_button = new QPushButton ( tr ( " Browse ▁ Input ▁ Directory " ) ) ; connect ( browse_button , SIGNAL ( clicked ( ) ) , this , SLOT ( browse ( ) ) ) ; browse_button -> setMinimumHeight ( 50 ) ; QPushButton * print_scr_button = new QPushButton ( tr ( " Make ▁ Screenshot " ) ) ; connect ( print_scr_button , SIGNAL ( clicked ( ) ) , this , SLOT ( print_scr ( ) ) ) ; print_scr_button -> setMinimumHeight ( 50 ) ; file_layout -> addWidget ( message_label_ , 0 , 0 ) ; file_layout -> addWidget ( file_list_ , 1 , 0 ) ; file_layout -> addWidget ( primary_checkbox , 2 , 0 ) ; file_layout -> addWidget ( internal_checkbox , 3 , 0 ) ; file_layout -> addWidget ( browse_button , 4 , 0 ) ; file_layout -> addWidget ( print_scr_button , 5 , 0 ) ; return file_layout ; } void update_file_list ( ) { QFileInfoList list = file_dir_ . entryInfoList ( ) ; file_list_ -> clear ( ) ; if ( file_dir_ . count ( ) == 0 ) { return ; } QFileInfoList :: const_iterator it ; for ( it = list . begin ( ) ; it != list . end ( ) ; it ++ ) { file_list_ -> addItem ( it -> fileName ( ) ) ; } file_list_ -> setCurrentRow ( 0 ) ; } QDir file_dir_ ; QString file_name_ ; GLWidget * glWidget_ ; QListWidget * file_list_ ; QLabel * message_label_ ; } ; int main ( int argc , char * argv [ ] ) { QApplication app ( argc , argv ) ; MainWindow window ; window . show ( ) ; return app . exec ( ) ; } # include " voronoi _ visualizer . moc " </DOCUMENT>
<DOCUMENT_ID="quang-ha/lammps/tree/master/lib/kokkos/core/src/eti/OpenMP/Kokkos_OpenMP_ViewCopyETIInst_int64_t_double_LayoutStride_Rank3.cpp"> # define KOKKOS_IMPL_COMPILING_LIBRARY true # include < Kokkos_Core . hpp > namespace Kokkos { namespace Impl { KOKKOS_IMPL_VIEWCOPY_ETI_INST ( double * * * , LayoutStride , LayoutRight , OpenMP , int64_t ) KOKKOS_IMPL_VIEWCOPY_ETI_INST ( double * * * , LayoutStride , LayoutLeft , OpenMP , int64_t ) KOKKOS_IMPL_VIEWCOPY_ETI_INST ( double * * * , LayoutStride , LayoutStride , OpenMP , int64_t ) KOKKOS_IMPL_VIEWFILL_ETI_INST ( double * * * , LayoutStride , OpenMP , int64_t ) } } </DOCUMENT>
<DOCUMENT_ID="Voyager1/xbmc/tree/master/xbmc/windowing/rpi/GLContextEGL.cpp"> # include " GLContextEGL . h " # include " guilib / IDirtyRegionSolver . h " # include " settings / AdvancedSettings . h " # include " utils / log . h " CGLContextEGL :: CGLContextEGL ( ) : m_eglDisplay ( EGL_NO_DISPLAY ) , m_eglSurface ( EGL_NO_SURFACE ) , m_eglContext ( EGL_NO_CONTEXT ) , m_eglConfig ( 0 ) { } CGLContextEGL :: ~ CGLContextEGL ( ) { Destroy ( ) ; } bool CGLContextEGL :: CreateDisplay ( EGLDisplay display , EGLint renderable_type , EGLint rendering_api ) { EGLint neglconfigs = 0 ; int major , minor ; EGLint surface_type = EGL_WINDOW_BIT ; if ( g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION || g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION ) surface_type |= EGL_SWAP_BEHAVIOR_PRESERVED_BIT ; EGLint attribs [ ] = { EGL_RED_SIZE , 8 , EGL_GREEN_SIZE , 8 , EGL_BLUE_SIZE , 8 , EGL_ALPHA_SIZE , 8 , EGL_DEPTH_SIZE , 16 , EGL_STENCIL_SIZE , 0 , EGL_SAMPLE_BUFFERS , 0 , EGL_SAMPLES , 0 , EGL_SURFACE_TYPE , surface_type , EGL_RENDERABLE_TYPE , renderable_type , EGL_NONE } ; if ( m_eglDisplay == EGL_NO_DISPLAY ) { m_eglDisplay = eglGetDisplay ( ( EGLNativeDisplayType ) display ) ; } if ( m_eglDisplay == EGL_NO_DISPLAY ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ get ▁ EGL ▁ display " ) ; return false ; } if ( ! eglInitialize ( m_eglDisplay , & major , & minor ) ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ initialize ▁ EGL ▁ display " ) ; return false ; } eglBindAPI ( rendering_api ) ; if ( ! eglChooseConfig ( m_eglDisplay , attribs , & m_eglConfig , 1 , & neglconfigs ) ) { CLog :: Log ( LOGERROR , " Failed ▁ to ▁ query ▁ number ▁ of ▁ EGL ▁ configs " ) ; return false ; } if ( neglconfigs <= 0 ) { CLog :: Log ( LOGERROR , " No ▁ suitable ▁ EGL ▁ configs ▁ found " ) ; return false ; } return true ; } bool CGLContextEGL :: CreateContext ( ) { int client_version = 2 ; const EGLint context_attribs [ ] = { EGL_CONTEXT_CLIENT_VERSION , client_version , EGL_NONE } ; if ( m_eglContext == EGL_NO_CONTEXT ) { m_eglContext = eglCreateContext ( m_eglDisplay , m_eglConfig , EGL_NO_CONTEXT , context_attribs ) ; } if ( m_eglContext == EGL_NO_CONTEXT ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ create ▁ EGL ▁ context " ) ; return false ; } return true ; } bool CGLContextEGL :: BindContext ( ) { if ( ! eglMakeCurrent ( m_eglDisplay , m_eglSurface , m_eglSurface , m_eglContext ) ) { CLog :: Log ( LOGERROR , " Failed ▁ to ▁ make ▁ context ▁ current ▁ % p ▁ % p ▁ % p " , m_eglDisplay , m_eglSurface , m_eglContext ) ; return false ; } return true ; } bool CGLContextEGL :: SurfaceAttrib ( ) { if ( g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION || g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION ) { if ( ( m_eglDisplay == EGL_NO_DISPLAY ) || ( m_eglSurface == EGL_NO_SURFACE ) ) { return false ; } if ( ! eglSurfaceAttrib ( m_eglDisplay , m_eglSurface , EGL_SWAP_BEHAVIOR , EGL_BUFFER_PRESERVED ) ) { CLog :: Log ( LOGDEBUG , " % s : ▁ Could ▁ not ▁ set ▁ EGL _ SWAP _ BEHAVIOR " , __FUNCTION__ ) ; } } return true ; } bool CGLContextEGL :: CreateSurface ( EGLNativeWindowType surface ) { m_eglSurface = eglCreateWindowSurface ( m_eglDisplay , m_eglConfig , surface , nullptr ) ; if ( m_eglSurface == EGL_NO_SURFACE ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ create ▁ EGL ▁ window ▁ surface ▁ % d " , eglGetError ( ) ) ; return false ; } return true ; } void CGLContextEGL :: Destroy ( ) { if ( m_eglContext != EGL_NO_CONTEXT ) { eglDestroyContext ( m_eglDisplay , m_eglContext ) ; eglMakeCurrent ( m_eglDisplay , EGL_NO_SURFACE , EGL_NO_SURFACE , EGL_NO_CONTEXT ) ; m_eglContext = EGL_NO_CONTEXT ; } if ( m_eglSurface != EGL_NO_SURFACE ) { eglDestroySurface ( m_eglDisplay , m_eglSurface ) ; m_eglSurface = EGL_NO_SURFACE ; } if ( m_eglDisplay != EGL_NO_DISPLAY ) { eglTerminate ( m_eglDisplay ) ; m_eglDisplay = EGL_NO_DISPLAY ; } } void CGLContextEGL :: Detach ( ) { if ( m_eglContext != EGL_NO_CONTEXT ) { eglMakeCurrent ( m_eglDisplay , EGL_NO_SURFACE , EGL_NO_SURFACE , EGL_NO_CONTEXT ) ; } if ( m_eglSurface != EGL_NO_SURFACE ) { eglDestroySurface ( m_eglDisplay , m_eglSurface ) ; m_eglSurface = EGL_NO_SURFACE ; } } bool CGLContextEGL :: SetVSync ( bool enable ) { if ( ! eglSwapInterval ( m_eglDisplay , enable ) ) { return false ; } return true ; } void CGLContextEGL :: SwapBuffers ( ) { if ( m_eglDisplay == EGL_NO_DISPLAY || m_eglSurface == EGL_NO_SURFACE ) { return ; } eglSwapBuffers ( m_eglDisplay , m_eglSurface ) ; } </DOCUMENT>
<DOCUMENT_ID="thiphariel/navitia/tree/master/source/kraken/tests/data_manager_test.cpp"> # define BOOST_TEST_DYN_LINK # define BOOST_TEST_MODULE data_manager_test # include < boost / test / unit_test . hpp > # include < boost / optional . hpp > # include " kraken / data _ manager . h " # include < atomic > class Data { public : bool load ( const std :: string & , const boost :: optional < std :: string > & , const std :: vector < std :: string > & ) { return load_status ; } mutable std :: atomic < bool > is_connected_to_rabbitmq ; static bool load_status ; static bool destructor_called ; size_t data_identifier ; Data ( size_t data_identifier = 0 ) : data_identifier ( data_identifier ) { is_connected_to_rabbitmq = false ; } ~ Data ( ) { Data :: destructor_called = true ; } } ; bool Data :: load_status = true ; bool Data :: destructor_called = false ; struct fixture { fixture ( ) { Data :: load_status = true ; Data :: destructor_called = false ; } } ; BOOST_FIXTURE_TEST_SUITE ( s , fixture ) BOOST_AUTO_TEST_CASE ( get_data ) { DataManager < Data > data_manager ; auto data = data_manager . get_data ( ) ; BOOST_REQUIRE ( data ) ; BOOST_CHECK_EQUAL ( Data :: destructor_called , false ) ; } BOOST_AUTO_TEST_CASE ( load_success ) { DataManager < Data > data_manager ; auto first_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , data_manager . get_data ( ) ) ; BOOST_CHECK ( data_manager . load ( " " ) ) ; auto second_data = data_manager . get_data ( ) ; BOOST_CHECK_NE ( first_data , second_data ) ; BOOST_CHECK_EQUAL ( Data :: destructor_called , false ) ; } BOOST_AUTO_TEST_CASE ( load_fail ) { DataManager < Data > data_manager ; auto first_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , data_manager . get_data ( ) ) ; Data :: load_status = false ; BOOST_CHECK ( ! data_manager . load ( " " ) ) ; Data :: load_status = true ; auto second_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , second_data ) ; } BOOST_AUTO_TEST_CASE ( destructor_called ) { DataManager < Data > data_manager ; { auto first_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , data_manager . get_data ( ) ) ; BOOST_CHECK ( data_manager . load ( " " ) ) ; auto second_data = data_manager . get_data ( ) ; BOOST_CHECK_NE ( first_data , second_data ) ; BOOST_CHECK_EQUAL ( Data :: destructor_called , false ) ; first_data = boost :: shared_ptr < Data > ( ) ; } BOOST_CHECK_EQUAL ( Data :: destructor_called , true ) ; BOOST_CHECK ( data_manager . get_data ( ) ) ; } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
<DOCUMENT_ID="daedalus/iodoom3/tree/master/neo/tools/materialeditor/MaterialDocManager.cpp"> # include " . . / . . / idlib / precompiled . h " # pragma hdrstop # include " MaterialDocManager . h " # include " MaterialView . h " MaterialDocManager :: MaterialDocManager ( void ) { currentMaterial = NULL ; cutMaterial = false ; } MaterialDocManager :: ~ MaterialDocManager ( void ) { UnRegisterAllMaterialViews ( ) ; ClearUndo ( ) ; ClearRedo ( ) ; } void MaterialDocManager :: RegisterMaterialView ( MaterialView * view ) { ASSERT ( view ) ; UnRegisterMaterialView ( view ) ; materialViews . Append ( view ) ; view -> SetMaterialDocManager ( this ) ; } void MaterialDocManager :: UnRegisterMaterialView ( MaterialView * view ) { ASSERT ( view ) ; materialViews . Remove ( view ) ; view -> SetMaterialDocManager ( NULL ) ; } void MaterialDocManager :: UnRegisterAllMaterialViews ( ) { int c = materialViews . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { materialViews [ i ] -> SetMaterialDocManager ( NULL ) ; } materialViews . Clear ( ) ; } void MaterialDocManager :: SetSelectedMaterial ( idMaterial * material ) { bool change = false ; if ( material ) { if ( currentMaterial ) { if ( strcmp ( material -> GetName ( ) , currentMaterial -> renderMaterial -> GetName ( ) ) ) { change = true ; } } else { change = true ; } } else { if ( currentMaterial ) { change = true ; } } if ( change ) { if ( currentMaterial ) { if ( ! inProgressMaterials . Get ( currentMaterial -> name . c_str ( ) ) ) { delete currentMaterial ; currentMaterial = NULL ; } } MaterialDoc * * tempDoc ; if ( material && inProgressMaterials . Get ( material -> GetName ( ) , & tempDoc ) ) { currentMaterial = * tempDoc ; } else { currentMaterial = CreateMaterialDoc ( material ) ; } NotifyViews ( currentMaterial , SELECTION_CHANGE ) ; } } bool MaterialDocManager :: DoesFileNeedApply ( const char * filename ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) && ( * pDoc ) -> applyWaiting ) return true ; } return false ; } bool MaterialDocManager :: DoesAnyNeedApply ( ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ( * pDoc ) -> applyWaiting ) return true ; } return false ; } bool MaterialDocManager :: IsFileModified ( const char * filename ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) return true ; } return false ; } bool MaterialDocManager :: IsAnyModified ( ) { return ( inProgressMaterials . Num ( ) > 0 ) ; } void MaterialDocManager :: AddMaterial ( const char * name , const char * filename , const char * sourceText , bool addUndo ) { if ( addUndo ) { AddMaterialModifier * mod = new AddMaterialModifier ( this , name , filename ) ; AddMaterialUndoModifier ( mod ) ; } MaterialDoc * newDoc = new MaterialDoc ( ) ; newDoc -> manager = this ; newDoc -> modified = true ; idMaterial * rendMat = ( idMaterial * ) declManager -> CreateNewDecl ( DECL_MATERIAL , name , filename ) ; if ( sourceText ) { rendMat -> SetText ( sourceText ) ; } newDoc -> SetRenderMaterial ( rendMat , true , sourceText ? true : false ) ; inProgressMaterials . Set ( newDoc -> name . c_str ( ) , newDoc ) ; NotifyViews ( newDoc , MATERIAL_ADD ) ; newDoc -> applyWaiting = true ; newDoc -> ApplyMaterialChanges ( ) ; } void MaterialDocManager :: RedoAddMaterial ( const char * name , bool clearData ) { MaterialDoc * newDoc = new MaterialDoc ( ) ; newDoc -> manager = this ; newDoc -> modified = true ; idMaterial * rendMat = const_cast < idMaterial * > ( declManager -> FindMaterial ( name , false ) ) ; if ( clearData ) { rendMat -> SetText ( rendMat -> DefaultDefinition ( ) ) ; } newDoc -> SetRenderMaterial ( rendMat , true , true ) ; inProgressMaterials . Set ( newDoc -> name . c_str ( ) , newDoc ) ; NotifyViews ( newDoc , MATERIAL_ADD ) ; newDoc -> applyWaiting = true ; newDoc -> ApplyMaterialChanges ( ) ; } void MaterialDocManager :: DeleteMaterial ( MaterialDoc * material , bool addUndo ) { assert ( material ) ; material -> Delete ( ) ; if ( addUndo ) { DeleteMaterialModifier * mod = new DeleteMaterialModifier ( this , material -> name ) ; AddMaterialUndoModifier ( mod ) ; } NotifyViews ( material , MATERIAL_DELETE ) ; } void MaterialDocManager :: ApplyMaterial ( MaterialDoc * materialDoc ) { assert ( materialDoc ) ; materialDoc -> ApplyMaterialChanges ( ) ; } void MaterialDocManager :: ApplyFile ( const char * filename ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) ( * pDoc ) -> ApplyMaterialChanges ( ) ; } } void MaterialDocManager :: ApplyAll ( ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; ( * pDoc ) -> ApplyMaterialChanges ( ) ; } } void MaterialDocManager :: SaveMaterial ( MaterialDoc * material ) { assert ( material ) ; material -> Save ( ) ; } void MaterialDocManager :: SaveFile ( const char * filename ) { for ( int i = inProgressMaterials . Num ( ) - 1 ; i >= 0 ; i -- ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) ( * pDoc ) -> Save ( ) ; } NotifyViews ( NULL , MATERIAL_SAVE_FILE , filename ) ; } void MaterialDocManager :: SaveAllMaterials ( ) { for ( int i = inProgressMaterials . Num ( ) - 1 ; i >= 0 ; i -- ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; ( * pDoc ) -> Save ( ) ; } } void MaterialDocManager :: ReloadFile ( const char * filename ) { declManager -> ReloadFile ( filename , true ) ; for ( int j = inProgressMaterials . Num ( ) - 1 ; j >= 0 ; j -- ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( j ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) { ( * pDoc ) -> SetRenderMaterial ( ( * pDoc ) -> renderMaterial ) ; inProgressMaterials . Remove ( ( * pDoc ) -> name ) ; } } if ( currentMaterial ) { currentMaterial -> SetRenderMaterial ( currentMaterial -> renderMaterial ) ; NotifyViews ( currentMaterial , SELECTION_CHANGE ) ; } NotifyViews ( NULL , FILE_RELOAD , filename ) ; } MaterialDoc * MaterialDocManager :: CreateMaterialDoc ( const char * materialName ) { const idMaterial * material = declManager -> FindMaterial ( materialName ) ; return CreateMaterialDoc ( const_cast < idMaterial * > ( material ) ) ; } MaterialDoc * MaterialDocManager :: CreateMaterialDoc ( idMaterial * material ) { MaterialDoc * existingDoc = GetInProgressDoc ( material ) ; if ( existingDoc ) { return existingDoc ; } if ( currentMaterial && material && ! currentMaterial -> name . Icmp ( material -> GetName ( ) ) ) { return currentMaterial ; } if ( material ) { MaterialDoc * newDoc = new MaterialDoc ( ) ; newDoc -> manager = this ; newDoc -> SetRenderMaterial ( material ) ; return newDoc ; } return NULL ; } MaterialDoc * MaterialDocManager :: GetInProgressDoc ( idMaterial * material ) { if ( material ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! ( * pDoc ) -> name . Icmp ( material -> GetName ( ) ) ) return * pDoc ; } } return NULL ; } void MaterialDocManager :: CopyMaterial ( MaterialDoc * materialDoc , bool cut ) { cutMaterial = cut ; if ( materialDoc ) copyMaterial = materialDoc -> name ; else ClearCopy ( ) ; } void MaterialDocManager :: ClearCopy ( ) { copyMaterial . Empty ( ) ; } bool MaterialDocManager :: IsCopyMaterial ( ) { return ( copyMaterial . Length ( ) ) ? true : false ; } idStr MaterialDocManager :: GetCopyMaterialName ( ) { return copyMaterial ; } void MaterialDocManager :: PasteMaterial ( const char * name , const char * filename ) { if ( ! IsCopyMaterial ( ) ) { return ; } MaterialDoc * copyMat = CreateMaterialDoc ( copyMaterial ) ; if ( copyMat -> applyWaiting ) { copyMat -> ApplyMaterialChanges ( ) ; } idMaterial * material = copyMat -> renderMaterial ; char * declText = ( char * ) _alloca ( material -> GetTextLength ( ) + 1 ) ; material -> GetText ( declText ) ; AddMaterial ( name , filename , declText , ! cutMaterial ) ; if ( cutMaterial ) { MaterialDoc * cutMaterial = CreateMaterialDoc ( material ) ; DeleteMaterial ( cutMaterial , false ) ; MoveMaterialModifier * mod = new MoveMaterialModifier ( this , name , filename , copyMaterial ) ; AddMaterialUndoModifier ( mod ) ; ClearCopy ( ) ; } } void MaterialDocManager :: CopyStage ( MaterialDoc * materialDoc , int stageNum ) { assert ( materialDoc ) ; copyStageMaterial = materialDoc -> name ; copyStage = materialDoc -> GetStage ( stageNum ) ; idStr stageName = copyStage . stageData . GetString ( " name " ) ; } void MaterialDocManager :: ClearCopyStage ( ) { copyStageMaterial . Empty ( ) ; copyStage . stageData . Clear ( ) ; } bool MaterialDocManager :: IsCopyStage ( ) { return ( copyStageMaterial . Length ( ) ) ? true : false ; } void MaterialDocManager :: PasteStage ( MaterialDoc * materialDoc ) { assert ( materialDoc ) ; int stageType = copyStage . stageData . GetInt ( " stagetype " ) ; materialDoc -> AddStage ( stageType , copyStage . stageData . GetString ( " name " ) ) ; materialDoc -> SetData ( materialDoc -> GetStageCount ( ) - 1 , & copyStage . stageData ) ; } void MaterialDocManager :: GetCopyStageInfo ( int & type , idStr & name ) { if ( IsCopyStage ( ) ) { type = copyStage . stageData . GetInt ( " stagetype " ) ; name = copyStage . stageData . GetString ( " name " ) ; } } void MaterialDocManager :: Undo ( ) { if ( IsUndoAvailable ( ) ) { MaterialModifier * mod = undoModifiers [ undoModifiers . Num ( ) - 1 ] ; undoModifiers . RemoveIndex ( undoModifiers . Num ( ) - 1 ) ; mod -> Undo ( ) ; AddMaterialRedoModifier ( mod ) ; } } bool MaterialDocManager :: IsUndoAvailable ( ) { return ( undoModifiers . Num ( ) > 0 ) ; } void MaterialDocManager :: ClearUndo ( ) { int c = undoModifiers . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { delete undoModifiers [ i ] ; } undoModifiers . Clear ( ) ; } void MaterialDocManager :: Redo ( ) { if ( IsRedoAvailable ( ) ) { MaterialModifier * mod = redoModifiers [ redoModifiers . Num ( ) - 1 ] ; redoModifiers . RemoveIndex ( redoModifiers . Num ( ) - 1 ) ; mod -> Redo ( ) ; AddMaterialUndoModifier ( mod , false ) ; } } bool MaterialDocManager :: IsRedoAvailable ( ) { return ( redoModifiers . Num ( ) > 0 ) ; } void MaterialDocManager :: ClearRedo ( ) { int c = redoModifiers . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { delete redoModifiers [ i ] ; } redoModifiers . Clear ( ) ; } void MaterialDocManager :: AddMaterialUndoModifier ( MaterialModifier * mod , bool clearRedo ) { undoModifiers . Append ( mod ) ; while ( undoModifiers . Num ( ) > MAX_UNDOREDO ) { undoModifiers . RemoveIndex ( 0 ) ; } if ( clearRedo ) { ClearRedo ( ) ; } } void MaterialDocManager :: AddMaterialRedoModifier ( MaterialModifier * mod ) { redoModifiers . Append ( mod ) ; while ( redoModifiers . Num ( ) > MAX_UNDOREDO ) { redoModifiers . RemoveIndex ( 0 ) ; } } bool MaterialDocManager :: FindMaterial ( const char * name , MaterialSearchData_t * searchData , bool checkName ) { const idMaterial * material = static_cast < const idMaterial * > ( declManager -> FindDeclWithoutParsing ( DECL_MATERIAL , name , false ) ) ; if ( material ) { int findPos ; if ( checkName ) { idStr name = material -> GetName ( ) ; findPos = name . Find ( searchData -> searchText , false ) ; if ( findPos != - 1 ) { return true ; } } char * declText = ( char * ) _alloca ( material -> GetTextLength ( ) + 1 ) ; material -> GetText ( declText ) ; idStr text = declText ; int start = text . Find ( " { " ) ; if ( start != - 1 ) { text = text . Right ( text . Length ( ) - start ) ; } findPos = text . Find ( searchData -> searchText , false ) ; if ( findPos != - 1 ) { return true ; } } return false ; } idStr MaterialDocManager :: GetUniqueMaterialName ( idStr name ) { int num = 0 ; while ( 1 ) { idStr testName ; if ( num == 0 ) testName = name ; else testName = va ( " % s % d " , name . c_str ( ) , num ) ; const idMaterial * mat = declManager -> FindMaterial ( testName . c_str ( ) , false ) ; if ( ! mat ) { return testName ; } else { if ( mat -> GetTextLength ( ) < 1 ) return testName ; } num ++ ; } } void MaterialDocManager :: NotifyViews ( MaterialDoc * materialDoc , int notifyType , ... ) { va_list argptr ; int c = materialViews . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { va_start ( argptr , notifyType ) ; switch ( notifyType ) { case SELECTION_CHANGE : materialViews [ i ] -> MV_OnMaterialSelectionChange ( materialDoc ) ; break ; case MATERIAL_CHANGE : materialViews [ i ] -> MV_OnMaterialChange ( materialDoc ) ; break ; case MATERIAL_APPLY : materialViews [ i ] -> MV_OnMaterialApply ( materialDoc ) ; break ; case MATERIAL_SAVE : materialViews [ i ] -> MV_OnMaterialSaved ( materialDoc ) ; break ; case MATERIAL_SAVE_FILE : materialViews [ i ] -> MV_OnMaterialSaveFile ( va_arg ( argptr , const char * ) ) ; break ; case MATERIAL_ADD : materialViews [ i ] -> MV_OnMaterialAdd ( materialDoc ) ; break ; case MATERIAL_DELETE : materialViews [ i ] -> MV_OnMaterialDelete ( materialDoc ) ; break ; case MATERIAL_ADD_STAGE : materialViews [ i ] -> MV_OnMaterialStageAdd ( materialDoc , va_arg ( argptr , int ) ) ; break ; case MATERIAL_DELETE_STAGE : materialViews [ i ] -> MV_OnMaterialStageDelete ( materialDoc , va_arg ( argptr , int ) ) ; break ; case MATERIAL_MOVE_STAGE : { int from = va_arg ( argptr , int ) ; int to = va_arg ( argptr , int ) ; materialViews [ i ] -> MV_OnMaterialStageMove ( materialDoc , from , to ) ; } break ; case MATERIAL_ATTRIBUTE_CHANGE : { int stage = va_arg ( argptr , int ) ; const char * attribName = va_arg ( argptr , const char * ) ; materialViews [ i ] -> MV_OnMaterialAttributeChanged ( materialDoc , stage , attribName ) ; } break ; case MATERIAL_NAME_CHANGE : { const char * oldName = va_arg ( argptr , const char * ) ; materialViews [ i ] -> MV_OnMaterialNameChanged ( materialDoc , oldName ) ; } break ; case FILE_RELOAD : { const char * filename = va_arg ( argptr , const char * ) ; materialViews [ i ] -> MV_OnFileReload ( filename ) ; } break ; } va_end ( argptr ) ; } } void MaterialDocManager :: MaterialChanged ( MaterialDoc * materialDoc ) { if ( ! inProgressMaterials . Get ( materialDoc -> name . c_str ( ) ) ) { inProgressMaterials . Set ( materialDoc -> name . c_str ( ) , materialDoc ) ; } NotifyViews ( materialDoc , MATERIAL_CHANGE ) ; } void MaterialDocManager :: MaterialApplied ( MaterialDoc * materialDoc ) { NotifyViews ( materialDoc , MATERIAL_APPLY ) ; } void MaterialDocManager :: MaterialSaved ( MaterialDoc * materialDoc ) { MaterialDoc * * tempDoc ; if ( inProgressMaterials . Get ( materialDoc -> name . c_str ( ) , & tempDoc ) ) { idStr name = materialDoc -> name . c_str ( ) ; inProgressMaterials . Remove ( name . c_str ( ) ) ; NotifyViews ( materialDoc , MATERIAL_SAVE ) ; if ( materialDoc != currentMaterial ) delete materialDoc ; } } void MaterialDocManager :: MaterialNameChanged ( const char * oldName , MaterialDoc * materialDoc ) { MaterialDoc * * tempDoc ; if ( inProgressMaterials . Get ( oldName , & tempDoc ) ) { inProgressMaterials . Set ( materialDoc -> name , * tempDoc ) ; inProgressMaterials . Remove ( oldName ) ; } NotifyViews ( materialDoc , MATERIAL_NAME_CHANGE , oldName ) ; } void MaterialDocManager :: StageAdded ( MaterialDoc * materialDoc , int stageNum ) { NotifyViews ( materialDoc , MATERIAL_ADD_STAGE , stageNum ) ; } void MaterialDocManager :: StageDeleted ( MaterialDoc * materialDoc , int stageNum ) { NotifyViews ( materialDoc , MATERIAL_DELETE_STAGE , stageNum ) ; } void MaterialDocManager :: StageMoved ( MaterialDoc * materialDoc , int from , int to ) { NotifyViews ( materialDoc , MATERIAL_MOVE_STAGE , from , to ) ; } void MaterialDocManager :: AttributeChanged ( MaterialDoc * materialDoc , int stage , const char * attribName ) { NotifyViews ( materialDoc , MATERIAL_ATTRIBUTE_CHANGE , stage , attribName ) ; } </DOCUMENT>
<DOCUMENT_ID="YelaSeamless/mysql-server/tree/master/storage/ndb/test/ndbapi/testLimits.cpp"> # include < NDBT . hpp > # include < NDBT_Test . hpp > # include < NdbRestarter . hpp > # define CHECKNOTNULL ( p ) if ( ( p ) == NULL ) { ndbout << " Error ▁ at ▁ line ▁ " << __LINE__ << endl ; NDB_ERR ( trans -> getNdbError ( ) ) ; trans -> close ( ) ; return NDBT_FAILED ; } # define CHECKEQUAL ( v , e ) if ( ( e ) != ( v ) ) { ndbout << " Error ▁ at ▁ line ▁ " << __LINE__ << " ▁ expected ▁ " << v << endl ; NDB_ERR ( trans -> getNdbError ( ) ) ; trans -> close ( ) ; return NDBT_FAILED ; } Uint32 setLongVarchar ( char * where , const char * what , Uint32 sz ) { where [ 0 ] = sz & 0xff ; where [ 1 ] = ( sz >> 8 ) & 0xff ; memcpy ( & where [ 2 ] , what , sz ) ; return ( sz + 2 ) ; } int activateErrorInsert ( NdbTransaction * trans , const NdbRecord * record , const NdbDictionary :: Table * tab , const char * buf , NdbRestarter * restarter , Uint32 val ) { if ( restarter -> insertErrorInAllNodes ( val ) != 0 ) { g_err << " error ▁ insert ▁ 1 ▁ ( " << val << " ) ▁ failed " << endl ; return NDBT_FAILED ; } if ( restarter -> insertErrorInAllNodes ( val ) != 0 ) { g_err << " error ▁ insert ▁ 2 ▁ ( " << val << " ) ▁ failed " << endl ; return NDBT_FAILED ; } NdbOperation * insert = trans -> getNdbOperation ( tab ) ; CHECKNOTNULL ( insert ) ; CHECKEQUAL ( 0 , insert -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , insert -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , buf , 0 ) ) ) ; CHECKEQUAL ( 0 , insert -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , buf , 1 ) ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; return NDBT_OK ; } int testSegmentedSectionPk ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " WIDE _ 2COL " ) != 0 ) return NDBT_OK ; const Uint32 maxRowBytes = NDB_MAX_TUPLE_SIZE_IN_WORDS * sizeof ( Uint32 ) ; const Uint32 maxKeyBytes = NDBT_Tables :: MaxVarTypeKeyBytes ; const Uint32 maxAttrBytes = NDBT_Tables :: MaxKeyMaxVarTypeAttrBytes ; const Uint32 srcBuffBytes = MAX ( maxKeyBytes , maxAttrBytes ) ; char smallKey [ 50 ] ; char srcBuff [ srcBuffBytes ] ; char smallRowBuf [ maxRowBytes ] ; char bigKeyRowBuf [ maxRowBytes ] ; char bigAttrRowBuf [ maxRowBytes ] ; Uint32 smallKeySize = setLongVarchar ( & smallKey [ 0 ] , " ShortKey " , 8 ) ; memset ( srcBuff , ' B ' , srcBuffBytes ) ; const NdbRecord * record = ctx -> getTab ( ) -> getDefaultRecord ( ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , smallRowBuf , 0 ) , " ShortKey " , 8 ) ; NdbDictionary :: setNull ( record , smallRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , smallRowBuf , 1 ) , " ShortData " , 9 ) ; NdbDictionary :: setNull ( record , smallRowBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , bigKeyRowBuf , 0 ) , & srcBuff [ 0 ] , maxKeyBytes ) ; NdbDictionary :: setNull ( record , bigKeyRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , bigKeyRowBuf , 1 ) , " ShortData " , 9 ) ; NdbDictionary :: setNull ( record , bigKeyRowBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , bigAttrRowBuf , 0 ) , " ShortKey " , 8 ) ; NdbDictionary :: setNull ( record , bigAttrRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , bigAttrRowBuf , 1 ) , & srcBuff [ 0 ] , maxAttrBytes ) ; NdbDictionary :: setNull ( record , bigAttrRowBuf , 1 , false ) ; NdbRestarter restarter ; Ndb * pNdb = GETNDB ( step ) ; NdbTransaction * trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ; CHECKNOTNULL ( trans ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , record , ctx -> getTab ( ) , smallRowBuf , & restarter , 8065 ) ) ; const NdbOperation * bigInsert = trans -> insertTuple ( record , bigKeyRowBuf ) ; CHECKNOTNULL ( bigInsert ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsert = trans -> insertTuple ( record , bigAttrRowBuf ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsert = trans -> insertTuple ( record , bigAttrRowBuf ) ) ; const NdbOperation * secondOp ; CHECKNOTNULL ( secondOp = trans -> insertTuple ( record , bigAttrRowBuf ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; NdbOperation * bigInsertOldApi ; CHECKNOTNULL ( bigInsertOldApi = trans -> getNdbOperation ( ctx -> getTab ( ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , bigKeyRowBuf , 0 ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , bigKeyRowBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsertOldApi = trans -> getNdbOperation ( ctx -> getTab ( ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , bigAttrRowBuf , 0 ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , bigAttrRowBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; # if 0 restarter . insertErrorInAllNodes ( 8066 ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsertOldApi = trans -> getNdbOperation ( ctx -> getTab ( ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , smallRowBuf , 0 ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; restarter . insertErrorInAllNodes ( 8067 ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsertOldApi = trans -> getNdbOperation ( ctx -> getTab ( ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , smallRowBuf , 0 ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; # endif CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , record , ctx -> getTab ( ) , smallRowBuf , & restarter , 8068 ) ) ; trans -> execute ( NdbTransaction :: Rollback ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; return NDBT_OK ; } int testSegmentedSectionIx ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " WIDE _ 2COL _ IX " ) != 0 ) return NDBT_OK ; const char * indexName = " WIDE _ 2COL _ IX $ NDBT _ IDX0" ; const Uint32 maxRowBytes = NDB_MAX_TUPLE_SIZE_IN_WORDS * sizeof ( Uint32 ) ; const Uint32 srcBuffBytes = NDBT_Tables :: MaxVarTypeKeyBytes ; const Uint32 maxIndexKeyBytes = NDBT_Tables :: MaxKeyMaxVarTypeAttrBytesIndex ; const Uint32 mediumPrimaryKeyBytes = ( 6 * 60 * 4 ) - 2 ; char smallKey [ 50 ] ; char srcBuff [ srcBuffBytes ] ; char smallRowBuf [ maxRowBytes ] ; char bigKeyIxBuf [ maxRowBytes ] ; char bigAttrIxBuf [ maxRowBytes ] ; char bigKeyRowBuf [ maxRowBytes ] ; char resultSpace [ maxRowBytes ] ; Uint32 smallKeySize = setLongVarchar ( & smallKey [ 0 ] , " ShortKey " , 8 ) ; memset ( srcBuff , ' B ' , srcBuffBytes ) ; Ndb * pNdb = GETNDB ( step ) ; const NdbRecord * baseRecord = ctx -> getTab ( ) -> getDefaultRecord ( ) ; const NdbRecord * ixRecord = pNdb -> getDictionary ( ) -> getIndex ( indexName , ctx -> getTab ( ) -> getName ( ) ) -> getDefaultRecord ( ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 0 ) , " ShortKey " , 8 ) ; NdbDictionary :: setNull ( baseRecord , smallRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 1 ) , " ShortData " , 9 ) ; NdbDictionary :: setNull ( baseRecord , smallRowBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( ixRecord , bigKeyIxBuf , 1 ) , & srcBuff [ 0 ] , maxIndexKeyBytes ) ; NdbDictionary :: setNull ( ixRecord , bigKeyIxBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 0 ) , " ShortIXKey " , 10 ) ; NdbDictionary :: setNull ( baseRecord , bigAttrIxBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 1 ) , & srcBuff [ 0 ] , maxIndexKeyBytes ) ; NdbDictionary :: setNull ( baseRecord , bigAttrIxBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , bigKeyRowBuf , 0 ) , & srcBuff [ 0 ] , mediumPrimaryKeyBytes ) ; NdbDictionary :: setNull ( baseRecord , bigKeyRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , bigKeyRowBuf , 1 ) , " ShortIXKey " , 10 ) ; NdbDictionary :: setNull ( baseRecord , bigKeyRowBuf , 1 , false ) ; NdbTransaction * trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ; CHECKNOTNULL ( trans -> insertTuple ( baseRecord , bigKeyRowBuf ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: Commit ) ) ; NdbRestarter restarter ; trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ; CHECKNOTNULL ( trans ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , baseRecord , ctx -> getTab ( ) , smallRowBuf , & restarter , 8065 ) ) ; const NdbOperation * bigRead = trans -> readTuple ( ixRecord , bigKeyIxBuf , baseRecord , resultSpace ) ; CHECKNOTNULL ( bigRead ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( trans -> readTuple ( ixRecord , bigKeyIxBuf , baseRecord , resultSpace ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( trans -> readTuple ( ixRecord , bigKeyIxBuf , baseRecord , resultSpace ) ) ; CHECKNOTNULL ( trans -> readTuple ( ixRecord , bigKeyIxBuf , baseRecord , resultSpace ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , baseRecord , ctx -> getTab ( ) , smallRowBuf , & restarter , 8066 ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKNOTNULL ( bigRead = trans -> readTuple ( ixRecord , bigAttrIxBuf , baseRecord , resultSpace ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; # if 0 CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; const NdbDictionary :: Index * index ; CHECKNOTNULL ( index = pNdb -> getDictionary ( ) -> getIndex ( indexName , ctx -> getTab ( ) -> getName ( ) ) ) ; NdbIndexOperation * bigReadOldApi ; CHECKNOTNULL ( bigReadOldApi = trans -> getNdbIndexOperation ( index ) ) ; CHECKEQUAL ( 0 , bigReadOldApi -> readTuple ( ) ) ; CHECKEQUAL ( 0 , bigReadOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( ixRecord , bigKeyIxBuf , 1 ) ) ) ; CHECKNOTNULL ( bigReadOldApi -> getValue ( ( Uint32 ) 1 ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; NdbIndexOperation * bigUpdateOldApi ; CHECKNOTNULL ( bigUpdateOldApi = trans -> getNdbIndexOperation ( index ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> updateTuple ( ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> setValue ( ( Uint32 ) 1 , NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; restarter . insertErrorInAllNodes ( 8066 ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigUpdateOldApi = trans -> getNdbIndexOperation ( index ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> updateTuple ( ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> setValue ( ( Uint32 ) 1 , NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; restarter . insertErrorInAllNodes ( 8067 ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigUpdateOldApi = trans -> getNdbIndexOperation ( index ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> updateTuple ( ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> setValue ( ( Uint32 ) 1 , NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; # endif CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , baseRecord , ctx -> getTab ( ) , smallRowBuf , & restarter , 8068 ) ) ; trans -> execute ( NdbTransaction :: Rollback ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; return NDBT_OK ; } int testSegmentedSectionScan ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " WIDE _ 2COL " ) != 0 ) return NDBT_OK ; const Uint32 maxRowBytes = NDB_MAX_TUPLE_SIZE_IN_WORDS * sizeof ( Uint32 ) ; char smallKey [ 50 ] ; char smallRowBuf [ maxRowBytes ] ; Uint32 smallKeySize = setLongVarchar ( & smallKey [ 0 ] , " ShortKey " , 8 ) ; const NdbRecord * record = ctx -> getTab ( ) -> getDefaultRecord ( ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , smallRowBuf , 0 ) , " ShortKey " , 8 ) ; NdbDictionary :: setNull ( record , smallRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , smallRowBuf , 1 ) , " ShortData " , 9 ) ; NdbDictionary :: setNull ( record , smallRowBuf , 1 , false ) ; NdbRestarter restarter ; Ndb * pNdb = GETNDB ( step ) ; NdbTransaction * trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ; CHECKNOTNULL ( trans ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , record , ctx -> getTab ( ) , smallRowBuf , & restarter , 8066 ) ) ; NdbScanOperation * scan = trans -> getNdbScanOperation ( ctx -> getTab ( ) ) ; CHECKNOTNULL ( scan ) ; CHECKEQUAL ( 0 , scan -> readTuples ( ) ) ; NdbInterpretedCode prog ; for ( Uint32 w = 0 ; w < 2500 ; w ++ ) CHECKEQUAL ( 0 , prog . load_const_null ( 1 ) ) ; CHECKEQUAL ( 0 , prog . interpret_exit_ok ( ) ) ; CHECKEQUAL ( 0 , prog . finalise ( ) ) ; CHECKEQUAL ( 0 , scan -> setInterpretedCode ( & prog ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; CHECKEQUAL ( - 1 , scan -> nextResult ( ) ) ; CHECKEQUAL ( 217 , scan -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , record , ctx -> getTab ( ) , smallRowBuf , & restarter , 8068 ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: Rollback ) ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; return NDBT_OK ; } int testDropSignalFragments ( NDBT_Context * ctx , NDBT_Step * step ) { NdbRestarter restarter ; Ndb * pNdb = GETNDB ( step ) ; const Uint32 PROG_WORDS = 16500 ; struct SubCase { Uint32 errorInsertCode ; int expectedRc ; } ; const Uint32 numSubCases = 5 ; const SubCase cases [ numSubCases ] = { { 0 , 874 } , { 8074 , 217 } , { 8075 , 217 } , { 8076 , 217 } , { 8077 , 217 } } ; const Uint32 numIterations = 50 ; Uint32 buff [ PROG_WORDS + 10 ] ; for ( Uint32 iteration = 0 ; iteration < ( numIterations * numSubCases ) ; iteration ++ ) { NdbTransaction * trans = pNdb -> startTransaction ( ) ; CHECKNOTNULL ( trans ) ; SubCase subcase = cases [ iteration % numSubCases ] ; Uint32 errorInsertVal = subcase . errorInsertCode ; CHECKEQUAL ( 0 , restarter . insertErrorInAllNodes ( errorInsertVal ) ) ; CHECKEQUAL ( 0 , restarter . insertErrorInAllNodes ( errorInsertVal ) ) ; NdbScanOperation * scan = trans -> getNdbScanOperation ( ctx -> getTab ( ) ) ; CHECKNOTNULL ( scan ) ; CHECKEQUAL ( 0 , scan -> readTuples ( ) ) ; NdbInterpretedCode prog ( ctx -> getTab ( ) , buff , PROG_WORDS + 10 ) ; for ( Uint32 w = 0 ; w < PROG_WORDS ; w ++ ) CHECKEQUAL ( 0 , prog . load_const_null ( 1 ) ) ; CHECKEQUAL ( 0 , prog . interpret_exit_ok ( ) ) ; CHECKEQUAL ( 0 , prog . finalise ( ) ) ; CHECKEQUAL ( 0 , scan -> setInterpretedCode ( & prog ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; CHECKEQUAL ( - 1 , scan -> nextResult ( ) ) ; int expectedResult = subcase . expectedRc ; CHECKEQUAL ( expectedResult , scan -> getNdbError ( ) . code ) ; scan -> close ( ) ; trans -> close ( ) ; } restarter . insertErrorInAllNodes ( 0 ) ; return NDBT_OK ; } int create100Tables ( NDBT_Context * ctx , NDBT_Step * step ) { Ndb * pNdb = GETNDB ( step ) ; const NdbDictionary :: Table * pTab = ctx -> getTab ( ) ; if ( strcmp ( pTab -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; for ( Uint32 t = 0 ; t < 100 ; t ++ ) { char tabnameBuff [ 10 ] ; snprintf ( tabnameBuff , sizeof ( tabnameBuff ) , " TAB % u " , t ) ; NdbDictionary :: Table tab ; tab . setName ( tabnameBuff ) ; NdbDictionary :: Column pk ; pk . setName ( " PK " ) ; pk . setType ( NdbDictionary :: Column :: Varchar ) ; pk . setLength ( 20 ) ; pk . setNullable ( false ) ; pk . setPrimaryKey ( true ) ; tab . addColumn ( pk ) ; pNdb -> getDictionary ( ) -> dropTable ( tab . getName ( ) ) ; if ( pNdb -> getDictionary ( ) -> createTable ( tab ) != 0 ) { ndbout << " Create ▁ table ▁ failed ▁ with ▁ error ▁ : ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . code << " ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . message << endl ; return NDBT_FAILED ; } ndbout << " Created ▁ table ▁ " << tabnameBuff << endl ; } return NDBT_OK ; } int drop100Tables ( NDBT_Context * ctx , NDBT_Step * step ) { Ndb * pNdb = GETNDB ( step ) ; const NdbDictionary :: Table * pTab = ctx -> getTab ( ) ; if ( strcmp ( pTab -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; for ( Uint32 t = 0 ; t < 100 ; t ++ ) { char tabnameBuff [ 10 ] ; snprintf ( tabnameBuff , sizeof ( tabnameBuff ) , " TAB % u " , t ) ; if ( pNdb -> getDictionary ( ) -> dropTable ( tabnameBuff ) != 0 ) { ndbout << " Drop ▁ table ▁ failed ▁ with ▁ error ▁ : ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . code << " ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . message << endl ; } else { ndbout << " Dropped ▁ table ▁ " << tabnameBuff << endl ; } } return NDBT_OK ; } int dropTable ( NDBT_Context * ctx , NDBT_Step * step , Uint32 num ) { Ndb * pNdb = GETNDB ( step ) ; const NdbDictionary :: Table * pTab = ctx -> getTab ( ) ; if ( strcmp ( pTab -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; char tabnameBuff [ 10 ] ; snprintf ( tabnameBuff , sizeof ( tabnameBuff ) , " TAB % u " , num ) ; if ( pNdb -> getDictionary ( ) -> dropTable ( tabnameBuff ) != 0 ) { ndbout << " Drop ▁ table ▁ failed ▁ with ▁ error ▁ : ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . code << " ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . message << endl ; } else { ndbout << " Dropped ▁ table ▁ " << tabnameBuff << endl ; } return NDBT_OK ; } enum Scenarios { DROP_TABLE , RESTART_MASTER , RESTART_SLAVE , NUM_SCENARIOS } ; enum Tasks { WAIT = 0 , DROP_TABLE_REQ = 1 , MASTER_RESTART_REQ = 2 , SLAVE_RESTART_REQ = 3 } ; int testWorker ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; while ( ! ctx -> isTestStopped ( ) ) { ndbout_c ( " Worker ▁ : ▁ waiting ▁ for ▁ request . . . " ) ; ctx -> getPropertyWait ( " DIHWritesRequest " , 1 ) ; if ( ! ctx -> isTestStopped ( ) ) { Uint32 req = ctx -> getProperty ( " DIHWritesRequestType " , ( Uint32 ) 0 ) ; switch ( ( Tasks ) req ) { case DROP_TABLE_REQ : { ndbout_c ( " Worker ▁ : ▁ dropping ▁ table " ) ; if ( dropTable ( ctx , step , 2 ) != NDBT_OK ) { return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ table ▁ dropped . " ) ; break ; } case MASTER_RESTART_REQ : { ndbout_c ( " Worker ▁ : ▁ restarting ▁ Master " ) ; NdbRestarter restarter ; int master_nodeid = restarter . getMasterNodeId ( ) ; ndbout_c ( " Worker ▁ : ▁ Restarting ▁ Master ▁ ( % d ) . . . " , master_nodeid ) ; if ( restarter . restartOneDbNode2 ( master_nodeid , NdbRestarter :: NRRF_NOSTART | NdbRestarter :: NRRF_FORCE | NdbRestarter :: NRRF_ABORT ) || restarter . waitNodesNoStart ( & master_nodeid , 1 ) || restarter . startAll ( ) ) { ndbout_c ( " Worker ▁ : ▁ Error ▁ restarting ▁ Master . " ) ; return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ Waiting ▁ for ▁ master ▁ to ▁ recover . . . " ) ; if ( restarter . waitNodesStarted ( & master_nodeid , 1 ) ) { ndbout_c ( " Worker ▁ : ▁ Error ▁ waiting ▁ for ▁ Master ▁ restart " ) ; return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ Master ▁ recovered . " ) ; break ; } case SLAVE_RESTART_REQ : { NdbRestarter restarter ; int slave_nodeid = restarter . getRandomNotMasterNodeId ( rand ( ) ) ; ndbout_c ( " Worker ▁ : ▁ Restarting ▁ non - master ▁ ( % d ) . . . " , slave_nodeid ) ; if ( restarter . restartOneDbNode2 ( slave_nodeid , NdbRestarter :: NRRF_NOSTART | NdbRestarter :: NRRF_FORCE | NdbRestarter :: NRRF_ABORT ) || restarter . waitNodesNoStart ( & slave_nodeid , 1 ) || restarter . startAll ( ) ) { ndbout_c ( " Worker ▁ : ▁ Error ▁ restarting ▁ Slave . " ) ; return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ Waiting ▁ for ▁ slave ▁ to ▁ recover . . . " ) ; if ( restarter . waitNodesStarted ( & slave_nodeid , 1 ) ) { ndbout_c ( " Worker ▁ : ▁ Error ▁ waiting ▁ for ▁ Slave ▁ restart " ) ; return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ Slave ▁ recovered . " ) ; break ; } default : { break ; } } } ctx -> setProperty ( " DIHWritesRequestType " , ( Uint32 ) 0 ) ; ctx -> setProperty ( " DIHWritesRequest " , ( Uint32 ) 2 ) ; } ndbout_c ( " Worker , ▁ done . " ) ; return NDBT_OK ; } int testSlowDihFileWrites ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; NdbRestarter restarter ; for ( Uint32 scenario = 0 ; scenario < NUM_SCENARIOS ; scenario ++ ) { ndbout_c ( " Inserting ▁ error ▁ 7235" ) ; restarter . insertErrorInAllNodes ( 7235 ) ; ndbout_c ( " Triggering ▁ LCP " ) ; int dumpArg = 7099 ; restarter . dumpStateAllNodes ( & dumpArg , 1 ) ; const Uint32 periodSeconds = 10 ; Uint32 waitPeriods = 6 ; dumpArg = 7032 ; for ( Uint32 p = 0 ; p < waitPeriods ; p ++ ) { if ( p == 3 ) { switch ( ( Scenarios ) scenario ) { case DROP_TABLE : { ndbout_c ( " Requesting ▁ DROP ▁ TABLE " ) ; ctx -> setProperty ( " DIHWritesRequestType " , ( Uint32 ) DROP_TABLE_REQ ) ; ctx -> setProperty ( " DIHWritesRequest " , ( Uint32 ) 1 ) ; break ; } case RESTART_MASTER : { ndbout_c ( " Requesting ▁ Master ▁ restart " ) ; ctx -> setProperty ( " DIHWritesRequestType " , ( Uint32 ) MASTER_RESTART_REQ ) ; ctx -> setProperty ( " DIHWritesRequest " , ( Uint32 ) 1 ) ; break ; } case RESTART_SLAVE : { ndbout_c ( " Requesting ▁ Slave ▁ restart " ) ; ctx -> setProperty ( " DIHWritesRequestType " , ( Uint32 ) SLAVE_RESTART_REQ ) ; ctx -> setProperty ( " DIHWritesRequest " , ( Uint32 ) 1 ) ; break ; } default : break ; } } ndbout_c ( " Dumping ▁ DIH ▁ page ▁ info ▁ to ▁ ndbd ▁ stdout " ) ; restarter . dumpStateAllNodes ( & dumpArg , 1 ) ; NdbSleep_MilliSleep ( periodSeconds * 1000 ) ; } ndbout_c ( " Clearing ▁ error ▁ insert . . . " ) ; restarter . insertErrorInAllNodes ( 0 ) ; waitPeriods = 2 ; for ( Uint32 p = 0 ; p < waitPeriods ; p ++ ) { ndbout_c ( " Dumping ▁ DIH ▁ page ▁ info ▁ to ▁ ndbd ▁ stdout " ) ; restarter . dumpStateAllNodes ( & dumpArg , 1 ) ; NdbSleep_MilliSleep ( periodSeconds * 1000 ) ; } ndbout_c ( " Waiting ▁ for ▁ worker ▁ to ▁ finish ▁ task . . . " ) ; ctx -> getPropertyWait ( " DIHWritesRequest " , 2 ) ; if ( ctx -> isTestStopped ( ) ) return NDBT_OK ; ndbout_c ( " Done . " ) ; } ctx -> stopTest ( ) ; return NDBT_OK ; } NDBT_TESTSUITE ( testLimits ) ; TESTCASE ( " ExhaustSegmentedSectionPk " , " Test ▁ behaviour ▁ at ▁ Segmented ▁ Section ▁ exhaustion ▁ for ▁ PK " ) { INITIALIZER ( testSegmentedSectionPk ) ; } TESTCASE ( " ExhaustSegmentedSectionIX " , " Test ▁ behaviour ▁ at ▁ Segmented ▁ Section ▁ exhaustion ▁ for ▁ Unique ▁ index " ) { INITIALIZER ( testSegmentedSectionIx ) ; } TESTCASE ( " ExhaustSegmentedSectionScan " , " Test ▁ behaviour ▁ at ▁ Segmented ▁ Section ▁ exhaustion ▁ for ▁ Scan " ) { INITIALIZER ( testSegmentedSectionScan ) ; } TESTCASE ( " DropSignalFragments " , " Test ▁ behaviour ▁ of ▁ Segmented ▁ Section ▁ exhaustion ▁ with ▁ fragmented ▁ signals " ) { INITIALIZER ( testDropSignalFragments ) ; } TESTCASE ( " SlowDihFileWrites " , " Test ▁ behaviour ▁ of ▁ slow ▁ Dih ▁ table ▁ file ▁ writes " ) { INITIALIZER ( create100Tables ) ; STEP ( testWorker ) ; STEP ( testSlowDihFileWrites ) ; FINALIZER ( drop100Tables ) ; } NDBT_TESTSUITE_END ( testLimits ) ; int main ( int argc , const char * * argv ) { ndb_init ( ) ; NDBT_TESTSUITE_INSTANCE ( testLimits ) ; return testLimits . execute ( argc , argv ) ; } </DOCUMENT>
<DOCUMENT_ID="lassoan/CTK/tree/master/Plugins/org.commontk.plugingenerator.ui/ctkPluginGeneratorUiPlugin.cpp"> # include " ctkPluginGeneratorUiPlugin _ p . h " # include " ctkPluginGeneratorMainExtension . h " # include < ctkPluginConstants . h > # include < QtPlugin > # include < QDebug > void ctkPluginGeneratorUiPlugin :: start ( ctkPluginContext * context ) { mainExtension = new ctkPluginGeneratorMainExtension ( ) ; ctkDictionary props ; props . insert ( ctkPluginConstants :: SERVICE_RANKING , 0 ) ; context -> registerService ( QStringList ( " ctkPluginGeneratorAbstractUiExtension " ) , mainExtension , props ) ; qDebug ( ) << " Registered ▁ Main ▁ Extension " ; } void ctkPluginGeneratorUiPlugin :: stop ( ctkPluginContext * context ) { Q_UNUSED ( context ) delete mainExtension ; } Q_EXPORT_PLUGIN2 ( org_commontk_plugingenerator_ui , ctkPluginGeneratorUiPlugin ) </DOCUMENT>
