<DOCUMENT_ID="xdajog/samsung_sources_i927/tree/master/external/webkit/Source/WebKit2/Shared/DictionaryPopupInfo.cpp"> # include " config . h " # include " DictionaryPopupInfo . h " # include " WebCoreArgumentCoders . h " # if PLATFORM ( MAC ) # include " ArgumentCodersCF . h " # endif namespace WebKit { void DictionaryPopupInfo :: encode ( CoreIPC :: ArgumentEncoder * encoder ) const { encoder -> encode ( origin ) ; encoder -> encode ( fontInfo ) ; encoder -> encodeEnum ( type ) ; # if PLATFORM ( MAC ) && ! defined ( BUILDING_ON_SNOW_LEOPARD ) CoreIPC :: encode ( encoder , options . get ( ) ) ; # endif } bool DictionaryPopupInfo :: decode ( CoreIPC :: ArgumentDecoder * decoder , DictionaryPopupInfo & result ) { if ( ! decoder -> decode ( result . origin ) ) return false ; if ( ! decoder -> decode ( result . fontInfo ) ) return false ; if ( ! decoder -> decodeEnum ( result . type ) ) return false ; # if PLATFORM ( MAC ) && ! defined ( BUILDING_ON_SNOW_LEOPARD ) if ( ! CoreIPC :: decode ( decoder , result . options ) ) return false ; # endif return true ; } } </DOCUMENT>
<DOCUMENT_ID="twalpole/selenium/tree/master/cpp/iedriver/CommandHandlers/MaximizeWindowCommandHandler.cpp"> # include " MaximizeWindowCommandHandler . h " # include " errorcodes . h " # include " . . / Browser . h " # include " . . / IECommandExecutor . h " namespace webdriver { MaximizeWindowCommandHandler :: MaximizeWindowCommandHandler ( void ) { } MaximizeWindowCommandHandler :: ~ MaximizeWindowCommandHandler ( void ) { } void MaximizeWindowCommandHandler :: ExecuteInternal ( const IECommandExecutor & executor , const ParametersMap & command_parameters , Response * response ) { int status_code = WD_SUCCESS ; BrowserHandle browser_wrapper ; status_code = executor . GetCurrentBrowser ( & browser_wrapper ) ; if ( status_code != WD_SUCCESS ) { response -> SetErrorResponse ( ERROR_NO_SUCH_WINDOW , " Error ▁ retrieving ▁ window " ) ; return ; } HWND window_handle = browser_wrapper -> GetTopLevelWindowHandle ( ) ; if ( ! :: IsZoomed ( window_handle ) ) { browser_wrapper -> Restore ( ) ; :: ShowWindow ( window_handle , SW_MAXIMIZE ) ; } RECT window_rect ; :: GetWindowRect ( window_handle , & window_rect ) ; Json :: Value response_value ; response_value [ " width " ] = window_rect . right - window_rect . left ; response_value [ " height " ] = window_rect . bottom - window_rect . top ; response_value [ " x " ] = window_rect . left ; response_value [ " y " ] = window_rect . top ; response -> SetSuccessResponse ( response_value ) ; } } </DOCUMENT>
<DOCUMENT_ID="cypsun/FreeCAD/tree/master/src/Mod/Robot/Gui/ViewProviderTrajectory.cpp"> # include " PreCompiled . h " # ifndef _PreComp_ # include < Inventor / SoDB . h > # include < Inventor / SoInput . h > # include < Inventor / SbVec3f . h > # include < Inventor / nodes / SoSeparator . h > # include < Inventor / nodes / SoTransform . h > # include < Inventor / nodes / SoSphere . h > # include < Inventor / nodes / SoRotation . h > # include < Inventor / actions / SoSearchAction . h > # include < Inventor / draggers / SoJackDragger . h > # include < Inventor / VRMLnodes / SoVRMLTransform . h > # include < Inventor / nodes / SoBaseColor . h > # include < Inventor / nodes / SoCoordinate3 . h > # include < Inventor / nodes / SoDrawStyle . h > # include < Inventor / nodes / SoFaceSet . h > # include < Inventor / nodes / SoLineSet . h > # include < Inventor / nodes / SoMarkerSet . h > # include < Inventor / nodes / SoShapeHints . h > # include < QFile > # endif # include " ViewProviderTrajectory . h " # include < Mod / Robot / App / TrajectoryObject . h > # include < Mod / Robot / App / Trajectory . h > # include < App / Document . h > # include < Base / FileInfo . h > # include < Base / Stream . h > # include < Base / Console . h > # include < sstream > using namespace Gui ; using namespace RobotGui ; using namespace Robot ; PROPERTY_SOURCE ( RobotGui :: ViewProviderTrajectory , Gui :: ViewProviderGeometryObject ) ViewProviderTrajectory :: ViewProviderTrajectory ( ) { pcTrajectoryRoot = new Gui :: SoFCSelection ( ) ; pcTrajectoryRoot -> highlightMode = Gui :: SoFCSelection :: OFF ; pcTrajectoryRoot -> selectionMode = Gui :: SoFCSelection :: SEL_OFF ; pcTrajectoryRoot -> ref ( ) ; pcCoords = new SoCoordinate3 ( ) ; pcCoords -> ref ( ) ; pcDrawStyle = new SoDrawStyle ( ) ; pcDrawStyle -> ref ( ) ; pcDrawStyle -> style = SoDrawStyle :: LINES ; pcDrawStyle -> lineWidth = 2 ; pcLines = new SoLineSet ; pcLines -> ref ( ) ; } ViewProviderTrajectory :: ~ ViewProviderTrajectory ( ) { pcTrajectoryRoot -> unref ( ) ; pcCoords -> unref ( ) ; pcDrawStyle -> unref ( ) ; pcLines -> unref ( ) ; } void ViewProviderTrajectory :: attach ( App :: DocumentObject * pcObj ) { ViewProviderDocumentObject :: attach ( pcObj ) ; SoSeparator * linesep = new SoSeparator ; SoBaseColor * basecol = new SoBaseColor ; basecol -> rgb . setValue ( 1.0f , 0.5f , 0.0f ) ; linesep -> addChild ( basecol ) ; linesep -> addChild ( pcCoords ) ; linesep -> addChild ( pcLines ) ; SoBaseColor * markcol = new SoBaseColor ; markcol -> rgb . setValue ( 1.0f , 1.0f , 0.0f ) ; SoMarkerSet * marker = new SoMarkerSet ; marker -> markerIndex = SoMarkerSet :: CROSS_5_5 ; linesep -> addChild ( markcol ) ; linesep -> addChild ( marker ) ; pcTrajectoryRoot -> addChild ( linesep ) ; addDisplayMaskMode ( pcTrajectoryRoot , " Waypoints " ) ; pcTrajectoryRoot -> objectName = pcObj -> getNameInDocument ( ) ; pcTrajectoryRoot -> documentName = pcObj -> getDocument ( ) -> getName ( ) ; pcTrajectoryRoot -> subElementName = " Main " ; } void ViewProviderTrajectory :: setDisplayMode ( const char * ModeName ) { if ( strcmp ( " Waypoints " , ModeName ) == 0 ) setDisplayMaskMode ( " Waypoints " ) ; ViewProviderGeometryObject :: setDisplayMode ( ModeName ) ; } std :: vector < std :: string > ViewProviderTrajectory :: getDisplayModes ( void ) const { std :: vector < std :: string > StrList ; StrList . push_back ( " Waypoints " ) ; return StrList ; } void ViewProviderTrajectory :: updateData ( const App :: Property * prop ) { Robot :: TrajectoryObject * pcTracObj = static_cast < Robot :: TrajectoryObject * > ( pcObject ) ; if ( prop == & pcTracObj -> Trajectory ) { const Trajectory & trak = pcTracObj -> Trajectory . getValue ( ) ; pcCoords -> point . deleteValues ( 0 ) ; pcCoords -> point . setNum ( trak . getSize ( ) ) ; for ( unsigned int i = 0 ; i < trak . getSize ( ) ; ++ i ) { Base :: Vector3d pos = trak . getWaypoint ( i ) . EndPos . getPosition ( ) ; pcCoords -> point . set1Value ( i , pos . x , pos . y , pos . z ) ; } pcLines -> numVertices . set1Value ( 0 , trak . getSize ( ) ) ; } else if ( prop == & pcTracObj -> Base ) { Base :: Placement loc = * ( & pcTracObj -> Base . getValue ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="LEEluoman/MazeScrnSave/tree/master/MazeScrnSave/Maze.cpp"> # include " Maze . h " # include < set > # include < vector > # include < algorithm > using namespace std ; CMaze :: CMaze ( int nWidth , int nHeight , int nCellWidth , int nCellHeight , bool bCopyScreen ) { m_nCounter = 0 ; m_nWidth = nWidth ; m_nHeight = nHeight ; m_nCellWidth = nCellWidth ; m_nCellHeight = nCellHeight ; m_nCols = m_nWidth / m_nCellWidth - 1 ; m_nRows = m_nHeight / m_nCellHeight - 1 ; m_nOffsetX = ( m_nWidth - m_nCols * m_nCellWidth ) / 2 ; m_nOffsetY = ( m_nHeight - m_nRows * m_nCellHeight ) / 2 ; m_bReDrawBeforeGenerate = FALSE ; m_bAllowNonSolution = FALSE ; m_bFlashPath = TRUE ; HDC hScreenDc = GetDC ( NULL ) ; m_hWorkDc = CreateCompatibleDC ( NULL ) ; m_hWorkBmp = CreateCompatibleBitmap ( hScreenDc , m_nWidth , m_nHeight ) ; m_hOldBmp = SelectObject ( m_hWorkDc , ( HGDIOBJ ) m_hWorkBmp ) ; m_hOldPen = SelectObject ( m_hWorkDc , m_mazeColor . GetPen ( clWall ) ) ; if ( bCopyScreen ) { BitBlt ( m_hWorkDc , 0 , 0 , m_nWidth , m_nHeight , hScreenDc , 0 , 0 , SRCCOPY ) ; } ReleaseDC ( NULL , hScreenDc ) ; RECT rect = { 0 , 0 , m_nWidth , m_nHeight } ; FillRect ( m_hWorkDc , & rect , m_mazeColor . GetBrush ( clBackGround ) ) ; if ( m_nCols > 0 && m_nRows > 0 ) { m_cells = new CMazeCell [ m_nCols * m_nRows ] ; InitializeCells ( ) ; ResetAndReDrawAllCells ( ) ; m_state = MS_INITIALIZED ; } else { m_state = MS_ERROR ; m_cells = NULL ; } } CMaze :: ~ CMaze ( void ) { SelectObject ( m_hWorkDc , m_hOldPen ) ; SelectObject ( m_hWorkDc , m_hOldBmp ) ; DeleteDC ( m_hWorkDc ) ; DeleteObject ( m_hWorkBmp ) ; if ( m_cells != NULL ) { delete [ ] m_cells ; } } CMazeCell * CMaze :: GetCell ( int i , int j ) { if ( i < 0 || j < 0 || i >= m_nCols || j >= m_nRows ) { return NULL ; } return & m_cells [ j * m_nCols + i ] ; } void CMaze :: InitializeCells ( ) { for ( int i = 0 ; i < m_nCols ; ++ i ) { for ( int j = 0 ; j < m_nRows ; ++ j ) { CMazeCell * pCell = GetCell ( i , j ) ; pCell -> SetParent ( this , i , j ) ; } } } void CMaze :: ReDrawSides ( ) { int nPicWidth = m_nCols * m_nCellWidth ; int nPicHeight = m_nRows * m_nCellHeight ; MoveToEx ( m_hWorkDc , m_nOffsetX , m_nOffsetY , NULL ) ; LineTo ( m_hWorkDc , m_nOffsetX + nPicWidth , m_nOffsetY ) ; LineTo ( m_hWorkDc , m_nOffsetX + nPicWidth , m_nOffsetY + nPicHeight ) ; LineTo ( m_hWorkDc , m_nOffsetX , m_nOffsetY + nPicHeight ) ; LineTo ( m_hWorkDc , m_nOffsetX , m_nOffsetY ) ; } void CMaze :: ResetAllCells ( ) { for ( int i = 0 ; i < m_nCols ; ++ i ) { for ( int j = 0 ; j < m_nRows ; ++ j ) { CMazeCell * pCell = GetCell ( i , j ) ; pCell -> Reset ( ) ; } } } void CMaze :: ResetAndReDrawAllCells ( ) { for ( int i = 0 ; i < m_nCols ; ++ i ) { for ( int j = 0 ; j < m_nRows ; ++ j ) { CMazeCell * pCell = GetCell ( i , j ) ; pCell -> Reset ( ) ; pCell -> ReDraw ( ) ; } } ReDrawSides ( ) ; } void CMaze :: ReDrawAllCells ( ) { for ( int i = 0 ; i < m_nCols ; ++ i ) { for ( int j = 0 ; j < m_nRows ; ++ j ) { CMazeCell * pCell = GetCell ( i , j ) ; pCell -> ReDraw ( ) ; } } ReDrawSides ( ) ; } void CMaze :: Next ( BOOL bDelay ) { DWORD dwDelayValue = 0 ; switch ( m_state ) { case MS_INITIALIZED : m_cellGenerating = GetRandomCell ( ) ; m_cellStack . Init ( ) ; m_cellStack . Push ( m_cellGenerating ) ; m_cellGenerating -> m_bGenerated = true ; ChangeState ( MS_GENERATING ) ; break ; case MS_GENERATING : if ( m_cellStack . IsEmpty ( ) ) { ChangeState ( MS_GENERATED ) ; } else { bool bGetNewCell = false ; CMazeCell * pTopCell = m_cellStack . Top ( ) ; pTopCell -> ReDraw ( ) ; pTopCell -> GoGenerate ( & bGetNewCell ) ; if ( bGetNewCell ) { } } break ; case MS_GENERATED : if ( m_bAllowNonSolution && m_nRows * m_nCols >= 10 && m_nCols > 1 && m_nRows > 1 ) { int nRightWallsCount = ( m_nCols - 1 ) * m_nRows ; int nBottomWallsCount = ( m_nRows - 1 ) * m_nCols ; int nWallsCount = nRightWallsCount + nBottomWallsCount ; int nChangedWallsCount = nWallsCount * 2 / 100 ; set < int > setChangedWalls ; vector < int > vectorChangedWalls ; if ( nChangedWallsCount > 100 ) { nChangedWallsCount = 100 ; } while ( ( int ) setChangedWalls . size ( ) < nChangedWallsCount ) { setChangedWalls . insert ( BigRand ( ) % nWallsCount ) ; } vectorChangedWalls . assign ( setChangedWalls . begin ( ) , setChangedWalls . end ( ) ) ; random_shuffle ( vectorChangedWalls . begin ( ) , vectorChangedWalls . end ( ) ) ; for ( int i = 0 ; i < nChangedWallsCount ; ++ i ) { int nOffset = vectorChangedWalls . at ( i ) ; if ( nOffset < nRightWallsCount ) { int nRow = nOffset / ( m_nCols - 1 ) ; int nCol = nOffset % ( m_nCols - 1 ) ; CMazeCell * pCell = GetCell ( nCol , nRow ) ; pCell -> SetWall ( DIR_RIGHT , ! pCell -> GetWall ( DIR_RIGHT ) ) ; } else { nOffset -= nRightWallsCount ; int nRow = nOffset / m_nCols ; int nCol = nOffset % m_nCols ; CMazeCell * pCell = GetCell ( nCol , nRow ) ; pCell -> SetWall ( DIR_BOTTOM , ! pCell -> GetWall ( DIR_BOTTOM ) ) ; } } } ReDrawAllCells ( ) ; ChangeState ( MS_SETTING ) ; break ; case MS_SETTING : if ( true ) { int nCounter = GetCounter ( ) ; if ( nCounter == 0 ) { if ( rand ( ) % 5 == 0 ) { int bx [ ] = { 0 , 0 , 1 , 1 } ; int by [ ] = { 0 , 1 , 0 , 1 } ; int ex [ ] = { 1 , 1 , 0 , 0 } ; int ey [ ] = { 1 , 0 , 1 , 0 } ; int offset = rand ( ) % 4 ; m_cellBegin = GetCell ( ( GetCols ( ) - 1 ) * bx [ offset ] , ( GetRows ( ) - 1 ) * by [ offset ] ) ; m_cellEnd = GetCell ( ( GetCols ( ) - 1 ) * ex [ offset ] , ( GetRows ( ) - 1 ) * ey [ offset ] ) ; } else { m_cellBegin = GetRandomCell ( ) ; do { m_cellEnd = GetRandomCell ( ) ; } while ( m_cellEnd == m_cellBegin ) ; } m_cellBegin -> m_bIsBegin = true ; m_cellEnd -> m_bIsEnd = true ; } else if ( nCounter < 19 ) { m_cellBegin -> m_bIsBegin = ! m_cellBegin -> m_bIsBegin ; m_cellBegin -> ReDraw ( ) ; dwDelayValue = 55 ; } else if ( nCounter < 37 ) { m_cellEnd -> m_bIsEnd = ! m_cellEnd -> m_bIsEnd ; m_cellEnd -> ReDraw ( ) ; dwDelayValue = 55 ; } else { ChangeState ( MS_SET ) ; } } break ; case MS_SET : m_cellStack . Init ( ) ; m_cellStack . Push ( m_cellBegin ) ; m_cellBegin -> m_bVisited = true ; ChangeState ( MS_RESOLVING ) ; break ; case MS_RESOLVING : if ( m_cellStack . IsEmpty ( ) ) { ChangeState ( MS_RESOLVEFAILED ) ; } else { bool bGetNewCell = false ; CMazeCell * pTopCell = m_cellStack . Top ( ) ; pTopCell -> ReDraw ( ) ; if ( pTopCell == m_cellEnd ) { ChangeState ( MS_RESOLVED ) ; break ; } pTopCell -> GoResolve ( & bGetNewCell ) ; if ( bGetNewCell ) { } } dwDelayValue = 10 ; break ; case MS_RESOLVED : { int nCounter = GetCounter ( ) ; if ( nCounter > 5 ) { if ( m_bReDrawBeforeGenerate ) { ResetAndReDrawAllCells ( ) ; } else { ResetAllCells ( ) ; } ChangeState ( MS_INITIALIZED ) ; } else { if ( m_bFlashPath ) { COLORREF cl = m_mazeColor . GetColor ( clVisited ) ; m_mazeColor . SetColor ( clVisited , GetReverseColor ( cl ) ) ; ReDrawAllCells ( ) ; } dwDelayValue = 500 ; } } break ; case MS_RESOLVEFAILED : dwDelayValue = 3000 ; if ( m_bReDrawBeforeGenerate ) { ResetAndReDrawAllCells ( ) ; } else { ResetAllCells ( ) ; } ChangeState ( MS_INITIALIZED ) ; case MS_PAUSED : break ; case MS_ERROR : break ; default : break ; } if ( bDelay && dwDelayValue > 0 ) { Sleep ( dwDelayValue ) ; } } HDC CMaze :: GetDc ( ) const { return m_hWorkDc ; } CMazeColor & CMaze :: GetColorManager ( ) { return m_mazeColor ; } MazeState CMaze :: GetState ( ) const { return m_state ; } CMazeCell * CMaze :: GetRandomCell ( ) { return GetCell ( rand ( ) % m_nCols , rand ( ) % m_nRows ) ; } void CMaze :: MakeRandomBeginAndEndCell ( ) { m_cellBegin = GetRandomCell ( ) ; m_cellEnd = GetRandomCell ( ) ; while ( m_cellEnd == m_cellBegin ) { m_cellEnd = GetRandomCell ( ) ; } } int CMaze :: GetWidth ( ) const { return m_nWidth ; } int CMaze :: GetHeight ( ) const { return m_nHeight ; } int CMaze :: GetCellWidth ( ) const { return m_nCellWidth ; } int CMaze :: GetCellHeight ( ) const { return m_nCellHeight ; } int CMaze :: GetRows ( ) const { return m_nRows ; } int CMaze :: GetCols ( ) const { return m_nCols ; } int CMaze :: GetOffsetX ( ) const { return m_nOffsetX ; } int CMaze :: GetOffsetY ( ) const { return m_nOffsetY ; } CMazeCellStack & CMaze :: GetCellStack ( ) { return m_cellStack ; } void CMaze :: ChangeState ( MazeState state ) { if ( m_state != state ) { m_state = state ; m_nCounter = 0 ; } } int CMaze :: GetCounter ( ) { return m_nCounter ++ ; } int CMaze :: BigRand ( ) { return ( ( ( rand ( ) % 0x100 ) << 0 ) | ( ( rand ( ) % 0x100 ) << 8 ) | ( ( rand ( ) % 0x100 ) << 16 ) | ( ( rand ( ) % 0x100 ) << 24 ) ) & ( ( unsigned ) - 1 >> 1 ) ; } COLORREF CMaze :: GetReverseColor ( COLORREF cl ) { return RGB ( ~ GetRValue ( cl ) , ~ GetGValue ( cl ) , ~ GetBValue ( cl ) ) ; } void CMaze :: SetReDrawBeforeGenerate ( BOOL bReDrawBeforeGenerate ) { m_bReDrawBeforeGenerate = bReDrawBeforeGenerate ; } void CMaze :: SetAllowNonSolution ( BOOL bAllowNonSolution ) { m_bAllowNonSolution = bAllowNonSolution ; } void CMaze :: SetFlashPath ( BOOL bFlashPath ) { m_bFlashPath = bFlashPath ; } void CMaze :: UpdateColors ( ) { SelectObject ( m_hWorkDc , m_mazeColor . GetPen ( clWall ) ) ; } void CMaze :: Restart ( ) { if ( m_bReDrawBeforeGenerate ) { ResetAndReDrawAllCells ( ) ; } else { ResetAllCells ( ) ; } ChangeState ( MS_INITIALIZED ) ; } </DOCUMENT>
<DOCUMENT_ID="CodeDJ/qt5-hidpi/tree/master/qt/qtdeclarative/src/quick/util/qquickanimatorcontroller.cpp"> # include " qquickanimatorcontroller _ p . h " # include < private / qquickwindow_p . h > # include < private / qsgrenderloop_p . h > # include < private / qanimationgroupjob_p . h > # include < QtGui / qscreen . h > # include < QtCore / qcoreapplication . h > QT_BEGIN_NAMESPACE QQuickAnimatorController :: QQuickAnimatorController ( ) : m_window ( 0 ) { } QQuickAnimatorController :: ~ QQuickAnimatorController ( ) { foreach ( QAbstractAnimationJob * job , m_deleting ) { m_starting . take ( job ) ; m_stopping . take ( job ) ; m_animatorRoots . take ( job ) ; delete job ; } foreach ( QQuickAnimatorProxyJob * proxy , m_animatorRoots ) proxy -> controllerWasDeleted ( ) ; qDeleteAll ( m_animatorRoots . keys ( ) ) ; foreach ( QAbstractAnimationJob * job , m_starting . keys ( ) ) { if ( ! m_animatorRoots . contains ( job ) ) delete job ; } } void QQuickAnimatorController :: itemDestroyed ( QObject * o ) { m_deletedSinceLastFrame << ( QQuickItem * ) o ; } void QQuickAnimatorController :: advance ( ) { bool running = false ; for ( QHash < QAbstractAnimationJob * , QQuickAnimatorProxyJob * > :: const_iterator it = m_animatorRoots . constBegin ( ) ; ! running && it != m_animatorRoots . constEnd ( ) ; ++ it ) { if ( it . key ( ) -> isRunning ( ) ) running = true ; } lock ( ) ; for ( QHash < QQuickItem * , QQuickTransformAnimatorJob :: Helper * > :: const_iterator it = m_transforms . constBegin ( ) ; it != m_transforms . constEnd ( ) ; ++ it ) { QQuickTransformAnimatorJob :: Helper * xform = * it ; if ( ! xform -> item ) continue ; ( * it ) -> apply ( ) ; } unlock ( ) ; if ( running ) m_window -> update ( ) ; } static void qquick_initialize_helper ( QAbstractAnimationJob * job , QQuickAnimatorController * c ) { if ( job -> isRenderThreadJob ( ) ) { QQuickAnimatorJob * j = static_cast < QQuickAnimatorJob * > ( job ) ; if ( ! j -> target ( ) ) { return ; } else if ( c -> m_deletedSinceLastFrame . contains ( j -> target ( ) ) ) { j -> targetWasDeleted ( ) ; } else { j -> addAnimationChangeListener ( c , QAbstractAnimationJob :: StateChange ) ; j -> initialize ( c ) ; } } else if ( job -> isGroup ( ) ) { QAnimationGroupJob * g = static_cast < QAnimationGroupJob * > ( job ) ; for ( QAbstractAnimationJob * a = g -> firstChild ( ) ; a ; a = a -> nextSibling ( ) ) qquick_initialize_helper ( a , c ) ; } } void QQuickAnimatorController :: beforeNodeSync ( ) { foreach ( QAbstractAnimationJob * job , m_deleting ) { m_starting . take ( job ) ; m_stopping . take ( job ) ; m_animatorRoots . take ( job ) ; job -> stop ( ) ; delete job ; } m_deleting . clear ( ) ; if ( m_starting . size ( ) ) m_window -> update ( ) ; foreach ( QQuickAnimatorProxyJob * proxy , m_starting ) { QAbstractAnimationJob * job = proxy -> job ( ) ; job -> addAnimationChangeListener ( this , QAbstractAnimationJob :: Completion ) ; qquick_initialize_helper ( job , this ) ; m_animatorRoots [ job ] = proxy ; job -> start ( ) ; proxy -> startedByController ( ) ; } m_starting . clear ( ) ; foreach ( QQuickAnimatorProxyJob * proxy , m_stopping ) { QAbstractAnimationJob * job = proxy -> job ( ) ; job -> stop ( ) ; } m_stopping . clear ( ) ; foreach ( QQuickAnimatorJob * job , m_activeLeafAnimations ) { if ( ! job -> target ( ) ) continue ; else if ( m_deletedSinceLastFrame . contains ( job -> target ( ) ) ) job -> targetWasDeleted ( ) ; else if ( job -> isTransform ( ) ) { QQuickTransformAnimatorJob * xform = static_cast < QQuickTransformAnimatorJob * > ( job ) ; xform -> transformHelper ( ) -> sync ( ) ; } } foreach ( QQuickItem * wiped , m_deletedSinceLastFrame ) { QQuickTransformAnimatorJob :: Helper * helper = m_transforms . value ( wiped ) ; if ( helper ) helper -> item = 0 ; } m_deletedSinceLastFrame . clear ( ) ; } void QQuickAnimatorController :: afterNodeSync ( ) { foreach ( QQuickAnimatorJob * job , m_activeLeafAnimations ) { if ( job -> isUniform ( ) && job -> target ( ) ) static_cast < QQuickUniformAnimatorJob * > ( job ) -> afterNodeSync ( ) ; } } void QQuickAnimatorController :: animationFinished ( QAbstractAnimationJob * job ) { if ( ! m_deleting . contains ( job ) ) { QQuickAnimatorProxyJob * proxy = m_animatorRoots [ job ] ; if ( proxy ) QCoreApplication :: postEvent ( proxy , new QEvent ( QEvent :: User ) ) ; } } void QQuickAnimatorController :: animationStateChanged ( QAbstractAnimationJob * job , QAbstractAnimationJob :: State newState , QAbstractAnimationJob :: State oldState ) { Q_ASSERT ( job -> isRenderThreadJob ( ) ) ; QQuickAnimatorJob * animator = static_cast < QQuickAnimatorJob * > ( job ) ; if ( newState == QAbstractAnimationJob :: Running ) { m_activeLeafAnimations << animator ; animator -> setHasBeenRunning ( true ) ; } else if ( oldState == QAbstractAnimationJob :: Running ) { m_activeLeafAnimations . remove ( animator ) ; } } void QQuickAnimatorController :: requestSync ( ) { m_window -> maybeUpdate ( ) ; } void QQuickAnimatorController :: startJob ( QQuickAnimatorProxyJob * proxy , QAbstractAnimationJob * job ) { m_starting [ job ] = proxy ; requestSync ( ) ; } void QQuickAnimatorController :: stopJob ( QQuickAnimatorProxyJob * proxy , QAbstractAnimationJob * job ) { m_stopping [ job ] = proxy ; requestSync ( ) ; } void QQuickAnimatorController :: deleteJob ( QAbstractAnimationJob * job ) { lock ( ) ; m_deleting << job ; requestSync ( ) ; unlock ( ) ; } QT_END_NAMESPACE </DOCUMENT>
<DOCUMENT_ID="jobermayr/pcsx2/tree/master/3rdparty/wxwidgets3.0/src/common/filectrlcmn.cpp"> # include " wx / wxprec . h " # ifdef __BORLANDC__ # pragma hdrstop # endif # if wxUSE_FILECTRL # include " wx / filectrl . h " # ifndef WX_PRECOMP # include " wx / debug . h " # endif const char wxFileCtrlNameStr [ ] = " wxfilectrl " ; wxDEFINE_EVENT ( wxEVT_FILECTRL_SELECTIONCHANGED , wxFileCtrlEvent ) ; wxDEFINE_EVENT ( wxEVT_FILECTRL_FILEACTIVATED , wxFileCtrlEvent ) ; wxDEFINE_EVENT ( wxEVT_FILECTRL_FOLDERCHANGED , wxFileCtrlEvent ) ; wxDEFINE_EVENT ( wxEVT_FILECTRL_FILTERCHANGED , wxFileCtrlEvent ) ; IMPLEMENT_DYNAMIC_CLASS ( wxFileCtrlEvent , wxCommandEvent ) void GenerateFilterChangedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_FILTERCHANGED , wnd , wnd -> GetId ( ) ) ; event . SetFilterIndex ( fileCtrl -> GetFilterIndex ( ) ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } void GenerateFolderChangedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_FOLDERCHANGED , wnd , wnd -> GetId ( ) ) ; event . SetDirectory ( fileCtrl -> GetDirectory ( ) ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } void GenerateSelectionChangedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_SELECTIONCHANGED , wnd , wnd -> GetId ( ) ) ; event . SetDirectory ( fileCtrl -> GetDirectory ( ) ) ; wxArrayString filenames ; fileCtrl -> GetFilenames ( filenames ) ; event . SetFiles ( filenames ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } void GenerateFileActivatedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd , const wxString filename ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_FILEACTIVATED , wnd , wnd -> GetId ( ) ) ; event . SetDirectory ( fileCtrl -> GetDirectory ( ) ) ; wxArrayString filenames ; if ( filename . empty ( ) ) { fileCtrl -> GetFilenames ( filenames ) ; } else { filenames . Add ( filename ) ; } event . SetFiles ( filenames ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } wxString wxFileCtrlEvent :: GetFile ( ) const { wxASSERT_MSG ( ! wxDynamicCast ( GetEventObject ( ) , wxFileCtrl ) -> HasMultipleFileSelection ( ) , wxT ( " Please ▁ use ▁ GetFiles ( ) ▁ to ▁ get ▁ all ▁ files ▁ instead ▁ of ▁ this ▁ function " ) ) ; wxString string ; if ( m_files . Count ( ) != 0 ) string = m_files [ 0 ] ; return string ; } # endif </DOCUMENT>
<DOCUMENT_ID="Maximus-/WinObjC/tree/master/deps/3rdparty/iculegacy/source/test/intltest/testidna.cpp"> # include " unicode / utypes . h " # if ! UCONFIG_NO_IDNA && ! UCONFIG_NO_TRANSLITERATION # include < time . h > # include < limits . h > # include < stdlib . h > # include < string . h > # include " unicode / localpointer . h " # include " unicode / ustring . h " # include " unicode / usprep . h " # include " unicode / uniset . h " # include " testidna . h " # include " idnaref . h " # include " nptrans . h " # include " unicode / putil . h " # include " idnaconf . h " static const UChar unicodeIn [ ] [ 41 ] = { { 0x0644 , 0x064A , 0x0647 , 0x0645 , 0x0627 , 0x0628 , 0x062A , 0x0643 , 0x0644 , 0x0645 , 0x0648 , 0x0634 , 0x0639 , 0x0631 , 0x0628 , 0x064A , 0x061F , 0x0000 } , { 0x4ED6 , 0x4EEC , 0x4E3A , 0x4EC0 , 0x4E48 , 0x4E0D , 0x8BF4 , 0x4E2D , 0x6587 , 0x0000 } , { 0x0050 , 0x0072 , 0x006F , 0x010D , 0x0070 , 0x0072 , 0x006F , 0x0073 , 0x0074 , 0x011B , 0x006E , 0x0065 , 0x006D , 0x006C , 0x0075 , 0x0076 , 0x00ED , 0x010D , 0x0065 , 0x0073 , 0x006B , 0x0079 , 0x0000 } , { 0x05DC , 0x05DE , 0x05D4 , 0x05D4 , 0x05DD , 0x05E4 , 0x05E9 , 0x05D5 , 0x05D8 , 0x05DC , 0x05D0 , 0x05DE , 0x05D3 , 0x05D1 , 0x05E8 , 0x05D9 , 0x05DD , 0x05E2 , 0x05D1 , 0x05E8 , 0x05D9 , 0x05EA , 0x0000 } , { 0x092F , 0x0939 , 0x0932 , 0x094B , 0x0917 , 0x0939 , 0x093F , 0x0928 , 0x094D , 0x0926 , 0x0940 , 0x0915 , 0x094D , 0x092F , 0x094B , 0x0902 , 0x0928 , 0x0939 , 0x0940 , 0x0902 , 0x092C , 0x094B , 0x0932 , 0x0938 , 0x0915 , 0x0924 , 0x0947 , 0x0939 , 0x0948 , 0x0902 , 0x0000 } , { 0x306A , 0x305C , 0x307F , 0x3093 , 0x306A , 0x65E5 , 0x672C , 0x8A9E , 0x3092 , 0x8A71 , 0x3057 , 0x3066 , 0x304F , 0x308C , 0x306A , 0x3044 , 0x306E , 0x304B , 0x0000 } , { 0x043F , 0x043E , 0x0447 , 0x0435 , 0x043C , 0x0443 , 0x0436 , 0x0435 , 0x043E , 0x043D , 0x0438 , 0x043D , 0x0435 , 0x0433 , 0x043E , 0x0432 , 0x043E , 0x0440 , 0x044F , 0x0442 , 0x043F , 0x043E , 0x0440 , 0x0443 , 0x0441 , 0x0441 , 0x043A , 0x0438 , 0x0000 } , { 0x0050 , 0x006F , 0x0072 , 0x0071 , 0x0075 , 0x00E9 , 0x006E , 0x006F , 0x0070 , 0x0075 , 0x0065 , 0x0064 , 0x0065 , 0x006E , 0x0073 , 0x0069 , 0x006D , 0x0070 , 0x006C , 0x0065 , 0x006D , 0x0065 , 0x006E , 0x0074 , 0x0065 , 0x0068 , 0x0061 , 0x0062 , 0x006C , 0x0061 , 0x0072 , 0x0065 , 0x006E , 0x0045 , 0x0073 , 0x0070 , 0x0061 , 0x00F1 , 0x006F , 0x006C , 0x0000 } , { 0x4ED6 , 0x5011 , 0x7232 , 0x4EC0 , 0x9EBD , 0x4E0D , 0x8AAA , 0x4E2D , 0x6587 , 0x0000 } , { 0x0054 , 0x1EA1 , 0x0069 , 0x0073 , 0x0061 , 0x006F , 0x0068 , 0x1ECD , 0x006B , 0x0068 , 0x00F4 , 0x006E , 0x0067 , 0x0074 , 0x0068 , 0x1EC3 , 0x0063 , 0x0068 , 0x1EC9 , 0x006E , 0x00F3 , 0x0069 , 0x0074 , 0x0069 , 0x1EBF , 0x006E , 0x0067 , 0x0056 , 0x0069 , 0x1EC7 , 0x0074 , 0x0000 } , { 0x0033 , 0x5E74 , 0x0042 , 0x7D44 , 0x91D1 , 0x516B , 0x5148 , 0x751F , 0x0000 } , { 0x5B89 , 0x5BA4 , 0x5948 , 0x7F8E , 0x6075 , 0x002D , 0x0077 , 0x0069 , 0x0074 , 0x0068 , 0x002D , 0x0053 , 0x0055 , 0x0050 , 0x0045 , 0x0052 , 0x002D , 0x004D , 0x004F , 0x004E , 0x004B , 0x0045 , 0x0059 , 0x0053 , 0x0000 } , { 0x0048 , 0x0065 , 0x006C , 0x006C , 0x006F , 0x002D , 0x0041 , 0x006E , 0x006F , 0x0074 , 0x0068 , 0x0065 , 0x0072 , 0x002D , 0x0057 , 0x0061 , 0x0079 , 0x002D , 0x305D , 0x308C , 0x305E , 0x308C , 0x306E , 0x5834 , 0x6240 , 0x0000 } , { 0x3072 , 0x3068 , 0x3064 , 0x5C4B , 0x6839 , 0x306E , 0x4E0B , 0x0032 , 0x0000 } , { 0x004D , 0x0061 , 0x006A , 0x0069 , 0x3067 , 0x004B , 0x006F , 0x0069 , 0x3059 , 0x308B , 0x0035 , 0x79D2 , 0x524D , 0x0000 } , { 0x30D1 , 0x30D5 , 0x30A3 , 0x30FC , 0x0064 , 0x0065 , 0x30EB , 0x30F3 , 0x30D0 , 0x0000 } , { 0x305D , 0x306E , 0x30B9 , 0x30D4 , 0x30FC , 0x30C9 , 0x3067 , 0x0000 } , { 0xD800 , 0xDF00 , 0xD800 , 0xDF01 , 0xD800 , 0xDF02 , 0xD800 , 0xDF03 , 0xD800 , 0xDF05 , 0xD800 , 0xDF06 , 0xD800 , 0xDF07 , 0xD800 , 0xDF09 , 0xD800 , 0xDF0A , 0xD800 , 0xDF0B , 0x0000 } , { 0xD800 , 0xDF0D , 0xD800 , 0xDF0C , 0xD800 , 0xDF1E , 0xD800 , 0xDF0F , 0xD800 , 0xDF16 , 0xD800 , 0xDF15 , 0xD800 , 0xDF14 , 0xD800 , 0xDF12 , 0xD800 , 0xDF10 , 0xD800 , 0xDF20 , 0xD800 , 0xDF21 , 0x0000 } , { 0x03b5 , 0x03bb , 0x03bb , 0x03b7 , 0x03bd , 0x03b9 , 0x03ba , 0x03ac } , { 0x0062 , 0x006f , 0x006e , 0x0121 , 0x0075 , 0x0073 , 0x0061 , 0x0127 , 0x0127 , 0x0061 } , { 0x043f , 0x043e , 0x0447 , 0x0435 , 0x043c , 0x0443 , 0x0436 , 0x0435 , 0x043e , 0x043d , 0x0438 , 0x043d , 0x0435 , 0x0433 , 0x043e , 0x0432 , 0x043e , 0x0440 , 0x044f , 0x0442 , 0x043f , 0x043e , 0x0440 , 0x0443 , 0x0441 , 0x0441 , 0x043a , 0x0438 } , { 0xFB00 , 0xFB01 } } ; static const char * asciiIn [ ] = { " xn - - egbpdaj6bu4bxfgehfvwxn " , " xn - - ihqwcrb4cv8a8dqg056pqjye " , " xn - - Proprostnemluvesky - uyb24dma41a " , " xn - -4dbcagdahymbxekheh6e0a7fei0b " , " xn - - i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd " , " xn - - n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa " , " xn - - b1abfaaepdrnnbgefbaDotcwatmq2g4l " , " xn - - PorqunopuedensimplementehablarenEspaol - fmd56a " , " xn - - ihqwctvzc91f659drss3x8bo0yb " , " xn - - TisaohkhngthchnitingVit - kjcr8268qyxafd2f1b9g " , " xn - -3B - ww4c5e180e575a65lsy2b " , " xn - - - with - SUPER - MONKEYS - pc58ag80a8qai00g7n9n " , " xn - - Hello - Another - Way - - fc4qua05auwb3674vfr0b " , " xn - -2 - u9tlzr9756bt3uc0v " , " xn - - MajiKoi5-783gue6qz075azm5e " , " xn - - de - jg4avhby1noc0d " , " xn - - d9juau41awczczp " , " XN - -097CCDEKGHQJK " , " XN - - db8CBHEJLGH4E0AL " , " xn - - hxargifdar " , " xn - - bonusaa - 5bb1da " , " xn - - b1abfaaepdrnnbgefbadotcwatmq2g4l " , " fffi " } ; static const char * domainNames [ ] = { " slip129-37-118-146 . nc . us . ibm . net " , " saratoga . pe . utexas . edu " , " dial - 120-45 . ots . utexas . edu " , " woo - 085 . dorms . waller . net " , " hd30-049 . hil . compuserve . com " , " pem203-31 . pe . ttu . edu " , "56K - 227 . MaxTNT3 . pdq . net " , " dial - 36-2 . ots . utexas . edu " , " slip129-37-23-152 . ga . us . ibm . net " , " ts45ip119 . cadvision . com " , " sdn - ts - 004txaustP05 . dialsprint . net " , " bar - tnt1s66 . erols . com " , "101 . st - louis - 15 . mo . dial - access . att . net " , " h92-245 . Arco . COM " , " dial - 13-2 . ots . utexas . edu " , " net - redynet29 . datamarkets . com . ar " , " ccs - shiva28 . reacciun . net . ve " , "7 . houston - 11 . tx . dial - access . att . net " , " ingw129-37-120-26 . mo . us . ibm . net " , " dialup6 . austintx . com " , " dns2 . tpao . gov . tr " , " slip129-37-119-194 . nc . us . ibm . net " , " cs7 . dillons . co . uk . 203.119.193 . in - addr . arpa " , " swprd1 . innovplace . saskatoon . sk . ca " , " bikini . bologna . maraut . it " , " node91 . subnet159-198-79 . baxter . com " , " cust19 . max5 . new - york . ny . ms . uu . net " , " balexander . slip . andrew . cmu . edu " , " pool029 . max2 . denver . co . dynip . alter . net " , " cust49 . max9 . new - york . ny . ms . uu . net " , " s61 . abq - dialin2 . hollyberry . com " , " \\u0917\\u0928\\u0947\\u0936 . sanjose . ibm . com " , " www . xn - - vea . com " , " www . \\u00C2\\u00A4 . com " , " www . \\u00C2\\u00A3 . com " , " \\u00C3\\u00BC . com " , } ; typedef struct ErrorCases ErrorCases ; static const struct ErrorCases { UChar unicode [ 100 ] ; const char * ascii ; UErrorCode expected ; UBool useSTD3ASCIIRules ; UBool testToUnicode ; UBool testLabel ; } errorCases [ ] = { { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0xC138 , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0x070F , 0xD55C , 0xAD6D , 0xC5B4 , 0xB97C , 0xC774 , 0xD574 , 0xD55C , 0xB2E4 , 0xBA74 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . XN - -8mb5595fsoa28orucya378bqre2tcwop06c5qbw82a1rffmae0361dea96b . com " , U_IDNA_PROHIBITED_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0xC138 , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0x0221 , 0x0234 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . XN - -6lA2Bz548Fj1GuA391Bf1Gb1N59Ab29A7iA . com " , U_IDNA_UNASSIGNED_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0xC138 , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0x0644 , 0x064A , 0x0647 , 0xD55C , 0xAD6D , 0xC5B4 , 0xB97C , 0xC774 , 0xD574 , 0xD55C , 0xB2E4 , 0xBA74 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . xn - - ghBGI4851OiyA33VqrD6Az86C4qF83CtRv93D5xBk15AzfG0nAgA0578DeA71C . com " , U_IDNA_CHECK_BIDI_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x002D , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0x002E , 0xD55C , 0xAD6D , 0xC5B4 , 0xB97C , 0xC774 , 0xD574 , 0xD55C , 0xB2E4 , 0xBA74 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . xn - - - - b95Ew8SqA315Ao5FbuMlnNmhA . com " , U_IDNA_STD3_ASCII_RULES_ERROR , TRUE , FALSE , FALSE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x0078 , 0x006e , 0x002d , 0x002d , 0x002D , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0x002D , 0xD55C , 0xAD6D , 0xC5B4 , 0xB97C , 0xC774 , 0xD574 , 0xD55C , 0xB2E4 , 0xBA74 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . XY - - - - - b91I0V65S96C2A355Cw1E5yCeQr19CsnP1mFfmAE0361DeA96B . com " , U_IDNA_ACE_PREFIX_ERROR , FALSE , FALSE , FALSE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0xC138 , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0xD55C , 0xAD6D , 0xC5B4 , 0xB97C , 0xC774 , 0xD574 , 0xD55C , 0xB2E4 , 0xBA74 , 0xC5BC , 0xB9C8 , 0xB098 , 0xC88B , 0xC744 , 0xAE4C , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . xn - -989AoMsVi5E83Db1D2A355Cv1E0vAk1DwRv93D5xBh15A0Dt30A5JpSD879Ccm6FeA98C . com " , U_IDNA_LABEL_TOO_LONG_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x0030 , 0x0644 , 0x064A , 0x0647 , 0x0031 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . xn - -01 - tvdmo . com " , U_IDNA_CHECK_BIDI_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x206C , 0x0644 , 0x064A , 0x0647 , 0x206D , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . XN - - ghbgi278xia . com " , U_IDNA_PROHIBITED_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x002D , 0x0041 , 0x0042 , 0x0043 , 0x0044 , 0x0045 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . - abcde . com " , U_IDNA_STD3_ASCII_RULES_ERROR , TRUE , FALSE , FALSE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x0041 , 0x0042 , 0x0043 , 0x0044 , 0x0045 , 0x002D , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . abcde - . com " , U_IDNA_STD3_ASCII_RULES_ERROR , TRUE , FALSE , FALSE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x0041 , 0x0042 , 0x0043 , 0x0044 , 0x0045 , 0x0040 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . abcde @ . com " , U_IDNA_STD3_ASCII_RULES_ERROR , TRUE , FALSE , FALSE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . . com " , U_IDNA_ZERO_LENGTH_LABEL_ERROR , TRUE , FALSE , FALSE } , { { 0 } , NULL , U_ILLEGAL_ARGUMENT_ERROR , TRUE , TRUE , FALSE } } ; # define MAX_DEST_SIZE 300 void TestIDNA :: debug ( const UChar * src , int32_t srcLength , int32_t options ) { UParseError parseError ; UErrorCode transStatus = U_ZERO_ERROR ; UErrorCode prepStatus = U_ZERO_ERROR ; NamePrepTransform * trans = NamePrepTransform :: createInstance ( parseError , transStatus ) ; int32_t prepOptions = ( ( ( options & UIDNA_ALLOW_UNASSIGNED ) != 0 ) ? USPREP_ALLOW_UNASSIGNED : 0 ) ; LocalUStringPrepProfilePointer prep ( usprep_openByType ( USPREP_RFC3491_NAMEPREP , & prepStatus ) ) ; UChar * transOut = NULL , * prepOut = NULL ; int32_t transOutLength = 0 , prepOutLength = 0 ; transOutLength = trans -> process ( src , srcLength , transOut , 0 , prepOptions > 0 , & parseError , transStatus ) ; if ( transStatus == U_BUFFER_OVERFLOW_ERROR ) { transStatus = U_ZERO_ERROR ; transOut = ( UChar * ) malloc ( U_SIZEOF_UCHAR * transOutLength ) ; transOutLength = trans -> process ( src , srcLength , transOut , transOutLength , prepOptions > 0 , & parseError , transStatus ) ; } prepOutLength = usprep_prepare ( prep . getAlias ( ) , src , srcLength , prepOut , 0 , prepOptions , & parseError , & prepStatus ) ; if ( prepStatus == U_BUFFER_OVERFLOW_ERROR ) { prepStatus = U_ZERO_ERROR ; prepOut = ( UChar * ) malloc ( U_SIZEOF_UCHAR * prepOutLength ) ; prepOutLength = usprep_prepare ( prep . getAlias ( ) , src , srcLength , prepOut , prepOutLength , prepOptions , & parseError , & prepStatus ) ; } if ( UnicodeString ( transOut , transOutLength ) != UnicodeString ( prepOut , prepOutLength ) ) { errln ( " Failed . ▁ Expected : ▁ " + prettify ( UnicodeString ( transOut , transOutLength ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( prepOut , prepOutLength ) ) ) ; } free ( transOut ) ; free ( prepOut ) ; delete trans ; } void TestIDNA :: testAPI ( const UChar * src , const UChar * expected , const char * testName , UBool useSTD3ASCIIRules , UErrorCode expectedStatus , UBool doCompare , UBool testUnassigned , TestFunc func , UBool testSTD3ASCIIRules ) { UErrorCode status = U_ZERO_ERROR ; UChar destStack [ MAX_DEST_SIZE ] ; int32_t destLen = 0 ; UChar * dest = NULL ; int32_t expectedLen = ( expected != NULL ) ? u_strlen ( expected ) : 0 ; int32_t options = ( useSTD3ASCIIRules == TRUE ) ? UIDNA_USE_STD3_RULES : UIDNA_DEFAULT ; UParseError parseError ; int32_t tSrcLen = 0 ; UChar * tSrc = NULL ; if ( src != NULL ) { tSrcLen = u_strlen ( src ) ; tSrc = ( UChar * ) malloc ( U_SIZEOF_UCHAR * tSrcLen ) ; memcpy ( tSrc , src , tSrcLen * U_SIZEOF_UCHAR ) ; } destLen = func ( src , - 1 , NULL , 0 , options , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options , & parseError , & status ) ; if ( U_SUCCESS ( status ) && expectedStatus != U_IDNA_STD3_ASCII_RULES_ERROR && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source . ▁ Expected ▁ : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( dest , destLen ) ) ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus ) { errcheckln ( status , " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; free ( tSrc ) ; return ; } if ( testUnassigned ) { status = U_ZERO_ERROR ; destLen = func ( src , - 1 , NULL , 0 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ " + prettify ( src ) + " ▁ with ▁ both ▁ options ▁ set . ▁ Expected : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) + " Got : ▁ " + prettify ( UnicodeString ( dest , destLen ) ) ) ; debug ( src , - 1 , options | UIDNA_ALLOW_UNASSIGNED ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } status = U_ZERO_ERROR ; destLen = func ( tSrc , tSrcLen , NULL , 0 , options , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } if ( testUnassigned ) { status = U_ZERO_ERROR ; destLen = func ( tSrc , tSrcLen , NULL , 0 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length ▁ and ▁ both ▁ options ▁ set . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } status = U_ZERO_ERROR ; if ( testSTD3ASCIIRules == TRUE ) { destLen = func ( src , - 1 , NULL , 0 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ both ▁ options ▁ set . ▁ Expected : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } status = U_ZERO_ERROR ; destLen = func ( tSrc , tSrcLen , NULL , 0 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length ▁ and ▁ both ▁ options ▁ set . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } free ( tSrc ) ; } void TestIDNA :: testCompare ( const UChar * s1 , int32_t s1Len , const UChar * s2 , int32_t s2Len , const char * testName , CompareFunc func , UBool isEqual ) { UErrorCode status = U_ZERO_ERROR ; int32_t retVal = func ( s1 , - 1 , s2 , - 1 , UIDNA_DEFAULT , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ null ▁ termniated ▁ strings . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , - 1 , s2 , - 1 , UIDNA_ALLOW_UNASSIGNED , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ null ▁ termniated ▁ strings ▁ with ▁ options ▁ set . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ and ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , s1Len , s2 , s2Len , UIDNA_DEFAULT , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ string ▁ length . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ with ▁ string ▁ length . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , s1Len , s2 , s2Len , UIDNA_ALLOW_UNASSIGNED , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ string ▁ length ▁ and ▁ options ▁ set . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ with ▁ string ▁ length ▁ and ▁ options ▁ set . ▁ Error : ▁ % s " , u_errorName ( status ) , testName ) ; } } void TestIDNA :: testToASCII ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testAPI ( unicodeIn [ i ] , buf , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; } } void TestIDNA :: testToUnicode ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( asciiIn ) / sizeof ( asciiIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testAPI ( buf , unicodeIn [ i ] , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; } } void TestIDNA :: testIDNToUnicode ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; UErrorCode status = U_ZERO_ERROR ; int32_t bufLen = 0 ; UParseError parseError ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( domainNames ) / sizeof ( domainNames [ 0 ] ) ) ; i ++ ) { bufLen = ( int32_t ) strlen ( domainNames [ i ] ) ; bufLen = u_unescape ( domainNames [ i ] , buf , bufLen + 1 ) ; func ( buf , bufLen , expected , MAX_DEST_SIZE , UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s " , testName , i , u_errorName ( status ) ) ; break ; } testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s ▁ \n " , testName , i , u_errorName ( status ) ) ; break ; } } } void TestIDNA :: testIDNToASCII ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; UErrorCode status = U_ZERO_ERROR ; int32_t bufLen = 0 ; UParseError parseError ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( domainNames ) / sizeof ( domainNames [ 0 ] ) ) ; i ++ ) { bufLen = ( int32_t ) strlen ( domainNames [ i ] ) ; bufLen = u_unescape ( domainNames [ i ] , buf , bufLen + 1 ) ; func ( buf , bufLen , expected , MAX_DEST_SIZE , UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s " , testName , i , u_errorName ( status ) ) ; break ; } testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , FALSE , TRUE , func ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s ▁ \n " , testName , i , u_errorName ( status ) ) ; break ; } } } void TestIDNA :: testCompare ( const char * testName , CompareFunc func ) { int32_t i ; UChar www [ ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UChar com [ ] = { 0x002E , 0x0043 , 0x004F , 0x004D , 0x0000 } ; UChar buf [ MAX_DEST_SIZE ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UnicodeString source ( www ) , uni0 ( www ) , uni1 ( www ) , ascii0 ( www ) , ascii1 ( www ) ; uni0 . append ( unicodeIn [ 0 ] ) ; uni0 . append ( com ) ; uni0 . append ( ( UChar ) 0x0000 ) ; uni1 . append ( unicodeIn [ 1 ] ) ; uni1 . append ( com ) ; uni1 . append ( ( UChar ) 0x0000 ) ; ascii0 . append ( asciiIn [ 0 ] ) ; ascii0 . append ( com ) ; ascii0 . append ( ( UChar ) 0x0000 ) ; ascii1 . append ( asciiIn [ 1 ] ) ; ascii1 . append ( com ) ; ascii1 . append ( ( UChar ) 0x0000 ) ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf + 4 , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; u_strcat ( buf , com ) ; source . truncate ( 4 ) ; source . append ( unicodeIn [ i ] ) ; source . append ( com ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; int32_t srcLen = u_strlen ( src ) ; testCompare ( src , srcLen , src , srcLen , testName , func , TRUE ) ; testCompare ( src , srcLen , buf , u_strlen ( buf ) , testName , func , TRUE ) ; if ( i == 0 ) { testCompare ( src , srcLen , uni1 . getBuffer ( ) , uni1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , uni0 . getBuffer ( ) , uni0 . length ( ) - 1 , testName , func , FALSE ) ; } if ( i == 0 ) { testCompare ( src , srcLen , ascii1 . getBuffer ( ) , ascii1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , ascii0 . getBuffer ( ) , ascii0 . length ( ) - 1 , testName , func , FALSE ) ; } } } # if 0 static int32_t getNextSeperator ( UChar * src , int32_t srcLength , UChar * * limit ) { if ( srcLength == - 1 ) { int32_t i ; for ( i = 0 ; ; i ++ ) { if ( src [ i ] == 0 ) { * limit = src + i ; return i ; } if ( src [ i ] == 0x002e ) { * limit = src + ( i + 1 ) ; return i ; } } if ( i == srcLength ) { * limit = src + srcLength ; } return i ; } else { int32_t i ; for ( i = 0 ; i < srcLength ; i ++ ) { if ( src [ i ] == 0x002e ) { * limit = src + ( i + 1 ) ; return i ; } } if ( i == srcLength ) { * limit = src + srcLength ; } return i ; } } void printPunycodeOutput ( ) { UChar dest [ MAX_DEST_SIZE ] ; int32_t destCapacity = MAX_DEST_SIZE ; UChar * start ; UChar * limit ; int32_t labelLen = 0 ; UBool caseFlags [ MAX_DEST_SIZE ] ; for ( int32_t i = 0 ; i < sizeof ( errorCases ) / sizeof ( errorCases [ 0 ] ) ; i ++ ) { ErrorCases errorCase = errorCases [ i ] ; UErrorCode status = U_ZERO_ERROR ; start = errorCase . unicode ; int32_t srcLen = u_strlen ( start ) ; labelLen = getNextSeperator ( start , srcLen , & limit ) ; start = limit ; labelLen = getNextSeperator ( start , srcLen - labelLen , & limit ) ; int32_t destLen = u_strToPunycode ( dest , destCapacity , start , labelLen , caseFlags , & status ) ; if ( U_FAILURE ( status ) ) { printf ( " u _ strToPunycode ▁ failed ▁ for ▁ index ▁ % i \n " , i ) ; continue ; } for ( int32_t j = 0 ; j < destLen ; j ++ ) { printf ( " % c " , ( char ) dest [ j ] ) ; } printf ( " \n " ) ; } } # endif void TestIDNA :: testErrorCases ( const char * IDNToASCIIName , TestFunc IDNToASCII , const char * IDNToUnicodeName , TestFunc IDNToUnicode ) { UChar buf [ MAX_DEST_SIZE ] ; int32_t bufLen = 0 ; for ( int32_t i = 0 ; i < ( int32_t ) ( sizeof ( errorCases ) / sizeof ( errorCases [ 0 ] ) ) ; i ++ ) { ErrorCases errorCase = errorCases [ i ] ; UChar * src = NULL ; if ( errorCase . ascii != NULL ) { bufLen = ( int32_t ) strlen ( errorCase . ascii ) ; u_charsToUChars ( errorCase . ascii , buf , bufLen + 1 ) ; } else { bufLen = 1 ; memset ( buf , 0 , U_SIZEOF_UCHAR * MAX_DEST_SIZE ) ; } if ( errorCase . unicode [ 0 ] != 0 ) { src = errorCase . unicode ; } testAPI ( src , buf , IDNToASCIIName , errorCase . useSTD3ASCIIRules , errorCase . expected , TRUE , TRUE , IDNToASCII ) ; if ( errorCase . testLabel == TRUE ) { testAPI ( src , buf , IDNToASCIIName , errorCase . useSTD3ASCIIRules , errorCase . expected , FALSE , TRUE , IDNToASCII ) ; } if ( errorCase . testToUnicode == TRUE ) { testAPI ( ( src == NULL ) ? NULL : buf , src , IDNToUnicodeName , errorCase . useSTD3ASCIIRules , errorCase . expected , TRUE , TRUE , IDNToUnicode ) ; } } } void TestIDNA :: testChaining ( const UChar * src , int32_t numIterations , const char * testName , UBool useSTD3ASCIIRules , UBool caseInsensitive , TestFunc func ) { UChar even [ MAX_DEST_SIZE ] ; UChar odd [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; int32_t i = 0 , evenLen = 0 , oddLen = 0 , expectedLen = 0 ; UErrorCode status = U_ZERO_ERROR ; int32_t srcLen = u_strlen ( src ) ; int32_t options = ( useSTD3ASCIIRules == TRUE ) ? UIDNA_USE_STD3_RULES : UIDNA_DEFAULT ; UParseError parseError ; expectedLen = func ( src , - 1 , expected , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , - 1 , even , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , - 1 , odd , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; } } status = U_ZERO_ERROR ; expectedLen = func ( src , - 1 , expected , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , - 1 , even , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , - 1 , odd , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; } } status = U_ZERO_ERROR ; expectedLen = func ( src , srcLen , expected , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , oddLen , even , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , evenLen , odd , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ source ▁ with ▁ source ▁ length ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ source ▁ with ▁ source ▁ length ▁ failed \n " , testName ) ; } } status = U_ZERO_ERROR ; expectedLen = func ( src , srcLen , expected , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , oddLen , even , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , evenLen , odd , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed \n " , testName ) ; } } } void TestIDNA :: testChaining ( const char * toASCIIName , TestFunc toASCII , const char * toUnicodeName , TestFunc toUnicode ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( asciiIn ) / sizeof ( asciiIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testChaining ( buf , 5 , toUnicodeName , FALSE , FALSE , toUnicode ) ; } for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { testChaining ( unicodeIn [ i ] , 5 , toASCIIName , FALSE , TRUE , toASCII ) ; } } void TestIDNA :: testRootLabelSeparator ( const char * testName , CompareFunc func , const char * IDNToASCIIName , TestFunc IDNToASCII , const char * IDNToUnicodeName , TestFunc IDNToUnicode ) { int32_t i ; UChar www [ ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UChar com [ ] = { 0x002E , 0x0043 , 0x004F , 0x004D , 0x002E , 0x0000 } ; UChar buf [ MAX_DEST_SIZE ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UnicodeString source ( www ) , uni0 ( www ) , uni1 ( www ) , ascii0 ( www ) , ascii1 ( www ) ; uni0 . append ( unicodeIn [ 0 ] ) ; uni0 . append ( com ) ; uni0 . append ( ( UChar ) 0x0000 ) ; uni1 . append ( unicodeIn [ 1 ] ) ; uni1 . append ( com ) ; uni1 . append ( ( UChar ) 0x0000 ) ; ascii0 . append ( asciiIn [ 0 ] ) ; ascii0 . append ( com ) ; ascii0 . append ( ( UChar ) 0x0000 ) ; ascii1 . append ( asciiIn [ 1 ] ) ; ascii1 . append ( com ) ; ascii1 . append ( ( UChar ) 0x0000 ) ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf + 4 , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; u_strcat ( buf , com ) ; source . truncate ( 4 ) ; source . append ( unicodeIn [ i ] ) ; source . append ( com ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; int32_t srcLen = u_strlen ( src ) ; testCompare ( src , srcLen , buf , u_strlen ( buf ) , testName , func , TRUE ) ; testCompare ( src , srcLen , src , srcLen , testName , func , TRUE ) ; testAPI ( src , buf , IDNToASCIIName , FALSE , U_ZERO_ERROR , TRUE , TRUE , IDNToASCII ) ; testAPI ( buf , src , IDNToUnicodeName , FALSE , U_ZERO_ERROR , TRUE , TRUE , IDNToUnicode ) ; if ( i == 0 ) { testCompare ( src , srcLen , uni1 . getBuffer ( ) , uni1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , uni0 . getBuffer ( ) , uni0 . length ( ) - 1 , testName , func , FALSE ) ; } if ( i == 0 ) { testCompare ( src , srcLen , ascii1 . getBuffer ( ) , ascii1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , ascii0 . getBuffer ( ) , ascii0 . length ( ) - 1 , testName , func , FALSE ) ; } } } extern IntlTest * createUTS46Test ( ) ; void TestIDNA :: runIndexedTest ( int32_t index , UBool exec , const char * & name , char * par ) { if ( exec ) logln ( ( UnicodeString ) " TestSuite ▁ IDNA ▁ API ▁ " ) ; switch ( index ) { case 0 : name = " TestToASCII " ; if ( exec ) TestToASCII ( ) ; break ; case 1 : name = " TestToUnicode " ; if ( exec ) TestToUnicode ( ) ; break ; case 2 : name = " TestIDNToASCII " ; if ( exec ) TestIDNToASCII ( ) ; break ; case 3 : name = " TestIDNToUnicode " ; if ( exec ) TestIDNToUnicode ( ) ; break ; case 4 : name = " TestCompare " ; if ( exec ) TestCompare ( ) ; break ; case 5 : name = " TestErrorCases " ; if ( exec ) TestErrorCases ( ) ; break ; case 6 : name = " TestChaining " ; if ( exec ) TestChaining ( ) ; break ; case 7 : name = " TestRootLabelSeparator " ; if ( exec ) TestRootLabelSeparator ( ) ; break ; case 8 : name = " TestCompareReferenceImpl " ; if ( exec ) TestCompareReferenceImpl ( ) ; break ; case 9 : name = " TestDataFile " ; if ( exec ) TestDataFile ( ) ; break ; # if ! UCONFIG_NO_FILE_IO && ! UCONFIG_NO_LEGACY_CONVERSION case 10 : name = " TestRefIDNA " ; if ( exec ) TestRefIDNA ( ) ; break ; case 11 : name = " TestIDNAMonkeyTest " ; if ( exec ) TestIDNAMonkeyTest ( ) ; break ; # else case 10 : case 11 : name = " skip " ; break ; # endif case 12 : { name = " TestConformanceTestVectors " ; if ( exec ) { logln ( " TestSuite ▁ IDNA ▁ conf - - - - " ) ; logln ( ) ; IdnaConfTest test ; callTest ( test , par ) ; } break ; } case 13 : name = " UTS46Test " ; if ( exec ) { logln ( " TestSuite ▁ UTS46Test - - - " ) ; logln ( ) ; LocalPointer < IntlTest > test ( createUTS46Test ( ) ) ; callTest ( * test , par ) ; } break ; default : name = " " ; break ; } } void TestIDNA :: TestToASCII ( ) { testToASCII ( " uidna _ toASCII " , uidna_toASCII ) ; } void TestIDNA :: TestToUnicode ( ) { testToUnicode ( " uidna _ toUnicode " , uidna_toUnicode ) ; } void TestIDNA :: TestIDNToASCII ( ) { testIDNToASCII ( " uidna _ IDNToASCII " , uidna_IDNToASCII ) ; } void TestIDNA :: TestIDNToUnicode ( ) { testIDNToUnicode ( " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; } void TestIDNA :: TestCompare ( ) { testCompare ( " uidna _ compare " , uidna_compare ) ; } void TestIDNA :: TestErrorCases ( ) { testErrorCases ( " uidna _ IDNToASCII " , uidna_IDNToASCII , " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; } void TestIDNA :: TestRootLabelSeparator ( ) { testRootLabelSeparator ( " uidna _ compare " , uidna_compare , " uidna _ IDNToASCII " , uidna_IDNToASCII , " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; } void TestIDNA :: TestChaining ( ) { testChaining ( " uidna _ toASCII " , uidna_toASCII , " uidna _ toUnicode " , uidna_toUnicode ) ; } static const int loopCount = 100 ; static const int maxCharCount = 20 ; static const int maxCodePoint = 0x10ffff ; static uint32_t randul ( ) { static UBool initialized = FALSE ; if ( ! initialized ) { srand ( ( unsigned ) time ( NULL ) ) ; initialized = TRUE ; } uint32_t l = 0 ; for ( uint32_t i = 0 ; i < sizeof ( l ) ; ++ i ) ( ( char * ) & l ) [ i ] = ( char ) ( ( rand ( ) & 0x0FF0 ) >> 4 ) ; return l ; } static int32_t rand_uni ( ) { int32_t retVal = ( int32_t ) ( randul ( ) & 0x3FFFF ) ; if ( retVal >= 0x30000 ) { retVal += 0xB0000 ; } return retVal ; } static int32_t randi ( int32_t n ) { return ( int32_t ) ( randul ( ) % ( n + 1 ) ) ; } void getTestSource ( UnicodeString & fillIn ) { int32_t i = 0 ; int32_t charCount = ( randi ( maxCharCount ) + 1 ) ; while ( i < charCount ) { int32_t codepoint = rand_uni ( ) ; if ( codepoint == 0x0000 ) { continue ; } fillIn . append ( ( UChar32 ) codepoint ) ; i ++ ; } } UnicodeString TestIDNA :: testCompareReferenceImpl ( UnicodeString & src , TestFunc refIDNA , const char * refIDNAName , TestFunc uIDNA , const char * uIDNAName , int32_t options ) { const UChar * srcUChars = src . getBuffer ( ) ; UChar exp [ MAX_DEST_SIZE ] = { 0 } ; int32_t expCap = MAX_DEST_SIZE , expLen = 0 ; UErrorCode expStatus = U_ZERO_ERROR ; UParseError parseError ; logln ( " Comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ for ▁ input : ▁ " + prettify ( srcUChars ) ) ; expLen = refIDNA ( srcUChars , src . length ( ) - 1 , exp , expCap , options , & parseError , & expStatus ) ; UChar got [ MAX_DEST_SIZE ] = { 0 } ; int32_t gotCap = MAX_DEST_SIZE , gotLen = 0 ; UErrorCode gotStatus = U_ZERO_ERROR ; gotLen = uIDNA ( srcUChars , src . length ( ) - 1 , got , gotCap , options , & parseError , & gotStatus ) ; if ( expStatus != gotStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ status ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( gotStatus ) ) + " ▁ for ▁ Source : ▁ " + prettify ( srcUChars ) + " ▁ Options : ▁ " + options ) ; return UnicodeString ( " " ) ; } if ( U_SUCCESS ( expStatus ) ) { if ( u_strCompare ( exp , expLen , got , gotLen , TRUE ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ output ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ Expected : ▁ " + prettify ( UnicodeString ( exp , expLen ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( got , gotLen ) ) + " ▁ for ▁ Source : ▁ " + prettify ( srcUChars ) + " ▁ Options : ▁ " + options ) ; } return UnicodeString ( exp , expLen ) ; } else { logln ( " Got ▁ the ▁ same ▁ error ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ for ▁ input : ▁ " + prettify ( srcUChars ) ) ; } return UnicodeString ( " " ) ; } void TestIDNA :: testCompareReferenceImpl ( const UChar * src , int32_t srcLen ) { UnicodeString label ( src , srcLen ) ; label . append ( ( UChar ) 0x0000 ) ; UnicodeString asciiLabel = testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_ALLOW_UNASSIGNED ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_DEFAULT ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_USE_STD3_RULES ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_USE_STD3_RULES | UIDNA_ALLOW_UNASSIGNED ) ; if ( asciiLabel . length ( ) != 0 ) { asciiLabel . append ( ( UChar ) 0x0000 ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_ALLOW_UNASSIGNED ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_DEFAULT ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_USE_STD3_RULES ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_USE_STD3_RULES | UIDNA_ALLOW_UNASSIGNED ) ; } } const char * failures [ ] = { " \\uAA42\\U0001F8DD\\U00019D01\\U000149A3\\uD385\\U000EE0F5\\U00018B92\\U000179D1\\U00018624\\U0002227F\\U000E83C0\\U000E8DCD\\u5460\\U00017F34\\U0001570B\\u43D1\\U0002C9C9\\U000281EC\\u2105\\U000180AE\\uC5D4" , " \\U0002F5A6\\uD638\\u0D0A\\u9E9C\\uFE5B\\U0001FCCB\\u66C4" , } ; void TestIDNA :: TestIDNAMonkeyTest ( ) { UnicodeString source ; UErrorCode status = U_ZERO_ERROR ; int i ; getInstance ( status ) ; if ( U_FAILURE ( status ) ) { dataerrln ( " Test ▁ could ▁ not ▁ initialize . ▁ Got ▁ % s " , u_errorName ( status ) ) ; return ; } for ( i = 0 ; i < loopCount ; i ++ ) { source . truncate ( 0 ) ; getTestSource ( source ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; } for ( i = 0 ; i < ( int ) ( sizeof ( failures ) / sizeof ( failures [ 0 ] ) ) ; i ++ ) { source . truncate ( 0 ) ; source . append ( UnicodeString ( failures [ i ] , - 1 , US_INV ) ) ; source = source . unescape ( ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; } source . truncate ( 0 ) ; source . append ( UNICODE_STRING_SIMPLE ( " \\uCF18\\U00021161\\U000EEF11\\U0002BB82\\U0001D63C " ) ) ; debug ( source . getBuffer ( ) , source . length ( ) , UIDNA_ALLOW_UNASSIGNED ) ; { UnicodeString source ( " \\u043f\\u00AD\\u034f\\u043e\\u0447\\u0435\\u043c\\u0443\\u0436\\u0435\\u043e\\u043d\\u0438\\u043d\\u0435\\u0433\\u043e\\u0432\\u043e\\u0440\\u044f\\u0442\\u043f\\u043e\\u0440\\u0443\\u0441\\u0441\\u043a\\u0438\\u0000" , - 1 , US_INV ) ; source = source . unescape ( ) ; UnicodeString expected ( " \\u043f\\u043e\\u0447\\u0435\\u043c\\u0443\\u0436\\u0435\\u043e\\u043d\\u0438\\u043d\\u0435\\u0433\\u043e\\u0432\\u043e\\u0440\\u044f\\u0442\\u043f\\u043e\\u0440\\u0443\\u0441\\u0441\\u043a\\u0438\\u0000" , - 1 , US_INV ) ; expected = expected . unescape ( ) ; UnicodeString ascii ( " xn - - b1abfaaepdrnnbgefbadotcwatmq2g4l " ) ; ascii . append ( ( UChar ) 0x0000 ) ; testAPI ( source . getBuffer ( ) , ascii . getBuffer ( ) , " uidna _ toASCII " , FALSE , U_ZERO_ERROR , TRUE , TRUE , uidna_toASCII ) ; testAPI ( source . getBuffer ( ) , ascii . getBuffer ( ) , " idnaref _ toASCII " , FALSE , U_ZERO_ERROR , TRUE , TRUE , idnaref_toASCII ) ; testCompareReferenceImpl ( source . getBuffer ( ) , source . length ( ) - 1 ) ; } } void TestIDNA :: TestCompareReferenceImpl ( ) { UChar src [ 2 ] = { 0 , 0 } ; int32_t srcLen = 0 ; for ( int32_t i = 0x40000 ; i < 0x10ffff ; i ++ ) { if ( quick == TRUE && i > 0x1FFFF ) { return ; } if ( i >= 0x30000 && i <= 0xF0000 ) { i += 0xB0000 ; } if ( i > 0xFFFF ) { src [ 0 ] = U16_LEAD ( i ) ; src [ 1 ] = U16_TRAIL ( i ) ; srcLen = 2 ; } else { src [ 0 ] = ( UChar ) i ; src [ 1 ] = 0 ; srcLen = 1 ; } testCompareReferenceImpl ( src , srcLen ) ; } } void TestIDNA :: TestRefIDNA ( ) { UErrorCode status = U_ZERO_ERROR ; getInstance ( status ) ; if ( U_FAILURE ( status ) ) { if ( status == U_FILE_ACCESS_ERROR ) { dataerrln ( " Test ▁ could ▁ not ▁ initialize . ▁ Got ▁ % s " , u_errorName ( status ) ) ; } return ; } testToASCII ( " idnaref _ toASCII " , idnaref_toASCII ) ; testToUnicode ( " idnaref _ toUnicode " , idnaref_toUnicode ) ; testIDNToASCII ( " idnaref _ IDNToASCII " , idnaref_IDNToASCII ) ; testIDNToUnicode ( " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testCompare ( " idnaref _ compare " , idnaref_compare ) ; testErrorCases ( " idnaref _ IDNToASCII " , idnaref_IDNToASCII , " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testChaining ( " idnaref _ toASCII " , idnaref_toASCII , " idnaref _ toUnicode " , idnaref_toUnicode ) ; testRootLabelSeparator ( " idnaref _ compare " , idnaref_compare , " idnaref _ IDNToASCII " , idnaref_IDNToASCII , " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testChaining ( " idnaref _ toASCII " , idnaref_toASCII , " idnaref _ toUnicode " , idnaref_toUnicode ) ; } void TestIDNA :: TestDataFile ( ) { testData ( * this ) ; } TestIDNA :: ~ TestIDNA ( ) { if ( gPrep != NULL ) { delete gPrep ; gPrep = NULL ; } } NamePrepTransform * TestIDNA :: gPrep = NULL ; NamePrepTransform * TestIDNA :: getInstance ( UErrorCode & status ) { if ( TestIDNA :: gPrep == NULL ) { UParseError parseError ; TestIDNA :: gPrep = NamePrepTransform :: createInstance ( parseError , status ) ; if ( TestIDNA :: gPrep == NULL ) { return NULL ; } } return TestIDNA :: gPrep ; } # endif </DOCUMENT>
<DOCUMENT_ID="liuchuo/LeetCode-practice/tree/master/C++/079. Word Search.cpp"> 79. Word Search Given a 2D board and a word , find if the word exists in the grid . The word can be constructed from letters of sequentially adjacent cell , where " adjacent " cells are those horizontally or vertically neighboring . The same letter cell may not be used more than once . For example , Given board = [ [ ' A ' , ' B ' , ' C ' , ' E ' ] , [ ' S ' , ' F ' , ' C ' , ' S ' ] , [ ' A ' , ' D ' , ' E ' , ' E ' ] ] word = " ABCCED " , -> returns true , word = " SEE " , -> returns true , word = " ABCB " , -> returns false . 题目大意：给一个char型二维数组和一个word字符串，寻找网格中是否含有word字符串，只能通过相邻（垂直或者水平）的格子连接～ 分析：对于二维数组中的每一个点都开始遍历，如果当前点的字母正好等于word [ 0 ] 就进入dfs，设立flag标记是否找到，设立visit标记是否访问： 首先令起始节点visit [ j ] [ k ] 标记为已经访问过，接着dfs，如果flag为true直接return，如果当前index正好为word的最后一个字符下标就标记flag为true，return 。 从四个方向开始对结点进行深度优先搜索，首先要保证搜索的结点满足：1 . 是合法的在网格之内的 2 . 未被访问过 3 . 当前字符与要找的word [ index + 1 ] 相同 。 满足则标记visit [ tx ] [ ty ] = true , 且dfs tx和ty以及index + 1 ， 两个dfs后要把他重新置为false ～ 这样最后返回flag的值即为是否能找到的结果～ class Solution { private : bool flag = false ; vector < vector < bool >> visit ; vector < vector < char >> board ; string word = " " ; int dir [ 4 ] [ 2 ] = { { 0 , 1 } , { 1 , 0 } , { 0 , - 1 } , { - 1 , 0 } } ; int m , n ; public : bool exist ( vector < vector < char >> & board , string word ) { if ( board . size ( ) == 0 ) return word == " " ; m = board . size ( ) , n = board [ 0 ] . size ( ) ; this -> word = word ; this -> board = board ; visit . resize ( m , vector < bool > ( n ) ) ; for ( int j = 0 ; j < m ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( board [ j ] [ k ] == word [ 0 ] ) { visit [ j ] [ k ] = true ; dfs ( j , k , 0 ) ; visit [ j ] [ k ] = false ; } } } return flag ; } void dfs ( int x , int y , int index ) { if ( flag == true ) return ; if ( index == word . length ( ) - 1 ) { flag = true ; return ; } for ( int i = 0 ; i < 4 ; i ++ ) { int tx = x + dir [ i ] [ 0 ] , ty = y + dir [ i ] [ 1 ] ; if ( tx >= 0 && tx < m && ty >= 0 && ty < n && board [ tx ] [ ty ] == word [ index + 1 ] && visit [ tx ] [ ty ] == false ) { visit [ tx ] [ ty ] = true ; dfs ( tx , ty , index + 1 ) ; visit [ tx ] [ ty ] = false ; } } } } ; </DOCUMENT>
<DOCUMENT_ID="Distrotech/xbmc/tree/master/xbmc/android/jni/BaseColumns.cpp"> # include " BaseColumns . h " # include " jutils / jutils - details . hpp " using namespace jni ; std :: string CJNIBaseColumns :: _ID ; std :: string CJNIBaseColumns :: _COUNT ; void CJNIBaseColumns :: PopulateStaticFields ( ) { jhclass clazz = find_class ( " android / provider / BaseColumns " ) ; _ID = ( jcast < std :: string > ( get_static_field < jhstring > ( clazz , " _ ID " ) ) ) ; _COUNT = ( jcast < std :: string > ( get_static_field < jhstring > ( clazz , " _ COUNT " ) ) ) ; } </DOCUMENT>
<DOCUMENT_ID="BenKeyFSI/poedit/tree/master/deps/boost/libs/wave/test/testwave/testfiles/t_6_044.cpp"> # define CON ## name CON </DOCUMENT>
<DOCUMENT_ID="yxcoin/yxcoin/tree/master/src/boost_1_55_0/libs/phoenix/test/include/stl/algorithm/querying.cpp"> # include < boost / phoenix / stl / algorithm / querying . hpp > int main ( ) { } </DOCUMENT>
<DOCUMENT_ID="wayfinder/Wayfinder-S60-Navigator/tree/master/CPP/Shared/GuiProt/GeneralParamReceiver.cpp"> # include " arch . h " # include " GuiProt / GuiParameterEnums . h " # include " GuiProt / GuiProtEnums . h " # include " GuiProt / GuiProtMess . h " # include " GuiProt / GeneralParamReceiver . h " # include " GuiProt / GuiProtMessageHandler . h " # include " GenericSettingsData . h " namespace isab { GeneralParamReceiver :: ~ GeneralParamReceiver ( ) { m_guiProtHandler -> DeregisterReceiver ( this , isab :: GuiProtEnums :: SET_GENERAL_PARAMETER ) ; m_guiProtHandler -> DeregisterReceiver ( this , isab :: GuiProtEnums :: GET_GENERAL_PARAMETER ) ; } void GeneralParamReceiver :: init ( ) { m_guiProtHandler -> RegisterReceiver ( this , isab :: GuiProtEnums :: SET_GENERAL_PARAMETER ) ; m_guiProtHandler -> RegisterReceiver ( this , isab :: GuiProtEnums :: GET_GENERAL_PARAMETER ) ; } bool GeneralParamReceiver :: decodedParamNoValue ( uint32 paramId ) { return false ; } bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const float * data , int32 numEntries ) { return false ; } bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const uint8 * data , int32 numEntries ) { return false ; } bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const char * * data , int32 numEntries ) { return false ; } bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const int32 * data , int32 numEntries ) { switch ( paramId ) { case GuiProtEnums :: paramAutoReroute : { m_settingsData -> m_autoReroute = data [ 0 ] ; } break ; case GuiProtEnums :: paramBacklightStrategy : { m_settingsData -> m_backlightStrategy = data [ 0 ] ; } break ; case GuiProtEnums :: paramAutoTracking : { m_settingsData -> m_autoTracking = data [ 0 ] ; } break ; case GuiProtEnums :: paramDistanceMode : { m_settingsData -> m_distanceMode = data [ 0 ] ; } break ; case GuiProtEnums :: paramFavoriteShow : { m_settingsData -> m_favoriteShowInMap = data [ 0 ] ; } break ; case GuiProtEnums :: paramHighways : { m_settingsData -> m_routeHighways = data [ 0 ] ; } break ; case GuiProtEnums :: paramTollRoads : { m_settingsData -> m_routeTollRoads = data [ 0 ] ; } break ; case GuiProtEnums :: paramTimeDist : { m_settingsData -> m_routeCostType = data [ 0 ] ; } break ; case GuiProtEnums :: paramTrackingLevel : { m_settingsData -> m_trackingLevel = data [ 0 ] ; } break ; case GuiProtEnums :: paramTransportationType : { m_settingsData -> m_transportationType = data [ 0 ] ; } break ; case GuiProtEnums :: paramTurnSoundsLevel : { m_settingsData -> m_turnSoundsLevel = data [ 0 ] ; } break ; case GuiProtEnums :: userTrafficUpdatePeriod : { int32 val = data [ 0 ] ; m_settingsData -> m_trafficUpdatePeriod = 0xbfffffff & val ; m_settingsData -> m_trafficOldUpdatePeriod = 0xbfffffff & val ; m_settingsData -> m_trafficUpdate = 0x40000000 & val ? 0 : 1 ; m_settingsData -> m_trafficOldUpdate = 0x40000000 & val ? 0 : 1 ; } break ; case GuiProtEnums :: paramAutomaticRouteOnSMSDest : { m_settingsData -> m_autoRouteOnSMSDest = data [ 0 ] ; } break ; case GuiProtEnums :: paramKeepSMSDestInInbox : { m_settingsData -> m_keepSMSDestInInbox = data [ 0 ] ; } break ; case GuiProtEnums :: paramStoreSMSDestInMyDest : { m_settingsData -> m_storeSMSDestInFavorites = data [ 0 ] ; } break ; case GuiProtEnums :: paramPositionSymbol : { m_settingsData -> m_positionSymbol = data [ 0 ] ; } break ; case GuiProtEnums :: paramCheckForUpdates : { m_settingsData -> m_checkForUpdates = data [ 0 ] ; } break ; default : return false ; break ; } return true ; } bool GeneralParamReceiver :: GuiProtReceiveMessage ( class GuiProtMess * mess ) { GuiProtEnums :: MessageType type = mess -> getMessageType ( ) ; if ( type == GuiProtEnums :: GET_GENERAL_PARAMETER ) { isab :: GeneralParameterMess * gpm = ( isab :: GeneralParameterMess * ) mess ; return decodedParamNoValue ( gpm -> getParamId ( ) ) ; } else if ( type == GuiProtEnums :: SET_GENERAL_PARAMETER ) { isab :: GeneralParameterMess * gpm = ( isab :: GeneralParameterMess * ) mess ; switch ( gpm -> getParamType ( ) ) { case isab :: GuiProtEnums :: paramTypeInt32 : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getIntegerData ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramTypeFloat : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getFloatData ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramTypeBinary : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getBinaryData ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramTypeString : return decodedParamValue ( gpm -> getParamId ( ) , ( const char * * ) gpm -> getStringData ( ) , gpm -> getNumEntries ( ) ) ; break ; default : case isab :: GuiProtEnums :: paramTypeInvalid : return false ; break ; } } return false ; } } </DOCUMENT>
<DOCUMENT_ID="waddlesplash/DolphinQt/tree/master/Externals/wxWidgets3/src/osx/carbon/textctrl.cpp"> # include " wx / wxprec . h " # if wxUSE_TEXTCTRL # include " wx / textctrl . h " # ifndef WX_PRECOMP # include " wx / intl . h " # include " wx / app . h " # include " wx / utils . h " # include " wx / dc . h " # include " wx / button . h " # include " wx / menu . h " # include " wx / settings . h " # include " wx / msgdlg . h " # include " wx / toplevel . h " # endif # ifdef __DARWIN__ # include < sys / types . h > # include < sys / stat . h > # else # include < stat . h > # endif # if wxUSE_STD_IOSTREAM # if wxUSE_IOSTREAMH # include < fstream . h > # else # include < fstream > # endif # endif # include " wx / filefn . h " # include " wx / sysopt . h " # include " wx / thread . h " # include " wx / osx / private . h " # include " wx / osx / carbon / private / mactext . h " class wxMacFunctor { public : wxMacFunctor ( ) { } virtual ~ wxMacFunctor ( ) { } virtual void * operator ( ) ( ) = 0 ; static void * CallBackProc ( void * param ) { wxMacFunctor * f = ( wxMacFunctor * ) param ; void * result = ( * f ) ( ) ; return result ; } } ; template < typename classtype , typename param1type > class wxMacObjectFunctor1 : public wxMacFunctor { typedef void ( classtype :: * function ) ( param1type p1 ) ; typedef void ( classtype :: * ref_function ) ( const param1type & p1 ) ; public : wxMacObjectFunctor1 ( classtype * obj , function f , param1type p1 ) : wxMacFunctor ( ) { m_object = obj ; m_function = f ; m_param1 = p1 ; } wxMacObjectFunctor1 ( classtype * obj , ref_function f , param1type p1 ) : wxMacFunctor ( ) { m_object = obj ; m_refFunction = f ; m_param1 = p1 ; } virtual ~ wxMacObjectFunctor1 ( ) { } virtual void * operator ( ) ( ) { ( m_object ->* m_function ) ( m_param1 ) ; return NULL ; } private : classtype * m_object ; param1type m_param1 ; union { function m_function ; ref_function m_refFunction ; } ; } ; template < typename classtype , typename param1type > void * wxMacMPRemoteCall ( classtype * object , void ( classtype :: * function ) ( param1type p1 ) , param1type p1 ) { wxMacObjectFunctor1 < classtype , param1type > params ( object , function , p1 ) ; void * result = MPRemoteCall ( wxMacFunctor :: CallBackProc , & params , kMPOwningProcessRemoteContext ) ; return result ; } template < typename classtype , typename param1type > void * wxMacMPRemoteCall ( classtype * object , void ( classtype :: * function ) ( const param1type & p1 ) , param1type p1 ) { wxMacObjectFunctor1 < classtype , param1type > params ( object , function , p1 ) ; void * result = MPRemoteCall ( wxMacFunctor :: CallBackProc , & params , kMPOwningProcessRemoteContext ) ; return result ; } template < typename classtype , typename param1type > void * wxMacMPRemoteGUICall ( classtype * object , void ( classtype :: * function ) ( param1type p1 ) , param1type p1 ) { wxMutexGuiLeave ( ) ; void * result = wxMacMPRemoteCall ( object , function , p1 ) ; wxMutexGuiEnter ( ) ; return result ; } template < typename classtype , typename param1type > void * wxMacMPRemoteGUICall ( classtype * object , void ( classtype :: * function ) ( const param1type & p1 ) , param1type p1 ) { wxMutexGuiLeave ( ) ; void * result = wxMacMPRemoteCall ( object , function , p1 ) ; wxMutexGuiEnter ( ) ; return result ; } class WXDLLEXPORT wxMacPortSaver { wxDECLARE_NO_COPY_CLASS ( wxMacPortSaver ) ; public : wxMacPortSaver ( GrafPtr port ) ; ~ wxMacPortSaver ( ) ; private : GrafPtr m_port ; } ; class WXDLLEXPORT wxMacWindowClipper : public wxMacPortSaver { wxDECLARE_NO_COPY_CLASS ( wxMacWindowClipper ) ; public : wxMacWindowClipper ( const wxWindow * win ) ; ~ wxMacWindowClipper ( ) ; private : GrafPtr m_newPort ; RgnHandle m_formerClip ; RgnHandle m_newClip ; } ; wxMacPortSaver :: wxMacPortSaver ( GrafPtr port ) { :: GetPort ( & m_port ) ; :: SetPort ( port ) ; } wxMacPortSaver :: ~ wxMacPortSaver ( ) { :: SetPort ( m_port ) ; } wxMacWindowClipper :: wxMacWindowClipper ( const wxWindow * win ) : wxMacPortSaver ( ( GrafPtr ) GetWindowPort ( ( WindowRef ) win -> MacGetTopLevelWindowRef ( ) ) ) { m_newPort = ( GrafPtr ) GetWindowPort ( ( WindowRef ) win -> MacGetTopLevelWindowRef ( ) ) ; m_formerClip = NewRgn ( ) ; m_newClip = NewRgn ( ) ; GetClip ( m_formerClip ) ; if ( win ) { if ( win -> GetPeer ( ) ) { int x = 0 , y = 0 ; win -> MacWindowToRootWindow ( & x , & y ) ; HIShapeGetAsQDRgn ( ( ( wxWindow * ) win ) -> MacGetVisibleRegion ( true ) . GetWXHRGN ( ) , m_newClip ) ; if ( ! EmptyRgn ( m_newClip ) ) OffsetRgn ( m_newClip , x , y ) ; } SetClip ( m_newClip ) ; } } wxMacWindowClipper :: ~ wxMacWindowClipper ( ) { SetPort ( m_newPort ) ; SetClip ( m_formerClip ) ; DisposeRgn ( m_newClip ) ; DisposeRgn ( m_formerClip ) ; } class wxMacMLTEControl : public wxMacControl , public wxTextWidgetImpl { public : wxMacMLTEControl ( wxTextCtrl * peer ) ; ~ wxMacMLTEControl ( ) { } virtual bool CanFocus ( ) const { return true ; } virtual wxString GetStringValue ( ) const ; virtual void SetStringValue ( const wxString & str ) ; static TXNFrameOptions FrameOptionsFromWXStyle ( long wxStyle ) ; void AdjustCreationAttributes ( const wxColour & background , bool visible ) ; virtual void SetFont ( const wxFont & font , const wxColour & foreground , long windowStyle , bool ignoreBlack ) ; virtual void SetBackgroundColour ( const wxColour & col ) ; virtual void SetStyle ( long start , long end , const wxTextAttr & style ) ; virtual void Copy ( ) ; virtual void Cut ( ) ; virtual void Paste ( ) ; virtual bool CanPaste ( ) const ; virtual void SetEditable ( bool editable ) ; virtual long GetLastPosition ( ) const ; virtual void Replace ( long from , long to , const wxString & str ) ; virtual void Remove ( long from , long to ) ; virtual void GetSelection ( long * from , long * to ) const ; virtual void SetSelection ( long from , long to ) ; virtual void WriteText ( const wxString & str ) ; virtual bool HasOwnContextMenu ( ) const { TXNCommandEventSupportOptions options ; TXNGetCommandEventSupport ( m_txn , & options ) ; return options & kTXNSupportEditCommandProcessing ; } virtual void CheckSpelling ( bool check ) { TXNSetSpellCheckAsYouType ( m_txn , ( Boolean ) check ) ; } virtual void Clear ( ) ; virtual bool CanUndo ( ) const ; virtual void Undo ( ) ; virtual bool CanRedo ( ) const ; virtual void Redo ( ) ; virtual int GetNumberOfLines ( ) const ; virtual long XYToPosition ( long x , long y ) const ; virtual bool PositionToXY ( long pos , long * x , long * y ) const ; virtual void ShowPosition ( long pos ) ; virtual int GetLineLength ( long lineNo ) const ; virtual wxString GetLineText ( long lineNo ) const ; void SetTXNData ( const wxString & st , TXNOffset start , TXNOffset end ) ; TXNObject GetTXNObject ( ) { return m_txn ; } protected : void TXNSetAttribute ( const wxTextAttr & style , long from , long to ) ; TXNObject m_txn ; } ; class wxMacMLTEHIViewControl : public wxMacMLTEControl { public : wxMacMLTEHIViewControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) ; virtual ~ wxMacMLTEHIViewControl ( ) ; virtual bool SetFocus ( ) ; virtual bool HasFocus ( ) const ; virtual void SetBackgroundColour ( const wxColour & col ) ; protected : HIViewRef m_scrollView ; HIViewRef m_textView ; } ; class wxMacMLTEClassicControl : public wxMacMLTEControl { public : wxMacMLTEClassicControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) ; virtual ~ wxMacMLTEClassicControl ( ) ; virtual void VisibilityChanged ( bool shown ) ; virtual void SuperChangedPosition ( ) ; virtual void MacControlUserPaneDrawProc ( wxInt16 part ) ; virtual wxInt16 MacControlUserPaneHitTestProc ( wxInt16 x , wxInt16 y ) ; virtual wxInt16 MacControlUserPaneTrackingProc ( wxInt16 x , wxInt16 y , void * actionProc ) ; virtual void MacControlUserPaneIdleProc ( ) ; virtual wxInt16 MacControlUserPaneKeyDownProc ( wxInt16 keyCode , wxInt16 charCode , wxInt16 modifiers ) ; virtual void MacControlUserPaneActivateProc ( bool activating ) ; virtual wxInt16 MacControlUserPaneFocusProc ( wxInt16 action ) ; virtual void MacControlUserPaneBackgroundProc ( void * info ) ; virtual bool SetupCursor ( const wxPoint & WXUNUSED ( pt ) ) { MacControlUserPaneIdleProc ( ) ; return true ; } virtual void Move ( int x , int y , int width , int height ) ; protected : OSStatus DoCreate ( ) ; void MacUpdatePosition ( ) ; void MacActivatePaneText ( bool setActive ) ; void MacFocusPaneText ( bool setFocus ) ; void MacSetObjectVisibility ( bool vis ) ; private : TXNFrameID m_txnFrameID ; GrafPtr m_txnPort ; WindowRef m_txnWindow ; Rect m_txnControlBounds ; Rect m_txnVisBounds ; static pascal void TXNScrollActionProc ( ControlRef controlRef , ControlPartCode partCode ) ; static pascal void TXNScrollInfoProc ( SInt32 iValue , SInt32 iMaximumValue , TXNScrollBarOrientation iScrollBarOrientation , SInt32 iRefCon ) ; ControlRef m_sbHorizontal ; SInt32 m_lastHorizontalValue ; ControlRef m_sbVertical ; SInt32 m_lastVerticalValue ; } ; wxWidgetImplType * wxWidgetImpl :: CreateTextControl ( wxTextCtrl * wxpeer , wxWindowMac * WXUNUSED ( parent ) , wxWindowID WXUNUSED ( id ) , const wxString & str , const wxPoint & pos , const wxSize & size , long style , long WXUNUSED ( extraStyle ) ) { return new wxMacMLTEHIViewControl ( wxpeer , str , pos , size , style ) ; } static const EventTypeSpec unicodeTextControlEventList [ ] = { { kEventClassControl , kEventControlSetFocusPart } , } ; static pascal OSStatus wxMacUnicodeTextControlControlEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; wxMacUnicodeTextControl * focus = ( wxMacUnicodeTextControl * ) data ; wxMacCarbonEvent cEvent ( event ) ; switch ( GetEventKind ( event ) ) { case kEventControlSetFocusPart : { ControlPartCode controlPart = cEvent . GetParameter < ControlPartCode > ( kEventParamControlPart , typeControlPartCode ) ; if ( controlPart == kControlFocusNoPart ) { focus -> GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & focus -> m_selection ) ; } result = CallNextEventHandler ( handler , event ) ; if ( controlPart != kControlFocusNoPart ) { focus -> SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & focus -> m_selection ) ; } break ; } default : break ; } return result ; } static pascal OSStatus wxMacUnicodeTextControlEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; switch ( GetEventClass ( event ) ) { case kEventClassControl : result = wxMacUnicodeTextControlControlEventHandler ( handler , event , data ) ; break ; default : break ; } return result ; } DEFINE_ONE_SHOT_HANDLER_GETTER ( wxMacUnicodeTextControlEventHandler ) wxMacUnicodeTextControl :: wxMacUnicodeTextControl ( wxTextCtrl * wxPeer ) : wxMacControl ( wxPeer ) , wxTextWidgetImpl ( wxPeer ) { } wxMacUnicodeTextControl :: wxMacUnicodeTextControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) : wxMacControl ( wxPeer ) , wxTextWidgetImpl ( wxPeer ) { m_font = wxPeer -> GetFont ( ) ; m_windowStyle = style ; m_selection . selStart = m_selection . selEnd = 0 ; Rect bounds = wxMacGetBoundsForControl ( wxPeer , pos , size ) ; wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; m_valueTag = kControlEditTextCFStringTag ; Boolean isPassword = ( m_windowStyle & wxTE_PASSWORD ) != 0 ; if ( isPassword ) { m_valueTag = kControlEditTextPasswordCFStringTag ; } OSStatus err = CreateEditUnicodeTextControl ( MAC_WXHWND ( wxPeer -> MacGetTopLevelWindowRef ( ) ) , & bounds , cf , isPassword , NULL , & m_controlRef ) ; verify_noerr ( err ) ; if ( ! ( m_windowStyle & wxTE_MULTILINE ) ) SetData < Boolean > ( kControlEditTextPart , kControlEditTextSingleLineTag , true ) ; InstallEventHandlers ( ) ; } void wxMacUnicodeTextControl :: InstallEventHandlers ( ) { :: InstallControlEventHandler ( m_controlRef , GetwxMacUnicodeTextControlEventHandlerUPP ( ) , GetEventTypeCount ( unicodeTextControlEventList ) , unicodeTextControlEventList , this , ( EventHandlerRef * ) & m_macTextCtrlEventHandler ) ; } wxMacUnicodeTextControl :: ~ wxMacUnicodeTextControl ( ) { :: RemoveEventHandler ( ( EventHandlerRef ) m_macTextCtrlEventHandler ) ; } void wxMacUnicodeTextControl :: VisibilityChanged ( bool shown ) { if ( ! ( m_windowStyle & wxTE_MULTILINE ) && shown ) { ControlEditTextSelectionRec sel ; CFStringRef value = NULL ; verify_noerr ( GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; verify_noerr ( GetData < CFStringRef > ( 0 , m_valueTag , & value ) ) ; verify_noerr ( SetData < CFStringRef > ( 0 , m_valueTag , & value ) ) ; verify_noerr ( SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; CFRelease ( value ) ; } } wxString wxMacUnicodeTextControl :: GetStringValue ( ) const { wxString result ; CFStringRef value = GetData < CFStringRef > ( 0 , m_valueTag ) ; if ( value ) { wxCFStringRef cf ( value ) ; result = cf . AsString ( ) ; } # if ' \n ' == 10 wxMacConvertNewlines13To10 ( & result ) ; # else wxMacConvertNewlines10To13 ( & result ) ; # endif return result ; } void wxMacUnicodeTextControl :: SetStringValue ( const wxString & str ) { wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; verify_noerr ( SetData < CFStringRef > ( 0 , m_valueTag , cf ) ) ; } void wxMacUnicodeTextControl :: Copy ( ) { SendHICommand ( kHICommandCopy ) ; } void wxMacUnicodeTextControl :: Cut ( ) { SendHICommand ( kHICommandCut ) ; } void wxMacUnicodeTextControl :: Paste ( ) { SendHICommand ( kHICommandPaste ) ; } bool wxMacUnicodeTextControl :: CanPaste ( ) const { return true ; } void wxMacUnicodeTextControl :: SetEditable ( bool WXUNUSED ( editable ) ) { # if 0 SetData < Boolean > ( kControlEditTextPart , kControlEditTextLockedTag , ( Boolean ) ! editable ) ; # endif } void wxMacUnicodeTextControl :: GetSelection ( long * from , long * to ) const { ControlEditTextSelectionRec sel ; if ( HasFocus ( ) ) verify_noerr ( GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; else sel = m_selection ; if ( from ) * from = sel . selStart ; if ( to ) * to = sel . selEnd ; } void wxMacUnicodeTextControl :: SetSelection ( long from , long to ) { ControlEditTextSelectionRec sel ; wxString result ; int textLength = 0 ; CFStringRef value = GetData < CFStringRef > ( 0 , m_valueTag ) ; if ( value ) { wxCFStringRef cf ( value ) ; textLength = cf . AsString ( ) . length ( ) ; } if ( ( from == - 1 ) && ( to == - 1 ) ) { from = 0 ; to = textLength ; } else { from = wxMin ( textLength , wxMax ( from , 0 ) ) ; if ( to == - 1 ) to = textLength ; else to = wxMax ( 0 , wxMin ( textLength , to ) ) ; } sel . selStart = from ; sel . selEnd = to ; if ( HasFocus ( ) ) SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ; else m_selection = sel ; } void wxMacUnicodeTextControl :: WriteText ( const wxString & str ) { if ( ! wxIsMainThread ( ) ) { # if wxOSX_USE_CARBON wxMacMPRemoteGUICall < wxTextCtrl , wxString > ( ( wxTextCtrl * ) GetWXPeer ( ) , & wxTextCtrl :: WriteText , str ) ; # endif return ; } wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; if ( HasFocus ( ) ) { wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; CFStringRef value = cf ; SetData < CFStringRef > ( 0 , kControlEditTextInsertCFStringRefTag , & value ) ; } else { wxString val = GetStringValue ( ) ; long start , end ; GetSelection ( & start , & end ) ; val . Remove ( start , end - start ) ; val . insert ( start , str ) ; SetStringValue ( val ) ; SetSelection ( start + str . length ( ) , start + str . length ( ) ) ; } } class wxMacEditHelper { public : wxMacEditHelper ( TXNObject txn ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; m_txn = txn ; TXNGetTXNObjectControls ( m_txn , 1 , tag , m_data ) ; if ( m_data [ 0 ] . uValue == kTXNReadOnly ) { TXNControlData data [ ] = { { kTXNReadWrite } } ; TXNSetTXNObjectControls ( m_txn , false , 1 , tag , data ) ; } } ~ wxMacEditHelper ( ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; if ( m_data [ 0 ] . uValue == kTXNReadOnly ) TXNSetTXNObjectControls ( m_txn , false , 1 , tag , m_data ) ; } protected : TXNObject m_txn ; TXNControlData m_data [ 1 ] ; } ; wxMacMLTEControl :: wxMacMLTEControl ( wxTextCtrl * peer ) : wxMacControl ( peer ) , wxTextWidgetImpl ( peer ) { SetNeedsFocusRect ( true ) ; } wxString wxMacMLTEControl :: GetStringValue ( ) const { wxString result ; OSStatus err ; Size actualSize = 0 ; { # if wxUSE_UNICODE Handle theText ; err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNUnicodeTextData ) ; if ( err != noErr ) { actualSize = 0 ; } else { actualSize = GetHandleSize ( theText ) / sizeof ( UniChar ) ; if ( actualSize > 0 ) { wxChar * ptr = NULL ; SetHandleSize ( theText , ( actualSize + 1 ) * sizeof ( UniChar ) ) ; HLock ( theText ) ; ( ( ( UniChar * ) * theText ) [ actualSize ] ) = 0 ; wxMBConvUTF16 converter ; size_t noChars = converter . MB2WC ( NULL , ( const char * ) * theText , 0 ) ; wxASSERT_MSG ( noChars != wxCONV_FAILED , wxT ( " Unable ▁ to ▁ count ▁ the ▁ number ▁ of ▁ characters ▁ in ▁ this ▁ string ! " ) ) ; ptr = new wxChar [ noChars + 1 ] ; noChars = converter . MB2WC ( ptr , ( const char * ) * theText , noChars + 1 ) ; wxASSERT_MSG ( noChars != wxCONV_FAILED , wxT ( " Conversion ▁ of ▁ string ▁ failed ! " ) ) ; ptr [ noChars ] = 0 ; HUnlock ( theText ) ; ptr [ actualSize ] = 0 ; result = wxString ( ptr ) ; delete [ ] ptr ; } DisposeHandle ( theText ) ; } # else Handle theText ; err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNTextData ) ; if ( err != noErr ) { actualSize = 0 ; } else { actualSize = GetHandleSize ( theText ) ; if ( actualSize > 0 ) { HLock ( theText ) ; result = wxString ( * theText , wxConvLocal , actualSize ) ; HUnlock ( theText ) ; } DisposeHandle ( theText ) ; } # endif } # if ' \n ' == 10 wxMacConvertNewlines13To10 ( & result ) ; # else wxMacConvertNewlines10To13 ( & result ) ; # endif return result ; } void wxMacMLTEControl :: SetStringValue ( const wxString & str ) { wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif { wxMacEditHelper help ( m_txn ) ; SetTXNData ( st , kTXNStartOffset , kTXNEndOffset ) ; } TXNSetSelection ( m_txn , 0 , 0 ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; } } TXNFrameOptions wxMacMLTEControl :: FrameOptionsFromWXStyle ( long wxStyle ) { TXNFrameOptions frameOptions = kTXNDontDrawCaretWhenInactiveMask ; frameOptions |= kTXNDoFontSubstitutionMask ; if ( ! ( wxStyle & wxTE_NOHIDESEL ) ) frameOptions |= kTXNDontDrawSelectionWhenInactiveMask ; if ( wxStyle & ( wxHSCROLL | wxTE_DONTWRAP ) ) frameOptions |= kTXNWantHScrollBarMask ; if ( wxStyle & wxTE_MULTILINE ) { if ( ! ( wxStyle & wxTE_DONTWRAP ) ) frameOptions |= kTXNAlwaysWrapAtViewEdgeMask ; if ( ! ( wxStyle & wxTE_NO_VSCROLL ) ) { frameOptions |= kTXNWantVScrollBarMask ; } } else { frameOptions |= kTXNSingleLineOnlyMask ; } return frameOptions ; } void wxMacMLTEControl :: AdjustCreationAttributes ( const wxColour & background , bool WXUNUSED ( visible ) ) { TXNControlTag iControlTags [ ] = { kTXNDoFontSubstitution , kTXNWordWrapStateTag , } ; TXNControlData iControlData [ ] = { { true } , { kTXNNoAutoWrap } , } ; int toptag = WXSIZEOF ( iControlTags ) ; if ( m_windowStyle & wxTE_MULTILINE ) { iControlData [ 1 ] . uValue = ( m_windowStyle & wxTE_DONTWRAP ) ? kTXNNoAutoWrap : kTXNAutoWrap ; } OSStatus err = TXNSetTXNObjectControls ( m_txn , false , toptag , iControlTags , iControlData ) ; verify_noerr ( err ) ; Str255 fontName ; SInt16 fontSize ; Style fontStyle ; GetThemeFont ( kThemeSystemFont , GetApplicationScript ( ) , fontName , & fontSize , & fontStyle ) ; TXNTypeAttributes typeAttr [ ] = { { kTXNQDFontNameAttribute , kTXNQDFontNameAttributeSize , { ( void * ) fontName } } , { kTXNQDFontSizeAttribute , kTXNFontSizeAttributeSize , { ( void * ) ( fontSize << 16 ) } } , { kTXNQDFontStyleAttribute , kTXNQDFontStyleAttributeSize , { ( void * ) normal } } , } ; err = TXNSetTypeAttributes ( m_txn , WXSIZEOF ( typeAttr ) , typeAttr , kTXNStartOffset , kTXNEndOffset ) ; verify_noerr ( err ) ; if ( m_windowStyle & wxTE_PASSWORD ) { UniChar c = 0x00A5 ; err = TXNEchoMode ( m_txn , c , 0 , true ) ; verify_noerr ( err ) ; } TXNBackground tback ; tback . bgType = kTXNBackgroundTypeRGB ; background . GetRGBColor ( & tback . bg . color ) ; TXNSetBackground ( m_txn , & tback ) ; TXNCommandEventSupportOptions options ; if ( TXNGetCommandEventSupport ( m_txn , & options ) == noErr ) { options |= kTXNSupportEditCommandProcessing | kTXNSupportEditCommandUpdating | kTXNSupportFontCommandProcessing | kTXNSupportFontCommandUpdating ; bool checkSpelling = false ; if ( ! ( m_windowStyle & wxTE_READONLY ) ) { # if wxUSE_SYSTEM_OPTIONS if ( wxSystemOptions :: HasOption ( wxMAC_TEXTCONTROL_USE_SPELL_CHECKER ) && ( wxSystemOptions :: GetOptionInt ( wxMAC_TEXTCONTROL_USE_SPELL_CHECKER ) == 1 ) ) { checkSpelling = true ; } # endif } if ( checkSpelling ) options |= kTXNSupportSpellCheckCommandProcessing | kTXNSupportSpellCheckCommandUpdating ; TXNSetCommandEventSupport ( m_txn , options ) ; } } void wxMacMLTEControl :: SetBackgroundColour ( const wxColour & col ) { TXNBackground tback ; tback . bgType = kTXNBackgroundTypeRGB ; col . GetRGBColor ( & tback . bg . color ) ; TXNSetBackground ( m_txn , & tback ) ; } static inline int wxConvertToTXN ( int x ) { return static_cast < int > ( x / 254.0 * 72 + 0.5 ) ; } void wxMacMLTEControl :: TXNSetAttribute ( const wxTextAttr & style , long from , long to ) { TXNTypeAttributes typeAttr [ 4 ] ; RGBColor color ; size_t typeAttrCount = 0 ; TXNMargins margins ; TXNControlTag controlTags [ 4 ] ; TXNControlData controlData [ 4 ] ; size_t controlAttrCount = 0 ; TXNTab * tabs = NULL ; bool relayout = false ; wxFont font ; if ( style . HasFont ( ) ) { wxASSERT ( typeAttrCount < WXSIZEOF ( typeAttr ) ) ; font = style . GetFont ( ) ; typeAttr [ typeAttrCount ] . tag = kTXNATSUIStyle ; typeAttr [ typeAttrCount ] . size = kTXNATSUIStyleSize ; typeAttr [ typeAttrCount ] . data . dataPtr = font . MacGetATSUStyle ( ) ; typeAttrCount ++ ; } if ( style . HasTextColour ( ) ) { wxASSERT ( typeAttrCount < WXSIZEOF ( typeAttr ) ) ; style . GetTextColour ( ) . GetRGBColor ( & color ) ; typeAttr [ typeAttrCount ] . tag = kTXNQDFontColorAttribute ; typeAttr [ typeAttrCount ] . size = kTXNQDFontColorAttributeSize ; typeAttr [ typeAttrCount ] . data . dataPtr = ( void * ) & color ; typeAttrCount ++ ; } if ( style . HasAlignment ( ) ) { wxASSERT ( controlAttrCount < WXSIZEOF ( controlTags ) ) ; SInt32 align ; switch ( style . GetAlignment ( ) ) { case wxTEXT_ALIGNMENT_LEFT : align = kTXNFlushLeft ; break ; case wxTEXT_ALIGNMENT_CENTRE : align = kTXNCenter ; break ; case wxTEXT_ALIGNMENT_RIGHT : align = kTXNFlushRight ; break ; case wxTEXT_ALIGNMENT_JUSTIFIED : align = kTXNFullJust ; break ; default : case wxTEXT_ALIGNMENT_DEFAULT : align = kTXNFlushDefault ; break ; } controlTags [ controlAttrCount ] = kTXNJustificationTag ; controlData [ controlAttrCount ] . sValue = align ; controlAttrCount ++ ; } if ( style . HasLeftIndent ( ) || style . HasRightIndent ( ) ) { wxASSERT ( controlAttrCount < WXSIZEOF ( controlTags ) ) ; controlTags [ controlAttrCount ] = kTXNMarginsTag ; controlData [ controlAttrCount ] . marginsPtr = & margins ; verify_noerr ( TXNGetTXNObjectControls ( m_txn , 1 , & controlTags [ controlAttrCount ] , & controlData [ controlAttrCount ] ) ) ; if ( style . HasLeftIndent ( ) ) { margins . leftMargin = wxConvertToTXN ( style . GetLeftIndent ( ) ) ; } if ( style . HasRightIndent ( ) ) { margins . rightMargin = wxConvertToTXN ( style . GetRightIndent ( ) ) ; } controlAttrCount ++ ; } if ( style . HasTabs ( ) ) { const wxArrayInt & tabarray = style . GetTabs ( ) ; controlTags [ controlAttrCount ] = kTXNTabSettingsTag ; if ( tabarray . size ( ) > 0 ) controlData [ controlAttrCount ] . tabValue . value = wxConvertToTXN ( tabarray [ 0 ] ) ; else controlData [ controlAttrCount ] . tabValue . value = 72 ; controlData [ controlAttrCount ] . tabValue . tabType = kTXNLeftTab ; controlAttrCount ++ ; } if ( controlAttrCount > 0 ) { verify_noerr ( TXNSetTXNObjectControls ( m_txn , false , controlAttrCount , controlTags , controlData ) ) ; relayout = true ; } if ( typeAttrCount > 0 ) { verify_noerr ( TXNSetTypeAttributes ( m_txn , typeAttrCount , typeAttr , from , to ) ) ; if ( from != to ) relayout = true ; } if ( tabs != NULL ) { delete [ ] tabs ; } if ( relayout ) { TXNRecalcTextLayout ( m_txn ) ; } } void wxMacMLTEControl :: SetFont ( const wxFont & font , const wxColour & foreground , long WXUNUSED ( windowStyle ) , bool WXUNUSED ( ignoreBlack ) ) { wxMacEditHelper help ( m_txn ) ; TXNSetAttribute ( wxTextAttr ( foreground , wxNullColour , font ) , kTXNStartOffset , kTXNEndOffset ) ; } void wxMacMLTEControl :: SetStyle ( long start , long end , const wxTextAttr & style ) { wxMacEditHelper help ( m_txn ) ; TXNSetAttribute ( style , start , end ) ; } void wxMacMLTEControl :: Copy ( ) { TXNCopy ( m_txn ) ; } void wxMacMLTEControl :: Cut ( ) { TXNCut ( m_txn ) ; } void wxMacMLTEControl :: Paste ( ) { TXNPaste ( m_txn ) ; } bool wxMacMLTEControl :: CanPaste ( ) const { return TXNIsScrapPastable ( ) ; } void wxMacMLTEControl :: SetEditable ( bool editable ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; TXNControlData data [ ] = { { editable ? kTXNReadWrite : kTXNReadOnly } } ; TXNSetTXNObjectControls ( m_txn , false , WXSIZEOF ( tag ) , tag , data ) ; } long wxMacMLTEControl :: GetLastPosition ( ) const { wxTextPos actualsize = 0 ; Handle theText ; # if wxUSE_UNICODE OSErr err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNUnicodeTextData ) ; if ( err == noErr ) { actualsize = GetHandleSize ( theText ) / sizeof ( UniChar ) ; DisposeHandle ( theText ) ; } # else OSErr err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNTextData ) ; if ( err == noErr ) { actualsize = GetHandleSize ( theText ) ; DisposeHandle ( theText ) ; } # endif else { actualsize = 0 ; } return actualsize ; } void wxMacMLTEControl :: Replace ( long from , long to , const wxString & str ) { wxString value = str ; wxMacConvertNewlines10To13 ( & value ) ; wxMacEditHelper help ( m_txn ) ; # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif TXNSetSelection ( m_txn , from , to == - 1 ? kTXNEndOffset : to ) ; TXNClear ( m_txn ) ; SetTXNData ( value , kTXNUseCurrentSelection , kTXNUseCurrentSelection ) ; } void wxMacMLTEControl :: Remove ( long from , long to ) { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif wxMacEditHelper help ( m_txn ) ; TXNSetSelection ( m_txn , from , to ) ; TXNClear ( m_txn ) ; } void wxMacMLTEControl :: GetSelection ( long * from , long * to ) const { TXNOffset f , t ; TXNGetSelection ( m_txn , & f , & t ) ; * from = f ; * to = t ; } void wxMacMLTEControl :: SetSelection ( long from , long to ) { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif if ( ( from == - 1 ) && ( to == - 1 ) ) TXNSelectAll ( m_txn ) ; else TXNSetSelection ( m_txn , from , to == - 1 ? kTXNEndOffset : to ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; } void wxMacMLTEControl :: WriteText ( const wxString & str ) { if ( ! wxIsMainThread ( ) ) { # if wxOSX_USE_CARBON wxMacMPRemoteGUICall < wxTextCtrl , wxString > ( ( wxTextCtrl * ) GetWXPeer ( ) , & wxTextCtrl :: WriteText , str ) ; # endif return ; } wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; long start , end , dummy ; GetSelection ( & start , & dummy ) ; # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif { wxMacEditHelper helper ( m_txn ) ; SetTXNData ( st , kTXNUseCurrentSelection , kTXNUseCurrentSelection ) ; } GetSelection ( & dummy , & end ) ; } void wxMacMLTEControl :: Clear ( ) { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif wxMacEditHelper st ( m_txn ) ; TXNSetSelection ( m_txn , kTXNStartOffset , kTXNEndOffset ) ; TXNClear ( m_txn ) ; } bool wxMacMLTEControl :: CanUndo ( ) const { return TXNCanUndo ( m_txn , NULL ) ; } void wxMacMLTEControl :: Undo ( ) { TXNUndo ( m_txn ) ; } bool wxMacMLTEControl :: CanRedo ( ) const { return TXNCanRedo ( m_txn , NULL ) ; } void wxMacMLTEControl :: Redo ( ) { TXNRedo ( m_txn ) ; } int wxMacMLTEControl :: GetNumberOfLines ( ) const { ItemCount lines = 0 ; TXNGetLineCount ( m_txn , & lines ) ; return lines ; } long wxMacMLTEControl :: XYToPosition ( long x , long y ) const { Point curpt ; wxTextPos lastpos ; long xpos = 0 , ypos = 0 ; int lastHeight = 0 ; ItemCount n ; lastpos = GetLastPosition ( ) ; for ( n = 0 ; n <= ( ItemCount ) lastpos ; ++ n ) { if ( y == ypos && x == xpos ) return n ; TXNOffsetToPoint ( m_txn , n , & curpt ) ; if ( curpt . v > lastHeight ) { xpos = 0 ; if ( n > 0 ) ++ ypos ; lastHeight = curpt . v ; } else ++ xpos ; } return 0 ; } bool wxMacMLTEControl :: PositionToXY ( long pos , long * x , long * y ) const { Point curpt ; wxTextPos lastpos ; if ( y ) * y = 0 ; if ( x ) * x = 0 ; lastpos = GetLastPosition ( ) ; if ( pos <= lastpos ) { long xpos = 0 , ypos = 0 ; int lastHeight = 0 ; ItemCount n ; for ( n = 0 ; n <= ( ItemCount ) pos ; ++ n ) { TXNOffsetToPoint ( m_txn , n , & curpt ) ; if ( curpt . v > lastHeight ) { xpos = 0 ; if ( n > 0 ) ++ ypos ; lastHeight = curpt . v ; } else ++ xpos ; } if ( y ) * y = ypos ; if ( x ) * x = xpos ; } return false ; } void wxMacMLTEControl :: ShowPosition ( long pos ) { Point current , desired ; TXNOffset selstart , selend ; TXNGetSelection ( m_txn , & selstart , & selend ) ; TXNOffsetToPoint ( m_txn , selstart , & current ) ; TXNOffsetToPoint ( m_txn , pos , & desired ) ; OSErr theErr = noErr ; long dv = desired . v - current . v ; long dh = desired . h - current . h ; TXNShowSelection ( m_txn , kTXNShowStart ) ; theErr = TXNScroll ( m_txn , kTXNScrollUnitsInPixels , kTXNScrollUnitsInPixels , & dv , & dh ) ; } void wxMacMLTEControl :: SetTXNData ( const wxString & st , TXNOffset start , TXNOffset end ) { # if wxUSE_UNICODE wxMBConvUTF16 converter ; ByteCount byteBufferLen = converter . WC2MB ( NULL , st . wc_str ( ) , 0 ) ; wxASSERT_MSG ( byteBufferLen != wxCONV_FAILED , wxT ( " Conversion ▁ to ▁ UTF - 16 ▁ unexpectedly ▁ failed " ) ) ; UniChar * unibuf = ( UniChar * ) malloc ( byteBufferLen + 2 ) ; converter . WC2MB ( ( char * ) unibuf , st . wc_str ( ) , byteBufferLen + 2 ) ; TXNSetData ( m_txn , kTXNUnicodeTextData , ( void * ) unibuf , byteBufferLen , start , end ) ; free ( unibuf ) ; # else wxCharBuffer text = st . mb_str ( wxConvLocal ) ; TXNSetData ( m_txn , kTXNTextData , ( void * ) text . data ( ) , strlen ( text ) , start , end ) ; # endif } wxString wxMacMLTEControl :: GetLineText ( long lineNo ) const { wxString line ; if ( lineNo < GetNumberOfLines ( ) ) { Point firstPoint ; Fixed lineWidth , lineHeight , currentHeight ; long ypos ; TXNOffsetToPoint ( m_txn , 0 , & firstPoint ) ; ypos = 0 ; currentHeight = 0 ; while ( ypos < lineNo ) { TXNGetLineMetrics ( m_txn , ypos ++ , & lineWidth , & lineHeight ) ; currentHeight += lineHeight ; } Point thePoint = { firstPoint . v + ( currentHeight >> 16 ) , firstPoint . h + ( 0 ) } ; TXNOffset theOffset ; TXNPointToOffset ( m_txn , thePoint , & theOffset ) ; wxString content = GetStringValue ( ) ; Point currentPoint = thePoint ; while ( thePoint . v == currentPoint . v && theOffset < content . length ( ) ) { line += content [ theOffset ] ; TXNOffsetToPoint ( m_txn , ++ theOffset , & currentPoint ) ; } } return line ; } int wxMacMLTEControl :: GetLineLength ( long lineNo ) const { int theLength = 0 ; if ( lineNo < GetNumberOfLines ( ) ) { Point firstPoint ; Fixed lineWidth , lineHeight , currentHeight ; long ypos ; TXNOffsetToPoint ( m_txn , 0 , & firstPoint ) ; ypos = 0 ; currentHeight = 0 ; while ( ypos < lineNo ) { TXNGetLineMetrics ( m_txn , ypos ++ , & lineWidth , & lineHeight ) ; currentHeight += lineHeight ; } Point thePoint = { firstPoint . v + ( currentHeight >> 16 ) , firstPoint . h + ( 0 ) } ; TXNOffset theOffset ; TXNPointToOffset ( m_txn , thePoint , & theOffset ) ; wxString content = GetStringValue ( ) ; Point currentPoint = thePoint ; while ( thePoint . v == currentPoint . v && theOffset < content . length ( ) ) { ++ theLength ; TXNOffsetToPoint ( m_txn , ++ theOffset , & currentPoint ) ; } } return theLength ; } static const EventTypeSpec eventList [ ] = { { kEventClassTextInput , kEventTextInputUnicodeForKeyEvent } , } ; static pascal OSStatus wxMacUnicodeTextEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; wxMacMLTEHIViewControl * focus = ( wxMacMLTEHIViewControl * ) data ; switch ( GetEventKind ( event ) ) { case kEventTextInputUnicodeForKeyEvent : { TXNOffset from , to ; TXNGetSelection ( focus -> GetTXNObject ( ) , & from , & to ) ; if ( from == to ) TXNShowSelection ( focus -> GetTXNObject ( ) , kTXNShowStart ) ; result = CallNextEventHandler ( handler , event ) ; break ; } default : break ; } return result ; } static pascal OSStatus wxMacTextControlEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; switch ( GetEventClass ( event ) ) { case kEventClassTextInput : result = wxMacUnicodeTextEventHandler ( handler , event , data ) ; break ; default : break ; } return result ; } DEFINE_ONE_SHOT_HANDLER_GETTER ( wxMacTextControlEventHandler ) wxMacMLTEHIViewControl :: wxMacMLTEHIViewControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) : wxMacMLTEControl ( wxPeer ) { m_font = wxPeer -> GetFont ( ) ; m_windowStyle = style ; Rect bounds = wxMacGetBoundsForControl ( wxPeer , pos , size ) ; wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; HIRect hr = { { bounds . left , bounds . top } , { bounds . right - bounds . left , bounds . bottom - bounds . top } } ; m_scrollView = NULL ; TXNFrameOptions frameOptions = FrameOptionsFromWXStyle ( style ) ; if ( ( frameOptions & ( kTXNWantVScrollBarMask | kTXNWantHScrollBarMask ) ) || ( frameOptions & kTXNSingleLineOnlyMask ) ) { if ( frameOptions & ( kTXNWantVScrollBarMask | kTXNWantHScrollBarMask ) ) { HIScrollViewCreate ( ( frameOptions & kTXNWantHScrollBarMask ? kHIScrollViewOptionsHorizScroll : 0 ) | ( frameOptions & kTXNWantVScrollBarMask ? kHIScrollViewOptionsVertScroll : 0 ) , & m_scrollView ) ; } else { HIScrollViewCreate ( kHIScrollViewOptionsVertScroll , & m_scrollView ) ; HIScrollViewSetScrollBarAutoHide ( m_scrollView , true ) ; } HIViewSetFrame ( m_scrollView , & hr ) ; HIViewSetVisible ( m_scrollView , true ) ; } m_textView = NULL ; HITextViewCreate ( NULL , 0 , frameOptions , & m_textView ) ; m_txn = HITextViewGetTXNObject ( m_textView ) ; HIViewSetVisible ( m_textView , true ) ; if ( m_scrollView ) { HIViewAddSubview ( m_scrollView , m_textView ) ; m_controlRef = m_scrollView ; InstallEventHandler ( ( WXWidget ) m_textView ) ; } else { HIViewSetFrame ( m_textView , & hr ) ; m_controlRef = m_textView ; } AdjustCreationAttributes ( * wxWHITE , true ) ; # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif SetTXNData ( st , kTXNStartOffset , kTXNEndOffset ) ; TXNSetSelection ( m_txn , 0 , 0 ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; :: InstallControlEventHandler ( m_textView , GetwxMacTextControlEventHandlerUPP ( ) , GetEventTypeCount ( eventList ) , eventList , this , NULL ) ; } wxMacMLTEHIViewControl :: ~ wxMacMLTEHIViewControl ( ) { } bool wxMacMLTEHIViewControl :: SetFocus ( ) { return SetKeyboardFocus ( GetControlOwner ( m_textView ) , m_textView , kControlFocusNextPart ) == noErr ; } bool wxMacMLTEHIViewControl :: HasFocus ( ) const { ControlRef control ; if ( GetUserFocusWindow ( ) == NULL ) return false ; GetKeyboardFocus ( GetUserFocusWindow ( ) , & control ) ; return control == m_textView ; } void wxMacMLTEHIViewControl :: SetBackgroundColour ( const wxColour & col ) { HITextViewSetBackgroundColor ( m_textView , col . GetPixel ( ) ) ; } # endif </DOCUMENT>
<DOCUMENT_ID="attackjz/Cocos2d-x_CustomSliderList/tree/master/CustomSliderList/cocos2d/cocos/platform/winrt/CCFreeTypeFont.cpp"> # include " CCFreeTypeFont . h " # include " base / CCDirector . h " # include " platform / CCFileUtils . h " # if ( CC_TARGET_PLATFORM != CC_PLATFORM_WP8 ) # include < dwrite . h > # endif # include < map > # include < string > # include < sstream > # include < vector > # include < memory > # include < algorithm > using namespace std ; NS_CC_BEGIN static map < std :: string , FontBufferInfo > s_fontsNames ; static FT_Library s_FreeTypeLibrary = nullptr ; CCFreeTypeFont :: CCFreeTypeFont ( ) : m_space ( " ▁ " ) , m_face ( nullptr ) { } CCFreeTypeFont :: ~ CCFreeTypeFont ( ) { reset ( ) ; } void CCFreeTypeFont :: reset ( ) { for ( auto line : m_lines ) { line -> glyphs . clear ( ) ; delete line ; } m_lines . clear ( ) ; if ( m_face ) { FT_Done_Face ( m_face ) ; m_face = nullptr ; } } unsigned char * CCFreeTypeFont :: initWithString ( const char * text , const FontDefinition & textDefinition , Device :: TextAlign align , int & width , int & height , ssize_t & dataLength ) { FT_Error error = 0 ; ssize_t size = 0 ; unsigned char * pBuffer = nullptr ; unsigned char * data = nullptr ; Size winSize = Director :: getInstance ( ) -> getWinSizeInPixels ( ) ; m_windowWidth = ( int ) winSize . width ; m_inWidth = textDefinition . _dimensions . width ; m_inHeight = textDefinition . _dimensions . height ; m_fontFillColorR = textDefinition . _fontFillColor . r ; m_fontFillColorG = textDefinition . _fontFillColor . g ; m_fontFillColorB = textDefinition . _fontFillColor . b ; # if 0 auto ittFontNames = s_fontsNames . find ( textDefinition . _fontName ) ; if ( ittFontNames != s_fontsNames . end ( ) ) { pBuffer = ittFontNames -> second . pBuffer ; size = ittFontNames -> second . size ; } # endif if ( ! pBuffer ) { pBuffer = loadFont ( textDefinition . _fontName . c_str ( ) , & size ) ; if ( ! pBuffer ) { pBuffer = loadSystemFont ( textDefinition . _fontName . c_str ( ) , & size ) ; } if ( ! pBuffer ) { pBuffer = loadFont ( " Arial " , & size ) ; } if ( ! pBuffer ) { pBuffer = loadSystemFont ( " Arial " , & size ) ; } if ( ! pBuffer ) { return false ; } # if 0 FontBufferInfo info ; info . pBuffer = pBuffer ; info . size = size ; s_fontsNames [ textDefinition . _fontName ] = info ; # endif } m_fontName = textDefinition . _fontName ; m_text = text ; if ( ! s_FreeTypeLibrary ) { error = FT_Init_FreeType ( & s_FreeTypeLibrary ) ; } if ( ! error && ! m_face ) { error = FT_New_Memory_Face ( s_FreeTypeLibrary , pBuffer , size , 0 , & m_face ) ; } if ( ! error ) { error = FT_Select_Charmap ( m_face , FT_ENCODING_UNICODE ) ; } if ( ! error ) { error = FT_Set_Char_Size ( m_face , textDefinition . _fontSize << 6 , textDefinition . _fontSize << 6 , 72 , 72 ) ; } if ( ! error ) { error = initGlyphs ( text ) ; } if ( ! error ) { data = getBitmap ( align , width , height , dataLength ) ; } delete [ ] pBuffer ; reset ( ) ; return data ; } unsigned char * CCFreeTypeFont :: getBitmap ( Device :: TextAlign eAlignMask , int & width , int & height , ssize_t & dataLength ) { int lineNumber = 0 ; int totalLines = m_lines . size ( ) ; m_width = m_inWidth ? m_inWidth : m_textWidth ; m_height = m_inHeight ? m_inHeight : m_textHeight ; unsigned int size = m_width * m_height * 4 ; unsigned char * pBuffer = new unsigned char [ size ] ; dataLength = size ; if ( ! pBuffer ) { dataLength = 0 ; return nullptr ; } memset ( pBuffer , 0 , size ) ; for ( auto line = m_lines . begin ( ) ; line != m_lines . end ( ) ; ++ line ) { FT_Vector pen = getPenForAlignment ( * line , eAlignMask , lineNumber , totalLines ) ; drawText ( * line , pBuffer , & pen ) ; lineNumber ++ ; } width = m_width ; height = m_height ; return pBuffer ; } FT_Vector CCFreeTypeFont :: getPenForAlignment ( FTLineInfo * pInfo , Device :: TextAlign eAlignMask , int lineNumber , int totalLines ) { FT_Error error = 0 ; FT_Vector pen ; int top ; int stringWidth = pInfo -> bbox . xMax - pInfo -> bbox . xMin ; int maxLineNumber = totalLines - 1 ; pen . x = 0 ; pen . y = 0 ; switch ( eAlignMask ) { case Device :: TextAlign :: TOP : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: TOP_LEFT : pen . x -= pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: TOP_RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM_RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM_LEFT : pen . x -= pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: CENTER : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; case Device :: TextAlign :: RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; case Device :: TextAlign :: LEFT : default : pen . x -= pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; } return pen ; } void CCFreeTypeFont :: drawText ( FTLineInfo * pInfo , unsigned char * pBuffer , FT_Vector * pen ) { auto glyphs = pInfo -> glyphs ; for ( auto glyph = glyphs . begin ( ) ; glyph != glyphs . end ( ) ; ++ glyph ) { FT_Glyph image = glyph -> image ; FT_Error error = FT_Glyph_To_Bitmap ( & image , FT_RENDER_MODE_NORMAL , 0 , 1 ) ; if ( ! error ) { FT_BitmapGlyph bit = ( FT_BitmapGlyph ) image ; draw_bitmap ( pBuffer , & bit -> bitmap , pen -> x + glyph -> pos . x + bit -> left , pen -> y - bit -> top ) ; FT_Done_Glyph ( image ) ; } } } void CCFreeTypeFont :: draw_bitmap ( unsigned char * pBuffer , FT_Bitmap * bitmap , FT_Int x , FT_Int y ) { FT_Int i , j , p , q ; FT_Int x_max = x + bitmap -> width ; FT_Int y_max = y + bitmap -> rows ; for ( i = x , p = 0 ; i < x_max ; i ++ , p ++ ) { for ( j = y , q = 0 ; j < y_max ; j ++ , q ++ ) { if ( i < 0 || j < 0 || i >= m_width || j >= m_height ) continue ; unsigned char value = bitmap -> buffer [ q * bitmap -> width + p ] ; if ( value > 0 ) { FT_Int index = ( j * m_width * 4 ) + ( i * 4 ) ; pBuffer [ index ++ ] = m_fontFillColorR ; pBuffer [ index ++ ] = m_fontFillColorG ; pBuffer [ index ++ ] = m_fontFillColorB ; pBuffer [ index ++ ] = value ; } } } } void CCFreeTypeFont :: endLine ( ) { if ( m_currentLine ) { m_lines . push_back ( m_currentLine ) ; m_textWidth = std :: max ( ( long ) m_textWidth , m_currentLine -> bbox . xMax - m_currentLine -> bbox . xMin ) ; m_textHeight += m_lineHeight ; } } void CCFreeTypeFont :: newLine ( ) { m_currentLine = new FTLineInfo ( ) ; m_currentLine -> width = 0 ; m_currentLine -> pen . x = 0 ; m_currentLine -> pen . y = 0 ; } FT_Error CCFreeTypeFont :: addWord ( const std :: string & word ) { std :: vector < TGlyph > glyphs ; FT_BBox bbox ; int maxWidth = m_inWidth ? m_inWidth : m_windowWidth ; std :: string newWord ; if ( m_currentLine -> width > 0 ) { newWord = ' ▁ ' + word ; } else { newWord = word ; } FT_Error error = initWordGlyphs ( glyphs , newWord , m_currentLine -> pen ) ; if ( ! error ) { compute_bbox ( glyphs , & bbox ) ; if ( m_currentLine -> width == 0 || bbox . xMax <= maxWidth ) { m_currentLine -> glyphs . insert ( m_currentLine -> glyphs . end ( ) , glyphs . begin ( ) , glyphs . end ( ) ) ; if ( m_currentLine -> width == 0 ) { m_currentLine -> bbox = bbox ; } else { m_currentLine -> bbox . xMax = bbox . xMax ; } m_currentLine -> width = m_currentLine -> bbox . xMax - m_currentLine -> bbox . xMin ; } else { endLine ( ) ; newLine ( ) ; addWord ( word ) ; } } return error ; } FT_Error CCFreeTypeFont :: initGlyphs ( const char * text ) { FT_Error error = 0 ; std :: stringstream stringStream ( text ) ; std :: string line ; vector < std :: string > lines ; vector < std :: string > words ; m_textWidth = 0 ; m_textHeight = 0 ; m_lineHeight = ( ( m_face -> size -> metrics . ascender ) >> 6 ) - ( ( m_face -> size -> metrics . descender ) >> 6 ) ; m_lines . clear ( ) ; while ( std :: getline ( stringStream , line ) && ! error ) { newLine ( ) ; std :: size_t prev = 0 , pos ; while ( ( pos = line . find_first_of ( " ▁ " , prev ) ) != std :: string :: npos ) { if ( pos > prev ) { addWord ( line . substr ( prev , pos - prev ) ) ; } prev = pos + 1 ; } if ( prev < line . length ( ) ) { addWord ( line . substr ( prev , std :: string :: npos ) ) ; } endLine ( ) ; } return error ; } void CCFreeTypeFont :: initWords ( const char * text ) { std :: stringstream stringStream ( text ) ; std :: string line ; vector < std :: string > lines ; vector < std :: string > words ; while ( std :: getline ( stringStream , line ) ) { lines . push_back ( line ) ; } for ( auto it = lines . begin ( ) ; it != lines . end ( ) ; ++ it ) { std :: size_t prev = 0 , pos ; while ( ( pos = it -> find_first_of ( " ▁ ' ; " , prev ) ) != std :: string :: npos ) { if ( pos > prev ) words . push_back ( it -> substr ( prev , pos - prev ) ) ; prev = pos + 1 ; } if ( prev < it -> length ( ) ) words . push_back ( it -> substr ( prev , std :: string :: npos ) ) ; } for ( auto it = words . begin ( ) ; it != words . end ( ) ; ++ it ) { std :: string foo ( * it ) ; } } FT_Error CCFreeTypeFont :: initWordGlyphs ( std :: vector < TGlyph > & glyphs , const std :: string & text , FT_Vector & pen ) { FT_GlyphSlot slot = m_face -> glyph ; FT_UInt glyph_index ; FT_UInt previous = 0 ; FT_Error error = 0 ; PGlyph glyph ; unsigned int numGlyphs = 0 ; wchar_t * pwszBuffer = nullptr ; int num_chars = text . size ( ) ; int nBufLen = num_chars + 1 ; pwszBuffer = new wchar_t [ nBufLen ] ; if ( ! pwszBuffer ) { return - 1 ; } memset ( pwszBuffer , 0 , nBufLen ) ; num_chars = MultiByteToWideChar ( CP_UTF8 , 0 , text . c_str ( ) , num_chars , pwszBuffer , nBufLen ) ; pwszBuffer [ num_chars ] = ' \0' ; glyphs . clear ( ) ; glyphs . resize ( num_chars ) ; FT_Bool useKerning = FT_HAS_KERNING ( m_face ) ; for ( int n = 0 ; n < num_chars ; n ++ ) { glyph = & glyphs [ numGlyphs ] ; FT_ULong c = pwszBuffer [ n ] ; glyph_index = FT_Get_Char_Index ( m_face , c ) ; if ( useKerning && previous && glyph_index ) { FT_Vector delta ; FT_Get_Kerning ( m_face , previous , glyph_index , FT_KERNING_DEFAULT , & delta ) ; pen . x += delta . x >> 6 ; } glyph -> pos = pen ; glyph -> index = glyph_index ; error = FT_Load_Glyph ( m_face , glyph_index , FT_LOAD_DEFAULT ) ; if ( error ) continue ; error = FT_Get_Glyph ( m_face -> glyph , & glyph -> image ) ; if ( error ) continue ; FT_Glyph_Transform ( glyph -> image , 0 , & glyph -> pos ) ; pen . x += slot -> advance . x >> 6 ; previous = glyph_index ; numGlyphs ++ ; } CC_SAFE_DELETE_ARRAY ( pwszBuffer ) ; return error ; } void CCFreeTypeFont :: compute_bbox ( std :: vector < TGlyph > & glyphs , FT_BBox * abbox ) { FT_BBox bbox ; FT_BBox glyph_bbox ; bbox . xMin = 32000 ; bbox . xMax = - 32000 ; bbox . yMin = ( m_face -> size -> metrics . descender ) >> 6 ; bbox . yMax = ( m_face -> size -> metrics . ascender ) >> 6 ; for ( auto glyph = glyphs . begin ( ) ; glyph != glyphs . end ( ) ; ++ glyph ) { FT_Glyph_Get_CBox ( glyph -> image , ft_glyph_bbox_pixels , & glyph_bbox ) ; glyph_bbox . xMin += glyph -> pos . x ; glyph_bbox . xMax += glyph -> pos . x ; glyph_bbox . yMin += glyph -> pos . y ; glyph_bbox . yMax += glyph -> pos . y ; if ( glyph_bbox . xMin < bbox . xMin ) bbox . xMin = glyph_bbox . xMin ; if ( glyph_bbox . yMin < bbox . yMin ) bbox . yMin = glyph_bbox . yMin ; if ( glyph_bbox . xMax > bbox . xMax ) bbox . xMax = glyph_bbox . xMax ; if ( glyph_bbox . yMax > bbox . yMax ) bbox . yMax = glyph_bbox . yMax ; } if ( bbox . xMin > bbox . xMax ) { bbox . xMin = 0 ; bbox . yMin = 0 ; bbox . xMax = 0 ; bbox . yMax = 0 ; } * abbox = bbox ; } unsigned char * CCFreeTypeFont :: loadFont ( const char * pFontName , ssize_t * size ) { std :: string lowerCase ( pFontName ) ; std :: string path ( pFontName ) ; for ( unsigned int i = 0 ; i < lowerCase . length ( ) ; ++ i ) { lowerCase [ i ] = tolower ( lowerCase [ i ] ) ; } if ( std :: string :: npos == lowerCase . find ( " fonts / " ) ) { path = " fonts / " ; path += pFontName ; } if ( std :: string :: npos == lowerCase . find ( " . ttf " ) ) { path += " . ttf " ; } std :: string fullpath = FileUtils :: getInstance ( ) -> fullPathForFilename ( path . c_str ( ) ) ; return FileUtils :: sharedFileUtils ( ) -> getFileData ( fullpath . c_str ( ) , " rb " , size ) ; } unsigned char * CCFreeTypeFont :: loadSystemFont ( const char * pFontName , ssize_t * size ) { # if ( CC_TARGET_PLATFORM == CC_PLATFORM_WP8 ) return nullptr ; # else std :: string aName ( pFontName ) ; unsigned char * pBuffer = nullptr ; HRESULT hr = S_OK ; IDWriteFactory * writeFactory = nullptr ; IDWriteFontCollection * fontCollection = nullptr ; IDWriteFontFamily * fontFamily = nullptr ; IDWriteFont * matchingFont = nullptr ; IDWriteFontFace * fontFace = nullptr ; IDWriteFontFile * fontFile = nullptr ; IDWriteFontFileLoader * fontFileLoader = nullptr ; IDWriteFontFileStream * fontFileStream = nullptr ; UINT32 index ; BOOL exists ; std :: wstring fontNameW ; const void * fontFileReferenceKey = nullptr ; UINT32 fontFileReferenceKeySize ; void * fragmentContext = nullptr ; for ( unsigned int i = 0 ; i < aName . length ( ) ; ++ i ) { aName [ i ] = tolower ( aName [ i ] ) ; } fontNameW . assign ( aName . begin ( ) , aName . end ( ) ) ; hr = DWriteCreateFactory ( DWRITE_FACTORY_TYPE_SHARED , __uuidof ( IDWriteFactory ) , reinterpret_cast < IUnknown * * > ( & writeFactory ) ) ; if ( SUCCEEDED ( hr ) ) { hr = writeFactory -> GetSystemFontCollection ( & fontCollection , TRUE ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontCollection -> FindFamilyName ( fontNameW . c_str ( ) , & index , & exists ) ; if ( SUCCEEDED ( hr ) && exists ) { hr = fontCollection -> GetFontFamily ( index , & fontFamily ) ; if ( SUCCEEDED ( hr ) ) { hr = fontFamily -> GetFirstMatchingFont ( DWRITE_FONT_WEIGHT_REGULAR , DWRITE_FONT_STRETCH_NORMAL , DWRITE_FONT_STYLE_NORMAL , & matchingFont ) ; } if ( SUCCEEDED ( hr ) ) { hr = matchingFont -> CreateFontFace ( & fontFace ) ; } if ( SUCCEEDED ( hr ) ) { UINT32 numberOfFiles = 1 ; hr = fontFace -> GetFiles ( & numberOfFiles , & fontFile ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFile -> GetReferenceKey ( & fontFileReferenceKey , & fontFileReferenceKeySize ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFile -> GetLoader ( & fontFileLoader ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFileLoader -> CreateStreamFromKey ( fontFileReferenceKey , fontFileReferenceKeySize , & fontFileStream ) ; } if ( SUCCEEDED ( hr ) ) { UINT64 fileSize ; const void * fragmentStart = nullptr ; hr = fontFileStream -> GetFileSize ( & fileSize ) ; if ( SUCCEEDED ( hr ) ) { hr = fontFileStream -> ReadFileFragment ( & fragmentStart , 0 , fileSize , & fragmentContext ) ; } if ( SUCCEEDED ( hr ) ) { pBuffer = ( unsigned char * ) malloc ( ( size_t ) fileSize ) ; memcpy ( pBuffer , fragmentStart , ( size_t ) fileSize ) ; * size = ( unsigned long ) fileSize ; } } } } if ( fontFileStream ) { fontFileStream -> ReleaseFileFragment ( fragmentContext ) ; fontFileStream -> Release ( ) ; } if ( fontFileLoader ) { fontFileLoader -> Release ( ) ; } if ( fontFile ) { fontFile -> Release ( ) ; } if ( fontFace ) { fontFace -> Release ( ) ; } if ( matchingFont ) { matchingFont -> Release ( ) ; } if ( fontFamily ) { fontFamily -> Release ( ) ; } if ( fontCollection ) { fontCollection -> Release ( ) ; } if ( writeFactory ) { writeFactory -> Release ( ) ; } return pBuffer ; # endif } NS_CC_END </DOCUMENT>
<DOCUMENT_ID="rexim/beatwave/tree/master/test/core/testanimated.cpp"> # define CATCH_CONFIG_MAIN # include < catch . hpp > # include < core / animated . hpp > TEST_CASE ( " Animating ▁ object ▁ with ▁ nullptr ▁ should ▁ not ▁ crash ▁ the ▁ app " , " [ animated ] " ) { Animated < int > x ( 10 ) ; x . animate ( nullptr ) ; } </DOCUMENT>
<DOCUMENT_ID="Hankuo/color-emoji.skia/tree/master/src/gpu/gl/unix/GrGLCreateNativeInterface_unix.cpp"> # include " gl / GrGLExtensions . h " # include " gl / GrGLInterface . h " # include " . . / GrGLUtil . h " # include < GL / glx . h > # include < GL / gl . h > # include < GL / glext . h > # include < GL / glu . h > # define GR_GL_GET_PROC ( F ) interface -> f ## F = ( GrGL ## F ## Proc ) glXGetProcAddress ( reinterpret_cast < const GLubyte * > ( " gl " # F ) ) ; # define GR_GL_GET_PROC_SUFFIX ( F , S ) interface -> f ## F = ( GrGL ## F ## Proc ) glXGetProcAddress ( reinterpret_cast < const GLubyte * > ( " gl " # F # S ) ) ; const GrGLInterface * GrGLCreateNativeInterface ( ) { if ( NULL != glXGetCurrentContext ( ) ) { const char * versionString = ( const char * ) glGetString ( GL_VERSION ) ; GrGLVersion glVer = GrGLGetVersionFromString ( versionString ) ; GrGLGetStringiProc glGetStringi = ( GrGLGetStringiProc ) glXGetProcAddress ( reinterpret_cast < const GLubyte * > ( " glGetStringi " ) ) ; GrGLExtensions extensions ; if ( ! extensions . init ( kDesktop_GrGLBinding , glGetString , glGetStringi , glGetIntegerv ) ) { return NULL ; } if ( glVer < GR_GL_VER ( 1 , 5 ) ) { return NULL ; } GrGLInterface * interface = new GrGLInterface ( ) ; interface -> fActiveTexture = glActiveTexture ; GR_GL_GET_PROC ( AttachShader ) ; GR_GL_GET_PROC ( BindAttribLocation ) ; GR_GL_GET_PROC ( BindBuffer ) ; GR_GL_GET_PROC ( BindFragDataLocation ) ; GR_GL_GET_PROC ( BeginQuery ) ; interface -> fBindTexture = glBindTexture ; interface -> fBlendFunc = glBlendFunc ; if ( glVer >= GR_GL_VER ( 1 , 4 ) || extensions . has ( " GL _ ARB _ imaging " ) || extensions . has ( " GL _ EXT _ blend _ color " ) ) { GR_GL_GET_PROC ( BlendColor ) ; } GR_GL_GET_PROC ( BufferData ) ; GR_GL_GET_PROC ( BufferSubData ) ; interface -> fClear = glClear ; interface -> fClearColor = glClearColor ; interface -> fClearStencil = glClearStencil ; interface -> fColorMask = glColorMask ; GR_GL_GET_PROC ( CompileShader ) ; interface -> fCompressedTexImage2D = glCompressedTexImage2D ; interface -> fCopyTexSubImage2D = glCopyTexSubImage2D ; GR_GL_GET_PROC ( CreateProgram ) ; GR_GL_GET_PROC ( CreateShader ) ; interface -> fCullFace = glCullFace ; GR_GL_GET_PROC ( DeleteBuffers ) ; GR_GL_GET_PROC ( DeleteProgram ) ; GR_GL_GET_PROC ( DeleteQueries ) ; GR_GL_GET_PROC ( DeleteShader ) ; interface -> fDeleteTextures = glDeleteTextures ; interface -> fDepthMask = glDepthMask ; interface -> fDisable = glDisable ; GR_GL_GET_PROC ( DisableVertexAttribArray ) ; interface -> fDrawArrays = glDrawArrays ; interface -> fDrawBuffer = glDrawBuffer ; GR_GL_GET_PROC ( DrawBuffers ) ; interface -> fDrawElements = glDrawElements ; interface -> fEnable = glEnable ; GR_GL_GET_PROC ( EnableVertexAttribArray ) ; GR_GL_GET_PROC ( EndQuery ) ; interface -> fFinish = glFinish ; interface -> fFlush = glFlush ; interface -> fFrontFace = glFrontFace ; GR_GL_GET_PROC ( GenBuffers ) ; GR_GL_GET_PROC ( GetBufferParameteriv ) ; interface -> fGetError = glGetError ; interface -> fGetIntegerv = glGetIntegerv ; GR_GL_GET_PROC ( GetQueryObjectiv ) ; GR_GL_GET_PROC ( GetQueryObjectuiv ) ; if ( glVer >= GR_GL_VER ( 3 , 3 ) || extensions . has ( " GL _ ARB _ timer _ query " ) ) { GR_GL_GET_PROC ( GetQueryObjecti64v ) ; GR_GL_GET_PROC ( GetQueryObjectui64v ) ; GR_GL_GET_PROC ( QueryCounter ) ; } else if ( extensions . has ( " GL _ EXT _ timer _ query " ) ) { GR_GL_GET_PROC_SUFFIX ( GetQueryObjecti64v , EXT ) ; GR_GL_GET_PROC_SUFFIX ( GetQueryObjectui64v , EXT ) ; } GR_GL_GET_PROC ( GetQueryiv ) ; GR_GL_GET_PROC ( GetProgramInfoLog ) ; GR_GL_GET_PROC ( GetProgramiv ) ; GR_GL_GET_PROC ( GetShaderInfoLog ) ; GR_GL_GET_PROC ( GetShaderiv ) ; interface -> fGetString = glGetString ; GR_GL_GET_PROC ( GetStringi ) ; interface -> fGetTexLevelParameteriv = glGetTexLevelParameteriv ; GR_GL_GET_PROC ( GenQueries ) ; interface -> fGenTextures = glGenTextures ; GR_GL_GET_PROC ( GetUniformLocation ) ; interface -> fLineWidth = glLineWidth ; GR_GL_GET_PROC ( LinkProgram ) ; GR_GL_GET_PROC ( MapBuffer ) ; interface -> fPixelStorei = glPixelStorei ; interface -> fReadBuffer = glReadBuffer ; interface -> fReadPixels = glReadPixels ; if ( extensions . has ( " GL _ NV _ framebuffer _ multisample _ coverage " ) ) { GR_GL_GET_PROC_SUFFIX ( RenderbufferStorageMultisampleCoverage , NV ) ; } interface -> fScissor = glScissor ; GR_GL_GET_PROC ( ShaderSource ) ; interface -> fStencilFunc = glStencilFunc ; GR_GL_GET_PROC ( StencilFuncSeparate ) ; interface -> fStencilMask = glStencilMask ; GR_GL_GET_PROC ( StencilMaskSeparate ) ; interface -> fStencilOp = glStencilOp ; GR_GL_GET_PROC ( StencilOpSeparate ) ; interface -> fTexImage2D = glTexImage2D ; interface -> fTexParameteri = glTexParameteri ; interface -> fTexParameteriv = glTexParameteriv ; if ( glVer >= GR_GL_VER ( 4 , 2 ) || extensions . has ( " GL _ ARB _ texture _ storage " ) ) { GR_GL_GET_PROC ( TexStorage2D ) ; } else if ( extensions . has ( " GL _ EXT _ texture _ storage " ) ) { GR_GL_GET_PROC_SUFFIX ( TexStorage2D , EXT ) ; } interface -> fTexSubImage2D = glTexSubImage2D ; GR_GL_GET_PROC ( Uniform1f ) ; GR_GL_GET_PROC ( Uniform1i ) ; GR_GL_GET_PROC ( Uniform1fv ) ; GR_GL_GET_PROC ( Uniform1iv ) ; GR_GL_GET_PROC ( Uniform2f ) ; GR_GL_GET_PROC ( Uniform2i ) ; GR_GL_GET_PROC ( Uniform2fv ) ; GR_GL_GET_PROC ( Uniform2iv ) ; GR_GL_GET_PROC ( Uniform3f ) ; GR_GL_GET_PROC ( Uniform3i ) ; GR_GL_GET_PROC ( Uniform3fv ) ; GR_GL_GET_PROC ( Uniform3iv ) ; GR_GL_GET_PROC ( Uniform4f ) ; GR_GL_GET_PROC ( Uniform4i ) ; GR_GL_GET_PROC ( Uniform4fv ) ; GR_GL_GET_PROC ( Uniform4iv ) ; GR_GL_GET_PROC ( UniformMatrix2fv ) ; GR_GL_GET_PROC ( UniformMatrix3fv ) ; GR_GL_GET_PROC ( UniformMatrix4fv ) ; GR_GL_GET_PROC ( UnmapBuffer ) ; GR_GL_GET_PROC ( UseProgram ) ; GR_GL_GET_PROC ( VertexAttrib4fv ) ; GR_GL_GET_PROC ( VertexAttribPointer ) ; interface -> fViewport = glViewport ; GR_GL_GET_PROC ( BindFragDataLocationIndexed ) ; if ( glVer >= GR_GL_VER ( 3 , 0 ) || extensions . has ( " GL _ ARB _ vertex _ array _ object " ) ) { GR_GL_GET_PROC ( BindVertexArray ) ; GR_GL_GET_PROC ( GenVertexArrays ) ; GR_GL_GET_PROC ( DeleteVertexArrays ) ; } if ( glVer >= GR_GL_VER ( 3 , 0 ) || extensions . has ( " GL _ ARB _ framebuffer _ object " ) ) { GR_GL_GET_PROC ( GenFramebuffers ) ; GR_GL_GET_PROC ( GetFramebufferAttachmentParameteriv ) ; GR_GL_GET_PROC ( GetRenderbufferParameteriv ) ; GR_GL_GET_PROC ( BindFramebuffer ) ; GR_GL_GET_PROC ( FramebufferTexture2D ) ; GR_GL_GET_PROC ( CheckFramebufferStatus ) ; GR_GL_GET_PROC ( DeleteFramebuffers ) ; GR_GL_GET_PROC ( RenderbufferStorage ) ; GR_GL_GET_PROC ( GenRenderbuffers ) ; GR_GL_GET_PROC ( DeleteRenderbuffers ) ; GR_GL_GET_PROC ( FramebufferRenderbuffer ) ; GR_GL_GET_PROC ( BindRenderbuffer ) ; GR_GL_GET_PROC ( RenderbufferStorageMultisample ) ; GR_GL_GET_PROC ( BlitFramebuffer ) ; } else if ( extensions . has ( " GL _ EXT _ framebuffer _ object " ) ) { GR_GL_GET_PROC_SUFFIX ( GenFramebuffers , EXT ) ; GR_GL_GET_PROC_SUFFIX ( GetFramebufferAttachmentParameteriv , EXT ) ; GR_GL_GET_PROC_SUFFIX ( GetRenderbufferParameteriv , EXT ) ; GR_GL_GET_PROC_SUFFIX ( BindFramebuffer , EXT ) ; GR_GL_GET_PROC_SUFFIX ( FramebufferTexture2D , EXT ) ; GR_GL_GET_PROC_SUFFIX ( CheckFramebufferStatus , EXT ) ; GR_GL_GET_PROC_SUFFIX ( DeleteFramebuffers , EXT ) ; GR_GL_GET_PROC_SUFFIX ( RenderbufferStorage , EXT ) ; GR_GL_GET_PROC_SUFFIX ( GenRenderbuffers , EXT ) ; GR_GL_GET_PROC_SUFFIX ( DeleteRenderbuffers , EXT ) ; GR_GL_GET_PROC_SUFFIX ( FramebufferRenderbuffer , EXT ) ; GR_GL_GET_PROC_SUFFIX ( BindRenderbuffer , EXT ) ; if ( extensions . has ( " GL _ EXT _ framebuffer _ multisample " ) ) { GR_GL_GET_PROC_SUFFIX ( RenderbufferStorageMultisample , EXT ) ; } if ( extensions . has ( " GL _ EXT _ framebuffer _ blit " ) ) { GR_GL_GET_PROC_SUFFIX ( BlitFramebuffer , EXT ) ; } } else { delete interface ; return NULL ; } interface -> fBindingsExported = kDesktop_GrGLBinding ; return interface ; } else { return NULL ; } } </DOCUMENT>
<DOCUMENT_ID="carvalhomb/tsmells/tree/master/sample/poco/poco/Net/src/ICMPPacket.cpp"> # include " Poco / Net / ICMPPacket . h " # include " Poco / Net / ICMPv4PacketImpl . h " # include " Poco / Net / NetException . h " # include " Poco / Timestamp . h " # include " Poco / Timespan . h " # include " Poco / Process . h " # include " Poco / NumberFormatter . h " # include < sstream > using Poco :: InvalidArgumentException ; using Poco :: NotImplementedException ; using Poco :: Timestamp ; using Poco :: Timespan ; using Poco :: Process ; using Poco :: NumberFormatter ; using Poco :: UInt8 ; using Poco :: UInt16 ; using Poco :: Int32 ; namespace Poco { namespace Net { ICMPPacket :: ICMPPacket ( IPAddress :: Family family , int dataSize ) : _pImpl ( 0 ) { if ( family == IPAddress :: IPv4 ) _pImpl = new ICMPv4PacketImpl ( dataSize ) ; # if POCO_HAVE_IPv6 else if ( family == IPAddress :: IPv6 ) throw NotImplementedException ( " ICMPv6 ▁ packets ▁ not ▁ implemented . " ) ; # endif else throw InvalidArgumentException ( " Invalid ▁ or ▁ unsupported ▁ address ▁ family ▁ passed ▁ to ▁ ICMPPacket " ) ; } ICMPPacket :: ~ ICMPPacket ( ) { delete _pImpl ; } void ICMPPacket :: setDataSize ( int dataSize ) { _pImpl -> setDataSize ( dataSize ) ; } int ICMPPacket :: getDataSize ( ) const { return _pImpl -> getDataSize ( ) ; } int ICMPPacket :: packetSize ( ) const { return _pImpl -> packetSize ( ) ; } int ICMPPacket :: maxPacketSize ( ) const { return _pImpl -> maxPacketSize ( ) ; } const Poco :: UInt8 * ICMPPacket :: packet ( ) { return _pImpl -> packet ( ) ; } struct timeval ICMPPacket :: time ( Poco :: UInt8 * buffer , int length ) const { return _pImpl -> time ( buffer , length ) ; } bool ICMPPacket :: validReplyID ( Poco :: UInt8 * buffer , int length ) const { return _pImpl -> validReplyID ( buffer , length ) ; } std :: string ICMPPacket :: errorDescription ( Poco :: UInt8 * buffer , int length ) { return _pImpl -> errorDescription ( buffer , length ) ; } std :: string ICMPPacket :: typeDescription ( int typeId ) { return _pImpl -> typeDescription ( typeId ) ; } } } </DOCUMENT>
<DOCUMENT_ID="taiki-okano/Algorithm/tree/master/AOJ/AOJ0554.cpp"> # include < cstdio > int main ( ) { int sum = 0 ; for ( int i = 0 ; i < 4 ; ++ i ) { int in ; scanf ( " % d " , & in ) ; sum += in ; } printf ( " % d \n " , sum / 60 ) ; printf ( " % d \n " , sum % 60 ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="atidot3/Orizon-510/tree/master/src/server/authserver/Main.cpp"> # include < ace / Dev_Poll_Reactor . h > # include < ace / TP_Reactor . h > # include < ace / ACE . h > # include < ace / Sig_Handler . h > # include < openssl / opensslv . h > # include < openssl / crypto . h > # include " Common . h " # include " Database / DatabaseEnv . h " # include " Configuration / Config . h " # include " Log . h " # include " SystemConfig . h " # include " Util . h " # include " SignalHandler . h " # include " RealmList . h " # include " RealmAcceptor . h " # ifndef _TRINITY_REALM_CONFIG # define _TRINITY_REALM_CONFIG " authserver . conf " # endif bool StartDB ( ) ; void StopDB ( ) ; bool stopEvent = false ; LoginDatabaseWorkerPool LoginDatabase ; class AuthServerSignalHandler : public Trinity :: SignalHandler { public : virtual void HandleSignal ( int SigNum ) { switch ( SigNum ) { case SIGINT : case SIGTERM : stopEvent = true ; break ; } } } ; void usage ( const char * prog ) { sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Usage : ▁ \n ▁ % s ▁ [ < options > ] \n " " ▁ ▁ ▁ ▁ - c ▁ config _ file ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ use ▁ config _ file ▁ as ▁ configuration ▁ file \n " , prog ) ; } extern int main ( int argc , char * * argv ) { char const * cfg_file = _TRINITY_REALM_CONFIG ; int c = 1 ; while ( c < argc ) { if ( strcmp ( argv [ c ] , " - c " ) == 0 ) { if ( ++ c >= argc ) { printf ( " Runtime - Error : ▁ - c ▁ option ▁ requires ▁ an ▁ input ▁ argument \n " ) ; usage ( argv [ 0 ] ) ; return 1 ; } else cfg_file = argv [ c ] ; } ++ c ; } if ( ! ConfigMgr :: Load ( cfg_file ) ) { printf ( " Invalid ▁ or ▁ missing ▁ configuration ▁ file ▁ : ▁ % s \n " , cfg_file ) ; printf ( " Verify ▁ that ▁ the ▁ file ▁ exists ▁ and ▁ has ▁ \ ' [ authserver ] \ ' ▁ written ▁ in ▁ the ▁ top ▁ of ▁ the ▁ file ! \n " ) ; return 1 ; } sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " % s ▁ ( authserver ) " , _FULLVERSION ) ; sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " < Ctrl - C > ▁ to ▁ stop . \n " ) ; sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Using ▁ configuration ▁ file ▁ % s . " , cfg_file ) ; sLog -> outWarn ( LOG_FILTER_AUTHSERVER , " % s ▁ ( Library : ▁ % s ) " , OPENSSL_VERSION_TEXT , SSLeay_version ( SSLEAY_VERSION ) ) ; # if defined ( ACE_HAS_EVENT_POLL ) || defined ( ACE_HAS_DEV_POLL ) ACE_Reactor :: instance ( new ACE_Reactor ( new ACE_Dev_Poll_Reactor ( ACE :: max_handles ( ) , 1 ) , 1 ) , true ) ; # else ACE_Reactor :: instance ( new ACE_Reactor ( new ACE_TP_Reactor ( ) , true ) , true ) ; # endif sLog -> outDebug ( LOG_FILTER_AUTHSERVER , " Max ▁ allowed ▁ open ▁ files ▁ is ▁ % d " , ACE :: max_handles ( ) ) ; std :: string pidfile = ConfigMgr :: GetStringDefault ( " PidFile " , " " ) ; if ( ! pidfile . empty ( ) ) { uint32 pid = CreatePIDFile ( pidfile ) ; if ( ! pid ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Cannot ▁ create ▁ PID ▁ file ▁ % s . \n " , pidfile . c_str ( ) ) ; return 1 ; } sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Daemon ▁ PID : ▁ % u \n " , pid ) ; } if ( ! StartDB ( ) ) return 1 ; sLog -> SetRealmID ( 0 ) ; sRealmList -> Initialize ( ConfigMgr :: GetIntDefault ( " RealmsStateUpdateDelay " , 20 ) ) ; if ( sRealmList -> size ( ) == 0 ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " No ▁ valid ▁ realms ▁ specified . " ) ; return 1 ; } RealmAcceptor acceptor ; int32 rmport = ConfigMgr :: GetIntDefault ( " RealmServerPort " , 3724 ) ; if ( rmport < 0 || rmport > 0xFFFF ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Specified ▁ port ▁ out ▁ of ▁ allowed ▁ range ▁ ( 1-65535 ) " ) ; return 1 ; } std :: string bind_ip = ConfigMgr :: GetStringDefault ( " BindIP " , "0.0.0.0" ) ; ACE_INET_Addr bind_addr ( uint16 ( rmport ) , bind_ip . c_str ( ) ) ; if ( acceptor . open ( bind_addr , ACE_Reactor :: instance ( ) , ACE_NONBLOCK ) == - 1 ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Auth ▁ server ▁ can ▁ not ▁ bind ▁ to ▁ % s : % d " , bind_ip . c_str ( ) , rmport ) ; return 1 ; } AuthServerSignalHandler SignalINT , SignalTERM ; ACE_Sig_Handler Handler ; Handler . register_handler ( SIGINT , & SignalINT ) ; Handler . register_handler ( SIGTERM , & SignalTERM ) ; # ifdef _WIN32 { HANDLE hProcess = GetCurrentProcess ( ) ; uint32 Aff = ConfigMgr :: GetIntDefault ( " UseProcessors " , 0 ) ; if ( Aff > 0 ) { ULONG_PTR appAff ; ULONG_PTR sysAff ; if ( GetProcessAffinityMask ( hProcess , & appAff , & sysAff ) ) { ULONG_PTR curAff = Aff & appAff ; if ( ! curAff ) sLog -> outError ( LOG_FILTER_AUTHSERVER , " Processors ▁ marked ▁ in ▁ UseProcessors ▁ bitmask ▁ ( hex ) ▁ % x ▁ not ▁ accessible ▁ for ▁ authserver . ▁ Accessible ▁ processors ▁ bitmask ▁ ( hex ) : ▁ % x " , Aff , appAff ) ; else if ( SetProcessAffinityMask ( hProcess , curAff ) ) sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Using ▁ processors ▁ ( bitmask , ▁ hex ) : ▁ % x " , curAff ) ; else sLog -> outError ( LOG_FILTER_AUTHSERVER , " Can ' t ▁ set ▁ used ▁ processors ▁ ( hex ) : ▁ % x " , curAff ) ; } } bool Prio = ConfigMgr :: GetBoolDefault ( " ProcessPriority " , false ) ; if ( Prio ) { if ( SetPriorityClass ( hProcess , HIGH_PRIORITY_CLASS ) ) sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " The ▁ auth ▁ server ▁ process ▁ priority ▁ class ▁ has ▁ been ▁ set ▁ to ▁ HIGH " ) ; else sLog -> outError ( LOG_FILTER_AUTHSERVER , " Can ' t ▁ set ▁ auth ▁ server ▁ process ▁ priority ▁ class . " ) ; } } # endif uint32 numLoops = ( ConfigMgr :: GetIntDefault ( " MaxPingTime " , 30 ) * ( MINUTE * 1000000 / 100000 ) ) ; uint32 loopCounter = 0 ; while ( ! stopEvent ) { ACE_Time_Value interval ( 0 , 100000 ) ; if ( ACE_Reactor :: instance ( ) -> run_reactor_event_loop ( interval ) == - 1 ) break ; if ( ( ++ loopCounter ) == numLoops ) { loopCounter = 0 ; sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Ping ▁ MySQL ▁ to ▁ keep ▁ connection ▁ alive " ) ; LoginDatabase . KeepAlive ( ) ; } } StopDB ( ) ; sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Halting ▁ process . . . " ) ; return 0 ; } bool StartDB ( ) { MySQL :: Library_Init ( ) ; std :: string dbstring = ConfigMgr :: GetStringDefault ( " LoginDatabaseInfo " , " " ) ; if ( dbstring . empty ( ) ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Database ▁ not ▁ specified " ) ; return false ; } int32 worker_threads = ConfigMgr :: GetIntDefault ( " LoginDatabase . WorkerThreads " , 1 ) ; if ( worker_threads < 1 || worker_threads > 32 ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Improper ▁ value ▁ specified ▁ for ▁ LoginDatabase . WorkerThreads , ▁ defaulting ▁ to ▁ 1 . " ) ; worker_threads = 1 ; } int32 synch_threads = ConfigMgr :: GetIntDefault ( " LoginDatabase . SynchThreads " , 1 ) ; if ( synch_threads < 1 || synch_threads > 32 ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Improper ▁ value ▁ specified ▁ for ▁ LoginDatabase . SynchThreads , ▁ defaulting ▁ to ▁ 1 . " ) ; synch_threads = 1 ; } if ( ! LoginDatabase . Open ( dbstring . c_str ( ) , uint8 ( worker_threads ) , uint8 ( synch_threads ) ) ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Cannot ▁ connect ▁ to ▁ database " ) ; return false ; } sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Started ▁ auth ▁ database ▁ connection ▁ pool . " ) ; sLog -> EnableDBAppenders ( ) ; return true ; } void StopDB ( ) { LoginDatabase . Close ( ) ; MySQL :: Library_End ( ) ; } </DOCUMENT>
<DOCUMENT_ID="ichu501/WinObjC/tree/master/deps/3rdparty/icu/icu/source/test/intltest/tsmthred.cpp"> # if defined ( hpux ) # ifndef _INCLUDE_POSIX_SOURCE # define _INCLUDE_POSIX_SOURCE # endif # endif # include " simplethread . h " # include " unicode / utypes . h " # include " unicode / ustring . h " # include " umutex . h " # include " cmemory . h " # include " cstring . h " # include " uparse . h " # include " unicode / localpointer . h " # include " unicode / resbund . h " # include " unicode / udata . h " # include " unicode / uloc . h " # include " unicode / locid . h " # include " putilimp . h " # include " intltest . h " # include " tsmthred . h " # include " unicode / ushape . h " # include " unicode / translit . h " # include " sharedobject . h " # include " unifiedcache . h " # include " uassert . h " # if U_PLATFORM_USES_ONLY_WIN32_API # undef POSIX # elif U_PLATFORM_IMPLEMENTS_POSIX # define POSIX # else # undef POSIX # endif # if U_PLATFORM == U_PF_OS390 # define __DOT1 1 # define __UU # ifndef _XPG4_2 # define _XPG4_2 # endif # include < unistd . h > # endif # if defined ( POSIX ) # define HAVE_IMP # if ( ICU_USE_THREADS == 1 ) # include < pthread . h > # endif # if defined ( __hpux ) && defined ( HPUX_CMA ) # if defined ( read ) # undef read # endif # endif # ifndef __EXTENSIONS__ # define __EXTENSIONS__ # endif # if U_PLATFORM == U_PF_OS390 # include < sys / types . h > # endif # if U_PLATFORM != U_PF_OS390 # include < signal . h > # endif # ifndef _XPG4_2 # define _XPG4_2 # endif # ifndef __USE_XOPEN_EXTENDED # define __USE_XOPEN_EXTENDED # endif # ifndef _INCLUDE_XOPEN_SOURCE_EXTENDED # define _INCLUDE_XOPEN_SOURCE_EXTENDED # endif # include < unistd . h > # endif # ifdef sleep # undef sleep # endif # define TSMTHREAD_FAIL ( msg ) errln ( " % s ▁ at ▁ file ▁ % s , ▁ line ▁ % d " , msg , __FILE__ , __LINE__ ) # define TSMTHREAD_ASSERT ( expr ) { if ( ! ( expr ) ) { TSMTHREAD_FAIL ( " Fail " ) ; } } MultithreadTest :: MultithreadTest ( ) { } MultithreadTest :: ~ MultithreadTest ( ) { } # if ( ICU_USE_THREADS == 0 ) void MultithreadTest :: runIndexedTest ( int32_t index , UBool exec , const char * & name , char * ) { if ( exec ) logln ( " TestSuite ▁ MultithreadTest : ▁ " ) ; if ( index == 0 ) name = " NO _ THREADED _ TESTS " ; else name = " " ; if ( exec ) { logln ( " MultithreadTest ▁ - ▁ test ▁ DISABLED . ▁ ▁ ICU _ USE _ THREADS ▁ set ▁ to ▁ 0 , ▁ check ▁ your ▁ configuration ▁ if ▁ this ▁ is ▁ a ▁ problem . . " ) ; } } # else # include < stdio . h > # include < string . h > # include < ctype . h > # include " unicode / putil . h " # include " unicode / numfmt . h " # include " unicode / choicfmt . h " # include " unicode / msgfmt . h " # include " unicode / locid . h " # include " unicode / coll . h " # include " unicode / calendar . h " # include " ucaconf . h " void SimpleThread :: errorFunc ( ) { } void MultithreadTest :: runIndexedTest ( int32_t index , UBool exec , const char * & name , char * ) { if ( exec ) logln ( " TestSuite ▁ MultithreadTest : ▁ " ) ; switch ( index ) { case 0 : name = " TestThreads " ; if ( exec ) TestThreads ( ) ; break ; case 1 : name = " TestMutex " ; if ( exec ) TestMutex ( ) ; break ; case 2 : name = " TestThreadedIntl " ; # if ! UCONFIG_NO_FORMATTING if ( exec ) { TestThreadedIntl ( ) ; } # endif break ; case 3 : name = " TestCollators " ; # if ! UCONFIG_NO_COLLATION if ( exec ) { TestCollators ( ) ; } # endif break ; case 4 : name = " TestString " ; if ( exec ) { TestString ( ) ; } break ; case 5 : name = " TestArabicShapingThreads " ; if ( exec ) { TestArabicShapingThreads ( ) ; } break ; case 6 : name = " TestAnyTranslit " ; if ( exec ) { TestAnyTranslit ( ) ; } break ; case 7 : name = " TestConditionVariables " ; if ( exec ) { TestConditionVariables ( ) ; } break ; case 8 : name = " TestUnifiedCache " ; if ( exec ) { TestUnifiedCache ( ) ; } break ; default : name = " " ; break ; } } # define THREADTEST_NRTHREADS 8 # define ARABICSHAPE_THREADTEST 30 class TestThreadsThread : public SimpleThread { public : TestThreadsThread ( char * whatToChange ) { fWhatToChange = whatToChange ; } virtual void run ( ) { SimpleThread :: sleep ( 1000 ) ; Mutex m ; * fWhatToChange = ' * ' ; } private : char * fWhatToChange ; } ; class TestArabicShapeThreads : public SimpleThread { public : TestArabicShapeThreads ( char * whatToChange ) { fWhatToChange = whatToChange ; } virtual void run ( ) { if ( doTailTest ( ) == TRUE ) * fWhatToChange = ' * ' ; } private : char * fWhatToChange ; UBool doTailTest ( void ) { static const UChar src [ ] = { 0x0020 , 0x0633 , 0 } ; static const UChar dst_old [ ] = { 0xFEB1 , 0x200B , 0 } ; static const UChar dst_new [ ] = { 0xFEB1 , 0xFE73 , 0 } ; UChar dst [ 3 ] = { 0x0000 , 0x0000 , 0 } ; int32_t length ; UErrorCode status ; IntlTest inteltst = IntlTest ( ) ; status = U_ZERO_ERROR ; length = u_shapeArabic ( src , - 1 , dst , UPRV_LENGTHOF ( dst ) , U_SHAPE_LETTERS_SHAPE | U_SHAPE_SEEN_TWOCELL_NEAR , & status ) ; if ( U_FAILURE ( status ) ) { inteltst . errln ( " Fail : ▁ status ▁ % s \n " , u_errorName ( status ) ) ; return FALSE ; } else if ( length != 2 ) { inteltst . errln ( " Fail : ▁ len ▁ % d ▁ expected ▁ 3 \n " , length ) ; return FALSE ; } else if ( u_strncmp ( dst , dst_old , UPRV_LENGTHOF ( dst ) ) ) { inteltst . errln ( " Fail : ▁ got ▁ U + % 04X ▁ U + % 04X ▁ expected ▁ U + % 04X ▁ U + % 04X \n " , dst [ 0 ] , dst [ 1 ] , dst_old [ 0 ] , dst_old [ 1 ] ) ; return FALSE ; } status = U_ZERO_ERROR ; length = u_shapeArabic ( src , - 1 , dst , UPRV_LENGTHOF ( dst ) , U_SHAPE_LETTERS_SHAPE | U_SHAPE_SEEN_TWOCELL_NEAR | U_SHAPE_TAIL_NEW_UNICODE , & status ) ; if ( U_FAILURE ( status ) ) { inteltst . errln ( " Fail : ▁ status ▁ % s \n " , u_errorName ( status ) ) ; return FALSE ; } else if ( length != 2 ) { inteltst . errln ( " Fail : ▁ len ▁ % d ▁ expected ▁ 3 \n " , length ) ; return FALSE ; } else if ( u_strncmp ( dst , dst_new , UPRV_LENGTHOF ( dst ) ) ) { inteltst . errln ( " Fail : ▁ got ▁ U + % 04X ▁ U + % 04X ▁ expected ▁ U + % 04X ▁ U + % 04X \n " , dst [ 0 ] , dst [ 1 ] , dst_new [ 0 ] , dst_new [ 1 ] ) ; return FALSE ; } return TRUE ; } } ; void MultithreadTest :: TestThreads ( ) { char threadTestChars [ THREADTEST_NRTHREADS + 1 ] ; SimpleThread * threads [ THREADTEST_NRTHREADS ] ; int32_t numThreadsStarted = 0 ; int32_t i ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { threadTestChars [ i ] = ' ▁ ' ; threads [ i ] = new TestThreadsThread ( & threadTestChars [ i ] ) ; } threadTestChars [ THREADTEST_NRTHREADS ] = ' \0' ; logln ( " - > " + UnicodeString ( threadTestChars ) + " < - ▁ Firing ▁ off ▁ threads . . ▁ " ) ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { if ( threads [ i ] -> start ( ) != 0 ) { errln ( " Error ▁ starting ▁ thread ▁ % d " , i ) ; } else { numThreadsStarted ++ ; } SimpleThread :: sleep ( 100 ) ; logln ( " ▁ Subthread ▁ started . " ) ; } logln ( " Waiting ▁ for ▁ threads ▁ to ▁ be ▁ set . . " ) ; if ( numThreadsStarted == 0 ) { errln ( " No ▁ threads ▁ could ▁ be ▁ started ▁ for ▁ testing ! " ) ; return ; } int32_t patience = 40 ; while ( patience -- ) { int32_t count = 0 ; umtx_lock ( NULL ) ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { if ( threadTestChars [ i ] == ' * ' ) { count ++ ; } } umtx_unlock ( NULL ) ; if ( count == THREADTEST_NRTHREADS ) { logln ( " - > " + UnicodeString ( threadTestChars ) + " < - ▁ Got ▁ all ▁ threads ! ▁ cya " ) ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { delete threads [ i ] ; } return ; } logln ( " - > " + UnicodeString ( threadTestChars ) + " < - ▁ Waiting . . " ) ; SimpleThread :: sleep ( 500 ) ; } errln ( " - > " + UnicodeString ( threadTestChars ) + " < - ▁ PATIENCE ▁ EXCEEDED ! ! ▁ Still ▁ missing ▁ some . " ) ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { delete threads [ i ] ; } } void MultithreadTest :: TestArabicShapingThreads ( ) { char threadTestChars [ ARABICSHAPE_THREADTEST + 1 ] ; SimpleThread * threads [ ARABICSHAPE_THREADTEST ] ; int32_t numThreadsStarted = 0 ; int32_t i ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { threadTestChars [ i ] = ' ▁ ' ; threads [ i ] = new TestArabicShapeThreads ( & threadTestChars [ i ] ) ; } threadTestChars [ ARABICSHAPE_THREADTEST ] = ' \0' ; logln ( " - > ▁ do ▁ TestArabicShapingThreads ▁ < - ▁ Firing ▁ off ▁ threads . . ▁ " ) ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { if ( threads [ i ] -> start ( ) != 0 ) { errln ( " Error ▁ starting ▁ thread ▁ % d " , i ) ; } else { numThreadsStarted ++ ; } logln ( " ▁ Subthread ▁ started . " ) ; } logln ( " Waiting ▁ for ▁ threads ▁ to ▁ be ▁ set . . " ) ; if ( numThreadsStarted == 0 ) { errln ( " No ▁ threads ▁ could ▁ be ▁ started ▁ for ▁ testing ! " ) ; return ; } int32_t patience = 100 ; while ( patience -- ) { int32_t count = 0 ; umtx_lock ( NULL ) ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { if ( threadTestChars [ i ] == ' * ' ) { count ++ ; } } umtx_unlock ( NULL ) ; if ( count == ARABICSHAPE_THREADTEST ) { logln ( " - > TestArabicShapingThreads ▁ < - ▁ Got ▁ all ▁ threads ! ▁ cya " ) ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { delete threads [ i ] ; } return ; } logln ( " - > ▁ TestArabicShapingThreads ▁ < - ▁ Waiting . . " ) ; SimpleThread :: sleep ( 500 ) ; } errln ( " - > ▁ TestArabicShapingThreads ▁ < - ▁ PATIENCE ▁ EXCEEDED ! ! ▁ Still ▁ missing ▁ some . " ) ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { delete threads [ i ] ; } } static UMutex gTestMutexA = U_MUTEX_INITIALIZER ; static UMutex gTestMutexB = U_MUTEX_INITIALIZER ; static int gThreadsStarted = 0 ; static int gThreadsInMiddle = 0 ; static int gThreadsDone = 0 ; static const int TESTMUTEX_THREAD_COUNT = 4 ; static int safeIncr ( int & var , int amt ) { Mutex m ; var += amt ; return var ; } class TestMutexThread : public SimpleThread { public : virtual void run ( ) { safeIncr ( gThreadsStarted , 1 ) ; umtx_lock ( & gTestMutexA ) ; umtx_unlock ( & gTestMutexA ) ; safeIncr ( gThreadsInMiddle , 1 ) ; umtx_lock ( & gTestMutexB ) ; umtx_unlock ( & gTestMutexB ) ; safeIncr ( gThreadsDone , 1 ) ; } } ; void MultithreadTest :: TestMutex ( ) { gThreadsStarted = 0 ; gThreadsInMiddle = 0 ; gThreadsDone = 0 ; umtx_lock ( & gTestMutexA ) ; TestMutexThread * threads [ TESTMUTEX_THREAD_COUNT ] ; int i ; int32_t numThreadsStarted = 0 ; for ( i = 0 ; i < TESTMUTEX_THREAD_COUNT ; i ++ ) { threads [ i ] = new TestMutexThread ; if ( threads [ i ] -> start ( ) != 0 ) { errln ( " Error ▁ starting ▁ thread ▁ % d " , i ) ; } else { numThreadsStarted ++ ; } } if ( numThreadsStarted == 0 ) { errln ( " No ▁ threads ▁ could ▁ be ▁ started ▁ for ▁ testing ! " ) ; return ; } int patience = 0 ; while ( safeIncr ( gThreadsStarted , 0 ) != TESTMUTEX_THREAD_COUNT ) { if ( patience ++ > 24 ) { TSMTHREAD_FAIL ( " Patience ▁ Exceeded " ) ; return ; } SimpleThread :: sleep ( 500 ) ; } TSMTHREAD_ASSERT ( gThreadsInMiddle == 0 ) ; TSMTHREAD_ASSERT ( gThreadsDone == 0 ) ; umtx_lock ( & gTestMutexB ) ; umtx_unlock ( & gTestMutexA ) ; patience = 0 ; while ( safeIncr ( gThreadsInMiddle , 0 ) != TESTMUTEX_THREAD_COUNT ) { if ( patience ++ > 24 ) { TSMTHREAD_FAIL ( " Patience ▁ Exceeded " ) ; return ; } SimpleThread :: sleep ( 500 ) ; } TSMTHREAD_ASSERT ( gThreadsDone == 0 ) ; umtx_unlock ( & gTestMutexB ) ; patience = 0 ; while ( safeIncr ( gThreadsDone , 0 ) != TESTMUTEX_THREAD_COUNT ) { if ( patience ++ > 24 ) { TSMTHREAD_FAIL ( " Patience ▁ Exceeded " ) ; return ; } SimpleThread :: sleep ( 500 ) ; } for ( i = 0 ; i < TESTMUTEX_THREAD_COUNT ; i ++ ) { delete threads [ i ] ; } } class ThreadWithStatus : public SimpleThread { public : UBool getError ( ) { return ( fErrors > 0 ) ; } UBool getError ( UnicodeString & fillinError ) { fillinError = fErrorString ; return ( fErrors > 0 ) ; } virtual ~ ThreadWithStatus ( ) { } protected : ThreadWithStatus ( ) : fErrors ( 0 ) { } void error ( const UnicodeString & error ) { fErrors ++ ; fErrorString = error ; SimpleThread :: errorFunc ( ) ; } void error ( ) { error ( " An ▁ error ▁ occured . " ) ; } private : int32_t fErrors ; UnicodeString fErrorString ; } ; UnicodeString showDifference ( const UnicodeString & expected , const UnicodeString & result ) { UnicodeString res ; res = expected + " < Expected \n " ; if ( expected . length ( ) != result . length ( ) ) res += " ▁ [ ▁ Different ▁ lengths ▁ ] ▁ \n " ; else { for ( int32_t i = 0 ; i < expected . length ( ) ; i ++ ) { if ( expected [ i ] == result [ i ] ) { res += " ▁ " ; } else { res += " | " ; } } res += " < Differences " ; res += " \n " ; } res += result + " < Result \n " ; return res ; } const int kFormatThreadIterations = 100 ; const int kFormatThreadThreads = 10 ; # if ! UCONFIG_NO_FORMATTING struct FormatThreadTestData { double number ; UnicodeString string ; FormatThreadTestData ( double a , const UnicodeString & b ) : number ( a ) , string ( b ) { } } ; static void formatErrorMessage ( UErrorCode & realStatus , const UnicodeString & pattern , const Locale & theLocale , UErrorCode inStatus0 , const Locale & inCountry2 , double currency3 , UnicodeString & result ) { if ( U_FAILURE ( realStatus ) ) return ; UnicodeString errString1 ( u_errorName ( inStatus0 ) ) ; UnicodeString countryName2 ; inCountry2 . getDisplayCountry ( theLocale , countryName2 ) ; Formattable myArgs [ ] = { Formattable ( ( int32_t ) inStatus0 ) , Formattable ( errString1 ) , Formattable ( countryName2 ) , Formattable ( currency3 ) } ; MessageFormat * fmt = new MessageFormat ( " MessageFormat ' s ▁ API ▁ is ▁ broken ! ! ! ! ! ! ! ! ! ! ! " , realStatus ) ; fmt -> setLocale ( theLocale ) ; fmt -> applyPattern ( pattern , realStatus ) ; if ( U_FAILURE ( realStatus ) ) { delete fmt ; return ; } FieldPosition ignore = 0 ; fmt -> format ( myArgs , 4 , result , ignore , realStatus ) ; delete fmt ; } class ThreadSafeFormatSharedData { public : ThreadSafeFormatSharedData ( UErrorCode & status ) ; ~ ThreadSafeFormatSharedData ( ) ; LocalPointer < NumberFormat > fFormat ; Formattable fYDDThing ; Formattable fBBDThing ; UnicodeString fYDDStr ; UnicodeString fBBDStr ; } ; const ThreadSafeFormatSharedData * gSharedData = NULL ; ThreadSafeFormatSharedData :: ThreadSafeFormatSharedData ( UErrorCode & status ) { fFormat . adoptInstead ( NumberFormat :: createCurrencyInstance ( Locale :: getUS ( ) , status ) ) ; static const UChar kYDD [ ] = { 0x59 , 0x44 , 0x44 , 0x00 } ; static const UChar kBBD [ ] = { 0x42 , 0x42 , 0x44 , 0x00 } ; fYDDThing . adoptObject ( new CurrencyAmount ( 123.456 , kYDD , status ) ) ; fBBDThing . adoptObject ( new CurrencyAmount ( 987.654 , kBBD , status ) ) ; if ( U_FAILURE ( status ) ) { return ; } fFormat -> format ( fYDDThing , fYDDStr , NULL , status ) ; fFormat -> format ( fBBDThing , fBBDStr , NULL , status ) ; gSharedData = this ; } ThreadSafeFormatSharedData :: ~ ThreadSafeFormatSharedData ( ) { gSharedData = NULL ; } class ThreadSafeFormat { public : ThreadSafeFormat ( UErrorCode & status ) ; UBool doStuff ( int32_t offset , UnicodeString & appendErr , UErrorCode & status ) const ; private : LocalPointer < NumberFormat > fFormat ; } ; ThreadSafeFormat :: ThreadSafeFormat ( UErrorCode & status ) { fFormat . adoptInstead ( NumberFormat :: createCurrencyInstance ( Locale :: getUS ( ) , status ) ) ; } static const UChar kUSD [ ] = { 0x55 , 0x53 , 0x44 , 0x00 } ; UBool ThreadSafeFormat :: doStuff ( int32_t offset , UnicodeString & appendErr , UErrorCode & status ) const { UBool okay = TRUE ; if ( u_strcmp ( fFormat -> getCurrency ( ) , kUSD ) ) { appendErr . append ( " fFormat ▁ currency ▁ ! = ▁ " ) . append ( kUSD ) . append ( " , ▁ = " ) . append ( fFormat -> getCurrency ( ) ) . append ( " ! ▁ " ) ; okay = FALSE ; } if ( u_strcmp ( gSharedData -> fFormat -> getCurrency ( ) , kUSD ) ) { appendErr . append ( " gFormat ▁ currency ▁ ! = ▁ " ) . append ( kUSD ) . append ( " , ▁ = " ) . append ( gSharedData -> fFormat -> getCurrency ( ) ) . append ( " ! ▁ " ) ; okay = FALSE ; } UnicodeString str ; const UnicodeString * o = NULL ; Formattable f ; const NumberFormat * nf = NULL ; switch ( offset % 4 ) { case 0 : f = gSharedData -> fYDDThing ; o = & gSharedData -> fYDDStr ; nf = gSharedData -> fFormat . getAlias ( ) ; break ; case 1 : f = gSharedData -> fBBDThing ; o = & gSharedData -> fBBDStr ; nf = gSharedData -> fFormat . getAlias ( ) ; break ; case 2 : f = gSharedData -> fYDDThing ; o = & gSharedData -> fYDDStr ; nf = fFormat . getAlias ( ) ; break ; case 3 : f = gSharedData -> fBBDThing ; o = & gSharedData -> fBBDStr ; nf = fFormat . getAlias ( ) ; break ; } nf -> format ( f , str , NULL , status ) ; if ( * o != str ) { appendErr . append ( showDifference ( * o , str ) ) ; okay = FALSE ; } return okay ; } UBool U_CALLCONV isAcceptable ( void * , const char * , const char * , const UDataInfo * ) { return TRUE ; } class FormatThreadTest : public ThreadWithStatus { public : int fNum ; int fTraceInfo ; LocalPointer < ThreadSafeFormat > fTSF ; FormatThreadTest ( ) : ThreadWithStatus ( ) , fNum ( 0 ) , fTraceInfo ( 0 ) , fTSF ( NULL ) , fOffset ( 0 ) { UErrorCode status = U_ZERO_ERROR ; fTSF . adoptInstead ( new ThreadSafeFormat ( status ) ) ; static int32_t fgOffset = 0 ; fgOffset += 3 ; fOffset = fgOffset ; } virtual void run ( ) { fTraceInfo = 1 ; LocalPointer < NumberFormat > percentFormatter ; UErrorCode status = U_ZERO_ERROR ; # if 0 for ( int i = 0 ; i < 4000 ; i ++ ) { status = U_ZERO_ERROR ; UDataMemory * data1 = udata_openChoice ( 0 , " res " , " en _ US " , isAcceptable , 0 , & status ) ; UDataMemory * data2 = udata_openChoice ( 0 , " res " , " fr " , isAcceptable , 0 , & status ) ; udata_close ( data1 ) ; udata_close ( data2 ) ; if ( U_FAILURE ( status ) ) { error ( " udata _ openChoice ▁ failed . \n " ) ; break ; } } return ; # endif # if 0 int m ; for ( m = 0 ; m < 4000 ; m ++ ) { status = U_ZERO_ERROR ; UResourceBundle * res = NULL ; const char * localeName = NULL ; Locale loc = Locale :: getEnglish ( ) ; localeName = loc . getName ( ) ; res = ures_open ( NULL , localeName , & status ) ; ures_close ( res ) ; if ( U_FAILURE ( status ) ) { error ( " Resource ▁ bundle ▁ construction ▁ failed . \n " ) ; break ; } } return ; # endif FormatThreadTestData kNumberFormatTestData [ ] = { FormatThreadTestData ( ( double ) 5.0 , UnicodeString ( "5" , " " ) ) , FormatThreadTestData ( 6.0 , UnicodeString ( "6" , " " ) ) , FormatThreadTestData ( 20.0 , UnicodeString ( "20" , " " ) ) , FormatThreadTestData ( 8.0 , UnicodeString ( "8" , " " ) ) , FormatThreadTestData ( 8.3 , UnicodeString ( "8.3" , " " ) ) , FormatThreadTestData ( 12345 , UnicodeString ( "12,345" , " " ) ) , FormatThreadTestData ( 81890.23 , UnicodeString ( "81,890.23" , " " ) ) , } ; int32_t kNumberFormatTestDataLength = UPRV_LENGTHOF ( kNumberFormatTestData ) ; FormatThreadTestData kPercentFormatTestData [ ] = { FormatThreadTestData ( ( double ) 5.0 , CharsToUnicodeString ( "500\\u00a0 % " ) ) , FormatThreadTestData ( 1.0 , CharsToUnicodeString ( "100\\u00a0 % " ) ) , FormatThreadTestData ( 0.26 , CharsToUnicodeString ( "26\\u00a0 % " ) ) , FormatThreadTestData ( 16384.99 , CharsToUnicodeString ( "1\\u00a0638\\u00a0499\\u00a0 % " ) ) , FormatThreadTestData ( 81890.23 , CharsToUnicodeString ( "8\\u00a0189\\u00a0023\\u00a0 % " ) ) , } ; int32_t kPercentFormatTestDataLength = UPRV_LENGTHOF ( kPercentFormatTestData ) ; int32_t iteration ; status = U_ZERO_ERROR ; LocalPointer < NumberFormat > formatter ( NumberFormat :: createInstance ( Locale :: getEnglish ( ) , status ) ) ; if ( U_FAILURE ( status ) ) { error ( " Error ▁ on ▁ NumberFormat : : createInstance ( ) . " ) ; goto cleanupAndReturn ; } percentFormatter . adoptInstead ( NumberFormat :: createPercentInstance ( Locale :: getFrench ( ) , status ) ) ; if ( U_FAILURE ( status ) ) { error ( " Error ▁ on ▁ NumberFormat : : createPercentInstance ( ) . " ) ; goto cleanupAndReturn ; } for ( iteration = 0 ; ! getError ( ) && iteration < kFormatThreadIterations ; iteration ++ ) { int32_t whichLine = ( iteration + fOffset ) % kNumberFormatTestDataLength ; UnicodeString output ; formatter -> format ( kNumberFormatTestData [ whichLine ] . number , output ) ; if ( 0 != output . compare ( kNumberFormatTestData [ whichLine ] . string ) ) { error ( " format ( ) . . ▁ expected ▁ " + kNumberFormatTestData [ whichLine ] . string + " ▁ got ▁ " + output ) ; goto cleanupAndReturn ; } output . remove ( ) ; whichLine = ( iteration + fOffset ) % kPercentFormatTestDataLength ; percentFormatter -> format ( kPercentFormatTestData [ whichLine ] . number , output ) ; if ( 0 != output . compare ( kPercentFormatTestData [ whichLine ] . string ) ) { error ( " percent ▁ format ( ) . . ▁ \n " + showDifference ( kPercentFormatTestData [ whichLine ] . string , output ) ) ; goto cleanupAndReturn ; } const int kNumberOfMessageTests = 3 ; UErrorCode statusToCheck ; UnicodeString patternToCheck ; Locale messageLocale ; Locale countryToCheck ; double currencyToCheck ; UnicodeString expected ; switch ( ( iteration + fOffset ) % kNumberOfMessageTests ) { default : case 0 : statusToCheck = U_FILE_ACCESS_ERROR ; patternToCheck = "0 : Someone ▁ from ▁ { 2 } ▁ is ▁ receiving ▁ a ▁ # {0 } " " ▁ error ▁ - ▁ { 1 } . ▁ Their ▁ telephone ▁ call ▁ is ▁ costing ▁ " " { 3 , number , currency } . " ; messageLocale = Locale ( " en " , " US " ) ; countryToCheck = Locale ( " " , " HR " ) ; currencyToCheck = 8192.77 ; expected = "0 : Someone ▁ from ▁ Croatia ▁ is ▁ receiving ▁ a ▁ # 4 ▁ error ▁ - ▁ " " U _ FILE _ ACCESS _ ERROR . ▁ Their ▁ telephone ▁ call ▁ is ▁ costing ▁ $ 8,192.77 . " ; break ; case 1 : statusToCheck = U_INDEX_OUTOFBOUNDS_ERROR ; patternToCheck = "1 : A ▁ customer ▁ in ▁ { 2 } ▁ is ▁ receiving ▁ a ▁ # {0 } ▁ error ▁ - ▁ { 1 } . ▁ " " Their ▁ telephone ▁ call ▁ is ▁ costing ▁ { 3 , number , currency } . " ; messageLocale = Locale ( " de " , " DE @ currency = DEM " ) ; countryToCheck = Locale ( " " , " BF " ) ; currencyToCheck = 2.32 ; expected = CharsToUnicodeString ( "1 : A ▁ customer ▁ in ▁ Burkina ▁ Faso ▁ is ▁ receiving ▁ a ▁ # 8 ▁ error ▁ - ▁ U _ INDEX _ OUTOFBOUNDS _ ERROR . ▁ " " Their ▁ telephone ▁ call ▁ is ▁ costing ▁ 2,32\\u00A0DM . " ) ; break ; case 2 : statusToCheck = U_MEMORY_ALLOCATION_ERROR ; patternToCheck = "2 : user ▁ in ▁ { 2 } ▁ is ▁ receiving ▁ a ▁ # {0 } ▁ error ▁ - ▁ { 1 } . ▁ " " They ▁ insist ▁ they ▁ just ▁ spent ▁ { 3 , number , currency } ▁ " " on ▁ memory . " ; messageLocale = Locale ( " de " , " AT @ currency = ATS " ) ; countryToCheck = Locale ( " " , " US " ) ; currencyToCheck = 40193.12 ; expected = CharsToUnicodeString ( "2 : user ▁ in ▁ Vereinigte ▁ Staaten ▁ is ▁ receiving ▁ a ▁ # 7 ▁ error " " ▁ - ▁ U _ MEMORY _ ALLOCATION _ ERROR . ▁ They ▁ insist ▁ they ▁ just ▁ spent " " ▁ \\u00f6S\\u00A040.193,12 ▁ on ▁ memory . " ) ; break ; } UnicodeString result ; UErrorCode status = U_ZERO_ERROR ; formatErrorMessage ( status , patternToCheck , messageLocale , statusToCheck , countryToCheck , currencyToCheck , result ) ; if ( U_FAILURE ( status ) ) { UnicodeString tmp ( u_errorName ( status ) ) ; error ( " Failure ▁ on ▁ message ▁ format , ▁ pattern = " + patternToCheck + " , ▁ error ▁ = ▁ " + tmp ) ; goto cleanupAndReturn ; } if ( result != expected ) { error ( " PatternFormat : ▁ \n " + showDifference ( expected , result ) ) ; goto cleanupAndReturn ; } UnicodeString appendErr ; if ( ! fTSF -> doStuff ( fNum , appendErr , status ) ) { error ( appendErr ) ; goto cleanupAndReturn ; } } cleanupAndReturn : fTraceInfo = 2 ; } private : int32_t fOffset ; } ; void MultithreadTest :: TestThreadedIntl ( ) { int i ; UnicodeString theErr ; UBool haveDisplayedInfo [ kFormatThreadThreads ] ; static const int32_t PATIENCE_SECONDS = 45 ; UErrorCode threadSafeErr = U_ZERO_ERROR ; ThreadSafeFormatSharedData sharedData ( threadSafeErr ) ; assertSuccess ( " initializing ▁ ThreadSafeFormat " , threadSafeErr , TRUE ) ; logln ( " Spawning : ▁ % d ▁ threads ▁ * ▁ % d ▁ iterations ▁ each . " , kFormatThreadThreads , kFormatThreadIterations ) ; LocalArray < FormatThreadTest > tests ( new FormatThreadTest [ kFormatThreadThreads ] ) ; for ( int32_t j = 0 ; j < kFormatThreadThreads ; j ++ ) { tests [ j ] . fNum = j ; int32_t threadStatus = tests [ j ] . start ( ) ; if ( threadStatus != 0 ) { errln ( " System ▁ Error ▁ % d ▁ starting ▁ thread ▁ number ▁ % d . " , threadStatus , j ) ; SimpleThread :: errorFunc ( ) ; return ; } haveDisplayedInfo [ j ] = FALSE ; } UBool stillRunning ; UDate startTime , endTime ; startTime = Calendar :: getNow ( ) ; double lastComplaint = 0 ; do { stillRunning = FALSE ; endTime = Calendar :: getNow ( ) ; double elapsedSeconds = ( ( int32_t ) ( endTime - startTime ) / U_MILLIS_PER_SECOND ) ; if ( elapsedSeconds > PATIENCE_SECONDS ) { errln ( " Patience ▁ exceeded . ▁ Test ▁ is ▁ taking ▁ too ▁ long . " ) ; return ; } else if ( ( elapsedSeconds - lastComplaint ) > 2.0 ) { infoln ( " % .1f ▁ seconds ▁ elapsed ▁ ( still ▁ waiting . . ) " , elapsedSeconds ) ; lastComplaint = elapsedSeconds ; } SimpleThread :: sleep ( 1 ) ; for ( i = 0 ; i < kFormatThreadThreads ; i ++ ) { if ( tests [ i ] . isRunning ( ) ) { stillRunning = TRUE ; } else if ( haveDisplayedInfo [ i ] == FALSE ) { logln ( " Thread ▁ # ▁ % d ▁ is ▁ complete . . " , i ) ; if ( tests [ i ] . getError ( theErr ) ) { dataerrln ( UnicodeString ( " # " ) + i + " : ▁ " + theErr ) ; SimpleThread :: errorFunc ( ) ; } haveDisplayedInfo [ i ] = TRUE ; } } } while ( stillRunning ) ; assertSuccess ( " finalizing ▁ ThreadSafeFormat " , threadSafeErr , TRUE ) ; } # endif # if ! UCONFIG_NO_COLLATION # define kCollatorThreadThreads 10 # define kCollatorThreadPatience kCollatorThreadThreads * 30 struct Line { UChar buff [ 25 ] ; int32_t buflen ; } ; static UBool skipLineBecauseOfBug ( const UChar * s , int32_t length ) { if ( length >= 3 && ( s [ 0 ] == 0xfb2 || s [ 0 ] == 0xfb3 ) && s [ 1 ] == 0x334 && ( s [ 2 ] == 0xf73 || s [ 2 ] == 0xf75 || s [ 2 ] == 0xf81 ) ) { return TRUE ; } return FALSE ; } static UCollationResult normalizeResult ( int32_t result ) { return result < 0 ? UCOL_LESS : result == 0 ? UCOL_EQUAL : UCOL_GREATER ; } class CollatorThreadTest : public ThreadWithStatus { private : const Collator * coll ; const Line * lines ; int32_t noLines ; UBool isAtLeastUCA62 ; public : CollatorThreadTest ( ) : ThreadWithStatus ( ) , coll ( NULL ) , lines ( NULL ) , noLines ( 0 ) , isAtLeastUCA62 ( TRUE ) { } ; void setCollator ( Collator * c , Line * l , int32_t nl , UBool atLeastUCA62 ) { coll = c ; lines = l ; noLines = nl ; isAtLeastUCA62 = atLeastUCA62 ; } virtual void run ( ) { uint8_t sk1 [ 1024 ] , sk2 [ 1024 ] ; uint8_t * oldSk = NULL , * newSk = sk1 ; int32_t oldLen = 0 ; int32_t prev = 0 ; int32_t i = 0 ; for ( i = 0 ; i < noLines ; i ++ ) { if ( lines [ i ] . buflen == 0 ) { continue ; } if ( skipLineBecauseOfBug ( lines [ i ] . buff , lines [ i ] . buflen ) ) { continue ; } int32_t resLen = coll -> getSortKey ( lines [ i ] . buff , lines [ i ] . buflen , newSk , 1024 ) ; if ( oldSk != NULL ) { int32_t skres = strcmp ( ( char * ) oldSk , ( char * ) newSk ) ; int32_t cmpres = coll -> compare ( lines [ prev ] . buff , lines [ prev ] . buflen , lines [ i ] . buff , lines [ i ] . buflen ) ; int32_t cmpres2 = coll -> compare ( lines [ i ] . buff , lines [ i ] . buflen , lines [ prev ] . buff , lines [ prev ] . buflen ) ; if ( cmpres != - cmpres2 ) { error ( UnicodeString ( " Compare ▁ result ▁ not ▁ symmetrical ▁ on ▁ line ▁ " ) + ( i + 1 ) ) ; break ; } if ( cmpres != normalizeResult ( skres ) ) { error ( UnicodeString ( " Difference ▁ between ▁ coll - > compare ▁ and ▁ sortkey ▁ compare ▁ on ▁ line ▁ " ) + ( i + 1 ) ) ; break ; } int32_t res = cmpres ; if ( res == 0 && ! isAtLeastUCA62 ) { res = u_strcmpCodePointOrder ( lines [ prev ] . buff , lines [ i ] . buff ) ; } if ( res > 0 ) { error ( UnicodeString ( " Line ▁ is ▁ not ▁ greater ▁ or ▁ equal ▁ than ▁ previous ▁ line , ▁ for ▁ line ▁ " ) + ( i + 1 ) ) ; break ; } } oldSk = newSk ; oldLen = resLen ; ( void ) oldLen ; prev = i ; newSk = ( newSk == sk1 ) ? sk2 : sk1 ; } } } ; void MultithreadTest :: TestCollators ( ) { UErrorCode status = U_ZERO_ERROR ; FILE * testFile = NULL ; char testDataPath [ 1024 ] ; strcpy ( testDataPath , IntlTest :: getSourceTestData ( status ) ) ; if ( U_FAILURE ( status ) ) { errln ( " ERROR : ▁ could ▁ not ▁ open ▁ test ▁ data ▁ % s " , u_errorName ( status ) ) ; return ; } strcat ( testDataPath , " CollationTest _ " ) ; const char * type = " NON _ IGNORABLE " ; const char * ext = " . txt " ; if ( testFile ) { fclose ( testFile ) ; } char buffer [ 1024 ] ; strcpy ( buffer , testDataPath ) ; strcat ( buffer , type ) ; size_t bufLen = strlen ( buffer ) ; strcpy ( buffer + bufLen , ext ) ; testFile = fopen ( buffer , " rb " ) ; if ( testFile == 0 ) { strcpy ( buffer + bufLen , " _ SHORT " ) ; strcat ( buffer , ext ) ; testFile = fopen ( buffer , " rb " ) ; if ( testFile == 0 ) { strcpy ( buffer + bufLen , " _ STUB " ) ; strcat ( buffer , ext ) ; testFile = fopen ( buffer , " rb " ) ; if ( testFile == 0 ) { * ( buffer + bufLen ) = 0 ; dataerrln ( " could ▁ not ▁ open ▁ any ▁ of ▁ the ▁ conformance ▁ test ▁ files , ▁ tried ▁ opening ▁ base ▁ % s " , buffer ) ; return ; } else { infoln ( " INFO : ▁ Working ▁ with ▁ the ▁ stub ▁ file . \n " " If ▁ you ▁ need ▁ the ▁ full ▁ conformance ▁ test , ▁ please \n " " download ▁ the ▁ appropriate ▁ data ▁ files ▁ from : \n " " http : // source . icu - project . org / repos / icu / tools / trunk / unicodetools / com / ibm / text / data / " ) ; } } } LocalArray < Line > lines ( new Line [ 200000 ] ) ; memset ( lines . getAlias ( ) , 0 , sizeof ( Line ) * 200000 ) ; int32_t lineNum = 0 ; UChar bufferU [ 1024 ] ; uint32_t first = 0 ; while ( fgets ( buffer , 1024 , testFile ) != NULL ) { if ( * buffer == 0 || buffer [ 0 ] == ' # ' ) { lines [ lineNum ] . buflen = 0 ; lines [ lineNum ] . buff [ 0 ] = 0 ; } else { int32_t buflen = u_parseString ( buffer , bufferU , 1024 , & first , & status ) ; lines [ lineNum ] . buflen = buflen ; u_memcpy ( lines [ lineNum ] . buff , bufferU , buflen ) ; lines [ lineNum ] . buff [ buflen ] = 0 ; } lineNum ++ ; } fclose ( testFile ) ; if ( U_FAILURE ( status ) ) { dataerrln ( " Couldn ' t ▁ read ▁ the ▁ test ▁ file ! " ) ; return ; } UVersionInfo uniVersion ; static const UVersionInfo v62 = { 6 , 2 , 0 , 0 } ; u_getUnicodeVersion ( uniVersion ) ; UBool isAtLeastUCA62 = uprv_memcmp ( uniVersion , v62 , 4 ) >= 0 ; LocalPointer < Collator > coll ( Collator :: createInstance ( Locale :: getRoot ( ) , status ) ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " Couldn ' t ▁ open ▁ UCA ▁ collator " ) ; return ; } coll -> setAttribute ( UCOL_NORMALIZATION_MODE , UCOL_ON , status ) ; coll -> setAttribute ( UCOL_CASE_FIRST , UCOL_OFF , status ) ; coll -> setAttribute ( UCOL_CASE_LEVEL , UCOL_OFF , status ) ; coll -> setAttribute ( UCOL_STRENGTH , isAtLeastUCA62 ? UCOL_IDENTICAL : UCOL_TERTIARY , status ) ; coll -> setAttribute ( UCOL_ALTERNATE_HANDLING , UCOL_NON_IGNORABLE , status ) ; int32_t noSpawned = 0 ; int32_t spawnResult = 0 ; LocalArray < CollatorThreadTest > tests ( new CollatorThreadTest [ kCollatorThreadThreads ] ) ; logln ( UnicodeString ( " Spawning : ▁ " ) + kCollatorThreadThreads + " ▁ threads ▁ * ▁ " + kFormatThreadIterations + " ▁ iterations ▁ each . " ) ; int32_t j = 0 ; for ( j = 0 ; j < kCollatorThreadThreads ; j ++ ) { tests [ j ] . setCollator ( coll . getAlias ( ) , lines . getAlias ( ) , lineNum , isAtLeastUCA62 ) ; } for ( j = 0 ; j < kCollatorThreadThreads ; j ++ ) { log ( " % i ▁ " , j ) ; spawnResult = tests [ j ] . start ( ) ; if ( spawnResult != 0 ) { infoln ( " THREAD ▁ INFO : ▁ Couldn ' t ▁ spawn ▁ more ▁ than ▁ % i ▁ threads " , noSpawned ) ; break ; } noSpawned ++ ; } logln ( " Spawned ▁ all " ) ; if ( noSpawned == 0 ) { errln ( " No ▁ threads ▁ could ▁ be ▁ spawned . " ) ; return ; } for ( int32_t patience = kCollatorThreadPatience ; patience > 0 ; patience -- ) { logln ( " Waiting . . . " ) ; int32_t i ; int32_t terrs = 0 ; int32_t completed = 0 ; for ( i = 0 ; i < kCollatorThreadThreads ; i ++ ) { if ( tests [ i ] . isRunning ( ) == FALSE ) { completed ++ ; UnicodeString theErr ; if ( tests [ i ] . getError ( theErr ) ) { terrs ++ ; errln ( UnicodeString ( " # " ) + i + " : ▁ " + theErr ) ; } } } logln ( " Completed ▁ % i ▁ tests " , completed ) ; if ( completed == noSpawned ) { logln ( " Done ! ▁ All ▁ % i ▁ tests ▁ are ▁ finished " , noSpawned ) ; if ( terrs ) { errln ( " There ▁ were ▁ errors . " ) ; SimpleThread :: errorFunc ( ) ; } return ; } SimpleThread :: sleep ( 900 ) ; } errln ( " patience ▁ exceeded . ▁ " ) ; SimpleThread :: errorFunc ( ) ; } # endif const int kStringThreadIterations = 2500 ; const int kStringThreadThreads = 10 ; const int kStringThreadPatience = 120 ; class StringThreadTest2 : public ThreadWithStatus { public : int fNum ; int fTraceInfo ; const UnicodeString * fSharedString ; StringThreadTest2 ( const UnicodeString * sharedString , int num ) : ThreadWithStatus ( ) , fNum ( num ) , fTraceInfo ( 0 ) , fSharedString ( sharedString ) { } ; virtual void run ( ) { fTraceInfo = 1 ; int loopCount = 0 ; for ( loopCount = 0 ; loopCount < kStringThreadIterations ; loopCount ++ ) { if ( * fSharedString != " This ▁ is ▁ the ▁ original ▁ test ▁ string . " ) { error ( " Original ▁ string ▁ is ▁ corrupt . " ) ; break ; } UnicodeString s1 = * fSharedString ; s1 += " cat ▁ this " ; UnicodeString s2 ( s1 ) ; UnicodeString s3 = * fSharedString ; s2 = s3 ; s3 . truncate ( 12 ) ; s2 . truncate ( 0 ) ; } fTraceInfo = 2 ; } } ; void MultithreadTest :: TestString ( ) { int patience ; int terrs = 0 ; int j ; UnicodeString * testString = new UnicodeString ( " This ▁ is ▁ the ▁ original ▁ test ▁ string . " ) ; StringThreadTest2 * tests [ kStringThreadThreads ] ; for ( j = 0 ; j < kStringThreadThreads ; j ++ ) { tests [ j ] = new StringThreadTest2 ( testString , j ) ; } logln ( UnicodeString ( " Spawning : ▁ " ) + kStringThreadThreads + " ▁ threads ▁ * ▁ " + kStringThreadIterations + " ▁ iterations ▁ each . " ) ; for ( j = 0 ; j < kStringThreadThreads ; j ++ ) { int32_t threadStatus = tests [ j ] -> start ( ) ; if ( threadStatus != 0 ) { errln ( " System ▁ Error ▁ % d ▁ starting ▁ thread ▁ number ▁ % d . " , threadStatus , j ) ; SimpleThread :: errorFunc ( ) ; goto cleanupAndReturn ; } } for ( patience = kStringThreadPatience ; patience > 0 ; patience -- ) { logln ( " Waiting . . . " ) ; int32_t i ; terrs = 0 ; int32_t completed = 0 ; for ( i = 0 ; i < kStringThreadThreads ; i ++ ) { if ( tests [ i ] -> isRunning ( ) == FALSE ) { completed ++ ; logln ( UnicodeString ( " Test ▁ # " ) + i + " ▁ is ▁ complete . . ▁ " ) ; UnicodeString theErr ; if ( tests [ i ] -> getError ( theErr ) ) { terrs ++ ; errln ( UnicodeString ( " # " ) + i + " : ▁ " + theErr ) ; } } } if ( completed == kStringThreadThreads ) { logln ( " Done ! " ) ; if ( terrs ) { errln ( " There ▁ were ▁ errors . " ) ; } break ; } SimpleThread :: sleep ( 900 ) ; } if ( patience <= 0 ) { errln ( " patience ▁ exceeded . ▁ " ) ; terrs ++ ; } if ( terrs > 0 ) { SimpleThread :: errorFunc ( ) ; } cleanupAndReturn : if ( terrs == 0 ) { for ( j = 0 ; j < kStringThreadThreads ; j ++ ) { delete tests [ j ] ; } delete testString ; } } # if ! UCONFIG_NO_TRANSLITERATION class TxThread : public SimpleThread { private : Transliterator * fSharedTranslit ; public : UBool fSuccess ; TxThread ( Transliterator * tx ) : fSharedTranslit ( tx ) , fSuccess ( FALSE ) { } ; ~ TxThread ( ) ; void run ( ) ; } ; TxThread :: ~ TxThread ( ) { } void TxThread :: run ( ) { UnicodeString greekString ( " \\u03B4\\u03B9\\u03B1\\u03C6\\u03BF\\u03C1\\u03B5\\u03C4\\u03B9\\u03BA\\u03BF\\u03CD\\u03C2" ) ; greekString = greekString . unescape ( ) ; fSharedTranslit -> transliterate ( greekString ) ; fSuccess = greekString [ 0 ] == 0x64 ; } # endif void MultithreadTest :: TestAnyTranslit ( ) { # if ! UCONFIG_NO_TRANSLITERATION UErrorCode status = U_ZERO_ERROR ; LocalPointer < Transliterator > tx ( Transliterator :: createInstance ( " Any - Latin " , UTRANS_FORWARD , status ) ) ; if ( U_FAILURE ( status ) ) { dataerrln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ status ▁ = ▁ % s " , __FILE__ , __LINE__ , u_errorName ( status ) ) ; return ; } TxThread * threads [ 4 ] ; int32_t i ; for ( i = 0 ; i < 4 ; i ++ ) { threads [ i ] = new TxThread ( tx . getAlias ( ) ) ; } for ( i = 0 ; i < 4 ; i ++ ) { threads [ i ] -> start ( ) ; } int32_t patience = 100 ; UBool success ; UBool someThreadRunning ; do { someThreadRunning = FALSE ; success = TRUE ; for ( i = 0 ; i < 4 ; i ++ ) { if ( threads [ i ] -> isRunning ( ) ) { someThreadRunning = TRUE ; SimpleThread :: sleep ( 10 ) ; break ; } else { if ( threads [ i ] -> fSuccess == FALSE ) { success = FALSE ; } } } } while ( someThreadRunning && -- patience > 0 ) ; if ( patience <= 0 ) { errln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ one ▁ or ▁ more ▁ threads ▁ did ▁ not ▁ complete . " , __FILE__ , __LINE__ ) ; } if ( success == FALSE ) { errln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ transliteration ▁ result ▁ incorrect . " , __FILE__ , __LINE__ ) ; } for ( i = 0 ; i < 4 ; i ++ ) { delete threads [ i ] ; } # endif } class CondThread : public SimpleThread { public : CondThread ( ) : fFinished ( false ) { } ; ~ CondThread ( ) { } ; void run ( ) ; bool fFinished ; } ; static UMutex gCTMutex = U_MUTEX_INITIALIZER ; static UConditionVar gCTConditionVar = U_CONDITION_INITIALIZER ; int gConditionTestOne = 1 ; int gStartedThreads ; int gFinishedThreads ; static const int NUMTHREADS = 10 ; static MultithreadTest * gThisTest = NULL ; void CondThread :: run ( ) { umtx_lock ( & gCTMutex ) ; gStartedThreads += gConditionTestOne ; umtx_condBroadcast ( & gCTConditionVar ) ; while ( gStartedThreads < NUMTHREADS ) { if ( gFinishedThreads != 0 ) { gThisTest -> errln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ gStartedThreads ▁ = ▁ % d , ▁ gFinishedThreads ▁ = ▁ % d " , __FILE__ , __LINE__ , gStartedThreads , gFinishedThreads ) ; } umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } gFinishedThreads += gConditionTestOne ; fFinished = true ; umtx_condBroadcast ( & gCTConditionVar ) ; while ( gFinishedThreads < NUMTHREADS ) { umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } umtx_unlock ( & gCTMutex ) ; } void MultithreadTest :: TestConditionVariables ( ) { gThisTest = this ; gStartedThreads = 0 ; gFinishedThreads = 0 ; int i ; umtx_lock ( & gCTMutex ) ; CondThread * threads [ NUMTHREADS ] ; for ( i = 0 ; i < NUMTHREADS ; ++ i ) { threads [ i ] = new CondThread ; threads [ i ] -> start ( ) ; } while ( gStartedThreads < NUMTHREADS ) { umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } while ( gFinishedThreads < NUMTHREADS ) { umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } umtx_unlock ( & gCTMutex ) ; for ( i = 0 ; i < NUMTHREADS ; ++ i ) { if ( ! threads [ i ] -> fFinished ) { errln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ threads [ % d ] - > fFinished ▁ = = ▁ false " , __FILE__ , __LINE__ , i ) ; } delete threads [ i ] ; } } static const char * gCacheLocales [ ] = { " en _ US " , " en _ GB " , " fr _ FR " , " fr " } ; static int32_t gObjectsCreated = 0 ; static const int32_t CACHE_LOAD = 3 ; class UCTMultiThreadItem : public SharedObject { public : char * value ; UCTMultiThreadItem ( const char * x ) : value ( NULL ) { value = uprv_strdup ( x ) ; } virtual ~ UCTMultiThreadItem ( ) { uprv_free ( value ) ; } } ; U_NAMESPACE_BEGIN template < > U_EXPORT const UCTMultiThreadItem * LocaleCacheKey < UCTMultiThreadItem > :: createObject ( const void * , UErrorCode & ) const { umtx_lock ( & gCTMutex ) ; if ( gObjectsCreated != 0 ) { gThisTest -> errln ( " Expected ▁ no ▁ objects ▁ to ▁ be ▁ created ▁ yet . " ) ; } umtx_unlock ( & gCTMutex ) ; SimpleThread :: sleep ( 1000 ) ; umtx_lock ( & gCTMutex ) ; ++ gObjectsCreated ; umtx_unlock ( & gCTMutex ) ; UCTMultiThreadItem * result = new UCTMultiThreadItem ( fLoc . getName ( ) ) ; result -> addRef ( ) ; return result ; } U_NAMESPACE_END class UnifiedCacheThread : public SimpleThread { public : UnifiedCacheThread ( const char * loc ) : fLoc ( loc ) { } ; ~ UnifiedCacheThread ( ) { } ; void run ( ) ; const char * fLoc ; } ; void UnifiedCacheThread :: run ( ) { UErrorCode status = U_ZERO_ERROR ; const UnifiedCache * cache = UnifiedCache :: getInstance ( status ) ; U_ASSERT ( status == U_ZERO_ERROR ) ; const UCTMultiThreadItem * item = NULL ; cache -> get ( LocaleCacheKey < UCTMultiThreadItem > ( fLoc ) , item , status ) ; U_ASSERT ( item != NULL ) ; if ( uprv_strcmp ( fLoc , item -> value ) ) { gThisTest -> errln ( " Expected ▁ % s , ▁ got ▁ % s " , fLoc , item -> value ) ; } item -> removeRef ( ) ; umtx_lock ( & gCTMutex ) ; ++ gFinishedThreads ; umtx_condBroadcast ( & gCTConditionVar ) ; umtx_unlock ( & gCTMutex ) ; } void MultithreadTest :: TestUnifiedCache ( ) { UErrorCode status = U_ZERO_ERROR ; const UnifiedCache * cache = UnifiedCache :: getInstance ( status ) ; U_ASSERT ( cache != NULL ) ; cache -> flush ( ) ; gThisTest = this ; gFinishedThreads = 0 ; gObjectsCreated = 0 ; UnifiedCacheThread * threads [ CACHE_LOAD ] [ UPRV_LENGTHOF ( gCacheLocales ) ] ; for ( int32_t i = 0 ; i < CACHE_LOAD ; ++ i ) { for ( int32_t j = 0 ; j < UPRV_LENGTHOF ( gCacheLocales ) ; ++ j ) { threads [ i ] [ j ] = new UnifiedCacheThread ( gCacheLocales [ j ] ) ; threads [ i ] [ j ] -> start ( ) ; } } umtx_lock ( & gCTMutex ) ; while ( gFinishedThreads < CACHE_LOAD * UPRV_LENGTHOF ( gCacheLocales ) ) { umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } assertEquals ( " Objects ▁ created " , UPRV_LENGTHOF ( gCacheLocales ) , gObjectsCreated ) ; umtx_unlock ( & gCTMutex ) ; for ( int32_t i = 0 ; i < CACHE_LOAD ; ++ i ) { for ( int32_t j = 0 ; j < UPRV_LENGTHOF ( gCacheLocales ) ; ++ j ) { delete threads [ i ] [ j ] ; } } } # endif </DOCUMENT>
<DOCUMENT_ID="MazZzinatus/storm/tree/master/src/test/storm-pars/utility/ModelInstantiatorTest.cpp"> # include " gtest / gtest . h " # include " storm - config . h " # ifdef STORM_HAVE_CARL # include " storm / adapters / RationalFunctionAdapter . h " # include < carl / numbers / numbers . h > # include < carl / core / VariablePool . h > # include " storm / settings / SettingsManager . h " # include " storm / settings / modules / GeneralSettings . h " # include " storm - pars / utility / ModelInstantiator . h " # include " storm / api / storm . h " # include " storm / models / sparse / Model . h " # include " storm / models / sparse / Dtmc . h " # include " storm / models / sparse / Mdp . h " TEST ( ModelInstantiatorTest , BrpProb ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pdtmc / brp16_2 . pm " ; std :: string formulaAsString = " P = ? ▁ [ F ▁ s = 5 ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> dtmc = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Dtmc < storm :: RationalFunction > , storm :: models :: sparse :: Dtmc < double >> modelInstantiator ( * dtmc ) ; EXPECT_FALSE ( dtmc -> hasRewardModel ( ) ) ; { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.8 ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.2989278941 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_EQ ( 0.0 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] ) ; } { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.01588055832 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } } TEST ( ModelInstantiatorTest , Brp_Rew ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pdtmc / brp16_2 . pm " ; std :: string formulaAsString = " R = ? ▁ [ F ▁ ( ( s = 5 ) ▁ | ▁ ( s = 0 & srep = 3 ) ) ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> dtmc = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Dtmc < storm :: RationalFunction > , storm :: models :: sparse :: Dtmc < double >> modelInstantiator ( * dtmc ) ; { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & TOMsg = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " TOMsg " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & TOAck = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " TOAck " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.3 ) ) ) ; valuation . insert ( std :: make_pair ( TOMsg , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.3 ) ) ) ; valuation . insert ( std :: make_pair ( TOAck , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.5 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } ASSERT_TRUE ( instantiated . hasUniqueRewardModel ( ) ) ; EXPECT_FALSE ( instantiated . getUniqueRewardModel ( ) . hasStateRewards ( ) ) ; EXPECT_FALSE ( instantiated . getUniqueRewardModel ( ) . hasTransitionRewards ( ) ) ; EXPECT_TRUE ( instantiated . getUniqueRewardModel ( ) . hasStateActionRewards ( ) ) ; ASSERT_TRUE ( dtmc -> getUniqueRewardModel ( ) . hasStateActionRewards ( ) ) ; std :: size_t stateActionEntries = dtmc -> getUniqueRewardModel ( ) . getStateActionRewardVector ( ) . size ( ) ; ASSERT_EQ ( stateActionEntries , instantiated . getUniqueRewardModel ( ) . getStateActionRewardVector ( ) . size ( ) ) ; for ( std :: size_t i = 0 ; i < stateActionEntries ; ++ i ) { double evaluatedValue = carl :: toDouble ( dtmc -> getUniqueRewardModel ( ) . getStateActionRewardVector ( ) [ i ] . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiated . getUniqueRewardModel ( ) . getStateActionRewardVector ( ) [ i ] ) ; } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 1.308324495 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } } TEST ( ModelInstantiatorTest , Consensus ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pmdp / coin2_2 . nm " ; std :: string formulaAsString = " Pmin = ? ▁ [ F ▁ \ " finished\ " & \ " all _ coins _ equal _ 1\ " ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Mdp < storm :: RationalFunction >> mdp = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Mdp < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Mdp < storm :: RationalFunction > , storm :: models :: sparse :: Mdp < double >> modelInstantiator ( * mdp ) ; std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & p1 = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " p1" ) ; ASSERT_NE ( p1 , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & p2 = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " p2" ) ; ASSERT_NE ( p2 , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( p1 , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.51 ) ) ) ; valuation . insert ( std :: make_pair ( p2 , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.49 ) ) ) ; storm :: models :: sparse :: Mdp < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < mdp -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : mdp -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( mdp -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( mdp -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseMdpPrctlModelChecker < storm :: models :: sparse :: Mdp < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.3526577219 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } # endif </DOCUMENT>
<DOCUMENT_ID="pmprog/TugOfWar/tree/master/Game/gamelobbystage.cpp"> # include " gamelobbystage . h " # include " menu . h " # include " input . h " # include " gamelobby _ addlocal . h " # include " gamestage . h " GameLobbyStage :: GameLobbyStage ( ) { networkconnection = nullptr ; currentinfo = new GameInfo ( true ) ; selection = 0 ; selectionteamisblue = true ; } GameLobbyStage :: GameLobbyStage ( Network * Connection ) { selection = 0 ; networkconnection = Connection ; currentinfo = new GameInfo ( Connection -> IsServer ( ) ) ; if ( ! Connection -> IsServer ( ) ) { } } void GameLobbyStage :: Begin ( ) { optionfont = FontCache :: LoadFont ( " resources / armalite . ttf " , 32 ) ; helpfont = FontCache :: LoadFont ( " resources / armalite . ttf " , 16 ) ; } void GameLobbyStage :: Pause ( ) { } void GameLobbyStage :: Resume ( ) { } void GameLobbyStage :: Finish ( ) { AUDIO -> StopMusic ( ) ; if ( networkconnection != nullptr ) { delete networkconnection ; networkconnection = nullptr ; } } void GameLobbyStage :: EventOccurred ( Event * e ) { InputItems :: ItemSet inputevent = InputItems :: NONE ; if ( e -> Type == EVENT_KEY_DOWN ) { if ( e -> Data . Keyboard . KeyCode == ALLEGRO_KEY_ESCAPE ) { delete FRAMEWORK -> ProgramStages -> Pop ( ) ; return ; } inputevent = Input :: GetItemFromEvent ( e ) ; } if ( e -> Type == EVENT_JOYSTICK_BUTTON_DOWN && inputevent == InputItems :: NONE ) { inputevent = Input :: GetItemFromEvent ( e ) ; } if ( inputevent != InputItems :: NONE ) { InputEvent ( inputevent ) ; } NetworkEvent ( e ) ; } void GameLobbyStage :: InputEvent ( InputItems :: ItemSet inputevent ) { switch ( inputevent ) { case InputItems :: UP : if ( selection > 0 ) { selection -- ; } break ; case InputItems :: DOWN : if ( selection < 2 ) { selection ++ ; } break ; case InputItems :: LEFT : selectionteamisblue = true ; break ; case InputItems :: RIGHT : selectionteamisblue = false ; break ; case InputItems :: SELECT : delete FRAMEWORK -> ProgramStages -> Pop ( ) ; return ; break ; case InputItems :: X : if ( networkconnection == nullptr ) { PlayerInfo * p = nullptr ; if ( selectionteamisblue ) { if ( currentinfo -> BlueTeam [ selection ] == nullptr ) { currentinfo -> BlueTeam [ selection ] = new PlayerInfo ( " " , true , false ) ; } p = currentinfo -> BlueTeam [ selection ] ; } else { if ( currentinfo -> RedTeam [ selection ] == nullptr ) { currentinfo -> RedTeam [ selection ] = new PlayerInfo ( " " , true , false ) ; } p = currentinfo -> RedTeam [ selection ] ; } p -> BlueTeam = selectionteamisblue ; p -> TeamIndex = selection ; p -> GameData = currentinfo ; FRAMEWORK -> ProgramStages -> Push ( new GameLobbyAddLocalStage ( p ) ) ; } break ; case InputItems :: B : if ( networkconnection == nullptr ) { PlayerInfo * p = nullptr ; if ( selectionteamisblue ) { if ( currentinfo -> BlueTeam [ selection ] == nullptr ) { p = new PlayerInfo ( " CPU " , true , true ) ; currentinfo -> BlueTeam [ selection ] = p ; } } else { if ( currentinfo -> RedTeam [ selection ] == nullptr ) { p = new PlayerInfo ( " CPU " , true , true ) ; currentinfo -> RedTeam [ selection ] = p ; } } if ( p != nullptr ) { p -> BlueTeam = selectionteamisblue ; p -> TeamIndex = selection ; p -> GameData = currentinfo ; } } break ; case InputItems :: Y : if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { PlayerInfo * p = nullptr ; if ( selectionteamisblue ) { p = currentinfo -> BlueTeam [ selection ] ; currentinfo -> BlueTeam [ selection ] = nullptr ; } else { p = currentinfo -> RedTeam [ selection ] ; currentinfo -> RedTeam [ selection ] = nullptr ; } if ( p != nullptr ) { if ( ! p -> Local ) { } delete p ; } } break ; case InputItems :: START : if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { GameStage * g = new GameStage ( currentinfo ) ; delete FRAMEWORK -> ProgramStages -> Pop ( ) ; FRAMEWORK -> ProgramStages -> Push ( g ) ; } break ; } } void GameLobbyStage :: NetworkEvent ( Event * e ) { if ( e -> Type == EVENT_NETWORK_CONNECTION_REQUEST ) { bool freeslot = false ; for ( int i = 0 ; i < 3 ; i ++ ) { freeslot = ( currentinfo -> BlueTeam [ i ] == nullptr ? true : freeslot ) ; freeslot = ( currentinfo -> RedTeam [ i ] == nullptr ? true : freeslot ) ; } if ( freeslot ) { } } if ( e -> Type == EVENT_NETWORK_CONNECTED ) { } if ( e -> Type == EVENT_NETWORK_DISCONNECTED ) { } if ( e -> Type == EVENT_NETWORK_PACKET_RECEIVED ) { } } void GameLobbyStage :: Update ( ) { } void GameLobbyStage :: Render ( ) { al_clear_to_color ( al_map_rgb ( 255 , 220 , 128 ) ) ; optionfont -> DrawString ( ( DISPLAY -> GetWidth ( ) / 2 ) + 2 , 12 , " Lobby " , FontHAlign :: CENTRE , al_map_rgb ( 0 , 0 , 0 ) ) ; optionfont -> DrawString ( ( DISPLAY -> GetWidth ( ) / 2 ) , 10 , " Lobby " , FontHAlign :: CENTRE , al_map_rgb ( 255 , 255 , 0 ) ) ; GameResources :: DrawPanel ( GameResources :: BluePanel , 5 , 80 , 13 , 8 , 8 ) ; optionfont -> DrawString ( 15 , 85 , " Blue ▁ Team " , FontHAlign :: LEFT , al_map_rgb ( 255 , 255 , 255 ) ) ; RenderPlayerSlot ( true , 0 , 15 , 140 ) ; RenderPlayerSlot ( true , 1 , 15 , 192 ) ; RenderPlayerSlot ( true , 2 , 15 , 244 ) ; GameResources :: DrawPanel ( GameResources :: RedPanel , 405 , 80 , 13 , 8 , 8 ) ; optionfont -> DrawString ( 415 , 85 , " Red ▁ Team " , FontHAlign :: LEFT , al_map_rgb ( 255 , 255 , 255 ) ) ; RenderPlayerSlot ( false , 0 , 415 , 140 ) ; RenderPlayerSlot ( false , 1 , 415 , 192 ) ; RenderPlayerSlot ( false , 2 , 415 , 244 ) ; int textoff = ( 50 - helpfont -> GetFontHeight ( ) ) / 2 ; if ( networkconnection == nullptr ) { al_draw_bitmap ( Input :: GetIcon ( InputItems :: X ) , 10 , 320 , 0 ) ; helpfont -> DrawString ( 64 , 320 + textoff , " Add ▁ Local ▁ Player " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; al_draw_bitmap ( Input :: GetIcon ( InputItems :: B ) , 10 , 370 , 0 ) ; helpfont -> DrawString ( 64 , 370 + textoff , " Add ▁ CPU ▁ Player " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; } if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { al_draw_bitmap ( Input :: GetIcon ( InputItems :: Y ) , 10 , 420 , 0 ) ; helpfont -> DrawString ( 64 , 420 + textoff , " Kick ▁ Player " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; al_draw_bitmap ( Input :: GetIcon ( InputItems :: START ) , 500 , 370 , 0 ) ; helpfont -> DrawString ( 554 , 370 + textoff , " Start " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; } al_draw_bitmap ( Input :: GetIcon ( InputItems :: SELECT ) , 500 , 420 , 0 ) ; helpfont -> DrawString ( 554 , 420 + textoff , " Quit " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; } bool GameLobbyStage :: IsTransition ( ) { return false ; } void GameLobbyStage :: RenderPlayerSlot ( bool BlueTeam , int Index , int X , int Y ) { ButtonColours :: Colours colour = ButtonColours :: WHITE ; bool btnup = false ; PlayerInfo * p = ( BlueTeam ? currentinfo -> BlueTeam [ Index ] : currentinfo -> RedTeam [ Index ] ) ; if ( p != nullptr ) { colour = ( BlueTeam ? ButtonColours :: BLUE : ButtonColours :: RED ) ; } if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { if ( selection == Index && selectionteamisblue == BlueTeam ) { colour = ButtonColours :: YELLOW ; btnup = true ; } } GameResources :: DrawButton ( colour , btnup , X , Y , 23 , 3 ) ; if ( p != nullptr ) { helpfont -> DrawString ( X + 184 , Y + 24 - ( helpfont -> GetFontHeight ( ) / 2 ) + ( ! btnup ? 4 : 0 ) , p -> Name , FontHAlign :: CENTRE , al_map_rgb ( 0 , 0 , 0 ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="braska/tdesktop/tree/master/Telegram/SourceFiles/gui/twidget.cpp"> # include " stdafx . h " # include " application . h " namespace { void _sendResizeEvents ( QWidget * target ) { QResizeEvent e ( target -> size ( ) , QSize ( ) ) ; QApplication :: sendEvent ( target , & e ) ; const QObjectList children = target -> children ( ) ; for ( int i = 0 ; i < children . size ( ) ; ++ i ) { QWidget * child = static_cast < QWidget * > ( children . at ( i ) ) ; if ( child -> isWidgetType ( ) && ! child -> isWindow ( ) && child -> testAttribute ( Qt :: WA_PendingResizeEvent ) ) { _sendResizeEvents ( child ) ; } } } } void myEnsureResized ( QWidget * target ) { if ( target && ( target -> testAttribute ( Qt :: WA_PendingResizeEvent ) || ! target -> testAttribute ( Qt :: WA_WState_Created ) ) ) { _sendResizeEvents ( target ) ; } } QPixmap myGrab ( QWidget * target , const QRect & rect ) { if ( ! cRetina ( ) ) return target -> grab ( rect ) ; myEnsureResized ( target ) ; qreal dpr = App :: app ( ) -> devicePixelRatio ( ) ; QPixmap result ( rect . size ( ) * dpr ) ; result . setDevicePixelRatio ( dpr ) ; result . fill ( Qt :: transparent ) ; target -> render ( & result , QPoint ( ) , QRegion ( rect ) , QWidget :: DrawWindowBackground | QWidget :: DrawChildren | QWidget :: IgnoreMask ) ; return result ; } </DOCUMENT>
<DOCUMENT_ID="MorcoFreeCode/2015__MorcoEngine3D/tree/master/MorcoEngine3D v0.13/Source/Libraries/glm/Include/detail/glm.cpp"> # include < glm / glm . hpp > # include < glm / gtc / quaternion . hpp > # include < glm / gtx / dual_quaternion . hpp > namespace glm { namespace detail { template struct tvec2 < uint8 , lowp > ; template struct tvec2 < uint16 , lowp > ; template struct tvec2 < uint32 , lowp > ; template struct tvec2 < uint64 , lowp > ; template struct tvec2 < int8 , lowp > ; template struct tvec2 < int16 , lowp > ; template struct tvec2 < int32 , lowp > ; template struct tvec2 < int64 , lowp > ; template struct tvec2 < float32 , lowp > ; template struct tvec2 < float64 , lowp > ; template struct tvec2 < uint8 , mediump > ; template struct tvec2 < uint16 , mediump > ; template struct tvec2 < uint32 , mediump > ; template struct tvec2 < uint64 , mediump > ; template struct tvec2 < int8 , mediump > ; template struct tvec2 < int16 , mediump > ; template struct tvec2 < int32 , mediump > ; template struct tvec2 < int64 , mediump > ; template struct tvec2 < float32 , mediump > ; template struct tvec2 < float64 , mediump > ; template struct tvec2 < uint8 , highp > ; template struct tvec2 < uint16 , highp > ; template struct tvec2 < uint32 , highp > ; template struct tvec2 < uint64 , highp > ; template struct tvec2 < int8 , highp > ; template struct tvec2 < int16 , highp > ; template struct tvec2 < int32 , highp > ; template struct tvec2 < int64 , highp > ; template struct tvec2 < float32 , highp > ; template struct tvec2 < float64 , highp > ; template struct tvec3 < uint8 , lowp > ; template struct tvec3 < uint16 , lowp > ; template struct tvec3 < uint32 , lowp > ; template struct tvec3 < uint64 , lowp > ; template struct tvec3 < int8 , lowp > ; template struct tvec3 < int16 , lowp > ; template struct tvec3 < int32 , lowp > ; template struct tvec3 < int64 , lowp > ; template struct tvec3 < float32 , lowp > ; template struct tvec3 < float64 , lowp > ; template struct tvec3 < uint8 , mediump > ; template struct tvec3 < uint16 , mediump > ; template struct tvec3 < uint32 , mediump > ; template struct tvec3 < uint64 , mediump > ; template struct tvec3 < int8 , mediump > ; template struct tvec3 < int16 , mediump > ; template struct tvec3 < int32 , mediump > ; template struct tvec3 < int64 , mediump > ; template struct tvec3 < float32 , mediump > ; template struct tvec3 < float64 , mediump > ; template struct tvec3 < uint8 , highp > ; template struct tvec3 < uint16 , highp > ; template struct tvec3 < uint32 , highp > ; template struct tvec3 < uint64 , highp > ; template struct tvec3 < int8 , highp > ; template struct tvec3 < int16 , highp > ; template struct tvec3 < int32 , highp > ; template struct tvec3 < int64 , highp > ; template struct tvec3 < float32 , highp > ; template struct tvec3 < float64 , highp > ; template struct tvec4 < uint8 , lowp > ; template struct tvec4 < uint16 , lowp > ; template struct tvec4 < uint32 , lowp > ; template struct tvec4 < uint64 , lowp > ; template struct tvec4 < int8 , lowp > ; template struct tvec4 < int16 , lowp > ; template struct tvec4 < int32 , lowp > ; template struct tvec4 < int64 , lowp > ; template struct tvec4 < float32 , lowp > ; template struct tvec4 < float64 , lowp > ; template struct tvec4 < uint8 , mediump > ; template struct tvec4 < uint16 , mediump > ; template struct tvec4 < uint32 , mediump > ; template struct tvec4 < uint64 , mediump > ; template struct tvec4 < int8 , mediump > ; template struct tvec4 < int16 , mediump > ; template struct tvec4 < int32 , mediump > ; template struct tvec4 < int64 , mediump > ; template struct tvec4 < float32 , mediump > ; template struct tvec4 < float64 , mediump > ; template struct tvec4 < uint8 , highp > ; template struct tvec4 < uint16 , highp > ; template struct tvec4 < uint32 , highp > ; template struct tvec4 < uint64 , highp > ; template struct tvec4 < int8 , highp > ; template struct tvec4 < int16 , highp > ; template struct tvec4 < int32 , highp > ; template struct tvec4 < int64 , highp > ; template struct tvec4 < float32 , highp > ; template struct tvec4 < float64 , highp > ; template struct tmat2x2 < float32 , lowp > ; template struct tmat2x2 < float64 , lowp > ; template struct tmat2x2 < float32 , mediump > ; template struct tmat2x2 < float64 , mediump > ; template struct tmat2x2 < float32 , highp > ; template struct tmat2x2 < float64 , highp > ; template struct tmat2x3 < float32 , lowp > ; template struct tmat2x3 < float64 , lowp > ; template struct tmat2x3 < float32 , mediump > ; template struct tmat2x3 < float64 , mediump > ; template struct tmat2x3 < float32 , highp > ; template struct tmat2x3 < float64 , highp > ; template struct tmat2x4 < float32 , lowp > ; template struct tmat2x4 < float64 , lowp > ; template struct tmat2x4 < float32 , mediump > ; template struct tmat2x4 < float64 , mediump > ; template struct tmat2x4 < float32 , highp > ; template struct tmat2x4 < float64 , highp > ; template struct tmat3x2 < float32 , lowp > ; template struct tmat3x2 < float64 , lowp > ; template struct tmat3x2 < float32 , mediump > ; template struct tmat3x2 < float64 , mediump > ; template struct tmat3x2 < float32 , highp > ; template struct tmat3x2 < float64 , highp > ; template struct tmat3x3 < float32 , lowp > ; template struct tmat3x3 < float64 , lowp > ; template struct tmat3x3 < float32 , mediump > ; template struct tmat3x3 < float64 , mediump > ; template struct tmat3x3 < float32 , highp > ; template struct tmat3x3 < float64 , highp > ; template struct tmat3x4 < float32 , lowp > ; template struct tmat3x4 < float64 , lowp > ; template struct tmat3x4 < float32 , mediump > ; template struct tmat3x4 < float64 , mediump > ; template struct tmat3x4 < float32 , highp > ; template struct tmat3x4 < float64 , highp > ; template struct tmat4x2 < float32 , lowp > ; template struct tmat4x2 < float64 , lowp > ; template struct tmat4x2 < float32 , mediump > ; template struct tmat4x2 < float64 , mediump > ; template struct tmat4x2 < float32 , highp > ; template struct tmat4x2 < float64 , highp > ; template struct tmat4x3 < float32 , lowp > ; template struct tmat4x3 < float64 , lowp > ; template struct tmat4x3 < float32 , mediump > ; template struct tmat4x3 < float64 , mediump > ; template struct tmat4x3 < float32 , highp > ; template struct tmat4x3 < float64 , highp > ; template struct tmat4x4 < float32 , lowp > ; template struct tmat4x4 < float64 , lowp > ; template struct tmat4x4 < float32 , mediump > ; template struct tmat4x4 < float64 , mediump > ; template struct tmat4x4 < float32 , highp > ; template struct tmat4x4 < float64 , highp > ; template struct tquat < float32 , lowp > ; template struct tquat < float64 , lowp > ; template struct tquat < float32 , mediump > ; template struct tquat < float64 , mediump > ; template struct tquat < float32 , highp > ; template struct tquat < float64 , highp > ; template struct tdualquat < float32 , lowp > ; template struct tdualquat < float64 , lowp > ; template struct tdualquat < float32 , mediump > ; template struct tdualquat < float64 , mediump > ; template struct tdualquat < float32 , highp > ; template struct tdualquat < float64 , highp > ; } } </DOCUMENT>
<DOCUMENT_ID="shadowofreality/ShadowCore/tree/master/src/server/game/Handlers/MiscHandler.cpp"> # include " Common . h " # include " Language . h " # include " DatabaseEnv . h " # include " WorldPacket . h " # include " Opcodes . h " # include " Log . h " # include " Player . h " # include " GameTime . h " # include " GossipDef . h " # include " World . h " # include " ObjectMgr . h " # include " GuildMgr . h " # include " WorldSession . h " # include " Chat . h " # include " zlib . h " # include " ObjectAccessor . h " # include " Object . h " # include " Battleground . h " # include " OutdoorPvP . h " # include " AccountMgr . h " # include " DBCEnums . h " # include " ScriptMgr . h " # include " MapManager . h " # include " GameObjectAI . h " # include " Group . h " # include " Spell . h " # include " BattlegroundMgr . h " # include " Battlefield . h " # include " BattlefieldMgr . h " # include " WhoListStorage . h " void WorldSession :: HandleRepopRequestOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ REPOP _ REQUEST ▁ Message " ) ; recvData . read_skip < uint8 > ( ) ; if ( GetPlayer ( ) -> IsAlive ( ) || GetPlayer ( ) -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_GHOST ) ) return ; if ( GetPlayer ( ) -> HasAuraType ( SPELL_AURA_PREVENT_RESURRECTION ) ) return ; if ( GetPlayer ( ) -> getDeathState ( ) == JUST_DIED ) { TC_LOG_DEBUG ( " network " , " HandleRepopRequestOpcode : ▁ got ▁ request ▁ after ▁ player ▁ % s ( % d ) ▁ was ▁ killed ▁ and ▁ before ▁ he ▁ was ▁ updated " , GetPlayer ( ) -> GetName ( ) . c_str ( ) , GetPlayer ( ) -> GetGUID ( ) . GetCounter ( ) ) ; GetPlayer ( ) -> KillPlayer ( ) ; } GetPlayer ( ) -> RemoveGhoul ( ) ; GetPlayer ( ) -> RemovePet ( NULL , PET_SAVE_NOT_IN_SLOT , true ) ; GetPlayer ( ) -> BuildPlayerRepop ( ) ; GetPlayer ( ) -> RepopAtGraveyard ( ) ; } void WorldSession :: HandleGossipSelectOptionOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ GOSSIP _ SELECT _ OPTION " ) ; uint32 gossipListId ; uint32 menuId ; ObjectGuid guid ; std :: string code = " " ; recvData >> guid >> menuId >> gossipListId ; if ( ! _player -> PlayerTalkClass -> GetGossipMenu ( ) . GetItem ( gossipListId ) ) { recvData . rfinish ( ) ; return ; } if ( _player -> PlayerTalkClass -> IsGossipOptionCoded ( gossipListId ) ) recvData >> code ; if ( _player -> PlayerTalkClass -> GetGossipMenu ( ) . GetSenderGUID ( ) != guid ) return ; Creature * unit = NULL ; GameObject * go = NULL ; if ( guid . IsCreatureOrVehicle ( ) ) { unit = GetPlayer ( ) -> GetNPCIfCanInteractWith ( guid , UNIT_NPC_FLAG_GOSSIP ) ; if ( ! unit ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ HandleGossipSelectOptionOpcode ▁ - ▁ % s ▁ not ▁ found ▁ or ▁ you ▁ can ' t ▁ interact ▁ with ▁ him . " , guid . ToString ( ) . c_str ( ) ) ; return ; } } else if ( guid . IsGameObject ( ) ) { go = _player -> GetGameObjectIfCanInteractWith ( guid ) ; if ( ! go ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ HandleGossipSelectOptionOpcode ▁ - ▁ % s ▁ not ▁ found ▁ or ▁ you ▁ can ' t ▁ interact ▁ with ▁ it . " , guid . ToString ( ) . c_str ( ) ) ; return ; } } else { TC_LOG_DEBUG ( " network " , " WORLD : ▁ HandleGossipSelectOptionOpcode ▁ - ▁ unsupported ▁ % s . " , guid . ToString ( ) . c_str ( ) ) ; return ; } if ( GetPlayer ( ) -> HasUnitState ( UNIT_STATE_DIED ) ) GetPlayer ( ) -> RemoveAurasByType ( SPELL_AURA_FEIGN_DEATH ) ; if ( ( unit && unit -> GetScriptId ( ) != unit -> LastUsedScriptID ) || ( go && go -> GetScriptId ( ) != go -> LastUsedScriptID ) ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ HandleGossipSelectOptionOpcode ▁ - ▁ Script ▁ reloaded ▁ while ▁ in ▁ use , ▁ ignoring ▁ and ▁ set ▁ new ▁ scipt ▁ id " ) ; if ( unit ) unit -> LastUsedScriptID = unit -> GetScriptId ( ) ; if ( go ) go -> LastUsedScriptID = go -> GetScriptId ( ) ; _player -> PlayerTalkClass -> SendCloseGossip ( ) ; return ; } if ( ! code . empty ( ) ) { if ( unit ) { unit -> AI ( ) -> sGossipSelectCode ( _player , menuId , gossipListId , code . c_str ( ) ) ; if ( ! sScriptMgr -> OnGossipSelectCode ( _player , unit , _player -> PlayerTalkClass -> GetGossipOptionSender ( gossipListId ) , _player -> PlayerTalkClass -> GetGossipOptionAction ( gossipListId ) , code . c_str ( ) ) ) _player -> OnGossipSelect ( unit , gossipListId , menuId ) ; } else { go -> AI ( ) -> GossipSelectCode ( _player , menuId , gossipListId , code . c_str ( ) ) ; if ( ! sScriptMgr -> OnGossipSelectCode ( _player , go , _player -> PlayerTalkClass -> GetGossipOptionSender ( gossipListId ) , _player -> PlayerTalkClass -> GetGossipOptionAction ( gossipListId ) , code . c_str ( ) ) ) _player -> OnGossipSelect ( go , gossipListId , menuId ) ; } } else { if ( unit ) { unit -> AI ( ) -> sGossipSelect ( _player , menuId , gossipListId ) ; if ( ! sScriptMgr -> OnGossipSelect ( _player , unit , _player -> PlayerTalkClass -> GetGossipOptionSender ( gossipListId ) , _player -> PlayerTalkClass -> GetGossipOptionAction ( gossipListId ) ) ) _player -> OnGossipSelect ( unit , gossipListId , menuId ) ; } else { go -> AI ( ) -> GossipSelect ( _player , menuId , gossipListId ) ; if ( ! sScriptMgr -> OnGossipSelect ( _player , go , _player -> PlayerTalkClass -> GetGossipOptionSender ( gossipListId ) , _player -> PlayerTalkClass -> GetGossipOptionAction ( gossipListId ) ) ) _player -> OnGossipSelect ( go , gossipListId , menuId ) ; } } } void WorldSession :: HandleWhoOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ WHO ▁ Message " ) ; uint32 matchCount = 0 ; uint32 levelMin , levelMax , racemask , classmask , zonesCount , strCount ; uint32 zoneids [ 10 ] ; std :: string packetPlayerName , packetGuildName ; recvData >> levelMin ; recvData >> levelMax ; recvData >> packetPlayerName ; recvData >> packetGuildName ; recvData >> racemask ; recvData >> classmask ; recvData >> zonesCount ; if ( zonesCount > 10 ) return ; for ( uint32 i = 0 ; i < zonesCount ; ++ i ) { uint32 temp ; recvData >> temp ; zoneids [ i ] = temp ; TC_LOG_DEBUG ( " network " , " Zone ▁ % u : ▁ % u " , i , zoneids [ i ] ) ; } recvData >> strCount ; if ( strCount > 4 ) return ; TC_LOG_DEBUG ( " network " , " Minlvl ▁ % u , ▁ maxlvl ▁ % u , ▁ name ▁ % s , ▁ guild ▁ % s , ▁ racemask ▁ % u , ▁ classmask ▁ % u , ▁ zones ▁ % u , ▁ strings ▁ % u " , levelMin , levelMax , packetPlayerName . c_str ( ) , packetGuildName . c_str ( ) , racemask , classmask , zonesCount , strCount ) ; std :: wstring str [ 4 ] ; for ( uint32 i = 0 ; i < strCount ; ++ i ) { std :: string temp ; recvData >> temp ; if ( ! Utf8toWStr ( temp , str [ i ] ) ) continue ; wstrToLower ( str [ i ] ) ; TC_LOG_DEBUG ( " network " , " String ▁ % u : ▁ % s " , i , temp . c_str ( ) ) ; } std :: wstring wpacketPlayerName ; std :: wstring wpacketGuildName ; if ( ! ( Utf8toWStr ( packetPlayerName , wpacketPlayerName ) && Utf8toWStr ( packetGuildName , wpacketGuildName ) ) ) return ; wstrToLower ( wpacketPlayerName ) ; wstrToLower ( wpacketGuildName ) ; if ( levelMax >= MAX_LEVEL ) levelMax = STRONG_MAX_LEVEL ; uint32 team = _player -> GetTeam ( ) ; uint32 gmLevelInWhoList = sWorld -> getIntConfig ( CONFIG_GM_LEVEL_IN_WHO_LIST ) ; uint32 displayCount = 0 ; WorldPacket data ( SMSG_WHO , 500 ) ; data << uint32 ( matchCount ) ; data << uint32 ( displayCount ) ; WhoListInfoVector const & whoList = sWhoListStorageMgr -> GetWhoList ( ) ; for ( WhoListPlayerInfo const & target : whoList ) { if ( target . GetTeam ( ) != team && ! HasPermission ( rbac :: RBAC_PERM_TWO_SIDE_WHO_LIST ) ) continue ; if ( ! HasPermission ( rbac :: RBAC_PERM_WHO_SEE_ALL_SEC_LEVELS ) && target . GetSecurity ( ) > AccountTypes ( gmLevelInWhoList ) ) continue ; if ( _player -> GetGUID ( ) != target . GetGuid ( ) && ! target . IsVisible ( ) ) if ( AccountMgr :: IsPlayerAccount ( _player -> GetSession ( ) -> GetSecurity ( ) ) || target . GetSecurity ( ) > _player -> GetSession ( ) -> GetSecurity ( ) ) continue ; uint8 lvl = target . GetLevel ( ) ; if ( lvl < levelMin || lvl > levelMax ) continue ; uint8 class_ = target . GetClass ( ) ; if ( ! ( classmask & ( 1 << class_ ) ) ) continue ; uint32 race = target . GetRace ( ) ; if ( ! ( racemask & ( 1 << race ) ) ) continue ; uint32 playerZoneId = target . GetZoneId ( ) ; uint8 gender = target . GetGender ( ) ; bool showZones = true ; for ( uint32 i = 0 ; i < zonesCount ; ++ i ) { if ( zoneids [ i ] == playerZoneId ) { showZones = true ; break ; } showZones = false ; } if ( ! showZones ) continue ; std :: wstring const & wideplayername = target . GetWidePlayerName ( ) ; if ( ! ( wpacketPlayerName . empty ( ) || wideplayername . find ( wpacketPlayerName ) != std :: wstring :: npos ) ) continue ; std :: wstring const & wideguildname = target . GetWideGuildName ( ) ; if ( ! ( wpacketGuildName . empty ( ) || wideguildname . find ( wpacketGuildName ) != std :: wstring :: npos ) ) continue ; std :: string aname ; if ( AreaTableEntry const * areaEntry = sAreaTableStore . LookupEntry ( playerZoneId ) ) aname = areaEntry -> area_name [ GetSessionDbcLocale ( ) ] ; bool s_show = true ; for ( uint32 i = 0 ; i < strCount ; ++ i ) { if ( ! str [ i ] . empty ( ) ) { if ( wideguildname . find ( str [ i ] ) != std :: wstring :: npos || wideplayername . find ( str [ i ] ) != std :: wstring :: npos || Utf8FitTo ( aname , str [ i ] ) ) { s_show = true ; break ; } s_show = false ; } } if ( ! s_show ) continue ; if ( ( matchCount ++ ) >= sWorld -> getIntConfig ( CONFIG_MAX_WHO ) ) continue ; data << target . GetPlayerName ( ) ; data << target . GetGuildName ( ) ; data << uint32 ( lvl ) ; data << uint32 ( class_ ) ; data << uint32 ( race ) ; data << uint8 ( gender ) ; data << uint32 ( playerZoneId ) ; ++ displayCount ; } data . put ( 0 , displayCount ) ; data . put ( 4 , matchCount ) ; SendPacket ( & data ) ; TC_LOG_DEBUG ( " network " , " WORLD : ▁ Send ▁ SMSG _ WHO ▁ Message " ) ; } void WorldSession :: HandleLogoutRequestOpcode ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ LOGOUT _ REQUEST ▁ Message , ▁ security ▁ - ▁ % u " , GetSecurity ( ) ) ; if ( ObjectGuid lguid = GetPlayer ( ) -> GetLootGUID ( ) ) DoLootRelease ( lguid ) ; bool instantLogout = ( GetPlayer ( ) -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_RESTING ) && ! GetPlayer ( ) -> IsInCombat ( ) ) || GetPlayer ( ) -> IsInFlight ( ) || HasPermission ( rbac :: RBAC_PERM_INSTANT_LOGOUT ) ; bool canLogoutInCombat = GetPlayer ( ) -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_RESTING ) ; uint32 reason = 0 ; if ( GetPlayer ( ) -> IsInCombat ( ) && ! canLogoutInCombat ) reason = 1 ; else if ( GetPlayer ( ) -> m_movementInfo . HasMovementFlag ( MOVEMENTFLAG_FALLING | MOVEMENTFLAG_FALLING_FAR ) ) reason = 3 ; else if ( GetPlayer ( ) -> duel || GetPlayer ( ) -> HasAura ( 9454 ) ) reason = 2 ; WorldPacket data ( SMSG_LOGOUT_RESPONSE , 1 + 4 ) ; data << uint32 ( reason ) ; data << uint8 ( instantLogout ) ; SendPacket ( & data ) ; if ( reason ) { LogoutRequest ( 0 ) ; return ; } if ( instantLogout ) { LogoutPlayer ( true ) ; return ; } if ( GetPlayer ( ) -> CanFreeMove ( ) ) { if ( GetPlayer ( ) -> GetStandState ( ) == UNIT_STAND_STATE_STAND ) GetPlayer ( ) -> SetStandState ( UNIT_STAND_STATE_SIT ) ; WorldPacket data ( SMSG_FORCE_MOVE_ROOT , ( 8 + 4 ) ) ; data << GetPlayer ( ) -> GetPackGUID ( ) ; data << ( uint32 ) 2 ; SendPacket ( & data ) ; GetPlayer ( ) -> SetFlag ( UNIT_FIELD_FLAGS , UNIT_FLAG_STUNNED ) ; } LogoutRequest ( time ( NULL ) ) ; } void WorldSession :: HandlePlayerLogoutOpcode ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ PLAYER _ LOGOUT ▁ Message " ) ; } void WorldSession :: HandleLogoutCancelOpcode ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ LOGOUT _ CANCEL ▁ Message " ) ; if ( ! GetPlayer ( ) ) return ; LogoutRequest ( 0 ) ; WorldPacket data ( SMSG_LOGOUT_CANCEL_ACK , 0 ) ; SendPacket ( & data ) ; if ( GetPlayer ( ) -> CanFreeMove ( ) ) { data . Initialize ( SMSG_FORCE_MOVE_UNROOT , 8 ) ; data << GetPlayer ( ) -> GetPackGUID ( ) ; data << uint32 ( 0 ) ; SendPacket ( & data ) ; GetPlayer ( ) -> SetStandState ( UNIT_STAND_STATE_STAND ) ; GetPlayer ( ) -> RemoveFlag ( UNIT_FIELD_FLAGS , UNIT_FLAG_STUNNED ) ; } } void WorldSession :: HandleTogglePvP ( WorldPacket & recvData ) { if ( recvData . size ( ) == 1 ) { bool newPvPStatus ; recvData >> newPvPStatus ; GetPlayer ( ) -> ApplyModFlag ( PLAYER_FLAGS , PLAYER_FLAGS_IN_PVP , newPvPStatus ) ; GetPlayer ( ) -> ApplyModFlag ( PLAYER_FLAGS , PLAYER_FLAGS_PVP_TIMER , ! newPvPStatus ) ; } else { GetPlayer ( ) -> ToggleFlag ( PLAYER_FLAGS , PLAYER_FLAGS_IN_PVP ) ; GetPlayer ( ) -> ToggleFlag ( PLAYER_FLAGS , PLAYER_FLAGS_PVP_TIMER ) ; } if ( GetPlayer ( ) -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_IN_PVP ) ) { if ( ! GetPlayer ( ) -> IsPvP ( ) || GetPlayer ( ) -> pvpInfo . EndTimer ) GetPlayer ( ) -> UpdatePvP ( true , true ) ; } else { if ( ! GetPlayer ( ) -> pvpInfo . IsHostile && GetPlayer ( ) -> IsPvP ( ) ) GetPlayer ( ) -> pvpInfo . EndTimer = time ( NULL ) ; } } void WorldSession :: HandleZoneUpdateOpcode ( WorldPacket & recvData ) { uint32 newZone ; recvData >> newZone ; TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ ZONE _ UPDATE : ▁ % u " , newZone ) ; GetPlayer ( ) -> SetNeedsZoneUpdate ( true ) ; } void WorldSession :: HandleSetSelectionOpcode ( WorldPacket & recvData ) { ObjectGuid guid ; recvData >> guid ; _player -> SetSelection ( guid ) ; } void WorldSession :: HandleStandStateChangeOpcode ( WorldPacket & recvData ) { uint32 animstate ; recvData >> animstate ; _player -> SetStandState ( animstate ) ; } void WorldSession :: HandleBugOpcode ( WorldPacket & recvData ) { uint32 suggestion , contentlen , typelen ; std :: string content , type ; recvData >> suggestion >> contentlen >> content ; recvData >> typelen >> type ; if ( suggestion == 0 ) TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ BUG ▁ [ Bug ▁ Report ] " ) ; else TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ BUG ▁ [ Suggestion ] " ) ; TC_LOG_DEBUG ( " network " , " % s " , type . c_str ( ) ) ; TC_LOG_DEBUG ( " network " , " % s " , content . c_str ( ) ) ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_BUG_REPORT ) ; stmt -> setString ( 0 , type ) ; stmt -> setString ( 1 , content ) ; CharacterDatabase . Execute ( stmt ) ; } void WorldSession :: HandleReclaimCorpseOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ RECLAIM _ CORPSE " ) ; ObjectGuid guid ; recvData >> guid ; if ( _player -> IsAlive ( ) ) return ; if ( _player -> InArena ( ) ) return ; if ( ! _player -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_GHOST ) ) return ; Corpse * corpse = _player -> GetCorpse ( ) ; if ( ! corpse ) return ; if ( time_t ( corpse -> GetGhostTime ( ) + _player -> GetCorpseReclaimDelay ( corpse -> GetType ( ) == CORPSE_RESURRECTABLE_PVP ) ) > time_t ( time ( NULL ) ) ) return ; if ( ! corpse -> IsWithinDistInMap ( _player , CORPSE_RECLAIM_RADIUS , true ) ) return ; _player -> ResurrectPlayer ( _player -> InBattleground ( ) ? 1.0f : 0.5f ) ; _player -> SpawnCorpseBones ( ) ; } void WorldSession :: HandleResurrectResponseOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ RESURRECT _ RESPONSE " ) ; ObjectGuid guid ; uint8 status ; recvData >> guid ; recvData >> status ; if ( GetPlayer ( ) -> IsAlive ( ) ) return ; if ( status == 0 ) { GetPlayer ( ) -> ClearResurrectRequestData ( ) ; return ; } if ( ! GetPlayer ( ) -> IsResurrectRequestedBy ( guid ) ) return ; GetPlayer ( ) -> ResurrectUsingRequestData ( ) ; } void WorldSession :: SendAreaTriggerMessage ( const char * Text , ... ) { va_list ap ; char szStr [ 1024 ] ; szStr [ 0 ] = ' \0' ; va_start ( ap , Text ) ; vsnprintf ( szStr , 1024 , Text , ap ) ; va_end ( ap ) ; uint32 length = strlen ( szStr ) + 1 ; WorldPacket data ( SMSG_AREA_TRIGGER_MESSAGE , 4 + length ) ; data << length ; data << szStr ; SendPacket ( & data ) ; } void WorldSession :: HandleAreaTriggerOpcode ( WorldPacket & recvData ) { uint32 triggerId ; recvData >> triggerId ; TC_LOG_DEBUG ( " network " , " CMSG _ AREATRIGGER . ▁ Trigger ▁ ID : ▁ % u " , triggerId ) ; Player * player = GetPlayer ( ) ; if ( player -> IsInFlight ( ) ) { TC_LOG_DEBUG ( " network " , " HandleAreaTriggerOpcode : ▁ Player ▁ ' % s ' ▁ ( GUID : ▁ % u ) ▁ in ▁ flight , ▁ ignore ▁ Area ▁ Trigger ▁ ID : % u " , player -> GetName ( ) . c_str ( ) , player -> GetGUID ( ) . GetCounter ( ) , triggerId ) ; return ; } AreaTriggerEntry const * atEntry = sAreaTriggerStore . LookupEntry ( triggerId ) ; if ( ! atEntry ) { TC_LOG_DEBUG ( " network " , " HandleAreaTriggerOpcode : ▁ Player ▁ ' % s ' ▁ ( GUID : ▁ % u ) ▁ send ▁ unknown ▁ ( by ▁ DBC ) ▁ Area ▁ Trigger ▁ ID : % u " , player -> GetName ( ) . c_str ( ) , player -> GetGUID ( ) . GetCounter ( ) , triggerId ) ; return ; } if ( ! player -> IsInAreaTriggerRadius ( atEntry ) ) { TC_LOG_DEBUG ( " network " , " HandleAreaTriggerOpcode : ▁ Player ▁ ' % s ' ▁ ( GUID : ▁ % u ) ▁ too ▁ far , ▁ ignore ▁ Area ▁ Trigger ▁ ID : ▁ % u " , player -> GetName ( ) . c_str ( ) , player -> GetGUID ( ) . GetCounter ( ) , triggerId ) ; return ; } if ( player -> isDebugAreaTriggers ) ChatHandler ( player -> GetSession ( ) ) . PSendSysMessage ( LANG_DEBUG_AREATRIGGER_REACHED , triggerId ) ; if ( sScriptMgr -> OnAreaTrigger ( player , atEntry ) ) return ; if ( player -> IsAlive ( ) ) if ( uint32 questId = sObjectMgr -> GetQuestForAreaTrigger ( triggerId ) ) if ( player -> GetQuestStatus ( questId ) == QUEST_STATUS_INCOMPLETE ) player -> AreaExploredOrEventHappens ( questId ) ; if ( sObjectMgr -> IsTavernAreaTrigger ( triggerId ) ) { player -> SetRestFlag ( REST_FLAG_IN_TAVERN , atEntry -> id ) ; if ( sWorld -> IsFFAPvPRealm ( ) ) player -> RemoveByteFlag ( UNIT_FIELD_BYTES_2 , UNIT_BYTES_2_OFFSET_PVP_FLAG , UNIT_BYTE2_FLAG_FFA_PVP ) ; return ; } if ( Battleground * bg = player -> GetBattleground ( ) ) if ( bg -> GetStatus ( ) == STATUS_IN_PROGRESS ) bg -> HandleAreaTrigger ( player , triggerId ) ; if ( OutdoorPvP * pvp = player -> GetOutdoorPvP ( ) ) if ( pvp -> HandleAreaTrigger ( _player , triggerId ) ) return ; AreaTrigger const * at = sObjectMgr -> GetAreaTrigger ( triggerId ) ; if ( ! at ) return ; bool teleported = false ; if ( player -> GetMapId ( ) != at -> target_mapId ) { if ( Map :: EnterState denyReason = sMapMgr -> PlayerCannotEnter ( at -> target_mapId , player , false ) ) { bool reviveAtTrigger = false ; switch ( denyReason ) { case Map :: CANNOT_ENTER_NO_ENTRY : TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ attempted ▁ to ▁ enter ▁ map ▁ with ▁ id ▁ % d ▁ which ▁ has ▁ no ▁ entry " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; break ; case Map :: CANNOT_ENTER_UNINSTANCED_DUNGEON : TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ attempted ▁ to ▁ enter ▁ dungeon ▁ map ▁ % d ▁ but ▁ no ▁ instance ▁ template ▁ was ▁ found " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; break ; case Map :: CANNOT_ENTER_DIFFICULTY_UNAVAILABLE : TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ attempted ▁ to ▁ enter ▁ instance ▁ map ▁ % d ▁ but ▁ the ▁ requested ▁ difficulty ▁ was ▁ not ▁ found " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; if ( MapEntry const * entry = sMapStore . LookupEntry ( at -> target_mapId ) ) player -> SendTransferAborted ( entry -> MapID , TRANSFER_ABORT_DIFFICULTY , player -> GetDifficulty ( entry -> IsRaid ( ) ) ) ; break ; case Map :: CANNOT_ENTER_NOT_IN_RAID : { WorldPacket data ( SMSG_RAID_GROUP_ONLY , 4 + 4 ) ; data << uint32 ( 0 ) ; data << uint32 ( 2 ) ; player -> GetSession ( ) -> SendPacket ( & data ) ; TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ must ▁ be ▁ in ▁ a ▁ raid ▁ group ▁ to ▁ enter ▁ instance ▁ map ▁ % d " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; reviveAtTrigger = true ; break ; } case Map :: CANNOT_ENTER_CORPSE_IN_DIFFERENT_INSTANCE : { WorldPacket data ( SMSG_CORPSE_NOT_IN_INSTANCE ) ; player -> GetSession ( ) -> SendPacket ( & data ) ; TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ does ▁ not ▁ have ▁ a ▁ corpse ▁ in ▁ instance ▁ map ▁ % d ▁ and ▁ cannot ▁ enter " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; break ; } case Map :: CANNOT_ENTER_INSTANCE_BIND_MISMATCH : if ( MapEntry const * entry = sMapStore . LookupEntry ( at -> target_mapId ) ) { char const * mapName = entry -> name [ player -> GetSession ( ) -> GetSessionDbcLocale ( ) ] ; TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ cannot ▁ enter ▁ instance ▁ map ▁ ' % s ' ▁ because ▁ their ▁ permanent ▁ bind ▁ is ▁ incompatible ▁ with ▁ their ▁ group ' s " , player -> GetName ( ) . c_str ( ) , mapName ) ; ChatHandler ( player -> GetSession ( ) ) . PSendSysMessage ( player -> GetSession ( ) -> GetTrinityString ( LANG_INSTANCE_BIND_MISMATCH ) , mapName ) ; } reviveAtTrigger = true ; break ; case Map :: CANNOT_ENTER_TOO_MANY_INSTANCES : player -> SendTransferAborted ( at -> target_mapId , TRANSFER_ABORT_TOO_MANY_INSTANCES ) ; TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ cannot ▁ enter ▁ instance ▁ map ▁ % d ▁ because ▁ he ▁ has ▁ exceeded ▁ the ▁ maximum ▁ number ▁ of ▁ instances ▁ per ▁ hour . " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; reviveAtTrigger = true ; break ; case Map :: CANNOT_ENTER_MAX_PLAYERS : player -> SendTransferAborted ( at -> target_mapId , TRANSFER_ABORT_MAX_PLAYERS ) ; reviveAtTrigger = true ; break ; case Map :: CANNOT_ENTER_ZONE_IN_COMBAT : player -> SendTransferAborted ( at -> target_mapId , TRANSFER_ABORT_ZONE_IN_COMBAT ) ; reviveAtTrigger = true ; break ; default : break ; } if ( reviveAtTrigger ) if ( ! player -> IsAlive ( ) && player -> HasCorpse ( ) ) if ( player -> GetCorpseLocation ( ) . GetMapId ( ) == at -> target_mapId ) { player -> ResurrectPlayer ( 0.5f ) ; player -> SpawnCorpseBones ( ) ; } return ; } if ( Group * group = player -> GetGroup ( ) ) if ( group -> isLFGGroup ( ) && player -> GetMap ( ) -> IsDungeon ( ) ) teleported = player -> TeleportToBGEntryPoint ( ) ; } if ( ! teleported ) player -> TeleportTo ( at -> target_mapId , at -> target_X , at -> target_Y , at -> target_Z , at -> target_Orientation , TELE_TO_NOT_LEAVE_TRANSPORT ) ; } void WorldSession :: HandleUpdateAccountData ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ UPDATE _ ACCOUNT _ DATA " ) ; uint32 type , timestamp , decompressedSize ; recvData >> type >> timestamp >> decompressedSize ; TC_LOG_DEBUG ( " network " , " UAD : ▁ type ▁ % u , ▁ time ▁ % u , ▁ decompressedSize ▁ % u " , type , timestamp , decompressedSize ) ; if ( type > NUM_ACCOUNT_DATA_TYPES ) return ; if ( decompressedSize == 0 ) { SetAccountData ( AccountDataType ( type ) , 0 , " " ) ; WorldPacket data ( SMSG_UPDATE_ACCOUNT_DATA_COMPLETE , 4 + 4 ) ; data << uint32 ( type ) ; data << uint32 ( 0 ) ; SendPacket ( & data ) ; return ; } if ( decompressedSize > 0xFFFF ) { recvData . rfinish ( ) ; TC_LOG_ERROR ( " network " , " UAD : ▁ Account ▁ data ▁ packet ▁ too ▁ big , ▁ size ▁ % u " , decompressedSize ) ; return ; } ByteBuffer dest ; dest . resize ( decompressedSize ) ; uLongf realSize = decompressedSize ; if ( uncompress ( dest . contents ( ) , & realSize , recvData . contents ( ) + recvData . rpos ( ) , recvData . size ( ) - recvData . rpos ( ) ) != Z_OK ) { recvData . rfinish ( ) ; TC_LOG_ERROR ( " network " , " UAD : ▁ Failed ▁ to ▁ decompress ▁ account ▁ data " ) ; return ; } recvData . rfinish ( ) ; std :: string adata ; dest >> adata ; SetAccountData ( AccountDataType ( type ) , timestamp , adata ) ; WorldPacket data ( SMSG_UPDATE_ACCOUNT_DATA_COMPLETE , 4 + 4 ) ; data << uint32 ( type ) ; data << uint32 ( 0 ) ; SendPacket ( & data ) ; } void WorldSession :: HandleRequestAccountData ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ REQUEST _ ACCOUNT _ DATA " ) ; uint32 type ; recvData >> type ; TC_LOG_DEBUG ( " network " , " RAD : ▁ type ▁ % u " , type ) ; if ( type >= NUM_ACCOUNT_DATA_TYPES ) return ; AccountData * adata = GetAccountData ( AccountDataType ( type ) ) ; uint32 size = adata -> Data . size ( ) ; uLongf destSize = compressBound ( size ) ; ByteBuffer dest ; dest . resize ( destSize ) ; if ( size && compress ( dest . contents ( ) , & destSize , ( uint8 const * ) adata -> Data . c_str ( ) , size ) != Z_OK ) { TC_LOG_DEBUG ( " network " , " RAD : ▁ Failed ▁ to ▁ compress ▁ account ▁ data " ) ; return ; } dest . resize ( destSize ) ; WorldPacket data ( SMSG_UPDATE_ACCOUNT_DATA , 8 + 4 + 4 + 4 + destSize ) ; data << uint64 ( _player ? _player -> GetGUID ( ) : ObjectGuid :: Empty ) ; data << uint32 ( type ) ; data << uint32 ( adata -> Time ) ; data << uint32 ( size ) ; data . append ( dest ) ; SendPacket ( & data ) ; } void WorldSession :: HandleSetActionButtonOpcode ( WorldPacket & recvData ) { uint8 button ; uint32 packetData ; recvData >> button >> packetData ; TC_LOG_DEBUG ( " network " , " CMSG _ SET _ ACTION _ BUTTON ▁ Button : ▁ % u ▁ Data : ▁ % u " , button , packetData ) ; if ( ! packetData ) GetPlayer ( ) -> removeActionButton ( button ) ; else GetPlayer ( ) -> addActionButton ( button , ACTION_BUTTON_ACTION ( packetData ) , ACTION_BUTTON_TYPE ( packetData ) ) ; } void WorldSession :: HandleCompleteCinematic ( WorldPacket & ) { GetPlayer ( ) -> GetCinematicMgr ( ) -> EndCinematic ( ) ; } void WorldSession :: HandleNextCinematicCamera ( WorldPacket & ) { GetPlayer ( ) -> GetCinematicMgr ( ) -> BeginCinematic ( ) ; } void WorldSession :: HandleMoveTimeSkippedOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ MOVE _ TIME _ SKIPPED " ) ; ObjectGuid guid ; recvData >> guid . ReadAsPacked ( ) ; recvData . read_skip < uint32 > ( ) ; } void WorldSession :: HandleFeatherFallAck ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ MOVE _ FEATHER _ FALL _ ACK " ) ; recvData . rfinish ( ) ; } void WorldSession :: HandleMoveUnRootAck ( WorldPacket & recvData ) { recvData . rfinish ( ) ; } void WorldSession :: HandleMoveRootAck ( WorldPacket & recvData ) { recvData . rfinish ( ) ; } void WorldSession :: HandleSetActionBarToggles ( WorldPacket & recvData ) { uint8 actionBar ; recvData >> actionBar ; if ( ! GetPlayer ( ) ) { if ( actionBar != 0 ) TC_LOG_ERROR ( " network " , " WorldSession : : HandleSetActionBarToggles ▁ in ▁ not ▁ logged ▁ state ▁ with ▁ value : ▁ % u , ▁ ignored " , uint32 ( actionBar ) ) ; return ; } GetPlayer ( ) -> SetByteValue ( PLAYER_FIELD_BYTES , PLAYER_FIELD_BYTES_OFFSET_ACTION_BAR_TOGGLES , actionBar ) ; } void WorldSession :: HandlePlayedTime ( WorldPacket & recvData ) { uint8 unk1 ; recvData >> unk1 ; WorldPacket data ( SMSG_PLAYED_TIME , 4 + 4 + 1 ) ; data << uint32 ( _player -> GetTotalPlayedTime ( ) ) ; data << uint32 ( _player -> GetLevelPlayedTime ( ) ) ; data << uint8 ( unk1 ) ; SendPacket ( & data ) ; } void WorldSession :: HandleInspectOpcode ( WorldPacket & recvData ) { ObjectGuid guid ; recvData >> guid ; TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ INSPECT " ) ; Player * player = ObjectAccessor :: GetPlayer ( * _player , guid ) ; if ( ! player ) { TC_LOG_DEBUG ( " network " , " CMSG _ INSPECT : ▁ No ▁ player ▁ found ▁ from ▁ % s " , guid . ToString ( ) . c_str ( ) ) ; return ; } if ( ! GetPlayer ( ) -> IsWithinDistInMap ( player , INSPECT_DISTANCE , false ) ) return ; if ( GetPlayer ( ) -> IsValidAttackTarget ( player ) ) return ; uint32 talent_points = 0x47 ; uint32 guid_size = player -> GetPackGUID ( ) . size ( ) ; WorldPacket data ( SMSG_INSPECT_TALENT , guid_size + 4 + talent_points ) ; data << player -> GetPackGUID ( ) ; if ( GetPlayer ( ) -> CanBeGameMaster ( ) || sWorld -> getIntConfig ( CONFIG_TALENTS_INSPECTING ) + ( GetPlayer ( ) -> GetTeamId ( ) == player -> GetTeamId ( ) ) > 1 ) player -> BuildPlayerTalentsInfoData ( & data ) ; else { data << uint32 ( 0 ) ; data << uint8 ( 0 ) ; data << uint8 ( 0 ) ; } player -> BuildEnchantmentsInfoData ( & data ) ; SendPacket ( & data ) ; } void WorldSession :: HandleInspectHonorStatsOpcode ( WorldPacket & recvData ) { ObjectGuid guid ; recvData >> guid ; Player * player = ObjectAccessor :: GetPlayer ( * _player , guid ) ; if ( ! player ) { TC_LOG_DEBUG ( " network " , " MSG _ INSPECT _ HONOR _ STATS : ▁ No ▁ player ▁ found ▁ from ▁ % s " , guid . ToString ( ) . c_str ( ) ) ; return ; } if ( ! GetPlayer ( ) -> IsWithinDistInMap ( player , INSPECT_DISTANCE , false ) ) return ; if ( GetPlayer ( ) -> IsValidAttackTarget ( player ) ) return ; WorldPacket data ( MSG_INSPECT_HONOR_STATS , 8 + 1 + 4 * 4 ) ; data << uint64 ( player -> GetGUID ( ) ) ; data << uint8 ( player -> GetHonorPoints ( ) ) ; data << uint32 ( player -> GetUInt32Value ( PLAYER_FIELD_KILLS ) ) ; data << uint32 ( player -> GetUInt32Value ( PLAYER_FIELD_TODAY_CONTRIBUTION ) ) ; data << uint32 ( player -> GetUInt32Value ( PLAYER_FIELD_YESTERDAY_CONTRIBUTION ) ) ; data << uint32 ( player -> GetUInt32Value ( PLAYER_FIELD_LIFETIME_HONORABLE_KILLS ) ) ; SendPacket ( & data ) ; } void WorldSession :: HandleWorldTeleportOpcode ( WorldPacket & recvData ) { uint32 time ; uint32 mapid ; float PositionX ; float PositionY ; float PositionZ ; float Orientation ; recvData >> time ; recvData >> mapid ; recvData >> PositionX ; recvData >> PositionY ; recvData >> PositionZ ; recvData >> Orientation ; TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ WORLD _ TELEPORT " ) ; if ( GetPlayer ( ) -> IsInFlight ( ) ) { TC_LOG_DEBUG ( " network " , " Player ▁ ' % s ' ▁ ( GUID : ▁ % u ) ▁ in ▁ flight , ▁ ignore ▁ worldport ▁ command . " , GetPlayer ( ) -> GetName ( ) . c_str ( ) , GetPlayer ( ) -> GetGUID ( ) . GetCounter ( ) ) ; return ; } TC_LOG_DEBUG ( " network " , " CMSG _ WORLD _ TELEPORT : ▁ Player ▁ = ▁ % s , ▁ Time ▁ = ▁ % u , ▁ map ▁ = ▁ % u , ▁ x ▁ = ▁ % f , ▁ y ▁ = ▁ % f , ▁ z ▁ = ▁ % f , ▁ o ▁ = ▁ % f " , GetPlayer ( ) -> GetName ( ) . c_str ( ) , time , mapid , PositionX , PositionY , PositionZ , Orientation ) ; if ( HasPermission ( rbac :: RBAC_PERM_OPCODE_WORLD_TELEPORT ) ) GetPlayer ( ) -> TeleportTo ( mapid , PositionX , PositionY , PositionZ , Orientation ) ; else SendNotification ( LANG_YOU_NOT_HAVE_PERMISSION ) ; } void WorldSession :: HandleWhoisOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " Received ▁ opcode ▁ CMSG _ WHOIS " ) ; std :: string charname ; recvData >> charname ; if ( ! HasPermission ( rbac :: RBAC_PERM_OPCODE_WHOIS ) ) { SendNotification ( LANG_YOU_NOT_HAVE_PERMISSION ) ; return ; } if ( charname . empty ( ) || ! normalizePlayerName ( charname ) ) { SendNotification ( LANG_NEED_CHARACTER_NAME ) ; return ; } Player * player = ObjectAccessor :: FindConnectedPlayerByName ( charname ) ; if ( ! player ) { SendNotification ( LANG_PLAYER_NOT_EXIST_OR_OFFLINE , charname . c_str ( ) ) ; return ; } uint32 accid = player -> GetSession ( ) -> GetAccountId ( ) ; PreparedStatement * stmt = LoginDatabase . GetPreparedStatement ( LOGIN_SEL_ACCOUNT_WHOIS ) ; stmt -> setUInt32 ( 0 , accid ) ; PreparedQueryResult result = LoginDatabase . Query ( stmt ) ; if ( ! result ) { SendNotification ( LANG_ACCOUNT_FOR_PLAYER_NOT_FOUND , charname . c_str ( ) ) ; return ; } Field * fields = result -> Fetch ( ) ; std :: string acc = fields [ 0 ] . GetString ( ) ; if ( acc . empty ( ) ) acc = " Unknown " ; std :: string email = fields [ 1 ] . GetString ( ) ; if ( email . empty ( ) ) email = " Unknown " ; std :: string lastip = fields [ 2 ] . GetString ( ) ; if ( lastip . empty ( ) ) lastip = " Unknown " ; std :: string msg = charname + " ' s ▁ " + " account ▁ is ▁ " + acc + " , ▁ e - mail : ▁ " + email + " , ▁ last ▁ ip : ▁ " + lastip ; WorldPacket data ( SMSG_WHOIS , msg . size ( ) + 1 ) ; data << msg ; SendPacket ( & data ) ; TC_LOG_DEBUG ( " network " , " Received ▁ whois ▁ command ▁ from ▁ player ▁ % s ▁ for ▁ character ▁ % s " , GetPlayer ( ) -> GetName ( ) . c_str ( ) , charname . c_str ( ) ) ; } void WorldSession :: HandleComplainOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ COMPLAIN " ) ; uint8 spam_type ; ObjectGuid spammer_guid ; uint32 unk1 = 0 ; uint32 unk2 = 0 ; uint32 unk3 = 0 ; uint32 unk4 = 0 ; std :: string description = " " ; recvData >> spam_type ; recvData >> spammer_guid ; switch ( spam_type ) { case 0 : recvData >> unk1 ; recvData >> unk2 ; recvData >> unk3 ; break ; case 1 : recvData >> unk1 ; recvData >> unk2 ; recvData >> unk3 ; recvData >> unk4 ; recvData >> description ; break ; } WorldPacket data ( SMSG_COMPLAIN_RESULT , 1 ) ; data << uint8 ( 0 ) ; SendPacket ( & data ) ; TC_LOG_DEBUG ( " network " , " REPORT ▁ SPAM : ▁ type ▁ % u , ▁ % s , ▁ unk1 ▁ % u , ▁ unk2 ▁ % u , ▁ unk3 ▁ % u , ▁ unk4 ▁ % u , ▁ message ▁ % s " , spam_type , spammer_guid . ToString ( ) . c_str ( ) , unk1 , unk2 , unk3 , unk4 , description . c_str ( ) ) ; } void WorldSession :: HandleRealmSplitOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " CMSG _ REALM _ SPLIT " ) ; uint32 unk ; std :: string split_date = "01/01/01" ; recvData >> unk ; WorldPacket data ( SMSG_REALM_SPLIT , 4 + 4 + split_date . size ( ) + 1 ) ; data << unk ; data << uint32 ( 0x00000000 ) ; data << split_date ; SendPacket ( & data ) ; } void WorldSession :: HandleFarSightOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ FAR _ SIGHT " ) ; bool apply ; recvData >> apply ; if ( apply ) { TC_LOG_DEBUG ( " network " , " Added ▁ FarSight ▁ % s ▁ to ▁ player ▁ % u " , _player -> GetGuidValue ( PLAYER_FARSIGHT ) . ToString ( ) . c_str ( ) , _player -> GetGUID ( ) . GetCounter ( ) ) ; if ( WorldObject * target = _player -> GetViewpoint ( ) ) _player -> SetSeer ( target ) ; else TC_LOG_DEBUG ( " network " , " Player ▁ % s ▁ ( % s ) ▁ requests ▁ non - existing ▁ seer ▁ % s " , _player -> GetName ( ) . c_str ( ) , _player -> GetGUID ( ) . ToString ( ) . c_str ( ) , _player -> GetGuidValue ( PLAYER_FARSIGHT ) . ToString ( ) . c_str ( ) ) ; } else { TC_LOG_DEBUG ( " network " , " Player ▁ % u ▁ set ▁ vision ▁ to ▁ self " , _player -> GetGUID ( ) . GetCounter ( ) ) ; _player -> SetSeer ( _player ) ; } GetPlayer ( ) -> UpdateVisibilityForPlayer ( ) ; } void WorldSession :: HandleSetTitleOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " CMSG _ SET _ TITLE " ) ; int32 title ; recvData >> title ; if ( title > 0 && title < MAX_TITLE_INDEX ) { if ( ! GetPlayer ( ) -> HasTitle ( title ) ) return ; } else title = 0 ; GetPlayer ( ) -> SetUInt32Value ( PLAYER_CHOSEN_TITLE , title ) ; } void WorldSession :: HandleTimeSyncResp ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " CMSG _ TIME _ SYNC _ RESP " ) ; uint32 counter , clientTicks ; recvData >> counter >> clientTicks ; if ( counter != _player -> m_timeSyncCounter - 1 ) TC_LOG_DEBUG ( " network " , " Wrong ▁ time ▁ sync ▁ counter ▁ from ▁ player ▁ % s ▁ ( cheater ? ) " , _player -> GetName ( ) . c_str ( ) ) ; TC_LOG_DEBUG ( " network " , " Time ▁ sync ▁ received : ▁ counter ▁ % u , ▁ client ▁ ticks ▁ % u , ▁ time ▁ since ▁ last ▁ sync ▁ % u " , counter , clientTicks , clientTicks - _player -> m_timeSyncClient ) ; uint32 ourTicks = clientTicks + ( GameTime :: GetGameTimeMS ( ) - _player -> m_timeSyncServer ) ; TC_LOG_DEBUG ( " network " , " Our ▁ ticks : ▁ % u , ▁ diff ▁ % u , ▁ latency ▁ % u " , ourTicks , ourTicks - clientTicks , GetLatency ( ) ) ; _player -> m_timeSyncClient = clientTicks ; } void WorldSession :: HandleResetInstancesOpcode ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ RESET _ INSTANCES " ) ; if ( Group * group = _player -> GetGroup ( ) ) { if ( group -> IsLeader ( _player -> GetGUID ( ) ) ) group -> ResetInstances ( INSTANCE_RESET_ALL , false , _player ) ; } else _player -> ResetInstances ( INSTANCE_RESET_ALL , false ) ; } void WorldSession :: HandleSetDungeonDifficultyOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " MSG _ SET _ DUNGEON _ DIFFICULTY " ) ; uint32 mode ; recvData >> mode ; if ( mode >= MAX_DUNGEON_DIFFICULTY ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetDungeonDifficultyOpcode : ▁ player ▁ % d ▁ sent ▁ an ▁ invalid ▁ instance ▁ mode ▁ % d ! " , _player -> GetGUID ( ) . GetCounter ( ) , mode ) ; return ; } if ( Difficulty ( mode ) == _player -> GetDungeonDifficulty ( ) ) return ; Map * map = _player -> FindMap ( ) ; if ( map && map -> IsDungeon ( ) ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetDungeonDifficultyOpcode : ▁ player ▁ ( Name : ▁ % s , ▁ GUID : ▁ % u ) ▁ tried ▁ to ▁ reset ▁ the ▁ instance ▁ while ▁ player ▁ is ▁ inside ! " , _player -> GetName ( ) . c_str ( ) , _player -> GetGUID ( ) . GetCounter ( ) ) ; return ; } Group * group = _player -> GetGroup ( ) ; if ( group ) { if ( group -> IsLeader ( _player -> GetGUID ( ) ) ) { for ( GroupReference * itr = group -> GetFirstMember ( ) ; itr != NULL ; itr = itr -> next ( ) ) { Player * groupGuy = itr -> GetSource ( ) ; if ( ! groupGuy ) continue ; if ( ! groupGuy -> IsInMap ( groupGuy ) ) return ; if ( groupGuy -> GetMap ( ) -> IsNonRaidDungeon ( ) ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetDungeonDifficultyOpcode : ▁ player ▁ % d ▁ tried ▁ to ▁ reset ▁ the ▁ instance ▁ while ▁ group ▁ member ▁ ( Name : ▁ % s , ▁ GUID : ▁ % u ) ▁ is ▁ inside ! " , _player -> GetGUID ( ) . GetCounter ( ) , groupGuy -> GetName ( ) . c_str ( ) , groupGuy -> GetGUID ( ) . GetCounter ( ) ) ; return ; } } group -> ResetInstances ( INSTANCE_RESET_CHANGE_DIFFICULTY , false , _player ) ; group -> SetDungeonDifficulty ( Difficulty ( mode ) ) ; } } else { _player -> ResetInstances ( INSTANCE_RESET_CHANGE_DIFFICULTY , false ) ; _player -> SetDungeonDifficulty ( Difficulty ( mode ) ) ; } } void WorldSession :: HandleSetRaidDifficultyOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " MSG _ SET _ RAID _ DIFFICULTY " ) ; uint32 mode ; recvData >> mode ; if ( mode >= MAX_RAID_DIFFICULTY ) { TC_LOG_ERROR ( " network " , " WorldSession : : HandleSetRaidDifficultyOpcode : ▁ player ▁ % d ▁ sent ▁ an ▁ invalid ▁ instance ▁ mode ▁ % d ! " , _player -> GetGUID ( ) . GetCounter ( ) , mode ) ; return ; } Map * map = _player -> FindMap ( ) ; if ( map && map -> IsDungeon ( ) ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetRaidDifficultyOpcode : ▁ player ▁ % d ▁ tried ▁ to ▁ reset ▁ the ▁ instance ▁ while ▁ inside ! " , _player -> GetGUID ( ) . GetCounter ( ) ) ; return ; } if ( Difficulty ( mode ) == _player -> GetRaidDifficulty ( ) ) return ; Group * group = _player -> GetGroup ( ) ; if ( group ) { if ( group -> IsLeader ( _player -> GetGUID ( ) ) ) { for ( GroupReference * itr = group -> GetFirstMember ( ) ; itr != NULL ; itr = itr -> next ( ) ) { Player * groupGuy = itr -> GetSource ( ) ; if ( ! groupGuy ) continue ; if ( ! groupGuy -> IsInMap ( groupGuy ) ) return ; if ( groupGuy -> GetMap ( ) -> IsRaid ( ) ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetRaidDifficultyOpcode : ▁ player ▁ % d ▁ tried ▁ to ▁ reset ▁ the ▁ instance ▁ while ▁ inside ! " , _player -> GetGUID ( ) . GetCounter ( ) ) ; return ; } } group -> ResetInstances ( INSTANCE_RESET_CHANGE_DIFFICULTY , true , _player ) ; group -> SetRaidDifficulty ( Difficulty ( mode ) ) ; } } else { _player -> ResetInstances ( INSTANCE_RESET_CHANGE_DIFFICULTY , true ) ; _player -> SetRaidDifficulty ( Difficulty ( mode ) ) ; } } void WorldSession :: HandleCancelMountAuraOpcode ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ CANCEL _ MOUNT _ AURA " ) ; if ( ! _player -> IsMounted ( ) ) { ChatHandler ( this ) . SendSysMessage ( LANG_CHAR_NON_MOUNTED ) ; return ; } if ( _player -> IsInFlight ( ) ) { ChatHandler ( this ) . SendSysMessage ( LANG_YOU_IN_FLIGHT ) ; return ; } _player -> RemoveAurasByType ( SPELL_AURA_MOUNTED ) ; } void WorldSession :: HandleMoveSetCanFlyAckOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ MOVE _ SET _ CAN _ FLY _ ACK " ) ; ObjectGuid guid ; recvData >> guid . ReadAsPacked ( ) ; recvData . read_skip < uint32 > ( ) ; MovementInfo movementInfo ; movementInfo . guid = guid ; ReadMovementInfo ( recvData , & movementInfo ) ; recvData . read_skip < float > ( ) ; _player -> m_unitMovedByMe -> m_movementInfo . flags = movementInfo . GetMovementFlags ( ) ; } void WorldSession :: HandleRequestPetInfoOpcode ( WorldPacket & ) { } void WorldSession :: HandleSetTaxiBenchmarkOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ SET _ TAXI _ BENCHMARK _ MODE " ) ; uint8 mode ; recvData >> mode ; mode ? _player -> SetFlag ( PLAYER_FLAGS , PLAYER_FLAGS_TAXI_BENCHMARK ) : _player -> RemoveFlag ( PLAYER_FLAGS , PLAYER_FLAGS_TAXI_BENCHMARK ) ; TC_LOG_DEBUG ( " network " , " Client ▁ used ▁ \ " / timetest ▁ % d\ " ▁ command " , mode ) ; } void WorldSession :: HandleQueryInspectAchievements ( WorldPacket & recvData ) { ObjectGuid guid ; recvData >> guid . ReadAsPacked ( ) ; TC_LOG_DEBUG ( " network " , " CMSG _ QUERY _ INSPECT _ ACHIEVEMENTS ▁ [ % s ] ▁ Inspected ▁ Player ▁ [ % s ] " , _player -> GetGUID ( ) . ToString ( ) . c_str ( ) , guid . ToString ( ) . c_str ( ) ) ; Player * player = ObjectAccessor :: GetPlayer ( * _player , guid ) ; if ( ! player ) return ; if ( ! GetPlayer ( ) -> IsWithinDistInMap ( player , INSPECT_DISTANCE , false ) ) return ; if ( GetPlayer ( ) -> IsValidAttackTarget ( player ) ) return ; player -> SendRespondInspectAchievements ( _player ) ; } void WorldSession :: HandleWorldStateUITimerUpdate ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ WORLD _ STATE _ UI _ TIMER _ UPDATE " ) ; WorldPacket data ( SMSG_WORLD_STATE_UI_TIMER_UPDATE , 4 ) ; data << uint32 ( time ( NULL ) ) ; SendPacket ( & data ) ; } void WorldSession :: HandleReadyForAccountDataTimes ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ READY _ FOR _ ACCOUNT _ DATA _ TIMES " ) ; SendAccountDataTimes ( GLOBAL_CACHE_MASK ) ; } void WorldSession :: SendSetPhaseShift ( uint32 PhaseShift ) { WorldPacket data ( SMSG_SET_PHASE_SHIFT , 4 ) ; data << uint32 ( PhaseShift ) ; SendPacket ( & data ) ; } void WorldSession :: HandleAreaSpiritHealerQueryOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ AREA _ SPIRIT _ HEALER _ QUERY " ) ; Battleground * bg = _player -> GetBattleground ( ) ; ObjectGuid guid ; recvData >> guid ; Creature * unit = GetPlayer ( ) -> GetMap ( ) -> GetCreature ( guid ) ; if ( ! unit ) return ; if ( ! unit -> IsSpiritService ( ) ) return ; if ( bg ) sBattlegroundMgr -> SendAreaSpiritHealerQueryOpcode ( _player , bg , guid ) ; if ( Battlefield * bf = sBattlefieldMgr -> GetBattlefieldToZoneId ( _player -> GetZoneId ( ) ) ) bf -> SendAreaSpiritHealerQueryOpcode ( _player , guid ) ; } void WorldSession :: HandleAreaSpiritHealerQueueOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ AREA _ SPIRIT _ HEALER _ QUEUE " ) ; Battleground * bg = _player -> GetBattleground ( ) ; ObjectGuid guid ; recvData >> guid ; Creature * unit = GetPlayer ( ) -> GetMap ( ) -> GetCreature ( guid ) ; if ( ! unit ) return ; if ( ! unit -> IsSpiritService ( ) ) return ; if ( bg ) bg -> AddPlayerToResurrectQueue ( guid , _player -> GetGUID ( ) ) ; if ( Battlefield * bf = sBattlefieldMgr -> GetBattlefieldToZoneId ( _player -> GetZoneId ( ) ) ) bf -> AddPlayerToResurrectQueue ( guid , _player -> GetGUID ( ) ) ; } void WorldSession :: HandleHearthAndResurrect ( WorldPacket & ) { if ( _player -> IsInFlight ( ) ) return ; if ( Battlefield * bf = sBattlefieldMgr -> GetBattlefieldToZoneId ( _player -> GetZoneId ( ) ) ) { bf -> PlayerAskToLeave ( _player ) ; return ; } AreaTableEntry const * atEntry = sAreaTableStore . LookupEntry ( _player -> GetAreaId ( ) ) ; if ( ! atEntry || ! ( atEntry -> flags & AREA_FLAG_WINTERGRASP_2 ) ) return ; _player -> BuildPlayerRepop ( ) ; _player -> ResurrectPlayer ( 1.0f ) ; _player -> TeleportTo ( _player -> m_homebindMapId , _player -> m_homebindX , _player -> m_homebindY , _player -> m_homebindZ , _player -> GetOrientation ( ) ) ; } void WorldSession :: HandleInstanceLockResponse ( WorldPacket & recvPacket ) { uint8 accept ; recvPacket >> accept ; if ( ! _player -> HasPendingBind ( ) ) { TC_LOG_INFO ( " network " , " InstanceLockResponse : ▁ Player ▁ % s ▁ ( guid ▁ % u ) ▁ tried ▁ to ▁ bind ▁ himself / teleport ▁ to ▁ graveyard ▁ without ▁ a ▁ pending ▁ bind ! " , _player -> GetName ( ) . c_str ( ) , _player -> GetGUID ( ) . GetCounter ( ) ) ; return ; } if ( accept ) _player -> BindToInstance ( ) ; else _player -> RepopAtGraveyard ( ) ; _player -> SetPendingBind ( 0 , 0 ) ; } void WorldSession :: HandleUpdateMissileTrajectory ( WorldPacket & recvPacket ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ UPDATE _ MISSILE _ TRAJECTORY " ) ; ObjectGuid guid ; uint32 spellId ; float elevation , speed ; float curX , curY , curZ ; float targetX , targetY , targetZ ; uint8 moveStop ; recvPacket >> guid >> spellId >> elevation >> speed ; recvPacket >> curX >> curY >> curZ ; recvPacket >> targetX >> targetY >> targetZ ; recvPacket >> moveStop ; Unit * caster = ObjectAccessor :: GetUnit ( * _player , guid ) ; Spell * spell = caster ? caster -> GetCurrentSpell ( CURRENT_GENERIC_SPELL ) : NULL ; if ( ! spell || spell -> m_spellInfo -> Id != spellId || ! spell -> m_targets . HasDst ( ) || ! spell -> m_targets . HasSrc ( ) ) { recvPacket . rfinish ( ) ; return ; } Position pos = * spell -> m_targets . GetSrcPos ( ) ; pos . Relocate ( curX , curY , curZ ) ; spell -> m_targets . ModSrc ( pos ) ; pos = * spell -> m_targets . GetDstPos ( ) ; pos . Relocate ( targetX , targetY , targetZ ) ; spell -> m_targets . ModDst ( pos ) ; spell -> m_targets . SetElevation ( elevation ) ; spell -> m_targets . SetSpeed ( speed ) ; if ( moveStop ) { uint32 opcode ; recvPacket >> opcode ; recvPacket . SetOpcode ( opcode ) ; HandleMovementOpcodes ( recvPacket ) ; } } </DOCUMENT>
<DOCUMENT_ID="lthall/Leonard_ardupilot/tree/master/libraries/AP_NavEKF/AP_NavEKF_core_common.cpp"> # include " AP _ NavEKF _ core _ common . h " NavEKF_core_common :: Matrix24 NavEKF_core_common :: KH ; NavEKF_core_common :: Matrix24 NavEKF_core_common :: KHP ; NavEKF_core_common :: Matrix24 NavEKF_core_common :: nextP ; NavEKF_core_common :: Vector28 NavEKF_core_common :: Kfusion ; void NavEKF_core_common :: fill_scratch_variables ( void ) { # if CONFIG_HAL_BOARD == HAL_BOARD_SITL fill_nanf ( & KH [ 0 ] [ 0 ] , sizeof ( KH ) / sizeof ( float ) ) ; fill_nanf ( & KHP [ 0 ] [ 0 ] , sizeof ( KHP ) / sizeof ( float ) ) ; fill_nanf ( & nextP [ 0 ] [ 0 ] , sizeof ( nextP ) / sizeof ( float ) ) ; fill_nanf ( & Kfusion [ 0 ] , sizeof ( Kfusion ) / sizeof ( float ) ) ; # endif } </DOCUMENT>
<DOCUMENT_ID="samdnic/Tarantula/tree/master/boost/libs/coroutine/src/detail/standard_stack_allocator_posix.cpp"> # define BOOST_COROUTINES_SOURCE # include " boost / coroutine / detail / standard _ stack _ allocator . hpp " extern " C " { # include < fcntl . h > # include < signal . h > # include < sys / mman . h > # include < sys / resource . h > # include < sys / stat . h > # include < sys / time . h > # include < sys / types . h > # include < unistd . h > } # include < algorithm > # include < cmath > # include < cstring > # include < stdexcept > # include < boost / assert . hpp > # include < boost / context / fcontext . hpp > # include < boost / coroutine / stack_context . hpp > # if ! defined ( SIGSTKSZ ) # define SIGSTKSZ ( 8 * 1024 ) # define UDEF_SIGSTKSZ # endif # ifdef BOOST_HAS_ABI_HEADERS # include BOOST_ABI_PREFIX # endif namespace boost { namespace coroutines { namespace detail { std :: size_t pagesize ( ) { static std :: size_t size = :: sysconf ( _SC_PAGESIZE ) ; return size ; } rlimit stacksize_limit_ ( ) { rlimit limit ; # if defined ( BOOST_DISABLE_ASSERTS ) :: getrlimit ( RLIMIT_STACK , & limit ) ; # else const int result = :: getrlimit ( RLIMIT_STACK , & limit ) ; BOOST_ASSERT ( 0 == result ) ; # endif return limit ; } rlimit stacksize_limit ( ) { static rlimit limit = stacksize_limit_ ( ) ; return limit ; } std :: size_t page_count ( std :: size_t stacksize ) { return static_cast < std :: size_t > ( std :: ceil ( static_cast < float > ( stacksize ) / pagesize ( ) ) ) ; } bool standard_stack_allocator :: is_stack_unbound ( ) { return RLIM_INFINITY == detail :: stacksize_limit ( ) . rlim_max ; } std :: size_t standard_stack_allocator :: default_stacksize ( ) { std :: size_t size = 8 * minimum_stacksize ( ) ; if ( is_stack_unbound ( ) ) return size ; BOOST_ASSERT ( maximum_stacksize ( ) >= minimum_stacksize ( ) ) ; return maximum_stacksize ( ) == size ? size : ( std :: min ) ( size , maximum_stacksize ( ) ) ; } std :: size_t standard_stack_allocator :: minimum_stacksize ( ) { return SIGSTKSZ + sizeof ( context :: fcontext_t ) + 15 ; } std :: size_t standard_stack_allocator :: maximum_stacksize ( ) { BOOST_ASSERT ( ! is_stack_unbound ( ) ) ; return static_cast < std :: size_t > ( detail :: stacksize_limit ( ) . rlim_max ) ; } void standard_stack_allocator :: allocate ( stack_context & ctx , std :: size_t size ) { BOOST_ASSERT ( minimum_stacksize ( ) <= size ) ; BOOST_ASSERT ( is_stack_unbound ( ) || ( maximum_stacksize ( ) >= size ) ) ; const std :: size_t pages ( detail :: page_count ( size ) + 1 ) ; const std :: size_t size_ ( pages * detail :: pagesize ( ) ) ; BOOST_ASSERT ( 0 < size && 0 < size_ ) ; const int fd ( :: open ( " / dev / zero " , O_RDONLY ) ) ; BOOST_ASSERT ( - 1 != fd ) ; void * limit = # if defined ( macintosh ) || defined ( __APPLE__ ) || defined ( __APPLE_CC__ ) :: mmap ( 0 , size_ , PROT_READ | PROT_WRITE , MAP_PRIVATE | MAP_ANON , - 1 , 0 ) ; # else :: mmap ( 0 , size_ , PROT_READ | PROT_WRITE , MAP_PRIVATE , fd , 0 ) ; # endif :: close ( fd ) ; if ( ! limit ) throw std :: bad_alloc ( ) ; std :: memset ( limit , ' \0' , size_ ) ; # if defined ( BOOST_DISABLE_ASSERTS ) :: mprotect ( limit , detail :: pagesize ( ) , PROT_NONE ) ; # else const int result ( :: mprotect ( limit , detail :: pagesize ( ) , PROT_NONE ) ) ; BOOST_ASSERT ( 0 == result ) ; # endif ctx . size = size_ ; ctx . sp = static_cast < char * > ( limit ) + ctx . size ; } void standard_stack_allocator :: deallocate ( stack_context & ctx ) { BOOST_ASSERT ( ctx . sp ) ; BOOST_ASSERT ( minimum_stacksize ( ) <= ctx . size ) ; BOOST_ASSERT ( is_stack_unbound ( ) || ( maximum_stacksize ( ) >= ctx . size ) ) ; void * limit = static_cast < char * > ( ctx . sp ) - ctx . size ; :: munmap ( limit , ctx . size ) ; } } } } # ifdef BOOST_HAS_ABI_HEADERS # include BOOST_ABI_SUFFIX # endif # ifdef UDEF_SIGSTKSZ # undef SIGSTKSZ # endif </DOCUMENT>
<DOCUMENT_ID="KDE/koffice/tree/master/kcells/dialogs/StyleManagerDialog.cpp"> # include " StyleManagerDialog . h " # include < QMap > # include < QTreeWidget > # include < QVBoxLayout > # include < kcombobox . h > # include < kdebug . h > # include < klocale . h > # include " KCCell . h " # include " LayoutDialog . h " # include " ui / Selection . h " # include " KCSheet . h " # include " KCStyle . h " # include " KCStyleManager . h " # include " commands / KCStyleCommand . h " StyleManagerDialog :: StyleManagerDialog ( QWidget * parent , Selection * selection , KCStyleManager * manager ) : KDialog ( parent ) , m_selection ( selection ) , m_styleManager ( manager ) { setButtons ( Apply | User1 | User2 | User3 | Close ) ; setButtonText ( User3 , i18n ( " & New . . . " ) ) ; setButtonText ( User2 , i18n ( " & Modify . . . " ) ) ; setButtonText ( User1 , i18n ( " & Delete . . . " ) ) ; setButtonsOrientation ( Qt :: Vertical ) ; setCaption ( i18n ( " Style ▁ Manager " ) ) ; QWidget * widget = new QWidget ( this ) ; setMainWidget ( widget ) ; QVBoxLayout * layout = new QVBoxLayout ( widget ) ; m_styleList = new QTreeWidget ( this ) ; m_styleList -> setHeaderLabel ( i18n ( " Style " ) ) ; layout -> addWidget ( m_styleList ) ; m_displayBox = new KComboBox ( false , this ) ; m_displayBox -> insertItem ( 0 , i18n ( " All ▁ Styles " ) ) ; m_displayBox -> insertItem ( 1 , i18n ( " Custom ▁ Styles " ) ) ; m_displayBox -> insertItem ( 2 , i18n ( " Hierarchical " ) ) ; layout -> addWidget ( m_displayBox ) ; slotDisplayMode ( 0 ) ; enableButton ( KDialog :: User3 , true ) ; enableButton ( KDialog :: User2 , true ) ; enableButton ( KDialog :: User1 , false ) ; connect ( m_displayBox , SIGNAL ( activated ( int ) ) , this , SLOT ( slotDisplayMode ( int ) ) ) ; connect ( this , SIGNAL ( applyClicked ( ) ) , this , SLOT ( slotOk ( ) ) ) ; connect ( this , SIGNAL ( user3Clicked ( ) ) , this , SLOT ( slotNew ( ) ) ) ; connect ( this , SIGNAL ( user2Clicked ( ) ) , this , SLOT ( slotEdit ( ) ) ) ; connect ( this , SIGNAL ( user1Clicked ( ) ) , this , SLOT ( slotRemove ( ) ) ) ; connect ( m_styleList , SIGNAL ( itemDoubleClicked ( QTreeWidgetItem * , int ) ) , this , SLOT ( slotEdit ( ) ) ) ; connect ( m_styleList , SIGNAL ( currentItemChanged ( QTreeWidgetItem * , QTreeWidgetItem * ) ) , this , SLOT ( selectionChanged ( QTreeWidgetItem * ) ) ) ; } StyleManagerDialog :: ~ StyleManagerDialog ( ) { } void StyleManagerDialog :: fillComboBox ( ) { typedef QMap < KCCustomStyle * , QTreeWidgetItem * > KCMap ; KCMap entries ; entries . clear ( ) ; entries [ m_styleManager -> defaultStyle ( ) ] = new QTreeWidgetItem ( m_styleList , QStringList ( i18n ( " Default " ) ) ) ; CustomStyles :: const_iterator iter = m_styleManager -> m_styles . constBegin ( ) ; CustomStyles :: const_iterator end = m_styleManager -> m_styles . constEnd ( ) ; while ( entries . count ( ) != m_styleManager -> m_styles . count ( ) + 1 ) { if ( entries . find ( iter . value ( ) ) == entries . end ( ) ) { if ( iter . value ( ) -> parentName ( ) . isNull ( ) ) entries [ iter . value ( ) ] = new QTreeWidgetItem ( entries [ m_styleManager -> defaultStyle ( ) ] , QStringList ( iter . value ( ) -> name ( ) ) ) ; else { KCCustomStyle * parentStyle = m_styleManager -> style ( iter . value ( ) -> parentName ( ) ) ; if ( parentStyle ) { KCMap :: const_iterator i = entries . constFind ( parentStyle ) ; if ( i != entries . constEnd ( ) ) entries [ iter . value ( ) ] = new QTreeWidgetItem ( i . value ( ) , QStringList ( iter . value ( ) -> name ( ) ) ) ; } } } ++ iter ; if ( iter == end ) iter = m_styleManager -> m_styles . constBegin ( ) ; } entries . clear ( ) ; } void StyleManagerDialog :: slotDisplayMode ( int mode ) { m_styleList -> clear ( ) ; if ( mode != 2 ) m_styleList -> setRootIsDecorated ( false ) ; else { m_styleList -> setRootIsDecorated ( true ) ; fillComboBox ( ) ; return ; } if ( mode != 1 ) new QTreeWidgetItem ( m_styleList , QStringList ( i18n ( " Default " ) ) ) ; CustomStyles :: iterator iter = m_styleManager -> m_styles . begin ( ) ; CustomStyles :: iterator end = m_styleManager -> m_styles . end ( ) ; while ( iter != end ) { KCCustomStyle * styleData = iter . value ( ) ; if ( ! styleData || styleData -> name ( ) . isEmpty ( ) ) { ++ iter ; continue ; } if ( mode == 1 ) { if ( styleData -> type ( ) == KCStyle :: CUSTOM ) new QTreeWidgetItem ( m_styleList , QStringList ( styleData -> name ( ) ) ) ; } else new QTreeWidgetItem ( m_styleList , QStringList ( styleData -> name ( ) ) ) ; ++ iter ; } } void StyleManagerDialog :: slotOk ( ) { kDebug ( ) ; QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) { accept ( ) ; return ; } QString name ( item -> text ( 0 ) ) ; if ( name == i18n ( " Default " ) ) { KCStyleCommand * command = new KCStyleCommand ( ) ; command -> setSheet ( m_selection -> activeSheet ( ) ) ; command -> setDefault ( ) ; command -> add ( * m_selection ) ; command -> execute ( m_selection -> canvas ( ) ) ; } else { KCStyleCommand * command = new KCStyleCommand ( ) ; command -> setSheet ( m_selection -> activeSheet ( ) ) ; command -> setParentName ( name ) ; command -> add ( * m_selection ) ; command -> execute ( m_selection -> canvas ( ) ) ; } accept ( ) ; } void StyleManagerDialog :: slotNew ( ) { KCCustomStyle * parentStyle = 0 ; QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( item ) { const QString name = item -> text ( 0 ) ; if ( name == i18n ( " Default " ) ) parentStyle = m_styleManager -> defaultStyle ( ) ; else parentStyle = m_styleManager -> style ( name ) ; } else parentStyle = m_styleManager -> defaultStyle ( ) ; int i = 1 ; QString newName ( i18n ( " style % 1" , m_styleManager -> count ( ) + i ) ) ; while ( m_styleManager -> style ( newName ) != 0 ) { ++ i ; newName = i18n ( " style % 1" , m_styleManager -> count ( ) + i ) ; } KCCustomStyle * style = new KCCustomStyle ( newName , parentStyle ) ; style -> setType ( KCStyle :: TENTATIVE ) ; QPointer < CellFormatDialog > dialog = new CellFormatDialog ( this , m_selection , style , m_styleManager ) ; dialog -> exec ( ) ; delete dialog ; if ( style -> type ( ) == KCStyle :: TENTATIVE ) { delete style ; return ; } m_styleManager -> m_styles [ style -> name ( ) ] = style ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; } void StyleManagerDialog :: slotEdit ( ) { QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) return ; KCCustomStyle * style = 0 ; QString name ( item -> text ( 0 ) ) ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) return ; QPointer < CellFormatDialog > dialog = new CellFormatDialog ( this , m_selection , style , m_styleManager ) ; dialog -> exec ( ) ; if ( dialog -> result ( ) == Accepted ) m_selection -> emitRefreshSheetViews ( ) ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; delete dialog ; } void StyleManagerDialog :: slotRemove ( ) { QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) return ; const QString name = item -> text ( 0 ) ; KCCustomStyle * style = 0 ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) return ; if ( style -> type ( ) != KCStyle :: CUSTOM ) return ; m_styleManager -> takeStyle ( style ) ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; } void StyleManagerDialog :: selectionChanged ( QTreeWidgetItem * item ) { if ( ! item ) return ; const QString name = item -> text ( 0 ) ; KCCustomStyle * style = 0 ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) { enableButton ( KDialog :: User1 , false ) ; return ; } if ( style -> type ( ) == KCStyle :: BUILTIN ) enableButton ( KDialog :: User1 , false ) ; else enableButton ( KDialog :: User1 , true ) ; } # include " StyleManagerDialog . moc " </DOCUMENT>
