<DOCUMENT_ID="nawawi/wkhtmltopdf/tree/master/webkit/Source/WebCore/bindings/js/JSDocumentCustom.cpp"> # include " config . h " # include " JSDocument . h " # include " ExceptionCode . h " # include " Frame . h " # include " FrameLoader . h " # include " HTMLDocument . h " # include " JSCanvasRenderingContext2D . h " # if ENABLE ( WEBGL ) # include " JSWebGLRenderingContext . h " # endif # include " JSDOMWindowCustom . h " # include " JSHTMLDocument . h " # include " JSLocation . h " # include " JSTouch . h " # include " JSTouchList . h " # include " Location . h " # include " ScriptController . h " # include " TouchList . h " # if ENABLE ( SVG ) # include " JSSVGDocument . h " # include " SVGDocument . h " # endif # include < wtf / GetPtr . h > using namespace JSC ; namespace WebCore { JSValue JSDocument :: location ( ExecState * exec ) const { Frame * frame = static_cast < Document * > ( impl ( ) ) -> frame ( ) ; if ( ! frame ) return jsNull ( ) ; Location * location = frame -> document ( ) -> domWindow ( ) -> location ( ) ; if ( JSDOMWrapper * wrapper = getCachedWrapper ( currentWorld ( exec ) , location ) ) return wrapper ; JSLocation * jsLocation = JSLocation :: create ( getDOMStructure < JSLocation > ( exec , globalObject ( ) ) , globalObject ( ) , location ) ; cacheWrapper ( currentWorld ( exec ) , location , jsLocation ) ; return jsLocation ; } void JSDocument :: setLocation ( ExecState * exec , JSValue value ) { Frame * frame = static_cast < Document * > ( impl ( ) ) -> frame ( ) ; if ( ! frame ) return ; String locationString = value . toString ( exec ) -> value ( exec ) ; if ( exec -> hadException ( ) ) return ; if ( Location * location = frame -> document ( ) -> domWindow ( ) -> location ( ) ) location -> setHref ( locationString , activeDOMWindow ( exec ) , firstDOMWindow ( exec ) ) ; } JSValue toJS ( ExecState * exec , JSDOMGlobalObject * globalObject , Document * document ) { if ( ! document ) return jsNull ( ) ; JSDOMWrapper * wrapper = getCachedWrapper ( currentWorld ( exec ) , document ) ; if ( wrapper ) return wrapper ; if ( DOMWindow * domWindow = document -> domWindow ( ) ) { globalObject = toJSDOMWindow ( toJS ( exec , domWindow ) ) ; wrapper = getCachedWrapper ( currentWorld ( exec ) , document ) ; if ( wrapper ) return wrapper ; } if ( document -> isHTMLDocument ( ) ) wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , HTMLDocument , document ) ; # if ENABLE ( SVG ) else if ( document -> isSVGDocument ( ) ) wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , SVGDocument , document ) ; # endif else wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , Document , document ) ; if ( ! document -> frame ( ) ) { size_t nodeCount = 0 ; for ( Node * n = document ; n ; n = n -> traverseNextNode ( ) ) nodeCount ++ ; exec -> heap ( ) -> reportExtraMemoryCost ( nodeCount * sizeof ( Node ) ) ; } return wrapper ; } # if ENABLE ( TOUCH_EVENTS ) JSValue JSDocument :: createTouchList ( ExecState * exec ) { RefPtr < TouchList > touchList = TouchList :: create ( ) ; for ( size_t i = 0 ; i < exec -> argumentCount ( ) ; i ++ ) touchList -> append ( toTouch ( exec -> argument ( i ) ) ) ; return toJS ( exec , globalObject ( ) , touchList . release ( ) ) ; } # endif } </DOCUMENT>
<DOCUMENT_ID="sunblithe/qt-everywhere-opensource-src-4.7.1/tree/master/src/gui/kernel/qeventdispatcher_x11.cpp"> # include " qeventdispatcher _ x11 _ p . h " # include " qapplication . h " # include " qx11info _ x11 . h " # include " qt _ x11 _ p . h " # include < private / qeventdispatcher_unix_p . h > QT_BEGIN_NAMESPACE class QEventDispatcherX11Private : public QEventDispatcherUNIXPrivate { Q_DECLARE_PUBLIC ( QEventDispatcherX11 ) public : inline QEventDispatcherX11Private ( ) : xfd ( - 1 ) { } int xfd ; QList < XEvent > queuedUserInputEvents ; } ; QEventDispatcherX11 :: QEventDispatcherX11 ( QObject * parent ) : QEventDispatcherUNIX ( * new QEventDispatcherX11Private , parent ) { } QEventDispatcherX11 :: ~ QEventDispatcherX11 ( ) { } bool QEventDispatcherX11 :: processEvents ( QEventLoop :: ProcessEventsFlags flags ) { Q_D ( QEventDispatcherX11 ) ; d -> interrupt = false ; QApplication :: sendPostedEvents ( ) ; ulong marker = XNextRequest ( X11 -> display ) ; int nevents = 0 ; do { while ( ! d -> interrupt ) { XEvent event ; if ( ! ( flags & QEventLoop :: ExcludeUserInputEvents ) && ! d -> queuedUserInputEvents . isEmpty ( ) ) { event = d -> queuedUserInputEvents . takeFirst ( ) ; } else if ( XEventsQueued ( X11 -> display , QueuedAlready ) ) { XNextEvent ( X11 -> display , & event ) ; if ( flags & QEventLoop :: ExcludeUserInputEvents ) { switch ( event . type ) { case ButtonPress : case ButtonRelease : case MotionNotify : case XKeyPress : case XKeyRelease : case EnterNotify : case LeaveNotify : d -> queuedUserInputEvents . append ( event ) ; continue ; case ClientMessage : if ( event . xclient . format == 32 ) { if ( event . xclient . message_type == ATOM ( WM_PROTOCOLS ) && ( Atom ) event . xclient . data . l [ 0 ] == ATOM ( WM_TAKE_FOCUS ) ) { break ; } else if ( event . xclient . message_type == ATOM ( _QT_SCROLL_DONE ) ) { break ; } } d -> queuedUserInputEvents . append ( event ) ; continue ; default : break ; } } } else { break ; } if ( filterEvent ( & event ) ) continue ; nevents ++ ; if ( qApp -> x11ProcessEvent ( & event ) == 1 ) return true ; if ( event . xany . serial >= marker ) { if ( XEventsQueued ( X11 -> display , QueuedAfterFlush ) ) flags &= ~ QEventLoop :: WaitForMoreEvents ; goto out ; } } } while ( ! d -> interrupt && XEventsQueued ( X11 -> display , QueuedAfterFlush ) ) ; out : if ( ! d -> interrupt ) { const uint exclude_all = QEventLoop :: ExcludeSocketNotifiers | QEventLoop :: X11ExcludeTimers | QEventLoop :: WaitForMoreEvents ; if ( nevents > 0 && ( ( uint ) flags & exclude_all ) == exclude_all ) { QApplication :: sendPostedEvents ( ) ; return nevents > 0 ; } return QEventDispatcherUNIX :: processEvents ( flags ) || ( nevents > 0 ) ; } return nevents > 0 ; } bool QEventDispatcherX11 :: hasPendingEvents ( ) { extern uint qGlobalPostedEventsCount ( ) ; return ( qGlobalPostedEventsCount ( ) || XPending ( X11 -> display ) ) ; } void QEventDispatcherX11 :: flush ( ) { XFlush ( X11 -> display ) ; } void QEventDispatcherX11 :: startingUp ( ) { Q_D ( QEventDispatcherX11 ) ; d -> xfd = XConnectionNumber ( X11 -> display ) ; } void QEventDispatcherX11 :: closingDown ( ) { Q_D ( QEventDispatcherX11 ) ; d -> xfd = - 1 ; } int QEventDispatcherX11 :: select ( int nfds , fd_set * readfds , fd_set * writefds , fd_set * exceptfds , timeval * timeout ) { Q_D ( QEventDispatcherX11 ) ; if ( d -> xfd > 0 ) { nfds = qMax ( nfds - 1 , d -> xfd ) + 1 ; FD_SET ( d -> xfd , readfds ) ; } return QEventDispatcherUNIX :: select ( nfds , readfds , writefds , exceptfds , timeout ) ; } QT_END_NAMESPACE </DOCUMENT>
<DOCUMENT_ID="PGer/incubator-hawq/tree/master/src/backend/access/parquet/metadatautil_c++/Metadatainterface.cpp"> # include < iostream > # include < stdint . h > # include < boost / shared_ptr . hpp > # include < boost / math_fwd . hpp > # include < thrift / protocol / TBinaryProtocol . h > # include < fcntl . h > # include < fstream > # include < stdio . h > # include < bitset > # include " MetadataUtil . h " using namespace hawq ; using namespace std ; using namespace boost ; extern " C " { # include " postgres . h " # include " utils / palloc . h " int readPageMetadata ( uint8_t * buf , uint32_t * len , int compact , struct PageMetadata_4C * * ppageMetdata ) { * ppageMetdata = ( struct PageMetadata_4C * ) palloc0 ( sizeof ( struct PageMetadata_4C ) ) ; bool compactBool = ( compact == 1 ) ? true : false ; int iret = MetadataUtil :: readPageMetadata ( buf , len , compactBool , * ppageMetdata ) ; return iret ; } int writePageMetadata ( uint8_t * * buf , uint32_t * len , struct PageMetadata_4C * ppageMetadata ) { int iret = MetadataUtil :: writePageMetadata ( buf , len , ppageMetadata ) ; return iret ; } int writeColumnChunkMetadata ( uint8_t * * buf , uint32_t * len , struct ColumnChunkMetadata_4C * blockMetadata ) { int iret = MetadataUtil :: writeColumnChunkMetadata ( buf , len , blockMetadata ) ; return iret ; } } </DOCUMENT>
<DOCUMENT_ID="JIghtuse/functional-cpp/tree/master/src/functional_objects/company.cpp"> # include < company . h > # include < algorithm > class lambda_implementation { public : lambda_implementation ( const Company * _this , const std :: string & teamName ) : m_this { _this } , m_teamName { teamName } { } bool operator ( ) ( const Person & employee ) const { return m_this -> teamNameFor ( employee ) == m_teamName ; } private : const Company * m_this ; const std :: string & m_teamName ; } ; int Company :: countTeamMembers ( const std :: string & teamName ) const { return std :: count_if ( m_employees . cbegin ( ) , m_employees . cend ( ) , [ this , & teamName ] ( const Person & p ) { return teamNameFor ( p ) == teamName ; } ) ; } std :: string Company :: teamNameFor ( const Person & ) const { return " some " ; } </DOCUMENT>
<DOCUMENT_ID="domin1101/malmo-challenge/tree/master/cpp/src/main.cpp"> # include " LightBulbApp / App . hpp " # include < wx / wxprec . h > # include " PigChase / PigChaseEvolution . hpp " # include " PigChase / TensorflowExporter . hpp " int main ( int argc , char * * argv ) { LightBulb :: App * app = new LightBulb :: App ( ) ; app -> addTrainingPlan ( new PigChaseEvolution ( ) ) ; app -> addExporter ( new TensorflowExporter ( ) ) ; wxApp :: SetInstance ( app ) ; wxEntry ( argc , argv ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="grokys/coreclr/tree/master/src/vm/common.cpp"> # include " common . h " </DOCUMENT>
<DOCUMENT_ID="jmanday/Master/tree/master/TFM/library/boost_1_63_0/libs/icl/test/fastest_split_interval_set_/fastest_split_interval_set.cpp"> # define BOOST_TEST_MODULE icl :: split_interval_set unit test # include < libs / icl / test / disable_test_warnings . hpp > # include < string > # include < boost / mpl / list . hpp > # include " . . / unit _ test _ unwarned . hpp " # include " . . / test _ type _ lists . hpp " # include " . . / test _ value _ maker . hpp " # include < boost / icl / split_interval_set . hpp > using namespace std ; using namespace boost ; using namespace unit_test ; using namespace boost :: icl ; # include " . . / test _ interval _ set _ shared . hpp " # define INTERVAL_SET split_interval_set # include " . . / fastest _ interval _ set _ cases . hpp " </DOCUMENT>
<DOCUMENT_ID="hoangt/goblin-core/tree/master/riscv/llvm/3.5/llvm-3.5.0.src/lib/Target/Mips/MipsSEFrameLowering.cpp"> # include " MipsSEFrameLowering . h " # include " MCTargetDesc / MipsBaseInfo . h " # include " MipsAnalyzeImmediate . h " # include " MipsMachineFunction . h " # include " MipsSEInstrInfo . h " # include " MipsSubtarget . h " # include " llvm / CodeGen / MachineFrameInfo . h " # include " llvm / CodeGen / MachineFunction . h " # include " llvm / CodeGen / MachineInstrBuilder . h " # include " llvm / CodeGen / MachineModuleInfo . h " # include " llvm / CodeGen / MachineRegisterInfo . h " # include " llvm / CodeGen / RegisterScavenging . h " # include " llvm / IR / DataLayout . h " # include " llvm / IR / Function . h " # include " llvm / Support / CommandLine . h " # include " llvm / Target / TargetOptions . h " using namespace llvm ; namespace { typedef MachineBasicBlock :: iterator Iter ; static std :: pair < unsigned , unsigned > getMFHiLoOpc ( unsigned Src ) { if ( Mips :: ACC64RegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: PseudoMFHI , ( unsigned ) Mips :: PseudoMFLO ) ; if ( Mips :: ACC64DSPRegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: MFHI_DSP , ( unsigned ) Mips :: MFLO_DSP ) ; if ( Mips :: ACC128RegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: PseudoMFHI64 , ( unsigned ) Mips :: PseudoMFLO64 ) ; return std :: make_pair ( 0 , 0 ) ; } class ExpandPseudo { public : ExpandPseudo ( MachineFunction & MF ) ; bool expand ( ) ; private : bool expandInstr ( MachineBasicBlock & MBB , Iter I ) ; void expandLoadCCond ( MachineBasicBlock & MBB , Iter I ) ; void expandStoreCCond ( MachineBasicBlock & MBB , Iter I ) ; void expandLoadACC ( MachineBasicBlock & MBB , Iter I , unsigned RegSize ) ; void expandStoreACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc , unsigned RegSize ) ; bool expandCopy ( MachineBasicBlock & MBB , Iter I ) ; bool expandCopyACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc ) ; bool expandBuildPairF64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool FP64 ) const ; bool expandExtractElementF64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool FP64 ) const ; MachineFunction & MF ; MachineRegisterInfo & MRI ; } ; } ExpandPseudo :: ExpandPseudo ( MachineFunction & MF_ ) : MF ( MF_ ) , MRI ( MF . getRegInfo ( ) ) { } bool ExpandPseudo :: expand ( ) { bool Expanded = false ; for ( MachineFunction :: iterator BB = MF . begin ( ) , BBEnd = MF . end ( ) ; BB != BBEnd ; ++ BB ) for ( Iter I = BB -> begin ( ) , End = BB -> end ( ) ; I != End ; ) Expanded |= expandInstr ( * BB , I ++ ) ; return Expanded ; } bool ExpandPseudo :: expandInstr ( MachineBasicBlock & MBB , Iter I ) { switch ( I -> getOpcode ( ) ) { case Mips :: LOAD_CCOND_DSP : expandLoadCCond ( MBB , I ) ; break ; case Mips :: STORE_CCOND_DSP : expandStoreCCond ( MBB , I ) ; break ; case Mips :: LOAD_ACC64 : case Mips :: LOAD_ACC64DSP : expandLoadACC ( MBB , I , 4 ) ; break ; case Mips :: LOAD_ACC128 : expandLoadACC ( MBB , I , 8 ) ; break ; case Mips :: STORE_ACC64 : expandStoreACC ( MBB , I , Mips :: PseudoMFHI , Mips :: PseudoMFLO , 4 ) ; break ; case Mips :: STORE_ACC64DSP : expandStoreACC ( MBB , I , Mips :: MFHI_DSP , Mips :: MFLO_DSP , 4 ) ; break ; case Mips :: STORE_ACC128 : expandStoreACC ( MBB , I , Mips :: PseudoMFHI64 , Mips :: PseudoMFLO64 , 8 ) ; break ; case Mips :: BuildPairF64 : if ( expandBuildPairF64 ( MBB , I , false ) ) MBB . erase ( I ) ; return false ; case Mips :: BuildPairF64_64 : if ( expandBuildPairF64 ( MBB , I , true ) ) MBB . erase ( I ) ; return false ; case Mips :: ExtractElementF64 : if ( expandExtractElementF64 ( MBB , I , false ) ) MBB . erase ( I ) ; return false ; case Mips :: ExtractElementF64_64 : if ( expandExtractElementF64 ( MBB , I , true ) ) MBB . erase ( I ) ; return false ; case TargetOpcode :: COPY : if ( ! expandCopy ( MBB , I ) ) return false ; break ; default : return false ; } MBB . erase ( I ) ; return true ; } void ExpandPseudo :: expandLoadCCond ( MachineBasicBlock & MBB , Iter I ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( 4 ) ; unsigned VR = MRI . createVirtualRegister ( RC ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; TII . loadRegFromStack ( MBB , I , VR , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , I -> getDebugLoc ( ) , TII . get ( TargetOpcode :: COPY ) , Dst ) . addReg ( VR , RegState :: Kill ) ; } void ExpandPseudo :: expandStoreCCond ( MachineBasicBlock & MBB , Iter I ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( 4 ) ; unsigned VR = MRI . createVirtualRegister ( RC ) ; unsigned Src = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; BuildMI ( MBB , I , I -> getDebugLoc ( ) , TII . get ( TargetOpcode :: COPY ) , VR ) . addReg ( Src , getKillRegState ( I -> getOperand ( 0 ) . isKill ( ) ) ) ; TII . storeRegToStack ( MBB , I , VR , true , FI , RC , & RegInfo , 0 ) ; } void ExpandPseudo :: expandLoadACC ( MachineBasicBlock & MBB , Iter I , unsigned RegSize ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( RegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; unsigned Lo = RegInfo . getSubReg ( Dst , Mips :: sub_lo ) ; unsigned Hi = RegInfo . getSubReg ( Dst , Mips :: sub_hi ) ; DebugLoc DL = I -> getDebugLoc ( ) ; const MCInstrDesc & Desc = TII . get ( TargetOpcode :: COPY ) ; TII . loadRegFromStack ( MBB , I , VR0 , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , DL , Desc , Lo ) . addReg ( VR0 , RegState :: Kill ) ; TII . loadRegFromStack ( MBB , I , VR1 , FI , RC , & RegInfo , RegSize ) ; BuildMI ( MBB , I , DL , Desc , Hi ) . addReg ( VR1 , RegState :: Kill ) ; } void ExpandPseudo :: expandStoreACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc , unsigned RegSize ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( RegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned Src = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; unsigned SrcKill = getKillRegState ( I -> getOperand ( 0 ) . isKill ( ) ) ; DebugLoc DL = I -> getDebugLoc ( ) ; BuildMI ( MBB , I , DL , TII . get ( MFLoOpc ) , VR0 ) . addReg ( Src ) ; TII . storeRegToStack ( MBB , I , VR0 , true , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , DL , TII . get ( MFHiOpc ) , VR1 ) . addReg ( Src , SrcKill ) ; TII . storeRegToStack ( MBB , I , VR1 , true , FI , RC , & RegInfo , RegSize ) ; } bool ExpandPseudo :: expandCopy ( MachineBasicBlock & MBB , Iter I ) { unsigned Src = I -> getOperand ( 1 ) . getReg ( ) ; std :: pair < unsigned , unsigned > Opcodes = getMFHiLoOpc ( Src ) ; if ( ! Opcodes . first ) return false ; return expandCopyACC ( MBB , I , Opcodes . first , Opcodes . second ) ; } bool ExpandPseudo :: expandCopyACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc ) { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , Src = I -> getOperand ( 1 ) . getReg ( ) ; unsigned VRegSize = RegInfo . getMinimalPhysRegClass ( Dst ) -> getSize ( ) / 2 ; const TargetRegisterClass * RC = RegInfo . intRegClass ( VRegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned SrcKill = getKillRegState ( I -> getOperand ( 1 ) . isKill ( ) ) ; unsigned DstLo = RegInfo . getSubReg ( Dst , Mips :: sub_lo ) ; unsigned DstHi = RegInfo . getSubReg ( Dst , Mips :: sub_hi ) ; DebugLoc DL = I -> getDebugLoc ( ) ; BuildMI ( MBB , I , DL , TII . get ( MFLoOpc ) , VR0 ) . addReg ( Src ) ; BuildMI ( MBB , I , DL , TII . get ( TargetOpcode :: COPY ) , DstLo ) . addReg ( VR0 , RegState :: Kill ) ; BuildMI ( MBB , I , DL , TII . get ( MFHiOpc ) , VR1 ) . addReg ( Src , SrcKill ) ; BuildMI ( MBB , I , DL , TII . get ( TargetOpcode :: COPY ) , DstHi ) . addReg ( VR1 , RegState :: Kill ) ; return true ; } bool ExpandPseudo :: expandBuildPairF64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool FP64 ) const { const TargetMachine & TM = MF . getTarget ( ) ; const MipsSubtarget & Subtarget = TM . getSubtarget < MipsSubtarget > ( ) ; if ( ( Subtarget . isABI_FPXX ( ) && ! Subtarget . hasMTHC1 ( ) ) || ( FP64 && ! Subtarget . useOddSPReg ( ) ) ) { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( TM . getInstrInfo ( ) ) ; const MipsRegisterInfo & TRI = * static_cast < const MipsRegisterInfo * > ( TM . getRegisterInfo ( ) ) ; unsigned DstReg = I -> getOperand ( 0 ) . getReg ( ) ; unsigned LoReg = I -> getOperand ( 1 ) . getReg ( ) ; unsigned HiReg = I -> getOperand ( 2 ) . getReg ( ) ; assert ( Subtarget . isGP64bit ( ) || Subtarget . hasMTHC1 ( ) || ! Subtarget . isFP64bit ( ) ) ; const TargetRegisterClass * RC = & Mips :: GPR32RegClass ; const TargetRegisterClass * RC2 = FP64 ? & Mips :: FGR64RegClass : & Mips :: AFGR64RegClass ; int FI = MF . getInfo < MipsFunctionInfo > ( ) -> getMoveF64ViaSpillFI ( RC2 ) ; TII . storeRegToStack ( MBB , I , LoReg , I -> getOperand ( 1 ) . isKill ( ) , FI , RC , & TRI , 0 ) ; TII . storeRegToStack ( MBB , I , HiReg , I -> getOperand ( 2 ) . isKill ( ) , FI , RC , & TRI , 4 ) ; TII . loadRegFromStack ( MBB , I , DstReg , FI , RC2 , & TRI , 0 ) ; return true ; } return false ; } bool ExpandPseudo :: expandExtractElementF64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool FP64 ) const { const TargetMachine & TM = MF . getTarget ( ) ; const MipsSubtarget & Subtarget = TM . getSubtarget < MipsSubtarget > ( ) ; if ( ( Subtarget . isABI_FPXX ( ) && ! Subtarget . hasMTHC1 ( ) ) || ( FP64 && ! Subtarget . useOddSPReg ( ) ) ) { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( TM . getInstrInfo ( ) ) ; const MipsRegisterInfo & TRI = * static_cast < const MipsRegisterInfo * > ( TM . getRegisterInfo ( ) ) ; unsigned DstReg = I -> getOperand ( 0 ) . getReg ( ) ; unsigned SrcReg = I -> getOperand ( 1 ) . getReg ( ) ; unsigned N = I -> getOperand ( 2 ) . getImm ( ) ; assert ( Subtarget . isGP64bit ( ) || Subtarget . hasMTHC1 ( ) || ! Subtarget . isFP64bit ( ) ) ; const TargetRegisterClass * RC = FP64 ? & Mips :: FGR64RegClass : & Mips :: AFGR64RegClass ; const TargetRegisterClass * RC2 = & Mips :: GPR32RegClass ; int FI = MF . getInfo < MipsFunctionInfo > ( ) -> getMoveF64ViaSpillFI ( RC ) ; TII . storeRegToStack ( MBB , I , SrcReg , I -> getOperand ( 1 ) . isKill ( ) , FI , RC , & TRI , 0 ) ; TII . loadRegFromStack ( MBB , I , DstReg , FI , RC2 , & TRI , N * 4 ) ; return true ; } return false ; } MipsSEFrameLowering :: MipsSEFrameLowering ( const MipsSubtarget & STI ) : MipsFrameLowering ( STI , STI . stackAlignment ( ) ) { } unsigned MipsSEFrameLowering :: ehDataReg ( unsigned I ) const { static const unsigned EhDataReg [ ] = { Mips :: A0 , Mips :: A1 , Mips :: A2 , Mips :: A3 } ; static const unsigned EhDataReg64 [ ] = { Mips :: A0_64 , Mips :: A1_64 , Mips :: A2_64 , Mips :: A3_64 } ; return STI . isABI_N64 ( ) ? EhDataReg64 [ I ] : EhDataReg [ I ] ; } void MipsSEFrameLowering :: emitPrologue ( MachineFunction & MF ) const { MachineBasicBlock & MBB = MF . front ( ) ; MachineFrameInfo * MFI = MF . getFrameInfo ( ) ; MipsFunctionInfo * MipsFI = MF . getInfo < MipsFunctionInfo > ( ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; MachineBasicBlock :: iterator MBBI = MBB . begin ( ) ; DebugLoc dl = MBBI != MBB . end ( ) ? MBBI -> getDebugLoc ( ) : DebugLoc ( ) ; unsigned SP = STI . isABI_N64 ( ) ? Mips :: SP_64 : Mips :: SP ; unsigned FP = STI . isABI_N64 ( ) ? Mips :: FP_64 : Mips :: FP ; unsigned ZERO = STI . isABI_N64 ( ) ? Mips :: ZERO_64 : Mips :: ZERO ; unsigned ADDu = STI . isABI_N64 ( ) ? Mips :: DADDu : Mips :: ADDu ; uint64_t StackSize = MFI -> getStackSize ( ) ; if ( StackSize == 0 && ! MFI -> adjustsStack ( ) ) return ; MachineModuleInfo & MMI = MF . getMMI ( ) ; const MCRegisterInfo * MRI = MMI . getContext ( ) . getRegisterInfo ( ) ; MachineLocation DstML , SrcML ; TII . adjustStackPtr ( SP , - StackSize , MBB , MBBI ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createDefCfaOffset ( nullptr , - StackSize ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; const std :: vector < CalleeSavedInfo > & CSI = MFI -> getCalleeSavedInfo ( ) ; if ( CSI . size ( ) ) { for ( unsigned i = 0 ; i < CSI . size ( ) ; ++ i ) ++ MBBI ; for ( std :: vector < CalleeSavedInfo > :: const_iterator I = CSI . begin ( ) , E = CSI . end ( ) ; I != E ; ++ I ) { int64_t Offset = MFI -> getObjectOffset ( I -> getFrameIdx ( ) ) ; unsigned Reg = I -> getReg ( ) ; if ( Mips :: AFGR64RegClass . contains ( Reg ) ) { unsigned Reg0 = MRI -> getDwarfRegNum ( RegInfo . getSubReg ( Reg , Mips :: sub_lo ) , true ) ; unsigned Reg1 = MRI -> getDwarfRegNum ( RegInfo . getSubReg ( Reg , Mips :: sub_hi ) , true ) ; if ( ! STI . isLittle ( ) ) std :: swap ( Reg0 , Reg1 ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg0 , Offset ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg1 , Offset + 4 ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } else if ( Mips :: FGR64RegClass . contains ( Reg ) ) { unsigned Reg0 = MRI -> getDwarfRegNum ( Reg , true ) ; unsigned Reg1 = MRI -> getDwarfRegNum ( Reg , true ) + 1 ; if ( ! STI . isLittle ( ) ) std :: swap ( Reg0 , Reg1 ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg0 , Offset ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg1 , Offset + 4 ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } else { unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , MRI -> getDwarfRegNum ( Reg , 1 ) , Offset ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } } } if ( MipsFI -> callsEhReturn ( ) ) { const TargetRegisterClass * RC = STI . isABI_N64 ( ) ? & Mips :: GPR64RegClass : & Mips :: GPR32RegClass ; for ( int I = 0 ; I < 4 ; ++ I ) { if ( ! MBB . isLiveIn ( ehDataReg ( I ) ) ) MBB . addLiveIn ( ehDataReg ( I ) ) ; TII . storeRegToStackSlot ( MBB , MBBI , ehDataReg ( I ) , false , MipsFI -> getEhDataRegFI ( I ) , RC , & RegInfo ) ; } for ( int I = 0 ; I < 4 ; ++ I ) { int64_t Offset = MFI -> getObjectOffset ( MipsFI -> getEhDataRegFI ( I ) ) ; unsigned Reg = MRI -> getDwarfRegNum ( ehDataReg ( I ) , true ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg , Offset ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } } if ( hasFP ( MF ) ) { BuildMI ( MBB , MBBI , dl , TII . get ( ADDu ) , FP ) . addReg ( SP ) . addReg ( ZERO ) . setMIFlag ( MachineInstr :: FrameSetup ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createDefCfaRegister ( nullptr , MRI -> getDwarfRegNum ( FP , true ) ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } } void MipsSEFrameLowering :: emitEpilogue ( MachineFunction & MF , MachineBasicBlock & MBB ) const { MachineBasicBlock :: iterator MBBI = MBB . getLastNonDebugInstr ( ) ; MachineFrameInfo * MFI = MF . getFrameInfo ( ) ; MipsFunctionInfo * MipsFI = MF . getInfo < MipsFunctionInfo > ( ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; DebugLoc dl = MBBI -> getDebugLoc ( ) ; unsigned SP = STI . isABI_N64 ( ) ? Mips :: SP_64 : Mips :: SP ; unsigned FP = STI . isABI_N64 ( ) ? Mips :: FP_64 : Mips :: FP ; unsigned ZERO = STI . isABI_N64 ( ) ? Mips :: ZERO_64 : Mips :: ZERO ; unsigned ADDu = STI . isABI_N64 ( ) ? Mips :: DADDu : Mips :: ADDu ; if ( hasFP ( MF ) ) { MachineBasicBlock :: iterator I = MBBI ; for ( unsigned i = 0 ; i < MFI -> getCalleeSavedInfo ( ) . size ( ) ; ++ i ) -- I ; BuildMI ( MBB , I , dl , TII . get ( ADDu ) , SP ) . addReg ( FP ) . addReg ( ZERO ) ; } if ( MipsFI -> callsEhReturn ( ) ) { const TargetRegisterClass * RC = STI . isABI_N64 ( ) ? & Mips :: GPR64RegClass : & Mips :: GPR32RegClass ; MachineBasicBlock :: iterator I = MBBI ; for ( unsigned i = 0 ; i < MFI -> getCalleeSavedInfo ( ) . size ( ) ; ++ i ) -- I ; for ( int J = 0 ; J < 4 ; ++ J ) { TII . loadRegFromStackSlot ( MBB , I , ehDataReg ( J ) , MipsFI -> getEhDataRegFI ( J ) , RC , & RegInfo ) ; } } uint64_t StackSize = MFI -> getStackSize ( ) ; if ( ! StackSize ) return ; TII . adjustStackPtr ( SP , StackSize , MBB , MBBI ) ; } bool MipsSEFrameLowering :: spillCalleeSavedRegisters ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator MI , const std :: vector < CalleeSavedInfo > & CSI , const TargetRegisterInfo * TRI ) const { MachineFunction * MF = MBB . getParent ( ) ; MachineBasicBlock * EntryBlock = MF -> begin ( ) ; const TargetInstrInfo & TII = * MF -> getTarget ( ) . getInstrInfo ( ) ; for ( unsigned i = 0 , e = CSI . size ( ) ; i != e ; ++ i ) { unsigned Reg = CSI [ i ] . getReg ( ) ; bool IsRAAndRetAddrIsTaken = ( Reg == Mips :: RA || Reg == Mips :: RA_64 ) && MF -> getFrameInfo ( ) -> isReturnAddressTaken ( ) ; if ( ! IsRAAndRetAddrIsTaken ) EntryBlock -> addLiveIn ( Reg ) ; bool IsKill = ! IsRAAndRetAddrIsTaken ; const TargetRegisterClass * RC = TRI -> getMinimalPhysRegClass ( Reg ) ; TII . storeRegToStackSlot ( * EntryBlock , MI , Reg , IsKill , CSI [ i ] . getFrameIdx ( ) , RC , TRI ) ; } return true ; } bool MipsSEFrameLowering :: hasReservedCallFrame ( const MachineFunction & MF ) const { const MachineFrameInfo * MFI = MF . getFrameInfo ( ) ; return isInt < 16 > ( MFI -> getMaxCallFrameSize ( ) + getStackAlignment ( ) ) && ! MFI -> hasVarSizedObjects ( ) ; } void MipsSEFrameLowering :: eliminateCallFramePseudoInstr ( MachineFunction & MF , MachineBasicBlock & MBB , MachineBasicBlock :: iterator I ) const { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; if ( ! hasReservedCallFrame ( MF ) ) { int64_t Amount = I -> getOperand ( 0 ) . getImm ( ) ; if ( I -> getOpcode ( ) == Mips :: ADJCALLSTACKDOWN ) Amount = - Amount ; unsigned SP = STI . isABI_N64 ( ) ? Mips :: SP_64 : Mips :: SP ; TII . adjustStackPtr ( SP , Amount , MBB , I ) ; } MBB . erase ( I ) ; } void MipsSEFrameLowering :: processFunctionBeforeCalleeSavedScan ( MachineFunction & MF , RegScavenger * RS ) const { MachineRegisterInfo & MRI = MF . getRegInfo ( ) ; MipsFunctionInfo * MipsFI = MF . getInfo < MipsFunctionInfo > ( ) ; unsigned FP = STI . isABI_N64 ( ) ? Mips :: FP_64 : Mips :: FP ; if ( hasFP ( MF ) ) MRI . setPhysRegUsed ( FP ) ; if ( MipsFI -> callsEhReturn ( ) ) MipsFI -> createEhDataRegsFI ( ) ; if ( ExpandPseudo ( MF ) . expand ( ) ) { const TargetRegisterClass * RC = STI . hasMips64 ( ) ? & Mips :: GPR64RegClass : & Mips :: GPR32RegClass ; int FI = MF . getFrameInfo ( ) -> CreateStackObject ( RC -> getSize ( ) , RC -> getAlignment ( ) , false ) ; RS -> addScavengingFrameIndex ( FI ) ; } uint64_t MaxSPOffset = MF . getInfo < MipsFunctionInfo > ( ) -> getIncomingArgSize ( ) + estimateStackSize ( MF ) ; if ( isInt < 16 > ( MaxSPOffset ) ) return ; const TargetRegisterClass * RC = STI . isABI_N64 ( ) ? & Mips :: GPR64RegClass : & Mips :: GPR32RegClass ; int FI = MF . getFrameInfo ( ) -> CreateStackObject ( RC -> getSize ( ) , RC -> getAlignment ( ) , false ) ; RS -> addScavengingFrameIndex ( FI ) ; } const MipsFrameLowering * llvm :: createMipsSEFrameLowering ( const MipsSubtarget & ST ) { return new MipsSEFrameLowering ( ST ) ; } </DOCUMENT>
<DOCUMENT_ID="doorxp/ccjson/tree/master/cocos2d/cocos/audio/android/AudioResampler.cpp"> # define LOG_TAG " AudioResampler " # include < stdint . h > # include < stdlib . h > # include < sys / types . h > # include < pthread . h > # include < new > # include " audio / android / cutils / log . h " # include " audio / android / utils / Utils . h " # include " audio / android / audio _ utils / include / audio _ utils / primitives . h " # include " audio / android / AudioResampler . h " # include " audio / android / AudioResamplerCubic . h " namespace cocos2d { namespace experimental { class AudioResamplerOrder1 : public AudioResampler { public : AudioResamplerOrder1 ( int inChannelCount , int32_t sampleRate ) : AudioResampler ( inChannelCount , sampleRate , LOW_QUALITY ) , mX0L ( 0 ) , mX0R ( 0 ) { } virtual size_t resample ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) ; private : static const int kNumInterpBits = 15 ; static const int kPreInterpShift = kNumPhaseBits - kNumInterpBits ; void init ( ) { } size_t resampleMono16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) ; size_t resampleStereo16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) ; # ifdef ASM_ARM_RESAMP1 void AsmMono16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) ; void AsmStereo16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) ; # endif static inline int32_t Interp ( int32_t x0 , int32_t x1 , uint32_t f ) { return x0 + ( ( ( x1 - x0 ) * ( int32_t ) ( f >> kPreInterpShift ) ) >> kNumInterpBits ) ; } static inline void Advance ( size_t * index , uint32_t * frac , uint32_t inc ) { * frac += inc ; * index += ( size_t ) ( * frac >> kNumPhaseBits ) ; * frac &= kPhaseMask ; } int mX0L ; int mX0R ; } ; const double AudioResampler :: kPhaseMultiplier = 1L << AudioResampler :: kNumPhaseBits ; bool AudioResampler :: qualityIsSupported ( src_quality quality ) { switch ( quality ) { case DEFAULT_QUALITY : case LOW_QUALITY : case MED_QUALITY : case HIGH_QUALITY : case VERY_HIGH_QUALITY : return true ; default : return false ; } } static pthread_once_t once_control = PTHREAD_ONCE_INIT ; static AudioResampler :: src_quality defaultQuality = AudioResampler :: DEFAULT_QUALITY ; void AudioResampler :: init_routine ( ) { } uint32_t AudioResampler :: qualityMHz ( src_quality quality ) { switch ( quality ) { default : case DEFAULT_QUALITY : case LOW_QUALITY : return 3 ; case MED_QUALITY : return 6 ; case HIGH_QUALITY : return 20 ; case VERY_HIGH_QUALITY : return 34 ; } } static const uint32_t maxMHz = 130 ; static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER ; static uint32_t currentMHz = 0 ; AudioResampler * AudioResampler :: create ( audio_format_t format , int inChannelCount , int32_t sampleRate , src_quality quality ) { bool atFinalQuality ; if ( quality == DEFAULT_QUALITY ) { int ok = pthread_once ( & once_control , init_routine ) ; if ( ok != 0 ) { ALOGE ( " % s ▁ pthread _ once ▁ failed : ▁ % d " , __func__ , ok ) ; } quality = defaultQuality ; atFinalQuality = false ; } else { atFinalQuality = true ; } if ( quality == DEFAULT_QUALITY ) { } pthread_mutex_lock ( & mutex ) ; for ( ; ; ) { uint32_t deltaMHz = qualityMHz ( quality ) ; uint32_t newMHz = currentMHz + deltaMHz ; if ( ( qualityIsSupported ( quality ) && newMHz <= maxMHz ) || atFinalQuality ) { ALOGV ( " resampler ▁ load ▁ % u ▁ - > ▁ % u ▁ MHz ▁ due ▁ to ▁ delta ▁ + % u ▁ MHz ▁ from ▁ quality ▁ % d " , currentMHz , newMHz , deltaMHz , quality ) ; currentMHz = newMHz ; break ; } switch ( quality ) { default : case LOW_QUALITY : atFinalQuality = true ; break ; case MED_QUALITY : quality = LOW_QUALITY ; break ; case HIGH_QUALITY : quality = MED_QUALITY ; break ; case VERY_HIGH_QUALITY : quality = HIGH_QUALITY ; break ; } } pthread_mutex_unlock ( & mutex ) ; AudioResampler * resampler ; switch ( quality ) { default : case LOW_QUALITY : ALOGV ( " Create ▁ linear ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; resampler = new ( std :: nothrow ) AudioResamplerOrder1 ( inChannelCount , sampleRate ) ; break ; case MED_QUALITY : ALOGV ( " Create ▁ cubic ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; resampler = new ( std :: nothrow ) AudioResamplerCubic ( inChannelCount , sampleRate ) ; break ; case HIGH_QUALITY : ALOGV ( " Create ▁ HIGH _ QUALITY ▁ sinc ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; ALOG_ASSERT ( false , " HIGH _ QUALITY ▁ isn ' t ▁ supported " ) ; break ; case VERY_HIGH_QUALITY : ALOGV ( " Create ▁ VERY _ HIGH _ QUALITY ▁ sinc ▁ Resampler ▁ = ▁ % d " , quality ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; ALOG_ASSERT ( false , " VERY _ HIGH _ QUALITY ▁ isn ' t ▁ supported " ) ; break ; } resampler -> init ( ) ; return resampler ; } AudioResampler :: AudioResampler ( int inChannelCount , int32_t sampleRate , src_quality quality ) : mChannelCount ( inChannelCount ) , mSampleRate ( sampleRate ) , mInSampleRate ( sampleRate ) , mInputIndex ( 0 ) , mPhaseFraction ( 0 ) , mLocalTimeFreq ( 0 ) , mPTS ( AudioBufferProvider :: kInvalidPTS ) , mQuality ( quality ) { const int maxChannels = 2 ; if ( inChannelCount < 1 || inChannelCount > maxChannels ) { LOG_ALWAYS_FATAL ( " Unsupported ▁ sample ▁ format ▁ % d ▁ quality ▁ % d ▁ channels " , quality , inChannelCount ) ; } if ( sampleRate <= 0 ) { LOG_ALWAYS_FATAL ( " Unsupported ▁ sample ▁ rate ▁ % d ▁ Hz " , sampleRate ) ; } mVolume [ 0 ] = mVolume [ 1 ] = 0 ; mBuffer . frameCount = 0 ; } AudioResampler :: ~ AudioResampler ( ) { pthread_mutex_lock ( & mutex ) ; src_quality quality = getQuality ( ) ; uint32_t deltaMHz = qualityMHz ( quality ) ; int32_t newMHz = currentMHz - deltaMHz ; ALOGV ( " resampler ▁ load ▁ % u ▁ - > ▁ % d ▁ MHz ▁ due ▁ to ▁ delta ▁ - % u ▁ MHz ▁ from ▁ quality ▁ % d " , currentMHz , newMHz , deltaMHz , quality ) ; LOG_ALWAYS_FATAL_IF ( newMHz < 0 , " negative ▁ resampler ▁ load ▁ % d ▁ MHz " , newMHz ) ; currentMHz = newMHz ; pthread_mutex_unlock ( & mutex ) ; } void AudioResampler :: setSampleRate ( int32_t inSampleRate ) { mInSampleRate = inSampleRate ; mPhaseIncrement = ( uint32_t ) ( ( kPhaseMultiplier * inSampleRate ) / mSampleRate ) ; } void AudioResampler :: setVolume ( float left , float right ) { mVolume [ 0 ] = u4_12_from_float ( clampFloatVol ( left ) ) ; mVolume [ 1 ] = u4_12_from_float ( clampFloatVol ( right ) ) ; } void AudioResampler :: setLocalTimeFreq ( uint64_t freq ) { mLocalTimeFreq = freq ; } void AudioResampler :: setPTS ( int64_t pts ) { mPTS = pts ; } int64_t AudioResampler :: calculateOutputPTS ( int outputFrameIndex ) { if ( mPTS == AudioBufferProvider :: kInvalidPTS ) { return AudioBufferProvider :: kInvalidPTS ; } else { return mPTS + ( ( outputFrameIndex * mLocalTimeFreq ) / mSampleRate ) ; } } void AudioResampler :: reset ( ) { mInputIndex = 0 ; mPhaseFraction = 0 ; mBuffer . frameCount = 0 ; } size_t AudioResamplerOrder1 :: resample ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { switch ( mChannelCount ) { case 1 : return resampleMono16 ( out , outFrameCount , provider ) ; case 2 : return resampleStereo16 ( out , outFrameCount , provider ) ; default : LOG_ALWAYS_FATAL ( " invalid ▁ channel ▁ count : ▁ % d " , mChannelCount ) ; return 0 ; } } size_t AudioResamplerOrder1 :: resampleStereo16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { int32_t vl = mVolume [ 0 ] ; int32_t vr = mVolume [ 1 ] ; size_t inputIndex = mInputIndex ; uint32_t phaseFraction = mPhaseFraction ; uint32_t phaseIncrement = mPhaseIncrement ; size_t outputIndex = 0 ; size_t outputSampleCount = outFrameCount * 2 ; size_t inFrameCount = getInFrameCountRequired ( outFrameCount ) ; while ( outputIndex < outputSampleCount ) { while ( mBuffer . frameCount == 0 ) { mBuffer . frameCount = inFrameCount ; provider -> getNextBuffer ( & mBuffer , calculateOutputPTS ( outputIndex / 2 ) ) ; if ( mBuffer . raw == NULL ) { goto resampleStereo16_exit ; } if ( mBuffer . frameCount > inputIndex ) break ; inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount * 2 - 2 ] ; mX0R = mBuffer . i16 [ mBuffer . frameCount * 2 - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } int16_t * in = mBuffer . i16 ; while ( inputIndex == 0 ) { out [ outputIndex ++ ] += vl * Interp ( mX0L , in [ 0 ] , phaseFraction ) ; out [ outputIndex ++ ] += vr * Interp ( mX0R , in [ 1 ] , phaseFraction ) ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; if ( outputIndex == outputSampleCount ) { break ; } } # ifdef ASM_ARM_RESAMP1 if ( inputIndex + 2 < mBuffer . frameCount ) { int32_t * maxOutPt ; int32_t maxInIdx ; maxOutPt = out + ( outputSampleCount - 2 ) ; maxInIdx = mBuffer . frameCount - 2 ; AsmStereo16Loop ( in , maxOutPt , maxInIdx , outputIndex , out , inputIndex , vl , vr , phaseFraction , phaseIncrement ) ; } # endif while ( outputIndex < outputSampleCount && inputIndex < mBuffer . frameCount ) { out [ outputIndex ++ ] += vl * Interp ( in [ inputIndex * 2 - 2 ] , in [ inputIndex * 2 ] , phaseFraction ) ; out [ outputIndex ++ ] += vr * Interp ( in [ inputIndex * 2 - 1 ] , in [ inputIndex * 2 + 1 ] , phaseFraction ) ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; } if ( inputIndex >= mBuffer . frameCount ) { inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount * 2 - 2 ] ; mX0R = mBuffer . i16 [ mBuffer . frameCount * 2 - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } } resampleStereo16_exit : mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; return outputIndex / 2 ; } size_t AudioResamplerOrder1 :: resampleMono16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { int32_t vl = mVolume [ 0 ] ; int32_t vr = mVolume [ 1 ] ; size_t inputIndex = mInputIndex ; uint32_t phaseFraction = mPhaseFraction ; uint32_t phaseIncrement = mPhaseIncrement ; size_t outputIndex = 0 ; size_t outputSampleCount = outFrameCount * 2 ; size_t inFrameCount = getInFrameCountRequired ( outFrameCount ) ; while ( outputIndex < outputSampleCount ) { while ( mBuffer . frameCount == 0 ) { mBuffer . frameCount = inFrameCount ; provider -> getNextBuffer ( & mBuffer , calculateOutputPTS ( outputIndex / 2 ) ) ; if ( mBuffer . raw == NULL ) { mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; goto resampleMono16_exit ; } if ( mBuffer . frameCount > inputIndex ) break ; inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } int16_t * in = mBuffer . i16 ; while ( inputIndex == 0 ) { int32_t sample = Interp ( mX0L , in [ 0 ] , phaseFraction ) ; out [ outputIndex ++ ] += vl * sample ; out [ outputIndex ++ ] += vr * sample ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; if ( outputIndex == outputSampleCount ) { break ; } } # ifdef ASM_ARM_RESAMP1 if ( inputIndex + 2 < mBuffer . frameCount ) { int32_t * maxOutPt ; int32_t maxInIdx ; maxOutPt = out + ( outputSampleCount - 2 ) ; maxInIdx = ( int32_t ) mBuffer . frameCount - 2 ; AsmMono16Loop ( in , maxOutPt , maxInIdx , outputIndex , out , inputIndex , vl , vr , phaseFraction , phaseIncrement ) ; } # endif while ( outputIndex < outputSampleCount && inputIndex < mBuffer . frameCount ) { int32_t sample = Interp ( in [ inputIndex - 1 ] , in [ inputIndex ] , phaseFraction ) ; out [ outputIndex ++ ] += vl * sample ; out [ outputIndex ++ ] += vr * sample ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; } if ( inputIndex >= mBuffer . frameCount ) { inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } } resampleMono16_exit : mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; return outputIndex ; } # ifdef ASM_ARM_RESAMP1 __attribute__ ( ( noinline ) ) void AudioResamplerOrder1 :: AsmMono16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) { ( void ) maxOutPt ; ( void ) maxInIdx ; ( void ) outputIndex ; ( void ) out ; ( void ) inputIndex ; ( void ) vl ; ( void ) vr ; ( void ) phaseFraction ; ( void ) phaseIncrement ; ( void ) in ; # define MO_PARAM5 "36" asm ( " stmfd ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ lr } \n " " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 20 ] \n " " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ r6 ] \n " " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 8 ] \n " " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ r7 ] \n " " ▁ ▁ ▁ ldr ▁ r8 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 4 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ r0 ] \n " " ▁ ▁ ▁ add ▁ r8 , ▁ r8 , ▁ r0 , ▁ asl ▁ # 2 \n " " ▁ ▁ ▁ ldr ▁ r9 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 24 ] \n " " ▁ ▁ ▁ ldr ▁ r10 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 12 ] \n " " ▁ ▁ ▁ ldr ▁ r11 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 16 ] \n " "1 : \n " " ▁ ▁ ▁ cmp ▁ r8 , ▁ r2 \n " " ▁ ▁ ▁ bcs ▁ 2f \n " # define MO_ONE_FRAME " ▁ ▁ ▁ add ▁ r0 , ▁ r1 , ▁ r7 , ▁ asl ▁ # 1 \n " " ▁ ▁ ▁ ldrsh ▁ r4 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r5 , ▁ [ r8 ] \n " " ▁ ▁ ▁ ldrsh ▁ r0 , ▁ [ r0 , ▁ # -2 ] \n " " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " " ▁ ▁ ▁ sub ▁ r4 , ▁ r4 , ▁ r0 \n " " ▁ ▁ ▁ mov ▁ r4 , ▁ r4 , ▁ lsl ▁ # 2 \n " " ▁ ▁ ▁ smulwt ▁ r4 , ▁ r4 , ▁ r6 \n " " ▁ ▁ ▁ add ▁ r6 , ▁ r6 , ▁ r9 \n " " ▁ ▁ ▁ add ▁ r0 , ▁ r0 , ▁ r4 \n " " ▁ ▁ ▁ mla ▁ r5 , ▁ r0 , ▁ r10 , ▁ r5 \n " " ▁ ▁ ▁ ldr ▁ r4 , ▁ [ r8 , ▁ # 4 ] \n " " ▁ ▁ ▁ str ▁ r5 , ▁ [ r8 ] , ▁ # 4 \n " " ▁ ▁ ▁ mla ▁ r4 , ▁ r0 , ▁ r11 , ▁ r4 \n " " ▁ ▁ ▁ add ▁ r7 , ▁ r7 , ▁ r6 , ▁ lsr ▁ # 30 \n " " ▁ ▁ ▁ str ▁ r4 , ▁ [ r8 ] , ▁ # 4 \n " MO_ONE_FRAME MO_ONE_FRAME " ▁ ▁ ▁ cmp ▁ r7 , ▁ r3 \n " " ▁ ▁ ▁ bcc ▁ 1b \n " "2 : \n " " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 20 ] \n " " ▁ ▁ ▁ str ▁ r6 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 8 ] \n " " ▁ ▁ ▁ str ▁ r7 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 4 ] \n " " ▁ ▁ ▁ sub ▁ r8 , ▁ r0 \n " " ▁ ▁ ▁ asr ▁ r8 , ▁ # 2 \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 0 ] \n " " ▁ ▁ ▁ str ▁ r8 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldmfd ▁ ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ pc } \n " ) ; } __attribute__ ( ( noinline ) ) void AudioResamplerOrder1 :: AsmStereo16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) { ( void ) maxOutPt ; ( void ) maxInIdx ; ( void ) outputIndex ; ( void ) out ; ( void ) inputIndex ; ( void ) vl ; ( void ) vr ; ( void ) phaseFraction ; ( void ) phaseIncrement ; ( void ) in ; # define ST_PARAM5 "40" asm ( " stmfd ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ r12 , ▁ lr } \n " " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 20 ] \n " " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ r6 ] \n " " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 8 ] \n " " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ r7 ] \n " " ▁ ▁ ▁ ldr ▁ r8 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 4 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ r0 ] \n " " ▁ ▁ ▁ add ▁ r8 , ▁ r8 , ▁ r0 , ▁ asl ▁ # 2 \n " " ▁ ▁ ▁ ldr ▁ r9 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 24 ] \n " " ▁ ▁ ▁ ldr ▁ r10 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 12 ] \n " " ▁ ▁ ▁ ldr ▁ r11 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 16 ] \n " "3 : \n " " ▁ ▁ ▁ cmp ▁ r8 , ▁ r2 \n " " ▁ ▁ ▁ bcs ▁ 4f \n " # define ST_ONE_FRAME " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " " ▁ ▁ ▁ add ▁ r0 , ▁ r1 , ▁ r7 , ▁ asl ▁ # 2 \n " " ▁ ▁ ▁ ldrsh ▁ r4 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r5 , ▁ [ r8 ] \n " " ▁ ▁ ▁ ldrsh ▁ r12 , ▁ [ r0 , ▁ # -4 ] \n " " ▁ ▁ ▁ sub ▁ r4 , ▁ r4 , ▁ r12 \n " " ▁ ▁ ▁ mov ▁ r4 , ▁ r4 , ▁ lsl ▁ # 2 \n " " ▁ ▁ ▁ smulwt ▁ r4 , ▁ r4 , ▁ r6 \n " " ▁ ▁ ▁ add ▁ r12 , ▁ r12 , ▁ r4 \n " " ▁ ▁ ▁ mla ▁ r5 , ▁ r12 , ▁ r10 , ▁ r5 \n " " ▁ ▁ ▁ ldr ▁ r4 , ▁ [ r8 , ▁ # 4 ] \n " " ▁ ▁ ▁ str ▁ r5 , ▁ [ r8 ] , ▁ # 4 \n " " ▁ ▁ ▁ ldrsh ▁ r12 , ▁ [ r0 , ▁ # + 2 ] \n " " ▁ ▁ ▁ ldrsh ▁ r0 , ▁ [ r0 , ▁ # -2 ] \n " " ▁ ▁ ▁ sub ▁ r12 , ▁ r12 , ▁ r0 \n " " ▁ ▁ ▁ mov ▁ r12 , ▁ r12 , ▁ lsl ▁ # 2 \n " " ▁ ▁ ▁ smulwt ▁ r12 , ▁ r12 , ▁ r6 \n " " ▁ ▁ ▁ add ▁ r12 , ▁ r0 , ▁ r12 \n " " ▁ ▁ ▁ mla ▁ r4 , ▁ r12 , ▁ r11 , ▁ r4 \n " " ▁ ▁ ▁ str ▁ r4 , ▁ [ r8 ] , ▁ # 4 \n " " ▁ ▁ ▁ add ▁ r6 , ▁ r6 , ▁ r9 \n " " ▁ ▁ ▁ add ▁ r7 , ▁ r7 , ▁ r6 , ▁ lsr ▁ # 30 \n " ST_ONE_FRAME ST_ONE_FRAME " ▁ ▁ ▁ cmp ▁ r7 , ▁ r3 \n " " ▁ ▁ ▁ bcc ▁ 3b \n " "4 : \n " " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 20 ] \n " " ▁ ▁ ▁ str ▁ r6 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 8 ] \n " " ▁ ▁ ▁ str ▁ r7 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 4 ] \n " " ▁ ▁ ▁ sub ▁ r8 , ▁ r0 \n " " ▁ ▁ ▁ asr ▁ r8 , ▁ # 2 \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 0 ] \n " " ▁ ▁ ▁ str ▁ r8 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldmfd ▁ ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ r12 , ▁ pc } \n " ) ; } # endif } } </DOCUMENT>
<DOCUMENT_ID="sjsinju/coreclr/tree/master/src/pal/tests/palsuite/c_runtime/fmod/test1/test1.cpp"> # include < palsuite . h > # define PAL_EPSILON 8.8817841970012523e - 16 # define PAL_NAN sqrt ( - 1.0 ) # define PAL_POSINF - log ( 0.0 ) # define PAL_NEGINF log ( 0.0 ) struct test { double numerator ; double denominator ; double expected ; double variance ; } ; void __cdecl validate ( double numerator , double denominator , double expected , double variance ) { double result = fmod ( numerator , denominator ) ; double delta = fabs ( result - expected ) ; if ( delta > variance ) { Fail ( " fmod ( % g , ▁ % g ) ▁ returned ▁ % 20.17g ▁ when ▁ it ▁ should ▁ have ▁ returned ▁ % 20.17g " , numerator , denominator , result , expected ) ; } } void __cdecl validate_isnan ( double numerator , double denominator ) { double result = fmod ( numerator , denominator ) ; if ( ! _isnan ( result ) ) { Fail ( " fmod ( % g , ▁ % g ) ▁ returned ▁ % 20.17g ▁ when ▁ it ▁ should ▁ have ▁ returned ▁ % 20.17g " , numerator , denominator , result , PAL_NAN ) ; } } INT __cdecl main ( INT argc , CHAR * * argv ) { struct test tests [ ] = { { 0 , PAL_POSINF , 0 , PAL_EPSILON } , { 0.31296179620778659 , 0.94976571538163866 , 0.31296179620778658 , PAL_EPSILON } , { 0.42077048331375735 , 0.90716712923909839 , 0.42077048331375733 , PAL_EPSILON } , { 0.59448076852482208 , 0.80410982822879171 , 0.59448076852482212 , PAL_EPSILON } , { 0.63896127631363480 , 0.76923890136397213 , 0.63896127631363475 , PAL_EPSILON } , { 0.64963693908006244 , 0.76024459707563015 , 0.64963693908006248 , PAL_EPSILON } , { 0.70710678118654752 , 0.70710678118654752 , 0 , PAL_EPSILON } , { 1 , 1 , 0 , PAL_EPSILON } , { 0.84147098480789651 , 0.54030230586813972 , 0.30116867893975674 , PAL_EPSILON } , { 0.90371945743584630 , 0.42812514788535792 , 0.047469161665130377 , PAL_EPSILON / 10 } , { 0.98776594599273553 , 0.15594369476537447 , 0.052103777400488605 , PAL_EPSILON / 10 } , { 0.99180624439366372 , 0.12775121753523991 , 0.097547721646984359 , PAL_EPSILON / 10 } , { 0.74398033695749319 , - 0.66820151019031295 , 0.075778826767180285 , PAL_EPSILON / 10 } , { 0.41078129050290870 , - 0.91173391478696510 , 0.41078129050290868 , PAL_EPSILON } , { 0 , - 1 , 0 , PAL_EPSILON } , { 1 , PAL_POSINF , 1 , PAL_EPSILON * 10 } , } ; if ( PAL_Initialize ( argc , argv ) != 0 ) { return FAIL ; } for ( int i = 0 ; i < ( sizeof ( tests ) / sizeof ( struct test ) ) ; i ++ ) { validate ( tests [ i ] . numerator , tests [ i ] . denominator , tests [ i ] . expected , tests [ i ] . variance ) ; validate ( - tests [ i ] . numerator , tests [ i ] . denominator , - tests [ i ] . expected , tests [ i ] . variance ) ; validate ( tests [ i ] . numerator , - tests [ i ] . denominator , tests [ i ] . expected , tests [ i ] . variance ) ; validate ( - tests [ i ] . numerator , - tests [ i ] . denominator , - tests [ i ] . expected , tests [ i ] . variance ) ; } validate_isnan ( 0 , 0 ) ; validate_isnan ( - 0.0 , 0 ) ; validate_isnan ( 0 , - 0.0 ) ; validate_isnan ( - 0.0 , - 0.0 ) ; validate_isnan ( 1 , 0 ) ; validate_isnan ( - 1.0 , 0 ) ; validate_isnan ( 1 , - 0.0 ) ; validate_isnan ( - 1.0 , - 0.0 ) ; validate_isnan ( PAL_POSINF , PAL_POSINF ) ; validate_isnan ( PAL_NEGINF , PAL_POSINF ) ; validate_isnan ( PAL_POSINF , PAL_NEGINF ) ; validate_isnan ( PAL_NEGINF , PAL_NEGINF ) ; validate_isnan ( PAL_POSINF , 0 ) ; validate_isnan ( PAL_NEGINF , 0 ) ; validate_isnan ( PAL_POSINF , - 0.0 ) ; validate_isnan ( PAL_NEGINF , - 0.0 ) ; validate_isnan ( PAL_POSINF , 1 ) ; validate_isnan ( PAL_NEGINF , 1 ) ; validate_isnan ( PAL_POSINF , - 1.0 ) ; validate_isnan ( PAL_NEGINF , - 1.0 ) ; PAL_Terminate ( ) ; return PASS ; } </DOCUMENT>
<DOCUMENT_ID="dklann/rivendell/tree/master/lib/rdlist_logs.cpp"> # include " rdapplication . h " # include " rddb . h " # include " rdescape _ string . h " # include " rdlist _ logs . h " RDListLogs :: RDListLogs ( QString * logname , RDLogFilter :: FilterMode mode , QWidget * parent ) : RDDialog ( parent ) { list_logname = logname ; setMinimumSize ( sizeHint ( ) ) ; setWindowTitle ( tr ( " Select ▁ Log " ) ) ; list_filter_widget = new RDLogFilter ( mode , this ) ; connect ( list_filter_widget , SIGNAL ( filterChanged ( const QString & ) ) , this , SLOT ( filterChangedData ( const QString & ) ) ) ; list_log_list = new Q3ListView ( this ) ; list_log_list -> setAllColumnsShowFocus ( true ) ; list_log_list -> setItemMargin ( 5 ) ; list_log_list -> setSelectionMode ( Q3ListView :: Single ) ; connect ( list_log_list , SIGNAL ( doubleClicked ( Q3ListViewItem * , const QPoint & , int ) ) , this , SLOT ( doubleClickedData ( Q3ListViewItem * , const QPoint & , int ) ) ) ; list_log_list -> addColumn ( tr ( " Name " ) ) ; list_log_list -> setColumnAlignment ( 0 , Qt :: AlignLeft ) ; list_log_list -> addColumn ( tr ( " Description " ) ) ; list_log_list -> setColumnAlignment ( 1 , Qt :: AlignLeft ) ; list_log_list -> addColumn ( tr ( " Service " ) ) ; list_log_list -> setColumnAlignment ( 2 , Qt :: AlignLeft ) ; list_ok_button = new QPushButton ( this ) ; list_ok_button -> setFont ( buttonFont ( ) ) ; list_ok_button -> setText ( tr ( " OK " ) ) ; connect ( list_ok_button , SIGNAL ( clicked ( ) ) , this , SLOT ( okButtonData ( ) ) ) ; list_cancel_button = new QPushButton ( this ) ; list_cancel_button -> setFont ( buttonFont ( ) ) ; list_cancel_button -> setText ( tr ( " Cancel " ) ) ; list_cancel_button -> setDefault ( true ) ; connect ( list_cancel_button , SIGNAL ( clicked ( ) ) , this , SLOT ( cancelButtonData ( ) ) ) ; RefreshList ( ) ; } QSize RDListLogs :: sizeHint ( ) const { return QSize ( 500 , 300 ) ; } QSizePolicy RDListLogs :: sizePolicy ( ) const { return QSizePolicy ( QSizePolicy :: Fixed , QSizePolicy :: Fixed ) ; } void RDListLogs :: closeEvent ( QCloseEvent * e ) { done ( 1 ) ; } void RDListLogs :: filterChangedData ( const QString & where_sql ) { RefreshList ( ) ; } void RDListLogs :: doubleClickedData ( Q3ListViewItem * , const QPoint & , int ) { okButtonData ( ) ; } void RDListLogs :: okButtonData ( ) { Q3ListViewItem * item = list_log_list -> selectedItem ( ) ; if ( item == NULL ) { return ; } * list_logname = item -> text ( 0 ) ; done ( 0 ) ; } void RDListLogs :: cancelButtonData ( ) { done ( 1 ) ; } void RDListLogs :: resizeEvent ( QResizeEvent * e ) { list_filter_widget -> setGeometry ( 10 , 10 , size ( ) . width ( ) - 10 , list_filter_widget -> sizeHint ( ) . height ( ) ) ; list_log_list -> setGeometry ( 10 , list_filter_widget -> sizeHint ( ) . height ( ) , size ( ) . width ( ) - 20 , size ( ) . height ( ) - list_filter_widget -> sizeHint ( ) . height ( ) - 70 ) ; list_ok_button -> setGeometry ( size ( ) . width ( ) - 190 , size ( ) . height ( ) - 60 , 80 , 50 ) ; list_cancel_button -> setGeometry ( size ( ) . width ( ) - 90 , size ( ) . height ( ) - 60 , 80 , 50 ) ; } void RDListLogs :: RefreshList ( ) { RDSqlQuery * q ; QString sql ; Q3ListViewItem * l ; Q3ListViewItem * view_item = NULL ; QDate current_date = QDate :: currentDate ( ) ; list_log_list -> clear ( ) ; sql = QString ( " select ▁ NAME , DESCRIPTION , SERVICE ▁ from ▁ LOGS ▁ " ) + " where ▁ ( TYPE = 0 ) & & ( LOG _ EXISTS = \ " Y\ " ) & & " + " ( ( START _ DATE < = \ " " + current_date . toString ( " yyyy - MM - dd " ) + " \ " ) | | " + " ( START _ DATE = \ " 0000-00-00\ " ) | | " + " ( START _ DATE ▁ is ▁ null ) ) & & " + " ( ( END _ DATE > = \ " " + current_date . toString ( " yyyy - MM - dd " ) + " \ " ) | | " + " ( END _ DATE = \ " 0000-00-00\ " ) | | " + " ( END _ DATE ▁ is ▁ null ) ) " + list_filter_widget -> whereSql ( ) ; q = new RDSqlQuery ( sql ) ; while ( q -> next ( ) ) { l = new Q3ListViewItem ( list_log_list ) ; l -> setText ( 0 , q -> value ( 0 ) . toString ( ) ) ; l -> setText ( 1 , q -> value ( 1 ) . toString ( ) ) ; l -> setText ( 2 , q -> value ( 2 ) . toString ( ) ) ; if ( l -> text ( 0 ) == * list_logname ) { view_item = l ; } } delete q ; if ( view_item != NULL ) { list_log_list -> setCurrentItem ( view_item ) ; list_log_list -> ensureItemVisible ( view_item ) ; } } </DOCUMENT>
<DOCUMENT_ID="gavoski/audacity/tree/master/lib-src/taglib/tests/test_map.cpp"> # include < cppunit / extensions / HelperMacros . h > # include < tstring . h > # include < tmap . h > using namespace std ; using namespace TagLib ; class TestMap : public CppUnit :: TestFixture { CPPUNIT_TEST_SUITE ( TestMap ) ; CPPUNIT_TEST ( testInsert ) ; CPPUNIT_TEST_SUITE_END ( ) ; public : void testInsert ( ) { Map < String , int > m ; m . insert ( " foo " , 3 ) ; CPPUNIT_ASSERT_EQUAL ( 3 , m [ " foo " ] ) ; m . insert ( " foo " , 7 ) ; CPPUNIT_ASSERT_EQUAL ( 7 , m [ " foo " ] ) ; } } ; CPPUNIT_TEST_SUITE_REGISTRATION ( TestMap ) ; </DOCUMENT>
<DOCUMENT_ID="root-mirror/root/tree/master/interpreter/llvm/src/tools/llvm-pdbutil/PrettyExternalSymbolDumper.cpp"> # include " PrettyExternalSymbolDumper . h " # include " LinePrinter . h " # include " llvm / DebugInfo / PDB / PDBSymbolExe . h " # include " llvm / DebugInfo / PDB / PDBSymbolPublicSymbol . h " # include " llvm / Support / Format . h " using namespace llvm ; using namespace llvm :: pdb ; ExternalSymbolDumper :: ExternalSymbolDumper ( LinePrinter & P ) : PDBSymDumper ( true ) , Printer ( P ) { } void ExternalSymbolDumper :: start ( const PDBSymbolExe & Symbol ) { auto Vars = Symbol . findAllChildren < PDBSymbolPublicSymbol > ( ) ; while ( auto Var = Vars -> getNext ( ) ) Var -> dump ( * this ) ; } void ExternalSymbolDumper :: dump ( const PDBSymbolPublicSymbol & Symbol ) { std :: string LinkageName = Symbol . getName ( ) ; if ( Printer . IsSymbolExcluded ( LinkageName ) ) return ; Printer . NewLine ( ) ; uint64_t Addr = Symbol . getVirtualAddress ( ) ; Printer << " [ " ; WithColor ( Printer , PDB_ColorItem :: Address ) . get ( ) << format_hex ( Addr , 10 ) ; Printer << " ] ▁ " ; WithColor ( Printer , PDB_ColorItem :: Identifier ) . get ( ) << LinkageName ; } </DOCUMENT>
<DOCUMENT_ID="huan5765/codelite-translate2chinese/tree/master/sdk/astyle/src/ASResource.cpp"> # include " astyle . h " namespace astyle { const string ASResource :: AS_IF = string ( " if " ) ; const string ASResource :: AS_ELSE = string ( " else " ) ; const string ASResource :: AS_FOR = string ( " for " ) ; const string ASResource :: AS_DO = string ( " do " ) ; const string ASResource :: AS_WHILE = string ( " while " ) ; const string ASResource :: AS_SWITCH = string ( " switch " ) ; const string ASResource :: AS_CASE = string ( " case " ) ; const string ASResource :: AS_DEFAULT = string ( " default " ) ; const string ASResource :: AS_CLASS = string ( " class " ) ; const string ASResource :: AS_STRUCT = string ( " struct " ) ; const string ASResource :: AS_UNION = string ( " union " ) ; const string ASResource :: AS_INTERFACE = string ( " interface " ) ; const string ASResource :: AS_NAMESPACE = string ( " namespace " ) ; const string ASResource :: AS_EXTERN = string ( " extern " ) ; const string ASResource :: AS_PUBLIC = string ( " public " ) ; const string ASResource :: AS_PROTECTED = string ( " protected " ) ; const string ASResource :: AS_PRIVATE = string ( " private " ) ; const string ASResource :: AS_STATIC = string ( " static " ) ; const string ASResource :: AS_SYNCHRONIZED = string ( " synchronized " ) ; const string ASResource :: AS_OPERATOR = string ( " operator " ) ; const string ASResource :: AS_TEMPLATE = string ( " template " ) ; const string ASResource :: AS_TRY = string ( " try " ) ; const string ASResource :: AS_CATCH = string ( " catch " ) ; const string ASResource :: AS_FINALLY = string ( " finally " ) ; const string ASResource :: AS_THROWS = string ( " throws " ) ; const string ASResource :: AS_CONST = string ( " const " ) ; const string ASResource :: AS_ASM = string ( " asm " ) ; const string ASResource :: AS_BAR_DEFINE = string ( " # define " ) ; const string ASResource :: AS_BAR_INCLUDE = string ( " # include " ) ; const string ASResource :: AS_BAR_IF = string ( " # if " ) ; const string ASResource :: AS_BAR_EL = string ( " # el " ) ; const string ASResource :: AS_BAR_ENDIF = string ( " # endif " ) ; const string ASResource :: AS_OPEN_BRACKET = string ( " { " ) ; const string ASResource :: AS_CLOSE_BRACKET = string ( " } " ) ; const string ASResource :: AS_OPEN_LINE_COMMENT = string ( " // " ) ; const string ASResource :: AS_OPEN_COMMENT = string ( " /* " ) ; const string ASResource :: AS_CLOSE_COMMENT = string ( " */ " ) ; const string ASResource :: AS_ASSIGN = string ( " = " ) ; const string ASResource :: AS_PLUS_ASSIGN = string ( " + = " ) ; const string ASResource :: AS_MINUS_ASSIGN = string ( " - = " ) ; const string ASResource :: AS_MULT_ASSIGN = string ( " * = " ) ; const string ASResource :: AS_DIV_ASSIGN = string ( " / = " ) ; const string ASResource :: AS_MOD_ASSIGN = string ( " % = " ) ; const string ASResource :: AS_OR_ASSIGN = string ( " | = " ) ; const string ASResource :: AS_AND_ASSIGN = string ( " & = " ) ; const string ASResource :: AS_XOR_ASSIGN = string ( " ^ = " ) ; const string ASResource :: AS_GR_GR_ASSIGN = string ( " > > = " ) ; const string ASResource :: AS_LS_LS_ASSIGN = string ( " < < = " ) ; const string ASResource :: AS_GR_GR_GR_ASSIGN = string ( " > > > = " ) ; const string ASResource :: AS_LS_LS_LS_ASSIGN = string ( " < < < = " ) ; const string ASResource :: AS_RETURN = string ( " return " ) ; const string ASResource :: AS_EQUAL = string ( " = = " ) ; const string ASResource :: AS_PLUS_PLUS = string ( " + + " ) ; const string ASResource :: AS_MINUS_MINUS = string ( " - - " ) ; const string ASResource :: AS_NOT_EQUAL = string ( " ! = " ) ; const string ASResource :: AS_GR_EQUAL = string ( " > = " ) ; const string ASResource :: AS_GR_GR = string ( " > > " ) ; const string ASResource :: AS_GR_GR_GR = string ( " > > > " ) ; const string ASResource :: AS_LS_EQUAL = string ( " < = " ) ; const string ASResource :: AS_LS_LS = string ( " < < " ) ; const string ASResource :: AS_LS_LS_LS = string ( " < < < " ) ; const string ASResource :: AS_ARROW = string ( " - > " ) ; const string ASResource :: AS_AND = string ( " & & " ) ; const string ASResource :: AS_OR = string ( " | | " ) ; const string ASResource :: AS_COLON_COLON = string ( " : : " ) ; const string ASResource :: AS_PAREN_PAREN = string ( " ( ) " ) ; const string ASResource :: AS_BLPAREN_BLPAREN = string ( " [ ] " ) ; const string ASResource :: AS_PLUS = string ( " + " ) ; const string ASResource :: AS_MINUS = string ( " - " ) ; const string ASResource :: AS_MULT = string ( " * " ) ; const string ASResource :: AS_DIV = string ( " / " ) ; const string ASResource :: AS_MOD = string ( " % " ) ; const string ASResource :: AS_GR = string ( " > " ) ; const string ASResource :: AS_LS = string ( " < " ) ; const string ASResource :: AS_NOT = string ( " ! " ) ; const string ASResource :: AS_BIT_OR = string ( " | " ) ; const string ASResource :: AS_BIT_AND = string ( " & " ) ; const string ASResource :: AS_BIT_NOT = string ( " ~ " ) ; const string ASResource :: AS_BIT_XOR = string ( " ^ " ) ; const string ASResource :: AS_QUESTION = string ( " ? " ) ; const string ASResource :: AS_COLON = string ( " : " ) ; const string ASResource :: AS_COMMA = string ( " , " ) ; const string ASResource :: AS_SEMICOLON = string ( " ; " ) ; const string ASResource :: AS_FOREACH = string ( " foreach " ) ; const string ASResource :: AS_LOCK = string ( " lock " ) ; const string ASResource :: AS_UNSAFE = string ( " unsafe " ) ; const string ASResource :: AS_FIXED = string ( " fixed " ) ; const string ASResource :: AS_GET = string ( " get " ) ; const string ASResource :: AS_SET = string ( " set " ) ; const string ASResource :: AS_ADD = string ( " add " ) ; const string ASResource :: AS_REMOVE = string ( " remove " ) ; const string ASResource :: AS_CONST_CAST = string ( " const _ cast " ) ; const string ASResource :: AS_DYNAMIC_CAST = string ( " dynamic _ cast " ) ; const string ASResource :: AS_REINTERPRET_CAST = string ( " reinterpret _ cast " ) ; const string ASResource :: AS_STATIC_CAST = string ( " static _ cast " ) ; void ASResource :: buildAssignmentOperators ( vector < const string * > & assignmentOperators ) { assignmentOperators . push_back ( & AS_ASSIGN ) ; assignmentOperators . push_back ( & AS_PLUS_ASSIGN ) ; assignmentOperators . push_back ( & AS_MINUS_ASSIGN ) ; assignmentOperators . push_back ( & AS_MULT_ASSIGN ) ; assignmentOperators . push_back ( & AS_DIV_ASSIGN ) ; assignmentOperators . push_back ( & AS_MOD_ASSIGN ) ; assignmentOperators . push_back ( & AS_OR_ASSIGN ) ; assignmentOperators . push_back ( & AS_AND_ASSIGN ) ; assignmentOperators . push_back ( & AS_XOR_ASSIGN ) ; assignmentOperators . push_back ( & AS_GR_GR_GR_ASSIGN ) ; assignmentOperators . push_back ( & AS_GR_GR_ASSIGN ) ; assignmentOperators . push_back ( & AS_LS_LS_ASSIGN ) ; assignmentOperators . push_back ( & AS_LS_LS_LS_ASSIGN ) ; assignmentOperators . push_back ( & AS_RETURN ) ; } void ASResource :: buildCastOperators ( vector < const string * > & castOperators ) { castOperators . push_back ( & AS_CONST_CAST ) ; castOperators . push_back ( & AS_DYNAMIC_CAST ) ; castOperators . push_back ( & AS_REINTERPRET_CAST ) ; castOperators . push_back ( & AS_STATIC_CAST ) ; } void ASResource :: buildHeaders ( vector < const string * > & headers , int fileType , bool beautifier ) { headers . push_back ( & AS_IF ) ; headers . push_back ( & AS_ELSE ) ; headers . push_back ( & AS_FOR ) ; headers . push_back ( & AS_WHILE ) ; headers . push_back ( & AS_DO ) ; headers . push_back ( & AS_SWITCH ) ; headers . push_back ( & AS_TRY ) ; headers . push_back ( & AS_CATCH ) ; if ( beautifier ) { headers . push_back ( & AS_CASE ) ; headers . push_back ( & AS_DEFAULT ) ; headers . push_back ( & AS_CONST ) ; headers . push_back ( & AS_STATIC ) ; headers . push_back ( & AS_EXTERN ) ; headers . push_back ( & AS_TEMPLATE ) ; } if ( fileType == JAVA_TYPE ) { headers . push_back ( & AS_FINALLY ) ; headers . push_back ( & AS_SYNCHRONIZED ) ; } if ( fileType == SHARP_TYPE ) { headers . push_back ( & AS_FINALLY ) ; headers . push_back ( & AS_FOREACH ) ; headers . push_back ( & AS_LOCK ) ; headers . push_back ( & AS_UNSAFE ) ; headers . push_back ( & AS_FIXED ) ; headers . push_back ( & AS_GET ) ; headers . push_back ( & AS_SET ) ; headers . push_back ( & AS_ADD ) ; headers . push_back ( & AS_REMOVE ) ; } } void ASResource :: buildNonAssignmentOperators ( vector < const string * > & nonAssignmentOperators ) { nonAssignmentOperators . push_back ( & AS_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_PLUS_PLUS ) ; nonAssignmentOperators . push_back ( & AS_MINUS_MINUS ) ; nonAssignmentOperators . push_back ( & AS_NOT_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_GR_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_GR_GR_GR ) ; nonAssignmentOperators . push_back ( & AS_GR_GR ) ; nonAssignmentOperators . push_back ( & AS_LS_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_LS_LS_LS ) ; nonAssignmentOperators . push_back ( & AS_LS_LS ) ; nonAssignmentOperators . push_back ( & AS_ARROW ) ; nonAssignmentOperators . push_back ( & AS_AND ) ; nonAssignmentOperators . push_back ( & AS_OR ) ; } void ASResource :: buildNonParenHeaders ( vector < const string * > & nonParenHeaders , int fileType , bool beautifier ) { nonParenHeaders . push_back ( & AS_ELSE ) ; nonParenHeaders . push_back ( & AS_DO ) ; nonParenHeaders . push_back ( & AS_TRY ) ; if ( beautifier ) { nonParenHeaders . push_back ( & AS_CASE ) ; nonParenHeaders . push_back ( & AS_DEFAULT ) ; nonParenHeaders . push_back ( & AS_CONST ) ; nonParenHeaders . push_back ( & AS_STATIC ) ; nonParenHeaders . push_back ( & AS_EXTERN ) ; nonParenHeaders . push_back ( & AS_TEMPLATE ) ; } if ( fileType == JAVA_TYPE ) { nonParenHeaders . push_back ( & AS_FINALLY ) ; } if ( fileType == SHARP_TYPE ) { nonParenHeaders . push_back ( & AS_FINALLY ) ; nonParenHeaders . push_back ( & AS_UNSAFE ) ; nonParenHeaders . push_back ( & AS_GET ) ; nonParenHeaders . push_back ( & AS_SET ) ; nonParenHeaders . push_back ( & AS_ADD ) ; nonParenHeaders . push_back ( & AS_REMOVE ) ; } } void ASResource :: buildOperators ( vector < const string * > & operators ) { operators . push_back ( & AS_PLUS_ASSIGN ) ; operators . push_back ( & AS_MINUS_ASSIGN ) ; operators . push_back ( & AS_MULT_ASSIGN ) ; operators . push_back ( & AS_DIV_ASSIGN ) ; operators . push_back ( & AS_MOD_ASSIGN ) ; operators . push_back ( & AS_OR_ASSIGN ) ; operators . push_back ( & AS_AND_ASSIGN ) ; operators . push_back ( & AS_XOR_ASSIGN ) ; operators . push_back ( & AS_EQUAL ) ; operators . push_back ( & AS_PLUS_PLUS ) ; operators . push_back ( & AS_MINUS_MINUS ) ; operators . push_back ( & AS_NOT_EQUAL ) ; operators . push_back ( & AS_GR_EQUAL ) ; operators . push_back ( & AS_GR_GR_GR_ASSIGN ) ; operators . push_back ( & AS_GR_GR_ASSIGN ) ; operators . push_back ( & AS_GR_GR_GR ) ; operators . push_back ( & AS_GR_GR ) ; operators . push_back ( & AS_LS_EQUAL ) ; operators . push_back ( & AS_LS_LS_LS_ASSIGN ) ; operators . push_back ( & AS_LS_LS_ASSIGN ) ; operators . push_back ( & AS_LS_LS_LS ) ; operators . push_back ( & AS_LS_LS ) ; operators . push_back ( & AS_ARROW ) ; operators . push_back ( & AS_AND ) ; operators . push_back ( & AS_OR ) ; operators . push_back ( & AS_COLON_COLON ) ; operators . push_back ( & AS_PLUS ) ; operators . push_back ( & AS_MINUS ) ; operators . push_back ( & AS_MULT ) ; operators . push_back ( & AS_DIV ) ; operators . push_back ( & AS_MOD ) ; operators . push_back ( & AS_QUESTION ) ; operators . push_back ( & AS_COLON ) ; operators . push_back ( & AS_ASSIGN ) ; operators . push_back ( & AS_LS ) ; operators . push_back ( & AS_GR ) ; operators . push_back ( & AS_NOT ) ; operators . push_back ( & AS_BIT_OR ) ; operators . push_back ( & AS_BIT_AND ) ; operators . push_back ( & AS_BIT_NOT ) ; operators . push_back ( & AS_BIT_XOR ) ; operators . push_back ( & AS_OPERATOR ) ; operators . push_back ( & AS_COMMA ) ; operators . push_back ( & AS_RETURN ) ; } void ASResource :: buildPreBlockStatements ( vector < const string * > & preBlockStatements ) { preBlockStatements . push_back ( & AS_CLASS ) ; preBlockStatements . push_back ( & AS_STRUCT ) ; preBlockStatements . push_back ( & AS_UNION ) ; preBlockStatements . push_back ( & AS_INTERFACE ) ; preBlockStatements . push_back ( & AS_NAMESPACE ) ; preBlockStatements . push_back ( & AS_THROWS ) ; preBlockStatements . push_back ( & AS_EXTERN ) ; } void ASResource :: buildPreCommandHeaders ( vector < const string * > & preCommandHeaders ) { preCommandHeaders . push_back ( & AS_EXTERN ) ; preCommandHeaders . push_back ( & AS_THROWS ) ; preCommandHeaders . push_back ( & AS_CONST ) ; } void ASResource :: buildPreDefinitionHeaders ( vector < const string * > & preDefinitionHeaders ) { preDefinitionHeaders . push_back ( & AS_CLASS ) ; preDefinitionHeaders . push_back ( & AS_INTERFACE ) ; preDefinitionHeaders . push_back ( & AS_NAMESPACE ) ; preDefinitionHeaders . push_back ( & AS_STRUCT ) ; } } </DOCUMENT>
<DOCUMENT_ID="GreenDamTan/ppsspp/tree/master/Core/MIPS/x86/Asm.cpp"> # include " math / math _ util . h " # include " ABI . h " # include " x64Emitter . h " # include " Core / Core . h " # include " Core / MemMap . h " # include " Core / System . h " # include " Core / MIPS / MIPS . h " # include " Core / CoreTiming . h " # include " Common / MemoryUtil . h " # include " Core / MIPS / JitCommon / JitCommon . h " # include " Core / MIPS / x86 / Asm . h " # include " Core / MIPS / x86 / Jit . h " using namespace Gen ; using namespace X64JitConstants ; static bool enableDebug = false ; extern volatile CoreState coreState ; void ImHere ( ) { DEBUG_LOG ( CPU , " JIT ▁ Here : ▁ % 08x " , currentMIPS -> pc ) ; } void AsmRoutineManager :: Generate ( MIPSState * mips , MIPSComp :: Jit * jit , MIPSComp :: JitOptions * jo ) { enterCode = AlignCode16 ( ) ; ABI_PushAllCalleeSavedRegsAndAdjustStack ( ) ; # ifdef _M_X64 MOV ( 64 , R ( MEMBASEREG ) , ImmPtr ( Memory :: base ) ) ; uintptr_t jitbase = ( uintptr_t ) jit -> GetBasePtr ( ) ; if ( jitbase > 0x7FFFFFFFULL ) { MOV ( 64 , R ( JITBASEREG ) , ImmPtr ( jit -> GetBasePtr ( ) ) ) ; jo -> reserveR15ForAsm = true ; } # endif MOV ( PTRBITS , R ( CTXREG ) , ImmPtr ( & mips -> f [ 0 ] ) ) ; outerLoop = GetCodePtr ( ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_CallFunction ( reinterpret_cast < void * > ( & CoreTiming :: Advance ) ) ; jit -> ApplyRoundingMode ( true , this ) ; FixupBranch skipToRealDispatch = J ( ) ; dispatcherCheckCoreState = GetCodePtr ( ) ; FixupBranch bailCoreState = J_CC ( CC_S , true ) ; CMP ( 32 , M ( & coreState ) , Imm32 ( 0 ) ) ; FixupBranch badCoreState = J_CC ( CC_NZ , true ) ; FixupBranch skipToRealDispatch2 = J ( ) ; dispatcher = GetCodePtr ( ) ; FixupBranch bail = J_CC ( CC_S , true ) ; SetJumpTarget ( skipToRealDispatch ) ; SetJumpTarget ( skipToRealDispatch2 ) ; dispatcherNoCheck = GetCodePtr ( ) ; MOV ( 32 , R ( EAX ) , M ( & mips -> pc ) ) ; dispatcherInEAXNoCheck = GetCodePtr ( ) ; # ifdef _M_IX86 AND ( 32 , R ( EAX ) , Imm32 ( Memory :: MEMVIEW32_MASK ) ) ; _assert_msg_ ( CPU , Memory :: base != 0 , " Memory ▁ base ▁ bogus " ) ; MOV ( 32 , R ( EAX ) , MDisp ( EAX , ( u32 ) Memory :: base ) ) ; # elif _M_X64 MOV ( 32 , R ( EAX ) , MComplex ( MEMBASEREG , RAX , SCALE_1 , 0 ) ) ; # endif MOV ( 32 , R ( EDX ) , R ( EAX ) ) ; _assert_msg_ ( JIT , MIPS_JITBLOCK_MASK == 0xFF000000 , " Hardcoded ▁ assumption ▁ of ▁ emuhack ▁ mask " ) ; SHR ( 32 , R ( EDX ) , Imm8 ( 24 ) ) ; CMP ( 32 , R ( EDX ) , Imm8 ( MIPS_EMUHACK_OPCODE >> 24 ) ) ; FixupBranch notfound = J_CC ( CC_NE ) ; if ( enableDebug ) { ADD ( 32 , M ( & mips -> debugCount ) , Imm8 ( 1 ) ) ; } AND ( 32 , R ( EAX ) , Imm32 ( MIPS_EMUHACK_VALUE_MASK ) ) ; # ifdef _M_IX86 ADD ( 32 , R ( EAX ) , ImmPtr ( jit -> GetBasePtr ( ) ) ) ; # elif _M_X64 if ( jo -> reserveR15ForAsm ) ADD ( 64 , R ( RAX ) , R ( JITBASEREG ) ) ; else ADD ( 64 , R ( EAX ) , Imm32 ( jitbase ) ) ; # endif JMPptr ( R ( EAX ) ) ; SetJumpTarget ( notfound ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_CallFunction ( & MIPSComp :: JitAt ) ; jit -> ApplyRoundingMode ( true , this ) ; JMP ( dispatcherNoCheck , true ) ; SetJumpTarget ( bail ) ; SetJumpTarget ( bailCoreState ) ; CMP ( 32 , M ( & coreState ) , Imm32 ( 0 ) ) ; J_CC ( CC_Z , outerLoop , true ) ; SetJumpTarget ( badCoreState ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_PopAllCalleeSavedRegsAndAdjustStack ( ) ; RET ( ) ; breakpointBailout = GetCodePtr ( ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_PopAllCalleeSavedRegsAndAdjustStack ( ) ; RET ( ) ; } </DOCUMENT>
<DOCUMENT_ID="fbergmann/libSEDML/tree/master/sedml/SedDocument.cpp"> # include < sedml / SedDocument . h > # include < sedml / SedTypes . h > # include < sbml / xml / XMLInputStream . h > using namespace std ; LIBSEDML_CPP_NAMESPACE_BEGIN SedDocument :: SedDocument ( unsigned int level , unsigned int version ) : SedBase ( level , version ) , mLevel ( SEDML_INT_MAX ) , mIsSetLevel ( false ) , mVersion ( SEDML_INT_MAX ) , mIsSetVersion ( false ) , mDataDescriptions ( level , version ) , mSimulations ( level , version ) , mModels ( level , version ) , mTasks ( level , version ) , mDataGenerators ( level , version ) , mOutputs ( level , version ) { mLevel = level ; mIsSetLevel = true ; mVersion = version ; mIsSetVersion = true ; setSedDocument ( this ) ; setSedNamespacesAndOwn ( new SedNamespaces ( level , version ) ) ; connectToChild ( ) ; } SedDocument :: SedDocument ( SedNamespaces * sedns ) : SedBase ( sedns ) , mLevel ( SEDML_INT_MAX ) , mIsSetLevel ( false ) , mVersion ( SEDML_INT_MAX ) , mIsSetVersion ( false ) , mDataDescriptions ( sedns ) , mSimulations ( sedns ) , mModels ( sedns ) , mTasks ( sedns ) , mDataGenerators ( sedns ) , mOutputs ( sedns ) { mLevel = sedns -> getLevel ( ) ; mIsSetLevel = true ; mVersion = sedns -> getVersion ( ) ; mIsSetVersion = true ; setSedDocument ( this ) ; setElementNamespace ( sedns -> getURI ( ) ) ; connectToChild ( ) ; } SedDocument :: SedDocument ( const SedDocument & orig ) : SedBase ( orig ) { setSedDocument ( this ) ; mLevel = orig . mLevel ; mIsSetLevel = orig . mIsSetLevel ; mVersion = orig . mVersion ; mIsSetVersion = orig . mIsSetVersion ; mDataDescriptions = orig . mDataDescriptions ; mSimulations = orig . mSimulations ; mModels = orig . mModels ; mTasks = orig . mTasks ; mDataGenerators = orig . mDataGenerators ; mOutputs = orig . mOutputs ; connectToChild ( ) ; } SedDocument & SedDocument :: operator = ( const SedDocument & rhs ) { if ( & rhs != this ) { SedBase :: operator = ( rhs ) ; setSedDocument ( this ) ; mLevel = rhs . mLevel ; mIsSetLevel = rhs . mIsSetLevel ; mVersion = rhs . mVersion ; mIsSetVersion = rhs . mIsSetVersion ; mDataDescriptions = rhs . mDataDescriptions ; mSimulations = rhs . mSimulations ; mModels = rhs . mModels ; mTasks = rhs . mTasks ; mDataGenerators = rhs . mDataGenerators ; mOutputs = rhs . mOutputs ; connectToChild ( ) ; } return * this ; } SedDocument * SedDocument :: clone ( ) const { return new SedDocument ( * this ) ; } SedDocument :: ~ SedDocument ( ) { } const int SedDocument :: getLevel ( ) const { return mLevel ; } const int SedDocument :: getVersion ( ) const { return mVersion ; } bool SedDocument :: isSetLevel ( ) const { return mIsSetLevel ; } bool SedDocument :: isSetVersion ( ) const { return mIsSetVersion ; } int SedDocument :: setLevel ( int level ) { mLevel = level ; mIsSetLevel = true ; return LIBSEDML_OPERATION_SUCCESS ; } int SedDocument :: setVersion ( int version ) { mVersion = version ; mIsSetVersion = true ; return LIBSEDML_OPERATION_SUCCESS ; } int SedDocument :: unsetLevel ( ) { mLevel = SEDML_INT_MAX ; mIsSetLevel = false ; if ( isSetLevel ( ) == false ) { return LIBSEDML_OPERATION_SUCCESS ; } else { return LIBSEDML_OPERATION_FAILED ; } } int SedDocument :: unsetVersion ( ) { mVersion = SEDML_INT_MAX ; mIsSetVersion = false ; if ( isSetVersion ( ) == false ) { return LIBSEDML_OPERATION_SUCCESS ; } else { return LIBSEDML_OPERATION_FAILED ; } } const SedListOfDataDescriptions * SedDocument :: getListOfDataDescriptions ( ) const { return & mDataDescriptions ; } SedDataDescription * SedDocument :: removeDataDescription ( unsigned int n ) { return mDataDescriptions . remove ( n ) ; } SedDataDescription * SedDocument :: removeDataDescription ( const std :: string & sid ) { return mDataDescriptions . remove ( sid ) ; } SedDataDescription * SedDocument :: getDataDescription ( unsigned int n ) { return mDataDescriptions . get ( n ) ; } const SedDataDescription * SedDocument :: getDataDescription ( unsigned int n ) const { return mDataDescriptions . get ( n ) ; } SedDataDescription * SedDocument :: getDataDescription ( const std :: string & sid ) { return mDataDescriptions . get ( sid ) ; } const SedDataDescription * SedDocument :: getDataDescription ( const std :: string & sid ) const { return mDataDescriptions . get ( sid ) ; } int SedDocument :: addDataDescription ( const SedDataDescription * sdd ) { if ( sdd == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mDataDescriptions . append ( sdd ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumDataDescriptions ( ) const { return mDataDescriptions . size ( ) ; } SedDataDescription * SedDocument :: createDataDescription ( ) { SedDataDescription * temp = new SedDataDescription ( ) ; if ( temp != NULL ) mDataDescriptions . appendAndOwn ( temp ) ; return temp ; } const SedListOfSimulations * SedDocument :: getListOfSimulations ( ) const { return & mSimulations ; } SedSimulation * SedDocument :: removeSimulation ( unsigned int n ) { return mSimulations . remove ( n ) ; } SedSimulation * SedDocument :: removeSimulation ( const std :: string & sid ) { return mSimulations . remove ( sid ) ; } SedSimulation * SedDocument :: getSimulation ( unsigned int n ) { return mSimulations . get ( n ) ; } const SedSimulation * SedDocument :: getSimulation ( unsigned int n ) const { return mSimulations . get ( n ) ; } SedSimulation * SedDocument :: getSimulation ( const std :: string & sid ) { return mSimulations . get ( sid ) ; } const SedSimulation * SedDocument :: getSimulation ( const std :: string & sid ) const { return mSimulations . get ( sid ) ; } int SedDocument :: addSimulation ( const SedSimulation * ss ) { if ( ss == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mSimulations . append ( ss ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumSimulations ( ) const { return mSimulations . size ( ) ; } SedUniformTimeCourse * SedDocument :: createUniformTimeCourse ( ) { SedUniformTimeCourse * temp = new SedUniformTimeCourse ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; } SedOneStep * SedDocument :: createOneStep ( ) { SedOneStep * temp = new SedOneStep ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; } SedSteadyState * SedDocument :: createSteadyState ( ) { SedSteadyState * temp = new SedSteadyState ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; } const SedListOfModels * SedDocument :: getListOfModels ( ) const { return & mModels ; } SedModel * SedDocument :: removeModel ( unsigned int n ) { return mModels . remove ( n ) ; } SedModel * SedDocument :: removeModel ( const std :: string & sid ) { return mModels . remove ( sid ) ; } SedModel * SedDocument :: getModel ( unsigned int n ) { return mModels . get ( n ) ; } const SedModel * SedDocument :: getModel ( unsigned int n ) const { return mModels . get ( n ) ; } SedModel * SedDocument :: getModel ( const std :: string & sid ) { return mModels . get ( sid ) ; } const SedModel * SedDocument :: getModel ( const std :: string & sid ) const { return mModels . get ( sid ) ; } int SedDocument :: addModel ( const SedModel * sm ) { if ( sm == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mModels . append ( sm ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumModels ( ) const { return mModels . size ( ) ; } SedModel * SedDocument :: createModel ( ) { SedModel * temp = new SedModel ( ) ; if ( temp != NULL ) mModels . appendAndOwn ( temp ) ; return temp ; } const SedListOfTasks * SedDocument :: getListOfTasks ( ) const { return & mTasks ; } SedTask * SedDocument :: removeTask ( unsigned int n ) { return mTasks . remove ( n ) ; } SedTask * SedDocument :: removeTask ( const std :: string & sid ) { return mTasks . remove ( sid ) ; } SedTask * SedDocument :: getTask ( unsigned int n ) { return mTasks . get ( n ) ; } const SedTask * SedDocument :: getTask ( unsigned int n ) const { return mTasks . get ( n ) ; } SedTask * SedDocument :: getTask ( const std :: string & sid ) { return mTasks . get ( sid ) ; } const SedTask * SedDocument :: getTask ( const std :: string & sid ) const { return mTasks . get ( sid ) ; } int SedDocument :: addTask ( const SedTask * st ) { if ( st == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mTasks . append ( st ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumTasks ( ) const { return mTasks . size ( ) ; } SedTask * SedDocument :: createTask ( ) { SedTask * temp = new SedTask ( ) ; if ( temp != NULL ) mTasks . appendAndOwn ( temp ) ; return temp ; } SedRepeatedTask * SedDocument :: createRepeatedTask ( ) { SedRepeatedTask * temp = new SedRepeatedTask ( ) ; if ( temp != NULL ) mTasks . appendAndOwn ( temp ) ; return temp ; } const SedListOfDataGenerators * SedDocument :: getListOfDataGenerators ( ) const { return & mDataGenerators ; } SedDataGenerator * SedDocument :: removeDataGenerator ( unsigned int n ) { return mDataGenerators . remove ( n ) ; } SedDataGenerator * SedDocument :: removeDataGenerator ( const std :: string & sid ) { return mDataGenerators . remove ( sid ) ; } SedDataGenerator * SedDocument :: getDataGenerator ( unsigned int n ) { return mDataGenerators . get ( n ) ; } const SedDataGenerator * SedDocument :: getDataGenerator ( unsigned int n ) const { return mDataGenerators . get ( n ) ; } SedDataGenerator * SedDocument :: getDataGenerator ( const std :: string & sid ) { return mDataGenerators . get ( sid ) ; } const SedDataGenerator * SedDocument :: getDataGenerator ( const std :: string & sid ) const { return mDataGenerators . get ( sid ) ; } int SedDocument :: addDataGenerator ( const SedDataGenerator * sdg ) { if ( sdg == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mDataGenerators . append ( sdg ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumDataGenerators ( ) const { return mDataGenerators . size ( ) ; } SedDataGenerator * SedDocument :: createDataGenerator ( ) { SedDataGenerator * temp = new SedDataGenerator ( ) ; if ( temp != NULL ) mDataGenerators . appendAndOwn ( temp ) ; return temp ; } const SedListOfOutputs * SedDocument :: getListOfOutputs ( ) const { return & mOutputs ; } SedOutput * SedDocument :: removeOutput ( unsigned int n ) { return mOutputs . remove ( n ) ; } SedOutput * SedDocument :: removeOutput ( const std :: string & sid ) { return mOutputs . remove ( sid ) ; } SedOutput * SedDocument :: getOutput ( unsigned int n ) { return mOutputs . get ( n ) ; } const SedOutput * SedDocument :: getOutput ( unsigned int n ) const { return mOutputs . get ( n ) ; } SedOutput * SedDocument :: getOutput ( const std :: string & sid ) { return mOutputs . get ( sid ) ; } const SedOutput * SedDocument :: getOutput ( const std :: string & sid ) const { return mOutputs . get ( sid ) ; } int SedDocument :: addOutput ( const SedOutput * so ) { if ( so == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mOutputs . append ( so ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumOutputs ( ) const { return mOutputs . size ( ) ; } SedReport * SedDocument :: createReport ( ) { SedReport * temp = new SedReport ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; } SedPlot2D * SedDocument :: createPlot2D ( ) { SedPlot2D * temp = new SedPlot2D ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; } SedPlot3D * SedDocument :: createPlot3D ( ) { SedPlot3D * temp = new SedPlot3D ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; } const std :: string & SedDocument :: getElementName ( ) const { static const string name = " sedML " ; return name ; } SedBase * SedDocument :: createObject ( XMLInputStream & stream ) { SedBase * object = NULL ; const string & name = stream . peek ( ) . getName ( ) ; if ( name == " listOfDataDescriptions " ) { object = & mDataDescriptions ; } if ( name == " listOfSimulations " ) { object = & mSimulations ; } if ( name == " listOfModels " ) { object = & mModels ; } if ( name == " listOfTasks " ) { object = & mTasks ; } if ( name == " listOfDataGenerators " ) { object = & mDataGenerators ; } if ( name == " listOfOutputs " ) { object = & mOutputs ; } connectToChild ( ) ; return object ; } void SedDocument :: connectToChild ( ) { SedBase :: connectToChild ( ) ; mDataDescriptions . connectToParent ( this ) ; mSimulations . connectToParent ( this ) ; mModels . connectToParent ( this ) ; mTasks . connectToParent ( this ) ; mDataGenerators . connectToParent ( this ) ; mOutputs . connectToParent ( this ) ; } int SedDocument :: getTypeCode ( ) const { return SEDML_DOCUMENT ; } bool SedDocument :: hasRequiredAttributes ( ) const { bool allPresent = true ; if ( isSetLevel ( ) == false ) allPresent = false ; if ( isSetVersion ( ) == false ) allPresent = false ; return allPresent ; } bool SedDocument :: hasRequiredElements ( ) const { bool allPresent = true ; return allPresent ; } void SedDocument :: writeElements ( XMLOutputStream & stream ) const { SedBase :: writeElements ( stream ) ; if ( getNumDataDescriptions ( ) > 0 ) { mDataDescriptions . write ( stream ) ; } if ( getNumSimulations ( ) > 0 ) { mSimulations . write ( stream ) ; } if ( getNumModels ( ) > 0 ) { mModels . write ( stream ) ; } if ( getNumTasks ( ) > 0 ) { mTasks . write ( stream ) ; } if ( getNumDataGenerators ( ) > 0 ) { mDataGenerators . write ( stream ) ; } if ( getNumOutputs ( ) > 0 ) { mOutputs . write ( stream ) ; } } bool SedDocument :: accept ( SedVisitor & v ) const { return false ; } void SedDocument :: setSedDocument ( SedDocument * d ) { SedBase :: setSedDocument ( d ) ; mDataDescriptions . setSedDocument ( d ) ; mSimulations . setSedDocument ( d ) ; mModels . setSedDocument ( d ) ; mTasks . setSedDocument ( d ) ; mDataGenerators . setSedDocument ( d ) ; mOutputs . setSedDocument ( d ) ; } void SedDocument :: addExpectedAttributes ( ExpectedAttributes & attributes ) { SedBase :: addExpectedAttributes ( attributes ) ; attributes . add ( " level " ) ; attributes . add ( " version " ) ; } void SedDocument :: readAttributes ( const XMLAttributes & attributes , const ExpectedAttributes & expectedAttributes ) { SedBase :: readAttributes ( attributes , expectedAttributes ) ; bool assigned = false ; mIsSetLevel = attributes . readInto ( " level " , mLevel , getErrorLog ( ) , true ) ; mIsSetVersion = attributes . readInto ( " version " , mVersion , getErrorLog ( ) , true ) ; } void SedDocument :: writeAttributes ( XMLOutputStream & stream ) const { SedBase :: writeAttributes ( stream ) ; if ( isSetLevel ( ) == true ) stream . writeAttribute ( " level " , getPrefix ( ) , mLevel ) ; if ( isSetVersion ( ) == true ) stream . writeAttribute ( " version " , getPrefix ( ) , mVersion ) ; } const SedError * SedDocument :: getError ( unsigned int n ) const { return mErrorLog . getError ( n ) ; } unsigned int SedDocument :: getNumErrors ( ) const { return mErrorLog . getNumErrors ( ) ; } unsigned int SedDocument :: getNumErrors ( unsigned int severity ) const { return getErrorLog ( ) -> getNumFailsWithSeverity ( severity ) ; } SedErrorLog * SedDocument :: getErrorLog ( ) { return & mErrorLog ; } const SedErrorLog * SedDocument :: getErrorLog ( ) const { return & mErrorLog ; } void SedDocument :: writeXMLNS ( XMLOutputStream & stream ) const { XMLNamespaces * thisNs = this -> getNamespaces ( ) ; if ( thisNs == NULL ) { XMLNamespaces xmlns ; if ( getVersion ( ) == 1 ) xmlns . add ( SEDML_XMLNS_L1V1 ) ; else xmlns . add ( SEDML_XMLNS_L1V2 ) ; mSedNamespaces -> setNamespaces ( & xmlns ) ; thisNs = getNamespaces ( ) ; } else if ( thisNs -> getLength ( ) == 0 ) { if ( getVersion ( ) == 1 ) thisNs -> add ( SEDML_XMLNS_L1V1 ) ; else if ( getVersion ( ) == 2 ) thisNs -> add ( SEDML_XMLNS_L1V2 ) ; else thisNs -> add ( SEDML_XMLNS_L1V3 ) ; } else { std :: string sedmlURI = SedNamespaces :: getSedNamespaceURI ( getLevel ( ) , getVersion ( ) ) ; std :: string sedmlPrefix = thisNs -> getPrefix ( sedmlURI ) ; if ( thisNs -> hasNS ( sedmlURI , sedmlPrefix ) == false ) { std :: string other = thisNs -> getURI ( sedmlPrefix ) ; if ( other . empty ( ) == false ) { thisNs -> remove ( sedmlPrefix ) ; thisNs -> add ( sedmlURI , sedmlPrefix ) ; thisNs -> add ( other , " addedPrefix " ) ; } else { thisNs -> add ( sedmlURI , sedmlPrefix ) ; } } } XMLNamespaces * xmlns = thisNs -> clone ( ) ; if ( xmlns != NULL ) { stream << * ( xmlns ) ; delete xmlns ; } } XMLNamespaces * SedDocument :: getNamespaces ( ) const { return mSedNamespaces -> getNamespaces ( ) ; } LIBSEDML_EXTERN SedDocument_t * SedDocument_create ( unsigned int level , unsigned int version ) { return new SedDocument ( level , version ) ; } LIBSEDML_EXTERN void SedDocument_free ( SedDocument_t * sd ) { if ( sd != NULL ) delete sd ; } LIBSEDML_EXTERN SedDocument_t * SedDocument_clone ( SedDocument_t * sd ) { if ( sd != NULL ) { return static_cast < SedDocument_t * > ( sd -> clone ( ) ) ; } else { return NULL ; } } LIBSEDML_EXTERN int SedDocument_getLevel ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getLevel ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN int SedDocument_getVersion ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getVersion ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN int SedDocument_isSetLevel ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> isSetLevel ( ) ) : 0 ; } LIBSEDML_EXTERN int SedDocument_isSetVersion ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> isSetVersion ( ) ) : 0 ; } LIBSEDML_EXTERN int SedDocument_setLevel ( SedDocument_t * sd , int level ) { return ( sd != NULL ) ? sd -> setLevel ( level ) : LIBSEDML_INVALID_OBJECT ; } LIBSEDML_EXTERN int SedDocument_setVersion ( SedDocument_t * sd , int version ) { return ( sd != NULL ) ? sd -> setVersion ( version ) : LIBSEDML_INVALID_OBJECT ; } LIBSEDML_EXTERN int SedDocument_unsetLevel ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> unsetLevel ( ) : LIBSEDML_INVALID_OBJECT ; } LIBSEDML_EXTERN int SedDocument_unsetVersion ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> unsetVersion ( ) : LIBSEDML_INVALID_OBJECT ; } LIBSEDML_EXTERN int SedDocument_addDataDescription ( SedDocument_t * sd , SedDataDescription_t * sdd ) { return ( sd != NULL ) ? sd -> addDataDescription ( sdd ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_createDataDescription ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createDataDescription ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfDataDescriptions ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfDataDescriptions ( ) : NULL ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_getDataDescription ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getDataDescription ( n ) : NULL ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_getDataDescriptionById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getDataDescription ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumDataDescriptions ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumDataDescriptions ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_removeDataDescription ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeDataDescription ( n ) : NULL ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_removeDataDescriptionById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeDataDescription ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_addSimulation ( SedDocument_t * sd , SedSimulation_t * ss ) { return ( sd != NULL ) ? sd -> addSimulation ( ss ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedUniformTimeCourse_t * SedDocument_createUniformTimeCourse ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createUniformTimeCourse ( ) : NULL ; } LIBSEDML_EXTERN SedOneStep_t * SedDocument_createOneStep ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createOneStep ( ) : NULL ; } LIBSEDML_EXTERN SedSteadyState_t * SedDocument_createSteadyState ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createSteadyState ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfSimulations ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfSimulations ( ) : NULL ; } LIBSEDML_EXTERN SedSimulation_t * SedDocument_getSimulation ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getSimulation ( n ) : NULL ; } LIBSEDML_EXTERN SedSimulation_t * SedDocument_getSimulationById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getSimulation ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumSimulations ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumSimulations ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedSimulation_t * SedDocument_removeSimulation ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeSimulation ( n ) : NULL ; } LIBSEDML_EXTERN SedSimulation_t * SedDocument_removeSimulationById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeSimulation ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_addModel ( SedDocument_t * sd , SedModel_t * sm ) { return ( sd != NULL ) ? sd -> addModel ( sm ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedModel_t * SedDocument_createModel ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createModel ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfModels ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfModels ( ) : NULL ; } LIBSEDML_EXTERN SedModel_t * SedDocument_getModel ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getModel ( n ) : NULL ; } LIBSEDML_EXTERN SedModel_t * SedDocument_getModelById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getModel ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumModels ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumModels ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedModel_t * SedDocument_removeModel ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeModel ( n ) : NULL ; } LIBSEDML_EXTERN SedModel_t * SedDocument_removeModelById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeModel ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_addTask ( SedDocument_t * sd , SedTask_t * st ) { return ( sd != NULL ) ? sd -> addTask ( st ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedTask_t * SedDocument_createTask ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createTask ( ) : NULL ; } LIBSEDML_EXTERN SedRepeatedTask_t * SedDocument_createRepeatedTask ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createRepeatedTask ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfTasks ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfTasks ( ) : NULL ; } LIBSEDML_EXTERN SedTask_t * SedDocument_getTask ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getTask ( n ) : NULL ; } LIBSEDML_EXTERN SedTask_t * SedDocument_getTaskById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getTask ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumTasks ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumTasks ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedTask_t * SedDocument_removeTask ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeTask ( n ) : NULL ; } LIBSEDML_EXTERN SedTask_t * SedDocument_removeTaskById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeTask ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_addDataGenerator ( SedDocument_t * sd , SedDataGenerator_t * sdg ) { return ( sd != NULL ) ? sd -> addDataGenerator ( sdg ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_createDataGenerator ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createDataGenerator ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfDataGenerators ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfDataGenerators ( ) : NULL ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_getDataGenerator ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getDataGenerator ( n ) : NULL ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_getDataGeneratorById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getDataGenerator ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumDataGenerators ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumDataGenerators ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_removeDataGenerator ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeDataGenerator ( n ) : NULL ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_removeDataGeneratorById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeDataGenerator ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_addOutput ( SedDocument_t * sd , SedOutput_t * so ) { return ( sd != NULL ) ? sd -> addOutput ( so ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedReport_t * SedDocument_createReport ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createReport ( ) : NULL ; } LIBSEDML_EXTERN SedPlot2D_t * SedDocument_createPlot2D ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createPlot2D ( ) : NULL ; } LIBSEDML_EXTERN SedPlot3D_t * SedDocument_createPlot3D ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createPlot3D ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfOutputs ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfOutputs ( ) : NULL ; } LIBSEDML_EXTERN SedOutput_t * SedDocument_getOutput ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getOutput ( n ) : NULL ; } LIBSEDML_EXTERN SedOutput_t * SedDocument_getOutputById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getOutput ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumOutputs ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumOutputs ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedOutput_t * SedDocument_removeOutput ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeOutput ( n ) : NULL ; } LIBSEDML_EXTERN SedOutput_t * SedDocument_removeOutputById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeOutput ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_hasRequiredAttributes ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> hasRequiredAttributes ( ) ) : 0 ; } LIBSEDML_EXTERN int SedDocument_hasRequiredElements ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> hasRequiredElements ( ) ) : 0 ; } LIBSEDML_CPP_NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="kstripp/LittleBudget/tree/master/src/core/main.cpp"> # include < iostream > # include " lb . h " using std :: cout ; using std :: endl ; using std :: cerr ; # ifndef VERSION # define VERSION "1.0.1" # endif int main ( int argc , const char * argv [ ] ) { try { lb app ( argc , argv ) ; return app . run ( ) ; } catch ( lb_error e ) { cerr << e . what ( ) << endl ; return EXIT_FAILURE ; } catch ( runtime_error e ) { cerr << e . what ( ) << endl ; return EXIT_FAILURE ; } catch ( ... ) { cerr << " Unhandled ▁ exception ▁ in ▁ lb . " << endl ; return EXIT_FAILURE ; } } </DOCUMENT>
<DOCUMENT_ID="didoutheone/MangosOneDidou/tree/master/dep/recastnavigation/RecastDemo/Source/CrowdManager.cpp"> # define _USE_MATH_DEFINES # include < math . h > # include < stdio . h > # include < stdlib . h > # include < string . h > # include < float . h > # include " DetourNavMesh . h " # include " DetourNavMeshQuery . h " # include " DetourObstacleAvoidance . h " # include " DetourCommon . h " # include " CrowdManager . h " # include " SampleInterfaces . h " # include " DetourAssert . h " # include " DetourAlloc . h " static const int VO_ADAPTIVE_DIVS = 7 ; static const int VO_ADAPTIVE_RINGS = 2 ; static const int VO_ADAPTIVE_DEPTH = 5 ; static const int VO_GRID_SIZE = 33 ; inline int hashPos2 ( int x , int y , int n ) { return ( ( x * 73856093 ) ^ ( y * 19349663 ) ) & ( n - 1 ) ; } ProximityGrid :: ProximityGrid ( ) : m_maxItems ( 0 ) , m_cellSize ( 0 ) , m_pool ( 0 ) , m_poolHead ( 0 ) , m_poolSize ( 0 ) , m_buckets ( 0 ) , m_bucketsSize ( 0 ) { } ProximityGrid :: ~ ProximityGrid ( ) { dtFree ( m_buckets ) ; dtFree ( m_pool ) ; } bool ProximityGrid :: init ( const int maxItems , const float cellSize ) { dtAssert ( maxItems > 0 ) ; dtAssert ( cellSize > 0.0f ) ; m_cellSize = cellSize ; m_invCellSize = 1.0f / m_cellSize ; m_bucketsSize = dtNextPow2 ( maxItems ) ; m_buckets = ( unsigned short * ) dtAlloc ( sizeof ( unsigned short ) * m_bucketsSize , DT_ALLOC_PERM ) ; if ( ! m_buckets ) return false ; m_poolSize = maxItems * 4 ; m_poolHead = 0 ; m_pool = ( Item * ) dtAlloc ( sizeof ( Item ) * m_poolSize , DT_ALLOC_PERM ) ; if ( ! m_pool ) return false ; clear ( ) ; return true ; } void ProximityGrid :: clear ( ) { memset ( m_buckets , 0xff , sizeof ( unsigned short ) * m_bucketsSize ) ; m_poolHead = 0 ; m_bounds [ 0 ] = 0xffff ; m_bounds [ 1 ] = 0xffff ; m_bounds [ 2 ] = - 0xffff ; m_bounds [ 3 ] = - 0xffff ; } void ProximityGrid :: addItem ( const unsigned short id , const float minx , const float miny , const float maxx , const float maxy ) { const int iminx = ( int ) floorf ( minx * m_invCellSize ) ; const int iminy = ( int ) floorf ( miny * m_invCellSize ) ; const int imaxx = ( int ) floorf ( maxx * m_invCellSize ) ; const int imaxy = ( int ) floorf ( maxy * m_invCellSize ) ; m_bounds [ 0 ] = dtMin ( m_bounds [ 0 ] , iminx ) ; m_bounds [ 1 ] = dtMin ( m_bounds [ 1 ] , iminy ) ; m_bounds [ 2 ] = dtMax ( m_bounds [ 2 ] , imaxx ) ; m_bounds [ 3 ] = dtMax ( m_bounds [ 3 ] , imaxy ) ; for ( int y = iminy ; y <= imaxy ; ++ y ) { for ( int x = iminx ; x <= imaxx ; ++ x ) { if ( m_poolHead < m_poolSize ) { const int h = hashPos2 ( x , y , m_bucketsSize ) ; const unsigned short idx = ( unsigned short ) m_poolHead ; m_poolHead ++ ; Item & item = m_pool [ idx ] ; item . x = ( short ) x ; item . y = ( short ) y ; item . id = id ; item . next = m_buckets [ h ] ; m_buckets [ h ] = idx ; } } } } int ProximityGrid :: queryItems ( const float minx , const float miny , const float maxx , const float maxy , unsigned short * ids , const int maxIds ) const { const int iminx = ( int ) floorf ( minx * m_invCellSize ) ; const int iminy = ( int ) floorf ( miny * m_invCellSize ) ; const int imaxx = ( int ) floorf ( maxx * m_invCellSize ) ; const int imaxy = ( int ) floorf ( maxy * m_invCellSize ) ; int n = 0 ; for ( int y = iminy ; y <= imaxy ; ++ y ) { for ( int x = iminx ; x <= imaxx ; ++ x ) { const int h = hashPos2 ( x , y , m_bucketsSize ) ; unsigned short idx = m_buckets [ h ] ; while ( idx != 0xffff ) { Item & item = m_pool [ idx ] ; if ( ( int ) item . x == x && ( int ) item . y == y ) { const unsigned short * end = ids + n ; unsigned short * i = ids ; while ( i != end && * i != item . id ) ++ i ; if ( i == end ) { if ( n >= maxIds ) return n ; ids [ n ++ ] = item . id ; } } idx = item . next ; } } } return n ; } int ProximityGrid :: getItemCountAt ( const int x , const int y ) const { int n = 0 ; const int h = hashPos2 ( x , y , m_bucketsSize ) ; unsigned short idx = m_buckets [ h ] ; while ( idx != 0xffff ) { Item & item = m_pool [ idx ] ; if ( ( int ) item . x == x && ( int ) item . y == y ) n ++ ; idx = item . next ; } return n ; } PathQueue :: PathQueue ( ) : m_nextHandle ( 1 ) , m_delay ( 0 ) { for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) m_queue [ i ] . ref = PATHQ_INVALID ; } PathQueue :: ~ PathQueue ( ) { } void PathQueue :: update ( dtNavMeshQuery * navquery ) { m_delay ++ ; if ( ( m_delay % 4 ) == 0 ) { for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { PathQuery & q = m_queue [ i ] ; if ( q . ref == PATHQ_INVALID ) continue ; navquery -> findPath ( q . startRef , q . endRef , q . startPos , q . endPos , q . filter , q . path , & q . npath , PQ_MAX_PATH ) ; q . ready = true ; break ; } } for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { PathQuery & q = m_queue [ i ] ; if ( q . ref != PATHQ_INVALID && q . ready ) { q . keepalive ++ ; if ( q . keepalive > 2 ) q . ref = PATHQ_INVALID ; } } } PathQueueRef PathQueue :: request ( dtPolyRef startRef , dtPolyRef endRef , const float * startPos , const float * endPos , const dtQueryFilter * filter ) { int slot = - 1 ; for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { if ( m_queue [ i ] . ref == PATHQ_INVALID ) { slot = i ; break ; } } if ( slot == - 1 ) return PATHQ_INVALID ; PathQueueRef ref = m_nextHandle ++ ; if ( m_nextHandle == PATHQ_INVALID ) m_nextHandle ++ ; PathQuery & q = m_queue [ slot ] ; q . ref = ref ; dtVcopy ( q . startPos , startPos ) ; q . startRef = startRef ; dtVcopy ( q . endPos , endPos ) ; q . endRef = endRef ; q . ready = false ; q . npath = 0 ; q . filter = filter ; q . keepalive = 0 ; return ref ; } int PathQueue :: getRequestState ( PathQueueRef ref ) { for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { if ( m_queue [ i ] . ref == ref ) return m_queue [ i ] . ready ? PATHQ_STATE_READY : PATHQ_STATE_WORKING ; } return PATHQ_STATE_INVALID ; } int PathQueue :: getPathResult ( PathQueueRef ref , dtPolyRef * path , const int maxPath ) { for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { if ( m_queue [ i ] . ref == ref ) { PathQuery & q = m_queue [ i ] ; q . ref = PATHQ_INVALID ; int n = 0 ; for ( int j = 0 ; j < q . npath && j < maxPath ; ++ j ) path [ n ++ ] = q . path [ j ] ; return n ; } } return 0 ; } static int fixupCorridor ( dtPolyRef * path , const int npath , const int maxPath , const dtPolyRef * visited , const int nvisited ) { int furthestPath = - 1 ; int furthestVisited = - 1 ; for ( int i = npath - 1 ; i >= 0 ; -- i ) { bool found = false ; for ( int j = nvisited - 1 ; j >= 0 ; -- j ) { if ( path [ i ] == visited [ j ] ) { furthestPath = i ; furthestVisited = j ; found = true ; } } if ( found ) break ; } if ( furthestPath == - 1 || furthestVisited == - 1 ) return npath ; const int req = nvisited - furthestVisited ; const int orig = dtMin ( furthestPath + 1 , npath ) ; int size = dtMax ( 0 , npath - orig ) ; if ( req + size > maxPath ) size = maxPath - req ; if ( size ) memmove ( path + req , path + orig , size * sizeof ( dtPolyRef ) ) ; for ( int i = 0 ; i < req ; ++ i ) path [ i ] = visited [ ( nvisited - 1 ) - i ] ; return req + size ; } static int fixupCorridorEnd ( dtPolyRef * path , const int npath , const int maxPath , const dtPolyRef * visited , const int nvisited ) { int furthestPath = - 1 ; int furthestVisited = - 1 ; for ( int i = 0 ; i < npath ; ++ i ) { bool found = false ; for ( int j = nvisited - 1 ; j >= 0 ; -- j ) { if ( path [ i ] == visited [ j ] ) { furthestPath = i ; furthestVisited = j ; found = true ; } } if ( found ) break ; } if ( furthestPath == - 1 || furthestVisited == - 1 ) return npath ; const int ppos = furthestPath + 1 ; const int vpos = furthestVisited + 1 ; const int count = dtMin ( nvisited - vpos , maxPath - ppos ) ; dtAssert ( ppos + count <= maxPath ) ; if ( count ) memcpy ( path + ppos , visited + vpos , sizeof ( dtPolyRef ) * count ) ; return ppos + count ; } static int mergeCorridor ( dtPolyRef * path , const int npath , const int maxPath , const dtPolyRef * visited , const int nvisited ) { int furthestPath = - 1 ; int furthestVisited = - 1 ; for ( int i = npath - 1 ; i >= 0 ; -- i ) { bool found = false ; for ( int j = nvisited - 1 ; j >= 0 ; -- j ) { if ( path [ i ] == visited [ j ] ) { furthestPath = i ; furthestVisited = j ; found = true ; } } if ( found ) break ; } if ( furthestPath == - 1 || furthestVisited == - 1 ) return npath ; const int req = furthestVisited ; if ( req <= 0 ) return npath ; const int orig = furthestPath ; int size = dtMax ( 0 , npath - orig ) ; if ( req + size > maxPath ) size = maxPath - req ; if ( size ) memmove ( path + req , path + orig , size * sizeof ( dtPolyRef ) ) ; for ( int i = 0 ; i < req ; ++ i ) path [ i ] = visited [ i ] ; return req + size ; } PathCorridor :: PathCorridor ( ) : m_path ( 0 ) , m_npath ( 0 ) , m_maxPath ( 0 ) { } PathCorridor :: ~ PathCorridor ( ) { dtFree ( m_path ) ; } bool PathCorridor :: init ( const int maxPath ) { dtAssert ( ! m_path ) ; m_path = ( dtPolyRef * ) dtAlloc ( sizeof ( dtPolyRef ) * maxPath , DT_ALLOC_PERM ) ; if ( ! m_path ) return false ; m_npath = 0 ; m_maxPath = maxPath ; return true ; } void PathCorridor :: reset ( dtPolyRef ref , const float * pos ) { dtAssert ( m_path ) ; dtVcopy ( m_pos , pos ) ; dtVcopy ( m_target , pos ) ; m_path [ 0 ] = ref ; m_npath = 1 ; } int PathCorridor :: findCorners ( float * cornerVerts , unsigned char * cornerFlags , dtPolyRef * cornerPolys , const int maxCorners , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; dtAssert ( m_npath ) ; static const float MIN_TARGET_DIST = 0.01f ; int ncorners = 0 ; navquery -> findStraightPath ( m_pos , m_target , m_path , m_npath , cornerVerts , cornerFlags , cornerPolys , & ncorners , maxCorners ) ; while ( ncorners ) { if ( ( cornerFlags [ 0 ] & DT_STRAIGHTPATH_OFFMESH_CONNECTION ) || dtVdist2DSqr ( & cornerVerts [ 0 ] , m_pos ) > dtSqr ( MIN_TARGET_DIST ) ) break ; ncorners -- ; if ( ncorners ) { memmove ( cornerFlags , cornerFlags + 1 , sizeof ( unsigned char ) * ncorners ) ; memmove ( cornerPolys , cornerPolys + 1 , sizeof ( dtPolyRef ) * ncorners ) ; memmove ( cornerVerts , cornerVerts + 3 , sizeof ( float ) * 3 * ncorners ) ; } } for ( int i = 0 ; i < ncorners ; ++ i ) { if ( cornerFlags [ i ] & DT_STRAIGHTPATH_OFFMESH_CONNECTION ) { ncorners = i + 1 ; break ; } } return ncorners ; } void PathCorridor :: optimizePathVisibility ( const float * next , const float pathOptimizationRange , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; float goal [ 3 ] ; dtVcopy ( goal , next ) ; float dist = dtVdist2D ( m_pos , goal ) ; if ( dist < 0.01f ) return ; dist = dtMin ( dist + 0.01f , pathOptimizationRange ) ; float delta [ 3 ] ; dtVsub ( delta , goal , m_pos ) ; dtVmad ( goal , m_pos , delta , pathOptimizationRange / dist ) ; static const int MAX_RES = 32 ; dtPolyRef res [ MAX_RES ] ; float t , norm [ 3 ] ; int nres = 0 ; navquery -> raycast ( m_path [ 0 ] , m_pos , goal , filter , & t , norm , res , & nres , MAX_RES ) ; if ( nres > 1 && t > 0.99f ) { m_npath = mergeCorridor ( m_path , m_npath , m_maxPath , res , nres ) ; } } bool PathCorridor :: optimizePathTopology ( dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; if ( m_npath < 3 ) return false ; static const int MAX_ITER = 32 ; static const int MAX_RES = 32 ; dtPolyRef res [ MAX_RES ] ; int nres = 0 ; navquery -> initSlicedFindPath ( m_path [ 0 ] , m_path [ m_npath - 1 ] , m_pos , m_target , filter ) ; navquery -> updateSlicedFindPath ( MAX_ITER ) ; dtStatus status = navquery -> finalizeSlicedFindPathPartial ( m_path , m_npath , res , & nres , MAX_RES ) ; if ( status == DT_SUCCESS && nres > 0 ) { m_npath = mergeCorridor ( m_path , m_npath , m_maxPath , res , nres ) ; return true ; } return false ; } void PathCorridor :: movePosition ( const float * npos , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; dtAssert ( m_npath ) ; float result [ 3 ] ; static const int MAX_VISITED = 16 ; dtPolyRef visited [ MAX_VISITED ] ; int nvisited = 0 ; navquery -> moveAlongSurface ( m_path [ 0 ] , m_pos , npos , filter , result , visited , & nvisited , MAX_VISITED ) ; m_npath = fixupCorridor ( m_path , m_npath , m_maxPath , visited , nvisited ) ; float h = m_pos [ 1 ] ; navquery -> getPolyHeight ( m_path [ 0 ] , result , & h ) ; result [ 1 ] = h ; dtVcopy ( m_pos , result ) ; } void PathCorridor :: moveTargetPosition ( const float * npos , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; dtAssert ( m_npath ) ; float result [ 3 ] ; static const int MAX_VISITED = 16 ; dtPolyRef visited [ MAX_VISITED ] ; int nvisited = 0 ; navquery -> moveAlongSurface ( m_path [ m_npath - 1 ] , m_target , npos , filter , result , visited , & nvisited , MAX_VISITED ) ; m_npath = fixupCorridorEnd ( m_path , m_npath , m_maxPath , visited , nvisited ) ; dtVcopy ( m_target , result ) ; } void PathCorridor :: setCorridor ( const float * target , const dtPolyRef * path , const int npath ) { dtAssert ( m_path ) ; dtAssert ( npath > 0 ) ; dtAssert ( npath < m_maxPath ) ; dtVcopy ( m_target , target ) ; memcpy ( m_path , path , sizeof ( dtPolyRef ) * npath ) ; m_npath = npath ; } void Agent :: integrate ( const float maxAcc , const float dt ) { const float maxDelta = maxAcc * dt ; float dv [ 3 ] ; dtVsub ( dv , nvel , vel ) ; float ds = dtVlen ( dv ) ; if ( ds > maxDelta ) dtVscale ( dv , dv , maxDelta / ds ) ; dtVadd ( vel , vel , dv ) ; if ( dtVlen ( vel ) > 0.0001f ) dtVmad ( npos , npos , vel , dt ) ; else dtVset ( vel , 0 , 0 , 0 ) ; } float Agent :: getDistanceToGoal ( const float range ) const { if ( ! ncorners ) return range ; const bool endOfPath = ( cornerFlags [ ncorners - 1 ] & DT_STRAIGHTPATH_END ) ? true : false ; const bool offMeshConnection = ( cornerFlags [ ncorners - 1 ] & DT_STRAIGHTPATH_OFFMESH_CONNECTION ) ? true : false ; if ( endOfPath || offMeshConnection ) return dtMin ( dtVdist2D ( npos , & cornerVerts [ ( ncorners - 1 ) * 3 ] ) , range ) ; return range ; } void Agent :: calcSmoothSteerDirection ( float * dir ) { if ( ! ncorners ) { dtVset ( dir , 0 , 0 , 0 ) ; return ; } const int ip0 = 0 ; const int ip1 = dtMin ( 1 , ncorners - 1 ) ; const float * p0 = & cornerVerts [ ip0 * 3 ] ; const float * p1 = & cornerVerts [ ip1 * 3 ] ; float dir0 [ 3 ] , dir1 [ 3 ] ; dtVsub ( dir0 , p0 , npos ) ; dtVsub ( dir1 , p1 , npos ) ; dir0 [ 1 ] = 0 ; dir1 [ 1 ] = 0 ; float len0 = dtVlen ( dir0 ) ; float len1 = dtVlen ( dir1 ) ; if ( len1 > 0.001f ) dtVscale ( dir1 , dir1 , 1.0f / len1 ) ; dir [ 0 ] = dir0 [ 0 ] - dir1 [ 0 ] * len0 * 0.5f ; dir [ 1 ] = 0 ; dir [ 2 ] = dir0 [ 2 ] - dir1 [ 2 ] * len0 * 0.5f ; dtVnormalize ( dir ) ; } void Agent :: calcStraightSteerDirection ( float * dir ) { if ( ! ncorners ) { dtVset ( dir , 0 , 0 , 0 ) ; return ; } dtVsub ( dir , & cornerVerts [ 0 ] , npos ) ; dir [ 1 ] = 0 ; dtVnormalize ( dir ) ; } LocalBoundary :: LocalBoundary ( ) : m_nsegs ( 0 ) { dtVset ( m_center , FLT_MAX , FLT_MAX , FLT_MAX ) ; } LocalBoundary :: ~ LocalBoundary ( ) { } void LocalBoundary :: reset ( ) { dtVset ( m_center , FLT_MAX , FLT_MAX , FLT_MAX ) ; m_nsegs = 0 ; } void LocalBoundary :: addSegment ( const float dist , const float * s ) { Segment * seg = 0 ; if ( ! m_nsegs ) { seg = & m_segs [ 0 ] ; } else if ( dist >= m_segs [ m_nsegs - 1 ] . d ) { if ( m_nsegs >= MAX_SEGS ) return ; seg = & m_segs [ m_nsegs ] ; } else { int i ; for ( i = 0 ; i < m_nsegs ; ++ i ) if ( dist <= m_segs [ i ] . d ) break ; const int tgt = i + 1 ; const int n = dtMin ( m_nsegs - i , MAX_SEGS - tgt ) ; dtAssert ( tgt + n <= MAX_SEGS ) ; if ( n > 0 ) memmove ( & m_segs [ tgt ] , & m_segs [ i ] , sizeof ( Segment ) * n ) ; seg = & m_segs [ i ] ; } seg -> d = dist ; memcpy ( seg -> s , s , sizeof ( float ) * 6 ) ; if ( m_nsegs < MAX_SEGS ) m_nsegs ++ ; } void LocalBoundary :: update ( dtPolyRef ref , const float * pos , const float collisionQueryRange , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { static const int MAX_LOCAL_POLYS = 16 ; static const int MAX_SEGS_PER_POLY = DT_VERTS_PER_POLYGON * 2 ; if ( ! ref ) { dtVset ( m_center , FLT_MAX , FLT_MAX , FLT_MAX ) ; m_nsegs = 0 ; return ; } dtVcopy ( m_center , pos ) ; dtPolyRef locals [ MAX_LOCAL_POLYS ] ; int nlocals = 0 ; navquery -> findLocalNeighbourhood ( ref , pos , collisionQueryRange , filter , locals , 0 , & nlocals , MAX_LOCAL_POLYS ) ; m_nsegs = 0 ; float segs [ MAX_SEGS_PER_POLY * 6 ] ; int nsegs = 0 ; for ( int j = 0 ; j < nlocals ; ++ j ) { navquery -> getPolyWallSegments ( locals [ j ] , filter , segs , & nsegs , MAX_SEGS_PER_POLY ) ; for ( int k = 0 ; k < nsegs ; ++ k ) { const float * s = & segs [ k * 6 ] ; float tseg ; const float distSqr = dtDistancePtSegSqr2D ( pos , s , s + 3 , tseg ) ; if ( distSqr > dtSqr ( collisionQueryRange ) ) continue ; addSegment ( distSqr , s ) ; } } } CrowdManager :: CrowdManager ( ) : m_obstacleQuery ( 0 ) , m_pathResult ( 0 ) , m_maxPathResult ( 0 ) , m_totalTime ( 0 ) , m_rvoTime ( 0 ) , m_sampleCount ( 0 ) , m_moveRequestCount ( 0 ) { dtVset ( m_ext , 2 , 4 , 2 ) ; m_obstacleQuery = dtAllocObstacleAvoidanceQuery ( ) ; m_obstacleQuery -> init ( 6 , 8 ) ; m_obstacleQuery -> setDesiredVelocityWeight ( 2.0f ) ; m_obstacleQuery -> setCurrentVelocityWeight ( 0.75f ) ; m_obstacleQuery -> setPreferredSideWeight ( 0.75f ) ; m_obstacleQuery -> setCollisionTimeWeight ( 2.5f ) ; m_obstacleQuery -> setTimeHorizon ( 2.5f ) ; m_obstacleQuery -> setVelocitySelectionBias ( 0.4f ) ; memset ( m_vodebug , 0 , sizeof ( m_vodebug ) ) ; const int maxAdaptiveSamples = ( VO_ADAPTIVE_DIVS * VO_ADAPTIVE_RINGS + 1 ) * VO_ADAPTIVE_DEPTH ; const int maxGridSamples = VO_GRID_SIZE * VO_GRID_SIZE ; const int sampleCount = dtMax ( maxAdaptiveSamples , maxGridSamples ) ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) { m_vodebug [ i ] = dtAllocObstacleAvoidanceDebugData ( ) ; m_vodebug [ i ] -> init ( sampleCount ) ; } m_maxPathResult = 256 ; m_pathResult = ( dtPolyRef * ) dtAlloc ( sizeof ( dtPolyRef ) * m_maxPathResult , DT_ALLOC_PERM ) ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) { m_agents [ i ] . corridor . init ( m_maxPathResult ) ; } m_grid . init ( 100 , 1.0f ) ; reset ( ) ; } CrowdManager :: ~ CrowdManager ( ) { delete [ ] m_pathResult ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) dtFreeObstacleAvoidanceDebugData ( m_vodebug [ i ] ) ; dtFreeObstacleAvoidanceQuery ( m_obstacleQuery ) ; } void CrowdManager :: reset ( ) { for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) m_agents [ i ] . active = 0 ; } const int CrowdManager :: getAgentCount ( ) const { return MAX_AGENTS ; } const Agent * CrowdManager :: getAgent ( const int idx ) { return & m_agents [ idx ] ; } int CrowdManager :: addAgent ( const float * pos , const float radius , const float height , dtNavMeshQuery * navquery ) { int idx = - 1 ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) { if ( ! m_agents [ i ] . active ) { idx = i ; break ; } } if ( idx == - 1 ) return - 1 ; Agent * ag = & m_agents [ idx ] ; float nearest [ 3 ] ; dtPolyRef ref ; navquery -> findNearestPoly ( pos , m_ext , & m_filter , & ref , nearest ) ; if ( ! ref ) { return - 1 ; } ag -> corridor . reset ( ref , nearest ) ; ag -> boundary . reset ( ) ; ag -> radius = radius ; ag -> height = height ; ag -> collisionQueryRange = radius * 8 ; ag -> pathOptimizationRange = radius * 30 ; ag -> topologyOptTime = 0 ; ag -> nneis = 0 ; dtVset ( ag -> dvel , 0 , 0 , 0 ) ; dtVset ( ag -> nvel , 0 , 0 , 0 ) ; dtVset ( ag -> vel , 0 , 0 , 0 ) ; dtVcopy ( ag -> npos , nearest ) ; ag -> maxspeed = 0 ; ag -> t = 0 ; dtVset ( ag -> opts , 0 , 0 , 0 ) ; dtVset ( ag -> opte , 0 , 0 , 0 ) ; ag -> active = 1 ; ag -> var = ( rand ( ) % 10 ) / 9.0f ; for ( int i = 0 ; i < AGENT_MAX_TRAIL ; ++ i ) dtVcopy ( & ag -> trail [ i * 3 ] , ag -> corridor . getPos ( ) ) ; ag -> htrail = 0 ; return idx ; } void CrowdManager :: removeAgent ( const int idx ) { if ( idx >= 0 && idx < MAX_AGENTS ) { m_agents [ idx ] . active = 0 ; } } bool CrowdManager :: requestMoveTarget ( const int idx , dtPolyRef ref , const float * pos ) { if ( idx < 0 || idx > MAX_AGENTS ) return false ; if ( ! ref ) return false ; MoveRequest * req = 0 ; for ( int i = 0 ; i < m_moveRequestCount ; ++ i ) { if ( m_moveRequests [ i ] . idx == idx ) { req = & m_moveRequests [ i ] ; break ; } } if ( ! req ) { if ( m_moveRequestCount >= MAX_AGENTS ) return false ; req = & m_moveRequests [ m_moveRequestCount ++ ] ; memset ( req , 0 , sizeof ( MoveRequest ) ) ; } req -> idx = idx ; req -> ref = ref ; dtVcopy ( req -> pos , pos ) ; req -> pathqRef = PATHQ_INVALID ; req -> state = MR_TARGET_REQUESTING ; req -> temp [ 0 ] = ref ; req -> ntemp = 1 ; return true ; } bool CrowdManager :: adjustMoveTarget ( const int idx , dtPolyRef ref , const float * pos ) { if ( idx < 0 || idx > MAX_AGENTS ) return false ; if ( ! ref ) return false ; MoveRequest * req = 0 ; for ( int i = 0 ; i < m_moveRequestCount ; ++ i ) { if ( m_moveRequests [ i ] . idx == idx ) { req = & m_moveRequests [ i ] ; break ; } } if ( ! req ) { if ( m_moveRequestCount >= MAX_AGENTS ) return false ; req = & m_moveRequests [ m_moveRequestCount ++ ] ; memset ( req , 0 , sizeof ( MoveRequest ) ) ; req -> state = MR_TARGET_ADJUST ; req -> idx = idx ; } req -> aref = ref ; dtVcopy ( req -> apos , pos ) ; return true ; } int CrowdManager :: getActiveAgents ( Agent * * agents , const int maxAgents ) { int n = 0 ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) { if ( ! m_agents [ i ] . active ) continue ; if ( n < maxAgents ) agents [ n ++ ] = & m_agents [ i ] ; } return n ; } static int addNeighbour ( const int idx , const float dist , Neighbour * neis , const int nneis , const int maxNeis ) { Neighbour * nei = 0 ; if ( ! nneis ) { nei = & neis [ nneis ] ; } else if ( dist >= neis [ nneis - 1 ] . dist ) { if ( nneis >= maxNeis ) return nneis ; nei = & neis [ nneis ] ; } else { int i ; for ( i = 0 ; i < nneis ; ++ i ) if ( dist <= neis [ i ] . dist ) break ; const int tgt = i + 1 ; const int n = dtMin ( nneis - i , maxNeis - tgt ) ; dtAssert ( tgt + n <= maxNeis ) ; if ( n > 0 ) memmove ( & neis [ tgt ] , & neis [ i ] , sizeof ( Neighbour ) * n ) ; nei = & neis [ i ] ; } memset ( nei , 0 , sizeof ( Neighbour ) ) ; nei -> idx = idx ; nei -> dist = dist ; return dtMin ( nneis + 1 , maxNeis ) ; } int CrowdManager :: getNeighbours ( const float * pos , const float height , const float range , const Agent * skip , Neighbour * result , const int maxResult ) { int n = 0 ; unsigned short ids [ MAX_AGENTS ] ; int nids = m_grid . queryItems ( pos [ 0 ] - range , pos [ 2 ] - range , pos [ 0 ] + range , pos [ 2 ] + range , ids , MAX_AGENTS ) ; for ( int i = 0 ; i < nids ; ++ i ) { Agent * ag = & m_agents [ ids [ i ] ] ; if ( ag == skip ) continue ; float diff [ 3 ] ; dtVsub ( diff , pos , ag -> npos ) ; if ( fabsf ( diff [ 1 ] ) >= ( height + ag -> height ) / 2.0f ) continue ; diff [ 1 ] = 0 ; const float distSqr = dtVlenSqr ( diff ) ; if ( distSqr > dtSqr ( range ) ) continue ; n = addNeighbour ( ids [ i ] , distSqr , result , n , maxResult ) ; } return n ; } void CrowdManager :: updateMoveRequest ( const float dt , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { for ( int i = 0 ; i < m_moveRequestCount ; ++ i ) { MoveRequest * req = & m_moveRequests [ i ] ; Agent * ag = & m_agents [ req -> idx ] ; if ( ! ag -> active ) req -> state = MR_TARGET_FAILED ; if ( req -> aref ) { if ( req -> state == MR_TARGET_ADJUST ) { ag -> corridor . moveTargetPosition ( req -> apos , navquery , filter ) ; req -> state = MR_TARGET_VALID ; } else { float result [ 3 ] ; static const int MAX_VISITED = 16 ; dtPolyRef visited [ MAX_VISITED ] ; int nvisited = 0 ; navquery -> moveAlongSurface ( req -> temp [ req -> ntemp - 1 ] , req -> pos , req -> apos , filter , result , visited , & nvisited , MAX_VISITED ) ; req -> ntemp = fixupCorridorEnd ( req -> temp , req -> ntemp , MAX_TEMP_PATH , visited , nvisited ) ; dtVcopy ( req -> pos , result ) ; dtVset ( req -> apos , 0 , 0 , 0 ) ; req -> aref = 0 ; } } if ( req -> state == MR_TARGET_REQUESTING ) { const dtPolyRef * path = ag -> corridor . getPath ( ) ; const int npath = ag -> corridor . getPathCount ( ) ; dtAssert ( npath ) ; float reqPos [ 3 ] ; dtVcopy ( reqPos , ag -> corridor . getPos ( ) ) ; dtPolyRef reqPath [ 8 ] ; reqPath [ 0 ] = path [ 0 ] ; int reqPathCount = 1 ; req -> pathqRef = m_pathq . request ( reqPath [ reqPathCount - 1 ] , req -> ref , reqPos , req -> pos , & m_filter ) ; if ( req -> pathqRef != PATHQ_INVALID ) { ag -> corridor . setCorridor ( reqPos , reqPath , reqPathCount ) ; req -> state = MR_TARGET_WAITING_FOR_PATH ; } } } m_pathq . update ( navquery ) ; for ( int i = 0 ; i < m_moveRequestCount ; ++ i ) { MoveRequest * req = & m_moveRequests [ i ] ; Agent * ag = & m_agents [ req -> idx ] ; if ( req -> state == MR_TARGET_WAITING_FOR_PATH ) { int state = m_pathq . getRequestState ( req -> pathqRef ) ; if ( state == PATHQ_STATE_INVALID ) { req -> pathqRef = PATHQ_INVALID ; req -> state = MR_TARGET_FAILED ; } else if ( state == PATHQ_STATE_READY ) { const dtPolyRef * path = ag -> corridor . getPath ( ) ; const int npath = ag -> corridor . getPathCount ( ) ; dtAssert ( npath ) ; float targetPos [ 3 ] ; dtVcopy ( targetPos , req -> pos ) ; dtPolyRef * res = m_pathResult ; bool valid = true ; int nres = m_pathq . getPathResult ( req -> pathqRef , res , m_maxPathResult ) ; if ( ! nres ) valid = false ; if ( req -> ntemp > 1 ) { nres = fixupCorridorEnd ( res , nres , m_maxPathResult , req -> temp , req -> ntemp ) ; } if ( valid && path [ npath - 1 ] != res [ 0 ] ) valid = false ; if ( valid ) { if ( npath > 1 ) { if ( ( npath - 1 ) + nres > m_maxPathResult ) nres = m_maxPathResult - ( npath - 1 ) ; memmove ( res + npath - 1 , res , sizeof ( dtPolyRef ) * nres ) ; memcpy ( res , path , sizeof ( dtPolyRef ) * ( npath - 1 ) ) ; nres += npath - 1 ; } if ( res [ nres - 1 ] != req -> ref ) { float nearest [ 3 ] ; if ( navquery -> closestPointOnPoly ( res [ nres - 1 ] , targetPos , nearest ) == DT_SUCCESS ) dtVcopy ( targetPos , nearest ) ; else valid = false ; } } if ( valid ) { ag -> corridor . setCorridor ( targetPos , res , nres ) ; req -> state = MR_TARGET_VALID ; } else { req -> state = MR_TARGET_FAILED ; } } } if ( req -> state == MR_TARGET_VALID || req -> state == MR_TARGET_FAILED ) { m_moveRequestCount -- ; if ( i != m_moveRequestCount ) memcpy ( & m_moveRequests [ i ] , & m_moveRequests [ m_moveRequestCount ] , sizeof ( MoveRequest ) ) ; -- i ; } } } static int addToOptQueue ( Agent * newag , Agent * * agents , const int nagents , const int maxAgents ) { int slot = 0 ; if ( ! nagents ) { slot = nagents ; } else if ( newag -> topologyOptTime <= agents [ nagents - 1 ] -> topologyOptTime ) { if ( nagents >= maxAgents ) return nagents ; slot = nagents ; } else { int i ; for ( i = 0 ; i < nagents ; ++ i ) if ( newag -> topologyOptTime >= agents [ i ] -> topologyOptTime ) break ; const int tgt = i + 1 ; const int n = dtMin ( nagents - i , maxAgents - tgt ) ; dtAssert ( tgt + n <= maxAgents ) ; if ( n > 0 ) memmove ( & agents [ tgt ] , & agents [ i ] , sizeof ( Agent * ) * n ) ; slot = i ; } agents [ slot ] = newag ; return dtMin ( nagents + 1 , maxAgents ) ; } void CrowdManager :: updateTopologyOptimization ( const float dt , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { Agent * agents [ MAX_AGENTS ] ; int nagents = getActiveAgents ( agents , MAX_AGENTS ) ; if ( ! nagents ) return ; const float OPT_TIME_THR = 0.5f ; const int OPT_MAX_AGENTS = 1 ; Agent * queue [ OPT_MAX_AGENTS ] ; int nqueue = 0 ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; ag -> topologyOptTime += dt ; if ( ag -> topologyOptTime >= OPT_TIME_THR ) { nqueue = addToOptQueue ( ag , queue , nqueue , OPT_MAX_AGENTS ) ; } } for ( int i = 0 ; i < nqueue ; ++ i ) { Agent * ag = queue [ i ] ; ag -> corridor . optimizePathTopology ( navquery , filter ) ; ag -> topologyOptTime = 0 ; } } void CrowdManager :: update ( const float dt , unsigned int flags , dtNavMeshQuery * navquery ) { m_sampleCount = 0 ; m_totalTime = 0 ; m_rvoTime = 0 ; if ( ! navquery ) return ; TimeVal startTime = getPerfTime ( ) ; Agent * agents [ MAX_AGENTS ] ; int nagents = getActiveAgents ( agents , MAX_AGENTS ) ; static const float MAX_ACC = 8.0f ; static const float MAX_SPEED = 3.5f ; updateMoveRequest ( dt , navquery , & m_filter ) ; if ( flags & CROWDMAN_OPTIMIZE_TOPO ) updateTopologyOptimization ( dt , navquery , & m_filter ) ; m_grid . clear ( ) ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; const float * p = ag -> npos ; const float r = ag -> radius ; m_grid . addItem ( ( unsigned short ) i , p [ 0 ] - r , p [ 2 ] - r , p [ 0 ] + r , p [ 2 ] + r ) ; } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; if ( dtVdist2DSqr ( ag -> npos , ag -> boundary . getCenter ( ) ) > dtSqr ( ag -> collisionQueryRange * 0.25f ) ) ag -> boundary . update ( ag -> corridor . getFirstPoly ( ) , ag -> npos , ag -> collisionQueryRange , navquery , & m_filter ) ; ag -> nneis = getNeighbours ( ag -> npos , ag -> height , ag -> collisionQueryRange , ag , ag -> neis , AGENT_MAX_NEIGHBOURS ) ; } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; ag -> ncorners = ag -> corridor . findCorners ( ag -> cornerVerts , ag -> cornerFlags , ag -> cornerPolys , AGENT_MAX_CORNERS , navquery , & m_filter ) ; if ( ( flags & CROWDMAN_OPTIMIZE_VIS ) && ag -> ncorners > 0 ) { const float * target = & ag -> cornerVerts [ dtMin ( 1 , ag -> ncorners - 1 ) * 3 ] ; dtVcopy ( ag -> opts , ag -> corridor . getPos ( ) ) ; dtVcopy ( ag -> opte , target ) ; ag -> corridor . optimizePathVisibility ( target , ag -> pathOptimizationRange , navquery , & m_filter ) ; } else { dtVset ( ag -> opts , 0 , 0 , 0 ) ; dtVset ( ag -> opte , 0 , 0 , 0 ) ; } } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; float dvel [ 3 ] = { 0 , 0 , 0 } ; if ( flags & CROWDMAN_ANTICIPATE_TURNS ) ag -> calcSmoothSteerDirection ( dvel ) ; else ag -> calcStraightSteerDirection ( dvel ) ; const float slowDownRadius = ag -> radius * 2 ; const float speedScale = ag -> getDistanceToGoal ( slowDownRadius ) / slowDownRadius ; if ( flags & CROWDMAN_DRUNK ) { ag -> t += dt * ( 1.0f - ag -> var * 0.25f ) ; ag -> maxspeed = MAX_SPEED * ( 1 + dtSqr ( cosf ( ag -> t * 2.0f ) ) * 0.3f ) ; dtVscale ( dvel , dvel , ag -> maxspeed * speedScale ) ; const float amp = cosf ( ag -> var * 13.69f + ag -> t * 3.123f ) * 0.2f ; const float nx = - dvel [ 2 ] ; const float nz = dvel [ 0 ] ; dvel [ 0 ] += nx * amp ; dvel [ 2 ] += nz * amp ; } else { ag -> maxspeed = MAX_SPEED ; dtVscale ( dvel , dvel , ag -> maxspeed * speedScale ) ; } dtVcopy ( ag -> dvel , dvel ) ; } TimeVal rvoStartTime = getPerfTime ( ) ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; if ( flags & CROWDMAN_USE_VO ) { m_obstacleQuery -> reset ( ) ; for ( int j = 0 ; j < ag -> nneis ; ++ j ) { const Agent * nei = & m_agents [ ag -> neis [ j ] . idx ] ; m_obstacleQuery -> addCircle ( nei -> npos , nei -> radius , nei -> vel , nei -> dvel ) ; } for ( int j = 0 ; j < ag -> boundary . getSegmentCount ( ) ; ++ j ) { const float * s = ag -> boundary . getSegment ( j ) ; if ( dtTriArea2D ( ag -> npos , s , s + 3 ) < 0.0f ) continue ; m_obstacleQuery -> addSegment ( s , s + 3 ) ; } bool adaptive = true ; if ( adaptive ) { m_obstacleQuery -> sampleVelocityAdaptive ( ag -> npos , ag -> radius , ag -> maxspeed , ag -> vel , ag -> dvel , ag -> nvel , VO_ADAPTIVE_DIVS , VO_ADAPTIVE_RINGS , VO_ADAPTIVE_DEPTH , m_vodebug [ i ] ) ; } else { m_obstacleQuery -> sampleVelocityGrid ( ag -> npos , ag -> radius , ag -> maxspeed , ag -> vel , ag -> dvel , ag -> nvel , VO_GRID_SIZE , m_vodebug [ i ] ) ; } } else { dtVcopy ( ag -> nvel , ag -> dvel ) ; } } TimeVal rvoEndTime = getPerfTime ( ) ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; ag -> integrate ( MAX_ACC , dt ) ; } for ( int iter = 0 ; iter < 4 ; ++ iter ) { for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; dtVset ( ag -> disp , 0 , 0 , 0 ) ; float w = 0 ; for ( int j = 0 ; j < ag -> nneis ; ++ j ) { const Agent * nei = & m_agents [ ag -> neis [ j ] . idx ] ; float diff [ 3 ] ; dtVsub ( diff , ag -> npos , nei -> npos ) ; if ( fabsf ( diff [ 1 ] ) >= ( ag -> height + nei -> height ) / 2.0f ) continue ; diff [ 1 ] = 0 ; float dist = dtVlenSqr ( diff ) ; if ( dist > dtSqr ( ag -> radius + nei -> radius ) ) continue ; dist = sqrtf ( dist ) ; float pen = ( ag -> radius + nei -> radius ) - dist ; if ( dist > 0.0001f ) pen = ( 1.0f / dist ) * ( pen * 0.5f ) * 0.7f ; dtVmad ( ag -> disp , ag -> disp , diff , pen ) ; w += 1.0f ; } if ( w > 0.0001f ) { const float iw = 1.0f / w ; dtVscale ( ag -> disp , ag -> disp , iw ) ; } } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; dtVadd ( ag -> npos , ag -> npos , ag -> disp ) ; } } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; ag -> corridor . movePosition ( ag -> npos , navquery , & m_filter ) ; dtVcopy ( ag -> npos , ag -> corridor . getPos ( ) ) ; } TimeVal endTime = getPerfTime ( ) ; int ns = 0 ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; if ( flags & CROWDMAN_USE_VO ) { m_vodebug [ i ] -> normalizeSamples ( ) ; ns += m_vodebug [ i ] -> getSampleCount ( ) ; } ag -> htrail = ( ag -> htrail + 1 ) % AGENT_MAX_TRAIL ; dtVcopy ( & ag -> trail [ ag -> htrail * 3 ] , ag -> npos ) ; } m_sampleCount = ns ; m_rvoTime = getPerfDeltaTimeUsec ( rvoStartTime , rvoEndTime ) ; m_totalTime = getPerfDeltaTimeUsec ( startTime , endTime ) ; } </DOCUMENT>
<DOCUMENT_ID="Earlz/dobbscoin-source/tree/master/src/test/transaction_tests.cpp"> # include " data / tx _ invalid . json . h " # include " data / tx _ valid . json . h " # include " clientversion . h " # include " key . h " # include " keystore . h " # include " main . h " # include " script / script . h " # include " script / script _ error . h " # include " core _ io . h " # include < map > # include < string > # include < boost / algorithm / string / classification . hpp > # include < boost / algorithm / string / split . hpp > # include < boost / test / unit_test . hpp > # include < boost / assign / list_of . hpp > # include " json / json _ spirit _ writer _ template . h " using namespace std ; using namespace json_spirit ; using namespace boost :: algorithm ; extern Array read_json ( const std :: string & jsondata ) ; static std :: map < string , unsigned int > mapFlagNames = boost :: assign :: map_list_of ( string ( " NONE " ) , ( unsigned int ) SCRIPT_VERIFY_NONE ) ( string ( " P2SH " ) , ( unsigned int ) SCRIPT_VERIFY_P2SH ) ( string ( " STRICTENC " ) , ( unsigned int ) SCRIPT_VERIFY_STRICTENC ) ( string ( " DERSIG " ) , ( unsigned int ) SCRIPT_VERIFY_DERSIG ) ( string ( " LOW _ S " ) , ( unsigned int ) SCRIPT_VERIFY_LOW_S ) ( string ( " SIGPUSHONLY " ) , ( unsigned int ) SCRIPT_VERIFY_SIGPUSHONLY ) ( string ( " MINIMALDATA " ) , ( unsigned int ) SCRIPT_VERIFY_MINIMALDATA ) ( string ( " NULLDUMMY " ) , ( unsigned int ) SCRIPT_VERIFY_NULLDUMMY ) ( string ( " DISCOURAGE _ UPGRADABLE _ NOPS " ) , ( unsigned int ) SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS ) ; unsigned int ParseScriptFlags ( string strFlags ) { if ( strFlags . empty ( ) ) { return 0 ; } unsigned int flags = 0 ; vector < string > words ; split ( words , strFlags , is_any_of ( " , " ) ) ; BOOST_FOREACH ( string word , words ) { if ( ! mapFlagNames . count ( word ) ) BOOST_ERROR ( " Bad ▁ test : ▁ unknown ▁ verification ▁ flag ▁ ' " << word << " ' " ) ; flags |= mapFlagNames [ word ] ; } return flags ; } string FormatScriptFlags ( unsigned int flags ) { if ( flags == 0 ) { return " " ; } string ret ; std :: map < string , unsigned int > :: const_iterator it = mapFlagNames . begin ( ) ; while ( it != mapFlagNames . end ( ) ) { if ( flags & it -> second ) { ret += it -> first + " , " ; } it ++ ; } return ret . substr ( 0 , ret . size ( ) - 1 ) ; } BOOST_AUTO_TEST_SUITE ( transaction_tests ) BOOST_AUTO_TEST_CASE ( tx_valid ) { Array tests = read_json ( std :: string ( json_tests :: tx_valid , json_tests :: tx_valid + sizeof ( json_tests :: tx_valid ) ) ) ; ScriptError err ; BOOST_FOREACH ( Value & tv , tests ) { Array test = tv . get_array ( ) ; string strTest = write_string ( tv , false ) ; if ( test [ 0 ] . type ( ) == array_type ) { if ( test . size ( ) != 3 || test [ 1 ] . type ( ) != str_type || test [ 2 ] . type ( ) != str_type ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } map < COutPoint , CScript > mapprevOutScriptPubKeys ; Array inputs = test [ 0 ] . get_array ( ) ; bool fValid = true ; BOOST_FOREACH ( Value & input , inputs ) { if ( input . type ( ) != array_type ) { fValid = false ; break ; } Array vinput = input . get_array ( ) ; if ( vinput . size ( ) != 3 ) { fValid = false ; break ; } mapprevOutScriptPubKeys [ COutPoint ( uint256 ( vinput [ 0 ] . get_str ( ) ) , vinput [ 1 ] . get_int ( ) ) ] = ParseScript ( vinput [ 2 ] . get_str ( ) ) ; } if ( ! fValid ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } string transaction = test [ 1 ] . get_str ( ) ; CDataStream stream ( ParseHex ( transaction ) , SER_NETWORK , PROTOCOL_VERSION ) ; CTransaction tx ; stream >> tx ; CValidationState state ; BOOST_CHECK_MESSAGE ( CheckTransaction ( tx , state ) , strTest ) ; BOOST_CHECK ( state . IsValid ( ) ) ; for ( unsigned int i = 0 ; i < tx . vin . size ( ) ; i ++ ) { if ( ! mapprevOutScriptPubKeys . count ( tx . vin [ i ] . prevout ) ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; break ; } unsigned int verify_flags = ParseScriptFlags ( test [ 2 ] . get_str ( ) ) ; BOOST_CHECK_MESSAGE ( VerifyScript ( tx . vin [ i ] . scriptSig , mapprevOutScriptPubKeys [ tx . vin [ i ] . prevout ] , verify_flags , TransactionSignatureChecker ( & tx , i ) , & err ) , strTest ) ; BOOST_CHECK_MESSAGE ( err == SCRIPT_ERR_OK , ScriptErrorString ( err ) ) ; } } } } BOOST_AUTO_TEST_CASE ( tx_invalid ) { Array tests = read_json ( std :: string ( json_tests :: tx_invalid , json_tests :: tx_invalid + sizeof ( json_tests :: tx_invalid ) ) ) ; ScriptError err ; BOOST_FOREACH ( Value & tv , tests ) { Array test = tv . get_array ( ) ; string strTest = write_string ( tv , false ) ; if ( test [ 0 ] . type ( ) == array_type ) { if ( test . size ( ) != 3 || test [ 1 ] . type ( ) != str_type || test [ 2 ] . type ( ) != str_type ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } map < COutPoint , CScript > mapprevOutScriptPubKeys ; Array inputs = test [ 0 ] . get_array ( ) ; bool fValid = true ; BOOST_FOREACH ( Value & input , inputs ) { if ( input . type ( ) != array_type ) { fValid = false ; break ; } Array vinput = input . get_array ( ) ; if ( vinput . size ( ) != 3 ) { fValid = false ; break ; } mapprevOutScriptPubKeys [ COutPoint ( uint256 ( vinput [ 0 ] . get_str ( ) ) , vinput [ 1 ] . get_int ( ) ) ] = ParseScript ( vinput [ 2 ] . get_str ( ) ) ; } if ( ! fValid ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } string transaction = test [ 1 ] . get_str ( ) ; CDataStream stream ( ParseHex ( transaction ) , SER_NETWORK , PROTOCOL_VERSION ) ; CTransaction tx ; stream >> tx ; CValidationState state ; fValid = CheckTransaction ( tx , state ) && state . IsValid ( ) ; for ( unsigned int i = 0 ; i < tx . vin . size ( ) && fValid ; i ++ ) { if ( ! mapprevOutScriptPubKeys . count ( tx . vin [ i ] . prevout ) ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; break ; } unsigned int verify_flags = ParseScriptFlags ( test [ 2 ] . get_str ( ) ) ; fValid = VerifyScript ( tx . vin [ i ] . scriptSig , mapprevOutScriptPubKeys [ tx . vin [ i ] . prevout ] , verify_flags , TransactionSignatureChecker ( & tx , i ) , & err ) ; } BOOST_CHECK_MESSAGE ( ! fValid , strTest ) ; BOOST_CHECK_MESSAGE ( err != SCRIPT_ERR_OK , ScriptErrorString ( err ) ) ; } } } BOOST_AUTO_TEST_CASE ( basic_transaction_tests ) { unsigned char ch [ ] = { 0x01 , 0x00 , 0x00 , 0x00 , 0x01 , 0x6b , 0xff , 0x7f , 0xcd , 0x4f , 0x85 , 0x65 , 0xef , 0x40 , 0x6d , 0xd5 , 0xd6 , 0x3d , 0x4f , 0xf9 , 0x4f , 0x31 , 0x8f , 0xe8 , 0x20 , 0x27 , 0xfd , 0x4d , 0xc4 , 0x51 , 0xb0 , 0x44 , 0x74 , 0x01 , 0x9f , 0x74 , 0xb4 , 0x00 , 0x00 , 0x00 , 0x00 , 0x8c , 0x49 , 0x30 , 0x46 , 0x02 , 0x21 , 0x00 , 0xda , 0x0d , 0xc6 , 0xae , 0xce , 0xfe , 0x1e , 0x06 , 0xef , 0xdf , 0x05 , 0x77 , 0x37 , 0x57 , 0xde , 0xb1 , 0x68 , 0x82 , 0x09 , 0x30 , 0xe3 , 0xb0 , 0xd0 , 0x3f , 0x46 , 0xf5 , 0xfc , 0xf1 , 0x50 , 0xbf , 0x99 , 0x0c , 0x02 , 0x21 , 0x00 , 0xd2 , 0x5b , 0x5c , 0x87 , 0x04 , 0x00 , 0x76 , 0xe4 , 0xf2 , 0x53 , 0xf8 , 0x26 , 0x2e , 0x76 , 0x3e , 0x2d , 0xd5 , 0x1e , 0x7f , 0xf0 , 0xbe , 0x15 , 0x77 , 0x27 , 0xc4 , 0xbc , 0x42 , 0x80 , 0x7f , 0x17 , 0xbd , 0x39 , 0x01 , 0x41 , 0x04 , 0xe6 , 0xc2 , 0x6e , 0xf6 , 0x7d , 0xc6 , 0x10 , 0xd2 , 0xcd , 0x19 , 0x24 , 0x84 , 0x78 , 0x9a , 0x6c , 0xf9 , 0xae , 0xa9 , 0x93 , 0x0b , 0x94 , 0x4b , 0x7e , 0x2d , 0xb5 , 0x34 , 0x2b , 0x9d , 0x9e , 0x5b , 0x9f , 0xf7 , 0x9a , 0xff , 0x9a , 0x2e , 0xe1 , 0x97 , 0x8d , 0xd7 , 0xfd , 0x01 , 0xdf , 0xc5 , 0x22 , 0xee , 0x02 , 0x28 , 0x3d , 0x3b , 0x06 , 0xa9 , 0xd0 , 0x3a , 0xcf , 0x80 , 0x96 , 0x96 , 0x8d , 0x7d , 0xbb , 0x0f , 0x91 , 0x78 , 0xff , 0xff , 0xff , 0xff , 0x02 , 0x8b , 0xa7 , 0x94 , 0x0e , 0x00 , 0x00 , 0x00 , 0x00 , 0x19 , 0x76 , 0xa9 , 0x14 , 0xba , 0xde , 0xec , 0xfd , 0xef , 0x05 , 0x07 , 0x24 , 0x7f , 0xc8 , 0xf7 , 0x42 , 0x41 , 0xd7 , 0x3b , 0xc0 , 0x39 , 0x97 , 0x2d , 0x7b , 0x88 , 0xac , 0x40 , 0x94 , 0xa8 , 0x02 , 0x00 , 0x00 , 0x00 , 0x00 , 0x19 , 0x76 , 0xa9 , 0x14 , 0xc1 , 0x09 , 0x32 , 0x48 , 0x3f , 0xec , 0x93 , 0xed , 0x51 , 0xf5 , 0xfe , 0x95 , 0xe7 , 0x25 , 0x59 , 0xf2 , 0xcc , 0x70 , 0x43 , 0xf9 , 0x88 , 0xac , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 } ; vector < unsigned char > vch ( ch , ch + sizeof ( ch ) - 1 ) ; CDataStream stream ( vch , SER_DISK , CLIENT_VERSION ) ; CMutableTransaction tx ; stream >> tx ; CValidationState state ; BOOST_CHECK_MESSAGE ( CheckTransaction ( tx , state ) && state . IsValid ( ) , " Simple ▁ deserialized ▁ transaction ▁ should ▁ be ▁ valid . " ) ; tx . vin . push_back ( tx . vin [ 0 ] ) ; BOOST_CHECK_MESSAGE ( ! CheckTransaction ( tx , state ) || ! state . IsValid ( ) , " Transaction ▁ with ▁ duplicate ▁ txins ▁ should ▁ be ▁ invalid . " ) ; } static std :: vector < CMutableTransaction > SetupDummyInputs ( CBasicKeyStore & keystoreRet , CCoinsViewCache & coinsRet ) { std :: vector < CMutableTransaction > dummyTransactions ; dummyTransactions . resize ( 2 ) ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { key [ i ] . MakeNewKey ( i % 2 ) ; keystoreRet . AddKey ( key [ i ] ) ; } dummyTransactions [ 0 ] . vout . resize ( 2 ) ; dummyTransactions [ 0 ] . vout [ 0 ] . nValue = 11 * CENT ; dummyTransactions [ 0 ] . vout [ 0 ] . scriptPubKey << ToByteVector ( key [ 0 ] . GetPubKey ( ) ) << OP_CHECKSIG ; dummyTransactions [ 0 ] . vout [ 1 ] . nValue = 50 * CENT ; dummyTransactions [ 0 ] . vout [ 1 ] . scriptPubKey << ToByteVector ( key [ 1 ] . GetPubKey ( ) ) << OP_CHECKSIG ; coinsRet . ModifyCoins ( dummyTransactions [ 0 ] . GetHash ( ) ) -> FromTx ( dummyTransactions [ 0 ] , 0 ) ; dummyTransactions [ 1 ] . vout . resize ( 2 ) ; dummyTransactions [ 1 ] . vout [ 0 ] . nValue = 21 * CENT ; dummyTransactions [ 1 ] . vout [ 0 ] . scriptPubKey = GetScriptForDestination ( key [ 2 ] . GetPubKey ( ) . GetID ( ) ) ; dummyTransactions [ 1 ] . vout [ 1 ] . nValue = 22 * CENT ; dummyTransactions [ 1 ] . vout [ 1 ] . scriptPubKey = GetScriptForDestination ( key [ 3 ] . GetPubKey ( ) . GetID ( ) ) ; coinsRet . ModifyCoins ( dummyTransactions [ 1 ] . GetHash ( ) ) -> FromTx ( dummyTransactions [ 1 ] , 0 ) ; return dummyTransactions ; } BOOST_AUTO_TEST_CASE ( test_Get ) { CBasicKeyStore keystore ; CCoinsView coinsDummy ; CCoinsViewCache coins ( & coinsDummy ) ; std :: vector < CMutableTransaction > dummyTransactions = SetupDummyInputs ( keystore , coins ) ; CMutableTransaction t1 ; t1 . vin . resize ( 3 ) ; t1 . vin [ 0 ] . prevout . hash = dummyTransactions [ 0 ] . GetHash ( ) ; t1 . vin [ 0 ] . prevout . n = 1 ; t1 . vin [ 0 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) ; t1 . vin [ 1 ] . prevout . hash = dummyTransactions [ 1 ] . GetHash ( ) ; t1 . vin [ 1 ] . prevout . n = 0 ; t1 . vin [ 1 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) << std :: vector < unsigned char > ( 33 , 4 ) ; t1 . vin [ 2 ] . prevout . hash = dummyTransactions [ 1 ] . GetHash ( ) ; t1 . vin [ 2 ] . prevout . n = 1 ; t1 . vin [ 2 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) << std :: vector < unsigned char > ( 33 , 4 ) ; t1 . vout . resize ( 2 ) ; t1 . vout [ 0 ] . nValue = 90 * CENT ; t1 . vout [ 0 ] . scriptPubKey << OP_1 ; BOOST_CHECK ( AreInputsStandard ( t1 , coins ) ) ; BOOST_CHECK_EQUAL ( coins . GetValueIn ( t1 ) , ( 50 + 21 + 22 ) * CENT ) ; t1 . vin [ 0 ] . scriptSig << OP_11 ; BOOST_CHECK ( ! AreInputsStandard ( t1 , coins ) ) ; t1 . vin [ 0 ] . scriptSig = CScript ( ) ; BOOST_CHECK ( ! AreInputsStandard ( t1 , coins ) ) ; } BOOST_AUTO_TEST_CASE ( test_IsStandard ) { LOCK ( cs_main ) ; CBasicKeyStore keystore ; CCoinsView coinsDummy ; CCoinsViewCache coins ( & coinsDummy ) ; std :: vector < CMutableTransaction > dummyTransactions = SetupDummyInputs ( keystore , coins ) ; CMutableTransaction t ; t . vin . resize ( 1 ) ; t . vin [ 0 ] . prevout . hash = dummyTransactions [ 0 ] . GetHash ( ) ; t . vin [ 0 ] . prevout . n = 1 ; t . vin [ 0 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) ; t . vout . resize ( 1 ) ; t . vout [ 0 ] . nValue = 90 * CENT ; CKey key ; key . MakeNewKey ( true ) ; t . vout [ 0 ] . scriptPubKey = GetScriptForDestination ( key . GetPubKey ( ) . GetID ( ) ) ; string reason ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . nValue = 501 ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . nValue = 601 ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_1 ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3800" ) ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout . resize ( 1 ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout . resize ( 2 ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; t . vout [ 1 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; t . vout [ 1 ] . scriptPubKey = CScript ( ) << OP_RETURN ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN ; t . vout [ 1 ] . scriptPubKey = CScript ( ) << OP_RETURN ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
<DOCUMENT_ID="afoksha/OpenGL/tree/master/demos/100_Player/player_5.cpp"> # include < iostream > # include < string > # include < thread > # include < mutex > # include < condition_variable > std :: mutex m ; std :: condition_variable cv ; std :: string data ; bool ready = false ; bool processed = false ; void worker_thread ( ) { std :: unique_lock < std :: mutex > lk ( m ) ; cv . wait ( lk , [ ] { return ready ; } ) ; std :: cout << " Worker ▁ thread ▁ is ▁ processing ▁ data \n " ; data += " ▁ after ▁ processing " ; processed = true ; std :: cout << " Worker ▁ thread ▁ signals ▁ data ▁ processing ▁ completed \n " ; lk . unlock ( ) ; cv . notify_one ( ) ; } int main ( int argc , char * argv [ ] ) { std :: thread worker ( worker_thread ) ; data = " Example ▁ data " ; { std :: lock_guard < std :: mutex > lk ( m ) ; ready = true ; std :: cout << " main ( ) ▁ signals ▁ data ▁ ready ▁ for ▁ processing \n " ; } cv . notify_one ( ) ; { std :: unique_lock < std :: mutex > lk ( m ) ; cv . wait ( lk , [ ] { return processed ; } ) ; } std :: cout << " Back ▁ in ▁ main ( ) , ▁ data ▁ = ▁ " << data << ' \n ' ; worker . join ( ) ; } </DOCUMENT>
<DOCUMENT_ID="pokowaka/xbmc/tree/master/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbumCompilations.cpp"> # include " DirectoryNodeAlbumCompilations . h " # include " QueryParams . h " # include " music / MusicDatabase . h " using namespace XFILE :: MUSICDATABASEDIRECTORY ; CDirectoryNodeAlbumCompilations :: CDirectoryNodeAlbumCompilations ( const std :: string & strName , CDirectoryNode * pParent ) : CDirectoryNode ( NODE_TYPE_ALBUM_COMPILATIONS , strName , pParent ) { } NODE_TYPE CDirectoryNodeAlbumCompilations :: GetChildType ( ) const { if ( GetName ( ) == " - 1" ) return NODE_TYPE_ALBUM_COMPILATIONS_SONGS ; return NODE_TYPE_SONG ; } std :: string CDirectoryNodeAlbumCompilations :: GetLocalizedName ( ) const { if ( GetID ( ) == - 1 ) return g_localizeStrings . Get ( 15102 ) ; CMusicDatabase db ; if ( db . Open ( ) ) return db . GetAlbumById ( GetID ( ) ) ; return " " ; } bool CDirectoryNodeAlbumCompilations :: GetContent ( CFileItemList & items ) const { CMusicDatabase musicdatabase ; if ( ! musicdatabase . Open ( ) ) return false ; CQueryParams params ; CollectQueryParams ( params ) ; bool bSuccess = musicdatabase . GetCompilationAlbums ( BuildPath ( ) , items ) ; musicdatabase . Close ( ) ; return bSuccess ; } </DOCUMENT>
<DOCUMENT_ID="SuperHex/psychic-aero/tree/master/base/HAL.cpp"> # ifndef __HAL__ # define __HAL__ # include . . / config / config . h # include < avr / io . h > namespace base { template < class init_traits , class rw_traits > struct hal { typedef init_traits I ; typedef rw_traits RW ; public : hal ( ) { I :: init ( ) ; } virtual ~ hal ( ) ; virtual void write ( const unsigned char data ) { RW :: write ( data ) ; } virtual unsigned char read ( ) { return RW :: read ( ) ; } } ; struct skip_init { static void init ( ) { } } ; struct USART_default_init { static void init ( const long baudRate ) { long ubrr = F_CPU / 16 / baudRate - 1 ; UBRR0H = ubrr >> 8 ; UBRR0L = ubrr ; UCSR0B = ( 1 << RXEN0 ) | ( 1 << TXEN0 ) ; UCSR0C = ( 3 << UCSZ00 ) ; } } ; struct USART_8N1_RW { public : static void write ( const unsigned char data ) { while ( ! ( UCSR0A & ( 1 << UDRE0 ) ) ) ; UDR0 = data ; } static unsigned char read ( ) { while ( ! ( UCSR0A & ( 1 << RXC0 ) ) ) ; return UDR0 ; } } ; struct SPI_RW { static void write ( unsigned char data ) { SPDR = data ; while ( ! ( SPSR & ( 1 << SPIF ) ) ) ; } static unsigned char read ( ) { while ( ! ( SPSR & ( 1 << SPIF ) ) ) ; return SPDR ; } } ; struct SPI_master_init { static void init ( ) { DDRB |= ( 1 << PB3 ) | ( 1 << PB5 ) | ( 1 << PB2 ) ; SPCR = ( 1 << SPE ) | ( 1 << MSTR ) | ( 1 << SPR0 ) ; } } ; struct SPI_slave_init { static void init ( ) { DDRB |= ( 1 << PB4 ) ; SPCR = ( 1 << SPE ) ; } } ; template < class T = USART_default_init > struct USART : public hal < skip_init , USART_8N1_RW > { public : USART ( const long Rate ) { T :: init ( Rate ) ; } virtual ~ USART ( ) ; } ; typedef USART < > Serial ; template < class T > struct SPI : public hal < T , SPI_RW > { } ; typedef SPI < SPI_master_init > SPIMaster ; typedef SPI < SPI_slave_init > SPISlave ; } # endif </DOCUMENT>
<DOCUMENT_ID="thivod/forgottenserver/tree/master/src/trashholder.cpp"> # include " otpch . h " # include " trashholder . h " # include " game . h " extern Game g_game ; TrashHolder :: TrashHolder ( uint16_t _type ) : Item ( _type ) { } TrashHolder :: ~ TrashHolder ( ) { } ReturnValue TrashHolder :: __queryAdd ( int32_t , const Thing * , uint32_t , uint32_t , Creature * ) const { return RET_NOERROR ; } ReturnValue TrashHolder :: __queryMaxCount ( int32_t , const Thing * , uint32_t count , uint32_t & maxQueryCount , uint32_t ) const { maxQueryCount = std :: max < uint32_t > ( 1 , count ) ; return RET_NOERROR ; } ReturnValue TrashHolder :: __queryRemove ( const Thing * , uint32_t , uint32_t ) const { return RET_NOTPOSSIBLE ; } Cylinder * TrashHolder :: __queryDestination ( int32_t & , const Thing * , Item * * , uint32_t & ) { return this ; } void TrashHolder :: __addThing ( Thing * thing ) { return __addThing ( 0 , thing ) ; } void TrashHolder :: __addThing ( int32_t , Thing * thing ) { Item * item = thing -> getItem ( ) ; if ( ! item ) { return ; } if ( item == this || ! item -> hasProperty ( CONST_PROP_MOVEABLE ) ) { return ; } if ( item -> isHangable ( ) && isGroundTile ( ) ) { Tile * tile = dynamic_cast < Tile * > ( getParent ( ) ) ; if ( tile && tile -> hasFlag ( TILESTATE_SUPPORTS_HANGABLE ) ) { return ; } } g_game . internalRemoveItem ( item ) ; const ItemType & it = Item :: items [ getID ( ) ] ; if ( it . magicEffect != CONST_ME_NONE ) { g_game . addMagicEffect ( getPosition ( ) , it . magicEffect ) ; } } void TrashHolder :: __updateThing ( Thing * , uint16_t , uint32_t ) { } void TrashHolder :: __replaceThing ( uint32_t , Thing * ) { } void TrashHolder :: __removeThing ( Thing * , uint32_t ) { } void TrashHolder :: postAddNotification ( Thing * thing , const Cylinder * oldParent , int32_t index , cylinderlink_t ) { getParent ( ) -> postAddNotification ( thing , oldParent , index , LINK_PARENT ) ; } void TrashHolder :: postRemoveNotification ( Thing * thing , const Cylinder * newParent , int32_t index , bool isCompleteRemoval , cylinderlink_t ) { getParent ( ) -> postRemoveNotification ( thing , newParent , index , isCompleteRemoval , LINK_PARENT ) ; } </DOCUMENT>
<DOCUMENT_ID="xlmbn/trscoin/tree/master/src/test/multisig_tests.cpp"> # include < boost / assert . hpp > # include < boost / assign / list_of . hpp > # include < boost / assign / list_inserter . hpp > # include < boost / assign / std / vector . hpp > # include < boost / test / unit_test . hpp > # include < boost / foreach . hpp > # include < boost / tuple / tuple . hpp > # include < openssl / ec . h > # include < openssl / err . h > # include " keystore . h " # include " main . h " # include " script . h " # include " wallet . h " using namespace std ; using namespace boost :: assign ; typedef vector < unsigned char > valtype ; extern uint256 SignatureHash ( CScript scriptCode , const CTransaction & txTo , unsigned int nIn , int nHashType ) ; BOOST_AUTO_TEST_SUITE ( multisig_tests ) CScript sign_multisig ( CScript scriptPubKey , vector < CKey > keys , CTransaction transaction , int whichIn ) { uint256 hash = SignatureHash ( scriptPubKey , transaction , whichIn , SIGHASH_ALL ) ; CScript result ; result << OP_0 ; BOOST_FOREACH ( const CKey & key , keys ) { vector < unsigned char > vchSig ; BOOST_CHECK ( key . Sign ( hash , vchSig ) ) ; vchSig . push_back ( ( unsigned char ) SIGHASH_ALL ) ; result << vchSig ; } return result ; } BOOST_AUTO_TEST_CASE ( multisig_verify ) { unsigned int flags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) key [ i ] . MakeNewKey ( true ) ; CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; CTransaction txFrom ; txFrom . vout . resize ( 3 ) ; txFrom . vout [ 0 ] . scriptPubKey = a_and_b ; txFrom . vout [ 1 ] . scriptPubKey = a_or_b ; txFrom . vout [ 2 ] . scriptPubKey = escrow ; CTransaction txTo [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { txTo [ i ] . vin . resize ( 1 ) ; txTo [ i ] . vout . resize ( 1 ) ; txTo [ i ] . vin [ 0 ] . prevout . n = i ; txTo [ i ] . vin [ 0 ] . prevout . hash = txFrom . GetHash ( ) ; txTo [ i ] . vout [ 0 ] . nValue = 1 ; } vector < CKey > keys ; CScript s ; keys . clear ( ) ; keys += key [ 0 ] , key [ 1 ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK ( VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) { keys . clear ( ) ; keys += key [ i ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) , strprintf ( " a & b ▁ 1 : ▁ % d " , i ) ) ; keys . clear ( ) ; keys += key [ 1 ] , key [ i ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) , strprintf ( " a & b ▁ 2 : ▁ % d " , i ) ) ; } for ( int i = 0 ; i < 4 ; i ++ ) { keys . clear ( ) ; keys += key [ i ] ; s = sign_multisig ( a_or_b , keys , txTo [ 1 ] , 0 ) ; if ( i == 0 || i == 1 ) BOOST_CHECK_MESSAGE ( VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) , strprintf ( " a | b : ▁ % d " , i ) ) ; else BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) , strprintf ( " a | b : ▁ % d " , i ) ) ; } s . clear ( ) ; s << OP_0 << OP_0 ; BOOST_CHECK ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) ) ; s . clear ( ) ; s << OP_0 << OP_1 ; BOOST_CHECK ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) { keys . clear ( ) ; keys += key [ i ] , key [ j ] ; s = sign_multisig ( escrow , keys , txTo [ 2 ] , 0 ) ; if ( i < j && i < 3 && j < 3 ) BOOST_CHECK_MESSAGE ( VerifyScript ( s , escrow , txTo [ 2 ] , 0 , flags , 0 ) , strprintf ( " escrow ▁ 1 : ▁ % d ▁ % d " , i , j ) ) ; else BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , escrow , txTo [ 2 ] , 0 , flags , 0 ) , strprintf ( " escrow ▁ 2 : ▁ % d ▁ % d " , i , j ) ) ; } } BOOST_AUTO_TEST_CASE ( multisig_IsStandard ) { CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) key [ i ] . MakeNewKey ( true ) ; CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( a_and_b ) ) ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( a_or_b ) ) ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( escrow ) ) ; CScript one_of_four ; one_of_four << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << key [ 3 ] . GetPubKey ( ) << OP_4 << OP_CHECKMULTISIG ; BOOST_CHECK ( ! :: IsStandard ( one_of_four ) ) ; CScript malformed [ 6 ] ; malformed [ 0 ] << OP_3 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; malformed [ 1 ] << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; malformed [ 2 ] << OP_0 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; malformed [ 3 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_0 << OP_CHECKMULTISIG ; malformed [ 4 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_CHECKMULTISIG ; malformed [ 5 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) ; for ( int i = 0 ; i < 6 ; i ++ ) BOOST_CHECK ( ! :: IsStandard ( malformed [ i ] ) ) ; } BOOST_AUTO_TEST_CASE ( multisig_Solver1 ) { CBasicKeyStore keystore , emptykeystore , partialkeystore ; CKey key [ 3 ] ; CTxDestination keyaddr [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { key [ i ] . MakeNewKey ( true ) ; keystore . AddKey ( key [ i ] ) ; keyaddr [ i ] = key [ i ] . GetPubKey ( ) . GetID ( ) ; } partialkeystore . AddKey ( key [ 0 ] ) ; { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << key [ 0 ] . GetPubKey ( ) << OP_CHECKSIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 1 ) ; CTxDestination addr ; BOOST_CHECK ( ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( addr == keyaddr [ 0 ] ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_DUP << OP_HASH160 << key [ 0 ] . GetPubKey ( ) . GetID ( ) << OP_EQUALVERIFY << OP_CHECKSIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 1 ) ; CTxDestination addr ; BOOST_CHECK ( ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( addr == keyaddr [ 0 ] ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK_EQUAL ( solutions . size ( ) , 4U ) ; CTxDestination addr ; BOOST_CHECK ( ! ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; BOOST_CHECK ( ! IsMine ( partialkeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK_EQUAL ( solutions . size ( ) , 4U ) ; vector < CTxDestination > addrs ; int nRequired ; BOOST_CHECK ( ExtractDestinations ( s , whichType , addrs , nRequired ) ) ; BOOST_CHECK ( addrs [ 0 ] == keyaddr [ 0 ] ) ; BOOST_CHECK ( addrs [ 1 ] == keyaddr [ 1 ] ) ; BOOST_CHECK ( nRequired == 1 ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; BOOST_CHECK ( ! IsMine ( partialkeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 5 ) ; } } BOOST_AUTO_TEST_CASE ( multisig_Sign ) { CBasicKeyStore keystore ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { key [ i ] . MakeNewKey ( true ) ; keystore . AddKey ( key [ i ] ) ; } CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; CTransaction txFrom ; txFrom . vout . resize ( 3 ) ; txFrom . vout [ 0 ] . scriptPubKey = a_and_b ; txFrom . vout [ 1 ] . scriptPubKey = a_or_b ; txFrom . vout [ 2 ] . scriptPubKey = escrow ; CTransaction txTo [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { txTo [ i ] . vin . resize ( 1 ) ; txTo [ i ] . vout . resize ( 1 ) ; txTo [ i ] . vin [ 0 ] . prevout . n = i ; txTo [ i ] . vin [ 0 ] . prevout . hash = txFrom . GetHash ( ) ; txTo [ i ] . vout [ 0 ] . nValue = 1 ; } for ( int i = 0 ; i < 3 ; i ++ ) { BOOST_CHECK_MESSAGE ( SignSignature ( keystore , txFrom , txTo [ i ] , 0 ) , strprintf ( " SignSignature ▁ % d " , i ) ) ; } } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
<DOCUMENT_ID="KonceptGeek/mosesdecoder/tree/master/mert/TER/infosHasher.cpp"> # include " infosHasher . h " using namespace std ; using namespace TERCPPNS_Tools ; namespace TERCPPNS_HashMapSpace { infosHasher :: infosHasher ( long cle , string cleTxt , vector < int > valueVecInt ) { m_hashKey = cle ; m_key = cleTxt ; m_value = valueVecInt ; } long infosHasher :: getHashKey ( ) { return m_hashKey ; } string infosHasher :: getKey ( ) { return m_key ; } vector < int > infosHasher :: getValue ( ) { return m_value ; } void infosHasher :: setValue ( vector < int > value ) { m_value = value ; } string infosHasher :: toString ( ) { stringstream to_return ; to_return << m_hashKey << " \t " << m_key << " \t " << vectorToString ( m_value , " \t " ) << endl ; return to_return . str ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="TTimo/doom3.gpl/tree/master/neo/tools/materialeditor/MaterialDef.cpp"> # include " . . / . . / idlib / precompiled . h " # pragma hdrstop # include " MaterialDef . h " MaterialDef :: MaterialDef ( void ) { type = 0 ; quotes = false ; } MaterialDef :: ~ MaterialDef ( void ) { } DWORD MaterialDef :: GetViewData ( const char * viewName ) { DWORD * value = NULL ; viewData . Get ( viewName , & value ) ; return * value ; } void MaterialDef :: SetViewData ( const char * viewName , DWORD value ) { viewData . Set ( viewName , value ) ; } # define MATERIAL_DEF_FILE " MaterialEditorDefs . med " MaterialDefList MaterialDefManager :: materialDefs [ MaterialDefManager :: MATERIAL_DEF_NUM ] ; void MaterialDefManager :: InitializeMaterialDefLists ( ) { char * buffer ; int length = fileSystem -> ReadFile ( MATERIAL_DEF_FILE , ( void * * ) & buffer ) ; if ( length == - 1 ) { common -> Error ( " Couldn ' t ▁ load ▁ material ▁ editor ▁ definition : ▁ % s " , MATERIAL_DEF_FILE ) ; return ; } idLexer src ; if ( ! src . LoadMemory ( buffer , length , MATERIAL_DEF_FILE ) ) { common -> Error ( " Couldn ' t ▁ parse ▁ % s " , MATERIAL_DEF_FILE ) ; fileSystem -> FreeFile ( buffer ) ; } InitializeMaterialDefList ( & src , " materialprops " , & materialDefs [ MATERIAL_DEF_MATERIAL ] ) ; InitializeMaterialDefList ( & src , " stageprops " , & materialDefs [ MATERIAL_DEF_STAGE ] ) ; InitializeMaterialDefList ( & src , " specialmapstageprops " , & materialDefs [ MATERIAL_DEF_SPECIAL_STAGE ] ) ; fileSystem -> FreeFile ( buffer ) ; } void MaterialDefManager :: InitializeMaterialDefList ( idLexer * src , const char * typeName , MaterialDefList * list ) { idToken token ; src -> Reset ( ) ; src -> SkipUntilString ( typeName ) ; src -> SkipUntilString ( " { " ) ; while ( 1 ) { if ( ! src -> ExpectAnyToken ( & token ) ) { return ; } if ( token == " } " ) { break ; } MaterialDef * newProp = new MaterialDef ( ) ; if ( ! token . Icmp ( " TYPE _ GROUP " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_GROUP ; } else if ( ! token . Icmp ( " TYPE _ BOOL " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_BOOL ; } else if ( ! token . Icmp ( " TYPE _ STRING " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_STRING ; } else if ( ! token . Icmp ( " TYPE _ FLOAT " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_FLOAT ; } else if ( ! token . Icmp ( " TYPE _ INT " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_INT ; } src -> ReadToken ( & token ) ; src -> ReadToken ( & token ) ; newProp -> dictName = token ; src -> ReadToken ( & token ) ; src -> ReadToken ( & token ) ; newProp -> displayName = token ; src -> ReadToken ( & token ) ; src -> ReadToken ( & token ) ; newProp -> displayInfo = token ; if ( newProp -> type == MaterialDef :: MATERIAL_DEF_TYPE_STRING ) { newProp -> quotes = false ; src -> ReadToken ( & token ) ; src -> ReadToken ( & token ) ; if ( token == "1" ) { newProp -> quotes = true ; } } src -> SkipRestOfLine ( ) ; list -> Append ( newProp ) ; } } void MaterialDefManager :: DestroyMaterialDefLists ( ) { for ( int i = 0 ; i < MATERIAL_DEF_NUM ; i ++ ) { for ( int j = 0 ; j < materialDefs [ i ] . Num ( ) ; j ++ ) { delete materialDefs [ i ] [ j ] ; } materialDefs [ i ] . Clear ( ) ; } } MaterialDefList * MaterialDefManager :: GetMaterialDefs ( int type ) { if ( type >= 0 && type < MATERIAL_DEF_NUM ) { return & materialDefs [ type ] ; } return NULL ; } </DOCUMENT>
<DOCUMENT_ID="dev-ily/ILoveYouCoins/tree/master/src/rpcwallet.cpp"> # include < boost / assign / list_of . hpp > # include " wallet . h " # include " walletdb . h " # include " bitcoinrpc . h " # include " init . h " # include " base58 . h " using namespace std ; using namespace boost ; using namespace boost :: assign ; using namespace json_spirit ; int64 nWalletUnlockTime ; static CCriticalSection cs_nWalletUnlockTime ; std :: string HelpRequiringPassphrase ( ) { return pwalletMain && pwalletMain -> IsCrypted ( ) ? " \n requires ▁ wallet ▁ passphrase ▁ to ▁ be ▁ set ▁ with ▁ walletpassphrase ▁ first " : " " ; } void EnsureWalletIsUnlocked ( ) { if ( pwalletMain -> IsLocked ( ) ) throw JSONRPCError ( RPC_WALLET_UNLOCK_NEEDED , " Error : ▁ Please ▁ enter ▁ the ▁ wallet ▁ passphrase ▁ with ▁ walletpassphrase ▁ first . " ) ; if ( fWalletUnlockStakingOnly ) throw JSONRPCError ( RPC_WALLET_ALREADY_UNLOCKED_STAKING_ONLY , " Error : ▁ Wallet ▁ is ▁ unlocked ▁ for ▁ staking ▁ only . " ) ; } void WalletTxToJSON ( const CWalletTx & wtx , Object & entry ) { int confirms = wtx . GetDepthInMainChain ( ) ; entry . push_back ( Pair ( " confirmations " , confirms ) ) ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) ) entry . push_back ( Pair ( " generated " , true ) ) ; if ( confirms > 0 ) { entry . push_back ( Pair ( " blockhash " , wtx . hashBlock . GetHex ( ) ) ) ; entry . push_back ( Pair ( " blockindex " , wtx . nIndex ) ) ; entry . push_back ( Pair ( " blocktime " , ( boost :: int64_t ) ( mapBlockIndex [ wtx . hashBlock ] -> nTime ) ) ) ; } entry . push_back ( Pair ( " txid " , wtx . GetHash ( ) . GetHex ( ) ) ) ; entry . push_back ( Pair ( " normtxid " , wtx . GetNormalizedHash ( ) . GetHex ( ) ) ) ; entry . push_back ( Pair ( " time " , ( boost :: int64_t ) wtx . GetTxTime ( ) ) ) ; entry . push_back ( Pair ( " timereceived " , ( boost :: int64_t ) wtx . nTimeReceived ) ) ; BOOST_FOREACH ( const PAIRTYPE ( string , string ) & item , wtx . mapValue ) entry . push_back ( Pair ( item . first , item . second ) ) ; } string AccountFromValue ( const Value & value ) { string strAccount = value . get_str ( ) ; if ( strAccount == " * " ) throw JSONRPCError ( RPC_WALLET_INVALID_ACCOUNT_NAME , " Invalid ▁ account ▁ name " ) ; return strAccount ; } Value getinfo ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 0 ) throw runtime_error ( " getinfo \n " " Returns ▁ an ▁ object ▁ containing ▁ various ▁ state ▁ info . " ) ; proxyType proxy ; GetProxy ( NET_IPV4 , proxy ) ; Object obj ; obj . push_back ( Pair ( " version " , ( int ) CLIENT_VERSION ) ) ; obj . push_back ( Pair ( " protocolversion " , ( int ) PROTOCOL_VERSION ) ) ; if ( pwalletMain ) { obj . push_back ( Pair ( " walletversion " , pwalletMain -> GetVersion ( ) ) ) ; obj . push_back ( Pair ( " balance " , ValueFromAmount ( pwalletMain -> GetBalance ( ) ) ) ) ; obj . push_back ( Pair ( " unconfirmedbalance " , ValueFromAmount ( pwalletMain -> GetUnconfirmedBalance ( ) ) ) ) ; obj . push_back ( Pair ( " stake " , ValueFromAmount ( pwalletMain -> GetStake ( ) ) ) ) ; obj . push_back ( Pair ( " locked " , pwalletMain -> IsLocked ( ) ) ) ; obj . push_back ( Pair ( " encrypted " , pwalletMain -> IsCrypted ( ) ) ) ; } obj . push_back ( Pair ( " blocks " , ( int ) nBestHeight ) ) ; obj . push_back ( Pair ( " timeoffset " , ( boost :: int64_t ) GetTimeOffset ( ) ) ) ; obj . push_back ( Pair ( " moneysupply " , ValueFromAmount ( pindexBest -> nMoneySupply ) ) ) ; obj . push_back ( Pair ( " connections " , ( int ) vNodes . size ( ) ) ) ; obj . push_back ( Pair ( " proxy " , ( proxy . first . IsValid ( ) ? proxy . first . ToStringIPPort ( ) : string ( ) ) ) ) ; obj . push_back ( Pair ( " difficulty " , ( double ) GetDifficulty ( ) ) ) ; obj . push_back ( Pair ( " testnet " , fTestNet ) ) ; if ( pwalletMain ) { obj . push_back ( Pair ( " keypoololdest " , ( boost :: int64_t ) pwalletMain -> GetOldestKeyPoolTime ( ) ) ) ; obj . push_back ( Pair ( " keypoolsize " , ( int ) pwalletMain -> GetKeyPoolSize ( ) ) ) ; } obj . push_back ( Pair ( " paytxfee " , ValueFromAmount ( nTransactionFee ) ) ) ; obj . push_back ( Pair ( " mininput " , ValueFromAmount ( nMinimumInputValue ) ) ) ; if ( pwalletMain && pwalletMain -> IsCrypted ( ) ) obj . push_back ( Pair ( " unlocked _ until " , ( boost :: int64_t ) nWalletUnlockTime ) ) ; obj . push_back ( Pair ( " errors " , GetWarnings ( " statusbar " ) ) ) ; return obj ; } Value getnewaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 1 ) throw runtime_error ( " getnewaddress ▁ [ account ] \n " " Returns ▁ a ▁ new ▁ ILoveYouCoins ▁ address ▁ for ▁ receiving ▁ payments . ▁ ▁ " " If ▁ [ account ] ▁ is ▁ specified ▁ ( recommended ) , ▁ it ▁ is ▁ added ▁ to ▁ the ▁ address ▁ book ▁ " " so ▁ payments ▁ received ▁ with ▁ the ▁ address ▁ will ▁ be ▁ credited ▁ to ▁ [ account ] . " ) ; string strAccount ; if ( params . size ( ) > 0 ) strAccount = AccountFromValue ( params [ 0 ] ) ; if ( ! pwalletMain -> IsLocked ( ) ) pwalletMain -> TopUpKeyPool ( ) ; CPubKey newKey ; if ( ! pwalletMain -> GetKeyFromPool ( newKey , false ) ) throw JSONRPCError ( RPC_WALLET_KEYPOOL_RAN_OUT , " Error : ▁ Keypool ▁ ran ▁ out , ▁ please ▁ call ▁ keypoolrefill ▁ first " ) ; CKeyID keyID = newKey . GetID ( ) ; pwalletMain -> SetAddressBookName ( keyID , strAccount ) ; return CBitcoinAddress ( keyID ) . ToString ( ) ; } CBitcoinAddress GetAccountAddress ( string strAccount , bool bForceNew = false ) { CWalletDB walletdb ( pwalletMain -> strWalletFile ) ; CAccount account ; walletdb . ReadAccount ( strAccount , account ) ; bool bKeyUsed = false ; if ( account . vchPubKey . IsValid ( ) ) { CScript scriptPubKey ; scriptPubKey . SetDestination ( account . vchPubKey . GetID ( ) ) ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) && account . vchPubKey . IsValid ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) if ( txout . scriptPubKey == scriptPubKey ) bKeyUsed = true ; } } if ( ! account . vchPubKey . IsValid ( ) || bForceNew || bKeyUsed ) { if ( ! pwalletMain -> GetKeyFromPool ( account . vchPubKey , false ) ) throw JSONRPCError ( RPC_WALLET_KEYPOOL_RAN_OUT , " Error : ▁ Keypool ▁ ran ▁ out , ▁ please ▁ call ▁ keypoolrefill ▁ first " ) ; pwalletMain -> SetAddressBookName ( account . vchPubKey . GetID ( ) , strAccount ) ; walletdb . WriteAccount ( strAccount , account ) ; } return CBitcoinAddress ( account . vchPubKey . GetID ( ) ) ; } Value getaccountaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " getaccountaddress ▁ < account > \n " " Returns ▁ the ▁ current ▁ ILoveYouCoins ▁ address ▁ for ▁ receiving ▁ payments ▁ to ▁ this ▁ account . " ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; Value ret ; ret = GetAccountAddress ( strAccount ) . ToString ( ) ; return ret ; } Value setaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " setaccount ▁ < iloveyoucoinsaddress > ▁ < account > \n " " Sets ▁ the ▁ account ▁ associated ▁ with ▁ the ▁ given ▁ address . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; string strAccount ; if ( params . size ( ) > 1 ) strAccount = AccountFromValue ( params [ 1 ] ) ; if ( pwalletMain -> mapAddressBook . count ( address . Get ( ) ) ) { string strOldAccount = pwalletMain -> mapAddressBook [ address . Get ( ) ] ; if ( address == GetAccountAddress ( strOldAccount ) ) GetAccountAddress ( strOldAccount , true ) ; } pwalletMain -> SetAddressBookName ( address . Get ( ) , strAccount ) ; return Value :: null ; } Value getaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " getaccount ▁ < iloveyoucoinsaddress > \n " " Returns ▁ the ▁ account ▁ associated ▁ with ▁ the ▁ given ▁ address . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; string strAccount ; map < CTxDestination , string > :: iterator mi = pwalletMain -> mapAddressBook . find ( address . Get ( ) ) ; if ( mi != pwalletMain -> mapAddressBook . end ( ) && ! ( * mi ) . second . empty ( ) ) strAccount = ( * mi ) . second ; return strAccount ; } Value getaddressesbyaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " getaddressesbyaccount ▁ < account > \n " " Returns ▁ the ▁ list ▁ of ▁ addresses ▁ for ▁ the ▁ given ▁ account . " ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; Array ret ; BOOST_FOREACH ( const PAIRTYPE ( CBitcoinAddress , string ) & item , pwalletMain -> mapAddressBook ) { const CBitcoinAddress & address = item . first ; const string & strName = item . second ; if ( strName == strAccount ) ret . push_back ( address . ToString ( ) ) ; } return ret ; } Value setmininput ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 1 ) throw runtime_error ( " setmininput ▁ < amount > \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ rounded ▁ to ▁ the ▁ nearest ▁ 0.00000001" ) ; int64 nAmount = 0 ; if ( params [ 0 ] . get_real ( ) != 0.0 ) nAmount = AmountFromValue ( params [ 0 ] ) ; nMinimumInputValue = nAmount ; return true ; } Value sendtoaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 4 ) throw runtime_error ( " sendtoaddress ▁ < iloveyoucoinsaddress > ▁ < amount > ▁ [ comment ] ▁ [ comment - to ] \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ rounded ▁ to ▁ the ▁ nearest ▁ 0.00000001" + HelpRequiringPassphrase ( ) ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; int64 nAmount = AmountFromValue ( params [ 1 ] ) ; CWalletTx wtx ; if ( params . size ( ) > 2 && params [ 2 ] . type ( ) != null_type && ! params [ 2 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " comment " ] = params [ 2 ] . get_str ( ) ; if ( params . size ( ) > 3 && params [ 3 ] . type ( ) != null_type && ! params [ 3 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " to " ] = params [ 3 ] . get_str ( ) ; EnsureWalletIsUnlocked ( ) ; string strError = pwalletMain -> SendMoneyToDestination ( address . Get ( ) , nAmount , wtx ) ; if ( strError != " " ) throw JSONRPCError ( RPC_WALLET_ERROR , strError ) ; return wtx . GetHash ( ) . GetHex ( ) ; } Value listaddressgroupings ( const Array & params , bool fHelp ) { if ( fHelp ) throw runtime_error ( " listaddressgroupings \n " " Lists ▁ groups ▁ of ▁ addresses ▁ which ▁ have ▁ had ▁ their ▁ common ▁ ownership \n " " made ▁ public ▁ by ▁ common ▁ use ▁ as ▁ inputs ▁ or ▁ as ▁ the ▁ resulting ▁ change \n " " in ▁ past ▁ transactions " ) ; Array jsonGroupings ; map < CTxDestination , int64 > balances = pwalletMain -> GetAddressBalances ( ) ; BOOST_FOREACH ( set < CTxDestination > grouping , pwalletMain -> GetAddressGroupings ( ) ) { Array jsonGrouping ; BOOST_FOREACH ( CTxDestination address , grouping ) { Array addressInfo ; addressInfo . push_back ( CBitcoinAddress ( address ) . ToString ( ) ) ; addressInfo . push_back ( ValueFromAmount ( balances [ address ] ) ) ; { LOCK ( pwalletMain -> cs_wallet ) ; if ( pwalletMain -> mapAddressBook . find ( CBitcoinAddress ( address ) . Get ( ) ) != pwalletMain -> mapAddressBook . end ( ) ) addressInfo . push_back ( pwalletMain -> mapAddressBook . find ( CBitcoinAddress ( address ) . Get ( ) ) -> second ) ; } jsonGrouping . push_back ( addressInfo ) ; } jsonGroupings . push_back ( jsonGrouping ) ; } return jsonGroupings ; } Value signmessage ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 2 ) throw runtime_error ( " signmessage ▁ < iloveyoucoinsaddress > ▁ < message > \n " " Sign ▁ a ▁ message ▁ with ▁ the ▁ private ▁ key ▁ of ▁ an ▁ address " ) ; EnsureWalletIsUnlocked ( ) ; string strAddress = params [ 0 ] . get_str ( ) ; string strMessage = params [ 1 ] . get_str ( ) ; CBitcoinAddress addr ( strAddress ) ; if ( ! addr . IsValid ( ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Invalid ▁ address " ) ; CKeyID keyID ; if ( ! addr . GetKeyID ( keyID ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Address ▁ does ▁ not ▁ refer ▁ to ▁ key " ) ; CKey key ; if ( ! pwalletMain -> GetKey ( keyID , key ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Private ▁ key ▁ not ▁ available " ) ; CHashWriter ss ( SER_GETHASH , 0 ) ; ss << strMessageMagic ; ss << strMessage ; vector < unsigned char > vchSig ; if ( ! key . SignCompact ( ss . GetHash ( ) , vchSig ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Sign ▁ failed " ) ; return EncodeBase64 ( & vchSig [ 0 ] , vchSig . size ( ) ) ; } Value verifymessage ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 3 ) throw runtime_error ( " verifymessage ▁ < iloveyoucoinsaddress > ▁ < signature > ▁ < message > \n " " Verify ▁ a ▁ signed ▁ message " ) ; string strAddress = params [ 0 ] . get_str ( ) ; string strSign = params [ 1 ] . get_str ( ) ; string strMessage = params [ 2 ] . get_str ( ) ; CBitcoinAddress addr ( strAddress ) ; if ( ! addr . IsValid ( ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Invalid ▁ address " ) ; CKeyID keyID ; if ( ! addr . GetKeyID ( keyID ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Address ▁ does ▁ not ▁ refer ▁ to ▁ key " ) ; bool fInvalid = false ; vector < unsigned char > vchSig = DecodeBase64 ( strSign . c_str ( ) , & fInvalid ) ; if ( fInvalid ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Malformed ▁ base64 ▁ encoding " ) ; CHashWriter ss ( SER_GETHASH , 0 ) ; ss << strMessageMagic ; ss << strMessage ; CPubKey pubkey ; if ( ! pubkey . RecoverCompact ( ss . GetHash ( ) , vchSig ) ) return false ; return ( pubkey . GetID ( ) == keyID ) ; } Value getreceivedbyaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " getreceivedbyaddress ▁ < iloveyoucoinsaddress > ▁ [ minconf = 1 ] \n " " Returns ▁ the ▁ total ▁ amount ▁ received ▁ by ▁ < iloveyoucoinsaddress > ▁ in ▁ transactions ▁ with ▁ at ▁ least ▁ [ minconf ] ▁ confirmations . " ) ; CBitcoinAddress address = CBitcoinAddress ( params [ 0 ] . get_str ( ) ) ; CScript scriptPubKey ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; scriptPubKey . SetDestination ( address . Get ( ) ) ; if ( ! IsMine ( * pwalletMain , scriptPubKey ) ) return ( double ) 0.0 ; int nMinDepth = 1 ; if ( params . size ( ) > 1 ) nMinDepth = params [ 1 ] . get_int ( ) ; int64 nAmount = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) || ! wtx . IsFinal ( ) ) continue ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) if ( txout . scriptPubKey == scriptPubKey ) if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) nAmount += txout . nValue ; } return ValueFromAmount ( nAmount ) ; } void GetAccountAddresses ( string strAccount , set < CTxDestination > & setAddress ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , string ) & item , pwalletMain -> mapAddressBook ) { const CTxDestination & address = item . first ; const string & strName = item . second ; if ( strName == strAccount ) setAddress . insert ( address ) ; } } Value getreceivedbyaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " getreceivedbyaccount ▁ < account > ▁ [ minconf = 1 ] \n " " Returns ▁ the ▁ total ▁ amount ▁ received ▁ by ▁ addresses ▁ with ▁ < account > ▁ in ▁ transactions ▁ with ▁ at ▁ least ▁ [ minconf ] ▁ confirmations . " ) ; int nMinDepth = 1 ; if ( params . size ( ) > 1 ) nMinDepth = params [ 1 ] . get_int ( ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; set < CTxDestination > setAddress ; GetAccountAddresses ( strAccount , setAddress ) ; int64 nAmount = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) || ! wtx . IsFinal ( ) ) continue ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) { CTxDestination address ; if ( ExtractDestination ( txout . scriptPubKey , address ) && IsMine ( * pwalletMain , address ) && setAddress . count ( address ) ) if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) nAmount += txout . nValue ; } } return ( double ) nAmount / ( double ) COIN ; } int64 GetAccountBalance ( CWalletDB & walletdb , const string & strAccount , int nMinDepth ) { int64 nBalance = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . IsFinal ( ) ) continue ; int64 nReceived , nSent , nFee ; wtx . GetAccountAmounts ( strAccount , nReceived , nSent , nFee ) ; if ( nReceived != 0 && wtx . GetDepthInMainChain ( ) >= nMinDepth ) nBalance += nReceived ; nBalance -= nSent + nFee ; } nBalance += walletdb . GetAccountCreditDebit ( strAccount ) ; return nBalance ; } int64 GetAccountBalance ( const string & strAccount , int nMinDepth ) { CWalletDB walletdb ( pwalletMain -> strWalletFile ) ; return GetAccountBalance ( walletdb , strAccount , nMinDepth ) ; } Value getbalance ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " getbalance ▁ [ account ] ▁ [ minconf = 1 ] \n " " If ▁ [ account ] ▁ is ▁ not ▁ specified , ▁ returns ▁ the ▁ server ' s ▁ total ▁ available ▁ balance . \n " " If ▁ [ account ] ▁ is ▁ specified , ▁ returns ▁ the ▁ balance ▁ in ▁ the ▁ account . " ) ; if ( params . size ( ) == 0 ) return ValueFromAmount ( pwalletMain -> GetBalance ( ) ) ; int nMinDepth = 1 ; if ( params . size ( ) > 1 ) nMinDepth = params [ 1 ] . get_int ( ) ; if ( params [ 0 ] . get_str ( ) == " * " ) { int64 nBalance = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . IsConfirmed ( ) ) continue ; int64 allFee ; string strSentAccount ; list < pair < CTxDestination , int64 > > listReceived ; list < pair < CTxDestination , int64 > > listSent ; wtx . GetAmounts ( listReceived , listSent , allFee , strSentAccount ) ; if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listReceived ) nBalance += r . second ; } BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listSent ) nBalance -= r . second ; nBalance -= allFee ; } return ValueFromAmount ( nBalance ) ; } string strAccount = AccountFromValue ( params [ 0 ] ) ; int64 nBalance = GetAccountBalance ( strAccount , nMinDepth ) ; return ValueFromAmount ( nBalance ) ; } Value getunconfirmedbalance ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 0 ) throw runtime_error ( " getunconfirmedbalance \n " " Returns ▁ the ▁ server ' s ▁ total ▁ unconfirmed ▁ balance \n " ) ; return ValueFromAmount ( pwalletMain -> GetUnconfirmedBalance ( ) ) ; } Value movecmd ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 3 || params . size ( ) > 5 ) throw runtime_error ( " move ▁ < fromaccount > ▁ < toaccount > ▁ < amount > ▁ [ minconf = 1 ] ▁ [ comment ] \n " " Move ▁ from ▁ one ▁ account ▁ in ▁ your ▁ wallet ▁ to ▁ another . " ) ; string strFrom = AccountFromValue ( params [ 0 ] ) ; string strTo = AccountFromValue ( params [ 1 ] ) ; int64 nAmount = AmountFromValue ( params [ 2 ] ) ; if ( params . size ( ) > 3 ) ( void ) params [ 3 ] . get_int ( ) ; string strComment ; if ( params . size ( ) > 4 ) strComment = params [ 4 ] . get_str ( ) ; CWalletDB walletdb ( pwalletMain -> strWalletFile ) ; if ( ! walletdb . TxnBegin ( ) ) throw JSONRPCError ( RPC_DATABASE_ERROR , " database ▁ error " ) ; int64 nNow = GetAdjustedTime ( ) ; CAccountingEntry debit ; debit . nOrderPos = pwalletMain -> IncOrderPosNext ( & walletdb ) ; debit . strAccount = strFrom ; debit . nCreditDebit = - nAmount ; debit . nTime = nNow ; debit . strOtherAccount = strTo ; debit . strComment = strComment ; walletdb . WriteAccountingEntry ( debit ) ; CAccountingEntry credit ; credit . nOrderPos = pwalletMain -> IncOrderPosNext ( & walletdb ) ; credit . strAccount = strTo ; credit . nCreditDebit = nAmount ; credit . nTime = nNow ; credit . strOtherAccount = strFrom ; credit . strComment = strComment ; walletdb . WriteAccountingEntry ( credit ) ; if ( ! walletdb . TxnCommit ( ) ) throw JSONRPCError ( RPC_DATABASE_ERROR , " database ▁ error " ) ; return true ; } Value sendfrom ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 3 || params . size ( ) > 6 ) throw runtime_error ( " sendfrom ▁ < fromaccount > ▁ < toiloveyoucoinsaddress > ▁ < amount > ▁ [ minconf = 1 ] ▁ [ comment ] ▁ [ comment - to ] \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ rounded ▁ to ▁ the ▁ nearest ▁ 0.00000001" + HelpRequiringPassphrase ( ) ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; CBitcoinAddress address ( params [ 1 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; int64 nAmount = AmountFromValue ( params [ 2 ] ) ; int nMinDepth = 1 ; if ( params . size ( ) > 3 ) nMinDepth = params [ 3 ] . get_int ( ) ; CWalletTx wtx ; wtx . strFromAccount = strAccount ; if ( params . size ( ) > 4 && params [ 4 ] . type ( ) != null_type && ! params [ 4 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " comment " ] = params [ 4 ] . get_str ( ) ; if ( params . size ( ) > 5 && params [ 5 ] . type ( ) != null_type && ! params [ 5 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " to " ] = params [ 5 ] . get_str ( ) ; EnsureWalletIsUnlocked ( ) ; int64 nBalance = GetAccountBalance ( strAccount , nMinDepth ) ; if ( nAmount > nBalance ) throw JSONRPCError ( RPC_WALLET_INSUFFICIENT_FUNDS , " Account ▁ has ▁ insufficient ▁ funds " ) ; string strError = pwalletMain -> SendMoneyToDestination ( address . Get ( ) , nAmount , wtx ) ; if ( strError != " " ) throw JSONRPCError ( RPC_WALLET_ERROR , strError ) ; return wtx . GetHash ( ) . GetHex ( ) ; } Value sendmany ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 4 ) throw runtime_error ( " sendmany ▁ < fromaccount > ▁ { address : amount , . . . } ▁ [ minconf = 1 ] ▁ [ comment ] \n " " amounts ▁ are ▁ double - precision ▁ floating ▁ point ▁ numbers " + HelpRequiringPassphrase ( ) ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; Object sendTo = params [ 1 ] . get_obj ( ) ; int nMinDepth = 1 ; if ( params . size ( ) > 2 ) nMinDepth = params [ 2 ] . get_int ( ) ; CWalletTx wtx ; wtx . strFromAccount = strAccount ; if ( params . size ( ) > 3 && params [ 3 ] . type ( ) != null_type && ! params [ 3 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " comment " ] = params [ 3 ] . get_str ( ) ; set < CBitcoinAddress > setAddress ; vector < pair < CScript , int64 > > vecSend ; int64 totalAmount = 0 ; BOOST_FOREACH ( const Pair & s , sendTo ) { CBitcoinAddress address ( s . name_ ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , string ( " Invalid ▁ ILoveYouCoins ▁ address : ▁ " ) + s . name_ ) ; if ( setAddress . count ( address ) ) throw JSONRPCError ( RPC_INVALID_PARAMETER , string ( " Invalid ▁ parameter , ▁ duplicated ▁ address : ▁ " ) + s . name_ ) ; setAddress . insert ( address ) ; CScript scriptPubKey ; scriptPubKey . SetDestination ( address . Get ( ) ) ; int64 nAmount = AmountFromValue ( s . value_ ) ; totalAmount += nAmount ; vecSend . push_back ( make_pair ( scriptPubKey , nAmount ) ) ; } EnsureWalletIsUnlocked ( ) ; int64 nBalance = GetAccountBalance ( strAccount , nMinDepth ) ; if ( totalAmount > nBalance ) throw JSONRPCError ( RPC_WALLET_INSUFFICIENT_FUNDS , " Account ▁ has ▁ insufficient ▁ funds " ) ; CReserveKey keyChange ( pwalletMain ) ; int64 nFeeRequired = 0 ; string strFailReason ; bool fCreated = pwalletMain -> CreateTransaction ( vecSend , wtx , keyChange , nFeeRequired , strFailReason ) ; if ( ! fCreated ) throw JSONRPCError ( RPC_WALLET_INSUFFICIENT_FUNDS , strFailReason ) ; if ( ! pwalletMain -> CommitTransaction ( wtx , keyChange ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Transaction ▁ commit ▁ failed " ) ; return wtx . GetHash ( ) . GetHex ( ) ; } static CScript _createmultisig ( const Array & params ) { int nRequired = params [ 0 ] . get_int ( ) ; const Array & keys = params [ 1 ] . get_array ( ) ; if ( nRequired < 1 ) throw runtime_error ( " a ▁ multisignature ▁ address ▁ must ▁ require ▁ at ▁ least ▁ one ▁ key ▁ to ▁ redeem " ) ; if ( ( int ) keys . size ( ) < nRequired ) throw runtime_error ( strprintf ( " not ▁ enough ▁ keys ▁ supplied ▁ " " ( got ▁ % " PRIszu " ▁ keys , ▁ but ▁ need ▁ at ▁ least ▁ % d ▁ to ▁ redeem ) " , keys . size ( ) , nRequired ) ) ; std :: vector < CPubKey > pubkeys ; pubkeys . resize ( keys . size ( ) ) ; for ( unsigned int i = 0 ; i < keys . size ( ) ; i ++ ) { const std :: string & ks = keys [ i ] . get_str ( ) ; CBitcoinAddress address ( ks ) ; if ( pwalletMain && address . IsValid ( ) ) { CKeyID keyID ; if ( ! address . GetKeyID ( keyID ) ) throw runtime_error ( strprintf ( " % s ▁ does ▁ not ▁ refer ▁ to ▁ a ▁ key " , ks . c_str ( ) ) ) ; CPubKey vchPubKey ; if ( ! pwalletMain -> GetPubKey ( keyID , vchPubKey ) ) throw runtime_error ( strprintf ( " no ▁ full ▁ public ▁ key ▁ for ▁ address ▁ % s " , ks . c_str ( ) ) ) ; if ( ! vchPubKey . IsFullyValid ( ) ) throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; pubkeys [ i ] = vchPubKey ; } else if ( IsHex ( ks ) ) { CPubKey vchPubKey ( ParseHex ( ks ) ) ; if ( ! vchPubKey . IsFullyValid ( ) ) throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; pubkeys [ i ] = vchPubKey ; } else { throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; } } CScript result ; result . SetMultisig ( nRequired , pubkeys ) ; return result ; } Value addmultisigaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 3 ) { string msg = " addmultisigaddress ▁ < nrequired > ▁ < ' [ \ " key\ " , \ " key\ " ] ' > ▁ [ account ] \n " " Add ▁ a ▁ nrequired - to - sign ▁ multisignature ▁ address ▁ to ▁ the ▁ wallet\ " \n " " each ▁ key ▁ is ▁ a ▁ ILoveYouCoins ▁ address ▁ or ▁ hex - encoded ▁ public ▁ key \n " " If ▁ [ account ] ▁ is ▁ specified , ▁ assign ▁ address ▁ to ▁ [ account ] . " ; throw runtime_error ( msg ) ; } string strAccount ; if ( params . size ( ) > 2 ) strAccount = AccountFromValue ( params [ 2 ] ) ; CScript inner = _createmultisig ( params ) ; CScriptID innerID = inner . GetID ( ) ; pwalletMain -> AddCScript ( inner ) ; pwalletMain -> SetAddressBookName ( innerID , strAccount ) ; return CBitcoinAddress ( innerID ) . ToString ( ) ; } Value createmultisig ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 2 ) { string msg = " createmultisig ▁ < nrequired > ▁ < ' [ \ " key\ " , \ " key\ " ] ' > \n " " Creates ▁ a ▁ multi - signature ▁ address ▁ and ▁ returns ▁ a ▁ json ▁ object \n " " with ▁ keys : \n " " address ▁ : ▁ iloveyoucoins ▁ address \n " " redeemScript ▁ : ▁ hex - encoded ▁ redemption ▁ script " ; throw runtime_error ( msg ) ; } CScript inner = _createmultisig ( params ) ; CScriptID innerID = inner . GetID ( ) ; CBitcoinAddress address ( innerID ) ; Object result ; result . push_back ( Pair ( " address " , address . ToString ( ) ) ) ; result . push_back ( Pair ( " redeemScript " , HexStr ( inner . begin ( ) , inner . end ( ) ) ) ) ; return result ; } struct tallyitem { int64 nAmount ; int nConf ; vector < uint256 > txids ; tallyitem ( ) { nAmount = 0 ; nConf = std :: numeric_limits < int > :: max ( ) ; } } ; Value ListReceived ( const Array & params , bool fByAccounts ) { int nMinDepth = 1 ; if ( params . size ( ) > 0 ) nMinDepth = params [ 0 ] . get_int ( ) ; bool fIncludeEmpty = false ; if ( params . size ( ) > 1 ) fIncludeEmpty = params [ 1 ] . get_bool ( ) ; map < CBitcoinAddress , tallyitem > mapTally ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) || ! wtx . IsFinal ( ) ) continue ; int nDepth = wtx . GetDepthInMainChain ( ) ; if ( nDepth < nMinDepth ) continue ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) { CTxDestination address ; if ( ! ExtractDestination ( txout . scriptPubKey , address ) || ! IsMine ( * pwalletMain , address ) ) continue ; tallyitem & item = mapTally [ address ] ; item . nAmount += txout . nValue ; item . nConf = min ( item . nConf , nDepth ) ; item . txids . push_back ( wtx . GetHash ( ) ) ; } } Array ret ; map < string , tallyitem > mapAccountTally ; BOOST_FOREACH ( const PAIRTYPE ( CBitcoinAddress , string ) & item , pwalletMain -> mapAddressBook ) { const CBitcoinAddress & address = item . first ; const string & strAccount = item . second ; map < CBitcoinAddress , tallyitem > :: iterator it = mapTally . find ( address ) ; if ( it == mapTally . end ( ) && ! fIncludeEmpty ) continue ; int64 nAmount = 0 ; int nConf = std :: numeric_limits < int > :: max ( ) ; if ( it != mapTally . end ( ) ) { nAmount = ( * it ) . second . nAmount ; nConf = ( * it ) . second . nConf ; } if ( fByAccounts ) { tallyitem & item = mapAccountTally [ strAccount ] ; item . nAmount += nAmount ; item . nConf = min ( item . nConf , nConf ) ; } else { Object obj ; obj . push_back ( Pair ( " address " , address . ToString ( ) ) ) ; obj . push_back ( Pair ( " account " , strAccount ) ) ; obj . push_back ( Pair ( " amount " , ValueFromAmount ( nAmount ) ) ) ; obj . push_back ( Pair ( " confirmations " , ( nConf == std :: numeric_limits < int > :: max ( ) ? 0 : nConf ) ) ) ; Array transactions ; if ( it != mapTally . end ( ) ) { BOOST_FOREACH ( const uint256 & item , ( * it ) . second . txids ) { transactions . push_back ( item . GetHex ( ) ) ; } } obj . push_back ( Pair ( " txids " , transactions ) ) ; ret . push_back ( obj ) ; } } if ( fByAccounts ) { for ( map < string , tallyitem > :: iterator it = mapAccountTally . begin ( ) ; it != mapAccountTally . end ( ) ; ++ it ) { int64 nAmount = ( * it ) . second . nAmount ; int nConf = ( * it ) . second . nConf ; Object obj ; obj . push_back ( Pair ( " account " , ( * it ) . first ) ) ; obj . push_back ( Pair ( " amount " , ValueFromAmount ( nAmount ) ) ) ; obj . push_back ( Pair ( " confirmations " , ( nConf == std :: numeric_limits < int > :: max ( ) ? 0 : nConf ) ) ) ; ret . push_back ( obj ) ; } } return ret ; } Value listreceivedbyaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " listreceivedbyaddress ▁ [ minconf = 1 ] ▁ [ includeempty = false ] \n " " [ minconf ] ▁ is ▁ the ▁ minimum ▁ number ▁ of ▁ confirmations ▁ before ▁ payments ▁ are ▁ included . \n " " [ includeempty ] ▁ whether ▁ to ▁ include ▁ addresses ▁ that ▁ haven ' t ▁ received ▁ any ▁ payments . \n " " Returns ▁ an ▁ array ▁ of ▁ objects ▁ containing : \n " " ▁ ▁ \ " address\ " ▁ : ▁ receiving ▁ address \n " " ▁ ▁ \ " account\ " ▁ : ▁ the ▁ account ▁ of ▁ the ▁ receiving ▁ address \n " " ▁ ▁ \ " amount\ " ▁ : ▁ total ▁ amount ▁ received ▁ by ▁ the ▁ address \n " " ▁ ▁ \ " confirmations\ " ▁ : ▁ number ▁ of ▁ confirmations ▁ of ▁ the ▁ most ▁ recent ▁ transaction ▁ included \n " " ▁ ▁ \ " txids\ " ▁ : ▁ list ▁ of ▁ transactions ▁ with ▁ outputs ▁ to ▁ the ▁ address \n " ) ; return ListReceived ( params , false ) ; } Value listreceivedbyaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " listreceivedbyaccount ▁ [ minconf = 1 ] ▁ [ includeempty = false ] \n " " [ minconf ] ▁ is ▁ the ▁ minimum ▁ number ▁ of ▁ confirmations ▁ before ▁ payments ▁ are ▁ included . \n " " [ includeempty ] ▁ whether ▁ to ▁ include ▁ accounts ▁ that ▁ haven ' t ▁ received ▁ any ▁ payments . \n " " Returns ▁ an ▁ array ▁ of ▁ objects ▁ containing : \n " " ▁ ▁ \ " account\ " ▁ : ▁ the ▁ account ▁ of ▁ the ▁ receiving ▁ addresses \n " " ▁ ▁ \ " amount\ " ▁ : ▁ total ▁ amount ▁ received ▁ by ▁ addresses ▁ with ▁ this ▁ account \n " " ▁ ▁ \ " confirmations\ " ▁ : ▁ number ▁ of ▁ confirmations ▁ of ▁ the ▁ most ▁ recent ▁ transaction ▁ included " ) ; return ListReceived ( params , true ) ; } static void MaybePushAddress ( Object & entry , const CTxDestination & dest ) { CBitcoinAddress addr ; if ( addr . Set ( dest ) ) entry . push_back ( Pair ( " address " , addr . ToString ( ) ) ) ; } void ListTransactions ( const CWalletTx & wtx , const string & strAccount , int nMinDepth , bool fLong , Array & ret ) { int64 nFee ; string strSentAccount ; list < pair < CTxDestination , int64 > > listReceived ; list < pair < CTxDestination , int64 > > listSent ; wtx . GetAmounts ( listReceived , listSent , nFee , strSentAccount ) ; bool fAllAccounts = ( strAccount == string ( " * " ) ) ; if ( ! wtx . IsCoinStake ( ) && ( ! listSent . empty ( ) || nFee != 0 ) && ( fAllAccounts || strAccount == strSentAccount ) ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & s , listSent ) { Object entry ; entry . push_back ( Pair ( " account " , strSentAccount ) ) ; MaybePushAddress ( entry , s . first ) ; entry . push_back ( Pair ( " category " , " send " ) ) ; entry . push_back ( Pair ( " amount " , ValueFromAmount ( - s . second ) ) ) ; entry . push_back ( Pair ( " fee " , ValueFromAmount ( - nFee ) ) ) ; if ( fLong ) WalletTxToJSON ( wtx , entry ) ; ret . push_back ( entry ) ; } } if ( listReceived . size ( ) > 0 && wtx . GetDepthInMainChain ( ) >= nMinDepth ) { bool stop = false ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listReceived ) { string account ; if ( pwalletMain -> mapAddressBook . count ( r . first ) ) account = pwalletMain -> mapAddressBook [ r . first ] ; if ( fAllAccounts || ( account == strAccount ) ) { Object entry ; entry . push_back ( Pair ( " account " , account ) ) ; MaybePushAddress ( entry , r . first ) ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) ) { if ( wtx . GetDepthInMainChain ( ) < 1 ) entry . push_back ( Pair ( " category " , " orphan " ) ) ; else if ( wtx . GetBlocksToMaturity ( ) > 0 ) entry . push_back ( Pair ( " category " , " immature " ) ) ; else if ( wtx . IsCoinStake ( ) ) entry . push_back ( Pair ( " category " , " stake " ) ) ; else entry . push_back ( Pair ( " category " , " generate " ) ) ; } else { entry . push_back ( Pair ( " category " , " receive " ) ) ; } if ( ! wtx . IsCoinStake ( ) ) entry . push_back ( Pair ( " amount " , ValueFromAmount ( r . second ) ) ) ; else { entry . push_back ( Pair ( " amount " , ValueFromAmount ( - nFee ) ) ) ; stop = true ; } if ( fLong ) WalletTxToJSON ( wtx , entry ) ; ret . push_back ( entry ) ; } if ( stop ) break ; } } } void AcentryToJSON ( const CAccountingEntry & acentry , const string & strAccount , Array & ret ) { bool fAllAccounts = ( strAccount == string ( " * " ) ) ; if ( fAllAccounts || acentry . strAccount == strAccount ) { Object entry ; entry . push_back ( Pair ( " account " , acentry . strAccount ) ) ; entry . push_back ( Pair ( " category " , " move " ) ) ; entry . push_back ( Pair ( " time " , ( boost :: int64_t ) acentry . nTime ) ) ; entry . push_back ( Pair ( " amount " , ValueFromAmount ( acentry . nCreditDebit ) ) ) ; entry . push_back ( Pair ( " otheraccount " , acentry . strOtherAccount ) ) ; entry . push_back ( Pair ( " comment " , acentry . strComment ) ) ; ret . push_back ( entry ) ; } } Value listtransactions ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 3 ) throw runtime_error ( " listtransactions ▁ [ account ] ▁ [ count = 10 ] ▁ [ from = 0 ] \n " " Returns ▁ up ▁ to ▁ [ count ] ▁ most ▁ recent ▁ transactions ▁ skipping ▁ the ▁ first ▁ [ from ] ▁ transactions ▁ for ▁ account ▁ [ account ] . " ) ; string strAccount = " * " ; if ( params . size ( ) > 0 ) strAccount = params [ 0 ] . get_str ( ) ; int nCount = 10 ; if ( params . size ( ) > 1 ) nCount = params [ 1 ] . get_int ( ) ; int nFrom = 0 ; if ( params . size ( ) > 2 ) nFrom = params [ 2 ] . get_int ( ) ; if ( nCount < 0 ) throw JSONRPCError ( RPC_INVALID_PARAMETER , " Negative ▁ count " ) ; if ( nFrom < 0 ) throw JSONRPCError ( RPC_INVALID_PARAMETER , " Negative ▁ from " ) ; Array ret ; std :: list < CAccountingEntry > acentries ; CWallet :: TxItems txOrdered = pwalletMain -> OrderedTxItems ( acentries , strAccount ) ; for ( CWallet :: TxItems :: reverse_iterator it = txOrdered . rbegin ( ) ; it != txOrdered . rend ( ) ; ++ it ) { CWalletTx * const pwtx = ( * it ) . second . first ; if ( pwtx != 0 ) ListTransactions ( * pwtx , strAccount , 0 , true , ret ) ; CAccountingEntry * const pacentry = ( * it ) . second . second ; if ( pacentry != 0 ) AcentryToJSON ( * pacentry , strAccount , ret ) ; if ( ( int ) ret . size ( ) >= ( nCount + nFrom ) ) break ; } if ( nFrom > ( int ) ret . size ( ) ) nFrom = ret . size ( ) ; if ( ( nFrom + nCount ) > ( int ) ret . size ( ) ) nCount = ret . size ( ) - nFrom ; Array :: iterator first = ret . begin ( ) ; std :: advance ( first , nFrom ) ; Array :: iterator last = ret . begin ( ) ; std :: advance ( last , nFrom + nCount ) ; if ( last != ret . end ( ) ) ret . erase ( last , ret . end ( ) ) ; if ( first != ret . begin ( ) ) ret . erase ( ret . begin ( ) , first ) ; std :: reverse ( ret . begin ( ) , ret . end ( ) ) ; return ret ; } Value listaccounts ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 1 ) throw runtime_error ( " listaccounts ▁ [ minconf = 1 ] \n " " Returns ▁ Object ▁ that ▁ has ▁ account ▁ names ▁ as ▁ keys , ▁ account ▁ balances ▁ as ▁ values . " ) ; int nMinDepth = 1 ; if ( params . size ( ) > 0 ) nMinDepth = params [ 0 ] . get_int ( ) ; map < string , int64 > mapAccountBalances ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , string ) & entry , pwalletMain -> mapAddressBook ) { if ( IsMine ( * pwalletMain , entry . first ) ) mapAccountBalances [ entry . second ] = 0 ; } for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; int64 nFee ; string strSentAccount ; list < pair < CTxDestination , int64 > > listReceived ; list < pair < CTxDestination , int64 > > listSent ; wtx . GetAmounts ( listReceived , listSent , nFee , strSentAccount ) ; mapAccountBalances [ strSentAccount ] -= nFee ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & s , listSent ) mapAccountBalances [ strSentAccount ] -= s . second ; if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listReceived ) if ( pwalletMain -> mapAddressBook . count ( r . first ) ) mapAccountBalances [ pwalletMain -> mapAddressBook [ r . first ] ] += r . second ; else mapAccountBalances [ " " ] += r . second ; } } list < CAccountingEntry > acentries ; CWalletDB ( pwalletMain -> strWalletFile ) . ListAccountCreditDebit ( " * " , acentries ) ; BOOST_FOREACH ( const CAccountingEntry & entry , acentries ) mapAccountBalances [ entry . strAccount ] += entry . nCreditDebit ; Object ret ; BOOST_FOREACH ( const PAIRTYPE ( string , int64 ) & accountBalance , mapAccountBalances ) { ret . push_back ( Pair ( accountBalance . first , ValueFromAmount ( accountBalance . second ) ) ) ; } return ret ; } Value listsinceblock ( const Array & params , bool fHelp ) { if ( fHelp ) throw runtime_error ( " listsinceblock ▁ [ blockhash ] ▁ [ target - confirmations ] \n " " Get ▁ all ▁ transactions ▁ in ▁ blocks ▁ since ▁ block ▁ [ blockhash ] , ▁ or ▁ all ▁ transactions ▁ if ▁ omitted " ) ; CBlockIndex * pindex = NULL ; int target_confirms = 1 ; if ( params . size ( ) > 0 ) { uint256 blockId = 0 ; blockId . SetHex ( params [ 0 ] . get_str ( ) ) ; pindex = CBlockLocator ( blockId ) . GetBlockIndex ( ) ; } if ( params . size ( ) > 1 ) { target_confirms = params [ 1 ] . get_int ( ) ; if ( target_confirms < 1 ) throw JSONRPCError ( RPC_INVALID_PARAMETER , " Invalid ▁ parameter " ) ; } int depth = pindex ? ( 1 + nBestHeight - pindex -> nHeight ) : - 1 ; Array transactions ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; it ++ ) { CWalletTx tx = ( * it ) . second ; if ( depth == - 1 || tx . GetDepthInMainChain ( ) < depth ) ListTransactions ( tx , " * " , 0 , true , transactions ) ; } uint256 lastblock ; if ( target_confirms == 1 ) { lastblock = hashBestChain ; } else { int target_height = pindexBest -> nHeight + 1 - target_confirms ; CBlockIndex * block ; for ( block = pindexBest ; block && block -> nHeight > target_height ; block = block -> pprev ) { } lastblock = block ? block -> GetBlockHash ( ) : 0 ; } Object ret ; ret . push_back ( Pair ( " transactions " , transactions ) ) ; ret . push_back ( Pair ( " lastblock " , lastblock . GetHex ( ) ) ) ; return ret ; } Value gettransaction ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " gettransaction ▁ < txid > \n " " Get ▁ detailed ▁ information ▁ about ▁ in - wallet ▁ transaction ▁ < txid > " ) ; uint256 hash ; hash . SetHex ( params [ 0 ] . get_str ( ) ) ; Object entry ; if ( ! pwalletMain -> mapWallet . count ( hash ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ or ▁ non - wallet ▁ transaction ▁ id " ) ; const CWalletTx & wtx = pwalletMain -> mapWallet [ hash ] ; int64 nCredit = wtx . GetCredit ( ) ; int64 nDebit = wtx . GetDebit ( ) ; int64 nNet = nCredit - nDebit ; int64 nFee = ( wtx . IsFromMe ( ) ? wtx . GetValueOut ( ) - nDebit : 0 ) ; entry . push_back ( Pair ( " amount " , ValueFromAmount ( nNet - nFee ) ) ) ; if ( wtx . IsFromMe ( ) ) entry . push_back ( Pair ( " fee " , ValueFromAmount ( nFee ) ) ) ; WalletTxToJSON ( wtx , entry ) ; Array details ; ListTransactions ( wtx , " * " , 0 , false , details ) ; entry . push_back ( Pair ( " details " , details ) ) ; return entry ; } Value backupwallet ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " backupwallet ▁ < destination > \n " " Safely ▁ copies ▁ wallet . dat ▁ to ▁ destination , ▁ which ▁ can ▁ be ▁ a ▁ directory ▁ or ▁ a ▁ path ▁ with ▁ filename . " ) ; string strDest = params [ 0 ] . get_str ( ) ; if ( ! BackupWallet ( * pwalletMain , strDest ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Error : ▁ Wallet ▁ backup ▁ failed ! " ) ; return Value :: null ; } Value keypoolrefill ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 0 ) throw runtime_error ( " keypoolrefill \n " " Fills ▁ the ▁ keypool . " + HelpRequiringPassphrase ( ) ) ; EnsureWalletIsUnlocked ( ) ; pwalletMain -> TopUpKeyPool ( ) ; if ( pwalletMain -> GetKeyPoolSize ( ) < GetArg ( " - keypool " , 100 ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Error ▁ refreshing ▁ keypool . " ) ; return Value :: null ; } void ThreadTopUpKeyPool ( void * parg ) { RenameThread ( " iloveyoucoins - key - top " ) ; pwalletMain -> TopUpKeyPool ( ) ; } void ThreadCleanWalletPassphrase ( void * parg ) { RenameThread ( " iloveyoucoins - lock - wa " ) ; int64 nMyWakeTime = GetTimeMillis ( ) + * ( ( int64 * ) parg ) * 1000 ; ENTER_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; if ( nWalletUnlockTime == 0 ) { nWalletUnlockTime = nMyWakeTime ; do { if ( nWalletUnlockTime == 0 ) break ; int64 nToSleep = nWalletUnlockTime - GetTimeMillis ( ) ; if ( nToSleep <= 0 ) break ; LEAVE_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; MilliSleep ( nToSleep ) ; ENTER_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; } while ( 1 ) ; if ( nWalletUnlockTime ) { nWalletUnlockTime = 0 ; pwalletMain -> Lock ( ) ; } } else { if ( nWalletUnlockTime < nMyWakeTime ) nWalletUnlockTime = nMyWakeTime ; } LEAVE_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; delete ( int64 * ) parg ; } Value walletpassphrase ( const Array & params , bool fHelp ) { if ( pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) < 2 || params . size ( ) > 3 ) ) throw runtime_error ( " walletpassphrase ▁ < passphrase > ▁ < timeout > ▁ [ stakingonly ] \n " " Stores ▁ the ▁ wallet ▁ decryption ▁ key ▁ in ▁ memory ▁ for ▁ < timeout > ▁ seconds . \n " " if ▁ [ stakingonly ] ▁ is ▁ true ▁ sending ▁ functions ▁ are ▁ disabled . " ) ; if ( fHelp ) return true ; if ( ! pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ unencrypted ▁ wallet , ▁ but ▁ walletpassphrase ▁ was ▁ called . " ) ; if ( ! pwalletMain -> IsLocked ( ) ) throw JSONRPCError ( RPC_WALLET_ALREADY_UNLOCKED , " Error : ▁ Wallet ▁ is ▁ already ▁ unlocked . " ) ; SecureString strWalletPass ; strWalletPass . reserve ( 100 ) ; strWalletPass = params [ 0 ] . get_str ( ) . c_str ( ) ; if ( strWalletPass . length ( ) > 0 ) { if ( ! pwalletMain -> Unlock ( strWalletPass ) ) throw JSONRPCError ( RPC_WALLET_PASSPHRASE_INCORRECT , " Error : ▁ The ▁ wallet ▁ passphrase ▁ entered ▁ was ▁ incorrect . " ) ; } else throw runtime_error ( " walletpassphrase ▁ < passphrase > ▁ < timeout > \n " " Stores ▁ the ▁ wallet ▁ decryption ▁ key ▁ in ▁ memory ▁ for ▁ < timeout > ▁ seconds . " ) ; NewThread ( ThreadTopUpKeyPool , NULL ) ; int64 * pnSleepTime = new int64 ( params [ 1 ] . get_int64 ( ) ) ; NewThread ( ThreadCleanWalletPassphrase , pnSleepTime ) ; if ( params . size ( ) > 2 ) fWalletUnlockStakingOnly = params [ 2 ] . get_bool ( ) ; else fWalletUnlockStakingOnly = false ; return Value :: null ; } Value walletpassphrasechange ( const Array & params , bool fHelp ) { if ( pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) != 2 ) ) throw runtime_error ( " walletpassphrasechange ▁ < oldpassphrase > ▁ < newpassphrase > \n " " Changes ▁ the ▁ wallet ▁ passphrase ▁ from ▁ < oldpassphrase > ▁ to ▁ < newpassphrase > . " ) ; if ( fHelp ) return true ; if ( ! pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ unencrypted ▁ wallet , ▁ but ▁ walletpassphrasechange ▁ was ▁ called . " ) ; SecureString strOldWalletPass ; strOldWalletPass . reserve ( 100 ) ; strOldWalletPass = params [ 0 ] . get_str ( ) . c_str ( ) ; SecureString strNewWalletPass ; strNewWalletPass . reserve ( 100 ) ; strNewWalletPass = params [ 1 ] . get_str ( ) . c_str ( ) ; if ( strOldWalletPass . length ( ) < 1 || strNewWalletPass . length ( ) < 1 ) throw runtime_error ( " walletpassphrasechange ▁ < oldpassphrase > ▁ < newpassphrase > \n " " Changes ▁ the ▁ wallet ▁ passphrase ▁ from ▁ < oldpassphrase > ▁ to ▁ < newpassphrase > . " ) ; if ( ! pwalletMain -> ChangeWalletPassphrase ( strOldWalletPass , strNewWalletPass ) ) throw JSONRPCError ( RPC_WALLET_PASSPHRASE_INCORRECT , " Error : ▁ The ▁ wallet ▁ passphrase ▁ entered ▁ was ▁ incorrect . " ) ; return Value :: null ; } Value walletlock ( const Array & params , bool fHelp ) { if ( pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) != 0 ) ) throw runtime_error ( " walletlock \n " " Removes ▁ the ▁ wallet ▁ encryption ▁ key ▁ from ▁ memory , ▁ locking ▁ the ▁ wallet . \n " " After ▁ calling ▁ this ▁ method , ▁ you ▁ will ▁ need ▁ to ▁ call ▁ walletpassphrase ▁ again \n " " before ▁ being ▁ able ▁ to ▁ call ▁ any ▁ methods ▁ which ▁ require ▁ the ▁ wallet ▁ to ▁ be ▁ unlocked . " ) ; if ( fHelp ) return true ; if ( ! pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ unencrypted ▁ wallet , ▁ but ▁ walletlock ▁ was ▁ called . " ) ; { LOCK ( cs_nWalletUnlockTime ) ; pwalletMain -> Lock ( ) ; nWalletUnlockTime = 0 ; } return Value :: null ; } Value encryptwallet ( const Array & params , bool fHelp ) { if ( ! pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) != 1 ) ) throw runtime_error ( " encryptwallet ▁ < passphrase > \n " " Encrypts ▁ the ▁ wallet ▁ with ▁ < passphrase > . " ) ; if ( fHelp ) return true ; if ( pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ encrypted ▁ wallet , ▁ but ▁ encryptwallet ▁ was ▁ called . " ) ; SecureString strWalletPass ; strWalletPass . reserve ( 100 ) ; strWalletPass = params [ 0 ] . get_str ( ) . c_str ( ) ; if ( strWalletPass . length ( ) < 1 ) throw runtime_error ( " encryptwallet ▁ < passphrase > \n " " Encrypts ▁ the ▁ wallet ▁ with ▁ < passphrase > . " ) ; if ( ! pwalletMain -> EncryptWallet ( strWalletPass ) ) throw JSONRPCError ( RPC_WALLET_ENCRYPTION_FAILED , " Error : ▁ Failed ▁ to ▁ encrypt ▁ the ▁ wallet . " ) ; StartShutdown ( ) ; return " wallet ▁ encrypted ; ▁ ILoveYouCoins ▁ server ▁ stopping , ▁ restart ▁ to ▁ run ▁ with ▁ encrypted ▁ wallet . ▁ The ▁ keypool ▁ has ▁ been ▁ flushed , ▁ you ▁ need ▁ to ▁ make ▁ a ▁ new ▁ backup . " ; } class DescribeAddressVisitor : public boost :: static_visitor < Object > { public : Object operator ( ) ( const CNoDestination & dest ) const { return Object ( ) ; } Object operator ( ) ( const CKeyID & keyID ) const { Object obj ; CPubKey vchPubKey ; pwalletMain -> GetPubKey ( keyID , vchPubKey ) ; obj . push_back ( Pair ( " isscript " , false ) ) ; obj . push_back ( Pair ( " pubkey " , HexStr ( vchPubKey ) ) ) ; obj . push_back ( Pair ( " iscompressed " , vchPubKey . IsCompressed ( ) ) ) ; return obj ; } Object operator ( ) ( const CScriptID & scriptID ) const { Object obj ; obj . push_back ( Pair ( " isscript " , true ) ) ; CScript subscript ; pwalletMain -> GetCScript ( scriptID , subscript ) ; std :: vector < CTxDestination > addresses ; txnouttype whichType ; int nRequired ; ExtractDestinations ( subscript , whichType , addresses , nRequired ) ; obj . push_back ( Pair ( " script " , GetTxnOutputType ( whichType ) ) ) ; Array a ; BOOST_FOREACH ( const CTxDestination & addr , addresses ) a . push_back ( CBitcoinAddress ( addr ) . ToString ( ) ) ; obj . push_back ( Pair ( " addresses " , a ) ) ; if ( whichType == TX_MULTISIG ) obj . push_back ( Pair ( " sigsrequired " , nRequired ) ) ; return obj ; } } ; Value validateaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " validateaddress ▁ < iloveyoucoinsaddress > \n " " Return ▁ information ▁ about ▁ < iloveyoucoinsaddress > . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; bool isValid = address . IsValid ( ) ; Object ret ; ret . push_back ( Pair ( " isvalid " , isValid ) ) ; if ( isValid ) { CTxDestination dest = address . Get ( ) ; string currentAddress = address . ToString ( ) ; ret . push_back ( Pair ( " address " , currentAddress ) ) ; bool fMine = pwalletMain ? IsMine ( * pwalletMain , dest ) : false ; ret . push_back ( Pair ( " ismine " , fMine ) ) ; if ( fMine ) { Object detail = boost :: apply_visitor ( DescribeAddressVisitor ( ) , dest ) ; ret . insert ( ret . end ( ) , detail . begin ( ) , detail . end ( ) ) ; } if ( pwalletMain && pwalletMain -> mapAddressBook . count ( dest ) ) ret . push_back ( Pair ( " account " , pwalletMain -> mapAddressBook [ dest ] ) ) ; } return ret ; } Value reservebalance ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " reservebalance ▁ [ < reserve > ▁ [ amount ] ] \n " " < reserve > ▁ is ▁ true ▁ or ▁ false ▁ to ▁ turn ▁ balance ▁ reserve ▁ on ▁ or ▁ off . \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ rounded ▁ to ▁ cent . \n " " Set ▁ reserve ▁ amount ▁ not ▁ participating ▁ in ▁ network ▁ protection . \n " " If ▁ no ▁ parameters ▁ provided ▁ current ▁ setting ▁ is ▁ printed . \n " ) ; if ( params . size ( ) > 0 ) { bool fReserve = params [ 0 ] . get_bool ( ) ; if ( fReserve ) { if ( params . size ( ) == 1 ) throw runtime_error ( " must ▁ provide ▁ amount ▁ to ▁ reserve ▁ balance . \n " ) ; int64 nAmount = AmountFromValue ( params [ 1 ] ) ; nAmount = ( nAmount / CENT ) * CENT ; if ( nAmount < 0 ) throw runtime_error ( " amount ▁ cannot ▁ be ▁ negative . \n " ) ; nReserveBalance = nAmount ; } else { if ( params . size ( ) > 1 ) throw runtime_error ( " cannot ▁ specify ▁ amount ▁ to ▁ turn ▁ off ▁ reserve . \n " ) ; nReserveBalance = 0 ; } } Object result ; result . push_back ( Pair ( " reserve " , ( nReserveBalance > 0 ) ) ) ; result . push_back ( Pair ( " amount " , ValueFromAmount ( nReserveBalance ) ) ) ; return result ; } Value getinterest ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " getinterest ▁ [ start ] ▁ [ end ] \n " " Both ▁ [ start ] ▁ and ▁ [ end ] ▁ are ▁ inclusive ▁ and ▁ in ▁ the ▁ form ▁ of ▁ UNIX ▁ timestamps . " ) ; unsigned int nTimeStart = 0 ; unsigned int nTimeEnd = - 1 ; if ( params . size ( ) >= 1 ) nTimeStart = ( unsigned int ) ( params [ 0 ] . get_int ( ) ) ; if ( params . size ( ) == 2 ) nTimeEnd = ( unsigned int ) ( params [ 1 ] . get_int ( ) ) ; int64 nInterest = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . IsCoinStake ( ) || wtx . nTime < nTimeStart || wtx . nTime > nTimeEnd ) continue ; int64 nDebit = wtx . GetDebit ( ) ; int64 nCredit = wtx . GetCredit ( ) ; if ( nDebit <= 0 || nCredit <= 0 || nDebit >= nCredit ) continue ; else nInterest += nCredit - nDebit ; } return ValueFromAmount ( nInterest ) ; } Value lockunspent ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " lockunspent ▁ unlock ? ▁ [ array - of - Objects ] \n " " Updates ▁ list ▁ of ▁ temporarily ▁ unspendable ▁ outputs . " ) ; if ( params . size ( ) == 1 ) RPCTypeCheck ( params , list_of ( bool_type ) ) ; else RPCTypeCheck ( params , list_of ( bool_type ) ( array_type ) ) ; bool fUnlock = params [ 0 ] . get_bool ( ) ; if ( params . size ( ) == 1 ) { if ( fUnlock ) pwalletMain -> UnlockAllCoins ( ) ; return true ; } Array outputs = params [ 1 ] . get_array ( ) ; BOOST_FOREACH ( Value & output , outputs ) { if ( output . type ( ) != obj_type ) throw JSONRPCError ( - 8 , " Invalid ▁ parameter , ▁ expected ▁ object " ) ; const Object & o = output . get_obj ( ) ; RPCTypeCheck ( o , map_list_of ( " txid " , str_type ) ( " vout " , int_type ) ) ; string txid = find_value ( o , " txid " ) . get_str ( ) ; if ( ! IsHex ( txid ) ) throw JSONRPCError ( - 8 , " Invalid ▁ parameter , ▁ expected ▁ hex ▁ txid " ) ; int nOutput = find_value ( o , " vout " ) . get_int ( ) ; if ( nOutput < 0 ) throw JSONRPCError ( - 8 , " Invalid ▁ parameter , ▁ vout ▁ must ▁ be ▁ positive " ) ; COutPoint outpt ( uint256 ( txid ) , nOutput ) ; if ( fUnlock ) pwalletMain -> UnlockCoin ( outpt ) ; else pwalletMain -> LockCoin ( outpt ) ; } return true ; } Value listlockunspent ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 0 ) throw runtime_error ( " listlockunspent \n " " Returns ▁ list ▁ of ▁ temporarily ▁ unspendable ▁ outputs . " ) ; vector < COutPoint > vOutpts ; pwalletMain -> ListLockedCoins ( vOutpts ) ; Array ret ; BOOST_FOREACH ( COutPoint & outpt , vOutpts ) { Object o ; o . push_back ( Pair ( " txid " , outpt . hash . GetHex ( ) ) ) ; o . push_back ( Pair ( " vout " , ( int ) outpt . n ) ) ; ret . push_back ( o ) ; } return ret ; } </DOCUMENT>
<DOCUMENT_ID="SingularityCore/Singularity/tree/master/dep/acelite/ace/Log_Msg_IPC.cpp"> # include " ace / Log _ Msg _ IPC . h " # include " ace / Log _ Record . h " # include " ace / CDR _ Stream . h " # include " ace / Truncate . h " ACE_BEGIN_VERSIONED_NAMESPACE_DECL ACE_Log_Msg_IPC :: ACE_Log_Msg_IPC ( void ) { } ACE_Log_Msg_IPC :: ~ ACE_Log_Msg_IPC ( void ) { ( void ) this -> close ( ) ; } int ACE_Log_Msg_IPC :: open ( const ACE_TCHAR * logger_key ) { ACE_LOG_MSG_IPC_CONNECTOR con ; return con . connect ( this -> message_queue_ , ACE_LOG_MSG_IPC_ADDR ( logger_key ) ) ; } int ACE_Log_Msg_IPC :: reset ( void ) { if ( this -> message_queue_ . get_handle ( ) != ACE_INVALID_HANDLE ) { return this -> close ( ) ; } return 0 ; } int ACE_Log_Msg_IPC :: close ( void ) { return this -> message_queue_ . close ( ) ; } ssize_t ACE_Log_Msg_IPC :: log ( ACE_Log_Record & log_record ) { size_t const max_payload_size = 4 + 4 + 12 + 4 + 4 # if defined ( ACE_USES_WCHAR ) + ( log_record . msg_data_len ( ) * ACE_OutputCDR :: wchar_maxbytes ( ) ) # else + log_record . msg_data_len ( ) # endif + ACE_CDR :: MAX_ALIGNMENT ; ACE_OutputCDR payload ( max_payload_size ) ; if ( ! ( payload << log_record ) ) return - 1 ; ACE_CDR :: ULong const length = ACE_Utils :: truncate_cast < ACE_CDR :: ULong > ( payload . total_length ( ) ) ; ACE_OutputCDR header ( ACE_CDR :: MAX_ALIGNMENT + 8 ) ; if ( ! ( header << ACE_OutputCDR :: from_boolean ( ACE_CDR_BYTE_ORDER ) ) ) return - 1 ; if ( ! ( header << ACE_CDR :: ULong ( length ) ) ) return - 1 ; iovec iov [ 2 ] ; iov [ 0 ] . iov_base = header . begin ( ) -> rd_ptr ( ) ; iov [ 0 ] . iov_len = 8 ; iov [ 1 ] . iov_base = payload . begin ( ) -> rd_ptr ( ) ; iov [ 1 ] . iov_len = length ; # if ( ACE_HAS_STREAM_LOG_MSG_IPC == 1 ) ACE_Str_Buf header_msg ( static_cast < void * > ( header . begin ( ) -> rd_ptr ( ) ) , static_cast < int > ( 8 ) ) ; ACE_Str_Buf payload_msg ( static_cast < void * > ( payload . begin ( ) -> rd_ptr ( ) ) , static_cast < int > ( length ) ) ; return this -> message_queue_ . send ( & header_msg , & payload_msg , static_cast < int > ( log_record . priority ( ) ) , MSG_BAND ) ; # else return this -> message_queue_ . sendv_n ( iov , 2 ) ; # endif } ACE_END_VERSIONED_NAMESPACE_DECL </DOCUMENT>
