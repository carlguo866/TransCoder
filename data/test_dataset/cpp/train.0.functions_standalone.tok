int main ( int argc , char * * argv ) { if ( game . start ( ) != 0 ) return - 1 ; int retcode = game . getServer ( ) -> start ( ) ; if ( retcode == 0 ) { TerminateProcess ( GetCurrentProcess ( ) , EXIT_SUCCESS ) ; return 0 ; } else return retcode ; }
int main ( int argc , char * argv [ ] ) { QApplication a ( argc , argv ) ; MainWindow w ; w . show ( ) ; return a . exec ( ) ; }
int main ( ) { constexpr Person john { 30 } ; BOOST_HANA_CONSTANT_CHECK ( f ( john ) == hana :: nothing ) ; BOOST_HANA_CONSTANT_CHECK ( f ( 1 ) == hana :: nothing ) ; BOOST_HANA_CONSTEXPR_CHECK ( f ( & john ) == hana :: just ( 30u ) ) ; }
void build ( const arrow :: RecordBatch & record_batch ) { rb :: protect ( [ & ] { const auto n_rows = record_batch . num_rows ( ) ; for ( int64_t i = 0 ; i < n_rows ; ++ i ) { auto record = rb_ary_new_capa ( n_columns_ ) ; rb_ary_push ( records_ , record ) ; } row_offset_ = 0 ; for ( int i = 0 ; i < n_columns_ ; ++ i ) { const auto array = record_batch . column ( i ) . get ( ) ; column_index_ = i ; check_status ( array -> Accept ( this ) , " [ record - batch ] [ raw - records ] " ) ; } return Qnil ; } ) ; }
void build ( const arrow :: Table & table ) { rb :: protect ( [ & ] { const auto n_rows = table . num_rows ( ) ; for ( int64_t i = 0 ; i < n_rows ; ++ i ) { auto record = rb_ary_new_capa ( n_columns_ ) ; rb_ary_push ( records_ , record ) ; } for ( int i = 0 ; i < n_columns_ ; ++ i ) { const auto & chunked_array = table . column ( i ) . get ( ) ; column_index_ = i ; row_offset_ = 0 ; for ( const auto array : chunked_array -> chunks ( ) ) { check_status ( array -> Accept ( this ) , " [ table ] [ raw - records ] " ) ; row_offset_ += array -> length ( ) ; } } return Qnil ; } ) ; }
void AddSC_arathi_highlands ( ) { new npc_professor_phizzlethorpe ( ) ; }
double time_match ( const std :: string & re , const std :: string & text , bool icase ) { regex :: rpattern e ( re , ( icase ? regex :: MULTILINE | regex :: NORMALIZE | regex :: NOCASE : regex :: MULTILINE | regex :: NORMALIZE ) ) ; regex :: match_results what ; boost :: timer tim ; int iter = 1 ; int counter , repeats ; double result = 0 ; double run ; assert ( e . match ( text , what ) ) ; do { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text , what ) ; } result = tim . elapsed ( ) ; iter *= 2 ; } while ( result < 0.5 ) ; iter /= 2 ; for ( repeats = 0 ; repeats < REPEAT_COUNT ; ++ repeats ) { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text , what ) ; } run = tim . elapsed ( ) ; result = ( std :: min ) ( run , result ) ; } return result / iter ; }
double time_find_all ( const std :: string & re , const std :: string & text , bool icase ) { regex :: rpattern e ( re , ( icase ? regex :: MULTILINE | regex :: NORMALIZE | regex :: NOCASE : regex :: MULTILINE | regex :: NORMALIZE ) ) ; regex :: match_results what ; boost :: timer tim ; int iter = 1 ; int counter , repeats ; double result = 0 ; double run ; do { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text . begin ( ) , text . end ( ) , what ) ; while ( what . backref ( 0 ) . matched ) { e . match ( what . backref ( 0 ) . end ( ) , text . end ( ) , what ) ; } } result = tim . elapsed ( ) ; iter *= 2 ; } while ( result < 0.5 ) ; iter /= 2 ; if ( result > 10 ) return result / iter ; for ( repeats = 0 ; repeats < REPEAT_COUNT ; ++ repeats ) { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text . begin ( ) , text . end ( ) , what ) ; while ( what . backref ( 0 ) . matched ) { e . match ( what . backref ( 0 ) . end ( ) , text . end ( ) , what ) ; } } run = tim . elapsed ( ) ; result = ( std :: min ) ( run , result ) ; } return result / iter ; }
double time_match ( const std :: string & re , const std :: string & text , bool icase ) { return - 1 ; }
double time_find_all ( const std :: string & re , const std :: string & text , bool icase ) { return - 1 ; }
int main ( ) { QMap < int , int > m ; m [ 10 ] = 100 ; m [ 20 ] = 200 ; m [ 30 ] = 300 ; return 0 ; }
void compile_and_link_test ( ) { check_result < float > ( boost :: math :: hypot < float > ( f , f ) ) ; check_result < double > ( boost :: math :: hypot < double > ( d , d ) ) ; check_result < long double > ( boost :: math :: hypot < long double > ( l , l ) ) ; }
void func ( ) { auto x = " TABSYMBOL test\t ▁ TABSYMBOL ▁ TABSYMBOL ▁ TABSYMBOL TABSYMBOL . . . ▁ ▁ ▁ ? ? ? " ; }
void func ( ) { auto x = " TABSYMBOL test\t ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . . . ▁ ▁ ▁ ? ? ? " ; }
template < class S > void test ( S s , const typename S :: value_type * str , S expected ) { s . append ( str ) ; assert ( s . __invariants ( ) ) ; assert ( s == expected ) ; }
int main ( ) { typedef std :: string S ; test ( S ( ) , " " , S ( ) ) ; test ( S ( ) , "12345" , S ( "12345" ) ) ; test ( S ( ) , "12345678901234567890" , S ( "12345678901234567890" ) ) ; test ( S ( "12345" ) , " " , S ( "12345" ) ) ; test ( S ( "12345" ) , "12345" , S ( "1234512345" ) ) ; test ( S ( "12345" ) , "1234567890" , S ( "123451234567890" ) ) ; test ( S ( "12345678901234567890" ) , " " , S ( "12345678901234567890" ) ) ; test ( S ( "12345678901234567890" ) , "12345" , S ( "1234567890123456789012345" ) ) ; test ( S ( "12345678901234567890" ) , "12345678901234567890" , S ( "1234567890123456789012345678901234567890" ) ) ; }
void gbump ( int n ) { base :: gbump ( n ) ; }
virtual int_type pbackfail ( int_type c = traits_type :: eof ( ) ) { return base :: pbackfail ( c ) ; }
int main ( ) { { std :: ifstream bs ( " underflow . dat " ) ; test_buf f ( bs . rdbuf ( ) ) ; assert ( f . sbumpc ( ) == L ' 1' ) ; assert ( f . sgetc ( ) == L ' 2' ) ; assert ( f . pbackfail ( L ' a ' ) == test_buf :: traits_type :: eof ( ) ) ; } { std :: fstream bs ( " underflow . dat " ) ; test_buf f ( bs . rdbuf ( ) ) ; assert ( f . sbumpc ( ) == L ' 1' ) ; assert ( f . sgetc ( ) == L ' 2' ) ; assert ( f . pbackfail ( L ' a ' ) == test_buf :: traits_type :: eof ( ) ) ; assert ( f . sbumpc ( ) == L ' 2' ) ; assert ( f . sgetc ( ) == L ' 3' ) ; } }
public : void test_backends ( ) { parameters [ " linear _ algebra _ backend " ] = " Eigen " ; _test_operators ( MPI_COMM_SELF ) ; parameters [ " linear _ algebra _ backend " ] = " PETSc " ; _test_operators ( MPI_COMM_WORLD ) ; }
void _test_operators ( MPI_Comm comm ) { Vector v ( comm , 10 ) , u ( comm , 10 ) ; v = 0.0 ; u = 0.0 ; CPPUNIT_ASSERT ( v . sum ( ) == 0.0 ) ; v = 1.0 ; CPPUNIT_ASSERT ( v . sum ( ) == v . size ( ) ) ; u = v ; CPPUNIT_ASSERT ( u . sum ( ) == u . size ( ) ) ; u += v ; CPPUNIT_ASSERT ( u . sum ( ) == 2 * u . size ( ) ) ; u -= v ; u -= v ; CPPUNIT_ASSERT ( u . sum ( ) == 0.0 ) ; v *= 5.0 ; CPPUNIT_ASSERT ( v . sum ( ) == v . size ( ) * 5.0 ) ; v /= 2.0 ; CPPUNIT_ASSERT ( v . sum ( ) == 2.5 * v . size ( ) ) ; u = 2.0 ; v *= u ; CPPUNIT_ASSERT ( v . sum ( ) == v . size ( ) * 5.0 ) ; }
void test_init ( ) { const std :: vector < std :: size_t > dims ( 1 , 203 ) ; TensorLayout layout_local ( 0 , false ) ; std :: vector < std :: pair < std :: size_t , std :: size_t > > local_range ( 1 , std :: make_pair ( 0 , 203 ) ) ; layout_local . init ( MPI_COMM_SELF , dims , 1 , local_range ) ; TensorLayout layout_distributed ( 0 , false ) ; std :: vector < std :: pair < std :: size_t , std :: size_t > > ownership_range ( 1 , dolfin :: MPI :: local_range ( MPI_COMM_WORLD , 203 ) ) ; layout_distributed . init ( MPI_COMM_WORLD , dims , 1 , ownership_range ) ; parameters [ " linear _ algebra _ backend " ] = " PETSc " ; { Vector x ; x . init ( layout_local ) ; CPPUNIT_ASSERT ( x . size ( ) == 203 ) ; Vector y ; y . init ( layout_distributed ) ; CPPUNIT_ASSERT ( y . size ( ) == 203 ) ; } { EigenVector x ; x . init ( layout_local ) ; CPPUNIT_ASSERT ( x . size ( ) == 203 ) ; } { PETScVector x ; x . init ( layout_local ) ; CPPUNIT_ASSERT ( x . size ( ) == 203 ) ; PETScVector y ; y . init ( layout_distributed ) ; CPPUNIT_ASSERT ( y . size ( ) == 203 ) ; } }
void test_get_local_empty ( ) { const std :: vector < std :: size_t > dims ( 1 , 203 ) ; TensorLayout layout_local ( 0 , false ) ; std :: vector < std :: pair < std :: size_t , std :: size_t > > local_range ( 1 , std :: make_pair ( 0 , 203 ) ) ; layout_local . init ( MPI_COMM_SELF , dims , 1 , local_range ) ; TensorLayout layout_distributed ( 0 , false ) ; std :: vector < std :: pair < std :: size_t , std :: size_t > > ownership_range ( 1 , dolfin :: MPI :: local_range ( MPI_COMM_WORLD , 203 ) ) ; layout_distributed . init ( MPI_COMM_WORLD , dims , 1 , ownership_range ) ; parameters [ " linear _ algebra _ backend " ] = " PETSc " ; { Vector x ; x . init ( layout_local ) ; CPPUNIT_ASSERT ( x . size ( ) == 203 ) ; Vector y ; y . init ( layout_distributed ) ; CPPUNIT_ASSERT ( y . size ( ) == 203 ) ; double * block = NULL ; dolfin :: la_index * rows = NULL ; x . get_local ( block , 0 , rows ) ; y . get_local ( block , 0 , rows ) ; } }
int main ( ) { DOLFIN_TEST ; }
String base64Encode ( const char * data , unsigned length , Base64EncodePolicy policy ) { Vector < char > result ; base64Encode ( data , length , result , policy ) ; return String ( result . data ( ) , result . size ( ) ) ; }
void base64Encode ( const char * data , unsigned len , Vector < char > & out , Base64EncodePolicy policy ) { out . clear ( ) ; if ( ! len ) return ; const unsigned maxInputBufferSize = UINT_MAX / 77 * 76 / 4 * 3 - 2 ; if ( len > maxInputBufferSize ) return ; unsigned sidx = 0 ; unsigned didx = 0 ; unsigned outLength = ( ( len + 2 ) / 3 ) * 4 ; bool insertLFs = ( policy == Base64InsertLFs && outLength > 76 ) ; if ( insertLFs ) outLength += ( ( outLength - 1 ) / 76 ) ; int count = 0 ; out . grow ( outLength ) ; if ( len > 1 ) { while ( sidx < len - 2 ) { if ( insertLFs ) { if ( count && ! ( count % 76 ) ) out [ didx ++ ] = ' \n ' ; count += 4 ; } out [ didx ++ ] = base64EncMap [ ( data [ sidx ] >> 2 ) & 077 ] ; out [ didx ++ ] = base64EncMap [ ( ( data [ sidx + 1 ] >> 4 ) & 017 ) | ( ( data [ sidx ] << 4 ) & 077 ) ] ; out [ didx ++ ] = base64EncMap [ ( ( data [ sidx + 2 ] >> 6 ) & 003 ) | ( ( data [ sidx + 1 ] << 2 ) & 077 ) ] ; out [ didx ++ ] = base64EncMap [ data [ sidx + 2 ] & 077 ] ; sidx += 3 ; } } if ( sidx < len ) { if ( insertLFs && ( count > 0 ) && ! ( count % 76 ) ) out [ didx ++ ] = ' \n ' ; out [ didx ++ ] = base64EncMap [ ( data [ sidx ] >> 2 ) & 077 ] ; if ( sidx < len - 1 ) { out [ didx ++ ] = base64EncMap [ ( ( data [ sidx + 1 ] >> 4 ) & 017 ) | ( ( data [ sidx ] << 4 ) & 077 ) ] ; out [ didx ++ ] = base64EncMap [ ( data [ sidx + 1 ] << 2 ) & 077 ] ; } else out [ didx ++ ] = base64EncMap [ ( data [ sidx ] << 4 ) & 077 ] ; } while ( didx < out . size ( ) ) { out [ didx ] = ' = ' ; ++ didx ; } }
bool base64Decode ( const Vector < char > & in , Vector < char > & out , Base64DecodePolicy policy ) { out . clear ( ) ; if ( in . size ( ) > UINT_MAX ) return false ; return base64Decode ( in . data ( ) , in . size ( ) , out , policy ) ; }
template < typename T > static inline bool base64DecodeInternal ( const T * data , unsigned len , Vector < char > & out , Base64DecodePolicy policy ) { out . clear ( ) ; if ( ! len ) return true ; out . grow ( len ) ; bool sawEqualsSign = false ; unsigned outLength = 0 ; for ( unsigned idx = 0 ; idx < len ; ++ idx ) { unsigned ch = data [ idx ] ; if ( ch == ' = ' ) sawEqualsSign = true ; else if ( ( '0' <= ch && ch <= '9' ) || ( ' A ' <= ch && ch <= ' Z ' ) || ( ' a ' <= ch && ch <= ' z ' ) || ch == ' + ' || ch == ' / ' ) { if ( sawEqualsSign ) return false ; out [ outLength ] = base64DecMap [ ch ] ; ++ outLength ; } else if ( policy == Base64FailOnInvalidCharacter || ( policy == Base64IgnoreWhitespace && ! isSpaceOrNewline ( ch ) ) ) return false ; } if ( ! outLength ) return ! sawEqualsSign ; if ( ( outLength % 4 ) == 1 ) return false ; outLength -= ( outLength + 3 ) / 4 ; if ( ! outLength ) return false ; unsigned sidx = 0 ; unsigned didx = 0 ; if ( outLength > 1 ) { while ( didx < outLength - 2 ) { out [ didx ] = ( ( ( out [ sidx ] << 2 ) & 255 ) | ( ( out [ sidx + 1 ] >> 4 ) & 003 ) ) ; out [ didx + 1 ] = ( ( ( out [ sidx + 1 ] << 4 ) & 255 ) | ( ( out [ sidx + 2 ] >> 2 ) & 017 ) ) ; out [ didx + 2 ] = ( ( ( out [ sidx + 2 ] << 6 ) & 255 ) | ( out [ sidx + 3 ] & 077 ) ) ; sidx += 4 ; didx += 3 ; } } if ( didx < outLength ) out [ didx ] = ( ( ( out [ sidx ] << 2 ) & 255 ) | ( ( out [ sidx + 1 ] >> 4 ) & 003 ) ) ; if ( ++ didx < outLength ) out [ didx ] = ( ( ( out [ sidx + 1 ] << 4 ) & 255 ) | ( ( out [ sidx + 2 ] >> 2 ) & 017 ) ) ; if ( outLength < out . size ( ) ) out . shrink ( outLength ) ; return true ; }
bool base64Decode ( const char * data , unsigned len , Vector < char > & out , Base64DecodePolicy policy ) { return base64DecodeInternal < char > ( data , len , out , policy ) ; }
bool base64Decode ( const String & in , Vector < char > & out , Base64DecodePolicy policy ) { return base64DecodeInternal < UChar > ( in . characters ( ) , in . length ( ) , out , policy ) ; }
boss_ormorokAI ( Creature * creature ) : BossAI ( creature , DATA_ORMOROK ) { Initialize ( ) ; }
void Initialize ( ) { frenzy = false ; }
npc_crystal_spike_triggerAI ( Creature * creature ) : ScriptedAI ( creature ) { _count = 0 ; _despawntimer = 0 ; }
void HandlePeriodic ( AuraEffect const * ) { Unit * target = GetTarget ( ) ; if ( target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_INITIAL || target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_TRIGGER ) if ( Creature * trigger = target -> ToCreature ( ) ) { uint32 spell = target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_INITIAL ? crystalSpikeSummon [ 0 ] : crystalSpikeSummon [ urand ( 0 , 2 ) ] ; if ( trigger -> AI ( ) -> GetData ( DATA_COUNT ) < MAX_COUNT ) trigger -> CastSpell ( trigger , spell , true ) ; } }
void AddSC_boss_ormorok ( ) { new boss_ormorok ( ) ; new npc_crystal_spike_trigger ( ) ; new spell_crystal_spike ( ) ; }
void process ( SILInstruction * I ) { visit ( I ) ; }
SILBasicBlock * remapBasicBlock ( SILBasicBlock * BB ) { return BB ; }
SILValue getMappedValue ( SILValue Value ) { return SILCloner < InitSequenceCloner > :: getMappedValue ( Value ) ; }
void postProcess ( SILInstruction * orig , SILInstruction * cloned ) { DestIP -> getParent ( ) -> push_front ( cloned ) ; cloned -> moveBefore ( DestIP ) ; SILClonerWithScopes < InitSequenceCloner > :: postProcess ( orig , cloned ) ; }
SILValue clone ( ) { for ( auto I : Init . Instructions ) process ( I ) ; return getMappedValue ( Init . Result ) ; }
static bool isStructurallyIdentical ( SILValue LHS , SILValue RHS ) { if ( LHS == RHS ) return true ; if ( LHS -> getType ( ) != RHS -> getType ( ) ) return false ; auto lResult = LHS -> getDefiningInstructionResult ( ) ; auto rResult = RHS -> getDefiningInstructionResult ( ) ; assert ( lResult && rResult && " operands ▁ of ▁ instructions ▁ approved ▁ by ▁ analyzeStaticInitializer ▁ " " should ▁ always ▁ be ▁ defined ▁ by ▁ instructions " ) ; return ( lResult -> ResultIndex == rResult -> ResultIndex && lResult -> Instruction -> isIdenticalTo ( rResult -> Instruction , isStructurallyIdentical ) ) ; }
static bool isSameInitSequence ( const InitSequence & LHS , const InitSequence & RHS ) { assert ( LHS . isValid ( ) && RHS . isValid ( ) ) ; return isStructurallyIdentical ( LHS . Result , RHS . Result ) ; }
static bool isAssignableExternally ( VarDecl * Property , SILModule * Module ) { if ( Module -> isVisibleExternally ( Property ) ) { auto * Ty = dyn_cast < NominalTypeDecl > ( Property -> getDeclContext ( ) ) ; if ( isa < ClassDecl > ( Ty ) ) return false ; for ( auto SP : Ty -> getStoredProperties ( ) ) { auto storedPropertyAccess = SP -> getEffectiveAccess ( ) ; if ( storedPropertyAccess <= AccessLevel :: FilePrivate || ( storedPropertyAccess <= AccessLevel :: Internal && Module -> isWholeModule ( ) ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ cannot ▁ be ▁ set ▁ externally \n " ) ; return false ; } } LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ can ▁ be ▁ used ▁ externally \n " ) ; return true ; } return false ; }
static bool mayHaveUnknownUses ( VarDecl * Property , SILModule * Module ) { if ( Property -> getDeclContext ( ) -> getParentModule ( ) != Module -> getSwiftModule ( ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ is ▁ defined ▁ in ▁ a ▁ different ▁ module \n " ) ; return true ; } if ( isAssignableExternally ( Property , Module ) ) { return true ; } return false ; }
static bool isProjectionOfProperty ( SILValue addr , VarDecl * Property ) { if ( auto * REA = dyn_cast < RefElementAddrInst > ( addr ) ) { return REA -> getField ( ) == Property ; } if ( auto * SEA = dyn_cast < StructElementAddrInst > ( addr ) ) { return SEA -> getField ( ) == Property ; } return false ; }
static bool isValidPropertyLoad ( SILInstruction * I ) { if ( isa < LoadInst > ( I ) ) return true ; if ( isa < StructElementAddrInst > ( I ) || isa < TupleElementAddrInst > ( I ) ) { auto projection = cast < SingleValueInstruction > ( I ) ; for ( auto Use : getNonDebugUses ( projection ) ) { if ( isIncidentalUse ( Use -> getUser ( ) ) ) continue ; if ( ! isValidPropertyLoad ( Use -> getUser ( ) ) ) return false ; } return true ; } return false ; }
OSErr QuitAppleEventHandler ( const AppleEvent * appleEvt , AppleEvent * reply , UInt32 refcon ) { DescType senderType ; Size actualSize ; ProcessSerialNumber SenderPSN ; ProcessInfoRec pInfo ; FSSpec fileSpec ; OSStatus anErr ; if ( wxGetApp ( ) . IsModalDialogDisplayed ( ) ) { SysBeep ( 4 ) ; return userCanceledErr ; } anErr = AEGetAttributePtr ( appleEvt , keyAddressAttr , typeProcessSerialNumber , & senderType , & SenderPSN , sizeof ( SenderPSN ) , & actualSize ) ; if ( anErr == noErr ) { pInfo . processInfoLength = sizeof ( ProcessInfoRec ) ; pInfo . processName = NULL ; pInfo . processAppSpec = & fileSpec ; anErr = GetProcessInformation ( & SenderPSN , & pInfo ) ; if ( ( pInfo . processSignature != ' dock ' ) && ( pInfo . processSignature != ' BNC ! ' ) ) { s_bSkipExitConfirmation = true ; wxGetApp ( ) . ExitMainLoop ( ) ; } } return wxGetApp ( ) . MacHandleAEQuit ( ( AppleEvent * ) appleEvt , reply ) ; }
double angleDiff ( double phi1 , double phi2 ) { double d = phi2 - phi1 ; if ( d > 0.0 ) { d = fmod ( d + M_PI , 2 * M_PI ) - M_PI ; } else { d = fmod ( d - M_PI , 2 * M_PI ) + M_PI ; } return d ; }
Vector4d quatConjugate ( const Eigen :: Vector4d & q ) { Vector4d q_conj ; q_conj << q ( 0 ) , - q ( 1 ) , - q ( 2 ) , - q ( 3 ) ; return q_conj ; }
double quatDiffAxisInvar ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 , const Eigen :: Vector3d & u ) { Vector4d r = quatDiff ( q1 , q2 ) ; double e = - 2.0 + 2 * r ( 0 ) * r ( 0 ) + 2 * pow ( u ( 0 ) * r ( 1 ) + u ( 1 ) * r ( 2 ) + u ( 2 ) * r ( 3 ) , 2 ) ; return e ; }
double quatNorm ( const Eigen :: Vector4d & q ) { return std :: acos ( q ( 0 ) ) ; }
Vector4d uniformlyRandomAxisAngle ( std :: default_random_engine & generator ) { std :: normal_distribution < double > normal ; std :: uniform_real_distribution < double > uniform ( - M_PI , M_PI ) ; double angle = uniform ( generator ) ; Vector3d axis = Vector3d ( normal ( generator ) , normal ( generator ) , normal ( generator ) ) ; axis . normalize ( ) ; Vector4d a ; a << axis , angle ; return a ; }
Vector4d uniformlyRandomQuat ( std :: default_random_engine & generator ) { return axis2quat ( uniformlyRandomAxisAngle ( generator ) ) ; }
DLLEXPORT int rotationRepresentationSize ( int rotation_type ) { switch ( rotation_type ) { case 0 : return 0 ; break ; case 1 : return 3 ; break ; case 2 : return 4 ; break ; default : throw std :: runtime_error ( " rotation ▁ representation ▁ type ▁ not ▁ recognized " ) ; } }
Matrix3d rotz ( double theta ) { Matrix3d M ; double c = cos ( theta ) ; double s = sin ( theta ) ; M << c , - s , 0 , s , c , 0 , 0 , 0 , 1 ; return M ; }
void rotz ( double theta , Matrix3d & M , Matrix3d & dM , Matrix3d & ddM ) { double c = cos ( theta ) , s = sin ( theta ) ; M << c , - s , 0 , s , c , 0 , 0 , 0 , 1 ; dM << - s , - c , 0 , c , - s , 0 , 0 , 0 , 0 ; ddM << - c , s , 0 , - s , - c , 0 , 0 , 0 , 0 ; }
template < typename Derived > void normalizeVec ( const Eigen :: MatrixBase < Derived > & x , typename Derived :: PlainObject & x_norm , typename Gradient < Derived , Derived :: RowsAtCompileTime , 1 > :: type * dx_norm , typename Gradient < Derived , Derived :: RowsAtCompileTime , 2 > :: type * ddx_norm ) { typename Derived :: Scalar xdotx = x . squaredNorm ( ) ; typename Derived :: Scalar norm_x = std :: sqrt ( xdotx ) ; x_norm = x / norm_x ; if ( dx_norm ) { dx_norm -> setIdentity ( x . rows ( ) , x . rows ( ) ) ; ( * dx_norm ) -= x * x . transpose ( ) / xdotx ; ( * dx_norm ) /= norm_x ; if ( ddx_norm ) { auto dx_norm_transpose = transposeGrad ( * dx_norm , x . rows ( ) ) ; auto ddx_norm_times_norm = - matGradMultMat ( x_norm , x_norm . transpose ( ) , ( * dx_norm ) , dx_norm_transpose ) ; auto dnorm_inv = - x . transpose ( ) / ( xdotx * norm_x ) ; ( * ddx_norm ) = ddx_norm_times_norm / norm_x ; auto temp = ( * dx_norm ) * norm_x ; typename Derived :: Index n = x . rows ( ) ; for ( int col = 0 ; col < n ; col ++ ) { auto column_as_matrix = ( dnorm_inv ( 0 , col ) * temp ) ; for ( int row_block = 0 ; row_block < n ; row_block ++ ) { ddx_norm -> block ( row_block * n , col , n , 1 ) += column_as_matrix . col ( row_block ) ; } } } } }
template < typename DerivedQ , typename DerivedM , typename DerivedDM > void angularvel2quatdotMatrix ( const Eigen :: MatrixBase < DerivedQ > & q , Eigen :: MatrixBase < DerivedM > & M , Eigen :: MatrixBase < DerivedDM > * dM ) { M . resize ( QUAT_SIZE , SPACE_DIMENSION ) ; M . row ( 0 ) << - q ( 1 ) , - q ( 2 ) , - q ( 3 ) ; M . row ( 1 ) << q ( 0 ) , q ( 3 ) , - q ( 2 ) ; M . row ( 2 ) << - q ( 3 ) , q ( 0 ) , q ( 1 ) ; M . row ( 3 ) << q ( 2 ) , - q ( 1 ) , q ( 0 ) ; M *= 0.5 ; if ( dM ) { ( * dM ) << 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.5 , 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 ; } }
template < typename DerivedQ , typename DerivedM > void quatdot2angularvelMatrix ( const Eigen :: MatrixBase < DerivedQ > & q , Eigen :: MatrixBase < DerivedM > & M , typename Gradient < DerivedM , QUAT_SIZE , 1 > :: type * dM ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedQ > , QUAT_SIZE ) ; EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedM > , SPACE_DIMENSION , QUAT_SIZE ) ; typename DerivedQ :: PlainObject qtilde ; if ( dM ) { typename Gradient < DerivedQ , QUAT_SIZE > :: type dqtilde ; normalizeVec ( q , qtilde , & dqtilde ) ; ( * dM ) << 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , 0.0 ; ( * dM ) *= dqtilde ; } else { normalizeVec ( q , qtilde ) ; } M << - qtilde ( 1 ) , qtilde ( 0 ) , - qtilde ( 3 ) , qtilde ( 2 ) , - qtilde ( 2 ) , qtilde ( 3 ) , qtilde ( 0 ) , - qtilde ( 1 ) , - qtilde ( 3 ) , - qtilde ( 2 ) , qtilde ( 1 ) , qtilde ( 0 ) ; M *= 2.0 ; }
template < typename DerivedRPY , typename DerivedPhi , typename DerivedDPhi , typename DerivedDDPhi > void angularvel2rpydotMatrix ( const Eigen :: MatrixBase < DerivedRPY > & rpy , typename Eigen :: MatrixBase < DerivedPhi > & phi , typename Eigen :: MatrixBase < DerivedDPhi > * dphi , typename Eigen :: MatrixBase < DerivedDDPhi > * ddphi ) { phi . resize ( RPY_SIZE , SPACE_DIMENSION ) ; typedef typename DerivedRPY :: Scalar Scalar ; Scalar p = rpy ( 1 ) ; Scalar y = rpy ( 2 ) ; using namespace std ; Scalar sy = sin ( y ) ; Scalar cy = cos ( y ) ; Scalar sp = sin ( p ) ; Scalar cp = cos ( p ) ; Scalar tp = sp / cp ; phi << cy / cp , sy / cp , 0.0 , - sy , cy , 0.0 , cy * tp , tp * sy , 1.0 ; if ( dphi ) { dphi -> resize ( phi . size ( ) , RPY_SIZE ) ; Scalar sp2 = sp * sp ; Scalar cp2 = cp * cp ; ( * dphi ) << 0.0 , ( cy * sp ) / cp2 , - sy / cp , 0.0 , 0.0 , - cy , 0.0 , cy + ( cy * sp2 ) / cp2 , - ( sp * sy ) / cp , 0.0 , ( sp * sy ) / cp2 , cy / cp , 0.0 , 0.0 , - sy , 0.0 , sy + ( sp2 * sy ) / cp2 , ( cy * sp ) / cp , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; if ( ddphi ) { ddphi -> resize ( dphi -> size ( ) , RPY_SIZE ) ; Scalar cp3 = cp2 * cp ; ( * ddphi ) << 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - ( cy * ( cp2 - 2.0 ) ) / cp3 , ( sp * sy ) / ( sp2 - 1.0 ) , 0.0 , 0.0 , 0.0 , 0.0 , ( 2.0 * cy * sp ) / cp3 , sy / ( sp2 - 1.0 ) , 0.0 , ( 2.0 * sy - cp2 * sy ) / cp3 , ( cy * sp ) / cp2 , 0.0 , 0.0 , 0.0 , 0.0 , ( 2.0 * sp * sy ) / cp3 , cy / cp2 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , ( sp * sy ) / ( sp2 - 1.0 ) , - cy / cp , 0.0 , 0.0 , sy , 0.0 , sy / ( sp2 - 1.0 ) , - ( cy * sp ) / cp , 0.0 , ( cy * sp ) / cp2 , - sy / cp , 0.0 , 0.0 , - cy , 0.0 , cy / cp2 , - ( sp * sy ) / cp , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; } } }
template < typename DerivedRPY , typename DerivedE > void rpydot2angularvelMatrix ( const Eigen :: MatrixBase < DerivedRPY > & rpy , Eigen :: MatrixBase < DerivedE > & E , typename Gradient < DerivedE , RPY_SIZE , 1 > :: type * dE ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedRPY > , RPY_SIZE ) ; EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedE > , SPACE_DIMENSION , RPY_SIZE ) ; typedef typename DerivedRPY :: Scalar Scalar ; Scalar p = rpy ( 1 ) ; Scalar y = rpy ( 2 ) ; Scalar sp = sin ( p ) ; Scalar cp = cos ( p ) ; Scalar sy = sin ( y ) ; Scalar cy = cos ( y ) ; using namespace std ; E << cp * cy , - sy , 0.0 , cp * sy , cy , 0.0 , - sp , 0.0 , 1.0 ; if ( dE ) { ( * dE ) << 0.0 , - sp * cy , - cp * sy , 0.0 , - sp * sy , cp * cy , 0.0 , - cp , 0.0 , 0.0 , 0.0 , - cy , 0.0 , 0.0 , - sy , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; } }
template < typename Scalar > DLLEXPORT void cylindrical2cartesian ( const Matrix < Scalar , 3 , 1 > & m_cylinder_axis , const Matrix < Scalar , 3 , 1 > & m_cylinder_x_dir , const Matrix < Scalar , 3 , 1 > & cylinder_origin , const Matrix < Scalar , 6 , 1 > & x_cylinder , const Matrix < Scalar , 6 , 1 > & v_cylinder , Matrix < Scalar , 6 , 1 > & x_cartesian , Matrix < Scalar , 6 , 1 > & v_cartesian , Matrix < Scalar , 6 , 6 > & J , Matrix < Scalar , 6 , 1 > & Jdotv ) { Matrix < Scalar , 3 , 1 > cylinder_axis = m_cylinder_axis / m_cylinder_axis . norm ( ) ; Matrix < Scalar , 3 , 1 > cylinder_x_dir = m_cylinder_x_dir / m_cylinder_x_dir . norm ( ) ; Matrix < Scalar , 3 , 3 > R_cylinder2cartesian ; R_cylinder2cartesian . col ( 0 ) = cylinder_x_dir ; R_cylinder2cartesian . col ( 1 ) = cylinder_axis . cross ( cylinder_x_dir ) ; R_cylinder2cartesian . col ( 2 ) = cylinder_axis ; double radius = x_cylinder ( 0 ) ; double theta = x_cylinder ( 1 ) ; double c_theta = cos ( theta ) ; double s_theta = sin ( theta ) ; double height = x_cylinder ( 2 ) ; double radius_dot = v_cylinder ( 0 ) ; double theta_dot = v_cylinder ( 1 ) ; double height_dot = v_cylinder ( 2 ) ; Matrix < Scalar , 3 , 1 > x_pos_cartesian ; x_pos_cartesian << radius * c_theta , radius * s_theta , height ; x_pos_cartesian = R_cylinder2cartesian * x_pos_cartesian + cylinder_origin ; Matrix < Scalar , 3 , 1 > v_pos_cartesian ; v_pos_cartesian << radius * - s_theta * theta_dot + radius_dot * c_theta , radius * c_theta * theta_dot + radius_dot * s_theta , height_dot ; v_pos_cartesian = R_cylinder2cartesian * v_pos_cartesian ; Vector3d x_rpy_cylinder = x_cylinder . block ( 3 , 0 , 3 , 1 ) ; Matrix < Scalar , 3 , 3 > R_tangent = rpy2rotmat ( x_rpy_cylinder ) ; Matrix < Scalar , 3 , 3 > R_tangent2cylinder ; Matrix < Scalar , 3 , 3 > dR_tangent2cylinder ; Matrix < Scalar , 3 , 3 > ddR_tangent2cylinder ; rotz ( theta - M_PI / 2 , R_tangent2cylinder , dR_tangent2cylinder , ddR_tangent2cylinder ) ; Matrix < Scalar , 3 , 3 > dR_tangent2cylinder_dtheta = dR_tangent2cylinder ; Matrix < Scalar , 3 , 3 > R_cylinder = R_tangent2cylinder * R_tangent ; Matrix < Scalar , 3 , 3 > R_cartesian = R_cylinder2cartesian * R_cylinder ; Matrix < Scalar , 3 , 1 > x_rpy_cartesian = rotmat2rpy ( R_cartesian ) ; x_cartesian . block ( 0 , 0 , 3 , 1 ) = x_pos_cartesian ; x_cartesian . block ( 3 , 0 , 3 , 1 ) = x_rpy_cartesian ; v_cartesian . block ( 0 , 0 , 3 , 1 ) = v_pos_cartesian ; v_cartesian . block ( 3 , 0 , 3 , 1 ) = theta_dot * R_cylinder2cartesian . col ( 2 ) + R_cylinder2cartesian * R_tangent2cylinder * v_cylinder . block ( 3 , 0 , 3 , 1 ) ; J = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; J . block ( 0 , 0 , 3 , 1 ) << c_theta , s_theta , 0 ; J . block ( 0 , 1 , 3 , 1 ) << radius * - s_theta , radius * c_theta , 0 ; J . block ( 0 , 2 , 3 , 1 ) << 0 , 0 , 1 ; J . block ( 0 , 0 , 3 , 3 ) = R_cylinder2cartesian * J . block ( 0 , 0 , 3 , 3 ) ; J . block ( 3 , 1 , 3 , 1 ) = R_cylinder2cartesian . col ( 2 ) ; J . block ( 3 , 3 , 3 , 3 ) = R_cylinder2cartesian * R_tangent2cylinder ; Matrix < Scalar , 3 , 3 > dJ1_dradius = Matrix < Scalar , 3 , 3 > :: Zero ( ) ; dJ1_dradius ( 0 , 1 ) = - s_theta ; dJ1_dradius ( 1 , 1 ) = c_theta ; Matrix < Scalar , 3 , 3 > dJ1_dtheta = Matrix < Scalar , 3 , 3 > :: Zero ( ) ; dJ1_dtheta ( 0 , 0 ) = - s_theta ; dJ1_dtheta ( 0 , 1 ) = - radius * c_theta ; dJ1_dtheta ( 1 , 0 ) = c_theta ; dJ1_dtheta ( 1 , 1 ) = - radius * s_theta ; Jdotv . block ( 0 , 0 , 3 , 1 ) = R_cylinder2cartesian * ( dJ1_dradius * radius_dot + dJ1_dtheta * theta_dot ) * v_cylinder . block ( 0 , 0 , 3 , 1 ) ; Jdotv . block ( 3 , 0 , 3 , 1 ) = R_cylinder2cartesian * dR_tangent2cylinder_dtheta * theta_dot * v_cylinder . block ( 3 , 0 , 3 , 1 ) ; }
template < typename Scalar > DLLEXPORT void cartesian2cylindrical ( const Eigen :: Matrix < Scalar , 3 , 1 > & m_cylinder_axis , const Eigen :: Matrix < Scalar , 3 , 1 > & m_cylinder_x_dir , const Eigen :: Matrix < Scalar , 3 , 1 > & cylinder_origin , const Eigen :: Matrix < Scalar , 6 , 1 > & x_cartesian , const Eigen :: Matrix < Scalar , 6 , 1 > & v_cartesian , Eigen :: Matrix < Scalar , 6 , 1 > & x_cylinder , Eigen :: Matrix < Scalar , 6 , 1 > & v_cylinder , Eigen :: Matrix < Scalar , 6 , 6 > & J , Eigen :: Matrix < Scalar , 6 , 1 > & Jdotv ) { Matrix < Scalar , 3 , 1 > cylinder_axis = m_cylinder_axis / m_cylinder_axis . norm ( ) ; Matrix < Scalar , 3 , 1 > cylinder_x_dir = m_cylinder_x_dir / m_cylinder_x_dir . norm ( ) ; Matrix < Scalar , 3 , 3 > R_cylinder2cartesian ; R_cylinder2cartesian . col ( 0 ) = cylinder_x_dir ; R_cylinder2cartesian . col ( 1 ) = cylinder_axis . cross ( cylinder_x_dir ) ; R_cylinder2cartesian . col ( 2 ) = cylinder_axis ; Matrix < Scalar , 3 , 3 > R_cartesian2cylinder = R_cylinder2cartesian . transpose ( ) ; Matrix < Scalar , 3 , 1 > x_pos_cylinder = R_cartesian2cylinder * ( x_cartesian . block ( 0 , 0 , 3 , 1 ) - cylinder_origin ) ; Matrix < Scalar , 3 , 1 > v_pos_cylinder = R_cartesian2cylinder * v_cartesian . block ( 0 , 0 , 3 , 1 ) ; double radius = sqrt ( pow ( x_pos_cylinder ( 0 ) , 2 ) + pow ( x_pos_cylinder ( 1 ) , 2 ) ) ; double radius_dot = ( x_pos_cylinder ( 0 ) * v_pos_cylinder ( 0 ) + x_pos_cylinder ( 1 ) * v_pos_cylinder ( 1 ) ) / radius ; double theta = atan2 ( x_pos_cylinder ( 1 ) , x_pos_cylinder ( 0 ) ) ; double radius_square = pow ( radius , 2 ) ; double radius_cubic = pow ( radius , 3 ) ; double radius_quad = pow ( radius , 4 ) ; double theta_dot = ( - x_pos_cylinder ( 1 ) * v_pos_cylinder ( 0 ) + x_pos_cylinder ( 0 ) * v_pos_cylinder ( 1 ) ) / radius_square ; double height = x_pos_cylinder ( 2 ) ; double height_dot = v_pos_cylinder ( 2 ) ; x_cylinder ( 0 ) = radius ; x_cylinder ( 1 ) = theta ; x_cylinder ( 2 ) = height ; v_cylinder ( 0 ) = radius_dot ; v_cylinder ( 1 ) = theta_dot ; v_cylinder ( 2 ) = height_dot ; Matrix < Scalar , 3 , 3 > R_tangent2cylinder ; Matrix < Scalar , 3 , 3 > dR_tangent2cylinder ; Matrix < Scalar , 3 , 3 > ddR_tangent2cylinder ; rotz ( theta - M_PI / 2 , R_tangent2cylinder , dR_tangent2cylinder , ddR_tangent2cylinder ) ; Matrix < Scalar , 3 , 3 > R_cylinder2tangent = R_tangent2cylinder . transpose ( ) ; Vector3d x_rpy_cartesian = x_cartesian . block ( 3 , 0 , 3 , 1 ) ; Matrix < Scalar , 3 , 3 > R_cartesian = rpy2rotmat ( x_rpy_cartesian ) ; x_cylinder . block ( 3 , 0 , 3 , 1 ) = rotmat2rpy ( R_cylinder2tangent * R_cartesian2cylinder * R_cartesian ) ; J = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; Matrix < Scalar , 6 , 6 > Jdot = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; J ( 0 , 0 ) = x_pos_cylinder ( 0 ) / radius ; J ( 0 , 1 ) = x_pos_cylinder ( 1 ) / radius ; J ( 1 , 0 ) = - x_pos_cylinder ( 1 ) / radius_square ; J ( 1 , 1 ) = x_pos_cylinder ( 0 ) / radius_square ; J ( 2 , 2 ) = 1.0 ; J . block ( 0 , 0 , 3 , 3 ) = J . block ( 0 , 0 , 3 , 3 ) * R_cartesian2cylinder ; Jdot ( 0 , 0 ) = pow ( x_pos_cylinder ( 1 ) , 2 ) / radius_cubic * v_pos_cylinder ( 0 ) - x_pos_cylinder ( 0 ) * x_pos_cylinder ( 1 ) / radius_cubic * v_pos_cylinder ( 1 ) ; Jdot ( 0 , 1 ) = - x_pos_cylinder ( 0 ) * x_pos_cylinder ( 1 ) / radius_cubic * v_pos_cylinder ( 0 ) + pow ( x_pos_cylinder ( 0 ) , 2 ) / radius_cubic * v_pos_cylinder ( 1 ) ; Jdot ( 1 , 0 ) = 2 * x_pos_cylinder ( 0 ) * x_pos_cylinder ( 1 ) / radius_quad * v_pos_cylinder ( 0 ) + ( pow ( x_pos_cylinder ( 1 ) , 2 ) - pow ( x_pos_cylinder ( 0 ) , 2 ) ) / radius_quad * v_pos_cylinder ( 1 ) ; Jdot ( 1 , 1 ) = ( pow ( x_pos_cylinder ( 1 ) , 2 ) - pow ( x_pos_cylinder ( 0 ) , 2 ) ) / radius_quad * v_pos_cylinder ( 0 ) - 2 * x_pos_cylinder ( 0 ) * x_pos_cylinder ( 1 ) / radius_quad * v_pos_cylinder ( 1 ) ; Jdot . block ( 0 , 0 , 3 , 3 ) = Jdot . block ( 0 , 0 , 3 , 3 ) * R_cartesian2cylinder ; v_cylinder . block ( 3 , 0 , 3 , 1 ) = R_cylinder2tangent * R_cartesian2cylinder * v_cartesian . block ( 3 , 0 , 3 , 1 ) - theta_dot * R_cylinder2tangent . col ( 2 ) ; J . block ( 3 , 0 , 3 , 3 ) = R_cylinder2tangent . col ( 2 ) * - J . block ( 1 , 0 , 1 , 3 ) ; J . block ( 3 , 3 , 3 , 3 ) = R_cylinder2tangent * R_cartesian2cylinder ; Jdot . block ( 3 , 0 , 3 , 3 ) = dR_tangent2cylinder . row ( 2 ) . transpose ( ) * - J . block ( 1 , 0 , 1 , 3 ) * theta_dot + R_cylinder2tangent . col ( 2 ) * - Jdot . block ( 1 , 0 , 1 , 3 ) ; Jdot . block ( 3 , 3 , 3 , 3 ) = dR_tangent2cylinder . transpose ( ) * theta_dot * R_cartesian2cylinder ; Jdotv = Jdot * v_cartesian ; }
DLLEXPORT GradientVar < double , 3 , 1 > quat2expmap ( const Ref < const Vector4d > & q , int gradient_order ) { double t = sqrt ( 1 - q ( 0 ) * q ( 0 ) ) ; bool is_degenerate = ( t * t < std :: numeric_limits < double > :: epsilon ( ) ) ; double s = is_degenerate ? 2.0 : 2.0 * acos ( q ( 0 ) ) / t ; GradientVar < double , 3 , 1 > ret ( 3 , 1 , 4 , gradient_order ) ; ret . value ( ) = s * q . tail ( 3 ) ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = Matrix < double , 3 , 4 > :: Zero ( ) ; double dsdq1 = is_degenerate ? 0.0 : ( - 2 * t + 2 * acos ( q ( 0 ) ) * q ( 0 ) ) / pow ( t , 3 ) ; ret . gradient ( ) . value ( ) . col ( 0 ) = q . tail ( 3 ) * dsdq1 ; ret . gradient ( ) . value ( ) . block ( 0 , 1 , 3 , 3 ) = Matrix3d :: Identity ( ) * s ; } else if ( gradient_order > 1 ) { throw std :: runtime_error ( " gradient _ order > 1 ▁ is ▁ not ▁ supported ▁ in ▁ quat2expmap " ) ; } return ret ; }
DLLEXPORT GradientVar < double , 3 , 1 > flipExpmap ( const Ref < const Vector3d > & expmap , int gradient_order ) { if ( gradient_order > 1 ) { throw std :: runtime_error ( " gradient _ order > 1 ▁ is ▁ not ▁ supported ▁ in ▁ flipExpmap " ) ; } double expmap_norm = expmap . norm ( ) ; bool is_degenerate = ( expmap_norm < std :: numeric_limits < double > :: epsilon ( ) ) ; GradientVar < double , 3 , 1 > ret ( 3 , 1 , 3 , gradient_order ) ; Matrix3d eye3 = Matrix3d :: Identity ( ) ; if ( is_degenerate ) { ret . value ( ) = expmap ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = eye3 ; } } else { ret . value ( ) = expmap - expmap / expmap_norm * 2 * M_PI ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = eye3 - ( expmap_norm * expmap_norm * eye3 - expmap * expmap . transpose ( ) ) / pow ( expmap_norm , 3 ) * 2 * M_PI ; } } return ret ; }
DLLEXPORT GradientVar < double , 3 , 1 > unwrapExpmap ( const Ref < const Vector3d > & expmap1 , const Ref < const Vector3d > & expmap2 , int gradient_order ) { auto expmap2_flip = flipExpmap ( expmap2 , gradient_order ) ; double distance1 = ( expmap1 - expmap2 ) . squaredNorm ( ) ; double distance2 = ( expmap1 - expmap2_flip . value ( ) ) . squaredNorm ( ) ; if ( distance1 > distance2 ) { return expmap2_flip ; } else { GradientVar < double , 3 , 1 > ret ( 3 , 1 , 3 , gradient_order ) ; ret . value ( ) = expmap2 ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = Matrix3d :: Identity ( ) ; } return ret ; } }
void quat2expmapSequence ( const Ref < const Matrix < double , 4 , Dynamic >> & quat , const Ref < const Matrix < double , 4 , Dynamic >> & quat_dot , Ref < Matrix < double , 3 , Dynamic >> expmap , Ref < Matrix < double , 3 , Dynamic >> expmap_dot ) { DenseIndex N = quat . cols ( ) ; if ( quat_dot . cols ( ) != N ) { throw std :: runtime_error ( " quat _ dot ▁ must ▁ have ▁ the ▁ same ▁ number ▁ of ▁ columns ▁ as ▁ quat ▁ in ▁ quat2expmapSequence " ) ; } expmap . resize ( 3 , N ) ; expmap_dot . resize ( 3 , N ) ; for ( int i = 0 ; i < N ; i ++ ) { auto expmap_grad = quat2expmap ( quat . col ( i ) , 1 ) ; expmap . col ( i ) = expmap_grad . value ( ) ; expmap_dot . col ( i ) = expmap_grad . gradient ( ) . value ( ) * quat_dot . col ( i ) ; if ( i >= 1 ) { auto closest_grad = closestExpmap ( expmap . col ( i - 1 ) , expmap . col ( i ) , 1 ) ; expmap . col ( i ) = closest_grad . value ( ) ; expmap_dot . col ( i ) = closest_grad . gradient ( ) . value ( ) * expmap_dot . col ( i ) ; } } }
DLLEXPORT GradientVar < double , 3 , 1 > closestExpmap ( const Ref < const Vector3d > & expmap1 , const Ref < const Vector3d > & expmap2 , int gradient_order ) { if ( gradient_order > 1 ) { throw std :: runtime_error ( " closestExpmap ▁ only ▁ supports ▁ first ▁ order ▁ gradient " ) ; } double expmap1_norm = expmap1 . norm ( ) ; double expmap2_norm = expmap2 . norm ( ) ; GradientVar < double , 3 , 1 > ret ( 3 , 1 , 3 , gradient_order ) ; if ( expmap2_norm < std :: numeric_limits < double > :: epsilon ( ) ) { if ( expmap1_norm > std :: numeric_limits < double > :: epsilon ( ) ) { Vector3d expmap1_axis = expmap1 / expmap1_norm ; int expmap1_round = static_cast < int > ( expmap1_norm / ( 2 * M_PI ) + 0.5 ) ; ret . value ( ) = expmap1_axis * expmap1_round * 2 * M_PI ; if ( ret . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = Matrix3d :: Zero ( ) ; } return ret ; } else { ret . value ( ) = expmap2 ; if ( ret . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = Matrix3d :: Identity ( ) ; } } } else { Vector3d expmap2_axis = expmap2 / expmap2_norm ; Matrix3d dexpmap2_axis_dexpmap2 = ( expmap2_norm * Matrix3d :: Identity ( ) - expmap2 * expmap2 . transpose ( ) / expmap2_norm ) / pow ( expmap2_norm , 2 ) ; double expmap2_closest_k = ( expmap2_axis . transpose ( ) * expmap1 - expmap2_norm ) / ( 2 * M_PI ) ; int expmap2_closest_k1 ; int expmap2_closest_k2 ; if ( expmap2_closest_k > 0 ) { expmap2_closest_k1 = ( int ) expmap2_closest_k ; } else { expmap2_closest_k1 = ( int ) expmap2_closest_k - 1 ; } expmap2_closest_k2 = expmap2_closest_k1 + 1 ; Vector3d expmap2_closest1 = expmap2 + 2 * expmap2_closest_k1 * M_PI * expmap2_axis ; Vector3d expmap2_closest2 = expmap2 + 2 * expmap2_closest_k2 * M_PI * expmap2_axis ; if ( ( expmap2_closest1 - expmap1 ) . norm ( ) < ( expmap2_closest2 - expmap1 ) . norm ( ) ) { ret . value ( ) = expmap2_closest1 ; if ( ret . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = Matrix3d :: Identity ( ) + 2 * dexpmap2_axis_dexpmap2 * ( double ) expmap2_closest_k1 * M_PI ; } return ret ; } else { ret . value ( ) = expmap2_closest2 ; if ( ret . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = Matrix3d :: Identity ( ) + 2 * dexpmap2_axis_dexpmap2 * ( double ) expmap2_closest_k2 * M_PI ; } return ret ; } } return ret ; }
