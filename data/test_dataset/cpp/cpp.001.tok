<DOCUMENT_ID="fstudio/Phoenix/tree/master/test/Experimental/libcxx/test/std/strings/char.traits/char.traits.specializations/char.traits.specializations.char16_t/eof.pass.cpp"> # include < string > # include < cassert > int main ( ) { # ifndef _LIBCPP_HAS_NO_UNICODE_CHARS std :: char_traits < char16_t > :: int_type i = std :: char_traits < char16_t > :: eof ( ) ; # endif } </DOCUMENT>
<DOCUMENT_ID="leighleighleigh/smol-pong/tree/master/smol_pong/DNSServer.cpp"> # include " . / DNSServer . h " # include < lwip / def . h > # include < Arduino . h > # define DEBUG # define DEBUG_OUTPUT Serial DNSServer :: DNSServer ( ) { _ttl = htonl ( 60 ) ; _errorReplyCode = DNSReplyCode :: NonExistentDomain ; } bool DNSServer :: start ( const uint16_t & port , const String & domainName , const IPAddress & resolvedIP ) { _port = port ; _domainName = domainName ; _resolvedIP [ 0 ] = resolvedIP [ 0 ] ; _resolvedIP [ 1 ] = resolvedIP [ 1 ] ; _resolvedIP [ 2 ] = resolvedIP [ 2 ] ; _resolvedIP [ 3 ] = resolvedIP [ 3 ] ; downcaseAndRemoveWwwPrefix ( _domainName ) ; return _udp . begin ( _port ) == 1 ; } void DNSServer :: setErrorReplyCode ( const DNSReplyCode & replyCode ) { _errorReplyCode = replyCode ; } void DNSServer :: setTTL ( const uint32_t & ttl ) { _ttl = htonl ( ttl ) ; } void DNSServer :: stop ( ) { _udp . stop ( ) ; } void DNSServer :: downcaseAndRemoveWwwPrefix ( String & domainName ) { domainName . toLowerCase ( ) ; domainName . replace ( " www . " , " " ) ; } void DNSServer :: processNextRequest ( ) { _currentPacketSize = _udp . parsePacket ( ) ; if ( _currentPacketSize ) { _buffer = ( unsigned char * ) malloc ( _currentPacketSize * sizeof ( char ) ) ; _udp . read ( _buffer , _currentPacketSize ) ; _dnsHeader = ( DNSHeader * ) _buffer ; if ( _dnsHeader -> QR == DNS_QR_QUERY && _dnsHeader -> OPCode == DNS_OPCODE_QUERY && requestIncludesOnlyOneQuestion ( ) && ( _domainName == " * " || getDomainNameWithoutWwwPrefix ( ) == _domainName ) ) { replyWithIP ( ) ; } else if ( _dnsHeader -> QR == DNS_QR_QUERY ) { replyWithCustomCode ( ) ; } free ( _buffer ) ; } } bool DNSServer :: requestIncludesOnlyOneQuestion ( ) { return ntohs ( _dnsHeader -> QDCount ) == 1 && _dnsHeader -> ANCount == 0 && _dnsHeader -> NSCount == 0 && _dnsHeader -> ARCount == 0 ; } String DNSServer :: getDomainNameWithoutWwwPrefix ( ) { String parsedDomainName = " " ; unsigned char * start = _buffer + 12 ; if ( * start == 0 ) { return parsedDomainName ; } int pos = 0 ; while ( true ) { unsigned char labelLength = * ( start + pos ) ; for ( int i = 0 ; i < labelLength ; i ++ ) { pos ++ ; parsedDomainName += ( char ) * ( start + pos ) ; } pos ++ ; if ( * ( start + pos ) == 0 ) { downcaseAndRemoveWwwPrefix ( parsedDomainName ) ; return parsedDomainName ; } else { parsedDomainName += " . " ; } } } void DNSServer :: replyWithIP ( ) { _dnsHeader -> QR = DNS_QR_RESPONSE ; _dnsHeader -> ANCount = _dnsHeader -> QDCount ; _dnsHeader -> QDCount = _dnsHeader -> QDCount ; _udp . beginPacket ( _udp . remoteIP ( ) , _udp . remotePort ( ) ) ; _udp . write ( _buffer , _currentPacketSize ) ; _udp . write ( ( uint8_t ) 192 ) ; _udp . write ( ( uint8_t ) 12 ) ; _udp . write ( ( uint8_t ) 0 ) ; _udp . write ( ( uint8_t ) 1 ) ; _udp . write ( ( uint8_t ) 0 ) ; _udp . write ( ( uint8_t ) 1 ) ; _udp . write ( ( unsigned char * ) & _ttl , 4 ) ; _udp . write ( ( uint8_t ) 0 ) ; _udp . write ( ( uint8_t ) 4 ) ; _udp . write ( _resolvedIP , sizeof ( _resolvedIP ) ) ; _udp . endPacket ( ) ; # ifdef DEBUG DEBUG_OUTPUT . print ( " DNS ▁ responds : ▁ " ) ; DEBUG_OUTPUT . print ( _resolvedIP [ 0 ] ) ; DEBUG_OUTPUT . print ( " . " ) ; DEBUG_OUTPUT . print ( _resolvedIP [ 1 ] ) ; DEBUG_OUTPUT . print ( " . " ) ; DEBUG_OUTPUT . print ( _resolvedIP [ 2 ] ) ; DEBUG_OUTPUT . print ( " . " ) ; DEBUG_OUTPUT . print ( _resolvedIP [ 3 ] ) ; DEBUG_OUTPUT . print ( " ▁ for ▁ " ) ; DEBUG_OUTPUT . println ( getDomainNameWithoutWwwPrefix ( ) ) ; # endif } void DNSServer :: replyWithCustomCode ( ) { _dnsHeader -> QR = DNS_QR_RESPONSE ; _dnsHeader -> RCode = ( unsigned char ) _errorReplyCode ; _dnsHeader -> QDCount = 0 ; _udp . beginPacket ( _udp . remoteIP ( ) , _udp . remotePort ( ) ) ; _udp . write ( _buffer , sizeof ( DNSHeader ) ) ; _udp . endPacket ( ) ; } </DOCUMENT>
<DOCUMENT_ID="yantrabuddhi/FreeCAD/tree/master/src/3rdParty/salomesmesh/src/Driver/Driver_Document.cpp"> # include " Driver _ Document . h " Driver_Document :: Driver_Document ( ) : myDocument ( NULL ) { } void Driver_Document :: SetFile ( const std :: string & theFileName ) { myFile = theFileName ; } void Driver_Document :: SetDocument ( SMESHDS_Document * theDocument ) { myDocument = theDocument ; } </DOCUMENT>
<DOCUMENT_ID="pmprog/TugOfWar/tree/master/Game/gamelobbystage.cpp"> # include " gamelobbystage . h " # include " menu . h " # include " input . h " # include " gamelobby _ addlocal . h " # include " gamestage . h " GameLobbyStage :: GameLobbyStage ( ) { networkconnection = nullptr ; currentinfo = new GameInfo ( true ) ; selection = 0 ; selectionteamisblue = true ; } GameLobbyStage :: GameLobbyStage ( Network * Connection ) { selection = 0 ; networkconnection = Connection ; currentinfo = new GameInfo ( Connection -> IsServer ( ) ) ; if ( ! Connection -> IsServer ( ) ) { } } void GameLobbyStage :: Begin ( ) { optionfont = FontCache :: LoadFont ( " resources / armalite . ttf " , 32 ) ; helpfont = FontCache :: LoadFont ( " resources / armalite . ttf " , 16 ) ; } void GameLobbyStage :: Pause ( ) { } void GameLobbyStage :: Resume ( ) { } void GameLobbyStage :: Finish ( ) { AUDIO -> StopMusic ( ) ; if ( networkconnection != nullptr ) { delete networkconnection ; networkconnection = nullptr ; } } void GameLobbyStage :: EventOccurred ( Event * e ) { InputItems :: ItemSet inputevent = InputItems :: NONE ; if ( e -> Type == EVENT_KEY_DOWN ) { if ( e -> Data . Keyboard . KeyCode == ALLEGRO_KEY_ESCAPE ) { delete FRAMEWORK -> ProgramStages -> Pop ( ) ; return ; } inputevent = Input :: GetItemFromEvent ( e ) ; } if ( e -> Type == EVENT_JOYSTICK_BUTTON_DOWN && inputevent == InputItems :: NONE ) { inputevent = Input :: GetItemFromEvent ( e ) ; } if ( inputevent != InputItems :: NONE ) { InputEvent ( inputevent ) ; } NetworkEvent ( e ) ; } void GameLobbyStage :: InputEvent ( InputItems :: ItemSet inputevent ) { switch ( inputevent ) { case InputItems :: UP : if ( selection > 0 ) { selection -- ; } break ; case InputItems :: DOWN : if ( selection < 2 ) { selection ++ ; } break ; case InputItems :: LEFT : selectionteamisblue = true ; break ; case InputItems :: RIGHT : selectionteamisblue = false ; break ; case InputItems :: SELECT : delete FRAMEWORK -> ProgramStages -> Pop ( ) ; return ; break ; case InputItems :: X : if ( networkconnection == nullptr ) { PlayerInfo * p = nullptr ; if ( selectionteamisblue ) { if ( currentinfo -> BlueTeam [ selection ] == nullptr ) { currentinfo -> BlueTeam [ selection ] = new PlayerInfo ( " " , true , false ) ; } p = currentinfo -> BlueTeam [ selection ] ; } else { if ( currentinfo -> RedTeam [ selection ] == nullptr ) { currentinfo -> RedTeam [ selection ] = new PlayerInfo ( " " , true , false ) ; } p = currentinfo -> RedTeam [ selection ] ; } p -> BlueTeam = selectionteamisblue ; p -> TeamIndex = selection ; p -> GameData = currentinfo ; FRAMEWORK -> ProgramStages -> Push ( new GameLobbyAddLocalStage ( p ) ) ; } break ; case InputItems :: B : if ( networkconnection == nullptr ) { PlayerInfo * p = nullptr ; if ( selectionteamisblue ) { if ( currentinfo -> BlueTeam [ selection ] == nullptr ) { p = new PlayerInfo ( " CPU " , true , true ) ; currentinfo -> BlueTeam [ selection ] = p ; } } else { if ( currentinfo -> RedTeam [ selection ] == nullptr ) { p = new PlayerInfo ( " CPU " , true , true ) ; currentinfo -> RedTeam [ selection ] = p ; } } if ( p != nullptr ) { p -> BlueTeam = selectionteamisblue ; p -> TeamIndex = selection ; p -> GameData = currentinfo ; } } break ; case InputItems :: Y : if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { PlayerInfo * p = nullptr ; if ( selectionteamisblue ) { p = currentinfo -> BlueTeam [ selection ] ; currentinfo -> BlueTeam [ selection ] = nullptr ; } else { p = currentinfo -> RedTeam [ selection ] ; currentinfo -> RedTeam [ selection ] = nullptr ; } if ( p != nullptr ) { if ( ! p -> Local ) { } delete p ; } } break ; case InputItems :: START : if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { GameStage * g = new GameStage ( currentinfo ) ; delete FRAMEWORK -> ProgramStages -> Pop ( ) ; FRAMEWORK -> ProgramStages -> Push ( g ) ; } break ; } } void GameLobbyStage :: NetworkEvent ( Event * e ) { if ( e -> Type == EVENT_NETWORK_CONNECTION_REQUEST ) { bool freeslot = false ; for ( int i = 0 ; i < 3 ; i ++ ) { freeslot = ( currentinfo -> BlueTeam [ i ] == nullptr ? true : freeslot ) ; freeslot = ( currentinfo -> RedTeam [ i ] == nullptr ? true : freeslot ) ; } if ( freeslot ) { } } if ( e -> Type == EVENT_NETWORK_CONNECTED ) { } if ( e -> Type == EVENT_NETWORK_DISCONNECTED ) { } if ( e -> Type == EVENT_NETWORK_PACKET_RECEIVED ) { } } void GameLobbyStage :: Update ( ) { } void GameLobbyStage :: Render ( ) { al_clear_to_color ( al_map_rgb ( 255 , 220 , 128 ) ) ; optionfont -> DrawString ( ( DISPLAY -> GetWidth ( ) / 2 ) + 2 , 12 , " Lobby " , FontHAlign :: CENTRE , al_map_rgb ( 0 , 0 , 0 ) ) ; optionfont -> DrawString ( ( DISPLAY -> GetWidth ( ) / 2 ) , 10 , " Lobby " , FontHAlign :: CENTRE , al_map_rgb ( 255 , 255 , 0 ) ) ; GameResources :: DrawPanel ( GameResources :: BluePanel , 5 , 80 , 13 , 8 , 8 ) ; optionfont -> DrawString ( 15 , 85 , " Blue ▁ Team " , FontHAlign :: LEFT , al_map_rgb ( 255 , 255 , 255 ) ) ; RenderPlayerSlot ( true , 0 , 15 , 140 ) ; RenderPlayerSlot ( true , 1 , 15 , 192 ) ; RenderPlayerSlot ( true , 2 , 15 , 244 ) ; GameResources :: DrawPanel ( GameResources :: RedPanel , 405 , 80 , 13 , 8 , 8 ) ; optionfont -> DrawString ( 415 , 85 , " Red ▁ Team " , FontHAlign :: LEFT , al_map_rgb ( 255 , 255 , 255 ) ) ; RenderPlayerSlot ( false , 0 , 415 , 140 ) ; RenderPlayerSlot ( false , 1 , 415 , 192 ) ; RenderPlayerSlot ( false , 2 , 415 , 244 ) ; int textoff = ( 50 - helpfont -> GetFontHeight ( ) ) / 2 ; if ( networkconnection == nullptr ) { al_draw_bitmap ( Input :: GetIcon ( InputItems :: X ) , 10 , 320 , 0 ) ; helpfont -> DrawString ( 64 , 320 + textoff , " Add ▁ Local ▁ Player " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; al_draw_bitmap ( Input :: GetIcon ( InputItems :: B ) , 10 , 370 , 0 ) ; helpfont -> DrawString ( 64 , 370 + textoff , " Add ▁ CPU ▁ Player " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; } if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { al_draw_bitmap ( Input :: GetIcon ( InputItems :: Y ) , 10 , 420 , 0 ) ; helpfont -> DrawString ( 64 , 420 + textoff , " Kick ▁ Player " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; al_draw_bitmap ( Input :: GetIcon ( InputItems :: START ) , 500 , 370 , 0 ) ; helpfont -> DrawString ( 554 , 370 + textoff , " Start " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; } al_draw_bitmap ( Input :: GetIcon ( InputItems :: SELECT ) , 500 , 420 , 0 ) ; helpfont -> DrawString ( 554 , 420 + textoff , " Quit " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; } bool GameLobbyStage :: IsTransition ( ) { return false ; } void GameLobbyStage :: RenderPlayerSlot ( bool BlueTeam , int Index , int X , int Y ) { ButtonColours :: Colours colour = ButtonColours :: WHITE ; bool btnup = false ; PlayerInfo * p = ( BlueTeam ? currentinfo -> BlueTeam [ Index ] : currentinfo -> RedTeam [ Index ] ) ; if ( p != nullptr ) { colour = ( BlueTeam ? ButtonColours :: BLUE : ButtonColours :: RED ) ; } if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { if ( selection == Index && selectionteamisblue == BlueTeam ) { colour = ButtonColours :: YELLOW ; btnup = true ; } } GameResources :: DrawButton ( colour , btnup , X , Y , 23 , 3 ) ; if ( p != nullptr ) { helpfont -> DrawString ( X + 184 , Y + 24 - ( helpfont -> GetFontHeight ( ) / 2 ) + ( ! btnup ? 4 : 0 ) , p -> Name , FontHAlign :: CENTRE , al_map_rgb ( 0 , 0 , 0 ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="kyoungchinseo/aws-sdk-cpp/tree/master/aws-cpp-sdk-s3/source/model/Delete.cpp"> # include < aws / s3 / model / Delete . h > # include < aws / core / utils / xml / XmlSerializer . h > # include < aws / core / utils / StringUtils . h > # include < aws / core / utils / memory / stl / AWSStringStream . h > # include < utility > using namespace Aws :: S3 :: Model ; using namespace Aws :: Utils :: Xml ; using namespace Aws :: Utils ; Delete :: Delete ( ) : m_objectsHasBeenSet ( false ) , m_quiet ( false ) , m_quietHasBeenSet ( false ) { } Delete :: Delete ( const XmlNode & xmlNode ) : m_objectsHasBeenSet ( false ) , m_quiet ( false ) , m_quietHasBeenSet ( false ) { * this = xmlNode ; } Delete & Delete :: operator = ( const XmlNode & xmlNode ) { XmlNode resultNode = xmlNode ; if ( ! resultNode . IsNull ( ) ) { XmlNode objectsNode = resultNode . FirstChild ( " Objects " ) ; if ( ! objectsNode . IsNull ( ) ) { XmlNode objectsMember = objectsNode ; while ( ! objectsMember . IsNull ( ) ) { m_objects . push_back ( objectsMember ) ; objectsMember = objectsMember . NextNode ( " Object " ) ; } m_objectsHasBeenSet = true ; } XmlNode quietNode = resultNode . FirstChild ( " Quiet " ) ; if ( quietNode . IsNull ( ) ) { quietNode = resultNode ; } if ( ! quietNode . IsNull ( ) ) { m_quiet = StringUtils :: ConvertToBool ( StringUtils :: Trim ( quietNode . GetText ( ) . c_str ( ) ) . c_str ( ) ) ; m_quietHasBeenSet = true ; } } return * this ; } void Delete :: AddToNode ( XmlNode & parentNode ) const { Aws :: StringStream ss ; if ( m_objectsHasBeenSet ) { for ( const auto & item : m_objects ) { XmlNode objectsNode = parentNode . CreateChildElement ( " Object " ) ; item . AddToNode ( objectsNode ) ; } } if ( m_quietHasBeenSet ) { XmlNode quietNode = parentNode . CreateChildElement ( " Object " ) ; ss << m_quiet ; quietNode . SetText ( ss . str ( ) ) ; ss . str ( " " ) ; } } </DOCUMENT>
<DOCUMENT_ID="attilahorvath/phantomjs/tree/master/src/qt/qtwebkit/Source/JavaScriptCore/llint/LLIntEntrypoints.cpp"> # include " config . h " # include " LLIntEntrypoints . h " # if ENABLE ( LLINT ) # include " JITCode . h " # include " VM . h " # include " JSObject . h " # include " LLIntThunks . h " # include " LowLevelInterpreter . h " namespace JSC { namespace LLInt { void getFunctionEntrypoint ( VM & vm , CodeSpecializationKind kind , JITCode & jitCode , MacroAssemblerCodePtr & arityCheck ) { if ( ! vm . canUseJIT ( ) ) { if ( kind == CodeForCall ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_function_for_call_prologue ) , JITCode :: InterpreterThunk ) ; arityCheck = MacroAssemblerCodePtr :: createLLIntCodePtr ( llint_function_for_call_arity_check ) ; return ; } ASSERT ( kind == CodeForConstruct ) ; jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_function_for_construct_prologue ) , JITCode :: InterpreterThunk ) ; arityCheck = MacroAssemblerCodePtr :: createLLIntCodePtr ( llint_function_for_construct_arity_check ) ; return ; } # if ENABLE ( JIT ) if ( kind == CodeForCall ) { jitCode = JITCode ( vm . getCTIStub ( functionForCallEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; arityCheck = vm . getCTIStub ( functionForCallArityCheckThunkGenerator ) . code ( ) ; return ; } ASSERT ( kind == CodeForConstruct ) ; jitCode = JITCode ( vm . getCTIStub ( functionForConstructEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; arityCheck = vm . getCTIStub ( functionForConstructArityCheckThunkGenerator ) . code ( ) ; # endif } void getEvalEntrypoint ( VM & vm , JITCode & jitCode ) { if ( ! vm . canUseJIT ( ) ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_eval_prologue ) , JITCode :: InterpreterThunk ) ; return ; } # if ENABLE ( JIT ) jitCode = JITCode ( vm . getCTIStub ( evalEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; # endif } void getProgramEntrypoint ( VM & vm , JITCode & jitCode ) { if ( ! vm . canUseJIT ( ) ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_program_prologue ) , JITCode :: InterpreterThunk ) ; return ; } # if ENABLE ( JIT ) jitCode = JITCode ( vm . getCTIStub ( programEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; # endif } } } # endif </DOCUMENT>
<DOCUMENT_ID="arangodb/arangodb/tree/master/3rdParty/boost/1.71.0/libs/hana/example/chain.cpp"> # include < boost / hana / assert . hpp > # include < boost / hana / chain . hpp > # include < boost / hana / config . hpp > # include < boost / hana / equal . hpp > # include < boost / hana / optional . hpp > namespace hana = boost :: hana ; BOOST_HANA_CONSTEXPR_LAMBDA auto deref = [ ] ( auto x ) -> decltype ( * x ) { return * x ; } ; BOOST_HANA_CONSTEXPR_LAMBDA auto age = [ ] ( auto x ) -> decltype ( x . age ) { return x . age ; } ; BOOST_HANA_CONSTEXPR_LAMBDA auto f = [ ] ( auto x ) { return hana :: chain ( hana :: sfinae ( deref ) ( x ) , hana :: sfinae ( age ) ) ; } ; struct Person { unsigned int age ; } ; int main ( ) { constexpr Person john { 30 } ; BOOST_HANA_CONSTANT_CHECK ( f ( john ) == hana :: nothing ) ; BOOST_HANA_CONSTANT_CHECK ( f ( 1 ) == hana :: nothing ) ; BOOST_HANA_CONSTEXPR_CHECK ( f ( & john ) == hana :: just ( 30u ) ) ; } </DOCUMENT>
<DOCUMENT_ID="jerrys123111/pcsx2/tree/master/plugins/GSdx_legacy/linux_replay.cpp"> # include " stdafx . h " # include < dlfcn . h > static void * handle ; void help ( ) { fprintf ( stderr , " Loader ▁ gs ▁ file \n " ) ; fprintf ( stderr , " ARG1 ▁ GSdx ▁ plugin \n " ) ; fprintf ( stderr , " ARG2 ▁ . gs ▁ file \n " ) ; fprintf ( stderr , " ARG3 ▁ Ini ▁ directory \n " ) ; if ( handle ) { dlclose ( handle ) ; } exit ( 1 ) ; } char * read_env ( const char * var ) { char * v = getenv ( var ) ; if ( ! v ) { fprintf ( stderr , " Failed ▁ to ▁ get ▁ % s \n " , var ) ; help ( ) ; } return v ; } int main ( int argc , char * argv [ ] ) { if ( argc < 1 ) help ( ) ; char * plugin ; char * gs ; if ( argc > 2 ) { plugin = argv [ 1 ] ; gs = argv [ 2 ] ; } else { plugin = read_env ( " GSDUMP _ SO " ) ; gs = argv [ 1 ] ; } handle = dlopen ( plugin , RTLD_LAZY | RTLD_GLOBAL ) ; if ( handle == NULL ) { fprintf ( stderr , " Failed ▁ to ▁ dlopen ▁ plugin ▁ % s \n " , plugin ) ; help ( ) ; } __attribute__ ( ( stdcall ) ) void ( * GSsetSettingsDir_ptr ) ( const char * ) ; __attribute__ ( ( stdcall ) ) void ( * GSReplay_ptr ) ( char * , int ) ; * ( void * * ) ( & GSsetSettingsDir_ptr ) = dlsym ( handle , " GSsetSettingsDir " ) ; * ( void * * ) ( & GSReplay_ptr ) = dlsym ( handle , " GSReplay " ) ; if ( argc == 2 ) { char * ini = read_env ( " GSDUMP _ CONF " ) ; GSsetSettingsDir_ptr ( ini ) ; } else if ( argc == 4 ) { ( void ) GSsetSettingsDir_ptr ( argv [ 3 ] ) ; } else if ( argc == 3 ) { # ifdef XDG_STD char * val = read_env ( " HOME " ) ; std :: string ini_dir ( val ) ; ini_dir += " / . config / pcsx2 / inis " ; GSsetSettingsDir_ptr ( ini_dir . c_str ( ) ) ; # else fprintf ( stderr , " default ▁ ini ▁ dir ▁ only ▁ supported ▁ on ▁ XDG \n " ) ; help ( ) ; # endif } GSReplay_ptr ( gs , 12 ) ; if ( handle ) { dlclose ( handle ) ; } } </DOCUMENT>
<DOCUMENT_ID="lunastorm/wissbi/tree/master/3rd_party/libcxx/test/strings/basic.string/string.modifiers/string_append/pointer.pass.cpp"> # include < string > # include < stdexcept > # include < cassert > template < class S > void test ( S s , const typename S :: value_type * str , S expected ) { s . append ( str ) ; assert ( s . __invariants ( ) ) ; assert ( s == expected ) ; } int main ( ) { typedef std :: string S ; test ( S ( ) , " " , S ( ) ) ; test ( S ( ) , "12345" , S ( "12345" ) ) ; test ( S ( ) , "12345678901234567890" , S ( "12345678901234567890" ) ) ; test ( S ( "12345" ) , " " , S ( "12345" ) ) ; test ( S ( "12345" ) , "12345" , S ( "1234512345" ) ) ; test ( S ( "12345" ) , "1234567890" , S ( "123451234567890" ) ) ; test ( S ( "12345678901234567890" ) , " " , S ( "12345678901234567890" ) ) ; test ( S ( "12345678901234567890" ) , "12345" , S ( "1234567890123456789012345" ) ) ; test ( S ( "12345678901234567890" ) , "12345678901234567890" , S ( "1234567890123456789012345678901234567890" ) ) ; } </DOCUMENT>
<DOCUMENT_ID="GreenDamTan/ppsspp/tree/master/Core/MIPS/x86/Asm.cpp"> # include " math / math _ util . h " # include " ABI . h " # include " x64Emitter . h " # include " Core / Core . h " # include " Core / MemMap . h " # include " Core / System . h " # include " Core / MIPS / MIPS . h " # include " Core / CoreTiming . h " # include " Common / MemoryUtil . h " # include " Core / MIPS / JitCommon / JitCommon . h " # include " Core / MIPS / x86 / Asm . h " # include " Core / MIPS / x86 / Jit . h " using namespace Gen ; using namespace X64JitConstants ; static bool enableDebug = false ; extern volatile CoreState coreState ; void ImHere ( ) { DEBUG_LOG ( CPU , " JIT ▁ Here : ▁ % 08x " , currentMIPS -> pc ) ; } void AsmRoutineManager :: Generate ( MIPSState * mips , MIPSComp :: Jit * jit , MIPSComp :: JitOptions * jo ) { enterCode = AlignCode16 ( ) ; ABI_PushAllCalleeSavedRegsAndAdjustStack ( ) ; # ifdef _M_X64 MOV ( 64 , R ( MEMBASEREG ) , ImmPtr ( Memory :: base ) ) ; uintptr_t jitbase = ( uintptr_t ) jit -> GetBasePtr ( ) ; if ( jitbase > 0x7FFFFFFFULL ) { MOV ( 64 , R ( JITBASEREG ) , ImmPtr ( jit -> GetBasePtr ( ) ) ) ; jo -> reserveR15ForAsm = true ; } # endif MOV ( PTRBITS , R ( CTXREG ) , ImmPtr ( & mips -> f [ 0 ] ) ) ; outerLoop = GetCodePtr ( ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_CallFunction ( reinterpret_cast < void * > ( & CoreTiming :: Advance ) ) ; jit -> ApplyRoundingMode ( true , this ) ; FixupBranch skipToRealDispatch = J ( ) ; dispatcherCheckCoreState = GetCodePtr ( ) ; FixupBranch bailCoreState = J_CC ( CC_S , true ) ; CMP ( 32 , M ( & coreState ) , Imm32 ( 0 ) ) ; FixupBranch badCoreState = J_CC ( CC_NZ , true ) ; FixupBranch skipToRealDispatch2 = J ( ) ; dispatcher = GetCodePtr ( ) ; FixupBranch bail = J_CC ( CC_S , true ) ; SetJumpTarget ( skipToRealDispatch ) ; SetJumpTarget ( skipToRealDispatch2 ) ; dispatcherNoCheck = GetCodePtr ( ) ; MOV ( 32 , R ( EAX ) , M ( & mips -> pc ) ) ; dispatcherInEAXNoCheck = GetCodePtr ( ) ; # ifdef _M_IX86 AND ( 32 , R ( EAX ) , Imm32 ( Memory :: MEMVIEW32_MASK ) ) ; _assert_msg_ ( CPU , Memory :: base != 0 , " Memory ▁ base ▁ bogus " ) ; MOV ( 32 , R ( EAX ) , MDisp ( EAX , ( u32 ) Memory :: base ) ) ; # elif _M_X64 MOV ( 32 , R ( EAX ) , MComplex ( MEMBASEREG , RAX , SCALE_1 , 0 ) ) ; # endif MOV ( 32 , R ( EDX ) , R ( EAX ) ) ; _assert_msg_ ( JIT , MIPS_JITBLOCK_MASK == 0xFF000000 , " Hardcoded ▁ assumption ▁ of ▁ emuhack ▁ mask " ) ; SHR ( 32 , R ( EDX ) , Imm8 ( 24 ) ) ; CMP ( 32 , R ( EDX ) , Imm8 ( MIPS_EMUHACK_OPCODE >> 24 ) ) ; FixupBranch notfound = J_CC ( CC_NE ) ; if ( enableDebug ) { ADD ( 32 , M ( & mips -> debugCount ) , Imm8 ( 1 ) ) ; } AND ( 32 , R ( EAX ) , Imm32 ( MIPS_EMUHACK_VALUE_MASK ) ) ; # ifdef _M_IX86 ADD ( 32 , R ( EAX ) , ImmPtr ( jit -> GetBasePtr ( ) ) ) ; # elif _M_X64 if ( jo -> reserveR15ForAsm ) ADD ( 64 , R ( RAX ) , R ( JITBASEREG ) ) ; else ADD ( 64 , R ( EAX ) , Imm32 ( jitbase ) ) ; # endif JMPptr ( R ( EAX ) ) ; SetJumpTarget ( notfound ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_CallFunction ( & MIPSComp :: JitAt ) ; jit -> ApplyRoundingMode ( true , this ) ; JMP ( dispatcherNoCheck , true ) ; SetJumpTarget ( bail ) ; SetJumpTarget ( bailCoreState ) ; CMP ( 32 , M ( & coreState ) , Imm32 ( 0 ) ) ; J_CC ( CC_Z , outerLoop , true ) ; SetJumpTarget ( badCoreState ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_PopAllCalleeSavedRegsAndAdjustStack ( ) ; RET ( ) ; breakpointBailout = GetCodePtr ( ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_PopAllCalleeSavedRegsAndAdjustStack ( ) ; RET ( ) ; } </DOCUMENT>
<DOCUMENT_ID="tectronics/mysql-parallel-replication/tree/master/extra/yassl/taocrypt/src/hash.cpp"> # include " runtime . hpp " # include < string . h > # include < assert . h > # include " hash . hpp " namespace TaoCrypt { HASHwithTransform :: HASHwithTransform ( word32 digSz , word32 buffSz ) { assert ( digSz <= MaxDigestSz ) ; assert ( buffSz <= MaxBufferSz ) ; } void HASHwithTransform :: AddLength ( word32 len ) { HashLengthType tmp = loLen_ ; if ( ( loLen_ += len ) < tmp ) hiLen_ ++ ; hiLen_ += SafeRightShift < 8 * sizeof ( HashLengthType ) > ( len ) ; } void HASHwithTransform :: Update ( const byte * data , word32 len ) { word32 blockSz = getBlockSize ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; while ( len ) { word32 add = min ( len , blockSz - buffLen_ ) ; memcpy ( & local [ buffLen_ ] , data , add ) ; buffLen_ += add ; data += add ; len -= add ; if ( buffLen_ == blockSz ) { ByteReverseIf ( local , local , blockSz , getByteOrder ( ) ) ; Transform ( ) ; AddLength ( blockSz ) ; buffLen_ = 0 ; } } } void HASHwithTransform :: Final ( byte * hash ) { word32 blockSz = getBlockSize ( ) ; word32 digestSz = getDigestSize ( ) ; word32 padSz = getPadSize ( ) ; ByteOrder order = getByteOrder ( ) ; AddLength ( buffLen_ ) ; HashLengthType preLoLen = GetBitCountLo ( ) ; HashLengthType preHiLen = GetBitCountHi ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; local [ buffLen_ ++ ] = 0x80 ; if ( buffLen_ > padSz ) { memset ( & local [ buffLen_ ] , 0 , blockSz - buffLen_ ) ; buffLen_ += blockSz - buffLen_ ; ByteReverseIf ( local , local , blockSz , order ) ; Transform ( ) ; buffLen_ = 0 ; } memset ( & local [ buffLen_ ] , 0 , padSz - buffLen_ ) ; ByteReverseIf ( local , local , blockSz , order ) ; memcpy ( & local [ padSz ] , order ? & preHiLen : & preLoLen , sizeof ( preLoLen ) ) ; memcpy ( & local [ padSz + 4 ] , order ? & preLoLen : & preHiLen , sizeof ( preLoLen ) ) ; Transform ( ) ; ByteReverseIf ( digest_ , digest_ , digestSz , order ) ; memcpy ( hash , digest_ , digestSz ) ; Init ( ) ; } # ifdef WORD64_AVAILABLE HASH64withTransform :: HASH64withTransform ( word32 digSz , word32 buffSz ) { assert ( digSz <= MaxDigestSz ) ; assert ( buffSz <= MaxBufferSz ) ; } void HASH64withTransform :: AddLength ( word32 len ) { HashLengthType tmp = loLen_ ; if ( ( loLen_ += len ) < tmp ) hiLen_ ++ ; hiLen_ += SafeRightShift < 8 * sizeof ( HashLengthType ) > ( len ) ; } void HASH64withTransform :: Update ( const byte * data , word32 len ) { word32 blockSz = getBlockSize ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; while ( len ) { word32 add = min ( len , blockSz - buffLen_ ) ; memcpy ( & local [ buffLen_ ] , data , add ) ; buffLen_ += add ; data += add ; len -= add ; if ( buffLen_ == blockSz ) { ByteReverseIf ( buffer_ , buffer_ , blockSz , getByteOrder ( ) ) ; Transform ( ) ; AddLength ( blockSz ) ; buffLen_ = 0 ; } } } void HASH64withTransform :: Final ( byte * hash ) { word32 blockSz = getBlockSize ( ) ; word32 digestSz = getDigestSize ( ) ; word32 padSz = getPadSize ( ) ; ByteOrder order = getByteOrder ( ) ; AddLength ( buffLen_ ) ; HashLengthType preLoLen = GetBitCountLo ( ) ; HashLengthType preHiLen = GetBitCountHi ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; local [ buffLen_ ++ ] = 0x80 ; if ( buffLen_ > padSz ) { memset ( & local [ buffLen_ ] , 0 , blockSz - buffLen_ ) ; buffLen_ += blockSz - buffLen_ ; ByteReverseIf ( buffer_ , buffer_ , blockSz , order ) ; Transform ( ) ; buffLen_ = 0 ; } memset ( & local [ buffLen_ ] , 0 , padSz - buffLen_ ) ; ByteReverseIf ( buffer_ , buffer_ , padSz , order ) ; buffer_ [ blockSz / sizeof ( word64 ) - 2 ] = order ? preHiLen : preLoLen ; buffer_ [ blockSz / sizeof ( word64 ) - 1 ] = order ? preLoLen : preHiLen ; Transform ( ) ; ByteReverseIf ( digest_ , digest_ , digestSz , order ) ; memcpy ( hash , digest_ , digestSz ) ; Init ( ) ; } # endif } </DOCUMENT>
<DOCUMENT_ID="jbrains/trivia/tree/master/C++/GameRunner.cpp"> # include < stdlib . h > # include " Game . h " static bool notAWinner ; int main ( ) { Game aGame ; aGame . add ( " Chet " ) ; aGame . add ( " Pat " ) ; aGame . add ( " Sue " ) ; do { aGame . roll ( rand ( ) % 5 + 1 ) ; if ( rand ( ) % 9 == 7 ) { notAWinner = aGame . wrongAnswer ( ) ; } else { notAWinner = aGame . wasCorrectlyAnswered ( ) ; } } while ( notAWinner ) ; } </DOCUMENT>
<DOCUMENT_ID="naucoin/CTK/tree/master/Libs/Widgets/Testing/Cpp/ctkExampleUseOfWorkflowWidgetUsingSignalsAndSlots.cpp"> # include < QApplication > # include < QTimer > # include " ctkWorkflow . h " # include " ctkWorkflowTabWidget . h " # include " ctkWorkflowWidgetStep . h " # include " ctkWorkflowGroupBox . h " # include " ctkExampleWorkflowWidgetStepUsingSignalsAndSlots . h " # include < cstdlib > # include < iostream > int ctkExampleUseOfWorkflowWidgetUsingSignalsAndSlots ( int argc , char * argv [ ] ) { QApplication app ( argc , argv ) ; bool hideWidgets = false ; ctkWorkflow * workflow = new ctkWorkflow ; ctkWorkflowTabWidget * workflowWidget = new ctkWorkflowTabWidget ; workflowWidget -> setWorkflow ( workflow ) ; ctkWorkflowGroupBox * groupBox = workflowWidget -> workflowGroupBox ( ) ; groupBox -> setPreText ( " I ▁ am ▁ some ▁ pre - text " ) ; groupBox -> setPostText ( " I ▁ am ▁ some ▁ post - text " ) ; groupBox -> setHideWidgetsOfNonCurrentSteps ( hideWidgets ) ; ctkWorkflowWidgetStep * testStep1 = new ctkWorkflowWidgetStep ( " Step ▁ 1" ) ; testStep1 -> setName ( " Step ▁ 1" ) ; testStep1 -> setDescription ( " I ▁ am ▁ in ▁ step ▁ 1" ) ; workflowWidget -> associateStepWithLabel ( testStep1 , " name ▁ 1" ) ; ctkWorkflowWidgetStep * testStep2 = new ctkWorkflowWidgetStep ( " Step ▁ 2" ) ; testStep2 -> setName ( " Step ▁ 2" ) ; testStep2 -> setDescription ( " I ▁ am ▁ in ▁ step ▁ 2" ) ; workflowWidget -> associateStepWithLabel ( testStep2 , " name ▁ 2" ) ; ctkWorkflowWidgetStep * testStep3 = new ctkWorkflowWidgetStep ( " Step ▁ 3" ) ; testStep3 -> setName ( " Step ▁ 3" ) ; testStep3 -> setDescription ( " I ▁ am ▁ in ▁ step ▁ 3" ) ; workflowWidget -> associateStepWithPage ( testStep3 , 1 , " name ▁ 3" ) ; workflow -> addTransition ( testStep1 , testStep2 ) ; workflow -> addTransition ( testStep2 , testStep3 ) ; ctkExampleWorkflowWidgetStepUsingSignalsAndSlots * qObject1 = new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots ( testStep1 ) ; ctkExampleWorkflowWidgetStepUsingSignalsAndSlots * qObject2 = new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots ( testStep2 ) ; ctkExampleWorkflowWidgetStepUsingSignalsAndSlots * qObject3 = new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots ( testStep3 ) ; qObject1 -> setWidget ( testStep1 -> stepArea ( ) ) ; qObject2 -> setWidget ( testStep2 -> stepArea ( ) ) ; qObject3 -> setWidget ( testStep3 -> stepArea ( ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeValidateCommand ( QString ) ) , qObject1 , SLOT ( validate ( QString ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeValidateCommand ( QString ) ) , qObject2 , SLOT ( validate ( QString ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeValidateCommand ( QString ) ) , qObject3 , SLOT ( validate ( QString ) ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnEntryCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject1 , SLOT ( onEntry ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnEntryCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject2 , SLOT ( onEntry ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnEntryCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject3 , SLOT ( onEntry ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnExitCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject1 , SLOT ( onExit ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnExitCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject2 , SLOT ( onExit ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnExitCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject3 , SLOT ( onExit ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeCreateUserInterfaceCommand ( ) ) , qObject1 , SLOT ( createUserInterface ( ) ) ) ; QObject :: connect ( qObject1 , SIGNAL ( createUserInterfaceComplete ( ) ) , testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( showUserInterfaceComplete ( ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeCreateUserInterfaceCommand ( ) ) , qObject2 , SLOT ( createUserInterface ( ) ) ) ; QObject :: connect ( qObject2 , SIGNAL ( createUserInterfaceComplete ( ) ) , testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( showUserInterfaceComplete ( ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeCreateUserInterfaceCommand ( ) ) , qObject3 , SLOT ( createUserInterface ( ) ) ) ; QObject :: connect ( qObject3 , SIGNAL ( createUserInterfaceComplete ( ) ) , testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( showUserInterfaceComplete ( ) ) ) ; testStep1 -> setHasValidateCommand ( 1 ) ; testStep1 -> setHasOnEntryCommand ( 1 ) ; testStep1 -> setHasOnExitCommand ( 1 ) ; testStep1 -> setHasCreateUserInterfaceCommand ( 1 ) ; testStep2 -> setHasValidateCommand ( 1 ) ; testStep2 -> setHasOnEntryCommand ( 1 ) ; testStep2 -> setHasOnExitCommand ( 1 ) ; testStep2 -> setHasCreateUserInterfaceCommand ( 1 ) ; testStep3 -> setHasValidateCommand ( 1 ) ; testStep3 -> setHasOnEntryCommand ( 1 ) ; testStep3 -> setHasOnExitCommand ( 1 ) ; testStep3 -> setHasCreateUserInterfaceCommand ( 1 ) ; workflow -> setInitialStep ( testStep1 ) ; workflow -> start ( ) ; workflowWidget -> show ( ) ; QTimer :: singleShot ( 500 , & app , SLOT ( quit ( ) ) ) ; app . exec ( ) ; workflow -> stop ( ) ; QTimer :: singleShot ( 100 , & app , SLOT ( quit ( ) ) ) ; app . exec ( ) ; delete workflowWidget ; return EXIT_SUCCESS ; } </DOCUMENT>
<DOCUMENT_ID="rexim/beatwave/tree/master/test/core/testanimated.cpp"> # define CATCH_CONFIG_MAIN # include < catch . hpp > # include < core / animated . hpp > TEST_CASE ( " Animating ▁ object ▁ with ▁ nullptr ▁ should ▁ not ▁ crash ▁ the ▁ app " , " [ animated ] " ) { Animated < int > x ( 10 ) ; x . animate ( nullptr ) ; } </DOCUMENT>
<DOCUMENT_ID="ChameleonOS/android_external_skia/tree/master/tests/PathOpsAngleTest.cpp"> # include " PathOpsTestCommon . h " # include " SkOpSegment . h " # include " SkTArray . h " # include " Test . h " static const SkPoint cubics [ ] [ 4 ] = { { { 0 , 1 } , { 2 , 6 } , { 4 , 2 } , { 5 , 3 } } , { { 10 , 234 } , { 10 , 229.581726f } , { 13.5817204f , 226 } , { 18 , 226 } } , { { 132 , 11419 } , { 130.89543151855469f , 11419 } , { 130 , 11418.1044921875f } , { 130 , 11417 } } , { { 130.04275512695312f , 11417.4130859375f } , { 130.23307800292969f , 11418.3193359375f } , { 131.03709411621094f , 11419 } , { 132 , 11419 } } , { { 0 , 1 } , { 0 , 5 } , { 4 , 1 } , { 6 , 4 } } , { { 1 , 5 } , { 4 , 6 } , { 1 , 0 } , { 4 , 0 } } , { { 0 , 1 } , { 0 , 4 } , { 5 , 1 } , { 6 , 4 } } , { { 0 , 1 } , { 1 , 2 } , { 1 , 0 } , { 6 , 1 } } , { { 0 , 3 } , { 0 , 1 } , { 2 , 0 } , { 1 , 0 } } , { { 189 , 7 } , { 189 , 5.3431458473205566f } , { 190.3431396484375f , 4 } , { 192 , 4 } } , { { 0 , 1 } , { 1 , 3 } , { 1 , 0 } , { 6 , 4 } } , { { 0 , 1 } , { 2 , 3 } , { 2 , 1 } , { 4 , 3 } } , { { 1 , 2 } , { 3 , 4 } , { 1 , 0 } , { 3 , 2 } } , { { 0 , 1 } , { 4 , 6 } , { 4 , 3 } , { 5 , 4 } } , { { 806 , 11419 } , { 806.962890625f , 11419 } , { 807.76690673828125f , 11418.3193359375f } , { 807.957275390625f , 11417.4130859375f } } , { { 808 , 11417 } , { 808 , 11418.1044921875f } , { 807.10455322265625f , 11419 } , { 806 , 11419 } } , { { 132 , 11419 } , { 130.89543151855469f , 11419 } , { 130 , 11418.1044921875f } , { 130 , 11417 } } , { { 130.04275512695312f , 11417.4130859375f } , { 130.23312377929687f , 11418.3193359375f } , { 131.03707885742187f , 11419 } , { 132 , 11419 } } , { { 1006.6951293945312f , 291 } , { 1023.263671875f , 291 } , { 1033.8402099609375f , 304.43145751953125f } , { 1030.318359375f , 321 } } , } ; static const SkPoint quads [ ] [ 3 ] = { { { 12.3423996f , 228.342407f } , { 10 , 230.686295f } , { 10 , 234 } } , { { 304.24319458007812f , 591.75677490234375f } , { 306 , 593.51470947265625f } , { 306 , 596 } } , { { 0 , 0 } , { 3 , 1 } , { 0 , 3 } } , { { 0 , 1 } , { 3 , 1 } , { 0 , 2 } } , } ; static const SkPoint lines [ ] [ 2 ] = { { { 6 , 2 } , { 2 , 4 } } , { { 306 , 617 } , { 306 , 590 } } , { { 306 , 596 } , { 306 , 617 } } , { { 6 , 4 } , { 0 , 1 } } , { { 6 , 1 } , { 0 , 1 } } , { { 1 , 0 } , { 0 , 3 } } , { { 246 , 4 } , { 189 , 4 } } , { { 192 , 4 } , { 243 , 4 } } , { { 4 , 3 } , { 0 , 1 } } , { { 3 , 2 } , { 1 , 2 } } , { { 6 , 4 } , { 3 , 4 } } , { { 979.30487060546875f , 561 } , { 1036.695068359375f , 291 } } , } ; struct SortSet { const SkPoint * ptData ; int ptCount ; double tStart ; double tEnd ; SkPoint endPt ; } ; static const SortSet set1 [ ] = { { cubics [ 0 ] , 4 , 0.66666987081928919 , 0.875 , { 0 , 0 } } , { lines [ 0 ] , 2 , 0.574070336 , 0.388888889 , { 0 , 0 } } , { cubics [ 0 ] , 4 , 0.66666987081928919 , 0.4050371120499307 , { 0 , 0 } } , { lines [ 0 ] , 2 , 0.574070336 , 0.9140625 , { 0 , 0 } } , } ; static const SortSet set1a [ ] = { { cubics [ 0 ] , 4 , 0.666666667 , 0.405037112 , { 4.58007812f , 2.83203125f } } , { lines [ 0 ] , 2 , 0.574074074 , 0.9140625 , { 4.44444466f , 2.77777767f } } , } ; static const SortSet set2 [ ] = { { cubics [ 0 ] , 4 , 0.666666667 , 0.875 , { 0 , 0 } } , { lines [ 0 ] , 2 , 0.574074074 , 0.388888889 , { 0 , 0 } } , { cubics [ 0 ] , 4 , 0.666666667 , 0.405037112 , { 0 , 0 } } , { lines [ 0 ] , 2 , 0.574074074 , 0.9140625 , { 0 , 0 } } , } ; static const SortSet set3 [ ] = { { cubics [ 1 ] , 4 , 0 , 1 , { 0 , 0 } } , { quads [ 0 ] , 3 , 1 , 0 , { 0 , 0 } } , } ; static const SortSet set4 [ ] = { { cubics [ 2 ] , 4 , 0.812114222 , 1 , { 0 , 0 } } , { cubics [ 3 ] , 4 , 0.0684734759 , 0 , { 0 , 0 } } , } ; static const SortSet set5 [ ] = { { lines [ 1 ] , 2 , 0.777777778 , 1 , { 0 , 0 } } , { quads [ 1 ] , 3 , 1 , 4.34137342e - 06 , { 0 , 0 } } , { lines [ 2 ] , 2 , 0 , 1 , { 0 , 0 } } , } ; static const SortSet set5a [ ] = { { lines [ 1 ] , 2 , 0.777777778 , 1 , { 306 , 590 } } , { quads [ 1 ] , 3 , 1 , 4.34137342e - 06 , { 304.243195f , 591.756775f } } , { lines [ 2 ] , 2 , 0 , 1 , { 306 , 617 } } , } ; static const SortSet set6 [ ] = { { lines [ 3 ] , 2 , 0.407407407 , 0.554627832 , { 0 , 0 } } , { cubics [ 4 ] , 4 , 0.666666667 , 0.548022446 , { 0 , 0 } } , { lines [ 3 ] , 2 , 0.407407407 , 0 , { 0 , 0 } } , { cubics [ 4 ] , 4 , 0.666666667 , 1 , { 0 , 0 } } , } ; static const SortSet set6a [ ] = { { lines [ 3 ] , 2 , 0.407407407 , 0.554627832 , { 2.6722331f , 2.33611655f } } , { cubics [ 4 ] , 4 , 0.666666667 , 0.548022446 , { 2.61642241f , 2.83718514f } } , { lines [ 3 ] , 2 , 0.407407407 , 0 , { 6 , 4 } } , { cubics [ 4 ] , 4 , 0.666666667 , 1 , { 6 , 4 } } , } ; static const SortSet set7 [ ] = { { cubics [ 5 ] , 4 , 0.545233342 , 0.545454545 , { 0 , 0 } } , { cubics [ 6 ] , 4 , 0.484938134 , 0.484805744 , { 0 , 0 } } , { cubics [ 5 ] , 4 , 0.545233342 , 0 , { 0 , 0 } } , { cubics [ 6 ] , 4 , 0.484938134 , 0.545454545 , { 0 , 0 } } , } ; static const SortSet set8 [ ] = { { cubics [ 7 ] , 4 , 0.5 , 0.522986744 , { 0 , 0 } } , { lines [ 4 ] , 2 , 0.75 , 1 , { 0 , 0 } } , { cubics [ 7 ] , 4 , 0.5 , 0 , { 0 , 0 } } , { lines [ 4 ] , 2 , 0.75 , 0.737654321 , { 0 , 0 } } , } ; static const SortSet set8a [ ] = { { cubics [ 7 ] , 4 , 0.5 , 0.522986744 , { 1.60668361f , 0.965592742f } } , { lines [ 4 ] , 2 , 0.75 , 1 , { 0 , 1 } } , { cubics [ 7 ] , 4 , 0.5 , 0 , { 0 , 1 } } , { lines [ 4 ] , 2 , 0.75 , 0.737654321 , { 1.57407403f , 1 } } , } ; static const SortSet set9 [ ] = { { cubics [ 8 ] , 4 , 0.4 , 1 , { 0 , 0 } } , { lines [ 5 ] , 2 , 0.36 , 0 , { 0 , 0 } } , { cubics [ 8 ] , 4 , 0.4 , 0.394675838 , { 0 , 0 } } , { lines [ 5 ] , 2 , 0.36 , 0.363999782 , { 0 , 0 } } , } ; static const SortSet set10 [ ] = { { lines [ 6 ] , 2 , 0.947368421 , 1 , { 0 , 0 } } , { cubics [ 9 ] , 4 , 1 , 0.500000357 , { 0 , 0 } } , { lines [ 7 ] , 2 , 0 , 1 , { 0 , 0 } } , } ; static const SortSet set11 [ ] = { { lines [ 3 ] , 2 , 0.75 , 1 , { 0 , 0 } } , { cubics [ 10 ] , 4 , 0.5 , 0.228744269 , { 0 , 0 } } , { lines [ 3 ] , 2 , 0.75 , 0.627112191 , { 0 , 0 } } , { cubics [ 10 ] , 4 , 0.5 , 0.6339746 , { 0 , 0 } } , } ; static const SortSet set12 [ ] = { { cubics [ 12 ] , 4 , 0.5 , 1 , { 0 , 0 } } , { lines [ 8 ] , 2 , 0.5 , 1 , { 0 , 0 } } , { cubics [ 11 ] , 4 , 0.5 , 0 , { 0 , 0 } } , { lines [ 9 ] , 2 , 0.5 , 1 , { 0 , 0 } } , { cubics [ 12 ] , 4 , 0.5 , 0 , { 0 , 0 } } , { lines [ 8 ] , 2 , 0.5 , 0 , { 0 , 0 } } , { cubics [ 11 ] , 4 , 0.5 , 1 , { 0 , 0 } } , { lines [ 9 ] , 2 , 0.5 , 0 , { 0 , 0 } } , } ; static const SortSet set13 [ ] = { { cubics [ 13 ] , 4 , 0.5 , 0.400631046 , { 0 , 0 } } , { lines [ 10 ] , 2 , 0.791666667 , 0.928 , { 0 , 0 } } , { lines [ 10 ] , 2 , 0.791666667 , 0.333333333 , { 0 , 0 } } , { cubics [ 13 ] , 4 , 0.5 , 0.866666667 , { 0 , 0 } } , } ; static const SortSet set14 [ ] = { { quads [ 2 ] , 3 , 0.5 , 0.310102051 , { 0 , 0 } } , { quads [ 3 ] , 3 , 0.5 , 0.2 , { 0 , 0 } } , { quads [ 3 ] , 3 , 0.5 , 0.770156212 , { 0 , 0 } } , { quads [ 2 ] , 3 , 0.5 , 0.7 , { 0 , 0 } } , } ; static const SortSet set15 [ ] = { { cubics [ 14 ] , 4 , 0.93081374 , 1 , { 0 , 0 } } , { cubics [ 15 ] , 4 , 0.188518131 , 0 , { 0 , 0 } } , { cubics [ 14 ] , 4 , 0.93081374 , 0 , { 0 , 0 } } , } ; static const SortSet set16 [ ] = { { cubics [ 17 ] , 4 , 0.0682619216 , 0 , { 130.042755f , 11417.4131f } } , { cubics [ 16 ] , 4 , 0.812302088 , 1 , { 130 , 11417 } } , { cubics [ 17 ] , 4 , 0.0682619216 , 1 , { 132 , 11419 } } , } ; static const SortSet set17 [ ] = { { lines [ 11 ] , 2 , 0.888889581 , 1 , { 0 , 0 } } , { cubics [ 18 ] , 4 , 0.999996241 , 0 , { 0 , 0 } } , { lines [ 11 ] , 2 , 0.888889581 , 0 , { 0 , 0 } } , { cubics [ 18 ] , 4 , 0.999996241 , 1 , { 0 , 0 } } , } ; struct SortSetTests { const char * name ; const SortSet * set ; size_t count ; SkPoint startPt ; } ; # define TEST_ENTRY ( name ) # name , name , SK_ARRAY_COUNT ( name ) static const SortSetTests tests [ ] = { { TEST_ENTRY ( set17 ) , { 0 , 0 } } , { TEST_ENTRY ( set16 ) , { 130.090179f , 11417.5957f } } , { TEST_ENTRY ( set14 ) , { 0 , 0 } } , { TEST_ENTRY ( set13 ) , { 0 , 0 } } , { TEST_ENTRY ( set12 ) , { 0 , 0 } } , { TEST_ENTRY ( set11 ) , { 0 , 0 } } , { TEST_ENTRY ( set10 ) , { 0 , 0 } } , { TEST_ENTRY ( set9 ) , { 0 , 0 } } , { TEST_ENTRY ( set6a ) , { 3.55555558f , 2.77777767f } } , { TEST_ENTRY ( set8a ) , { 1.5f , 1 } } , { TEST_ENTRY ( set8 ) , { 0 , 0 } } , { TEST_ENTRY ( set7 ) , { 0 , 0 } } , { TEST_ENTRY ( set6a ) , { 3.55555558f , 2.77777767f } } , { TEST_ENTRY ( set6 ) , { 0 , 0 } } , { TEST_ENTRY ( set5a ) , { 306 , 596 } } , { TEST_ENTRY ( set5 ) , { 0 , 0 } } , { TEST_ENTRY ( set3 ) , { 0 , 0 } } , { TEST_ENTRY ( set2 ) , { 0 , 0 } } , { TEST_ENTRY ( set1 ) , { 0 , 0 } } , } ; # undef TEST_ENTRY static void setup ( const SortSet * set , const size_t idx , SkOpSegment * seg , int * ts , const SkPoint & startPt ) { SkPoint start , end ; const SkPoint * data = set [ idx ] . ptData ; bool useIntersectPt = startPt . fX != 0 || startPt . fY != 0 ; if ( useIntersectPt ) { start = startPt ; end = set [ idx ] . endPt ; } switch ( set [ idx ] . ptCount ) { case 2 : { SkASSERT ( ValidPoints ( data , 2 ) ) ; seg -> addLine ( data , false , false ) ; SkDLine dLine ; dLine . set ( set [ idx ] . ptData ) ; SkASSERT ( ValidLine ( dLine ) ) ; if ( useIntersectPt ) { break ; } start = dLine . ptAtT ( set [ idx ] . tStart ) . asSkPoint ( ) ; end = dLine . ptAtT ( set [ idx ] . tEnd ) . asSkPoint ( ) ; } break ; case 3 : { SkASSERT ( ValidPoints ( data , 3 ) ) ; seg -> addQuad ( data , false , false ) ; SkDQuad dQuad ; dQuad . set ( set [ idx ] . ptData ) ; SkASSERT ( ValidQuad ( dQuad ) ) ; if ( useIntersectPt ) { break ; } start = dQuad . ptAtT ( set [ idx ] . tStart ) . asSkPoint ( ) ; end = dQuad . ptAtT ( set [ idx ] . tEnd ) . asSkPoint ( ) ; } break ; case 4 : { SkASSERT ( ValidPoints ( data , 4 ) ) ; seg -> addCubic ( data , false , false ) ; SkDCubic dCubic ; dCubic . set ( set [ idx ] . ptData ) ; SkASSERT ( ValidCubic ( dCubic ) ) ; if ( useIntersectPt ) { break ; } start = dCubic . ptAtT ( set [ idx ] . tStart ) . asSkPoint ( ) ; end = dCubic . ptAtT ( set [ idx ] . tEnd ) . asSkPoint ( ) ; } break ; } double tStart = set [ idx ] . tStart ; double tEnd = set [ idx ] . tEnd ; seg -> addT ( NULL , start , tStart ) ; seg -> addT ( NULL , end , tEnd ) ; if ( tStart != 0 && tEnd != 0 ) { seg -> addT ( NULL , set [ idx ] . ptData [ 0 ] , 0 ) ; } if ( tStart != 1 && tEnd != 1 ) { seg -> addT ( NULL , set [ idx ] . ptData [ set [ idx ] . ptCount - 1 ] , 1 ) ; } int tIndex = 0 ; ts [ 0 ] = 0 ; ts [ 1 ] = 1 ; do { if ( seg -> t ( tIndex ) == set [ idx ] . tStart ) { ts [ 0 ] = tIndex ; } if ( seg -> t ( tIndex ) == set [ idx ] . tEnd ) { ts [ 1 ] = tIndex ; } if ( seg -> t ( tIndex ) >= 1 ) { break ; } } while ( ++ tIndex ) ; } static void testOne ( skiatest :: Reporter * reporter , const SortSetTests & test ) { SkTDArray < SkOpAngle > angles ; bool unsortable = false ; bool unorderable = false ; SkTArray < SkOpSegment > segs ; for ( size_t idx = 0 ; idx < test . count ; ++ idx ) { int ts [ 2 ] ; const SortSet * set = test . set ; SkOpSegment & seg = segs . push_back ( ) ; setup ( set , idx , & seg , ts , test . startPt ) ; SkOpAngle * angle = angles . append ( ) ; angle -> set ( & seg , ts [ 0 ] , ts [ 1 ] ) ; # if DEBUG_ANGLE angle -> setID ( idx ) ; # endif if ( angle -> unsortable ( ) ) { # if DEBUG_ANGLE SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ angle [ % d ] ▁ unsortable \n " , __FUNCTION__ , test . name , idx ) ; # endif unsortable = true ; } if ( angle -> unorderable ( ) ) { # if DEBUG_ANGLE SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ angle [ % d ] ▁ unorderable \n " , __FUNCTION__ , test . name , idx ) ; # endif unorderable = true ; } reporter -> bumpTestCount ( ) ; } if ( unsortable || unorderable ) { return ; } # if DEBUG_ANGLE SkDebugf ( " % s ▁ test [ % s ] \n " , __FUNCTION__ , test . name ) ; # endif for ( size_t idxL = 0 ; idxL < test . count ; ++ idxL ) { const SkOpAngle & first = angles [ idxL ] ; for ( size_t idxG = 0 ; idxG < test . count ; ++ idxG ) { if ( idxL == idxG ) { continue ; } const SkOpAngle & second = angles [ idxG ] ; bool compare = first < second ; if ( idxL < idxG ) { if ( ! compare ) { SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ first [ % d ] ▁ > ▁ second [ % d ] \n " , __FUNCTION__ , test . name , idxL , idxG ) ; compare = first < second ; } REPORTER_ASSERT ( reporter , compare ) ; } else { SkASSERT ( idxL > idxG ) ; if ( compare ) { SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ first [ % d ] ▁ < ▁ second [ % d ] \n " , __FUNCTION__ , test . name , idxL , idxG ) ; compare = first < second ; } REPORTER_ASSERT ( reporter , ! compare ) ; } compare = second < first ; if ( idxL < idxG ) { if ( compare ) { SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ second [ % d ] ▁ < ▁ first [ % d ] \n " , __FUNCTION__ , test . name , idxL , idxG ) ; compare = second < first ; } REPORTER_ASSERT ( reporter , ! compare ) ; } else { SkASSERT ( idxL > idxG ) ; if ( ! compare ) { SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ second [ % d ] ▁ > ▁ first [ % d ] \n " , __FUNCTION__ , test . name , idxL , idxG ) ; compare = second < first ; } REPORTER_ASSERT ( reporter , compare ) ; } } } } static void PathOpsAngleTest ( skiatest :: Reporter * reporter ) { for ( size_t index = 0 ; index < SK_ARRAY_COUNT ( tests ) ; ++ index ) { const SortSetTests & test = tests [ index ] ; testOne ( reporter , test ) ; reporter -> bumpTestCount ( ) ; } } static void PathOpsAngleTestOne ( skiatest :: Reporter * reporter ) { size_t index = 0 ; const SortSetTests & test = tests [ index ] ; testOne ( reporter , test ) ; } # if 0 static int find_slop ( double x , double y , double rx , double ry ) { int slopBits = 0 ; bool less1 , less2 ; double absX = fabs ( x ) ; double absY = fabs ( y ) ; double length = absX < absY ? absX / 2 + absY : absX + absY / 2 ; int exponent ; ( void ) frexp ( length , & exponent ) ; double epsilon = ldexp ( FLT_EPSILON , exponent ) ; do { double xSlop = epsilon * slopBits ; double ySlop = x * y < 0 ? - xSlop : xSlop ; double x1 = x - xSlop ; double y1 = y + ySlop ; double x_ry1 = x1 * ry ; double rx_y1 = rx * y1 ; less1 = x_ry1 < rx_y1 ; double x2 = x + xSlop ; double y2 = y - ySlop ; double x_ry2 = x2 * ry ; double rx_y2 = rx * y2 ; less2 = x_ry2 < rx_y2 ; } while ( less1 == less2 && ++ slopBits ) ; return slopBits ; } static double diamond_angle ( double y , double x ) { if ( y >= 0 ) return ( x >= 0 ? y / ( x + y ) : 1 - x / ( - x + y ) ) ; else return ( x < 0 ? 2 - y / ( - x - y ) : 3 + x / ( x - y ) ) ; } static const double slopTests [ ] [ 4 ] = { { - 0.058554756452593892 , - 0.18804585843827226 , - 0.018568569646021160 , - 0.059615294434479438 } , { - 0.0013717412948608398 , 0.0041152238845825195 , - 0.00045837944195925573 , 0.0013753175735478074 } , { - 2.1033774145221198 , - 1.4046019261273715e - 008 , - 0.70062688352066704 , - 1.2706324683777995e - 008 } , } ; static void PathOpsAngleFindSlop ( skiatest :: Reporter * reporter ) { for ( size_t index = 0 ; index < SK_ARRAY_COUNT ( slopTests ) ; ++ index ) { const double * slopTest = slopTests [ index ] ; double x = slopTest [ 0 ] ; double y = slopTest [ 1 ] ; double rx = slopTest [ 2 ] ; double ry = slopTest [ 3 ] ; SkDebugf ( " % s ▁ ▁ xy ▁ % d = % d \n " , __FUNCTION__ , ( int ) index , find_slop ( x , y , rx , ry ) ) ; SkDebugf ( " % s ▁ rxy ▁ % d = % d \n " , __FUNCTION__ , ( int ) index , find_slop ( rx , ry , x , y ) ) ; double angle = diamond_angle ( y , x ) ; double rAngle = diamond_angle ( ry , rx ) ; double diff = fabs ( angle - rAngle ) ; SkDebugf ( " % s ▁ diamond ▁ xy = % 1.9g ▁ rxy = % 1.9g ▁ diff = % 1.9g ▁ factor = % d \n " , __FUNCTION__ , angle , rAngle , diff , ( int ) ( diff / FLT_EPSILON ) ) ; } } # endif # include " TestClassDef . h " DEFINE_TESTCLASS_SHORT ( PathOpsAngleTest ) DEFINE_TESTCLASS_SHORT ( PathOpsAngleTestOne ) </DOCUMENT>
<DOCUMENT_ID="deadcoda/arg3db/tree/master/src/sqlite/resultset.cpp"> # include " resultset . h " # include " . . / exception . h " # include " row . h " # include " session . h " using namespace std ; namespace coda { namespace db { namespace sqlite { resultset :: resultset ( const std :: shared_ptr < sqlite :: session > & sess , const shared_ptr < sqlite3_stmt > & stmt ) : stmt_ ( stmt ) , sess_ ( sess ) , status_ ( - 1 ) { if ( sess_ == nullptr ) { throw database_exception ( " No ▁ database ▁ provided ▁ to ▁ sqlite3 ▁ resultset " ) ; } if ( stmt_ == nullptr ) { throw database_exception ( " no ▁ statement ▁ provided ▁ to ▁ sqlite3 ▁ resultset " ) ; } } resultset :: resultset ( resultset && other ) : stmt_ ( std :: move ( other . stmt_ ) ) , sess_ ( std :: move ( other . sess_ ) ) , status_ ( other . status_ ) { other . sess_ = nullptr ; other . stmt_ = nullptr ; } resultset :: ~ resultset ( ) { } resultset & resultset :: operator = ( resultset && other ) { stmt_ = std :: move ( other . stmt_ ) ; sess_ = std :: move ( other . sess_ ) ; status_ = other . status_ ; other . sess_ = nullptr ; other . stmt_ = nullptr ; return * this ; } bool resultset :: is_valid ( ) const noexcept { return stmt_ != nullptr && stmt_ ; } bool resultset :: next ( ) { if ( ! is_valid ( ) ) { return false ; } if ( status_ == SQLITE_DONE ) { return false ; } status_ = sqlite3_step ( stmt_ . get ( ) ) ; return status_ == SQLITE_ROW ; } void resultset :: reset ( ) { if ( ! is_valid ( ) ) { return ; } if ( sqlite3_reset ( stmt_ . get ( ) ) != SQLITE_OK ) { throw database_exception ( sess_ -> last_error ( ) ) ; } status_ = - 1 ; } resultset :: row_type resultset :: current_row ( ) { return row_type ( make_shared < row > ( sess_ , stmt_ ) ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="h0tw1r3/mame/tree/master/src/mame/video/mikromik.cpp"> # include " includes / mikromik . h " # define HORIZONTAL_CHARACTER_PIXELS 10 I8275_DRAW_CHARACTER_MEMBER ( mm1_state :: crtc_display_pixels ) { UINT8 romdata = m_char_rom -> base ( ) [ ( charcode << 4 ) | linecount ] ; int gpa0 = BIT ( gpa , 0 ) ; int llen = m_llen ; int compl_in = rvv ; int hlt_in = hlgt ; int color ; int i , qh , video_in ; int d7 = BIT ( romdata , 7 ) ; int d6 = BIT ( romdata , 6 ) ; int d0 = BIT ( romdata , 0 ) ; UINT8 data = ( romdata << 1 ) | ( d7 & d0 ) ; if ( y < 360 || x >= HORIZONTAL_CHARACTER_PIXELS || compl_in == 0 ) { if ( HORIZONTAL_CHARACTER_PIXELS == 10 ) { qh = d7 & d6 ; video_in = ( ( ( ( d7 & llen ) | ( vsp ? 0 : 1 ) ) & ( gpa0 ? 0 : 1 ) ) & qh ) | lten ; color = ( hlt_in ? 1 : 2 ) * ( video_in ^ compl_in ) ; bitmap . pix32 ( y , x + 8 ) = m_palette -> pen ( color ) ; bitmap . pix32 ( y , x + 9 ) = m_palette -> pen ( color ) ; } for ( i = 0 ; i < 8 ; ++ i ) { qh = BIT ( data , i ) ; video_in = ( ( ( ( d7 & llen ) | ( vsp ? 0 : 1 ) ) & ( gpa0 ? 0 : 1 ) ) & qh ) | lten ; color = ( hlt_in ? 1 : 2 ) * ( video_in ^ compl_in ) ; bitmap . pix32 ( y , x + i ) = m_palette -> pen ( color ) ; } } } static ADDRESS_MAP_START ( mm1_upd7220_map , AS_0 , 16 , mm1_state ) ADDRESS_MAP_GLOBAL_MASK ( 0x7fff ) AM_RANGE ( 0x0000 , 0x7fff ) AM_RAM AM_SHARE ( " video _ ram " ) ADDRESS_MAP_END UPD7220_DISPLAY_PIXELS_MEMBER ( mm1_state :: hgdc_display_pixels ) { UINT16 data = m_video_ram [ address >> 1 ] ; for ( int i = 0 ; i < 16 ; i ++ ) { if ( BIT ( data , i ) ) bitmap . pix32 ( y , x + i ) = m_palette -> pen ( 2 ) ; } } UINT32 mm1_state :: screen_update ( screen_device & screen , bitmap_rgb32 & bitmap , const rectangle & cliprect ) { m_crtc -> screen_update ( screen , bitmap , cliprect ) ; m_hgdc -> screen_update ( screen , bitmap , cliprect ) ; return 0 ; } static const gfx_layout charlayout = { 8 , 16 , RGN_FRAC ( 1 , 1 ) , 1 , { 0 } , { 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 } , { 0 * 8 , 1 * 8 , 2 * 8 , 3 * 8 , 4 * 8 , 5 * 8 , 6 * 8 , 7 * 8 , 8 * 8 , 9 * 8 , 10 * 8 , 11 * 8 , 12 * 8 , 13 * 8 , 14 * 8 , 15 * 8 } , 8 * 16 } ; static GFXDECODE_START ( mm1 ) GFXDECODE_ENTRY ( " chargen " , 0 , charlayout , 0 , 1 ) GFXDECODE_END PALETTE_INIT_MEMBER ( mm1_state , mm1 ) { palette . set_pen_color ( 0 , rgb_t ( 0x00 , 0x00 , 0x00 ) ) ; palette . set_pen_color ( 1 , rgb_t ( 0x00 , 0x7F , 0x0A ) ) ; palette . set_pen_color ( 2 , rgb_t ( 0x08 , 0xD0 , 0x1A ) ) ; } MACHINE_CONFIG_FRAGMENT ( mm1m6_video ) MCFG_SCREEN_ADD ( SCREEN_TAG , RASTER ) MCFG_SCREEN_REFRESH_RATE ( 50 ) MCFG_SCREEN_UPDATE_DRIVER ( mm1_state , screen_update ) MCFG_SCREEN_SIZE ( 800 , 375 ) MCFG_SCREEN_VISIBLE_AREA ( 0 , 800 - 1 , 0 , 375 - 1 ) MCFG_GFXDECODE_ADD ( " gfxdecode " , " palette " , mm1 ) MCFG_PALETTE_ADD ( " palette " , 3 ) MCFG_PALETTE_INIT_OWNER ( mm1_state , mm1 ) MCFG_DEVICE_ADD ( I8275_TAG , I8275 , XTAL_18_720MHz / 8 ) MCFG_I8275_CHARACTER_WIDTH ( HORIZONTAL_CHARACTER_PIXELS ) MCFG_I8275_DRAW_CHARACTER_CALLBACK_OWNER ( mm1_state , crtc_display_pixels ) MCFG_I8275_DRQ_CALLBACK ( DEVWRITELINE ( I8237_TAG , am9517a_device , dreq0_w ) ) MCFG_I8275_VRTC_CALLBACK ( DEVWRITELINE ( UPD7220_TAG , upd7220_device , ext_sync_w ) ) MCFG_VIDEO_SET_SCREEN ( SCREEN_TAG ) MCFG_DEVICE_ADD ( UPD7220_TAG , UPD7220 , XTAL_18_720MHz / 8 ) MCFG_DEVICE_ADDRESS_MAP ( AS_0 , mm1_upd7220_map ) MCFG_UPD7220_DISPLAY_PIXELS_CALLBACK_OWNER ( mm1_state , hgdc_display_pixels ) MCFG_VIDEO_SET_SCREEN ( SCREEN_TAG ) MACHINE_CONFIG_END </DOCUMENT>
<DOCUMENT_ID="mapmapteam/mapmap/tree/master/src/gui/contrib/qtpropertybrowser/src/qtpropertybrowserutils.cpp"> # include " qtpropertybrowserutils _ p . h " # include < QApplication > # include < QPainter > # include < QHBoxLayout > # include < QMouseEvent > # include < QCheckBox > # include < QLineEdit > # include < QMenu > # include < QStyleOption > # if QT_VERSION >= 0x040400 QT_BEGIN_NAMESPACE # endif QtCursorDatabase :: QtCursorDatabase ( ) { appendCursor ( Qt :: ArrowCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Arrow " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - arrow . png " ) ) ) ; appendCursor ( Qt :: UpArrowCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Up ▁ Arrow " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - uparrow . png " ) ) ) ; appendCursor ( Qt :: CrossCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Cross " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - cross . png " ) ) ) ; appendCursor ( Qt :: WaitCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Wait " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - wait . png " ) ) ) ; appendCursor ( Qt :: IBeamCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " IBeam " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - ibeam . png " ) ) ) ; appendCursor ( Qt :: SizeVerCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Vertical " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizev . png " ) ) ) ; appendCursor ( Qt :: SizeHorCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Horizontal " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeh . png " ) ) ) ; appendCursor ( Qt :: SizeFDiagCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Backslash " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizef . png " ) ) ) ; appendCursor ( Qt :: SizeBDiagCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Slash " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeb . png " ) ) ) ; appendCursor ( Qt :: SizeAllCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ All " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeall . png " ) ) ) ; appendCursor ( Qt :: BlankCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Blank " ) , QIcon ( ) ) ; appendCursor ( Qt :: SplitVCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Split ▁ Vertical " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - vsplit . png " ) ) ) ; appendCursor ( Qt :: SplitHCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Split ▁ Horizontal " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - hsplit . png " ) ) ) ; appendCursor ( Qt :: PointingHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Pointing ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - hand . png " ) ) ) ; appendCursor ( Qt :: ForbiddenCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Forbidden " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - forbidden . png " ) ) ) ; appendCursor ( Qt :: OpenHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Open ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - openhand . png " ) ) ) ; appendCursor ( Qt :: ClosedHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Closed ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - closedhand . png " ) ) ) ; appendCursor ( Qt :: WhatsThisCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " What ' s ▁ This " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - whatsthis . png " ) ) ) ; appendCursor ( Qt :: BusyCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Busy " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - busy . png " ) ) ) ; } void QtCursorDatabase :: clear ( ) { m_cursorNames . clear ( ) ; m_cursorIcons . clear ( ) ; m_valueToCursorShape . clear ( ) ; m_cursorShapeToValue . clear ( ) ; } void QtCursorDatabase :: appendCursor ( Qt :: CursorShape shape , const QString & name , const QIcon & icon ) { if ( m_cursorShapeToValue . contains ( shape ) ) return ; const int value = m_cursorNames . count ( ) ; m_cursorNames . append ( name ) ; m_cursorIcons . insert ( value , icon ) ; m_valueToCursorShape . insert ( value , shape ) ; m_cursorShapeToValue . insert ( shape , value ) ; } QStringList QtCursorDatabase :: cursorShapeNames ( ) const { return m_cursorNames ; } QMap < int , QIcon > QtCursorDatabase :: cursorShapeIcons ( ) const { return m_cursorIcons ; } QString QtCursorDatabase :: cursorToShapeName ( const QCursor & cursor ) const { int val = cursorToValue ( cursor ) ; if ( val >= 0 ) return m_cursorNames . at ( val ) ; return QString ( ) ; } QIcon QtCursorDatabase :: cursorToShapeIcon ( const QCursor & cursor ) const { int val = cursorToValue ( cursor ) ; return m_cursorIcons . value ( val ) ; } int QtCursorDatabase :: cursorToValue ( const QCursor & cursor ) const { # ifndef QT_NO_CURSOR Qt :: CursorShape shape = cursor . shape ( ) ; if ( m_cursorShapeToValue . contains ( shape ) ) return m_cursorShapeToValue [ shape ] ; # endif return - 1 ; } # ifndef QT_NO_CURSOR QCursor QtCursorDatabase :: valueToCursor ( int value ) const { if ( m_valueToCursorShape . contains ( value ) ) return QCursor ( m_valueToCursorShape [ value ] ) ; return QCursor ( ) ; } # endif QPixmap QtPropertyBrowserUtils :: brushValuePixmap ( const QBrush & b ) { QImage img ( 16 , 16 , QImage :: Format_ARGB32_Premultiplied ) ; img . fill ( 0 ) ; QPainter painter ( & img ) ; painter . setCompositionMode ( QPainter :: CompositionMode_Source ) ; painter . fillRect ( 0 , 0 , img . width ( ) , img . height ( ) , b ) ; QColor color = b . color ( ) ; if ( color . alpha ( ) != 255 ) { QBrush opaqueBrush = b ; color . setAlpha ( 255 ) ; opaqueBrush . setColor ( color ) ; painter . fillRect ( img . width ( ) / 4 , img . height ( ) / 4 , img . width ( ) / 2 , img . height ( ) / 2 , opaqueBrush ) ; } painter . end ( ) ; return QPixmap :: fromImage ( img ) ; } QIcon QtPropertyBrowserUtils :: brushValueIcon ( const QBrush & b ) { return QIcon ( brushValuePixmap ( b ) ) ; } QString QtPropertyBrowserUtils :: colorValueText ( const QColor & c ) { return QCoreApplication :: translate ( " QtPropertyBrowserUtils " , " [ %1 , ▁ % 2 , ▁ % 3 ] ▁ ( %4 ) " ) . arg ( c . red ( ) ) . arg ( c . green ( ) ) . arg ( c . blue ( ) ) . arg ( c . alpha ( ) ) ; } QPixmap QtPropertyBrowserUtils :: fontValuePixmap ( const QFont & font ) { QFont f = font ; QImage img ( 16 , 16 , QImage :: Format_ARGB32_Premultiplied ) ; img . fill ( 0 ) ; QPainter p ( & img ) ; p . setRenderHint ( QPainter :: TextAntialiasing , true ) ; p . setRenderHint ( QPainter :: Antialiasing , true ) ; f . setPointSize ( 13 ) ; p . setFont ( f ) ; QTextOption t ; t . setAlignment ( Qt :: AlignCenter ) ; p . drawText ( QRect ( 0 , 0 , 16 , 16 ) , QString ( QLatin1Char ( ' A ' ) ) , t ) ; return QPixmap :: fromImage ( img ) ; } QIcon QtPropertyBrowserUtils :: fontValueIcon ( const QFont & f ) { return QIcon ( fontValuePixmap ( f ) ) ; } QString QtPropertyBrowserUtils :: fontValueText ( const QFont & f ) { return QCoreApplication :: translate ( " QtPropertyBrowserUtils " , " [ %1 , ▁ % 2 ] " ) . arg ( f . family ( ) ) . arg ( f . pointSize ( ) ) ; } QtBoolEdit :: QtBoolEdit ( QWidget * parent ) : QWidget ( parent ) , m_checkBox ( new QCheckBox ( this ) ) , m_textVisible ( true ) { QHBoxLayout * lt = new QHBoxLayout ; if ( QApplication :: layoutDirection ( ) == Qt :: LeftToRight ) lt -> setContentsMargins ( 4 , 0 , 0 , 0 ) ; else lt -> setContentsMargins ( 0 , 0 , 4 , 0 ) ; lt -> addWidget ( m_checkBox ) ; setLayout ( lt ) ; connect ( m_checkBox , SIGNAL ( toggled ( bool ) ) , this , SIGNAL ( toggled ( bool ) ) ) ; setFocusProxy ( m_checkBox ) ; m_checkBox -> setText ( tr ( " True " ) ) ; } void QtBoolEdit :: setTextVisible ( bool textVisible ) { if ( m_textVisible == textVisible ) return ; m_textVisible = textVisible ; if ( m_textVisible ) m_checkBox -> setText ( isChecked ( ) ? tr ( " True " ) : tr ( " False " ) ) ; else m_checkBox -> setText ( QString ( ) ) ; } Qt :: CheckState QtBoolEdit :: checkState ( ) const { return m_checkBox -> checkState ( ) ; } void QtBoolEdit :: setCheckState ( Qt :: CheckState state ) { m_checkBox -> setCheckState ( state ) ; } bool QtBoolEdit :: isChecked ( ) const { return m_checkBox -> isChecked ( ) ; } void QtBoolEdit :: setChecked ( bool c ) { m_checkBox -> setChecked ( c ) ; if ( ! m_textVisible ) return ; m_checkBox -> setText ( isChecked ( ) ? tr ( " True " ) : tr ( " False " ) ) ; } bool QtBoolEdit :: blockCheckBoxSignals ( bool block ) { return m_checkBox -> blockSignals ( block ) ; } void QtBoolEdit :: mousePressEvent ( QMouseEvent * event ) { if ( event -> buttons ( ) == Qt :: LeftButton ) { m_checkBox -> click ( ) ; event -> accept ( ) ; } else { QWidget :: mousePressEvent ( event ) ; } } void QtBoolEdit :: paintEvent ( QPaintEvent * ) { QStyleOption opt ; opt . init ( this ) ; QPainter p ( this ) ; style ( ) -> drawPrimitive ( QStyle :: PE_Widget , & opt , & p , this ) ; } QtKeySequenceEdit :: QtKeySequenceEdit ( QWidget * parent ) : QWidget ( parent ) , m_num ( 0 ) , m_lineEdit ( new QLineEdit ( this ) ) { QHBoxLayout * layout = new QHBoxLayout ( this ) ; layout -> addWidget ( m_lineEdit ) ; layout -> setMargin ( 0 ) ; m_lineEdit -> installEventFilter ( this ) ; m_lineEdit -> setReadOnly ( true ) ; m_lineEdit -> setFocusProxy ( this ) ; setFocusPolicy ( m_lineEdit -> focusPolicy ( ) ) ; setAttribute ( Qt :: WA_InputMethodEnabled ) ; } bool QtKeySequenceEdit :: eventFilter ( QObject * o , QEvent * e ) { if ( o == m_lineEdit && e -> type ( ) == QEvent :: ContextMenu ) { QContextMenuEvent * c = static_cast < QContextMenuEvent * > ( e ) ; QMenu * menu = m_lineEdit -> createStandardContextMenu ( ) ; const QList < QAction * > actions = menu -> actions ( ) ; QListIterator < QAction * > itAction ( actions ) ; while ( itAction . hasNext ( ) ) { QAction * action = itAction . next ( ) ; action -> setShortcut ( QKeySequence ( ) ) ; QString actionString = action -> text ( ) ; const int pos = actionString . lastIndexOf ( QLatin1Char ( ' \t ' ) ) ; if ( pos > 0 ) actionString . remove ( pos , actionString . length ( ) - pos ) ; action -> setText ( actionString ) ; } QAction * actionBefore = 0 ; if ( actions . count ( ) > 0 ) actionBefore = actions [ 0 ] ; QAction * clearAction = new QAction ( tr ( " Clear ▁ Shortcut " ) , menu ) ; menu -> insertAction ( actionBefore , clearAction ) ; menu -> insertSeparator ( actionBefore ) ; clearAction -> setEnabled ( ! m_keySequence . isEmpty ( ) ) ; connect ( clearAction , SIGNAL ( triggered ( ) ) , this , SLOT ( slotClearShortcut ( ) ) ) ; menu -> exec ( c -> globalPos ( ) ) ; delete menu ; e -> accept ( ) ; return true ; } return QWidget :: eventFilter ( o , e ) ; } void QtKeySequenceEdit :: slotClearShortcut ( ) { if ( m_keySequence . isEmpty ( ) ) return ; setKeySequence ( QKeySequence ( ) ) ; emit keySequenceChanged ( m_keySequence ) ; } void QtKeySequenceEdit :: handleKeyEvent ( QKeyEvent * e ) { int nextKey = e -> key ( ) ; if ( nextKey == Qt :: Key_Control || nextKey == Qt :: Key_Shift || nextKey == Qt :: Key_Meta || nextKey == Qt :: Key_Alt || nextKey == Qt :: Key_Super_L || nextKey == Qt :: Key_AltGr ) return ; nextKey |= translateModifiers ( e -> modifiers ( ) , e -> text ( ) ) ; int k0 = m_keySequence [ 0 ] ; int k1 = m_keySequence [ 1 ] ; int k2 = m_keySequence [ 2 ] ; int k3 = m_keySequence [ 3 ] ; switch ( m_num ) { case 0 : k0 = nextKey ; k1 = 0 ; k2 = 0 ; k3 = 0 ; break ; case 1 : k1 = nextKey ; k2 = 0 ; k3 = 0 ; break ; case 2 : k2 = nextKey ; k3 = 0 ; break ; case 3 : k3 = nextKey ; break ; default : break ; } ++ m_num ; if ( m_num > 3 ) m_num = 0 ; m_keySequence = QKeySequence ( k0 , k1 , k2 , k3 ) ; m_lineEdit -> setText ( m_keySequence . toString ( QKeySequence :: NativeText ) ) ; e -> accept ( ) ; emit keySequenceChanged ( m_keySequence ) ; } void QtKeySequenceEdit :: setKeySequence ( const QKeySequence & sequence ) { if ( sequence == m_keySequence ) return ; m_num = 0 ; m_keySequence = sequence ; m_lineEdit -> setText ( m_keySequence . toString ( QKeySequence :: NativeText ) ) ; } QKeySequence QtKeySequenceEdit :: keySequence ( ) const { return m_keySequence ; } int QtKeySequenceEdit :: translateModifiers ( Qt :: KeyboardModifiers state , const QString & text ) const { int result = 0 ; if ( ( state & Qt :: ShiftModifier ) && ( text . size ( ) == 0 || ! text . at ( 0 ) . isPrint ( ) || text . at ( 0 ) . isLetter ( ) || text . at ( 0 ) . isSpace ( ) ) ) result |= Qt :: SHIFT ; if ( state & Qt :: ControlModifier ) result |= Qt :: CTRL ; if ( state & Qt :: MetaModifier ) result |= Qt :: META ; if ( state & Qt :: AltModifier ) result |= Qt :: ALT ; return result ; } void QtKeySequenceEdit :: focusInEvent ( QFocusEvent * e ) { m_lineEdit -> event ( e ) ; m_lineEdit -> selectAll ( ) ; QWidget :: focusInEvent ( e ) ; } void QtKeySequenceEdit :: focusOutEvent ( QFocusEvent * e ) { m_num = 0 ; m_lineEdit -> event ( e ) ; QWidget :: focusOutEvent ( e ) ; } void QtKeySequenceEdit :: keyPressEvent ( QKeyEvent * e ) { handleKeyEvent ( e ) ; e -> accept ( ) ; } void QtKeySequenceEdit :: keyReleaseEvent ( QKeyEvent * e ) { m_lineEdit -> event ( e ) ; } void QtKeySequenceEdit :: paintEvent ( QPaintEvent * ) { QStyleOption opt ; opt . init ( this ) ; QPainter p ( this ) ; style ( ) -> drawPrimitive ( QStyle :: PE_Widget , & opt , & p , this ) ; } bool QtKeySequenceEdit :: event ( QEvent * e ) { if ( e -> type ( ) == QEvent :: Shortcut || e -> type ( ) == QEvent :: ShortcutOverride || e -> type ( ) == QEvent :: KeyRelease ) { e -> accept ( ) ; return true ; } return QWidget :: event ( e ) ; } # if QT_VERSION >= 0x040400 QT_END_NAMESPACE # endif </DOCUMENT>
<DOCUMENT_ID="gilleslabelle/sagetv/tree/master/third_party/codecs/faac/common/mp4v2/atom_dmax.cpp"> # include " mp4common . h " MP4DmaxAtom :: MP4DmaxAtom ( ) : MP4Atom ( " dmax " ) { AddProperty ( new MP4Integer32Property ( " milliSecs " ) ) ; } </DOCUMENT>
<DOCUMENT_ID="MobWiMetro/gba10/tree/master/GBA10/VBAM/gba/gbafilter.cpp"> # include " gbafilter . h " # include < math . h > extern int systemColorDepth ; extern int systemRedShift ; extern int systemGreenShift ; extern int systemBlueShift ; extern u16 systemColorMap16 [ 0x10000 ] ; extern u32 systemColorMap32 [ 0x10000 ] ; static const unsigned char curve [ 32 ] = { 0x08 , 0x09 , 0x0a , 0x0b , 0x0c , 0x0e , 0x10 , 0x12 , 0x14 , 0x16 , 0x18 , 0x1c , 0x20 , 0x28 , 0x30 , 0x38 , 0x40 , 0x48 , 0x50 , 0x58 , 0x60 , 0x68 , 0x70 , 0x80 , 0x88 , 0x90 , 0xa0 , 0xb0 , 0xc0 , 0xd0 , 0xe0 , 0xf0 } ; static const unsigned char influence [ 3 * 3 ] = { 16 , 4 , 4 , 8 , 16 , 8 , 0 , 8 , 16 } ; inline void swap ( short & a , short & b ) { short temp = a ; a = b ; b = temp ; } void gbafilter_pal ( u16 * buf , int count ) { short temp [ 3 * 3 ] , s ; unsigned pix ; u8 red , green , blue ; while ( count -- ) { pix = * buf ; s = curve [ ( pix >> systemGreenShift ) & 0x1f ] ; temp [ 3 ] = s * influence [ 3 ] ; temp [ 4 ] = s * influence [ 4 ] ; temp [ 5 ] = s * influence [ 5 ] ; s = curve [ ( pix >> systemRedShift ) & 0x1f ] ; temp [ 0 ] = s * influence [ 0 ] ; temp [ 1 ] = s * influence [ 1 ] ; temp [ 2 ] = s * influence [ 2 ] ; s = curve [ ( pix >> systemBlueShift ) & 0x1f ] ; temp [ 6 ] = s * influence [ 6 ] ; temp [ 7 ] = s * influence [ 7 ] ; temp [ 8 ] = s * influence [ 8 ] ; if ( temp [ 0 ] < temp [ 3 ] ) swap ( temp [ 0 ] , temp [ 3 ] ) ; if ( temp [ 0 ] < temp [ 6 ] ) swap ( temp [ 0 ] , temp [ 6 ] ) ; if ( temp [ 3 ] < temp [ 6 ] ) swap ( temp [ 3 ] , temp [ 6 ] ) ; temp [ 3 ] <<= 1 ; temp [ 0 ] <<= 2 ; temp [ 0 ] += temp [ 3 ] + temp [ 6 ] ; red = ( ( int ( temp [ 0 ] ) * 160 ) >> 17 ) + 4 ; if ( red > 31 ) red = 31 ; if ( temp [ 2 ] < temp [ 5 ] ) swap ( temp [ 2 ] , temp [ 5 ] ) ; if ( temp [ 2 ] < temp [ 8 ] ) swap ( temp [ 2 ] , temp [ 8 ] ) ; if ( temp [ 5 ] < temp [ 8 ] ) swap ( temp [ 5 ] , temp [ 8 ] ) ; temp [ 5 ] <<= 1 ; temp [ 2 ] <<= 2 ; temp [ 2 ] += temp [ 5 ] + temp [ 8 ] ; blue = ( ( int ( temp [ 2 ] ) * 160 ) >> 17 ) + 4 ; if ( blue > 31 ) blue = 31 ; if ( temp [ 1 ] < temp [ 4 ] ) swap ( temp [ 1 ] , temp [ 4 ] ) ; if ( temp [ 1 ] < temp [ 7 ] ) swap ( temp [ 1 ] , temp [ 7 ] ) ; if ( temp [ 4 ] < temp [ 7 ] ) swap ( temp [ 4 ] , temp [ 7 ] ) ; temp [ 4 ] <<= 1 ; temp [ 1 ] <<= 2 ; temp [ 1 ] += temp [ 4 ] + temp [ 7 ] ; green = ( ( int ( temp [ 1 ] ) * 160 ) >> 17 ) + 4 ; if ( green > 31 ) green = 31 ; pix = red << systemRedShift ; pix += green << systemGreenShift ; pix += blue << systemBlueShift ; * buf ++ = pix ; } } void gbafilter_pal32 ( u32 * buf , int count ) { short temp [ 3 * 3 ] , s ; unsigned pix ; u8 red , green , blue ; while ( count -- ) { pix = * buf ; s = curve [ ( pix >> systemGreenShift ) & 0x1f ] ; temp [ 3 ] = s * influence [ 3 ] ; temp [ 4 ] = s * influence [ 4 ] ; temp [ 5 ] = s * influence [ 5 ] ; s = curve [ ( pix >> systemRedShift ) & 0x1f ] ; temp [ 0 ] = s * influence [ 0 ] ; temp [ 1 ] = s * influence [ 1 ] ; temp [ 2 ] = s * influence [ 2 ] ; s = curve [ ( pix >> systemBlueShift ) & 0x1f ] ; temp [ 6 ] = s * influence [ 6 ] ; temp [ 7 ] = s * influence [ 7 ] ; temp [ 8 ] = s * influence [ 8 ] ; if ( temp [ 0 ] < temp [ 3 ] ) swap ( temp [ 0 ] , temp [ 3 ] ) ; if ( temp [ 0 ] < temp [ 6 ] ) swap ( temp [ 0 ] , temp [ 6 ] ) ; if ( temp [ 3 ] < temp [ 6 ] ) swap ( temp [ 3 ] , temp [ 6 ] ) ; temp [ 3 ] <<= 1 ; temp [ 0 ] <<= 2 ; temp [ 0 ] += temp [ 3 ] + temp [ 6 ] ; red = ( ( int ( temp [ 0 ] ) * 160 ) >> 14 ) + 32 ; if ( temp [ 2 ] < temp [ 5 ] ) swap ( temp [ 2 ] , temp [ 5 ] ) ; if ( temp [ 2 ] < temp [ 8 ] ) swap ( temp [ 2 ] , temp [ 8 ] ) ; if ( temp [ 5 ] < temp [ 8 ] ) swap ( temp [ 5 ] , temp [ 8 ] ) ; temp [ 5 ] <<= 1 ; temp [ 2 ] <<= 2 ; temp [ 2 ] += temp [ 5 ] + temp [ 8 ] ; blue = ( ( int ( temp [ 2 ] ) * 160 ) >> 14 ) + 32 ; if ( temp [ 1 ] < temp [ 4 ] ) swap ( temp [ 1 ] , temp [ 4 ] ) ; if ( temp [ 1 ] < temp [ 7 ] ) swap ( temp [ 1 ] , temp [ 7 ] ) ; if ( temp [ 4 ] < temp [ 7 ] ) swap ( temp [ 4 ] , temp [ 7 ] ) ; temp [ 4 ] <<= 1 ; temp [ 1 ] <<= 2 ; temp [ 1 ] += temp [ 4 ] + temp [ 7 ] ; green = ( ( int ( temp [ 1 ] ) * 160 ) >> 14 ) + 32 ; pix = red << ( systemRedShift - 3 ) ; pix += green << ( systemGreenShift - 3 ) ; pix += blue << ( systemBlueShift - 3 ) ; * buf ++ = pix ; } } void gbafilter_pad ( u8 * buf , int count ) { union { struct { u8 r ; u8 g ; u8 b ; u8 a ; } part ; unsigned whole ; } mask ; mask . whole = 0x1f << systemRedShift ; mask . whole += 0x1f << systemGreenShift ; mask . whole += 0x1f << systemBlueShift ; switch ( systemColorDepth ) { case 24 : while ( count -- ) { * buf ++ &= mask . part . r ; * buf ++ &= mask . part . g ; * buf ++ &= mask . part . b ; } break ; case 32 : while ( count -- ) { * ( ( u32 * ) buf ) &= mask . whole ; buf += 4 ; } } } </DOCUMENT>
<DOCUMENT_ID="Roxtedy/SkyFire_6xx/tree/master/src/server/game/Handlers/TicketHandler.cpp"> # include " zlib . h " # include " Common . h " # include " Language . h " # include " ObjectMgr . h " # include " Opcodes . h " # include " Player . h " # include " TicketMgr . h " # include " Util . h " # include " World . h " # include " WorldPacket . h " # include " WorldSession . h " void WorldSession :: HandleGMTicketCreateOpcode ( WorldPacket & recvData ) { if ( sTicketMgr -> GetStatus ( ) == GMTICKET_QUEUE_STATUS_DISABLED ) return ; if ( GetPlayer ( ) -> getLevel ( ) < sWorld -> getIntConfig ( CONFIG_TICKET_LEVEL_REQ ) ) { SendNotification ( GetTrinityString ( LANG_TICKET_REQ ) , sWorld -> getIntConfig ( CONFIG_TICKET_LEVEL_REQ ) ) ; return ; } GMTicketResponse response = GMTICKET_RESPONSE_CREATE_ERROR ; GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ; if ( ticket && ticket -> IsCompleted ( ) ) sTicketMgr -> CloseTicket ( ticket -> GetId ( ) , GetPlayer ( ) -> GetGUID ( ) ) ; ; if ( ! ticket || ticket -> IsClosed ( ) ) { ticket = new GmTicket ( GetPlayer ( ) , recvData ) ; uint32 count ; std :: list < uint32 > times ; uint32 decompressedSize ; std :: string chatLog ; recvData >> count ; for ( uint32 i = 0 ; i < count ; i ++ ) { uint32 time ; recvData >> time ; times . push_back ( time ) ; } recvData >> decompressedSize ; if ( count && decompressedSize && decompressedSize < 0xFFFF ) { uint32 pos = recvData . rpos ( ) ; ByteBuffer dest ; dest . resize ( decompressedSize ) ; uLongf realSize = decompressedSize ; if ( uncompress ( dest . contents ( ) , & realSize , recvData . contents ( ) + pos , recvData . size ( ) - pos ) == Z_OK ) { dest >> chatLog ; ticket -> SetChatLog ( times , chatLog ) ; } else { TC_LOG_ERROR ( " network " , " CMSG _ GMTICKET _ CREATE ▁ possibly ▁ corrupt . ▁ Uncompression ▁ failed . " ) ; recvData . rfinish ( ) ; delete ticket ; return ; } recvData . rfinish ( ) ; } sTicketMgr -> AddTicket ( ticket ) ; sTicketMgr -> UpdateLastChange ( ) ; sWorld -> SendGMText ( LANG_COMMAND_TICKETNEW , GetPlayer ( ) -> GetName ( ) . c_str ( ) , ticket -> GetId ( ) ) ; response = GMTICKET_RESPONSE_CREATE_SUCCESS ; } WorldPacket data ( SMSG_GMTICKET_CREATE , 4 ) ; data << uint32 ( response ) ; SendPacket ( & data ) ; } void WorldSession :: HandleGMTicketUpdateOpcode ( WorldPacket & recvData ) { std :: string message ; recvData >> message ; GMTicketResponse response = GMTICKET_RESPONSE_UPDATE_ERROR ; if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { SQLTransaction trans = SQLTransaction ( NULL ) ; ticket -> SetMessage ( message ) ; ticket -> SaveToDB ( trans ) ; sWorld -> SendGMText ( LANG_COMMAND_TICKETUPDATED , GetPlayer ( ) -> GetName ( ) . c_str ( ) , ticket -> GetId ( ) ) ; response = GMTICKET_RESPONSE_UPDATE_SUCCESS ; } WorldPacket data ( SMSG_GMTICKET_UPDATETEXT , 4 ) ; data << uint32 ( response ) ; SendPacket ( & data ) ; } void WorldSession :: HandleGMTicketDeleteOpcode ( WorldPacket & ) { if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { WorldPacket data ( SMSG_GMTICKET_DELETETICKET , 4 ) ; data << uint32 ( GMTICKET_RESPONSE_TICKET_DELETED ) ; SendPacket ( & data ) ; sWorld -> SendGMText ( LANG_COMMAND_TICKETPLAYERABANDON , GetPlayer ( ) -> GetName ( ) . c_str ( ) , ticket -> GetId ( ) ) ; sTicketMgr -> CloseTicket ( ticket -> GetId ( ) , GetPlayer ( ) -> GetGUID ( ) ) ; sTicketMgr -> SendTicket ( this , NULL ) ; } } void WorldSession :: HandleGMTicketGetTicketOpcode ( WorldPacket & ) { SendQueryTimeResponse ( ) ; if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { if ( ticket -> IsCompleted ( ) ) ticket -> SendResponse ( this ) ; else sTicketMgr -> SendTicket ( this , ticket ) ; } else sTicketMgr -> SendTicket ( this , NULL ) ; } void WorldSession :: HandleGMTicketSystemStatusOpcode ( WorldPacket & ) { WorldPacket data ( SMSG_GMTICKET_SYSTEMSTATUS , 4 ) ; data << uint32 ( sTicketMgr -> GetStatus ( ) ? GMTICKET_QUEUE_STATUS_ENABLED : GMTICKET_QUEUE_STATUS_DISABLED ) ; SendPacket ( & data ) ; } void WorldSession :: HandleGMSurveySubmit ( WorldPacket & recvData ) { uint32 nextSurveyID = sTicketMgr -> GetNextSurveyID ( ) ; uint32 mainSurvey ; recvData >> mainSurvey ; for ( uint8 i = 0 ; i < 15 ; i ++ ) { uint32 subSurveyId ; recvData >> subSurveyId ; if ( ! subSurveyId ) break ; uint8 rank ; recvData >> rank ; std :: string comment ; recvData >> comment ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_GM_SUBSURVEY ) ; stmt -> setUInt32 ( 0 , nextSurveyID ) ; stmt -> setUInt32 ( 1 , subSurveyId ) ; stmt -> setUInt32 ( 2 , rank ) ; stmt -> setString ( 3 , comment ) ; CharacterDatabase . Execute ( stmt ) ; } std :: string comment ; recvData >> comment ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_GM_SURVEY ) ; stmt -> setUInt32 ( 0 , GUID_LOPART ( GetPlayer ( ) -> GetGUID ( ) ) ) ; stmt -> setUInt32 ( 1 , nextSurveyID ) ; stmt -> setUInt32 ( 2 , mainSurvey ) ; stmt -> setString ( 3 , comment ) ; CharacterDatabase . Execute ( stmt ) ; } void WorldSession :: HandleReportLag ( WorldPacket & recvData ) { uint32 lagType , mapId ; recvData >> lagType ; recvData >> mapId ; float x , y , z ; recvData >> x ; recvData >> y ; recvData >> z ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_LAG_REPORT ) ; stmt -> setUInt32 ( 0 , GUID_LOPART ( GetPlayer ( ) -> GetGUID ( ) ) ) ; stmt -> setUInt8 ( 1 , lagType ) ; stmt -> setUInt16 ( 2 , mapId ) ; stmt -> setFloat ( 3 , x ) ; stmt -> setFloat ( 4 , y ) ; stmt -> setFloat ( 5 , z ) ; stmt -> setUInt32 ( 6 , GetLatency ( ) ) ; stmt -> setUInt32 ( 7 , time ( NULL ) ) ; CharacterDatabase . Execute ( stmt ) ; } void WorldSession :: HandleGMResponseResolve ( WorldPacket & ) { if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { uint8 getSurvey = 0 ; if ( float ( rand_chance ( ) ) < sWorld -> getFloatConfig ( CONFIG_CHANCE_OF_GM_SURVEY ) ) getSurvey = 1 ; WorldPacket data ( SMSG_GMRESPONSE_STATUS_UPDATE , 4 ) ; data << uint8 ( getSurvey ) ; SendPacket ( & data ) ; WorldPacket data2 ( SMSG_GMTICKET_DELETETICKET , 4 ) ; data2 << uint32 ( GMTICKET_RESPONSE_TICKET_DELETED ) ; SendPacket ( & data2 ) ; sTicketMgr -> CloseTicket ( ticket -> GetId ( ) , GetPlayer ( ) -> GetGUID ( ) ) ; sTicketMgr -> SendTicket ( this , NULL ) ; } } </DOCUMENT>
<DOCUMENT_ID="patmarion/PCL/tree/master/sample_consensus/src/ransac.cpp"> # include < pcl / impl / instantiate . hpp > # include < pcl / point_types . h > # include < pcl / sample_consensus / ransac . h > # include < pcl / sample_consensus / impl / ransac . hpp > # ifdef PCL_ONLY_CORE_POINT_TYPES PCL_INSTANTIATE ( RandomSampleConsensus , ( pcl :: PointXYZ ) ( pcl :: PointXYZI ) ( pcl :: PointXYZRGBA ) ( pcl :: PointXYZRGB ) ) # else PCL_INSTANTIATE ( RandomSampleConsensus , PCL_XYZ_POINT_TYPES ) # endif </DOCUMENT>
<DOCUMENT_ID="ShiftMediaProject/game-music-emu/tree/master/gme/Ay_Apu.cpp"> # include " Ay _ Apu . h " # include " blargg _ source . h " unsigned const inaudible_freq = 16384 ; int const period_factor = 16 ; static byte const amp_table [ 16 ] = { # define ENTRY ( n ) byte ( n * Ay_Apu :: amp_range + 0.5 ) ENTRY ( 0.000000 ) , ENTRY ( 0.007813 ) , ENTRY ( 0.011049 ) , ENTRY ( 0.015625 ) , ENTRY ( 0.022097 ) , ENTRY ( 0.031250 ) , ENTRY ( 0.044194 ) , ENTRY ( 0.062500 ) , ENTRY ( 0.088388 ) , ENTRY ( 0.125000 ) , ENTRY ( 0.176777 ) , ENTRY ( 0.250000 ) , ENTRY ( 0.353553 ) , ENTRY ( 0.500000 ) , ENTRY ( 0.707107 ) , ENTRY ( 1.000000 ) , # undef ENTRY } ; static byte const modes [ 8 ] = { # define MODE ( a0 , a1 , b0 , b1 , c0 , c1 ) ( a0 | a1 << 1 | b0 << 2 | b1 << 3 | c0 << 4 | c1 << 5 ) MODE ( 1 , 0 , 1 , 0 , 1 , 0 ) , MODE ( 1 , 0 , 0 , 0 , 0 , 0 ) , MODE ( 1 , 0 , 0 , 1 , 1 , 0 ) , MODE ( 1 , 0 , 1 , 1 , 1 , 1 ) , MODE ( 0 , 1 , 0 , 1 , 0 , 1 ) , MODE ( 0 , 1 , 1 , 1 , 1 , 1 ) , MODE ( 0 , 1 , 1 , 0 , 0 , 1 ) , MODE ( 0 , 1 , 0 , 0 , 0 , 0 ) , } ; Ay_Apu :: Ay_Apu ( ) { for ( int m = 8 ; m -- ; ) { byte * out = env . modes [ m ] ; int flags = modes [ m ] ; for ( int x = 3 ; -- x >= 0 ; ) { int amp = flags & 1 ; int end = flags >> 1 & 1 ; int step = end - amp ; amp *= 15 ; for ( int y = 16 ; -- y >= 0 ; ) { * out ++ = amp_table [ amp ] ; amp += step ; } flags >>= 2 ; } } output ( 0 ) ; volume ( 1.0 ) ; reset ( ) ; } void Ay_Apu :: reset ( ) { last_time = 0 ; noise . delay = 0 ; noise . lfsr = 1 ; osc_t * osc = & oscs [ osc_count ] ; do { osc -- ; osc -> period = period_factor ; osc -> delay = 0 ; osc -> last_amp = 0 ; osc -> phase = 0 ; } while ( osc != oscs ) ; for ( int i = sizeof regs ; -- i >= 0 ; ) regs [ i ] = 0 ; regs [ 7 ] = 0xFF ; write_data_ ( 13 , 0 ) ; } void Ay_Apu :: write_data_ ( int addr , int data ) { assert ( ( unsigned ) addr < reg_count ) ; if ( ( unsigned ) addr >= 14 ) { # ifdef debug_printf debug_printf ( " Wrote ▁ to ▁ I / O ▁ port ▁ % 02X \n " , ( int ) addr ) ; # endif } if ( addr == 13 ) { if ( ! ( data & 8 ) ) data = ( data & 4 ) ? 15 : 9 ; env . wave = env . modes [ data - 7 ] ; env . pos = - 48 ; env . delay = 0 ; } regs [ addr ] = data ; int i = addr >> 1 ; if ( i < osc_count ) { blip_time_t period = ( regs [ i * 2 + 1 ] & 0x0F ) * ( 0x100L * period_factor ) + regs [ i * 2 ] * period_factor ; if ( ! period ) period = period_factor ; osc_t & osc = oscs [ i ] ; if ( ( osc . delay += period - osc . period ) < 0 ) osc . delay = 0 ; osc . period = period ; } } int const noise_off = 0x08 ; int const tone_off = 0x01 ; void Ay_Apu :: run_until ( blip_time_t final_end_time ) { require ( final_end_time >= last_time ) ; blip_time_t const noise_period_factor = period_factor * 2 ; blip_time_t noise_period = ( regs [ 6 ] & 0x1F ) * noise_period_factor ; if ( ! noise_period ) noise_period = noise_period_factor ; blip_time_t const old_noise_delay = noise . delay ; blargg_ulong const old_noise_lfsr = noise . lfsr ; blip_time_t const env_period_factor = period_factor * 2 ; blip_time_t env_period = ( regs [ 12 ] * 0x100L + regs [ 11 ] ) * env_period_factor ; if ( ! env_period ) env_period = env_period_factor ; if ( ! env . delay ) env . delay = env_period ; for ( int index = 0 ; index < osc_count ; index ++ ) { osc_t * const osc = & oscs [ index ] ; int osc_mode = regs [ 7 ] >> index ; Blip_Buffer * const osc_output = osc -> output ; if ( ! osc_output ) continue ; osc_output -> set_modified ( ) ; int half_vol = 0 ; blip_time_t inaudible_period = ( blargg_ulong ) ( osc_output -> clock_rate ( ) + inaudible_freq ) / ( inaudible_freq * 2 ) ; if ( osc -> period <= inaudible_period && ! ( osc_mode & tone_off ) ) { half_vol = 1 ; osc_mode |= tone_off ; } blip_time_t start_time = last_time ; blip_time_t end_time = final_end_time ; int const vol_mode = regs [ 0x08 + index ] ; int volume = amp_table [ vol_mode & 0x0F ] >> half_vol ; int osc_env_pos = env . pos ; if ( vol_mode & 0x10 ) { volume = env . wave [ osc_env_pos ] >> half_vol ; if ( ! ( regs [ 13 ] & 1 ) || osc_env_pos < - 32 ) { end_time = start_time + env . delay ; if ( end_time >= final_end_time ) end_time = final_end_time ; } else if ( ! volume ) { osc_mode = noise_off | tone_off ; } } else if ( ! volume ) { osc_mode = noise_off | tone_off ; } blip_time_t const period = osc -> period ; blip_time_t time = start_time + osc -> delay ; if ( osc_mode & tone_off ) { blargg_long count = ( final_end_time - time + period - 1 ) / period ; time += count * period ; osc -> phase ^= count & 1 ; } blip_time_t ntime = final_end_time ; blargg_ulong noise_lfsr = 1 ; if ( ! ( osc_mode & noise_off ) ) { ntime = start_time + old_noise_delay ; noise_lfsr = old_noise_lfsr ; } while ( 1 ) { int amp = 0 ; if ( ( osc_mode | osc -> phase ) & 1 & ( osc_mode >> 3 | noise_lfsr ) ) amp = volume ; { int delta = amp - osc -> last_amp ; if ( delta ) { osc -> last_amp = amp ; synth_ . offset ( start_time , delta , osc_output ) ; } } if ( ntime < end_time || time < end_time ) { int delta = amp * 2 - volume ; int delta_non_zero = delta != 0 ; int phase = osc -> phase | ( osc_mode & tone_off ) ; assert ( tone_off == 0x01 ) ; do { blip_time_t end = end_time ; if ( end_time > time ) end = time ; if ( phase & delta_non_zero ) { while ( ntime <= end ) { int changed = noise_lfsr + 1 ; noise_lfsr = ( - ( noise_lfsr & 1 ) & 0x12000 ) ^ ( noise_lfsr >> 1 ) ; if ( changed & 2 ) { delta = - delta ; synth_ . offset ( ntime , delta , osc_output ) ; } ntime += noise_period ; } } else { blargg_long remain = end - ntime ; blargg_long count = remain / noise_period ; if ( remain >= 0 ) ntime += noise_period + count * noise_period ; } end = end_time ; if ( end_time > ntime ) end = ntime ; if ( noise_lfsr & delta_non_zero ) { while ( time < end ) { delta = - delta ; synth_ . offset ( time , delta , osc_output ) ; time += period ; } phase = unsigned ( - delta ) >> ( CHAR_BIT * sizeof ( unsigned ) - 1 ) ; } else { while ( time < end ) { time += period ; phase ^= 1 ; } } } while ( time < end_time || ntime < end_time ) ; osc -> last_amp = ( delta + volume ) >> 1 ; if ( ! ( osc_mode & tone_off ) ) osc -> phase = phase ; } if ( end_time >= final_end_time ) break ; if ( ++ osc_env_pos >= 0 ) osc_env_pos -= 32 ; volume = env . wave [ osc_env_pos ] >> half_vol ; start_time = end_time ; end_time += env_period ; if ( end_time > final_end_time ) end_time = final_end_time ; } osc -> delay = time - final_end_time ; if ( ! ( osc_mode & noise_off ) ) { noise . delay = ntime - final_end_time ; noise . lfsr = noise_lfsr ; } } blip_time_t remain = final_end_time - last_time - env . delay ; if ( remain >= 0 ) { blargg_long count = ( remain + env_period ) / env_period ; env . pos += count ; if ( env . pos >= 0 ) env . pos = ( env . pos & 31 ) - 32 ; remain -= count * env_period ; assert ( - remain <= env_period ) ; } env . delay = - remain ; assert ( env . delay > 0 ) ; assert ( env . pos < 0 ) ; last_time = final_end_time ; } </DOCUMENT>
<DOCUMENT_ID="bombehub/PPR_PPV/tree/master/Snap-3.0/snap-exp/test-dev/ExplicitStringTableTest2.cpp"> # include " Snap . h " # include < cstring > # include " BenchmarkUtilities . h " int main ( int argc , char * * argv ) { TBool debug = false ; TStr TagsFnm = " / lfs / madmax4/0 / yonathan / tags " ; if ( debug ) { TagsFnm = " / lfs / madmax4/0 / yonathan / tags _ small " ; } Schema TagS ; TagS . Add ( TPair < TStr , TAttrType > ( " UserId " , atInt ) ) ; TagS . Add ( TPair < TStr , TAttrType > ( " Tag " , atStr ) ) ; float ft_max ; float mu_max ; timeval timer4 ; gettimeofday ( & timer4 , NULL ) ; double t1 = timer4 . tv_sec + ( timer4 . tv_usec / 1000000.0 ) ; PExplicitStringTable ES_Tags = ExplicitStringTable :: LoadSS ( TagS , TagsFnm + " . tsv " ) ; gettimeofday ( & timer4 , NULL ) ; double t2 = timer4 . tv_sec + ( timer4 . tv_usec / 1000000.0 ) ; printf ( " Time ▁ to ▁ load ▁ tags ▁ table : ▁ % f \n " , t2 - t1 ) ; printf ( " Table ▁ Size : \n " ) ; ES_Tags -> PrintSize ( ) ; getmaxcpumem ( & ft_max , & mu_max ) ; printf ( " time : ▁ % 0.3f ▁ seconds , ▁ memory : ▁ % 0.3f ▁ MB \n " , ft_max , mu_max ) ; printf ( " \n " ) ; timeval timer6 ; gettimeofday ( & timer6 , NULL ) ; t1 = timer6 . tv_sec + ( timer6 . tv_usec / 1000000.0 ) ; PExplicitStringTable ES_TagsJoinUser = ES_Tags -> SelfJoin ( " UserId " ) ; gettimeofday ( & timer6 , NULL ) ; t2 = timer6 . tv_sec + ( timer6 . tv_usec / 1000000.0 ) ; printf ( " Time ▁ to ▁ join ▁ on ▁ user ▁ id ▁ column : ▁ % f \n " , t2 - t1 ) ; printf ( " Table ▁ Size : \n " ) ; ES_TagsJoinUser -> PrintSize ( ) ; if ( debug ) { ES_TagsJoinUser -> SaveSS ( TagsFnm + " _ join _ user _ es . tsv " ) ; } getmaxcpumem ( & ft_max , & mu_max ) ; printf ( " time : ▁ % 0.3f ▁ seconds , ▁ memory : ▁ % 0.3f ▁ MB \n " , ft_max , mu_max ) ; printf ( " \n " ) ; timeval timer7 ; gettimeofday ( & timer7 , NULL ) ; t1 = timer7 . tv_sec + ( timer7 . tv_usec / 1000000.0 ) ; PExplicitStringTable ES_JavaTags = ExplicitStringTable :: New ( TagS ) ; TIntV SelectedRows1 ; if ( debug ) { ES_Tags -> SelectAtomicConst ( TStr ( " Tag " ) , TStr ( " c # " ) , EQ , SelectedRows1 , ES_JavaTags , false , true ) ; } else { ES_Tags -> SelectAtomicConst ( TStr ( " Tag " ) , TStr ( " java " ) , EQ , SelectedRows1 , ES_JavaTags , false , true ) ; } gettimeofday ( & timer7 , NULL ) ; t2 = timer7 . tv_sec + ( timer7 . tv_usec / 1000000.0 ) ; printf ( " Time ▁ to ▁ select ▁ java ▁ users : ▁ % f \n " , t2 - t1 ) ; printf ( " Table ▁ Size : \n " ) ; ES_JavaTags -> PrintSize ( ) ; if ( debug ) { ES_JavaTags -> SaveSS ( TagsFnm + " _ select _ es . tsv " ) ; } getmaxcpumem ( & ft_max , & mu_max ) ; printf ( " time : ▁ % 0.3f ▁ seconds , ▁ memory : ▁ % 0.3f ▁ MB \n " , ft_max , mu_max ) ; printf ( " \n " ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="SlavaRa/coreclr/tree/master/src/binder/variables.cpp"> # include " variables . hpp " # include " ex . h " namespace BINDER_SPACE { # ifdef FEATURE_VERSIONING_LOG namespace { HRESULT CheckFileExistence ( LPCWSTR pwzFile , LPDWORD pdwAttrib ) { HRESULT hr = S_FALSE ; DWORD dwRet = 0 ; _ASSERTE ( pwzFile && pdwAttrib ) ; * pdwAttrib = 0 ; dwRet = WszGetFileAttributes ( pwzFile ) ; if ( dwRet == INVALID_FILE_ATTRIBUTES ) { hr = HRESULT_FROM_GetLastError ( ) ; if ( ( hr == HRESULT_FROM_WIN32 ( ERROR_FILE_NOT_FOUND ) ) || ( hr == HRESULT_FROM_WIN32 ( ERROR_PATH_NOT_FOUND ) ) ) { GO_WITH_HRESULT ( S_FALSE ) ; } } else { * pdwAttrib = dwRet ; GO_WITH_HRESULT ( S_OK ) ; } Exit : return hr ; } } ; # endif Variables * g_BinderVariables = NULL ; Variables :: Variables ( ) { } Variables :: ~ Variables ( ) { } HRESULT Variables :: Init ( ) { HRESULT hr = S_OK ; EX_TRY { httpURLPrefix . SetLiteral ( W ( " http : // " ) ) ; architectureMSIL . SetLiteral ( W ( " MSIL " ) ) ; architectureX86 . SetLiteral ( W ( " x86" ) ) ; architectureAMD64 . SetLiteral ( W ( " AMD64" ) ) ; architectureARM . SetLiteral ( W ( " ARM " ) ) ; architectureARM64 . SetLiteral ( W ( " ARM64" ) ) ; cultureNeutral . SetLiteral ( W ( " neutral " ) ) ; mscorlib . SetLiteral ( W ( " mscorlib " ) ) ; emptyString . Clear ( ) ; # ifdef FEATURE_VERSIONING_LOG REGUTIL :: CORConfigLevel kCorConfigLevel = static_cast < REGUTIL :: CORConfigLevel > ( REGUTIL :: COR_CONFIG_ENV | REGUTIL :: COR_CONFIG_FUSION ) ; DWORD dwLoggingNeeded = REGUTIL :: GetConfigDWORD_DontUse_ ( CLRConfig :: EXTERNAL_ForceLog , 0 , kCorConfigLevel , TRUE ) ; fLoggingNeeded = ( dwLoggingNeeded ? TRUE : FALSE ) ; NewArrayHolder < WCHAR > pwzLogDirectory = REGUTIL :: GetConfigString_DontUse_ ( CLRConfig :: INTERNAL_LogPath , TRUE , kCorConfigLevel , FALSE ) ; if ( pwzLogDirectory == NULL ) { fLoggingNeeded = FALSE ; } else { DWORD dwAttr = 0 ; hr = CheckFileExistence ( pwzLogDirectory , & dwAttr ) ; if ( ( hr == S_OK ) && ( ( dwAttr & FILE_ATTRIBUTE_DIRECTORY ) != 0 ) ) { logPath . Set ( pwzLogDirectory ) ; } else { hr = S_OK ; fLoggingNeeded = FALSE ; } } # endif } EX_CATCH_HRESULT ( hr ) ; return hr ; } } ; </DOCUMENT>
<DOCUMENT_ID="zaclimon/android_kernel_samsung_kylepro/tree/master/tools/gator/daemon/LocalCapture.cpp"> # include < sys / stat . h > # include < sys / types . h > # include < dirent . h > # include < string . h > # include < stdlib . h > # include < unistd . h > # include " LocalCapture . h " # include " SessionData . h " # include " Logging . h " # include " OlyUtility . h " # include " EventsXML . h " LocalCapture :: LocalCapture ( ) { } LocalCapture :: ~ LocalCapture ( ) { } void LocalCapture :: createAPCDirectory ( char * target_path ) { gSessionData -> mAPCDir = createUniqueDirectory ( target_path , " . apc " ) ; if ( ( removeDirAndAllContents ( gSessionData -> mAPCDir ) != 0 || mkdir ( gSessionData -> mAPCDir , S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH ) != 0 ) ) { logg -> logError ( __FILE__ , __LINE__ , " Unable ▁ to ▁ create ▁ directory ▁ % s " , gSessionData -> mAPCDir ) ; handleException ( ) ; } } void LocalCapture :: write ( char * string ) { char file [ PATH_MAX ] ; snprintf ( file , PATH_MAX , " % s / session . xml " , gSessionData -> mAPCDir ) ; if ( util -> writeToDisk ( file , string ) < 0 ) { logg -> logError ( __FILE__ , __LINE__ , " Error ▁ writing ▁ % s \n Please ▁ verify ▁ the ▁ path . " , file ) ; handleException ( ) ; } EventsXML eventsXML ; eventsXML . write ( gSessionData -> mAPCDir ) ; } char * LocalCapture :: createUniqueDirectory ( const char * initialPath , const char * ending ) { char * output ; char path [ PATH_MAX ] ; if ( initialPath == 0 || strlen ( initialPath ) == 0 ) { logg -> logError ( __FILE__ , __LINE__ , " Missing ▁ - o ▁ command ▁ line ▁ option ▁ required ▁ for ▁ a ▁ local ▁ capture . " ) ; handleException ( ) ; } else if ( initialPath [ 0 ] != ' / ' ) { if ( getcwd ( path , PATH_MAX ) == 0 ) { logg -> logMessage ( " Unable ▁ to ▁ retrieve ▁ the ▁ current ▁ working ▁ directory " ) ; } strncat ( path , " / " , PATH_MAX - strlen ( path ) - 1 ) ; strncat ( path , initialPath , PATH_MAX - strlen ( path ) - 1 ) ; } else { strncpy ( path , initialPath , PATH_MAX ) ; path [ PATH_MAX - 1 ] = 0 ; } if ( strcmp ( & path [ strlen ( path ) - strlen ( ending ) ] , ending ) != 0 ) { strncat ( path , ending , PATH_MAX - strlen ( path ) - 1 ) ; } output = strdup ( path ) ; return output ; } int LocalCapture :: removeDirAndAllContents ( char * path ) { int error = 0 ; struct stat mFileInfo ; if ( stat ( path , & mFileInfo ) == 0 ) { if ( mFileInfo . st_mode & S_IFDIR ) { DIR * dir = opendir ( path ) ; dirent * entry = readdir ( dir ) ; while ( entry ) { if ( strcmp ( entry -> d_name , " . " ) != 0 && strcmp ( entry -> d_name , " . . " ) != 0 ) { char * newpath = ( char * ) malloc ( strlen ( path ) + strlen ( entry -> d_name ) + 2 ) ; sprintf ( newpath , " % s / % s " , path , entry -> d_name ) ; error = removeDirAndAllContents ( newpath ) ; free ( newpath ) ; if ( error ) { break ; } } entry = readdir ( dir ) ; } closedir ( dir ) ; if ( error == 0 ) { error = rmdir ( path ) ; } } else { error = remove ( path ) ; } } return error ; } void LocalCapture :: copyImages ( ImageLinkList * ptr ) { char dstfilename [ PATH_MAX ] ; while ( ptr ) { strncpy ( dstfilename , gSessionData -> mAPCDir , PATH_MAX ) ; dstfilename [ PATH_MAX - 1 ] = 0 ; if ( gSessionData -> mAPCDir [ strlen ( gSessionData -> mAPCDir ) - 1 ] != ' / ' ) { strncat ( dstfilename , " / " , PATH_MAX - strlen ( dstfilename ) - 1 ) ; } strncat ( dstfilename , util -> getFilePart ( ptr -> path ) , PATH_MAX - strlen ( dstfilename ) - 1 ) ; if ( util -> copyFile ( ptr -> path , dstfilename ) ) { logg -> logMessage ( " copied ▁ file ▁ % s ▁ to ▁ % s " , ptr -> path , dstfilename ) ; } else { logg -> logMessage ( " copy ▁ of ▁ file ▁ % s ▁ to ▁ % s ▁ failed " , ptr -> path , dstfilename ) ; } ptr = ptr -> next ; } } </DOCUMENT>
<DOCUMENT_ID="zeliard/aws-sdk-cpp/tree/master/aws-cpp-sdk-iam/source/model/ListGroupsRequest.cpp"> # include < aws / iam / model / ListGroupsRequest . h > # include < aws / core / utils / StringUtils . h > # include < aws / core / utils / memory / stl / AWSStringStream . h > using namespace Aws :: IAM :: Model ; using namespace Aws :: Utils ; ListGroupsRequest :: ListGroupsRequest ( ) : m_pathPrefixHasBeenSet ( false ) , m_markerHasBeenSet ( false ) , m_maxItems ( 0 ) , m_maxItemsHasBeenSet ( false ) { } Aws :: String ListGroupsRequest :: SerializePayload ( ) const { Aws :: StringStream ss ; ss << " Action = ListGroups & " ; if ( m_pathPrefixHasBeenSet ) { ss << " PathPrefix = " << StringUtils :: URLEncode ( m_pathPrefix . c_str ( ) ) << " & " ; } if ( m_markerHasBeenSet ) { ss << " Marker = " << StringUtils :: URLEncode ( m_marker . c_str ( ) ) << " & " ; } if ( m_maxItemsHasBeenSet ) { ss << " MaxItems = " << m_maxItems << " & " ; } ss << " Version = 2010-05-08" ; return ss . str ( ) ; } </DOCUMENT>
<DOCUMENT_ID="YelaSeamless/mysql-server/tree/master/storage/ndb/test/ndbapi/testLimits.cpp"> # include < NDBT . hpp > # include < NDBT_Test . hpp > # include < NdbRestarter . hpp > # define CHECKNOTNULL ( p ) if ( ( p ) == NULL ) { ndbout << " Error ▁ at ▁ line ▁ " << __LINE__ << endl ; NDB_ERR ( trans -> getNdbError ( ) ) ; trans -> close ( ) ; return NDBT_FAILED ; } # define CHECKEQUAL ( v , e ) if ( ( e ) != ( v ) ) { ndbout << " Error ▁ at ▁ line ▁ " << __LINE__ << " ▁ expected ▁ " << v << endl ; NDB_ERR ( trans -> getNdbError ( ) ) ; trans -> close ( ) ; return NDBT_FAILED ; } Uint32 setLongVarchar ( char * where , const char * what , Uint32 sz ) { where [ 0 ] = sz & 0xff ; where [ 1 ] = ( sz >> 8 ) & 0xff ; memcpy ( & where [ 2 ] , what , sz ) ; return ( sz + 2 ) ; } int activateErrorInsert ( NdbTransaction * trans , const NdbRecord * record , const NdbDictionary :: Table * tab , const char * buf , NdbRestarter * restarter , Uint32 val ) { if ( restarter -> insertErrorInAllNodes ( val ) != 0 ) { g_err << " error ▁ insert ▁ 1 ▁ ( " << val << " ) ▁ failed " << endl ; return NDBT_FAILED ; } if ( restarter -> insertErrorInAllNodes ( val ) != 0 ) { g_err << " error ▁ insert ▁ 2 ▁ ( " << val << " ) ▁ failed " << endl ; return NDBT_FAILED ; } NdbOperation * insert = trans -> getNdbOperation ( tab ) ; CHECKNOTNULL ( insert ) ; CHECKEQUAL ( 0 , insert -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , insert -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , buf , 0 ) ) ) ; CHECKEQUAL ( 0 , insert -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , buf , 1 ) ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; return NDBT_OK ; } int testSegmentedSectionPk ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " WIDE _ 2COL " ) != 0 ) return NDBT_OK ; const Uint32 maxRowBytes = NDB_MAX_TUPLE_SIZE_IN_WORDS * sizeof ( Uint32 ) ; const Uint32 maxKeyBytes = NDBT_Tables :: MaxVarTypeKeyBytes ; const Uint32 maxAttrBytes = NDBT_Tables :: MaxKeyMaxVarTypeAttrBytes ; const Uint32 srcBuffBytes = MAX ( maxKeyBytes , maxAttrBytes ) ; char smallKey [ 50 ] ; char srcBuff [ srcBuffBytes ] ; char smallRowBuf [ maxRowBytes ] ; char bigKeyRowBuf [ maxRowBytes ] ; char bigAttrRowBuf [ maxRowBytes ] ; Uint32 smallKeySize = setLongVarchar ( & smallKey [ 0 ] , " ShortKey " , 8 ) ; memset ( srcBuff , ' B ' , srcBuffBytes ) ; const NdbRecord * record = ctx -> getTab ( ) -> getDefaultRecord ( ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , smallRowBuf , 0 ) , " ShortKey " , 8 ) ; NdbDictionary :: setNull ( record , smallRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , smallRowBuf , 1 ) , " ShortData " , 9 ) ; NdbDictionary :: setNull ( record , smallRowBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , bigKeyRowBuf , 0 ) , & srcBuff [ 0 ] , maxKeyBytes ) ; NdbDictionary :: setNull ( record , bigKeyRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , bigKeyRowBuf , 1 ) , " ShortData " , 9 ) ; NdbDictionary :: setNull ( record , bigKeyRowBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , bigAttrRowBuf , 0 ) , " ShortKey " , 8 ) ; NdbDictionary :: setNull ( record , bigAttrRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , bigAttrRowBuf , 1 ) , & srcBuff [ 0 ] , maxAttrBytes ) ; NdbDictionary :: setNull ( record , bigAttrRowBuf , 1 , false ) ; NdbRestarter restarter ; Ndb * pNdb = GETNDB ( step ) ; NdbTransaction * trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ; CHECKNOTNULL ( trans ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , record , ctx -> getTab ( ) , smallRowBuf , & restarter , 8065 ) ) ; const NdbOperation * bigInsert = trans -> insertTuple ( record , bigKeyRowBuf ) ; CHECKNOTNULL ( bigInsert ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsert = trans -> insertTuple ( record , bigAttrRowBuf ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsert = trans -> insertTuple ( record , bigAttrRowBuf ) ) ; const NdbOperation * secondOp ; CHECKNOTNULL ( secondOp = trans -> insertTuple ( record , bigAttrRowBuf ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; NdbOperation * bigInsertOldApi ; CHECKNOTNULL ( bigInsertOldApi = trans -> getNdbOperation ( ctx -> getTab ( ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , bigKeyRowBuf , 0 ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , bigKeyRowBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsertOldApi = trans -> getNdbOperation ( ctx -> getTab ( ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , bigAttrRowBuf , 0 ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , bigAttrRowBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; # if 0 restarter . insertErrorInAllNodes ( 8066 ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsertOldApi = trans -> getNdbOperation ( ctx -> getTab ( ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , smallRowBuf , 0 ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; restarter . insertErrorInAllNodes ( 8067 ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsertOldApi = trans -> getNdbOperation ( ctx -> getTab ( ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , smallRowBuf , 0 ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; # endif CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , record , ctx -> getTab ( ) , smallRowBuf , & restarter , 8068 ) ) ; trans -> execute ( NdbTransaction :: Rollback ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; return NDBT_OK ; } int testSegmentedSectionIx ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " WIDE _ 2COL _ IX " ) != 0 ) return NDBT_OK ; const char * indexName = " WIDE _ 2COL _ IX $ NDBT _ IDX0" ; const Uint32 maxRowBytes = NDB_MAX_TUPLE_SIZE_IN_WORDS * sizeof ( Uint32 ) ; const Uint32 srcBuffBytes = NDBT_Tables :: MaxVarTypeKeyBytes ; const Uint32 maxIndexKeyBytes = NDBT_Tables :: MaxKeyMaxVarTypeAttrBytesIndex ; const Uint32 mediumPrimaryKeyBytes = ( 6 * 60 * 4 ) - 2 ; char smallKey [ 50 ] ; char srcBuff [ srcBuffBytes ] ; char smallRowBuf [ maxRowBytes ] ; char bigKeyIxBuf [ maxRowBytes ] ; char bigAttrIxBuf [ maxRowBytes ] ; char bigKeyRowBuf [ maxRowBytes ] ; char resultSpace [ maxRowBytes ] ; Uint32 smallKeySize = setLongVarchar ( & smallKey [ 0 ] , " ShortKey " , 8 ) ; memset ( srcBuff , ' B ' , srcBuffBytes ) ; Ndb * pNdb = GETNDB ( step ) ; const NdbRecord * baseRecord = ctx -> getTab ( ) -> getDefaultRecord ( ) ; const NdbRecord * ixRecord = pNdb -> getDictionary ( ) -> getIndex ( indexName , ctx -> getTab ( ) -> getName ( ) ) -> getDefaultRecord ( ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 0 ) , " ShortKey " , 8 ) ; NdbDictionary :: setNull ( baseRecord , smallRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 1 ) , " ShortData " , 9 ) ; NdbDictionary :: setNull ( baseRecord , smallRowBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( ixRecord , bigKeyIxBuf , 1 ) , & srcBuff [ 0 ] , maxIndexKeyBytes ) ; NdbDictionary :: setNull ( ixRecord , bigKeyIxBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 0 ) , " ShortIXKey " , 10 ) ; NdbDictionary :: setNull ( baseRecord , bigAttrIxBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 1 ) , & srcBuff [ 0 ] , maxIndexKeyBytes ) ; NdbDictionary :: setNull ( baseRecord , bigAttrIxBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , bigKeyRowBuf , 0 ) , & srcBuff [ 0 ] , mediumPrimaryKeyBytes ) ; NdbDictionary :: setNull ( baseRecord , bigKeyRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , bigKeyRowBuf , 1 ) , " ShortIXKey " , 10 ) ; NdbDictionary :: setNull ( baseRecord , bigKeyRowBuf , 1 , false ) ; NdbTransaction * trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ; CHECKNOTNULL ( trans -> insertTuple ( baseRecord , bigKeyRowBuf ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: Commit ) ) ; NdbRestarter restarter ; trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ; CHECKNOTNULL ( trans ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , baseRecord , ctx -> getTab ( ) , smallRowBuf , & restarter , 8065 ) ) ; const NdbOperation * bigRead = trans -> readTuple ( ixRecord , bigKeyIxBuf , baseRecord , resultSpace ) ; CHECKNOTNULL ( bigRead ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( trans -> readTuple ( ixRecord , bigKeyIxBuf , baseRecord , resultSpace ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( trans -> readTuple ( ixRecord , bigKeyIxBuf , baseRecord , resultSpace ) ) ; CHECKNOTNULL ( trans -> readTuple ( ixRecord , bigKeyIxBuf , baseRecord , resultSpace ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , baseRecord , ctx -> getTab ( ) , smallRowBuf , & restarter , 8066 ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKNOTNULL ( bigRead = trans -> readTuple ( ixRecord , bigAttrIxBuf , baseRecord , resultSpace ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; # if 0 CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; const NdbDictionary :: Index * index ; CHECKNOTNULL ( index = pNdb -> getDictionary ( ) -> getIndex ( indexName , ctx -> getTab ( ) -> getName ( ) ) ) ; NdbIndexOperation * bigReadOldApi ; CHECKNOTNULL ( bigReadOldApi = trans -> getNdbIndexOperation ( index ) ) ; CHECKEQUAL ( 0 , bigReadOldApi -> readTuple ( ) ) ; CHECKEQUAL ( 0 , bigReadOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( ixRecord , bigKeyIxBuf , 1 ) ) ) ; CHECKNOTNULL ( bigReadOldApi -> getValue ( ( Uint32 ) 1 ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; NdbIndexOperation * bigUpdateOldApi ; CHECKNOTNULL ( bigUpdateOldApi = trans -> getNdbIndexOperation ( index ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> updateTuple ( ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> setValue ( ( Uint32 ) 1 , NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; restarter . insertErrorInAllNodes ( 8066 ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigUpdateOldApi = trans -> getNdbIndexOperation ( index ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> updateTuple ( ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> setValue ( ( Uint32 ) 1 , NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; restarter . insertErrorInAllNodes ( 8067 ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigUpdateOldApi = trans -> getNdbIndexOperation ( index ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> updateTuple ( ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> setValue ( ( Uint32 ) 1 , NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; # endif CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , baseRecord , ctx -> getTab ( ) , smallRowBuf , & restarter , 8068 ) ) ; trans -> execute ( NdbTransaction :: Rollback ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; return NDBT_OK ; } int testSegmentedSectionScan ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " WIDE _ 2COL " ) != 0 ) return NDBT_OK ; const Uint32 maxRowBytes = NDB_MAX_TUPLE_SIZE_IN_WORDS * sizeof ( Uint32 ) ; char smallKey [ 50 ] ; char smallRowBuf [ maxRowBytes ] ; Uint32 smallKeySize = setLongVarchar ( & smallKey [ 0 ] , " ShortKey " , 8 ) ; const NdbRecord * record = ctx -> getTab ( ) -> getDefaultRecord ( ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , smallRowBuf , 0 ) , " ShortKey " , 8 ) ; NdbDictionary :: setNull ( record , smallRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , smallRowBuf , 1 ) , " ShortData " , 9 ) ; NdbDictionary :: setNull ( record , smallRowBuf , 1 , false ) ; NdbRestarter restarter ; Ndb * pNdb = GETNDB ( step ) ; NdbTransaction * trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ; CHECKNOTNULL ( trans ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , record , ctx -> getTab ( ) , smallRowBuf , & restarter , 8066 ) ) ; NdbScanOperation * scan = trans -> getNdbScanOperation ( ctx -> getTab ( ) ) ; CHECKNOTNULL ( scan ) ; CHECKEQUAL ( 0 , scan -> readTuples ( ) ) ; NdbInterpretedCode prog ; for ( Uint32 w = 0 ; w < 2500 ; w ++ ) CHECKEQUAL ( 0 , prog . load_const_null ( 1 ) ) ; CHECKEQUAL ( 0 , prog . interpret_exit_ok ( ) ) ; CHECKEQUAL ( 0 , prog . finalise ( ) ) ; CHECKEQUAL ( 0 , scan -> setInterpretedCode ( & prog ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; CHECKEQUAL ( - 1 , scan -> nextResult ( ) ) ; CHECKEQUAL ( 217 , scan -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , record , ctx -> getTab ( ) , smallRowBuf , & restarter , 8068 ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: Rollback ) ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; return NDBT_OK ; } int testDropSignalFragments ( NDBT_Context * ctx , NDBT_Step * step ) { NdbRestarter restarter ; Ndb * pNdb = GETNDB ( step ) ; const Uint32 PROG_WORDS = 16500 ; struct SubCase { Uint32 errorInsertCode ; int expectedRc ; } ; const Uint32 numSubCases = 5 ; const SubCase cases [ numSubCases ] = { { 0 , 874 } , { 8074 , 217 } , { 8075 , 217 } , { 8076 , 217 } , { 8077 , 217 } } ; const Uint32 numIterations = 50 ; Uint32 buff [ PROG_WORDS + 10 ] ; for ( Uint32 iteration = 0 ; iteration < ( numIterations * numSubCases ) ; iteration ++ ) { NdbTransaction * trans = pNdb -> startTransaction ( ) ; CHECKNOTNULL ( trans ) ; SubCase subcase = cases [ iteration % numSubCases ] ; Uint32 errorInsertVal = subcase . errorInsertCode ; CHECKEQUAL ( 0 , restarter . insertErrorInAllNodes ( errorInsertVal ) ) ; CHECKEQUAL ( 0 , restarter . insertErrorInAllNodes ( errorInsertVal ) ) ; NdbScanOperation * scan = trans -> getNdbScanOperation ( ctx -> getTab ( ) ) ; CHECKNOTNULL ( scan ) ; CHECKEQUAL ( 0 , scan -> readTuples ( ) ) ; NdbInterpretedCode prog ( ctx -> getTab ( ) , buff , PROG_WORDS + 10 ) ; for ( Uint32 w = 0 ; w < PROG_WORDS ; w ++ ) CHECKEQUAL ( 0 , prog . load_const_null ( 1 ) ) ; CHECKEQUAL ( 0 , prog . interpret_exit_ok ( ) ) ; CHECKEQUAL ( 0 , prog . finalise ( ) ) ; CHECKEQUAL ( 0 , scan -> setInterpretedCode ( & prog ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; CHECKEQUAL ( - 1 , scan -> nextResult ( ) ) ; int expectedResult = subcase . expectedRc ; CHECKEQUAL ( expectedResult , scan -> getNdbError ( ) . code ) ; scan -> close ( ) ; trans -> close ( ) ; } restarter . insertErrorInAllNodes ( 0 ) ; return NDBT_OK ; } int create100Tables ( NDBT_Context * ctx , NDBT_Step * step ) { Ndb * pNdb = GETNDB ( step ) ; const NdbDictionary :: Table * pTab = ctx -> getTab ( ) ; if ( strcmp ( pTab -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; for ( Uint32 t = 0 ; t < 100 ; t ++ ) { char tabnameBuff [ 10 ] ; snprintf ( tabnameBuff , sizeof ( tabnameBuff ) , " TAB % u " , t ) ; NdbDictionary :: Table tab ; tab . setName ( tabnameBuff ) ; NdbDictionary :: Column pk ; pk . setName ( " PK " ) ; pk . setType ( NdbDictionary :: Column :: Varchar ) ; pk . setLength ( 20 ) ; pk . setNullable ( false ) ; pk . setPrimaryKey ( true ) ; tab . addColumn ( pk ) ; pNdb -> getDictionary ( ) -> dropTable ( tab . getName ( ) ) ; if ( pNdb -> getDictionary ( ) -> createTable ( tab ) != 0 ) { ndbout << " Create ▁ table ▁ failed ▁ with ▁ error ▁ : ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . code << " ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . message << endl ; return NDBT_FAILED ; } ndbout << " Created ▁ table ▁ " << tabnameBuff << endl ; } return NDBT_OK ; } int drop100Tables ( NDBT_Context * ctx , NDBT_Step * step ) { Ndb * pNdb = GETNDB ( step ) ; const NdbDictionary :: Table * pTab = ctx -> getTab ( ) ; if ( strcmp ( pTab -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; for ( Uint32 t = 0 ; t < 100 ; t ++ ) { char tabnameBuff [ 10 ] ; snprintf ( tabnameBuff , sizeof ( tabnameBuff ) , " TAB % u " , t ) ; if ( pNdb -> getDictionary ( ) -> dropTable ( tabnameBuff ) != 0 ) { ndbout << " Drop ▁ table ▁ failed ▁ with ▁ error ▁ : ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . code << " ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . message << endl ; } else { ndbout << " Dropped ▁ table ▁ " << tabnameBuff << endl ; } } return NDBT_OK ; } int dropTable ( NDBT_Context * ctx , NDBT_Step * step , Uint32 num ) { Ndb * pNdb = GETNDB ( step ) ; const NdbDictionary :: Table * pTab = ctx -> getTab ( ) ; if ( strcmp ( pTab -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; char tabnameBuff [ 10 ] ; snprintf ( tabnameBuff , sizeof ( tabnameBuff ) , " TAB % u " , num ) ; if ( pNdb -> getDictionary ( ) -> dropTable ( tabnameBuff ) != 0 ) { ndbout << " Drop ▁ table ▁ failed ▁ with ▁ error ▁ : ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . code << " ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . message << endl ; } else { ndbout << " Dropped ▁ table ▁ " << tabnameBuff << endl ; } return NDBT_OK ; } enum Scenarios { DROP_TABLE , RESTART_MASTER , RESTART_SLAVE , NUM_SCENARIOS } ; enum Tasks { WAIT = 0 , DROP_TABLE_REQ = 1 , MASTER_RESTART_REQ = 2 , SLAVE_RESTART_REQ = 3 } ; int testWorker ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; while ( ! ctx -> isTestStopped ( ) ) { ndbout_c ( " Worker ▁ : ▁ waiting ▁ for ▁ request . . . " ) ; ctx -> getPropertyWait ( " DIHWritesRequest " , 1 ) ; if ( ! ctx -> isTestStopped ( ) ) { Uint32 req = ctx -> getProperty ( " DIHWritesRequestType " , ( Uint32 ) 0 ) ; switch ( ( Tasks ) req ) { case DROP_TABLE_REQ : { ndbout_c ( " Worker ▁ : ▁ dropping ▁ table " ) ; if ( dropTable ( ctx , step , 2 ) != NDBT_OK ) { return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ table ▁ dropped . " ) ; break ; } case MASTER_RESTART_REQ : { ndbout_c ( " Worker ▁ : ▁ restarting ▁ Master " ) ; NdbRestarter restarter ; int master_nodeid = restarter . getMasterNodeId ( ) ; ndbout_c ( " Worker ▁ : ▁ Restarting ▁ Master ▁ ( % d ) . . . " , master_nodeid ) ; if ( restarter . restartOneDbNode2 ( master_nodeid , NdbRestarter :: NRRF_NOSTART | NdbRestarter :: NRRF_FORCE | NdbRestarter :: NRRF_ABORT ) || restarter . waitNodesNoStart ( & master_nodeid , 1 ) || restarter . startAll ( ) ) { ndbout_c ( " Worker ▁ : ▁ Error ▁ restarting ▁ Master . " ) ; return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ Waiting ▁ for ▁ master ▁ to ▁ recover . . . " ) ; if ( restarter . waitNodesStarted ( & master_nodeid , 1 ) ) { ndbout_c ( " Worker ▁ : ▁ Error ▁ waiting ▁ for ▁ Master ▁ restart " ) ; return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ Master ▁ recovered . " ) ; break ; } case SLAVE_RESTART_REQ : { NdbRestarter restarter ; int slave_nodeid = restarter . getRandomNotMasterNodeId ( rand ( ) ) ; ndbout_c ( " Worker ▁ : ▁ Restarting ▁ non - master ▁ ( % d ) . . . " , slave_nodeid ) ; if ( restarter . restartOneDbNode2 ( slave_nodeid , NdbRestarter :: NRRF_NOSTART | NdbRestarter :: NRRF_FORCE | NdbRestarter :: NRRF_ABORT ) || restarter . waitNodesNoStart ( & slave_nodeid , 1 ) || restarter . startAll ( ) ) { ndbout_c ( " Worker ▁ : ▁ Error ▁ restarting ▁ Slave . " ) ; return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ Waiting ▁ for ▁ slave ▁ to ▁ recover . . . " ) ; if ( restarter . waitNodesStarted ( & slave_nodeid , 1 ) ) { ndbout_c ( " Worker ▁ : ▁ Error ▁ waiting ▁ for ▁ Slave ▁ restart " ) ; return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ Slave ▁ recovered . " ) ; break ; } default : { break ; } } } ctx -> setProperty ( " DIHWritesRequestType " , ( Uint32 ) 0 ) ; ctx -> setProperty ( " DIHWritesRequest " , ( Uint32 ) 2 ) ; } ndbout_c ( " Worker , ▁ done . " ) ; return NDBT_OK ; } int testSlowDihFileWrites ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; NdbRestarter restarter ; for ( Uint32 scenario = 0 ; scenario < NUM_SCENARIOS ; scenario ++ ) { ndbout_c ( " Inserting ▁ error ▁ 7235" ) ; restarter . insertErrorInAllNodes ( 7235 ) ; ndbout_c ( " Triggering ▁ LCP " ) ; int dumpArg = 7099 ; restarter . dumpStateAllNodes ( & dumpArg , 1 ) ; const Uint32 periodSeconds = 10 ; Uint32 waitPeriods = 6 ; dumpArg = 7032 ; for ( Uint32 p = 0 ; p < waitPeriods ; p ++ ) { if ( p == 3 ) { switch ( ( Scenarios ) scenario ) { case DROP_TABLE : { ndbout_c ( " Requesting ▁ DROP ▁ TABLE " ) ; ctx -> setProperty ( " DIHWritesRequestType " , ( Uint32 ) DROP_TABLE_REQ ) ; ctx -> setProperty ( " DIHWritesRequest " , ( Uint32 ) 1 ) ; break ; } case RESTART_MASTER : { ndbout_c ( " Requesting ▁ Master ▁ restart " ) ; ctx -> setProperty ( " DIHWritesRequestType " , ( Uint32 ) MASTER_RESTART_REQ ) ; ctx -> setProperty ( " DIHWritesRequest " , ( Uint32 ) 1 ) ; break ; } case RESTART_SLAVE : { ndbout_c ( " Requesting ▁ Slave ▁ restart " ) ; ctx -> setProperty ( " DIHWritesRequestType " , ( Uint32 ) SLAVE_RESTART_REQ ) ; ctx -> setProperty ( " DIHWritesRequest " , ( Uint32 ) 1 ) ; break ; } default : break ; } } ndbout_c ( " Dumping ▁ DIH ▁ page ▁ info ▁ to ▁ ndbd ▁ stdout " ) ; restarter . dumpStateAllNodes ( & dumpArg , 1 ) ; NdbSleep_MilliSleep ( periodSeconds * 1000 ) ; } ndbout_c ( " Clearing ▁ error ▁ insert . . . " ) ; restarter . insertErrorInAllNodes ( 0 ) ; waitPeriods = 2 ; for ( Uint32 p = 0 ; p < waitPeriods ; p ++ ) { ndbout_c ( " Dumping ▁ DIH ▁ page ▁ info ▁ to ▁ ndbd ▁ stdout " ) ; restarter . dumpStateAllNodes ( & dumpArg , 1 ) ; NdbSleep_MilliSleep ( periodSeconds * 1000 ) ; } ndbout_c ( " Waiting ▁ for ▁ worker ▁ to ▁ finish ▁ task . . . " ) ; ctx -> getPropertyWait ( " DIHWritesRequest " , 2 ) ; if ( ctx -> isTestStopped ( ) ) return NDBT_OK ; ndbout_c ( " Done . " ) ; } ctx -> stopTest ( ) ; return NDBT_OK ; } NDBT_TESTSUITE ( testLimits ) ; TESTCASE ( " ExhaustSegmentedSectionPk " , " Test ▁ behaviour ▁ at ▁ Segmented ▁ Section ▁ exhaustion ▁ for ▁ PK " ) { INITIALIZER ( testSegmentedSectionPk ) ; } TESTCASE ( " ExhaustSegmentedSectionIX " , " Test ▁ behaviour ▁ at ▁ Segmented ▁ Section ▁ exhaustion ▁ for ▁ Unique ▁ index " ) { INITIALIZER ( testSegmentedSectionIx ) ; } TESTCASE ( " ExhaustSegmentedSectionScan " , " Test ▁ behaviour ▁ at ▁ Segmented ▁ Section ▁ exhaustion ▁ for ▁ Scan " ) { INITIALIZER ( testSegmentedSectionScan ) ; } TESTCASE ( " DropSignalFragments " , " Test ▁ behaviour ▁ of ▁ Segmented ▁ Section ▁ exhaustion ▁ with ▁ fragmented ▁ signals " ) { INITIALIZER ( testDropSignalFragments ) ; } TESTCASE ( " SlowDihFileWrites " , " Test ▁ behaviour ▁ of ▁ slow ▁ Dih ▁ table ▁ file ▁ writes " ) { INITIALIZER ( create100Tables ) ; STEP ( testWorker ) ; STEP ( testSlowDihFileWrites ) ; FINALIZER ( drop100Tables ) ; } NDBT_TESTSUITE_END ( testLimits ) ; int main ( int argc , const char * * argv ) { ndb_init ( ) ; NDBT_TESTSUITE_INSTANCE ( testLimits ) ; return testLimits . execute ( argc , argv ) ; } </DOCUMENT>
<DOCUMENT_ID="ThomasLee969/video_classifier/tree/master/workspace/mexopencv/src/+cv/cornerHarris.cpp"> # include " mexopencv . hpp " using namespace std ; using namespace cv ; void mexFunction ( int nlhs , mxArray * plhs [ ] , int nrhs , const mxArray * prhs [ ] ) { nargchk ( nrhs >= 1 && ( nrhs % 2 ) == 1 && nlhs <= 1 ) ; vector < MxArray > rhs ( prhs , prhs + nrhs ) ; int blockSize = 5 ; int ksize = 3 ; double k = 0.04 ; int borderType = cv :: BORDER_DEFAULT ; for ( int i = 1 ; i < nrhs ; i += 2 ) { string key ( rhs [ i ] . toString ( ) ) ; if ( key == " BlockSize " ) blockSize = rhs [ i + 1 ] . toInt ( ) ; else if ( key == " KSize " ) ksize = rhs [ i + 1 ] . toInt ( ) ; else if ( key == " K " ) k = rhs [ i + 1 ] . toDouble ( ) ; else if ( key == " BorderType " ) borderType = BorderType [ rhs [ i + 1 ] . toString ( ) ] ; else mexErrMsgIdAndTxt ( " mexopencv : error " , " Unrecognized ▁ option " ) ; } Mat src ( rhs [ 0 ] . toMat ( rhs [ 0 ] . isUint8 ( ) ? CV_8U : CV_32F ) ) , dst ; cornerHarris ( src , dst , blockSize , ksize , k , borderType ) ; plhs [ 0 ] = MxArray ( dst ) ; } </DOCUMENT>
<DOCUMENT_ID="RazZziel/sc_pong/tree/master/src/scfont.cpp"> # include < stdlib . h > # include < string . h > # include " SDL / SDL . h " # include " SDL / SDL _ image . h " # include " scfont . h " ScFont * ScLoadFont ( const char * filename ) { ScFont * font = ( ScFont * ) malloc ( sizeof ( ScFont ) ) ; FILE * file = fopen ( filename , " r " ) ; fread ( ( void * ) & font -> header , sizeof ( ScFontHeader ) , 1 , file ) ; int n_offsets = font -> header . highIndex - font -> header . lowIndex ; Uint32 * offsets = ( Uint32 * ) malloc ( sizeof ( Uint32 ) * ( n_offsets + 1 ) ) ; fseek ( file , sizeof ( ScFontHeader ) , SEEK_SET ) ; fread ( ( void * ) offsets , sizeof ( Uint32 ) , n_offsets , file ) ; fseek ( file , 0 , SEEK_END ) ; offsets [ n_offsets ] = ftell ( file ) ; font -> letters = ( ScLetter * ) malloc ( sizeof ( ScLetter ) * ( n_offsets + 1 ) ) ; for ( int i = 1 ; i <= n_offsets ; i ++ ) { if ( offsets [ i - 1 ] ) { fseek ( file , offsets [ i - 1 ] , SEEK_SET ) ; fread ( ( void * ) & font -> letters [ i ] . header , sizeof ( ScLetterHeader ) , 1 , file ) ; int next_offset = offsets [ i ] ; for ( int o = 0 ; ! next_offset ; o ++ ) { next_offset = offsets [ i + o ] ; } font -> letters [ i ] . n_pixels = next_offset - ( offsets [ i - 1 ] + sizeof ( ScLetterHeader ) ) - 1 ; font -> letters [ i ] . pixels = ( Uint8 * ) malloc ( sizeof ( Uint8 ) * font -> letters [ i ] . n_pixels ) ; fseek ( file , ( offsets [ i - 1 ] + sizeof ( ScLetterHeader ) ) , SEEK_SET ) ; fread ( ( void * ) font -> letters [ i ] . pixels , sizeof ( Uint8 ) , font -> letters [ i ] . n_pixels , file ) ; } else font -> letters [ i ] . n_pixels = - 1 ; } font -> letters [ 0 ] . n_pixels = 0 ; font -> letters [ 0 ] . header . x = 0 ; font -> letters [ 0 ] . header . y = 0 ; font -> letters [ 0 ] . header . h = 0 ; font -> letters [ 0 ] . header . w = font -> header . maxWidth / 2 ; free ( offsets ) ; fclose ( file ) ; return font ; } ScPalette * ScLoadPalette ( const char * filename ) { ScPalette * palette = ( ScPalette * ) malloc ( sizeof ( ScPalette ) ) ; SDL_Surface * s_palette ; if ( ( s_palette = SDL_DisplayFormat ( IMG_Load ( filename ) ) ) == NULL ) { fprintf ( stderr , " ERROR : ▁ Cannot ▁ load ▁ palette ▁ ' % s ' " , filename ) ; exit ( 1 ) ; } memcpy ( * palette , s_palette -> pixels , s_palette -> format -> BytesPerPixel * s_palette -> w ) ; SDL_FreeSurface ( s_palette ) ; return palette ; } SDL_Surface * ScRenderChar ( unsigned const char car , ScFont * font , ScColor * color ) { SDL_Surface * screen = SDL_GetVideoSurface ( ) ; int index = car - font -> header . lowIndex ; if ( ( car < font -> header . lowIndex ) || ( car > font -> header . highIndex ) || ( font -> letters [ index ] . n_pixels < 0 ) ) { fprintf ( stderr , " ERROR ▁ ( ScRenderChar ) : ▁ Invalid ▁ character ▁ index ▁ % d \n " , car ) ; return NULL ; } SDL_Surface * letter = SDL_CreateRGBSurface ( SDL_SWSURFACE , font -> letters [ index ] . header . w , font -> letters [ index ] . header . h , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; if ( font -> letters [ index ] . header . h > 0 ) { char * pixels = ( char * ) letter -> pixels - letter -> format -> BytesPerPixel ; for ( int p = 0 ; p < font -> letters [ index ] . n_pixels ; p ++ ) { Uint8 skip = font -> letters [ index ] . pixels [ p ] >> 3 ; Uint8 gamma = font -> letters [ index ] . pixels [ p ] & 7 ; pixels += skip * letter -> format -> BytesPerPixel + letter -> format -> BytesPerPixel ; memcpy ( pixels , * color + gamma , letter -> format -> BytesPerPixel ) ; } SDL_SetColorKey ( letter , SDL_SRCCOLORKEY | SDL_RLEACCEL , 0 ) ; } SDL_Surface * final_letter = SDL_CreateRGBSurface ( SDL_SWSURFACE , font -> letters [ index ] . header . w , font -> header . maxHeight , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; SDL_Rect offset = { font -> letters [ index ] . header . x , font -> letters [ index ] . header . y , 0 , 0 } ; SDL_BlitSurface ( letter , NULL , final_letter , & offset ) ; SDL_FreeSurface ( letter ) ; SDL_SetColorKey ( final_letter , SDL_SRCCOLORKEY | SDL_RLEACCEL , 0 ) ; return final_letter ; } int calculateWidth ( const unsigned char * text , ScFont * font , char delim ) { int width = 0 ; while ( * text ) { if ( * text != delim ) width += font -> letters [ * text - font -> header . lowIndex ] . header . w + 1 ; text ++ ; } return width - 1 ; } SDL_Surface * ScRenderText ( const char * text , ScFont * font , ScColor * color , ScColor * color_hi , char delim ) { SDL_Surface * screen = SDL_GetVideoSurface ( ) ; SDL_Surface * s_text = SDL_CreateRGBSurface ( SDL_SWSURFACE , calculateWidth ( ( unsigned char * ) text , font , delim ) , font -> header . maxHeight , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; SDL_SetColorKey ( s_text , SDL_SRCCOLORKEY | SDL_RLEACCEL , 0 ) ; SDL_Surface * s_char ; SDL_Rect offset = { 0 , 0 , 0 , 0 } ; if ( color_hi ) { ScColor * actual_color = color ; while ( * text ) { if ( * text == delim ) { if ( actual_color == color ) actual_color = color_hi ; else actual_color = color ; } else { if ( ( s_char = ScRenderChar ( * text , font , actual_color ) ) ) { SDL_BlitSurface ( s_char , NULL , s_text , & offset ) ; offset . x += s_char -> w + 1 ; SDL_FreeSurface ( s_char ) ; } } text ++ ; } } else { while ( * text ) { if ( * text != delim ) { if ( ( s_char = ScRenderChar ( * text , font , color ) ) ) { SDL_BlitSurface ( s_char , NULL , s_text , & offset ) ; offset . x += s_char -> w + 1 ; SDL_FreeSurface ( s_char ) ; } } text ++ ; } } return s_text ; } ScColor * ScGetColor ( const ScPalette * palette , int index ) { ScColor * color = ( ScColor * ) malloc ( sizeof ( ScColor ) ) ; memcpy ( * color , * palette + ( index * MAX_GAMMA ) , sizeof ( ScColor ) ) ; return color ; } void ScTestFont ( ScFont * font , ScPalette * palette ) { # define TEST_SDL SDL_Surface * screen = SDL_GetVideoSurface ( ) ; SDL_FillRect ( screen , NULL , SDL_MapRGB ( SDL_GetVideoSurface ( ) -> format , 255 , 255 , 255 ) ) ; SDL_Flip ( screen ) ; # ifdef TEST_SDL SDL_Rect offset = { 10 , 10 , 0 , 0 } ; SDL_BlitSurface ( ScRenderText ( " El ▁ veloz ▁ murci � ago ▁ hind " , font , ScGetColor ( palette , 1 ) ) , NULL , screen , & offset ) ; offset . y += font -> header . maxHeight + 2 ; SDL_BlitSurface ( ScRenderText ( " Juiporentenderlas " , font , ScGetColor ( palette , 5 ) ) , NULL , screen , & offset ) ; offset . y += font -> header . maxHeight + 2 ; SDL_BlitSurface ( ScRenderText ( " _ S _ ingle ▁ Player " , font , ScGetColor ( palette , 1 ) , ScGetColor ( palette , 2 ) , ' _ ' ) , NULL , screen , & offset ) ; offset . y += font -> header . maxHeight + 2 ; # endif for ( int i = font -> header . lowIndex ; i <= font -> header . highIndex ; i ++ ) { # ifdef TEST_SDL SDL_Surface * s_char = ScRenderChar ( i , font , ScGetColor ( palette , 2 ) ) ; if ( s_char ) { SDL_BlitSurface ( s_char , NULL , screen , & offset ) ; SDL_FreeSurface ( s_char ) ; } if ( ( offset . x += font -> header . maxWidth + 2 ) > ( screen -> w - font -> header . maxWidth - 10 ) ) { offset . x = 10 ; offset . y += font -> header . maxHeight + 2 ; } # else int index = i - font -> header . lowIndex ; int x = 1 ; for ( int p = 0 ; p < font -> letters [ index ] . n_pixels ; p ++ ) printf ( " % d ▁ " , ( font -> letters [ i ] . pixels [ p ] >> 3 ) ) ; printf ( " \n " ) ; for ( int p = 0 ; p < font -> letters [ index ] . n_pixels ; p ++ ) { Uint8 skip = font -> letters [ index ] . pixels [ p ] >> 3 ; Uint8 color = font -> letters [ index ] . pixels [ p ] & 7 ; for ( int j = 0 ; j < skip ; j ++ ) { printf ( " ▁ " ) ; if ( x ++ == font -> letters [ index ] . header . w ) { printf ( " \n " ) ; x = 1 ; } } printf ( " % d " , color ) ; if ( x ++ == font -> letters [ index ] . header . w ) { printf ( " \n " ) ; x = 1 ; } } printf ( " \n test ▁ end \n " ) ; getchar ( ) ; # endif } SDL_Flip ( screen ) ; * screen = * SDL_CreateRGBSurface ( SDL_SWSURFACE , screen -> w , screen -> h , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; getchar ( ) ; } </DOCUMENT>
<DOCUMENT_ID="braindx/scummvm/tree/master/engines/titanic/gfx/icon_nav_receive.cpp"> # include " titanic / gfx / icon _ nav _ receive . h " namespace Titanic { EMPTY_MESSAGE_MAP ( CIconNavReceive , CPetGraphic ) ; void CIconNavReceive :: save ( SimpleFile * file , int indent ) { file -> writeNumberLine ( 1 , indent ) ; CPetGraphic :: save ( file , indent ) ; } void CIconNavReceive :: load ( SimpleFile * file ) { file -> readNumber ( ) ; CPetGraphic :: load ( file ) ; } } </DOCUMENT>
<DOCUMENT_ID="omazapa/root-old/tree/master/interpreter/llvm/src/lib/CodeGen/MachineSSAUpdater.cpp"> # include " llvm / CodeGen / MachineSSAUpdater . h " # include " llvm / ADT / DenseMap . h " # include " llvm / ADT / SmallVector . h " # include " llvm / CodeGen / MachineInstr . h " # include " llvm / CodeGen / MachineInstrBuilder . h " # include " llvm / CodeGen / MachineRegisterInfo . h " # include " llvm / Support / AlignOf . h " # include " llvm / Support / Allocator . h " # include " llvm / Support / Debug . h " # include " llvm / Support / ErrorHandling . h " # include " llvm / Support / raw _ ostream . h " # include " llvm / Target / TargetInstrInfo . h " # include " llvm / Target / TargetRegisterInfo . h " # include " llvm / Target / TargetSubtargetInfo . h " # include " llvm / Transforms / Utils / SSAUpdaterImpl . h " using namespace llvm ; # define DEBUG_TYPE " machine - ssaupdater " typedef DenseMap < MachineBasicBlock * , unsigned > AvailableValsTy ; static AvailableValsTy & getAvailableVals ( void * AV ) { return * static_cast < AvailableValsTy * > ( AV ) ; } MachineSSAUpdater :: MachineSSAUpdater ( MachineFunction & MF , SmallVectorImpl < MachineInstr * > * NewPHI ) : AV ( nullptr ) , InsertedPHIs ( NewPHI ) { TII = MF . getSubtarget ( ) . getInstrInfo ( ) ; MRI = & MF . getRegInfo ( ) ; } MachineSSAUpdater :: ~ MachineSSAUpdater ( ) { delete static_cast < AvailableValsTy * > ( AV ) ; } void MachineSSAUpdater :: Initialize ( unsigned V ) { if ( ! AV ) AV = new AvailableValsTy ( ) ; else getAvailableVals ( AV ) . clear ( ) ; VR = V ; VRC = MRI -> getRegClass ( VR ) ; } bool MachineSSAUpdater :: HasValueForBlock ( MachineBasicBlock * BB ) const { return getAvailableVals ( AV ) . count ( BB ) ; } void MachineSSAUpdater :: AddAvailableValue ( MachineBasicBlock * BB , unsigned V ) { getAvailableVals ( AV ) [ BB ] = V ; } unsigned MachineSSAUpdater :: GetValueAtEndOfBlock ( MachineBasicBlock * BB ) { return GetValueAtEndOfBlockInternal ( BB ) ; } static unsigned LookForIdenticalPHI ( MachineBasicBlock * BB , SmallVectorImpl < std :: pair < MachineBasicBlock * , unsigned > > & PredValues ) { if ( BB -> empty ( ) ) return 0 ; MachineBasicBlock :: iterator I = BB -> begin ( ) ; if ( ! I -> isPHI ( ) ) return 0 ; AvailableValsTy AVals ; for ( unsigned i = 0 , e = PredValues . size ( ) ; i != e ; ++ i ) AVals [ PredValues [ i ] . first ] = PredValues [ i ] . second ; while ( I != BB -> end ( ) && I -> isPHI ( ) ) { bool Same = true ; for ( unsigned i = 1 , e = I -> getNumOperands ( ) ; i != e ; i += 2 ) { unsigned SrcReg = I -> getOperand ( i ) . getReg ( ) ; MachineBasicBlock * SrcBB = I -> getOperand ( i + 1 ) . getMBB ( ) ; if ( AVals [ SrcBB ] != SrcReg ) { Same = false ; break ; } } if ( Same ) return I -> getOperand ( 0 ) . getReg ( ) ; ++ I ; } return 0 ; } static MachineInstrBuilder InsertNewDef ( unsigned Opcode , MachineBasicBlock * BB , MachineBasicBlock :: iterator I , const TargetRegisterClass * RC , MachineRegisterInfo * MRI , const TargetInstrInfo * TII ) { unsigned NewVR = MRI -> createVirtualRegister ( RC ) ; return BuildMI ( * BB , I , DebugLoc ( ) , TII -> get ( Opcode ) , NewVR ) ; } unsigned MachineSSAUpdater :: GetValueInMiddleOfBlock ( MachineBasicBlock * BB ) { if ( ! HasValueForBlock ( BB ) ) return GetValueAtEndOfBlockInternal ( BB ) ; if ( BB -> pred_empty ( ) ) { MachineInstr * NewDef = InsertNewDef ( TargetOpcode :: IMPLICIT_DEF , BB , BB -> getFirstTerminator ( ) , VRC , MRI , TII ) ; return NewDef -> getOperand ( 0 ) . getReg ( ) ; } SmallVector < std :: pair < MachineBasicBlock * , unsigned > , 8 > PredValues ; unsigned SingularValue = 0 ; bool isFirstPred = true ; for ( MachineBasicBlock :: pred_iterator PI = BB -> pred_begin ( ) , E = BB -> pred_end ( ) ; PI != E ; ++ PI ) { MachineBasicBlock * PredBB = * PI ; unsigned PredVal = GetValueAtEndOfBlockInternal ( PredBB ) ; PredValues . push_back ( std :: make_pair ( PredBB , PredVal ) ) ; if ( isFirstPred ) { SingularValue = PredVal ; isFirstPred = false ; } else if ( PredVal != SingularValue ) SingularValue = 0 ; } if ( SingularValue != 0 ) return SingularValue ; unsigned DupPHI = LookForIdenticalPHI ( BB , PredValues ) ; if ( DupPHI ) return DupPHI ; MachineBasicBlock :: iterator Loc = BB -> empty ( ) ? BB -> end ( ) : BB -> begin ( ) ; MachineInstrBuilder InsertedPHI = InsertNewDef ( TargetOpcode :: PHI , BB , Loc , VRC , MRI , TII ) ; for ( unsigned i = 0 , e = PredValues . size ( ) ; i != e ; ++ i ) InsertedPHI . addReg ( PredValues [ i ] . second ) . addMBB ( PredValues [ i ] . first ) ; if ( unsigned ConstVal = InsertedPHI -> isConstantValuePHI ( ) ) { InsertedPHI -> eraseFromParent ( ) ; return ConstVal ; } if ( InsertedPHIs ) InsertedPHIs -> push_back ( InsertedPHI ) ; DEBUG ( dbgs ( ) << " ▁ ▁ Inserted ▁ PHI : ▁ " << * InsertedPHI << " \n " ) ; return InsertedPHI -> getOperand ( 0 ) . getReg ( ) ; } static MachineBasicBlock * findCorrespondingPred ( const MachineInstr * MI , MachineOperand * U ) { for ( unsigned i = 1 , e = MI -> getNumOperands ( ) ; i != e ; i += 2 ) { if ( & MI -> getOperand ( i ) == U ) return MI -> getOperand ( i + 1 ) . getMBB ( ) ; } llvm_unreachable ( " MachineOperand : : getParent ( ) ▁ failure ? " ) ; } void MachineSSAUpdater :: RewriteUse ( MachineOperand & U ) { MachineInstr * UseMI = U . getParent ( ) ; unsigned NewVR = 0 ; if ( UseMI -> isPHI ( ) ) { MachineBasicBlock * SourceBB = findCorrespondingPred ( UseMI , & U ) ; NewVR = GetValueAtEndOfBlockInternal ( SourceBB ) ; } else { NewVR = GetValueInMiddleOfBlock ( UseMI -> getParent ( ) ) ; } U . setReg ( NewVR ) ; } namespace llvm { template < > class SSAUpdaterTraits < MachineSSAUpdater > { public : typedef MachineBasicBlock BlkT ; typedef unsigned ValT ; typedef MachineInstr PhiT ; typedef MachineBasicBlock :: succ_iterator BlkSucc_iterator ; static BlkSucc_iterator BlkSucc_begin ( BlkT * BB ) { return BB -> succ_begin ( ) ; } static BlkSucc_iterator BlkSucc_end ( BlkT * BB ) { return BB -> succ_end ( ) ; } class PHI_iterator { private : MachineInstr * PHI ; unsigned idx ; public : explicit PHI_iterator ( MachineInstr * P ) : PHI ( P ) , idx ( 1 ) { } PHI_iterator ( MachineInstr * P , bool ) : PHI ( P ) , idx ( PHI -> getNumOperands ( ) ) { } PHI_iterator & operator ++ ( ) { idx += 2 ; return * this ; } bool operator == ( const PHI_iterator & x ) const { return idx == x . idx ; } bool operator != ( const PHI_iterator & x ) const { return ! operator == ( x ) ; } unsigned getIncomingValue ( ) { return PHI -> getOperand ( idx ) . getReg ( ) ; } MachineBasicBlock * getIncomingBlock ( ) { return PHI -> getOperand ( idx + 1 ) . getMBB ( ) ; } } ; static inline PHI_iterator PHI_begin ( PhiT * PHI ) { return PHI_iterator ( PHI ) ; } static inline PHI_iterator PHI_end ( PhiT * PHI ) { return PHI_iterator ( PHI , true ) ; } static void FindPredecessorBlocks ( MachineBasicBlock * BB , SmallVectorImpl < MachineBasicBlock * > * Preds ) { for ( MachineBasicBlock :: pred_iterator PI = BB -> pred_begin ( ) , E = BB -> pred_end ( ) ; PI != E ; ++ PI ) Preds -> push_back ( * PI ) ; } static unsigned GetUndefVal ( MachineBasicBlock * BB , MachineSSAUpdater * Updater ) { MachineInstr * NewDef = InsertNewDef ( TargetOpcode :: IMPLICIT_DEF , BB , BB -> getFirstTerminator ( ) , Updater -> VRC , Updater -> MRI , Updater -> TII ) ; return NewDef -> getOperand ( 0 ) . getReg ( ) ; } static unsigned CreateEmptyPHI ( MachineBasicBlock * BB , unsigned NumPreds , MachineSSAUpdater * Updater ) { MachineBasicBlock :: iterator Loc = BB -> empty ( ) ? BB -> end ( ) : BB -> begin ( ) ; MachineInstr * PHI = InsertNewDef ( TargetOpcode :: PHI , BB , Loc , Updater -> VRC , Updater -> MRI , Updater -> TII ) ; return PHI -> getOperand ( 0 ) . getReg ( ) ; } static void AddPHIOperand ( MachineInstr * PHI , unsigned Val , MachineBasicBlock * Pred ) { MachineInstrBuilder ( * Pred -> getParent ( ) , PHI ) . addReg ( Val ) . addMBB ( Pred ) ; } static MachineInstr * InstrIsPHI ( MachineInstr * I ) { if ( I && I -> isPHI ( ) ) return I ; return nullptr ; } static MachineInstr * ValueIsPHI ( unsigned Val , MachineSSAUpdater * Updater ) { return InstrIsPHI ( Updater -> MRI -> getVRegDef ( Val ) ) ; } static MachineInstr * ValueIsNewPHI ( unsigned Val , MachineSSAUpdater * Updater ) { MachineInstr * PHI = ValueIsPHI ( Val , Updater ) ; if ( PHI && PHI -> getNumOperands ( ) <= 1 ) return PHI ; return nullptr ; } static unsigned GetPHIValue ( MachineInstr * PHI ) { return PHI -> getOperand ( 0 ) . getReg ( ) ; } } ; } unsigned MachineSSAUpdater :: GetValueAtEndOfBlockInternal ( MachineBasicBlock * BB ) { AvailableValsTy & AvailableVals = getAvailableVals ( AV ) ; if ( unsigned V = AvailableVals [ BB ] ) return V ; SSAUpdaterImpl < MachineSSAUpdater > Impl ( this , & AvailableVals , InsertedPHIs ) ; return Impl . GetValue ( BB ) ; } </DOCUMENT>
<DOCUMENT_ID="circa-one/OpenJK-Alt/tree/master/code/cgame/cg_marks.cpp"> # include " cg _ headers . h " # include " cg _ media . h " markPoly_t cg_activeMarkPolys ; markPoly_t * cg_freeMarkPolys ; markPoly_t cg_markPolys [ MAX_MARK_POLYS ] ; void CG_InitMarkPolys ( void ) { int i ; memset ( cg_markPolys , 0 , sizeof ( cg_markPolys ) ) ; cg_activeMarkPolys . nextMark = & cg_activeMarkPolys ; cg_activeMarkPolys . prevMark = & cg_activeMarkPolys ; cg_freeMarkPolys = cg_markPolys ; for ( i = 0 ; i < MAX_MARK_POLYS - 1 ; i ++ ) { cg_markPolys [ i ] . nextMark = & cg_markPolys [ i + 1 ] ; } } void CG_FreeMarkPoly ( markPoly_t * le ) { if ( ! le -> prevMark ) { CG_Error ( " CG _ FreeLocalEntity : ▁ not ▁ active " ) ; } le -> prevMark -> nextMark = le -> nextMark ; le -> nextMark -> prevMark = le -> prevMark ; le -> nextMark = cg_freeMarkPolys ; cg_freeMarkPolys = le ; } markPoly_t * CG_AllocMark ( void ) { markPoly_t * le ; int time ; if ( ! cg_freeMarkPolys ) { time = cg_activeMarkPolys . prevMark -> time ; while ( cg_activeMarkPolys . prevMark && time == cg_activeMarkPolys . prevMark -> time ) { CG_FreeMarkPoly ( cg_activeMarkPolys . prevMark ) ; } } le = cg_freeMarkPolys ; cg_freeMarkPolys = cg_freeMarkPolys -> nextMark ; memset ( le , 0 , sizeof ( * le ) ) ; le -> nextMark = cg_activeMarkPolys . nextMark ; le -> prevMark = & cg_activeMarkPolys ; cg_activeMarkPolys . nextMark -> prevMark = le ; cg_activeMarkPolys . nextMark = le ; return le ; } # define MAX_MARK_FRAGMENTS 128 # define MAX_MARK_POINTS 384 void CG_ImpactMark ( qhandle_t markShader , const vec3_t origin , const vec3_t dir , float orientation , float red , float green , float blue , float alpha , qboolean alphaFade , float radius , qboolean temporary ) { vec3_t axis [ 3 ] ; float texCoordScale ; vec3_t originalPoints [ 4 ] ; byte colors [ 4 ] ; int i , j ; int numFragments ; markFragment_t markFragments [ MAX_MARK_FRAGMENTS ] , * mf ; vec3_t markPoints [ MAX_MARK_POINTS ] ; vec3_t projection ; if ( ! cg_addMarks . integer ) { return ; } if ( radius <= 0 ) { CG_Error ( " CG _ ImpactMark ▁ called ▁ with ▁ < = ▁ 0 ▁ radius " ) ; } VectorNormalize2 ( dir , axis [ 0 ] ) ; PerpendicularVector ( axis [ 1 ] , axis [ 0 ] ) ; RotatePointAroundVector ( axis [ 2 ] , axis [ 0 ] , axis [ 1 ] , orientation ) ; CrossProduct ( axis [ 0 ] , axis [ 2 ] , axis [ 1 ] ) ; texCoordScale = 0.5 * 1.0 / radius ; for ( i = 0 ; i < 3 ; i ++ ) { originalPoints [ 0 ] [ i ] = origin [ i ] - radius * axis [ 1 ] [ i ] - radius * axis [ 2 ] [ i ] ; originalPoints [ 1 ] [ i ] = origin [ i ] + radius * axis [ 1 ] [ i ] - radius * axis [ 2 ] [ i ] ; originalPoints [ 2 ] [ i ] = origin [ i ] + radius * axis [ 1 ] [ i ] + radius * axis [ 2 ] [ i ] ; originalPoints [ 3 ] [ i ] = origin [ i ] - radius * axis [ 1 ] [ i ] + radius * axis [ 2 ] [ i ] ; } VectorScale ( dir , - 20 , projection ) ; numFragments = cgi_CM_MarkFragments ( 4 , ( const float ( * ) [ 3 ] ) originalPoints , projection , MAX_MARK_POINTS , markPoints [ 0 ] , MAX_MARK_FRAGMENTS , markFragments ) ; colors [ 0 ] = red * 255 ; colors [ 1 ] = green * 255 ; colors [ 2 ] = blue * 255 ; colors [ 3 ] = alpha * 255 ; for ( i = 0 , mf = markFragments ; i < numFragments ; i ++ , mf ++ ) { polyVert_t * v ; polyVert_t verts [ MAX_VERTS_ON_POLY ] ; markPoly_t * mark ; if ( mf -> numPoints > MAX_VERTS_ON_POLY ) { mf -> numPoints = MAX_VERTS_ON_POLY ; } for ( j = 0 , v = verts ; j < mf -> numPoints ; j ++ , v ++ ) { vec3_t delta ; VectorCopy ( markPoints [ mf -> firstPoint + j ] , v -> xyz ) ; VectorSubtract ( v -> xyz , origin , delta ) ; v -> st [ 0 ] = 0.5f + DotProduct ( delta , axis [ 1 ] ) * texCoordScale ; v -> st [ 1 ] = 0.5f + DotProduct ( delta , axis [ 2 ] ) * texCoordScale ; for ( int k = 0 ; k < 4 ; k ++ ) { v -> modulate [ k ] = colors [ k ] ; } } if ( temporary ) { cgi_R_AddPolyToScene ( markShader , mf -> numPoints , verts ) ; continue ; } mark = CG_AllocMark ( ) ; mark -> time = cg . time ; mark -> alphaFade = alphaFade ; mark -> markShader = markShader ; mark -> poly . numVerts = mf -> numPoints ; mark -> color [ 0 ] = colors [ 0 ] ; mark -> color [ 1 ] = colors [ 1 ] ; mark -> color [ 2 ] = colors [ 2 ] ; mark -> color [ 3 ] = colors [ 3 ] ; memcpy ( mark -> verts , verts , mf -> numPoints * sizeof ( verts [ 0 ] ) ) ; } } # define MARK_TOTAL_TIME 10000 # define MARK_FADE_TIME 1000 void CG_AddMarks ( void ) { int j ; markPoly_t * mp , * next ; int t ; int fade ; if ( ! cg_addMarks . integer ) { return ; } mp = cg_activeMarkPolys . nextMark ; for ( ; mp != & cg_activeMarkPolys ; mp = next ) { next = mp -> nextMark ; if ( cg . time > mp -> time + MARK_TOTAL_TIME ) { CG_FreeMarkPoly ( mp ) ; continue ; } t = mp -> time + MARK_TOTAL_TIME - cg . time ; if ( t < MARK_FADE_TIME ) { fade = 255 * t / MARK_FADE_TIME ; if ( mp -> alphaFade ) { for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 3 ] = fade ; } } else { float f = ( float ) t / MARK_FADE_TIME ; for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 0 ] = mp -> color [ 0 ] * f ; mp -> verts [ j ] . modulate [ 1 ] = mp -> color [ 1 ] * f ; mp -> verts [ j ] . modulate [ 2 ] = mp -> color [ 2 ] * f ; } } } else { for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 0 ] = mp -> color [ 0 ] ; mp -> verts [ j ] . modulate [ 1 ] = mp -> color [ 1 ] ; mp -> verts [ j ] . modulate [ 2 ] = mp -> color [ 2 ] ; } } cgi_R_AddPolyToScene ( mp -> markShader , mp -> poly . numVerts , mp -> verts ) ; } } </DOCUMENT>
<DOCUMENT_ID="fbergmann/libSEDML/tree/master/sedml/SedDocument.cpp"> # include < sedml / SedDocument . h > # include < sedml / SedTypes . h > # include < sbml / xml / XMLInputStream . h > using namespace std ; LIBSEDML_CPP_NAMESPACE_BEGIN SedDocument :: SedDocument ( unsigned int level , unsigned int version ) : SedBase ( level , version ) , mLevel ( SEDML_INT_MAX ) , mIsSetLevel ( false ) , mVersion ( SEDML_INT_MAX ) , mIsSetVersion ( false ) , mDataDescriptions ( level , version ) , mSimulations ( level , version ) , mModels ( level , version ) , mTasks ( level , version ) , mDataGenerators ( level , version ) , mOutputs ( level , version ) { mLevel = level ; mIsSetLevel = true ; mVersion = version ; mIsSetVersion = true ; setSedDocument ( this ) ; setSedNamespacesAndOwn ( new SedNamespaces ( level , version ) ) ; connectToChild ( ) ; } SedDocument :: SedDocument ( SedNamespaces * sedns ) : SedBase ( sedns ) , mLevel ( SEDML_INT_MAX ) , mIsSetLevel ( false ) , mVersion ( SEDML_INT_MAX ) , mIsSetVersion ( false ) , mDataDescriptions ( sedns ) , mSimulations ( sedns ) , mModels ( sedns ) , mTasks ( sedns ) , mDataGenerators ( sedns ) , mOutputs ( sedns ) { mLevel = sedns -> getLevel ( ) ; mIsSetLevel = true ; mVersion = sedns -> getVersion ( ) ; mIsSetVersion = true ; setSedDocument ( this ) ; setElementNamespace ( sedns -> getURI ( ) ) ; connectToChild ( ) ; } SedDocument :: SedDocument ( const SedDocument & orig ) : SedBase ( orig ) { setSedDocument ( this ) ; mLevel = orig . mLevel ; mIsSetLevel = orig . mIsSetLevel ; mVersion = orig . mVersion ; mIsSetVersion = orig . mIsSetVersion ; mDataDescriptions = orig . mDataDescriptions ; mSimulations = orig . mSimulations ; mModels = orig . mModels ; mTasks = orig . mTasks ; mDataGenerators = orig . mDataGenerators ; mOutputs = orig . mOutputs ; connectToChild ( ) ; } SedDocument & SedDocument :: operator = ( const SedDocument & rhs ) { if ( & rhs != this ) { SedBase :: operator = ( rhs ) ; setSedDocument ( this ) ; mLevel = rhs . mLevel ; mIsSetLevel = rhs . mIsSetLevel ; mVersion = rhs . mVersion ; mIsSetVersion = rhs . mIsSetVersion ; mDataDescriptions = rhs . mDataDescriptions ; mSimulations = rhs . mSimulations ; mModels = rhs . mModels ; mTasks = rhs . mTasks ; mDataGenerators = rhs . mDataGenerators ; mOutputs = rhs . mOutputs ; connectToChild ( ) ; } return * this ; } SedDocument * SedDocument :: clone ( ) const { return new SedDocument ( * this ) ; } SedDocument :: ~ SedDocument ( ) { } const int SedDocument :: getLevel ( ) const { return mLevel ; } const int SedDocument :: getVersion ( ) const { return mVersion ; } bool SedDocument :: isSetLevel ( ) const { return mIsSetLevel ; } bool SedDocument :: isSetVersion ( ) const { return mIsSetVersion ; } int SedDocument :: setLevel ( int level ) { mLevel = level ; mIsSetLevel = true ; return LIBSEDML_OPERATION_SUCCESS ; } int SedDocument :: setVersion ( int version ) { mVersion = version ; mIsSetVersion = true ; return LIBSEDML_OPERATION_SUCCESS ; } int SedDocument :: unsetLevel ( ) { mLevel = SEDML_INT_MAX ; mIsSetLevel = false ; if ( isSetLevel ( ) == false ) { return LIBSEDML_OPERATION_SUCCESS ; } else { return LIBSEDML_OPERATION_FAILED ; } } int SedDocument :: unsetVersion ( ) { mVersion = SEDML_INT_MAX ; mIsSetVersion = false ; if ( isSetVersion ( ) == false ) { return LIBSEDML_OPERATION_SUCCESS ; } else { return LIBSEDML_OPERATION_FAILED ; } } const SedListOfDataDescriptions * SedDocument :: getListOfDataDescriptions ( ) const { return & mDataDescriptions ; } SedDataDescription * SedDocument :: removeDataDescription ( unsigned int n ) { return mDataDescriptions . remove ( n ) ; } SedDataDescription * SedDocument :: removeDataDescription ( const std :: string & sid ) { return mDataDescriptions . remove ( sid ) ; } SedDataDescription * SedDocument :: getDataDescription ( unsigned int n ) { return mDataDescriptions . get ( n ) ; } const SedDataDescription * SedDocument :: getDataDescription ( unsigned int n ) const { return mDataDescriptions . get ( n ) ; } SedDataDescription * SedDocument :: getDataDescription ( const std :: string & sid ) { return mDataDescriptions . get ( sid ) ; } const SedDataDescription * SedDocument :: getDataDescription ( const std :: string & sid ) const { return mDataDescriptions . get ( sid ) ; } int SedDocument :: addDataDescription ( const SedDataDescription * sdd ) { if ( sdd == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mDataDescriptions . append ( sdd ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumDataDescriptions ( ) const { return mDataDescriptions . size ( ) ; } SedDataDescription * SedDocument :: createDataDescription ( ) { SedDataDescription * temp = new SedDataDescription ( ) ; if ( temp != NULL ) mDataDescriptions . appendAndOwn ( temp ) ; return temp ; } const SedListOfSimulations * SedDocument :: getListOfSimulations ( ) const { return & mSimulations ; } SedSimulation * SedDocument :: removeSimulation ( unsigned int n ) { return mSimulations . remove ( n ) ; } SedSimulation * SedDocument :: removeSimulation ( const std :: string & sid ) { return mSimulations . remove ( sid ) ; } SedSimulation * SedDocument :: getSimulation ( unsigned int n ) { return mSimulations . get ( n ) ; } const SedSimulation * SedDocument :: getSimulation ( unsigned int n ) const { return mSimulations . get ( n ) ; } SedSimulation * SedDocument :: getSimulation ( const std :: string & sid ) { return mSimulations . get ( sid ) ; } const SedSimulation * SedDocument :: getSimulation ( const std :: string & sid ) const { return mSimulations . get ( sid ) ; } int SedDocument :: addSimulation ( const SedSimulation * ss ) { if ( ss == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mSimulations . append ( ss ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumSimulations ( ) const { return mSimulations . size ( ) ; } SedUniformTimeCourse * SedDocument :: createUniformTimeCourse ( ) { SedUniformTimeCourse * temp = new SedUniformTimeCourse ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; } SedOneStep * SedDocument :: createOneStep ( ) { SedOneStep * temp = new SedOneStep ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; } SedSteadyState * SedDocument :: createSteadyState ( ) { SedSteadyState * temp = new SedSteadyState ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; } const SedListOfModels * SedDocument :: getListOfModels ( ) const { return & mModels ; } SedModel * SedDocument :: removeModel ( unsigned int n ) { return mModels . remove ( n ) ; } SedModel * SedDocument :: removeModel ( const std :: string & sid ) { return mModels . remove ( sid ) ; } SedModel * SedDocument :: getModel ( unsigned int n ) { return mModels . get ( n ) ; } const SedModel * SedDocument :: getModel ( unsigned int n ) const { return mModels . get ( n ) ; } SedModel * SedDocument :: getModel ( const std :: string & sid ) { return mModels . get ( sid ) ; } const SedModel * SedDocument :: getModel ( const std :: string & sid ) const { return mModels . get ( sid ) ; } int SedDocument :: addModel ( const SedModel * sm ) { if ( sm == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mModels . append ( sm ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumModels ( ) const { return mModels . size ( ) ; } SedModel * SedDocument :: createModel ( ) { SedModel * temp = new SedModel ( ) ; if ( temp != NULL ) mModels . appendAndOwn ( temp ) ; return temp ; } const SedListOfTasks * SedDocument :: getListOfTasks ( ) const { return & mTasks ; } SedTask * SedDocument :: removeTask ( unsigned int n ) { return mTasks . remove ( n ) ; } SedTask * SedDocument :: removeTask ( const std :: string & sid ) { return mTasks . remove ( sid ) ; } SedTask * SedDocument :: getTask ( unsigned int n ) { return mTasks . get ( n ) ; } const SedTask * SedDocument :: getTask ( unsigned int n ) const { return mTasks . get ( n ) ; } SedTask * SedDocument :: getTask ( const std :: string & sid ) { return mTasks . get ( sid ) ; } const SedTask * SedDocument :: getTask ( const std :: string & sid ) const { return mTasks . get ( sid ) ; } int SedDocument :: addTask ( const SedTask * st ) { if ( st == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mTasks . append ( st ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumTasks ( ) const { return mTasks . size ( ) ; } SedTask * SedDocument :: createTask ( ) { SedTask * temp = new SedTask ( ) ; if ( temp != NULL ) mTasks . appendAndOwn ( temp ) ; return temp ; } SedRepeatedTask * SedDocument :: createRepeatedTask ( ) { SedRepeatedTask * temp = new SedRepeatedTask ( ) ; if ( temp != NULL ) mTasks . appendAndOwn ( temp ) ; return temp ; } const SedListOfDataGenerators * SedDocument :: getListOfDataGenerators ( ) const { return & mDataGenerators ; } SedDataGenerator * SedDocument :: removeDataGenerator ( unsigned int n ) { return mDataGenerators . remove ( n ) ; } SedDataGenerator * SedDocument :: removeDataGenerator ( const std :: string & sid ) { return mDataGenerators . remove ( sid ) ; } SedDataGenerator * SedDocument :: getDataGenerator ( unsigned int n ) { return mDataGenerators . get ( n ) ; } const SedDataGenerator * SedDocument :: getDataGenerator ( unsigned int n ) const { return mDataGenerators . get ( n ) ; } SedDataGenerator * SedDocument :: getDataGenerator ( const std :: string & sid ) { return mDataGenerators . get ( sid ) ; } const SedDataGenerator * SedDocument :: getDataGenerator ( const std :: string & sid ) const { return mDataGenerators . get ( sid ) ; } int SedDocument :: addDataGenerator ( const SedDataGenerator * sdg ) { if ( sdg == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mDataGenerators . append ( sdg ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumDataGenerators ( ) const { return mDataGenerators . size ( ) ; } SedDataGenerator * SedDocument :: createDataGenerator ( ) { SedDataGenerator * temp = new SedDataGenerator ( ) ; if ( temp != NULL ) mDataGenerators . appendAndOwn ( temp ) ; return temp ; } const SedListOfOutputs * SedDocument :: getListOfOutputs ( ) const { return & mOutputs ; } SedOutput * SedDocument :: removeOutput ( unsigned int n ) { return mOutputs . remove ( n ) ; } SedOutput * SedDocument :: removeOutput ( const std :: string & sid ) { return mOutputs . remove ( sid ) ; } SedOutput * SedDocument :: getOutput ( unsigned int n ) { return mOutputs . get ( n ) ; } const SedOutput * SedDocument :: getOutput ( unsigned int n ) const { return mOutputs . get ( n ) ; } SedOutput * SedDocument :: getOutput ( const std :: string & sid ) { return mOutputs . get ( sid ) ; } const SedOutput * SedDocument :: getOutput ( const std :: string & sid ) const { return mOutputs . get ( sid ) ; } int SedDocument :: addOutput ( const SedOutput * so ) { if ( so == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mOutputs . append ( so ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumOutputs ( ) const { return mOutputs . size ( ) ; } SedReport * SedDocument :: createReport ( ) { SedReport * temp = new SedReport ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; } SedPlot2D * SedDocument :: createPlot2D ( ) { SedPlot2D * temp = new SedPlot2D ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; } SedPlot3D * SedDocument :: createPlot3D ( ) { SedPlot3D * temp = new SedPlot3D ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; } const std :: string & SedDocument :: getElementName ( ) const { static const string name = " sedML " ; return name ; } SedBase * SedDocument :: createObject ( XMLInputStream & stream ) { SedBase * object = NULL ; const string & name = stream . peek ( ) . getName ( ) ; if ( name == " listOfDataDescriptions " ) { object = & mDataDescriptions ; } if ( name == " listOfSimulations " ) { object = & mSimulations ; } if ( name == " listOfModels " ) { object = & mModels ; } if ( name == " listOfTasks " ) { object = & mTasks ; } if ( name == " listOfDataGenerators " ) { object = & mDataGenerators ; } if ( name == " listOfOutputs " ) { object = & mOutputs ; } connectToChild ( ) ; return object ; } void SedDocument :: connectToChild ( ) { SedBase :: connectToChild ( ) ; mDataDescriptions . connectToParent ( this ) ; mSimulations . connectToParent ( this ) ; mModels . connectToParent ( this ) ; mTasks . connectToParent ( this ) ; mDataGenerators . connectToParent ( this ) ; mOutputs . connectToParent ( this ) ; } int SedDocument :: getTypeCode ( ) const { return SEDML_DOCUMENT ; } bool SedDocument :: hasRequiredAttributes ( ) const { bool allPresent = true ; if ( isSetLevel ( ) == false ) allPresent = false ; if ( isSetVersion ( ) == false ) allPresent = false ; return allPresent ; } bool SedDocument :: hasRequiredElements ( ) const { bool allPresent = true ; return allPresent ; } void SedDocument :: writeElements ( XMLOutputStream & stream ) const { SedBase :: writeElements ( stream ) ; if ( getNumDataDescriptions ( ) > 0 ) { mDataDescriptions . write ( stream ) ; } if ( getNumSimulations ( ) > 0 ) { mSimulations . write ( stream ) ; } if ( getNumModels ( ) > 0 ) { mModels . write ( stream ) ; } if ( getNumTasks ( ) > 0 ) { mTasks . write ( stream ) ; } if ( getNumDataGenerators ( ) > 0 ) { mDataGenerators . write ( stream ) ; } if ( getNumOutputs ( ) > 0 ) { mOutputs . write ( stream ) ; } } bool SedDocument :: accept ( SedVisitor & v ) const { return false ; } void SedDocument :: setSedDocument ( SedDocument * d ) { SedBase :: setSedDocument ( d ) ; mDataDescriptions . setSedDocument ( d ) ; mSimulations . setSedDocument ( d ) ; mModels . setSedDocument ( d ) ; mTasks . setSedDocument ( d ) ; mDataGenerators . setSedDocument ( d ) ; mOutputs . setSedDocument ( d ) ; } void SedDocument :: addExpectedAttributes ( ExpectedAttributes & attributes ) { SedBase :: addExpectedAttributes ( attributes ) ; attributes . add ( " level " ) ; attributes . add ( " version " ) ; } void SedDocument :: readAttributes ( const XMLAttributes & attributes , const ExpectedAttributes & expectedAttributes ) { SedBase :: readAttributes ( attributes , expectedAttributes ) ; bool assigned = false ; mIsSetLevel = attributes . readInto ( " level " , mLevel , getErrorLog ( ) , true ) ; mIsSetVersion = attributes . readInto ( " version " , mVersion , getErrorLog ( ) , true ) ; } void SedDocument :: writeAttributes ( XMLOutputStream & stream ) const { SedBase :: writeAttributes ( stream ) ; if ( isSetLevel ( ) == true ) stream . writeAttribute ( " level " , getPrefix ( ) , mLevel ) ; if ( isSetVersion ( ) == true ) stream . writeAttribute ( " version " , getPrefix ( ) , mVersion ) ; } const SedError * SedDocument :: getError ( unsigned int n ) const { return mErrorLog . getError ( n ) ; } unsigned int SedDocument :: getNumErrors ( ) const { return mErrorLog . getNumErrors ( ) ; } unsigned int SedDocument :: getNumErrors ( unsigned int severity ) const { return getErrorLog ( ) -> getNumFailsWithSeverity ( severity ) ; } SedErrorLog * SedDocument :: getErrorLog ( ) { return & mErrorLog ; } const SedErrorLog * SedDocument :: getErrorLog ( ) const { return & mErrorLog ; } void SedDocument :: writeXMLNS ( XMLOutputStream & stream ) const { XMLNamespaces * thisNs = this -> getNamespaces ( ) ; if ( thisNs == NULL ) { XMLNamespaces xmlns ; if ( getVersion ( ) == 1 ) xmlns . add ( SEDML_XMLNS_L1V1 ) ; else xmlns . add ( SEDML_XMLNS_L1V2 ) ; mSedNamespaces -> setNamespaces ( & xmlns ) ; thisNs = getNamespaces ( ) ; } else if ( thisNs -> getLength ( ) == 0 ) { if ( getVersion ( ) == 1 ) thisNs -> add ( SEDML_XMLNS_L1V1 ) ; else if ( getVersion ( ) == 2 ) thisNs -> add ( SEDML_XMLNS_L1V2 ) ; else thisNs -> add ( SEDML_XMLNS_L1V3 ) ; } else { std :: string sedmlURI = SedNamespaces :: getSedNamespaceURI ( getLevel ( ) , getVersion ( ) ) ; std :: string sedmlPrefix = thisNs -> getPrefix ( sedmlURI ) ; if ( thisNs -> hasNS ( sedmlURI , sedmlPrefix ) == false ) { std :: string other = thisNs -> getURI ( sedmlPrefix ) ; if ( other . empty ( ) == false ) { thisNs -> remove ( sedmlPrefix ) ; thisNs -> add ( sedmlURI , sedmlPrefix ) ; thisNs -> add ( other , " addedPrefix " ) ; } else { thisNs -> add ( sedmlURI , sedmlPrefix ) ; } } } XMLNamespaces * xmlns = thisNs -> clone ( ) ; if ( xmlns != NULL ) { stream << * ( xmlns ) ; delete xmlns ; } } XMLNamespaces * SedDocument :: getNamespaces ( ) const { return mSedNamespaces -> getNamespaces ( ) ; } LIBSEDML_EXTERN SedDocument_t * SedDocument_create ( unsigned int level , unsigned int version ) { return new SedDocument ( level , version ) ; } LIBSEDML_EXTERN void SedDocument_free ( SedDocument_t * sd ) { if ( sd != NULL ) delete sd ; } LIBSEDML_EXTERN SedDocument_t * SedDocument_clone ( SedDocument_t * sd ) { if ( sd != NULL ) { return static_cast < SedDocument_t * > ( sd -> clone ( ) ) ; } else { return NULL ; } } LIBSEDML_EXTERN int SedDocument_getLevel ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getLevel ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN int SedDocument_getVersion ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getVersion ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN int SedDocument_isSetLevel ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> isSetLevel ( ) ) : 0 ; } LIBSEDML_EXTERN int SedDocument_isSetVersion ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> isSetVersion ( ) ) : 0 ; } LIBSEDML_EXTERN int SedDocument_setLevel ( SedDocument_t * sd , int level ) { return ( sd != NULL ) ? sd -> setLevel ( level ) : LIBSEDML_INVALID_OBJECT ; } LIBSEDML_EXTERN int SedDocument_setVersion ( SedDocument_t * sd , int version ) { return ( sd != NULL ) ? sd -> setVersion ( version ) : LIBSEDML_INVALID_OBJECT ; } LIBSEDML_EXTERN int SedDocument_unsetLevel ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> unsetLevel ( ) : LIBSEDML_INVALID_OBJECT ; } LIBSEDML_EXTERN int SedDocument_unsetVersion ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> unsetVersion ( ) : LIBSEDML_INVALID_OBJECT ; } LIBSEDML_EXTERN int SedDocument_addDataDescription ( SedDocument_t * sd , SedDataDescription_t * sdd ) { return ( sd != NULL ) ? sd -> addDataDescription ( sdd ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_createDataDescription ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createDataDescription ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfDataDescriptions ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfDataDescriptions ( ) : NULL ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_getDataDescription ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getDataDescription ( n ) : NULL ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_getDataDescriptionById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getDataDescription ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumDataDescriptions ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumDataDescriptions ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_removeDataDescription ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeDataDescription ( n ) : NULL ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_removeDataDescriptionById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeDataDescription ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_addSimulation ( SedDocument_t * sd , SedSimulation_t * ss ) { return ( sd != NULL ) ? sd -> addSimulation ( ss ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedUniformTimeCourse_t * SedDocument_createUniformTimeCourse ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createUniformTimeCourse ( ) : NULL ; } LIBSEDML_EXTERN SedOneStep_t * SedDocument_createOneStep ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createOneStep ( ) : NULL ; } LIBSEDML_EXTERN SedSteadyState_t * SedDocument_createSteadyState ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createSteadyState ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfSimulations ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfSimulations ( ) : NULL ; } LIBSEDML_EXTERN SedSimulation_t * SedDocument_getSimulation ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getSimulation ( n ) : NULL ; } LIBSEDML_EXTERN SedSimulation_t * SedDocument_getSimulationById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getSimulation ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumSimulations ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumSimulations ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedSimulation_t * SedDocument_removeSimulation ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeSimulation ( n ) : NULL ; } LIBSEDML_EXTERN SedSimulation_t * SedDocument_removeSimulationById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeSimulation ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_addModel ( SedDocument_t * sd , SedModel_t * sm ) { return ( sd != NULL ) ? sd -> addModel ( sm ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedModel_t * SedDocument_createModel ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createModel ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfModels ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfModels ( ) : NULL ; } LIBSEDML_EXTERN SedModel_t * SedDocument_getModel ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getModel ( n ) : NULL ; } LIBSEDML_EXTERN SedModel_t * SedDocument_getModelById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getModel ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumModels ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumModels ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedModel_t * SedDocument_removeModel ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeModel ( n ) : NULL ; } LIBSEDML_EXTERN SedModel_t * SedDocument_removeModelById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeModel ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_addTask ( SedDocument_t * sd , SedTask_t * st ) { return ( sd != NULL ) ? sd -> addTask ( st ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedTask_t * SedDocument_createTask ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createTask ( ) : NULL ; } LIBSEDML_EXTERN SedRepeatedTask_t * SedDocument_createRepeatedTask ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createRepeatedTask ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfTasks ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfTasks ( ) : NULL ; } LIBSEDML_EXTERN SedTask_t * SedDocument_getTask ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getTask ( n ) : NULL ; } LIBSEDML_EXTERN SedTask_t * SedDocument_getTaskById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getTask ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumTasks ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumTasks ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedTask_t * SedDocument_removeTask ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeTask ( n ) : NULL ; } LIBSEDML_EXTERN SedTask_t * SedDocument_removeTaskById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeTask ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_addDataGenerator ( SedDocument_t * sd , SedDataGenerator_t * sdg ) { return ( sd != NULL ) ? sd -> addDataGenerator ( sdg ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_createDataGenerator ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createDataGenerator ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfDataGenerators ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfDataGenerators ( ) : NULL ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_getDataGenerator ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getDataGenerator ( n ) : NULL ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_getDataGeneratorById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getDataGenerator ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumDataGenerators ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumDataGenerators ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_removeDataGenerator ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeDataGenerator ( n ) : NULL ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_removeDataGeneratorById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeDataGenerator ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_addOutput ( SedDocument_t * sd , SedOutput_t * so ) { return ( sd != NULL ) ? sd -> addOutput ( so ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedReport_t * SedDocument_createReport ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createReport ( ) : NULL ; } LIBSEDML_EXTERN SedPlot2D_t * SedDocument_createPlot2D ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createPlot2D ( ) : NULL ; } LIBSEDML_EXTERN SedPlot3D_t * SedDocument_createPlot3D ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createPlot3D ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfOutputs ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfOutputs ( ) : NULL ; } LIBSEDML_EXTERN SedOutput_t * SedDocument_getOutput ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getOutput ( n ) : NULL ; } LIBSEDML_EXTERN SedOutput_t * SedDocument_getOutputById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getOutput ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumOutputs ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumOutputs ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedOutput_t * SedDocument_removeOutput ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeOutput ( n ) : NULL ; } LIBSEDML_EXTERN SedOutput_t * SedDocument_removeOutputById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeOutput ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_hasRequiredAttributes ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> hasRequiredAttributes ( ) ) : 0 ; } LIBSEDML_EXTERN int SedDocument_hasRequiredElements ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> hasRequiredElements ( ) ) : 0 ; } LIBSEDML_CPP_NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="boiled-sugar/mkvtoolnix/tree/master/src/output/p_mpeg4_p2.cpp"> # include " common / common _ pch . h " # include " avilib . h " # include " common / codec . h " # include " common / endian . h " # include " common / hacks . h " # include " common / math . h " # include " common / strings / formatting . h " # include " merge / generic _ reader . h " # include " merge / output _ control . h " # include " output / p _ mpeg4 _ p2 . h " mpeg4_p2_video_packetizer_c :: mpeg4_p2_video_packetizer_c ( generic_reader_c * p_reader , track_info_c & p_ti , double fps , int width , int height , bool input_is_native ) : video_for_windows_packetizer_c ( p_reader , p_ti , fps , width , height ) , m_timecodes_generated ( 0 ) , m_previous_timecode ( 0 ) , m_aspect_ratio_extracted ( false ) , m_input_is_native ( input_is_native ) , m_output_is_native ( hack_engaged ( ENGAGE_NATIVE_MPEG4 ) || input_is_native ) , m_size_extracted ( false ) { if ( ! m_output_is_native ) m_timestamp_factory_application_mode = TFA_SHORT_QUEUEING ; else { set_codec_id ( MKV_V_MPEG4_ASP ) ; if ( ! m_input_is_native ) m_ti . m_private_data . reset ( ) ; if ( m_ti . m_ext_timecodes . empty ( ) ) m_timestamp_factory . reset ( ) ; if ( m_default_duration_forced ) m_fps = 1000000000.0 / m_htrack_default_duration ; else if ( 0.0 != m_fps ) m_htrack_default_duration = static_cast < int64_t > ( 1000000000ll / m_fps ) ; m_timestamp_factory_application_mode = TFA_FULL_QUEUEING ; } } mpeg4_p2_video_packetizer_c :: ~ mpeg4_p2_video_packetizer_c ( ) { if ( ! debugging_c :: requested ( " mpeg4 _ p2 _ statistics " ) ) return ; mxinfo ( boost :: format ( " mpeg4 _ p2 _ video _ packetizer _ c ▁ statistics : \n " " ▁ ▁ # ▁ I ▁ frames : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 1 % \n " " ▁ ▁ # ▁ P ▁ frames : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 2 % \n " " ▁ ▁ # ▁ B ▁ frames : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 3 % \n " " ▁ ▁ # ▁ NVOPs : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 4 % \n " " ▁ ▁ # ▁ generated ▁ timecodes : ▁ % 5 % \n " " ▁ ▁ # ▁ dropped ▁ timecodes : ▁ ▁ ▁ % 6 % \n " ) % m_statistics . m_num_i_frames % m_statistics . m_num_p_frames % m_statistics . m_num_b_frames % m_statistics . m_num_n_vops % m_statistics . m_num_generated_timecodes % m_statistics . m_num_dropped_timecodes ) ; } int mpeg4_p2_video_packetizer_c :: process ( packet_cptr packet ) { extract_size ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) ) ; extract_aspect_ratio ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) ) ; int result = m_input_is_native == m_output_is_native ? video_for_windows_packetizer_c :: process ( packet ) : m_input_is_native ? process_native ( packet ) : process_non_native ( packet ) ; ++ m_frames_output ; return result ; } int mpeg4_p2_video_packetizer_c :: process_non_native ( packet_cptr packet ) { extract_config_data ( packet ) ; if ( - 1 != packet -> timecode ) { if ( ! m_default_duration_forced ) m_available_timecodes . push_back ( timecode_duration_t ( packet -> timecode , packet -> duration ) ) ; else { m_available_timecodes . push_back ( timecode_duration_t ( m_timecodes_generated * m_htrack_default_duration , m_htrack_default_duration ) ) ; ++ m_timecodes_generated ; } } else if ( 0.0 == m_fps ) mxerror_tid ( m_ti . m_fname , m_ti . m_id , Y ( " Cannot ▁ convert ▁ non - native ▁ MPEG4 ▁ video ▁ frames ▁ into ▁ native ▁ ones ▁ if ▁ the ▁ source ▁ container ▁ " " provides ▁ neither ▁ timecodes ▁ nor ▁ a ▁ number ▁ of ▁ frames ▁ per ▁ second . \n " ) ) ; std :: vector < video_frame_t > frames ; mpeg4 :: p2 :: find_frame_types ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) , frames , m_config_data ) ; for ( auto & frame : frames ) { if ( ! frame . is_coded ) { ++ m_statistics . m_num_n_vops ; int num_surplus_timecodes = static_cast < int > ( m_available_timecodes . size ( ) ) - static_cast < int > ( m_ref_frames . size ( ) + m_b_frames . size ( ) ) ; if ( 0 < num_surplus_timecodes ) { std :: deque < timecode_duration_t > :: iterator start = m_available_timecodes . begin ( ) + m_ref_frames . size ( ) + m_b_frames . size ( ) ; std :: deque < timecode_duration_t > :: iterator end = start + num_surplus_timecodes ; if ( 0 != ( m_ref_frames . size ( ) + m_b_frames . size ( ) ) ) { std :: deque < timecode_duration_t > :: iterator last = m_available_timecodes . begin ( ) + m_ref_frames . size ( ) + m_b_frames . size ( ) - 1 ; std :: deque < timecode_duration_t > :: iterator cur = start ; while ( cur != end ) { last -> m_duration = std :: max ( last -> m_duration , static_cast < int64_t > ( 0 ) ) + std :: max ( cur -> m_duration , static_cast < int64_t > ( 0 ) ) ; ++ cur ; } } m_available_timecodes . erase ( start , end ) ; m_statistics . m_num_dropped_timecodes += num_surplus_timecodes ; } continue ; } if ( FRAME_TYPE_I == frame . type ) ++ m_statistics . m_num_i_frames ; else if ( FRAME_TYPE_P == frame . type ) ++ m_statistics . m_num_p_frames ; else ++ m_statistics . m_num_b_frames ; if ( FRAME_TYPE_B != frame . type ) flush_frames ( false ) ; frame . data = ( unsigned char * ) safememdup ( packet -> data -> get_buffer ( ) + frame . pos , frame . size ) ; frame . timecode = - 1 ; if ( FRAME_TYPE_B == frame . type ) m_b_frames . push_back ( frame ) ; else m_ref_frames . push_back ( frame ) ; } m_previous_timecode = m_available_timecodes . back ( ) . m_timecode ; return FILE_STATUS_MOREDATA ; } void mpeg4_p2_video_packetizer_c :: extract_config_data ( packet_cptr & packet ) { if ( m_ti . m_private_data ) return ; m_ti . m_private_data = memory_cptr { mpeg4 :: p2 :: parse_config_data ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) , m_config_data ) } ; if ( ! m_ti . m_private_data ) mxerror_tid ( m_ti . m_fname , m_ti . m_id , Y ( " Could ▁ not ▁ find ▁ the ▁ codec ▁ configuration ▁ data ▁ in ▁ the ▁ first ▁ MPEG - 4 ▁ part ▁ 2 ▁ video ▁ frame . ▁ This ▁ track ▁ cannot ▁ be ▁ stored ▁ in ▁ native ▁ mode . \n " ) ) ; fix_codec_string ( ) ; set_codec_private ( m_ti . m_private_data ) ; rerender_track_headers ( ) ; } void mpeg4_p2_video_packetizer_c :: fix_codec_string ( ) { static const unsigned char start_code [ 4 ] = { 0x00 , 0x00 , 0x01 , 0xb2 } ; if ( ! m_ti . m_private_data || ( 0 == m_ti . m_private_data -> get_size ( ) ) ) return ; auto private_data = m_ti . m_private_data -> get_buffer ( ) ; int size = m_ti . m_private_data -> get_size ( ) ; int i ; for ( i = 0 ; 9 < size ; ) { if ( memcmp ( & private_data [ i ] , start_code , 4 ) != 0 ) { ++ i ; -- size ; continue ; } i += 8 ; size -= 8 ; if ( strncasecmp ( ( const char * ) & private_data [ i - 4 ] , " divx " , 4 ) != 0 ) continue ; unsigned char * end_pos = ( unsigned char * ) memchr ( & private_data [ i ] , 0 , size ) ; if ( ! end_pos ) end_pos = & private_data [ i + size ] ; -- end_pos ; if ( ' p ' == * end_pos ) * end_pos = ' n ' ; return ; } } int mpeg4_p2_video_packetizer_c :: process_native ( packet_cptr ) { return FILE_STATUS_MOREDATA ; } void mpeg4_p2_video_packetizer_c :: generate_timecode_and_duration ( ) { if ( 0.0 >= m_fps ) { mxexit ( 1 ) ; } if ( m_available_timecodes . empty ( ) ) { m_previous_timecode = ( int64_t ) ( m_previous_timecode + 1000000000.0 / m_fps ) ; m_available_timecodes . push_back ( timecode_duration_t ( m_previous_timecode , ( int64_t ) ( 1000000000.0 / m_fps ) ) ) ; mxverb ( 3 , boost :: format ( " mpeg4 _ p2 : : flush _ frames ( ) : ▁ Needed ▁ new ▁ timecode ▁ % 1 % \n " ) % m_previous_timecode ) ; ++ m_statistics . m_num_generated_timecodes ; } } void mpeg4_p2_video_packetizer_c :: get_next_timecode_and_duration ( int64_t & timecode , int64_t & duration ) { if ( m_available_timecodes . empty ( ) ) generate_timecode_and_duration ( ) ; timecode = m_available_timecodes . front ( ) . m_timecode ; duration = m_available_timecodes . front ( ) . m_duration ; m_available_timecodes . pop_front ( ) ; } void mpeg4_p2_video_packetizer_c :: flush_frames ( bool end_of_file ) { if ( m_ref_frames . empty ( ) ) return ; if ( m_ref_frames . size ( ) == 1 ) { video_frame_t & frame = m_ref_frames . front ( ) ; if ( - 1 == frame . timecode ) { get_next_timecode_and_duration ( frame . timecode , frame . duration ) ; add_packet ( new packet_t ( new memory_c ( frame . data , frame . size , true ) , frame . timecode , frame . duration ) ) ; } return ; } video_frame_t & bref_frame = m_ref_frames . front ( ) ; video_frame_t & fref_frame = m_ref_frames . back ( ) ; for ( auto & frame : m_b_frames ) get_next_timecode_and_duration ( frame . timecode , frame . duration ) ; get_next_timecode_and_duration ( fref_frame . timecode , fref_frame . duration ) ; add_packet ( new packet_t ( new memory_c ( fref_frame . data , fref_frame . size , true ) , fref_frame . timecode , fref_frame . duration , FRAME_TYPE_P == fref_frame . type ? bref_frame . timecode : VFT_IFRAME ) ) ; for ( auto & frame : m_b_frames ) add_packet ( new packet_t ( new memory_c ( frame . data , frame . size , true ) , frame . timecode , frame . duration , bref_frame . timecode , fref_frame . timecode ) ) ; m_ref_frames . pop_front ( ) ; m_b_frames . clear ( ) ; if ( end_of_file ) m_ref_frames . clear ( ) ; } void mpeg4_p2_video_packetizer_c :: flush_impl ( ) { flush_frames ( true ) ; } void mpeg4_p2_video_packetizer_c :: extract_aspect_ratio ( const unsigned char * buffer , int size ) { if ( m_aspect_ratio_extracted ) return ; if ( ( 0 != m_connected_to ) || display_dimensions_or_aspect_ratio_set ( ) ) { m_aspect_ratio_extracted = true ; return ; } uint32_t num , den ; if ( mpeg4 :: p2 :: extract_par ( buffer , size , num , den ) ) { m_aspect_ratio_extracted = true ; set_video_aspect_ratio ( ( double ) m_hvideo_pixel_width / ( double ) m_hvideo_pixel_height * ( double ) num / ( double ) den , false , OPTION_SOURCE_BITSTREAM ) ; generic_packetizer_c :: set_headers ( ) ; rerender_track_headers ( ) ; mxinfo_tid ( m_ti . m_fname , m_ti . m_id , boost :: format ( Y ( " Extracted ▁ the ▁ aspect ▁ ratio ▁ information ▁ from ▁ the ▁ MPEG4 ▁ layer ▁ 2 ▁ video ▁ data ▁ and ▁ set ▁ the ▁ display ▁ dimensions ▁ to ▁ % 1 % / %2 % . \n " ) ) % m_hvideo_display_width % m_hvideo_display_height ) ; } else if ( 50 <= m_frames_output ) m_aspect_ratio_extracted = true ; } void mpeg4_p2_video_packetizer_c :: extract_size ( const unsigned char * buffer , int size ) { if ( m_size_extracted ) return ; if ( 0 != m_connected_to ) { m_size_extracted = true ; return ; } uint32_t xtr_width , xtr_height ; if ( mpeg4 :: p2 :: extract_size ( buffer , size , xtr_width , xtr_height ) ) { m_size_extracted = true ; if ( ! m_reader -> m_appending && ( ( xtr_width != static_cast < uint32_t > ( m_hvideo_pixel_width ) ) || ( xtr_height != static_cast < uint32_t > ( m_hvideo_pixel_height ) ) ) ) { set_video_pixel_width ( xtr_width ) ; set_video_pixel_height ( xtr_height ) ; if ( ! m_output_is_native && m_ti . m_private_data && ( sizeof ( alBITMAPINFOHEADER ) <= m_ti . m_private_data -> get_size ( ) ) ) { auto bih = reinterpret_cast < alBITMAPINFOHEADER * > ( m_ti . m_private_data -> get_buffer ( ) ) ; put_uint32_le ( & bih -> bi_width , xtr_width ) ; put_uint32_le ( & bih -> bi_height , xtr_height ) ; set_codec_private ( m_ti . m_private_data ) ; } m_hvideo_display_width = - 1 ; m_hvideo_display_height = - 1 ; generic_packetizer_c :: set_headers ( ) ; rerender_track_headers ( ) ; mxinfo_tid ( m_ti . m_fname , m_ti . m_id , boost :: format ( Y ( " The ▁ extracted ▁ values ▁ for ▁ video ▁ width ▁ and ▁ height ▁ from ▁ the ▁ MPEG4 ▁ layer ▁ 2 ▁ video ▁ data ▁ bitstream ▁ differ ▁ from ▁ what ▁ the ▁ values ▁ " " in ▁ the ▁ source ▁ container . ▁ The ▁ ones ▁ from ▁ the ▁ video ▁ data ▁ bitstream ▁ ( %1 % x % 2 % ) ▁ will ▁ be ▁ used . \n " ) ) % xtr_width % xtr_height ) ; } } else if ( 50 <= m_frames_output ) m_aspect_ratio_extracted = true ; } </DOCUMENT>
<DOCUMENT_ID="nawawi/wkhtmltopdf/tree/master/webkit/Source/WebCore/bindings/js/JSDocumentCustom.cpp"> # include " config . h " # include " JSDocument . h " # include " ExceptionCode . h " # include " Frame . h " # include " FrameLoader . h " # include " HTMLDocument . h " # include " JSCanvasRenderingContext2D . h " # if ENABLE ( WEBGL ) # include " JSWebGLRenderingContext . h " # endif # include " JSDOMWindowCustom . h " # include " JSHTMLDocument . h " # include " JSLocation . h " # include " JSTouch . h " # include " JSTouchList . h " # include " Location . h " # include " ScriptController . h " # include " TouchList . h " # if ENABLE ( SVG ) # include " JSSVGDocument . h " # include " SVGDocument . h " # endif # include < wtf / GetPtr . h > using namespace JSC ; namespace WebCore { JSValue JSDocument :: location ( ExecState * exec ) const { Frame * frame = static_cast < Document * > ( impl ( ) ) -> frame ( ) ; if ( ! frame ) return jsNull ( ) ; Location * location = frame -> document ( ) -> domWindow ( ) -> location ( ) ; if ( JSDOMWrapper * wrapper = getCachedWrapper ( currentWorld ( exec ) , location ) ) return wrapper ; JSLocation * jsLocation = JSLocation :: create ( getDOMStructure < JSLocation > ( exec , globalObject ( ) ) , globalObject ( ) , location ) ; cacheWrapper ( currentWorld ( exec ) , location , jsLocation ) ; return jsLocation ; } void JSDocument :: setLocation ( ExecState * exec , JSValue value ) { Frame * frame = static_cast < Document * > ( impl ( ) ) -> frame ( ) ; if ( ! frame ) return ; String locationString = value . toString ( exec ) -> value ( exec ) ; if ( exec -> hadException ( ) ) return ; if ( Location * location = frame -> document ( ) -> domWindow ( ) -> location ( ) ) location -> setHref ( locationString , activeDOMWindow ( exec ) , firstDOMWindow ( exec ) ) ; } JSValue toJS ( ExecState * exec , JSDOMGlobalObject * globalObject , Document * document ) { if ( ! document ) return jsNull ( ) ; JSDOMWrapper * wrapper = getCachedWrapper ( currentWorld ( exec ) , document ) ; if ( wrapper ) return wrapper ; if ( DOMWindow * domWindow = document -> domWindow ( ) ) { globalObject = toJSDOMWindow ( toJS ( exec , domWindow ) ) ; wrapper = getCachedWrapper ( currentWorld ( exec ) , document ) ; if ( wrapper ) return wrapper ; } if ( document -> isHTMLDocument ( ) ) wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , HTMLDocument , document ) ; # if ENABLE ( SVG ) else if ( document -> isSVGDocument ( ) ) wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , SVGDocument , document ) ; # endif else wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , Document , document ) ; if ( ! document -> frame ( ) ) { size_t nodeCount = 0 ; for ( Node * n = document ; n ; n = n -> traverseNextNode ( ) ) nodeCount ++ ; exec -> heap ( ) -> reportExtraMemoryCost ( nodeCount * sizeof ( Node ) ) ; } return wrapper ; } # if ENABLE ( TOUCH_EVENTS ) JSValue JSDocument :: createTouchList ( ExecState * exec ) { RefPtr < TouchList > touchList = TouchList :: create ( ) ; for ( size_t i = 0 ; i < exec -> argumentCount ( ) ; i ++ ) touchList -> append ( toTouch ( exec -> argument ( i ) ) ) ; return toJS ( exec , globalObject ( ) , touchList . release ( ) ) ; } # endif } </DOCUMENT>
<DOCUMENT_ID="eugene1g/phantomjs/tree/master/src/qt/qtwebkit/Source/WebCore/css/CSSSupportsRule.cpp"> # include " config . h " # include " CSSSupportsRule . h " # include " CSSParser . h " # include " CSSRule . h " # include " CSSRuleList . h " # include " CSSStyleSheet . h " # include " ExceptionCode . h " # include " StyleRule . h " # include < wtf / text / StringBuilder . h > # if ENABLE ( CSS3_CONDITIONAL_RULES ) namespace WebCore { CSSSupportsRule :: CSSSupportsRule ( StyleRuleSupports * supportsRule , CSSStyleSheet * parent ) : CSSGroupingRule ( supportsRule , parent ) { } String CSSSupportsRule :: cssText ( ) const { StringBuilder result ; result . append ( " @ supports ▁ " ) ; result . append ( conditionText ( ) ) ; result . append ( " ▁ { \n " ) ; appendCssTextForItems ( result ) ; result . append ( ' } ' ) ; return result . toString ( ) ; } String CSSSupportsRule :: conditionText ( ) const { return toStyleRuleSupports ( m_groupRule . get ( ) ) -> conditionText ( ) ; } } # endif </DOCUMENT>
<DOCUMENT_ID="Hual/SA-MP-Plus/tree/master/Common/RakNet/VariableDeltaSerializer.cpp"> # include " VariableDeltaSerializer . h " using namespace RakNet ; VariableDeltaSerializer :: VariableDeltaSerializer ( ) { didComparisonThisTick = false ; } VariableDeltaSerializer :: ~ VariableDeltaSerializer ( ) { RemoveRemoteSystemVariableHistory ( ) ; } VariableDeltaSerializer :: SerializationContext :: SerializationContext ( ) { variableHistoryIdentical = 0 ; variableHistoryUnique = 0 ; } VariableDeltaSerializer :: SerializationContext :: ~ SerializationContext ( ) { } void VariableDeltaSerializer :: OnMessageReceipt ( RakNetGUID guid , uint32_t receiptId , bool messageArrived ) { if ( messageArrived ) FreeVarsAssociatedWithReceipt ( guid , receiptId ) ; else DirtyAndFreeVarsAssociatedWithReceipt ( guid , receiptId ) ; } void VariableDeltaSerializer :: BeginUnreliableAckedSerialize ( SerializationContext * context , RakNetGUID _guid , BitStream * _bitStream , uint32_t _sendReceipt ) { RakAssert ( _guid != UNASSIGNED_RAKNET_GUID ) ; context -> anyVariablesWritten = false ; context -> guid = _guid ; context -> bitStream = _bitStream ; if ( context -> variableHistoryUnique == 0 ) context -> variableHistoryUnique = StartVariableHistoryWrite ( _guid ) ; context -> variableHistory = context -> variableHistoryUnique ; context -> sendReceipt = _sendReceipt ; context -> changedVariables = AllocChangedVariablesList ( ) ; context -> newSystemSend = false ; context -> serializationMode = UNRELIABLE_WITH_ACK_RECEIPT ; } void VariableDeltaSerializer :: BeginUniqueSerialize ( SerializationContext * context , RakNetGUID _guid , BitStream * _bitStream ) { RakAssert ( _guid != UNASSIGNED_RAKNET_GUID ) ; context -> anyVariablesWritten = false ; context -> guid = _guid ; context -> bitStream = _bitStream ; if ( context -> variableHistoryUnique == 0 ) context -> variableHistoryUnique = StartVariableHistoryWrite ( _guid ) ; context -> variableHistory = context -> variableHistoryUnique ; context -> newSystemSend = false ; context -> serializationMode = RELIABLE ; } void VariableDeltaSerializer :: BeginIdenticalSerialize ( SerializationContext * context , bool _isFirstSendToRemoteSystem , BitStream * _bitStream ) { context -> anyVariablesWritten = false ; context -> guid = UNASSIGNED_RAKNET_GUID ; context -> bitStream = _bitStream ; context -> serializationMode = RELIABLE ; if ( context -> variableHistoryIdentical == 0 ) context -> variableHistoryIdentical = StartVariableHistoryWrite ( UNASSIGNED_RAKNET_GUID ) ; context -> variableHistory = context -> variableHistoryIdentical ; context -> newSystemSend = _isFirstSendToRemoteSystem ; } void VariableDeltaSerializer :: EndSerialize ( SerializationContext * context ) { if ( context -> serializationMode == UNRELIABLE_WITH_ACK_RECEIPT ) { if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; FreeChangedVariablesList ( context -> changedVariables ) ; return ; } StoreChangedVariablesList ( context -> variableHistory , context -> changedVariables , context -> sendReceipt ) ; } else { if ( context -> variableHistoryIdentical ) { if ( didComparisonThisTick == false ) { didComparisonThisTick = true ; identicalSerializationBs . Reset ( ) ; if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; return ; } identicalSerializationBs . Write ( context -> bitStream ) ; context -> bitStream -> ResetReadPointer ( ) ; } else { context -> bitStream -> Write ( & identicalSerializationBs ) ; identicalSerializationBs . ResetReadPointer ( ) ; } } else if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; return ; } } } void VariableDeltaSerializer :: BeginDeserialize ( DeserializationContext * context , BitStream * _bitStream ) { context -> bitStream = _bitStream ; } void VariableDeltaSerializer :: EndDeserialize ( DeserializationContext * context ) { ( void ) context ; } void VariableDeltaSerializer :: AddRemoteSystemVariableHistory ( RakNetGUID guid ) { ( void ) guid ; } void VariableDeltaSerializer :: RemoveRemoteSystemVariableHistory ( RakNetGUID guid ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) { for ( idx2 = 0 ; idx2 < remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory . Size ( ) ; idx2 ++ ) { FreeChangedVariablesList ( remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory [ idx2 ] ) ; } delete remoteSystemVariableHistoryList [ idx ] ; remoteSystemVariableHistoryList . RemoveAtIndexFast ( idx ) ; return ; } } int RakNet :: VariableDeltaSerializer :: UpdatedVariablesListPtrComp ( const uint32_t & key , ChangedVariablesList * const & data ) { if ( key < data -> sendReceipt ) return - 1 ; if ( key == data -> sendReceipt ) return 0 ; return 1 ; } void VariableDeltaSerializer :: FreeVarsAssociatedWithReceipt ( RakNetGUID guid , uint32_t receiptId ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; RemoteSystemVariableHistory * vprs = remoteSystemVariableHistoryList [ idx ] ; bool objectExists ; idx2 = vprs -> updatedVariablesHistory . GetIndexFromKey ( receiptId , & objectExists ) ; if ( objectExists ) { FreeChangedVariablesList ( vprs -> updatedVariablesHistory [ idx2 ] ) ; vprs -> updatedVariablesHistory . RemoveAtIndex ( idx2 ) ; } } void VariableDeltaSerializer :: DirtyAndFreeVarsAssociatedWithReceipt ( RakNetGUID guid , uint32_t receiptId ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; RemoteSystemVariableHistory * vprs = remoteSystemVariableHistoryList [ idx ] ; bool objectExists ; idx2 = vprs -> updatedVariablesHistory . GetIndexFromKey ( receiptId , & objectExists ) ; if ( objectExists ) { vprs -> variableListDeltaTracker . FlagDirtyFromBitArray ( vprs -> updatedVariablesHistory [ idx2 ] -> bitField ) ; FreeChangedVariablesList ( vprs -> updatedVariablesHistory [ idx2 ] ) ; vprs -> updatedVariablesHistory . RemoveAtIndex ( idx2 ) ; } } unsigned int VariableDeltaSerializer :: GetVarsWrittenPerRemoteSystemListIndex ( RakNetGUID guid ) { unsigned int idx ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) return idx ; } return ( unsigned int ) - 1 ; } void VariableDeltaSerializer :: RemoveRemoteSystemVariableHistory ( void ) { unsigned int idx , idx2 ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { for ( idx2 = 0 ; idx2 < remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory . Size ( ) ; idx2 ++ ) { FreeChangedVariablesList ( remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory [ idx2 ] ) ; } delete remoteSystemVariableHistoryList [ idx ] ; } remoteSystemVariableHistoryList . Clear ( false , _FILE_AND_LINE_ ) ; } VariableDeltaSerializer :: RemoteSystemVariableHistory * VariableDeltaSerializer :: GetRemoteSystemVariableHistory ( RakNetGUID guid ) { unsigned int rshli = GetRemoteSystemHistoryListIndex ( guid ) ; return remoteSystemVariableHistoryList [ rshli ] ; } VariableDeltaSerializer :: ChangedVariablesList * VariableDeltaSerializer :: AllocChangedVariablesList ( void ) { VariableDeltaSerializer :: ChangedVariablesList * p = updatedVariablesMemoryPool . Allocate ( _FILE_AND_LINE_ ) ; p -> bitWriteIndex = 0 ; p -> bitField [ 0 ] = 0 ; return p ; } void VariableDeltaSerializer :: FreeChangedVariablesList ( ChangedVariablesList * changedVariables ) { updatedVariablesMemoryPool . Release ( changedVariables , _FILE_AND_LINE_ ) ; } void VariableDeltaSerializer :: StoreChangedVariablesList ( RemoteSystemVariableHistory * variableHistory , ChangedVariablesList * changedVariables , uint32_t sendReceipt ) { changedVariables -> sendReceipt = sendReceipt ; variableHistory -> updatedVariablesHistory . Insert ( changedVariables -> sendReceipt , changedVariables , true , _FILE_AND_LINE_ ) ; } VariableDeltaSerializer :: RemoteSystemVariableHistory * VariableDeltaSerializer :: StartVariableHistoryWrite ( RakNetGUID guid ) { RemoteSystemVariableHistory * variableHistory ; unsigned int rshli = GetRemoteSystemHistoryListIndex ( guid ) ; if ( rshli == ( unsigned int ) - 1 ) { variableHistory = new RemoteSystemVariableHistory ; variableHistory -> guid = guid ; remoteSystemVariableHistoryList . Push ( variableHistory , _FILE_AND_LINE_ ) ; } else { variableHistory = remoteSystemVariableHistoryList [ rshli ] ; } variableHistory -> variableListDeltaTracker . StartWrite ( ) ; return variableHistory ; } unsigned int VariableDeltaSerializer :: GetRemoteSystemHistoryListIndex ( RakNetGUID guid ) { unsigned int idx ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) { return idx ; } } return ( unsigned int ) - 1 ; } void VariableDeltaSerializer :: OnPreSerializeTick ( void ) { didComparisonThisTick = false ; } </DOCUMENT>
<DOCUMENT_ID="cryptometh/cryptometh_1/tree/master/src/cryptopp/vmac.cpp"> # include " pch . h " # include " vmac . h " # include " argnames . h " # include " cpu . h " NAMESPACE_BEGIN ( CryptoPP ) # if defined ( _MSC_VER ) && ! CRYPTOPP_BOOL_SLOW_WORD64 # include < intrin . h > # endif # define VMAC_BOOL_WORD128 ( defined ( CRYPTOPP_WORD128_AVAILABLE ) && ! defined ( CRYPTOPP_X64_ASM_AVAILABLE ) ) # ifdef __BORLANDC__ # define const # endif static const word64 p64 = W64LIT ( 0xfffffffffffffeff ) ; static const word64 m62 = W64LIT ( 0x3fffffffffffffff ) ; static const word64 m63 = W64LIT ( 0x7fffffffffffffff ) ; static const word64 m64 = W64LIT ( 0xffffffffffffffff ) ; static const word64 mpoly = W64LIT ( 0x1fffffff1fffffff ) ; # ifdef __BORLANDC__ # undef const # endif # if VMAC_BOOL_WORD128 # ifdef __powerpc__ # define m126 ( ( word128 ( m62 ) << 64 ) | m64 ) # else static const word128 m126 = ( word128 ( m62 ) << 64 ) | m64 ; # endif # endif void VMAC_Base :: UncheckedSetKey ( const byte * userKey , unsigned int keylength , const NameValuePairs & params ) { int digestLength = params . GetIntValueWithDefault ( Name :: DigestSize ( ) , DefaultDigestSize ( ) ) ; if ( digestLength != 8 && digestLength != 16 ) throw InvalidArgument ( " VMAC : ▁ DigestSize ▁ must ▁ be ▁ 8 ▁ or ▁ 16" ) ; m_is128 = digestLength == 16 ; m_L1KeyLength = params . GetIntValueWithDefault ( Name :: L1KeyLength ( ) , 128 ) ; if ( m_L1KeyLength <= 0 || m_L1KeyLength % 128 != 0 ) throw InvalidArgument ( " VMAC : ▁ L1KeyLength ▁ must ▁ be ▁ a ▁ positive ▁ multiple ▁ of ▁ 128" ) ; AllocateBlocks ( ) ; BlockCipher & cipher = AccessCipher ( ) ; cipher . SetKey ( userKey , keylength , params ) ; unsigned int blockSize = cipher . BlockSize ( ) ; unsigned int blockSizeInWords = blockSize / sizeof ( word64 ) ; SecBlock < word64 > out ( blockSizeInWords ) ; SecByteBlock in ; in . CleanNew ( blockSize ) ; size_t i ; in [ 0 ] = 0x80 ; cipher . AdvancedProcessBlocks ( in , NULL , ( byte * ) m_nhKey ( ) , m_nhKeySize ( ) * sizeof ( word64 ) , cipher . BT_InBlockIsCounter ) ; ConditionalByteReverse < word64 > ( BIG_ENDIAN_ORDER , m_nhKey ( ) , m_nhKey ( ) , m_nhKeySize ( ) * sizeof ( word64 ) ) ; in [ 0 ] = 0xC0 ; in [ 15 ] = 0 ; for ( i = 0 ; i <= ( size_t ) m_is128 ; i ++ ) { cipher . ProcessBlock ( in , out . BytePtr ( ) ) ; m_polyState ( ) [ i * 4 + 2 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) ) & mpoly ; m_polyState ( ) [ i * 4 + 3 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) + 8 ) & mpoly ; in [ 15 ] ++ ; } in [ 0 ] = 0xE0 ; in [ 15 ] = 0 ; word64 * l3Key = m_l3Key ( ) ; for ( i = 0 ; i <= ( size_t ) m_is128 ; i ++ ) do { cipher . ProcessBlock ( in , out . BytePtr ( ) ) ; l3Key [ i * 2 + 0 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) ) ; l3Key [ i * 2 + 1 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) + 8 ) ; in [ 15 ] ++ ; } while ( ( l3Key [ i * 2 + 0 ] >= p64 ) || ( l3Key [ i * 2 + 1 ] >= p64 ) ) ; m_padCached = false ; size_t nonceLength ; const byte * nonce = GetIVAndThrowIfInvalid ( params , nonceLength ) ; Resynchronize ( nonce , ( int ) nonceLength ) ; } void VMAC_Base :: GetNextIV ( RandomNumberGenerator & rng , byte * IV ) { SimpleKeyingInterface :: GetNextIV ( rng , IV ) ; IV [ 0 ] &= 0x7f ; } void VMAC_Base :: Resynchronize ( const byte * nonce , int len ) { size_t length = ThrowIfInvalidIVLength ( len ) ; size_t s = IVSize ( ) ; byte * storedNonce = m_nonce ( ) ; if ( m_is128 ) { memset ( storedNonce , 0 , s - length ) ; memcpy ( storedNonce + s - length , nonce , length ) ; AccessCipher ( ) . ProcessBlock ( storedNonce , m_pad ( ) ) ; } else { if ( m_padCached && ( storedNonce [ s - 1 ] | 1 ) == ( nonce [ length - 1 ] | 1 ) ) { m_padCached = VerifyBufsEqual ( storedNonce + s - length , nonce , length - 1 ) ; for ( size_t i = 0 ; m_padCached && i < s - length ; i ++ ) m_padCached = ( storedNonce [ i ] == 0 ) ; } if ( ! m_padCached ) { memset ( storedNonce , 0 , s - length ) ; memcpy ( storedNonce + s - length , nonce , length - 1 ) ; storedNonce [ s - 1 ] = nonce [ length - 1 ] & 0xfe ; AccessCipher ( ) . ProcessBlock ( storedNonce , m_pad ( ) ) ; m_padCached = true ; } storedNonce [ s - 1 ] = nonce [ length - 1 ] ; } m_isFirstBlock = true ; Restart ( ) ; } void VMAC_Base :: HashEndianCorrectedBlock ( const word64 * data ) { assert ( false ) ; throw 0 ; } # if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86 # pragma warning ( disable : 4731 ) void # ifdef __GNUC__ __attribute__ ( ( noinline ) ) # endif VMAC_Base :: VHASH_Update_SSE2 ( const word64 * data , size_t blocksRemainingInWord64 , int tagPart ) { const word64 * nhK = m_nhKey ( ) ; word64 * polyS = m_polyState ( ) ; word32 L1KeyLength = m_L1KeyLength ; # ifdef __GNUC__ word32 temp ; __asm__ __volatile__ ( AS2 ( mov % % ebx , % 0 ) AS2 ( mov % 1 , % % ebx ) " . intel _ syntax ▁ noprefix ; " # else # if _MSC_VER < 1300 || defined ( __INTEL_COMPILER ) char isFirstBlock = m_isFirstBlock ; AS2 ( mov ebx , [ L1KeyLength ] ) AS2 ( mov dl , [ isFirstBlock ] ) # else AS2 ( mov ecx , this ) AS2 ( mov ebx , [ ecx + m_L1KeyLength ] ) AS2 ( mov dl , [ ecx + m_isFirstBlock ] ) # endif AS2 ( mov eax , tagPart ) AS2 ( shl eax , 4 ) AS2 ( mov edi , nhK ) AS2 ( add edi , eax ) AS2 ( add eax , eax ) AS2 ( add eax , polyS ) AS2 ( mov esi , data ) AS2 ( mov ecx , blocksRemainingInWord64 ) # endif AS2 ( shr ebx , 3 ) AS1 ( push ebp ) AS2 ( sub esp , 12 ) ASL ( 4 ) AS2 ( mov ebp , ebx ) AS2 ( cmp ecx , ebx ) AS2 ( cmovl ebp , ecx ) AS2 ( sub ecx , ebp ) AS2 ( lea ebp , [ edi + 8 * ebp ] ) AS2 ( movq mm6 , [ esi ] ) AS2 ( paddq mm6 , [ edi ] ) AS2 ( movq mm5 , [ esi + 8 ] ) AS2 ( paddq mm5 , [ edi + 8 ] ) AS2 ( add esi , 16 ) AS2 ( add edi , 16 ) AS2 ( movq mm4 , mm6 ) ASS ( pshufw mm2 , mm6 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm6 , mm5 ) ASS ( pshufw mm3 , mm5 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm5 , mm2 ) AS2 ( pmuludq mm2 , mm3 ) AS2 ( pmuludq mm3 , mm4 ) AS2 ( pxor mm7 , mm7 ) AS2 ( movd [ esp ] , mm6 ) AS2 ( psrlq mm6 , 32 ) AS2 ( movd [ esp + 4 ] , mm5 ) AS2 ( psrlq mm5 , 32 ) AS2 ( cmp edi , ebp ) ASJ ( je , 1 , f ) ASL ( 0 ) AS2 ( movq mm0 , [ esi ] ) AS2 ( paddq mm0 , [ edi ] ) AS2 ( movq mm1 , [ esi + 8 ] ) AS2 ( paddq mm1 , [ edi + 8 ] ) AS2 ( add esi , 16 ) AS2 ( add edi , 16 ) AS2 ( movq mm4 , mm0 ) AS2 ( paddq mm5 , mm2 ) ASS ( pshufw mm2 , mm0 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm0 , mm1 ) AS2 ( movd [ esp + 8 ] , mm3 ) AS2 ( psrlq mm3 , 32 ) AS2 ( paddq mm5 , mm3 ) ASS ( pshufw mm3 , mm1 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm1 , mm2 ) AS2 ( pmuludq mm2 , mm3 ) AS2 ( pmuludq mm3 , mm4 ) AS2 ( movd mm4 , [ esp ] ) AS2 ( paddq mm7 , mm4 ) AS2 ( movd mm4 , [ esp + 4 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( movd mm4 , [ esp + 8 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( movd [ esp ] , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( paddq mm6 , mm0 ) AS2 ( movd [ esp + 4 ] , mm1 ) AS2 ( psrlq mm1 , 32 ) AS2 ( paddq mm5 , mm1 ) AS2 ( cmp edi , ebp ) ASJ ( jne , 0 , b ) ASL ( 1 ) AS2 ( paddq mm5 , mm2 ) AS2 ( movd [ esp + 8 ] , mm3 ) AS2 ( psrlq mm3 , 32 ) AS2 ( paddq mm5 , mm3 ) AS2 ( movd mm4 , [ esp ] ) AS2 ( paddq mm7 , mm4 ) AS2 ( movd mm4 , [ esp + 4 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( movd mm4 , [ esp + 8 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( lea ebp , [ 8 * ebx ] ) AS2 ( sub edi , ebp ) AS2 ( movd [ esp ] , mm7 ) AS2 ( psrlq mm7 , 32 ) AS2 ( paddq mm6 , mm7 ) AS2 ( movd [ esp + 4 ] , mm6 ) AS2 ( psrlq mm6 , 32 ) AS2 ( paddq mm5 , mm6 ) AS2 ( psllq mm5 , 2 ) AS2 ( psrlq mm5 , 2 ) # define a0 [ eax + 2 * 4 ] # define a1 [ eax + 3 * 4 ] # define a2 [ eax + 0 * 4 ] # define a3 [ eax + 1 * 4 ] # define k0 [ eax + 2 * 8 + 2 * 4 ] # define k1 [ eax + 2 * 8 + 3 * 4 ] # define k2 [ eax + 2 * 8 + 0 * 4 ] # define k3 [ eax + 2 * 8 + 1 * 4 ] AS2 ( test dl , dl ) ASJ ( jz , 2 , f ) AS2 ( movd mm1 , k0 ) AS2 ( movd mm0 , [ esp ] ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd a0 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( movd mm1 , k1 ) AS2 ( movd mm2 , [ esp + 4 ] ) AS2 ( paddq mm1 , mm2 ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd a1 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( paddq mm5 , k2 ) AS2 ( paddq mm0 , mm5 ) AS2 ( movq a2 , mm0 ) AS2 ( xor edx , edx ) ASJ ( jmp , 3 , f ) ASL ( 2 ) AS2 ( movd mm0 , a3 ) AS2 ( movq mm4 , mm0 ) AS2 ( pmuludq mm0 , k3 ) AS2 ( movd mm1 , a0 ) AS2 ( pmuludq mm1 , k2 ) AS2 ( movd mm2 , a1 ) AS2 ( movd mm6 , k1 ) AS2 ( pmuludq mm2 , mm6 ) AS2 ( movd mm3 , a2 ) AS2 ( psllq mm0 , 1 ) AS2 ( paddq mm0 , mm5 ) AS2 ( movq mm5 , mm3 ) AS2 ( movd mm7 , k0 ) AS2 ( pmuludq mm3 , mm7 ) AS2 ( pmuludq mm4 , mm7 ) AS2 ( pmuludq mm5 , mm6 ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd mm1 , a1 ) AS2 ( paddq mm4 , mm5 ) AS2 ( movq mm5 , mm1 ) AS2 ( pmuludq mm1 , k2 ) AS2 ( paddq mm0 , mm2 ) AS2 ( movd mm2 , a0 ) AS2 ( paddq mm0 , mm3 ) AS2 ( movq mm3 , mm2 ) AS2 ( pmuludq mm2 , k3 ) AS2 ( pmuludq mm3 , mm7 ) AS2 ( movd [ esp + 8 ] , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( pmuludq mm7 , mm5 ) AS2 ( pmuludq mm5 , k3 ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd mm1 , a2 ) AS2 ( pmuludq mm1 , k2 ) AS2 ( paddq mm0 , mm2 ) AS2 ( paddq mm0 , mm4 ) AS2 ( movq mm4 , mm0 ) AS2 ( movd mm2 , a3 ) AS2 ( pmuludq mm2 , mm6 ) AS2 ( pmuludq mm6 , a0 ) AS2 ( psrlq mm0 , 31 ) AS2 ( paddq mm0 , mm3 ) AS2 ( movd mm3 , [ esp ] ) AS2 ( paddq mm0 , mm3 ) AS2 ( movd mm3 , a2 ) AS2 ( pmuludq mm3 , k3 ) AS2 ( paddq mm5 , mm1 ) AS2 ( movd mm1 , a3 ) AS2 ( pmuludq mm1 , k2 ) AS2 ( paddq mm5 , mm2 ) AS2 ( movd mm2 , [ esp + 4 ] ) AS2 ( psllq mm5 , 1 ) AS2 ( paddq mm0 , mm5 ) AS2 ( psllq mm4 , 33 ) AS2 ( movd a0 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( paddq mm6 , mm7 ) AS2 ( movd mm7 , [ esp + 8 ] ) AS2 ( paddq mm0 , mm6 ) AS2 ( paddq mm0 , mm2 ) AS2 ( paddq mm3 , mm1 ) AS2 ( psllq mm3 , 1 ) AS2 ( paddq mm0 , mm3 ) AS2 ( psrlq mm4 , 1 ) AS2 ( movd a1 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( por mm4 , mm7 ) AS2 ( paddq mm0 , mm4 ) AS2 ( movq a2 , mm0 ) # undef a0 # undef a1 # undef a2 # undef a3 # undef k0 # undef k1 # undef k2 # undef k3 ASL ( 3 ) AS2 ( test ecx , ecx ) ASJ ( jnz , 4 , b ) AS2 ( add esp , 12 ) AS1 ( pop ebp ) AS1 ( emms ) # ifdef __GNUC__ " . att _ syntax ▁ prefix ; " AS2 ( mov % 0 , % % ebx ) : " = m " ( temp ) : " m " ( L1KeyLength ) , " c " ( blocksRemainingInWord64 ) , " S " ( data ) , " D " ( nhK + tagPart * 2 ) , " d " ( m_isFirstBlock ) , " a " ( polyS + tagPart * 4 ) : " memory " , " cc " ) ; # endif } # endif # if VMAC_BOOL_WORD128 # define DeclareNH ( a ) word128 a = 0 # define MUL64 ( rh , rl , i1 , i2 ) { word128 p = word128 ( i1 ) * ( i2 ) ; rh = word64 ( p >> 64 ) ; rl = word64 ( p ) ; } # define AccumulateNH ( a , b , c ) a += word128 ( b ) * ( c ) # define Multiply128 ( r , i1 , i2 ) r = word128 ( word64 ( i1 ) ) * word64 ( i2 ) # else # if _MSC_VER >= 1400 && ! defined ( __INTEL_COMPILER ) # define MUL32 ( a , b ) __emulu ( word32 ( a ) , word32 ( b ) ) # else # define MUL32 ( a , b ) ( ( word64 ) ( ( word32 ) ( a ) ) * ( word32 ) ( b ) ) # endif # if defined ( CRYPTOPP_X64_ASM_AVAILABLE ) # define DeclareNH ( a ) word64 a ## 0 = 0 , a ## 1 = 0 # define MUL64 ( rh , rl , i1 , i2 ) asm ( " mulq ▁ % 3" : " = a " ( rl ) , " = d " ( rh ) : " a " ( i1 ) , " g " ( i2 ) : " cc " ) ; # define AccumulateNH ( a , b , c ) asm ( " mulq ▁ % 3 ; ▁ addq ▁ % % rax , ▁ % 0 ; ▁ adcq ▁ % % rdx , ▁ % 1" : " + r " ( a ## 0 ) , " + r " ( a ## 1 ) : " a " ( b ) , " g " ( c ) : " % rdx " , " cc " ) ; # define ADD128 ( rh , rl , ih , il ) asm ( " addq ▁ % 3 , ▁ % 1 ; ▁ adcq ▁ % 2 , ▁ % 0" : " + r " ( rh ) , " + r " ( rl ) : " r " ( ih ) , " r " ( il ) : " cc " ) ; # elif defined ( _MSC_VER ) && ! CRYPTOPP_BOOL_SLOW_WORD64 # define DeclareNH ( a ) word64 a ## 0 = 0 , a ## 1 = 0 # define MUL64 ( rh , rl , i1 , i2 ) ( rl ) = _umul128 ( i1 , i2 , & ( rh ) ) ; # define AccumulateNH ( a , b , c ) { word64 ph , pl ; pl = _umul128 ( b , c , & ph ) ; a ## 0 += pl ; a ## 1 += ph + ( a ## 0 < pl ) ; } # else # define VMAC_BOOL_32BIT 1 # define DeclareNH ( a ) word64 a ## 0 = 0 , a ## 1 = 0 , a ## 2 = 0 # define MUL64 ( rh , rl , i1 , i2 ) { word64 _i1 = ( i1 ) , _i2 = ( i2 ) ; word64 m1 = MUL32 ( _i1 , _i2 >> 32 ) ; word64 m2 = MUL32 ( _i1 >> 32 , _i2 ) ; rh = MUL32 ( _i1 >> 32 , _i2 >> 32 ) ; rl = MUL32 ( _i1 , _i2 ) ; ADD128 ( rh , rl , ( m1 >> 32 ) , ( m1 << 32 ) ) ; ADD128 ( rh , rl , ( m2 >> 32 ) , ( m2 << 32 ) ) ; } # define AccumulateNH ( a , b , c ) { word64 p = MUL32 ( b , c ) ; a ## 1 += word32 ( ( p ) >> 32 ) ; a ## 0 += word32 ( p ) ; p = MUL32 ( ( b ) >> 32 , c ) ; a ## 2 += word32 ( ( p ) >> 32 ) ; a ## 1 += word32 ( p ) ; p = MUL32 ( ( b ) >> 32 , ( c ) >> 32 ) ; a ## 2 += p ; p = MUL32 ( b , ( c ) >> 32 ) ; a ## 1 += word32 ( p ) ; a ## 2 += word32 ( p >> 32 ) ; } # endif # endif # ifndef VMAC_BOOL_32BIT # define VMAC_BOOL_32BIT 0 # endif # ifndef ADD128 # define ADD128 ( rh , rl , ih , il ) { word64 _il = ( il ) ; ( rl ) += ( _il ) ; ( rh ) += ( ih ) + ( ( rl ) < ( _il ) ) ; } # endif # if ! ( defined ( _MSC_VER ) && _MSC_VER < 1300 ) template < bool T_128BitTag > # endif void VMAC_Base :: VHASH_Update_Template ( const word64 * data , size_t blocksRemainingInWord64 ) { # define INNER_LOOP_ITERATION ( j ) { word64 d0 = ConditionalByteReverse ( LITTLE_ENDIAN_ORDER , data [ i + 2 * j + 0 ] ) ; word64 d1 = ConditionalByteReverse ( LITTLE_ENDIAN_ORDER , data [ i + 2 * j + 1 ] ) ; AccumulateNH ( nhA , d0 + nhK [ i + 2 * j + 0 ] , d1 + nhK [ i + 2 * j + 1 ] ) ; if ( T_128BitTag ) AccumulateNH ( nhB , d0 + nhK [ i + 2 * j + 2 ] , d1 + nhK [ i + 2 * j + 3 ] ) ; } # if ( defined ( _MSC_VER ) && _MSC_VER < 1300 ) bool T_128BitTag = m_is128 ; # endif size_t L1KeyLengthInWord64 = m_L1KeyLength / 8 ; size_t innerLoopEnd = L1KeyLengthInWord64 ; const word64 * nhK = m_nhKey ( ) ; word64 * polyS = m_polyState ( ) ; bool isFirstBlock = true ; size_t i ; # if ! VMAC_BOOL_32BIT # if VMAC_BOOL_WORD128 word128 a1 , a2 ; # else word64 ah1 , al1 , ah2 , al2 ; # endif word64 kh1 , kl1 , kh2 , kl2 ; kh1 = ( polyS + 0 * 4 + 2 ) [ 0 ] ; kl1 = ( polyS + 0 * 4 + 2 ) [ 1 ] ; if ( T_128BitTag ) { kh2 = ( polyS + 1 * 4 + 2 ) [ 0 ] ; kl2 = ( polyS + 1 * 4 + 2 ) [ 1 ] ; } # endif do { DeclareNH ( nhA ) ; DeclareNH ( nhB ) ; i = 0 ; if ( blocksRemainingInWord64 < L1KeyLengthInWord64 ) { if ( blocksRemainingInWord64 % 8 ) { innerLoopEnd = blocksRemainingInWord64 % 8 ; for ( ; i < innerLoopEnd ; i += 2 ) INNER_LOOP_ITERATION ( 0 ) ; } innerLoopEnd = blocksRemainingInWord64 ; } for ( ; i < innerLoopEnd ; i += 8 ) { INNER_LOOP_ITERATION ( 0 ) ; INNER_LOOP_ITERATION ( 1 ) ; INNER_LOOP_ITERATION ( 2 ) ; INNER_LOOP_ITERATION ( 3 ) ; } blocksRemainingInWord64 -= innerLoopEnd ; data += innerLoopEnd ; # if VMAC_BOOL_32BIT word32 nh0 [ 2 ] , nh1 [ 2 ] ; word64 nh2 [ 2 ] ; nh0 [ 0 ] = word32 ( nhA0 ) ; nhA1 += ( nhA0 >> 32 ) ; nh1 [ 0 ] = word32 ( nhA1 ) ; nh2 [ 0 ] = ( nhA2 + ( nhA1 >> 32 ) ) & m62 ; if ( T_128BitTag ) { nh0 [ 1 ] = word32 ( nhB0 ) ; nhB1 += ( nhB0 >> 32 ) ; nh1 [ 1 ] = word32 ( nhB1 ) ; nh2 [ 1 ] = ( nhB2 + ( nhB1 >> 32 ) ) & m62 ; } # define a0 ( ( ( word32 * ) ( polyS + i * 4 ) ) [ 2 + NativeByteOrder :: ToEnum ( ) ] ) # define a1 ( * ( ( ( word32 * ) ( polyS + i * 4 ) ) + 3 - NativeByteOrder :: ToEnum ( ) ) ) # define a2 ( ( ( word32 * ) ( polyS + i * 4 ) ) [ 0 + NativeByteOrder :: ToEnum ( ) ] ) # define a3 ( * ( ( ( word32 * ) ( polyS + i * 4 ) ) + 1 - NativeByteOrder :: ToEnum ( ) ) ) # define aHi ( ( polyS + i * 4 ) [ 0 ] ) # define k0 ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) [ 2 + NativeByteOrder :: ToEnum ( ) ] ) # define k1 ( * ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) + 3 - NativeByteOrder :: ToEnum ( ) ) ) # define k2 ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) [ 0 + NativeByteOrder :: ToEnum ( ) ] ) # define k3 ( * ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) + 1 - NativeByteOrder :: ToEnum ( ) ) ) # define kHi ( ( polyS + i * 4 + 2 ) [ 0 ] ) if ( isFirstBlock ) { isFirstBlock = false ; if ( m_isFirstBlock ) { m_isFirstBlock = false ; for ( i = 0 ; i <= ( size_t ) T_128BitTag ; i ++ ) { word64 t = ( word64 ) nh0 [ i ] + k0 ; a0 = ( word32 ) t ; t = ( t >> 32 ) + nh1 [ i ] + k1 ; a1 = ( word32 ) t ; aHi = ( t >> 32 ) + nh2 [ i ] + kHi ; } continue ; } } for ( i = 0 ; i <= ( size_t ) T_128BitTag ; i ++ ) { word64 p , t ; word32 t2 ; p = MUL32 ( a3 , 2 * k3 ) ; p += nh2 [ i ] ; p += MUL32 ( a0 , k2 ) ; p += MUL32 ( a1 , k1 ) ; p += MUL32 ( a2 , k0 ) ; t2 = ( word32 ) p ; p >>= 32 ; p += MUL32 ( a0 , k3 ) ; p += MUL32 ( a1 , k2 ) ; p += MUL32 ( a2 , k1 ) ; p += MUL32 ( a3 , k0 ) ; t = ( word64 ( word32 ( p ) & 0x7fffffff ) << 32 ) | t2 ; p >>= 31 ; p += nh0 [ i ] ; p += MUL32 ( a0 , k0 ) ; p += MUL32 ( a1 , 2 * k3 ) ; p += MUL32 ( a2 , 2 * k2 ) ; p += MUL32 ( a3 , 2 * k1 ) ; t2 = ( word32 ) p ; p >>= 32 ; p += nh1 [ i ] ; p += MUL32 ( a0 , k1 ) ; p += MUL32 ( a1 , k0 ) ; p += MUL32 ( a2 , 2 * k3 ) ; p += MUL32 ( a3 , 2 * k2 ) ; a0 = t2 ; a1 = ( word32 ) p ; aHi = ( p >> 32 ) + t ; } # undef a0 # undef a1 # undef a2 # undef a3 # undef aHi # undef k0 # undef k1 # undef k2 # undef k3 # undef kHi # else if ( isFirstBlock ) { isFirstBlock = false ; if ( m_isFirstBlock ) { m_isFirstBlock = false ; # if VMAC_BOOL_WORD128 # define first_poly_step ( a , kh , kl , m ) a = ( m & m126 ) + ( ( word128 ( kh ) << 64 ) | kl ) first_poly_step ( a1 , kh1 , kl1 , nhA ) ; if ( T_128BitTag ) first_poly_step ( a2 , kh2 , kl2 , nhB ) ; # else # define first_poly_step ( ah , al , kh , kl , mh , ml ) { mh &= m62 ; ADD128 ( mh , ml , kh , kl ) ; ah = mh ; al = ml ; } first_poly_step ( ah1 , al1 , kh1 , kl1 , nhA1 , nhA0 ) ; if ( T_128BitTag ) first_poly_step ( ah2 , al2 , kh2 , kl2 , nhB1 , nhB0 ) ; # endif continue ; } else { # if VMAC_BOOL_WORD128 a1 = ( word128 ( ( polyS + 0 * 4 ) [ 0 ] ) << 64 ) | ( polyS + 0 * 4 ) [ 1 ] ; # else ah1 = ( polyS + 0 * 4 ) [ 0 ] ; al1 = ( polyS + 0 * 4 ) [ 1 ] ; # endif if ( T_128BitTag ) { # if VMAC_BOOL_WORD128 a2 = ( word128 ( ( polyS + 1 * 4 ) [ 0 ] ) << 64 ) | ( polyS + 1 * 4 ) [ 1 ] ; # else ah2 = ( polyS + 1 * 4 ) [ 0 ] ; al2 = ( polyS + 1 * 4 ) [ 1 ] ; # endif } } } # if VMAC_BOOL_WORD128 # define poly_step ( a , kh , kl , m ) { word128 t1 , t2 , t3 , t4 ; Multiply128 ( t2 , a >> 64 , kl ) ; Multiply128 ( t3 , a , kh ) ; Multiply128 ( t1 , a , kl ) ; Multiply128 ( t4 , a >> 64 , 2 * kh ) ; t2 += t3 ; t4 += t1 ; t2 += t4 >> 64 ; a = ( word128 ( word64 ( t2 ) & m63 ) << 64 ) | word64 ( t4 ) ; t2 *= 2 ; a += m & m126 ; a += t2 >> 64 ; } poly_step ( a1 , kh1 , kl1 , nhA ) ; if ( T_128BitTag ) poly_step ( a2 , kh2 , kl2 , nhB ) ; # else # define poly_step ( ah , al , kh , kl , mh , ml ) { word64 t1h , t1l , t2h , t2l , t3h , t3l , z = 0 ; MUL64 ( t2h , t2l , ah , kl ) ; MUL64 ( t3h , t3l , al , kh ) ; MUL64 ( t1h , t1l , ah , 2 * kh ) ; MUL64 ( ah , al , al , kl ) ; ADD128 ( t2h , t2l , t3h , t3l ) ; ADD128 ( ah , al , t1h , t1l ) ; ADD128 ( t2h , ah , z , t2l ) ; t2h += t2h + ( ah >> 63 ) ; ah &= m63 ; mh &= m62 ; ADD128 ( ah , al , mh , ml ) ; ADD128 ( ah , al , z , t2h ) ; } poly_step ( ah1 , al1 , kh1 , kl1 , nhA1 , nhA0 ) ; if ( T_128BitTag ) poly_step ( ah2 , al2 , kh2 , kl2 , nhB1 , nhB0 ) ; # endif # endif } while ( blocksRemainingInWord64 ) ; # if VMAC_BOOL_WORD128 ( polyS + 0 * 4 ) [ 0 ] = word64 ( a1 >> 64 ) ; ( polyS + 0 * 4 ) [ 1 ] = word64 ( a1 ) ; if ( T_128BitTag ) { ( polyS + 1 * 4 ) [ 0 ] = word64 ( a2 >> 64 ) ; ( polyS + 1 * 4 ) [ 1 ] = word64 ( a2 ) ; } # elif ! VMAC_BOOL_32BIT ( polyS + 0 * 4 ) [ 0 ] = ah1 ; ( polyS + 0 * 4 ) [ 1 ] = al1 ; if ( T_128BitTag ) { ( polyS + 1 * 4 ) [ 0 ] = ah2 ; ( polyS + 1 * 4 ) [ 1 ] = al2 ; } # endif } inline void VMAC_Base :: VHASH_Update ( const word64 * data , size_t blocksRemainingInWord64 ) { # if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86 if ( HasSSE2 ( ) ) { VHASH_Update_SSE2 ( data , blocksRemainingInWord64 , 0 ) ; if ( m_is128 ) VHASH_Update_SSE2 ( data , blocksRemainingInWord64 , 1 ) ; m_isFirstBlock = false ; } else # endif { # if defined ( _MSC_VER ) && _MSC_VER < 1300 VHASH_Update_Template ( data , blocksRemainingInWord64 ) ; # else if ( m_is128 ) VHASH_Update_Template < true > ( data , blocksRemainingInWord64 ) ; else VHASH_Update_Template < false > ( data , blocksRemainingInWord64 ) ; # endif } } size_t VMAC_Base :: HashMultipleBlocks ( const word64 * data , size_t length ) { size_t remaining = ModPowerOf2 ( length , m_L1KeyLength ) ; VHASH_Update ( data , ( length - remaining ) / 8 ) ; return remaining ; } static word64 L3Hash ( const word64 * input , const word64 * l3Key , size_t len ) { word64 rh , rl , t , z = 0 ; word64 p1 = input [ 0 ] , p2 = input [ 1 ] ; word64 k1 = l3Key [ 0 ] , k2 = l3Key [ 1 ] ; t = p1 >> 63 ; p1 &= m63 ; ADD128 ( p1 , p2 , len , t ) ; t = ( p1 > m63 ) + ( ( p1 == m63 ) & ( p2 == m64 ) ) ; ADD128 ( p1 , p2 , z , t ) ; p1 &= m63 ; t = p1 + ( p2 >> 32 ) ; t += ( t >> 32 ) ; t += ( word32 ) t > 0xfffffffeU ; p1 += ( t >> 32 ) ; p2 += ( p1 << 32 ) ; p1 += k1 ; p1 += ( 0 - ( p1 < k1 ) ) & 257 ; p2 += k2 ; p2 += ( 0 - ( p2 < k2 ) ) & 257 ; MUL64 ( rh , rl , p1 , p2 ) ; t = rh >> 56 ; ADD128 ( t , rl , z , rh ) ; rh <<= 8 ; ADD128 ( t , rl , z , rh ) ; t += t << 8 ; rl += t ; rl += ( 0 - ( rl < t ) ) & 257 ; rl += ( 0 - ( rl > p64 - 1 ) ) & 257 ; return rl ; } void VMAC_Base :: TruncatedFinal ( byte * mac , size_t size ) { size_t len = ModPowerOf2 ( GetBitCountLo ( ) / 8 , m_L1KeyLength ) ; if ( len ) { memset ( m_data ( ) + len , 0 , ( 0 - len ) % 16 ) ; VHASH_Update ( DataBuf ( ) , ( ( len + 15 ) / 16 ) * 2 ) ; len *= 8 ; } else if ( m_isFirstBlock ) { m_polyState ( ) [ 0 ] = m_polyState ( ) [ 2 ] ; m_polyState ( ) [ 1 ] = m_polyState ( ) [ 3 ] ; if ( m_is128 ) { m_polyState ( ) [ 4 ] = m_polyState ( ) [ 6 ] ; m_polyState ( ) [ 5 ] = m_polyState ( ) [ 7 ] ; } } if ( m_is128 ) { word64 t [ 2 ] ; t [ 0 ] = L3Hash ( m_polyState ( ) , m_l3Key ( ) , len ) + GetWord < word64 > ( true , BIG_ENDIAN_ORDER , m_pad ( ) ) ; t [ 1 ] = L3Hash ( m_polyState ( ) + 4 , m_l3Key ( ) + 2 , len ) + GetWord < word64 > ( true , BIG_ENDIAN_ORDER , m_pad ( ) + 8 ) ; if ( size == 16 ) { PutWord ( false , BIG_ENDIAN_ORDER , mac , t [ 0 ] ) ; PutWord ( false , BIG_ENDIAN_ORDER , mac + 8 , t [ 1 ] ) ; } else { t [ 0 ] = ConditionalByteReverse ( BIG_ENDIAN_ORDER , t [ 0 ] ) ; t [ 1 ] = ConditionalByteReverse ( BIG_ENDIAN_ORDER , t [ 1 ] ) ; memcpy ( mac , t , size ) ; } } else { word64 t = L3Hash ( m_polyState ( ) , m_l3Key ( ) , len ) ; t += GetWord < word64 > ( true , BIG_ENDIAN_ORDER , m_pad ( ) + ( m_nonce ( ) [ IVSize ( ) - 1 ] & 1 ) * 8 ) ; if ( size == 8 ) PutWord ( false , BIG_ENDIAN_ORDER , mac , t ) ; else { t = ConditionalByteReverse ( BIG_ENDIAN_ORDER , t ) ; memcpy ( mac , & t , size ) ; } } } NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="SignFinder/FaceCore/tree/master/src/server/game/Movement/MovementGenerators/PointMovementGenerator.cpp"> # include " PointMovementGenerator . h " # include " Errors . h " # include " Creature . h " # include " CreatureAI . h " # include " World . h " # include " MoveSplineInit . h " # include " MoveSpline . h " # include " Player . h " template < class T > void PointMovementGenerator < T > :: DoInitialize ( T * unit ) { if ( ! unit -> IsStopped ( ) ) unit -> StopMoving ( ) ; unit -> AddUnitState ( UNIT_STATE_ROAMING | UNIT_STATE_ROAMING_MOVE ) ; if ( id == EVENT_CHARGE_PREPATH ) return ; Movement :: MoveSplineInit init ( unit ) ; init . MoveTo ( i_x , i_y , i_z , m_generatePath ) ; if ( speed > 0.0f ) init . SetVelocity ( speed ) ; init . Launch ( ) ; } template < class T > bool PointMovementGenerator < T > :: DoUpdate ( T * unit , uint32 ) { if ( ! unit ) return false ; if ( unit -> HasUnitState ( UNIT_STATE_ROOT | UNIT_STATE_STUNNED ) ) { unit -> ClearUnitState ( UNIT_STATE_ROAMING_MOVE ) ; return true ; } unit -> AddUnitState ( UNIT_STATE_ROAMING_MOVE ) ; if ( id != EVENT_CHARGE_PREPATH && i_recalculateSpeed && ! unit -> movespline -> Finalized ( ) ) { i_recalculateSpeed = false ; Movement :: MoveSplineInit init ( unit ) ; init . MoveTo ( i_x , i_y , i_z , m_generatePath ) ; if ( speed > 0.0f ) init . SetVelocity ( speed ) ; init . Launch ( ) ; } return ! unit -> movespline -> Finalized ( ) ; } template < class T > void PointMovementGenerator < T > :: DoFinalize ( T * unit ) { if ( unit -> HasUnitState ( UNIT_STATE_CHARGING ) ) unit -> ClearUnitState ( UNIT_STATE_ROAMING | UNIT_STATE_ROAMING_MOVE ) ; if ( unit -> movespline -> Finalized ( ) ) MovementInform ( unit ) ; } template < class T > void PointMovementGenerator < T > :: DoReset ( T * unit ) { if ( ! unit -> IsStopped ( ) ) unit -> StopMoving ( ) ; unit -> AddUnitState ( UNIT_STATE_ROAMING | UNIT_STATE_ROAMING_MOVE ) ; } template < class T > void PointMovementGenerator < T > :: MovementInform ( T * ) { } template < > void PointMovementGenerator < Creature > :: MovementInform ( Creature * unit ) { if ( unit -> AI ( ) ) unit -> AI ( ) -> MovementInform ( POINT_MOTION_TYPE , id ) ; } template void PointMovementGenerator < Player > :: DoInitialize ( Player * ) ; template void PointMovementGenerator < Creature > :: DoInitialize ( Creature * ) ; template void PointMovementGenerator < Player > :: DoFinalize ( Player * ) ; template void PointMovementGenerator < Creature > :: DoFinalize ( Creature * ) ; template void PointMovementGenerator < Player > :: DoReset ( Player * ) ; template void PointMovementGenerator < Creature > :: DoReset ( Creature * ) ; template bool PointMovementGenerator < Player > :: DoUpdate ( Player * , uint32 ) ; template bool PointMovementGenerator < Creature > :: DoUpdate ( Creature * , uint32 ) ; void AssistanceMovementGenerator :: Finalize ( Unit * unit ) { unit -> ToCreature ( ) -> SetNoCallAssistance ( false ) ; unit -> ToCreature ( ) -> CallAssistance ( ) ; if ( unit -> isAlive ( ) ) unit -> GetMotionMaster ( ) -> MoveSeekAssistanceDistract ( sWorld -> getIntConfig ( CONFIG_CREATURE_FAMILY_ASSISTANCE_DELAY ) ) ; } bool EffectMovementGenerator :: Update ( Unit * unit , uint32 ) { return ! unit -> movespline -> Finalized ( ) ; } void EffectMovementGenerator :: Finalize ( Unit * unit ) { if ( unit -> GetTypeId ( ) != TYPEID_UNIT ) return ; if ( unit -> isAlive ( ) && ! unit -> HasUnitState ( UNIT_STATE_CONFUSED | UNIT_STATE_FLEEING ) ) { if ( Unit * victim = unit -> getVictim ( ) ) unit -> GetMotionMaster ( ) -> MoveChase ( victim ) ; else unit -> GetMotionMaster ( ) -> Initialize ( ) ; } if ( unit -> ToCreature ( ) -> AI ( ) ) unit -> ToCreature ( ) -> AI ( ) -> MovementInform ( EFFECT_MOTION_TYPE , m_Id ) ; } </DOCUMENT>
<DOCUMENT_ID="huan5765/codelite-translate2chinese/tree/master/sdk/astyle/src/ASResource.cpp"> # include " astyle . h " namespace astyle { const string ASResource :: AS_IF = string ( " if " ) ; const string ASResource :: AS_ELSE = string ( " else " ) ; const string ASResource :: AS_FOR = string ( " for " ) ; const string ASResource :: AS_DO = string ( " do " ) ; const string ASResource :: AS_WHILE = string ( " while " ) ; const string ASResource :: AS_SWITCH = string ( " switch " ) ; const string ASResource :: AS_CASE = string ( " case " ) ; const string ASResource :: AS_DEFAULT = string ( " default " ) ; const string ASResource :: AS_CLASS = string ( " class " ) ; const string ASResource :: AS_STRUCT = string ( " struct " ) ; const string ASResource :: AS_UNION = string ( " union " ) ; const string ASResource :: AS_INTERFACE = string ( " interface " ) ; const string ASResource :: AS_NAMESPACE = string ( " namespace " ) ; const string ASResource :: AS_EXTERN = string ( " extern " ) ; const string ASResource :: AS_PUBLIC = string ( " public " ) ; const string ASResource :: AS_PROTECTED = string ( " protected " ) ; const string ASResource :: AS_PRIVATE = string ( " private " ) ; const string ASResource :: AS_STATIC = string ( " static " ) ; const string ASResource :: AS_SYNCHRONIZED = string ( " synchronized " ) ; const string ASResource :: AS_OPERATOR = string ( " operator " ) ; const string ASResource :: AS_TEMPLATE = string ( " template " ) ; const string ASResource :: AS_TRY = string ( " try " ) ; const string ASResource :: AS_CATCH = string ( " catch " ) ; const string ASResource :: AS_FINALLY = string ( " finally " ) ; const string ASResource :: AS_THROWS = string ( " throws " ) ; const string ASResource :: AS_CONST = string ( " const " ) ; const string ASResource :: AS_ASM = string ( " asm " ) ; const string ASResource :: AS_BAR_DEFINE = string ( " # define " ) ; const string ASResource :: AS_BAR_INCLUDE = string ( " # include " ) ; const string ASResource :: AS_BAR_IF = string ( " # if " ) ; const string ASResource :: AS_BAR_EL = string ( " # el " ) ; const string ASResource :: AS_BAR_ENDIF = string ( " # endif " ) ; const string ASResource :: AS_OPEN_BRACKET = string ( " { " ) ; const string ASResource :: AS_CLOSE_BRACKET = string ( " } " ) ; const string ASResource :: AS_OPEN_LINE_COMMENT = string ( " // " ) ; const string ASResource :: AS_OPEN_COMMENT = string ( " /* " ) ; const string ASResource :: AS_CLOSE_COMMENT = string ( " */ " ) ; const string ASResource :: AS_ASSIGN = string ( " = " ) ; const string ASResource :: AS_PLUS_ASSIGN = string ( " + = " ) ; const string ASResource :: AS_MINUS_ASSIGN = string ( " - = " ) ; const string ASResource :: AS_MULT_ASSIGN = string ( " * = " ) ; const string ASResource :: AS_DIV_ASSIGN = string ( " / = " ) ; const string ASResource :: AS_MOD_ASSIGN = string ( " % = " ) ; const string ASResource :: AS_OR_ASSIGN = string ( " | = " ) ; const string ASResource :: AS_AND_ASSIGN = string ( " & = " ) ; const string ASResource :: AS_XOR_ASSIGN = string ( " ^ = " ) ; const string ASResource :: AS_GR_GR_ASSIGN = string ( " > > = " ) ; const string ASResource :: AS_LS_LS_ASSIGN = string ( " < < = " ) ; const string ASResource :: AS_GR_GR_GR_ASSIGN = string ( " > > > = " ) ; const string ASResource :: AS_LS_LS_LS_ASSIGN = string ( " < < < = " ) ; const string ASResource :: AS_RETURN = string ( " return " ) ; const string ASResource :: AS_EQUAL = string ( " = = " ) ; const string ASResource :: AS_PLUS_PLUS = string ( " + + " ) ; const string ASResource :: AS_MINUS_MINUS = string ( " - - " ) ; const string ASResource :: AS_NOT_EQUAL = string ( " ! = " ) ; const string ASResource :: AS_GR_EQUAL = string ( " > = " ) ; const string ASResource :: AS_GR_GR = string ( " > > " ) ; const string ASResource :: AS_GR_GR_GR = string ( " > > > " ) ; const string ASResource :: AS_LS_EQUAL = string ( " < = " ) ; const string ASResource :: AS_LS_LS = string ( " < < " ) ; const string ASResource :: AS_LS_LS_LS = string ( " < < < " ) ; const string ASResource :: AS_ARROW = string ( " - > " ) ; const string ASResource :: AS_AND = string ( " & & " ) ; const string ASResource :: AS_OR = string ( " | | " ) ; const string ASResource :: AS_COLON_COLON = string ( " : : " ) ; const string ASResource :: AS_PAREN_PAREN = string ( " ( ) " ) ; const string ASResource :: AS_BLPAREN_BLPAREN = string ( " [ ] " ) ; const string ASResource :: AS_PLUS = string ( " + " ) ; const string ASResource :: AS_MINUS = string ( " - " ) ; const string ASResource :: AS_MULT = string ( " * " ) ; const string ASResource :: AS_DIV = string ( " / " ) ; const string ASResource :: AS_MOD = string ( " % " ) ; const string ASResource :: AS_GR = string ( " > " ) ; const string ASResource :: AS_LS = string ( " < " ) ; const string ASResource :: AS_NOT = string ( " ! " ) ; const string ASResource :: AS_BIT_OR = string ( " | " ) ; const string ASResource :: AS_BIT_AND = string ( " & " ) ; const string ASResource :: AS_BIT_NOT = string ( " ~ " ) ; const string ASResource :: AS_BIT_XOR = string ( " ^ " ) ; const string ASResource :: AS_QUESTION = string ( " ? " ) ; const string ASResource :: AS_COLON = string ( " : " ) ; const string ASResource :: AS_COMMA = string ( " , " ) ; const string ASResource :: AS_SEMICOLON = string ( " ; " ) ; const string ASResource :: AS_FOREACH = string ( " foreach " ) ; const string ASResource :: AS_LOCK = string ( " lock " ) ; const string ASResource :: AS_UNSAFE = string ( " unsafe " ) ; const string ASResource :: AS_FIXED = string ( " fixed " ) ; const string ASResource :: AS_GET = string ( " get " ) ; const string ASResource :: AS_SET = string ( " set " ) ; const string ASResource :: AS_ADD = string ( " add " ) ; const string ASResource :: AS_REMOVE = string ( " remove " ) ; const string ASResource :: AS_CONST_CAST = string ( " const _ cast " ) ; const string ASResource :: AS_DYNAMIC_CAST = string ( " dynamic _ cast " ) ; const string ASResource :: AS_REINTERPRET_CAST = string ( " reinterpret _ cast " ) ; const string ASResource :: AS_STATIC_CAST = string ( " static _ cast " ) ; void ASResource :: buildAssignmentOperators ( vector < const string * > & assignmentOperators ) { assignmentOperators . push_back ( & AS_ASSIGN ) ; assignmentOperators . push_back ( & AS_PLUS_ASSIGN ) ; assignmentOperators . push_back ( & AS_MINUS_ASSIGN ) ; assignmentOperators . push_back ( & AS_MULT_ASSIGN ) ; assignmentOperators . push_back ( & AS_DIV_ASSIGN ) ; assignmentOperators . push_back ( & AS_MOD_ASSIGN ) ; assignmentOperators . push_back ( & AS_OR_ASSIGN ) ; assignmentOperators . push_back ( & AS_AND_ASSIGN ) ; assignmentOperators . push_back ( & AS_XOR_ASSIGN ) ; assignmentOperators . push_back ( & AS_GR_GR_GR_ASSIGN ) ; assignmentOperators . push_back ( & AS_GR_GR_ASSIGN ) ; assignmentOperators . push_back ( & AS_LS_LS_ASSIGN ) ; assignmentOperators . push_back ( & AS_LS_LS_LS_ASSIGN ) ; assignmentOperators . push_back ( & AS_RETURN ) ; } void ASResource :: buildCastOperators ( vector < const string * > & castOperators ) { castOperators . push_back ( & AS_CONST_CAST ) ; castOperators . push_back ( & AS_DYNAMIC_CAST ) ; castOperators . push_back ( & AS_REINTERPRET_CAST ) ; castOperators . push_back ( & AS_STATIC_CAST ) ; } void ASResource :: buildHeaders ( vector < const string * > & headers , int fileType , bool beautifier ) { headers . push_back ( & AS_IF ) ; headers . push_back ( & AS_ELSE ) ; headers . push_back ( & AS_FOR ) ; headers . push_back ( & AS_WHILE ) ; headers . push_back ( & AS_DO ) ; headers . push_back ( & AS_SWITCH ) ; headers . push_back ( & AS_TRY ) ; headers . push_back ( & AS_CATCH ) ; if ( beautifier ) { headers . push_back ( & AS_CASE ) ; headers . push_back ( & AS_DEFAULT ) ; headers . push_back ( & AS_CONST ) ; headers . push_back ( & AS_STATIC ) ; headers . push_back ( & AS_EXTERN ) ; headers . push_back ( & AS_TEMPLATE ) ; } if ( fileType == JAVA_TYPE ) { headers . push_back ( & AS_FINALLY ) ; headers . push_back ( & AS_SYNCHRONIZED ) ; } if ( fileType == SHARP_TYPE ) { headers . push_back ( & AS_FINALLY ) ; headers . push_back ( & AS_FOREACH ) ; headers . push_back ( & AS_LOCK ) ; headers . push_back ( & AS_UNSAFE ) ; headers . push_back ( & AS_FIXED ) ; headers . push_back ( & AS_GET ) ; headers . push_back ( & AS_SET ) ; headers . push_back ( & AS_ADD ) ; headers . push_back ( & AS_REMOVE ) ; } } void ASResource :: buildNonAssignmentOperators ( vector < const string * > & nonAssignmentOperators ) { nonAssignmentOperators . push_back ( & AS_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_PLUS_PLUS ) ; nonAssignmentOperators . push_back ( & AS_MINUS_MINUS ) ; nonAssignmentOperators . push_back ( & AS_NOT_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_GR_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_GR_GR_GR ) ; nonAssignmentOperators . push_back ( & AS_GR_GR ) ; nonAssignmentOperators . push_back ( & AS_LS_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_LS_LS_LS ) ; nonAssignmentOperators . push_back ( & AS_LS_LS ) ; nonAssignmentOperators . push_back ( & AS_ARROW ) ; nonAssignmentOperators . push_back ( & AS_AND ) ; nonAssignmentOperators . push_back ( & AS_OR ) ; } void ASResource :: buildNonParenHeaders ( vector < const string * > & nonParenHeaders , int fileType , bool beautifier ) { nonParenHeaders . push_back ( & AS_ELSE ) ; nonParenHeaders . push_back ( & AS_DO ) ; nonParenHeaders . push_back ( & AS_TRY ) ; if ( beautifier ) { nonParenHeaders . push_back ( & AS_CASE ) ; nonParenHeaders . push_back ( & AS_DEFAULT ) ; nonParenHeaders . push_back ( & AS_CONST ) ; nonParenHeaders . push_back ( & AS_STATIC ) ; nonParenHeaders . push_back ( & AS_EXTERN ) ; nonParenHeaders . push_back ( & AS_TEMPLATE ) ; } if ( fileType == JAVA_TYPE ) { nonParenHeaders . push_back ( & AS_FINALLY ) ; } if ( fileType == SHARP_TYPE ) { nonParenHeaders . push_back ( & AS_FINALLY ) ; nonParenHeaders . push_back ( & AS_UNSAFE ) ; nonParenHeaders . push_back ( & AS_GET ) ; nonParenHeaders . push_back ( & AS_SET ) ; nonParenHeaders . push_back ( & AS_ADD ) ; nonParenHeaders . push_back ( & AS_REMOVE ) ; } } void ASResource :: buildOperators ( vector < const string * > & operators ) { operators . push_back ( & AS_PLUS_ASSIGN ) ; operators . push_back ( & AS_MINUS_ASSIGN ) ; operators . push_back ( & AS_MULT_ASSIGN ) ; operators . push_back ( & AS_DIV_ASSIGN ) ; operators . push_back ( & AS_MOD_ASSIGN ) ; operators . push_back ( & AS_OR_ASSIGN ) ; operators . push_back ( & AS_AND_ASSIGN ) ; operators . push_back ( & AS_XOR_ASSIGN ) ; operators . push_back ( & AS_EQUAL ) ; operators . push_back ( & AS_PLUS_PLUS ) ; operators . push_back ( & AS_MINUS_MINUS ) ; operators . push_back ( & AS_NOT_EQUAL ) ; operators . push_back ( & AS_GR_EQUAL ) ; operators . push_back ( & AS_GR_GR_GR_ASSIGN ) ; operators . push_back ( & AS_GR_GR_ASSIGN ) ; operators . push_back ( & AS_GR_GR_GR ) ; operators . push_back ( & AS_GR_GR ) ; operators . push_back ( & AS_LS_EQUAL ) ; operators . push_back ( & AS_LS_LS_LS_ASSIGN ) ; operators . push_back ( & AS_LS_LS_ASSIGN ) ; operators . push_back ( & AS_LS_LS_LS ) ; operators . push_back ( & AS_LS_LS ) ; operators . push_back ( & AS_ARROW ) ; operators . push_back ( & AS_AND ) ; operators . push_back ( & AS_OR ) ; operators . push_back ( & AS_COLON_COLON ) ; operators . push_back ( & AS_PLUS ) ; operators . push_back ( & AS_MINUS ) ; operators . push_back ( & AS_MULT ) ; operators . push_back ( & AS_DIV ) ; operators . push_back ( & AS_MOD ) ; operators . push_back ( & AS_QUESTION ) ; operators . push_back ( & AS_COLON ) ; operators . push_back ( & AS_ASSIGN ) ; operators . push_back ( & AS_LS ) ; operators . push_back ( & AS_GR ) ; operators . push_back ( & AS_NOT ) ; operators . push_back ( & AS_BIT_OR ) ; operators . push_back ( & AS_BIT_AND ) ; operators . push_back ( & AS_BIT_NOT ) ; operators . push_back ( & AS_BIT_XOR ) ; operators . push_back ( & AS_OPERATOR ) ; operators . push_back ( & AS_COMMA ) ; operators . push_back ( & AS_RETURN ) ; } void ASResource :: buildPreBlockStatements ( vector < const string * > & preBlockStatements ) { preBlockStatements . push_back ( & AS_CLASS ) ; preBlockStatements . push_back ( & AS_STRUCT ) ; preBlockStatements . push_back ( & AS_UNION ) ; preBlockStatements . push_back ( & AS_INTERFACE ) ; preBlockStatements . push_back ( & AS_NAMESPACE ) ; preBlockStatements . push_back ( & AS_THROWS ) ; preBlockStatements . push_back ( & AS_EXTERN ) ; } void ASResource :: buildPreCommandHeaders ( vector < const string * > & preCommandHeaders ) { preCommandHeaders . push_back ( & AS_EXTERN ) ; preCommandHeaders . push_back ( & AS_THROWS ) ; preCommandHeaders . push_back ( & AS_CONST ) ; } void ASResource :: buildPreDefinitionHeaders ( vector < const string * > & preDefinitionHeaders ) { preDefinitionHeaders . push_back ( & AS_CLASS ) ; preDefinitionHeaders . push_back ( & AS_INTERFACE ) ; preDefinitionHeaders . push_back ( & AS_NAMESPACE ) ; preDefinitionHeaders . push_back ( & AS_STRUCT ) ; } } </DOCUMENT>
<DOCUMENT_ID="taiki-okano/Algorithm/tree/master/AOJ/AOJ0554.cpp"> # include < cstdio > int main ( ) { int sum = 0 ; for ( int i = 0 ; i < 4 ; ++ i ) { int in ; scanf ( " % d " , & in ) ; sum += in ; } printf ( " % d \n " , sum / 60 ) ; printf ( " % d \n " , sum % 60 ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="stoman/HashCode2017Warmup/tree/master/loon/code/pathfinding.cpp"> # pragma once # include " util . cpp " # include < set > # include < cmath > struct Coord { int r , c , h ; } ; bool operator < ( const Coord & a , const Coord & b ) { if ( a . r != b . r ) return a . r < b . r ; else if ( a . c != b . c ) return a . c < b . c ; else return a . h < b . h ; } double compute_distance ( double r1 , double c1 , double h , double r2 , double c2 , double r , double c ) { if ( r1 < 0 || r1 >= r || r2 < 0 || r2 >= r ) return 1e12 ; double dr = abs ( r1 - r2 ) ; double dc = min ( abs ( c1 - c2 ) , c - abs ( c1 - c2 ) ) ; return sqrt ( dr * dr + dc * dc ) + 20. * ( h - 1. ) / ( sqrt ( dr * dr + dc * dc ) + 1 ) ; } int check_cell_value ( Input & input , int r , int c ) { c = ( c + input . c ) % input . c ; if ( r >= 0 && r < input . r ) return input . cell_field [ r ] [ c ] ; else return 0 ; } void check_cell ( Input & input , Coord cur , vector < Coord > & path , vector < int > & prev , set < Coord > & visited , vector < double > & dist , int idx , double r , double c , double alpha ) { int dr = input . movement_r [ cur . r ] [ cur . c ] [ cur . h ] ; int dc = input . movement_c [ cur . r ] [ cur . c ] [ cur . h ] ; cur . r += dr ; cur . c += dc ; cur . c = ( cur . c + input . c ) % input . c ; if ( visited . find ( cur ) != visited . end ( ) ) return ; int cnt_cells = 0 ; for ( int i = - 2 ; i <= 2 ; i ++ ) for ( int j = - 2 ; j <= 2 ; j ++ ) cnt_cells += check_cell_value ( input , cur . r + i , cur . c + j ) ; if ( cnt_cells > 12 ) dist . push_back ( dist [ idx ] + alpha ) ; else dist . push_back ( dist [ idx ] + 1.0 ) ; path . push_back ( cur ) ; prev . push_back ( idx ) ; visited . insert ( cur ) ; } void bfs ( Input & input , vector < Coord > & path , vector < int > & prev , double r , double c , int bfsdepth , double alpha ) { set < Coord > visited ; vector < double > dist ; int idx = 0 ; dist . push_back ( 0 ) ; visited . insert ( path [ idx ] ) ; while ( idx < path . size ( ) ) { Coord cur = path [ idx ] ; if ( dist [ idx ] > ( double ) bfsdepth ) break ; if ( cur . r >= input . r || cur . r < 0 ) { path . push_back ( cur ) ; prev . push_back ( idx ) ; dist . push_back ( dist [ idx ] + 1 ) ; } else { check_cell ( input , cur , path , prev , visited , dist , idx , r , c , alpha ) ; if ( cur . h > 1 ) { cur . h -- ; check_cell ( input , cur , path , prev , visited , dist , idx , r , c , alpha ) ; cur . h ++ ; } if ( cur . h < input . a ) { cur . h ++ ; check_cell ( input , cur , path , prev , visited , dist , idx , r , c , alpha ) ; cur . h -- ; } } idx ++ ; } } void append_path ( Input & input , int balloon , vector < Coord > & path , vector < int > & prev , int idx_min ) { vector < Coord > reversed_path ; for ( int i = idx_min ; i != 0 ; i = prev [ i ] ) reversed_path . push_back ( path [ i ] ) ; for ( int i = reversed_path . size ( ) - 1 ; i >= 0 ; i -- ) { input . balloons [ balloon ] . h . push_back ( reversed_path [ i ] . h ) ; input . balloons [ balloon ] . r . push_back ( reversed_path [ i ] . r ) ; input . balloons [ balloon ] . c . push_back ( reversed_path [ i ] . c ) ; if ( input . balloons [ balloon ] . h . size ( ) > input . t ) break ; } } int choose_closest_point ( Input & input , vector < Coord > & path , double r , double c ) { double mind = 1e10 , curd ; int idx_min = 0 ; for ( int i = 1 ; i < path . size ( ) ; i ++ ) { curd = compute_distance ( path [ i ] . r , path [ i ] . c , path [ i ] . h , r , c , input . r , input . c ) ; if ( curd < mind || idx_min == 0 ) { idx_min = i ; mind = curd ; } } return idx_min ; } bool check_horizontal_distance ( double c1 , double c2 , double delta_c , double c ) { if ( delta_c > c ) return true ; c2 += delta_c ; if ( c2 > c ) c2 -= c ; if ( abs ( c2 - c1 ) < c - abs ( c2 - c1 ) ) return c1 < c2 ; else return c1 > c2 ; } void pathfinding ( Input & input , int balloon , double r , double c , double delta , int bfsdepth , double delta_c , double alpha = 0.5 ) { bool step_done = false ; while ( step_done == false || ( input . balloons [ balloon ] . h . size ( ) <= input . t && compute_distance ( input . balloons [ balloon ] . r . back ( ) , input . balloons [ balloon ] . c . back ( ) , input . balloons [ balloon ] . h . back ( ) , r , c , input . r , input . c ) > delta && check_horizontal_distance ( input . balloons [ balloon ] . c . back ( ) , c , delta_c , input . c ) ) ) { vector < Coord > path ; vector < int > prev ; Coord start ; start . r = input . balloons [ balloon ] . r . back ( ) ; start . c = input . balloons [ balloon ] . c . back ( ) ; start . h = input . balloons [ balloon ] . h . back ( ) ; path . push_back ( start ) ; prev . push_back ( - 1 ) ; bfs ( input , path , prev , r , c , bfsdepth , alpha ) ; int idx_min = choose_closest_point ( input , path , r , c ) ; append_path ( input , balloon , path , prev , idx_min ) ; step_done = true ; } } </DOCUMENT>
<DOCUMENT_ID="geodynamics/gale/tree/master/boost/libs/regex/performance/time_greta.cpp"> # include " regex _ comparison . hpp " # if defined ( BOOST_HAS_GRETA ) # include < cassert > # include < boost / timer . hpp > # include " regexpr2 . h " namespace g { double time_match ( const std :: string & re , const std :: string & text , bool icase ) { regex :: rpattern e ( re , ( icase ? regex :: MULTILINE | regex :: NORMALIZE | regex :: NOCASE : regex :: MULTILINE | regex :: NORMALIZE ) ) ; regex :: match_results what ; boost :: timer tim ; int iter = 1 ; int counter , repeats ; double result = 0 ; double run ; assert ( e . match ( text , what ) ) ; do { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text , what ) ; } result = tim . elapsed ( ) ; iter *= 2 ; } while ( result < 0.5 ) ; iter /= 2 ; for ( repeats = 0 ; repeats < REPEAT_COUNT ; ++ repeats ) { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text , what ) ; } run = tim . elapsed ( ) ; result = ( std :: min ) ( run , result ) ; } return result / iter ; } double time_find_all ( const std :: string & re , const std :: string & text , bool icase ) { regex :: rpattern e ( re , ( icase ? regex :: MULTILINE | regex :: NORMALIZE | regex :: NOCASE : regex :: MULTILINE | regex :: NORMALIZE ) ) ; regex :: match_results what ; boost :: timer tim ; int iter = 1 ; int counter , repeats ; double result = 0 ; double run ; do { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text . begin ( ) , text . end ( ) , what ) ; while ( what . backref ( 0 ) . matched ) { e . match ( what . backref ( 0 ) . end ( ) , text . end ( ) , what ) ; } } result = tim . elapsed ( ) ; iter *= 2 ; } while ( result < 0.5 ) ; iter /= 2 ; if ( result > 10 ) return result / iter ; for ( repeats = 0 ; repeats < REPEAT_COUNT ; ++ repeats ) { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text . begin ( ) , text . end ( ) , what ) ; while ( what . backref ( 0 ) . matched ) { e . match ( what . backref ( 0 ) . end ( ) , text . end ( ) , what ) ; } } run = tim . elapsed ( ) ; result = ( std :: min ) ( run , result ) ; } return result / iter ; } } # else namespace g { double time_match ( const std :: string & re , const std :: string & text , bool icase ) { return - 1 ; } double time_find_all ( const std :: string & re , const std :: string & text , bool icase ) { return - 1 ; } } # endif </DOCUMENT>
<DOCUMENT_ID="MazZzinatus/storm/tree/master/src/test/storm-pars/utility/ModelInstantiatorTest.cpp"> # include " gtest / gtest . h " # include " storm - config . h " # ifdef STORM_HAVE_CARL # include " storm / adapters / RationalFunctionAdapter . h " # include < carl / numbers / numbers . h > # include < carl / core / VariablePool . h > # include " storm / settings / SettingsManager . h " # include " storm / settings / modules / GeneralSettings . h " # include " storm - pars / utility / ModelInstantiator . h " # include " storm / api / storm . h " # include " storm / models / sparse / Model . h " # include " storm / models / sparse / Dtmc . h " # include " storm / models / sparse / Mdp . h " TEST ( ModelInstantiatorTest , BrpProb ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pdtmc / brp16_2 . pm " ; std :: string formulaAsString = " P = ? ▁ [ F ▁ s = 5 ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> dtmc = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Dtmc < storm :: RationalFunction > , storm :: models :: sparse :: Dtmc < double >> modelInstantiator ( * dtmc ) ; EXPECT_FALSE ( dtmc -> hasRewardModel ( ) ) ; { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.8 ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.2989278941 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_EQ ( 0.0 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] ) ; } { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.01588055832 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } } TEST ( ModelInstantiatorTest , Brp_Rew ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pdtmc / brp16_2 . pm " ; std :: string formulaAsString = " R = ? ▁ [ F ▁ ( ( s = 5 ) ▁ | ▁ ( s = 0 & srep = 3 ) ) ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> dtmc = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Dtmc < storm :: RationalFunction > , storm :: models :: sparse :: Dtmc < double >> modelInstantiator ( * dtmc ) ; { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & TOMsg = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " TOMsg " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & TOAck = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " TOAck " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.3 ) ) ) ; valuation . insert ( std :: make_pair ( TOMsg , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.3 ) ) ) ; valuation . insert ( std :: make_pair ( TOAck , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.5 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } ASSERT_TRUE ( instantiated . hasUniqueRewardModel ( ) ) ; EXPECT_FALSE ( instantiated . getUniqueRewardModel ( ) . hasStateRewards ( ) ) ; EXPECT_FALSE ( instantiated . getUniqueRewardModel ( ) . hasTransitionRewards ( ) ) ; EXPECT_TRUE ( instantiated . getUniqueRewardModel ( ) . hasStateActionRewards ( ) ) ; ASSERT_TRUE ( dtmc -> getUniqueRewardModel ( ) . hasStateActionRewards ( ) ) ; std :: size_t stateActionEntries = dtmc -> getUniqueRewardModel ( ) . getStateActionRewardVector ( ) . size ( ) ; ASSERT_EQ ( stateActionEntries , instantiated . getUniqueRewardModel ( ) . getStateActionRewardVector ( ) . size ( ) ) ; for ( std :: size_t i = 0 ; i < stateActionEntries ; ++ i ) { double evaluatedValue = carl :: toDouble ( dtmc -> getUniqueRewardModel ( ) . getStateActionRewardVector ( ) [ i ] . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiated . getUniqueRewardModel ( ) . getStateActionRewardVector ( ) [ i ] ) ; } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 1.308324495 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } } TEST ( ModelInstantiatorTest , Consensus ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pmdp / coin2_2 . nm " ; std :: string formulaAsString = " Pmin = ? ▁ [ F ▁ \ " finished\ " & \ " all _ coins _ equal _ 1\ " ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Mdp < storm :: RationalFunction >> mdp = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Mdp < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Mdp < storm :: RationalFunction > , storm :: models :: sparse :: Mdp < double >> modelInstantiator ( * mdp ) ; std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & p1 = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " p1" ) ; ASSERT_NE ( p1 , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & p2 = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " p2" ) ; ASSERT_NE ( p2 , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( p1 , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.51 ) ) ) ; valuation . insert ( std :: make_pair ( p2 , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.49 ) ) ) ; storm :: models :: sparse :: Mdp < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < mdp -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : mdp -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( mdp -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( mdp -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseMdpPrctlModelChecker < storm :: models :: sparse :: Mdp < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.3526577219 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } # endif </DOCUMENT>
<DOCUMENT_ID="MattMulhern/OpenMamaCassandra/tree/master/mamda/c_cpp/src/examples/parsecmd.cpp"> # include < mama / mama . h > # include < mama / mamacpp . h > # include < mama / MamaTransport . h > # include " parsecmd . h " # include < fstream > # include < iostream > # include < string > # include < map > # include < string . h > # include < mamda / MamdaVersion . h > using std :: ifstream ; using std :: cerr ; using std :: string ; using std :: map ; using namespace Wombat ; typedef map < string , const char * > OptionMap ; extern void usage ( int ) ; ExampleLogLevel gExampleLogLevel = EXAMPLE_LOG_LEVEL_NORMAL ; struct CommonCommandLineParser :: CommonCommandLineParserImpl { CommonCommandLineParserImpl ( int argc , const char * argv [ ] ) ; const char * mSourceName ; const char * mTportName ; MamaSource * mSource ; const char * mDictSourceName ; const char * mDictTportName ; const char * mDictFileName ; MamaSource * mDictSource ; const char * mOptionSourceName ; const char * mOptionTportName ; MamaSource * mOptionSource ; const char * mSymbolMapFile ; vector < const char * > mSymbolList ; double mThrottleRate ; int mThreads ; double mTimeout ; MamaLogLevel mSubscLogLevel ; OptionMap mOptions ; bool mLogReqResp ; bool mUseWorldView ; const char * mSymbology ; int mChurnRate ; double mTimerInterval ; const char * mLogFileName ; const char * mMiddleware ; int mPrecision ; int mShutdownTime ; bool mShowDeltas ; mamaBridge mBridge ; bool mSnapShot ; const char * mQueryArg1 ; const char * mQueryArg2 ; const char * mQueryArg3 ; const char * mQueryArg4 ; int mQuery ; int mQueryType ; int mQueryCycles ; bool mPublishRecaps ; } ; CommonCommandLineParser :: CommonCommandLineParser ( int argc , const char * argv [ ] ) : mImpl ( * new CommonCommandLineParserImpl ( argc , argv ) ) { } CommonCommandLineParser :: ~ CommonCommandLineParser ( ) { delete & mImpl ; } bool CommonCommandLineParser :: getPublishRecaps ( ) { return mImpl . mPublishRecaps ; } MamaSource * CommonCommandLineParser :: getSource ( ) { if ( ! mImpl . mSource ) { mImpl . mSource = new MamaSource ( " default " , mImpl . mTportName , mImpl . mSourceName , mImpl . mBridge ) ; mImpl . mSource -> getTransport ( ) -> setOutboundThrottle ( mImpl . mThrottleRate , MAMA_THROTTLE_DEFAULT ) ; } return mImpl . mSource ; } MamaSource * CommonCommandLineParser :: getDictSource ( ) { if ( ! mImpl . mDictSource ) { mImpl . mDictSource = new MamaSource ( " dict " , mImpl . mDictTportName ? mImpl . mDictTportName : mImpl . mTportName , mImpl . mDictSourceName , mImpl . mBridge ) ; } return mImpl . mDictSource ; } MamaSource * CommonCommandLineParser :: getOptionSource ( ) { if ( ! mImpl . mOptionSource ) { mImpl . mOptionSource = new MamaSource ( " options " , mImpl . mOptionTportName ? mImpl . mOptionTportName : mImpl . mTportName , mImpl . mOptionSourceName , mImpl . mBridge ) ; mImpl . mOptionSource -> getTransport ( ) -> setOutboundThrottle ( mImpl . mThrottleRate , MAMA_THROTTLE_DEFAULT ) ; } return mImpl . mOptionSource ; } const char * CommonCommandLineParser :: getSymbolMapFile ( ) { return mImpl . mSymbolMapFile ; } const vector < const char * > & CommonCommandLineParser :: getSymbolList ( ) { return mImpl . mSymbolList ; } double CommonCommandLineParser :: getThrottleRate ( ) { return mImpl . mThrottleRate ; } int CommonCommandLineParser :: getNumThreads ( ) { return mImpl . mThreads ; } double CommonCommandLineParser :: getTimeout ( ) { return mImpl . mTimeout ; } MamaLogLevel CommonCommandLineParser :: getSubscLogLevel ( ) { return mImpl . mSubscLogLevel ; } bool CommonCommandLineParser :: getUseWorldview ( ) { return mImpl . mUseWorldView ; } bool CommonCommandLineParser :: getLogReqResp ( ) { return mImpl . mLogReqResp ; } const char * CommonCommandLineParser :: getSymbology ( ) { return mImpl . mSymbology ; } const char * CommonCommandLineParser :: getMiddleware ( ) { return mImpl . mMiddleware ; } int CommonCommandLineParser :: getPrecision ( ) { return mImpl . mPrecision ; } int CommonCommandLineParser :: getShutdownTime ( ) { return mImpl . mShutdownTime ; } bool CommonCommandLineParser :: showDeltas ( ) { return mImpl . mShowDeltas ; } mamaBridge CommonCommandLineParser :: getBridge ( ) { return mImpl . mBridge ; } bool CommonCommandLineParser :: getSnapshot ( ) { return mImpl . mSnapShot ; } bool CommonCommandLineParser :: getOptBool ( char option0 ) { string option ( & option0 , 0 , 1 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; return ( found != mImpl . mOptions . end ( ) ) ; } bool CommonCommandLineParser :: getOptBool ( const char * option0 ) { string option ( option0 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; return ( found != mImpl . mOptions . end ( ) ) ; } int CommonCommandLineParser :: getOptInt ( char option0 , int defaultValue ) { string option ( & option0 , 0 , 1 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; if ( found != mImpl . mOptions . end ( ) ) { const char * value = found -> second ; if ( value ) return strtol ( value , NULL , 10 ) ; } return defaultValue ; } int CommonCommandLineParser :: getOptInt ( const char * option0 , int defaultValue ) { string option ( option0 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; if ( found != mImpl . mOptions . end ( ) ) { const char * value = found -> second ; if ( value ) return strtol ( value , NULL , 10 ) ; } return defaultValue ; } const char * CommonCommandLineParser :: getOptString ( char option0 ) { string option ( & option0 , 0 , 1 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; if ( found != mImpl . mOptions . end ( ) ) { return found -> second ; } return NULL ; } const char * CommonCommandLineParser :: getOptString ( const char * option0 ) { string option ( option0 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; if ( found != mImpl . mOptions . end ( ) ) { return found -> second ; } return NULL ; } int CommonCommandLineParser :: getChurnRate ( ) { return mImpl . mChurnRate ; } double CommonCommandLineParser :: getTimerInterval ( ) { return mImpl . mTimerInterval ; } const char * CommonCommandLineParser :: getLogFileName ( ) { return mImpl . mLogFileName ; } const char * CommonCommandLineParser :: getQueryArg1 ( ) { return mImpl . mQueryArg1 ; } const char * CommonCommandLineParser :: getQueryArg2 ( ) { return mImpl . mQueryArg2 ; } const char * CommonCommandLineParser :: getQueryArg3 ( ) { return mImpl . mQueryArg3 ; } const char * CommonCommandLineParser :: getQueryArg4 ( ) { return mImpl . mQueryArg4 ; } int CommonCommandLineParser :: getQuery ( ) { return mImpl . mQuery ; } int CommonCommandLineParser :: getQueryType ( ) { return mImpl . mQueryType ; } int CommonCommandLineParser :: getQueries ( ) { return mImpl . mQueryCycles ; } CommonCommandLineParser :: CommonCommandLineParserImpl :: CommonCommandLineParserImpl ( int argc , const char * argv [ ] ) { mSource = NULL ; mDictSource = NULL ; mOptionSource = NULL ; mSymbolMapFile = NULL ; mThrottleRate = 500.0 ; mThreads = 0 ; mTimeout = 1.0 ; mChurnRate = 0 ; mTimerInterval = 1.0 ; mLogFileName = NULL ; mMiddleware = " wmw " ; mPrecision = 2 ; mShutdownTime = 0 ; mShowDeltas = false ; mBridge = NULL ; int i = 1 ; mUseWorldView = false ; mTportName = NULL ; mDictTportName = NULL ; mOptionTportName = NULL ; mSourceName = " WOMBAT " ; mDictSourceName = " WOMBAT " ; mOptionSourceName = " OPRA " ; mSnapShot = false ; mPublishRecaps = false ; mQueryArg1 = NULL ; mQueryArg2 = NULL ; mQueryArg3 = NULL ; mQueryArg4 = NULL ; mQuery = 0 ; mQueryType = 0 ; mQueryCycles = 1 ; while ( i < argc ) { bool handled = false ; if ( ( strcmp ( argv [ i ] , " - OS " ) == 0 ) || ( strcmp ( argv [ i ] , " - optionSource " ) == 0 ) || ( strcmp ( argv [ i ] , " - option - source " ) == 0 ) ) { mOptionSourceName = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - S " ) == 0 ) || ( strcmp ( argv [ i ] , " - source " ) == 0 ) ) { mSourceName = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - use _ dict _ file " ) == 0 ) ) { mDictFileName = argv [ i + 1 ] ; } else if ( ( strcmp ( argv [ i ] , " - DS " ) == 0 ) || ( strcmp ( argv [ i ] , " - dict - source " ) == 0 ) || ( strcmp ( argv [ i ] , " - dictSource " ) == 0 ) || ( strcmp ( argv [ i ] , " - d " ) == 0 ) ) { mDictSourceName = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - T " ) == 0 ) || ( strcmp ( argv [ i ] , " - tport " ) == 0 ) ) { mTportName = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - DT " ) == 0 ) || ( strcmp ( argv [ i ] , " - dictTport " ) == 0 ) || ( strcmp ( argv [ i ] , " - dict - tport " ) == 0 ) || ( strcmp ( argv [ i ] , " - dict _ tport " ) == 0 ) ) { mDictTportName = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - OT " ) == 0 ) || ( strcmp ( argv [ i ] , " - optionTport " ) == 0 ) || ( strcmp ( argv [ i ] , " - option - tport " ) == 0 ) ) { mOptionTportName = argv [ i + 1 ] ; handled = true ; } else if ( strcmp ( argv [ i ] , " - s " ) == 0 ) { mSymbolList . push_back ( argv [ i + 1 ] ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - threads " ) == 0 ) { mThreads = strtol ( argv [ i + 1 ] , NULL , 10 ) ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - r " ) == 0 ) || ( strcmp ( argv [ i ] , " - rate " ) == 0 ) ) { mThrottleRate = strtod ( argv [ i + 1 ] , NULL ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - t " ) == 0 ) { mTimeout = strtod ( argv [ i + 1 ] , NULL ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - mp " ) == 0 ) { mSymbolMapFile = argv [ i + 1 ] ; handled = true ; } else if ( strcmp ( argv [ i ] , " - m " ) == 0 ) { mMiddleware = argv [ i + 1 ] ; handled = true ; } else if ( strcmp ( argv [ i ] , " - precision " ) == 0 ) { mPrecision = strtol ( argv [ i + 1 ] , NULL , 10 ) ; if ( ! mPrecision ) { mPrecision = 2 ; } if ( mPrecision > 6 ) { mPrecision = 6 ; } handled = true ; } else if ( strcmp ( " - shutdown " , argv [ i ] ) == 0 ) { mShutdownTime = atoi ( argv [ i + 1 ] ) ; } else if ( strcmp ( argv [ i ] , " - deltas " ) == 0 ) { mShowDeltas = true ; } else if ( strcmp ( argv [ i ] , " - churn " ) == 0 ) { mChurnRate = strtol ( argv [ i + 1 ] , NULL , 10 ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - timerInterval " ) == 0 ) { mTimerInterval = strtod ( argv [ i + 1 ] , NULL ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - logfile " ) == 0 ) { mLogFileName = argv [ i + 1 ] ; handled = true ; } else if ( strcmp ( argv [ i ] , " - f " ) == 0 ) { const char * filename = argv [ i + 1 ] ; ifstream input ( filename ) ; if ( ! input ) { cerr << " Cannot ▁ open ▁ file : ▁ " << filename << " \n " ; exit ( 1 ) ; } string symbol ; input >> symbol ; while ( ! input . eof ( ) ) { if ( ! symbol . empty ( ) ) { mSymbolList . push_back ( strdup ( symbol . c_str ( ) ) ) ; } input >> symbol ; } handled = true ; } else if ( strcmp ( argv [ i ] , " - v " ) == 0 ) { if ( mama_getLogLevel ( ) == MAMA_LOG_LEVEL_NORMAL ) { mama_enableLogging ( stderr , MAMA_LOG_LEVEL_FINE ) ; } else if ( mama_getLogLevel ( ) == MAMA_LOG_LEVEL_FINE ) { mama_enableLogging ( stderr , MAMA_LOG_LEVEL_FINER ) ; } else { mama_enableLogging ( stderr , MAMA_LOG_LEVEL_FINEST ) ; } handled = true ; } else if ( strcmp ( argv [ i ] , " - q " ) == 0 ) { if ( gExampleLogLevel == EXAMPLE_LOG_LEVEL_NORMAL ) { gExampleLogLevel = EXAMPLE_LOG_LEVEL_QUIET ; } else if ( gExampleLogLevel == EXAMPLE_LOG_LEVEL_QUIET ) { gExampleLogLevel = EXAMPLE_LOG_LEVEL_QUIETER ; } else if ( gExampleLogLevel == EXAMPLE_LOG_LEVEL_QUIETER ) { gExampleLogLevel = EXAMPLE_LOG_LEVEL_QUIETEST ; } handled = true ; } else if ( strcmp ( argv [ i ] , " - V " ) == 0 ) { if ( mSubscLogLevel == MAMA_LOG_LEVEL_NORMAL ) { mSubscLogLevel = MAMA_LOG_LEVEL_FINE ; } else if ( mSubscLogLevel == MAMA_LOG_LEVEL_FINE ) { mSubscLogLevel = MAMA_LOG_LEVEL_FINER ; } else { mSubscLogLevel = MAMA_LOG_LEVEL_FINEST ; } handled = true ; } else if ( strcmp ( argv [ i ] , " - W " ) == 0 ) { mUseWorldView = true ; handled = true ; } else if ( strcmp ( argv [ i ] , " - L " ) == 0 ) { mLogReqResp = true ; handled = true ; } else if ( strcmp ( argv [ i ] , " - Y " ) == 0 ) { mSymbology = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - ? " ) == 0 ) || ( strcmp ( argv [ i ] , " - - help " ) == 0 ) ) { usage ( 1 ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - PR " ) == 0 ) { mPublishRecaps = true ; } else if ( strcmp ( argv [ i ] , " - 1" ) == 0 ) { mSnapShot = true ; handled = true ; } else if ( strcmp ( argv [ i ] , " - Q " ) == 0 ) { mQuery = strtol ( argv [ i + 1 ] , NULL , 10 ) ; } else if ( strcmp ( argv [ i ] , " - QT " ) == 0 ) { mQueryType = strtol ( argv [ i + 1 ] , NULL , 10 ) ; } else if ( strcmp ( argv [ i ] , " - A1" ) == 0 ) { mQueryArg1 = argv [ i + 1 ] ; } else if ( strcmp ( argv [ i ] , " - A2" ) == 0 ) { mQueryArg2 = argv [ i + 1 ] ; } else if ( strcmp ( argv [ i ] , " - A3" ) == 0 ) { mQueryArg3 = argv [ i + 1 ] ; } else if ( strcmp ( argv [ i ] , " - A4" ) == 0 ) { mQueryArg4 = argv [ i + 1 ] ; } else if ( strcmp ( argv [ i ] , " - QC " ) == 0 ) { mQueryCycles = strtol ( argv [ i + 1 ] , NULL , 10 ) ; } if ( argv [ i ] [ 0 ] == ' - ' ) { const char * opt = argv [ i ] + 1 ; if ( strlen ( opt ) > 0 ) { if ( ( i + 1 < argc ) && ( argv [ i + 1 ] [ 0 ] != ' - ' ) ) { mOptions [ opt ] = argv [ i + 1 ] ; i += 2 ; } else { mOptions [ opt ] = "1" ; i ++ ; } } handled = true ; } if ( ! handled ) { usage ( 1 ) ; } } mBridge = Mama :: loadBridge ( mMiddleware ) ; } </DOCUMENT>
<DOCUMENT_ID="fritsvanveen/QGIS/tree/master/src/gui/qgsnewhttpconnection.cpp"> # include " qgsnewhttpconnection . h " # include " qgscontexthelp . h " # include " qgsauthconfigselect . h " # include < QSettings > # include < QMessageBox > # include < QUrl > # include < QPushButton > # include < QRegExpValidator > QgsNewHttpConnection :: QgsNewHttpConnection ( QWidget * parent , const QString & baseKey , const QString & connName , Qt :: WindowFlags fl ) : QDialog ( parent , fl ) , mBaseKey ( baseKey ) , mOriginalConnName ( connName ) , mAuthConfigSelect ( nullptr ) { setupUi ( this ) ; QString service = baseKey . mid ( 18 , 3 ) . toUpper ( ) ; setWindowTitle ( tr ( " Create ▁ a ▁ new ▁ % 1 ▁ connection " ) . arg ( service ) ) ; mCredentialsBaseKey = mBaseKey . split ( ' - ' ) . last ( ) . toUpper ( ) ; txtName -> setValidator ( new QRegExpValidator ( QRegExp ( " [ ^ \\ / ] + " ) , txtName ) ) ; cmbDpiMode -> clear ( ) ; cmbDpiMode -> addItem ( tr ( " all " ) ) ; cmbDpiMode -> addItem ( tr ( " off " ) ) ; cmbDpiMode -> addItem ( tr ( " QGIS " ) ) ; cmbDpiMode -> addItem ( tr ( " UMN " ) ) ; cmbDpiMode -> addItem ( tr ( " GeoServer " ) ) ; cmbVersion -> clear ( ) ; cmbVersion -> addItem ( tr ( " Auto - detect " ) ) ; cmbVersion -> addItem ( tr ( "1.0" ) ) ; cmbVersion -> addItem ( tr ( "1.1" ) ) ; cmbVersion -> addItem ( tr ( "2.0" ) ) ; mAuthConfigSelect = new QgsAuthConfigSelect ( this ) ; tabAuth -> insertTab ( 1 , mAuthConfigSelect , tr ( " Configurations " ) ) ; if ( ! connName . isEmpty ( ) ) { QSettings settings ; QString key = mBaseKey + connName ; QString credentialsKey = " / Qgis / " + mCredentialsBaseKey + ' / ' + connName ; txtName -> setText ( connName ) ; txtUrl -> setText ( settings . value ( key + " / url " ) . toString ( ) ) ; cbxIgnoreGetMapURI -> setChecked ( settings . value ( key + " / ignoreGetMapURI " , false ) . toBool ( ) ) ; cbxIgnoreAxisOrientation -> setChecked ( settings . value ( key + " / ignoreAxisOrientation " , false ) . toBool ( ) ) ; cbxInvertAxisOrientation -> setChecked ( settings . value ( key + " / invertAxisOrientation " , false ) . toBool ( ) ) ; cbxIgnoreGetFeatureInfoURI -> setChecked ( settings . value ( key + " / ignoreGetFeatureInfoURI " , false ) . toBool ( ) ) ; cbxSmoothPixmapTransform -> setChecked ( settings . value ( key + " / smoothPixmapTransform " , false ) . toBool ( ) ) ; int dpiIdx ; switch ( settings . value ( key + " / dpiMode " , 7 ) . toInt ( ) ) { case 0 : dpiIdx = 1 ; break ; case 1 : dpiIdx = 2 ; break ; case 2 : dpiIdx = 3 ; break ; case 4 : dpiIdx = 4 ; break ; default : dpiIdx = 0 ; break ; } cmbDpiMode -> setCurrentIndex ( dpiIdx ) ; QString version = settings . value ( key + " / version " ) . toString ( ) ; int versionIdx = 0 ; if ( version == "1.0.0" ) versionIdx = 1 ; else if ( version == "1.1.0" ) versionIdx = 2 ; else if ( version == "2.0.0" ) versionIdx = 3 ; cmbVersion -> setCurrentIndex ( versionIdx ) ; txtReferer -> setText ( settings . value ( key + " / referer " ) . toString ( ) ) ; txtMaxNumFeatures -> setText ( settings . value ( key + " / maxnumfeatures " ) . toString ( ) ) ; txtUserName -> setText ( settings . value ( credentialsKey + " / username " ) . toString ( ) ) ; txtPassword -> setText ( settings . value ( credentialsKey + " / password " ) . toString ( ) ) ; QString authcfg = settings . value ( credentialsKey + " / authcfg " ) . toString ( ) ; mAuthConfigSelect -> setConfigId ( authcfg ) ; if ( ! authcfg . isEmpty ( ) ) { tabAuth -> setCurrentIndex ( tabAuth -> indexOf ( mAuthConfigSelect ) ) ; } } if ( mBaseKey != " / Qgis / connections - wms / " ) { if ( mBaseKey != " / Qgis / connections - wcs / " && mBaseKey != " / Qgis / connections - wfs / " ) { cbxIgnoreAxisOrientation -> setVisible ( false ) ; cbxInvertAxisOrientation -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxIgnoreAxisOrientation ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxInvertAxisOrientation ) ; } if ( mBaseKey == " / Qgis / connections - wfs / " ) { cbxIgnoreAxisOrientation -> setText ( tr ( " Ignore ▁ axis ▁ orientation ▁ ( WFS ▁ 1.1 / WFS ▁ 2.0 ) " ) ) ; } if ( mBaseKey == " / Qgis / connections - wcs / " ) { cbxIgnoreGetMapURI -> setText ( tr ( " Ignore ▁ GetCoverage ▁ URI ▁ reported ▁ in ▁ capabilities " ) ) ; cbxIgnoreAxisOrientation -> setText ( tr ( " Ignore ▁ axis ▁ orientation " ) ) ; } else { cbxIgnoreGetMapURI -> setVisible ( false ) ; cbxSmoothPixmapTransform -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxIgnoreGetMapURI ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxSmoothPixmapTransform ) ; } cbxIgnoreGetFeatureInfoURI -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxIgnoreGetFeatureInfoURI ) ; cmbDpiMode -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cmbDpiMode ) ; lblDpiMode -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( lblDpiMode ) ; txtReferer -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( txtReferer ) ; lblReferer -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( lblReferer ) ; } if ( mBaseKey != " / Qgis / connections - wfs / " ) { cmbVersion -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cmbVersion ) ; lblMaxNumFeatures -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( lblMaxNumFeatures ) ; txtMaxNumFeatures -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( txtMaxNumFeatures ) ; } int w = width ( ) ; adjustSize ( ) ; resize ( w , height ( ) ) ; on_txtName_textChanged ( connName ) ; } QgsNewHttpConnection :: ~ QgsNewHttpConnection ( ) { } void QgsNewHttpConnection :: on_txtName_textChanged ( const QString & text ) { Q_UNUSED ( text ) ; buttonBox -> button ( QDialogButtonBox :: Ok ) -> setDisabled ( txtName -> text ( ) . isEmpty ( ) || txtUrl -> text ( ) . isEmpty ( ) ) ; } void QgsNewHttpConnection :: on_txtUrl_textChanged ( const QString & text ) { Q_UNUSED ( text ) ; buttonBox -> button ( QDialogButtonBox :: Ok ) -> setDisabled ( txtName -> text ( ) . isEmpty ( ) || txtUrl -> text ( ) . isEmpty ( ) ) ; } void QgsNewHttpConnection :: accept ( ) { QSettings settings ; QString key = mBaseKey + txtName -> text ( ) ; QString credentialsKey = " / Qgis / " + mCredentialsBaseKey + ' / ' + txtName -> text ( ) ; if ( ( mOriginalConnName . isNull ( ) || mOriginalConnName . compare ( txtName -> text ( ) , Qt :: CaseInsensitive ) != 0 ) && settings . contains ( key + " / url " ) && QMessageBox :: question ( this , tr ( " Save ▁ connection " ) , tr ( " Should ▁ the ▁ existing ▁ connection ▁ % 1 ▁ be ▁ overwritten ? " ) . arg ( txtName -> text ( ) ) , QMessageBox :: Ok | QMessageBox :: Cancel ) == QMessageBox :: Cancel ) { return ; } if ( ! txtPassword -> text ( ) . isEmpty ( ) && QMessageBox :: question ( this , tr ( " Saving ▁ passwords " ) , tr ( " WARNING : ▁ You ▁ have ▁ entered ▁ a ▁ password . ▁ It ▁ will ▁ be ▁ stored ▁ in ▁ plain ▁ text ▁ in ▁ your ▁ project ▁ files ▁ and ▁ in ▁ your ▁ home ▁ directory ▁ on ▁ Unix - like ▁ systems , ▁ or ▁ in ▁ your ▁ user ▁ profile ▁ on ▁ Windows . ▁ If ▁ you ▁ do ▁ not ▁ want ▁ this ▁ to ▁ happen , ▁ please ▁ press ▁ the ▁ Cancel ▁ button . \n Note : ▁ giving ▁ the ▁ password ▁ is ▁ optional . ▁ It ▁ will ▁ be ▁ requested ▁ interactivly , ▁ when ▁ needed . " ) , QMessageBox :: Ok | QMessageBox :: Cancel ) == QMessageBox :: Cancel ) { return ; } if ( ! mOriginalConnName . isNull ( ) && mOriginalConnName != key ) { settings . remove ( mBaseKey + mOriginalConnName ) ; settings . remove ( " / Qgis / " + mCredentialsBaseKey + ' / ' + mOriginalConnName ) ; settings . sync ( ) ; } QUrl url ( txtUrl -> text ( ) . trimmed ( ) ) ; const QList < QPair < QByteArray , QByteArray > > & items = url . encodedQueryItems ( ) ; QHash < QString , QPair < QByteArray , QByteArray > > params ; for ( QList < QPair < QByteArray , QByteArray > > :: const_iterator it = items . constBegin ( ) ; it != items . constEnd ( ) ; ++ it ) { params . insert ( QString ( it -> first ) . toUpper ( ) , * it ) ; } if ( params [ " SERVICE " ] . second . toUpper ( ) == " WMS " || params [ " SERVICE " ] . second . toUpper ( ) == " WFS " || params [ " SERVICE " ] . second . toUpper ( ) == " WCS " ) { url . removeEncodedQueryItem ( params [ " SERVICE " ] . first ) ; url . removeEncodedQueryItem ( params [ " REQUEST " ] . first ) ; url . removeEncodedQueryItem ( params [ " FORMAT " ] . first ) ; } if ( url . encodedPath ( ) . isEmpty ( ) ) { url . setEncodedPath ( " / " ) ; } settings . setValue ( key + " / url " , url . toString ( ) ) ; if ( mBaseKey == " / Qgis / connections - wms / " || mBaseKey == " / Qgis / connections - wcs / " || mBaseKey == " / Qgis / connections - wfs / " ) { settings . setValue ( key + " / ignoreAxisOrientation " , cbxIgnoreAxisOrientation -> isChecked ( ) ) ; settings . setValue ( key + " / invertAxisOrientation " , cbxInvertAxisOrientation -> isChecked ( ) ) ; } if ( mBaseKey == " / Qgis / connections - wms / " || mBaseKey == " / Qgis / connections - wcs / " ) { settings . setValue ( key + " / ignoreGetMapURI " , cbxIgnoreGetMapURI -> isChecked ( ) ) ; settings . setValue ( key + " / smoothPixmapTransform " , cbxSmoothPixmapTransform -> isChecked ( ) ) ; int dpiMode = 0 ; switch ( cmbDpiMode -> currentIndex ( ) ) { case 0 : dpiMode = 7 ; break ; case 1 : dpiMode = 0 ; break ; case 2 : dpiMode = 1 ; break ; case 3 : dpiMode = 2 ; break ; case 4 : dpiMode = 4 ; break ; } settings . setValue ( key + " / dpiMode " , dpiMode ) ; } if ( mBaseKey == " / Qgis / connections - wms / " ) { settings . setValue ( key + " / ignoreGetFeatureInfoURI " , cbxIgnoreGetFeatureInfoURI -> isChecked ( ) ) ; } if ( mBaseKey == " / Qgis / connections - wfs / " ) { QString version = " auto " ; switch ( cmbVersion -> currentIndex ( ) ) { case 0 : version = " auto " ; break ; case 1 : version = "1.0.0" ; break ; case 2 : version = "1.1.0" ; break ; case 3 : version = "2.0.0" ; break ; } settings . setValue ( key + " / version " , version ) ; settings . setValue ( key + " / maxnumfeatures " , txtMaxNumFeatures -> text ( ) ) ; } settings . setValue ( key + " / referer " , txtReferer -> text ( ) ) ; settings . setValue ( credentialsKey + " / username " , txtUserName -> text ( ) ) ; settings . setValue ( credentialsKey + " / password " , txtPassword -> text ( ) ) ; settings . setValue ( credentialsKey + " / authcfg " , mAuthConfigSelect -> configId ( ) ) ; settings . setValue ( mBaseKey + " / selected " , txtName -> text ( ) ) ; QDialog :: accept ( ) ; } </DOCUMENT>
<DOCUMENT_ID="yuhangwang/spii/tree/master/thirdparty/Eigen/demos/opengl/icosphere.cpp"> # include " icosphere . h " # include < GL / gl . h > # include < map > using namespace Eigen ; # define X .525731112119133606 # define Z .850650808352039932 static GLfloat vdata [ 12 ] [ 3 ] = { { - X , 0.0 , Z } , { X , 0.0 , Z } , { - X , 0.0 , - Z } , { X , 0.0 , - Z } , { 0.0 , Z , X } , { 0.0 , Z , - X } , { 0.0 , - Z , X } , { 0.0 , - Z , - X } , { Z , X , 0.0 } , { - Z , X , 0.0 } , { Z , - X , 0.0 } , { - Z , - X , 0.0 } } ; static GLint tindices [ 20 ] [ 3 ] = { { 0 , 4 , 1 } , { 0 , 9 , 4 } , { 9 , 5 , 4 } , { 4 , 5 , 8 } , { 4 , 8 , 1 } , { 8 , 10 , 1 } , { 8 , 3 , 10 } , { 5 , 3 , 8 } , { 5 , 2 , 3 } , { 2 , 7 , 3 } , { 7 , 10 , 3 } , { 7 , 6 , 10 } , { 7 , 11 , 6 } , { 11 , 0 , 6 } , { 0 , 1 , 6 } , { 6 , 1 , 10 } , { 9 , 0 , 11 } , { 9 , 11 , 2 } , { 9 , 2 , 5 } , { 7 , 2 , 11 } } ; IcoSphere :: IcoSphere ( unsigned int levels ) { for ( int i = 0 ; i < 12 ; i ++ ) mVertices . push_back ( Map < Vector3f > ( vdata [ i ] ) ) ; mIndices . push_back ( new std :: vector < int > ) ; std :: vector < int > & indices = * mIndices . back ( ) ; for ( int i = 0 ; i < 20 ; i ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) indices . push_back ( tindices [ i ] [ k ] ) ; } mListIds . push_back ( 0 ) ; while ( mIndices . size ( ) < levels ) _subdivide ( ) ; } const std :: vector < int > & IcoSphere :: indices ( int level ) const { while ( level >= int ( mIndices . size ( ) ) ) const_cast < IcoSphere * > ( this ) -> _subdivide ( ) ; return * mIndices [ level ] ; } void IcoSphere :: _subdivide ( void ) { typedef unsigned long long Key ; std :: map < Key , int > edgeMap ; const std :: vector < int > & indices = * mIndices . back ( ) ; mIndices . push_back ( new std :: vector < int > ) ; std :: vector < int > & refinedIndices = * mIndices . back ( ) ; int end = indices . size ( ) ; for ( int i = 0 ; i < end ; i += 3 ) { int ids0 [ 3 ] , ids1 [ 3 ] ; for ( int k = 0 ; k < 3 ; ++ k ) { int k1 = ( k + 1 ) % 3 ; int e0 = indices [ i + k ] ; int e1 = indices [ i + k1 ] ; ids0 [ k ] = e0 ; if ( e1 > e0 ) std :: swap ( e0 , e1 ) ; Key edgeKey = Key ( e0 ) | ( Key ( e1 ) << 32 ) ; std :: map < Key , int > :: iterator it = edgeMap . find ( edgeKey ) ; if ( it == edgeMap . end ( ) ) { ids1 [ k ] = mVertices . size ( ) ; edgeMap [ edgeKey ] = ids1 [ k ] ; mVertices . push_back ( ( mVertices [ e0 ] + mVertices [ e1 ] ) . normalized ( ) ) ; } else ids1 [ k ] = it -> second ; } refinedIndices . push_back ( ids0 [ 0 ] ) ; refinedIndices . push_back ( ids1 [ 0 ] ) ; refinedIndices . push_back ( ids1 [ 2 ] ) ; refinedIndices . push_back ( ids0 [ 1 ] ) ; refinedIndices . push_back ( ids1 [ 1 ] ) ; refinedIndices . push_back ( ids1 [ 0 ] ) ; refinedIndices . push_back ( ids0 [ 2 ] ) ; refinedIndices . push_back ( ids1 [ 2 ] ) ; refinedIndices . push_back ( ids1 [ 1 ] ) ; refinedIndices . push_back ( ids1 [ 0 ] ) ; refinedIndices . push_back ( ids1 [ 1 ] ) ; refinedIndices . push_back ( ids1 [ 2 ] ) ; } mListIds . push_back ( 0 ) ; } void IcoSphere :: draw ( int level ) { while ( level >= int ( mIndices . size ( ) ) ) const_cast < IcoSphere * > ( this ) -> _subdivide ( ) ; if ( mListIds [ level ] == 0 ) { mListIds [ level ] = glGenLists ( 1 ) ; glNewList ( mListIds [ level ] , GL_COMPILE ) ; glVertexPointer ( 3 , GL_FLOAT , 0 , mVertices [ 0 ] . data ( ) ) ; glNormalPointer ( GL_FLOAT , 0 , mVertices [ 0 ] . data ( ) ) ; glEnableClientState ( GL_VERTEX_ARRAY ) ; glEnableClientState ( GL_NORMAL_ARRAY ) ; glDrawElements ( GL_TRIANGLES , mIndices [ level ] -> size ( ) , GL_UNSIGNED_INT , & ( mIndices [ level ] -> at ( 0 ) ) ) ; glDisableClientState ( GL_VERTEX_ARRAY ) ; glDisableClientState ( GL_NORMAL_ARRAY ) ; glEndList ( ) ; } glCallList ( mListIds [ level ] ) ; } </DOCUMENT>
<DOCUMENT_ID="hoangt/goblin-core/tree/master/riscv/llvm/3.5/llvm-3.5.0.src/lib/Target/Mips/MipsSEFrameLowering.cpp"> # include " MipsSEFrameLowering . h " # include " MCTargetDesc / MipsBaseInfo . h " # include " MipsAnalyzeImmediate . h " # include " MipsMachineFunction . h " # include " MipsSEInstrInfo . h " # include " MipsSubtarget . h " # include " llvm / CodeGen / MachineFrameInfo . h " # include " llvm / CodeGen / MachineFunction . h " # include " llvm / CodeGen / MachineInstrBuilder . h " # include " llvm / CodeGen / MachineModuleInfo . h " # include " llvm / CodeGen / MachineRegisterInfo . h " # include " llvm / CodeGen / RegisterScavenging . h " # include " llvm / IR / DataLayout . h " # include " llvm / IR / Function . h " # include " llvm / Support / CommandLine . h " # include " llvm / Target / TargetOptions . h " using namespace llvm ; namespace { typedef MachineBasicBlock :: iterator Iter ; static std :: pair < unsigned , unsigned > getMFHiLoOpc ( unsigned Src ) { if ( Mips :: ACC64RegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: PseudoMFHI , ( unsigned ) Mips :: PseudoMFLO ) ; if ( Mips :: ACC64DSPRegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: MFHI_DSP , ( unsigned ) Mips :: MFLO_DSP ) ; if ( Mips :: ACC128RegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: PseudoMFHI64 , ( unsigned ) Mips :: PseudoMFLO64 ) ; return std :: make_pair ( 0 , 0 ) ; } class ExpandPseudo { public : ExpandPseudo ( MachineFunction & MF ) ; bool expand ( ) ; private : bool expandInstr ( MachineBasicBlock & MBB , Iter I ) ; void expandLoadCCond ( MachineBasicBlock & MBB , Iter I ) ; void expandStoreCCond ( MachineBasicBlock & MBB , Iter I ) ; void expandLoadACC ( MachineBasicBlock & MBB , Iter I , unsigned RegSize ) ; void expandStoreACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc , unsigned RegSize ) ; bool expandCopy ( MachineBasicBlock & MBB , Iter I ) ; bool expandCopyACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc ) ; bool expandBuildPairF64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool FP64 ) const ; bool expandExtractElementF64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool FP64 ) const ; MachineFunction & MF ; MachineRegisterInfo & MRI ; } ; } ExpandPseudo :: ExpandPseudo ( MachineFunction & MF_ ) : MF ( MF_ ) , MRI ( MF . getRegInfo ( ) ) { } bool ExpandPseudo :: expand ( ) { bool Expanded = false ; for ( MachineFunction :: iterator BB = MF . begin ( ) , BBEnd = MF . end ( ) ; BB != BBEnd ; ++ BB ) for ( Iter I = BB -> begin ( ) , End = BB -> end ( ) ; I != End ; ) Expanded |= expandInstr ( * BB , I ++ ) ; return Expanded ; } bool ExpandPseudo :: expandInstr ( MachineBasicBlock & MBB , Iter I ) { switch ( I -> getOpcode ( ) ) { case Mips :: LOAD_CCOND_DSP : expandLoadCCond ( MBB , I ) ; break ; case Mips :: STORE_CCOND_DSP : expandStoreCCond ( MBB , I ) ; break ; case Mips :: LOAD_ACC64 : case Mips :: LOAD_ACC64DSP : expandLoadACC ( MBB , I , 4 ) ; break ; case Mips :: LOAD_ACC128 : expandLoadACC ( MBB , I , 8 ) ; break ; case Mips :: STORE_ACC64 : expandStoreACC ( MBB , I , Mips :: PseudoMFHI , Mips :: PseudoMFLO , 4 ) ; break ; case Mips :: STORE_ACC64DSP : expandStoreACC ( MBB , I , Mips :: MFHI_DSP , Mips :: MFLO_DSP , 4 ) ; break ; case Mips :: STORE_ACC128 : expandStoreACC ( MBB , I , Mips :: PseudoMFHI64 , Mips :: PseudoMFLO64 , 8 ) ; break ; case Mips :: BuildPairF64 : if ( expandBuildPairF64 ( MBB , I , false ) ) MBB . erase ( I ) ; return false ; case Mips :: BuildPairF64_64 : if ( expandBuildPairF64 ( MBB , I , true ) ) MBB . erase ( I ) ; return false ; case Mips :: ExtractElementF64 : if ( expandExtractElementF64 ( MBB , I , false ) ) MBB . erase ( I ) ; return false ; case Mips :: ExtractElementF64_64 : if ( expandExtractElementF64 ( MBB , I , true ) ) MBB . erase ( I ) ; return false ; case TargetOpcode :: COPY : if ( ! expandCopy ( MBB , I ) ) return false ; break ; default : return false ; } MBB . erase ( I ) ; return true ; } void ExpandPseudo :: expandLoadCCond ( MachineBasicBlock & MBB , Iter I ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( 4 ) ; unsigned VR = MRI . createVirtualRegister ( RC ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; TII . loadRegFromStack ( MBB , I , VR , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , I -> getDebugLoc ( ) , TII . get ( TargetOpcode :: COPY ) , Dst ) . addReg ( VR , RegState :: Kill ) ; } void ExpandPseudo :: expandStoreCCond ( MachineBasicBlock & MBB , Iter I ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( 4 ) ; unsigned VR = MRI . createVirtualRegister ( RC ) ; unsigned Src = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; BuildMI ( MBB , I , I -> getDebugLoc ( ) , TII . get ( TargetOpcode :: COPY ) , VR ) . addReg ( Src , getKillRegState ( I -> getOperand ( 0 ) . isKill ( ) ) ) ; TII . storeRegToStack ( MBB , I , VR , true , FI , RC , & RegInfo , 0 ) ; } void ExpandPseudo :: expandLoadACC ( MachineBasicBlock & MBB , Iter I , unsigned RegSize ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( RegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; unsigned Lo = RegInfo . getSubReg ( Dst , Mips :: sub_lo ) ; unsigned Hi = RegInfo . getSubReg ( Dst , Mips :: sub_hi ) ; DebugLoc DL = I -> getDebugLoc ( ) ; const MCInstrDesc & Desc = TII . get ( TargetOpcode :: COPY ) ; TII . loadRegFromStack ( MBB , I , VR0 , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , DL , Desc , Lo ) . addReg ( VR0 , RegState :: Kill ) ; TII . loadRegFromStack ( MBB , I , VR1 , FI , RC , & RegInfo , RegSize ) ; BuildMI ( MBB , I , DL , Desc , Hi ) . addReg ( VR1 , RegState :: Kill ) ; } void ExpandPseudo :: expandStoreACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc , unsigned RegSize ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( RegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned Src = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; unsigned SrcKill = getKillRegState ( I -> getOperand ( 0 ) . isKill ( ) ) ; DebugLoc DL = I -> getDebugLoc ( ) ; BuildMI ( MBB , I , DL , TII . get ( MFLoOpc ) , VR0 ) . addReg ( Src ) ; TII . storeRegToStack ( MBB , I , VR0 , true , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , DL , TII . get ( MFHiOpc ) , VR1 ) . addReg ( Src , SrcKill ) ; TII . storeRegToStack ( MBB , I , VR1 , true , FI , RC , & RegInfo , RegSize ) ; } bool ExpandPseudo :: expandCopy ( MachineBasicBlock & MBB , Iter I ) { unsigned Src = I -> getOperand ( 1 ) . getReg ( ) ; std :: pair < unsigned , unsigned > Opcodes = getMFHiLoOpc ( Src ) ; if ( ! Opcodes . first ) return false ; return expandCopyACC ( MBB , I , Opcodes . first , Opcodes . second ) ; } bool ExpandPseudo :: expandCopyACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc ) { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , Src = I -> getOperand ( 1 ) . getReg ( ) ; unsigned VRegSize = RegInfo . getMinimalPhysRegClass ( Dst ) -> getSize ( ) / 2 ; const TargetRegisterClass * RC = RegInfo . intRegClass ( VRegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned SrcKill = getKillRegState ( I -> getOperand ( 1 ) . isKill ( ) ) ; unsigned DstLo = RegInfo . getSubReg ( Dst , Mips :: sub_lo ) ; unsigned DstHi = RegInfo . getSubReg ( Dst , Mips :: sub_hi ) ; DebugLoc DL = I -> getDebugLoc ( ) ; BuildMI ( MBB , I , DL , TII . get ( MFLoOpc ) , VR0 ) . addReg ( Src ) ; BuildMI ( MBB , I , DL , TII . get ( TargetOpcode :: COPY ) , DstLo ) . addReg ( VR0 , RegState :: Kill ) ; BuildMI ( MBB , I , DL , TII . get ( MFHiOpc ) , VR1 ) . addReg ( Src , SrcKill ) ; BuildMI ( MBB , I , DL , TII . get ( TargetOpcode :: COPY ) , DstHi ) . addReg ( VR1 , RegState :: Kill ) ; return true ; } bool ExpandPseudo :: expandBuildPairF64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool FP64 ) const { const TargetMachine & TM = MF . getTarget ( ) ; const MipsSubtarget & Subtarget = TM . getSubtarget < MipsSubtarget > ( ) ; if ( ( Subtarget . isABI_FPXX ( ) && ! Subtarget . hasMTHC1 ( ) ) || ( FP64 && ! Subtarget . useOddSPReg ( ) ) ) { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( TM . getInstrInfo ( ) ) ; const MipsRegisterInfo & TRI = * static_cast < const MipsRegisterInfo * > ( TM . getRegisterInfo ( ) ) ; unsigned DstReg = I -> getOperand ( 0 ) . getReg ( ) ; unsigned LoReg = I -> getOperand ( 1 ) . getReg ( ) ; unsigned HiReg = I -> getOperand ( 2 ) . getReg ( ) ; assert ( Subtarget . isGP64bit ( ) || Subtarget . hasMTHC1 ( ) || ! Subtarget . isFP64bit ( ) ) ; const TargetRegisterClass * RC = & Mips :: GPR32RegClass ; const TargetRegisterClass * RC2 = FP64 ? & Mips :: FGR64RegClass : & Mips :: AFGR64RegClass ; int FI = MF . getInfo < MipsFunctionInfo > ( ) -> getMoveF64ViaSpillFI ( RC2 ) ; TII . storeRegToStack ( MBB , I , LoReg , I -> getOperand ( 1 ) . isKill ( ) , FI , RC , & TRI , 0 ) ; TII . storeRegToStack ( MBB , I , HiReg , I -> getOperand ( 2 ) . isKill ( ) , FI , RC , & TRI , 4 ) ; TII . loadRegFromStack ( MBB , I , DstReg , FI , RC2 , & TRI , 0 ) ; return true ; } return false ; } bool ExpandPseudo :: expandExtractElementF64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool FP64 ) const { const TargetMachine & TM = MF . getTarget ( ) ; const MipsSubtarget & Subtarget = TM . getSubtarget < MipsSubtarget > ( ) ; if ( ( Subtarget . isABI_FPXX ( ) && ! Subtarget . hasMTHC1 ( ) ) || ( FP64 && ! Subtarget . useOddSPReg ( ) ) ) { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( TM . getInstrInfo ( ) ) ; const MipsRegisterInfo & TRI = * static_cast < const MipsRegisterInfo * > ( TM . getRegisterInfo ( ) ) ; unsigned DstReg = I -> getOperand ( 0 ) . getReg ( ) ; unsigned SrcReg = I -> getOperand ( 1 ) . getReg ( ) ; unsigned N = I -> getOperand ( 2 ) . getImm ( ) ; assert ( Subtarget . isGP64bit ( ) || Subtarget . hasMTHC1 ( ) || ! Subtarget . isFP64bit ( ) ) ; const TargetRegisterClass * RC = FP64 ? & Mips :: FGR64RegClass : & Mips :: AFGR64RegClass ; const TargetRegisterClass * RC2 = & Mips :: GPR32RegClass ; int FI = MF . getInfo < MipsFunctionInfo > ( ) -> getMoveF64ViaSpillFI ( RC ) ; TII . storeRegToStack ( MBB , I , SrcReg , I -> getOperand ( 1 ) . isKill ( ) , FI , RC , & TRI , 0 ) ; TII . loadRegFromStack ( MBB , I , DstReg , FI , RC2 , & TRI , N * 4 ) ; return true ; } return false ; } MipsSEFrameLowering :: MipsSEFrameLowering ( const MipsSubtarget & STI ) : MipsFrameLowering ( STI , STI . stackAlignment ( ) ) { } unsigned MipsSEFrameLowering :: ehDataReg ( unsigned I ) const { static const unsigned EhDataReg [ ] = { Mips :: A0 , Mips :: A1 , Mips :: A2 , Mips :: A3 } ; static const unsigned EhDataReg64 [ ] = { Mips :: A0_64 , Mips :: A1_64 , Mips :: A2_64 , Mips :: A3_64 } ; return STI . isABI_N64 ( ) ? EhDataReg64 [ I ] : EhDataReg [ I ] ; } void MipsSEFrameLowering :: emitPrologue ( MachineFunction & MF ) const { MachineBasicBlock & MBB = MF . front ( ) ; MachineFrameInfo * MFI = MF . getFrameInfo ( ) ; MipsFunctionInfo * MipsFI = MF . getInfo < MipsFunctionInfo > ( ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; MachineBasicBlock :: iterator MBBI = MBB . begin ( ) ; DebugLoc dl = MBBI != MBB . end ( ) ? MBBI -> getDebugLoc ( ) : DebugLoc ( ) ; unsigned SP = STI . isABI_N64 ( ) ? Mips :: SP_64 : Mips :: SP ; unsigned FP = STI . isABI_N64 ( ) ? Mips :: FP_64 : Mips :: FP ; unsigned ZERO = STI . isABI_N64 ( ) ? Mips :: ZERO_64 : Mips :: ZERO ; unsigned ADDu = STI . isABI_N64 ( ) ? Mips :: DADDu : Mips :: ADDu ; uint64_t StackSize = MFI -> getStackSize ( ) ; if ( StackSize == 0 && ! MFI -> adjustsStack ( ) ) return ; MachineModuleInfo & MMI = MF . getMMI ( ) ; const MCRegisterInfo * MRI = MMI . getContext ( ) . getRegisterInfo ( ) ; MachineLocation DstML , SrcML ; TII . adjustStackPtr ( SP , - StackSize , MBB , MBBI ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createDefCfaOffset ( nullptr , - StackSize ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; const std :: vector < CalleeSavedInfo > & CSI = MFI -> getCalleeSavedInfo ( ) ; if ( CSI . size ( ) ) { for ( unsigned i = 0 ; i < CSI . size ( ) ; ++ i ) ++ MBBI ; for ( std :: vector < CalleeSavedInfo > :: const_iterator I = CSI . begin ( ) , E = CSI . end ( ) ; I != E ; ++ I ) { int64_t Offset = MFI -> getObjectOffset ( I -> getFrameIdx ( ) ) ; unsigned Reg = I -> getReg ( ) ; if ( Mips :: AFGR64RegClass . contains ( Reg ) ) { unsigned Reg0 = MRI -> getDwarfRegNum ( RegInfo . getSubReg ( Reg , Mips :: sub_lo ) , true ) ; unsigned Reg1 = MRI -> getDwarfRegNum ( RegInfo . getSubReg ( Reg , Mips :: sub_hi ) , true ) ; if ( ! STI . isLittle ( ) ) std :: swap ( Reg0 , Reg1 ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg0 , Offset ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg1 , Offset + 4 ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } else if ( Mips :: FGR64RegClass . contains ( Reg ) ) { unsigned Reg0 = MRI -> getDwarfRegNum ( Reg , true ) ; unsigned Reg1 = MRI -> getDwarfRegNum ( Reg , true ) + 1 ; if ( ! STI . isLittle ( ) ) std :: swap ( Reg0 , Reg1 ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg0 , Offset ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg1 , Offset + 4 ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } else { unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , MRI -> getDwarfRegNum ( Reg , 1 ) , Offset ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } } } if ( MipsFI -> callsEhReturn ( ) ) { const TargetRegisterClass * RC = STI . isABI_N64 ( ) ? & Mips :: GPR64RegClass : & Mips :: GPR32RegClass ; for ( int I = 0 ; I < 4 ; ++ I ) { if ( ! MBB . isLiveIn ( ehDataReg ( I ) ) ) MBB . addLiveIn ( ehDataReg ( I ) ) ; TII . storeRegToStackSlot ( MBB , MBBI , ehDataReg ( I ) , false , MipsFI -> getEhDataRegFI ( I ) , RC , & RegInfo ) ; } for ( int I = 0 ; I < 4 ; ++ I ) { int64_t Offset = MFI -> getObjectOffset ( MipsFI -> getEhDataRegFI ( I ) ) ; unsigned Reg = MRI -> getDwarfRegNum ( ehDataReg ( I ) , true ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg , Offset ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } } if ( hasFP ( MF ) ) { BuildMI ( MBB , MBBI , dl , TII . get ( ADDu ) , FP ) . addReg ( SP ) . addReg ( ZERO ) . setMIFlag ( MachineInstr :: FrameSetup ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createDefCfaRegister ( nullptr , MRI -> getDwarfRegNum ( FP , true ) ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } } void MipsSEFrameLowering :: emitEpilogue ( MachineFunction & MF , MachineBasicBlock & MBB ) const { MachineBasicBlock :: iterator MBBI = MBB . getLastNonDebugInstr ( ) ; MachineFrameInfo * MFI = MF . getFrameInfo ( ) ; MipsFunctionInfo * MipsFI = MF . getInfo < MipsFunctionInfo > ( ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; DebugLoc dl = MBBI -> getDebugLoc ( ) ; unsigned SP = STI . isABI_N64 ( ) ? Mips :: SP_64 : Mips :: SP ; unsigned FP = STI . isABI_N64 ( ) ? Mips :: FP_64 : Mips :: FP ; unsigned ZERO = STI . isABI_N64 ( ) ? Mips :: ZERO_64 : Mips :: ZERO ; unsigned ADDu = STI . isABI_N64 ( ) ? Mips :: DADDu : Mips :: ADDu ; if ( hasFP ( MF ) ) { MachineBasicBlock :: iterator I = MBBI ; for ( unsigned i = 0 ; i < MFI -> getCalleeSavedInfo ( ) . size ( ) ; ++ i ) -- I ; BuildMI ( MBB , I , dl , TII . get ( ADDu ) , SP ) . addReg ( FP ) . addReg ( ZERO ) ; } if ( MipsFI -> callsEhReturn ( ) ) { const TargetRegisterClass * RC = STI . isABI_N64 ( ) ? & Mips :: GPR64RegClass : & Mips :: GPR32RegClass ; MachineBasicBlock :: iterator I = MBBI ; for ( unsigned i = 0 ; i < MFI -> getCalleeSavedInfo ( ) . size ( ) ; ++ i ) -- I ; for ( int J = 0 ; J < 4 ; ++ J ) { TII . loadRegFromStackSlot ( MBB , I , ehDataReg ( J ) , MipsFI -> getEhDataRegFI ( J ) , RC , & RegInfo ) ; } } uint64_t StackSize = MFI -> getStackSize ( ) ; if ( ! StackSize ) return ; TII . adjustStackPtr ( SP , StackSize , MBB , MBBI ) ; } bool MipsSEFrameLowering :: spillCalleeSavedRegisters ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator MI , const std :: vector < CalleeSavedInfo > & CSI , const TargetRegisterInfo * TRI ) const { MachineFunction * MF = MBB . getParent ( ) ; MachineBasicBlock * EntryBlock = MF -> begin ( ) ; const TargetInstrInfo & TII = * MF -> getTarget ( ) . getInstrInfo ( ) ; for ( unsigned i = 0 , e = CSI . size ( ) ; i != e ; ++ i ) { unsigned Reg = CSI [ i ] . getReg ( ) ; bool IsRAAndRetAddrIsTaken = ( Reg == Mips :: RA || Reg == Mips :: RA_64 ) && MF -> getFrameInfo ( ) -> isReturnAddressTaken ( ) ; if ( ! IsRAAndRetAddrIsTaken ) EntryBlock -> addLiveIn ( Reg ) ; bool IsKill = ! IsRAAndRetAddrIsTaken ; const TargetRegisterClass * RC = TRI -> getMinimalPhysRegClass ( Reg ) ; TII . storeRegToStackSlot ( * EntryBlock , MI , Reg , IsKill , CSI [ i ] . getFrameIdx ( ) , RC , TRI ) ; } return true ; } bool MipsSEFrameLowering :: hasReservedCallFrame ( const MachineFunction & MF ) const { const MachineFrameInfo * MFI = MF . getFrameInfo ( ) ; return isInt < 16 > ( MFI -> getMaxCallFrameSize ( ) + getStackAlignment ( ) ) && ! MFI -> hasVarSizedObjects ( ) ; } void MipsSEFrameLowering :: eliminateCallFramePseudoInstr ( MachineFunction & MF , MachineBasicBlock & MBB , MachineBasicBlock :: iterator I ) const { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; if ( ! hasReservedCallFrame ( MF ) ) { int64_t Amount = I -> getOperand ( 0 ) . getImm ( ) ; if ( I -> getOpcode ( ) == Mips :: ADJCALLSTACKDOWN ) Amount = - Amount ; unsigned SP = STI . isABI_N64 ( ) ? Mips :: SP_64 : Mips :: SP ; TII . adjustStackPtr ( SP , Amount , MBB , I ) ; } MBB . erase ( I ) ; } void MipsSEFrameLowering :: processFunctionBeforeCalleeSavedScan ( MachineFunction & MF , RegScavenger * RS ) const { MachineRegisterInfo & MRI = MF . getRegInfo ( ) ; MipsFunctionInfo * MipsFI = MF . getInfo < MipsFunctionInfo > ( ) ; unsigned FP = STI . isABI_N64 ( ) ? Mips :: FP_64 : Mips :: FP ; if ( hasFP ( MF ) ) MRI . setPhysRegUsed ( FP ) ; if ( MipsFI -> callsEhReturn ( ) ) MipsFI -> createEhDataRegsFI ( ) ; if ( ExpandPseudo ( MF ) . expand ( ) ) { const TargetRegisterClass * RC = STI . hasMips64 ( ) ? & Mips :: GPR64RegClass : & Mips :: GPR32RegClass ; int FI = MF . getFrameInfo ( ) -> CreateStackObject ( RC -> getSize ( ) , RC -> getAlignment ( ) , false ) ; RS -> addScavengingFrameIndex ( FI ) ; } uint64_t MaxSPOffset = MF . getInfo < MipsFunctionInfo > ( ) -> getIncomingArgSize ( ) + estimateStackSize ( MF ) ; if ( isInt < 16 > ( MaxSPOffset ) ) return ; const TargetRegisterClass * RC = STI . isABI_N64 ( ) ? & Mips :: GPR64RegClass : & Mips :: GPR32RegClass ; int FI = MF . getFrameInfo ( ) -> CreateStackObject ( RC -> getSize ( ) , RC -> getAlignment ( ) , false ) ; RS -> addScavengingFrameIndex ( FI ) ; } const MipsFrameLowering * llvm :: createMipsSEFrameLowering ( const MipsSubtarget & ST ) { return new MipsSEFrameLowering ( ST ) ; } </DOCUMENT>
<DOCUMENT_ID="waddlesplash/DolphinQt/tree/master/Externals/wxWidgets3/src/osx/carbon/textctrl.cpp"> # include " wx / wxprec . h " # if wxUSE_TEXTCTRL # include " wx / textctrl . h " # ifndef WX_PRECOMP # include " wx / intl . h " # include " wx / app . h " # include " wx / utils . h " # include " wx / dc . h " # include " wx / button . h " # include " wx / menu . h " # include " wx / settings . h " # include " wx / msgdlg . h " # include " wx / toplevel . h " # endif # ifdef __DARWIN__ # include < sys / types . h > # include < sys / stat . h > # else # include < stat . h > # endif # if wxUSE_STD_IOSTREAM # if wxUSE_IOSTREAMH # include < fstream . h > # else # include < fstream > # endif # endif # include " wx / filefn . h " # include " wx / sysopt . h " # include " wx / thread . h " # include " wx / osx / private . h " # include " wx / osx / carbon / private / mactext . h " class wxMacFunctor { public : wxMacFunctor ( ) { } virtual ~ wxMacFunctor ( ) { } virtual void * operator ( ) ( ) = 0 ; static void * CallBackProc ( void * param ) { wxMacFunctor * f = ( wxMacFunctor * ) param ; void * result = ( * f ) ( ) ; return result ; } } ; template < typename classtype , typename param1type > class wxMacObjectFunctor1 : public wxMacFunctor { typedef void ( classtype :: * function ) ( param1type p1 ) ; typedef void ( classtype :: * ref_function ) ( const param1type & p1 ) ; public : wxMacObjectFunctor1 ( classtype * obj , function f , param1type p1 ) : wxMacFunctor ( ) { m_object = obj ; m_function = f ; m_param1 = p1 ; } wxMacObjectFunctor1 ( classtype * obj , ref_function f , param1type p1 ) : wxMacFunctor ( ) { m_object = obj ; m_refFunction = f ; m_param1 = p1 ; } virtual ~ wxMacObjectFunctor1 ( ) { } virtual void * operator ( ) ( ) { ( m_object ->* m_function ) ( m_param1 ) ; return NULL ; } private : classtype * m_object ; param1type m_param1 ; union { function m_function ; ref_function m_refFunction ; } ; } ; template < typename classtype , typename param1type > void * wxMacMPRemoteCall ( classtype * object , void ( classtype :: * function ) ( param1type p1 ) , param1type p1 ) { wxMacObjectFunctor1 < classtype , param1type > params ( object , function , p1 ) ; void * result = MPRemoteCall ( wxMacFunctor :: CallBackProc , & params , kMPOwningProcessRemoteContext ) ; return result ; } template < typename classtype , typename param1type > void * wxMacMPRemoteCall ( classtype * object , void ( classtype :: * function ) ( const param1type & p1 ) , param1type p1 ) { wxMacObjectFunctor1 < classtype , param1type > params ( object , function , p1 ) ; void * result = MPRemoteCall ( wxMacFunctor :: CallBackProc , & params , kMPOwningProcessRemoteContext ) ; return result ; } template < typename classtype , typename param1type > void * wxMacMPRemoteGUICall ( classtype * object , void ( classtype :: * function ) ( param1type p1 ) , param1type p1 ) { wxMutexGuiLeave ( ) ; void * result = wxMacMPRemoteCall ( object , function , p1 ) ; wxMutexGuiEnter ( ) ; return result ; } template < typename classtype , typename param1type > void * wxMacMPRemoteGUICall ( classtype * object , void ( classtype :: * function ) ( const param1type & p1 ) , param1type p1 ) { wxMutexGuiLeave ( ) ; void * result = wxMacMPRemoteCall ( object , function , p1 ) ; wxMutexGuiEnter ( ) ; return result ; } class WXDLLEXPORT wxMacPortSaver { wxDECLARE_NO_COPY_CLASS ( wxMacPortSaver ) ; public : wxMacPortSaver ( GrafPtr port ) ; ~ wxMacPortSaver ( ) ; private : GrafPtr m_port ; } ; class WXDLLEXPORT wxMacWindowClipper : public wxMacPortSaver { wxDECLARE_NO_COPY_CLASS ( wxMacWindowClipper ) ; public : wxMacWindowClipper ( const wxWindow * win ) ; ~ wxMacWindowClipper ( ) ; private : GrafPtr m_newPort ; RgnHandle m_formerClip ; RgnHandle m_newClip ; } ; wxMacPortSaver :: wxMacPortSaver ( GrafPtr port ) { :: GetPort ( & m_port ) ; :: SetPort ( port ) ; } wxMacPortSaver :: ~ wxMacPortSaver ( ) { :: SetPort ( m_port ) ; } wxMacWindowClipper :: wxMacWindowClipper ( const wxWindow * win ) : wxMacPortSaver ( ( GrafPtr ) GetWindowPort ( ( WindowRef ) win -> MacGetTopLevelWindowRef ( ) ) ) { m_newPort = ( GrafPtr ) GetWindowPort ( ( WindowRef ) win -> MacGetTopLevelWindowRef ( ) ) ; m_formerClip = NewRgn ( ) ; m_newClip = NewRgn ( ) ; GetClip ( m_formerClip ) ; if ( win ) { if ( win -> GetPeer ( ) ) { int x = 0 , y = 0 ; win -> MacWindowToRootWindow ( & x , & y ) ; HIShapeGetAsQDRgn ( ( ( wxWindow * ) win ) -> MacGetVisibleRegion ( true ) . GetWXHRGN ( ) , m_newClip ) ; if ( ! EmptyRgn ( m_newClip ) ) OffsetRgn ( m_newClip , x , y ) ; } SetClip ( m_newClip ) ; } } wxMacWindowClipper :: ~ wxMacWindowClipper ( ) { SetPort ( m_newPort ) ; SetClip ( m_formerClip ) ; DisposeRgn ( m_newClip ) ; DisposeRgn ( m_formerClip ) ; } class wxMacMLTEControl : public wxMacControl , public wxTextWidgetImpl { public : wxMacMLTEControl ( wxTextCtrl * peer ) ; ~ wxMacMLTEControl ( ) { } virtual bool CanFocus ( ) const { return true ; } virtual wxString GetStringValue ( ) const ; virtual void SetStringValue ( const wxString & str ) ; static TXNFrameOptions FrameOptionsFromWXStyle ( long wxStyle ) ; void AdjustCreationAttributes ( const wxColour & background , bool visible ) ; virtual void SetFont ( const wxFont & font , const wxColour & foreground , long windowStyle , bool ignoreBlack ) ; virtual void SetBackgroundColour ( const wxColour & col ) ; virtual void SetStyle ( long start , long end , const wxTextAttr & style ) ; virtual void Copy ( ) ; virtual void Cut ( ) ; virtual void Paste ( ) ; virtual bool CanPaste ( ) const ; virtual void SetEditable ( bool editable ) ; virtual long GetLastPosition ( ) const ; virtual void Replace ( long from , long to , const wxString & str ) ; virtual void Remove ( long from , long to ) ; virtual void GetSelection ( long * from , long * to ) const ; virtual void SetSelection ( long from , long to ) ; virtual void WriteText ( const wxString & str ) ; virtual bool HasOwnContextMenu ( ) const { TXNCommandEventSupportOptions options ; TXNGetCommandEventSupport ( m_txn , & options ) ; return options & kTXNSupportEditCommandProcessing ; } virtual void CheckSpelling ( bool check ) { TXNSetSpellCheckAsYouType ( m_txn , ( Boolean ) check ) ; } virtual void Clear ( ) ; virtual bool CanUndo ( ) const ; virtual void Undo ( ) ; virtual bool CanRedo ( ) const ; virtual void Redo ( ) ; virtual int GetNumberOfLines ( ) const ; virtual long XYToPosition ( long x , long y ) const ; virtual bool PositionToXY ( long pos , long * x , long * y ) const ; virtual void ShowPosition ( long pos ) ; virtual int GetLineLength ( long lineNo ) const ; virtual wxString GetLineText ( long lineNo ) const ; void SetTXNData ( const wxString & st , TXNOffset start , TXNOffset end ) ; TXNObject GetTXNObject ( ) { return m_txn ; } protected : void TXNSetAttribute ( const wxTextAttr & style , long from , long to ) ; TXNObject m_txn ; } ; class wxMacMLTEHIViewControl : public wxMacMLTEControl { public : wxMacMLTEHIViewControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) ; virtual ~ wxMacMLTEHIViewControl ( ) ; virtual bool SetFocus ( ) ; virtual bool HasFocus ( ) const ; virtual void SetBackgroundColour ( const wxColour & col ) ; protected : HIViewRef m_scrollView ; HIViewRef m_textView ; } ; class wxMacMLTEClassicControl : public wxMacMLTEControl { public : wxMacMLTEClassicControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) ; virtual ~ wxMacMLTEClassicControl ( ) ; virtual void VisibilityChanged ( bool shown ) ; virtual void SuperChangedPosition ( ) ; virtual void MacControlUserPaneDrawProc ( wxInt16 part ) ; virtual wxInt16 MacControlUserPaneHitTestProc ( wxInt16 x , wxInt16 y ) ; virtual wxInt16 MacControlUserPaneTrackingProc ( wxInt16 x , wxInt16 y , void * actionProc ) ; virtual void MacControlUserPaneIdleProc ( ) ; virtual wxInt16 MacControlUserPaneKeyDownProc ( wxInt16 keyCode , wxInt16 charCode , wxInt16 modifiers ) ; virtual void MacControlUserPaneActivateProc ( bool activating ) ; virtual wxInt16 MacControlUserPaneFocusProc ( wxInt16 action ) ; virtual void MacControlUserPaneBackgroundProc ( void * info ) ; virtual bool SetupCursor ( const wxPoint & WXUNUSED ( pt ) ) { MacControlUserPaneIdleProc ( ) ; return true ; } virtual void Move ( int x , int y , int width , int height ) ; protected : OSStatus DoCreate ( ) ; void MacUpdatePosition ( ) ; void MacActivatePaneText ( bool setActive ) ; void MacFocusPaneText ( bool setFocus ) ; void MacSetObjectVisibility ( bool vis ) ; private : TXNFrameID m_txnFrameID ; GrafPtr m_txnPort ; WindowRef m_txnWindow ; Rect m_txnControlBounds ; Rect m_txnVisBounds ; static pascal void TXNScrollActionProc ( ControlRef controlRef , ControlPartCode partCode ) ; static pascal void TXNScrollInfoProc ( SInt32 iValue , SInt32 iMaximumValue , TXNScrollBarOrientation iScrollBarOrientation , SInt32 iRefCon ) ; ControlRef m_sbHorizontal ; SInt32 m_lastHorizontalValue ; ControlRef m_sbVertical ; SInt32 m_lastVerticalValue ; } ; wxWidgetImplType * wxWidgetImpl :: CreateTextControl ( wxTextCtrl * wxpeer , wxWindowMac * WXUNUSED ( parent ) , wxWindowID WXUNUSED ( id ) , const wxString & str , const wxPoint & pos , const wxSize & size , long style , long WXUNUSED ( extraStyle ) ) { return new wxMacMLTEHIViewControl ( wxpeer , str , pos , size , style ) ; } static const EventTypeSpec unicodeTextControlEventList [ ] = { { kEventClassControl , kEventControlSetFocusPart } , } ; static pascal OSStatus wxMacUnicodeTextControlControlEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; wxMacUnicodeTextControl * focus = ( wxMacUnicodeTextControl * ) data ; wxMacCarbonEvent cEvent ( event ) ; switch ( GetEventKind ( event ) ) { case kEventControlSetFocusPart : { ControlPartCode controlPart = cEvent . GetParameter < ControlPartCode > ( kEventParamControlPart , typeControlPartCode ) ; if ( controlPart == kControlFocusNoPart ) { focus -> GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & focus -> m_selection ) ; } result = CallNextEventHandler ( handler , event ) ; if ( controlPart != kControlFocusNoPart ) { focus -> SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & focus -> m_selection ) ; } break ; } default : break ; } return result ; } static pascal OSStatus wxMacUnicodeTextControlEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; switch ( GetEventClass ( event ) ) { case kEventClassControl : result = wxMacUnicodeTextControlControlEventHandler ( handler , event , data ) ; break ; default : break ; } return result ; } DEFINE_ONE_SHOT_HANDLER_GETTER ( wxMacUnicodeTextControlEventHandler ) wxMacUnicodeTextControl :: wxMacUnicodeTextControl ( wxTextCtrl * wxPeer ) : wxMacControl ( wxPeer ) , wxTextWidgetImpl ( wxPeer ) { } wxMacUnicodeTextControl :: wxMacUnicodeTextControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) : wxMacControl ( wxPeer ) , wxTextWidgetImpl ( wxPeer ) { m_font = wxPeer -> GetFont ( ) ; m_windowStyle = style ; m_selection . selStart = m_selection . selEnd = 0 ; Rect bounds = wxMacGetBoundsForControl ( wxPeer , pos , size ) ; wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; m_valueTag = kControlEditTextCFStringTag ; Boolean isPassword = ( m_windowStyle & wxTE_PASSWORD ) != 0 ; if ( isPassword ) { m_valueTag = kControlEditTextPasswordCFStringTag ; } OSStatus err = CreateEditUnicodeTextControl ( MAC_WXHWND ( wxPeer -> MacGetTopLevelWindowRef ( ) ) , & bounds , cf , isPassword , NULL , & m_controlRef ) ; verify_noerr ( err ) ; if ( ! ( m_windowStyle & wxTE_MULTILINE ) ) SetData < Boolean > ( kControlEditTextPart , kControlEditTextSingleLineTag , true ) ; InstallEventHandlers ( ) ; } void wxMacUnicodeTextControl :: InstallEventHandlers ( ) { :: InstallControlEventHandler ( m_controlRef , GetwxMacUnicodeTextControlEventHandlerUPP ( ) , GetEventTypeCount ( unicodeTextControlEventList ) , unicodeTextControlEventList , this , ( EventHandlerRef * ) & m_macTextCtrlEventHandler ) ; } wxMacUnicodeTextControl :: ~ wxMacUnicodeTextControl ( ) { :: RemoveEventHandler ( ( EventHandlerRef ) m_macTextCtrlEventHandler ) ; } void wxMacUnicodeTextControl :: VisibilityChanged ( bool shown ) { if ( ! ( m_windowStyle & wxTE_MULTILINE ) && shown ) { ControlEditTextSelectionRec sel ; CFStringRef value = NULL ; verify_noerr ( GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; verify_noerr ( GetData < CFStringRef > ( 0 , m_valueTag , & value ) ) ; verify_noerr ( SetData < CFStringRef > ( 0 , m_valueTag , & value ) ) ; verify_noerr ( SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; CFRelease ( value ) ; } } wxString wxMacUnicodeTextControl :: GetStringValue ( ) const { wxString result ; CFStringRef value = GetData < CFStringRef > ( 0 , m_valueTag ) ; if ( value ) { wxCFStringRef cf ( value ) ; result = cf . AsString ( ) ; } # if ' \n ' == 10 wxMacConvertNewlines13To10 ( & result ) ; # else wxMacConvertNewlines10To13 ( & result ) ; # endif return result ; } void wxMacUnicodeTextControl :: SetStringValue ( const wxString & str ) { wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; verify_noerr ( SetData < CFStringRef > ( 0 , m_valueTag , cf ) ) ; } void wxMacUnicodeTextControl :: Copy ( ) { SendHICommand ( kHICommandCopy ) ; } void wxMacUnicodeTextControl :: Cut ( ) { SendHICommand ( kHICommandCut ) ; } void wxMacUnicodeTextControl :: Paste ( ) { SendHICommand ( kHICommandPaste ) ; } bool wxMacUnicodeTextControl :: CanPaste ( ) const { return true ; } void wxMacUnicodeTextControl :: SetEditable ( bool WXUNUSED ( editable ) ) { # if 0 SetData < Boolean > ( kControlEditTextPart , kControlEditTextLockedTag , ( Boolean ) ! editable ) ; # endif } void wxMacUnicodeTextControl :: GetSelection ( long * from , long * to ) const { ControlEditTextSelectionRec sel ; if ( HasFocus ( ) ) verify_noerr ( GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; else sel = m_selection ; if ( from ) * from = sel . selStart ; if ( to ) * to = sel . selEnd ; } void wxMacUnicodeTextControl :: SetSelection ( long from , long to ) { ControlEditTextSelectionRec sel ; wxString result ; int textLength = 0 ; CFStringRef value = GetData < CFStringRef > ( 0 , m_valueTag ) ; if ( value ) { wxCFStringRef cf ( value ) ; textLength = cf . AsString ( ) . length ( ) ; } if ( ( from == - 1 ) && ( to == - 1 ) ) { from = 0 ; to = textLength ; } else { from = wxMin ( textLength , wxMax ( from , 0 ) ) ; if ( to == - 1 ) to = textLength ; else to = wxMax ( 0 , wxMin ( textLength , to ) ) ; } sel . selStart = from ; sel . selEnd = to ; if ( HasFocus ( ) ) SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ; else m_selection = sel ; } void wxMacUnicodeTextControl :: WriteText ( const wxString & str ) { if ( ! wxIsMainThread ( ) ) { # if wxOSX_USE_CARBON wxMacMPRemoteGUICall < wxTextCtrl , wxString > ( ( wxTextCtrl * ) GetWXPeer ( ) , & wxTextCtrl :: WriteText , str ) ; # endif return ; } wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; if ( HasFocus ( ) ) { wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; CFStringRef value = cf ; SetData < CFStringRef > ( 0 , kControlEditTextInsertCFStringRefTag , & value ) ; } else { wxString val = GetStringValue ( ) ; long start , end ; GetSelection ( & start , & end ) ; val . Remove ( start , end - start ) ; val . insert ( start , str ) ; SetStringValue ( val ) ; SetSelection ( start + str . length ( ) , start + str . length ( ) ) ; } } class wxMacEditHelper { public : wxMacEditHelper ( TXNObject txn ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; m_txn = txn ; TXNGetTXNObjectControls ( m_txn , 1 , tag , m_data ) ; if ( m_data [ 0 ] . uValue == kTXNReadOnly ) { TXNControlData data [ ] = { { kTXNReadWrite } } ; TXNSetTXNObjectControls ( m_txn , false , 1 , tag , data ) ; } } ~ wxMacEditHelper ( ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; if ( m_data [ 0 ] . uValue == kTXNReadOnly ) TXNSetTXNObjectControls ( m_txn , false , 1 , tag , m_data ) ; } protected : TXNObject m_txn ; TXNControlData m_data [ 1 ] ; } ; wxMacMLTEControl :: wxMacMLTEControl ( wxTextCtrl * peer ) : wxMacControl ( peer ) , wxTextWidgetImpl ( peer ) { SetNeedsFocusRect ( true ) ; } wxString wxMacMLTEControl :: GetStringValue ( ) const { wxString result ; OSStatus err ; Size actualSize = 0 ; { # if wxUSE_UNICODE Handle theText ; err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNUnicodeTextData ) ; if ( err != noErr ) { actualSize = 0 ; } else { actualSize = GetHandleSize ( theText ) / sizeof ( UniChar ) ; if ( actualSize > 0 ) { wxChar * ptr = NULL ; SetHandleSize ( theText , ( actualSize + 1 ) * sizeof ( UniChar ) ) ; HLock ( theText ) ; ( ( ( UniChar * ) * theText ) [ actualSize ] ) = 0 ; wxMBConvUTF16 converter ; size_t noChars = converter . MB2WC ( NULL , ( const char * ) * theText , 0 ) ; wxASSERT_MSG ( noChars != wxCONV_FAILED , wxT ( " Unable ▁ to ▁ count ▁ the ▁ number ▁ of ▁ characters ▁ in ▁ this ▁ string ! " ) ) ; ptr = new wxChar [ noChars + 1 ] ; noChars = converter . MB2WC ( ptr , ( const char * ) * theText , noChars + 1 ) ; wxASSERT_MSG ( noChars != wxCONV_FAILED , wxT ( " Conversion ▁ of ▁ string ▁ failed ! " ) ) ; ptr [ noChars ] = 0 ; HUnlock ( theText ) ; ptr [ actualSize ] = 0 ; result = wxString ( ptr ) ; delete [ ] ptr ; } DisposeHandle ( theText ) ; } # else Handle theText ; err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNTextData ) ; if ( err != noErr ) { actualSize = 0 ; } else { actualSize = GetHandleSize ( theText ) ; if ( actualSize > 0 ) { HLock ( theText ) ; result = wxString ( * theText , wxConvLocal , actualSize ) ; HUnlock ( theText ) ; } DisposeHandle ( theText ) ; } # endif } # if ' \n ' == 10 wxMacConvertNewlines13To10 ( & result ) ; # else wxMacConvertNewlines10To13 ( & result ) ; # endif return result ; } void wxMacMLTEControl :: SetStringValue ( const wxString & str ) { wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif { wxMacEditHelper help ( m_txn ) ; SetTXNData ( st , kTXNStartOffset , kTXNEndOffset ) ; } TXNSetSelection ( m_txn , 0 , 0 ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; } } TXNFrameOptions wxMacMLTEControl :: FrameOptionsFromWXStyle ( long wxStyle ) { TXNFrameOptions frameOptions = kTXNDontDrawCaretWhenInactiveMask ; frameOptions |= kTXNDoFontSubstitutionMask ; if ( ! ( wxStyle & wxTE_NOHIDESEL ) ) frameOptions |= kTXNDontDrawSelectionWhenInactiveMask ; if ( wxStyle & ( wxHSCROLL | wxTE_DONTWRAP ) ) frameOptions |= kTXNWantHScrollBarMask ; if ( wxStyle & wxTE_MULTILINE ) { if ( ! ( wxStyle & wxTE_DONTWRAP ) ) frameOptions |= kTXNAlwaysWrapAtViewEdgeMask ; if ( ! ( wxStyle & wxTE_NO_VSCROLL ) ) { frameOptions |= kTXNWantVScrollBarMask ; } } else { frameOptions |= kTXNSingleLineOnlyMask ; } return frameOptions ; } void wxMacMLTEControl :: AdjustCreationAttributes ( const wxColour & background , bool WXUNUSED ( visible ) ) { TXNControlTag iControlTags [ ] = { kTXNDoFontSubstitution , kTXNWordWrapStateTag , } ; TXNControlData iControlData [ ] = { { true } , { kTXNNoAutoWrap } , } ; int toptag = WXSIZEOF ( iControlTags ) ; if ( m_windowStyle & wxTE_MULTILINE ) { iControlData [ 1 ] . uValue = ( m_windowStyle & wxTE_DONTWRAP ) ? kTXNNoAutoWrap : kTXNAutoWrap ; } OSStatus err = TXNSetTXNObjectControls ( m_txn , false , toptag , iControlTags , iControlData ) ; verify_noerr ( err ) ; Str255 fontName ; SInt16 fontSize ; Style fontStyle ; GetThemeFont ( kThemeSystemFont , GetApplicationScript ( ) , fontName , & fontSize , & fontStyle ) ; TXNTypeAttributes typeAttr [ ] = { { kTXNQDFontNameAttribute , kTXNQDFontNameAttributeSize , { ( void * ) fontName } } , { kTXNQDFontSizeAttribute , kTXNFontSizeAttributeSize , { ( void * ) ( fontSize << 16 ) } } , { kTXNQDFontStyleAttribute , kTXNQDFontStyleAttributeSize , { ( void * ) normal } } , } ; err = TXNSetTypeAttributes ( m_txn , WXSIZEOF ( typeAttr ) , typeAttr , kTXNStartOffset , kTXNEndOffset ) ; verify_noerr ( err ) ; if ( m_windowStyle & wxTE_PASSWORD ) { UniChar c = 0x00A5 ; err = TXNEchoMode ( m_txn , c , 0 , true ) ; verify_noerr ( err ) ; } TXNBackground tback ; tback . bgType = kTXNBackgroundTypeRGB ; background . GetRGBColor ( & tback . bg . color ) ; TXNSetBackground ( m_txn , & tback ) ; TXNCommandEventSupportOptions options ; if ( TXNGetCommandEventSupport ( m_txn , & options ) == noErr ) { options |= kTXNSupportEditCommandProcessing | kTXNSupportEditCommandUpdating | kTXNSupportFontCommandProcessing | kTXNSupportFontCommandUpdating ; bool checkSpelling = false ; if ( ! ( m_windowStyle & wxTE_READONLY ) ) { # if wxUSE_SYSTEM_OPTIONS if ( wxSystemOptions :: HasOption ( wxMAC_TEXTCONTROL_USE_SPELL_CHECKER ) && ( wxSystemOptions :: GetOptionInt ( wxMAC_TEXTCONTROL_USE_SPELL_CHECKER ) == 1 ) ) { checkSpelling = true ; } # endif } if ( checkSpelling ) options |= kTXNSupportSpellCheckCommandProcessing | kTXNSupportSpellCheckCommandUpdating ; TXNSetCommandEventSupport ( m_txn , options ) ; } } void wxMacMLTEControl :: SetBackgroundColour ( const wxColour & col ) { TXNBackground tback ; tback . bgType = kTXNBackgroundTypeRGB ; col . GetRGBColor ( & tback . bg . color ) ; TXNSetBackground ( m_txn , & tback ) ; } static inline int wxConvertToTXN ( int x ) { return static_cast < int > ( x / 254.0 * 72 + 0.5 ) ; } void wxMacMLTEControl :: TXNSetAttribute ( const wxTextAttr & style , long from , long to ) { TXNTypeAttributes typeAttr [ 4 ] ; RGBColor color ; size_t typeAttrCount = 0 ; TXNMargins margins ; TXNControlTag controlTags [ 4 ] ; TXNControlData controlData [ 4 ] ; size_t controlAttrCount = 0 ; TXNTab * tabs = NULL ; bool relayout = false ; wxFont font ; if ( style . HasFont ( ) ) { wxASSERT ( typeAttrCount < WXSIZEOF ( typeAttr ) ) ; font = style . GetFont ( ) ; typeAttr [ typeAttrCount ] . tag = kTXNATSUIStyle ; typeAttr [ typeAttrCount ] . size = kTXNATSUIStyleSize ; typeAttr [ typeAttrCount ] . data . dataPtr = font . MacGetATSUStyle ( ) ; typeAttrCount ++ ; } if ( style . HasTextColour ( ) ) { wxASSERT ( typeAttrCount < WXSIZEOF ( typeAttr ) ) ; style . GetTextColour ( ) . GetRGBColor ( & color ) ; typeAttr [ typeAttrCount ] . tag = kTXNQDFontColorAttribute ; typeAttr [ typeAttrCount ] . size = kTXNQDFontColorAttributeSize ; typeAttr [ typeAttrCount ] . data . dataPtr = ( void * ) & color ; typeAttrCount ++ ; } if ( style . HasAlignment ( ) ) { wxASSERT ( controlAttrCount < WXSIZEOF ( controlTags ) ) ; SInt32 align ; switch ( style . GetAlignment ( ) ) { case wxTEXT_ALIGNMENT_LEFT : align = kTXNFlushLeft ; break ; case wxTEXT_ALIGNMENT_CENTRE : align = kTXNCenter ; break ; case wxTEXT_ALIGNMENT_RIGHT : align = kTXNFlushRight ; break ; case wxTEXT_ALIGNMENT_JUSTIFIED : align = kTXNFullJust ; break ; default : case wxTEXT_ALIGNMENT_DEFAULT : align = kTXNFlushDefault ; break ; } controlTags [ controlAttrCount ] = kTXNJustificationTag ; controlData [ controlAttrCount ] . sValue = align ; controlAttrCount ++ ; } if ( style . HasLeftIndent ( ) || style . HasRightIndent ( ) ) { wxASSERT ( controlAttrCount < WXSIZEOF ( controlTags ) ) ; controlTags [ controlAttrCount ] = kTXNMarginsTag ; controlData [ controlAttrCount ] . marginsPtr = & margins ; verify_noerr ( TXNGetTXNObjectControls ( m_txn , 1 , & controlTags [ controlAttrCount ] , & controlData [ controlAttrCount ] ) ) ; if ( style . HasLeftIndent ( ) ) { margins . leftMargin = wxConvertToTXN ( style . GetLeftIndent ( ) ) ; } if ( style . HasRightIndent ( ) ) { margins . rightMargin = wxConvertToTXN ( style . GetRightIndent ( ) ) ; } controlAttrCount ++ ; } if ( style . HasTabs ( ) ) { const wxArrayInt & tabarray = style . GetTabs ( ) ; controlTags [ controlAttrCount ] = kTXNTabSettingsTag ; if ( tabarray . size ( ) > 0 ) controlData [ controlAttrCount ] . tabValue . value = wxConvertToTXN ( tabarray [ 0 ] ) ; else controlData [ controlAttrCount ] . tabValue . value = 72 ; controlData [ controlAttrCount ] . tabValue . tabType = kTXNLeftTab ; controlAttrCount ++ ; } if ( controlAttrCount > 0 ) { verify_noerr ( TXNSetTXNObjectControls ( m_txn , false , controlAttrCount , controlTags , controlData ) ) ; relayout = true ; } if ( typeAttrCount > 0 ) { verify_noerr ( TXNSetTypeAttributes ( m_txn , typeAttrCount , typeAttr , from , to ) ) ; if ( from != to ) relayout = true ; } if ( tabs != NULL ) { delete [ ] tabs ; } if ( relayout ) { TXNRecalcTextLayout ( m_txn ) ; } } void wxMacMLTEControl :: SetFont ( const wxFont & font , const wxColour & foreground , long WXUNUSED ( windowStyle ) , bool WXUNUSED ( ignoreBlack ) ) { wxMacEditHelper help ( m_txn ) ; TXNSetAttribute ( wxTextAttr ( foreground , wxNullColour , font ) , kTXNStartOffset , kTXNEndOffset ) ; } void wxMacMLTEControl :: SetStyle ( long start , long end , const wxTextAttr & style ) { wxMacEditHelper help ( m_txn ) ; TXNSetAttribute ( style , start , end ) ; } void wxMacMLTEControl :: Copy ( ) { TXNCopy ( m_txn ) ; } void wxMacMLTEControl :: Cut ( ) { TXNCut ( m_txn ) ; } void wxMacMLTEControl :: Paste ( ) { TXNPaste ( m_txn ) ; } bool wxMacMLTEControl :: CanPaste ( ) const { return TXNIsScrapPastable ( ) ; } void wxMacMLTEControl :: SetEditable ( bool editable ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; TXNControlData data [ ] = { { editable ? kTXNReadWrite : kTXNReadOnly } } ; TXNSetTXNObjectControls ( m_txn , false , WXSIZEOF ( tag ) , tag , data ) ; } long wxMacMLTEControl :: GetLastPosition ( ) const { wxTextPos actualsize = 0 ; Handle theText ; # if wxUSE_UNICODE OSErr err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNUnicodeTextData ) ; if ( err == noErr ) { actualsize = GetHandleSize ( theText ) / sizeof ( UniChar ) ; DisposeHandle ( theText ) ; } # else OSErr err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNTextData ) ; if ( err == noErr ) { actualsize = GetHandleSize ( theText ) ; DisposeHandle ( theText ) ; } # endif else { actualsize = 0 ; } return actualsize ; } void wxMacMLTEControl :: Replace ( long from , long to , const wxString & str ) { wxString value = str ; wxMacConvertNewlines10To13 ( & value ) ; wxMacEditHelper help ( m_txn ) ; # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif TXNSetSelection ( m_txn , from , to == - 1 ? kTXNEndOffset : to ) ; TXNClear ( m_txn ) ; SetTXNData ( value , kTXNUseCurrentSelection , kTXNUseCurrentSelection ) ; } void wxMacMLTEControl :: Remove ( long from , long to ) { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif wxMacEditHelper help ( m_txn ) ; TXNSetSelection ( m_txn , from , to ) ; TXNClear ( m_txn ) ; } void wxMacMLTEControl :: GetSelection ( long * from , long * to ) const { TXNOffset f , t ; TXNGetSelection ( m_txn , & f , & t ) ; * from = f ; * to = t ; } void wxMacMLTEControl :: SetSelection ( long from , long to ) { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif if ( ( from == - 1 ) && ( to == - 1 ) ) TXNSelectAll ( m_txn ) ; else TXNSetSelection ( m_txn , from , to == - 1 ? kTXNEndOffset : to ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; } void wxMacMLTEControl :: WriteText ( const wxString & str ) { if ( ! wxIsMainThread ( ) ) { # if wxOSX_USE_CARBON wxMacMPRemoteGUICall < wxTextCtrl , wxString > ( ( wxTextCtrl * ) GetWXPeer ( ) , & wxTextCtrl :: WriteText , str ) ; # endif return ; } wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; long start , end , dummy ; GetSelection ( & start , & dummy ) ; # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif { wxMacEditHelper helper ( m_txn ) ; SetTXNData ( st , kTXNUseCurrentSelection , kTXNUseCurrentSelection ) ; } GetSelection ( & dummy , & end ) ; } void wxMacMLTEControl :: Clear ( ) { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif wxMacEditHelper st ( m_txn ) ; TXNSetSelection ( m_txn , kTXNStartOffset , kTXNEndOffset ) ; TXNClear ( m_txn ) ; } bool wxMacMLTEControl :: CanUndo ( ) const { return TXNCanUndo ( m_txn , NULL ) ; } void wxMacMLTEControl :: Undo ( ) { TXNUndo ( m_txn ) ; } bool wxMacMLTEControl :: CanRedo ( ) const { return TXNCanRedo ( m_txn , NULL ) ; } void wxMacMLTEControl :: Redo ( ) { TXNRedo ( m_txn ) ; } int wxMacMLTEControl :: GetNumberOfLines ( ) const { ItemCount lines = 0 ; TXNGetLineCount ( m_txn , & lines ) ; return lines ; } long wxMacMLTEControl :: XYToPosition ( long x , long y ) const { Point curpt ; wxTextPos lastpos ; long xpos = 0 , ypos = 0 ; int lastHeight = 0 ; ItemCount n ; lastpos = GetLastPosition ( ) ; for ( n = 0 ; n <= ( ItemCount ) lastpos ; ++ n ) { if ( y == ypos && x == xpos ) return n ; TXNOffsetToPoint ( m_txn , n , & curpt ) ; if ( curpt . v > lastHeight ) { xpos = 0 ; if ( n > 0 ) ++ ypos ; lastHeight = curpt . v ; } else ++ xpos ; } return 0 ; } bool wxMacMLTEControl :: PositionToXY ( long pos , long * x , long * y ) const { Point curpt ; wxTextPos lastpos ; if ( y ) * y = 0 ; if ( x ) * x = 0 ; lastpos = GetLastPosition ( ) ; if ( pos <= lastpos ) { long xpos = 0 , ypos = 0 ; int lastHeight = 0 ; ItemCount n ; for ( n = 0 ; n <= ( ItemCount ) pos ; ++ n ) { TXNOffsetToPoint ( m_txn , n , & curpt ) ; if ( curpt . v > lastHeight ) { xpos = 0 ; if ( n > 0 ) ++ ypos ; lastHeight = curpt . v ; } else ++ xpos ; } if ( y ) * y = ypos ; if ( x ) * x = xpos ; } return false ; } void wxMacMLTEControl :: ShowPosition ( long pos ) { Point current , desired ; TXNOffset selstart , selend ; TXNGetSelection ( m_txn , & selstart , & selend ) ; TXNOffsetToPoint ( m_txn , selstart , & current ) ; TXNOffsetToPoint ( m_txn , pos , & desired ) ; OSErr theErr = noErr ; long dv = desired . v - current . v ; long dh = desired . h - current . h ; TXNShowSelection ( m_txn , kTXNShowStart ) ; theErr = TXNScroll ( m_txn , kTXNScrollUnitsInPixels , kTXNScrollUnitsInPixels , & dv , & dh ) ; } void wxMacMLTEControl :: SetTXNData ( const wxString & st , TXNOffset start , TXNOffset end ) { # if wxUSE_UNICODE wxMBConvUTF16 converter ; ByteCount byteBufferLen = converter . WC2MB ( NULL , st . wc_str ( ) , 0 ) ; wxASSERT_MSG ( byteBufferLen != wxCONV_FAILED , wxT ( " Conversion ▁ to ▁ UTF - 16 ▁ unexpectedly ▁ failed " ) ) ; UniChar * unibuf = ( UniChar * ) malloc ( byteBufferLen + 2 ) ; converter . WC2MB ( ( char * ) unibuf , st . wc_str ( ) , byteBufferLen + 2 ) ; TXNSetData ( m_txn , kTXNUnicodeTextData , ( void * ) unibuf , byteBufferLen , start , end ) ; free ( unibuf ) ; # else wxCharBuffer text = st . mb_str ( wxConvLocal ) ; TXNSetData ( m_txn , kTXNTextData , ( void * ) text . data ( ) , strlen ( text ) , start , end ) ; # endif } wxString wxMacMLTEControl :: GetLineText ( long lineNo ) const { wxString line ; if ( lineNo < GetNumberOfLines ( ) ) { Point firstPoint ; Fixed lineWidth , lineHeight , currentHeight ; long ypos ; TXNOffsetToPoint ( m_txn , 0 , & firstPoint ) ; ypos = 0 ; currentHeight = 0 ; while ( ypos < lineNo ) { TXNGetLineMetrics ( m_txn , ypos ++ , & lineWidth , & lineHeight ) ; currentHeight += lineHeight ; } Point thePoint = { firstPoint . v + ( currentHeight >> 16 ) , firstPoint . h + ( 0 ) } ; TXNOffset theOffset ; TXNPointToOffset ( m_txn , thePoint , & theOffset ) ; wxString content = GetStringValue ( ) ; Point currentPoint = thePoint ; while ( thePoint . v == currentPoint . v && theOffset < content . length ( ) ) { line += content [ theOffset ] ; TXNOffsetToPoint ( m_txn , ++ theOffset , & currentPoint ) ; } } return line ; } int wxMacMLTEControl :: GetLineLength ( long lineNo ) const { int theLength = 0 ; if ( lineNo < GetNumberOfLines ( ) ) { Point firstPoint ; Fixed lineWidth , lineHeight , currentHeight ; long ypos ; TXNOffsetToPoint ( m_txn , 0 , & firstPoint ) ; ypos = 0 ; currentHeight = 0 ; while ( ypos < lineNo ) { TXNGetLineMetrics ( m_txn , ypos ++ , & lineWidth , & lineHeight ) ; currentHeight += lineHeight ; } Point thePoint = { firstPoint . v + ( currentHeight >> 16 ) , firstPoint . h + ( 0 ) } ; TXNOffset theOffset ; TXNPointToOffset ( m_txn , thePoint , & theOffset ) ; wxString content = GetStringValue ( ) ; Point currentPoint = thePoint ; while ( thePoint . v == currentPoint . v && theOffset < content . length ( ) ) { ++ theLength ; TXNOffsetToPoint ( m_txn , ++ theOffset , & currentPoint ) ; } } return theLength ; } static const EventTypeSpec eventList [ ] = { { kEventClassTextInput , kEventTextInputUnicodeForKeyEvent } , } ; static pascal OSStatus wxMacUnicodeTextEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; wxMacMLTEHIViewControl * focus = ( wxMacMLTEHIViewControl * ) data ; switch ( GetEventKind ( event ) ) { case kEventTextInputUnicodeForKeyEvent : { TXNOffset from , to ; TXNGetSelection ( focus -> GetTXNObject ( ) , & from , & to ) ; if ( from == to ) TXNShowSelection ( focus -> GetTXNObject ( ) , kTXNShowStart ) ; result = CallNextEventHandler ( handler , event ) ; break ; } default : break ; } return result ; } static pascal OSStatus wxMacTextControlEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; switch ( GetEventClass ( event ) ) { case kEventClassTextInput : result = wxMacUnicodeTextEventHandler ( handler , event , data ) ; break ; default : break ; } return result ; } DEFINE_ONE_SHOT_HANDLER_GETTER ( wxMacTextControlEventHandler ) wxMacMLTEHIViewControl :: wxMacMLTEHIViewControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) : wxMacMLTEControl ( wxPeer ) { m_font = wxPeer -> GetFont ( ) ; m_windowStyle = style ; Rect bounds = wxMacGetBoundsForControl ( wxPeer , pos , size ) ; wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; HIRect hr = { { bounds . left , bounds . top } , { bounds . right - bounds . left , bounds . bottom - bounds . top } } ; m_scrollView = NULL ; TXNFrameOptions frameOptions = FrameOptionsFromWXStyle ( style ) ; if ( ( frameOptions & ( kTXNWantVScrollBarMask | kTXNWantHScrollBarMask ) ) || ( frameOptions & kTXNSingleLineOnlyMask ) ) { if ( frameOptions & ( kTXNWantVScrollBarMask | kTXNWantHScrollBarMask ) ) { HIScrollViewCreate ( ( frameOptions & kTXNWantHScrollBarMask ? kHIScrollViewOptionsHorizScroll : 0 ) | ( frameOptions & kTXNWantVScrollBarMask ? kHIScrollViewOptionsVertScroll : 0 ) , & m_scrollView ) ; } else { HIScrollViewCreate ( kHIScrollViewOptionsVertScroll , & m_scrollView ) ; HIScrollViewSetScrollBarAutoHide ( m_scrollView , true ) ; } HIViewSetFrame ( m_scrollView , & hr ) ; HIViewSetVisible ( m_scrollView , true ) ; } m_textView = NULL ; HITextViewCreate ( NULL , 0 , frameOptions , & m_textView ) ; m_txn = HITextViewGetTXNObject ( m_textView ) ; HIViewSetVisible ( m_textView , true ) ; if ( m_scrollView ) { HIViewAddSubview ( m_scrollView , m_textView ) ; m_controlRef = m_scrollView ; InstallEventHandler ( ( WXWidget ) m_textView ) ; } else { HIViewSetFrame ( m_textView , & hr ) ; m_controlRef = m_textView ; } AdjustCreationAttributes ( * wxWHITE , true ) ; # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif SetTXNData ( st , kTXNStartOffset , kTXNEndOffset ) ; TXNSetSelection ( m_txn , 0 , 0 ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; :: InstallControlEventHandler ( m_textView , GetwxMacTextControlEventHandlerUPP ( ) , GetEventTypeCount ( eventList ) , eventList , this , NULL ) ; } wxMacMLTEHIViewControl :: ~ wxMacMLTEHIViewControl ( ) { } bool wxMacMLTEHIViewControl :: SetFocus ( ) { return SetKeyboardFocus ( GetControlOwner ( m_textView ) , m_textView , kControlFocusNextPart ) == noErr ; } bool wxMacMLTEHIViewControl :: HasFocus ( ) const { ControlRef control ; if ( GetUserFocusWindow ( ) == NULL ) return false ; GetKeyboardFocus ( GetUserFocusWindow ( ) , & control ) ; return control == m_textView ; } void wxMacMLTEHIViewControl :: SetBackgroundColour ( const wxColour & col ) { HITextViewSetBackgroundColor ( m_textView , col . GetPixel ( ) ) ; } # endif </DOCUMENT>
<DOCUMENT_ID="alessonrenato/TrinityCore/tree/master/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp"> # include " BattlegroundAB . h " # include " WorldPacket . h " # include " BattlegroundMgr . h " # include " Creature . h " # include " Language . h " # include " Player . h " # include " Util . h " # include " WorldSession . h " BattlegroundAB :: BattlegroundAB ( ) { m_IsInformedNearVictory = false ; m_BuffChange = true ; BgObjects . resize ( BG_AB_OBJECT_MAX ) ; BgCreatures . resize ( BG_AB_ALL_NODES_COUNT + 5 ) ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { m_Nodes [ i ] = 0 ; m_prevNodes [ i ] = 0 ; m_NodeTimers [ i ] = 0 ; m_BannerTimers [ i ] . timer = 0 ; m_BannerTimers [ i ] . type = 0 ; m_BannerTimers [ i ] . teamIndex = 0 ; } for ( uint8 i = 0 ; i < BG_TEAMS_COUNT ; ++ i ) { m_lastTick [ i ] = 0 ; m_HonorScoreTics [ i ] = 0 ; m_ReputationScoreTics [ i ] = 0 ; m_TeamScores500Disadvantage [ i ] = false ; } m_HonorTics = 0 ; m_ReputationTics = 0 ; StartMessageIds [ BG_STARTING_EVENT_FIRST ] = LANG_BG_AB_START_TWO_MINUTES ; StartMessageIds [ BG_STARTING_EVENT_SECOND ] = LANG_BG_AB_START_ONE_MINUTE ; StartMessageIds [ BG_STARTING_EVENT_THIRD ] = LANG_BG_AB_START_HALF_MINUTE ; StartMessageIds [ BG_STARTING_EVENT_FOURTH ] = LANG_BG_AB_HAS_BEGUN ; } BattlegroundAB :: ~ BattlegroundAB ( ) { } void BattlegroundAB :: PostUpdateImpl ( uint32 diff ) { if ( GetStatus ( ) == STATUS_IN_PROGRESS ) { int team_points [ BG_TEAMS_COUNT ] = { 0 , 0 } ; for ( int node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) { if ( m_BannerTimers [ node ] . timer ) { if ( m_BannerTimers [ node ] . timer > diff ) m_BannerTimers [ node ] . timer -= diff ; else { m_BannerTimers [ node ] . timer = 0 ; _CreateBanner ( node , m_BannerTimers [ node ] . type , m_BannerTimers [ node ] . teamIndex , false ) ; } } if ( m_NodeTimers [ node ] ) { if ( m_NodeTimers [ node ] > diff ) m_NodeTimers [ node ] -= diff ; else { m_NodeTimers [ node ] = 0 ; uint8 teamIndex = m_Nodes [ node ] - 1 ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] += 2 ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; _NodeOccupied ( node , ( teamIndex == 0 ) ? ALLIANCE : HORDE ) ; if ( teamIndex == 0 ) { SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_ALLIANCE , NULL , LANG_BG_AB_ALLY , _GetNodeNameId ( node ) ) ; PlaySoundToAll ( BG_AB_SOUND_NODE_CAPTURED_ALLIANCE ) ; } else { SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_HORDE , NULL , LANG_BG_AB_HORDE , _GetNodeNameId ( node ) ) ; PlaySoundToAll ( BG_AB_SOUND_NODE_CAPTURED_HORDE ) ; } } } for ( int team = 0 ; team < BG_TEAMS_COUNT ; ++ team ) if ( m_Nodes [ node ] == team + BG_AB_NODE_TYPE_OCCUPIED ) ++ team_points [ team ] ; } for ( int team = 0 ; team < BG_TEAMS_COUNT ; ++ team ) { int points = team_points [ team ] ; if ( ! points ) continue ; m_lastTick [ team ] += diff ; if ( m_lastTick [ team ] > BG_AB_TickIntervals [ points ] ) { m_lastTick [ team ] -= BG_AB_TickIntervals [ points ] ; m_TeamScores [ team ] += BG_AB_TickPoints [ points ] ; m_HonorScoreTics [ team ] += BG_AB_TickPoints [ points ] ; m_ReputationScoreTics [ team ] += BG_AB_TickPoints [ points ] ; if ( m_ReputationScoreTics [ team ] >= m_ReputationTics ) { ( team == TEAM_ALLIANCE ) ? RewardReputationToTeam ( 509 , 10 , ALLIANCE ) : RewardReputationToTeam ( 510 , 10 , HORDE ) ; m_ReputationScoreTics [ team ] -= m_ReputationTics ; } if ( m_HonorScoreTics [ team ] >= m_HonorTics ) { RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ( team == TEAM_ALLIANCE ) ? ALLIANCE : HORDE ) ; m_HonorScoreTics [ team ] -= m_HonorTics ; } if ( ! m_IsInformedNearVictory && m_TeamScores [ team ] > BG_AB_WARNING_NEAR_VICTORY_SCORE ) { if ( team == TEAM_ALLIANCE ) SendMessageToAll ( LANG_BG_AB_A_NEAR_VICTORY , CHAT_MSG_BG_SYSTEM_NEUTRAL ) ; else SendMessageToAll ( LANG_BG_AB_H_NEAR_VICTORY , CHAT_MSG_BG_SYSTEM_NEUTRAL ) ; PlaySoundToAll ( BG_AB_SOUND_NEAR_VICTORY ) ; m_IsInformedNearVictory = true ; } if ( m_TeamScores [ team ] > BG_AB_MAX_TEAM_SCORE ) m_TeamScores [ team ] = BG_AB_MAX_TEAM_SCORE ; if ( team == TEAM_ALLIANCE ) UpdateWorldState ( BG_AB_OP_RESOURCES_ALLY , m_TeamScores [ team ] ) ; else if ( team == TEAM_HORDE ) UpdateWorldState ( BG_AB_OP_RESOURCES_HORDE , m_TeamScores [ team ] ) ; uint8 otherTeam = ( team + 1 ) % BG_TEAMS_COUNT ; if ( m_TeamScores [ team ] > m_TeamScores [ otherTeam ] + 500 ) m_TeamScores500Disadvantage [ otherTeam ] = true ; } } if ( m_TeamScores [ TEAM_ALLIANCE ] >= BG_AB_MAX_TEAM_SCORE ) EndBattleground ( ALLIANCE ) ; else if ( m_TeamScores [ TEAM_HORDE ] >= BG_AB_MAX_TEAM_SCORE ) EndBattleground ( HORDE ) ; } } void BattlegroundAB :: StartingEventCloseDoors ( ) { for ( int obj = BG_AB_OBJECT_BANNER_NEUTRAL ; obj < BG_AB_DYNAMIC_NODES_COUNT * 8 ; ++ obj ) SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT * 3 ; ++ i ) SpawnBGObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + i , RESPAWN_ONE_DAY ) ; DoorClose ( BG_AB_OBJECT_GATE_A ) ; DoorClose ( BG_AB_OBJECT_GATE_H ) ; SpawnBGObject ( BG_AB_OBJECT_GATE_A , RESPAWN_IMMEDIATELY ) ; SpawnBGObject ( BG_AB_OBJECT_GATE_H , RESPAWN_IMMEDIATELY ) ; _NodeOccupied ( BG_AB_SPIRIT_ALIANCE , ALLIANCE ) ; _NodeOccupied ( BG_AB_SPIRIT_HORDE , HORDE ) ; } void BattlegroundAB :: StartingEventOpenDoors ( ) { for ( int banner = BG_AB_OBJECT_BANNER_NEUTRAL , i = 0 ; i < 5 ; banner += 8 , ++ i ) SpawnBGObject ( banner , RESPAWN_IMMEDIATELY ) ; for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { uint8 buff = urand ( 0 , 2 ) ; SpawnBGObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + buff + i * 3 , RESPAWN_IMMEDIATELY ) ; } DoorOpen ( BG_AB_OBJECT_GATE_A ) ; DoorOpen ( BG_AB_OBJECT_GATE_H ) ; StartTimedAchievement ( ACHIEVEMENT_TIMED_TYPE_EVENT , AB_EVENT_START_BATTLE ) ; } void BattlegroundAB :: AddPlayer ( Player * player ) { Battleground :: AddPlayer ( player ) ; PlayerScores [ player -> GetGUID ( ) ] = new BattlegroundABScore ( player -> GetGUID ( ) , player -> GetBGTeam ( ) ) ; } void BattlegroundAB :: RemovePlayer ( Player * , ObjectGuid , uint32 ) { } void BattlegroundAB :: HandleAreaTrigger ( Player * player , uint32 trigger , bool entered ) { if ( GetStatus ( ) != STATUS_IN_PROGRESS ) return ; switch ( trigger ) { case 3948 : if ( player -> GetTeam ( ) != ALLIANCE ) player -> GetSession ( ) -> SendNotification ( " Only ▁ The ▁ Alliance ▁ can ▁ use ▁ that ▁ portal " ) ; else player -> LeaveBattleground ( ) ; break ; case 3949 : if ( player -> GetTeam ( ) != HORDE ) player -> GetSession ( ) -> SendNotification ( " Only ▁ The ▁ Horde ▁ can ▁ use ▁ that ▁ portal " ) ; else player -> LeaveBattleground ( ) ; break ; case 3866 : case 3869 : case 3867 : case 3868 : case 3870 : case 4020 : case 4021 : case 4674 : default : Battleground :: HandleAreaTrigger ( player , trigger , entered ) ; break ; } } void BattlegroundAB :: _CreateBanner ( uint8 node , uint8 type , uint8 teamIndex , bool delay ) { if ( delay ) { m_BannerTimers [ node ] . timer = 2000 ; m_BannerTimers [ node ] . type = type ; m_BannerTimers [ node ] . teamIndex = teamIndex ; return ; } uint8 obj = node * 8 + type + teamIndex ; SpawnBGObject ( obj , RESPAWN_IMMEDIATELY ) ; if ( ! type ) return ; obj = node * 8 + ( ( type == BG_AB_NODE_TYPE_OCCUPIED ) ? ( 5 + teamIndex ) : 7 ) ; SpawnBGObject ( obj , RESPAWN_IMMEDIATELY ) ; } void BattlegroundAB :: _DelBanner ( uint8 node , uint8 type , uint8 teamIndex ) { uint8 obj = node * 8 + type + teamIndex ; SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; if ( ! type ) return ; obj = node * 8 + ( ( type == BG_AB_NODE_TYPE_OCCUPIED ) ? ( 5 + teamIndex ) : 7 ) ; SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; } int32 BattlegroundAB :: _GetNodeNameId ( uint8 node ) { switch ( node ) { case BG_AB_NODE_STABLES : return LANG_BG_AB_NODE_STABLES ; case BG_AB_NODE_BLACKSMITH : return LANG_BG_AB_NODE_BLACKSMITH ; case BG_AB_NODE_FARM : return LANG_BG_AB_NODE_FARM ; case BG_AB_NODE_LUMBER_MILL : return LANG_BG_AB_NODE_LUMBER_MILL ; case BG_AB_NODE_GOLD_MINE : return LANG_BG_AB_NODE_GOLD_MINE ; default : ABORT ( ) ; } return 0 ; } void BattlegroundAB :: FillInitialWorldStates ( WorldPackets :: WorldState :: InitWorldStates & packet ) { const uint8 plusArray [ ] = { 0 , 2 , 3 , 0 , 1 } ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_NODEICONS [ node ] ) , int32 ( ( m_Nodes [ node ] == 0 ) ? 1 : 0 ) ) ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) for ( uint8 i = 1 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_NODESTATES [ node ] + plusArray [ i ] ) , int32 ( ( m_Nodes [ node ] == i ) ? 1 : 0 ) ) ; uint8 ally = 0 , horde = 0 ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) if ( m_Nodes [ node ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ node ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_OCCUPIED_BASES_ALLY ) , int32 ( ally ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_OCCUPIED_BASES_HORDE ) , int32 ( horde ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_MAX ) , int32 ( BG_AB_MAX_TEAM_SCORE ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_WARNING ) , int32 ( BG_AB_WARNING_NEAR_VICTORY_SCORE ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_ALLY ) , int32 ( m_TeamScores [ TEAM_ALLIANCE ] ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_HORDE ) , int32 ( m_TeamScores [ TEAM_HORDE ] ) ) ; packet . Worldstates . emplace_back ( uint32 ( 0x745 ) , 0x2 ) ; } void BattlegroundAB :: _SendNodeUpdate ( uint8 node ) { const uint8 plusArray [ ] = { 0 , 2 , 3 , 0 , 1 } ; if ( m_prevNodes [ node ] ) UpdateWorldState ( BG_AB_OP_NODESTATES [ node ] + plusArray [ m_prevNodes [ node ] ] , 0 ) ; else UpdateWorldState ( BG_AB_OP_NODEICONS [ node ] , 0 ) ; UpdateWorldState ( BG_AB_OP_NODESTATES [ node ] + plusArray [ m_Nodes [ node ] ] , 1 ) ; uint8 ally = 0 , horde = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; UpdateWorldState ( BG_AB_OP_OCCUPIED_BASES_ALLY , ally ) ; UpdateWorldState ( BG_AB_OP_OCCUPIED_BASES_HORDE , horde ) ; } void BattlegroundAB :: _NodeOccupied ( uint8 node , Team team ) { if ( ! AddSpiritGuide ( node , BG_AB_SpiritGuidePos [ node ] , GetTeamIndexByTeamId ( team ) ) ) TC_LOG_ERROR ( " bg . battleground " , " Failed ▁ to ▁ spawn ▁ spirit ▁ guide ! ▁ point : ▁ % u , ▁ team : ▁ % u , ▁ " , node , team ) ; if ( node >= BG_AB_DYNAMIC_NODES_COUNT ) return ; uint8 capturedNodes = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == GetTeamIndexByTeamId ( team ) + BG_AB_NODE_TYPE_OCCUPIED && ! m_NodeTimers [ i ] ) ++ capturedNodes ; if ( capturedNodes >= 5 ) CastSpellOnTeam ( SPELL_AB_QUEST_REWARD_5_BASES , team ) ; if ( capturedNodes >= 4 ) CastSpellOnTeam ( SPELL_AB_QUEST_REWARD_4_BASES , team ) ; Creature * trigger = ! BgCreatures [ node + 7 ] ? GetBGCreature ( node + 7 ) : NULL ; if ( ! trigger ) trigger = AddCreature ( WORLD_TRIGGER , node + 7 , BG_AB_NodePositions [ node ] , GetTeamIndexByTeamId ( team ) ) ; if ( trigger ) { trigger -> setFaction ( team == ALLIANCE ? 84 : 83 ) ; trigger -> CastSpell ( trigger , SPELL_HONORABLE_DEFENDER_25Y , false ) ; } } void BattlegroundAB :: _NodeDeOccupied ( uint8 node ) { if ( node >= BG_AB_DYNAMIC_NODES_COUNT ) return ; if ( node < BG_AB_DYNAMIC_NODES_COUNT ) DelCreature ( node + 7 ) ; RelocateDeadPlayers ( BgCreatures [ node ] ) ; DelCreature ( node ) ; } void BattlegroundAB :: EventPlayerClickedOnFlag ( Player * source , GameObject * ) { if ( GetStatus ( ) != STATUS_IN_PROGRESS ) return ; uint8 node = BG_AB_NODE_STABLES ; GameObject * obj = GetBgMap ( ) -> GetGameObject ( BgObjects [ node * 8 + 7 ] ) ; while ( ( node < BG_AB_DYNAMIC_NODES_COUNT ) && ( ( ! obj ) || ( ! source -> IsWithinDistInMap ( obj , 10 ) ) ) ) { ++ node ; obj = GetBgMap ( ) -> GetGameObject ( BgObjects [ node * 8 + BG_AB_OBJECT_AURA_CONTESTED ] ) ; } if ( node == BG_AB_DYNAMIC_NODES_COUNT ) { return ; } TeamId teamIndex = GetTeamIndexByTeamId ( source -> GetTeam ( ) ) ; if ( ! ( m_Nodes [ node ] == 0 || teamIndex == m_Nodes [ node ] % 2 ) ) return ; source -> RemoveAurasWithInterruptFlags ( AURA_INTERRUPT_FLAG_ENTER_PVP_COMBAT ) ; uint32 sound = 0 ; if ( m_Nodes [ node ] == BG_AB_NODE_TYPE_NEUTRAL ) { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + 1 ; _DelBanner ( node , BG_AB_NODE_TYPE_NEUTRAL , 0 ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == 0 ) SendMessage2ToAll ( LANG_BG_AB_NODE_CLAIMED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) , LANG_BG_AB_ALLY ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_CLAIMED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) , LANG_BG_AB_HORDE ) ; sound = BG_AB_SOUND_NODE_CLAIMED ; } else if ( ( m_Nodes [ node ] == BG_AB_NODE_STATUS_ALLY_CONTESTED ) || ( m_Nodes [ node ] == BG_AB_NODE_STATUS_HORDE_CONTESTED ) ) { if ( m_prevNodes [ node ] < BG_AB_NODE_TYPE_OCCUPIED ) { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_CONTESTED ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; } else { UpdatePlayerScore ( source , SCORE_BASES_DEFENDED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_OCCUPIED ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = 0 ; _NodeOccupied ( node , ( teamIndex == TEAM_ALLIANCE ) ? ALLIANCE : HORDE ) ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_DEFENDED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_DEFENDED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; } sound = ( teamIndex == TEAM_ALLIANCE ) ? BG_AB_SOUND_NODE_ASSAULTED_ALLIANCE : BG_AB_SOUND_NODE_ASSAULTED_HORDE ; } else { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_CONTESTED ; _DelBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; _NodeDeOccupied ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; sound = ( teamIndex == TEAM_ALLIANCE ) ? BG_AB_SOUND_NODE_ASSAULTED_ALLIANCE : BG_AB_SOUND_NODE_ASSAULTED_HORDE ; } if ( m_Nodes [ node ] >= BG_AB_NODE_TYPE_OCCUPIED ) { if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_ALLIANCE , NULL , LANG_BG_AB_ALLY , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_HORDE , NULL , LANG_BG_AB_HORDE , _GetNodeNameId ( node ) ) ; } PlaySoundToAll ( sound ) ; } uint32 BattlegroundAB :: GetPrematureWinner ( ) { uint8 ally = 0 , horde = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; if ( ally > horde ) return ALLIANCE ; else if ( horde > ally ) return HORDE ; return Battleground :: GetPrematureWinner ( ) ; } bool BattlegroundAB :: SetupBattleground ( ) { for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { if ( ! AddObject ( BG_AB_OBJECT_BANNER_NEUTRAL + 8 * i , BG_AB_OBJECTID_NODE_BANNER_0 + i , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_CONT_A + 8 * i , BG_AB_OBJECTID_BANNER_CONT_A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_CONT_H + 8 * i , BG_AB_OBJECTID_BANNER_CONT_H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_ALLY + 8 * i , BG_AB_OBJECTID_BANNER_A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_HORDE + 8 * i , BG_AB_OBJECTID_BANNER_H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_ALLY + 8 * i , BG_AB_OBJECTID_AURA_A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_HORDE + 8 * i , BG_AB_OBJECTID_AURA_H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_CONTESTED + 8 * i , BG_AB_OBJECTID_AURA_C , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) ) { TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ some ▁ object ▁ Battleground ▁ not ▁ created ! " ) ; return false ; } } if ( ! AddObject ( BG_AB_OBJECT_GATE_A , BG_AB_OBJECTID_GATE_A , BG_AB_DoorPositions [ 0 ] [ 0 ] , BG_AB_DoorPositions [ 0 ] [ 1 ] , BG_AB_DoorPositions [ 0 ] [ 2 ] , BG_AB_DoorPositions [ 0 ] [ 3 ] , BG_AB_DoorPositions [ 0 ] [ 4 ] , BG_AB_DoorPositions [ 0 ] [ 5 ] , BG_AB_DoorPositions [ 0 ] [ 6 ] , BG_AB_DoorPositions [ 0 ] [ 7 ] , RESPAWN_IMMEDIATELY ) || ! AddObject ( BG_AB_OBJECT_GATE_H , BG_AB_OBJECTID_GATE_H , BG_AB_DoorPositions [ 1 ] [ 0 ] , BG_AB_DoorPositions [ 1 ] [ 1 ] , BG_AB_DoorPositions [ 1 ] [ 2 ] , BG_AB_DoorPositions [ 1 ] [ 3 ] , BG_AB_DoorPositions [ 1 ] [ 4 ] , BG_AB_DoorPositions [ 1 ] [ 5 ] , BG_AB_DoorPositions [ 1 ] [ 6 ] , BG_AB_DoorPositions [ 1 ] [ 7 ] , RESPAWN_IMMEDIATELY ) ) { TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ door ▁ object ▁ Battleground ▁ not ▁ created ! " ) ; return false ; } for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { if ( ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i , Buff_Entries [ 0 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i + 1 , Buff_Entries [ 1 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i + 2 , Buff_Entries [ 2 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) ) TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ buff ▁ object ! " ) ; } return true ; } void BattlegroundAB :: Reset ( ) { Battleground :: Reset ( ) ; m_TeamScores [ TEAM_ALLIANCE ] = 0 ; m_TeamScores [ TEAM_HORDE ] = 0 ; m_lastTick [ TEAM_ALLIANCE ] = 0 ; m_lastTick [ TEAM_HORDE ] = 0 ; m_HonorScoreTics [ TEAM_ALLIANCE ] = 0 ; m_HonorScoreTics [ TEAM_HORDE ] = 0 ; m_ReputationScoreTics [ TEAM_ALLIANCE ] = 0 ; m_ReputationScoreTics [ TEAM_HORDE ] = 0 ; m_IsInformedNearVictory = false ; bool isBGWeekend = sBattlegroundMgr -> IsBGWeekend ( GetTypeID ( ) ) ; m_HonorTics = ( isBGWeekend ) ? BG_AB_ABBGWeekendHonorTicks : BG_AB_NotABBGWeekendHonorTicks ; m_ReputationTics = ( isBGWeekend ) ? BG_AB_ABBGWeekendReputationTicks : BG_AB_NotABBGWeekendReputationTicks ; m_TeamScores500Disadvantage [ TEAM_ALLIANCE ] = false ; m_TeamScores500Disadvantage [ TEAM_HORDE ] = false ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { m_Nodes [ i ] = 0 ; m_prevNodes [ i ] = 0 ; m_NodeTimers [ i ] = 0 ; m_BannerTimers [ i ] . timer = 0 ; } for ( uint8 i = 0 ; i < BG_AB_ALL_NODES_COUNT + 5 ; ++ i ) if ( ! BgCreatures [ i ] . IsEmpty ( ) ) DelCreature ( i ) ; } void BattlegroundAB :: EndBattleground ( uint32 winner ) { if ( winner == ALLIANCE ) RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ALLIANCE ) ; if ( winner == HORDE ) RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , HORDE ) ; RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , HORDE ) ; RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ALLIANCE ) ; Battleground :: EndBattleground ( winner ) ; } WorldSafeLocsEntry const * BattlegroundAB :: GetClosestGraveYard ( Player * player ) { TeamId teamIndex = GetTeamIndexByTeamId ( player -> GetTeam ( ) ) ; std :: vector < uint8 > nodes ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == teamIndex + 3 ) nodes . push_back ( i ) ; WorldSafeLocsEntry const * good_entry = NULL ; if ( ! nodes . empty ( ) ) { float plr_x = player -> GetPositionX ( ) ; float plr_y = player -> GetPositionY ( ) ; float mindist = 999999.0f ; for ( uint8 i = 0 ; i < nodes . size ( ) ; ++ i ) { WorldSafeLocsEntry const * entry = sWorldSafeLocsStore . LookupEntry ( BG_AB_GraveyardIds [ nodes [ i ] ] ) ; if ( ! entry ) continue ; float dist = ( entry -> Loc . X - plr_x ) * ( entry -> Loc . X - plr_x ) + ( entry -> Loc . Y - plr_y ) * ( entry -> Loc . Y - plr_y ) ; if ( mindist > dist ) { mindist = dist ; good_entry = entry ; } } nodes . clear ( ) ; } if ( ! good_entry ) good_entry = sWorldSafeLocsStore . LookupEntry ( BG_AB_GraveyardIds [ teamIndex + 5 ] ) ; return good_entry ; } bool BattlegroundAB :: UpdatePlayerScore ( Player * player , uint32 type , uint32 value , bool doAddHonor ) { if ( ! Battleground :: UpdatePlayerScore ( player , type , value , doAddHonor ) ) return false ; switch ( type ) { case SCORE_BASES_ASSAULTED : player -> UpdateAchievementCriteria ( ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE , AB_OBJECTIVE_ASSAULT_BASE ) ; break ; case SCORE_BASES_DEFENDED : player -> UpdateAchievementCriteria ( ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE , AB_OBJECTIVE_DEFEND_BASE ) ; break ; default : break ; } return true ; } bool BattlegroundAB :: IsAllNodesControlledByTeam ( uint32 team ) const { uint32 count = 0 ; for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( ( team == ALLIANCE && m_Nodes [ i ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) || ( team == HORDE && m_Nodes [ i ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ) ++ count ; return count == BG_AB_DYNAMIC_NODES_COUNT ; } bool BattlegroundAB :: CheckAchievementCriteriaMeet ( uint32 criteriaId , Player const * player , Unit const * target , uint32 miscvalue ) { switch ( criteriaId ) { case BG_CRITERIA_CHECK_RESILIENT_VICTORY : return m_TeamScores500Disadvantage [ GetTeamIndexByTeamId ( player -> GetTeam ( ) ) ] ; } return Battleground :: CheckAchievementCriteriaMeet ( criteriaId , player , target , miscvalue ) ; } </DOCUMENT>
<DOCUMENT_ID="ondra-novak/blink/tree/master/Source/core/svg/SVGFontFaceUriElement.cpp"> # include " config . h " # if ENABLE ( SVG_FONTS ) # include " core / svg / SVGFontFaceUriElement . h " # include " core / XLinkNames . h " # include " core / css / CSSFontFaceSrcValue . h " # include " core / dom / Document . h " # include " core / fetch / FetchRequest . h " # include " core / fetch / ResourceFetcher . h " # include " core / svg / SVGFontFaceElement . h " namespace blink { using namespace SVGNames ; inline SVGFontFaceUriElement :: SVGFontFaceUriElement ( Document & document ) : SVGElement ( font_face_uriTag , document ) { ScriptWrappable :: init ( this ) ; } DEFINE_NODE_FACTORY ( SVGFontFaceUriElement ) SVGFontFaceUriElement :: ~ SVGFontFaceUriElement ( ) { if ( m_resource ) m_resource -> removeClient ( this ) ; } PassRefPtrWillBeRawPtr < CSSFontFaceSrcValue > SVGFontFaceUriElement :: srcValue ( ) const { RefPtrWillBeRawPtr < CSSFontFaceSrcValue > src = CSSFontFaceSrcValue :: create ( getAttribute ( XLinkNames :: hrefAttr ) ) ; AtomicString value ( fastGetAttribute ( formatAttr ) ) ; src -> setFormat ( value . isEmpty ( ) ? " svg " : value ) ; return src . release ( ) ; } void SVGFontFaceUriElement :: parseAttribute ( const QualifiedName & name , const AtomicString & value ) { if ( name . matches ( XLinkNames :: hrefAttr ) ) loadFont ( ) ; else SVGElement :: parseAttribute ( name , value ) ; } void SVGFontFaceUriElement :: childrenChanged ( const ChildrenChange & change ) { SVGElement :: childrenChanged ( change ) ; if ( ! isSVGFontFaceSrcElement ( parentNode ( ) ) ) return ; ContainerNode * grandparent = parentNode ( ) -> parentNode ( ) ; if ( isSVGFontFaceElement ( grandparent ) ) toSVGFontFaceElement ( * grandparent ) . rebuildFontFace ( ) ; } Node :: InsertionNotificationRequest SVGFontFaceUriElement :: insertedInto ( ContainerNode * rootParent ) { loadFont ( ) ; return SVGElement :: insertedInto ( rootParent ) ; } void SVGFontFaceUriElement :: loadFont ( ) { if ( m_resource ) m_resource -> removeClient ( this ) ; const AtomicString & href = getAttribute ( XLinkNames :: hrefAttr ) ; if ( ! href . isNull ( ) ) { ResourceFetcher * fetcher = document ( ) . fetcher ( ) ; FetchRequest request ( ResourceRequest ( document ( ) . completeURL ( href ) ) , localName ( ) ) ; m_resource = fetcher -> fetchFont ( request ) ; if ( m_resource ) { m_resource -> addClient ( this ) ; m_resource -> beginLoadIfNeeded ( fetcher ) ; } } else { m_resource = 0 ; } } } # endif </DOCUMENT>
<DOCUMENT_ID="chirilo/phantomjs/tree/master/src/qt/qtbase/src/gui/doc/snippets/code/src_gui_painting_qpainter.cpp"> void SimpleExampleWidget :: paintEvent ( QPaintEvent * ) { QPainter painter ( this ) ; painter . setPen ( Qt :: blue ) ; painter . setFont ( QFont ( " Arial " , 30 ) ) ; painter . drawText ( rect ( ) , Qt :: AlignCenter , " Qt " ) ; } void MyWidget :: paintEvent ( QPaintEvent * ) { QPainter p ; p . begin ( this ) ; p . drawLine ( ... ) ; p . end ( ) ; } void MyWidget :: paintEvent ( QPaintEvent * ) { QPainter p ( this ) ; p . drawLine ( ... ) ; } painter -> begin ( 0 ) ; QPixmap image ( 0 , 0 ) ; painter -> begin ( & image ) ; painter -> begin ( myWidget ) ; painter2 -> begin ( myWidget ) ; void QPainter :: rotate ( qreal angle ) { QMatrix matrix ; matrix . rotate ( angle ) ; setWorldMatrix ( matrix , true ) ; } QPainterPath path ; path . moveTo ( 20 , 80 ) ; path . lineTo ( 20 , 30 ) ; path . cubicTo ( 80 , 0 , 50 , 50 , 80 , 80 ) ; QPainter painter ( this ) ; painter . drawPath ( path ) ; QLineF line ( 10.0 , 80.0 , 90.0 , 20.0 ) ; QPainter ( this ) ; painter . drawLine ( line ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QPainter painter ( this ) ; painter . drawRect ( rectangle ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QPainter painter ( this ) ; painter . drawRoundedRect ( rectangle , 20.0 , 15.0 ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QPainter painter ( this ) ; painter . drawEllipse ( rectangle ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; int startAngle = 30 * 16 ; int spanAngle = 120 * 16 ; QPainter painter ( this ) ; painter . drawArc ( rectangle , startAngle , spanAngle ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; int startAngle = 30 * 16 ; int spanAngle = 120 * 16 ; QPainter painter ( this ) ; painter . drawPie ( rectangle , startAngle , spanAngle ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; int startAngle = 30 * 16 ; int spanAngle = 120 * 16 ; QPainter painter ( this ) ; painter . drawChord ( rect , startAngle , spanAngle ) ; static const QPointF points [ 3 ] = { QPointF ( 10.0 , 80.0 ) , QPointF ( 20.0 , 10.0 ) , QPointF ( 80.0 , 30.0 ) , } ; QPainter painter ( this ) ; painter . drawPolyline ( points , 3 ) ; static const QPointF points [ 4 ] = { QPointF ( 10.0 , 80.0 ) , QPointF ( 20.0 , 10.0 ) , QPointF ( 80.0 , 30.0 ) , QPointF ( 90.0 , 70.0 ) } ; QPainter painter ( this ) ; painter . drawPolygon ( points , 4 ) ; static const QPointF points [ 4 ] = { QPointF ( 10.0 , 80.0 ) , QPointF ( 20.0 , 10.0 ) , QPointF ( 80.0 , 30.0 ) , QPointF ( 90.0 , 70.0 ) } ; QPainter painter ( this ) ; painter . drawConvexPolygon ( points , 4 ) ; QRectF target ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QRectF source ( 0.0 , 0.0 , 70.0 , 40.0 ) ; QPixmap pixmap ( " : myPixmap . png " ) ; QPainter ( this ) ; painter . drawPixmap ( target , pixmap , source ) ; QPainter painter ( this ) ; painter . drawText ( rect , Qt :: AlignCenter , tr ( " Qt \n Project " ) ) ; QPicture picture ; QPointF point ( 10.0 , 20.0 ) picture . load ( " drawing . pic " ) ; QPainter painter ( this ) ; painter . drawPicture ( 0 , 0 , picture ) ; fillRect ( rectangle , background ( ) ) . QRectF target ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QRectF source ( 0.0 , 0.0 , 70.0 , 40.0 ) ; QImage image ( " : / images / myImage . png " ) ; QPainter painter ( this ) ; painter . drawImage ( target , image , source ) ; QPainter painter ( this ) ; painter . fillRect ( 0 , 0 , 128 , 128 , Qt :: green ) ; painter . beginNativePainting ( ) ; glEnable ( GL_SCISSOR_TEST ) ; glScissor ( 0 , 0 , 64 , 64 ) ; glClearColor ( 1 , 0 , 0 , 1 ) ; glClear ( GL_COLOR_BUFFER_BIT ) ; glDisable ( GL_SCISSOR_TEST ) ; painter . endNativePainting ( ) ; </DOCUMENT>
<DOCUMENT_ID="hbwhlklive/color-emoji.skia/tree/master/src/ports/SkGlobalInitialization_chromium.cpp"> # include " SkBitmapProcShader . h " # include " SkBlurImageFilter . h " # include " SkBlurMaskFilter . h " # include " SkColorFilter . h " # include " SkCornerPathEffect . h " # include " SkDashPathEffect . h " # include " SkGradientShader . h " # include " SkLayerDrawLooper . h " # include " SkMallocPixelRef . h " # include " SkXfermode . h " # include " SkMagnifierImageFilter . h " void SkFlattenable :: InitializeFlattenables ( ) { SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkBitmapProcShader ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkBlurImageFilter ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkCornerPathEffect ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkDashPathEffect ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkLayerDrawLooper ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkMallocPixelRef ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkMagnifierImageFilter ) SkBlurMaskFilter :: InitializeFlattenables ( ) ; SkColorFilter :: InitializeFlattenables ( ) ; SkGradientShader :: InitializeFlattenables ( ) ; SkXfermode :: InitializeFlattenables ( ) ; } </DOCUMENT>
<DOCUMENT_ID="austinzheng/swift/tree/master/lib/SILOptimizer/IPO/LetPropertiesOpts.cpp"> # define DEBUG_TYPE " let - properties - opt " # include " swift / SIL / DebugUtils . h " # include " swift / SIL / InstructionUtils . h " # include " swift / SIL / SILBasicBlock . h " # include " swift / SIL / SILInstruction . h " # include " swift / SIL / SILLinkage . h " # include " swift / SILOptimizer / PassManager / Passes . h " # include " swift / SILOptimizer / PassManager / Transforms . h " # include " swift / SILOptimizer / Utils / Local . h " # include " llvm / ADT / MapVector . h " # include " llvm / Support / CommandLine . h " # include " llvm / Support / Debug . h " using namespace swift ; namespace { using InstructionList = SmallVector < SILInstruction * , 8 > ; struct InitSequence { InstructionList Instructions ; SILValue Result ; bool isValid ( ) const { return ( bool ) Result ; } } ; class LetPropertiesOpt { SILModule * Module ; typedef SmallVector < VarDecl * , 4 > Properties ; llvm :: SetVector < SILFunction * > ChangedFunctions ; llvm :: MapVector < VarDecl * , InstructionList > AccessMap ; llvm :: MapVector < VarDecl * , InitSequence > InitMap ; llvm :: SmallPtrSet < VarDecl * , 16 > SkipProcessing ; llvm :: SmallPtrSet < NominalTypeDecl * , 16 > SkipTypeProcessing ; llvm :: SmallPtrSet < VarDecl * , 16 > CannotRemove ; llvm :: MapVector < NominalTypeDecl * , Properties > NominalTypeLetProperties ; llvm :: SmallPtrSet < VarDecl * , 16 > PotentialConstantLetProperty ; public : LetPropertiesOpt ( SILModule * M ) : Module ( M ) { } void run ( SILModuleTransform * T ) ; protected : bool isConstantLetProperty ( VarDecl * Property ) ; void collectPropertyAccess ( SILInstruction * I , VarDecl * Property , bool NonRemovable ) ; void collectStructPropertiesAccess ( StructInst * SI , bool NonRemovable ) ; void optimizeLetPropertyAccess ( VarDecl * SILG , const InitSequence & Init ) ; bool analyzeInitValue ( SILInstruction * I , VarDecl * Prop ) ; } ; class InitSequenceCloner : public SILClonerWithScopes < InitSequenceCloner > { friend class SILInstructionVisitor < InitSequenceCloner > ; friend class SILCloner < InitSequenceCloner > ; const InitSequence & Init ; SILInstruction * DestIP ; public : InitSequenceCloner ( const InitSequence & init , SILInstruction * destIP ) : SILClonerWithScopes ( * destIP -> getFunction ( ) ) , Init ( init ) , DestIP ( destIP ) { } void process ( SILInstruction * I ) { visit ( I ) ; } SILBasicBlock * remapBasicBlock ( SILBasicBlock * BB ) { return BB ; } SILValue getMappedValue ( SILValue Value ) { return SILCloner < InitSequenceCloner > :: getMappedValue ( Value ) ; } void postProcess ( SILInstruction * orig , SILInstruction * cloned ) { DestIP -> getParent ( ) -> push_front ( cloned ) ; cloned -> moveBefore ( DestIP ) ; SILClonerWithScopes < InitSequenceCloner > :: postProcess ( orig , cloned ) ; } SILValue clone ( ) { for ( auto I : Init . Instructions ) process ( I ) ; return getMappedValue ( Init . Result ) ; } } ; } # ifndef NDEBUG static raw_ostream & operator << ( raw_ostream & OS , const VarDecl & decl ) { auto * Ty = dyn_cast < NominalTypeDecl > ( decl . getDeclContext ( ) ) ; if ( Ty ) OS << Ty -> getName ( ) << " : : " ; OS << decl . getName ( ) ; return OS ; } # endif void LetPropertiesOpt :: optimizeLetPropertyAccess ( VarDecl * Property , const InitSequence & init ) { assert ( init . isValid ( ) ) ; if ( SkipProcessing . count ( Property ) ) return ; auto * Ty = dyn_cast < NominalTypeDecl > ( Property -> getDeclContext ( ) ) ; if ( SkipTypeProcessing . count ( Ty ) ) return ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Replacing ▁ access ▁ to ▁ property ▁ ' " << * Property << " ' ▁ by ▁ its ▁ constant ▁ initializer \n " ) ; auto PropertyAccess = Property -> getEffectiveAccess ( ) ; auto TypeAccess = Ty -> getEffectiveAccess ( ) ; auto CanRemove = false ; if ( TypeAccess <= AccessLevel :: FilePrivate || PropertyAccess <= AccessLevel :: FilePrivate || ( ( TypeAccess <= AccessLevel :: Internal || PropertyAccess <= AccessLevel :: Internal ) && Module -> isWholeModule ( ) ) ) { CanRemove = true ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Storage ▁ for ▁ property ▁ ' " << * Property << " ' ▁ can ▁ be ▁ eliminated \n " ) ; } if ( CannotRemove . count ( Property ) ) CanRemove = false ; if ( ! AccessMap . count ( Property ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ is ▁ never ▁ read \n " ) ; if ( CanRemove ) { } return ; } auto & Loads = AccessMap [ Property ] ; unsigned NumReplaced = 0 ; for ( auto Load : Loads ) { SILFunction * F = Load -> getFunction ( ) ; auto cloneInitAt = [ & ] ( SILInstruction * insertionPoint ) -> SILValue { InitSequenceCloner cloner ( init , insertionPoint ) ; return cloner . clone ( ) ; } ; if ( isa < RefElementAddrInst > ( Load ) || isa < StructElementAddrInst > ( Load ) || isa < BeginAccessInst > ( Load ) ) { auto proj = cast < SingleValueInstruction > ( Load ) ; SILValue clonedInit = cloneInitAt ( proj ) ; SILBuilderWithScope B ( proj ) ; for ( auto UI = proj -> use_begin ( ) , E = proj -> use_end ( ) ; UI != E ; ) { auto * User = UI -> getUser ( ) ; ++ UI ; if ( isIncidentalUse ( User ) ) continue ; if ( isa < BeginAccessInst > ( User ) ) continue ; if ( isa < StoreInst > ( User ) ) continue ; replaceLoadSequence ( User , clonedInit , B ) ; eraseUsesOfInstruction ( User ) ; User -> eraseFromParent ( ) ; ++ NumReplaced ; } ChangedFunctions . insert ( F ) ; } else if ( auto proj = dyn_cast < StructExtractInst > ( Load ) ) { SILValue clonedInit = cloneInitAt ( proj ) ; proj -> replaceAllUsesWith ( clonedInit ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Access ▁ to ▁ " << * Property << " ▁ was ▁ replaced : \n " ; clonedInit -> dumpInContext ( ) ) ; proj -> eraseFromParent ( ) ; ++ NumReplaced ; ChangedFunctions . insert ( F ) ; } } LLVM_DEBUG ( llvm :: dbgs ( ) << " Access ▁ to ▁ " << * Property << " ▁ was ▁ replaced ▁ " << NumReplaced << " ▁ time ( s ) \n " ) ; if ( CanRemove ) { } } static bool isStructurallyIdentical ( SILValue LHS , SILValue RHS ) { if ( LHS == RHS ) return true ; if ( LHS -> getType ( ) != RHS -> getType ( ) ) return false ; auto lResult = LHS -> getDefiningInstructionResult ( ) ; auto rResult = RHS -> getDefiningInstructionResult ( ) ; assert ( lResult && rResult && " operands ▁ of ▁ instructions ▁ approved ▁ by ▁ analyzeStaticInitializer ▁ " " should ▁ always ▁ be ▁ defined ▁ by ▁ instructions " ) ; return ( lResult -> ResultIndex == rResult -> ResultIndex && lResult -> Instruction -> isIdenticalTo ( rResult -> Instruction , isStructurallyIdentical ) ) ; } ; static bool isSameInitSequence ( const InitSequence & LHS , const InitSequence & RHS ) { assert ( LHS . isValid ( ) && RHS . isValid ( ) ) ; return isStructurallyIdentical ( LHS . Result , RHS . Result ) ; } static bool isAssignableExternally ( VarDecl * Property , SILModule * Module ) { if ( Module -> isVisibleExternally ( Property ) ) { auto * Ty = dyn_cast < NominalTypeDecl > ( Property -> getDeclContext ( ) ) ; if ( isa < ClassDecl > ( Ty ) ) return false ; for ( auto SP : Ty -> getStoredProperties ( ) ) { auto storedPropertyAccess = SP -> getEffectiveAccess ( ) ; if ( storedPropertyAccess <= AccessLevel :: FilePrivate || ( storedPropertyAccess <= AccessLevel :: Internal && Module -> isWholeModule ( ) ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ cannot ▁ be ▁ set ▁ externally \n " ) ; return false ; } } LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ can ▁ be ▁ used ▁ externally \n " ) ; return true ; } return false ; } static bool mayHaveUnknownUses ( VarDecl * Property , SILModule * Module ) { if ( Property -> getDeclContext ( ) -> getParentModule ( ) != Module -> getSwiftModule ( ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ is ▁ defined ▁ in ▁ a ▁ different ▁ module \n " ) ; return true ; } if ( isAssignableExternally ( Property , Module ) ) { return true ; } return false ; } bool LetPropertiesOpt :: isConstantLetProperty ( VarDecl * Property ) { if ( ! Property -> isLet ( ) || Property -> isStatic ( ) ) return false ; if ( SkipProcessing . count ( Property ) ) return false ; if ( PotentialConstantLetProperty . count ( Property ) ) return true ; if ( mayHaveUnknownUses ( Property , Module ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ may ▁ have ▁ unknown ▁ uses \n " ) ; SkipProcessing . insert ( Property ) ; return false ; } LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ has ▁ no ▁ unknown ▁ uses \n " ) ; if ( ! isSimpleType ( Module -> Types . getLoweredType ( Property -> getType ( ) ) , * Module ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ is ▁ not ▁ of ▁ trivial ▁ type \n " ) ; SkipProcessing . insert ( Property ) ; return false ; } PotentialConstantLetProperty . insert ( Property ) ; return true ; } static bool isProjectionOfProperty ( SILValue addr , VarDecl * Property ) { if ( auto * REA = dyn_cast < RefElementAddrInst > ( addr ) ) { return REA -> getField ( ) == Property ; } if ( auto * SEA = dyn_cast < StructElementAddrInst > ( addr ) ) { return SEA -> getField ( ) == Property ; } return false ; } bool LetPropertiesOpt :: analyzeInitValue ( SILInstruction * I , VarDecl * Property ) { SILValue value ; if ( auto SI = dyn_cast < StructInst > ( I ) ) { value = SI -> getFieldValue ( Property ) ; } else if ( auto SI = dyn_cast < StoreInst > ( I ) ) { auto Dest = stripAddressAccess ( SI -> getDest ( ) ) ; assert ( isProjectionOfProperty ( stripAddressAccess ( SI -> getDest ( ) ) , Property ) && " Store ▁ instruction ▁ should ▁ store ▁ into ▁ a ▁ proper ▁ let ▁ property " ) ; ( void ) Dest ; value = SI -> getSrc ( ) ; } if ( auto * LI = dyn_cast < LoadInst > ( value ) ) { SILValue addr = LI -> getOperand ( ) ; if ( isProjectionOfProperty ( addr , Property ) ) return true ; } InitSequence sequence ; sequence . Result = value ; if ( ! analyzeStaticInitializer ( value , sequence . Instructions ) ) return false ; auto & cachedSequence = InitMap [ Property ] ; if ( cachedSequence . isValid ( ) && ! isSameInitSequence ( cachedSequence , sequence ) ) { return false ; } else { LLVM_DEBUG ( llvm :: dbgs ( ) << " The ▁ value ▁ of ▁ property ▁ ' " << * Property << " ' ▁ is ▁ statically ▁ known ▁ so ▁ far \n " ) ; cachedSequence = std :: move ( sequence ) ; return true ; } } void LetPropertiesOpt :: collectStructPropertiesAccess ( StructInst * SI , bool NonRemovable ) { auto structDecl = SI -> getStructDecl ( ) ; if ( SkipTypeProcessing . count ( structDecl ) ) return ; if ( ! NominalTypeLetProperties . count ( structDecl ) ) { SmallVector < VarDecl * , 4 > LetProps ; for ( auto Prop : structDecl -> getStoredProperties ( ) ) { if ( ! isConstantLetProperty ( Prop ) ) continue ; LetProps . push_back ( Prop ) ; } if ( LetProps . empty ( ) ) { SkipTypeProcessing . insert ( structDecl ) ; return ; } NominalTypeLetProperties [ structDecl ] = LetProps ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Computed ▁ set ▁ of ▁ let ▁ properties ▁ for ▁ struct ▁ ' " << structDecl -> getName ( ) << " ' \n " ) ; } auto & Props = NominalTypeLetProperties [ structDecl ] ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Found ▁ a ▁ struct ▁ instruction ▁ initializing ▁ some ▁ " " let ▁ properties : ▁ " ; SI -> dumpInContext ( ) ) ; for ( auto Prop : Props ) { if ( SkipProcessing . count ( Prop ) ) continue ; SILValue PropValue = SI -> getOperandForField ( Prop ) -> get ( ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Check ▁ the ▁ value ▁ of ▁ property ▁ ' " << * Prop << " ' ▁ : " << PropValue << " \n " ) ; if ( ! analyzeInitValue ( SI , Prop ) ) { SkipProcessing . insert ( Prop ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " The ▁ value ▁ of ▁ a ▁ let ▁ property ▁ ' " << * Prop << " ' ▁ is ▁ not ▁ statically ▁ known \n " ) ; } ( void ) PropValue ; } } static bool isValidPropertyLoad ( SILInstruction * I ) { if ( isa < LoadInst > ( I ) ) return true ; if ( isa < StructElementAddrInst > ( I ) || isa < TupleElementAddrInst > ( I ) ) { auto projection = cast < SingleValueInstruction > ( I ) ; for ( auto Use : getNonDebugUses ( projection ) ) { if ( isIncidentalUse ( Use -> getUser ( ) ) ) continue ; if ( ! isValidPropertyLoad ( Use -> getUser ( ) ) ) return false ; } return true ; } return false ; } void LetPropertiesOpt :: collectPropertyAccess ( SILInstruction * I , VarDecl * Property , bool NonRemovable ) { if ( ! isConstantLetProperty ( Property ) ) return ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Collecting ▁ property ▁ access ▁ for ▁ property ▁ ' " << * Property << " ' : \n " ; llvm :: dbgs ( ) << " The ▁ instructions ▁ are : \n " ; I -> dumpInContext ( ) ) ; if ( isa < RefElementAddrInst > ( I ) || isa < StructElementAddrInst > ( I ) || isa < BeginAccessInst > ( I ) ) { auto projection = cast < SingleValueInstruction > ( I ) ; for ( auto Use : getNonDebugUses ( projection ) ) { auto * User = Use -> getUser ( ) ; if ( isIncidentalUse ( User ) ) continue ; if ( isa < BeginAccessInst > ( User ) ) continue ; if ( auto * SI = dyn_cast < StoreInst > ( User ) ) { if ( SI -> getDest ( ) != projection || ! analyzeInitValue ( SI , Property ) ) { SkipProcessing . insert ( Property ) ; return ; } continue ; } if ( ! isValidPropertyLoad ( User ) ) { SkipProcessing . insert ( Property ) ; return ; } } } AccessMap [ Property ] . push_back ( I ) ; if ( NonRemovable ) CannotRemove . insert ( Property ) ; } void LetPropertiesOpt :: run ( SILModuleTransform * T ) { for ( auto & F : * Module ) { bool NonRemovable = ! F . shouldOptimize ( ) ; for ( auto & BB : F ) { for ( auto & I : BB ) if ( auto * BAI = dyn_cast < BeginAccessInst > ( & I ) ) { if ( auto * REAI = dyn_cast < RefElementAddrInst > ( stripAddressAccess ( BAI ) ) ) { collectPropertyAccess ( BAI , REAI -> getField ( ) , NonRemovable ) ; } } else if ( auto * REAI = dyn_cast < RefElementAddrInst > ( & I ) ) { collectPropertyAccess ( REAI , REAI -> getField ( ) , NonRemovable ) ; } else if ( auto * SEI = dyn_cast < StructExtractInst > ( & I ) ) { collectPropertyAccess ( SEI , SEI -> getField ( ) , NonRemovable ) ; } else if ( auto * SEAI = dyn_cast < StructElementAddrInst > ( & I ) ) { collectPropertyAccess ( SEAI , SEAI -> getField ( ) , NonRemovable ) ; } else if ( auto * SI = dyn_cast < StructInst > ( & I ) ) { collectStructPropertiesAccess ( SI , NonRemovable ) ; } } } for ( auto & Init : InitMap ) { optimizeLetPropertyAccess ( Init . first , Init . second ) ; } for ( SILFunction * ChangedFn : ChangedFunctions ) { T -> invalidateAnalysis ( ChangedFn , SILAnalysis :: InvalidationKind :: Instructions ) ; } } namespace { class LetPropertiesOptPass : public SILModuleTransform { void run ( ) override { LetPropertiesOpt ( getModule ( ) ) . run ( this ) ; } } ; } SILTransform * swift :: createLetPropertiesOpt ( ) { return new LetPropertiesOptPass ( ) ; } </DOCUMENT>
<DOCUMENT_ID="hyuk-kim-tmax/OFASM-test/tree/master/Mtest/UNKNOWN/MVI01/main.cpp"> # include < stdlib . h > # include < string . h > extern int MVI01 ( char * p_0 , char * p_1 , char * p_2 ) ; int main ( ) { char * p_0 = ( char * ) malloc ( sizeof ( char ) * 7 ) ; char * p_1_0 = ( char * ) malloc ( sizeof ( char ) * 7 ) ; char * p_1 = ( char * ) & p_1_0 ; char * p_2 = ( char * ) malloc ( sizeof ( char ) * 3 ) ; strcpy ( p_0 , " HELLO ▁ " ) ; strcpy ( p_1_0 , " WORLD ▁ " ) ; strcpy ( p_2 , " ! ! " ) ; MVI01 ( p_0 , p_1 , p_2 ) ; MVI01 ( p_0 , p_1 , p_2 ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="Pumpuli/multitheftauto/tree/master/vendor/cegui-0.4.0-custom/WidgetSets/Falagard/src/FalCheckbox.cpp"> # include " StdInc . h " # include " FalCheckbox . h " # include " falagard / CEGUIFalWidgetLookManager . h " # include " falagard / CEGUIFalWidgetLookFeel . h " namespace CEGUI { const utf8 FalagardCheckbox :: WidgetTypeName [ ] = " Falagard / Checkbox " ; FalagardCheckbox :: FalagardCheckbox ( const String & type , const String & name ) : Checkbox ( type , name ) { } FalagardCheckbox :: ~ FalagardCheckbox ( ) { } void FalagardCheckbox :: drawSelf ( float z ) { Checkbox :: drawSelf ( z ) ; Window :: drawSelf ( z ) ; } void FalagardCheckbox :: drawNormal ( float z ) { doButtonRender ( d_selected ? " SelectedNormal " : " Normal " ) ; } void FalagardCheckbox :: drawHover ( float z ) { doButtonRender ( d_selected ? " SelectedHover " : " Hover " ) ; } void FalagardCheckbox :: drawPushed ( float z ) { doButtonRender ( d_selected ? " SelectedPushed " : " Pushed " ) ; } void FalagardCheckbox :: drawDisabled ( float z ) { doButtonRender ( d_selected ? " SelectedDisabled " : " Disabled " ) ; } void FalagardCheckbox :: doButtonRender ( const String & state ) { if ( d_needsRedraw ) { const StateImagery * imagery ; d_renderCache . clearCachedImagery ( ) ; d_needsRedraw = false ; try { const WidgetLookFeel & wlf = WidgetLookManager :: getSingleton ( ) . getWidgetLook ( d_lookName ) ; imagery = wlf . isStateImageryPresent ( state ) ? & wlf . getStateImagery ( state ) : d_selected ? & wlf . getStateImagery ( " SelectedNormal " ) : & wlf . getStateImagery ( " Normal " ) ; } catch ( UnknownObjectException ) { return ; } imagery -> render ( * this ) ; } } Window * FalagardCheckboxFactory :: createWindow ( const String & name ) { return new FalagardCheckbox ( d_type , name ) ; } void FalagardCheckboxFactory :: destroyWindow ( Window * window ) { delete window ; } } </DOCUMENT>
<DOCUMENT_ID="dolphin-emu/dolphin/tree/master/Source/Core/VideoCommon/OnScreenDisplay.cpp"> # include " VideoCommon / OnScreenDisplay . h " # include < algorithm > # include < map > # include < mutex > # include < string > # include < fmt / format . h > # include < imgui . h > # include " Common / CommonTypes . h " # include " Common / Timer . h " # include " Core / ConfigManager . h " namespace OSD { constexpr float LEFT_MARGIN = 10.0f ; constexpr float TOP_MARGIN = 10.0f ; constexpr float WINDOW_PADDING = 4.0f ; struct Message { Message ( ) = default ; Message ( std :: string text_ , u32 timestamp_ , u32 color_ ) : text ( std :: move ( text_ ) ) , timestamp ( timestamp_ ) , color ( color_ ) { } std :: string text ; u32 timestamp = 0 ; u32 color = 0 ; } ; static std :: multimap < MessageType , Message > s_messages ; static std :: mutex s_messages_mutex ; static ImVec4 RGBAToImVec4 ( const u32 rgba ) { return ImVec4 ( static_cast < float > ( ( rgba >> 16 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 8 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 0 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 24 ) & 0xFF ) / 255.0f ) ; } static float DrawMessage ( int index , const Message & msg , const ImVec2 & position , int time_left ) { const std :: string window_name = fmt :: format ( " osd _ { } " , index ) ; ImGui :: SetNextWindowPos ( position ) ; ImGui :: SetNextWindowSize ( ImVec2 ( 0.0f , 0.0f ) ) ; const float alpha = std :: min ( 1.0f , std :: max ( 0.0f , time_left / 1024.0f ) ) ; ImGui :: PushStyleVar ( ImGuiStyleVar_Alpha , alpha ) ; float window_height = 0.0f ; if ( ImGui :: Begin ( window_name . c_str ( ) , nullptr , ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoFocusOnAppearing ) ) { ImGui :: TextColored ( RGBAToImVec4 ( msg . color ) , " % s " , msg . text . c_str ( ) ) ; window_height = ImGui :: GetWindowSize ( ) . y + ( WINDOW_PADDING * ImGui :: GetIO ( ) . DisplayFramebufferScale . y ) ; } ImGui :: End ( ) ; ImGui :: PopStyleVar ( ) ; return window_height ; } void AddTypedMessage ( MessageType type , std :: string message , u32 ms , u32 rgba ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . erase ( type ) ; s_messages . emplace ( type , Message ( std :: move ( message ) , Common :: Timer :: GetTimeMs ( ) + ms , rgba ) ) ; } void AddMessage ( std :: string message , u32 ms , u32 rgba ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . emplace ( MessageType :: Typeless , Message ( std :: move ( message ) , Common :: Timer :: GetTimeMs ( ) + ms , rgba ) ) ; } void DrawMessages ( ) { if ( ! SConfig :: GetInstance ( ) . bOnScreenDisplayMessages ) return ; { std :: lock_guard lock { s_messages_mutex } ; const u32 now = Common :: Timer :: GetTimeMs ( ) ; float current_x = LEFT_MARGIN * ImGui :: GetIO ( ) . DisplayFramebufferScale . x ; float current_y = TOP_MARGIN * ImGui :: GetIO ( ) . DisplayFramebufferScale . y ; int index = 0 ; auto it = s_messages . begin ( ) ; while ( it != s_messages . end ( ) ) { const Message & msg = it -> second ; const int time_left = static_cast < int > ( msg . timestamp - now ) ; current_y += DrawMessage ( index ++ , msg , ImVec2 ( current_x , current_y ) , time_left ) ; if ( time_left <= 0 ) it = s_messages . erase ( it ) ; else ++ it ; } } } void ClearMessages ( ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . clear ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="thivod/forgottenserver/tree/master/src/trashholder.cpp"> # include " otpch . h " # include " trashholder . h " # include " game . h " extern Game g_game ; TrashHolder :: TrashHolder ( uint16_t _type ) : Item ( _type ) { } TrashHolder :: ~ TrashHolder ( ) { } ReturnValue TrashHolder :: __queryAdd ( int32_t , const Thing * , uint32_t , uint32_t , Creature * ) const { return RET_NOERROR ; } ReturnValue TrashHolder :: __queryMaxCount ( int32_t , const Thing * , uint32_t count , uint32_t & maxQueryCount , uint32_t ) const { maxQueryCount = std :: max < uint32_t > ( 1 , count ) ; return RET_NOERROR ; } ReturnValue TrashHolder :: __queryRemove ( const Thing * , uint32_t , uint32_t ) const { return RET_NOTPOSSIBLE ; } Cylinder * TrashHolder :: __queryDestination ( int32_t & , const Thing * , Item * * , uint32_t & ) { return this ; } void TrashHolder :: __addThing ( Thing * thing ) { return __addThing ( 0 , thing ) ; } void TrashHolder :: __addThing ( int32_t , Thing * thing ) { Item * item = thing -> getItem ( ) ; if ( ! item ) { return ; } if ( item == this || ! item -> hasProperty ( CONST_PROP_MOVEABLE ) ) { return ; } if ( item -> isHangable ( ) && isGroundTile ( ) ) { Tile * tile = dynamic_cast < Tile * > ( getParent ( ) ) ; if ( tile && tile -> hasFlag ( TILESTATE_SUPPORTS_HANGABLE ) ) { return ; } } g_game . internalRemoveItem ( item ) ; const ItemType & it = Item :: items [ getID ( ) ] ; if ( it . magicEffect != CONST_ME_NONE ) { g_game . addMagicEffect ( getPosition ( ) , it . magicEffect ) ; } } void TrashHolder :: __updateThing ( Thing * , uint16_t , uint32_t ) { } void TrashHolder :: __replaceThing ( uint32_t , Thing * ) { } void TrashHolder :: __removeThing ( Thing * , uint32_t ) { } void TrashHolder :: postAddNotification ( Thing * thing , const Cylinder * oldParent , int32_t index , cylinderlink_t ) { getParent ( ) -> postAddNotification ( thing , oldParent , index , LINK_PARENT ) ; } void TrashHolder :: postRemoveNotification ( Thing * thing , const Cylinder * newParent , int32_t index , bool isCompleteRemoval , cylinderlink_t ) { getParent ( ) -> postRemoveNotification ( thing , newParent , index , isCompleteRemoval , LINK_PARENT ) ; } </DOCUMENT>
<DOCUMENT_ID="cypsun/FreeCAD/tree/master/src/Mod/Robot/Gui/ViewProviderTrajectory.cpp"> # include " PreCompiled . h " # ifndef _PreComp_ # include < Inventor / SoDB . h > # include < Inventor / SoInput . h > # include < Inventor / SbVec3f . h > # include < Inventor / nodes / SoSeparator . h > # include < Inventor / nodes / SoTransform . h > # include < Inventor / nodes / SoSphere . h > # include < Inventor / nodes / SoRotation . h > # include < Inventor / actions / SoSearchAction . h > # include < Inventor / draggers / SoJackDragger . h > # include < Inventor / VRMLnodes / SoVRMLTransform . h > # include < Inventor / nodes / SoBaseColor . h > # include < Inventor / nodes / SoCoordinate3 . h > # include < Inventor / nodes / SoDrawStyle . h > # include < Inventor / nodes / SoFaceSet . h > # include < Inventor / nodes / SoLineSet . h > # include < Inventor / nodes / SoMarkerSet . h > # include < Inventor / nodes / SoShapeHints . h > # include < QFile > # endif # include " ViewProviderTrajectory . h " # include < Mod / Robot / App / TrajectoryObject . h > # include < Mod / Robot / App / Trajectory . h > # include < App / Document . h > # include < Base / FileInfo . h > # include < Base / Stream . h > # include < Base / Console . h > # include < sstream > using namespace Gui ; using namespace RobotGui ; using namespace Robot ; PROPERTY_SOURCE ( RobotGui :: ViewProviderTrajectory , Gui :: ViewProviderGeometryObject ) ViewProviderTrajectory :: ViewProviderTrajectory ( ) { pcTrajectoryRoot = new Gui :: SoFCSelection ( ) ; pcTrajectoryRoot -> highlightMode = Gui :: SoFCSelection :: OFF ; pcTrajectoryRoot -> selectionMode = Gui :: SoFCSelection :: SEL_OFF ; pcTrajectoryRoot -> ref ( ) ; pcCoords = new SoCoordinate3 ( ) ; pcCoords -> ref ( ) ; pcDrawStyle = new SoDrawStyle ( ) ; pcDrawStyle -> ref ( ) ; pcDrawStyle -> style = SoDrawStyle :: LINES ; pcDrawStyle -> lineWidth = 2 ; pcLines = new SoLineSet ; pcLines -> ref ( ) ; } ViewProviderTrajectory :: ~ ViewProviderTrajectory ( ) { pcTrajectoryRoot -> unref ( ) ; pcCoords -> unref ( ) ; pcDrawStyle -> unref ( ) ; pcLines -> unref ( ) ; } void ViewProviderTrajectory :: attach ( App :: DocumentObject * pcObj ) { ViewProviderDocumentObject :: attach ( pcObj ) ; SoSeparator * linesep = new SoSeparator ; SoBaseColor * basecol = new SoBaseColor ; basecol -> rgb . setValue ( 1.0f , 0.5f , 0.0f ) ; linesep -> addChild ( basecol ) ; linesep -> addChild ( pcCoords ) ; linesep -> addChild ( pcLines ) ; SoBaseColor * markcol = new SoBaseColor ; markcol -> rgb . setValue ( 1.0f , 1.0f , 0.0f ) ; SoMarkerSet * marker = new SoMarkerSet ; marker -> markerIndex = SoMarkerSet :: CROSS_5_5 ; linesep -> addChild ( markcol ) ; linesep -> addChild ( marker ) ; pcTrajectoryRoot -> addChild ( linesep ) ; addDisplayMaskMode ( pcTrajectoryRoot , " Waypoints " ) ; pcTrajectoryRoot -> objectName = pcObj -> getNameInDocument ( ) ; pcTrajectoryRoot -> documentName = pcObj -> getDocument ( ) -> getName ( ) ; pcTrajectoryRoot -> subElementName = " Main " ; } void ViewProviderTrajectory :: setDisplayMode ( const char * ModeName ) { if ( strcmp ( " Waypoints " , ModeName ) == 0 ) setDisplayMaskMode ( " Waypoints " ) ; ViewProviderGeometryObject :: setDisplayMode ( ModeName ) ; } std :: vector < std :: string > ViewProviderTrajectory :: getDisplayModes ( void ) const { std :: vector < std :: string > StrList ; StrList . push_back ( " Waypoints " ) ; return StrList ; } void ViewProviderTrajectory :: updateData ( const App :: Property * prop ) { Robot :: TrajectoryObject * pcTracObj = static_cast < Robot :: TrajectoryObject * > ( pcObject ) ; if ( prop == & pcTracObj -> Trajectory ) { const Trajectory & trak = pcTracObj -> Trajectory . getValue ( ) ; pcCoords -> point . deleteValues ( 0 ) ; pcCoords -> point . setNum ( trak . getSize ( ) ) ; for ( unsigned int i = 0 ; i < trak . getSize ( ) ; ++ i ) { Base :: Vector3d pos = trak . getWaypoint ( i ) . EndPos . getPosition ( ) ; pcCoords -> point . set1Value ( i , pos . x , pos . y , pos . z ) ; } pcLines -> numVertices . set1Value ( 0 , trak . getSize ( ) ) ; } else if ( prop == & pcTracObj -> Base ) { Base :: Placement loc = * ( & pcTracObj -> Base . getValue ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="dysonltd/gts/tree/master/app/src/tools/core/components/FloorPlanning.cpp"> # include " RoomsCollection . h " # include " CamerasCollection . h " # include " CameraPositionsCollection . h " # include " CalibrationSchema . h " # include " ExtrinsicCalibrationSchema . h " # include " CameraPositionSchema . h " # include " RoomLayoutSchema . h " # include " FloorPlanSchema . h " # include " CalibrationAlgorithm . h " # include " WbConfigTools . h " # include " WbConfig . h " # include " GroundPlaneUtility . h " # include " OpenCvUtility . h " # include " RobotMetrics . h " # include " CameraCalibration . h " # include " FileUtilities . h " # include " FileDialogs . h " # include " Message . h " # include " Logging . h " # include < QFileDialog > # include < QtGlobal > # include < opencv / cv . h > # include < opencv / highgui . h > # include < iostream > # include < algorithm > namespace FloorPlanning { bool LoadFile ( WbConfig config , KeyId cameraPosition , IplImage * * camImg , QString fileName , CvPoint2D32f * offset , bool unWarp ) { bool successful = true ; Collection camerasCollection ( CamerasCollection ( ) ) ; Collection cameraPositionsCollection ( CameraPositionsCollection ( ) ) ; camerasCollection . SetConfig ( config ) ; cameraPositionsCollection . SetConfig ( config ) ; const KeyId camPosId = cameraPosition ; LOG_INFO ( QObject :: tr ( " Camera ▁ position ▁ id : ▁ % 1" ) . arg ( camPosId ) ) ; const WbConfig camPosConfig = cameraPositionsCollection . ElementById ( camPosId ) ; if ( camPosConfig . IsNull ( ) ) successful = false ; CvMat * cameraMtx = cvCreateMat ( 3 , 3 , CV_32F ) ; CvMat * distortionCoeffs = cvCreateMat ( 5 , 1 , CV_32F ) ; CvMat * inverseCoeffs = cvCreateMat ( 5 , 1 , CV_32F ) ; CvMat * rot = cvCreateMat ( 3 , 3 , CV_32F ) ; CvMat * trans = cvCreateMat ( 1 , 3 , CV_32F ) ; if ( successful ) { const KeyId camId = camPosConfig . GetKeyValue ( CameraPositionSchema :: cameraIdKey ) . ToKeyId ( ) ; LOG_INFO ( QObject :: tr ( " Camera ▁ id : ▁ % 1" ) . arg ( camId ) ) ; WbConfig cameraConfig = camerasCollection . ElementById ( camId ) ; if ( cameraConfig . IsNull ( ) ) successful = false ; if ( successful ) { const WbConfig cameraIntrisicConfig ( cameraConfig . GetSubConfig ( CalibrationSchema :: schemaName ) ) ; if ( cameraIntrisicConfig . IsNull ( ) ) successful = false ; if ( successful ) { const bool calibrationWasSuccessful = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: calibrationSuccessfulKey ) . ToBool ( ) ; const bool cameraMtxValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: cameraMatrixKey ) . ToCvMat ( * cameraMtx ) ; const bool distortionCoeffsValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: distortionCoefficientsKey ) . ToCvMat ( * distortionCoeffs ) ; const bool inverseCoeffsValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: invDistortionCoefficientsKey ) . ToCvMat ( * inverseCoeffs ) ; successful = calibrationWasSuccessful && cameraMtxValid && distortionCoeffsValid && inverseCoeffsValid ; } const WbConfig cameraExtrisicConfig ( camPosConfig . GetSubConfig ( ExtrinsicCalibrationSchema :: schemaName ) ) ; if ( cameraExtrisicConfig . IsNull ( ) ) successful = false ; if ( successful ) { const bool rotMatValid = cameraExtrisicConfig . GetKeyValue ( ExtrinsicCalibrationSchema :: rotationMatrixKey ) . ToCvMat ( * rot ) ; const bool transValid = cameraExtrisicConfig . GetKeyValue ( ExtrinsicCalibrationSchema :: translationKey ) . ToCvMat ( * trans ) ; successful = rotMatValid && transValid ; } } } if ( successful ) { IplImage * imgGrey = cvLoadImage ( fileName . toAscii ( ) , CV_LOAD_IMAGE_GRAYSCALE ) ; if ( unWarp ) { * camImg = GroundPlaneUtility :: unwarpGroundPlane ( imgGrey , cameraMtx , distortionCoeffs , inverseCoeffs , rot , trans , offset ) ; } else { * camImg = cvCloneImage ( imgGrey ) ; } cvReleaseImage ( & imgGrey ) ; } cvReleaseMat ( & cameraMtx ) ; cvReleaseMat ( & distortionCoeffs ) ; cvReleaseMat ( & inverseCoeffs ) ; cvReleaseMat ( & rot ) ; cvReleaseMat ( & trans ) ; return successful ; } bool CheckMappingIsComplete ( WbConfig config ) { bool allMapped = true ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; bool found = false ; LOG_INFO ( QObject :: tr ( " Checking ▁ mapping ▁ for ▁ % 1 . " ) . arg ( camPosId ) ) ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( ( camPosId == camera1Id ) || ( camPosId == camera2Id ) ) { found = true ; break ; } } if ( ! found ) { allMapped = false ; break ; } } return allMapped ; } bool IsBase ( WbConfig config , KeyId camId ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; bool base = false ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camId == camera1Id ) { base = true ; break ; } } return base ; } bool IsRef ( WbConfig config , KeyId camId ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; bool ref = false ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camId == camera2Id ) { ref = true ; break ; } } return ref ; } std :: vector < KeyId > FindRoot ( WbConfig config ) { std :: vector < KeyId > rootCamera ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; bool root = true ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camPosId == camera2Id ) { root = false ; break ; } } if ( root && IsBase ( config , camPosId ) ) { rootCamera . push_back ( camPosId ) ; } } return rootCamera ; } std :: vector < KeyId > FindChain ( WbConfig config , KeyId camId , KeyId rootId , std :: vector < KeyId > mappingChain ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; LOG_INFO ( QObject :: tr ( " Camera1 ▁ id ▁ = ▁ % 1 . " ) . arg ( camera1Id ) ) ; LOG_INFO ( QObject :: tr ( " Camera2 ▁ id ▁ = ▁ % 1 . " ) . arg ( camera2Id ) ) ; if ( camId == camera2Id ) { if ( std :: find ( mappingChain . begin ( ) , mappingChain . end ( ) , camera1Id ) == mappingChain . end ( ) ) { mappingChain . push_back ( camera1Id ) ; if ( camera1Id != rootId ) { LOG_INFO ( QObject :: tr ( " Find ▁ chain ▁ for ▁ % 1 ▁ - ▁ % 2 . " ) . arg ( camera1Id ) . arg ( rootId ) ) ; mappingChain = FindChain ( config , camera1Id , rootId , mappingChain ) ; } if ( mappingChain . back ( ) == rootId ) { LOG_INFO ( " Found . " ) ; break ; } else { mappingChain . pop_back ( ) ; } } } } return mappingChain ; } bool CheckRootMapping ( WbConfig config , KeyId rootId ) { bool allMapped = true ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; if ( ( camPosId != rootId ) && IsRef ( config , camPosId ) ) { LOG_INFO ( QObject :: tr ( " Find ▁ chain ▁ for ▁ % 1 ▁ - ▁ % 2 . " ) . arg ( camPosId ) . arg ( rootId ) ) ; std :: vector < KeyId > chain = FindChain ( config , camPosId , rootId , std :: vector < KeyId > ( ) ) ; if ( chain . size ( ) == 0 ) { LOG_INFO ( " Not ▁ found . " ) ; allMapped = false ; break ; } } } return allMapped ; } void ComputeTransform ( WbConfig config , KeyId refId , std :: vector < KeyId > chain , CvMat * transform ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( std :: vector < KeyId > :: iterator elt = chain . begin ( ) ; elt != chain . end ( ) ; ++ elt ) { for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( ( camera1Id == * elt ) && ( camera2Id == refId ) ) { CvMat * homography = cvCreateMat ( 3 , 3 , CV_32F ) ; const bool homographyValid = config . GetKeyValue ( FloorPlanSchema :: homographyKey , it -> id ) . ToCvMat ( * homography ) ; Q_UNUSED ( homographyValid ) ; CvMat * tmp = cvCreateMat ( 3 , 3 , CV_32F ) ; cvMatMul ( homography , transform , tmp ) ; cvmSet ( transform , 0 , 0 , cvmGet ( tmp , 0 , 0 ) ) ; cvmSet ( transform , 0 , 1 , cvmGet ( tmp , 0 , 1 ) ) ; cvmSet ( transform , 0 , 2 , cvmGet ( tmp , 0 , 2 ) ) ; cvmSet ( transform , 1 , 0 , cvmGet ( tmp , 1 , 0 ) ) ; cvmSet ( transform , 1 , 1 , cvmGet ( tmp , 1 , 1 ) ) ; cvmSet ( transform , 1 , 2 , cvmGet ( tmp , 1 , 2 ) ) ; cvmSet ( transform , 2 , 0 , cvmGet ( tmp , 2 , 0 ) ) ; cvmSet ( transform , 2 , 1 , cvmGet ( tmp , 2 , 1 ) ) ; cvmSet ( transform , 2 , 2 , cvmGet ( tmp , 2 , 2 ) ) ; cvReleaseMat ( & tmp ) ; cvReleaseMat ( & homography ) ; refId = * elt ; } } } } } </DOCUMENT>
<DOCUMENT_ID="mat12/mytest/tree/master/lib/gdi/sdl.cpp"> # include < lib / gdi / sdl . h > # include < lib / actions / action . h > # include < lib / base / init . h > # include < lib / base / init_num . h > # include < lib / driver / input_fake . h > # include < lib / driver / rcsdl . h > # include < SDL . h > gSDLDC :: gSDLDC ( ) : m_pump ( eApp , 1 ) { if ( SDL_Init ( SDL_INIT_VIDEO ) < 0 ) { eWarning ( " [ gSDLDC ] ▁ Could ▁ not ▁ initialize ▁ SDL : ▁ % s " , SDL_GetError ( ) ) ; return ; } setResolution ( 720 , 576 ) ; CONNECT ( m_pump . recv_msg , gSDLDC :: pumpEvent ) ; m_surface . type = 0 ; m_surface . clut . colors = 256 ; m_surface . clut . data = new gRGB [ m_surface . clut . colors ] ; m_pixmap = new gPixmap ( & m_surface ) ; memset ( m_surface . clut . data , 0 , sizeof ( * m_surface . clut . data ) * m_surface . clut . colors ) ; run ( ) ; } gSDLDC :: ~ gSDLDC ( ) { pushEvent ( EV_QUIT ) ; kill ( ) ; SDL_Quit ( ) ; } void gSDLDC :: keyEvent ( const SDL_Event & event ) { eSDLInputDriver * driver = eSDLInputDriver :: getInstance ( ) ; eDebug ( " [ gSDLDC ] ▁ Key ▁ % s : ▁ key = % d " , ( event . type == SDL_KEYDOWN ) ? " Down " : " Up " , event . key . keysym . sym ) ; if ( driver ) driver -> keyPressed ( & event . key ) ; } void gSDLDC :: pumpEvent ( const SDL_Event & event ) { switch ( event . type ) { case SDL_KEYDOWN : case SDL_KEYUP : keyEvent ( event ) ; break ; case SDL_QUIT : eDebug ( " [ gSDLDC ] ▁ Quit " ) ; extern void quitMainloop ( int exit_code ) ; quitMainloop ( 0 ) ; break ; } } void gSDLDC :: pushEvent ( enum event code , void * data1 , void * data2 ) { SDL_Event event ; event . type = SDL_USEREVENT ; event . user . code = code ; event . user . data1 = data1 ; event . user . data2 = data2 ; SDL_PushEvent ( & event ) ; } void gSDLDC :: exec ( const gOpcode * o ) { switch ( o -> opcode ) { case gOpcode :: flush : pushEvent ( EV_FLIP ) ; eDebug ( " [ gSDLDC ] ▁ FLUSH " ) ; break ; default : gDC :: exec ( o ) ; break ; } } void gSDLDC :: setResolution ( int xres , int yres ) { pushEvent ( EV_SET_VIDEO_MODE , ( void * ) xres , ( void * ) yres ) ; } void gSDLDC :: evSetVideoMode ( unsigned long xres , unsigned long yres ) { m_screen = SDL_SetVideoMode ( xres , yres , 32 , SDL_HWSURFACE ) ; if ( ! m_screen ) { eFatal ( " [ gSDLDC ] ▁ Could ▁ not ▁ create ▁ SDL ▁ surface : ▁ % s " , SDL_GetError ( ) ) ; return ; } m_surface . x = m_screen -> w ; m_surface . y = m_screen -> h ; m_surface . bpp = m_screen -> format -> BitsPerPixel ; m_surface . bypp = m_screen -> format -> BytesPerPixel ; m_surface . stride = m_screen -> pitch ; m_surface . data = m_screen -> pixels ; SDL_EnableUNICODE ( 1 ) ; } void gSDLDC :: evFlip ( ) { SDL_Flip ( m_screen ) ; } void gSDLDC :: thread ( ) { hasStarted ( ) ; bool stop = false ; while ( ! stop ) { SDL_Event event ; if ( SDL_WaitEvent ( & event ) ) { switch ( event . type ) { case SDL_KEYDOWN : case SDL_KEYUP : case SDL_QUIT : m_pump . send ( event ) ; break ; case SDL_USEREVENT : switch ( event . user . code ) { case EV_SET_VIDEO_MODE : evSetVideoMode ( ( unsigned long ) event . user . data1 , ( unsigned long ) event . user . data2 ) ; break ; case EV_FLIP : evFlip ( ) ; break ; case EV_QUIT : stop = true ; break ; } break ; } } } } eAutoInitPtr < gSDLDC > init_gSDLDC ( eAutoInitNumbers :: graphic - 1 , " gSDLDC " ) ; </DOCUMENT>
<DOCUMENT_ID="makhdumi/robomongo/tree/master/src/third-party/mongodb/src/mongo/db/pipeline/accumulator.cpp"> # include " pch . h " # include " db / pipeline / accumulator . h " # include " db / jsobj . h " # include " util / mongoutils / str . h " namespace mongo { using namespace mongoutils ; void Accumulator :: addOperand ( const intrusive_ptr < Expression > & pExpression ) { uassert ( 15943 , str :: stream ( ) << " group ▁ accumulator ▁ " << getOpName ( ) << " ▁ only ▁ accepts ▁ one ▁ operand " , vpOperand . size ( ) < 1 ) ; ExpressionNary :: addOperand ( pExpression ) ; } Accumulator :: Accumulator ( ) : ExpressionNary ( ) { } void Accumulator :: opToBson ( BSONObjBuilder * pBuilder , StringData opName , StringData fieldName , bool requireExpression ) const { verify ( vpOperand . size ( ) == 1 ) ; BSONObjBuilder builder ; vpOperand [ 0 ] -> addToBsonObj ( & builder , opName , requireExpression ) ; pBuilder -> append ( fieldName , builder . done ( ) ) ; } void Accumulator :: addToBsonObj ( BSONObjBuilder * pBuilder , StringData fieldName , bool requireExpression ) const { opToBson ( pBuilder , getOpName ( ) , fieldName , requireExpression ) ; } void Accumulator :: addToBsonArray ( BSONArrayBuilder * pBuilder ) const { verify ( false ) ; } void agg_framework_reservedErrors ( ) { uassert ( 16030 , " reserved ▁ error " , false ) ; uassert ( 16031 , " reserved ▁ error " , false ) ; uassert ( 16032 , " reserved ▁ error " , false ) ; uassert ( 16033 , " reserved ▁ error " , false ) ; uassert ( 16036 , " reserved ▁ error " , false ) ; uassert ( 16037 , " reserved ▁ error " , false ) ; uassert ( 16038 , " reserved ▁ error " , false ) ; uassert ( 16039 , " reserved ▁ error " , false ) ; uassert ( 16040 , " reserved ▁ error " , false ) ; uassert ( 16041 , " reserved ▁ error " , false ) ; uassert ( 16042 , " reserved ▁ error " , false ) ; uassert ( 16043 , " reserved ▁ error " , false ) ; uassert ( 16044 , " reserved ▁ error " , false ) ; uassert ( 16045 , " reserved ▁ error " , false ) ; uassert ( 16046 , " reserved ▁ error " , false ) ; uassert ( 16047 , " reserved ▁ error " , false ) ; uassert ( 16048 , " reserved ▁ error " , false ) ; uassert ( 16049 , " reserved ▁ error " , false ) ; } } </DOCUMENT>
<DOCUMENT_ID="pcolby/libqtaws/tree/master/src/ssm/describeinstancepatchstatesresponse.cpp"> # include " describeinstancepatchstatesresponse . h " # include " describeinstancepatchstatesresponse _ p . h " # include < QDebug > # include < QNetworkReply > # include < QXmlStreamReader > namespace QtAws { namespace SSM { DescribeInstancePatchStatesResponse :: DescribeInstancePatchStatesResponse ( const DescribeInstancePatchStatesRequest & request , QNetworkReply * const reply , QObject * const parent ) : SsmResponse ( new DescribeInstancePatchStatesResponsePrivate ( this ) , parent ) { setRequest ( new DescribeInstancePatchStatesRequest ( request ) ) ; setReply ( reply ) ; } const DescribeInstancePatchStatesRequest * DescribeInstancePatchStatesResponse :: request ( ) const { Q_D ( const DescribeInstancePatchStatesResponse ) ; return static_cast < const DescribeInstancePatchStatesRequest * > ( d -> request ) ; } void DescribeInstancePatchStatesResponse :: parseSuccess ( QIODevice & response ) { QXmlStreamReader xml ( & response ) ; } DescribeInstancePatchStatesResponsePrivate :: DescribeInstancePatchStatesResponsePrivate ( DescribeInstancePatchStatesResponse * const q ) : SsmResponsePrivate ( q ) { } void DescribeInstancePatchStatesResponsePrivate :: parseDescribeInstancePatchStatesResponse ( QXmlStreamReader & xml ) { Q_ASSERT ( xml . name ( ) == QLatin1String ( " DescribeInstancePatchStatesResponse " ) ) ; Q_UNUSED ( xml ) } } } </DOCUMENT>
<DOCUMENT_ID="slicer4ever/Lightwave/tree/master/Engine/Source/C++11/LWEProtocols/LWEProtocolWebSocketSecure.cpp"> # include " LWEProtocols / LWEProtocolWebSocketSecure . h " # include " LWEProtocols / LWEProtocolHTTP . h " # include < LWNetwork / LWSocket . h > # include < LWNetwork / LWProtocolManager . h > # include < LWCore / LWAllocator . h > # include < LWCore / LWCrypto . h > # include < LWCore / LWText . h > # include < LWCore / LWByteBuffer . h > # include < iostream > bool LWEProtocolWebSocketSecure :: ProcessRead ( LWSocket & Socket , const char * Buffer , uint32_t BufferLen ) { char Buf [ 256 ] ; char BufB [ 256 ] ; LWEWebSocket * WebSocket = ( LWEWebSocket * ) Socket . GetProtocolData ( m_wProtocolID ) ; if ( ! WebSocket ) { LWEHttpRequest Request ; uint32_t Error = 0 ; Error = Request . Deserialize ( Buffer , BufferLen ) ? 0 : 1 ; Error = Error ? Error : ( * Request . m_SecWebSockKey && Request . m_WebSockVersion == LWEWEBSOCKET_SUPPVER && Request . UpgradeConnection ( ) ) ? 0 : 2 ; if ( ! Error && * Request . m_SecWebSockProto ) { bool ValidProtocol = false ; if ( * m_SubProtocol ) { uint32_t ProtocolLen = ( uint32_t ) strlen ( m_SubProtocol ) ; for ( const char * C = Request . m_SecWebSockProto ; C && ! ValidProtocol ; C = LWText :: FirstToken ( C , ' , ' ) ) { C = LWText :: NextWord ( * C == ' , ' ? C + 1 : C , true ) ; ValidProtocol = LWText :: Compare ( C , m_SubProtocol , ProtocolLen ) ; } } if ( ! ValidProtocol ) Error = 3 ; } if ( Error ) { std :: cout << " Buffer : " << std :: endl << Buffer << std :: endl ; if ( Error == 1 ) std :: cout << " Error ▁ deserializing ▁ websocket ▁ request . " << std :: endl ; else if ( Error == 2 ) std :: cout << " Error ▁ Headers ▁ did ▁ not ▁ include ▁ correct ▁ websocket ▁ data . " << std :: endl ; else if ( Error == 3 ) std :: cout << " Error ▁ protocol ▁ asked ▁ for ▁ is ▁ not ▁ supported . " << std :: endl ; Socket . MarkClosable ( ) ; return false ; } WebSocket = m_Allocator . Allocate < LWEWebSocket > ( nullptr , nullptr ) ; WebSocket -> m_Socket = & Socket ; * Buf = ' \0' ; strncat ( Buf , Request . m_SecWebSockKey , sizeof ( Buf ) ) ; strncat ( Buf , LWEWEBSOCKET_GUID , sizeof ( Buf ) ) ; LWCrypto :: HashSHA1 ( Buf , ( uint32_t ) strlen ( Buf ) , BufB ) ; uint32_t * uBuf = ( uint32_t * ) BufB ; for ( uint32_t i = 0 ; i < 5 ; i ++ ) uBuf [ i ] = ( uBuf [ i ] & 0xFF ) << 24 | ( uBuf [ i ] & 0xFF00 ) << 8 | ( uBuf [ i ] & 0xFF0000 ) >> 8 | ( uBuf [ i ] & 0xFF000000 ) >> 24 ; uint32_t Len = LWCrypto :: Base64Encode ( BufB , 20 , WebSocket -> m_SecKey , sizeof ( WebSocket -> m_SecKey ) ) ; WebSocket -> m_SecKey [ Len ] = ' \0' ; WebSocket -> SetSecProtocols ( m_SubProtocol ) ; WebSocket -> SetHost ( Request . m_Host ) ; WebSocket -> SetPath ( Request . m_Path ) ; WebSocket -> SetOrigin ( Request . m_Origin ) ; WebSocket -> m_Flag |= LWEWebSocket :: CONNECTING_SERVER ; Socket . SetProtocolData ( m_wProtocolID , WebSocket ) ; PushOutPacket ( nullptr , 0 , WebSocket , LWEWebPacket :: CONTROL_CONNECT ) ; return true ; } if ( ! WebSocket -> IsConnected ( ) ) { if ( WebSocket -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_CLIENT ) { LWEHttpRequest Request ; uint32_t Error = 0 ; Error = Request . Deserialize ( Buffer , BufferLen ) ? 0 : 1 ; Error = Error ? Error : ( ( * Request . m_SecWebSockKey && Request . m_Status == LWEHttpRequest :: SwitchingProtocols ) ? 0 : 2 ) ; if ( Error ) { std :: cout << " Buffer : " << std :: endl << Buffer << std :: endl ; if ( Error == 1 ) std :: cout << " Error ▁ deserializing ▁ websocket ▁ request . " << std :: endl ; else if ( Error == 2 ) std :: cout << " Error ▁ headers ▁ did ▁ not ▁ include ▁ correct ▁ websocket ▁ data . " << std :: endl ; Socket . MarkClosable ( ) ; return false ; } WebSocket -> m_Flag = ( WebSocket -> m_Flag & ~ LWEWebSocket :: CONNECTING_CLIENT ) | LWEWebSocket :: CONNECTED_CLIENT ; } return true ; } char IPBuf [ 32 ] ; LWSocket :: MakeAddress ( Socket . GetRemoteIP ( ) , IPBuf , sizeof ( IPBuf ) ) ; if ( BufferLen > 100 ) { } LWEWebPacket * OPack ; uint32_t Target ; uint32_t ReservePos ; uint32_t o = 0 ; while ( o != BufferLen ) { uint32_t Res = WebSocket -> m_ActivePacket . Deserialize ( Buffer + o , BufferLen - o , m_Allocator ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ deserializing ▁ data . " << std :: endl ; return false ; } o += Res ; if ( ! WebSocket -> m_ActivePacket . Finished ( ) ) continue ; if ( WebSocket -> m_ActivePacket . m_DataLen != WebSocket -> m_ActivePacket . m_DataPos ) continue ; if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_CLOSED ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; Socket . MarkClosable ( ) ; return true ; } else if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_PING ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; PushOutPacket ( nullptr , 0 , WebSocket , LWEWebPacket :: CONTROL_PONG ) ; continue ; } else if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_PONG ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; continue ; } WebSocket -> m_ActivePacket . m_WebSocket = WebSocket ; if ( ! m_InPackets . PushStart ( & OPack , Target , ReservePos ) ) return false ; * OPack = std :: move ( WebSocket -> m_ActivePacket ) ; m_InPackets . PushFinished ( Target , ReservePos ) ; } return true ; } LWProtocol & LWEProtocolWebSocketSecure :: SocketClosed ( LWSocket & Socket , LWProtocolManager * Manager ) { LWEProtocolTLS :: SocketClosed ( Socket , Manager ) ; LWEWebSocket * WebSock = ( LWEWebSocket * ) Socket . GetProtocolData ( m_wProtocolID ) ; bool Del = true ; if ( m_WebSocketClosedCallback ) Del = m_WebSocketClosedCallback ( Socket , WebSock , Manager ) ; if ( WebSock ) WebSock -> m_Socket = nullptr ; if ( Del ) LWAllocator :: Destroy ( WebSock ) ; return * this ; } LWProtocol & LWEProtocolWebSocketSecure :: SocketChanged ( LWSocket & Prev , LWSocket & New , LWProtocolManager * Manager ) { LWEProtocolTLS :: SocketChanged ( Prev , New , Manager ) ; LWEWebSocket * WebSocket = ( LWEWebSocket * ) Prev . GetProtocolData ( m_wProtocolID ) ; New . SetProtocolData ( m_wProtocolID , Prev . GetProtocolData ( m_wProtocolID ) ) ; if ( WebSocket ) WebSocket -> m_Socket = & New ; if ( m_WebSocketChangedCallback ) m_WebSocketChangedCallback ( Prev , New , WebSocket , Manager ) ; return * this ; } LWProtocol & LWEProtocolWebSocketSecure :: ProcessTLSData ( LWSocket & Socket , const char * Data , uint32_t DataLen ) { ProcessRead ( Socket , Data , DataLen ) ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: ProcessOutPackets ( void ) { char Buffer [ 1024 * 64 ] ; LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; while ( m_OutPackets . PopStart ( & Pack , Target , ReservePos ) ) { LWEWebPacket RPack = std :: move ( * Pack ) ; m_OutPackets . PopFinshed ( Target , ReservePos ) ; LWEWebSocket * Sock = RPack . m_WebSocket ; if ( ! Sock -> IsConnected ( ) && ( RPack . m_ControlFlag & LWEWebPacket :: CONTROL_CONNECT ) ) { if ( ! Sock -> m_Socket ) return * this ; LWEHttpRequest Request ; Request . SetWebSockKey ( Sock -> m_SecKey ) ; Request . SetWebSockProto ( m_SubProtocol ) ; Request . m_Flag |= LWEHttpRequest :: ConnectionUpgrade | LWEHttpRequest :: UpgradeWebSock ; Request . m_Status = Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_SERVER ? LWEHttpRequest :: SwitchingProtocols : 0 ; if ( Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_CLIENT ) { Request . SetHost ( Sock -> m_Host ) . SetPath ( Sock -> m_Path ) . SetOrigin ( Sock -> m_Origin ) ; Request . m_WebSockVersion = LWEWEBSOCKET_SUPPVER ; } else Sock -> m_Flag = ( Sock -> m_Flag & ~ LWEWebSocket :: CONNECTING_SERVER ) | LWEWebSocket :: CONNECTED_SERVER ; uint32_t Len = Request . Serialize ( Buffer , sizeof ( Buffer ) , Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_CLIENT ? m_UserAgent : m_Server ) ; std :: cout << " Sending ▁ headers ! " << std :: endl ; uint32_t Res = Send ( * Sock -> m_Socket , Buffer , Len ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ sending ▁ data . " << std :: endl ; return * this ; } if ( ! Res ) { if ( Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_SERVER ) Sock -> m_Flag = ( Sock -> m_Flag & ~ LWEWebSocket :: CONNECTING_SERVER ) | LWEWebSocket :: CONNECTING_SERVER ; PushOutPacket ( nullptr , 0 , Sock , LWEWebPacket :: CONTROL_CONNECT ) ; return * this ; } } if ( RPack . m_ControlFlag & LWEWebPacket :: CONTROL_CONNECT ) continue ; if ( ! Sock -> IsConnected ( ) ) { if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) { std :: cout << " Error ▁ re - inserting ▁ packet . " << std :: endl ; return * this ; } * Pack = std :: move ( RPack ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; return * this ; } std :: cout << " Sending ▁ data : ▁ " << RPack . GetOp ( ) << " ▁ Len : ▁ " << RPack . m_DataLen << " ▁ Fin : ▁ " << RPack . m_ControlFlag << std :: endl ; LWSocket * rSock = RPack . m_WebSocket -> m_Socket ; if ( ! rSock ) continue ; uint32_t Len = RPack . Serialize ( Buffer , sizeof ( Buffer ) , Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_CLIENT ) ; std :: cout << " Serialized : ▁ " << Len << std :: endl ; uint32_t Res = Send ( * rSock , Buffer , Len ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ sending ▁ data . " << std :: endl ; return * this ; } if ( ! Res ) { if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) { std :: cout << " Error ▁ re - inserting ▁ packet . " << std :: endl ; return * this ; } * Pack = std :: move ( RPack ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; } } return * this ; } LWEWebSocket * LWEProtocolWebSocketSecure :: OpenSocket ( const char * URI , uint32_t ProtocolID , const char * Origin ) { char Host [ 256 ] ; char Path [ 256 ] ; char Protocol [ 256 ] ; uint16_t Port = LWEHttpRequest :: ParseURI ( URI , Host , sizeof ( Host ) , nullptr , Path , sizeof ( Path ) , nullptr , Protocol , sizeof ( Protocol ) , nullptr ) ; LWSocket Sock ; uint32_t Err = LWSocket :: CreateSocket ( Sock , Host , Port , LWSocket :: Tcp , ProtocolID ) ; if ( Err ) { std :: cout << " Error ▁ creating ▁ socket : ▁ " << Err << std :: endl ; return nullptr ; } LWSocket * S = m_Manager -> PushSocket ( Sock ) ; LWEWebSocket * WebSock = m_Allocator . Allocate < LWEWebSocket > ( URI , Origin ) ; WebSock -> m_Flag |= LWEWebSocket :: CONNECTING_CLIENT ; WebSock -> GenerateKey ( m_KeySeed ++ ) ; S -> SetProtocolData ( m_wProtocolID , WebSock ) ; WebSock -> m_Socket = S ; PushOutPacket ( nullptr , 0 , WebSock , LWEWebPacket :: CONTROL_CONNECT ) ; return WebSock ; } bool LWEProtocolWebSocketSecure :: PushOutPacket ( const char * Buffer , uint32_t BufferLen , LWEWebSocket * Socket , uint32_t ControlFlag ) { LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) return false ; * Pack = LWEWebPacket ( Buffer , BufferLen , m_Allocator , ControlFlag | LWEWebPacket :: CONTROL_FINISHED , Socket ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; return true ; } bool LWEProtocolWebSocketSecure :: GetNextPacket ( LWEWebPacket & Packet ) { LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; if ( ! m_InPackets . PopStart ( & Pack , Target , ReservePos ) ) return false ; Packet = std :: move ( * Pack ) ; m_InPackets . PopFinshed ( Target , ReservePos ) ; return true ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetServer ( const char * Server ) { * m_Server = ' \0' ; strncat ( m_Server , Server , sizeof ( m_Server ) ) ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetUserAgent ( const char * Agent ) { * m_UserAgent = ' \0' ; strncat ( m_UserAgent , Agent , sizeof ( m_UserAgent ) ) ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetSubProtocol ( const char * SubProtocol ) { * m_SubProtocol = ' \0' ; strncat ( m_SubProtocol , SubProtocol , sizeof ( m_SubProtocol ) ) ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetWebSocketClosedCallback ( std :: function < bool ( LWSocket & , LWEWebSocket * , LWProtocolManager * ) > WebSocketClosedCallback ) { m_WebSocketClosedCallback = WebSocketClosedCallback ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetWebSocketChangedCallback ( std :: function < void ( LWSocket & , LWSocket & , LWEWebSocket * , LWProtocolManager * ) > WebSocketChangedCallback ) { m_WebSocketChangedCallback = WebSocketChangedCallback ; return * this ; } LWEProtocolWebSocketSecure :: LWEProtocolWebSocketSecure ( uint32_t ProtocolID , uint32_t TLSProtocolID , LWAllocator & Allocator , LWProtocolManager * Manager , const char * CertFile , const char * KeyFile ) : LWEProtocolTLS ( TLSProtocolID , Allocator , CertFile , KeyFile ) , m_wProtocolID ( ProtocolID ) , m_Allocator ( Allocator ) , m_Manager ( Manager ) , m_KeySeed ( 0 ) { * m_Server = * m_UserAgent = * m_SubProtocol = ' \0' ; m_WebSocketClosedCallback = nullptr ; m_WebSocketChangedCallback = nullptr ; } </DOCUMENT>
<DOCUMENT_ID="Greymane/SkyFireEMU/tree/master/dep/acelite/ace/OS_NS_errno.cpp"> # include " ace / OS _ NS _ errno . h " # if ! defined ( ACE_HAS_INLINED_OSCALLS ) # include " ace / OS _ NS _ errno . inl " # endif </DOCUMENT>
<DOCUMENT_ID="mgsergio/omim/tree/master/base/osm_id.cpp"> # include " base / osm _ id . hpp " # include " base / assert . hpp " # include < sstream > namespace osm { static const uint64_t NODE = 0x4000000000000000ULL ; static const uint64_t WAY = 0x8000000000000000ULL ; static const uint64_t RELATION = 0xC000000000000000ULL ; static const uint64_t RESET = ~ ( NODE | WAY | RELATION ) ; Id :: Id ( uint64_t encodedId ) : m_encodedId ( encodedId ) { } Id Id :: Node ( uint64_t id ) { return Id ( id | NODE ) ; } Id Id :: Way ( uint64_t id ) { return Id ( id | WAY ) ; } Id Id :: Relation ( uint64_t id ) { return Id ( id | RELATION ) ; } uint64_t Id :: OsmId ( ) const { return m_encodedId & RESET ; } uint64_t Id :: EncodedId ( ) const { return m_encodedId ; } bool Id :: IsNode ( ) const { return ( ( m_encodedId & NODE ) == NODE ) ; } bool Id :: IsWay ( ) const { return ( ( m_encodedId & WAY ) == WAY ) ; } bool Id :: IsRelation ( ) const { return ( ( m_encodedId & RELATION ) == RELATION ) ; } std :: string Id :: Type ( ) const { if ( ( m_encodedId & RELATION ) == RELATION ) return " relation " ; else if ( ( m_encodedId & NODE ) == NODE ) return " node " ; else if ( ( m_encodedId & WAY ) == WAY ) return " way " ; else return " ERROR : ▁ Not ▁ initialized ▁ Osm ▁ ID " ; } std :: string DebugPrint ( osm :: Id const & id ) { std :: ostringstream stream ; stream << id . Type ( ) << " ▁ " << id . OsmId ( ) ; return stream . str ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="BillHally/boo/tree/master/lib/antlr-2.7.5/lib/cpp/src/TreeParser.cpp"> # include < iostream > # include " antlr / TreeParser . hpp " # include " antlr / ASTNULLType . hpp " # ifdef ANTLR_CXX_SUPPORTS_NAMESPACE namespace antlr { # endif RefAST TreeParser :: ASTNULL ( new ASTNULLType ) ; void TreeParser :: reportError ( const RecognitionException & ex ) { ANTLR_USE_NAMESPACE ( std ) cerr << ex . toString ( ) . c_str ( ) << ANTLR_USE_NAMESPACE ( std ) endl ; } void TreeParser :: reportError ( const ANTLR_USE_NAMESPACE ( std ) string & s ) { ANTLR_USE_NAMESPACE ( std ) cerr << " error : ▁ " << s . c_str ( ) << ANTLR_USE_NAMESPACE ( std ) endl ; } void TreeParser :: reportWarning ( const ANTLR_USE_NAMESPACE ( std ) string & s ) { ANTLR_USE_NAMESPACE ( std ) cerr << " warning : ▁ " << s . c_str ( ) << ANTLR_USE_NAMESPACE ( std ) endl ; } void TreeParser :: traceIndent ( ) { for ( int i = 0 ; i < traceDepth ; i ++ ) ANTLR_USE_NAMESPACE ( std ) cout << " ▁ " ; } void TreeParser :: traceIn ( const char * rname , RefAST t ) { traceDepth ++ ; traceIndent ( ) ; ANTLR_USE_NAMESPACE ( std ) cout << " > ▁ " << rname << " ( " << ( t ? t -> toString ( ) . c_str ( ) : " null " ) << " ) " << ( ( inputState -> guessing > 0 ) ? " ▁ [ guessing ] " : " " ) << ANTLR_USE_NAMESPACE ( std ) endl ; } void TreeParser :: traceOut ( const char * rname , RefAST t ) { traceIndent ( ) ; ANTLR_USE_NAMESPACE ( std ) cout << " < ▁ " << rname << " ( " << ( t ? t -> toString ( ) . c_str ( ) : " null " ) << " ) " << ( ( inputState -> guessing > 0 ) ? " ▁ [ guessing ] " : " " ) << ANTLR_USE_NAMESPACE ( std ) endl ; traceDepth -- ; } # ifdef ANTLR_CXX_SUPPORTS_NAMESPACE } # endif </DOCUMENT>
<DOCUMENT_ID="braingl/braingl/tree/master/src/algos/sdthread.cpp"> # include " sdthread . h " # include " . . / data / datasets / datasetdwi . h " # include " . . / gui / gl / glfunctions . h " SDThread :: SDThread ( DatasetDWI * ds , int id ) : m_dataset ( ds ) , m_id ( id ) { m_dwi = ds -> getData ( ) ; m_bvals = ds -> getBvals ( ) ; m_bvecs = ds -> getBvecs ( ) ; int nx = ds -> properties ( " maingl " ) . get ( Fn :: Property :: D_NX ) . toInt ( ) ; int ny = ds -> properties ( " maingl " ) . get ( Fn :: Property :: D_NY ) . toInt ( ) ; int nz = ds -> properties ( " maingl " ) . get ( Fn :: Property :: D_NZ ) . toInt ( ) ; m_blockSize = nx * ny * nz ; } SDThread :: ~ SDThread ( ) { } void SDThread :: run ( ) { int numThreads = GLFunctions :: idealThreadCount ; int progressCounter = 0 ; for ( int i = m_id ; i < m_blockSize ; i += numThreads ) { calcSD ( i ) ; ++ progressCounter ; if ( progressCounter == 100 ) { emit ( progress ( ) ) ; progressCounter = 0 ; } } emit ( finished ( ) ) ; } ColumnVector SDThread :: calcSD ( int id ) { return ColumnVector ( 20 ) ; } </DOCUMENT>
<DOCUMENT_ID="xhochy/arrow/tree/master/ruby/red-arrow/ext/arrow/raw-records.cpp"> # include " converters . hpp " namespace red_arrow { namespace { class RawRecordsBuilder : private Converter , public arrow :: ArrayVisitor { public : explicit RawRecordsBuilder ( VALUE records , int n_columns ) : Converter ( ) , records_ ( records ) , n_columns_ ( n_columns ) { } void build ( const arrow :: RecordBatch & record_batch ) { rb :: protect ( [ & ] { const auto n_rows = record_batch . num_rows ( ) ; for ( int64_t i = 0 ; i < n_rows ; ++ i ) { auto record = rb_ary_new_capa ( n_columns_ ) ; rb_ary_push ( records_ , record ) ; } row_offset_ = 0 ; for ( int i = 0 ; i < n_columns_ ; ++ i ) { const auto array = record_batch . column ( i ) . get ( ) ; column_index_ = i ; check_status ( array -> Accept ( this ) , " [ record - batch ] [ raw - records ] " ) ; } return Qnil ; } ) ; } void build ( const arrow :: Table & table ) { rb :: protect ( [ & ] { const auto n_rows = table . num_rows ( ) ; for ( int64_t i = 0 ; i < n_rows ; ++ i ) { auto record = rb_ary_new_capa ( n_columns_ ) ; rb_ary_push ( records_ , record ) ; } for ( int i = 0 ; i < n_columns_ ; ++ i ) { const auto & chunked_array = table . column ( i ) . get ( ) ; column_index_ = i ; row_offset_ = 0 ; for ( const auto array : chunked_array -> chunks ( ) ) { check_status ( array -> Accept ( this ) , " [ table ] [ raw - records ] " ) ; row_offset_ += array -> length ( ) ; } } return Qnil ; } ) ; } # define VISIT ( TYPE ) arrow :: Status Visit ( const arrow :: TYPE ## Array & array ) override { convert ( array ) ; return arrow :: Status :: OK ( ) ; } VISIT ( Null ) VISIT ( Boolean ) VISIT ( Int8 ) VISIT ( Int16 ) VISIT ( Int32 ) VISIT ( Int64 ) VISIT ( UInt8 ) VISIT ( UInt16 ) VISIT ( UInt32 ) VISIT ( UInt64 ) VISIT ( Float ) VISIT ( Double ) VISIT ( Binary ) VISIT ( String ) VISIT ( FixedSizeBinary ) VISIT ( Date32 ) VISIT ( Date64 ) VISIT ( Time32 ) VISIT ( Time64 ) VISIT ( Timestamp ) VISIT ( List ) VISIT ( Struct ) VISIT ( Union ) VISIT ( Dictionary ) VISIT ( Decimal128 ) # undef VISIT private : template < typename ArrayType > void convert ( const ArrayType & array ) { const auto n = array . length ( ) ; if ( array . null_count ( ) > 0 ) { for ( int64_t i = 0 , ii = row_offset_ ; i < n ; ++ i , ++ ii ) { auto value = Qnil ; if ( ! array . IsNull ( i ) ) { value = convert_value ( array , i ) ; } auto record = rb_ary_entry ( records_ , ii ) ; rb_ary_store ( record , column_index_ , value ) ; } } else { for ( int64_t i = 0 , ii = row_offset_ ; i < n ; ++ i , ++ ii ) { auto record = rb_ary_entry ( records_ , ii ) ; rb_ary_store ( record , column_index_ , convert_value ( array , i ) ) ; } } } VALUE records_ ; int column_index_ ; int64_t row_offset_ ; const int n_columns_ ; } ; } VALUE record_batch_raw_records ( VALUE rb_record_batch ) { auto garrow_record_batch = GARROW_RECORD_BATCH ( RVAL2GOBJ ( rb_record_batch ) ) ; auto record_batch = garrow_record_batch_get_raw ( garrow_record_batch ) . get ( ) ; const auto n_rows = record_batch -> num_rows ( ) ; const auto n_columns = record_batch -> num_columns ( ) ; auto records = rb_ary_new_capa ( n_rows ) ; try { RawRecordsBuilder builder ( records , n_columns ) ; builder . build ( * record_batch ) ; } catch ( rb :: State & state ) { state . jump ( ) ; } return records ; } VALUE table_raw_records ( VALUE rb_table ) { auto garrow_table = GARROW_TABLE ( RVAL2GOBJ ( rb_table ) ) ; auto table = garrow_table_get_raw ( garrow_table ) . get ( ) ; const auto n_rows = table -> num_rows ( ) ; const auto n_columns = table -> num_columns ( ) ; auto records = rb_ary_new_capa ( n_rows ) ; try { RawRecordsBuilder builder ( records , n_columns ) ; builder . build ( * table ) ; } catch ( rb :: State & state ) { state . jump ( ) ; } return records ; } } </DOCUMENT>
<DOCUMENT_ID="attackjz/Cocos2d-x_CustomSliderList/tree/master/CustomSliderList/cocos2d/cocos/platform/winrt/CCFreeTypeFont.cpp"> # include " CCFreeTypeFont . h " # include " base / CCDirector . h " # include " platform / CCFileUtils . h " # if ( CC_TARGET_PLATFORM != CC_PLATFORM_WP8 ) # include < dwrite . h > # endif # include < map > # include < string > # include < sstream > # include < vector > # include < memory > # include < algorithm > using namespace std ; NS_CC_BEGIN static map < std :: string , FontBufferInfo > s_fontsNames ; static FT_Library s_FreeTypeLibrary = nullptr ; CCFreeTypeFont :: CCFreeTypeFont ( ) : m_space ( " ▁ " ) , m_face ( nullptr ) { } CCFreeTypeFont :: ~ CCFreeTypeFont ( ) { reset ( ) ; } void CCFreeTypeFont :: reset ( ) { for ( auto line : m_lines ) { line -> glyphs . clear ( ) ; delete line ; } m_lines . clear ( ) ; if ( m_face ) { FT_Done_Face ( m_face ) ; m_face = nullptr ; } } unsigned char * CCFreeTypeFont :: initWithString ( const char * text , const FontDefinition & textDefinition , Device :: TextAlign align , int & width , int & height , ssize_t & dataLength ) { FT_Error error = 0 ; ssize_t size = 0 ; unsigned char * pBuffer = nullptr ; unsigned char * data = nullptr ; Size winSize = Director :: getInstance ( ) -> getWinSizeInPixels ( ) ; m_windowWidth = ( int ) winSize . width ; m_inWidth = textDefinition . _dimensions . width ; m_inHeight = textDefinition . _dimensions . height ; m_fontFillColorR = textDefinition . _fontFillColor . r ; m_fontFillColorG = textDefinition . _fontFillColor . g ; m_fontFillColorB = textDefinition . _fontFillColor . b ; # if 0 auto ittFontNames = s_fontsNames . find ( textDefinition . _fontName ) ; if ( ittFontNames != s_fontsNames . end ( ) ) { pBuffer = ittFontNames -> second . pBuffer ; size = ittFontNames -> second . size ; } # endif if ( ! pBuffer ) { pBuffer = loadFont ( textDefinition . _fontName . c_str ( ) , & size ) ; if ( ! pBuffer ) { pBuffer = loadSystemFont ( textDefinition . _fontName . c_str ( ) , & size ) ; } if ( ! pBuffer ) { pBuffer = loadFont ( " Arial " , & size ) ; } if ( ! pBuffer ) { pBuffer = loadSystemFont ( " Arial " , & size ) ; } if ( ! pBuffer ) { return false ; } # if 0 FontBufferInfo info ; info . pBuffer = pBuffer ; info . size = size ; s_fontsNames [ textDefinition . _fontName ] = info ; # endif } m_fontName = textDefinition . _fontName ; m_text = text ; if ( ! s_FreeTypeLibrary ) { error = FT_Init_FreeType ( & s_FreeTypeLibrary ) ; } if ( ! error && ! m_face ) { error = FT_New_Memory_Face ( s_FreeTypeLibrary , pBuffer , size , 0 , & m_face ) ; } if ( ! error ) { error = FT_Select_Charmap ( m_face , FT_ENCODING_UNICODE ) ; } if ( ! error ) { error = FT_Set_Char_Size ( m_face , textDefinition . _fontSize << 6 , textDefinition . _fontSize << 6 , 72 , 72 ) ; } if ( ! error ) { error = initGlyphs ( text ) ; } if ( ! error ) { data = getBitmap ( align , width , height , dataLength ) ; } delete [ ] pBuffer ; reset ( ) ; return data ; } unsigned char * CCFreeTypeFont :: getBitmap ( Device :: TextAlign eAlignMask , int & width , int & height , ssize_t & dataLength ) { int lineNumber = 0 ; int totalLines = m_lines . size ( ) ; m_width = m_inWidth ? m_inWidth : m_textWidth ; m_height = m_inHeight ? m_inHeight : m_textHeight ; unsigned int size = m_width * m_height * 4 ; unsigned char * pBuffer = new unsigned char [ size ] ; dataLength = size ; if ( ! pBuffer ) { dataLength = 0 ; return nullptr ; } memset ( pBuffer , 0 , size ) ; for ( auto line = m_lines . begin ( ) ; line != m_lines . end ( ) ; ++ line ) { FT_Vector pen = getPenForAlignment ( * line , eAlignMask , lineNumber , totalLines ) ; drawText ( * line , pBuffer , & pen ) ; lineNumber ++ ; } width = m_width ; height = m_height ; return pBuffer ; } FT_Vector CCFreeTypeFont :: getPenForAlignment ( FTLineInfo * pInfo , Device :: TextAlign eAlignMask , int lineNumber , int totalLines ) { FT_Error error = 0 ; FT_Vector pen ; int top ; int stringWidth = pInfo -> bbox . xMax - pInfo -> bbox . xMin ; int maxLineNumber = totalLines - 1 ; pen . x = 0 ; pen . y = 0 ; switch ( eAlignMask ) { case Device :: TextAlign :: TOP : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: TOP_LEFT : pen . x -= pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: TOP_RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM_RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM_LEFT : pen . x -= pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: CENTER : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; case Device :: TextAlign :: RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; case Device :: TextAlign :: LEFT : default : pen . x -= pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; } return pen ; } void CCFreeTypeFont :: drawText ( FTLineInfo * pInfo , unsigned char * pBuffer , FT_Vector * pen ) { auto glyphs = pInfo -> glyphs ; for ( auto glyph = glyphs . begin ( ) ; glyph != glyphs . end ( ) ; ++ glyph ) { FT_Glyph image = glyph -> image ; FT_Error error = FT_Glyph_To_Bitmap ( & image , FT_RENDER_MODE_NORMAL , 0 , 1 ) ; if ( ! error ) { FT_BitmapGlyph bit = ( FT_BitmapGlyph ) image ; draw_bitmap ( pBuffer , & bit -> bitmap , pen -> x + glyph -> pos . x + bit -> left , pen -> y - bit -> top ) ; FT_Done_Glyph ( image ) ; } } } void CCFreeTypeFont :: draw_bitmap ( unsigned char * pBuffer , FT_Bitmap * bitmap , FT_Int x , FT_Int y ) { FT_Int i , j , p , q ; FT_Int x_max = x + bitmap -> width ; FT_Int y_max = y + bitmap -> rows ; for ( i = x , p = 0 ; i < x_max ; i ++ , p ++ ) { for ( j = y , q = 0 ; j < y_max ; j ++ , q ++ ) { if ( i < 0 || j < 0 || i >= m_width || j >= m_height ) continue ; unsigned char value = bitmap -> buffer [ q * bitmap -> width + p ] ; if ( value > 0 ) { FT_Int index = ( j * m_width * 4 ) + ( i * 4 ) ; pBuffer [ index ++ ] = m_fontFillColorR ; pBuffer [ index ++ ] = m_fontFillColorG ; pBuffer [ index ++ ] = m_fontFillColorB ; pBuffer [ index ++ ] = value ; } } } } void CCFreeTypeFont :: endLine ( ) { if ( m_currentLine ) { m_lines . push_back ( m_currentLine ) ; m_textWidth = std :: max ( ( long ) m_textWidth , m_currentLine -> bbox . xMax - m_currentLine -> bbox . xMin ) ; m_textHeight += m_lineHeight ; } } void CCFreeTypeFont :: newLine ( ) { m_currentLine = new FTLineInfo ( ) ; m_currentLine -> width = 0 ; m_currentLine -> pen . x = 0 ; m_currentLine -> pen . y = 0 ; } FT_Error CCFreeTypeFont :: addWord ( const std :: string & word ) { std :: vector < TGlyph > glyphs ; FT_BBox bbox ; int maxWidth = m_inWidth ? m_inWidth : m_windowWidth ; std :: string newWord ; if ( m_currentLine -> width > 0 ) { newWord = ' ▁ ' + word ; } else { newWord = word ; } FT_Error error = initWordGlyphs ( glyphs , newWord , m_currentLine -> pen ) ; if ( ! error ) { compute_bbox ( glyphs , & bbox ) ; if ( m_currentLine -> width == 0 || bbox . xMax <= maxWidth ) { m_currentLine -> glyphs . insert ( m_currentLine -> glyphs . end ( ) , glyphs . begin ( ) , glyphs . end ( ) ) ; if ( m_currentLine -> width == 0 ) { m_currentLine -> bbox = bbox ; } else { m_currentLine -> bbox . xMax = bbox . xMax ; } m_currentLine -> width = m_currentLine -> bbox . xMax - m_currentLine -> bbox . xMin ; } else { endLine ( ) ; newLine ( ) ; addWord ( word ) ; } } return error ; } FT_Error CCFreeTypeFont :: initGlyphs ( const char * text ) { FT_Error error = 0 ; std :: stringstream stringStream ( text ) ; std :: string line ; vector < std :: string > lines ; vector < std :: string > words ; m_textWidth = 0 ; m_textHeight = 0 ; m_lineHeight = ( ( m_face -> size -> metrics . ascender ) >> 6 ) - ( ( m_face -> size -> metrics . descender ) >> 6 ) ; m_lines . clear ( ) ; while ( std :: getline ( stringStream , line ) && ! error ) { newLine ( ) ; std :: size_t prev = 0 , pos ; while ( ( pos = line . find_first_of ( " ▁ " , prev ) ) != std :: string :: npos ) { if ( pos > prev ) { addWord ( line . substr ( prev , pos - prev ) ) ; } prev = pos + 1 ; } if ( prev < line . length ( ) ) { addWord ( line . substr ( prev , std :: string :: npos ) ) ; } endLine ( ) ; } return error ; } void CCFreeTypeFont :: initWords ( const char * text ) { std :: stringstream stringStream ( text ) ; std :: string line ; vector < std :: string > lines ; vector < std :: string > words ; while ( std :: getline ( stringStream , line ) ) { lines . push_back ( line ) ; } for ( auto it = lines . begin ( ) ; it != lines . end ( ) ; ++ it ) { std :: size_t prev = 0 , pos ; while ( ( pos = it -> find_first_of ( " ▁ ' ; " , prev ) ) != std :: string :: npos ) { if ( pos > prev ) words . push_back ( it -> substr ( prev , pos - prev ) ) ; prev = pos + 1 ; } if ( prev < it -> length ( ) ) words . push_back ( it -> substr ( prev , std :: string :: npos ) ) ; } for ( auto it = words . begin ( ) ; it != words . end ( ) ; ++ it ) { std :: string foo ( * it ) ; } } FT_Error CCFreeTypeFont :: initWordGlyphs ( std :: vector < TGlyph > & glyphs , const std :: string & text , FT_Vector & pen ) { FT_GlyphSlot slot = m_face -> glyph ; FT_UInt glyph_index ; FT_UInt previous = 0 ; FT_Error error = 0 ; PGlyph glyph ; unsigned int numGlyphs = 0 ; wchar_t * pwszBuffer = nullptr ; int num_chars = text . size ( ) ; int nBufLen = num_chars + 1 ; pwszBuffer = new wchar_t [ nBufLen ] ; if ( ! pwszBuffer ) { return - 1 ; } memset ( pwszBuffer , 0 , nBufLen ) ; num_chars = MultiByteToWideChar ( CP_UTF8 , 0 , text . c_str ( ) , num_chars , pwszBuffer , nBufLen ) ; pwszBuffer [ num_chars ] = ' \0' ; glyphs . clear ( ) ; glyphs . resize ( num_chars ) ; FT_Bool useKerning = FT_HAS_KERNING ( m_face ) ; for ( int n = 0 ; n < num_chars ; n ++ ) { glyph = & glyphs [ numGlyphs ] ; FT_ULong c = pwszBuffer [ n ] ; glyph_index = FT_Get_Char_Index ( m_face , c ) ; if ( useKerning && previous && glyph_index ) { FT_Vector delta ; FT_Get_Kerning ( m_face , previous , glyph_index , FT_KERNING_DEFAULT , & delta ) ; pen . x += delta . x >> 6 ; } glyph -> pos = pen ; glyph -> index = glyph_index ; error = FT_Load_Glyph ( m_face , glyph_index , FT_LOAD_DEFAULT ) ; if ( error ) continue ; error = FT_Get_Glyph ( m_face -> glyph , & glyph -> image ) ; if ( error ) continue ; FT_Glyph_Transform ( glyph -> image , 0 , & glyph -> pos ) ; pen . x += slot -> advance . x >> 6 ; previous = glyph_index ; numGlyphs ++ ; } CC_SAFE_DELETE_ARRAY ( pwszBuffer ) ; return error ; } void CCFreeTypeFont :: compute_bbox ( std :: vector < TGlyph > & glyphs , FT_BBox * abbox ) { FT_BBox bbox ; FT_BBox glyph_bbox ; bbox . xMin = 32000 ; bbox . xMax = - 32000 ; bbox . yMin = ( m_face -> size -> metrics . descender ) >> 6 ; bbox . yMax = ( m_face -> size -> metrics . ascender ) >> 6 ; for ( auto glyph = glyphs . begin ( ) ; glyph != glyphs . end ( ) ; ++ glyph ) { FT_Glyph_Get_CBox ( glyph -> image , ft_glyph_bbox_pixels , & glyph_bbox ) ; glyph_bbox . xMin += glyph -> pos . x ; glyph_bbox . xMax += glyph -> pos . x ; glyph_bbox . yMin += glyph -> pos . y ; glyph_bbox . yMax += glyph -> pos . y ; if ( glyph_bbox . xMin < bbox . xMin ) bbox . xMin = glyph_bbox . xMin ; if ( glyph_bbox . yMin < bbox . yMin ) bbox . yMin = glyph_bbox . yMin ; if ( glyph_bbox . xMax > bbox . xMax ) bbox . xMax = glyph_bbox . xMax ; if ( glyph_bbox . yMax > bbox . yMax ) bbox . yMax = glyph_bbox . yMax ; } if ( bbox . xMin > bbox . xMax ) { bbox . xMin = 0 ; bbox . yMin = 0 ; bbox . xMax = 0 ; bbox . yMax = 0 ; } * abbox = bbox ; } unsigned char * CCFreeTypeFont :: loadFont ( const char * pFontName , ssize_t * size ) { std :: string lowerCase ( pFontName ) ; std :: string path ( pFontName ) ; for ( unsigned int i = 0 ; i < lowerCase . length ( ) ; ++ i ) { lowerCase [ i ] = tolower ( lowerCase [ i ] ) ; } if ( std :: string :: npos == lowerCase . find ( " fonts / " ) ) { path = " fonts / " ; path += pFontName ; } if ( std :: string :: npos == lowerCase . find ( " . ttf " ) ) { path += " . ttf " ; } std :: string fullpath = FileUtils :: getInstance ( ) -> fullPathForFilename ( path . c_str ( ) ) ; return FileUtils :: sharedFileUtils ( ) -> getFileData ( fullpath . c_str ( ) , " rb " , size ) ; } unsigned char * CCFreeTypeFont :: loadSystemFont ( const char * pFontName , ssize_t * size ) { # if ( CC_TARGET_PLATFORM == CC_PLATFORM_WP8 ) return nullptr ; # else std :: string aName ( pFontName ) ; unsigned char * pBuffer = nullptr ; HRESULT hr = S_OK ; IDWriteFactory * writeFactory = nullptr ; IDWriteFontCollection * fontCollection = nullptr ; IDWriteFontFamily * fontFamily = nullptr ; IDWriteFont * matchingFont = nullptr ; IDWriteFontFace * fontFace = nullptr ; IDWriteFontFile * fontFile = nullptr ; IDWriteFontFileLoader * fontFileLoader = nullptr ; IDWriteFontFileStream * fontFileStream = nullptr ; UINT32 index ; BOOL exists ; std :: wstring fontNameW ; const void * fontFileReferenceKey = nullptr ; UINT32 fontFileReferenceKeySize ; void * fragmentContext = nullptr ; for ( unsigned int i = 0 ; i < aName . length ( ) ; ++ i ) { aName [ i ] = tolower ( aName [ i ] ) ; } fontNameW . assign ( aName . begin ( ) , aName . end ( ) ) ; hr = DWriteCreateFactory ( DWRITE_FACTORY_TYPE_SHARED , __uuidof ( IDWriteFactory ) , reinterpret_cast < IUnknown * * > ( & writeFactory ) ) ; if ( SUCCEEDED ( hr ) ) { hr = writeFactory -> GetSystemFontCollection ( & fontCollection , TRUE ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontCollection -> FindFamilyName ( fontNameW . c_str ( ) , & index , & exists ) ; if ( SUCCEEDED ( hr ) && exists ) { hr = fontCollection -> GetFontFamily ( index , & fontFamily ) ; if ( SUCCEEDED ( hr ) ) { hr = fontFamily -> GetFirstMatchingFont ( DWRITE_FONT_WEIGHT_REGULAR , DWRITE_FONT_STRETCH_NORMAL , DWRITE_FONT_STYLE_NORMAL , & matchingFont ) ; } if ( SUCCEEDED ( hr ) ) { hr = matchingFont -> CreateFontFace ( & fontFace ) ; } if ( SUCCEEDED ( hr ) ) { UINT32 numberOfFiles = 1 ; hr = fontFace -> GetFiles ( & numberOfFiles , & fontFile ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFile -> GetReferenceKey ( & fontFileReferenceKey , & fontFileReferenceKeySize ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFile -> GetLoader ( & fontFileLoader ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFileLoader -> CreateStreamFromKey ( fontFileReferenceKey , fontFileReferenceKeySize , & fontFileStream ) ; } if ( SUCCEEDED ( hr ) ) { UINT64 fileSize ; const void * fragmentStart = nullptr ; hr = fontFileStream -> GetFileSize ( & fileSize ) ; if ( SUCCEEDED ( hr ) ) { hr = fontFileStream -> ReadFileFragment ( & fragmentStart , 0 , fileSize , & fragmentContext ) ; } if ( SUCCEEDED ( hr ) ) { pBuffer = ( unsigned char * ) malloc ( ( size_t ) fileSize ) ; memcpy ( pBuffer , fragmentStart , ( size_t ) fileSize ) ; * size = ( unsigned long ) fileSize ; } } } } if ( fontFileStream ) { fontFileStream -> ReleaseFileFragment ( fragmentContext ) ; fontFileStream -> Release ( ) ; } if ( fontFileLoader ) { fontFileLoader -> Release ( ) ; } if ( fontFile ) { fontFile -> Release ( ) ; } if ( fontFace ) { fontFace -> Release ( ) ; } if ( matchingFont ) { matchingFont -> Release ( ) ; } if ( fontFamily ) { fontFamily -> Release ( ) ; } if ( fontCollection ) { fontCollection -> Release ( ) ; } if ( writeFactory ) { writeFactory -> Release ( ) ; } return pBuffer ; # endif } NS_CC_END </DOCUMENT>
<DOCUMENT_ID="EdisonCodeKeeper/hacker-rank/tree/master/practice/mathematics/geometry/meeting-point/meeting-point.cpp"> # include < iostream > # include < vector > # include < algorithm > using namespace std ; # define M 100 bool pair_compare ( const pair < int , long long > & a , const pair < int , long long > & b ) { return a . second == b . second ? a . first < b . first : a . second < b . second ; } int main ( ) { int N ; cin >> N ; vector < pair < long long , long long > > pos ; long long avg_x = 0 , avg_y = 0 ; for ( int i = 0 ; i < N ; ++ i ) { int x , y ; cin >> x >> y ; pos . push_back ( make_pair ( x , y ) ) ; avg_x += x ; avg_y += y ; } avg_x /= N , avg_y /= N ; vector < pair < int , long long > > ans ; for ( int i = 0 ; i < N ; ++ i ) { long long dis = max ( abs ( pos [ i ] . first - avg_x ) , abs ( pos [ i ] . second - avg_y ) ) ; ans . push_back ( make_pair ( i , dis ) ) ; } sort ( ans . begin ( ) , ans . end ( ) , pair_compare ) ; long long ret = 1e16 ; for ( int i = 0 ; i < min ( M , int ( ans . size ( ) ) ) ; ++ i ) { long long tmp = 0 ; for ( int j = 0 ; j < N ; ++ j ) tmp += max ( abs ( pos [ j ] . first - pos [ ans [ i ] . first ] . first ) , abs ( pos [ j ] . second - pos [ ans [ i ] . first ] . second ) ) ; ret = min ( ret , tmp ) ; } cout << ret << endl ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="tony--/WinObjC/tree/master/deps/3rdparty/iculegacy/source/i18n/rbtz.cpp"> # include < typeinfo > # include " unicode / utypes . h " # if ! UCONFIG_NO_FORMATTING # include " unicode / rbtz . h " # include " unicode / gregocal . h " # include " uvector . h " # include " gregoimp . h " # include " cmemory . h " U_NAMESPACE_BEGIN struct Transition { UDate time ; TimeZoneRule * from ; TimeZoneRule * to ; } ; static UBool compareRules ( UVector * rules1 , UVector * rules2 ) { if ( rules1 == NULL && rules2 == NULL ) { return TRUE ; } else if ( rules1 == NULL || rules2 == NULL ) { return FALSE ; } int32_t size = rules1 -> size ( ) ; if ( size != rules2 -> size ( ) ) { return FALSE ; } for ( int32_t i = 0 ; i < size ; i ++ ) { TimeZoneRule * r1 = ( TimeZoneRule * ) rules1 -> elementAt ( i ) ; TimeZoneRule * r2 = ( TimeZoneRule * ) rules2 -> elementAt ( i ) ; if ( * r1 != * r2 ) { return FALSE ; } } return TRUE ; } UOBJECT_DEFINE_RTTI_IMPLEMENTATION ( RuleBasedTimeZone ) RuleBasedTimeZone :: RuleBasedTimeZone ( const UnicodeString & id , InitialTimeZoneRule * initialRule ) : BasicTimeZone ( id ) , fInitialRule ( initialRule ) , fHistoricRules ( NULL ) , fFinalRules ( NULL ) , fHistoricTransitions ( NULL ) , fUpToDate ( FALSE ) { } RuleBasedTimeZone :: RuleBasedTimeZone ( const RuleBasedTimeZone & source ) : BasicTimeZone ( source ) , fInitialRule ( source . fInitialRule -> clone ( ) ) , fHistoricTransitions ( NULL ) , fUpToDate ( FALSE ) { fHistoricRules = copyRules ( source . fHistoricRules ) ; fFinalRules = copyRules ( source . fFinalRules ) ; if ( source . fUpToDate ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; } } RuleBasedTimeZone :: ~ RuleBasedTimeZone ( ) { deleteTransitions ( ) ; deleteRules ( ) ; } RuleBasedTimeZone & RuleBasedTimeZone :: operator = ( const RuleBasedTimeZone & right ) { if ( * this != right ) { BasicTimeZone :: operator = ( right ) ; deleteRules ( ) ; fInitialRule = right . fInitialRule -> clone ( ) ; fHistoricRules = copyRules ( right . fHistoricRules ) ; fFinalRules = copyRules ( right . fFinalRules ) ; deleteTransitions ( ) ; fUpToDate = FALSE ; } return * this ; } UBool RuleBasedTimeZone :: operator == ( const TimeZone & that ) const { if ( this == & that ) { return TRUE ; } if ( typeid ( * this ) != typeid ( that ) || BasicTimeZone :: operator == ( that ) == FALSE ) { return FALSE ; } RuleBasedTimeZone * rbtz = ( RuleBasedTimeZone * ) & that ; if ( * fInitialRule != * ( rbtz -> fInitialRule ) ) { return FALSE ; } if ( compareRules ( fHistoricRules , rbtz -> fHistoricRules ) && compareRules ( fFinalRules , rbtz -> fFinalRules ) ) { return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: operator != ( const TimeZone & that ) const { return ! operator == ( that ) ; } void RuleBasedTimeZone :: addTransitionRule ( TimeZoneRule * rule , UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } AnnualTimeZoneRule * atzrule = dynamic_cast < AnnualTimeZoneRule * > ( rule ) ; if ( atzrule != NULL && atzrule -> getEndYear ( ) == AnnualTimeZoneRule :: MAX_YEAR ) { if ( fFinalRules == NULL ) { fFinalRules = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { return ; } } else if ( fFinalRules -> size ( ) >= 2 ) { status = U_INVALID_STATE_ERROR ; return ; } fFinalRules -> addElement ( ( void * ) rule , status ) ; } else { if ( fHistoricRules == NULL ) { fHistoricRules = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { return ; } } fHistoricRules -> addElement ( ( void * ) rule , status ) ; } fUpToDate = FALSE ; } void RuleBasedTimeZone :: complete ( UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } if ( fUpToDate ) { return ; } if ( fFinalRules != NULL && fFinalRules -> size ( ) != 2 ) { status = U_INVALID_STATE_ERROR ; return ; } UBool * done = NULL ; if ( fHistoricRules != NULL || fFinalRules != NULL ) { TimeZoneRule * curRule = fInitialRule ; UDate lastTransitionTime = MIN_MILLIS ; if ( fHistoricRules != NULL && fHistoricRules -> size ( ) > 0 ) { int32_t i ; int32_t historicCount = fHistoricRules -> size ( ) ; done = ( UBool * ) uprv_malloc ( sizeof ( UBool ) * historicCount ) ; if ( done == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } for ( i = 0 ; i < historicCount ; i ++ ) { done [ i ] = FALSE ; } while ( TRUE ) { int32_t curStdOffset = curRule -> getRawOffset ( ) ; int32_t curDstSavings = curRule -> getDSTSavings ( ) ; UDate nextTransitionTime = MAX_MILLIS ; TimeZoneRule * nextRule = NULL ; TimeZoneRule * r = NULL ; UBool avail ; UDate tt ; UnicodeString curName , name ; curRule -> getName ( curName ) ; for ( i = 0 ; i < historicCount ; i ++ ) { if ( done [ i ] ) { continue ; } r = ( TimeZoneRule * ) fHistoricRules -> elementAt ( i ) ; avail = r -> getNextStart ( lastTransitionTime , curStdOffset , curDstSavings , false , tt ) ; if ( ! avail ) { done [ i ] = TRUE ; } else { r -> getName ( name ) ; if ( * r == * curRule || ( name == curName && r -> getRawOffset ( ) == curRule -> getRawOffset ( ) && r -> getDSTSavings ( ) == curRule -> getDSTSavings ( ) ) ) { continue ; } if ( tt < nextTransitionTime ) { nextTransitionTime = tt ; nextRule = r ; } } } if ( nextRule == NULL ) { UBool bDoneAll = TRUE ; for ( int32_t j = 0 ; j < historicCount ; j ++ ) { if ( ! done [ j ] ) { bDoneAll = FALSE ; break ; } } if ( bDoneAll ) { break ; } } if ( fFinalRules != NULL ) { for ( i = 0 ; i < 2 ; i ++ ) { TimeZoneRule * fr = ( TimeZoneRule * ) fFinalRules -> elementAt ( i ) ; if ( * fr == * curRule ) { continue ; } r = ( TimeZoneRule * ) fFinalRules -> elementAt ( i ) ; avail = r -> getNextStart ( lastTransitionTime , curStdOffset , curDstSavings , false , tt ) ; if ( avail ) { if ( tt < nextTransitionTime ) { nextTransitionTime = tt ; nextRule = r ; } } } } if ( nextRule == NULL ) { break ; } if ( fHistoricTransitions == NULL ) { fHistoricTransitions = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } Transition * trst = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( trst == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } trst -> time = nextTransitionTime ; trst -> from = curRule ; trst -> to = nextRule ; fHistoricTransitions -> addElement ( trst , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } lastTransitionTime = nextTransitionTime ; curRule = nextRule ; } } if ( fFinalRules != NULL ) { if ( fHistoricTransitions == NULL ) { fHistoricTransitions = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } TimeZoneRule * rule0 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; TimeZoneRule * rule1 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; UDate tt0 , tt1 ; UBool avail0 = rule0 -> getNextStart ( lastTransitionTime , curRule -> getRawOffset ( ) , curRule -> getDSTSavings ( ) , false , tt0 ) ; UBool avail1 = rule1 -> getNextStart ( lastTransitionTime , curRule -> getRawOffset ( ) , curRule -> getDSTSavings ( ) , false , tt1 ) ; if ( ! avail0 || ! avail1 ) { status = U_INVALID_STATE_ERROR ; goto cleanup ; } Transition * final0 = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( final0 == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } Transition * final1 = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( final1 == NULL ) { uprv_free ( final0 ) ; status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } if ( tt0 < tt1 ) { final0 -> time = tt0 ; final0 -> from = curRule ; final0 -> to = rule0 ; rule1 -> getNextStart ( tt0 , rule0 -> getRawOffset ( ) , rule0 -> getDSTSavings ( ) , false , final1 -> time ) ; final1 -> from = rule0 ; final1 -> to = rule1 ; } else { final0 -> time = tt1 ; final0 -> from = curRule ; final0 -> to = rule1 ; rule0 -> getNextStart ( tt1 , rule1 -> getRawOffset ( ) , rule1 -> getDSTSavings ( ) , false , final1 -> time ) ; final1 -> from = rule1 ; final1 -> to = rule0 ; } fHistoricTransitions -> addElement ( final0 , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } fHistoricTransitions -> addElement ( final1 , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } } fUpToDate = TRUE ; if ( done != NULL ) { uprv_free ( done ) ; } return ; cleanup : deleteTransitions ( ) ; if ( done != NULL ) { uprv_free ( done ) ; } fUpToDate = FALSE ; } TimeZone * RuleBasedTimeZone :: clone ( void ) const { return new RuleBasedTimeZone ( * this ) ; } int32_t RuleBasedTimeZone :: getOffset ( uint8_t era , int32_t year , int32_t month , int32_t day , uint8_t dayOfWeek , int32_t millis , UErrorCode & status ) const { if ( U_FAILURE ( status ) ) { return 0 ; } if ( month < UCAL_JANUARY || month > UCAL_DECEMBER ) { status = U_ILLEGAL_ARGUMENT_ERROR ; return 0 ; } else { return getOffset ( era , year , month , day , dayOfWeek , millis , Grego :: monthLength ( year , month ) , status ) ; } } int32_t RuleBasedTimeZone :: getOffset ( uint8_t era , int32_t year , int32_t month , int32_t day , uint8_t , int32_t millis , int32_t , UErrorCode & status ) const { if ( U_FAILURE ( status ) ) { return 0 ; } if ( era == GregorianCalendar :: BC ) { year = 1 - year ; } int32_t rawOffset , dstOffset ; UDate time = ( UDate ) Grego :: fieldsToDay ( year , month , day ) * U_MILLIS_PER_DAY + millis ; getOffsetInternal ( time , TRUE , kDaylight , kStandard , rawOffset , dstOffset , status ) ; if ( U_FAILURE ( status ) ) { return 0 ; } return ( rawOffset + dstOffset ) ; } void RuleBasedTimeZone :: getOffset ( UDate date , UBool local , int32_t & rawOffset , int32_t & dstOffset , UErrorCode & status ) const { getOffsetInternal ( date , local , kFormer , kLatter , rawOffset , dstOffset , status ) ; } void RuleBasedTimeZone :: getOffsetFromLocal ( UDate date , int32_t nonExistingTimeOpt , int32_t duplicatedTimeOpt , int32_t & rawOffset , int32_t & dstOffset , UErrorCode & status ) { getOffsetInternal ( date , TRUE , nonExistingTimeOpt , duplicatedTimeOpt , rawOffset , dstOffset , status ) ; } void RuleBasedTimeZone :: getOffsetInternal ( UDate date , UBool local , int32_t NonExistingTimeOpt , int32_t DuplicatedTimeOpt , int32_t & rawOffset , int32_t & dstOffset , UErrorCode & status ) const { rawOffset = 0 ; dstOffset = 0 ; if ( U_FAILURE ( status ) ) { return ; } if ( ! fUpToDate ) { status = U_INVALID_STATE_ERROR ; return ; } const TimeZoneRule * rule = NULL ; if ( fHistoricTransitions == NULL ) { rule = fInitialRule ; } else { UDate tstart = getTransitionTime ( ( Transition * ) fHistoricTransitions -> elementAt ( 0 ) , local , NonExistingTimeOpt , DuplicatedTimeOpt ) ; if ( date < tstart ) { rule = fInitialRule ; } else { int32_t idx = fHistoricTransitions -> size ( ) - 1 ; UDate tend = getTransitionTime ( ( Transition * ) fHistoricTransitions -> elementAt ( idx ) , local , NonExistingTimeOpt , DuplicatedTimeOpt ) ; if ( date > tend ) { if ( fFinalRules != NULL ) { rule = findRuleInFinal ( date , local , NonExistingTimeOpt , DuplicatedTimeOpt ) ; } else { rule = ( ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ) -> to ; } } else { while ( idx >= 0 ) { if ( date >= getTransitionTime ( ( Transition * ) fHistoricTransitions -> elementAt ( idx ) , local , NonExistingTimeOpt , DuplicatedTimeOpt ) ) { break ; } idx -- ; } rule = ( ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ) -> to ; } } } if ( rule != NULL ) { rawOffset = rule -> getRawOffset ( ) ; dstOffset = rule -> getDSTSavings ( ) ; } } void RuleBasedTimeZone :: setRawOffset ( int32_t ) { } int32_t RuleBasedTimeZone :: getRawOffset ( void ) const { UErrorCode status = U_ZERO_ERROR ; int32_t raw , dst ; getOffset ( uprv_getUTCtime ( ) * U_MILLIS_PER_SECOND , FALSE , raw , dst , status ) ; return raw ; } UBool RuleBasedTimeZone :: useDaylightTime ( void ) const { UErrorCode status = U_ZERO_ERROR ; UDate now = uprv_getUTCtime ( ) * U_MILLIS_PER_SECOND ; int32_t raw , dst ; getOffset ( now , FALSE , raw , dst , status ) ; if ( dst != 0 ) { return TRUE ; } UDate time ; TimeZoneRule * from , * to ; UBool avail = findNext ( now , FALSE , time , from , to ) ; if ( avail && to -> getDSTSavings ( ) != 0 ) { return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: inDaylightTime ( UDate date , UErrorCode & status ) const { if ( U_FAILURE ( status ) ) { return FALSE ; } int32_t raw , dst ; getOffset ( date , FALSE , raw , dst , status ) ; if ( dst != 0 ) { return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: hasSameRules ( const TimeZone & other ) const { if ( this == & other ) { return TRUE ; } if ( typeid ( * this ) != typeid ( other ) ) { return FALSE ; } const RuleBasedTimeZone & that = ( const RuleBasedTimeZone & ) other ; if ( * fInitialRule != * ( that . fInitialRule ) ) { return FALSE ; } if ( compareRules ( fHistoricRules , that . fHistoricRules ) && compareRules ( fFinalRules , that . fFinalRules ) ) { return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: getNextTransition ( UDate base , UBool inclusive , TimeZoneTransition & result ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; if ( U_FAILURE ( status ) ) { return FALSE ; } UDate transitionTime ; TimeZoneRule * fromRule , * toRule ; UBool found = findNext ( base , inclusive , transitionTime , fromRule , toRule ) ; if ( found ) { result . setTime ( transitionTime ) ; result . setFrom ( ( const TimeZoneRule & ) * fromRule ) ; result . setTo ( ( const TimeZoneRule & ) * toRule ) ; return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: getPreviousTransition ( UDate base , UBool inclusive , TimeZoneTransition & result ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; if ( U_FAILURE ( status ) ) { return FALSE ; } UDate transitionTime ; TimeZoneRule * fromRule , * toRule ; UBool found = findPrev ( base , inclusive , transitionTime , fromRule , toRule ) ; if ( found ) { result . setTime ( transitionTime ) ; result . setFrom ( ( const TimeZoneRule & ) * fromRule ) ; result . setTo ( ( const TimeZoneRule & ) * toRule ) ; return TRUE ; } return FALSE ; } int32_t RuleBasedTimeZone :: countTransitionRules ( UErrorCode & ) { int32_t count = 0 ; if ( fHistoricRules != NULL ) { count += fHistoricRules -> size ( ) ; } if ( fFinalRules != NULL ) { count += fFinalRules -> size ( ) ; } return count ; } void RuleBasedTimeZone :: getTimeZoneRules ( const InitialTimeZoneRule * & initial , const TimeZoneRule * trsrules [ ] , int32_t & trscount , UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } initial = fInitialRule ; int32_t cnt = 0 ; int32_t idx ; if ( fHistoricRules != NULL && cnt < trscount ) { int32_t historicCount = fHistoricRules -> size ( ) ; idx = 0 ; while ( cnt < trscount && idx < historicCount ) { trsrules [ cnt ++ ] = ( const TimeZoneRule * ) fHistoricRules -> elementAt ( idx ++ ) ; } } if ( fFinalRules != NULL && cnt < trscount ) { int32_t finalCount = fFinalRules -> size ( ) ; idx = 0 ; while ( cnt < trscount && idx < finalCount ) { trsrules [ cnt ++ ] = ( const TimeZoneRule * ) fFinalRules -> elementAt ( idx ++ ) ; } } trscount = cnt ; } void RuleBasedTimeZone :: deleteRules ( void ) { delete fInitialRule ; fInitialRule = NULL ; if ( fHistoricRules != NULL ) { while ( ! fHistoricRules -> isEmpty ( ) ) { delete ( TimeZoneRule * ) ( fHistoricRules -> orphanElementAt ( 0 ) ) ; } delete fHistoricRules ; fHistoricRules = NULL ; } if ( fFinalRules != NULL ) { while ( ! fFinalRules -> isEmpty ( ) ) { delete ( AnnualTimeZoneRule * ) ( fFinalRules -> orphanElementAt ( 0 ) ) ; } delete fFinalRules ; fFinalRules = NULL ; } } void RuleBasedTimeZone :: deleteTransitions ( void ) { if ( fHistoricTransitions != NULL ) { while ( ! fHistoricTransitions -> isEmpty ( ) ) { Transition * trs = ( Transition * ) fHistoricTransitions -> orphanElementAt ( 0 ) ; uprv_free ( trs ) ; } delete fHistoricTransitions ; } fHistoricTransitions = NULL ; } UVector * RuleBasedTimeZone :: copyRules ( UVector * source ) { if ( source == NULL ) { return NULL ; } UErrorCode ec = U_ZERO_ERROR ; int32_t size = source -> size ( ) ; UVector * rules = new UVector ( size , ec ) ; if ( U_FAILURE ( ec ) ) { return NULL ; } int32_t i ; for ( i = 0 ; i < size ; i ++ ) { rules -> addElement ( ( ( TimeZoneRule * ) source -> elementAt ( i ) ) -> clone ( ) , ec ) ; if ( U_FAILURE ( ec ) ) { break ; } } if ( U_FAILURE ( ec ) ) { for ( i = 0 ; i < rules -> size ( ) ; i ++ ) { TimeZoneRule * rule = ( TimeZoneRule * ) rules -> orphanElementAt ( i ) ; delete rule ; } delete rules ; return NULL ; } return rules ; } TimeZoneRule * RuleBasedTimeZone :: findRuleInFinal ( UDate date , UBool local , int32_t NonExistingTimeOpt , int32_t DuplicatedTimeOpt ) const { if ( fFinalRules == NULL ) { return NULL ; } AnnualTimeZoneRule * fr0 = ( AnnualTimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; AnnualTimeZoneRule * fr1 = ( AnnualTimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; if ( fr0 == NULL || fr1 == NULL ) { return NULL ; } UDate start0 , start1 ; UDate base ; int32_t localDelta ; base = date ; if ( local ) { localDelta = getLocalDelta ( fr1 -> getRawOffset ( ) , fr1 -> getDSTSavings ( ) , fr0 -> getRawOffset ( ) , fr0 -> getDSTSavings ( ) , NonExistingTimeOpt , DuplicatedTimeOpt ) ; base -= localDelta ; } UBool avail0 = fr0 -> getPreviousStart ( base , fr1 -> getRawOffset ( ) , fr1 -> getDSTSavings ( ) , TRUE , start0 ) ; base = date ; if ( local ) { localDelta = getLocalDelta ( fr0 -> getRawOffset ( ) , fr0 -> getDSTSavings ( ) , fr1 -> getRawOffset ( ) , fr1 -> getDSTSavings ( ) , NonExistingTimeOpt , DuplicatedTimeOpt ) ; base -= localDelta ; } UBool avail1 = fr1 -> getPreviousStart ( base , fr0 -> getRawOffset ( ) , fr0 -> getDSTSavings ( ) , TRUE , start1 ) ; if ( avail0 && ( ! avail1 || start0 > start1 ) ) { return fr0 ; } else if ( avail1 ) { return fr1 ; } return NULL ; } UBool RuleBasedTimeZone :: findNext ( UDate base , UBool inclusive , UDate & transitionTime , TimeZoneRule * & fromRule , TimeZoneRule * & toRule ) const { if ( fHistoricTransitions == NULL ) { return FALSE ; } UBool isFinal = FALSE ; UBool found = FALSE ; Transition result ; Transition * tzt = ( Transition * ) fHistoricTransitions -> elementAt ( 0 ) ; UDate tt = tzt -> time ; if ( tt > base || ( inclusive && tt == base ) ) { result = * tzt ; found = TRUE ; } else { int32_t idx = fHistoricTransitions -> size ( ) - 1 ; tzt = ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ; tt = tzt -> time ; if ( inclusive && tt == base ) { result = * tzt ; found = TRUE ; } else if ( tt <= base ) { if ( fFinalRules != NULL ) { TimeZoneRule * r0 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; TimeZoneRule * r1 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; UDate start0 , start1 ; UBool avail0 = r0 -> getNextStart ( base , r1 -> getRawOffset ( ) , r1 -> getDSTSavings ( ) , inclusive , start0 ) ; UBool avail1 = r1 -> getNextStart ( base , r0 -> getRawOffset ( ) , r0 -> getDSTSavings ( ) , inclusive , start1 ) ; if ( ! avail0 && ! avail1 ) { return FALSE ; } if ( ! avail1 || start0 < start1 ) { result . time = start0 ; result . from = r1 ; result . to = r0 ; } else { result . time = start1 ; result . from = r0 ; result . to = r1 ; } isFinal = TRUE ; found = TRUE ; } } else { idx -- ; Transition * prev = tzt ; while ( idx > 0 ) { tzt = ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ; tt = tzt -> time ; if ( tt < base || ( ! inclusive && tt == base ) ) { break ; } idx -- ; prev = tzt ; } result . time = prev -> time ; result . from = prev -> from ; result . to = prev -> to ; found = TRUE ; } } if ( found ) { if ( result . from -> getRawOffset ( ) == result . to -> getRawOffset ( ) && result . from -> getDSTSavings ( ) == result . to -> getDSTSavings ( ) ) { if ( isFinal ) { return FALSE ; } else { return findNext ( result . time , FALSE , transitionTime , fromRule , toRule ) ; } } transitionTime = result . time ; fromRule = result . from ; toRule = result . to ; return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: findPrev ( UDate base , UBool inclusive , UDate & transitionTime , TimeZoneRule * & fromRule , TimeZoneRule * & toRule ) const { if ( fHistoricTransitions == NULL ) { return FALSE ; } UBool found = FALSE ; Transition result ; Transition * tzt = ( Transition * ) fHistoricTransitions -> elementAt ( 0 ) ; UDate tt = tzt -> time ; if ( inclusive && tt == base ) { result = * tzt ; found = TRUE ; } else if ( tt < base ) { int32_t idx = fHistoricTransitions -> size ( ) - 1 ; tzt = ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ; tt = tzt -> time ; if ( inclusive && tt == base ) { result = * tzt ; found = TRUE ; } else if ( tt < base ) { if ( fFinalRules != NULL ) { TimeZoneRule * r0 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; TimeZoneRule * r1 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; UDate start0 , start1 ; UBool avail0 = r0 -> getPreviousStart ( base , r1 -> getRawOffset ( ) , r1 -> getDSTSavings ( ) , inclusive , start0 ) ; UBool avail1 = r1 -> getPreviousStart ( base , r0 -> getRawOffset ( ) , r0 -> getDSTSavings ( ) , inclusive , start1 ) ; if ( ! avail0 && ! avail1 ) { return FALSE ; } if ( ! avail1 || start0 > start1 ) { result . time = start0 ; result . from = r1 ; result . to = r0 ; } else { result . time = start1 ; result . from = r0 ; result . to = r1 ; } } else { result = * tzt ; } found = TRUE ; } else { idx -- ; while ( idx >= 0 ) { tzt = ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ; tt = tzt -> time ; if ( tt < base || ( inclusive && tt == base ) ) { break ; } idx -- ; } result = * tzt ; found = TRUE ; } } if ( found ) { if ( result . from -> getRawOffset ( ) == result . to -> getRawOffset ( ) && result . from -> getDSTSavings ( ) == result . to -> getDSTSavings ( ) ) { return findPrev ( result . time , FALSE , transitionTime , fromRule , toRule ) ; } transitionTime = result . time ; fromRule = result . from ; toRule = result . to ; return TRUE ; } return FALSE ; } UDate RuleBasedTimeZone :: getTransitionTime ( Transition * transition , UBool local , int32_t NonExistingTimeOpt , int32_t DuplicatedTimeOpt ) const { UDate time = transition -> time ; if ( local ) { time += getLocalDelta ( transition -> from -> getRawOffset ( ) , transition -> from -> getDSTSavings ( ) , transition -> to -> getRawOffset ( ) , transition -> to -> getDSTSavings ( ) , NonExistingTimeOpt , DuplicatedTimeOpt ) ; } return time ; } int32_t RuleBasedTimeZone :: getLocalDelta ( int32_t rawBefore , int32_t dstBefore , int32_t rawAfter , int32_t dstAfter , int32_t NonExistingTimeOpt , int32_t DuplicatedTimeOpt ) const { int32_t delta = 0 ; int32_t offsetBefore = rawBefore + dstBefore ; int32_t offsetAfter = rawAfter + dstAfter ; UBool dstToStd = ( dstBefore != 0 ) && ( dstAfter == 0 ) ; UBool stdToDst = ( dstBefore == 0 ) && ( dstAfter != 0 ) ; if ( offsetAfter - offsetBefore >= 0 ) { if ( ( ( NonExistingTimeOpt & kStdDstMask ) == kStandard && dstToStd ) || ( ( NonExistingTimeOpt & kStdDstMask ) == kDaylight && stdToDst ) ) { delta = offsetBefore ; } else if ( ( ( NonExistingTimeOpt & kStdDstMask ) == kStandard && stdToDst ) || ( ( NonExistingTimeOpt & kStdDstMask ) == kDaylight && dstToStd ) ) { delta = offsetAfter ; } else if ( ( NonExistingTimeOpt & kFormerLatterMask ) == kLatter ) { delta = offsetBefore ; } else { delta = offsetAfter ; } } else { if ( ( ( DuplicatedTimeOpt & kStdDstMask ) == kStandard && dstToStd ) || ( ( DuplicatedTimeOpt & kStdDstMask ) == kDaylight && stdToDst ) ) { delta = offsetAfter ; } else if ( ( ( DuplicatedTimeOpt & kStdDstMask ) == kStandard && stdToDst ) || ( ( DuplicatedTimeOpt & kStdDstMask ) == kDaylight && dstToStd ) ) { delta = offsetBefore ; } else if ( ( DuplicatedTimeOpt & kFormerLatterMask ) == kFormer ) { delta = offsetBefore ; } else { delta = offsetAfter ; } } return delta ; } U_NAMESPACE_END # endif </DOCUMENT>
<DOCUMENT_ID="whc10002/study/tree/master/libcds/test/unit/striped-map/map_boost_flat_map.cpp"> # ifdef CDSUNIT_ENABLE_BOOST_CONTAINER # include < boost / version . hpp > # include < cds / details / defs . h > # if CDS_COMPILER == CDS_COMPILER_MSVC && CDS_COMPILER_VERSION == CDS_COMPILER_MSVC12 && BOOST_VERSION < 105500 # elif BOOST_VERSION >= 104800 # include < cds / container / striped_map / boost_flat_map . h > # include " test _ striped _ map . h " namespace { struct test_traits { typedef boost :: container :: flat_map < cds_test :: striped_map_fixture :: key_type , cds_test :: striped_map_fixture :: value_type , cds_test :: striped_map_fixture :: less > container_type ; struct copy_policy { typedef container_type :: iterator iterator ; void operator ( ) ( container_type & m , iterator , iterator itWhat ) { m . insert ( * itWhat ) ; } } ; static bool const c_hasFindWith = false ; static bool const c_hasEraseWith = false ; } ; INSTANTIATE_TYPED_TEST_CASE_P ( BoostFlatMap , StripedMap , test_traits ) ; INSTANTIATE_TYPED_TEST_CASE_P ( BoostFlatMap , RefinableMap , test_traits ) ; } # else # endif # endif </DOCUMENT>
<DOCUMENT_ID="HofiOne/xbmc/tree/master/xbmc/settings/dialogs/GUIDialogLibExportSettings.cpp"> # include < map > # include < memory > # include < string > # include < utility > # include < vector > # include < limits . h > # include " GUIDialogLibExportSettings . h " # include " dialogs / GUIDialogFileBrowser . h " # include " guilib / GUIComponent . h " # include " guilib / GUIWindowManager . h " # include " guilib / LocalizeStrings . h " # include " messaging / helpers / DialogHelper . h " # include " messaging / helpers / DialogOKHelper . h " # include " ServiceBroker . h " # include " settings / SettingUtils . h " # include " settings / lib / Setting . h " # include " settings / Settings . h " # include " settings / windows / GUIControlSettings . h " # include " storage / MediaManager . h " # include " Util . h " # include " utils / log . h " # include " utils / URIUtils . h " # include " filesystem / Directory . h " using namespace ADDON ; using namespace KODI :: MESSAGING ; using KODI :: MESSAGING :: HELPERS :: DialogResponse ; CGUIDialogLibExportSettings :: CGUIDialogLibExportSettings ( ) : CGUIDialogSettingsManualBase ( WINDOW_DIALOG_LIBEXPORT_SETTINGS , " DialogSettings . xml " ) , m_destinationChecked ( false ) { } bool CGUIDialogLibExportSettings :: Show ( CLibExportSettings & settings ) { CGUIDialogLibExportSettings * dialog = CServiceBroker :: GetGUI ( ) -> GetWindowManager ( ) . GetWindow < CGUIDialogLibExportSettings > ( WINDOW_DIALOG_LIBEXPORT_SETTINGS ) ; if ( ! dialog ) return false ; dialog -> m_settings . SetExportType ( CServiceBroker :: GetSettings ( ) . GetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) ) ; dialog -> m_settings . m_strPath = CServiceBroker :: GetSettings ( ) . GetString ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; dialog -> m_settings . SetItemsToExport ( CServiceBroker :: GetSettings ( ) . GetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS ) ) ; dialog -> m_settings . m_unscraped = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED ) ; dialog -> m_settings . m_artwork = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK ) ; dialog -> m_settings . m_skipnfo = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO ) ; dialog -> m_settings . m_overwrite = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE ) ; dialog -> m_destinationChecked = false ; dialog -> Open ( ) ; bool confirmed = dialog -> IsConfirmed ( ) ; if ( confirmed ) { settings = dialog -> m_settings ; } return confirmed ; } void CGUIDialogLibExportSettings :: OnInitWindow ( ) { CGUIDialogSettingsManualBase :: OnInitWindow ( ) ; } void CGUIDialogLibExportSettings :: OnSettingChanged ( std :: shared_ptr < const CSetting > setting ) { if ( ! setting ) return ; CGUIDialogSettingsManualBase :: OnSettingChanged ( setting ) ; const std :: string & settingId = setting -> GetId ( ) ; if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) { m_settings . SetExportType ( std :: static_pointer_cast < const CSettingInt > ( setting ) -> GetValue ( ) ) ; SetupView ( ) ; SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) { m_settings . m_strPath = std :: static_pointer_cast < const CSettingString > ( setting ) -> GetValue ( ) ; UpdateButtons ( ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE ) m_settings . m_overwrite = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS ) m_settings . SetItemsToExport ( GetExportItemsFromSetting ( setting ) ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK ) { m_settings . m_artwork = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED ) m_settings . m_unscraped = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO ) m_settings . m_skipnfo = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; } void CGUIDialogLibExportSettings :: OnSettingAction ( std :: shared_ptr < const CSetting > setting ) { if ( setting == NULL ) return ; CGUIDialogSettingsManualBase :: OnSettingAction ( setting ) ; const std :: string & settingId = setting -> GetId ( ) ; if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) { VECSOURCES shares ; g_mediaManager . GetLocalDrives ( shares ) ; g_mediaManager . GetNetworkLocations ( shares ) ; g_mediaManager . GetRemovableDrives ( shares ) ; std :: string strDirectory = m_settings . m_strPath ; if ( ! strDirectory . empty ( ) ) { URIUtils :: AddSlashAtEnd ( strDirectory ) ; bool bIsSource ; if ( CUtil :: GetMatchingSource ( strDirectory , shares , bIsSource ) < 0 ) { CMediaSource share ; share . strName = g_localizeStrings . Get ( 13278 ) ; share . strPath = strDirectory ; shares . push_back ( share ) ; } } else strDirectory = " default ▁ location " ; if ( CGUIDialogFileBrowser :: ShowAndGetDirectory ( shares , g_localizeStrings . Get ( 661 ) , strDirectory , true ) ) { if ( ! strDirectory . empty ( ) ) { m_destinationChecked = true ; m_settings . m_strPath = strDirectory ; SetLabel2 ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , strDirectory ) ; SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; } } UpdateButtons ( ) ; } } bool CGUIDialogLibExportSettings :: OnMessage ( CGUIMessage & message ) { switch ( message . GetMessage ( ) ) { case GUI_MSG_CLICKED : { int iControl = message . GetSenderId ( ) ; if ( iControl == CONTROL_SETTINGS_OKAY_BUTTON ) { OnOK ( ) ; return true ; } } break ; } return CGUIDialogSettingsManualBase :: OnMessage ( message ) ; } void CGUIDialogLibExportSettings :: OnOK ( ) { if ( m_settings . IsToLibFolders ( ) ) { std :: string path = CServiceBroker :: GetSettings ( ) . GetString ( CSettings :: SETTING_MUSICLIBRARY_ARTISTSFOLDER ) ; if ( path . empty ( ) ) { if ( HELPERS :: ShowYesNoDialogText ( 20223 , 38317 , 186 , 10004 ) == DialogResponse :: YES ) { m_confirmed = false ; Close ( ) ; CServiceBroker :: GetGUI ( ) -> GetWindowManager ( ) . ActivateWindow ( WINDOW_SETTINGS_MEDIA , CSettings :: SETTING_MUSICLIBRARY_ARTISTSFOLDER ) ; } return ; } } else if ( ! m_destinationChecked ) { if ( ! XFILE :: CDirectory :: Exists ( m_settings . m_strPath ) ) { HELPERS :: ShowOKDialogText ( CVariant { 38300 } , CVariant { 38318 } ) ; return ; } } m_confirmed = true ; Save ( ) ; Close ( ) ; } void CGUIDialogLibExportSettings :: Save ( ) { CLog :: Log ( LOGINFO , " CGUIDialogMusicExportSettings : ▁ Save ( ) ▁ called " ) ; CServiceBroker :: GetSettings ( ) . SetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE , m_settings . GetExportType ( ) ) ; CServiceBroker :: GetSettings ( ) . SetString ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , m_settings . m_strPath ) ; CServiceBroker :: GetSettings ( ) . SetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS , m_settings . GetItemsToExport ( ) ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED , m_settings . m_unscraped ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , m_settings . m_overwrite ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , m_settings . m_artwork ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_skipnfo ) ; CServiceBroker :: GetSettings ( ) . Save ( ) ; } void CGUIDialogLibExportSettings :: SetupView ( ) { CGUIDialogSettingsManualBase :: SetupView ( ) ; SetHeading ( 38300 ) ; SET_CONTROL_HIDDEN ( CONTROL_SETTINGS_CUSTOM_BUTTON ) ; SET_CONTROL_LABEL ( CONTROL_SETTINGS_OKAY_BUTTON , 38319 ) ; SET_CONTROL_LABEL ( CONTROL_SETTINGS_CANCEL_BUTTON , 222 ) ; SetLabel2 ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , m_settings . m_strPath ) ; if ( m_settings . IsSingleFile ( ) ) { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , false ) ; } else if ( m_settings . IsSeparateFiles ( ) ) { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } else { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } UpdateButtons ( ) ; } void CGUIDialogLibExportSettings :: UpdateButtons ( ) { bool enableExport ( true ) ; if ( m_settings . IsSingleFile ( ) || m_settings . IsSeparateFiles ( ) ) enableExport = ! m_settings . m_strPath . empty ( ) ; CONTROL_ENABLE_ON_CONDITION ( CONTROL_SETTINGS_OKAY_BUTTON , enableExport ) ; if ( ! enableExport ) SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; } void CGUIDialogLibExportSettings :: InitializeSettings ( ) { CGUIDialogSettingsManualBase :: InitializeSettings ( ) ; std :: shared_ptr < CSettingCategory > category = AddCategory ( " exportsettings " , - 1 ) ; if ( ! category ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : ▁ unable ▁ to ▁ setup ▁ settings " ) ; return ; } std :: shared_ptr < CSettingGroup > groupDetails = AddGroup ( category ) ; if ( ! groupDetails ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : ▁ unable ▁ to ▁ setup ▁ settings " ) ; return ; } TranslatableIntegerSettingOptions entries ; entries . push_back ( std :: make_pair ( 38301 , ELIBEXPORT_SINGLEFILE ) ) ; entries . push_back ( std :: make_pair ( 38302 , ELIBEXPORT_SEPARATEFILES ) ) ; entries . push_back ( std :: make_pair ( 38303 , ELIBEXPORT_TOLIBRARYFOLDER ) ) ; AddList ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE , 38304 , SettingLevel :: Basic , m_settings . GetExportType ( ) , entries , 38304 ) ; AddButton ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , 38305 , SettingLevel :: Basic ) ; entries . clear ( ) ; entries . push_back ( std :: make_pair ( 132 , ELIBEXPORT_ALBUMS ) ) ; entries . push_back ( std :: make_pair ( 38043 , ELIBEXPORT_ALBUMARTISTS ) ) ; entries . push_back ( std :: make_pair ( 38312 , ELIBEXPORT_SONGARTISTS ) ) ; entries . push_back ( std :: make_pair ( 38313 , ELIBEXPORT_OTHERARTISTS ) ) ; AddList ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS , 38306 , SettingLevel :: Basic , m_settings . GetExportItems ( ) , entries , 133 , 1 ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED , 38308 , SettingLevel :: Basic , m_settings . m_unscraped ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , 38307 , SettingLevel :: Basic , m_settings . m_artwork ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , 38309 , SettingLevel :: Basic , m_settings . m_skipnfo ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , 38310 , SettingLevel :: Basic , m_settings . m_overwrite ) ; } void CGUIDialogLibExportSettings :: SetLabel2 ( const std :: string & settingid , const std :: string & label ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) SET_CONTROL_LABEL2 ( settingControl -> GetID ( ) , label ) ; } void CGUIDialogLibExportSettings :: ToggleState ( const std :: string & settingid , bool enabled ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) { if ( enabled ) CONTROL_ENABLE ( settingControl -> GetID ( ) ) ; else CONTROL_DISABLE ( settingControl -> GetID ( ) ) ; } } void CGUIDialogLibExportSettings :: SetFocus ( const std :: string & settingid ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) SET_CONTROL_FOCUS ( settingControl -> GetID ( ) , 0 ) ; } int CGUIDialogLibExportSettings :: GetExportItemsFromSetting ( SettingConstPtr setting ) { std :: shared_ptr < const CSettingList > settingList = std :: static_pointer_cast < const CSettingList > ( setting ) ; if ( settingList -> GetElementType ( ) != SettingType :: Integer ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : : % s ▁ - ▁ wrong ▁ items ▁ element ▁ type " , __FUNCTION__ ) ; return 0 ; } int exportitems = 0 ; std :: vector < CVariant > list = CSettingUtils :: GetList ( settingList ) ; for ( const auto & value : list ) { if ( ! value . isInteger ( ) ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : : % s ▁ - ▁ wrong ▁ items ▁ value ▁ type " , __FUNCTION__ ) ; return 0 ; } exportitems += value . asInteger ( ) ; } return exportitems ; } </DOCUMENT>
<DOCUMENT_ID="wayfinder/Wayfinder-S60-Navigator/tree/master/CPP/Shared/GuiProt/GeneralParamReceiver.cpp"> # include " arch . h " # include " GuiProt / GuiParameterEnums . h " # include " GuiProt / GuiProtEnums . h " # include " GuiProt / GuiProtMess . h " # include " GuiProt / GeneralParamReceiver . h " # include " GuiProt / GuiProtMessageHandler . h " # include " GenericSettingsData . h " namespace isab { GeneralParamReceiver :: ~ GeneralParamReceiver ( ) { m_guiProtHandler -> DeregisterReceiver ( this , isab :: GuiProtEnums :: SET_GENERAL_PARAMETER ) ; m_guiProtHandler -> DeregisterReceiver ( this , isab :: GuiProtEnums :: GET_GENERAL_PARAMETER ) ; } void GeneralParamReceiver :: init ( ) { m_guiProtHandler -> RegisterReceiver ( this , isab :: GuiProtEnums :: SET_GENERAL_PARAMETER ) ; m_guiProtHandler -> RegisterReceiver ( this , isab :: GuiProtEnums :: GET_GENERAL_PARAMETER ) ; } bool GeneralParamReceiver :: decodedParamNoValue ( uint32 paramId ) { return false ; } bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const float * data , int32 numEntries ) { return false ; } bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const uint8 * data , int32 numEntries ) { return false ; } bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const char * * data , int32 numEntries ) { return false ; } bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const int32 * data , int32 numEntries ) { switch ( paramId ) { case GuiProtEnums :: paramAutoReroute : { m_settingsData -> m_autoReroute = data [ 0 ] ; } break ; case GuiProtEnums :: paramBacklightStrategy : { m_settingsData -> m_backlightStrategy = data [ 0 ] ; } break ; case GuiProtEnums :: paramAutoTracking : { m_settingsData -> m_autoTracking = data [ 0 ] ; } break ; case GuiProtEnums :: paramDistanceMode : { m_settingsData -> m_distanceMode = data [ 0 ] ; } break ; case GuiProtEnums :: paramFavoriteShow : { m_settingsData -> m_favoriteShowInMap = data [ 0 ] ; } break ; case GuiProtEnums :: paramHighways : { m_settingsData -> m_routeHighways = data [ 0 ] ; } break ; case GuiProtEnums :: paramTollRoads : { m_settingsData -> m_routeTollRoads = data [ 0 ] ; } break ; case GuiProtEnums :: paramTimeDist : { m_settingsData -> m_routeCostType = data [ 0 ] ; } break ; case GuiProtEnums :: paramTrackingLevel : { m_settingsData -> m_trackingLevel = data [ 0 ] ; } break ; case GuiProtEnums :: paramTransportationType : { m_settingsData -> m_transportationType = data [ 0 ] ; } break ; case GuiProtEnums :: paramTurnSoundsLevel : { m_settingsData -> m_turnSoundsLevel = data [ 0 ] ; } break ; case GuiProtEnums :: userTrafficUpdatePeriod : { int32 val = data [ 0 ] ; m_settingsData -> m_trafficUpdatePeriod = 0xbfffffff & val ; m_settingsData -> m_trafficOldUpdatePeriod = 0xbfffffff & val ; m_settingsData -> m_trafficUpdate = 0x40000000 & val ? 0 : 1 ; m_settingsData -> m_trafficOldUpdate = 0x40000000 & val ? 0 : 1 ; } break ; case GuiProtEnums :: paramAutomaticRouteOnSMSDest : { m_settingsData -> m_autoRouteOnSMSDest = data [ 0 ] ; } break ; case GuiProtEnums :: paramKeepSMSDestInInbox : { m_settingsData -> m_keepSMSDestInInbox = data [ 0 ] ; } break ; case GuiProtEnums :: paramStoreSMSDestInMyDest : { m_settingsData -> m_storeSMSDestInFavorites = data [ 0 ] ; } break ; case GuiProtEnums :: paramPositionSymbol : { m_settingsData -> m_positionSymbol = data [ 0 ] ; } break ; case GuiProtEnums :: paramCheckForUpdates : { m_settingsData -> m_checkForUpdates = data [ 0 ] ; } break ; default : return false ; break ; } return true ; } bool GeneralParamReceiver :: GuiProtReceiveMessage ( class GuiProtMess * mess ) { GuiProtEnums :: MessageType type = mess -> getMessageType ( ) ; if ( type == GuiProtEnums :: GET_GENERAL_PARAMETER ) { isab :: GeneralParameterMess * gpm = ( isab :: GeneralParameterMess * ) mess ; return decodedParamNoValue ( gpm -> getParamId ( ) ) ; } else if ( type == GuiProtEnums :: SET_GENERAL_PARAMETER ) { isab :: GeneralParameterMess * gpm = ( isab :: GeneralParameterMess * ) mess ; switch ( gpm -> getParamType ( ) ) { case isab :: GuiProtEnums :: paramTypeInt32 : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getIntegerData ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramTypeFloat : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getFloatData ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramTypeBinary : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getBinaryData ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramTypeString : return decodedParamValue ( gpm -> getParamId ( ) , ( const char * * ) gpm -> getStringData ( ) , gpm -> getNumEntries ( ) ) ; break ; default : case isab :: GuiProtEnums :: paramTypeInvalid : return false ; break ; } } return false ; } } </DOCUMENT>
<DOCUMENT_ID="ostash/qt-creator-i18n-uk/tree/master/src/plugins/help/xbelsupport.cpp"> # include " xbelsupport . h " # include " bookmarkmanager . h " # include < QCoreApplication > using namespace Help :: Internal ; struct Bookmark { QString title ; QString url ; bool folded ; } ; XbelWriter :: XbelWriter ( BookmarkModel * model ) : QXmlStreamWriter ( ) , treeModel ( model ) { setAutoFormatting ( true ) ; } void XbelWriter :: writeToFile ( QIODevice * device ) { setDevice ( device ) ; writeStartDocument ( ) ; writeDTD ( QLatin1String ( " < ! DOCTYPE ▁ xbel > " ) ) ; writeStartElement ( QLatin1String ( " xbel " ) ) ; writeAttribute ( QLatin1String ( " version " ) , QLatin1String ( "1.0" ) ) ; QStandardItem * root = treeModel -> invisibleRootItem ( ) ; for ( int i = 0 ; i < root -> rowCount ( ) ; ++ i ) writeData ( root -> child ( i ) ) ; writeEndDocument ( ) ; } void XbelWriter :: writeData ( QStandardItem * child ) { Bookmark entry ; entry . title = child -> data ( Qt :: DisplayRole ) . toString ( ) ; entry . url = child -> data ( Qt :: UserRole + 10 ) . toString ( ) ; if ( entry . url == QLatin1String ( " Folder " ) ) { writeStartElement ( QLatin1String ( " folder " ) ) ; entry . folded = ! child -> data ( Qt :: UserRole + 11 ) . toBool ( ) ; writeAttribute ( QLatin1String ( " folded " ) , entry . folded ? QLatin1String ( " yes " ) : QLatin1String ( " no " ) ) ; writeTextElement ( QLatin1String ( " title " ) , entry . title ) ; for ( int i = 0 ; i < child -> rowCount ( ) ; ++ i ) writeData ( child -> child ( i ) ) ; writeEndElement ( ) ; } else { writeStartElement ( QLatin1String ( " bookmark " ) ) ; writeAttribute ( QLatin1String ( " href " ) , entry . url ) ; writeTextElement ( QLatin1String ( " title " ) , entry . title ) ; writeEndElement ( ) ; } } XbelReader :: XbelReader ( BookmarkModel * tree , BookmarkModel * list ) : QXmlStreamReader ( ) , treeModel ( tree ) , listModel ( list ) { bookmarkIcon = QIcon ( QLatin1String ( " : / help / images / bookmark . png " ) ) ; folderIcon = QApplication :: style ( ) -> standardIcon ( QStyle :: SP_DirClosedIcon ) ; } bool XbelReader :: readFromFile ( QIODevice * device ) { setDevice ( device ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " xbel " ) && attributes ( ) . value ( QLatin1String ( " version " ) ) == QLatin1String ( "1.0" ) ) { readXBEL ( ) ; } else { raiseError ( QCoreApplication :: translate ( " Help : : Internal : : XbelReader " , " The ▁ file ▁ is ▁ not ▁ an ▁ XBEL ▁ version ▁ 1.0 ▁ file . " ) ) ; } } } return ! error ( ) ; } void XbelReader :: readXBEL ( ) { while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " folder " ) ) readFolder ( 0 ) ; else if ( name ( ) == QLatin1String ( " bookmark " ) ) readBookmark ( 0 ) ; else readUnknownElement ( ) ; } } } void XbelReader :: readUnknownElement ( ) { while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) readUnknownElement ( ) ; } } void XbelReader :: readFolder ( QStandardItem * item ) { QStandardItem * folder = createChildItem ( item ) ; folder -> setIcon ( folderIcon ) ; folder -> setData ( QLatin1String ( " Folder " ) , Qt :: UserRole + 10 ) ; bool expanded = ( attributes ( ) . value ( QLatin1String ( " folded " ) ) != QLatin1String ( " no " ) ) ; folder -> setData ( expanded , Qt :: UserRole + 11 ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " title " ) ) folder -> setText ( readElementText ( ) ) ; else if ( name ( ) == QLatin1String ( " folder " ) ) readFolder ( folder ) ; else if ( name ( ) == QLatin1String ( " bookmark " ) ) readBookmark ( folder ) ; else readUnknownElement ( ) ; } } } void XbelReader :: readBookmark ( QStandardItem * item ) { QStandardItem * bookmark = createChildItem ( item ) ; bookmark -> setIcon ( bookmarkIcon ) ; bookmark -> setText ( QCoreApplication :: translate ( " Help : : Internal : : XbelReader " , " Unknown ▁ title " ) ) ; bookmark -> setData ( attributes ( ) . value ( QLatin1String ( " href " ) ) . toString ( ) , Qt :: UserRole + 10 ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " title " ) ) bookmark -> setText ( readElementText ( ) ) ; else readUnknownElement ( ) ; } } listModel -> appendRow ( bookmark -> clone ( ) ) ; } QStandardItem * XbelReader :: createChildItem ( QStandardItem * item ) { QStandardItem * childItem = new QStandardItem ( ) ; childItem -> setEditable ( false ) ; if ( item ) item -> appendRow ( childItem ) ; else treeModel -> appendRow ( childItem ) ; return childItem ; } </DOCUMENT>
<DOCUMENT_ID="carvalhomb/tsmells/tree/master/sample/poco/poco/Net/src/ICMPPacket.cpp"> # include " Poco / Net / ICMPPacket . h " # include " Poco / Net / ICMPv4PacketImpl . h " # include " Poco / Net / NetException . h " # include " Poco / Timestamp . h " # include " Poco / Timespan . h " # include " Poco / Process . h " # include " Poco / NumberFormatter . h " # include < sstream > using Poco :: InvalidArgumentException ; using Poco :: NotImplementedException ; using Poco :: Timestamp ; using Poco :: Timespan ; using Poco :: Process ; using Poco :: NumberFormatter ; using Poco :: UInt8 ; using Poco :: UInt16 ; using Poco :: Int32 ; namespace Poco { namespace Net { ICMPPacket :: ICMPPacket ( IPAddress :: Family family , int dataSize ) : _pImpl ( 0 ) { if ( family == IPAddress :: IPv4 ) _pImpl = new ICMPv4PacketImpl ( dataSize ) ; # if POCO_HAVE_IPv6 else if ( family == IPAddress :: IPv6 ) throw NotImplementedException ( " ICMPv6 ▁ packets ▁ not ▁ implemented . " ) ; # endif else throw InvalidArgumentException ( " Invalid ▁ or ▁ unsupported ▁ address ▁ family ▁ passed ▁ to ▁ ICMPPacket " ) ; } ICMPPacket :: ~ ICMPPacket ( ) { delete _pImpl ; } void ICMPPacket :: setDataSize ( int dataSize ) { _pImpl -> setDataSize ( dataSize ) ; } int ICMPPacket :: getDataSize ( ) const { return _pImpl -> getDataSize ( ) ; } int ICMPPacket :: packetSize ( ) const { return _pImpl -> packetSize ( ) ; } int ICMPPacket :: maxPacketSize ( ) const { return _pImpl -> maxPacketSize ( ) ; } const Poco :: UInt8 * ICMPPacket :: packet ( ) { return _pImpl -> packet ( ) ; } struct timeval ICMPPacket :: time ( Poco :: UInt8 * buffer , int length ) const { return _pImpl -> time ( buffer , length ) ; } bool ICMPPacket :: validReplyID ( Poco :: UInt8 * buffer , int length ) const { return _pImpl -> validReplyID ( buffer , length ) ; } std :: string ICMPPacket :: errorDescription ( Poco :: UInt8 * buffer , int length ) { return _pImpl -> errorDescription ( buffer , length ) ; } std :: string ICMPPacket :: typeDescription ( int typeId ) { return _pImpl -> typeDescription ( typeId ) ; } } } </DOCUMENT>
<DOCUMENT_ID="Tomcc/dolphin/tree/master/Source/Core/Core/HW/EXI/EXI_DeviceAGP.cpp"> # include " Core / HW / EXI / EXI _ DeviceAGP . h " # include < algorithm > # include < memory > # include < string > # include < vector > # include " Common / ChunkFile . h " # include " Common / CommonTypes . h " # include " Common / File . h " # include " Common / Logging / Log . h " # include " Common / StringUtil . h " # include " Core / ConfigManager . h " namespace ExpansionInterface { CEXIAgp :: CEXIAgp ( int index ) { m_slot = index ; m_rom_size = 0 ; LoadRom ( ) ; m_address = 0 ; } CEXIAgp :: ~ CEXIAgp ( ) { std :: string path ; std :: string filename ; std :: string ext ; std :: string gbapath ; SplitPath ( m_slot == 0 ? SConfig :: GetInstance ( ) . m_strGbaCartA : SConfig :: GetInstance ( ) . m_strGbaCartB , & path , & filename , & ext ) ; gbapath = path + filename ; SaveFileFromEEPROM ( gbapath + " . sav " ) ; } void CEXIAgp :: CRC8 ( const u8 * data , u32 size ) { for ( u32 it = 0 ; it < size ; it ++ ) { u8 crc = 0 ; m_hash = m_hash ^ data [ it ] ; if ( m_hash & 1 ) crc ^= 0x5e ; if ( m_hash & 2 ) crc ^= 0xbc ; if ( m_hash & 4 ) crc ^= 0x61 ; if ( m_hash & 8 ) crc ^= 0xc2 ; if ( m_hash & 0x10 ) crc ^= 0x9d ; if ( m_hash & 0x20 ) crc ^= 0x23 ; if ( m_hash & 0x40 ) crc ^= 0x46 ; if ( m_hash & 0x80 ) crc ^= 0x8c ; m_hash = crc ; } } void CEXIAgp :: LoadRom ( ) { std :: string path ; std :: string filename ; std :: string ext ; std :: string gbapath ; SplitPath ( m_slot == 0 ? SConfig :: GetInstance ( ) . m_strGbaCartA : SConfig :: GetInstance ( ) . m_strGbaCartB , & path , & filename , & ext ) ; gbapath = path + filename ; LoadFileToROM ( gbapath + ext ) ; INFO_LOG ( EXPANSIONINTERFACE , " Loaded ▁ GBA ▁ rom : ▁ % s ▁ card : ▁ % d " , gbapath . c_str ( ) , m_slot ) ; LoadFileToEEPROM ( gbapath + " . sav " ) ; INFO_LOG ( EXPANSIONINTERFACE , " Loaded ▁ GBA ▁ sav : ▁ % s ▁ card : ▁ % d " , gbapath . c_str ( ) , m_slot ) ; } void CEXIAgp :: LoadFileToROM ( const std :: string & filename ) { File :: IOFile pStream ( filename , " rb " ) ; if ( pStream ) { u64 filesize = pStream . GetSize ( ) ; m_rom_size = filesize & 0xFFFFFFFF ; m_rom_mask = ( m_rom_size - 1 ) ; m_rom . resize ( m_rom_size ) ; pStream . ReadBytes ( m_rom . data ( ) , filesize ) ; } else { m_rom . resize ( 0x2000 ) ; } } void CEXIAgp :: LoadFileToEEPROM ( const std :: string & filename ) { File :: IOFile pStream ( filename , " rb " ) ; if ( pStream ) { u64 filesize = pStream . GetSize ( ) ; m_eeprom_size = filesize & 0xFFFFFFFF ; m_eeprom_mask = ( m_eeprom_size - 1 ) ; m_eeprom . resize ( m_eeprom_size ) ; pStream . ReadBytes ( m_eeprom . data ( ) , filesize ) ; if ( ( m_eeprom_size == 512 ) || ( m_eeprom_size == 8192 ) ) { for ( u32 index = 0 ; index < ( m_eeprom_size / 8 ) ; index ++ ) { u64 NewVal = 0 ; for ( u32 indexb = 0 ; indexb < 8 ; indexb ++ ) NewVal = ( NewVal << 0x8 ) | m_eeprom [ index * 8 + indexb ] ; ( ( u64 * ) ( m_eeprom . data ( ) ) ) [ index ] = NewVal ; } m_eeprom_add_end = ( m_eeprom_size == 512 ? ( 2 + 6 ) : ( 2 + 14 ) ) ; m_eeprom_add_mask = ( m_eeprom_size == 512 ? 0x3F : 0x3FF ) ; m_eeprom_read_mask = ( m_eeprom_size == 512 ? 0x80 : 0x8000 ) ; m_eeprom_status_mask = ( m_rom_size == 0x2000000 ? 0x1FFFF00 : 0x1000000 ) ; } else m_eeprom_status_mask = 0 ; } else { m_eeprom_size = 0 ; m_eeprom . clear ( ) ; } } void CEXIAgp :: SaveFileFromEEPROM ( const std :: string & filename ) { File :: IOFile pStream ( filename , " wb " ) ; if ( pStream ) { if ( ( m_eeprom_size == 512 ) || ( m_eeprom_size == 8192 ) ) { std :: vector < u8 > temp_eeprom ( m_eeprom_size ) ; for ( u32 index = 0 ; index < ( m_eeprom_size / 8 ) ; index ++ ) { u64 NewVal = ( ( u64 * ) ( m_eeprom . data ( ) ) ) [ index ] ; for ( u32 indexb = 0 ; indexb < 8 ; indexb ++ ) temp_eeprom [ index * 8 + ( 7 - indexb ) ] = ( NewVal >> ( indexb * 8 ) ) & 0xFF ; } pStream . WriteBytes ( temp_eeprom . data ( ) , m_eeprom_size ) ; } else { pStream . WriteBytes ( m_eeprom . data ( ) , m_eeprom_size ) ; } } } u32 CEXIAgp :: ImmRead ( u32 _uSize ) { u32 uData = 0 ; u8 RomVal1 , RomVal2 , RomVal3 , RomVal4 ; switch ( m_current_cmd ) { case 0xAE000000 : uData = 0x5AAA5517 ; m_current_cmd = 0 ; break ; case 0xAE010000 : uData = ( m_return_pos == 0 ) ? 0x01020304 : 0xF0020304 ; if ( m_return_pos == 1 ) m_current_cmd = 0 ; else m_return_pos = 1 ; break ; case 0xAE020000 : if ( m_eeprom_write_status && ( ( m_rw_offset & m_eeprom_status_mask ) == m_eeprom_status_mask ) && ( m_eeprom_status_mask != 0 ) ) { RomVal1 = 0x1 ; RomVal2 = 0x0 ; } else { RomVal1 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal2 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; } CRC8 ( & RomVal2 , 1 ) ; CRC8 ( & RomVal1 , 1 ) ; uData = ( RomVal2 << 24 ) | ( RomVal1 << 16 ) | ( m_hash << 8 ) ; m_current_cmd = 0 ; break ; case 0xAE030000 : if ( _uSize == 1 ) { uData = 0xFF000000 ; m_current_cmd = 0 ; } else { RomVal1 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal2 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal3 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal4 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; CRC8 ( & RomVal2 , 1 ) ; CRC8 ( & RomVal1 , 1 ) ; CRC8 ( & RomVal4 , 1 ) ; CRC8 ( & RomVal3 , 1 ) ; uData = ( RomVal2 << 24 ) | ( RomVal1 << 16 ) | ( RomVal4 << 8 ) | ( RomVal3 ) ; } break ; case 0xAE040000 : if ( m_eeprom_size == 0 ) RomVal1 = 0xFF ; else RomVal1 = ( m_eeprom . data ( ) ) [ m_eeprom_pos ] ; CRC8 ( & RomVal1 , 1 ) ; uData = ( RomVal1 << 24 ) | ( m_hash << 16 ) ; m_current_cmd = 0 ; break ; case 0xAE0B0000 : RomVal1 = EE_READ_FALSE ; if ( ( m_eeprom_size != 0 ) && ( m_eeprom_pos >= EE_IGNORE_BITS ) && ( ( ( ( u64 * ) m_eeprom . data ( ) ) [ ( m_eeprom_cmd >> 1 ) & m_eeprom_add_mask ] ) >> ( ( EE_DATA_BITS - 1 ) - ( m_eeprom_pos - EE_IGNORE_BITS ) ) ) & 0x1 ) { RomVal1 = EE_READ_TRUE ; } RomVal2 = 0 ; CRC8 ( & RomVal2 , 1 ) ; CRC8 ( & RomVal1 , 1 ) ; uData = ( RomVal2 << 24 ) | ( RomVal1 << 16 ) | ( m_hash << 8 ) ; m_eeprom_pos ++ ; m_current_cmd = 0 ; break ; case 0xAE070000 : case 0xAE0C0000 : uData = m_hash << 24 ; m_current_cmd = 0 ; break ; default : uData = 0x0 ; m_current_cmd = 0 ; break ; } DEBUG_LOG ( EXPANSIONINTERFACE , " AGP ▁ read ▁ % x " , uData ) ; return uData ; } void CEXIAgp :: ImmWrite ( u32 _uData , u32 _uSize ) { if ( ( _uSize == 1 ) && ( ( _uData & 0xFF000000 ) == 0 ) ) return ; u8 HashCmd ; u64 Mask ; DEBUG_LOG ( EXPANSIONINTERFACE , " AGP ▁ command ▁ % x " , _uData ) ; switch ( m_current_cmd ) { case 0xAE020000 : case 0xAE030000 : m_rw_offset = ( ( _uData & 0xFFFFFF00 ) >> ( 8 - 1 ) ) ; m_return_pos = 0 ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x0000FF00 ) >> 8 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE040000 : m_eeprom_pos = ( ( _uData & 0xFFFF0000 ) >> 0x10 ) & m_eeprom_mask ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE070000 : m_eeprom_pos = ( ( _uData & 0xFFFF0000 ) >> 0x10 ) & m_eeprom_mask ; if ( m_eeprom_size != 0 ) ( ( m_eeprom . data ( ) ) ) [ ( m_eeprom_pos ) ] = ( _uData & 0x0000FF00 ) >> 0x8 ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x0000FF00 ) >> 8 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE0C0000 : if ( ( m_eeprom_pos < m_eeprom_add_end ) || ( m_eeprom_pos == ( ( m_eeprom_cmd & m_eeprom_read_mask ) ? m_eeprom_add_end : m_eeprom_add_end + EE_DATA_BITS ) ) ) { Mask = ( 1ULL << ( m_eeprom_add_end - std :: min ( m_eeprom_pos , m_eeprom_add_end ) ) ) ; if ( ( _uData >> 16 ) & 0x1 ) m_eeprom_cmd |= Mask ; else m_eeprom_cmd &= ~ Mask ; if ( m_eeprom_pos == m_eeprom_add_end + EE_DATA_BITS ) { if ( m_eeprom_size != 0 ) ( ( u64 * ) ( m_eeprom . data ( ) ) ) [ ( m_eeprom_cmd >> 1 ) & m_eeprom_add_mask ] = m_eeprom_data ; m_eeprom_write_status = true ; } } else { Mask = ( 1ULL << ( m_eeprom_add_end + EE_DATA_BITS - 1 - m_eeprom_pos ) ) ; if ( ( _uData >> 16 ) & 0x1 ) m_eeprom_data |= Mask ; else m_eeprom_data &= ~ Mask ; } m_eeprom_pos ++ ; m_return_pos = 0 ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE0B0000 : m_eeprom_write_status = false ; break ; case 0xAE000000 : case 0xAE010000 : case 0xAE090000 : m_eeprom_write_status = false ; case 0xAE0A0000 : m_eeprom_pos = 0 ; default : m_current_cmd = _uData ; m_return_pos = 0 ; m_hash = 0xFF ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; break ; } } void CEXIAgp :: DoState ( PointerWrap & p ) { p . Do ( m_slot ) ; p . Do ( m_address ) ; p . Do ( m_current_cmd ) ; p . Do ( m_eeprom ) ; p . Do ( m_eeprom_cmd ) ; p . Do ( m_eeprom_data ) ; p . Do ( m_eeprom_mask ) ; p . Do ( m_eeprom_pos ) ; p . Do ( m_eeprom_size ) ; p . Do ( m_eeprom_add_end ) ; p . Do ( m_eeprom_add_mask ) ; p . Do ( m_eeprom_read_mask ) ; p . Do ( m_eeprom_status_mask ) ; p . Do ( m_eeprom_write_status ) ; p . Do ( m_hash ) ; p . Do ( m_position ) ; p . Do ( m_return_pos ) ; p . Do ( m_rom ) ; p . Do ( m_rom_mask ) ; p . Do ( m_rom_size ) ; p . Do ( m_rw_offset ) ; } } </DOCUMENT>
<DOCUMENT_ID="asmaurya95/My-ACM-ICPC-Handbook/tree/master/Suffix Array/Naive Implementation.cpp"> # include < iostream > # include < string > # include < map > # include < algorithm > # include < vector > using namespace std ; int main ( ) { string s ; cin >> s ; map < string , int > m ; vector < string > ar ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { string sstr = s . substr ( i , s . size ( ) - i ) ; m [ sstr ] = i ; ar . push_back ( sstr ) ; } sort ( ar . begin ( ) , ar . end ( ) ) ; for ( int i = 0 ; i < ar . size ( ) ; i ++ ) { cout << m [ ar [ i ] ] << endl ; } return 0 ; } </DOCUMENT>
<DOCUMENT_ID="quickhand/Prosit/tree/master/src/highlighter.cpp"> # include " highlighter . h " # include " block _ stats . h " # include " dictionary . h " # include " spell _ checker . h " # include " editor . h " # include < QAction > # include < QContextMenuEvent > # include < QEvent > # include < QMenu > # include < QTextEdit > # include < iostream > # include < QAbstractTextDocumentLayout > # include < QTextLayout > Highlighter :: Highlighter ( Editor * text , Dictionary * dictionary ) : QSyntaxHighlighter ( text -> document ( ) ) , m_dictionary ( dictionary ) , m_text ( text ) , m_enabled ( true ) , m_misspelled ( " # ff0000" ) { connect ( m_text , SIGNAL ( cursorPositionChanged ( ) ) , this , SLOT ( cursorPositionChanged ( ) ) ) ; m_text -> viewport ( ) -> installEventFilter ( this ) ; m_add_action = new QAction ( tr ( " Add " ) , this ) ; m_check_action = new QAction ( tr ( " Check ▁ Spelling . . . " ) , this ) ; } bool Highlighter :: enabled ( ) const { return m_enabled ; } QColor Highlighter :: misspelledColor ( ) const { return m_misspelled ; } void Highlighter :: setEnabled ( bool enabled ) { m_enabled = enabled ; rehighlight ( ) ; } void Highlighter :: setMisspelledColor ( const QColor & color ) { m_misspelled = color ; rehighlight ( ) ; } bool Highlighter :: eventFilter ( QObject * watched , QEvent * event ) { if ( watched != m_text -> viewport ( ) || event -> type ( ) != QEvent :: ContextMenu || ! m_enabled ) { return QSyntaxHighlighter :: eventFilter ( watched , event ) ; } else { QContextMenuEvent * context_event = static_cast < QContextMenuEvent * > ( event ) ; m_start_cursor = m_text -> cursorForPosition ( context_event -> pos ( ) ) ; QTextBlock block = m_start_cursor . block ( ) ; int cursor = m_start_cursor . position ( ) - block . position ( ) ; bool under_mouse = false ; QStringRef word ; QVector < QStringRef > words = static_cast < BlockStats * > ( block . userData ( ) ) -> misspelled ( ) ; for ( int i = 0 ; i < words . count ( ) ; ++ i ) { word = words . at ( i ) ; int delta = cursor - word . position ( ) ; if ( delta >= 0 && delta <= word . length ( ) ) { under_mouse = true ; break ; } } if ( ! under_mouse ) { return false ; } else { m_cursor = m_start_cursor ; m_cursor . setPosition ( word . position ( ) + block . position ( ) ) ; m_cursor . setPosition ( m_cursor . position ( ) + word . length ( ) , QTextCursor :: KeepAnchor ) ; m_word = m_cursor . selectedText ( ) ; m_text -> setTextCursor ( m_cursor ) ; QMenu * menu = new QMenu ; QStringList guesses = m_dictionary -> suggestions ( m_word ) ; if ( ! guesses . isEmpty ( ) ) { foreach ( const QString & guess , guesses ) { menu -> addAction ( guess ) ; } } else { QAction * none_action = menu -> addAction ( tr ( " ( No ▁ suggestions ▁ found ) " ) ) ; none_action -> setEnabled ( false ) ; } menu -> addSeparator ( ) ; menu -> addAction ( m_add_action ) ; menu -> addSeparator ( ) ; menu -> addAction ( m_check_action ) ; connect ( menu , SIGNAL ( triggered ( QAction * ) ) , this , SLOT ( suggestion ( QAction * ) ) ) ; menu -> exec ( context_event -> globalPos ( ) ) ; delete menu ; return true ; } } } void Highlighter :: highlightBlock ( const QString & text ) { QTextCharFormat hformat ; QTextBlockFormat blockformat = currentBlock ( ) . blockFormat ( ) ; if ( blockformat . hasProperty ( QTextFormat :: UserProperty ) ) { hformat . setProperty ( QTextFormat :: FontWeight , blockformat . property ( QTextFormat :: FontWeight ) ) ; hformat . setProperty ( QTextFormat :: FontItalic , blockformat . property ( QTextFormat :: FontItalic ) ) ; hformat . setProperty ( QTextFormat :: FontSizeAdjustment , blockformat . property ( QTextFormat :: FontSizeAdjustment ) ) ; setFormat ( 0 , text . length ( ) , hformat ) ; } if ( ! m_enabled ) { return ; } int cursor = m_text -> textCursor ( ) . position ( ) - currentBlock ( ) . position ( ) ; BlockStats * stats = static_cast < BlockStats * > ( currentBlockUserData ( ) ) ; if ( ! stats ) { stats = new BlockStats ( text , m_dictionary ) ; setCurrentBlockUserData ( stats ) ; } QTextCharFormat error ; error . setUnderlineColor ( m_misspelled ) ; error . setUnderlineStyle ( QTextCharFormat :: SpellCheckUnderline ) ; error . merge ( hformat ) ; QVector < QStringRef > words = stats -> misspelled ( ) ; for ( int i = 0 ; i < words . count ( ) ; ++ i ) { const QStringRef & word = words . at ( i ) ; int delta = cursor - word . position ( ) ; if ( delta < 0 || delta > word . length ( ) ) { setFormat ( word . position ( ) , word . length ( ) , error ) ; } } } void Highlighter :: cursorPositionChanged ( ) { QTextBlock current = m_text -> textCursor ( ) . block ( ) ; if ( m_current != current ) { if ( m_current . isValid ( ) && m_text -> document ( ) -> blockCount ( ) > m_current . blockNumber ( ) ) { rehighlightBlock ( m_current ) ; } m_current = current ; } rehighlightBlock ( m_current ) ; } void Highlighter :: suggestion ( QAction * action ) { if ( action == m_add_action ) { m_text -> setTextCursor ( m_start_cursor ) ; m_dictionary -> add ( m_word ) ; } else if ( action == m_check_action ) { m_text -> setTextCursor ( m_start_cursor ) ; SpellChecker :: checkDocument ( m_text ) ; } else { m_cursor . insertText ( action -> text ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="lassoan/CTK/tree/master/Libs/Core/ctkWorkflowStep.cpp"> # include < QDebug > # include < QMetaType > # include < QObject > # include < QState > # include " ctkWorkflowStep . h " # include " ctkWorkflowStep _ p . h " # include " ctkWorkflow . h " # include " ctkLogger . h " # include < iostream > static ctkLogger logger ( " org . commontk . core . ctkWorkflowStep " ) ; ctkWorkflowStepPrivate :: ctkWorkflowStepPrivate ( ctkWorkflowStep & object ) : q_ptr ( & object ) { qRegisterMetaType < ctkWorkflowStep * > ( " ctkWorkflowStep * " ) ; this -> Workflow = 0 ; this -> WidgetType = false ; this -> HasValidateCommand = false ; this -> HasOnEntryCommand = false ; this -> HasOnExitCommand = false ; this -> ProcessingState = new QState ( ) ; this -> ValidationState = new QState ( ) ; this -> ValidationTransition = new ctkWorkflowIntrastepTransition ( ctkWorkflowIntrastepTransition :: ValidationTransition ) ; this -> ValidationTransition -> setTargetState ( this -> ValidationState ) ; this -> ProcessingState -> addTransition ( this -> ValidationTransition ) ; this -> ValidationFailedTransition = 0 ; this -> ValidationFailedTransition = new ctkWorkflowIntrastepTransition ( ctkWorkflowIntrastepTransition :: ValidationFailedTransition ) ; this -> ValidationFailedTransition -> setTargetState ( this -> ProcessingState ) ; this -> ValidationState -> addTransition ( this -> ValidationFailedTransition ) ; } ctkWorkflowStepPrivate :: ~ ctkWorkflowStepPrivate ( ) { if ( ! this -> ValidationState . isNull ( ) ) { delete this -> ValidationState ; } if ( ! this -> ProcessingState . isNull ( ) ) { delete this -> ProcessingState ; } } void ctkWorkflowStepPrivate :: validationCompleteInternal ( bool validationResults , const QString & branchId ) const { emit validationComplete ( validationResults , branchId ) ; } void ctkWorkflowStepPrivate :: onEntryCompleteInternal ( ) const { emit onEntryComplete ( ) ; } void ctkWorkflowStepPrivate :: onExitCompleteInternal ( ) const { emit onExitComplete ( ) ; } void ctkWorkflowStepPrivate :: invokeValidateCommandInternal ( const QString & desiredBranchId ) const { emit invokeValidateCommand ( desiredBranchId ) ; } void ctkWorkflowStepPrivate :: invokeOnEntryCommandInternal ( const ctkWorkflowStep * comingFrom , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) const { emit invokeOnEntryCommand ( comingFrom , transitionType ) ; } void ctkWorkflowStepPrivate :: invokeOnExitCommandInternal ( const ctkWorkflowStep * goingTo , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) const { emit invokeOnExitCommand ( goingTo , transitionType ) ; } ctkWorkflowStep :: ctkWorkflowStep ( ) : d_ptr ( new ctkWorkflowStepPrivate ( * this ) ) { } ctkWorkflowStep :: ctkWorkflowStep ( const QString & newId ) : d_ptr ( new ctkWorkflowStepPrivate ( * this ) ) { Q_D ( ctkWorkflowStep ) ; d -> Id = newId ; } ctkWorkflowStep :: ctkWorkflowStep ( ctkWorkflowStepPrivate * pimpl , const QString & newId ) : d_ptr ( pimpl ) { Q_D ( ctkWorkflowStep ) ; d -> Id = newId ; } ctkWorkflowStep :: ~ ctkWorkflowStep ( ) { } CTK_GET_CPP ( ctkWorkflowStep , ctkWorkflow * , workflow , Workflow ) ; CTK_SET_CPP ( ctkWorkflowStep , ctkWorkflow * , setWorkflow , Workflow ) ; CTK_GET_CPP ( ctkWorkflowStep , QString , id , Id ) ; void ctkWorkflowStep :: setId ( const QString & newId ) { Q_D ( ctkWorkflowStep ) ; if ( d -> Workflow && d -> Workflow -> hasStep ( newId ) && ! this -> id ( ) . isEmpty ( ) ) { logger . error ( QString ( " ctkWorkflowStep ▁ - ▁ Failed ▁ to ▁ change ▁ id ▁ from ▁ ' %1 ' ▁ to ▁ ' %2 ' ▁ - ▁ " " Step ▁ already ▁ added ▁ to ▁ a ▁ workflow ▁ ! " ) . arg ( this -> id ( ) ) . arg ( newId ) ) ; return ; } d -> Id = newId ; } CTK_GET_CPP ( ctkWorkflowStep , QString , name , Name ) ; CTK_SET_CPP ( ctkWorkflowStep , const QString & , setName , Name ) ; CTK_GET_CPP ( ctkWorkflowStep , QString , description , Description ) ; CTK_SET_CPP ( ctkWorkflowStep , const QString & , setDescription , Description ) ; CTK_GET_CPP ( ctkWorkflowStep , QString , statusText , StatusText ) ; CTK_SET_CPP ( ctkWorkflowStep , const QString & , setStatusText , StatusText ) ; CTK_GET_CPP ( ctkWorkflowStep , bool , hasValidateCommand , HasValidateCommand ) ; CTK_SET_CPP ( ctkWorkflowStep , bool , setHasValidateCommand , HasValidateCommand ) ; CTK_GET_CPP ( ctkWorkflowStep , bool , hasOnEntryCommand , HasOnEntryCommand ) ; CTK_SET_CPP ( ctkWorkflowStep , bool , setHasOnEntryCommand , HasOnEntryCommand ) ; CTK_GET_CPP ( ctkWorkflowStep , bool , hasOnExitCommand , HasOnExitCommand ) ; CTK_SET_CPP ( ctkWorkflowStep , bool , setHasOnExitCommand , HasOnExitCommand ) ; CTK_GET_CPP ( ctkWorkflowStep , QState * , processingState , ProcessingState ) ; CTK_GET_CPP ( ctkWorkflowStep , QState * , validationState , ValidationState ) ; CTK_GET_CPP ( ctkWorkflowStep , ctkWorkflowIntrastepTransition * , validationTransition , ValidationTransition ) ; CTK_GET_CPP ( ctkWorkflowStep , ctkWorkflowIntrastepTransition * , validationFailedTransition , ValidationFailedTransition ) ; CTK_GET_CPP ( ctkWorkflowStep , bool , isWidgetType , WidgetType ) ; QObject * ctkWorkflowStep :: ctkWorkflowStepQObject ( ) { Q_D ( ctkWorkflowStep ) ; return d ; } void ctkWorkflowStep :: validationComplete ( bool validationResults , const QString & branchId ) const { Q_D ( const ctkWorkflowStep ) ; d -> validationCompleteInternal ( validationResults , branchId ) ; } void ctkWorkflowStep :: onEntryComplete ( ) const { Q_D ( const ctkWorkflowStep ) ; d -> onEntryCompleteInternal ( ) ; } void ctkWorkflowStep :: onExitComplete ( ) const { Q_D ( const ctkWorkflowStep ) ; d -> onExitCompleteInternal ( ) ; } void ctkWorkflowStep :: invokeValidateCommand ( const QString & desiredBranchId ) const { Q_D ( const ctkWorkflowStep ) ; d -> invokeValidateCommandInternal ( desiredBranchId ) ; } void ctkWorkflowStep :: invokeOnEntryCommand ( const ctkWorkflowStep * comingFrom , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) const { Q_D ( const ctkWorkflowStep ) ; d -> invokeOnEntryCommandInternal ( comingFrom , transitionType ) ; } void ctkWorkflowStep :: invokeOnExitCommand ( const ctkWorkflowStep * goingTo , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) const { Q_D ( const ctkWorkflowStep ) ; d -> invokeOnExitCommandInternal ( goingTo , transitionType ) ; } void ctkWorkflowStep :: validate ( const QString & desiredBranchId ) { Q_D ( ctkWorkflowStep ) ; logger . info ( QString ( " validate ▁ - ▁ validating ▁ the ▁ input ▁ from ▁ % 1" ) . arg ( d -> Name ) ) ; this -> validationComplete ( true , desiredBranchId ) ; } void ctkWorkflowStep :: onEntry ( const ctkWorkflowStep * comingFrom , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) { Q_UNUSED ( comingFrom ) ; Q_UNUSED ( transitionType ) ; this -> onEntryComplete ( ) ; } void ctkWorkflowStep :: onExit ( const ctkWorkflowStep * goingTo , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) { Q_UNUSED ( goingTo ) ; Q_UNUSED ( transitionType ) ; this -> onExitComplete ( ) ; } </DOCUMENT>
<DOCUMENT_ID="TTimo/doom3.gpl/tree/master/neo/tools/materialeditor/MaterialDef.cpp"> # include " . . / . . / idlib / precompiled . h " # pragma hdrstop # include " MaterialDef . h " MaterialDef :: MaterialDef ( void ) { type = 0 ; quotes = false ; } MaterialDef :: ~ MaterialDef ( void ) { } DWORD MaterialDef :: GetViewData ( const char * viewName ) { DWORD * value = NULL ; viewData . Get ( viewName , & value ) ; return * value ; } void MaterialDef :: SetViewData ( const char * viewName , DWORD value ) { viewData . Set ( viewName , value ) ; } # define MATERIAL_DEF_FILE " MaterialEditorDefs . med " MaterialDefList MaterialDefManager :: materialDefs [ MaterialDefManager :: MATERIAL_DEF_NUM ] ; void MaterialDefManager :: InitializeMaterialDefLists ( ) { char * buffer ; int length = fileSystem -> ReadFile ( MATERIAL_DEF_FILE , ( void * * ) & buffer ) ; if ( length == - 1 ) { common -> Error ( " Couldn ' t ▁ load ▁ material ▁ editor ▁ definition : ▁ % s " , MATERIAL_DEF_FILE ) ; return ; } idLexer src ; if ( ! src . LoadMemory ( buffer , length , MATERIAL_DEF_FILE ) ) { common -> Error ( " Couldn ' t ▁ parse ▁ % s " , MATERIAL_DEF_FILE ) ; fileSystem -> FreeFile ( buffer ) ; } InitializeMaterialDefList ( & src , " materialprops " , & materialDefs [ MATERIAL_DEF_MATERIAL ] ) ; InitializeMaterialDefList ( & src , " stageprops " , & materialDefs [ MATERIAL_DEF_STAGE ] ) ; InitializeMaterialDefList ( & src , " specialmapstageprops " , & materialDefs [ MATERIAL_DEF_SPECIAL_STAGE ] ) ; fileSystem -> FreeFile ( buffer ) ; } void MaterialDefManager :: InitializeMaterialDefList ( idLexer * src , const char * typeName , MaterialDefList * list ) { idToken token ; src -> Reset ( ) ; src -> SkipUntilString ( typeName ) ; src -> SkipUntilString ( " { " ) ; while ( 1 ) { if ( ! src -> ExpectAnyToken ( & token ) ) { return ; } if ( token == " } " ) { break ; } MaterialDef * newProp = new MaterialDef ( ) ; if ( ! token . Icmp ( " TYPE _ GROUP " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_GROUP ; } else if ( ! token . Icmp ( " TYPE _ BOOL " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_BOOL ; } else if ( ! token . Icmp ( " TYPE _ STRING " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_STRING ; } else if ( ! token . Icmp ( " TYPE _ FLOAT " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_FLOAT ; } else if ( ! token . Icmp ( " TYPE _ INT " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_INT ; } src -> ReadToken ( & token ) ; src -> ReadToken ( & token ) ; newProp -> dictName = token ; src -> ReadToken ( & token ) ; src -> ReadToken ( & token ) ; newProp -> displayName = token ; src -> ReadToken ( & token ) ; src -> ReadToken ( & token ) ; newProp -> displayInfo = token ; if ( newProp -> type == MaterialDef :: MATERIAL_DEF_TYPE_STRING ) { newProp -> quotes = false ; src -> ReadToken ( & token ) ; src -> ReadToken ( & token ) ; if ( token == "1" ) { newProp -> quotes = true ; } } src -> SkipRestOfLine ( ) ; list -> Append ( newProp ) ; } } void MaterialDefManager :: DestroyMaterialDefLists ( ) { for ( int i = 0 ; i < MATERIAL_DEF_NUM ; i ++ ) { for ( int j = 0 ; j < materialDefs [ i ] . Num ( ) ; j ++ ) { delete materialDefs [ i ] [ j ] ; } materialDefs [ i ] . Clear ( ) ; } } MaterialDefList * MaterialDefManager :: GetMaterialDefs ( int type ) { if ( type >= 0 && type < MATERIAL_DEF_NUM ) { return & materialDefs [ type ] ; } return NULL ; } </DOCUMENT>
<DOCUMENT_ID="grzegorz2047/HotelReservation/tree/master/fileio.cpp"> # include < stdio . h > # include < string > # include < stdlib . h > # include < time . h > # include < sstream > # include < fstream > # include < vector > # include < iostream > std :: vector < std :: string > readFile ( std :: string filename ) { std :: vector < std :: string > lines ; std :: ifstream read ; std :: string line ; read . open ( filename . c_str ( ) ) ; if ( ! read . good ( ) ) { read . close ( ) ; std :: ofstream create ; create . open ( filename . c_str ( ) ) ; return lines ; } while ( ! read . eof ( ) ) { getline ( read , line ) ; if ( line != " " ) { lines . push_back ( line ) ; } } read . close ( ) ; return lines ; } void saveFile ( std :: string filename , std :: vector < std :: string > lines ) { std :: ofstream save ; save . open ( filename . c_str ( ) ) ; for ( int i = 0 ; i < lines . size ( ) ; i ++ ) { save << lines [ i ] << std :: endl ; } save . close ( ) ; } </DOCUMENT>
<DOCUMENT_ID="carvalhomb/tsmells/tree/master/sample/poco/poco/Foundation/testsuite/src/UniqueExpireCacheTest.cpp"> # include " UniqueExpireCacheTest . h " # include " CppUnit / TestCaller . h " # include " CppUnit / TestSuite . h " # include " Poco / Exception . h " # include " Poco / UniqueExpireCache . h " # include " Poco / UniqueAccessExpireCache . h " # include " Poco / ExpirationDecorator . h " # include " Poco / AccessExpirationDecorator . h " # include " Poco / Bugcheck . h " # include " Poco / Thread . h " using namespace Poco ; struct IntVal { int value ; Poco :: Timestamp validUntil ; IntVal ( int val , Poco :: Timestamp :: TimeDiff v ) : value ( val ) , validUntil ( ) { validUntil += ( v * 1000 ) ; } const Poco :: Timestamp & getExpiration ( ) const { return validUntil ; } } ; typedef AccessExpirationDecorator < int > DIntVal ; # define DURSLEEP 250 # define DURHALFSLEEP DURSLEEP / 2 # define DURWAIT 300 UniqueExpireCacheTest :: UniqueExpireCacheTest ( const std :: string & name ) : CppUnit :: TestCase ( name ) { } UniqueExpireCacheTest :: ~ UniqueExpireCacheTest ( ) { } void UniqueExpireCacheTest :: testClear ( ) { UniqueExpireCache < int , IntVal > aCache ; aCache . add ( 1 , IntVal ( 2 , DURSLEEP ) ) ; aCache . add ( 3 , IntVal ( 4 , DURSLEEP ) ) ; aCache . add ( 5 , IntVal ( 6 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; assert ( aCache . has ( 5 ) ) ; assert ( aCache . get ( 1 ) -> value == 2 ) ; assert ( aCache . get ( 3 ) -> value == 4 ) ; assert ( aCache . get ( 5 ) -> value == 6 ) ; aCache . clear ( ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( ! aCache . has ( 5 ) ) ; } void UniqueExpireCacheTest :: testAccessClear ( ) { UniqueAccessExpireCache < int , DIntVal > aCache ; aCache . add ( 1 , DIntVal ( 2 , DURSLEEP ) ) ; aCache . add ( 3 , DIntVal ( 4 , DURSLEEP ) ) ; aCache . add ( 5 , DIntVal ( 6 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; assert ( aCache . has ( 5 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; assert ( aCache . get ( 3 ) -> value ( ) == 4 ) ; assert ( aCache . get ( 5 ) -> value ( ) == 6 ) ; aCache . clear ( ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( ! aCache . has ( 5 ) ) ; } void UniqueExpireCacheTest :: testAccessUpdate ( ) { UniqueAccessExpireCache < int , DIntVal > aCache ; aCache . add ( 1 , DIntVal ( 2 , DURSLEEP ) ) ; aCache . add ( 3 , DIntVal ( 4 , DURSLEEP ) ) ; aCache . add ( 5 , DIntVal ( 6 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; assert ( aCache . has ( 5 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; Thread :: sleep ( DURSLEEP / 2 ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; Thread :: sleep ( DURSLEEP / 2 ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; Thread :: sleep ( DURSLEEP / 2 ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( ! aCache . has ( 5 ) ) ; Thread :: sleep ( DURSLEEP * 2 ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( ! aCache . has ( 5 ) ) ; aCache . remove ( 666 ) ; } void UniqueExpireCacheTest :: testExpire0 ( ) { UniqueExpireCache < int , IntVal > aCache ; aCache . add ( 1 , IntVal ( 2 , 0 ) ) ; assert ( ! aCache . has ( 1 ) ) ; } void UniqueExpireCacheTest :: testAccessExpire0 ( ) { UniqueAccessExpireCache < int , DIntVal > aCache ; aCache . add ( 1 , DIntVal ( 2 , Timespan ( 0 , 0 ) ) ) ; assert ( ! aCache . has ( 1 ) ) ; } void UniqueExpireCacheTest :: testExpireN ( ) { UniqueExpireCache < int , IntVal > aCache ; aCache . add ( 1 , IntVal ( 2 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; SharedPtr < IntVal > tmp = aCache . get ( 1 ) ; assert ( ! tmp . isNull ( ) ) ; assert ( tmp -> value == 2 ) ; Thread :: sleep ( DURWAIT ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( tmp -> value == 2 ) ; tmp = aCache . get ( 1 ) ; assert ( tmp . isNull ( ) ) ; aCache . add ( 1 , IntVal ( 2 , DURSLEEP ) ) ; Thread :: sleep ( DURHALFSLEEP ) ; aCache . add ( 3 , IntVal ( 4 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; tmp = aCache . get ( 1 ) ; SharedPtr < IntVal > tmp2 = aCache . get ( 3 ) ; assert ( tmp -> value == 2 ) ; assert ( tmp2 -> value == 4 ) ; Thread :: sleep ( DURHALFSLEEP + 25 ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; assert ( tmp -> value == 2 ) ; assert ( tmp2 -> value == 4 ) ; tmp2 = aCache . get ( 3 ) ; assert ( tmp2 -> value == 4 ) ; Thread :: sleep ( DURHALFSLEEP + 25 ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( tmp2 -> value == 4 ) ; tmp = aCache . get ( 1 ) ; tmp2 = aCache . get ( 3 ) ; assert ( ! tmp ) ; assert ( ! tmp2 ) ; aCache . remove ( 666 ) ; aCache . clear ( ) ; assert ( ! aCache . has ( 5 ) ) ; assert ( ! aCache . has ( 3 ) ) ; } void UniqueExpireCacheTest :: testDuplicateAdd ( ) { UniqueExpireCache < int , IntVal > aCache ; aCache . add ( 1 , IntVal ( 2 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value == 2 ) ; aCache . add ( 1 , IntVal ( 3 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value == 3 ) ; } void UniqueExpireCacheTest :: testAccessDuplicateAdd ( ) { UniqueAccessExpireCache < int , DIntVal > aCache ; aCache . add ( 1 , DIntVal ( 2 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; aCache . add ( 1 , DIntVal ( 3 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 3 ) ; } void UniqueExpireCacheTest :: testExpirationDecorator ( ) { typedef ExpirationDecorator < int > ExpireInt ; UniqueExpireCache < int , ExpireInt > aCache ; aCache . add ( 1 , ExpireInt ( 2 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; aCache . add ( 1 , ExpireInt ( 3 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 3 ) ; } void UniqueExpireCacheTest :: setUp ( ) { } void UniqueExpireCacheTest :: tearDown ( ) { } CppUnit :: Test * UniqueExpireCacheTest :: suite ( ) { CppUnit :: TestSuite * pSuite = new CppUnit :: TestSuite ( " UniqueExpireCacheTest " ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testClear ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testAccessClear ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testAccessUpdate ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testExpire0 ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testAccessExpire0 ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testExpireN ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testDuplicateAdd ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testAccessDuplicateAdd ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testExpirationDecorator ) ; return pSuite ; } </DOCUMENT>
<DOCUMENT_ID="poixen/Cockatrice/tree/master/cockatrice/src/dlg_edit_user.cpp"> # include < QSettings > # include < QLabel > # include < QGridLayout > # include < QHBoxLayout > # include < QDialogButtonBox > # include < QDebug > # include " dlg _ edit _ user . h " # include " settingscache . h " DlgEditUser :: DlgEditUser ( QWidget * parent , QString email , int gender , QString country , QString realName ) : QDialog ( parent ) { emailLabel = new QLabel ( tr ( " Email : " ) ) ; emailEdit = new QLineEdit ( ) ; emailLabel -> setBuddy ( emailEdit ) ; emailEdit -> setText ( email ) ; genderLabel = new QLabel ( tr ( " Pronouns : " ) ) ; genderEdit = new QComboBox ( ) ; genderLabel -> setBuddy ( genderEdit ) ; genderEdit -> insertItem ( 0 , QIcon ( " : / resources / genders / unknown . svg " ) , tr ( " Neutral " ) ) ; genderEdit -> insertItem ( 1 , QIcon ( " : / resources / genders / male . svg " ) , tr ( " Masculine " ) ) ; genderEdit -> insertItem ( 2 , QIcon ( " : / resources / genders / female . svg " ) , tr ( " Feminine " ) ) ; genderEdit -> setCurrentIndex ( gender + 1 ) ; countryLabel = new QLabel ( tr ( " Country : " ) ) ; countryEdit = new QComboBox ( ) ; countryLabel -> setBuddy ( countryEdit ) ; countryEdit -> insertItem ( 0 , tr ( " Undefined " ) ) ; countryEdit -> setCurrentIndex ( 0 ) ; QStringList countries = settingsCache -> getCountries ( ) ; int i = 1 ; foreach ( QString c , countries ) { countryEdit -> addItem ( QPixmap ( " : / resources / countries / " + c + " . svg " ) , c ) ; if ( c == country ) countryEdit -> setCurrentIndex ( i ) ; ++ i ; } realnameLabel = new QLabel ( tr ( " Real ▁ name : " ) ) ; realnameEdit = new QLineEdit ( ) ; realnameLabel -> setBuddy ( realnameEdit ) ; realnameEdit -> setText ( realName ) ; QGridLayout * grid = new QGridLayout ; grid -> addWidget ( emailLabel , 0 , 0 ) ; grid -> addWidget ( emailEdit , 0 , 1 ) ; grid -> addWidget ( genderLabel , 1 , 0 ) ; grid -> addWidget ( genderEdit , 1 , 1 ) ; grid -> addWidget ( countryLabel , 2 , 0 ) ; grid -> addWidget ( countryEdit , 2 , 1 ) ; grid -> addWidget ( realnameLabel , 3 , 0 ) ; grid -> addWidget ( realnameEdit , 3 , 1 ) ; QDialogButtonBox * buttonBox = new QDialogButtonBox ( QDialogButtonBox :: Ok | QDialogButtonBox :: Cancel ) ; connect ( buttonBox , SIGNAL ( accepted ( ) ) , this , SLOT ( actOk ( ) ) ) ; connect ( buttonBox , SIGNAL ( rejected ( ) ) , this , SLOT ( actCancel ( ) ) ) ; QVBoxLayout * mainLayout = new QVBoxLayout ; mainLayout -> addLayout ( grid ) ; mainLayout -> addWidget ( buttonBox ) ; setLayout ( mainLayout ) ; setWindowTitle ( tr ( " Edit ▁ user ▁ profile " ) ) ; setFixedHeight ( sizeHint ( ) . height ( ) ) ; setMinimumWidth ( 300 ) ; } void DlgEditUser :: actOk ( ) { accept ( ) ; } void DlgEditUser :: actCancel ( ) { reject ( ) ; } </DOCUMENT>
<DOCUMENT_ID="geocool/libtmx-parser/tree/master/src/tmxparser.cpp"> # include " tmxparser . h " # include " base64 . h " # if ( defined ( _WIN32 ) ) # include < string . h > # endif # if ( ( defined ( ANDROID ) ) ) # include < android / log . h > # include < string . h > # else # include < cstdlib > # include < cstdio > # endif # include < algorithm > # include < string > # include < sstream > # ifndef LOG_TAG # define LOG_TAG " libtmxparser " # endif # if defined ( WIN32 ) || defined ( _WIN32 ) # define PATH_SEPARATOR " \\ " # define PATH_SEPARATOR_ALT " / " # else # define PATH_SEPARATOR " / " # define PATH_SEPARATOR_ALT " / " # endif # define QUOTEME_ ( x ) # x # define QUOTEME ( x ) QUOTEME_ ( x ) # define WHERESTR " [ file ▁ % s , ▁ line ▁ % d ] : ▁ " # define WHEREARG __FILE__ , __LINE__ # if ( ( defined ( ANDROID ) ) ) # ifdef DEBUG # define LOGD ( ... ) __android_log_print ( ANDROID_LOG_DEBUG , LOG_TAG , " ▁ ( " __FILE__ " : " QUOTEME ( __LINE__ ) " ) ▁ " __VA_ARGS__ ) # else # define LOGD ( ... ) # endif # define LOGI ( ... ) __android_log_print ( ANDROID_LOG_INFO , LOG_TAG , " " __VA_ARGS__ ) # define LOGE ( ... ) __android_log_print ( ANDROID_LOG_ERROR , LOG_TAG , __VA_ARGS__ ) # define LOGW ( ... ) __android_log_print ( ANDROID_LOG_WARN , LOG_TAG , __VA_ARGS__ ) # else # ifdef DEBUG # define LOGD ( ... ) fprintf ( stderr , " D / " LOG_TAG " ▁ ( " __FILE__ " : " QUOTEME ( __LINE__ ) " ) : ▁ " __VA_ARGS__ ) ; fprintf ( stderr , " \n " ) ; # else # define LOGD ( ... ) # endif # define LOGI ( ... ) fprintf ( stdout , " I / " QUOTEME ( LOG_TAG ) " ( " " ) " __VA_ARGS__ ) ; fprintf ( stdout , " \n " ) ; # define LOGE ( ... ) fprintf ( stderr , " E / " QUOTEME ( LOG_TAG ) " ( " " ) " __VA_ARGS__ ) ; fprintf ( stderr , " \n " ) ; # define LOGW ( ... ) fprintf ( stderr , " W / " QUOTEME ( LOG_TAG ) " ( " " ) " __VA_ARGS__ ) ; fprintf ( stderr , " \n " ) ; # endif namespace tmxparser { # define CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( XMLELEMENT , ATTRIBNAME , LHS ) if ( XMLELEMENT -> Attribute ( ATTRIBNAME ) != NULL ) { LHS = XMLELEMENT -> Attribute ( ATTRIBNAME ) ; } else { LHS = ' \0' ; } # define CHECK_AND_RETRIEVE_REQ_ATTRIBUTE_STRING ( XMLELEMENT , ATTRIBNAME , LHS ) LHS = XMLELEMENT -> Attribute ( ATTRIBNAME ) ; if ( LHS . size ( ) == 0 ) { LOGE ( " Missing ▁ required ▁ attribute ▁ [ % s ] " , ATTRIBNAME ) ; return TmxReturn :: kMissingRequiredAttribute ; } # define CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( FUNC , ATTRIBNAME , OUT ) if ( FUNC ( ATTRIBNAME , OUT ) == tinyxml2 :: XML_NO_ATTRIBUTE ) { LOGE ( " Missing ▁ required ▁ attribute ▁ [ % s ] " , ATTRIBNAME ) ; return kMissingRequiredAttribute ; } TmxReturn _parseStart ( tinyxml2 :: XMLElement * element , TmxMap * outMap , const std :: string & tilesetPath ) ; TmxReturn _parseEnd ( TmxMap * outMap , const std :: string & tilesetPath ) ; void _parseEndHelper ( TmxImage & image , const std :: string & tilesetPath ) ; TmxReturn _parseMapNode ( tinyxml2 :: XMLElement * element , TmxMap * outMap ) ; TmxReturn _parsePropertyNode ( tinyxml2 :: XMLElement * element , TmxPropertyMap_t * outPropertyMap ) ; TmxReturn _parseImageNode ( tinyxml2 :: XMLElement * element , TmxImage * outImage ) ; TmxReturn _parseTilesetNode ( tinyxml2 :: XMLElement * element , TmxTileset * outTileset ) ; TmxReturn _parseTileDefinitionNode ( tinyxml2 :: XMLElement * element , TmxTileDefinition * outTileDefinition ) ; TmxReturn _parseTileAnimationNode ( tinyxml2 :: XMLElement * element , TmxAnimationFrameCollection_t * outAnimationCollection ) ; TmxReturn _parseLayerNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayer * outLayer ) ; TmxReturn _parseLayerDataNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayerTileCollection_t * outTileCollection ) ; TmxReturn _parseLayerXmlTileNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayerTile * outTile ) ; TmxReturn _calculateTileIndices ( const TmxTilesetCollection_t & tilesets , TmxLayerTile * outTile ) ; TmxReturn _parseObjectGroupNode ( tinyxml2 :: XMLElement * element , TmxObjectGroup * outObjectGroup ) ; TmxReturn _parseObjectNode ( tinyxml2 :: XMLElement * element , TmxObject * outObj ) ; TmxReturn _parseOffsetNode ( tinyxml2 :: XMLElement * element , TmxOffset * offset ) ; TmxReturn _parseImageLayerNode ( tinyxml2 :: XMLElement * element , TmxImageLayer * outImageLayer ) ; TmxReturn parseFromFile ( const std :: string & fileName , TmxMap * outMap , const std :: string & tilesetPath ) { tinyxml2 :: XMLDocument doc ; if ( doc . LoadFile ( fileName . c_str ( ) ) != tinyxml2 :: XML_SUCCESS ) { LOGE ( " Cannot ▁ read ▁ xml ▁ file " ) ; return TmxReturn :: kErrorParsing ; } return _parseStart ( doc . FirstChildElement ( " map " ) , outMap , tilesetPath ) ; } TmxReturn parseFromMemory ( void * data , size_t length , TmxMap * outMap , const std :: string & tilesetPath ) { tinyxml2 :: XMLDocument doc ; if ( doc . Parse ( ( char * ) data , length ) ) { LOGE ( " Cannot ▁ parse ▁ xml ▁ memory ▁ file . . . " ) ; return TmxReturn :: kErrorParsing ; } return _parseStart ( doc . FirstChildElement ( " map " ) , outMap , tilesetPath ) ; } TmxReturn _parseStart ( tinyxml2 :: XMLElement * element , TmxMap * outMap , const std :: string & tilesetPath ) { TmxReturn retVal = _parseMapNode ( element , outMap ) ; return ( retVal == TmxReturn :: kSuccess ) ? _parseEnd ( outMap , tilesetPath ) : retVal ; } TmxReturn _parseEnd ( TmxMap * outMap , const std :: string & tilesetPath ) { for ( auto tileIt = outMap -> tilesetCollection . begin ( ) ; tileIt != outMap -> tilesetCollection . end ( ) ; ++ tileIt ) _parseEndHelper ( tileIt -> image , tilesetPath ) ; for ( auto tileIt = outMap -> imageLayerCollection . begin ( ) ; tileIt != outMap -> imageLayerCollection . end ( ) ; ++ tileIt ) _parseEndHelper ( tileIt -> image , tilesetPath ) ; return TmxReturn :: kSuccess ; } void _parseEndHelper ( TmxImage & image , const std :: string & tilesetPath ) { auto pathSeperatorMissing = ( image . source . find ( PATH_SEPARATOR ) == std :: string :: npos ) ; auto pathSeperatorAltMissing = ( image . source . find ( PATH_SEPARATOR_ALT ) == std :: string :: npos ) ; if ( pathSeperatorMissing && pathSeperatorAltMissing ) { std :: string baseFilename = image . source . substr ( image . source . find_last_of ( PATH_SEPARATOR ) + 1 ) ; auto seperatorThere = ( tilesetPath . find ( PATH_SEPARATOR ) != std :: string :: npos ) ; auto seperatorAltThere = ( tilesetPath . find ( PATH_SEPARATOR_ALT ) != std :: string :: npos ) ; auto tileSetPathSeparator = PATH_SEPARATOR ; if ( ! seperatorThere && seperatorAltThere ) tileSetPathSeparator = PATH_SEPARATOR_ALT ; image . source = tilesetPath + tileSetPathSeparator + baseFilename ; } } TmxReturn _parseMapNode ( tinyxml2 :: XMLElement * element , TmxMap * outMap ) { if ( element == NULL ) { return TmxReturn :: kMissingMapNode ; } outMap -> version = element -> Attribute ( " version " ) ; const char * orientation = element -> Attribute ( " orientation " ) ; if ( orientation != NULL ) { if ( strcmp ( orientation , " orthogonal " ) == 0 ) { outMap -> orientation = TmxOrientation :: kOrthogonal ; } else if ( strcmp ( orientation , " isometric " ) == 0 ) { outMap -> orientation = TmxOrientation :: kIsometric ; } else if ( strcmp ( orientation , " staggered " ) == 0 ) { outMap -> orientation = TmxOrientation :: kStaggered ; } } else { LOGW ( " Missing ▁ orientation ▁ attribute " ) ; } CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " width " , & outMap -> width ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " height " , & outMap -> height ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " tilewidth " , & outMap -> tileWidth ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " tileheight " , & outMap -> tileHeight ) ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " backgroundcolor " , outMap -> backgroundColor ) ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " renderorder " , outMap -> renderOrder ) ; TmxReturn error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outMap -> propertyMap ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ map ▁ properties . . . " ) ; return error ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " tileset " ) ; child != NULL ; child = child -> NextSiblingElement ( " tileset " ) ) { TmxTileset set ; error = _parseTilesetNode ( child , & set ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ tileset ▁ node . . . " ) ; return error ; } outMap -> tilesetCollection . push_back ( set ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " layer " ) ; child != NULL ; child = child -> NextSiblingElement ( " layer " ) ) { TmxLayer layer ; error = _parseLayerNode ( child , outMap -> tilesetCollection , & layer ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ layer ▁ node . . . " ) ; return error ; } outMap -> layerCollection . push_back ( layer ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " objectgroup " ) ; child != NULL ; child = child -> NextSiblingElement ( " objectgroup " ) ) { TmxObjectGroup group ; error = _parseObjectGroupNode ( child , & group ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ objectgroup ▁ node . . . " ) ; return error ; } outMap -> objectGroupCollection . push_back ( group ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " imagelayer " ) ; child != NULL ; child = child -> NextSiblingElement ( " imagelayer " ) ) { TmxImageLayer imageLayer ; error = _parseImageLayerNode ( child , & imageLayer ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ imagelayer ▁ node . . . " ) ; return error ; } outMap -> imageLayerCollection . push_back ( imageLayer ) ; } return error ; } TmxReturn _parsePropertyNode ( tinyxml2 :: XMLElement * element , TmxPropertyMap_t * outPropertyMap ) { if ( element == NULL ) { return TmxReturn :: kSuccess ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " property " ) ; child != NULL ; child = child -> NextSiblingElement ( " property " ) ) { if ( strcmp ( child -> Name ( ) , " property " ) == 0 ) { if ( child -> Attribute ( " name " ) != NULL && child -> Attribute ( " value " ) != NULL ) { ( * outPropertyMap ) [ child -> Attribute ( " name " ) ] = child -> Attribute ( " value " ) ; } else { return TmxReturn :: kMalformedPropertyNode ; } } } return TmxReturn :: kSuccess ; } TmxReturn _parseImageNode ( tinyxml2 :: XMLElement * element , TmxImage * outImage ) { CHECK_AND_RETRIEVE_REQ_ATTRIBUTE_STRING ( element , " source " , outImage -> source ) ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " format " , outImage -> format ) ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " trans " , outImage -> transparentColor ) ; outImage -> width = element -> UnsignedAttribute ( " width " ) ; outImage -> height = element -> UnsignedAttribute ( " height " ) ; return TmxReturn :: kSuccess ; } TmxReturn _parseTilesetNode ( tinyxml2 :: XMLElement * element , TmxTileset * outTileset ) { if ( strcmp ( element -> Name ( ) , " tileset " ) == 0 ) { CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " firstgid " , & outTileset -> firstgid ) ; outTileset -> name = element -> Attribute ( " name " ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " tilewidth " , & outTileset -> tileWidth ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " tileheight " , & outTileset -> tileHeight ) ; outTileset -> tileSpacingInImage = element -> UnsignedAttribute ( " spacing " ) ; outTileset -> tileMarginInImage = element -> UnsignedAttribute ( " margin " ) ; if ( element -> FirstChildElement ( " image " ) == NULL ) { LOGE ( " We ▁ do ▁ not ▁ support ▁ maps ▁ with ▁ tilesets ▁ that ▁ have ▁ no ▁ image ▁ associated ▁ currently . . . " ) ; return kErrorParsing ; } TmxImage image ; TmxReturn error = _parseImageNode ( element -> FirstChildElement ( " image " ) , & outTileset -> image ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ image ▁ node . . . " ) ; return error ; } outTileset -> offset . x = 0 ; outTileset -> offset . y = 0 ; if ( element -> FirstChildElement ( " tileoffset " ) != NULL ) { error = _parseOffsetNode ( element -> FirstChildElement ( " tileoffset " ) , & outTileset -> offset ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " tile " ) ; child != NULL ; child = child -> NextSiblingElement ( " tile " ) ) { TmxTileDefinition tileDef ; tileDef . id = 0 ; error = _parseTileDefinitionNode ( child , & tileDef ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ tile ▁ definition " ) ; return error ; } outTileset -> tileDefinitions [ tileDef . id ] = tileDef ; } outTileset -> colCount = ( outTileset -> image . width - outTileset -> tileMarginInImage ) / ( outTileset -> tileWidth + outTileset -> tileSpacingInImage ) ; outTileset -> rowCount = ( outTileset -> image . height - outTileset -> tileMarginInImage ) / ( outTileset -> tileHeight + outTileset -> tileSpacingInImage ) ; } return TmxReturn :: kSuccess ; } TmxReturn _parseTileDefinitionNode ( tinyxml2 :: XMLElement * element , TmxTileDefinition * outTileDefinition ) { TmxReturn error = TmxReturn :: kSuccess ; outTileDefinition -> id = element -> UnsignedAttribute ( " id " ) ; error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outTileDefinition -> propertyMap ) ; if ( error ) { return error ; } if ( element -> FirstChildElement ( " animation " ) != NULL ) { error = _parseTileAnimationNode ( element -> FirstChildElement ( " animation " ) , & outTileDefinition -> animations ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " objectgroup " ) ; child != NULL ; child = child -> NextSiblingElement ( " objectgroup " ) ) { TmxObjectGroup group ; error = _parseObjectGroupNode ( child , & group ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ objectgroup ▁ node . . . " ) ; return error ; } outTileDefinition -> objectgroups . push_back ( group ) ; } return error ; } TmxReturn _parseTileAnimationNode ( tinyxml2 :: XMLElement * element , TmxAnimationFrameCollection_t * outAnimationCollection ) { for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " frame " ) ; child != NULL ; child = child -> NextSiblingElement ( " frame " ) ) { TmxAnimationFrame frame ; frame . duration = child -> FloatAttribute ( " duration " ) ; frame . tileId = child -> UnsignedAttribute ( " tileid " ) ; outAnimationCollection -> push_back ( frame ) ; } return kSuccess ; } TmxReturn _parseLayerNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayer * outLayer ) { TmxReturn error = TmxReturn :: kSuccess ; outLayer -> name = element -> Attribute ( " name " ) ; if ( element -> Attribute ( " opacity " ) ) outLayer -> opacity = element -> FloatAttribute ( " opacity " ) ; else outLayer -> opacity = 1 . f ; if ( element -> Attribute ( " visible " ) ) outLayer -> visible = ( element -> IntAttribute ( " visible " ) == 1 ? true : false ) ; else outLayer -> visible = true ; outLayer -> width = element -> UnsignedAttribute ( " width " ) ; outLayer -> height = element -> UnsignedAttribute ( " height " ) ; error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outLayer -> propertyMap ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ layer ▁ property ▁ node . . . " ) ; return error ; } tinyxml2 :: XMLElement * dataElement = element -> FirstChildElement ( " data " ) ; if ( dataElement != NULL ) { error = _parseLayerDataNode ( dataElement , tilesets , & outLayer -> tiles ) ; } else { LOGE ( " Layer ▁ missing ▁ data ▁ node . . . " ) ; return TmxReturn :: kMissingDataNode ; } return error ; } TmxReturn _parseLayerDataNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayerTileCollection_t * outTileCollection ) { TmxReturn error = TmxReturn :: kSuccess ; const char * encoding = element -> Attribute ( " encoding " ) ; const char * compression = element -> Attribute ( " compression " ) ; if ( compression != NULL ) { LOGE ( " Does ▁ not ▁ support ▁ compression ▁ yet . . . " ) ; return TmxReturn :: kErrorParsing ; } if ( encoding == NULL ) { for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " tile " ) ; child != NULL ; child = child -> NextSiblingElement ( " tile " ) ) { TmxLayerTile tile ; error = _parseLayerXmlTileNode ( child , tilesets , & tile ) ; outTileCollection -> push_back ( tile ) ; } } else if ( strcmp ( encoding , " csv " ) == 0 ) { std :: stringstream csvss ( element -> FirstChild ( ) -> Value ( ) ) ; unsigned int gid = 0 ; while ( csvss >> gid ) { if ( csvss . peek ( ) == ' , ' || csvss . peek ( ) == ' \n ' ) { csvss . ignore ( ) ; } TmxLayerTile tile ; tile . gid = gid ; error = _calculateTileIndices ( tilesets , & tile ) ; if ( error == TmxReturn :: kErrorParsing ) { return error ; } outTileCollection -> push_back ( tile ) ; } } else if ( strcmp ( encoding , " base64" ) == 0 ) { std :: string csvbase64 = element -> FirstChild ( ) -> Value ( ) ; csvbase64 . erase ( std :: remove ( csvbase64 . begin ( ) , csvbase64 . end ( ) , ' \n ' ) , csvbase64 . end ( ) ) ; csvbase64 . erase ( std :: remove ( csvbase64 . begin ( ) , csvbase64 . end ( ) , '' ) , csvbase64 . end ( ) ) ; csvbase64 . erase ( std :: remove ( csvbase64 . begin ( ) , csvbase64 . end ( ) , ' ▁ ' ) , csvbase64 . end ( ) ) ; std :: string csv = base64_decode ( csvbase64 ) ; unsigned int length = csv . size ( ) / sizeof ( unsigned int ) ; unsigned int * p = ( unsigned int * ) csv . c_str ( ) ; for ( unsigned int i = 0 ; i < length ; i ++ ) { TmxLayerTile tile ; tile . gid = p [ i ] ; error = _calculateTileIndices ( tilesets , & tile ) ; if ( error == TmxReturn :: kErrorParsing ) { return error ; } outTileCollection -> push_back ( tile ) ; } } else { LOGE ( " Unsupported ▁ layer ▁ compression ▁ [ % s ] . . . ▁ coming ▁ soon . . . " , encoding ) ; return TmxReturn :: kErrorParsing ; } return error ; } TmxReturn _parseLayerXmlTileNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayerTile * outTile ) { TmxReturn error = TmxReturn :: kSuccess ; unsigned int gid = element -> UnsignedAttribute ( " gid " ) ; unsigned int flipXFlag = 0x80000000 ; unsigned int flipYFlag = 0x40000000 ; unsigned int flipDiagonalFlag = 0x20000000 ; outTile -> flipX = ( gid & flipXFlag ? true : false ) ; outTile -> flipY = ( gid & flipYFlag ? true : false ) ; outTile -> flipDiagonal = ( gid & flipDiagonalFlag ? true : false ) ; outTile -> gid = ( gid & ~ ( flipXFlag | flipYFlag | flipDiagonalFlag ) ) ; return _calculateTileIndices ( tilesets , outTile ) ; } TmxReturn _calculateTileIndices ( const TmxTilesetCollection_t & tilesets , TmxLayerTile * outTile ) { outTile -> tilesetIndex = 0 ; outTile -> tileFlatIndex = 0 ; if ( outTile -> gid == 0 ) { return TmxReturn :: kSuccess ; } unsigned int index = 0 ; unsigned int lastEndIndex = 1 ; for ( auto it = tilesets . begin ( ) ; it != tilesets . end ( ) ; ++ it ) { unsigned int colCount = it -> colCount ; unsigned int rowCount = it -> rowCount ; unsigned int startIndex = it -> firstgid ; unsigned int endIndex = it -> firstgid + ( colCount * rowCount ) ; if ( outTile -> gid >= startIndex && outTile -> gid < endIndex ) { outTile -> tilesetIndex = index ; outTile -> tileFlatIndex = ( outTile -> gid ) - lastEndIndex ; return TmxReturn :: kSuccess ; } lastEndIndex = endIndex ; index ++ ; } return TmxReturn :: kUnknownTileIndices ; } TmxReturn _parseObjectGroupNode ( tinyxml2 :: XMLElement * element , TmxObjectGroup * outObjectGroup ) { TmxReturn error = TmxReturn :: kSuccess ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " name " , outObjectGroup -> name ) ; if ( element -> Attribute ( " opacity " ) != NULL ) { outObjectGroup -> opacity = element -> FloatAttribute ( " opacity " ) ; } else { outObjectGroup -> opacity = 1.0f ; } if ( element -> Attribute ( " visible " ) != NULL ) { outObjectGroup -> visible = element -> BoolAttribute ( " visible " ) ; } else { outObjectGroup -> visible = true ; } error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outObjectGroup -> propertyMap ) ; if ( error ) { return error ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " object " ) ; child != NULL ; child = child -> NextSiblingElement ( " object " ) ) { TmxObject obj ; error = _parseObjectNode ( child , & obj ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ object ▁ node . . . " ) ; return TmxReturn :: kErrorParsing ; } outObjectGroup -> objects . push_back ( obj ) ; } return error ; } TmxReturn _parseObjectNode ( tinyxml2 :: XMLElement * element , TmxObject * outObj ) { TmxReturn error = TmxReturn :: kSuccess ; if ( element -> Attribute ( " name " ) ) { outObj -> name = element -> Attribute ( " name " ) ; } if ( element -> Attribute ( " type " ) ) { outObj -> type = element -> Attribute ( " type " ) ; } outObj -> x = element -> FloatAttribute ( " x " ) ; outObj -> y = element -> FloatAttribute ( " y " ) ; outObj -> width = element -> FloatAttribute ( " width " ) ; outObj -> height = element -> FloatAttribute ( " height " ) ; outObj -> rotation = element -> FloatAttribute ( " rotation " ) ; outObj -> referenceGid = element -> UnsignedAttribute ( " gid " ) ; outObj -> visible = element -> BoolAttribute ( " visible " ) ; error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outObj -> propertyMap ) ; if ( error ) { return error ; } tinyxml2 :: XMLElement * shapeElement = NULL ; if ( ( shapeElement = element -> FirstChildElement ( " ellipse " ) ) != NULL ) { outObj -> shapeType = kEllipse ; } else if ( ( shapeElement = element -> FirstChildElement ( " polygon " ) ) != NULL ) { outObj -> shapeType = kPolygon ; } else if ( ( shapeElement = element -> FirstChildElement ( " polyline " ) ) != NULL ) { outObj -> shapeType = kPolyline ; } else { outObj -> shapeType = kSquare ; } if ( ( outObj -> shapeType == kPolygon || outObj -> shapeType == kPolyline ) && shapeElement != NULL ) { if ( shapeElement -> Attribute ( " points " ) == NULL ) { LOGE ( " Missing ▁ points ▁ attribute ▁ for ▁ shape ▁ requiring ▁ one . . . " ) ; return TmxReturn :: kErrorParsing ; } std :: string pointString = shapeElement -> Attribute ( " points " ) ; std :: istringstream pairStringStream ( pointString ) ; std :: string pairToken ; while ( std :: getline ( pairStringStream , pairToken , ' ▁ ' ) ) { TmxShapePoint pair ; std :: istringstream pointStringString ( pairToken ) ; std :: string pointToken ; std :: getline ( pointStringString , pointToken , ' , ' ) ; pair . first = ( float ) atof ( pointToken . c_str ( ) ) ; std :: getline ( pointStringString , pointToken , ' , ' ) ; pair . second = ( float ) atof ( pointToken . c_str ( ) ) ; outObj -> shapePoints . push_back ( pair ) ; } } return error ; } TmxReturn calculateTileCoordinatesUV ( const TmxTileset & tileset , unsigned int tileFlatIndex , float pixelCorrection , bool flipY , TmxRect & outRect ) { if ( tileFlatIndex >= tileset . colCount * tileset . rowCount ) { return TmxReturn :: kInvalidTileIndex ; } TileId_t xIndex = tileFlatIndex % tileset . colCount ; TileId_t yIndex = tileFlatIndex / tileset . colCount ; unsigned int widthDelta = tileset . tileSpacingInImage + tileset . tileMarginInImage * xIndex ; unsigned int heightDelta = tileset . tileSpacingInImage + tileset . tileMarginInImage * yIndex ; float u = ( float ) ( ( xIndex * tileset . tileWidth ) + widthDelta + pixelCorrection ) / ( float ) tileset . image . width ; float v = ( float ) ( ( yIndex * tileset . tileHeight ) + heightDelta + pixelCorrection ) / ( float ) tileset . image . height ; float u2 = ( float ) ( ( ( ( xIndex + 1 ) * tileset . tileWidth ) + widthDelta ) - pixelCorrection ) / ( float ) tileset . image . width ; float v2 = ( float ) ( ( ( ( yIndex + 1 ) * tileset . tileHeight ) + heightDelta ) - pixelCorrection ) / ( float ) tileset . image . height ; if ( flipY ) { float tmpV = v ; v = 1 . f - v2 ; v2 = 1 . f - tmpV ; } outRect . u = u ; outRect . v = v ; outRect . u2 = u2 ; outRect . v2 = v2 ; return kSuccess ; } tmxparser :: TmxReturn _parseOffsetNode ( tinyxml2 :: XMLElement * element , TmxOffset * offset ) { TmxReturn error = TmxReturn :: kSuccess ; offset -> x = 0 ; offset -> y = 0 ; if ( element -> Attribute ( " x " ) ) { offset -> x = element -> IntAttribute ( " x " ) ; } if ( element -> Attribute ( " y " ) ) { offset -> y = element -> IntAttribute ( " y " ) ; } return error ; } tmxparser :: TmxReturn _parseImageLayerNode ( tinyxml2 :: XMLElement * element , TmxImageLayer * outImageLayer ) { TmxReturn error = TmxReturn :: kSuccess ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE_STRING ( element , " name " , outImageLayer -> name ) ; if ( element -> QueryUnsignedAttribute ( " x " , & outImageLayer -> x ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> x = 0U ; if ( element -> QueryUnsignedAttribute ( " y " , & outImageLayer -> y ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> y = 0U ; if ( element -> QueryUnsignedAttribute ( " width " , & outImageLayer -> widthInTiles ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> widthInTiles = 0U ; if ( element -> QueryUnsignedAttribute ( " height " , & outImageLayer -> heightInTiles ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> heightInTiles = 0U ; if ( element -> QueryFloatAttribute ( " opacity " , & outImageLayer -> opacity ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> opacity = 1 . f ; if ( element -> QueryBoolAttribute ( " visible " , & outImageLayer -> visible ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> visible = true ; if ( element -> FirstChildElement ( " properties " ) != NULL ) { error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outImageLayer -> propertyMap ) ; if ( error != kSuccess ) { LOGE ( " Error ▁ parsing ▁ image ▁ layer ▁ property ▁ node . . . " ) ; return error ; } } if ( element -> FirstChildElement ( " image " ) != NULL ) { error = _parseImageNode ( element -> FirstChildElement ( " image " ) , & outImageLayer -> image ) ; if ( error != kSuccess ) return error ; } return error ; } } </DOCUMENT>
<DOCUMENT_ID="AdmiralCurtiss/ppsspp/tree/master/unittest/UnitTest.cpp"> # include < cstdio > # include < cstdlib > # include < cmath > # include < string > # include < sstream > # include " base / NativeApp . h " # include " base / logging . h " # include " Common / CPUDetect . h " # include " Common / ArmEmitter . h " # include " ext / disarm . h " # include " math / math _ util . h " # include " util / text / parsers . h " # include " Core / Config . h " # include " Core / MIPS / MIPSVFPUUtils . h " # include " Core / FileSystems / ISOFileSystem . h " # include " unittest / JitHarness . h " # include " unittest / TestVertexJit . h " # include " unittest / UnitTest . h " std :: string System_GetProperty ( SystemProperty prop ) { return " " ; } int System_GetPropertyInt ( SystemProperty prop ) { return - 1 ; } void NativeMessageReceived ( const char * message , const char * value ) { } void GL_SwapInterval ( int ) { } # ifndef M_PI_2 # define M_PI_2 1.57079632679489661923 # endif float fastasin ( double x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; float sqrtthing = sqrt ( 1.0f - x * x ) ; float y = - .3572142480f + .1087063463f * x ; y = y * x + 1.062519236f ; y = y * x + - 2.511278506f ; y = y * x + .191900116f ; y = y * x + 1.807607311f ; y /= ( 1.807607311f - 1.615195094 * x ) ; return sign * ( y - sqrtthing ) ; } double atan_66s ( double x ) { const double c1 = 1.6867629106 ; const double c2 = 0.4378497304 ; const double c3 = 1.6867633134 ; double x2 ; x2 = x * x ; return ( x * ( c1 + x2 * c2 ) / ( c3 + x2 ) ) ; } double fastasin2 ( double x ) { return atan_66s ( x / sqrt ( 1 - x * x ) ) ; } float fastasin3 ( float x ) { return x + x * x * x * x * x * 0.4971 ; } float fastasin4 ( float x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; x = M_PI / 2 - sqrtf ( 1.0f - x ) * ( 1.5707288 + - 0.2121144 * x + 0.0742610 * x * x + - 0.0187293 * x * x * x ) ; return sign * x ; } float fastasin5 ( float x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; float fRoot = sqrtf ( 1.0f - x ) ; float fResult = 0.0742610f + - 0.0187293f * x ; fResult = - 0.2121144f + fResult * x ; fResult = 1.5707288f + fResult * x ; fResult = M_PI / 2 - fRoot * fResult ; return sign * fResult ; } # define C 0.70710678118654752440f # define BITSPERQUARTER ( 20 ) void fcs ( float angle , float & sinout , float & cosout ) { int phasein = angle * ( 1 << BITSPERQUARTER ) ; float modphase = ( phasein & ( ( 1 << BITSPERQUARTER ) - 1 ) ) * ( 1.0f / ( 1 << BITSPERQUARTER ) ) ; int quarter = phasein >> BITSPERQUARTER ; if ( ! quarter ) { float x = modphase - 0.5f ; float temp = ( 2 - 4 * C ) * x * x + C ; sinout = temp + x ; cosout = temp - x ; } else if ( quarter == 1 ) { float x = 0.5f - modphase ; float temp = ( 2 - 4 * C ) * x * x + C ; sinout = x + temp ; cosout = x - temp ; } else if ( quarter == 2 ) { float x = modphase - 0.5f ; float temp = ( 4 * C - 2 ) * x * x - C ; sinout = temp - x ; cosout = temp + x ; } else if ( quarter == 3 ) { float x = modphase - 0.5f ; float temp = ( 2 - 4 * C ) * x * x + C ; sinout = x - temp ; cosout = x + temp ; } } # undef C const float PI_SQR = 9.86960440108935861883449099987615114f ; void fcs2 ( float theta , float & outsine , float & outcosine ) { float gamma = theta + 1 ; gamma += 2 ; gamma /= 4 ; theta += 2 ; theta /= 4 ; theta -= floorf ( theta ) ; gamma -= floorf ( gamma ) ; theta *= 4 ; theta -= 2 ; gamma *= 4 ; gamma -= 2 ; float x = 2 * gamma - gamma * fabs ( gamma ) ; float y = 2 * theta - theta * fabs ( theta ) ; const float P = 0.225 ; outsine = P * ( y * fabsf ( y ) - y ) + y ; outcosine = P * ( x * fabsf ( x ) - x ) + x ; } void fastsincos ( float x , float & sine , float & cosine ) { fcs2 ( x , sine , cosine ) ; } bool TestSinCos ( ) { for ( int i = - 100 ; i <= 100 ; i ++ ) { float f = i / 30.0f ; float slowsin = sinf ( f * M_PI_2 ) , slowcos = cosf ( f * M_PI_2 ) ; float fastsin , fastcos ; fastsincos ( f , fastsin , fastcos ) ; printf ( " % f : ▁ slow : ▁ % 0.8f , ▁ % 0.8f ▁ fast : ▁ % 0.8f , ▁ % 0.8f \n " , f , slowsin , slowcos , fastsin , fastcos ) ; } return true ; } bool TestAsin ( ) { for ( int i = - 100 ; i <= 100 ; i ++ ) { float f = i / 100.0f ; float slowval = asinf ( f ) / M_PI_2 ; float fastval = fastasin5 ( f ) / M_PI_2 ; printf ( " slow : ▁ % 0.16f ▁ fast : ▁ % 0.16f \n " , slowval , fastval ) ; float diff = fabsf ( slowval - fastval ) ; } return true ; } bool TestMathUtil ( ) { EXPECT_FALSE ( my_isinf ( 1.0 ) ) ; volatile float zero = 0.0f ; EXPECT_TRUE ( my_isinf ( 1.0f / zero ) ) ; EXPECT_FALSE ( my_isnan ( 1.0f / zero ) ) ; return true ; } bool TestParsers ( ) { const char * macstr = "01:02:03 : ff : fe : fd " ; uint8_t mac [ 6 ] ; ParseMacAddress ( macstr , mac ) ; EXPECT_TRUE ( mac [ 0 ] == 1 ) ; EXPECT_TRUE ( mac [ 1 ] == 2 ) ; EXPECT_TRUE ( mac [ 2 ] == 3 ) ; EXPECT_TRUE ( mac [ 3 ] == 255 ) ; EXPECT_TRUE ( mac [ 4 ] == 254 ) ; EXPECT_TRUE ( mac [ 5 ] == 253 ) ; return true ; } bool TestVFPUSinCos ( ) { float sine , cosine ; vfpu_sincos ( 0.0f , sine , cosine ) ; EXPECT_EQ_FLOAT ( sine , 0.0f ) ; EXPECT_EQ_FLOAT ( cosine , 1.0f ) ; vfpu_sincos ( 1.0f , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , 1.0f ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , 0.0f ) ; vfpu_sincos ( 2.0f , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , 0.0f ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , - 1.0f ) ; vfpu_sincos ( 3.0f , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , - 1.0f ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , 0.0f ) ; vfpu_sincos ( 4.0f , sine , cosine ) ; EXPECT_EQ_FLOAT ( sine , 0.0f ) ; EXPECT_EQ_FLOAT ( cosine , 1.0f ) ; vfpu_sincos ( 5.0f , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , 1.0f ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , 0.0f ) ; for ( float angle = - 10.0f ; angle < 10.0f ; angle ++ ) { vfpu_sincos ( angle , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , sinf ( angle * M_PI_2 ) ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , cosf ( angle * M_PI_2 ) ) ; } return true ; } bool TestMatrixTranspose ( ) { MatrixSize sz = M_4x4 ; int matrix = 0 ; u8 cols [ 4 ] ; u8 rows [ 4 ] ; GetMatrixColumns ( matrix , sz , cols ) ; GetMatrixRows ( matrix , sz , rows ) ; int transposed = Xpose ( matrix ) ; u8 x_cols [ 4 ] ; u8 x_rows [ 4 ] ; GetMatrixColumns ( transposed , sz , x_cols ) ; GetMatrixRows ( transposed , sz , x_rows ) ; for ( int i = 0 ; i < GetMatrixSide ( sz ) ; i ++ ) { EXPECT_EQ_INT ( cols [ i ] , x_rows [ i ] ) ; EXPECT_EQ_INT ( x_cols [ i ] , rows [ i ] ) ; } return true ; } void TestGetMatrix ( int matrix , MatrixSize sz ) { ILOG ( " Testing ▁ matrix ▁ % s " , GetMatrixNotation ( matrix , sz ) ) ; u8 fullMatrix [ 16 ] ; u8 cols [ 4 ] ; u8 rows [ 4 ] ; GetMatrixColumns ( matrix , sz , cols ) ; GetMatrixRows ( matrix , sz , rows ) ; GetMatrixRegs ( fullMatrix , sz , matrix ) ; int n = GetMatrixSide ( sz ) ; VectorSize vsz = GetVectorSize ( sz ) ; for ( int i = 0 ; i < n ; i ++ ) { int colName = cols [ i ] ; int rowName = rows [ i ] ; ILOG ( " Column ▁ % i : ▁ % s " , i , GetVectorNotation ( colName , vsz ) ) ; ILOG ( " Row ▁ % i : ▁ % s " , i , GetVectorNotation ( rowName , vsz ) ) ; u8 colRegs [ 4 ] ; u8 rowRegs [ 4 ] ; GetVectorRegs ( colRegs , vsz , colName ) ; GetVectorRegs ( rowRegs , vsz , rowName ) ; std :: stringstream a , b , c , d ; for ( int j = 0 ; j < n ; j ++ ) { a . clear ( ) ; b . clear ( ) ; a << ( int ) fullMatrix [ i * 4 + j ] << " ▁ " ; b << ( int ) colRegs [ j ] << " ▁ " ; c . clear ( ) ; d . clear ( ) ; c << ( int ) fullMatrix [ j * 4 + i ] << " ▁ " ; d << ( int ) rowRegs [ j ] << " ▁ " ; } ILOG ( " Col : ▁ % s ▁ vs ▁ % s " , a . str ( ) . c_str ( ) , b . str ( ) . c_str ( ) ) ; if ( a . str ( ) != b . str ( ) ) ILOG ( " WRONG ! " ) ; ILOG ( " Row : ▁ % s ▁ vs ▁ % s " , c . str ( ) . c_str ( ) , d . str ( ) . c_str ( ) ) ; if ( c . str ( ) != d . str ( ) ) ILOG ( " WRONG ! " ) ; } } bool TestParseLBN ( ) { const char * validStrings [ ] = { " / sce _ lbn0x5fa0 _ size0x1428" , " / sce _ lbn7050 _ sizeee850" , " / sce _ lbn0x5eeeh _ size0x234x " , " / sce _ lbneee _ _ size434 . " , } ; int expectedResults [ ] [ 2 ] = { { 0x5fa0 , 0x1428 } , { 0x7050 , 0xee850 } , { 0x5eee , 0x234 } , { 0xeee , 0x434 } , } ; const char * invalidStrings [ ] = { " / sce _ lbn0x5fa0 _ sze0x1428" , " " , " // " , } ; for ( int i = 0 ; i < ARRAY_SIZE ( validStrings ) ; i ++ ) { u32 startSector = 0 , readSize = 0 ; EXPECT_TRUE ( parseLBN ( validStrings [ i ] , & startSector , & readSize ) ) ; EXPECT_EQ_INT ( startSector , expectedResults [ i ] [ 0 ] ) ; EXPECT_EQ_INT ( readSize , expectedResults [ i ] [ 1 ] ) ; } for ( int i = 0 ; i < ARRAY_SIZE ( invalidStrings ) ; i ++ ) { u32 startSector , readSize ; EXPECT_FALSE ( parseLBN ( invalidStrings [ i ] , & startSector , & readSize ) ) ; } return true ; } typedef bool ( * TestFunc ) ( ) ; struct TestItem { const char * name ; TestFunc func ; } ; # define TEST_ITEM ( name ) { # name , & Test ## name , } bool TestArmEmitter ( ) ; bool TestArm64Emitter ( ) ; bool TestX64Emitter ( ) ; TestItem availableTests [ ] = { # if defined ( ARM64 ) || defined ( _M_X64 ) || defined ( _M_IX86 ) TEST_ITEM ( Arm64Emitter ) , # endif # if defined ( ARM ) || defined ( _M_X64 ) || defined ( _M_IX86 ) TEST_ITEM ( ArmEmitter ) , # endif # if defined ( _M_X64 ) || defined ( _M_IX86 ) TEST_ITEM ( X64Emitter ) , # endif TEST_ITEM ( VertexJit ) , TEST_ITEM ( Asin ) , TEST_ITEM ( SinCos ) , TEST_ITEM ( VFPUSinCos ) , TEST_ITEM ( MathUtil ) , TEST_ITEM ( Parsers ) , TEST_ITEM ( Jit ) , TEST_ITEM ( MatrixTranspose ) , TEST_ITEM ( ParseLBN ) , } ; int main ( int argc , const char * argv [ ] ) { cpu_info . bNEON = true ; cpu_info . bVFP = true ; cpu_info . bVFPv3 = true ; cpu_info . bVFPv4 = true ; g_Config . bEnableLogging = true ; bool allTests = false ; TestFunc testFunc = nullptr ; if ( argc >= 2 ) { if ( ! strcasecmp ( argv [ 1 ] , " all " ) ) { allTests = true ; } for ( auto f : availableTests ) { if ( ! strcasecmp ( argv [ 1 ] , f . name ) ) { testFunc = f . func ; break ; } } } if ( allTests ) { int passes = 0 ; int fails = 0 ; for ( auto f : availableTests ) { if ( f . func ( ) ) { ++ passes ; } else { printf ( " % s : ▁ FAILED \n " , f . name ) ; ++ fails ; } } if ( passes > 0 ) { printf ( " % d ▁ tests ▁ passed . \n " , passes ) ; } if ( fails > 0 ) { return 2 ; } } else if ( testFunc == nullptr ) { fprintf ( stderr , " You ▁ may ▁ select ▁ a ▁ test ▁ to ▁ run ▁ by ▁ passing ▁ an ▁ argument . \n " ) ; fprintf ( stderr , " \n " ) ; fprintf ( stderr , " Available ▁ tests : \n " ) ; for ( auto f : availableTests ) { fprintf ( stderr , " ▁ ▁ * ▁ % s \n " , f . name ) ; } return 1 ; } else { if ( ! testFunc ( ) ) { return 2 ; } } return 0 ; } </DOCUMENT>
<DOCUMENT_ID="PGer/incubator-hawq/tree/master/src/backend/access/parquet/metadatautil_c++/Metadatainterface.cpp"> # include < iostream > # include < stdint . h > # include < boost / shared_ptr . hpp > # include < boost / math_fwd . hpp > # include < thrift / protocol / TBinaryProtocol . h > # include < fcntl . h > # include < fstream > # include < stdio . h > # include < bitset > # include " MetadataUtil . h " using namespace hawq ; using namespace std ; using namespace boost ; extern " C " { # include " postgres . h " # include " utils / palloc . h " int readPageMetadata ( uint8_t * buf , uint32_t * len , int compact , struct PageMetadata_4C * * ppageMetdata ) { * ppageMetdata = ( struct PageMetadata_4C * ) palloc0 ( sizeof ( struct PageMetadata_4C ) ) ; bool compactBool = ( compact == 1 ) ? true : false ; int iret = MetadataUtil :: readPageMetadata ( buf , len , compactBool , * ppageMetdata ) ; return iret ; } int writePageMetadata ( uint8_t * * buf , uint32_t * len , struct PageMetadata_4C * ppageMetadata ) { int iret = MetadataUtil :: writePageMetadata ( buf , len , ppageMetadata ) ; return iret ; } int writeColumnChunkMetadata ( uint8_t * * buf , uint32_t * len , struct ColumnChunkMetadata_4C * blockMetadata ) { int iret = MetadataUtil :: writeColumnChunkMetadata ( buf , len , blockMetadata ) ; return iret ; } } </DOCUMENT>
<DOCUMENT_ID="cndpost/cppidioms/tree/master/bft/bft.cpp"> # include < iostream > # include < vector > # include < queue > using namespace std ; class Tree ; class Tree { public : char data ; bool visited ; std :: vector < Tree * > children ; } ; void bft ( Tree * root ) { if ( root == NULL ) return ; if ( root -> visited ) return ; root -> visited = true ; printf ( " % c ▁ \n " , root -> data ) ; std :: queue < Tree * > * newQue = new std :: queue < Tree * > ( ) ; int Size = root -> children . size ( ) ; for ( int i = 0 ; i < Size ; i ++ ) { Tree * child = root -> children [ i ] ; if ( child != NULL ) newQue -> push ( child ) ; } for ( int i = 0 ; i < Size ; i ++ ) { Tree * child = newQue -> front ( ) ; if ( child != NULL ) bft ( child ) ; newQue -> pop ( ) ; } return ; } ; void insert ( Tree * root , char data ) { Tree * newTree = new Tree ( ) ; newTree -> data = data ; newTree -> visited = false ; root -> children . push_back ( newTree ) ; return ; } ; int main ( ) { Tree * root = new Tree ( ) ; root -> data = ' a ' ; Tree * leftChild = new Tree { } ; leftChild -> data = ' b ' ; Tree * rightChild = new Tree ( ) ; rightChild -> data = ' c ' ; root -> children . push_back ( leftChild ) ; root -> children . push_back ( rightChild ) ; cout << " start ▁ doing ▁ BFT ▁ in ▁ one ▁ way ▁ " << endl ; bft ( root ) ; delete root ; root = new Tree ( ) ; root -> data = ' a ' ; insert ( root , ' d ' ) ; insert ( root , ' e ' ) ; cout << " start ▁ doing ▁ BFT ▁ in ▁ 2nd ▁ way " << endl ; bft ( root ) ; cout << " done ▁ DFT ▁ " << endl ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="shliujing/TeamTalk/tree/master/server/src/db_proxy_server/business/UserAction.cpp"> # include < list > # include < map > # include " . . / ProxyConn . h " # include " . . / DBPool . h " # include " . . / SyncCenter . h " # include " public _ define . h " # include " UserModel . h " # include " IM . Login . pb . h " # include " IM . Buddy . pb . h " # include " IM . BaseDefine . pb . h " namespace DB_PROXY { void getUserInfo ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMUsersInfoReq msg ; IM :: Buddy :: IMUsersInfoRsp msgResp ; if ( msg . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { CImPdu * pPduRes = new CImPdu ; uint32_t from_user_id = msg . user_id ( ) ; uint32_t userCount = msg . user_id_list_size ( ) ; std :: list < uint32_t > idList ; for ( uint32_t i = 0 ; i < userCount ; ++ i ) { idList . push_back ( msg . user_id_list ( i ) ) ; } std :: list < IM :: BaseDefine :: UserInfo > lsUser ; CUserModel :: getInstance ( ) -> getUsers ( idList , lsUser ) ; msgResp . set_user_id ( from_user_id ) ; for ( list < IM :: BaseDefine :: UserInfo > :: iterator it = lsUser . begin ( ) ; it != lsUser . end ( ) ; ++ it ) { IM :: BaseDefine :: UserInfo * pUser = msgResp . add_user_info_list ( ) ; pUser -> set_user_id ( it -> user_id ( ) ) ; pUser -> set_user_gender ( it -> user_gender ( ) ) ; pUser -> set_user_nick_name ( it -> user_nick_name ( ) ) ; pUser -> set_avatar_url ( it -> avatar_url ( ) ) ; pUser -> set_sign_info ( it -> sign_info ( ) ) ; pUser -> set_department_id ( it -> department_id ( ) ) ; pUser -> set_email ( it -> email ( ) ) ; pUser -> set_user_real_name ( it -> user_real_name ( ) ) ; pUser -> set_user_tel ( it -> user_tel ( ) ) ; pUser -> set_user_domain ( it -> user_domain ( ) ) ; pUser -> set_status ( it -> status ( ) ) ; } log ( " userId = % u , ▁ userCnt = % u " , from_user_id , userCount ) ; msgResp . set_attach_data ( msg . attach_data ( ) ) ; pPduRes -> SetPBMsg ( & msgResp ) ; pPduRes -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pPduRes -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pPduRes -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_USER_INFO_RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pPduRes ) ; } else { log ( " parse ▁ pb ▁ failed " ) ; } } void getChangedUser ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMAllUserReq msg ; IM :: Buddy :: IMAllUserRsp msgResp ; if ( msg . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { CImPdu * pPduRes = new CImPdu ; uint32_t nReqId = msg . user_id ( ) ; uint32_t nLastTime = msg . latest_update_time ( ) ; uint32_t nLastUpdate = CSyncCenter :: getInstance ( ) -> getLastUpdate ( ) ; list < IM :: BaseDefine :: UserInfo > lsUsers ; if ( nLastUpdate > nLastTime ) { list < uint32_t > lsIds ; CUserModel :: getInstance ( ) -> getChangedId ( nLastTime , lsIds ) ; CUserModel :: getInstance ( ) -> getUsers ( lsIds , lsUsers ) ; } msgResp . set_user_id ( nReqId ) ; msgResp . set_latest_update_time ( nLastTime ) ; for ( list < IM :: BaseDefine :: UserInfo > :: iterator it = lsUsers . begin ( ) ; it != lsUsers . end ( ) ; ++ it ) { IM :: BaseDefine :: UserInfo * pUser = msgResp . add_user_list ( ) ; pUser -> set_user_id ( it -> user_id ( ) ) ; pUser -> set_user_gender ( it -> user_gender ( ) ) ; pUser -> set_user_nick_name ( it -> user_nick_name ( ) ) ; pUser -> set_avatar_url ( it -> avatar_url ( ) ) ; pUser -> set_sign_info ( it -> sign_info ( ) ) ; pUser -> set_department_id ( it -> department_id ( ) ) ; pUser -> set_email ( it -> email ( ) ) ; pUser -> set_user_real_name ( it -> user_real_name ( ) ) ; pUser -> set_user_tel ( it -> user_tel ( ) ) ; pUser -> set_user_domain ( it -> user_domain ( ) ) ; pUser -> set_status ( it -> status ( ) ) ; } log ( " userId = % u , nLastUpdate = % u , ▁ last _ time = % u , ▁ userCnt = % u " , nReqId , nLastUpdate , nLastTime , msgResp . user_list_size ( ) ) ; msgResp . set_attach_data ( msg . attach_data ( ) ) ; pPduRes -> SetPBMsg ( & msgResp ) ; pPduRes -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pPduRes -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pPduRes -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_ALL_USER_RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pPduRes ) ; } else { log ( " parse ▁ pb ▁ failed " ) ; } } void changeUserSignInfo ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMChangeSignInfoReq req ; IM :: Buddy :: IMChangeSignInfoRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; const string & sign_info = req . sign_info ( ) ; bool result = CUserModel :: getInstance ( ) -> updateUserSignInfo ( user_id , sign_info ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_sign_info ( sign_info ) ; log ( " changeUserSignInfo ▁ sucess , ▁ user _ id = % u , ▁ sign _ info = % s " , user_id , sign_info . c_str ( ) ) ; } else { log ( " changeUserSignInfo ▁ false , ▁ user _ id = % u , ▁ sign _ info = % s " , user_id , sign_info . c_str ( ) ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " changeUserSignInfo : ▁ IMChangeSignInfoReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } } void doPushShield ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Login :: IMPushShieldReq req ; IM :: Login :: IMPushShieldRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; uint32_t shield_status = req . shield_status ( ) ; bool result = CUserModel :: getInstance ( ) -> updatePushShield ( user_id , shield_status ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_shield_status ( shield_status ) ; log ( " doPushShield ▁ sucess , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } else { log ( " doPushShield ▁ false , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_LOGIN ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_LOGIN_RES_PUSH_SHIELD ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " doPushShield : ▁ IMPushShieldReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } } void doQueryPushShield ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Login :: IMQueryPushShieldReq req ; IM :: Login :: IMQueryPushShieldRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; uint32_t shield_status = 0 ; bool result = CUserModel :: getInstance ( ) -> getPushShield ( user_id , & shield_status ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_shield_status ( shield_status ) ; log ( " doQueryPushShield ▁ sucess , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } else { log ( " doQueryPushShield ▁ false , ▁ user _ id = % u " , user_id ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_LOGIN ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_LOGIN_RES_QUERY_PUSH_SHIELD ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " doQueryPushShield : ▁ IMQueryPushShieldReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } } } ; </DOCUMENT>
<DOCUMENT_ID="jmanday/Master/tree/master/TFM/library/boost_1_63_0/libs/icl/test/fastest_split_interval_set_/fastest_split_interval_set.cpp"> # define BOOST_TEST_MODULE icl :: split_interval_set unit test # include < libs / icl / test / disable_test_warnings . hpp > # include < string > # include < boost / mpl / list . hpp > # include " . . / unit _ test _ unwarned . hpp " # include " . . / test _ type _ lists . hpp " # include " . . / test _ value _ maker . hpp " # include < boost / icl / split_interval_set . hpp > using namespace std ; using namespace boost ; using namespace unit_test ; using namespace boost :: icl ; # include " . . / test _ interval _ set _ shared . hpp " # define INTERVAL_SET split_interval_set # include " . . / fastest _ interval _ set _ cases . hpp " </DOCUMENT>
<DOCUMENT_ID="wiltonlazary/arangodb/tree/master/3rdParty/boost/1.61.0/libs/math/test/compile_test/sf_hypot_incl_test.cpp"> # include < boost / math / special_functions / hypot . hpp > # include " test _ compile _ result . hpp " void compile_and_link_test ( ) { check_result < float > ( boost :: math :: hypot < float > ( f , f ) ) ; check_result < double > ( boost :: math :: hypot < double > ( d , d ) ) ; # ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS check_result < long double > ( boost :: math :: hypot < long double > ( l , l ) ) ; # endif } </DOCUMENT>
<DOCUMENT_ID="goldcoin/gldcoin/tree/master/BuildDeps/deps/boost/libs/polygon/example/voronoi_visualizer.cpp"> # include < iostream > # include < vector > # include < QtOpenGL / QGLWidget > # include < QtGui / QtGui > # include < boost / polygon / polygon . hpp > # include < boost / polygon / voronoi . hpp > using namespace boost :: polygon ; # include " voronoi _ visual _ utils . hpp " class GLWidget : public QGLWidget { Q_OBJECT public : explicit GLWidget ( QMainWindow * parent = NULL ) : QGLWidget ( QGLFormat ( QGL :: SampleBuffers ) , parent ) , primary_edges_only_ ( false ) , internal_edges_only_ ( false ) { startTimer ( 40 ) ; } QSize sizeHint ( ) const { return QSize ( 600 , 600 ) ; } void build ( const QString & file_path ) { clear ( ) ; read_data ( file_path ) ; if ( ! brect_initialized_ ) { return ; } construct_brect ( ) ; construct_voronoi ( point_data_ . begin ( ) , point_data_ . end ( ) , segment_data_ . begin ( ) , segment_data_ . end ( ) , & vd_ ) ; for ( const_edge_iterator it = vd_ . edges ( ) . begin ( ) ; it != vd_ . edges ( ) . end ( ) ; ++ it ) { if ( ! it -> is_finite ( ) ) { color_exterior ( & ( * it ) ) ; } } update_view_port ( ) ; } void show_primary_edges_only ( ) { primary_edges_only_ ^= true ; } void show_internal_edges_only ( ) { internal_edges_only_ ^= true ; } protected : void initializeGL ( ) { glHint ( GL_POINT_SMOOTH_HINT , GL_NICEST ) ; glBlendFunc ( GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA ) ; glEnable ( GL_BLEND ) ; glEnable ( GL_POINT_SMOOTH ) ; } void paintGL ( ) { qglClearColor ( QColor :: fromRgb ( 255 , 255 , 255 ) ) ; glClear ( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT ) ; draw_points ( ) ; draw_segments ( ) ; draw_vertices ( ) ; draw_edges ( ) ; } void resizeGL ( int width , int height ) { int side = qMin ( width , height ) ; glViewport ( ( width - side ) / 2 , ( height - side ) / 2 , side , side ) ; } void timerEvent ( QTimerEvent * e ) { update ( ) ; } private : typedef double coordinate_type ; typedef point_data < coordinate_type > point_type ; typedef segment_data < coordinate_type > segment_type ; typedef rectangle_data < coordinate_type > rect_type ; typedef voronoi_builder < int > VB ; typedef voronoi_diagram < coordinate_type > VD ; typedef VD :: cell_type cell_type ; typedef VD :: cell_type :: source_index_type source_index_type ; typedef VD :: cell_type :: source_category_type source_category_type ; typedef VD :: edge_type edge_type ; typedef VD :: cell_container_type cell_container_type ; typedef VD :: cell_container_type vertex_container_type ; typedef VD :: edge_container_type edge_container_type ; typedef VD :: const_cell_iterator const_cell_iterator ; typedef VD :: const_vertex_iterator const_vertex_iterator ; typedef VD :: const_edge_iterator const_edge_iterator ; static const std :: size_t EXTERNAL_COLOR = 1 ; void clear ( ) { brect_initialized_ = false ; point_data_ . clear ( ) ; segment_data_ . clear ( ) ; vd_ . clear ( ) ; } void read_data ( const QString & file_path ) { QFile data ( file_path ) ; if ( ! data . open ( QFile :: ReadOnly ) ) { QMessageBox :: warning ( this , tr ( " Voronoi ▁ Visualizer " ) , tr ( " Disable ▁ to ▁ open ▁ file ▁ " ) + file_path ) ; } QTextStream in_stream ( & data ) ; std :: size_t num_points , num_segments ; int x1 , y1 , x2 , y2 ; in_stream >> num_points ; for ( std :: size_t i = 0 ; i < num_points ; ++ i ) { in_stream >> x1 >> y1 ; point_type p ( x1 , y1 ) ; update_brect ( p ) ; point_data_ . push_back ( p ) ; } in_stream >> num_segments ; for ( std :: size_t i = 0 ; i < num_segments ; ++ i ) { in_stream >> x1 >> y1 >> x2 >> y2 ; point_type lp ( x1 , y1 ) ; point_type hp ( x2 , y2 ) ; update_brect ( lp ) ; update_brect ( hp ) ; segment_data_ . push_back ( segment_type ( lp , hp ) ) ; } in_stream . flush ( ) ; } void update_brect ( const point_type & point ) { if ( brect_initialized_ ) { encompass ( brect_ , point ) ; } else { set_points ( brect_ , point , point ) ; brect_initialized_ = true ; } } void construct_brect ( ) { double side = ( std :: max ) ( xh ( brect_ ) - xl ( brect_ ) , yh ( brect_ ) - yl ( brect_ ) ) ; center ( shift_ , brect_ ) ; set_points ( brect_ , shift_ , shift_ ) ; bloat ( brect_ , side * 1.2 ) ; } void color_exterior ( const VD :: edge_type * edge ) { if ( edge -> color ( ) == EXTERNAL_COLOR ) { return ; } edge -> color ( EXTERNAL_COLOR ) ; edge -> twin ( ) -> color ( EXTERNAL_COLOR ) ; const VD :: vertex_type * v = edge -> vertex1 ( ) ; if ( v == NULL || ! edge -> is_primary ( ) ) { return ; } v -> color ( EXTERNAL_COLOR ) ; const VD :: edge_type * e = v -> incident_edge ( ) ; do { color_exterior ( e ) ; e = e -> rot_next ( ) ; } while ( e != v -> incident_edge ( ) ) ; } void update_view_port ( ) { glMatrixMode ( GL_PROJECTION ) ; glLoadIdentity ( ) ; rect_type view_rect = brect_ ; deconvolve ( view_rect , shift_ ) ; glOrtho ( xl ( view_rect ) , xh ( view_rect ) , yl ( view_rect ) , yh ( view_rect ) , - 1.0 , 1.0 ) ; glMatrixMode ( GL_MODELVIEW ) ; } void draw_points ( ) { glColor3f ( 0.0f , 0.5f , 1.0f ) ; glPointSize ( 9 ) ; glBegin ( GL_POINTS ) ; for ( std :: size_t i = 0 ; i < point_data_ . size ( ) ; ++ i ) { point_type point = point_data_ [ i ] ; deconvolve ( point , shift_ ) ; glVertex2f ( point . x ( ) , point . y ( ) ) ; } for ( std :: size_t i = 0 ; i < segment_data_ . size ( ) ; ++ i ) { point_type lp = low ( segment_data_ [ i ] ) ; lp = deconvolve ( lp , shift_ ) ; glVertex2f ( lp . x ( ) , lp . y ( ) ) ; point_type hp = high ( segment_data_ [ i ] ) ; hp = deconvolve ( hp , shift_ ) ; glVertex2f ( hp . x ( ) , hp . y ( ) ) ; } glEnd ( ) ; } void draw_segments ( ) { glColor3f ( 0.0f , 0.5f , 1.0f ) ; glLineWidth ( 2.7f ) ; glBegin ( GL_LINES ) ; for ( std :: size_t i = 0 ; i < segment_data_ . size ( ) ; ++ i ) { point_type lp = low ( segment_data_ [ i ] ) ; lp = deconvolve ( lp , shift_ ) ; glVertex2f ( lp . x ( ) , lp . y ( ) ) ; point_type hp = high ( segment_data_ [ i ] ) ; hp = deconvolve ( hp , shift_ ) ; glVertex2f ( hp . x ( ) , hp . y ( ) ) ; } glEnd ( ) ; } void draw_vertices ( ) { glColor3f ( 0.0f , 0.0f , 0.0f ) ; glPointSize ( 6 ) ; glBegin ( GL_POINTS ) ; for ( const_vertex_iterator it = vd_ . vertices ( ) . begin ( ) ; it != vd_ . vertices ( ) . end ( ) ; ++ it ) { if ( internal_edges_only_ && ( it -> color ( ) == EXTERNAL_COLOR ) ) { continue ; } point_type vertex ( it -> x ( ) , it -> y ( ) ) ; vertex = deconvolve ( vertex , shift_ ) ; glVertex2f ( vertex . x ( ) , vertex . y ( ) ) ; } glEnd ( ) ; } void draw_edges ( ) { glColor3f ( 0.0f , 0.0f , 0.0f ) ; glLineWidth ( 1.7f ) ; for ( const_edge_iterator it = vd_ . edges ( ) . begin ( ) ; it != vd_ . edges ( ) . end ( ) ; ++ it ) { if ( primary_edges_only_ && ! it -> is_primary ( ) ) { continue ; } if ( internal_edges_only_ && ( it -> color ( ) == EXTERNAL_COLOR ) ) { continue ; } std :: vector < point_type > samples ; if ( ! it -> is_finite ( ) ) { clip_infinite_edge ( * it , & samples ) ; } else { point_type vertex0 ( it -> vertex0 ( ) -> x ( ) , it -> vertex0 ( ) -> y ( ) ) ; samples . push_back ( vertex0 ) ; point_type vertex1 ( it -> vertex1 ( ) -> x ( ) , it -> vertex1 ( ) -> y ( ) ) ; samples . push_back ( vertex1 ) ; if ( it -> is_curved ( ) ) { sample_curved_edge ( * it , & samples ) ; } } glBegin ( GL_LINE_STRIP ) ; for ( std :: size_t i = 0 ; i < samples . size ( ) ; ++ i ) { point_type vertex = deconvolve ( samples [ i ] , shift_ ) ; glVertex2f ( vertex . x ( ) , vertex . y ( ) ) ; } glEnd ( ) ; } } void clip_infinite_edge ( const edge_type & edge , std :: vector < point_type > * clipped_edge ) { const cell_type & cell1 = * edge . cell ( ) ; const cell_type & cell2 = * edge . twin ( ) -> cell ( ) ; point_type origin , direction ; if ( cell1 . contains_point ( ) && cell2 . contains_point ( ) ) { point_type p1 = retrieve_point ( cell1 ) ; point_type p2 = retrieve_point ( cell2 ) ; origin . x ( ( p1 . x ( ) + p2 . x ( ) ) * 0.5 ) ; origin . y ( ( p1 . y ( ) + p2 . y ( ) ) * 0.5 ) ; direction . x ( p1 . y ( ) - p2 . y ( ) ) ; direction . y ( p2 . x ( ) - p1 . x ( ) ) ; } else { origin = cell1 . contains_segment ( ) ? retrieve_point ( cell2 ) : retrieve_point ( cell1 ) ; segment_type segment = cell1 . contains_segment ( ) ? retrieve_segment ( cell1 ) : retrieve_segment ( cell2 ) ; coordinate_type dx = high ( segment ) . x ( ) - low ( segment ) . x ( ) ; coordinate_type dy = high ( segment ) . y ( ) - low ( segment ) . y ( ) ; if ( ( low ( segment ) == origin ) ^ cell1 . contains_point ( ) ) { direction . x ( dy ) ; direction . y ( - dx ) ; } else { direction . x ( - dy ) ; direction . y ( dx ) ; } } coordinate_type side = xh ( brect_ ) - xl ( brect_ ) ; coordinate_type koef = side / ( std :: max ) ( fabs ( direction . x ( ) ) , fabs ( direction . y ( ) ) ) ; if ( edge . vertex0 ( ) == NULL ) { clipped_edge -> push_back ( point_type ( origin . x ( ) - direction . x ( ) * koef , origin . y ( ) - direction . y ( ) * koef ) ) ; } else { clipped_edge -> push_back ( point_type ( edge . vertex0 ( ) -> x ( ) , edge . vertex0 ( ) -> y ( ) ) ) ; } if ( edge . vertex1 ( ) == NULL ) { clipped_edge -> push_back ( point_type ( origin . x ( ) + direction . x ( ) * koef , origin . y ( ) + direction . y ( ) * koef ) ) ; } else { clipped_edge -> push_back ( point_type ( edge . vertex1 ( ) -> x ( ) , edge . vertex1 ( ) -> y ( ) ) ) ; } } void sample_curved_edge ( const edge_type & edge , std :: vector < point_type > * sampled_edge ) { coordinate_type max_dist = 1E - 3 * ( xh ( brect_ ) - xl ( brect_ ) ) ; point_type point = edge . cell ( ) -> contains_point ( ) ? retrieve_point ( * edge . cell ( ) ) : retrieve_point ( * edge . twin ( ) -> cell ( ) ) ; segment_type segment = edge . cell ( ) -> contains_point ( ) ? retrieve_segment ( * edge . twin ( ) -> cell ( ) ) : retrieve_segment ( * edge . cell ( ) ) ; voronoi_visual_utils < coordinate_type > :: discretize ( point , segment , max_dist , sampled_edge ) ; } point_type retrieve_point ( const cell_type & cell ) { source_index_type index = cell . source_index ( ) ; source_category_type category = cell . source_category ( ) ; if ( category == SOURCE_CATEGORY_SINGLE_POINT ) { return point_data_ [ index ] ; } index -= point_data_ . size ( ) ; if ( category == SOURCE_CATEGORY_SEGMENT_START_POINT ) { return low ( segment_data_ [ index ] ) ; } else { return high ( segment_data_ [ index ] ) ; } } segment_type retrieve_segment ( const cell_type & cell ) { source_index_type index = cell . source_index ( ) - point_data_ . size ( ) ; return segment_data_ [ index ] ; } point_type shift_ ; std :: vector < point_type > point_data_ ; std :: vector < segment_type > segment_data_ ; rect_type brect_ ; VB vb_ ; VD vd_ ; bool brect_initialized_ ; bool primary_edges_only_ ; bool internal_edges_only_ ; } ; class MainWindow : public QWidget { Q_OBJECT public : MainWindow ( ) { glWidget_ = new GLWidget ( ) ; file_dir_ = QDir ( QDir :: currentPath ( ) , tr ( " * . txt " ) ) ; file_name_ = tr ( " " ) ; QHBoxLayout * centralLayout = new QHBoxLayout ; centralLayout -> addWidget ( glWidget_ ) ; centralLayout -> addLayout ( create_file_layout ( ) ) ; setLayout ( centralLayout ) ; update_file_list ( ) ; setWindowTitle ( tr ( " Voronoi ▁ Visualizer " ) ) ; layout ( ) -> setSizeConstraint ( QLayout :: SetFixedSize ) ; } private slots : void primary_edges_only ( ) { glWidget_ -> show_primary_edges_only ( ) ; } void internal_edges_only ( ) { glWidget_ -> show_internal_edges_only ( ) ; } void browse ( ) { QString new_path = QFileDialog :: getExistingDirectory ( 0 , tr ( " Choose ▁ Directory " ) , file_dir_ . absolutePath ( ) ) ; if ( new_path . isEmpty ( ) ) { return ; } file_dir_ . setPath ( new_path ) ; update_file_list ( ) ; } void build ( ) { file_name_ = file_list_ -> currentItem ( ) -> text ( ) ; QString file_path = file_dir_ . filePath ( file_name_ ) ; message_label_ -> setText ( " Building . . . " ) ; glWidget_ -> build ( file_path ) ; message_label_ -> setText ( " Double ▁ click ▁ the ▁ item ▁ to ▁ build ▁ voronoi ▁ diagram : " ) ; setWindowTitle ( tr ( " Voronoi ▁ Visualizer ▁ - ▁ " ) + file_path ) ; } void print_scr ( ) { if ( ! file_name_ . isEmpty ( ) ) { QImage screenshot = glWidget_ -> grabFrameBuffer ( true ) ; QString output_file = file_dir_ . absolutePath ( ) + tr ( " / " ) + file_name_ . left ( file_name_ . indexOf ( ' . ' ) ) + tr ( " . png " ) ; screenshot . save ( output_file , 0 , - 1 ) ; } } private : QGridLayout * create_file_layout ( ) { QGridLayout * file_layout = new QGridLayout ; message_label_ = new QLabel ( " Double ▁ click ▁ item ▁ to ▁ build ▁ voronoi ▁ diagram : " ) ; file_list_ = new QListWidget ( ) ; file_list_ -> connect ( file_list_ , SIGNAL ( itemDoubleClicked ( QListWidgetItem * ) ) , this , SLOT ( build ( ) ) ) ; QCheckBox * primary_checkbox = new QCheckBox ( " Show ▁ primary ▁ edges ▁ only . " ) ; connect ( primary_checkbox , SIGNAL ( clicked ( ) ) , this , SLOT ( primary_edges_only ( ) ) ) ; QCheckBox * internal_checkbox = new QCheckBox ( " Show ▁ internal ▁ edges ▁ only . " ) ; connect ( internal_checkbox , SIGNAL ( clicked ( ) ) , this , SLOT ( internal_edges_only ( ) ) ) ; QPushButton * browse_button = new QPushButton ( tr ( " Browse ▁ Input ▁ Directory " ) ) ; connect ( browse_button , SIGNAL ( clicked ( ) ) , this , SLOT ( browse ( ) ) ) ; browse_button -> setMinimumHeight ( 50 ) ; QPushButton * print_scr_button = new QPushButton ( tr ( " Make ▁ Screenshot " ) ) ; connect ( print_scr_button , SIGNAL ( clicked ( ) ) , this , SLOT ( print_scr ( ) ) ) ; print_scr_button -> setMinimumHeight ( 50 ) ; file_layout -> addWidget ( message_label_ , 0 , 0 ) ; file_layout -> addWidget ( file_list_ , 1 , 0 ) ; file_layout -> addWidget ( primary_checkbox , 2 , 0 ) ; file_layout -> addWidget ( internal_checkbox , 3 , 0 ) ; file_layout -> addWidget ( browse_button , 4 , 0 ) ; file_layout -> addWidget ( print_scr_button , 5 , 0 ) ; return file_layout ; } void update_file_list ( ) { QFileInfoList list = file_dir_ . entryInfoList ( ) ; file_list_ -> clear ( ) ; if ( file_dir_ . count ( ) == 0 ) { return ; } QFileInfoList :: const_iterator it ; for ( it = list . begin ( ) ; it != list . end ( ) ; it ++ ) { file_list_ -> addItem ( it -> fileName ( ) ) ; } file_list_ -> setCurrentRow ( 0 ) ; } QDir file_dir_ ; QString file_name_ ; GLWidget * glWidget_ ; QListWidget * file_list_ ; QLabel * message_label_ ; } ; int main ( int argc , char * argv [ ] ) { QApplication app ( argc , argv ) ; MainWindow window ; window . show ( ) ; return app . exec ( ) ; } # include " voronoi _ visualizer . moc " </DOCUMENT>
<DOCUMENT_ID="cppisfun/GameEngine/tree/master/foreign/boost/libs/multi_array/example/subview2.cpp"> # include " boost / multi _ array . hpp " # include " boost / cstdlib . hpp " int main ( ) { using boost :: extents ; using boost :: indices ; typedef boost :: multi_array < int , 3 > array ; int data [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 } ; const int data_size = 24 ; array myarray ( extents [ 2 ] [ 3 ] [ 4 ] ) ; myarray . assign ( data , data + data_size ) ; typedef boost :: multi_array_types :: index_range range ; array :: array_view < 3 > :: type myview = myarray [ indices [ range ( 0 , 2 ) ] [ range ( 1 , 3 ) ] [ range ( 0 , 4 , 2 ) ] ] ; for ( array :: index i = 0 ; i != 2 ; ++ i ) for ( array :: index j = 0 ; j != 2 ; ++ j ) for ( array :: index k = 0 ; k != 2 ; ++ k ) assert ( myview [ i ] [ j ] [ k ] == myarray [ i ] [ j + 1 ] [ k * 2 ] ) ; return boost :: exit_success ; } </DOCUMENT>
<DOCUMENT_ID="thiphariel/navitia/tree/master/source/kraken/tests/data_manager_test.cpp"> # define BOOST_TEST_DYN_LINK # define BOOST_TEST_MODULE data_manager_test # include < boost / test / unit_test . hpp > # include < boost / optional . hpp > # include " kraken / data _ manager . h " # include < atomic > class Data { public : bool load ( const std :: string & , const boost :: optional < std :: string > & , const std :: vector < std :: string > & ) { return load_status ; } mutable std :: atomic < bool > is_connected_to_rabbitmq ; static bool load_status ; static bool destructor_called ; size_t data_identifier ; Data ( size_t data_identifier = 0 ) : data_identifier ( data_identifier ) { is_connected_to_rabbitmq = false ; } ~ Data ( ) { Data :: destructor_called = true ; } } ; bool Data :: load_status = true ; bool Data :: destructor_called = false ; struct fixture { fixture ( ) { Data :: load_status = true ; Data :: destructor_called = false ; } } ; BOOST_FIXTURE_TEST_SUITE ( s , fixture ) BOOST_AUTO_TEST_CASE ( get_data ) { DataManager < Data > data_manager ; auto data = data_manager . get_data ( ) ; BOOST_REQUIRE ( data ) ; BOOST_CHECK_EQUAL ( Data :: destructor_called , false ) ; } BOOST_AUTO_TEST_CASE ( load_success ) { DataManager < Data > data_manager ; auto first_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , data_manager . get_data ( ) ) ; BOOST_CHECK ( data_manager . load ( " " ) ) ; auto second_data = data_manager . get_data ( ) ; BOOST_CHECK_NE ( first_data , second_data ) ; BOOST_CHECK_EQUAL ( Data :: destructor_called , false ) ; } BOOST_AUTO_TEST_CASE ( load_fail ) { DataManager < Data > data_manager ; auto first_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , data_manager . get_data ( ) ) ; Data :: load_status = false ; BOOST_CHECK ( ! data_manager . load ( " " ) ) ; Data :: load_status = true ; auto second_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , second_data ) ; } BOOST_AUTO_TEST_CASE ( destructor_called ) { DataManager < Data > data_manager ; { auto first_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , data_manager . get_data ( ) ) ; BOOST_CHECK ( data_manager . load ( " " ) ) ; auto second_data = data_manager . get_data ( ) ; BOOST_CHECK_NE ( first_data , second_data ) ; BOOST_CHECK_EQUAL ( Data :: destructor_called , false ) ; first_data = boost :: shared_ptr < Data > ( ) ; } BOOST_CHECK_EQUAL ( Data :: destructor_called , true ) ; BOOST_CHECK ( data_manager . get_data ( ) ) ; } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
<DOCUMENT_ID="yxcoin/yxcoin/tree/master/src/boost_1_55_0/libs/phoenix/test/include/stl/algorithm/querying.cpp"> # include < boost / phoenix / stl / algorithm / querying . hpp > int main ( ) { } </DOCUMENT>
<DOCUMENT_ID="JoseBarrales/mlnc/tree/master/src/test/rpc_tests.cpp"> # include < boost / test / unit_test . hpp > # include < boost / foreach . hpp > # include " base58 . h " # include " util . h " # include " bitcoinrpc . h " using namespace std ; using namespace json_spirit ; BOOST_AUTO_TEST_SUITE ( rpc_tests ) static Array createArgs ( int nRequired , const char * address1 = NULL , const char * address2 = NULL ) { Array result ; result . push_back ( nRequired ) ; Array addresses ; if ( address1 ) addresses . push_back ( address1 ) ; if ( address2 ) addresses . push_back ( address1 ) ; result . push_back ( addresses ) ; return result ; } struct TestNetFixture { TestNetFixture ( ) { fTestNet = true ; } ~ TestNetFixture ( ) { fTestNet = false ; } } ; BOOST_FIXTURE_TEST_CASE ( rpc_addmultisig , TestNetFixture ) { rpcfn_type addmultisig = tableRPC [ " addmultisigaddress " ] -> actor ; const char * address1Hex = "0434e3e09f49ea168c5bbf53f877ff4206923858aab7c7e1df25bc263978107c95e35065a27ef6f1b27222db0ec97e0e895eaca603d3ee0d4c060ce3d8a00286c8" ; const char * address2Hex = "0388c2037017c62240b6b72ac1a2a5f94da790596ebd06177c8572752922165cb4" ; Value v ; CBitcoinAddress address ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 1 , address1Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 1 , address1Hex , address2Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 2 , address1Hex , address2Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 0 ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , address1Hex ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 , " " ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 , " NotAValidPubkey " ) , false ) , runtime_error ) ; string short1 ( address1Hex , address1Hex + sizeof ( address1Hex ) - 2 ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , short1 . c_str ( ) ) , false ) , runtime_error ) ; string short2 ( address1Hex + 2 , address1Hex + sizeof ( address1Hex ) ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , short2 . c_str ( ) ) , false ) , runtime_error ) ; } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
<DOCUMENT_ID="yinchunlong/abelkhan-1/tree/master/ext/c++/thirdpart/c++/boost/libs/math/reporting/accuracy/test_ibeta.cpp"> # include " bindings . hpp " # include " . . / . . / test / test _ ibeta . hpp " # include < boost / math / special_functions / beta . hpp > BOOST_AUTO_TEST_CASE_EXPECTED_FAILURES ( test_main , 10000 ) ; BOOST_AUTO_TEST_CASE ( test_main ) { BOOST_MATH_CONTROL_FP ; error_stream_replacer rep ; # ifdef TYPE_TO_TEST test_beta ( static_cast < TYPE_TO_TEST > ( 0 ) , NAME_OF_TYPE_TO_TEST ) ; # else bool test_float = false ; bool test_double = false ; bool test_long_double = false ; if ( std :: numeric_limits < long double > :: digits == std :: numeric_limits < double > :: digits ) { if ( BOOST_MATH_PROMOTE_FLOAT_POLICY == false ) test_float = true ; test_double = true ; } else { if ( BOOST_MATH_PROMOTE_FLOAT_POLICY == false ) test_float = true ; if ( BOOST_MATH_PROMOTE_DOUBLE_POLICY == false ) test_double = true ; test_long_double = true ; } # ifdef ALWAYS_TEST_DOUBLE test_double = true ; # endif if ( test_float ) test_beta ( 0.0f , " float " ) ; if ( test_double ) test_beta ( 0.0 , " double " ) ; if ( test_long_double ) test_beta ( 0.0L , " long ▁ double " ) ; # ifdef BOOST_MATH_USE_FLOAT128 # endif # endif } </DOCUMENT>
<DOCUMENT_ID="fedech/ldpc_sim/tree/master/src/Simulation.cpp"> # include < iostream > # include < fstream > # include < string > # include < boost / numeric / ublas / matrix . hpp > # include < boost / random . hpp > # include < boost / random / normal_distribution . hpp > # include " LDPCEncoder . h " # include " LDPCDecoder . h " int main ( ) { int n = 648 ; int k = 432 ; int p = n - k ; std :: string file = " n648r23" ; int passes = 50 ; bool qam = true ; int symbols = 4 ; double step = 0.25 ; int minsnr = 0 ; double maxsnr = 4.1 ; int maxPackets = 1E6 ; int minErrors = 100 ; int printInterval = maxPackets / 1000 ; std :: string matrixFolder = " . / matrices / " ; std :: string extIn = " . csv " ; std :: string resultsFolder = " . / results / " ; std :: string extOut = " . dat " ; std :: string encoding = matrixFolder + " enc " + file + extIn ; std :: string decoding = matrixFolder + " dec " + file + extIn ; std :: stringstream ss ; if ( qam ) { ss << " qam " << symbols ; } ss << " _ " << passes ; std :: string output = resultsFolder + file + ss . str ( ) + extOut ; std :: ifstream enc ; enc . open ( encoding . c_str ( ) ) ; std :: ifstream dec ; dec . open ( decoding . c_str ( ) ) ; std :: ofstream out ; out . open ( output . c_str ( ) ) ; out << " # LDPC , ▁ n ▁ = ▁ " << n << " , ▁ k ▁ = ▁ " << k << " \n " ; out << " # SNR ▁ ( dB ) ▁ - ▁ BER ▁ - ▁ PER \n " ; std :: vector < double > snrdb ; std :: vector < int > errors ; std :: vector < int > pktErrors ; std :: vector < int > packets ; boost :: numeric :: ublas :: matrix < int > parityMatrix ( p , n ) ; boost :: numeric :: ublas :: matrix < int > encodingMatrix ( n , k ) ; for ( int i = 0 ; i < p ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dec >> parityMatrix ( i , j ) ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < k ; j ++ ) { enc >> encodingMatrix ( i , j ) ; } } for ( double snr = minsnr ; snr < maxsnr ; snr += step ) { snrdb . push_back ( snr ) ; errors . push_back ( 0 ) ; pktErrors . push_back ( 0 ) ; packets . push_back ( 0 ) ; } boost :: mt19937 rng = boost :: mt19937 ( time ( 0 ) ) ; boost :: variate_generator < boost :: mt19937 & , boost :: normal_distribution < > > generator ( rng , boost :: normal_distribution < > ( ) ) ; LDPCEncoder * encoder = new LDPCEncoder ( k , n , encodingMatrix , symbols ) ; LDPCDecoder * decoder = new LDPCDecoder ( k , n , parityMatrix , passes , symbols ) ; std :: cout << std :: time ( NULL ) << " Created ! \n " ; boost :: numeric :: ublas :: matrix < double > results ( snrdb . size ( ) , 26 ) ; for ( int i = 0 ; i < snrdb . size ( ) ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { results ( i , j ) = 0 ; } } for ( int packet = 0 ; packet < maxPackets ; packet ++ ) { if ( packet % printInterval == 0 ) { std :: cout << packet << " ▁ " << std :: time ( NULL ) << " \n " ; } std :: vector < int > uncoded ; std :: vector < double > w ; std :: vector < double > w_q ; for ( int i = 0 ; i < n ; i ++ ) { w . push_back ( generator ( ) ) ; if ( qam ) { w_q . push_back ( generator ( ) ) ; } } for ( int i = 0 ; i < k ; i ++ ) { uncoded . push_back ( rand ( ) % 2 ) ; } std :: vector < int > coded = encoder -> encode ( uncoded ) ; int counter = 0 ; for ( double snr = minsnr ; snr < maxsnr ; snr += step ) { if ( packets . at ( counter ) == 0 ) { double n0 = 1 / pow ( 10 , snr / 10 ) / log2 ( symbols ) / 2 ; std :: vector < double > received ; std :: vector < LDPCEncoder :: symbol > modulated ; if ( ! qam ) { for ( int i = 0 ; i < n ; i ++ ) { double rec = 2 * coded . at ( i ) - 1 + w . at ( i ) * sqrt ( n0 ) ; received . push_back ( rec ) ; } for ( int i = 0 ; i < n ; i ++ ) { double llr = - 2 * received . at ( i ) / n0 ; received . at ( i ) = llr ; } } else { modulated = encoder -> modulate ( coded ) ; std :: vector < double > phase ; std :: vector < double > quad ; for ( int i = 0 ; i < modulated . size ( ) ; i ++ ) { phase . push_back ( modulated . at ( i ) . phase + w . at ( i ) * sqrt ( n0 ) ) ; quad . push_back ( modulated . at ( i ) . quad + w_q . at ( i ) * sqrt ( n0 ) ) ; } received = decoder -> deModLlr ( phase , quad , n0 ) ; } while ( received . size ( ) > n ) { received . pop_back ( ) ; } std :: vector < int > decoded = decoder -> decode ( received ) ; int error = 0 ; bool correct = true ; for ( int i = 0 ; i < k ; i ++ ) { if ( decoded . at ( i ) != coded . at ( i ) ) { if ( correct ) { correct = false ; pktErrors . at ( counter ) ++ ; } error ++ ; } } errors . at ( counter ) += error ; if ( pktErrors . at ( counter ) > minErrors ) { packets . at ( counter ) = packet + 1 ; } } counter ++ ; } } std :: cout << std :: time ( NULL ) << " Finished ! \n " ; int counter = 0 ; for ( double snr = minsnr ; snr < maxsnr ; snr += step ) { double nPackets = maxPackets ; if ( packets . at ( counter ) != 0 ) { nPackets = packets . at ( counter ) ; } double per = pktErrors . at ( counter ) / nPackets ; double ber = errors . at ( counter ) / ( nPackets * k ) ; out << snr << " ▁ " << ber << " ▁ " << per << " \n " ; counter ++ ; } enc . close ( ) ; dec . close ( ) ; out . close ( ) ; delete encoder ; delete decoder ; } </DOCUMENT>
