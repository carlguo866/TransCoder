void ExternalSymbolDumper :: start ( const PDBSymbolExe & Symbol ) { auto Vars = Symbol . findAllChildren < PDBSymbolPublicSymbol > ( ) ; while ( auto Var = Vars -> getNext ( ) ) Var -> dump ( * this ) ; }
void ExternalSymbolDumper :: dump ( const PDBSymbolPublicSymbol & Symbol ) { std :: string LinkageName = Symbol . getName ( ) ; if ( Printer . IsSymbolExcluded ( LinkageName ) ) return ; Printer . NewLine ( ) ; uint64_t Addr = Symbol . getVirtualAddress ( ) ; Printer << " [ " ; WithColor ( Printer , PDB_ColorItem :: Address ) . get ( ) << format_hex ( Addr , 10 ) ; Printer << " ] ▁ " ; WithColor ( Printer , PDB_ColorItem :: Identifier ) . get ( ) << LinkageName ; }
void JSDocument :: setLocation ( ExecState * exec , JSValue value ) { Frame * frame = static_cast < Document * > ( impl ( ) ) -> frame ( ) ; if ( ! frame ) return ; String locationString = value . toString ( exec ) -> value ( exec ) ; if ( exec -> hadException ( ) ) return ; if ( Location * location = frame -> document ( ) -> domWindow ( ) -> location ( ) ) location -> setHref ( locationString , activeDOMWindow ( exec ) , firstDOMWindow ( exec ) ) ; }
return std :: count_if ( m_employees . cbegin ( ) , m_employees . cend ( ) , [ this , & teamName ] ( const Person & p ) { return teamNameFor ( p ) == teamName ; }
infosHasher :: infosHasher ( long cle , string cleTxt , vector < int > valueVecInt ) { m_hashKey = cle ; m_key = cleTxt ; m_value = valueVecInt ; }
long infosHasher :: getHashKey ( ) { return m_hashKey ; }
string infosHasher :: getKey ( ) { return m_key ; }
vector < int > infosHasher :: getValue ( ) { return m_value ; }
void infosHasher :: setValue ( vector < int > value ) { m_value = value ; }
string infosHasher :: toString ( ) { stringstream to_return ; to_return << m_hashKey << " \t " << m_key << " \t " << vectorToString ( m_value , " \t " ) << endl ; return to_return . str ( ) ; }
void AsmRoutineManager :: Generate ( MIPSState * mips , MIPSComp :: Jit * jit , MIPSComp :: JitOptions * jo ) { enterCode = AlignCode16 ( ) ; ABI_PushAllCalleeSavedRegsAndAdjustStack ( ) ; MOV ( 64 , R ( MEMBASEREG ) , ImmPtr ( Memory :: base ) ) ; uintptr_t jitbase = ( uintptr_t ) jit -> GetBasePtr ( ) ; if ( jitbase > 0x7FFFFFFFULL ) { MOV ( 64 , R ( JITBASEREG ) , ImmPtr ( jit -> GetBasePtr ( ) ) ) ; jo -> reserveR15ForAsm = true ; } MOV ( PTRBITS , R ( CTXREG ) , ImmPtr ( & mips -> f [ 0 ] ) ) ; outerLoop = GetCodePtr ( ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_CallFunction ( reinterpret_cast < void * > ( & CoreTiming :: Advance ) ) ; jit -> ApplyRoundingMode ( true , this ) ; FixupBranch skipToRealDispatch = J ( ) ; dispatcherCheckCoreState = GetCodePtr ( ) ; FixupBranch bailCoreState = J_CC ( CC_S , true ) ; CMP ( 32 , M ( & coreState ) , Imm32 ( 0 ) ) ; FixupBranch badCoreState = J_CC ( CC_NZ , true ) ; FixupBranch skipToRealDispatch2 = J ( ) ; dispatcher = GetCodePtr ( ) ; FixupBranch bail = J_CC ( CC_S , true ) ; SetJumpTarget ( skipToRealDispatch ) ; SetJumpTarget ( skipToRealDispatch2 ) ; dispatcherNoCheck = GetCodePtr ( ) ; MOV ( 32 , R ( EAX ) , M ( & mips -> pc ) ) ; dispatcherInEAXNoCheck = GetCodePtr ( ) ; AND ( 32 , R ( EAX ) , Imm32 ( Memory :: MEMVIEW32_MASK ) ) ; _assert_msg_ ( CPU , Memory :: base != 0 , " Memory ▁ base ▁ bogus " ) ; MOV ( 32 , R ( EAX ) , MDisp ( EAX , ( u32 ) Memory :: base ) ) ; # elif _M_X64 MOV ( 32 , R ( EAX ) , MComplex ( MEMBASEREG , RAX , SCALE_1 , 0 ) ) ; MOV ( 32 , R ( EDX ) , R ( EAX ) ) ; _assert_msg_ ( JIT , MIPS_JITBLOCK_MASK == 0xFF000000 , " Hardcoded ▁ assumption ▁ of ▁ emuhack ▁ mask " ) ; SHR ( 32 , R ( EDX ) , Imm8 ( 24 ) ) ; CMP ( 32 , R ( EDX ) , Imm8 ( MIPS_EMUHACK_OPCODE >> 24 ) ) ; FixupBranch notfound = J_CC ( CC_NE ) ; if ( enableDebug ) { ADD ( 32 , M ( & mips -> debugCount ) , Imm8 ( 1 ) ) ; } AND ( 32 , R ( EAX ) , Imm32 ( MIPS_EMUHACK_VALUE_MASK ) ) ; ADD ( 32 , R ( EAX ) , ImmPtr ( jit -> GetBasePtr ( ) ) ) ; # elif _M_X64 if ( jo -> reserveR15ForAsm ) ADD ( 64 , R ( RAX ) , R ( JITBASEREG ) ) ; else ADD ( 64 , R ( EAX ) , Imm32 ( jitbase ) ) ; JMPptr ( R ( EAX ) ) ; SetJumpTarget ( notfound ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_CallFunction ( & MIPSComp :: JitAt ) ; jit -> ApplyRoundingMode ( true , this ) ; JMP ( dispatcherNoCheck , true ) ; SetJumpTarget ( bail ) ; SetJumpTarget ( bailCoreState ) ; CMP ( 32 , M ( & coreState ) , Imm32 ( 0 ) ) ; J_CC ( CC_Z , outerLoop , true ) ; SetJumpTarget ( badCoreState ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_PopAllCalleeSavedRegsAndAdjustStack ( ) ; RET ( ) ; breakpointBailout = GetCodePtr ( ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_PopAllCalleeSavedRegsAndAdjustStack ( ) ; RET ( ) ; }
RDListLogs :: RDListLogs ( QString * logname , RDLogFilter :: FilterMode mode , QWidget * parent ) : RDDialog ( parent ) { list_logname = logname ; setMinimumSize ( sizeHint ( ) ) ; setWindowTitle ( tr ( " Select ▁ Log " ) ) ; list_filter_widget = new RDLogFilter ( mode , this ) ; connect ( list_filter_widget , SIGNAL ( filterChanged ( const QString & ) ) , this , SLOT ( filterChangedData ( const QString & ) ) ) ; list_log_list = new Q3ListView ( this ) ; list_log_list -> setAllColumnsShowFocus ( true ) ; list_log_list -> setItemMargin ( 5 ) ; list_log_list -> setSelectionMode ( Q3ListView :: Single ) ; connect ( list_log_list , SIGNAL ( doubleClicked ( Q3ListViewItem * , const QPoint & , int ) ) , this , SLOT ( doubleClickedData ( Q3ListViewItem * , const QPoint & , int ) ) ) ; list_log_list -> addColumn ( tr ( " Name " ) ) ; list_log_list -> setColumnAlignment ( 0 , Qt :: AlignLeft ) ; list_log_list -> addColumn ( tr ( " Description " ) ) ; list_log_list -> setColumnAlignment ( 1 , Qt :: AlignLeft ) ; list_log_list -> addColumn ( tr ( " Service " ) ) ; list_log_list -> setColumnAlignment ( 2 , Qt :: AlignLeft ) ; list_ok_button = new QPushButton ( this ) ; list_ok_button -> setFont ( buttonFont ( ) ) ; list_ok_button -> setText ( tr ( " OK " ) ) ; connect ( list_ok_button , SIGNAL ( clicked ( ) ) , this , SLOT ( okButtonData ( ) ) ) ; list_cancel_button = new QPushButton ( this ) ; list_cancel_button -> setFont ( buttonFont ( ) ) ; list_cancel_button -> setText ( tr ( " Cancel " ) ) ; list_cancel_button -> setDefault ( true ) ; connect ( list_cancel_button , SIGNAL ( clicked ( ) ) , this , SLOT ( cancelButtonData ( ) ) ) ; RefreshList ( ) ; }
void RDListLogs :: closeEvent ( QCloseEvent * e ) { done ( 1 ) ; }
void RDListLogs :: filterChangedData ( const QString & where_sql ) { RefreshList ( ) ; }
void RDListLogs :: doubleClickedData ( Q3ListViewItem * , const QPoint & , int ) { okButtonData ( ) ; }
void RDListLogs :: okButtonData ( ) { Q3ListViewItem * item = list_log_list -> selectedItem ( ) ; if ( item == NULL ) { return ; } * list_logname = item -> text ( 0 ) ; done ( 0 ) ; }
void RDListLogs :: cancelButtonData ( ) { done ( 1 ) ; }
void RDListLogs :: resizeEvent ( QResizeEvent * e ) { list_filter_widget -> setGeometry ( 10 , 10 , size ( ) . width ( ) - 10 , list_filter_widget -> sizeHint ( ) . height ( ) ) ; list_log_list -> setGeometry ( 10 , list_filter_widget -> sizeHint ( ) . height ( ) , size ( ) . width ( ) - 20 , size ( ) . height ( ) - list_filter_widget -> sizeHint ( ) . height ( ) - 70 ) ; list_ok_button -> setGeometry ( size ( ) . width ( ) - 190 , size ( ) . height ( ) - 60 , 80 , 50 ) ; list_cancel_button -> setGeometry ( size ( ) . width ( ) - 90 , size ( ) . height ( ) - 60 , 80 , 50 ) ; }
void RDListLogs :: RefreshList ( ) { RDSqlQuery * q ; QString sql ; Q3ListViewItem * l ; Q3ListViewItem * view_item = NULL ; QDate current_date = QDate :: currentDate ( ) ; list_log_list -> clear ( ) ; sql = QString ( " select ▁ NAME , DESCRIPTION , SERVICE ▁ from ▁ LOGS ▁ " ) + " where ▁ ( TYPE = 0 ) & & ( LOG _ EXISTS = \ " Y \ " ) & & " + " ( ( START _ DATE < = \ " " + current_date . toString ( " yyyy - MM - dd " ) + " \ " ) | | " + " ( START _ DATE = \ " 0000 - 00 - 00 \ " ) | | " + " ( START _ DATE ▁ is ▁ null ) ) & & " + " ( ( END _ DATE > = \ " " + current_date . toString ( " yyyy - MM - dd " ) + " \ " ) | | " + " ( END _ DATE = \ " 0000 - 00 - 00 \ " ) | | " + " ( END _ DATE ▁ is ▁ null ) ) " + list_filter_widget -> whereSql ( ) ; q = new RDSqlQuery ( sql ) ; while ( q -> next ( ) ) { l = new Q3ListViewItem ( list_log_list ) ; l -> setText ( 0 , q -> value ( 0 ) . toString ( ) ) ; l -> setText ( 1 , q -> value ( 1 ) . toString ( ) ) ; l -> setText ( 2 , q -> value ( 2 ) . toString ( ) ) ; if ( l -> text ( 0 ) == * list_logname ) { view_item = l ; } } delete q ; if ( view_item != NULL ) { list_log_list -> setCurrentItem ( view_item ) ; list_log_list -> ensureItemVisible ( view_item ) ; } }
ACE_Log_Msg_IPC :: ~ ACE_Log_Msg_IPC ( void ) { ( void ) this -> close ( ) ; }
int ACE_Log_Msg_IPC :: open ( const ACE_TCHAR * logger_key ) { ACE_LOG_MSG_IPC_CONNECTOR con ; return con . connect ( this -> message_queue_ , ACE_LOG_MSG_IPC_ADDR ( logger_key ) ) ; }
int ACE_Log_Msg_IPC :: reset ( void ) { if ( this -> message_queue_ . get_handle ( ) != ACE_INVALID_HANDLE ) { return this -> close ( ) ; } return 0 ; }
int ACE_Log_Msg_IPC :: close ( void ) { return this -> message_queue_ . close ( ) ; }
ssize_t ACE_Log_Msg_IPC :: log ( ACE_Log_Record & log_record ) { size_t const max_payload_size = 4 + 4 + 12 + 4 + 4 + ( log_record . msg_data_len ( ) * ACE_OutputCDR :: wchar_maxbytes ( ) ) + log_record . msg_data_len ( ) + ACE_CDR :: MAX_ALIGNMENT ; ACE_OutputCDR payload ( max_payload_size ) ; if ( ! ( payload << log_record ) ) return - 1 ; ACE_CDR :: ULong const length = ACE_Utils :: truncate_cast < ACE_CDR :: ULong > ( payload . total_length ( ) ) ; ACE_OutputCDR header ( ACE_CDR :: MAX_ALIGNMENT + 8 ) ; if ( ! ( header << ACE_OutputCDR :: from_boolean ( ACE_CDR_BYTE_ORDER ) ) ) return - 1 ; if ( ! ( header << ACE_CDR :: ULong ( length ) ) ) return - 1 ; iovec iov [ 2 ] ; iov [ 0 ] . iov_base = header . begin ( ) -> rd_ptr ( ) ; iov [ 0 ] . iov_len = 8 ; iov [ 1 ] . iov_base = payload . begin ( ) -> rd_ptr ( ) ; iov [ 1 ] . iov_len = length ; ACE_HAS_STREAM_LOG_MSG_IPC == 1 ) ACE_Str_Buf header_msg ( static_cast < void * > ( header . begin ( ) -> rd_ptr ( ) ) , static_cast < int > ( 8 ) ) ; ACE_Str_Buf payload_msg ( static_cast < void * > ( payload . begin ( ) -> rd_ptr ( ) ) , static_cast < int > ( length ) ) ; return this -> message_queue_ . send ( & header_msg , & payload_msg , static_cast < int > ( log_record . priority ( ) ) , MSG_BAND ) ; return this -> message_queue_ . sendv_n ( iov , 2 ) ; }
bool QEventDispatcherX11 :: processEvents ( QEventLoop :: ProcessEventsFlags flags ) { Q_D ( QEventDispatcherX11 ) ; d -> interrupt = false ; QApplication :: sendPostedEvents ( ) ; ulong marker = XNextRequest ( X11 -> display ) ; int nevents = 0 ; do { while ( ! d -> interrupt ) { XEvent event ; if ( ! ( flags & QEventLoop :: ExcludeUserInputEvents ) && ! d -> queuedUserInputEvents . isEmpty ( ) ) { event = d -> queuedUserInputEvents . takeFirst ( ) ; } else if ( XEventsQueued ( X11 -> display , QueuedAlready ) ) { XNextEvent ( X11 -> display , & event ) ; if ( flags & QEventLoop :: ExcludeUserInputEvents ) { switch ( event . type ) { case ButtonPress : case ButtonRelease : case MotionNotify : case XKeyPress : case XKeyRelease : case EnterNotify : case LeaveNotify : d -> queuedUserInputEvents . append ( event ) ; continue ; case ClientMessage : if ( event . xclient . format == 32 ) { if ( event . xclient . message_type == ATOM ( WM_PROTOCOLS ) && ( Atom ) event . xclient . data . l [ 0 ] == ATOM ( WM_TAKE_FOCUS ) ) { break ; } else if ( event . xclient . message_type == ATOM ( _QT_SCROLL_DONE ) ) { break ; } } d -> queuedUserInputEvents . append ( event ) ; continue ; default : break ; } } } else { break ; } if ( filterEvent ( & event ) ) continue ; nevents ++ ; if ( qApp -> x11ProcessEvent ( & event ) == 1 ) return true ; if ( event . xany . serial >= marker ) { if ( XEventsQueued ( X11 -> display , QueuedAfterFlush ) ) flags &= ~ QEventLoop :: WaitForMoreEvents ; goto out ; } } } while ( ! d -> interrupt && XEventsQueued ( X11 -> display , QueuedAfterFlush ) ) ; out : if ( ! d -> interrupt ) { const uint exclude_all = QEventLoop :: ExcludeSocketNotifiers | QEventLoop :: X11ExcludeTimers | QEventLoop :: WaitForMoreEvents ; if ( nevents > 0 && ( ( uint ) flags & exclude_all ) == exclude_all ) { QApplication :: sendPostedEvents ( ) ; return nevents > 0 ; } return QEventDispatcherUNIX :: processEvents ( flags ) || ( nevents > 0 ) ; } return nevents > 0 ; }
bool QEventDispatcherX11 :: hasPendingEvents ( ) { extern uint qGlobalPostedEventsCount ( ) ; return ( qGlobalPostedEventsCount ( ) || XPending ( X11 -> display ) ) ; }
void QEventDispatcherX11 :: flush ( ) { XFlush ( X11 -> display ) ; }
void QEventDispatcherX11 :: startingUp ( ) { Q_D ( QEventDispatcherX11 ) ; d -> xfd = XConnectionNumber ( X11 -> display ) ; }
void QEventDispatcherX11 :: closingDown ( ) { Q_D ( QEventDispatcherX11 ) ; d -> xfd = - 1 ; }
int QEventDispatcherX11 :: select ( int nfds , fd_set * readfds , fd_set * writefds , fd_set * exceptfds , timeval * timeout ) { Q_D ( QEventDispatcherX11 ) ; if ( d -> xfd > 0 ) { nfds = qMax ( nfds - 1 , d -> xfd ) + 1 ; FD_SET ( d -> xfd , readfds ) ; } return QEventDispatcherUNIX :: select ( nfds , readfds , writefds , exceptfds , timeout ) ; }
Cylinder * TrashHolder :: __queryDestination ( int32_t & , const Thing * , Item * * , uint32_t & ) { return this ; }
void TrashHolder :: __addThing ( Thing * thing ) { return __addThing ( 0 , thing ) ; }
void TrashHolder :: __addThing ( int32_t , Thing * thing ) { Item * item = thing -> getItem ( ) ; if ( ! item ) { return ; } if ( item == this || ! item -> hasProperty ( CONST_PROP_MOVEABLE ) ) { return ; } if ( item -> isHangable ( ) && isGroundTile ( ) ) { Tile * tile = dynamic_cast < Tile * > ( getParent ( ) ) ; if ( tile && tile -> hasFlag ( TILESTATE_SUPPORTS_HANGABLE ) ) { return ; } } g_game . internalRemoveItem ( item ) ; const ItemType & it = Item :: items [ getID ( ) ] ; if ( it . magicEffect != CONST_ME_NONE ) { g_game . addMagicEffect ( getPosition ( ) , it . magicEffect ) ; } }
void TrashHolder :: postAddNotification ( Thing * thing , const Cylinder * oldParent , int32_t index , cylinderlink_t ) { getParent ( ) -> postAddNotification ( thing , oldParent , index , LINK_PARENT ) ; }
void TrashHolder :: postRemoveNotification ( Thing * thing , const Cylinder * newParent , int32_t index , bool isCompleteRemoval , cylinderlink_t ) { getParent ( ) -> postRemoveNotification ( thing , newParent , index , isCompleteRemoval , LINK_PARENT ) ; }
DWORD MaterialDef :: GetViewData ( const char * viewName ) { DWORD * value = NULL ; viewData . Get ( viewName , & value ) ; return * value ; }
void MaterialDef :: SetViewData ( const char * viewName , DWORD value ) { viewData . Set ( viewName , value ) ; }
void MaterialDefManager :: InitializeMaterialDefLists ( ) { char * buffer ; int length = fileSystem -> ReadFile ( MATERIAL_DEF_FILE , ( void * * ) & buffer ) ; if ( length == - 1 ) { common -> Error ( " Couldn ' t ▁ load ▁ material ▁ editor ▁ definition : ▁ % s " , MATERIAL_DEF_FILE ) ; return ; } idLexer src ; if ( ! src . LoadMemory ( buffer , length , MATERIAL_DEF_FILE ) ) { common -> Error ( " Couldn ' t ▁ parse ▁ % s " , MATERIAL_DEF_FILE ) ; fileSystem -> FreeFile ( buffer ) ; } InitializeMaterialDefList ( & src , " materialprops " , & materialDefs [ MATERIAL_DEF_MATERIAL ] ) ; InitializeMaterialDefList ( & src , " stageprops " , & materialDefs [ MATERIAL_DEF_STAGE ] ) ; InitializeMaterialDefList ( & src , " specialmapstageprops " , & materialDefs [ MATERIAL_DEF_SPECIAL_STAGE ] ) ; fileSystem -> FreeFile ( buffer ) ; }
void MaterialDefManager :: InitializeMaterialDefList ( idLexer * src , const char * typeName , MaterialDefList * list ) { idToken token ; src -> Reset ( ) ; src -> SkipUntilString ( typeName ) ; src -> SkipUntilString ( " { " ) ; while ( 1 ) { if ( ! src -> ExpectAnyToken ( & token ) ) { return ; } if ( token == " } " ) { break ; } MaterialDef * newProp = new MaterialDef ( ) ; if ( ! token . Icmp ( " TYPE _ GROUP " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_GROUP ; } else if ( ! token . Icmp ( " TYPE _ BOOL " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_BOOL ; } else if ( ! token . Icmp ( " TYPE _ STRING " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_STRING ; } else if ( ! token . Icmp ( " TYPE _ FLOAT " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_FLOAT ; } else if ( ! token . Icmp ( " TYPE _ INT " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_INT ; } src -> ReadToken ( & token ) ; src -> ReadToken ( & token ) ; newProp -> dictName = token ; src -> ReadToken ( & token ) ; src -> ReadToken ( & token ) ; newProp -> displayName = token ; src -> ReadToken ( & token ) ; src -> ReadToken ( & token ) ; newProp -> displayInfo = token ; if ( newProp -> type == MaterialDef :: MATERIAL_DEF_TYPE_STRING ) { newProp -> quotes = false ; src -> ReadToken ( & token ) ; src -> ReadToken ( & token ) ; if ( token == "1" ) { newProp -> quotes = true ; } } src -> SkipRestOfLine ( ) ; list -> Append ( newProp ) ; } }
void MaterialDefManager :: DestroyMaterialDefLists ( ) { for ( int i = 0 ; i < MATERIAL_DEF_NUM ; i ++ ) { for ( int j = 0 ; j < materialDefs [ i ] . Num ( ) ; j ++ ) { delete materialDefs [ i ] [ j ] ; } materialDefs [ i ] . Clear ( ) ; } }
MaterialDefList * MaterialDefManager :: GetMaterialDefs ( int type ) { if ( type >= 0 && type < MATERIAL_DEF_NUM ) { return & materialDefs [ type ] ; } return NULL ; }
void ASResource :: buildAssignmentOperators ( vector < const string * > & assignmentOperators ) { assignmentOperators . push_back ( & AS_ASSIGN ) ; assignmentOperators . push_back ( & AS_PLUS_ASSIGN ) ; assignmentOperators . push_back ( & AS_MINUS_ASSIGN ) ; assignmentOperators . push_back ( & AS_MULT_ASSIGN ) ; assignmentOperators . push_back ( & AS_DIV_ASSIGN ) ; assignmentOperators . push_back ( & AS_MOD_ASSIGN ) ; assignmentOperators . push_back ( & AS_OR_ASSIGN ) ; assignmentOperators . push_back ( & AS_AND_ASSIGN ) ; assignmentOperators . push_back ( & AS_XOR_ASSIGN ) ; assignmentOperators . push_back ( & AS_GR_GR_GR_ASSIGN ) ; assignmentOperators . push_back ( & AS_GR_GR_ASSIGN ) ; assignmentOperators . push_back ( & AS_LS_LS_ASSIGN ) ; assignmentOperators . push_back ( & AS_LS_LS_LS_ASSIGN ) ; assignmentOperators . push_back ( & AS_RETURN ) ; }
void ASResource :: buildCastOperators ( vector < const string * > & castOperators ) { castOperators . push_back ( & AS_CONST_CAST ) ; castOperators . push_back ( & AS_DYNAMIC_CAST ) ; castOperators . push_back ( & AS_REINTERPRET_CAST ) ; castOperators . push_back ( & AS_STATIC_CAST ) ; }
void ASResource :: buildHeaders ( vector < const string * > & headers , int fileType , bool beautifier ) { headers . push_back ( & AS_IF ) ; headers . push_back ( & AS_ELSE ) ; headers . push_back ( & AS_FOR ) ; headers . push_back ( & AS_WHILE ) ; headers . push_back ( & AS_DO ) ; headers . push_back ( & AS_SWITCH ) ; headers . push_back ( & AS_TRY ) ; headers . push_back ( & AS_CATCH ) ; if ( beautifier ) { headers . push_back ( & AS_CASE ) ; headers . push_back ( & AS_DEFAULT ) ; headers . push_back ( & AS_CONST ) ; headers . push_back ( & AS_STATIC ) ; headers . push_back ( & AS_EXTERN ) ; headers . push_back ( & AS_TEMPLATE ) ; } if ( fileType == JAVA_TYPE ) { headers . push_back ( & AS_FINALLY ) ; headers . push_back ( & AS_SYNCHRONIZED ) ; } if ( fileType == SHARP_TYPE ) { headers . push_back ( & AS_FINALLY ) ; headers . push_back ( & AS_FOREACH ) ; headers . push_back ( & AS_LOCK ) ; headers . push_back ( & AS_UNSAFE ) ; headers . push_back ( & AS_FIXED ) ; headers . push_back ( & AS_GET ) ; headers . push_back ( & AS_SET ) ; headers . push_back ( & AS_ADD ) ; headers . push_back ( & AS_REMOVE ) ; } }
void ASResource :: buildNonAssignmentOperators ( vector < const string * > & nonAssignmentOperators ) { nonAssignmentOperators . push_back ( & AS_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_PLUS_PLUS ) ; nonAssignmentOperators . push_back ( & AS_MINUS_MINUS ) ; nonAssignmentOperators . push_back ( & AS_NOT_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_GR_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_GR_GR_GR ) ; nonAssignmentOperators . push_back ( & AS_GR_GR ) ; nonAssignmentOperators . push_back ( & AS_LS_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_LS_LS_LS ) ; nonAssignmentOperators . push_back ( & AS_LS_LS ) ; nonAssignmentOperators . push_back ( & AS_ARROW ) ; nonAssignmentOperators . push_back ( & AS_AND ) ; nonAssignmentOperators . push_back ( & AS_OR ) ; }
void ASResource :: buildNonParenHeaders ( vector < const string * > & nonParenHeaders , int fileType , bool beautifier ) { nonParenHeaders . push_back ( & AS_ELSE ) ; nonParenHeaders . push_back ( & AS_DO ) ; nonParenHeaders . push_back ( & AS_TRY ) ; if ( beautifier ) { nonParenHeaders . push_back ( & AS_CASE ) ; nonParenHeaders . push_back ( & AS_DEFAULT ) ; nonParenHeaders . push_back ( & AS_CONST ) ; nonParenHeaders . push_back ( & AS_STATIC ) ; nonParenHeaders . push_back ( & AS_EXTERN ) ; nonParenHeaders . push_back ( & AS_TEMPLATE ) ; } if ( fileType == JAVA_TYPE ) { nonParenHeaders . push_back ( & AS_FINALLY ) ; } if ( fileType == SHARP_TYPE ) { nonParenHeaders . push_back ( & AS_FINALLY ) ; nonParenHeaders . push_back ( & AS_UNSAFE ) ; nonParenHeaders . push_back ( & AS_GET ) ; nonParenHeaders . push_back ( & AS_SET ) ; nonParenHeaders . push_back ( & AS_ADD ) ; nonParenHeaders . push_back ( & AS_REMOVE ) ; } }
void ASResource :: buildOperators ( vector < const string * > & operators ) { operators . push_back ( & AS_PLUS_ASSIGN ) ; operators . push_back ( & AS_MINUS_ASSIGN ) ; operators . push_back ( & AS_MULT_ASSIGN ) ; operators . push_back ( & AS_DIV_ASSIGN ) ; operators . push_back ( & AS_MOD_ASSIGN ) ; operators . push_back ( & AS_OR_ASSIGN ) ; operators . push_back ( & AS_AND_ASSIGN ) ; operators . push_back ( & AS_XOR_ASSIGN ) ; operators . push_back ( & AS_EQUAL ) ; operators . push_back ( & AS_PLUS_PLUS ) ; operators . push_back ( & AS_MINUS_MINUS ) ; operators . push_back ( & AS_NOT_EQUAL ) ; operators . push_back ( & AS_GR_EQUAL ) ; operators . push_back ( & AS_GR_GR_GR_ASSIGN ) ; operators . push_back ( & AS_GR_GR_ASSIGN ) ; operators . push_back ( & AS_GR_GR_GR ) ; operators . push_back ( & AS_GR_GR ) ; operators . push_back ( & AS_LS_EQUAL ) ; operators . push_back ( & AS_LS_LS_LS_ASSIGN ) ; operators . push_back ( & AS_LS_LS_ASSIGN ) ; operators . push_back ( & AS_LS_LS_LS ) ; operators . push_back ( & AS_LS_LS ) ; operators . push_back ( & AS_ARROW ) ; operators . push_back ( & AS_AND ) ; operators . push_back ( & AS_OR ) ; operators . push_back ( & AS_COLON_COLON ) ; operators . push_back ( & AS_PLUS ) ; operators . push_back ( & AS_MINUS ) ; operators . push_back ( & AS_MULT ) ; operators . push_back ( & AS_DIV ) ; operators . push_back ( & AS_MOD ) ; operators . push_back ( & AS_QUESTION ) ; operators . push_back ( & AS_COLON ) ; operators . push_back ( & AS_ASSIGN ) ; operators . push_back ( & AS_LS ) ; operators . push_back ( & AS_GR ) ; operators . push_back ( & AS_NOT ) ; operators . push_back ( & AS_BIT_OR ) ; operators . push_back ( & AS_BIT_AND ) ; operators . push_back ( & AS_BIT_NOT ) ; operators . push_back ( & AS_BIT_XOR ) ; operators . push_back ( & AS_OPERATOR ) ; operators . push_back ( & AS_COMMA ) ; operators . push_back ( & AS_RETURN ) ; }
void ASResource :: buildPreBlockStatements ( vector < const string * > & preBlockStatements ) { preBlockStatements . push_back ( & AS_CLASS ) ; preBlockStatements . push_back ( & AS_STRUCT ) ; preBlockStatements . push_back ( & AS_UNION ) ; preBlockStatements . push_back ( & AS_INTERFACE ) ; preBlockStatements . push_back ( & AS_NAMESPACE ) ; preBlockStatements . push_back ( & AS_THROWS ) ; preBlockStatements . push_back ( & AS_EXTERN ) ; }
void ASResource :: buildPreCommandHeaders ( vector < const string * > & preCommandHeaders ) { preCommandHeaders . push_back ( & AS_EXTERN ) ; preCommandHeaders . push_back ( & AS_THROWS ) ; preCommandHeaders . push_back ( & AS_CONST ) ; }
void ASResource :: buildPreDefinitionHeaders ( vector < const string * > & preDefinitionHeaders ) { preDefinitionHeaders . push_back ( & AS_CLASS ) ; preDefinitionHeaders . push_back ( & AS_INTERFACE ) ; preDefinitionHeaders . push_back ( & AS_NAMESPACE ) ; preDefinitionHeaders . push_back ( & AS_STRUCT ) ; }
bool AudioResampler :: qualityIsSupported ( src_quality quality ) { switch ( quality ) { case DEFAULT_QUALITY : case LOW_QUALITY : case MED_QUALITY : case HIGH_QUALITY : case VERY_HIGH_QUALITY : return true ; default : return false ; } }
uint32_t AudioResampler :: qualityMHz ( src_quality quality ) { switch ( quality ) { default : case DEFAULT_QUALITY : case LOW_QUALITY : return 3 ; case MED_QUALITY : return 6 ; case HIGH_QUALITY : return 20 ; case VERY_HIGH_QUALITY : return 34 ; } }
AudioResampler * AudioResampler :: create ( audio_format_t format , int inChannelCount , int32_t sampleRate , src_quality quality ) { bool atFinalQuality ; if ( quality == DEFAULT_QUALITY ) { int ok = pthread_once ( & once_control , init_routine ) ; if ( ok != 0 ) { ALOGE ( " % s ▁ pthread _ once ▁ failed : ▁ % d " , __func__ , ok ) ; } quality = defaultQuality ; atFinalQuality = false ; } else { atFinalQuality = true ; } if ( quality == DEFAULT_QUALITY ) { } pthread_mutex_lock ( & mutex ) ; for ( ; ; ) { uint32_t deltaMHz = qualityMHz ( quality ) ; uint32_t newMHz = currentMHz + deltaMHz ; if ( ( qualityIsSupported ( quality ) && newMHz <= maxMHz ) || atFinalQuality ) { ALOGV ( " resampler ▁ load ▁ % u ▁ - > ▁ % u ▁ MHz ▁ due ▁ to ▁ delta ▁ + % u ▁ MHz ▁ from ▁ quality ▁ % d " , currentMHz , newMHz , deltaMHz , quality ) ; currentMHz = newMHz ; break ; } switch ( quality ) { default : case LOW_QUALITY : atFinalQuality = true ; break ; case MED_QUALITY : quality = LOW_QUALITY ; break ; case HIGH_QUALITY : quality = MED_QUALITY ; break ; case VERY_HIGH_QUALITY : quality = HIGH_QUALITY ; break ; } } pthread_mutex_unlock ( & mutex ) ; AudioResampler * resampler ; switch ( quality ) { default : case LOW_QUALITY : ALOGV ( " Create ▁ linear ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; resampler = new ( std :: nothrow ) AudioResamplerOrder1 ( inChannelCount , sampleRate ) ; break ; case MED_QUALITY : ALOGV ( " Create ▁ cubic ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; resampler = new ( std :: nothrow ) AudioResamplerCubic ( inChannelCount , sampleRate ) ; break ; case HIGH_QUALITY : ALOGV ( " Create ▁ HIGH _ QUALITY ▁ sinc ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; ALOG_ASSERT ( false , " HIGH _ QUALITY ▁ isn ' t ▁ supported " ) ; break ; case VERY_HIGH_QUALITY : ALOGV ( " Create ▁ VERY _ HIGH _ QUALITY ▁ sinc ▁ Resampler ▁ = ▁ % d " , quality ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; ALOG_ASSERT ( false , " VERY _ HIGH _ QUALITY ▁ isn ' t ▁ supported " ) ; break ; } resampler -> init ( ) ; return resampler ; }
AudioResampler :: AudioResampler ( int inChannelCount , int32_t sampleRate , src_quality quality ) : mChannelCount ( inChannelCount ) , mSampleRate ( sampleRate ) , mInSampleRate ( sampleRate ) , mInputIndex ( 0 ) , mPhaseFraction ( 0 ) , mLocalTimeFreq ( 0 ) , mPTS ( AudioBufferProvider :: kInvalidPTS ) , mQuality ( quality ) { const int maxChannels = 2 ; if ( inChannelCount < 1 || inChannelCount > maxChannels ) { LOG_ALWAYS_FATAL ( " Unsupported ▁ sample ▁ format ▁ % d ▁ quality ▁ % d ▁ channels " , quality , inChannelCount ) ; } if ( sampleRate <= 0 ) { LOG_ALWAYS_FATAL ( " Unsupported ▁ sample ▁ rate ▁ % d ▁ Hz " , sampleRate ) ; } mVolume [ 0 ] = mVolume [ 1 ] = 0 ; mBuffer . frameCount = 0 ; }
AudioResampler :: ~ AudioResampler ( ) { pthread_mutex_lock ( & mutex ) ; src_quality quality = getQuality ( ) ; uint32_t deltaMHz = qualityMHz ( quality ) ; int32_t newMHz = currentMHz - deltaMHz ; ALOGV ( " resampler ▁ load ▁ % u ▁ - > ▁ % d ▁ MHz ▁ due ▁ to ▁ delta ▁ - % u ▁ MHz ▁ from ▁ quality ▁ % d " , currentMHz , newMHz , deltaMHz , quality ) ; LOG_ALWAYS_FATAL_IF ( newMHz < 0 , " negative ▁ resampler ▁ load ▁ % d ▁ MHz " , newMHz ) ; currentMHz = newMHz ; pthread_mutex_unlock ( & mutex ) ; }
void AudioResampler :: setSampleRate ( int32_t inSampleRate ) { mInSampleRate = inSampleRate ; mPhaseIncrement = ( uint32_t ) ( ( kPhaseMultiplier * inSampleRate ) / mSampleRate ) ; }
void AudioResampler :: setVolume ( float left , float right ) { mVolume [ 0 ] = u4_12_from_float ( clampFloatVol ( left ) ) ; mVolume [ 1 ] = u4_12_from_float ( clampFloatVol ( right ) ) ; }
void AudioResampler :: setLocalTimeFreq ( uint64_t freq ) { mLocalTimeFreq = freq ; }
void AudioResampler :: setPTS ( int64_t pts ) { mPTS = pts ; }
int64_t AudioResampler :: calculateOutputPTS ( int outputFrameIndex ) { if ( mPTS == AudioBufferProvider :: kInvalidPTS ) { return AudioBufferProvider :: kInvalidPTS ; } else { return mPTS + ( ( outputFrameIndex * mLocalTimeFreq ) / mSampleRate ) ; } }
void AudioResampler :: reset ( ) { mInputIndex = 0 ; mPhaseFraction = 0 ; mBuffer . frameCount = 0 ; }
size_t AudioResamplerOrder1 :: resample ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { switch ( mChannelCount ) { case 1 : return resampleMono16 ( out , outFrameCount , provider ) ; case 2 : return resampleStereo16 ( out , outFrameCount , provider ) ; default : LOG_ALWAYS_FATAL ( " invalid ▁ channel ▁ count : ▁ % d " , mChannelCount ) ; return 0 ; } }
size_t AudioResamplerOrder1 :: resampleStereo16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { int32_t vl = mVolume [ 0 ] ; int32_t vr = mVolume [ 1 ] ; size_t inputIndex = mInputIndex ; uint32_t phaseFraction = mPhaseFraction ; uint32_t phaseIncrement = mPhaseIncrement ; size_t outputIndex = 0 ; size_t outputSampleCount = outFrameCount * 2 ; size_t inFrameCount = getInFrameCountRequired ( outFrameCount ) ; while ( outputIndex < outputSampleCount ) { while ( mBuffer . frameCount == 0 ) { mBuffer . frameCount = inFrameCount ; provider -> getNextBuffer ( & mBuffer , calculateOutputPTS ( outputIndex / 2 ) ) ; if ( mBuffer . raw == NULL ) { goto resampleStereo16_exit ; } if ( mBuffer . frameCount > inputIndex ) break ; inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount * 2 - 2 ] ; mX0R = mBuffer . i16 [ mBuffer . frameCount * 2 - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } int16_t * in = mBuffer . i16 ; while ( inputIndex == 0 ) { out [ outputIndex ++ ] += vl * Interp ( mX0L , in [ 0 ] , phaseFraction ) ; out [ outputIndex ++ ] += vr * Interp ( mX0R , in [ 1 ] , phaseFraction ) ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; if ( outputIndex == outputSampleCount ) { break ; } } if ( inputIndex + 2 < mBuffer . frameCount ) { int32_t * maxOutPt ; int32_t maxInIdx ; maxOutPt = out + ( outputSampleCount - 2 ) ; maxInIdx = mBuffer . frameCount - 2 ; AsmStereo16Loop ( in , maxOutPt , maxInIdx , outputIndex , out , inputIndex , vl , vr , phaseFraction , phaseIncrement ) ; } while ( outputIndex < outputSampleCount && inputIndex < mBuffer . frameCount ) { out [ outputIndex ++ ] += vl * Interp ( in [ inputIndex * 2 - 2 ] , in [ inputIndex * 2 ] , phaseFraction ) ; out [ outputIndex ++ ] += vr * Interp ( in [ inputIndex * 2 - 1 ] , in [ inputIndex * 2 + 1 ] , phaseFraction ) ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; } if ( inputIndex >= mBuffer . frameCount ) { inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount * 2 - 2 ] ; mX0R = mBuffer . i16 [ mBuffer . frameCount * 2 - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } } resampleStereo16_exit : mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; return outputIndex / 2 ; }
size_t AudioResamplerOrder1 :: resampleMono16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { int32_t vl = mVolume [ 0 ] ; int32_t vr = mVolume [ 1 ] ; size_t inputIndex = mInputIndex ; uint32_t phaseFraction = mPhaseFraction ; uint32_t phaseIncrement = mPhaseIncrement ; size_t outputIndex = 0 ; size_t outputSampleCount = outFrameCount * 2 ; size_t inFrameCount = getInFrameCountRequired ( outFrameCount ) ; while ( outputIndex < outputSampleCount ) { while ( mBuffer . frameCount == 0 ) { mBuffer . frameCount = inFrameCount ; provider -> getNextBuffer ( & mBuffer , calculateOutputPTS ( outputIndex / 2 ) ) ; if ( mBuffer . raw == NULL ) { mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; goto resampleMono16_exit ; } if ( mBuffer . frameCount > inputIndex ) break ; inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } int16_t * in = mBuffer . i16 ; while ( inputIndex == 0 ) { int32_t sample = Interp ( mX0L , in [ 0 ] , phaseFraction ) ; out [ outputIndex ++ ] += vl * sample ; out [ outputIndex ++ ] += vr * sample ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; if ( outputIndex == outputSampleCount ) { break ; } } if ( inputIndex + 2 < mBuffer . frameCount ) { int32_t * maxOutPt ; int32_t maxInIdx ; maxOutPt = out + ( outputSampleCount - 2 ) ; maxInIdx = ( int32_t ) mBuffer . frameCount - 2 ; AsmMono16Loop ( in , maxOutPt , maxInIdx , outputIndex , out , inputIndex , vl , vr , phaseFraction , phaseIncrement ) ; } while ( outputIndex < outputSampleCount && inputIndex < mBuffer . frameCount ) { int32_t sample = Interp ( in [ inputIndex - 1 ] , in [ inputIndex ] , phaseFraction ) ; out [ outputIndex ++ ] += vl * sample ; out [ outputIndex ++ ] += vr * sample ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; } if ( inputIndex >= mBuffer . frameCount ) { inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } } resampleMono16_exit : mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; return outputIndex ; }
LIBSEDML_CPP_NAMESPACE_BEGIN SedDocument :: SedDocument ( unsigned int level , unsigned int version ) : SedBase ( level , version ) , mLevel ( SEDML_INT_MAX ) , mIsSetLevel ( false ) , mVersion ( SEDML_INT_MAX ) , mIsSetVersion ( false ) , mDataDescriptions ( level , version ) , mSimulations ( level , version ) , mModels ( level , version ) , mTasks ( level , version ) , mDataGenerators ( level , version ) , mOutputs ( level , version ) { mLevel = level ; mIsSetLevel = true ; mVersion = version ; mIsSetVersion = true ; setSedDocument ( this ) ; setSedNamespacesAndOwn ( new SedNamespaces ( level , version ) ) ; connectToChild ( ) ; }
SedDocument :: SedDocument ( SedNamespaces * sedns ) : SedBase ( sedns ) , mLevel ( SEDML_INT_MAX ) , mIsSetLevel ( false ) , mVersion ( SEDML_INT_MAX ) , mIsSetVersion ( false ) , mDataDescriptions ( sedns ) , mSimulations ( sedns ) , mModels ( sedns ) , mTasks ( sedns ) , mDataGenerators ( sedns ) , mOutputs ( sedns ) { mLevel = sedns -> getLevel ( ) ; mIsSetLevel = true ; mVersion = sedns -> getVersion ( ) ; mIsSetVersion = true ; setSedDocument ( this ) ; setElementNamespace ( sedns -> getURI ( ) ) ; connectToChild ( ) ; }
SedDocument :: SedDocument ( const SedDocument & orig ) : SedBase ( orig ) { setSedDocument ( this ) ; mLevel = orig . mLevel ; mIsSetLevel = orig . mIsSetLevel ; mVersion = orig . mVersion ; mIsSetVersion = orig . mIsSetVersion ; mDataDescriptions = orig . mDataDescriptions ; mSimulations = orig . mSimulations ; mModels = orig . mModels ; mTasks = orig . mTasks ; mDataGenerators = orig . mDataGenerators ; mOutputs = orig . mOutputs ; connectToChild ( ) ; }
int SedDocument :: setLevel ( int level ) { mLevel = level ; mIsSetLevel = true ; return LIBSEDML_OPERATION_SUCCESS ; }
int SedDocument :: setVersion ( int version ) { mVersion = version ; mIsSetVersion = true ; return LIBSEDML_OPERATION_SUCCESS ; }
int SedDocument :: unsetLevel ( ) { mLevel = SEDML_INT_MAX ; mIsSetLevel = false ; if ( isSetLevel ( ) == false ) { return LIBSEDML_OPERATION_SUCCESS ; } else { return LIBSEDML_OPERATION_FAILED ; } }
int SedDocument :: unsetVersion ( ) { mVersion = SEDML_INT_MAX ; mIsSetVersion = false ; if ( isSetVersion ( ) == false ) { return LIBSEDML_OPERATION_SUCCESS ; } else { return LIBSEDML_OPERATION_FAILED ; } }
SedDataDescription * SedDocument :: removeDataDescription ( unsigned int n ) { return mDataDescriptions . remove ( n ) ; }
SedDataDescription * SedDocument :: removeDataDescription ( const std :: string & sid ) { return mDataDescriptions . remove ( sid ) ; }
SedDataDescription * SedDocument :: getDataDescription ( unsigned int n ) { return mDataDescriptions . get ( n ) ; }
SedDataDescription * SedDocument :: getDataDescription ( const std :: string & sid ) { return mDataDescriptions . get ( sid ) ; }
int SedDocument :: addDataDescription ( const SedDataDescription * sdd ) { if ( sdd == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mDataDescriptions . append ( sdd ) ; return LIBSEDML_OPERATION_SUCCESS ; }
SedDataDescription * SedDocument :: createDataDescription ( ) { SedDataDescription * temp = new SedDataDescription ( ) ; if ( temp != NULL ) mDataDescriptions . appendAndOwn ( temp ) ; return temp ; }
SedSimulation * SedDocument :: removeSimulation ( unsigned int n ) { return mSimulations . remove ( n ) ; }
SedSimulation * SedDocument :: removeSimulation ( const std :: string & sid ) { return mSimulations . remove ( sid ) ; }
SedSimulation * SedDocument :: getSimulation ( unsigned int n ) { return mSimulations . get ( n ) ; }
SedSimulation * SedDocument :: getSimulation ( const std :: string & sid ) { return mSimulations . get ( sid ) ; }
int SedDocument :: addSimulation ( const SedSimulation * ss ) { if ( ss == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mSimulations . append ( ss ) ; return LIBSEDML_OPERATION_SUCCESS ; }
SedUniformTimeCourse * SedDocument :: createUniformTimeCourse ( ) { SedUniformTimeCourse * temp = new SedUniformTimeCourse ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; }
SedOneStep * SedDocument :: createOneStep ( ) { SedOneStep * temp = new SedOneStep ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; }
SedSteadyState * SedDocument :: createSteadyState ( ) { SedSteadyState * temp = new SedSteadyState ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; }
SedModel * SedDocument :: removeModel ( unsigned int n ) { return mModels . remove ( n ) ; }
SedModel * SedDocument :: removeModel ( const std :: string & sid ) { return mModels . remove ( sid ) ; }
SedModel * SedDocument :: getModel ( unsigned int n ) { return mModels . get ( n ) ; }
SedModel * SedDocument :: getModel ( const std :: string & sid ) { return mModels . get ( sid ) ; }
int SedDocument :: addModel ( const SedModel * sm ) { if ( sm == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mModels . append ( sm ) ; return LIBSEDML_OPERATION_SUCCESS ; }
SedModel * SedDocument :: createModel ( ) { SedModel * temp = new SedModel ( ) ; if ( temp != NULL ) mModels . appendAndOwn ( temp ) ; return temp ; }
SedTask * SedDocument :: removeTask ( unsigned int n ) { return mTasks . remove ( n ) ; }
SedTask * SedDocument :: removeTask ( const std :: string & sid ) { return mTasks . remove ( sid ) ; }
SedTask * SedDocument :: getTask ( unsigned int n ) { return mTasks . get ( n ) ; }
SedTask * SedDocument :: getTask ( const std :: string & sid ) { return mTasks . get ( sid ) ; }
int SedDocument :: addTask ( const SedTask * st ) { if ( st == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mTasks . append ( st ) ; return LIBSEDML_OPERATION_SUCCESS ; }
SedTask * SedDocument :: createTask ( ) { SedTask * temp = new SedTask ( ) ; if ( temp != NULL ) mTasks . appendAndOwn ( temp ) ; return temp ; }
SedRepeatedTask * SedDocument :: createRepeatedTask ( ) { SedRepeatedTask * temp = new SedRepeatedTask ( ) ; if ( temp != NULL ) mTasks . appendAndOwn ( temp ) ; return temp ; }
SedDataGenerator * SedDocument :: removeDataGenerator ( unsigned int n ) { return mDataGenerators . remove ( n ) ; }
SedDataGenerator * SedDocument :: removeDataGenerator ( const std :: string & sid ) { return mDataGenerators . remove ( sid ) ; }
SedDataGenerator * SedDocument :: getDataGenerator ( unsigned int n ) { return mDataGenerators . get ( n ) ; }
SedDataGenerator * SedDocument :: getDataGenerator ( const std :: string & sid ) { return mDataGenerators . get ( sid ) ; }
int SedDocument :: addDataGenerator ( const SedDataGenerator * sdg ) { if ( sdg == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mDataGenerators . append ( sdg ) ; return LIBSEDML_OPERATION_SUCCESS ; }
SedDataGenerator * SedDocument :: createDataGenerator ( ) { SedDataGenerator * temp = new SedDataGenerator ( ) ; if ( temp != NULL ) mDataGenerators . appendAndOwn ( temp ) ; return temp ; }
SedOutput * SedDocument :: removeOutput ( unsigned int n ) { return mOutputs . remove ( n ) ; }
SedOutput * SedDocument :: removeOutput ( const std :: string & sid ) { return mOutputs . remove ( sid ) ; }
SedOutput * SedDocument :: getOutput ( unsigned int n ) { return mOutputs . get ( n ) ; }
SedOutput * SedDocument :: getOutput ( const std :: string & sid ) { return mOutputs . get ( sid ) ; }
int SedDocument :: addOutput ( const SedOutput * so ) { if ( so == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mOutputs . append ( so ) ; return LIBSEDML_OPERATION_SUCCESS ; }
SedReport * SedDocument :: createReport ( ) { SedReport * temp = new SedReport ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; }
SedPlot2D * SedDocument :: createPlot2D ( ) { SedPlot2D * temp = new SedPlot2D ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; }
SedPlot3D * SedDocument :: createPlot3D ( ) { SedPlot3D * temp = new SedPlot3D ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; }
SedBase * SedDocument :: createObject ( XMLInputStream & stream ) { SedBase * object = NULL ; const string & name = stream . peek ( ) . getName ( ) ; if ( name == " listOfDataDescriptions " ) { object = & mDataDescriptions ; } if ( name == " listOfSimulations " ) { object = & mSimulations ; } if ( name == " listOfModels " ) { object = & mModels ; } if ( name == " listOfTasks " ) { object = & mTasks ; } if ( name == " listOfDataGenerators " ) { object = & mDataGenerators ; } if ( name == " listOfOutputs " ) { object = & mOutputs ; } connectToChild ( ) ; return object ; }
void SedDocument :: connectToChild ( ) { SedBase :: connectToChild ( ) ; mDataDescriptions . connectToParent ( this ) ; mSimulations . connectToParent ( this ) ; mModels . connectToParent ( this ) ; mTasks . connectToParent ( this ) ; mDataGenerators . connectToParent ( this ) ; mOutputs . connectToParent ( this ) ; }
void SedDocument :: setSedDocument ( SedDocument * d ) { SedBase :: setSedDocument ( d ) ; mDataDescriptions . setSedDocument ( d ) ; mSimulations . setSedDocument ( d ) ; mModels . setSedDocument ( d ) ; mTasks . setSedDocument ( d ) ; mDataGenerators . setSedDocument ( d ) ; mOutputs . setSedDocument ( d ) ; }
void SedDocument :: addExpectedAttributes ( ExpectedAttributes & attributes ) { SedBase :: addExpectedAttributes ( attributes ) ; attributes . add ( " level " ) ; attributes . add ( " version " ) ; }
void SedDocument :: readAttributes ( const XMLAttributes & attributes , const ExpectedAttributes & expectedAttributes ) { SedBase :: readAttributes ( attributes , expectedAttributes ) ; bool assigned = false ; mIsSetLevel = attributes . readInto ( " level " , mLevel , getErrorLog ( ) , true ) ; mIsSetVersion = attributes . readInto ( " version " , mVersion , getErrorLog ( ) , true ) ; }
SedErrorLog * SedDocument :: getErrorLog ( ) { return & mErrorLog ; }
bool ExpandPseudo :: expand ( ) { bool Expanded = false ; for ( MachineFunction :: iterator BB = MF . begin ( ) , BBEnd = MF . end ( ) ; BB != BBEnd ; ++ BB ) for ( Iter I = BB -> begin ( ) , End = BB -> end ( ) ; I != End ; ) Expanded |= expandInstr ( * BB , I ++ ) ; return Expanded ; }
bool ExpandPseudo :: expandInstr ( MachineBasicBlock & MBB , Iter I ) { switch ( I -> getOpcode ( ) ) { case Mips :: LOAD_CCOND_DSP : expandLoadCCond ( MBB , I ) ; break ; case Mips :: STORE_CCOND_DSP : expandStoreCCond ( MBB , I ) ; break ; case Mips :: LOAD_ACC64 : case Mips :: LOAD_ACC64DSP : expandLoadACC ( MBB , I , 4 ) ; break ; case Mips :: LOAD_ACC128 : expandLoadACC ( MBB , I , 8 ) ; break ; case Mips :: STORE_ACC64 : expandStoreACC ( MBB , I , Mips :: PseudoMFHI , Mips :: PseudoMFLO , 4 ) ; break ; case Mips :: STORE_ACC64DSP : expandStoreACC ( MBB , I , Mips :: MFHI_DSP , Mips :: MFLO_DSP , 4 ) ; break ; case Mips :: STORE_ACC128 : expandStoreACC ( MBB , I , Mips :: PseudoMFHI64 , Mips :: PseudoMFLO64 , 8 ) ; break ; case Mips :: BuildPairF64 : if ( expandBuildPairF64 ( MBB , I , false ) ) MBB . erase ( I ) ; return false ; case Mips :: BuildPairF64_64 : if ( expandBuildPairF64 ( MBB , I , true ) ) MBB . erase ( I ) ; return false ; case Mips :: ExtractElementF64 : if ( expandExtractElementF64 ( MBB , I , false ) ) MBB . erase ( I ) ; return false ; case Mips :: ExtractElementF64_64 : if ( expandExtractElementF64 ( MBB , I , true ) ) MBB . erase ( I ) ; return false ; case TargetOpcode :: COPY : if ( ! expandCopy ( MBB , I ) ) return false ; break ; default : return false ; } MBB . erase ( I ) ; return true ; }
void ExpandPseudo :: expandLoadCCond ( MachineBasicBlock & MBB , Iter I ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( 4 ) ; unsigned VR = MRI . createVirtualRegister ( RC ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; TII . loadRegFromStack ( MBB , I , VR , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , I -> getDebugLoc ( ) , TII . get ( TargetOpcode :: COPY ) , Dst ) . addReg ( VR , RegState :: Kill ) ; }
void ExpandPseudo :: expandStoreCCond ( MachineBasicBlock & MBB , Iter I ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( 4 ) ; unsigned VR = MRI . createVirtualRegister ( RC ) ; unsigned Src = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; BuildMI ( MBB , I , I -> getDebugLoc ( ) , TII . get ( TargetOpcode :: COPY ) , VR ) . addReg ( Src , getKillRegState ( I -> getOperand ( 0 ) . isKill ( ) ) ) ; TII . storeRegToStack ( MBB , I , VR , true , FI , RC , & RegInfo , 0 ) ; }
void ExpandPseudo :: expandLoadACC ( MachineBasicBlock & MBB , Iter I , unsigned RegSize ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( RegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; unsigned Lo = RegInfo . getSubReg ( Dst , Mips :: sub_lo ) ; unsigned Hi = RegInfo . getSubReg ( Dst , Mips :: sub_hi ) ; DebugLoc DL = I -> getDebugLoc ( ) ; const MCInstrDesc & Desc = TII . get ( TargetOpcode :: COPY ) ; TII . loadRegFromStack ( MBB , I , VR0 , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , DL , Desc , Lo ) . addReg ( VR0 , RegState :: Kill ) ; TII . loadRegFromStack ( MBB , I , VR1 , FI , RC , & RegInfo , RegSize ) ; BuildMI ( MBB , I , DL , Desc , Hi ) . addReg ( VR1 , RegState :: Kill ) ; }
void ExpandPseudo :: expandStoreACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc , unsigned RegSize ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( RegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned Src = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; unsigned SrcKill = getKillRegState ( I -> getOperand ( 0 ) . isKill ( ) ) ; DebugLoc DL = I -> getDebugLoc ( ) ; BuildMI ( MBB , I , DL , TII . get ( MFLoOpc ) , VR0 ) . addReg ( Src ) ; TII . storeRegToStack ( MBB , I , VR0 , true , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , DL , TII . get ( MFHiOpc ) , VR1 ) . addReg ( Src , SrcKill ) ; TII . storeRegToStack ( MBB , I , VR1 , true , FI , RC , & RegInfo , RegSize ) ; }
bool ExpandPseudo :: expandCopy ( MachineBasicBlock & MBB , Iter I ) { unsigned Src = I -> getOperand ( 1 ) . getReg ( ) ; std :: pair < unsigned , unsigned > Opcodes = getMFHiLoOpc ( Src ) ; if ( ! Opcodes . first ) return false ; return expandCopyACC ( MBB , I , Opcodes . first , Opcodes . second ) ; }
bool ExpandPseudo :: expandCopyACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc ) { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , Src = I -> getOperand ( 1 ) . getReg ( ) ; unsigned VRegSize = RegInfo . getMinimalPhysRegClass ( Dst ) -> getSize ( ) / 2 ; const TargetRegisterClass * RC = RegInfo . intRegClass ( VRegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned SrcKill = getKillRegState ( I -> getOperand ( 1 ) . isKill ( ) ) ; unsigned DstLo = RegInfo . getSubReg ( Dst , Mips :: sub_lo ) ; unsigned DstHi = RegInfo . getSubReg ( Dst , Mips :: sub_hi ) ; DebugLoc DL = I -> getDebugLoc ( ) ; BuildMI ( MBB , I , DL , TII . get ( MFLoOpc ) , VR0 ) . addReg ( Src ) ; BuildMI ( MBB , I , DL , TII . get ( TargetOpcode :: COPY ) , DstLo ) . addReg ( VR0 , RegState :: Kill ) ; BuildMI ( MBB , I , DL , TII . get ( MFHiOpc ) , VR1 ) . addReg ( Src , SrcKill ) ; BuildMI ( MBB , I , DL , TII . get ( TargetOpcode :: COPY ) , DstHi ) . addReg ( VR1 , RegState :: Kill ) ; return true ; }
ProximityGrid :: ~ ProximityGrid ( ) { dtFree ( m_buckets ) ; dtFree ( m_pool ) ; }
bool ProximityGrid :: init ( const int maxItems , const float cellSize ) { dtAssert ( maxItems > 0 ) ; dtAssert ( cellSize > 0.0f ) ; m_cellSize = cellSize ; m_invCellSize = 1.0f / m_cellSize ; m_bucketsSize = dtNextPow2 ( maxItems ) ; m_buckets = ( unsigned short * ) dtAlloc ( sizeof ( unsigned short ) * m_bucketsSize , DT_ALLOC_PERM ) ; if ( ! m_buckets ) return false ; m_poolSize = maxItems * 4 ; m_poolHead = 0 ; m_pool = ( Item * ) dtAlloc ( sizeof ( Item ) * m_poolSize , DT_ALLOC_PERM ) ; if ( ! m_pool ) return false ; clear ( ) ; return true ; }
void ProximityGrid :: clear ( ) { memset ( m_buckets , 0xff , sizeof ( unsigned short ) * m_bucketsSize ) ; m_poolHead = 0 ; m_bounds [ 0 ] = 0xffff ; m_bounds [ 1 ] = 0xffff ; m_bounds [ 2 ] = - 0xffff ; m_bounds [ 3 ] = - 0xffff ; }
void ProximityGrid :: addItem ( const unsigned short id , const float minx , const float miny , const float maxx , const float maxy ) { const int iminx = ( int ) floorf ( minx * m_invCellSize ) ; const int iminy = ( int ) floorf ( miny * m_invCellSize ) ; const int imaxx = ( int ) floorf ( maxx * m_invCellSize ) ; const int imaxy = ( int ) floorf ( maxy * m_invCellSize ) ; m_bounds [ 0 ] = dtMin ( m_bounds [ 0 ] , iminx ) ; m_bounds [ 1 ] = dtMin ( m_bounds [ 1 ] , iminy ) ; m_bounds [ 2 ] = dtMax ( m_bounds [ 2 ] , imaxx ) ; m_bounds [ 3 ] = dtMax ( m_bounds [ 3 ] , imaxy ) ; for ( int y = iminy ; y <= imaxy ; ++ y ) { for ( int x = iminx ; x <= imaxx ; ++ x ) { if ( m_poolHead < m_poolSize ) { const int h = hashPos2 ( x , y , m_bucketsSize ) ; const unsigned short idx = ( unsigned short ) m_poolHead ; m_poolHead ++ ; Item & item = m_pool [ idx ] ; item . x = ( short ) x ; item . y = ( short ) y ; item . id = id ; item . next = m_buckets [ h ] ; m_buckets [ h ] = idx ; } } } }
std :: string HelpRequiringPassphrase ( ) { return pwalletMain && pwalletMain -> IsCrypted ( ) ? " \n requires ▁ wallet ▁ passphrase ▁ to ▁ be ▁ set ▁ with ▁ walletpassphrase ▁ first " : " " ; }
