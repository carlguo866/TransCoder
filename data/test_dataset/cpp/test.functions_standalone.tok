int main ( ) { std :: char_traits < char16_t > :: int_type i = std :: char_traits < char16_t > :: eof ( ) ; }
KURL soupURIToKURL ( SoupURI * soupURI ) { GOwnPtr < gchar > urlString ( soup_uri_to_string ( soupURI , FALSE ) ) ; KURL url ( KURL ( ) , String :: fromUTF8 ( urlString . get ( ) ) ) ; if ( ! soupURI -> password ) return url ; url . setPass ( String :: fromUTF8 ( soupURI -> password ) ) ; return url ; }
TEST ( CodeGenTest , TestNullCodeGen ) { auto Invocation = std :: make_shared < CompilerInvocation > ( ) ; Invocation -> getPreprocessorOpts ( ) . addRemappedFile ( " test . cc " , MemoryBuffer :: getMemBuffer ( " " ) . release ( ) ) ; Invocation -> getFrontendOpts ( ) . Inputs . push_back ( FrontendInputFile ( " test . cc " , Language :: CXX ) ) ; Invocation -> getFrontendOpts ( ) . ProgramAction = EmitLLVM ; Invocation -> getTargetOpts ( ) . Triple = " i386 - unknown - linux - gnu " ; CompilerInstance Compiler ; Compiler . setInvocation ( std :: move ( Invocation ) ) ; Compiler . createDiagnostics ( ) ; EXPECT_TRUE ( Compiler . hasDiagnostics ( ) ) ; std :: unique_ptr < FrontendAction > Act ( new NullCodeGenAction ) ; bool Success = Compiler . ExecuteAction ( * Act ) ; EXPECT_TRUE ( Success ) ; }
void agg_framework_reservedErrors ( ) { uassert ( 16030 , " reserved ▁ error " , false ) ; uassert ( 16031 , " reserved ▁ error " , false ) ; uassert ( 16032 , " reserved ▁ error " , false ) ; uassert ( 16033 , " reserved ▁ error " , false ) ; uassert ( 16036 , " reserved ▁ error " , false ) ; uassert ( 16037 , " reserved ▁ error " , false ) ; uassert ( 16038 , " reserved ▁ error " , false ) ; uassert ( 16039 , " reserved ▁ error " , false ) ; uassert ( 16040 , " reserved ▁ error " , false ) ; uassert ( 16041 , " reserved ▁ error " , false ) ; uassert ( 16042 , " reserved ▁ error " , false ) ; uassert ( 16043 , " reserved ▁ error " , false ) ; uassert ( 16044 , " reserved ▁ error " , false ) ; uassert ( 16045 , " reserved ▁ error " , false ) ; uassert ( 16046 , " reserved ▁ error " , false ) ; uassert ( 16047 , " reserved ▁ error " , false ) ; uassert ( 16048 , " reserved ▁ error " , false ) ; uassert ( 16049 , " reserved ▁ error " , false ) ; }
inline void swap ( short & a , short & b ) { short temp = a ; a = b ; b = temp ; }
void gbafilter_pal ( u16 * buf , int count ) { short temp [ 3 * 3 ] , s ; unsigned pix ; u8 red , green , blue ; while ( count -- ) { pix = * buf ; s = curve [ ( pix >> systemGreenShift ) & 0x1f ] ; temp [ 3 ] = s * influence [ 3 ] ; temp [ 4 ] = s * influence [ 4 ] ; temp [ 5 ] = s * influence [ 5 ] ; s = curve [ ( pix >> systemRedShift ) & 0x1f ] ; temp [ 0 ] = s * influence [ 0 ] ; temp [ 1 ] = s * influence [ 1 ] ; temp [ 2 ] = s * influence [ 2 ] ; s = curve [ ( pix >> systemBlueShift ) & 0x1f ] ; temp [ 6 ] = s * influence [ 6 ] ; temp [ 7 ] = s * influence [ 7 ] ; temp [ 8 ] = s * influence [ 8 ] ; if ( temp [ 0 ] < temp [ 3 ] ) swap ( temp [ 0 ] , temp [ 3 ] ) ; if ( temp [ 0 ] < temp [ 6 ] ) swap ( temp [ 0 ] , temp [ 6 ] ) ; if ( temp [ 3 ] < temp [ 6 ] ) swap ( temp [ 3 ] , temp [ 6 ] ) ; temp [ 3 ] <<= 1 ; temp [ 0 ] <<= 2 ; temp [ 0 ] += temp [ 3 ] + temp [ 6 ] ; red = ( ( int ( temp [ 0 ] ) * 160 ) >> 17 ) + 4 ; if ( red > 31 ) red = 31 ; if ( temp [ 2 ] < temp [ 5 ] ) swap ( temp [ 2 ] , temp [ 5 ] ) ; if ( temp [ 2 ] < temp [ 8 ] ) swap ( temp [ 2 ] , temp [ 8 ] ) ; if ( temp [ 5 ] < temp [ 8 ] ) swap ( temp [ 5 ] , temp [ 8 ] ) ; temp [ 5 ] <<= 1 ; temp [ 2 ] <<= 2 ; temp [ 2 ] += temp [ 5 ] + temp [ 8 ] ; blue = ( ( int ( temp [ 2 ] ) * 160 ) >> 17 ) + 4 ; if ( blue > 31 ) blue = 31 ; if ( temp [ 1 ] < temp [ 4 ] ) swap ( temp [ 1 ] , temp [ 4 ] ) ; if ( temp [ 1 ] < temp [ 7 ] ) swap ( temp [ 1 ] , temp [ 7 ] ) ; if ( temp [ 4 ] < temp [ 7 ] ) swap ( temp [ 4 ] , temp [ 7 ] ) ; temp [ 4 ] <<= 1 ; temp [ 1 ] <<= 2 ; temp [ 1 ] += temp [ 4 ] + temp [ 7 ] ; green = ( ( int ( temp [ 1 ] ) * 160 ) >> 17 ) + 4 ; if ( green > 31 ) green = 31 ; pix = red << systemRedShift ; pix += green << systemGreenShift ; pix += blue << systemBlueShift ; * buf ++ = pix ; } }
void gbafilter_pal32 ( u32 * buf , int count ) { short temp [ 3 * 3 ] , s ; unsigned pix ; u8 red , green , blue ; while ( count -- ) { pix = * buf ; s = curve [ ( pix >> systemGreenShift ) & 0x1f ] ; temp [ 3 ] = s * influence [ 3 ] ; temp [ 4 ] = s * influence [ 4 ] ; temp [ 5 ] = s * influence [ 5 ] ; s = curve [ ( pix >> systemRedShift ) & 0x1f ] ; temp [ 0 ] = s * influence [ 0 ] ; temp [ 1 ] = s * influence [ 1 ] ; temp [ 2 ] = s * influence [ 2 ] ; s = curve [ ( pix >> systemBlueShift ) & 0x1f ] ; temp [ 6 ] = s * influence [ 6 ] ; temp [ 7 ] = s * influence [ 7 ] ; temp [ 8 ] = s * influence [ 8 ] ; if ( temp [ 0 ] < temp [ 3 ] ) swap ( temp [ 0 ] , temp [ 3 ] ) ; if ( temp [ 0 ] < temp [ 6 ] ) swap ( temp [ 0 ] , temp [ 6 ] ) ; if ( temp [ 3 ] < temp [ 6 ] ) swap ( temp [ 3 ] , temp [ 6 ] ) ; temp [ 3 ] <<= 1 ; temp [ 0 ] <<= 2 ; temp [ 0 ] += temp [ 3 ] + temp [ 6 ] ; red = ( ( int ( temp [ 0 ] ) * 160 ) >> 14 ) + 32 ; if ( temp [ 2 ] < temp [ 5 ] ) swap ( temp [ 2 ] , temp [ 5 ] ) ; if ( temp [ 2 ] < temp [ 8 ] ) swap ( temp [ 2 ] , temp [ 8 ] ) ; if ( temp [ 5 ] < temp [ 8 ] ) swap ( temp [ 5 ] , temp [ 8 ] ) ; temp [ 5 ] <<= 1 ; temp [ 2 ] <<= 2 ; temp [ 2 ] += temp [ 5 ] + temp [ 8 ] ; blue = ( ( int ( temp [ 2 ] ) * 160 ) >> 14 ) + 32 ; if ( temp [ 1 ] < temp [ 4 ] ) swap ( temp [ 1 ] , temp [ 4 ] ) ; if ( temp [ 1 ] < temp [ 7 ] ) swap ( temp [ 1 ] , temp [ 7 ] ) ; if ( temp [ 4 ] < temp [ 7 ] ) swap ( temp [ 4 ] , temp [ 7 ] ) ; temp [ 4 ] <<= 1 ; temp [ 1 ] <<= 2 ; temp [ 1 ] += temp [ 4 ] + temp [ 7 ] ; green = ( ( int ( temp [ 1 ] ) * 160 ) >> 14 ) + 32 ; pix = red << ( systemRedShift - 3 ) ; pix += green << ( systemGreenShift - 3 ) ; pix += blue << ( systemBlueShift - 3 ) ; * buf ++ = pix ; } }
void gbafilter_pad ( u8 * buf , int count ) { union { struct { u8 r ; u8 g ; u8 b ; u8 a ; } part ; unsigned whole ; } mask ; mask . whole = 0x1f << systemRedShift ; mask . whole += 0x1f << systemGreenShift ; mask . whole += 0x1f << systemBlueShift ; switch ( systemColorDepth ) { case 24 : while ( count -- ) { * buf ++ &= mask . part . r ; * buf ++ &= mask . part . g ; * buf ++ &= mask . part . b ; } break ; case 32 : while ( count -- ) { * ( ( u32 * ) buf ) &= mask . whole ; buf += 4 ; } } }
