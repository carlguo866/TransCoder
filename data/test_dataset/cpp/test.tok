<DOCUMENT_ID="MobWiMetro/gba10/tree/master/GBA10/VBAM/gba/gbafilter.cpp"> # include " gbafilter . h " # include < math . h > extern int systemColorDepth ; extern int systemRedShift ; extern int systemGreenShift ; extern int systemBlueShift ; extern u16 systemColorMap16 [ 0x10000 ] ; extern u32 systemColorMap32 [ 0x10000 ] ; static const unsigned char curve [ 32 ] = { 0x08 , 0x09 , 0x0a , 0x0b , 0x0c , 0x0e , 0x10 , 0x12 , 0x14 , 0x16 , 0x18 , 0x1c , 0x20 , 0x28 , 0x30 , 0x38 , 0x40 , 0x48 , 0x50 , 0x58 , 0x60 , 0x68 , 0x70 , 0x80 , 0x88 , 0x90 , 0xa0 , 0xb0 , 0xc0 , 0xd0 , 0xe0 , 0xf0 } ; static const unsigned char influence [ 3 * 3 ] = { 16 , 4 , 4 , 8 , 16 , 8 , 0 , 8 , 16 } ; inline void swap ( short & a , short & b ) { short temp = a ; a = b ; b = temp ; } void gbafilter_pal ( u16 * buf , int count ) { short temp [ 3 * 3 ] , s ; unsigned pix ; u8 red , green , blue ; while ( count -- ) { pix = * buf ; s = curve [ ( pix >> systemGreenShift ) & 0x1f ] ; temp [ 3 ] = s * influence [ 3 ] ; temp [ 4 ] = s * influence [ 4 ] ; temp [ 5 ] = s * influence [ 5 ] ; s = curve [ ( pix >> systemRedShift ) & 0x1f ] ; temp [ 0 ] = s * influence [ 0 ] ; temp [ 1 ] = s * influence [ 1 ] ; temp [ 2 ] = s * influence [ 2 ] ; s = curve [ ( pix >> systemBlueShift ) & 0x1f ] ; temp [ 6 ] = s * influence [ 6 ] ; temp [ 7 ] = s * influence [ 7 ] ; temp [ 8 ] = s * influence [ 8 ] ; if ( temp [ 0 ] < temp [ 3 ] ) swap ( temp [ 0 ] , temp [ 3 ] ) ; if ( temp [ 0 ] < temp [ 6 ] ) swap ( temp [ 0 ] , temp [ 6 ] ) ; if ( temp [ 3 ] < temp [ 6 ] ) swap ( temp [ 3 ] , temp [ 6 ] ) ; temp [ 3 ] <<= 1 ; temp [ 0 ] <<= 2 ; temp [ 0 ] += temp [ 3 ] + temp [ 6 ] ; red = ( ( int ( temp [ 0 ] ) * 160 ) >> 17 ) + 4 ; if ( red > 31 ) red = 31 ; if ( temp [ 2 ] < temp [ 5 ] ) swap ( temp [ 2 ] , temp [ 5 ] ) ; if ( temp [ 2 ] < temp [ 8 ] ) swap ( temp [ 2 ] , temp [ 8 ] ) ; if ( temp [ 5 ] < temp [ 8 ] ) swap ( temp [ 5 ] , temp [ 8 ] ) ; temp [ 5 ] <<= 1 ; temp [ 2 ] <<= 2 ; temp [ 2 ] += temp [ 5 ] + temp [ 8 ] ; blue = ( ( int ( temp [ 2 ] ) * 160 ) >> 17 ) + 4 ; if ( blue > 31 ) blue = 31 ; if ( temp [ 1 ] < temp [ 4 ] ) swap ( temp [ 1 ] , temp [ 4 ] ) ; if ( temp [ 1 ] < temp [ 7 ] ) swap ( temp [ 1 ] , temp [ 7 ] ) ; if ( temp [ 4 ] < temp [ 7 ] ) swap ( temp [ 4 ] , temp [ 7 ] ) ; temp [ 4 ] <<= 1 ; temp [ 1 ] <<= 2 ; temp [ 1 ] += temp [ 4 ] + temp [ 7 ] ; green = ( ( int ( temp [ 1 ] ) * 160 ) >> 17 ) + 4 ; if ( green > 31 ) green = 31 ; pix = red << systemRedShift ; pix += green << systemGreenShift ; pix += blue << systemBlueShift ; * buf ++ = pix ; } } void gbafilter_pal32 ( u32 * buf , int count ) { short temp [ 3 * 3 ] , s ; unsigned pix ; u8 red , green , blue ; while ( count -- ) { pix = * buf ; s = curve [ ( pix >> systemGreenShift ) & 0x1f ] ; temp [ 3 ] = s * influence [ 3 ] ; temp [ 4 ] = s * influence [ 4 ] ; temp [ 5 ] = s * influence [ 5 ] ; s = curve [ ( pix >> systemRedShift ) & 0x1f ] ; temp [ 0 ] = s * influence [ 0 ] ; temp [ 1 ] = s * influence [ 1 ] ; temp [ 2 ] = s * influence [ 2 ] ; s = curve [ ( pix >> systemBlueShift ) & 0x1f ] ; temp [ 6 ] = s * influence [ 6 ] ; temp [ 7 ] = s * influence [ 7 ] ; temp [ 8 ] = s * influence [ 8 ] ; if ( temp [ 0 ] < temp [ 3 ] ) swap ( temp [ 0 ] , temp [ 3 ] ) ; if ( temp [ 0 ] < temp [ 6 ] ) swap ( temp [ 0 ] , temp [ 6 ] ) ; if ( temp [ 3 ] < temp [ 6 ] ) swap ( temp [ 3 ] , temp [ 6 ] ) ; temp [ 3 ] <<= 1 ; temp [ 0 ] <<= 2 ; temp [ 0 ] += temp [ 3 ] + temp [ 6 ] ; red = ( ( int ( temp [ 0 ] ) * 160 ) >> 14 ) + 32 ; if ( temp [ 2 ] < temp [ 5 ] ) swap ( temp [ 2 ] , temp [ 5 ] ) ; if ( temp [ 2 ] < temp [ 8 ] ) swap ( temp [ 2 ] , temp [ 8 ] ) ; if ( temp [ 5 ] < temp [ 8 ] ) swap ( temp [ 5 ] , temp [ 8 ] ) ; temp [ 5 ] <<= 1 ; temp [ 2 ] <<= 2 ; temp [ 2 ] += temp [ 5 ] + temp [ 8 ] ; blue = ( ( int ( temp [ 2 ] ) * 160 ) >> 14 ) + 32 ; if ( temp [ 1 ] < temp [ 4 ] ) swap ( temp [ 1 ] , temp [ 4 ] ) ; if ( temp [ 1 ] < temp [ 7 ] ) swap ( temp [ 1 ] , temp [ 7 ] ) ; if ( temp [ 4 ] < temp [ 7 ] ) swap ( temp [ 4 ] , temp [ 7 ] ) ; temp [ 4 ] <<= 1 ; temp [ 1 ] <<= 2 ; temp [ 1 ] += temp [ 4 ] + temp [ 7 ] ; green = ( ( int ( temp [ 1 ] ) * 160 ) >> 14 ) + 32 ; pix = red << ( systemRedShift - 3 ) ; pix += green << ( systemGreenShift - 3 ) ; pix += blue << ( systemBlueShift - 3 ) ; * buf ++ = pix ; } } void gbafilter_pad ( u8 * buf , int count ) { union { struct { u8 r ; u8 g ; u8 b ; u8 a ; } part ; unsigned whole ; } mask ; mask . whole = 0x1f << systemRedShift ; mask . whole += 0x1f << systemGreenShift ; mask . whole += 0x1f << systemBlueShift ; switch ( systemColorDepth ) { case 24 : while ( count -- ) { * buf ++ &= mask . part . r ; * buf ++ &= mask . part . g ; * buf ++ &= mask . part . b ; } break ; case 32 : while ( count -- ) { * ( ( u32 * ) buf ) &= mask . whole ; buf += 4 ; } } } </DOCUMENT>
<DOCUMENT_ID="fstudio/Phoenix/tree/master/test/Experimental/libcxx/test/std/strings/char.traits/char.traits.specializations/char.traits.specializations.char16_t/eof.pass.cpp"> # include < string > # include < cassert > int main ( ) { # ifndef _LIBCPP_HAS_NO_UNICODE_CHARS std :: char_traits < char16_t > :: int_type i = std :: char_traits < char16_t > :: eof ( ) ; # endif } </DOCUMENT>
<DOCUMENT_ID="murraymeehan/marsyas/tree/master/src/otherlibs/ANN/kd_pr_search.cpp"> # include " kd _ pr _ search . h " double ANNprEps ; int ANNprDim ; ANNpoint ANNprQ ; double ANNprMaxErr ; ANNpointArray ANNprPts ; ANNpr_queue * ANNprBoxPQ ; ANNmin_k * ANNprPointMK ; void ANNkd_tree :: annkPriSearch ( ANNpoint q , int k , ANNidxArray nn_idx , ANNdistArray dd , double eps ) { ANNprMaxErr = ANN_POW ( 1.0 + eps ) ; ANN_FLOP ( 2 ) ANNprDim = dim ; ANNprQ = q ; ANNprPts = pts ; ANNptsVisited = 0 ; ANNprPointMK = new ANNmin_k ( k ) ; ANNdist box_dist = annBoxDistance ( q , bnd_box_lo , bnd_box_hi , dim ) ; ANNprBoxPQ = new ANNpr_queue ( n_pts ) ; ANNprBoxPQ -> insert ( box_dist , root ) ; while ( ANNprBoxPQ -> non_empty ( ) && ( ! ( ANNmaxPtsVisited != 0 && ANNptsVisited > ANNmaxPtsVisited ) ) ) { ANNkd_ptr np ; ANNprBoxPQ -> extr_min ( box_dist , ( void * & ) np ) ; ANN_FLOP ( 2 ) if ( box_dist * ANNprMaxErr >= ANNprPointMK -> max_key ( ) ) break ; np -> ann_pri_search ( box_dist ) ; } for ( int i = 0 ; i < k ; i ++ ) { dd [ i ] = ANNprPointMK -> ith_smallest_key ( i ) ; nn_idx [ i ] = ANNprPointMK -> ith_smallest_info ( i ) ; } delete ANNprPointMK ; delete ANNprBoxPQ ; } void ANNkd_split :: ann_pri_search ( ANNdist box_dist ) { ANNdist new_dist ; ANNcoord cut_diff = ANNprQ [ cut_dim ] - cut_val ; if ( cut_diff < 0 ) { ANNcoord box_diff = cd_bnds [ ANN_LO ] - ANNprQ [ cut_dim ] ; if ( box_diff < 0 ) box_diff = 0 ; new_dist = ( ANNdist ) ANN_SUM ( box_dist , ANN_DIFF ( ANN_POW ( box_diff ) , ANN_POW ( cut_diff ) ) ) ; if ( child [ ANN_HI ] != KD_TRIVIAL ) ANNprBoxPQ -> insert ( new_dist , child [ ANN_HI ] ) ; child [ ANN_LO ] -> ann_pri_search ( box_dist ) ; } else { ANNcoord box_diff = ANNprQ [ cut_dim ] - cd_bnds [ ANN_HI ] ; if ( box_diff < 0 ) box_diff = 0 ; new_dist = ( ANNdist ) ANN_SUM ( box_dist , ANN_DIFF ( ANN_POW ( box_diff ) , ANN_POW ( cut_diff ) ) ) ; if ( child [ ANN_LO ] != KD_TRIVIAL ) ANNprBoxPQ -> insert ( new_dist , child [ ANN_LO ] ) ; child [ ANN_HI ] -> ann_pri_search ( box_dist ) ; } ANN_SPL ( 1 ) ANN_FLOP ( 8 ) } void ANNkd_leaf :: ann_pri_search ( ANNdist box_dist ) { register ANNdist dist ; register ANNcoord * pp ; register ANNcoord * qq ; register ANNdist min_dist ; register ANNcoord t ; register int d ; min_dist = ANNprPointMK -> max_key ( ) ; for ( int i = 0 ; i < n_pts ; i ++ ) { pp = ANNprPts [ bkt [ i ] ] ; qq = ANNprQ ; dist = 0 ; for ( d = 0 ; d < ANNprDim ; d ++ ) { ANN_COORD ( 1 ) ANN_FLOP ( 4 ) t = * ( qq ++ ) - * ( pp ++ ) ; if ( ( dist = ANN_SUM ( dist , ANN_POW ( t ) ) ) > min_dist ) { break ; } } if ( d >= ANNprDim && ( ANN_ALLOW_SELF_MATCH || dist != 0 ) ) { ANNprPointMK -> insert ( dist , bkt [ i ] ) ; min_dist = ANNprPointMK -> max_key ( ) ; } } ANN_LEAF ( 1 ) ANN_PTS ( n_pts ) ANNptsVisited += n_pts ; } </DOCUMENT>
<DOCUMENT_ID="makhdumi/robomongo/tree/master/src/third-party/mongodb/src/mongo/db/pipeline/accumulator.cpp"> # include " pch . h " # include " db / pipeline / accumulator . h " # include " db / jsobj . h " # include " util / mongoutils / str . h " namespace mongo { using namespace mongoutils ; void Accumulator :: addOperand ( const intrusive_ptr < Expression > & pExpression ) { uassert ( 15943 , str :: stream ( ) << " group ▁ accumulator ▁ " << getOpName ( ) << " ▁ only ▁ accepts ▁ one ▁ operand " , vpOperand . size ( ) < 1 ) ; ExpressionNary :: addOperand ( pExpression ) ; } Accumulator :: Accumulator ( ) : ExpressionNary ( ) { } void Accumulator :: opToBson ( BSONObjBuilder * pBuilder , StringData opName , StringData fieldName , bool requireExpression ) const { verify ( vpOperand . size ( ) == 1 ) ; BSONObjBuilder builder ; vpOperand [ 0 ] -> addToBsonObj ( & builder , opName , requireExpression ) ; pBuilder -> append ( fieldName , builder . done ( ) ) ; } void Accumulator :: addToBsonObj ( BSONObjBuilder * pBuilder , StringData fieldName , bool requireExpression ) const { opToBson ( pBuilder , getOpName ( ) , fieldName , requireExpression ) ; } void Accumulator :: addToBsonArray ( BSONArrayBuilder * pBuilder ) const { verify ( false ) ; } void agg_framework_reservedErrors ( ) { uassert ( 16030 , " reserved ▁ error " , false ) ; uassert ( 16031 , " reserved ▁ error " , false ) ; uassert ( 16032 , " reserved ▁ error " , false ) ; uassert ( 16033 , " reserved ▁ error " , false ) ; uassert ( 16036 , " reserved ▁ error " , false ) ; uassert ( 16037 , " reserved ▁ error " , false ) ; uassert ( 16038 , " reserved ▁ error " , false ) ; uassert ( 16039 , " reserved ▁ error " , false ) ; uassert ( 16040 , " reserved ▁ error " , false ) ; uassert ( 16041 , " reserved ▁ error " , false ) ; uassert ( 16042 , " reserved ▁ error " , false ) ; uassert ( 16043 , " reserved ▁ error " , false ) ; uassert ( 16044 , " reserved ▁ error " , false ) ; uassert ( 16045 , " reserved ▁ error " , false ) ; uassert ( 16046 , " reserved ▁ error " , false ) ; uassert ( 16047 , " reserved ▁ error " , false ) ; uassert ( 16048 , " reserved ▁ error " , false ) ; uassert ( 16049 , " reserved ▁ error " , false ) ; } } </DOCUMENT>
<DOCUMENT_ID="llvm-mirror/clang/tree/master/unittests/Frontend/CodeGenActionTest.cpp"> # include " clang / CodeGen / CodeGenAction . h " # include " clang / Basic / LangStandard . h " # include " clang / CodeGen / BackendUtil . h " # include " clang / Frontend / CompilerInstance . h " # include " clang / Lex / PreprocessorOptions . h " # include " gtest / gtest . h " using namespace llvm ; using namespace clang ; using namespace clang :: frontend ; namespace { class NullCodeGenAction : public CodeGenAction { public : NullCodeGenAction ( llvm :: LLVMContext * _VMContext = nullptr ) : CodeGenAction ( Backend_EmitMCNull , _VMContext ) { } void ExecuteAction ( ) override { CompilerInstance & CI = getCompilerInstance ( ) ; if ( ! CI . hasPreprocessor ( ) ) return ; if ( ! CI . hasSema ( ) ) CI . createSema ( getTranslationUnitKind ( ) , nullptr ) ; } } ; TEST ( CodeGenTest , TestNullCodeGen ) { auto Invocation = std :: make_shared < CompilerInvocation > ( ) ; Invocation -> getPreprocessorOpts ( ) . addRemappedFile ( " test . cc " , MemoryBuffer :: getMemBuffer ( " " ) . release ( ) ) ; Invocation -> getFrontendOpts ( ) . Inputs . push_back ( FrontendInputFile ( " test . cc " , Language :: CXX ) ) ; Invocation -> getFrontendOpts ( ) . ProgramAction = EmitLLVM ; Invocation -> getTargetOpts ( ) . Triple = " i386 - unknown - linux - gnu " ; CompilerInstance Compiler ; Compiler . setInvocation ( std :: move ( Invocation ) ) ; Compiler . createDiagnostics ( ) ; EXPECT_TRUE ( Compiler . hasDiagnostics ( ) ) ; std :: unique_ptr < FrontendAction > Act ( new NullCodeGenAction ) ; bool Success = Compiler . ExecuteAction ( * Act ) ; EXPECT_TRUE ( Success ) ; } } </DOCUMENT>
<DOCUMENT_ID="kyroskoh/phantomjs/tree/master/src/qt/qtwebkit/Source/WebCore/platform/network/soup/SoupURIUtils.cpp"> # include " config . h " # include " SoupURIUtils . h " # include < wtf / gobject / GOwnPtr . h > # include < libsoup / soup . h > namespace WebCore { KURL soupURIToKURL ( SoupURI * soupURI ) { GOwnPtr < gchar > urlString ( soup_uri_to_string ( soupURI , FALSE ) ) ; KURL url ( KURL ( ) , String :: fromUTF8 ( urlString . get ( ) ) ) ; if ( ! soupURI -> password ) return url ; url . setPass ( String :: fromUTF8 ( soupURI -> password ) ) ; return url ; } } </DOCUMENT>
<DOCUMENT_ID="quickhand/Prosit/tree/master/src/highlighter.cpp"> # include " highlighter . h " # include " block _ stats . h " # include " dictionary . h " # include " spell _ checker . h " # include " editor . h " # include < QAction > # include < QContextMenuEvent > # include < QEvent > # include < QMenu > # include < QTextEdit > # include < iostream > # include < QAbstractTextDocumentLayout > # include < QTextLayout > Highlighter :: Highlighter ( Editor * text , Dictionary * dictionary ) : QSyntaxHighlighter ( text -> document ( ) ) , m_dictionary ( dictionary ) , m_text ( text ) , m_enabled ( true ) , m_misspelled ( " # ff0000" ) { connect ( m_text , SIGNAL ( cursorPositionChanged ( ) ) , this , SLOT ( cursorPositionChanged ( ) ) ) ; m_text -> viewport ( ) -> installEventFilter ( this ) ; m_add_action = new QAction ( tr ( " Add " ) , this ) ; m_check_action = new QAction ( tr ( " Check ▁ Spelling . . . " ) , this ) ; } bool Highlighter :: enabled ( ) const { return m_enabled ; } QColor Highlighter :: misspelledColor ( ) const { return m_misspelled ; } void Highlighter :: setEnabled ( bool enabled ) { m_enabled = enabled ; rehighlight ( ) ; } void Highlighter :: setMisspelledColor ( const QColor & color ) { m_misspelled = color ; rehighlight ( ) ; } bool Highlighter :: eventFilter ( QObject * watched , QEvent * event ) { if ( watched != m_text -> viewport ( ) || event -> type ( ) != QEvent :: ContextMenu || ! m_enabled ) { return QSyntaxHighlighter :: eventFilter ( watched , event ) ; } else { QContextMenuEvent * context_event = static_cast < QContextMenuEvent * > ( event ) ; m_start_cursor = m_text -> cursorForPosition ( context_event -> pos ( ) ) ; QTextBlock block = m_start_cursor . block ( ) ; int cursor = m_start_cursor . position ( ) - block . position ( ) ; bool under_mouse = false ; QStringRef word ; QVector < QStringRef > words = static_cast < BlockStats * > ( block . userData ( ) ) -> misspelled ( ) ; for ( int i = 0 ; i < words . count ( ) ; ++ i ) { word = words . at ( i ) ; int delta = cursor - word . position ( ) ; if ( delta >= 0 && delta <= word . length ( ) ) { under_mouse = true ; break ; } } if ( ! under_mouse ) { return false ; } else { m_cursor = m_start_cursor ; m_cursor . setPosition ( word . position ( ) + block . position ( ) ) ; m_cursor . setPosition ( m_cursor . position ( ) + word . length ( ) , QTextCursor :: KeepAnchor ) ; m_word = m_cursor . selectedText ( ) ; m_text -> setTextCursor ( m_cursor ) ; QMenu * menu = new QMenu ; QStringList guesses = m_dictionary -> suggestions ( m_word ) ; if ( ! guesses . isEmpty ( ) ) { foreach ( const QString & guess , guesses ) { menu -> addAction ( guess ) ; } } else { QAction * none_action = menu -> addAction ( tr ( " ( No ▁ suggestions ▁ found ) " ) ) ; none_action -> setEnabled ( false ) ; } menu -> addSeparator ( ) ; menu -> addAction ( m_add_action ) ; menu -> addSeparator ( ) ; menu -> addAction ( m_check_action ) ; connect ( menu , SIGNAL ( triggered ( QAction * ) ) , this , SLOT ( suggestion ( QAction * ) ) ) ; menu -> exec ( context_event -> globalPos ( ) ) ; delete menu ; return true ; } } } void Highlighter :: highlightBlock ( const QString & text ) { QTextCharFormat hformat ; QTextBlockFormat blockformat = currentBlock ( ) . blockFormat ( ) ; if ( blockformat . hasProperty ( QTextFormat :: UserProperty ) ) { hformat . setProperty ( QTextFormat :: FontWeight , blockformat . property ( QTextFormat :: FontWeight ) ) ; hformat . setProperty ( QTextFormat :: FontItalic , blockformat . property ( QTextFormat :: FontItalic ) ) ; hformat . setProperty ( QTextFormat :: FontSizeAdjustment , blockformat . property ( QTextFormat :: FontSizeAdjustment ) ) ; setFormat ( 0 , text . length ( ) , hformat ) ; } if ( ! m_enabled ) { return ; } int cursor = m_text -> textCursor ( ) . position ( ) - currentBlock ( ) . position ( ) ; BlockStats * stats = static_cast < BlockStats * > ( currentBlockUserData ( ) ) ; if ( ! stats ) { stats = new BlockStats ( text , m_dictionary ) ; setCurrentBlockUserData ( stats ) ; } QTextCharFormat error ; error . setUnderlineColor ( m_misspelled ) ; error . setUnderlineStyle ( QTextCharFormat :: SpellCheckUnderline ) ; error . merge ( hformat ) ; QVector < QStringRef > words = stats -> misspelled ( ) ; for ( int i = 0 ; i < words . count ( ) ; ++ i ) { const QStringRef & word = words . at ( i ) ; int delta = cursor - word . position ( ) ; if ( delta < 0 || delta > word . length ( ) ) { setFormat ( word . position ( ) , word . length ( ) , error ) ; } } } void Highlighter :: cursorPositionChanged ( ) { QTextBlock current = m_text -> textCursor ( ) . block ( ) ; if ( m_current != current ) { if ( m_current . isValid ( ) && m_text -> document ( ) -> blockCount ( ) > m_current . blockNumber ( ) ) { rehighlightBlock ( m_current ) ; } m_current = current ; } rehighlightBlock ( m_current ) ; } void Highlighter :: suggestion ( QAction * action ) { if ( action == m_add_action ) { m_text -> setTextCursor ( m_start_cursor ) ; m_dictionary -> add ( m_word ) ; } else if ( action == m_check_action ) { m_text -> setTextCursor ( m_start_cursor ) ; SpellChecker :: checkDocument ( m_text ) ; } else { m_cursor . insertText ( action -> text ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="gilleslabelle/sagetv/tree/master/third_party/codecs/faac/common/mp4v2/atom_dmax.cpp"> # include " mp4common . h " MP4DmaxAtom :: MP4DmaxAtom ( ) : MP4Atom ( " dmax " ) { AddProperty ( new MP4Integer32Property ( " milliSecs " ) ) ; } </DOCUMENT>
<DOCUMENT_ID="braingl/braingl/tree/master/src/algos/sdthread.cpp"> # include " sdthread . h " # include " . . / data / datasets / datasetdwi . h " # include " . . / gui / gl / glfunctions . h " SDThread :: SDThread ( DatasetDWI * ds , int id ) : m_dataset ( ds ) , m_id ( id ) { m_dwi = ds -> getData ( ) ; m_bvals = ds -> getBvals ( ) ; m_bvecs = ds -> getBvecs ( ) ; int nx = ds -> properties ( " maingl " ) . get ( Fn :: Property :: D_NX ) . toInt ( ) ; int ny = ds -> properties ( " maingl " ) . get ( Fn :: Property :: D_NY ) . toInt ( ) ; int nz = ds -> properties ( " maingl " ) . get ( Fn :: Property :: D_NZ ) . toInt ( ) ; m_blockSize = nx * ny * nz ; } SDThread :: ~ SDThread ( ) { } void SDThread :: run ( ) { int numThreads = GLFunctions :: idealThreadCount ; int progressCounter = 0 ; for ( int i = m_id ; i < m_blockSize ; i += numThreads ) { calcSD ( i ) ; ++ progressCounter ; if ( progressCounter == 100 ) { emit ( progress ( ) ) ; progressCounter = 0 ; } } emit ( finished ( ) ) ; } ColumnVector SDThread :: calcSD ( int id ) { return ColumnVector ( 20 ) ; } </DOCUMENT>
<DOCUMENT_ID="CharlieMarshall/xbmc/tree/master/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagMicroDVD.cpp"> # include " DVDSubtitleTagMicroDVD . h " # include " DVDCodecs / Overlay / DVDOverlayText . h " # include " utils / StdString . h " # include " utils / StringUtils . h " void CDVDSubtitleTagMicroDVD :: ConvertLine ( CDVDOverlayText * pOverlay , const char * line , int len ) { CStdString strUTF8 ; strUTF8 . assign ( line , len ) ; m_flag [ FLAG_BOLD ] = 0 ; m_flag [ FLAG_ITALIC ] = 0 ; m_flag [ FLAG_COLOR ] = 0 ; int machine_status = 1 ; size_t pos = 0 ; while ( machine_status > 0 ) { if ( machine_status == 1 ) { if ( strUTF8 [ pos ] == ' { ' ) { size_t pos2 , pos3 ; if ( ( ( pos2 = strUTF8 . find ( ' : ' , pos ) ) != CStdString :: npos ) && ( ( pos3 = strUTF8 . find ( ' } ' , pos2 ) ) != CStdString :: npos ) ) { CStdString tagName = strUTF8 . substr ( pos + 1 , pos2 - pos - 1 ) ; CStdString tagValue = strUTF8 . substr ( pos2 + 1 , pos3 - pos2 - 1 ) ; StringUtils :: ToLower ( tagValue ) ; strUTF8 . erase ( pos , pos3 - pos + 1 ) ; if ( ( tagName == " Y " ) || ( tagName == " y " ) ) { if ( ( tagValue == " b " ) && ( m_flag [ FLAG_BOLD ] == 0 ) ) { m_flag [ FLAG_BOLD ] = ( tagName == " Y " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , " [ B ] " ) ; pos += 3 ; } else if ( ( tagValue == " i " ) && ( m_flag [ FLAG_ITALIC ] == 0 ) ) { m_flag [ FLAG_ITALIC ] = ( tagName == " Y " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , " [ I ] " ) ; pos += 3 ; } } else if ( ( tagName == " C " ) || ( tagName == " c " ) ) { if ( ( tagValue [ 0 ] == ' $ ' ) && ( tagValue . size ( ) == 7 ) ) { bool bHex = true ; for ( int i = 1 ; i < 7 ; i ++ ) { char temp = tagValue [ i ] ; if ( ! ( ( '0' <= temp && temp <= '9' ) || ( ' a ' <= temp && temp <= ' f ' ) || ( ' A ' <= temp && temp <= ' F ' ) ) ) { bHex = false ; break ; } } if ( bHex && ( m_flag [ FLAG_COLOR ] == 0 ) ) { CStdString tempColorTag = " [ COLOR ▁ " ; tempColorTag += " FF " ; tempColorTag += tagValue . substr ( 1 , 6 ) ; tempColorTag += " ] " ; m_flag [ FLAG_COLOR ] = ( tagName == " C " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , tempColorTag ) ; pos += tempColorTag . length ( ) ; } } } } else machine_status = 2 ; } else if ( strUTF8 [ pos ] == ' / ' ) { if ( m_flag [ FLAG_ITALIC ] == 0 ) { m_flag [ FLAG_ITALIC ] = TAG_ONE_LINE ; strUTF8 . replace ( pos , 1 , " [ I ] " ) ; pos += 3 ; } else strUTF8 . erase ( pos , 1 ) ; } else machine_status = 2 ; } else if ( machine_status == 2 ) { size_t pos4 ; if ( ( pos4 = strUTF8 . find ( ' | ' , pos ) ) != CStdString :: npos ) { pos = pos4 ; if ( m_flag [ FLAG_BOLD ] == TAG_ONE_LINE ) { m_flag [ FLAG_BOLD ] = 0 ; strUTF8 . insert ( pos , " [ / B ] " ) ; pos += 4 ; } if ( m_flag [ FLAG_ITALIC ] == TAG_ONE_LINE ) { m_flag [ FLAG_ITALIC ] = 0 ; strUTF8 . insert ( pos , " [ / I ] " ) ; pos += 4 ; } if ( m_flag [ FLAG_COLOR ] == TAG_ONE_LINE ) { m_flag [ FLAG_COLOR ] = 0 ; strUTF8 . insert ( pos , " [ / COLOR ] " ) ; pos += 8 ; } strUTF8 . replace ( pos , 1 , " [ CR ] " ) ; pos += 4 ; machine_status = 1 ; } else { if ( m_flag [ FLAG_BOLD ] != 0 ) strUTF8 . append ( " [ / B ] " ) ; if ( m_flag [ FLAG_ITALIC ] != 0 ) strUTF8 . append ( " [ / I ] " ) ; if ( m_flag [ FLAG_COLOR ] != 0 ) strUTF8 . append ( " [ / COLOR ] " ) ; machine_status = 0 ; } } } if ( strUTF8 . empty ( ) ) return ; if ( strUTF8 [ strUTF8 . size ( ) - 1 ] == ' \n ' ) strUTF8 . erase ( strUTF8 . size ( ) - 1 ) ; pOverlay -> AddElement ( new CDVDOverlayText :: CElementText ( strUTF8 . c_str ( ) ) ) ; } </DOCUMENT>
