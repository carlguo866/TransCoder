<DOCUMENT_ID="cesarmarinhorj/phantomjs/tree/master/src/qt/qtwebkit/Source/WTF/wtf/text/Base64.cpp"> # include " config . h " # include " Base64 . h " # include < limits . h > # include < wtf / StringExtras . h > # include < wtf / text / WTFString . h > namespace WTF { static const char base64EncMap [ 64 ] = { 0x41 , 0x42 , 0x43 , 0x44 , 0x45 , 0x46 , 0x47 , 0x48 , 0x49 , 0x4A , 0x4B , 0x4C , 0x4D , 0x4E , 0x4F , 0x50 , 0x51 , 0x52 , 0x53 , 0x54 , 0x55 , 0x56 , 0x57 , 0x58 , 0x59 , 0x5A , 0x61 , 0x62 , 0x63 , 0x64 , 0x65 , 0x66 , 0x67 , 0x68 , 0x69 , 0x6A , 0x6B , 0x6C , 0x6D , 0x6E , 0x6F , 0x70 , 0x71 , 0x72 , 0x73 , 0x74 , 0x75 , 0x76 , 0x77 , 0x78 , 0x79 , 0x7A , 0x30 , 0x31 , 0x32 , 0x33 , 0x34 , 0x35 , 0x36 , 0x37 , 0x38 , 0x39 , 0x2B , 0x2F } ; static const char base64DecMap [ 128 ] = { 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x3E , 0x00 , 0x00 , 0x00 , 0x3F , 0x34 , 0x35 , 0x36 , 0x37 , 0x38 , 0x39 , 0x3A , 0x3B , 0x3C , 0x3D , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 , 0x08 , 0x09 , 0x0A , 0x0B , 0x0C , 0x0D , 0x0E , 0x0F , 0x10 , 0x11 , 0x12 , 0x13 , 0x14 , 0x15 , 0x16 , 0x17 , 0x18 , 0x19 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x1A , 0x1B , 0x1C , 0x1D , 0x1E , 0x1F , 0x20 , 0x21 , 0x22 , 0x23 , 0x24 , 0x25 , 0x26 , 0x27 , 0x28 , 0x29 , 0x2A , 0x2B , 0x2C , 0x2D , 0x2E , 0x2F , 0x30 , 0x31 , 0x32 , 0x33 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 } ; String base64Encode ( const char * data , unsigned length , Base64EncodePolicy policy ) { Vector < char > result ; base64Encode ( data , length , result , policy ) ; return String ( result . data ( ) , result . size ( ) ) ; } void base64Encode ( const char * data , unsigned len , Vector < char > & out , Base64EncodePolicy policy ) { out . clear ( ) ; if ( ! len ) return ; const unsigned maxInputBufferSize = UINT_MAX / 77 * 76 / 4 * 3 - 2 ; if ( len > maxInputBufferSize ) return ; unsigned sidx = 0 ; unsigned didx = 0 ; unsigned outLength = ( ( len + 2 ) / 3 ) * 4 ; bool insertLFs = ( policy == Base64InsertLFs && outLength > 76 ) ; if ( insertLFs ) outLength += ( ( outLength - 1 ) / 76 ) ; int count = 0 ; out . grow ( outLength ) ; if ( len > 1 ) { while ( sidx < len - 2 ) { if ( insertLFs ) { if ( count && ! ( count % 76 ) ) out [ didx ++ ] = ' \n ' ; count += 4 ; } out [ didx ++ ] = base64EncMap [ ( data [ sidx ] >> 2 ) & 077 ] ; out [ didx ++ ] = base64EncMap [ ( ( data [ sidx + 1 ] >> 4 ) & 017 ) | ( ( data [ sidx ] << 4 ) & 077 ) ] ; out [ didx ++ ] = base64EncMap [ ( ( data [ sidx + 2 ] >> 6 ) & 003 ) | ( ( data [ sidx + 1 ] << 2 ) & 077 ) ] ; out [ didx ++ ] = base64EncMap [ data [ sidx + 2 ] & 077 ] ; sidx += 3 ; } } if ( sidx < len ) { if ( insertLFs && ( count > 0 ) && ! ( count % 76 ) ) out [ didx ++ ] = ' \n ' ; out [ didx ++ ] = base64EncMap [ ( data [ sidx ] >> 2 ) & 077 ] ; if ( sidx < len - 1 ) { out [ didx ++ ] = base64EncMap [ ( ( data [ sidx + 1 ] >> 4 ) & 017 ) | ( ( data [ sidx ] << 4 ) & 077 ) ] ; out [ didx ++ ] = base64EncMap [ ( data [ sidx + 1 ] << 2 ) & 077 ] ; } else out [ didx ++ ] = base64EncMap [ ( data [ sidx ] << 4 ) & 077 ] ; } while ( didx < out . size ( ) ) { out [ didx ] = ' = ' ; ++ didx ; } } bool base64Decode ( const Vector < char > & in , Vector < char > & out , Base64DecodePolicy policy ) { out . clear ( ) ; if ( in . size ( ) > UINT_MAX ) return false ; return base64Decode ( in . data ( ) , in . size ( ) , out , policy ) ; } template < typename T > static inline bool base64DecodeInternal ( const T * data , unsigned len , Vector < char > & out , Base64DecodePolicy policy ) { out . clear ( ) ; if ( ! len ) return true ; out . grow ( len ) ; bool sawEqualsSign = false ; unsigned outLength = 0 ; for ( unsigned idx = 0 ; idx < len ; ++ idx ) { unsigned ch = data [ idx ] ; if ( ch == ' = ' ) sawEqualsSign = true ; else if ( ( '0' <= ch && ch <= '9' ) || ( ' A ' <= ch && ch <= ' Z ' ) || ( ' a ' <= ch && ch <= ' z ' ) || ch == ' + ' || ch == ' / ' ) { if ( sawEqualsSign ) return false ; out [ outLength ] = base64DecMap [ ch ] ; ++ outLength ; } else if ( policy == Base64FailOnInvalidCharacter || ( policy == Base64IgnoreWhitespace && ! isSpaceOrNewline ( ch ) ) ) return false ; } if ( ! outLength ) return ! sawEqualsSign ; if ( ( outLength % 4 ) == 1 ) return false ; outLength -= ( outLength + 3 ) / 4 ; if ( ! outLength ) return false ; unsigned sidx = 0 ; unsigned didx = 0 ; if ( outLength > 1 ) { while ( didx < outLength - 2 ) { out [ didx ] = ( ( ( out [ sidx ] << 2 ) & 255 ) | ( ( out [ sidx + 1 ] >> 4 ) & 003 ) ) ; out [ didx + 1 ] = ( ( ( out [ sidx + 1 ] << 4 ) & 255 ) | ( ( out [ sidx + 2 ] >> 2 ) & 017 ) ) ; out [ didx + 2 ] = ( ( ( out [ sidx + 2 ] << 6 ) & 255 ) | ( out [ sidx + 3 ] & 077 ) ) ; sidx += 4 ; didx += 3 ; } } if ( didx < outLength ) out [ didx ] = ( ( ( out [ sidx ] << 2 ) & 255 ) | ( ( out [ sidx + 1 ] >> 4 ) & 003 ) ) ; if ( ++ didx < outLength ) out [ didx ] = ( ( ( out [ sidx + 1 ] << 4 ) & 255 ) | ( ( out [ sidx + 2 ] >> 2 ) & 017 ) ) ; if ( outLength < out . size ( ) ) out . shrink ( outLength ) ; return true ; } bool base64Decode ( const char * data , unsigned len , Vector < char > & out , Base64DecodePolicy policy ) { return base64DecodeInternal < char > ( data , len , out , policy ) ; } bool base64Decode ( const String & in , Vector < char > & out , Base64DecodePolicy policy ) { return base64DecodeInternal < UChar > ( in . characters ( ) , in . length ( ) , out , policy ) ; } } </DOCUMENT>
<DOCUMENT_ID="Rudi9719/curly-octo-barnacle/tree/master/TrinityCore/src/server/scripts/Northrend/Nexus/Nexus/boss_ormorok.cpp"> # include " ScriptMgr . h " # include " ScriptedCreature . h " # include " nexus . h " # include " SpellScript . h " enum Spells { SPELL_SPELL_REFLECTION = 47981 , SPELL_TRAMPLE = 48016 , SPELL_FRENZY = 48017 , SPELL_SUMMON_CRYSTALLINE_TANGLER = 61564 , SPELL_CRYSTAL_SPIKES = 47958 , } ; enum Yells { SAY_AGGRO = 1 , SAY_DEATH = 2 , SAY_REFLECT = 3 , SAY_CRYSTAL_SPIKES = 4 , SAY_KILL = 5 , SAY_FRENZY = 6 } ; enum Events { EVENT_CRYSTAL_SPIKES = 1 , EVENT_TRAMPLE = 2 , EVENT_SPELL_REFLECTION = 3 , EVENT_CRYSTALLINE_TANGLER = 4 , } ; class OrmorokTanglerPredicate { public : OrmorokTanglerPredicate ( Unit * unit ) : me ( unit ) { } bool operator ( ) ( WorldObject * object ) const { return object -> GetDistance2d ( me ) >= 5.0f ; } private : Unit * me ; } ; class boss_ormorok : public CreatureScript { public : boss_ormorok ( ) : CreatureScript ( " boss _ ormorok " ) { } struct boss_ormorokAI : public BossAI { boss_ormorokAI ( Creature * creature ) : BossAI ( creature , DATA_ORMOROK ) { Initialize ( ) ; } void Initialize ( ) { frenzy = false ; } void Reset ( ) override { BossAI :: Reset ( ) ; Initialize ( ) ; } void EnterCombat ( Unit * ) override { _EnterCombat ( ) ; events . ScheduleEvent ( EVENT_CRYSTAL_SPIKES , 12000 ) ; events . ScheduleEvent ( EVENT_TRAMPLE , 10000 ) ; events . ScheduleEvent ( EVENT_SPELL_REFLECTION , 30000 ) ; if ( IsHeroic ( ) ) events . ScheduleEvent ( EVENT_CRYSTALLINE_TANGLER , 17000 ) ; Talk ( SAY_AGGRO ) ; } void DamageTaken ( Unit * , uint32 & ) override { if ( ! frenzy && HealthBelowPct ( 25 ) ) { Talk ( SAY_FRENZY ) ; DoCast ( me , SPELL_FRENZY ) ; frenzy = true ; } } void JustDied ( Unit * ) override { _JustDied ( ) ; Talk ( SAY_DEATH ) ; } void KilledUnit ( Unit * who ) override { if ( who -> GetTypeId ( ) == TYPEID_PLAYER ) Talk ( SAY_KILL ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; while ( uint32 eventId = events . ExecuteEvent ( ) ) { switch ( eventId ) { case EVENT_TRAMPLE : DoCast ( me , SPELL_TRAMPLE ) ; events . ScheduleEvent ( EVENT_TRAMPLE , 10000 ) ; break ; case EVENT_SPELL_REFLECTION : Talk ( SAY_REFLECT ) ; DoCast ( me , SPELL_SPELL_REFLECTION ) ; events . ScheduleEvent ( EVENT_SPELL_REFLECTION , 30000 ) ; break ; case EVENT_CRYSTAL_SPIKES : Talk ( SAY_CRYSTAL_SPIKES ) ; DoCast ( SPELL_CRYSTAL_SPIKES ) ; events . ScheduleEvent ( EVENT_CRYSTAL_SPIKES , 12000 ) ; break ; case EVENT_CRYSTALLINE_TANGLER : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , OrmorokTanglerPredicate ( me ) ) ) DoCast ( target , SPELL_SUMMON_CRYSTALLINE_TANGLER ) ; events . ScheduleEvent ( EVENT_CRYSTALLINE_TANGLER , 17000 ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } private : bool frenzy ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetInstanceAI < boss_ormorokAI > ( creature ) ; } } ; enum CrystalSpikes { NPC_CRYSTAL_SPIKE_INITIAL = 27101 , NPC_CRYSTAL_SPIKE_TRIGGER = 27079 , DATA_COUNT = 1 , MAX_COUNT = 5 , SPELL_CRYSTAL_SPIKE_DAMAGE = 47944 , GO_CRYSTAL_SPIKE_TRAP = 188537 , } ; uint32 const crystalSpikeSummon [ 3 ] = { 47936 , 47942 , 47943 } ; class npc_crystal_spike_trigger : public CreatureScript { public : npc_crystal_spike_trigger ( ) : CreatureScript ( " npc _ crystal _ spike _ trigger " ) { } struct npc_crystal_spike_triggerAI : public ScriptedAI { npc_crystal_spike_triggerAI ( Creature * creature ) : ScriptedAI ( creature ) { _count = 0 ; _despawntimer = 0 ; } void IsSummonedBy ( Unit * owner ) override { switch ( me -> GetEntry ( ) ) { case NPC_CRYSTAL_SPIKE_INITIAL : _count = 0 ; me -> SetFacingToObject ( owner ) ; break ; case NPC_CRYSTAL_SPIKE_TRIGGER : if ( Creature * trigger = owner -> ToCreature ( ) ) _count = trigger -> AI ( ) -> GetData ( DATA_COUNT ) + 1 ; break ; default : _count = MAX_COUNT ; break ; } if ( me -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_TRIGGER ) if ( GameObject * trap = me -> FindNearestGameObject ( GO_CRYSTAL_SPIKE_TRAP , 1.0f ) ) trap -> Use ( me ) ; _despawntimer = 2000 ; } uint32 GetData ( uint32 type ) const override { return type == DATA_COUNT ? _count : 0 ; } void UpdateAI ( uint32 diff ) override { if ( _despawntimer <= diff ) { if ( me -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_TRIGGER ) if ( GameObject * trap = me -> FindNearestGameObject ( GO_CRYSTAL_SPIKE_TRAP , 1.0f ) ) trap -> Delete ( ) ; me -> DespawnOrUnsummon ( ) ; } else _despawntimer -= diff ; } private : uint32 _count ; uint32 _despawntimer ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return new npc_crystal_spike_triggerAI ( creature ) ; } } ; class spell_crystal_spike : public SpellScriptLoader { public : spell_crystal_spike ( ) : SpellScriptLoader ( " spell _ crystal _ spike " ) { } class spell_crystal_spike_AuraScript : public AuraScript { PrepareAuraScript ( spell_crystal_spike_AuraScript ) ; void HandlePeriodic ( AuraEffect const * ) { Unit * target = GetTarget ( ) ; if ( target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_INITIAL || target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_TRIGGER ) if ( Creature * trigger = target -> ToCreature ( ) ) { uint32 spell = target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_INITIAL ? crystalSpikeSummon [ 0 ] : crystalSpikeSummon [ urand ( 0 , 2 ) ] ; if ( trigger -> AI ( ) -> GetData ( DATA_COUNT ) < MAX_COUNT ) trigger -> CastSpell ( trigger , spell , true ) ; } } void Register ( ) override { OnEffectPeriodic += AuraEffectPeriodicFn ( spell_crystal_spike_AuraScript :: HandlePeriodic , EFFECT_0 , SPELL_AURA_PERIODIC_DUMMY ) ; } } ; AuraScript * GetAuraScript ( ) const override { return new spell_crystal_spike_AuraScript ( ) ; } } ; void AddSC_boss_ormorok ( ) { new boss_ormorok ( ) ; new npc_crystal_spike_trigger ( ) ; new spell_crystal_spike ( ) ; } </DOCUMENT>
<DOCUMENT_ID="arangodb/arangodb/tree/master/3rdParty/boost/1.71.0/libs/hana/example/chain.cpp"> # include < boost / hana / assert . hpp > # include < boost / hana / chain . hpp > # include < boost / hana / config . hpp > # include < boost / hana / equal . hpp > # include < boost / hana / optional . hpp > namespace hana = boost :: hana ; BOOST_HANA_CONSTEXPR_LAMBDA auto deref = [ ] ( auto x ) -> decltype ( * x ) { return * x ; } ; BOOST_HANA_CONSTEXPR_LAMBDA auto age = [ ] ( auto x ) -> decltype ( x . age ) { return x . age ; } ; BOOST_HANA_CONSTEXPR_LAMBDA auto f = [ ] ( auto x ) { return hana :: chain ( hana :: sfinae ( deref ) ( x ) , hana :: sfinae ( age ) ) ; } ; struct Person { unsigned int age ; } ; int main ( ) { constexpr Person john { 30 } ; BOOST_HANA_CONSTANT_CHECK ( f ( john ) == hana :: nothing ) ; BOOST_HANA_CONSTANT_CHECK ( f ( 1 ) == hana :: nothing ) ; BOOST_HANA_CONSTEXPR_CHECK ( f ( & john ) == hana :: just ( 30u ) ) ; } </DOCUMENT>
<DOCUMENT_ID="xhochy/arrow/tree/master/ruby/red-arrow/ext/arrow/raw-records.cpp"> # include " converters . hpp " namespace red_arrow { namespace { class RawRecordsBuilder : private Converter , public arrow :: ArrayVisitor { public : explicit RawRecordsBuilder ( VALUE records , int n_columns ) : Converter ( ) , records_ ( records ) , n_columns_ ( n_columns ) { } void build ( const arrow :: RecordBatch & record_batch ) { rb :: protect ( [ & ] { const auto n_rows = record_batch . num_rows ( ) ; for ( int64_t i = 0 ; i < n_rows ; ++ i ) { auto record = rb_ary_new_capa ( n_columns_ ) ; rb_ary_push ( records_ , record ) ; } row_offset_ = 0 ; for ( int i = 0 ; i < n_columns_ ; ++ i ) { const auto array = record_batch . column ( i ) . get ( ) ; column_index_ = i ; check_status ( array -> Accept ( this ) , " [ record - batch ] [ raw - records ] " ) ; } return Qnil ; } ) ; } void build ( const arrow :: Table & table ) { rb :: protect ( [ & ] { const auto n_rows = table . num_rows ( ) ; for ( int64_t i = 0 ; i < n_rows ; ++ i ) { auto record = rb_ary_new_capa ( n_columns_ ) ; rb_ary_push ( records_ , record ) ; } for ( int i = 0 ; i < n_columns_ ; ++ i ) { const auto & chunked_array = table . column ( i ) . get ( ) ; column_index_ = i ; row_offset_ = 0 ; for ( const auto array : chunked_array -> chunks ( ) ) { check_status ( array -> Accept ( this ) , " [ table ] [ raw - records ] " ) ; row_offset_ += array -> length ( ) ; } } return Qnil ; } ) ; } # define VISIT ( TYPE ) arrow :: Status Visit ( const arrow :: TYPE ## Array & array ) override { convert ( array ) ; return arrow :: Status :: OK ( ) ; } VISIT ( Null ) VISIT ( Boolean ) VISIT ( Int8 ) VISIT ( Int16 ) VISIT ( Int32 ) VISIT ( Int64 ) VISIT ( UInt8 ) VISIT ( UInt16 ) VISIT ( UInt32 ) VISIT ( UInt64 ) VISIT ( Float ) VISIT ( Double ) VISIT ( Binary ) VISIT ( String ) VISIT ( FixedSizeBinary ) VISIT ( Date32 ) VISIT ( Date64 ) VISIT ( Time32 ) VISIT ( Time64 ) VISIT ( Timestamp ) VISIT ( List ) VISIT ( Struct ) VISIT ( Union ) VISIT ( Dictionary ) VISIT ( Decimal128 ) # undef VISIT private : template < typename ArrayType > void convert ( const ArrayType & array ) { const auto n = array . length ( ) ; if ( array . null_count ( ) > 0 ) { for ( int64_t i = 0 , ii = row_offset_ ; i < n ; ++ i , ++ ii ) { auto value = Qnil ; if ( ! array . IsNull ( i ) ) { value = convert_value ( array , i ) ; } auto record = rb_ary_entry ( records_ , ii ) ; rb_ary_store ( record , column_index_ , value ) ; } } else { for ( int64_t i = 0 , ii = row_offset_ ; i < n ; ++ i , ++ ii ) { auto record = rb_ary_entry ( records_ , ii ) ; rb_ary_store ( record , column_index_ , convert_value ( array , i ) ) ; } } } VALUE records_ ; int column_index_ ; int64_t row_offset_ ; const int n_columns_ ; } ; } VALUE record_batch_raw_records ( VALUE rb_record_batch ) { auto garrow_record_batch = GARROW_RECORD_BATCH ( RVAL2GOBJ ( rb_record_batch ) ) ; auto record_batch = garrow_record_batch_get_raw ( garrow_record_batch ) . get ( ) ; const auto n_rows = record_batch -> num_rows ( ) ; const auto n_columns = record_batch -> num_columns ( ) ; auto records = rb_ary_new_capa ( n_rows ) ; try { RawRecordsBuilder builder ( records , n_columns ) ; builder . build ( * record_batch ) ; } catch ( rb :: State & state ) { state . jump ( ) ; } return records ; } VALUE table_raw_records ( VALUE rb_table ) { auto garrow_table = GARROW_TABLE ( RVAL2GOBJ ( rb_table ) ) ; auto table = garrow_table_get_raw ( garrow_table ) . get ( ) ; const auto n_rows = table -> num_rows ( ) ; const auto n_columns = table -> num_columns ( ) ; auto records = rb_ary_new_capa ( n_rows ) ; try { RawRecordsBuilder builder ( records , n_columns ) ; builder . build ( * table ) ; } catch ( rb :: State & state ) { state . jump ( ) ; } return records ; } } </DOCUMENT>
<DOCUMENT_ID="wakashige/TrinityCore/tree/master/src/server/scripts/EasternKingdoms/zone_arathi_highlands.cpp"> # include " ScriptMgr . h " # include " ScriptedCreature . h " # include " ScriptedEscortAI . h " # include " Player . h " enum ProfessorPhizzlethorpe { SAY_PROGRESS_1 = 0 , SAY_PROGRESS_2 = 1 , SAY_PROGRESS_3 = 2 , EMOTE_PROGRESS_4 = 3 , SAY_AGGRO = 4 , SAY_PROGRESS_5 = 5 , SAY_PROGRESS_6 = 6 , SAY_PROGRESS_7 = 7 , EMOTE_PROGRESS_8 = 8 , SAY_PROGRESS_9 = 9 , EVENT_SAY_3 = 1 , EVENT_SAY_6 = 2 , EVENT_SAY_8 = 3 , QUEST_SUNKEN_TREASURE = 665 , QUEST_GOGGLE_BOGGLE = 26050 , NPC_VENGEFUL_SURGE = 2776 , FACTION_SUNKEN_TREASURE = 113 } ; class npc_professor_phizzlethorpe : public CreatureScript { public : npc_professor_phizzlethorpe ( ) : CreatureScript ( " npc _ professor _ phizzlethorpe " ) { } struct npc_professor_phizzlethorpeAI : public npc_escortAI { npc_professor_phizzlethorpeAI ( Creature * creature ) : npc_escortAI ( creature ) { } void WaypointReached ( uint32 waypointId ) override { Player * player = GetPlayerForEscort ( ) ; if ( ! player ) return ; switch ( waypointId ) { case 6 : Talk ( SAY_PROGRESS_2 , player ) ; events . ScheduleEvent ( EVENT_SAY_3 , 3000 ) ; break ; case 8 : Talk ( EMOTE_PROGRESS_4 ) ; me -> SummonCreature ( NPC_VENGEFUL_SURGE , - 2065.505f , - 2136.88f , 22.20362f , 1.0f , TEMPSUMMON_CORPSE_DESPAWN , 0 ) ; me -> SummonCreature ( NPC_VENGEFUL_SURGE , - 2059.249f , - 2134.88f , 21.51582f , 1.0f , TEMPSUMMON_CORPSE_DESPAWN , 0 ) ; break ; case 11 : Talk ( SAY_PROGRESS_5 , player ) ; events . ScheduleEvent ( EVENT_SAY_6 , 11000 ) ; break ; case 17 : Talk ( SAY_PROGRESS_7 , player ) ; events . ScheduleEvent ( EVENT_SAY_8 , 6000 ) ; break ; } } void JustSummoned ( Creature * summoned ) override { summoned -> AI ( ) -> AttackStart ( me ) ; } void EnterCombat ( Unit * ) override { Talk ( SAY_AGGRO ) ; } void sQuestAccept ( Player * player , Quest const * quest ) override { if ( quest -> GetQuestId ( ) == QUEST_SUNKEN_TREASURE ) { Talk ( SAY_PROGRESS_1 , player ) ; npc_escortAI :: Start ( false , false , player -> GetGUID ( ) , quest ) ; me -> setFaction ( FACTION_SUNKEN_TREASURE ) ; } } void UpdateAI ( uint32 diff ) override { Player * player = GetPlayerForEscort ( ) ; if ( ! player ) return ; events . Update ( diff ) ; while ( uint32 event = events . ExecuteEvent ( ) ) { switch ( event ) { case EVENT_SAY_3 : Talk ( SAY_PROGRESS_3 , player ) ; break ; case EVENT_SAY_6 : Talk ( SAY_PROGRESS_6 , player ) ; SetRun ( ) ; break ; case EVENT_SAY_8 : Talk ( EMOTE_PROGRESS_8 ) ; Talk ( SAY_PROGRESS_9 , player ) ; player -> GroupEventHappens ( QUEST_GOGGLE_BOGGLE , me ) ; break ; } } npc_escortAI :: UpdateAI ( diff ) ; } EventMap events ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return new npc_professor_phizzlethorpeAI ( creature ) ; } } ; void AddSC_arathi_highlands ( ) { new npc_professor_phizzlethorpe ( ) ; } </DOCUMENT>
<DOCUMENT_ID="mapmapteam/mapmap/tree/master/src/gui/contrib/qtpropertybrowser/src/qtpropertybrowserutils.cpp"> # include " qtpropertybrowserutils _ p . h " # include < QApplication > # include < QPainter > # include < QHBoxLayout > # include < QMouseEvent > # include < QCheckBox > # include < QLineEdit > # include < QMenu > # include < QStyleOption > # if QT_VERSION >= 0x040400 QT_BEGIN_NAMESPACE # endif QtCursorDatabase :: QtCursorDatabase ( ) { appendCursor ( Qt :: ArrowCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Arrow " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - arrow . png " ) ) ) ; appendCursor ( Qt :: UpArrowCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Up ▁ Arrow " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - uparrow . png " ) ) ) ; appendCursor ( Qt :: CrossCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Cross " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - cross . png " ) ) ) ; appendCursor ( Qt :: WaitCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Wait " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - wait . png " ) ) ) ; appendCursor ( Qt :: IBeamCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " IBeam " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - ibeam . png " ) ) ) ; appendCursor ( Qt :: SizeVerCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Vertical " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizev . png " ) ) ) ; appendCursor ( Qt :: SizeHorCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Horizontal " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeh . png " ) ) ) ; appendCursor ( Qt :: SizeFDiagCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Backslash " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizef . png " ) ) ) ; appendCursor ( Qt :: SizeBDiagCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Slash " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeb . png " ) ) ) ; appendCursor ( Qt :: SizeAllCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ All " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeall . png " ) ) ) ; appendCursor ( Qt :: BlankCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Blank " ) , QIcon ( ) ) ; appendCursor ( Qt :: SplitVCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Split ▁ Vertical " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - vsplit . png " ) ) ) ; appendCursor ( Qt :: SplitHCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Split ▁ Horizontal " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - hsplit . png " ) ) ) ; appendCursor ( Qt :: PointingHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Pointing ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - hand . png " ) ) ) ; appendCursor ( Qt :: ForbiddenCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Forbidden " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - forbidden . png " ) ) ) ; appendCursor ( Qt :: OpenHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Open ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - openhand . png " ) ) ) ; appendCursor ( Qt :: ClosedHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Closed ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - closedhand . png " ) ) ) ; appendCursor ( Qt :: WhatsThisCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " What ' s ▁ This " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - whatsthis . png " ) ) ) ; appendCursor ( Qt :: BusyCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Busy " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - busy . png " ) ) ) ; } void QtCursorDatabase :: clear ( ) { m_cursorNames . clear ( ) ; m_cursorIcons . clear ( ) ; m_valueToCursorShape . clear ( ) ; m_cursorShapeToValue . clear ( ) ; } void QtCursorDatabase :: appendCursor ( Qt :: CursorShape shape , const QString & name , const QIcon & icon ) { if ( m_cursorShapeToValue . contains ( shape ) ) return ; const int value = m_cursorNames . count ( ) ; m_cursorNames . append ( name ) ; m_cursorIcons . insert ( value , icon ) ; m_valueToCursorShape . insert ( value , shape ) ; m_cursorShapeToValue . insert ( shape , value ) ; } QStringList QtCursorDatabase :: cursorShapeNames ( ) const { return m_cursorNames ; } QMap < int , QIcon > QtCursorDatabase :: cursorShapeIcons ( ) const { return m_cursorIcons ; } QString QtCursorDatabase :: cursorToShapeName ( const QCursor & cursor ) const { int val = cursorToValue ( cursor ) ; if ( val >= 0 ) return m_cursorNames . at ( val ) ; return QString ( ) ; } QIcon QtCursorDatabase :: cursorToShapeIcon ( const QCursor & cursor ) const { int val = cursorToValue ( cursor ) ; return m_cursorIcons . value ( val ) ; } int QtCursorDatabase :: cursorToValue ( const QCursor & cursor ) const { # ifndef QT_NO_CURSOR Qt :: CursorShape shape = cursor . shape ( ) ; if ( m_cursorShapeToValue . contains ( shape ) ) return m_cursorShapeToValue [ shape ] ; # endif return - 1 ; } # ifndef QT_NO_CURSOR QCursor QtCursorDatabase :: valueToCursor ( int value ) const { if ( m_valueToCursorShape . contains ( value ) ) return QCursor ( m_valueToCursorShape [ value ] ) ; return QCursor ( ) ; } # endif QPixmap QtPropertyBrowserUtils :: brushValuePixmap ( const QBrush & b ) { QImage img ( 16 , 16 , QImage :: Format_ARGB32_Premultiplied ) ; img . fill ( 0 ) ; QPainter painter ( & img ) ; painter . setCompositionMode ( QPainter :: CompositionMode_Source ) ; painter . fillRect ( 0 , 0 , img . width ( ) , img . height ( ) , b ) ; QColor color = b . color ( ) ; if ( color . alpha ( ) != 255 ) { QBrush opaqueBrush = b ; color . setAlpha ( 255 ) ; opaqueBrush . setColor ( color ) ; painter . fillRect ( img . width ( ) / 4 , img . height ( ) / 4 , img . width ( ) / 2 , img . height ( ) / 2 , opaqueBrush ) ; } painter . end ( ) ; return QPixmap :: fromImage ( img ) ; } QIcon QtPropertyBrowserUtils :: brushValueIcon ( const QBrush & b ) { return QIcon ( brushValuePixmap ( b ) ) ; } QString QtPropertyBrowserUtils :: colorValueText ( const QColor & c ) { return QCoreApplication :: translate ( " QtPropertyBrowserUtils " , " [ %1 , ▁ % 2 , ▁ % 3 ] ▁ ( %4 ) " ) . arg ( c . red ( ) ) . arg ( c . green ( ) ) . arg ( c . blue ( ) ) . arg ( c . alpha ( ) ) ; } QPixmap QtPropertyBrowserUtils :: fontValuePixmap ( const QFont & font ) { QFont f = font ; QImage img ( 16 , 16 , QImage :: Format_ARGB32_Premultiplied ) ; img . fill ( 0 ) ; QPainter p ( & img ) ; p . setRenderHint ( QPainter :: TextAntialiasing , true ) ; p . setRenderHint ( QPainter :: Antialiasing , true ) ; f . setPointSize ( 13 ) ; p . setFont ( f ) ; QTextOption t ; t . setAlignment ( Qt :: AlignCenter ) ; p . drawText ( QRect ( 0 , 0 , 16 , 16 ) , QString ( QLatin1Char ( ' A ' ) ) , t ) ; return QPixmap :: fromImage ( img ) ; } QIcon QtPropertyBrowserUtils :: fontValueIcon ( const QFont & f ) { return QIcon ( fontValuePixmap ( f ) ) ; } QString QtPropertyBrowserUtils :: fontValueText ( const QFont & f ) { return QCoreApplication :: translate ( " QtPropertyBrowserUtils " , " [ %1 , ▁ % 2 ] " ) . arg ( f . family ( ) ) . arg ( f . pointSize ( ) ) ; } QtBoolEdit :: QtBoolEdit ( QWidget * parent ) : QWidget ( parent ) , m_checkBox ( new QCheckBox ( this ) ) , m_textVisible ( true ) { QHBoxLayout * lt = new QHBoxLayout ; if ( QApplication :: layoutDirection ( ) == Qt :: LeftToRight ) lt -> setContentsMargins ( 4 , 0 , 0 , 0 ) ; else lt -> setContentsMargins ( 0 , 0 , 4 , 0 ) ; lt -> addWidget ( m_checkBox ) ; setLayout ( lt ) ; connect ( m_checkBox , SIGNAL ( toggled ( bool ) ) , this , SIGNAL ( toggled ( bool ) ) ) ; setFocusProxy ( m_checkBox ) ; m_checkBox -> setText ( tr ( " True " ) ) ; } void QtBoolEdit :: setTextVisible ( bool textVisible ) { if ( m_textVisible == textVisible ) return ; m_textVisible = textVisible ; if ( m_textVisible ) m_checkBox -> setText ( isChecked ( ) ? tr ( " True " ) : tr ( " False " ) ) ; else m_checkBox -> setText ( QString ( ) ) ; } Qt :: CheckState QtBoolEdit :: checkState ( ) const { return m_checkBox -> checkState ( ) ; } void QtBoolEdit :: setCheckState ( Qt :: CheckState state ) { m_checkBox -> setCheckState ( state ) ; } bool QtBoolEdit :: isChecked ( ) const { return m_checkBox -> isChecked ( ) ; } void QtBoolEdit :: setChecked ( bool c ) { m_checkBox -> setChecked ( c ) ; if ( ! m_textVisible ) return ; m_checkBox -> setText ( isChecked ( ) ? tr ( " True " ) : tr ( " False " ) ) ; } bool QtBoolEdit :: blockCheckBoxSignals ( bool block ) { return m_checkBox -> blockSignals ( block ) ; } void QtBoolEdit :: mousePressEvent ( QMouseEvent * event ) { if ( event -> buttons ( ) == Qt :: LeftButton ) { m_checkBox -> click ( ) ; event -> accept ( ) ; } else { QWidget :: mousePressEvent ( event ) ; } } void QtBoolEdit :: paintEvent ( QPaintEvent * ) { QStyleOption opt ; opt . init ( this ) ; QPainter p ( this ) ; style ( ) -> drawPrimitive ( QStyle :: PE_Widget , & opt , & p , this ) ; } QtKeySequenceEdit :: QtKeySequenceEdit ( QWidget * parent ) : QWidget ( parent ) , m_num ( 0 ) , m_lineEdit ( new QLineEdit ( this ) ) { QHBoxLayout * layout = new QHBoxLayout ( this ) ; layout -> addWidget ( m_lineEdit ) ; layout -> setMargin ( 0 ) ; m_lineEdit -> installEventFilter ( this ) ; m_lineEdit -> setReadOnly ( true ) ; m_lineEdit -> setFocusProxy ( this ) ; setFocusPolicy ( m_lineEdit -> focusPolicy ( ) ) ; setAttribute ( Qt :: WA_InputMethodEnabled ) ; } bool QtKeySequenceEdit :: eventFilter ( QObject * o , QEvent * e ) { if ( o == m_lineEdit && e -> type ( ) == QEvent :: ContextMenu ) { QContextMenuEvent * c = static_cast < QContextMenuEvent * > ( e ) ; QMenu * menu = m_lineEdit -> createStandardContextMenu ( ) ; const QList < QAction * > actions = menu -> actions ( ) ; QListIterator < QAction * > itAction ( actions ) ; while ( itAction . hasNext ( ) ) { QAction * action = itAction . next ( ) ; action -> setShortcut ( QKeySequence ( ) ) ; QString actionString = action -> text ( ) ; const int pos = actionString . lastIndexOf ( QLatin1Char ( ' \t ' ) ) ; if ( pos > 0 ) actionString . remove ( pos , actionString . length ( ) - pos ) ; action -> setText ( actionString ) ; } QAction * actionBefore = 0 ; if ( actions . count ( ) > 0 ) actionBefore = actions [ 0 ] ; QAction * clearAction = new QAction ( tr ( " Clear ▁ Shortcut " ) , menu ) ; menu -> insertAction ( actionBefore , clearAction ) ; menu -> insertSeparator ( actionBefore ) ; clearAction -> setEnabled ( ! m_keySequence . isEmpty ( ) ) ; connect ( clearAction , SIGNAL ( triggered ( ) ) , this , SLOT ( slotClearShortcut ( ) ) ) ; menu -> exec ( c -> globalPos ( ) ) ; delete menu ; e -> accept ( ) ; return true ; } return QWidget :: eventFilter ( o , e ) ; } void QtKeySequenceEdit :: slotClearShortcut ( ) { if ( m_keySequence . isEmpty ( ) ) return ; setKeySequence ( QKeySequence ( ) ) ; emit keySequenceChanged ( m_keySequence ) ; } void QtKeySequenceEdit :: handleKeyEvent ( QKeyEvent * e ) { int nextKey = e -> key ( ) ; if ( nextKey == Qt :: Key_Control || nextKey == Qt :: Key_Shift || nextKey == Qt :: Key_Meta || nextKey == Qt :: Key_Alt || nextKey == Qt :: Key_Super_L || nextKey == Qt :: Key_AltGr ) return ; nextKey |= translateModifiers ( e -> modifiers ( ) , e -> text ( ) ) ; int k0 = m_keySequence [ 0 ] ; int k1 = m_keySequence [ 1 ] ; int k2 = m_keySequence [ 2 ] ; int k3 = m_keySequence [ 3 ] ; switch ( m_num ) { case 0 : k0 = nextKey ; k1 = 0 ; k2 = 0 ; k3 = 0 ; break ; case 1 : k1 = nextKey ; k2 = 0 ; k3 = 0 ; break ; case 2 : k2 = nextKey ; k3 = 0 ; break ; case 3 : k3 = nextKey ; break ; default : break ; } ++ m_num ; if ( m_num > 3 ) m_num = 0 ; m_keySequence = QKeySequence ( k0 , k1 , k2 , k3 ) ; m_lineEdit -> setText ( m_keySequence . toString ( QKeySequence :: NativeText ) ) ; e -> accept ( ) ; emit keySequenceChanged ( m_keySequence ) ; } void QtKeySequenceEdit :: setKeySequence ( const QKeySequence & sequence ) { if ( sequence == m_keySequence ) return ; m_num = 0 ; m_keySequence = sequence ; m_lineEdit -> setText ( m_keySequence . toString ( QKeySequence :: NativeText ) ) ; } QKeySequence QtKeySequenceEdit :: keySequence ( ) const { return m_keySequence ; } int QtKeySequenceEdit :: translateModifiers ( Qt :: KeyboardModifiers state , const QString & text ) const { int result = 0 ; if ( ( state & Qt :: ShiftModifier ) && ( text . size ( ) == 0 || ! text . at ( 0 ) . isPrint ( ) || text . at ( 0 ) . isLetter ( ) || text . at ( 0 ) . isSpace ( ) ) ) result |= Qt :: SHIFT ; if ( state & Qt :: ControlModifier ) result |= Qt :: CTRL ; if ( state & Qt :: MetaModifier ) result |= Qt :: META ; if ( state & Qt :: AltModifier ) result |= Qt :: ALT ; return result ; } void QtKeySequenceEdit :: focusInEvent ( QFocusEvent * e ) { m_lineEdit -> event ( e ) ; m_lineEdit -> selectAll ( ) ; QWidget :: focusInEvent ( e ) ; } void QtKeySequenceEdit :: focusOutEvent ( QFocusEvent * e ) { m_num = 0 ; m_lineEdit -> event ( e ) ; QWidget :: focusOutEvent ( e ) ; } void QtKeySequenceEdit :: keyPressEvent ( QKeyEvent * e ) { handleKeyEvent ( e ) ; e -> accept ( ) ; } void QtKeySequenceEdit :: keyReleaseEvent ( QKeyEvent * e ) { m_lineEdit -> event ( e ) ; } void QtKeySequenceEdit :: paintEvent ( QPaintEvent * ) { QStyleOption opt ; opt . init ( this ) ; QPainter p ( this ) ; style ( ) -> drawPrimitive ( QStyle :: PE_Widget , & opt , & p , this ) ; } bool QtKeySequenceEdit :: event ( QEvent * e ) { if ( e -> type ( ) == QEvent :: Shortcut || e -> type ( ) == QEvent :: ShortcutOverride || e -> type ( ) == QEvent :: KeyRelease ) { e -> accept ( ) ; return true ; } return QWidget :: event ( e ) ; } # if QT_VERSION >= 0x040400 QT_END_NAMESPACE # endif </DOCUMENT>
<DOCUMENT_ID="dgrat/ANNetGPGPU/tree/master/examples/designer/ANNetDesigner.cpp"> # include < QApplication > # include " gui / QMainWindow . h " int main ( int argc , char * argv [ ] ) { QApplication a ( argc , argv ) ; MainWindow w ; w . show ( ) ; return a . exec ( ) ; } </DOCUMENT>
<DOCUMENT_ID="esqudo/cymrucoin/tree/master/src/qt/aboutdialog.cpp"> # include " aboutdialog . h " # include " ui _ aboutdialog . h " # include " clientmodel . h " # include " clientversion . h " const int ABOUTDIALOG_COPYRIGHT_YEAR = 2014 ; AboutDialog :: AboutDialog ( QWidget * parent ) : QDialog ( parent ) , ui ( new Ui :: AboutDialog ) { ui -> setupUi ( this ) ; ui -> copyrightLabel -> setText ( tr ( " Copyright " ) + QString ( " ▁ & copy ; ▁ 2009 - % 1 ▁ " ) . arg ( COPYRIGHT_YEAR ) + tr ( " The ▁ Bitcoin ▁ developers " ) + QString ( " < br > " ) + tr ( " Copyright " ) + QString ( " ▁ & copy ; ▁ " ) + tr ( " % 1 ▁ StartJOIN " ) . arg ( ABOUTDIALOG_COPYRIGHT_YEAR ) ) ; } void AboutDialog :: setModel ( ClientModel * model ) { if ( model ) { ui -> versionLabel -> setText ( model -> formatFullVersion ( ) ) ; } } AboutDialog :: ~ AboutDialog ( ) { delete ui ; } void AboutDialog :: on_buttonBox_accepted ( ) { close ( ) ; } </DOCUMENT>
<DOCUMENT_ID="miniwebkit/src/tree/master/WebCore/xml/XMLSerializer.cpp"> # include " config . h " # include " XMLSerializer . h " # include " Document . h " # include " ExceptionCode . h " # include " markup . h " namespace WebCore { String XMLSerializer :: serializeToString ( Node * node , ExceptionCode & ec ) { if ( ! node ) return String ( ) ; if ( ! node -> document ( ) ) { ASSERT ( node -> nodeType ( ) == Node :: DOCUMENT_TYPE_NODE ) ; ec = INVALID_ACCESS_ERR ; return String ( ) ; } return createMarkup ( node ) ; } } </DOCUMENT>
<DOCUMENT_ID="slitvinov/lammps-sph-multiphase/tree/master/src/ASPHERE/compute_temp_asphere.cpp"> # include " mpi . h " # include " string . h " # include " compute _ temp _ asphere . h " # include " math _ extra . h " # include " atom . h " # include " atom _ vec _ ellipsoid . h " # include " update . h " # include " force . h " # include " domain . h " # include " modify . h " # include " group . h " # include " memory . h " # include " error . h " using namespace LAMMPS_NS ; enum { ROTATE , ALL } ; # define INERTIA 0.2 ComputeTempAsphere :: ComputeTempAsphere ( LAMMPS * lmp , int narg , char * * arg ) : Compute ( lmp , narg , arg ) { if ( narg < 3 ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; scalar_flag = vector_flag = 1 ; size_vector = 6 ; extscalar = 0 ; extvector = 1 ; tempflag = 1 ; tempbias = 0 ; id_bias = NULL ; mode = ALL ; int iarg = 3 ; while ( iarg < narg ) { if ( strcmp ( arg [ iarg ] , " bias " ) == 0 ) { if ( iarg + 2 > narg ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; tempbias = 1 ; int n = strlen ( arg [ iarg + 1 ] ) + 1 ; id_bias = new char [ n ] ; strcpy ( id_bias , arg [ iarg + 1 ] ) ; iarg += 2 ; } else if ( strcmp ( arg [ iarg ] , " dof " ) == 0 ) { if ( iarg + 2 > narg ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; if ( strcmp ( arg [ iarg + 1 ] , " rotate " ) == 0 ) mode = ROTATE ; else if ( strcmp ( arg [ iarg + 1 ] , " all " ) == 0 ) mode = ALL ; else error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; iarg += 2 ; } else error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; } vector = new double [ 6 ] ; } ComputeTempAsphere :: ~ ComputeTempAsphere ( ) { delete [ ] id_bias ; delete [ ] vector ; } void ComputeTempAsphere :: init ( ) { avec = ( AtomVecEllipsoid * ) atom -> style_match ( " ellipsoid " ) ; if ( ! avec ) error -> all ( FLERR , " Compute ▁ temp / asphere ▁ requires ▁ atom ▁ style ▁ ellipsoid " ) ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) if ( ellipsoid [ i ] < 0 ) error -> one ( FLERR , " Compute ▁ temp / asphere ▁ requires ▁ extended ▁ particles " ) ; if ( tempbias ) { int i = modify -> find_compute ( id_bias ) ; if ( i < 0 ) error -> all ( FLERR , " Could ▁ not ▁ find ▁ compute ▁ ID ▁ for ▁ temperature ▁ bias " ) ; tbias = modify -> compute [ i ] ; if ( tbias -> tempflag == 0 ) error -> all ( FLERR , " Bias ▁ compute ▁ does ▁ not ▁ calculate ▁ temperature " ) ; if ( tbias -> tempbias == 0 ) error -> all ( FLERR , " Bias ▁ compute ▁ does ▁ not ▁ calculate ▁ a ▁ velocity ▁ bias " ) ; if ( tbias -> igroup != igroup ) error -> all ( FLERR , " Bias ▁ compute ▁ group ▁ does ▁ not ▁ match ▁ compute ▁ group " ) ; tbias -> init ( ) ; tbias -> setup ( ) ; if ( strcmp ( tbias -> style , " temp / region " ) == 0 ) tempbias = 2 ; else tempbias = 1 ; } } void ComputeTempAsphere :: setup ( ) { fix_dof = - 1 ; dof_compute ( ) ; } void ComputeTempAsphere :: dof_compute ( ) { if ( fix_dof ) adjust_dof_fix ( ) ; double natoms = group -> count ( igroup ) ; int nper ; if ( domain -> dimension == 3 ) { if ( mode == ALL ) nper = 6 ; else nper = 3 ; } else { if ( mode == ALL ) nper = 3 ; else nper = 1 ; } dof = nper * natoms ; if ( tempbias == 1 ) { if ( mode == ALL ) dof -= tbias -> dof_remove ( - 1 ) * natoms ; } else if ( tempbias == 2 ) { int * mask = atom -> mask ; int nlocal = atom -> nlocal ; tbias -> dof_remove_pre ( ) ; int count = 0 ; for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) if ( tbias -> dof_remove ( i ) ) count ++ ; int count_all ; MPI_Allreduce ( & count , & count_all , 1 , MPI_INT , MPI_SUM , world ) ; dof -= nper * count_all ; } dof -= extra_dof + fix_dof ; if ( dof > 0 ) tfactor = force -> mvv2e / ( dof * force -> boltz ) ; else tfactor = 0.0 ; } double ComputeTempAsphere :: compute_scalar ( ) { invoked_scalar = update -> ntimestep ; if ( tempbias ) { if ( tbias -> invoked_scalar != update -> ntimestep ) tbias -> compute_scalar ( ) ; tbias -> remove_bias_all ( ) ; } AtomVecEllipsoid :: Bonus * bonus = avec -> bonus ; double * * v = atom -> v ; double * * angmom = atom -> angmom ; double * rmass = atom -> rmass ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; double * shape , * quat ; double wbody [ 3 ] , inertia [ 3 ] ; double rot [ 3 ] [ 3 ] ; double t = 0.0 ; if ( mode == ALL ) { for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { t += ( v [ i ] [ 0 ] * v [ i ] [ 0 ] + v [ i ] [ 1 ] * v [ i ] [ 1 ] + v [ i ] [ 2 ] * v [ i ] [ 2 ] ) * rmass [ i ] ; shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * rmass [ i ] * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] + inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] + inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; } } else { for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * rmass [ i ] * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] + inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] + inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; } } if ( tempbias ) tbias -> restore_bias_all ( ) ; MPI_Allreduce ( & t , & scalar , 1 , MPI_DOUBLE , MPI_SUM , world ) ; if ( dynamic || tempbias == 2 ) dof_compute ( ) ; scalar *= tfactor ; return scalar ; } void ComputeTempAsphere :: compute_vector ( ) { int i ; invoked_vector = update -> ntimestep ; if ( tempbias ) { if ( tbias -> invoked_vector != update -> ntimestep ) tbias -> compute_vector ( ) ; tbias -> remove_bias_all ( ) ; } AtomVecEllipsoid :: Bonus * bonus = avec -> bonus ; double * * v = atom -> v ; double * * angmom = atom -> angmom ; double * rmass = atom -> rmass ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; double * shape , * quat ; double wbody [ 3 ] , inertia [ 3 ] , t [ 6 ] ; double rot [ 3 ] [ 3 ] ; double massone ; for ( i = 0 ; i < 6 ; i ++ ) t [ i ] = 0.0 ; if ( mode == ALL ) { for ( i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { massone = rmass [ i ] ; t [ 0 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 0 ] ; t [ 1 ] += massone * v [ i ] [ 1 ] * v [ i ] [ 1 ] ; t [ 2 ] += massone * v [ i ] [ 2 ] * v [ i ] [ 2 ] ; t [ 3 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 1 ] ; t [ 4 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 2 ] ; t [ 5 ] += massone * v [ i ] [ 1 ] * v [ i ] [ 2 ] ; shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * massone * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t [ 0 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] ; t [ 1 ] += inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] ; t [ 2 ] += inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; t [ 3 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 1 ] ; t [ 4 ] += inertia [ 1 ] * wbody [ 0 ] * wbody [ 2 ] ; t [ 5 ] += inertia [ 2 ] * wbody [ 1 ] * wbody [ 2 ] ; } } else { for ( i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; massone = rmass [ i ] ; inertia [ 0 ] = INERTIA * massone * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t [ 0 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] ; t [ 1 ] += inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] ; t [ 2 ] += inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; t [ 3 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 1 ] ; t [ 4 ] += inertia [ 1 ] * wbody [ 0 ] * wbody [ 2 ] ; t [ 5 ] += inertia [ 2 ] * wbody [ 1 ] * wbody [ 2 ] ; } } if ( tempbias ) tbias -> restore_bias_all ( ) ; MPI_Allreduce ( t , vector , 6 , MPI_DOUBLE , MPI_SUM , world ) ; for ( i = 0 ; i < 6 ; i ++ ) vector [ i ] *= force -> mvv2e ; } void ComputeTempAsphere :: remove_bias ( int i , double * v ) { if ( tbias ) tbias -> remove_bias ( i , v ) ; } void ComputeTempAsphere :: restore_bias ( int i , double * v ) { if ( tbias ) tbias -> restore_bias ( i , v ) ; } </DOCUMENT>
<DOCUMENT_ID="ellipsis14/dolfin/tree/master/test/unit/la/cpp/Vector.cpp"> # include < dolfin . h > # include < dolfin / common / unittest . h > using namespace dolfin ; class TestVector : public CppUnit :: TestFixture { CPPUNIT_TEST_SUITE ( TestVector ) ; CPPUNIT_TEST ( test_backends ) ; CPPUNIT_TEST ( test_init ) ; CPPUNIT_TEST ( test_get_local_empty ) ; CPPUNIT_TEST_SUITE_END ( ) ; public : void test_backends ( ) { parameters [ " linear _ algebra _ backend " ] = " Eigen " ; _test_operators ( MPI_COMM_SELF ) ; # ifdef HAS_PETSC parameters [ " linear _ algebra _ backend " ] = " PETSc " ; _test_operators ( MPI_COMM_WORLD ) ; # endif } void _test_operators ( MPI_Comm comm ) { Vector v ( comm , 10 ) , u ( comm , 10 ) ; v = 0.0 ; u = 0.0 ; CPPUNIT_ASSERT ( v . sum ( ) == 0.0 ) ; v = 1.0 ; CPPUNIT_ASSERT ( v . sum ( ) == v . size ( ) ) ; u = v ; CPPUNIT_ASSERT ( u . sum ( ) == u . size ( ) ) ; u += v ; CPPUNIT_ASSERT ( u . sum ( ) == 2 * u . size ( ) ) ; u -= v ; u -= v ; CPPUNIT_ASSERT ( u . sum ( ) == 0.0 ) ; v *= 5.0 ; CPPUNIT_ASSERT ( v . sum ( ) == v . size ( ) * 5.0 ) ; v /= 2.0 ; CPPUNIT_ASSERT ( v . sum ( ) == 2.5 * v . size ( ) ) ; u = 2.0 ; v *= u ; CPPUNIT_ASSERT ( v . sum ( ) == v . size ( ) * 5.0 ) ; } void test_init ( ) { const std :: vector < std :: size_t > dims ( 1 , 203 ) ; TensorLayout layout_local ( 0 , false ) ; std :: vector < std :: pair < std :: size_t , std :: size_t > > local_range ( 1 , std :: make_pair ( 0 , 203 ) ) ; layout_local . init ( MPI_COMM_SELF , dims , 1 , local_range ) ; TensorLayout layout_distributed ( 0 , false ) ; std :: vector < std :: pair < std :: size_t , std :: size_t > > ownership_range ( 1 , dolfin :: MPI :: local_range ( MPI_COMM_WORLD , 203 ) ) ; layout_distributed . init ( MPI_COMM_WORLD , dims , 1 , ownership_range ) ; # ifdef HAS_PETSC parameters [ " linear _ algebra _ backend " ] = " PETSc " ; { Vector x ; x . init ( layout_local ) ; CPPUNIT_ASSERT ( x . size ( ) == 203 ) ; Vector y ; y . init ( layout_distributed ) ; CPPUNIT_ASSERT ( y . size ( ) == 203 ) ; } # endif { EigenVector x ; x . init ( layout_local ) ; CPPUNIT_ASSERT ( x . size ( ) == 203 ) ; } # ifdef HAS_PETSC { PETScVector x ; x . init ( layout_local ) ; CPPUNIT_ASSERT ( x . size ( ) == 203 ) ; PETScVector y ; y . init ( layout_distributed ) ; CPPUNIT_ASSERT ( y . size ( ) == 203 ) ; } # endif } void test_get_local_empty ( ) { const std :: vector < std :: size_t > dims ( 1 , 203 ) ; TensorLayout layout_local ( 0 , false ) ; std :: vector < std :: pair < std :: size_t , std :: size_t > > local_range ( 1 , std :: make_pair ( 0 , 203 ) ) ; layout_local . init ( MPI_COMM_SELF , dims , 1 , local_range ) ; TensorLayout layout_distributed ( 0 , false ) ; std :: vector < std :: pair < std :: size_t , std :: size_t > > ownership_range ( 1 , dolfin :: MPI :: local_range ( MPI_COMM_WORLD , 203 ) ) ; layout_distributed . init ( MPI_COMM_WORLD , dims , 1 , ownership_range ) ; # ifdef HAS_PETSC parameters [ " linear _ algebra _ backend " ] = " PETSc " ; { Vector x ; x . init ( layout_local ) ; CPPUNIT_ASSERT ( x . size ( ) == 203 ) ; Vector y ; y . init ( layout_distributed ) ; CPPUNIT_ASSERT ( y . size ( ) == 203 ) ; double * block = NULL ; dolfin :: la_index * rows = NULL ; x . get_local ( block , 0 , rows ) ; y . get_local ( block , 0 , rows ) ; } # endif } } ; CPPUNIT_TEST_SUITE_REGISTRATION ( TestVector ) ; int main ( ) { DOLFIN_TEST ; } </DOCUMENT>
<DOCUMENT_ID="Dako300/BasicTV/tree/master/src/math/numbers/math_numbers.cpp"> # include " . . / . . / main . h " # include " . . / . . / util . h " # include " math _ numbers . h " # include " . . / math . h " # include " . . / . . / id / id _ api . h " # define MINOR_SPECIES_MULTIPLIER ( pow ( 2 , 64 ) - 1 ) static void number_sanity_fetch ( void * ptr , uint64_t start , uint64_t size , std :: vector < uint8_t > * data ) { if ( data -> size ( ) < start + size ) { print ( " can ' t ▁ copy , ▁ not ▁ enough ▁ room " , P_ERR ) ; } memcpy ( ptr , data -> data ( ) + start , size ) ; convert :: nbo :: from ( ( uint8_t * ) ptr , size ) ; } static std :: vector < uint8_t > number_sanity_fetch ( std :: vector < uint8_t > * data ) { std :: vector < uint8_t > retval ; if ( data -> size ( ) < 4 ) { print ( " not ▁ enough ▁ room ▁ to ▁ possibly ▁ encode ▁ major / minor ▁ size " , P_ERR ) ; } uint32_t size ; memcpy ( & size , data -> data ( ) , 4 ) ; size = NBO_32 ( size ) ; if ( data -> size ( ) < 4 + size ) { P_V ( size , P_WARN ) ; P_V ( data -> size ( ) , P_WARN ) ; print ( " invalid ▁ size ▁ for ▁ current ▁ number ▁ chunk " , P_ERR ) ; } retval = convert :: nbo :: from ( std :: vector < uint8_t > ( data -> begin ( ) + 4 , data -> begin ( ) + 4 + size ) ) ; data -> erase ( data -> begin ( ) , data -> begin ( ) + 4 + size ) ; return retval ; } uint64_t math :: number :: get :: unit ( std :: vector < uint8_t > data ) { uint64_t retval ; number_sanity_fetch ( & retval , 0 , sizeof ( retval ) , & data ) ; return retval ; } std :: pair < std :: vector < uint8_t > , std :: vector < uint8_t > > math :: number :: get :: raw_species ( std :: vector < uint8_t > data ) { uint64_t start = sizeof ( math_number_unit_t ) ; if ( data . size ( ) < start ) { return std :: pair < std :: vector < uint8_t > , std :: vector < uint8_t > > ( { } , { } ) ; } data . erase ( data . begin ( ) , data . begin ( ) + start ) ; std :: pair < std :: vector < uint8_t > , std :: vector < uint8_t > > retval ; retval . first = number_sanity_fetch ( & data ) ; retval . second = number_sanity_fetch ( & data ) ; return retval ; } long double math :: number :: get :: number ( std :: vector < uint8_t > data ) { long double retval ; std :: pair < std :: vector < uint8_t > , std :: vector < uint8_t > > species = math :: number :: get :: raw_species ( data ) ; if ( species . first . size ( ) > 8 || species . second . size ( ) > 8 ) { print ( " I ▁ need ▁ to ▁ expand ▁ this ▁ beyond ▁ 64 - bits " , P_ERR ) ; } uint64_t major_int = 0 , minor_int = 0 ; memcpy ( & major_int , species . first . data ( ) , species . first . size ( ) ) ; memcpy ( & minor_int , species . second . data ( ) , species . second . size ( ) ) ; retval = ( long double ) ( major_int ) + ( long double ) ( ( long double ) ( minor_int / MINOR_SPECIES_MULTIPLIER ) ) ; return retval ; } # define NUMBER_CREATE_ADD ( x ) retval . insert ( retval . end ( ) , ( uint8_t * ) & x , ( uint8_t * ) & x + sizeof ( x ) ) std :: vector < uint8_t > math :: number :: create ( long double number , uint64_t unit ) { std :: vector < uint8_t > retval ; int64_t major_int = ( ( uint64_t ) ( long double ) ( number ) ) ; uint32_t major_size = ( 8 ) ; uint64_t minor_int = ( ( ( ( long double ) number - ( long double ) major_int ) * ( long double ) MINOR_SPECIES_MULTIPLIER ) ) ; uint32_t minor_size = ( 8 ) ; unit = NBO_64 ( unit ) ; major_int = NBO_64 ( major_int ) ; major_size = NBO_32 ( major_size ) ; minor_int = NBO_64 ( minor_int ) ; minor_size = NBO_32 ( minor_size ) ; NUMBER_CREATE_ADD ( unit ) ; NUMBER_CREATE_ADD ( major_size ) ; NUMBER_CREATE_ADD ( major_int ) ; NUMBER_CREATE_ADD ( minor_size ) ; NUMBER_CREATE_ADD ( minor_int ) ; return retval ; } std :: vector < uint8_t > math :: number :: create ( uint64_t number , uint64_t unit ) { std :: vector < uint8_t > retval ; uint64_t major_int = number ; uint32_t major_size = 8 ; uint64_t minor_int = 0 ; uint32_t minor_size = 0 ; unit = NBO_64 ( unit ) ; major_int = NBO_64 ( major_int ) ; major_size = NBO_32 ( major_size ) ; minor_int = NBO_64 ( minor_int ) ; minor_size = NBO_32 ( minor_size ) ; NUMBER_CREATE_ADD ( unit ) ; NUMBER_CREATE_ADD ( major_size ) ; NUMBER_CREATE_ADD ( major_int ) ; NUMBER_CREATE_ADD ( minor_size ) ; NUMBER_CREATE_ADD ( minor_int ) ; return retval ; } std :: vector < uint8_t > math :: number :: create ( int64_t number , uint64_t unit ) { std :: vector < uint8_t > retval ; int64_t major_int = number ; uint32_t major_size = 8 ; uint64_t minor_int = 0 ; uint32_t minor_size = 0 ; unit = NBO_64 ( unit ) ; major_int = NBO_64 ( major_int ) ; major_size = NBO_32 ( major_size ) ; minor_int = NBO_64 ( minor_int ) ; minor_size = NBO_32 ( minor_size ) ; NUMBER_CREATE_ADD ( unit ) ; NUMBER_CREATE_ADD ( major_size ) ; NUMBER_CREATE_ADD ( major_int ) ; NUMBER_CREATE_ADD ( minor_size ) ; NUMBER_CREATE_ADD ( minor_int ) ; return retval ; } std :: vector < uint8_t > math :: number :: create ( std :: vector < uint8_t > raw_number_data_major , std :: vector < uint8_t > raw_number_data_minor , uint64_t unit ) { std :: vector < uint8_t > retval ; convert :: nbo :: to ( raw_number_data_major . data ( ) , raw_number_data_major . size ( ) ) ; convert :: nbo :: to ( raw_number_data_minor . data ( ) , raw_number_data_minor . size ( ) ) ; ASSERT ( raw_number_data_major . size ( ) <= UINT32_MAX , P_ERR ) ; ASSERT ( raw_number_data_minor . size ( ) <= UINT32_MAX , P_ERR ) ; uint32_t major_size = NBO_32 ( static_cast < uint32_t > ( raw_number_data_major . size ( ) ) ) ; uint32_t minor_size = NBO_32 ( static_cast < uint32_t > ( raw_number_data_minor . size ( ) ) ) ; NUMBER_CREATE_ADD ( unit ) ; NUMBER_CREATE_ADD ( major_size ) ; retval . insert ( retval . end ( ) , raw_number_data_major . begin ( ) , raw_number_data_major . end ( ) ) ; NUMBER_CREATE_ADD ( minor_size ) ; retval . insert ( retval . end ( ) , raw_number_data_minor . begin ( ) , raw_number_data_minor . end ( ) ) ; } void math :: number :: add_data_to_set ( std :: vector < std :: vector < uint8_t > > data , id_t_ math_number_set_id ) { math_number_set_t * math_number_set_ptr = PTR_DATA ( math_number_set_id , math_number_set_t ) ; if ( math_number_set_ptr == nullptr ) { print ( " math _ number _ set _ ptr ▁ is ▁ a ▁ nullptr " , P_ERR ) ; } math_number_set_ptr -> add_data ( data ) ; } </DOCUMENT>
<DOCUMENT_ID="geodynamics/gale/tree/master/boost/libs/regex/performance/time_greta.cpp"> # include " regex _ comparison . hpp " # if defined ( BOOST_HAS_GRETA ) # include < cassert > # include < boost / timer . hpp > # include " regexpr2 . h " namespace g { double time_match ( const std :: string & re , const std :: string & text , bool icase ) { regex :: rpattern e ( re , ( icase ? regex :: MULTILINE | regex :: NORMALIZE | regex :: NOCASE : regex :: MULTILINE | regex :: NORMALIZE ) ) ; regex :: match_results what ; boost :: timer tim ; int iter = 1 ; int counter , repeats ; double result = 0 ; double run ; assert ( e . match ( text , what ) ) ; do { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text , what ) ; } result = tim . elapsed ( ) ; iter *= 2 ; } while ( result < 0.5 ) ; iter /= 2 ; for ( repeats = 0 ; repeats < REPEAT_COUNT ; ++ repeats ) { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text , what ) ; } run = tim . elapsed ( ) ; result = ( std :: min ) ( run , result ) ; } return result / iter ; } double time_find_all ( const std :: string & re , const std :: string & text , bool icase ) { regex :: rpattern e ( re , ( icase ? regex :: MULTILINE | regex :: NORMALIZE | regex :: NOCASE : regex :: MULTILINE | regex :: NORMALIZE ) ) ; regex :: match_results what ; boost :: timer tim ; int iter = 1 ; int counter , repeats ; double result = 0 ; double run ; do { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text . begin ( ) , text . end ( ) , what ) ; while ( what . backref ( 0 ) . matched ) { e . match ( what . backref ( 0 ) . end ( ) , text . end ( ) , what ) ; } } result = tim . elapsed ( ) ; iter *= 2 ; } while ( result < 0.5 ) ; iter /= 2 ; if ( result > 10 ) return result / iter ; for ( repeats = 0 ; repeats < REPEAT_COUNT ; ++ repeats ) { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text . begin ( ) , text . end ( ) , what ) ; while ( what . backref ( 0 ) . matched ) { e . match ( what . backref ( 0 ) . end ( ) , text . end ( ) , what ) ; } } run = tim . elapsed ( ) ; result = ( std :: min ) ( run , result ) ; } return result / iter ; } } # else namespace g { double time_match ( const std :: string & re , const std :: string & text , bool icase ) { return - 1 ; } double time_find_all ( const std :: string & re , const std :: string & text , bool icase ) { return - 1 ; } } # endif </DOCUMENT>
<DOCUMENT_ID="wiltonlazary/arangodb/tree/master/3rdParty/boost/1.61.0/libs/math/test/compile_test/sf_hypot_incl_test.cpp"> # include < boost / math / special_functions / hypot . hpp > # include " test _ compile _ result . hpp " void compile_and_link_test ( ) { check_result < float > ( boost :: math :: hypot < float > ( f , f ) ) ; check_result < double > ( boost :: math :: hypot < double > ( d , d ) ) ; # ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS check_result < long double > ( boost :: math :: hypot < long double > ( l , l ) ) ; # endif } </DOCUMENT>
<DOCUMENT_ID="hacklab-turku/luumuhillo/tree/master/source/main.cpp"> # include " game . hpp " # include " server . hpp " # ifdef _WIN32 # include < Windows . h > # endif int main ( int argc , char * * argv ) { if ( game . start ( ) != 0 ) return - 1 ; int retcode = game . getServer ( ) -> start ( ) ; if ( retcode == 0 ) { # ifdef _WIN32 TerminateProcess ( GetCurrentProcess ( ) , EXIT_SUCCESS ) ; # endif return 0 ; } else return retcode ; } </DOCUMENT>
<DOCUMENT_ID="pcolby/libqtaws/tree/master/src/ssm/describeinstancepatchstatesresponse.cpp"> # include " describeinstancepatchstatesresponse . h " # include " describeinstancepatchstatesresponse _ p . h " # include < QDebug > # include < QNetworkReply > # include < QXmlStreamReader > namespace QtAws { namespace SSM { DescribeInstancePatchStatesResponse :: DescribeInstancePatchStatesResponse ( const DescribeInstancePatchStatesRequest & request , QNetworkReply * const reply , QObject * const parent ) : SsmResponse ( new DescribeInstancePatchStatesResponsePrivate ( this ) , parent ) { setRequest ( new DescribeInstancePatchStatesRequest ( request ) ) ; setReply ( reply ) ; } const DescribeInstancePatchStatesRequest * DescribeInstancePatchStatesResponse :: request ( ) const { Q_D ( const DescribeInstancePatchStatesResponse ) ; return static_cast < const DescribeInstancePatchStatesRequest * > ( d -> request ) ; } void DescribeInstancePatchStatesResponse :: parseSuccess ( QIODevice & response ) { QXmlStreamReader xml ( & response ) ; } DescribeInstancePatchStatesResponsePrivate :: DescribeInstancePatchStatesResponsePrivate ( DescribeInstancePatchStatesResponse * const q ) : SsmResponsePrivate ( q ) { } void DescribeInstancePatchStatesResponsePrivate :: parseDescribeInstancePatchStatesResponse ( QXmlStreamReader & xml ) { Q_ASSERT ( xml . name ( ) == QLatin1String ( " DescribeInstancePatchStatesResponse " ) ) ; Q_UNUSED ( xml ) } } } </DOCUMENT>
<DOCUMENT_ID="LiveAsynchronousVisualizedArchitecture/lava/tree/master/nuklear/unified.cpp"> # define LAVA_INDEXED_VERTS_IMPL # include " IndexedVerts . h " # include " nanogui / src / screen . cpp " # include " main . cpp " </DOCUMENT>
<DOCUMENT_ID="uwafsl/ardupilot/tree/master/libraries/AP_HAL_Linux/Util.cpp"> # include < AP_HAL / AP_HAL . h > # if CONFIG_HAL_BOARD == HAL_BOARD_LINUX # include < stdio . h > # include < stdarg . h > # include < sys / stat . h > # include < unistd . h > # include < stdlib . h > # include < errno . h > # include < time . h > # include < fcntl . h > extern const AP_HAL :: HAL & hal ; # include " ToneAlarm _ Raspilot . h " # include " Util . h " # include " Heat _ Pwm . h " using namespace Linux ; static int state ; # if CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_RASPILOT ToneAlarm_Raspilot Util :: _toneAlarm ; # else ToneAlarm Util :: _toneAlarm ; # endif void Util :: init ( int argc , char * const * argv ) { saved_argc = argc ; saved_argv = argv ; # ifdef HAL_UTILS_HEAT # if HAL_UTILS_HEAT == HAL_LINUX_HEAT_PWM _heat = new Linux :: HeatPwm ( HAL_LINUX_HEAT_PWM_NUM , HAL_LINUX_HEAT_KP , HAL_LINUX_HEAT_KI , HAL_LINUX_HEAT_PERIOD_NS , HAL_LINUX_HEAT_TARGET_TEMP ) ; # else # error Unrecognized Heat # endif # else _heat = new Linux :: Heat ( ) ; # endif } void Util :: set_imu_temp ( float current ) { _heat -> set_imu_temp ( current ) ; } void Util :: commandline_arguments ( uint8_t & argc , char * const * & argv ) { argc = saved_argc ; argv = saved_argv ; } bool Util :: toneAlarm_init ( ) { return _toneAlarm . init ( ) ; } void Util :: toneAlarm_set_tune ( uint8_t tone ) { _toneAlarm . set_tune ( tone ) ; } void Util :: _toneAlarm_timer_tick ( ) { if ( state == 0 ) { state = state + _toneAlarm . init_tune ( ) ; } else if ( state == 1 ) { state = state + _toneAlarm . set_note ( ) ; } if ( state == 2 ) { state = state + _toneAlarm . play ( ) ; } else if ( state == 3 ) { state = 1 ; } if ( _toneAlarm . is_tune_comp ( ) ) { state = 0 ; } } void Util :: set_system_clock ( uint64_t time_utc_usec ) { # if CONFIG_HAL_BOARD_SUBTYPE != HAL_BOARD_SUBTYPE_LINUX_NONE timespec ts ; ts . tv_sec = time_utc_usec / 1.0e6 ; ts . tv_nsec = ( time_utc_usec % 1000000 ) * 1000 ; clock_settime ( CLOCK_REALTIME , & ts ) ; # endif } bool Util :: is_chardev_node ( const char * path ) { struct stat st ; if ( ! path || lstat ( path , & st ) < 0 ) return false ; return S_ISCHR ( st . st_mode ) ; } uint32_t Util :: available_memory ( void ) { return 256 * 1024 ; } int Util :: write_file ( const char * path , const char * fmt , ... ) { errno = 0 ; int fd = :: open ( path , O_WRONLY | O_CLOEXEC ) ; if ( fd == - 1 ) { return - errno ; } va_list args ; va_start ( args , fmt ) ; int ret = :: vdprintf ( fd , fmt , args ) ; int errno_bkp = errno ; :: close ( fd ) ; va_end ( args ) ; if ( ret < 1 ) { return - errno_bkp ; } return ret ; } int Util :: read_file ( const char * path , const char * fmt , ... ) { errno = 0 ; FILE * file = :: fopen ( path , " re " ) ; if ( ! file ) return - errno ; va_list args ; va_start ( args , fmt ) ; int ret = :: vfscanf ( file , fmt , args ) ; int errno_bkp = errno ; :: fclose ( file ) ; va_end ( args ) ; if ( ret < 1 ) return - errno_bkp ; return ret ; } const char * Linux :: Util :: _hw_names [ UTIL_NUM_HARDWARES ] = { [ UTIL_HARDWARE_RPI1 ] = " BCM2708" , [ UTIL_HARDWARE_RPI2 ] = " BCM2709" , [ UTIL_HARDWARE_BEBOP ] = " Mykonos3 ▁ board " , [ UTIL_HARDWARE_BEBOP2 ] = " Milos ▁ board " , } ; # define MAX_SIZE_LINE 50 int Util :: get_hw_arm32 ( ) { int ret = - ENOENT ; char buffer [ MAX_SIZE_LINE ] ; const char * hardware_description_entry = " Hardware " ; char * flag ; FILE * f ; f = fopen ( " / proc / cpuinfo " , " r " ) ; if ( f == NULL ) { ret = - errno ; goto end ; } while ( fgets ( buffer , MAX_SIZE_LINE , f ) != NULL ) { flag = strstr ( buffer , hardware_description_entry ) ; if ( flag != NULL ) { for ( uint8_t i = 0 ; i < UTIL_NUM_HARDWARES ; i ++ ) { if ( strstr ( buffer , _hw_names [ i ] ) != 0 ) { ret = i ; goto close_end ; } } } } close_end : fclose ( f ) ; end : return ret ; } # endif </DOCUMENT>
<DOCUMENT_ID="thientu/drake/tree/master/util/drakeGeometryUtil.cpp"> # include " drakeGeometryUtil . h " # include < iostream > # include < cmath > # include < limits > # include < stdexcept > # include < Eigen / Sparse > # include " expmap2quat . h " using namespace Eigen ; double angleDiff ( double phi1 , double phi2 ) { double d = phi2 - phi1 ; if ( d > 0.0 ) { d = fmod ( d + M_PI , 2 * M_PI ) - M_PI ; } else { d = fmod ( d - M_PI , 2 * M_PI ) + M_PI ; } return d ; } Vector4d quatConjugate ( const Eigen :: Vector4d & q ) { Vector4d q_conj ; q_conj << q ( 0 ) , - q ( 1 ) , - q ( 2 ) , - q ( 3 ) ; return q_conj ; } Eigen :: Matrix4d dquatConjugate ( ) { Matrix4d dq_conj = Matrix4d :: Identity ( ) ; dq_conj ( 1 , 1 ) = - 1.0 ; dq_conj ( 2 , 2 ) = - 1.0 ; dq_conj ( 3 , 3 ) = - 1.0 ; return dq_conj ; } Eigen :: Vector4d quatProduct ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 ) { double w1 = q1 ( 0 ) ; double w2 = q2 ( 0 ) ; const auto & v1 = q1 . tail < 3 > ( ) ; const auto & v2 = q2 . tail < 3 > ( ) ; Vector4d r ; r << w1 * w2 - v1 . dot ( v2 ) , v1 . cross ( v2 ) + w1 * v2 + w2 * v1 ; return r ; } Eigen :: Matrix < double , 4 , 8 > dquatProduct ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 ) { double w1 = q1 ( 0 ) ; double w2 = q2 ( 0 ) ; const auto & v1 = q1 . tail < 3 > ( ) ; const auto & v2 = q2 . tail < 3 > ( ) ; Matrix < double , 4 , 8 > dr ; dr . row ( 0 ) << w2 , - v2 . transpose ( ) , w1 , - v1 . transpose ( ) ; dr . row ( 1 ) << q2 ( 1 ) , q2 ( 0 ) , q2 ( 3 ) , - q2 ( 2 ) , q1 ( 1 ) , q1 ( 0 ) , - q1 ( 3 ) , q1 ( 2 ) ; dr . row ( 2 ) << q2 ( 2 ) , - q2 ( 3 ) , q2 ( 0 ) , q2 ( 1 ) , q1 ( 2 ) , q1 ( 3 ) , q1 ( 0 ) , - q1 ( 1 ) ; dr . row ( 3 ) << q2 ( 3 ) , q2 ( 2 ) , - q2 ( 1 ) , q2 ( 0 ) , q1 ( 3 ) , - q1 ( 2 ) , q1 ( 1 ) , q1 ( 0 ) ; return dr ; } Eigen :: Vector3d quatRotateVec ( const Eigen :: Vector4d & q , const Eigen :: Vector3d & v ) { Vector4d v_quat ; v_quat << 0 , v ; Vector4d q_times_v = quatProduct ( q , v_quat ) ; Vector4d q_conj = quatConjugate ( q ) ; Vector4d v_rot = quatProduct ( q_times_v , q_conj ) ; Vector3d r = v_rot . bottomRows < 3 > ( ) ; return r ; } Eigen :: Matrix < double , 3 , 7 > dquatRotateVec ( const Eigen :: Vector4d & q , const Eigen :: Vector3d & v ) { Matrix < double , 4 , 7 > dq ; dq << Matrix4d :: Identity ( ) , MatrixXd :: Zero ( 4 , 3 ) ; Matrix < double , 4 , 7 > dv = Matrix < double , 4 , 7 > :: Zero ( ) ; dv . bottomRightCorner < 3 , 3 > ( ) = Matrix3d :: Identity ( ) ; Matrix < double , 8 , 7 > dqdv ; dqdv << dq , dv ; Vector4d v_quat ; v_quat << 0 , v ; Vector4d q_times_v = quatProduct ( q , v_quat ) ; Matrix < double , 4 , 8 > dq_times_v_tmp = dquatProduct ( q , v_quat ) ; Matrix < double , 4 , 7 > dq_times_v = dq_times_v_tmp * dqdv ; Matrix < double , 4 , 7 > dq_conj = dquatConjugate ( ) * dq ; Matrix < double , 8 , 7 > dq_times_v_dq_conj ; dq_times_v_dq_conj << dq_times_v , dq_conj ; Matrix < double , 4 , 8 > dv_rot_tmp = dquatProduct ( q_times_v , quatConjugate ( q ) ) ; Matrix < double , 4 , 7 > dv_rot = dv_rot_tmp * dq_times_v_dq_conj ; Eigen :: Matrix < double , 3 , 7 > dr = dv_rot . bottomRows ( 3 ) ; return dr ; } Eigen :: Vector4d quatDiff ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 ) { return quatProduct ( quatConjugate ( q1 ) , q2 ) ; } Eigen :: Matrix < double , 4 , 8 > dquatDiff ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 ) { auto dr = dquatProduct ( quatConjugate ( q1 ) , q2 ) ; dr . block < 4 , 3 > ( 0 , 1 ) = - dr . block < 4 , 3 > ( 0 , 1 ) ; return dr ; } double quatDiffAxisInvar ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 , const Eigen :: Vector3d & u ) { Vector4d r = quatDiff ( q1 , q2 ) ; double e = - 2.0 + 2 * r ( 0 ) * r ( 0 ) + 2 * pow ( u ( 0 ) * r ( 1 ) + u ( 1 ) * r ( 2 ) + u ( 2 ) * r ( 3 ) , 2 ) ; return e ; } Eigen :: Matrix < double , 1 , 11 > dquatDiffAxisInvar ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 , const Eigen :: Vector3d & u ) { Vector4d r = quatDiff ( q1 , q2 ) ; Matrix < double , 4 , 8 > dr = dquatDiff ( q1 , q2 ) ; Matrix < double , 1 , 11 > de ; const auto & rvec = r . tail < 3 > ( ) ; de << 4.0 * r ( 0 ) * dr . row ( 0 ) + 4.0 * u . transpose ( ) * rvec * u . transpose ( ) * dr . block < 3 , 8 > ( 1 , 0 ) , 4.0 * u . transpose ( ) * rvec * rvec . transpose ( ) ; return de ; } double quatNorm ( const Eigen :: Vector4d & q ) { return std :: acos ( q ( 0 ) ) ; } Eigen :: Vector4d slerp ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 , double interpolation_parameter ) { double lambda = ( q1 . transpose ( ) * q2 ) . value ( ) ; int q2_sign ; if ( lambda < 0.0 ) { lambda = - lambda ; q2_sign = - 1 ; } else { q2_sign = 1 ; } double r , s ; if ( std :: abs ( 1.0 - lambda ) < std :: numeric_limits < double > :: epsilon ( ) ) { r = 1.0 - interpolation_parameter ; s = interpolation_parameter ; } else { double alpha = std :: acos ( lambda ) ; double gamma = 1.0 / std :: sin ( alpha ) ; r = std :: sin ( ( 1.0 - interpolation_parameter ) * alpha ) * gamma ; s = std :: sin ( interpolation_parameter * alpha ) * gamma ; } Vector4d ret = q1 * r ; ret += q2_sign * q2 * s ; return ret ; } Vector4d uniformlyRandomAxisAngle ( std :: default_random_engine & generator ) { std :: normal_distribution < double > normal ; std :: uniform_real_distribution < double > uniform ( - M_PI , M_PI ) ; double angle = uniform ( generator ) ; Vector3d axis = Vector3d ( normal ( generator ) , normal ( generator ) , normal ( generator ) ) ; axis . normalize ( ) ; Vector4d a ; a << axis , angle ; return a ; } Vector4d uniformlyRandomQuat ( std :: default_random_engine & generator ) { return axis2quat ( uniformlyRandomAxisAngle ( generator ) ) ; } Eigen :: Matrix3d uniformlyRandomRotmat ( std :: default_random_engine & generator ) { return axis2rotmat ( uniformlyRandomAxisAngle ( generator ) ) ; } Eigen :: Vector3d uniformlyRandomRPY ( std :: default_random_engine & generator ) { return axis2rpy ( uniformlyRandomAxisAngle ( generator ) ) ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > quat2rpy ( const Eigen :: MatrixBase < Derived > & q ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; auto q_normalized = q . normalized ( ) ; auto w = q_normalized ( 0 ) ; auto x = q_normalized ( 1 ) ; auto y = q_normalized ( 2 ) ; auto z = q_normalized ( 3 ) ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > ret ; ret << std :: atan2 ( 2.0 * ( w * x + y * z ) , w * w + z * z - ( x * x + y * y ) ) , std :: asin ( 2.0 * ( w * y - z * x ) ) , std :: atan2 ( 2.0 * ( w * z + x * y ) , w * w + x * x - ( y * y + z * z ) ) ; return ret ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > quat2rotmat ( const Eigen :: MatrixBase < Derived > & q ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; auto q_normalized = q . normalized ( ) ; auto w = q_normalized ( 0 ) ; auto x = q_normalized ( 1 ) ; auto y = q_normalized ( 2 ) ; auto z = q_normalized ( 3 ) ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > M ; M . row ( 0 ) << w * w + x * x - y * y - z * z , 2.0 * x * y - 2.0 * w * z , 2.0 * x * z + 2.0 * w * y ; M . row ( 1 ) << 2.0 * x * y + 2.0 * w * z , w * w + y * y - x * x - z * z , 2.0 * y * z - 2.0 * w * x ; M . row ( 2 ) << 2.0 * x * z - 2.0 * w * y , 2.0 * y * z + 2.0 * w * x , w * w + z * z - x * x - y * y ; return M ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > quat2axis ( const Eigen :: MatrixBase < Derived > & q ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; auto q_normalized = q . normalized ( ) ; auto s = std :: sqrt ( 1.0 - q_normalized ( 0 ) * q_normalized ( 0 ) ) + std :: numeric_limits < typename Derived :: Scalar > :: epsilon ( ) ; Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > a ; a << q_normalized . template tail < 3 > ( ) / s , 2.0 * std :: acos ( q_normalized ( 0 ) ) ; return a ; } template < typename Derived > Eigen :: Vector4d axis2quat ( const Eigen :: MatrixBase < Derived > & a ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; auto axis = a . template head < 3 > ( ) ; auto angle = a ( 3 ) ; auto arg = 0.5 * angle ; auto c = std :: cos ( arg ) ; auto s = std :: sin ( arg ) ; Eigen :: Vector4d ret ; ret << c , s * axis ; return ret ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > axis2rotmat ( const Eigen :: MatrixBase < Derived > & a ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; const auto & axis = ( a . template head < 3 > ( ) ) / ( a . template head < 3 > ( ) ) . norm ( ) ; const auto & theta = a ( 3 ) ; auto x = axis ( 0 ) ; auto y = axis ( 1 ) ; auto z = axis ( 2 ) ; auto ctheta = std :: cos ( theta ) ; auto stheta = std :: sin ( theta ) ; auto c = 1 - ctheta ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > R ; R << ctheta + x * x * c , x * y * c - z * stheta , x * z * c + y * stheta , y * x * c + z * stheta , ctheta + y * y * c , y * z * c - x * stheta , z * x * c - y * stheta , z * y * c + x * stheta , ctheta + z * z * c ; return R ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > axis2rpy ( const Eigen :: MatrixBase < Derived > & a ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; return quat2rpy ( axis2quat ( a ) ) ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > rotmat2axis ( const Eigen :: MatrixBase < Derived > & R ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 , 3 ) ; typename Derived :: Scalar theta = std :: acos ( ( R . trace ( ) - 1.0 ) / 2.0 ) ; Vector4d a ; if ( theta > std :: numeric_limits < typename Derived :: Scalar > :: epsilon ( ) ) { a << R ( 2 , 1 ) - R ( 1 , 2 ) , R ( 0 , 2 ) - R ( 2 , 0 ) , R ( 1 , 0 ) - R ( 0 , 1 ) , theta ; a . head < 3 > ( ) *= 1.0 / ( 2.0 * std :: sin ( theta ) ) ; } else { a << 1.0 , 0.0 , 0.0 , 0.0 ; } return a ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > rotmat2quat ( const Eigen :: MatrixBase < Derived > & M ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 , 3 ) ; using namespace std ; Matrix < typename Derived :: Scalar , 4 , 3 > A ; A . row ( 0 ) << 1.0 , 1.0 , 1.0 ; A . row ( 1 ) << 1.0 , - 1.0 , - 1.0 ; A . row ( 2 ) << - 1.0 , 1.0 , - 1.0 ; A . row ( 3 ) << - 1.0 , - 1.0 , 1.0 ; Matrix < typename Derived :: Scalar , 4 , 1 > B = A * M . diagonal ( ) ; typename Matrix < typename Derived :: Scalar , 4 , 1 > :: Index ind , max_col ; typename Derived :: Scalar val = B . maxCoeff ( & ind , & max_col ) ; typename Derived :: Scalar w , x , y , z ; switch ( ind ) { case 0 : { w = sqrt ( 1.0 + val ) / 2.0 ; typename Derived :: Scalar w4 = w * 4.0 ; x = ( M ( 2 , 1 ) - M ( 1 , 2 ) ) / w4 ; y = ( M ( 0 , 2 ) - M ( 2 , 0 ) ) / w4 ; z = ( M ( 1 , 0 ) - M ( 0 , 1 ) ) / w4 ; break ; } case 1 : { double s = 2.0 * sqrt ( 1.0 + val ) ; w = ( M ( 2 , 1 ) - M ( 1 , 2 ) ) / s ; x = 0.25 * s ; y = ( M ( 0 , 1 ) + M ( 1 , 0 ) ) / s ; z = ( M ( 0 , 2 ) + M ( 2 , 0 ) ) / s ; break ; } case 2 : { double s = 2.0 * ( sqrt ( 1.0 + val ) ) ; w = ( M ( 0 , 2 ) - M ( 2 , 0 ) ) / s ; x = ( M ( 0 , 1 ) + M ( 1 , 0 ) ) / s ; y = 0.25 * s ; z = ( M ( 1 , 2 ) + M ( 2 , 1 ) ) / s ; break ; } default : { double s = 2.0 * ( sqrt ( 1.0 + val ) ) ; w = ( M ( 1 , 0 ) - M ( 0 , 1 ) ) / s ; x = ( M ( 0 , 2 ) + M ( 2 , 0 ) ) / s ; y = ( M ( 1 , 2 ) + M ( 2 , 1 ) ) / s ; z = 0.25 * s ; break ; } } Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > q ; q << w , x , y , z ; return q ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > rotmat2rpy ( const Eigen :: MatrixBase < Derived > & R ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 , 3 ) ; using namespace std ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > rpy ; rpy << atan2 ( R ( 2 , 1 ) , R ( 2 , 2 ) ) , atan2 ( - R ( 2 , 0 ) , sqrt ( pow ( R ( 2 , 1 ) , 2.0 ) + pow ( R ( 2 , 2 ) , 2.0 ) ) ) , atan2 ( R ( 1 , 0 ) , R ( 0 , 0 ) ) ; return rpy ; } template < typename Derived > DLLEXPORT Eigen :: Matrix < typename Derived :: Scalar , Eigen :: Dynamic , 1 > rotmat2Representation ( const Eigen :: MatrixBase < Derived > & R , int rotation_type ) { typedef typename Derived :: Scalar Scalar ; Eigen :: Matrix < Scalar , Eigen :: Dynamic , 1 > ret ; switch ( rotation_type ) { case 0 : return Eigen :: Matrix < Scalar , Eigen :: Dynamic , 1 > ( 0 , 1 ) ; case 1 : return rotmat2rpy ( R ) ; case 2 : return rotmat2quat ( R ) ; default : throw std :: runtime_error ( " rotation ▁ representation ▁ type ▁ not ▁ recognized " ) ; } } template < typename Scalar > DLLEXPORT GradientVar < Scalar , Eigen :: Dynamic , 1 > rotmat2Representation ( const GradientVar < Scalar , SPACE_DIMENSION , SPACE_DIMENSION > & R , int rotation_type ) { GradientVar < Scalar , Eigen :: Dynamic , 1 > ret ( rotationRepresentationSize ( rotation_type ) , 1 , R . getNumVariables ( ) , R . maxOrder ( ) ) ; switch ( rotation_type ) { case 0 : break ; case 1 : ret . value ( ) = rotmat2rpy ( R . value ( ) ) ; if ( R . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = drotmat2rpy ( R . value ( ) , R . gradient ( ) . value ( ) ) ; } break ; case 2 : ret . value ( ) = rotmat2quat ( R . value ( ) ) ; if ( R . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = drotmat2quat ( R . value ( ) , R . gradient ( ) . value ( ) ) ; } break ; default : throw std :: runtime_error ( " rotation ▁ representation ▁ type ▁ not ▁ recognized " ) ; } return ret ; } template < typename Derived > GradientVar < typename Derived :: Scalar , QUAT_SIZE , 1 > expmap2quat ( const Eigen :: MatrixBase < Derived > & v , const int gradient_order ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 ) ; GradientVar < typename Derived :: Scalar , QUAT_SIZE , 1 > ret ( QUAT_SIZE , 1 , EXPMAP_SIZE , gradient_order ) ; auto theta = v . norm ( ) ; if ( theta < pow ( std :: numeric_limits < typename Derived :: Scalar > :: epsilon ( ) , 0.25 ) ) { ret . value ( ) = expmap2quatDegenerate ( v , theta ) ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = dexpmap2quatDegenerate ( v , theta ) ; if ( gradient_order > 1 ) { ret . gradient ( ) . gradient ( ) . value ( ) = ddexpmap2quatDegenerate ( v , theta ) ; if ( gradient_order > 2 ) { throw std :: runtime_error ( " expmap2quat ▁ does ▁ not ▁ support ▁ gradient ▁ order ▁ larger ▁ than ▁ 2" ) ; } } } } else { ret . value ( ) = expmap2quatNonDegenerate ( v , theta ) ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = dexpmap2quatNonDegenerate ( v , theta ) ; if ( gradient_order > 1 ) { ret . gradient ( ) . gradient ( ) . value ( ) = ddexpmap2quatNonDegenerate ( v , theta ) ; if ( gradient_order > 2 ) { throw std :: runtime_error ( " expmap2quat ▁ does ▁ not ▁ support ▁ gradient ▁ order ▁ larger ▁ than ▁ 2" ) ; } } } } return ret ; } DLLEXPORT int rotationRepresentationSize ( int rotation_type ) { switch ( rotation_type ) { case 0 : return 0 ; break ; case 1 : return 3 ; break ; case 2 : return 4 ; break ; default : throw std :: runtime_error ( " rotation ▁ representation ▁ type ▁ not ▁ recognized " ) ; } } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > rpy2axis ( const Eigen :: MatrixBase < Derived > & rpy ) { return quat2axis ( rpy2quat ( rpy ) ) ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > rpy2quat ( const Eigen :: MatrixBase < Derived > & rpy ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 ) ; auto rpy_2 = ( rpy / 2.0 ) . array ( ) ; auto s = rpy_2 . sin ( ) ; auto c = rpy_2 . cos ( ) ; Vector4d q ; q << c ( 0 ) * c ( 1 ) * c ( 2 ) + s ( 0 ) * s ( 1 ) * s ( 2 ) , s ( 0 ) * c ( 1 ) * c ( 2 ) - c ( 0 ) * s ( 1 ) * s ( 2 ) , c ( 0 ) * s ( 1 ) * c ( 2 ) + s ( 0 ) * c ( 1 ) * s ( 2 ) , c ( 0 ) * c ( 1 ) * s ( 2 ) - s ( 0 ) * s ( 1 ) * c ( 2 ) ; q /= q . norm ( ) + std :: numeric_limits < typename Derived :: Scalar > :: epsilon ( ) ; return q ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > rpy2rotmat ( const Eigen :: MatrixBase < Derived > & rpy ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 ) ; auto rpy_array = rpy . array ( ) ; auto s = rpy_array . sin ( ) ; auto c = rpy_array . cos ( ) ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > R ; R . row ( 0 ) << c ( 2 ) * c ( 1 ) , c ( 2 ) * s ( 1 ) * s ( 0 ) - s ( 2 ) * c ( 0 ) , c ( 2 ) * s ( 1 ) * c ( 0 ) + s ( 2 ) * s ( 0 ) ; R . row ( 1 ) << s ( 2 ) * c ( 1 ) , s ( 2 ) * s ( 1 ) * s ( 0 ) + c ( 2 ) * c ( 0 ) , s ( 2 ) * s ( 1 ) * c ( 0 ) - c ( 2 ) * s ( 0 ) ; R . row ( 2 ) << - s ( 1 ) , c ( 1 ) * s ( 0 ) , c ( 1 ) * c ( 0 ) ; return R ; } Matrix3d rotz ( double theta ) { Matrix3d M ; double c = cos ( theta ) ; double s = sin ( theta ) ; M << c , - s , 0 , s , c , 0 , 0 , 0 , 1 ; return M ; } void rotz ( double theta , Matrix3d & M , Matrix3d & dM , Matrix3d & ddM ) { double c = cos ( theta ) , s = sin ( theta ) ; M << c , - s , 0 , s , c , 0 , 0 , 0 , 1 ; dM << - s , - c , 0 , c , - s , 0 , 0 , 0 , 0 ; ddM << - c , s , 0 , - s , - c , 0 , 0 , 0 , 0 ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 9 , 3 > drpy2rotmat ( const Eigen :: MatrixBase < Derived > & rpy ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 ) ; auto rpy_array = rpy . array ( ) ; auto s = rpy_array . sin ( ) ; auto c = rpy_array . cos ( ) ; Eigen :: Matrix < typename Derived :: Scalar , 9 , 3 > dR ; dR . row ( 0 ) << 0 , c ( 2 ) * - s ( 1 ) , c ( 1 ) * - s ( 2 ) ; dR . row ( 1 ) << 0 , - s ( 1 ) * s ( 2 ) , c ( 2 ) * c ( 1 ) ; dR . row ( 2 ) << 0 , - c ( 1 ) , 0 ; dR . row ( 3 ) << c ( 2 ) * s ( 1 ) * c ( 0 ) - s ( 2 ) * - s ( 0 ) , c ( 2 ) * c ( 1 ) * s ( 0 ) , - s ( 2 ) * s ( 1 ) * s ( 0 ) - c ( 2 ) * c ( 0 ) ; dR . row ( 4 ) << s ( 2 ) * s ( 1 ) * c ( 0 ) + c ( 2 ) * - s ( 0 ) , s ( 2 ) * c ( 1 ) * s ( 0 ) , c ( 2 ) * s ( 1 ) * s ( 0 ) - s ( 2 ) * c ( 0 ) ; dR . row ( 5 ) << c ( 1 ) * c ( 0 ) , - s ( 1 ) * s ( 0 ) , 0 ; dR . row ( 6 ) << c ( 2 ) * s ( 1 ) * - s ( 0 ) + s ( 2 ) * c ( 0 ) , c ( 2 ) * c ( 1 ) * c ( 0 ) , - s ( 2 ) * s ( 1 ) * c ( 0 ) + c ( 2 ) * s ( 0 ) ; dR . row ( 7 ) << s ( 2 ) * s ( 1 ) * - s ( 0 ) - c ( 2 ) * c ( 0 ) , s ( 2 ) * c ( 1 ) * c ( 0 ) , c ( 2 ) * s ( 1 ) * c ( 0 ) + s ( 2 ) * s ( 0 ) ; dR . row ( 8 ) << c ( 1 ) * - s ( 0 ) , - s ( 1 ) * c ( 0 ) , 0 ; return dR ; } template < typename Derived > void normalizeVec ( const Eigen :: MatrixBase < Derived > & x , typename Derived :: PlainObject & x_norm , typename Gradient < Derived , Derived :: RowsAtCompileTime , 1 > :: type * dx_norm , typename Gradient < Derived , Derived :: RowsAtCompileTime , 2 > :: type * ddx_norm ) { typename Derived :: Scalar xdotx = x . squaredNorm ( ) ; typename Derived :: Scalar norm_x = std :: sqrt ( xdotx ) ; x_norm = x / norm_x ; if ( dx_norm ) { dx_norm -> setIdentity ( x . rows ( ) , x . rows ( ) ) ; ( * dx_norm ) -= x * x . transpose ( ) / xdotx ; ( * dx_norm ) /= norm_x ; if ( ddx_norm ) { auto dx_norm_transpose = transposeGrad ( * dx_norm , x . rows ( ) ) ; auto ddx_norm_times_norm = - matGradMultMat ( x_norm , x_norm . transpose ( ) , ( * dx_norm ) , dx_norm_transpose ) ; auto dnorm_inv = - x . transpose ( ) / ( xdotx * norm_x ) ; ( * ddx_norm ) = ddx_norm_times_norm / norm_x ; auto temp = ( * dx_norm ) * norm_x ; typename Derived :: Index n = x . rows ( ) ; for ( int col = 0 ; col < n ; col ++ ) { auto column_as_matrix = ( dnorm_inv ( 0 , col ) * temp ) ; for ( int row_block = 0 ; row_block < n ; row_block ++ ) { ddx_norm -> block ( row_block * n , col , n , 1 ) += column_as_matrix . col ( row_block ) ; } } } } } template < typename Derived > typename Gradient < Matrix < typename Derived :: Scalar , 3 , 3 > , QUAT_SIZE > :: type dquat2rotmat ( const Eigen :: MatrixBase < Derived > & q ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , QUAT_SIZE ) ; typename Gradient < Matrix < typename Derived :: Scalar , 3 , 3 > , QUAT_SIZE > :: type ret ; typename Eigen :: MatrixBase < Derived > :: PlainObject qtilde ; typename Gradient < Derived , QUAT_SIZE > :: type dqtilde ; normalizeVec ( q , qtilde , & dqtilde ) ; typedef typename Derived :: Scalar Scalar ; Scalar w = qtilde ( 0 ) ; Scalar x = qtilde ( 1 ) ; Scalar y = qtilde ( 2 ) ; Scalar z = qtilde ( 3 ) ; ret << w , x , - y , - z , z , y , x , w , - y , z , - w , x , - z , y , x , - w , w , - x , y , - z , x , w , z , y , y , z , w , x , - x , - w , z , y , w , - x , - y , z ; ret *= 2.0 ; ret *= dqtilde ; return ret ; } template < typename DerivedR , typename DerivedDR > typename Gradient < Eigen :: Matrix < typename DerivedR :: Scalar , RPY_SIZE , 1 > , DerivedDR :: ColsAtCompileTime > :: type drotmat2rpy ( const Eigen :: MatrixBase < DerivedR > & R , const Eigen :: MatrixBase < DerivedDR > & dR ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedR > , SPACE_DIMENSION , SPACE_DIMENSION ) ; EIGEN_STATIC_ASSERT ( Eigen :: MatrixBase < DerivedDR > :: RowsAtCompileTime == RotmatSize , THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE ) ; typename DerivedDR :: Index nq = dR . cols ( ) ; typedef typename DerivedR :: Scalar Scalar ; typedef typename Gradient < Eigen :: Matrix < Scalar , RPY_SIZE , 1 > , DerivedDR :: ColsAtCompileTime > :: type ReturnType ; ReturnType drpy ( RPY_SIZE , nq ) ; auto dR11_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 0 , 0 , R . rows ( ) ) ; auto dR21_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 1 , 0 , R . rows ( ) ) ; auto dR31_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 0 , R . rows ( ) ) ; auto dR32_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 1 , R . rows ( ) ) ; auto dR33_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 2 , R . rows ( ) ) ; Scalar sqterm = R ( 2 , 1 ) * R ( 2 , 1 ) + R ( 2 , 2 ) * R ( 2 , 2 ) ; using namespace std ; drpy . row ( 0 ) = ( R ( 2 , 2 ) * dR32_dq - R ( 2 , 1 ) * dR33_dq ) / sqterm ; Scalar sqrt_sqterm = sqrt ( sqterm ) ; drpy . row ( 1 ) = ( - sqrt_sqterm * dR31_dq + R ( 2 , 0 ) / sqrt_sqterm * ( R ( 2 , 1 ) * dR32_dq + R ( 2 , 2 ) * dR33_dq ) ) / ( R ( 2 , 0 ) * R ( 2 , 0 ) + R ( 2 , 1 ) * R ( 2 , 1 ) + R ( 2 , 2 ) * R ( 2 , 2 ) ) ; sqterm = R ( 0 , 0 ) * R ( 0 , 0 ) + R ( 1 , 0 ) * R ( 1 , 0 ) ; drpy . row ( 2 ) = ( R ( 0 , 0 ) * dR21_dq - R ( 1 , 0 ) * dR11_dq ) / sqterm ; return drpy ; } template < typename DerivedR , typename DerivedDR > typename Gradient < Eigen :: Matrix < typename DerivedR :: Scalar , QUAT_SIZE , 1 > , DerivedDR :: ColsAtCompileTime > :: type drotmat2quat ( const Eigen :: MatrixBase < DerivedR > & R , const Eigen :: MatrixBase < DerivedDR > & dR ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedR > , SPACE_DIMENSION , SPACE_DIMENSION ) ; EIGEN_STATIC_ASSERT ( Eigen :: MatrixBase < DerivedDR > :: RowsAtCompileTime == RotmatSize , THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE ) ; typedef typename DerivedR :: Scalar Scalar ; typedef typename Gradient < Eigen :: Matrix < Scalar , QUAT_SIZE , 1 > , DerivedDR :: ColsAtCompileTime > :: type ReturnType ; typename DerivedDR :: Index nq = dR . cols ( ) ; auto dR11_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 0 , 0 , R . rows ( ) ) ; auto dR12_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 0 , 1 , R . rows ( ) ) ; auto dR13_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 0 , 2 , R . rows ( ) ) ; auto dR21_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 1 , 0 , R . rows ( ) ) ; auto dR22_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 1 , 1 , R . rows ( ) ) ; auto dR23_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 1 , 2 , R . rows ( ) ) ; auto dR31_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 0 , R . rows ( ) ) ; auto dR32_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 1 , R . rows ( ) ) ; auto dR33_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 2 , R . rows ( ) ) ; Matrix < Scalar , 4 , 3 > A ; A . row ( 0 ) << 1.0 , 1.0 , 1.0 ; A . row ( 1 ) << 1.0 , - 1.0 , - 1.0 ; A . row ( 2 ) << - 1.0 , 1.0 , - 1.0 ; A . row ( 3 ) << - 1.0 , - 1.0 , 1.0 ; Matrix < Scalar , 4 , 1 > B = A * R . diagonal ( ) ; typename Matrix < Scalar , 4 , 1 > :: Index ind , max_col ; Scalar val = B . maxCoeff ( & ind , & max_col ) ; ReturnType dq ( QUAT_SIZE , nq ) ; using namespace std ; switch ( ind ) { case 0 : { auto dvaldq = dR11_dq + dR22_dq + dR33_dq ; auto dwdq = dvaldq / ( 4.0 * sqrt ( 1.0 + val ) ) ; auto w = sqrt ( 1.0 + val ) / 2.0 ; auto wsquare4 = 4.0 * w * w ; dq . row ( 0 ) = dwdq ; dq . row ( 1 ) = ( ( dR32_dq - dR23_dq ) * w - ( R ( 2 , 1 ) - R ( 1 , 2 ) ) * dwdq ) / wsquare4 ; dq . row ( 2 ) = ( ( dR13_dq - dR31_dq ) * w - ( R ( 0 , 2 ) - R ( 2 , 0 ) ) * dwdq ) / wsquare4 ; dq . row ( 3 ) = ( ( dR21_dq - dR12_dq ) * w - ( R ( 1 , 0 ) - R ( 0 , 1 ) ) * dwdq ) / wsquare4 ; break ; } case 1 : { auto dvaldq = dR11_dq - dR22_dq - dR33_dq ; auto s = 2.0 * sqrt ( 1.0 + val ) ; auto ssquare = s * s ; auto dsdq = dvaldq / sqrt ( 1.0 + val ) ; dq . row ( 0 ) = ( ( dR32_dq - dR23_dq ) * s - ( R ( 2 , 1 ) - R ( 1 , 2 ) ) * dsdq ) / ssquare ; dq . row ( 1 ) = .25 * dsdq ; dq . row ( 2 ) = ( ( dR12_dq + dR21_dq ) * s - ( R ( 0 , 1 ) + R ( 1 , 0 ) ) * dsdq ) / ssquare ; dq . row ( 3 ) = ( ( dR13_dq + dR31_dq ) * s - ( R ( 0 , 2 ) + R ( 2 , 0 ) ) * dsdq ) / ssquare ; break ; } case 2 : { auto dvaldq = - dR11_dq + dR22_dq - dR33_dq ; auto s = 2.0 * ( sqrt ( 1.0 + val ) ) ; auto ssquare = s * s ; auto dsdq = dvaldq / sqrt ( 1.0 + val ) ; dq . row ( 0 ) = ( ( dR13_dq - dR31_dq ) * s - ( R ( 0 , 2 ) - R ( 2 , 0 ) ) * dsdq ) / ssquare ; dq . row ( 1 ) = ( ( dR12_dq + dR21_dq ) * s - ( R ( 0 , 1 ) + R ( 1 , 0 ) ) * dsdq ) / ssquare ; dq . row ( 2 ) = .25 * dsdq ; dq . row ( 3 ) = ( ( dR23_dq + dR32_dq ) * s - ( R ( 1 , 2 ) + R ( 2 , 1 ) ) * dsdq ) / ssquare ; break ; } default : { auto dvaldq = - dR11_dq - dR22_dq + dR33_dq ; auto s = 2.0 * ( sqrt ( 1.0 + val ) ) ; auto ssquare = s * s ; auto dsdq = dvaldq / sqrt ( 1.0 + val ) ; dq . row ( 0 ) = ( ( dR21_dq - dR12_dq ) * s - ( R ( 1 , 0 ) - R ( 0 , 1 ) ) * dsdq ) / ssquare ; dq . row ( 1 ) = ( ( dR13_dq + dR31_dq ) * s - ( R ( 0 , 2 ) + R ( 2 , 0 ) ) * dsdq ) / ssquare ; dq . row ( 2 ) = ( ( dR23_dq + dR32_dq ) * s - ( R ( 1 , 2 ) + R ( 2 , 1 ) ) * dsdq ) / ssquare ; dq . row ( 3 ) = .25 * dsdq ; break ; } } return dq ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > vectorToSkewSymmetric ( const Eigen :: MatrixBase < Derived > & p ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , SPACE_DIMENSION ) ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > ret ; ret << 0.0 , - p ( 2 ) , p ( 1 ) , p ( 2 ) , 0.0 , - p ( 0 ) , - p ( 1 ) , p ( 0 ) , 0.0 ; return ret ; } template < typename DerivedA , typename DerivedB > Eigen :: Matrix < typename DerivedA :: Scalar , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b , const typename Gradient < DerivedA , Eigen :: Dynamic > :: type & da , const typename Gradient < DerivedB , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename DerivedA :: Scalar , 3 , Eigen :: Dynamic > ret ( 3 , da . cols ( ) ) ; ret . noalias ( ) = da . colwise ( ) . cross ( b ) ; ret . noalias ( ) -= db . colwise ( ) . cross ( a ) ; return ret ; } template < typename DerivedQ , typename DerivedM , typename DerivedDM > void angularvel2quatdotMatrix ( const Eigen :: MatrixBase < DerivedQ > & q , Eigen :: MatrixBase < DerivedM > & M , Eigen :: MatrixBase < DerivedDM > * dM ) { M . resize ( QUAT_SIZE , SPACE_DIMENSION ) ; M . row ( 0 ) << - q ( 1 ) , - q ( 2 ) , - q ( 3 ) ; M . row ( 1 ) << q ( 0 ) , q ( 3 ) , - q ( 2 ) ; M . row ( 2 ) << - q ( 3 ) , q ( 0 ) , q ( 1 ) ; M . row ( 3 ) << q ( 2 ) , - q ( 1 ) , q ( 0 ) ; M *= 0.5 ; if ( dM ) { ( * dM ) << 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.5 , 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 ; } } template < typename DerivedQ , typename DerivedM > void quatdot2angularvelMatrix ( const Eigen :: MatrixBase < DerivedQ > & q , Eigen :: MatrixBase < DerivedM > & M , typename Gradient < DerivedM , QUAT_SIZE , 1 > :: type * dM ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedQ > , QUAT_SIZE ) ; EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedM > , SPACE_DIMENSION , QUAT_SIZE ) ; typename DerivedQ :: PlainObject qtilde ; if ( dM ) { typename Gradient < DerivedQ , QUAT_SIZE > :: type dqtilde ; normalizeVec ( q , qtilde , & dqtilde ) ; ( * dM ) << 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , 0.0 ; ( * dM ) *= dqtilde ; } else { normalizeVec ( q , qtilde ) ; } M << - qtilde ( 1 ) , qtilde ( 0 ) , - qtilde ( 3 ) , qtilde ( 2 ) , - qtilde ( 2 ) , qtilde ( 3 ) , qtilde ( 0 ) , - qtilde ( 1 ) , - qtilde ( 3 ) , - qtilde ( 2 ) , qtilde ( 1 ) , qtilde ( 0 ) ; M *= 2.0 ; } template < typename DerivedRPY , typename DerivedPhi , typename DerivedDPhi , typename DerivedDDPhi > void angularvel2rpydotMatrix ( const Eigen :: MatrixBase < DerivedRPY > & rpy , typename Eigen :: MatrixBase < DerivedPhi > & phi , typename Eigen :: MatrixBase < DerivedDPhi > * dphi , typename Eigen :: MatrixBase < DerivedDDPhi > * ddphi ) { phi . resize ( RPY_SIZE , SPACE_DIMENSION ) ; typedef typename DerivedRPY :: Scalar Scalar ; Scalar p = rpy ( 1 ) ; Scalar y = rpy ( 2 ) ; using namespace std ; Scalar sy = sin ( y ) ; Scalar cy = cos ( y ) ; Scalar sp = sin ( p ) ; Scalar cp = cos ( p ) ; Scalar tp = sp / cp ; phi << cy / cp , sy / cp , 0.0 , - sy , cy , 0.0 , cy * tp , tp * sy , 1.0 ; if ( dphi ) { dphi -> resize ( phi . size ( ) , RPY_SIZE ) ; Scalar sp2 = sp * sp ; Scalar cp2 = cp * cp ; ( * dphi ) << 0.0 , ( cy * sp ) / cp2 , - sy / cp , 0.0 , 0.0 , - cy , 0.0 , cy + ( cy * sp2 ) / cp2 , - ( sp * sy ) / cp , 0.0 , ( sp * sy ) / cp2 , cy / cp , 0.0 , 0.0 , - sy , 0.0 , sy + ( sp2 * sy ) / cp2 , ( cy * sp ) / cp , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; if ( ddphi ) { ddphi -> resize ( dphi -> size ( ) , RPY_SIZE ) ; Scalar cp3 = cp2 * cp ; ( * ddphi ) << 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - ( cy * ( cp2 - 2.0 ) ) / cp3 , ( sp * sy ) / ( sp2 - 1.0 ) , 0.0 , 0.0 , 0.0 , 0.0 , ( 2.0 * cy * sp ) / cp3 , sy / ( sp2 - 1.0 ) , 0.0 , ( 2.0 * sy - cp2 * sy ) / cp3 , ( cy * sp ) / cp2 , 0.0 , 0.0 , 0.0 , 0.0 , ( 2.0 * sp * sy ) / cp3 , cy / cp2 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , ( sp * sy ) / ( sp2 - 1.0 ) , - cy / cp , 0.0 , 0.0 , sy , 0.0 , sy / ( sp2 - 1.0 ) , - ( cy * sp ) / cp , 0.0 , ( cy * sp ) / cp2 , - sy / cp , 0.0 , 0.0 , - cy , 0.0 , cy / cp2 , - ( sp * sy ) / cp , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; } } } template < typename Derived > DLLEXPORT GradientVar < typename Derived :: Scalar , Eigen :: Dynamic , SPACE_DIMENSION > angularvel2RepresentationDotMatrix ( int rotation_type , const Eigen :: MatrixBase < Derived > & qrot , int gradient_order ) { GradientVar < typename Derived :: Scalar , Eigen :: Dynamic , SPACE_DIMENSION > ret ( qrot . rows ( ) , SPACE_DIMENSION , qrot . rows ( ) , gradient_order ) ; switch ( rotation_type ) { case 0 : break ; case 1 : { if ( gradient_order > 1 ) { angularvel2rpydotMatrix ( qrot , ret . value ( ) , & ret . gradient ( ) . value ( ) , & ret . gradient ( ) . gradient ( ) . value ( ) ) ; } else if ( gradient_order > 0 ) { angularvel2rpydotMatrix ( qrot , ret . value ( ) , & ret . gradient ( ) . value ( ) , ( MatrixXd * ) nullptr ) ; } else { angularvel2rpydotMatrix ( qrot , ret . value ( ) , ( MatrixXd * ) nullptr , ( MatrixXd * ) nullptr ) ; } break ; } case 2 : { if ( gradient_order > 1 ) { ret . gradient ( ) . gradient ( ) . value ( ) . setZero ( ) ; } if ( gradient_order > 0 ) { angularvel2quatdotMatrix ( qrot , ret . value ( ) , & ret . gradient ( ) . value ( ) ) ; } else { angularvel2quatdotMatrix ( qrot , ret . value ( ) , ( MatrixXd * ) nullptr ) ; } break ; } default : throw std :: runtime_error ( " rotation ▁ representation ▁ type ▁ not ▁ recognized " ) ; } return ret ; } template < typename DerivedRPY , typename DerivedE > void rpydot2angularvelMatrix ( const Eigen :: MatrixBase < DerivedRPY > & rpy , Eigen :: MatrixBase < DerivedE > & E , typename Gradient < DerivedE , RPY_SIZE , 1 > :: type * dE ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedRPY > , RPY_SIZE ) ; EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedE > , SPACE_DIMENSION , RPY_SIZE ) ; typedef typename DerivedRPY :: Scalar Scalar ; Scalar p = rpy ( 1 ) ; Scalar y = rpy ( 2 ) ; Scalar sp = sin ( p ) ; Scalar cp = cos ( p ) ; Scalar sy = sin ( y ) ; Scalar cy = cos ( y ) ; using namespace std ; E << cp * cy , - sy , 0.0 , cp * sy , cy , 0.0 , - sp , 0.0 , 1.0 ; if ( dE ) { ( * dE ) << 0.0 , - sp * cy , - cp * sy , 0.0 , - sp * sy , cp * cy , 0.0 , - cp , 0.0 , 0.0 , 0.0 , - cy , 0.0 , 0.0 , - sy , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; } } template < typename DerivedM > typename TransformSpatial < DerivedM > :: type transformSpatialMotion ( const Eigen :: Transform < typename DerivedM :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedM > & M ) { Eigen :: Matrix < typename DerivedM :: Scalar , TWIST_SIZE , DerivedM :: ColsAtCompileTime > ret ( TWIST_SIZE , M . cols ( ) ) ; ret . template topRows < 3 > ( ) . noalias ( ) = T . linear ( ) * M . template topRows < 3 > ( ) ; ret . template bottomRows < 3 > ( ) . noalias ( ) = - ret . template topRows < 3 > ( ) . colwise ( ) . cross ( T . translation ( ) ) ; ret . template bottomRows < 3 > ( ) . noalias ( ) += T . linear ( ) * M . template bottomRows < 3 > ( ) ; return ret ; } template < typename DerivedF > typename TransformSpatial < DerivedF > :: type transformSpatialForce ( const Eigen :: Transform < typename DerivedF :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedF > & F ) { Eigen :: Matrix < typename DerivedF :: Scalar , TWIST_SIZE , DerivedF :: ColsAtCompileTime > ret ( TWIST_SIZE , F . cols ( ) ) ; ret . template bottomRows < 3 > ( ) . noalias ( ) = T . linear ( ) * F . template bottomRows < 3 > ( ) . eval ( ) ; ret . template topRows < 3 > ( ) = - ret . template bottomRows < 3 > ( ) . colwise ( ) . cross ( T . translation ( ) ) ; ret . template topRows < 3 > ( ) . noalias ( ) += T . linear ( ) * F . template topRows < 3 > ( ) ; return ret ; } template < typename DerivedI > GradientVar < typename DerivedI :: Scalar , TWIST_SIZE , TWIST_SIZE > transformSpatialInertia ( const Eigen :: Transform < typename DerivedI :: Scalar , SPACE_DIMENSION , Eigen :: Isometry > & T_current_to_new , const typename Gradient < typename Eigen :: Transform < typename DerivedI :: Scalar , SPACE_DIMENSION , Eigen :: Isometry > :: MatrixType , Eigen :: Dynamic > :: type * dT_current_to_new , const Eigen :: MatrixBase < DerivedI > & I ) { int gradient_order ; typename DerivedI :: Index nq ; if ( dT_current_to_new ) { gradient_order = 1 ; nq = dT_current_to_new -> cols ( ) ; } else { nq = 0 ; gradient_order = 0 ; } GradientVar < typename DerivedI :: Scalar , TWIST_SIZE , TWIST_SIZE > ret ( TWIST_SIZE , TWIST_SIZE , nq , gradient_order ) ; auto I_half_transformed = transformSpatialForce ( T_current_to_new , I ) ; ret . value ( ) = transformSpatialForce ( T_current_to_new , I_half_transformed . transpose ( ) ) ; if ( gradient_order > 0 ) { auto dI = Eigen :: Matrix < typename DerivedI :: Scalar , DerivedI :: SizeAtCompileTime , Eigen :: Dynamic > :: Zero ( I . size ( ) , nq ) . eval ( ) ; auto dI_half_transformed = dTransformSpatialForce ( T_current_to_new , I , * dT_current_to_new , dI ) ; auto dI_half_transformed_transpose = transposeGrad ( dI_half_transformed , I_half_transformed . rows ( ) ) ; ret . gradient ( ) . value ( ) = dTransformSpatialForce ( T_current_to_new , I_half_transformed . transpose ( ) , * dT_current_to_new , dI_half_transformed_transpose ) ; } return ret ; } template < typename DerivedA , typename DerivedB > typename TransformSpatial < DerivedB > :: type crossSpatialMotion ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b ) { typename TransformSpatial < DerivedB > :: type ret ( TWIST_SIZE , b . cols ( ) ) ; ret . template topRows < 3 > ( ) = - b . template topRows < 3 > ( ) . colwise ( ) . cross ( a . template topRows < 3 > ( ) ) ; ret . template bottomRows < 3 > ( ) = - b . template topRows < 3 > ( ) . colwise ( ) . cross ( a . template bottomRows < 3 > ( ) ) ; ret . template bottomRows < 3 > ( ) -= b . template bottomRows < 3 > ( ) . colwise ( ) . cross ( a . template topRows < 3 > ( ) ) ; return ret ; } template < typename DerivedA , typename DerivedB > typename TransformSpatial < DerivedB > :: type crossSpatialForce ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b ) { typename TransformSpatial < DerivedB > :: type ret ( TWIST_SIZE , b . cols ( ) ) ; ret . template topRows < 3 > ( ) = - b . template topRows < 3 > ( ) . colwise ( ) . cross ( a . template topRows < 3 > ( ) ) ; ret . template topRows < 3 > ( ) -= b . template bottomRows < 3 > ( ) . colwise ( ) . cross ( a . template bottomRows < 3 > ( ) ) ; ret . template bottomRows < 3 > ( ) = - b . template bottomRows < 3 > ( ) . colwise ( ) . cross ( a . template topRows < 3 > ( ) ) ; return ret ; } template < typename DerivedA , typename DerivedB > Eigen :: Matrix < typename DerivedA :: Scalar , TWIST_SIZE , Eigen :: Dynamic > dCrossSpatialMotion ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b , const typename Gradient < DerivedA , Eigen :: Dynamic > :: type & da , const typename Gradient < DerivedB , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename DerivedA :: Scalar , TWIST_SIZE , Eigen :: Dynamic > ret ( TWIST_SIZE , da . cols ( ) ) ; ret . row ( 0 ) = - da . row ( 2 ) * b [ 1 ] + da . row ( 1 ) * b [ 2 ] - a [ 2 ] * db . row ( 1 ) + a [ 1 ] * db . row ( 2 ) ; ret . row ( 1 ) = da . row ( 2 ) * b [ 0 ] - da . row ( 0 ) * b [ 2 ] + a [ 2 ] * db . row ( 0 ) - a [ 0 ] * db . row ( 2 ) ; ret . row ( 2 ) = - da . row ( 1 ) * b [ 0 ] + da . row ( 0 ) * b [ 1 ] - a [ 1 ] * db . row ( 0 ) + a [ 0 ] * db . row ( 1 ) ; ret . row ( 3 ) = - da . row ( 5 ) * b [ 1 ] + da . row ( 4 ) * b [ 2 ] - da . row ( 2 ) * b [ 4 ] + da . row ( 1 ) * b [ 5 ] - a [ 5 ] * db . row ( 1 ) + a [ 4 ] * db . row ( 2 ) - a [ 2 ] * db . row ( 4 ) + a [ 1 ] * db . row ( 5 ) ; ret . row ( 4 ) = da . row ( 5 ) * b [ 0 ] - da . row ( 3 ) * b [ 2 ] + da . row ( 2 ) * b [ 3 ] - da . row ( 0 ) * b [ 5 ] + a [ 5 ] * db . row ( 0 ) - a [ 3 ] * db . row ( 2 ) + a [ 2 ] * db . row ( 3 ) - a [ 0 ] * db . row ( 5 ) ; ret . row ( 5 ) = - da . row ( 4 ) * b [ 0 ] + da . row ( 3 ) * b [ 1 ] - da . row ( 1 ) * b [ 3 ] + da . row ( 0 ) * b [ 4 ] - a [ 4 ] * db . row ( 0 ) + a [ 3 ] * db . row ( 1 ) - a [ 1 ] * db . row ( 3 ) + a [ 0 ] * db . row ( 4 ) ; return ret ; } template < typename DerivedA , typename DerivedB > Eigen :: Matrix < typename DerivedA :: Scalar , TWIST_SIZE , Eigen :: Dynamic > dCrossSpatialForce ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b , const typename Gradient < DerivedA , Eigen :: Dynamic > :: type & da , const typename Gradient < DerivedB , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename DerivedA :: Scalar , TWIST_SIZE , Eigen :: Dynamic > ret ( TWIST_SIZE , da . cols ( ) ) ; ret . row ( 0 ) = da . row ( 2 ) * b [ 1 ] - da . row ( 1 ) * b [ 2 ] + da . row ( 5 ) * b [ 4 ] - da . row ( 4 ) * b [ 5 ] + a [ 2 ] * db . row ( 1 ) - a [ 1 ] * db . row ( 2 ) + a [ 5 ] * db . row ( 4 ) - a [ 4 ] * db . row ( 5 ) ; ret . row ( 1 ) = - da . row ( 2 ) * b [ 0 ] + da . row ( 0 ) * b [ 2 ] - da . row ( 5 ) * b [ 3 ] + da . row ( 3 ) * b [ 5 ] - a [ 2 ] * db . row ( 0 ) + a [ 0 ] * db . row ( 2 ) - a [ 5 ] * db . row ( 3 ) + a [ 3 ] * db . row ( 5 ) ; ret . row ( 2 ) = da . row ( 1 ) * b [ 0 ] - da . row ( 0 ) * b [ 1 ] + da . row ( 4 ) * b [ 3 ] - da . row ( 3 ) * b [ 4 ] + a [ 1 ] * db . row ( 0 ) - a [ 0 ] * db . row ( 1 ) + a [ 4 ] * db . row ( 3 ) - a [ 3 ] * db . row ( 4 ) ; ret . row ( 3 ) = da . row ( 2 ) * b [ 4 ] - da . row ( 1 ) * b [ 5 ] + a [ 2 ] * db . row ( 4 ) - a [ 1 ] * db . row ( 5 ) ; ret . row ( 4 ) = - da . row ( 2 ) * b [ 3 ] + da . row ( 0 ) * b [ 5 ] - a [ 2 ] * db . row ( 3 ) + a [ 0 ] * db . row ( 5 ) ; ret . row ( 5 ) = da . row ( 1 ) * b [ 3 ] - da . row ( 0 ) * b [ 4 ] + a [ 1 ] * db . row ( 3 ) - a [ 0 ] * db . row ( 4 ) ; ret = - ret ; return ret ; } template < typename DerivedS , typename DerivedQdotToV > typename DHomogTrans < DerivedQdotToV > :: type dHomogTrans ( const Eigen :: Transform < typename DerivedQdotToV :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedS > & S , const Eigen :: MatrixBase < DerivedQdotToV > & qdot_to_v ) { const int nq_at_compile_time = DerivedQdotToV :: ColsAtCompileTime ; typename DerivedQdotToV :: Index nq = qdot_to_v . cols ( ) ; auto qdot_to_twist = ( S * qdot_to_v ) . eval ( ) ; const int numel = HOMOGENEOUS_TRANSFORM_SIZE ; Eigen :: Matrix < typename DerivedQdotToV :: Scalar , numel , nq_at_compile_time > ret ( numel , nq ) ; const auto & Rx = T . linear ( ) . col ( 0 ) ; const auto & Ry = T . linear ( ) . col ( 1 ) ; const auto & Rz = T . linear ( ) . col ( 2 ) ; const auto & qdot_to_omega_x = qdot_to_twist . row ( 0 ) ; const auto & qdot_to_omega_y = qdot_to_twist . row ( 1 ) ; const auto & qdot_to_omega_z = qdot_to_twist . row ( 2 ) ; ret . template middleRows < 3 > ( 0 ) = - Rz * qdot_to_omega_y + Ry * qdot_to_omega_z ; ret . row ( 3 ) . setZero ( ) ; ret . template middleRows < 3 > ( 4 ) = Rz * qdot_to_omega_x - Rx * qdot_to_omega_z ; ret . row ( 7 ) . setZero ( ) ; ret . template middleRows < 3 > ( 8 ) = - Ry * qdot_to_omega_x + Rx * qdot_to_omega_y ; ret . row ( 11 ) . setZero ( ) ; ret . template middleRows < 3 > ( 12 ) = T . linear ( ) * qdot_to_twist . bottomRows ( 3 ) ; ret . row ( 15 ) . setZero ( ) ; return ret ; } template < typename DerivedDT > typename DHomogTrans < DerivedDT > :: type dHomogTransInv ( const Eigen :: Transform < typename DerivedDT :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedDT > & dT ) { typename DerivedDT :: Index nq = dT . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_cols = { 3 } ; auto dR = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , R_cols , T . Rows ) ; auto dp = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , p_cols , T . Rows ) ; auto dinvT_R = transposeGrad ( dR , R . rows ( ) ) ; auto dinvT_p = ( - R . transpose ( ) * dp - matGradMult ( dinvT_R , p ) ) . eval ( ) ; const int numel = HOMOGENEOUS_TRANSFORM_SIZE ; Eigen :: Matrix < typename DerivedDT :: Scalar , numel , DerivedDT :: ColsAtCompileTime > ret ( numel , nq ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , dinvT_R , rows , R_cols , T . Rows ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , dinvT_p , rows , p_cols , T . Rows ) ; const int last_row = 3 ; for ( int col = 0 ; col < T . HDim ; col ++ ) { ret . row ( last_row + col * T . Rows ) . setZero ( ) ; } return ret ; } template < typename Scalar , typename DerivedX , typename DerivedDT , typename DerivedDX > typename Gradient < DerivedX , DerivedDX :: ColsAtCompileTime , 1 > :: type dTransformSpatialMotion ( const Eigen :: Transform < Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedX > & X , const Eigen :: MatrixBase < DerivedDT > & dT , const Eigen :: MatrixBase < DerivedDX > & dX ) { assert ( dT . cols ( ) == dX . cols ( ) ) ; typename DerivedDT :: Index nq = dT . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_cols = { 3 } ; auto dR = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , R_cols , T . Rows ) ; auto dp = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , p_cols , T . Rows ) ; typename Gradient < DerivedX , DerivedDX :: ColsAtCompileTime , 1 > :: type ret ( X . size ( ) , nq ) ; std :: array < int , 3 > Xomega_rows = { 0 , 1 , 2 } ; std :: array < int , 3 > Xv_rows = { 3 , 4 , 5 } ; for ( int col = 0 ; col < X . cols ( ) ; col ++ ) { auto Xomega_col = X . template block < 3 , 1 > ( 0 , col ) ; auto Xv_col = X . template block < 3 , 1 > ( 3 , col ) ; auto RXomega_col = ( R * Xomega_col ) . eval ( ) ; std :: array < int , 1 > col_array = { col } ; auto dXomega_col = getSubMatrixGradient < Eigen :: Dynamic > ( dX , Xomega_rows , col_array , X . rows ( ) ) ; auto dXv_col = getSubMatrixGradient < Eigen :: Dynamic > ( dX , Xv_rows , col_array , X . rows ( ) ) ; auto domega_part_col = ( R * dXomega_col + matGradMult ( dR , Xomega_col ) ) . eval ( ) ; auto dv_part_col = ( R * dXv_col + matGradMult ( dR , Xv_col ) ) . eval ( ) ; dv_part_col += dp . colwise ( ) . cross ( RXomega_col ) ; dv_part_col -= domega_part_col . colwise ( ) . cross ( p ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , domega_part_col , Xomega_rows , col_array , X . rows ( ) ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , dv_part_col , Xv_rows , col_array , X . rows ( ) ) ; } return ret ; } template < typename Scalar , typename DerivedX , typename DerivedDT , typename DerivedDX > typename Gradient < DerivedX , DerivedDX :: ColsAtCompileTime > :: type dTransformSpatialForce ( const Eigen :: Transform < Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedX > & X , const Eigen :: MatrixBase < DerivedDT > & dT , const Eigen :: MatrixBase < DerivedDX > & dX ) { assert ( dT . cols ( ) == dX . cols ( ) ) ; typename DerivedDT :: Index nq = dT . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_cols = { 3 } ; auto dR = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , R_cols , T . Rows ) ; auto dp = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , p_cols , T . Rows ) ; typename Gradient < DerivedX , DerivedDX :: ColsAtCompileTime > :: type ret ( X . size ( ) , nq ) ; std :: array < int , 3 > Xomega_rows = { 0 , 1 , 2 } ; std :: array < int , 3 > Xv_rows = { 3 , 4 , 5 } ; for ( int col = 0 ; col < X . cols ( ) ; col ++ ) { auto Xomega_col = X . template block < 3 , 1 > ( 0 , col ) ; auto Xv_col = X . template block < 3 , 1 > ( 3 , col ) ; auto RXv_col = ( R * Xv_col ) . eval ( ) ; std :: array < int , 1 > col_array = { col } ; auto dXomega_col = getSubMatrixGradient < Eigen :: Dynamic > ( dX , Xomega_rows , col_array , X . rows ( ) ) ; auto dXv_col = getSubMatrixGradient < Eigen :: Dynamic > ( dX , Xv_rows , col_array , X . rows ( ) ) ; auto domega_part_col = ( R * dXomega_col ) . eval ( ) ; domega_part_col += matGradMult ( dR , Xomega_col ) ; auto dv_part_col = ( R * dXv_col ) . eval ( ) ; dv_part_col += matGradMult ( dR , Xv_col ) ; domega_part_col += dp . colwise ( ) . cross ( RXv_col ) ; domega_part_col -= dv_part_col . colwise ( ) . cross ( p ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , domega_part_col , Xomega_rows , col_array , X . rows ( ) ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , dv_part_col , Xv_rows , col_array , X . rows ( ) ) ; } return ret ; } template < typename Scalar > DLLEXPORT void cylindrical2cartesian ( const Matrix < Scalar , 3 , 1 > & m_cylinder_axis , const Matrix < Scalar , 3 , 1 > & m_cylinder_x_dir , const Matrix < Scalar , 3 , 1 > & cylinder_origin , const Matrix < Scalar , 6 , 1 > & x_cylinder , const Matrix < Scalar , 6 , 1 > & v_cylinder , Matrix < Scalar , 6 , 1 > & x_cartesian , Matrix < Scalar , 6 , 1 > & v_cartesian , Matrix < Scalar , 6 , 6 > & J , Matrix < Scalar , 6 , 1 > & Jdotv ) { Matrix < Scalar , 3 , 1 > cylinder_axis = m_cylinder_axis / m_cylinder_axis . norm ( ) ; Matrix < Scalar , 3 , 1 > cylinder_x_dir = m_cylinder_x_dir / m_cylinder_x_dir . norm ( ) ; Matrix < Scalar , 3 , 3 > R_cylinder2cartesian ; R_cylinder2cartesian . col ( 0 ) = cylinder_x_dir ; R_cylinder2cartesian . col ( 1 ) = cylinder_axis . cross ( cylinder_x_dir ) ; R_cylinder2cartesian . col ( 2 ) = cylinder_axis ; double radius = x_cylinder ( 0 ) ; double theta = x_cylinder ( 1 ) ; double c_theta = cos ( theta ) ; double s_theta = sin ( theta ) ; double height = x_cylinder ( 2 ) ; double radius_dot = v_cylinder ( 0 ) ; double theta_dot = v_cylinder ( 1 ) ; double height_dot = v_cylinder ( 2 ) ; Matrix < Scalar , 3 , 1 > x_pos_cartesian ; x_pos_cartesian << radius * c_theta , radius * s_theta , height ; x_pos_cartesian = R_cylinder2cartesian * x_pos_cartesian + cylinder_origin ; Matrix < Scalar , 3 , 1 > v_pos_cartesian ; v_pos_cartesian << radius * - s_theta * theta_dot + radius_dot * c_theta , radius * c_theta * theta_dot + radius_dot * s_theta , height_dot ; v_pos_cartesian = R_cylinder2cartesian * v_pos_cartesian ; Vector3d x_rpy_cylinder = x_cylinder . block ( 3 , 0 , 3 , 1 ) ; Matrix < Scalar , 3 , 3 > R_tangent = rpy2rotmat ( x_rpy_cylinder ) ; Matrix < Scalar , 3 , 3 > R_tangent2cylinder ; Matrix < Scalar , 3 , 3 > dR_tangent2cylinder ; Matrix < Scalar , 3 , 3 > ddR_tangent2cylinder ; rotz ( theta - M_PI / 2 , R_tangent2cylinder , dR_tangent2cylinder , ddR_tangent2cylinder ) ; Matrix < Scalar , 3 , 3 > dR_tangent2cylinder_dtheta = dR_tangent2cylinder ; Matrix < Scalar , 3 , 3 > R_cylinder = R_tangent2cylinder * R_tangent ; Matrix < Scalar , 3 , 3 > R_cartesian = R_cylinder2cartesian * R_cylinder ; Matrix < Scalar , 3 , 1 > x_rpy_cartesian = rotmat2rpy ( R_cartesian ) ; x_cartesian . block ( 0 , 0 , 3 , 1 ) = x_pos_cartesian ; x_cartesian . block ( 3 , 0 , 3 , 1 ) = x_rpy_cartesian ; v_cartesian . block ( 0 , 0 , 3 , 1 ) = v_pos_cartesian ; v_cartesian . block ( 3 , 0 , 3 , 1 ) = theta_dot * R_cylinder2cartesian . col ( 2 ) + R_cylinder2cartesian * R_tangent2cylinder * v_cylinder . block ( 3 , 0 , 3 , 1 ) ; J = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; J . block ( 0 , 0 , 3 , 1 ) << c_theta , s_theta , 0 ; J . block ( 0 , 1 , 3 , 1 ) << radius * - s_theta , radius * c_theta , 0 ; J . block ( 0 , 2 , 3 , 1 ) << 0 , 0 , 1 ; J . block ( 0 , 0 , 3 , 3 ) = R_cylinder2cartesian * J . block ( 0 , 0 , 3 , 3 ) ; J . block ( 3 , 1 , 3 , 1 ) = R_cylinder2cartesian . col ( 2 ) ; J . block ( 3 , 3 , 3 , 3 ) = R_cylinder2cartesian * R_tangent2cylinder ; Matrix < Scalar , 3 , 3 > dJ1_dradius = Matrix < Scalar , 3 , 3 > :: Zero ( ) ; dJ1_dradius ( 0 , 1 ) = - s_theta ; dJ1_dradius ( 1 , 1 ) = c_theta ; Matrix < Scalar , 3 , 3 > dJ1_dtheta = Matrix < Scalar , 3 , 3 > :: Zero ( ) ; dJ1_dtheta ( 0 , 0 ) = - s_theta ; dJ1_dtheta ( 0 , 1 ) = - radius * c_theta ; dJ1_dtheta ( 1 , 0 ) = c_theta ; dJ1_dtheta ( 1 , 1 ) = - radius * s_theta ; Jdotv . block ( 0 , 0 , 3 , 1 ) = R_cylinder2cartesian * ( dJ1_dradius * radius_dot + dJ1_dtheta * theta_dot ) * v_cylinder . block ( 0 , 0 , 3 , 1 ) ; Jdotv . block ( 3 , 0 , 3 , 1 ) = R_cylinder2cartesian * dR_tangent2cylinder_dtheta * theta_dot * v_cylinder . block ( 3 , 0 , 3 , 1 ) ; } template < typename Scalar > DLLEXPORT void cartesian2cylindrical ( const Eigen :: Matrix < Scalar , 3 , 1 > & m_cylinder_axis , const Eigen :: Matrix < Scalar , 3 , 1 > & m_cylinder_x_dir , const Eigen :: Matrix < Scalar , 3 , 1 > & cylinder_origin , const Eigen :: Matrix < Scalar , 6 , 1 > & x_cartesian , const Eigen :: Matrix < Scalar , 6 , 1 > & v_cartesian , Eigen :: Matrix < Scalar , 6 , 1 > & x_cylinder , Eigen :: Matrix < Scalar , 6 , 1 > & v_cylinder , Eigen :: Matrix < Scalar , 6 , 6 > & J , Eigen :: Matrix < Scalar , 6 , 1 > & Jdotv ) { Matrix < Scalar , 3 , 1 > cylinder_axis = m_cylinder_axis / m_cylinder_axis . norm ( ) ; Matrix < Scalar , 3 , 1 > cylinder_x_dir = m_cylinder_x_dir / m_cylinder_x_dir . norm ( ) ; Matrix < Scalar , 3 , 3 > R_cylinder2cartesian ; R_cylinder2cartesian . col ( 0 ) = cylinder_x_dir ; R_cylinder2cartesian . col ( 1 ) = cylinder_axis . cross ( cylinder_x_dir ) ; R_cylinder2cartesian . col ( 2 ) = cylinder_axis ; Matrix < Scalar , 3 , 3 > R_cartesian2cylinder = R_cylinder2cartesian . transpose ( ) ; Matrix < Scalar , 3 , 1 > x_pos_cylinder = R_cartesian2cylinder * ( x_cartesian . block ( 0 , 0 , 3 , 1 ) - cylinder_origin ) ; Matrix < Scalar , 3 , 1 > v_pos_cylinder = R_cartesian2cylinder * v_cartesian . block ( 0 , 0 , 3 , 1 ) ; double radius = sqrt ( pow ( x_pos_cylinder ( 0 ) , 2 ) + pow ( x_pos_cylinder ( 1 ) , 2 ) ) ; double radius_dot = ( x_pos_cylinder ( 0 ) * v_pos_cylinder ( 0 ) + x_pos_cylinder ( 1 ) * v_pos_cylinder ( 1 ) ) / radius ; double theta = atan2 ( x_pos_cylinder ( 1 ) , x_pos_cylinder ( 0 ) ) ; double radius_square = pow ( radius , 2 ) ; double radius_cubic = pow ( radius , 3 ) ; double radius_quad = pow ( radius , 4 ) ; double theta_dot = ( - x_pos_cylinder ( 1 ) * v_pos_cylinder ( 0 ) + x_pos_cylinder ( 0 ) * v_pos_cylinder ( 1 ) ) / radius_square ; double height = x_pos_cylinder ( 2 ) ; double height_dot = v_pos_cylinder ( 2 ) ; x_cylinder ( 0 ) = radius ; x_cylinder ( 1 ) = theta ; x_cylinder ( 2 ) = height ; v_cylinder ( 0 ) = radius_dot ; v_cylinder ( 1 ) = theta_dot ; v_cylinder ( 2 ) = height_dot ; Matrix < Scalar , 3 , 3 > R_tangent2cylinder ; Matrix < Scalar , 3 , 3 > dR_tangent2cylinder ; Matrix < Scalar , 3 , 3 > ddR_tangent2cylinder ; rotz ( theta - M_PI / 2 , R_tangent2cylinder , dR_tangent2cylinder , ddR_tangent2cylinder ) ; Matrix < Scalar , 3 , 3 > R_cylinder2tangent = R_tangent2cylinder . transpose ( ) ; Vector3d x_rpy_cartesian = x_cartesian . block ( 3 , 0 , 3 , 1 ) ; Matrix < Scalar , 3 , 3 > R_cartesian = rpy2rotmat ( x_rpy_cartesian ) ; x_cylinder . block ( 3 , 0 , 3 , 1 ) = rotmat2rpy ( R_cylinder2tangent * R_cartesian2cylinder * R_cartesian ) ; J = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; Matrix < Scalar , 6 , 6 > Jdot = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; J ( 0 , 0 ) = x_pos_cylinder ( 0 ) / radius ; J ( 0 , 1 ) = x_pos_cylinder ( 1 ) / radius ; J ( 1 , 0 ) = - x_pos_cylinder ( 1 ) / radius_square ; J ( 1 , 1 ) = x_pos_cylinder ( 0 ) / radius_square ; J ( 2 , 2 ) = 1.0 ; J . block ( 0 , 0 , 3 , 3 ) = J . block ( 0 , 0 , 3 , 3 ) * R_cartesian2cylinder ; Jdot ( 0 , 0 ) = pow ( x_pos_cylinder ( 1 ) , 2 ) / radius_cubic * v_pos_cylinder ( 0 ) - x_pos_cylinder ( 0 ) * x_pos_cylinder ( 1 ) / radius_cubic * v_pos_cylinder ( 1 ) ; Jdot ( 0 , 1 ) = - x_pos_cylinder ( 0 ) * x_pos_cylinder ( 1 ) / radius_cubic * v_pos_cylinder ( 0 ) + pow ( x_pos_cylinder ( 0 ) , 2 ) / radius_cubic * v_pos_cylinder ( 1 ) ; Jdot ( 1 , 0 ) = 2 * x_pos_cylinder ( 0 ) * x_pos_cylinder ( 1 ) / radius_quad * v_pos_cylinder ( 0 ) + ( pow ( x_pos_cylinder ( 1 ) , 2 ) - pow ( x_pos_cylinder ( 0 ) , 2 ) ) / radius_quad * v_pos_cylinder ( 1 ) ; Jdot ( 1 , 1 ) = ( pow ( x_pos_cylinder ( 1 ) , 2 ) - pow ( x_pos_cylinder ( 0 ) , 2 ) ) / radius_quad * v_pos_cylinder ( 0 ) - 2 * x_pos_cylinder ( 0 ) * x_pos_cylinder ( 1 ) / radius_quad * v_pos_cylinder ( 1 ) ; Jdot . block ( 0 , 0 , 3 , 3 ) = Jdot . block ( 0 , 0 , 3 , 3 ) * R_cartesian2cylinder ; v_cylinder . block ( 3 , 0 , 3 , 1 ) = R_cylinder2tangent * R_cartesian2cylinder * v_cartesian . block ( 3 , 0 , 3 , 1 ) - theta_dot * R_cylinder2tangent . col ( 2 ) ; J . block ( 3 , 0 , 3 , 3 ) = R_cylinder2tangent . col ( 2 ) * - J . block ( 1 , 0 , 1 , 3 ) ; J . block ( 3 , 3 , 3 , 3 ) = R_cylinder2tangent * R_cartesian2cylinder ; Jdot . block ( 3 , 0 , 3 , 3 ) = dR_tangent2cylinder . row ( 2 ) . transpose ( ) * - J . block ( 1 , 0 , 1 , 3 ) * theta_dot + R_cylinder2tangent . col ( 2 ) * - Jdot . block ( 1 , 0 , 1 , 3 ) ; Jdot . block ( 3 , 3 , 3 , 3 ) = dR_tangent2cylinder . transpose ( ) * theta_dot * R_cartesian2cylinder ; Jdotv = Jdot * v_cartesian ; } DLLEXPORT GradientVar < double , 3 , 1 > quat2expmap ( const Ref < const Vector4d > & q , int gradient_order ) { double t = sqrt ( 1 - q ( 0 ) * q ( 0 ) ) ; bool is_degenerate = ( t * t < std :: numeric_limits < double > :: epsilon ( ) ) ; double s = is_degenerate ? 2.0 : 2.0 * acos ( q ( 0 ) ) / t ; GradientVar < double , 3 , 1 > ret ( 3 , 1 , 4 , gradient_order ) ; ret . value ( ) = s * q . tail ( 3 ) ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = Matrix < double , 3 , 4 > :: Zero ( ) ; double dsdq1 = is_degenerate ? 0.0 : ( - 2 * t + 2 * acos ( q ( 0 ) ) * q ( 0 ) ) / pow ( t , 3 ) ; ret . gradient ( ) . value ( ) . col ( 0 ) = q . tail ( 3 ) * dsdq1 ; ret . gradient ( ) . value ( ) . block ( 0 , 1 , 3 , 3 ) = Matrix3d :: Identity ( ) * s ; } else if ( gradient_order > 1 ) { throw std :: runtime_error ( " gradient _ order > 1 ▁ is ▁ not ▁ supported ▁ in ▁ quat2expmap " ) ; } return ret ; } DLLEXPORT GradientVar < double , 3 , 1 > flipExpmap ( const Ref < const Vector3d > & expmap , int gradient_order ) { if ( gradient_order > 1 ) { throw std :: runtime_error ( " gradient _ order > 1 ▁ is ▁ not ▁ supported ▁ in ▁ flipExpmap " ) ; } double expmap_norm = expmap . norm ( ) ; bool is_degenerate = ( expmap_norm < std :: numeric_limits < double > :: epsilon ( ) ) ; GradientVar < double , 3 , 1 > ret ( 3 , 1 , 3 , gradient_order ) ; Matrix3d eye3 = Matrix3d :: Identity ( ) ; if ( is_degenerate ) { ret . value ( ) = expmap ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = eye3 ; } } else { ret . value ( ) = expmap - expmap / expmap_norm * 2 * M_PI ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = eye3 - ( expmap_norm * expmap_norm * eye3 - expmap * expmap . transpose ( ) ) / pow ( expmap_norm , 3 ) * 2 * M_PI ; } } return ret ; } DLLEXPORT GradientVar < double , 3 , 1 > unwrapExpmap ( const Ref < const Vector3d > & expmap1 , const Ref < const Vector3d > & expmap2 , int gradient_order ) { auto expmap2_flip = flipExpmap ( expmap2 , gradient_order ) ; double distance1 = ( expmap1 - expmap2 ) . squaredNorm ( ) ; double distance2 = ( expmap1 - expmap2_flip . value ( ) ) . squaredNorm ( ) ; if ( distance1 > distance2 ) { return expmap2_flip ; } else { GradientVar < double , 3 , 1 > ret ( 3 , 1 , 3 , gradient_order ) ; ret . value ( ) = expmap2 ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = Matrix3d :: Identity ( ) ; } return ret ; } } void quat2expmapSequence ( const Ref < const Matrix < double , 4 , Dynamic >> & quat , const Ref < const Matrix < double , 4 , Dynamic >> & quat_dot , Ref < Matrix < double , 3 , Dynamic >> expmap , Ref < Matrix < double , 3 , Dynamic >> expmap_dot ) { DenseIndex N = quat . cols ( ) ; if ( quat_dot . cols ( ) != N ) { throw std :: runtime_error ( " quat _ dot ▁ must ▁ have ▁ the ▁ same ▁ number ▁ of ▁ columns ▁ as ▁ quat ▁ in ▁ quat2expmapSequence " ) ; } expmap . resize ( 3 , N ) ; expmap_dot . resize ( 3 , N ) ; for ( int i = 0 ; i < N ; i ++ ) { auto expmap_grad = quat2expmap ( quat . col ( i ) , 1 ) ; expmap . col ( i ) = expmap_grad . value ( ) ; expmap_dot . col ( i ) = expmap_grad . gradient ( ) . value ( ) * quat_dot . col ( i ) ; if ( i >= 1 ) { auto closest_grad = closestExpmap ( expmap . col ( i - 1 ) , expmap . col ( i ) , 1 ) ; expmap . col ( i ) = closest_grad . value ( ) ; expmap_dot . col ( i ) = closest_grad . gradient ( ) . value ( ) * expmap_dot . col ( i ) ; } } } DLLEXPORT GradientVar < double , 3 , 1 > closestExpmap ( const Ref < const Vector3d > & expmap1 , const Ref < const Vector3d > & expmap2 , int gradient_order ) { if ( gradient_order > 1 ) { throw std :: runtime_error ( " closestExpmap ▁ only ▁ supports ▁ first ▁ order ▁ gradient " ) ; } double expmap1_norm = expmap1 . norm ( ) ; double expmap2_norm = expmap2 . norm ( ) ; GradientVar < double , 3 , 1 > ret ( 3 , 1 , 3 , gradient_order ) ; if ( expmap2_norm < std :: numeric_limits < double > :: epsilon ( ) ) { if ( expmap1_norm > std :: numeric_limits < double > :: epsilon ( ) ) { Vector3d expmap1_axis = expmap1 / expmap1_norm ; int expmap1_round = static_cast < int > ( expmap1_norm / ( 2 * M_PI ) + 0.5 ) ; ret . value ( ) = expmap1_axis * expmap1_round * 2 * M_PI ; if ( ret . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = Matrix3d :: Zero ( ) ; } return ret ; } else { ret . value ( ) = expmap2 ; if ( ret . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = Matrix3d :: Identity ( ) ; } } } else { Vector3d expmap2_axis = expmap2 / expmap2_norm ; Matrix3d dexpmap2_axis_dexpmap2 = ( expmap2_norm * Matrix3d :: Identity ( ) - expmap2 * expmap2 . transpose ( ) / expmap2_norm ) / pow ( expmap2_norm , 2 ) ; double expmap2_closest_k = ( expmap2_axis . transpose ( ) * expmap1 - expmap2_norm ) / ( 2 * M_PI ) ; int expmap2_closest_k1 ; int expmap2_closest_k2 ; if ( expmap2_closest_k > 0 ) { expmap2_closest_k1 = ( int ) expmap2_closest_k ; } else { expmap2_closest_k1 = ( int ) expmap2_closest_k - 1 ; } expmap2_closest_k2 = expmap2_closest_k1 + 1 ; Vector3d expmap2_closest1 = expmap2 + 2 * expmap2_closest_k1 * M_PI * expmap2_axis ; Vector3d expmap2_closest2 = expmap2 + 2 * expmap2_closest_k2 * M_PI * expmap2_axis ; if ( ( expmap2_closest1 - expmap1 ) . norm ( ) < ( expmap2_closest2 - expmap1 ) . norm ( ) ) { ret . value ( ) = expmap2_closest1 ; if ( ret . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = Matrix3d :: Identity ( ) + 2 * dexpmap2_axis_dexpmap2 * ( double ) expmap2_closest_k1 * M_PI ; } return ret ; } else { ret . value ( ) = expmap2_closest2 ; if ( ret . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = Matrix3d :: Identity ( ) + 2 * dexpmap2_axis_dexpmap2 * ( double ) expmap2_closest_k2 * M_PI ; } return ret ; } } return ret ; } template DLLEXPORT void normalizeVec ( const MatrixBase < Vector3d > & x , Vector3d & x_norm , Gradient < Vector3d , 3 , 1 > :: type * , Gradient < Vector3d , 3 , 2 > :: type * ) ; template DLLEXPORT void normalizeVec ( const MatrixBase < Vector4d > & x , Vector4d & x_norm , Gradient < Vector4d , 4 , 1 > :: type * , Gradient < Vector4d , 4 , 2 > :: type * ) ; template DLLEXPORT void normalizeVec ( const MatrixBase < Map < Vector4d > > & x , Vector4d & x_norm , Gradient < Vector4d , 4 , 1 > :: type * , Gradient < Vector4d , 4 , 2 > :: type * ) ; template DLLEXPORT void normalizeVec ( const MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 4 , 1 , false > > & x , Vector4d & x_norm , Gradient < Vector4d , 4 , 1 > :: type * , Gradient < Vector4d , 4 , 2 > :: type * ) ; template DLLEXPORT Vector4d quat2axis ( const MatrixBase < Vector4d > & ) ; template DLLEXPORT Matrix3d quat2rotmat ( const MatrixBase < Vector4d > & q ) ; template DLLEXPORT Matrix3d quat2rotmat ( const MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 4 , 1 , false > > & q ) ; template DLLEXPORT Matrix < Map < Matrix < double , 4 , 1 , 0 , 4 , 1 > const , 0 , Stride < 0 , 0 > > :: Scalar , 3 , 3 , 0 , 3 , 3 > quat2rotmat < Map < Matrix < double , 4 , 1 , 0 , 4 , 1 > const , 0 , Stride < 0 , 0 > > > ( MatrixBase < Map < Matrix < double , 4 , 1 , 0 , 4 , 1 > const , 0 , Stride < 0 , 0 > > > const & ) ; template DLLEXPORT Vector3d quat2rpy ( const MatrixBase < Vector4d > & ) ; template DLLEXPORT Vector4d axis2quat ( const MatrixBase < Vector4d > & ) ; template DLLEXPORT Matrix3d axis2rotmat ( const MatrixBase < Vector4d > & ) ; template DLLEXPORT Vector3d axis2rpy ( const MatrixBase < Vector4d > & ) ; template DLLEXPORT Vector4d rotmat2axis ( const MatrixBase < Matrix3d > & ) ; template DLLEXPORT Vector4d rotmat2quat ( const MatrixBase < Matrix3d > & ) ; template DLLEXPORT Vector3d rotmat2rpy ( const MatrixBase < Matrix3d > & ) ; template DLLEXPORT Eigen :: Matrix < Eigen :: Block < Eigen :: Matrix < double , 4 , 4 , 0 , 4 , 4 > , 3 , 3 , false > :: Scalar , - 1 , 1 , 0 , - 1 , 1 > rotmat2Representation < Eigen :: Block < Eigen :: Matrix < double , 4 , 4 , 0 , 4 , 4 > , 3 , 3 , false > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 4 , 4 , 0 , 4 , 4 > , 3 , 3 , false > > const & , int ) ; template DLLEXPORT GradientVar < double , Eigen :: Dynamic , 1 > rotmat2Representation ( const GradientVar < double , SPACE_DIMENSION , SPACE_DIMENSION > & R , int rotation_type ) ; template DLLEXPORT GradientVar < double , QUAT_SIZE , 1 > expmap2quat ( const MatrixBase < Vector3d > & v , const int gradient_order ) ; template DLLEXPORT GradientVar < double , QUAT_SIZE , 1 > expmap2quat ( const MatrixBase < Map < Vector3d >> & v , const int gradient_order ) ; template DLLEXPORT GradientVar < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > :: Scalar , 4 , 1 > expmap2quat < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > > const & , int ) ; template DLLEXPORT Vector4d rpy2axis ( const Eigen :: MatrixBase < Vector3d > & ) ; template DLLEXPORT Vector4d rpy2quat ( const Eigen :: MatrixBase < Vector3d > & ) ; template DLLEXPORT Matrix3d rpy2rotmat ( const Eigen :: MatrixBase < Vector3d > & ) ; template DLLEXPORT Matrix3d rpy2rotmat ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 3 , 1 , false >> & ) ; template DLLEXPORT Matrix < double , 9 , 3 > drpy2rotmat ( const Eigen :: MatrixBase < Vector3d > & ) ; template DLLEXPORT Matrix < double , 9 , 3 > drpy2rotmat ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 3 , 1 , false >> & ) ; template DLLEXPORT Vector4d quat2axis ( const MatrixBase < Map < Vector4d > > & ) ; template DLLEXPORT Matrix3d quat2rotmat ( const MatrixBase < Map < Vector4d > > & q ) ; template DLLEXPORT Vector3d quat2rpy ( const MatrixBase < Map < Vector4d > > & ) ; template DLLEXPORT Vector4d axis2quat ( const MatrixBase < Map < Vector4d > > & ) ; template DLLEXPORT Matrix3d axis2rotmat ( const MatrixBase < Map < Vector4d > > & ) ; template DLLEXPORT Vector3d axis2rpy ( const MatrixBase < Map < Vector4d > > & ) ; template DLLEXPORT Vector4d rotmat2axis ( const MatrixBase < Map < Matrix3d > > & ) ; template DLLEXPORT Vector4d rotmat2quat ( const MatrixBase < Map < Matrix3d > > & ) ; template DLLEXPORT Vector3d rotmat2rpy ( const MatrixBase < Map < Matrix3d > > & ) ; template DLLEXPORT Vector4d rpy2axis ( const Eigen :: MatrixBase < Map < Vector3d > > & ) ; template DLLEXPORT Vector4d rpy2quat ( const Eigen :: MatrixBase < Map < Vector3d > > & ) ; template DLLEXPORT Matrix3d rpy2rotmat ( const Eigen :: MatrixBase < Map < Vector3d > > & ) ; template DLLEXPORT Matrix < double , 9 , 3 > drpy2rotmat ( const Eigen :: MatrixBase < Map < Vector3d > > & ) ; template DLLEXPORT Matrix < Block < Matrix4d const , 3 , 3 , false > :: Scalar , 4 , 1 , 0 , 4 , 1 > rotmat2quat < Block < Matrix4d const , 3 , 3 , false > > ( MatrixBase < Block < Matrix4d const , 3 , 3 , false > > const & ) ; template DLLEXPORT Eigen :: Matrix < double , TWIST_SIZE , Eigen :: Dynamic > transformSpatialMotion ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , Eigen :: Dynamic > > & ) ; template DLLEXPORT Eigen :: Matrix < double , TWIST_SIZE , 1 > transformSpatialMotion ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & ) ; template DLLEXPORT TransformSpatial < MatrixXd > :: type transformSpatialMotion < MatrixXd > ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < MatrixXd > & ) ; template DLLEXPORT TransformSpatial < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 6 , - 1 , false > > :: type transformSpatialMotion ( const Eigen :: Isometry3d & T , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 6 , - 1 , false > > & M ) ; template DLLEXPORT TransformSpatial < Matrix < double , TWIST_SIZE , Eigen :: Dynamic > > :: type transformSpatialForce < Matrix < double , TWIST_SIZE , Eigen :: Dynamic >> ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < Matrix < double , TWIST_SIZE , Eigen :: Dynamic > > & ) ; template DLLEXPORT TransformSpatial < MatrixXd > :: type transformSpatialForce < MatrixXd > ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < MatrixXd > & ) ; template DLLEXPORT TransformSpatial < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 6 , - 1 , true >> :: type transformSpatialForce ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 6 , - 1 , true > > & ) ; template DLLEXPORT TransformSpatial < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > :: type transformSpatialForce ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & ) ; template DLLEXPORT TransformSpatial < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > const , 6 , 1 , true > > :: type transformSpatialForce ( const Eigen :: Transform < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > const , 6 , 1 , true > :: Scalar , 3 , 1 , 0 > & , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > const , 6 , 1 , true > > & ) ; template DLLEXPORT TransformSpatial < Map < Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 0 , Stride < 0 , 0 > > > :: type transformSpatialForce < Map < Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 0 , Stride < 0 , 0 > >> ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < Map < Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 0 , Stride < 0 , 0 > > > & ) ; template DLLEXPORT GradientVar < double , TWIST_SIZE , TWIST_SIZE > transformSpatialInertia ( const Eigen :: Transform < double , SPACE_DIMENSION , Eigen :: Isometry > & T_current_to_new , const Gradient < Eigen :: Transform < double , SPACE_DIMENSION , Eigen :: Isometry > :: MatrixType , Eigen :: Dynamic > :: type * dT_current_to_new , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , TWIST_SIZE > > & I ) ; template DLLEXPORT GradientVar < double , TWIST_SIZE , TWIST_SIZE > transformSpatialInertia ( const Eigen :: Transform < double , SPACE_DIMENSION , Eigen :: Isometry > & T_current_to_new , const Gradient < Eigen :: Transform < double , SPACE_DIMENSION , Eigen :: Isometry > :: MatrixType , Eigen :: Dynamic > :: type * dT_current_to_new , const Eigen :: MatrixBase < Eigen :: MatrixXd > & I ) ; template DLLEXPORT Eigen :: Matrix < double , TWIST_SIZE , Eigen :: Dynamic > dCrossSpatialMotion ( const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & b , const Gradient < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , TWIST_SIZE , Eigen :: Dynamic > dCrossSpatialForce ( const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & b , const Gradient < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Gradient < Matrix3d , QUAT_SIZE > :: type dquat2rotmat ( const Eigen :: MatrixBase < Vector4d > & ) ; template DLLEXPORT Gradient < Matrix3d , QUAT_SIZE > :: type dquat2rotmat ( const Eigen :: MatrixBase < Map < Vector4d > > & ) ; template DLLEXPORT Gradient < Matrix3d , QUAT_SIZE > :: type dquat2rotmat ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 4 , 1 , false > > & ) ; template DLLEXPORT Gradient < Vector3d , Dynamic > :: type drotmat2rpy ( const Eigen :: MatrixBase < Matrix3d > & , const Eigen :: MatrixBase < Matrix < double , RotmatSize , Dynamic > > & ) ; template DLLEXPORT Gradient < Vector3d , 6 > :: type drotmat2rpy ( const Eigen :: MatrixBase < Matrix3d > & , const Eigen :: MatrixBase < Matrix < double , RotmatSize , 6 > > & ) ; template DLLEXPORT Gradient < Vector4d , Dynamic > :: type drotmat2quat ( const Eigen :: MatrixBase < Matrix3d > & , const Eigen :: MatrixBase < Matrix < double , RotmatSize , Dynamic > > & ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , 3 > vectorToSkewSymmetric ( const Eigen :: MatrixBase < Eigen :: Vector3d > & ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Vector3d > & a , const Eigen :: MatrixBase < Vector3d > & b , const Gradient < Vector3d , Eigen :: Dynamic > :: type & da , const Gradient < Vector3d , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true >> & a , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 3 , 1 , false >> & b , const Gradient < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 3 , 1 , false > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true > > & a , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , 3 , 1 , false > > & b , const Gradient < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , 3 , 1 , false > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false >> & a , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 3 , - 1 , false > , 3 , 1 , true >> & b , const Gradient < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false >> & a , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true >> & b , const Gradient < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true >> & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 >> & b , const Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , 3 , 1 , false >> & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 >> & b , const Gradient < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , 3 , 1 , false > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > :: Scalar , 3 , - 1 , 0 , 3 , - 1 > dcrossProduct < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 3 , 1 , false > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > > const & , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 3 , 1 , false > > const & , Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , - 1 , 1 > :: type const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 3 , 1 , false > , - 1 , 1 > :: type const & ) ; template DLLEXPORT Eigen :: Matrix < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > :: Scalar , 3 , - 1 , 0 , 3 , - 1 > dcrossProduct < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , 3 , 1 , false > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > > const & , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , 3 , 1 , false > > const & , Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , - 1 , 1 > :: type const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , 3 , 1 , false > , - 1 , 1 > :: type const & ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > dcrossProduct < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > , 3 , 1 , true > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > > const & , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > , 3 , 1 , true > > const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , - 1 , 1 > :: type const & , Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > , 3 , 1 , true > , - 1 , 1 > :: type const & ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > dcrossProduct < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , Eigen :: Block < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 > , 3 , 1 , true > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > > const & , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 > , 3 , 1 , true > > const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , - 1 , 1 > :: type const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 > , 3 , 1 , true > , - 1 , 1 > :: type const & ) ; template DLLEXPORT Eigen :: Matrix < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > :: Scalar , 3 , - 1 , 0 , 3 , - 1 > dcrossProduct < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > > const & , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > > const & , Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , - 1 , 1 > :: type const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > , - 1 , 1 > :: type const & ) ; template DLLEXPORT Eigen :: Matrix < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > :: Scalar , 3 , - 1 , 0 , 3 , - 1 > dcrossProduct < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 3 , 1 , false > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > > const & , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 3 , 1 , false > > const & , Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , - 1 , 1 > :: type const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 3 , 1 , false > , - 1 , 1 > :: type const & ) ; template DLLEXPORT DHomogTrans < MatrixXd > :: type dHomogTrans ( const Isometry3d & , const MatrixBase < Matrix < double , TWIST_SIZE , Dynamic > > & , const MatrixBase < MatrixXd > & ) ; template DLLEXPORT DHomogTrans < Matrix < double , HOMOGENEOUS_TRANSFORM_SIZE , Dynamic >> :: type dHomogTransInv ( const Isometry3d & , const MatrixBase < Matrix < double , HOMOGENEOUS_TRANSFORM_SIZE , Dynamic > > & ) ; template DLLEXPORT Gradient < Matrix < double , TWIST_SIZE , Dynamic > , Dynamic , 1 > :: type dTransformSpatialMotion ( const Isometry3d & , const MatrixBase < Matrix < double , TWIST_SIZE , Dynamic > > & , const MatrixBase < Matrix < double , HOMOGENEOUS_TRANSFORM_SIZE , Dynamic > > & , const MatrixBase < MatrixXd > & ) ; template DLLEXPORT Gradient < Matrix < double , TWIST_SIZE , 1 > , Dynamic , 1 > :: type dTransformSpatialMotion ( const Isometry3d & , const MatrixBase < Matrix < double , TWIST_SIZE , 1 > > & , const MatrixBase < Matrix < double , HOMOGENEOUS_TRANSFORM_SIZE , Dynamic > > & , const MatrixBase < Matrix < double , TWIST_SIZE , Eigen :: Dynamic > > & ) ; template DLLEXPORT TransformSpatial < Eigen :: Matrix < double , TWIST_SIZE , 1 >> :: type crossSpatialMotion ( const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & b ) ; template DLLEXPORT TransformSpatial < Eigen :: Matrix < double , TWIST_SIZE , TWIST_SIZE >> :: type crossSpatialMotion ( const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , TWIST_SIZE > > & b ) ; template DLLEXPORT TransformSpatial < Eigen :: Matrix < double , TWIST_SIZE , Eigen :: Dynamic >> :: type crossSpatialMotion ( const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , Eigen :: Dynamic > > & b ) ; template DLLEXPORT TransformSpatial < Eigen :: Matrix < double , TWIST_SIZE , 1 >> :: type crossSpatialForce ( const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & b ) ; template DLLEXPORT TransformSpatial < Eigen :: Matrix < double , TWIST_SIZE , TWIST_SIZE >> :: type crossSpatialForce ( const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , TWIST_SIZE > > & b ) ; template DLLEXPORT Gradient < Matrix < double , TWIST_SIZE , Dynamic > , Dynamic , 1 > :: type dTransformSpatialForce ( const Isometry3d & , const MatrixBase < Matrix < double , TWIST_SIZE , Dynamic > > & , const MatrixBase < Matrix < double , HOMOGENEOUS_TRANSFORM_SIZE , Dynamic > > & , const MatrixBase < MatrixXd > & ) ; template DLLEXPORT Gradient < Matrix < double , TWIST_SIZE , Dynamic > , Dynamic , 1 > :: type dTransformSpatialForce ( const Isometry3d & , const MatrixBase < Matrix < double , TWIST_SIZE , Dynamic > > & , const MatrixBase < MatrixXd > & , const MatrixBase < MatrixXd > & ) ; template DLLEXPORT Gradient < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 6 , - 1 , true > :: ColsAtCompileTime > :: type dTransformSpatialForce ( const Isometry3d & T , const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & X , const Eigen :: MatrixBase < Eigen :: Matrix < double , 16 , - 1 , 0 , 16 , - 1 > > & dT , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 6 , - 1 , true > > & dX ) ; template DLLEXPORT Gradient < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > :: ColsAtCompileTime > :: type dTransformSpatialForce ( const Isometry3d & T , const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 >> & X , const Eigen :: MatrixBase < Eigen :: Matrix < double , 16 , - 1 , 0 , 16 , - 1 >> & dT , const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 >> & dX ) ; template DLLEXPORT void cylindrical2cartesian ( const Matrix < double , 3 , 1 > & cylinder_axis , const Matrix < double , 3 , 1 > & cylinder_x_dir , const Matrix < double , 3 , 1 > & cylinder_origin , const Matrix < double , 6 , 1 > & x_cylinder , const Matrix < double , 6 , 1 > & v_cylinder , Matrix < double , 6 , 1 > & x_cartesian , Matrix < double , 6 , 1 > & v_cartesian , Matrix < double , 6 , 6 > & J , Matrix < double , 6 , 1 > & Jdotv ) ; template DLLEXPORT void cartesian2cylindrical ( const Matrix < double , 3 , 1 > & cylinder_axis , const Matrix < double , 3 , 1 > & cylinder_x_dir , const Matrix < double , 3 , 1 > & cylinder_origin , const Matrix < double , 6 , 1 > & x_cartesian , const Matrix < double , 6 , 1 > & v_cartesian , Matrix < double , 6 , 1 > & x_cylinder , Matrix < double , 6 , 1 > & v_cylinder , Matrix < double , 6 , 6 > & J , Matrix < double , 6 , 1 > & Jdotv ) ; template DLLEXPORT void angularvel2quatdotMatrix ( const Eigen :: MatrixBase < Vector4d > & q , Eigen :: MatrixBase < Matrix < double , QUAT_SIZE , SPACE_DIMENSION > > & M , Eigen :: MatrixBase < Gradient < Matrix < double , QUAT_SIZE , SPACE_DIMENSION > , QUAT_SIZE , 1 > :: type > * dM ) ; template DLLEXPORT void angularvel2quatdotMatrix ( const Eigen :: MatrixBase < Map < Vector4d >> & q , Eigen :: MatrixBase < Matrix < double , QUAT_SIZE , SPACE_DIMENSION > > & M , Eigen :: MatrixBase < Gradient < Matrix < double , QUAT_SIZE , SPACE_DIMENSION > , QUAT_SIZE , 1 > :: type > * dM ) ; template DLLEXPORT void angularvel2quatdotMatrix ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 4 , 1 , false > > & q , Eigen :: MatrixBase < Matrix < double , QUAT_SIZE , SPACE_DIMENSION > > & M , Eigen :: MatrixBase < Gradient < Matrix < double , QUAT_SIZE , SPACE_DIMENSION > , QUAT_SIZE , 1 > :: type > * dM ) ; template DLLEXPORT void angularvel2rpydotMatrix ( const Eigen :: MatrixBase < Vector3d > & rpy , Eigen :: MatrixBase < Matrix < double , RPY_SIZE , SPACE_DIMENSION > > & phi , Eigen :: MatrixBase < Gradient < Matrix < double , RPY_SIZE , SPACE_DIMENSION > , RPY_SIZE , 1 > :: type > * dphi , Eigen :: MatrixBase < Gradient < Matrix < double , RPY_SIZE , SPACE_DIMENSION > , RPY_SIZE , 2 > :: type > * ddphi ) ; template DLLEXPORT void angularvel2rpydotMatrix ( const Eigen :: MatrixBase < Vector3d > & rpy , Eigen :: MatrixBase < Matrix < double , RPY_SIZE , SPACE_DIMENSION > > & phi , Eigen :: MatrixBase < Matrix < double , Eigen :: Dynamic , Eigen :: Dynamic > > * dphi , Eigen :: MatrixBase < Matrix < double , Eigen :: Dynamic , Eigen :: Dynamic > > * ddphi ) ; template DLLEXPORT void rpydot2angularvelMatrix ( const Eigen :: MatrixBase < Vector3d > & rpy , Eigen :: MatrixBase < Eigen :: Matrix < double , SPACE_DIMENSION , RPY_SIZE > > & E , Gradient < Matrix < double , SPACE_DIMENSION , RPY_SIZE > , RPY_SIZE , 1 > :: type * dE ) ; template DLLEXPORT void rpydot2angularvelMatrix ( const Eigen :: MatrixBase < Map < Vector3d >> & rpy , Eigen :: MatrixBase < Eigen :: Matrix < double , SPACE_DIMENSION , RPY_SIZE > > & E , Gradient < Matrix < double , SPACE_DIMENSION , RPY_SIZE > , RPY_SIZE , 1 > :: type * dE ) ; template DLLEXPORT void rpydot2angularvelMatrix ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 3 , 1 , false > > & rpy , Eigen :: MatrixBase < Eigen :: Matrix < double , SPACE_DIMENSION , RPY_SIZE > > & E , Gradient < Matrix < double , SPACE_DIMENSION , RPY_SIZE > , RPY_SIZE , 1 > :: type * dE ) ; template DLLEXPORT GradientVar < double , Eigen :: Dynamic , SPACE_DIMENSION > angularvel2RepresentationDotMatrix ( int rotation_type , const Eigen :: MatrixBase < VectorXd > & qrot , int gradient_order ) ; template DLLEXPORT GradientVar < double , Eigen :: Dynamic , SPACE_DIMENSION > angularvel2RepresentationDotMatrix ( int rotation_type , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , - 1 , 1 , false > > & qrot , int gradient_order ) ; template DLLEXPORT GradientVar < double , - 1 , 3 > angularvel2RepresentationDotMatrix < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , - 1 , 1 , false > > ( int , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , - 1 , 1 , false > > const & , int ) ; template DLLEXPORT GradientVar < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , - 1 , 1 , false > :: Scalar , - 1 , 3 > angularvel2RepresentationDotMatrix < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , - 1 , 1 , false > > ( int , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , - 1 , 1 , false > > const & , int ) ; template DLLEXPORT GradientVar < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , - 1 , 1 , false > :: Scalar , - 1 , 3 > angularvel2RepresentationDotMatrix < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , - 1 , 1 , false > > ( int , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , - 1 , 1 , false > > const & , int ) ; template DLLEXPORT void quatdot2angularvelMatrix ( const Eigen :: MatrixBase < Vector4d > & q , Eigen :: MatrixBase < Matrix < double , SPACE_DIMENSION , QUAT_SIZE > > & M , Gradient < Matrix < double , SPACE_DIMENSION , QUAT_SIZE > , QUAT_SIZE , 1 > :: type * dM ) ; template DLLEXPORT void quatdot2angularvelMatrix ( const Eigen :: MatrixBase < Map < Vector4d >> & q , Eigen :: MatrixBase < Matrix < double , SPACE_DIMENSION , QUAT_SIZE > > & M , Gradient < Matrix < double , SPACE_DIMENSION , QUAT_SIZE > , QUAT_SIZE , 1 > :: type * dM ) ; template DLLEXPORT void quatdot2angularvelMatrix ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 4 , 1 , false > > & q , Eigen :: MatrixBase < Matrix < double , SPACE_DIMENSION , QUAT_SIZE > > & M , Gradient < Matrix < double , SPACE_DIMENSION , QUAT_SIZE > , QUAT_SIZE , 1 > :: type * dM ) ; </DOCUMENT>
<DOCUMENT_ID="MestreLion/boinc-debian/tree/master/clientgui/BOINCGUIApp.cpp"> # if defined ( __GNUG__ ) && ! defined ( __APPLE__ ) # pragma implementation " BOINCGUIApp . h " # endif # ifdef __WXMAC__ # include < Carbon / Carbon . h > # include " filesys . h " # include " util . h " # if ( defined ( SANDBOX ) && defined ( _DEBUG ) ) # include " SetupSecurity . h " # endif # include " sandbox . h " # endif # include " stdwx . h " # include " diagnostics . h " # include " network . h " # include " util . h " # include " mfile . h " # include " miofile . h " # include " parse . h " # include " idlemon . h " # include " Events . h " # include " common / wxFlatNotebook . h " # include " BOINCInternetFSHandler . h " # include " LogBOINC . h " # include " BOINCGUIApp . h " # include " SkinManager . h " # include " MainDocument . h " # include " BOINCClientManager . h " # include " BOINCTaskBar . h " # include " BOINCBaseFrame . h " # include " AdvancedFrame . h " # include " DlgExitMessage . h " # include " DlgEventLog . h " # include " procinfo . h " # include " sg _ BoincSimpleFrame . h " DEFINE_EVENT_TYPE ( wxEVT_RPC_FINISHED ) IMPLEMENT_APP ( CBOINCGUIApp ) IMPLEMENT_DYNAMIC_CLASS ( CBOINCGUIApp , wxApp ) BEGIN_EVENT_TABLE ( CBOINCGUIApp , wxApp ) EVT_ACTIVATE_APP ( CBOINCGUIApp :: OnActivateApp ) EVT_RPC_FINISHED ( CBOINCGUIApp :: OnRPCFinished ) END_EVENT_TABLE ( ) bool s_bSkipExitConfirmation = false ; # ifdef __WXMAC__ OSErr QuitAppleEventHandler ( const AppleEvent * appleEvt , AppleEvent * reply , UInt32 refcon ) { DescType senderType ; Size actualSize ; ProcessSerialNumber SenderPSN ; ProcessInfoRec pInfo ; FSSpec fileSpec ; OSStatus anErr ; if ( wxGetApp ( ) . IsModalDialogDisplayed ( ) ) { SysBeep ( 4 ) ; return userCanceledErr ; } anErr = AEGetAttributePtr ( appleEvt , keyAddressAttr , typeProcessSerialNumber , & senderType , & SenderPSN , sizeof ( SenderPSN ) , & actualSize ) ; if ( anErr == noErr ) { pInfo . processInfoLength = sizeof ( ProcessInfoRec ) ; pInfo . processName = NULL ; pInfo . processAppSpec = & fileSpec ; anErr = GetProcessInformation ( & SenderPSN , & pInfo ) ; if ( ( pInfo . processSignature != ' dock ' ) && ( pInfo . processSignature != ' BNC ! ' ) ) { s_bSkipExitConfirmation = true ; wxGetApp ( ) . ExitMainLoop ( ) ; } } return wxGetApp ( ) . MacHandleAEQuit ( ( AppleEvent * ) appleEvt , reply ) ; } # endif bool CBOINCGUIApp :: OnInit ( ) { # ifdef SANDBOX g_use_sandbox = true ; # else g_use_sandbox = false ; # endif s_bSkipExitConfirmation = false ; m_bFilterEvents = false ; m_pLocale = NULL ; m_pSkinManager = NULL ; m_pFrame = NULL ; m_pDocument = NULL ; m_pTaskBarIcon = NULL ; m_pEventLog = NULL ; # ifdef __WXMAC__ m_pMacSystemMenu = NULL ; # endif m_strBOINCMGRExecutableName = wxEmptyString ; m_strBOINCMGRRootDirectory = wxEmptyString ; m_strBOINCMGRDataDirectory = wxEmptyString ; m_strHostNameArg = wxEmptyString ; m_strPasswordArg = wxEmptyString ; m_iRPCPortArg = GUI_RPC_PORT ; m_strBOINCArguments = wxEmptyString ; m_bGUIVisible = true ; m_bDebugSkins = false ; m_bMultipleInstancesOK = false ; m_bBOINCMGRAutoStarted = false ; m_iBOINCMGRDisableAutoStart = 0 ; m_iShutdownCoreClient = 0 ; m_iDisplayExitDialog = 1 ; m_iGUISelected = BOINC_SIMPLEGUI ; m_bSafeMessageBoxDisplayed = 0 ; # ifdef __WXMSW__ m_hClientLibraryDll = NULL ; # endif int iErrorCode = 0 ; int iSelectedLanguage = 0 ; bool bOpenEventLog = false ; wxString strDesiredSkinName = wxEmptyString ; wxString strDialogMessage = wxEmptyString ; bool success = false ; # ifdef __WXMSW__ wxSystemOptions :: SetOption ( wxT ( " msw . staticbox . optimized - paint " ) , 0 ) ; # endif # ifdef __WXMAC__ wxSystemOptions :: SetOption ( wxT ( " mac . listctrl . always _ use _ generic " ) , 1 ) ; AEInstallEventHandler ( kCoreEventClass , kAEQuitApplication , NewAEEventHandlerUPP ( ( AEEventHandlerProcPtr ) QuitAppleEventHandler ) , 0 , false ) ; GetCurrentProcess ( & m_psnCurrentProcess ) ; # endif if ( ! wxApp :: OnInit ( ) ) { return false ; } if ( g_use_sandbox ) { wxCHANGE_UMASK ( 2 ) ; } SetAppName ( wxT ( " BOINC ▁ Manager " ) ) ; SetVendorName ( wxT ( " Space ▁ Sciences ▁ Laboratory , ▁ U . C . ▁ Berkeley " ) ) ; m_pConfig = new wxConfig ( GetAppName ( ) ) ; wxConfigBase :: Set ( m_pConfig ) ; wxASSERT ( m_pConfig ) ; m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Read ( wxT ( " AutomaticallyShutdownClient " ) , & m_iShutdownCoreClient , 0L ) ; m_pConfig -> Read ( wxT ( " DisplayShutdownClientDialog " ) , & m_iDisplayExitDialog , 1L ) ; m_pConfig -> Read ( wxT ( " DisableAutoStart " ) , & m_iBOINCMGRDisableAutoStart , 0L ) ; m_pConfig -> Read ( wxT ( " Language " ) , & iSelectedLanguage , 0L ) ; m_pConfig -> Read ( wxT ( " GUISelection " ) , & m_iGUISelected , BOINC_SIMPLEGUI ) ; m_pConfig -> Read ( wxT ( " EventLogOpen " ) , & bOpenEventLog ) ; if ( m_bBOINCMGRAutoStarted && m_iBOINCMGRDisableAutoStart ) { return false ; } DetectExecutableName ( ) ; DetectRootDirectory ( ) ; DetectDataDirectory ( ) ; if ( ! GetDataDirectory ( ) . IsEmpty ( ) ) { success = wxSetWorkingDirectory ( GetDataDirectory ( ) ) ; if ( ! success ) { if ( ! g_use_sandbox ) { if ( ! wxDirExists ( GetDataDirectory ( ) ) ) { success = wxMkdir ( GetDataDirectory ( ) , 0777 ) ; } } } } if ( ! success ) iErrorCode = - 1016 ; int dwDiagnosticsFlags = BOINC_DIAG_DUMPCALLSTACKENABLED | BOINC_DIAG_HEAPCHECKENABLED | BOINC_DIAG_MEMORYLEAKCHECKENABLED | # if defined ( __WXMSW__ ) || defined ( __WXMAC__ ) BOINC_DIAG_REDIRECTSTDERR | BOINC_DIAG_REDIRECTSTDOUT | # endif BOINC_DIAG_TRACETOSTDOUT ; diagnostics_init ( dwDiagnosticsFlags , " stdoutgui " , " stderrgui " ) ; m_pLog = new wxLogBOINC ( ) ; wxLog :: SetActiveTarget ( m_pLog ) ; m_pLog -> AddTraceMask ( wxT ( " Function ▁ Start / End " ) ) ; m_pLog -> AddTraceMask ( wxT ( " Function ▁ Status " ) ) ; # ifdef __WXMSW__ _configthreadlocale ( _ENABLE_PER_THREAD_LOCALE ) ; # endif m_pLocale = new wxLocale ( ) ; wxASSERT ( m_pLocale ) ; m_pLocale -> Init ( iSelectedLanguage ) ; if ( ! m_strBOINCMGRRootDirectory . IsEmpty ( ) ) { m_pLocale -> AddCatalogLookupPathPrefix ( wxString ( m_strBOINCMGRRootDirectory + wxT ( " locale " ) ) ) ; } m_pLocale -> AddCatalogLookupPathPrefix ( wxT ( " locale " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Manager " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Client " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Web " ) ) ; InitSupportedLanguages ( ) ; wxHelpProvider :: Set ( new wxHelpControllerHelpProvider ( ) ) ; wxInitAllImageHandlers ( ) ; wxFileSystem :: AddHandler ( new wxMemoryFSHandler ) ; m_pInternetFSHandler = new CBOINCInternetFSHandler ; wxFileSystem :: AddHandler ( m_pInternetFSHandler ) ; m_pSkinManager = new CSkinManager ( m_bDebugSkins ) ; wxASSERT ( m_pSkinManager ) ; m_pConfig -> Read ( wxT ( " Skin " ) , & strDesiredSkinName , m_pSkinManager -> GetDefaultSkinName ( ) ) ; m_pSkinManager -> ReloadSkin ( strDesiredSkinName ) ; # ifdef SANDBOX char path_to_error [ MAXPATHLEN ] ; path_to_error [ 0 ] = ' \0' ; if ( ! iErrorCode ) { # if ( defined ( __WXMAC__ ) && defined ( _DEBUG ) ) if ( check_security ( g_use_sandbox , true ) ) { CreateBOINCUsersAndGroups ( ) ; SetBOINCDataOwnersGroupsAndPermissions ( ) ; SetBOINCAppOwnersGroupsAndPermissions ( NULL ) ; } # endif iErrorCode = check_security ( g_use_sandbox , true , path_to_error ) ; } if ( iErrorCode ) { ShowApplication ( true ) ; if ( iErrorCode == - 1099 ) { strDialogMessage . Printf ( _ ( " You ▁ currently ▁ are ▁ not ▁ authorized ▁ to ▁ manage ▁ the ▁ client . \n \n To ▁ run ▁ % s ▁ as ▁ this ▁ user , ▁ please : \n ▁ ▁ - ▁ reinstall ▁ % s ▁ answering ▁ \ " Yes\ " ▁ to ▁ the ▁ question ▁ about \n ▁ ▁ ▁ ▁ ▁ non - administrative ▁ users \n ▁ or \n ▁ ▁ - ▁ contact ▁ your ▁ administrator ▁ to ▁ add ▁ you ▁ to ▁ the ▁ ' boinc _ master ' \n ▁ ▁ ▁ ▁ ▁ user ▁ group . " ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) ) ; } else { strDialogMessage . Printf ( _ ( " % s ▁ ownership ▁ or ▁ permissions ▁ are ▁ not ▁ set ▁ properly ; ▁ please ▁ reinstall ▁ % s . \n ( Error ▁ code ▁ % d " ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , iErrorCode ) ; if ( path_to_error [ 0 ] ) { strDialogMessage += _ ( " ▁ at ▁ " ) ; strDialogMessage += wxString :: FromUTF8 ( path_to_error ) ; } strDialogMessage += _ ( " ) " ) ; fprintf ( stderr , " % ls ▁ ownership ▁ or ▁ permissions ▁ are ▁ not ▁ set ▁ properly ; ▁ please ▁ reinstall ▁ % ls . \n ( Error ▁ code ▁ % d ▁ at ▁ % s ) " , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , iErrorCode , path_to_error ) ; } wxMessageDialog * pDlg = new wxMessageDialog ( NULL , strDialogMessage , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , wxOK ) ; pDlg -> ShowModal ( ) ; if ( pDlg ) pDlg -> Destroy ( ) ; return false ; } # endif # ifdef __WXMSW__ wxString strRebootPendingFile = GetRootDirectory ( ) + wxFileName :: GetPathSeparator ( ) + wxT ( " RebootPending . txt " ) ; if ( wxFile :: Exists ( strRebootPendingFile ) ) { wxMessageDialog dialog ( NULL , _ ( " A ▁ reboot ▁ is ▁ required ▁ in ▁ order ▁ for ▁ BOINC ▁ to ▁ run ▁ properly . \n Please ▁ reboot ▁ your ▁ computer ▁ and ▁ try ▁ again . " ) , _ ( " BOINC ▁ Manager " ) , wxOK | wxICON_ERROR ) ; dialog . ShowModal ( ) ; return false ; } # endif if ( ! m_bMultipleInstancesOK ) { if ( DetectDuplicateInstance ( ) ) { return false ; } } m_pDocument = new CMainDocument ( ) ; wxASSERT ( m_pDocument ) ; m_pDocument -> OnInit ( ) ; if ( BOINC_SIMPLEGUI == m_iGUISelected ) { if ( wxGetDisplaySize ( ) . GetHeight ( ) < 600 ) { m_iGUISelected = BOINC_ADVANCEDGUI ; } } m_pTaskBarIcon = new CTaskBarIcon ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationDisconnectedIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationSnoozeIcon ( ) ) ; wxASSERT ( m_pTaskBarIcon ) ; # ifdef __WXMAC__ m_pMacSystemMenu = new CMacSystemMenu ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationDisconnectedIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationSnoozeIcon ( ) ) ; wxASSERT ( m_pMacSystemMenu ) ; # endif IdleTrackerAttach ( ) ; # ifdef __WXMAC__ ProcessSerialNumber psn ; ProcessInfoRec pInfo ; OSStatus err ; memset ( & pInfo , 0 , sizeof ( pInfo ) ) ; pInfo . processInfoLength = sizeof ( ProcessInfoRec ) ; err = GetProcessInformation ( & m_psnCurrentProcess , & pInfo ) ; if ( ! err ) { psn = pInfo . processLauncher ; memset ( & pInfo , 0 , sizeof ( pInfo ) ) ; pInfo . processInfoLength = sizeof ( ProcessInfoRec ) ; err = GetProcessInformation ( & psn , & pInfo ) ; } if ( pInfo . processSignature == ' lgnw ' ) { m_bGUIVisible = false ; sleep ( 10 ) ; } # endif SetActiveGUI ( m_iGUISelected , false ) ; if ( m_bGUIVisible ) { SetActiveGUI ( m_iGUISelected ) ; } else { ShowApplication ( false ) ; } if ( bOpenEventLog ) { DisplayEventLog ( m_bGUIVisible ) ; m_pFrame -> Raise ( ) ; } return true ; } int CBOINCGUIApp :: OnExit ( ) { IdleTrackerDetach ( ) ; if ( m_pDocument ) { m_pDocument -> OnExit ( ) ; delete m_pDocument ; m_pDocument = NULL ; } m_pConfig -> SetPath ( wxT ( " / " ) ) ; if ( m_pSkinManager ) { m_pConfig -> Write ( wxT ( " Skin " ) , m_pSkinManager -> GetSelectedSkin ( ) ) ; delete m_pSkinManager ; } if ( m_pLocale ) { delete m_pLocale ; m_pLocale = NULL ; } if ( m_pEventLog ) { m_pEventLog -> Destroy ( ) ; m_pEventLog = NULL ; } m_pConfig -> Write ( wxT ( " AutomaticallyShutdownClient " ) , m_iShutdownCoreClient ) ; m_pConfig -> Write ( wxT ( " DisplayShutdownClientDialog " ) , m_iDisplayExitDialog ) ; m_pConfig -> Write ( wxT ( " DisableAutoStart " ) , m_iBOINCMGRDisableAutoStart ) ; diagnostics_finish ( ) ; return wxApp :: OnExit ( ) ; } void CBOINCGUIApp :: OnInitCmdLine ( wxCmdLineParser & parser ) { wxApp :: OnInitCmdLine ( parser ) ; static const wxCmdLineEntryDesc cmdLineDesc [ ] = { { wxCMD_LINE_SWITCH , wxT ( " a " ) , wxT ( " autostart " ) , _ ( " BOINC ▁ Manager ▁ was ▁ started ▁ by ▁ the ▁ operating ▁ system ▁ automatically " ) } , # if defined ( __WXMSW__ ) || defined ( __WXMAC__ ) { wxCMD_LINE_SWITCH , wxT ( " s " ) , wxT ( " systray " ) , _ ( " Startup ▁ BOINC ▁ so ▁ only ▁ the ▁ system ▁ tray ▁ icon ▁ is ▁ visible " ) } , # else { wxCMD_LINE_OPTION , wxT ( " e " ) , wxT ( " clientdir " ) , _ ( " Directory ▁ containing ▁ the ▁ BOINC ▁ Client ▁ executable " ) } , { wxCMD_LINE_OPTION , wxT ( " d " ) , wxT ( " datadir " ) , _ ( " BOINC ▁ data ▁ directory " ) } , # endif { wxCMD_LINE_OPTION , wxT ( " n " ) , wxT ( " namehost " ) , _ ( " Host ▁ name ▁ or ▁ IP ▁ address " ) } , { wxCMD_LINE_OPTION , wxT ( " g " ) , wxT ( " gui _ rpc _ port " ) , _ ( " GUI ▁ RPC ▁ port ▁ number " ) } , { wxCMD_LINE_OPTION , wxT ( " p " ) , wxT ( " password " ) , _ ( " Password " ) } , { wxCMD_LINE_OPTION , wxT ( " b " ) , wxT ( " boincargs " ) , _ ( " Startup ▁ BOINC ▁ with ▁ these ▁ optional ▁ arguments " ) } , { wxCMD_LINE_SWITCH , wxT ( " i " ) , wxT ( " insecure " ) , _ ( " disable ▁ BOINC ▁ security ▁ users ▁ and ▁ permissions " ) } , { wxCMD_LINE_SWITCH , wxT ( " c " ) , wxT ( " checkskins " ) , _ ( " set ▁ skin ▁ debugging ▁ mode ▁ to ▁ enable ▁ skin ▁ manager ▁ error ▁ messages " ) } , { wxCMD_LINE_SWITCH , wxT ( " m " ) , wxT ( " multiple " ) , _ ( " multiple ▁ instances ▁ of ▁ BOINC ▁ Manager ▁ allowed " ) } , # if ( defined ( __WXMAC__ ) && defined ( _DEBUG ) ) { wxCMD_LINE_OPTION , wxT ( " NSDocumentRevisionsDebugMode " ) , NULL , _ ( " Not ▁ used : ▁ workaround ▁ for ▁ bug ▁ in ▁ XCode ▁ 4.2" ) } , # endif { wxCMD_LINE_NONE } } ; parser . SetDesc ( cmdLineDesc ) ; } bool CBOINCGUIApp :: OnCmdLineParsed ( wxCmdLineParser & parser ) { wxApp :: OnCmdLineParsed ( parser ) ; wxString portNum = wxEmptyString ; long longPort ; bool hostNameSpecified = false ; bool passwordSpecified = false ; parser . Found ( wxT ( " boincargs " ) , & m_strBOINCArguments ) ; if ( parser . Found ( wxT ( " autostart " ) ) ) { m_bBOINCMGRAutoStarted = true ; } # if defined ( __WXMSW__ ) || defined ( __WXMAC__ ) if ( parser . Found ( wxT ( " systray " ) ) ) { m_bGUIVisible = false ; } # endif if ( parser . Found ( wxT ( " insecure " ) ) ) { g_use_sandbox = false ; } if ( parser . Found ( wxT ( " checkskins " ) ) ) { m_bDebugSkins = true ; } if ( parser . Found ( wxT ( " multiple " ) ) ) { m_bMultipleInstancesOK = true ; } # if ! ( defined ( __WXMSW__ ) || defined ( __WXMAC__ ) ) if ( ! parser . Found ( wxT ( " clientdir " ) , & m_strBOINCMGRRootDirectory ) ) { m_strBOINCMGRRootDirectory = :: wxGetCwd ( ) ; } if ( m_strBOINCMGRRootDirectory . Last ( ) != ' / ' ) { m_strBOINCMGRRootDirectory . Append ( ' / ' ) ; } if ( ! parser . Found ( wxT ( " datadir " ) , & m_strBOINCMGRDataDirectory ) ) { m_strBOINCMGRDataDirectory = m_strBOINCMGRRootDirectory ; } if ( m_strBOINCMGRDataDirectory . Last ( ) != ' / ' ) { m_strBOINCMGRDataDirectory . Append ( ' / ' ) ; } # endif if ( parser . Found ( wxT ( " namehost " ) , & m_strHostNameArg ) ) { hostNameSpecified = true ; } else { m_strHostNameArg = wxT ( " localhost " ) ; } if ( parser . Found ( wxT ( " gui _ rpc _ port " ) , & portNum ) ) { if ( portNum . ToLong ( & longPort ) ) { m_iRPCPortArg = longPort ; } else { m_iRPCPortArg = GUI_RPC_PORT ; } } else { m_iRPCPortArg = GUI_RPC_PORT ; } if ( parser . Found ( wxT ( " password " ) , & m_strPasswordArg ) ) { passwordSpecified = true ; } else { m_strPasswordArg = wxEmptyString ; } if ( hostNameSpecified && passwordSpecified ) { m_bMultipleInstancesOK = true ; } return true ; } bool CBOINCGUIApp :: DetectDuplicateInstance ( ) { # ifdef __WXMSW__ if ( CTaskBarIcon :: FireAppRestore ( ) ) { return true ; } # endif # ifdef __WXMAC__ ProcessSerialNumber PSN ; int iInstanceID = wxGetApp ( ) . IsAnotherInstanceRunning ( ) ; if ( iInstanceID ) { OSStatus err = GetProcessForPID ( iInstanceID , & PSN ) ; if ( ! err ) SetFrontProcess ( & PSN ) ; return true ; } # endif return false ; } void CBOINCGUIApp :: DetectExecutableName ( ) { # ifdef __WXMSW__ TCHAR szPath [ MAX_PATH - 1 ] ; GetModuleFileName ( NULL , szPath , ( sizeof ( szPath ) / sizeof ( TCHAR ) ) ) ; TCHAR * pszProg = _tcsrchr ( szPath , ' \\ ' ) ; if ( pszProg ) { pszProg ++ ; } m_strBOINCMGRExecutableName = pszProg ; # endif } void CBOINCGUIApp :: DetectRootDirectory ( ) { # ifdef __WXMSW__ TCHAR szPath [ MAX_PATH - 1 ] ; GetModuleFileName ( NULL , szPath , ( sizeof ( szPath ) / sizeof ( TCHAR ) ) ) ; TCHAR * pszProg = _tcsrchr ( szPath , ' \\ ' ) ; if ( pszProg ) { szPath [ pszProg - szPath + 1 ] = 0 ; } m_strBOINCMGRRootDirectory = szPath ; # endif } void CBOINCGUIApp :: DetectDataDirectory ( ) { # ifdef __WXMSW__ LONG lReturnValue ; HKEY hkSetupHive ; LPTSTR lpszRegistryValue = NULL ; DWORD dwSize = 0 ; lReturnValue = RegOpenKeyEx ( HKEY_LOCAL_MACHINE , _T ( " SOFTWARE\\Space ▁ Sciences ▁ Laboratory , ▁ U . C . ▁ Berkeley\\BOINC ▁ Setup " ) , 0 , KEY_READ , & hkSetupHive ) ; if ( lReturnValue == ERROR_SUCCESS ) { lReturnValue = RegQueryValueEx ( hkSetupHive , _T ( " DATADIR " ) , NULL , NULL , NULL , & dwSize ) ; if ( lReturnValue != ERROR_FILE_NOT_FOUND ) { lpszRegistryValue = ( LPTSTR ) malloc ( dwSize ) ; ( * lpszRegistryValue ) = NULL ; lReturnValue = RegQueryValueEx ( hkSetupHive , _T ( " DATADIR " ) , NULL , NULL , ( LPBYTE ) lpszRegistryValue , & dwSize ) ; m_strBOINCMGRDataDirectory = lpszRegistryValue ; } } if ( hkSetupHive ) RegCloseKey ( hkSetupHive ) ; if ( lpszRegistryValue ) free ( lpszRegistryValue ) ; # endif # ifdef __WXMAC__ m_strBOINCMGRDataDirectory = wxT ( " / Library / Application ▁ Support / BOINC ▁ Data " ) ; # endif } void CBOINCGUIApp :: InitSupportedLanguages ( ) { wxInt32 iIndex = 0 ; const wxLanguageInfo * liLanguage = NULL ; m_astrLanguages . Insert ( wxEmptyString , 0 , wxLANGUAGE_USER_DEFINED + 1 ) ; m_astrLanguages [ wxLANGUAGE_DEFAULT ] = _ ( " ( Automatic ▁ Detection ) " ) ; m_astrLanguages [ wxLANGUAGE_UNKNOWN ] = _ ( " ( Unknown ) " ) ; m_astrLanguages [ wxLANGUAGE_USER_DEFINED ] = _ ( " ( User ▁ Defined ) " ) ; for ( iIndex = 0 ; iIndex <= wxLANGUAGE_USER_DEFINED ; iIndex ++ ) { liLanguage = wxLocale :: GetLanguageInfo ( iIndex ) ; if ( liLanguage ) { m_astrLanguages [ iIndex ] = liLanguage -> Description ; } } } int CBOINCGUIApp :: IdleTrackerAttach ( ) { # ifdef __WXMSW__ :: attach_idle_monitor ( ) ; # endif return 0 ; } int CBOINCGUIApp :: IdleTrackerDetach ( ) { # ifdef __WXMSW__ :: detach_idle_monitor ( ) ; # endif return 0 ; } void CBOINCGUIApp :: OnActivateApp ( wxActivateEvent & event ) { # ifdef __WXMAC__ if ( IsModalDialogDisplayed ( ) ) { event . Skip ( ) ; return ; } # endif if ( event . GetActive ( ) ) { if ( m_pEventLog && ! m_pEventLog -> IsIconized ( ) ) { m_pEventLog -> Raise ( ) ; } if ( m_pFrame ) m_pFrame -> Raise ( ) ; } event . Skip ( ) ; } void CBOINCGUIApp :: OnRPCFinished ( CRPCFinishedEvent & event ) { CMainDocument * pDoc = wxGetApp ( ) . GetDocument ( ) ; wxASSERT ( pDoc ) ; wxASSERT ( wxDynamicCast ( pDoc , CMainDocument ) ) ; pDoc -> OnRPCComplete ( event ) ; } int CBOINCGUIApp :: UpdateSystemIdleDetection ( ) { # ifdef __WXMSW__ return get_idle_tick_count ( ) ; # else return TRUE ; # endif } int CBOINCGUIApp :: StartBOINCScreensaverTest ( ) { # ifdef __WXMSW__ wxString strExecute = wxEmptyString ; wxChar szExecutableDirectory [ 4096 ] ; memset ( szExecutableDirectory , 0 , sizeof ( szExecutableDirectory ) ) ; GetWindowsDirectory ( szExecutableDirectory , ( sizeof ( szExecutableDirectory ) / sizeof ( wxChar ) ) ) ; strExecute = wxT ( " \ " " ) + wxString ( szExecutableDirectory ) + wxT ( " \\boinc . scr\ " ▁ / t " ) ; :: wxExecute ( strExecute ) ; # endif return 0 ; } int CBOINCGUIApp :: StartBOINCDefaultScreensaverTest ( ) { # ifdef __WXMSW__ wxString strExecute = wxEmptyString ; strExecute = wxT ( " \ " " ) + m_strBOINCMGRRootDirectory + wxT ( " \\boincscr . exe\ " ▁ - - test " ) ; :: wxExecute ( strExecute ) ; # endif return 0 ; } void CBOINCGUIApp :: DisplayEventLog ( bool bShowWindow ) { if ( m_pEventLog ) { if ( bShowWindow ) { if ( m_pEventLog -> IsIconized ( ) ) { m_pEventLog -> Iconize ( false ) ; } m_pEventLog -> Raise ( ) ; } } else { m_pEventLog = new CDlgEventLog ( ) ; if ( m_pEventLog ) { m_pEventLog -> Show ( bShowWindow ) ; if ( bShowWindow ) { m_pEventLog -> Raise ( ) ; } if ( m_pFrame ) { m_pFrame -> UpdateRefreshTimerInterval ( ) ; } } } } void CBOINCGUIApp :: OnEventLogClose ( ) { m_pEventLog = NULL ; if ( m_pFrame ) { m_pFrame -> UpdateRefreshTimerInterval ( ) ; } } void CBOINCGUIApp :: FireReloadSkin ( ) { if ( m_pFrame ) { m_pFrame -> FireReloadSkin ( ) ; } if ( m_pTaskBarIcon ) { m_pTaskBarIcon -> FireReloadSkin ( ) ; } } bool CBOINCGUIApp :: SetActiveGUI ( int iGUISelection , bool bShowWindow ) { wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ Function ▁ Begin " ) ) ; wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ GUI ▁ Selection : ▁ ' % d ' , ▁ Show : ▁ % d ' " ) , iGUISelection , ( int ) bShowWindow ) ; CBOINCBaseFrame * pNewFrame = NULL ; CBOINCBaseFrame * pOldFrame = m_pFrame ; wxInt32 iTop = 0 ; wxInt32 iLeft = 0 ; wxInt32 iHeight = 0 ; wxInt32 iWidth = 0 ; if ( ( iGUISelection != m_iGUISelected ) || ! m_pFrame ) { if ( BOINC_ADVANCEDGUI == iGUISelection ) { m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Read ( wxT ( " YPos " ) , & iTop , 30 ) ; m_pConfig -> Read ( wxT ( " XPos " ) , & iLeft , 30 ) ; m_pConfig -> Read ( wxT ( " Width " ) , & iWidth , 800 ) ; m_pConfig -> Read ( wxT ( " Height " ) , & iHeight , 600 ) ; } else { m_pConfig -> SetPath ( wxT ( " / Simple " ) ) ; m_pConfig -> Read ( wxT ( " YPos " ) , & iTop , 30 ) ; m_pConfig -> Read ( wxT ( " XPos " ) , & iLeft , 30 ) ; # ifdef __WXMAC__ iWidth = 409 ; iHeight = 561 ; # else iWidth = 416 ; iHeight = 570 ; # endif } # ifdef __WXMAC__ if ( ! IsWindowOnScreen ( iLeft , iTop , iWidth , iHeight ) ) { iTop = iLeft = 30 ; } # else if ( iLeft < 0 ) iLeft = 30 ; if ( iTop < 0 ) iTop = 30 ; wxInt32 iMaxWidth = wxSystemSettings :: GetMetric ( wxSYS_SCREEN_X ) ; wxInt32 iMaxHeight = wxSystemSettings :: GetMetric ( wxSYS_SCREEN_Y ) ; if ( iLeft + iWidth > iMaxWidth ) iLeft = iMaxWidth - iWidth ; if ( iTop + iHeight > iMaxHeight ) iTop = iMaxHeight - iHeight ; # endif if ( BOINC_ADVANCEDGUI == iGUISelection ) { pNewFrame = new CAdvancedFrame ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon32 ( ) , wxPoint ( iLeft , iTop ) , wxSize ( iWidth , iHeight ) ) ; } else { pNewFrame = new CSimpleFrame ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon32 ( ) , wxPoint ( iLeft , iTop ) , wxSize ( iWidth , iHeight ) ) ; } wxASSERT ( pNewFrame ) ; if ( pNewFrame ) { SetTopWindow ( pNewFrame ) ; m_pFrame = pNewFrame ; if ( pOldFrame ) pOldFrame -> Hide ( ) ; if ( pOldFrame ) pOldFrame -> Destroy ( ) ; } } if ( m_pFrame && bShowWindow ) { if ( m_pEventLog ) { m_pEventLog -> Show ( ) ; m_pEventLog -> Raise ( ) ; # ifdef __WXMSW__ :: SetForegroundWindow ( ( HWND ) m_pEventLog -> GetHWND ( ) ) ; # endif } if ( ! m_pFrame -> IsShown ( ) ) { m_pFrame -> Show ( ) ; } if ( m_pFrame -> IsIconized ( ) ) { m_pFrame -> Maximize ( false ) ; } m_pFrame -> Raise ( ) ; # ifdef __WXMSW__ :: SetForegroundWindow ( ( HWND ) m_pFrame -> GetHWND ( ) ) ; # endif } m_iGUISelected = iGUISelection ; m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Write ( wxT ( " GUISelection " ) , iGUISelection ) ; wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ Function ▁ End " ) ) ; return true ; } int CBOINCGUIApp :: ConfirmExit ( ) { CSkinAdvanced * pSkinAdvanced = wxGetApp ( ) . GetSkinManager ( ) -> GetAdvanced ( ) ; CMainDocument * pDoc = wxGetApp ( ) . GetDocument ( ) ; wxString strConnectedCompter = wxEmptyString ; bool bWasVisible ; int retval = 0 ; wxASSERT ( pDoc ) ; wxASSERT ( pSkinAdvanced ) ; wxASSERT ( wxDynamicCast ( pDoc , CMainDocument ) ) ; wxASSERT ( wxDynamicCast ( pSkinAdvanced , CSkinAdvanced ) ) ; pDoc -> GetConnectedComputerName ( strConnectedCompter ) ; if ( ! pDoc -> IsComputerNameLocal ( strConnectedCompter ) ) { return 1 ; } if ( s_bSkipExitConfirmation ) return 1 ; if ( IsMgrMultipleInstance ( ) ) return 1 ; if ( ! m_iDisplayExitDialog ) { return 1 ; } bWasVisible = IsApplicationVisible ( ) ; ShowApplication ( true ) ; CDlgExitMessage dlg ( NULL ) ; if ( ! pSkinAdvanced -> GetExitMessage ( ) . IsEmpty ( ) ) { dlg . m_DialogExitMessage -> SetLabel ( pSkinAdvanced -> GetExitMessage ( ) ) ; } # ifdef __WXMSW__ if ( m_iShutdownCoreClient ) { dlg . m_DialogShutdownCoreClient -> SetValue ( TRUE ) ; } # endif if ( m_iDisplayExitDialog ) { dlg . m_DialogDisplay -> SetValue ( FALSE ) ; } dlg . Fit ( ) ; dlg . Centre ( ) ; if ( wxID_OK == dlg . ShowModal ( ) ) { # ifdef __WXMAC__ s_bSkipExitConfirmation = true ; # else m_iShutdownCoreClient = dlg . m_DialogShutdownCoreClient -> GetValue ( ) ; # endif m_iDisplayExitDialog = ! dlg . m_DialogDisplay -> GetValue ( ) ; retval = true ; } if ( ! bWasVisible ) { ShowApplication ( false ) ; } return retval ; } int CBOINCGUIApp :: SafeMessageBox ( const wxString & message , const wxString & caption , long style , wxWindow * parent , int x , int y ) { int retval ; m_bSafeMessageBoxDisplayed ++ ; retval = wxMessageBox ( message , caption , style , parent , x , y ) ; m_bSafeMessageBoxDisplayed -- ; return retval ; } int CBOINCGUIApp :: IsAnotherInstanceRunning ( ) { PROC_MAP pm ; int retval ; char myName [ 256 ] ; int otherInstanceID = 0 ; int myPid ; retval = procinfo_setup ( pm ) ; if ( retval ) return false ; # ifdef _WIN32 myPid = ( int ) GetCurrentProcessId ( ) ; # else myPid = getpid ( ) ; # endif myName [ 0 ] = 0 ; PROC_MAP :: iterator i ; for ( i = pm . begin ( ) ; i != pm . end ( ) ; i ++ ) { PROCINFO & pi = i -> second ; if ( pi . id == myPid ) { strncpy ( myName , pi . command , sizeof ( myName ) ) ; break ; } } if ( myName [ 0 ] == 0 ) { return false ; } for ( i = pm . begin ( ) ; i != pm . end ( ) ; i ++ ) { PROCINFO & pi = i -> second ; if ( pi . id == myPid ) continue ; if ( ! strcmp ( pi . command , myName ) ) { otherInstanceID = pi . id ; break ; } } return otherInstanceID ; } bool CBOINCGUIApp :: IsApplicationVisible ( ) { # ifdef __WXMAC__ if ( IsProcessVisible ( & m_psnCurrentProcess ) ) { return true ; } # endif return false ; } # ifdef __WXMAC__ void CBOINCGUIApp :: ShowApplication ( bool bShow ) { if ( bShow ) { SetFrontProcess ( & m_psnCurrentProcess ) ; } else { ShowHideProcess ( & m_psnCurrentProcess , false ) ; } } # else void CBOINCGUIApp :: ShowApplication ( bool ) { } # endif bool CBOINCGUIApp :: ShowInterface ( ) { return SetActiveGUI ( m_iGUISelected , true ) ; } bool CBOINCGUIApp :: ShowNotifications ( ) { bool retval = false ; retval = SetActiveGUI ( m_iGUISelected , true ) ; if ( retval ) { GetFrame ( ) -> FireNotification ( ) ; GetDocument ( ) -> UpdateUnreadNoticeState ( ) ; } return retval ; } bool CBOINCGUIApp :: IsModalDialogDisplayed ( ) { if ( m_bSafeMessageBoxDisplayed ) return true ; if ( wxDynamicCast ( wxWindow :: FindWindowById ( ID_ANYDIALOG ) , wxDialog ) ) { return true ; } if ( m_pDocument ) { if ( m_pDocument -> WaitingForRPC ( ) ) { return true ; } } return false ; } void CBOINCGUIApp :: DeleteTaskBarIcon ( ) { if ( m_pTaskBarIcon ) { delete m_pTaskBarIcon ; } m_pTaskBarIcon = NULL ; } # ifdef __WXMAC__ void CBOINCGUIApp :: DeleteMacSystemMenu ( ) { if ( m_pMacSystemMenu ) { delete m_pMacSystemMenu ; } m_pMacSystemMenu = NULL ; } # endif int CBOINCGUIApp :: FilterEvent ( wxEvent & event ) { int theEventType ; wxDialog * theRPCWaitDialog ; wxObject * theObject ; if ( ! m_pDocument ) return - 1 ; theEventType = event . GetEventType ( ) ; if ( m_pDocument -> WaitingForRPC ( ) ) { if ( ( theEventType == wxEVT_COMMAND_MENU_SELECTED ) && ( event . GetId ( ) == wxID_OPEN ) ) { return - 1 ; } theRPCWaitDialog = m_pDocument -> GetRPCWaitDialog ( ) ; theObject = event . GetEventObject ( ) ; while ( theObject ) { if ( ! theObject -> IsKindOf ( CLASSINFO ( wxWindow ) ) ) break ; if ( theObject == theRPCWaitDialog ) return - 1 ; theObject = ( ( wxWindow * ) theObject ) -> GetParent ( ) ; } } else { if ( ! m_bFilterEvents ) return - 1 ; } if ( event . IsCommandEvent ( ) ) { return false ; } if ( theEventType == wxEVT_TIMER ) { return false ; } # ifdef __WXMSW__ if ( theEventType == wxEVT_TASKBAR_MOVE ) { return false ; } # endif return - 1 ; } </DOCUMENT>
<DOCUMENT_ID="babymannen/theforgottenserver-7.4/tree/master/src/items.cpp"> # include " otpch . h " # include " items . h " # include " spells . h " # include " movement . h " # include " weapons . h " # include " pugicast . h " uint32_t Items :: dwMajorVersion = 0 ; uint32_t Items :: dwMinorVersion = 0 ; uint32_t Items :: dwBuildNumber = 0 ; extern MoveEvents * g_moveEvents ; extern Weapons * g_weapons ; ItemType :: ItemType ( ) : group ( ITEM_GROUP_NONE ) , type ( ITEM_TYPE_NONE ) , id ( 0 ) , clientId ( 0 ) , stackable ( false ) , isAnimation ( false ) , weight ( 0 ) , levelDoor ( 0 ) , decayTime ( 0 ) , wieldInfo ( 0 ) , minReqLevel ( 0 ) , minReqMagicLevel ( 0 ) , charges ( 0 ) , maxHitChance ( - 1 ) , decayTo ( - 1 ) , attack ( 0 ) , defense ( 0 ) , extraDefense ( 0 ) , armor ( 0 ) , rotateTo ( 0 ) , runeMagLevel ( 0 ) , runeLevel ( 0 ) , combatType ( COMBAT_NONE ) , transformToOnUse ( 0 ) , transformToFree ( 0 ) , destroyTo ( 0 ) , maxTextLen ( 0 ) , writeOnceItemId ( 0 ) , transformEquipTo ( 0 ) , transformDeEquipTo ( 0 ) , maxItems ( 8 ) , slotPosition ( SLOTP_HAND ) , speed ( 0 ) , wareId ( 0 ) , magicEffect ( CONST_ME_NONE ) , bedPartnerDir ( DIRECTION_NONE ) , weaponType ( WEAPON_NONE ) , ammoType ( AMMO_NONE ) , shootType ( CONST_ANI_NONE ) , corpseType ( RACE_NONE ) , fluidSource ( FLUID_NONE ) , floorChange ( 0 ) , alwaysOnTopOrder ( 0 ) , lightLevel ( 0 ) , lightColor ( 0 ) , shootRange ( 1 ) , hitChance ( 0 ) , forceUse ( false ) , hasHeight ( false ) , walkStack ( true ) , blockSolid ( false ) , blockPickupable ( false ) , blockProjectile ( false ) , blockPathFind ( false ) , allowPickupable ( false ) , showDuration ( false ) , showCharges ( false ) , showAttributes ( false ) , replaceable ( true ) , pickupable ( false ) , rotatable ( false ) , useable ( false ) , moveable ( false ) , alwaysOnTop ( false ) , canReadText ( false ) , canWriteText ( false ) , isVertical ( false ) , isHorizontal ( false ) , isHangable ( false ) , allowDistRead ( false ) , lookThrough ( false ) , stopTime ( false ) , showCount ( true ) { } Items :: Items ( ) { items . reserve ( 20000 ) ; } Items :: ~ Items ( ) { clear ( ) ; } void Items :: clear ( ) { items . clear ( ) ; } bool Items :: reload ( ) { clear ( ) ; loadFromOtb ( " data / items / items . otb " ) ; if ( ! loadFromXml ( ) ) { return false ; } g_moveEvents -> reload ( ) ; g_weapons -> reload ( ) ; g_weapons -> loadDefaults ( ) ; return true ; } FILELOADER_ERRORS Items :: loadFromOtb ( const std :: string & file ) { FileLoader f ; if ( ! f . openFile ( file . c_str ( ) , " OTBI " ) ) { return f . getError ( ) ; } uint32_t type ; NODE node = f . getChildNode ( NO_NODE , type ) ; PropStream props ; if ( f . getProps ( node , props ) ) { uint32_t flags ; if ( ! props . read < uint32_t > ( flags ) ) { return ERROR_INVALID_FORMAT ; } uint8_t attr ; if ( ! props . read < uint8_t > ( attr ) ) { return ERROR_INVALID_FORMAT ; } if ( attr == ROOT_ATTR_VERSION ) { uint16_t datalen ; if ( ! props . read < uint16_t > ( datalen ) ) { return ERROR_INVALID_FORMAT ; } if ( datalen != sizeof ( VERSIONINFO ) ) { return ERROR_INVALID_FORMAT ; } VERSIONINFO vi ; if ( ! props . read ( vi ) ) { return ERROR_INVALID_FORMAT ; } Items :: dwMajorVersion = vi . dwMajorVersion ; Items :: dwMinorVersion = vi . dwMinorVersion ; Items :: dwBuildNumber = vi . dwBuildNumber ; } } if ( Items :: dwMajorVersion == 0xFFFFFFFF ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromOtb ] ▁ items . otb ▁ using ▁ generic ▁ client ▁ version . " << std :: endl ; } else if ( Items :: dwMajorVersion > 2 ) { std :: cout << " New ▁ version ▁ detected , ▁ an ▁ older ▁ version ▁ of ▁ items . otb ▁ is ▁ required . " << std :: endl ; return ERROR_INVALID_FORMAT ; } else if ( Items :: dwMinorVersion < CLIENT_VERSION_740 ) { std :: cout << " A ▁ newer ▁ version ▁ of ▁ items . otb ▁ is ▁ required . " << std :: endl ; return ERROR_INVALID_FORMAT ; } node = f . getChildNode ( node , type ) ; while ( node != NO_NODE ) { PropStream stream ; if ( ! f . getProps ( node , stream ) ) { return f . getError ( ) ; } uint32_t flags ; if ( ! stream . read < uint32_t > ( flags ) ) { return ERROR_INVALID_FORMAT ; } uint16_t serverId = 0 ; uint16_t clientId = 0 ; uint16_t speed = 0 ; uint16_t wareId = 0 ; uint8_t lightLevel = 0 ; uint8_t lightColor = 0 ; uint8_t alwaysOnTopOrder = 0 ; uint8_t attrib ; while ( stream . read < uint8_t > ( attrib ) ) { uint16_t datalen ; if ( ! stream . read < uint16_t > ( datalen ) ) { return ERROR_INVALID_FORMAT ; } switch ( attrib ) { case ITEM_ATTR_SERVERID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( serverId ) ) { return ERROR_INVALID_FORMAT ; } if ( serverId > 20000 && serverId < 20100 ) { serverId -= 20000 ; } break ; } case ITEM_ATTR_CLIENTID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( clientId ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_SPEED : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( speed ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_LIGHT2 : { if ( datalen != sizeof ( lightBlock2 ) ) { return ERROR_INVALID_FORMAT ; } lightBlock2 lb2 ; if ( ! stream . read ( lb2 ) ) { return ERROR_INVALID_FORMAT ; } lightLevel = static_cast < uint8_t > ( lb2 . lightLevel ) ; lightColor = static_cast < uint8_t > ( lb2 . lightColor ) ; break ; } case ITEM_ATTR_TOPORDER : { if ( datalen != sizeof ( uint8_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint8_t > ( alwaysOnTopOrder ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_WAREID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( wareId ) ) { return ERROR_INVALID_FORMAT ; } break ; } default : { if ( ! stream . skip ( datalen ) ) { return ERROR_INVALID_FORMAT ; } break ; } } } reverseItemMap . emplace ( clientId , serverId ) ; if ( serverId >= items . size ( ) ) { items . resize ( serverId + 1 ) ; } ItemType & iType = items [ serverId ] ; iType . group = static_cast < itemgroup_t > ( type ) ; switch ( type ) { case ITEM_GROUP_CONTAINER : iType . type = ITEM_TYPE_CONTAINER ; break ; case ITEM_GROUP_DOOR : iType . type = ITEM_TYPE_DOOR ; break ; case ITEM_GROUP_MAGICFIELD : iType . type = ITEM_TYPE_MAGICFIELD ; break ; case ITEM_GROUP_TELEPORT : iType . type = ITEM_TYPE_TELEPORT ; break ; case ITEM_GROUP_NONE : case ITEM_GROUP_GROUND : case ITEM_GROUP_SPLASH : case ITEM_GROUP_FLUID : case ITEM_GROUP_CHARGES : case ITEM_GROUP_DEPRECATED : break ; default : return ERROR_INVALID_FORMAT ; } iType . blockSolid = hasBitSet ( FLAG_BLOCK_SOLID , flags ) ; iType . blockProjectile = hasBitSet ( FLAG_BLOCK_PROJECTILE , flags ) ; iType . blockPathFind = hasBitSet ( FLAG_BLOCK_PATHFIND , flags ) ; iType . hasHeight = hasBitSet ( FLAG_HAS_HEIGHT , flags ) ; iType . useable = hasBitSet ( FLAG_USEABLE , flags ) ; iType . pickupable = hasBitSet ( FLAG_PICKUPABLE , flags ) ; iType . moveable = hasBitSet ( FLAG_MOVEABLE , flags ) ; iType . stackable = hasBitSet ( FLAG_STACKABLE , flags ) ; iType . alwaysOnTop = hasBitSet ( FLAG_ALWAYSONTOP , flags ) ; iType . isVertical = hasBitSet ( FLAG_VERTICAL , flags ) ; iType . isHorizontal = hasBitSet ( FLAG_HORIZONTAL , flags ) ; iType . isHangable = hasBitSet ( FLAG_HANGABLE , flags ) ; iType . allowDistRead = hasBitSet ( FLAG_ALLOWDISTREAD , flags ) ; iType . rotatable = hasBitSet ( FLAG_ROTATABLE , flags ) ; iType . canReadText = hasBitSet ( FLAG_READABLE , flags ) ; iType . lookThrough = hasBitSet ( FLAG_LOOKTHROUGH , flags ) ; iType . forceUse = hasBitSet ( FLAG_FORCEUSE , flags ) ; iType . id = serverId ; iType . clientId = clientId ; iType . speed = speed ; iType . lightLevel = lightLevel ; iType . lightColor = lightColor ; iType . wareId = wareId ; iType . alwaysOnTopOrder = alwaysOnTopOrder ; node = f . getNextNode ( node , type ) ; } items . shrink_to_fit ( ) ; return ERROR_NONE ; } bool Items :: loadFromXml ( ) { pugi :: xml_document doc ; pugi :: xml_parse_result result = doc . load_file ( " data / items / items . xml " ) ; if ( ! result ) { printXMLError ( " Error ▁ - ▁ Items : : loadFromXml " , " data / items / items . xml " , result ) ; return false ; } for ( auto itemNode : doc . child ( " items " ) . children ( ) ) { pugi :: xml_attribute idAttribute = itemNode . attribute ( " id " ) ; if ( idAttribute ) { parseItemNode ( itemNode , pugi :: cast < uint16_t > ( idAttribute . value ( ) ) ) ; continue ; } pugi :: xml_attribute fromIdAttribute = itemNode . attribute ( " fromid " ) ; if ( ! fromIdAttribute ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromXml ] ▁ No ▁ item ▁ id ▁ found " << std :: endl ; continue ; } pugi :: xml_attribute toIdAttribute = itemNode . attribute ( " toid " ) ; if ( ! toIdAttribute ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromXml ] ▁ fromid ▁ ( " << fromIdAttribute . value ( ) << " ) ▁ without ▁ toid " << std :: endl ; continue ; } uint16_t id = pugi :: cast < uint16_t > ( fromIdAttribute . value ( ) ) ; uint16_t toId = pugi :: cast < uint16_t > ( toIdAttribute . value ( ) ) ; while ( id <= toId ) { parseItemNode ( itemNode , id ++ ) ; } } return true ; } void Items :: parseItemNode ( const pugi :: xml_node & itemNode , uint16_t id ) { if ( id > 20000 && id < 20100 ) { id -= 20000 ; if ( id >= items . size ( ) ) { items . resize ( id + 1 ) ; } ItemType & iType = items [ id ] ; iType . id = id ; } ItemType & it = getItemType ( id ) ; if ( it . id == 0 ) { return ; } it . name = itemNode . attribute ( " name " ) . as_string ( ) ; pugi :: xml_attribute articleAttribute = itemNode . attribute ( " article " ) ; if ( articleAttribute ) { it . article = articleAttribute . as_string ( ) ; } pugi :: xml_attribute pluralAttribute = itemNode . attribute ( " plural " ) ; if ( pluralAttribute ) { it . pluralName = pluralAttribute . as_string ( ) ; } for ( auto attributeNode : itemNode . children ( ) ) { pugi :: xml_attribute keyAttribute = attributeNode . attribute ( " key " ) ; if ( ! keyAttribute ) { continue ; } pugi :: xml_attribute valueAttribute = attributeNode . attribute ( " value " ) ; if ( ! valueAttribute ) { continue ; } std :: string tmpStrValue = asLowerCaseString ( keyAttribute . as_string ( ) ) ; if ( tmpStrValue == " type " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " key " ) { it . type = ITEM_TYPE_KEY ; } else if ( tmpStrValue == " magicfield " ) { it . type = ITEM_TYPE_MAGICFIELD ; } else if ( tmpStrValue == " container " ) { it . group = ITEM_GROUP_CONTAINER ; it . type = ITEM_TYPE_CONTAINER ; } else if ( tmpStrValue == " depot " ) { it . type = ITEM_TYPE_DEPOT ; } else if ( tmpStrValue == " mailbox " ) { it . type = ITEM_TYPE_MAILBOX ; } else if ( tmpStrValue == " trashholder " ) { it . type = ITEM_TYPE_TRASHHOLDER ; } else if ( tmpStrValue == " teleport " ) { it . type = ITEM_TYPE_TELEPORT ; } else if ( tmpStrValue == " door " ) { it . type = ITEM_TYPE_DOOR ; } else if ( tmpStrValue == " bed " ) { it . type = ITEM_TYPE_BED ; } else if ( tmpStrValue == " rune " ) { it . type = ITEM_TYPE_RUNE ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ type : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " description " ) { it . description = valueAttribute . as_string ( ) ; } else if ( tmpStrValue == " runespellname " ) { it . runeSpellName = valueAttribute . as_string ( ) ; } else if ( tmpStrValue == " weight " ) { it . weight = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showcount " ) { it . showCount = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " armor " ) { it . armor = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " defense " ) { it . defense = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " extradef " ) { it . extraDefense = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " attack " ) { it . attack = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " rotateto " ) { it . rotateTo = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " moveable " || tmpStrValue == " movable " ) { it . moveable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " blockprojectile " ) { it . blockProjectile = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " allowpickupable " || tmpStrValue == " pickupable " ) { it . allowPickupable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " floorchange " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " down " ) { it . floorChange = TILESTATE_FLOORCHANGE_DOWN ; } else if ( tmpStrValue == " north " ) { it . floorChange = TILESTATE_FLOORCHANGE_NORTH ; } else if ( tmpStrValue == " south " ) { it . floorChange = TILESTATE_FLOORCHANGE_SOUTH ; } else if ( tmpStrValue == " southalt " ) { it . floorChange = TILESTATE_FLOORCHANGE_SOUTH_ALT ; } else if ( tmpStrValue == " west " ) { it . floorChange = TILESTATE_FLOORCHANGE_WEST ; } else if ( tmpStrValue == " east " ) { it . floorChange = TILESTATE_FLOORCHANGE_EAST ; } else if ( tmpStrValue == " eastalt " ) { it . floorChange = TILESTATE_FLOORCHANGE_EAST_ALT ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ floorChange : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " corpsetype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " venom " ) { it . corpseType = RACE_VENOM ; } else if ( tmpStrValue == " blood " ) { it . corpseType = RACE_BLOOD ; } else if ( tmpStrValue == " undead " ) { it . corpseType = RACE_UNDEAD ; } else if ( tmpStrValue == " fire " ) { it . corpseType = RACE_FIRE ; } else if ( tmpStrValue == " energy " ) { it . corpseType = RACE_ENERGY ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ corpseType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " containersize " ) { it . maxItems = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fluidsource " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " water " ) { it . fluidSource = FLUID_WATER ; } else if ( tmpStrValue == " blood " ) { it . fluidSource = FLUID_BLOOD ; } else if ( tmpStrValue == " beer " ) { it . fluidSource = FLUID_BEER ; } else if ( tmpStrValue == " slime " ) { it . fluidSource = FLUID_SLIME ; } else if ( tmpStrValue == " lemonade " ) { it . fluidSource = FLUID_LEMONADE ; } else if ( tmpStrValue == " milk " ) { it . fluidSource = FLUID_MILK ; } else if ( tmpStrValue == " mana " ) { it . fluidSource = FLUID_MANA ; } else if ( tmpStrValue == " life " ) { it . fluidSource = FLUID_LIFE ; } else if ( tmpStrValue == " oil " ) { it . fluidSource = FLUID_OIL ; } else if ( tmpStrValue == " urine " ) { it . fluidSource = FLUID_URINE ; } else if ( tmpStrValue == " coconut " ) { it . fluidSource = FLUID_COCONUTMILK ; } else if ( tmpStrValue == " wine " ) { it . fluidSource = FLUID_WINE ; } else if ( tmpStrValue == " mud " ) { it . fluidSource = FLUID_MUD ; } else if ( tmpStrValue == " fruitjuice " ) { it . fluidSource = FLUID_FRUITJUICE ; } else if ( tmpStrValue == " lava " ) { it . fluidSource = FLUID_LAVA ; } else if ( tmpStrValue == " rum " ) { it . fluidSource = FLUID_RUM ; } else if ( tmpStrValue == " swamp " ) { it . fluidSource = FLUID_SWAMP ; } else if ( tmpStrValue == " tea " ) { it . fluidSource = FLUID_TEA ; } else if ( tmpStrValue == " mead " ) { it . fluidSource = FLUID_MEAD ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ fluidSource : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " readable " ) { it . canReadText = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " writeable " ) { it . canWriteText = valueAttribute . as_bool ( ) ; it . canReadText = it . canWriteText ; } else if ( tmpStrValue == " maxtextlen " ) { it . maxTextLen = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " writeonceitemid " ) { it . writeOnceItemId = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " weapontype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " sword " ) { it . weaponType = WEAPON_SWORD ; } else if ( tmpStrValue == " club " ) { it . weaponType = WEAPON_CLUB ; } else if ( tmpStrValue == " axe " ) { it . weaponType = WEAPON_AXE ; } else if ( tmpStrValue == " shield " ) { it . weaponType = WEAPON_SHIELD ; } else if ( tmpStrValue == " distance " ) { it . weaponType = WEAPON_DISTANCE ; } else if ( tmpStrValue == " wand " ) { it . weaponType = WEAPON_WAND ; } else if ( tmpStrValue == " ammunition " ) { it . weaponType = WEAPON_AMMO ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ weaponType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " slottype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " head " ) { it . slotPosition |= SLOTP_HEAD ; } else if ( tmpStrValue == " body " ) { it . slotPosition |= SLOTP_ARMOR ; } else if ( tmpStrValue == " legs " ) { it . slotPosition |= SLOTP_LEGS ; } else if ( tmpStrValue == " feet " ) { it . slotPosition |= SLOTP_FEET ; } else if ( tmpStrValue == " backpack " ) { it . slotPosition |= SLOTP_BACKPACK ; } else if ( tmpStrValue == " two - handed " ) { it . slotPosition |= SLOTP_TWO_HAND ; } else if ( tmpStrValue == " right - hand " ) { it . slotPosition &= ~ SLOTP_LEFT ; } else if ( tmpStrValue == " left - hand " ) { it . slotPosition &= ~ SLOTP_RIGHT ; } else if ( tmpStrValue == " necklace " ) { it . slotPosition |= SLOTP_NECKLACE ; } else if ( tmpStrValue == " ring " ) { it . slotPosition |= SLOTP_RING ; } else if ( tmpStrValue == " ammo " ) { it . slotPosition |= SLOTP_AMMO ; } else if ( tmpStrValue == " hand " ) { it . slotPosition |= SLOTP_HAND ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ slotType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " ammotype " ) { it . ammoType = getAmmoType ( valueAttribute . as_string ( ) ) ; if ( it . ammoType == AMMO_NONE ) { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ ammoType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " shoottype " ) { ShootType_t shoot = getShootType ( valueAttribute . as_string ( ) ) ; if ( shoot != CONST_ANI_NONE ) { it . shootType = shoot ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ shootType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " effect " ) { MagicEffectClasses effect = getMagicEffect ( valueAttribute . as_string ( ) ) ; if ( effect != CONST_ME_NONE ) { it . magicEffect = effect ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ effect : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " range " ) { it . shootRange = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " stopduration " ) { it . stopTime = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " decayto " ) { it . decayTo = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " transformequipto " ) { it . transformEquipTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " transformdeequipto " ) { it . transformDeEquipTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " duration " ) { it . decayTime = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showduration " ) { it . showDuration = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " charges " ) { it . charges = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showcharges " ) { it . showCharges = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " showattributes " ) { it . showAttributes = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " hitchance " ) { it . hitChance = std :: min < int8_t > ( 100 , std :: max < int8_t > ( - 100 , pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ) ) ; } else if ( tmpStrValue == " maxhitchance " ) { it . maxHitChance = std :: min < uint32_t > ( 100 , pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " invisible " ) { it . getAbilities ( ) . invisible = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " speed " ) { it . getAbilities ( ) . speed = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " healthgain " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . healthGain = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " healthticks " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . healthTicks = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " managain " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . manaGain = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " manaticks " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . manaTicks = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " manashield " ) { it . getAbilities ( ) . manaShield = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " skillsword " ) { it . getAbilities ( ) . skills [ SKILL_SWORD ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillaxe " ) { it . getAbilities ( ) . skills [ SKILL_AXE ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillclub " ) { it . getAbilities ( ) . skills [ SKILL_CLUB ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skilldist " ) { it . getAbilities ( ) . skills [ SKILL_DISTANCE ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillfish " ) { it . getAbilities ( ) . skills [ SKILL_FISHING ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillshield " ) { it . getAbilities ( ) . skills [ SKILL_SHIELD ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillfist " ) { it . getAbilities ( ) . skills [ SKILL_FIST ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxhitpoints " ) { it . getAbilities ( ) . stats [ STAT_MAXHITPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxhitpointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAXHITPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxmanapoints " ) { it . getAbilities ( ) . stats [ STAT_MAXMANAPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxmanapointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAXMANAPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " magicpoints " || tmpStrValue == " magiclevelpoints " ) { it . getAbilities ( ) . stats [ STAT_MAGICPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " magicpointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAGICPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercentenergy " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercentfire " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercentpoison " || tmpStrValue == " fieldabsorpercentearth " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentall " || tmpStrValue == " absorbpercentallelements " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; for ( size_t i = 0 ; i < COMBAT_COUNT ; ++ i ) { abilities . absorbPercent [ i ] += value ; } } else if ( tmpStrValue == " absorbpercentelements " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += value ; } else if ( tmpStrValue == " absorbpercentmagic " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += value ; } else if ( tmpStrValue == " absorbpercentenergy " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentfire " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentpoison " || tmpStrValue == " absorbpercentearth " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentlifedrain " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_LIFEDRAIN ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentmanadrain " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_MANADRAIN ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentphysical " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_PHYSICALDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercenthealing " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_HEALING ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentundefined " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_UNDEFINEDDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " suppressdrunk " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_DRUNK ; } } else if ( tmpStrValue == " suppressenergy " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_ENERGY ; } } else if ( tmpStrValue == " suppressfire " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_FIRE ; } } else if ( tmpStrValue == " suppresspoison " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_POISON ; } } else if ( tmpStrValue == " suppressphysical " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_BLEEDING ; } } else if ( tmpStrValue == " field " ) { it . group = ITEM_GROUP_MAGICFIELD ; it . type = ITEM_TYPE_MAGICFIELD ; CombatType_t combatType = COMBAT_NONE ; ConditionDamage * conditionDamage = nullptr ; tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " fire " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_FIRE ) ; combatType = COMBAT_FIREDAMAGE ; } else if ( tmpStrValue == " energy " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_ENERGY ) ; combatType = COMBAT_ENERGYDAMAGE ; } else if ( tmpStrValue == " poison " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_POISON ) ; combatType = COMBAT_EARTHDAMAGE ; } else if ( tmpStrValue == " physical " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_BLEEDING ) ; combatType = COMBAT_PHYSICALDAMAGE ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ field ▁ value : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } if ( combatType != COMBAT_NONE ) { it . combatType = combatType ; it . conditionDamage . reset ( conditionDamage ) ; uint32_t ticks = 0 ; int32_t damage = 0 ; int32_t start = 0 ; int32_t count = 1 ; for ( auto subAttributeNode : attributeNode . children ( ) ) { pugi :: xml_attribute subKeyAttribute = subAttributeNode . attribute ( " key " ) ; if ( ! subKeyAttribute ) { continue ; } pugi :: xml_attribute subValueAttribute = subAttributeNode . attribute ( " value " ) ; if ( ! subValueAttribute ) { continue ; } tmpStrValue = asLowerCaseString ( subKeyAttribute . as_string ( ) ) ; if ( tmpStrValue == " ticks " ) { ticks = pugi :: cast < uint32_t > ( subValueAttribute . value ( ) ) ; } else if ( tmpStrValue == " count " ) { count = std :: max < int32_t > ( 1 , pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " start " ) { start = std :: max < int32_t > ( 0 , pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " damage " ) { damage = - pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ; if ( start > 0 ) { std :: list < int32_t > damageList ; ConditionDamage :: generateDamageList ( damage , start , damageList ) ; for ( int32_t damageValue : damageList ) { conditionDamage -> addDamage ( 1 , ticks , - damageValue ) ; } start = 0 ; } else { conditionDamage -> addDamage ( count , ticks , damage ) ; } } } conditionDamage -> setParam ( CONDITION_PARAM_FIELD , 1 ) ; if ( conditionDamage -> getTotalDamage ( ) > 0 ) { conditionDamage -> setParam ( CONDITION_PARAM_FORCEUPDATE , 1 ) ; } } } else if ( tmpStrValue == " replaceable " ) { it . replaceable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " partnerdirection " ) { it . bedPartnerDir = getDirection ( valueAttribute . as_string ( ) ) ; } else if ( tmpStrValue == " leveldoor " ) { it . levelDoor = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " sleeper " ) { uint16_t value = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; it . transformToOnUse = value ; ItemType & other = getItemType ( value ) ; if ( other . transformToFree == 0 ) { other . transformToFree = it . id ; } if ( it . transformToOnUse == 0 ) { it . transformToOnUse = value ; } } else if ( tmpStrValue == " transformto " ) { it . transformToFree = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " destroyto " ) { it . destroyTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " elementearth " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_EARTHDAMAGE ; } else if ( tmpStrValue == " elementfire " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_FIREDAMAGE ; } else if ( tmpStrValue == " elementenergy " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_ENERGYDAMAGE ; } else if ( tmpStrValue == " walkstack " ) { it . walkStack = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " blocking " ) { it . blockSolid = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " allowdistread " ) { it . allowDistRead = booleanString ( valueAttribute . as_string ( ) ) ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ key ▁ value : ▁ " << keyAttribute . as_string ( ) << std :: endl ; } } if ( ( it . transformToFree != 0 || it . transformToOnUse != 0 || it . transformToOnUse != 0 ) && it . type != ITEM_TYPE_BED ) { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Item ▁ " << it . id << " ▁ is ▁ not ▁ set ▁ as ▁ a ▁ bed - type " << std :: endl ; } } ItemType & Items :: getItemType ( size_t id ) { if ( id < items . size ( ) ) { return items [ id ] ; } return items . front ( ) ; } const ItemType & Items :: getItemType ( size_t id ) const { if ( id < items . size ( ) ) { return items [ id ] ; } return items . front ( ) ; } const ItemType & Items :: getItemIdByClientId ( uint16_t spriteId ) const { auto it = reverseItemMap . find ( spriteId ) ; if ( it != reverseItemMap . end ( ) ) { return getItemType ( it -> second ) ; } return items . front ( ) ; } uint16_t Items :: getItemIdByName ( const std :: string & name ) { if ( name . empty ( ) ) { return 0 ; } const char * itemName = name . c_str ( ) ; for ( size_t i = 100 , size = items . size ( ) ; i < size ; ++ i ) { if ( strcasecmp ( itemName , items [ i ] . name . c_str ( ) ) == 0 ) { return i ; } } return 0 ; } </DOCUMENT>
<DOCUMENT_ID="peak3d/inputstream.adaptive/tree/master/lib/libbento4/Core/Ap4.cpp"> # include " Ap4 . h " static AP4 AP4_LoaderCheck ; AP4 :: AP4 ( ) : m_ConstructedByLoader ( true ) { } AP4_Result AP4 :: Initialize ( ) { AP4_Result result = AP4_SUCCESS ; # if defined ( AP4_CONFIG_CONSTRUCT_STATICS_ON_INITIALIZE ) if ( ! AP4_DefaultAtomFactory :: Instance . m_Initialized ) { result = AP4_DefaultAtomFactory :: Instance . Initialize ( ) ; if ( AP4_FAILED ( result ) ) return result ; } if ( ! AP4_DefaultBlockCipherFactory :: Instance . m_Initialized ) { result = AP4_DefaultBlockCipherFactory :: Instance . Initialize ( ) ; if ( AP4_FAILED ( result ) ) return result ; } if ( ! AP4_MetaData :: Initialized ( ) ) { AP4_MetaData :: Initialize ( ) ; } # endif return result ; } AP4_Result AP4 :: Terminate ( ) { # if defined ( AP4_CONFIG_DESTRUCT_STATICS_ON_TERMINATE ) if ( ! AP4_LoaderCheck . m_ConstructedByLoader ) { if ( AP4_DefaultAtomFactory :: Instance . m_Initialized ) { AP4_DefaultAtomFactory :: Instance . ~ AP4_DefaultAtomFactory ( ) ; } if ( AP4_DefaultBlockCipherFactory :: Instance . m_Initialized ) { AP4_DefaultBlockCipherFactory :: Instance . ~ AP4_DefaultBlockCipherFactory ( ) ; } if ( AP4_MetaData :: Initialized ( ) ) { AP4_MetaData :: UnInitialize ( ) ; } } # endif return AP4_SUCCESS ; } </DOCUMENT>
<DOCUMENT_ID="ericzhou2008/WinObjC/tree/master/deps/3rdparty/iculegacy/source/common/parsepos.cpp"> # include " unicode / parsepos . h " U_NAMESPACE_BEGIN UOBJECT_DEFINE_RTTI_IMPLEMENTATION ( ParsePosition ) ParsePosition :: ~ ParsePosition ( ) { } ParsePosition * ParsePosition :: clone ( ) const { return new ParsePosition ( * this ) ; } U_NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="tpltnt/uncrustify/tree/master/tests/output/cpp/30920-indent-off.cpp"> struct X { void operator - ( int ) ; void operator + ( int ) ; void operator ( ) ( ) ; } ; struct Y { void operator - ( int ) { } void operator + ( int ) { } void operator ( ) ( ) { } void func ( ) { auto x = " TABSYMBOL test\t ▁ TABSYMBOL ▁ TABSYMBOL ▁ TABSYMBOL TABSYMBOL . . . ▁ ▁ ▁ ? ? ? " ; } } ; struct Y { void operator - ( int ) { } void operator + ( int ) { } void operator ( ) ( ) { } void func ( ) { auto x = " TABSYMBOL test\t ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . . . ▁ ▁ ▁ ? ? ? " ; } } ; </DOCUMENT>
<DOCUMENT_ID="syslover33/ctank/tree/master/java/android-sdk-linux_r24.4.1_src/ndk-bundle_r11c/sources/cxx-stl/llvm-libc++/libcxx/test/localization/locales/locale.convenience/conversions/conversions.buffer/pbackfail.pass.cpp"> # include < locale > # include < codecvt > # include < fstream > # include < cassert > struct test_buf : public std :: wbuffer_convert < std :: codecvt_utf8 < wchar_t > > { typedef std :: wbuffer_convert < std :: codecvt_utf8 < wchar_t > > base ; typedef base :: char_type char_type ; typedef base :: int_type int_type ; typedef base :: traits_type traits_type ; explicit test_buf ( std :: streambuf * sb ) : base ( sb ) { } char_type * eback ( ) const { return base :: eback ( ) ; } char_type * gptr ( ) const { return base :: gptr ( ) ; } char_type * egptr ( ) const { return base :: egptr ( ) ; } void gbump ( int n ) { base :: gbump ( n ) ; } virtual int_type pbackfail ( int_type c = traits_type :: eof ( ) ) { return base :: pbackfail ( c ) ; } } ; int main ( ) { { std :: ifstream bs ( " underflow . dat " ) ; test_buf f ( bs . rdbuf ( ) ) ; assert ( f . sbumpc ( ) == L ' 1' ) ; assert ( f . sgetc ( ) == L ' 2' ) ; assert ( f . pbackfail ( L ' a ' ) == test_buf :: traits_type :: eof ( ) ) ; } { std :: fstream bs ( " underflow . dat " ) ; test_buf f ( bs . rdbuf ( ) ) ; assert ( f . sbumpc ( ) == L ' 1' ) ; assert ( f . sgetc ( ) == L ' 2' ) ; assert ( f . pbackfail ( L ' a ' ) == test_buf :: traits_type :: eof ( ) ) ; assert ( f . sbumpc ( ) == L ' 2' ) ; assert ( f . sgetc ( ) == L ' 3' ) ; } } </DOCUMENT>
<DOCUMENT_ID="austinzheng/swift/tree/master/lib/SILOptimizer/IPO/LetPropertiesOpts.cpp"> # define DEBUG_TYPE " let - properties - opt " # include " swift / SIL / DebugUtils . h " # include " swift / SIL / InstructionUtils . h " # include " swift / SIL / SILBasicBlock . h " # include " swift / SIL / SILInstruction . h " # include " swift / SIL / SILLinkage . h " # include " swift / SILOptimizer / PassManager / Passes . h " # include " swift / SILOptimizer / PassManager / Transforms . h " # include " swift / SILOptimizer / Utils / Local . h " # include " llvm / ADT / MapVector . h " # include " llvm / Support / CommandLine . h " # include " llvm / Support / Debug . h " using namespace swift ; namespace { using InstructionList = SmallVector < SILInstruction * , 8 > ; struct InitSequence { InstructionList Instructions ; SILValue Result ; bool isValid ( ) const { return ( bool ) Result ; } } ; class LetPropertiesOpt { SILModule * Module ; typedef SmallVector < VarDecl * , 4 > Properties ; llvm :: SetVector < SILFunction * > ChangedFunctions ; llvm :: MapVector < VarDecl * , InstructionList > AccessMap ; llvm :: MapVector < VarDecl * , InitSequence > InitMap ; llvm :: SmallPtrSet < VarDecl * , 16 > SkipProcessing ; llvm :: SmallPtrSet < NominalTypeDecl * , 16 > SkipTypeProcessing ; llvm :: SmallPtrSet < VarDecl * , 16 > CannotRemove ; llvm :: MapVector < NominalTypeDecl * , Properties > NominalTypeLetProperties ; llvm :: SmallPtrSet < VarDecl * , 16 > PotentialConstantLetProperty ; public : LetPropertiesOpt ( SILModule * M ) : Module ( M ) { } void run ( SILModuleTransform * T ) ; protected : bool isConstantLetProperty ( VarDecl * Property ) ; void collectPropertyAccess ( SILInstruction * I , VarDecl * Property , bool NonRemovable ) ; void collectStructPropertiesAccess ( StructInst * SI , bool NonRemovable ) ; void optimizeLetPropertyAccess ( VarDecl * SILG , const InitSequence & Init ) ; bool analyzeInitValue ( SILInstruction * I , VarDecl * Prop ) ; } ; class InitSequenceCloner : public SILClonerWithScopes < InitSequenceCloner > { friend class SILInstructionVisitor < InitSequenceCloner > ; friend class SILCloner < InitSequenceCloner > ; const InitSequence & Init ; SILInstruction * DestIP ; public : InitSequenceCloner ( const InitSequence & init , SILInstruction * destIP ) : SILClonerWithScopes ( * destIP -> getFunction ( ) ) , Init ( init ) , DestIP ( destIP ) { } void process ( SILInstruction * I ) { visit ( I ) ; } SILBasicBlock * remapBasicBlock ( SILBasicBlock * BB ) { return BB ; } SILValue getMappedValue ( SILValue Value ) { return SILCloner < InitSequenceCloner > :: getMappedValue ( Value ) ; } void postProcess ( SILInstruction * orig , SILInstruction * cloned ) { DestIP -> getParent ( ) -> push_front ( cloned ) ; cloned -> moveBefore ( DestIP ) ; SILClonerWithScopes < InitSequenceCloner > :: postProcess ( orig , cloned ) ; } SILValue clone ( ) { for ( auto I : Init . Instructions ) process ( I ) ; return getMappedValue ( Init . Result ) ; } } ; } # ifndef NDEBUG static raw_ostream & operator << ( raw_ostream & OS , const VarDecl & decl ) { auto * Ty = dyn_cast < NominalTypeDecl > ( decl . getDeclContext ( ) ) ; if ( Ty ) OS << Ty -> getName ( ) << " : : " ; OS << decl . getName ( ) ; return OS ; } # endif void LetPropertiesOpt :: optimizeLetPropertyAccess ( VarDecl * Property , const InitSequence & init ) { assert ( init . isValid ( ) ) ; if ( SkipProcessing . count ( Property ) ) return ; auto * Ty = dyn_cast < NominalTypeDecl > ( Property -> getDeclContext ( ) ) ; if ( SkipTypeProcessing . count ( Ty ) ) return ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Replacing ▁ access ▁ to ▁ property ▁ ' " << * Property << " ' ▁ by ▁ its ▁ constant ▁ initializer \n " ) ; auto PropertyAccess = Property -> getEffectiveAccess ( ) ; auto TypeAccess = Ty -> getEffectiveAccess ( ) ; auto CanRemove = false ; if ( TypeAccess <= AccessLevel :: FilePrivate || PropertyAccess <= AccessLevel :: FilePrivate || ( ( TypeAccess <= AccessLevel :: Internal || PropertyAccess <= AccessLevel :: Internal ) && Module -> isWholeModule ( ) ) ) { CanRemove = true ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Storage ▁ for ▁ property ▁ ' " << * Property << " ' ▁ can ▁ be ▁ eliminated \n " ) ; } if ( CannotRemove . count ( Property ) ) CanRemove = false ; if ( ! AccessMap . count ( Property ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ is ▁ never ▁ read \n " ) ; if ( CanRemove ) { } return ; } auto & Loads = AccessMap [ Property ] ; unsigned NumReplaced = 0 ; for ( auto Load : Loads ) { SILFunction * F = Load -> getFunction ( ) ; auto cloneInitAt = [ & ] ( SILInstruction * insertionPoint ) -> SILValue { InitSequenceCloner cloner ( init , insertionPoint ) ; return cloner . clone ( ) ; } ; if ( isa < RefElementAddrInst > ( Load ) || isa < StructElementAddrInst > ( Load ) || isa < BeginAccessInst > ( Load ) ) { auto proj = cast < SingleValueInstruction > ( Load ) ; SILValue clonedInit = cloneInitAt ( proj ) ; SILBuilderWithScope B ( proj ) ; for ( auto UI = proj -> use_begin ( ) , E = proj -> use_end ( ) ; UI != E ; ) { auto * User = UI -> getUser ( ) ; ++ UI ; if ( isIncidentalUse ( User ) ) continue ; if ( isa < BeginAccessInst > ( User ) ) continue ; if ( isa < StoreInst > ( User ) ) continue ; replaceLoadSequence ( User , clonedInit , B ) ; eraseUsesOfInstruction ( User ) ; User -> eraseFromParent ( ) ; ++ NumReplaced ; } ChangedFunctions . insert ( F ) ; } else if ( auto proj = dyn_cast < StructExtractInst > ( Load ) ) { SILValue clonedInit = cloneInitAt ( proj ) ; proj -> replaceAllUsesWith ( clonedInit ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Access ▁ to ▁ " << * Property << " ▁ was ▁ replaced : \n " ; clonedInit -> dumpInContext ( ) ) ; proj -> eraseFromParent ( ) ; ++ NumReplaced ; ChangedFunctions . insert ( F ) ; } } LLVM_DEBUG ( llvm :: dbgs ( ) << " Access ▁ to ▁ " << * Property << " ▁ was ▁ replaced ▁ " << NumReplaced << " ▁ time ( s ) \n " ) ; if ( CanRemove ) { } } static bool isStructurallyIdentical ( SILValue LHS , SILValue RHS ) { if ( LHS == RHS ) return true ; if ( LHS -> getType ( ) != RHS -> getType ( ) ) return false ; auto lResult = LHS -> getDefiningInstructionResult ( ) ; auto rResult = RHS -> getDefiningInstructionResult ( ) ; assert ( lResult && rResult && " operands ▁ of ▁ instructions ▁ approved ▁ by ▁ analyzeStaticInitializer ▁ " " should ▁ always ▁ be ▁ defined ▁ by ▁ instructions " ) ; return ( lResult -> ResultIndex == rResult -> ResultIndex && lResult -> Instruction -> isIdenticalTo ( rResult -> Instruction , isStructurallyIdentical ) ) ; } ; static bool isSameInitSequence ( const InitSequence & LHS , const InitSequence & RHS ) { assert ( LHS . isValid ( ) && RHS . isValid ( ) ) ; return isStructurallyIdentical ( LHS . Result , RHS . Result ) ; } static bool isAssignableExternally ( VarDecl * Property , SILModule * Module ) { if ( Module -> isVisibleExternally ( Property ) ) { auto * Ty = dyn_cast < NominalTypeDecl > ( Property -> getDeclContext ( ) ) ; if ( isa < ClassDecl > ( Ty ) ) return false ; for ( auto SP : Ty -> getStoredProperties ( ) ) { auto storedPropertyAccess = SP -> getEffectiveAccess ( ) ; if ( storedPropertyAccess <= AccessLevel :: FilePrivate || ( storedPropertyAccess <= AccessLevel :: Internal && Module -> isWholeModule ( ) ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ cannot ▁ be ▁ set ▁ externally \n " ) ; return false ; } } LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ can ▁ be ▁ used ▁ externally \n " ) ; return true ; } return false ; } static bool mayHaveUnknownUses ( VarDecl * Property , SILModule * Module ) { if ( Property -> getDeclContext ( ) -> getParentModule ( ) != Module -> getSwiftModule ( ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ is ▁ defined ▁ in ▁ a ▁ different ▁ module \n " ) ; return true ; } if ( isAssignableExternally ( Property , Module ) ) { return true ; } return false ; } bool LetPropertiesOpt :: isConstantLetProperty ( VarDecl * Property ) { if ( ! Property -> isLet ( ) || Property -> isStatic ( ) ) return false ; if ( SkipProcessing . count ( Property ) ) return false ; if ( PotentialConstantLetProperty . count ( Property ) ) return true ; if ( mayHaveUnknownUses ( Property , Module ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ may ▁ have ▁ unknown ▁ uses \n " ) ; SkipProcessing . insert ( Property ) ; return false ; } LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ has ▁ no ▁ unknown ▁ uses \n " ) ; if ( ! isSimpleType ( Module -> Types . getLoweredType ( Property -> getType ( ) ) , * Module ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ is ▁ not ▁ of ▁ trivial ▁ type \n " ) ; SkipProcessing . insert ( Property ) ; return false ; } PotentialConstantLetProperty . insert ( Property ) ; return true ; } static bool isProjectionOfProperty ( SILValue addr , VarDecl * Property ) { if ( auto * REA = dyn_cast < RefElementAddrInst > ( addr ) ) { return REA -> getField ( ) == Property ; } if ( auto * SEA = dyn_cast < StructElementAddrInst > ( addr ) ) { return SEA -> getField ( ) == Property ; } return false ; } bool LetPropertiesOpt :: analyzeInitValue ( SILInstruction * I , VarDecl * Property ) { SILValue value ; if ( auto SI = dyn_cast < StructInst > ( I ) ) { value = SI -> getFieldValue ( Property ) ; } else if ( auto SI = dyn_cast < StoreInst > ( I ) ) { auto Dest = stripAddressAccess ( SI -> getDest ( ) ) ; assert ( isProjectionOfProperty ( stripAddressAccess ( SI -> getDest ( ) ) , Property ) && " Store ▁ instruction ▁ should ▁ store ▁ into ▁ a ▁ proper ▁ let ▁ property " ) ; ( void ) Dest ; value = SI -> getSrc ( ) ; } if ( auto * LI = dyn_cast < LoadInst > ( value ) ) { SILValue addr = LI -> getOperand ( ) ; if ( isProjectionOfProperty ( addr , Property ) ) return true ; } InitSequence sequence ; sequence . Result = value ; if ( ! analyzeStaticInitializer ( value , sequence . Instructions ) ) return false ; auto & cachedSequence = InitMap [ Property ] ; if ( cachedSequence . isValid ( ) && ! isSameInitSequence ( cachedSequence , sequence ) ) { return false ; } else { LLVM_DEBUG ( llvm :: dbgs ( ) << " The ▁ value ▁ of ▁ property ▁ ' " << * Property << " ' ▁ is ▁ statically ▁ known ▁ so ▁ far \n " ) ; cachedSequence = std :: move ( sequence ) ; return true ; } } void LetPropertiesOpt :: collectStructPropertiesAccess ( StructInst * SI , bool NonRemovable ) { auto structDecl = SI -> getStructDecl ( ) ; if ( SkipTypeProcessing . count ( structDecl ) ) return ; if ( ! NominalTypeLetProperties . count ( structDecl ) ) { SmallVector < VarDecl * , 4 > LetProps ; for ( auto Prop : structDecl -> getStoredProperties ( ) ) { if ( ! isConstantLetProperty ( Prop ) ) continue ; LetProps . push_back ( Prop ) ; } if ( LetProps . empty ( ) ) { SkipTypeProcessing . insert ( structDecl ) ; return ; } NominalTypeLetProperties [ structDecl ] = LetProps ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Computed ▁ set ▁ of ▁ let ▁ properties ▁ for ▁ struct ▁ ' " << structDecl -> getName ( ) << " ' \n " ) ; } auto & Props = NominalTypeLetProperties [ structDecl ] ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Found ▁ a ▁ struct ▁ instruction ▁ initializing ▁ some ▁ " " let ▁ properties : ▁ " ; SI -> dumpInContext ( ) ) ; for ( auto Prop : Props ) { if ( SkipProcessing . count ( Prop ) ) continue ; SILValue PropValue = SI -> getOperandForField ( Prop ) -> get ( ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Check ▁ the ▁ value ▁ of ▁ property ▁ ' " << * Prop << " ' ▁ : " << PropValue << " \n " ) ; if ( ! analyzeInitValue ( SI , Prop ) ) { SkipProcessing . insert ( Prop ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " The ▁ value ▁ of ▁ a ▁ let ▁ property ▁ ' " << * Prop << " ' ▁ is ▁ not ▁ statically ▁ known \n " ) ; } ( void ) PropValue ; } } static bool isValidPropertyLoad ( SILInstruction * I ) { if ( isa < LoadInst > ( I ) ) return true ; if ( isa < StructElementAddrInst > ( I ) || isa < TupleElementAddrInst > ( I ) ) { auto projection = cast < SingleValueInstruction > ( I ) ; for ( auto Use : getNonDebugUses ( projection ) ) { if ( isIncidentalUse ( Use -> getUser ( ) ) ) continue ; if ( ! isValidPropertyLoad ( Use -> getUser ( ) ) ) return false ; } return true ; } return false ; } void LetPropertiesOpt :: collectPropertyAccess ( SILInstruction * I , VarDecl * Property , bool NonRemovable ) { if ( ! isConstantLetProperty ( Property ) ) return ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Collecting ▁ property ▁ access ▁ for ▁ property ▁ ' " << * Property << " ' : \n " ; llvm :: dbgs ( ) << " The ▁ instructions ▁ are : \n " ; I -> dumpInContext ( ) ) ; if ( isa < RefElementAddrInst > ( I ) || isa < StructElementAddrInst > ( I ) || isa < BeginAccessInst > ( I ) ) { auto projection = cast < SingleValueInstruction > ( I ) ; for ( auto Use : getNonDebugUses ( projection ) ) { auto * User = Use -> getUser ( ) ; if ( isIncidentalUse ( User ) ) continue ; if ( isa < BeginAccessInst > ( User ) ) continue ; if ( auto * SI = dyn_cast < StoreInst > ( User ) ) { if ( SI -> getDest ( ) != projection || ! analyzeInitValue ( SI , Property ) ) { SkipProcessing . insert ( Property ) ; return ; } continue ; } if ( ! isValidPropertyLoad ( User ) ) { SkipProcessing . insert ( Property ) ; return ; } } } AccessMap [ Property ] . push_back ( I ) ; if ( NonRemovable ) CannotRemove . insert ( Property ) ; } void LetPropertiesOpt :: run ( SILModuleTransform * T ) { for ( auto & F : * Module ) { bool NonRemovable = ! F . shouldOptimize ( ) ; for ( auto & BB : F ) { for ( auto & I : BB ) if ( auto * BAI = dyn_cast < BeginAccessInst > ( & I ) ) { if ( auto * REAI = dyn_cast < RefElementAddrInst > ( stripAddressAccess ( BAI ) ) ) { collectPropertyAccess ( BAI , REAI -> getField ( ) , NonRemovable ) ; } } else if ( auto * REAI = dyn_cast < RefElementAddrInst > ( & I ) ) { collectPropertyAccess ( REAI , REAI -> getField ( ) , NonRemovable ) ; } else if ( auto * SEI = dyn_cast < StructExtractInst > ( & I ) ) { collectPropertyAccess ( SEI , SEI -> getField ( ) , NonRemovable ) ; } else if ( auto * SEAI = dyn_cast < StructElementAddrInst > ( & I ) ) { collectPropertyAccess ( SEAI , SEAI -> getField ( ) , NonRemovable ) ; } else if ( auto * SI = dyn_cast < StructInst > ( & I ) ) { collectStructPropertiesAccess ( SI , NonRemovable ) ; } } } for ( auto & Init : InitMap ) { optimizeLetPropertyAccess ( Init . first , Init . second ) ; } for ( SILFunction * ChangedFn : ChangedFunctions ) { T -> invalidateAnalysis ( ChangedFn , SILAnalysis :: InvalidationKind :: Instructions ) ; } } namespace { class LetPropertiesOptPass : public SILModuleTransform { void run ( ) override { LetPropertiesOpt ( getModule ( ) ) . run ( this ) ; } } ; } SILTransform * swift :: createLetPropertiesOpt ( ) { return new LetPropertiesOptPass ( ) ; } </DOCUMENT>
<DOCUMENT_ID="lunastorm/wissbi/tree/master/3rd_party/libcxx/test/strings/basic.string/string.modifiers/string_append/pointer.pass.cpp"> # include < string > # include < stdexcept > # include < cassert > template < class S > void test ( S s , const typename S :: value_type * str , S expected ) { s . append ( str ) ; assert ( s . __invariants ( ) ) ; assert ( s == expected ) ; } int main ( ) { typedef std :: string S ; test ( S ( ) , " " , S ( ) ) ; test ( S ( ) , "12345" , S ( "12345" ) ) ; test ( S ( ) , "12345678901234567890" , S ( "12345678901234567890" ) ) ; test ( S ( "12345" ) , " " , S ( "12345" ) ) ; test ( S ( "12345" ) , "12345" , S ( "1234512345" ) ) ; test ( S ( "12345" ) , "1234567890" , S ( "123451234567890" ) ) ; test ( S ( "12345678901234567890" ) , " " , S ( "12345678901234567890" ) ) ; test ( S ( "12345678901234567890" ) , "12345" , S ( "1234567890123456789012345" ) ) ; test ( S ( "12345678901234567890" ) , "12345678901234567890" , S ( "1234567890123456789012345678901234567890" ) ) ; } </DOCUMENT>
<DOCUMENT_ID="krf/kdevelop/tree/master/debuggers/gdb/printers/tests/qmapint.cpp"> # include < QMap > int main ( ) { QMap < int , int > m ; m [ 10 ] = 100 ; m [ 20 ] = 200 ; m [ 30 ] = 300 ; return 0 ; } </DOCUMENT>
