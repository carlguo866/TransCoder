Scenario_Document1 :: Scenario_Document1 ( ) { InitializeComponent ( ) ; }
void Scenario_Document1 :: Page_Loaded ( Platform :: Object ^ sender , Windows :: UI :: Xaml :: Routed@@ EventArgs ^ e ) { this -> FontFamily = ref new Windows :: UI :: Xaml :: Media :: FontFamily ( " Neue ▁ Haas ▁ Grotesk ▁ Text ▁ Pro " ) ; }
CGLContextEGL :: ~ CGLContextEGL ( ) { Destroy ( ) ; }
bool CGLContextEGL :: CreateDisplay ( EGLDisplay display , EGLint renderable_type , EGLint rendering_api ) { EGLint neglconfigs = 0 ; int major , minor ; EGLint surface_type = EGL_WINDOW_@@ BIT ; if ( g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION || g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION ) surface_type |= EGL_SWAP_BEHAVIOR_@@ PRESERV@@ ED_BIT ; EGLint attribs [ ] = { EGL_RED@@ _SIZE , 8 , EGL_GRE@@ EN_SIZE , 8 , EGL_BL@@ UE_SIZE , 8 , EGL_ALPH@@ A_SIZE , 8 , EGL_DEP@@ TH_SIZE , 16 , EGL_STENCI@@ L_SIZE , 0 , EGL_SAMPLE_BUFFERS , 0 , EGL_SAMPLES , 0 , EGL_SURFACE_@@ TYPE , surface_type , EGL_RENDER@@ ABLE_TYPE , renderable_type , EGL_NONE } ; if ( m_eglDisplay == EGL_NO_DISPLAY ) { m_eglDisplay = eglGetDisplay ( ( EGLNativeDisplayType ) display ) ; } if ( m_eglDisplay == EGL_NO_DISPLAY ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ get ▁ EGL ▁ display " ) ; return false ; } if ( ! eglInitialize ( m_eglDisplay , & major , & minor ) ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ initialize ▁ EGL ▁ display " ) ; return false ; } eglBindAPI ( rendering_api ) ; if ( ! eglChoo@@ seConfig ( m_eglDisplay , attribs , & m_eglConfig , 1 , & neglconfigs ) ) { CLog :: Log ( LOGERROR , " Failed ▁ to ▁ query ▁ number ▁ of ▁ EGL ▁ configs " ) ; return false ; } if ( neglconfigs <= 0 ) { CLog :: Log ( LOGERROR , " No ▁ suitable ▁ EGL ▁ configs ▁ found " ) ; return false ; } return true ; }
bool CGLContextEGL :: CreateContext ( ) { int client_version = 2 ; const EGLint context_attribs [ ] = { EGL_CONTEXT_@@ CLIENT_VERSION , client_version , EGL_NONE } ; if ( m_eglContext == EGL_NO_CONTEXT ) { m_eglContext = eglCreateContext ( m_eglDisplay , m_eglConfig , EGL_NO_CONTEXT , context_attribs ) ; } if ( m_eglContext == EGL_NO_CONTEXT ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ create ▁ EGL ▁ context " ) ; return false ; } return true ; }
bool CGLContextEGL :: BindContext ( ) { if ( ! eglMakeCurrent ( m_eglDisplay , m_eglSurface , m_eglSurface , m_eglContext ) ) { CLog :: Log ( LOGERROR , " Failed ▁ to ▁ make ▁ context ▁ current ▁ % p ▁ % p ▁ % p " , m_eglDisplay , m_eglSurface , m_eglContext ) ; return false ; } return true ; }
bool CGLContextEGL :: SurfaceAttrib ( ) { if ( g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION || g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION ) { if ( ( m_eglDisplay == EGL_NO_DISPLAY ) || ( m_eglSurface == EGL_NO_SURFACE ) ) { return false ; } if ( ! eglSurfaceAttrib ( m_eglDisplay , m_eglSurface , EGL_SWAP_BEHAVIOR , EGL_BUFFER_@@ PRESERVED ) ) { CLog :: Log ( LOGDEBUG , " % s : ▁ Could ▁ not ▁ set ▁ EGL _ SWAP _ BEHAVIOR " , __FUNCTION__ ) ; } } return true ; }
bool CGLContextEGL :: CreateSurface ( EGLNativeWindowType surface ) { m_eglSurface = eglCreateWindow@@ Surface ( m_eglDisplay , m_eglConfig , surface , nullptr ) ; if ( m_eglSurface == EGL_NO_SURFACE ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ create ▁ EGL ▁ window ▁ surface ▁ % d " , eglGetError ( ) ) ; return false ; } return true ; }
void CGLContextEGL :: Destroy ( ) { if ( m_eglContext != EGL_NO_CONTEXT ) { eglDestroyContext ( m_eglDisplay , m_eglContext ) ; eglMakeCurrent ( m_eglDisplay , EGL_NO_SURFACE , EGL_NO_SURFACE , EGL_NO_CONTEXT ) ; m_eglContext = EGL_NO_CONTEXT ; } if ( m_eglSurface != EGL_NO_SURFACE ) { eglDestroySurface ( m_eglDisplay , m_eglSurface ) ; m_eglSurface = EGL_NO_SURFACE ; } if ( m_eglDisplay != EGL_NO_DISPLAY ) { eglTerminate ( m_eglDisplay ) ; m_eglDisplay = EGL_NO_DISPLAY ; } }
void CGLContextEGL :: Detach ( ) { if ( m_eglContext != EGL_NO_CONTEXT ) { eglMakeCurrent ( m_eglDisplay , EGL_NO_SURFACE , EGL_NO_SURFACE , EGL_NO_CONTEXT ) ; } if ( m_eglSurface != EGL_NO_SURFACE ) { eglDestroySurface ( m_eglDisplay , m_eglSurface ) ; m_eglSurface = EGL_NO_SURFACE ; } }
bool CGLContextEGL :: SetVSync ( bool enable ) { if ( ! eglSwapInterval ( m_eglDisplay , enable ) ) { return false ; } return true ; }
void CGLContextEGL :: SwapBuffers ( ) { if ( m_eglDisplay == EGL_NO_DISPLAY || m_eglSurface == EGL_NO_SURFACE ) { return ; } eglSwapBuffers ( m_eglDisplay , m_eglSurface ) ; }
SDThread :: SDThread ( DatasetDW@@ I * ds , int id ) : m_dataset ( ds ) , m_id ( id ) { m_dwi = ds -> getData ( ) ; m_bvals = ds -> getBvals ( ) ; m_bvecs = ds -> getBvecs ( ) ; int nx = ds -> properties ( " maingl " ) . get ( Fn :: Property :: D_NX ) . toInt ( ) ; int ny = ds -> properties ( " maingl " ) . get ( Fn :: Property :: D_NY ) . toInt ( ) ; int nz = ds -> properties ( " maingl " ) . get ( Fn :: Property :: D_NZ ) . toInt ( ) ; m_blockSize = nx * ny * nz ; }
void SDThread :: run ( ) { int numThreads = GLFunctions :: idealThread@@ Count ; int progressCounter = 0 ; for ( int i = m_id ; i < m_blockSize ; i += numThreads ) { calcSD ( i ) ; ++ progressCounter ; if ( progressCounter == 100 ) { emit ( progress ( ) ) ; progressCounter = 0 ; } } emit ( finished ( ) ) ; }
ColumnVector SDThread :: calcSD ( int id ) { return ColumnVector ( 20 ) ; }
Cylinder * TrashHolder :: __queryDestination ( int32_t & , const Thing * , Item * * , uint32_t & ) { return this ; }
void TrashHolder :: __addThing ( Thing * thing ) { return __addThing ( 0 , thing ) ; }
void TrashHolder :: __addThing ( int32_t , Thing * thing ) { Item * item = thing -> getItem ( ) ; if ( ! item ) { return ; } if ( item == this || ! item -> hasProperty ( CONST_PROP_MOVEABLE ) ) { return ; } if ( item -> isHangable ( ) && isGroundTile ( ) ) { Tile * tile = dynamic_cast < Tile * > ( getParent ( ) ) ; if ( tile && tile -> hasFlag ( TILESTATE_SUPPORTS_@@ HANGABLE ) ) { return ; } } g_game . internalRemoveItem ( item ) ; const ItemType & it = Item :: items [ getID ( ) ] ; if ( it . magicEffect != CONST_ME_NONE ) { g_game . addMagicEffect ( getPosition ( ) , it . magicEffect ) ; } }
void TrashHolder :: postAddNotification ( Thing * thing , const Cylinder * oldParent , int32_t index , cylinderlink_t ) { getParent ( ) -> postAddNotification ( thing , oldParent , index , LINK_PARENT ) ; }
void TrashHolder :: postRemoveNotification ( Thing * thing , const Cylinder * newParent , int32_t index , bool isCompleteRemoval , cylinderlink_t ) { getParent ( ) -> postRemoveNotification ( thing , newParent , index , isCompleteRemoval , LINK_PARENT ) ; }
PassRefPtrWillBeRawPtr < HTMLContentElement > HTMLContentElement :: create ( Document & document , PassOwnPtrWillBeRawPtr < HTMLContentSelectFilter > filter ) { return adoptRefWillBe@@ Noop ( new HTMLContentElement ( document , filter ) ) ; }
void HTMLContentElement :: parseSelect ( ) { ASSERT ( m_shouldParseSelect ) ; CSSParser :: parseSelector ( CSSParser@@ Context ( document ( ) , 0 ) , m_select , m_selectorList ) ; m_shouldParseSelect = false ; m_isValidSelector = validateSelect ( ) ; if ( ! m_isValidSelector ) { CSSSelectorList emptyList ; m_selectorList . adopt ( emptyList ) ; } }
void HTMLContentElement :: parseAttribute ( const QualifiedName & name , const AtomicString & value ) { if ( name == selectAttr ) { if ( ShadowRoot * root = containingShadowRoot ( ) ) root -> owner ( ) -> willAffectSelector ( ) ; m_shouldParseSelect = true ; m_select = value ; } else { InsertionPoint :: parseAttribute ( name , value ) ; } }
selector = CSSSelectorList :: next ( * selector ) ) { context . selector = selector ; if ( selectorChecker . match ( context ) ) return true ; }
void AsmRout@@ ineManager :: Generate ( MIPSState * mips , MIPSComp :: Jit * jit , MIPSComp :: JitOptions * jo ) { enterCode = AlignCode16 ( ) ; ABI_PushAllCalleeSavedRegsAndAdjustStack ( ) ; MOV ( 64 , R ( MEMBASEREG ) , ImmPtr ( Memory :: base ) ) ; uintptr_t jitbase = ( uintptr_t ) jit -> GetBasePtr ( ) ; if ( jitbase > 0x7FFFF@@ FFFULL ) { MOV ( 64 , R ( JITBASEREG ) , ImmPtr ( jit -> GetBasePtr ( ) ) ) ; jo -> reserveR15ForAsm = true ; } MOV ( PTRBITS , R ( CTXREG ) , ImmPtr ( & mips -> f [ 0 ] ) ) ; outerLoop = GetCodePtr ( ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_CallFunction ( reinterpret_cast < void * > ( & CoreTiming :: Advance ) ) ; jit -> ApplyRoundingMode ( true , this ) ; FixupBranch skipToRealDispatch = J ( ) ; dispatcherCheckCoreState = GetCodePtr ( ) ; FixupBranch bailCoreState = J_CC ( CC_S , true ) ; CMP ( 32 , M ( & coreState ) , Imm32 ( 0 ) ) ; FixupBranch badCoreState = J_CC ( CC_NZ , true ) ; FixupBranch skipToRealDispatch2 = J ( ) ; dispatcher = GetCodePtr ( ) ; FixupBranch bail = J_CC ( CC_S , true ) ; SetJumpTarget ( skipToRealDispatch ) ; SetJumpTarget ( skipToRealDispatch2 ) ; dispatcherNoCheck = GetCodePtr ( ) ; MOV ( 32 , R ( EAX ) , M ( & mips -> pc ) ) ; dispatcherInEA@@ XNoCheck = GetCodePtr ( ) ; AND ( 32 , R ( EAX ) , Imm32 ( Memory :: MEMVIEW@@ 32_MASK ) ) ; _assert_msg_ ( CPU , Memory :: base != 0 , " Memory ▁ base ▁ bogus " ) ; MOV ( 32 , R ( EAX ) , MDisp ( EAX , ( u32 ) Memory :: base ) ) ; # elif _M_X64 MOV ( 32 , R ( EAX ) , MComplex ( MEMBASEREG , RAX , SCALE_1 , 0 ) ) ; MOV ( 32 , R ( EDX ) , R ( EAX ) ) ; _assert_msg_ ( JIT , MIPS_JITBLOC@@ K_MASK == 0xFF000000 , " Hardcoded ▁ assump@@ tion ▁ of ▁ emuh@@ ack ▁ mask " ) ; SHR ( 32 , R ( EDX ) , Imm8 ( 24 ) ) ; CMP ( 32 , R ( EDX ) , Imm8 ( MIPS_EMUHACK_OPCODE >> 24 ) ) ; FixupBranch notfound = J_CC ( CC_NE ) ; if ( enableDebug ) { ADD ( 32 , M ( & mips -> debugCount ) , Imm8 ( 1 ) ) ; } AND ( 32 , R ( EAX ) , Imm32 ( MIPS_EMUHACK_VALUE_MASK ) ) ; ADD ( 32 , R ( EAX ) , ImmPtr ( jit -> GetBasePtr ( ) ) ) ; # elif _M_X64 if ( jo -> reserveR15ForAsm ) ADD ( 64 , R ( RAX ) , R ( JITBASEREG ) ) ; else ADD ( 64 , R ( EAX ) , Imm32 ( jitbase ) ) ; JMPptr ( R ( EAX ) ) ; SetJumpTarget ( notfound ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_CallFunction ( & MIPSComp :: JitAt ) ; jit -> ApplyRoundingMode ( true , this ) ; JMP ( dispatcherNoCheck , true ) ; SetJumpTarget ( bail ) ; SetJumpTarget ( bailCoreState ) ; CMP ( 32 , M ( & coreState ) , Imm32 ( 0 ) ) ; J_CC ( CC_Z , outerLoop , true ) ; SetJumpTarget ( badCoreState ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_PopAllCalleeSavedRegsAndAdjustStack ( ) ; RET ( ) ; breakpointBailout = GetCodePtr ( ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_PopAllCalleeSavedRegsAndAdjustStack ( ) ; RET ( ) ; }
bool GlyphPage :: fill ( unsigned offset , unsigned length , UChar * buffer , unsigned bufferLength , const SimpleFontData * fontData ) { bool haveGlyphs = false ; if ( ! shouldUseCoreText ( buffer , bufferLength , fontData ) ) { Vector < CGGlyph , 512 > glyphs ( bufferLength ) ; wkGetGlyphsFor@@ Characters ( fontData -> platformData ( ) . cgFont ( ) , buffer , glyphs . data ( ) , bufferLength ) ; for ( unsigned i = 0 ; i < length ; ++ i ) { if ( ! glyphs [ i ] ) setGlyphDataForIndex ( offset + i , 0 , 0 ) ; else { setGlyphDataForIndex ( offset + i , glyphs [ i ] , fontData ) ; haveGlyphs = true ; } } } else { RetainPtr < CFStringRef > string ( AdoptCF , CFStringCreateWith@@ CharactersNo@@ Copy ( kCFAllocatorDefault , buffer , bufferLength , kCFAllocatorNull ) ) ; RetainPtr < CFAttributedStringRef > attributedString ( AdoptCF , CFAttributedStringCreate ( kCFAllocatorDefault , string . get ( ) , fontData -> getCFStringAttributes ( 0 , fontData -> hasVerticalGlyphs ( ) ? Vertical : Horizontal ) ) ) ; RetainPtr < CTLineRef > line ( AdoptCF , CTLineCreateWith@@ AttributedString ( attributedString . get ( ) ) ) ; CFArrayRef runArray = CTLineGetGlyphRuns ( line . get ( ) ) ; CFIndex runCount = CFArrayGetCount ( runArray ) ; for ( unsigned index = 0 ; index < length ; ++ index ) setGlyphDataForIndex ( offset + index , 0 , 0 ) ; Vector < CGGlyph , 512 > glyphVector ; Vector < CFIndex , 512 > indexVector ; bool done = false ; RetainPtr < CGFontRef > cgFont ( AdoptCF , CTFontCopyGraphicsFont ( fontData -> platformData ( ) . ctFont ( ) , 0 ) ) ; for ( CFIndex r = 0 ; r < runCount && ! done ; ++ r ) { CTRunRef ctRun = static_cast < CTRunRef > ( CFArrayGetValueAtIndex ( runArray , r ) ) ; ASSERT ( CFGetTypeID ( ctRun ) == CTRunGetTypeID ( ) ) ; CFDictionaryRef attributes = CTRunGetAttributes ( ctRun ) ; CTFontRef runFont = static_cast < CTFontRef > ( CFDictionaryGetValue ( attributes , kCTFontAttributeName ) ) ; RetainPtr < CGFontRef > runCGFont ( AdoptCF , CTFontCopyGraphicsFont ( runFont , 0 ) ) ; if ( CFEqual ( cgFont . get ( ) , runCGFont . get ( ) ) ) { CFIndex glyphCount = CTRunGetGlyphCount ( ctRun ) ; const CGGlyph * glyphs = CTRunGetGlyphsPtr ( ctRun ) ; if ( ! glyphs ) { glyphVector . resize ( glyphCount ) ; CTRunGetGlyphs ( ctRun , CFRangeMake ( 0 , 0 ) , glyphVector . data ( ) ) ; glyphs = glyphVector . data ( ) ; } const CFIndex * stringIndices = CTRunGetStringIndices@@ Ptr ( ctRun ) ; if ( ! stringIndices ) { indexVector . resize ( glyphCount ) ; CTRunGetStringIndices ( ctRun , CFRangeMake ( 0 , 0 ) , indexVector . data ( ) ) ; stringIndices = indexVector . data ( ) ; } for ( CFIndex i = 0 ; i < glyphCount ; ++ i ) { if ( stringIndices [ i ] >= static_cast < CFIndex > ( length ) ) { done = true ; break ; } if ( glyphs [ i ] ) { setGlyphDataForIndex ( offset + stringIndices [ i ] , glyphs [ i ] , fontData ) ; haveGlyphs = true ; } } } } } return haveGlyphs ; }
bool QEventDispatcherX11 :: processEvents ( QEventLoop :: ProcessEvents@@ Flags flags ) { Q_D ( QEventDispatcherX11 ) ; d -> interrupt = false ; QApplication :: sendPostedEvents ( ) ; ulong marker = XNextRequest ( X11 -> display ) ; int nevents = 0 ; do { while ( ! d -> interrupt ) { XEvent event ; if ( ! ( flags & QEventLoop :: ExcludeUserInputEvents ) && ! d -> queuedUserInputEvents . isEmpty ( ) ) { event = d -> queuedUserInputEvents . takeFirst ( ) ; } else if ( XEventsQueued ( X11 -> display , QueuedAlready ) ) { XNextEvent ( X11 -> display , & event ) ; if ( flags & QEventLoop :: ExcludeUserInputEvents ) { switch ( event . type ) { case ButtonPress : case ButtonRelease : case MotionNotify : case XKeyPress : case XKeyRelease : case EnterNotify : case LeaveNotify : d -> queuedUserInputEvents . append ( event ) ; continue ; case ClientMessage : if ( event . xclient . format == 32 ) { if ( event . xclient . message_type == ATOM ( WM_PROTO@@ COLS ) && ( Atom ) event . xclient . data . l [ 0 ] == ATOM ( WM_TAKE_@@ FOCUS ) ) { break ; } else if ( event . xclient . message_type == ATOM ( _QT_SCROLL_@@ DONE ) ) { break ; } } d -> queuedUserInputEvents . append ( event ) ; continue ; default : break ; } } } else { break ; } if ( filterEvent ( & event ) ) continue ; nevents ++ ; if ( qApp -> x11ProcessEvent ( & event ) == 1 ) return true ; if ( event . xany . serial >= marker ) { if ( XEventsQueued ( X11 -> display , QueuedAfterFlush ) ) flags &= ~ QEventLoop :: WaitForMoreEvents ; goto out ; } } } while ( ! d -> interrupt && XEventsQueued ( X11 -> display , QueuedAfterFlush ) ) ; out : if ( ! d -> interrupt ) { const uint exclude_all = QEventLoop :: ExcludeSocketNoti@@ fiers | QEventLoop :: X11Exclude@@ Timers | QEventLoop :: WaitForMoreEvents ; if ( nevents > 0 && ( ( uint ) flags & exclude_all ) == exclude_all ) { QApplication :: sendPostedEvents ( ) ; return nevents > 0 ; } return QEventDispatcherUNIX :: processEvents ( flags ) || ( nevents > 0 ) ; } return nevents > 0 ; }
bool QEventDispatcherX11 :: hasPending@@ Events ( ) { extern uint qGlobalPostedEventsCount ( ) ; return ( qGlobalPostedEventsCount ( ) || XPending ( X11 -> display ) ) ; }
void QEventDispatcherX11 :: flush ( ) { XFlush ( X11 -> display ) ; }
void QEventDispatcherX11 :: startingUp ( ) { Q_D ( QEventDispatcherX11 ) ; d -> xfd = XConnectionNumber ( X11 -> display ) ; }
void QEventDispatcherX11 :: closingDown ( ) { Q_D ( QEventDispatcherX11 ) ; d -> xfd = - 1 ; }
int QEventDispatcherX11 :: select ( int nfds , fd_set * readfds , fd_set * writefds , fd_set * exceptfds , timeval * timeout ) { Q_D ( QEventDispatcherX11 ) ; if ( d -> xfd > 0 ) { nfds = qMax ( nfds - 1 , d -> xfd ) + 1 ; FD_SET ( d -> xfd , readfds ) ; } return QEventDispatcherUNIX :: select ( nfds , readfds , writefds , exceptfds , timeout ) ; }
inline SVGFontFaceUriElement :: SVGFontFaceUriElement ( Document & document ) : SVGElement ( font_face_uriTag , document ) { ScriptWrappable :: init ( this ) ; }
void SVGFontFaceUriElement :: parseAttribute ( const QualifiedName & name , const AtomicString & value ) { if ( name . matches ( XLinkNames :: hrefAttr ) ) loadFont ( ) ; else SVGElement :: parseAttribute ( name , value ) ; }
void SVGFontFaceUriElement :: childrenChanged ( const ChildrenChange & change ) { SVGElement :: childrenChanged ( change ) ; if ( ! isSVGFontFaceSrcElement ( parentNode ( ) ) ) return ; ContainerNode * grandparent = parentNode ( ) -> parentNode ( ) ; if ( isSVGFontFaceElement ( grandparent ) ) toSVGFontFaceElement ( * grandparent ) . rebuildFontFace ( ) ; }
Node :: InsertionNotificationRequest SVGFontFaceUriElement :: insertedInto ( ContainerNode * rootParent ) { loadFont ( ) ; return SVGElement :: insertedInto ( rootParent ) ; }
void SVGFontFaceUriElement :: loadFont ( ) { if ( m_resource ) m_resource -> removeClient ( this ) ; const AtomicString & href = getAttribute ( XLinkNames :: hrefAttr ) ; if ( ! href . isNull ( ) ) { ResourceFetcher * fetcher = document ( ) . fetcher ( ) ; FetchRequest request ( ResourceRequest ( document ( ) . completeURL ( href ) ) , localName ( ) ) ; m_resource = fetcher -> fetchFont ( request ) ; if ( m_resource ) { m_resource -> addClient ( this ) ; m_resource -> beginLoadIf@@ Needed ( fetcher ) ; } } else { m_resource = 0 ; } }
HASHwithTransform :: HASHwithTransform ( word32 digSz , word32 buffSz ) { assert ( digSz <= MaxDigestSz ) ; assert ( buffSz <= MaxBufferSz ) ; }
void HASHwithTransform :: AddLength ( word32 len ) { HashLengthType tmp = loLen_ ; if ( ( loLen_ += len ) < tmp ) hiLen_ ++ ; hiLen_ += SafeRightShift < 8 * sizeof ( HashLengthType ) > ( len ) ; }
void HASHwithTransform :: Update ( const byte * data , word32 len ) { word32 blockSz = getBlockSize ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; while ( len ) { word32 add = min ( len , blockSz - buffLen_ ) ; memcpy ( & local [ buffLen_ ] , data , add ) ; buffLen_ += add ; data += add ; len -= add ; if ( buffLen_ == blockSz ) { ByteReverseIf ( local , local , blockSz , getByteOrder ( ) ) ; Transform ( ) ; AddLength ( blockSz ) ; buffLen_ = 0 ; } } }
void HASHwithTransform :: Final ( byte * hash ) { word32 blockSz = getBlockSize ( ) ; word32 digestSz = getDigestSize ( ) ; word32 padSz = getPadSize ( ) ; ByteOrder order = getByteOrder ( ) ; AddLength ( buffLen_ ) ; HashLengthType preLoLen = GetBitCountLo ( ) ; HashLengthType preHiLen = GetBitCountHi ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; local [ buffLen_ ++ ] = 0x80 ; if ( buffLen_ > padSz ) { memset ( & local [ buffLen_ ] , 0 , blockSz - buffLen_ ) ; buffLen_ += blockSz - buffLen_ ; ByteReverseIf ( local , local , blockSz , order ) ; Transform ( ) ; buffLen_ = 0 ; } memset ( & local [ buffLen_ ] , 0 , padSz - buffLen_ ) ; ByteReverseIf ( local , local , blockSz , order ) ; memcpy ( & local [ padSz ] , order ? & preHiLen : & preLoLen , sizeof ( preLoLen ) ) ; memcpy ( & local [ padSz + 4 ] , order ? & preLoLen : & preHiLen , sizeof ( preLoLen ) ) ; Transform ( ) ; ByteReverseIf ( digest_ , digest_ , digestSz , order ) ; memcpy ( hash , digest_ , digestSz ) ; Init ( ) ; }
HASH64withTransform :: HASH64withTransform ( word32 digSz , word32 buffSz ) { assert ( digSz <= MaxDigestSz ) ; assert ( buffSz <= MaxBufferSz ) ; }
void HASH64withTransform :: AddLength ( word32 len ) { HashLengthType tmp = loLen_ ; if ( ( loLen_ += len ) < tmp ) hiLen_ ++ ; hiLen_ += SafeRightShift < 8 * sizeof ( HashLengthType ) > ( len ) ; }
void HASH64withTransform :: Update ( const byte * data , word32 len ) { word32 blockSz = getBlockSize ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; while ( len ) { word32 add = min ( len , blockSz - buffLen_ ) ; memcpy ( & local [ buffLen_ ] , data , add ) ; buffLen_ += add ; data += add ; len -= add ; if ( buffLen_ == blockSz ) { ByteReverseIf ( buffer_ , buffer_ , blockSz , getByteOrder ( ) ) ; Transform ( ) ; AddLength ( blockSz ) ; buffLen_ = 0 ; } } }
void HASH64withTransform :: Final ( byte * hash ) { word32 blockSz = getBlockSize ( ) ; word32 digestSz = getDigestSize ( ) ; word32 padSz = getPadSize ( ) ; ByteOrder order = getByteOrder ( ) ; AddLength ( buffLen_ ) ; HashLengthType preLoLen = GetBitCountLo ( ) ; HashLengthType preHiLen = GetBitCountHi ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; local [ buffLen_ ++ ] = 0x80 ; if ( buffLen_ > padSz ) { memset ( & local [ buffLen_ ] , 0 , blockSz - buffLen_ ) ; buffLen_ += blockSz - buffLen_ ; ByteReverseIf ( buffer_ , buffer_ , blockSz , order ) ; Transform ( ) ; buffLen_ = 0 ; } memset ( & local [ buffLen_ ] , 0 , padSz - buffLen_ ) ; ByteReverseIf ( buffer_ , buffer_ , padSz , order ) ; buffer_ [ blockSz / sizeof ( word64 ) - 2 ] = order ? preHiLen : preLoLen ; buffer_ [ blockSz / sizeof ( word64 ) - 1 ] = order ? preLoLen : preHiLen ; Transform ( ) ; ByteReverseIf ( digest_ , digest_ , digestSz , order ) ; memcpy ( hash , digest_ , digestSz ) ; Init ( ) ; }
XbelWriter :: XbelWriter ( BookmarkModel * model ) : QXmlStreamWriter ( ) , treeModel ( model ) { setAutoFormatting ( true ) ; }
void XbelWriter :: writeToFile ( QIODevice * device ) { setDevice ( device ) ; writeStart@@ Document ( ) ; writeDT@@ D ( QLatin1String ( " < ! DOCTYPE ▁ xbel > " ) ) ; writeStartElement ( QLatin1String ( " xbel " ) ) ; writeAttribute ( QLatin1String ( " version " ) , QLatin1String ( "1.0" ) ) ; QStandardItem * root = treeModel -> invisibleRootItem ( ) ; for ( int i = 0 ; i < root -> rowCount ( ) ; ++ i ) writeData ( root -> child ( i ) ) ; writeEnd@@ Document ( ) ; }
void XbelWriter :: writeData ( QStandardItem * child ) { Bookmark entry ; entry . title = child -> data ( Qt :: DisplayRole ) . toString ( ) ; entry . url = child -> data ( Qt :: UserRole + 10 ) . toString ( ) ; if ( entry . url == QLatin1String ( " Folder " ) ) { writeStartElement ( QLatin1String ( " folder " ) ) ; entry . folded = ! child -> data ( Qt :: UserRole + 11 ) . toBool ( ) ; writeAttribute ( QLatin1String ( " folded " ) , entry . folded ? QLatin1String ( " yes " ) : QLatin1String ( " no " ) ) ; writeTextElement ( QLatin1String ( " title " ) , entry . title ) ; for ( int i = 0 ; i < child -> rowCount ( ) ; ++ i ) writeData ( child -> child ( i ) ) ; writeEndElement ( ) ; } else { writeStartElement ( QLatin1String ( " bookmark " ) ) ; writeAttribute ( QLatin1String ( " href " ) , entry . url ) ; writeTextElement ( QLatin1String ( " title " ) , entry . title ) ; writeEndElement ( ) ; } }
XbelReader :: XbelReader ( BookmarkModel * tree , BookmarkModel * list ) : QXmlStreamReader ( ) , treeModel ( tree ) , listModel ( list ) { bookmarkIcon = QIcon ( QLatin1String ( " : / help / images / bookmark . png " ) ) ; folderIcon = QApplication :: style ( ) -> standardIcon ( QStyle :: SP_Dir@@ ClosedIcon ) ; }
bool XbelReader :: readFromFile ( QIODevice * device ) { setDevice ( device ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " xbel " ) && attributes ( ) . value ( QLatin1String ( " version " ) ) == QLatin1String ( "1.0" ) ) { readXBEL ( ) ; } else { raiseError ( QCoreApplication :: translate ( " Help : : Internal : : XbelReader " , " The ▁ file ▁ is ▁ not ▁ an ▁ XBEL ▁ version ▁ 1.0 ▁ file . " ) ) ; } } } return ! error ( ) ; }
void XbelReader :: readXBEL ( ) { while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " folder " ) ) readFolder ( 0 ) ; else if ( name ( ) == QLatin1String ( " bookmark " ) ) readBookmark ( 0 ) ; else readUnknownElement ( ) ; } } }
void XbelReader :: readUnknownElement ( ) { while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) readUnknownElement ( ) ; } }
void XbelReader :: readFolder ( QStandardItem * item ) { QStandardItem * folder = createChildItem ( item ) ; folder -> setIcon ( folderIcon ) ; folder -> setData ( QLatin1String ( " Folder " ) , Qt :: UserRole + 10 ) ; bool expanded = ( attributes ( ) . value ( QLatin1String ( " folded " ) ) != QLatin1String ( " no " ) ) ; folder -> setData ( expanded , Qt :: UserRole + 11 ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " title " ) ) folder -> setText ( readElementText ( ) ) ; else if ( name ( ) == QLatin1String ( " folder " ) ) readFolder ( folder ) ; else if ( name ( ) == QLatin1String ( " bookmark " ) ) readBookmark ( folder ) ; else readUnknownElement ( ) ; } } }
void XbelReader :: readBookmark ( QStandardItem * item ) { QStandardItem * bookmark = createChildItem ( item ) ; bookmark -> setIcon ( bookmarkIcon ) ; bookmark -> setText ( QCoreApplication :: translate ( " Help : : Internal : : XbelReader " , " Unknown ▁ title " ) ) ; bookmark -> setData ( attributes ( ) . value ( QLatin1String ( " href " ) ) . toString ( ) , Qt :: UserRole + 10 ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " title " ) ) bookmark -> setText ( readElementText ( ) ) ; else readUnknownElement ( ) ; } } listModel -> appendRow ( bookmark -> clone ( ) ) ; }
QStandardItem * XbelReader :: createChildItem ( QStandardItem * item ) { QStandardItem * childItem = new QStandardItem ( ) ; childItem -> setEditable ( false ) ; if ( item ) item -> appendRow ( childItem ) ; else treeModel -> appendRow ( childItem ) ; return childItem ; }
bool CGUIDialogLibExportSettings :: Show ( CLibExportSettings & settings ) { CGUIDialogLibExportSettings * dialog = CServiceBroker :: GetGUI ( ) -> GetWindowManager ( ) . GetWindow < CGUIDialogLibExportSettings > ( WINDOW_DIALOG_LIBEXPORT_SETTINGS ) ; if ( ! dialog ) return false ; dialog -> m_settings . SetExportType ( CServiceBroker :: GetSettings ( ) . GetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) ) ; dialog -> m_settings . m_strPath = CServiceBroker :: GetSettings ( ) . GetString ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; dialog -> m_settings . SetItemsToExport ( CServiceBroker :: GetSettings ( ) . GetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS ) ) ; dialog -> m_settings . m_unscraped = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED ) ; dialog -> m_settings . m_artwork = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK ) ; dialog -> m_settings . m_skipnfo = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO ) ; dialog -> m_settings . m_overwrite = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE ) ; dialog -> m_destinationChecked = false ; dialog -> Open ( ) ; bool confirmed = dialog -> IsConfirm@@ ed ( ) ; if ( confirmed ) { settings = dialog -> m_settings ; } return confirmed ; }
void CGUIDialogLibExportSettings :: OnInitWindow ( ) { CGUIDialogSettingsManualBase :: OnInitWindow ( ) ; }
void CGUIDialogLibExportSettings :: OnSettingChanged ( std :: shared_ptr < const CSetting > setting ) { if ( ! setting ) return ; CGUIDialogSettingsManualBase :: OnSettingChanged ( setting ) ; const std :: string & settingId = setting -> GetId ( ) ; if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) { m_settings . SetExportType ( std :: static_pointer_cast < const CSettingInt > ( setting ) -> GetValue ( ) ) ; SetupView ( ) ; SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) { m_settings . m_strPath = std :: static_pointer_cast < const CSettingString > ( setting ) -> GetValue ( ) ; UpdateButtons ( ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE ) m_settings . m_overwrite = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS ) m_settings . SetItemsToExport ( GetExportItemsFromSetting ( setting ) ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK ) { m_settings . m_artwork = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED ) m_settings . m_unscraped = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO ) m_settings . m_skipnfo = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; }
void CGUIDialogLibExportSettings :: OnSettingAction ( std :: shared_ptr < const CSetting > setting ) { if ( setting == NULL ) return ; CGUIDialogSettingsManualBase :: OnSettingAction ( setting ) ; const std :: string & settingId = setting -> GetId ( ) ; if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) { VECSOURCES shares ; g_mediaManager . GetLocalDrives ( shares ) ; g_mediaManager . GetNetworkLocations ( shares ) ; g_mediaManager . GetRemovableDrives ( shares ) ; std :: string strDirectory = m_settings . m_strPath ; if ( ! strDirectory . empty ( ) ) { URIUtils :: AddSlashAt@@ End ( strDirectory ) ; bool bIsSource ; if ( CUtil :: GetMatchingSource ( strDirectory , shares , bIsSource ) < 0 ) { CMediaSource share ; share . strName = g_localizeStrings . Get ( 13278 ) ; share . strPath = strDirectory ; shares . push_back ( share ) ; } } else strDirectory = " default ▁ location " ; if ( CGUIDialogFileBrowser :: ShowAndGetDirectory ( shares , g_localizeStrings . Get ( 661 ) , strDirectory , true ) ) { if ( ! strDirectory . empty ( ) ) { m_destinationChecked = true ; m_settings . m_strPath = strDirectory ; SetLabel2 ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , strDirectory ) ; SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; } } UpdateButtons ( ) ; } }
bool CGUIDialogLibExportSettings :: OnMessage ( CGUIMessage & message ) { switch ( message . GetMessage ( ) ) { case GUI_MSG_CLICKED : { int iControl = message . GetSenderId ( ) ; if ( iControl == CONTROL_SETTINGS_OKAY_BUTTON ) { OnOK ( ) ; return true ; } } break ; } return CGUIDialogSettingsManualBase :: OnMessage ( message ) ; }
void CGUIDialogLibExportSettings :: OnOK ( ) { if ( m_settings . IsToLib@@ Folders ( ) ) { std :: string path = CServiceBroker :: GetSettings ( ) . GetString ( CSettings :: SETTING_MUSICLIBRARY_ARTISTSFOLDER ) ; if ( path . empty ( ) ) { if ( HELPERS :: ShowYes@@ NoDialogText ( 2022@@ 3 , 38317 , 186 , 10004 ) == DialogResponse :: YES ) { m_confirmed = false ; Close ( ) ; CServiceBroker :: GetGUI ( ) -> GetWindowManager ( ) . ActivateWindow ( WINDOW_SETTINGS_MEDIA , CSettings :: SETTING_MUSICLIBRARY_ARTISTSFOLDER ) ; } return ; } } else if ( ! m_destinationChecked ) { if ( ! XFILE :: CDirectory :: Exists ( m_settings . m_strPath ) ) { HELPERS :: ShowOK@@ DialogText ( CVariant { 38300 } , CVariant { 38318 } ) ; return ; } } m_confirmed = true ; Save ( ) ; Close ( ) ; }
void CGUIDialogLibExportSettings :: Save ( ) { CLog :: Log ( LOGINFO , " CGUIDialogMusic@@ ExportSettings : ▁ Save ( ) ▁ called " ) ; CServiceBroker :: GetSettings ( ) . SetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE , m_settings . GetExportType ( ) ) ; CServiceBroker :: GetSettings ( ) . SetString ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , m_settings . m_strPath ) ; CServiceBroker :: GetSettings ( ) . SetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS , m_settings . GetItemsToExport ( ) ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED , m_settings . m_unscraped ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , m_settings . m_overwrite ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , m_settings . m_artwork ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_skipnfo ) ; CServiceBroker :: GetSettings ( ) . Save ( ) ; }
void CGUIDialogLibExportSettings :: SetupView ( ) { CGUIDialogSettingsManualBase :: SetupView ( ) ; SetHeading ( 38300 ) ; SET_CONTROL_HID@@ DEN ( CONTROL_SETTINGS_CUSTO@@ M_BUTTON ) ; SET_CONTROL_LABEL ( CONTROL_SETTINGS_OKAY_BUTTON , 38319 ) ; SET_CONTROL_LABEL ( CONTROL_SETTINGS_CANC@@ EL_BUTTON , 222 ) ; SetLabel2 ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , m_settings . m_strPath ) ; if ( m_settings . IsSingleFile ( ) ) { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , false ) ; } else if ( m_settings . IsSeparateFiles ( ) ) { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } else { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } UpdateButtons ( ) ; }
void CGUIDialogLibExportSettings :: UpdateButtons ( ) { bool enableExport ( true ) ; if ( m_settings . IsSingleFile ( ) || m_settings . IsSeparateFiles ( ) ) enableExport = ! m_settings . m_strPath . empty ( ) ; CONTROL_ENABLE_@@ ON_CONDITION ( CONTROL_SETTINGS_OKAY_BUTTON , enableExport ) ; if ( ! enableExport ) SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; }
void CGUIDialogLibExportSettings :: InitializeSettings ( ) { CGUIDialogSettingsManualBase :: InitializeSettings ( ) ; std :: shared_ptr < CSettingCategory > category = AddCategory ( " exportsettings " , - 1 ) ; if ( ! category ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : ▁ unable ▁ to ▁ setup ▁ settings " ) ; return ; } std :: shared_ptr < CSettingGroup > groupDetails = AddGroup ( category ) ; if ( ! groupDetails ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : ▁ unable ▁ to ▁ setup ▁ settings " ) ; return ; } Translat@@ ableInteger@@ SettingOptions entries ; entries . push_back ( std :: make_pair ( 38301 , ELIBEXPORT_SING@@ LEFILE ) ) ; entries . push_back ( std :: make_pair ( 38302 , ELIBEXPORT_SEPAR@@ ATEFILES ) ) ; entries . push_back ( std :: make_pair ( 38303 , ELIBEXPORT_TOLIBRARYFOLDER ) ) ; AddList ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE , 38304 , SettingLevel :: Basic , m_settings . GetExportType ( ) , entries , 38304 ) ; AddButton ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , 38305 , SettingLevel :: Basic ) ; entries . clear ( ) ; entries . push_back ( std :: make_pair ( 132 , ELIBEXPORT_ALBUMS ) ) ; entries . push_back ( std :: make_pair ( 38043 , ELIBEXPORT_ALBUMARTISTS ) ) ; entries . push_back ( std :: make_pair ( 38312 , ELIBEXPORT_SON@@ GARTISTS ) ) ; entries . push_back ( std :: make_pair ( 38313 , ELIBEXPORT_OTH@@ ERARTISTS ) ) ; AddList ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS , 38306 , SettingLevel :: Basic , m_settings . GetExportItems ( ) , entries , 133 , 1 ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED , 38308 , SettingLevel :: Basic , m_settings . m_unscraped ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , 38307 , SettingLevel :: Basic , m_settings . m_artwork ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , 38309 , SettingLevel :: Basic , m_settings . m_skipnfo ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , 38310 , SettingLevel :: Basic , m_settings . m_overwrite ) ; }
void CGUIDialogLibExportSettings :: SetLabel2 ( const std :: string & settingid , const std :: string & label ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) SET_CONTROL_LABEL2 ( settingControl -> GetID ( ) , label ) ; }
void CGUIDialogLibExportSettings :: ToggleState ( const std :: string & settingid , bool enabled ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) { if ( enabled ) CONTROL_ENABLE ( settingControl -> GetID ( ) ) ; else CONTROL_DISABLE ( settingControl -> GetID ( ) ) ; } }
void CGUIDialogLibExportSettings :: SetFocus ( const std :: string & settingid ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) SET_CONTROL_FOCUS ( settingControl -> GetID ( ) , 0 ) ; }
int CGUIDialogLibExportSettings :: GetExportItemsFromSetting ( SettingConstPtr setting ) { std :: shared_ptr < const CSettingList > settingList = std :: static_pointer_cast < const CSettingList > ( setting ) ; if ( settingList -> GetElementType ( ) != SettingType :: Integer ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : : % s ▁ - ▁ wrong ▁ items ▁ element ▁ type " , __FUNCTION__ ) ; return 0 ; } int exportitems = 0 ; std :: vector < CVariant > list = CSettingUtils :: GetList ( settingList ) ; for ( const auto & value : list ) { if ( ! value . isInteger ( ) ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : : % s ▁ - ▁ wrong ▁ items ▁ value ▁ type " , __FUNCTION__ ) ; return 0 ; } exportitems += value . asInteger ( ) ; } return exportitems ; }
std :: vector < KeyId > FindRoot ( WbConfig config ) { std :: vector < KeyId > rootCamera ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; bool root = true ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camPosId == camera2Id ) { root = false ; break ; } } if ( root && IsBase ( config , camPosId ) ) { rootCamera . push_back ( camPosId ) ; } } return rootCamera ; }
std :: vector < KeyId > FindChain ( WbConfig config , KeyId camId , KeyId rootId , std :: vector < KeyId > mappingChain ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; LOG_INFO ( QObject :: tr ( " Camera1 ▁ id ▁ = ▁ % 1 . " ) . arg ( camera1Id ) ) ; LOG_INFO ( QObject :: tr ( " Camera2 ▁ id ▁ = ▁ % 1 . " ) . arg ( camera2Id ) ) ; if ( camId == camera2Id ) { if ( std :: find ( mappingChain . begin ( ) , mappingChain . end ( ) , camera1Id ) == mappingChain . end ( ) ) { mappingChain . push_back ( camera1Id ) ; if ( camera1Id != rootId ) { LOG_INFO ( QObject :: tr ( " Find ▁ chain ▁ for ▁ % 1 ▁ - ▁ % 2 . " ) . arg ( camera1Id ) . arg ( rootId ) ) ; mappingChain = FindChain ( config , camera1Id , rootId , mappingChain ) ; } if ( mappingChain . back ( ) == rootId ) { LOG_INFO ( " Found . " ) ; break ; } else { mappingChain . pop_back ( ) ; } } } } return mappingChain ; }
CEXIAgp :: CEXIAgp ( int index ) { m_slot = index ; m_rom_size = 0 ; LoadRom ( ) ; m_address = 0 ; }
CEXIAgp :: ~ CEXIAgp ( ) { std :: string path ; std :: string filename ; std :: string ext ; std :: string gbapath ; SplitPath ( m_slot == 0 ? SConfig :: GetInstance ( ) . m_strGbaCartA : SConfig :: GetInstance ( ) . m_strGbaCartB , & path , & filename , & ext ) ; gbapath = path + filename ; SaveFileFromEEPROM ( gbapath + " . sav " ) ; }
void CEXIAgp :: CRC8 ( const u8 * data , u32 size ) { for ( u32 it = 0 ; it < size ; it ++ ) { u8 crc = 0 ; m_hash = m_hash ^ data [ it ] ; if ( m_hash & 1 ) crc ^= 0x5e ; if ( m_hash & 2 ) crc ^= 0xbc ; if ( m_hash & 4 ) crc ^= 0x61 ; if ( m_hash & 8 ) crc ^= 0xc2 ; if ( m_hash & 0x10 ) crc ^= 0x9d ; if ( m_hash & 0x20 ) crc ^= 0x23 ; if ( m_hash & 0x40 ) crc ^= 0x46 ; if ( m_hash & 0x80 ) crc ^= 0x8c ; m_hash = crc ; } }
void CEXIAgp :: LoadRom ( ) { std :: string path ; std :: string filename ; std :: string ext ; std :: string gbapath ; SplitPath ( m_slot == 0 ? SConfig :: GetInstance ( ) . m_strGbaCartA : SConfig :: GetInstance ( ) . m_strGbaCartB , & path , & filename , & ext ) ; gbapath = path + filename ; LoadFileToROM ( gbapath + ext ) ; INFO_LOG ( EXPANSIONINTERFACE , " Loaded ▁ GBA ▁ rom : ▁ % s ▁ card : ▁ % d " , gbapath . c_str ( ) , m_slot ) ; LoadFileToEEPROM ( gbapath + " . sav " ) ; INFO_LOG ( EXPANSIONINTERFACE , " Loaded ▁ GBA ▁ sav : ▁ % s ▁ card : ▁ % d " , gbapath . c_str ( ) , m_slot ) ; }
void CEXIAgp :: LoadFileToROM ( const std :: string & filename ) { File :: IOFile pStream ( filename , " rb " ) ; if ( pStream ) { u64 filesize = pStream . GetSize ( ) ; m_rom_size = filesize & 0xFFFFFFFF ; m_rom_mask = ( m_rom_size - 1 ) ; m_rom . resize ( m_rom_size ) ; pStream . ReadBytes ( m_rom . data ( ) , filesize ) ; } else { m_rom . resize ( 0x2000 ) ; } }
void CEXIAgp :: LoadFileToEEPROM ( const std :: string & filename ) { File :: IOFile pStream ( filename , " rb " ) ; if ( pStream ) { u64 filesize = pStream . GetSize ( ) ; m_eeprom_size = filesize & 0xFFFFFFFF ; m_eeprom_mask = ( m_eeprom_size - 1 ) ; m_eeprom . resize ( m_eeprom_size ) ; pStream . ReadBytes ( m_eeprom . data ( ) , filesize ) ; if ( ( m_eeprom_size == 512 ) || ( m_eeprom_size == 8192 ) ) { for ( u32 index = 0 ; index < ( m_eeprom_size / 8 ) ; index ++ ) { u64 NewVal = 0 ; for ( u32 indexb = 0 ; indexb < 8 ; indexb ++ ) NewVal = ( NewVal << 0x8 ) | m_eeprom [ index * 8 + indexb ] ; ( ( u64 * ) ( m_eeprom . data ( ) ) ) [ index ] = NewVal ; } m_eeprom_add_end = ( m_eeprom_size == 512 ? ( 2 + 6 ) : ( 2 + 14 ) ) ; m_eeprom_add_mask = ( m_eeprom_size == 512 ? 0x3F : 0x3FF ) ; m_eeprom_read_mask = ( m_eeprom_size == 512 ? 0x80 : 0x8000 ) ; m_eeprom_status_mask = ( m_rom_size == 0x2000000 ? 0x1FFFF@@ 00 : 0x1000000 ) ; } else m_eeprom_status_mask = 0 ; } else { m_eeprom_size = 0 ; m_eeprom . clear ( ) ; } }
void CEXIAgp :: SaveFileFromEEPROM ( const std :: string & filename ) { File :: IOFile pStream ( filename , " wb " ) ; if ( pStream ) { if ( ( m_eeprom_size == 512 ) || ( m_eeprom_size == 8192 ) ) { std :: vector < u8 > temp_eeprom ( m_eeprom_size ) ; for ( u32 index = 0 ; index < ( m_eeprom_size / 8 ) ; index ++ ) { u64 NewVal = ( ( u64 * ) ( m_eeprom . data ( ) ) ) [ index ] ; for ( u32 indexb = 0 ; indexb < 8 ; indexb ++ ) temp_eeprom [ index * 8 + ( 7 - indexb ) ] = ( NewVal >> ( indexb * 8 ) ) & 0xFF ; } pStream . WriteBytes ( temp_eeprom . data ( ) , m_eeprom_size ) ; } else { pStream . WriteBytes ( m_eeprom . data ( ) , m_eeprom_size ) ; } } }
u32 CEXIAgp :: ImmRead ( u32 _uSize ) { u32 uData = 0 ; u8 RomVal1 , RomVal2 , RomVal3 , RomVal4 ; switch ( m_current_cmd ) { case 0xAE000000 : uData = 0x5AA@@ A5517 ; m_current_cmd = 0 ; break ; case 0xAE010000 : uData = ( m_return_pos == 0 ) ? 0x01020304 : 0xF0020304 ; if ( m_return_pos == 1 ) m_current_cmd = 0 ; else m_return_pos = 1 ; break ; case 0xAE020000 : if ( m_eeprom_write_status && ( ( m_rw_offset & m_eeprom_status_mask ) == m_eeprom_status_mask ) && ( m_eeprom_status_mask != 0 ) ) { RomVal1 = 0x1 ; RomVal2 = 0x0 ; } else { RomVal1 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal2 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; } CRC8 ( & RomVal2 , 1 ) ; CRC8 ( & RomVal1 , 1 ) ; uData = ( RomVal2 << 24 ) | ( RomVal1 << 16 ) | ( m_hash << 8 ) ; m_current_cmd = 0 ; break ; case 0xAE030000 : if ( _uSize == 1 ) { uData = 0xFF000000 ; m_current_cmd = 0 ; } else { RomVal1 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal2 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal3 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal4 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; CRC8 ( & RomVal2 , 1 ) ; CRC8 ( & RomVal1 , 1 ) ; CRC8 ( & RomVal4 , 1 ) ; CRC8 ( & RomVal3 , 1 ) ; uData = ( RomVal2 << 24 ) | ( RomVal1 << 16 ) | ( RomVal4 << 8 ) | ( RomVal3 ) ; } break ; case 0xAE040000 : if ( m_eeprom_size == 0 ) RomVal1 = 0xFF ; else RomVal1 = ( m_eeprom . data ( ) ) [ m_eeprom_pos ] ; CRC8 ( & RomVal1 , 1 ) ; uData = ( RomVal1 << 24 ) | ( m_hash << 16 ) ; m_current_cmd = 0 ; break ; case 0xAE0B0000 : RomVal1 = EE_READ_FALSE ; if ( ( m_eeprom_size != 0 ) && ( m_eeprom_pos >= EE_IGNORE_BITS ) && ( ( ( ( u64 * ) m_eeprom . data ( ) ) [ ( m_eeprom_cmd >> 1 ) & m_eeprom_add_mask ] ) >> ( ( EE_DATA_BITS - 1 ) - ( m_eeprom_pos - EE_IGNORE_BITS ) ) ) & 0x1 ) { RomVal1 = EE_READ_TRUE ; } RomVal2 = 0 ; CRC8 ( & RomVal2 , 1 ) ; CRC8 ( & RomVal1 , 1 ) ; uData = ( RomVal2 << 24 ) | ( RomVal1 << 16 ) | ( m_hash << 8 ) ; m_eeprom_pos ++ ; m_current_cmd = 0 ; break ; case 0xAE070000 : case 0xAE0C0000 : uData = m_hash << 24 ; m_current_cmd = 0 ; break ; default : uData = 0x0 ; m_current_cmd = 0 ; break ; } DEBUG_LOG ( EXPANSIONINTERFACE , " AGP ▁ read ▁ % x " , uData ) ; return uData ; }
void CEXIAgp :: ImmWrite ( u32 _uData , u32 _uSize ) { if ( ( _uSize == 1 ) && ( ( _uData & 0xFF000000 ) == 0 ) ) return ; u8 HashCmd ; u64 Mask ; DEBUG_LOG ( EXPANSIONINTERFACE , " AGP ▁ command ▁ % x " , _uData ) ; switch ( m_current_cmd ) { case 0xAE020000 : case 0xAE030000 : m_rw_offset = ( ( _uData & 0xFFFFFF00 ) >> ( 8 - 1 ) ) ; m_return_pos = 0 ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x0000FF00 ) >> 8 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE040000 : m_eeprom_pos = ( ( _uData & 0xFFFF0000 ) >> 0x10 ) & m_eeprom_mask ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE070000 : m_eeprom_pos = ( ( _uData & 0xFFFF0000 ) >> 0x10 ) & m_eeprom_mask ; if ( m_eeprom_size != 0 ) ( ( m_eeprom . data ( ) ) ) [ ( m_eeprom_pos ) ] = ( _uData & 0x0000FF00 ) >> 0x8 ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x0000FF00 ) >> 8 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE0C0000 : if ( ( m_eeprom_pos < m_eeprom_add_end ) || ( m_eeprom_pos == ( ( m_eeprom_cmd & m_eeprom_read_mask ) ? m_eeprom_add_end : m_eeprom_add_end + EE_DATA_BITS ) ) ) { Mask = ( 1ULL << ( m_eeprom_add_end - std :: min ( m_eeprom_pos , m_eeprom_add_end ) ) ) ; if ( ( _uData >> 16 ) & 0x1 ) m_eeprom_cmd |= Mask ; else m_eeprom_cmd &= ~ Mask ; if ( m_eeprom_pos == m_eeprom_add_end + EE_DATA_BITS ) { if ( m_eeprom_size != 0 ) ( ( u64 * ) ( m_eeprom . data ( ) ) ) [ ( m_eeprom_cmd >> 1 ) & m_eeprom_add_mask ] = m_eeprom_data ; m_eeprom_write_status = true ; } } else { Mask = ( 1ULL << ( m_eeprom_add_end + EE_DATA_BITS - 1 - m_eeprom_pos ) ) ; if ( ( _uData >> 16 ) & 0x1 ) m_eeprom_data |= Mask ; else m_eeprom_data &= ~ Mask ; } m_eeprom_pos ++ ; m_return_pos = 0 ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE0B0000 : m_eeprom_write_status = false ; break ; case 0xAE000000 : case 0xAE010000 : case 0xAE090000 : m_eeprom_write_status = false ; case 0xAE0A0000 : m_eeprom_pos = 0 ; default : m_current_cmd = _uData ; m_return_pos = 0 ; m_hash = 0xFF ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; break ; } }
void CEXIAgp :: DoState ( PointerWrap & p ) { p . Do ( m_slot ) ; p . Do ( m_address ) ; p . Do ( m_current_cmd ) ; p . Do ( m_eeprom ) ; p . Do ( m_eeprom_cmd ) ; p . Do ( m_eeprom_data ) ; p . Do ( m_eeprom_mask ) ; p . Do ( m_eeprom_pos ) ; p . Do ( m_eeprom_size ) ; p . Do ( m_eeprom_add_end ) ; p . Do ( m_eeprom_add_mask ) ; p . Do ( m_eeprom_read_mask ) ; p . Do ( m_eeprom_status_mask ) ; p . Do ( m_eeprom_write_status ) ; p . Do ( m_hash ) ; p . Do ( m_position ) ; p . Do ( m_return_pos ) ; p . Do ( m_rom ) ; p . Do ( m_rom_mask ) ; p . Do ( m_rom_size ) ; p . Do ( m_rw_offset ) ; }
bool LWEProtocolWebSocketSecure :: ProcessRead ( LWSocket & Socket , const char * Buffer , uint32_t BufferLen ) { char Buf [ 256 ] ; char BufB [ 256 ] ; LWEWebSocket * WebSocket = ( LWEWebSocket * ) Socket . GetProtocolData ( m_wProtocolID ) ; if ( ! WebSocket ) { LWEHttpRequest Request ; uint32_t Error = 0 ; Error = Request . Deserialize ( Buffer , BufferLen ) ? 0 : 1 ; Error = Error ? Error : ( * Request . m_SecWebSockKey && Request . m_WebSockVersion == LWEWEBSOCKET_SUPPVER && Request . UpgradeConnection ( ) ) ? 0 : 2 ; if ( ! Error && * Request . m_SecWebSockProto ) { bool ValidProtocol = false ; if ( * m_SubProtocol ) { uint32_t ProtocolLen = ( uint32_t ) strlen ( m_SubProtocol ) ; for ( const char * C = Request . m_SecWebSockProto ; C && ! ValidProtocol ; C = LWText :: FirstToken ( C , ' , ' ) ) { C = LWText :: NextWord ( * C == ' , ' ? C + 1 : C , true ) ; ValidProtocol = LWText :: Compare ( C , m_SubProtocol , ProtocolLen ) ; } } if ( ! ValidProtocol ) Error = 3 ; } if ( Error ) { std :: cout << " Buffer : " << std :: endl << Buffer << std :: endl ; if ( Error == 1 ) std :: cout << " Error ▁ deserializing ▁ websocket ▁ request . " << std :: endl ; else if ( Error == 2 ) std :: cout << " Error ▁ Headers ▁ did ▁ not ▁ include ▁ correct ▁ websocket ▁ data . " << std :: endl ; else if ( Error == 3 ) std :: cout << " Error ▁ protocol ▁ asked ▁ for ▁ is ▁ not ▁ supported . " << std :: endl ; Socket . MarkClosable ( ) ; return false ; } WebSocket = m_Allocator . Allocate < LWEWebSocket > ( nullptr , nullptr ) ; WebSocket -> m_Socket = & Socket ; * Buf = ' \0' ; strncat ( Buf , Request . m_SecWebSockKey , sizeof ( Buf ) ) ; strncat ( Buf , LWEWEBSOCKET_GUID , sizeof ( Buf ) ) ; LWCrypto :: HashSHA1 ( Buf , ( uint32_t ) strlen ( Buf ) , BufB ) ; uint32_t * uBuf = ( uint32_t * ) BufB ; for ( uint32_t i = 0 ; i < 5 ; i ++ ) uBuf [ i ] = ( uBuf [ i ] & 0xFF ) << 24 | ( uBuf [ i ] & 0xFF00 ) << 8 | ( uBuf [ i ] & 0xFF0000 ) >> 8 | ( uBuf [ i ] & 0xFF000000 ) >> 24 ; uint32_t Len = LWCrypto :: Base64Encode ( BufB , 20 , WebSocket -> m_SecKey , sizeof ( WebSocket -> m_SecKey ) ) ; WebSocket -> m_SecKey [ Len ] = ' \0' ; WebSocket -> SetSecProtocols ( m_SubProtocol ) ; WebSocket -> SetHost ( Request . m_Host ) ; WebSocket -> SetPath ( Request . m_Path ) ; WebSocket -> SetOrigin ( Request . m_Origin ) ; WebSocket -> m_Flag |= LWEWebSocket :: CONNECTING_SERVER ; Socket . SetProtocolData ( m_wProtocolID , WebSocket ) ; PushOutPacket ( nullptr , 0 , WebSocket , LWEWebPacket :: CONTROL_CONNECT ) ; return true ; } if ( ! WebSocket -> IsConnected ( ) ) { if ( WebSocket -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_CLIENT ) { LWEHttpRequest Request ; uint32_t Error = 0 ; Error = Request . Deserialize ( Buffer , BufferLen ) ? 0 : 1 ; Error = Error ? Error : ( ( * Request . m_SecWebSockKey && Request . m_Status == LWEHttpRequest :: SwitchingProtocols ) ? 0 : 2 ) ; if ( Error ) { std :: cout << " Buffer : " << std :: endl << Buffer << std :: endl ; if ( Error == 1 ) std :: cout << " Error ▁ deserializing ▁ websocket ▁ request . " << std :: endl ; else if ( Error == 2 ) std :: cout << " Error ▁ headers ▁ did ▁ not ▁ include ▁ correct ▁ websocket ▁ data . " << std :: endl ; Socket . MarkClosable ( ) ; return false ; } WebSocket -> m_Flag = ( WebSocket -> m_Flag & ~ LWEWebSocket :: CONNECTING_CLIENT ) | LWEWebSocket :: CONNECTED_CLIENT ; } return true ; } char IPBuf [ 32 ] ; LWSocket :: MakeAddress ( Socket . GetRemoteIP ( ) , IPBuf , sizeof ( IPBuf ) ) ; if ( BufferLen > 100 ) { } LWEWebPacket * OPack ; uint32_t Target ; uint32_t ReservePos ; uint32_t o = 0 ; while ( o != BufferLen ) { uint32_t Res = WebSocket -> m_ActivePacket . Deserialize ( Buffer + o , BufferLen - o , m_Allocator ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ deserializing ▁ data . " << std :: endl ; return false ; } o += Res ; if ( ! WebSocket -> m_ActivePacket . Finished ( ) ) continue ; if ( WebSocket -> m_ActivePacket . m_DataLen != WebSocket -> m_ActivePacket . m_DataPos ) continue ; if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_CLO@@ SED ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; Socket . MarkClosable ( ) ; return true ; } else if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_PING ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; PushOutPacket ( nullptr , 0 , WebSocket , LWEWebPacket :: CONTROL_PONG ) ; continue ; } else if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_PONG ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; continue ; } WebSocket -> m_ActivePacket . m_WebSocket = WebSocket ; if ( ! m_InPackets . PushStart ( & OPack , Target , ReservePos ) ) return false ; * OPack = std :: move ( WebSocket -> m_ActivePacket ) ; m_InPackets . PushFinished ( Target , ReservePos ) ; } return true ; }
LWProtocol & LWEProtocolWebSocketSecure :: SocketClosed ( LWSocket & Socket , LWProtocolManager * Manager ) { LWEProtocolTLS :: SocketClosed ( Socket , Manager ) ; LWEWebSocket * WebSock = ( LWEWebSocket * ) Socket . GetProtocolData ( m_wProtocolID ) ; bool Del = true ; if ( m_WebSocketClosedCallback ) Del = m_WebSocketClosedCallback ( Socket , WebSock , Manager ) ; if ( WebSock ) WebSock -> m_Socket = nullptr ; if ( Del ) LWAllocator :: Destroy ( WebSock ) ; return * this ; }
LWProtocol & LWEProtocolWebSocketSecure :: SocketChanged ( LWSocket & Prev , LWSocket & New , LWProtocolManager * Manager ) { LWEProtocolTLS :: SocketChanged ( Prev , New , Manager ) ; LWEWebSocket * WebSocket = ( LWEWebSocket * ) Prev . GetProtocolData ( m_wProtocolID ) ; New . SetProtocolData ( m_wProtocolID , Prev . GetProtocolData ( m_wProtocolID ) ) ; if ( WebSocket ) WebSocket -> m_Socket = & New ; if ( m_WebSocketChangedCallback ) m_WebSocketChangedCallback ( Prev , New , WebSocket , Manager ) ; return * this ; }
LWProtocol & LWEProtocolWebSocketSecure :: ProcessTLS@@ Data ( LWSocket & Socket , const char * Data , uint32_t DataLen ) { ProcessRead ( Socket , Data , DataLen ) ; return * this ; }
LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: ProcessOutPackets ( void ) { char Buffer [ 1024 * 64 ] ; LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; while ( m_OutPackets . PopStart ( & Pack , Target , ReservePos ) ) { LWEWebPacket RPack = std :: move ( * Pack ) ; m_OutPackets . PopFinshed ( Target , ReservePos ) ; LWEWebSocket * Sock = RPack . m_WebSocket ; if ( ! Sock -> IsConnected ( ) && ( RPack . m_ControlFlag & LWEWebPacket :: CONTROL_CONNECT ) ) { if ( ! Sock -> m_Socket ) return * this ; LWEHttpRequest Request ; Request . SetWebSockKey ( Sock -> m_SecKey ) ; Request . SetWebSockProto ( m_SubProtocol ) ; Request . m_Flag |= LWEHttpRequest :: ConnectionUpgrade | LWEHttpRequest :: UpgradeWebSock ; Request . m_Status = Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_SERVER ? LWEHttpRequest :: SwitchingProtocols : 0 ; if ( Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_CLIENT ) { Request . SetHost ( Sock -> m_Host ) . SetPath ( Sock -> m_Path ) . SetOrigin ( Sock -> m_Origin ) ; Request . m_WebSockVersion = LWEWEBSOCKET_SUPPVER ; } else Sock -> m_Flag = ( Sock -> m_Flag & ~ LWEWebSocket :: CONNECTING_SERVER ) | LWEWebSocket :: CONNECTED_SERVER ; uint32_t Len = Request . Serialize ( Buffer , sizeof ( Buffer ) , Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_CLIENT ? m_UserAgent : m_Server ) ; std :: cout << " Sending ▁ headers ! " << std :: endl ; uint32_t Res = Send ( * Sock -> m_Socket , Buffer , Len ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ sending ▁ data . " << std :: endl ; return * this ; } if ( ! Res ) { if ( Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_SERVER ) Sock -> m_Flag = ( Sock -> m_Flag & ~ LWEWebSocket :: CONNECTING_SERVER ) | LWEWebSocket :: CONNECTING_SERVER ; PushOutPacket ( nullptr , 0 , Sock , LWEWebPacket :: CONTROL_CONNECT ) ; return * this ; } } if ( RPack . m_ControlFlag & LWEWebPacket :: CONTROL_CONNECT ) continue ; if ( ! Sock -> IsConnected ( ) ) { if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) { std :: cout << " Error ▁ re - inserting ▁ packet . " << std :: endl ; return * this ; } * Pack = std :: move ( RPack ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; return * this ; } std :: cout << " Sending ▁ data : ▁ " << RPack . GetOp ( ) << " ▁ Len : ▁ " << RPack . m_DataLen << " ▁ Fin : ▁ " << RPack . m_ControlFlag << std :: endl ; LWSocket * rSock = RPack . m_WebSocket -> m_Socket ; if ( ! rSock ) continue ; uint32_t Len = RPack . Serialize ( Buffer , sizeof ( Buffer ) , Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_CLIENT ) ; std :: cout << " Serialized : ▁ " << Len << std :: endl ; uint32_t Res = Send ( * rSock , Buffer , Len ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ sending ▁ data . " << std :: endl ; return * this ; } if ( ! Res ) { if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) { std :: cout << " Error ▁ re - inserting ▁ packet . " << std :: endl ; return * this ; } * Pack = std :: move ( RPack ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; } } return * this ; }
LWEWebSocket * LWEProtocolWebSocketSecure :: OpenSocket ( const char * URI , uint32_t ProtocolID , const char * Origin ) { char Host [ 256 ] ; char Path [ 256 ] ; char Protocol [ 256 ] ; uint16_t Port = LWEHttpRequest :: ParseURI ( URI , Host , sizeof ( Host ) , nullptr , Path , sizeof ( Path ) , nullptr , Protocol , sizeof ( Protocol ) , nullptr ) ; LWSocket Sock ; uint32_t Err = LWSocket :: CreateSocket ( Sock , Host , Port , LWSocket :: Tcp , ProtocolID ) ; if ( Err ) { std :: cout << " Error ▁ creating ▁ socket : ▁ " << Err << std :: endl ; return nullptr ; } LWSocket * S = m_Manager -> PushSocket ( Sock ) ; LWEWebSocket * WebSock = m_Allocator . Allocate < LWEWebSocket > ( URI , Origin ) ; WebSock -> m_Flag |= LWEWebSocket :: CONNECTING_CLIENT ; WebSock -> GenerateKey ( m_KeySeed ++ ) ; S -> SetProtocolData ( m_wProtocolID , WebSock ) ; WebSock -> m_Socket = S ; PushOutPacket ( nullptr , 0 , WebSock , LWEWebPacket :: CONTROL_CONNECT ) ; return WebSock ; }
bool LWEProtocolWebSocketSecure :: PushOutPacket ( const char * Buffer , uint32_t BufferLen , LWEWebSocket * Socket , uint32_t ControlFlag ) { LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) return false ; * Pack = LWEWebPacket ( Buffer , BufferLen , m_Allocator , ControlFlag | LWEWebPacket :: CONTROL_FIN@@ ISHED , Socket ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; return true ; }
bool LWEProtocolWebSocketSecure :: GetNextPacket ( LWEWebPacket & Packet ) { LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; if ( ! m_InPackets . PopStart ( & Pack , Target , ReservePos ) ) return false ; Packet = std :: move ( * Pack ) ; m_InPackets . PopFinshed ( Target , ReservePos ) ; return true ; }
LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetServer ( const char * Server ) { * m_Server = ' \0' ; strncat ( m_Server , Server , sizeof ( m_Server ) ) ; return * this ; }
LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetUserAgent ( const char * Agent ) { * m_UserAgent = ' \0' ; strncat ( m_UserAgent , Agent , sizeof ( m_UserAgent ) ) ; return * this ; }
LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetSubProtocol ( const char * SubProtocol ) { * m_SubProtocol = ' \0' ; strncat ( m_SubProtocol , SubProtocol , sizeof ( m_SubProtocol ) ) ; return * this ; }
LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetWebSocketClosedCallback ( std :: function < bool ( LWSocket & , LWEWebSocket * , LWProtocolManager * ) > WebSocketClosedCallback ) { m_WebSocketClosedCallback = WebSocketClosedCallback ; return * this ; }
LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetWebSocketChangedCallback ( std :: function < void ( LWSocket & , LWSocket & , LWEWebSocket * , LWProtocolManager * ) > WebSocketChangedCallback ) { m_WebSocketChangedCallback = WebSocketChangedCallback ; return * this ; }
LWEProtocolWebSocketSecure :: LWEProtocolWebSocketSecure ( uint32_t ProtocolID , uint32_t TLSProtocolID , LWAllocator & Allocator , LWProtocolManager * Manager , const char * CertFile , const char * KeyFile ) : LWEProtocolTLS ( TLSProtocolID , Allocator , CertFile , KeyFile ) , m_wProtocolID ( ProtocolID ) , m_Allocator ( Allocator ) , m_Manager ( Manager ) , m_KeySeed ( 0 ) { * m_Server = * m_UserAgent = * m_SubProtocol = ' \0' ; m_WebSocketClosedCallback = nullptr ; m_WebSocketChangedCallback = nullptr ; }
>= 0x040400 QT_BEGIN_NAMESPACE QtCursorDatabase :: QtCursorDatabase ( ) { appendCursor ( Qt :: ArrowCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Arrow " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - arrow . png " ) ) ) ; appendCursor ( Qt :: UpArrowCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Up ▁ Arrow " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - uparrow . png " ) ) ) ; appendCursor ( Qt :: CrossCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Cross " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - cross . png " ) ) ) ; appendCursor ( Qt :: WaitCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Wait " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - wait . png " ) ) ) ; appendCursor ( Qt :: IBeamCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " IBeam " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - ibeam . png " ) ) ) ; appendCursor ( Qt :: SizeVerCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Vertical " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizev . png " ) ) ) ; appendCursor ( Qt :: SizeHorCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Horizontal " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeh . png " ) ) ) ; appendCursor ( Qt :: SizeFDiagCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Backslash " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizef . png " ) ) ) ; appendCursor ( Qt :: SizeBDiagCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Slash " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeb . png " ) ) ) ; appendCursor ( Qt :: SizeAllCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ All " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeall . png " ) ) ) ; appendCursor ( Qt :: BlankCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Blank " ) , QIcon ( ) ) ; appendCursor ( Qt :: SplitVCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Split ▁ Vertical " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - vsplit . png " ) ) ) ; appendCursor ( Qt :: SplitHCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Split ▁ Horizontal " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - hsplit . png " ) ) ) ; appendCursor ( Qt :: PointingHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Pointing ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - hand . png " ) ) ) ; appendCursor ( Qt :: ForbiddenCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Forbidden " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - forbidden . png " ) ) ) ; appendCursor ( Qt :: OpenHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Open ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - openhand . png " ) ) ) ; appendCursor ( Qt :: ClosedHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Closed ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - closedhand . png " ) ) ) ; appendCursor ( Qt :: WhatsThis@@ Cursor , QCoreApplication :: translate ( " QtCursorDatabase " , " What ' s ▁ This " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - whatsth@@ is . png " ) ) ) ; appendCursor ( Qt :: BusyCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Busy " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - busy . png " ) ) ) ; }
void QtCursorDatabase :: clear ( ) { m_cursorNames . clear ( ) ; m_cursorIcons . clear ( ) ; m_valueToCursorShape . clear ( ) ; m_cursorShapeToValue . clear ( ) ; }
void QtCursorDatabase :: appendCursor ( Qt :: CursorShape shape , const QString & name , const QIcon & icon ) { if ( m_cursorShapeToValue . contains ( shape ) ) return ; const int value = m_cursorNames . count ( ) ; m_cursorNames . append ( name ) ; m_cursorIcons . insert ( value , icon ) ; m_valueToCursorShape . insert ( value , shape ) ; m_cursorShapeToValue . insert ( shape , value ) ; }
QPixmap QtPropertyBrowserUtils :: brushValuePixmap ( const QBrush & b ) { QImage img ( 16 , 16 , QImage :: Format_ARGB32_Premultiplied ) ; img . fill ( 0 ) ; QPainter painter ( & img ) ; painter . setCompositionMode ( QPainter :: CompositionMode@@ _Source ) ; painter . fillRect ( 0 , 0 , img . width ( ) , img . height ( ) , b ) ; QColor color = b . color ( ) ; if ( color . alpha ( ) != 255 ) { QBrush opaqueBrush = b ; color . setAlpha ( 255 ) ; opaqueBrush . setColor ( color ) ; painter . fillRect ( img . width ( ) / 4 , img . height ( ) / 4 , img . width ( ) / 2 , img . height ( ) / 2 , opaqueBrush ) ; } painter . end ( ) ; return QPixmap :: fromImage ( img ) ; }
QIcon QtPropertyBrowserUtils :: brushValueIcon ( const QBrush & b ) { return QIcon ( brushValuePixmap ( b ) ) ; }
QString QtPropertyBrowserUtils :: colorValueText ( const QColor & c ) { return QCoreApplication :: translate ( " QtPropertyBrowserUtils " , " [ %1 , ▁ % 2 , ▁ % 3 ] ▁ ( %4 ) " ) . arg ( c . red ( ) ) . arg ( c . green ( ) ) . arg ( c . blue ( ) ) . arg ( c . alpha ( ) ) ; }
QPixmap QtPropertyBrowserUtils :: fontValuePixmap ( const QFont & font ) { QFont f = font ; QImage img ( 16 , 16 , QImage :: Format_ARGB32_Premultiplied ) ; img . fill ( 0 ) ; QPainter p ( & img ) ; p . setRenderHint ( QPainter :: TextAntialiasing , true ) ; p . setRenderHint ( QPainter :: Antialiasing , true ) ; f . setPointSize ( 13 ) ; p . setFont ( f ) ; QTextOption t ; t . setAlignment ( Qt :: AlignCenter ) ; p . drawText ( QRect ( 0 , 0 , 16 , 16 ) , QString ( QLatin1Char ( ' A ' ) ) , t ) ; return QPixmap :: fromImage ( img ) ; }
QIcon QtPropertyBrowserUtils :: fontValueIcon ( const QFont & f ) { return QIcon ( fontValuePixmap ( f ) ) ; }
QString QtPropertyBrowserUtils :: fontValueText ( const QFont & f ) { return QCoreApplication :: translate ( " QtPropertyBrowserUtils " , " [ %1 , ▁ % 2 ] " ) . arg ( f . family ( ) ) . arg ( f . pointSize ( ) ) ; }
QtBoolEdit :: QtBoolEdit ( QWidget * parent ) : QWidget ( parent ) , m_checkBox ( new QCheckBox ( this ) ) , m_textVisible ( true ) { QHBoxLayout * lt = new QHBoxLayout ; if ( QApplication :: layoutDirection ( ) == Qt :: LeftToRight ) lt -> setContentsMargins ( 4 , 0 , 0 , 0 ) ; else lt -> setContentsMargins ( 0 , 0 , 4 , 0 ) ; lt -> addWidget ( m_checkBox ) ; setLayout ( lt ) ; connect ( m_checkBox , SIGNAL ( toggled ( bool ) ) , this , SIGNAL ( toggled ( bool ) ) ) ; setFocusProxy ( m_checkBox ) ; m_checkBox -> setText ( tr ( " True " ) ) ; }
void QtBoolEdit :: setTextVisible ( bool textVisible ) { if ( m_textVisible == textVisible ) return ; m_textVisible = textVisible ; if ( m_textVisible ) m_checkBox -> setText ( isChecked ( ) ? tr ( " True " ) : tr ( " False " ) ) ; else m_checkBox -> setText ( QString ( ) ) ; }
void QtBoolEdit :: setCheckState ( Qt :: CheckState state ) { m_checkBox -> setCheckState ( state ) ; }
void QtBoolEdit :: setChecked ( bool c ) { m_checkBox -> setChecked ( c ) ; if ( ! m_textVisible ) return ; m_checkBox -> setText ( isChecked ( ) ? tr ( " True " ) : tr ( " False " ) ) ; }
bool QtBoolEdit :: blockCheckBox@@ Signals ( bool block ) { return m_checkBox -> blockSignals ( block ) ; }
void QtBoolEdit :: mousePressEvent ( QMouseEvent * event ) { if ( event -> buttons ( ) == Qt :: LeftButton ) { m_checkBox -> click ( ) ; event -> accept ( ) ; } else { QWidget :: mousePressEvent ( event ) ; } }
void QtBoolEdit :: paintEvent ( QPaintEvent * ) { QStyleOption opt ; opt . init ( this ) ; QPainter p ( this ) ; style ( ) -> drawPrimitive ( QStyle :: PE_Widget , & opt , & p , this ) ; }
QtKeySequenceEdit :: QtKeySequenceEdit ( QWidget * parent ) : QWidget ( parent ) , m_num ( 0 ) , m_lineEdit ( new QLineEdit ( this ) ) { QHBoxLayout * layout = new QHBoxLayout ( this ) ; layout -> addWidget ( m_lineEdit ) ; layout -> setMargin ( 0 ) ; m_lineEdit -> installEventFilter ( this ) ; m_lineEdit -> setReadOnly ( true ) ; m_lineEdit -> setFocusProxy ( this ) ; setFocusPolicy ( m_lineEdit -> focusPolicy ( ) ) ; setAttribute ( Qt :: WA_InputMethod@@ Enabled ) ; }
bool QtKeySequenceEdit :: eventFilter ( QObject * o , QEvent * e ) { if ( o == m_lineEdit && e -> type ( ) == QEvent :: ContextMenu ) { QContextMenuEvent * c = static_cast < QContextMenuEvent * > ( e ) ; QMenu * menu = m_lineEdit -> createStandard@@ ContextMenu ( ) ; const QList < QAction * > actions = menu -> actions ( ) ; QListIterator < QAction * > itAction ( actions ) ; while ( itAction . hasNext ( ) ) { QAction * action = itAction . next ( ) ; action -> setShortcut ( QKeySequence ( ) ) ; QString actionString = action -> text ( ) ; const int pos = actionString . lastIndexOf ( QLatin1Char ( ' \t ' ) ) ; if ( pos > 0 ) actionString . remove ( pos , actionString . length ( ) - pos ) ; action -> setText ( actionString ) ; } QAction * actionBefore = 0 ; if ( actions . count ( ) > 0 ) actionBefore = actions [ 0 ] ; QAction * clearAction = new QAction ( tr ( " Clear ▁ Shortcut " ) , menu ) ; menu -> insertAction ( actionBefore , clearAction ) ; menu -> insertSeparator ( actionBefore ) ; clearAction -> setEnabled ( ! m_keySequence . isEmpty ( ) ) ; connect ( clearAction , SIGNAL ( triggered ( ) ) , this , SLOT ( slotClearShortcut ( ) ) ) ; menu -> exec ( c -> globalPos ( ) ) ; delete menu ; e -> accept ( ) ; return true ; } return QWidget :: eventFilter ( o , e ) ; }
void QtKeySequenceEdit :: slotClearShortcut ( ) { if ( m_keySequence . isEmpty ( ) ) return ; setKeySequence ( QKeySequence ( ) ) ; emit keySequenceChanged ( m_keySequence ) ; }
void QtKeySequenceEdit :: handleKeyEvent ( QKeyEvent * e ) { int nextKey = e -> key ( ) ; if ( nextKey == Qt :: Key_Control || nextKey == Qt :: Key_Shift || nextKey == Qt :: Key_Meta || nextKey == Qt :: Key_Alt || nextKey == Qt :: Key_Super_@@ L || nextKey == Qt :: Key_AltGr ) return ; nextKey |= translateModifiers ( e -> modifiers ( ) , e -> text ( ) ) ; int k0 = m_keySequence [ 0 ] ; int k1 = m_keySequence [ 1 ] ; int k2 = m_keySequence [ 2 ] ; int k3 = m_keySequence [ 3 ] ; switch ( m_num ) { case 0 : k0 = nextKey ; k1 = 0 ; k2 = 0 ; k3 = 0 ; break ; case 1 : k1 = nextKey ; k2 = 0 ; k3 = 0 ; break ; case 2 : k2 = nextKey ; k3 = 0 ; break ; case 3 : k3 = nextKey ; break ; default : break ; } ++ m_num ; if ( m_num > 3 ) m_num = 0 ; m_keySequence = QKeySequence ( k0 , k1 , k2 , k3 ) ; m_lineEdit -> setText ( m_keySequence . toString ( QKeySequence :: NativeText ) ) ; e -> accept ( ) ; emit keySequenceChanged ( m_keySequence ) ; }
void QtKeySequenceEdit :: setKeySequence ( const QKeySequence & sequence ) { if ( sequence == m_keySequence ) return ; m_num = 0 ; m_keySequence = sequence ; m_lineEdit -> setText ( m_keySequence . toString ( QKeySequence :: NativeText ) ) ; }
void QtKeySequenceEdit :: focusInEvent ( QFocusEvent * e ) { m_lineEdit -> event ( e ) ; m_lineEdit -> selectAll ( ) ; QWidget :: focusInEvent ( e ) ; }
void QtKeySequenceEdit :: focusOutEvent ( QFocusEvent * e ) { m_num = 0 ; m_lineEdit -> event ( e ) ; QWidget :: focusOutEvent ( e ) ; }
void QtKeySequenceEdit :: keyPressEvent ( QKeyEvent * e ) { handleKeyEvent ( e ) ; e -> accept ( ) ; }
void QtKeySequenceEdit :: keyRelease@@ Event ( QKeyEvent * e ) { m_lineEdit -> event ( e ) ; }
void QtKeySequenceEdit :: paintEvent ( QPaintEvent * ) { QStyleOption opt ; opt . init ( this ) ; QPainter p ( this ) ; style ( ) -> drawPrimitive ( QStyle :: PE_Widget , & opt , & p , this ) ; }
bool QtKeySequenceEdit :: event ( QEvent * e ) { if ( e -> type ( ) == QEvent :: Shortcut || e -> type ( ) == QEvent :: Shortcut@@ Override || e -> type ( ) == QEvent :: KeyRelease ) { e -> accept ( ) ; return true ; } return QWidget :: event ( e ) ; }
bool ExpandPseudo :: expand ( ) { bool Expanded = false ; for ( MachineFunction :: iterator BB = MF . begin ( ) , BBEnd = MF . end ( ) ; BB != BBEnd ; ++ BB ) for ( Iter I = BB -> begin ( ) , End = BB -> end ( ) ; I != End ; ) Expanded |= expandInstr ( * BB , I ++ ) ; return Expanded ; }
bool ExpandPseudo :: expandInstr ( MachineBasicBlock & MBB , Iter I ) { switch ( I -> getOpcode ( ) ) { case Mips :: LOAD_CCOND_DSP : expandLoadCCond ( MBB , I ) ; break ; case Mips :: STORE_CCOND_DSP : expandStoreCCond ( MBB , I ) ; break ; case Mips :: LOAD_ACC64 : case Mips :: LOAD_ACC64DSP : expandLoadACC ( MBB , I , 4 ) ; break ; case Mips :: LOAD_ACC128 : expandLoadACC ( MBB , I , 8 ) ; break ; case Mips :: STORE_ACC64 : expandStoreACC ( MBB , I , Mips :: PseudoMFHI , Mips :: PseudoMFLO , 4 ) ; break ; case Mips :: STORE_ACC64DSP : expandStoreACC ( MBB , I , Mips :: MFHI_DSP , Mips :: MFLO_DSP , 4 ) ; break ; case Mips :: STORE_ACC128 : expandStoreACC ( MBB , I , Mips :: PseudoMFHI64 , Mips :: PseudoMFLO64 , 8 ) ; break ; case Mips :: BuildPairF64 : if ( expandBuildPairF64 ( MBB , I , false ) ) MBB . erase ( I ) ; return false ; case Mips :: BuildPairF64_64 : if ( expandBuildPairF64 ( MBB , I , true ) ) MBB . erase ( I ) ; return false ; case Mips :: ExtractElementF64 : if ( expandExtractElementF64 ( MBB , I , false ) ) MBB . erase ( I ) ; return false ; case Mips :: ExtractElementF64_64 : if ( expandExtractElementF64 ( MBB , I , true ) ) MBB . erase ( I ) ; return false ; case TargetOpcode :: COPY : if ( ! expandCopy ( MBB , I ) ) return false ; break ; default : return false ; } MBB . erase ( I ) ; return true ; }
void ExpandPseudo :: expandLoadCCond ( MachineBasicBlock & MBB , Iter I ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( 4 ) ; unsigned VR = MRI . createVirtualRegister ( RC ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; TII . loadRegFromStack ( MBB , I , VR , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , I -> getDebugLoc ( ) , TII . get ( TargetOpcode :: COPY ) , Dst ) . addReg ( VR , RegState :: Kill ) ; }
void ExpandPseudo :: expandStoreCCond ( MachineBasicBlock & MBB , Iter I ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( 4 ) ; unsigned VR = MRI . createVirtualRegister ( RC ) ; unsigned Src = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; BuildMI ( MBB , I , I -> getDebugLoc ( ) , TII . get ( TargetOpcode :: COPY ) , VR ) . addReg ( Src , getKillRegState ( I -> getOperand ( 0 ) . isKill ( ) ) ) ; TII . storeRegToStack ( MBB , I , VR , true , FI , RC , & RegInfo , 0 ) ; }
void ExpandPseudo :: expandLoadACC ( MachineBasicBlock & MBB , Iter I , unsigned RegSize ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( RegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; unsigned Lo = RegInfo . getSubReg ( Dst , Mips :: sub_lo ) ; unsigned Hi = RegInfo . getSubReg ( Dst , Mips :: sub_hi ) ; DebugLoc DL = I -> getDebugLoc ( ) ; const MCInstrDesc & Desc = TII . get ( TargetOpcode :: COPY ) ; TII . loadRegFromStack ( MBB , I , VR0 , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , DL , Desc , Lo ) . addReg ( VR0 , RegState :: Kill ) ; TII . loadRegFromStack ( MBB , I , VR1 , FI , RC , & RegInfo , RegSize ) ; BuildMI ( MBB , I , DL , Desc , Hi ) . addReg ( VR1 , RegState :: Kill ) ; }
void ExpandPseudo :: expandStoreACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc , unsigned RegSize ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( RegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned Src = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; unsigned SrcKill = getKillRegState ( I -> getOperand ( 0 ) . isKill ( ) ) ; DebugLoc DL = I -> getDebugLoc ( ) ; BuildMI ( MBB , I , DL , TII . get ( MFLoOpc ) , VR0 ) . addReg ( Src ) ; TII . storeRegToStack ( MBB , I , VR0 , true , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , DL , TII . get ( MFHiOpc ) , VR1 ) . addReg ( Src , SrcKill ) ; TII . storeRegToStack ( MBB , I , VR1 , true , FI , RC , & RegInfo , RegSize ) ; }
bool ExpandPseudo :: expandCopy ( MachineBasicBlock & MBB , Iter I ) { unsigned Src = I -> getOperand ( 1 ) . getReg ( ) ; std :: pair < unsigned , unsigned > Opcodes = getMFHiLoOpc ( Src ) ; if ( ! Opcodes . first ) return false ; return expandCopyACC ( MBB , I , Opcodes . first , Opcodes . second ) ; }
bool ExpandPseudo :: expandCopyACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc ) { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , Src = I -> getOperand ( 1 ) . getReg ( ) ; unsigned VRegSize = RegInfo . getMinimalPhysRegClass ( Dst ) -> getSize ( ) / 2 ; const TargetRegisterClass * RC = RegInfo . intRegClass ( VRegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned SrcKill = getKillRegState ( I -> getOperand ( 1 ) . isKill ( ) ) ; unsigned DstLo = RegInfo . getSubReg ( Dst , Mips :: sub_lo ) ; unsigned DstHi = RegInfo . getSubReg ( Dst , Mips :: sub_hi ) ; DebugLoc DL = I -> getDebugLoc ( ) ; BuildMI ( MBB , I , DL , TII . get ( MFLoOpc ) , VR0 ) . addReg ( Src ) ; BuildMI ( MBB , I , DL , TII . get ( TargetOpcode :: COPY ) , DstLo ) . addReg ( VR0 , RegState :: Kill ) ; BuildMI ( MBB , I , DL , TII . get ( MFHiOpc ) , VR1 ) . addReg ( Src , SrcKill ) ; BuildMI ( MBB , I , DL , TII . get ( TargetOpcode :: COPY ) , DstHi ) . addReg ( VR1 , RegState :: Kill ) ; return true ; }
