void NavEKF_core_common :: fill_sc@@ ratch_variables ( void ) { == HAL_BOARD_SIT@@ L fill_nanf ( & KH [ 0 ] [ 0 ] , sizeof ( KH ) / sizeof ( float ) ) ; fill_nanf ( & KHP [ 0 ] [ 0 ] , sizeof ( KHP ) / sizeof ( float ) ) ; fill_nanf ( & nextP [ 0 ] [ 0 ] , sizeof ( nextP ) / sizeof ( float ) ) ; fill_nanf ( & Kfusion [ 0 ] , sizeof ( Kfusion ) / sizeof ( float ) ) ; }
bool DictionaryPopupInfo :: decode ( CoreIPC :: ArgumentDecoder * decoder , DictionaryPopupInfo & result ) { if ( ! decoder -> decode ( result . origin ) ) return false ; if ( ! decoder -> decode ( result . fontInfo ) ) return false ; if ( ! decoder -> decodeEnum ( result . type ) ) return false ; ( MAC ) && ! defined ( BUILDING_ON_SNOW_LEOPARD ) if ( ! CoreIPC :: decode ( decoder , result . options ) ) return false ; return true ; }
AboutDialog :: AboutDialog ( QWidget * parent ) : QDialog ( parent ) , ui ( new Ui :: AboutDialog ) { ui -> setupUi ( this ) ; ui -> copyright@@ Label -> setText ( tr ( " Copyright " ) + QString ( " ▁ & copy ; ▁ 2009 - % 1 ▁ " ) . arg ( COPYRIGHT_YEAR ) + tr ( " The ▁ Bitcoin ▁ developers " ) + QString ( " < br > " ) + tr ( " Copyright " ) + QString ( " ▁ & copy ; ▁ " ) + tr ( " % 1 ▁ StartJOIN " ) . arg ( ABOUTDIALOG_COPYRIGHT_YEAR ) ) ; }
void AboutDialog :: setModel ( ClientModel * model ) { if ( model ) { ui -> versionLabel -> setText ( model -> formatFull@@ Version ( ) ) ; } }
AboutDialog :: ~ AboutDialog ( ) { delete ui ; }
void AboutDialog :: on_buttonBox_@@ accepted ( ) { close ( ) ; }
HRESULT Variables :: Init ( ) { HRESULT hr = S_OK ; EX_TR@@ Y { httpURL@@ Prefix . SetLiteral ( W ( " http : // " ) ) ; architectureMSIL . SetLiteral ( W ( " MSIL " ) ) ; architectureX86 . SetLiteral ( W ( " x86" ) ) ; architectureAMD@@ 64 . SetLiteral ( W ( " AMD64" ) ) ; architectureARM . SetLiteral ( W ( " ARM " ) ) ; architectureARM64 . SetLiteral ( W ( " ARM64" ) ) ; cultureNeutral . SetLiteral ( W ( " neutral " ) ) ; mscorlib . SetLiteral ( W ( " mscorlib " ) ) ; emptyString . Clear ( ) ; REGUTIL :: CORConfigLevel kCorConfigLevel = static_cast < REGUTIL :: CORConfigLevel > ( REGUTIL :: COR_CONFIG_ENV | REGUTIL :: COR_CONFIG_FUSION ) ; DWORD dwLoggingNeeded = REGUTIL :: GetConfigDWORD_@@ DontUse_ ( CLRConfig :: EXTERNAL_Force@@ Log , 0 , kCorConfigLevel , TRUE ) ; fLoggingNeeded = ( dwLoggingNeeded ? TRUE : FALSE ) ; NewArrayHolder < WCHAR > pwzLogDirectory = REGUTIL :: GetConfigString_DontUse_ ( CLRConfig :: INTERNAL_@@ LogPath , TRUE , kCorConfigLevel , FALSE ) ; if ( pwzLogDirectory == NULL ) { fLoggingNeeded = FALSE ; } else { DWORD dwAttr = 0 ; hr = CheckFileExistence ( pwzLogDirectory , & dwAttr ) ; if ( ( hr == S_OK ) && ( ( dwAttr & FILE_ATTRIBUTE_DIREC@@ TORY ) != 0 ) ) { logPath . Set ( pwzLogDirectory ) ; } else { hr = S_OK ; fLoggingNeeded = FALSE ; } } } EX_C@@ ATCH_HRESULT ( hr ) ; return hr ; }
ICMPPacket :: ICMPPacket ( IPAddress :: Family family , int dataSize ) : _pImpl ( 0 ) { if ( family == IPAddress :: IPv4 ) _pImpl = new ICMPv4PacketImpl ( dataSize ) ; else if ( family == IPAddress :: IPv6 ) throw NotImplementedException ( " ICMPv6 ▁ packets ▁ not ▁ implemented . " ) ; else throw InvalidArgumentException ( " Invalid ▁ or ▁ unsupported ▁ address ▁ family ▁ passed ▁ to ▁ ICMPPacket " ) ; }
ICMPPacket :: ~ ICMPPacket ( ) { delete _pImpl ; }
void ICMPPacket :: setDataSize ( int dataSize ) { _pImpl -> setDataSize ( dataSize ) ; }
const Poco :: UInt8 * ICMPPacket :: packet ( ) { return _pImpl -> packet ( ) ; }
std :: string ICMPPacket :: errorDescription ( Poco :: UInt8 * buffer , int length ) { return _pImpl -> errorDescription ( buffer , length ) ; }
std :: string ICMPPacket :: typeDescription ( int typeId ) { return _pImpl -> typeDescription ( typeId ) ; }
ACE_Log_Msg_IPC :: ~ ACE_Log_Msg_IPC ( void ) { ( void ) this -> close ( ) ; }
int ACE_Log_Msg_IPC :: open ( const ACE_TCHAR * logger_key ) { ACE_LOG_MSG_IPC_CONNECTOR con ; return con . connect ( this -> message_queue_ , ACE_LOG_MSG_IPC_ADDR ( logger_key ) ) ; }
int ACE_Log_Msg_IPC :: reset ( void ) { if ( this -> message_queue_ . get_handle ( ) != ACE_INVALID_@@ HANDLE ) { return this -> close ( ) ; } return 0 ; }
int ACE_Log_Msg_IPC :: close ( void ) { return this -> message_queue_ . close ( ) ; }
ssize_t ACE_Log_Msg_IPC :: log ( ACE_Log_Record & log_record ) { size_t const max_payload_size = 4 + 4 + 12 + 4 + 4 + ( log_record . msg_data_len ( ) * ACE_OutputCDR :: wchar_maxbytes ( ) ) + log_record . msg_data_len ( ) + ACE_CDR :: MAX_ALIGNMENT ; ACE_OutputCDR payload ( max_payload_size ) ; if ( ! ( payload << log_record ) ) return - 1 ; ACE_CDR :: ULong const length = ACE_Utils :: truncate_cast < ACE_CDR :: ULong > ( payload . total_length ( ) ) ; ACE_OutputCDR header ( ACE_CDR :: MAX_ALIGNMENT + 8 ) ; if ( ! ( header << ACE_OutputCDR :: from_boolean ( ACE_CD@@ R_BY@@ TE_ORDER ) ) ) return - 1 ; if ( ! ( header << ACE_CDR :: ULong ( length ) ) ) return - 1 ; iovec iov [ 2 ] ; iov [ 0 ] . iov_base = header . begin ( ) -> rd_ptr ( ) ; iov [ 0 ] . iov_len = 8 ; iov [ 1 ] . iov_base = payload . begin ( ) -> rd_ptr ( ) ; iov [ 1 ] . iov_len = length ; ACE_HAS@@ _STREAM_LOG_MSG_IPC == 1 ) ACE_Str_Buf header_msg ( static_cast < void * > ( header . begin ( ) -> rd_ptr ( ) ) , static_cast < int > ( 8 ) ) ; ACE_Str_Buf payload_msg ( static_cast < void * > ( payload . begin ( ) -> rd_ptr ( ) ) , static_cast < int > ( length ) ) ; return this -> message_queue_ . send ( & header_msg , & payload_msg , static_cast < int > ( log_record . priority ( ) ) , MSG_BAND ) ; return this -> message_queue_ . sendv_n ( iov , 2 ) ; }
HTMLFrameSetElement :: HTMLFrameSetElement ( const QualifiedName & tagName , Document & document ) : HTMLElement ( tagName , document ) , m_totalRows ( 1 ) , m_totalCols ( 1 ) , m_border ( 6 ) , m_borderSet ( false ) , m_borderColorSet ( false ) , m_frameborder ( true ) , m_frameborderSet ( false ) , m_noresize ( false ) { ASSERT ( hasTagName ( framesetTag ) ) ; setHasCustomStyleResolveCallbacks ( ) ; }
Ref < HTMLFrameSetElement > HTMLFrameSetElement :: create ( const QualifiedName & tagName , Document & document ) { return adoptRef ( * new HTMLFrameSetElement ( tagName , document ) ) ; }
void HTMLFrameSetElement :: collectStyleForPresentationAttribute ( const QualifiedName & name , const AtomicString & value , MutableStyleProperties & style ) { if ( name == bordercolorAttr ) addHTMLColorToStyle ( style , CSSPropertyBorderColor , value ) ; else HTMLElement :: collectStyleForPresentationAttribute ( name , value , style ) ; }
void HTMLFrameSetElement :: parseAttribute ( const QualifiedName & name , const AtomicString & value ) { if ( name == rowsAttr ) { if ( ! value . isNull ( ) ) { m_rowLengths = newLengthArray ( value . string ( ) , m_totalRows ) ; setNeedsStyleRecalc ( ) ; } return ; } if ( name == colsAttr ) { if ( ! value . isNull ( ) ) { m_colLengths = newLengthArray ( value . string ( ) , m_totalCols ) ; setNeedsStyleRecalc ( ) ; } return ; } if ( name == frameborderAttr ) { if ( ! value . isNull ( ) ) { if ( equalLettersIgnoringASCIICase ( value , " no " ) || value == "0" ) { m_frameborder = false ; m_frameborderSet = true ; } else if ( equalLettersIgnoringASCIICase ( value , " yes " ) || value == "1" ) { m_frameborderSet = true ; } } else { m_frameborder = false ; m_frameborderSet = false ; } return ; } if ( name == noresizeAttr ) { m_noresize = true ; return ; } if ( name == borderAttr ) { if ( ! value . isNull ( ) ) { m_border = value . toInt ( ) ; m_borderSet = true ; } else m_borderSet = false ; return ; } if ( name == bordercolorAttr ) { m_borderColorSet = ! value . isEmpty ( ) ; return ; } auto & eventName = HTMLBodyElement :: eventNameFor@@ WindowEventHandler@@ Attribute ( name ) ; if ( ! eventName . isNull ( ) ) { document ( ) . setWindowAttributeEventListener ( eventName , name , value ) ; return ; } HTMLElement :: parseAttribute ( name , value ) ; }
bool HTMLFrameSetElement :: rendererIsNeeded ( const RenderStyle & style ) { return style . isStyleAvailable ( ) ; }
RenderPtr < RenderElement > HTMLFrameSetElement :: createElement@@ Renderer ( Ref < RenderStyle > && style , const RenderTreePosition & ) { if ( style . get ( ) . hasContent ( ) ) return RenderElement :: createFor ( * this , WTFMove ( style ) ) ; return createRenderer < RenderFrameSet > ( * this , WTFMove ( style ) ) ; }
HTMLFrameSetElement * HTMLFrameSetElement :: findContaining ( Element * descendant ) { return ancestorsOf@@ Type < HTMLFrameSetElement > ( * descendant ) . first ( ) ; }
void HTMLFrameSetElement :: willAttachRendere@@ rs ( ) { const HTMLFrameSetElement * containingFrameSet = findContaining ( this ) ; if ( ! containingFrameSet ) return ; if ( ! m_frameborderSet ) m_frameborder = containingFrameSet -> hasFrame@@ Border ( ) ; if ( m_frameborder ) { if ( ! m_borderSet ) m_border = containingFrameSet -> border ( ) ; if ( ! m_borderColorSet ) m_borderColorSet = containingFrameSet -> hasBorderColor ( ) ; } if ( ! m_noresize ) m_noresize = containingFrameSet -> noResize ( ) ; }
void HTMLFrameSetElement :: defaultEventHandler ( Event * event ) { ASSERT ( event ) ; if ( is < MouseEvent > ( * event ) && ! m_noresize && is < RenderFrameSet > ( renderer ( ) ) ) { if ( downcast < RenderFrameSet > ( * renderer ( ) ) . userResize ( downcast < MouseEvent > ( event ) ) ) { event -> setDefaultHandled ( ) ; return ; } } HTMLElement :: defaultEventHandler ( event ) ; }
bool HTMLFrameSetElement :: willRecalcStyle ( Style :: Change ) { if ( needsStyleRecalc ( ) && renderer ( ) ) { renderer ( ) -> setNeedsLayout ( ) ; clearNeeds@@ StyleRecalc ( ) ; } return true ; }
Node :: InsertionNotificationRequest HTMLFrameSetElement :: insertedInto ( ContainerNode & insertionPoint ) { HTMLElement :: insertedInto ( insertionPoint ) ; if ( insertionPoint . inDocument ( ) ) { if ( Frame * frame = document ( ) . frame ( ) ) frame -> loader ( ) . client ( ) . dispatchDidBecomeFrameset ( document ( ) . isFrameSet ( ) ) ; } return InsertionDone ; }
void HTMLFrameSetElement :: removedFrom ( ContainerNode & insertionPoint ) { HTMLElement :: removedFrom ( insertionPoint ) ; if ( insertionPoint . inDocument ( ) ) { if ( Frame * frame = document ( ) . frame ( ) ) frame -> loader ( ) . client ( ) . dispatchDidBecomeFrameset ( document ( ) . isFrameSet ( ) ) ; } }
void Accumulator :: addOperand ( const intrusi@@ ve_ptr < Expression > & pExpression ) { uassert ( 1594@@ 3 , str :: stream ( ) << " group ▁ accumulator ▁ " << getOpName ( ) << " ▁ only ▁ accepts ▁ one ▁ operand " , vpOperand . size ( ) < 1 ) ; ExpressionNary :: addOperand ( pExpression ) ; }
void JSDocument :: setLocation ( ExecState * exec , JSValue value ) { Frame * frame = static_cast < Document * > ( impl ( ) ) -> frame ( ) ; if ( ! frame ) return ; String locationString = value . toString ( exec ) -> value ( exec ) ; if ( exec -> hadException ( ) ) return ; if ( Location * location = frame -> document ( ) -> domWindow ( ) -> location ( ) ) location -> setHref ( locationString , activeDOMWindow ( exec ) , firstDOMWindow ( exec ) ) ; }
GeneralParamReceiver :: ~ GeneralParamReceiver ( ) { m_guiProtHandler -> DeregisterReceiver ( this , isab :: GuiProtEnums :: SET_GENERAL_PARAMETER ) ; m_guiProtHandler -> DeregisterReceiver ( this , isab :: GuiProtEnums :: GET_GENERAL_PARAMETER ) ; }
void GeneralParamReceiver :: init ( ) { m_guiProtHandler -> RegisterReceiver ( this , isab :: GuiProtEnums :: SET_GENERAL_PARAMETER ) ; m_guiProtHandler -> RegisterReceiver ( this , isab :: GuiProtEnums :: GET_GENERAL_PARAMETER ) ; }
bool GeneralParamReceiver :: decodedParamNoValue ( uint32 paramId ) { return false ; }
bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const float * data , int32 numEntries ) { return false ; }
bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const uint8 * data , int32 numEntries ) { return false ; }
bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const char * * data , int32 numEntries ) { return false ; }
bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const int32 * data , int32 numEntries ) { switch ( paramId ) { case GuiProtEnums :: paramAutoReroute : { m_settingsData -> m_autoReroute = data [ 0 ] ; } break ; case GuiProtEnums :: paramBack@@ lightStrategy : { m_settingsData -> m_backlightStrategy = data [ 0 ] ; } break ; case GuiProtEnums :: paramAutoTracking : { m_settingsData -> m_autoTracking = data [ 0 ] ; } break ; case GuiProtEnums :: paramDistance@@ Mode : { m_settingsData -> m_distanceMode = data [ 0 ] ; } break ; case GuiProtEnums :: paramFavorite@@ Show : { m_settingsData -> m_favorite@@ ShowInMap = data [ 0 ] ; } break ; case GuiProtEnums :: paramHighways : { m_settingsData -> m_routeHighways = data [ 0 ] ; } break ; case GuiProtEnums :: paramTollRoads : { m_settingsData -> m_routeTollRoads = data [ 0 ] ; } break ; case GuiProtEnums :: paramTimeDi@@ st : { m_settingsData -> m_routeCostType = data [ 0 ] ; } break ; case GuiProtEnums :: paramTrack@@ ingLevel : { m_settingsData -> m_trackingLevel = data [ 0 ] ; } break ; case GuiProtEnums :: paramTransport@@ ationType : { m_settingsData -> m_transportationType = data [ 0 ] ; } break ; case GuiProtEnums :: paramTurn@@ SoundsLevel : { m_settingsData -> m_turnSoundsLevel = data [ 0 ] ; } break ; case GuiProtEnums :: userTraffic@@ UpdatePeriod : { int32 val = data [ 0 ] ; m_settingsData -> m_trafficUpdatePeriod = 0xbfffffff & val ; m_settingsData -> m_trafficOldUpdatePeriod = 0xbfffffff & val ; m_settingsData -> m_trafficUpdate = 0x40000000 & val ? 0 : 1 ; m_settingsData -> m_trafficOldUpdate = 0x40000000 & val ? 0 : 1 ; } break ; case GuiProtEnums :: paramAutomati@@ cRouteOnSMSDest : { m_settingsData -> m_autoRouteOnSMSDest = data [ 0 ] ; } break ; case GuiProtEnums :: paramKeep@@ SMSDestInInbox : { m_settingsData -> m_keepSMSDestInInbox = data [ 0 ] ; } break ; case GuiProtEnums :: paramStore@@ SMSDestInMyDest : { m_settingsData -> m_storeSMSDestIn@@ Favorites = data [ 0 ] ; } break ; case GuiProtEnums :: paramPosition@@ Symbol : { m_settingsData -> m_positionSymbol = data [ 0 ] ; } break ; case GuiProtEnums :: paramCheck@@ ForUpdates : { m_settingsData -> m_checkForUpdates = data [ 0 ] ; } break ; default : return false ; break ; } return true ; }
bool GeneralParamReceiver :: GuiProtReceiveMessage ( class GuiProtMess * mess ) { GuiProtEnums :: MessageType type = mess -> getMessageType ( ) ; if ( type == GuiProtEnums :: GET_GENERAL_PARAMETER ) { isab :: GeneralParameterMess * gpm = ( isab :: GeneralParameterMess * ) mess ; return decodedParamNoValue ( gpm -> getParamId ( ) ) ; } else if ( type == GuiProtEnums :: SET_GENERAL_PARAMETER ) { isab :: GeneralParameterMess * gpm = ( isab :: GeneralParameterMess * ) mess ; switch ( gpm -> getParamType ( ) ) { case isab :: GuiProtEnums :: paramTypeInt32 : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getIntegerData ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramTypeFloat : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getFloatData ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramTypeBinary : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getBinaryData ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramTypeString : return decodedParamValue ( gpm -> getParamId ( ) , ( const char * * ) gpm -> getStringData ( ) , gpm -> getNumEntries ( ) ) ; break ; default : case isab :: GuiProtEnums :: paramTypeInvalid : return false ; break ; } } return false ; }
StyleManagerDialog :: StyleManagerDialog ( QWidget * parent , Selection * selection , KCStyleManager * manager ) : KDialog ( parent ) , m_selection ( selection ) , m_styleManager ( manager ) { setButtons ( Apply | User1 | User2 | User3 | Close ) ; setButtonText ( User3 , i18n ( " & New . . . " ) ) ; setButtonText ( User2 , i18n ( " & Modify . . . " ) ) ; setButtonText ( User1 , i18n ( " & Delete . . . " ) ) ; setButtonsOrientation ( Qt :: Vertical ) ; setCaption ( i18n ( " Style ▁ Manager " ) ) ; QWidget * widget = new QWidget ( this ) ; setMainWidget ( widget ) ; QVBoxLayout * layout = new QVBoxLayout ( widget ) ; m_styleList = new QTreeWidget ( this ) ; m_styleList -> setHeaderLabel ( i18n ( " Style " ) ) ; layout -> addWidget ( m_styleList ) ; m_displayBox = new KComboBox ( false , this ) ; m_displayBox -> insertItem ( 0 , i18n ( " All ▁ Styles " ) ) ; m_displayBox -> insertItem ( 1 , i18n ( " Custom ▁ Styles " ) ) ; m_displayBox -> insertItem ( 2 , i18n ( " Hierarchical " ) ) ; layout -> addWidget ( m_displayBox ) ; slotDisplayMode ( 0 ) ; enableButton ( KDialog :: User3 , true ) ; enableButton ( KDialog :: User2 , true ) ; enableButton ( KDialog :: User1 , false ) ; connect ( m_displayBox , SIGNAL ( activated ( int ) ) , this , SLOT ( slotDisplayMode ( int ) ) ) ; connect ( this , SIGNAL ( applyClicked ( ) ) , this , SLOT ( slotOk ( ) ) ) ; connect ( this , SIGNAL ( user3Clicked ( ) ) , this , SLOT ( slotNew ( ) ) ) ; connect ( this , SIGNAL ( user2Clicked ( ) ) , this , SLOT ( slotEdit ( ) ) ) ; connect ( this , SIGNAL ( user1Clicked ( ) ) , this , SLOT ( slotRemove ( ) ) ) ; connect ( m_styleList , SIGNAL ( itemDoubleClicked ( QTreeWidgetItem * , int ) ) , this , SLOT ( slotEdit ( ) ) ) ; connect ( m_styleList , SIGNAL ( currentItem@@ Changed ( QTreeWidgetItem * , QTreeWidgetItem * ) ) , this , SLOT ( selectionChanged ( QTreeWidgetItem * ) ) ) ; }
void StyleManagerDialog :: fillComboBox ( ) { typedef QMap < KCCustomStyle * , QTreeWidgetItem * > KCMap ; KCMap entries ; entries . clear ( ) ; entries [ m_styleManager -> defaultStyle ( ) ] = new QTreeWidgetItem ( m_styleList , QStringList ( i18n ( " Default " ) ) ) ; CustomStyles :: const_iterator iter = m_styleManager -> m_styles . constBegin ( ) ; CustomStyles :: const_iterator end = m_styleManager -> m_styles . constEnd ( ) ; while ( entries . count ( ) != m_styleManager -> m_styles . count ( ) + 1 ) { if ( entries . find ( iter . value ( ) ) == entries . end ( ) ) { if ( iter . value ( ) -> parentName ( ) . isNull ( ) ) entries [ iter . value ( ) ] = new QTreeWidgetItem ( entries [ m_styleManager -> defaultStyle ( ) ] , QStringList ( iter . value ( ) -> name ( ) ) ) ; else { KCCustomStyle * parentStyle = m_styleManager -> style ( iter . value ( ) -> parentName ( ) ) ; if ( parentStyle ) { KCMap :: const_iterator i = entries . constFind ( parentStyle ) ; if ( i != entries . constEnd ( ) ) entries [ iter . value ( ) ] = new QTreeWidgetItem ( i . value ( ) , QStringList ( iter . value ( ) -> name ( ) ) ) ; } } } ++ iter ; if ( iter == end ) iter = m_styleManager -> m_styles . constBegin ( ) ; } entries . clear ( ) ; }
void StyleManagerDialog :: slotDisplayMode ( int mode ) { m_styleList -> clear ( ) ; if ( mode != 2 ) m_styleList -> setRootIsDecorated ( false ) ; else { m_styleList -> setRootIsDecorated ( true ) ; fillComboBox ( ) ; return ; } if ( mode != 1 ) new QTreeWidgetItem ( m_styleList , QStringList ( i18n ( " Default " ) ) ) ; CustomStyles :: iterator iter = m_styleManager -> m_styles . begin ( ) ; CustomStyles :: iterator end = m_styleManager -> m_styles . end ( ) ; while ( iter != end ) { KCCustomStyle * styleData = iter . value ( ) ; if ( ! styleData || styleData -> name ( ) . isEmpty ( ) ) { ++ iter ; continue ; } if ( mode == 1 ) { if ( styleData -> type ( ) == KCStyle :: CUSTOM ) new QTreeWidgetItem ( m_styleList , QStringList ( styleData -> name ( ) ) ) ; } else new QTreeWidgetItem ( m_styleList , QStringList ( styleData -> name ( ) ) ) ; ++ iter ; } }
void StyleManagerDialog :: slotOk ( ) { kDebug ( ) ; QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) { accept ( ) ; return ; } QString name ( item -> text ( 0 ) ) ; if ( name == i18n ( " Default " ) ) { KCStyleCommand * command = new KCStyleCommand ( ) ; command -> setSheet ( m_selection -> activeSheet ( ) ) ; command -> setDefault ( ) ; command -> add ( * m_selection ) ; command -> execute ( m_selection -> canvas ( ) ) ; } else { KCStyleCommand * command = new KCStyleCommand ( ) ; command -> setSheet ( m_selection -> activeSheet ( ) ) ; command -> setParentName ( name ) ; command -> add ( * m_selection ) ; command -> execute ( m_selection -> canvas ( ) ) ; } accept ( ) ; }
void StyleManagerDialog :: slotNew ( ) { KCCustomStyle * parentStyle = 0 ; QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( item ) { const QString name = item -> text ( 0 ) ; if ( name == i18n ( " Default " ) ) parentStyle = m_styleManager -> defaultStyle ( ) ; else parentStyle = m_styleManager -> style ( name ) ; } else parentStyle = m_styleManager -> defaultStyle ( ) ; int i = 1 ; QString newName ( i18n ( " style % 1" , m_styleManager -> count ( ) + i ) ) ; while ( m_styleManager -> style ( newName ) != 0 ) { ++ i ; newName = i18n ( " style % 1" , m_styleManager -> count ( ) + i ) ; } KCCustomStyle * style = new KCCustomStyle ( newName , parentStyle ) ; style -> setType ( KCStyle :: TENTATIVE ) ; QPointer < CellFormatDialog > dialog = new CellFormatDialog ( this , m_selection , style , m_styleManager ) ; dialog -> exec ( ) ; delete dialog ; if ( style -> type ( ) == KCStyle :: TENTATIVE ) { delete style ; return ; } m_styleManager -> m_styles [ style -> name ( ) ] = style ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; }
void StyleManagerDialog :: slotEdit ( ) { QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) return ; KCCustomStyle * style = 0 ; QString name ( item -> text ( 0 ) ) ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) return ; QPointer < CellFormatDialog > dialog = new CellFormatDialog ( this , m_selection , style , m_styleManager ) ; dialog -> exec ( ) ; if ( dialog -> result ( ) == Accepted ) m_selection -> emitRefreshSheet@@ Views ( ) ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; delete dialog ; }
void StyleManagerDialog :: slotRemove ( ) { QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) return ; const QString name = item -> text ( 0 ) ; KCCustomStyle * style = 0 ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) return ; if ( style -> type ( ) != KCStyle :: CUSTOM ) return ; m_styleManager -> takeStyle ( style ) ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; }
void StyleManagerDialog :: selectionChanged ( QTreeWidgetItem * item ) { if ( ! item ) return ; const QString name = item -> text ( 0 ) ; KCCustomStyle * style = 0 ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) { enableButton ( KDialog :: User1 , false ) ; return ; } if ( style -> type ( ) == KCStyle :: BUILTIN ) enableButton ( KDialog :: User1 , false ) ; else enableButton ( KDialog :: User1 , true ) ; }
Color3 :: Color3 ( const Any & any ) { * this = Color3 :: zero ( ) ; any . verifyName ( " Color3" ) ; std :: string name = toLower ( any . name ( ) ) ; switch ( any . type ( ) ) { case Any :: TABLE : for ( Any :: AnyTable :: Iterator it = any . table ( ) . begin ( ) ; it . hasMore ( ) ; ++ it ) { const std :: string & key = toLower ( it -> key ) ; if ( key == " r " ) { r = it -> value ; } else if ( key == " g " ) { g = it -> value ; } else if ( key == " b " ) { b = it -> value ; } else { any . verify ( false , " Illegal ▁ key : ▁ " + it -> key ) ; } } break ; case Any :: ARRAY : if ( name == " color3" ) { any . verifySize ( 3 ) ; r = any [ 0 ] ; g = any [ 1 ] ; b = any [ 2 ] ; } else if ( name == " color3 : : one " ) { any . verifySize ( 0 ) ; * this = one ( ) ; } else if ( name == " color3 : : zero " ) { any . verifySize ( 0 ) ; * this = zero ( ) ; } else if ( name == " color3 : : fromargb " ) { * this = Color3 :: fromARGB ( ( int ) any [ 0 ] . number ( ) ) ; } else { any . verify ( false , " Expected ▁ Color3 ▁ constructor " ) ; } break ; default : any . verify ( false , " Bad ▁ Color3 ▁ constructor " ) ; } }
Color3 Color3 :: ansiMap ( uint32 i ) { static const Color3 map [ ] = { Color3 :: black ( ) , Color3 :: red ( ) * 0.75f , Color3 :: green ( ) * 0.75f , Color3 :: yellow ( ) * 0.75f , Color3 :: blue ( ) * 0.75f , Color3 :: purple ( ) * 0.75f , Color3 :: cyan ( ) * 0.75f , Color3 :: white ( ) * 0.75f , Color3 :: white ( ) * 0.90f , Color3 :: red ( ) , Color3 :: green ( ) , Color3 :: yellow ( ) , Color3 :: blue ( ) , Color3 :: purple ( ) , Color3 :: cyan ( ) , Color3 :: white ( ) } ; return map [ i & 15 ] ; }
Color3 Color3 :: pastelMap ( uint32 i ) { uint32 x = Crypto :: crc32 ( & i , sizeof ( uint32 ) ) ; Vector3 v ( ( ( x >> 22 ) & 1023 ) / 1023@@ .0f , ( ( ( x >> 11 ) & 2047 ) / 2047.0f ) * 0.5f + 0.25f , ( ( x & 2047 ) / 2047.0f ) * 0.75f + 0.25f ) ; return Color3 :: fromHSV ( v ) ; }
const Color3 & Color3 :: red ( ) { static Color3 c ( 1.0f , 0.0f , 0.0f ) ; return c ; }
const Color3 & Color3 :: green ( ) { static Color3 c ( 0.0f , 1.0f , 0.0f ) ; return c ; }
const Color3 & Color3 :: blue ( ) { static Color3 c ( 0.0f , 0.0f , 1.0f ) ; return c ; }
const Color3 & Color3 :: purple ( ) { static Color3 c ( 0.7f , 0.0f , 1.0f ) ; return c ; }
const Color3 & Color3 :: cyan ( ) { static Color3 c ( 0.0f , 0.7f , 1.0f ) ; return c ; }
const Color3 & Color3 :: yellow ( ) { static Color3 c ( 1.0f , 1.0f , 0.0f ) ; return c ; }
const Color3 & Color3 :: brown ( ) { static Color3 c ( 0.5f , 0.5f , 0.0f ) ; return c ; }
const Color3 & Color3 :: orange ( ) { static Color3 c ( 1.0f , 0.5f , 0.0f ) ; return c ; }
const Color3 & Color3 :: black ( ) { static Color3 c ( 0.0f , 0.0f , 0.0f ) ; return c ; }
const Color3 & Color3 :: zero ( ) { static Color3 c ( 0.0f , 0.0f , 0.0f ) ; return c ; }
const Color3 & Color3 :: one ( ) { static Color3 c ( 1.0f , 1.0f , 1.0f ) ; return c ; }
const Color3 & Color3 :: gray ( ) { static Color3 c ( 0.7f , 0.7f , 0.7f ) ; return c ; }
const Color3 & Color3 :: white ( ) { static Color3 c ( 1 , 1 , 1 ) ; return c ; }
Color3 :: Color3 ( BinaryInput & bi ) { deserialize ( bi ) ; }
void Color3 :: deserialize ( BinaryInput & bi ) { r = bi . readFloat32 ( ) ; g = bi . readFloat32 ( ) ; b = bi . readFloat32 ( ) ; }
const Color3 & Color3 :: wheelRandom ( ) { static const Color3 colorArray [ 8 ] = { Color3 :: blue ( ) , Color3 :: red ( ) , Color3 :: green ( ) , Color3 :: orange ( ) , Color3 :: yellow ( ) , Color3 :: cyan ( ) , Color3 :: purple ( ) , Color3 :: brown ( ) } ; return colorArray [ iRandom ( 0 , 7 ) ] ; }
Color3 :: Color3 ( const Vector3 & v ) { r = v . x ; g = v . y ; b = v . z ; }
Color3 :: Color3 ( const class Color3uint8 & other ) { r = other . r / 255.0f ; g = other . g / 255.0f ; b = other . b / 255.0f ; }
Color3 Color3 :: fromARGB ( uint32 x ) { return Color3 ( ( float ) ( ( x >> 16 ) & 0xFF ) , ( float ) ( ( x >> 8 ) & 0xFF ) , ( float ) ( x & 0xFF ) ) / 255.0f ; }
Color3 Color3 :: random ( ) { return Color3 ( uniformRandom ( ) , uniformRandom ( ) , uniformRandom ( ) ) . direction ( ) ; }
float Color3 :: unitize ( float fTolerance ) { float fLength = length ( ) ; if ( fLength > fTolerance ) { float fInvLength = 1.0f / fLength ; r *= fInvLength ; g *= fInvLength ; b *= fInvLength ; } else { fLength = 0.0f ; } return fLength ; }
Color3 Color3 :: fromHSV ( const Vector3 & _hsv ) { debugAssertM ( ( _hsv . x <= 1.0f && _hsv . x >= 0.0f ) && ( _hsv . y <= 1.0f && _hsv . y >= 0.0f ) && ( _hsv . z <= 1.0f && _hsv . z >= 0.0f ) , " H , S , V ▁ must ▁ be ▁ between ▁ [ 0,1 ] " ) ; const int i = iMin ( 5 , G3D :: iFloor ( 6.0 * _hsv . x ) ) ; const float f = 6.0f * _hsv . x - i ; const float m = _hsv . z * ( 1.0f - ( _hsv . y ) ) ; const float n = _hsv . z * ( 1.0f - ( _hsv . y * f ) ) ; const float k = _hsv . z * ( 1.0f - ( _hsv . y * ( 1 - f ) ) ) ; switch ( i ) { case 0 : return Color3 ( _hsv . z , k , m ) ; case 1 : return Color3 ( n , _hsv . z , m ) ; case 2 : return Color3 ( m , _hsv . z , k ) ; case 3 : return Color3 ( m , n , _hsv . z ) ; case 4 : return Color3 ( k , m , _hsv . z ) ; case 5 : return Color3 ( _hsv . z , m , n ) ; default : debugAssertM ( false , " fell ▁ through ▁ switch . . " ) ; } return Color3 :: black ( ) ; }
Vector3 Color3 :: toHSV ( const Color3 & _rgb ) { debugAssertM ( ( _rgb . r <= 1.0f && _rgb . r >= 0.0f ) && ( _rgb . g <= 1.0f && _rgb . g >= 0.0f ) && ( _rgb . b <= 1.0f && _rgb . b >= 0.0f ) , " R , G , B ▁ must ▁ be ▁ between ▁ [ 0,1 ] " ) ; Vector3 hsv = Vector3 :: zero ( ) ; hsv . z = G3D :: max ( G3D :: max ( _rgb . r , _rgb . g ) , _rgb . b ) ; if ( G3D :: fuzzyEq ( hsv . z , 0.0f ) ) { return hsv ; } const float x = G3D :: min ( G3D :: min ( _rgb . r , _rgb . g ) , _rgb . b ) ; hsv . y = ( hsv . z - x ) / hsv . z ; if ( G3D :: fuzzyEq ( hsv . y , 0.0f ) ) { return hsv ; } Vector3 rgbN ; rgbN . x = ( hsv . z - _rgb . r ) / ( hsv . z - x ) ; rgbN . y = ( hsv . z - _rgb . g ) / ( hsv . z - x ) ; rgbN . z = ( hsv . z - _rgb . b ) / ( hsv . z - x ) ; if ( _rgb . r == hsv . z ) { hsv . x = ( _rgb . g == x ) ? 5.0f + rgbN . z : 1.0f - rgbN . y ; } else if ( _rgb . g == hsv . z ) { hsv . x = ( _rgb . b == x ) ? 1.0f + rgbN . x : 3.0f - rgbN . z ; } else { hsv . x = ( _rgb . r == x ) ? 3.0f + rgbN . y : 5.0f - rgbN . x ; } hsv . x /= 6.0f ; return hsv ; }
Color3 Color3 :: jetColorMap ( const float & val ) { debugAssertM ( val <= 1.0f && val >= 0.0f , " value ▁ should ▁ be ▁ in ▁ [ 0,1 ] " ) ; Color3 jet ; jet . r = G3D :: min ( 4.0f * val - 1.5f , - 4.0f * val + 4.5f ) ; jet . g = G3D :: min ( 4.0f * val - 0.5f , - 4.0f * val + 3.5f ) ; jet . b = G3D :: min ( 4.0f * val + 0.5f , - 4.0f * val + 2.5f ) ; jet . r = G3D :: clamp ( jet . r , 0.0f , 1.0f ) ; jet . g = G3D :: clamp ( jet . g , 0.0f , 1.0f ) ; jet . b = G3D :: clamp ( jet . b , 0.0f , 1.0f ) ; return jet ; }
Color3 Color3 :: rainbowColorMap ( float hue ) { return fromHSV ( Vector3 ( hue , 1.0f , 1.0f ) ) ; }
PythonScriptController :: PythonScriptController ( ) : ScriptController ( ) , m_filename ( initData ( & m_filename , " filename " , " Python ▁ script ▁ filename " ) ) , m_classname ( initData ( & m_classname , " classname " , " Python ▁ class ▁ implemented ▁ in ▁ the ▁ script ▁ to ▁ instanciate ▁ for ▁ the ▁ controller " ) ) , m_variables ( initData ( & m_variables , " variables " , " Array ▁ of ▁ string ▁ variables ▁ ( equivalent ▁ to ▁ a ▁ c - like ▁ argv ) " ) ) , m_timingEnabled ( initData ( & m_timingEnabled , true , " timingEnabled " , " Set ▁ this ▁ attribute ▁ to ▁ true ▁ or ▁ false ▁ to ▁ activate / deactivate ▁ the ▁ gathering " " ▁ of ▁ timing ▁ statistics ▁ on ▁ the ▁ python ▁ execution ▁ time . ▁ Default ▁ value ▁ is ▁ set " " to ▁ true . " ) ) , m_doAutoReload ( initData ( & m_doAutoReload , false , " autore@@ load " , " Automatically ▁ reload ▁ the ▁ file ▁ when ▁ the ▁ source ▁ code ▁ is ▁ changed . ▁ " " Default ▁ value ▁ is ▁ set ▁ to ▁ false " ) ) , m_ScriptControllerClass ( nullptr ) , m_ScriptControllerInstance ( nullptr ) { m_filelistener = new MyFileEventListener ( this ) ; }
PythonScriptController :: ~ PythonScriptController ( ) { if ( m_filelistener ) { FileMonitor :: removeListener ( m_filelistener ) ; delete m_filelistener ; } }
void PythonScriptController :: setInstance ( PyObject * instance ) { PythonEnvironment :: gil lock ( __func__ ) ; if ( m_ScriptControllerInstance ) { Py_DECREF ( m_ScriptControllerInstance ) ; } m_ScriptControllerInstance = instance ; m_ScriptControllerClass = ( PyObject * ) instance -> ob_type ; Py_INCRE@@ F ( instance ) ; refreshBinding ( ) ; }
void PythonScriptController :: refreshBinding ( ) { BIND_OBJECT_METHOD ( onLoaded ) BIND_OBJECT_METHOD ( createGraph ) BIND_OBJECT_METHOD ( initGraph ) BIND_OBJECT_METHOD ( bwdInitGraph ) BIND_OBJECT_METHOD ( onKeyPressed ) BIND_OBJECT_METHOD ( onKeyReleased ) BIND_OBJECT_METHOD ( onMouseMove ) BIND_OBJECT_METHOD ( onMouseButtonLeft ) BIND_OBJECT_METHOD ( onMouseButtonRight ) BIND_OBJECT_METHOD ( onMouseButtonMiddle ) BIND_OBJECT_METHOD ( onMouseWheel ) BIND_OBJECT_METHOD ( onBeginAnimationStep ) BIND_OBJECT_METHOD ( onEndAnimationStep ) BIND_OBJECT_METHOD ( storeResetState ) BIND_OBJECT_METHOD ( reset ) BIND_OBJECT_METHOD ( cleanup ) BIND_OBJECT_METHOD ( onGUIEvent ) BIND_OBJECT_METHOD ( onScriptEvent ) BIND_OBJECT_METHOD ( draw ) BIND_OBJECT_METHOD ( onIdle ) }
bool PythonScriptController :: isDerivedFrom ( const std :: string & name , const std :: string & module ) { PythonEnvironment :: gil lock ( __func__ ) ; PyObject * moduleDict = PyModule_GetDict ( PyImport_AddModule ( module . c_str ( ) ) ) ; PyObject * controllerClass = PyDict_GetItemString ( moduleDict , name . c_str ( ) ) ; return 1 == PyObject_IsInstance ( m_ScriptControllerInstance , controllerClass ) ; }
void PythonScriptController :: loadScript ( ) { PythonEnvironment :: gil lock ( __func__ ) ; if ( m_doAutoReload . getValue ( ) ) { FileMonitor :: addFile ( m_filename . getFullPath ( ) , m_filelistener ) ; } if ( m_filename . isSet ( ) && ! m_filename . getRelativePath ( ) . empty ( ) && ! PythonEnvironment :: runFile ( m_filename . getFullPath ( ) . c_str ( ) ) ) { msg_error ( ) << " ▁ load ▁ error ▁ ( file ▁ ' " << m_filename . getFullPath ( ) . c_str ( ) << " ' ▁ not ▁ parsable ) " ; return ; } PyObject * pDict = PyModule_GetDict ( PyImport_AddModule ( " _ _ main _ _ " ) ) ; m_ScriptControllerClass = PyDict_GetItemString ( pDict , m_classname . getValueString ( ) . c_str ( ) ) ; if ( ! m_ScriptControllerClass ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ not ▁ found ) . " ; return ; } if ( 1 != PyObject_IsSubclass ( m_ScriptControllerClass , ( PyObject * ) & SP_SOF@@ APYTYPE@@ OBJECT ( PythonScriptController ) ) ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ does ▁ not ▁ inherit ▁ from ▁ ' Sofa . PythonScriptController ' ) . " ; return ; } m_ScriptControllerInstance = BuildPySPtr < Base > ( this , ( PyTypeObject * ) m_ScriptControllerClass ) ; if ( ! m_ScriptControllerInstance ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ instanciation ▁ error ) . " ; return ; } refreshBinding ( ) ; }
void PythonScriptController :: doLoadScript ( ) { loadScript ( ) ; }
void PythonScriptController :: script_onIdleEvent ( const IdleEvent * ) { FileMonitor :: updates ( 0 ) ; { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_onIdle ) ; } std :: cout . flush ( ) ; std :: cerr . flush ( ) ; }
void PythonScriptController :: script_onLoaded ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onLoaded , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) }
void PythonScriptController :: script_createGraph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_createGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) }
void PythonScriptController :: script_init@@ Graph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_initGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) }
void PythonScriptController :: script_bwdInitGraph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_bwdInitGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) }
bool PythonScriptController :: script_onKeyPressed ( const char c ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onKeyPressed " , this ) ; bool b = false ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEBOOLFUNC ( m_Func_onKeyPressed , " ( c ) " , c ) ; return b ; }
bool PythonScriptController :: script_onKeyReleased ( const char c ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onKeyReleased " , this ) ; bool b = false ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEBOOLFUNC ( m_Func_onKeyReleased , " ( c ) " , c ) ; return b ; }
void PythonScriptController :: script_onMouseMove ( const int posX , const int posY ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseMove " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onMouseMove , " ( ii ) " , posX , posY ) ; }
void PythonScriptController :: script_onMouseButtonLeft ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonLeft " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonLeft , " ( iiO ) " , posX , posY , pyPressed ) }
void PythonScriptController :: script_onMouseButtonRight ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonRight " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonRight , " ( iiO ) " , posX , posY , pyPressed ) }
void PythonScriptController :: script_onMouseButtonMiddle ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonMiddle " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonMiddle , " ( iiO ) " , posX , posY , pyPressed ) }
void PythonScriptController :: script_onMouseWheel ( const int posX , const int posY , const int delta ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseWheel " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onMouseWheel , " ( iii ) " , posX , posY , delta ) }
void PythonScriptController :: script_onBeginAnimationStep ( const double dt ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onBeginAnimationStep " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onBeginAnimationStep , " ( d ) " , dt ) }
void PythonScriptController :: script_onEndAnimationStep ( const double dt ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onEndAnimationStep " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onEndAnimationStep , " ( d ) " , dt ) }
void PythonScriptController :: script_storeResetState ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_storeResetState ) }
void PythonScriptController :: script_reset ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_reset ) }
void PythonScriptController :: script_cleanup ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_cleanup ) }
void PythonScriptController :: script_onGUIEvent ( const char * controlID , const char * valueName , const char * value ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onGUIEvent " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onGUIEvent , " ( sss ) " , controlID , valueName , value ) ; }
void PythonScriptController :: script_onScriptEvent ( core :: objectmodel :: ScriptEvent * event ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onScriptEvent " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PythonScriptEvent * pyEvent = static_cast < PythonScriptEvent * > ( event ) ; SP_CALL_MODULEFUNC ( m_Func_onScriptEvent , " ( OsO ) " , sofa :: PythonFactory :: toPython ( pyEvent -> getSender ( ) . get ( ) ) , pyEvent -> getEventName ( ) . c_str ( ) , pyEvent -> getUserData ( ) ) ; }
void PythonScriptController :: script_d@@ raw ( const core :: visual :: VisualParams * ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ draw " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_draw ) ; }
void PythonScriptController :: handleEvent ( core :: objectmodel :: Event * event ) { if ( PythonScriptEvent :: checkEventType ( event ) ) { script_onScriptEvent ( static_cast < PythonScriptEvent * > ( event ) ) ; } else { ScriptController :: handleEvent ( event ) ; } }
bool AudioResampler :: qualityIsSupported ( src_quality quality ) { switch ( quality ) { case DEFAULT_QUALITY : case LOW_QUALITY : case MED_QUALITY : case HIGH_QUALITY : case VERY_HIGH_QUALITY : return true ; default : return false ; } }
uint32_t AudioResampler :: qualityMHz ( src_quality quality ) { switch ( quality ) { default : case DEFAULT_QUALITY : case LOW_QUALITY : return 3 ; case MED_QUALITY : return 6 ; case HIGH_QUALITY : return 20 ; case VERY_HIGH_QUALITY : return 34 ; } }
AudioResampler * AudioResampler :: create ( audio_format@@ _t format , int inChannelCount , int32_t sampleRate , src_quality quality ) { bool atFinalQuality ; if ( quality == DEFAULT_QUALITY ) { int ok = pthread_once ( & once_control , init_routine ) ; if ( ok != 0 ) { ALOGE ( " % s ▁ pthread _ once ▁ failed : ▁ % d " , __func__ , ok ) ; } quality = defaultQuality ; atFinalQuality = false ; } else { atFinalQuality = true ; } if ( quality == DEFAULT_QUALITY ) { } pthread_mutex_lock ( & mutex ) ; for ( ; ; ) { uint32_t deltaMHz = qualityMHz ( quality ) ; uint32_t newMHz = currentMHz + deltaMHz ; if ( ( qualityIsSupported ( quality ) && newMHz <= maxMHz ) || atFinalQuality ) { ALOGV ( " resampler ▁ load ▁ % u ▁ - > ▁ % u ▁ MHz ▁ due ▁ to ▁ delta ▁ + % u ▁ MHz ▁ from ▁ quality ▁ % d " , currentMHz , newMHz , deltaMHz , quality ) ; currentMHz = newMHz ; break ; } switch ( quality ) { default : case LOW_QUALITY : atFinalQuality = true ; break ; case MED_QUALITY : quality = LOW_QUALITY ; break ; case HIGH_QUALITY : quality = MED_QUALITY ; break ; case VERY_HIGH_QUALITY : quality = HIGH_QUALITY ; break ; } } pthread_mutex_unlock ( & mutex ) ; AudioResampler * resampler ; switch ( quality ) { default : case LOW_QUALITY : ALOGV ( " Create ▁ linear ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; resampler = new ( std :: nothrow ) AudioResamplerOrder1 ( inChannelCount , sampleRate ) ; break ; case MED_QUALITY : ALOGV ( " Create ▁ cubic ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; resampler = new ( std :: nothrow ) AudioResamplerCubic ( inChannelCount , sampleRate ) ; break ; case HIGH_QUALITY : ALOGV ( " Create ▁ HIGH _ QUALITY ▁ sinc ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; ALOG_ASSERT ( false , " HIGH _ QUALITY ▁ isn ' t ▁ supported " ) ; break ; case VERY_HIGH_QUALITY : ALOGV ( " Create ▁ VERY _ HIGH _ QUALITY ▁ sinc ▁ Resampler ▁ = ▁ % d " , quality ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; ALOG_ASSERT ( false , " VERY _ HIGH _ QUALITY ▁ isn ' t ▁ supported " ) ; break ; } resampler -> init ( ) ; return resampler ; }
AudioResampler :: AudioResampler ( int inChannelCount , int32_t sampleRate , src_quality quality ) : mChannelCount ( inChannelCount ) , mSampleRate ( sampleRate ) , mInSampleRate ( sampleRate ) , mInputIndex ( 0 ) , mPhaseFraction ( 0 ) , mLocalTimeFreq ( 0 ) , mPTS ( AudioBufferProvider :: kInvalidPTS ) , mQuality ( quality ) { const int maxChannels = 2 ; if ( inChannelCount < 1 || inChannelCount > maxChannels ) { LOG_ALWAYS_FATAL ( " Unsupported ▁ sample ▁ format ▁ % d ▁ quality ▁ % d ▁ channels " , quality , inChannelCount ) ; } if ( sampleRate <= 0 ) { LOG_ALWAYS_FATAL ( " Unsupported ▁ sample ▁ rate ▁ % d ▁ Hz " , sampleRate ) ; } mVolume [ 0 ] = mVolume [ 1 ] = 0 ; mBuffer . frameCount = 0 ; }
AudioResampler :: ~ AudioResampler ( ) { pthread_mutex_lock ( & mutex ) ; src_quality quality = getQuality ( ) ; uint32_t deltaMHz = qualityMHz ( quality ) ; int32_t newMHz = currentMHz - deltaMHz ; ALOGV ( " resampler ▁ load ▁ % u ▁ - > ▁ % d ▁ MHz ▁ due ▁ to ▁ delta ▁ - % u ▁ MHz ▁ from ▁ quality ▁ % d " , currentMHz , newMHz , deltaMHz , quality ) ; LOG_ALWAYS_FATAL_IF ( newMHz < 0 , " negative ▁ resampler ▁ load ▁ % d ▁ MHz " , newMHz ) ; currentMHz = newMHz ; pthread_mutex_unlock ( & mutex ) ; }
void AudioResampler :: setSampleRate ( int32_t inSampleRate ) { mInSampleRate = inSampleRate ; mPhaseIncrement = ( uint32_t ) ( ( kPhaseMultiplier * inSampleRate ) / mSampleRate ) ; }
void AudioResampler :: setVolume ( float left , float right ) { mVolume [ 0 ] = u4_12_from_float ( clampFloatVol ( left ) ) ; mVolume [ 1 ] = u4_12_from_float ( clampFloatVol ( right ) ) ; }
void AudioResampler :: setLocalTimeFreq ( uint64_t freq ) { mLocalTimeFreq = freq ; }
void AudioResampler :: setPTS ( int64_t pts ) { mPTS = pts ; }
int64_t AudioResampler :: calculateOutputPTS ( int outputFrameIndex ) { if ( mPTS == AudioBufferProvider :: kInvalidPTS ) { return AudioBufferProvider :: kInvalidPTS ; } else { return mPTS + ( ( outputFrameIndex * mLocalTimeFreq ) / mSampleRate ) ; } }
void AudioResampler :: reset ( ) { mInputIndex = 0 ; mPhaseFraction = 0 ; mBuffer . frameCount = 0 ; }
size_t AudioResamplerOrder1 :: resample ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { switch ( mChannelCount ) { case 1 : return resampleMono16 ( out , outFrameCount , provider ) ; case 2 : return resampleStereo16 ( out , outFrameCount , provider ) ; default : LOG_ALWAYS_FATAL ( " invalid ▁ channel ▁ count : ▁ % d " , mChannelCount ) ; return 0 ; } }
size_t AudioResamplerOrder1 :: resampleStereo16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { int32_t vl = mVolume [ 0 ] ; int32_t vr = mVolume [ 1 ] ; size_t inputIndex = mInputIndex ; uint32_t phaseFraction = mPhaseFraction ; uint32_t phaseIncrement = mPhaseIncrement ; size_t outputIndex = 0 ; size_t outputSampleCount = outFrameCount * 2 ; size_t inFrameCount = getInFrameCountRequired ( outFrameCount ) ; while ( outputIndex < outputSampleCount ) { while ( mBuffer . frameCount == 0 ) { mBuffer . frameCount = inFrameCount ; provider -> getNextBuffer ( & mBuffer , calculateOutputPTS ( outputIndex / 2 ) ) ; if ( mBuffer . raw == NULL ) { goto resampleStereo16_exit ; } if ( mBuffer . frameCount > inputIndex ) break ; inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount * 2 - 2 ] ; mX0R = mBuffer . i16 [ mBuffer . frameCount * 2 - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } int16_t * in = mBuffer . i16 ; while ( inputIndex == 0 ) { out [ outputIndex ++ ] += vl * Interp ( mX0L , in [ 0 ] , phaseFraction ) ; out [ outputIndex ++ ] += vr * Interp ( mX0R , in [ 1 ] , phaseFraction ) ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; if ( outputIndex == outputSampleCount ) { break ; } } if ( inputIndex + 2 < mBuffer . frameCount ) { int32_t * maxOutPt ; int32_t maxInIdx ; maxOutPt = out + ( outputSampleCount - 2 ) ; maxInIdx = mBuffer . frameCount - 2 ; AsmStereo16Loop ( in , maxOutPt , maxInIdx , outputIndex , out , inputIndex , vl , vr , phaseFraction , phaseIncrement ) ; } while ( outputIndex < outputSampleCount && inputIndex < mBuffer . frameCount ) { out [ outputIndex ++ ] += vl * Interp ( in [ inputIndex * 2 - 2 ] , in [ inputIndex * 2 ] , phaseFraction ) ; out [ outputIndex ++ ] += vr * Interp ( in [ inputIndex * 2 - 1 ] , in [ inputIndex * 2 + 1 ] , phaseFraction ) ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; } if ( inputIndex >= mBuffer . frameCount ) { inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount * 2 - 2 ] ; mX0R = mBuffer . i16 [ mBuffer . frameCount * 2 - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } } resampleStereo16_exit : mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; return outputIndex / 2 ; }
size_t AudioResamplerOrder1 :: resampleMono16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { int32_t vl = mVolume [ 0 ] ; int32_t vr = mVolume [ 1 ] ; size_t inputIndex = mInputIndex ; uint32_t phaseFraction = mPhaseFraction ; uint32_t phaseIncrement = mPhaseIncrement ; size_t outputIndex = 0 ; size_t outputSampleCount = outFrameCount * 2 ; size_t inFrameCount = getInFrameCountRequired ( outFrameCount ) ; while ( outputIndex < outputSampleCount ) { while ( mBuffer . frameCount == 0 ) { mBuffer . frameCount = inFrameCount ; provider -> getNextBuffer ( & mBuffer , calculateOutputPTS ( outputIndex / 2 ) ) ; if ( mBuffer . raw == NULL ) { mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; goto resampleMono16_exit ; } if ( mBuffer . frameCount > inputIndex ) break ; inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } int16_t * in = mBuffer . i16 ; while ( inputIndex == 0 ) { int32_t sample = Interp ( mX0L , in [ 0 ] , phaseFraction ) ; out [ outputIndex ++ ] += vl * sample ; out [ outputIndex ++ ] += vr * sample ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; if ( outputIndex == outputSampleCount ) { break ; } } if ( inputIndex + 2 < mBuffer . frameCount ) { int32_t * maxOutPt ; int32_t maxInIdx ; maxOutPt = out + ( outputSampleCount - 2 ) ; maxInIdx = ( int32_t ) mBuffer . frameCount - 2 ; AsmMono16Loop ( in , maxOutPt , maxInIdx , outputIndex , out , inputIndex , vl , vr , phaseFraction , phaseIncrement ) ; } while ( outputIndex < outputSampleCount && inputIndex < mBuffer . frameCount ) { int32_t sample = Interp ( in [ inputIndex - 1 ] , in [ inputIndex ] , phaseFraction ) ; out [ outputIndex ++ ] += vl * sample ; out [ outputIndex ++ ] += vr * sample ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; } if ( inputIndex >= mBuffer . frameCount ) { inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } } resampleMono16_exit : mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; return outputIndex ; }
ComputeTempAsphere :: ComputeTempAsphere ( LAMMPS * lmp , int narg , char * * arg ) : Compute ( lmp , narg , arg ) { if ( narg < 3 ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; scalar_@@ flag = vector_flag = 1 ; size_vector = 6 ; extscalar = 0 ; extvector = 1 ; tempflag = 1 ; tempbias = 0 ; id_bias = NULL ; mode = ALL ; int iarg = 3 ; while ( iarg < narg ) { if ( strcmp ( arg [ iarg ] , " bias " ) == 0 ) { if ( iarg + 2 > narg ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; tempbias = 1 ; int n = strlen ( arg [ iarg + 1 ] ) + 1 ; id_bias = new char [ n ] ; strcpy ( id_bias , arg [ iarg + 1 ] ) ; iarg += 2 ; } else if ( strcmp ( arg [ iarg ] , " dof " ) == 0 ) { if ( iarg + 2 > narg ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; if ( strcmp ( arg [ iarg + 1 ] , " rotate " ) == 0 ) mode = ROTATE ; else if ( strcmp ( arg [ iarg + 1 ] , " all " ) == 0 ) mode = ALL ; else error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; iarg += 2 ; } else error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; } vector = new double [ 6 ] ; }
ComputeTempAsphere :: ~ ComputeTempAsphere ( ) { delete [ ] id_bias ; delete [ ] vector ; }
void ComputeTempAsphere :: init ( ) { avec = ( AtomVecEllipsoid * ) atom -> style_match ( " ellipsoid " ) ; if ( ! avec ) error -> all ( FLERR , " Compute ▁ temp / asphere ▁ requires ▁ atom ▁ style ▁ ellipsoid " ) ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) if ( ellipsoid [ i ] < 0 ) error -> one ( FLERR , " Compute ▁ temp / asphere ▁ requires ▁ extended ▁ particles " ) ; if ( tempbias ) { int i = modify -> find_compute ( id_bias ) ; if ( i < 0 ) error -> all ( FLERR , " Could ▁ not ▁ find ▁ compute ▁ ID ▁ for ▁ temperature ▁ bias " ) ; tbias = modify -> compute [ i ] ; if ( tbias -> tempflag == 0 ) error -> all ( FLERR , " Bias ▁ compute ▁ does ▁ not ▁ calculate ▁ temperature " ) ; if ( tbias -> tempbias == 0 ) error -> all ( FLERR , " Bias ▁ compute ▁ does ▁ not ▁ calculate ▁ a ▁ velocity ▁ bias " ) ; if ( tbias -> igroup != igroup ) error -> all ( FLERR , " Bias ▁ compute ▁ group ▁ does ▁ not ▁ match ▁ compute ▁ group " ) ; tbias -> init ( ) ; tbias -> setup ( ) ; if ( strcmp ( tbias -> style , " temp / region " ) == 0 ) tempbias = 2 ; else tempbias = 1 ; } }
void ComputeTempAsphere :: setup ( ) { fix_dof = - 1 ; dof_compute ( ) ; }
void ComputeTempAsphere :: dof_compute ( ) { if ( fix_dof ) adjust_dof_@@ fix ( ) ; double natoms = group -> count ( igroup ) ; int nper ; if ( domain -> dimension == 3 ) { if ( mode == ALL ) nper = 6 ; else nper = 3 ; } else { if ( mode == ALL ) nper = 3 ; else nper = 1 ; } dof = nper * natoms ; if ( tempbias == 1 ) { if ( mode == ALL ) dof -= tbias -> dof_remove ( - 1 ) * natoms ; } else if ( tempbias == 2 ) { int * mask = atom -> mask ; int nlocal = atom -> nlocal ; tbias -> dof_remove_pre ( ) ; int count = 0 ; for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) if ( tbias -> dof_remove ( i ) ) count ++ ; int count_all ; MPI_Allreduce ( & count , & count_all , 1 , MPI_INT , MPI_SUM , world ) ; dof -= nper * count_all ; } dof -= extra_dof + fix_dof ; if ( dof > 0 ) tfactor = force -> mvv2e / ( dof * force -> boltz ) ; else tfactor = 0.0 ; }
double ComputeTempAsphere :: compute_scalar ( ) { invoked_scalar = update -> ntimestep ; if ( tempbias ) { if ( tbias -> invoked_scalar != update -> ntimestep ) tbias -> compute_scalar ( ) ; tbias -> remove_bias_all ( ) ; } AtomVecEllipsoid :: Bonus * bonus = avec -> bonus ; double * * v = atom -> v ; double * * angmom = atom -> angmom ; double * rmass = atom -> rmass ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; double * shape , * quat ; double wbody [ 3 ] , inertia [ 3 ] ; double rot [ 3 ] [ 3 ] ; double t = 0.0 ; if ( mode == ALL ) { for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { t += ( v [ i ] [ 0 ] * v [ i ] [ 0 ] + v [ i ] [ 1 ] * v [ i ] [ 1 ] + v [ i ] [ 2 ] * v [ i ] [ 2 ] ) * rmass [ i ] ; shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * rmass [ i ] * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] + inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] + inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; } } else { for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * rmass [ i ] * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] + inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] + inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; } } if ( tempbias ) tbias -> restore_bias_all ( ) ; MPI_Allreduce ( & t , & scalar , 1 , MPI_DOUBLE , MPI_SUM , world ) ; if ( dynamic || tempbias == 2 ) dof_compute ( ) ; scalar *= tfactor ; return scalar ; }
void ComputeTempAsphere :: compute_vector ( ) { int i ; invoked_vector = update -> ntimestep ; if ( tempbias ) { if ( tbias -> invoked_vector != update -> ntimestep ) tbias -> compute_vector ( ) ; tbias -> remove_bias_all ( ) ; } AtomVecEllipsoid :: Bonus * bonus = avec -> bonus ; double * * v = atom -> v ; double * * angmom = atom -> angmom ; double * rmass = atom -> rmass ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; double * shape , * quat ; double wbody [ 3 ] , inertia [ 3 ] , t [ 6 ] ; double rot [ 3 ] [ 3 ] ; double massone ; for ( i = 0 ; i < 6 ; i ++ ) t [ i ] = 0.0 ; if ( mode == ALL ) { for ( i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { massone = rmass [ i ] ; t [ 0 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 0 ] ; t [ 1 ] += massone * v [ i ] [ 1 ] * v [ i ] [ 1 ] ; t [ 2 ] += massone * v [ i ] [ 2 ] * v [ i ] [ 2 ] ; t [ 3 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 1 ] ; t [ 4 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 2 ] ; t [ 5 ] += massone * v [ i ] [ 1 ] * v [ i ] [ 2 ] ; shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * massone * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t [ 0 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] ; t [ 1 ] += inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] ; t [ 2 ] += inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; t [ 3 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 1 ] ; t [ 4 ] += inertia [ 1 ] * wbody [ 0 ] * wbody [ 2 ] ; t [ 5 ] += inertia [ 2 ] * wbody [ 1 ] * wbody [ 2 ] ; } } else { for ( i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; massone = rmass [ i ] ; inertia [ 0 ] = INERTIA * massone * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t [ 0 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] ; t [ 1 ] += inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] ; t [ 2 ] += inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; t [ 3 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 1 ] ; t [ 4 ] += inertia [ 1 ] * wbody [ 0 ] * wbody [ 2 ] ; t [ 5 ] += inertia [ 2 ] * wbody [ 1 ] * wbody [ 2 ] ; } } if ( tempbias ) tbias -> restore_bias_all ( ) ; MPI_Allreduce ( t , vector , 6 , MPI_DOUBLE , MPI_SUM , world ) ; for ( i = 0 ; i < 6 ; i ++ ) vector [ i ] *= force -> mvv2e ; }
void ComputeTempAsphere :: remove_bias ( int i , double * v ) { if ( tbias ) tbias -> remove_bias ( i , v ) ; }
void ComputeTempAsphere :: restore_bias ( int i , double * v ) { if ( tbias ) tbias -> restore_bias ( i , v ) ; }
wxMacPortSaver :: wxMacPortSaver ( GrafPtr port ) { :: GetPort ( & m_port ) ; :: SetPort ( port ) ; }
wxMacPortSaver :: ~ wxMacPortSaver ( ) { :: SetPort ( m_port ) ; }
wxMacWindowClipper :: wxMacWindowClipper ( const wxWindow * win ) : wxMacPortSaver ( ( GrafPtr ) GetWindowPort ( ( WindowRef ) win -> MacGetTopLevelWindowRef ( ) ) ) { m_newPort = ( GrafPtr ) GetWindowPort ( ( WindowRef ) win -> MacGetTopLevelWindowRef ( ) ) ; m_formerClip = NewRgn ( ) ; m_newClip = NewRgn ( ) ; GetClip ( m_formerClip ) ; if ( win ) { if ( win -> GetPeer ( ) ) { int x = 0 , y = 0 ; win -> MacWindow@@ ToRootWindow ( & x , & y ) ; HIShape@@ GetAsQDRgn ( ( ( wxWindow * ) win ) -> MacGetVisible@@ Region ( true ) . GetWXHRG@@ N ( ) , m_newClip ) ; if ( ! EmptyRgn ( m_newClip ) ) OffsetRgn ( m_newClip , x , y ) ; } SetClip ( m_newClip ) ; } }
wxMacWindowClipper :: ~ wxMacWindowClipper ( ) { SetPort ( m_newPort ) ; SetClip ( m_formerClip ) ; DisposeRgn ( m_newClip ) ; DisposeRgn ( m_formerClip ) ; }
wxWidgetImplType * wxWidgetImpl :: CreateText@@ Control ( wxTextCtrl * wxpeer , wxWindowMac * WXUNUSED ( parent ) , wxWindowID WXUNUSED ( id ) , const wxString & str , const wxPoint & pos , const wxSize & size , long style , long WXUNUSED ( extraStyle ) ) { return new wxMacMLTEHIViewControl ( wxpeer , str , pos , size , style ) ; }
wxMacUnicodeTextControl :: wxMacUnicodeTextControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) : wxMacControl ( wxPeer ) , wxTextWidgetImpl ( wxPeer ) { m_font = wxPeer -> GetFont ( ) ; m_windowStyle = style ; m_selection . selStart = m_selection . selEnd = 0 ; Rect bounds = wxMacGetBoundsForControl ( wxPeer , pos , size ) ; wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; m_valueTag = kControlEditTextCFStringTag ; Boolean isPassword = ( m_windowStyle & wxTE_PASSWORD ) != 0 ; if ( isPassword ) { m_valueTag = kControlEditTextPassword@@ CFStringTag ; } OSStatus err = CreateEdit@@ UnicodeTextControl ( MAC_WXHWND ( wxPeer -> MacGetTopLevelWindowRef ( ) ) , & bounds , cf , isPassword , NULL , & m_controlRef ) ; verify_noerr ( err ) ; if ( ! ( m_windowStyle & wxTE_MULTILINE ) ) SetData < Boolean > ( kControlEditTextPart , kControlEditTextSingleLine@@ Tag , true ) ; InstallEventHandlers ( ) ; }
void wxMacUnicodeTextControl :: InstallEventHandlers ( ) { :: InstallControlEventHandler ( m_controlRef , GetwxMacUnicodeTextControlEventHandlerUPP ( ) , GetEventTypeCount ( unicodeTextControlEventList ) , unicodeTextControlEventList , this , ( EventHandlerRef * ) & m_macTextCtrlEventHandler ) ; }
wxMacUnicodeTextControl :: ~ wxMacUnicodeTextControl ( ) { :: RemoveEventHandler ( ( EventHandlerRef ) m_macTextCtrlEventHandler ) ; }
void wxMacUnicodeTextControl :: VisibilityChanged ( bool shown ) { if ( ! ( m_windowStyle & wxTE_MULTILINE ) && shown ) { ControlEditTextSelectionRec sel ; CFStringRef value = NULL ; verify_noerr ( GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; verify_noerr ( GetData < CFStringRef > ( 0 , m_valueTag , & value ) ) ; verify_noerr ( SetData < CFStringRef > ( 0 , m_valueTag , & value ) ) ; verify_noerr ( SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; CFRelease ( value ) ; } }
void wxMacMLTEControl :: SetStringValue ( const wxString & str ) { wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; { wxMacWindowClipper c ( GetWXPeer ( ) ) ; { wxMacEditHelper help ( m_txn ) ; SetTXNData ( st , kTXNStartOffset , kTXNEndOffset ) ; } TXNSetSelection ( m_txn , 0 , 0 ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; } }
TXNFrameOptions wxMacMLTEControl :: FrameOptionsFromWXStyle ( long wxStyle ) { TXNFrameOptions frameOptions = kTXNDontDrawCare@@ tWhenInactiveMask ; frameOptions |= kTXNDoFontSubstitution@@ Mask ; if ( ! ( wxStyle & wxTE_NOHID@@ ESEL ) ) frameOptions |= kTXNDontDrawSelectionWhenInactiveMask ; if ( wxStyle & ( wxHSCROLL | wxTE_DONTWRAP ) ) frameOptions |= kTXNWantHScrollBarMask ; if ( wxStyle & wxTE_MULTILINE ) { if ( ! ( wxStyle & wxTE_DONTWRAP ) ) frameOptions |= kTXNAlways@@ WrapAtView@@ EdgeMask ; if ( ! ( wxStyle & wxTE_NO_VSCROLL ) ) { frameOptions |= kTXNWantVScrollBarMask ; } } else { frameOptions |= kTXNSingleLineOnlyMask ; } return frameOptions ; }
void wxMacMLTEControl :: AdjustCreationAttributes ( const wxColour & background , bool WXUNUSED ( visible ) ) { TXNControlTag iControlTags [ ] = { kTXNDoFontSubstitution , kTXNWord@@ WrapStateTag , } ; TXNControlData iControlData [ ] = { { true } , { kTXNNoAutoWrap } , } ; int toptag = WXSIZEOF ( iControlTags ) ; if ( m_windowStyle & wxTE_MULTILINE ) { iControlData [ 1 ] . uValue = ( m_windowStyle & wxTE_DONTWRAP ) ? kTXNNoAutoWrap : kTXNAutoWrap ; } OSStatus err = TXNSetTXNObjectControls ( m_txn , false , toptag , iControlTags , iControlData ) ; verify_noerr ( err ) ; Str255 fontName ; SInt16 fontSize ; Style fontStyle ; GetThemeFont ( kThemeSystemFont , GetApplicationScript ( ) , fontName , & fontSize , & fontStyle ) ; TXNTypeAttributes typeAttr [ ] = { { kTXNQDFontNameAttribute , kTXNQDFontNameAttributeSize , { ( void * ) fontName } } , { kTXNQDFontSizeAttribute , kTXNFont@@ SizeAttributeSize , { ( void * ) ( fontSize << 16 ) } } , { kTXNQDFontStyleAttribute , kTXNQDFontStyleAttributeSize , { ( void * ) normal } } , } ; err = TXNSetTypeAttributes ( m_txn , WXSIZEOF ( typeAttr ) , typeAttr , kTXNStartOffset , kTXNEndOffset ) ; verify_noerr ( err ) ; if ( m_windowStyle & wxTE_PASSWORD ) { UniChar c = 0x00A5 ; err = TXNEcho@@ Mode ( m_txn , c , 0 , true ) ; verify_noerr ( err ) ; } TXNBackground tback ; tback . bgType = kTXNBackgroundTypeRGB ; background . GetRGBColor ( & tback . bg . color ) ; TXNSetBackground ( m_txn , & tback ) ; TXNCommandEventSupportOptions options ; if ( TXNGetCommandEventSupport ( m_txn , & options ) == noErr ) { options |= kTXNSupportEditCommandProcessing | kTXNSupportEditCommandUpdating | kTXNSupportFontCommandProcessing | kTXNSupportFontCommandUpdating ; bool checkSpelling = false ; if ( ! ( m_windowStyle & wxTE_READONLY ) ) { if ( wxSystemOptions :: HasOption ( wxMAC_TEXTCONTROL_USE_SPELL_CHECKER ) && ( wxSystemOptions :: GetOptionInt ( wxMAC_TEXTCONTROL_USE_SPELL_CHECKER ) == 1 ) ) { checkSpelling = true ; } } if ( checkSpelling ) options |= kTXNSupportSpellCheckCommandProcessing | kTXNSupportSpellCheckCommandUpdating ; TXNSetCommandEventSupport ( m_txn , options ) ; } }
void wxMacMLTEControl :: SetBackgroundColour ( const wxColour & col ) { TXNBackground tback ; tback . bgType = kTXNBackgroundTypeRGB ; col . GetRGBColor ( & tback . bg . color ) ; TXNSetBackground ( m_txn , & tback ) ; }
void wxMacMLTEControl :: TXNSetAttribute ( const wxTextAttr & style , long from , long to ) { TXNTypeAttributes typeAttr [ 4 ] ; RGBColor color ; size_t typeAttrCount = 0 ; TXNMargins margins ; TXNControlTag controlTags [ 4 ] ; TXNControlData controlData [ 4 ] ; size_t controlAttrCount = 0 ; TXNTab * tabs = NULL ; bool relayout = false ; wxFont font ; if ( style . HasFont ( ) ) { wxASSERT ( typeAttrCount < WXSIZEOF ( typeAttr ) ) ; font = style . GetFont ( ) ; typeAttr [ typeAttrCount ] . tag = kTXNATSUIStyle ; typeAttr [ typeAttrCount ] . size = kTXNATSUIStyleSize ; typeAttr [ typeAttrCount ] . data . dataPtr = font . MacGetATSU@@ Style ( ) ; typeAttrCount ++ ; } if ( style . HasTextColour ( ) ) { wxASSERT ( typeAttrCount < WXSIZEOF ( typeAttr ) ) ; style . GetTextColour ( ) . GetRGBColor ( & color ) ; typeAttr [ typeAttrCount ] . tag = kTXNQDFontColorAttribute ; typeAttr [ typeAttrCount ] . size = kTXNQDFontColorAttributeSize ; typeAttr [ typeAttrCount ] . data . dataPtr = ( void * ) & color ; typeAttrCount ++ ; } if ( style . HasAlignment ( ) ) { wxASSERT ( controlAttrCount < WXSIZEOF ( controlTags ) ) ; SInt32 align ; switch ( style . GetAlignment ( ) ) { case wxTEXT_ALIGNMENT_LEFT : align = kTXNFlushLeft ; break ; case wxTEXT_ALIGNMENT_CENTR@@ E : align = kTXNCenter ; break ; case wxTEXT_ALIGNMENT_RIGHT : align = kTXNFlushRight ; break ; case wxTEXT_ALIGNMENT_JUS@@ TIFI@@ ED : align = kTXNFull@@ Just ; break ; default : case wxTEXT_ALIGNMENT_DEFAULT : align = kTXNFlushDefault ; break ; } controlTags [ controlAttrCount ] = kTXNJust@@ ificationTag ; controlData [ controlAttrCount ] . sValue = align ; controlAttrCount ++ ; } if ( style . HasLeftIndent ( ) || style . HasRightIndent ( ) ) { wxASSERT ( controlAttrCount < WXSIZEOF ( controlTags ) ) ; controlTags [ controlAttrCount ] = kTXNMarg@@ insTag ; controlData [ controlAttrCount ] . margins@@ Ptr = & margins ; verify_noerr ( TXNGetTXNObjectControls ( m_txn , 1 , & controlTags [ controlAttrCount ] , & controlData [ controlAttrCount ] ) ) ; if ( style . HasLeftIndent ( ) ) { margins . leftMargin = wxConvertToTXN ( style . GetLeftIndent ( ) ) ; } if ( style . HasRightIndent ( ) ) { margins . rightMargin = wxConvertToTXN ( style . GetRightIndent ( ) ) ; } controlAttrCount ++ ; } if ( style . HasTabs ( ) ) { const wxArrayInt & tabarray = style . GetTabs ( ) ; controlTags [ controlAttrCount ] = kTXNTab@@ SettingsTag ; if ( tabarray . size ( ) > 0 ) controlData [ controlAttrCount ] . tabValue . value = wxConvertToTXN ( tabarray [ 0 ] ) ; else controlData [ controlAttrCount ] . tabValue . value = 72 ; controlData [ controlAttrCount ] . tabValue . tabType = kTXNLeft@@ Tab ; controlAttrCount ++ ; } if ( controlAttrCount > 0 ) { verify_noerr ( TXNSetTXNObjectControls ( m_txn , false , controlAttrCount , controlTags , controlData ) ) ; relayout = true ; } if ( typeAttrCount > 0 ) { verify_noerr ( TXNSetTypeAttributes ( m_txn , typeAttrCount , typeAttr , from , to ) ) ; if ( from != to ) relayout = true ; } if ( tabs != NULL ) { delete [ ] tabs ; } if ( relayout ) { TXNRecalc@@ TextLayout ( m_txn ) ; } }
void wxMacMLTEControl :: SetFont ( const wxFont & font , const wxColour & foreground , long WXUNUSED ( windowStyle ) , bool WXUNUSED ( ignoreBlack ) ) { wxMacEditHelper help ( m_txn ) ; TXNSetAttribute ( wxTextAttr ( foreground , wxNullColour , font ) , kTXNStartOffset , kTXNEndOffset ) ; }
void wxMacMLTEControl :: SetStyle ( long start , long end , const wxTextAttr & style ) { wxMacEditHelper help ( m_txn ) ; TXNSetAttribute ( style , start , end ) ; }
void wxMacMLTEControl :: Copy ( ) { TXNCopy ( m_txn ) ; }
void wxMacMLTEControl :: Cut ( ) { TXNCut ( m_txn ) ; }
void wxMacMLTEControl :: Paste ( ) { TXNPaste ( m_txn ) ; }
void wxMacMLTEControl :: SetEditable ( bool editable ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; TXNControlData data [ ] = { { editable ? kTXNReadWrite : kTXNReadOnly } } ; TXNSetTXNObjectControls ( m_txn , false , WXSIZEOF ( tag ) , tag , data ) ; }
void wxMacMLTEControl :: Replace ( long from , long to , const wxString & str ) { wxString value = str ; wxMacConvertNewlines10To13 ( & value ) ; wxMacEditHelper help ( m_txn ) ; wxMacWindowClipper c ( GetWXPeer ( ) ) ; TXNSetSelection ( m_txn , from , to == - 1 ? kTXNEndOffset : to ) ; TXNClear ( m_txn ) ; SetTXNData ( value , kTXNUseCurrentSelection , kTXNUseCurrentSelection ) ; }
void wxMacMLTEControl :: Remove ( long from , long to ) { wxMacWindowClipper c ( GetWXPeer ( ) ) ; wxMacEditHelper help ( m_txn ) ; TXNSetSelection ( m_txn , from , to ) ; TXNClear ( m_txn ) ; }
void wxMacMLTEControl :: SetSelection ( long from , long to ) { wxMacWindowClipper c ( GetWXPeer ( ) ) ; if ( ( from == - 1 ) && ( to == - 1 ) ) TXNSelect@@ All ( m_txn ) ; else TXNSetSelection ( m_txn , from , to == - 1 ? kTXNEndOffset : to ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; }
void wxMacMLTEControl :: WriteText ( const wxString & str ) { if ( ! wxIsMainThread ( ) ) { wxMacMPRemoteGUICall < wxTextCtrl , wxString > ( ( wxTextCtrl * ) GetWXPeer ( ) , & wxTextCtrl :: WriteText , str ) ; return ; } wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; long start , end , dummy ; GetSelection ( & start , & dummy ) ; wxMacWindowClipper c ( GetWXPeer ( ) ) ; { wxMacEditHelper helper ( m_txn ) ; SetTXNData ( st , kTXNUseCurrentSelection , kTXNUseCurrentSelection ) ; } GetSelection ( & dummy , & end ) ; }
void wxMacMLTEControl :: Clear ( ) { wxMacWindowClipper c ( GetWXPeer ( ) ) ; wxMacEditHelper st ( m_txn ) ; TXNSetSelection ( m_txn , kTXNStartOffset , kTXNEndOffset ) ; TXNClear ( m_txn ) ; }
void wxMacMLTEControl :: Undo ( ) { TXNUndo ( m_txn ) ; }
void wxMacMLTEControl :: Redo ( ) { TXNRedo ( m_txn ) ; }
void TestIDNA :: debug ( const UChar * src , int32_t srcLength , int32_t options ) { UParseError parseError ; UErrorCode transStatus = U_ZERO_ERROR ; UErrorCode prepStatus = U_ZERO_ERROR ; NamePrepTransform * trans = NamePrepTransform :: createInstance ( parseError , transStatus ) ; int32_t prepOptions = ( ( ( options & UIDNA_ALLOW_UNASSIGNED ) != 0 ) ? USPREP_ALLOW_UNASSIGNED : 0 ) ; LocalUString@@ PrepProfile@@ Pointer prep ( usprep_openByType ( USPREP_RFC@@ 3491_NAMEP@@ REP , & prepStatus ) ) ; UChar * transOut = NULL , * prepOut = NULL ; int32_t transOutLength = 0 , prepOutLength = 0 ; transOutLength = trans -> process ( src , srcLength , transOut , 0 , prepOptions > 0 , & parseError , transStatus ) ; if ( transStatus == U_BUFFER_OVERFLOW_ERROR ) { transStatus = U_ZERO_ERROR ; transOut = ( UChar * ) malloc ( U_SIZEOF_UCHAR * transOutLength ) ; transOutLength = trans -> process ( src , srcLength , transOut , transOutLength , prepOptions > 0 , & parseError , transStatus ) ; } prepOutLength = usprep_prepare ( prep . getAlias ( ) , src , srcLength , prepOut , 0 , prepOptions , & parseError , & prepStatus ) ; if ( prepStatus == U_BUFFER_OVERFLOW_ERROR ) { prepStatus = U_ZERO_ERROR ; prepOut = ( UChar * ) malloc ( U_SIZEOF_UCHAR * prepOutLength ) ; prepOutLength = usprep_prepare ( prep . getAlias ( ) , src , srcLength , prepOut , prepOutLength , prepOptions , & parseError , & prepStatus ) ; } if ( UnicodeString ( transOut , transOutLength ) != UnicodeString ( prepOut , prepOutLength ) ) { errln ( " Failed . ▁ Expected : ▁ " + prettify ( UnicodeString ( transOut , transOutLength ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( prepOut , prepOutLength ) ) ) ; } free ( transOut ) ; free ( prepOut ) ; delete trans ; }
void TestIDNA :: testAPI ( const UChar * src , const UChar * expected , const char * testName , UBool useSTD3ASCIIRules , UErrorCode expectedStatus , UBool doCompare , UBool testUnassigned , TestFunc func , UBool testSTD3ASCIIRules ) { UErrorCode status = U_ZERO_ERROR ; UChar destStack [ MAX_DEST_SIZE ] ; int32_t destLen = 0 ; UChar * dest = NULL ; int32_t expectedLen = ( expected != NULL ) ? u_strlen ( expected ) : 0 ; int32_t options = ( useSTD3ASCIIRules == TRUE ) ? UIDNA_USE_STD3_RULES : UIDNA_DEFAULT ; UParseError parseError ; int32_t tSrcLen = 0 ; UChar * tSrc = NULL ; if ( src != NULL ) { tSrcLen = u_strlen ( src ) ; tSrc = ( UChar * ) malloc ( U_SIZEOF_UCHAR * tSrcLen ) ; memcpy ( tSrc , src , tSrcLen * U_SIZEOF_UCHAR ) ; } destLen = func ( src , - 1 , NULL , 0 , options , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options , & parseError , & status ) ; if ( U_SUCCESS ( status ) && expectedStatus != U_IDNA_STD3_ASCII_RULES_ERROR && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source . ▁ Expected ▁ : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( dest , destLen ) ) ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus ) { errcheckln ( status , " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; free ( tSrc ) ; return ; } if ( testUnassigned ) { status = U_ZERO_ERROR ; destLen = func ( src , - 1 , NULL , 0 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ " + prettify ( src ) + " ▁ with ▁ both ▁ options ▁ set . ▁ Expected : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) + " Got : ▁ " + prettify ( UnicodeString ( dest , destLen ) ) ) ; debug ( src , - 1 , options | UIDNA_ALLOW_UNASSIGNED ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } status = U_ZERO_ERROR ; destLen = func ( tSrc , tSrcLen , NULL , 0 , options , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } if ( testUnassigned ) { status = U_ZERO_ERROR ; destLen = func ( tSrc , tSrcLen , NULL , 0 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length ▁ and ▁ both ▁ options ▁ set . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } status = U_ZERO_ERROR ; if ( testSTD3ASCIIRules == TRUE ) { destLen = func ( src , - 1 , NULL , 0 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ both ▁ options ▁ set . ▁ Expected : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } status = U_ZERO_ERROR ; destLen = func ( tSrc , tSrcLen , NULL , 0 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length ▁ and ▁ both ▁ options ▁ set . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } free ( tSrc ) ; }
void TestIDNA :: testCompare ( const UChar * s1 , int32_t s1Len , const UChar * s2 , int32_t s2Len , const char * testName , CompareFunc func , UBool isEqual ) { UErrorCode status = U_ZERO_ERROR ; int32_t retVal = func ( s1 , - 1 , s2 , - 1 , UIDNA_DEFAULT , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ null ▁ termniated ▁ strings . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , - 1 , s2 , - 1 , UIDNA_ALLOW_UNASSIGNED , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ null ▁ termniated ▁ strings ▁ with ▁ options ▁ set . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ and ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , s1Len , s2 , s2Len , UIDNA_DEFAULT , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ string ▁ length . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ with ▁ string ▁ length . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , s1Len , s2 , s2Len , UIDNA_ALLOW_UNASSIGNED , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ string ▁ length ▁ and ▁ options ▁ set . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ with ▁ string ▁ length ▁ and ▁ options ▁ set . ▁ Error : ▁ % s " , u_errorName ( status ) , testName ) ; } }
void TestIDNA :: testToASCII ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testAPI ( unicodeIn [ i ] , buf , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; } }
void TestIDNA :: testToUnicode ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( asciiIn ) / sizeof ( asciiIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testAPI ( buf , unicodeIn [ i ] , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; } }
void TestIDNA :: testIDNToUnicode ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; UErrorCode status = U_ZERO_ERROR ; int32_t bufLen = 0 ; UParseError parseError ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( domainNames ) / sizeof ( domainNames [ 0 ] ) ) ; i ++ ) { bufLen = ( int32_t ) strlen ( domainNames [ i ] ) ; bufLen = u_unescape ( domainNames [ i ] , buf , bufLen + 1 ) ; func ( buf , bufLen , expected , MAX_DEST_SIZE , UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s " , testName , i , u_errorName ( status ) ) ; break ; } testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s ▁ \n " , testName , i , u_errorName ( status ) ) ; break ; } } }
void TestIDNA :: testIDNToASCII ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; UErrorCode status = U_ZERO_ERROR ; int32_t bufLen = 0 ; UParseError parseError ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( domainNames ) / sizeof ( domainNames [ 0 ] ) ) ; i ++ ) { bufLen = ( int32_t ) strlen ( domainNames [ i ] ) ; bufLen = u_unescape ( domainNames [ i ] , buf , bufLen + 1 ) ; func ( buf , bufLen , expected , MAX_DEST_SIZE , UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s " , testName , i , u_errorName ( status ) ) ; break ; } testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , FALSE , TRUE , func ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s ▁ \n " , testName , i , u_errorName ( status ) ) ; break ; } } }
void TestIDNA :: testCompare ( const char * testName , CompareFunc func ) { int32_t i ; UChar www [ ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UChar com [ ] = { 0x002E , 0x0043 , 0x004F , 0x004D , 0x0000 } ; UChar buf [ MAX_DEST_SIZE ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UnicodeString source ( www ) , uni0 ( www ) , uni1 ( www ) , ascii0 ( www ) , ascii1 ( www ) ; uni0 . append ( unicodeIn [ 0 ] ) ; uni0 . append ( com ) ; uni0 . append ( ( UChar ) 0x0000 ) ; uni1 . append ( unicodeIn [ 1 ] ) ; uni1 . append ( com ) ; uni1 . append ( ( UChar ) 0x0000 ) ; ascii0 . append ( asciiIn [ 0 ] ) ; ascii0 . append ( com ) ; ascii0 . append ( ( UChar ) 0x0000 ) ; ascii1 . append ( asciiIn [ 1 ] ) ; ascii1 . append ( com ) ; ascii1 . append ( ( UChar ) 0x0000 ) ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf + 4 , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; u_strcat ( buf , com ) ; source . truncate ( 4 ) ; source . append ( unicodeIn [ i ] ) ; source . append ( com ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; int32_t srcLen = u_strlen ( src ) ; testCompare ( src , srcLen , src , srcLen , testName , func , TRUE ) ; testCompare ( src , srcLen , buf , u_strlen ( buf ) , testName , func , TRUE ) ; if ( i == 0 ) { testCompare ( src , srcLen , uni1 . getBuffer ( ) , uni1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , uni0 . getBuffer ( ) , uni0 . length ( ) - 1 , testName , func , FALSE ) ; } if ( i == 0 ) { testCompare ( src , srcLen , ascii1 . getBuffer ( ) , ascii1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , ascii0 . getBuffer ( ) , ascii0 . length ( ) - 1 , testName , func , FALSE ) ; } } }
void TestIDNA :: testErrorCases ( const char * IDNToASCIIName , TestFunc IDNToASCII , const char * IDNToUnicodeName , TestFunc IDNToUnicode ) { UChar buf [ MAX_DEST_SIZE ] ; int32_t bufLen = 0 ; for ( int32_t i = 0 ; i < ( int32_t ) ( sizeof ( errorCases ) / sizeof ( errorCases [ 0 ] ) ) ; i ++ ) { ErrorCases errorCase = errorCases [ i ] ; UChar * src = NULL ; if ( errorCase . ascii != NULL ) { bufLen = ( int32_t ) strlen ( errorCase . ascii ) ; u_charsToUChars ( errorCase . ascii , buf , bufLen + 1 ) ; } else { bufLen = 1 ; memset ( buf , 0 , U_SIZEOF_UCHAR * MAX_DEST_SIZE ) ; } if ( errorCase . unicode [ 0 ] != 0 ) { src = errorCase . unicode ; } testAPI ( src , buf , IDNToASCIIName , errorCase . useSTD3ASCIIRules , errorCase . expected , TRUE , TRUE , IDNToASCII ) ; if ( errorCase . testLabel == TRUE ) { testAPI ( src , buf , IDNToASCIIName , errorCase . useSTD3ASCIIRules , errorCase . expected , FALSE , TRUE , IDNToASCII ) ; } if ( errorCase . testToUnicode == TRUE ) { testAPI ( ( src == NULL ) ? NULL : buf , src , IDNToUnicodeName , errorCase . useSTD3ASCIIRules , errorCase . expected , TRUE , TRUE , IDNToUnicode ) ; } } }
void TestIDNA :: testChaining ( const UChar * src , int32_t numIterations , const char * testName , UBool useSTD3ASCIIRules , UBool caseInsensitive , TestFunc func ) { UChar even [ MAX_DEST_SIZE ] ; UChar odd [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; int32_t i = 0 , evenLen = 0 , oddLen = 0 , expectedLen = 0 ; UErrorCode status = U_ZERO_ERROR ; int32_t srcLen = u_strlen ( src ) ; int32_t options = ( useSTD3ASCIIRules == TRUE ) ? UIDNA_USE_STD3_RULES : UIDNA_DEFAULT ; UParseError parseError ; expectedLen = func ( src , - 1 , expected , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , - 1 , even , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , - 1 , odd , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; } } status = U_ZERO_ERROR ; expectedLen = func ( src , - 1 , expected , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , - 1 , even , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , - 1 , odd , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; } } status = U_ZERO_ERROR ; expectedLen = func ( src , srcLen , expected , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , oddLen , even , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , evenLen , odd , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ source ▁ with ▁ source ▁ length ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ source ▁ with ▁ source ▁ length ▁ failed \n " , testName ) ; } } status = U_ZERO_ERROR ; expectedLen = func ( src , srcLen , expected , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , oddLen , even , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , evenLen , odd , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed \n " , testName ) ; } } }
void TestIDNA :: testChaining ( const char * toASCIIName , TestFunc toASCII , const char * toUnicodeName , TestFunc toUnicode ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( asciiIn ) / sizeof ( asciiIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testChaining ( buf , 5 , toUnicodeName , FALSE , FALSE , toUnicode ) ; } for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { testChaining ( unicodeIn [ i ] , 5 , toASCIIName , FALSE , TRUE , toASCII ) ; } }
void TestIDNA :: testRootLabelSeparator ( const char * testName , CompareFunc func , const char * IDNToASCIIName , TestFunc IDNToASCII , const char * IDNToUnicodeName , TestFunc IDNToUnicode ) { int32_t i ; UChar www [ ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UChar com [ ] = { 0x002E , 0x0043 , 0x004F , 0x004D , 0x002E , 0x0000 } ; UChar buf [ MAX_DEST_SIZE ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UnicodeString source ( www ) , uni0 ( www ) , uni1 ( www ) , ascii0 ( www ) , ascii1 ( www ) ; uni0 . append ( unicodeIn [ 0 ] ) ; uni0 . append ( com ) ; uni0 . append ( ( UChar ) 0x0000 ) ; uni1 . append ( unicodeIn [ 1 ] ) ; uni1 . append ( com ) ; uni1 . append ( ( UChar ) 0x0000 ) ; ascii0 . append ( asciiIn [ 0 ] ) ; ascii0 . append ( com ) ; ascii0 . append ( ( UChar ) 0x0000 ) ; ascii1 . append ( asciiIn [ 1 ] ) ; ascii1 . append ( com ) ; ascii1 . append ( ( UChar ) 0x0000 ) ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf + 4 , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; u_strcat ( buf , com ) ; source . truncate ( 4 ) ; source . append ( unicodeIn [ i ] ) ; source . append ( com ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; int32_t srcLen = u_strlen ( src ) ; testCompare ( src , srcLen , buf , u_strlen ( buf ) , testName , func , TRUE ) ; testCompare ( src , srcLen , src , srcLen , testName , func , TRUE ) ; testAPI ( src , buf , IDNToASCIIName , FALSE , U_ZERO_ERROR , TRUE , TRUE , IDNToASCII ) ; testAPI ( buf , src , IDNToUnicodeName , FALSE , U_ZERO_ERROR , TRUE , TRUE , IDNToUnicode ) ; if ( i == 0 ) { testCompare ( src , srcLen , uni1 . getBuffer ( ) , uni1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , uni0 . getBuffer ( ) , uni0 . length ( ) - 1 , testName , func , FALSE ) ; } if ( i == 0 ) { testCompare ( src , srcLen , ascii1 . getBuffer ( ) , ascii1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , ascii0 . getBuffer ( ) , ascii0 . length ( ) - 1 , testName , func , FALSE ) ; } } }
void TestIDNA :: runIndexedTest ( int32_t index , UBool exec , const char * & name , char * par ) { if ( exec ) logln ( ( UnicodeString ) " TestSuite ▁ IDNA ▁ API ▁ " ) ; switch ( index ) { case 0 : name = " TestToASCII " ; if ( exec ) TestToASCII ( ) ; break ; case 1 : name = " TestToUnicode " ; if ( exec ) TestToUnicode ( ) ; break ; case 2 : name = " TestIDNToASCII " ; if ( exec ) TestIDNToASCII ( ) ; break ; case 3 : name = " TestIDNToUnicode " ; if ( exec ) TestIDNToUnicode ( ) ; break ; case 4 : name = " TestCompare " ; if ( exec ) TestCompare ( ) ; break ; case 5 : name = " TestErrorCases " ; if ( exec ) TestErrorCases ( ) ; break ; case 6 : name = " TestChaining " ; if ( exec ) TestChaining ( ) ; break ; case 7 : name = " TestRootLabelSeparator " ; if ( exec ) TestRootLabelSeparator ( ) ; break ; case 8 : name = " TestCompareReferenceImpl " ; if ( exec ) TestCompareReferenceImpl ( ) ; break ; case 9 : name = " TestDataFile " ; if ( exec ) TestDataFile ( ) ; break ; UCONFIG_NO_FILE_IO && ! UCONFIG_NO_LEGACY_CON@@ VERSION case 10 : name = " TestRefIDNA " ; if ( exec ) TestRefIDNA ( ) ; break ; case 11 : name = " TestIDNAMonkeyTest " ; if ( exec ) TestIDNAMonkeyTest ( ) ; break ; case 10 : case 11 : name = " skip " ; break ; case 12 : { name = " TestConformance@@ TestVector@@ s " ; if ( exec ) { logln ( " TestSuite ▁ IDNA ▁ conf - - - - " ) ; logln ( ) ; Idna@@ ConfTest test ; callTest ( test , par ) ; } break ; } case 13 : name = " UTS46Test " ; if ( exec ) { logln ( " TestSuite ▁ UTS46Test - - - " ) ; logln ( ) ; LocalPointer < IntlTest > test ( createUTS46Test ( ) ) ; callTest ( * test , par ) ; } break ; default : name = " " ; break ; } }
void TestIDNA :: TestToASCII ( ) { testToASCII ( " uidna _ toASCII " , uidna_toASCII ) ; }
void TestIDNA :: TestToUnicode ( ) { testToUnicode ( " uidna _ toUnicode " , uidna_toUnicode ) ; }
void TestIDNA :: TestIDNToASCII ( ) { testIDNToASCII ( " uidna _ IDNToASCII " , uidna_IDNToASCII ) ; }
void TestIDNA :: TestIDNToUnicode ( ) { testIDNToUnicode ( " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; }
void TestIDNA :: TestCompare ( ) { testCompare ( " uidna _ compare " , uidna_compare ) ; }
void TestIDNA :: TestErrorCases ( ) { testErrorCases ( " uidna _ IDNToASCII " , uidna_IDNToASCII , " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; }
void TestIDNA :: TestRootLabelSeparator ( ) { testRootLabelSeparator ( " uidna _ compare " , uidna_compare , " uidna _ IDNToASCII " , uidna_IDNToASCII , " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; }
void TestIDNA :: TestChaining ( ) { testChaining ( " uidna _ toASCII " , uidna_toASCII , " uidna _ toUnicode " , uidna_toUnicode ) ; }
UnicodeString TestIDNA :: testCompareReferenceImpl ( UnicodeString & src , TestFunc refIDNA , const char * refIDNAName , TestFunc uIDNA , const char * uIDNAName , int32_t options ) { const UChar * srcUChars = src . getBuffer ( ) ; UChar exp [ MAX_DEST_SIZE ] = { 0 } ; int32_t expCap = MAX_DEST_SIZE , expLen = 0 ; UErrorCode expStatus = U_ZERO_ERROR ; UParseError parseError ; logln ( " Comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ for ▁ input : ▁ " + prettify ( srcUChars ) ) ; expLen = refIDNA ( srcUChars , src . length ( ) - 1 , exp , expCap , options , & parseError , & expStatus ) ; UChar got [ MAX_DEST_SIZE ] = { 0 } ; int32_t gotCap = MAX_DEST_SIZE , gotLen = 0 ; UErrorCode gotStatus = U_ZERO_ERROR ; gotLen = uIDNA ( srcUChars , src . length ( ) - 1 , got , gotCap , options , & parseError , & gotStatus ) ; if ( expStatus != gotStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ status ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( gotStatus ) ) + " ▁ for ▁ Source : ▁ " + prettify ( srcUChars ) + " ▁ Options : ▁ " + options ) ; return UnicodeString ( " " ) ; } if ( U_SUCCESS ( expStatus ) ) { if ( u_strCompare ( exp , expLen , got , gotLen , TRUE ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ output ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ Expected : ▁ " + prettify ( UnicodeString ( exp , expLen ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( got , gotLen ) ) + " ▁ for ▁ Source : ▁ " + prettify ( srcUChars ) + " ▁ Options : ▁ " + options ) ; } return UnicodeString ( exp , expLen ) ; } else { logln ( " Got ▁ the ▁ same ▁ error ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ for ▁ input : ▁ " + prettify ( srcUChars ) ) ; } return UnicodeString ( " " ) ; }
void TestIDNA :: testCompareReferenceImpl ( const UChar * src , int32_t srcLen ) { UnicodeString label ( src , srcLen ) ; label . append ( ( UChar ) 0x0000 ) ; UnicodeString asciiLabel = testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_ALLOW_UNASSIGNED ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_DEFAULT ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_USE_STD3_RULES ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_USE_STD3_RULES | UIDNA_ALLOW_UNASSIGNED ) ; if ( asciiLabel . length ( ) != 0 ) { asciiLabel . append ( ( UChar ) 0x0000 ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_ALLOW_UNASSIGNED ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_DEFAULT ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_USE_STD3_RULES ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_USE_STD3_RULES | UIDNA_ALLOW_UNASSIGNED ) ; } }
void TestIDNA :: TestIDNAMonkeyTest ( ) { UnicodeString source ; UErrorCode status = U_ZERO_ERROR ; int i ; getInstance ( status ) ; if ( U_FAILURE ( status ) ) { dataerrln ( " Test ▁ could ▁ not ▁ initialize . ▁ Got ▁ % s " , u_errorName ( status ) ) ; return ; } for ( i = 0 ; i < loopCount ; i ++ ) { source . truncate ( 0 ) ; getTestSource ( source ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; } for ( i = 0 ; i < ( int ) ( sizeof ( failures ) / sizeof ( failures [ 0 ] ) ) ; i ++ ) { source . truncate ( 0 ) ; source . append ( UnicodeString ( failures [ i ] , - 1 , US_INV ) ) ; source = source . unescape ( ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; } source . truncate ( 0 ) ; source . append ( UNICODE_STRING@@ _SIMPLE ( " \\uCF18@@ \\U00021@@ 161\\U000@@ EEF11@@ \\U0002BB82\\U000@@ 1D63C " ) ) ; debug ( source . getBuffer ( ) , source . length ( ) , UIDNA_ALLOW_UNASSIGNED ) ; { UnicodeString source ( " \\u043f\\u00@@ AD\\u0@@ 34f\\u043e\\u04@@ 47\\u0435\\u043c\\u0443\\u0436\\u0435\\u043e\\u043d\\u0438\\u043d\\u0435\\u0433\\u043e\\u0432\\u043e\\u0440\\u044f\\u0442\\u043f\\u043e\\u0440\\u0443\\u0441\\u0441\\u043a\\u0438\\u0000" , - 1 , US_INV ) ; source = source . unescape ( ) ; UnicodeString expected ( " \\u043f\\u043e\\u0447\\u0435\\u043c\\u0443\\u0436\\u0435\\u043e\\u043d\\u0438\\u043d\\u0435\\u0433\\u043e\\u0432\\u043e\\u0440\\u044f\\u0442\\u043f\\u043e\\u0440\\u0443\\u0441\\u0441\\u043a\\u0438\\u0000" , - 1 , US_INV ) ; expected = expected . unescape ( ) ; UnicodeString ascii ( " xn - - b1abfaaepdrnnbgefbadotcwatmq2g4l " ) ; ascii . append ( ( UChar ) 0x0000 ) ; testAPI ( source . getBuffer ( ) , ascii . getBuffer ( ) , " uidna _ toASCII " , FALSE , U_ZERO_ERROR , TRUE , TRUE , uidna_toASCII ) ; testAPI ( source . getBuffer ( ) , ascii . getBuffer ( ) , " idnaref _ toASCII " , FALSE , U_ZERO_ERROR , TRUE , TRUE , idnaref_toASCII ) ; testCompareReferenceImpl ( source . getBuffer ( ) , source . length ( ) - 1 ) ; } }
void TestIDNA :: TestCompareReferenceImpl ( ) { UChar src [ 2 ] = { 0 , 0 } ; int32_t srcLen = 0 ; for ( int32_t i = 0x40000 ; i < 0x10ffff ; i ++ ) { if ( quick == TRUE && i > 0x1FFFF ) { return ; } if ( i >= 0x30000 && i <= 0xF0000 ) { i += 0xB0000 ; } if ( i > 0xFFFF ) { src [ 0 ] = U16_LEAD ( i ) ; src [ 1 ] = U16_TRAIL ( i ) ; srcLen = 2 ; } else { src [ 0 ] = ( UChar ) i ; src [ 1 ] = 0 ; srcLen = 1 ; } testCompareReferenceImpl ( src , srcLen ) ; } }
void TestIDNA :: TestRefIDNA ( ) { UErrorCode status = U_ZERO_ERROR ; getInstance ( status ) ; if ( U_FAILURE ( status ) ) { if ( status == U_FILE_ACCESS_ERROR ) { dataerrln ( " Test ▁ could ▁ not ▁ initialize . ▁ Got ▁ % s " , u_errorName ( status ) ) ; } return ; } testToASCII ( " idnaref _ toASCII " , idnaref_toASCII ) ; testToUnicode ( " idnaref _ toUnicode " , idnaref_toUnicode ) ; testIDNToASCII ( " idnaref _ IDNToASCII " , idnaref_IDNToASCII ) ; testIDNToUnicode ( " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testCompare ( " idnaref _ compare " , idnaref_compare ) ; testErrorCases ( " idnaref _ IDNToASCII " , idnaref_IDNToASCII , " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testChaining ( " idnaref _ toASCII " , idnaref_toASCII , " idnaref _ toUnicode " , idnaref_toUnicode ) ; testRootLabelSeparator ( " idnaref _ compare " , idnaref_compare , " idnaref _ IDNToASCII " , idnaref_IDNToASCII , " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testChaining ( " idnaref _ toASCII " , idnaref_toASCII , " idnaref _ toUnicode " , idnaref_toUnicode ) ; }
void TestIDNA :: TestDataFile ( ) { testData ( * this ) ; }
TestIDNA :: ~ TestIDNA ( ) { if ( gPrep != NULL ) { delete gPrep ; gPrep = NULL ; } }
NamePrepTransform * TestIDNA :: getInstance ( UErrorCode & status ) { if ( TestIDNA :: gPrep == NULL ) { UParseError parseError ; TestIDNA :: gPrep = NamePrepTransform :: createInstance ( parseError , status ) ; if ( TestIDNA :: gPrep == NULL ) { return NULL ; } } return TestIDNA :: gPrep ; }
