public UTName ( ColumnIdentifier ksName , ColumnIdentifier utName ) { this . ksName = ksName == null ? null : ksName . toString ( ) ; this . utName = utName ; }
public boolean hasKeyspace ( ) { return ksName != null ; }
public void setKeyspace ( String keyspace ) { this . ksName = keyspace ; }
public String getKeyspace ( ) { return ksName ; }
public ByteBuffer getUserTypeName ( ) { return utName . bytes ; }
public String getStringTypeName ( ) { return utName . toString ( ) ; }
public String toString ( ) { return ( hasKeyspace ( ) ? ( ksName + " . " ) : " " ) + utName ; }
public SAMRecord makeSAMRecord ( Read read , ReadGroupSet readGroupSet , List < Reference > references , boolean forceSetMatePositionToThisPosition ) { return makeSAMRecord ( read , makeSAMFileHeader ( readGroupSet , references ) ) ; }
public SAMRecord makeSAMRecord ( Read read , boolean forceSetMatePositionToThisPosition ) { return makeSAMRecord ( read , new SAMFileHeader ( ) ) ; }
public void validateReportParameters ( ReportParameters reportCriteria , ValidationContext context ) { MessageContext messages = context . getMessageContext ( ) ; List < ReportDateParm > dateParms = reportCriteria . getDateParms ( ) ; for ( Iterator < ReportDateParm > dateParmIter = dateParms . iterator ( ) ; dateParmIter . hasNext ( ) ; ) { ReportDateParm dateParm = dateParmIter . next ( ) ; if ( dateParm . getDate ( ) == null ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " date ▁ parms " ) . defaultText ( " cannot ▁ have ▁ null ▁ date ▁ field " + dateParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportStringParm > stringParms = reportCriteria . getStringParms ( ) ; for ( Iterator < ReportStringParm > stringParmIter = stringParms . iterator ( ) ; stringParmIter . hasNext ( ) ; ) { ReportStringParm stringParm = stringParmIter . next ( ) ; if ( stringParm . getValue ( ) == " " ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " string ▁ parms " ) . defaultText ( " cannot ▁ have ▁ empty ▁ string ▁ field " + stringParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportIntParm > intParms = reportCriteria . getIntParms ( ) ; for ( Iterator < ReportIntParm > intParmIter = intParms . iterator ( ) ; intParmIter . hasNext ( ) ; ) { ReportIntParm intParm = intParmIter . next ( ) ; if ( intParm . getValue ( ) == 0 ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " int ▁ parms " ) . defaultText ( " cannot ▁ have ▁ zero ▁ integer ▁ field " + intParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportFloatParm > floatParms = reportCriteria . getFloatParms ( ) ; for ( Iterator < ReportFloatParm > floatParmIter = floatParms . iterator ( ) ; floatParmIter . hasNext ( ) ; ) { ReportFloatParm floatParm = floatParmIter . next ( ) ; if ( floatParm . getValue ( ) == null ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " float ▁ parms " ) . defaultText ( " cannot ▁ have ▁ null ▁ float ▁ field " + floatParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportDoubleParm > doubleParms = reportCriteria . getDoubleParms ( ) ; for ( Iterator < ReportDoubleParm > doubleParmIter = doubleParms . iterator ( ) ; doubleParmIter . hasNext ( ) ; ) { ReportDoubleParm doubleParm = doubleParmIter . next ( ) ; if ( doubleParm . getValue ( ) == null ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " double ▁ parms " ) . defaultText ( " cannot ▁ have ▁ null ▁ double ▁ field " + doubleParm . getDisplayName ( ) ) . build ( ) ) ; } } }
public JarFileX ( File file ) throws IOException { super ( file ) ; }
public JarFileX ( File file , boolean verify ) throws IOException { super ( file , verify ) ; }
public JarFileX ( File file , boolean verify , int mode ) throws IOException { super ( file , verify , mode ) ; }
public JarFileX ( String name ) throws IOException { super ( name ) ; }
public JarFileX ( String name , boolean verify ) throws IOException { super ( name , verify ) ; }
public ZipEntry getEntry ( String name ) { ZipEntry entry = super . getEntry ( name ) ; if ( ( entry != null ) && ( entry . getSize ( ) == 0 ) && ! entry . isDirectory ( ) ) { ZipEntry dirEntry = super . getEntry ( name + ' / ' ) ; if ( dirEntry != null ) { entry = dirEntry ; } } return entry ; }
public JarEntry getJarEntry ( String name ) { JarEntry entry = super . getJarEntry ( name ) ; if ( ( entry != null ) && ( entry . getSize ( ) == 0 ) && ! entry . isDirectory ( ) ) { JarEntry dirEntry = super . getJarEntry ( name + ' / ' ) ; if ( dirEntry != null ) { entry = dirEntry ; } } return entry ; }
public Handler ( ) { }
protected URLConnection openConnection ( URL url ) throws IOException { return new Connection ( url ) ; }
protected void parseURL ( URL url , String url_string , int start , int end ) { String file = url . getFile ( ) ; if ( ! file . equals ( " " ) ) { url_string = url_string . substring ( start , end ) ; if ( url_string . startsWith ( " / " ) ) { int idx = file . lastIndexOf ( " ! / " ) ; if ( idx < 0 ) throw new URLParseError ( " no ▁ ! / ▁ in ▁ spec " ) ; file = file . substring ( 0 , idx + 1 ) + url_string ; } else if ( url_string . length ( ) > 0 ) { int idx = file . lastIndexOf ( " / " ) ; if ( idx == - 1 ) file = " / " + url_string ; else if ( idx == ( file . length ( ) - 1 ) ) file = file + url_string ; else file = file . substring ( 0 , idx + 1 ) + url_string ; } setURL ( url , " jar " , url . getHost ( ) , url . getPort ( ) , flat ( file ) , null ) ; return ; } if ( end < start ) return ; if ( end - start < 2 ) return ; if ( start > url_string . length ( ) ) return ; url_string = url_string . substring ( start , end ) ; int jar_stop ; if ( ( jar_stop = url_string . indexOf ( " ! / " ) ) < 0 ) throw new URLParseError ( " no ▁ ! / ▁ in ▁ spec " ) ; try { new URL ( url_string . substring ( 0 , jar_stop ) ) ; } catch ( MalformedURLException e ) { throw new URLParseError ( " invalid ▁ inner ▁ URL : ▁ " + e . getMessage ( ) ) ; } if ( ! url . getProtocol ( ) . equals ( " jar " ) ) throw new URLParseError ( " unexpected ▁ protocol ▁ " + url . getProtocol ( ) ) ; setURL ( url , " jar " , url . getHost ( ) , url . getPort ( ) , url_string , null ) ; }
protected String toExternalForm ( URL url ) { String file = url . getFile ( ) ; String ref = url . getRef ( ) ; CPStringBuilder sb = new CPStringBuilder ( file . length ( ) + 5 ) ; sb . append ( " jar : " ) ; sb . append ( file ) ; if ( ref != null ) sb . append ( ' # ' ) . append ( ref ) ; return sb . toString ( ) ; }
private Factory ( ) { }
public void write ( Element root , OutputStream out ) throws IOException { Writer wri = new OutputStream@@ Writer ( out , " UTF - 8" ) ; wri . write ( " < ? xml ▁ version = \ " 1.0\ " ▁ encoding = \ " UTF - 8\ " ? > " + lSep ) ; write ( root , wri , 0 , " ▁ ▁ " ) ; wri . flush ( ) ; }
public void write ( Node element , Writer out , int indent , String indentWith ) throws IOException { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } if ( element . getNodeType ( ) == Node . COMMENT_NODE ) { out . write ( " < ! - - " ) ; out . write ( encode ( element . getNodeValue ( ) ) ) ; out . write ( " - - > " ) ; } else { out . write ( " < " ) ; out . write ( ( ( Element ) element ) . getTagName ( ) ) ; NamedNode@@ Map attrs = element . getAttributes ( ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; out . write ( " ▁ " ) ; out . write ( attr . getName ( ) ) ; out . write ( " = \ " " ) ; out . write ( encode ( attr . getValue ( ) ) ) ; out . write ( " \ " " ) ; } out . write ( " > " ) ; } boolean hasChildren = false ; NodeList children = element . getChildNodes ( ) ; for ( int i = 0 ; element . hasChild@@ Nodes ( ) && i < children . getLength ( ) ; i ++ ) { Node child = children . item ( i ) ; switch ( child . getNodeType ( ) ) { case Node . ELEMENT_NODE : case Node . COMMENT_NODE : if ( ! hasChildren ) { out . write ( lSep ) ; hasChildren = true ; } write ( child , out , indent + 1 , indentWith ) ; break ; case Node . TEXT_NODE : if ( child . getNodeValue ( ) != null && ( child . getNodeValue ( ) . indexOf ( " \n " ) == - 1 || child . getNodeValue ( ) . trim ( ) . length ( ) != 0 ) ) out . write ( encode ( child . getNodeValue ( ) ) ) ; break ; case Node . CDATA_SECTION_NODE : out . write ( " < ! [ CDATA [ " ) ; out . write ( encodedata ( ( ( Text ) child ) . getData ( ) ) ) ; out . write ( " ] ] > " ) ; break ; case Node . ENTITY_@@ REFERENCE_@@ NODE : out . write ( ' & ' ) ; out . write ( child . getNodeName ( ) ) ; out . write ( ' ; ' ) ; break ; case Node . PROCESSING_INSTRUC@@ TION_NODE : out . write ( " < ? " ) ; out . write ( child . getNodeName ( ) ) ; String data = child . getNodeValue ( ) ; if ( data != null && data . length ( ) > 0 ) { out . write ( ' ▁ ' ) ; out . write ( data ) ; } out . write ( " ? > " ) ; break ; } } if ( hasChildren ) { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } } if ( element . getNodeType ( ) == Node . ELEMENT_NODE ) { out . write ( " < / " ) ; out . write ( ( ( Element ) element ) . getTagName ( ) ) ; out . write ( " > " ) ; } out . write ( lSep ) ; out . flush ( ) ; }
public String encode ( String value ) { StringBuffer sb = new StringBuffer ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = value . charAt ( i ) ; switch ( c ) { case ' < ' : sb . append ( " & lt ; " ) ; break ; case ' > ' : sb . append ( " & gt ; " ) ; break ; case ' \ ' ' : sb . append ( " & apos ; " ) ; break ; case ' \ " ' : sb . append ( " & quot ; " ) ; break ; case ' & ' : int nextSemi = value . indexOf ( " ; " , i ) ; if ( ( nextSemi < 0 ) || ! isReference ( value . substring ( i , nextSemi + 1 ) ) ) sb . append ( " & amp ; " ) ; else sb . append ( ' & ' ) ; break ; default : if ( isLegalCharacter ( c ) ) sb . append ( c ) ; break ; } } return sb . substring ( 0 ) ; }
public String encodedata ( final String value ) { StringBuffer sb = new StringBuffer ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; ++ i ) { char c = value . charAt ( i ) ; if ( isLegalCharacter ( c ) ) { sb . append ( c ) ; } } String result = sb . substring ( 0 ) ; int cdEnd = result . indexOf ( " ] ] > " ) ; while ( cdEnd != - 1 ) { sb . setLength ( cdEnd ) ; sb . append ( " & # x5d ; & # x5d ; & gt ; " ) . append ( result . substring ( cdEnd + 3 ) ) ; result = sb . substring ( 0 ) ; cdEnd = result . indexOf ( " ] ] > " ) ; } return result ; }
public boolean isReference ( String ent ) { if ( ! ( ent . charAt ( 0 ) == ' & ' ) || ! ent . endsWith ( " ; " ) ) return false ; if ( ent . charAt ( 1 ) == ' # ' ) { if ( ent . charAt ( 2 ) == ' x ' ) { try { Integer . parseInt ( ent . substring ( 3 , ent . length ( ) - 1 ) , 16 ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } else { try { Integer . parseInt ( ent . substring ( 2 , ent . length ( ) - 1 ) ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } } String name = ent . substring ( 1 , ent . length ( ) - 1 ) ; for ( int i = 0 ; i < knownEntities . length ; i ++ ) { if ( name . equals ( knownEntities [ i ] ) ) { return true ; } } return false ; }
public boolean isLegalCharacter ( char c ) { if ( c == 0x9 || c == 0xA || c == 0xD ) { return true ; } else if ( c < 0x20 ) { return false ; } else if ( c <= 0xD7FF ) { return true ; } else if ( c < 0xE000 ) { return false ; } else if ( c <= 0xFFFD ) { return true ; } return false ; }
public void run ( ) { try { synchronized ( this ) { this . notify ( ) ; this . wait ( delay ) ; } } catch ( InterruptedException e ) { return ; } }
public SimpleThread ( int d ) { if ( d >= 0 ) delay = d ; }
public void run ( ) { int x = 0 ; while ( true ) { ++ x ; } }
public YieldThread ( int d ) { if ( d >= 0 ) delay = d ; }
public void run ( ) { try { synchronized ( this ) { this . notify ( ) ; } while ( true ) { checkVal ++ ; zz ( ) ; Thread . sleep ( 100 ) ; } } catch ( InterruptedException e ) { return ; } catch ( BogusException e ) { try { Thread . sleep ( 500 ) ; } catch ( InterruptedException x ) { } parent . interrupt ( ) ; while ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { try { Thread . sleep ( 50 ) ; } catch ( InterruptedException x ) { break ; } } } }
public void zz ( ) throws BogusException { }
public ResSupThread ( Thread t ) { parent = t ; }
public synchronized int getCheckVal ( ) { return checkVal ; }
public BogusException ( String s ) { super ( s ) ; }
public void test_Constructor ( ) { Thread t ; SecurityManager m = new SecurityManager ( ) { @ Override public ThreadGroup getThreadGroup ( ) { calledMySecurityManager = true ; return Thread . currentThread ( ) . getThreadGroup ( ) ; } @ Override public void checkPermission ( Permission permission ) { if ( permission . getName ( ) . equals ( " setSecurityManager " ) ) { return ; } super . checkPermission ( permission ) ; } } ; try { System . setSecurityManager ( m ) ; t = new Thread ( ) ; } finally { System . setSecurityManager ( null ) ; } assertTrue ( " Did ▁ not ▁ call ▁ SecurityManager . getThreadGroup ▁ ( ) " , calledMySecurityManager ) ; t . start ( ) ; }
public void test_ConstructorLjava_lang_Runnable ( ) { ct = new Thread ( new SimpleThread ( 10 ) ) ; ct . start ( ) ; }
public void test_ConstructorLjava_lang_RunnableLjava_lang_String ( ) { Thread st1 = new Thread ( new SimpleThread ( 1 ) , " SimpleThread1" ) ; assertEquals ( " Constructed ▁ thread ▁ with ▁ incorrect ▁ thread ▁ name " , " SimpleThread1" , st1 . getName ( ) ) ; st1 . start ( ) ; }
public void test_ConstructorLjava_lang_String ( ) { Thread t = new Thread ( " Testing " ) ; assertEquals ( " Created ▁ tread ▁ with ▁ incorrect ▁ name " , " Testing " , t . getName ( ) ) ; t . start ( ) ; }
public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_Runnable ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group1" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread2" ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ group " , st . getThreadGroup ( ) == tg ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; }
public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_RunnableLjava_lang_String ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group2" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread3" ) ; assertTrue ( " Constructed ▁ incorrect ▁ thread " , ( st . getThreadGroup ( ) == tg ) && st . getName ( ) . equals ( " SimpleThread3" ) ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; Runnable r = new Runnable ( ) { public void run ( ) { } } ; ThreadGroup foo = null ; try { new Thread ( foo = new ThreadGroup ( " foo " ) , r , null ) ; fail ( " Null ▁ cannot ▁ be ▁ accepted ▁ as ▁ Thread ▁ name " ) ; } catch ( NullPointerException npe ) { assertTrue ( " Null ▁ cannot ▁ be ▁ accepted ▁ as ▁ Thread ▁ name " , true ) ; foo . destroy ( ) ; } }
public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_String ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread4" ) ; assertEquals ( " Returned ▁ incorrect ▁ thread ▁ name " , " SimpleThread4" , st . getName ( ) ) ; st . start ( ) ; }
public void test_activeCount ( ) { Thread t = new Thread ( new SimpleThread ( 10 ) ) ; int active = 0 ; synchronized ( t ) { t . start ( ) ; active = Thread . activeCount ( ) ; } assertTrue ( " Incorrect ▁ activeCount ▁ for ▁ current ▁ group : ▁ " + active , active > 1 ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { } }
public void test_checkAccess ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group3" ) ; try { st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread5" ) ; st . checkAccess ( ) ; assertTrue ( " CheckAccess ▁ passed " , true ) ; } catch ( SecurityException e ) { fail ( " CheckAccess ▁ failed ▁ : ▁ " + e . getMessage ( ) ) ; } st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; }
; }
public void test_currentThread ( ) { assertNotNull ( Thread . currentThread ( ) ) ; }
{ } }
public void test_enumer@@ ate$Ljava_lang_Thread ( ) { class MyThread extends Thread { MyThread ( ThreadGroup tg , String name ) { super ( tg , name ) ; } boolean failed = false ; String failMessage = null ; public void run ( ) { SimpleThread st1 = null ; SimpleThread st2 = null ; ThreadGroup mytg = null ; Thread firstOne = null ; Thread secondOne = null ; try { int arrayLength = 10 ; Thread [ ] tarray = new Thread [ arrayLength ] ; st1 = new SimpleThread ( - 1 ) ; st2 = new SimpleThread ( - 1 ) ; mytg = new ThreadGroup ( " jp " ) ; firstOne = new Thread ( mytg , st1 , " firstOne2" ) ; secondOne = new Thread ( mytg , st2 , " secondOne1" ) ; int count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned1" , 1 , count ) ; synchronized ( st1 ) { firstOne . start ( ) ; try { st1 . wait ( ) ; } catch ( InterruptedException e ) { } } count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned2" , 2 , count ) ; synchronized ( st2 ) { secondOne . start ( ) ; try { st2 . wait ( ) ; } catch ( InterruptedException e ) { } } count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned3" , 3 , count ) ; } catch ( junit . framework . Assertion@@ FailedError e ) { failed = true ; failMessage = e . getMessage ( ) ; } finally { synchronized ( st1 ) { firstOne . interrupt ( ) ; } synchronized ( st2 ) { secondOne . interrupt ( ) ; } try { firstOne . join ( ) ; secondOne . join ( ) ; } catch ( InterruptedException e ) { } mytg . destroy ( ) ; } } } ; ThreadGroup tg = new ThreadGroup ( " tg " ) ; MyThread t = new MyThread ( tg , " top " ) ; t . start ( ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt " ) ; } finally { tg . destroy ( ) ; } assertFalse ( t . failMessage , t . failed ) ; }
public void test_getContextClassLoader ( ) { Thread t = new Thread ( ) ; assertTrue ( " Incorrect ▁ class ▁ loader ▁ returned " , t . getContextClassLoader ( ) == Thread . currentThread ( ) . getContextClassLoader ( ) ) ; t . start ( ) ; }
public void test_getName ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread6" ) ; assertEquals ( " Returned ▁ incorrect ▁ thread ▁ name " , " SimpleThread6" , st . getName ( ) ) ; st . start ( ) ; }
public void test_getPriority ( ) { st = new Thread ( new SimpleThread ( 1 ) ) ; st . setPriority ( Thread . MAX_PRIORITY ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ priority " , st . getPriority ( ) == Thread . MAX_PRIORITY ) ; st . start ( ) ; }
public void test_getThreadGroup ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group4" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread8" ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ group " , st . getThreadGroup ( ) == tg ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } assertNull ( " group ▁ should ▁ be ▁ null " , st . getThreadGroup ( ) ) ; assertNotNull ( " toString ( ) ▁ should ▁ not ▁ be ▁ null " , st . toString ( ) ) ; tg . destroy ( ) ; final Object lock = new Object ( ) ; Thread t = new Thread ( ) { @ Override public void run ( ) { synchronized ( lock ) { lock . notifyAll ( ) ; } } } ; synchronized ( lock ) { t . start ( ) ; try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } int running = 0 ; while ( t . isAlive ( ) ) running ++ ; ThreadGroup group = t . getThreadGroup ( ) ; assertNull ( " ThreadGroup ▁ is ▁ not ▁ null " , group ) ; }
public void test_interrupt ( ) { final Object lock = new Object ( ) ; class ChildThread1 extends Thread { Thread parent ; boolean sync ; @ Override public void run ( ) { if ( sync ) { synchronized ( lock ) { lock . notify ( ) ; try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } } parent . interrupt ( ) ; } public ChildThread1 ( Thread p , String name , boolean sync ) { super ( name ) ; parent = p ; this . sync = sync ; } } boolean interrupted = false ; try { ct = new ChildThread1 ( Thread . currentThread ( ) , " Interrupt ▁ Test1" , false ) ; synchronized ( lock ) { ct . start ( ) ; lock . wait ( ) ; } } catch ( InterruptedException e ) { interrupted = true ; } assertTrue ( " Failed ▁ to ▁ Interrupt ▁ thread1" , interrupted ) ; interrupted = false ; try { ct = new ChildThread1 ( Thread . currentThread ( ) , " Interrupt ▁ Test2" , true ) ; synchronized ( lock ) { ct . start ( ) ; lock . wait ( ) ; lock . notify ( ) ; } Thread . sleep ( 20000 ) ; } catch ( InterruptedException e ) { interrupted = true ; } assertTrue ( " Failed ▁ to ▁ Interrupt ▁ thread2" , interrupted ) ; }
public void test_interrupted ( ) { assertFalse ( " Interrupted ▁ returned ▁ true ▁ for ▁ non - interrupted ▁ thread " , Thread . interrupted ( ) ) ; Thread . currentThread ( ) . interrupt ( ) ; assertTrue ( " Interrupted ▁ returned ▁ true ▁ for ▁ non - interrupted ▁ thread " , Thread . interrupted ( ) ) ; assertFalse ( " Failed ▁ to ▁ clear ▁ interrupted ▁ flag " , Thread . interrupted ( ) ) ; }
public void test_isAlive ( ) { SimpleThread simple ; st = new Thread ( simple = new SimpleThread ( 500 ) ) ; assertFalse ( " A ▁ thread ▁ that ▁ wasn ' t ▁ started ▁ is ▁ alive . " , st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; try { simple . wait ( ) ; } catch ( InterruptedException e ) { } } assertTrue ( " Started ▁ thread ▁ returned ▁ false " , st . isAlive ( ) ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { fail ( " Thread ▁ did ▁ not ▁ die " ) ; } assertTrue ( " Stopped ▁ thread ▁ returned ▁ true " , ! st . isAlive ( ) ) ; }
public void test_isDaemon ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread10" ) ; assertTrue ( " Non - Daemon ▁ thread ▁ returned ▁ true " , ! st . isDaemon ( ) ) ; st . setDaemon ( true ) ; assertTrue ( " Daemon ▁ thread ▁ returned ▁ false " , st . isDaemon ( ) ) ; st . start ( ) ; }
public void test_isInterrupted ( ) { class SpinThread implements Runnable { public volatile boolean done = false ; public void run ( ) { while ( ! Thread . currentThread ( ) . isInterrupted ( ) ) ; while ( ! done ) ; } } SpinThread spin = new SpinThread ( ) ; spinner = new Thread ( spin ) ; spinner . start ( ) ; Thread . yield ( ) ; try { assertTrue ( " Non - Interrupted ▁ thread ▁ returned ▁ true " , ! spinner . isInterrupted ( ) ) ; spinner . interrupt ( ) ; assertTrue ( " Interrupted ▁ thread ▁ returned ▁ false " , spinner . isInterrupted ( ) ) ; spin . done = true ; } finally { spinner . interrupt ( ) ; spin . done = true ; } }
public void test_join ( ) { SimpleThread simple ; try { st = new Thread ( simple = new SimpleThread ( 100 ) ) ; assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ " ) ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! st . isAlive ( ) ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { th . join ( ) ; } catch ( InterruptedException e ) { result = false ; } assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; }
public void test_joinJ ( ) { SimpleThread simple ; try { st = new Thread ( simple = new SimpleThread ( 1000 ) , " SimpleThread12" ) ; assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( 10 ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ " ) ; } assertTrue ( " Join ▁ failed ▁ to ▁ timeout " , st . isAlive ( ) ) ; st . interrupt ( ) ; try { st = new Thread ( simple = new SimpleThread ( 100 ) , " SimpleThread13" ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( 1000 ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ : ▁ " + e . getMessage ( ) ) ; return ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! st . isAlive ( ) ) ; final Object lock = new Object ( ) ; final Thread main = Thread . currentThread ( ) ; Thread killer = new Thread ( new Runnable ( ) { public void run ( ) { try { synchronized ( lock ) { lock . notify ( ) ; } Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { return ; } main . interrupt ( ) ; } } ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { synchronized ( lock ) { killer . start ( ) ; lock . wait ( ) ; } th . join ( 200 ) ; } catch ( InterruptedException e ) { result = false ; } killer . interrupt ( ) ; assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; }
public void test_joinJI ( ) throws Exception { SimpleThread simple ; st = new Thread ( simple = new SimpleThread ( 1000 ) , " Squawk1" ) ; assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } long firstRead = System . currentTimeMillis ( ) ; st . join ( 100 , 999999 ) ; long secondRead = System . currentTimeMillis ( ) ; assertTrue ( " Did ▁ not ▁ join ▁ by ▁ appropriate ▁ time : ▁ " + secondRead + " - " + firstRead + " = " + ( secondRead - firstRead ) , secondRead - firstRead <= 300 ) ; assertTrue ( " Joined ▁ thread ▁ is ▁ not ▁ alive " , st . isAlive ( ) ) ; st . interrupt ( ) ; final Object lock = new Object ( ) ; final Thread main = Thread . currentThread ( ) ; Thread killer = new Thread ( new Runnable ( ) { public void run ( ) { try { synchronized ( lock ) { lock . notify ( ) ; } Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { return ; } main . interrupt ( ) ; } } ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { synchronized ( lock ) { killer . start ( ) ; lock . wait ( ) ; } th . join ( 200 , 20 ) ; } catch ( InterruptedException e ) { result = false ; } killer . interrupt ( ) ; assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; }
; } }
public void test_run ( ) { class RunThread implements Runnable { boolean didThreadRun = false ; public void run ( ) { didThreadRun = true ; } } RunThread rt = new RunThread ( ) ; Thread t = new Thread ( rt ) ; try { t . start ( ) ; int count = 0 ; while ( ! rt . didThreadRun && count < 20 ) { Thread . sleep ( 100 ) ; count ++ ; } assertTrue ( " Thread ▁ did ▁ not ▁ run " , rt . didThreadRun ) ; t . join ( ) ; } catch ( InterruptedException e ) { assertTrue ( " Joined ▁ thread ▁ was ▁ interrupted " , true ) ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! t . isAlive ( ) ) ; }
public void test_setDaemon@@ Z ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread14" ) ; st . setDaemon ( true ) ; assertTrue ( " Failed ▁ to ▁ set ▁ thread ▁ as ▁ daemon ▁ thread " , st . isDaemon ( ) ) ; st . start ( ) ; }
public void test_setNameLjava_lang_String ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread15" ) ; st . setName ( " Bogus ▁ Name " ) ; assertEquals ( " Failed ▁ to ▁ set ▁ thread ▁ name " , " Bogus ▁ Name " , st . getName ( ) ) ; try { st . setName ( null ) ; fail ( " Null ▁ should ▁ not ▁ be ▁ accepted ▁ as ▁ a ▁ valid ▁ name " ) ; } catch ( NullPointerException e ) { assertTrue ( " Null ▁ should ▁ not ▁ be ▁ accepted ▁ as ▁ a ▁ valid ▁ name " , true ) ; } st . start ( ) ; }
public void test_setPriority@@ I ( ) { st = new Thread ( new SimpleThread ( 1 ) ) ; st . setPriority ( Thread . MAX_PRIORITY ) ; assertTrue ( " Failed ▁ to ▁ set ▁ priority " , st . getPriority ( ) == Thread . MAX_PRIORITY ) ; st . start ( ) ; }
public void test_sleepJ ( ) { long stime = 0 , ftime = 0 ; try { stime = System . currentTimeMillis ( ) ; Thread . sleep ( 1000 ) ; ftime = System . currentTimeMillis ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ received " ) ; } assertTrue ( " Failed ▁ to ▁ sleep ▁ long ▁ enough " , ( ftime - stime ) >= 800 ) ; }
public void test_sleepJI ( ) { long stime = 0 , ftime = 0 ; try { stime = System . currentTimeMillis ( ) ; Thread . sleep ( 1000 , 999999 ) ; ftime = System . currentTimeMillis ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ received " ) ; } long result = ftime - stime ; assertTrue ( " Failed ▁ to ▁ sleep ▁ long ▁ enough : ▁ " + result , result >= 900 && result <= 1100 ) ; }
public void test_start ( ) { try { ResSupThread t = new ResSupThread ( Thread . currentThread ( ) ) ; synchronized ( t ) { ct = new Thread ( t , " Interrupt ▁ Test4" ) ; ct . start ( ) ; t . wait ( ) ; } assertTrue ( " Thread ▁ is ▁ not ▁ running1" , ct . isAlive ( ) ) ; int orgval = t . getCheckVal ( ) ; Thread . sleep ( 150 ) ; assertTrue ( " Thread ▁ is ▁ not ▁ running2" , orgval != t . getCheckVal ( ) ) ; ct . interrupt ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ occurred " ) ; } }
; }
; } }
; } }
; }
{ } }
public void test_toString ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group5" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread17" ) ; final String stString = st . toString ( ) ; final String expected = " Thread [ SimpleThread17,5 , Test ▁ Group5 ] " ; assertTrue ( " Returned ▁ incorrect ▁ string : ▁ " + stString + " \t ( expecting ▁ : " + expected + " ) " , stString . equals ( expected ) ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; }
public void test_getAllStackTraces ( ) { Map < Thread , StackTraceElement [ ] > stMap = Thread . getAllStackTraces ( ) ; assertNotNull ( stMap ) ; }
public void test_get_setDefaultUncaughtExceptionHandler ( ) { class Handler implements UncaughtExceptionHandler { public void uncaughtException ( Thread thread , Throwable ex ) { } } final Handler handler = new Handler ( ) ; Thread . setDefaultUncaughtExceptionHandler ( handler ) ; assertSame ( handler , Thread . getDefaultUncaughtExceptionHandler ( ) ) ; Thread . setDefaultUncaughtExceptionHandler ( null ) ; assertNull ( Thread . getDefaultUncaughtExceptionHandler ( ) ) ; }
public void test_getStackTrace ( ) { StackTraceElement [ ] stackTrace = Thread . currentThread ( ) . getStackTrace ( ) ; assertNotNull ( stackTrace ) ; stack_trace_loop : { for ( int i = 0 ; i < stackTrace . length ; i ++ ) { StackTraceElement e = stackTrace [ i ] ; if ( getClass ( ) . getName ( ) . equals ( e . getClassName ( ) ) ) { if ( " test _ getStackTrace " . equals ( e . getMethodName ( ) ) ) { break stack_trace_loop ; } } } fail ( " class ▁ and ▁ method ▁ not ▁ found ▁ in ▁ stack ▁ trace " ) ; } }
public void test_getState ( ) { Thread . State state = Thread . currentThread ( ) . getState ( ) ; assertNotNull ( state ) ; assertEquals ( Thread . State . RUNNABLE , state ) ; }
public void test_get_setUncaughtExceptionHandler ( ) { class Handler implements UncaughtExceptionHandler { public void uncaughtException ( Thread thread , Throwable ex ) { } } final Handler handler = new Handler ( ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( handler ) ; assertSame ( handler , Thread . currentThread ( ) . getUncaughtExceptionHandler ( ) ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( null ) ; }
public void test_getId ( ) { assertTrue ( " current ▁ thread ' s ▁ ID ▁ is ▁ not ▁ positive " , Thread . currentThread ( ) . getId ( ) > 0 ) ; Map < Thread , StackTraceElement [ ] > stMap = Thread . getAllStackTraces ( ) ; for ( Thread thread : stMap . keySet ( ) ) { assertTrue ( " thread ' s ▁ ID ▁ is ▁ not ▁ positive : ▁ " + thread . getName ( ) , thread . getId ( ) > 0 ) ; } }
protected void tearDown ( ) { try { if ( st != null ) st . interrupt ( ) ; } catch ( Exception e ) { } try { if ( spinner != null ) spinner . interrupt ( ) ; } catch ( Exception e ) { } try { if ( ct != null ) ct . interrupt ( ) ; } catch ( Exception e ) { } try { spinner = null ; st = null ; ct = null ; System . runFinalization ( ) ; } catch ( Exception e ) { } }
