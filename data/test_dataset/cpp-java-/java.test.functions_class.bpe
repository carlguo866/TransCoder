public String foo ( ) { return null ; }
String foo ( int i ) { return null ; }
String foo ( Fo@@ o foo ) { return null ; }
public void write@@ Object ( F@@ ST@@ Object@@ Output out , Object to@@ Write , F@@ ST@@ C@@ la@@ zz@@ Info cl@@ z@@ Info , F@@ ST@@ C@@ la@@ zz@@ Info . F@@ ST@@ Field@@ Info referenced@@ By , int stream@@ Position ) throws IOException { EnumSet en@@ set = ( EnumSet ) to@@ Write ; int count = 0 ; out . write@@ Int ( en@@ set . size ( ) ) ; if ( en@@ set . isEmpty ( ) ) { EnumSet comp@@ l = EnumSet . comp@@ lement@@ Of ( en@@ set ) ; out . write@@ Class@@ Tag ( comp@@ l . iterator ( ) . next ( ) . getClass ( ) ) ; } else { for ( Object element : en@@ set ) { if ( count == 0 ) { out . write@@ String@@ UTF ( element . getClass ( ) . getName ( ) ) ; } out . write@@ String@@ UTF ( element . toString ( ) ) ; count ++ ; } } }
public boolean alway@@ s@@ Copy ( ) { return false ; }
public Object instantiate ( Class object@@ Class , F@@ ST@@ Object@@ Input in , F@@ ST@@ C@@ la@@ zz@@ Info serialization@@ Info , F@@ ST@@ C@@ la@@ zz@@ Info . F@@ ST@@ Field@@ Info referen@@ ce@@ e , int stream@@ Position ) throws Exception { int len = in . read@@ Int ( ) ; Class elem@@ C@@ l = in . get@@ Class@@ For@@ Name ( in . read@@ String@@ UTF ( ) ) ; EnumSet en@@ Set = EnumSet . n@@ one@@ Of ( elem@@ C@@ l ) ; in . register@@ Object ( en@@ Set , stream@@ Position , serialization@@ Info , referen@@ ce@@ e ) ; for ( int i = 0 ; i < len ; i ++ ) { String val = in . read@@ String@@ UTF ( ) ; en@@ Set . add ( Enum . valueOf ( elem@@ C@@ l , val ) ) ; } return en@@ Set ; }
BufferedHttpInputStream ( InputStream stream , HttpURLConnection connection ) { super ( stream , Utility . DEFAULT_STRE@@ AM_BUFFER_SIZE ) ; this . connection = connection ; }
public void close ( ) throws IOException { super . close ( ) ; Utility . disconnect@@ Quietly ( connection ) ; }
public void test@@ Zip ( ) { String [ ] s1 = new String [ ] { " a " , " b " , " c " } ; Integer [ ] s2 = new Integer [ ] { 1 , 2 , 3 , 4 } ; int count = 0 ; for ( Pair < String , Integer > pair : Iter@@ able@@ s . zip ( s1 , s2 ) ) { assertEquals ( pair . first , s1 [ count ] ) ; assertEquals ( pair . second , s2 [ count ] ) ; count ++ ; } assertEquals ( s1 . length < s2 . length ? s1 . length : s2 . length , count ) ; }
; }
public void test@@ Filter ( ) { List < String > values = Arrays . asList ( " a " , " HI " , " t@@ Here " , " Y@@ O " ) ; Iterator < String > iterator = Iter@@ able@@ s . filter ( values , new Function < String , Boolean > ( ) { public Boolean apply ( String in ) { return in . equals ( in . toUpperCase ( ) ) ; } } ) . iterator ( ) ; assertTrue ( iterator . hasNext ( ) ) ; assertEquals ( iterator . next ( ) , " HI " ) ; assertEquals ( iterator . next ( ) , " Y@@ O " ) ; assertFalse ( iterator . hasNext ( ) ) ; }
public void test@@ Transform ( ) { List < Integer > values = Arrays . asList ( 1 , 2 , 3 , 4 ) ; List < Integer > squ@@ are@@ s = Arrays . asList ( 1 , 4 , 9 , 16 ) ; Function < Integer , Integer > squ@@ are@@ r = new Function < Integer , Integer > ( ) { public Integer apply ( Integer in ) { return in * in ; } } ; for ( Pair < Integer , Integer > pair : Iter@@ able@@ s . zip ( Iter@@ able@@ s . transform ( values , squ@@ are@@ r ) , squ@@ are@@ s ) ) { assertEquals ( pair . first , pair . second ) ; } }
public void test@@ Mer@@ ge ( ) { List < String > a = Arrays . asList ( " a " , " b " , " d " , " e " ) ; List < String > b = Arrays . asList ( " b " , " c " , " d " , " e " ) ; Comparator < String > comp@@ ar@@ ator = new Comparator < String > ( ) { public int compare ( String o@@ 1 , String o@@ 2 ) { return o@@ 1 . compareTo ( o@@ 2 ) ; } } ; Iterator < Pair < String , String > > iter = Iter@@ able@@ s . merge ( a , b , comp@@ ar@@ ator ) . iterator ( ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " b " , " b " ) ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " d " , " d " ) ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " e " , " e " ) ) ; assertTrue ( ! iter . hasNext ( ) ) ; }
public void test@@ Merge@@ 3 ( ) { List < String > a = Arrays . asList ( " a " , " b " , " d " , " e " ) ; List < String > b = Arrays . asList ( " b " , " c " , " d " , " e " ) ; List < String > c = Arrays . asList ( " a " , " b " , " c " , " e " , " f " ) ; Comparator < String > comp@@ ar@@ ator = new Comparator < String > ( ) { public int compare ( String o@@ 1 , String o@@ 2 ) { return o@@ 1 . compareTo ( o@@ 2 ) ; } } ; Iterator < Triple < String , String , String > > iter = Iter@@ able@@ s . merge ( a , b , c , comp@@ ar@@ ator ) . iterator ( ) ; assertEquals ( iter . next ( ) , new Triple < String , String , String > ( " b " , " b " , " b " ) ) ; assertEquals ( iter . next ( ) , new Triple < String , String , String > ( " e " , " e " , " e " ) ) ; assertTrue ( ! iter . hasNext ( ) ) ; }
public void test@@ Group ( ) { String [ ] input = new String [ ] { "0 ▁ ab " , "0 ▁ b@@ b " , "0 ▁ cc " , "1 ▁ dd " , "2 ▁ dd " , "2 ▁ k@@ j " , "3 ▁ k@@ j " , "3 ▁ k@@ k " } ; int [ ] coun@@ ts = new int [ ] { 3 , 1 , 2 , 2 } ; Comparator < String > field@@ One = new Comparator < String > ( ) { public int compare ( String o@@ 1 , String o@@ 2 ) { return o@@ 1 . split ( " ▁ " ) [ 0 ] . compareTo ( o@@ 2 . split ( " ▁ " ) [ 0 ] ) ; } } ; int index = 0 ; int group = 0 ; for ( Iter@@ able < String > set : Iter@@ able@@ s . group ( Arrays . asList ( input ) , field@@ One ) ) { String shared@@ Key = null ; int this@@ Count = 0 ; for ( String line : set ) { String this@@ Key = line . split ( " ▁ " ) [ 0 ] ; if ( shared@@ Key == null ) { shared@@ Key = this@@ Key ; } else { assertEquals ( " W@@ ron@@ g ▁ key " , shared@@ Key , this@@ Key ) ; } assertEquals ( " W@@ ron@@ g ▁ input ▁ line " , line , input [ index ++ ] ) ; this@@ Count ++ ; } assertEquals ( " W@@ ron@@ g ▁ number ▁ of ▁ items ▁ in ▁ this ▁ iterator " , coun@@ ts [ group ++ ] , this@@ Count ) ; } assertEquals ( " Did@@ n ' t ▁ get ▁ all ▁ inputs " , input . length , index ) ; assertEquals ( " W@@ ron@@ g ▁ number ▁ of ▁ groups " , coun@@ ts . length , group ) ; }
public void test@@ S@@ ample ( ) { Iter@@ able < Integer > items = Arrays . asList ( 5 , 4 , 3 , 2 , 1 ) ; int count = 0 ; for ( Integer item : Iter@@ able@@ s . sample ( items , 5 , 2 , new Random ( ) ) ) { ++ count ; Assert . assertTrue ( item <= 5 ) ; Assert . assertTrue ( item >= 1 ) ; } Assert . assertEquals ( 2 , count ) ; }
public Grid@@ Job@@ Sib@@ ling@@ s@@ Response ( ) { }
public Grid@@ Job@@ Sib@@ ling@@ s@@ Response ( @ Nullable Collection < Compute@@ Job@@ Sibling > si@@ bl@@ ings , @ Nullable byte [ ] si@@ bl@@ ing@@ s@@ Bytes ) { this . si@@ bl@@ ings = si@@ bl@@ ings ; this . si@@ bl@@ ing@@ s@@ Bytes = si@@ bl@@ ing@@ s@@ Bytes ; }
public Collection < Compute@@ Job@@ Sibling > job@@ Sib@@ l@@ ings ( ) { return si@@ bl@@ ings ; }
public void un@@ mar@@ sh@@ al@@ Sib@@ l@@ ings ( Mar@@ sh@@ al@@ ler mar@@ sh ) throws Ig@@ n@@ ite@@ Check@@ ed@@ Exception { assert mar@@ sh != null ; if ( si@@ bl@@ ing@@ s@@ Bytes != null ) si@@ bl@@ ings = mar@@ sh . un@@ mar@@ sh@@ al ( si@@ bl@@ ing@@ s@@ Bytes , null ) ; }
public void on@@ Ac@@ k@@ Received ( ) { }
public boolean write@@ To ( ByteBuffer buf , Message@@ Writer writer ) { writer . set@@ Buffer ( buf ) ; if ( ! writer . is@@ Header@@ Written ( ) ) { if ( ! writer . write@@ Header ( di@@ rect@@ Type ( ) , field@@ sCount ( ) ) ) return false ; writer . onHeader@@ Written ( ) ; } switch ( writer . state ( ) ) { case 0 : if ( ! writer . write@@ Byte@@ Array ( " si@@ bl@@ ing@@ s@@ Bytes " , si@@ bl@@ ing@@ s@@ Bytes ) ) return false ; writer . incre@@ ment@@ State ( ) ; } return true ; }
public boolean read@@ From ( ByteBuffer buf , Message@@ Reader reader ) { reader . set@@ Buffer ( buf ) ; if ( ! reader . before@@ Message@@ Read ( ) ) return false ; switch ( reader . state ( ) ) { case 0 : si@@ bl@@ ing@@ s@@ Bytes = reader . read@@ Byte@@ Array ( " si@@ bl@@ ing@@ s@@ Bytes " ) ; if ( ! reader . is@@ Last@@ Read ( ) ) return false ; reader . incre@@ ment@@ State ( ) ; } return reader . after@@ Message@@ Read ( Grid@@ Job@@ Sib@@ ling@@ s@@ Response . class ) ; }
public byte di@@ rect@@ Type ( ) { return 4 ; }
public byte field@@ sCount ( ) { return 1 ; }
public String toString ( ) { return S . toString ( Grid@@ Job@@ Sib@@ ling@@ s@@ Response . class , this ) ; }
public Style ( Disp@@ atch disp@@ atch ) { super ( disp@@ atch ) ; }
@ Before public void setup ( ) { cre@@ ator = new S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ gEn@@ h@@ et@@ Cre@@ ator ( ) ; parameters = new In@@ ty@@ g@@ Param@@ etr@@ ar ( 5 , Local@@ Date . parse ( "20@@ 16@@ -@@ 02@@ -@@ 16" ) ) ; }
@ Test public void test@@ Cre@@ ating@@ Map ( ) { Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create@@ Map ( int@@ y@@ g@@ Data@@ List , parameters ) ; assertTrue ( " Expected ▁ 7 ▁ bu@@ t ▁ was ▁ " + map . size ( ) , map . size ( ) == 7 ) ; }
@ Test public void test@@ Reduce@@ d@@ Map ( ) { Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create@@ Map ( int@@ y@@ g@@ Data@@ List , parameters ) ; Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > redu@@ ced@@ Map = cre@@ ator . redu@@ ce@@ Map ( map ) ; assertTrue ( " Expected ▁ 6 ▁ bu@@ t ▁ was ▁ " + redu@@ ced@@ Map . size ( ) , redu@@ ced@@ Map . size ( ) == 6 ) ; }
@ Test public void test@@ Sor@@ ted@@ Map ( ) { Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create@@ Map ( int@@ y@@ g@@ Data@@ List , parameters ) ; Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > sor@@ ted@@ Map = cre@@ ator . sort@@ Values ( map ) ; for ( Map . Entry < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > entry : sor@@ ted@@ Map . entrySet ( ) ) { if ( entry . getValue ( ) . size ( ) > 1 ) { S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g [ ] ar@@ r = entry . getValue ( ) . toArray ( new S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g [ entry . getValue ( ) . size ( ) ] ) ; for ( int i = 0 ; i < ar@@ r . length - 1 ; i ++ ) { assertTrue ( ar@@ r [ i ] . get@@ S@@ l@@ ut@@ D@@ atu@@ m ( ) . is@@ Before ( ar@@ r [ i + 1 ] . get@@ S@@ l@@ ut@@ D@@ atu@@ m ( ) ) ) ; } } } }
@ Test public void test@@ SetActive@@ C@@ erti@@ fic@@ ate ( ) { Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create@@ Map ( int@@ y@@ g@@ Data@@ List , parameters ) ; Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > active@@ Map = cre@@ ator . setActive ( map ) ; assertTrue ( active@@ Map . entrySet ( ) . stream ( ) . all@@ Match ( e -> e . getValue ( ) . stream ( ) . filter ( o -> o . is@@ A@@ k@@ tiv@@ t@@ In@@ ty@@ g ( ) ) . count ( ) < 2 ) ) ; }
@ Test public void test@@ F@@ all@@ 1 ( ) { String key = "@@ 19@@ 79@@ 11@@ 10@@ -@@ 92@@ 9@@ 1" ; Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create ( int@@ y@@ g@@ Data@@ List , parameters ) ; List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ bu@@ t ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assert@@ Start@@ Date ( list . get ( 0 ) , "20@@ 16@@ -@@ 02@@ -0@@ 1" ) ; assert@@ End@@ Date ( list . get ( 1 ) , "20@@ 16@@ -@@ 02@@ -@@ 20@@ " ) ; assertTrue ( list . get ( 1 ) . is@@ A@@ k@@ tiv@@ t@@ In@@ ty@@ g ( ) ) ; }
@ Test public void test@@ F@@ all@@ 2 ( ) { String key = "@@ 19@@ 79@@ 112@@ 3@@ -@@ 92@@ 62@@ " ; Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create ( int@@ y@@ g@@ Data@@ List , parameters ) ; List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ bu@@ t ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assert@@ Start@@ Date ( list . get ( 0 ) , "20@@ 16@@ -@@ 02@@ -0@@ 1" ) ; assert@@ End@@ Date ( list . get ( 1 ) , "20@@ 16@@ -@@ 02@@ -@@ 20@@ " ) ; assertTrue ( list . get ( 1 ) . is@@ A@@ k@@ tiv@@ t@@ In@@ ty@@ g ( ) ) ; }
@ Test public void test@@ F@@ all@@ 3 ( ) { String key = "@@ 19@@ 79@@ 12@@ 12@@ -@@ 92@@ 80@@ " ; Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create ( int@@ y@@ g@@ Data@@ List , parameters ) ; List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > list = map . get ( key ) ; assertTrue ( " Expected ▁ 3 ▁ bu@@ t ▁ was ▁ " + list . size ( ) , list . size ( ) == 3 ) ; assert@@ Start@@ Date ( list . get ( 0 ) , "20@@ 16@@ -@@ 02@@ -0@@ 1" ) ; assert@@ End@@ Date ( list . get ( 2 ) , "20@@ 16@@ -@@ 02@@ -@@ 25" ) ; assertTrue ( list . get ( 1 ) . is@@ A@@ k@@ tiv@@ t@@ In@@ ty@@ g ( ) ) ; }
@ Test public void test@@ F@@ all@@ 4 ( ) { String key = "@@ 198@@ 00@@ 11@@ 3@@ -@@ 92@@ 97@@ " ; Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create ( int@@ y@@ g@@ Data@@ List , parameters ) ; List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > list = map . get ( key ) ; assertTrue ( " Expected ▁ 3 ▁ bu@@ t ▁ was ▁ " + list . size ( ) , list . size ( ) == 3 ) ; assert@@ Start@@ Date ( list . get ( 0 ) , "20@@ 16@@ -@@ 02@@ -0@@ 1" ) ; assert@@ End@@ Date ( list . get ( 2 ) , "20@@ 16@@ -@@ 02@@ -@@ 25" ) ; assertTrue ( list . get ( 1 ) . is@@ A@@ k@@ tiv@@ t@@ In@@ ty@@ g ( ) ) ; }
@ Test public void test@@ F@@ all@@ 5 ( ) { String key = "@@ 198@@ 00@@ 12@@ 4@@ -@@ 9@@ 28@@ 6" ; Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create ( int@@ y@@ g@@ Data@@ List , parameters ) ; List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ bu@@ t ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assert@@ Start@@ Date ( list . get ( 0 ) , "20@@ 16@@ -@@ 02@@ -@@ 12" ) ; assert@@ End@@ Date ( list . get ( 1 ) , "20@@ 16@@ -@@ 02@@ -@@ 25" ) ; assertTrue ( list . get ( 0 ) . is@@ A@@ k@@ tiv@@ t@@ In@@ ty@@ g ( ) ) ; assertFalse ( list . get ( 1 ) . is@@ A@@ k@@ tiv@@ t@@ In@@ ty@@ g ( ) ) ; }
@ Test public void test@@ F@@ all@@ 6 ( ) { String key = "@@ 198@@ 00@@ 20@@ 7@@ -@@ 92@@ 94@@ " ; Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create ( int@@ y@@ g@@ Data@@ List , parameters ) ; List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ bu@@ t ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assert@@ Start@@ Date ( list . get ( 0 ) , "20@@ 16@@ -@@ 02@@ -@@ 12" ) ; assert@@ End@@ Date ( list . get ( 1 ) , "20@@ 16@@ -@@ 02@@ -@@ 25" ) ; assertFalse ( list . get ( 0 ) . is@@ A@@ k@@ tiv@@ t@@ In@@ ty@@ g ( ) ) ; assertTrue ( list . get ( 1 ) . is@@ A@@ k@@ tiv@@ t@@ In@@ ty@@ g ( ) ) ; }
@ Test public void test@@ F@@ all@@ 7 ( ) { String key = "@@ 198@@ 00@@ 22@@ 8-@@ 9@@ 22@@ 4" ; Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create ( int@@ y@@ g@@ Data@@ List , parameters ) ; assertNull ( map . get ( key ) ) ; }
protected Collection < Request@@ Handler > create@@ Request@@ Handlers ( ) { return Immutable@@ Set . of ( new T@@ un@@ n@@ el@@ Data@@ Request@@ Handler ( ) ) ; }
public T@@ un@@ n@@ el@@ Data@@ Request@@ Handler ( ) { super ( T@@ UN@@ N@@ EL_@@ DATA_@@ REQ , T@@ UN@@ N@@ EL_@@ DATA_@@ RES@@ P , T@@ UN@@ N@@ EL@@ S ) ; }
protected String [ ] get@@ Column@@ Ids ( ) { return COL_@@ ID@@ S ; }
protected String no@@ Row@@ s@@ Message ( Object@@ Node payload ) { return NO_@@ RO@@ WS_@@ MESSA@@ GE ; }
protected Table@@ Model create@@ Table@@ Model ( ) { Table@@ Model tm = super . create@@ Table@@ Model ( ) ; tm . set@@ Formatter ( ONE , T@@ un@@ n@@ el@@ End@@ Point@@ Formatter . INSTANCE ) ; tm . set@@ Formatter ( TW@@ O , T@@ un@@ n@@ el@@ End@@ Point@@ Formatter . INSTANCE ) ; tm . set@@ Formatter ( TYPE , Enum@@ Formatter . INSTANCE ) ; return tm ; }
protected void pop@@ ulate@@ Table ( Table@@ Model tm , Object@@ Node payload ) { T@@ un@@ n@@ el@@ Service ts = get ( T@@ un@@ n@@ el@@ Service . class ) ; ts . query@@ All@@ T@@ un@@ n@@ els ( ) . for@@ E@@ ach ( tun@@ nel -> pop@@ ulate@@ Row ( tm . add@@ Row ( ) , tun@@ nel ) ) ; }
private void pop@@ ulate@@ Row ( Table@@ Model . Row row , T@@ un@@ nel tun@@ nel ) { row . cell ( ID , tun@@ nel . tun@@ n@@ el@@ Id ( ) . id ( ) ) . cell ( NAME , tun@@ nel . tun@@ n@@ el@@ Name ( ) . value ( ) ) . cell ( ONE , tun@@ nel . src ( ) ) . cell ( TW@@ O , tun@@ nel . dst ( ) ) . cell ( TYPE , tun@@ nel . type ( ) ) . cell ( GROUP_@@ ID , tun@@ nel . group@@ Id ( ) . id ( ) ) . cell ( B@@ AND@@ WID@@ TH , tun@@ nel . annotations ( ) . value ( B@@ AND@@ WID@@ TH ) ) . cell ( PATH , tun@@ nel . path ( ) ) ; }
@ Before public void start@@ up ( ) { server = Ap@@ ns@@ Utils . prepare@@ And@@ Start@@ Server ( Test@@ Constants . TEST_@@ G@@ AT@@ E@@ WA@@ Y_@@ PORT , Test@@ Constants . TEST_@@ FEE@@ DB@@ ACK_@@ PORT ) ; }
@ After public void stop ( ) { server . stop ( ) ; }
@ Test ( timeout = 5000 ) public void test@@ Produc@@ er ( ) throws Exception { String message = " Hello ▁ World " ; String message@@ Payload = AP@@ NS . new@@ Payload ( ) . al@@ er@@ t@@ Bo@@ dy ( message ) . build ( ) ; En@@ h@@ ance@@ d@@ Ap@@ ns@@ Notification ap@@ ns@@ Notification = new En@@ h@@ ance@@ d@@ Ap@@ ns@@ Notification ( 1 , En@@ h@@ ance@@ d@@ Ap@@ ns@@ Notification . MAX@@ IM@@ UM@@ _@@ EXP@@ IR@@ Y , F@@ A@@ KE_@@ TO@@ KEN , message@@ Payload ) ; server . stop@@ At ( ap@@ ns@@ Notification . length ( ) ) ; template . send@@ Bo@@ dy ( " di@@ rect : test " , message ) ; server . get@@ Messages ( ) . ac@@ qu@@ ir@@ e ( ) ; assert@@ Array@@ Equals ( ap@@ ns@@ Notification . mar@@ sh@@ all ( ) , server . get@@ Received ( ) . to@@ Byte@@ Array ( ) ) ; }
@ Test ( timeout = 5000 ) public void test@@ Produc@@ erWith@@ Ap@@ ns@@ Notification ( ) throws InterruptedException { String message = " Hello ▁ World " ; String message@@ Payload = AP@@ NS . new@@ Payload ( ) . al@@ er@@ t@@ Bo@@ dy ( message ) . build ( ) ; final En@@ h@@ ance@@ d@@ Ap@@ ns@@ Notification ap@@ ns@@ Notification = new En@@ h@@ ance@@ d@@ Ap@@ ns@@ Notification ( 14 , En@@ h@@ ance@@ d@@ Ap@@ ns@@ Notification . MAX@@ IM@@ UM@@ _@@ EXP@@ IR@@ Y , F@@ A@@ KE_@@ TO@@ KEN , message@@ Payload ) ; server . stop@@ At ( ap@@ ns@@ Notification . length ( ) ) ; template . send@@ Bo@@ dy ( " di@@ rect : test@@ With@@ Ap@@ ns@@ Notification " , ap@@ ns@@ Notification ) ; server . get@@ Messages ( ) . ac@@ qu@@ ir@@ e ( ) ; assert@@ Array@@ Equals ( ap@@ ns@@ Notification . mar@@ sh@@ all ( ) , server . get@@ Received ( ) . to@@ Byte@@ Array ( ) ) ; }
protected Cam@@ elContext create@@ Cam@@ elContext ( ) throws Exception { Cam@@ elContext camel@@ Context = super . create@@ Cam@@ elContext ( ) ; Ap@@ ns@@ Service@@ Factory ap@@ ns@@ Service@@ Factory = Ap@@ ns@@ Utils . create@@ Default@@ Test@@ Configuration ( camel@@ Context ) ; Ap@@ ns@@ Service ap@@ ns@@ Service = ap@@ ns@@ Service@@ Factory . get@@ Ap@@ ns@@ Service ( ) ; Ap@@ ns@@ Component ap@@ ns@@ Component = new Ap@@ ns@@ Component ( ap@@ ns@@ Service ) ; camel@@ Context . add@@ Component ( " ap@@ ns " , ap@@ ns@@ Component ) ; return camel@@ Context ; }
protected Route@@ Builder create@@ Route@@ Builder ( ) throws Exception { return new Route@@ Builder ( ) { public void configure ( ) throws Exception { from ( " di@@ rect : test " ) . set@@ Header ( Ap@@ ns@@ Constants . HE@@ ADER_@@ TO@@ K@@ EN@@ S , constant ( F@@ A@@ KE_@@ TO@@ KEN ) ) . to ( " ap@@ ns : notify " ) ; from ( " di@@ rect : test@@ With@@ Ap@@ ns@@ Notification " ) . set@@ Header ( Ap@@ ns@@ Constants . HE@@ ADER_@@ MESSA@@ GE_@@ TYPE , constant ( MessageType . AP@@ NS_@@ NO@@ TI@@ F@@ IC@@ ATION . name ( ) ) ) . to ( " ap@@ ns : notify " ) ; } } ; }
@ Data@@ Bound@@ Constructor public ListView ( String name ) { super ( name ) ; init@@ Columns ( ) ; init@@ Job@@ Fil@@ ters ( ) ; }
public ListView ( String name , ViewGroup owner ) { this ( name ) ; this . owner = owner ; }
private Object read@@ Resolve ( ) { if ( include@@ Reg@@ ex != null ) { try { include@@ Pattern = Pattern . compile ( include@@ Reg@@ ex ) ; } catch ( Pattern@@ Syntax@@ Exception x ) { include@@ Reg@@ ex = null ; Old@@ Data@@ Monitor . report ( this , Collections . < Throwable > singleton ( x ) ) ; } } if ( job@@ Names == null ) { job@@ Names = new Tree@@ Set < String > ( Case@@ Insen@@ sitive@@ Comparator . INSTANCE ) ; } init@@ Columns ( ) ; init@@ Job@@ Fil@@ ters ( ) ; return this ; }
protected void init@@ Columns ( ) { if ( columns == null ) columns = new Descri@@ b@@ able@@ List < ListView@@ Column , Descriptor < ListView@@ Column > > ( this , ListView@@ Column . create@@ Default@@ Initial@@ Column@@ List ( ) ) ; }
protected void init@@ Job@@ Fil@@ ters ( ) { if ( job@@ Fil@@ ters == null ) job@@ Fil@@ ters = new Descri@@ b@@ able@@ List < View@@ Job@@ Filter , Descriptor < View@@ Job@@ Filter > > ( this ) ; }
public boolean has@@ Job@@ Filter@@ Extensions ( ) { return ! View@@ Job@@ Filter . all ( ) . isEmpty ( ) ; }
public Descri@@ b@@ able@@ List < View@@ Job@@ Filter , Descriptor < View@@ Job@@ Filter > > getJob@@ Fil@@ ters ( ) { return job@@ Fil@@ ters ; }
public Descri@@ b@@ able@@ List < ListView@@ Column , Descriptor < ListView@@ Column > > get@@ Columns ( ) { return columns ; }
public List < TopLevel@@ Item > get@@ Items ( ) { Sor@@ ted@@ Set < String > names ; List < TopLevel@@ Item > items = new ArrayList < TopLevel@@ Item > ( ) ; synchronized ( this ) { names = new Tree@@ Set < String > ( job@@ Names ) ; } Item@@ Group < ? extends TopLevel@@ Item > parent = get@@ Owner@@ Item@@ Group ( ) ; List < TopLevel@@ Item > parent@@ Items = new ArrayList < TopLevel@@ Item > ( parent . get@@ Items ( ) ) ; include@@ Items ( parent , parent@@ Items , names ) ; Boolean statu@@ s@@ Filter = this . statu@@ s@@ Filter ; Iter@@ able < ? extends TopLevel@@ Item > cand@@ id@@ ates ; if ( re@@ curse ) { cand@@ id@@ ates = Items . getAll@@ Items ( parent , TopLevel@@ Item . class ) ; } else { cand@@ id@@ ates = parent . get@@ Items ( ) ; } for ( TopLevel@@ Item item : cand@@ id@@ ates ) { if ( ! names . contains ( item . getRelative@@ Name@@ From ( get@@ Owner@@ Item@@ Group ( ) ) ) ) continue ; if ( statu@@ s@@ Filter == null || ! ( item instanceof Abstract@@ Project ) || ( ( Abstract@@ Project ) item ) . is@@ Disabled ( ) ^ statu@@ s@@ Filter ) items . add ( item ) ; } Iter@@ able < View@@ Job@@ Filter > job@@ Fil@@ ters = getJob@@ Fil@@ ters ( ) ; List < TopLevel@@ Item > all@@ Items = new ArrayList < TopLevel@@ Item > ( parent@@ Items ) ; if ( re@@ curse ) all@@ Items = expand ( all@@ Items , new ArrayList < TopLevel@@ Item > ( ) ) ; for ( View@@ Job@@ Filter job@@ Filter : job@@ Fil@@ ters ) { items = job@@ Filter . filter ( items , all@@ Items , this ) ; } items = new ArrayList < TopLevel@@ Item > ( new Link@@ ed@@ Hash@@ Set < TopLevel@@ Item > ( items ) ) ; return items ; }
private List < TopLevel@@ Item > expand ( Collection < TopLevel@@ Item > items , List < TopLevel@@ Item > all@@ Items ) { for ( TopLevel@@ Item item : items ) { if ( item instanceof Item@@ Group ) { Item@@ Group < ? extends Item > i@@ g = ( Item@@ Group < ? extends Item > ) item ; expand ( Util . filter ( i@@ g . get@@ Items ( ) , TopLevel@@ Item . class ) , all@@ Items ) ; } all@@ Items . add ( item ) ; } return all@@ Items ; }
public boolean contains ( TopLevel@@ Item item ) { return get@@ Items ( ) . contains ( item ) ; }
private void include@@ Items ( Item@@ Group < ? extends TopLevel@@ Item > root , Collection < ? extends Item > parent@@ Items , Sor@@ ted@@ Set < String > names ) { if ( include@@ Pattern != null ) { for ( Item item : parent@@ Items ) { if ( re@@ curse && item instanceof Item@@ Group ) { Item@@ Group < ? > i@@ g = ( Item@@ Group < ? > ) item ; include@@ Items ( root , i@@ g . get@@ Items ( ) , names ) ; } if ( item instanceof TopLevel@@ Item ) { String itemName = item . getRelative@@ Name@@ From ( root ) ; if ( include@@ Pattern . match@@ er ( itemName ) . matches ( ) ) { names . add ( itemName ) ; } } } } }
public synchronized boolean job@@ N@@ ames@@ Contain@@ s ( TopLevel@@ Item item ) { if ( item == null ) return false ; return job@@ Names . contains ( item . getRelative@@ Name@@ From ( get@@ Owner@@ Item@@ Group ( ) ) ) ; }
public void add ( TopLevel@@ Item item ) throws IOException { synchronized ( this ) { job@@ Names . add ( item . getRelative@@ Name@@ From ( get@@ Owner@@ Item@@ Group ( ) ) ) ; } save ( ) ; }
public boolean remove ( TopLevel@@ Item item ) throws IOException { synchronized ( this ) { String name = item . getRelative@@ Name@@ From ( get@@ Owner@@ Item@@ Group ( ) ) ; if ( ! job@@ Names . remove ( name ) ) return false ; } save ( ) ; return true ; }
public String getIn@@ clude@@ Reg@@ ex ( ) { return include@@ Reg@@ ex ; }
public boolean is@@ Rec@@ ur@@ se ( ) { return re@@ curse ; }
public void set@@ Rec@@ ur@@ se ( boolean re@@ curse ) { this . re@@ curse = re@@ curse ; }
public Boolean get@@ Status@@ Filter ( ) { return statu@@ s@@ Filter ; }
if ( i@@ g instanceof Modi@@ fiable@@ Item@@ Group ) { TopLevel@@ Item item = ( ( Modi@@ fiable@@ Item@@ Group < ? extends TopLevel@@ Item > ) i@@ g ) . do@@ Create@@ Item ( req , r@@ sp ) ; if ( item != null ) { synchronized ( this ) { job@@ Names . add ( item . getRelative@@ Name@@ From ( get@@ Owner@@ Item@@ Group ( ) ) ) ; } owner . save ( ) ; } return item ; }
private TopLevel@@ Item resolve@@ Name ( String name ) { TopLevel@@ Item item = get@@ Owner@@ Item@@ Group ( ) . getItem ( name ) ; if ( item == null ) { name = Items . getCanonicalName ( get@@ Owner@@ Item@@ Group ( ) , name ) ; item = J@@ enk@@ ins . getInstance ( ) . getItem@@ By@@ Full@@ Name ( name , TopLevel@@ Item . class ) ; } return item ; }
synchronized ( this ) { re@@ curse = json . opt@@ Boolean ( " re@@ curse " , true ) ; job@@ Names . clear ( ) ; Iter@@ able < ? extends TopLevel@@ Item > items ; if ( re@@ curse ) { items = Items . getAll@@ Items ( get@@ Owner@@ Item@@ Group ( ) , TopLevel@@ Item . class ) ; } else { items = get@@ Owner@@ Item@@ Group ( ) . get@@ Items ( ) ; } for ( TopLevel@@ Item item : items ) { String relative@@ Name@@ From = item . getRelative@@ Name@@ From ( get@@ Owner@@ Item@@ Group ( ) ) ; if ( req . getParam@@ eter ( relative@@ Name@@ From ) != null ) { job@@ Names . add ( relative@@ Name@@ From ) ; } } }
if ( columns == null ) { columns = new Descri@@ b@@ able@@ List < ListView@@ Column , Descriptor < ListView@@ Column > > ( this ) ; }
if ( job@@ Fil@@ ters == null ) { job@@ Fil@@ ters = new Descri@@ b@@ able@@ List < View@@ Job@@ Filter , Descriptor < View@@ Job@@ Filter > > ( this ) ; }
public void set@@ Include@@ Reg@@ ex ( String include@@ Reg@@ ex ) { this . include@@ Reg@@ ex = Util . nul@@ lify ( include@@ Reg@@ ex ) ; if ( this . include@@ Reg@@ ex == null ) this . include@@ Pattern = null ; else this . include@@ Pattern = Pattern . compile ( include@@ Reg@@ ex ) ; }
public String getDisplayName ( ) { return Messages . ListView@@ _@@ DisplayName ( ) ; }
if ( v != null ) { try { Pattern . compile ( v ) ; } catch ( Pattern@@ Syntax@@ Exception p@@ se ) { return Form@@ Valid@@ ation . error ( p@@ se . getMessage ( ) ) ; } }
public void on@@ Location@@ Changed ( final Item item , final String old@@ Full@@ Name , final String new@@ Full@@ Name ) { AC@@ L . imp@@ er@@ son@@ ate ( AC@@ L . SYSTE@@ M , new Runnable ( ) { @ Override public void run ( ) { location@@ Changed ( item , old@@ Full@@ Name , new@@ Full@@ Name ) ; } } ) ; }
private void location@@ Changed ( Item item , String old@@ Full@@ Name , String new@@ Full@@ Name ) { final J@@ enk@@ ins j@@ enk@@ ins = J@@ enk@@ ins . getInstance ( ) ; for ( View view : j@@ enk@@ ins . getView@@ s ( ) ) { if ( view instanceof ListView ) { ren@@ ame@@ View@@ Item ( old@@ Full@@ Name , new@@ Full@@ Name , j@@ enk@@ ins , ( ListView ) view ) ; } } for ( Item g : j@@ enk@@ ins . getAll@@ Items ( ) ) { if ( g instanceof ViewGroup ) { ViewGroup v@@ g = ( ViewGroup ) g ; for ( View v : v@@ g . getView@@ s ( ) ) { if ( v instanceof ListView ) { ren@@ ame@@ View@@ Item ( old@@ Full@@ Name , new@@ Full@@ Name , v@@ g , ( ListView ) v ) ; } } } } }
private void ren@@ ame@@ View@@ Item ( String old@@ Full@@ Name , String new@@ Full@@ Name , ViewGroup v@@ g , ListView lv ) { boolean need@@ s@@ Save ; synchronized ( lv ) { Set < String > old@@ Job@@ Names = new Hash@@ Set < String > ( lv . job@@ Names ) ; lv . job@@ Names . clear ( ) ; for ( String old@@ Name : old@@ Job@@ Names ) { lv . job@@ Names . add ( Items . compute@@ Relative@@ N@@ ames@@ After@@ Ren@@ am@@ ing ( old@@ Full@@ Name , new@@ Full@@ Name , old@@ Name , v@@ g . getItem@@ Group ( ) ) ) ; } need@@ s@@ Save = ! old@@ Job@@ Names . equals ( lv . job@@ Names ) ; } if ( need@@ s@@ Save ) { try { lv . save ( ) ; } catch ( IOException x ) { Logger . getLogger ( ListView . class . getName ( ) ) . log ( Level . WARNING , null , x ) ; } } }
public void on@@ Deleted ( final Item item ) { AC@@ L . imp@@ er@@ son@@ ate ( AC@@ L . SYSTE@@ M , new Runnable ( ) { @ Override public void run ( ) { del@@ eted ( item ) ; } } ) ; }
private void del@@ eted ( Item item ) { final J@@ enk@@ ins j@@ enk@@ ins = J@@ enk@@ ins . getInstance ( ) ; for ( View view : j@@ enk@@ ins . getView@@ s ( ) ) { if ( view instanceof ListView ) { delete@@ View@@ Item ( item , j@@ enk@@ ins , ( ListView ) view ) ; } } for ( Item g : j@@ enk@@ ins . getAll@@ Items ( ) ) { if ( g instanceof ViewGroup ) { ViewGroup v@@ g = ( ViewGroup ) g ; for ( View v : v@@ g . getView@@ s ( ) ) { if ( v instanceof ListView ) { delete@@ View@@ Item ( item , v@@ g , ( ListView ) v ) ; } } } } }
private void delete@@ View@@ Item ( Item item , ViewGroup v@@ g , ListView lv ) { boolean need@@ s@@ Save ; synchronized ( lv ) { need@@ s@@ Save = lv . job@@ Names . remove ( item . getRelative@@ Name@@ From ( v@@ g . getItem@@ Group ( ) ) ) ; } if ( need@@ s@@ Save ) { try { lv . save ( ) ; } catch ( IOException x ) { Logger . getLogger ( ListView . class . getName ( ) ) . log ( Level . WARNING , null , x ) ; } } }
