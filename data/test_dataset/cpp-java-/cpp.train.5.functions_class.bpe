Id Id :: Node ( uint64_t id ) { return Id ( id | NODE ) ; }
Id Id :: Way ( uint64_t id ) { return Id ( id | WAY ) ; }
Id Id :: Relation ( uint64_t id ) { return Id ( id | RELATION ) ; }
std :: string DebugPrint ( osm :: Id const & id ) { std :: ostringstream stream ; stream << id . Type ( ) << " ▁ " << id . OsmId ( ) ; return stream . str ( ) ; }
String XMLSerializer :: serializeTo@@ String ( Node * node , ExceptionCode & ec ) { if ( ! node ) return String ( ) ; if ( ! node -> document ( ) ) { ASSERT ( node -> nodeType ( ) == Node :: DOCUMENT_TYPE_@@ NODE ) ; ec = INVALID_ACCESS_@@ ERR ; return String ( ) ; } return createMark@@ up ( node ) ; }
return std :: count_if ( m_employees . cbegin ( ) , m_employees . cend ( ) , [ this , & teamName ] ( const Person & p ) { return teamNameFor ( p ) == teamName ; }
QgsFieldValidator :: QgsFieldValidator ( QObject * parent , const QgsField & field , QString dateFormat ) : QValidator ( parent ) , mField ( field ) , mDateFormat ( dateFormat ) { switch ( mField . type ( ) ) { case QVariant :: Int : { if ( mField . length ( ) > 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } " ) . arg ( mField . length ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else { mValidator = new QIntValidator ( parent ) ; } } break ; case QVariant :: Double : { if ( mField . length ( ) > 0 && mField . precision ( ) > 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } ( \\ . \\d { 0 , % 2 } ) ? " ) . arg ( mField . length ( ) - mField . precision ( ) ) . arg ( mField . precision ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else if ( mField . length ( ) > 0 && mField . precision ( ) == 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } " ) . arg ( mField . length ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else if ( mField . precision ( ) > 0 ) { QString re = QString ( " - ? \\d * ( \\ . \\d { 0 , % 1 } ) ? " ) . arg ( mField . precision ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else { mValidator = new QDoubleValidator ( parent ) ; } } break ; case QVariant :: LongLong : mValidator = new QgsLong@@ LongValidator ( parent ) ; break ; default : mValidator = 0 ; } QSettings settings ; mNullValue = settings . value ( " qgis / nullValue " , " NULL " ) . toString ( ) ; }
QgsFieldValidator :: ~ QgsFieldValidator ( ) { delete mValidator ; }
IcoSphere :: IcoSphere ( unsigned int levels ) { for ( int i = 0 ; i < 12 ; i ++ ) mVertices . push_back ( Map < Vector3f > ( vdata [ i ] ) ) ; mIndices . push_back ( new std :: vector < int > ) ; std :: vector < int > & indices = * mIndices . back ( ) ; for ( int i = 0 ; i < 20 ; i ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) indices . push_back ( tindices [ i ] [ k ] ) ; } mListIds . push_back ( 0 ) ; while ( mIndices . size ( ) < levels ) _subdivide ( ) ; }
void IcoSphere :: _subdivide ( void ) { typedef unsigned long long Key ; std :: map < Key , int > edgeMap ; const std :: vector < int > & indices = * mIndices . back ( ) ; mIndices . push_back ( new std :: vector < int > ) ; std :: vector < int > & refinedIndices = * mIndices . back ( ) ; int end = indices . size ( ) ; for ( int i = 0 ; i < end ; i += 3 ) { int ids0 [ 3 ] , ids1 [ 3 ] ; for ( int k = 0 ; k < 3 ; ++ k ) { int k1 = ( k + 1 ) % 3 ; int e0 = indices [ i + k ] ; int e1 = indices [ i + k1 ] ; ids0 [ k ] = e0 ; if ( e1 > e0 ) std :: swap ( e0 , e1 ) ; Key edgeKey = Key ( e0 ) | ( Key ( e1 ) << 32 ) ; std :: map < Key , int > :: iterator it = edgeMap . find ( edgeKey ) ; if ( it == edgeMap . end ( ) ) { ids1 [ k ] = mVertices . size ( ) ; edgeMap [ edgeKey ] = ids1 [ k ] ; mVertices . push_back ( ( mVertices [ e0 ] + mVertices [ e1 ] ) . normalized ( ) ) ; } else ids1 [ k ] = it -> second ; } refinedIndices . push_back ( ids0 [ 0 ] ) ; refinedIndices . push_back ( ids1 [ 0 ] ) ; refinedIndices . push_back ( ids1 [ 2 ] ) ; refinedIndices . push_back ( ids0 [ 1 ] ) ; refinedIndices . push_back ( ids1 [ 1 ] ) ; refinedIndices . push_back ( ids1 [ 0 ] ) ; refinedIndices . push_back ( ids0 [ 2 ] ) ; refinedIndices . push_back ( ids1 [ 2 ] ) ; refinedIndices . push_back ( ids1 [ 1 ] ) ; refinedIndices . push_back ( ids1 [ 0 ] ) ; refinedIndices . push_back ( ids1 [ 1 ] ) ; refinedIndices . push_back ( ids1 [ 2 ] ) ; } mListIds . push_back ( 0 ) ; }
void IcoSphere :: draw ( int level ) { while ( level >= int ( mIndices . size ( ) ) ) const_cast < IcoSphere * > ( this ) -> _subdivide ( ) ; if ( mListIds [ level ] == 0 ) { mListIds [ level ] = glGenLists ( 1 ) ; glNew@@ List ( mListIds [ level ] , GL_COMPIL@@ E ) ; glVertexPointer ( 3 , GL_FLOAT , 0 , mVertices [ 0 ] . data ( ) ) ; glNor@@ malPointer ( GL_FLOAT , 0 , mVertices [ 0 ] . data ( ) ) ; glEnableClientState ( GL_VERTEX_ARRAY ) ; glEnableClientState ( GL_NORMAL_ARRAY ) ; glDrawElements ( GL_TRIANG@@ LES , mIndices [ level ] -> size ( ) , GL_UNSIGN@@ ED_INT , & ( mIndices [ level ] -> at ( 0 ) ) ) ; glDisableClientState ( GL_VERTEX_ARRAY ) ; glDisableClientState ( GL_NORMAL_ARRAY ) ; glEnd@@ List ( ) ; } glCall@@ List ( mListIds [ level ] ) ; }
mscorlib :: System :: String SoapNmtoken :: GetXsdType ( ) { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " GetXsdType " , __native_object__ , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; }
mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken SoapNmtoken :: Parse ( mscorlib :: System :: String value ) { MonoType * __parameter_types__ [ 1 ] ; void * __parameters__ [ 1 ] ; __parameter_types__ [ 0 ] = Global :: GetType ( typeid ( value ) . name ( ) ) ; __parameters__ [ 0 ] = ( MonoObject * ) value ; MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " Parse " , NullMonoObject , 1 , __parameter_types__ , __parameters__ , NULL ) ; return mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken ( __result__ ) ; }
mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken SoapNmtoken :: Parse ( const char * value ) { MonoType * __parameter_types__ [ 1 ] ; void * __parameters__ [ 1 ] ; __parameter_types__ [ 0 ] = Global :: GetType ( " mscorlib " , " System " , " String " ) ; __parameters__ [ 0 ] = mono_@@ string_new ( Global :: GetDomain ( ) , value ) ; MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " Parse " , NullMonoObject , 1 , __parameter_types__ , __parameters__ , NULL ) ; return mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken ( __result__ ) ; }
mscorlib :: System :: String SoapNmtoken :: ToString ( ) { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " ToString " , __native_object__ , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; }
void SoapNmtoken :: set_Value ( mscorlib :: System :: String value ) { MonoType * __parameter_types__ [ 1 ] ; void * __parameters__ [ 1 ] ; __parameter_types__ [ 0 ] = Global :: GetType ( typeid ( value ) . name ( ) ) ; __parameters__ [ 0 ] = ( MonoObject * ) value ; Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " set _ Value " , __native_object__ , 1 , __parameter_types__ , __parameters__ , NULL ) ; }
mscorlib :: System :: String SoapNmtoken :: get_XsdType ( ) { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " get _ XsdType " , NullMonoObject , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; }
void SoapNmtoken :: set_XsdType ( mscorlib :: System :: String value ) { throw ; }
UINT32 mm1_state :: screen_update ( screen_device & screen , bitmap_@@ rgb32 & bitmap , const rectangle & cliprect ) { m_crtc -> screen_update ( screen , bitmap , cliprect ) ; m_hgdc -> screen_update ( screen , bitmap , cliprect ) ; return 0 ; }
void VM_CMS_Operation :: acquire_pending_list_lock ( ) { ConcurrentMarkSweepThread :: slt ( ) -> manipulatePLL ( SurrogateLockerThread :: acquirePLL ) ; }
void VM_CMS_Operation :: release_and_notify_pending_list_lock ( ) { ConcurrentMarkSweepThread :: slt ( ) -> manipulatePLL ( SurrogateLockerThread :: releaseAndNotify@@ PLL ) ; }
void VM_CMS_Operation :: verify_before_gc ( ) { if ( VerifyBefore@@ GC && GenCollectedHeap :: heap ( ) -> total_collections ( ) >= VerifyGCStartAt ) { GCTraceTime tm ( " Verify ▁ Before " , false , false , _collector -> _gc_timer_cm ) ; HandleMark hm ; FreelistLocker x ( _collector ) ; MutexLockerEx y ( _collector -> bitMapLock ( ) , Mutex :: _no_safepoint_check_flag ) ; Universe :: heap ( ) -> prepare_for_@@ verify ( ) ; Universe :: verify ( ) ; } }
void VM_CMS_Operation :: verify_after_gc ( ) { if ( VerifyAfter@@ GC && GenCollectedHeap :: heap ( ) -> total_collections ( ) >= VerifyGCStartAt ) { GCTraceTime tm ( " Verify ▁ After " , false , false , _collector -> _gc_timer_cm ) ; HandleMark hm ; FreelistLocker x ( _collector ) ; MutexLockerEx y ( _collector -> bitMapLock ( ) , Mutex :: _no_safepoint_check_flag ) ; Universe :: verify ( ) ; } }
bool VM_CMS_Operation :: doit_prologue ( ) { assert ( Thread :: current ( ) -> is_ConcurrentGC_thread ( ) , " just ▁ checking " ) ; assert ( ! CMSCollector :: foregroundGCShouldWait ( ) , " Possible ▁ deadlock " ) ; assert ( ! ConcurrentMarkSweepThread :: cms_thread_has_cms_token ( ) , " Possible ▁ deadlock " ) ; if ( needs_pll ( ) ) { acquire_pending_list_lock ( ) ; } Heap_lock -> lock ( ) ; if ( lost_race ( ) ) { assert ( _prologue_succeeded == false , " Initialized ▁ in ▁ c ' tor " ) ; Heap_lock -> unlock ( ) ; if ( needs_pll ( ) ) { release_and_notify_pending_list_lock ( ) ; } } else { _prologue_succeeded = true ; } return _prologue_succeeded ; }
void VM_CMS_Operation :: doit_epilogue ( ) { assert ( Thread :: current ( ) -> is_ConcurrentGC_thread ( ) , " just ▁ checking " ) ; assert ( ! CMSCollector :: foregroundGCShouldWait ( ) , " Possible ▁ deadlock " ) ; assert ( ! ConcurrentMarkSweepThread :: cms_thread_has_cms_token ( ) , " Possible ▁ deadlock " ) ; Heap_lock -> unlock ( ) ; if ( needs_pll ( ) ) { release_and_notify_pending_list_lock ( ) ; } }
void VM_CMS_Initial_Mark :: doit ( ) { if ( lost_race ( ) ) { return ; } HS_DTRACE_PROBE ( hs_private , cms__initmark__begin ) ; HS_PRIVATE_CMS_INITMARK_BEGIN ( ) ; _collector -> _gc_timer_cm -> register_gc_pause_start ( " Initial ▁ Mark " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; GCCauseSetter gccs ( gch , GCCause :: _cms_initial_@@ mark ) ; VM_CMS_Operation :: verify_before_gc ( ) ; IsGCActiveMark x ; _collector -> do_CMS_operation ( CMSCollector :: CMS_op_checkpointRootsInitial , gch -> gc_cause ( ) ) ; VM_CMS_Operation :: verify_after_gc ( ) ; _collector -> _gc_timer_cm -> register_gc_pause_end ( ) ; HS_DTRACE_PROBE ( hs_private , cms__initmark__end ) ; HS_PRIVATE_CMS_INITMARK_END ( ) ; }
void VM_CMS@@ _Final_@@ Remark :: doit ( ) { if ( lost_race ( ) ) { return ; } HS_DTRACE_PROBE ( hs_private , cms__remark__begin ) ; HS_PRIVATE_CMS_REMARK_BEGIN ( ) ; _collector -> _gc_timer_cm -> register_gc_pause_start ( " Final ▁ Mark " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; GCCauseSetter gccs ( gch , GCCause :: _cms_final_remark ) ; VM_CMS_Operation :: verify_before_gc ( ) ; IsGCActiveMark x ; _collector -> do_CMS_operation ( CMSCollector :: CMS_op_checkpointRootsFinal , gch -> gc_cause ( ) ) ; VM_CMS_Operation :: verify_after_gc ( ) ; _collector -> save_he@@ ap_summary ( ) ; _collector -> _gc_timer_cm -> register_gc_pause_end ( ) ; HS_DTRACE_PROBE ( hs_private , cms__remark__end ) ; HS_PRIVATE_CMS_REMARK_END ( ) ; }
void VM_GenCollectFullConcurrent :: doit ( ) { assert ( Thread :: current ( ) -> is_VM_thread ( ) , " Should ▁ be ▁ VM ▁ thread " ) ; assert ( GCLocker@@ InvokesConcurrent || ExplicitGCInvokesConcurrent , " Unexpected " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; if ( _gc_count_before == gch -> total_collections ( ) ) { assert ( SafepointSyn@@ chronize :: is_at_safepoint ( ) , " We ▁ can ▁ only ▁ be ▁ executing ▁ this ▁ arm ▁ of ▁ if ▁ at ▁ a ▁ safepoint " ) ; GCCauseSetter gccs ( gch , _gc_cause ) ; gch -> do_full_collection ( gch -> must_clear_all@@ _sof@@ t_ref@@ s ( ) , 0 ) ; } assert ( ( _gc_count_before < gch -> total_collections ( ) ) || ( GC_locker :: is_active ( ) && ( _gc_count_before == gch -> total_collections ( ) ) ) , " total _ collections ( ) ▁ should ▁ be ▁ monotonically ▁ increasing " ) ; MutexLockerEx x ( FullGCCount_lock , Mutex :: _no_safepoint_check_flag ) ; assert ( _full_gc_count_before <= gch -> total_full_collections ( ) , " Error " ) ; if ( gch -> total_full_collections ( ) == _full_gc_count_before ) { CMSCollector :: disable_@@ icms ( ) ; _disabled_icms = true ; CMSCollector :: start_icms ( ) ; CMSCollector :: request_full_gc ( _full_gc_count_before , _gc_cause ) ; } else { assert ( _full_gc_count_before < gch -> total_full_collections ( ) , " Error " ) ; FullGCCount_lock -> notify_all ( ) ; } }
void VM_GenCollectFullConcurrent :: doit_epilogue ( ) { Thread * thr = Thread :: current ( ) ; assert ( thr -> is_Java_thread ( ) , " just ▁ checking " ) ; JavaThread * jt = ( JavaThread * ) thr ; Heap_lock -> unlock ( ) ; release_and_notify_pending_list_lock ( ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; if ( _gc_cause != GCCause :: _gc_locker && gch -> total_full_collections_completed ( ) <= _full_gc_count_before ) { assert ( _gc_cause == GCCause :: _java_lang_system_gc , " the ▁ only ▁ way ▁ to ▁ get ▁ here ▁ if ▁ this ▁ was ▁ a ▁ System . gc ( ) - induce@@ d ▁ GC " ) ; assert ( ExplicitGCInvokesConcurrent , " Error " ) ; ThreadToNative@@ FromVM native ( jt ) ; MutexLockerEx ml ( FullGCCount_lock , Mutex :: _no_safepoint_check_flag ) ; while ( gch -> total_full_collections_completed ( ) <= _full_gc_count_before ) { FullGCCount_lock -> wait ( Mutex :: _no_safepoint_check_flag ) ; } } if ( _disabled_icms ) { CMSCollector :: enable_icms ( ) ; } }
bool JlCompress :: compressFile ( QuaZip * zip , QString fileName , QString fileDest ) { if ( ! zip ) return false ; if ( zip -> getMode ( ) != QuaZip :: mdCreate && zip -> getMode ( ) != QuaZip :: mdAppend && zip -> getMode ( ) != QuaZip :: mdAdd ) return false ; QFile inFile ; inFile . setFileName ( fileName ) ; if ( ! inFile . open ( QIODevice :: ReadOnly ) ) return false ; QuaZipFile outFile ( zip ) ; if ( ! outFile . open ( QIODevice :: WriteOnly , QuaZipNewInfo ( fileDest , inFile . fileName ( ) ) ) ) return false ; if ( ! copyData ( inFile , outFile ) || outFile . getZipError ( ) != UNZ_OK ) { return false ; } outFile . close ( ) ; if ( outFile . getZipError ( ) != UNZ_OK ) return false ; inFile . close ( ) ; return true ; }
bool JlCompress :: compressSubDir ( QuaZip * zip , QString dir , QString origDir , bool recursive ) { if ( ! zip ) return false ; if ( zip -> getMode ( ) != QuaZip :: mdCreate && zip -> getMode ( ) != QuaZip :: mdAppend && zip -> getMode ( ) != QuaZip :: mdAdd ) return false ; QDir directory ( dir ) ; if ( ! directory . exists ( ) ) return false ; if ( recursive ) { QFileInfoList files = directory . entryInfoList ( QDir :: AllDirs | QDir :: NoDot@@ AndDot@@ Dot ) ; Q_FOREACH ( QFileInfo file , files ) { if ( ! compressSubDir ( zip , file . absoluteFilePath ( ) , origDir , recursive ) ) return false ; } } QFileInfoList files = directory . entryInfoList ( QDir :: Files ) ; QDir origDirectory ( origDir ) ; Q_FOREACH ( QFileInfo file , files ) { if ( ! file . isFile ( ) || file . absoluteFilePath ( ) == zip -> getZipName ( ) ) continue ; QString filename = origDirectory . relativeFilePath ( file . absoluteFilePath ( ) ) ; if ( ! compressFile ( zip , file . absoluteFilePath ( ) , filename ) ) return false ; } return true ; }
bool JlCompress :: extractFile ( QuaZip * zip , QString fileName , QString fileDest ) { if ( ! zip ) return false ; if ( zip -> getMode ( ) != QuaZip :: mdUnzip ) return false ; if ( ! fileName . isEmpty ( ) ) zip -> setCurrentFile ( fileName ) ; QuaZipFile inFile ( zip ) ; if ( ! inFile . open ( QIODevice :: ReadOnly ) || inFile . getZipError ( ) != UNZ_OK ) return false ; QDir curDir ; if ( ! curDir . mkpath ( QFileInfo ( fileDest ) . absolutePath ( ) ) ) { return false ; } if ( QFileInfo ( fileDest ) . isDir ( ) ) return true ; QFile outFile ; outFile . setFileName ( fileDest ) ; if ( ! outFile . open ( QIODevice :: WriteOnly ) ) return false ; if ( ! copyData ( inFile , outFile ) || inFile . getZipError ( ) != UNZ_OK ) { outFile . close ( ) ; removeFile ( QStringList ( fileDest ) ) ; return false ; } outFile . close ( ) ; inFile . close ( ) ; if ( inFile . getZipError ( ) != UNZ_OK ) { removeFile ( QStringList ( fileDest ) ) ; return false ; } return true ; }
bool JlCompress :: removeFile ( QStringList listFile ) { bool ret = true ; for ( int i = 0 ; i < listFile . count ( ) ; i ++ ) { ret = ret && QFile :: remove ( listFile . at ( i ) ) ; } return ret ; }
bool JlCompress :: compressFile ( QString fileCompressed , QString file ) { QuaZip zip ( fileCompressed ) ; QDir ( ) . mkpath ( QFileInfo ( fileCompressed ) . absolutePath ( ) ) ; if ( ! zip . open ( QuaZip :: mdCreate ) ) { QFile :: remove ( fileCompressed ) ; return false ; } if ( ! compressFile ( & zip , file , QFileInfo ( file ) . fileName ( ) ) ) { QFile :: remove ( fileCompressed ) ; return false ; } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { QFile :: remove ( fileCompressed ) ; return false ; } return true ; }
bool JlCompress :: compressFiles ( QString fileCompressed , QStringList files ) { QuaZip zip ( fileCompressed ) ; QDir ( ) . mkpath ( QFileInfo ( fileCompressed ) . absolutePath ( ) ) ; if ( ! zip . open ( QuaZip :: mdCreate ) ) { QFile :: remove ( fileCompressed ) ; return false ; } QFileInfo info ; Q_FOREACH ( QString file , files ) { info . setFile ( file ) ; if ( ! info . exists ( ) || ! compressFile ( & zip , file , info . fileName ( ) ) ) { QFile :: remove ( fileCompressed ) ; return false ; } } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { QFile :: remove ( fileCompressed ) ; return false ; } return true ; }
bool JlCompress :: compressDir ( QString fileCompressed , QString dir , bool recursive ) { QuaZip zip ( fileCompressed ) ; QDir ( ) . mkpath ( QFileInfo ( fileCompressed ) . absolutePath ( ) ) ; if ( ! zip . open ( QuaZip :: mdCreate ) ) { QFile :: remove ( fileCompressed ) ; return false ; } if ( ! compressSubDir ( & zip , dir , dir , recursive ) ) { QFile :: remove ( fileCompressed ) ; return false ; } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { QFile :: remove ( fileCompressed ) ; return false ; } return true ; }
QString JlCompress :: extractFile ( QString fileCompressed , QString fileName , QString fileDest ) { QuaZip zip ( fileCompressed ) ; if ( ! zip . open ( QuaZip :: mdUnzip ) ) { return QString ( ) ; } if ( fileDest . isEmpty ( ) ) fileDest = fileName ; if ( ! extractFile ( & zip , fileName , fileDest ) ) { return QString ( ) ; } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { removeFile ( QStringList ( fileDest ) ) ; return QString ( ) ; } return QFileInfo ( fileDest ) . absoluteFilePath ( ) ; }
QStringList JlCompress :: extractFiles ( QString fileCompressed , QStringList files , QString dir ) { QuaZip zip ( fileCompressed ) ; if ( ! zip . open ( QuaZip :: mdUnzip ) ) { return QStringList ( ) ; } QStringList extracted ; for ( int i = 0 ; i < files . count ( ) ; i ++ ) { QString absPath = QDir ( dir ) . absoluteFilePath ( files . at ( i ) ) ; if ( ! extractFile ( & zip , files . at ( i ) , absPath ) ) { removeFile ( extracted ) ; return QStringList ( ) ; } extracted . append ( absPath ) ; } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { removeFile ( extracted ) ; return QStringList ( ) ; } return extracted ; }
QStringList JlCompress :: extractDir ( QString fileCompressed , QString dir ) { QuaZip zip ( fileCompressed ) ; if ( ! zip . open ( QuaZip :: mdUnzip ) ) { return QStringList ( ) ; } QDir directory ( dir ) ; QStringList extracted ; if ( ! zip . goToFirstFile ( ) ) { return QStringList ( ) ; } do { QString name = zip . getCurrentFileName ( ) ; QString absFilePath = directory . absoluteFilePath ( name ) ; if ( ! extractFile ( & zip , " " , absFilePath ) ) { removeFile ( extracted ) ; return QStringList ( ) ; } extracted . append ( absFilePath ) ; } while ( zip . goToNextFile ( ) ) ; zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { removeFile ( extracted ) ; return QStringList ( ) ; } return extracted ; }
QStringList JlCompress :: getFileList ( QString fileCompressed ) { QuaZip * zip = new QuaZip ( QFileInfo ( fileCompressed ) . absoluteFilePath ( ) ) ; if ( ! zip -> open ( QuaZip :: mdUnzip ) ) { delete zip ; return QStringList ( ) ; } QStringList lst ; QuaZipFileInfo info ; for ( bool more = zip -> goToFirstFile ( ) ; more ; more = zip -> goToNextFile ( ) ) { if ( ! zip -> getCurrentFileInfo ( & info ) ) { delete zip ; return QStringList ( ) ; } lst << info . name ; } zip -> close ( ) ; if ( zip -> getZipError ( ) != 0 ) { delete zip ; return QStringList ( ) ; } delete zip ; return lst ; }
void UniqueExpireCacheTest :: testClear ( ) { UniqueExpireCache < int , IntVal > aCache ; aCache . add ( 1 , IntVal ( 2 , DURSLEEP ) ) ; aCache . add ( 3 , IntVal ( 4 , DURSLEEP ) ) ; aCache . add ( 5 , IntVal ( 6 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; assert ( aCache . has ( 5 ) ) ; assert ( aCache . get ( 1 ) -> value == 2 ) ; assert ( aCache . get ( 3 ) -> value == 4 ) ; assert ( aCache . get ( 5 ) -> value == 6 ) ; aCache . clear ( ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( ! aCache . has ( 5 ) ) ; }
void UniqueExpireCacheTest :: testAccessClear ( ) { UniqueAccessExpireCache < int , DIntVal > aCache ; aCache . add ( 1 , DIntVal ( 2 , DURSLEEP ) ) ; aCache . add ( 3 , DIntVal ( 4 , DURSLEEP ) ) ; aCache . add ( 5 , DIntVal ( 6 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; assert ( aCache . has ( 5 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; assert ( aCache . get ( 3 ) -> value ( ) == 4 ) ; assert ( aCache . get ( 5 ) -> value ( ) == 6 ) ; aCache . clear ( ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( ! aCache . has ( 5 ) ) ; }
void UniqueExpireCacheTest :: testAccessUpdate ( ) { UniqueAccessExpireCache < int , DIntVal > aCache ; aCache . add ( 1 , DIntVal ( 2 , DURSLEEP ) ) ; aCache . add ( 3 , DIntVal ( 4 , DURSLEEP ) ) ; aCache . add ( 5 , DIntVal ( 6 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; assert ( aCache . has ( 5 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; Thread :: sleep ( DURSLEEP / 2 ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; Thread :: sleep ( DURSLEEP / 2 ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; Thread :: sleep ( DURSLEEP / 2 ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( ! aCache . has ( 5 ) ) ; Thread :: sleep ( DURSLEEP * 2 ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( ! aCache . has ( 5 ) ) ; aCache . remove ( 666 ) ; }
void UniqueExpireCacheTest :: testExpire0 ( ) { UniqueExpireCache < int , IntVal > aCache ; aCache . add ( 1 , IntVal ( 2 , 0 ) ) ; assert ( ! aCache . has ( 1 ) ) ; }
void UniqueExpireCacheTest :: testAccessExpire0 ( ) { UniqueAccessExpireCache < int , DIntVal > aCache ; aCache . add ( 1 , DIntVal ( 2 , Timespan ( 0 , 0 ) ) ) ; assert ( ! aCache . has ( 1 ) ) ; }
void UniqueExpireCacheTest :: testExpireN ( ) { UniqueExpireCache < int , IntVal > aCache ; aCache . add ( 1 , IntVal ( 2 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; SharedPtr < IntVal > tmp = aCache . get ( 1 ) ; assert ( ! tmp . isNull ( ) ) ; assert ( tmp -> value == 2 ) ; Thread :: sleep ( DURWAIT ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( tmp -> value == 2 ) ; tmp = aCache . get ( 1 ) ; assert ( tmp . isNull ( ) ) ; aCache . add ( 1 , IntVal ( 2 , DURSLEEP ) ) ; Thread :: sleep ( DURHALFSLEEP ) ; aCache . add ( 3 , IntVal ( 4 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; tmp = aCache . get ( 1 ) ; SharedPtr < IntVal > tmp2 = aCache . get ( 3 ) ; assert ( tmp -> value == 2 ) ; assert ( tmp2 -> value == 4 ) ; Thread :: sleep ( DURHALFSLEEP + 25 ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; assert ( tmp -> value == 2 ) ; assert ( tmp2 -> value == 4 ) ; tmp2 = aCache . get ( 3 ) ; assert ( tmp2 -> value == 4 ) ; Thread :: sleep ( DURHALFSLEEP + 25 ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( tmp2 -> value == 4 ) ; tmp = aCache . get ( 1 ) ; tmp2 = aCache . get ( 3 ) ; assert ( ! tmp ) ; assert ( ! tmp2 ) ; aCache . remove ( 666 ) ; aCache . clear ( ) ; assert ( ! aCache . has ( 5 ) ) ; assert ( ! aCache . has ( 3 ) ) ; }
void UniqueExpireCacheTest :: testDuplicateAdd ( ) { UniqueExpireCache < int , IntVal > aCache ; aCache . add ( 1 , IntVal ( 2 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value == 2 ) ; aCache . add ( 1 , IntVal ( 3 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value == 3 ) ; }
void UniqueExpireCacheTest :: testAccessDuplicateAdd ( ) { UniqueAccessExpireCache < int , DIntVal > aCache ; aCache . add ( 1 , DIntVal ( 2 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; aCache . add ( 1 , DIntVal ( 3 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 3 ) ; }
void UniqueExpireCacheTest :: testExpirationDecorator ( ) { typedef ExpirationDecorator < int > ExpireInt ; UniqueExpireCache < int , ExpireInt > aCache ; aCache . add ( 1 , ExpireInt ( 2 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; aCache . add ( 1 , ExpireInt ( 3 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 3 ) ; }
CppUnit :: Test * UniqueExpireCacheTest :: suite ( ) { CppUnit :: TestSuite * pSuite = new CppUnit :: TestSuite ( " UniqueExpireCacheTest " ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testClear ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testAccessClear ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testAccessUpdate ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testExpire0 ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testAccessExpire0 ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testExpireN ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testDuplicateAdd ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testAccessDuplicateAdd ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testExpirationDecorator ) ; return pSuite ; }
BtSrc8Iii :: BtSrc8Iii ( RDMatrix * matrix , QObject * parent ) : Switcher ( matrix , parent ) { bt_istate = 0 ; for ( int i = 0 ; i < BTSRC8III_GPIO_@@ PINS ; i ++ ) { bt_gpi_state [ i ] = false ; bt_gpi_mask [ i ] = false ; } bt_matrix = matrix -> matrix ( ) ; bt_gpis = matrix -> gpis ( ) ; bt_gpos = matrix -> gpos ( ) ; RDTty * tty = new RDTty ( rda -> station ( ) -> name ( ) , matrix -> port ( RDMatrix :: Primary ) ) ; bt_device = new RDTTYDevice ( ) ; if ( tty -> active ( ) ) { bt_device -> setName ( tty -> port ( ) ) ; bt_device -> setSpeed ( tty -> baudRate ( ) ) ; bt_device -> setWordLength ( tty -> dataBits ( ) ) ; bt_device -> setParity ( tty -> parity ( ) ) ; bt_device -> open ( QIODevice :: Unbuffered | QIODevice :: ReadWrite ) ; } delete tty ; bt_gpi_oneshot = new RDOneShot ( this ) ; connect ( bt_gpi_oneshot , SIGNAL ( timeout ( int ) ) , this , SLOT ( gpiOneshotData ( int ) ) ) ; bt_gpo_oneshot = new RDOneShot ( this ) ; connect ( bt_gpo_oneshot , SIGNAL ( timeout ( int ) ) , this , SLOT ( gpoOneshotData ( int ) ) ) ; QTimer * timer = new QTimer ( this , " poll _ timer " ) ; connect ( timer , SIGNAL ( timeout ( ) ) , this , SLOT ( processStatus ( ) ) ) ; timer -> start ( BTSRC8III_POLL_INTER@@ VAL ) ; }
BtSrc8Iii :: ~ BtSrc8Iii ( ) { delete bt_device ; delete bt_gpi_oneshot ; delete bt_gpo_oneshot ; }
RDMatrix :: Type BtSrc8Iii :: type ( ) { return RDMatrix :: BtSrc8III ; }
unsigned BtSrc8Iii :: gpiQuantity ( ) { return bt_gpis ; }
unsigned BtSrc8Iii :: gpoQuantity ( ) { return bt_gpos ; }
bool BtSrc8Iii :: primaryTtyActive ( ) { return true ; }
bool BtSrc8Iii :: secondaryTtyActive ( ) { return false ; }
void BtSrc8Iii :: processCommand ( RDMacro * cmd ) { char str [ 9 ] ; switch ( cmd -> command ( ) ) { case RDMacro :: GO : if ( ( cmd -> argQuantity ( ) != 5 ) || ( ( cmd -> arg ( 1 ) . lower ( ) != " i " ) && ( cmd -> arg ( 1 ) . lower ( ) != " o " ) ) || ( cmd -> arg ( 2 ) . toInt ( ) < 1 ) || ( cmd -> arg ( 3 ) . toInt ( ) > bt_gpos ) || ( cmd -> arg ( 2 ) . toInt ( ) > bt_gpos ) || ( ( cmd -> arg ( 3 ) . toInt ( ) != 1 ) && ( cmd -> arg ( 3 ) . toInt ( ) != 0 ) && ( cmd -> arg ( 1 ) . lower ( ) != " i " ) ) || ( ( cmd -> arg ( 3 ) . toInt ( ) != 1 ) && ( cmd -> arg ( 3 ) . toInt ( ) != 0 ) && ( cmd -> arg ( 3 ) . toInt ( ) != - 1 ) && ( cmd -> arg ( 1 ) . lower ( ) == " i " ) ) || ( cmd -> arg ( 4 ) . toInt ( ) < 0 ) ) { cmd -> acknowledge ( false ) ; emit rmlEcho ( cmd ) ; return ; } if ( cmd -> arg ( 3 ) . toInt ( ) == 0 ) { if ( cmd -> arg ( 4 ) . toInt ( ) == 0 ) { if ( cmd -> arg ( 1 ) . lower ( ) == " i " ) { if ( bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] ) { emit gpiChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , false ) ; bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = false ; } bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } if ( cmd -> arg ( 1 ) . lower ( ) == " o " ) { sprintf ( str , " * % dOR % dF \n " , BTSRC8III_UNIT_ID , cmd -> arg ( 2 ) . toInt ( ) ) ; bt_device -> write ( str , 8 ) ; emit gpoChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , false ) ; } } else { if ( cmd -> echoRequested ( ) ) { cmd -> acknowledge ( false ) ; emit rmlEcho ( cmd ) ; } return ; } } else { if ( cmd -> arg ( 3 ) . toInt ( ) == - 1 ) { bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = false ; bt_device -> write ( " * 0SPA \n " , 7 ) ; } else { if ( cmd -> arg ( 4 ) . toInt ( ) == 0 ) { if ( cmd -> arg ( 1 ) . lower ( ) == " i " ) { if ( ! bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] ) { emit gpiChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } if ( cmd -> arg ( 1 ) . lower ( ) == " o " ) { sprintf ( str , " * % dOR % dL \n " , BTSRC8III_UNIT_ID , cmd -> arg ( 2 ) . toInt ( ) ) ; bt_device -> write ( str , 8 ) ; emit gpoChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; } } else { if ( cmd -> arg ( 1 ) . lower ( ) == " i " ) { if ( ! bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] ) { emit gpiChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; bt_gpi_oneshot -> start ( cmd -> arg ( 2 ) . toInt ( ) - 1 , 500 ) ; } if ( cmd -> arg ( 1 ) . lower ( ) == " o " ) { sprintf ( str , " * % dOR % dP % 02d \n " , BTSRC8III_UNIT_ID , cmd -> arg ( 2 ) . toInt ( ) , cmd -> arg ( 4 ) . toInt ( ) / 100 + 1 ) ; bt_device -> write ( str , 10 ) ; emit gpoChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; bt_gpo_oneshot -> start ( cmd -> arg ( 2 ) . toInt ( ) - 1 , 500 ) ; } } } } if ( cmd -> echoRequested ( ) ) { cmd -> acknowledge ( true ) ; emit rmlEcho ( cmd ) ; } break ; default : cmd -> acknowledge ( false ) ; emit rmlEcho ( cmd ) ; break ; } }
void BtSrc8Iii :: processStatus ( ) { char buffer [ 256 ] ; int n ; int gpi ; while ( ( n = bt_device -> read ( buffer , 255 ) ) > 0 ) { for ( int i = 0 ; i < n ; i ++ ) { switch ( bt_istate ) { case 0 : if ( buffer [ i ] == ' S ' ) { bt_istate = 1 ; } break ; case 1 : if ( buffer [ i ] == ( BTSRC8III_UNIT_ID + '0' ) ) { bt_istate = 2 ; } else { bt_istate = 0 ; } break ; case 2 : if ( buffer [ i ] == ' P ' ) { bt_istate = 3 ; } else { bt_istate = 0 ; } break ; case 3 : if ( buffer [ i ] == ' , ' ) { bt_istate = 4 ; } else { bt_istate = 0 ; } break ; case 4 : if ( buffer [ i ] == ' A ' ) { bt_istate = 5 ; } else { bt_istate = 0 ; } break ; case 5 : case 7 : case 9 : case 11 : case 13 : case 15 : case 17 : case 19 : if ( buffer [ i ] == ' , ' ) { bt_istate ++ ; } else { bt_istate = 0 ; } break ; case 6 : case 8 : case 10 : case 12 : case 14 : case 16 : case 18 : case 20 : if ( buffer [ i ] == '0' ) { gpi = ( bt_istate - 6 ) / 2 ; if ( bt_gpi_state [ gpi ] && ( ! bt_gpi_mask [ gpi ] ) ) { emit gpiChanged ( bt_matrix , gpi , false ) ; bt_gpi_state [ gpi ] = false ; } bt_istate ++ ; } if ( buffer [ i ] == '1' ) { gpi = ( bt_istate - 6 ) / 2 ; if ( ( ! bt_gpi_state [ gpi ] ) && ( ! bt_gpi_mask [ gpi ] ) ) { emit gpiChanged ( bt_matrix , gpi , true ) ; bt_gpi_state [ gpi ] = true ; } bt_istate ++ ; } break ; default : bt_istate = 0 ; } } } }
void BtSrc8Iii :: gpiOneshotData ( int value ) { bt_gpi_mask [ value ] = false ; bt_device -> write ( " * 0SPA " , 5 ) ; }
void BtSrc8Iii :: gpoOneshotData ( int value ) { emit gpoChanged ( bt_matrix , value , false ) ; }
void V8VideoTrackList :: visitDOMWrapper ( v8 :: Isolate * isolate , ScriptWrappable * scriptWrappable , const v8 :: Persistent < v8 :: Object > & wrapper ) { VideoTrackList * impl = scriptWrappable -> toImpl < VideoTrackList > ( ) ; if ( Node * owner = WTF :: getPtr ( impl -> owner ( ) ) ) { Node * root = V8GCController :: opaqueRootForGC ( isolate , owner ) ; isolate -> SetReferenceFromGroup ( v8 :: UniqueId ( reinterpret_cast < intptr_t > ( root ) ) , wrapper ) ; return ; } }
v8 :: Local < v8 :: FunctionTemplate > V8VideoTrackList :: domTemplate ( v8 :: Isolate * isolate ) { return V8DOMConfiguration :: domClassTemplate ( isolate , const_cast < WrapperTypeInfo * > ( & wrapperTypeInfo ) , installV8VideoTrackListTemplate ) ; }
bool V8VideoTrackList :: hasInstance ( v8 :: Local < v8 :: Value > v8Value , v8 :: Isolate * isolate ) { return V8PerIsolateData :: from ( isolate ) -> hasInstance ( & wrapperTypeInfo , v8Value ) ; }
v8 :: Local < v8 :: Object > V8VideoTrackList :: findInstanceInPrototypeChain ( v8 :: Local < v8 :: Value > v8Value , v8 :: Isolate * isolate ) { return V8PerIsolateData :: from ( isolate ) -> findInstanceInPrototypeChain ( & wrapperTypeInfo , v8Value ) ; }
VideoTrackList * V8VideoTrackList :: toImplWithTypeCheck ( v8 :: Isolate * isolate , v8 :: Local < v8 :: Value > value ) { return hasInstance ( value , isolate ) ? toImpl ( v8 :: Local < v8 :: Object > :: Cast ( value ) ) : 0 ; }
void V8VideoTrackList :: refObject ( ScriptWrappable * scriptWrappable ) { ENABLE ( OILPAN ) scriptWrappable -> toImpl < VideoTrackList > ( ) -> ref ( ) ; }
void V8VideoTrackList :: derefObject ( ScriptWrappable * scriptWrappable ) { ENABLE ( OILPAN ) scriptWrappable -> toImpl < VideoTrackList > ( ) -> deref ( ) ; }
QgsNewHttpConnection :: QgsNewHttpConnection ( QWidget * parent , const QString & baseKey , const QString & connName , Qt :: WindowFlags fl ) : QDialog ( parent , fl ) , mBaseKey ( baseKey ) , mOriginalConnName ( connName ) , mAuthConfigSelect ( nullptr ) { setupUi ( this ) ; QString service = baseKey . mid ( 18 , 3 ) . toUpper ( ) ; setWindowTitle ( tr ( " Create ▁ a ▁ new ▁ % 1 ▁ connection " ) . arg ( service ) ) ; mCredentialsBaseKey = mBaseKey . split ( ' - ' ) . last ( ) . toUpper ( ) ; txtName -> setValidator ( new QRegExpValidator ( QRegExp ( " [ ^ \\ / ] + " ) , txtName ) ) ; cmbDpiMode -> clear ( ) ; cmbDpiMode -> addItem ( tr ( " all " ) ) ; cmbDpiMode -> addItem ( tr ( " off " ) ) ; cmbDpiMode -> addItem ( tr ( " QGIS " ) ) ; cmbDpiMode -> addItem ( tr ( " UMN " ) ) ; cmbDpiMode -> addItem ( tr ( " GeoServer " ) ) ; cmbVersion -> clear ( ) ; cmbVersion -> addItem ( tr ( " Auto - detect " ) ) ; cmbVersion -> addItem ( tr ( "1.0" ) ) ; cmbVersion -> addItem ( tr ( "1.1" ) ) ; cmbVersion -> addItem ( tr ( "2.0" ) ) ; mAuthConfigSelect = new QgsAuthConfigSelect ( this ) ; tabAuth -> insertTab ( 1 , mAuthConfigSelect , tr ( " Configurations " ) ) ; if ( ! connName . isEmpty ( ) ) { QSettings settings ; QString key = mBaseKey + connName ; QString credentialsKey = " / Qgis / " + mCredentialsBaseKey + ' / ' + connName ; txtName -> setText ( connName ) ; txtUrl -> setText ( settings . value ( key + " / url " ) . toString ( ) ) ; cbxIgnoreGetMapURI -> setChecked ( settings . value ( key + " / ignoreGetMapURI " , false ) . toBool ( ) ) ; cbxIgnoreAxisOrientation -> setChecked ( settings . value ( key + " / ignoreAxisOrientation " , false ) . toBool ( ) ) ; cbxInvertAxisOrientation -> setChecked ( settings . value ( key + " / invertAxisOrientation " , false ) . toBool ( ) ) ; cbxIgnoreGetFeatureInfoURI -> setChecked ( settings . value ( key + " / ignoreGetFeatureInfoURI " , false ) . toBool ( ) ) ; cbxSmoothPixmapTransform -> setChecked ( settings . value ( key + " / smoothPixmapTransform " , false ) . toBool ( ) ) ; int dpiIdx ; switch ( settings . value ( key + " / dpiMode " , 7 ) . toInt ( ) ) { case 0 : dpiIdx = 1 ; break ; case 1 : dpiIdx = 2 ; break ; case 2 : dpiIdx = 3 ; break ; case 4 : dpiIdx = 4 ; break ; default : dpiIdx = 0 ; break ; } cmbDpiMode -> setCurrentIndex ( dpiIdx ) ; QString version = settings . value ( key + " / version " ) . toString ( ) ; int versionIdx = 0 ; if ( version == "1.0.0" ) versionIdx = 1 ; else if ( version == "1.1.0" ) versionIdx = 2 ; else if ( version == "2.0.0" ) versionIdx = 3 ; cmbVersion -> setCurrentIndex ( versionIdx ) ; txtReferer -> setText ( settings . value ( key + " / referer " ) . toString ( ) ) ; txtMaxNumFeatures -> setText ( settings . value ( key + " / maxnumfeatures " ) . toString ( ) ) ; txtUserName -> setText ( settings . value ( credentialsKey + " / username " ) . toString ( ) ) ; txtPassword -> setText ( settings . value ( credentialsKey + " / password " ) . toString ( ) ) ; QString authcfg = settings . value ( credentialsKey + " / authcfg " ) . toString ( ) ; mAuthConfigSelect -> setConfigId ( authcfg ) ; if ( ! authcfg . isEmpty ( ) ) { tabAuth -> setCurrentIndex ( tabAuth -> indexOf ( mAuthConfigSelect ) ) ; } } if ( mBaseKey != " / Qgis / connections - wms / " ) { if ( mBaseKey != " / Qgis / connections - wcs / " && mBaseKey != " / Qgis / connections - wfs / " ) { cbxIgnoreAxisOrientation -> setVisible ( false ) ; cbxInvertAxisOrientation -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxIgnoreAxisOrientation ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxInvertAxisOrientation ) ; } if ( mBaseKey == " / Qgis / connections - wfs / " ) { cbxIgnoreAxisOrientation -> setText ( tr ( " Ignore ▁ axis ▁ orientation ▁ ( WFS ▁ 1.1 / WFS ▁ 2.0 ) " ) ) ; } if ( mBaseKey == " / Qgis / connections - wcs / " ) { cbxIgnoreGetMapURI -> setText ( tr ( " Ignore ▁ GetCoverage ▁ URI ▁ reported ▁ in ▁ capabilities " ) ) ; cbxIgnoreAxisOrientation -> setText ( tr ( " Ignore ▁ axis ▁ orientation " ) ) ; } else { cbxIgnoreGetMapURI -> setVisible ( false ) ; cbxSmoothPixmapTransform -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxIgnoreGetMapURI ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxSmoothPixmapTransform ) ; } cbxIgnoreGetFeatureInfoURI -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxIgnoreGetFeatureInfoURI ) ; cmbDpiMode -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cmbDpiMode ) ; lblDpiMode -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( lblDpiMode ) ; txtReferer -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( txtReferer ) ; lblReferer -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( lblReferer ) ; } if ( mBaseKey != " / Qgis / connections - wfs / " ) { cmbVersion -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cmbVersion ) ; lblMaxNumFeatures -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( lblMaxNumFeatures ) ; txtMaxNumFeatures -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( txtMaxNumFeatures ) ; } int w = width ( ) ; adjustSize ( ) ; resize ( w , height ( ) ) ; on_txtName_textChanged ( connName ) ; }
void QgsNewHttpConnection :: on_txtName_textChanged ( const QString & text ) { Q_UNUSED ( text ) ; buttonBox -> button ( QDialogButtonBox :: Ok ) -> setDisabled ( txtName -> text ( ) . isEmpty ( ) || txtUrl -> text ( ) . isEmpty ( ) ) ; }
void QgsNewHttpConnection :: on_txtUrl@@ _textChanged ( const QString & text ) { Q_UNUSED ( text ) ; buttonBox -> button ( QDialogButtonBox :: Ok ) -> setDisabled ( txtName -> text ( ) . isEmpty ( ) || txtUrl -> text ( ) . isEmpty ( ) ) ; }
void QgsNewHttpConnection :: accept ( ) { QSettings settings ; QString key = mBaseKey + txtName -> text ( ) ; QString credentialsKey = " / Qgis / " + mCredentialsBaseKey + ' / ' + txtName -> text ( ) ; if ( ( mOriginalConnName . isNull ( ) || mOriginalConnName . compare ( txtName -> text ( ) , Qt :: CaseInsensitive ) != 0 ) && settings . contains ( key + " / url " ) && QMessageBox :: question ( this , tr ( " Save ▁ connection " ) , tr ( " Should ▁ the ▁ existing ▁ connection ▁ % 1 ▁ be ▁ overwritten ? " ) . arg ( txtName -> text ( ) ) , QMessageBox :: Ok | QMessageBox :: Cancel ) == QMessageBox :: Cancel ) { return ; } if ( ! txtPassword -> text ( ) . isEmpty ( ) && QMessageBox :: question ( this , tr ( " Saving ▁ passwords " ) , tr ( " WARNING : ▁ You ▁ have ▁ entered ▁ a ▁ password . ▁ It ▁ will ▁ be ▁ stored ▁ in ▁ plain ▁ text ▁ in ▁ your ▁ project ▁ files ▁ and ▁ in ▁ your ▁ home ▁ directory ▁ on ▁ Unix - like ▁ systems , ▁ or ▁ in ▁ your ▁ user ▁ profile ▁ on ▁ Windows . ▁ If ▁ you ▁ do ▁ not ▁ want ▁ this ▁ to ▁ happen , ▁ please ▁ press ▁ the ▁ Cancel ▁ button . \n Note : ▁ giving ▁ the ▁ password ▁ is ▁ optional . ▁ It ▁ will ▁ be ▁ requested ▁ interactiv@@ ly , ▁ when ▁ needed . " ) , QMessageBox :: Ok | QMessageBox :: Cancel ) == QMessageBox :: Cancel ) { return ; } if ( ! mOriginalConnName . isNull ( ) && mOriginalConnName != key ) { settings . remove ( mBaseKey + mOriginalConnName ) ; settings . remove ( " / Qgis / " + mCredentialsBaseKey + ' / ' + mOriginalConnName ) ; settings . sync ( ) ; } QUrl url ( txtUrl -> text ( ) . trimmed ( ) ) ; const QList < QPair < QByteArray , QByteArray > > & items = url . encodedQueryItems ( ) ; QHash < QString , QPair < QByteArray , QByteArray > > params ; for ( QList < QPair < QByteArray , QByteArray > > :: const_iterator it = items . constBegin ( ) ; it != items . constEnd ( ) ; ++ it ) { params . insert ( QString ( it -> first ) . toUpper ( ) , * it ) ; } if ( params [ " SERVICE " ] . second . toUpper ( ) == " WMS " || params [ " SERVICE " ] . second . toUpper ( ) == " WFS " || params [ " SERVICE " ] . second . toUpper ( ) == " WCS " ) { url . removeEncodedQueryItem ( params [ " SERVICE " ] . first ) ; url . removeEncodedQueryItem ( params [ " REQUEST " ] . first ) ; url . removeEncodedQueryItem ( params [ " FORMAT " ] . first ) ; } if ( url . encodedPath ( ) . isEmpty ( ) ) { url . setEncodedPath ( " / " ) ; } settings . setValue ( key + " / url " , url . toString ( ) ) ; if ( mBaseKey == " / Qgis / connections - wms / " || mBaseKey == " / Qgis / connections - wcs / " || mBaseKey == " / Qgis / connections - wfs / " ) { settings . setValue ( key + " / ignoreAxisOrientation " , cbxIgnoreAxisOrientation -> isChecked ( ) ) ; settings . setValue ( key + " / invertAxisOrientation " , cbxInvertAxisOrientation -> isChecked ( ) ) ; } if ( mBaseKey == " / Qgis / connections - wms / " || mBaseKey == " / Qgis / connections - wcs / " ) { settings . setValue ( key + " / ignoreGetMapURI " , cbxIgnoreGetMapURI -> isChecked ( ) ) ; settings . setValue ( key + " / smoothPixmapTransform " , cbxSmoothPixmapTransform -> isChecked ( ) ) ; int dpiMode = 0 ; switch ( cmbDpiMode -> currentIndex ( ) ) { case 0 : dpiMode = 7 ; break ; case 1 : dpiMode = 0 ; break ; case 2 : dpiMode = 1 ; break ; case 3 : dpiMode = 2 ; break ; case 4 : dpiMode = 4 ; break ; } settings . setValue ( key + " / dpiMode " , dpiMode ) ; } if ( mBaseKey == " / Qgis / connections - wms / " ) { settings . setValue ( key + " / ignoreGetFeatureInfoURI " , cbxIgnoreGetFeatureInfoURI -> isChecked ( ) ) ; } if ( mBaseKey == " / Qgis / connections - wfs / " ) { QString version = " auto " ; switch ( cmbVersion -> currentIndex ( ) ) { case 0 : version = " auto " ; break ; case 1 : version = "1.0.0" ; break ; case 2 : version = "1.1.0" ; break ; case 3 : version = "2.0.0" ; break ; } settings . setValue ( key + " / version " , version ) ; settings . setValue ( key + " / maxnumfeatures " , txtMaxNumFeatures -> text ( ) ) ; } settings . setValue ( key + " / referer " , txtReferer -> text ( ) ) ; settings . setValue ( credentialsKey + " / username " , txtUserName -> text ( ) ) ; settings . setValue ( credentialsKey + " / password " , txtPassword -> text ( ) ) ; settings . setValue ( credentialsKey + " / authcfg " , mAuthConfigSelect -> configId ( ) ) ; settings . setValue ( mBaseKey + " / selected " , txtName -> text ( ) ) ; QDialog :: accept ( ) ; }
CommonCommandLineParser :: ~ CommonCommandLineParser ( ) { delete & mImpl ; }
bool CommonCommandLineParser :: getPublishRecaps ( ) { return mImpl . mPublishRecaps ; }
MamaSource * CommonCommandLineParser :: getSource ( ) { if ( ! mImpl . mSource ) { mImpl . mSource = new MamaSource ( " default " , mImpl . mTportName , mImpl . mSourceName , mImpl . mBridge ) ; mImpl . mSource -> getTransport ( ) -> setOutboundThrottle ( mImpl . mThrottleRate , MAMA_THROTTLE_DEFAULT ) ; } return mImpl . mSource ; }
MamaSource * CommonCommandLineParser :: getDictSource ( ) { if ( ! mImpl . mDictSource ) { mImpl . mDictSource = new MamaSource ( " dict " , mImpl . mDictTportName ? mImpl . mDictTportName : mImpl . mTportName , mImpl . mDictSourceName , mImpl . mBridge ) ; } return mImpl . mDictSource ; }
MamaSource * CommonCommandLineParser :: getOptionSource ( ) { if ( ! mImpl . mOptionSource ) { mImpl . mOptionSource = new MamaSource ( " options " , mImpl . mOptionTportName ? mImpl . mOptionTportName : mImpl . mTportName , mImpl . mOptionSourceName , mImpl . mBridge ) ; mImpl . mOptionSource -> getTransport ( ) -> setOutboundThrottle ( mImpl . mThrottleRate , MAMA_THROTTLE_DEFAULT ) ; } return mImpl . mOptionSource ; }
const char * CommonCommandLineParser :: getSymbolMapFile ( ) { return mImpl . mSymbolMapFile ; }
const vector < const char * > & CommonCommandLineParser :: getSymbolList ( ) { return mImpl . mSymbolList ; }
double CommonCommandLineParser :: getThrottleRate ( ) { return mImpl . mThrottleRate ; }
int CommonCommandLineParser :: getNumThreads ( ) { return mImpl . mThreads ; }
double CommonCommandLineParser :: getTimeout ( ) { return mImpl . mTimeout ; }
MamaLogLevel CommonCommandLineParser :: getSubscLogLevel ( ) { return mImpl . mSubscLogLevel ; }
bool CommonCommandLineParser :: getUseWorldview ( ) { return mImpl . mUseWorldView ; }
bool CommonCommandLineParser :: getLogReqResp ( ) { return mImpl . mLogReqResp ; }
const char * CommonCommandLineParser :: getSymbology ( ) { return mImpl . mSymbology ; }
const char * CommonCommandLineParser :: getMiddleware ( ) { return mImpl . mMiddleware ; }
int CommonCommandLineParser :: getPrecision ( ) { return mImpl . mPrecision ; }
int CommonCommandLineParser :: getShutdownTime ( ) { return mImpl . mShutdownTime ; }
bool CommonCommandLineParser :: showDeltas ( ) { return mImpl . mShowDeltas ; }
mamaBridge CommonCommandLineParser :: getBridge ( ) { return mImpl . mBridge ; }
bool CommonCommandLineParser :: getSnapshot ( ) { return mImpl . mSnapShot ; }
bool CommonCommandLineParser :: getOptBool ( char option0 ) { string option ( & option0 , 0 , 1 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; return ( found != mImpl . mOptions . end ( ) ) ; }
bool CommonCommandLineParser :: getOptBool ( const char * option0 ) { string option ( option0 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; return ( found != mImpl . mOptions . end ( ) ) ; }
int CommonCommandLineParser :: getOptInt ( char option0 , int defaultValue ) { string option ( & option0 , 0 , 1 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; if ( found != mImpl . mOptions . end ( ) ) { const char * value = found -> second ; if ( value ) return strtol ( value , NULL , 10 ) ; } return defaultValue ; }
int CommonCommandLineParser :: getOptInt ( const char * option0 , int defaultValue ) { string option ( option0 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; if ( found != mImpl . mOptions . end ( ) ) { const char * value = found -> second ; if ( value ) return strtol ( value , NULL , 10 ) ; } return defaultValue ; }
const char * CommonCommandLineParser :: getOptString ( char option0 ) { string option ( & option0 , 0 , 1 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; if ( found != mImpl . mOptions . end ( ) ) { return found -> second ; } return NULL ; }
const char * CommonCommandLineParser :: getOptString ( const char * option0 ) { string option ( option0 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; if ( found != mImpl . mOptions . end ( ) ) { return found -> second ; } return NULL ; }
int CommonCommandLineParser :: getChurnRate ( ) { return mImpl . mChurnRate ; }
double CommonCommandLineParser :: getTimerInterval ( ) { return mImpl . mTimerInterval ; }
const char * CommonCommandLineParser :: getLogFileName ( ) { return mImpl . mLogFileName ; }
const char * CommonCommandLineParser :: getQueryArg1 ( ) { return mImpl . mQueryArg1 ; }
const char * CommonCommandLineParser :: getQueryArg2 ( ) { return mImpl . mQueryArg2 ; }
const char * CommonCommandLineParser :: getQueryArg3 ( ) { return mImpl . mQueryArg3 ; }
const char * CommonCommandLineParser :: getQueryArg4 ( ) { return mImpl . mQueryArg4 ; }
int CommonCommandLineParser :: getQuery ( ) { return mImpl . mQuery ; }
int CommonCommandLineParser :: getQueryType ( ) { return mImpl . mQueryType ; }
int CommonCommandLineParser :: getQueries ( ) { return mImpl . mQueryCycles ; }
CommonCommandLineParser :: CommonCommandLineParserImpl :: CommonCommandLineParserImpl ( int argc , const char * argv [ ] ) { mSource = NULL ; mDictSource = NULL ; mOptionSource = NULL ; mSymbolMapFile = NULL ; mThrottleRate = 500.0 ; mThreads = 0 ; mTimeout = 1.0 ; mChurnRate = 0 ; mTimerInterval = 1.0 ; mLogFileName = NULL ; mMiddleware = " wmw " ; mPrecision = 2 ; mShutdownTime = 0 ; mShowDeltas = false ; mBridge = NULL ; int i = 1 ; mUseWorldView = false ; mTportName = NULL ; mDictTportName = NULL ; mOptionTportName = NULL ; mSourceName = " WOMBAT " ; mDictSourceName = " WOMBAT " ; mOptionSourceName = " OPRA " ; mSnapShot = false ; mPublishRecaps = false ; mQueryArg1 = NULL ; mQueryArg2 = NULL ; mQueryArg3 = NULL ; mQueryArg4 = NULL ; mQuery = 0 ; mQueryType = 0 ; mQueryCycles = 1 ; while ( i < argc ) { bool handled = false ; if ( ( strcmp ( argv [ i ] , " - OS " ) == 0 ) || ( strcmp ( argv [ i ] , " - optionSource " ) == 0 ) || ( strcmp ( argv [ i ] , " - option - source " ) == 0 ) ) { mOptionSourceName = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - S " ) == 0 ) || ( strcmp ( argv [ i ] , " - source " ) == 0 ) ) { mSourceName = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - use _ dict _ file " ) == 0 ) ) { mDictFileName = argv [ i + 1 ] ; } else if ( ( strcmp ( argv [ i ] , " - DS " ) == 0 ) || ( strcmp ( argv [ i ] , " - dict - source " ) == 0 ) || ( strcmp ( argv [ i ] , " - dictSource " ) == 0 ) || ( strcmp ( argv [ i ] , " - d " ) == 0 ) ) { mDictSourceName = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - T " ) == 0 ) || ( strcmp ( argv [ i ] , " - tport " ) == 0 ) ) { mTportName = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - DT " ) == 0 ) || ( strcmp ( argv [ i ] , " - dictTport " ) == 0 ) || ( strcmp ( argv [ i ] , " - dict - tport " ) == 0 ) || ( strcmp ( argv [ i ] , " - dict _ tport " ) == 0 ) ) { mDictTportName = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - OT " ) == 0 ) || ( strcmp ( argv [ i ] , " - optionTport " ) == 0 ) || ( strcmp ( argv [ i ] , " - option - tport " ) == 0 ) ) { mOptionTportName = argv [ i + 1 ] ; handled = true ; } else if ( strcmp ( argv [ i ] , " - s " ) == 0 ) { mSymbolList . push_back ( argv [ i + 1 ] ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - threads " ) == 0 ) { mThreads = strtol ( argv [ i + 1 ] , NULL , 10 ) ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - r " ) == 0 ) || ( strcmp ( argv [ i ] , " - rate " ) == 0 ) ) { mThrottleRate = strtod ( argv [ i + 1 ] , NULL ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - t " ) == 0 ) { mTimeout = strtod ( argv [ i + 1 ] , NULL ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - mp " ) == 0 ) { mSymbolMapFile = argv [ i + 1 ] ; handled = true ; } else if ( strcmp ( argv [ i ] , " - m " ) == 0 ) { mMiddleware = argv [ i + 1 ] ; handled = true ; } else if ( strcmp ( argv [ i ] , " - precision " ) == 0 ) { mPrecision = strtol ( argv [ i + 1 ] , NULL , 10 ) ; if ( ! mPrecision ) { mPrecision = 2 ; } if ( mPrecision > 6 ) { mPrecision = 6 ; } handled = true ; } else if ( strcmp ( " - shutdown " , argv [ i ] ) == 0 ) { mShutdownTime = atoi ( argv [ i + 1 ] ) ; } else if ( strcmp ( argv [ i ] , " - deltas " ) == 0 ) { mShowDeltas = true ; } else if ( strcmp ( argv [ i ] , " - churn " ) == 0 ) { mChurnRate = strtol ( argv [ i + 1 ] , NULL , 10 ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - timerInterval " ) == 0 ) { mTimerInterval = strtod ( argv [ i + 1 ] , NULL ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - logfile " ) == 0 ) { mLogFileName = argv [ i + 1 ] ; handled = true ; } else if ( strcmp ( argv [ i ] , " - f " ) == 0 ) { const char * filename = argv [ i + 1 ] ; ifstream input ( filename ) ; if ( ! input ) { cerr << " Cannot ▁ open ▁ file : ▁ " << filename << " \n " ; exit ( 1 ) ; } string symbol ; input >> symbol ; while ( ! input . eof ( ) ) { if ( ! symbol . empty ( ) ) { mSymbolList . push_back ( strdup ( symbol . c_str ( ) ) ) ; } input >> symbol ; } handled = true ; } else if ( strcmp ( argv [ i ] , " - v " ) == 0 ) { if ( mama_getLogLevel ( ) == MAMA_LOG_LEVEL_NORMAL ) { mama_enableLogging ( stderr , MAMA_LOG_LEVEL_FINE ) ; } else if ( mama_getLogLevel ( ) == MAMA_LOG_LEVEL_FINE ) { mama_enableLogging ( stderr , MAMA_LOG_LEVEL_FINER ) ; } else { mama_enableLogging ( stderr , MAMA_LOG_LEVEL_FINEST ) ; } handled = true ; } else if ( strcmp ( argv [ i ] , " - q " ) == 0 ) { if ( gExampleLogLevel == EXAMPLE_LOG_LEVEL_NORMAL ) { gExampleLogLevel = EXAMPLE_LOG_LEVEL_QUIET ; } else if ( gExampleLogLevel == EXAMPLE_LOG_LEVEL_QUIET ) { gExampleLogLevel = EXAMPLE_LOG_LEVEL_QUIETER ; } else if ( gExampleLogLevel == EXAMPLE_LOG_LEVEL_QUIETER ) { gExampleLogLevel = EXAMPLE_LOG_LEVEL_QUIETEST ; } handled = true ; } else if ( strcmp ( argv [ i ] , " - V " ) == 0 ) { if ( mSubscLogLevel == MAMA_LOG_LEVEL_NORMAL ) { mSubscLogLevel = MAMA_LOG_LEVEL_FINE ; } else if ( mSubscLogLevel == MAMA_LOG_LEVEL_FINE ) { mSubscLogLevel = MAMA_LOG_LEVEL_FINER ; } else { mSubscLogLevel = MAMA_LOG_LEVEL_FINEST ; } handled = true ; } else if ( strcmp ( argv [ i ] , " - W " ) == 0 ) { mUseWorldView = true ; handled = true ; } else if ( strcmp ( argv [ i ] , " - L " ) == 0 ) { mLogReqResp = true ; handled = true ; } else if ( strcmp ( argv [ i ] , " - Y " ) == 0 ) { mSymbology = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - ? " ) == 0 ) || ( strcmp ( argv [ i ] , " - - help " ) == 0 ) ) { usage ( 1 ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - PR " ) == 0 ) { mPublishRecaps = true ; } else if ( strcmp ( argv [ i ] , " - 1" ) == 0 ) { mSnapShot = true ; handled = true ; } else if ( strcmp ( argv [ i ] , " - Q " ) == 0 ) { mQuery = strtol ( argv [ i + 1 ] , NULL , 10 ) ; } else if ( strcmp ( argv [ i ] , " - QT " ) == 0 ) { mQueryType = strtol ( argv [ i + 1 ] , NULL , 10 ) ; } else if ( strcmp ( argv [ i ] , " - A1" ) == 0 ) { mQueryArg1 = argv [ i + 1 ] ; } else if ( strcmp ( argv [ i ] , " - A2" ) == 0 ) { mQueryArg2 = argv [ i + 1 ] ; } else if ( strcmp ( argv [ i ] , " - A3" ) == 0 ) { mQueryArg3 = argv [ i + 1 ] ; } else if ( strcmp ( argv [ i ] , " - A4" ) == 0 ) { mQueryArg4 = argv [ i + 1 ] ; } else if ( strcmp ( argv [ i ] , " - QC " ) == 0 ) { mQueryCycles = strtol ( argv [ i + 1 ] , NULL , 10 ) ; } if ( argv [ i ] [ 0 ] == ' - ' ) { const char * opt = argv [ i ] + 1 ; if ( strlen ( opt ) > 0 ) { if ( ( i + 1 < argc ) && ( argv [ i + 1 ] [ 0 ] != ' - ' ) ) { mOptions [ opt ] = argv [ i + 1 ] ; i += 2 ; } else { mOptions [ opt ] = "1" ; i ++ ; } } handled = true ; } if ( ! handled ) { usage ( 1 ) ; } } mBridge = Mama :: loadBridge ( mMiddleware ) ; }
void LetPropertiesOpt :: optimizeLetPropertyAccess ( VarDecl * Property , const InitSequence & init ) { assert ( init . isValid ( ) ) ; if ( SkipProcessing . count ( Property ) ) return ; auto * Ty = dyn_cast < NominalTypeDecl > ( Property -> getDeclContext ( ) ) ; if ( SkipTypeProcessing . count ( Ty ) ) return ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Replacing ▁ access ▁ to ▁ property ▁ ' " << * Property << " ' ▁ by ▁ its ▁ constant ▁ initializer \n " ) ; auto PropertyAccess = Property -> getEffectiveAccess ( ) ; auto TypeAccess = Ty -> getEffectiveAccess ( ) ; auto CanRemove = false ; if ( TypeAccess <= AccessLevel :: FilePrivate || PropertyAccess <= AccessLevel :: FilePrivate || ( ( TypeAccess <= AccessLevel :: Internal || PropertyAccess <= AccessLevel :: Internal ) && Module -> isWholeModule ( ) ) ) { CanRemove = true ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Storage ▁ for ▁ property ▁ ' " << * Property << " ' ▁ can ▁ be ▁ eliminated \n " ) ; } if ( CannotRemove . count ( Property ) ) CanRemove = false ; if ( ! AccessMap . count ( Property ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ is ▁ never ▁ read \n " ) ; if ( CanRemove ) { } return ; } auto & Loads = AccessMap [ Property ] ; unsigned NumReplaced = 0 ; for ( auto Load : Loads ) { SILFunction * F = Load -> getFunction ( ) ; auto cloneInitAt = [ & ] ( SILInstruction * insertionPoint ) -> SILValue { InitSequenceCloner cloner ( init , insertionPoint ) ; return cloner . clone ( ) ; } ; if ( isa < RefElementAddrInst > ( Load ) || isa < StructElementAddrInst > ( Load ) || isa < BeginAccessInst > ( Load ) ) { auto proj = cast < SingleValueInstruction > ( Load ) ; SILValue clonedInit = cloneInitAt ( proj ) ; SILBuilder@@ WithScope B ( proj ) ; for ( auto UI = proj -> use_begin ( ) , E = proj -> use_end ( ) ; UI != E ; ) { auto * User = UI -> getUser ( ) ; ++ UI ; if ( isIncidentalUse ( User ) ) continue ; if ( isa < BeginAccessInst > ( User ) ) continue ; if ( isa < StoreInst > ( User ) ) continue ; replaceLoadSequence ( User , clonedInit , B ) ; eraseUses@@ OfInstruction ( User ) ; User -> eraseFromParent ( ) ; ++ NumReplaced ; } ChangedFunctions . insert ( F ) ; } else if ( auto proj = dyn_cast < StructExtractInst > ( Load ) ) { SILValue clonedInit = cloneInitAt ( proj ) ; proj -> replaceAllUses@@ With ( clonedInit ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Access ▁ to ▁ " << * Property << " ▁ was ▁ replaced : \n " ; clonedInit -> dumpInContext ( ) ) ; proj -> eraseFromParent ( ) ; ++ NumReplaced ; ChangedFunctions . insert ( F ) ; } } LLVM_DEBUG ( llvm :: dbgs ( ) << " Access ▁ to ▁ " << * Property << " ▁ was ▁ replaced ▁ " << NumReplaced << " ▁ time ( s ) \n " ) ; if ( CanRemove ) { } }
bool LetPropertiesOpt :: isConstantLetProperty ( VarDecl * Property ) { if ( ! Property -> isLet ( ) || Property -> isStatic ( ) ) return false ; if ( SkipProcessing . count ( Property ) ) return false ; if ( PotentialConstantLetProperty . count ( Property ) ) return true ; if ( mayHaveUnknownUses ( Property , Module ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ may ▁ have ▁ unknown ▁ uses \n " ) ; SkipProcessing . insert ( Property ) ; return false ; } LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ has ▁ no ▁ unknown ▁ uses \n " ) ; if ( ! isSimpleType ( Module -> Types . getLoweredType ( Property -> getType ( ) ) , * Module ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ is ▁ not ▁ of ▁ trivial ▁ type \n " ) ; SkipProcessing . insert ( Property ) ; return false ; } PotentialConstantLetProperty . insert ( Property ) ; return true ; }
bool LetPropertiesOpt :: analyzeInitValue ( SILInstruction * I , VarDecl * Property ) { SILValue value ; if ( auto SI = dyn_cast < StructInst > ( I ) ) { value = SI -> getFieldValue ( Property ) ; } else if ( auto SI = dyn_cast < StoreInst > ( I ) ) { auto Dest = stripAddressAccess ( SI -> getDest ( ) ) ; assert ( isProjectionOfProperty ( stripAddressAccess ( SI -> getDest ( ) ) , Property ) && " Store ▁ instruction ▁ should ▁ store ▁ into ▁ a ▁ proper ▁ let ▁ property " ) ; ( void ) Dest ; value = SI -> getSrc ( ) ; } if ( auto * LI = dyn_cast < LoadInst > ( value ) ) { SILValue addr = LI -> getOperand ( ) ; if ( isProjectionOfProperty ( addr , Property ) ) return true ; } InitSequence sequence ; sequence . Result = value ; if ( ! analyzeStaticInitializer ( value , sequence . Instructions ) ) return false ; auto & cachedSequence = InitMap [ Property ] ; if ( cachedSequence . isValid ( ) && ! isSameInitSequence ( cachedSequence , sequence ) ) { return false ; } else { LLVM_DEBUG ( llvm :: dbgs ( ) << " The ▁ value ▁ of ▁ property ▁ ' " << * Property << " ' ▁ is ▁ statically ▁ known ▁ so ▁ far \n " ) ; cachedSequence = std :: move ( sequence ) ; return true ; } }
void LetPropertiesOpt :: collectStructPropertiesAccess ( StructInst * SI , bool NonRemovable ) { auto structDecl = SI -> getStructDecl ( ) ; if ( SkipTypeProcessing . count ( structDecl ) ) return ; if ( ! NominalTypeLetProperties . count ( structDecl ) ) { SmallVector < VarDecl * , 4 > LetProps ; for ( auto Prop : structDecl -> getStoredProperties ( ) ) { if ( ! isConstantLetProperty ( Prop ) ) continue ; LetProps . push_back ( Prop ) ; } if ( LetProps . empty ( ) ) { SkipTypeProcessing . insert ( structDecl ) ; return ; } NominalTypeLetProperties [ structDecl ] = LetProps ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Computed ▁ set ▁ of ▁ let ▁ properties ▁ for ▁ struct ▁ ' " << structDecl -> getName ( ) << " ' \n " ) ; } auto & Props = NominalTypeLetProperties [ structDecl ] ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Found ▁ a ▁ struct ▁ instruction ▁ initializing ▁ some ▁ " " let ▁ properties : ▁ " ; SI -> dumpInContext ( ) ) ; for ( auto Prop : Props ) { if ( SkipProcessing . count ( Prop ) ) continue ; SILValue PropValue = SI -> getOperandFor@@ Field ( Prop ) -> get ( ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Check ▁ the ▁ value ▁ of ▁ property ▁ ' " << * Prop << " ' ▁ : " << PropValue << " \n " ) ; if ( ! analyzeInitValue ( SI , Prop ) ) { SkipProcessing . insert ( Prop ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " The ▁ value ▁ of ▁ a ▁ let ▁ property ▁ ' " << * Prop << " ' ▁ is ▁ not ▁ statically ▁ known \n " ) ; } ( void ) PropValue ; } }
void LetPropertiesOpt :: collectPropertyAccess ( SILInstruction * I , VarDecl * Property , bool NonRemovable ) { if ( ! isConstantLetProperty ( Property ) ) return ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Collecting ▁ property ▁ access ▁ for ▁ property ▁ ' " << * Property << " ' : \n " ; llvm :: dbgs ( ) << " The ▁ instructions ▁ are : \n " ; I -> dumpInContext ( ) ) ; if ( isa < RefElementAddrInst > ( I ) || isa < StructElementAddrInst > ( I ) || isa < BeginAccessInst > ( I ) ) { auto projection = cast < SingleValueInstruction > ( I ) ; for ( auto Use : getNonDebugUses ( projection ) ) { auto * User = Use -> getUser ( ) ; if ( isIncidentalUse ( User ) ) continue ; if ( isa < BeginAccessInst > ( User ) ) continue ; if ( auto * SI = dyn_cast < StoreInst > ( User ) ) { if ( SI -> getDest ( ) != projection || ! analyzeInitValue ( SI , Property ) ) { SkipProcessing . insert ( Property ) ; return ; } continue ; } if ( ! isValidPropertyLoad ( User ) ) { SkipProcessing . insert ( Property ) ; return ; } } } AccessMap [ Property ] . push_back ( I ) ; if ( NonRemovable ) CannotRemove . insert ( Property ) ; }
void LetPropertiesOpt :: run ( SILModuleTransform * T ) { for ( auto & F : * Module ) { bool NonRemovable = ! F . shouldOptimize ( ) ; for ( auto & BB : F ) { for ( auto & I : BB ) if ( auto * BAI = dyn_cast < BeginAccessInst > ( & I ) ) { if ( auto * REAI = dyn_cast < RefElementAddrInst > ( stripAddressAccess ( BAI ) ) ) { collectPropertyAccess ( BAI , REAI -> getField ( ) , NonRemovable ) ; } } else if ( auto * REAI = dyn_cast < RefElementAddrInst > ( & I ) ) { collectPropertyAccess ( REAI , REAI -> getField ( ) , NonRemovable ) ; } else if ( auto * SEI = dyn_cast < StructExtractInst > ( & I ) ) { collectPropertyAccess ( SEI , SEI -> getField ( ) , NonRemovable ) ; } else if ( auto * SEAI = dyn_cast < StructElementAddrInst > ( & I ) ) { collectPropertyAccess ( SEAI , SEAI -> getField ( ) , NonRemovable ) ; } else if ( auto * SI = dyn_cast < StructInst > ( & I ) ) { collectStructPropertiesAccess ( SI , NonRemovable ) ; } } } for ( auto & Init : InitMap ) { optimizeLetPropertyAccess ( Init . first , Init . second ) ; } for ( SILFunction * ChangedFn : ChangedFunctions ) { T -> invalidateAnalysis ( ChangedFn , SILAnalysis :: InvalidationKind :: Instructions ) ; } }
SILTransform * swift :: createLetPropertiesOpt ( ) { return new LetPropertiesOptPass ( ) ; }
HrPwPlot :: HrPwPlot ( MainWindow * mainWindow , HrPwWindow * hrPwWindow ) : QwtPlot ( hrPwWindow ) , hrPwWindow ( hrPwWindow ) , mainWindow ( mainWindow ) , bg ( NULL ) , delay ( - 1 ) , minHr ( 50 ) , minWatt ( 50 ) , maxWatt ( 500 ) , settings ( GC_SETTINGS_CO , GC_SETTINGS_AP@@ P ) , unit ( settings . value ( GC_UNIT ) ) { setCanvas@@ Background ( Qt :: white ) ; canvas ( ) -> setFrameStyle ( QFrame :: NoFrame ) ; setXTitle ( ) ; regCurve = new QwtPlotCurve ( " reg " ) ; regCurve -> setPen ( QPen ( GColor ( CPLOTMARKER ) ) ) ; regCurve -> attach ( this ) ; wattsStepCurve = new QwtPlotCurve ( " Power " ) ; wattsStepCurve -> setStyle ( QwtPlotCurve :: Steps ) ; wattsStepCurve -> setRenderHint ( QwtPlotItem :: RenderAntialiased ) ; QColor wattsColor = QColor ( 200 , 200 , 255 ) ; QColor wattsColor2 = QColor ( 100 , 100 , 255 ) ; wattsStepCurve -> setPen ( QPen ( wattsColor2 ) ) ; wattsStepCurve -> setBrush ( QBrush ( wattsColor ) ) ; wattsStepCurve -> attach ( this ) ; hrStepCurve = new QwtPlotCurve ( " Hr " ) ; hrStepCurve -> setStyle ( QwtPlotCurve :: Steps ) ; hrStepCurve -> setRenderHint ( QwtPlotItem :: RenderAntialiased ) ; QColor hrColor = QColor ( 255 , 200 , 200 ) ; QColor hrColor2 = QColor ( 255 , 100 , 100 ) ; hrStepCurve -> setPen ( QPen ( hrColor2 ) ) ; hrStepCurve -> setBrush ( QBrush ( hrColor ) ) ; hrStepCurve -> attach ( this ) ; hrCurves . resize ( 36 ) ; for ( int i = 0 ; i < 36 ; ++ i ) { hrCurves [ i ] = new QwtPlotCurve ; hrCurves [ i ] -> attach ( this ) ; } grid = new QwtPlotGrid ( ) ; grid -> enableX ( false ) ; QPen gridPen ; gridPen . setStyle ( Qt :: DotLine ) ; gridPen . setColor ( GColor ( CPLOTGRID ) ) ; grid -> setPen ( gridPen ) ; grid -> attach ( this ) ; r_mrk1 = new QwtPlotMarker ; r_mrk2 = new QwtPlotMarker ; r_mrk1 -> attach ( this ) ; r_mrk2 -> attach ( this ) ; shade_zones = true ; }
void HrPwPlot :: setAxisTitle ( int axis , QString label ) { QFont stGiles ; stGiles . fromString ( appsettings -> value ( this , GC_FONT_CHARTLABELS , QFont ( ) . toString ( ) ) . toString ( ) ) ; stGiles . setPointSize ( appsettings -> value ( NULL , GC_FONT_CHARTLABELS_SIZE , 8 ) . toInt ( ) ) ; QwtText title ( label ) ; title . setFont ( stGiles ) ; QwtPlot :: setAxisFont ( axis , stGiles ) ; QwtPlot :: setAxisTitle ( axis , title ) ; }
void HrPwPlot :: recalc ( ) { if ( timeArray . count ( ) == 0 ) return ; int rideTimeSecs = ( int ) ceil ( timeArray [ arrayLength - 1 ] ) ; if ( rideTimeSecs > 7 * 24 * 60 * 60 ) { return ; } double totalWatts = 0.0 ; double totalHr = 0.0 ; QList < DataPoint * > list ; int i = 0 ; QVector < double > smoothWatts ( rideTimeSecs + 1 ) ; QVector < double > smoothHr ( rideTimeSecs + 1 ) ; QVector < double > smoothTime ( rideTimeSecs + 1 ) ; int decal = 0 ; int smooth = hrPwWindow -> smooth ; for ( int secs = smooth ; secs <= rideTimeSecs ; ++ secs ) { while ( ( i < arrayLength ) && ( timeArray [ i ] <= secs ) ) { DataPoint * dp = new DataPoint ( timeArray [ i ] , hrArray [ i ] , wattsArray [ i ] , interArray [ i ] ) ; totalWatts += wattsArray [ i ] ; totalHr += hrArray [ i ] ; list . append ( dp ) ; ++ i ; } while ( ! list . empty ( ) && ( list . front ( ) -> time < secs - smooth ) ) { DataPoint * dp = list . front ( ) ; list . removeFirst ( ) ; totalWatts -= dp -> watts ; totalHr -= dp -> hr ; delete dp ; } if ( list . empty ( ) ) { ++ decal ; } else { smoothWatts [ secs - decal ] = totalWatts / list . size ( ) ; smoothHr [ secs - decal ] = totalHr / list . size ( ) ; } smoothTime [ secs ] = secs / 60.0 ; } rideTimeSecs = rideTimeSecs - decal ; smoothWatts . resize ( rideTimeSecs ) ; smoothHr . resize ( rideTimeSecs ) ; QVector < double > clipWatts ( rideTimeSecs ) ; QVector < double > clipHr ( rideTimeSecs ) ; decal = 0 ; for ( int secs = 0 ; secs < rideTimeSecs ; ++ secs ) { if ( smoothHr [ secs ] >= minHr && smoothWatts [ secs ] >= minWatt && smoothWatts [ secs ] < maxWatt ) { clipWatts [ secs - decal ] = smoothWatts [ secs ] ; clipHr [ secs - decal ] = smoothHr [ secs ] ; } else decal ++ ; } rideTimeSecs = rideTimeSecs - decal ; clipWatts . resize ( rideTimeSecs ) ; clipHr . resize ( rideTimeSecs ) ; if ( delay == - 1 ) delay = hrPwWindow -> findDelay ( clipWatts , clipHr , clipWatts . size ( ) ) ; QVector < double > delayWatts ( rideTimeSecs - delay ) ; QVector < double > delayHr ( rideTimeSecs - delay ) ; for ( int secs = 0 ; secs < rideTimeSecs - delay ; ++ secs ) { delayWatts [ secs ] = clipWatts [ secs ] ; delayHr [ secs ] = clipHr [ secs + delay ] ; } rideTimeSecs = rideTimeSecs - delay ; double rpente = hrPwWindow -> pente ( delayWatts , delayHr , delayWatts . size ( ) ) ; double rordonnee = hrPwWindow -> ordonnee ( delayWatts , delayHr , delayWatts . size ( ) ) ; double maxr = hrPwWindow -> corr ( delayWatts , delayHr , delayWatts . size ( ) ) ; int intpoints = 10 ; int nbpoints = ( int ) floor ( rideTimeSecs / intpoints ) ; QVector < double > plotedWatts ( nbpoints ) ; QVector < double > plotedHr ( nbpoints ) ; for ( int secs = 0 ; secs < nbpoints ; ++ secs ) { plotedWatts [ secs ] = clipWatts [ secs * intpoints ] ; plotedHr [ secs ] = clipHr [ secs * intpoints ] ; } int nbpoints2 = ( int ) floor ( nbpoints / 36 ) + 2 ; double * plotedWattsArray [ 36 ] ; double * plotedHrArray [ 36 ] ; for ( int i = 0 ; i < 36 ; ++ i ) { plotedWattsArray [ i ] = new double [ nbpoints2 ] ; plotedHrArray [ i ] = new double [ nbpoints2 ] ; } for ( int secs = 0 ; secs < nbpoints ; ++ secs ) { for ( int i = 0 ; i < 36 ; ++ i ) { if ( secs >= i * nbpoints2 && secs < ( i + 1 ) * nbpoints2 ) { plotedWattsArray [ i ] [ secs - i * nbpoints2 ] = plotedWatts [ secs - i ] ; plotedHrArray [ i ] [ secs - i * nbpoints2 ] = plotedHr [ secs - i ] ; } } } for ( int i = 0 ; i < 36 ; ++ i ) { if ( nbpoints - i * nbpoints2 > 0 ) { hrCurves [ i ] -> setData ( plotedWattsArray [ i ] , plotedHrArray [ i ] , ( nbpoints - i * nbpoints2 < nbpoints2 ? nbpoints - i * nbpoints2 : nbpoints2 ) ) ; hrCurves [ i ] -> setVisible ( true ) ; } else hrCurves [ i ] -> setVisible ( false ) ; } setAxisScale ( xBottom , 0.0 , maxWatt ) ; setYMax ( ) ; refreshZoneLabels ( ) ; QString labelp ; labelp . setNum ( rpente , ' f ' , 3 ) ; QString labelo ; labelo . setNum ( rordonnee , ' f ' , 1 ) ; QString labelr ; labelr . setNum ( maxr , ' f ' , 3 ) ; QString labeldelay ; labeldelay . setNum ( delay ) ; int power150 = ( int ) floor ( ( 150 - rordonnee ) / rpente ) ; QString labelpower150 ; labelpower150 . setNum ( power150 ) ; QwtText textr = QwtText ( labelp + " * x + " + labelo + " ▁ : ▁ R ▁ " + labelr + " ▁ ( " + labeldelay + " ) ▁ \n ▁ Power @ 150 : " + labelpower150 + " W " ) ; textr . setFont ( QFont ( " Helvetica " , 10 , QFont :: Bold ) ) ; textr . setColor ( Qt :: black ) ; r_mrk1 -> setValue ( 0 , 0 ) ; r_mrk1 -> setLineStyle ( QwtPlotMarker :: VLine ) ; r_mrk1 -> setLabelAlignment ( Qt :: AlignRight | Qt :: AlignTop ) ; r_mrk1 -> setLinePen ( QPen ( Qt :: black , 0 , Qt :: DashDotLine ) ) ; double moyennewatt = hrPwWindow -> moyenne ( clipWatts , clipWatts . size ( ) ) ; r_mrk1 -> setValue ( moyennewatt , 0.0 ) ; r_mrk1 -> setLabel ( textr ) ; r_mrk2 -> setValue ( 0 , 0 ) ; r_mrk2 -> setLineStyle ( QwtPlotMarker :: HLine ) ; r_mrk2 -> setLabelAlignment ( Qt :: AlignRight | Qt :: AlignTop ) ; r_mrk2 -> setLinePen ( QPen ( Qt :: black , 0 , Qt :: DashDotLine ) ) ; double moyennehr = hrPwWindow -> moyenne ( clipHr , clipHr . size ( ) ) ; r_mrk2 -> setValue ( 0.0 , moyennehr ) ; addWattStepCurve ( clipWatts , clipWatts . size ( ) ) ; addHrStepCurve ( clipHr , clipHr . size ( ) ) ; addRegLinCurve ( rpente , rordonnee ) ; setJoinLine ( joinLine ) ; replot ( ) ; }
void HrPwPlot :: setYMax ( ) { double ymax = 0 ; QString ylabel = " " ; for ( int i = 0 ; i < 36 ; ++ i ) { if ( hrCurves [ i ] -> isVisible ( ) ) { ymax = max ( ymax , hrCurves [ i ] -> maxYValue ( ) ) ; } } setAxisScale ( yLeft , minHr , ymax * 1.2 ) ; setAxisTitle ( yLeft , tr ( " Heart ▁ Rate ( BPM ) " ) ) ; }
void HrPwPlot :: addWattStepCurve ( QVector < double > & finalWatts , int nbpoints ) { QMap < double , double > powerHist ; for ( int h = 0 ; h < nbpoints ; ++ h ) { if ( powerHist . contains ( finalWatts [ h ] ) ) powerHist [ finalWatts [ h ] ] += 1 ; else powerHist [ finalWatts [ h ] ] = 1 ; } int maxPower = 500 ; double * array = new double [ maxPower ] ; for ( int i = 0 ; i < maxPower ; ++ i ) array [ i ] = 0.0 ; QMapIterator < double , double > k ( powerHist ) ; while ( k . hasNext ( ) ) { k . next ( ) ; array [ ( int ) round ( k . key ( ) ) ] += k . value ( ) ; } int nbSteps = ( int ) ceil ( ( maxPower - 1 ) / 10 ) ; QVector < double > smoothWattsStep ( nbSteps + 1 ) ; QVector < double > smoothTimeStep ( nbSteps + 1 ) ; int t ; for ( t = 1 ; t < nbSteps ; ++ t ) { int low = t * 10 ; int high = low + 10 ; smoothWattsStep [ t ] = low ; smoothTimeStep [ t ] = minHr ; while ( low < high ) { smoothTimeStep [ t ] += array [ low ++ ] / nbpoints * 300 ; } } smoothTimeStep [ t ] = 0.0 ; smoothWattsStep [ t ] = t * 10 ; wattsStepCurve -> setData ( smoothWattsStep . data ( ) , smoothTimeStep . data ( ) , nbSteps + 1 ) ; }
void HrPwPlot :: addHrStepCurve ( QVector < double > & finalHr , int nbpoints ) { QMap < double , double > hrHist ; for ( int h = 0 ; h < nbpoints ; ++ h ) { if ( hrHist . contains ( finalHr [ h ] ) ) hrHist [ finalHr [ h ] ] += 1 ; else hrHist [ finalHr [ h ] ] = 1 ; } int maxHr = 220 ; double * array = new double [ maxHr ] ; for ( int i = 0 ; i < maxHr ; ++ i ) array [ i ] = 0.0 ; QMapIterator < double , double > l ( hrHist ) ; while ( l . hasNext ( ) ) { l . next ( ) ; array [ ( int ) round ( l . key ( ) ) ] += l . value ( ) ; } int nbSteps = ( int ) ceil ( ( maxHr - 1 ) / 2 ) ; QVector < double > smoothHrStep ( nbSteps + 1 ) ; QVector < double > smoothTimeStep2 ( nbSteps + 1 ) ; int t ; for ( t = 1 ; t < nbSteps ; ++ t ) { int low = t * 2 ; int high = low + 2 ; smoothHrStep [ t ] = low ; smoothTimeStep2 [ t ] = 0.0 ; while ( low < high ) { smoothTimeStep2 [ t ] += array [ low ++ ] / nbpoints * 500 ; } } smoothTimeStep2 [ t ] = 0.0 ; smoothHrStep [ t ] = t * 2 ; hrStepCurve -> setData ( smoothTimeStep2 . data ( ) , smoothHrStep . data ( ) , nbSteps + 1 ) ; }
void HrPwPlot :: addRegLinCurve ( double rpente , double rordonnee ) { double regWatts [ ] = { 0 , 0 } ; double regHr [ ] = { 0 , 500 } ; regWatts [ 0 ] = regHr [ 0 ] * rpente + rordonnee ; regWatts [ 1 ] = regHr [ 1 ] * rpente + rordonnee ; regCurve -> setData ( regHr , regWatts , 2 ) ; }
void HrPwPlot :: setXTitle ( ) { setAxisTitle ( xBottom , tr ( " Power ▁ ( Watts ) " ) ) ; }
void HrPwPlot :: setDataFromRide ( RideItem * _rideItem ) { rideItem = _rideItem ; if ( ! _rideItem || ! _rideItem -> ride ( ) ) return ; RideFile * ride = rideItem -> ride ( ) ; const RideFileDataPresent * dataPresent = ride -> areDataPresent ( ) ; int npoints = ride -> dataPoints ( ) . size ( ) ; if ( dataPresent -> watts && dataPresent -> hr ) { wattsArray . resize ( npoints ) ; hrArray . resize ( npoints ) ; timeArray . resize ( npoints ) ; interArray . resize ( npoints ) ; arrayLength = 0 ; foreach ( const RideFilePoint * point , ride -> dataPoints ( ) ) { if ( ! timeArray . empty ( ) ) timeArray [ arrayLength ] = point -> secs ; if ( ! wattsArray . empty ( ) ) wattsArray [ arrayLength ] = max ( 0 , point -> watts ) ; if ( ! hrArray . empty ( ) ) hrArray [ arrayLength ] = max ( 0 , point -> hr ) ; if ( ! interArray . empty ( ) ) interArray [ arrayLength ] = point -> interval ; ++ arrayLength ; } delay = - 1 ; recalc ( ) ; } }
void HrPwPlot :: setJoinLine ( bool value ) { joinLine = value ; for ( int i = 0 ; i < 36 ; ++ i ) { QColor color = QColor ( 255 , 255 , 255 ) ; color . setHsv ( 60 + i * ( 360 / 36 ) , 255 , 255 , 255 ) ; if ( value ) { QwtSymbol sym ; sym . setStyle ( QwtSymbol :: NoSymbol ) ; QPen pen = QPen ( color ) ; pen . setWidth ( 1 ) ; hrCurves [ i ] -> setPen ( pen ) ; hrCurves [ i ] -> setStyle ( QwtPlotCurve :: Lines ) ; hrCurves [ i ] -> setSymbol ( new QwtSymbol ( sym ) ) ; } else { QwtSymbol sym ; sym . setStyle ( QwtSymbol :: Ellipse ) ; sym . setSize ( 5 ) ; sym . setPen ( QPen ( color ) ) ; sym . setBrush ( QBrush ( color ) ) ; hrCurves [ i ] -> setPen ( Qt :: NoPen ) ; hrCurves [ i ] -> setStyle ( QwtPlotCurve :: Dots ) ; hrCurves [ i ] -> setSymbol ( new QwtSymbol ( sym ) ) ; } } }
void HrPwPlot :: pointHo@@ ver ( QwtPlotCurve * curve , int index ) { if ( index >= 0 ) { double yvalue = curve -> sample ( index ) . y ( ) ; double xvalue = curve -> sample ( index ) . x ( ) ; QString text = QString ( " % 1 ▁ % 2 \n % 3 ▁ % 4" ) . arg ( yvalue , 0 , ' f ' , 0 ) . arg ( this -> axisTitle ( curve -> yAxis ( ) ) . text ( ) ) . arg ( xvalue , 0 , ' f ' , 2 ) . arg ( this -> axisTitle ( curve -> xAxis ( ) ) . text ( ) ) ; tooltip -> setText ( text ) ; } else { tooltip -> setText ( " " ) ; } }
void AbstractState :: beginBasicBlock ( BasicBlock * basicBlock ) { ASSERT ( ! m_block ) ; ASSERT ( basicBlock -> variablesAtHead . numberOfLocals ( ) == basicBlock -> valuesAtHead . numberOfLocals ( ) ) ; ASSERT ( basicBlock -> variablesAtTail . numberOfLocals ( ) == basicBlock -> valuesAtTail . numberOfLocals ( ) ) ; ASSERT ( basicBlock -> variablesAtHead . numberOfLocals ( ) == basicBlock -> variablesAtTail . numberOfLocals ( ) ) ; for ( size_t i = 0 ; i < basicBlock -> size ( ) ; i ++ ) forNode ( basicBlock -> at ( i ) ) . clear ( ) ; m_variables = basicBlock -> valuesAtHead ; m_haveStructures = false ; for ( size_t i = 0 ; i < m_variables . numberOfArguments ( ) ; ++ i ) { if ( m_variables . argument ( i ) . m_currentKnownStructure . isNeitherClearNorTop ( ) ) { m_haveStructures = true ; break ; } } for ( size_t i = 0 ; i < m_variables . numberOfLocals ( ) ; ++ i ) { if ( m_variables . local ( i ) . m_currentKnownStructure . isNeitherClearNorTop ( ) ) { m_haveStructures = true ; break ; } } basicBlock -> cfaShouldRevisit = false ; basicBlock -> cfaHasVisited = true ; m_block = basicBlock ; m_isValid = true ; m_foundConstants = false ; m_branchDirection = InvalidBranchDirection ; }
void AbstractState :: initialize ( Graph & graph ) { BasicBlock * root = graph . m_blocks [ 0 ] . get ( ) ; root -> cfaShouldRevisit = true ; root -> cfaHasVisited = false ; root -> cfaFoundConstants = false ; for ( size_t i = 0 ; i < root -> valuesAtHead . numberOfArguments ( ) ; ++ i ) { Node * node = root -> variablesAtHead . argument ( i ) ; ASSERT ( node -> op ( ) == SetArgument ) ; if ( ! node -> variableAccessData ( ) -> shouldUnbox@@ IfPossible ( ) ) { root -> valuesAtHead . argument ( i ) . makeTop ( ) ; continue ; } SpeculatedType prediction = node -> variableAccessData ( ) -> prediction ( ) ; if ( isInt32Speculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecInt32 ) ; else if ( isBooleanSpeculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecBoolean ) ; else if ( isCellSpeculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecCell ) ; else root -> valuesAtHead . argument ( i ) . makeTop ( ) ; root -> valuesAtTail . argument ( i ) . clear ( ) ; } for ( size_t i = 0 ; i < root -> valuesAtHead . numberOfLocals ( ) ; ++ i ) { Node * node = root -> variablesAtHead . local ( i ) ; if ( node && node -> variableAccessData ( ) -> isCaptured ( ) ) root -> valuesAtHead . local ( i ) . makeTop ( ) ; else root -> valuesAtHead . local ( i ) . clear ( ) ; root -> valuesAtTail . local ( i ) . clear ( ) ; } for ( BlockIndex blockIndex = 1 ; blockIndex < graph . m_blocks . size ( ) ; ++ blockIndex ) { BasicBlock * block = graph . m_blocks [ blockIndex ] . get ( ) ; if ( ! block ) continue ; if ( ! block -> isReachable ) continue ; block -> cfaShouldRevisit = false ; block -> cfaHasVisited = false ; block -> cfaFoundConstants = false ; for ( size_t i = 0 ; i < block -> valuesAtHead . numberOfArguments ( ) ; ++ i ) { block -> valuesAtHead . argument ( i ) . clear ( ) ; block -> valuesAtTail . argument ( i ) . clear ( ) ; } for ( size_t i = 0 ; i < block -> valuesAtHead . numberOfLocals ( ) ; ++ i ) { block -> valuesAtHead . local ( i ) . clear ( ) ; block -> valuesAtTail . local ( i ) . clear ( ) ; } if ( ! block -> isOSRTarget ) continue ; if ( block -> bytecodeBegin != graph . m_osrEntryBytecodeIndex ) continue ; for ( size_t i = 0 ; i < graph . m_mustHandleValues . size ( ) ; ++ i ) { AbstractValue value ; value . setMostSpecific ( graph . m_mustHandleValues [ i ] ) ; int operand = graph . m_mustHandleValues . operandForIndex ( i ) ; block -> valuesAtHead . operand ( operand ) . merge ( value ) ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ Initializing ▁ Block ▁ # % u , ▁ operand ▁ r % d , ▁ to ▁ " , blockIndex , operand ) ; block -> valuesAtHead . operand ( operand ) . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; } block -> cfaShouldRevisit = true ; } }
bool AbstractState :: endBasicBlock ( MergeMode mergeMode ) { ASSERT ( m_block ) ; BasicBlock * block = m_block ; block -> cfaFoundConstants = m_foundConstants ; block -> cfaDid@@ Finish = m_isValid ; block -> cfaBranchDirection = m_branchDirection ; if ( ! m_isValid ) { reset ( ) ; return false ; } bool changed = false ; if ( mergeMode != DontMerge || ! ASSERT_DISABLED ) { for ( size_t argument = 0 ; argument < block -> variablesAtTail . numberOfArguments ( ) ; ++ argument ) { ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ state ▁ for ▁ argument ▁ % zu . \n " , argument ) ; AbstractValue & destination = block -> valuesAtTail . argument ( argument ) ; changed |= mergeStateAtTail ( destination , m_variables . argument ( argument ) , block -> variablesAtTail . argument ( argument ) ) ; } for ( size_t local = 0 ; local < block -> variablesAtTail . numberOfLocals ( ) ; ++ local ) { ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ state ▁ for ▁ local ▁ % zu . \n " , local ) ; AbstractValue & destination = block -> valuesAtTail . local ( local ) ; changed |= mergeStateAtTail ( destination , m_variables . local ( local ) , block -> variablesAtTail . local ( local ) ) ; } } ASSERT ( mergeMode != DontMerge || ! changed ) ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Branch ▁ direction ▁ = ▁ % s \n " , branchDirection@@ ToString ( m_branchDirection ) ) ; reset ( ) ; if ( mergeMode != MergeToSuccessors ) return changed ; return mergeToSuccessors ( m_graph , block ) ; }
void AbstractState :: reset ( ) { m_block = 0 ; m_isValid = false ; m_branchDirection = InvalidBranchDirection ; }
AbstractState :: BooleanResult AbstractState :: booleanResult ( Node * node , AbstractValue & value ) { JSValue childConst = value . value ( ) ; if ( childConst ) { if ( childConst . toBoolean ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> globalExec ( ) ) ) return DefinitelyTrue ; return DefinitelyFalse ; } if ( isCellSpeculation ( value . m_type ) && value . m_currentKnownStructure . hasSing@@ leton ( ) ) { Structure * structure = value . m_currentKnownStructure . singleton ( ) ; if ( ! structure -> masqueradesAsUndefined ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) ) && structure -> typeInfo ( ) . type ( ) != StringType ) return DefinitelyTrue ; } return UnknownBooleanResult ; }
bool AbstractState :: startExecuting ( Node * node ) { ASSERT ( m_block ) ; ASSERT ( m_isValid ) ; m_didClobber = false ; node -> setCanExit ( false ) ; if ( ! node -> shouldGenerate ( ) ) return false ; return true ; }
bool AbstractState :: startExecuting ( unsigned indexInBlock ) { return startExecuting ( m_block -> at ( indexInBlock ) ) ; }
void AbstractState :: executeEdges ( Node * node ) { DFG_NODE_DO_TO_CHILDREN ( m_graph , node , filterEdge@@ ByUse ) ; }
void AbstractState :: executeEdges ( unsigned indexInBlock ) { executeEdges ( m_block -> at ( indexInBlock ) ) ; }
void AbstractState :: verifyEdge ( Node * , Edge edge ) { RELEASE_ASSERT ( ! ( forNode ( edge ) . m_type & ~ typeFilter@@ For ( edge . useKind ( ) ) ) ) ; }
void AbstractState :: verifyEdges ( Node * node ) { DFG_NODE_DO_TO_CHILDREN ( m_graph , node , verifyEdge ) ; }
bool AbstractState :: executeEffects ( unsigned indexInBlock , Node * node ) { if ( ! ASSERT_DISABLED ) verifyEdges ( node ) ; switch ( node -> op ( ) ) { case JSConstant : case WeakJSConstant : case PhantomArguments : { forNode ( node ) . set ( m_graph . valueOfJSConstant ( node ) ) ; break ; } case Identity : { forNode ( node ) = forNode ( node -> child1 ( ) ) ; break ; } case GetLocal : { VariableAccessData * variableAccessData = node -> variableAccessData ( ) ; if ( variableAccessData -> prediction ( ) == SpecNone ) { m_isValid = false ; break ; } AbstractValue value = m_variables . operand ( variableAccessData -> local ( ) ) ; if ( ! variableAccessData -> isCaptured ( ) ) { if ( value . isClear ( ) ) node -> setCanExit ( true ) ; } if ( value . value ( ) ) m_foundConstants = true ; forNode ( node ) = value ; break ; } case GetLocalUnlinked : { AbstractValue value = m_variables . operand ( node -> unlinkedLocal ( ) ) ; if ( value . value ( ) ) m_foundConstants = true ; forNode ( node ) = value ; break ; } case SetLocal : { m_variables . operand ( node -> local ( ) ) = forNode ( node -> child1 ( ) ) ; break ; } case MovHint@@ AndCheck : { break ; } case MovHint : case ZombieHint : { RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } case SetArgument : ASSERT ( ! m_block -> valuesAtHead . operand ( node -> local ( ) ) . isClear ( ) ) ; break ; case BitAnd : case BitOr : case BitXor : case BitRShift : case BitLShift : case BitURShift : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isInt32 ( ) && right . isInt32 ( ) ) { int32_t a = left . asInt32 ( ) ; int32_t b = right . asInt32 ( ) ; bool constantWasSet ; switch ( node -> op ( ) ) { case BitAnd : constantWasSet = trySetConstant ( node , JSValue ( a & b ) ) ; break ; case BitOr : constantWasSet = trySetConstant ( node , JSValue ( a | b ) ) ; break ; case BitXor : constantWasSet = trySetConstant ( node , JSValue ( a ^ b ) ) ; break ; case BitRShift : constantWasSet = trySetConstant ( node , JSValue ( a >> static_cast < uint32_t > ( b ) ) ) ; break ; case BitLShift : constantWasSet = trySetConstant ( node , JSValue ( a << static_cast < uint32_t > ( b ) ) ) ; break ; case BitURShift : constantWasSet = trySetConstant ( node , JSValue ( static_cast < uint32_t > ( a ) >> static_cast < uint32_t > ( b ) ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecInt32 ) ; break ; } case UInt32ToNumber : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { ASSERT ( child . isInt32 ( ) ) ; if ( trySetConstant ( node , JSValue ( child . asUInt32 ( ) ) ) ) { m_foundConstants = true ; break ; } } if ( ! node -> canSpeculateInteger ( ) ) forNode ( node ) . set ( SpecDouble ) ; else { forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; } break ; } case DoubleAsInt32 : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { double asDouble = child . asNumber ( ) ; int32_t asInt = JSC :: toInt32 ( asDouble ) ; if ( bitwise_cast < int64_t > ( static_cast < double > ( asInt ) ) == bitwise_cast < int64_t > ( asDouble ) && trySetConstant ( node , JSValue ( asInt ) ) ) { m_foundConstants = true ; break ; } } node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecInt32 ) ; break ; } case ValueToInt32 : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { bool constantWasSet ; if ( child . isInt32 ( ) ) constantWasSet = trySetConstant ( node , child ) ; else constantWasSet = trySetConstant ( node , JSValue ( JSC :: toInt32 ( child . asDouble ( ) ) ) ) ; if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecInt32 ) ; break ; } case Int32ToDouble : case ForwardInt32ToDouble : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( JSValue :: EncodeAsDouble , child . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } if ( isInt32Speculation ( forNode ( node -> child1 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; } case ValueAdd : case ArithAdd : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) + right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : if ( isRealNumberSpeculation ( forNode ( node -> child1 ( ) ) . m_type ) && isRealNumberSpeculation ( forNode ( node -> child2 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT ( node -> op ( ) == ValueAdd ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . set ( SpecString | SpecInt32 | SpecNumber ) ; break ; } break ; } case MakeRop@@ e : { forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case ArithSub : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) - right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithNeg@@ ate : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( - child . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithMul : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) * right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) || ! nodeCanIgnoreNegative@@ Zero ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : if ( isRealNumberSpeculation ( forNode ( node -> child1 ( ) ) . m_type ) || isRealNumberSpeculation ( forNode ( node -> child2 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithIMul : { forNode ( node ) . set ( SpecInt32 ) ; break ; } case ArithDiv : case ArithMin : case ArithMax : case ArithMod : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) ) { double a = left . asNumber ( ) ; double b = right . asNumber ( ) ; bool constantWasSet ; switch ( node -> op ( ) ) { case ArithDiv : constantWasSet = trySetConstant ( node , JSValue ( a / b ) ) ; break ; case ArithMin : constantWasSet = trySetConstant ( node , JSValue ( a < b ? a : ( b <= a ? b : a + b ) ) ) ; break ; case ArithMax : constantWasSet = trySetConstant ( node , JSValue ( a > b ? a : ( b >= a ? b : a + b ) ) ) ; break ; case ArithMod : constantWasSet = trySetConstant ( node , JSValue ( fmod ( a , b ) ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; break ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithAbs : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( fabs ( child . asNumber ( ) ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithSqrt : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( sqrt ( child . asNumber ( ) ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecDouble ) ; break ; } case Logical@@ Not : { bool didSetConstant = false ; switch ( booleanResult ( node , forNode ( node -> child1 ( ) ) ) ) { case DefinitelyTrue : didSetConstant = trySetConstant ( node , jsBoolean ( false ) ) ; break ; case DefinitelyFalse : didSetConstant = trySetConstant ( node , jsBoolean ( true ) ) ; break ; default : break ; } if ( didSetConstant ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case BooleanUse : case Int32Use : case NumberUse : case UntypedUse : break ; case ObjectOr@@ OtherUse : node -> setCanExit ( true ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( SpecBoolean ) ; break ; } case IsUndefined : case IsBoolean : case IsNumber : case IsString : case IsObject : case IsFunction : { node -> setCanExit ( node -> op ( ) == IsUndefined && m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> masqueradesAsUndefinedWatchpoint ( ) -> isStillValid ( ) ) ; JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child ) { bool constantWasSet ; switch ( node -> op ( ) ) { case IsUndefined : if ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> masqueradesAsUndefinedWatchpoint ( ) -> isStillValid ( ) ) { constantWasSet = trySetConstant ( node , jsBoolean ( child . isCell ( ) ? false : child . isUndefined ( ) ) ) ; } else { constantWasSet = trySetConstant ( node , jsBoolean ( child . isCell ( ) ? child . asCell ( ) -> structure ( ) -> masqueradesAsUndefined ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) ) : child . isUndefined ( ) ) ) ; } break ; case IsBoolean : constantWasSet = trySetConstant ( node , jsBoolean ( child . isBoolean ( ) ) ) ; break ; case IsNumber : constantWasSet = trySetConstant ( node , jsBoolean ( child . isNumber ( ) ) ) ; break ; case IsString : constantWasSet = trySetConstant ( node , jsBoolean ( isJSString ( child ) ) ) ; break ; case IsObject : if ( child . isNull ( ) || ! child . isObject ( ) ) { constantWasSet = trySetConstant ( node , jsBoolean ( child . isNull ( ) ) ) ; break ; } default : constantWasSet = false ; break ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecBoolean ) ; break ; } case TypeOf : { VM * vm = m_codeBlock -> vm ( ) ; JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; AbstractValue & abstractChild = forNode ( node -> child1 ( ) ) ; if ( child ) { JSValue typeString = jsTypeStringFor@@ Value ( * vm , m_codeBlock -> globalObjectFor ( node -> codeOrigin ) , child ) ; if ( trySetConstant ( node , typeString ) ) { m_foundConstants = true ; break ; } } else if ( isNumberSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . numberString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecNumber ) ; m_foundConstants = true ; break ; } } else if ( isStringSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . stringString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecString ) ; m_foundConstants = true ; break ; } } else if ( isFinalObjectSpeculation ( abstractChild . m_type ) || isArraySpeculation ( abstractChild . m_type ) || isArgumentsSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . objectString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecFinalObject | SpecArray | SpecArguments ) ; m_foundConstants = true ; break ; } } else if ( isFunctionSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . functionString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecFunction ) ; m_foundConstants = true ; break ; } } else if ( isBooleanSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . booleanString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecBoolean ) ; m_foundConstants = true ; break ; } } switch ( node -> child1 ( ) . useKind ( ) ) { case StringUse : case CellUse : node -> setCanExit ( true ) ; break ; case UntypedUse : break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case CompareLess : case CompareLessEq : case CompareGreater : case CompareGreaterEq : case CompareEq : case CompareEqConstant : { bool constantWasSet = false ; JSValue leftConst = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue rightConst = forNode ( node -> child2 ( ) ) . value ( ) ; if ( leftConst && rightConst && leftConst . isNumber ( ) && rightConst . isNumber ( ) ) { double a = leftConst . asNumber ( ) ; double b = rightConst . asNumber ( ) ; switch ( node -> op ( ) ) { case CompareLess : constantWasSet = trySetConstant ( node , jsBoolean ( a < b ) ) ; break ; case CompareLessEq : constantWasSet = trySetConstant ( node , jsBoolean ( a <= b ) ) ; break ; case CompareGreater : constantWasSet = trySetConstant ( node , jsBoolean ( a > b ) ) ; break ; case CompareGreaterEq : constantWasSet = trySetConstant ( node , jsBoolean ( a >= b ) ) ; break ; case CompareEq : constantWasSet = trySetConstant ( node , jsBoolean ( a == b ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; break ; } } if ( ! constantWasSet && ( node -> op ( ) == CompareEqConstant || node -> op ( ) == CompareEq ) ) { SpeculatedType leftType = forNode ( node -> child1 ( ) ) . m_type ; SpeculatedType rightType = forNode ( node -> child2 ( ) ) . m_type ; if ( ( isInt32Speculation ( leftType ) && isOtherSpeculation ( rightType ) ) || ( isOtherSpeculation ( leftType ) && isInt32Speculation ( rightType ) ) ) constantWasSet = trySetConstant ( node , jsBoolean ( false ) ) ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecBoolean ) ; node -> setCanExit ( true ) ; break ; } case CompareStrictEq : case CompareStrictEqConstant : { Node * leftNode = node -> child1 ( ) . node ( ) ; Node * rightNode = node -> child2 ( ) . node ( ) ; JSValue left = forNode ( leftNode ) . value ( ) ; JSValue right = forNode ( rightNode ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , jsBoolean ( left . asNumber ( ) == right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecBoolean ) ; node -> setCanExit ( true ) ; break ; } case StringCharCodeAt : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecInt32 ) ; break ; case StringFrom@@ CharCode : forNode ( node ) . set ( SpecString ) ; break ; case StringCharAt : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; case GetByVal : { node -> setCanExit ( true ) ; switch ( node -> arrayMode ( ) . type ( ) ) { case Array :: SelectUsing@@ Predictions : case Array :: Unprofiled : case Array :: Undecided : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; case Array :: ForceExit : m_isValid = false ; break ; case Array :: Generic : clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case Array :: String : forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; case Array :: Arguments : forNode ( node ) . makeTop ( ) ; break ; case Array :: Int32 : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) { clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; } else forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Double : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) { clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; } else if ( node -> arrayMode ( ) . isSane@@ Chain ( ) ) forNode ( node ) . set ( SpecDouble ) ; else forNode ( node ) . set ( SpecDoubleReal ) ; break ; case Array :: Contiguous : case Array :: ArrayStorage : case Array :: SlowPutArrayStorage : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case Array :: Int8Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Int16Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Int32Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint8Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint8ClampedArray : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint16Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint32Array : if ( node -> shouldSpeculateInteger ( ) ) forNode ( node ) . set ( SpecInt32 ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; case Array :: Float32Array : forNode ( node ) . set ( SpecDouble ) ; break ; case Array :: Float64Array : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case PutByVal : case PutByV@@ alAlias : { node -> setCanExit ( true ) ; switch ( node -> arrayMode ( ) . modeForPut ( ) . type ( ) ) { case Array :: ForceExit : m_isValid = false ; break ; case Array :: Generic : clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Int32 : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Double : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Contiguous : case Array :: ArrayStorage : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: SlowPutArrayStorage : if ( node -> arrayMode ( ) . mayStoreToHo@@ le ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; default : break ; } break ; } case ArrayPush : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . set ( SpecNumber ) ; break ; case ArrayPop : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case RegExpExec : forNode ( node ) . makeTop ( ) ; break ; case RegExpTest : forNode ( node ) . set ( SpecBoolean ) ; break ; case Jump : break ; case Branch : { Node * child = node -> child1 ( ) . node ( ) ; BooleanResult result = booleanResult ( node , forNode ( child ) ) ; if ( result == DefinitelyTrue ) { m_branchDirection = TakeTrue ; break ; } if ( result == DefinitelyFalse ) { m_branchDirection = TakeFalse ; break ; } node -> setCanExit ( true ) ; m_branchDirection = TakeBoth ; break ; } case Return : m_isValid = false ; break ; case Throw : case ThrowReferenceError : m_isValid = false ; node -> setCanExit ( true ) ; break ; case ToPrimitive : { JSValue childConst = forNode ( node -> child1 ( ) ) . value ( ) ; if ( childConst && childConst . isNumber ( ) && trySetConstant ( node , childConst ) ) { m_foundConstants = true ; break ; } ASSERT ( node -> child1 ( ) . useKind ( ) == UntypedUse ) ; AbstractValue & source = forNode ( node -> child1 ( ) ) ; AbstractValue & destination = forNode ( node ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; SpeculatedType type = source . m_type ; if ( type & ~ ( SpecNumber | SpecString | SpecBoolean ) ) { type &= ( SpecNumber | SpecString | SpecBoolean ) ; type |= SpecString ; } destination . set ( type ) ; break ; } case ToString : { switch ( node -> child1 ( ) . useKind ( ) ) { case StringObjectUse : forNode ( node -> child1 ( ) ) . filter ( m_graph . globalObjectFor ( node -> codeOrigin ) -> stringObjectStructure ( ) ) ; node -> setCanExit ( true ) ; break ; case StringOr@@ StringObjectUse : node -> setCanExit ( true ) ; break ; case CellUse : case UntypedUse : clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case NewStringObject : { ASSERT ( node -> structure ( ) -> classInfo ( ) == & StringObject :: s_info ) ; forNode ( node ) . set ( node -> structure ( ) ) ; break ; } case NewArray : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> arrayStructureForIndexingTypeDuringAllocation ( node -> indexingType ( ) ) ) ; m_haveStructures = true ; break ; case NewArrayBuffer : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> arrayStructureForIndexingTypeDuringAllocation ( node -> indexingType ( ) ) ) ; m_haveStructures = true ; break ; case NewArrayWithSize : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecArray ) ; m_haveStructures = true ; break ; case NewRegexp : forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> regExpStructure ( ) ) ; m_haveStructures = true ; break ; case ConvertThis : { AbstractValue & source = forNode ( node -> child1 ( ) ) ; AbstractValue & destination = forNode ( node ) ; destination = source ; destination . merge ( SpecObjectOther ) ; break ; } case CreateThis : { forNode ( node ) . set ( SpecFinalObject ) ; break ; } case AllocationProfile@@ Watchpoint : node -> setCanExit ( true ) ; break ; case NewObject : forNode ( node ) . set ( node -> structure ( ) ) ; m_haveStructures = true ; break ; case CreateActivation : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> activationStructure ( ) ) ; m_haveStructures = true ; break ; case CreateArguments : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> argumentsStructure ( ) ) ; m_haveStructures = true ; break ; case TearOffActivation : case TearOffArguments : break ; case CheckArguments@@ NotCreated : if ( isEmptySpeculation ( m_variables . operand ( m_graph . argumentsRegisterFor ( node -> codeOrigin ) ) . m_type ) ) m_foundConstants = true ; else node -> setCanExit ( true ) ; break ; case GetMyArgumentsLength : if ( node -> codeOrigin . inlineCallFrame ) forNode ( node ) . set ( jsNumber ( node -> codeOrigin . inlineCallFrame -> arguments . size ( ) - 1 ) ) ; else forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( ! isEmptySpeculation ( m_variables . operand ( m_graph . argumentsRegisterFor ( node -> codeOrigin ) ) . m_type ) ) ; break ; case GetMyArgumentsLengthSafe : clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case GetMyArgumentByVal : node -> setCanExit ( true ) ; forNode ( node ) . makeTop ( ) ; break ; case GetMyArgumentByValSafe : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case NewFunction : { AbstractValue & value = forNode ( node ) ; value = forNode ( node -> child1 ( ) ) ; if ( ! ( value . m_type & SpecEmpty ) ) { m_foundConstants = true ; break ; } value . set ( ( value . m_type & ~ SpecEmpty ) | SpecFunction ) ; break ; } case NewFunctionExpression : case NewFunctionNoCheck : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> functionStructure ( ) ) ; break ; case GetCallee : forNode ( node ) . set ( SpecFunction ) ; break ; case SetCallee : case SetMyScope : break ; case GetScope : case GetMyScope : case SkipTop@@ Scope : forNode ( node ) . set ( SpecCellOther ) ; break ; case SkipScope : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && trySetConstant ( node , JSValue ( jsCast < JSScope * > ( child . asCell ( ) ) -> next ( ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecCellOther ) ; break ; } case GetScopeRegisters : forNode ( node ) . clear ( ) ; break ; case GetScopedVar : forNode ( node ) . makeTop ( ) ; break ; case PutScopedVar : clobberCapturedVars ( node -> codeOrigin ) ; break ; case GetById : case GetByIdFlush : node -> setCanExit ( true ) ; if ( ! node -> prediction ( ) ) { m_isValid = false ; break ; } if ( isCellSpeculation ( node -> child1 ( ) -> prediction ( ) ) ) { if ( Structure * structure = forNode ( node -> child1 ( ) ) . bestProvenStructure ( ) ) { GetByIdStatus status = GetByIdStatus :: computeFor ( m_graph . m_vm , structure , m_graph . m_codeBlock -> identifier ( node -> identifierNumber ( ) ) ) ; if ( status . isSimple ( ) ) { ASSERT ( status . structureSet ( ) . size ( ) == 1 ) ; ASSERT ( status . chain ( ) . isEmpty ( ) ) ; if ( status . specificValue ( ) ) forNode ( node ) . set ( status . specificValue ( ) ) ; else forNode ( node ) . makeTop ( ) ; forNode ( node -> child1 ( ) ) . filter ( status . structureSet ( ) ) ; m_foundConstants = true ; break ; } } } clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case GetArrayLength : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecInt32 ) ; break ; case CheckExecut@@ able : { node -> setCanExit ( true ) ; break ; } case CheckStructure : case ForwardCheckStructure : { AbstractValue & value = forNode ( node -> child1 ( ) ) ; ASSERT ( ! ( value . m_type & ~ SpecCell ) ) ; StructureSet & set = node -> structureSet ( ) ; if ( value . m_futurePossibleStructure . isSubsetOf ( set ) || value . m_currentKnownStructure . isSubsetOf ( set ) ) m_foundConstants = true ; if ( ! value . m_currentKnownStructure . isSubsetOf ( set ) ) node -> setCanExit ( true ) ; value . filter ( set ) ; m_haveStructures = true ; break ; } case StructureTransitionWatchpoint : case ForwardStructureTransitionWatchpoint : { AbstractValue & value = forNode ( node -> child1 ( ) ) ; ASSERT ( value . m_futurePossibleStructure . isSubsetOf ( StructureSet ( node -> structure ( ) ) ) ) ; value . filter ( node -> structure ( ) ) ; m_haveStructures = true ; node -> setCanExit ( true ) ; break ; } case PutStructure : case PhantomPutStructure : if ( ! forNode ( node -> child1 ( ) ) . m_currentKnownStructure . isClear ( ) ) { clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . set ( node -> structureTransitionData ( ) . newStructure ) ; m_haveStructures = true ; } break ; case GetButter@@ fly : case AllocatePropertyStorage : case ReallocatePropertyStorage : forNode ( node ) . clear ( ) ; break ; case CheckArray : { if ( node -> arrayMode ( ) . alreadyChecked ( m_graph , node , forNode ( node -> child1 ( ) ) ) ) { m_foundConstants = true ; break ; } node -> setCanExit ( true ) ; switch ( node -> arrayMode ( ) . type ( ) ) { case Array :: String : forNode ( node -> child1 ( ) ) . filter ( SpecString ) ; break ; case Array :: Int32 : case Array :: Double : case Array :: Contiguous : case Array :: ArrayStorage : case Array :: SlowPutArrayStorage : break ; case Array :: Arguments : forNode ( node -> child1 ( ) ) . filter ( SpecArguments ) ; break ; case Array :: Int8Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt8Array ) ; break ; case Array :: Int16Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt16Array ) ; break ; case Array :: Int32Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt32Array ) ; break ; case Array :: Uint8Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint8Array ) ; break ; case Array :: Uint8ClampedArray : forNode ( node -> child1 ( ) ) . filter ( SpecUint8ClampedArray ) ; break ; case Array :: Uint16Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint16Array ) ; break ; case Array :: Uint32Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint32Array ) ; break ; case Array :: Float32Array : forNode ( node -> child1 ( ) ) . filter ( SpecFloat32Array ) ; break ; case Array :: Float64Array : forNode ( node -> child1 ( ) ) . filter ( SpecFloat64Array ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node -> child1 ( ) ) . filterArrayModes ( node -> arrayMode ( ) . arrayModesThatPassFiltering ( ) ) ; m_haveStructures = true ; break ; } case Arrayify : { if ( node -> arrayMode ( ) . alreadyChecked ( m_graph , node , forNode ( node -> child1 ( ) ) ) ) { m_foundConstants = true ; break ; } ASSERT ( node -> arrayMode ( ) . conversion ( ) == Array :: Convert || node -> arrayMode ( ) . conversion ( ) == Array :: RageConvert ) ; node -> setCanExit ( true ) ; clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . filterArrayModes ( node -> arrayMode ( ) . arrayModesThatPassFiltering ( ) ) ; m_haveStructures = true ; break ; } case ArrayifyToStructure : { AbstractValue & value = forNode ( node -> child1 ( ) ) ; StructureSet set = node -> structure ( ) ; if ( value . m_futurePossibleStructure . isSubsetOf ( set ) || value . m_currentKnownStructure . isSubsetOf ( set ) ) m_foundConstants = true ; node -> setCanExit ( true ) ; clobberStructures ( indexInBlock ) ; value . filter ( set ) ; m_haveStructures = true ; break ; } case GetIndexedPropertyStorage : { forNode ( node ) . clear ( ) ; break ; } case GetByOffset : { forNode ( node ) . makeTop ( ) ; break ; } case PutByOffset : { break ; } case CheckFunction : { JSValue value = forNode ( node -> child1 ( ) ) . value ( ) ; if ( value == node -> function ( ) ) { m_foundConstants = true ; ASSERT ( value ) ; break ; } node -> setCanExit ( true ) ; forNode ( node -> child1 ( ) ) . filterByValue ( node -> function ( ) ) ; break ; } case PutById : case PutByIdDirect : node -> setCanExit ( true ) ; if ( Structure * structure = forNode ( node -> child1 ( ) ) . bestProvenStructure ( ) ) { PutByIdStatus status = PutByIdStatus :: computeFor ( m_graph . m_vm , m_graph . globalObjectFor ( node -> codeOrigin ) , structure , m_graph . m_codeBlock -> identifier ( node -> identifierNumber ( ) ) , node -> op ( ) == PutByIdDirect ) ; if ( status . isSimpleReplace ( ) ) { forNode ( node -> child1 ( ) ) . filter ( structure ) ; m_foundConstants = true ; break ; } if ( status . isSimpleTransition ( ) ) { clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . set ( status . newStructure ( ) ) ; m_haveStructures = true ; m_foundConstants = true ; break ; } } clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case GetGlobalVar : forNode ( node ) . makeTop ( ) ; break ; case GlobalVarWatchpoint : node -> setCanExit ( true ) ; break ; case PutGlobalVar : case PutGlobalVar@@ Check : break ; case CheckHasInstance : node -> setCanExit ( true ) ; break ; case InstanceOf : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecBoolean ) ; break ; case Phi : case Flush : case PhantomLocal : case Breakpoint : break ; case Call : case Construct : case Resolve : case ResolveBase : case ResolveBaseStrict@@ Put : case ResolveGlobal : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case GarbageValue : clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case ForceOSR@@ Exit : node -> setCanExit ( true ) ; m_isValid = false ; break ; case CheckWatch@@ dogTimer : node -> setCanExit ( true ) ; break ; case Phantom : case InlineStart : case Nop : case CountExecution : break ; case LastNodeType : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } return m_isValid ; }
bool AbstractState :: executeEffects ( unsigned indexInBlock ) { return executeEffects ( indexInBlock , m_block -> at ( indexInBlock ) ) ; }
bool AbstractState :: execute ( unsigned indexInBlock ) { Node * node = m_block -> at ( indexInBlock ) ; if ( ! startExecuting ( node ) ) return true ; executeEdges ( node ) ; return executeEffects ( indexInBlock , node ) ; }
inline void AbstractState :: clobberWorld ( const CodeOrigin & codeOrigin , unsigned indexInBlock ) { clobberCapturedVars ( codeOrigin ) ; clobberStructures ( indexInBlock ) ; }
inline void AbstractState :: clobberCapturedVars ( const CodeOrigin & codeOrigin ) { if ( codeOrigin . inlineCallFrame ) { const BitVector & capturedVars = codeOrigin . inlineCallFrame -> capturedVars ; for ( size_t i = capturedVars . size ( ) ; i -- ; ) { if ( ! capturedVars . quickGet ( i ) ) continue ; m_variables . local ( i ) . makeTop ( ) ; } } else { for ( size_t i = m_codeBlock -> m_numVars ; i -- ; ) { if ( m_codeBlock -> isCaptured ( i ) ) m_variables . local ( i ) . makeTop ( ) ; } } for ( size_t i = m_variables . numberOfArguments ( ) ; i -- ; ) { if ( m_codeBlock -> isCaptured ( argumentToOperand ( i ) ) ) m_variables . argument ( i ) . makeTop ( ) ; } }
inline void AbstractState :: clobberStructures ( unsigned indexInBlock ) { if ( ! m_haveStructures ) return ; for ( size_t i = indexInBlock + 1 ; i -- ; ) forNode ( m_block -> at ( i ) ) . clobberStructures ( ) ; for ( size_t i = m_variables . numberOfArguments ( ) ; i -- ; ) m_variables . argument ( i ) . clobberStructures ( ) ; for ( size_t i = m_variables . numberOfLocals ( ) ; i -- ; ) m_variables . local ( i ) . clobberStructures ( ) ; m_haveStructures = false ; m_didClobber = true ; }
inline bool AbstractState :: mergeStateAtTail ( AbstractValue & destination , AbstractValue & inVariable , Node * node ) { if ( ! node ) return false ; AbstractValue source ; if ( node -> variableAccessData ( ) -> isCaptured ( ) ) { source = inVariable ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Transfering ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " ▁ from ▁ last ▁ access ▁ due ▁ to ▁ captured ▁ variable . \n " ) ; } else { ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ It ' s ▁ live , ▁ node ▁ @ % u . \n " , node -> index ( ) ) ; switch ( node -> op ( ) ) { case Phi : case SetArgument : case PhantomLocal : case Flush : source = inVariable ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Transfering ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " ▁ from ▁ head ▁ to ▁ tail . \n " ) ; break ; case GetLocal : source = forNode ( node ) ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Refining ▁ to ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; break ; case SetLocal : if ( node -> variableAccessData ( ) -> shouldUseDoubleFormat ( ) ) { source . set ( SpecDouble ) ; } else source = forNode ( node -> child1 ( ) ) ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Setting ▁ to ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } } if ( destination == source ) { ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Not ▁ changed ! \n " ) ; return false ; } destination = source ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Changed ! \n " ) ; return true ; }
inline bool AbstractState :: merge ( BasicBlock * from , BasicBlock * to ) { ASSERT ( from -> variablesAtTail . numberOfArguments ( ) == to -> variablesAtHead . numberOfArguments ( ) ) ; ASSERT ( from -> variablesAtTail . numberOfLocals ( ) == to -> variablesAtHead . numberOfLocals ( ) ) ; bool changed = false ; for ( size_t argument = 0 ; argument < from -> variablesAtTail . numberOfArguments ( ) ; ++ argument ) { AbstractValue & destination = to -> valuesAtHead . argument ( argument ) ; changed |= mergeVariableBetweenBlocks ( destination , from -> valuesAtTail . argument ( argument ) , to -> variablesAtHead . argument ( argument ) , from -> variablesAtTail . argument ( argument ) ) ; } for ( size_t local = 0 ; local < from -> variablesAtTail . numberOfLocals ( ) ; ++ local ) { AbstractValue & destination = to -> valuesAtHead . local ( local ) ; changed |= mergeVariableBetweenBlocks ( destination , from -> valuesAtTail . local ( local ) , to -> variablesAtHead . local ( local ) , from -> variablesAtTail . local ( local ) ) ; } if ( ! to -> cfaHasVisited ) changed = true ; to -> cfaShouldRevisit |= changed ; return changed ; }
inline bool AbstractState :: mergeToSuccessors ( Graph & graph , BasicBlock * basicBlock ) { Node * terminal = basicBlock -> last ( ) ; ASSERT ( terminal -> isTerminal ( ) ) ; switch ( terminal -> op ( ) ) { case Jump : { ASSERT ( basicBlock -> cfaBranchDirection == InvalidBranchDirection ) ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> takenBlockIndex ( ) ) ; return merge ( basicBlock , graph . m_blocks [ terminal -> takenBlockIndex ( ) ] . get ( ) ) ; } case Branch : { ASSERT ( basicBlock -> cfaBranchDirection != InvalidBranchDirection ) ; bool changed = false ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> takenBlockIndex ( ) ) ; if ( basicBlock -> cfaBranchDirection != TakeFalse ) changed |= merge ( basicBlock , graph . m_blocks [ terminal -> takenBlockIndex ( ) ] . get ( ) ) ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> notTakenBlockIndex ( ) ) ; if ( basicBlock -> cfaBranchDirection != TakeTrue ) changed |= merge ( basicBlock , graph . m_blocks [ terminal -> notTakenBlockIndex ( ) ] . get ( ) ) ; return changed ; } case Return : case Throw : case ThrowReferenceError : ASSERT ( basicBlock -> cfaBranchDirection == InvalidBranchDirection ) ; return false ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; return false ; } }
inline bool AbstractState :: mergeVariableBetweenBlocks ( AbstractValue & destination , AbstractValue & source , Node * destinationNode , Node * sourceNode ) { if ( ! destinationNode ) return false ; ASSERT_UNUSED ( sourceNode , sourceNode ) ; return destination . merge ( source ) ; }
void AbstractState :: dump ( PrintStream & out ) { bool first = true ; for ( size_t i = 0 ; i < m_block -> size ( ) ; ++ i ) { Node * node = m_block -> at ( i ) ; AbstractValue & value = forNode ( node ) ; if ( value . isClear ( ) ) continue ; if ( first ) first = false ; else out . printf ( " ▁ " ) ; out . printf ( " @ % lu : " , static_cast < unsigned long > ( node -> index ( ) ) ) ; value . dump ( out ) ; } }
