TEST_CASE ( " Animating ▁ object ▁ with ▁ nullptr ▁ should ▁ not ▁ crash ▁ the ▁ app " , " [ animated ] " ) { Animated < int > x ( 10 ) ; x . animate ( nullptr ) ; }
PyObject * CppObj_iternext ( PyObject * self ) { Py_RETUR@@ N_NONE ; }
PyTypeObject * CppObj_type ( ) { static PyTypeObject t = { PyVar@@ Object_HEAD_@@ INIT ( NULL , 0 ) } ; t . tp_name = " cpp _ mod . CppObj " ; t . tp_basicsize = sizeof CppObj ; t . tp_flags = Py_TP@@ FLAGS_@@ DEFAULT ; t . tp_iternext = CppObj_iternext ; return & t ; }
void worker_thread ( ) { std :: unique_lock < std :: mutex > lk ( m ) ; cv . wait ( lk , [ ] { return ready ; } ) ; std :: cout << " Worker ▁ thread ▁ is ▁ processing ▁ data \n " ; data += " ▁ after ▁ processing " ; processed = true ; std :: cout << " Worker ▁ thread ▁ signals ▁ data ▁ processing ▁ completed \n " ; lk . unlock ( ) ; cv . notify_one ( ) ; }
int main ( int argc , char * argv [ ] ) { std :: thread worker ( worker_thread ) ; data = " Example ▁ data " ; { std :: lock_guard < std :: mutex > lk ( m ) ; ready = true ; std :: cout << " main ( ) ▁ signals ▁ data ▁ ready ▁ for ▁ processing \n " ; } cv . notify_one ( ) ; { std :: unique_lock < std :: mutex > lk ( m ) ; cv . wait ( lk , [ ] { return processed ; } ) ; } std :: cout << " Back ▁ in ▁ main ( ) , ▁ data ▁ = ▁ " << data << ' \n ' ; worker . join ( ) ; }
int main ( int argc , char * * argv ) { TBool debug = false ; TStr TagsFnm = " / lfs / madmax4/0 / yonathan / tags " ; if ( debug ) { TagsFnm = " / lfs / madmax4/0 / yonathan / tags _ small " ; } Schema TagS ; TagS . Add ( TPair < TStr , TAttrType > ( " UserId " , atInt ) ) ; TagS . Add ( TPair < TStr , TAttrType > ( " Tag " , atStr ) ) ; float ft_max ; float mu_max ; timeval timer4 ; gettimeofday ( & timer4 , NULL ) ; double t1 = timer4 . tv_sec + ( timer4 . tv_usec / 1000000.0 ) ; PExplicitStringTable ES_Tags = ExplicitStringTable :: LoadSS ( TagS , TagsFnm + " . tsv " ) ; gettimeofday ( & timer4 , NULL ) ; double t2 = timer4 . tv_sec + ( timer4 . tv_usec / 1000000.0 ) ; printf ( " Time ▁ to ▁ load ▁ tags ▁ table : ▁ % f \n " , t2 - t1 ) ; printf ( " Table ▁ Size : \n " ) ; ES_Tags -> PrintSize ( ) ; getmaxcpumem ( & ft_max , & mu_max ) ; printf ( " time : ▁ % 0.3f ▁ seconds , ▁ memory : ▁ % 0.3f ▁ MB \n " , ft_max , mu_max ) ; printf ( " \n " ) ; timeval timer6 ; gettimeofday ( & timer6 , NULL ) ; t1 = timer6 . tv_sec + ( timer6 . tv_usec / 1000000.0 ) ; PExplicitStringTable ES_TagsJoinUser = ES_Tags -> SelfJoin ( " UserId " ) ; gettimeofday ( & timer6 , NULL ) ; t2 = timer6 . tv_sec + ( timer6 . tv_usec / 1000000.0 ) ; printf ( " Time ▁ to ▁ join ▁ on ▁ user ▁ id ▁ column : ▁ % f \n " , t2 - t1 ) ; printf ( " Table ▁ Size : \n " ) ; ES_TagsJoinUser -> PrintSize ( ) ; if ( debug ) { ES_TagsJoinUser -> SaveSS ( TagsFnm + " _ join _ user _ es . tsv " ) ; } getmaxcpumem ( & ft_max , & mu_max ) ; printf ( " time : ▁ % 0.3f ▁ seconds , ▁ memory : ▁ % 0.3f ▁ MB \n " , ft_max , mu_max ) ; printf ( " \n " ) ; timeval timer7 ; gettimeofday ( & timer7 , NULL ) ; t1 = timer7 . tv_sec + ( timer7 . tv_usec / 1000000.0 ) ; PExplicitStringTable ES_JavaTags = ExplicitStringTable :: New ( TagS ) ; TIntV SelectedRows1 ; if ( debug ) { ES_Tags -> SelectAtomicConst ( TStr ( " Tag " ) , TStr ( " c # " ) , EQ , SelectedRows1 , ES_JavaTags , false , true ) ; } else { ES_Tags -> SelectAtomicConst ( TStr ( " Tag " ) , TStr ( " java " ) , EQ , SelectedRows1 , ES_JavaTags , false , true ) ; } gettimeofday ( & timer7 , NULL ) ; t2 = timer7 . tv_sec + ( timer7 . tv_usec / 1000000.0 ) ; printf ( " Time ▁ to ▁ select ▁ java ▁ users : ▁ % f \n " , t2 - t1 ) ; printf ( " Table ▁ Size : \n " ) ; ES_JavaTags -> PrintSize ( ) ; if ( debug ) { ES_JavaTags -> SaveSS ( TagsFnm + " _ select _ es . tsv " ) ; } getmaxcpumem ( & ft_max , & mu_max ) ; printf ( " time : ▁ % 0.3f ▁ seconds , ▁ memory : ▁ % 0.3f ▁ MB \n " , ft_max , mu_max ) ; printf ( " \n " ) ; return 0 ; }
private : virtual NPError NPP_New ( NPMIME@@ Type pluginType , uint16_t mode , int16_t argc , char * argn [ ] , char * argv [ ] , NPSavedData * saved ) { NPN_GetURL ( " javascript : removePlugin ( ) " , 0 ) ; return NPERR_NO_ERROR ; }
template < class S > void test ( S s , const typename S :: value_type * str , S expected ) { s . append ( str ) ; assert ( s . __invariants ( ) ) ; assert ( s == expected ) ; }
int main ( ) { typedef std :: string S ; test ( S ( ) , " " , S ( ) ) ; test ( S ( ) , "12345" , S ( "12345" ) ) ; test ( S ( ) , "12345678901234567890" , S ( "12345678901234567890" ) ) ; test ( S ( "12345" ) , " " , S ( "12345" ) ) ; test ( S ( "12345" ) , "12345" , S ( "1234512345" ) ) ; test ( S ( "12345" ) , "1234567890" , S ( "123451234567890" ) ) ; test ( S ( "12345678901234567890" ) , " " , S ( "12345678901234567890" ) ) ; test ( S ( "12345678901234567890" ) , "12345" , S ( "1234567890123456789012345" ) ) ; test ( S ( "12345678901234567890" ) , "12345678901234567890" , S ( "1234567890123456789012345678901234567890" ) ) ; }
void mexFunction ( int nlhs , mxArray * plhs [ ] , int nrhs , const mxArray * prhs [ ] ) { nargchk ( nrhs >= 1 && ( nrhs % 2 ) == 1 && nlhs <= 1 ) ; vector < MxArray > rhs ( prhs , prhs + nrhs ) ; int blockSize = 5 ; int ksize = 3 ; double k = 0.04 ; int borderType = cv :: BORDER_@@ DEFAULT ; for ( int i = 1 ; i < nrhs ; i += 2 ) { string key ( rhs [ i ] . toString ( ) ) ; if ( key == " BlockSize " ) blockSize = rhs [ i + 1 ] . toInt ( ) ; else if ( key == " KSize " ) ksize = rhs [ i + 1 ] . toInt ( ) ; else if ( key == " K " ) k = rhs [ i + 1 ] . toDouble ( ) ; else if ( key == " BorderType " ) borderType = BorderType [ rhs [ i + 1 ] . toString ( ) ] ; else mexErrMsg@@ IdAnd@@ Txt ( " mexopencv : error " , " Unrecognized ▁ option " ) ; } Mat src ( rhs [ 0 ] . toMat ( rhs [ 0 ] . isUint8 ( ) ? CV_8U : CV_32F ) ) , dst ; cornerHarris ( src , dst , blockSize , ksize , k , borderType ) ; plhs [ 0 ] = MxArray ( dst ) ; }
I8275_DRAW_@@ CHARACTER_MEMBER ( mm1_state :: crtc_display_pixels ) { UINT8 romdata = m_char_rom -> base ( ) [ ( charcode << 4 ) | linecount ] ; int gpa0 = BIT ( gpa , 0 ) ; int llen = m_llen ; int compl_in = rvv ; int hlt_in = hlgt ; int color ; int i , qh , video_in ; int d7 = BIT ( romdata , 7 ) ; int d6 = BIT ( romdata , 6 ) ; int d0 = BIT ( romdata , 0 ) ; UINT8 data = ( romdata << 1 ) | ( d7 & d0 ) ; if ( y < 360 || x >= HORIZONTAL_CHARACTER_PIXELS || compl_in == 0 ) { if ( HORIZONTAL_CHARACTER_PIXELS == 10 ) { qh = d7 & d6 ; video_in = ( ( ( ( d7 & llen ) | ( vsp ? 0 : 1 ) ) & ( gpa0 ? 0 : 1 ) ) & qh ) | lten ; color = ( hlt_in ? 1 : 2 ) * ( video_in ^ compl_in ) ; bitmap . pix32 ( y , x + 8 ) = m_palette -> pen ( color ) ; bitmap . pix32 ( y , x + 9 ) = m_palette -> pen ( color ) ; } for ( i = 0 ; i < 8 ; ++ i ) { qh = BIT ( data , i ) ; video_in = ( ( ( ( d7 & llen ) | ( vsp ? 0 : 1 ) ) & ( gpa0 ? 0 : 1 ) ) & qh ) | lten ; color = ( hlt_in ? 1 : 2 ) * ( video_in ^ compl_in ) ; bitmap . pix32 ( y , x + i ) = m_palette -> pen ( color ) ; } } }
static ADDRESS_MAP_START ( mm1_upd7220_map , AS_0 , 16 , mm1_state ) ADDRESS_MAP_GLOBAL_MASK ( 0x7fff ) AM_RANGE ( 0x0000 , 0x7fff ) AM_RAM AM_SHAR@@ E ( " video _ ram " ) ADDRESS_MAP_END UPD7220_DISPLAY_PIXELS_MEMBER ( mm1_state :: hgdc_display_pixels ) { UINT16 data = m_video_ram [ address >> 1 ] ; for ( int i = 0 ; i < 16 ; i ++ ) { if ( BIT ( data , i ) ) bitmap . pix32 ( y , x + i ) = m_palette -> pen ( 2 ) ; } }
static GFXDECODE_START ( mm1 ) GFXDECODE_ENTRY ( " chargen " , 0 , charlayout , 0 , 1 ) GFXDECODE_END PALETTE_INIT_MEMBER ( mm1_state , mm1 ) { palette . set_pen_color ( 0 , rgb_t ( 0x00 , 0x00 , 0x00 ) ) ; palette . set_pen_color ( 1 , rgb_t ( 0x00 , 0x7F , 0x0A ) ) ; palette . set_pen_color ( 2 , rgb_t ( 0x08 , 0xD0 , 0x1A ) ) ; }
int ctkExampleUseOfWorkflowWidgetUsingSignalsAndSlots ( int argc , char * argv [ ] ) { QApplication app ( argc , argv ) ; bool hideWidgets = false ; ctkWorkflow * workflow = new ctkWorkflow ; ctkWorkflowTabWidget * workflowWidget = new ctkWorkflowTabWidget ; workflowWidget -> setWorkflow ( workflow ) ; ctkWorkflowGroupBox * groupBox = workflowWidget -> workflowGroupBox ( ) ; groupBox -> setPreText ( " I ▁ am ▁ some ▁ pre - text " ) ; groupBox -> setPostText ( " I ▁ am ▁ some ▁ post - text " ) ; groupBox -> setHideWidgetsOf@@ NonCurrentSteps ( hideWidgets ) ; ctkWorkflowWidgetStep * testStep1 = new ctkWorkflowWidgetStep ( " Step ▁ 1" ) ; testStep1 -> setName ( " Step ▁ 1" ) ; testStep1 -> setDescription ( " I ▁ am ▁ in ▁ step ▁ 1" ) ; workflowWidget -> associateStepWithLabel ( testStep1 , " name ▁ 1" ) ; ctkWorkflowWidgetStep * testStep2 = new ctkWorkflowWidgetStep ( " Step ▁ 2" ) ; testStep2 -> setName ( " Step ▁ 2" ) ; testStep2 -> setDescription ( " I ▁ am ▁ in ▁ step ▁ 2" ) ; workflowWidget -> associateStepWithLabel ( testStep2 , " name ▁ 2" ) ; ctkWorkflowWidgetStep * testStep3 = new ctkWorkflowWidgetStep ( " Step ▁ 3" ) ; testStep3 -> setName ( " Step ▁ 3" ) ; testStep3 -> setDescription ( " I ▁ am ▁ in ▁ step ▁ 3" ) ; workflowWidget -> associateStepWithPage ( testStep3 , 1 , " name ▁ 3" ) ; workflow -> addTransition ( testStep1 , testStep2 ) ; workflow -> addTransition ( testStep2 , testStep3 ) ; ctkExampleWorkflowWidgetStepUsingSignalsAndSlots * qObject1 = new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots ( testStep1 ) ; ctkExampleWorkflowWidgetStepUsingSignalsAndSlots * qObject2 = new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots ( testStep2 ) ; ctkExampleWorkflowWidgetStepUsingSignalsAndSlots * qObject3 = new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots ( testStep3 ) ; qObject1 -> setWidget ( testStep1 -> stepArea ( ) ) ; qObject2 -> setWidget ( testStep2 -> stepArea ( ) ) ; qObject3 -> setWidget ( testStep3 -> stepArea ( ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeValidateCommand ( QString ) ) , qObject1 , SLOT ( validate ( QString ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeValidateCommand ( QString ) ) , qObject2 , SLOT ( validate ( QString ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeValidateCommand ( QString ) ) , qObject3 , SLOT ( validate ( QString ) ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnEntryCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject1 , SLOT ( onEntry ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnEntryCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject2 , SLOT ( onEntry ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnEntryCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject3 , SLOT ( onEntry ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnExitCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject1 , SLOT ( onExit ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnExitCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject2 , SLOT ( onExit ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnExitCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject3 , SLOT ( onExit ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeCreateUserInterfaceCommand ( ) ) , qObject1 , SLOT ( createUserInterface ( ) ) ) ; QObject :: connect ( qObject1 , SIGNAL ( createUserInterfaceComplete ( ) ) , testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( showUserInterfaceComplete ( ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeCreateUserInterfaceCommand ( ) ) , qObject2 , SLOT ( createUserInterface ( ) ) ) ; QObject :: connect ( qObject2 , SIGNAL ( createUserInterfaceComplete ( ) ) , testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( showUserInterfaceComplete ( ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeCreateUserInterfaceCommand ( ) ) , qObject3 , SLOT ( createUserInterface ( ) ) ) ; QObject :: connect ( qObject3 , SIGNAL ( createUserInterfaceComplete ( ) ) , testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( showUserInterfaceComplete ( ) ) ) ; testStep1 -> setHasValidateCommand ( 1 ) ; testStep1 -> setHasOnEntryCommand ( 1 ) ; testStep1 -> setHasOnExitCommand ( 1 ) ; testStep1 -> setHasCreateUserInterfaceCommand ( 1 ) ; testStep2 -> setHasValidateCommand ( 1 ) ; testStep2 -> setHasOnEntryCommand ( 1 ) ; testStep2 -> setHasOnExitCommand ( 1 ) ; testStep2 -> setHasCreateUserInterfaceCommand ( 1 ) ; testStep3 -> setHasValidateCommand ( 1 ) ; testStep3 -> setHasOnEntryCommand ( 1 ) ; testStep3 -> setHasOnExitCommand ( 1 ) ; testStep3 -> setHasCreateUserInterfaceCommand ( 1 ) ; workflow -> setInitialStep ( testStep1 ) ; workflow -> start ( ) ; workflowWidget -> show ( ) ; QTimer :: singleShot ( 500 , & app , SLOT ( quit ( ) ) ) ; app . exec ( ) ; workflow -> stop ( ) ; QTimer :: singleShot ( 100 , & app , SLOT ( quit ( ) ) ) ; app . exec ( ) ; delete workflowWidget ; return EXIT_SUCCESS ; }
static bool copyData ( QIODevice & inFile , QIODevice & outFile ) { while ( ! inFile . atEnd ( ) ) { char buf [ 4096 ] ; qint64 readLen = inFile . read ( buf , 4096 ) ; if ( readLen <= 0 ) return false ; if ( outFile . write ( buf , readLen ) != readLen ) return false ; } return true ; }
IntVal ( int val , Poco :: Timestamp :: TimeDiff v ) : value ( val ) , validUntil ( ) { validUntil += ( v * 1000 ) ; }
static void lengthAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; v8SetReturnValueUnsigned ( info , impl -> length ( ) ) ; }
static void lengthAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: lengthAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; }
static void selectedIndexAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; v8SetReturnValueInt ( info , impl -> selectedIndex ( ) ) ; }
static void selectedIndexAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: selectedIndexAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; }
static void onchangeAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; EventListener * cppValue ( impl -> onchange ( ) ) ; v8SetReturnValue ( info , cppValue ? v8 :: Local < v8 :: Value > ( V8AbstractEventListener :: cast ( cppValue ) -> getListenerObject ( impl -> executionContext ( ) ) ) : v8 :: Local < v8 :: Value > ( v8 :: Null ( info . GetIsolate ( ) ) ) ) ; }
static void onchangeAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: onchangeAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; }
static void onchangeAttributeSetter ( v8 :: Local < v8 :: Value > v8Value , const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; moveEventListenerToNewWrapper ( info . GetIsolate ( ) , holder , impl -> onchange ( ) , v8Value , V8VideoTrackList :: eventListenerCacheIndex ) ; impl -> setOnchange ( V8EventListenerList :: getEventListener ( ScriptState :: current ( info . GetIsolate ( ) ) , v8Value , true , ListenerFindOrCreate ) ) ; }
static void onchangeAttributeSetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Value > v8Value = info [ 0 ] ; TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMSetter " ) ; VideoTrackListV8Internal :: onchangeAttributeSetter ( v8Value , info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; }
static void onaddtrackAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; EventListener * cppValue ( impl -> onaddtrack ( ) ) ; v8SetReturnValue ( info , cppValue ? v8 :: Local < v8 :: Value > ( V8AbstractEventListener :: cast ( cppValue ) -> getListenerObject ( impl -> executionContext ( ) ) ) : v8 :: Local < v8 :: Value > ( v8 :: Null ( info . GetIsolate ( ) ) ) ) ; }
static void onaddtrackAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: onaddtrackAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; }
static void onaddtrackAttributeSetter ( v8 :: Local < v8 :: Value > v8Value , const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; moveEventListenerToNewWrapper ( info . GetIsolate ( ) , holder , impl -> onaddtrack ( ) , v8Value , V8VideoTrackList :: eventListenerCacheIndex ) ; impl -> setOnaddtrack ( V8EventListenerList :: getEventListener ( ScriptState :: current ( info . GetIsolate ( ) ) , v8Value , true , ListenerFindOrCreate ) ) ; }
static void onaddtrackAttributeSetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Value > v8Value = info [ 0 ] ; TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMSetter " ) ; VideoTrackListV8Internal :: onaddtrackAttributeSetter ( v8Value , info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; }
static void onremovetrackAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; EventListener * cppValue ( impl -> onremovetrack ( ) ) ; v8SetReturnValue ( info , cppValue ? v8 :: Local < v8 :: Value > ( V8AbstractEventListener :: cast ( cppValue ) -> getListenerObject ( impl -> executionContext ( ) ) ) : v8 :: Local < v8 :: Value > ( v8 :: Null ( info . GetIsolate ( ) ) ) ) ; }
static void onremovetrackAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: onremovetrackAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; }
static void onremovetrackAttributeSetter ( v8 :: Local < v8 :: Value > v8Value , const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; moveEventListenerToNewWrapper ( info . GetIsolate ( ) , holder , impl -> onremovetrack ( ) , v8Value , V8VideoTrackList :: eventListenerCacheIndex ) ; impl -> setOnremovetrack ( V8EventListenerList :: getEventListener ( ScriptState :: current ( info . GetIsolate ( ) ) , v8Value , true , ListenerFindOrCreate ) ) ; }
static void onremovetrackAttributeSetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Value > v8Value = info [ 0 ] ; TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMSetter " ) ; VideoTrackListV8Internal :: onremovetrackAttributeSetter ( v8Value , info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; }
static void getTrackByIdMethod ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { if ( UNLI@@ KELY ( info . Length ( ) < 1 ) ) { V8Throw@@ Exception :: throwException ( createMin@@ imumArity@@ TypeError@@ ForMethod ( info . GetIsolate ( ) , " getTrackById " , " VideoTrackList " , 1 , info . Length ( ) ) , info . GetIsolate ( ) ) ; return ; } VideoTrackList * impl = V8VideoTrackList :: toImpl ( info . Holder ( ) ) ; V8StringResource < > id ; { id = info [ 0 ] ; if ( ! id . prepare ( ) ) return ; } v8SetReturnValue ( info , impl -> getTrackById ( id ) ) ; }
static void getTrackByIdMethodCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMMethod " ) ; VideoTrackListV8Internal :: getTrackByIdMethod ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; }
static void indexedPropertyGetter ( uint32_t index , const v8 :: PropertyCallbackInfo < v8 :: Value > & info ) { VideoTrackList * impl = V8VideoTrackList :: toImpl ( info . Holder ( ) ) ; RefPtrWillBeRawPtr < VideoTrack > result = impl -> anonymousIndexedGetter ( index ) ; if ( ! result ) return ; v8SetReturnValueFast ( info , WTF :: getPtr ( result . release ( ) ) , impl ) ; }
static void indexedPropertyGetterCallback ( uint32_t index , const v8 :: PropertyCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMIndexed@@ Property " ) ; VideoTrackListV8Internal :: indexedPropertyGetter ( index , info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; }
static void installV8VideoTrackListTemplate ( v8 :: Local < v8 :: FunctionTemplate > functionTemplate , v8 :: Isolate * isolate ) { functionTemplate -> ReadOnly@@ Prototype ( ) ; v8 :: Local < v8 :: Signature > defaultSignature ; if ( ! RuntimeEnabledFeatures :: audioVideoTracksEnabled ( ) ) defaultSignature = V8DOMConfiguration :: installDOMClassTemplate ( isolate , functionTemplate , " VideoTrackList " , V8EventTarget :: domTemplate ( isolate ) , V8VideoTrackList :: internalFieldCount , 0 , 0 , 0 , 0 , 0 , 0 ) ; else defaultSignature = V8DOMConfiguration :: installDOMClassTemplate ( isolate , functionTemplate , " VideoTrackList " , V8EventTarget :: domTemplate ( isolate ) , V8VideoTrackList :: internalFieldCount , 0 , 0 , V8VideoTrackListAccessors , WTF_ARRAY_LENGTH ( V8VideoTrackListAccessors ) , V8VideoTrackListMethods , WTF_ARRAY_LENGTH ( V8VideoTrackListMethods ) ) ; v8 :: Local < v8 :: ObjectTemplate > instanceTemplate = functionTemplate -> InstanceTemplate ( ) ; ALLOW_UNUSED_LOCAL ( instanceTemplate ) ; v8 :: Local < v8 :: ObjectTemplate > prototypeTemplate = functionTemplate -> PrototypeTemplate ( ) ; ALLOW_UNUSED_LOCAL ( prototypeTemplate ) ; { v8 :: IndexedPropertyHandler@@ Configuration config ( VideoTrackListV8Internal :: indexedPropertyGetterCallback , 0 , 0 , 0 , indexedPropertyEnumerator < VideoTrackList > ) ; functionTemplate -> InstanceTemplate ( ) -> SetHandler ( config ) ; } functionTemplate -> Set ( v8AtomicString ( isolate , " toString " ) , V8PerIsolateData :: from ( isolate ) -> toStringTemplate ( ) ) ; }
clipHandle_t SV_ClipHandleForEntity ( const sharedEntity_t * ent ) { if ( ent -> r . bmodel ) { return CM_InlineModel ( ent -> s . modelindex ) ; } if ( ent -> r . svFlags & SVF_CAP@@ SULE ) { return CM_TempBoxModel ( ent -> r . mins , ent -> r . maxs , qtrue ) ; } return CM_TempBoxModel ( ent -> r . mins , ent -> r . maxs , qfalse ) ; }
void SV_Sector@@ List_f ( void ) { int i , c ; worldSector_t * sec ; svEntity_t * ent ; for ( i = 0 ; i < AREA_NODES ; i ++ ) { sec = & sv_worldSectors [ i ] ; c = 0 ; for ( ent = sec -> entities ; ent ; ent = ent -> nextEntityInWorldSector ) { c ++ ; } Com_Printf ( " sector ▁ % i : ▁ % i ▁ entities \n " , i , c ) ; } }
worldSector_t * SV_CreateworldSector ( int depth , vec3_t mins , vec3_t maxs ) { worldSector_t * anode ; vec3_t size ; vec3_t mins1 , maxs1 , mins2 , maxs2 ; anode = & sv_worldSectors [ sv_numworldSectors ] ; sv_numworldSectors ++ ; if ( depth == AREA_DEPTH ) { anode -> axis = - 1 ; anode -> children [ 0 ] = anode -> children [ 1 ] = NULL ; return anode ; } VectorSubtract ( maxs , mins , size ) ; if ( size [ 0 ] > size [ 1 ] ) { anode -> axis = 0 ; } else { anode -> axis = 1 ; } anode -> dist = 0.5 * ( maxs [ anode -> axis ] + mins [ anode -> axis ] ) ; VectorCopy ( mins , mins1 ) ; VectorCopy ( mins , mins2 ) ; VectorCopy ( maxs , maxs1 ) ; VectorCopy ( maxs , maxs2 ) ; maxs1 [ anode -> axis ] = mins2 [ anode -> axis ] = anode -> dist ; anode -> children [ 0 ] = SV_CreateworldSector ( depth + 1 , mins2 , maxs2 ) ; anode -> children [ 1 ] = SV_CreateworldSector ( depth + 1 , mins1 , maxs1 ) ; return anode ; }
void SV_Clear@@ World ( void ) { clipHandle_t h ; vec3_t mins , maxs ; Com_Memset ( sv_worldSectors , 0 , sizeof ( sv_worldSectors ) ) ; sv_numworldSectors = 0 ; h = CM_InlineModel ( 0 ) ; CM_ModelBounds ( h , mins , maxs ) ; SV_CreateworldSector ( 0 , mins , maxs ) ; }
void SV_UnlinkEntity ( sharedEntity_t * gEnt ) { svEntity_t * ent ; svEntity_t * scan ; worldSector_t * ws ; ent = SV_SvEntityForGentity ( gEnt ) ; gEnt -> r . linked = qfalse ; ws = ent -> worldSector ; if ( ! ws ) { return ; } ent -> worldSector = NULL ; if ( ws -> entities == ent ) { ws -> entities = ent -> nextEntityInWorldSector ; return ; } for ( scan = ws -> entities ; scan ; scan = scan -> nextEntityInWorldSector ) { if ( scan -> nextEntityInWorldSector == ent ) { scan -> nextEntityInWorldSector = ent -> nextEntityInWorldSector ; return ; } } Com_Printf ( " WARNING : ▁ SV _ UnlinkEntity : ▁ not ▁ found ▁ in ▁ worldSector \n " ) ; }
void SV_LinkEntity ( sharedEntity_t * gEnt ) { worldSector_t * node ; int leafs [ MAX_TOTAL_ENT_LEAFS ] ; int cluster ; int num_leafs ; int i , j , k ; int area ; int lastLeaf ; float * origin , * angles ; svEntity_t * ent ; ent = SV_SvEntityForGentity ( gEnt ) ; if ( ent -> worldSector ) { SV_UnlinkEntity ( gEnt ) ; } if ( gEnt -> r . bmodel ) { gEnt -> s . solid = SOLID_BMODE@@ L ; } else if ( gEnt -> r . contents & ( CONTENTS_SOLID | CONTENTS_BODY ) ) { i = gEnt -> r . maxs [ 0 ] ; if ( i < 1 ) i = 1 ; if ( i > 255 ) i = 255 ; j = ( - gEnt -> r . mins [ 2 ] ) ; if ( j < 1 ) j = 1 ; if ( j > 255 ) j = 255 ; k = ( gEnt -> r . maxs [ 2 ] + 32 ) ; if ( k < 1 ) k = 1 ; if ( k > 255 ) k = 255 ; gEnt -> s . solid = ( k << 16 ) | ( j << 8 ) | i ; } else { gEnt -> s . solid = 0 ; } origin = gEnt -> r . currentOrigin ; angles = gEnt -> r . currentAngles ; if ( gEnt -> r . bmodel && ( angles [ 0 ] || angles [ 1 ] || angles [ 2 ] ) ) { float max ; int i ; max = RadiusFrom@@ Bounds ( gEnt -> r . mins , gEnt -> r . maxs ) ; for ( i = 0 ; i < 3 ; i ++ ) { gEnt -> r . absmin [ i ] = origin [ i ] - max ; gEnt -> r . absmax [ i ] = origin [ i ] + max ; } } else { VectorAdd ( origin , gEnt -> r . mins , gEnt -> r . absmin ) ; VectorAdd ( origin , gEnt -> r . maxs , gEnt -> r . absmax ) ; } gEnt -> r . absmin [ 0 ] -= 1 ; gEnt -> r . absmin [ 1 ] -= 1 ; gEnt -> r . absmin [ 2 ] -= 1 ; gEnt -> r . absmax [ 0 ] += 1 ; gEnt -> r . absmax [ 1 ] += 1 ; gEnt -> r . absmax [ 2 ] += 1 ; ent -> numClusters = 0 ; ent -> lastCluster = 0 ; ent -> areanum = - 1 ; ent -> areanum2 = - 1 ; num_leafs = CM_BoxLeaf@@ nums ( gEnt -> r . absmin , gEnt -> r . absmax , leafs , MAX_TOTAL_ENT_LEAFS , & lastLeaf ) ; if ( ! num_leafs ) { return ; } for ( i = 0 ; i < num_leafs ; i ++ ) { area = CM_LeafArea ( leafs [ i ] ) ; if ( area != - 1 ) { if ( ent -> areanum != - 1 && ent -> areanum != area ) { if ( ent -> areanum2 != - 1 && ent -> areanum2 != area && sv . state == SS_LOADING ) { Com_DPrintf ( " Object ▁ % i ▁ touching ▁ 3 ▁ areas ▁ at ▁ % f ▁ % f ▁ % f \n " , gEnt -> s . number , gEnt -> r . absmin [ 0 ] , gEnt -> r . absmin [ 1 ] , gEnt -> r . absmin [ 2 ] ) ; } ent -> areanum2 = area ; } else { ent -> areanum = area ; } } } ent -> numClusters = 0 ; for ( i = 0 ; i < num_leafs ; i ++ ) { cluster = CM_LeafCluster ( leafs [ i ] ) ; if ( cluster != - 1 ) { ent -> clusternums [ ent -> numClusters ++ ] = cluster ; if ( ent -> numClusters == MAX_ENT_CLU@@ STERS ) { break ; } } } if ( i != num_leafs ) { ent -> lastCluster = CM_LeafCluster ( lastLeaf ) ; } gEnt -> r . linkcount ++ ; node = sv_worldSectors ; while ( 1 ) { if ( node -> axis == - 1 ) break ; if ( gEnt -> r . absmin [ node -> axis ] > node -> dist ) node = node -> children [ 0 ] ; else if ( gEnt -> r . absmax [ node -> axis ] < node -> dist ) node = node -> children [ 1 ] ; else break ; } ent -> worldSector = node ; ent -> nextEntityInWorldSector = node -> entities ; node -> entities = ent ; gEnt -> r . linked = qtrue ; }
void SV_AreaEntities_r ( worldSector_t * node , areaParms_t * ap ) { svEntity_t * check , * next ; sharedEntity_t * gcheck ; int count ; count = 0 ; for ( check = node -> entities ; check ; check = next ) { next = check -> nextEntityInWorldSector ; gcheck = SV_GEntityFor@@ SvEntity ( check ) ; if ( gcheck -> r . absmin [ 0 ] > ap -> maxs [ 0 ] || gcheck -> r . absmin [ 1 ] > ap -> maxs [ 1 ] || gcheck -> r . absmin [ 2 ] > ap -> maxs [ 2 ] || gcheck -> r . absmax [ 0 ] < ap -> mins [ 0 ] || gcheck -> r . absmax [ 1 ] < ap -> mins [ 1 ] || gcheck -> r . absmax [ 2 ] < ap -> mins [ 2 ] ) { continue ; } if ( ap -> count == ap -> maxcount ) { Com_Printf ( " SV _ AreaEntities : ▁ MAXCOUNT \n " ) ; return ; } ap -> list [ ap -> count ] = check - sv . svEntities ; ap -> count ++ ; } if ( node -> axis == - 1 ) { return ; } if ( ap -> maxs [ node -> axis ] > node -> dist ) { SV_AreaEntities_r ( node -> children [ 0 ] , ap ) ; } if ( ap -> mins [ node -> axis ] < node -> dist ) { SV_AreaEntities_r ( node -> children [ 1 ] , ap ) ; } }
int SV_AreaEntities ( const vec3_t mins , const vec3_t maxs , int * entityList , int maxcount ) { areaParms_t ap ; ap . mins = mins ; ap . maxs = maxs ; ap . list = entityList ; ap . count = 0 ; ap . maxcount = maxcount ; SV_AreaEntities_r ( sv_worldSectors , & ap ) ; return ap . count ; }
void SV_ClipToEntity ( trace_t * trace , const vec3_t start , const vec3_t mins , const vec3_t maxs , const vec3_t end , int entityNum , int contentmask , int capsule ) { sharedEntity_t * touch ; clipHandle_t clipHandle ; float * origin , * angles ; touch = SV_GentityNum ( entityNum ) ; Com_Memset ( trace , 0 , sizeof ( trace_t ) ) ; if ( ! ( contentmask & touch -> r . contents ) ) { trace -> fraction = 1.0 ; return ; } clipHandle = SV_ClipHandleForEntity ( touch ) ; origin = touch -> r . currentOrigin ; angles = touch -> r . currentAngles ; if ( ! touch -> r . bmodel ) { angles = vec3_origin ; } CM_TransformedBoxTrace ( trace , ( float * ) start , ( float * ) end , ( float * ) mins , ( float * ) maxs , clipHandle , contentmask , origin , angles , capsule ) ; if ( trace -> fraction < 1 ) { trace -> entityNum = touch -> s . number ; } }
void SV_ClipMoveToEntities ( moveclip_t * clip ) { int i , num ; int touchlist [ MAX_GENTITIES ] ; sharedEntity_t * touch ; int passOwnerNum ; trace_t trace , oldTrace ; clipHandle_t clipHandle ; float * origin , * angles ; int thisOwnerShared = 1 ; num = SV_AreaEntities ( clip -> boxmins , clip -> boxmaxs , touchlist , MAX_GENTITIES ) ; if ( clip -> passEntityNum != ENTITYNUM_NONE ) { passOwnerNum = ( SV_GentityNum ( clip -> passEntityNum ) ) -> r . ownerNum ; if ( passOwnerNum == ENTITYNUM_NONE ) { passOwnerNum = - 1 ; } } else { passOwnerNum = - 1 ; } if ( SV_GentityNum ( clip -> passEntityNum ) -> r . svFlags & SVF_OWNERNOTSHARED ) { thisOwnerShared = 0 ; } for ( i = 0 ; i < num ; i ++ ) { if ( clip -> trace . allsolid ) { return ; } touch = SV_GentityNum ( touchlist [ i ] ) ; if ( clip -> passEntityNum != ENTITYNUM_NONE ) { if ( touchlist [ i ] == clip -> passEntityNum ) { continue ; } if ( touch -> r . ownerNum == clip -> passEntityNum ) { if ( touch -> r . svFlags & SVF_OWNERNOTSHARED ) { if ( clip -> contentmask != ( MASK_SHOT | CONTENTS_LIGHTSABER ) && clip -> contentmask != ( MASK_SHOT ) ) { continue ; } } else { continue ; } } if ( touch -> r . ownerNum == passOwnerNum && ! ( touch -> r . svFlags & SVF_OWNERNOTSHARED ) && ! thisOwnerShared ) { continue ; } } if ( ! ( clip -> contentmask & touch -> r . contents ) ) { continue ; } if ( ( clip -> contentmask == ( MASK_SHOT | CONTENTS_LIGHTSABER ) || clip -> contentmask == MASK_SHOT ) && ( touch -> r . contents > 0 && ( touch -> r . contents & CONTENTS_NOSHOT ) ) ) { continue ; } clipHandle = SV_ClipHandleForEntity ( touch ) ; origin = touch -> r . currentOrigin ; angles = touch -> r . currentAngles ; if ( ! touch -> r . bmodel ) { angles = vec3_origin ; } CM_TransformedBoxTrace ( & trace , ( float * ) clip -> start , ( float * ) clip -> end , ( float * ) clip -> mins , ( float * ) clip -> maxs , clipHandle , clip -> contentmask , origin , angles , clip -> capsule ) ; oldTrace = clip -> trace ; if ( trace . allsolid ) { clip -> trace . allsolid = qtrue ; trace . entityNum = touch -> s . number ; } else if ( trace . startsolid ) { clip -> trace . startsolid = qtrue ; trace . entityNum = touch -> s . number ; } if ( trace . fraction < clip -> trace . fraction ) { qboolean oldStart ; oldStart = clip -> trace . startsolid ; trace . entityNum = touch -> s . number ; clip -> trace = trace ; clip -> trace . startsolid = ( qboolean ) ( ( unsigned ) clip -> trace . startsolid | ( unsigned ) oldStart ) ; } if ( ( trace . entityNum == touch -> s . number ) && ( clip -> traceFlags ) ) { if ( touch -> s . ghoul2 ) { int oldTraceRecSize = 0 ; int newTraceRecSize = 0 ; int z ; for ( z = 0 ; z < MAX_G2_COLLISIONS ; z ++ ) { if ( clip -> trace . G2CollisionMap [ z ] . mEntityNum != - 1 ) { oldTraceRecSize ++ ; } } G2API_@@ CollisionDetect ( & clip -> trace . G2CollisionMap [ 0 ] , * ( ( CGhoul2Info@@ _v * ) touch -> s . ghoul2 ) , touch -> s . angles , touch -> s . origin , svs . time , touch -> s . number , clip -> start , clip -> end , touch -> s . modelScale , G2Vert@@ Space@@ Server , clip -> traceFlags , clip -> useLod ) ; for ( z = 0 ; z < MAX_G2_COLLISIONS ; z ++ ) { if ( clip -> trace . G2CollisionMap [ z ] . mEntityNum != - 1 ) { newTraceRecSize ++ ; } } if ( newTraceRecSize == oldTraceRecSize ) { clip -> trace = oldTrace ; } } } } }
void SV_Trace ( trace_t * results , const vec3_t start , const vec3_t mins , const vec3_t maxs , const vec3_t end , int passEntityNum , int contentmask , int capsule , int traceFlags , int useLod ) { moveclip_t clip ; int i ; if ( ! mins ) { mins = vec3_origin ; } if ( ! maxs ) { maxs = vec3_origin ; } Com_Memset ( & clip , 0 , sizeof ( moveclip_t ) ) ; CM_BoxTrace ( & clip . trace , start , end , mins , maxs , 0 , contentmask , capsule ) ; clip . trace . entityNum = clip . trace . fraction != 1.0 ? ENTITYNUM_WORLD : ENTITYNUM_NONE ; if ( clip . trace . fraction == 0 ) { * results = clip . trace ; return ; } clip . contentmask = contentmask ; VectorCopy ( start , clip . start ) ; clip . traceFlags = traceFlags ; clip . useLod = useLod ; VectorCopy ( end , clip . end ) ; clip . mins = mins ; clip . maxs = maxs ; clip . passEntityNum = passEntityNum ; clip . capsule = capsule ; for ( i = 0 ; i < 3 ; i ++ ) { if ( end [ i ] > start [ i ] ) { clip . boxmins [ i ] = clip . start [ i ] + clip . mins [ i ] - 1 ; clip . boxmaxs [ i ] = clip . end [ i ] + clip . maxs [ i ] + 1 ; } else { clip . boxmins [ i ] = clip . end [ i ] + clip . mins [ i ] - 1 ; clip . boxmaxs [ i ] = clip . start [ i ] + clip . maxs [ i ] + 1 ; } } SV_ClipMoveToEntities ( & clip ) ; * results = clip . trace ; }
int SV_PointContents ( const vec3_t p , int passEntityNum ) { int touch [ MAX_GENTITIES ] ; sharedEntity_t * hit ; int i , num ; int contents , c2 ; clipHandle_t clipHandle ; float * angles ; contents = CM_PointContents ( p , 0 ) ; num = SV_AreaEntities ( p , p , touch , MAX_GENTITIES ) ; for ( i = 0 ; i < num ; i ++ ) { if ( touch [ i ] == passEntityNum ) { continue ; } hit = SV_GentityNum ( touch [ i ] ) ; clipHandle = SV_ClipHandleForEntity ( hit ) ; angles = hit -> s . angles ; if ( ! hit -> r . bmodel ) { angles = vec3_origin ; } c2 = CM_TransformedPointContents ( p , clipHandle , hit -> s . origin , hit -> s . angles ) ; contents |= c2 ; } return contents ; }
void process ( SILInstruction * I ) { visit ( I ) ; }
SILBasicBlock * remapBasicBlock ( SILBasicBlock * BB ) { return BB ; }
SILValue getMappedValue ( SILValue Value ) { return SILCloner < InitSequenceCloner > :: getMappedValue ( Value ) ; }
void postProcess ( SILInstruction * orig , SILInstruction * cloned ) { DestIP -> getParent ( ) -> push_front ( cloned ) ; cloned -> moveBefore ( DestIP ) ; SILClonerWithScopes < InitSequenceCloner > :: postProcess ( orig , cloned ) ; }
SILValue clone ( ) { for ( auto I : Init . Instructions ) process ( I ) ; return getMappedValue ( Init . Result ) ; }
static bool isStructurallyIdentical ( SILValue LHS , SILValue RHS ) { if ( LHS == RHS ) return true ; if ( LHS -> getType ( ) != RHS -> getType ( ) ) return false ; auto lResult = LHS -> getDefiningInstructionResult ( ) ; auto rResult = RHS -> getDefiningInstructionResult ( ) ; assert ( lResult && rResult && " operands ▁ of ▁ instructions ▁ approved ▁ by ▁ analyzeStaticInitializer ▁ " " should ▁ always ▁ be ▁ defined ▁ by ▁ instructions " ) ; return ( lResult -> ResultIndex == rResult -> ResultIndex && lResult -> Instruction -> isIdenticalTo ( rResult -> Instruction , isStructurallyIdentical ) ) ; }
static bool isSameInitSequence ( const InitSequence & LHS , const InitSequence & RHS ) { assert ( LHS . isValid ( ) && RHS . isValid ( ) ) ; return isStructurallyIdentical ( LHS . Result , RHS . Result ) ; }
static bool isAssignableExternally ( VarDecl * Property , SILModule * Module ) { if ( Module -> isVisibleExternally ( Property ) ) { auto * Ty = dyn_cast < NominalTypeDecl > ( Property -> getDeclContext ( ) ) ; if ( isa < ClassDecl > ( Ty ) ) return false ; for ( auto SP : Ty -> getStoredProperties ( ) ) { auto storedPropertyAccess = SP -> getEffectiveAccess ( ) ; if ( storedPropertyAccess <= AccessLevel :: FilePrivate || ( storedPropertyAccess <= AccessLevel :: Internal && Module -> isWholeModule ( ) ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ cannot ▁ be ▁ set ▁ externally \n " ) ; return false ; } } LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ can ▁ be ▁ used ▁ externally \n " ) ; return true ; } return false ; }
static bool mayHaveUnknownUses ( VarDecl * Property , SILModule * Module ) { if ( Property -> getDeclContext ( ) -> getParentModule ( ) != Module -> getSwiftModule ( ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ is ▁ defined ▁ in ▁ a ▁ different ▁ module \n " ) ; return true ; } if ( isAssignableExternally ( Property , Module ) ) { return true ; } return false ; }
static bool isProjectionOfProperty ( SILValue addr , VarDecl * Property ) { if ( auto * REA = dyn_cast < RefElementAddrInst > ( addr ) ) { return REA -> getField ( ) == Property ; } if ( auto * SEA = dyn_cast < StructElementAddrInst > ( addr ) ) { return SEA -> getField ( ) == Property ; } return false ; }
static bool isValidPropertyLoad ( SILInstruction * I ) { if ( isa < LoadInst > ( I ) ) return true ; if ( isa < StructElementAddrInst > ( I ) || isa < TupleElementAddrInst > ( I ) ) { auto projection = cast < SingleValueInstruction > ( I ) ; for ( auto Use : getNonDebugUses ( projection ) ) { if ( isIncidentalUse ( Use -> getUser ( ) ) ) continue ; if ( ! isValidPropertyLoad ( Use -> getUser ( ) ) ) return false ; } return true ; } return false ; }
static inline double max ( double a , double b ) { if ( a > b ) return a ; else return b ; }
public : HrPwPlotBackground ( HrPwPlot * _parent ) { setZ ( 0.0 ) ; parent = _parent ; }
