private static boolean hasOverflow ( PsiExpression expr , @ NotNull Project project ) { if ( ! TypeConversionUtil . isNumericType ( expr . getType ( ) ) ) return false ; boolean overflow = false ; try { if ( expr . getUserData ( HAS_OVERFLOW_IN_CHILD ) == null ) { JavaPsi@@ Facade . getInstance ( project ) . getConstantEvaluationHelper ( ) . computeConstantExpression ( expr , true ) ; } else { overflow = true ; } } catch ( ConstantEvaluationOverflowException e ) { overflow = true ; } finally { PsiElement parent = expr . getParent ( ) ; if ( overflow && parent instanceof PsiExpression ) { parent . putUserData ( HAS_OVERFLOW_IN_CHILD , " " ) ; } } return overflow ; }
public static void configure ( Settings settings ) { if ( loaded ) { return ; } loaded = true ; Environment environment = new Environment ( settings ) ; ImmutableSettings . Builder settingsBuilder = settingsBuilder ( ) . put ( settings ) ; resolveConfig ( environment , settingsBuilder ) ; settingsBuilder . putProperties ( " elasticsearch . " , System . getProperties ( ) ) . putProperties ( " es . " , System . getProperties ( ) ) . replacePropertyPlace@@ holders ( ) ; Properties props = new Properties ( ) ; for ( Map . Entry < String , String > entry : settingsBuilder . build ( ) . getAsMap ( ) . entrySet ( ) ) { String key = " log4j . " + entry . getKey ( ) ; String value = entry . getValue ( ) ; if ( replacements . containsKey ( value ) ) { value = replacements . get ( value ) ; } if ( key . endsWith ( " . value " ) ) { props . setProperty ( key . substring ( 0 , key . length ( ) - " . value " . length ( ) ) , value ) ; } else if ( key . endsWith ( " . type " ) ) { props . setProperty ( key . substring ( 0 , key . length ( ) - " . type " . length ( ) ) , value ) ; } else { props . setProperty ( key , value ) ; } } PropertyConfigurator . configure ( props ) ; }
public static void resolveConfig ( Environment env , final ImmutableSettings . Builder settingsBuilder ) { try { Files . walkFileTree ( env . configFile ( ) . toPath ( ) , EnumSet . of ( FileVisitOption . FOLLOW_LINKS ) , Integer . MAX_VALUE , new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { if ( file . getFileName ( ) . toString ( ) . startsWith ( " logging . " ) ) { loadConfig ( file , settingsBuilder ) ; } return FileVisitResult . CONTIN@@ UE ; } } ) ; } catch ( IOException ioe ) { throw new ElasticsearchException ( " Failed ▁ to ▁ load ▁ logging ▁ configuration " , ioe ) ; } }
public static void loadConfig ( Path file , ImmutableSettings . Builder settingsBuilder ) { try { settingsBuilder . loadFromUrl ( file . toUri ( ) . toURL ( ) ) ; } catch ( FailedToResolveConfigException | NoClass@@ DefFoundError | MalformedURLException e ) { } }
static Boolean launchWordCount ( String fileSys , String jobTracker , JobConf conf , String input , int numMaps , int numReduces ) throws IOException { final Path inDir = new Path ( " / testing / wc / input " ) ; final Path outDir = new Path ( " / testing / wc / output " ) ; FileSystem fs = FileSystem . get ( URI . create ( fileSys ) , conf ) ; fs . delete ( outDir , true ) ; if ( ! fs . mkdirs ( inDir ) ) { throw new IOException ( " Mkdirs ▁ failed ▁ to ▁ create ▁ " + inDir . toString ( ) ) ; } { DataOutputStream file = fs . create ( new Path ( inDir , " part - 0" ) ) ; file . writeBytes ( input ) ; file . close ( ) ; } FileSystem . setDefaultUri ( conf , fileSys ) ; conf . set ( " mapred . job . tracker " , jobTracker ) ; conf . setJobName ( " wordcount " ) ; conf . setInputFormat ( TextInputFormat . class ) ; conf . setOutputKeyClass ( Text . class ) ; conf . setOutputValueClass ( IntWritable . class ) ; conf . setMapperClass ( WordCount . MapClass . class ) ; conf . setCombinerClass ( WordCount . Reduce . class ) ; conf . setReducerClass ( WordCount . Reduce . class ) ; FileInput@@ Format . setInputPaths ( conf , inDir ) ; FileOutputFormat . setOutputPath ( conf , outDir ) ; conf . setNumMapTasks ( numMaps ) ; conf . setNumReduceTasks ( numReduces ) ; RunningJob rj = JobClient . runJob ( conf ) ; JobID jobId = rj . getID ( ) ; if ( rj . isSuccessful ( ) ) { System . out . println ( " Job ▁ Id : " + jobId + " ▁ completed ▁ successfully . ▁ Killing ▁ it ▁ now " ) ; rj . killJob ( ) ; } return rj . isSuccessful ( ) ; }
static void PrintHelp ( ) { System . out . println ( " \n Usage : ▁ ▁ LZMA ▁ < e | d > ▁ [ < switches > . . . ] ▁ inputFile ▁ outputFile \n " + " ▁ ▁ e : ▁ encode ▁ file \n " + " ▁ ▁ d : ▁ decode ▁ file \n " + " ▁ ▁ b : ▁ Benchmark \n " + " < Switches > \n " + " ▁ ▁ - d { N } : ▁ ▁ set ▁ dictionary ▁ - ▁ [ 0,28 ] , ▁ default : ▁ 23 ▁ ( 8MB ) \n " + " ▁ ▁ - fb { N } : ▁ set ▁ number ▁ of ▁ fast ▁ bytes ▁ - ▁ [ 5 , ▁ 273 ] , ▁ default : ▁ 128 \n " + " ▁ ▁ - lc { N } : ▁ set ▁ number ▁ of ▁ literal ▁ context ▁ bits ▁ - ▁ [ 0 , ▁ 8 ] , ▁ default : ▁ 3 \n " + " ▁ ▁ - lp { N } : ▁ set ▁ number ▁ of ▁ literal ▁ pos ▁ bits ▁ - ▁ [ 0 , ▁ 4 ] , ▁ default : ▁ 0 \n " + " ▁ ▁ - pb { N } : ▁ set ▁ number ▁ of ▁ pos ▁ bits ▁ - ▁ [ 0 , ▁ 4 ] , ▁ default : ▁ 2 \n " + " ▁ ▁ - mf { MF _ ID } : ▁ set ▁ Match ▁ Finder : ▁ [ bt2 , ▁ bt4 ] , ▁ default : ▁ bt4 \n " + " ▁ ▁ - eos : ▁ ▁ ▁ write ▁ End ▁ Of ▁ Stream ▁ marker \n " ) ; }
public static void main ( String [ ] args ) throws Exception { System . out . println ( " \n LZMA ▁ ( Java ) ▁ 4.61 ▁ ▁ 2008-@@ 11-23 \n " ) ; if ( args . length < 1 ) { PrintHelp ( ) ; return ; } CommandLine params = new CommandLine ( ) ; if ( ! params . Parse ( args ) ) { System . out . println ( " \n Incorrect ▁ command " ) ; return ; } if ( params . Command == CommandLine . kBenchmak ) { int dictionary = ( 1 << 21 ) ; if ( params . DictionarySizeIsDefined ) dictionary = params . DictionarySize ; if ( params . MatchFinder > 1 ) throw new Exception ( " Unsupported ▁ match ▁ finder " ) ; SevenZip . LzmaBen@@ ch . LzmaBenchmark ( params . NumBenchmarkPasses , dictionary ) ; } else if ( params . Command == CommandLine . kEncode || params . Command == CommandLine . kDecode ) { java . io . File inFile = new java . io . File ( params . InFile ) ; java . io . File outFile = new java . io . File ( params . OutFile ) ; java . io . BufferedInputStream inStream = new java . io . BufferedInputStream ( new java . io . FileInputStream ( inFile ) ) ; java . io . BufferedOutputStream outStream = new java . io . BufferedOutputStream ( new java . io . FileOutputStream ( outFile ) ) ; boolean eos = false ; if ( params . Eos ) eos = true ; if ( params . Command == CommandLine . kEncode ) { SevenZip . Compression . LZMA . Encoder encoder = new SevenZip . Compression . LZMA . Encoder ( ) ; if ( ! encoder . SetAlgorithm ( params . Algorithm ) ) throw new Exception ( " Incorrect ▁ compression ▁ mode " ) ; if ( ! encoder . SetDictionarySize ( params . DictionarySize ) ) throw new Exception ( " Incorrect ▁ dictionary ▁ size " ) ; if ( ! encoder . SetNumFastBytes ( params . Fb ) ) throw new Exception ( " Incorrect ▁ - fb ▁ value " ) ; if ( ! encoder . SetMatchFinder ( params . MatchFinder ) ) throw new Exception ( " Incorrect ▁ - mf ▁ value " ) ; if ( ! encoder . SetLcLpPb ( params . Lc , params . Lp , params . Pb ) ) throw new Exception ( " Incorrect ▁ - lc ▁ or ▁ - lp ▁ or ▁ - pb ▁ value " ) ; encoder . SetEndMarkerMode ( eos ) ; encoder . WriteCoder@@ Properties ( outStream ) ; long fileSize ; if ( eos ) fileSize = - 1 ; else fileSize = inFile . length ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) outStream . write ( ( int ) ( fileSize > > > ( 8 * i ) ) & 0xFF ) ; encoder . Code ( inStream , outStream , - 1 , - 1 , null ) ; } else { int propertiesSize = 5 ; byte [ ] properties = new byte [ propertiesSize ] ; if ( inStream . read ( properties , 0 , propertiesSize ) != propertiesSize ) throw new Exception ( " input ▁ . lzma ▁ file ▁ is ▁ too ▁ short " ) ; SevenZip . Compression . LZMA . Decoder decoder = new SevenZip . Compression . LZMA . Decoder ( ) ; if ( ! decoder . SetDecoderProperties ( properties ) ) throw new Exception ( " Incorrect ▁ stream ▁ properties " ) ; long outSize = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int v = inStream . read ( ) ; if ( v < 0 ) throw new Exception ( " Can ' t ▁ read ▁ stream ▁ size " ) ; outSize |= ( ( long ) v ) << ( 8 * i ) ; } if ( ! decoder . Code ( inStream , outStream , outSize ) ) throw new Exception ( " Error ▁ in ▁ data ▁ stream " ) ; } outStream . flush ( ) ; outStream . close ( ) ; inStream . close ( ) ; } else throw new Exception ( " Incorrect ▁ command " ) ; return ; }
