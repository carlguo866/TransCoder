MP@@ 4@@ D@@ max@@ Atom :: MP@@ 4@@ D@@ max@@ Atom ( ) : MP@@ 4@@ Atom ( " d@@ max " ) { Add@@ Property ( new MP@@ 4@@ Integer@@ 32@@ Property ( " m@@ illi@@ Sec@@ s " ) ) ; }
void Lower@@ ing :: Lower@@ Rot@@ ate ( Gen@@ Tree@@ Ptr tree ) { N@@ Y@@ I@@ _AR@@ M ( " ARM ▁ Lower@@ ing ▁ for ▁ RO@@ L ▁ and ▁ RO@@ R " ) ; }
void Lower@@ ing :: Tree@@ Node@@ Info@@ Init ( Gen@@ Tree * stmt ) { N@@ Y@@ I ( " ARM ▁ Tree@@ No@@ d@@ Info@@ Init " ) ; }
bool Lower@@ ing :: is@@ R@@ M@@ W@@ Reg@@ Op@@ er ( Gen@@ Tree@@ Ptr tree ) { return false ; }
bool Lower@@ ing :: Is@@ Call@@ Target@@ In@@ Range ( void * addr ) { return comp -> code@@ Gen -> valid@@ Imm@@ For@@ B@@ L ( ( ssize_t ) addr ) ; }
bool Lower@@ ing :: Is@@ Contain@@ able@@ Imm@@ ed ( Gen@@ Tree * parentNode , Gen@@ Tree * child@@ Node ) { N@@ Y@@ I@@ _AR@@ M ( " ARM ▁ Is@@ Contain@@ able@@ Imm@@ ed " ) ; return false ; }
std :: string CJNI@@ System :: getProperty ( const std :: string & property ) { return jcast < std :: string > ( call@@ _@@ static_@@ method < jhstring > ( " java / lang / System " , " getProperty " , " ( L@@ java / lang / String ; ) L@@ java / lang / String ; " , jcast < jhstring > ( property ) ) ) ; }
std :: string CJNI@@ System :: getProperty ( const std :: string & property , const std :: string & defaultValue ) { return jcast < std :: string > ( call@@ _@@ static_@@ method < jhstring > ( " java / lang / System " , " getProperty " , " ( L@@ java / lang / String ; L@@ java / lang / String ; ) L@@ java / lang / String ; " , jcast < jhstring > ( property ) , jcast < jhstring > ( defaultValue ) ) ) ; }
std :: string CJNI@@ System :: setProperty ( const std :: string & property , const std :: string & defaultValue ) { return jcast < std :: string > ( call@@ _@@ static_@@ method < jhstring > ( " java / lang / System " , " setProperty " , " ( L@@ java / lang / String ; L@@ java / lang / String ; ) L@@ java / lang / String ; " , jcast < jhstring > ( property ) , jcast < jhstring > ( defaultValue ) ) ) ; }
std :: string CJNI@@ System :: clearProperty ( const std :: string & property ) { return jcast < std :: string > ( call@@ _@@ static_@@ method < jhstring > ( " java / lang / System " , " clearProperty " , " ( L@@ java / lang / String ; ) L@@ java / lang / String ; " , jcast < jhstring > ( property ) ) ) ; }
int64_t CJNI@@ System :: nan@@ o@@ Time ( ) { return call@@ _@@ static_@@ method < j@@ long > ( " java / lang / System " , " nan@@ o@@ Time " , " ( ) J " ) ; }
template < class T > void Point@@ Movement@@ Generator < T > :: Do@@ Initialize ( T * unit ) { if ( ! unit -> Is@@ Stopped ( ) ) unit -> StopMoving ( ) ; unit -> Add@@ Unit@@ State ( UNIT_STATE_@@ RO@@ AM@@ ING | UNIT_STATE_@@ RO@@ AM@@ ING_@@ MOVE ) ; if ( id == EVENT_@@ CHAR@@ GE_@@ PRE@@ PATH ) return ; Movement :: MoveSpline@@ Init init ( unit ) ; init . MoveTo ( i_@@ x , i_@@ y , i_@@ z , m_@@ gener@@ ate@@ Path ) ; if ( speed > 0.0f ) init . Set@@ Veloc@@ ity ( speed ) ; init . La@@ un@@ ch ( ) ; }
template < class T > bool Point@@ Movement@@ Generator < T > :: Do@@ Update ( T * unit , uint32 ) { if ( ! unit ) return false ; if ( unit -> HasUnitState ( UNIT_STATE_@@ RO@@ OT | UNIT_STATE_@@ ST@@ UN@@ NED ) ) { unit -> Clear@@ Unit@@ State ( UNIT_STATE_@@ RO@@ AM@@ ING_@@ MOVE ) ; return true ; } unit -> Add@@ Unit@@ State ( UNIT_STATE_@@ RO@@ AM@@ ING_@@ MOVE ) ; if ( id != EVENT_@@ CHAR@@ GE_@@ PRE@@ PATH && i_@@ recal@@ culate@@ Speed && ! unit -> mov@@ esp@@ line -> Fin@@ alized ( ) ) { i_@@ recal@@ culate@@ Speed = false ; Movement :: MoveSpline@@ Init init ( unit ) ; init . MoveTo ( i_@@ x , i_@@ y , i_@@ z , m_@@ gener@@ ate@@ Path ) ; if ( speed > 0.0f ) init . Set@@ Veloc@@ ity ( speed ) ; init . La@@ un@@ ch ( ) ; } return ! unit -> mov@@ esp@@ line -> Fin@@ alized ( ) ; }
template < class T > void Point@@ Movement@@ Generator < T > :: Do@@ Final@@ ize ( T * unit ) { if ( unit -> HasUnitState ( UNIT_STATE_@@ CHAR@@ GING ) ) unit -> Clear@@ Unit@@ State ( UNIT_STATE_@@ RO@@ AM@@ ING | UNIT_STATE_@@ RO@@ AM@@ ING_@@ MOVE ) ; if ( unit -> mov@@ esp@@ line -> Fin@@ alized ( ) ) MovementInform ( unit ) ; }
template < class T > void Point@@ Movement@@ Generator < T > :: Do@@ Reset ( T * unit ) { if ( ! unit -> Is@@ Stopped ( ) ) unit -> StopMoving ( ) ; unit -> Add@@ Unit@@ State ( UNIT_STATE_@@ RO@@ AM@@ ING | UNIT_STATE_@@ RO@@ AM@@ ING_@@ MOVE ) ; }
template < > void Point@@ Movement@@ Generator < Creature > :: MovementInform ( Creature * unit ) { if ( unit -> AI ( ) ) unit -> AI ( ) -> MovementInform ( POINT_MOTION_TYPE , id ) ; }
void As@@ si@@ stance@@ Movement@@ Generator :: Final@@ ize ( Unit * unit ) { unit -> ToCreature ( ) -> Set@@ No@@ Call@@ As@@ si@@ stance ( false ) ; unit -> ToCreature ( ) -> Call@@ As@@ si@@ stance ( ) ; if ( unit -> isAlive ( ) ) unit -> GetMotionMaster ( ) -> Move@@ Seek@@ As@@ si@@ stance@@ Di@@ stract ( sWorld -> getIntConfig ( CONFIG_@@ CRE@@ ATURE_@@ F@@ AM@@ IL@@ Y_@@ AS@@ SI@@ ST@@ ANCE_@@ DEL@@ AY ) ) ; }
bool Effect@@ Movement@@ Generator :: Update ( Unit * unit , uint32 ) { return ! unit -> mov@@ esp@@ line -> Fin@@ alized ( ) ; }
void Effect@@ Movement@@ Generator :: Final@@ ize ( Unit * unit ) { if ( unit -> GetTypeId ( ) != TYPEID_UNIT ) return ; if ( unit -> isAlive ( ) && ! unit -> HasUnitState ( UNIT_STATE_@@ CON@@ FU@@ SED | UNIT_STATE_@@ F@@ LEE@@ ING ) ) { if ( Unit * victim = unit -> getVictim ( ) ) unit -> GetMotionMaster ( ) -> MoveChase ( victim ) ; else unit -> GetMotionMaster ( ) -> Initialize ( ) ; } if ( unit -> ToCreature ( ) -> AI ( ) ) unit -> ToCreature ( ) -> AI ( ) -> MovementInform ( EFFECT_MOTION_TYPE , m_@@ Id ) ; }
C@@ Ma@@ ze :: C@@ Ma@@ ze ( int n@@ Width , int nHeight , int n@@ Cell@@ Width , int n@@ Cell@@ Height , bool b@@ Copy@@ Screen ) { m_@@ n@@ Counter = 0 ; m_@@ n@@ Width = n@@ Width ; m_@@ nHeight = nHeight ; m_@@ n@@ Cell@@ Width = n@@ Cell@@ Width ; m_@@ n@@ Cell@@ Height = n@@ Cell@@ Height ; m_@@ n@@ Cols = m_@@ n@@ Width / m_@@ n@@ Cell@@ Width - 1 ; m_@@ n@@ Rows = m_@@ nHeight / m_@@ n@@ Cell@@ Height - 1 ; m_@@ n@@ Offset@@ X = ( m_@@ n@@ Width - m_@@ n@@ Cols * m_@@ n@@ Cell@@ Width ) / 2 ; m_@@ n@@ Offset@@ Y = ( m_@@ nHeight - m_@@ n@@ Rows * m_@@ n@@ Cell@@ Height ) / 2 ; m_b@@ Re@@ Draw@@ Before@@ Generate = FALSE ; m_b@@ Allow@@ Non@@ Solution = FALSE ; m_b@@ F@@ las@@ h@@ Path = TRUE ; H@@ DC h@@ Screen@@ D@@ c = Get@@ DC ( NULL ) ; m_h@@ Work@@ D@@ c = Create@@ Compatible@@ DC ( NULL ) ; m_h@@ Work@@ B@@ mp = Create@@ Compatible@@ Bitmap ( h@@ Screen@@ D@@ c , m_@@ n@@ Width , m_@@ nHeight ) ; m_h@@ Old@@ B@@ mp = Select@@ Object ( m_h@@ Work@@ D@@ c , ( H@@ G@@ D@@ IO@@ B@@ J ) m_h@@ Work@@ B@@ mp ) ; m_h@@ Old@@ Pen = Select@@ Object ( m_h@@ Work@@ D@@ c , m_@@ ma@@ ze@@ Color . Get@@ Pen ( cl@@ Wall ) ) ; if ( b@@ Copy@@ Screen ) { Bit@@ B@@ lt ( m_h@@ Work@@ D@@ c , 0 , 0 , m_@@ n@@ Width , m_@@ nHeight , h@@ Screen@@ D@@ c , 0 , 0 , SRC@@ COPY ) ; } Release@@ DC ( NULL , h@@ Screen@@ D@@ c ) ; RECT rect = { 0 , 0 , m_@@ n@@ Width , m_@@ nHeight } ; Fill@@ Rect ( m_h@@ Work@@ D@@ c , & rect , m_@@ ma@@ ze@@ Color . Get@@ Brush ( cl@@ Back@@ Gro@@ und ) ) ; if ( m_@@ n@@ Cols > 0 && m_@@ n@@ Rows > 0 ) { m_@@ cells = new C@@ Ma@@ ze@@ Cell [ m_@@ n@@ Cols * m_@@ n@@ Rows ] ; Initialize@@ Cells ( ) ; Reset@@ And@@ Re@@ Draw@@ All@@ Cells ( ) ; m_@@ state = MS_@@ INITI@@ ALIZ@@ ED ; } else { m_@@ state = MS_@@ ERROR ; m_@@ cells = NULL ; } }
C@@ Ma@@ ze :: ~ C@@ Ma@@ ze ( void ) { Select@@ Object ( m_h@@ Work@@ D@@ c , m_h@@ Old@@ Pen ) ; Select@@ Object ( m_h@@ Work@@ D@@ c , m_h@@ Old@@ B@@ mp ) ; Delete@@ DC ( m_h@@ Work@@ D@@ c ) ; Delete@@ Object ( m_h@@ Work@@ B@@ mp ) ; if ( m_@@ cells != NULL ) { delete [ ] m_@@ cells ; } }
C@@ Ma@@ ze@@ Cell * C@@ Ma@@ ze :: Get@@ Cell ( int i , int j ) { if ( i < 0 || j < 0 || i >= m_@@ n@@ Cols || j >= m_@@ n@@ Rows ) { return NULL ; } return & m_@@ cells [ j * m_@@ n@@ Cols + i ] ; }
void C@@ Ma@@ ze :: Initialize@@ Cells ( ) { for ( int i = 0 ; i < m_@@ n@@ Cols ; ++ i ) { for ( int j = 0 ; j < m_@@ n@@ Rows ; ++ j ) { C@@ Ma@@ ze@@ Cell * p@@ Cell = Get@@ Cell ( i , j ) ; p@@ Cell -> Set@@ Parent ( this , i , j ) ; } } }
void C@@ Ma@@ ze :: Re@@ Draw@@ Si@@ des ( ) { int nP@@ ic@@ Width = m_@@ n@@ Cols * m_@@ n@@ Cell@@ Width ; int nP@@ ic@@ Height = m_@@ n@@ Rows * m_@@ n@@ Cell@@ Height ; Move@@ To@@ Ex ( m_h@@ Work@@ D@@ c , m_@@ n@@ Offset@@ X , m_@@ n@@ Offset@@ Y , NULL ) ; LineTo ( m_h@@ Work@@ D@@ c , m_@@ n@@ Offset@@ X + nP@@ ic@@ Width , m_@@ n@@ Offset@@ Y ) ; LineTo ( m_h@@ Work@@ D@@ c , m_@@ n@@ Offset@@ X + nP@@ ic@@ Width , m_@@ n@@ Offset@@ Y + nP@@ ic@@ Height ) ; LineTo ( m_h@@ Work@@ D@@ c , m_@@ n@@ Offset@@ X , m_@@ n@@ Offset@@ Y + nP@@ ic@@ Height ) ; LineTo ( m_h@@ Work@@ D@@ c , m_@@ n@@ Offset@@ X , m_@@ n@@ Offset@@ Y ) ; }
void C@@ Ma@@ ze :: Reset@@ All@@ Cells ( ) { for ( int i = 0 ; i < m_@@ n@@ Cols ; ++ i ) { for ( int j = 0 ; j < m_@@ n@@ Rows ; ++ j ) { C@@ Ma@@ ze@@ Cell * p@@ Cell = Get@@ Cell ( i , j ) ; p@@ Cell -> Reset ( ) ; } } }
void C@@ Ma@@ ze :: Reset@@ And@@ Re@@ Draw@@ All@@ Cells ( ) { for ( int i = 0 ; i < m_@@ n@@ Cols ; ++ i ) { for ( int j = 0 ; j < m_@@ n@@ Rows ; ++ j ) { C@@ Ma@@ ze@@ Cell * p@@ Cell = Get@@ Cell ( i , j ) ; p@@ Cell -> Reset ( ) ; p@@ Cell -> Re@@ Draw ( ) ; } } Re@@ Draw@@ Si@@ des ( ) ; }
void C@@ Ma@@ ze :: Re@@ Draw@@ All@@ Cells ( ) { for ( int i = 0 ; i < m_@@ n@@ Cols ; ++ i ) { for ( int j = 0 ; j < m_@@ n@@ Rows ; ++ j ) { C@@ Ma@@ ze@@ Cell * p@@ Cell = Get@@ Cell ( i , j ) ; p@@ Cell -> Re@@ Draw ( ) ; } } Re@@ Draw@@ Si@@ des ( ) ; }
void C@@ Ma@@ ze :: Next ( BOOL b@@ Delay ) { DWORD dw@@ Delay@@ Value = 0 ; switch ( m_@@ state ) { case MS_@@ INITI@@ ALIZ@@ ED : m_@@ cell@@ Gener@@ ating = Get@@ Random@@ Cell ( ) ; m_@@ cell@@ Stack . Init ( ) ; m_@@ cell@@ Stack . Push ( m_@@ cell@@ Gener@@ ating ) ; m_@@ cell@@ Gener@@ ating -> m_b@@ Gener@@ ated = true ; Change@@ State ( MS_@@ GENER@@ AT@@ ING ) ; break ; case MS_@@ GENER@@ AT@@ ING : if ( m_@@ cell@@ Stack . IsEmpty ( ) ) { Change@@ State ( MS_@@ GENER@@ ATED ) ; } else { bool b@@ Get@@ New@@ Cell = false ; C@@ Ma@@ ze@@ Cell * p@@ Top@@ Cell = m_@@ cell@@ Stack . Top ( ) ; p@@ Top@@ Cell -> Re@@ Draw ( ) ; p@@ Top@@ Cell -> Go@@ Generate ( & b@@ Get@@ New@@ Cell ) ; if ( b@@ Get@@ New@@ Cell ) { } } break ; case MS_@@ GENER@@ ATED : if ( m_b@@ Allow@@ Non@@ Solution && m_@@ n@@ Rows * m_@@ n@@ Cols >= 10 && m_@@ n@@ Cols > 1 && m_@@ n@@ Rows > 1 ) { int n@@ Right@@ Wall@@ sCount = ( m_@@ n@@ Cols - 1 ) * m_@@ n@@ Rows ; int n@@ Botto@@ m@@ Wall@@ sCount = ( m_@@ n@@ Rows - 1 ) * m_@@ n@@ Cols ; int n@@ Wall@@ sCount = n@@ Right@@ Wall@@ sCount + n@@ Botto@@ m@@ Wall@@ sCount ; int n@@ Changed@@ Wall@@ sCount = n@@ Wall@@ sCount * 2 / 100 ; set < int > set@@ Changed@@ Wall@@ s ; vector < int > vector@@ Changed@@ Wall@@ s ; if ( n@@ Changed@@ Wall@@ sCount > 100 ) { n@@ Changed@@ Wall@@ sCount = 100 ; } while ( ( int ) set@@ Changed@@ Wall@@ s . size ( ) < n@@ Changed@@ Wall@@ sCount ) { set@@ Changed@@ Wall@@ s . insert ( Big@@ R@@ and ( ) % n@@ Wall@@ sCount ) ; } vector@@ Changed@@ Wall@@ s . assign ( set@@ Changed@@ Wall@@ s . begin ( ) , set@@ Changed@@ Wall@@ s . end ( ) ) ; random_@@ shuffle ( vector@@ Changed@@ Wall@@ s . begin ( ) , vector@@ Changed@@ Wall@@ s . end ( ) ) ; for ( int i = 0 ; i < n@@ Changed@@ Wall@@ sCount ; ++ i ) { int n@@ Offset = vector@@ Changed@@ Wall@@ s . at ( i ) ; if ( n@@ Offset < n@@ Right@@ Wall@@ sCount ) { int n@@ Row = n@@ Offset / ( m_@@ n@@ Cols - 1 ) ; int n@@ Col = n@@ Offset % ( m_@@ n@@ Cols - 1 ) ; C@@ Ma@@ ze@@ Cell * p@@ Cell = Get@@ Cell ( n@@ Col , n@@ Row ) ; p@@ Cell -> Set@@ Wall ( DIR_@@ RIGHT , ! p@@ Cell -> Get@@ Wall ( DIR_@@ RIGHT ) ) ; } else { n@@ Offset -= n@@ Right@@ Wall@@ sCount ; int n@@ Row = n@@ Offset / m_@@ n@@ Cols ; int n@@ Col = n@@ Offset % m_@@ n@@ Cols ; C@@ Ma@@ ze@@ Cell * p@@ Cell = Get@@ Cell ( n@@ Col , n@@ Row ) ; p@@ Cell -> Set@@ Wall ( DIR_@@ BOTTOM , ! p@@ Cell -> Get@@ Wall ( DIR_@@ BOTTOM ) ) ; } } } Re@@ Draw@@ All@@ Cells ( ) ; Change@@ State ( MS@@ _SETT@@ ING ) ; break ; case MS@@ _SETT@@ ING : if ( true ) { int n@@ Counter = Get@@ Counter ( ) ; if ( n@@ Counter == 0 ) { if ( rand ( ) % 5 == 0 ) { int b@@ x [ ] = { 0 , 0 , 1 , 1 } ; int by [ ] = { 0 , 1 , 0 , 1 } ; int ex [ ] = { 1 , 1 , 0 , 0 } ; int e@@ y [ ] = { 1 , 0 , 1 , 0 } ; int offset = rand ( ) % 4 ; m_@@ cell@@ Begin = Get@@ Cell ( ( Get@@ Cols ( ) - 1 ) * b@@ x [ offset ] , ( Get@@ Rows ( ) - 1 ) * by [ offset ] ) ; m_@@ cell@@ End = Get@@ Cell ( ( Get@@ Cols ( ) - 1 ) * ex [ offset ] , ( Get@@ Rows ( ) - 1 ) * e@@ y [ offset ] ) ; } else { m_@@ cell@@ Begin = Get@@ Random@@ Cell ( ) ; do { m_@@ cell@@ End = Get@@ Random@@ Cell ( ) ; } while ( m_@@ cell@@ End == m_@@ cell@@ Begin ) ; } m_@@ cell@@ Begin -> m_b@@ Is@@ Begin = true ; m_@@ cell@@ End -> m_b@@ Is@@ End = true ; } else if ( n@@ Counter < 19 ) { m_@@ cell@@ Begin -> m_b@@ Is@@ Begin = ! m_@@ cell@@ Begin -> m_b@@ Is@@ Begin ; m_@@ cell@@ Begin -> Re@@ Draw ( ) ; dw@@ Delay@@ Value = 5@@ 5 ; } else if ( n@@ Counter < 37 ) { m_@@ cell@@ End -> m_b@@ Is@@ End = ! m_@@ cell@@ End -> m_b@@ Is@@ End ; m_@@ cell@@ End -> Re@@ Draw ( ) ; dw@@ Delay@@ Value = 5@@ 5 ; } else { Change@@ State ( MS@@ _SET ) ; } } break ; case MS@@ _SET : m_@@ cell@@ Stack . Init ( ) ; m_@@ cell@@ Stack . Push ( m_@@ cell@@ Begin ) ; m_@@ cell@@ Begin -> m_b@@ Visited = true ; Change@@ State ( MS_@@ RES@@ O@@ LV@@ ING ) ; break ; case MS_@@ RES@@ O@@ LV@@ ING : if ( m_@@ cell@@ Stack . IsEmpty ( ) ) { Change@@ State ( MS_@@ RES@@ O@@ LV@@ E@@ FAILED ) ; } else { bool b@@ Get@@ New@@ Cell = false ; C@@ Ma@@ ze@@ Cell * p@@ Top@@ Cell = m_@@ cell@@ Stack . Top ( ) ; p@@ Top@@ Cell -> Re@@ Draw ( ) ; if ( p@@ Top@@ Cell == m_@@ cell@@ End ) { Change@@ State ( MS_@@ RES@@ O@@ LV@@ ED ) ; break ; } p@@ Top@@ Cell -> Go@@ Resolve ( & b@@ Get@@ New@@ Cell ) ; if ( b@@ Get@@ New@@ Cell ) { } } dw@@ Delay@@ Value = 10 ; break ; case MS_@@ RES@@ O@@ LV@@ ED : { int n@@ Counter = Get@@ Counter ( ) ; if ( n@@ Counter > 5 ) { if ( m_b@@ Re@@ Draw@@ Before@@ Generate ) { Reset@@ And@@ Re@@ Draw@@ All@@ Cells ( ) ; } else { Reset@@ All@@ Cells ( ) ; } Change@@ State ( MS_@@ INITI@@ ALIZ@@ ED ) ; } else { if ( m_b@@ F@@ las@@ h@@ Path ) { COLORREF c@@ l = m_@@ ma@@ ze@@ Color . GetColor ( cl@@ Visited ) ; m_@@ ma@@ ze@@ Color . Set@@ Color ( cl@@ Visited , Get@@ Re@@ verse@@ Color ( c@@ l ) ) ; Re@@ Draw@@ All@@ Cells ( ) ; } dw@@ Delay@@ Value = 500 ; } } break ; case MS_@@ RES@@ O@@ LV@@ E@@ FAILED : dw@@ Delay@@ Value = 3000 ; if ( m_b@@ Re@@ Draw@@ Before@@ Generate ) { Reset@@ And@@ Re@@ Draw@@ All@@ Cells ( ) ; } else { Reset@@ All@@ Cells ( ) ; } Change@@ State ( MS_@@ INITI@@ ALIZ@@ ED ) ; case MS_@@ PA@@ USE@@ D : break ; case MS_@@ ERROR : break ; default : break ; } if ( b@@ Delay && dw@@ Delay@@ Value > 0 ) { Sleep ( dw@@ Delay@@ Value ) ; } }
C@@ Ma@@ ze@@ Color & C@@ Ma@@ ze :: Get@@ Color@@ Manager ( ) { return m_@@ ma@@ ze@@ Color ; }
C@@ Ma@@ ze@@ Cell * C@@ Ma@@ ze :: Get@@ Random@@ Cell ( ) { return Get@@ Cell ( rand ( ) % m_@@ n@@ Cols , rand ( ) % m_@@ n@@ Rows ) ; }
void C@@ Ma@@ ze :: Make@@ Random@@ Begin@@ And@@ End@@ Cell ( ) { m_@@ cell@@ Begin = Get@@ Random@@ Cell ( ) ; m_@@ cell@@ End = Get@@ Random@@ Cell ( ) ; while ( m_@@ cell@@ End == m_@@ cell@@ Begin ) { m_@@ cell@@ End = Get@@ Random@@ Cell ( ) ; } }
C@@ Ma@@ ze@@ Cell@@ Stack & C@@ Ma@@ ze :: Get@@ Cell@@ Stack ( ) { return m_@@ cell@@ Stack ; }
void C@@ Ma@@ ze :: Change@@ State ( Ma@@ ze@@ State state ) { if ( m_@@ state != state ) { m_@@ state = state ; m_@@ n@@ Counter = 0 ; } }
int C@@ Ma@@ ze :: Get@@ Counter ( ) { return m_@@ n@@ Counter ++ ; }
int C@@ Ma@@ ze :: Big@@ R@@ and ( ) { return ( ( ( rand ( ) % 0x@@ 100 ) << 0 ) | ( ( rand ( ) % 0x@@ 100 ) << 8 ) | ( ( rand ( ) % 0x@@ 100 ) << 16 ) | ( ( rand ( ) % 0x@@ 100 ) << 24 ) ) & ( ( unsigned ) - 1 >> 1 ) ; }
COLORREF C@@ Ma@@ ze :: Get@@ Re@@ verse@@ Color ( COLORREF c@@ l ) { return RGB ( ~ Get@@ R@@ Value ( c@@ l ) , ~ GetG@@ Value ( c@@ l ) , ~ GetB@@ Value ( c@@ l ) ) ; }
void C@@ Ma@@ ze :: Set@@ Re@@ Draw@@ Before@@ Generate ( BOOL b@@ Re@@ Draw@@ Before@@ Generate ) { m_b@@ Re@@ Draw@@ Before@@ Generate = b@@ Re@@ Draw@@ Before@@ Generate ; }
void C@@ Ma@@ ze :: Set@@ Allow@@ Non@@ Solution ( BOOL b@@ Allow@@ Non@@ Solution ) { m_b@@ Allow@@ Non@@ Solution = b@@ Allow@@ Non@@ Solution ; }
void C@@ Ma@@ ze :: SetF@@ las@@ h@@ Path ( BOOL b@@ F@@ las@@ h@@ Path ) { m_b@@ F@@ las@@ h@@ Path = b@@ F@@ las@@ h@@ Path ; }
void C@@ Ma@@ ze :: Update@@ Colors ( ) { Select@@ Object ( m_h@@ Work@@ D@@ c , m_@@ ma@@ ze@@ Color . Get@@ Pen ( cl@@ Wall ) ) ; }
void C@@ Ma@@ ze :: Restart ( ) { if ( m_b@@ Re@@ Draw@@ Before@@ Generate ) { Reset@@ And@@ Re@@ Draw@@ All@@ Cells ( ) ; } else { Reset@@ All@@ Cells ( ) ; } Change@@ State ( MS_@@ INITI@@ ALIZ@@ ED ) ; }
Mat@@ eri@@ al@@ Doc@@ Manager :: ~ Mat@@ eri@@ al@@ Doc@@ Manager ( void ) { Un@@ Register@@ All@@ Mat@@ eri@@ al@@ Views ( ) ; Clear@@ Undo ( ) ; Clear@@ Redo ( ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Register@@ Mat@@ eri@@ al@@ View ( Mat@@ eri@@ al@@ View * view ) { ASSERT ( view ) ; Un@@ Register@@ Mat@@ eri@@ al@@ View ( view ) ; mat@@ eri@@ al@@ Views . Append ( view ) ; view -> Set@@ Mat@@ eri@@ al@@ Doc@@ Manager ( this ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Un@@ Register@@ Mat@@ eri@@ al@@ View ( Mat@@ eri@@ al@@ View * view ) { ASSERT ( view ) ; mat@@ eri@@ al@@ Views . Remove ( view ) ; view -> Set@@ Mat@@ eri@@ al@@ Doc@@ Manager ( NULL ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Un@@ Register@@ All@@ Mat@@ eri@@ al@@ Views ( ) { int c = mat@@ eri@@ al@@ Views . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { mat@@ eri@@ al@@ Views [ i ] -> Set@@ Mat@@ eri@@ al@@ Doc@@ Manager ( NULL ) ; } mat@@ eri@@ al@@ Views . Clear ( ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Set@@ Selected@@ Mat@@ eri@@ al ( id@@ Mat@@ eri@@ al * mat@@ eri@@ al ) { bool change = false ; if ( mat@@ eri@@ al ) { if ( current@@ Mat@@ eri@@ al ) { if ( strcmp ( mat@@ eri@@ al -> GetName ( ) , current@@ Mat@@ eri@@ al -> render@@ Mat@@ eri@@ al -> GetName ( ) ) ) { change = true ; } } else { change = true ; } } else { if ( current@@ Mat@@ eri@@ al ) { change = true ; } } if ( change ) { if ( current@@ Mat@@ eri@@ al ) { if ( ! in@@ Pro@@ gress@@ Mat@@ eri@@ als . Get ( current@@ Mat@@ eri@@ al -> name . c_str ( ) ) ) { delete current@@ Mat@@ eri@@ al ; current@@ Mat@@ eri@@ al = NULL ; } } Mat@@ eri@@ al@@ Doc * * temp@@ Doc ; if ( mat@@ eri@@ al && in@@ Pro@@ gress@@ Mat@@ eri@@ als . Get ( mat@@ eri@@ al -> GetName ( ) , & temp@@ Doc ) ) { current@@ Mat@@ eri@@ al = * temp@@ Doc ; } else { current@@ Mat@@ eri@@ al = Create@@ Mat@@ eri@@ al@@ Doc ( mat@@ eri@@ al ) ; } Notify@@ Views ( current@@ Mat@@ eri@@ al , SEL@@ ECTION_@@ CHANGE ) ; } }
bool Mat@@ eri@@ al@@ Doc@@ Manager :: Do@@ es@@ File@@ Need@@ Apply ( const char * filename ) { for ( int i = 0 ; i < in@@ Pro@@ gress@@ Mat@@ eri@@ als . Num ( ) ; i ++ ) { Mat@@ eri@@ al@@ Doc * * pDoc = in@@ Pro@@ gress@@ Mat@@ eri@@ als . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> render@@ Mat@@ eri@@ al -> GetFileName ( ) , filename ) && ( * pDoc ) -> apply@@ Waiting ) return true ; } return false ; }
bool Mat@@ eri@@ al@@ Doc@@ Manager :: Do@@ es@@ Any@@ Need@@ Apply ( ) { for ( int i = 0 ; i < in@@ Pro@@ gress@@ Mat@@ eri@@ als . Num ( ) ; i ++ ) { Mat@@ eri@@ al@@ Doc * * pDoc = in@@ Pro@@ gress@@ Mat@@ eri@@ als . GetIndex ( i ) ; if ( ( * pDoc ) -> apply@@ Waiting ) return true ; } return false ; }
bool Mat@@ eri@@ al@@ Doc@@ Manager :: Is@@ File@@ Modi@@ fied ( const char * filename ) { for ( int i = 0 ; i < in@@ Pro@@ gress@@ Mat@@ eri@@ als . Num ( ) ; i ++ ) { Mat@@ eri@@ al@@ Doc * * pDoc = in@@ Pro@@ gress@@ Mat@@ eri@@ als . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> render@@ Mat@@ eri@@ al -> GetFileName ( ) , filename ) ) return true ; } return false ; }
bool Mat@@ eri@@ al@@ Doc@@ Manager :: Is@@ Any@@ Modi@@ fied ( ) { return ( in@@ Pro@@ gress@@ Mat@@ eri@@ als . Num ( ) > 0 ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Add@@ Mat@@ eri@@ al ( const char * name , const char * filename , const char * source@@ Text , bool add@@ Undo ) { if ( add@@ Undo ) { Add@@ Mat@@ eri@@ al@@ Modifier * mod = new Add@@ Mat@@ eri@@ al@@ Modifier ( this , name , filename ) ; Add@@ Mat@@ eri@@ al@@ Un@@ do@@ Modifier ( mod ) ; } Mat@@ eri@@ al@@ Doc * new@@ Doc = new Mat@@ eri@@ al@@ Doc ( ) ; new@@ Doc -> manager = this ; new@@ Doc -> modi@@ fied = true ; id@@ Mat@@ eri@@ al * ren@@ d@@ Mat = ( id@@ Mat@@ eri@@ al * ) decl@@ Manager -> Create@@ New@@ Decl ( DEC@@ L_@@ MAT@@ ERI@@ AL , name , filename ) ; if ( source@@ Text ) { ren@@ d@@ Mat -> SetText ( source@@ Text ) ; } new@@ Doc -> Set@@ Render@@ Mat@@ eri@@ al ( ren@@ d@@ Mat , true , source@@ Text ? true : false ) ; in@@ Pro@@ gress@@ Mat@@ eri@@ als . Set ( new@@ Doc -> name . c_str ( ) , new@@ Doc ) ; Notify@@ Views ( new@@ Doc , MAT@@ ERI@@ AL_@@ ADD ) ; new@@ Doc -> apply@@ Waiting = true ; new@@ Doc -> Apply@@ Mat@@ eri@@ al@@ Chang@@ es ( ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Re@@ doAdd@@ Mat@@ eri@@ al ( const char * name , bool clear@@ Data ) { Mat@@ eri@@ al@@ Doc * new@@ Doc = new Mat@@ eri@@ al@@ Doc ( ) ; new@@ Doc -> manager = this ; new@@ Doc -> modi@@ fied = true ; id@@ Mat@@ eri@@ al * ren@@ d@@ Mat = const_cast < id@@ Mat@@ eri@@ al * > ( decl@@ Manager -> Find@@ Mat@@ eri@@ al ( name , false ) ) ; if ( clear@@ Data ) { ren@@ d@@ Mat -> SetText ( ren@@ d@@ Mat -> Default@@ Definition ( ) ) ; } new@@ Doc -> Set@@ Render@@ Mat@@ eri@@ al ( ren@@ d@@ Mat , true , true ) ; in@@ Pro@@ gress@@ Mat@@ eri@@ als . Set ( new@@ Doc -> name . c_str ( ) , new@@ Doc ) ; Notify@@ Views ( new@@ Doc , MAT@@ ERI@@ AL_@@ ADD ) ; new@@ Doc -> apply@@ Waiting = true ; new@@ Doc -> Apply@@ Mat@@ eri@@ al@@ Chang@@ es ( ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Delete@@ Mat@@ eri@@ al ( Mat@@ eri@@ al@@ Doc * mat@@ eri@@ al , bool add@@ Undo ) { assert ( mat@@ eri@@ al ) ; mat@@ eri@@ al -> Delete ( ) ; if ( add@@ Undo ) { Delete@@ Mat@@ eri@@ al@@ Modifier * mod = new Delete@@ Mat@@ eri@@ al@@ Modifier ( this , mat@@ eri@@ al -> name ) ; Add@@ Mat@@ eri@@ al@@ Un@@ do@@ Modifier ( mod ) ; } Notify@@ Views ( mat@@ eri@@ al , MAT@@ ERI@@ AL_@@ DELE@@ TE ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Apply@@ Mat@@ eri@@ al ( Mat@@ eri@@ al@@ Doc * mat@@ eri@@ al@@ Doc ) { assert ( mat@@ eri@@ al@@ Doc ) ; mat@@ eri@@ al@@ Doc -> Apply@@ Mat@@ eri@@ al@@ Chang@@ es ( ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Apply@@ File ( const char * filename ) { for ( int i = 0 ; i < in@@ Pro@@ gress@@ Mat@@ eri@@ als . Num ( ) ; i ++ ) { Mat@@ eri@@ al@@ Doc * * pDoc = in@@ Pro@@ gress@@ Mat@@ eri@@ als . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> render@@ Mat@@ eri@@ al -> GetFileName ( ) , filename ) ) ( * pDoc ) -> Apply@@ Mat@@ eri@@ al@@ Chang@@ es ( ) ; } }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Apply@@ All ( ) { for ( int i = 0 ; i < in@@ Pro@@ gress@@ Mat@@ eri@@ als . Num ( ) ; i ++ ) { Mat@@ eri@@ al@@ Doc * * pDoc = in@@ Pro@@ gress@@ Mat@@ eri@@ als . GetIndex ( i ) ; ( * pDoc ) -> Apply@@ Mat@@ eri@@ al@@ Chang@@ es ( ) ; } }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Save@@ Mat@@ eri@@ al ( Mat@@ eri@@ al@@ Doc * mat@@ eri@@ al ) { assert ( mat@@ eri@@ al ) ; mat@@ eri@@ al -> Save ( ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Save@@ File ( const char * filename ) { for ( int i = in@@ Pro@@ gress@@ Mat@@ eri@@ als . Num ( ) - 1 ; i >= 0 ; i -- ) { Mat@@ eri@@ al@@ Doc * * pDoc = in@@ Pro@@ gress@@ Mat@@ eri@@ als . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> render@@ Mat@@ eri@@ al -> GetFileName ( ) , filename ) ) ( * pDoc ) -> Save ( ) ; } Notify@@ Views ( NULL , MAT@@ ERI@@ AL_@@ SAVE_@@ FILE , filename ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Save@@ All@@ Mat@@ eri@@ als ( ) { for ( int i = in@@ Pro@@ gress@@ Mat@@ eri@@ als . Num ( ) - 1 ; i >= 0 ; i -- ) { Mat@@ eri@@ al@@ Doc * * pDoc = in@@ Pro@@ gress@@ Mat@@ eri@@ als . GetIndex ( i ) ; ( * pDoc ) -> Save ( ) ; } }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Reload@@ File ( const char * filename ) { decl@@ Manager -> Reload@@ File ( filename , true ) ; for ( int j = in@@ Pro@@ gress@@ Mat@@ eri@@ als . Num ( ) - 1 ; j >= 0 ; j -- ) { Mat@@ eri@@ al@@ Doc * * pDoc = in@@ Pro@@ gress@@ Mat@@ eri@@ als . GetIndex ( j ) ; if ( ! strcmp ( ( * pDoc ) -> render@@ Mat@@ eri@@ al -> GetFileName ( ) , filename ) ) { ( * pDoc ) -> Set@@ Render@@ Mat@@ eri@@ al ( ( * pDoc ) -> render@@ Mat@@ eri@@ al ) ; in@@ Pro@@ gress@@ Mat@@ eri@@ als . Remove ( ( * pDoc ) -> name ) ; } } if ( current@@ Mat@@ eri@@ al ) { current@@ Mat@@ eri@@ al -> Set@@ Render@@ Mat@@ eri@@ al ( current@@ Mat@@ eri@@ al -> render@@ Mat@@ eri@@ al ) ; Notify@@ Views ( current@@ Mat@@ eri@@ al , SEL@@ ECTION_@@ CHANGE ) ; } Notify@@ Views ( NULL , FILE_@@ REL@@ O@@ AD , filename ) ; }
Mat@@ eri@@ al@@ Doc * Mat@@ eri@@ al@@ Doc@@ Manager :: Create@@ Mat@@ eri@@ al@@ Doc ( const char * mat@@ eri@@ al@@ Name ) { const id@@ Mat@@ eri@@ al * mat@@ eri@@ al = decl@@ Manager -> Find@@ Mat@@ eri@@ al ( mat@@ eri@@ al@@ Name ) ; return Create@@ Mat@@ eri@@ al@@ Doc ( const_cast < id@@ Mat@@ eri@@ al * > ( mat@@ eri@@ al ) ) ; }
Mat@@ eri@@ al@@ Doc * Mat@@ eri@@ al@@ Doc@@ Manager :: Create@@ Mat@@ eri@@ al@@ Doc ( id@@ Mat@@ eri@@ al * mat@@ eri@@ al ) { Mat@@ eri@@ al@@ Doc * exist@@ ing@@ Doc = Get@@ In@@ Pro@@ gress@@ Doc ( mat@@ eri@@ al ) ; if ( exist@@ ing@@ Doc ) { return exist@@ ing@@ Doc ; } if ( current@@ Mat@@ eri@@ al && mat@@ eri@@ al && ! current@@ Mat@@ eri@@ al -> name . I@@ cmp ( mat@@ eri@@ al -> GetName ( ) ) ) { return current@@ Mat@@ eri@@ al ; } if ( mat@@ eri@@ al ) { Mat@@ eri@@ al@@ Doc * new@@ Doc = new Mat@@ eri@@ al@@ Doc ( ) ; new@@ Doc -> manager = this ; new@@ Doc -> Set@@ Render@@ Mat@@ eri@@ al ( mat@@ eri@@ al ) ; return new@@ Doc ; } return NULL ; }
Mat@@ eri@@ al@@ Doc * Mat@@ eri@@ al@@ Doc@@ Manager :: Get@@ In@@ Pro@@ gress@@ Doc ( id@@ Mat@@ eri@@ al * mat@@ eri@@ al ) { if ( mat@@ eri@@ al ) { for ( int i = 0 ; i < in@@ Pro@@ gress@@ Mat@@ eri@@ als . Num ( ) ; i ++ ) { Mat@@ eri@@ al@@ Doc * * pDoc = in@@ Pro@@ gress@@ Mat@@ eri@@ als . GetIndex ( i ) ; if ( ! ( * pDoc ) -> name . I@@ cmp ( mat@@ eri@@ al -> GetName ( ) ) ) return * pDoc ; } } return NULL ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Copy@@ Mat@@ eri@@ al ( Mat@@ eri@@ al@@ Doc * mat@@ eri@@ al@@ Doc , bool cut ) { cut@@ Mat@@ eri@@ al = cut ; if ( mat@@ eri@@ al@@ Doc ) copy@@ Mat@@ eri@@ al = mat@@ eri@@ al@@ Doc -> name ; else Clear@@ Copy ( ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Clear@@ Copy ( ) { copy@@ Mat@@ eri@@ al . Empty ( ) ; }
bool Mat@@ eri@@ al@@ Doc@@ Manager :: Is@@ Copy@@ Mat@@ eri@@ al ( ) { return ( copy@@ Mat@@ eri@@ al . Length ( ) ) ? true : false ; }
id@@ Str Mat@@ eri@@ al@@ Doc@@ Manager :: Get@@ Copy@@ Mat@@ eri@@ al@@ Name ( ) { return copy@@ Mat@@ eri@@ al ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Pa@@ ste@@ Mat@@ eri@@ al ( const char * name , const char * filename ) { if ( ! Is@@ Copy@@ Mat@@ eri@@ al ( ) ) { return ; } Mat@@ eri@@ al@@ Doc * copy@@ Mat = Create@@ Mat@@ eri@@ al@@ Doc ( copy@@ Mat@@ eri@@ al ) ; if ( copy@@ Mat -> apply@@ Waiting ) { copy@@ Mat -> Apply@@ Mat@@ eri@@ al@@ Chang@@ es ( ) ; } id@@ Mat@@ eri@@ al * mat@@ eri@@ al = copy@@ Mat -> render@@ Mat@@ eri@@ al ; char * decl@@ Text = ( char * ) _@@ alloc@@ a ( mat@@ eri@@ al -> Get@@ Text@@ Length ( ) + 1 ) ; mat@@ eri@@ al -> GetText ( decl@@ Text ) ; Add@@ Mat@@ eri@@ al ( name , filename , decl@@ Text , ! cut@@ Mat@@ eri@@ al ) ; if ( cut@@ Mat@@ eri@@ al ) { Mat@@ eri@@ al@@ Doc * cut@@ Mat@@ eri@@ al = Create@@ Mat@@ eri@@ al@@ Doc ( mat@@ eri@@ al ) ; Delete@@ Mat@@ eri@@ al ( cut@@ Mat@@ eri@@ al , false ) ; Move@@ Mat@@ eri@@ al@@ Modifier * mod = new Move@@ Mat@@ eri@@ al@@ Modifier ( this , name , filename , copy@@ Mat@@ eri@@ al ) ; Add@@ Mat@@ eri@@ al@@ Un@@ do@@ Modifier ( mod ) ; Clear@@ Copy ( ) ; } }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Copy@@ St@@ age ( Mat@@ eri@@ al@@ Doc * mat@@ eri@@ al@@ Doc , int st@@ age@@ Num ) { assert ( mat@@ eri@@ al@@ Doc ) ; copy@@ St@@ age@@ Mat@@ eri@@ al = mat@@ eri@@ al@@ Doc -> name ; copy@@ St@@ age = mat@@ eri@@ al@@ Doc -> Get@@ St@@ age ( st@@ age@@ Num ) ; id@@ Str st@@ ageName = copy@@ St@@ age . st@@ age@@ Data . GetString ( " name " ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Clear@@ Copy@@ St@@ age ( ) { copy@@ St@@ age@@ Mat@@ eri@@ al . Empty ( ) ; copy@@ St@@ age . st@@ age@@ Data . Clear ( ) ; }
bool Mat@@ eri@@ al@@ Doc@@ Manager :: Is@@ Copy@@ St@@ age ( ) { return ( copy@@ St@@ age@@ Mat@@ eri@@ al . Length ( ) ) ? true : false ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Pa@@ ste@@ St@@ age ( Mat@@ eri@@ al@@ Doc * mat@@ eri@@ al@@ Doc ) { assert ( mat@@ eri@@ al@@ Doc ) ; int st@@ age@@ Type = copy@@ St@@ age . st@@ age@@ Data . GetInt ( " st@@ a@@ get@@ ype " ) ; mat@@ eri@@ al@@ Doc -> Add@@ St@@ age ( st@@ age@@ Type , copy@@ St@@ age . st@@ age@@ Data . GetString ( " name " ) ) ; mat@@ eri@@ al@@ Doc -> SetData ( mat@@ eri@@ al@@ Doc -> Get@@ St@@ age@@ Count ( ) - 1 , & copy@@ St@@ age . st@@ age@@ Data ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Get@@ Copy@@ St@@ age@@ Info ( int & type , id@@ Str & name ) { if ( Is@@ Copy@@ St@@ age ( ) ) { type = copy@@ St@@ age . st@@ age@@ Data . GetInt ( " st@@ a@@ get@@ ype " ) ; name = copy@@ St@@ age . st@@ age@@ Data . GetString ( " name " ) ; } }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Undo ( ) { if ( Is@@ Un@@ do@@ Available ( ) ) { Mat@@ eri@@ al@@ Modifier * mod = un@@ do@@ Modifiers [ un@@ do@@ Modifiers . Num ( ) - 1 ] ; un@@ do@@ Modifiers . Remove@@ Index ( un@@ do@@ Modifiers . Num ( ) - 1 ) ; mod -> Undo ( ) ; Add@@ Mat@@ eri@@ al@@ Re@@ do@@ Modifier ( mod ) ; } }
bool Mat@@ eri@@ al@@ Doc@@ Manager :: Is@@ Un@@ do@@ Available ( ) { return ( un@@ do@@ Modifiers . Num ( ) > 0 ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Clear@@ Undo ( ) { int c = un@@ do@@ Modifiers . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { delete un@@ do@@ Modifiers [ i ] ; } un@@ do@@ Modifiers . Clear ( ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Redo ( ) { if ( Is@@ Re@@ do@@ Available ( ) ) { Mat@@ eri@@ al@@ Modifier * mod = re@@ do@@ Modifiers [ re@@ do@@ Modifiers . Num ( ) - 1 ] ; re@@ do@@ Modifiers . Remove@@ Index ( re@@ do@@ Modifiers . Num ( ) - 1 ) ; mod -> Redo ( ) ; Add@@ Mat@@ eri@@ al@@ Un@@ do@@ Modifier ( mod , false ) ; } }
bool Mat@@ eri@@ al@@ Doc@@ Manager :: Is@@ Re@@ do@@ Available ( ) { return ( re@@ do@@ Modifiers . Num ( ) > 0 ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Clear@@ Redo ( ) { int c = re@@ do@@ Modifiers . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { delete re@@ do@@ Modifiers [ i ] ; } re@@ do@@ Modifiers . Clear ( ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Add@@ Mat@@ eri@@ al@@ Un@@ do@@ Modifier ( Mat@@ eri@@ al@@ Modifier * mod , bool clear@@ Redo ) { un@@ do@@ Modifiers . Append ( mod ) ; while ( un@@ do@@ Modifiers . Num ( ) > MAX_@@ UN@@ DO@@ RED@@ O ) { un@@ do@@ Modifiers . Remove@@ Index ( 0 ) ; } if ( clear@@ Redo ) { Clear@@ Redo ( ) ; } }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Add@@ Mat@@ eri@@ al@@ Re@@ do@@ Modifier ( Mat@@ eri@@ al@@ Modifier * mod ) { re@@ do@@ Modifiers . Append ( mod ) ; while ( re@@ do@@ Modifiers . Num ( ) > MAX_@@ UN@@ DO@@ RED@@ O ) { re@@ do@@ Modifiers . Remove@@ Index ( 0 ) ; } }
bool Mat@@ eri@@ al@@ Doc@@ Manager :: Find@@ Mat@@ eri@@ al ( const char * name , Mat@@ eri@@ al@@ Search@@ Data@@ _t * search@@ Data , bool check@@ Name ) { const id@@ Mat@@ eri@@ al * mat@@ eri@@ al = static_cast < const id@@ Mat@@ eri@@ al * > ( decl@@ Manager -> Find@@ Dec@@ l@@ Without@@ Parsing ( DEC@@ L_@@ MAT@@ ERI@@ AL , name , false ) ) ; if ( mat@@ eri@@ al ) { int find@@ Pos ; if ( check@@ Name ) { id@@ Str name = mat@@ eri@@ al -> GetName ( ) ; find@@ Pos = name . Find ( search@@ Data -> search@@ Text , false ) ; if ( find@@ Pos != - 1 ) { return true ; } } char * decl@@ Text = ( char * ) _@@ alloc@@ a ( mat@@ eri@@ al -> Get@@ Text@@ Length ( ) + 1 ) ; mat@@ eri@@ al -> GetText ( decl@@ Text ) ; id@@ Str text = decl@@ Text ; int start = text . Find ( " { " ) ; if ( start != - 1 ) { text = text . Right ( text . Length ( ) - start ) ; } find@@ Pos = text . Find ( search@@ Data -> search@@ Text , false ) ; if ( find@@ Pos != - 1 ) { return true ; } } return false ; }
id@@ Str Mat@@ eri@@ al@@ Doc@@ Manager :: Get@@ Unique@@ Mat@@ eri@@ al@@ Name ( id@@ Str name ) { int num = 0 ; while ( 1 ) { id@@ Str testName ; if ( num == 0 ) testName = name ; else testName = v@@ a ( " % s % d " , name . c_str ( ) , num ) ; const id@@ Mat@@ eri@@ al * mat = decl@@ Manager -> Find@@ Mat@@ eri@@ al ( testName . c_str ( ) , false ) ; if ( ! mat ) { return testName ; } else { if ( mat -> Get@@ Text@@ Length ( ) < 1 ) return testName ; } num ++ ; } }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Notify@@ Views ( Mat@@ eri@@ al@@ Doc * mat@@ eri@@ al@@ Doc , int notify@@ Type , ... ) { va_list arg@@ ptr ; int c = mat@@ eri@@ al@@ Views . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { va_start ( arg@@ ptr , notify@@ Type ) ; switch ( notify@@ Type ) { case SEL@@ ECTION_@@ CHANGE : mat@@ eri@@ al@@ Views [ i ] -> M@@ V_@@ On@@ Mat@@ eri@@ al@@ Selection@@ Change ( mat@@ eri@@ al@@ Doc ) ; break ; case MAT@@ ERI@@ AL_@@ CHANGE : mat@@ eri@@ al@@ Views [ i ] -> M@@ V_@@ On@@ Mat@@ eri@@ al@@ Change ( mat@@ eri@@ al@@ Doc ) ; break ; case MAT@@ ERI@@ AL_@@ AP@@ PL@@ Y : mat@@ eri@@ al@@ Views [ i ] -> M@@ V_@@ On@@ Mat@@ eri@@ al@@ Apply ( mat@@ eri@@ al@@ Doc ) ; break ; case MAT@@ ERI@@ AL_@@ SA@@ VE : mat@@ eri@@ al@@ Views [ i ] -> M@@ V_@@ On@@ Mat@@ eri@@ alS@@ aved ( mat@@ eri@@ al@@ Doc ) ; break ; case MAT@@ ERI@@ AL_@@ SAVE_@@ FILE : mat@@ eri@@ al@@ Views [ i ] -> M@@ V_@@ On@@ Mat@@ eri@@ al@@ Save@@ File ( va_@@ arg ( arg@@ ptr , const char * ) ) ; break ; case MAT@@ ERI@@ AL_@@ ADD : mat@@ eri@@ al@@ Views [ i ] -> M@@ V_@@ On@@ Mat@@ eri@@ al@@ Add ( mat@@ eri@@ al@@ Doc ) ; break ; case MAT@@ ERI@@ AL_@@ DELE@@ TE : mat@@ eri@@ al@@ Views [ i ] -> M@@ V_@@ On@@ Mat@@ eri@@ al@@ Delete ( mat@@ eri@@ al@@ Doc ) ; break ; case MAT@@ ERI@@ AL_@@ ADD@@ _ST@@ AGE : mat@@ eri@@ al@@ Views [ i ] -> M@@ V_@@ On@@ Mat@@ eri@@ al@@ St@@ age@@ Add ( mat@@ eri@@ al@@ Doc , va_@@ arg ( arg@@ ptr , int ) ) ; break ; case MAT@@ ERI@@ AL_@@ DELETE_@@ ST@@ AGE : mat@@ eri@@ al@@ Views [ i ] -> M@@ V_@@ On@@ Mat@@ eri@@ al@@ St@@ age@@ Delete ( mat@@ eri@@ al@@ Doc , va_@@ arg ( arg@@ ptr , int ) ) ; break ; case MAT@@ ERI@@ AL_@@ MOVE_@@ ST@@ AGE : { int from = va_@@ arg ( arg@@ ptr , int ) ; int to = va_@@ arg ( arg@@ ptr , int ) ; mat@@ eri@@ al@@ Views [ i ] -> M@@ V_@@ On@@ Mat@@ eri@@ al@@ St@@ age@@ Move ( mat@@ eri@@ al@@ Doc , from , to ) ; } break ; case MAT@@ ERI@@ AL_@@ ATTRIBU@@ TE_@@ CHANGE : { int st@@ age = va_@@ arg ( arg@@ ptr , int ) ; const char * attri@@ b@@ Name = va_@@ arg ( arg@@ ptr , const char * ) ; mat@@ eri@@ al@@ Views [ i ] -> M@@ V_@@ On@@ Mat@@ eri@@ al@@ Attribute@@ Changed ( mat@@ eri@@ al@@ Doc , st@@ age , attri@@ b@@ Name ) ; } break ; case MAT@@ ERI@@ AL_@@ NAME_@@ CHANGE : { const char * old@@ Name = va_@@ arg ( arg@@ ptr , const char * ) ; mat@@ eri@@ al@@ Views [ i ] -> M@@ V_@@ On@@ Mat@@ eri@@ al@@ Name@@ Changed ( mat@@ eri@@ al@@ Doc , old@@ Name ) ; } break ; case FILE_@@ REL@@ O@@ AD : { const char * filename = va_@@ arg ( arg@@ ptr , const char * ) ; mat@@ eri@@ al@@ Views [ i ] -> M@@ V_@@ On@@ File@@ Re@@ load ( filename ) ; } break ; } va_end ( arg@@ ptr ) ; } }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Mat@@ eri@@ al@@ Changed ( Mat@@ eri@@ al@@ Doc * mat@@ eri@@ al@@ Doc ) { if ( ! in@@ Pro@@ gress@@ Mat@@ eri@@ als . Get ( mat@@ eri@@ al@@ Doc -> name . c_str ( ) ) ) { in@@ Pro@@ gress@@ Mat@@ eri@@ als . Set ( mat@@ eri@@ al@@ Doc -> name . c_str ( ) , mat@@ eri@@ al@@ Doc ) ; } Notify@@ Views ( mat@@ eri@@ al@@ Doc , MAT@@ ERI@@ AL_@@ CHANGE ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Mat@@ eri@@ al@@ App@@ lied ( Mat@@ eri@@ al@@ Doc * mat@@ eri@@ al@@ Doc ) { Notify@@ Views ( mat@@ eri@@ al@@ Doc , MAT@@ ERI@@ AL_@@ AP@@ PL@@ Y ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Mat@@ eri@@ alS@@ aved ( Mat@@ eri@@ al@@ Doc * mat@@ eri@@ al@@ Doc ) { Mat@@ eri@@ al@@ Doc * * temp@@ Doc ; if ( in@@ Pro@@ gress@@ Mat@@ eri@@ als . Get ( mat@@ eri@@ al@@ Doc -> name . c_str ( ) , & temp@@ Doc ) ) { id@@ Str name = mat@@ eri@@ al@@ Doc -> name . c_str ( ) ; in@@ Pro@@ gress@@ Mat@@ eri@@ als . Remove ( name . c_str ( ) ) ; Notify@@ Views ( mat@@ eri@@ al@@ Doc , MAT@@ ERI@@ AL_@@ SA@@ VE ) ; if ( mat@@ eri@@ al@@ Doc != current@@ Mat@@ eri@@ al ) delete mat@@ eri@@ al@@ Doc ; } }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Mat@@ eri@@ al@@ Name@@ Changed ( const char * old@@ Name , Mat@@ eri@@ al@@ Doc * mat@@ eri@@ al@@ Doc ) { Mat@@ eri@@ al@@ Doc * * temp@@ Doc ; if ( in@@ Pro@@ gress@@ Mat@@ eri@@ als . Get ( old@@ Name , & temp@@ Doc ) ) { in@@ Pro@@ gress@@ Mat@@ eri@@ als . Set ( mat@@ eri@@ al@@ Doc -> name , * temp@@ Doc ) ; in@@ Pro@@ gress@@ Mat@@ eri@@ als . Remove ( old@@ Name ) ; } Notify@@ Views ( mat@@ eri@@ al@@ Doc , MAT@@ ERI@@ AL_@@ NAME_@@ CHANGE , old@@ Name ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: St@@ age@@ Added ( Mat@@ eri@@ al@@ Doc * mat@@ eri@@ al@@ Doc , int st@@ age@@ Num ) { Notify@@ Views ( mat@@ eri@@ al@@ Doc , MAT@@ ERI@@ AL_@@ ADD@@ _ST@@ AGE , st@@ age@@ Num ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: St@@ age@@ Deleted ( Mat@@ eri@@ al@@ Doc * mat@@ eri@@ al@@ Doc , int st@@ age@@ Num ) { Notify@@ Views ( mat@@ eri@@ al@@ Doc , MAT@@ ERI@@ AL_@@ DELETE_@@ ST@@ AGE , st@@ age@@ Num ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: St@@ age@@ Moved ( Mat@@ eri@@ al@@ Doc * mat@@ eri@@ al@@ Doc , int from , int to ) { Notify@@ Views ( mat@@ eri@@ al@@ Doc , MAT@@ ERI@@ AL_@@ MOVE_@@ ST@@ AGE , from , to ) ; }
void Mat@@ eri@@ al@@ Doc@@ Manager :: Attribute@@ Changed ( Mat@@ eri@@ al@@ Doc * mat@@ eri@@ al@@ Doc , int st@@ age , const char * attri@@ b@@ Name ) { Notify@@ Views ( mat@@ eri@@ al@@ Doc , MAT@@ ERI@@ AL_@@ ATTRIBU@@ TE_@@ CHANGE , st@@ age , attri@@ b@@ Name ) ; }
