<DOCUMENT_ID="afoksha/OpenGL/tree/master/demos/100_Player/player_5.cpp"> # include < iostream > # include < string > # include < thread > # include < mutex > # include < condition_variable > std :: mutex m ; std :: condition_variable cv ; std :: string data ; bool ready = false ; bool processed = false ; void worker_thread ( ) { std :: unique_lock < std :: mutex > lk ( m ) ; cv . wait ( lk , [ ] { return ready ; } ) ; std :: cout << " Worker ▁ thread ▁ is ▁ processing ▁ data \n " ; data += " ▁ after ▁ processing " ; processed = true ; std :: cout << " Worker ▁ thread ▁ signals ▁ data ▁ processing ▁ completed \n " ; lk . unlock ( ) ; cv . notify_one ( ) ; } int main ( int argc , char * argv [ ] ) { std :: thread worker ( worker_thread ) ; data = " Example ▁ data " ; { std :: lock_guard < std :: mutex > lk ( m ) ; ready = true ; std :: cout << " main ( ) ▁ signals ▁ data ▁ ready ▁ for ▁ processing \n " ; } cv . notify_one ( ) ; { std :: unique_lock < std :: mutex > lk ( m ) ; cv . wait ( lk , [ ] { return processed ; } ) ; } std :: cout << " Back ▁ in ▁ main ( ) , ▁ data ▁ = ▁ " << data << ' \n ' ; worker . join ( ) ; } </DOCUMENT>
<DOCUMENT_ID="rexim/beatwave/tree/master/test/core/testanimated.cpp"> # define CATCH_CONFIG_MAIN # include < catch . hpp > # include < core / animated . hpp > TEST_CASE ( " Animating ▁ object ▁ with ▁ nullptr ▁ should ▁ not ▁ crash ▁ the ▁ app " , " [ animated ] " ) { Animated < int > x ( 10 ) ; x . animate ( nullptr ) ; } </DOCUMENT>
<DOCUMENT_ID="bombehub/PPR_PPV/tree/master/Snap-3.0/snap-exp/test-dev/ExplicitStringTableTest2.cpp"> # include " Snap . h " # include < cstring > # include " BenchmarkUtilities . h " int main ( int argc , char * * argv ) { TBool debug = false ; TStr TagsFnm = " / lfs / madmax4/0 / yonathan / tags " ; if ( debug ) { TagsFnm = " / lfs / madmax4/0 / yonathan / tags _ small " ; } Schema TagS ; TagS . Add ( TPair < TStr , TAttrType > ( " UserId " , atInt ) ) ; TagS . Add ( TPair < TStr , TAttrType > ( " Tag " , atStr ) ) ; float ft_max ; float mu_max ; timeval timer4 ; gettimeofday ( & timer4 , NULL ) ; double t1 = timer4 . tv_sec + ( timer4 . tv_usec / 1000000.0 ) ; PExplicitStringTable ES_Tags = ExplicitStringTable :: LoadSS ( TagS , TagsFnm + " . tsv " ) ; gettimeofday ( & timer4 , NULL ) ; double t2 = timer4 . tv_sec + ( timer4 . tv_usec / 1000000.0 ) ; printf ( " Time ▁ to ▁ load ▁ tags ▁ table : ▁ % f \n " , t2 - t1 ) ; printf ( " Table ▁ Size : \n " ) ; ES_Tags -> PrintSize ( ) ; getmaxcpumem ( & ft_max , & mu_max ) ; printf ( " time : ▁ % 0.3f ▁ seconds , ▁ memory : ▁ % 0.3f ▁ MB \n " , ft_max , mu_max ) ; printf ( " \n " ) ; timeval timer6 ; gettimeofday ( & timer6 , NULL ) ; t1 = timer6 . tv_sec + ( timer6 . tv_usec / 1000000.0 ) ; PExplicitStringTable ES_TagsJoinUser = ES_Tags -> SelfJoin ( " UserId " ) ; gettimeofday ( & timer6 , NULL ) ; t2 = timer6 . tv_sec + ( timer6 . tv_usec / 1000000.0 ) ; printf ( " Time ▁ to ▁ join ▁ on ▁ user ▁ id ▁ column : ▁ % f \n " , t2 - t1 ) ; printf ( " Table ▁ Size : \n " ) ; ES_TagsJoinUser -> PrintSize ( ) ; if ( debug ) { ES_TagsJoinUser -> SaveSS ( TagsFnm + " _ join _ user _ es . tsv " ) ; } getmaxcpumem ( & ft_max , & mu_max ) ; printf ( " time : ▁ % 0.3f ▁ seconds , ▁ memory : ▁ % 0.3f ▁ MB \n " , ft_max , mu_max ) ; printf ( " \n " ) ; timeval timer7 ; gettimeofday ( & timer7 , NULL ) ; t1 = timer7 . tv_sec + ( timer7 . tv_usec / 1000000.0 ) ; PExplicitStringTable ES_JavaTags = ExplicitStringTable :: New ( TagS ) ; TIntV SelectedRows1 ; if ( debug ) { ES_Tags -> SelectAtomicConst ( TStr ( " Tag " ) , TStr ( " c # " ) , EQ , SelectedRows1 , ES_JavaTags , false , true ) ; } else { ES_Tags -> SelectAtomicConst ( TStr ( " Tag " ) , TStr ( " java " ) , EQ , SelectedRows1 , ES_JavaTags , false , true ) ; } gettimeofday ( & timer7 , NULL ) ; t2 = timer7 . tv_sec + ( timer7 . tv_usec / 1000000.0 ) ; printf ( " Time ▁ to ▁ select ▁ java ▁ users : ▁ % f \n " , t2 - t1 ) ; printf ( " Table ▁ Size : \n " ) ; ES_JavaTags -> PrintSize ( ) ; if ( debug ) { ES_JavaTags -> SaveSS ( TagsFnm + " _ select _ es . tsv " ) ; } getmaxcpumem ( & ft_max , & mu_max ) ; printf ( " time : ▁ % 0.3f ▁ seconds , ▁ memory : ▁ % 0.3f ▁ MB \n " , ft_max , mu_max ) ; printf ( " \n " ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="mgsergio/omim/tree/master/base/osm_id.cpp"> # include " base / osm _ id . hpp " # include " base / assert . hpp " # include < sstream > namespace osm { static const uint64_t NODE = 0x4000000000000000ULL ; static const uint64_t WAY = 0x8000000000000000ULL ; static const uint64_t RELATION = 0xC000000000000000ULL ; static const uint64_t RESET = ~ ( NODE | WAY | RELATION ) ; Id :: Id ( uint64_t encodedId ) : m_encodedId ( encodedId ) { } Id Id :: Node ( uint64_t id ) { return Id ( id | NODE ) ; } Id Id :: Way ( uint64_t id ) { return Id ( id | WAY ) ; } Id Id :: Relation ( uint64_t id ) { return Id ( id | RELATION ) ; } uint64_t Id :: OsmId ( ) const { return m_encodedId & RESET ; } uint64_t Id :: EncodedId ( ) const { return m_encodedId ; } bool Id :: IsNode ( ) const { return ( ( m_encodedId & NODE ) == NODE ) ; } bool Id :: IsWay ( ) const { return ( ( m_encodedId & WAY ) == WAY ) ; } bool Id :: IsRelation ( ) const { return ( ( m_encodedId & RELATION ) == RELATION ) ; } std :: string Id :: Type ( ) const { if ( ( m_encodedId & RELATION ) == RELATION ) return " relation " ; else if ( ( m_encodedId & NODE ) == NODE ) return " node " ; else if ( ( m_encodedId & WAY ) == WAY ) return " way " ; else return " ERROR : ▁ Not ▁ initialized ▁ Osm ▁ ID " ; } std :: string DebugPrint ( osm :: Id const & id ) { std :: ostringstream stream ; stream << id . Type ( ) << " ▁ " << id . OsmId ( ) ; return stream . str ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="nextgis/NextGIS_QGIS_open/tree/master/src/gui/qgsfieldvalidator.cpp"> # include " qgsfieldvalidator . h " # include < QValidator > # include < QRegExpValidator > # include < QDate > # include < QVariant > # include < QSettings > # include " qgslogger . h " # include " qgslonglongvalidator . h " # include " qgsfield . h " QgsFieldValidator :: QgsFieldValidator ( QObject * parent , const QgsField & field , QString dateFormat ) : QValidator ( parent ) , mField ( field ) , mDateFormat ( dateFormat ) { switch ( mField . type ( ) ) { case QVariant :: Int : { if ( mField . length ( ) > 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } " ) . arg ( mField . length ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else { mValidator = new QIntValidator ( parent ) ; } } break ; case QVariant :: Double : { if ( mField . length ( ) > 0 && mField . precision ( ) > 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } ( \\ . \\d { 0 , % 2 } ) ? " ) . arg ( mField . length ( ) - mField . precision ( ) ) . arg ( mField . precision ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else if ( mField . length ( ) > 0 && mField . precision ( ) == 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } " ) . arg ( mField . length ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else if ( mField . precision ( ) > 0 ) { QString re = QString ( " - ? \\d * ( \\ . \\d { 0 , % 1 } ) ? " ) . arg ( mField . precision ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else { mValidator = new QDoubleValidator ( parent ) ; } } break ; case QVariant :: LongLong : mValidator = new QgsLongLongValidator ( parent ) ; break ; default : mValidator = 0 ; } QSettings settings ; mNullValue = settings . value ( " qgis / nullValue " , " NULL " ) . toString ( ) ; } QgsFieldValidator :: ~ QgsFieldValidator ( ) { delete mValidator ; } QValidator :: State QgsFieldValidator :: validate ( QString & s , int & i ) const { if ( s . isEmpty ( ) && ( mField . type ( ) == QVariant :: Double || mField . type ( ) == QVariant :: Int || mField . type ( ) == QVariant :: LongLong || mField . type ( ) == QVariant :: Date ) ) { return Acceptable ; } if ( mValidator ) { QValidator :: State result = mValidator -> validate ( s , i ) ; return result ; } else if ( mField . type ( ) == QVariant :: String ) { if ( mNullValue . size ( ) > 0 && s . size ( ) > 0 && s . size ( ) < mNullValue . size ( ) && s == mNullValue . left ( s . size ( ) ) ) return Intermediate ; if ( s == mNullValue ) return Acceptable ; if ( mField . length ( ) > 0 && s . size ( ) > mField . length ( ) ) return Invalid ; } else if ( mField . type ( ) == QVariant :: Date ) { return QDate :: fromString ( s , mDateFormat ) . isValid ( ) ? Acceptable : Intermediate ; } else { QgsDebugMsg ( QString ( " unsupported ▁ type ▁ % 1 ▁ for ▁ validation " ) . arg ( mField . type ( ) ) ) ; return Invalid ; } return Acceptable ; } void QgsFieldValidator :: fixup ( QString & s ) const { if ( mValidator ) { mValidator -> fixup ( s ) ; } else if ( mField . type ( ) == QVariant :: String && mField . length ( ) > 0 && s . size ( ) > mField . length ( ) ) { s = mNullValue ; } else if ( mField . type ( ) == QVariant :: Date ) { s = " " ; } } </DOCUMENT>
<DOCUMENT_ID="relipse/onethfour-chess-client/tree/master/src/quazip/JlCompress.cpp"> # include " JlCompress . h " # include < QDebug > static bool copyData ( QIODevice & inFile , QIODevice & outFile ) { while ( ! inFile . atEnd ( ) ) { char buf [ 4096 ] ; qint64 readLen = inFile . read ( buf , 4096 ) ; if ( readLen <= 0 ) return false ; if ( outFile . write ( buf , readLen ) != readLen ) return false ; } return true ; } bool JlCompress :: compressFile ( QuaZip * zip , QString fileName , QString fileDest ) { if ( ! zip ) return false ; if ( zip -> getMode ( ) != QuaZip :: mdCreate && zip -> getMode ( ) != QuaZip :: mdAppend && zip -> getMode ( ) != QuaZip :: mdAdd ) return false ; QFile inFile ; inFile . setFileName ( fileName ) ; if ( ! inFile . open ( QIODevice :: ReadOnly ) ) return false ; QuaZipFile outFile ( zip ) ; if ( ! outFile . open ( QIODevice :: WriteOnly , QuaZipNewInfo ( fileDest , inFile . fileName ( ) ) ) ) return false ; if ( ! copyData ( inFile , outFile ) || outFile . getZipError ( ) != UNZ_OK ) { return false ; } outFile . close ( ) ; if ( outFile . getZipError ( ) != UNZ_OK ) return false ; inFile . close ( ) ; return true ; } bool JlCompress :: compressSubDir ( QuaZip * zip , QString dir , QString origDir , bool recursive ) { if ( ! zip ) return false ; if ( zip -> getMode ( ) != QuaZip :: mdCreate && zip -> getMode ( ) != QuaZip :: mdAppend && zip -> getMode ( ) != QuaZip :: mdAdd ) return false ; QDir directory ( dir ) ; if ( ! directory . exists ( ) ) return false ; if ( recursive ) { QFileInfoList files = directory . entryInfoList ( QDir :: AllDirs | QDir :: NoDotAndDotDot ) ; Q_FOREACH ( QFileInfo file , files ) { if ( ! compressSubDir ( zip , file . absoluteFilePath ( ) , origDir , recursive ) ) return false ; } } QFileInfoList files = directory . entryInfoList ( QDir :: Files ) ; QDir origDirectory ( origDir ) ; Q_FOREACH ( QFileInfo file , files ) { if ( ! file . isFile ( ) || file . absoluteFilePath ( ) == zip -> getZipName ( ) ) continue ; QString filename = origDirectory . relativeFilePath ( file . absoluteFilePath ( ) ) ; if ( ! compressFile ( zip , file . absoluteFilePath ( ) , filename ) ) return false ; } return true ; } bool JlCompress :: extractFile ( QuaZip * zip , QString fileName , QString fileDest ) { if ( ! zip ) return false ; if ( zip -> getMode ( ) != QuaZip :: mdUnzip ) return false ; if ( ! fileName . isEmpty ( ) ) zip -> setCurrentFile ( fileName ) ; QuaZipFile inFile ( zip ) ; if ( ! inFile . open ( QIODevice :: ReadOnly ) || inFile . getZipError ( ) != UNZ_OK ) return false ; QDir curDir ; if ( ! curDir . mkpath ( QFileInfo ( fileDest ) . absolutePath ( ) ) ) { return false ; } if ( QFileInfo ( fileDest ) . isDir ( ) ) return true ; QFile outFile ; outFile . setFileName ( fileDest ) ; if ( ! outFile . open ( QIODevice :: WriteOnly ) ) return false ; if ( ! copyData ( inFile , outFile ) || inFile . getZipError ( ) != UNZ_OK ) { outFile . close ( ) ; removeFile ( QStringList ( fileDest ) ) ; return false ; } outFile . close ( ) ; inFile . close ( ) ; if ( inFile . getZipError ( ) != UNZ_OK ) { removeFile ( QStringList ( fileDest ) ) ; return false ; } return true ; } bool JlCompress :: removeFile ( QStringList listFile ) { bool ret = true ; for ( int i = 0 ; i < listFile . count ( ) ; i ++ ) { ret = ret && QFile :: remove ( listFile . at ( i ) ) ; } return ret ; } bool JlCompress :: compressFile ( QString fileCompressed , QString file ) { QuaZip zip ( fileCompressed ) ; QDir ( ) . mkpath ( QFileInfo ( fileCompressed ) . absolutePath ( ) ) ; if ( ! zip . open ( QuaZip :: mdCreate ) ) { QFile :: remove ( fileCompressed ) ; return false ; } if ( ! compressFile ( & zip , file , QFileInfo ( file ) . fileName ( ) ) ) { QFile :: remove ( fileCompressed ) ; return false ; } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { QFile :: remove ( fileCompressed ) ; return false ; } return true ; } bool JlCompress :: compressFiles ( QString fileCompressed , QStringList files ) { QuaZip zip ( fileCompressed ) ; QDir ( ) . mkpath ( QFileInfo ( fileCompressed ) . absolutePath ( ) ) ; if ( ! zip . open ( QuaZip :: mdCreate ) ) { QFile :: remove ( fileCompressed ) ; return false ; } QFileInfo info ; Q_FOREACH ( QString file , files ) { info . setFile ( file ) ; if ( ! info . exists ( ) || ! compressFile ( & zip , file , info . fileName ( ) ) ) { QFile :: remove ( fileCompressed ) ; return false ; } } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { QFile :: remove ( fileCompressed ) ; return false ; } return true ; } bool JlCompress :: compressDir ( QString fileCompressed , QString dir , bool recursive ) { QuaZip zip ( fileCompressed ) ; QDir ( ) . mkpath ( QFileInfo ( fileCompressed ) . absolutePath ( ) ) ; if ( ! zip . open ( QuaZip :: mdCreate ) ) { QFile :: remove ( fileCompressed ) ; return false ; } if ( ! compressSubDir ( & zip , dir , dir , recursive ) ) { QFile :: remove ( fileCompressed ) ; return false ; } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { QFile :: remove ( fileCompressed ) ; return false ; } return true ; } QString JlCompress :: extractFile ( QString fileCompressed , QString fileName , QString fileDest ) { QuaZip zip ( fileCompressed ) ; if ( ! zip . open ( QuaZip :: mdUnzip ) ) { return QString ( ) ; } if ( fileDest . isEmpty ( ) ) fileDest = fileName ; if ( ! extractFile ( & zip , fileName , fileDest ) ) { return QString ( ) ; } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { removeFile ( QStringList ( fileDest ) ) ; return QString ( ) ; } return QFileInfo ( fileDest ) . absoluteFilePath ( ) ; } QStringList JlCompress :: extractFiles ( QString fileCompressed , QStringList files , QString dir ) { QuaZip zip ( fileCompressed ) ; if ( ! zip . open ( QuaZip :: mdUnzip ) ) { return QStringList ( ) ; } QStringList extracted ; for ( int i = 0 ; i < files . count ( ) ; i ++ ) { QString absPath = QDir ( dir ) . absoluteFilePath ( files . at ( i ) ) ; if ( ! extractFile ( & zip , files . at ( i ) , absPath ) ) { removeFile ( extracted ) ; return QStringList ( ) ; } extracted . append ( absPath ) ; } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { removeFile ( extracted ) ; return QStringList ( ) ; } return extracted ; } QStringList JlCompress :: extractDir ( QString fileCompressed , QString dir ) { QuaZip zip ( fileCompressed ) ; if ( ! zip . open ( QuaZip :: mdUnzip ) ) { return QStringList ( ) ; } QDir directory ( dir ) ; QStringList extracted ; if ( ! zip . goToFirstFile ( ) ) { return QStringList ( ) ; } do { QString name = zip . getCurrentFileName ( ) ; QString absFilePath = directory . absoluteFilePath ( name ) ; if ( ! extractFile ( & zip , " " , absFilePath ) ) { removeFile ( extracted ) ; return QStringList ( ) ; } extracted . append ( absFilePath ) ; } while ( zip . goToNextFile ( ) ) ; zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { removeFile ( extracted ) ; return QStringList ( ) ; } return extracted ; } QStringList JlCompress :: getFileList ( QString fileCompressed ) { QuaZip * zip = new QuaZip ( QFileInfo ( fileCompressed ) . absoluteFilePath ( ) ) ; if ( ! zip -> open ( QuaZip :: mdUnzip ) ) { delete zip ; return QStringList ( ) ; } QStringList lst ; QuaZipFileInfo info ; for ( bool more = zip -> goToFirstFile ( ) ; more ; more = zip -> goToNextFile ( ) ) { if ( ! zip -> getCurrentFileInfo ( & info ) ) { delete zip ; return QStringList ( ) ; } lst << info . name ; } zip -> close ( ) ; if ( zip -> getZipError ( ) != 0 ) { delete zip ; return QStringList ( ) ; } delete zip ; return lst ; } </DOCUMENT>
<DOCUMENT_ID="ElvishArtisan/rivendell/tree/master/ripcd/btsrc8iii.cpp"> # include < stdlib . h > # include < qtimer . h > # include < rdapplication . h > # include " btsrc8iii . h " # include " globals . h " BtSrc8Iii :: BtSrc8Iii ( RDMatrix * matrix , QObject * parent ) : Switcher ( matrix , parent ) { bt_istate = 0 ; for ( int i = 0 ; i < BTSRC8III_GPIO_PINS ; i ++ ) { bt_gpi_state [ i ] = false ; bt_gpi_mask [ i ] = false ; } bt_matrix = matrix -> matrix ( ) ; bt_gpis = matrix -> gpis ( ) ; bt_gpos = matrix -> gpos ( ) ; RDTty * tty = new RDTty ( rda -> station ( ) -> name ( ) , matrix -> port ( RDMatrix :: Primary ) ) ; bt_device = new RDTTYDevice ( ) ; if ( tty -> active ( ) ) { bt_device -> setName ( tty -> port ( ) ) ; bt_device -> setSpeed ( tty -> baudRate ( ) ) ; bt_device -> setWordLength ( tty -> dataBits ( ) ) ; bt_device -> setParity ( tty -> parity ( ) ) ; bt_device -> open ( QIODevice :: Unbuffered | QIODevice :: ReadWrite ) ; } delete tty ; bt_gpi_oneshot = new RDOneShot ( this ) ; connect ( bt_gpi_oneshot , SIGNAL ( timeout ( int ) ) , this , SLOT ( gpiOneshotData ( int ) ) ) ; bt_gpo_oneshot = new RDOneShot ( this ) ; connect ( bt_gpo_oneshot , SIGNAL ( timeout ( int ) ) , this , SLOT ( gpoOneshotData ( int ) ) ) ; QTimer * timer = new QTimer ( this , " poll _ timer " ) ; connect ( timer , SIGNAL ( timeout ( ) ) , this , SLOT ( processStatus ( ) ) ) ; timer -> start ( BTSRC8III_POLL_INTERVAL ) ; } BtSrc8Iii :: ~ BtSrc8Iii ( ) { delete bt_device ; delete bt_gpi_oneshot ; delete bt_gpo_oneshot ; } RDMatrix :: Type BtSrc8Iii :: type ( ) { return RDMatrix :: BtSrc8III ; } unsigned BtSrc8Iii :: gpiQuantity ( ) { return bt_gpis ; } unsigned BtSrc8Iii :: gpoQuantity ( ) { return bt_gpos ; } bool BtSrc8Iii :: primaryTtyActive ( ) { return true ; } bool BtSrc8Iii :: secondaryTtyActive ( ) { return false ; } void BtSrc8Iii :: processCommand ( RDMacro * cmd ) { char str [ 9 ] ; switch ( cmd -> command ( ) ) { case RDMacro :: GO : if ( ( cmd -> argQuantity ( ) != 5 ) || ( ( cmd -> arg ( 1 ) . lower ( ) != " i " ) && ( cmd -> arg ( 1 ) . lower ( ) != " o " ) ) || ( cmd -> arg ( 2 ) . toInt ( ) < 1 ) || ( cmd -> arg ( 3 ) . toInt ( ) > bt_gpos ) || ( cmd -> arg ( 2 ) . toInt ( ) > bt_gpos ) || ( ( cmd -> arg ( 3 ) . toInt ( ) != 1 ) && ( cmd -> arg ( 3 ) . toInt ( ) != 0 ) && ( cmd -> arg ( 1 ) . lower ( ) != " i " ) ) || ( ( cmd -> arg ( 3 ) . toInt ( ) != 1 ) && ( cmd -> arg ( 3 ) . toInt ( ) != 0 ) && ( cmd -> arg ( 3 ) . toInt ( ) != - 1 ) && ( cmd -> arg ( 1 ) . lower ( ) == " i " ) ) || ( cmd -> arg ( 4 ) . toInt ( ) < 0 ) ) { cmd -> acknowledge ( false ) ; emit rmlEcho ( cmd ) ; return ; } if ( cmd -> arg ( 3 ) . toInt ( ) == 0 ) { if ( cmd -> arg ( 4 ) . toInt ( ) == 0 ) { if ( cmd -> arg ( 1 ) . lower ( ) == " i " ) { if ( bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] ) { emit gpiChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , false ) ; bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = false ; } bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } if ( cmd -> arg ( 1 ) . lower ( ) == " o " ) { sprintf ( str , " * % dOR % dF \n " , BTSRC8III_UNIT_ID , cmd -> arg ( 2 ) . toInt ( ) ) ; bt_device -> write ( str , 8 ) ; emit gpoChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , false ) ; } } else { if ( cmd -> echoRequested ( ) ) { cmd -> acknowledge ( false ) ; emit rmlEcho ( cmd ) ; } return ; } } else { if ( cmd -> arg ( 3 ) . toInt ( ) == - 1 ) { bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = false ; bt_device -> write ( " * 0SPA \n " , 7 ) ; } else { if ( cmd -> arg ( 4 ) . toInt ( ) == 0 ) { if ( cmd -> arg ( 1 ) . lower ( ) == " i " ) { if ( ! bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] ) { emit gpiChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } if ( cmd -> arg ( 1 ) . lower ( ) == " o " ) { sprintf ( str , " * % dOR % dL \n " , BTSRC8III_UNIT_ID , cmd -> arg ( 2 ) . toInt ( ) ) ; bt_device -> write ( str , 8 ) ; emit gpoChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; } } else { if ( cmd -> arg ( 1 ) . lower ( ) == " i " ) { if ( ! bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] ) { emit gpiChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; bt_gpi_oneshot -> start ( cmd -> arg ( 2 ) . toInt ( ) - 1 , 500 ) ; } if ( cmd -> arg ( 1 ) . lower ( ) == " o " ) { sprintf ( str , " * % dOR % dP % 02d \n " , BTSRC8III_UNIT_ID , cmd -> arg ( 2 ) . toInt ( ) , cmd -> arg ( 4 ) . toInt ( ) / 100 + 1 ) ; bt_device -> write ( str , 10 ) ; emit gpoChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; bt_gpo_oneshot -> start ( cmd -> arg ( 2 ) . toInt ( ) - 1 , 500 ) ; } } } } if ( cmd -> echoRequested ( ) ) { cmd -> acknowledge ( true ) ; emit rmlEcho ( cmd ) ; } break ; default : cmd -> acknowledge ( false ) ; emit rmlEcho ( cmd ) ; break ; } } void BtSrc8Iii :: processStatus ( ) { char buffer [ 256 ] ; int n ; int gpi ; while ( ( n = bt_device -> read ( buffer , 255 ) ) > 0 ) { for ( int i = 0 ; i < n ; i ++ ) { switch ( bt_istate ) { case 0 : if ( buffer [ i ] == ' S ' ) { bt_istate = 1 ; } break ; case 1 : if ( buffer [ i ] == ( BTSRC8III_UNIT_ID + '0' ) ) { bt_istate = 2 ; } else { bt_istate = 0 ; } break ; case 2 : if ( buffer [ i ] == ' P ' ) { bt_istate = 3 ; } else { bt_istate = 0 ; } break ; case 3 : if ( buffer [ i ] == ' , ' ) { bt_istate = 4 ; } else { bt_istate = 0 ; } break ; case 4 : if ( buffer [ i ] == ' A ' ) { bt_istate = 5 ; } else { bt_istate = 0 ; } break ; case 5 : case 7 : case 9 : case 11 : case 13 : case 15 : case 17 : case 19 : if ( buffer [ i ] == ' , ' ) { bt_istate ++ ; } else { bt_istate = 0 ; } break ; case 6 : case 8 : case 10 : case 12 : case 14 : case 16 : case 18 : case 20 : if ( buffer [ i ] == '0' ) { gpi = ( bt_istate - 6 ) / 2 ; if ( bt_gpi_state [ gpi ] && ( ! bt_gpi_mask [ gpi ] ) ) { emit gpiChanged ( bt_matrix , gpi , false ) ; bt_gpi_state [ gpi ] = false ; } bt_istate ++ ; } if ( buffer [ i ] == '1' ) { gpi = ( bt_istate - 6 ) / 2 ; if ( ( ! bt_gpi_state [ gpi ] ) && ( ! bt_gpi_mask [ gpi ] ) ) { emit gpiChanged ( bt_matrix , gpi , true ) ; bt_gpi_state [ gpi ] = true ; } bt_istate ++ ; } break ; default : bt_istate = 0 ; } } } } void BtSrc8Iii :: gpiOneshotData ( int value ) { bt_gpi_mask [ value ] = false ; bt_device -> write ( " * 0SPA " , 5 ) ; } void BtSrc8Iii :: gpoOneshotData ( int value ) { emit gpoChanged ( bt_matrix , value , false ) ; } </DOCUMENT>
<DOCUMENT_ID="mur47x111/JDK8-concurrent-tagging/tree/master/src/share/vm/gc_implementation/concurrentMarkSweep/vmCMSOperations.cpp"> # include " precompiled . hpp " # include " gc _ implementation / concurrentMarkSweep / concurrentMarkSweepGeneration . inline . hpp " # include " gc _ implementation / concurrentMarkSweep / concurrentMarkSweepThread . hpp " # include " gc _ implementation / concurrentMarkSweep / vmCMSOperations . hpp " # include " gc _ implementation / shared / gcTimer . hpp " # include " gc _ implementation / shared / gcTraceTime . hpp " # include " gc _ implementation / shared / isGCActiveMark . hpp " # include " memory / gcLocker . inline . hpp " # include " runtime / interfaceSupport . hpp " # include " runtime / os . hpp " # include " utilities / dtrace . hpp " # ifndef USDT2 HS_DTRACE_PROBE_DECL ( hs_private , cms__initmark__begin ) ; HS_DTRACE_PROBE_DECL ( hs_private , cms__initmark__end ) ; HS_DTRACE_PROBE_DECL ( hs_private , cms__remark__begin ) ; HS_DTRACE_PROBE_DECL ( hs_private , cms__remark__end ) ; # endif void VM_CMS_Operation :: acquire_pending_list_lock ( ) { ConcurrentMarkSweepThread :: slt ( ) -> manipulatePLL ( SurrogateLockerThread :: acquirePLL ) ; } void VM_CMS_Operation :: release_and_notify_pending_list_lock ( ) { ConcurrentMarkSweepThread :: slt ( ) -> manipulatePLL ( SurrogateLockerThread :: releaseAndNotifyPLL ) ; } void VM_CMS_Operation :: verify_before_gc ( ) { if ( VerifyBeforeGC && GenCollectedHeap :: heap ( ) -> total_collections ( ) >= VerifyGCStartAt ) { GCTraceTime tm ( " Verify ▁ Before " , false , false , _collector -> _gc_timer_cm ) ; HandleMark hm ; FreelistLocker x ( _collector ) ; MutexLockerEx y ( _collector -> bitMapLock ( ) , Mutex :: _no_safepoint_check_flag ) ; Universe :: heap ( ) -> prepare_for_verify ( ) ; Universe :: verify ( ) ; } } void VM_CMS_Operation :: verify_after_gc ( ) { if ( VerifyAfterGC && GenCollectedHeap :: heap ( ) -> total_collections ( ) >= VerifyGCStartAt ) { GCTraceTime tm ( " Verify ▁ After " , false , false , _collector -> _gc_timer_cm ) ; HandleMark hm ; FreelistLocker x ( _collector ) ; MutexLockerEx y ( _collector -> bitMapLock ( ) , Mutex :: _no_safepoint_check_flag ) ; Universe :: verify ( ) ; } } bool VM_CMS_Operation :: lost_race ( ) const { if ( CMSCollector :: abstract_state ( ) == CMSCollector :: Idling ) { return true ; } assert ( CMSCollector :: abstract_state ( ) == legal_state ( ) , " Inconsistent ▁ collector ▁ state ? " ) ; return false ; } bool VM_CMS_Operation :: doit_prologue ( ) { assert ( Thread :: current ( ) -> is_ConcurrentGC_thread ( ) , " just ▁ checking " ) ; assert ( ! CMSCollector :: foregroundGCShouldWait ( ) , " Possible ▁ deadlock " ) ; assert ( ! ConcurrentMarkSweepThread :: cms_thread_has_cms_token ( ) , " Possible ▁ deadlock " ) ; if ( needs_pll ( ) ) { acquire_pending_list_lock ( ) ; } Heap_lock -> lock ( ) ; if ( lost_race ( ) ) { assert ( _prologue_succeeded == false , " Initialized ▁ in ▁ c ' tor " ) ; Heap_lock -> unlock ( ) ; if ( needs_pll ( ) ) { release_and_notify_pending_list_lock ( ) ; } } else { _prologue_succeeded = true ; } return _prologue_succeeded ; } void VM_CMS_Operation :: doit_epilogue ( ) { assert ( Thread :: current ( ) -> is_ConcurrentGC_thread ( ) , " just ▁ checking " ) ; assert ( ! CMSCollector :: foregroundGCShouldWait ( ) , " Possible ▁ deadlock " ) ; assert ( ! ConcurrentMarkSweepThread :: cms_thread_has_cms_token ( ) , " Possible ▁ deadlock " ) ; Heap_lock -> unlock ( ) ; if ( needs_pll ( ) ) { release_and_notify_pending_list_lock ( ) ; } } void VM_CMS_Initial_Mark :: doit ( ) { if ( lost_race ( ) ) { return ; } # ifndef USDT2 HS_DTRACE_PROBE ( hs_private , cms__initmark__begin ) ; # else HS_PRIVATE_CMS_INITMARK_BEGIN ( ) ; # endif _collector -> _gc_timer_cm -> register_gc_pause_start ( " Initial ▁ Mark " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; GCCauseSetter gccs ( gch , GCCause :: _cms_initial_mark ) ; VM_CMS_Operation :: verify_before_gc ( ) ; IsGCActiveMark x ; _collector -> do_CMS_operation ( CMSCollector :: CMS_op_checkpointRootsInitial , gch -> gc_cause ( ) ) ; VM_CMS_Operation :: verify_after_gc ( ) ; _collector -> _gc_timer_cm -> register_gc_pause_end ( ) ; # ifndef USDT2 HS_DTRACE_PROBE ( hs_private , cms__initmark__end ) ; # else HS_PRIVATE_CMS_INITMARK_END ( ) ; # endif } void VM_CMS_Final_Remark :: doit ( ) { if ( lost_race ( ) ) { return ; } # ifndef USDT2 HS_DTRACE_PROBE ( hs_private , cms__remark__begin ) ; # else HS_PRIVATE_CMS_REMARK_BEGIN ( ) ; # endif _collector -> _gc_timer_cm -> register_gc_pause_start ( " Final ▁ Mark " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; GCCauseSetter gccs ( gch , GCCause :: _cms_final_remark ) ; VM_CMS_Operation :: verify_before_gc ( ) ; IsGCActiveMark x ; _collector -> do_CMS_operation ( CMSCollector :: CMS_op_checkpointRootsFinal , gch -> gc_cause ( ) ) ; VM_CMS_Operation :: verify_after_gc ( ) ; _collector -> save_heap_summary ( ) ; _collector -> _gc_timer_cm -> register_gc_pause_end ( ) ; # ifndef USDT2 HS_DTRACE_PROBE ( hs_private , cms__remark__end ) ; # else HS_PRIVATE_CMS_REMARK_END ( ) ; # endif } void VM_GenCollectFullConcurrent :: doit ( ) { assert ( Thread :: current ( ) -> is_VM_thread ( ) , " Should ▁ be ▁ VM ▁ thread " ) ; assert ( GCLockerInvokesConcurrent || ExplicitGCInvokesConcurrent , " Unexpected " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; if ( _gc_count_before == gch -> total_collections ( ) ) { assert ( SafepointSynchronize :: is_at_safepoint ( ) , " We ▁ can ▁ only ▁ be ▁ executing ▁ this ▁ arm ▁ of ▁ if ▁ at ▁ a ▁ safepoint " ) ; GCCauseSetter gccs ( gch , _gc_cause ) ; gch -> do_full_collection ( gch -> must_clear_all_soft_refs ( ) , 0 ) ; } assert ( ( _gc_count_before < gch -> total_collections ( ) ) || ( GC_locker :: is_active ( ) && ( _gc_count_before == gch -> total_collections ( ) ) ) , " total _ collections ( ) ▁ should ▁ be ▁ monotonically ▁ increasing " ) ; MutexLockerEx x ( FullGCCount_lock , Mutex :: _no_safepoint_check_flag ) ; assert ( _full_gc_count_before <= gch -> total_full_collections ( ) , " Error " ) ; if ( gch -> total_full_collections ( ) == _full_gc_count_before ) { CMSCollector :: disable_icms ( ) ; _disabled_icms = true ; CMSCollector :: start_icms ( ) ; CMSCollector :: request_full_gc ( _full_gc_count_before , _gc_cause ) ; } else { assert ( _full_gc_count_before < gch -> total_full_collections ( ) , " Error " ) ; FullGCCount_lock -> notify_all ( ) ; } } bool VM_GenCollectFullConcurrent :: evaluate_at_safepoint ( ) const { Thread * thr = Thread :: current ( ) ; assert ( thr != NULL , " Unexpected ▁ tid " ) ; if ( ! thr -> is_Java_thread ( ) ) { assert ( thr -> is_VM_thread ( ) , " Expected ▁ to ▁ be ▁ evaluated ▁ by ▁ VM ▁ thread " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; if ( _gc_count_before != gch -> total_collections ( ) ) { assert ( _gc_count_before < gch -> total_collections ( ) , " total _ collections ( ) ▁ should ▁ be ▁ monotnically ▁ increasing " ) ; return false ; } } return true ; } void VM_GenCollectFullConcurrent :: doit_epilogue ( ) { Thread * thr = Thread :: current ( ) ; assert ( thr -> is_Java_thread ( ) , " just ▁ checking " ) ; JavaThread * jt = ( JavaThread * ) thr ; Heap_lock -> unlock ( ) ; release_and_notify_pending_list_lock ( ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; if ( _gc_cause != GCCause :: _gc_locker && gch -> total_full_collections_completed ( ) <= _full_gc_count_before ) { assert ( _gc_cause == GCCause :: _java_lang_system_gc , " the ▁ only ▁ way ▁ to ▁ get ▁ here ▁ if ▁ this ▁ was ▁ a ▁ System . gc ( ) - induced ▁ GC " ) ; assert ( ExplicitGCInvokesConcurrent , " Error " ) ; ThreadToNativeFromVM native ( jt ) ; MutexLockerEx ml ( FullGCCount_lock , Mutex :: _no_safepoint_check_flag ) ; while ( gch -> total_full_collections_completed ( ) <= _full_gc_count_before ) { FullGCCount_lock -> wait ( Mutex :: _no_safepoint_check_flag ) ; } } if ( _disabled_icms ) { CMSCollector :: enable_icms ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="carvalhomb/tsmells/tree/master/sample/poco/poco/Foundation/testsuite/src/UniqueExpireCacheTest.cpp"> # include " UniqueExpireCacheTest . h " # include " CppUnit / TestCaller . h " # include " CppUnit / TestSuite . h " # include " Poco / Exception . h " # include " Poco / UniqueExpireCache . h " # include " Poco / UniqueAccessExpireCache . h " # include " Poco / ExpirationDecorator . h " # include " Poco / AccessExpirationDecorator . h " # include " Poco / Bugcheck . h " # include " Poco / Thread . h " using namespace Poco ; struct IntVal { int value ; Poco :: Timestamp validUntil ; IntVal ( int val , Poco :: Timestamp :: TimeDiff v ) : value ( val ) , validUntil ( ) { validUntil += ( v * 1000 ) ; } const Poco :: Timestamp & getExpiration ( ) const { return validUntil ; } } ; typedef AccessExpirationDecorator < int > DIntVal ; # define DURSLEEP 250 # define DURHALFSLEEP DURSLEEP / 2 # define DURWAIT 300 UniqueExpireCacheTest :: UniqueExpireCacheTest ( const std :: string & name ) : CppUnit :: TestCase ( name ) { } UniqueExpireCacheTest :: ~ UniqueExpireCacheTest ( ) { } void UniqueExpireCacheTest :: testClear ( ) { UniqueExpireCache < int , IntVal > aCache ; aCache . add ( 1 , IntVal ( 2 , DURSLEEP ) ) ; aCache . add ( 3 , IntVal ( 4 , DURSLEEP ) ) ; aCache . add ( 5 , IntVal ( 6 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; assert ( aCache . has ( 5 ) ) ; assert ( aCache . get ( 1 ) -> value == 2 ) ; assert ( aCache . get ( 3 ) -> value == 4 ) ; assert ( aCache . get ( 5 ) -> value == 6 ) ; aCache . clear ( ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( ! aCache . has ( 5 ) ) ; } void UniqueExpireCacheTest :: testAccessClear ( ) { UniqueAccessExpireCache < int , DIntVal > aCache ; aCache . add ( 1 , DIntVal ( 2 , DURSLEEP ) ) ; aCache . add ( 3 , DIntVal ( 4 , DURSLEEP ) ) ; aCache . add ( 5 , DIntVal ( 6 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; assert ( aCache . has ( 5 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; assert ( aCache . get ( 3 ) -> value ( ) == 4 ) ; assert ( aCache . get ( 5 ) -> value ( ) == 6 ) ; aCache . clear ( ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( ! aCache . has ( 5 ) ) ; } void UniqueExpireCacheTest :: testAccessUpdate ( ) { UniqueAccessExpireCache < int , DIntVal > aCache ; aCache . add ( 1 , DIntVal ( 2 , DURSLEEP ) ) ; aCache . add ( 3 , DIntVal ( 4 , DURSLEEP ) ) ; aCache . add ( 5 , DIntVal ( 6 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; assert ( aCache . has ( 5 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; Thread :: sleep ( DURSLEEP / 2 ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; Thread :: sleep ( DURSLEEP / 2 ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; Thread :: sleep ( DURSLEEP / 2 ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( ! aCache . has ( 5 ) ) ; Thread :: sleep ( DURSLEEP * 2 ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( ! aCache . has ( 5 ) ) ; aCache . remove ( 666 ) ; } void UniqueExpireCacheTest :: testExpire0 ( ) { UniqueExpireCache < int , IntVal > aCache ; aCache . add ( 1 , IntVal ( 2 , 0 ) ) ; assert ( ! aCache . has ( 1 ) ) ; } void UniqueExpireCacheTest :: testAccessExpire0 ( ) { UniqueAccessExpireCache < int , DIntVal > aCache ; aCache . add ( 1 , DIntVal ( 2 , Timespan ( 0 , 0 ) ) ) ; assert ( ! aCache . has ( 1 ) ) ; } void UniqueExpireCacheTest :: testExpireN ( ) { UniqueExpireCache < int , IntVal > aCache ; aCache . add ( 1 , IntVal ( 2 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; SharedPtr < IntVal > tmp = aCache . get ( 1 ) ; assert ( ! tmp . isNull ( ) ) ; assert ( tmp -> value == 2 ) ; Thread :: sleep ( DURWAIT ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( tmp -> value == 2 ) ; tmp = aCache . get ( 1 ) ; assert ( tmp . isNull ( ) ) ; aCache . add ( 1 , IntVal ( 2 , DURSLEEP ) ) ; Thread :: sleep ( DURHALFSLEEP ) ; aCache . add ( 3 , IntVal ( 4 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; tmp = aCache . get ( 1 ) ; SharedPtr < IntVal > tmp2 = aCache . get ( 3 ) ; assert ( tmp -> value == 2 ) ; assert ( tmp2 -> value == 4 ) ; Thread :: sleep ( DURHALFSLEEP + 25 ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; assert ( tmp -> value == 2 ) ; assert ( tmp2 -> value == 4 ) ; tmp2 = aCache . get ( 3 ) ; assert ( tmp2 -> value == 4 ) ; Thread :: sleep ( DURHALFSLEEP + 25 ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( tmp2 -> value == 4 ) ; tmp = aCache . get ( 1 ) ; tmp2 = aCache . get ( 3 ) ; assert ( ! tmp ) ; assert ( ! tmp2 ) ; aCache . remove ( 666 ) ; aCache . clear ( ) ; assert ( ! aCache . has ( 5 ) ) ; assert ( ! aCache . has ( 3 ) ) ; } void UniqueExpireCacheTest :: testDuplicateAdd ( ) { UniqueExpireCache < int , IntVal > aCache ; aCache . add ( 1 , IntVal ( 2 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value == 2 ) ; aCache . add ( 1 , IntVal ( 3 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value == 3 ) ; } void UniqueExpireCacheTest :: testAccessDuplicateAdd ( ) { UniqueAccessExpireCache < int , DIntVal > aCache ; aCache . add ( 1 , DIntVal ( 2 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; aCache . add ( 1 , DIntVal ( 3 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 3 ) ; } void UniqueExpireCacheTest :: testExpirationDecorator ( ) { typedef ExpirationDecorator < int > ExpireInt ; UniqueExpireCache < int , ExpireInt > aCache ; aCache . add ( 1 , ExpireInt ( 2 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; aCache . add ( 1 , ExpireInt ( 3 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 3 ) ; } void UniqueExpireCacheTest :: setUp ( ) { } void UniqueExpireCacheTest :: tearDown ( ) { } CppUnit :: Test * UniqueExpireCacheTest :: suite ( ) { CppUnit :: TestSuite * pSuite = new CppUnit :: TestSuite ( " UniqueExpireCacheTest " ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testClear ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testAccessClear ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testAccessUpdate ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testExpire0 ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testAccessExpire0 ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testExpireN ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testDuplicateAdd ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testAccessDuplicateAdd ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testExpirationDecorator ) ; return pSuite ; } </DOCUMENT>
<DOCUMENT_ID="h0tw1r3/mame/tree/master/src/mame/video/mikromik.cpp"> # include " includes / mikromik . h " # define HORIZONTAL_CHARACTER_PIXELS 10 I8275_DRAW_CHARACTER_MEMBER ( mm1_state :: crtc_display_pixels ) { UINT8 romdata = m_char_rom -> base ( ) [ ( charcode << 4 ) | linecount ] ; int gpa0 = BIT ( gpa , 0 ) ; int llen = m_llen ; int compl_in = rvv ; int hlt_in = hlgt ; int color ; int i , qh , video_in ; int d7 = BIT ( romdata , 7 ) ; int d6 = BIT ( romdata , 6 ) ; int d0 = BIT ( romdata , 0 ) ; UINT8 data = ( romdata << 1 ) | ( d7 & d0 ) ; if ( y < 360 || x >= HORIZONTAL_CHARACTER_PIXELS || compl_in == 0 ) { if ( HORIZONTAL_CHARACTER_PIXELS == 10 ) { qh = d7 & d6 ; video_in = ( ( ( ( d7 & llen ) | ( vsp ? 0 : 1 ) ) & ( gpa0 ? 0 : 1 ) ) & qh ) | lten ; color = ( hlt_in ? 1 : 2 ) * ( video_in ^ compl_in ) ; bitmap . pix32 ( y , x + 8 ) = m_palette -> pen ( color ) ; bitmap . pix32 ( y , x + 9 ) = m_palette -> pen ( color ) ; } for ( i = 0 ; i < 8 ; ++ i ) { qh = BIT ( data , i ) ; video_in = ( ( ( ( d7 & llen ) | ( vsp ? 0 : 1 ) ) & ( gpa0 ? 0 : 1 ) ) & qh ) | lten ; color = ( hlt_in ? 1 : 2 ) * ( video_in ^ compl_in ) ; bitmap . pix32 ( y , x + i ) = m_palette -> pen ( color ) ; } } } static ADDRESS_MAP_START ( mm1_upd7220_map , AS_0 , 16 , mm1_state ) ADDRESS_MAP_GLOBAL_MASK ( 0x7fff ) AM_RANGE ( 0x0000 , 0x7fff ) AM_RAM AM_SHARE ( " video _ ram " ) ADDRESS_MAP_END UPD7220_DISPLAY_PIXELS_MEMBER ( mm1_state :: hgdc_display_pixels ) { UINT16 data = m_video_ram [ address >> 1 ] ; for ( int i = 0 ; i < 16 ; i ++ ) { if ( BIT ( data , i ) ) bitmap . pix32 ( y , x + i ) = m_palette -> pen ( 2 ) ; } } UINT32 mm1_state :: screen_update ( screen_device & screen , bitmap_rgb32 & bitmap , const rectangle & cliprect ) { m_crtc -> screen_update ( screen , bitmap , cliprect ) ; m_hgdc -> screen_update ( screen , bitmap , cliprect ) ; return 0 ; } static const gfx_layout charlayout = { 8 , 16 , RGN_FRAC ( 1 , 1 ) , 1 , { 0 } , { 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 } , { 0 * 8 , 1 * 8 , 2 * 8 , 3 * 8 , 4 * 8 , 5 * 8 , 6 * 8 , 7 * 8 , 8 * 8 , 9 * 8 , 10 * 8 , 11 * 8 , 12 * 8 , 13 * 8 , 14 * 8 , 15 * 8 } , 8 * 16 } ; static GFXDECODE_START ( mm1 ) GFXDECODE_ENTRY ( " chargen " , 0 , charlayout , 0 , 1 ) GFXDECODE_END PALETTE_INIT_MEMBER ( mm1_state , mm1 ) { palette . set_pen_color ( 0 , rgb_t ( 0x00 , 0x00 , 0x00 ) ) ; palette . set_pen_color ( 1 , rgb_t ( 0x00 , 0x7F , 0x0A ) ) ; palette . set_pen_color ( 2 , rgb_t ( 0x08 , 0xD0 , 0x1A ) ) ; } MACHINE_CONFIG_FRAGMENT ( mm1m6_video ) MCFG_SCREEN_ADD ( SCREEN_TAG , RASTER ) MCFG_SCREEN_REFRESH_RATE ( 50 ) MCFG_SCREEN_UPDATE_DRIVER ( mm1_state , screen_update ) MCFG_SCREEN_SIZE ( 800 , 375 ) MCFG_SCREEN_VISIBLE_AREA ( 0 , 800 - 1 , 0 , 375 - 1 ) MCFG_GFXDECODE_ADD ( " gfxdecode " , " palette " , mm1 ) MCFG_PALETTE_ADD ( " palette " , 3 ) MCFG_PALETTE_INIT_OWNER ( mm1_state , mm1 ) MCFG_DEVICE_ADD ( I8275_TAG , I8275 , XTAL_18_720MHz / 8 ) MCFG_I8275_CHARACTER_WIDTH ( HORIZONTAL_CHARACTER_PIXELS ) MCFG_I8275_DRAW_CHARACTER_CALLBACK_OWNER ( mm1_state , crtc_display_pixels ) MCFG_I8275_DRQ_CALLBACK ( DEVWRITELINE ( I8237_TAG , am9517a_device , dreq0_w ) ) MCFG_I8275_VRTC_CALLBACK ( DEVWRITELINE ( UPD7220_TAG , upd7220_device , ext_sync_w ) ) MCFG_VIDEO_SET_SCREEN ( SCREEN_TAG ) MCFG_DEVICE_ADD ( UPD7220_TAG , UPD7220 , XTAL_18_720MHz / 8 ) MCFG_DEVICE_ADDRESS_MAP ( AS_0 , mm1_upd7220_map ) MCFG_UPD7220_DISPLAY_PIXELS_CALLBACK_OWNER ( mm1_state , hgdc_display_pixels ) MCFG_VIDEO_SET_SCREEN ( SCREEN_TAG ) MACHINE_CONFIG_END </DOCUMENT>
<DOCUMENT_ID="weolar/miniblink49/tree/master/gen/blink/bindings/core/v8/V8VideoTrackList.cpp"> # include " config . h " # include " V8VideoTrackList . h " # include " bindings / core / v8 / ExceptionState . h " # include " bindings / core / v8 / V8AbstractEventListener . h " # include " bindings / core / v8 / V8DOMConfiguration . h " # include " bindings / core / v8 / V8EventListenerList . h " # include " bindings / core / v8 / V8GCController . h " # include " bindings / core / v8 / V8ObjectConstructor . h " # include " bindings / core / v8 / V8VideoTrack . h " # include " core / dom / ContextFeatures . h " # include " core / dom / Document . h " # include " core / dom / Element . h " # include " platform / RuntimeEnabledFeatures . h " # include " platform / TraceEvent . h " # include " wtf / GetPtr . h " # include " wtf / RefPtr . h " namespace blink { # if defined ( COMPONENT_BUILD ) && defined ( WIN32 ) && COMPILER ( CLANG ) # pragma clang diagnostic push # pragma clang diagnostic ignored " - Wglobal - constructors " # endif const WrapperTypeInfo V8VideoTrackList :: wrapperTypeInfo = { gin :: kEmbedderBlink , V8VideoTrackList :: domTemplate , V8VideoTrackList :: refObject , V8VideoTrackList :: derefObject , V8VideoTrackList :: trace , 0 , V8VideoTrackList :: visitDOMWrapper , V8VideoTrackList :: preparePrototypeObject , V8VideoTrackList :: installConditionallyEnabledProperties , " VideoTrackList " , & V8EventTarget :: wrapperTypeInfo , WrapperTypeInfo :: WrapperTypeObjectPrototype , WrapperTypeInfo :: ObjectClassId , WrapperTypeInfo :: InheritFromEventTarget , WrapperTypeInfo :: Dependent , WrapperTypeInfo :: WillBeGarbageCollectedObject } ; # if defined ( COMPONENT_BUILD ) && defined ( WIN32 ) && COMPILER ( CLANG ) # pragma clang diagnostic pop # endif const WrapperTypeInfo & VideoTrackList :: s_wrapperTypeInfo = V8VideoTrackList :: wrapperTypeInfo ; namespace VideoTrackListV8Internal { static void lengthAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; v8SetReturnValueUnsigned ( info , impl -> length ( ) ) ; } static void lengthAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: lengthAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void selectedIndexAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; v8SetReturnValueInt ( info , impl -> selectedIndex ( ) ) ; } static void selectedIndexAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: selectedIndexAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onchangeAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; EventListener * cppValue ( impl -> onchange ( ) ) ; v8SetReturnValue ( info , cppValue ? v8 :: Local < v8 :: Value > ( V8AbstractEventListener :: cast ( cppValue ) -> getListenerObject ( impl -> executionContext ( ) ) ) : v8 :: Local < v8 :: Value > ( v8 :: Null ( info . GetIsolate ( ) ) ) ) ; } static void onchangeAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: onchangeAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onchangeAttributeSetter ( v8 :: Local < v8 :: Value > v8Value , const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; moveEventListenerToNewWrapper ( info . GetIsolate ( ) , holder , impl -> onchange ( ) , v8Value , V8VideoTrackList :: eventListenerCacheIndex ) ; impl -> setOnchange ( V8EventListenerList :: getEventListener ( ScriptState :: current ( info . GetIsolate ( ) ) , v8Value , true , ListenerFindOrCreate ) ) ; } static void onchangeAttributeSetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Value > v8Value = info [ 0 ] ; TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMSetter " ) ; VideoTrackListV8Internal :: onchangeAttributeSetter ( v8Value , info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onaddtrackAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; EventListener * cppValue ( impl -> onaddtrack ( ) ) ; v8SetReturnValue ( info , cppValue ? v8 :: Local < v8 :: Value > ( V8AbstractEventListener :: cast ( cppValue ) -> getListenerObject ( impl -> executionContext ( ) ) ) : v8 :: Local < v8 :: Value > ( v8 :: Null ( info . GetIsolate ( ) ) ) ) ; } static void onaddtrackAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: onaddtrackAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onaddtrackAttributeSetter ( v8 :: Local < v8 :: Value > v8Value , const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; moveEventListenerToNewWrapper ( info . GetIsolate ( ) , holder , impl -> onaddtrack ( ) , v8Value , V8VideoTrackList :: eventListenerCacheIndex ) ; impl -> setOnaddtrack ( V8EventListenerList :: getEventListener ( ScriptState :: current ( info . GetIsolate ( ) ) , v8Value , true , ListenerFindOrCreate ) ) ; } static void onaddtrackAttributeSetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Value > v8Value = info [ 0 ] ; TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMSetter " ) ; VideoTrackListV8Internal :: onaddtrackAttributeSetter ( v8Value , info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onremovetrackAttributeGetter ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; EventListener * cppValue ( impl -> onremovetrack ( ) ) ; v8SetReturnValue ( info , cppValue ? v8 :: Local < v8 :: Value > ( V8AbstractEventListener :: cast ( cppValue ) -> getListenerObject ( impl -> executionContext ( ) ) ) : v8 :: Local < v8 :: Value > ( v8 :: Null ( info . GetIsolate ( ) ) ) ) ; } static void onremovetrackAttributeGetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMGetter " ) ; VideoTrackListV8Internal :: onremovetrackAttributeGetter ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void onremovetrackAttributeSetter ( v8 :: Local < v8 :: Value > v8Value , const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Object > holder = info . Holder ( ) ; VideoTrackList * impl = V8VideoTrackList :: toImpl ( holder ) ; moveEventListenerToNewWrapper ( info . GetIsolate ( ) , holder , impl -> onremovetrack ( ) , v8Value , V8VideoTrackList :: eventListenerCacheIndex ) ; impl -> setOnremovetrack ( V8EventListenerList :: getEventListener ( ScriptState :: current ( info . GetIsolate ( ) ) , v8Value , true , ListenerFindOrCreate ) ) ; } static void onremovetrackAttributeSetterCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { v8 :: Local < v8 :: Value > v8Value = info [ 0 ] ; TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMSetter " ) ; VideoTrackListV8Internal :: onremovetrackAttributeSetter ( v8Value , info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void getTrackByIdMethod ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { if ( UNLIKELY ( info . Length ( ) < 1 ) ) { V8ThrowException :: throwException ( createMinimumArityTypeErrorForMethod ( info . GetIsolate ( ) , " getTrackById " , " VideoTrackList " , 1 , info . Length ( ) ) , info . GetIsolate ( ) ) ; return ; } VideoTrackList * impl = V8VideoTrackList :: toImpl ( info . Holder ( ) ) ; V8StringResource < > id ; { id = info [ 0 ] ; if ( ! id . prepare ( ) ) return ; } v8SetReturnValue ( info , impl -> getTrackById ( id ) ) ; } static void getTrackByIdMethodCallback ( const v8 :: FunctionCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMMethod " ) ; VideoTrackListV8Internal :: getTrackByIdMethod ( info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } static void indexedPropertyGetter ( uint32_t index , const v8 :: PropertyCallbackInfo < v8 :: Value > & info ) { VideoTrackList * impl = V8VideoTrackList :: toImpl ( info . Holder ( ) ) ; RefPtrWillBeRawPtr < VideoTrack > result = impl -> anonymousIndexedGetter ( index ) ; if ( ! result ) return ; v8SetReturnValueFast ( info , WTF :: getPtr ( result . release ( ) ) , impl ) ; } static void indexedPropertyGetterCallback ( uint32_t index , const v8 :: PropertyCallbackInfo < v8 :: Value > & info ) { TRACE_EVENT_SET_SAMPLING_STATE ( " blink " , " DOMIndexedProperty " ) ; VideoTrackListV8Internal :: indexedPropertyGetter ( index , info ) ; TRACE_EVENT_SET_SAMPLING_STATE ( " v8" , " V8Execution " ) ; } } void V8VideoTrackList :: visitDOMWrapper ( v8 :: Isolate * isolate , ScriptWrappable * scriptWrappable , const v8 :: Persistent < v8 :: Object > & wrapper ) { VideoTrackList * impl = scriptWrappable -> toImpl < VideoTrackList > ( ) ; if ( Node * owner = WTF :: getPtr ( impl -> owner ( ) ) ) { Node * root = V8GCController :: opaqueRootForGC ( isolate , owner ) ; isolate -> SetReferenceFromGroup ( v8 :: UniqueId ( reinterpret_cast < intptr_t > ( root ) ) , wrapper ) ; return ; } } static const V8DOMConfiguration :: AccessorConfiguration V8VideoTrackListAccessors [ ] = { { " length " , VideoTrackListV8Internal :: lengthAttributeGetterCallback , 0 , 0 , 0 , 0 , static_cast < v8 :: AccessControl > ( v8 :: DEFAULT ) , static_cast < v8 :: PropertyAttribute > ( v8 :: None ) , V8DOMConfiguration :: ExposedToAllScripts , V8DOMConfiguration :: OnPrototype , V8DOMConfiguration :: CheckHolder } , { " selectedIndex " , VideoTrackListV8Internal :: selectedIndexAttributeGetterCallback , 0 , 0 , 0 , 0 , static_cast < v8 :: AccessControl > ( v8 :: DEFAULT ) , static_cast < v8 :: PropertyAttribute > ( v8 :: None ) , V8DOMConfiguration :: ExposedToAllScripts , V8DOMConfiguration :: OnPrototype , V8DOMConfiguration :: CheckHolder } , { " onchange " , VideoTrackListV8Internal :: onchangeAttributeGetterCallback , VideoTrackListV8Internal :: onchangeAttributeSetterCallback , 0 , 0 , 0 , static_cast < v8 :: AccessControl > ( v8 :: DEFAULT ) , static_cast < v8 :: PropertyAttribute > ( v8 :: None ) , V8DOMConfiguration :: ExposedToAllScripts , V8DOMConfiguration :: OnPrototype , V8DOMConfiguration :: CheckHolder } , { " onaddtrack " , VideoTrackListV8Internal :: onaddtrackAttributeGetterCallback , VideoTrackListV8Internal :: onaddtrackAttributeSetterCallback , 0 , 0 , 0 , static_cast < v8 :: AccessControl > ( v8 :: DEFAULT ) , static_cast < v8 :: PropertyAttribute > ( v8 :: None ) , V8DOMConfiguration :: ExposedToAllScripts , V8DOMConfiguration :: OnPrototype , V8DOMConfiguration :: CheckHolder } , { " onremovetrack " , VideoTrackListV8Internal :: onremovetrackAttributeGetterCallback , VideoTrackListV8Internal :: onremovetrackAttributeSetterCallback , 0 , 0 , 0 , static_cast < v8 :: AccessControl > ( v8 :: DEFAULT ) , static_cast < v8 :: PropertyAttribute > ( v8 :: None ) , V8DOMConfiguration :: ExposedToAllScripts , V8DOMConfiguration :: OnPrototype , V8DOMConfiguration :: CheckHolder } , } ; static const V8DOMConfiguration :: MethodConfiguration V8VideoTrackListMethods [ ] = { { " getTrackById " , VideoTrackListV8Internal :: getTrackByIdMethodCallback , 0 , 1 , V8DOMConfiguration :: ExposedToAllScripts } , } ; static void installV8VideoTrackListTemplate ( v8 :: Local < v8 :: FunctionTemplate > functionTemplate , v8 :: Isolate * isolate ) { functionTemplate -> ReadOnlyPrototype ( ) ; v8 :: Local < v8 :: Signature > defaultSignature ; if ( ! RuntimeEnabledFeatures :: audioVideoTracksEnabled ( ) ) defaultSignature = V8DOMConfiguration :: installDOMClassTemplate ( isolate , functionTemplate , " VideoTrackList " , V8EventTarget :: domTemplate ( isolate ) , V8VideoTrackList :: internalFieldCount , 0 , 0 , 0 , 0 , 0 , 0 ) ; else defaultSignature = V8DOMConfiguration :: installDOMClassTemplate ( isolate , functionTemplate , " VideoTrackList " , V8EventTarget :: domTemplate ( isolate ) , V8VideoTrackList :: internalFieldCount , 0 , 0 , V8VideoTrackListAccessors , WTF_ARRAY_LENGTH ( V8VideoTrackListAccessors ) , V8VideoTrackListMethods , WTF_ARRAY_LENGTH ( V8VideoTrackListMethods ) ) ; v8 :: Local < v8 :: ObjectTemplate > instanceTemplate = functionTemplate -> InstanceTemplate ( ) ; ALLOW_UNUSED_LOCAL ( instanceTemplate ) ; v8 :: Local < v8 :: ObjectTemplate > prototypeTemplate = functionTemplate -> PrototypeTemplate ( ) ; ALLOW_UNUSED_LOCAL ( prototypeTemplate ) ; { v8 :: IndexedPropertyHandlerConfiguration config ( VideoTrackListV8Internal :: indexedPropertyGetterCallback , 0 , 0 , 0 , indexedPropertyEnumerator < VideoTrackList > ) ; functionTemplate -> InstanceTemplate ( ) -> SetHandler ( config ) ; } functionTemplate -> Set ( v8AtomicString ( isolate , " toString " ) , V8PerIsolateData :: from ( isolate ) -> toStringTemplate ( ) ) ; } v8 :: Local < v8 :: FunctionTemplate > V8VideoTrackList :: domTemplate ( v8 :: Isolate * isolate ) { return V8DOMConfiguration :: domClassTemplate ( isolate , const_cast < WrapperTypeInfo * > ( & wrapperTypeInfo ) , installV8VideoTrackListTemplate ) ; } bool V8VideoTrackList :: hasInstance ( v8 :: Local < v8 :: Value > v8Value , v8 :: Isolate * isolate ) { return V8PerIsolateData :: from ( isolate ) -> hasInstance ( & wrapperTypeInfo , v8Value ) ; } v8 :: Local < v8 :: Object > V8VideoTrackList :: findInstanceInPrototypeChain ( v8 :: Local < v8 :: Value > v8Value , v8 :: Isolate * isolate ) { return V8PerIsolateData :: from ( isolate ) -> findInstanceInPrototypeChain ( & wrapperTypeInfo , v8Value ) ; } VideoTrackList * V8VideoTrackList :: toImplWithTypeCheck ( v8 :: Isolate * isolate , v8 :: Local < v8 :: Value > value ) { return hasInstance ( value , isolate ) ? toImpl ( v8 :: Local < v8 :: Object > :: Cast ( value ) ) : 0 ; } void V8VideoTrackList :: refObject ( ScriptWrappable * scriptWrappable ) { # if ! ENABLE ( OILPAN ) scriptWrappable -> toImpl < VideoTrackList > ( ) -> ref ( ) ; # endif } void V8VideoTrackList :: derefObject ( ScriptWrappable * scriptWrappable ) { # if ! ENABLE ( OILPAN ) scriptWrappable -> toImpl < VideoTrackList > ( ) -> deref ( ) ; # endif } } </DOCUMENT>
<DOCUMENT_ID="g3rg/GoldenCheetah/tree/master/src/HrPwPlot.cpp"> # include " HrPwPlot . h " # include " MainWindow . h " # include " HrPwWindow . h " # include " RideFile . h " # include " RideItem . h " # include " Zones . h " # include " Settings . h " # include " Colors . h " # include < assert . h > # include < qwt_plot_curve . h > # include < qwt_plot_grid . h > # include < qwt_plot_canvas . h > # include < qwt_plot_marker . h > # include < qwt_text . h > # include < qwt_symbol . h > # include < qwt_legend . h > # include < qwt_series_data . h > static inline double max ( double a , double b ) { if ( a > b ) return a ; else return b ; } HrPwPlot :: HrPwPlot ( MainWindow * mainWindow , HrPwWindow * hrPwWindow ) : QwtPlot ( hrPwWindow ) , hrPwWindow ( hrPwWindow ) , mainWindow ( mainWindow ) , bg ( NULL ) , delay ( - 1 ) , minHr ( 50 ) , minWatt ( 50 ) , maxWatt ( 500 ) , settings ( GC_SETTINGS_CO , GC_SETTINGS_APP ) , unit ( settings . value ( GC_UNIT ) ) { setCanvasBackground ( Qt :: white ) ; canvas ( ) -> setFrameStyle ( QFrame :: NoFrame ) ; setXTitle ( ) ; regCurve = new QwtPlotCurve ( " reg " ) ; regCurve -> setPen ( QPen ( GColor ( CPLOTMARKER ) ) ) ; regCurve -> attach ( this ) ; wattsStepCurve = new QwtPlotCurve ( " Power " ) ; wattsStepCurve -> setStyle ( QwtPlotCurve :: Steps ) ; wattsStepCurve -> setRenderHint ( QwtPlotItem :: RenderAntialiased ) ; QColor wattsColor = QColor ( 200 , 200 , 255 ) ; QColor wattsColor2 = QColor ( 100 , 100 , 255 ) ; wattsStepCurve -> setPen ( QPen ( wattsColor2 ) ) ; wattsStepCurve -> setBrush ( QBrush ( wattsColor ) ) ; wattsStepCurve -> attach ( this ) ; hrStepCurve = new QwtPlotCurve ( " Hr " ) ; hrStepCurve -> setStyle ( QwtPlotCurve :: Steps ) ; hrStepCurve -> setRenderHint ( QwtPlotItem :: RenderAntialiased ) ; QColor hrColor = QColor ( 255 , 200 , 200 ) ; QColor hrColor2 = QColor ( 255 , 100 , 100 ) ; hrStepCurve -> setPen ( QPen ( hrColor2 ) ) ; hrStepCurve -> setBrush ( QBrush ( hrColor ) ) ; hrStepCurve -> attach ( this ) ; hrCurves . resize ( 36 ) ; for ( int i = 0 ; i < 36 ; ++ i ) { hrCurves [ i ] = new QwtPlotCurve ; hrCurves [ i ] -> attach ( this ) ; } grid = new QwtPlotGrid ( ) ; grid -> enableX ( false ) ; QPen gridPen ; gridPen . setStyle ( Qt :: DotLine ) ; gridPen . setColor ( GColor ( CPLOTGRID ) ) ; grid -> setPen ( gridPen ) ; grid -> attach ( this ) ; r_mrk1 = new QwtPlotMarker ; r_mrk2 = new QwtPlotMarker ; r_mrk1 -> attach ( this ) ; r_mrk2 -> attach ( this ) ; shade_zones = true ; } struct DataPoint { double time , hr , watts ; int inter ; DataPoint ( double t , double h , double w , int i ) : time ( t ) , hr ( h ) , watts ( w ) , inter ( i ) { } } ; void HrPwPlot :: setAxisTitle ( int axis , QString label ) { QFont stGiles ; stGiles . fromString ( appsettings -> value ( this , GC_FONT_CHARTLABELS , QFont ( ) . toString ( ) ) . toString ( ) ) ; stGiles . setPointSize ( appsettings -> value ( NULL , GC_FONT_CHARTLABELS_SIZE , 8 ) . toInt ( ) ) ; QwtText title ( label ) ; title . setFont ( stGiles ) ; QwtPlot :: setAxisFont ( axis , stGiles ) ; QwtPlot :: setAxisTitle ( axis , title ) ; } void HrPwPlot :: recalc ( ) { if ( timeArray . count ( ) == 0 ) return ; int rideTimeSecs = ( int ) ceil ( timeArray [ arrayLength - 1 ] ) ; if ( rideTimeSecs > 7 * 24 * 60 * 60 ) { return ; } double totalWatts = 0.0 ; double totalHr = 0.0 ; QList < DataPoint * > list ; int i = 0 ; QVector < double > smoothWatts ( rideTimeSecs + 1 ) ; QVector < double > smoothHr ( rideTimeSecs + 1 ) ; QVector < double > smoothTime ( rideTimeSecs + 1 ) ; int decal = 0 ; int smooth = hrPwWindow -> smooth ; for ( int secs = smooth ; secs <= rideTimeSecs ; ++ secs ) { while ( ( i < arrayLength ) && ( timeArray [ i ] <= secs ) ) { DataPoint * dp = new DataPoint ( timeArray [ i ] , hrArray [ i ] , wattsArray [ i ] , interArray [ i ] ) ; totalWatts += wattsArray [ i ] ; totalHr += hrArray [ i ] ; list . append ( dp ) ; ++ i ; } while ( ! list . empty ( ) && ( list . front ( ) -> time < secs - smooth ) ) { DataPoint * dp = list . front ( ) ; list . removeFirst ( ) ; totalWatts -= dp -> watts ; totalHr -= dp -> hr ; delete dp ; } if ( list . empty ( ) ) { ++ decal ; } else { smoothWatts [ secs - decal ] = totalWatts / list . size ( ) ; smoothHr [ secs - decal ] = totalHr / list . size ( ) ; } smoothTime [ secs ] = secs / 60.0 ; } rideTimeSecs = rideTimeSecs - decal ; smoothWatts . resize ( rideTimeSecs ) ; smoothHr . resize ( rideTimeSecs ) ; QVector < double > clipWatts ( rideTimeSecs ) ; QVector < double > clipHr ( rideTimeSecs ) ; decal = 0 ; for ( int secs = 0 ; secs < rideTimeSecs ; ++ secs ) { if ( smoothHr [ secs ] >= minHr && smoothWatts [ secs ] >= minWatt && smoothWatts [ secs ] < maxWatt ) { clipWatts [ secs - decal ] = smoothWatts [ secs ] ; clipHr [ secs - decal ] = smoothHr [ secs ] ; } else decal ++ ; } rideTimeSecs = rideTimeSecs - decal ; clipWatts . resize ( rideTimeSecs ) ; clipHr . resize ( rideTimeSecs ) ; if ( delay == - 1 ) delay = hrPwWindow -> findDelay ( clipWatts , clipHr , clipWatts . size ( ) ) ; QVector < double > delayWatts ( rideTimeSecs - delay ) ; QVector < double > delayHr ( rideTimeSecs - delay ) ; for ( int secs = 0 ; secs < rideTimeSecs - delay ; ++ secs ) { delayWatts [ secs ] = clipWatts [ secs ] ; delayHr [ secs ] = clipHr [ secs + delay ] ; } rideTimeSecs = rideTimeSecs - delay ; double rpente = hrPwWindow -> pente ( delayWatts , delayHr , delayWatts . size ( ) ) ; double rordonnee = hrPwWindow -> ordonnee ( delayWatts , delayHr , delayWatts . size ( ) ) ; double maxr = hrPwWindow -> corr ( delayWatts , delayHr , delayWatts . size ( ) ) ; int intpoints = 10 ; int nbpoints = ( int ) floor ( rideTimeSecs / intpoints ) ; QVector < double > plotedWatts ( nbpoints ) ; QVector < double > plotedHr ( nbpoints ) ; for ( int secs = 0 ; secs < nbpoints ; ++ secs ) { plotedWatts [ secs ] = clipWatts [ secs * intpoints ] ; plotedHr [ secs ] = clipHr [ secs * intpoints ] ; } int nbpoints2 = ( int ) floor ( nbpoints / 36 ) + 2 ; double * plotedWattsArray [ 36 ] ; double * plotedHrArray [ 36 ] ; for ( int i = 0 ; i < 36 ; ++ i ) { plotedWattsArray [ i ] = new double [ nbpoints2 ] ; plotedHrArray [ i ] = new double [ nbpoints2 ] ; } for ( int secs = 0 ; secs < nbpoints ; ++ secs ) { for ( int i = 0 ; i < 36 ; ++ i ) { if ( secs >= i * nbpoints2 && secs < ( i + 1 ) * nbpoints2 ) { plotedWattsArray [ i ] [ secs - i * nbpoints2 ] = plotedWatts [ secs - i ] ; plotedHrArray [ i ] [ secs - i * nbpoints2 ] = plotedHr [ secs - i ] ; } } } for ( int i = 0 ; i < 36 ; ++ i ) { if ( nbpoints - i * nbpoints2 > 0 ) { hrCurves [ i ] -> setData ( plotedWattsArray [ i ] , plotedHrArray [ i ] , ( nbpoints - i * nbpoints2 < nbpoints2 ? nbpoints - i * nbpoints2 : nbpoints2 ) ) ; hrCurves [ i ] -> setVisible ( true ) ; } else hrCurves [ i ] -> setVisible ( false ) ; } setAxisScale ( xBottom , 0.0 , maxWatt ) ; setYMax ( ) ; refreshZoneLabels ( ) ; QString labelp ; labelp . setNum ( rpente , ' f ' , 3 ) ; QString labelo ; labelo . setNum ( rordonnee , ' f ' , 1 ) ; QString labelr ; labelr . setNum ( maxr , ' f ' , 3 ) ; QString labeldelay ; labeldelay . setNum ( delay ) ; int power150 = ( int ) floor ( ( 150 - rordonnee ) / rpente ) ; QString labelpower150 ; labelpower150 . setNum ( power150 ) ; QwtText textr = QwtText ( labelp + " * x + " + labelo + " ▁ : ▁ R ▁ " + labelr + " ▁ ( " + labeldelay + " ) ▁ \n ▁ Power @ 150 : " + labelpower150 + " W " ) ; textr . setFont ( QFont ( " Helvetica " , 10 , QFont :: Bold ) ) ; textr . setColor ( Qt :: black ) ; r_mrk1 -> setValue ( 0 , 0 ) ; r_mrk1 -> setLineStyle ( QwtPlotMarker :: VLine ) ; r_mrk1 -> setLabelAlignment ( Qt :: AlignRight | Qt :: AlignTop ) ; r_mrk1 -> setLinePen ( QPen ( Qt :: black , 0 , Qt :: DashDotLine ) ) ; double moyennewatt = hrPwWindow -> moyenne ( clipWatts , clipWatts . size ( ) ) ; r_mrk1 -> setValue ( moyennewatt , 0.0 ) ; r_mrk1 -> setLabel ( textr ) ; r_mrk2 -> setValue ( 0 , 0 ) ; r_mrk2 -> setLineStyle ( QwtPlotMarker :: HLine ) ; r_mrk2 -> setLabelAlignment ( Qt :: AlignRight | Qt :: AlignTop ) ; r_mrk2 -> setLinePen ( QPen ( Qt :: black , 0 , Qt :: DashDotLine ) ) ; double moyennehr = hrPwWindow -> moyenne ( clipHr , clipHr . size ( ) ) ; r_mrk2 -> setValue ( 0.0 , moyennehr ) ; addWattStepCurve ( clipWatts , clipWatts . size ( ) ) ; addHrStepCurve ( clipHr , clipHr . size ( ) ) ; addRegLinCurve ( rpente , rordonnee ) ; setJoinLine ( joinLine ) ; replot ( ) ; } void HrPwPlot :: setYMax ( ) { double ymax = 0 ; QString ylabel = " " ; for ( int i = 0 ; i < 36 ; ++ i ) { if ( hrCurves [ i ] -> isVisible ( ) ) { ymax = max ( ymax , hrCurves [ i ] -> maxYValue ( ) ) ; } } setAxisScale ( yLeft , minHr , ymax * 1.2 ) ; setAxisTitle ( yLeft , tr ( " Heart ▁ Rate ( BPM ) " ) ) ; } void HrPwPlot :: addWattStepCurve ( QVector < double > & finalWatts , int nbpoints ) { QMap < double , double > powerHist ; for ( int h = 0 ; h < nbpoints ; ++ h ) { if ( powerHist . contains ( finalWatts [ h ] ) ) powerHist [ finalWatts [ h ] ] += 1 ; else powerHist [ finalWatts [ h ] ] = 1 ; } int maxPower = 500 ; double * array = new double [ maxPower ] ; for ( int i = 0 ; i < maxPower ; ++ i ) array [ i ] = 0.0 ; QMapIterator < double , double > k ( powerHist ) ; while ( k . hasNext ( ) ) { k . next ( ) ; array [ ( int ) round ( k . key ( ) ) ] += k . value ( ) ; } int nbSteps = ( int ) ceil ( ( maxPower - 1 ) / 10 ) ; QVector < double > smoothWattsStep ( nbSteps + 1 ) ; QVector < double > smoothTimeStep ( nbSteps + 1 ) ; int t ; for ( t = 1 ; t < nbSteps ; ++ t ) { int low = t * 10 ; int high = low + 10 ; smoothWattsStep [ t ] = low ; smoothTimeStep [ t ] = minHr ; while ( low < high ) { smoothTimeStep [ t ] += array [ low ++ ] / nbpoints * 300 ; } } smoothTimeStep [ t ] = 0.0 ; smoothWattsStep [ t ] = t * 10 ; wattsStepCurve -> setData ( smoothWattsStep . data ( ) , smoothTimeStep . data ( ) , nbSteps + 1 ) ; } void HrPwPlot :: addHrStepCurve ( QVector < double > & finalHr , int nbpoints ) { QMap < double , double > hrHist ; for ( int h = 0 ; h < nbpoints ; ++ h ) { if ( hrHist . contains ( finalHr [ h ] ) ) hrHist [ finalHr [ h ] ] += 1 ; else hrHist [ finalHr [ h ] ] = 1 ; } int maxHr = 220 ; double * array = new double [ maxHr ] ; for ( int i = 0 ; i < maxHr ; ++ i ) array [ i ] = 0.0 ; QMapIterator < double , double > l ( hrHist ) ; while ( l . hasNext ( ) ) { l . next ( ) ; array [ ( int ) round ( l . key ( ) ) ] += l . value ( ) ; } int nbSteps = ( int ) ceil ( ( maxHr - 1 ) / 2 ) ; QVector < double > smoothHrStep ( nbSteps + 1 ) ; QVector < double > smoothTimeStep2 ( nbSteps + 1 ) ; int t ; for ( t = 1 ; t < nbSteps ; ++ t ) { int low = t * 2 ; int high = low + 2 ; smoothHrStep [ t ] = low ; smoothTimeStep2 [ t ] = 0.0 ; while ( low < high ) { smoothTimeStep2 [ t ] += array [ low ++ ] / nbpoints * 500 ; } } smoothTimeStep2 [ t ] = 0.0 ; smoothHrStep [ t ] = t * 2 ; hrStepCurve -> setData ( smoothTimeStep2 . data ( ) , smoothHrStep . data ( ) , nbSteps + 1 ) ; } void HrPwPlot :: addRegLinCurve ( double rpente , double rordonnee ) { double regWatts [ ] = { 0 , 0 } ; double regHr [ ] = { 0 , 500 } ; regWatts [ 0 ] = regHr [ 0 ] * rpente + rordonnee ; regWatts [ 1 ] = regHr [ 1 ] * rpente + rordonnee ; regCurve -> setData ( regHr , regWatts , 2 ) ; } void HrPwPlot :: setXTitle ( ) { setAxisTitle ( xBottom , tr ( " Power ▁ ( Watts ) " ) ) ; } void HrPwPlot :: setDataFromRide ( RideItem * _rideItem ) { rideItem = _rideItem ; if ( ! _rideItem || ! _rideItem -> ride ( ) ) return ; RideFile * ride = rideItem -> ride ( ) ; const RideFileDataPresent * dataPresent = ride -> areDataPresent ( ) ; int npoints = ride -> dataPoints ( ) . size ( ) ; if ( dataPresent -> watts && dataPresent -> hr ) { wattsArray . resize ( npoints ) ; hrArray . resize ( npoints ) ; timeArray . resize ( npoints ) ; interArray . resize ( npoints ) ; arrayLength = 0 ; foreach ( const RideFilePoint * point , ride -> dataPoints ( ) ) { if ( ! timeArray . empty ( ) ) timeArray [ arrayLength ] = point -> secs ; if ( ! wattsArray . empty ( ) ) wattsArray [ arrayLength ] = max ( 0 , point -> watts ) ; if ( ! hrArray . empty ( ) ) hrArray [ arrayLength ] = max ( 0 , point -> hr ) ; if ( ! interArray . empty ( ) ) interArray [ arrayLength ] = point -> interval ; ++ arrayLength ; } delay = - 1 ; recalc ( ) ; } } void HrPwPlot :: setJoinLine ( bool value ) { joinLine = value ; for ( int i = 0 ; i < 36 ; ++ i ) { QColor color = QColor ( 255 , 255 , 255 ) ; color . setHsv ( 60 + i * ( 360 / 36 ) , 255 , 255 , 255 ) ; if ( value ) { QwtSymbol sym ; sym . setStyle ( QwtSymbol :: NoSymbol ) ; QPen pen = QPen ( color ) ; pen . setWidth ( 1 ) ; hrCurves [ i ] -> setPen ( pen ) ; hrCurves [ i ] -> setStyle ( QwtPlotCurve :: Lines ) ; hrCurves [ i ] -> setSymbol ( new QwtSymbol ( sym ) ) ; } else { QwtSymbol sym ; sym . setStyle ( QwtSymbol :: Ellipse ) ; sym . setSize ( 5 ) ; sym . setPen ( QPen ( color ) ) ; sym . setBrush ( QBrush ( color ) ) ; hrCurves [ i ] -> setPen ( Qt :: NoPen ) ; hrCurves [ i ] -> setStyle ( QwtPlotCurve :: Dots ) ; hrCurves [ i ] -> setSymbol ( new QwtSymbol ( sym ) ) ; } } } void HrPwPlot :: pointHover ( QwtPlotCurve * curve , int index ) { if ( index >= 0 ) { double yvalue = curve -> sample ( index ) . y ( ) ; double xvalue = curve -> sample ( index ) . x ( ) ; QString text = QString ( " % 1 ▁ % 2 \n % 3 ▁ % 4" ) . arg ( yvalue , 0 , ' f ' , 0 ) . arg ( this -> axisTitle ( curve -> yAxis ( ) ) . text ( ) ) . arg ( xvalue , 0 , ' f ' , 2 ) . arg ( this -> axisTitle ( curve -> xAxis ( ) ) . text ( ) ) ; tooltip -> setText ( text ) ; } else { tooltip -> setText ( " " ) ; } } class HrPwPlotBackground : public QwtPlotItem { private : HrPwPlot * parent ; public : HrPwPlotBackground ( HrPwPlot * _parent ) { setZ ( 0.0 ) ; parent = _parent ; } virtual int rtti ( ) const { return QwtPlotItem :: Rtti_PlotUserItem ; } virtual void draw ( QPainter * painter , const QwtScaleMap & xMap , const QwtScaleMap & , const QRectF & rect ) const { RideItem * rideItem = parent -> rideItem ; if ( ! rideItem ) return ; const Zones * zones = rideItem -> zones ; int zone_range = rideItem -> zoneRange ( ) ; if ( parent -> isShadeZones ( ) && zones && ( zone_range >= 0 ) ) { QList < int > zone_lows = zones -> getZoneLows ( zone_range ) ; int num_zones = zone_lows . size ( ) ; if ( num_zones > 0 ) { for ( int z = 0 ; z < num_zones ; z ++ ) { QRectF r = rect ; QColor shading_color = zoneColor ( z , num_zones ) ; shading_color . setHsv ( shading_color . hue ( ) , shading_color . saturation ( ) / 4 , shading_color . value ( ) ) ; r . setLeft ( xMap . transform ( zone_lows [ z ] ) ) ; if ( z + 1 < num_zones ) r . setRight ( xMap . transform ( zone_lows [ z + 1 ] ) ) ; if ( r . left ( ) <= r . right ( ) ) painter -> fillRect ( r , shading_color ) ; } } } } } ; class HrPwPlotZoneLabel : public QwtPlotItem { private : HrPwPlot * parent ; int zone_number ; double watts ; QwtText text ; public : HrPwPlotZoneLabel ( HrPwPlot * _parent , int _zone_number ) { parent = _parent ; zone_number = _zone_number ; RideItem * rideItem = parent -> rideItem ; if ( ! rideItem ) return ; const Zones * zones = rideItem -> zones ; int zone_range = rideItem -> zoneRange ( ) ; if ( parent -> isShadeZones ( ) && zones && ( zone_range >= 0 ) ) { QList < int > zone_lows = zones -> getZoneLows ( zone_range ) ; QList < QString > zone_names = zones -> getZoneNames ( zone_range ) ; int num_zones = zone_lows . size ( ) ; assert ( zone_names . size ( ) == num_zones ) ; if ( zone_number < num_zones ) { watts = ( ( zone_number + 1 < num_zones ) ? 0.5 * ( zone_lows [ zone_number ] + zone_lows [ zone_number + 1 ] ) : ( ( zone_number > 0 ) ? ( 1.5 * zone_lows [ zone_number ] - 0.5 * zone_lows [ zone_number - 1 ] ) : 2.0 * zone_lows [ zone_number ] ) ) ; text = QwtText ( zone_names [ zone_number ] ) ; text . setFont ( QFont ( " Helvetica " , 24 , QFont :: Bold ) ) ; QColor text_color = zoneColor ( zone_number , num_zones ) ; text_color . setAlpha ( 64 ) ; text . setColor ( text_color ) ; } } setZ ( 1.0 + zone_number / 100.0 ) ; } virtual int rtti ( ) const { return QwtPlotItem :: Rtti_PlotUserItem ; } void draw ( QPainter * painter , const QwtScaleMap & xMap , const QwtScaleMap & , const QRectF & rect ) const { if ( parent -> isShadeZones ( ) ) { int y = ( rect . bottom ( ) + rect . top ( ) ) / 2 ; int x = xMap . transform ( watts ) ; QRect tr ( QPoint ( 0 , 0 ) , text . textSize ( painter -> font ( ) ) . toSize ( ) ) ; tr . moveCenter ( QPoint ( x , y ) ) ; text . draw ( painter , tr ) ; } } } ; int HrPwPlot :: isShadeZones ( ) const { return ( shadeZones && ! wattsArray . empty ( ) ) ; } void HrPwPlot :: setShadeZones ( int x ) { shadeZones = x ; } void HrPwPlot :: refreshZoneLabels ( ) { foreach ( HrPwPlotZoneLabel * label , zoneLabels ) { label -> detach ( ) ; delete label ; } zoneLabels . clear ( ) ; if ( bg ) { bg -> detach ( ) ; delete bg ; bg = NULL ; } if ( rideItem ) { int zone_range = rideItem -> zoneRange ( ) ; const Zones * zones = rideItem -> zones ; if ( zones && ( zone_range >= 0 ) ) { int num_zones = zones -> numZones ( zone_range ) ; for ( int z = 0 ; z < num_zones ; z ++ ) { HrPwPlotZoneLabel * label = new HrPwPlotZoneLabel ( this , z ) ; label -> attach ( this ) ; zoneLabels . append ( label ) ; } } } bg = new HrPwPlotBackground ( this ) ; bg -> attach ( this ) ; } </DOCUMENT>
<DOCUMENT_ID="yuhangwang/spii/tree/master/thirdparty/Eigen/demos/opengl/icosphere.cpp"> # include " icosphere . h " # include < GL / gl . h > # include < map > using namespace Eigen ; # define X .525731112119133606 # define Z .850650808352039932 static GLfloat vdata [ 12 ] [ 3 ] = { { - X , 0.0 , Z } , { X , 0.0 , Z } , { - X , 0.0 , - Z } , { X , 0.0 , - Z } , { 0.0 , Z , X } , { 0.0 , Z , - X } , { 0.0 , - Z , X } , { 0.0 , - Z , - X } , { Z , X , 0.0 } , { - Z , X , 0.0 } , { Z , - X , 0.0 } , { - Z , - X , 0.0 } } ; static GLint tindices [ 20 ] [ 3 ] = { { 0 , 4 , 1 } , { 0 , 9 , 4 } , { 9 , 5 , 4 } , { 4 , 5 , 8 } , { 4 , 8 , 1 } , { 8 , 10 , 1 } , { 8 , 3 , 10 } , { 5 , 3 , 8 } , { 5 , 2 , 3 } , { 2 , 7 , 3 } , { 7 , 10 , 3 } , { 7 , 6 , 10 } , { 7 , 11 , 6 } , { 11 , 0 , 6 } , { 0 , 1 , 6 } , { 6 , 1 , 10 } , { 9 , 0 , 11 } , { 9 , 11 , 2 } , { 9 , 2 , 5 } , { 7 , 2 , 11 } } ; IcoSphere :: IcoSphere ( unsigned int levels ) { for ( int i = 0 ; i < 12 ; i ++ ) mVertices . push_back ( Map < Vector3f > ( vdata [ i ] ) ) ; mIndices . push_back ( new std :: vector < int > ) ; std :: vector < int > & indices = * mIndices . back ( ) ; for ( int i = 0 ; i < 20 ; i ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) indices . push_back ( tindices [ i ] [ k ] ) ; } mListIds . push_back ( 0 ) ; while ( mIndices . size ( ) < levels ) _subdivide ( ) ; } const std :: vector < int > & IcoSphere :: indices ( int level ) const { while ( level >= int ( mIndices . size ( ) ) ) const_cast < IcoSphere * > ( this ) -> _subdivide ( ) ; return * mIndices [ level ] ; } void IcoSphere :: _subdivide ( void ) { typedef unsigned long long Key ; std :: map < Key , int > edgeMap ; const std :: vector < int > & indices = * mIndices . back ( ) ; mIndices . push_back ( new std :: vector < int > ) ; std :: vector < int > & refinedIndices = * mIndices . back ( ) ; int end = indices . size ( ) ; for ( int i = 0 ; i < end ; i += 3 ) { int ids0 [ 3 ] , ids1 [ 3 ] ; for ( int k = 0 ; k < 3 ; ++ k ) { int k1 = ( k + 1 ) % 3 ; int e0 = indices [ i + k ] ; int e1 = indices [ i + k1 ] ; ids0 [ k ] = e0 ; if ( e1 > e0 ) std :: swap ( e0 , e1 ) ; Key edgeKey = Key ( e0 ) | ( Key ( e1 ) << 32 ) ; std :: map < Key , int > :: iterator it = edgeMap . find ( edgeKey ) ; if ( it == edgeMap . end ( ) ) { ids1 [ k ] = mVertices . size ( ) ; edgeMap [ edgeKey ] = ids1 [ k ] ; mVertices . push_back ( ( mVertices [ e0 ] + mVertices [ e1 ] ) . normalized ( ) ) ; } else ids1 [ k ] = it -> second ; } refinedIndices . push_back ( ids0 [ 0 ] ) ; refinedIndices . push_back ( ids1 [ 0 ] ) ; refinedIndices . push_back ( ids1 [ 2 ] ) ; refinedIndices . push_back ( ids0 [ 1 ] ) ; refinedIndices . push_back ( ids1 [ 1 ] ) ; refinedIndices . push_back ( ids1 [ 0 ] ) ; refinedIndices . push_back ( ids0 [ 2 ] ) ; refinedIndices . push_back ( ids1 [ 2 ] ) ; refinedIndices . push_back ( ids1 [ 1 ] ) ; refinedIndices . push_back ( ids1 [ 0 ] ) ; refinedIndices . push_back ( ids1 [ 1 ] ) ; refinedIndices . push_back ( ids1 [ 2 ] ) ; } mListIds . push_back ( 0 ) ; } void IcoSphere :: draw ( int level ) { while ( level >= int ( mIndices . size ( ) ) ) const_cast < IcoSphere * > ( this ) -> _subdivide ( ) ; if ( mListIds [ level ] == 0 ) { mListIds [ level ] = glGenLists ( 1 ) ; glNewList ( mListIds [ level ] , GL_COMPILE ) ; glVertexPointer ( 3 , GL_FLOAT , 0 , mVertices [ 0 ] . data ( ) ) ; glNormalPointer ( GL_FLOAT , 0 , mVertices [ 0 ] . data ( ) ) ; glEnableClientState ( GL_VERTEX_ARRAY ) ; glEnableClientState ( GL_NORMAL_ARRAY ) ; glDrawElements ( GL_TRIANGLES , mIndices [ level ] -> size ( ) , GL_UNSIGNED_INT , & ( mIndices [ level ] -> at ( 0 ) ) ) ; glDisableClientState ( GL_VERTEX_ARRAY ) ; glDisableClientState ( GL_NORMAL_ARRAY ) ; glEndList ( ) ; } glCallList ( mListIds [ level ] ) ; } </DOCUMENT>
<DOCUMENT_ID="Deepakpatle/phantomjs/tree/master/src/qt/qtwebkit/Source/JavaScriptCore/dfg/DFGAbstractState.cpp"> # include " config . h " # include " DFGAbstractState . h " # if ENABLE ( DFG_JIT ) # include " CodeBlock . h " # include " DFGBasicBlock . h " # include " GetByIdStatus . h " # include " Operations . h " # include " PutByIdStatus . h " # include " StringObject . h " namespace JSC { namespace DFG { AbstractState :: AbstractState ( Graph & graph ) : m_codeBlock ( graph . m_codeBlock ) , m_graph ( graph ) , m_variables ( m_codeBlock -> numParameters ( ) , graph . m_localVars ) , m_block ( 0 ) { } AbstractState :: ~ AbstractState ( ) { } void AbstractState :: beginBasicBlock ( BasicBlock * basicBlock ) { ASSERT ( ! m_block ) ; ASSERT ( basicBlock -> variablesAtHead . numberOfLocals ( ) == basicBlock -> valuesAtHead . numberOfLocals ( ) ) ; ASSERT ( basicBlock -> variablesAtTail . numberOfLocals ( ) == basicBlock -> valuesAtTail . numberOfLocals ( ) ) ; ASSERT ( basicBlock -> variablesAtHead . numberOfLocals ( ) == basicBlock -> variablesAtTail . numberOfLocals ( ) ) ; for ( size_t i = 0 ; i < basicBlock -> size ( ) ; i ++ ) forNode ( basicBlock -> at ( i ) ) . clear ( ) ; m_variables = basicBlock -> valuesAtHead ; m_haveStructures = false ; for ( size_t i = 0 ; i < m_variables . numberOfArguments ( ) ; ++ i ) { if ( m_variables . argument ( i ) . m_currentKnownStructure . isNeitherClearNorTop ( ) ) { m_haveStructures = true ; break ; } } for ( size_t i = 0 ; i < m_variables . numberOfLocals ( ) ; ++ i ) { if ( m_variables . local ( i ) . m_currentKnownStructure . isNeitherClearNorTop ( ) ) { m_haveStructures = true ; break ; } } basicBlock -> cfaShouldRevisit = false ; basicBlock -> cfaHasVisited = true ; m_block = basicBlock ; m_isValid = true ; m_foundConstants = false ; m_branchDirection = InvalidBranchDirection ; } void AbstractState :: initialize ( Graph & graph ) { BasicBlock * root = graph . m_blocks [ 0 ] . get ( ) ; root -> cfaShouldRevisit = true ; root -> cfaHasVisited = false ; root -> cfaFoundConstants = false ; for ( size_t i = 0 ; i < root -> valuesAtHead . numberOfArguments ( ) ; ++ i ) { Node * node = root -> variablesAtHead . argument ( i ) ; ASSERT ( node -> op ( ) == SetArgument ) ; if ( ! node -> variableAccessData ( ) -> shouldUnboxIfPossible ( ) ) { root -> valuesAtHead . argument ( i ) . makeTop ( ) ; continue ; } SpeculatedType prediction = node -> variableAccessData ( ) -> prediction ( ) ; if ( isInt32Speculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecInt32 ) ; else if ( isBooleanSpeculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecBoolean ) ; else if ( isCellSpeculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecCell ) ; else root -> valuesAtHead . argument ( i ) . makeTop ( ) ; root -> valuesAtTail . argument ( i ) . clear ( ) ; } for ( size_t i = 0 ; i < root -> valuesAtHead . numberOfLocals ( ) ; ++ i ) { Node * node = root -> variablesAtHead . local ( i ) ; if ( node && node -> variableAccessData ( ) -> isCaptured ( ) ) root -> valuesAtHead . local ( i ) . makeTop ( ) ; else root -> valuesAtHead . local ( i ) . clear ( ) ; root -> valuesAtTail . local ( i ) . clear ( ) ; } for ( BlockIndex blockIndex = 1 ; blockIndex < graph . m_blocks . size ( ) ; ++ blockIndex ) { BasicBlock * block = graph . m_blocks [ blockIndex ] . get ( ) ; if ( ! block ) continue ; if ( ! block -> isReachable ) continue ; block -> cfaShouldRevisit = false ; block -> cfaHasVisited = false ; block -> cfaFoundConstants = false ; for ( size_t i = 0 ; i < block -> valuesAtHead . numberOfArguments ( ) ; ++ i ) { block -> valuesAtHead . argument ( i ) . clear ( ) ; block -> valuesAtTail . argument ( i ) . clear ( ) ; } for ( size_t i = 0 ; i < block -> valuesAtHead . numberOfLocals ( ) ; ++ i ) { block -> valuesAtHead . local ( i ) . clear ( ) ; block -> valuesAtTail . local ( i ) . clear ( ) ; } if ( ! block -> isOSRTarget ) continue ; if ( block -> bytecodeBegin != graph . m_osrEntryBytecodeIndex ) continue ; for ( size_t i = 0 ; i < graph . m_mustHandleValues . size ( ) ; ++ i ) { AbstractValue value ; value . setMostSpecific ( graph . m_mustHandleValues [ i ] ) ; int operand = graph . m_mustHandleValues . operandForIndex ( i ) ; block -> valuesAtHead . operand ( operand ) . merge ( value ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ Initializing ▁ Block ▁ # % u , ▁ operand ▁ r % d , ▁ to ▁ " , blockIndex , operand ) ; block -> valuesAtHead . operand ( operand ) . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; # endif } block -> cfaShouldRevisit = true ; } } bool AbstractState :: endBasicBlock ( MergeMode mergeMode ) { ASSERT ( m_block ) ; BasicBlock * block = m_block ; block -> cfaFoundConstants = m_foundConstants ; block -> cfaDidFinish = m_isValid ; block -> cfaBranchDirection = m_branchDirection ; if ( ! m_isValid ) { reset ( ) ; return false ; } bool changed = false ; if ( mergeMode != DontMerge || ! ASSERT_DISABLED ) { for ( size_t argument = 0 ; argument < block -> variablesAtTail . numberOfArguments ( ) ; ++ argument ) { # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ state ▁ for ▁ argument ▁ % zu . \n " , argument ) ; # endif AbstractValue & destination = block -> valuesAtTail . argument ( argument ) ; changed |= mergeStateAtTail ( destination , m_variables . argument ( argument ) , block -> variablesAtTail . argument ( argument ) ) ; } for ( size_t local = 0 ; local < block -> variablesAtTail . numberOfLocals ( ) ; ++ local ) { # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ state ▁ for ▁ local ▁ % zu . \n " , local ) ; # endif AbstractValue & destination = block -> valuesAtTail . local ( local ) ; changed |= mergeStateAtTail ( destination , m_variables . local ( local ) , block -> variablesAtTail . local ( local ) ) ; } } ASSERT ( mergeMode != DontMerge || ! changed ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Branch ▁ direction ▁ = ▁ % s \n " , branchDirectionToString ( m_branchDirection ) ) ; # endif reset ( ) ; if ( mergeMode != MergeToSuccessors ) return changed ; return mergeToSuccessors ( m_graph , block ) ; } void AbstractState :: reset ( ) { m_block = 0 ; m_isValid = false ; m_branchDirection = InvalidBranchDirection ; } AbstractState :: BooleanResult AbstractState :: booleanResult ( Node * node , AbstractValue & value ) { JSValue childConst = value . value ( ) ; if ( childConst ) { if ( childConst . toBoolean ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> globalExec ( ) ) ) return DefinitelyTrue ; return DefinitelyFalse ; } if ( isCellSpeculation ( value . m_type ) && value . m_currentKnownStructure . hasSingleton ( ) ) { Structure * structure = value . m_currentKnownStructure . singleton ( ) ; if ( ! structure -> masqueradesAsUndefined ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) ) && structure -> typeInfo ( ) . type ( ) != StringType ) return DefinitelyTrue ; } return UnknownBooleanResult ; } bool AbstractState :: startExecuting ( Node * node ) { ASSERT ( m_block ) ; ASSERT ( m_isValid ) ; m_didClobber = false ; node -> setCanExit ( false ) ; if ( ! node -> shouldGenerate ( ) ) return false ; return true ; } bool AbstractState :: startExecuting ( unsigned indexInBlock ) { return startExecuting ( m_block -> at ( indexInBlock ) ) ; } void AbstractState :: executeEdges ( Node * node ) { DFG_NODE_DO_TO_CHILDREN ( m_graph , node , filterEdgeByUse ) ; } void AbstractState :: executeEdges ( unsigned indexInBlock ) { executeEdges ( m_block -> at ( indexInBlock ) ) ; } void AbstractState :: verifyEdge ( Node * , Edge edge ) { RELEASE_ASSERT ( ! ( forNode ( edge ) . m_type & ~ typeFilterFor ( edge . useKind ( ) ) ) ) ; } void AbstractState :: verifyEdges ( Node * node ) { DFG_NODE_DO_TO_CHILDREN ( m_graph , node , verifyEdge ) ; } bool AbstractState :: executeEffects ( unsigned indexInBlock , Node * node ) { if ( ! ASSERT_DISABLED ) verifyEdges ( node ) ; switch ( node -> op ( ) ) { case JSConstant : case WeakJSConstant : case PhantomArguments : { forNode ( node ) . set ( m_graph . valueOfJSConstant ( node ) ) ; break ; } case Identity : { forNode ( node ) = forNode ( node -> child1 ( ) ) ; break ; } case GetLocal : { VariableAccessData * variableAccessData = node -> variableAccessData ( ) ; if ( variableAccessData -> prediction ( ) == SpecNone ) { m_isValid = false ; break ; } AbstractValue value = m_variables . operand ( variableAccessData -> local ( ) ) ; if ( ! variableAccessData -> isCaptured ( ) ) { if ( value . isClear ( ) ) node -> setCanExit ( true ) ; } if ( value . value ( ) ) m_foundConstants = true ; forNode ( node ) = value ; break ; } case GetLocalUnlinked : { AbstractValue value = m_variables . operand ( node -> unlinkedLocal ( ) ) ; if ( value . value ( ) ) m_foundConstants = true ; forNode ( node ) = value ; break ; } case SetLocal : { m_variables . operand ( node -> local ( ) ) = forNode ( node -> child1 ( ) ) ; break ; } case MovHintAndCheck : { break ; } case MovHint : case ZombieHint : { RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } case SetArgument : ASSERT ( ! m_block -> valuesAtHead . operand ( node -> local ( ) ) . isClear ( ) ) ; break ; case BitAnd : case BitOr : case BitXor : case BitRShift : case BitLShift : case BitURShift : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isInt32 ( ) && right . isInt32 ( ) ) { int32_t a = left . asInt32 ( ) ; int32_t b = right . asInt32 ( ) ; bool constantWasSet ; switch ( node -> op ( ) ) { case BitAnd : constantWasSet = trySetConstant ( node , JSValue ( a & b ) ) ; break ; case BitOr : constantWasSet = trySetConstant ( node , JSValue ( a | b ) ) ; break ; case BitXor : constantWasSet = trySetConstant ( node , JSValue ( a ^ b ) ) ; break ; case BitRShift : constantWasSet = trySetConstant ( node , JSValue ( a >> static_cast < uint32_t > ( b ) ) ) ; break ; case BitLShift : constantWasSet = trySetConstant ( node , JSValue ( a << static_cast < uint32_t > ( b ) ) ) ; break ; case BitURShift : constantWasSet = trySetConstant ( node , JSValue ( static_cast < uint32_t > ( a ) >> static_cast < uint32_t > ( b ) ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecInt32 ) ; break ; } case UInt32ToNumber : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { ASSERT ( child . isInt32 ( ) ) ; if ( trySetConstant ( node , JSValue ( child . asUInt32 ( ) ) ) ) { m_foundConstants = true ; break ; } } if ( ! node -> canSpeculateInteger ( ) ) forNode ( node ) . set ( SpecDouble ) ; else { forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; } break ; } case DoubleAsInt32 : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { double asDouble = child . asNumber ( ) ; int32_t asInt = JSC :: toInt32 ( asDouble ) ; if ( bitwise_cast < int64_t > ( static_cast < double > ( asInt ) ) == bitwise_cast < int64_t > ( asDouble ) && trySetConstant ( node , JSValue ( asInt ) ) ) { m_foundConstants = true ; break ; } } node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecInt32 ) ; break ; } case ValueToInt32 : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { bool constantWasSet ; if ( child . isInt32 ( ) ) constantWasSet = trySetConstant ( node , child ) ; else constantWasSet = trySetConstant ( node , JSValue ( JSC :: toInt32 ( child . asDouble ( ) ) ) ) ; if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecInt32 ) ; break ; } case Int32ToDouble : case ForwardInt32ToDouble : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( JSValue :: EncodeAsDouble , child . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } if ( isInt32Speculation ( forNode ( node -> child1 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; } case ValueAdd : case ArithAdd : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) + right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : if ( isRealNumberSpeculation ( forNode ( node -> child1 ( ) ) . m_type ) && isRealNumberSpeculation ( forNode ( node -> child2 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT ( node -> op ( ) == ValueAdd ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . set ( SpecString | SpecInt32 | SpecNumber ) ; break ; } break ; } case MakeRope : { forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case ArithSub : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) - right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithNegate : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( - child . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithMul : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) * right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) || ! nodeCanIgnoreNegativeZero ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : if ( isRealNumberSpeculation ( forNode ( node -> child1 ( ) ) . m_type ) || isRealNumberSpeculation ( forNode ( node -> child2 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithIMul : { forNode ( node ) . set ( SpecInt32 ) ; break ; } case ArithDiv : case ArithMin : case ArithMax : case ArithMod : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) ) { double a = left . asNumber ( ) ; double b = right . asNumber ( ) ; bool constantWasSet ; switch ( node -> op ( ) ) { case ArithDiv : constantWasSet = trySetConstant ( node , JSValue ( a / b ) ) ; break ; case ArithMin : constantWasSet = trySetConstant ( node , JSValue ( a < b ? a : ( b <= a ? b : a + b ) ) ) ; break ; case ArithMax : constantWasSet = trySetConstant ( node , JSValue ( a > b ? a : ( b >= a ? b : a + b ) ) ) ; break ; case ArithMod : constantWasSet = trySetConstant ( node , JSValue ( fmod ( a , b ) ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; break ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithAbs : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( fabs ( child . asNumber ( ) ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithSqrt : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( sqrt ( child . asNumber ( ) ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecDouble ) ; break ; } case LogicalNot : { bool didSetConstant = false ; switch ( booleanResult ( node , forNode ( node -> child1 ( ) ) ) ) { case DefinitelyTrue : didSetConstant = trySetConstant ( node , jsBoolean ( false ) ) ; break ; case DefinitelyFalse : didSetConstant = trySetConstant ( node , jsBoolean ( true ) ) ; break ; default : break ; } if ( didSetConstant ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case BooleanUse : case Int32Use : case NumberUse : case UntypedUse : break ; case ObjectOrOtherUse : node -> setCanExit ( true ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( SpecBoolean ) ; break ; } case IsUndefined : case IsBoolean : case IsNumber : case IsString : case IsObject : case IsFunction : { node -> setCanExit ( node -> op ( ) == IsUndefined && m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> masqueradesAsUndefinedWatchpoint ( ) -> isStillValid ( ) ) ; JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child ) { bool constantWasSet ; switch ( node -> op ( ) ) { case IsUndefined : if ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> masqueradesAsUndefinedWatchpoint ( ) -> isStillValid ( ) ) { constantWasSet = trySetConstant ( node , jsBoolean ( child . isCell ( ) ? false : child . isUndefined ( ) ) ) ; } else { constantWasSet = trySetConstant ( node , jsBoolean ( child . isCell ( ) ? child . asCell ( ) -> structure ( ) -> masqueradesAsUndefined ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) ) : child . isUndefined ( ) ) ) ; } break ; case IsBoolean : constantWasSet = trySetConstant ( node , jsBoolean ( child . isBoolean ( ) ) ) ; break ; case IsNumber : constantWasSet = trySetConstant ( node , jsBoolean ( child . isNumber ( ) ) ) ; break ; case IsString : constantWasSet = trySetConstant ( node , jsBoolean ( isJSString ( child ) ) ) ; break ; case IsObject : if ( child . isNull ( ) || ! child . isObject ( ) ) { constantWasSet = trySetConstant ( node , jsBoolean ( child . isNull ( ) ) ) ; break ; } default : constantWasSet = false ; break ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecBoolean ) ; break ; } case TypeOf : { VM * vm = m_codeBlock -> vm ( ) ; JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; AbstractValue & abstractChild = forNode ( node -> child1 ( ) ) ; if ( child ) { JSValue typeString = jsTypeStringForValue ( * vm , m_codeBlock -> globalObjectFor ( node -> codeOrigin ) , child ) ; if ( trySetConstant ( node , typeString ) ) { m_foundConstants = true ; break ; } } else if ( isNumberSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . numberString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecNumber ) ; m_foundConstants = true ; break ; } } else if ( isStringSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . stringString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecString ) ; m_foundConstants = true ; break ; } } else if ( isFinalObjectSpeculation ( abstractChild . m_type ) || isArraySpeculation ( abstractChild . m_type ) || isArgumentsSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . objectString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecFinalObject | SpecArray | SpecArguments ) ; m_foundConstants = true ; break ; } } else if ( isFunctionSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . functionString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecFunction ) ; m_foundConstants = true ; break ; } } else if ( isBooleanSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . booleanString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecBoolean ) ; m_foundConstants = true ; break ; } } switch ( node -> child1 ( ) . useKind ( ) ) { case StringUse : case CellUse : node -> setCanExit ( true ) ; break ; case UntypedUse : break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case CompareLess : case CompareLessEq : case CompareGreater : case CompareGreaterEq : case CompareEq : case CompareEqConstant : { bool constantWasSet = false ; JSValue leftConst = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue rightConst = forNode ( node -> child2 ( ) ) . value ( ) ; if ( leftConst && rightConst && leftConst . isNumber ( ) && rightConst . isNumber ( ) ) { double a = leftConst . asNumber ( ) ; double b = rightConst . asNumber ( ) ; switch ( node -> op ( ) ) { case CompareLess : constantWasSet = trySetConstant ( node , jsBoolean ( a < b ) ) ; break ; case CompareLessEq : constantWasSet = trySetConstant ( node , jsBoolean ( a <= b ) ) ; break ; case CompareGreater : constantWasSet = trySetConstant ( node , jsBoolean ( a > b ) ) ; break ; case CompareGreaterEq : constantWasSet = trySetConstant ( node , jsBoolean ( a >= b ) ) ; break ; case CompareEq : constantWasSet = trySetConstant ( node , jsBoolean ( a == b ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; break ; } } if ( ! constantWasSet && ( node -> op ( ) == CompareEqConstant || node -> op ( ) == CompareEq ) ) { SpeculatedType leftType = forNode ( node -> child1 ( ) ) . m_type ; SpeculatedType rightType = forNode ( node -> child2 ( ) ) . m_type ; if ( ( isInt32Speculation ( leftType ) && isOtherSpeculation ( rightType ) ) || ( isOtherSpeculation ( leftType ) && isInt32Speculation ( rightType ) ) ) constantWasSet = trySetConstant ( node , jsBoolean ( false ) ) ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecBoolean ) ; node -> setCanExit ( true ) ; break ; } case CompareStrictEq : case CompareStrictEqConstant : { Node * leftNode = node -> child1 ( ) . node ( ) ; Node * rightNode = node -> child2 ( ) . node ( ) ; JSValue left = forNode ( leftNode ) . value ( ) ; JSValue right = forNode ( rightNode ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , jsBoolean ( left . asNumber ( ) == right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecBoolean ) ; node -> setCanExit ( true ) ; break ; } case StringCharCodeAt : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecInt32 ) ; break ; case StringFromCharCode : forNode ( node ) . set ( SpecString ) ; break ; case StringCharAt : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; case GetByVal : { node -> setCanExit ( true ) ; switch ( node -> arrayMode ( ) . type ( ) ) { case Array :: SelectUsingPredictions : case Array :: Unprofiled : case Array :: Undecided : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; case Array :: ForceExit : m_isValid = false ; break ; case Array :: Generic : clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case Array :: String : forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; case Array :: Arguments : forNode ( node ) . makeTop ( ) ; break ; case Array :: Int32 : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) { clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; } else forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Double : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) { clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; } else if ( node -> arrayMode ( ) . isSaneChain ( ) ) forNode ( node ) . set ( SpecDouble ) ; else forNode ( node ) . set ( SpecDoubleReal ) ; break ; case Array :: Contiguous : case Array :: ArrayStorage : case Array :: SlowPutArrayStorage : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case Array :: Int8Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Int16Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Int32Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint8Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint8ClampedArray : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint16Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint32Array : if ( node -> shouldSpeculateInteger ( ) ) forNode ( node ) . set ( SpecInt32 ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; case Array :: Float32Array : forNode ( node ) . set ( SpecDouble ) ; break ; case Array :: Float64Array : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case PutByVal : case PutByValAlias : { node -> setCanExit ( true ) ; switch ( node -> arrayMode ( ) . modeForPut ( ) . type ( ) ) { case Array :: ForceExit : m_isValid = false ; break ; case Array :: Generic : clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Int32 : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Double : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Contiguous : case Array :: ArrayStorage : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: SlowPutArrayStorage : if ( node -> arrayMode ( ) . mayStoreToHole ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; default : break ; } break ; } case ArrayPush : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . set ( SpecNumber ) ; break ; case ArrayPop : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case RegExpExec : forNode ( node ) . makeTop ( ) ; break ; case RegExpTest : forNode ( node ) . set ( SpecBoolean ) ; break ; case Jump : break ; case Branch : { Node * child = node -> child1 ( ) . node ( ) ; BooleanResult result = booleanResult ( node , forNode ( child ) ) ; if ( result == DefinitelyTrue ) { m_branchDirection = TakeTrue ; break ; } if ( result == DefinitelyFalse ) { m_branchDirection = TakeFalse ; break ; } node -> setCanExit ( true ) ; m_branchDirection = TakeBoth ; break ; } case Return : m_isValid = false ; break ; case Throw : case ThrowReferenceError : m_isValid = false ; node -> setCanExit ( true ) ; break ; case ToPrimitive : { JSValue childConst = forNode ( node -> child1 ( ) ) . value ( ) ; if ( childConst && childConst . isNumber ( ) && trySetConstant ( node , childConst ) ) { m_foundConstants = true ; break ; } ASSERT ( node -> child1 ( ) . useKind ( ) == UntypedUse ) ; AbstractValue & source = forNode ( node -> child1 ( ) ) ; AbstractValue & destination = forNode ( node ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; SpeculatedType type = source . m_type ; if ( type & ~ ( SpecNumber | SpecString | SpecBoolean ) ) { type &= ( SpecNumber | SpecString | SpecBoolean ) ; type |= SpecString ; } destination . set ( type ) ; break ; } case ToString : { switch ( node -> child1 ( ) . useKind ( ) ) { case StringObjectUse : forNode ( node -> child1 ( ) ) . filter ( m_graph . globalObjectFor ( node -> codeOrigin ) -> stringObjectStructure ( ) ) ; node -> setCanExit ( true ) ; break ; case StringOrStringObjectUse : node -> setCanExit ( true ) ; break ; case CellUse : case UntypedUse : clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case NewStringObject : { ASSERT ( node -> structure ( ) -> classInfo ( ) == & StringObject :: s_info ) ; forNode ( node ) . set ( node -> structure ( ) ) ; break ; } case NewArray : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> arrayStructureForIndexingTypeDuringAllocation ( node -> indexingType ( ) ) ) ; m_haveStructures = true ; break ; case NewArrayBuffer : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> arrayStructureForIndexingTypeDuringAllocation ( node -> indexingType ( ) ) ) ; m_haveStructures = true ; break ; case NewArrayWithSize : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecArray ) ; m_haveStructures = true ; break ; case NewRegexp : forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> regExpStructure ( ) ) ; m_haveStructures = true ; break ; case ConvertThis : { AbstractValue & source = forNode ( node -> child1 ( ) ) ; AbstractValue & destination = forNode ( node ) ; destination = source ; destination . merge ( SpecObjectOther ) ; break ; } case CreateThis : { forNode ( node ) . set ( SpecFinalObject ) ; break ; } case AllocationProfileWatchpoint : node -> setCanExit ( true ) ; break ; case NewObject : forNode ( node ) . set ( node -> structure ( ) ) ; m_haveStructures = true ; break ; case CreateActivation : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> activationStructure ( ) ) ; m_haveStructures = true ; break ; case CreateArguments : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> argumentsStructure ( ) ) ; m_haveStructures = true ; break ; case TearOffActivation : case TearOffArguments : break ; case CheckArgumentsNotCreated : if ( isEmptySpeculation ( m_variables . operand ( m_graph . argumentsRegisterFor ( node -> codeOrigin ) ) . m_type ) ) m_foundConstants = true ; else node -> setCanExit ( true ) ; break ; case GetMyArgumentsLength : if ( node -> codeOrigin . inlineCallFrame ) forNode ( node ) . set ( jsNumber ( node -> codeOrigin . inlineCallFrame -> arguments . size ( ) - 1 ) ) ; else forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( ! isEmptySpeculation ( m_variables . operand ( m_graph . argumentsRegisterFor ( node -> codeOrigin ) ) . m_type ) ) ; break ; case GetMyArgumentsLengthSafe : clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case GetMyArgumentByVal : node -> setCanExit ( true ) ; forNode ( node ) . makeTop ( ) ; break ; case GetMyArgumentByValSafe : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case NewFunction : { AbstractValue & value = forNode ( node ) ; value = forNode ( node -> child1 ( ) ) ; if ( ! ( value . m_type & SpecEmpty ) ) { m_foundConstants = true ; break ; } value . set ( ( value . m_type & ~ SpecEmpty ) | SpecFunction ) ; break ; } case NewFunctionExpression : case NewFunctionNoCheck : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> functionStructure ( ) ) ; break ; case GetCallee : forNode ( node ) . set ( SpecFunction ) ; break ; case SetCallee : case SetMyScope : break ; case GetScope : case GetMyScope : case SkipTopScope : forNode ( node ) . set ( SpecCellOther ) ; break ; case SkipScope : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && trySetConstant ( node , JSValue ( jsCast < JSScope * > ( child . asCell ( ) ) -> next ( ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecCellOther ) ; break ; } case GetScopeRegisters : forNode ( node ) . clear ( ) ; break ; case GetScopedVar : forNode ( node ) . makeTop ( ) ; break ; case PutScopedVar : clobberCapturedVars ( node -> codeOrigin ) ; break ; case GetById : case GetByIdFlush : node -> setCanExit ( true ) ; if ( ! node -> prediction ( ) ) { m_isValid = false ; break ; } if ( isCellSpeculation ( node -> child1 ( ) -> prediction ( ) ) ) { if ( Structure * structure = forNode ( node -> child1 ( ) ) . bestProvenStructure ( ) ) { GetByIdStatus status = GetByIdStatus :: computeFor ( m_graph . m_vm , structure , m_graph . m_codeBlock -> identifier ( node -> identifierNumber ( ) ) ) ; if ( status . isSimple ( ) ) { ASSERT ( status . structureSet ( ) . size ( ) == 1 ) ; ASSERT ( status . chain ( ) . isEmpty ( ) ) ; if ( status . specificValue ( ) ) forNode ( node ) . set ( status . specificValue ( ) ) ; else forNode ( node ) . makeTop ( ) ; forNode ( node -> child1 ( ) ) . filter ( status . structureSet ( ) ) ; m_foundConstants = true ; break ; } } } clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case GetArrayLength : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecInt32 ) ; break ; case CheckExecutable : { node -> setCanExit ( true ) ; break ; } case CheckStructure : case ForwardCheckStructure : { AbstractValue & value = forNode ( node -> child1 ( ) ) ; ASSERT ( ! ( value . m_type & ~ SpecCell ) ) ; StructureSet & set = node -> structureSet ( ) ; if ( value . m_futurePossibleStructure . isSubsetOf ( set ) || value . m_currentKnownStructure . isSubsetOf ( set ) ) m_foundConstants = true ; if ( ! value . m_currentKnownStructure . isSubsetOf ( set ) ) node -> setCanExit ( true ) ; value . filter ( set ) ; m_haveStructures = true ; break ; } case StructureTransitionWatchpoint : case ForwardStructureTransitionWatchpoint : { AbstractValue & value = forNode ( node -> child1 ( ) ) ; ASSERT ( value . m_futurePossibleStructure . isSubsetOf ( StructureSet ( node -> structure ( ) ) ) ) ; value . filter ( node -> structure ( ) ) ; m_haveStructures = true ; node -> setCanExit ( true ) ; break ; } case PutStructure : case PhantomPutStructure : if ( ! forNode ( node -> child1 ( ) ) . m_currentKnownStructure . isClear ( ) ) { clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . set ( node -> structureTransitionData ( ) . newStructure ) ; m_haveStructures = true ; } break ; case GetButterfly : case AllocatePropertyStorage : case ReallocatePropertyStorage : forNode ( node ) . clear ( ) ; break ; case CheckArray : { if ( node -> arrayMode ( ) . alreadyChecked ( m_graph , node , forNode ( node -> child1 ( ) ) ) ) { m_foundConstants = true ; break ; } node -> setCanExit ( true ) ; switch ( node -> arrayMode ( ) . type ( ) ) { case Array :: String : forNode ( node -> child1 ( ) ) . filter ( SpecString ) ; break ; case Array :: Int32 : case Array :: Double : case Array :: Contiguous : case Array :: ArrayStorage : case Array :: SlowPutArrayStorage : break ; case Array :: Arguments : forNode ( node -> child1 ( ) ) . filter ( SpecArguments ) ; break ; case Array :: Int8Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt8Array ) ; break ; case Array :: Int16Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt16Array ) ; break ; case Array :: Int32Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt32Array ) ; break ; case Array :: Uint8Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint8Array ) ; break ; case Array :: Uint8ClampedArray : forNode ( node -> child1 ( ) ) . filter ( SpecUint8ClampedArray ) ; break ; case Array :: Uint16Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint16Array ) ; break ; case Array :: Uint32Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint32Array ) ; break ; case Array :: Float32Array : forNode ( node -> child1 ( ) ) . filter ( SpecFloat32Array ) ; break ; case Array :: Float64Array : forNode ( node -> child1 ( ) ) . filter ( SpecFloat64Array ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node -> child1 ( ) ) . filterArrayModes ( node -> arrayMode ( ) . arrayModesThatPassFiltering ( ) ) ; m_haveStructures = true ; break ; } case Arrayify : { if ( node -> arrayMode ( ) . alreadyChecked ( m_graph , node , forNode ( node -> child1 ( ) ) ) ) { m_foundConstants = true ; break ; } ASSERT ( node -> arrayMode ( ) . conversion ( ) == Array :: Convert || node -> arrayMode ( ) . conversion ( ) == Array :: RageConvert ) ; node -> setCanExit ( true ) ; clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . filterArrayModes ( node -> arrayMode ( ) . arrayModesThatPassFiltering ( ) ) ; m_haveStructures = true ; break ; } case ArrayifyToStructure : { AbstractValue & value = forNode ( node -> child1 ( ) ) ; StructureSet set = node -> structure ( ) ; if ( value . m_futurePossibleStructure . isSubsetOf ( set ) || value . m_currentKnownStructure . isSubsetOf ( set ) ) m_foundConstants = true ; node -> setCanExit ( true ) ; clobberStructures ( indexInBlock ) ; value . filter ( set ) ; m_haveStructures = true ; break ; } case GetIndexedPropertyStorage : { forNode ( node ) . clear ( ) ; break ; } case GetByOffset : { forNode ( node ) . makeTop ( ) ; break ; } case PutByOffset : { break ; } case CheckFunction : { JSValue value = forNode ( node -> child1 ( ) ) . value ( ) ; if ( value == node -> function ( ) ) { m_foundConstants = true ; ASSERT ( value ) ; break ; } node -> setCanExit ( true ) ; forNode ( node -> child1 ( ) ) . filterByValue ( node -> function ( ) ) ; break ; } case PutById : case PutByIdDirect : node -> setCanExit ( true ) ; if ( Structure * structure = forNode ( node -> child1 ( ) ) . bestProvenStructure ( ) ) { PutByIdStatus status = PutByIdStatus :: computeFor ( m_graph . m_vm , m_graph . globalObjectFor ( node -> codeOrigin ) , structure , m_graph . m_codeBlock -> identifier ( node -> identifierNumber ( ) ) , node -> op ( ) == PutByIdDirect ) ; if ( status . isSimpleReplace ( ) ) { forNode ( node -> child1 ( ) ) . filter ( structure ) ; m_foundConstants = true ; break ; } if ( status . isSimpleTransition ( ) ) { clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . set ( status . newStructure ( ) ) ; m_haveStructures = true ; m_foundConstants = true ; break ; } } clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case GetGlobalVar : forNode ( node ) . makeTop ( ) ; break ; case GlobalVarWatchpoint : node -> setCanExit ( true ) ; break ; case PutGlobalVar : case PutGlobalVarCheck : break ; case CheckHasInstance : node -> setCanExit ( true ) ; break ; case InstanceOf : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecBoolean ) ; break ; case Phi : case Flush : case PhantomLocal : case Breakpoint : break ; case Call : case Construct : case Resolve : case ResolveBase : case ResolveBaseStrictPut : case ResolveGlobal : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case GarbageValue : clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case ForceOSRExit : node -> setCanExit ( true ) ; m_isValid = false ; break ; case CheckWatchdogTimer : node -> setCanExit ( true ) ; break ; case Phantom : case InlineStart : case Nop : case CountExecution : break ; case LastNodeType : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } return m_isValid ; } bool AbstractState :: executeEffects ( unsigned indexInBlock ) { return executeEffects ( indexInBlock , m_block -> at ( indexInBlock ) ) ; } bool AbstractState :: execute ( unsigned indexInBlock ) { Node * node = m_block -> at ( indexInBlock ) ; if ( ! startExecuting ( node ) ) return true ; executeEdges ( node ) ; return executeEffects ( indexInBlock , node ) ; } inline void AbstractState :: clobberWorld ( const CodeOrigin & codeOrigin , unsigned indexInBlock ) { clobberCapturedVars ( codeOrigin ) ; clobberStructures ( indexInBlock ) ; } inline void AbstractState :: clobberCapturedVars ( const CodeOrigin & codeOrigin ) { if ( codeOrigin . inlineCallFrame ) { const BitVector & capturedVars = codeOrigin . inlineCallFrame -> capturedVars ; for ( size_t i = capturedVars . size ( ) ; i -- ; ) { if ( ! capturedVars . quickGet ( i ) ) continue ; m_variables . local ( i ) . makeTop ( ) ; } } else { for ( size_t i = m_codeBlock -> m_numVars ; i -- ; ) { if ( m_codeBlock -> isCaptured ( i ) ) m_variables . local ( i ) . makeTop ( ) ; } } for ( size_t i = m_variables . numberOfArguments ( ) ; i -- ; ) { if ( m_codeBlock -> isCaptured ( argumentToOperand ( i ) ) ) m_variables . argument ( i ) . makeTop ( ) ; } } inline void AbstractState :: clobberStructures ( unsigned indexInBlock ) { if ( ! m_haveStructures ) return ; for ( size_t i = indexInBlock + 1 ; i -- ; ) forNode ( m_block -> at ( i ) ) . clobberStructures ( ) ; for ( size_t i = m_variables . numberOfArguments ( ) ; i -- ; ) m_variables . argument ( i ) . clobberStructures ( ) ; for ( size_t i = m_variables . numberOfLocals ( ) ; i -- ; ) m_variables . local ( i ) . clobberStructures ( ) ; m_haveStructures = false ; m_didClobber = true ; } inline bool AbstractState :: mergeStateAtTail ( AbstractValue & destination , AbstractValue & inVariable , Node * node ) { if ( ! node ) return false ; AbstractValue source ; if ( node -> variableAccessData ( ) -> isCaptured ( ) ) { source = inVariable ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Transfering ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " ▁ from ▁ last ▁ access ▁ due ▁ to ▁ captured ▁ variable . \n " ) ; # endif } else { # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ It ' s ▁ live , ▁ node ▁ @ % u . \n " , node -> index ( ) ) ; # endif switch ( node -> op ( ) ) { case Phi : case SetArgument : case PhantomLocal : case Flush : source = inVariable ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Transfering ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " ▁ from ▁ head ▁ to ▁ tail . \n " ) ; # endif break ; case GetLocal : source = forNode ( node ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Refining ▁ to ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; # endif break ; case SetLocal : if ( node -> variableAccessData ( ) -> shouldUseDoubleFormat ( ) ) { source . set ( SpecDouble ) ; } else source = forNode ( node -> child1 ( ) ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Setting ▁ to ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; # endif break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } } if ( destination == source ) { # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Not ▁ changed ! \n " ) ; # endif return false ; } destination = source ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Changed ! \n " ) ; # endif return true ; } inline bool AbstractState :: merge ( BasicBlock * from , BasicBlock * to ) { ASSERT ( from -> variablesAtTail . numberOfArguments ( ) == to -> variablesAtHead . numberOfArguments ( ) ) ; ASSERT ( from -> variablesAtTail . numberOfLocals ( ) == to -> variablesAtHead . numberOfLocals ( ) ) ; bool changed = false ; for ( size_t argument = 0 ; argument < from -> variablesAtTail . numberOfArguments ( ) ; ++ argument ) { AbstractValue & destination = to -> valuesAtHead . argument ( argument ) ; changed |= mergeVariableBetweenBlocks ( destination , from -> valuesAtTail . argument ( argument ) , to -> variablesAtHead . argument ( argument ) , from -> variablesAtTail . argument ( argument ) ) ; } for ( size_t local = 0 ; local < from -> variablesAtTail . numberOfLocals ( ) ; ++ local ) { AbstractValue & destination = to -> valuesAtHead . local ( local ) ; changed |= mergeVariableBetweenBlocks ( destination , from -> valuesAtTail . local ( local ) , to -> variablesAtHead . local ( local ) , from -> variablesAtTail . local ( local ) ) ; } if ( ! to -> cfaHasVisited ) changed = true ; to -> cfaShouldRevisit |= changed ; return changed ; } inline bool AbstractState :: mergeToSuccessors ( Graph & graph , BasicBlock * basicBlock ) { Node * terminal = basicBlock -> last ( ) ; ASSERT ( terminal -> isTerminal ( ) ) ; switch ( terminal -> op ( ) ) { case Jump : { ASSERT ( basicBlock -> cfaBranchDirection == InvalidBranchDirection ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> takenBlockIndex ( ) ) ; # endif return merge ( basicBlock , graph . m_blocks [ terminal -> takenBlockIndex ( ) ] . get ( ) ) ; } case Branch : { ASSERT ( basicBlock -> cfaBranchDirection != InvalidBranchDirection ) ; bool changed = false ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> takenBlockIndex ( ) ) ; # endif if ( basicBlock -> cfaBranchDirection != TakeFalse ) changed |= merge ( basicBlock , graph . m_blocks [ terminal -> takenBlockIndex ( ) ] . get ( ) ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> notTakenBlockIndex ( ) ) ; # endif if ( basicBlock -> cfaBranchDirection != TakeTrue ) changed |= merge ( basicBlock , graph . m_blocks [ terminal -> notTakenBlockIndex ( ) ] . get ( ) ) ; return changed ; } case Return : case Throw : case ThrowReferenceError : ASSERT ( basicBlock -> cfaBranchDirection == InvalidBranchDirection ) ; return false ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; return false ; } } inline bool AbstractState :: mergeVariableBetweenBlocks ( AbstractValue & destination , AbstractValue & source , Node * destinationNode , Node * sourceNode ) { if ( ! destinationNode ) return false ; ASSERT_UNUSED ( sourceNode , sourceNode ) ; return destination . merge ( source ) ; } void AbstractState :: dump ( PrintStream & out ) { bool first = true ; for ( size_t i = 0 ; i < m_block -> size ( ) ; ++ i ) { Node * node = m_block -> at ( i ) ; AbstractValue & value = forNode ( node ) ; if ( value . isClear ( ) ) continue ; if ( first ) first = false ; else out . printf ( " ▁ " ) ; out . printf ( " @ % lu : " , static_cast < unsigned long > ( node -> index ( ) ) ) ; value . dump ( out ) ; } } } } # endif </DOCUMENT>
<DOCUMENT_ID="Microsoft/PTVS/tree/master/Python/Tests/GlassTests/PythonTests/Python/StepPythonToNative_IterNext/cpp_mod.cpp"> # pragma optimize ( " " , off ) # include < python . h > struct CppObj { PyObject_HEAD } ; PyObject * CppObj_iternext ( PyObject * self ) { Py_RETURN_NONE ; } PyTypeObject * CppObj_type ( ) { static PyTypeObject t = { PyVarObject_HEAD_INIT ( NULL , 0 ) } ; t . tp_name = " cpp _ mod . CppObj " ; t . tp_basicsize = sizeof CppObj ; t . tp_flags = Py_TPFLAGS_DEFAULT ; t . tp_iternext = CppObj_iternext ; return & t ; } PyMethodDef methods [ ] = { NULL } ; PyTypeObject * types [ ] = { CppObj_type ( ) , NULL } ; </DOCUMENT>
<DOCUMENT_ID="brunolauze/MonoNative/tree/master/MonoNative/mscorlib/System/Runtime/Remoting/Metadata/W3cXsd2001/mscorlib_System_Runtime_Remoting_Metadata_W3cXsd2001_SoapNmtoken.cpp"> # include < mscorlib / System / Runtime / Remoting / Metadata / W3cXsd2001 / mscorlib_System_Runtime_Remoting_Metadata_W3cXsd2001_SoapNmtoken . h > # include < mscorlib / System / mscorlib_System_Type . h > namespace mscorlib { namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 { Property < mscorlib :: System :: String , mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken > mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken :: XsdType ( & mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken :: get_XsdType , & mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken :: set_XsdType ) ; mscorlib :: System :: String SoapNmtoken :: GetXsdType ( ) { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " GetXsdType " , __native_object__ , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; } mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken SoapNmtoken :: Parse ( mscorlib :: System :: String value ) { MonoType * __parameter_types__ [ 1 ] ; void * __parameters__ [ 1 ] ; __parameter_types__ [ 0 ] = Global :: GetType ( typeid ( value ) . name ( ) ) ; __parameters__ [ 0 ] = ( MonoObject * ) value ; MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " Parse " , NullMonoObject , 1 , __parameter_types__ , __parameters__ , NULL ) ; return mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken ( __result__ ) ; } mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken SoapNmtoken :: Parse ( const char * value ) { MonoType * __parameter_types__ [ 1 ] ; void * __parameters__ [ 1 ] ; __parameter_types__ [ 0 ] = Global :: GetType ( " mscorlib " , " System " , " String " ) ; __parameters__ [ 0 ] = mono_string_new ( Global :: GetDomain ( ) , value ) ; MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " Parse " , NullMonoObject , 1 , __parameter_types__ , __parameters__ , NULL ) ; return mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken ( __result__ ) ; } mscorlib :: System :: String SoapNmtoken :: ToString ( ) { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " ToString " , __native_object__ , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; } mscorlib :: System :: String SoapNmtoken :: get_Value ( ) const { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " get _ Value " , __native_object__ , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; } void SoapNmtoken :: set_Value ( mscorlib :: System :: String value ) { MonoType * __parameter_types__ [ 1 ] ; void * __parameters__ [ 1 ] ; __parameter_types__ [ 0 ] = Global :: GetType ( typeid ( value ) . name ( ) ) ; __parameters__ [ 0 ] = ( MonoObject * ) value ; Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " set _ Value " , __native_object__ , 1 , __parameter_types__ , __parameters__ , NULL ) ; } mscorlib :: System :: String SoapNmtoken :: get_XsdType ( ) { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " get _ XsdType " , NullMonoObject , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; } void SoapNmtoken :: set_XsdType ( mscorlib :: System :: String value ) { throw ; } } } } } } } </DOCUMENT>
<DOCUMENT_ID="JIghtuse/functional-cpp/tree/master/src/functional_objects/company.cpp"> # include < company . h > # include < algorithm > class lambda_implementation { public : lambda_implementation ( const Company * _this , const std :: string & teamName ) : m_this { _this } , m_teamName { teamName } { } bool operator ( ) ( const Person & employee ) const { return m_this -> teamNameFor ( employee ) == m_teamName ; } private : const Company * m_this ; const std :: string & m_teamName ; } ; int Company :: countTeamMembers ( const std :: string & teamName ) const { return std :: count_if ( m_employees . cbegin ( ) , m_employees . cend ( ) , [ this , & teamName ] ( const Person & p ) { return teamNameFor ( p ) == teamName ; } ) ; } std :: string Company :: teamNameFor ( const Person & ) const { return " some " ; } </DOCUMENT>
<DOCUMENT_ID="MattMulhern/OpenMamaCassandra/tree/master/mamda/c_cpp/src/examples/parsecmd.cpp"> # include < mama / mama . h > # include < mama / mamacpp . h > # include < mama / MamaTransport . h > # include " parsecmd . h " # include < fstream > # include < iostream > # include < string > # include < map > # include < string . h > # include < mamda / MamdaVersion . h > using std :: ifstream ; using std :: cerr ; using std :: string ; using std :: map ; using namespace Wombat ; typedef map < string , const char * > OptionMap ; extern void usage ( int ) ; ExampleLogLevel gExampleLogLevel = EXAMPLE_LOG_LEVEL_NORMAL ; struct CommonCommandLineParser :: CommonCommandLineParserImpl { CommonCommandLineParserImpl ( int argc , const char * argv [ ] ) ; const char * mSourceName ; const char * mTportName ; MamaSource * mSource ; const char * mDictSourceName ; const char * mDictTportName ; const char * mDictFileName ; MamaSource * mDictSource ; const char * mOptionSourceName ; const char * mOptionTportName ; MamaSource * mOptionSource ; const char * mSymbolMapFile ; vector < const char * > mSymbolList ; double mThrottleRate ; int mThreads ; double mTimeout ; MamaLogLevel mSubscLogLevel ; OptionMap mOptions ; bool mLogReqResp ; bool mUseWorldView ; const char * mSymbology ; int mChurnRate ; double mTimerInterval ; const char * mLogFileName ; const char * mMiddleware ; int mPrecision ; int mShutdownTime ; bool mShowDeltas ; mamaBridge mBridge ; bool mSnapShot ; const char * mQueryArg1 ; const char * mQueryArg2 ; const char * mQueryArg3 ; const char * mQueryArg4 ; int mQuery ; int mQueryType ; int mQueryCycles ; bool mPublishRecaps ; } ; CommonCommandLineParser :: CommonCommandLineParser ( int argc , const char * argv [ ] ) : mImpl ( * new CommonCommandLineParserImpl ( argc , argv ) ) { } CommonCommandLineParser :: ~ CommonCommandLineParser ( ) { delete & mImpl ; } bool CommonCommandLineParser :: getPublishRecaps ( ) { return mImpl . mPublishRecaps ; } MamaSource * CommonCommandLineParser :: getSource ( ) { if ( ! mImpl . mSource ) { mImpl . mSource = new MamaSource ( " default " , mImpl . mTportName , mImpl . mSourceName , mImpl . mBridge ) ; mImpl . mSource -> getTransport ( ) -> setOutboundThrottle ( mImpl . mThrottleRate , MAMA_THROTTLE_DEFAULT ) ; } return mImpl . mSource ; } MamaSource * CommonCommandLineParser :: getDictSource ( ) { if ( ! mImpl . mDictSource ) { mImpl . mDictSource = new MamaSource ( " dict " , mImpl . mDictTportName ? mImpl . mDictTportName : mImpl . mTportName , mImpl . mDictSourceName , mImpl . mBridge ) ; } return mImpl . mDictSource ; } MamaSource * CommonCommandLineParser :: getOptionSource ( ) { if ( ! mImpl . mOptionSource ) { mImpl . mOptionSource = new MamaSource ( " options " , mImpl . mOptionTportName ? mImpl . mOptionTportName : mImpl . mTportName , mImpl . mOptionSourceName , mImpl . mBridge ) ; mImpl . mOptionSource -> getTransport ( ) -> setOutboundThrottle ( mImpl . mThrottleRate , MAMA_THROTTLE_DEFAULT ) ; } return mImpl . mOptionSource ; } const char * CommonCommandLineParser :: getSymbolMapFile ( ) { return mImpl . mSymbolMapFile ; } const vector < const char * > & CommonCommandLineParser :: getSymbolList ( ) { return mImpl . mSymbolList ; } double CommonCommandLineParser :: getThrottleRate ( ) { return mImpl . mThrottleRate ; } int CommonCommandLineParser :: getNumThreads ( ) { return mImpl . mThreads ; } double CommonCommandLineParser :: getTimeout ( ) { return mImpl . mTimeout ; } MamaLogLevel CommonCommandLineParser :: getSubscLogLevel ( ) { return mImpl . mSubscLogLevel ; } bool CommonCommandLineParser :: getUseWorldview ( ) { return mImpl . mUseWorldView ; } bool CommonCommandLineParser :: getLogReqResp ( ) { return mImpl . mLogReqResp ; } const char * CommonCommandLineParser :: getSymbology ( ) { return mImpl . mSymbology ; } const char * CommonCommandLineParser :: getMiddleware ( ) { return mImpl . mMiddleware ; } int CommonCommandLineParser :: getPrecision ( ) { return mImpl . mPrecision ; } int CommonCommandLineParser :: getShutdownTime ( ) { return mImpl . mShutdownTime ; } bool CommonCommandLineParser :: showDeltas ( ) { return mImpl . mShowDeltas ; } mamaBridge CommonCommandLineParser :: getBridge ( ) { return mImpl . mBridge ; } bool CommonCommandLineParser :: getSnapshot ( ) { return mImpl . mSnapShot ; } bool CommonCommandLineParser :: getOptBool ( char option0 ) { string option ( & option0 , 0 , 1 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; return ( found != mImpl . mOptions . end ( ) ) ; } bool CommonCommandLineParser :: getOptBool ( const char * option0 ) { string option ( option0 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; return ( found != mImpl . mOptions . end ( ) ) ; } int CommonCommandLineParser :: getOptInt ( char option0 , int defaultValue ) { string option ( & option0 , 0 , 1 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; if ( found != mImpl . mOptions . end ( ) ) { const char * value = found -> second ; if ( value ) return strtol ( value , NULL , 10 ) ; } return defaultValue ; } int CommonCommandLineParser :: getOptInt ( const char * option0 , int defaultValue ) { string option ( option0 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; if ( found != mImpl . mOptions . end ( ) ) { const char * value = found -> second ; if ( value ) return strtol ( value , NULL , 10 ) ; } return defaultValue ; } const char * CommonCommandLineParser :: getOptString ( char option0 ) { string option ( & option0 , 0 , 1 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; if ( found != mImpl . mOptions . end ( ) ) { return found -> second ; } return NULL ; } const char * CommonCommandLineParser :: getOptString ( const char * option0 ) { string option ( option0 ) ; OptionMap :: iterator found = mImpl . mOptions . find ( option ) ; if ( found != mImpl . mOptions . end ( ) ) { return found -> second ; } return NULL ; } int CommonCommandLineParser :: getChurnRate ( ) { return mImpl . mChurnRate ; } double CommonCommandLineParser :: getTimerInterval ( ) { return mImpl . mTimerInterval ; } const char * CommonCommandLineParser :: getLogFileName ( ) { return mImpl . mLogFileName ; } const char * CommonCommandLineParser :: getQueryArg1 ( ) { return mImpl . mQueryArg1 ; } const char * CommonCommandLineParser :: getQueryArg2 ( ) { return mImpl . mQueryArg2 ; } const char * CommonCommandLineParser :: getQueryArg3 ( ) { return mImpl . mQueryArg3 ; } const char * CommonCommandLineParser :: getQueryArg4 ( ) { return mImpl . mQueryArg4 ; } int CommonCommandLineParser :: getQuery ( ) { return mImpl . mQuery ; } int CommonCommandLineParser :: getQueryType ( ) { return mImpl . mQueryType ; } int CommonCommandLineParser :: getQueries ( ) { return mImpl . mQueryCycles ; } CommonCommandLineParser :: CommonCommandLineParserImpl :: CommonCommandLineParserImpl ( int argc , const char * argv [ ] ) { mSource = NULL ; mDictSource = NULL ; mOptionSource = NULL ; mSymbolMapFile = NULL ; mThrottleRate = 500.0 ; mThreads = 0 ; mTimeout = 1.0 ; mChurnRate = 0 ; mTimerInterval = 1.0 ; mLogFileName = NULL ; mMiddleware = " wmw " ; mPrecision = 2 ; mShutdownTime = 0 ; mShowDeltas = false ; mBridge = NULL ; int i = 1 ; mUseWorldView = false ; mTportName = NULL ; mDictTportName = NULL ; mOptionTportName = NULL ; mSourceName = " WOMBAT " ; mDictSourceName = " WOMBAT " ; mOptionSourceName = " OPRA " ; mSnapShot = false ; mPublishRecaps = false ; mQueryArg1 = NULL ; mQueryArg2 = NULL ; mQueryArg3 = NULL ; mQueryArg4 = NULL ; mQuery = 0 ; mQueryType = 0 ; mQueryCycles = 1 ; while ( i < argc ) { bool handled = false ; if ( ( strcmp ( argv [ i ] , " - OS " ) == 0 ) || ( strcmp ( argv [ i ] , " - optionSource " ) == 0 ) || ( strcmp ( argv [ i ] , " - option - source " ) == 0 ) ) { mOptionSourceName = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - S " ) == 0 ) || ( strcmp ( argv [ i ] , " - source " ) == 0 ) ) { mSourceName = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - use _ dict _ file " ) == 0 ) ) { mDictFileName = argv [ i + 1 ] ; } else if ( ( strcmp ( argv [ i ] , " - DS " ) == 0 ) || ( strcmp ( argv [ i ] , " - dict - source " ) == 0 ) || ( strcmp ( argv [ i ] , " - dictSource " ) == 0 ) || ( strcmp ( argv [ i ] , " - d " ) == 0 ) ) { mDictSourceName = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - T " ) == 0 ) || ( strcmp ( argv [ i ] , " - tport " ) == 0 ) ) { mTportName = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - DT " ) == 0 ) || ( strcmp ( argv [ i ] , " - dictTport " ) == 0 ) || ( strcmp ( argv [ i ] , " - dict - tport " ) == 0 ) || ( strcmp ( argv [ i ] , " - dict _ tport " ) == 0 ) ) { mDictTportName = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - OT " ) == 0 ) || ( strcmp ( argv [ i ] , " - optionTport " ) == 0 ) || ( strcmp ( argv [ i ] , " - option - tport " ) == 0 ) ) { mOptionTportName = argv [ i + 1 ] ; handled = true ; } else if ( strcmp ( argv [ i ] , " - s " ) == 0 ) { mSymbolList . push_back ( argv [ i + 1 ] ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - threads " ) == 0 ) { mThreads = strtol ( argv [ i + 1 ] , NULL , 10 ) ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - r " ) == 0 ) || ( strcmp ( argv [ i ] , " - rate " ) == 0 ) ) { mThrottleRate = strtod ( argv [ i + 1 ] , NULL ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - t " ) == 0 ) { mTimeout = strtod ( argv [ i + 1 ] , NULL ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - mp " ) == 0 ) { mSymbolMapFile = argv [ i + 1 ] ; handled = true ; } else if ( strcmp ( argv [ i ] , " - m " ) == 0 ) { mMiddleware = argv [ i + 1 ] ; handled = true ; } else if ( strcmp ( argv [ i ] , " - precision " ) == 0 ) { mPrecision = strtol ( argv [ i + 1 ] , NULL , 10 ) ; if ( ! mPrecision ) { mPrecision = 2 ; } if ( mPrecision > 6 ) { mPrecision = 6 ; } handled = true ; } else if ( strcmp ( " - shutdown " , argv [ i ] ) == 0 ) { mShutdownTime = atoi ( argv [ i + 1 ] ) ; } else if ( strcmp ( argv [ i ] , " - deltas " ) == 0 ) { mShowDeltas = true ; } else if ( strcmp ( argv [ i ] , " - churn " ) == 0 ) { mChurnRate = strtol ( argv [ i + 1 ] , NULL , 10 ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - timerInterval " ) == 0 ) { mTimerInterval = strtod ( argv [ i + 1 ] , NULL ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - logfile " ) == 0 ) { mLogFileName = argv [ i + 1 ] ; handled = true ; } else if ( strcmp ( argv [ i ] , " - f " ) == 0 ) { const char * filename = argv [ i + 1 ] ; ifstream input ( filename ) ; if ( ! input ) { cerr << " Cannot ▁ open ▁ file : ▁ " << filename << " \n " ; exit ( 1 ) ; } string symbol ; input >> symbol ; while ( ! input . eof ( ) ) { if ( ! symbol . empty ( ) ) { mSymbolList . push_back ( strdup ( symbol . c_str ( ) ) ) ; } input >> symbol ; } handled = true ; } else if ( strcmp ( argv [ i ] , " - v " ) == 0 ) { if ( mama_getLogLevel ( ) == MAMA_LOG_LEVEL_NORMAL ) { mama_enableLogging ( stderr , MAMA_LOG_LEVEL_FINE ) ; } else if ( mama_getLogLevel ( ) == MAMA_LOG_LEVEL_FINE ) { mama_enableLogging ( stderr , MAMA_LOG_LEVEL_FINER ) ; } else { mama_enableLogging ( stderr , MAMA_LOG_LEVEL_FINEST ) ; } handled = true ; } else if ( strcmp ( argv [ i ] , " - q " ) == 0 ) { if ( gExampleLogLevel == EXAMPLE_LOG_LEVEL_NORMAL ) { gExampleLogLevel = EXAMPLE_LOG_LEVEL_QUIET ; } else if ( gExampleLogLevel == EXAMPLE_LOG_LEVEL_QUIET ) { gExampleLogLevel = EXAMPLE_LOG_LEVEL_QUIETER ; } else if ( gExampleLogLevel == EXAMPLE_LOG_LEVEL_QUIETER ) { gExampleLogLevel = EXAMPLE_LOG_LEVEL_QUIETEST ; } handled = true ; } else if ( strcmp ( argv [ i ] , " - V " ) == 0 ) { if ( mSubscLogLevel == MAMA_LOG_LEVEL_NORMAL ) { mSubscLogLevel = MAMA_LOG_LEVEL_FINE ; } else if ( mSubscLogLevel == MAMA_LOG_LEVEL_FINE ) { mSubscLogLevel = MAMA_LOG_LEVEL_FINER ; } else { mSubscLogLevel = MAMA_LOG_LEVEL_FINEST ; } handled = true ; } else if ( strcmp ( argv [ i ] , " - W " ) == 0 ) { mUseWorldView = true ; handled = true ; } else if ( strcmp ( argv [ i ] , " - L " ) == 0 ) { mLogReqResp = true ; handled = true ; } else if ( strcmp ( argv [ i ] , " - Y " ) == 0 ) { mSymbology = argv [ i + 1 ] ; handled = true ; } else if ( ( strcmp ( argv [ i ] , " - ? " ) == 0 ) || ( strcmp ( argv [ i ] , " - - help " ) == 0 ) ) { usage ( 1 ) ; handled = true ; } else if ( strcmp ( argv [ i ] , " - PR " ) == 0 ) { mPublishRecaps = true ; } else if ( strcmp ( argv [ i ] , " - 1" ) == 0 ) { mSnapShot = true ; handled = true ; } else if ( strcmp ( argv [ i ] , " - Q " ) == 0 ) { mQuery = strtol ( argv [ i + 1 ] , NULL , 10 ) ; } else if ( strcmp ( argv [ i ] , " - QT " ) == 0 ) { mQueryType = strtol ( argv [ i + 1 ] , NULL , 10 ) ; } else if ( strcmp ( argv [ i ] , " - A1" ) == 0 ) { mQueryArg1 = argv [ i + 1 ] ; } else if ( strcmp ( argv [ i ] , " - A2" ) == 0 ) { mQueryArg2 = argv [ i + 1 ] ; } else if ( strcmp ( argv [ i ] , " - A3" ) == 0 ) { mQueryArg3 = argv [ i + 1 ] ; } else if ( strcmp ( argv [ i ] , " - A4" ) == 0 ) { mQueryArg4 = argv [ i + 1 ] ; } else if ( strcmp ( argv [ i ] , " - QC " ) == 0 ) { mQueryCycles = strtol ( argv [ i + 1 ] , NULL , 10 ) ; } if ( argv [ i ] [ 0 ] == ' - ' ) { const char * opt = argv [ i ] + 1 ; if ( strlen ( opt ) > 0 ) { if ( ( i + 1 < argc ) && ( argv [ i + 1 ] [ 0 ] != ' - ' ) ) { mOptions [ opt ] = argv [ i + 1 ] ; i += 2 ; } else { mOptions [ opt ] = "1" ; i ++ ; } } handled = true ; } if ( ! handled ) { usage ( 1 ) ; } } mBridge = Mama :: loadBridge ( mMiddleware ) ; } </DOCUMENT>
<DOCUMENT_ID="miniwebkit/src/tree/master/WebCore/xml/XMLSerializer.cpp"> # include " config . h " # include " XMLSerializer . h " # include " Document . h " # include " ExceptionCode . h " # include " markup . h " namespace WebCore { String XMLSerializer :: serializeToString ( Node * node , ExceptionCode & ec ) { if ( ! node ) return String ( ) ; if ( ! node -> document ( ) ) { ASSERT ( node -> nodeType ( ) == Node :: DOCUMENT_TYPE_NODE ) ; ec = INVALID_ACCESS_ERR ; return String ( ) ; } return createMarkup ( node ) ; } } </DOCUMENT>
<DOCUMENT_ID="austinzheng/swift/tree/master/lib/SILOptimizer/IPO/LetPropertiesOpts.cpp"> # define DEBUG_TYPE " let - properties - opt " # include " swift / SIL / DebugUtils . h " # include " swift / SIL / InstructionUtils . h " # include " swift / SIL / SILBasicBlock . h " # include " swift / SIL / SILInstruction . h " # include " swift / SIL / SILLinkage . h " # include " swift / SILOptimizer / PassManager / Passes . h " # include " swift / SILOptimizer / PassManager / Transforms . h " # include " swift / SILOptimizer / Utils / Local . h " # include " llvm / ADT / MapVector . h " # include " llvm / Support / CommandLine . h " # include " llvm / Support / Debug . h " using namespace swift ; namespace { using InstructionList = SmallVector < SILInstruction * , 8 > ; struct InitSequence { InstructionList Instructions ; SILValue Result ; bool isValid ( ) const { return ( bool ) Result ; } } ; class LetPropertiesOpt { SILModule * Module ; typedef SmallVector < VarDecl * , 4 > Properties ; llvm :: SetVector < SILFunction * > ChangedFunctions ; llvm :: MapVector < VarDecl * , InstructionList > AccessMap ; llvm :: MapVector < VarDecl * , InitSequence > InitMap ; llvm :: SmallPtrSet < VarDecl * , 16 > SkipProcessing ; llvm :: SmallPtrSet < NominalTypeDecl * , 16 > SkipTypeProcessing ; llvm :: SmallPtrSet < VarDecl * , 16 > CannotRemove ; llvm :: MapVector < NominalTypeDecl * , Properties > NominalTypeLetProperties ; llvm :: SmallPtrSet < VarDecl * , 16 > PotentialConstantLetProperty ; public : LetPropertiesOpt ( SILModule * M ) : Module ( M ) { } void run ( SILModuleTransform * T ) ; protected : bool isConstantLetProperty ( VarDecl * Property ) ; void collectPropertyAccess ( SILInstruction * I , VarDecl * Property , bool NonRemovable ) ; void collectStructPropertiesAccess ( StructInst * SI , bool NonRemovable ) ; void optimizeLetPropertyAccess ( VarDecl * SILG , const InitSequence & Init ) ; bool analyzeInitValue ( SILInstruction * I , VarDecl * Prop ) ; } ; class InitSequenceCloner : public SILClonerWithScopes < InitSequenceCloner > { friend class SILInstructionVisitor < InitSequenceCloner > ; friend class SILCloner < InitSequenceCloner > ; const InitSequence & Init ; SILInstruction * DestIP ; public : InitSequenceCloner ( const InitSequence & init , SILInstruction * destIP ) : SILClonerWithScopes ( * destIP -> getFunction ( ) ) , Init ( init ) , DestIP ( destIP ) { } void process ( SILInstruction * I ) { visit ( I ) ; } SILBasicBlock * remapBasicBlock ( SILBasicBlock * BB ) { return BB ; } SILValue getMappedValue ( SILValue Value ) { return SILCloner < InitSequenceCloner > :: getMappedValue ( Value ) ; } void postProcess ( SILInstruction * orig , SILInstruction * cloned ) { DestIP -> getParent ( ) -> push_front ( cloned ) ; cloned -> moveBefore ( DestIP ) ; SILClonerWithScopes < InitSequenceCloner > :: postProcess ( orig , cloned ) ; } SILValue clone ( ) { for ( auto I : Init . Instructions ) process ( I ) ; return getMappedValue ( Init . Result ) ; } } ; } # ifndef NDEBUG static raw_ostream & operator << ( raw_ostream & OS , const VarDecl & decl ) { auto * Ty = dyn_cast < NominalTypeDecl > ( decl . getDeclContext ( ) ) ; if ( Ty ) OS << Ty -> getName ( ) << " : : " ; OS << decl . getName ( ) ; return OS ; } # endif void LetPropertiesOpt :: optimizeLetPropertyAccess ( VarDecl * Property , const InitSequence & init ) { assert ( init . isValid ( ) ) ; if ( SkipProcessing . count ( Property ) ) return ; auto * Ty = dyn_cast < NominalTypeDecl > ( Property -> getDeclContext ( ) ) ; if ( SkipTypeProcessing . count ( Ty ) ) return ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Replacing ▁ access ▁ to ▁ property ▁ ' " << * Property << " ' ▁ by ▁ its ▁ constant ▁ initializer \n " ) ; auto PropertyAccess = Property -> getEffectiveAccess ( ) ; auto TypeAccess = Ty -> getEffectiveAccess ( ) ; auto CanRemove = false ; if ( TypeAccess <= AccessLevel :: FilePrivate || PropertyAccess <= AccessLevel :: FilePrivate || ( ( TypeAccess <= AccessLevel :: Internal || PropertyAccess <= AccessLevel :: Internal ) && Module -> isWholeModule ( ) ) ) { CanRemove = true ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Storage ▁ for ▁ property ▁ ' " << * Property << " ' ▁ can ▁ be ▁ eliminated \n " ) ; } if ( CannotRemove . count ( Property ) ) CanRemove = false ; if ( ! AccessMap . count ( Property ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ is ▁ never ▁ read \n " ) ; if ( CanRemove ) { } return ; } auto & Loads = AccessMap [ Property ] ; unsigned NumReplaced = 0 ; for ( auto Load : Loads ) { SILFunction * F = Load -> getFunction ( ) ; auto cloneInitAt = [ & ] ( SILInstruction * insertionPoint ) -> SILValue { InitSequenceCloner cloner ( init , insertionPoint ) ; return cloner . clone ( ) ; } ; if ( isa < RefElementAddrInst > ( Load ) || isa < StructElementAddrInst > ( Load ) || isa < BeginAccessInst > ( Load ) ) { auto proj = cast < SingleValueInstruction > ( Load ) ; SILValue clonedInit = cloneInitAt ( proj ) ; SILBuilderWithScope B ( proj ) ; for ( auto UI = proj -> use_begin ( ) , E = proj -> use_end ( ) ; UI != E ; ) { auto * User = UI -> getUser ( ) ; ++ UI ; if ( isIncidentalUse ( User ) ) continue ; if ( isa < BeginAccessInst > ( User ) ) continue ; if ( isa < StoreInst > ( User ) ) continue ; replaceLoadSequence ( User , clonedInit , B ) ; eraseUsesOfInstruction ( User ) ; User -> eraseFromParent ( ) ; ++ NumReplaced ; } ChangedFunctions . insert ( F ) ; } else if ( auto proj = dyn_cast < StructExtractInst > ( Load ) ) { SILValue clonedInit = cloneInitAt ( proj ) ; proj -> replaceAllUsesWith ( clonedInit ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Access ▁ to ▁ " << * Property << " ▁ was ▁ replaced : \n " ; clonedInit -> dumpInContext ( ) ) ; proj -> eraseFromParent ( ) ; ++ NumReplaced ; ChangedFunctions . insert ( F ) ; } } LLVM_DEBUG ( llvm :: dbgs ( ) << " Access ▁ to ▁ " << * Property << " ▁ was ▁ replaced ▁ " << NumReplaced << " ▁ time ( s ) \n " ) ; if ( CanRemove ) { } } static bool isStructurallyIdentical ( SILValue LHS , SILValue RHS ) { if ( LHS == RHS ) return true ; if ( LHS -> getType ( ) != RHS -> getType ( ) ) return false ; auto lResult = LHS -> getDefiningInstructionResult ( ) ; auto rResult = RHS -> getDefiningInstructionResult ( ) ; assert ( lResult && rResult && " operands ▁ of ▁ instructions ▁ approved ▁ by ▁ analyzeStaticInitializer ▁ " " should ▁ always ▁ be ▁ defined ▁ by ▁ instructions " ) ; return ( lResult -> ResultIndex == rResult -> ResultIndex && lResult -> Instruction -> isIdenticalTo ( rResult -> Instruction , isStructurallyIdentical ) ) ; } ; static bool isSameInitSequence ( const InitSequence & LHS , const InitSequence & RHS ) { assert ( LHS . isValid ( ) && RHS . isValid ( ) ) ; return isStructurallyIdentical ( LHS . Result , RHS . Result ) ; } static bool isAssignableExternally ( VarDecl * Property , SILModule * Module ) { if ( Module -> isVisibleExternally ( Property ) ) { auto * Ty = dyn_cast < NominalTypeDecl > ( Property -> getDeclContext ( ) ) ; if ( isa < ClassDecl > ( Ty ) ) return false ; for ( auto SP : Ty -> getStoredProperties ( ) ) { auto storedPropertyAccess = SP -> getEffectiveAccess ( ) ; if ( storedPropertyAccess <= AccessLevel :: FilePrivate || ( storedPropertyAccess <= AccessLevel :: Internal && Module -> isWholeModule ( ) ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ cannot ▁ be ▁ set ▁ externally \n " ) ; return false ; } } LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ can ▁ be ▁ used ▁ externally \n " ) ; return true ; } return false ; } static bool mayHaveUnknownUses ( VarDecl * Property , SILModule * Module ) { if ( Property -> getDeclContext ( ) -> getParentModule ( ) != Module -> getSwiftModule ( ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ is ▁ defined ▁ in ▁ a ▁ different ▁ module \n " ) ; return true ; } if ( isAssignableExternally ( Property , Module ) ) { return true ; } return false ; } bool LetPropertiesOpt :: isConstantLetProperty ( VarDecl * Property ) { if ( ! Property -> isLet ( ) || Property -> isStatic ( ) ) return false ; if ( SkipProcessing . count ( Property ) ) return false ; if ( PotentialConstantLetProperty . count ( Property ) ) return true ; if ( mayHaveUnknownUses ( Property , Module ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ may ▁ have ▁ unknown ▁ uses \n " ) ; SkipProcessing . insert ( Property ) ; return false ; } LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ has ▁ no ▁ unknown ▁ uses \n " ) ; if ( ! isSimpleType ( Module -> Types . getLoweredType ( Property -> getType ( ) ) , * Module ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ is ▁ not ▁ of ▁ trivial ▁ type \n " ) ; SkipProcessing . insert ( Property ) ; return false ; } PotentialConstantLetProperty . insert ( Property ) ; return true ; } static bool isProjectionOfProperty ( SILValue addr , VarDecl * Property ) { if ( auto * REA = dyn_cast < RefElementAddrInst > ( addr ) ) { return REA -> getField ( ) == Property ; } if ( auto * SEA = dyn_cast < StructElementAddrInst > ( addr ) ) { return SEA -> getField ( ) == Property ; } return false ; } bool LetPropertiesOpt :: analyzeInitValue ( SILInstruction * I , VarDecl * Property ) { SILValue value ; if ( auto SI = dyn_cast < StructInst > ( I ) ) { value = SI -> getFieldValue ( Property ) ; } else if ( auto SI = dyn_cast < StoreInst > ( I ) ) { auto Dest = stripAddressAccess ( SI -> getDest ( ) ) ; assert ( isProjectionOfProperty ( stripAddressAccess ( SI -> getDest ( ) ) , Property ) && " Store ▁ instruction ▁ should ▁ store ▁ into ▁ a ▁ proper ▁ let ▁ property " ) ; ( void ) Dest ; value = SI -> getSrc ( ) ; } if ( auto * LI = dyn_cast < LoadInst > ( value ) ) { SILValue addr = LI -> getOperand ( ) ; if ( isProjectionOfProperty ( addr , Property ) ) return true ; } InitSequence sequence ; sequence . Result = value ; if ( ! analyzeStaticInitializer ( value , sequence . Instructions ) ) return false ; auto & cachedSequence = InitMap [ Property ] ; if ( cachedSequence . isValid ( ) && ! isSameInitSequence ( cachedSequence , sequence ) ) { return false ; } else { LLVM_DEBUG ( llvm :: dbgs ( ) << " The ▁ value ▁ of ▁ property ▁ ' " << * Property << " ' ▁ is ▁ statically ▁ known ▁ so ▁ far \n " ) ; cachedSequence = std :: move ( sequence ) ; return true ; } } void LetPropertiesOpt :: collectStructPropertiesAccess ( StructInst * SI , bool NonRemovable ) { auto structDecl = SI -> getStructDecl ( ) ; if ( SkipTypeProcessing . count ( structDecl ) ) return ; if ( ! NominalTypeLetProperties . count ( structDecl ) ) { SmallVector < VarDecl * , 4 > LetProps ; for ( auto Prop : structDecl -> getStoredProperties ( ) ) { if ( ! isConstantLetProperty ( Prop ) ) continue ; LetProps . push_back ( Prop ) ; } if ( LetProps . empty ( ) ) { SkipTypeProcessing . insert ( structDecl ) ; return ; } NominalTypeLetProperties [ structDecl ] = LetProps ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Computed ▁ set ▁ of ▁ let ▁ properties ▁ for ▁ struct ▁ ' " << structDecl -> getName ( ) << " ' \n " ) ; } auto & Props = NominalTypeLetProperties [ structDecl ] ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Found ▁ a ▁ struct ▁ instruction ▁ initializing ▁ some ▁ " " let ▁ properties : ▁ " ; SI -> dumpInContext ( ) ) ; for ( auto Prop : Props ) { if ( SkipProcessing . count ( Prop ) ) continue ; SILValue PropValue = SI -> getOperandForField ( Prop ) -> get ( ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Check ▁ the ▁ value ▁ of ▁ property ▁ ' " << * Prop << " ' ▁ : " << PropValue << " \n " ) ; if ( ! analyzeInitValue ( SI , Prop ) ) { SkipProcessing . insert ( Prop ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " The ▁ value ▁ of ▁ a ▁ let ▁ property ▁ ' " << * Prop << " ' ▁ is ▁ not ▁ statically ▁ known \n " ) ; } ( void ) PropValue ; } } static bool isValidPropertyLoad ( SILInstruction * I ) { if ( isa < LoadInst > ( I ) ) return true ; if ( isa < StructElementAddrInst > ( I ) || isa < TupleElementAddrInst > ( I ) ) { auto projection = cast < SingleValueInstruction > ( I ) ; for ( auto Use : getNonDebugUses ( projection ) ) { if ( isIncidentalUse ( Use -> getUser ( ) ) ) continue ; if ( ! isValidPropertyLoad ( Use -> getUser ( ) ) ) return false ; } return true ; } return false ; } void LetPropertiesOpt :: collectPropertyAccess ( SILInstruction * I , VarDecl * Property , bool NonRemovable ) { if ( ! isConstantLetProperty ( Property ) ) return ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Collecting ▁ property ▁ access ▁ for ▁ property ▁ ' " << * Property << " ' : \n " ; llvm :: dbgs ( ) << " The ▁ instructions ▁ are : \n " ; I -> dumpInContext ( ) ) ; if ( isa < RefElementAddrInst > ( I ) || isa < StructElementAddrInst > ( I ) || isa < BeginAccessInst > ( I ) ) { auto projection = cast < SingleValueInstruction > ( I ) ; for ( auto Use : getNonDebugUses ( projection ) ) { auto * User = Use -> getUser ( ) ; if ( isIncidentalUse ( User ) ) continue ; if ( isa < BeginAccessInst > ( User ) ) continue ; if ( auto * SI = dyn_cast < StoreInst > ( User ) ) { if ( SI -> getDest ( ) != projection || ! analyzeInitValue ( SI , Property ) ) { SkipProcessing . insert ( Property ) ; return ; } continue ; } if ( ! isValidPropertyLoad ( User ) ) { SkipProcessing . insert ( Property ) ; return ; } } } AccessMap [ Property ] . push_back ( I ) ; if ( NonRemovable ) CannotRemove . insert ( Property ) ; } void LetPropertiesOpt :: run ( SILModuleTransform * T ) { for ( auto & F : * Module ) { bool NonRemovable = ! F . shouldOptimize ( ) ; for ( auto & BB : F ) { for ( auto & I : BB ) if ( auto * BAI = dyn_cast < BeginAccessInst > ( & I ) ) { if ( auto * REAI = dyn_cast < RefElementAddrInst > ( stripAddressAccess ( BAI ) ) ) { collectPropertyAccess ( BAI , REAI -> getField ( ) , NonRemovable ) ; } } else if ( auto * REAI = dyn_cast < RefElementAddrInst > ( & I ) ) { collectPropertyAccess ( REAI , REAI -> getField ( ) , NonRemovable ) ; } else if ( auto * SEI = dyn_cast < StructExtractInst > ( & I ) ) { collectPropertyAccess ( SEI , SEI -> getField ( ) , NonRemovable ) ; } else if ( auto * SEAI = dyn_cast < StructElementAddrInst > ( & I ) ) { collectPropertyAccess ( SEAI , SEAI -> getField ( ) , NonRemovable ) ; } else if ( auto * SI = dyn_cast < StructInst > ( & I ) ) { collectStructPropertiesAccess ( SI , NonRemovable ) ; } } } for ( auto & Init : InitMap ) { optimizeLetPropertyAccess ( Init . first , Init . second ) ; } for ( SILFunction * ChangedFn : ChangedFunctions ) { T -> invalidateAnalysis ( ChangedFn , SILAnalysis :: InvalidationKind :: Instructions ) ; } } namespace { class LetPropertiesOptPass : public SILModuleTransform { void run ( ) override { LetPropertiesOpt ( getModule ( ) ) . run ( this ) ; } } ; } SILTransform * swift :: createLetPropertiesOpt ( ) { return new LetPropertiesOptPass ( ) ; } </DOCUMENT>
<DOCUMENT_ID="paulfitz/phantomjs/tree/master/src/qt/qtwebkit/Tools/DumpRenderTree/TestNetscapePlugIn/Tests/GetURLWithJavaScriptURLDestroyingPlugin.cpp"> # include " PluginTest . h " using namespace std ; class GetURLWithJavaScriptURLDestroyingPlugin : public PluginTest { public : GetURLWithJavaScriptURLDestroyingPlugin ( NPP npp , const string & identifier ) : PluginTest ( npp , identifier ) { } private : virtual NPError NPP_New ( NPMIMEType pluginType , uint16_t mode , int16_t argc , char * argn [ ] , char * argv [ ] , NPSavedData * saved ) { NPN_GetURL ( " javascript : removePlugin ( ) " , 0 ) ; return NPERR_NO_ERROR ; } } ; static PluginTest :: Register < GetURLWithJavaScriptURLDestroyingPlugin > getURLWithJavaScriptURLDestroyingPlugin ( " get - url - with - javascript - url - destroying - plugin " ) ; </DOCUMENT>
<DOCUMENT_ID="pcarrier-packaging/deb-phantomjs/tree/master/src/qt/src/3rdparty/webkit/Source/WebCore/generated/JSSVGPathSegLinetoHorizontalRel.cpp"> # include " config . h " # if ENABLE ( SVG ) # include " JSSVGPathSegLinetoHorizontalRel . h " # include " SVGPathSegLinetoHorizontal . h " # include < runtime / Error . h > # include < wtf / GetPtr . h > using namespace JSC ; namespace WebCore { ASSERT_CLASS_FITS_IN_CELL ( JSSVGPathSegLinetoHorizontalRel ) ; # if ENABLE ( JIT ) # define THUNK_GENERATOR ( generator ) , generator # else # define THUNK_GENERATOR ( generator ) # endif static const HashTableValue JSSVGPathSegLinetoHorizontalRelTableValues [ 3 ] = { { " x " , DontDelete , ( intptr_t ) static_cast < PropertySlot :: GetValueFunc > ( jsSVGPathSegLinetoHorizontalRelX ) , ( intptr_t ) setJSSVGPathSegLinetoHorizontalRelX THUNK_GENERATOR ( 0 ) } , { " constructor " , DontEnum | ReadOnly , ( intptr_t ) static_cast < PropertySlot :: GetValueFunc > ( jsSVGPathSegLinetoHorizontalRelConstructor ) , ( intptr_t ) 0 THUNK_GENERATOR ( 0 ) } , { 0 , 0 , 0 , 0 THUNK_GENERATOR ( 0 ) } } ; # undef THUNK_GENERATOR static JSC_CONST_HASHTABLE HashTable JSSVGPathSegLinetoHorizontalRelTable = { 5 , 3 , JSSVGPathSegLinetoHorizontalRelTableValues , 0 } ; # if ENABLE ( JIT ) # define THUNK_GENERATOR ( generator ) , generator # else # define THUNK_GENERATOR ( generator ) # endif static const HashTableValue JSSVGPathSegLinetoHorizontalRelConstructorTableValues [ 1 ] = { { 0 , 0 , 0 , 0 THUNK_GENERATOR ( 0 ) } } ; # undef THUNK_GENERATOR static JSC_CONST_HASHTABLE HashTable JSSVGPathSegLinetoHorizontalRelConstructorTable = { 1 , 0 , JSSVGPathSegLinetoHorizontalRelConstructorTableValues , 0 } ; class JSSVGPathSegLinetoHorizontalRelConstructor : public DOMConstructorObject { public : JSSVGPathSegLinetoHorizontalRelConstructor ( JSC :: ExecState * , JSC :: Structure * , JSDOMGlobalObject * ) ; virtual bool getOwnPropertySlot ( JSC :: ExecState * , const JSC :: Identifier & , JSC :: PropertySlot & ) ; virtual bool getOwnPropertyDescriptor ( JSC :: ExecState * , const JSC :: Identifier & , JSC :: PropertyDescriptor & ) ; static const JSC :: ClassInfo s_info ; static JSC :: Structure * createStructure ( JSC :: JSGlobalData & globalData , JSC :: JSValue prototype ) { return JSC :: Structure :: create ( globalData , prototype , JSC :: TypeInfo ( JSC :: ObjectType , StructureFlags ) , AnonymousSlotCount , & s_info ) ; } protected : static const unsigned StructureFlags = JSC :: OverridesGetOwnPropertySlot | JSC :: ImplementsHasInstance | DOMConstructorObject :: StructureFlags ; } ; const ClassInfo JSSVGPathSegLinetoHorizontalRelConstructor :: s_info = { " SVGPathSegLinetoHorizontalRelConstructor " , & DOMConstructorObject :: s_info , & JSSVGPathSegLinetoHorizontalRelConstructorTable , 0 } ; JSSVGPathSegLinetoHorizontalRelConstructor :: JSSVGPathSegLinetoHorizontalRelConstructor ( ExecState * exec , Structure * structure , JSDOMGlobalObject * globalObject ) : DOMConstructorObject ( structure , globalObject ) { ASSERT ( inherits ( & s_info ) ) ; putDirect ( exec -> globalData ( ) , exec -> propertyNames ( ) . prototype , JSSVGPathSegLinetoHorizontalRelPrototype :: self ( exec , globalObject ) , DontDelete | ReadOnly ) ; } bool JSSVGPathSegLinetoHorizontalRelConstructor :: getOwnPropertySlot ( ExecState * exec , const Identifier & propertyName , PropertySlot & slot ) { return getStaticValueSlot < JSSVGPathSegLinetoHorizontalRelConstructor , JSDOMWrapper > ( exec , & JSSVGPathSegLinetoHorizontalRelConstructorTable , this , propertyName , slot ) ; } bool JSSVGPathSegLinetoHorizontalRelConstructor :: getOwnPropertyDescriptor ( ExecState * exec , const Identifier & propertyName , PropertyDescriptor & descriptor ) { return getStaticValueDescriptor < JSSVGPathSegLinetoHorizontalRelConstructor , JSDOMWrapper > ( exec , & JSSVGPathSegLinetoHorizontalRelConstructorTable , this , propertyName , descriptor ) ; } # if ENABLE ( JIT ) # define THUNK_GENERATOR ( generator ) , generator # else # define THUNK_GENERATOR ( generator ) # endif static const HashTableValue JSSVGPathSegLinetoHorizontalRelPrototypeTableValues [ 1 ] = { { 0 , 0 , 0 , 0 THUNK_GENERATOR ( 0 ) } } ; # undef THUNK_GENERATOR static JSC_CONST_HASHTABLE HashTable JSSVGPathSegLinetoHorizontalRelPrototypeTable = { 1 , 0 , JSSVGPathSegLinetoHorizontalRelPrototypeTableValues , 0 } ; const ClassInfo JSSVGPathSegLinetoHorizontalRelPrototype :: s_info = { " SVGPathSegLinetoHorizontalRelPrototype " , & JSC :: JSObjectWithGlobalObject :: s_info , & JSSVGPathSegLinetoHorizontalRelPrototypeTable , 0 } ; JSObject * JSSVGPathSegLinetoHorizontalRelPrototype :: self ( ExecState * exec , JSGlobalObject * globalObject ) { return getDOMPrototype < JSSVGPathSegLinetoHorizontalRel > ( exec , globalObject ) ; } const ClassInfo JSSVGPathSegLinetoHorizontalRel :: s_info = { " SVGPathSegLinetoHorizontalRel " , & JSSVGPathSeg :: s_info , & JSSVGPathSegLinetoHorizontalRelTable , 0 } ; JSSVGPathSegLinetoHorizontalRel :: JSSVGPathSegLinetoHorizontalRel ( Structure * structure , JSDOMGlobalObject * globalObject , PassRefPtr < SVGPathSegLinetoHorizontalRel > impl ) : JSSVGPathSeg ( structure , globalObject , impl ) { ASSERT ( inherits ( & s_info ) ) ; } JSObject * JSSVGPathSegLinetoHorizontalRel :: createPrototype ( ExecState * exec , JSGlobalObject * globalObject ) { return new ( exec ) JSSVGPathSegLinetoHorizontalRelPrototype ( exec -> globalData ( ) , globalObject , JSSVGPathSegLinetoHorizontalRelPrototype :: createStructure ( exec -> globalData ( ) , JSSVGPathSegPrototype :: self ( exec , globalObject ) ) ) ; } bool JSSVGPathSegLinetoHorizontalRel :: getOwnPropertySlot ( ExecState * exec , const Identifier & propertyName , PropertySlot & slot ) { return getStaticValueSlot < JSSVGPathSegLinetoHorizontalRel , Base > ( exec , & JSSVGPathSegLinetoHorizontalRelTable , this , propertyName , slot ) ; } bool JSSVGPathSegLinetoHorizontalRel :: getOwnPropertyDescriptor ( ExecState * exec , const Identifier & propertyName , PropertyDescriptor & descriptor ) { return getStaticValueDescriptor < JSSVGPathSegLinetoHorizontalRel , Base > ( exec , & JSSVGPathSegLinetoHorizontalRelTable , this , propertyName , descriptor ) ; } JSValue jsSVGPathSegLinetoHorizontalRelX ( ExecState * exec , JSValue slotBase , const Identifier & ) { JSSVGPathSegLinetoHorizontalRel * castedThis = static_cast < JSSVGPathSegLinetoHorizontalRel * > ( asObject ( slotBase ) ) ; UNUSED_PARAM ( exec ) ; SVGPathSegLinetoHorizontalRel * imp = static_cast < SVGPathSegLinetoHorizontalRel * > ( castedThis -> impl ( ) ) ; JSValue result = jsNumber ( imp -> x ( ) ) ; return result ; } JSValue jsSVGPathSegLinetoHorizontalRelConstructor ( ExecState * exec , JSValue slotBase , const Identifier & ) { JSSVGPathSegLinetoHorizontalRel * domObject = static_cast < JSSVGPathSegLinetoHorizontalRel * > ( asObject ( slotBase ) ) ; return JSSVGPathSegLinetoHorizontalRel :: getConstructor ( exec , domObject -> globalObject ( ) ) ; } void JSSVGPathSegLinetoHorizontalRel :: put ( ExecState * exec , const Identifier & propertyName , JSValue value , PutPropertySlot & slot ) { lookupPut < JSSVGPathSegLinetoHorizontalRel , Base > ( exec , propertyName , value , & JSSVGPathSegLinetoHorizontalRelTable , this , slot ) ; } void setJSSVGPathSegLinetoHorizontalRelX ( ExecState * exec , JSObject * thisObject , JSValue value ) { JSSVGPathSegLinetoHorizontalRel * castedThis = static_cast < JSSVGPathSegLinetoHorizontalRel * > ( thisObject ) ; SVGPathSegLinetoHorizontalRel * imp = static_cast < SVGPathSegLinetoHorizontalRel * > ( castedThis -> impl ( ) ) ; imp -> setX ( value . toFloat ( exec ) ) ; } JSValue JSSVGPathSegLinetoHorizontalRel :: getConstructor ( ExecState * exec , JSGlobalObject * globalObject ) { return getDOMConstructor < JSSVGPathSegLinetoHorizontalRelConstructor > ( exec , static_cast < JSDOMGlobalObject * > ( globalObject ) ) ; } } # endif </DOCUMENT>
<DOCUMENT_ID="ThomasLee969/video_classifier/tree/master/workspace/mexopencv/src/+cv/cornerHarris.cpp"> # include " mexopencv . hpp " using namespace std ; using namespace cv ; void mexFunction ( int nlhs , mxArray * plhs [ ] , int nrhs , const mxArray * prhs [ ] ) { nargchk ( nrhs >= 1 && ( nrhs % 2 ) == 1 && nlhs <= 1 ) ; vector < MxArray > rhs ( prhs , prhs + nrhs ) ; int blockSize = 5 ; int ksize = 3 ; double k = 0.04 ; int borderType = cv :: BORDER_DEFAULT ; for ( int i = 1 ; i < nrhs ; i += 2 ) { string key ( rhs [ i ] . toString ( ) ) ; if ( key == " BlockSize " ) blockSize = rhs [ i + 1 ] . toInt ( ) ; else if ( key == " KSize " ) ksize = rhs [ i + 1 ] . toInt ( ) ; else if ( key == " K " ) k = rhs [ i + 1 ] . toDouble ( ) ; else if ( key == " BorderType " ) borderType = BorderType [ rhs [ i + 1 ] . toString ( ) ] ; else mexErrMsgIdAndTxt ( " mexopencv : error " , " Unrecognized ▁ option " ) ; } Mat src ( rhs [ 0 ] . toMat ( rhs [ 0 ] . isUint8 ( ) ? CV_8U : CV_32F ) ) , dst ; cornerHarris ( src , dst , blockSize , ksize , k , borderType ) ; plhs [ 0 ] = MxArray ( dst ) ; } </DOCUMENT>
<DOCUMENT_ID="fritsvanveen/QGIS/tree/master/src/gui/qgsnewhttpconnection.cpp"> # include " qgsnewhttpconnection . h " # include " qgscontexthelp . h " # include " qgsauthconfigselect . h " # include < QSettings > # include < QMessageBox > # include < QUrl > # include < QPushButton > # include < QRegExpValidator > QgsNewHttpConnection :: QgsNewHttpConnection ( QWidget * parent , const QString & baseKey , const QString & connName , Qt :: WindowFlags fl ) : QDialog ( parent , fl ) , mBaseKey ( baseKey ) , mOriginalConnName ( connName ) , mAuthConfigSelect ( nullptr ) { setupUi ( this ) ; QString service = baseKey . mid ( 18 , 3 ) . toUpper ( ) ; setWindowTitle ( tr ( " Create ▁ a ▁ new ▁ % 1 ▁ connection " ) . arg ( service ) ) ; mCredentialsBaseKey = mBaseKey . split ( ' - ' ) . last ( ) . toUpper ( ) ; txtName -> setValidator ( new QRegExpValidator ( QRegExp ( " [ ^ \\ / ] + " ) , txtName ) ) ; cmbDpiMode -> clear ( ) ; cmbDpiMode -> addItem ( tr ( " all " ) ) ; cmbDpiMode -> addItem ( tr ( " off " ) ) ; cmbDpiMode -> addItem ( tr ( " QGIS " ) ) ; cmbDpiMode -> addItem ( tr ( " UMN " ) ) ; cmbDpiMode -> addItem ( tr ( " GeoServer " ) ) ; cmbVersion -> clear ( ) ; cmbVersion -> addItem ( tr ( " Auto - detect " ) ) ; cmbVersion -> addItem ( tr ( "1.0" ) ) ; cmbVersion -> addItem ( tr ( "1.1" ) ) ; cmbVersion -> addItem ( tr ( "2.0" ) ) ; mAuthConfigSelect = new QgsAuthConfigSelect ( this ) ; tabAuth -> insertTab ( 1 , mAuthConfigSelect , tr ( " Configurations " ) ) ; if ( ! connName . isEmpty ( ) ) { QSettings settings ; QString key = mBaseKey + connName ; QString credentialsKey = " / Qgis / " + mCredentialsBaseKey + ' / ' + connName ; txtName -> setText ( connName ) ; txtUrl -> setText ( settings . value ( key + " / url " ) . toString ( ) ) ; cbxIgnoreGetMapURI -> setChecked ( settings . value ( key + " / ignoreGetMapURI " , false ) . toBool ( ) ) ; cbxIgnoreAxisOrientation -> setChecked ( settings . value ( key + " / ignoreAxisOrientation " , false ) . toBool ( ) ) ; cbxInvertAxisOrientation -> setChecked ( settings . value ( key + " / invertAxisOrientation " , false ) . toBool ( ) ) ; cbxIgnoreGetFeatureInfoURI -> setChecked ( settings . value ( key + " / ignoreGetFeatureInfoURI " , false ) . toBool ( ) ) ; cbxSmoothPixmapTransform -> setChecked ( settings . value ( key + " / smoothPixmapTransform " , false ) . toBool ( ) ) ; int dpiIdx ; switch ( settings . value ( key + " / dpiMode " , 7 ) . toInt ( ) ) { case 0 : dpiIdx = 1 ; break ; case 1 : dpiIdx = 2 ; break ; case 2 : dpiIdx = 3 ; break ; case 4 : dpiIdx = 4 ; break ; default : dpiIdx = 0 ; break ; } cmbDpiMode -> setCurrentIndex ( dpiIdx ) ; QString version = settings . value ( key + " / version " ) . toString ( ) ; int versionIdx = 0 ; if ( version == "1.0.0" ) versionIdx = 1 ; else if ( version == "1.1.0" ) versionIdx = 2 ; else if ( version == "2.0.0" ) versionIdx = 3 ; cmbVersion -> setCurrentIndex ( versionIdx ) ; txtReferer -> setText ( settings . value ( key + " / referer " ) . toString ( ) ) ; txtMaxNumFeatures -> setText ( settings . value ( key + " / maxnumfeatures " ) . toString ( ) ) ; txtUserName -> setText ( settings . value ( credentialsKey + " / username " ) . toString ( ) ) ; txtPassword -> setText ( settings . value ( credentialsKey + " / password " ) . toString ( ) ) ; QString authcfg = settings . value ( credentialsKey + " / authcfg " ) . toString ( ) ; mAuthConfigSelect -> setConfigId ( authcfg ) ; if ( ! authcfg . isEmpty ( ) ) { tabAuth -> setCurrentIndex ( tabAuth -> indexOf ( mAuthConfigSelect ) ) ; } } if ( mBaseKey != " / Qgis / connections - wms / " ) { if ( mBaseKey != " / Qgis / connections - wcs / " && mBaseKey != " / Qgis / connections - wfs / " ) { cbxIgnoreAxisOrientation -> setVisible ( false ) ; cbxInvertAxisOrientation -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxIgnoreAxisOrientation ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxInvertAxisOrientation ) ; } if ( mBaseKey == " / Qgis / connections - wfs / " ) { cbxIgnoreAxisOrientation -> setText ( tr ( " Ignore ▁ axis ▁ orientation ▁ ( WFS ▁ 1.1 / WFS ▁ 2.0 ) " ) ) ; } if ( mBaseKey == " / Qgis / connections - wcs / " ) { cbxIgnoreGetMapURI -> setText ( tr ( " Ignore ▁ GetCoverage ▁ URI ▁ reported ▁ in ▁ capabilities " ) ) ; cbxIgnoreAxisOrientation -> setText ( tr ( " Ignore ▁ axis ▁ orientation " ) ) ; } else { cbxIgnoreGetMapURI -> setVisible ( false ) ; cbxSmoothPixmapTransform -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxIgnoreGetMapURI ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxSmoothPixmapTransform ) ; } cbxIgnoreGetFeatureInfoURI -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxIgnoreGetFeatureInfoURI ) ; cmbDpiMode -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cmbDpiMode ) ; lblDpiMode -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( lblDpiMode ) ; txtReferer -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( txtReferer ) ; lblReferer -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( lblReferer ) ; } if ( mBaseKey != " / Qgis / connections - wfs / " ) { cmbVersion -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cmbVersion ) ; lblMaxNumFeatures -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( lblMaxNumFeatures ) ; txtMaxNumFeatures -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( txtMaxNumFeatures ) ; } int w = width ( ) ; adjustSize ( ) ; resize ( w , height ( ) ) ; on_txtName_textChanged ( connName ) ; } QgsNewHttpConnection :: ~ QgsNewHttpConnection ( ) { } void QgsNewHttpConnection :: on_txtName_textChanged ( const QString & text ) { Q_UNUSED ( text ) ; buttonBox -> button ( QDialogButtonBox :: Ok ) -> setDisabled ( txtName -> text ( ) . isEmpty ( ) || txtUrl -> text ( ) . isEmpty ( ) ) ; } void QgsNewHttpConnection :: on_txtUrl_textChanged ( const QString & text ) { Q_UNUSED ( text ) ; buttonBox -> button ( QDialogButtonBox :: Ok ) -> setDisabled ( txtName -> text ( ) . isEmpty ( ) || txtUrl -> text ( ) . isEmpty ( ) ) ; } void QgsNewHttpConnection :: accept ( ) { QSettings settings ; QString key = mBaseKey + txtName -> text ( ) ; QString credentialsKey = " / Qgis / " + mCredentialsBaseKey + ' / ' + txtName -> text ( ) ; if ( ( mOriginalConnName . isNull ( ) || mOriginalConnName . compare ( txtName -> text ( ) , Qt :: CaseInsensitive ) != 0 ) && settings . contains ( key + " / url " ) && QMessageBox :: question ( this , tr ( " Save ▁ connection " ) , tr ( " Should ▁ the ▁ existing ▁ connection ▁ % 1 ▁ be ▁ overwritten ? " ) . arg ( txtName -> text ( ) ) , QMessageBox :: Ok | QMessageBox :: Cancel ) == QMessageBox :: Cancel ) { return ; } if ( ! txtPassword -> text ( ) . isEmpty ( ) && QMessageBox :: question ( this , tr ( " Saving ▁ passwords " ) , tr ( " WARNING : ▁ You ▁ have ▁ entered ▁ a ▁ password . ▁ It ▁ will ▁ be ▁ stored ▁ in ▁ plain ▁ text ▁ in ▁ your ▁ project ▁ files ▁ and ▁ in ▁ your ▁ home ▁ directory ▁ on ▁ Unix - like ▁ systems , ▁ or ▁ in ▁ your ▁ user ▁ profile ▁ on ▁ Windows . ▁ If ▁ you ▁ do ▁ not ▁ want ▁ this ▁ to ▁ happen , ▁ please ▁ press ▁ the ▁ Cancel ▁ button . \n Note : ▁ giving ▁ the ▁ password ▁ is ▁ optional . ▁ It ▁ will ▁ be ▁ requested ▁ interactivly , ▁ when ▁ needed . " ) , QMessageBox :: Ok | QMessageBox :: Cancel ) == QMessageBox :: Cancel ) { return ; } if ( ! mOriginalConnName . isNull ( ) && mOriginalConnName != key ) { settings . remove ( mBaseKey + mOriginalConnName ) ; settings . remove ( " / Qgis / " + mCredentialsBaseKey + ' / ' + mOriginalConnName ) ; settings . sync ( ) ; } QUrl url ( txtUrl -> text ( ) . trimmed ( ) ) ; const QList < QPair < QByteArray , QByteArray > > & items = url . encodedQueryItems ( ) ; QHash < QString , QPair < QByteArray , QByteArray > > params ; for ( QList < QPair < QByteArray , QByteArray > > :: const_iterator it = items . constBegin ( ) ; it != items . constEnd ( ) ; ++ it ) { params . insert ( QString ( it -> first ) . toUpper ( ) , * it ) ; } if ( params [ " SERVICE " ] . second . toUpper ( ) == " WMS " || params [ " SERVICE " ] . second . toUpper ( ) == " WFS " || params [ " SERVICE " ] . second . toUpper ( ) == " WCS " ) { url . removeEncodedQueryItem ( params [ " SERVICE " ] . first ) ; url . removeEncodedQueryItem ( params [ " REQUEST " ] . first ) ; url . removeEncodedQueryItem ( params [ " FORMAT " ] . first ) ; } if ( url . encodedPath ( ) . isEmpty ( ) ) { url . setEncodedPath ( " / " ) ; } settings . setValue ( key + " / url " , url . toString ( ) ) ; if ( mBaseKey == " / Qgis / connections - wms / " || mBaseKey == " / Qgis / connections - wcs / " || mBaseKey == " / Qgis / connections - wfs / " ) { settings . setValue ( key + " / ignoreAxisOrientation " , cbxIgnoreAxisOrientation -> isChecked ( ) ) ; settings . setValue ( key + " / invertAxisOrientation " , cbxInvertAxisOrientation -> isChecked ( ) ) ; } if ( mBaseKey == " / Qgis / connections - wms / " || mBaseKey == " / Qgis / connections - wcs / " ) { settings . setValue ( key + " / ignoreGetMapURI " , cbxIgnoreGetMapURI -> isChecked ( ) ) ; settings . setValue ( key + " / smoothPixmapTransform " , cbxSmoothPixmapTransform -> isChecked ( ) ) ; int dpiMode = 0 ; switch ( cmbDpiMode -> currentIndex ( ) ) { case 0 : dpiMode = 7 ; break ; case 1 : dpiMode = 0 ; break ; case 2 : dpiMode = 1 ; break ; case 3 : dpiMode = 2 ; break ; case 4 : dpiMode = 4 ; break ; } settings . setValue ( key + " / dpiMode " , dpiMode ) ; } if ( mBaseKey == " / Qgis / connections - wms / " ) { settings . setValue ( key + " / ignoreGetFeatureInfoURI " , cbxIgnoreGetFeatureInfoURI -> isChecked ( ) ) ; } if ( mBaseKey == " / Qgis / connections - wfs / " ) { QString version = " auto " ; switch ( cmbVersion -> currentIndex ( ) ) { case 0 : version = " auto " ; break ; case 1 : version = "1.0.0" ; break ; case 2 : version = "1.1.0" ; break ; case 3 : version = "2.0.0" ; break ; } settings . setValue ( key + " / version " , version ) ; settings . setValue ( key + " / maxnumfeatures " , txtMaxNumFeatures -> text ( ) ) ; } settings . setValue ( key + " / referer " , txtReferer -> text ( ) ) ; settings . setValue ( credentialsKey + " / username " , txtUserName -> text ( ) ) ; settings . setValue ( credentialsKey + " / password " , txtPassword -> text ( ) ) ; settings . setValue ( credentialsKey + " / authcfg " , mAuthConfigSelect -> configId ( ) ) ; settings . setValue ( mBaseKey + " / selected " , txtName -> text ( ) ) ; QDialog :: accept ( ) ; } </DOCUMENT>
<DOCUMENT_ID="naucoin/CTK/tree/master/Libs/Widgets/Testing/Cpp/ctkExampleUseOfWorkflowWidgetUsingSignalsAndSlots.cpp"> # include < QApplication > # include < QTimer > # include " ctkWorkflow . h " # include " ctkWorkflowTabWidget . h " # include " ctkWorkflowWidgetStep . h " # include " ctkWorkflowGroupBox . h " # include " ctkExampleWorkflowWidgetStepUsingSignalsAndSlots . h " # include < cstdlib > # include < iostream > int ctkExampleUseOfWorkflowWidgetUsingSignalsAndSlots ( int argc , char * argv [ ] ) { QApplication app ( argc , argv ) ; bool hideWidgets = false ; ctkWorkflow * workflow = new ctkWorkflow ; ctkWorkflowTabWidget * workflowWidget = new ctkWorkflowTabWidget ; workflowWidget -> setWorkflow ( workflow ) ; ctkWorkflowGroupBox * groupBox = workflowWidget -> workflowGroupBox ( ) ; groupBox -> setPreText ( " I ▁ am ▁ some ▁ pre - text " ) ; groupBox -> setPostText ( " I ▁ am ▁ some ▁ post - text " ) ; groupBox -> setHideWidgetsOfNonCurrentSteps ( hideWidgets ) ; ctkWorkflowWidgetStep * testStep1 = new ctkWorkflowWidgetStep ( " Step ▁ 1" ) ; testStep1 -> setName ( " Step ▁ 1" ) ; testStep1 -> setDescription ( " I ▁ am ▁ in ▁ step ▁ 1" ) ; workflowWidget -> associateStepWithLabel ( testStep1 , " name ▁ 1" ) ; ctkWorkflowWidgetStep * testStep2 = new ctkWorkflowWidgetStep ( " Step ▁ 2" ) ; testStep2 -> setName ( " Step ▁ 2" ) ; testStep2 -> setDescription ( " I ▁ am ▁ in ▁ step ▁ 2" ) ; workflowWidget -> associateStepWithLabel ( testStep2 , " name ▁ 2" ) ; ctkWorkflowWidgetStep * testStep3 = new ctkWorkflowWidgetStep ( " Step ▁ 3" ) ; testStep3 -> setName ( " Step ▁ 3" ) ; testStep3 -> setDescription ( " I ▁ am ▁ in ▁ step ▁ 3" ) ; workflowWidget -> associateStepWithPage ( testStep3 , 1 , " name ▁ 3" ) ; workflow -> addTransition ( testStep1 , testStep2 ) ; workflow -> addTransition ( testStep2 , testStep3 ) ; ctkExampleWorkflowWidgetStepUsingSignalsAndSlots * qObject1 = new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots ( testStep1 ) ; ctkExampleWorkflowWidgetStepUsingSignalsAndSlots * qObject2 = new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots ( testStep2 ) ; ctkExampleWorkflowWidgetStepUsingSignalsAndSlots * qObject3 = new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots ( testStep3 ) ; qObject1 -> setWidget ( testStep1 -> stepArea ( ) ) ; qObject2 -> setWidget ( testStep2 -> stepArea ( ) ) ; qObject3 -> setWidget ( testStep3 -> stepArea ( ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeValidateCommand ( QString ) ) , qObject1 , SLOT ( validate ( QString ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeValidateCommand ( QString ) ) , qObject2 , SLOT ( validate ( QString ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeValidateCommand ( QString ) ) , qObject3 , SLOT ( validate ( QString ) ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnEntryCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject1 , SLOT ( onEntry ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnEntryCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject2 , SLOT ( onEntry ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnEntryCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject3 , SLOT ( onEntry ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnExitCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject1 , SLOT ( onExit ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnExitCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject2 , SLOT ( onExit ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnExitCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject3 , SLOT ( onExit ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeCreateUserInterfaceCommand ( ) ) , qObject1 , SLOT ( createUserInterface ( ) ) ) ; QObject :: connect ( qObject1 , SIGNAL ( createUserInterfaceComplete ( ) ) , testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( showUserInterfaceComplete ( ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeCreateUserInterfaceCommand ( ) ) , qObject2 , SLOT ( createUserInterface ( ) ) ) ; QObject :: connect ( qObject2 , SIGNAL ( createUserInterfaceComplete ( ) ) , testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( showUserInterfaceComplete ( ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeCreateUserInterfaceCommand ( ) ) , qObject3 , SLOT ( createUserInterface ( ) ) ) ; QObject :: connect ( qObject3 , SIGNAL ( createUserInterfaceComplete ( ) ) , testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( showUserInterfaceComplete ( ) ) ) ; testStep1 -> setHasValidateCommand ( 1 ) ; testStep1 -> setHasOnEntryCommand ( 1 ) ; testStep1 -> setHasOnExitCommand ( 1 ) ; testStep1 -> setHasCreateUserInterfaceCommand ( 1 ) ; testStep2 -> setHasValidateCommand ( 1 ) ; testStep2 -> setHasOnEntryCommand ( 1 ) ; testStep2 -> setHasOnExitCommand ( 1 ) ; testStep2 -> setHasCreateUserInterfaceCommand ( 1 ) ; testStep3 -> setHasValidateCommand ( 1 ) ; testStep3 -> setHasOnEntryCommand ( 1 ) ; testStep3 -> setHasOnExitCommand ( 1 ) ; testStep3 -> setHasCreateUserInterfaceCommand ( 1 ) ; workflow -> setInitialStep ( testStep1 ) ; workflow -> start ( ) ; workflowWidget -> show ( ) ; QTimer :: singleShot ( 500 , & app , SLOT ( quit ( ) ) ) ; app . exec ( ) ; workflow -> stop ( ) ; QTimer :: singleShot ( 100 , & app , SLOT ( quit ( ) ) ) ; app . exec ( ) ; delete workflowWidget ; return EXIT_SUCCESS ; } </DOCUMENT>
<DOCUMENT_ID="Dako300/BasicTV/tree/master/src/math/numbers/math_numbers.cpp"> # include " . . / . . / main . h " # include " . . / . . / util . h " # include " math _ numbers . h " # include " . . / math . h " # include " . . / . . / id / id _ api . h " # define MINOR_SPECIES_MULTIPLIER ( pow ( 2 , 64 ) - 1 ) static void number_sanity_fetch ( void * ptr , uint64_t start , uint64_t size , std :: vector < uint8_t > * data ) { if ( data -> size ( ) < start + size ) { print ( " can ' t ▁ copy , ▁ not ▁ enough ▁ room " , P_ERR ) ; } memcpy ( ptr , data -> data ( ) + start , size ) ; convert :: nbo :: from ( ( uint8_t * ) ptr , size ) ; } static std :: vector < uint8_t > number_sanity_fetch ( std :: vector < uint8_t > * data ) { std :: vector < uint8_t > retval ; if ( data -> size ( ) < 4 ) { print ( " not ▁ enough ▁ room ▁ to ▁ possibly ▁ encode ▁ major / minor ▁ size " , P_ERR ) ; } uint32_t size ; memcpy ( & size , data -> data ( ) , 4 ) ; size = NBO_32 ( size ) ; if ( data -> size ( ) < 4 + size ) { P_V ( size , P_WARN ) ; P_V ( data -> size ( ) , P_WARN ) ; print ( " invalid ▁ size ▁ for ▁ current ▁ number ▁ chunk " , P_ERR ) ; } retval = convert :: nbo :: from ( std :: vector < uint8_t > ( data -> begin ( ) + 4 , data -> begin ( ) + 4 + size ) ) ; data -> erase ( data -> begin ( ) , data -> begin ( ) + 4 + size ) ; return retval ; } uint64_t math :: number :: get :: unit ( std :: vector < uint8_t > data ) { uint64_t retval ; number_sanity_fetch ( & retval , 0 , sizeof ( retval ) , & data ) ; return retval ; } std :: pair < std :: vector < uint8_t > , std :: vector < uint8_t > > math :: number :: get :: raw_species ( std :: vector < uint8_t > data ) { uint64_t start = sizeof ( math_number_unit_t ) ; if ( data . size ( ) < start ) { return std :: pair < std :: vector < uint8_t > , std :: vector < uint8_t > > ( { } , { } ) ; } data . erase ( data . begin ( ) , data . begin ( ) + start ) ; std :: pair < std :: vector < uint8_t > , std :: vector < uint8_t > > retval ; retval . first = number_sanity_fetch ( & data ) ; retval . second = number_sanity_fetch ( & data ) ; return retval ; } long double math :: number :: get :: number ( std :: vector < uint8_t > data ) { long double retval ; std :: pair < std :: vector < uint8_t > , std :: vector < uint8_t > > species = math :: number :: get :: raw_species ( data ) ; if ( species . first . size ( ) > 8 || species . second . size ( ) > 8 ) { print ( " I ▁ need ▁ to ▁ expand ▁ this ▁ beyond ▁ 64 - bits " , P_ERR ) ; } uint64_t major_int = 0 , minor_int = 0 ; memcpy ( & major_int , species . first . data ( ) , species . first . size ( ) ) ; memcpy ( & minor_int , species . second . data ( ) , species . second . size ( ) ) ; retval = ( long double ) ( major_int ) + ( long double ) ( ( long double ) ( minor_int / MINOR_SPECIES_MULTIPLIER ) ) ; return retval ; } # define NUMBER_CREATE_ADD ( x ) retval . insert ( retval . end ( ) , ( uint8_t * ) & x , ( uint8_t * ) & x + sizeof ( x ) ) std :: vector < uint8_t > math :: number :: create ( long double number , uint64_t unit ) { std :: vector < uint8_t > retval ; int64_t major_int = ( ( uint64_t ) ( long double ) ( number ) ) ; uint32_t major_size = ( 8 ) ; uint64_t minor_int = ( ( ( ( long double ) number - ( long double ) major_int ) * ( long double ) MINOR_SPECIES_MULTIPLIER ) ) ; uint32_t minor_size = ( 8 ) ; unit = NBO_64 ( unit ) ; major_int = NBO_64 ( major_int ) ; major_size = NBO_32 ( major_size ) ; minor_int = NBO_64 ( minor_int ) ; minor_size = NBO_32 ( minor_size ) ; NUMBER_CREATE_ADD ( unit ) ; NUMBER_CREATE_ADD ( major_size ) ; NUMBER_CREATE_ADD ( major_int ) ; NUMBER_CREATE_ADD ( minor_size ) ; NUMBER_CREATE_ADD ( minor_int ) ; return retval ; } std :: vector < uint8_t > math :: number :: create ( uint64_t number , uint64_t unit ) { std :: vector < uint8_t > retval ; uint64_t major_int = number ; uint32_t major_size = 8 ; uint64_t minor_int = 0 ; uint32_t minor_size = 0 ; unit = NBO_64 ( unit ) ; major_int = NBO_64 ( major_int ) ; major_size = NBO_32 ( major_size ) ; minor_int = NBO_64 ( minor_int ) ; minor_size = NBO_32 ( minor_size ) ; NUMBER_CREATE_ADD ( unit ) ; NUMBER_CREATE_ADD ( major_size ) ; NUMBER_CREATE_ADD ( major_int ) ; NUMBER_CREATE_ADD ( minor_size ) ; NUMBER_CREATE_ADD ( minor_int ) ; return retval ; } std :: vector < uint8_t > math :: number :: create ( int64_t number , uint64_t unit ) { std :: vector < uint8_t > retval ; int64_t major_int = number ; uint32_t major_size = 8 ; uint64_t minor_int = 0 ; uint32_t minor_size = 0 ; unit = NBO_64 ( unit ) ; major_int = NBO_64 ( major_int ) ; major_size = NBO_32 ( major_size ) ; minor_int = NBO_64 ( minor_int ) ; minor_size = NBO_32 ( minor_size ) ; NUMBER_CREATE_ADD ( unit ) ; NUMBER_CREATE_ADD ( major_size ) ; NUMBER_CREATE_ADD ( major_int ) ; NUMBER_CREATE_ADD ( minor_size ) ; NUMBER_CREATE_ADD ( minor_int ) ; return retval ; } std :: vector < uint8_t > math :: number :: create ( std :: vector < uint8_t > raw_number_data_major , std :: vector < uint8_t > raw_number_data_minor , uint64_t unit ) { std :: vector < uint8_t > retval ; convert :: nbo :: to ( raw_number_data_major . data ( ) , raw_number_data_major . size ( ) ) ; convert :: nbo :: to ( raw_number_data_minor . data ( ) , raw_number_data_minor . size ( ) ) ; ASSERT ( raw_number_data_major . size ( ) <= UINT32_MAX , P_ERR ) ; ASSERT ( raw_number_data_minor . size ( ) <= UINT32_MAX , P_ERR ) ; uint32_t major_size = NBO_32 ( static_cast < uint32_t > ( raw_number_data_major . size ( ) ) ) ; uint32_t minor_size = NBO_32 ( static_cast < uint32_t > ( raw_number_data_minor . size ( ) ) ) ; NUMBER_CREATE_ADD ( unit ) ; NUMBER_CREATE_ADD ( major_size ) ; retval . insert ( retval . end ( ) , raw_number_data_major . begin ( ) , raw_number_data_major . end ( ) ) ; NUMBER_CREATE_ADD ( minor_size ) ; retval . insert ( retval . end ( ) , raw_number_data_minor . begin ( ) , raw_number_data_minor . end ( ) ) ; } void math :: number :: add_data_to_set ( std :: vector < std :: vector < uint8_t > > data , id_t_ math_number_set_id ) { math_number_set_t * math_number_set_ptr = PTR_DATA ( math_number_set_id , math_number_set_t ) ; if ( math_number_set_ptr == nullptr ) { print ( " math _ number _ set _ ptr ▁ is ▁ a ▁ nullptr " , P_ERR ) ; } math_number_set_ptr -> add_data ( data ) ; } </DOCUMENT>
<DOCUMENT_ID="lunastorm/wissbi/tree/master/3rd_party/libcxx/test/strings/basic.string/string.modifiers/string_append/pointer.pass.cpp"> # include < string > # include < stdexcept > # include < cassert > template < class S > void test ( S s , const typename S :: value_type * str , S expected ) { s . append ( str ) ; assert ( s . __invariants ( ) ) ; assert ( s == expected ) ; } int main ( ) { typedef std :: string S ; test ( S ( ) , " " , S ( ) ) ; test ( S ( ) , "12345" , S ( "12345" ) ) ; test ( S ( ) , "12345678901234567890" , S ( "12345678901234567890" ) ) ; test ( S ( "12345" ) , " " , S ( "12345" ) ) ; test ( S ( "12345" ) , "12345" , S ( "1234512345" ) ) ; test ( S ( "12345" ) , "1234567890" , S ( "123451234567890" ) ) ; test ( S ( "12345678901234567890" ) , " " , S ( "12345678901234567890" ) ) ; test ( S ( "12345678901234567890" ) , "12345" , S ( "1234567890123456789012345" ) ) ; test ( S ( "12345678901234567890" ) , "12345678901234567890" , S ( "1234567890123456789012345678901234567890" ) ) ; } </DOCUMENT>
<DOCUMENT_ID="geofl/JK2_1.02Source/tree/master/CODE-mp/server/sv_world.cpp"> # include " server . h " clipHandle_t SV_ClipHandleForEntity ( const sharedEntity_t * ent ) { if ( ent -> r . bmodel ) { return CM_InlineModel ( ent -> s . modelindex ) ; } if ( ent -> r . svFlags & SVF_CAPSULE ) { return CM_TempBoxModel ( ent -> r . mins , ent -> r . maxs , qtrue ) ; } return CM_TempBoxModel ( ent -> r . mins , ent -> r . maxs , qfalse ) ; } typedef struct worldSector_s { int axis ; float dist ; struct worldSector_s * children [ 2 ] ; svEntity_t * entities ; } worldSector_t ; # define AREA_DEPTH 4 # define AREA_NODES 64 worldSector_t sv_worldSectors [ AREA_NODES ] ; int sv_numworldSectors ; void SV_SectorList_f ( void ) { int i , c ; worldSector_t * sec ; svEntity_t * ent ; for ( i = 0 ; i < AREA_NODES ; i ++ ) { sec = & sv_worldSectors [ i ] ; c = 0 ; for ( ent = sec -> entities ; ent ; ent = ent -> nextEntityInWorldSector ) { c ++ ; } Com_Printf ( " sector ▁ % i : ▁ % i ▁ entities \n " , i , c ) ; } } worldSector_t * SV_CreateworldSector ( int depth , vec3_t mins , vec3_t maxs ) { worldSector_t * anode ; vec3_t size ; vec3_t mins1 , maxs1 , mins2 , maxs2 ; anode = & sv_worldSectors [ sv_numworldSectors ] ; sv_numworldSectors ++ ; if ( depth == AREA_DEPTH ) { anode -> axis = - 1 ; anode -> children [ 0 ] = anode -> children [ 1 ] = NULL ; return anode ; } VectorSubtract ( maxs , mins , size ) ; if ( size [ 0 ] > size [ 1 ] ) { anode -> axis = 0 ; } else { anode -> axis = 1 ; } anode -> dist = 0.5 * ( maxs [ anode -> axis ] + mins [ anode -> axis ] ) ; VectorCopy ( mins , mins1 ) ; VectorCopy ( mins , mins2 ) ; VectorCopy ( maxs , maxs1 ) ; VectorCopy ( maxs , maxs2 ) ; maxs1 [ anode -> axis ] = mins2 [ anode -> axis ] = anode -> dist ; anode -> children [ 0 ] = SV_CreateworldSector ( depth + 1 , mins2 , maxs2 ) ; anode -> children [ 1 ] = SV_CreateworldSector ( depth + 1 , mins1 , maxs1 ) ; return anode ; } void SV_ClearWorld ( void ) { clipHandle_t h ; vec3_t mins , maxs ; Com_Memset ( sv_worldSectors , 0 , sizeof ( sv_worldSectors ) ) ; sv_numworldSectors = 0 ; h = CM_InlineModel ( 0 ) ; CM_ModelBounds ( h , mins , maxs ) ; SV_CreateworldSector ( 0 , mins , maxs ) ; } void SV_UnlinkEntity ( sharedEntity_t * gEnt ) { svEntity_t * ent ; svEntity_t * scan ; worldSector_t * ws ; ent = SV_SvEntityForGentity ( gEnt ) ; gEnt -> r . linked = qfalse ; ws = ent -> worldSector ; if ( ! ws ) { return ; } ent -> worldSector = NULL ; if ( ws -> entities == ent ) { ws -> entities = ent -> nextEntityInWorldSector ; return ; } for ( scan = ws -> entities ; scan ; scan = scan -> nextEntityInWorldSector ) { if ( scan -> nextEntityInWorldSector == ent ) { scan -> nextEntityInWorldSector = ent -> nextEntityInWorldSector ; return ; } } Com_Printf ( " WARNING : ▁ SV _ UnlinkEntity : ▁ not ▁ found ▁ in ▁ worldSector \n " ) ; } # define MAX_TOTAL_ENT_LEAFS 128 void SV_LinkEntity ( sharedEntity_t * gEnt ) { worldSector_t * node ; int leafs [ MAX_TOTAL_ENT_LEAFS ] ; int cluster ; int num_leafs ; int i , j , k ; int area ; int lastLeaf ; float * origin , * angles ; svEntity_t * ent ; ent = SV_SvEntityForGentity ( gEnt ) ; if ( ent -> worldSector ) { SV_UnlinkEntity ( gEnt ) ; } if ( gEnt -> r . bmodel ) { gEnt -> s . solid = SOLID_BMODEL ; } else if ( gEnt -> r . contents & ( CONTENTS_SOLID | CONTENTS_BODY ) ) { i = gEnt -> r . maxs [ 0 ] ; if ( i < 1 ) i = 1 ; if ( i > 255 ) i = 255 ; j = ( - gEnt -> r . mins [ 2 ] ) ; if ( j < 1 ) j = 1 ; if ( j > 255 ) j = 255 ; k = ( gEnt -> r . maxs [ 2 ] + 32 ) ; if ( k < 1 ) k = 1 ; if ( k > 255 ) k = 255 ; gEnt -> s . solid = ( k << 16 ) | ( j << 8 ) | i ; } else { gEnt -> s . solid = 0 ; } origin = gEnt -> r . currentOrigin ; angles = gEnt -> r . currentAngles ; if ( gEnt -> r . bmodel && ( angles [ 0 ] || angles [ 1 ] || angles [ 2 ] ) ) { float max ; int i ; max = RadiusFromBounds ( gEnt -> r . mins , gEnt -> r . maxs ) ; for ( i = 0 ; i < 3 ; i ++ ) { gEnt -> r . absmin [ i ] = origin [ i ] - max ; gEnt -> r . absmax [ i ] = origin [ i ] + max ; } } else { VectorAdd ( origin , gEnt -> r . mins , gEnt -> r . absmin ) ; VectorAdd ( origin , gEnt -> r . maxs , gEnt -> r . absmax ) ; } gEnt -> r . absmin [ 0 ] -= 1 ; gEnt -> r . absmin [ 1 ] -= 1 ; gEnt -> r . absmin [ 2 ] -= 1 ; gEnt -> r . absmax [ 0 ] += 1 ; gEnt -> r . absmax [ 1 ] += 1 ; gEnt -> r . absmax [ 2 ] += 1 ; ent -> numClusters = 0 ; ent -> lastCluster = 0 ; ent -> areanum = - 1 ; ent -> areanum2 = - 1 ; num_leafs = CM_BoxLeafnums ( gEnt -> r . absmin , gEnt -> r . absmax , leafs , MAX_TOTAL_ENT_LEAFS , & lastLeaf ) ; if ( ! num_leafs ) { return ; } for ( i = 0 ; i < num_leafs ; i ++ ) { area = CM_LeafArea ( leafs [ i ] ) ; if ( area != - 1 ) { if ( ent -> areanum != - 1 && ent -> areanum != area ) { if ( ent -> areanum2 != - 1 && ent -> areanum2 != area && sv . state == SS_LOADING ) { Com_DPrintf ( " Object ▁ % i ▁ touching ▁ 3 ▁ areas ▁ at ▁ % f ▁ % f ▁ % f \n " , gEnt -> s . number , gEnt -> r . absmin [ 0 ] , gEnt -> r . absmin [ 1 ] , gEnt -> r . absmin [ 2 ] ) ; } ent -> areanum2 = area ; } else { ent -> areanum = area ; } } } ent -> numClusters = 0 ; for ( i = 0 ; i < num_leafs ; i ++ ) { cluster = CM_LeafCluster ( leafs [ i ] ) ; if ( cluster != - 1 ) { ent -> clusternums [ ent -> numClusters ++ ] = cluster ; if ( ent -> numClusters == MAX_ENT_CLUSTERS ) { break ; } } } if ( i != num_leafs ) { ent -> lastCluster = CM_LeafCluster ( lastLeaf ) ; } gEnt -> r . linkcount ++ ; node = sv_worldSectors ; while ( 1 ) { if ( node -> axis == - 1 ) break ; if ( gEnt -> r . absmin [ node -> axis ] > node -> dist ) node = node -> children [ 0 ] ; else if ( gEnt -> r . absmax [ node -> axis ] < node -> dist ) node = node -> children [ 1 ] ; else break ; } ent -> worldSector = node ; ent -> nextEntityInWorldSector = node -> entities ; node -> entities = ent ; gEnt -> r . linked = qtrue ; } typedef struct { const float * mins ; const float * maxs ; int * list ; int count , maxcount ; } areaParms_t ; void SV_AreaEntities_r ( worldSector_t * node , areaParms_t * ap ) { svEntity_t * check , * next ; sharedEntity_t * gcheck ; int count ; count = 0 ; for ( check = node -> entities ; check ; check = next ) { next = check -> nextEntityInWorldSector ; gcheck = SV_GEntityForSvEntity ( check ) ; if ( gcheck -> r . absmin [ 0 ] > ap -> maxs [ 0 ] || gcheck -> r . absmin [ 1 ] > ap -> maxs [ 1 ] || gcheck -> r . absmin [ 2 ] > ap -> maxs [ 2 ] || gcheck -> r . absmax [ 0 ] < ap -> mins [ 0 ] || gcheck -> r . absmax [ 1 ] < ap -> mins [ 1 ] || gcheck -> r . absmax [ 2 ] < ap -> mins [ 2 ] ) { continue ; } if ( ap -> count == ap -> maxcount ) { Com_Printf ( " SV _ AreaEntities : ▁ MAXCOUNT \n " ) ; return ; } ap -> list [ ap -> count ] = check - sv . svEntities ; ap -> count ++ ; } if ( node -> axis == - 1 ) { return ; } if ( ap -> maxs [ node -> axis ] > node -> dist ) { SV_AreaEntities_r ( node -> children [ 0 ] , ap ) ; } if ( ap -> mins [ node -> axis ] < node -> dist ) { SV_AreaEntities_r ( node -> children [ 1 ] , ap ) ; } } int SV_AreaEntities ( const vec3_t mins , const vec3_t maxs , int * entityList , int maxcount ) { areaParms_t ap ; ap . mins = mins ; ap . maxs = maxs ; ap . list = entityList ; ap . count = 0 ; ap . maxcount = maxcount ; SV_AreaEntities_r ( sv_worldSectors , & ap ) ; return ap . count ; } typedef struct { vec3_t boxmins , boxmaxs ; const float * mins ; const float * maxs ; vec3_t start ; vec3_t end ; int passEntityNum ; int contentmask ; int capsule ; int traceFlags ; int useLod ; trace_t trace ; } moveclip_t ; void SV_ClipToEntity ( trace_t * trace , const vec3_t start , const vec3_t mins , const vec3_t maxs , const vec3_t end , int entityNum , int contentmask , int capsule ) { sharedEntity_t * touch ; clipHandle_t clipHandle ; float * origin , * angles ; touch = SV_GentityNum ( entityNum ) ; Com_Memset ( trace , 0 , sizeof ( trace_t ) ) ; if ( ! ( contentmask & touch -> r . contents ) ) { trace -> fraction = 1.0 ; return ; } clipHandle = SV_ClipHandleForEntity ( touch ) ; origin = touch -> r . currentOrigin ; angles = touch -> r . currentAngles ; if ( ! touch -> r . bmodel ) { angles = vec3_origin ; } CM_TransformedBoxTrace ( trace , ( float * ) start , ( float * ) end , ( float * ) mins , ( float * ) maxs , clipHandle , contentmask , origin , angles , capsule ) ; if ( trace -> fraction < 1 ) { trace -> entityNum = touch -> s . number ; } } void SV_ClipMoveToEntities ( moveclip_t * clip ) { int i , num ; int touchlist [ MAX_GENTITIES ] ; sharedEntity_t * touch ; int passOwnerNum ; trace_t trace , oldTrace ; clipHandle_t clipHandle ; float * origin , * angles ; int thisOwnerShared = 1 ; num = SV_AreaEntities ( clip -> boxmins , clip -> boxmaxs , touchlist , MAX_GENTITIES ) ; if ( clip -> passEntityNum != ENTITYNUM_NONE ) { passOwnerNum = ( SV_GentityNum ( clip -> passEntityNum ) ) -> r . ownerNum ; if ( passOwnerNum == ENTITYNUM_NONE ) { passOwnerNum = - 1 ; } } else { passOwnerNum = - 1 ; } if ( SV_GentityNum ( clip -> passEntityNum ) -> r . svFlags & SVF_OWNERNOTSHARED ) { thisOwnerShared = 0 ; } for ( i = 0 ; i < num ; i ++ ) { if ( clip -> trace . allsolid ) { return ; } touch = SV_GentityNum ( touchlist [ i ] ) ; if ( clip -> passEntityNum != ENTITYNUM_NONE ) { if ( touchlist [ i ] == clip -> passEntityNum ) { continue ; } if ( touch -> r . ownerNum == clip -> passEntityNum ) { if ( touch -> r . svFlags & SVF_OWNERNOTSHARED ) { if ( clip -> contentmask != ( MASK_SHOT | CONTENTS_LIGHTSABER ) && clip -> contentmask != ( MASK_SHOT ) ) { continue ; } } else { continue ; } } if ( touch -> r . ownerNum == passOwnerNum && ! ( touch -> r . svFlags & SVF_OWNERNOTSHARED ) && ! thisOwnerShared ) { continue ; } } if ( ! ( clip -> contentmask & touch -> r . contents ) ) { continue ; } if ( ( clip -> contentmask == ( MASK_SHOT | CONTENTS_LIGHTSABER ) || clip -> contentmask == MASK_SHOT ) && ( touch -> r . contents > 0 && ( touch -> r . contents & CONTENTS_NOSHOT ) ) ) { continue ; } clipHandle = SV_ClipHandleForEntity ( touch ) ; origin = touch -> r . currentOrigin ; angles = touch -> r . currentAngles ; if ( ! touch -> r . bmodel ) { angles = vec3_origin ; } CM_TransformedBoxTrace ( & trace , ( float * ) clip -> start , ( float * ) clip -> end , ( float * ) clip -> mins , ( float * ) clip -> maxs , clipHandle , clip -> contentmask , origin , angles , clip -> capsule ) ; oldTrace = clip -> trace ; if ( trace . allsolid ) { clip -> trace . allsolid = qtrue ; trace . entityNum = touch -> s . number ; } else if ( trace . startsolid ) { clip -> trace . startsolid = qtrue ; trace . entityNum = touch -> s . number ; } if ( trace . fraction < clip -> trace . fraction ) { qboolean oldStart ; oldStart = clip -> trace . startsolid ; trace . entityNum = touch -> s . number ; clip -> trace = trace ; clip -> trace . startsolid = ( qboolean ) ( ( unsigned ) clip -> trace . startsolid | ( unsigned ) oldStart ) ; } # if 0 if ( ( trace . entityNum == touch -> s . number ) && ( clip -> traceFlags ) ) { if ( touch -> s . ghoul2 ) { int oldTraceRecSize = 0 ; int newTraceRecSize = 0 ; int z ; for ( z = 0 ; z < MAX_G2_COLLISIONS ; z ++ ) { if ( clip -> trace . G2CollisionMap [ z ] . mEntityNum != - 1 ) { oldTraceRecSize ++ ; } } G2API_CollisionDetect ( & clip -> trace . G2CollisionMap [ 0 ] , * ( ( CGhoul2Info_v * ) touch -> s . ghoul2 ) , touch -> s . angles , touch -> s . origin , svs . time , touch -> s . number , clip -> start , clip -> end , touch -> s . modelScale , G2VertSpaceServer , clip -> traceFlags , clip -> useLod ) ; for ( z = 0 ; z < MAX_G2_COLLISIONS ; z ++ ) { if ( clip -> trace . G2CollisionMap [ z ] . mEntityNum != - 1 ) { newTraceRecSize ++ ; } } if ( newTraceRecSize == oldTraceRecSize ) { clip -> trace = oldTrace ; } } } # endif } } void SV_Trace ( trace_t * results , const vec3_t start , const vec3_t mins , const vec3_t maxs , const vec3_t end , int passEntityNum , int contentmask , int capsule , int traceFlags , int useLod ) { moveclip_t clip ; int i ; if ( ! mins ) { mins = vec3_origin ; } if ( ! maxs ) { maxs = vec3_origin ; } Com_Memset ( & clip , 0 , sizeof ( moveclip_t ) ) ; CM_BoxTrace ( & clip . trace , start , end , mins , maxs , 0 , contentmask , capsule ) ; clip . trace . entityNum = clip . trace . fraction != 1.0 ? ENTITYNUM_WORLD : ENTITYNUM_NONE ; if ( clip . trace . fraction == 0 ) { * results = clip . trace ; return ; } clip . contentmask = contentmask ; VectorCopy ( start , clip . start ) ; clip . traceFlags = traceFlags ; clip . useLod = useLod ; VectorCopy ( end , clip . end ) ; clip . mins = mins ; clip . maxs = maxs ; clip . passEntityNum = passEntityNum ; clip . capsule = capsule ; for ( i = 0 ; i < 3 ; i ++ ) { if ( end [ i ] > start [ i ] ) { clip . boxmins [ i ] = clip . start [ i ] + clip . mins [ i ] - 1 ; clip . boxmaxs [ i ] = clip . end [ i ] + clip . maxs [ i ] + 1 ; } else { clip . boxmins [ i ] = clip . end [ i ] + clip . mins [ i ] - 1 ; clip . boxmaxs [ i ] = clip . start [ i ] + clip . maxs [ i ] + 1 ; } } SV_ClipMoveToEntities ( & clip ) ; * results = clip . trace ; } int SV_PointContents ( const vec3_t p , int passEntityNum ) { int touch [ MAX_GENTITIES ] ; sharedEntity_t * hit ; int i , num ; int contents , c2 ; clipHandle_t clipHandle ; float * angles ; contents = CM_PointContents ( p , 0 ) ; num = SV_AreaEntities ( p , p , touch , MAX_GENTITIES ) ; for ( i = 0 ; i < num ; i ++ ) { if ( touch [ i ] == passEntityNum ) { continue ; } hit = SV_GentityNum ( touch [ i ] ) ; clipHandle = SV_ClipHandleForEntity ( hit ) ; angles = hit -> s . angles ; if ( ! hit -> r . bmodel ) { angles = vec3_origin ; } c2 = CM_TransformedPointContents ( p , clipHandle , hit -> s . origin , hit -> s . angles ) ; contents |= c2 ; } return contents ; } </DOCUMENT>
<DOCUMENT_ID="Riztazz/trinitycore-m4a/tree/master/src/server/scripts/EasternKingdoms/Stratholme/boss_nerubenkan.cpp"> # include " stdafx . hpp " # include " ScriptMgr . h " # include " ScriptedCreature . h " # include " stratholme . h " enum Spells { SPELL_ENCASINGWEBS = 4962 , SPELL_PIERCEARMOR = 6016 , SPELL_CRYPT_SCARABS = 31602 , SPELL_RAISEUNDEADSCARAB = 17235 } ; class boss_nerubenkan : public CreatureScript { public : boss_nerubenkan ( ) : CreatureScript ( " boss _ nerubenkan " ) { } CreatureAI * GetAI ( Creature * creature ) const { return new boss_nerubenkanAI ( creature ) ; } struct boss_nerubenkanAI : public ScriptedAI { boss_nerubenkanAI ( Creature * creature ) : ScriptedAI ( creature ) { instance = me -> GetInstanceScript ( ) ; } InstanceScript * instance ; uint32 EncasingWebs_Timer ; uint32 PierceArmor_Timer ; uint32 CryptScarabs_Timer ; uint32 RaiseUndeadScarab_Timer ; void Reset ( ) { CryptScarabs_Timer = 3000 ; EncasingWebs_Timer = 7000 ; PierceArmor_Timer = 19000 ; RaiseUndeadScarab_Timer = 3000 ; } void EnterCombat ( Unit * ) { } void JustDied ( Unit * ) { if ( instance ) instance -> SetData ( TYPE_NERUB , IN_PROGRESS ) ; } void RaiseUndeadScarab ( Unit * victim ) { if ( Creature * pUndeadScarab = DoSpawnCreature ( 10876 , float ( irand ( - 9 , 9 ) ) , float ( irand ( - 9 , 9 ) ) , 0 , 0 , TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN , 180000 ) ) if ( pUndeadScarab -> AI ( ) ) pUndeadScarab -> AI ( ) -> AttackStart ( victim ) ; } void UpdateAI ( const uint32 diff ) { if ( ! UpdateVictim ( ) ) return ; if ( EncasingWebs_Timer <= diff ) { DoCast ( me -> getVictim ( ) , SPELL_ENCASINGWEBS ) ; EncasingWebs_Timer = 30000 ; } else EncasingWebs_Timer -= diff ; if ( PierceArmor_Timer <= diff ) { if ( urand ( 0 , 3 ) < 2 ) DoCast ( me -> getVictim ( ) , SPELL_PIERCEARMOR ) ; PierceArmor_Timer = 35000 ; } else PierceArmor_Timer -= diff ; if ( CryptScarabs_Timer <= diff ) { DoCast ( me -> getVictim ( ) , SPELL_CRYPT_SCARABS ) ; CryptScarabs_Timer = 20000 ; } else CryptScarabs_Timer -= diff ; if ( RaiseUndeadScarab_Timer <= diff ) { RaiseUndeadScarab ( me -> getVictim ( ) ) ; RaiseUndeadScarab_Timer = 16000 ; } else RaiseUndeadScarab_Timer -= diff ; DoMeleeAttackIfReady ( ) ; } } ; } ; void AddSC_boss_nerubenkan ( ) { new boss_nerubenkan ( ) ; } </DOCUMENT>
<DOCUMENT_ID="AshamaneProject/AshamaneCore/tree/master/dep/CascLib/src/CascDecompress.cpp"> # define __CASCLIB_SELF__ # include " CascLib . h " # include " CascCommon . h " DWORD CascDecompress ( LPBYTE pbOutBuffer , PDWORD pcbOutBuffer , LPBYTE pbInBuffer , DWORD cbInBuffer ) { z_stream z ; DWORD dwErrCode = ERROR_FILE_CORRUPT ; uInt cbOutBuffer = * pcbOutBuffer ; int nResult ; z . next_in = pbInBuffer ; z . avail_in = cbInBuffer ; z . total_in = cbInBuffer ; z . next_out = pbOutBuffer ; z . avail_out = cbOutBuffer ; z . total_out = 0 ; z . zalloc = NULL ; z . zfree = NULL ; cbOutBuffer = 0 ; if ( ( nResult = inflateInit ( & z ) ) == Z_OK ) { nResult = inflate ( & z , Z_NO_FLUSH ) ; if ( nResult == Z_OK || nResult == Z_STREAM_END ) { cbOutBuffer = z . total_out ; dwErrCode = ERROR_SUCCESS ; } inflateEnd ( & z ) ; } pcbOutBuffer [ 0 ] = cbOutBuffer ; return dwErrCode ; } </DOCUMENT>
<DOCUMENT_ID="arangodb/arangodb/tree/master/3rdParty/boost/1.71.0/libs/hana/example/chain.cpp"> # include < boost / hana / assert . hpp > # include < boost / hana / chain . hpp > # include < boost / hana / config . hpp > # include < boost / hana / equal . hpp > # include < boost / hana / optional . hpp > namespace hana = boost :: hana ; BOOST_HANA_CONSTEXPR_LAMBDA auto deref = [ ] ( auto x ) -> decltype ( * x ) { return * x ; } ; BOOST_HANA_CONSTEXPR_LAMBDA auto age = [ ] ( auto x ) -> decltype ( x . age ) { return x . age ; } ; BOOST_HANA_CONSTEXPR_LAMBDA auto f = [ ] ( auto x ) { return hana :: chain ( hana :: sfinae ( deref ) ( x ) , hana :: sfinae ( age ) ) ; } ; struct Person { unsigned int age ; } ; int main ( ) { constexpr Person john { 30 } ; BOOST_HANA_CONSTANT_CHECK ( f ( john ) == hana :: nothing ) ; BOOST_HANA_CONSTANT_CHECK ( f ( 1 ) == hana :: nothing ) ; BOOST_HANA_CONSTEXPR_CHECK ( f ( & john ) == hana :: just ( 30u ) ) ; } </DOCUMENT>
<DOCUMENT_ID="MazZzinatus/storm/tree/master/src/test/storm-pars/utility/ModelInstantiatorTest.cpp"> # include " gtest / gtest . h " # include " storm - config . h " # ifdef STORM_HAVE_CARL # include " storm / adapters / RationalFunctionAdapter . h " # include < carl / numbers / numbers . h > # include < carl / core / VariablePool . h > # include " storm / settings / SettingsManager . h " # include " storm / settings / modules / GeneralSettings . h " # include " storm - pars / utility / ModelInstantiator . h " # include " storm / api / storm . h " # include " storm / models / sparse / Model . h " # include " storm / models / sparse / Dtmc . h " # include " storm / models / sparse / Mdp . h " TEST ( ModelInstantiatorTest , BrpProb ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pdtmc / brp16_2 . pm " ; std :: string formulaAsString = " P = ? ▁ [ F ▁ s = 5 ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> dtmc = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Dtmc < storm :: RationalFunction > , storm :: models :: sparse :: Dtmc < double >> modelInstantiator ( * dtmc ) ; EXPECT_FALSE ( dtmc -> hasRewardModel ( ) ) ; { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.8 ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.2989278941 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_EQ ( 0.0 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] ) ; } { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.01588055832 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } } TEST ( ModelInstantiatorTest , Brp_Rew ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pdtmc / brp16_2 . pm " ; std :: string formulaAsString = " R = ? ▁ [ F ▁ ( ( s = 5 ) ▁ | ▁ ( s = 0 & srep = 3 ) ) ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> dtmc = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Dtmc < storm :: RationalFunction > , storm :: models :: sparse :: Dtmc < double >> modelInstantiator ( * dtmc ) ; { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & TOMsg = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " TOMsg " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & TOAck = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " TOAck " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.3 ) ) ) ; valuation . insert ( std :: make_pair ( TOMsg , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.3 ) ) ) ; valuation . insert ( std :: make_pair ( TOAck , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.5 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } ASSERT_TRUE ( instantiated . hasUniqueRewardModel ( ) ) ; EXPECT_FALSE ( instantiated . getUniqueRewardModel ( ) . hasStateRewards ( ) ) ; EXPECT_FALSE ( instantiated . getUniqueRewardModel ( ) . hasTransitionRewards ( ) ) ; EXPECT_TRUE ( instantiated . getUniqueRewardModel ( ) . hasStateActionRewards ( ) ) ; ASSERT_TRUE ( dtmc -> getUniqueRewardModel ( ) . hasStateActionRewards ( ) ) ; std :: size_t stateActionEntries = dtmc -> getUniqueRewardModel ( ) . getStateActionRewardVector ( ) . size ( ) ; ASSERT_EQ ( stateActionEntries , instantiated . getUniqueRewardModel ( ) . getStateActionRewardVector ( ) . size ( ) ) ; for ( std :: size_t i = 0 ; i < stateActionEntries ; ++ i ) { double evaluatedValue = carl :: toDouble ( dtmc -> getUniqueRewardModel ( ) . getStateActionRewardVector ( ) [ i ] . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiated . getUniqueRewardModel ( ) . getStateActionRewardVector ( ) [ i ] ) ; } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 1.308324495 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } } TEST ( ModelInstantiatorTest , Consensus ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pmdp / coin2_2 . nm " ; std :: string formulaAsString = " Pmin = ? ▁ [ F ▁ \ " finished\ " & \ " all _ coins _ equal _ 1\ " ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Mdp < storm :: RationalFunction >> mdp = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Mdp < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Mdp < storm :: RationalFunction > , storm :: models :: sparse :: Mdp < double >> modelInstantiator ( * mdp ) ; std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & p1 = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " p1" ) ; ASSERT_NE ( p1 , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & p2 = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " p2" ) ; ASSERT_NE ( p2 , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( p1 , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.51 ) ) ) ; valuation . insert ( std :: make_pair ( p2 , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.49 ) ) ) ; storm :: models :: sparse :: Mdp < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < mdp -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : mdp -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( mdp -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( mdp -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseMdpPrctlModelChecker < storm :: models :: sparse :: Mdp < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.3526577219 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } # endif </DOCUMENT>
<DOCUMENT_ID="verybadsoldier/xbmc/tree/master/xbmc/visualizations/Vortex/angelscript/angelscript/source/as_scriptengine.cpp"> # include < stdlib . h > # include " as _ config . h " # include " as _ scriptengine . h " # include " as _ builder . h " # include " as _ context . h " # include " as _ string _ util . h " # include " as _ tokenizer . h " # include " as _ texts . h " # include " as _ module . h " # include " as _ callfunc . h " # include " as _ arrayobject . h " # include " as _ generic . h " # include " as _ scriptobject . h " # include " as _ compiler . h " BEGIN_AS_NAMESPACE extern " C " { AS_API const char * asGetLibraryVersion ( ) { # ifdef _DEBUG return ANGELSCRIPT_VERSION_STRING " ▁ DEBUG " ; # else return ANGELSCRIPT_VERSION_STRING ; # endif } AS_API const char * asGetLibraryOptions ( ) { const char * string = " ▁ " # ifdef AS_MAX_PORTABILITY " AS _ MAX _ PORTABILITY ▁ " # endif # ifdef AS_DEBUG " AS _ DEBUG ▁ " # endif # ifdef AS_NO_CLASS_METHODS " AS _ NO _ CLASS _ METHODS ▁ " # endif # ifdef AS_USE_DOUBLE_AS_FLOAT " AS _ USE _ DOUBLE _ AS _ FLOAT ▁ " # endif # ifdef AS_64BIT_PTR " AS _ 64BIT _ PTR ▁ " # endif # ifdef AS_NO_THREADS " AS _ NO _ THREADS ▁ " # endif # ifdef AS_NO_ATOMIC " AS _ NO _ ATOMIC ▁ " # endif # ifdef AS_WIN " AS _ WIN ▁ " # endif # ifdef AS_LINUX " AS _ LINUX ▁ " # endif # ifdef AS_MAC " AS _ MAC ▁ " # endif # ifdef AS_BSD " AS _ BSD ▁ " # endif # ifdef AS_XBOX " AS _ XBOX ▁ " # endif # ifdef AS_XBOX360 " AS _ XBOX360 ▁ " # endif # ifdef AS_PSP " AS _ PSP ▁ " # endif # ifdef AS_PS2 " AS _ PS2 ▁ " # endif # ifdef AS_PS3 " AS _ PS3 ▁ " # endif # ifdef AS_DC " AS _ DC ▁ " # endif # ifdef AS_GC " AS _ GC ▁ " # endif # ifdef AS_WII " AS _ WII ▁ " # endif # ifdef AS_IPHONE " AS _ IPHONE ▁ " # endif # ifdef AS_ANDROID " AS _ ANDROID ▁ " # endif # ifdef AS_PPC " AS _ PPC ▁ " # endif # ifdef AS_PPC_64 " AS _ PPC _ 64 ▁ " # endif # ifdef AS_X86 " AS _ X86 ▁ " # endif # ifdef AS_MIPS " AS _ MIPS ▁ " # endif # ifdef AS_SH4 " AS _ SH4 ▁ " # endif # ifdef AS_XENON " AS _ XENON ▁ " # endif # ifdef AS_ARM " AS _ ARM ▁ " # endif ; return string ; } AS_API asIScriptEngine * asCreateScriptEngine ( asDWORD version ) { if ( ( version / 10000 ) != ( ANGELSCRIPT_VERSION / 10000 ) ) return 0 ; if ( ( version / 100 ) % 100 != ( ANGELSCRIPT_VERSION / 100 ) % 100 ) return 0 ; if ( ( version % 100 ) > ( ANGELSCRIPT_VERSION % 100 ) ) return 0 ; asASSERT ( sizeof ( asBYTE ) == 1 ) ; asASSERT ( sizeof ( asWORD ) == 2 ) ; asASSERT ( sizeof ( asDWORD ) == 4 ) ; asASSERT ( sizeof ( asQWORD ) == 8 ) ; asASSERT ( sizeof ( asPWORD ) == sizeof ( void * ) ) ; asASSERT ( sizeof ( bool ) == AS_SIZEOF_BOOL ) ; asASSERT ( true == VALUE_OF_BOOLEAN_TRUE ) ; # ifdef AS_BIG_ENDIAN asASSERT ( * ( asDWORD * ) " \x00\x01\x02\x03" == 0x00010203 ) ; asASSERT ( * ( asQWORD * ) " \x00\x01\x02\x03\x04\x05\x06\x07" == I64 ( 0x0001020304050607 ) ) ; # else asASSERT ( * ( asDWORD * ) " \x00\x01\x02\x03" == 0x03020100 ) ; asASSERT ( * ( asQWORD * ) " \x00\x01\x02\x03\x04\x05\x06\x07" == I64 ( 0x0706050403020100 ) ) ; # endif return asNEW ( asCScriptEngine ) ( ) ; } int asCScriptEngine :: SetEngineProperty ( asEEngineProp property , asPWORD value ) { switch ( property ) { case asEP_ALLOW_UNSAFE_REFERENCES : ep . allowUnsafeReferences = value ? true : false ; break ; case asEP_OPTIMIZE_BYTECODE : ep . optimizeByteCode = value ? true : false ; break ; case asEP_COPY_SCRIPT_SECTIONS : ep . copyScriptSections = value ? true : false ; break ; case asEP_MAX_STACK_SIZE : ep . maximumContextStackSize = ( int ) value / 4 ; if ( initialContextStackSize > ep . maximumContextStackSize ) initialContextStackSize = ep . maximumContextStackSize ; break ; case asEP_USE_CHARACTER_LITERALS : ep . useCharacterLiterals = value ? true : false ; break ; case asEP_ALLOW_MULTILINE_STRINGS : ep . allowMultilineStrings = value ? true : false ; break ; case asEP_ALLOW_IMPLICIT_HANDLE_TYPES : ep . allowImplicitHandleTypes = value ? true : false ; break ; case asEP_BUILD_WITHOUT_LINE_CUES : ep . buildWithoutLineCues = value ? true : false ; break ; case asEP_INIT_GLOBAL_VARS_AFTER_BUILD : ep . initGlobalVarsAfterBuild = value ? true : false ; break ; case asEP_REQUIRE_ENUM_SCOPE : ep . requireEnumScope = value ? true : false ; break ; case asEP_SCRIPT_SCANNER : if ( value <= 1 ) ep . scanner = ( int ) value ; else return asINVALID_ARG ; break ; case asEP_INCLUDE_JIT_INSTRUCTIONS : ep . includeJitInstructions = value ? true : false ; break ; case asEP_STRING_ENCODING : if ( value <= 1 ) ep . stringEncoding = ( int ) value ; else return asINVALID_ARG ; break ; default : return asINVALID_ARG ; } return asSUCCESS ; } asPWORD asCScriptEngine :: GetEngineProperty ( asEEngineProp property ) { switch ( property ) { case asEP_ALLOW_UNSAFE_REFERENCES : return ep . allowUnsafeReferences ; case asEP_OPTIMIZE_BYTECODE : return ep . optimizeByteCode ; case asEP_COPY_SCRIPT_SECTIONS : return ep . copyScriptSections ; case asEP_MAX_STACK_SIZE : return ep . maximumContextStackSize * 4 ; case asEP_USE_CHARACTER_LITERALS : return ep . useCharacterLiterals ; case asEP_ALLOW_MULTILINE_STRINGS : return ep . allowMultilineStrings ; case asEP_ALLOW_IMPLICIT_HANDLE_TYPES : return ep . allowImplicitHandleTypes ; case asEP_BUILD_WITHOUT_LINE_CUES : return ep . buildWithoutLineCues ; case asEP_INIT_GLOBAL_VARS_AFTER_BUILD : return ep . initGlobalVarsAfterBuild ; case asEP_REQUIRE_ENUM_SCOPE : return ep . requireEnumScope ; case asEP_SCRIPT_SCANNER : return ep . scanner ; case asEP_INCLUDE_JIT_INSTRUCTIONS : return ep . includeJitInstructions ; case asEP_STRING_ENCODING : return ep . stringEncoding ; } return 0 ; } } asCScriptEngine :: asCScriptEngine ( ) { if ( threadManager == 0 ) threadManager = asNEW ( asCThreadManager ) ; else threadManager -> AddRef ( ) ; ep . allowUnsafeReferences = false ; ep . optimizeByteCode = true ; ep . copyScriptSections = true ; ep . maximumContextStackSize = 0 ; ep . useCharacterLiterals = false ; ep . allowMultilineStrings = false ; ep . allowImplicitHandleTypes = false ; ep . buildWithoutLineCues = false ; ep . initGlobalVarsAfterBuild = true ; ep . requireEnumScope = false ; ep . scanner = 1 ; ep . includeJitInstructions = false ; ep . stringEncoding = 0 ; gc . engine = this ; refCount . set ( 1 ) ; stringFactory = 0 ; configFailed = false ; isPrepared = false ; isBuilding = false ; lastModule = 0 ; userData = 0 ; initialContextStackSize = 1024 ; typeIdSeqNbr = 0 ; currentGroup = & defaultGroup ; msgCallback = 0 ; jitCompiler = 0 ; scriptFunctions . PushLast ( 0 ) ; int id ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttVoid , false ) ) ; asASSERT ( id == asTYPEID_VOID ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttBool , false ) ) ; asASSERT ( id == asTYPEID_BOOL ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt8 , false ) ) ; asASSERT ( id == asTYPEID_INT8 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt16 , false ) ) ; asASSERT ( id == asTYPEID_INT16 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt , false ) ) ; asASSERT ( id == asTYPEID_INT32 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt64 , false ) ) ; asASSERT ( id == asTYPEID_INT64 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt8 , false ) ) ; asASSERT ( id == asTYPEID_UINT8 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt16 , false ) ) ; asASSERT ( id == asTYPEID_UINT16 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt , false ) ) ; asASSERT ( id == asTYPEID_UINT32 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt64 , false ) ) ; asASSERT ( id == asTYPEID_UINT64 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttFloat , false ) ) ; asASSERT ( id == asTYPEID_FLOAT ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttDouble , false ) ) ; asASSERT ( id == asTYPEID_DOUBLE ) ; defaultArrayObjectType = 0 ; RegisterArrayObject ( this ) ; RegisterScriptObject ( this ) ; RegisterScriptFunction ( this ) ; RegisterObjectTypeGCBehaviours ( this ) ; } asCScriptEngine :: ~ asCScriptEngine ( ) { asASSERT ( refCount . get ( ) == 0 ) ; asUINT n ; for ( n = ( asUINT ) scriptModules . GetLength ( ) ; n -- > 0 ; ) { if ( scriptModules [ n ] ) { asDELETE ( scriptModules [ n ] , asCModule ) ; } } scriptModules . SetLength ( 0 ) ; GarbageCollect ( asGC_FULL_CYCLE ) ; for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] ) { asUINT f ; for ( f = 0 ; f < templateTypes [ n ] -> beh . factories . GetLength ( ) ; f ++ ) { scriptFunctions [ templateTypes [ n ] -> beh . factories [ f ] ] -> Release ( ) ; } templateTypes [ n ] -> beh . factories . Allocate ( 0 , false ) ; for ( f = 1 ; f < templateTypes [ n ] -> beh . operators . GetLength ( ) ; f += 2 ) { if ( scriptFunctions [ templateTypes [ n ] -> beh . operators [ f ] ] -> objectType == templateTypes [ n ] ) { scriptFunctions [ templateTypes [ n ] -> beh . operators [ f ] ] -> Release ( ) ; templateTypes [ n ] -> beh . operators [ f ] = 0 ; } } } } GarbageCollect ( asGC_FULL_CYCLE ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; for ( n = 0 ; n < classTypes . GetLength ( ) ; n ++ ) { if ( classTypes [ n ] ) classTypes [ n ] -> ReleaseAllFunctions ( ) ; if ( classTypes [ n ] -> derivedFrom ) { classTypes [ n ] -> derivedFrom -> Release ( ) ; classTypes [ n ] -> derivedFrom = 0 ; } } GarbageCollect ( asGC_FULL_CYCLE ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; asSMapNode < int , asCDataType * > * cursor = 0 ; while ( mapTypeIdToDataType . MoveFirst ( & cursor ) ) { asDELETE ( mapTypeIdToDataType . GetValue ( cursor ) , asCDataType ) ; mapTypeIdToDataType . Erase ( cursor ) ; } defaultGroup . RemoveConfiguration ( this ) ; while ( configGroups . GetLength ( ) ) { asCConfigGroup * grp = configGroups . PopLast ( ) ; if ( grp ) { asDELETE ( grp , asCConfigGroup ) ; } } for ( n = 0 ; n < registeredGlobalProps . GetLength ( ) ; n ++ ) { if ( registeredGlobalProps [ n ] ) { asDELETE ( registeredGlobalProps [ n ] , asCGlobalProperty ) ; } } registeredGlobalProps . SetLength ( 0 ) ; FreeUnusedGlobalProperties ( ) ; for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] ) { templateTypes [ n ] -> templateSubType = asCDataType :: CreateNullHandle ( ) ; asDELETE ( templateTypes [ n ] , asCObjectType ) ; } } templateTypes . SetLength ( 0 ) ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] ) { objectTypes [ n ] -> templateSubType = asCDataType :: CreateNullHandle ( ) ; asDELETE ( objectTypes [ n ] , asCObjectType ) ; } } objectTypes . SetLength ( 0 ) ; for ( n = 0 ; n < templateSubTypes . GetLength ( ) ; n ++ ) { if ( templateSubTypes [ n ] ) { asDELETE ( templateSubTypes [ n ] , asCObjectType ) ; } } templateSubTypes . SetLength ( 0 ) ; registeredTypeDefs . SetLength ( 0 ) ; registeredEnums . SetLength ( 0 ) ; registeredObjTypes . SetLength ( 0 ) ; for ( n = 0 ; n < registeredGlobalFuncs . GetLength ( ) ; n ++ ) { if ( registeredGlobalFuncs [ n ] ) registeredGlobalFuncs [ n ] -> Release ( ) ; } registeredGlobalFuncs . SetLength ( 0 ) ; scriptTypeBehaviours . ReleaseAllFunctions ( ) ; functionBehaviours . ReleaseAllFunctions ( ) ; objectTypeBehaviours . ReleaseAllFunctions ( ) ; for ( n = 0 ; n < stringConstants . GetLength ( ) ; n ++ ) { asDELETE ( stringConstants [ n ] , asCString ) ; } stringConstants . SetLength ( 0 ) ; for ( n = 0 ; n < scriptSectionNames . GetLength ( ) ; n ++ ) { asDELETE ( scriptSectionNames [ n ] , asCString ) ; } scriptSectionNames . SetLength ( 0 ) ; threadManager -> Release ( ) ; } int asCScriptEngine :: AddRef ( ) { return refCount . atomicInc ( ) ; } int asCScriptEngine :: Release ( ) { int r = refCount . atomicDec ( ) ; if ( r == 0 ) { asDELETE ( this , asCScriptEngine ) ; return 0 ; } return r ; } void * asCScriptEngine :: SetUserData ( void * data ) { void * old = userData ; userData = data ; return old ; } void * asCScriptEngine :: GetUserData ( ) { return userData ; } int asCScriptEngine :: SetMessageCallback ( const asSFuncPtr & callback , void * obj , asDWORD callConv ) { msgCallback = true ; msgCallbackObj = obj ; bool isObj = false ; if ( ( unsigned ) callConv == asCALL_GENERIC ) { msgCallback = false ; return asNOT_SUPPORTED ; } if ( ( unsigned ) callConv >= asCALL_THISCALL ) { isObj = true ; if ( obj == 0 ) { msgCallback = false ; return asINVALID_ARG ; } } int r = DetectCallingConvention ( isObj , callback , callConv , & msgCallbackFunc ) ; if ( r < 0 ) msgCallback = false ; return r ; } int asCScriptEngine :: ClearMessageCallback ( ) { msgCallback = false ; return 0 ; } int asCScriptEngine :: WriteMessage ( const char * section , int row , int col , asEMsgType type , const char * message ) { if ( section == 0 || message == 0 ) return asINVALID_ARG ; if ( ! msgCallback ) return 0 ; asSMessageInfo msg ; msg . section = section ; msg . row = row ; msg . col = col ; msg . type = type ; msg . message = message ; if ( msgCallbackFunc . callConv < ICC_THISCALL ) CallGlobalFunction ( & msg , msgCallbackObj , & msgCallbackFunc , 0 ) ; else CallObjectMethod ( msgCallbackObj , & msg , & msgCallbackFunc , 0 ) ; return 0 ; } int asCScriptEngine :: SetJITCompiler ( asIJITCompiler * compiler ) { jitCompiler = compiler ; return asSUCCESS ; } asIJITCompiler * asCScriptEngine :: GetJITCompiler ( ) { return jitCompiler ; } asETokenClass asCScriptEngine :: ParseToken ( const char * string , size_t stringLength , int * tokenLength ) { if ( stringLength == 0 ) stringLength = strlen ( string ) ; size_t len ; asCTokenizer t ; asETokenClass tc ; t . GetToken ( string , stringLength , & len , & tc ) ; if ( tokenLength ) * tokenLength = ( int ) len ; return tc ; } asIScriptModule * asCScriptEngine :: GetModule ( const char * module , asEGMFlags flag ) { asCModule * mod = GetModule ( module , false ) ; if ( flag == asGM_ALWAYS_CREATE ) { if ( mod != 0 ) { asDELETE ( mod , asCModule ) ; } return GetModule ( module , true ) ; } if ( mod == 0 && flag == asGM_CREATE_IF_NOT_EXISTS ) { return GetModule ( module , true ) ; } return mod ; } int asCScriptEngine :: DiscardModule ( const char * module ) { asCModule * mod = GetModule ( module , false ) ; if ( mod == 0 ) return asNO_MODULE ; asDELETE ( mod , asCModule ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; return 0 ; } void asCScriptEngine :: ClearUnusedTypes ( ) { asCArray < asCObjectType * > types ; types = classTypes ; types . Concatenate ( templateInstanceTypes ) ; asUINT n ; for ( n = 0 ; n < scriptModules . GetLength ( ) && types . GetLength ( ) ; n ++ ) { asCModule * mod = scriptModules [ n ] ; if ( mod ) { asUINT m ; for ( m = 0 ; m < mod -> classTypes . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> classTypes [ m ] ) ; for ( m = 0 ; m < mod -> enumTypes . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> enumTypes [ m ] ) ; for ( m = 0 ; m < mod -> typeDefs . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> typeDefs [ m ] ) ; } } for ( n = 0 ; n < scriptFunctions . GetLength ( ) && types . GetLength ( ) ; n ++ ) { asCScriptFunction * func = scriptFunctions [ n ] ; if ( func ) { if ( func -> name == " factstub " ) continue ; asCObjectType * ot = func -> returnType . GetObjectType ( ) ; if ( ot != 0 && ot != func -> objectType ) if ( func -> name != ot -> name ) RemoveTypeAndRelatedFromList ( types , ot ) ; for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { ot = func -> parameterTypes [ p ] . GetObjectType ( ) ; if ( ot != 0 && ot != func -> objectType ) if ( func -> name != ot -> name ) RemoveTypeAndRelatedFromList ( types , ot ) ; } } } for ( n = 0 ; n < globalProperties . GetLength ( ) && types . GetLength ( ) ; n ++ ) { if ( globalProperties [ n ] && globalProperties [ n ] -> type . GetObjectType ( ) ) RemoveTypeAndRelatedFromList ( types , globalProperties [ n ] -> type . GetObjectType ( ) ) ; } for ( ; ; ) { bool didClearTemplateInstanceType = false ; for ( n = 0 ; n < types . GetLength ( ) ; n ++ ) { int refCount = ( ( types [ n ] -> flags & asOBJ_TEMPLATE ) || ( types [ n ] -> flags & asOBJ_SCRIPT_OBJECT ) ) ? 2 * ( int ) types [ n ] -> beh . factories . GetLength ( ) : 0 ; if ( types [ n ] -> GetRefCount ( ) == refCount ) { if ( types [ n ] -> flags & asOBJ_TEMPLATE ) { didClearTemplateInstanceType = true ; RemoveTemplateInstanceType ( types [ n ] ) ; } else { RemoveFromTypeIdMap ( types [ n ] ) ; asDELETE ( types [ n ] , asCObjectType ) ; int i = classTypes . IndexOf ( types [ n ] ) ; if ( i == ( signed ) classTypes . GetLength ( ) - 1 ) classTypes . PopLast ( ) ; else classTypes [ i ] = classTypes . PopLast ( ) ; } if ( n < types . GetLength ( ) - 1 ) types [ n ] = types . PopLast ( ) ; else types . PopLast ( ) ; n -- ; } } if ( didClearTemplateInstanceType == false ) break ; } } void asCScriptEngine :: RemoveTypeAndRelatedFromList ( asCArray < asCObjectType * > & types , asCObjectType * ot ) { int i = types . IndexOf ( ot ) ; if ( i == - 1 ) return ; if ( i == ( signed ) types . GetLength ( ) - 1 ) types . PopLast ( ) ; else types [ i ] = types . PopLast ( ) ; if ( ot -> templateSubType . GetObjectType ( ) ) { while ( ot -> templateSubType . GetObjectType ( ) ) { ot = ot -> templateSubType . GetObjectType ( ) ; RemoveTypeAndRelatedFromList ( types , ot ) ; } return ; } if ( ot -> properties . GetLength ( ) ) { for ( asUINT n = 0 ; n < ot -> properties . GetLength ( ) ; n ++ ) RemoveTypeAndRelatedFromList ( types , ot -> properties [ n ] -> type . GetObjectType ( ) ) ; } } int asCScriptEngine :: GetFactoryIdByDecl ( const asCObjectType * ot , const char * decl ) { asCModule * mod = 0 ; if ( ot -> flags & asOBJ_SCRIPT_OBJECT && ot -> size > 0 ) mod = scriptFunctions [ ot -> beh . factory ] -> module ; asCBuilder bld ( this , mod ) ; asCScriptFunction func ( this , mod , - 1 ) ; int r = bld . ParseFunctionDeclaration ( 0 , decl , & func , false ) ; if ( r < 0 ) return asINVALID_DECLARATION ; int id = - 1 ; for ( size_t n = 0 ; n < ot -> beh . factories . GetLength ( ) ; n ++ ) { asCScriptFunction * f = scriptFunctions [ ot -> beh . factories [ n ] ] ; if ( f -> IsSignatureEqual ( & func ) ) { id = ot -> beh . factories [ n ] ; break ; } } if ( id == - 1 ) return asNO_FUNCTION ; return id ; } int asCScriptEngine :: GetMethodIdByDecl ( const asCObjectType * ot , const char * decl , asCModule * mod ) { asCBuilder bld ( this , mod ) ; asCScriptFunction func ( this , mod , - 1 ) ; int r = bld . ParseFunctionDeclaration ( 0 , decl , & func , false ) ; if ( r < 0 ) return asINVALID_DECLARATION ; func . objectType = const_cast < asCObjectType * > ( ot ) ; int id = - 1 ; for ( size_t n = 0 ; n < ot -> methods . GetLength ( ) ; ++ n ) { if ( func . IsSignatureEqual ( scriptFunctions [ ot -> methods [ n ] ] ) ) { if ( id == - 1 ) id = ot -> methods [ n ] ; else return asMULTIPLE_FUNCTIONS ; } } if ( id == - 1 ) return asNO_FUNCTION ; return id ; } asCString asCScriptEngine :: GetFunctionDeclaration ( int funcID ) { asCString str ; asCScriptFunction * func = GetScriptFunction ( funcID ) ; if ( func ) str = func -> GetDeclarationStr ( ) ; return str ; } asCScriptFunction * asCScriptEngine :: GetScriptFunction ( int funcId ) { if ( funcId < 0 || funcId >= ( int ) scriptFunctions . GetLength ( ) ) return 0 ; return scriptFunctions [ funcId ] ; } asIScriptContext * asCScriptEngine :: CreateContext ( ) { asIScriptContext * ctx = 0 ; CreateContext ( & ctx , false ) ; return ctx ; } int asCScriptEngine :: CreateContext ( asIScriptContext * * context , bool isInternal ) { * context = asNEW ( asCContext ) ( this , ! isInternal ) ; PrepareEngine ( ) ; return 0 ; } int asCScriptEngine :: RegisterObjectProperty ( const char * obj , const char * declaration , int byteOffset ) { int r ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; r = bld . ParseDataType ( obj , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( currentGroup -> FindType ( dt . GetObjectType ( ) -> name . AddressOf ( ) ) == 0 ) return ConfigError ( asWRONG_CONFIG_GROUP ) ; asCDataType type ; asCString name ; if ( ( r = bld . VerifyProperty ( & dt , declaration , name , type ) ) < 0 ) return ConfigError ( r ) ; if ( dt . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_OBJECT ) ; asCObjectProperty * prop = asNEW ( asCObjectProperty ) ; prop -> name = name ; prop -> type = type ; prop -> byteOffset = byteOffset ; dt . GetObjectType ( ) -> properties . PushLast ( prop ) ; currentGroup -> RefConfigGroup ( FindConfigGroupForObjectType ( type . GetObjectType ( ) ) ) ; return asSUCCESS ; } int asCScriptEngine :: RegisterInterface ( const char * name ) { if ( name == 0 ) return ConfigError ( asINVALID_NAME ) ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) return asALREADY_REGISTERED ; } asCDataType dt ; asCBuilder bld ( this , 0 ) ; bool oldMsgCallback = msgCallback ; msgCallback = false ; int r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; if ( r >= 0 ) return ConfigError ( asERROR ) ; asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , strlen ( name ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( name ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * st = asNEW ( asCObjectType ) ( this ) ; st -> flags = asOBJ_REF | asOBJ_SCRIPT_OBJECT ; st -> size = 0 ; st -> name = name ; st -> beh . factory = 0 ; st -> beh . addref = scriptTypeBehaviours . beh . addref ; scriptFunctions [ st -> beh . addref ] -> AddRef ( ) ; st -> beh . release = scriptTypeBehaviours . beh . release ; scriptFunctions [ st -> beh . release ] -> AddRef ( ) ; st -> beh . copy = 0 ; objectTypes . PushLast ( st ) ; registeredObjTypes . PushLast ( st ) ; currentGroup -> objTypes . PushLast ( st ) ; return asSUCCESS ; } int asCScriptEngine :: RegisterInterfaceMethod ( const char * intf , const char * declaration ) { if ( currentGroup -> FindType ( intf ) == 0 ) return ConfigError ( asWRONG_CONFIG_GROUP ) ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( intf , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_INTERFACE ) ; func -> objectType = dt . GetObjectType ( ) ; r = bld . ParseFunctionDeclaration ( func -> objectType , declaration , func , false ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } r = bld . CheckNameConflictMember ( dt , func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; func -> objectType -> methods . PushLast ( func -> id ) ; func -> ComputeSignatureId ( ) ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } return func -> id ; } int asCScriptEngine :: RegisterObjectType ( const char * name , int byteSize , asDWORD flags ) { int r ; isPrepared = false ; if ( flags & asOBJ_REF ) { if ( flags & ~ ( asOBJ_REF | asOBJ_GC | asOBJ_NOHANDLE | asOBJ_SCOPED | asOBJ_TEMPLATE ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_GC ) && ( flags & ( asOBJ_NOHANDLE | asOBJ_SCOPED ) ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_NOHANDLE ) && ( flags & ( asOBJ_GC | asOBJ_SCOPED ) ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_SCOPED ) && ( flags & ( asOBJ_GC | asOBJ_NOHANDLE ) ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_VALUE ) { if ( flags & ( asOBJ_REF | asOBJ_GC | asOBJ_SCOPED ) ) return ConfigError ( asINVALID_ARG ) ; if ( flags & asOBJ_APP_CLASS ) { if ( flags & ( asOBJ_APP_PRIMITIVE | asOBJ_APP_FLOAT ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_APP_PRIMITIVE ) { if ( flags & ( asOBJ_APP_CLASS | asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT | asOBJ_APP_FLOAT ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_APP_FLOAT ) { if ( flags & ( asOBJ_APP_CLASS | asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT | asOBJ_APP_PRIMITIVE ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & ( asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT ) ) { return ConfigError ( asINVALID_ARG ) ; } } else return ConfigError ( asINVALID_ARG ) ; if ( flags - ( flags & asOBJ_MASK_VALID_FLAGS ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_VALUE ) && byteSize == 0 ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_VALUE_TYPE_MUST_HAVE_SIZE ) ; return ConfigError ( asINVALID_ARG ) ; } if ( name == 0 ) return ConfigError ( asINVALID_NAME ) ; asCString typeName ; asCBuilder bld ( this , 0 ) ; if ( flags & asOBJ_TEMPLATE ) { asCString subtypeName ; r = bld . ParseTemplateDecl ( name , & typeName , & subtypeName ) ; if ( r < 0 ) return r ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = typeName ; type -> size = byteSize ; type -> flags = flags ; objectTypes . PushLast ( type ) ; asCObjectType * subtype = 0 ; for ( n = 0 ; n < templateSubTypes . GetLength ( ) ; n ++ ) { if ( templateSubTypes [ n ] -> name == subtypeName ) { subtype = templateSubTypes [ n ] ; break ; } } if ( subtype == 0 ) { subtype = asNEW ( asCObjectType ) ( this ) ; subtype -> name = subtypeName ; subtype -> size = 0 ; subtype -> flags = asOBJ_TEMPLATE_SUBTYPE ; templateSubTypes . PushLast ( subtype ) ; subtype -> AddRef ( ) ; } type -> templateSubType = asCDataType :: CreateObject ( subtype , false ) ; subtype -> AddRef ( ) ; currentGroup -> objTypes . PushLast ( type ) ; if ( defaultArrayObjectType == 0 ) { defaultArrayObjectType = type ; type -> AddRef ( ) ; } else { registeredObjTypes . PushLast ( type ) ; } } else { typeName = name ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] && templateTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } asCObjectType * mostRecentTemplateInstanceType = 0 ; if ( templateInstanceTypes . GetLength ( ) ) mostRecentTemplateInstanceType = templateInstanceTypes [ templateInstanceTypes . GetLength ( ) - 1 ] ; asCDataType dt ; bool oldMsgCallback = msgCallback ; msgCallback = false ; r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; if ( r < 0 ) { asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , typeName . GetLength ( ) , & tokenLen ) ; if ( token != ttIdentifier || typeName . GetLength ( ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; int r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = typeName ; type -> size = byteSize ; type -> flags = flags ; objectTypes . PushLast ( type ) ; registeredObjTypes . PushLast ( type ) ; currentGroup -> objTypes . PushLast ( type ) ; } else { if ( dt . GetSubType ( ) . IsTemplate ( ) ) return ConfigError ( asLOWER_ARRAY_DIMENSION_NOT_REGISTERED ) ; if ( dt . IsReadOnly ( ) || dt . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; if ( templateInstanceTypes [ templateInstanceTypes . GetLength ( ) - 1 ] == mostRecentTemplateInstanceType || mostRecentTemplateInstanceType == dt . GetObjectType ( ) ) return ConfigError ( asNOT_SUPPORTED ) ; asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = dt . GetObjectType ( ) -> name ; type -> templateSubType = dt . GetSubType ( ) ; if ( type -> templateSubType . GetObjectType ( ) ) type -> templateSubType . GetObjectType ( ) -> AddRef ( ) ; type -> size = byteSize ; type -> flags = flags ; templateTypes . PushLast ( type ) ; currentGroup -> objTypes . PushLast ( type ) ; RemoveTemplateInstanceType ( dt . GetObjectType ( ) ) ; } } return asSUCCESS ; } int asCScriptEngine :: RegisterObjectBehaviour ( const char * datatype , asEBehaviours behaviour , const char * decl , const asSFuncPtr & funcPointer , asDWORD callConv ) { if ( datatype == 0 ) return ConfigError ( asINVALID_ARG ) ; asCBuilder bld ( this , 0 ) ; asCDataType type ; int r = bld . ParseDataType ( datatype , & type ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( type . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_TYPE ) ; if ( type . IsReadOnly ( ) || type . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; return RegisterBehaviourToObjectType ( type . GetObjectType ( ) , behaviour , decl , funcPointer , callConv ) ; } int asCScriptEngine :: RegisterBehaviourToObjectType ( asCObjectType * objectType , asEBehaviours behaviour , const char * decl , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; if ( behaviour == asBEHAVE_FACTORY || behaviour == asBEHAVE_TEMPLATE_CALLBACK ) { # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; } else { # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # else if ( callConv != asCALL_THISCALL && callConv != asCALL_CDECL_OBJLAST && callConv != asCALL_CDECL_OBJFIRST && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif int r = DetectCallingConvention ( true , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; } isPrepared = false ; asSTypeBehaviour * beh = & objectType -> beh ; asCScriptFunction func ( this , 0 , - 1 ) ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseFunctionDeclaration ( objectType , decl , & func , true , & internal . paramAutoHandles , & internal . returnAutoHandle ) ; if ( r < 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . name . Format ( " _ beh _ % d _ " , behaviour ) ; if ( behaviour != asBEHAVE_FACTORY ) func . objectType = objectType ; if ( objectType -> flags & asOBJ_TEMPLATE ) { if ( func . returnType . GetObjectType ( ) == objectType -> templateSubType . GetObjectType ( ) ) { if ( func . returnType . IsObjectHandle ( ) ) objectType -> acceptValueSubType = false ; else if ( ! func . returnType . IsReference ( ) ) objectType -> acceptRefSubType = false ; } for ( asUINT n = 0 ; n < func . parameterTypes . GetLength ( ) ; n ++ ) { if ( func . parameterTypes [ n ] . GetObjectType ( ) == objectType -> templateSubType . GetObjectType ( ) ) { if ( func . parameterTypes [ n ] . IsObjectHandle ( ) || ( func . parameterTypes [ n ] . IsReference ( ) && func . inOutFlags [ n ] == asTM_INOUTREF ) ) objectType -> acceptValueSubType = false ; else if ( ! func . parameterTypes [ n ] . IsReference ( ) ) objectType -> acceptRefSubType = false ; } } } if ( behaviour == asBEHAVE_CONSTRUCT ) { if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( objectType -> flags & asOBJ_SCRIPT_OBJECT ) { asASSERT ( func . parameterTypes . GetLength ( ) == 1 ) ; beh -> construct = AddBehaviourFunction ( func , internal ) ; beh -> factory = beh -> construct ; scriptFunctions [ beh -> factory ] -> AddRef ( ) ; beh -> constructors . PushLast ( beh -> construct ) ; beh -> factories . PushLast ( beh -> factory ) ; func . id = beh -> construct ; } else { if ( ! ( func . objectType -> flags & asOBJ_VALUE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( func . parameterTypes . GetLength ( ) == 0 ) { func . id = beh -> construct = AddBehaviourFunction ( func , internal ) ; beh -> constructors . PushLast ( beh -> construct ) ; } else { func . id = AddBehaviourFunction ( func , internal ) ; beh -> constructors . PushLast ( func . id ) ; } } } else if ( behaviour == asBEHAVE_DESTRUCT ) { if ( ! ( func . objectType -> flags & asOBJ_VALUE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> destruct ) return ConfigError ( asALREADY_REGISTERED ) ; if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> destruct = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_FACTORY ) { if ( ! ( objectType -> flags & asOBJ_REF ) || ( objectType -> flags & asOBJ_NOHANDLE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( func . returnType != asCDataType :: CreateObjectHandle ( objectType , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ( objectType -> flags & asOBJ_TEMPLATE ) && ( func . parameterTypes . GetLength ( ) == 0 || ! func . parameterTypes [ 0 ] . IsReference ( ) ) ) { return ConfigError ( asINVALID_DECLARATION ) ; } if ( ( func . parameterTypes . GetLength ( ) == 0 ) || ( func . parameterTypes . GetLength ( ) == 1 && ( objectType -> flags & asOBJ_TEMPLATE ) ) ) { func . id = beh -> factory = AddBehaviourFunction ( func , internal ) ; beh -> factories . PushLast ( beh -> factory ) ; } else { func . id = AddBehaviourFunction ( func , internal ) ; beh -> factories . PushLast ( func . id ) ; } } else if ( behaviour == asBEHAVE_ADDREF ) { if ( ! ( func . objectType -> flags & asOBJ_REF ) || ( func . objectType -> flags & asOBJ_NOHANDLE ) || ( func . objectType -> flags & asOBJ_SCOPED ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> addref ) return ConfigError ( asALREADY_REGISTERED ) ; if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> addref = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_RELEASE ) { if ( ! ( func . objectType -> flags & asOBJ_REF ) || ( func . objectType -> flags & asOBJ_NOHANDLE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> release ) return ConfigError ( asALREADY_REGISTERED ) ; if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> release = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_TEMPLATE_CALLBACK ) { if ( ! ( func . objectType -> flags & asOBJ_TEMPLATE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> templateCallback ) return ConfigError ( asALREADY_REGISTERED ) ; if ( func . returnType != asCDataType :: CreatePrimitive ( ttBool , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> templateCallback = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_INDEX ) { if ( VerifyVarTypeNotInFunction ( & func ) < 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . returnType . GetTokenType ( ) == ttVoid ) return ConfigError ( asINVALID_DECLARATION ) ; beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else if ( behaviour >= asBEHAVE_FIRST_GC && behaviour <= asBEHAVE_LAST_GC ) { if ( ! ( func . objectType -> flags & asOBJ_GC ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( ( behaviour == asBEHAVE_GETREFCOUNT || behaviour == asBEHAVE_SETGCFLAG || behaviour == asBEHAVE_GETGCFLAG ) && func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ( behaviour == asBEHAVE_ENUMREFS || behaviour == asBEHAVE_RELEASEREFS ) && func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( behaviour == asBEHAVE_GETREFCOUNT && func . returnType != asCDataType :: CreatePrimitive ( ttInt , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( behaviour == asBEHAVE_GETGCFLAG && func . returnType != asCDataType :: CreatePrimitive ( ttBool , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ( behaviour == asBEHAVE_SETGCFLAG || behaviour == asBEHAVE_ENUMREFS || behaviour == asBEHAVE_RELEASEREFS ) && func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( behaviour == asBEHAVE_GETREFCOUNT ) func . id = beh -> gcGetRefCount = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_SETGCFLAG ) func . id = beh -> gcSetFlag = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_GETGCFLAG ) func . id = beh -> gcGetFlag = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_ENUMREFS ) func . id = beh -> gcEnumReferences = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_RELEASEREFS ) func . id = beh -> gcReleaseAllReferences = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_IMPLICIT_VALUE_CAST || behaviour == asBEHAVE_VALUE_CAST ) { if ( func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . returnType . IsEqualExceptRefAndConst ( asCDataType :: CreatePrimitive ( ttBool , false ) ) ) return ConfigError ( asNOT_SUPPORTED ) ; if ( func . returnType . IsEqualExceptRefAndConst ( asCDataType :: CreatePrimitive ( ttVoid , false ) ) ) return ConfigError ( asINVALID_DECLARATION ) ; beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else if ( behaviour == asBEHAVE_REF_CAST || behaviour == asBEHAVE_IMPLICIT_REF_CAST ) { if ( func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ! func . returnType . IsObjectHandle ( ) ) return ConfigError ( asINVALID_DECLARATION ) ; beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else { asASSERT ( false ) ; return ConfigError ( asINVALID_ARG ) ; } return func . id ; } int asCScriptEngine :: VerifyVarTypeNotInFunction ( asCScriptFunction * func ) { if ( func -> returnType . GetTokenType ( ) == ttQuestion ) return asINVALID_DECLARATION ; for ( unsigned int n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) if ( func -> parameterTypes [ n ] . GetTokenType ( ) == ttQuestion ) return asINVALID_DECLARATION ; return 0 ; } int asCScriptEngine :: AddBehaviourFunction ( asCScriptFunction & func , asSSystemFunctionInterface & internal ) { asUINT n ; int id = GetNextScriptFunctionId ( ) ; asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ; newInterface -> func = internal . func ; newInterface -> baseOffset = internal . baseOffset ; newInterface -> callConv = internal . callConv ; newInterface -> scriptReturnSize = internal . scriptReturnSize ; newInterface -> hostReturnInMemory = internal . hostReturnInMemory ; newInterface -> hostReturnFloat = internal . hostReturnFloat ; newInterface -> hostReturnSize = internal . hostReturnSize ; newInterface -> paramSize = internal . paramSize ; newInterface -> takesObjByVal = internal . takesObjByVal ; newInterface -> paramAutoHandles = internal . paramAutoHandles ; newInterface -> returnAutoHandle = internal . returnAutoHandle ; newInterface -> hasAutoHandles = internal . hasAutoHandles ; asCScriptFunction * f = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; asASSERT ( func . name != " " && func . name != " f " ) ; f -> name = func . name ; f -> sysFuncIntf = newInterface ; f -> returnType = func . returnType ; f -> objectType = func . objectType ; f -> id = id ; f -> isReadOnly = func . isReadOnly ; for ( n = 0 ; n < func . parameterTypes . GetLength ( ) ; n ++ ) { f -> parameterTypes . PushLast ( func . parameterTypes [ n ] ) ; f -> inOutFlags . PushLast ( func . inOutFlags [ n ] ) ; } SetScriptFunction ( f ) ; if ( f -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( f -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( n = 0 ; n < f -> parameterTypes . GetLength ( ) ; n ++ ) { if ( f -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( f -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } return id ; } int asCScriptEngine :: RegisterGlobalProperty ( const char * declaration , void * pointer ) { asCDataType type ; asCString name ; int r ; asCBuilder bld ( this , 0 ) ; if ( ( r = bld . VerifyProperty ( 0 , declaration , name , type ) ) < 0 ) return ConfigError ( r ) ; if ( type . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; asCGlobalProperty * prop = AllocateGlobalProperty ( ) ; prop -> name = name ; prop -> type = type ; prop -> SetRegisteredAddress ( pointer ) ; registeredGlobalProps . PushLast ( prop ) ; currentGroup -> globalProps . PushLast ( prop ) ; if ( type . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( type . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } return asSUCCESS ; } asCGlobalProperty * asCScriptEngine :: AllocateGlobalProperty ( ) { asCGlobalProperty * prop = asNEW ( asCGlobalProperty ) ; if ( freeGlobalPropertyIds . GetLength ( ) ) { prop -> id = freeGlobalPropertyIds . PopLast ( ) ; globalProperties [ prop -> id ] = prop ; return prop ; } prop -> id = ( asUINT ) globalProperties . GetLength ( ) ; globalProperties . PushLast ( prop ) ; return prop ; } void asCScriptEngine :: FreeUnusedGlobalProperties ( ) { for ( asUINT n = 0 ; n < globalProperties . GetLength ( ) ; n ++ ) { if ( globalProperties [ n ] && globalProperties [ n ] -> refCount . get ( ) == 0 ) { freeGlobalPropertyIds . PushLast ( n ) ; asDELETE ( globalProperties [ n ] , asCGlobalProperty ) ; globalProperties [ n ] = 0 ; } } } int asCScriptEngine :: GetGlobalPropertyCount ( ) { return ( int ) registeredGlobalProps . GetLength ( ) ; } int asCScriptEngine :: GetGlobalPropertyByIndex ( asUINT index , const char * * name , int * typeId , bool * isConst , const char * * configGroup , void * * pointer ) { if ( index >= registeredGlobalProps . GetLength ( ) ) return asINVALID_ARG ; if ( name ) * name = registeredGlobalProps [ index ] -> name . AddressOf ( ) ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForGlobalVar ( index ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } if ( typeId ) * typeId = GetTypeIdFromDataType ( registeredGlobalProps [ index ] -> type ) ; if ( isConst ) * isConst = registeredGlobalProps [ index ] -> type . IsReadOnly ( ) ; if ( pointer ) * pointer = registeredGlobalProps [ index ] -> realAddress ; return asSUCCESS ; } int asCScriptEngine :: RegisterObjectMethod ( const char * obj , const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { if ( obj == 0 ) return ConfigError ( asINVALID_ARG ) ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( obj , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( dt . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_ARG ) ; return RegisterMethodToObjectType ( dt . GetObjectType ( ) , declaration , funcPointer , callConv ) ; } int asCScriptEngine :: RegisterMethodToObjectType ( asCObjectType * objectType , const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( true , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # else if ( callConv != asCALL_THISCALL && callConv != asCALL_CDECL_OBJLAST && callConv != asCALL_CDECL_OBJFIRST && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif isPrepared = false ; asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> sysFuncIntf = newInterface ; func -> objectType = objectType ; asCBuilder bld ( this , 0 ) ; r = bld . ParseFunctionDeclaration ( func -> objectType , declaration , func , true , & newInterface -> paramAutoHandles , & newInterface -> returnAutoHandle ) ; if ( r < 0 ) { func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } asCDataType x = asCDataType :: CreateObject ( objectType , false ) ; r = bld . CheckNameConflictMember ( x , func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; func -> objectType -> methods . PushLast ( func -> id ) ; SetScriptFunction ( func ) ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } if ( func -> objectType -> flags & asOBJ_TEMPLATE ) { if ( func -> returnType . GetObjectType ( ) == func -> objectType -> templateSubType . GetObjectType ( ) ) { if ( func -> returnType . IsObjectHandle ( ) ) func -> objectType -> acceptValueSubType = false ; else if ( ! func -> returnType . IsReference ( ) ) func -> objectType -> acceptRefSubType = false ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) == func -> objectType -> templateSubType . GetObjectType ( ) ) { if ( func -> parameterTypes [ n ] . IsObjectHandle ( ) || ( func -> parameterTypes [ n ] . IsReference ( ) && func -> inOutFlags [ n ] == asTM_INOUTREF ) ) func -> objectType -> acceptValueSubType = false ; else if ( ! func -> parameterTypes [ n ] . IsReference ( ) ) func -> objectType -> acceptRefSubType = false ; } } } if ( func -> name == " opAssign " && func -> parameterTypes . GetLength ( ) == 1 && func -> isReadOnly == false && ( objectType -> flags & asOBJ_SCRIPT_OBJECT || func -> parameterTypes [ 0 ] . IsEqualExceptRefAndConst ( asCDataType :: CreateObject ( func -> objectType , false ) ) ) ) { func -> objectType -> beh . copy = func -> id ; func -> AddRef ( ) ; } return func -> id ; } int asCScriptEngine :: RegisterGlobalFunction ( const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # else if ( callConv != asCALL_CDECL && callConv != asCALL_STDCALL && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif isPrepared = false ; asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> sysFuncIntf = newInterface ; asCBuilder bld ( this , 0 ) ; r = bld . ParseFunctionDeclaration ( 0 , declaration , func , true , & newInterface -> paramAutoHandles , & newInterface -> returnAutoHandle ) ; if ( r < 0 ) { func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } r = bld . CheckNameConflict ( func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; currentGroup -> scriptFunctions . PushLast ( func ) ; registeredGlobalFuncs . PushLast ( func ) ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } return func -> id ; } int asCScriptEngine :: GetGlobalFunctionCount ( ) { return ( int ) registeredGlobalFuncs . GetLength ( ) ; } int asCScriptEngine :: GetGlobalFunctionIdByIndex ( asUINT index ) { if ( index >= registeredGlobalFuncs . GetLength ( ) ) return asINVALID_ARG ; return registeredGlobalFuncs [ index ] -> id ; } asCObjectType * asCScriptEngine :: GetObjectType ( const char * type ) { for ( asUINT n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) if ( objectTypes [ n ] && objectTypes [ n ] -> name == type ) return objectTypes [ n ] ; return 0 ; } void asCScriptEngine :: PrepareEngine ( ) { if ( isPrepared ) return ; if ( configFailed ) return ; asUINT n ; for ( n = 0 ; n < scriptFunctions . GetLength ( ) ; n ++ ) { if ( scriptFunctions [ n ] && scriptFunctions [ n ] -> funcType == asFUNC_SYSTEM ) { if ( scriptFunctions [ n ] -> sysFuncIntf -> callConv == ICC_GENERIC_FUNC || scriptFunctions [ n ] -> sysFuncIntf -> callConv == ICC_GENERIC_METHOD ) PrepareSystemFunctionGeneric ( scriptFunctions [ n ] , scriptFunctions [ n ] -> sysFuncIntf , this ) ; else PrepareSystemFunction ( scriptFunctions [ n ] , scriptFunctions [ n ] -> sysFuncIntf , this ) ; } } for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && ! ( objectTypes [ n ] -> flags & asOBJ_SCRIPT_OBJECT ) ) { bool missingBehaviour = false ; const char * infoMsg = 0 ; if ( objectTypes [ n ] -> flags & asOBJ_GC ) { if ( objectTypes [ n ] -> beh . addref == 0 || objectTypes [ n ] -> beh . release == 0 || objectTypes [ n ] -> beh . gcGetRefCount == 0 || objectTypes [ n ] -> beh . gcSetFlag == 0 || objectTypes [ n ] -> beh . gcGetFlag == 0 || objectTypes [ n ] -> beh . gcEnumReferences == 0 || objectTypes [ n ] -> beh . gcReleaseAllReferences == 0 ) { infoMsg = TXT_GC_REQUIRE_ADD_REL_GC_BEHAVIOUR ; missingBehaviour = true ; } } else if ( objectTypes [ n ] -> flags & asOBJ_SCOPED ) { if ( objectTypes [ n ] -> beh . release == 0 ) { infoMsg = TXT_SCOPE_REQUIRE_REL_BEHAVIOUR ; missingBehaviour = true ; } } else if ( ( objectTypes [ n ] -> flags & asOBJ_REF ) && ! ( objectTypes [ n ] -> flags & asOBJ_NOHANDLE ) ) { if ( objectTypes [ n ] -> beh . addref == 0 || objectTypes [ n ] -> beh . release == 0 ) { infoMsg = TXT_REF_REQUIRE_ADD_REL_BEHAVIOUR ; missingBehaviour = true ; } } else if ( ( objectTypes [ n ] -> flags & asOBJ_VALUE ) && ! ( objectTypes [ n ] -> flags & asOBJ_POD ) ) { if ( objectTypes [ n ] -> beh . construct == 0 || objectTypes [ n ] -> beh . destruct == 0 ) { infoMsg = TXT_NON_POD_REQUIRE_CONSTR_DESTR_BEHAVIOUR ; missingBehaviour = true ; } } if ( missingBehaviour ) { asCString str ; str . Format ( TXT_TYPE_s_IS_MISSING_BEHAVIOURS , objectTypes [ n ] -> name . AddressOf ( ) ) ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , str . AddressOf ( ) ) ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_INFORMATION , infoMsg ) ; ConfigError ( asINVALID_CONFIGURATION ) ; } } } isPrepared = true ; } int asCScriptEngine :: ConfigError ( int err ) { configFailed = true ; return err ; } int asCScriptEngine :: RegisterStringFactory ( const char * datatype , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # else if ( callConv != asCALL_CDECL && callConv != asCALL_STDCALL && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> name = " _ string _ factory _ " ; func -> sysFuncIntf = newInterface ; asCBuilder bld ( this , 0 ) ; asCDataType dt ; r = bld . ParseDataType ( datatype , & dt ) ; if ( r < 0 ) { func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_TYPE ) ; } func -> returnType = dt ; func -> parameterTypes . PushLast ( asCDataType :: CreatePrimitive ( ttInt , true ) ) ; asCDataType parm1 = asCDataType :: CreatePrimitive ( ttUInt8 , true ) ; parm1 . MakeReference ( true ) ; func -> parameterTypes . PushLast ( parm1 ) ; func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; stringFactory = func ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; if ( group == 0 ) group = & defaultGroup ; group -> scriptFunctions . PushLast ( func ) ; } return func -> id ; } int asCScriptEngine :: GetStringFactoryReturnTypeId ( ) { if ( stringFactory == 0 ) return asNO_FUNCTION ; return GetTypeIdFromDataType ( stringFactory -> returnType ) ; } asCModule * asCScriptEngine :: GetModule ( const char * _name , bool create ) { const char * name = " " ; if ( _name != 0 ) name = _name ; if ( lastModule && lastModule -> name == name ) return lastModule ; for ( asUINT n = 0 ; n < scriptModules . GetLength ( ) ; ++ n ) if ( scriptModules [ n ] && scriptModules [ n ] -> name == name ) { lastModule = scriptModules [ n ] ; return lastModule ; } if ( create ) { asCModule * module = asNEW ( asCModule ) ( name , this ) ; scriptModules . PushLast ( module ) ; lastModule = module ; return lastModule ; } return 0 ; } asCModule * asCScriptEngine :: GetModuleFromFuncId ( int id ) { if ( id < 0 ) return 0 ; if ( id >= ( int ) scriptFunctions . GetLength ( ) ) return 0 ; asCScriptFunction * func = scriptFunctions [ id ] ; if ( func == 0 ) return 0 ; return func -> module ; } int asCScriptEngine :: RequestBuild ( ) { ENTERCRITICALSECTION ( engineCritical ) ; if ( isBuilding ) { LEAVECRITICALSECTION ( engineCritical ) ; return asBUILD_IN_PROGRESS ; } isBuilding = true ; LEAVECRITICALSECTION ( engineCritical ) ; return 0 ; } void asCScriptEngine :: BuildCompleted ( ) { memoryMgr . FreeUnusedMemory ( ) ; isBuilding = false ; } # ifdef AS_DEPRECATED int asCScriptEngine :: ExecuteString ( const char * module , const char * script , asIScriptContext * * ctx , asDWORD flags ) { int r ; if ( ( r = RequestBuild ( ) ) < 0 ) return r ; PrepareEngine ( ) ; if ( configFailed ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) * ctx = 0 ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_INVALID_CONFIGURATION ) ; isBuilding = false ; return asINVALID_CONFIGURATION ; } asIScriptContext * exec = 0 ; if ( ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { int r = CreateContext ( & exec , false ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) * ctx = 0 ; isBuilding = false ; return r ; } if ( ctx ) { * ctx = exec ; exec -> AddRef ( ) ; } } else { if ( * ctx == 0 ) { isBuilding = false ; return asINVALID_ARG ; } exec = * ctx ; exec -> AddRef ( ) ; } exec -> Unprepare ( ) ; asCModule * mod = GetModule ( module , true ) ; asCBuilder builder ( this , mod ) ; asCString str = script ; str = " void ▁ ExecuteString ( ) { \n " + str + " \n ; } " ; r = builder . BuildString ( str . AddressOf ( ) , ( asCContext * ) exec ) ; BuildCompleted ( ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { ( * ctx ) -> Release ( ) ; * ctx = 0 ; } exec -> Release ( ) ; return asERROR ; } r = ( ( asCContext * ) exec ) -> Prepare ( ( ( asCContext * ) exec ) -> stringFunction -> id ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { ( * ctx ) -> Release ( ) ; * ctx = 0 ; } exec -> Release ( ) ; return r ; } if ( flags & asEXECSTRING_ONLY_PREPARE ) r = asEXECUTION_PREPARED ; else r = exec -> Execute ( ) ; exec -> Release ( ) ; return r ; } # endif void asCScriptEngine :: RemoveTemplateInstanceType ( asCObjectType * t ) { int n ; for ( n = 0 ; n < ( int ) t -> beh . factories . GetLength ( ) ; n ++ ) { scriptFunctions [ t -> beh . factories [ n ] ] -> ReleaseAllHandles ( this ) ; scriptFunctions [ t -> beh . factories [ n ] ] -> Release ( ) ; } t -> beh . factories . SetLength ( 0 ) ; for ( n = 1 ; n < ( int ) t -> beh . operators . GetLength ( ) ; n += 2 ) { if ( t -> beh . operators [ n ] && scriptFunctions [ t -> beh . operators [ n ] ] -> objectType == t ) { scriptFunctions [ t -> beh . operators [ n ] ] -> Release ( ) ; } } t -> beh . operators . SetLength ( 0 ) ; for ( n = ( int ) templateTypes . GetLength ( ) - 1 ; n >= 0 ; n -- ) { if ( templateTypes [ n ] == t ) { if ( n == ( signed ) templateTypes . GetLength ( ) - 1 ) templateTypes . PopLast ( ) ; else templateTypes [ n ] = templateTypes . PopLast ( ) ; } } for ( n = ( int ) templateInstanceTypes . GetLength ( ) - 1 ; n >= 0 ; n -- ) { if ( templateInstanceTypes [ n ] == t ) { if ( n == ( signed ) templateInstanceTypes . GetLength ( ) - 1 ) templateInstanceTypes . PopLast ( ) ; else templateInstanceTypes [ n ] = templateInstanceTypes . PopLast ( ) ; } } asDELETE ( t , asCObjectType ) ; } asCObjectType * asCScriptEngine :: GetTemplateInstanceType ( asCObjectType * templateType , asCDataType & subType ) { asUINT n ; for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] && templateTypes [ n ] -> name == templateType -> name && templateTypes [ n ] -> templateSubType == subType ) return templateTypes [ n ] ; } if ( ! templateType -> acceptValueSubType && ( subType . IsPrimitive ( ) || ( subType . GetObjectType ( ) -> flags & asOBJ_VALUE ) ) ) return 0 ; if ( ! templateType -> acceptRefSubType && ( subType . IsObject ( ) && ( subType . GetObjectType ( ) -> flags & asOBJ_REF ) ) ) return 0 ; asCObjectType * ot = asNEW ( asCObjectType ) ( this ) ; ot -> templateSubType = subType ; ot -> flags = templateType -> flags ; ot -> size = templateType -> size ; ot -> name = templateType -> name ; if ( templateType -> beh . templateCallback ) { asCScriptFunction * callback = scriptFunctions [ templateType -> beh . templateCallback ] ; if ( ! CallGlobalFunctionRetBool ( ot , 0 , callback -> sysFuncIntf , callback ) ) { ot -> templateSubType = asCDataType ( ) ; asDELETE ( ot , asCObjectType ) ; return 0 ; } } ot -> methods = templateType -> methods ; for ( n = 0 ; n < ot -> methods . GetLength ( ) ; n ++ ) scriptFunctions [ ot -> methods [ n ] ] -> AddRef ( ) ; ot -> beh . construct = templateType -> beh . factory ; ot -> beh . constructors = templateType -> beh . factories ; for ( n = 0 ; n < ot -> beh . constructors . GetLength ( ) ; n ++ ) scriptFunctions [ ot -> beh . constructors [ n ] ] -> AddRef ( ) ; for ( n = 0 ; n < templateType -> beh . factories . GetLength ( ) ; n ++ ) { int factoryId = templateType -> beh . factories [ n ] ; asCScriptFunction * factory = scriptFunctions [ factoryId ] ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SCRIPT ) ; func -> name = " factstub " ; func -> id = GetNextScriptFunctionId ( ) ; func -> returnType = asCDataType :: CreateObjectHandle ( ot , false ) ; for ( asUINT p = 1 ; p < factory -> parameterTypes . GetLength ( ) ; p ++ ) { func -> parameterTypes . PushLast ( factory -> parameterTypes [ p ] ) ; func -> inOutFlags . PushLast ( factory -> inOutFlags [ p ] ) ; } SetScriptFunction ( func ) ; asCBuilder builder ( this , 0 ) ; asCCompiler compiler ( this ) ; compiler . CompileTemplateFactoryStub ( & builder , factoryId , ot , func ) ; ot -> beh . factories . PushLast ( func -> id ) ; } if ( ot -> beh . factories . GetLength ( ) ) ot -> beh . factory = ot -> beh . factories [ 0 ] ; else { asASSERT ( false ) ; ot -> beh . factory = templateType -> beh . factory ; } ot -> beh . addref = templateType -> beh . addref ; if ( scriptFunctions [ ot -> beh . addref ] ) scriptFunctions [ ot -> beh . addref ] -> AddRef ( ) ; ot -> beh . release = templateType -> beh . release ; if ( scriptFunctions [ ot -> beh . release ] ) scriptFunctions [ ot -> beh . release ] -> AddRef ( ) ; ot -> beh . copy = templateType -> beh . copy ; if ( scriptFunctions [ ot -> beh . copy ] ) scriptFunctions [ ot -> beh . copy ] -> AddRef ( ) ; ot -> beh . operators = templateType -> beh . operators ; for ( n = 1 ; n < ot -> beh . operators . GetLength ( ) ; n += 2 ) { scriptFunctions [ ot -> beh . operators [ n ] ] -> AddRef ( ) ; } ot -> beh . gcGetRefCount = templateType -> beh . gcGetRefCount ; if ( scriptFunctions [ ot -> beh . gcGetRefCount ] ) scriptFunctions [ ot -> beh . gcGetRefCount ] -> AddRef ( ) ; ot -> beh . gcSetFlag = templateType -> beh . gcSetFlag ; if ( scriptFunctions [ ot -> beh . gcSetFlag ] ) scriptFunctions [ ot -> beh . gcSetFlag ] -> AddRef ( ) ; ot -> beh . gcGetFlag = templateType -> beh . gcGetFlag ; if ( scriptFunctions [ ot -> beh . gcGetFlag ] ) scriptFunctions [ ot -> beh . gcGetFlag ] -> AddRef ( ) ; ot -> beh . gcEnumReferences = templateType -> beh . gcEnumReferences ; if ( scriptFunctions [ ot -> beh . gcEnumReferences ] ) scriptFunctions [ ot -> beh . gcEnumReferences ] -> AddRef ( ) ; ot -> beh . gcReleaseAllReferences = templateType -> beh . gcReleaseAllReferences ; if ( scriptFunctions [ ot -> beh . gcReleaseAllReferences ] ) scriptFunctions [ ot -> beh . gcReleaseAllReferences ] -> AddRef ( ) ; for ( n = 1 ; n < ot -> beh . operators . GetLength ( ) ; n += 2 ) { int funcId = ot -> beh . operators [ n ] ; asCScriptFunction * func = scriptFunctions [ funcId ] ; if ( GenerateNewTemplateFunction ( templateType , ot , subType , func , & func ) ) { scriptFunctions [ ot -> beh . operators [ n ] ] -> Release ( ) ; ot -> beh . operators [ n ] = func -> id ; } } for ( n = 0 ; n < ot -> methods . GetLength ( ) ; n ++ ) { int funcId = ot -> methods [ n ] ; asCScriptFunction * func = scriptFunctions [ funcId ] ; if ( GenerateNewTemplateFunction ( templateType , ot , subType , func , & func ) ) { scriptFunctions [ ot -> methods [ n ] ] -> Release ( ) ; ot -> methods [ n ] = func -> id ; } } if ( ot -> templateSubType . GetObjectType ( ) ) ot -> templateSubType . GetObjectType ( ) -> AddRef ( ) ; if ( ot -> templateSubType . GetObjectType ( ) && ( ot -> templateSubType . GetObjectType ( ) -> flags & asOBJ_GC ) ) ot -> flags |= asOBJ_GC ; else if ( ot -> name == defaultArrayObjectType -> name ) ot -> flags &= ~ asOBJ_GC ; templateTypes . PushLast ( ot ) ; templateInstanceTypes . PushLast ( ot ) ; return ot ; } bool asCScriptEngine :: GenerateNewTemplateFunction ( asCObjectType * templateType , asCObjectType * ot , asCDataType & subType , asCScriptFunction * func , asCScriptFunction * * newFunc ) { bool needNewFunc = false ; if ( func -> returnType . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) || func -> returnType . GetObjectType ( ) == templateType ) needNewFunc = true ; else { for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) || func -> parameterTypes [ p ] . GetObjectType ( ) == templateType ) { needNewFunc = true ; break ; } } } if ( needNewFunc ) { asCScriptFunction * func2 = asNEW ( asCScriptFunction ) ( this , 0 , func -> funcType ) ; func2 -> name = func -> name ; func2 -> id = GetNextScriptFunctionId ( ) ; if ( func -> returnType . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) ) { func2 -> returnType = subType ; if ( func -> returnType . IsObjectHandle ( ) ) func2 -> returnType . MakeHandle ( true , true ) ; func2 -> returnType . MakeReference ( func -> returnType . IsReference ( ) ) ; func2 -> returnType . MakeReadOnly ( func -> returnType . IsReadOnly ( ) ) ; } else if ( func -> returnType . GetObjectType ( ) == templateType ) { if ( func2 -> returnType . IsObjectHandle ( ) ) func2 -> returnType = asCDataType :: CreateObjectHandle ( ot , false ) ; else func2 -> returnType = asCDataType :: CreateObject ( ot , false ) ; func2 -> returnType . MakeReference ( func -> returnType . IsReference ( ) ) ; func2 -> returnType . MakeReadOnly ( func -> returnType . IsReadOnly ( ) ) ; } else func2 -> returnType = func -> returnType ; func2 -> parameterTypes . SetLength ( func -> parameterTypes . GetLength ( ) ) ; for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) ) { func2 -> parameterTypes [ p ] = subType ; if ( func -> parameterTypes [ p ] . IsObjectHandle ( ) ) func2 -> parameterTypes [ p ] . MakeHandle ( true ) ; func2 -> parameterTypes [ p ] . MakeReference ( func -> parameterTypes [ p ] . IsReference ( ) ) ; func2 -> parameterTypes [ p ] . MakeReadOnly ( func -> parameterTypes [ p ] . IsReference ( ) ) ; } else if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType ) { if ( func2 -> parameterTypes [ p ] . IsObjectHandle ( ) ) func2 -> parameterTypes [ p ] = asCDataType :: CreateObjectHandle ( ot , false ) ; else func2 -> parameterTypes [ p ] = asCDataType :: CreateObject ( ot , false ) ; func2 -> parameterTypes [ p ] . MakeReference ( func -> parameterTypes [ p ] . IsReference ( ) ) ; func2 -> parameterTypes [ p ] . MakeReadOnly ( func -> parameterTypes [ p ] . IsReadOnly ( ) ) ; } else func2 -> parameterTypes [ p ] = func -> parameterTypes [ p ] ; } func2 -> inOutFlags = func -> inOutFlags ; func2 -> isReadOnly = func -> isReadOnly ; func2 -> objectType = ot ; func2 -> stackNeeded = func -> stackNeeded ; func2 -> sysFuncIntf = asNEW ( asSSystemFunctionInterface ) ( * func -> sysFuncIntf ) ; SetScriptFunction ( func2 ) ; * newFunc = func2 ; } return needNewFunc ; } void asCScriptEngine :: CallObjectMethod ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; CallObjectMethod ( obj , s -> sysFuncIntf , s ) ; } void asCScriptEngine :: CallObjectMethod ( void * obj , asSSystemFunctionInterface * i , asCScriptFunction * s ) { # ifdef __GNUC__ if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asPWORD baseOffset ; } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = asPWORD ( i -> baseOffset ) ; void ( asCSimpleDummy :: * f ) ( ) = p . mthd ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else { void ( * f ) ( void * ) = ( void ( * ) ( void * ) ) ( i -> func ) ; f ( obj ) ; } # else # ifndef AS_NO_CLASS_METHODS if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; void ( asCSimpleDummy :: * f ) ( ) = p . mthd ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else # endif if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else { void ( * f ) ( void * ) = ( void ( * ) ( void * ) ) ( i -> func ) ; f ( obj ) ; } # endif } bool asCScriptEngine :: CallObjectMethodRetBool ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; asSSystemFunctionInterface * i = s -> sysFuncIntf ; # ifdef __GNUC__ if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asDWORD baseOffset ; } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = i -> baseOffset ; bool ( asCSimpleDummy :: * f ) ( ) = ( bool ( asCSimpleDummy :: * ) ( ) ) ( p . mthd ) ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else { bool ( * f ) ( void * ) = ( bool ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } # else # ifndef AS_NO_CLASS_METHODS if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; bool ( asCSimpleDummy :: * f ) ( ) = ( bool ( asCSimpleDummy :: * ) ( ) ) p . mthd ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else # endif if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } else { bool ( * f ) ( void * ) = ( bool ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } # endif } int asCScriptEngine :: CallObjectMethodRetInt ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; asSSystemFunctionInterface * i = s -> sysFuncIntf ; # ifdef __GNUC__ if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( int * ) gen . GetReturnPointer ( ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asDWORD baseOffset ; } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = i -> baseOffset ; int ( asCSimpleDummy :: * f ) ( ) = ( int ( asCSimpleDummy :: * ) ( ) ) ( p . mthd ) ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else { int ( * f ) ( void * ) = ( int ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } # else # ifndef AS_NO_CLASS_METHODS if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; int ( asCSimpleDummy :: * f ) ( ) = ( int ( asCSimpleDummy :: * ) ( ) ) p . mthd ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else # endif if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( int * ) gen . GetReturnPointer ( ) ; } else { int ( * f ) ( void * ) = ( int ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } # endif } void * asCScriptEngine :: CallGlobalFunctionRetPtr ( int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; return CallGlobalFunctionRetPtr ( s -> sysFuncIntf , s ) ; } void * asCScriptEngine :: CallGlobalFunctionRetPtr ( int func , void * param1 ) { asCScriptFunction * s = scriptFunctions [ func ] ; return CallGlobalFunctionRetPtr ( s -> sysFuncIntf , s , param1 ) ; } void * asCScriptEngine :: CallGlobalFunctionRetPtr ( asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { void * ( * f ) ( ) = ( void * ( * ) ( ) ) ( i -> func ) ; return f ( ) ; } else if ( i -> callConv == ICC_STDCALL ) { void * ( STDCALL * f ) ( ) = ( void * ( STDCALL * ) ( ) ) ( i -> func ) ; return f ( ) ; } else { asCGeneric gen ( this , s , 0 , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( void * * ) gen . GetReturnPointer ( ) ; } } void * asCScriptEngine :: CallGlobalFunctionRetPtr ( asSSystemFunctionInterface * i , asCScriptFunction * s , void * param1 ) { if ( i -> callConv == ICC_CDECL ) { void * ( * f ) ( void * ) = ( void * ( * ) ( void * ) ) ( i -> func ) ; return f ( param1 ) ; } else if ( i -> callConv == ICC_STDCALL ) { void * ( STDCALL * f ) ( void * ) = ( void * ( STDCALL * ) ( void * ) ) ( i -> func ) ; return f ( param1 ) ; } else { asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( void * * ) gen . GetReturnPointer ( ) ; } } void asCScriptEngine :: CallObjectMethod ( void * obj , void * param , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; CallObjectMethod ( obj , param , s -> sysFuncIntf , s ) ; } void asCScriptEngine :: CallObjectMethod ( void * obj , void * param , asSSystemFunctionInterface * i , asCScriptFunction * s ) { # ifdef __GNUC__ if ( i -> callConv == ICC_CDECL_OBJLAST ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param , obj ) ; } else if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , ( asDWORD * ) & param ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( obj , param ) ; } # else # ifndef AS_NO_CLASS_METHODS if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; void ( asCSimpleDummy :: * f ) ( void * ) = ( void ( asCSimpleDummy :: * ) ( void * ) ) ( p . mthd ) ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( param ) ; } else # endif if ( i -> callConv == ICC_CDECL_OBJLAST ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param , obj ) ; } else if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , ( asDWORD * ) & param ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( obj , param ) ; } # endif } void asCScriptEngine :: CallGlobalFunction ( void * param1 , void * param2 , asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param1 , param2 ) ; } else if ( i -> callConv == ICC_STDCALL ) { void ( STDCALL * f ) ( void * , void * ) = ( void ( STDCALL * ) ( void * , void * ) ) ( i -> func ) ; f ( param1 , param2 ) ; } else { asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } } bool asCScriptEngine :: CallGlobalFunctionRetBool ( void * param1 , void * param2 , asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { bool ( * f ) ( void * , void * ) = ( bool ( * ) ( void * , void * ) ) ( i -> func ) ; return f ( param1 , param2 ) ; } else if ( i -> callConv == ICC_STDCALL ) { bool ( STDCALL * f ) ( void * , void * ) = ( bool ( STDCALL * ) ( void * , void * ) ) ( i -> func ) ; return f ( param1 , param2 ) ; } else { asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } } void * asCScriptEngine :: CallAlloc ( asCObjectType * type ) { # if defined ( AS_DEBUG ) return ( ( asALLOCFUNCDEBUG_t ) ( userAlloc ) ) ( type -> size < 4 ? 4 : type -> size , __FILE__ , __LINE__ ) ; # else return userAlloc ( type -> size < 4 ? 4 : type -> size ) ; # endif } void asCScriptEngine :: CallFree ( void * obj ) { userFree ( obj ) ; } void asCScriptEngine :: NotifyGarbageCollectorOfNewObject ( void * obj , int typeId ) { asCObjectType * objType = GetObjectTypeFromTypeId ( typeId ) ; gc . AddScriptObjectToGC ( obj , objType ) ; } int asCScriptEngine :: GarbageCollect ( asDWORD flags ) { return gc . GarbageCollect ( flags ) ; } void asCScriptEngine :: GetGCStatistics ( asUINT * currentSize , asUINT * totalDestroyed , asUINT * totalDetected ) { gc . GetStatistics ( currentSize , totalDestroyed , totalDetected ) ; } void asCScriptEngine :: GCEnumCallback ( void * reference ) { gc . GCEnumCallback ( reference ) ; } int asCScriptEngine :: GetTypeIdFromDataType ( const asCDataType & dt ) { if ( dt . IsNullHandle ( ) ) return 0 ; asSMapNode < int , asCDataType * > * cursor = 0 ; mapTypeIdToDataType . MoveFirst ( & cursor ) ; while ( cursor ) { if ( mapTypeIdToDataType . GetValue ( cursor ) -> IsEqualExceptRefAndConst ( dt ) ) return mapTypeIdToDataType . GetKey ( cursor ) ; mapTypeIdToDataType . MoveNext ( & cursor , cursor ) ; } int typeId = typeIdSeqNbr ++ ; if ( dt . GetObjectType ( ) ) { if ( dt . GetObjectType ( ) -> flags & asOBJ_SCRIPT_OBJECT ) typeId |= asTYPEID_SCRIPTOBJECT ; else if ( dt . GetObjectType ( ) -> flags & asOBJ_TEMPLATE ) typeId |= asTYPEID_SCRIPTARRAY ; else if ( dt . GetObjectType ( ) -> flags & asOBJ_ENUM ) ; else typeId |= asTYPEID_APPOBJECT ; } asCDataType * newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( false ) ; mapTypeIdToDataType . Insert ( typeId , newDt ) ; if ( dt . IsObject ( ) && dt . GetObjectType ( ) -> beh . release ) { newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( true ) ; newDt -> MakeHandleToConst ( false ) ; mapTypeIdToDataType . Insert ( typeId | asTYPEID_OBJHANDLE , newDt ) ; newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( true ) ; newDt -> MakeHandleToConst ( true ) ; mapTypeIdToDataType . Insert ( typeId | asTYPEID_OBJHANDLE | asTYPEID_HANDLETOCONST , newDt ) ; } return GetTypeIdFromDataType ( dt ) ; } const asCDataType * asCScriptEngine :: GetDataTypeFromTypeId ( int typeId ) { asSMapNode < int , asCDataType * > * cursor = 0 ; if ( mapTypeIdToDataType . MoveTo ( & cursor , typeId ) ) return mapTypeIdToDataType . GetValue ( cursor ) ; return 0 ; } asCObjectType * asCScriptEngine :: GetObjectTypeFromTypeId ( int typeId ) { asSMapNode < int , asCDataType * > * cursor = 0 ; if ( mapTypeIdToDataType . MoveTo ( & cursor , typeId ) ) return mapTypeIdToDataType . GetValue ( cursor ) -> GetObjectType ( ) ; return 0 ; } void asCScriptEngine :: RemoveFromTypeIdMap ( asCObjectType * type ) { asSMapNode < int , asCDataType * > * cursor = 0 ; mapTypeIdToDataType . MoveFirst ( & cursor ) ; while ( cursor ) { asCDataType * dt = mapTypeIdToDataType . GetValue ( cursor ) ; asSMapNode < int , asCDataType * > * old = cursor ; mapTypeIdToDataType . MoveNext ( & cursor , cursor ) ; if ( dt -> GetObjectType ( ) == type ) { asDELETE ( dt , asCDataType ) ; mapTypeIdToDataType . Erase ( old ) ; } } } int asCScriptEngine :: GetTypeIdByDecl ( const char * decl ) { asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( decl , & dt ) ; if ( r < 0 ) return asINVALID_TYPE ; return GetTypeIdFromDataType ( dt ) ; } const char * asCScriptEngine :: GetTypeDeclaration ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( dt == 0 ) return 0 ; asASSERT ( threadManager ) ; asCString * tempString = & threadManager -> GetLocalData ( ) -> string ; * tempString = dt -> Format ( ) ; return tempString -> AddressOf ( ) ; } int asCScriptEngine :: GetSizeOfPrimitiveType ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( dt == 0 ) return 0 ; if ( ! dt -> IsPrimitive ( ) ) return 0 ; return dt -> GetSizeInMemoryBytes ( ) ; } void * asCScriptEngine :: CreateScriptObject ( int typeId ) { if ( ( typeId & ( asTYPEID_MASK_OBJECT | asTYPEID_MASK_SEQNBR ) ) != typeId ) return 0 ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return 0 ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return 0 ; asCObjectType * objType = dt -> GetObjectType ( ) ; void * ptr = 0 ; if ( objType -> flags & asOBJ_SCRIPT_OBJECT ) ptr = ScriptObjectFactory ( objType , this ) ; else if ( objType -> flags & asOBJ_TEMPLATE ) ptr = CallGlobalFunctionRetPtr ( objType -> beh . construct , objType ) ; else if ( objType -> flags & asOBJ_REF ) ptr = CallGlobalFunctionRetPtr ( objType -> beh . factory ) ; else { ptr = CallAlloc ( objType ) ; int funcIndex = objType -> beh . construct ; if ( funcIndex ) CallObjectMethod ( ptr , funcIndex ) ; } return ptr ; } void * asCScriptEngine :: CreateScriptObjectCopy ( void * origObj , int typeId ) { void * newObj = CreateScriptObject ( typeId ) ; if ( newObj == 0 ) return 0 ; CopyScriptObject ( newObj , origObj , typeId ) ; return newObj ; } void asCScriptEngine :: CopyScriptObject ( void * dstObj , void * srcObj , int typeId ) { if ( ( typeId & ( asTYPEID_MASK_OBJECT | asTYPEID_MASK_SEQNBR ) ) != typeId ) return ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; if ( objType -> beh . copy ) { CallObjectMethod ( dstObj , srcObj , objType -> beh . copy ) ; } else if ( objType -> size ) { memcpy ( dstObj , srcObj , objType -> size ) ; } } void asCScriptEngine :: AddRefScriptObject ( void * obj , int typeId ) { if ( obj == 0 ) return ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; if ( objType -> beh . addref ) { CallObjectMethod ( obj , objType -> beh . addref ) ; } } void asCScriptEngine :: ReleaseScriptObject ( void * obj , int typeId ) { if ( obj == 0 ) return ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; if ( objType -> beh . release ) { CallObjectMethod ( obj , objType -> beh . release ) ; } else { if ( objType -> beh . destruct ) CallObjectMethod ( obj , objType -> beh . destruct ) ; CallFree ( obj ) ; } } bool asCScriptEngine :: IsHandleCompatibleWithObject ( void * obj , int objTypeId , int handleTypeId ) { if ( objTypeId == handleTypeId ) return true ; const asCDataType * objDt = GetDataTypeFromTypeId ( objTypeId ) ; const asCDataType * hdlDt = GetDataTypeFromTypeId ( handleTypeId ) ; if ( objDt -> IsHandleToConst ( ) && ! hdlDt -> IsHandleToConst ( ) ) return false ; if ( objDt -> GetObjectType ( ) == hdlDt -> GetObjectType ( ) ) { return true ; } else if ( objDt -> IsScriptObject ( ) && obj ) { asCObjectType * objType = ( ( asCScriptObject * ) obj ) -> objType ; if ( objType -> Implements ( hdlDt -> GetObjectType ( ) ) ) return true ; } return false ; } int asCScriptEngine :: BeginConfigGroup ( const char * groupName ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) return asNAME_TAKEN ; } if ( currentGroup != & defaultGroup ) return asNOT_SUPPORTED ; asCConfigGroup * group = asNEW ( asCConfigGroup ) ( ) ; group -> groupName = groupName ; configGroups . PushLast ( group ) ; currentGroup = group ; return 0 ; } int asCScriptEngine :: EndConfigGroup ( ) { if ( currentGroup == & defaultGroup ) return asNOT_SUPPORTED ; currentGroup = & defaultGroup ; return 0 ; } int asCScriptEngine :: RemoveConfigGroup ( const char * groupName ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) { asCConfigGroup * group = configGroups [ n ] ; if ( group -> refCount > 0 ) return asCONFIG_GROUP_IS_IN_USE ; if ( group -> HasLiveObjects ( ) ) return asCONFIG_GROUP_IS_IN_USE ; if ( n == configGroups . GetLength ( ) - 1 ) configGroups . PopLast ( ) ; else configGroups [ n ] = configGroups . PopLast ( ) ; group -> RemoveConfiguration ( this ) ; asDELETE ( group , asCConfigGroup ) ; } } return 0 ; } asCConfigGroup * asCScriptEngine :: FindConfigGroupForFunction ( int funcId ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { asUINT m ; for ( m = 0 ; m < configGroups [ n ] -> scriptFunctions . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> scriptFunctions [ m ] -> id == funcId ) return configGroups [ n ] ; } } return 0 ; } asCConfigGroup * asCScriptEngine :: FindConfigGroupForGlobalVar ( int gvarId ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { for ( asUINT m = 0 ; m < configGroups [ n ] -> globalProps . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> globalProps [ m ] -> id == gvarId ) return configGroups [ n ] ; } } return 0 ; } asCConfigGroup * asCScriptEngine :: FindConfigGroupForObjectType ( const asCObjectType * objType ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { for ( asUINT m = 0 ; m < configGroups [ n ] -> objTypes . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> objTypes [ m ] == objType ) return configGroups [ n ] ; } } return 0 ; } int asCScriptEngine :: SetConfigGroupModuleAccess ( const char * groupName , const char * module , bool hasAccess ) { asCConfigGroup * group = 0 ; for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) { group = configGroups [ n ] ; break ; } } if ( group == 0 ) return asWRONG_CONFIG_GROUP ; return group -> SetModuleAccess ( module , hasAccess ) ; } int asCScriptEngine :: GetNextScriptFunctionId ( ) { if ( freeScriptFunctionIds . GetLength ( ) ) return freeScriptFunctionIds . PopLast ( ) ; int id = ( int ) scriptFunctions . GetLength ( ) ; scriptFunctions . PushLast ( 0 ) ; return id ; } void asCScriptEngine :: SetScriptFunction ( asCScriptFunction * func ) { scriptFunctions [ func -> id ] = func ; } void asCScriptEngine :: FreeScriptFunctionId ( int id ) { if ( id < 0 ) return ; id &= 0xFFFF ; if ( id >= ( int ) scriptFunctions . GetLength ( ) ) return ; if ( scriptFunctions [ id ] ) { asCScriptFunction * func = scriptFunctions [ id ] ; if ( id == ( int ) scriptFunctions . GetLength ( ) - 1 ) { scriptFunctions . PopLast ( ) ; } else { scriptFunctions [ id ] = 0 ; freeScriptFunctionIds . PushLast ( id ) ; } if ( func -> signatureId == id ) { signatureIds . RemoveValue ( func ) ; int newSigId = 0 ; for ( asUINT n = 0 ; n < scriptFunctions . GetLength ( ) ; n ++ ) { if ( scriptFunctions [ n ] && scriptFunctions [ n ] -> signatureId == id ) { if ( newSigId == 0 ) { newSigId = scriptFunctions [ n ] -> id ; signatureIds . PushLast ( scriptFunctions [ n ] ) ; } scriptFunctions [ n ] -> signatureId = newSigId ; } } } } } int asCScriptEngine :: RegisterTypedef ( const char * type , const char * decl ) { if ( type == 0 ) return ConfigError ( asINVALID_NAME ) ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == type ) return asALREADY_REGISTERED ; } asCTokenizer t ; size_t tokenLen ; eTokenType token ; asCDataType dataType ; token = t . GetToken ( decl , strlen ( decl ) , & tokenLen ) ; switch ( token ) { case ttBool : case ttInt : case ttInt8 : case ttInt16 : case ttInt64 : case ttUInt : case ttUInt8 : case ttUInt16 : case ttUInt64 : case ttFloat : case ttDouble : if ( strlen ( decl ) != tokenLen ) { return ConfigError ( asINVALID_TYPE ) ; } break ; default : return ConfigError ( asINVALID_TYPE ) ; } dataType = asCDataType :: CreatePrimitive ( token , false ) ; token = t . GetToken ( type , strlen ( type ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( type ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; asCBuilder bld ( this , 0 ) ; int r = bld . CheckNameConflict ( type , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * object = asNEW ( asCObjectType ) ( this ) ; object -> flags = asOBJ_TYPEDEF ; object -> size = dataType . GetSizeInMemoryBytes ( ) ; object -> name = type ; object -> templateSubType = dataType ; objectTypes . PushLast ( object ) ; registeredTypeDefs . PushLast ( object ) ; currentGroup -> objTypes . PushLast ( object ) ; return asSUCCESS ; } int asCScriptEngine :: GetTypedefCount ( ) { return ( int ) registeredTypeDefs . GetLength ( ) ; } const char * asCScriptEngine :: GetTypedefByIndex ( asUINT index , int * typeId , const char * * configGroup ) { if ( index >= registeredTypeDefs . GetLength ( ) ) return 0 ; if ( typeId ) * typeId = GetTypeIdByDecl ( registeredTypeDefs [ index ] -> name . AddressOf ( ) ) ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForObjectType ( registeredTypeDefs [ index ] ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } return registeredTypeDefs [ index ] -> name . AddressOf ( ) ; } int asCScriptEngine :: RegisterEnum ( const char * name ) { if ( NULL == name ) return ConfigError ( asINVALID_NAME ) ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) return asALREADY_REGISTERED ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; bool oldMsgCallback = msgCallback ; msgCallback = false ; int r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; if ( r >= 0 ) return ConfigError ( asERROR ) ; asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , strlen ( name ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( name ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * st = asNEW ( asCObjectType ) ( this ) ; asCDataType dataType ; dataType . CreatePrimitive ( ttInt , false ) ; st -> flags = asOBJ_ENUM ; st -> size = dataType . GetSizeInMemoryBytes ( ) ; st -> name = name ; objectTypes . PushLast ( st ) ; registeredEnums . PushLast ( st ) ; currentGroup -> objTypes . PushLast ( st ) ; return asSUCCESS ; } int asCScriptEngine :: RegisterEnumValue ( const char * typeName , const char * valueName , int value ) { if ( currentGroup -> FindType ( typeName ) == 0 ) return asWRONG_CONFIG_GROUP ; asCDataType dt ; int r ; asCBuilder bld ( this , 0 ) ; r = bld . ParseDataType ( typeName , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; asCObjectType * ot = dt . GetObjectType ( ) ; if ( ot == 0 || ! ( ot -> flags & asOBJ_ENUM ) ) return ConfigError ( asINVALID_TYPE ) ; if ( NULL == valueName ) return ConfigError ( asINVALID_NAME ) ; for ( unsigned int n = 0 ; n < ot -> enumValues . GetLength ( ) ; n ++ ) { if ( ot -> enumValues [ n ] -> name == valueName ) return ConfigError ( asALREADY_REGISTERED ) ; } asSEnumValue * e = asNEW ( asSEnumValue ) ; e -> name = valueName ; e -> value = value ; ot -> enumValues . PushLast ( e ) ; return asSUCCESS ; } int asCScriptEngine :: GetEnumCount ( ) { return ( int ) registeredEnums . GetLength ( ) ; } const char * asCScriptEngine :: GetEnumByIndex ( asUINT index , int * enumTypeId , const char * * configGroup ) { if ( index >= registeredEnums . GetLength ( ) ) return 0 ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForObjectType ( registeredEnums [ index ] ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } if ( enumTypeId ) * enumTypeId = GetTypeIdByDecl ( registeredEnums [ index ] -> name . AddressOf ( ) ) ; return registeredEnums [ index ] -> name . AddressOf ( ) ; } int asCScriptEngine :: GetEnumValueCount ( int enumTypeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( enumTypeId ) ; asCObjectType * t = dt -> GetObjectType ( ) ; if ( t == 0 || ! ( t -> GetFlags ( ) & asOBJ_ENUM ) ) return asINVALID_TYPE ; return ( int ) t -> enumValues . GetLength ( ) ; } const char * asCScriptEngine :: GetEnumValueByIndex ( int enumTypeId , asUINT index , int * outValue ) { const asCDataType * dt = GetDataTypeFromTypeId ( enumTypeId ) ; asCObjectType * t = dt -> GetObjectType ( ) ; if ( t == 0 || ! ( t -> GetFlags ( ) & asOBJ_ENUM ) ) return 0 ; if ( index >= t -> enumValues . GetLength ( ) ) return 0 ; if ( outValue ) * outValue = t -> enumValues [ index ] -> value ; return t -> enumValues [ index ] -> name . AddressOf ( ) ; } int asCScriptEngine :: GetObjectTypeCount ( ) { return ( int ) registeredObjTypes . GetLength ( ) ; } asIObjectType * asCScriptEngine :: GetObjectTypeByIndex ( asUINT index ) { if ( index >= registeredObjTypes . GetLength ( ) ) return 0 ; return registeredObjTypes [ index ] ; } asIObjectType * asCScriptEngine :: GetObjectTypeById ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return 0 ; if ( dt -> GetObjectType ( ) && dt -> GetObjectType ( ) -> GetFlags ( ) & asOBJ_ENUM ) return 0 ; return dt -> GetObjectType ( ) ; } asIScriptFunction * asCScriptEngine :: GetFunctionDescriptorById ( int funcId ) { return GetScriptFunction ( funcId ) ; } bool asCScriptEngine :: IsTemplateType ( const char * name ) { for ( unsigned int n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) { return objectTypes [ n ] -> flags & asOBJ_TEMPLATE ? true : false ; } } return false ; } int asCScriptEngine :: AddConstantString ( const char * str , size_t len ) { for ( size_t n = 0 ; n < stringConstants . GetLength ( ) ; n ++ ) { if ( stringConstants [ n ] -> Compare ( str , len ) == 0 ) { return ( int ) n ; } } asCString * cstr = asNEW ( asCString ) ( str , len ) ; stringConstants . PushLast ( cstr ) ; asASSERT ( stringConstants . GetLength ( ) <= 65536 ) ; return ( int ) stringConstants . GetLength ( ) - 1 ; } const asCString & asCScriptEngine :: GetConstantString ( int id ) { return * stringConstants [ id ] ; } int asCScriptEngine :: GetScriptSectionNameIndex ( const char * name ) { for ( asUINT n = 0 ; n < scriptSectionNames . GetLength ( ) ; n ++ ) { if ( scriptSectionNames [ n ] -> Compare ( name ) == 0 ) return n ; } scriptSectionNames . PushLast ( asNEW ( asCString ) ( name ) ) ; return int ( scriptSectionNames . GetLength ( ) - 1 ) ; } END_AS_NAMESPACE </DOCUMENT>
<DOCUMENT_ID="boiled-sugar/mkvtoolnix/tree/master/src/output/p_mpeg4_p2.cpp"> # include " common / common _ pch . h " # include " avilib . h " # include " common / codec . h " # include " common / endian . h " # include " common / hacks . h " # include " common / math . h " # include " common / strings / formatting . h " # include " merge / generic _ reader . h " # include " merge / output _ control . h " # include " output / p _ mpeg4 _ p2 . h " mpeg4_p2_video_packetizer_c :: mpeg4_p2_video_packetizer_c ( generic_reader_c * p_reader , track_info_c & p_ti , double fps , int width , int height , bool input_is_native ) : video_for_windows_packetizer_c ( p_reader , p_ti , fps , width , height ) , m_timecodes_generated ( 0 ) , m_previous_timecode ( 0 ) , m_aspect_ratio_extracted ( false ) , m_input_is_native ( input_is_native ) , m_output_is_native ( hack_engaged ( ENGAGE_NATIVE_MPEG4 ) || input_is_native ) , m_size_extracted ( false ) { if ( ! m_output_is_native ) m_timestamp_factory_application_mode = TFA_SHORT_QUEUEING ; else { set_codec_id ( MKV_V_MPEG4_ASP ) ; if ( ! m_input_is_native ) m_ti . m_private_data . reset ( ) ; if ( m_ti . m_ext_timecodes . empty ( ) ) m_timestamp_factory . reset ( ) ; if ( m_default_duration_forced ) m_fps = 1000000000.0 / m_htrack_default_duration ; else if ( 0.0 != m_fps ) m_htrack_default_duration = static_cast < int64_t > ( 1000000000ll / m_fps ) ; m_timestamp_factory_application_mode = TFA_FULL_QUEUEING ; } } mpeg4_p2_video_packetizer_c :: ~ mpeg4_p2_video_packetizer_c ( ) { if ( ! debugging_c :: requested ( " mpeg4 _ p2 _ statistics " ) ) return ; mxinfo ( boost :: format ( " mpeg4 _ p2 _ video _ packetizer _ c ▁ statistics : \n " " ▁ ▁ # ▁ I ▁ frames : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 1 % \n " " ▁ ▁ # ▁ P ▁ frames : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 2 % \n " " ▁ ▁ # ▁ B ▁ frames : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 3 % \n " " ▁ ▁ # ▁ NVOPs : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 4 % \n " " ▁ ▁ # ▁ generated ▁ timecodes : ▁ % 5 % \n " " ▁ ▁ # ▁ dropped ▁ timecodes : ▁ ▁ ▁ % 6 % \n " ) % m_statistics . m_num_i_frames % m_statistics . m_num_p_frames % m_statistics . m_num_b_frames % m_statistics . m_num_n_vops % m_statistics . m_num_generated_timecodes % m_statistics . m_num_dropped_timecodes ) ; } int mpeg4_p2_video_packetizer_c :: process ( packet_cptr packet ) { extract_size ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) ) ; extract_aspect_ratio ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) ) ; int result = m_input_is_native == m_output_is_native ? video_for_windows_packetizer_c :: process ( packet ) : m_input_is_native ? process_native ( packet ) : process_non_native ( packet ) ; ++ m_frames_output ; return result ; } int mpeg4_p2_video_packetizer_c :: process_non_native ( packet_cptr packet ) { extract_config_data ( packet ) ; if ( - 1 != packet -> timecode ) { if ( ! m_default_duration_forced ) m_available_timecodes . push_back ( timecode_duration_t ( packet -> timecode , packet -> duration ) ) ; else { m_available_timecodes . push_back ( timecode_duration_t ( m_timecodes_generated * m_htrack_default_duration , m_htrack_default_duration ) ) ; ++ m_timecodes_generated ; } } else if ( 0.0 == m_fps ) mxerror_tid ( m_ti . m_fname , m_ti . m_id , Y ( " Cannot ▁ convert ▁ non - native ▁ MPEG4 ▁ video ▁ frames ▁ into ▁ native ▁ ones ▁ if ▁ the ▁ source ▁ container ▁ " " provides ▁ neither ▁ timecodes ▁ nor ▁ a ▁ number ▁ of ▁ frames ▁ per ▁ second . \n " ) ) ; std :: vector < video_frame_t > frames ; mpeg4 :: p2 :: find_frame_types ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) , frames , m_config_data ) ; for ( auto & frame : frames ) { if ( ! frame . is_coded ) { ++ m_statistics . m_num_n_vops ; int num_surplus_timecodes = static_cast < int > ( m_available_timecodes . size ( ) ) - static_cast < int > ( m_ref_frames . size ( ) + m_b_frames . size ( ) ) ; if ( 0 < num_surplus_timecodes ) { std :: deque < timecode_duration_t > :: iterator start = m_available_timecodes . begin ( ) + m_ref_frames . size ( ) + m_b_frames . size ( ) ; std :: deque < timecode_duration_t > :: iterator end = start + num_surplus_timecodes ; if ( 0 != ( m_ref_frames . size ( ) + m_b_frames . size ( ) ) ) { std :: deque < timecode_duration_t > :: iterator last = m_available_timecodes . begin ( ) + m_ref_frames . size ( ) + m_b_frames . size ( ) - 1 ; std :: deque < timecode_duration_t > :: iterator cur = start ; while ( cur != end ) { last -> m_duration = std :: max ( last -> m_duration , static_cast < int64_t > ( 0 ) ) + std :: max ( cur -> m_duration , static_cast < int64_t > ( 0 ) ) ; ++ cur ; } } m_available_timecodes . erase ( start , end ) ; m_statistics . m_num_dropped_timecodes += num_surplus_timecodes ; } continue ; } if ( FRAME_TYPE_I == frame . type ) ++ m_statistics . m_num_i_frames ; else if ( FRAME_TYPE_P == frame . type ) ++ m_statistics . m_num_p_frames ; else ++ m_statistics . m_num_b_frames ; if ( FRAME_TYPE_B != frame . type ) flush_frames ( false ) ; frame . data = ( unsigned char * ) safememdup ( packet -> data -> get_buffer ( ) + frame . pos , frame . size ) ; frame . timecode = - 1 ; if ( FRAME_TYPE_B == frame . type ) m_b_frames . push_back ( frame ) ; else m_ref_frames . push_back ( frame ) ; } m_previous_timecode = m_available_timecodes . back ( ) . m_timecode ; return FILE_STATUS_MOREDATA ; } void mpeg4_p2_video_packetizer_c :: extract_config_data ( packet_cptr & packet ) { if ( m_ti . m_private_data ) return ; m_ti . m_private_data = memory_cptr { mpeg4 :: p2 :: parse_config_data ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) , m_config_data ) } ; if ( ! m_ti . m_private_data ) mxerror_tid ( m_ti . m_fname , m_ti . m_id , Y ( " Could ▁ not ▁ find ▁ the ▁ codec ▁ configuration ▁ data ▁ in ▁ the ▁ first ▁ MPEG - 4 ▁ part ▁ 2 ▁ video ▁ frame . ▁ This ▁ track ▁ cannot ▁ be ▁ stored ▁ in ▁ native ▁ mode . \n " ) ) ; fix_codec_string ( ) ; set_codec_private ( m_ti . m_private_data ) ; rerender_track_headers ( ) ; } void mpeg4_p2_video_packetizer_c :: fix_codec_string ( ) { static const unsigned char start_code [ 4 ] = { 0x00 , 0x00 , 0x01 , 0xb2 } ; if ( ! m_ti . m_private_data || ( 0 == m_ti . m_private_data -> get_size ( ) ) ) return ; auto private_data = m_ti . m_private_data -> get_buffer ( ) ; int size = m_ti . m_private_data -> get_size ( ) ; int i ; for ( i = 0 ; 9 < size ; ) { if ( memcmp ( & private_data [ i ] , start_code , 4 ) != 0 ) { ++ i ; -- size ; continue ; } i += 8 ; size -= 8 ; if ( strncasecmp ( ( const char * ) & private_data [ i - 4 ] , " divx " , 4 ) != 0 ) continue ; unsigned char * end_pos = ( unsigned char * ) memchr ( & private_data [ i ] , 0 , size ) ; if ( ! end_pos ) end_pos = & private_data [ i + size ] ; -- end_pos ; if ( ' p ' == * end_pos ) * end_pos = ' n ' ; return ; } } int mpeg4_p2_video_packetizer_c :: process_native ( packet_cptr ) { return FILE_STATUS_MOREDATA ; } void mpeg4_p2_video_packetizer_c :: generate_timecode_and_duration ( ) { if ( 0.0 >= m_fps ) { mxexit ( 1 ) ; } if ( m_available_timecodes . empty ( ) ) { m_previous_timecode = ( int64_t ) ( m_previous_timecode + 1000000000.0 / m_fps ) ; m_available_timecodes . push_back ( timecode_duration_t ( m_previous_timecode , ( int64_t ) ( 1000000000.0 / m_fps ) ) ) ; mxverb ( 3 , boost :: format ( " mpeg4 _ p2 : : flush _ frames ( ) : ▁ Needed ▁ new ▁ timecode ▁ % 1 % \n " ) % m_previous_timecode ) ; ++ m_statistics . m_num_generated_timecodes ; } } void mpeg4_p2_video_packetizer_c :: get_next_timecode_and_duration ( int64_t & timecode , int64_t & duration ) { if ( m_available_timecodes . empty ( ) ) generate_timecode_and_duration ( ) ; timecode = m_available_timecodes . front ( ) . m_timecode ; duration = m_available_timecodes . front ( ) . m_duration ; m_available_timecodes . pop_front ( ) ; } void mpeg4_p2_video_packetizer_c :: flush_frames ( bool end_of_file ) { if ( m_ref_frames . empty ( ) ) return ; if ( m_ref_frames . size ( ) == 1 ) { video_frame_t & frame = m_ref_frames . front ( ) ; if ( - 1 == frame . timecode ) { get_next_timecode_and_duration ( frame . timecode , frame . duration ) ; add_packet ( new packet_t ( new memory_c ( frame . data , frame . size , true ) , frame . timecode , frame . duration ) ) ; } return ; } video_frame_t & bref_frame = m_ref_frames . front ( ) ; video_frame_t & fref_frame = m_ref_frames . back ( ) ; for ( auto & frame : m_b_frames ) get_next_timecode_and_duration ( frame . timecode , frame . duration ) ; get_next_timecode_and_duration ( fref_frame . timecode , fref_frame . duration ) ; add_packet ( new packet_t ( new memory_c ( fref_frame . data , fref_frame . size , true ) , fref_frame . timecode , fref_frame . duration , FRAME_TYPE_P == fref_frame . type ? bref_frame . timecode : VFT_IFRAME ) ) ; for ( auto & frame : m_b_frames ) add_packet ( new packet_t ( new memory_c ( frame . data , frame . size , true ) , frame . timecode , frame . duration , bref_frame . timecode , fref_frame . timecode ) ) ; m_ref_frames . pop_front ( ) ; m_b_frames . clear ( ) ; if ( end_of_file ) m_ref_frames . clear ( ) ; } void mpeg4_p2_video_packetizer_c :: flush_impl ( ) { flush_frames ( true ) ; } void mpeg4_p2_video_packetizer_c :: extract_aspect_ratio ( const unsigned char * buffer , int size ) { if ( m_aspect_ratio_extracted ) return ; if ( ( 0 != m_connected_to ) || display_dimensions_or_aspect_ratio_set ( ) ) { m_aspect_ratio_extracted = true ; return ; } uint32_t num , den ; if ( mpeg4 :: p2 :: extract_par ( buffer , size , num , den ) ) { m_aspect_ratio_extracted = true ; set_video_aspect_ratio ( ( double ) m_hvideo_pixel_width / ( double ) m_hvideo_pixel_height * ( double ) num / ( double ) den , false , OPTION_SOURCE_BITSTREAM ) ; generic_packetizer_c :: set_headers ( ) ; rerender_track_headers ( ) ; mxinfo_tid ( m_ti . m_fname , m_ti . m_id , boost :: format ( Y ( " Extracted ▁ the ▁ aspect ▁ ratio ▁ information ▁ from ▁ the ▁ MPEG4 ▁ layer ▁ 2 ▁ video ▁ data ▁ and ▁ set ▁ the ▁ display ▁ dimensions ▁ to ▁ % 1 % / %2 % . \n " ) ) % m_hvideo_display_width % m_hvideo_display_height ) ; } else if ( 50 <= m_frames_output ) m_aspect_ratio_extracted = true ; } void mpeg4_p2_video_packetizer_c :: extract_size ( const unsigned char * buffer , int size ) { if ( m_size_extracted ) return ; if ( 0 != m_connected_to ) { m_size_extracted = true ; return ; } uint32_t xtr_width , xtr_height ; if ( mpeg4 :: p2 :: extract_size ( buffer , size , xtr_width , xtr_height ) ) { m_size_extracted = true ; if ( ! m_reader -> m_appending && ( ( xtr_width != static_cast < uint32_t > ( m_hvideo_pixel_width ) ) || ( xtr_height != static_cast < uint32_t > ( m_hvideo_pixel_height ) ) ) ) { set_video_pixel_width ( xtr_width ) ; set_video_pixel_height ( xtr_height ) ; if ( ! m_output_is_native && m_ti . m_private_data && ( sizeof ( alBITMAPINFOHEADER ) <= m_ti . m_private_data -> get_size ( ) ) ) { auto bih = reinterpret_cast < alBITMAPINFOHEADER * > ( m_ti . m_private_data -> get_buffer ( ) ) ; put_uint32_le ( & bih -> bi_width , xtr_width ) ; put_uint32_le ( & bih -> bi_height , xtr_height ) ; set_codec_private ( m_ti . m_private_data ) ; } m_hvideo_display_width = - 1 ; m_hvideo_display_height = - 1 ; generic_packetizer_c :: set_headers ( ) ; rerender_track_headers ( ) ; mxinfo_tid ( m_ti . m_fname , m_ti . m_id , boost :: format ( Y ( " The ▁ extracted ▁ values ▁ for ▁ video ▁ width ▁ and ▁ height ▁ from ▁ the ▁ MPEG4 ▁ layer ▁ 2 ▁ video ▁ data ▁ bitstream ▁ differ ▁ from ▁ what ▁ the ▁ values ▁ " " in ▁ the ▁ source ▁ container . ▁ The ▁ ones ▁ from ▁ the ▁ video ▁ data ▁ bitstream ▁ ( %1 % x % 2 % ) ▁ will ▁ be ▁ used . \n " ) ) % xtr_width % xtr_height ) ; } } else if ( 50 <= m_frames_output ) m_aspect_ratio_extracted = true ; } </DOCUMENT>
<DOCUMENT_ID="StevenBlack/phantomjs/tree/master/src/qt/qtwebkit/Source/WebCore/platform/audio/AudioFIFO.cpp"> # include " config . h " # if ENABLE ( WEB_AUDIO ) # include " AudioFIFO . h " namespace WebCore { AudioFIFO :: AudioFIFO ( unsigned numberOfChannels , size_t fifoLength ) : m_fifoAudioBus ( AudioBus :: create ( numberOfChannels , fifoLength ) ) , m_fifoLength ( fifoLength ) , m_framesInFifo ( 0 ) , m_readIndex ( 0 ) , m_writeIndex ( 0 ) { } void AudioFIFO :: consume ( AudioBus * destination , size_t framesToConsume ) { bool isGood = destination && ( framesToConsume <= m_fifoLength ) && ( framesToConsume <= m_framesInFifo ) && ( destination -> length ( ) >= framesToConsume ) ; ASSERT ( isGood ) ; if ( ! isGood ) return ; size_t part1Length ; size_t part2Length ; findWrapLengths ( m_readIndex , framesToConsume , part1Length , part2Length ) ; size_t numberOfChannels = m_fifoAudioBus -> numberOfChannels ( ) ; for ( size_t channelIndex = 0 ; channelIndex < numberOfChannels ; ++ channelIndex ) { float * destinationData = destination -> channel ( channelIndex ) -> mutableData ( ) ; const float * sourceData = m_fifoAudioBus -> channel ( channelIndex ) -> data ( ) ; bool isCopyGood = ( ( m_readIndex < m_fifoLength ) && ( m_readIndex + part1Length ) <= m_fifoLength && ( part1Length <= destination -> length ( ) ) && ( part1Length + part2Length ) <= destination -> length ( ) ) ; ASSERT ( isCopyGood ) ; if ( ! isCopyGood ) return ; memcpy ( destinationData , sourceData + m_readIndex , part1Length * sizeof ( * sourceData ) ) ; if ( part2Length ) memcpy ( destinationData + part1Length , sourceData , part2Length * sizeof ( * sourceData ) ) ; } m_readIndex = updateIndex ( m_readIndex , framesToConsume ) ; ASSERT ( m_framesInFifo >= framesToConsume ) ; m_framesInFifo -= framesToConsume ; } void AudioFIFO :: push ( const AudioBus * sourceBus ) { bool isGood = sourceBus && ( m_framesInFifo + sourceBus -> length ( ) <= m_fifoLength ) ; if ( ! isGood ) return ; size_t sourceLength = sourceBus -> length ( ) ; size_t part1Length ; size_t part2Length ; findWrapLengths ( m_writeIndex , sourceLength , part1Length , part2Length ) ; size_t numberOfChannels = m_fifoAudioBus -> numberOfChannels ( ) ; for ( size_t channelIndex = 0 ; channelIndex < numberOfChannels ; ++ channelIndex ) { float * destination = m_fifoAudioBus -> channel ( channelIndex ) -> mutableData ( ) ; const float * source = sourceBus -> channel ( channelIndex ) -> data ( ) ; bool isCopyGood = ( ( m_writeIndex < m_fifoLength ) && ( m_writeIndex + part1Length ) <= m_fifoLength && part2Length < m_fifoLength && part1Length + part2Length <= sourceLength ) ; ASSERT ( isCopyGood ) ; if ( ! isCopyGood ) return ; memcpy ( destination + m_writeIndex , source , part1Length * sizeof ( * destination ) ) ; if ( part2Length ) memcpy ( destination , source + part1Length , part2Length * sizeof ( * destination ) ) ; } m_framesInFifo += sourceLength ; ASSERT ( m_framesInFifo <= m_fifoLength ) ; m_writeIndex = updateIndex ( m_writeIndex , sourceLength ) ; } void AudioFIFO :: findWrapLengths ( size_t index , size_t size , size_t & part1Length , size_t & part2Length ) { ASSERT_WITH_SECURITY_IMPLICATION ( index < m_fifoLength && size <= m_fifoLength ) ; if ( index < m_fifoLength && size <= m_fifoLength ) { if ( index + size > m_fifoLength ) { part1Length = m_fifoLength - index ; part2Length = size - part1Length ; } else { part1Length = size ; part2Length = 0 ; } } else { part1Length = 0 ; part2Length = 0 ; } } } # endif </DOCUMENT>
<DOCUMENT_ID="Greymane/SkyFireEMU/tree/master/dep/acelite/ace/OS_NS_errno.cpp"> # include " ace / OS _ NS _ errno . h " # if ! defined ( ACE_HAS_INLINED_OSCALLS ) # include " ace / OS _ NS _ errno . inl " # endif </DOCUMENT>
<DOCUMENT_ID="jbrains/trivia/tree/master/C++/GameRunner.cpp"> # include < stdlib . h > # include " Game . h " static bool notAWinner ; int main ( ) { Game aGame ; aGame . add ( " Chet " ) ; aGame . add ( " Pat " ) ; aGame . add ( " Sue " ) ; do { aGame . roll ( rand ( ) % 5 + 1 ) ; if ( rand ( ) % 9 == 7 ) { notAWinner = aGame . wrongAnswer ( ) ; } else { notAWinner = aGame . wasCorrectlyAnswered ( ) ; } } while ( notAWinner ) ; } </DOCUMENT>
<DOCUMENT_ID="pokowaka/xbmc/tree/master/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbumCompilations.cpp"> # include " DirectoryNodeAlbumCompilations . h " # include " QueryParams . h " # include " music / MusicDatabase . h " using namespace XFILE :: MUSICDATABASEDIRECTORY ; CDirectoryNodeAlbumCompilations :: CDirectoryNodeAlbumCompilations ( const std :: string & strName , CDirectoryNode * pParent ) : CDirectoryNode ( NODE_TYPE_ALBUM_COMPILATIONS , strName , pParent ) { } NODE_TYPE CDirectoryNodeAlbumCompilations :: GetChildType ( ) const { if ( GetName ( ) == " - 1" ) return NODE_TYPE_ALBUM_COMPILATIONS_SONGS ; return NODE_TYPE_SONG ; } std :: string CDirectoryNodeAlbumCompilations :: GetLocalizedName ( ) const { if ( GetID ( ) == - 1 ) return g_localizeStrings . Get ( 15102 ) ; CMusicDatabase db ; if ( db . Open ( ) ) return db . GetAlbumById ( GetID ( ) ) ; return " " ; } bool CDirectoryNodeAlbumCompilations :: GetContent ( CFileItemList & items ) const { CMusicDatabase musicdatabase ; if ( ! musicdatabase . Open ( ) ) return false ; CQueryParams params ; CollectQueryParams ( params ) ; bool bSuccess = musicdatabase . GetCompilationAlbums ( BuildPath ( ) , items ) ; musicdatabase . Close ( ) ; return bSuccess ; } </DOCUMENT>
<DOCUMENT_ID="celeron55/clementine/tree/master/3rdparty/libprojectm/Renderer/Pipeline.cpp"> # include " Pipeline . hpp " # include " wipemalloc . h " Pipeline :: Pipeline ( ) : staticPerPixel ( false ) , gx ( 0 ) , gy ( 0 ) , blur1n ( 1 ) , blur2n ( 1 ) , blur3n ( 1 ) , blur1x ( 1 ) , blur2x ( 1 ) , blur3x ( 1 ) , blur1ed ( 1 ) { } void Pipeline :: setStaticPerPixel ( int gx , int gy ) { staticPerPixel = true ; this -> gx = gx ; this -> gy = gy ; this -> x_mesh = ( float * * ) wipemalloc ( gx * sizeof ( float * ) ) ; for ( int x = 0 ; x < gx ; x ++ ) { this -> x_mesh [ x ] = ( float * ) wipemalloc ( gy * sizeof ( float ) ) ; } this -> y_mesh = ( float * * ) wipemalloc ( gx * sizeof ( float * ) ) ; for ( int x = 0 ; x < gx ; x ++ ) { this -> y_mesh [ x ] = ( float * ) wipemalloc ( gy * sizeof ( float ) ) ; } } Pipeline :: ~ Pipeline ( ) { if ( staticPerPixel ) { for ( int x = 0 ; x < this -> gx ; x ++ ) { free ( this -> x_mesh [ x ] ) ; free ( this -> y_mesh [ x ] ) ; } free ( x_mesh ) ; free ( y_mesh ) ; } } PixelPoint Pipeline :: PerPixel ( PixelPoint p , const PerPixelContext context ) { return p ; } </DOCUMENT>
<DOCUMENT_ID="Rudi9719/curly-octo-barnacle/tree/master/TrinityCore/src/server/scripts/Northrend/Nexus/Nexus/boss_ormorok.cpp"> # include " ScriptMgr . h " # include " ScriptedCreature . h " # include " nexus . h " # include " SpellScript . h " enum Spells { SPELL_SPELL_REFLECTION = 47981 , SPELL_TRAMPLE = 48016 , SPELL_FRENZY = 48017 , SPELL_SUMMON_CRYSTALLINE_TANGLER = 61564 , SPELL_CRYSTAL_SPIKES = 47958 , } ; enum Yells { SAY_AGGRO = 1 , SAY_DEATH = 2 , SAY_REFLECT = 3 , SAY_CRYSTAL_SPIKES = 4 , SAY_KILL = 5 , SAY_FRENZY = 6 } ; enum Events { EVENT_CRYSTAL_SPIKES = 1 , EVENT_TRAMPLE = 2 , EVENT_SPELL_REFLECTION = 3 , EVENT_CRYSTALLINE_TANGLER = 4 , } ; class OrmorokTanglerPredicate { public : OrmorokTanglerPredicate ( Unit * unit ) : me ( unit ) { } bool operator ( ) ( WorldObject * object ) const { return object -> GetDistance2d ( me ) >= 5.0f ; } private : Unit * me ; } ; class boss_ormorok : public CreatureScript { public : boss_ormorok ( ) : CreatureScript ( " boss _ ormorok " ) { } struct boss_ormorokAI : public BossAI { boss_ormorokAI ( Creature * creature ) : BossAI ( creature , DATA_ORMOROK ) { Initialize ( ) ; } void Initialize ( ) { frenzy = false ; } void Reset ( ) override { BossAI :: Reset ( ) ; Initialize ( ) ; } void EnterCombat ( Unit * ) override { _EnterCombat ( ) ; events . ScheduleEvent ( EVENT_CRYSTAL_SPIKES , 12000 ) ; events . ScheduleEvent ( EVENT_TRAMPLE , 10000 ) ; events . ScheduleEvent ( EVENT_SPELL_REFLECTION , 30000 ) ; if ( IsHeroic ( ) ) events . ScheduleEvent ( EVENT_CRYSTALLINE_TANGLER , 17000 ) ; Talk ( SAY_AGGRO ) ; } void DamageTaken ( Unit * , uint32 & ) override { if ( ! frenzy && HealthBelowPct ( 25 ) ) { Talk ( SAY_FRENZY ) ; DoCast ( me , SPELL_FRENZY ) ; frenzy = true ; } } void JustDied ( Unit * ) override { _JustDied ( ) ; Talk ( SAY_DEATH ) ; } void KilledUnit ( Unit * who ) override { if ( who -> GetTypeId ( ) == TYPEID_PLAYER ) Talk ( SAY_KILL ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; while ( uint32 eventId = events . ExecuteEvent ( ) ) { switch ( eventId ) { case EVENT_TRAMPLE : DoCast ( me , SPELL_TRAMPLE ) ; events . ScheduleEvent ( EVENT_TRAMPLE , 10000 ) ; break ; case EVENT_SPELL_REFLECTION : Talk ( SAY_REFLECT ) ; DoCast ( me , SPELL_SPELL_REFLECTION ) ; events . ScheduleEvent ( EVENT_SPELL_REFLECTION , 30000 ) ; break ; case EVENT_CRYSTAL_SPIKES : Talk ( SAY_CRYSTAL_SPIKES ) ; DoCast ( SPELL_CRYSTAL_SPIKES ) ; events . ScheduleEvent ( EVENT_CRYSTAL_SPIKES , 12000 ) ; break ; case EVENT_CRYSTALLINE_TANGLER : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , OrmorokTanglerPredicate ( me ) ) ) DoCast ( target , SPELL_SUMMON_CRYSTALLINE_TANGLER ) ; events . ScheduleEvent ( EVENT_CRYSTALLINE_TANGLER , 17000 ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } private : bool frenzy ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetInstanceAI < boss_ormorokAI > ( creature ) ; } } ; enum CrystalSpikes { NPC_CRYSTAL_SPIKE_INITIAL = 27101 , NPC_CRYSTAL_SPIKE_TRIGGER = 27079 , DATA_COUNT = 1 , MAX_COUNT = 5 , SPELL_CRYSTAL_SPIKE_DAMAGE = 47944 , GO_CRYSTAL_SPIKE_TRAP = 188537 , } ; uint32 const crystalSpikeSummon [ 3 ] = { 47936 , 47942 , 47943 } ; class npc_crystal_spike_trigger : public CreatureScript { public : npc_crystal_spike_trigger ( ) : CreatureScript ( " npc _ crystal _ spike _ trigger " ) { } struct npc_crystal_spike_triggerAI : public ScriptedAI { npc_crystal_spike_triggerAI ( Creature * creature ) : ScriptedAI ( creature ) { _count = 0 ; _despawntimer = 0 ; } void IsSummonedBy ( Unit * owner ) override { switch ( me -> GetEntry ( ) ) { case NPC_CRYSTAL_SPIKE_INITIAL : _count = 0 ; me -> SetFacingToObject ( owner ) ; break ; case NPC_CRYSTAL_SPIKE_TRIGGER : if ( Creature * trigger = owner -> ToCreature ( ) ) _count = trigger -> AI ( ) -> GetData ( DATA_COUNT ) + 1 ; break ; default : _count = MAX_COUNT ; break ; } if ( me -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_TRIGGER ) if ( GameObject * trap = me -> FindNearestGameObject ( GO_CRYSTAL_SPIKE_TRAP , 1.0f ) ) trap -> Use ( me ) ; _despawntimer = 2000 ; } uint32 GetData ( uint32 type ) const override { return type == DATA_COUNT ? _count : 0 ; } void UpdateAI ( uint32 diff ) override { if ( _despawntimer <= diff ) { if ( me -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_TRIGGER ) if ( GameObject * trap = me -> FindNearestGameObject ( GO_CRYSTAL_SPIKE_TRAP , 1.0f ) ) trap -> Delete ( ) ; me -> DespawnOrUnsummon ( ) ; } else _despawntimer -= diff ; } private : uint32 _count ; uint32 _despawntimer ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return new npc_crystal_spike_triggerAI ( creature ) ; } } ; class spell_crystal_spike : public SpellScriptLoader { public : spell_crystal_spike ( ) : SpellScriptLoader ( " spell _ crystal _ spike " ) { } class spell_crystal_spike_AuraScript : public AuraScript { PrepareAuraScript ( spell_crystal_spike_AuraScript ) ; void HandlePeriodic ( AuraEffect const * ) { Unit * target = GetTarget ( ) ; if ( target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_INITIAL || target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_TRIGGER ) if ( Creature * trigger = target -> ToCreature ( ) ) { uint32 spell = target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_INITIAL ? crystalSpikeSummon [ 0 ] : crystalSpikeSummon [ urand ( 0 , 2 ) ] ; if ( trigger -> AI ( ) -> GetData ( DATA_COUNT ) < MAX_COUNT ) trigger -> CastSpell ( trigger , spell , true ) ; } } void Register ( ) override { OnEffectPeriodic += AuraEffectPeriodicFn ( spell_crystal_spike_AuraScript :: HandlePeriodic , EFFECT_0 , SPELL_AURA_PERIODIC_DUMMY ) ; } } ; AuraScript * GetAuraScript ( ) const override { return new spell_crystal_spike_AuraScript ( ) ; } } ; void AddSC_boss_ormorok ( ) { new boss_ormorok ( ) ; new npc_crystal_spike_trigger ( ) ; new spell_crystal_spike ( ) ; } </DOCUMENT>
<DOCUMENT_ID="hbwhlklive/color-emoji.skia/tree/master/src/ports/SkGlobalInitialization_chromium.cpp"> # include " SkBitmapProcShader . h " # include " SkBlurImageFilter . h " # include " SkBlurMaskFilter . h " # include " SkColorFilter . h " # include " SkCornerPathEffect . h " # include " SkDashPathEffect . h " # include " SkGradientShader . h " # include " SkLayerDrawLooper . h " # include " SkMallocPixelRef . h " # include " SkXfermode . h " # include " SkMagnifierImageFilter . h " void SkFlattenable :: InitializeFlattenables ( ) { SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkBitmapProcShader ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkBlurImageFilter ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkCornerPathEffect ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkDashPathEffect ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkLayerDrawLooper ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkMallocPixelRef ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkMagnifierImageFilter ) SkBlurMaskFilter :: InitializeFlattenables ( ) ; SkColorFilter :: InitializeFlattenables ( ) ; SkGradientShader :: InitializeFlattenables ( ) ; SkXfermode :: InitializeFlattenables ( ) ; } </DOCUMENT>
<DOCUMENT_ID="krf/kdevelop/tree/master/debuggers/gdb/printers/tests/qmapint.cpp"> # include < QMap > int main ( ) { QMap < int , int > m ; m [ 10 ] = 100 ; m [ 20 ] = 200 ; m [ 30 ] = 300 ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="Residentik/TestingRepo/tree/master/src/server/scripts/EasternKingdoms/BlackrockMountain/BlackrockDepths/boss_high_interrogator_gerstahn.cpp"> # include " ScriptMgr . h " # include " ScriptedCreature . h " enum Spells { SPELL_SHADOWWORDPAIN = 10894 , SPELL_MANABURN = 10876 , SPELL_PSYCHICSCREAM = 8122 , SPELL_SHADOWSHIELD = 22417 } ; class boss_high_interrogator_gerstahn : public CreatureScript { public : boss_high_interrogator_gerstahn ( ) : CreatureScript ( " boss _ high _ interrogator _ gerstahn " ) { } CreatureAI * GetAI ( Creature * creature ) const OVERRIDE { return new boss_high_interrogator_gerstahnAI ( creature ) ; } struct boss_high_interrogator_gerstahnAI : public ScriptedAI { boss_high_interrogator_gerstahnAI ( Creature * creature ) : ScriptedAI ( creature ) { } uint32 ShadowWordPain_Timer ; uint32 ManaBurn_Timer ; uint32 PsychicScream_Timer ; uint32 ShadowShield_Timer ; void Reset ( ) OVERRIDE { ShadowWordPain_Timer = 4000 ; ManaBurn_Timer = 14000 ; PsychicScream_Timer = 32000 ; ShadowShield_Timer = 8000 ; } void EnterCombat ( Unit * ) OVERRIDE { } void UpdateAI ( uint32 diff ) OVERRIDE { if ( ! UpdateVictim ( ) ) return ; if ( ShadowWordPain_Timer <= diff ) { if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 100 , true ) ) DoCast ( target , SPELL_SHADOWWORDPAIN ) ; ShadowWordPain_Timer = 7000 ; } else ShadowWordPain_Timer -= diff ; if ( ManaBurn_Timer <= diff ) { if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 100 , true ) ) DoCast ( target , SPELL_MANABURN ) ; ManaBurn_Timer = 10000 ; } else ManaBurn_Timer -= diff ; if ( PsychicScream_Timer <= diff ) { DoCastVictim ( SPELL_PSYCHICSCREAM ) ; PsychicScream_Timer = 30000 ; } else PsychicScream_Timer -= diff ; if ( ShadowShield_Timer <= diff ) { DoCast ( me , SPELL_SHADOWSHIELD ) ; ShadowShield_Timer = 25000 ; } else ShadowShield_Timer -= diff ; DoMeleeAttackIfReady ( ) ; } } ; } ; void AddSC_boss_high_interrogator_gerstahn ( ) { new boss_high_interrogator_gerstahn ( ) ; } </DOCUMENT>
<DOCUMENT_ID="root-mirror/root/tree/master/interpreter/llvm/src/tools/llvm-pdbutil/PrettyExternalSymbolDumper.cpp"> # include " PrettyExternalSymbolDumper . h " # include " LinePrinter . h " # include " llvm / DebugInfo / PDB / PDBSymbolExe . h " # include " llvm / DebugInfo / PDB / PDBSymbolPublicSymbol . h " # include " llvm / Support / Format . h " using namespace llvm ; using namespace llvm :: pdb ; ExternalSymbolDumper :: ExternalSymbolDumper ( LinePrinter & P ) : PDBSymDumper ( true ) , Printer ( P ) { } void ExternalSymbolDumper :: start ( const PDBSymbolExe & Symbol ) { auto Vars = Symbol . findAllChildren < PDBSymbolPublicSymbol > ( ) ; while ( auto Var = Vars -> getNext ( ) ) Var -> dump ( * this ) ; } void ExternalSymbolDumper :: dump ( const PDBSymbolPublicSymbol & Symbol ) { std :: string LinkageName = Symbol . getName ( ) ; if ( Printer . IsSymbolExcluded ( LinkageName ) ) return ; Printer . NewLine ( ) ; uint64_t Addr = Symbol . getVirtualAddress ( ) ; Printer << " [ " ; WithColor ( Printer , PDB_ColorItem :: Address ) . get ( ) << format_hex ( Addr , 10 ) ; Printer << " ] ▁ " ; WithColor ( Printer , PDB_ColorItem :: Identifier ) . get ( ) << LinkageName ; } </DOCUMENT>
<DOCUMENT_ID="eriser/Obxd/tree/master/JuceLibraryCode/modules/juce_box2d/box2d/Common/b2StackAllocator.cpp"> # include " b2StackAllocator . h " # include " b2Math . h " b2StackAllocator :: b2StackAllocator ( ) { m_index = 0 ; m_allocation = 0 ; m_maxAllocation = 0 ; m_entryCount = 0 ; } b2StackAllocator :: ~ b2StackAllocator ( ) { b2Assert ( m_index == 0 ) ; b2Assert ( m_entryCount == 0 ) ; } void * b2StackAllocator :: Allocate ( int32 size ) { b2Assert ( m_entryCount < b2_maxStackEntries ) ; b2StackEntry * entry = m_entries + m_entryCount ; entry -> size = size ; if ( m_index + size > b2_stackSize ) { entry -> data = ( char * ) b2Alloc ( size ) ; entry -> usedMalloc = true ; } else { entry -> data = m_data + m_index ; entry -> usedMalloc = false ; m_index += size ; } m_allocation += size ; m_maxAllocation = b2Max ( m_maxAllocation , m_allocation ) ; ++ m_entryCount ; return entry -> data ; } void b2StackAllocator :: Free ( void * p ) { b2Assert ( m_entryCount > 0 ) ; b2StackEntry * entry = m_entries + m_entryCount - 1 ; b2Assert ( p == entry -> data ) ; if ( entry -> usedMalloc ) { b2Free ( p ) ; } else { m_index -= entry -> size ; } m_allocation -= entry -> size ; -- m_entryCount ; p = NULL ; } int32 b2StackAllocator :: GetMaxAllocation ( ) const { return m_maxAllocation ; } </DOCUMENT>
<DOCUMENT_ID="murraymeehan/marsyas/tree/master/src/otherlibs/ANN/kd_pr_search.cpp"> # include " kd _ pr _ search . h " double ANNprEps ; int ANNprDim ; ANNpoint ANNprQ ; double ANNprMaxErr ; ANNpointArray ANNprPts ; ANNpr_queue * ANNprBoxPQ ; ANNmin_k * ANNprPointMK ; void ANNkd_tree :: annkPriSearch ( ANNpoint q , int k , ANNidxArray nn_idx , ANNdistArray dd , double eps ) { ANNprMaxErr = ANN_POW ( 1.0 + eps ) ; ANN_FLOP ( 2 ) ANNprDim = dim ; ANNprQ = q ; ANNprPts = pts ; ANNptsVisited = 0 ; ANNprPointMK = new ANNmin_k ( k ) ; ANNdist box_dist = annBoxDistance ( q , bnd_box_lo , bnd_box_hi , dim ) ; ANNprBoxPQ = new ANNpr_queue ( n_pts ) ; ANNprBoxPQ -> insert ( box_dist , root ) ; while ( ANNprBoxPQ -> non_empty ( ) && ( ! ( ANNmaxPtsVisited != 0 && ANNptsVisited > ANNmaxPtsVisited ) ) ) { ANNkd_ptr np ; ANNprBoxPQ -> extr_min ( box_dist , ( void * & ) np ) ; ANN_FLOP ( 2 ) if ( box_dist * ANNprMaxErr >= ANNprPointMK -> max_key ( ) ) break ; np -> ann_pri_search ( box_dist ) ; } for ( int i = 0 ; i < k ; i ++ ) { dd [ i ] = ANNprPointMK -> ith_smallest_key ( i ) ; nn_idx [ i ] = ANNprPointMK -> ith_smallest_info ( i ) ; } delete ANNprPointMK ; delete ANNprBoxPQ ; } void ANNkd_split :: ann_pri_search ( ANNdist box_dist ) { ANNdist new_dist ; ANNcoord cut_diff = ANNprQ [ cut_dim ] - cut_val ; if ( cut_diff < 0 ) { ANNcoord box_diff = cd_bnds [ ANN_LO ] - ANNprQ [ cut_dim ] ; if ( box_diff < 0 ) box_diff = 0 ; new_dist = ( ANNdist ) ANN_SUM ( box_dist , ANN_DIFF ( ANN_POW ( box_diff ) , ANN_POW ( cut_diff ) ) ) ; if ( child [ ANN_HI ] != KD_TRIVIAL ) ANNprBoxPQ -> insert ( new_dist , child [ ANN_HI ] ) ; child [ ANN_LO ] -> ann_pri_search ( box_dist ) ; } else { ANNcoord box_diff = ANNprQ [ cut_dim ] - cd_bnds [ ANN_HI ] ; if ( box_diff < 0 ) box_diff = 0 ; new_dist = ( ANNdist ) ANN_SUM ( box_dist , ANN_DIFF ( ANN_POW ( box_diff ) , ANN_POW ( cut_diff ) ) ) ; if ( child [ ANN_LO ] != KD_TRIVIAL ) ANNprBoxPQ -> insert ( new_dist , child [ ANN_LO ] ) ; child [ ANN_HI ] -> ann_pri_search ( box_dist ) ; } ANN_SPL ( 1 ) ANN_FLOP ( 8 ) } void ANNkd_leaf :: ann_pri_search ( ANNdist box_dist ) { register ANNdist dist ; register ANNcoord * pp ; register ANNcoord * qq ; register ANNdist min_dist ; register ANNcoord t ; register int d ; min_dist = ANNprPointMK -> max_key ( ) ; for ( int i = 0 ; i < n_pts ; i ++ ) { pp = ANNprPts [ bkt [ i ] ] ; qq = ANNprQ ; dist = 0 ; for ( d = 0 ; d < ANNprDim ; d ++ ) { ANN_COORD ( 1 ) ANN_FLOP ( 4 ) t = * ( qq ++ ) - * ( pp ++ ) ; if ( ( dist = ANN_SUM ( dist , ANN_POW ( t ) ) ) > min_dist ) { break ; } } if ( d >= ANNprDim && ( ANN_ALLOW_SELF_MATCH || dist != 0 ) ) { ANNprPointMK -> insert ( dist , bkt [ i ] ) ; min_dist = ANNprPointMK -> max_key ( ) ; } } ANN_LEAF ( 1 ) ANN_PTS ( n_pts ) ANNptsVisited += n_pts ; } </DOCUMENT>
<DOCUMENT_ID="attackjz/Cocos2d-x_CustomSliderList/tree/master/CustomSliderList/cocos2d/cocos/platform/winrt/CCFreeTypeFont.cpp"> # include " CCFreeTypeFont . h " # include " base / CCDirector . h " # include " platform / CCFileUtils . h " # if ( CC_TARGET_PLATFORM != CC_PLATFORM_WP8 ) # include < dwrite . h > # endif # include < map > # include < string > # include < sstream > # include < vector > # include < memory > # include < algorithm > using namespace std ; NS_CC_BEGIN static map < std :: string , FontBufferInfo > s_fontsNames ; static FT_Library s_FreeTypeLibrary = nullptr ; CCFreeTypeFont :: CCFreeTypeFont ( ) : m_space ( " ▁ " ) , m_face ( nullptr ) { } CCFreeTypeFont :: ~ CCFreeTypeFont ( ) { reset ( ) ; } void CCFreeTypeFont :: reset ( ) { for ( auto line : m_lines ) { line -> glyphs . clear ( ) ; delete line ; } m_lines . clear ( ) ; if ( m_face ) { FT_Done_Face ( m_face ) ; m_face = nullptr ; } } unsigned char * CCFreeTypeFont :: initWithString ( const char * text , const FontDefinition & textDefinition , Device :: TextAlign align , int & width , int & height , ssize_t & dataLength ) { FT_Error error = 0 ; ssize_t size = 0 ; unsigned char * pBuffer = nullptr ; unsigned char * data = nullptr ; Size winSize = Director :: getInstance ( ) -> getWinSizeInPixels ( ) ; m_windowWidth = ( int ) winSize . width ; m_inWidth = textDefinition . _dimensions . width ; m_inHeight = textDefinition . _dimensions . height ; m_fontFillColorR = textDefinition . _fontFillColor . r ; m_fontFillColorG = textDefinition . _fontFillColor . g ; m_fontFillColorB = textDefinition . _fontFillColor . b ; # if 0 auto ittFontNames = s_fontsNames . find ( textDefinition . _fontName ) ; if ( ittFontNames != s_fontsNames . end ( ) ) { pBuffer = ittFontNames -> second . pBuffer ; size = ittFontNames -> second . size ; } # endif if ( ! pBuffer ) { pBuffer = loadFont ( textDefinition . _fontName . c_str ( ) , & size ) ; if ( ! pBuffer ) { pBuffer = loadSystemFont ( textDefinition . _fontName . c_str ( ) , & size ) ; } if ( ! pBuffer ) { pBuffer = loadFont ( " Arial " , & size ) ; } if ( ! pBuffer ) { pBuffer = loadSystemFont ( " Arial " , & size ) ; } if ( ! pBuffer ) { return false ; } # if 0 FontBufferInfo info ; info . pBuffer = pBuffer ; info . size = size ; s_fontsNames [ textDefinition . _fontName ] = info ; # endif } m_fontName = textDefinition . _fontName ; m_text = text ; if ( ! s_FreeTypeLibrary ) { error = FT_Init_FreeType ( & s_FreeTypeLibrary ) ; } if ( ! error && ! m_face ) { error = FT_New_Memory_Face ( s_FreeTypeLibrary , pBuffer , size , 0 , & m_face ) ; } if ( ! error ) { error = FT_Select_Charmap ( m_face , FT_ENCODING_UNICODE ) ; } if ( ! error ) { error = FT_Set_Char_Size ( m_face , textDefinition . _fontSize << 6 , textDefinition . _fontSize << 6 , 72 , 72 ) ; } if ( ! error ) { error = initGlyphs ( text ) ; } if ( ! error ) { data = getBitmap ( align , width , height , dataLength ) ; } delete [ ] pBuffer ; reset ( ) ; return data ; } unsigned char * CCFreeTypeFont :: getBitmap ( Device :: TextAlign eAlignMask , int & width , int & height , ssize_t & dataLength ) { int lineNumber = 0 ; int totalLines = m_lines . size ( ) ; m_width = m_inWidth ? m_inWidth : m_textWidth ; m_height = m_inHeight ? m_inHeight : m_textHeight ; unsigned int size = m_width * m_height * 4 ; unsigned char * pBuffer = new unsigned char [ size ] ; dataLength = size ; if ( ! pBuffer ) { dataLength = 0 ; return nullptr ; } memset ( pBuffer , 0 , size ) ; for ( auto line = m_lines . begin ( ) ; line != m_lines . end ( ) ; ++ line ) { FT_Vector pen = getPenForAlignment ( * line , eAlignMask , lineNumber , totalLines ) ; drawText ( * line , pBuffer , & pen ) ; lineNumber ++ ; } width = m_width ; height = m_height ; return pBuffer ; } FT_Vector CCFreeTypeFont :: getPenForAlignment ( FTLineInfo * pInfo , Device :: TextAlign eAlignMask , int lineNumber , int totalLines ) { FT_Error error = 0 ; FT_Vector pen ; int top ; int stringWidth = pInfo -> bbox . xMax - pInfo -> bbox . xMin ; int maxLineNumber = totalLines - 1 ; pen . x = 0 ; pen . y = 0 ; switch ( eAlignMask ) { case Device :: TextAlign :: TOP : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: TOP_LEFT : pen . x -= pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: TOP_RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM_RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM_LEFT : pen . x -= pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: CENTER : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; case Device :: TextAlign :: RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; case Device :: TextAlign :: LEFT : default : pen . x -= pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; } return pen ; } void CCFreeTypeFont :: drawText ( FTLineInfo * pInfo , unsigned char * pBuffer , FT_Vector * pen ) { auto glyphs = pInfo -> glyphs ; for ( auto glyph = glyphs . begin ( ) ; glyph != glyphs . end ( ) ; ++ glyph ) { FT_Glyph image = glyph -> image ; FT_Error error = FT_Glyph_To_Bitmap ( & image , FT_RENDER_MODE_NORMAL , 0 , 1 ) ; if ( ! error ) { FT_BitmapGlyph bit = ( FT_BitmapGlyph ) image ; draw_bitmap ( pBuffer , & bit -> bitmap , pen -> x + glyph -> pos . x + bit -> left , pen -> y - bit -> top ) ; FT_Done_Glyph ( image ) ; } } } void CCFreeTypeFont :: draw_bitmap ( unsigned char * pBuffer , FT_Bitmap * bitmap , FT_Int x , FT_Int y ) { FT_Int i , j , p , q ; FT_Int x_max = x + bitmap -> width ; FT_Int y_max = y + bitmap -> rows ; for ( i = x , p = 0 ; i < x_max ; i ++ , p ++ ) { for ( j = y , q = 0 ; j < y_max ; j ++ , q ++ ) { if ( i < 0 || j < 0 || i >= m_width || j >= m_height ) continue ; unsigned char value = bitmap -> buffer [ q * bitmap -> width + p ] ; if ( value > 0 ) { FT_Int index = ( j * m_width * 4 ) + ( i * 4 ) ; pBuffer [ index ++ ] = m_fontFillColorR ; pBuffer [ index ++ ] = m_fontFillColorG ; pBuffer [ index ++ ] = m_fontFillColorB ; pBuffer [ index ++ ] = value ; } } } } void CCFreeTypeFont :: endLine ( ) { if ( m_currentLine ) { m_lines . push_back ( m_currentLine ) ; m_textWidth = std :: max ( ( long ) m_textWidth , m_currentLine -> bbox . xMax - m_currentLine -> bbox . xMin ) ; m_textHeight += m_lineHeight ; } } void CCFreeTypeFont :: newLine ( ) { m_currentLine = new FTLineInfo ( ) ; m_currentLine -> width = 0 ; m_currentLine -> pen . x = 0 ; m_currentLine -> pen . y = 0 ; } FT_Error CCFreeTypeFont :: addWord ( const std :: string & word ) { std :: vector < TGlyph > glyphs ; FT_BBox bbox ; int maxWidth = m_inWidth ? m_inWidth : m_windowWidth ; std :: string newWord ; if ( m_currentLine -> width > 0 ) { newWord = ' ▁ ' + word ; } else { newWord = word ; } FT_Error error = initWordGlyphs ( glyphs , newWord , m_currentLine -> pen ) ; if ( ! error ) { compute_bbox ( glyphs , & bbox ) ; if ( m_currentLine -> width == 0 || bbox . xMax <= maxWidth ) { m_currentLine -> glyphs . insert ( m_currentLine -> glyphs . end ( ) , glyphs . begin ( ) , glyphs . end ( ) ) ; if ( m_currentLine -> width == 0 ) { m_currentLine -> bbox = bbox ; } else { m_currentLine -> bbox . xMax = bbox . xMax ; } m_currentLine -> width = m_currentLine -> bbox . xMax - m_currentLine -> bbox . xMin ; } else { endLine ( ) ; newLine ( ) ; addWord ( word ) ; } } return error ; } FT_Error CCFreeTypeFont :: initGlyphs ( const char * text ) { FT_Error error = 0 ; std :: stringstream stringStream ( text ) ; std :: string line ; vector < std :: string > lines ; vector < std :: string > words ; m_textWidth = 0 ; m_textHeight = 0 ; m_lineHeight = ( ( m_face -> size -> metrics . ascender ) >> 6 ) - ( ( m_face -> size -> metrics . descender ) >> 6 ) ; m_lines . clear ( ) ; while ( std :: getline ( stringStream , line ) && ! error ) { newLine ( ) ; std :: size_t prev = 0 , pos ; while ( ( pos = line . find_first_of ( " ▁ " , prev ) ) != std :: string :: npos ) { if ( pos > prev ) { addWord ( line . substr ( prev , pos - prev ) ) ; } prev = pos + 1 ; } if ( prev < line . length ( ) ) { addWord ( line . substr ( prev , std :: string :: npos ) ) ; } endLine ( ) ; } return error ; } void CCFreeTypeFont :: initWords ( const char * text ) { std :: stringstream stringStream ( text ) ; std :: string line ; vector < std :: string > lines ; vector < std :: string > words ; while ( std :: getline ( stringStream , line ) ) { lines . push_back ( line ) ; } for ( auto it = lines . begin ( ) ; it != lines . end ( ) ; ++ it ) { std :: size_t prev = 0 , pos ; while ( ( pos = it -> find_first_of ( " ▁ ' ; " , prev ) ) != std :: string :: npos ) { if ( pos > prev ) words . push_back ( it -> substr ( prev , pos - prev ) ) ; prev = pos + 1 ; } if ( prev < it -> length ( ) ) words . push_back ( it -> substr ( prev , std :: string :: npos ) ) ; } for ( auto it = words . begin ( ) ; it != words . end ( ) ; ++ it ) { std :: string foo ( * it ) ; } } FT_Error CCFreeTypeFont :: initWordGlyphs ( std :: vector < TGlyph > & glyphs , const std :: string & text , FT_Vector & pen ) { FT_GlyphSlot slot = m_face -> glyph ; FT_UInt glyph_index ; FT_UInt previous = 0 ; FT_Error error = 0 ; PGlyph glyph ; unsigned int numGlyphs = 0 ; wchar_t * pwszBuffer = nullptr ; int num_chars = text . size ( ) ; int nBufLen = num_chars + 1 ; pwszBuffer = new wchar_t [ nBufLen ] ; if ( ! pwszBuffer ) { return - 1 ; } memset ( pwszBuffer , 0 , nBufLen ) ; num_chars = MultiByteToWideChar ( CP_UTF8 , 0 , text . c_str ( ) , num_chars , pwszBuffer , nBufLen ) ; pwszBuffer [ num_chars ] = ' \0' ; glyphs . clear ( ) ; glyphs . resize ( num_chars ) ; FT_Bool useKerning = FT_HAS_KERNING ( m_face ) ; for ( int n = 0 ; n < num_chars ; n ++ ) { glyph = & glyphs [ numGlyphs ] ; FT_ULong c = pwszBuffer [ n ] ; glyph_index = FT_Get_Char_Index ( m_face , c ) ; if ( useKerning && previous && glyph_index ) { FT_Vector delta ; FT_Get_Kerning ( m_face , previous , glyph_index , FT_KERNING_DEFAULT , & delta ) ; pen . x += delta . x >> 6 ; } glyph -> pos = pen ; glyph -> index = glyph_index ; error = FT_Load_Glyph ( m_face , glyph_index , FT_LOAD_DEFAULT ) ; if ( error ) continue ; error = FT_Get_Glyph ( m_face -> glyph , & glyph -> image ) ; if ( error ) continue ; FT_Glyph_Transform ( glyph -> image , 0 , & glyph -> pos ) ; pen . x += slot -> advance . x >> 6 ; previous = glyph_index ; numGlyphs ++ ; } CC_SAFE_DELETE_ARRAY ( pwszBuffer ) ; return error ; } void CCFreeTypeFont :: compute_bbox ( std :: vector < TGlyph > & glyphs , FT_BBox * abbox ) { FT_BBox bbox ; FT_BBox glyph_bbox ; bbox . xMin = 32000 ; bbox . xMax = - 32000 ; bbox . yMin = ( m_face -> size -> metrics . descender ) >> 6 ; bbox . yMax = ( m_face -> size -> metrics . ascender ) >> 6 ; for ( auto glyph = glyphs . begin ( ) ; glyph != glyphs . end ( ) ; ++ glyph ) { FT_Glyph_Get_CBox ( glyph -> image , ft_glyph_bbox_pixels , & glyph_bbox ) ; glyph_bbox . xMin += glyph -> pos . x ; glyph_bbox . xMax += glyph -> pos . x ; glyph_bbox . yMin += glyph -> pos . y ; glyph_bbox . yMax += glyph -> pos . y ; if ( glyph_bbox . xMin < bbox . xMin ) bbox . xMin = glyph_bbox . xMin ; if ( glyph_bbox . yMin < bbox . yMin ) bbox . yMin = glyph_bbox . yMin ; if ( glyph_bbox . xMax > bbox . xMax ) bbox . xMax = glyph_bbox . xMax ; if ( glyph_bbox . yMax > bbox . yMax ) bbox . yMax = glyph_bbox . yMax ; } if ( bbox . xMin > bbox . xMax ) { bbox . xMin = 0 ; bbox . yMin = 0 ; bbox . xMax = 0 ; bbox . yMax = 0 ; } * abbox = bbox ; } unsigned char * CCFreeTypeFont :: loadFont ( const char * pFontName , ssize_t * size ) { std :: string lowerCase ( pFontName ) ; std :: string path ( pFontName ) ; for ( unsigned int i = 0 ; i < lowerCase . length ( ) ; ++ i ) { lowerCase [ i ] = tolower ( lowerCase [ i ] ) ; } if ( std :: string :: npos == lowerCase . find ( " fonts / " ) ) { path = " fonts / " ; path += pFontName ; } if ( std :: string :: npos == lowerCase . find ( " . ttf " ) ) { path += " . ttf " ; } std :: string fullpath = FileUtils :: getInstance ( ) -> fullPathForFilename ( path . c_str ( ) ) ; return FileUtils :: sharedFileUtils ( ) -> getFileData ( fullpath . c_str ( ) , " rb " , size ) ; } unsigned char * CCFreeTypeFont :: loadSystemFont ( const char * pFontName , ssize_t * size ) { # if ( CC_TARGET_PLATFORM == CC_PLATFORM_WP8 ) return nullptr ; # else std :: string aName ( pFontName ) ; unsigned char * pBuffer = nullptr ; HRESULT hr = S_OK ; IDWriteFactory * writeFactory = nullptr ; IDWriteFontCollection * fontCollection = nullptr ; IDWriteFontFamily * fontFamily = nullptr ; IDWriteFont * matchingFont = nullptr ; IDWriteFontFace * fontFace = nullptr ; IDWriteFontFile * fontFile = nullptr ; IDWriteFontFileLoader * fontFileLoader = nullptr ; IDWriteFontFileStream * fontFileStream = nullptr ; UINT32 index ; BOOL exists ; std :: wstring fontNameW ; const void * fontFileReferenceKey = nullptr ; UINT32 fontFileReferenceKeySize ; void * fragmentContext = nullptr ; for ( unsigned int i = 0 ; i < aName . length ( ) ; ++ i ) { aName [ i ] = tolower ( aName [ i ] ) ; } fontNameW . assign ( aName . begin ( ) , aName . end ( ) ) ; hr = DWriteCreateFactory ( DWRITE_FACTORY_TYPE_SHARED , __uuidof ( IDWriteFactory ) , reinterpret_cast < IUnknown * * > ( & writeFactory ) ) ; if ( SUCCEEDED ( hr ) ) { hr = writeFactory -> GetSystemFontCollection ( & fontCollection , TRUE ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontCollection -> FindFamilyName ( fontNameW . c_str ( ) , & index , & exists ) ; if ( SUCCEEDED ( hr ) && exists ) { hr = fontCollection -> GetFontFamily ( index , & fontFamily ) ; if ( SUCCEEDED ( hr ) ) { hr = fontFamily -> GetFirstMatchingFont ( DWRITE_FONT_WEIGHT_REGULAR , DWRITE_FONT_STRETCH_NORMAL , DWRITE_FONT_STYLE_NORMAL , & matchingFont ) ; } if ( SUCCEEDED ( hr ) ) { hr = matchingFont -> CreateFontFace ( & fontFace ) ; } if ( SUCCEEDED ( hr ) ) { UINT32 numberOfFiles = 1 ; hr = fontFace -> GetFiles ( & numberOfFiles , & fontFile ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFile -> GetReferenceKey ( & fontFileReferenceKey , & fontFileReferenceKeySize ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFile -> GetLoader ( & fontFileLoader ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFileLoader -> CreateStreamFromKey ( fontFileReferenceKey , fontFileReferenceKeySize , & fontFileStream ) ; } if ( SUCCEEDED ( hr ) ) { UINT64 fileSize ; const void * fragmentStart = nullptr ; hr = fontFileStream -> GetFileSize ( & fileSize ) ; if ( SUCCEEDED ( hr ) ) { hr = fontFileStream -> ReadFileFragment ( & fragmentStart , 0 , fileSize , & fragmentContext ) ; } if ( SUCCEEDED ( hr ) ) { pBuffer = ( unsigned char * ) malloc ( ( size_t ) fileSize ) ; memcpy ( pBuffer , fragmentStart , ( size_t ) fileSize ) ; * size = ( unsigned long ) fileSize ; } } } } if ( fontFileStream ) { fontFileStream -> ReleaseFileFragment ( fragmentContext ) ; fontFileStream -> Release ( ) ; } if ( fontFileLoader ) { fontFileLoader -> Release ( ) ; } if ( fontFile ) { fontFile -> Release ( ) ; } if ( fontFace ) { fontFace -> Release ( ) ; } if ( matchingFont ) { matchingFont -> Release ( ) ; } if ( fontFamily ) { fontFamily -> Release ( ) ; } if ( fontCollection ) { fontCollection -> Release ( ) ; } if ( writeFactory ) { writeFactory -> Release ( ) ; } return pBuffer ; # endif } NS_CC_END </DOCUMENT>
<DOCUMENT_ID="ericzhou2008/WinObjC/tree/master/deps/3rdparty/iculegacy/source/common/parsepos.cpp"> # include " unicode / parsepos . h " U_NAMESPACE_BEGIN UOBJECT_DEFINE_RTTI_IMPLEMENTATION ( ParsePosition ) ParsePosition :: ~ ParsePosition ( ) { } ParsePosition * ParsePosition :: clone ( ) const { return new ParsePosition ( * this ) ; } U_NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="OpenDSA/OpenDSA-stable/tree/master/SourceCode/C++/Sorting/Heapsort.cpp"> # include " Maxheap . cpp " void heapsort ( Comparable * A [ ] , int n ) { std :: cout << " Getting ▁ started ▁ with ▁ array : " << std :: endl ; for ( int j = 0 ; j < n ; j ++ ) std :: cout << * A [ j ] << " ▁ " ; std :: cout << std :: endl ; MaxHeap H ( A , n , n ) ; std :: cout << " Now , ▁ ready ▁ to ▁ unpack ▁ the ▁ heap " << std :: endl ; for ( int i = 0 ; i < n ; i ++ ) H . removemax ( ) ; } bool sorttest ( int array [ ] , int n , int threshold ) { Comparable * A [ n ] ; int i ; cout << " We ▁ came ▁ in ▁ with ▁ array : " << endl ; for ( i = 0 ; i < n ; i ++ ) std :: cout << array [ i ] << " ▁ " ; std :: cout << std :: endl ; for ( i = 0 ; i < n ; ++ i ) { A [ i ] = new Int ( array [ i ] ) ; } cout << " We ▁ are ▁ going ▁ to ▁ call ▁ Heapsort ▁ with ▁ this ▁ array : " << endl ; for ( i = 0 ; i < n ; i ++ ) std :: cout << A [ i ] << " ▁ " ; std :: cout << std :: endl ; heapsort ( A , n ) ; if ( ! checkorder ( A , n ) ) return false ; for ( i = 0 ; i < n ; ++ i ) { delete A [ i ] ; } for ( i = 0 ; i < n ; ++ i ) { A [ i ] = new KVPair ( array [ i ] , & array [ i ] ) ; } if ( ! checkorder ( A , n ) ) return false ; for ( i = 0 ; i < n ; ++ i ) { delete A [ i ] ; } delete [ ] array ; return true ; } # include " SortTest . cpp " </DOCUMENT>
<DOCUMENT_ID="basic60/ARCUS/tree/master/source/kernel/interruption/idt.cpp"> # include " types . h " # include " idt . h " # include " string . h " # include " print _ charmode . h " # include " port . h " # include " keyboard . h " idtEntry idtEntries [ 256 ] ; interruptHandler_t interruptHandler [ 256 ] ; idtPtr iptr ; extern " C " void idtFlush ( uint64 addr ) ; void initIDT ( ) { memset ( ( uint8 * ) idtEntries , 0 , sizeof ( idtEntries ) ) ; iptr . limit = sizeof ( idtEntries ) - 1 ; iptr . base = ( uint64 ) & idtEntries ; writePort ( 0x20 , 0x11 ) ; writePort ( 0xA0 , 0x11 ) ; writePort ( 0x21 , 0x20 ) ; writePort ( 0xA1 , 0x28 ) ; writePort ( 0x21 , 0x01 ) ; writePort ( 0xA1 , 0x01 ) ; writePort ( 0x21 , 0x00 ) ; writePort ( 0xA1 , 0x00 ) ; idtSetEntity ( 0 , ( uint64 ) isr0 , 0x08 , 0x8E ) ; idtSetEntity ( 1 , ( uint64 ) isr1 , 0x08 , 0x8E ) ; idtSetEntity ( 2 , ( uint64 ) isr2 , 0x08 , 0x8E ) ; idtSetEntity ( 3 , ( uint64 ) isr3 , 0x08 , 0x8E ) ; idtSetEntity ( 4 , ( uint64 ) isr4 , 0x08 , 0x8E ) ; idtSetEntity ( 5 , ( uint64 ) isr5 , 0x08 , 0x8E ) ; idtSetEntity ( 6 , ( uint64 ) isr6 , 0x08 , 0x8E ) ; idtSetEntity ( 7 , ( uint64 ) isr7 , 0x08 , 0x8E ) ; idtSetEntity ( 8 , ( uint64 ) isr8 , 0x08 , 0x8E ) ; idtSetEntity ( 9 , ( uint64 ) isr9 , 0x08 , 0x8E ) ; idtSetEntity ( 10 , ( uint64 ) isr10 , 0x08 , 0x8E ) ; idtSetEntity ( 11 , ( uint64 ) isr11 , 0x08 , 0x8E ) ; idtSetEntity ( 12 , ( uint64 ) isr12 , 0x08 , 0x8E ) ; idtSetEntity ( 13 , ( uint64 ) isr13 , 0x08 , 0x8E ) ; idtSetEntity ( 14 , ( uint64 ) isr14 , 0x08 , 0x8E ) ; idtSetEntity ( 15 , ( uint64 ) isr15 , 0x08 , 0x8E ) ; idtSetEntity ( 16 , ( uint64 ) isr16 , 0x08 , 0x8E ) ; idtSetEntity ( 17 , ( uint64 ) isr17 , 0x08 , 0x8E ) ; idtSetEntity ( 18 , ( uint64 ) isr18 , 0x08 , 0x8E ) ; idtSetEntity ( 19 , ( uint64 ) isr19 , 0x08 , 0x8E ) ; idtSetEntity ( 20 , ( uint64 ) isr20 , 0x08 , 0x8E ) ; idtSetEntity ( 21 , ( uint64 ) isr21 , 0x08 , 0x8E ) ; idtSetEntity ( 22 , ( uint64 ) isr22 , 0x08 , 0x8E ) ; idtSetEntity ( 23 , ( uint64 ) isr23 , 0x08 , 0x8E ) ; idtSetEntity ( 24 , ( uint64 ) isr24 , 0x08 , 0x8E ) ; idtSetEntity ( 25 , ( uint64 ) isr25 , 0x08 , 0x8E ) ; idtSetEntity ( 26 , ( uint64 ) isr26 , 0x08 , 0x8E ) ; idtSetEntity ( 27 , ( uint64 ) isr27 , 0x08 , 0x8E ) ; idtSetEntity ( 28 , ( uint64 ) isr27 , 0x08 , 0x8E ) ; idtSetEntity ( 29 , ( uint64 ) isr29 , 0x08 , 0x8E ) ; idtSetEntity ( 30 , ( uint64 ) isr30 , 0x08 , 0x8E ) ; idtSetEntity ( 31 , ( uint64 ) isr31 , 0x08 , 0x8E ) ; idtSetEntity ( 32 , ( uint64 ) irq0 , 0x08 , 0x8E ) ; idtSetEntity ( 33 , ( uint64 ) irq1 , 0x08 , 0x8E ) ; idtSetEntity ( 34 , ( uint64 ) irq2 , 0x08 , 0x8E ) ; idtSetEntity ( 35 , ( uint64 ) irq3 , 0x08 , 0x8E ) ; idtSetEntity ( 36 , ( uint64 ) irq4 , 0x08 , 0x8E ) ; idtSetEntity ( 37 , ( uint64 ) irq5 , 0x08 , 0x8E ) ; idtSetEntity ( 38 , ( uint64 ) irq6 , 0x08 , 0x8E ) ; idtSetEntity ( 39 , ( uint64 ) irq7 , 0x08 , 0x8E ) ; idtSetEntity ( 40 , ( uint64 ) irq8 , 0x08 , 0x8E ) ; idtSetEntity ( 41 , ( uint64 ) irq9 , 0x08 , 0x8E ) ; idtSetEntity ( 42 , ( uint64 ) irq10 , 0x08 , 0x8E ) ; idtSetEntity ( 43 , ( uint64 ) irq11 , 0x08 , 0x8E ) ; idtSetEntity ( 44 , ( uint64 ) irq12 , 0x08 , 0x8E ) ; idtSetEntity ( 45 , ( uint64 ) irq13 , 0x08 , 0x8E ) ; idtSetEntity ( 46 , ( uint64 ) irq14 , 0x08 , 0x8E ) ; idtSetEntity ( 47 , ( uint64 ) irq15 , 0x08 , 0x8E ) ; idtFlush ( ( uint64 ) & iptr ) ; printStr ( " Initializing ▁ interruption ▁ finished . \n " , color_white ) ; } void isrHandler ( ptRegs * regs ) { if ( interruptHandler [ regs -> intNum ] ) interruptHandler [ regs -> intNum ] ( regs ) ; else { } } void irqHandler ( ptRegs * regs ) { if ( regs -> intNum > 40 ) { writePort ( 0xA0 , 0x20 ) ; } writePort ( 0x20 , 0x20 ) ; if ( interruptHandler [ regs -> intNum ] ) { interruptHandler [ regs -> intNum ] ( regs ) ; } } void registerInterruptHandler ( uint8 n , interruptHandler_t h ) { interruptHandler [ n ] = h ; } void idtSetEntity ( uint8 num , uint64 base , uint16 selector , uint8 flags ) { idtEntries [ num ] . offset1 = base & 0xffff ; idtEntries [ num ] . offset2 = ( base >> 16 ) & 0xffff ; idtEntries [ num ] . offset3 = ( base >> 32 ) & 0xffffffff ; idtEntries [ num ] . selector = selector ; idtEntries [ num ] . typeAttr = flags ; } </DOCUMENT>
<DOCUMENT_ID="deadcoda/arg3db/tree/master/src/sqlite/resultset.cpp"> # include " resultset . h " # include " . . / exception . h " # include " row . h " # include " session . h " using namespace std ; namespace coda { namespace db { namespace sqlite { resultset :: resultset ( const std :: shared_ptr < sqlite :: session > & sess , const shared_ptr < sqlite3_stmt > & stmt ) : stmt_ ( stmt ) , sess_ ( sess ) , status_ ( - 1 ) { if ( sess_ == nullptr ) { throw database_exception ( " No ▁ database ▁ provided ▁ to ▁ sqlite3 ▁ resultset " ) ; } if ( stmt_ == nullptr ) { throw database_exception ( " no ▁ statement ▁ provided ▁ to ▁ sqlite3 ▁ resultset " ) ; } } resultset :: resultset ( resultset && other ) : stmt_ ( std :: move ( other . stmt_ ) ) , sess_ ( std :: move ( other . sess_ ) ) , status_ ( other . status_ ) { other . sess_ = nullptr ; other . stmt_ = nullptr ; } resultset :: ~ resultset ( ) { } resultset & resultset :: operator = ( resultset && other ) { stmt_ = std :: move ( other . stmt_ ) ; sess_ = std :: move ( other . sess_ ) ; status_ = other . status_ ; other . sess_ = nullptr ; other . stmt_ = nullptr ; return * this ; } bool resultset :: is_valid ( ) const noexcept { return stmt_ != nullptr && stmt_ ; } bool resultset :: next ( ) { if ( ! is_valid ( ) ) { return false ; } if ( status_ == SQLITE_DONE ) { return false ; } status_ = sqlite3_step ( stmt_ . get ( ) ) ; return status_ == SQLITE_ROW ; } void resultset :: reset ( ) { if ( ! is_valid ( ) ) { return ; } if ( sqlite3_reset ( stmt_ . get ( ) ) != SQLITE_OK ) { throw database_exception ( sess_ -> last_error ( ) ) ; } status_ = - 1 ; } resultset :: row_type resultset :: current_row ( ) { return row_type ( make_shared < row > ( sess_ , stmt_ ) ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="keichan100yen/ode-ext/tree/master/boost/libs/config/test/no_std_allocator_fail.cpp"> # ifdef BOOST_ASSERT_CONFIG # undef BOOST_ASSERT_CONFIG # endif # include < boost / config . hpp > # include " test . hpp " # ifdef BOOST_NO_STD_ALLOCATOR # include " boost _ no _ std _ allocator . ipp " # else # error " this ▁ file ▁ should ▁ not ▁ compile " # endif int main ( int , char * [ ] ) { return boost_no_std_allocator :: test ( ) ; } </DOCUMENT>
<DOCUMENT_ID="chirilo/phantomjs/tree/master/src/qt/qtbase/src/gui/doc/snippets/code/src_gui_painting_qpainter.cpp"> void SimpleExampleWidget :: paintEvent ( QPaintEvent * ) { QPainter painter ( this ) ; painter . setPen ( Qt :: blue ) ; painter . setFont ( QFont ( " Arial " , 30 ) ) ; painter . drawText ( rect ( ) , Qt :: AlignCenter , " Qt " ) ; } void MyWidget :: paintEvent ( QPaintEvent * ) { QPainter p ; p . begin ( this ) ; p . drawLine ( ... ) ; p . end ( ) ; } void MyWidget :: paintEvent ( QPaintEvent * ) { QPainter p ( this ) ; p . drawLine ( ... ) ; } painter -> begin ( 0 ) ; QPixmap image ( 0 , 0 ) ; painter -> begin ( & image ) ; painter -> begin ( myWidget ) ; painter2 -> begin ( myWidget ) ; void QPainter :: rotate ( qreal angle ) { QMatrix matrix ; matrix . rotate ( angle ) ; setWorldMatrix ( matrix , true ) ; } QPainterPath path ; path . moveTo ( 20 , 80 ) ; path . lineTo ( 20 , 30 ) ; path . cubicTo ( 80 , 0 , 50 , 50 , 80 , 80 ) ; QPainter painter ( this ) ; painter . drawPath ( path ) ; QLineF line ( 10.0 , 80.0 , 90.0 , 20.0 ) ; QPainter ( this ) ; painter . drawLine ( line ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QPainter painter ( this ) ; painter . drawRect ( rectangle ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QPainter painter ( this ) ; painter . drawRoundedRect ( rectangle , 20.0 , 15.0 ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QPainter painter ( this ) ; painter . drawEllipse ( rectangle ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; int startAngle = 30 * 16 ; int spanAngle = 120 * 16 ; QPainter painter ( this ) ; painter . drawArc ( rectangle , startAngle , spanAngle ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; int startAngle = 30 * 16 ; int spanAngle = 120 * 16 ; QPainter painter ( this ) ; painter . drawPie ( rectangle , startAngle , spanAngle ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; int startAngle = 30 * 16 ; int spanAngle = 120 * 16 ; QPainter painter ( this ) ; painter . drawChord ( rect , startAngle , spanAngle ) ; static const QPointF points [ 3 ] = { QPointF ( 10.0 , 80.0 ) , QPointF ( 20.0 , 10.0 ) , QPointF ( 80.0 , 30.0 ) , } ; QPainter painter ( this ) ; painter . drawPolyline ( points , 3 ) ; static const QPointF points [ 4 ] = { QPointF ( 10.0 , 80.0 ) , QPointF ( 20.0 , 10.0 ) , QPointF ( 80.0 , 30.0 ) , QPointF ( 90.0 , 70.0 ) } ; QPainter painter ( this ) ; painter . drawPolygon ( points , 4 ) ; static const QPointF points [ 4 ] = { QPointF ( 10.0 , 80.0 ) , QPointF ( 20.0 , 10.0 ) , QPointF ( 80.0 , 30.0 ) , QPointF ( 90.0 , 70.0 ) } ; QPainter painter ( this ) ; painter . drawConvexPolygon ( points , 4 ) ; QRectF target ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QRectF source ( 0.0 , 0.0 , 70.0 , 40.0 ) ; QPixmap pixmap ( " : myPixmap . png " ) ; QPainter ( this ) ; painter . drawPixmap ( target , pixmap , source ) ; QPainter painter ( this ) ; painter . drawText ( rect , Qt :: AlignCenter , tr ( " Qt \n Project " ) ) ; QPicture picture ; QPointF point ( 10.0 , 20.0 ) picture . load ( " drawing . pic " ) ; QPainter painter ( this ) ; painter . drawPicture ( 0 , 0 , picture ) ; fillRect ( rectangle , background ( ) ) . QRectF target ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QRectF source ( 0.0 , 0.0 , 70.0 , 40.0 ) ; QImage image ( " : / images / myImage . png " ) ; QPainter painter ( this ) ; painter . drawImage ( target , image , source ) ; QPainter painter ( this ) ; painter . fillRect ( 0 , 0 , 128 , 128 , Qt :: green ) ; painter . beginNativePainting ( ) ; glEnable ( GL_SCISSOR_TEST ) ; glScissor ( 0 , 0 , 64 , 64 ) ; glClearColor ( 1 , 0 , 0 , 1 ) ; glClear ( GL_COLOR_BUFFER_BIT ) ; glDisable ( GL_SCISSOR_TEST ) ; painter . endNativePainting ( ) ; </DOCUMENT>
<DOCUMENT_ID="liuchuo/LeetCode-practice/tree/master/C++/079. Word Search.cpp"> 79. Word Search Given a 2D board and a word , find if the word exists in the grid . The word can be constructed from letters of sequentially adjacent cell , where " adjacent " cells are those horizontally or vertically neighboring . The same letter cell may not be used more than once . For example , Given board = [ [ ' A ' , ' B ' , ' C ' , ' E ' ] , [ ' S ' , ' F ' , ' C ' , ' S ' ] , [ ' A ' , ' D ' , ' E ' , ' E ' ] ] word = " ABCCED " , -> returns true , word = " SEE " , -> returns true , word = " ABCB " , -> returns false . 题目大意：给一个char型二维数组和一个word字符串，寻找网格中是否含有word字符串，只能通过相邻（垂直或者水平）的格子连接～ 分析：对于二维数组中的每一个点都开始遍历，如果当前点的字母正好等于word [ 0 ] 就进入dfs，设立flag标记是否找到，设立visit标记是否访问： 首先令起始节点visit [ j ] [ k ] 标记为已经访问过，接着dfs，如果flag为true直接return，如果当前index正好为word的最后一个字符下标就标记flag为true，return 。 从四个方向开始对结点进行深度优先搜索，首先要保证搜索的结点满足：1 . 是合法的在网格之内的 2 . 未被访问过 3 . 当前字符与要找的word [ index + 1 ] 相同 。 满足则标记visit [ tx ] [ ty ] = true , 且dfs tx和ty以及index + 1 ， 两个dfs后要把他重新置为false ～ 这样最后返回flag的值即为是否能找到的结果～ class Solution { private : bool flag = false ; vector < vector < bool >> visit ; vector < vector < char >> board ; string word = " " ; int dir [ 4 ] [ 2 ] = { { 0 , 1 } , { 1 , 0 } , { 0 , - 1 } , { - 1 , 0 } } ; int m , n ; public : bool exist ( vector < vector < char >> & board , string word ) { if ( board . size ( ) == 0 ) return word == " " ; m = board . size ( ) , n = board [ 0 ] . size ( ) ; this -> word = word ; this -> board = board ; visit . resize ( m , vector < bool > ( n ) ) ; for ( int j = 0 ; j < m ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( board [ j ] [ k ] == word [ 0 ] ) { visit [ j ] [ k ] = true ; dfs ( j , k , 0 ) ; visit [ j ] [ k ] = false ; } } } return flag ; } void dfs ( int x , int y , int index ) { if ( flag == true ) return ; if ( index == word . length ( ) - 1 ) { flag = true ; return ; } for ( int i = 0 ; i < 4 ; i ++ ) { int tx = x + dir [ i ] [ 0 ] , ty = y + dir [ i ] [ 1 ] ; if ( tx >= 0 && tx < m && ty >= 0 && ty < n && board [ tx ] [ ty ] == word [ index + 1 ] && visit [ tx ] [ ty ] == false ) { visit [ tx ] [ ty ] = true ; dfs ( tx , ty , index + 1 ) ; visit [ tx ] [ ty ] = false ; } } } } ; </DOCUMENT>
<DOCUMENT_ID="ddark/ecl/tree/master/src/server/scripts/Northrend/zone_wintergrasp.cpp"> # include " BattlefieldMgr . h " # include " BattlefieldWG . h " # include " Battlefield . h " # include " ScriptSystem . h " # include " WorldSession . h " # include " ObjectMgr . h " # include " Vehicle . h " # include " GameObjectAI . h " # include " ScriptedCreature . h " # include " ScriptedGossip . h " # include " SpellScript . h " # include " Player . h " # define GOSSIP_HELLO_DEMO1 " Build ▁ catapult . " # define GOSSIP_HELLO_DEMO2 " Build ▁ demolisher . " # define GOSSIP_HELLO_DEMO3 " Build ▁ siege ▁ engine . " # define GOSSIP_HELLO_DEMO4 " I ▁ cannot ▁ build ▁ more ! " enum WGqueuenpctext { WG_NPCQUEUE_TEXT_H_NOWAR = 14775 , WG_NPCQUEUE_TEXT_H_QUEUE = 14790 , WG_NPCQUEUE_TEXT_H_WAR = 14777 , WG_NPCQUEUE_TEXT_A_NOWAR = 14782 , WG_NPCQUEUE_TEXT_A_QUEUE = 14791 , WG_NPCQUEUE_TEXT_A_WAR = 14781 , WG_NPCQUEUE_TEXTOPTION_JOIN = 20077 , } ; enum Spells { SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE = 61409 , SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE = 56662 , SPELL_BUILD_CATAPULT_FORCE = 56664 , SPELL_BUILD_DEMOLISHER_FORCE = 56659 , SPELL_ACTIVATE_CONTROL_ARMS = 49899 , SPELL_RIDE_WG_VEHICLE = 60968 , SPELL_VEHICLE_TELEPORT = 49759 , SPELL_CHANNEL_SPIRIT_HEAL = 22011 , } ; enum CreatureIds { NPC_GOBLIN_MECHANIC = 30400 , NPC_GNOMISH_ENGINEER = 30499 , NPC_WINTERGRASP_CONTROL_ARMS = 27852 , NPC_WORLD_TRIGGER_LARGE_AOI_NOT_IMMUNE_PC_NPC = 23472 , } ; enum QuestIds { QUEST_BONES_AND_ARROWS_HORDE_ATT = 13193 , QUEST_JINXING_THE_WALLS_HORDE_ATT = 13202 , QUEST_SLAY_THEM_ALL_HORDE_ATT = 13180 , QUEST_FUELING_THE_DEMOLISHERS_HORDE_ATT = 13200 , QUEST_HEALING_WITH_ROSES_HORDE_ATT = 13201 , QUEST_DEFEND_THE_SIEGE_HORDE_ATT = 13223 , QUEST_BONES_AND_ARROWS_HORDE_DEF = 13199 , QUEST_WARDING_THE_WALLS_HORDE_DEF = 13192 , QUEST_SLAY_THEM_ALL_HORDE_DEF = 13178 , QUEST_FUELING_THE_DEMOLISHERS_HORDE_DEF = 13191 , QUEST_HEALING_WITH_ROSES_HORDE_DEF = 13194 , QUEST_TOPPLING_THE_TOWERS_HORDE_DEF = 13539 , QUEST_STOP_THE_SIEGE_HORDE_DEF = 13185 , QUEST_BONES_AND_ARROWS_ALLIANCE_ATT = 13196 , QUEST_WARDING_THE_WARRIORS_ALLIANCE_ATT = 13198 , QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_ATT = 13179 , QUEST_DEFEND_THE_SIEGE_ALLIANCE_ATT = 13222 , QUEST_A_RARE_HERB_ALLIANCE_ATT = 13195 , QUEST_BONES_AND_ARROWS_ALLIANCE_DEF = 13154 , QUEST_WARDING_THE_WARRIORS_ALLIANCE_DEF = 13153 , QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_DEF = 13177 , QUEST_SHOUTHERN_SABOTAGE_ALLIANCE_DEF = 13538 , QUEST_STOP_THE_SIEGE_ALLIANCE_DEF = 13186 , QUEST_A_RARE_HERB_ALLIANCE_DEF = 13156 , } ; uint8 const MAX_WINTERGRASP_VEHICLES = 4 ; uint32 const vehiclesList [ MAX_WINTERGRASP_VEHICLES ] = { NPC_WINTERGRASP_CATAPULT , NPC_WINTERGRASP_DEMOLISHER , NPC_WINTERGRASP_SIEGE_ENGINE_ALLIANCE , NPC_WINTERGRASP_SIEGE_ENGINE_HORDE } ; class npc_wg_demolisher_engineer : public CreatureScript { public : npc_wg_demolisher_engineer ( ) : CreatureScript ( " npc _ wg _ demolisher _ engineer " ) { } bool OnGossipHello ( Player * player , Creature * creature ) OVERRIDE { if ( creature -> IsQuestGiver ( ) ) player -> PrepareQuestMenu ( creature -> GetGUID ( ) ) ; if ( CanBuild ( creature ) ) { if ( player -> HasAura ( SPELL_CORPORAL ) ) player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO1 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF ) ; else if ( player -> HasAura ( SPELL_LIEUTENANT ) ) { player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO1 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF ) ; player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO2 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF + 1 ) ; player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO3 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF + 2 ) ; } } else player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO4 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF + 9 ) ; player -> SEND_GOSSIP_MENU ( player -> GetGossipTextId ( creature ) , creature -> GetGUID ( ) ) ; return true ; } bool OnGossipSelect ( Player * player , Creature * creature , uint32 , uint32 action ) OVERRIDE { player -> CLOSE_GOSSIP_MENU ( ) ; if ( CanBuild ( creature ) ) { switch ( action - GOSSIP_ACTION_INFO_DEF ) { case 0 : creature -> CastSpell ( player , SPELL_BUILD_CATAPULT_FORCE , true ) ; break ; case 1 : creature -> CastSpell ( player , SPELL_BUILD_DEMOLISHER_FORCE , true ) ; break ; case 2 : creature -> CastSpell ( player , player -> GetTeamId ( ) == TEAM_ALLIANCE ? SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE : SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE , true ) ; break ; } if ( Creature * controlArms = creature -> FindNearestCreature ( NPC_WINTERGRASP_CONTROL_ARMS , 30.0f , true ) ) creature -> CastSpell ( controlArms , SPELL_ACTIVATE_CONTROL_ARMS , true ) ; } return true ; } private : bool CanBuild ( Creature * creature ) { Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return false ; switch ( creature -> GetEntry ( ) ) { case NPC_GOBLIN_MECHANIC : return ( wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_MAX_VEHICLE_H ) > wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_VEHICLE_H ) ) ; case NPC_GNOMISH_ENGINEER : return ( wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_MAX_VEHICLE_A ) > wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_VEHICLE_A ) ) ; default : return false ; } } } ; class npc_wg_spirit_guide : public CreatureScript { public : npc_wg_spirit_guide ( ) : CreatureScript ( " npc _ wg _ spirit _ guide " ) { } bool OnGossipHello ( Player * player , Creature * creature ) OVERRIDE { if ( creature -> IsQuestGiver ( ) ) player -> PrepareQuestMenu ( creature -> GetGUID ( ) ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return true ; GraveyardVect graveyard = wintergrasp -> GetGraveyardVector ( ) ; for ( uint8 i = 0 ; i < graveyard . size ( ) ; i ++ ) if ( graveyard [ i ] -> GetControlTeamId ( ) == player -> GetTeamId ( ) ) player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , sObjectMgr -> GetTrinityStringForDBCLocale ( ( ( BfGraveyardWG * ) graveyard [ i ] ) -> GetTextId ( ) ) , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF + i ) ; player -> SEND_GOSSIP_MENU ( player -> GetGossipTextId ( creature ) , creature -> GetGUID ( ) ) ; return true ; } bool OnGossipSelect ( Player * player , Creature * , uint32 , uint32 action ) OVERRIDE { player -> CLOSE_GOSSIP_MENU ( ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( wintergrasp ) { GraveyardVect gy = wintergrasp -> GetGraveyardVector ( ) ; for ( uint8 i = 0 ; i < gy . size ( ) ; i ++ ) if ( action - GOSSIP_ACTION_INFO_DEF == i && gy [ i ] -> GetControlTeamId ( ) == player -> GetTeamId ( ) ) if ( WorldSafeLocsEntry const * safeLoc = sWorldSafeLocsStore . LookupEntry ( gy [ i ] -> GetGraveyardId ( ) ) ) player -> TeleportTo ( safeLoc -> map_id , safeLoc -> x , safeLoc -> y , safeLoc -> z , 0 ) ; } return true ; } struct npc_wg_spirit_guideAI : public ScriptedAI { npc_wg_spirit_guideAI ( Creature * creature ) : ScriptedAI ( creature ) { } void UpdateAI ( uint32 ) OVERRIDE { if ( ! me -> HasUnitState ( UNIT_STATE_CASTING ) ) DoCast ( me , SPELL_CHANNEL_SPIRIT_HEAL ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const OVERRIDE { return new npc_wg_spirit_guideAI ( creature ) ; } } ; class npc_wg_queue : public CreatureScript { public : npc_wg_queue ( ) : CreatureScript ( " npc _ wg _ queue " ) { } bool OnGossipHello ( Player * player , Creature * creature ) OVERRIDE { if ( creature -> IsQuestGiver ( ) ) player -> PrepareQuestMenu ( creature -> GetGUID ( ) ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return true ; if ( wintergrasp -> IsWarTime ( ) ) { player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , sObjectMgr -> GetTrinityStringForDBCLocale ( WG_NPCQUEUE_TEXTOPTION_JOIN ) , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF ) ; player -> SEND_GOSSIP_MENU ( wintergrasp -> GetDefenderTeam ( ) ? WG_NPCQUEUE_TEXT_H_WAR : WG_NPCQUEUE_TEXT_A_WAR , creature -> GetGUID ( ) ) ; } else { uint32 timer = wintergrasp -> GetTimer ( ) / 1000 ; player -> SendUpdateWorldState ( 4354 , time ( NULL ) + timer ) ; if ( timer < 15 * MINUTE ) { player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , sObjectMgr -> GetTrinityStringForDBCLocale ( WG_NPCQUEUE_TEXTOPTION_JOIN ) , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF ) ; player -> SEND_GOSSIP_MENU ( wintergrasp -> GetDefenderTeam ( ) ? WG_NPCQUEUE_TEXT_H_QUEUE : WG_NPCQUEUE_TEXT_A_QUEUE , creature -> GetGUID ( ) ) ; } else player -> SEND_GOSSIP_MENU ( wintergrasp -> GetDefenderTeam ( ) ? WG_NPCQUEUE_TEXT_H_NOWAR : WG_NPCQUEUE_TEXT_A_NOWAR , creature -> GetGUID ( ) ) ; } return true ; } bool OnGossipSelect ( Player * player , Creature * , uint32 , uint32 ) OVERRIDE { player -> CLOSE_GOSSIP_MENU ( ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return true ; if ( wintergrasp -> IsWarTime ( ) ) wintergrasp -> InvitePlayerToWar ( player ) ; else { uint32 timer = wintergrasp -> GetTimer ( ) / 1000 ; if ( timer < 15 * MINUTE ) wintergrasp -> InvitePlayerToQueue ( player ) ; } return true ; } } ; class go_wg_vehicle_teleporter : public GameObjectScript { public : go_wg_vehicle_teleporter ( ) : GameObjectScript ( " go _ wg _ vehicle _ teleporter " ) { } struct go_wg_vehicle_teleporterAI : public GameObjectAI { go_wg_vehicle_teleporterAI ( GameObject * gameObject ) : GameObjectAI ( gameObject ) , _checkTimer ( 1000 ) { } void UpdateAI ( uint32 diff ) OVERRIDE { if ( _checkTimer <= diff ) { if ( Battlefield * wg = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ) for ( uint8 i = 0 ; i < MAX_WINTERGRASP_VEHICLES ; i ++ ) if ( Creature * vehicleCreature = go -> FindNearestCreature ( vehiclesList [ i ] , 3.0f , true ) ) if ( ! vehicleCreature -> HasAura ( SPELL_VEHICLE_TELEPORT ) && vehicleCreature -> getFaction ( ) == WintergraspFaction [ wg -> GetDefenderTeam ( ) ] ) if ( Creature * teleportTrigger = vehicleCreature -> FindNearestCreature ( NPC_WORLD_TRIGGER_LARGE_AOI_NOT_IMMUNE_PC_NPC , 100.0f , true ) ) teleportTrigger -> CastSpell ( vehicleCreature , SPELL_VEHICLE_TELEPORT , true ) ; _checkTimer = 1000 ; } else _checkTimer -= diff ; } private : uint32 _checkTimer ; } ; GameObjectAI * GetAI ( GameObject * go ) const OVERRIDE { return new go_wg_vehicle_teleporterAI ( go ) ; } } ; class npc_wg_quest_giver : public CreatureScript { public : npc_wg_quest_giver ( ) : CreatureScript ( " npc _ wg _ quest _ giver " ) { } bool OnGossipHello ( Player * player , Creature * creature ) OVERRIDE { if ( creature -> IsQuestGiver ( ) ) player -> PrepareQuestMenu ( creature -> GetGUID ( ) ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return true ; if ( creature -> IsQuestGiver ( ) ) { QuestRelationBounds objectQR = sObjectMgr -> GetCreatureQuestRelationBounds ( creature -> GetEntry ( ) ) ; QuestRelationBounds objectQIR = sObjectMgr -> GetCreatureQuestInvolvedRelationBounds ( creature -> GetEntry ( ) ) ; QuestMenu & qm = player -> PlayerTalkClass -> GetQuestMenu ( ) ; qm . ClearMenu ( ) ; for ( QuestRelations :: const_iterator i = objectQIR . first ; i != objectQIR . second ; ++ i ) { uint32 questId = i -> second ; QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( status == QUEST_STATUS_COMPLETE ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_INCOMPLETE ) qm . AddMenuItem ( questId , 4 ) ; } for ( QuestRelations :: const_iterator i = objectQR . first ; i != objectQR . second ; ++ i ) { uint32 questId = i -> second ; Quest const * quest = sObjectMgr -> GetQuestTemplate ( questId ) ; if ( ! quest ) continue ; switch ( questId ) { case QUEST_BONES_AND_ARROWS_HORDE_ATT : case QUEST_JINXING_THE_WALLS_HORDE_ATT : case QUEST_SLAY_THEM_ALL_HORDE_ATT : case QUEST_FUELING_THE_DEMOLISHERS_HORDE_ATT : case QUEST_HEALING_WITH_ROSES_HORDE_ATT : case QUEST_DEFEND_THE_SIEGE_HORDE_ATT : if ( wintergrasp -> GetAttackerTeam ( ) == TEAM_HORDE ) { QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; } break ; case QUEST_BONES_AND_ARROWS_HORDE_DEF : case QUEST_WARDING_THE_WALLS_HORDE_DEF : case QUEST_SLAY_THEM_ALL_HORDE_DEF : case QUEST_FUELING_THE_DEMOLISHERS_HORDE_DEF : case QUEST_HEALING_WITH_ROSES_HORDE_DEF : case QUEST_TOPPLING_THE_TOWERS_HORDE_DEF : case QUEST_STOP_THE_SIEGE_HORDE_DEF : if ( wintergrasp -> GetDefenderTeam ( ) == TEAM_HORDE ) { QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; } break ; case QUEST_BONES_AND_ARROWS_ALLIANCE_ATT : case QUEST_WARDING_THE_WARRIORS_ALLIANCE_ATT : case QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_ATT : case QUEST_DEFEND_THE_SIEGE_ALLIANCE_ATT : case QUEST_A_RARE_HERB_ALLIANCE_ATT : if ( wintergrasp -> GetAttackerTeam ( ) == TEAM_ALLIANCE ) { QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; } break ; case QUEST_BONES_AND_ARROWS_ALLIANCE_DEF : case QUEST_WARDING_THE_WARRIORS_ALLIANCE_DEF : case QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_DEF : case QUEST_SHOUTHERN_SABOTAGE_ALLIANCE_DEF : case QUEST_STOP_THE_SIEGE_ALLIANCE_DEF : case QUEST_A_RARE_HERB_ALLIANCE_DEF : if ( wintergrasp -> GetDefenderTeam ( ) == TEAM_ALLIANCE ) { QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; } break ; default : QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; break ; } } } player -> SEND_GOSSIP_MENU ( player -> GetGossipTextId ( creature ) , creature -> GetGUID ( ) ) ; return true ; } } ; class spell_wintergrasp_force_building : public SpellScriptLoader { public : spell_wintergrasp_force_building ( ) : SpellScriptLoader ( " spell _ wintergrasp _ force _ building " ) { } class spell_wintergrasp_force_building_SpellScript : public SpellScript { PrepareSpellScript ( spell_wintergrasp_force_building_SpellScript ) ; bool Validate ( SpellInfo const * ) OVERRIDE { if ( ! sSpellMgr -> GetSpellInfo ( SPELL_BUILD_CATAPULT_FORCE ) || ! sSpellMgr -> GetSpellInfo ( SPELL_BUILD_DEMOLISHER_FORCE ) || ! sSpellMgr -> GetSpellInfo ( SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE ) || ! sSpellMgr -> GetSpellInfo ( SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE ) ) return false ; return true ; } void HandleScript ( SpellEffIndex effIndex ) { PreventHitDefaultEffect ( effIndex ) ; GetHitUnit ( ) -> CastSpell ( GetHitUnit ( ) , GetEffectValue ( ) , false ) ; } void Register ( ) OVERRIDE { OnEffectHitTarget += SpellEffectFn ( spell_wintergrasp_force_building_SpellScript :: HandleScript , EFFECT_0 , SPELL_EFFECT_SCRIPT_EFFECT ) ; } } ; SpellScript * GetSpellScript ( ) const OVERRIDE { return new spell_wintergrasp_force_building_SpellScript ( ) ; } } ; class spell_wintergrasp_grab_passenger : public SpellScriptLoader { public : spell_wintergrasp_grab_passenger ( ) : SpellScriptLoader ( " spell _ wintergrasp _ grab _ passenger " ) { } class spell_wintergrasp_grab_passenger_SpellScript : public SpellScript { PrepareSpellScript ( spell_wintergrasp_grab_passenger_SpellScript ) ; void HandleScript ( SpellEffIndex ) { if ( Player * target = GetHitPlayer ( ) ) target -> CastSpell ( GetCaster ( ) , SPELL_RIDE_WG_VEHICLE , false ) ; } void Register ( ) OVERRIDE { OnEffectHitTarget += SpellEffectFn ( spell_wintergrasp_grab_passenger_SpellScript :: HandleScript , EFFECT_0 , SPELL_EFFECT_SCRIPT_EFFECT ) ; } } ; SpellScript * GetSpellScript ( ) const OVERRIDE { return new spell_wintergrasp_grab_passenger_SpellScript ( ) ; } } ; class achievement_wg_didnt_stand_a_chance : public AchievementCriteriaScript { public : achievement_wg_didnt_stand_a_chance ( ) : AchievementCriteriaScript ( " achievement _ wg _ didnt _ stand _ a _ chance " ) { } bool OnCheck ( Player * source , Unit * target ) OVERRIDE { if ( ! target ) return false ; if ( Player * victim = target -> ToPlayer ( ) ) { if ( ! victim -> IsMounted ( ) ) return false ; if ( Vehicle * vehicle = source -> GetVehicle ( ) ) if ( vehicle -> GetVehicleInfo ( ) -> m_ID == 244 ) return true ; } return false ; } } ; enum WgTeleport { SPELL_WINTERGRASP_TELEPORT_TRIGGER = 54643 , } ; class spell_wintergrasp_defender_teleport : public SpellScriptLoader { public : spell_wintergrasp_defender_teleport ( ) : SpellScriptLoader ( " spell _ wintergrasp _ defender _ teleport " ) { } class spell_wintergrasp_defender_teleport_SpellScript : public SpellScript { PrepareSpellScript ( spell_wintergrasp_defender_teleport_SpellScript ) ; SpellCastResult CheckCast ( ) { if ( Battlefield * wg = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ) if ( Player * target = GetExplTargetUnit ( ) -> ToPlayer ( ) ) if ( ( target -> GetZoneId ( ) == 4197 && target -> GetTeamId ( ) != wg -> GetDefenderTeam ( ) ) || target -> HasAura ( SPELL_WINTERGRASP_TELEPORT_TRIGGER ) ) return SPELL_FAILED_BAD_TARGETS ; return SPELL_CAST_OK ; } void Register ( ) OVERRIDE { OnCheckCast += SpellCheckCastFn ( spell_wintergrasp_defender_teleport_SpellScript :: CheckCast ) ; } } ; SpellScript * GetSpellScript ( ) const OVERRIDE { return new spell_wintergrasp_defender_teleport_SpellScript ( ) ; } } ; class spell_wintergrasp_defender_teleport_trigger : public SpellScriptLoader { public : spell_wintergrasp_defender_teleport_trigger ( ) : SpellScriptLoader ( " spell _ wintergrasp _ defender _ teleport _ trigger " ) { } class spell_wintergrasp_defender_teleport_trigger_SpellScript : public SpellScript { PrepareSpellScript ( spell_wintergrasp_defender_teleport_trigger_SpellScript ) ; void HandleDummy ( SpellEffIndex ) { if ( Unit * target = GetHitUnit ( ) ) { WorldLocation loc ; target -> GetPosition ( & loc ) ; SetExplTargetDest ( loc ) ; } } void Register ( ) OVERRIDE { OnEffectHitTarget += SpellEffectFn ( spell_wintergrasp_defender_teleport_trigger_SpellScript :: HandleDummy , EFFECT_0 , SPELL_EFFECT_DUMMY ) ; } } ; SpellScript * GetSpellScript ( ) const OVERRIDE { return new spell_wintergrasp_defender_teleport_trigger_SpellScript ( ) ; } } ; void AddSC_wintergrasp ( ) { new npc_wg_queue ( ) ; new npc_wg_spirit_guide ( ) ; new npc_wg_demolisher_engineer ( ) ; new go_wg_vehicle_teleporter ( ) ; new npc_wg_quest_giver ( ) ; new spell_wintergrasp_force_building ( ) ; new spell_wintergrasp_grab_passenger ( ) ; new achievement_wg_didnt_stand_a_chance ( ) ; new spell_wintergrasp_defender_teleport ( ) ; new spell_wintergrasp_defender_teleport_trigger ( ) ; } </DOCUMENT>
<DOCUMENT_ID="dolphin-emu/dolphin/tree/master/Source/Core/VideoCommon/OnScreenDisplay.cpp"> # include " VideoCommon / OnScreenDisplay . h " # include < algorithm > # include < map > # include < mutex > # include < string > # include < fmt / format . h > # include < imgui . h > # include " Common / CommonTypes . h " # include " Common / Timer . h " # include " Core / ConfigManager . h " namespace OSD { constexpr float LEFT_MARGIN = 10.0f ; constexpr float TOP_MARGIN = 10.0f ; constexpr float WINDOW_PADDING = 4.0f ; struct Message { Message ( ) = default ; Message ( std :: string text_ , u32 timestamp_ , u32 color_ ) : text ( std :: move ( text_ ) ) , timestamp ( timestamp_ ) , color ( color_ ) { } std :: string text ; u32 timestamp = 0 ; u32 color = 0 ; } ; static std :: multimap < MessageType , Message > s_messages ; static std :: mutex s_messages_mutex ; static ImVec4 RGBAToImVec4 ( const u32 rgba ) { return ImVec4 ( static_cast < float > ( ( rgba >> 16 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 8 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 0 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 24 ) & 0xFF ) / 255.0f ) ; } static float DrawMessage ( int index , const Message & msg , const ImVec2 & position , int time_left ) { const std :: string window_name = fmt :: format ( " osd _ { } " , index ) ; ImGui :: SetNextWindowPos ( position ) ; ImGui :: SetNextWindowSize ( ImVec2 ( 0.0f , 0.0f ) ) ; const float alpha = std :: min ( 1.0f , std :: max ( 0.0f , time_left / 1024.0f ) ) ; ImGui :: PushStyleVar ( ImGuiStyleVar_Alpha , alpha ) ; float window_height = 0.0f ; if ( ImGui :: Begin ( window_name . c_str ( ) , nullptr , ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoFocusOnAppearing ) ) { ImGui :: TextColored ( RGBAToImVec4 ( msg . color ) , " % s " , msg . text . c_str ( ) ) ; window_height = ImGui :: GetWindowSize ( ) . y + ( WINDOW_PADDING * ImGui :: GetIO ( ) . DisplayFramebufferScale . y ) ; } ImGui :: End ( ) ; ImGui :: PopStyleVar ( ) ; return window_height ; } void AddTypedMessage ( MessageType type , std :: string message , u32 ms , u32 rgba ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . erase ( type ) ; s_messages . emplace ( type , Message ( std :: move ( message ) , Common :: Timer :: GetTimeMs ( ) + ms , rgba ) ) ; } void AddMessage ( std :: string message , u32 ms , u32 rgba ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . emplace ( MessageType :: Typeless , Message ( std :: move ( message ) , Common :: Timer :: GetTimeMs ( ) + ms , rgba ) ) ; } void DrawMessages ( ) { if ( ! SConfig :: GetInstance ( ) . bOnScreenDisplayMessages ) return ; { std :: lock_guard lock { s_messages_mutex } ; const u32 now = Common :: Timer :: GetTimeMs ( ) ; float current_x = LEFT_MARGIN * ImGui :: GetIO ( ) . DisplayFramebufferScale . x ; float current_y = TOP_MARGIN * ImGui :: GetIO ( ) . DisplayFramebufferScale . y ; int index = 0 ; auto it = s_messages . begin ( ) ; while ( it != s_messages . end ( ) ) { const Message & msg = it -> second ; const int time_left = static_cast < int > ( msg . timestamp - now ) ; current_y += DrawMessage ( index ++ , msg , ImVec2 ( current_x , current_y ) , time_left ) ; if ( time_left <= 0 ) it = s_messages . erase ( it ) ; else ++ it ; } } } void ClearMessages ( ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . clear ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="quang-ha/lammps/tree/master/lib/kokkos/core/src/eti/OpenMP/Kokkos_OpenMP_ViewCopyETIInst_int64_t_double_LayoutStride_Rank3.cpp"> # define KOKKOS_IMPL_COMPILING_LIBRARY true # include < Kokkos_Core . hpp > namespace Kokkos { namespace Impl { KOKKOS_IMPL_VIEWCOPY_ETI_INST ( double * * * , LayoutStride , LayoutRight , OpenMP , int64_t ) KOKKOS_IMPL_VIEWCOPY_ETI_INST ( double * * * , LayoutStride , LayoutLeft , OpenMP , int64_t ) KOKKOS_IMPL_VIEWCOPY_ETI_INST ( double * * * , LayoutStride , LayoutStride , OpenMP , int64_t ) KOKKOS_IMPL_VIEWFILL_ETI_INST ( double * * * , LayoutStride , OpenMP , int64_t ) } } </DOCUMENT>
<DOCUMENT_ID="syslover33/ctank/tree/master/java/android-sdk-linux_r24.4.1_src/ndk-bundle_r11c/sources/cxx-stl/llvm-libc++/libcxx/test/localization/locales/locale.convenience/conversions/conversions.buffer/pbackfail.pass.cpp"> # include < locale > # include < codecvt > # include < fstream > # include < cassert > struct test_buf : public std :: wbuffer_convert < std :: codecvt_utf8 < wchar_t > > { typedef std :: wbuffer_convert < std :: codecvt_utf8 < wchar_t > > base ; typedef base :: char_type char_type ; typedef base :: int_type int_type ; typedef base :: traits_type traits_type ; explicit test_buf ( std :: streambuf * sb ) : base ( sb ) { } char_type * eback ( ) const { return base :: eback ( ) ; } char_type * gptr ( ) const { return base :: gptr ( ) ; } char_type * egptr ( ) const { return base :: egptr ( ) ; } void gbump ( int n ) { base :: gbump ( n ) ; } virtual int_type pbackfail ( int_type c = traits_type :: eof ( ) ) { return base :: pbackfail ( c ) ; } } ; int main ( ) { { std :: ifstream bs ( " underflow . dat " ) ; test_buf f ( bs . rdbuf ( ) ) ; assert ( f . sbumpc ( ) == L ' 1' ) ; assert ( f . sgetc ( ) == L ' 2' ) ; assert ( f . pbackfail ( L ' a ' ) == test_buf :: traits_type :: eof ( ) ) ; } { std :: fstream bs ( " underflow . dat " ) ; test_buf f ( bs . rdbuf ( ) ) ; assert ( f . sbumpc ( ) == L ' 1' ) ; assert ( f . sgetc ( ) == L ' 2' ) ; assert ( f . pbackfail ( L ' a ' ) == test_buf :: traits_type :: eof ( ) ) ; assert ( f . sbumpc ( ) == L ' 2' ) ; assert ( f . sgetc ( ) == L ' 3' ) ; } } </DOCUMENT>
<DOCUMENT_ID="sacarlson/MultiCoin-exp/tree/master/src/db.cpp"> # include " headers . h " # include " db . h " # include " net . h " # include " auxpow . h " # include < boost / filesystem . hpp > # include < boost / filesystem / fstream . hpp > using namespace std ; using namespace boost ; unsigned int nWalletDBUpdated ; uint64 nAccountingEntryNumber = 0 ; static CCriticalSection cs_db ; static bool fDbEnvInit = false ; DbEnv dbenv ( 0 ) ; static map < string , int > mapFileUseCount ; static map < string , Db * > mapDb ; class CDBInit { public : CDBInit ( ) { } ~ CDBInit ( ) { if ( fDbEnvInit ) { dbenv . close ( 0 ) ; fDbEnvInit = false ; } } } instance_of_cdbinit ; CDB :: CDB ( const char * pszFile , const char * pszMode ) : pdb ( NULL ) { int ret ; if ( pszFile == NULL ) return ; fReadOnly = ( ! strchr ( pszMode , ' + ' ) && ! strchr ( pszMode , ' w ' ) ) ; bool fCreate = strchr ( pszMode , ' c ' ) ; unsigned int nFlags = DB_THREAD ; if ( fCreate ) nFlags |= DB_CREATE ; CRITICAL_BLOCK ( cs_db ) { if ( ! fDbEnvInit ) { if ( fShutdown ) return ; string strDataDir = GetDataDir ( ) ; string strLogDir = strDataDir + " / database " ; filesystem :: create_directory ( strLogDir . c_str ( ) ) ; string strErrorFile = strDataDir + " / db . log " ; printf ( " dbenv . open ▁ strLogDir = % s ▁ strErrorFile = % s \n " , strLogDir . c_str ( ) , strErrorFile . c_str ( ) ) ; dbenv . set_lg_dir ( strLogDir . c_str ( ) ) ; dbenv . set_lg_max ( 10000000 ) ; dbenv . set_lk_max_locks ( 10000 ) ; dbenv . set_lk_max_objects ( 10000 ) ; dbenv . set_errfile ( fopen ( strErrorFile . c_str ( ) , " a " ) ) ; dbenv . set_flags ( DB_AUTO_COMMIT , 1 ) ; ret = dbenv . open ( strDataDir . c_str ( ) , DB_CREATE | DB_INIT_LOCK | DB_INIT_LOG | DB_INIT_MPOOL | DB_INIT_TXN | DB_THREAD | DB_RECOVER , S_IRUSR | S_IWUSR ) ; if ( ret > 0 ) throw runtime_error ( strprintf ( " CDB ( ) ▁ : ▁ error ▁ % d ▁ opening ▁ database ▁ environment " , ret ) ) ; fDbEnvInit = true ; } strFile = pszFile ; ++ mapFileUseCount [ strFile ] ; pdb = mapDb [ strFile ] ; if ( pdb == NULL ) { pdb = new Db ( & dbenv , 0 ) ; ret = pdb -> open ( NULL , pszFile , " main " , DB_BTREE , nFlags , 0 ) ; if ( ret > 0 ) { delete pdb ; pdb = NULL ; CRITICAL_BLOCK ( cs_db ) -- mapFileUseCount [ strFile ] ; strFile = " " ; throw runtime_error ( strprintf ( " CDB ( ) ▁ : ▁ can ' t ▁ open ▁ database ▁ file ▁ % s , ▁ error ▁ % d " , pszFile , ret ) ) ; } if ( fCreate && ! Exists ( string ( " version " ) ) ) { bool fTmp = fReadOnly ; fReadOnly = false ; WriteVersion ( VERSION ) ; fReadOnly = fTmp ; } mapDb [ strFile ] = pdb ; } } } void CDB :: Close ( ) { if ( ! pdb ) return ; if ( ! vTxn . empty ( ) ) vTxn . front ( ) -> abort ( ) ; vTxn . clear ( ) ; pdb = NULL ; unsigned int nMinutes = 0 ; if ( fReadOnly ) nMinutes = 1 ; if ( strFile == " addr . dat " ) nMinutes = 2 ; if ( strFile == " blkindex . dat " && IsInitialBlockDownload ( ) && nBestHeight % 500 != 0 ) nMinutes = 1 ; dbenv . txn_checkpoint ( 0 , nMinutes , 0 ) ; CRITICAL_BLOCK ( cs_db ) -- mapFileUseCount [ strFile ] ; } void static CloseDb ( const string & strFile ) { CRITICAL_BLOCK ( cs_db ) { if ( mapDb [ strFile ] != NULL ) { Db * pdb = mapDb [ strFile ] ; pdb -> close ( 0 ) ; delete pdb ; mapDb [ strFile ] = NULL ; } } } void DBFlush ( bool fShutdown ) { printf ( " DBFlush ( % s ) % s \n " , fShutdown ? " true " : " false " , fDbEnvInit ? " " : " ▁ db ▁ not ▁ started " ) ; if ( ! fDbEnvInit ) return ; CRITICAL_BLOCK ( cs_db ) { map < string , int > :: iterator mi = mapFileUseCount . begin ( ) ; while ( mi != mapFileUseCount . end ( ) ) { string strFile = ( * mi ) . first ; int nRefCount = ( * mi ) . second ; printf ( " % s ▁ refcount = % d \n " , strFile . c_str ( ) , nRefCount ) ; if ( nRefCount == 0 ) { CloseDb ( strFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; printf ( " % s ▁ flush \n " , strFile . c_str ( ) ) ; dbenv . lsn_reset ( strFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( mi ++ ) ; } else mi ++ ; } if ( fShutdown ) { char * * listp ; if ( mapFileUseCount . empty ( ) ) dbenv . log_archive ( & listp , DB_ARCH_REMOVE ) ; dbenv . close ( 0 ) ; fDbEnvInit = false ; } } } bool CTxDB :: ReadTxIndex ( uint256 hash , CTxIndex & txindex ) { assert ( ! fClient ) ; txindex . SetNull ( ) ; return Read ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; } bool CTxDB :: UpdateTxIndex ( uint256 hash , const CTxIndex & txindex ) { assert ( ! fClient ) ; return Write ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; } bool CTxDB :: AddTxIndex ( const CTransaction & tx , const CDiskTxPos & pos , int nHeight ) { assert ( ! fClient ) ; uint256 hash = tx . GetHash ( ) ; CTxIndex txindex ( pos , tx . vout . size ( ) ) ; return Write ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; } bool CTxDB :: EraseTxIndex ( const CTransaction & tx ) { assert ( ! fClient ) ; uint256 hash = tx . GetHash ( ) ; return Erase ( make_pair ( string ( " tx " ) , hash ) ) ; } bool CTxDB :: ContainsTx ( uint256 hash ) { assert ( ! fClient ) ; return Exists ( make_pair ( string ( " tx " ) , hash ) ) ; } bool CTxDB :: ReadOwnerTxes ( uint160 hash160 , int nMinHeight , vector < CTransaction > & vtx ) { assert ( ! fClient ) ; vtx . clear ( ) ; Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; unsigned int fFlags = DB_SET_RANGE ; loop { CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << string ( " owner " ) << hash160 << CDiskTxPos ( 0 , 0 , 0 ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) { pcursor -> close ( ) ; return false ; } string strType ; uint160 hashItem ; CDiskTxPos pos ; ssKey >> strType >> hashItem >> pos ; int nItemHeight ; ssValue >> nItemHeight ; if ( strType != " owner " || hashItem != hash160 ) break ; if ( nItemHeight >= nMinHeight ) { vtx . resize ( vtx . size ( ) + 1 ) ; if ( ! vtx . back ( ) . ReadFromDisk ( pos ) ) { pcursor -> close ( ) ; return false ; } } } pcursor -> close ( ) ; return true ; } bool CTxDB :: ReadDiskTx ( uint256 hash , CTransaction & tx , CTxIndex & txindex ) { assert ( ! fClient ) ; tx . SetNull ( ) ; if ( ! ReadTxIndex ( hash , txindex ) ) return false ; return ( tx . ReadFromDisk ( txindex . pos ) ) ; } bool CTxDB :: ReadDiskTx ( uint256 hash , CTransaction & tx ) { CTxIndex txindex ; return ReadDiskTx ( hash , tx , txindex ) ; } bool CTxDB :: ReadDiskTx ( COutPoint outpoint , CTransaction & tx , CTxIndex & txindex ) { return ReadDiskTx ( outpoint . hash , tx , txindex ) ; } bool CTxDB :: ReadDiskTx ( COutPoint outpoint , CTransaction & tx ) { CTxIndex txindex ; return ReadDiskTx ( outpoint . hash , tx , txindex ) ; } bool CTxDB :: WriteBlockIndex ( const CDiskBlockIndex & blockindex ) { return Write ( make_pair ( string ( " blockindex " ) , blockindex . GetBlockHash ( ) ) , blockindex ) ; } bool CTxDB :: EraseBlockIndex ( uint256 hash ) { return Erase ( make_pair ( string ( " blockindex " ) , hash ) ) ; } bool CTxDB :: ReadHashBestChain ( uint256 & hashBestChain ) { return Read ( string ( " hashBestChain " ) , hashBestChain ) ; } bool CTxDB :: WriteHashBestChain ( uint256 hashBestChain ) { return Write ( string ( " hashBestChain " ) , hashBestChain ) ; } bool CTxDB :: ReadBestInvalidWork ( CBigNum & bnBestInvalidWork ) { return Read ( string ( " bnBestInvalidWork " ) , bnBestInvalidWork ) ; } bool CTxDB :: WriteBestInvalidWork ( CBigNum bnBestInvalidWork ) { return Write ( string ( " bnBestInvalidWork " ) , bnBestInvalidWork ) ; } CBlockIndex static * InsertBlockIndex ( uint256 hash ) { if ( hash == 0 ) return NULL ; map < uint256 , CBlockIndex * > :: iterator mi = mapBlockIndex . find ( hash ) ; if ( mi != mapBlockIndex . end ( ) ) return ( * mi ) . second ; CBlockIndex * pindexNew = new CBlockIndex ( ) ; if ( ! pindexNew ) throw runtime_error ( " LoadBlockIndex ( ) ▁ : ▁ new ▁ CBlockIndex ▁ failed " ) ; mi = mapBlockIndex . insert ( make_pair ( hash , pindexNew ) ) . first ; pindexNew -> phashBlock = & ( ( * mi ) . first ) ; return pindexNew ; } bool CTxDB :: LoadBlockIndex ( ) { Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; unsigned int fFlags = DB_SET_RANGE ; loop { CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << make_pair ( string ( " blockindex " ) , uint256 ( 0 ) ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; string strType ; ssKey >> strType ; if ( strType == " blockindex " ) { CDiskBlockIndex diskindex ; ssValue >> diskindex ; CBlockIndex * pindexNew = InsertBlockIndex ( diskindex . GetBlockHash ( ) ) ; pindexNew -> pprev = InsertBlockIndex ( diskindex . hashPrev ) ; pindexNew -> pnext = InsertBlockIndex ( diskindex . hashNext ) ; pindexNew -> nFile = diskindex . nFile ; pindexNew -> nBlockPos = diskindex . nBlockPos ; pindexNew -> nHeight = diskindex . nHeight ; pindexNew -> nVersion = diskindex . nVersion ; pindexNew -> hashMerkleRoot = diskindex . hashMerkleRoot ; pindexNew -> nTime = diskindex . nTime ; pindexNew -> nBits = diskindex . nBits ; pindexNew -> nNonce = diskindex . nNonce ; pindexNew -> auxpow = diskindex . auxpow ; if ( pindexGenesisBlock == NULL && diskindex . GetBlockHash ( ) == hashGenesisBlock ) pindexGenesisBlock = pindexNew ; if ( ! pindexNew -> CheckIndex ( ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ CheckIndex ▁ failed ▁ at ▁ % d " , pindexNew -> nHeight ) ; } else { break ; } } pcursor -> close ( ) ; vector < pair < int , CBlockIndex * > > vSortedByHeight ; vSortedByHeight . reserve ( mapBlockIndex . size ( ) ) ; BOOST_FOREACH ( const PAIRTYPE ( uint256 , CBlockIndex * ) & item , mapBlockIndex ) { CBlockIndex * pindex = item . second ; vSortedByHeight . push_back ( make_pair ( pindex -> nHeight , pindex ) ) ; } sort ( vSortedByHeight . begin ( ) , vSortedByHeight . end ( ) ) ; BOOST_FOREACH ( const PAIRTYPE ( int , CBlockIndex * ) & item , vSortedByHeight ) { CBlockIndex * pindex = item . second ; pindex -> bnChainWork = ( pindex -> pprev ? pindex -> pprev -> bnChainWork : 0 ) + pindex -> GetBlockWork ( ) ; } if ( ! ReadHashBestChain ( hashBestChain ) ) { if ( pindexGenesisBlock == NULL ) return true ; return error ( " CTxDB : : LoadBlockIndex ( ) ▁ : ▁ hashBestChain ▁ not ▁ loaded " ) ; } if ( ! mapBlockIndex . count ( hashBestChain ) ) return error ( " CTxDB : : LoadBlockIndex ( ) ▁ : ▁ hashBestChain ▁ not ▁ found ▁ in ▁ the ▁ block ▁ index " ) ; pindexBest = mapBlockIndex [ hashBestChain ] ; nBestHeight = pindexBest -> nHeight ; bnBestChainWork = pindexBest -> bnChainWork ; printf ( " LoadBlockIndex ( ) : ▁ hashBestChain = % s ▁ ▁ height = % d \n " , hashBestChain . ToString ( ) . substr ( 0 , 20 ) . c_str ( ) , nBestHeight ) ; ReadBestInvalidWork ( bnBestInvalidWork ) ; CBlockIndex * pindexFork = NULL ; for ( CBlockIndex * pindex = pindexBest ; pindex && pindex -> pprev ; pindex = pindex -> pprev ) { if ( pindex -> nHeight < nBestHeight - 2500 && ! mapArgs . count ( " - checkblocks " ) ) break ; CBlock block ; if ( ! block . ReadFromDisk ( pindex ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ block . ReadFromDisk ▁ failed " ) ; if ( ! block . CheckBlock ( pindex -> nHeight ) ) { printf ( " LoadBlockIndex ( ) ▁ : ▁ * * * ▁ found ▁ bad ▁ block ▁ at ▁ % d , ▁ hash = % s \n " , pindex -> nHeight , pindex -> GetBlockHash ( ) . ToString ( ) . c_str ( ) ) ; pindexFork = pindex -> pprev ; } } if ( pindexFork ) { printf ( " LoadBlockIndex ( ) ▁ : ▁ * * * ▁ moving ▁ best ▁ chain ▁ pointer ▁ back ▁ to ▁ block ▁ % d \n " , pindexFork -> nHeight ) ; CBlock block ; if ( ! block . ReadFromDisk ( pindexFork ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ block . ReadFromDisk ▁ failed " ) ; CTxDB txdb ; block . SetBestChain ( txdb , pindexFork ) ; } return true ; } bool CAddrDB :: WriteAddress ( const CAddress & addr ) { return Write ( make_pair ( string ( " addr " ) , addr . GetKey ( ) ) , addr ) ; } bool CAddrDB :: EraseAddress ( const CAddress & addr ) { return Erase ( make_pair ( string ( " addr " ) , addr . GetKey ( ) ) ) ; } bool CAddrDB :: LoadAddresses ( ) { CRITICAL_BLOCK ( cs_mapAddresses ) { CAutoFile filein = fopen ( ( GetDataDir ( ) + " / addr . txt " ) . c_str ( ) , " rt " ) ; if ( filein ) { try { char psz [ 1000 ] ; while ( fgets ( psz , sizeof ( psz ) , filein ) ) { CAddress addr ( psz , NODE_NETWORK ) ; addr . nTime = 0 ; if ( addr . IsValid ( ) ) AddAddress ( addr ) ; } } catch ( ... ) { } } Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; loop { CDataStream ssKey ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue ) ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; string strType ; ssKey >> strType ; if ( strType == " addr " ) { CAddress addr ; ssValue >> addr ; mapAddresses . insert ( make_pair ( addr . GetKey ( ) , addr ) ) ; } } pcursor -> close ( ) ; printf ( " Loaded ▁ % d ▁ addresses \n " , mapAddresses . size ( ) ) ; } return true ; } bool LoadAddresses ( ) { return CAddrDB ( " cr + " ) . LoadAddresses ( ) ; } bool CWalletDB :: WriteName ( const string & strAddress , const string & strName ) { nWalletDBUpdated ++ ; return Write ( make_pair ( string ( " name " ) , strAddress ) , strName ) ; } bool CWalletDB :: EraseName ( const string & strAddress ) { nWalletDBUpdated ++ ; return Erase ( make_pair ( string ( " name " ) , strAddress ) ) ; } bool CWalletDB :: ReadAccount ( const string & strAccount , CAccount & account ) { account . SetNull ( ) ; return Read ( make_pair ( string ( " acc " ) , strAccount ) , account ) ; } bool CWalletDB :: WriteAccount ( const string & strAccount , const CAccount & account ) { return Write ( make_pair ( string ( " acc " ) , strAccount ) , account ) ; } bool CWalletDB :: WriteAccountingEntry ( const CAccountingEntry & acentry ) { return Write ( make_tuple ( string ( " acentry " ) , acentry . strAccount , ++ nAccountingEntryNumber ) , acentry ) ; } int64 CWalletDB :: GetAccountCreditDebit ( const string & strAccount ) { list < CAccountingEntry > entries ; ListAccountCreditDebit ( strAccount , entries ) ; int64 nCreditDebit = 0 ; BOOST_FOREACH ( const CAccountingEntry & entry , entries ) nCreditDebit += entry . nCreditDebit ; return nCreditDebit ; } void CWalletDB :: ListAccountCreditDebit ( const string & strAccount , list < CAccountingEntry > & entries ) { int64 nCreditDebit = 0 ; bool fAllAccounts = ( strAccount == " * " ) ; Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) throw runtime_error ( " CWalletDB : : ListAccountCreditDebit ( ) ▁ : ▁ cannot ▁ create ▁ DB ▁ cursor " ) ; unsigned int fFlags = DB_SET_RANGE ; loop { CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << make_tuple ( string ( " acentry " ) , ( fAllAccounts ? string ( " " ) : strAccount ) , uint64 ( 0 ) ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) { pcursor -> close ( ) ; throw runtime_error ( " CWalletDB : : ListAccountCreditDebit ( ) ▁ : ▁ error ▁ scanning ▁ DB " ) ; } string strType ; ssKey >> strType ; if ( strType != " acentry " ) break ; CAccountingEntry acentry ; ssKey >> acentry . strAccount ; if ( ! fAllAccounts && acentry . strAccount != strAccount ) break ; ssValue >> acentry ; entries . push_back ( acentry ) ; } pcursor -> close ( ) ; } bool CWalletDB :: LoadWallet ( CWallet * pwallet ) { pwallet -> vchDefaultKey . clear ( ) ; int nFileVersion = 0 ; vector < uint256 > vWalletUpgrade ; # ifndef __WXMSW__ fMinimizeToTray = false ; fMinimizeOnClose = false ; # endif CRITICAL_BLOCK ( pwallet -> cs_mapWallet ) CRITICAL_BLOCK ( pwallet -> cs_mapKeys ) { Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; loop { CDataStream ssKey ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue ) ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; string strType ; ssKey >> strType ; if ( strType == " name " ) { string strAddress ; ssKey >> strAddress ; ssValue >> pwallet -> mapAddressBook [ strAddress ] ; } else if ( strType == " tx " ) { uint256 hash ; ssKey >> hash ; CWalletTx & wtx = pwallet -> mapWallet [ hash ] ; ssValue >> wtx ; wtx . pwallet = pwallet ; if ( wtx . GetHash ( ) != hash ) printf ( " Error ▁ in ▁ wallet . dat , ▁ hash ▁ mismatch \n " ) ; if ( 31404 <= wtx . fTimeReceivedIsTxTime && wtx . fTimeReceivedIsTxTime <= 31703 ) { if ( ! ssValue . empty ( ) ) { char fTmp ; char fUnused ; ssValue >> fTmp >> fUnused >> wtx . strFromAccount ; printf ( " LoadWallet ( ) ▁ upgrading ▁ tx ▁ ver = % d ▁ % d ▁ ' % s ' ▁ % s \n " , wtx . fTimeReceivedIsTxTime , fTmp , wtx . strFromAccount . c_str ( ) , hash . ToString ( ) . c_str ( ) ) ; wtx . fTimeReceivedIsTxTime = fTmp ; } else { printf ( " LoadWallet ( ) ▁ repairing ▁ tx ▁ ver = % d ▁ % s \n " , wtx . fTimeReceivedIsTxTime , hash . ToString ( ) . c_str ( ) ) ; wtx . fTimeReceivedIsTxTime = 0 ; } vWalletUpgrade . push_back ( hash ) ; } } else if ( strType == " acentry " ) { string strAccount ; ssKey >> strAccount ; uint64 nNumber ; ssKey >> nNumber ; if ( nNumber > nAccountingEntryNumber ) nAccountingEntryNumber = nNumber ; } else if ( strType == " key " || strType == " wkey " ) { vector < unsigned char > vchPubKey ; ssKey >> vchPubKey ; CWalletKey wkey ; if ( strType == " key " ) ssValue >> wkey . vchPrivKey ; else ssValue >> wkey ; pwallet -> mapKeys [ vchPubKey ] = wkey . vchPrivKey ; mapPubKeys [ Hash160 ( vchPubKey ) ] = vchPubKey ; } else if ( strType == " defaultkey " ) { ssValue >> pwallet -> vchDefaultKey ; } else if ( strType == " pool " ) { int64 nIndex ; ssKey >> nIndex ; pwallet -> setKeyPool . insert ( nIndex ) ; } else if ( strType == " version " ) { ssValue >> nFileVersion ; if ( nFileVersion == 10300 ) nFileVersion = 300 ; } else if ( strType == " setting " ) { string strKey ; ssKey >> strKey ; # ifndef GUI if ( strKey == " fGenerateBitcoins " ) ssValue >> fGenerateBitcoins ; # endif if ( strKey == " nTransactionFee " ) ssValue >> nTransactionFee ; if ( strKey == " addrIncoming " ) ssValue >> addrIncoming ; if ( strKey == " fLimitProcessors " ) ssValue >> fLimitProcessors ; if ( strKey == " nLimitProcessors " ) ssValue >> nLimitProcessors ; if ( strKey == " fMinimizeToTray " ) ssValue >> fMinimizeToTray ; if ( strKey == " fMinimizeOnClose " ) ssValue >> fMinimizeOnClose ; if ( strKey == " fUseProxy " ) ssValue >> fUseProxy ; if ( strKey == " addrProxy " ) ssValue >> addrProxy ; if ( fHaveUPnP && strKey == " fUseUPnP " ) ssValue >> fUseUPnP ; } } pcursor -> close ( ) ; } BOOST_FOREACH ( uint256 hash , vWalletUpgrade ) WriteTx ( hash , pwallet -> mapWallet [ hash ] ) ; printf ( " nFileVersion ▁ = ▁ % d \n " , nFileVersion ) ; printf ( " fGenerateBitcoins ▁ = ▁ % d \n " , fGenerateBitcoins ) ; printf ( " nTransactionFee ▁ = ▁ % " PRI64d " \n " , nTransactionFee ) ; printf ( " addrIncoming ▁ = ▁ % s \n " , addrIncoming . ToString ( ) . c_str ( ) ) ; printf ( " fMinimizeToTray ▁ = ▁ % d \n " , fMinimizeToTray ) ; printf ( " fMinimizeOnClose ▁ = ▁ % d \n " , fMinimizeOnClose ) ; printf ( " fUseProxy ▁ = ▁ % d \n " , fUseProxy ) ; printf ( " addrProxy ▁ = ▁ % s \n " , addrProxy . ToString ( ) . c_str ( ) ) ; if ( fHaveUPnP ) printf ( " fUseUPnP ▁ = ▁ % d \n " , fUseUPnP ) ; if ( nFileVersion < VERSION ) { if ( nFileVersion <= 105 && ! pszSetDataDir [ 0 ] ) unlink ( " debug . log " ) ; WriteVersion ( VERSION ) ; } return true ; } void ThreadFlushWalletDB ( void * parg ) { const string & strFile = ( ( const string * ) parg ) [ 0 ] ; static bool fOneThread ; if ( fOneThread ) return ; fOneThread = true ; if ( mapArgs . count ( " - noflushwallet " ) ) return ; unsigned int nLastSeen = nWalletDBUpdated ; unsigned int nLastFlushed = nWalletDBUpdated ; int64 nLastWalletUpdate = GetTime ( ) ; while ( ! fShutdown ) { Sleep ( 500 ) ; if ( nLastSeen != nWalletDBUpdated ) { nLastSeen = nWalletDBUpdated ; nLastWalletUpdate = GetTime ( ) ; } if ( nLastFlushed != nWalletDBUpdated && GetTime ( ) - nLastWalletUpdate >= 2 ) { TRY_CRITICAL_BLOCK ( cs_db ) { int nRefCount = 0 ; map < string , int > :: iterator mi = mapFileUseCount . begin ( ) ; while ( mi != mapFileUseCount . end ( ) ) { nRefCount += ( * mi ) . second ; mi ++ ; } if ( nRefCount == 0 && ! fShutdown ) { map < string , int > :: iterator mi = mapFileUseCount . find ( strFile ) ; if ( mi != mapFileUseCount . end ( ) ) { printf ( " % s ▁ " , DateTimeStrFormat ( " % x ▁ % H : % M : % S " , GetTime ( ) ) . c_str ( ) ) ; printf ( " Flushing ▁ wallet . dat \n " ) ; nLastFlushed = nWalletDBUpdated ; int64 nStart = GetTimeMillis ( ) ; CloseDb ( strFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; dbenv . lsn_reset ( strFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( mi ++ ) ; printf ( " Flushed ▁ wallet . dat ▁ % " PRI64d " ms \n " , GetTimeMillis ( ) - nStart ) ; } } } } } } bool BackupWallet ( const CWallet & wallet , const string & strDest ) { if ( ! wallet . fFileBacked ) return false ; while ( ! fShutdown ) { CRITICAL_BLOCK ( cs_db ) { if ( ! mapFileUseCount . count ( wallet . strWalletFile ) || mapFileUseCount [ wallet . strWalletFile ] == 0 ) { CloseDb ( wallet . strWalletFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; dbenv . lsn_reset ( wallet . strWalletFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( wallet . strWalletFile ) ; filesystem :: path pathSrc ( GetDataDir ( ) + " / " + wallet . strWalletFile ) ; filesystem :: path pathDest ( strDest ) ; if ( filesystem :: is_directory ( pathDest ) ) pathDest = pathDest / wallet . strWalletFile ; # if BOOST_VERSION >= 104000 filesystem :: copy_file ( pathSrc , pathDest , filesystem :: copy_option :: overwrite_if_exists ) ; # else filesystem :: copy_file ( pathSrc , pathDest ) ; # endif printf ( " copied ▁ wallet . dat ▁ to ▁ % s \n " , pathDest . string ( ) . c_str ( ) ) ; return true ; } } Sleep ( 100 ) ; } return false ; } </DOCUMENT>
<DOCUMENT_ID="android-ia/platform_external_chromium_org_third_party_WebKit/tree/master/Source/core/dom/PseudoElement.cpp"> # include " config . h " # include " core / dom / PseudoElement . h " # include " core / inspector / InspectorInstrumentation . h " # include " core / rendering / RenderObject . h " # include " core / rendering / RenderQuote . h " # include " core / rendering / style / ContentData . h " namespace blink { const QualifiedName & pseudoElementTagName ( PseudoId pseudoId ) { switch ( pseudoId ) { case AFTER : { DEFINE_STATIC_LOCAL ( QualifiedName , after , ( nullAtom , " < pseudo : after > " , nullAtom ) ) ; return after ; } case BEFORE : { DEFINE_STATIC_LOCAL ( QualifiedName , before , ( nullAtom , " < pseudo : before > " , nullAtom ) ) ; return before ; } case BACKDROP : { DEFINE_STATIC_LOCAL ( QualifiedName , backdrop , ( nullAtom , " < pseudo : backdrop > " , nullAtom ) ) ; return backdrop ; } default : { ASSERT_NOT_REACHED ( ) ; } } DEFINE_STATIC_LOCAL ( QualifiedName , name , ( nullAtom , " < pseudo > " , nullAtom ) ) ; return name ; } String PseudoElement :: pseudoElementNameForEvents ( PseudoId pseudoId ) { DEFINE_STATIC_LOCAL ( const String , after , ( " : : after " ) ) ; DEFINE_STATIC_LOCAL ( const String , before , ( " : : before " ) ) ; switch ( pseudoId ) { case AFTER : return after ; case BEFORE : return before ; default : return emptyString ( ) ; } } PseudoElement :: PseudoElement ( Element * parent , PseudoId pseudoId ) : Element ( pseudoElementTagName ( pseudoId ) , & parent -> document ( ) , CreateElement ) , m_pseudoId ( pseudoId ) { ASSERT ( pseudoId != NOPSEUDO ) ; setParentOrShadowHostNode ( parent ) ; setHasCustomStyleCallbacks ( ) ; } PassRefPtr < RenderStyle > PseudoElement :: customStyleForRenderer ( ) { return parentOrShadowHostElement ( ) -> renderer ( ) -> getCachedPseudoStyle ( m_pseudoId ) ; } void PseudoElement :: dispose ( ) { ASSERT ( parentOrShadowHostElement ( ) ) ; InspectorInstrumentation :: pseudoElementDestroyed ( this ) ; ASSERT ( ! nextSibling ( ) ) ; ASSERT ( ! previousSibling ( ) ) ; detach ( ) ; RefPtrWillBeRawPtr < Element > parent = parentOrShadowHostElement ( ) ; setParentOrShadowHostNode ( 0 ) ; removedFrom ( parent . get ( ) ) ; } void PseudoElement :: attach ( const AttachContext & context ) { ASSERT ( ! renderer ( ) ) ; Element :: attach ( context ) ; RenderObject * renderer = this -> renderer ( ) ; if ( ! renderer ) return ; RenderStyle * style = renderer -> style ( ) ; if ( style -> styleType ( ) != BEFORE && style -> styleType ( ) != AFTER ) return ; ASSERT ( style -> contentData ( ) ) ; for ( const ContentData * content = style -> contentData ( ) ; content ; content = content -> next ( ) ) { RenderObject * child = content -> createRenderer ( document ( ) , style ) ; if ( renderer -> isChildAllowed ( child , style ) ) { renderer -> addChild ( child ) ; if ( child -> isQuote ( ) ) toRenderQuote ( child ) -> attachQuote ( ) ; } else child -> destroy ( ) ; } } bool PseudoElement :: rendererIsNeeded ( const RenderStyle & style ) { return pseudoElementRendererIsNeeded ( & style ) ; } void PseudoElement :: didRecalcStyle ( StyleRecalcChange ) { if ( ! renderer ( ) ) return ; RenderObject * renderer = this -> renderer ( ) ; for ( RenderObject * child = renderer -> nextInPreOrder ( renderer ) ; child ; child = child -> nextInPreOrder ( renderer ) ) { if ( ! child -> isText ( ) && ! child -> isQuote ( ) && ! child -> isImage ( ) ) continue ; if ( child -> style ( ) -> styleType ( ) == FIRST_LETTER ) continue ; child -> setPseudoStyle ( renderer -> style ( ) ) ; } } } </DOCUMENT>
<DOCUMENT_ID="CharlieMarshall/xbmc/tree/master/xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagMicroDVD.cpp"> # include " DVDSubtitleTagMicroDVD . h " # include " DVDCodecs / Overlay / DVDOverlayText . h " # include " utils / StdString . h " # include " utils / StringUtils . h " void CDVDSubtitleTagMicroDVD :: ConvertLine ( CDVDOverlayText * pOverlay , const char * line , int len ) { CStdString strUTF8 ; strUTF8 . assign ( line , len ) ; m_flag [ FLAG_BOLD ] = 0 ; m_flag [ FLAG_ITALIC ] = 0 ; m_flag [ FLAG_COLOR ] = 0 ; int machine_status = 1 ; size_t pos = 0 ; while ( machine_status > 0 ) { if ( machine_status == 1 ) { if ( strUTF8 [ pos ] == ' { ' ) { size_t pos2 , pos3 ; if ( ( ( pos2 = strUTF8 . find ( ' : ' , pos ) ) != CStdString :: npos ) && ( ( pos3 = strUTF8 . find ( ' } ' , pos2 ) ) != CStdString :: npos ) ) { CStdString tagName = strUTF8 . substr ( pos + 1 , pos2 - pos - 1 ) ; CStdString tagValue = strUTF8 . substr ( pos2 + 1 , pos3 - pos2 - 1 ) ; StringUtils :: ToLower ( tagValue ) ; strUTF8 . erase ( pos , pos3 - pos + 1 ) ; if ( ( tagName == " Y " ) || ( tagName == " y " ) ) { if ( ( tagValue == " b " ) && ( m_flag [ FLAG_BOLD ] == 0 ) ) { m_flag [ FLAG_BOLD ] = ( tagName == " Y " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , " [ B ] " ) ; pos += 3 ; } else if ( ( tagValue == " i " ) && ( m_flag [ FLAG_ITALIC ] == 0 ) ) { m_flag [ FLAG_ITALIC ] = ( tagName == " Y " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , " [ I ] " ) ; pos += 3 ; } } else if ( ( tagName == " C " ) || ( tagName == " c " ) ) { if ( ( tagValue [ 0 ] == ' $ ' ) && ( tagValue . size ( ) == 7 ) ) { bool bHex = true ; for ( int i = 1 ; i < 7 ; i ++ ) { char temp = tagValue [ i ] ; if ( ! ( ( '0' <= temp && temp <= '9' ) || ( ' a ' <= temp && temp <= ' f ' ) || ( ' A ' <= temp && temp <= ' F ' ) ) ) { bHex = false ; break ; } } if ( bHex && ( m_flag [ FLAG_COLOR ] == 0 ) ) { CStdString tempColorTag = " [ COLOR ▁ " ; tempColorTag += " FF " ; tempColorTag += tagValue . substr ( 1 , 6 ) ; tempColorTag += " ] " ; m_flag [ FLAG_COLOR ] = ( tagName == " C " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , tempColorTag ) ; pos += tempColorTag . length ( ) ; } } } } else machine_status = 2 ; } else if ( strUTF8 [ pos ] == ' / ' ) { if ( m_flag [ FLAG_ITALIC ] == 0 ) { m_flag [ FLAG_ITALIC ] = TAG_ONE_LINE ; strUTF8 . replace ( pos , 1 , " [ I ] " ) ; pos += 3 ; } else strUTF8 . erase ( pos , 1 ) ; } else machine_status = 2 ; } else if ( machine_status == 2 ) { size_t pos4 ; if ( ( pos4 = strUTF8 . find ( ' | ' , pos ) ) != CStdString :: npos ) { pos = pos4 ; if ( m_flag [ FLAG_BOLD ] == TAG_ONE_LINE ) { m_flag [ FLAG_BOLD ] = 0 ; strUTF8 . insert ( pos , " [ / B ] " ) ; pos += 4 ; } if ( m_flag [ FLAG_ITALIC ] == TAG_ONE_LINE ) { m_flag [ FLAG_ITALIC ] = 0 ; strUTF8 . insert ( pos , " [ / I ] " ) ; pos += 4 ; } if ( m_flag [ FLAG_COLOR ] == TAG_ONE_LINE ) { m_flag [ FLAG_COLOR ] = 0 ; strUTF8 . insert ( pos , " [ / COLOR ] " ) ; pos += 8 ; } strUTF8 . replace ( pos , 1 , " [ CR ] " ) ; pos += 4 ; machine_status = 1 ; } else { if ( m_flag [ FLAG_BOLD ] != 0 ) strUTF8 . append ( " [ / B ] " ) ; if ( m_flag [ FLAG_ITALIC ] != 0 ) strUTF8 . append ( " [ / I ] " ) ; if ( m_flag [ FLAG_COLOR ] != 0 ) strUTF8 . append ( " [ / COLOR ] " ) ; machine_status = 0 ; } } } if ( strUTF8 . empty ( ) ) return ; if ( strUTF8 [ strUTF8 . size ( ) - 1 ] == ' \n ' ) strUTF8 . erase ( strUTF8 . size ( ) - 1 ) ; pOverlay -> AddElement ( new CDVDOverlayText :: CElementText ( strUTF8 . c_str ( ) ) ) ; } </DOCUMENT>
<DOCUMENT_ID="Sija/swift/tree/master/Tests/Source/TestValueBool.cpp"> # include " stdafx . h " # include < cppunit / extensions / HelperMacros . h > # include " . . / . . / Source / stdafx . h " # include " . . / . . / Source / values / Bool . h " using namespace Swift ; class TestValueBool : public CPPUNIT_NS :: TestFixture { public : CPPUNIT_TEST_SUITE ( TestValueBool ) ; CPPUNIT_TEST ( testInit ) ; CPPUNIT_TEST ( testAssign ) ; CPPUNIT_TEST ( testGet ) ; CPPUNIT_TEST ( testSetClear ) ; CPPUNIT_TEST ( testOperators ) ; CPPUNIT_TEST_SUITE_END ( ) ; public : void setUp ( ) { } void tearDown ( ) { } protected : void testInit ( ) { CPPUNIT_ASSERT ( iValue :: hasTypeString ( Values :: Bool :: id ) ) ; } void testAssign ( ) { oValue b ( true ) ; CPPUNIT_ASSERT ( b -> getID ( ) == Values :: Bool :: id ) ; } void testGet ( ) { CPPUNIT_ASSERT ( oValue ( true ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ! ( ( Values :: Bool * ) oValue ( false ) . get ( ) ) -> output ( ) ) ; } void testSetClear ( ) { oValue v ( true ) ; v -> clear ( ) ; CPPUNIT_ASSERT ( ! ( v >> bool ( ) ) ) ; Values :: Bool * b = ( Values :: Bool * ) v . get ( ) ; b -> set ( true ) ; CPPUNIT_ASSERT ( v >> bool ( ) ) ; } void testOperators ( ) { CPPUNIT_ASSERT ( ( oValue ( true ) == oValue ( true ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( true ) != oValue ( false ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( true ) && oValue ( true ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( false ) || oValue ( true ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( ! oValue ( true ) == oValue ( false ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( ) << true ) -> getID ( ) == Values :: Bool :: id ) ; CPPUNIT_ASSERT ( ( oValue ( false ) >> bool ( ) ) == false ) ; } } ; CPPUNIT_TEST_SUITE_REGISTRATION ( TestValueBool ) ; </DOCUMENT>
<DOCUMENT_ID="rfloca/MITK/tree/master/Plugins/org.mitk.gui.qt.diffusionimagingapp/src/internal/Perspectives/QmitkDIAppConnectomicsPerspective.cpp"> # include " QmitkDIAppConnectomicsPerspective . h " # include " berryIViewLayout . h " void QmitkDIAppConnectomicsPerspective :: CreateInitialLayout ( berry :: IPageLayout :: Pointer layout ) { std :: string editorArea = layout -> GetEditorArea ( ) ; layout -> AddStandaloneView ( " org . mitk . views . datamanager " , false , berry :: IPageLayout :: LEFT , 0.3f , editorArea ) ; layout -> AddStandaloneView ( " org . mitk . views . controlvisualizationpropertiesview " , false , berry :: IPageLayout :: BOTTOM , .15f , " org . mitk . views . datamanager " ) ; berry :: IFolderLayout :: Pointer left = layout -> CreateFolder ( " org . mbi . diffusionimaginginternal . leftcontrols " , berry :: IPageLayout :: BOTTOM , 0.1f , " org . mitk . views . controlvisualizationpropertiesview " ) ; layout -> AddStandaloneViewPlaceholder ( " org . mitk . views . imagenavigator " , berry :: IPageLayout :: BOTTOM , .4f , " org . mbi . diffusionimaginginternal . leftcontrols " , false ) ; left -> AddView ( " org . mitk . views . connectomicsstatistics " ) ; berry :: IViewLayout :: Pointer lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsstatistics " ) ; lo -> SetCloseable ( false ) ; left -> AddView ( " org . mitk . views . connectomicsnetworkoperations " ) ; lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsnetworkoperations " ) ; lo -> SetCloseable ( false ) ; left -> AddView ( " org . mitk . views . connectomicsdata " ) ; lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsdata " ) ; lo -> SetCloseable ( false ) ; } </DOCUMENT>
<DOCUMENT_ID="asuradaimao/dolphin/tree/master/Source/Core/Core/PowerPC/Interpreter/Interpreter_Integer.cpp"> # include " Core / PowerPC / Interpreter / Interpreter . h " void Interpreter :: Helper_UpdateCR0 ( u32 value ) { s64 sign_extended = ( s64 ) ( s32 ) value ; u64 cr_val = ( u64 ) sign_extended ; cr_val = ( cr_val & ~ ( 1ull << 61 ) ) | ( ( u64 ) GetXER_SO ( ) << 61 ) ; PowerPC :: ppcState . cr_val [ 0 ] = cr_val ; } void Interpreter :: Helper_UpdateCRx ( int idx , u32 value ) { s64 sign_extended = ( s64 ) ( s32 ) value ; u64 cr_val = ( u64 ) sign_extended ; cr_val = ( cr_val & ~ ( 1ull << 61 ) ) | ( ( u64 ) GetXER_SO ( ) << 61 ) ; PowerPC :: ppcState . cr_val [ idx ] = cr_val ; } u32 Interpreter :: Helper_Carry ( u32 _uValue1 , u32 _uValue2 ) { return _uValue2 > ( ~ _uValue1 ) ; } u32 Interpreter :: Helper_Mask ( int mb , int me ) { u32 begin = 0xFFFFFFFF >> mb ; u32 end = me < 31 ? ( 0xFFFFFFFF >> ( me + 1 ) ) : 0 ; u32 mask = begin ^ end ; if ( me < mb ) return ~ mask ; else return mask ; } void Interpreter :: addi ( UGeckoInstruction _inst ) { if ( _inst . RA ) rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + _inst . SIMM_16 ; else rGPR [ _inst . RD ] = _inst . SIMM_16 ; } void Interpreter :: addic ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 imm = ( u32 ) ( s32 ) _inst . SIMM_16 ; rGPR [ _inst . RD ] = a + imm ; SetCarry ( Helper_Carry ( a , imm ) ) ; } void Interpreter :: addic_rc ( UGeckoInstruction _inst ) { addic ( _inst ) ; Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addis ( UGeckoInstruction _inst ) { if ( _inst . RA ) rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + ( _inst . SIMM_16 << 16 ) ; else rGPR [ _inst . RD ] = ( _inst . SIMM_16 << 16 ) ; } void Interpreter :: andi_rc ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & _inst . UIMM ; Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: andis_rc ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & ( ( u32 ) _inst . UIMM << 16 ) ; Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: cmpi ( UGeckoInstruction _inst ) { Helper_UpdateCRx ( _inst . CRFD , rGPR [ _inst . RA ] - _inst . SIMM_16 ) ; } void Interpreter :: cmpli ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = _inst . UIMM ; int f ; if ( a < b ) f = 0x8 ; else if ( a > b ) f = 0x4 ; else f = 0x2 ; if ( GetXER_SO ( ) ) f |= 0x1 ; SetCRField ( _inst . CRFD , f ) ; } void Interpreter :: mulli ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = ( s32 ) rGPR [ _inst . RA ] * _inst . SIMM_16 ; } void Interpreter :: ori ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | _inst . UIMM ; } void Interpreter :: oris ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | ( _inst . UIMM << 16 ) ; } void Interpreter :: subfic ( UGeckoInstruction _inst ) { s32 immediate = _inst . SIMM_16 ; rGPR [ _inst . RD ] = immediate - ( int ) rGPR [ _inst . RA ] ; SetCarry ( ( rGPR [ _inst . RA ] == 0 ) || ( Helper_Carry ( 0 - rGPR [ _inst . RA ] , immediate ) ) ) ; } void Interpreter :: twi ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = _inst . SIMM_16 ; s32 TO = _inst . TO ; DEBUG_LOG ( POWERPC , " twi ▁ rA ▁ % x ▁ SIMM ▁ % x ▁ TO ▁ % 0x " , a , b , TO ) ; if ( ( ( a < b ) && ( TO & 0x10 ) ) || ( ( a > b ) && ( TO & 0x08 ) ) || ( ( a == b ) && ( TO & 0x04 ) ) || ( ( ( u32 ) a < ( u32 ) b ) && ( TO & 0x02 ) ) || ( ( ( u32 ) a > ( u32 ) b ) && ( TO & 0x01 ) ) ) { PowerPC :: ppcState . Exceptions |= EXCEPTION_PROGRAM ; PowerPC :: CheckExceptions ( ) ; m_EndBlock = true ; } } void Interpreter :: xori ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ _inst . UIMM ; } void Interpreter :: xoris ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ ( _inst . UIMM << 16 ) ; } void Interpreter :: rlwimix ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = ( rGPR [ _inst . RA ] & ~ mask ) | ( _rotl ( rGPR [ _inst . RS ] , _inst . SH ) & mask ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: rlwinmx ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = _rotl ( rGPR [ _inst . RS ] , _inst . SH ) & mask ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: rlwnmx ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = _rotl ( rGPR [ _inst . RS ] , rGPR [ _inst . RB ] & 0x1F ) & mask ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: andx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: andcx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & ~ rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: cmp ( UGeckoInstruction _inst ) { s32 a = ( s32 ) rGPR [ _inst . RA ] ; s32 b = ( s32 ) rGPR [ _inst . RB ] ; int fTemp ; if ( a < b ) fTemp = 0x8 ; else if ( a > b ) fTemp = 0x4 ; else fTemp = 0x2 ; if ( GetXER_SO ( ) ) fTemp |= 0x1 ; SetCRField ( _inst . CRFD , fTemp ) ; } void Interpreter :: cmpl ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 fTemp ; if ( a < b ) fTemp = 0x8 ; else if ( a > b ) fTemp = 0x4 ; else fTemp = 0x2 ; if ( GetXER_SO ( ) ) fTemp |= 0x1 ; SetCRField ( _inst . CRFD , fTemp ) ; } void Interpreter :: cntlzwx ( UGeckoInstruction _inst ) { u32 val = rGPR [ _inst . RS ] ; u32 mask = 0x80000000 ; int i = 0 ; for ( ; i < 32 ; i ++ , mask >>= 1 ) { if ( val & mask ) break ; } rGPR [ _inst . RA ] = i ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: eqvx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] ^ rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: extsbx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ( u32 ) ( s32 ) ( s8 ) rGPR [ _inst . RS ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: extshx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ( u32 ) ( s32 ) ( s16 ) rGPR [ _inst . RS ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: nandx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] & rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: norx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] | rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: orx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: orcx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | ( ~ rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: slwx ( UGeckoInstruction _inst ) { u32 amount = rGPR [ _inst . RB ] ; rGPR [ _inst . RA ] = ( amount & 0x20 ) ? 0 : rGPR [ _inst . RS ] << ( amount & 0x1f ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: srawx ( UGeckoInstruction _inst ) { int rb = rGPR [ _inst . RB ] ; if ( rb & 0x20 ) { if ( rGPR [ _inst . RS ] & 0x80000000 ) { rGPR [ _inst . RA ] = 0xFFFFFFFF ; SetCarry ( 1 ) ; } else { rGPR [ _inst . RA ] = 0x00000000 ; SetCarry ( 0 ) ; } } else { int amount = rb & 0x1f ; if ( amount == 0 ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ; SetCarry ( 0 ) ; } else { s32 rrs = rGPR [ _inst . RS ] ; rGPR [ _inst . RA ] = rrs >> amount ; if ( ( rrs < 0 ) && ( rrs << ( 32 - amount ) ) ) SetCarry ( 1 ) ; else SetCarry ( 0 ) ; } } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: srawix ( UGeckoInstruction _inst ) { int amount = _inst . SH ; if ( amount != 0 ) { s32 rrs = rGPR [ _inst . RS ] ; rGPR [ _inst . RA ] = rrs >> amount ; if ( ( rrs < 0 ) && ( rrs << ( 32 - amount ) ) ) SetCarry ( 1 ) ; else SetCarry ( 0 ) ; } else { SetCarry ( 0 ) ; rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: srwx ( UGeckoInstruction _inst ) { u32 amount = rGPR [ _inst . RB ] ; rGPR [ _inst . RA ] = ( amount & 0x20 ) ? 0 : ( rGPR [ _inst . RS ] >> ( amount & 0x1f ) ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: tw ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = rGPR [ _inst . RB ] ; s32 TO = _inst . TO ; DEBUG_LOG ( POWERPC , " tw ▁ rA ▁ % 0x ▁ rB ▁ % 0x ▁ TO ▁ % 0x " , a , b , TO ) ; if ( ( ( a < b ) && ( TO & 0x10 ) ) || ( ( a > b ) && ( TO & 0x08 ) ) || ( ( a == b ) && ( TO & 0x04 ) ) || ( ( ( u32 ) a < ( u32 ) b ) && ( TO & 0x02 ) ) || ( ( ( u32 ) a > ( u32 ) b ) && ( TO & 0x01 ) ) ) { PowerPC :: ppcState . Exceptions |= EXCEPTION_PROGRAM ; PowerPC :: CheckExceptions ( ) ; m_EndBlock = true ; } } void Interpreter :: xorx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: addx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + rGPR [ _inst . RB ] ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addcx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = a + b ; SetCarry ( Helper_Carry ( a , b ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addcx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; int b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = a + b + carry ; SetCarry ( Helper_Carry ( a , b ) || ( carry != 0 && Helper_Carry ( a + b , carry ) ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addmex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; rGPR [ _inst . RD ] = a + carry - 1 ; SetCarry ( Helper_Carry ( a , carry - 1 ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addmex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addzex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; rGPR [ _inst . RD ] = a + carry ; SetCarry ( Helper_Carry ( a , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addzex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: divwx ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = rGPR [ _inst . RB ] ; if ( b == 0 || ( ( u32 ) a == 0x80000000 && b == - 1 ) ) { if ( _inst . OE ) { PanicAlert ( " OE : ▁ divwx " ) ; } if ( ( ( u32 ) a & 0x80000000 ) && b == 0 ) rGPR [ _inst . RD ] = - 1 ; else rGPR [ _inst . RD ] = 0 ; } else { rGPR [ _inst . RD ] = ( u32 ) ( a / b ) ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: divwux ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; if ( b == 0 ) { if ( _inst . OE ) { PanicAlert ( " OE : ▁ divwux " ) ; } rGPR [ _inst . RD ] = 0 ; } else { rGPR [ _inst . RD ] = a / b ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: mulhwx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( u64 ) ( ( ( s64 ) ( s32 ) a * ( s64 ) ( s32 ) b ) ) >> 32 ) ; rGPR [ _inst . RD ] = d ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: mulhwux ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( ( u64 ) a * ( u64 ) b ) >> 32 ) ; rGPR [ _inst . RD ] = d ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: mullwx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( s32 ) a * ( s32 ) b ) ; rGPR [ _inst . RD ] = d ; if ( _inst . OE ) PanicAlert ( " OE : ▁ mullwx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: negx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = ( ~ rGPR [ _inst . RA ] ) + 1 ; if ( rGPR [ _inst . RD ] == 0x80000000 ) { if ( _inst . OE ) PanicAlert ( " OE : ▁ negx " ) ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = rGPR [ _inst . RB ] - rGPR [ _inst . RA ] ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfcx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = b - a ; SetCarry ( a == 0 || Helper_Carry ( b , 0 - a ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfcx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + b + carry ; SetCarry ( Helper_Carry ( ~ a , b ) || Helper_Carry ( ( ~ a ) + b , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfmex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + carry - 1 ; SetCarry ( Helper_Carry ( ~ a , carry - 1 ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfmex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfzex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + carry ; SetCarry ( Helper_Carry ( ~ a , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfzex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } </DOCUMENT>
<DOCUMENT_ID="grzegorz2047/HotelReservation/tree/master/fileio.cpp"> # include < stdio . h > # include < string > # include < stdlib . h > # include < time . h > # include < sstream > # include < fstream > # include < vector > # include < iostream > std :: vector < std :: string > readFile ( std :: string filename ) { std :: vector < std :: string > lines ; std :: ifstream read ; std :: string line ; read . open ( filename . c_str ( ) ) ; if ( ! read . good ( ) ) { read . close ( ) ; std :: ofstream create ; create . open ( filename . c_str ( ) ) ; return lines ; } while ( ! read . eof ( ) ) { getline ( read , line ) ; if ( line != " " ) { lines . push_back ( line ) ; } } read . close ( ) ; return lines ; } void saveFile ( std :: string filename , std :: vector < std :: string > lines ) { std :: ofstream save ; save . open ( filename . c_str ( ) ) ; for ( int i = 0 ; i < lines . size ( ) ; i ++ ) { save << lines [ i ] << std :: endl ; } save . close ( ) ; } </DOCUMENT>
<DOCUMENT_ID="attilahorvath/phantomjs/tree/master/src/qt/qtwebkit/Source/JavaScriptCore/llint/LLIntEntrypoints.cpp"> # include " config . h " # include " LLIntEntrypoints . h " # if ENABLE ( LLINT ) # include " JITCode . h " # include " VM . h " # include " JSObject . h " # include " LLIntThunks . h " # include " LowLevelInterpreter . h " namespace JSC { namespace LLInt { void getFunctionEntrypoint ( VM & vm , CodeSpecializationKind kind , JITCode & jitCode , MacroAssemblerCodePtr & arityCheck ) { if ( ! vm . canUseJIT ( ) ) { if ( kind == CodeForCall ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_function_for_call_prologue ) , JITCode :: InterpreterThunk ) ; arityCheck = MacroAssemblerCodePtr :: createLLIntCodePtr ( llint_function_for_call_arity_check ) ; return ; } ASSERT ( kind == CodeForConstruct ) ; jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_function_for_construct_prologue ) , JITCode :: InterpreterThunk ) ; arityCheck = MacroAssemblerCodePtr :: createLLIntCodePtr ( llint_function_for_construct_arity_check ) ; return ; } # if ENABLE ( JIT ) if ( kind == CodeForCall ) { jitCode = JITCode ( vm . getCTIStub ( functionForCallEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; arityCheck = vm . getCTIStub ( functionForCallArityCheckThunkGenerator ) . code ( ) ; return ; } ASSERT ( kind == CodeForConstruct ) ; jitCode = JITCode ( vm . getCTIStub ( functionForConstructEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; arityCheck = vm . getCTIStub ( functionForConstructArityCheckThunkGenerator ) . code ( ) ; # endif } void getEvalEntrypoint ( VM & vm , JITCode & jitCode ) { if ( ! vm . canUseJIT ( ) ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_eval_prologue ) , JITCode :: InterpreterThunk ) ; return ; } # if ENABLE ( JIT ) jitCode = JITCode ( vm . getCTIStub ( evalEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; # endif } void getProgramEntrypoint ( VM & vm , JITCode & jitCode ) { if ( ! vm . canUseJIT ( ) ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_program_prologue ) , JITCode :: InterpreterThunk ) ; return ; } # if ENABLE ( JIT ) jitCode = JITCode ( vm . getCTIStub ( programEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; # endif } } } # endif </DOCUMENT>
<DOCUMENT_ID="Hankuo/color-emoji.skia/tree/master/src/gpu/gl/unix/GrGLCreateNativeInterface_unix.cpp"> # include " gl / GrGLExtensions . h " # include " gl / GrGLInterface . h " # include " . . / GrGLUtil . h " # include < GL / glx . h > # include < GL / gl . h > # include < GL / glext . h > # include < GL / glu . h > # define GR_GL_GET_PROC ( F ) interface -> f ## F = ( GrGL ## F ## Proc ) glXGetProcAddress ( reinterpret_cast < const GLubyte * > ( " gl " # F ) ) ; # define GR_GL_GET_PROC_SUFFIX ( F , S ) interface -> f ## F = ( GrGL ## F ## Proc ) glXGetProcAddress ( reinterpret_cast < const GLubyte * > ( " gl " # F # S ) ) ; const GrGLInterface * GrGLCreateNativeInterface ( ) { if ( NULL != glXGetCurrentContext ( ) ) { const char * versionString = ( const char * ) glGetString ( GL_VERSION ) ; GrGLVersion glVer = GrGLGetVersionFromString ( versionString ) ; GrGLGetStringiProc glGetStringi = ( GrGLGetStringiProc ) glXGetProcAddress ( reinterpret_cast < const GLubyte * > ( " glGetStringi " ) ) ; GrGLExtensions extensions ; if ( ! extensions . init ( kDesktop_GrGLBinding , glGetString , glGetStringi , glGetIntegerv ) ) { return NULL ; } if ( glVer < GR_GL_VER ( 1 , 5 ) ) { return NULL ; } GrGLInterface * interface = new GrGLInterface ( ) ; interface -> fActiveTexture = glActiveTexture ; GR_GL_GET_PROC ( AttachShader ) ; GR_GL_GET_PROC ( BindAttribLocation ) ; GR_GL_GET_PROC ( BindBuffer ) ; GR_GL_GET_PROC ( BindFragDataLocation ) ; GR_GL_GET_PROC ( BeginQuery ) ; interface -> fBindTexture = glBindTexture ; interface -> fBlendFunc = glBlendFunc ; if ( glVer >= GR_GL_VER ( 1 , 4 ) || extensions . has ( " GL _ ARB _ imaging " ) || extensions . has ( " GL _ EXT _ blend _ color " ) ) { GR_GL_GET_PROC ( BlendColor ) ; } GR_GL_GET_PROC ( BufferData ) ; GR_GL_GET_PROC ( BufferSubData ) ; interface -> fClear = glClear ; interface -> fClearColor = glClearColor ; interface -> fClearStencil = glClearStencil ; interface -> fColorMask = glColorMask ; GR_GL_GET_PROC ( CompileShader ) ; interface -> fCompressedTexImage2D = glCompressedTexImage2D ; interface -> fCopyTexSubImage2D = glCopyTexSubImage2D ; GR_GL_GET_PROC ( CreateProgram ) ; GR_GL_GET_PROC ( CreateShader ) ; interface -> fCullFace = glCullFace ; GR_GL_GET_PROC ( DeleteBuffers ) ; GR_GL_GET_PROC ( DeleteProgram ) ; GR_GL_GET_PROC ( DeleteQueries ) ; GR_GL_GET_PROC ( DeleteShader ) ; interface -> fDeleteTextures = glDeleteTextures ; interface -> fDepthMask = glDepthMask ; interface -> fDisable = glDisable ; GR_GL_GET_PROC ( DisableVertexAttribArray ) ; interface -> fDrawArrays = glDrawArrays ; interface -> fDrawBuffer = glDrawBuffer ; GR_GL_GET_PROC ( DrawBuffers ) ; interface -> fDrawElements = glDrawElements ; interface -> fEnable = glEnable ; GR_GL_GET_PROC ( EnableVertexAttribArray ) ; GR_GL_GET_PROC ( EndQuery ) ; interface -> fFinish = glFinish ; interface -> fFlush = glFlush ; interface -> fFrontFace = glFrontFace ; GR_GL_GET_PROC ( GenBuffers ) ; GR_GL_GET_PROC ( GetBufferParameteriv ) ; interface -> fGetError = glGetError ; interface -> fGetIntegerv = glGetIntegerv ; GR_GL_GET_PROC ( GetQueryObjectiv ) ; GR_GL_GET_PROC ( GetQueryObjectuiv ) ; if ( glVer >= GR_GL_VER ( 3 , 3 ) || extensions . has ( " GL _ ARB _ timer _ query " ) ) { GR_GL_GET_PROC ( GetQueryObjecti64v ) ; GR_GL_GET_PROC ( GetQueryObjectui64v ) ; GR_GL_GET_PROC ( QueryCounter ) ; } else if ( extensions . has ( " GL _ EXT _ timer _ query " ) ) { GR_GL_GET_PROC_SUFFIX ( GetQueryObjecti64v , EXT ) ; GR_GL_GET_PROC_SUFFIX ( GetQueryObjectui64v , EXT ) ; } GR_GL_GET_PROC ( GetQueryiv ) ; GR_GL_GET_PROC ( GetProgramInfoLog ) ; GR_GL_GET_PROC ( GetProgramiv ) ; GR_GL_GET_PROC ( GetShaderInfoLog ) ; GR_GL_GET_PROC ( GetShaderiv ) ; interface -> fGetString = glGetString ; GR_GL_GET_PROC ( GetStringi ) ; interface -> fGetTexLevelParameteriv = glGetTexLevelParameteriv ; GR_GL_GET_PROC ( GenQueries ) ; interface -> fGenTextures = glGenTextures ; GR_GL_GET_PROC ( GetUniformLocation ) ; interface -> fLineWidth = glLineWidth ; GR_GL_GET_PROC ( LinkProgram ) ; GR_GL_GET_PROC ( MapBuffer ) ; interface -> fPixelStorei = glPixelStorei ; interface -> fReadBuffer = glReadBuffer ; interface -> fReadPixels = glReadPixels ; if ( extensions . has ( " GL _ NV _ framebuffer _ multisample _ coverage " ) ) { GR_GL_GET_PROC_SUFFIX ( RenderbufferStorageMultisampleCoverage , NV ) ; } interface -> fScissor = glScissor ; GR_GL_GET_PROC ( ShaderSource ) ; interface -> fStencilFunc = glStencilFunc ; GR_GL_GET_PROC ( StencilFuncSeparate ) ; interface -> fStencilMask = glStencilMask ; GR_GL_GET_PROC ( StencilMaskSeparate ) ; interface -> fStencilOp = glStencilOp ; GR_GL_GET_PROC ( StencilOpSeparate ) ; interface -> fTexImage2D = glTexImage2D ; interface -> fTexParameteri = glTexParameteri ; interface -> fTexParameteriv = glTexParameteriv ; if ( glVer >= GR_GL_VER ( 4 , 2 ) || extensions . has ( " GL _ ARB _ texture _ storage " ) ) { GR_GL_GET_PROC ( TexStorage2D ) ; } else if ( extensions . has ( " GL _ EXT _ texture _ storage " ) ) { GR_GL_GET_PROC_SUFFIX ( TexStorage2D , EXT ) ; } interface -> fTexSubImage2D = glTexSubImage2D ; GR_GL_GET_PROC ( Uniform1f ) ; GR_GL_GET_PROC ( Uniform1i ) ; GR_GL_GET_PROC ( Uniform1fv ) ; GR_GL_GET_PROC ( Uniform1iv ) ; GR_GL_GET_PROC ( Uniform2f ) ; GR_GL_GET_PROC ( Uniform2i ) ; GR_GL_GET_PROC ( Uniform2fv ) ; GR_GL_GET_PROC ( Uniform2iv ) ; GR_GL_GET_PROC ( Uniform3f ) ; GR_GL_GET_PROC ( Uniform3i ) ; GR_GL_GET_PROC ( Uniform3fv ) ; GR_GL_GET_PROC ( Uniform3iv ) ; GR_GL_GET_PROC ( Uniform4f ) ; GR_GL_GET_PROC ( Uniform4i ) ; GR_GL_GET_PROC ( Uniform4fv ) ; GR_GL_GET_PROC ( Uniform4iv ) ; GR_GL_GET_PROC ( UniformMatrix2fv ) ; GR_GL_GET_PROC ( UniformMatrix3fv ) ; GR_GL_GET_PROC ( UniformMatrix4fv ) ; GR_GL_GET_PROC ( UnmapBuffer ) ; GR_GL_GET_PROC ( UseProgram ) ; GR_GL_GET_PROC ( VertexAttrib4fv ) ; GR_GL_GET_PROC ( VertexAttribPointer ) ; interface -> fViewport = glViewport ; GR_GL_GET_PROC ( BindFragDataLocationIndexed ) ; if ( glVer >= GR_GL_VER ( 3 , 0 ) || extensions . has ( " GL _ ARB _ vertex _ array _ object " ) ) { GR_GL_GET_PROC ( BindVertexArray ) ; GR_GL_GET_PROC ( GenVertexArrays ) ; GR_GL_GET_PROC ( DeleteVertexArrays ) ; } if ( glVer >= GR_GL_VER ( 3 , 0 ) || extensions . has ( " GL _ ARB _ framebuffer _ object " ) ) { GR_GL_GET_PROC ( GenFramebuffers ) ; GR_GL_GET_PROC ( GetFramebufferAttachmentParameteriv ) ; GR_GL_GET_PROC ( GetRenderbufferParameteriv ) ; GR_GL_GET_PROC ( BindFramebuffer ) ; GR_GL_GET_PROC ( FramebufferTexture2D ) ; GR_GL_GET_PROC ( CheckFramebufferStatus ) ; GR_GL_GET_PROC ( DeleteFramebuffers ) ; GR_GL_GET_PROC ( RenderbufferStorage ) ; GR_GL_GET_PROC ( GenRenderbuffers ) ; GR_GL_GET_PROC ( DeleteRenderbuffers ) ; GR_GL_GET_PROC ( FramebufferRenderbuffer ) ; GR_GL_GET_PROC ( BindRenderbuffer ) ; GR_GL_GET_PROC ( RenderbufferStorageMultisample ) ; GR_GL_GET_PROC ( BlitFramebuffer ) ; } else if ( extensions . has ( " GL _ EXT _ framebuffer _ object " ) ) { GR_GL_GET_PROC_SUFFIX ( GenFramebuffers , EXT ) ; GR_GL_GET_PROC_SUFFIX ( GetFramebufferAttachmentParameteriv , EXT ) ; GR_GL_GET_PROC_SUFFIX ( GetRenderbufferParameteriv , EXT ) ; GR_GL_GET_PROC_SUFFIX ( BindFramebuffer , EXT ) ; GR_GL_GET_PROC_SUFFIX ( FramebufferTexture2D , EXT ) ; GR_GL_GET_PROC_SUFFIX ( CheckFramebufferStatus , EXT ) ; GR_GL_GET_PROC_SUFFIX ( DeleteFramebuffers , EXT ) ; GR_GL_GET_PROC_SUFFIX ( RenderbufferStorage , EXT ) ; GR_GL_GET_PROC_SUFFIX ( GenRenderbuffers , EXT ) ; GR_GL_GET_PROC_SUFFIX ( DeleteRenderbuffers , EXT ) ; GR_GL_GET_PROC_SUFFIX ( FramebufferRenderbuffer , EXT ) ; GR_GL_GET_PROC_SUFFIX ( BindRenderbuffer , EXT ) ; if ( extensions . has ( " GL _ EXT _ framebuffer _ multisample " ) ) { GR_GL_GET_PROC_SUFFIX ( RenderbufferStorageMultisample , EXT ) ; } if ( extensions . has ( " GL _ EXT _ framebuffer _ blit " ) ) { GR_GL_GET_PROC_SUFFIX ( BlitFramebuffer , EXT ) ; } } else { delete interface ; return NULL ; } interface -> fBindingsExported = kDesktop_GrGLBinding ; return interface ; } else { return NULL ; } } </DOCUMENT>
<DOCUMENT_ID="Roxtedy/SkyFire_6xx/tree/master/src/server/game/Handlers/TicketHandler.cpp"> # include " zlib . h " # include " Common . h " # include " Language . h " # include " ObjectMgr . h " # include " Opcodes . h " # include " Player . h " # include " TicketMgr . h " # include " Util . h " # include " World . h " # include " WorldPacket . h " # include " WorldSession . h " void WorldSession :: HandleGMTicketCreateOpcode ( WorldPacket & recvData ) { if ( sTicketMgr -> GetStatus ( ) == GMTICKET_QUEUE_STATUS_DISABLED ) return ; if ( GetPlayer ( ) -> getLevel ( ) < sWorld -> getIntConfig ( CONFIG_TICKET_LEVEL_REQ ) ) { SendNotification ( GetTrinityString ( LANG_TICKET_REQ ) , sWorld -> getIntConfig ( CONFIG_TICKET_LEVEL_REQ ) ) ; return ; } GMTicketResponse response = GMTICKET_RESPONSE_CREATE_ERROR ; GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ; if ( ticket && ticket -> IsCompleted ( ) ) sTicketMgr -> CloseTicket ( ticket -> GetId ( ) , GetPlayer ( ) -> GetGUID ( ) ) ; ; if ( ! ticket || ticket -> IsClosed ( ) ) { ticket = new GmTicket ( GetPlayer ( ) , recvData ) ; uint32 count ; std :: list < uint32 > times ; uint32 decompressedSize ; std :: string chatLog ; recvData >> count ; for ( uint32 i = 0 ; i < count ; i ++ ) { uint32 time ; recvData >> time ; times . push_back ( time ) ; } recvData >> decompressedSize ; if ( count && decompressedSize && decompressedSize < 0xFFFF ) { uint32 pos = recvData . rpos ( ) ; ByteBuffer dest ; dest . resize ( decompressedSize ) ; uLongf realSize = decompressedSize ; if ( uncompress ( dest . contents ( ) , & realSize , recvData . contents ( ) + pos , recvData . size ( ) - pos ) == Z_OK ) { dest >> chatLog ; ticket -> SetChatLog ( times , chatLog ) ; } else { TC_LOG_ERROR ( " network " , " CMSG _ GMTICKET _ CREATE ▁ possibly ▁ corrupt . ▁ Uncompression ▁ failed . " ) ; recvData . rfinish ( ) ; delete ticket ; return ; } recvData . rfinish ( ) ; } sTicketMgr -> AddTicket ( ticket ) ; sTicketMgr -> UpdateLastChange ( ) ; sWorld -> SendGMText ( LANG_COMMAND_TICKETNEW , GetPlayer ( ) -> GetName ( ) . c_str ( ) , ticket -> GetId ( ) ) ; response = GMTICKET_RESPONSE_CREATE_SUCCESS ; } WorldPacket data ( SMSG_GMTICKET_CREATE , 4 ) ; data << uint32 ( response ) ; SendPacket ( & data ) ; } void WorldSession :: HandleGMTicketUpdateOpcode ( WorldPacket & recvData ) { std :: string message ; recvData >> message ; GMTicketResponse response = GMTICKET_RESPONSE_UPDATE_ERROR ; if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { SQLTransaction trans = SQLTransaction ( NULL ) ; ticket -> SetMessage ( message ) ; ticket -> SaveToDB ( trans ) ; sWorld -> SendGMText ( LANG_COMMAND_TICKETUPDATED , GetPlayer ( ) -> GetName ( ) . c_str ( ) , ticket -> GetId ( ) ) ; response = GMTICKET_RESPONSE_UPDATE_SUCCESS ; } WorldPacket data ( SMSG_GMTICKET_UPDATETEXT , 4 ) ; data << uint32 ( response ) ; SendPacket ( & data ) ; } void WorldSession :: HandleGMTicketDeleteOpcode ( WorldPacket & ) { if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { WorldPacket data ( SMSG_GMTICKET_DELETETICKET , 4 ) ; data << uint32 ( GMTICKET_RESPONSE_TICKET_DELETED ) ; SendPacket ( & data ) ; sWorld -> SendGMText ( LANG_COMMAND_TICKETPLAYERABANDON , GetPlayer ( ) -> GetName ( ) . c_str ( ) , ticket -> GetId ( ) ) ; sTicketMgr -> CloseTicket ( ticket -> GetId ( ) , GetPlayer ( ) -> GetGUID ( ) ) ; sTicketMgr -> SendTicket ( this , NULL ) ; } } void WorldSession :: HandleGMTicketGetTicketOpcode ( WorldPacket & ) { SendQueryTimeResponse ( ) ; if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { if ( ticket -> IsCompleted ( ) ) ticket -> SendResponse ( this ) ; else sTicketMgr -> SendTicket ( this , ticket ) ; } else sTicketMgr -> SendTicket ( this , NULL ) ; } void WorldSession :: HandleGMTicketSystemStatusOpcode ( WorldPacket & ) { WorldPacket data ( SMSG_GMTICKET_SYSTEMSTATUS , 4 ) ; data << uint32 ( sTicketMgr -> GetStatus ( ) ? GMTICKET_QUEUE_STATUS_ENABLED : GMTICKET_QUEUE_STATUS_DISABLED ) ; SendPacket ( & data ) ; } void WorldSession :: HandleGMSurveySubmit ( WorldPacket & recvData ) { uint32 nextSurveyID = sTicketMgr -> GetNextSurveyID ( ) ; uint32 mainSurvey ; recvData >> mainSurvey ; for ( uint8 i = 0 ; i < 15 ; i ++ ) { uint32 subSurveyId ; recvData >> subSurveyId ; if ( ! subSurveyId ) break ; uint8 rank ; recvData >> rank ; std :: string comment ; recvData >> comment ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_GM_SUBSURVEY ) ; stmt -> setUInt32 ( 0 , nextSurveyID ) ; stmt -> setUInt32 ( 1 , subSurveyId ) ; stmt -> setUInt32 ( 2 , rank ) ; stmt -> setString ( 3 , comment ) ; CharacterDatabase . Execute ( stmt ) ; } std :: string comment ; recvData >> comment ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_GM_SURVEY ) ; stmt -> setUInt32 ( 0 , GUID_LOPART ( GetPlayer ( ) -> GetGUID ( ) ) ) ; stmt -> setUInt32 ( 1 , nextSurveyID ) ; stmt -> setUInt32 ( 2 , mainSurvey ) ; stmt -> setString ( 3 , comment ) ; CharacterDatabase . Execute ( stmt ) ; } void WorldSession :: HandleReportLag ( WorldPacket & recvData ) { uint32 lagType , mapId ; recvData >> lagType ; recvData >> mapId ; float x , y , z ; recvData >> x ; recvData >> y ; recvData >> z ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_LAG_REPORT ) ; stmt -> setUInt32 ( 0 , GUID_LOPART ( GetPlayer ( ) -> GetGUID ( ) ) ) ; stmt -> setUInt8 ( 1 , lagType ) ; stmt -> setUInt16 ( 2 , mapId ) ; stmt -> setFloat ( 3 , x ) ; stmt -> setFloat ( 4 , y ) ; stmt -> setFloat ( 5 , z ) ; stmt -> setUInt32 ( 6 , GetLatency ( ) ) ; stmt -> setUInt32 ( 7 , time ( NULL ) ) ; CharacterDatabase . Execute ( stmt ) ; } void WorldSession :: HandleGMResponseResolve ( WorldPacket & ) { if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { uint8 getSurvey = 0 ; if ( float ( rand_chance ( ) ) < sWorld -> getFloatConfig ( CONFIG_CHANCE_OF_GM_SURVEY ) ) getSurvey = 1 ; WorldPacket data ( SMSG_GMRESPONSE_STATUS_UPDATE , 4 ) ; data << uint8 ( getSurvey ) ; SendPacket ( & data ) ; WorldPacket data2 ( SMSG_GMTICKET_DELETETICKET , 4 ) ; data2 << uint32 ( GMTICKET_RESPONSE_TICKET_DELETED ) ; SendPacket ( & data2 ) ; sTicketMgr -> CloseTicket ( ticket -> GetId ( ) , GetPlayer ( ) -> GetGUID ( ) ) ; sTicketMgr -> SendTicket ( this , NULL ) ; } } </DOCUMENT>
<DOCUMENT_ID="AdmiralCurtiss/ppsspp/tree/master/unittest/UnitTest.cpp"> # include < cstdio > # include < cstdlib > # include < cmath > # include < string > # include < sstream > # include " base / NativeApp . h " # include " base / logging . h " # include " Common / CPUDetect . h " # include " Common / ArmEmitter . h " # include " ext / disarm . h " # include " math / math _ util . h " # include " util / text / parsers . h " # include " Core / Config . h " # include " Core / MIPS / MIPSVFPUUtils . h " # include " Core / FileSystems / ISOFileSystem . h " # include " unittest / JitHarness . h " # include " unittest / TestVertexJit . h " # include " unittest / UnitTest . h " std :: string System_GetProperty ( SystemProperty prop ) { return " " ; } int System_GetPropertyInt ( SystemProperty prop ) { return - 1 ; } void NativeMessageReceived ( const char * message , const char * value ) { } void GL_SwapInterval ( int ) { } # ifndef M_PI_2 # define M_PI_2 1.57079632679489661923 # endif float fastasin ( double x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; float sqrtthing = sqrt ( 1.0f - x * x ) ; float y = - .3572142480f + .1087063463f * x ; y = y * x + 1.062519236f ; y = y * x + - 2.511278506f ; y = y * x + .191900116f ; y = y * x + 1.807607311f ; y /= ( 1.807607311f - 1.615195094 * x ) ; return sign * ( y - sqrtthing ) ; } double atan_66s ( double x ) { const double c1 = 1.6867629106 ; const double c2 = 0.4378497304 ; const double c3 = 1.6867633134 ; double x2 ; x2 = x * x ; return ( x * ( c1 + x2 * c2 ) / ( c3 + x2 ) ) ; } double fastasin2 ( double x ) { return atan_66s ( x / sqrt ( 1 - x * x ) ) ; } float fastasin3 ( float x ) { return x + x * x * x * x * x * 0.4971 ; } float fastasin4 ( float x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; x = M_PI / 2 - sqrtf ( 1.0f - x ) * ( 1.5707288 + - 0.2121144 * x + 0.0742610 * x * x + - 0.0187293 * x * x * x ) ; return sign * x ; } float fastasin5 ( float x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; float fRoot = sqrtf ( 1.0f - x ) ; float fResult = 0.0742610f + - 0.0187293f * x ; fResult = - 0.2121144f + fResult * x ; fResult = 1.5707288f + fResult * x ; fResult = M_PI / 2 - fRoot * fResult ; return sign * fResult ; } # define C 0.70710678118654752440f # define BITSPERQUARTER ( 20 ) void fcs ( float angle , float & sinout , float & cosout ) { int phasein = angle * ( 1 << BITSPERQUARTER ) ; float modphase = ( phasein & ( ( 1 << BITSPERQUARTER ) - 1 ) ) * ( 1.0f / ( 1 << BITSPERQUARTER ) ) ; int quarter = phasein >> BITSPERQUARTER ; if ( ! quarter ) { float x = modphase - 0.5f ; float temp = ( 2 - 4 * C ) * x * x + C ; sinout = temp + x ; cosout = temp - x ; } else if ( quarter == 1 ) { float x = 0.5f - modphase ; float temp = ( 2 - 4 * C ) * x * x + C ; sinout = x + temp ; cosout = x - temp ; } else if ( quarter == 2 ) { float x = modphase - 0.5f ; float temp = ( 4 * C - 2 ) * x * x - C ; sinout = temp - x ; cosout = temp + x ; } else if ( quarter == 3 ) { float x = modphase - 0.5f ; float temp = ( 2 - 4 * C ) * x * x + C ; sinout = x - temp ; cosout = x + temp ; } } # undef C const float PI_SQR = 9.86960440108935861883449099987615114f ; void fcs2 ( float theta , float & outsine , float & outcosine ) { float gamma = theta + 1 ; gamma += 2 ; gamma /= 4 ; theta += 2 ; theta /= 4 ; theta -= floorf ( theta ) ; gamma -= floorf ( gamma ) ; theta *= 4 ; theta -= 2 ; gamma *= 4 ; gamma -= 2 ; float x = 2 * gamma - gamma * fabs ( gamma ) ; float y = 2 * theta - theta * fabs ( theta ) ; const float P = 0.225 ; outsine = P * ( y * fabsf ( y ) - y ) + y ; outcosine = P * ( x * fabsf ( x ) - x ) + x ; } void fastsincos ( float x , float & sine , float & cosine ) { fcs2 ( x , sine , cosine ) ; } bool TestSinCos ( ) { for ( int i = - 100 ; i <= 100 ; i ++ ) { float f = i / 30.0f ; float slowsin = sinf ( f * M_PI_2 ) , slowcos = cosf ( f * M_PI_2 ) ; float fastsin , fastcos ; fastsincos ( f , fastsin , fastcos ) ; printf ( " % f : ▁ slow : ▁ % 0.8f , ▁ % 0.8f ▁ fast : ▁ % 0.8f , ▁ % 0.8f \n " , f , slowsin , slowcos , fastsin , fastcos ) ; } return true ; } bool TestAsin ( ) { for ( int i = - 100 ; i <= 100 ; i ++ ) { float f = i / 100.0f ; float slowval = asinf ( f ) / M_PI_2 ; float fastval = fastasin5 ( f ) / M_PI_2 ; printf ( " slow : ▁ % 0.16f ▁ fast : ▁ % 0.16f \n " , slowval , fastval ) ; float diff = fabsf ( slowval - fastval ) ; } return true ; } bool TestMathUtil ( ) { EXPECT_FALSE ( my_isinf ( 1.0 ) ) ; volatile float zero = 0.0f ; EXPECT_TRUE ( my_isinf ( 1.0f / zero ) ) ; EXPECT_FALSE ( my_isnan ( 1.0f / zero ) ) ; return true ; } bool TestParsers ( ) { const char * macstr = "01:02:03 : ff : fe : fd " ; uint8_t mac [ 6 ] ; ParseMacAddress ( macstr , mac ) ; EXPECT_TRUE ( mac [ 0 ] == 1 ) ; EXPECT_TRUE ( mac [ 1 ] == 2 ) ; EXPECT_TRUE ( mac [ 2 ] == 3 ) ; EXPECT_TRUE ( mac [ 3 ] == 255 ) ; EXPECT_TRUE ( mac [ 4 ] == 254 ) ; EXPECT_TRUE ( mac [ 5 ] == 253 ) ; return true ; } bool TestVFPUSinCos ( ) { float sine , cosine ; vfpu_sincos ( 0.0f , sine , cosine ) ; EXPECT_EQ_FLOAT ( sine , 0.0f ) ; EXPECT_EQ_FLOAT ( cosine , 1.0f ) ; vfpu_sincos ( 1.0f , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , 1.0f ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , 0.0f ) ; vfpu_sincos ( 2.0f , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , 0.0f ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , - 1.0f ) ; vfpu_sincos ( 3.0f , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , - 1.0f ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , 0.0f ) ; vfpu_sincos ( 4.0f , sine , cosine ) ; EXPECT_EQ_FLOAT ( sine , 0.0f ) ; EXPECT_EQ_FLOAT ( cosine , 1.0f ) ; vfpu_sincos ( 5.0f , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , 1.0f ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , 0.0f ) ; for ( float angle = - 10.0f ; angle < 10.0f ; angle ++ ) { vfpu_sincos ( angle , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , sinf ( angle * M_PI_2 ) ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , cosf ( angle * M_PI_2 ) ) ; } return true ; } bool TestMatrixTranspose ( ) { MatrixSize sz = M_4x4 ; int matrix = 0 ; u8 cols [ 4 ] ; u8 rows [ 4 ] ; GetMatrixColumns ( matrix , sz , cols ) ; GetMatrixRows ( matrix , sz , rows ) ; int transposed = Xpose ( matrix ) ; u8 x_cols [ 4 ] ; u8 x_rows [ 4 ] ; GetMatrixColumns ( transposed , sz , x_cols ) ; GetMatrixRows ( transposed , sz , x_rows ) ; for ( int i = 0 ; i < GetMatrixSide ( sz ) ; i ++ ) { EXPECT_EQ_INT ( cols [ i ] , x_rows [ i ] ) ; EXPECT_EQ_INT ( x_cols [ i ] , rows [ i ] ) ; } return true ; } void TestGetMatrix ( int matrix , MatrixSize sz ) { ILOG ( " Testing ▁ matrix ▁ % s " , GetMatrixNotation ( matrix , sz ) ) ; u8 fullMatrix [ 16 ] ; u8 cols [ 4 ] ; u8 rows [ 4 ] ; GetMatrixColumns ( matrix , sz , cols ) ; GetMatrixRows ( matrix , sz , rows ) ; GetMatrixRegs ( fullMatrix , sz , matrix ) ; int n = GetMatrixSide ( sz ) ; VectorSize vsz = GetVectorSize ( sz ) ; for ( int i = 0 ; i < n ; i ++ ) { int colName = cols [ i ] ; int rowName = rows [ i ] ; ILOG ( " Column ▁ % i : ▁ % s " , i , GetVectorNotation ( colName , vsz ) ) ; ILOG ( " Row ▁ % i : ▁ % s " , i , GetVectorNotation ( rowName , vsz ) ) ; u8 colRegs [ 4 ] ; u8 rowRegs [ 4 ] ; GetVectorRegs ( colRegs , vsz , colName ) ; GetVectorRegs ( rowRegs , vsz , rowName ) ; std :: stringstream a , b , c , d ; for ( int j = 0 ; j < n ; j ++ ) { a . clear ( ) ; b . clear ( ) ; a << ( int ) fullMatrix [ i * 4 + j ] << " ▁ " ; b << ( int ) colRegs [ j ] << " ▁ " ; c . clear ( ) ; d . clear ( ) ; c << ( int ) fullMatrix [ j * 4 + i ] << " ▁ " ; d << ( int ) rowRegs [ j ] << " ▁ " ; } ILOG ( " Col : ▁ % s ▁ vs ▁ % s " , a . str ( ) . c_str ( ) , b . str ( ) . c_str ( ) ) ; if ( a . str ( ) != b . str ( ) ) ILOG ( " WRONG ! " ) ; ILOG ( " Row : ▁ % s ▁ vs ▁ % s " , c . str ( ) . c_str ( ) , d . str ( ) . c_str ( ) ) ; if ( c . str ( ) != d . str ( ) ) ILOG ( " WRONG ! " ) ; } } bool TestParseLBN ( ) { const char * validStrings [ ] = { " / sce _ lbn0x5fa0 _ size0x1428" , " / sce _ lbn7050 _ sizeee850" , " / sce _ lbn0x5eeeh _ size0x234x " , " / sce _ lbneee _ _ size434 . " , } ; int expectedResults [ ] [ 2 ] = { { 0x5fa0 , 0x1428 } , { 0x7050 , 0xee850 } , { 0x5eee , 0x234 } , { 0xeee , 0x434 } , } ; const char * invalidStrings [ ] = { " / sce _ lbn0x5fa0 _ sze0x1428" , " " , " // " , } ; for ( int i = 0 ; i < ARRAY_SIZE ( validStrings ) ; i ++ ) { u32 startSector = 0 , readSize = 0 ; EXPECT_TRUE ( parseLBN ( validStrings [ i ] , & startSector , & readSize ) ) ; EXPECT_EQ_INT ( startSector , expectedResults [ i ] [ 0 ] ) ; EXPECT_EQ_INT ( readSize , expectedResults [ i ] [ 1 ] ) ; } for ( int i = 0 ; i < ARRAY_SIZE ( invalidStrings ) ; i ++ ) { u32 startSector , readSize ; EXPECT_FALSE ( parseLBN ( invalidStrings [ i ] , & startSector , & readSize ) ) ; } return true ; } typedef bool ( * TestFunc ) ( ) ; struct TestItem { const char * name ; TestFunc func ; } ; # define TEST_ITEM ( name ) { # name , & Test ## name , } bool TestArmEmitter ( ) ; bool TestArm64Emitter ( ) ; bool TestX64Emitter ( ) ; TestItem availableTests [ ] = { # if defined ( ARM64 ) || defined ( _M_X64 ) || defined ( _M_IX86 ) TEST_ITEM ( Arm64Emitter ) , # endif # if defined ( ARM ) || defined ( _M_X64 ) || defined ( _M_IX86 ) TEST_ITEM ( ArmEmitter ) , # endif # if defined ( _M_X64 ) || defined ( _M_IX86 ) TEST_ITEM ( X64Emitter ) , # endif TEST_ITEM ( VertexJit ) , TEST_ITEM ( Asin ) , TEST_ITEM ( SinCos ) , TEST_ITEM ( VFPUSinCos ) , TEST_ITEM ( MathUtil ) , TEST_ITEM ( Parsers ) , TEST_ITEM ( Jit ) , TEST_ITEM ( MatrixTranspose ) , TEST_ITEM ( ParseLBN ) , } ; int main ( int argc , const char * argv [ ] ) { cpu_info . bNEON = true ; cpu_info . bVFP = true ; cpu_info . bVFPv3 = true ; cpu_info . bVFPv4 = true ; g_Config . bEnableLogging = true ; bool allTests = false ; TestFunc testFunc = nullptr ; if ( argc >= 2 ) { if ( ! strcasecmp ( argv [ 1 ] , " all " ) ) { allTests = true ; } for ( auto f : availableTests ) { if ( ! strcasecmp ( argv [ 1 ] , f . name ) ) { testFunc = f . func ; break ; } } } if ( allTests ) { int passes = 0 ; int fails = 0 ; for ( auto f : availableTests ) { if ( f . func ( ) ) { ++ passes ; } else { printf ( " % s : ▁ FAILED \n " , f . name ) ; ++ fails ; } } if ( passes > 0 ) { printf ( " % d ▁ tests ▁ passed . \n " , passes ) ; } if ( fails > 0 ) { return 2 ; } } else if ( testFunc == nullptr ) { fprintf ( stderr , " You ▁ may ▁ select ▁ a ▁ test ▁ to ▁ run ▁ by ▁ passing ▁ an ▁ argument . \n " ) ; fprintf ( stderr , " \n " ) ; fprintf ( stderr , " Available ▁ tests : \n " ) ; for ( auto f : availableTests ) { fprintf ( stderr , " ▁ ▁ * ▁ % s \n " , f . name ) ; } return 1 ; } else { if ( ! testFunc ( ) ) { return 2 ; } } return 0 ; } </DOCUMENT>
<DOCUMENT_ID="dklann/rivendell/tree/master/lib/rdlist_logs.cpp"> # include " rdapplication . h " # include " rddb . h " # include " rdescape _ string . h " # include " rdlist _ logs . h " RDListLogs :: RDListLogs ( QString * logname , RDLogFilter :: FilterMode mode , QWidget * parent ) : RDDialog ( parent ) { list_logname = logname ; setMinimumSize ( sizeHint ( ) ) ; setWindowTitle ( tr ( " Select ▁ Log " ) ) ; list_filter_widget = new RDLogFilter ( mode , this ) ; connect ( list_filter_widget , SIGNAL ( filterChanged ( const QString & ) ) , this , SLOT ( filterChangedData ( const QString & ) ) ) ; list_log_list = new Q3ListView ( this ) ; list_log_list -> setAllColumnsShowFocus ( true ) ; list_log_list -> setItemMargin ( 5 ) ; list_log_list -> setSelectionMode ( Q3ListView :: Single ) ; connect ( list_log_list , SIGNAL ( doubleClicked ( Q3ListViewItem * , const QPoint & , int ) ) , this , SLOT ( doubleClickedData ( Q3ListViewItem * , const QPoint & , int ) ) ) ; list_log_list -> addColumn ( tr ( " Name " ) ) ; list_log_list -> setColumnAlignment ( 0 , Qt :: AlignLeft ) ; list_log_list -> addColumn ( tr ( " Description " ) ) ; list_log_list -> setColumnAlignment ( 1 , Qt :: AlignLeft ) ; list_log_list -> addColumn ( tr ( " Service " ) ) ; list_log_list -> setColumnAlignment ( 2 , Qt :: AlignLeft ) ; list_ok_button = new QPushButton ( this ) ; list_ok_button -> setFont ( buttonFont ( ) ) ; list_ok_button -> setText ( tr ( " OK " ) ) ; connect ( list_ok_button , SIGNAL ( clicked ( ) ) , this , SLOT ( okButtonData ( ) ) ) ; list_cancel_button = new QPushButton ( this ) ; list_cancel_button -> setFont ( buttonFont ( ) ) ; list_cancel_button -> setText ( tr ( " Cancel " ) ) ; list_cancel_button -> setDefault ( true ) ; connect ( list_cancel_button , SIGNAL ( clicked ( ) ) , this , SLOT ( cancelButtonData ( ) ) ) ; RefreshList ( ) ; } QSize RDListLogs :: sizeHint ( ) const { return QSize ( 500 , 300 ) ; } QSizePolicy RDListLogs :: sizePolicy ( ) const { return QSizePolicy ( QSizePolicy :: Fixed , QSizePolicy :: Fixed ) ; } void RDListLogs :: closeEvent ( QCloseEvent * e ) { done ( 1 ) ; } void RDListLogs :: filterChangedData ( const QString & where_sql ) { RefreshList ( ) ; } void RDListLogs :: doubleClickedData ( Q3ListViewItem * , const QPoint & , int ) { okButtonData ( ) ; } void RDListLogs :: okButtonData ( ) { Q3ListViewItem * item = list_log_list -> selectedItem ( ) ; if ( item == NULL ) { return ; } * list_logname = item -> text ( 0 ) ; done ( 0 ) ; } void RDListLogs :: cancelButtonData ( ) { done ( 1 ) ; } void RDListLogs :: resizeEvent ( QResizeEvent * e ) { list_filter_widget -> setGeometry ( 10 , 10 , size ( ) . width ( ) - 10 , list_filter_widget -> sizeHint ( ) . height ( ) ) ; list_log_list -> setGeometry ( 10 , list_filter_widget -> sizeHint ( ) . height ( ) , size ( ) . width ( ) - 20 , size ( ) . height ( ) - list_filter_widget -> sizeHint ( ) . height ( ) - 70 ) ; list_ok_button -> setGeometry ( size ( ) . width ( ) - 190 , size ( ) . height ( ) - 60 , 80 , 50 ) ; list_cancel_button -> setGeometry ( size ( ) . width ( ) - 90 , size ( ) . height ( ) - 60 , 80 , 50 ) ; } void RDListLogs :: RefreshList ( ) { RDSqlQuery * q ; QString sql ; Q3ListViewItem * l ; Q3ListViewItem * view_item = NULL ; QDate current_date = QDate :: currentDate ( ) ; list_log_list -> clear ( ) ; sql = QString ( " select ▁ NAME , DESCRIPTION , SERVICE ▁ from ▁ LOGS ▁ " ) + " where ▁ ( TYPE = 0 ) & & ( LOG _ EXISTS = \ " Y\ " ) & & " + " ( ( START _ DATE < = \ " " + current_date . toString ( " yyyy - MM - dd " ) + " \ " ) | | " + " ( START _ DATE = \ " 0000-00-00\ " ) | | " + " ( START _ DATE ▁ is ▁ null ) ) & & " + " ( ( END _ DATE > = \ " " + current_date . toString ( " yyyy - MM - dd " ) + " \ " ) | | " + " ( END _ DATE = \ " 0000-00-00\ " ) | | " + " ( END _ DATE ▁ is ▁ null ) ) " + list_filter_widget -> whereSql ( ) ; q = new RDSqlQuery ( sql ) ; while ( q -> next ( ) ) { l = new Q3ListViewItem ( list_log_list ) ; l -> setText ( 0 , q -> value ( 0 ) . toString ( ) ) ; l -> setText ( 1 , q -> value ( 1 ) . toString ( ) ) ; l -> setText ( 2 , q -> value ( 2 ) . toString ( ) ) ; if ( l -> text ( 0 ) == * list_logname ) { view_item = l ; } } delete q ; if ( view_item != NULL ) { list_log_list -> setCurrentItem ( view_item ) ; list_log_list -> ensureItemVisible ( view_item ) ; } } </DOCUMENT>
<DOCUMENT_ID="sneiiler/ardupilot/tree/master/libraries/AP_HAL/utility/getopt_cpp.cpp"> # include " getopt _ cpp . h " # include < stdio . h > # include < string . h > GetOptLong :: GetOptLong ( int _argc , char * const _argv [ ] , const char * _optstring , const GetOptLong :: option * _longopts ) : opterr ( 0 ) , optind ( 1 ) , optopt ( 0 ) , longindex ( - 1 ) , optarg ( NULL ) , argc ( _argc ) , argv ( _argv ) , optstring ( _optstring ) , longopts ( _longopts ) , place ( " " ) { } int GetOptLong :: getoption ( void ) { const char * oli ; if ( ! * place ) { if ( optind >= argc ) { place = " " ; return - 1 ; } place = argv [ optind ] ; if ( place [ 0 ] != ' - ' ) { place = " " ; return - 1 ; } place ++ ; if ( place [ 0 ] && place [ 0 ] == ' - ' && place [ 1 ] == ' \0' ) { ++ optind ; place = " " ; return - 1 ; } if ( place [ 0 ] && place [ 0 ] == ' - ' && place [ 1 ] ) { size_t namelen ; int i ; place ++ ; namelen = strcspn ( place , " = " ) ; for ( i = 0 ; longopts [ i ] . name != NULL ; i ++ ) { if ( strlen ( longopts [ i ] . name ) == namelen && strncmp ( place , longopts [ i ] . name , namelen ) == 0 ) { if ( longopts [ i ] . has_arg ) { if ( place [ namelen ] == ' = ' ) optarg = place + namelen + 1 ; else if ( optind < argc - 1 ) { optind ++ ; optarg = argv [ optind ] ; } else { if ( optstring [ 0 ] == ' : ' ) return BADARG ; if ( opterr ) fprintf ( stderr , " % s : ▁ option ▁ requires ▁ an ▁ argument ▁ - - ▁ % s \n " , argv [ 0 ] , place ) ; place = " " ; optind ++ ; return BADCH ; } } else { optarg = NULL ; if ( place [ namelen ] != 0 ) { } } optind ++ ; longindex = i ; place = " " ; if ( longopts [ i ] . flag == NULL ) return longopts [ i ] . val ; else { * longopts [ i ] . flag = longopts [ i ] . val ; return 0 ; } } } if ( opterr && optstring [ 0 ] != ' : ' ) fprintf ( stderr , " % s : ▁ illegal ▁ option ▁ - - ▁ % s \n " , argv [ 0 ] , place ) ; place = " " ; optind ++ ; return BADCH ; } } optopt = ( int ) * place ++ ; oli = strchr ( optstring , optopt ) ; if ( ! oli ) { if ( ! * place ) ++ optind ; if ( opterr && * optstring != ' : ' ) fprintf ( stderr , " % s : ▁ illegal ▁ option ▁ - - ▁ % c \n " , argv [ 0 ] , optopt ) ; return BADCH ; } if ( oli [ 1 ] != ' : ' ) { optarg = NULL ; if ( ! * place ) ++ optind ; } else { if ( * place ) optarg = place ; else if ( argc <= ++ optind ) { place = " " ; if ( * optstring == ' : ' ) return BADARG ; if ( opterr ) fprintf ( stderr , " % s : ▁ option ▁ requires ▁ an ▁ argument ▁ - - ▁ % c \n " , argv [ 0 ] , optopt ) ; return BADCH ; } else optarg = argv [ optind ] ; place = " " ; ++ optind ; } return optopt ; } </DOCUMENT>
<DOCUMENT_ID="dominik-th/xbmc/tree/master/xbmc/ApplicationPlayer.cpp"> # include " ApplicationPlayer . h " # include " cores / IPlayer . h " # include " Application . h " # include " settings / MediaSettings . h " CApplicationPlayer :: CApplicationPlayer ( ) { m_iPlayerOPSeq = 0 ; m_eCurrentPlayer = EPC_NONE ; } std :: shared_ptr < IPlayer > CApplicationPlayer :: GetInternal ( ) const { CSingleLock lock ( m_player_lock ) ; return m_pPlayer ; } void CApplicationPlayer :: ClosePlayer ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { CloseFile ( ) ; CSingleLock lock ( m_player_lock ) ; m_pPlayer . reset ( ) ; } } void CApplicationPlayer :: CloseFile ( bool reopen ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { ++ m_iPlayerOPSeq ; player -> CloseFile ( reopen ) ; } } void CApplicationPlayer :: ClosePlayerGapless ( PLAYERCOREID newCore ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( ! player ) return ; bool gaplessSupported = ( m_eCurrentPlayer == EPC_DVDPLAYER || m_eCurrentPlayer == EPC_PAPLAYER ) ; gaplessSupported = gaplessSupported && ( m_eCurrentPlayer == newCore ) ; if ( ! gaplessSupported ) { ClosePlayer ( ) ; } else { CloseFile ( true ) ; } } void CApplicationPlayer :: CreatePlayer ( PLAYERCOREID newCore , IPlayerCallback & callback ) { CSingleLock lock ( m_player_lock ) ; if ( ! m_pPlayer ) { m_eCurrentPlayer = newCore ; m_pPlayer . reset ( CPlayerCoreFactory :: Get ( ) . CreatePlayer ( newCore , callback ) ) ; } } PlayBackRet CApplicationPlayer :: OpenFile ( const CFileItem & item , const CPlayerOptions & options ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; PlayBackRet iResult = PLAYBACK_FAIL ; if ( player ) { unsigned int startingSeq = ++ m_iPlayerOPSeq ; iResult = player -> OpenFile ( item , options ) ? PLAYBACK_OK : PLAYBACK_FAIL ; if ( m_iPlayerOPSeq != startingSeq ) iResult = PLAYBACK_CANCELED ; } return iResult ; } bool CApplicationPlayer :: HasPlayer ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return player != NULL ; } int CApplicationPlayer :: GetChapter ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetChapter ( ) ; else return - 1 ; } int CApplicationPlayer :: GetChapterCount ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetChapterCount ( ) ; else return 0 ; } void CApplicationPlayer :: GetChapterName ( std :: string & strChapterName , int chapterIdx ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetChapterName ( strChapterName , chapterIdx ) ; } int64_t CApplicationPlayer :: GetChapterPos ( int chapterIdx ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetChapterPos ( chapterIdx ) ; return - 1 ; } bool CApplicationPlayer :: HasAudio ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> HasAudio ( ) ) ; } bool CApplicationPlayer :: HasVideo ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> HasVideo ( ) ) ; } int CApplicationPlayer :: GetPreferredPlaylist ( ) const { if ( IsPlayingVideo ( ) ) return PLAYLIST_VIDEO ; if ( IsPlayingAudio ( ) ) return PLAYLIST_MUSIC ; return PLAYLIST_NONE ; } bool CApplicationPlayer :: IsPaused ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsPaused ( ) ) ; } bool CApplicationPlayer :: IsPlaying ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsPlaying ( ) ) ; } bool CApplicationPlayer :: IsPausedPlayback ( ) const { return ( IsPlaying ( ) && IsPaused ( ) ) ; } bool CApplicationPlayer :: IsPlayingAudio ( ) const { return ( IsPlaying ( ) && ! HasVideo ( ) && HasAudio ( ) ) ; } bool CApplicationPlayer :: IsPlayingVideo ( ) const { return ( IsPlaying ( ) && HasVideo ( ) ) ; } void CApplicationPlayer :: Pause ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> Pause ( ) ; } bool CApplicationPlayer :: ControlsVolume ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> ControlsVolume ( ) ) ; } void CApplicationPlayer :: SetMute ( bool bOnOff ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetMute ( bOnOff ) ; } void CApplicationPlayer :: SetVolume ( float volume ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetVolume ( volume ) ; } void CApplicationPlayer :: Seek ( bool bPlus , bool bLargeStep , bool bChapterOverride ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> Seek ( bPlus , bLargeStep , bChapterOverride ) ; } void CApplicationPlayer :: SeekPercentage ( float fPercent ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SeekPercentage ( fPercent ) ; } bool CApplicationPlayer :: IsPassthrough ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsPassthrough ( ) ) ; } bool CApplicationPlayer :: CanSeek ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> CanSeek ( ) ) ; } bool CApplicationPlayer :: SeekScene ( bool bPlus ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> SeekScene ( bPlus ) ) ; } void CApplicationPlayer :: SeekTime ( int64_t iTime ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SeekTime ( iTime ) ; } void CApplicationPlayer :: SeekTimeRelative ( int64_t iTime ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { if ( ! player -> SeekTimeRelative ( iTime ) ) { int64_t abstime = player -> GetTime ( ) + iTime ; player -> SeekTime ( abstime ) ; } } } std :: string CApplicationPlayer :: GetPlayingTitle ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetPlayingTitle ( ) ; else return " " ; } int64_t CApplicationPlayer :: GetTime ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetTime ( ) ; else return 0 ; } int64_t CApplicationPlayer :: GetDisplayTime ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetDisplayTime ( ) ; else return 0 ; } bool CApplicationPlayer :: IsCaching ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsCaching ( ) ) ; } bool CApplicationPlayer :: IsInMenu ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsInMenu ( ) ) ; } bool CApplicationPlayer :: HasMenu ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> HasMenu ( ) ) ; } int CApplicationPlayer :: GetCacheLevel ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetCacheLevel ( ) ; else return 0 ; } int CApplicationPlayer :: GetSubtitleCount ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetSubtitleCount ( ) ; else return 0 ; } int CApplicationPlayer :: GetAudioStream ( ) { if ( ! m_audioStreamUpdate . IsTimePast ( ) ) return m_iAudioStream ; std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { m_iAudioStream = player -> GetAudioStream ( ) ; m_audioStreamUpdate . Set ( 1000 ) ; return m_iAudioStream ; } else return 0 ; } int CApplicationPlayer :: GetSubtitle ( ) { if ( ! m_subtitleStreamUpdate . IsTimePast ( ) ) return m_iSubtitleStream ; std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { m_iSubtitleStream = player -> GetSubtitle ( ) ; m_subtitleStreamUpdate . Set ( 1000 ) ; return m_iSubtitleStream ; } else return 0 ; } bool CApplicationPlayer :: GetSubtitleVisible ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> GetSubtitleVisible ( ) ) ; } bool CApplicationPlayer :: CanRecord ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> CanRecord ( ) ) ; } bool CApplicationPlayer :: CanPause ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> CanPause ( ) ) ; } bool CApplicationPlayer :: IsRecording ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsRecording ( ) ) ; } TextCacheStruct_t * CApplicationPlayer :: GetTeletextCache ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetTeletextCache ( ) ; else return NULL ; } int64_t CApplicationPlayer :: GetTotalTime ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetTotalTime ( ) ; else return 0 ; } float CApplicationPlayer :: GetPercentage ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetPercentage ( ) ; else return 0.0 ; } float CApplicationPlayer :: GetCachePercentage ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetCachePercentage ( ) ; else return 0.0 ; } void CApplicationPlayer :: ToFFRW ( int iSpeed ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> ToFFRW ( iSpeed ) ; } void CApplicationPlayer :: DoAudioWork ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> DoAudioWork ( ) ; } std :: string CApplicationPlayer :: GetPlayerState ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetPlayerState ( ) ; else return " " ; } bool CApplicationPlayer :: QueueNextFile ( const CFileItem & file ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> QueueNextFile ( file ) ) ; } bool CApplicationPlayer :: GetStreamDetails ( CStreamDetails & details ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> GetStreamDetails ( details ) ) ; } bool CApplicationPlayer :: SetPlayerState ( const std :: string & state ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> SetPlayerState ( state ) ) ; } void CApplicationPlayer :: OnNothingToQueueNotify ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OnNothingToQueueNotify ( ) ; } void CApplicationPlayer :: GetVideoStreamInfo ( SPlayerVideoStreamInfo & info ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetVideoStreamInfo ( info ) ; } void CApplicationPlayer :: GetAudioStreamInfo ( int index , SPlayerAudioStreamInfo & info ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetAudioStreamInfo ( index , info ) ; } bool CApplicationPlayer :: OnAction ( const CAction & action ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> OnAction ( action ) ) ; } bool CApplicationPlayer :: Record ( bool bOnOff ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> Record ( bOnOff ) ) ; } int CApplicationPlayer :: GetAudioStreamCount ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetAudioStreamCount ( ) ; else return 0 ; } void CApplicationPlayer :: SetAudioStream ( int iStream ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { player -> SetAudioStream ( iStream ) ; m_iAudioStream = iStream ; m_audioStreamUpdate . Set ( 1000 ) ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_AudioStream = iStream ; } } void CApplicationPlayer :: GetSubtitleStreamInfo ( int index , SPlayerSubtitleStreamInfo & info ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetSubtitleStreamInfo ( index , info ) ; } void CApplicationPlayer :: SetSubtitle ( int iStream ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { player -> SetSubtitle ( iStream ) ; m_iSubtitleStream = iStream ; m_subtitleStreamUpdate . Set ( 1000 ) ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_SubtitleStream = iStream ; } } void CApplicationPlayer :: SetSubtitleVisible ( bool bVisible ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { player -> SetSubtitleVisible ( bVisible ) ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_SubtitleOn = bVisible ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_SubtitleStream = player -> GetSubtitle ( ) ; } } void CApplicationPlayer :: AddSubtitle ( const std :: string & strSubPath ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> AddSubtitle ( strSubPath ) ; } void CApplicationPlayer :: SetSubTitleDelay ( float fValue ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetSubTitleDelay ( fValue ) ; } void CApplicationPlayer :: SetAVDelay ( float fValue ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetAVDelay ( fValue ) ; } void CApplicationPlayer :: SetDynamicRangeCompression ( long drc ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetDynamicRangeCompression ( drc ) ; } bool CApplicationPlayer :: SwitchChannel ( const PVR :: CPVRChannelPtr & channel ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> SwitchChannel ( channel ) ) ; } void CApplicationPlayer :: LoadPage ( int p , int sp , unsigned char * buffer ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> LoadPage ( p , sp , buffer ) ; } void CApplicationPlayer :: GetAudioCapabilities ( std :: vector < int > & audioCaps ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetAudioCapabilities ( audioCaps ) ; } void CApplicationPlayer :: GetSubtitleCapabilities ( std :: vector < int > & subCaps ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetSubtitleCapabilities ( subCaps ) ; } void CApplicationPlayer :: GetAudioInfo ( std :: string & strAudioInfo ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetAudioInfo ( strAudioInfo ) ; } void CApplicationPlayer :: GetVideoInfo ( std :: string & strVideoInfo ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetVideoInfo ( strVideoInfo ) ; } void CApplicationPlayer :: GetGeneralInfo ( std :: string & strVideoInfo ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetGeneralInfo ( strVideoInfo ) ; } int CApplicationPlayer :: SeekChapter ( int iChapter ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> SeekChapter ( iChapter ) ; else return 0 ; } void CApplicationPlayer :: GetRenderFeatures ( std :: vector < int > & renderFeatures ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGetRenderFeatures ( renderFeatures ) ; } void CApplicationPlayer :: GetDeinterlaceMethods ( std :: vector < int > & deinterlaceMethods ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGetDeinterlaceMethods ( deinterlaceMethods ) ; } void CApplicationPlayer :: GetDeinterlaceModes ( std :: vector < int > & deinterlaceModes ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGetDeinterlaceModes ( deinterlaceModes ) ; } void CApplicationPlayer :: GetScalingMethods ( std :: vector < int > & scalingMethods ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGetScalingMethods ( scalingMethods ) ; } void CApplicationPlayer :: SetPlaySpeed ( int iSpeed , bool bApplicationMuted ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( ! player ) return ; if ( ! IsPlayingAudio ( ) && ! IsPlayingVideo ( ) ) return ; if ( m_iPlaySpeed == iSpeed ) return ; if ( ! CanSeek ( ) ) return ; if ( IsPaused ( ) ) { if ( ( ( m_iPlaySpeed > 1 ) && ( iSpeed > m_iPlaySpeed ) ) || ( ( m_iPlaySpeed < - 1 ) && ( iSpeed < m_iPlaySpeed ) ) ) { iSpeed = m_iPlaySpeed ; } Pause ( ) ; } m_iPlaySpeed = iSpeed ; ToFFRW ( m_iPlaySpeed ) ; if ( ControlsVolume ( ) ) { if ( m_iPlaySpeed == 1 ) { player -> SetVolume ( g_application . GetVolume ( false ) ) ; } else { player -> SetVolume ( VOLUME_MINIMUM ) ; } player -> SetMute ( bApplicationMuted ) ; } } int CApplicationPlayer :: GetPlaySpeed ( ) const { return m_iPlaySpeed ; } </DOCUMENT>
<DOCUMENT_ID="grokys/coreclr/tree/master/src/vm/common.cpp"> # include " common . h " </DOCUMENT>
<DOCUMENT_ID="lopezloo/mtasa-blue/tree/master/Client/mods/deathmatch/logic/CCustomData.cpp"> # include " StdInc . h " # define DECLARE_PROFILER_SECTION_CCustomData # include " profiler / SharedUtil . Profiler . h " void CCustomData :: Copy ( CCustomData * pCustomData ) { std :: map < std :: string , SCustomData > :: const_iterator iter = pCustomData -> IterBegin ( ) ; for ( ; iter != pCustomData -> IterEnd ( ) ; iter ++ ) { Set ( iter -> first . c_str ( ) , iter -> second . Variable ) ; } } SCustomData * CCustomData :: Get ( const char * szName ) { assert ( szName ) ; std :: map < std :: string , SCustomData > :: iterator it = m_Data . find ( szName ) ; if ( it != m_Data . end ( ) ) return & it -> second ; return NULL ; } void CCustomData :: Set ( const char * szName , const CLuaArgument & Variable , bool bSynchronized ) { assert ( szName ) ; SCustomData * pData = Get ( szName ) ; if ( pData ) { pData -> Variable = Variable ; pData -> bSynchronized = bSynchronized ; } else { SCustomData newData ; newData . Variable = Variable ; newData . bSynchronized = bSynchronized ; m_Data [ szName ] = newData ; } } bool CCustomData :: Delete ( const char * szName ) { std :: map < std :: string , SCustomData > :: iterator it = m_Data . find ( szName ) ; if ( it != m_Data . end ( ) ) { m_Data . erase ( it ) ; return true ; } return false ; } </DOCUMENT>
<DOCUMENT_ID="tony--/WinObjC/tree/master/deps/3rdparty/iculegacy/source/i18n/rbtz.cpp"> # include < typeinfo > # include " unicode / utypes . h " # if ! UCONFIG_NO_FORMATTING # include " unicode / rbtz . h " # include " unicode / gregocal . h " # include " uvector . h " # include " gregoimp . h " # include " cmemory . h " U_NAMESPACE_BEGIN struct Transition { UDate time ; TimeZoneRule * from ; TimeZoneRule * to ; } ; static UBool compareRules ( UVector * rules1 , UVector * rules2 ) { if ( rules1 == NULL && rules2 == NULL ) { return TRUE ; } else if ( rules1 == NULL || rules2 == NULL ) { return FALSE ; } int32_t size = rules1 -> size ( ) ; if ( size != rules2 -> size ( ) ) { return FALSE ; } for ( int32_t i = 0 ; i < size ; i ++ ) { TimeZoneRule * r1 = ( TimeZoneRule * ) rules1 -> elementAt ( i ) ; TimeZoneRule * r2 = ( TimeZoneRule * ) rules2 -> elementAt ( i ) ; if ( * r1 != * r2 ) { return FALSE ; } } return TRUE ; } UOBJECT_DEFINE_RTTI_IMPLEMENTATION ( RuleBasedTimeZone ) RuleBasedTimeZone :: RuleBasedTimeZone ( const UnicodeString & id , InitialTimeZoneRule * initialRule ) : BasicTimeZone ( id ) , fInitialRule ( initialRule ) , fHistoricRules ( NULL ) , fFinalRules ( NULL ) , fHistoricTransitions ( NULL ) , fUpToDate ( FALSE ) { } RuleBasedTimeZone :: RuleBasedTimeZone ( const RuleBasedTimeZone & source ) : BasicTimeZone ( source ) , fInitialRule ( source . fInitialRule -> clone ( ) ) , fHistoricTransitions ( NULL ) , fUpToDate ( FALSE ) { fHistoricRules = copyRules ( source . fHistoricRules ) ; fFinalRules = copyRules ( source . fFinalRules ) ; if ( source . fUpToDate ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; } } RuleBasedTimeZone :: ~ RuleBasedTimeZone ( ) { deleteTransitions ( ) ; deleteRules ( ) ; } RuleBasedTimeZone & RuleBasedTimeZone :: operator = ( const RuleBasedTimeZone & right ) { if ( * this != right ) { BasicTimeZone :: operator = ( right ) ; deleteRules ( ) ; fInitialRule = right . fInitialRule -> clone ( ) ; fHistoricRules = copyRules ( right . fHistoricRules ) ; fFinalRules = copyRules ( right . fFinalRules ) ; deleteTransitions ( ) ; fUpToDate = FALSE ; } return * this ; } UBool RuleBasedTimeZone :: operator == ( const TimeZone & that ) const { if ( this == & that ) { return TRUE ; } if ( typeid ( * this ) != typeid ( that ) || BasicTimeZone :: operator == ( that ) == FALSE ) { return FALSE ; } RuleBasedTimeZone * rbtz = ( RuleBasedTimeZone * ) & that ; if ( * fInitialRule != * ( rbtz -> fInitialRule ) ) { return FALSE ; } if ( compareRules ( fHistoricRules , rbtz -> fHistoricRules ) && compareRules ( fFinalRules , rbtz -> fFinalRules ) ) { return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: operator != ( const TimeZone & that ) const { return ! operator == ( that ) ; } void RuleBasedTimeZone :: addTransitionRule ( TimeZoneRule * rule , UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } AnnualTimeZoneRule * atzrule = dynamic_cast < AnnualTimeZoneRule * > ( rule ) ; if ( atzrule != NULL && atzrule -> getEndYear ( ) == AnnualTimeZoneRule :: MAX_YEAR ) { if ( fFinalRules == NULL ) { fFinalRules = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { return ; } } else if ( fFinalRules -> size ( ) >= 2 ) { status = U_INVALID_STATE_ERROR ; return ; } fFinalRules -> addElement ( ( void * ) rule , status ) ; } else { if ( fHistoricRules == NULL ) { fHistoricRules = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { return ; } } fHistoricRules -> addElement ( ( void * ) rule , status ) ; } fUpToDate = FALSE ; } void RuleBasedTimeZone :: complete ( UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } if ( fUpToDate ) { return ; } if ( fFinalRules != NULL && fFinalRules -> size ( ) != 2 ) { status = U_INVALID_STATE_ERROR ; return ; } UBool * done = NULL ; if ( fHistoricRules != NULL || fFinalRules != NULL ) { TimeZoneRule * curRule = fInitialRule ; UDate lastTransitionTime = MIN_MILLIS ; if ( fHistoricRules != NULL && fHistoricRules -> size ( ) > 0 ) { int32_t i ; int32_t historicCount = fHistoricRules -> size ( ) ; done = ( UBool * ) uprv_malloc ( sizeof ( UBool ) * historicCount ) ; if ( done == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } for ( i = 0 ; i < historicCount ; i ++ ) { done [ i ] = FALSE ; } while ( TRUE ) { int32_t curStdOffset = curRule -> getRawOffset ( ) ; int32_t curDstSavings = curRule -> getDSTSavings ( ) ; UDate nextTransitionTime = MAX_MILLIS ; TimeZoneRule * nextRule = NULL ; TimeZoneRule * r = NULL ; UBool avail ; UDate tt ; UnicodeString curName , name ; curRule -> getName ( curName ) ; for ( i = 0 ; i < historicCount ; i ++ ) { if ( done [ i ] ) { continue ; } r = ( TimeZoneRule * ) fHistoricRules -> elementAt ( i ) ; avail = r -> getNextStart ( lastTransitionTime , curStdOffset , curDstSavings , false , tt ) ; if ( ! avail ) { done [ i ] = TRUE ; } else { r -> getName ( name ) ; if ( * r == * curRule || ( name == curName && r -> getRawOffset ( ) == curRule -> getRawOffset ( ) && r -> getDSTSavings ( ) == curRule -> getDSTSavings ( ) ) ) { continue ; } if ( tt < nextTransitionTime ) { nextTransitionTime = tt ; nextRule = r ; } } } if ( nextRule == NULL ) { UBool bDoneAll = TRUE ; for ( int32_t j = 0 ; j < historicCount ; j ++ ) { if ( ! done [ j ] ) { bDoneAll = FALSE ; break ; } } if ( bDoneAll ) { break ; } } if ( fFinalRules != NULL ) { for ( i = 0 ; i < 2 ; i ++ ) { TimeZoneRule * fr = ( TimeZoneRule * ) fFinalRules -> elementAt ( i ) ; if ( * fr == * curRule ) { continue ; } r = ( TimeZoneRule * ) fFinalRules -> elementAt ( i ) ; avail = r -> getNextStart ( lastTransitionTime , curStdOffset , curDstSavings , false , tt ) ; if ( avail ) { if ( tt < nextTransitionTime ) { nextTransitionTime = tt ; nextRule = r ; } } } } if ( nextRule == NULL ) { break ; } if ( fHistoricTransitions == NULL ) { fHistoricTransitions = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } Transition * trst = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( trst == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } trst -> time = nextTransitionTime ; trst -> from = curRule ; trst -> to = nextRule ; fHistoricTransitions -> addElement ( trst , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } lastTransitionTime = nextTransitionTime ; curRule = nextRule ; } } if ( fFinalRules != NULL ) { if ( fHistoricTransitions == NULL ) { fHistoricTransitions = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } TimeZoneRule * rule0 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; TimeZoneRule * rule1 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; UDate tt0 , tt1 ; UBool avail0 = rule0 -> getNextStart ( lastTransitionTime , curRule -> getRawOffset ( ) , curRule -> getDSTSavings ( ) , false , tt0 ) ; UBool avail1 = rule1 -> getNextStart ( lastTransitionTime , curRule -> getRawOffset ( ) , curRule -> getDSTSavings ( ) , false , tt1 ) ; if ( ! avail0 || ! avail1 ) { status = U_INVALID_STATE_ERROR ; goto cleanup ; } Transition * final0 = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( final0 == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } Transition * final1 = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( final1 == NULL ) { uprv_free ( final0 ) ; status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } if ( tt0 < tt1 ) { final0 -> time = tt0 ; final0 -> from = curRule ; final0 -> to = rule0 ; rule1 -> getNextStart ( tt0 , rule0 -> getRawOffset ( ) , rule0 -> getDSTSavings ( ) , false , final1 -> time ) ; final1 -> from = rule0 ; final1 -> to = rule1 ; } else { final0 -> time = tt1 ; final0 -> from = curRule ; final0 -> to = rule1 ; rule0 -> getNextStart ( tt1 , rule1 -> getRawOffset ( ) , rule1 -> getDSTSavings ( ) , false , final1 -> time ) ; final1 -> from = rule1 ; final1 -> to = rule0 ; } fHistoricTransitions -> addElement ( final0 , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } fHistoricTransitions -> addElement ( final1 , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } } fUpToDate = TRUE ; if ( done != NULL ) { uprv_free ( done ) ; } return ; cleanup : deleteTransitions ( ) ; if ( done != NULL ) { uprv_free ( done ) ; } fUpToDate = FALSE ; } TimeZone * RuleBasedTimeZone :: clone ( void ) const { return new RuleBasedTimeZone ( * this ) ; } int32_t RuleBasedTimeZone :: getOffset ( uint8_t era , int32_t year , int32_t month , int32_t day , uint8_t dayOfWeek , int32_t millis , UErrorCode & status ) const { if ( U_FAILURE ( status ) ) { return 0 ; } if ( month < UCAL_JANUARY || month > UCAL_DECEMBER ) { status = U_ILLEGAL_ARGUMENT_ERROR ; return 0 ; } else { return getOffset ( era , year , month , day , dayOfWeek , millis , Grego :: monthLength ( year , month ) , status ) ; } } int32_t RuleBasedTimeZone :: getOffset ( uint8_t era , int32_t year , int32_t month , int32_t day , uint8_t , int32_t millis , int32_t , UErrorCode & status ) const { if ( U_FAILURE ( status ) ) { return 0 ; } if ( era == GregorianCalendar :: BC ) { year = 1 - year ; } int32_t rawOffset , dstOffset ; UDate time = ( UDate ) Grego :: fieldsToDay ( year , month , day ) * U_MILLIS_PER_DAY + millis ; getOffsetInternal ( time , TRUE , kDaylight , kStandard , rawOffset , dstOffset , status ) ; if ( U_FAILURE ( status ) ) { return 0 ; } return ( rawOffset + dstOffset ) ; } void RuleBasedTimeZone :: getOffset ( UDate date , UBool local , int32_t & rawOffset , int32_t & dstOffset , UErrorCode & status ) const { getOffsetInternal ( date , local , kFormer , kLatter , rawOffset , dstOffset , status ) ; } void RuleBasedTimeZone :: getOffsetFromLocal ( UDate date , int32_t nonExistingTimeOpt , int32_t duplicatedTimeOpt , int32_t & rawOffset , int32_t & dstOffset , UErrorCode & status ) { getOffsetInternal ( date , TRUE , nonExistingTimeOpt , duplicatedTimeOpt , rawOffset , dstOffset , status ) ; } void RuleBasedTimeZone :: getOffsetInternal ( UDate date , UBool local , int32_t NonExistingTimeOpt , int32_t DuplicatedTimeOpt , int32_t & rawOffset , int32_t & dstOffset , UErrorCode & status ) const { rawOffset = 0 ; dstOffset = 0 ; if ( U_FAILURE ( status ) ) { return ; } if ( ! fUpToDate ) { status = U_INVALID_STATE_ERROR ; return ; } const TimeZoneRule * rule = NULL ; if ( fHistoricTransitions == NULL ) { rule = fInitialRule ; } else { UDate tstart = getTransitionTime ( ( Transition * ) fHistoricTransitions -> elementAt ( 0 ) , local , NonExistingTimeOpt , DuplicatedTimeOpt ) ; if ( date < tstart ) { rule = fInitialRule ; } else { int32_t idx = fHistoricTransitions -> size ( ) - 1 ; UDate tend = getTransitionTime ( ( Transition * ) fHistoricTransitions -> elementAt ( idx ) , local , NonExistingTimeOpt , DuplicatedTimeOpt ) ; if ( date > tend ) { if ( fFinalRules != NULL ) { rule = findRuleInFinal ( date , local , NonExistingTimeOpt , DuplicatedTimeOpt ) ; } else { rule = ( ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ) -> to ; } } else { while ( idx >= 0 ) { if ( date >= getTransitionTime ( ( Transition * ) fHistoricTransitions -> elementAt ( idx ) , local , NonExistingTimeOpt , DuplicatedTimeOpt ) ) { break ; } idx -- ; } rule = ( ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ) -> to ; } } } if ( rule != NULL ) { rawOffset = rule -> getRawOffset ( ) ; dstOffset = rule -> getDSTSavings ( ) ; } } void RuleBasedTimeZone :: setRawOffset ( int32_t ) { } int32_t RuleBasedTimeZone :: getRawOffset ( void ) const { UErrorCode status = U_ZERO_ERROR ; int32_t raw , dst ; getOffset ( uprv_getUTCtime ( ) * U_MILLIS_PER_SECOND , FALSE , raw , dst , status ) ; return raw ; } UBool RuleBasedTimeZone :: useDaylightTime ( void ) const { UErrorCode status = U_ZERO_ERROR ; UDate now = uprv_getUTCtime ( ) * U_MILLIS_PER_SECOND ; int32_t raw , dst ; getOffset ( now , FALSE , raw , dst , status ) ; if ( dst != 0 ) { return TRUE ; } UDate time ; TimeZoneRule * from , * to ; UBool avail = findNext ( now , FALSE , time , from , to ) ; if ( avail && to -> getDSTSavings ( ) != 0 ) { return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: inDaylightTime ( UDate date , UErrorCode & status ) const { if ( U_FAILURE ( status ) ) { return FALSE ; } int32_t raw , dst ; getOffset ( date , FALSE , raw , dst , status ) ; if ( dst != 0 ) { return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: hasSameRules ( const TimeZone & other ) const { if ( this == & other ) { return TRUE ; } if ( typeid ( * this ) != typeid ( other ) ) { return FALSE ; } const RuleBasedTimeZone & that = ( const RuleBasedTimeZone & ) other ; if ( * fInitialRule != * ( that . fInitialRule ) ) { return FALSE ; } if ( compareRules ( fHistoricRules , that . fHistoricRules ) && compareRules ( fFinalRules , that . fFinalRules ) ) { return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: getNextTransition ( UDate base , UBool inclusive , TimeZoneTransition & result ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; if ( U_FAILURE ( status ) ) { return FALSE ; } UDate transitionTime ; TimeZoneRule * fromRule , * toRule ; UBool found = findNext ( base , inclusive , transitionTime , fromRule , toRule ) ; if ( found ) { result . setTime ( transitionTime ) ; result . setFrom ( ( const TimeZoneRule & ) * fromRule ) ; result . setTo ( ( const TimeZoneRule & ) * toRule ) ; return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: getPreviousTransition ( UDate base , UBool inclusive , TimeZoneTransition & result ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; if ( U_FAILURE ( status ) ) { return FALSE ; } UDate transitionTime ; TimeZoneRule * fromRule , * toRule ; UBool found = findPrev ( base , inclusive , transitionTime , fromRule , toRule ) ; if ( found ) { result . setTime ( transitionTime ) ; result . setFrom ( ( const TimeZoneRule & ) * fromRule ) ; result . setTo ( ( const TimeZoneRule & ) * toRule ) ; return TRUE ; } return FALSE ; } int32_t RuleBasedTimeZone :: countTransitionRules ( UErrorCode & ) { int32_t count = 0 ; if ( fHistoricRules != NULL ) { count += fHistoricRules -> size ( ) ; } if ( fFinalRules != NULL ) { count += fFinalRules -> size ( ) ; } return count ; } void RuleBasedTimeZone :: getTimeZoneRules ( const InitialTimeZoneRule * & initial , const TimeZoneRule * trsrules [ ] , int32_t & trscount , UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } initial = fInitialRule ; int32_t cnt = 0 ; int32_t idx ; if ( fHistoricRules != NULL && cnt < trscount ) { int32_t historicCount = fHistoricRules -> size ( ) ; idx = 0 ; while ( cnt < trscount && idx < historicCount ) { trsrules [ cnt ++ ] = ( const TimeZoneRule * ) fHistoricRules -> elementAt ( idx ++ ) ; } } if ( fFinalRules != NULL && cnt < trscount ) { int32_t finalCount = fFinalRules -> size ( ) ; idx = 0 ; while ( cnt < trscount && idx < finalCount ) { trsrules [ cnt ++ ] = ( const TimeZoneRule * ) fFinalRules -> elementAt ( idx ++ ) ; } } trscount = cnt ; } void RuleBasedTimeZone :: deleteRules ( void ) { delete fInitialRule ; fInitialRule = NULL ; if ( fHistoricRules != NULL ) { while ( ! fHistoricRules -> isEmpty ( ) ) { delete ( TimeZoneRule * ) ( fHistoricRules -> orphanElementAt ( 0 ) ) ; } delete fHistoricRules ; fHistoricRules = NULL ; } if ( fFinalRules != NULL ) { while ( ! fFinalRules -> isEmpty ( ) ) { delete ( AnnualTimeZoneRule * ) ( fFinalRules -> orphanElementAt ( 0 ) ) ; } delete fFinalRules ; fFinalRules = NULL ; } } void RuleBasedTimeZone :: deleteTransitions ( void ) { if ( fHistoricTransitions != NULL ) { while ( ! fHistoricTransitions -> isEmpty ( ) ) { Transition * trs = ( Transition * ) fHistoricTransitions -> orphanElementAt ( 0 ) ; uprv_free ( trs ) ; } delete fHistoricTransitions ; } fHistoricTransitions = NULL ; } UVector * RuleBasedTimeZone :: copyRules ( UVector * source ) { if ( source == NULL ) { return NULL ; } UErrorCode ec = U_ZERO_ERROR ; int32_t size = source -> size ( ) ; UVector * rules = new UVector ( size , ec ) ; if ( U_FAILURE ( ec ) ) { return NULL ; } int32_t i ; for ( i = 0 ; i < size ; i ++ ) { rules -> addElement ( ( ( TimeZoneRule * ) source -> elementAt ( i ) ) -> clone ( ) , ec ) ; if ( U_FAILURE ( ec ) ) { break ; } } if ( U_FAILURE ( ec ) ) { for ( i = 0 ; i < rules -> size ( ) ; i ++ ) { TimeZoneRule * rule = ( TimeZoneRule * ) rules -> orphanElementAt ( i ) ; delete rule ; } delete rules ; return NULL ; } return rules ; } TimeZoneRule * RuleBasedTimeZone :: findRuleInFinal ( UDate date , UBool local , int32_t NonExistingTimeOpt , int32_t DuplicatedTimeOpt ) const { if ( fFinalRules == NULL ) { return NULL ; } AnnualTimeZoneRule * fr0 = ( AnnualTimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; AnnualTimeZoneRule * fr1 = ( AnnualTimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; if ( fr0 == NULL || fr1 == NULL ) { return NULL ; } UDate start0 , start1 ; UDate base ; int32_t localDelta ; base = date ; if ( local ) { localDelta = getLocalDelta ( fr1 -> getRawOffset ( ) , fr1 -> getDSTSavings ( ) , fr0 -> getRawOffset ( ) , fr0 -> getDSTSavings ( ) , NonExistingTimeOpt , DuplicatedTimeOpt ) ; base -= localDelta ; } UBool avail0 = fr0 -> getPreviousStart ( base , fr1 -> getRawOffset ( ) , fr1 -> getDSTSavings ( ) , TRUE , start0 ) ; base = date ; if ( local ) { localDelta = getLocalDelta ( fr0 -> getRawOffset ( ) , fr0 -> getDSTSavings ( ) , fr1 -> getRawOffset ( ) , fr1 -> getDSTSavings ( ) , NonExistingTimeOpt , DuplicatedTimeOpt ) ; base -= localDelta ; } UBool avail1 = fr1 -> getPreviousStart ( base , fr0 -> getRawOffset ( ) , fr0 -> getDSTSavings ( ) , TRUE , start1 ) ; if ( avail0 && ( ! avail1 || start0 > start1 ) ) { return fr0 ; } else if ( avail1 ) { return fr1 ; } return NULL ; } UBool RuleBasedTimeZone :: findNext ( UDate base , UBool inclusive , UDate & transitionTime , TimeZoneRule * & fromRule , TimeZoneRule * & toRule ) const { if ( fHistoricTransitions == NULL ) { return FALSE ; } UBool isFinal = FALSE ; UBool found = FALSE ; Transition result ; Transition * tzt = ( Transition * ) fHistoricTransitions -> elementAt ( 0 ) ; UDate tt = tzt -> time ; if ( tt > base || ( inclusive && tt == base ) ) { result = * tzt ; found = TRUE ; } else { int32_t idx = fHistoricTransitions -> size ( ) - 1 ; tzt = ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ; tt = tzt -> time ; if ( inclusive && tt == base ) { result = * tzt ; found = TRUE ; } else if ( tt <= base ) { if ( fFinalRules != NULL ) { TimeZoneRule * r0 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; TimeZoneRule * r1 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; UDate start0 , start1 ; UBool avail0 = r0 -> getNextStart ( base , r1 -> getRawOffset ( ) , r1 -> getDSTSavings ( ) , inclusive , start0 ) ; UBool avail1 = r1 -> getNextStart ( base , r0 -> getRawOffset ( ) , r0 -> getDSTSavings ( ) , inclusive , start1 ) ; if ( ! avail0 && ! avail1 ) { return FALSE ; } if ( ! avail1 || start0 < start1 ) { result . time = start0 ; result . from = r1 ; result . to = r0 ; } else { result . time = start1 ; result . from = r0 ; result . to = r1 ; } isFinal = TRUE ; found = TRUE ; } } else { idx -- ; Transition * prev = tzt ; while ( idx > 0 ) { tzt = ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ; tt = tzt -> time ; if ( tt < base || ( ! inclusive && tt == base ) ) { break ; } idx -- ; prev = tzt ; } result . time = prev -> time ; result . from = prev -> from ; result . to = prev -> to ; found = TRUE ; } } if ( found ) { if ( result . from -> getRawOffset ( ) == result . to -> getRawOffset ( ) && result . from -> getDSTSavings ( ) == result . to -> getDSTSavings ( ) ) { if ( isFinal ) { return FALSE ; } else { return findNext ( result . time , FALSE , transitionTime , fromRule , toRule ) ; } } transitionTime = result . time ; fromRule = result . from ; toRule = result . to ; return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: findPrev ( UDate base , UBool inclusive , UDate & transitionTime , TimeZoneRule * & fromRule , TimeZoneRule * & toRule ) const { if ( fHistoricTransitions == NULL ) { return FALSE ; } UBool found = FALSE ; Transition result ; Transition * tzt = ( Transition * ) fHistoricTransitions -> elementAt ( 0 ) ; UDate tt = tzt -> time ; if ( inclusive && tt == base ) { result = * tzt ; found = TRUE ; } else if ( tt < base ) { int32_t idx = fHistoricTransitions -> size ( ) - 1 ; tzt = ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ; tt = tzt -> time ; if ( inclusive && tt == base ) { result = * tzt ; found = TRUE ; } else if ( tt < base ) { if ( fFinalRules != NULL ) { TimeZoneRule * r0 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; TimeZoneRule * r1 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; UDate start0 , start1 ; UBool avail0 = r0 -> getPreviousStart ( base , r1 -> getRawOffset ( ) , r1 -> getDSTSavings ( ) , inclusive , start0 ) ; UBool avail1 = r1 -> getPreviousStart ( base , r0 -> getRawOffset ( ) , r0 -> getDSTSavings ( ) , inclusive , start1 ) ; if ( ! avail0 && ! avail1 ) { return FALSE ; } if ( ! avail1 || start0 > start1 ) { result . time = start0 ; result . from = r1 ; result . to = r0 ; } else { result . time = start1 ; result . from = r0 ; result . to = r1 ; } } else { result = * tzt ; } found = TRUE ; } else { idx -- ; while ( idx >= 0 ) { tzt = ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ; tt = tzt -> time ; if ( tt < base || ( inclusive && tt == base ) ) { break ; } idx -- ; } result = * tzt ; found = TRUE ; } } if ( found ) { if ( result . from -> getRawOffset ( ) == result . to -> getRawOffset ( ) && result . from -> getDSTSavings ( ) == result . to -> getDSTSavings ( ) ) { return findPrev ( result . time , FALSE , transitionTime , fromRule , toRule ) ; } transitionTime = result . time ; fromRule = result . from ; toRule = result . to ; return TRUE ; } return FALSE ; } UDate RuleBasedTimeZone :: getTransitionTime ( Transition * transition , UBool local , int32_t NonExistingTimeOpt , int32_t DuplicatedTimeOpt ) const { UDate time = transition -> time ; if ( local ) { time += getLocalDelta ( transition -> from -> getRawOffset ( ) , transition -> from -> getDSTSavings ( ) , transition -> to -> getRawOffset ( ) , transition -> to -> getDSTSavings ( ) , NonExistingTimeOpt , DuplicatedTimeOpt ) ; } return time ; } int32_t RuleBasedTimeZone :: getLocalDelta ( int32_t rawBefore , int32_t dstBefore , int32_t rawAfter , int32_t dstAfter , int32_t NonExistingTimeOpt , int32_t DuplicatedTimeOpt ) const { int32_t delta = 0 ; int32_t offsetBefore = rawBefore + dstBefore ; int32_t offsetAfter = rawAfter + dstAfter ; UBool dstToStd = ( dstBefore != 0 ) && ( dstAfter == 0 ) ; UBool stdToDst = ( dstBefore == 0 ) && ( dstAfter != 0 ) ; if ( offsetAfter - offsetBefore >= 0 ) { if ( ( ( NonExistingTimeOpt & kStdDstMask ) == kStandard && dstToStd ) || ( ( NonExistingTimeOpt & kStdDstMask ) == kDaylight && stdToDst ) ) { delta = offsetBefore ; } else if ( ( ( NonExistingTimeOpt & kStdDstMask ) == kStandard && stdToDst ) || ( ( NonExistingTimeOpt & kStdDstMask ) == kDaylight && dstToStd ) ) { delta = offsetAfter ; } else if ( ( NonExistingTimeOpt & kFormerLatterMask ) == kLatter ) { delta = offsetBefore ; } else { delta = offsetAfter ; } } else { if ( ( ( DuplicatedTimeOpt & kStdDstMask ) == kStandard && dstToStd ) || ( ( DuplicatedTimeOpt & kStdDstMask ) == kDaylight && stdToDst ) ) { delta = offsetAfter ; } else if ( ( ( DuplicatedTimeOpt & kStdDstMask ) == kStandard && stdToDst ) || ( ( DuplicatedTimeOpt & kStdDstMask ) == kDaylight && dstToStd ) ) { delta = offsetBefore ; } else if ( ( DuplicatedTimeOpt & kFormerLatterMask ) == kFormer ) { delta = offsetBefore ; } else { delta = offsetAfter ; } } return delta ; } U_NAMESPACE_END # endif </DOCUMENT>
<DOCUMENT_ID="BenKeyFSI/poedit/tree/master/deps/boost/libs/wave/test/testwave/testfiles/t_6_044.cpp"> # define CON ## name CON </DOCUMENT>
<DOCUMENT_ID="Sumahitha/samples/tree/master/AllJoyn/Samples/BACnetAdapter/HeadlessAdapterApp/pch.cpp"> # include " pch . h " </DOCUMENT>
<DOCUMENT_ID="MobWiMetro/gba10/tree/master/GBA10/VBAM/gba/gbafilter.cpp"> # include " gbafilter . h " # include < math . h > extern int systemColorDepth ; extern int systemRedShift ; extern int systemGreenShift ; extern int systemBlueShift ; extern u16 systemColorMap16 [ 0x10000 ] ; extern u32 systemColorMap32 [ 0x10000 ] ; static const unsigned char curve [ 32 ] = { 0x08 , 0x09 , 0x0a , 0x0b , 0x0c , 0x0e , 0x10 , 0x12 , 0x14 , 0x16 , 0x18 , 0x1c , 0x20 , 0x28 , 0x30 , 0x38 , 0x40 , 0x48 , 0x50 , 0x58 , 0x60 , 0x68 , 0x70 , 0x80 , 0x88 , 0x90 , 0xa0 , 0xb0 , 0xc0 , 0xd0 , 0xe0 , 0xf0 } ; static const unsigned char influence [ 3 * 3 ] = { 16 , 4 , 4 , 8 , 16 , 8 , 0 , 8 , 16 } ; inline void swap ( short & a , short & b ) { short temp = a ; a = b ; b = temp ; } void gbafilter_pal ( u16 * buf , int count ) { short temp [ 3 * 3 ] , s ; unsigned pix ; u8 red , green , blue ; while ( count -- ) { pix = * buf ; s = curve [ ( pix >> systemGreenShift ) & 0x1f ] ; temp [ 3 ] = s * influence [ 3 ] ; temp [ 4 ] = s * influence [ 4 ] ; temp [ 5 ] = s * influence [ 5 ] ; s = curve [ ( pix >> systemRedShift ) & 0x1f ] ; temp [ 0 ] = s * influence [ 0 ] ; temp [ 1 ] = s * influence [ 1 ] ; temp [ 2 ] = s * influence [ 2 ] ; s = curve [ ( pix >> systemBlueShift ) & 0x1f ] ; temp [ 6 ] = s * influence [ 6 ] ; temp [ 7 ] = s * influence [ 7 ] ; temp [ 8 ] = s * influence [ 8 ] ; if ( temp [ 0 ] < temp [ 3 ] ) swap ( temp [ 0 ] , temp [ 3 ] ) ; if ( temp [ 0 ] < temp [ 6 ] ) swap ( temp [ 0 ] , temp [ 6 ] ) ; if ( temp [ 3 ] < temp [ 6 ] ) swap ( temp [ 3 ] , temp [ 6 ] ) ; temp [ 3 ] <<= 1 ; temp [ 0 ] <<= 2 ; temp [ 0 ] += temp [ 3 ] + temp [ 6 ] ; red = ( ( int ( temp [ 0 ] ) * 160 ) >> 17 ) + 4 ; if ( red > 31 ) red = 31 ; if ( temp [ 2 ] < temp [ 5 ] ) swap ( temp [ 2 ] , temp [ 5 ] ) ; if ( temp [ 2 ] < temp [ 8 ] ) swap ( temp [ 2 ] , temp [ 8 ] ) ; if ( temp [ 5 ] < temp [ 8 ] ) swap ( temp [ 5 ] , temp [ 8 ] ) ; temp [ 5 ] <<= 1 ; temp [ 2 ] <<= 2 ; temp [ 2 ] += temp [ 5 ] + temp [ 8 ] ; blue = ( ( int ( temp [ 2 ] ) * 160 ) >> 17 ) + 4 ; if ( blue > 31 ) blue = 31 ; if ( temp [ 1 ] < temp [ 4 ] ) swap ( temp [ 1 ] , temp [ 4 ] ) ; if ( temp [ 1 ] < temp [ 7 ] ) swap ( temp [ 1 ] , temp [ 7 ] ) ; if ( temp [ 4 ] < temp [ 7 ] ) swap ( temp [ 4 ] , temp [ 7 ] ) ; temp [ 4 ] <<= 1 ; temp [ 1 ] <<= 2 ; temp [ 1 ] += temp [ 4 ] + temp [ 7 ] ; green = ( ( int ( temp [ 1 ] ) * 160 ) >> 17 ) + 4 ; if ( green > 31 ) green = 31 ; pix = red << systemRedShift ; pix += green << systemGreenShift ; pix += blue << systemBlueShift ; * buf ++ = pix ; } } void gbafilter_pal32 ( u32 * buf , int count ) { short temp [ 3 * 3 ] , s ; unsigned pix ; u8 red , green , blue ; while ( count -- ) { pix = * buf ; s = curve [ ( pix >> systemGreenShift ) & 0x1f ] ; temp [ 3 ] = s * influence [ 3 ] ; temp [ 4 ] = s * influence [ 4 ] ; temp [ 5 ] = s * influence [ 5 ] ; s = curve [ ( pix >> systemRedShift ) & 0x1f ] ; temp [ 0 ] = s * influence [ 0 ] ; temp [ 1 ] = s * influence [ 1 ] ; temp [ 2 ] = s * influence [ 2 ] ; s = curve [ ( pix >> systemBlueShift ) & 0x1f ] ; temp [ 6 ] = s * influence [ 6 ] ; temp [ 7 ] = s * influence [ 7 ] ; temp [ 8 ] = s * influence [ 8 ] ; if ( temp [ 0 ] < temp [ 3 ] ) swap ( temp [ 0 ] , temp [ 3 ] ) ; if ( temp [ 0 ] < temp [ 6 ] ) swap ( temp [ 0 ] , temp [ 6 ] ) ; if ( temp [ 3 ] < temp [ 6 ] ) swap ( temp [ 3 ] , temp [ 6 ] ) ; temp [ 3 ] <<= 1 ; temp [ 0 ] <<= 2 ; temp [ 0 ] += temp [ 3 ] + temp [ 6 ] ; red = ( ( int ( temp [ 0 ] ) * 160 ) >> 14 ) + 32 ; if ( temp [ 2 ] < temp [ 5 ] ) swap ( temp [ 2 ] , temp [ 5 ] ) ; if ( temp [ 2 ] < temp [ 8 ] ) swap ( temp [ 2 ] , temp [ 8 ] ) ; if ( temp [ 5 ] < temp [ 8 ] ) swap ( temp [ 5 ] , temp [ 8 ] ) ; temp [ 5 ] <<= 1 ; temp [ 2 ] <<= 2 ; temp [ 2 ] += temp [ 5 ] + temp [ 8 ] ; blue = ( ( int ( temp [ 2 ] ) * 160 ) >> 14 ) + 32 ; if ( temp [ 1 ] < temp [ 4 ] ) swap ( temp [ 1 ] , temp [ 4 ] ) ; if ( temp [ 1 ] < temp [ 7 ] ) swap ( temp [ 1 ] , temp [ 7 ] ) ; if ( temp [ 4 ] < temp [ 7 ] ) swap ( temp [ 4 ] , temp [ 7 ] ) ; temp [ 4 ] <<= 1 ; temp [ 1 ] <<= 2 ; temp [ 1 ] += temp [ 4 ] + temp [ 7 ] ; green = ( ( int ( temp [ 1 ] ) * 160 ) >> 14 ) + 32 ; pix = red << ( systemRedShift - 3 ) ; pix += green << ( systemGreenShift - 3 ) ; pix += blue << ( systemBlueShift - 3 ) ; * buf ++ = pix ; } } void gbafilter_pad ( u8 * buf , int count ) { union { struct { u8 r ; u8 g ; u8 b ; u8 a ; } part ; unsigned whole ; } mask ; mask . whole = 0x1f << systemRedShift ; mask . whole += 0x1f << systemGreenShift ; mask . whole += 0x1f << systemBlueShift ; switch ( systemColorDepth ) { case 24 : while ( count -- ) { * buf ++ &= mask . part . r ; * buf ++ &= mask . part . g ; * buf ++ &= mask . part . b ; } break ; case 32 : while ( count -- ) { * ( ( u32 * ) buf ) &= mask . whole ; buf += 4 ; } } } </DOCUMENT>
<DOCUMENT_ID="circa-one/OpenJK-Alt/tree/master/code/cgame/cg_marks.cpp"> # include " cg _ headers . h " # include " cg _ media . h " markPoly_t cg_activeMarkPolys ; markPoly_t * cg_freeMarkPolys ; markPoly_t cg_markPolys [ MAX_MARK_POLYS ] ; void CG_InitMarkPolys ( void ) { int i ; memset ( cg_markPolys , 0 , sizeof ( cg_markPolys ) ) ; cg_activeMarkPolys . nextMark = & cg_activeMarkPolys ; cg_activeMarkPolys . prevMark = & cg_activeMarkPolys ; cg_freeMarkPolys = cg_markPolys ; for ( i = 0 ; i < MAX_MARK_POLYS - 1 ; i ++ ) { cg_markPolys [ i ] . nextMark = & cg_markPolys [ i + 1 ] ; } } void CG_FreeMarkPoly ( markPoly_t * le ) { if ( ! le -> prevMark ) { CG_Error ( " CG _ FreeLocalEntity : ▁ not ▁ active " ) ; } le -> prevMark -> nextMark = le -> nextMark ; le -> nextMark -> prevMark = le -> prevMark ; le -> nextMark = cg_freeMarkPolys ; cg_freeMarkPolys = le ; } markPoly_t * CG_AllocMark ( void ) { markPoly_t * le ; int time ; if ( ! cg_freeMarkPolys ) { time = cg_activeMarkPolys . prevMark -> time ; while ( cg_activeMarkPolys . prevMark && time == cg_activeMarkPolys . prevMark -> time ) { CG_FreeMarkPoly ( cg_activeMarkPolys . prevMark ) ; } } le = cg_freeMarkPolys ; cg_freeMarkPolys = cg_freeMarkPolys -> nextMark ; memset ( le , 0 , sizeof ( * le ) ) ; le -> nextMark = cg_activeMarkPolys . nextMark ; le -> prevMark = & cg_activeMarkPolys ; cg_activeMarkPolys . nextMark -> prevMark = le ; cg_activeMarkPolys . nextMark = le ; return le ; } # define MAX_MARK_FRAGMENTS 128 # define MAX_MARK_POINTS 384 void CG_ImpactMark ( qhandle_t markShader , const vec3_t origin , const vec3_t dir , float orientation , float red , float green , float blue , float alpha , qboolean alphaFade , float radius , qboolean temporary ) { vec3_t axis [ 3 ] ; float texCoordScale ; vec3_t originalPoints [ 4 ] ; byte colors [ 4 ] ; int i , j ; int numFragments ; markFragment_t markFragments [ MAX_MARK_FRAGMENTS ] , * mf ; vec3_t markPoints [ MAX_MARK_POINTS ] ; vec3_t projection ; if ( ! cg_addMarks . integer ) { return ; } if ( radius <= 0 ) { CG_Error ( " CG _ ImpactMark ▁ called ▁ with ▁ < = ▁ 0 ▁ radius " ) ; } VectorNormalize2 ( dir , axis [ 0 ] ) ; PerpendicularVector ( axis [ 1 ] , axis [ 0 ] ) ; RotatePointAroundVector ( axis [ 2 ] , axis [ 0 ] , axis [ 1 ] , orientation ) ; CrossProduct ( axis [ 0 ] , axis [ 2 ] , axis [ 1 ] ) ; texCoordScale = 0.5 * 1.0 / radius ; for ( i = 0 ; i < 3 ; i ++ ) { originalPoints [ 0 ] [ i ] = origin [ i ] - radius * axis [ 1 ] [ i ] - radius * axis [ 2 ] [ i ] ; originalPoints [ 1 ] [ i ] = origin [ i ] + radius * axis [ 1 ] [ i ] - radius * axis [ 2 ] [ i ] ; originalPoints [ 2 ] [ i ] = origin [ i ] + radius * axis [ 1 ] [ i ] + radius * axis [ 2 ] [ i ] ; originalPoints [ 3 ] [ i ] = origin [ i ] - radius * axis [ 1 ] [ i ] + radius * axis [ 2 ] [ i ] ; } VectorScale ( dir , - 20 , projection ) ; numFragments = cgi_CM_MarkFragments ( 4 , ( const float ( * ) [ 3 ] ) originalPoints , projection , MAX_MARK_POINTS , markPoints [ 0 ] , MAX_MARK_FRAGMENTS , markFragments ) ; colors [ 0 ] = red * 255 ; colors [ 1 ] = green * 255 ; colors [ 2 ] = blue * 255 ; colors [ 3 ] = alpha * 255 ; for ( i = 0 , mf = markFragments ; i < numFragments ; i ++ , mf ++ ) { polyVert_t * v ; polyVert_t verts [ MAX_VERTS_ON_POLY ] ; markPoly_t * mark ; if ( mf -> numPoints > MAX_VERTS_ON_POLY ) { mf -> numPoints = MAX_VERTS_ON_POLY ; } for ( j = 0 , v = verts ; j < mf -> numPoints ; j ++ , v ++ ) { vec3_t delta ; VectorCopy ( markPoints [ mf -> firstPoint + j ] , v -> xyz ) ; VectorSubtract ( v -> xyz , origin , delta ) ; v -> st [ 0 ] = 0.5f + DotProduct ( delta , axis [ 1 ] ) * texCoordScale ; v -> st [ 1 ] = 0.5f + DotProduct ( delta , axis [ 2 ] ) * texCoordScale ; for ( int k = 0 ; k < 4 ; k ++ ) { v -> modulate [ k ] = colors [ k ] ; } } if ( temporary ) { cgi_R_AddPolyToScene ( markShader , mf -> numPoints , verts ) ; continue ; } mark = CG_AllocMark ( ) ; mark -> time = cg . time ; mark -> alphaFade = alphaFade ; mark -> markShader = markShader ; mark -> poly . numVerts = mf -> numPoints ; mark -> color [ 0 ] = colors [ 0 ] ; mark -> color [ 1 ] = colors [ 1 ] ; mark -> color [ 2 ] = colors [ 2 ] ; mark -> color [ 3 ] = colors [ 3 ] ; memcpy ( mark -> verts , verts , mf -> numPoints * sizeof ( verts [ 0 ] ) ) ; } } # define MARK_TOTAL_TIME 10000 # define MARK_FADE_TIME 1000 void CG_AddMarks ( void ) { int j ; markPoly_t * mp , * next ; int t ; int fade ; if ( ! cg_addMarks . integer ) { return ; } mp = cg_activeMarkPolys . nextMark ; for ( ; mp != & cg_activeMarkPolys ; mp = next ) { next = mp -> nextMark ; if ( cg . time > mp -> time + MARK_TOTAL_TIME ) { CG_FreeMarkPoly ( mp ) ; continue ; } t = mp -> time + MARK_TOTAL_TIME - cg . time ; if ( t < MARK_FADE_TIME ) { fade = 255 * t / MARK_FADE_TIME ; if ( mp -> alphaFade ) { for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 3 ] = fade ; } } else { float f = ( float ) t / MARK_FADE_TIME ; for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 0 ] = mp -> color [ 0 ] * f ; mp -> verts [ j ] . modulate [ 1 ] = mp -> color [ 1 ] * f ; mp -> verts [ j ] . modulate [ 2 ] = mp -> color [ 2 ] * f ; } } } else { for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 0 ] = mp -> color [ 0 ] ; mp -> verts [ j ] . modulate [ 1 ] = mp -> color [ 1 ] ; mp -> verts [ j ] . modulate [ 2 ] = mp -> color [ 2 ] ; } } cgi_R_AddPolyToScene ( mp -> markShader , mp -> poly . numVerts , mp -> verts ) ; } } </DOCUMENT>
<DOCUMENT_ID="native-m/slmath/tree/master/source/intersect_util.cpp"> # include < slm / intersect_util . h > SLMATH_BEGIN ( ) intersectLineBox_Line :: intersectLineBox_Line ( const vec3 & origin , const vec3 & direction ) : o ( origin ) , d ( direction ) , inv_d ( fabsf ( direction . x ) > FLT_MIN ? 1 . f / direction . x : FLT_MAX , fabsf ( direction . y ) > FLT_MIN ? 1 . f / direction . y : FLT_MAX , fabsf ( direction . z ) > FLT_MIN ? 1 . f / direction . z : FLT_MAX ) , signx ( direction . x < 0 . f ) , signy ( direction . y < 0 . f ) , signz ( direction . z < 0 . f ) { } bool intersectLineTri ( const vec3 & o , const vec3 & d , const vec3 & v0 , const vec3 & v1 , const vec3 & v2 , float * t ) { const vec3 e1 = v1 - v0 ; const vec3 e2 = v2 - v0 ; const vec3 pvec = cross ( d , e2 ) ; const float det = dot ( e1 , pvec ) ; if ( fabsf ( det ) <= FLT_MIN ) return false ; const float invdet = 1 . f / det ; const vec3 tvec = o - v0 ; const float u = dot ( tvec , pvec ) * invdet ; if ( 0 . f > u || 1 . f < u ) return false ; const vec3 qvec = cross ( tvec , e1 ) ; const float v = dot ( d , qvec ) * invdet ; if ( 0 . f > v || 1 . f < u + v ) return false ; const float s = dot ( e2 , qvec ) * invdet ; if ( s < 0 . f || s >= 1 . f ) return false ; if ( t ) * t = s ; assert ( s >= 0 . f && s <= 1 . f ) ; return true ; } bool intersectLineBox ( const intersectLineBox_Line & r , const vec3 * boxminmax ) { const float t0 = 0.0f ; const float t1 = 1.0f ; const int * const sign = & r . signx ; register float tmin , tmax , tymin , tymax , tzmin , tzmax ; tmin = ( boxminmax [ sign [ 0 ] ] . x - r . o . x ) * r . inv_d . x ; tmax = ( boxminmax [ 1 - sign [ 0 ] ] . x - r . o . x ) * r . inv_d . x ; tymin = ( boxminmax [ sign [ 1 ] ] . y - r . o . y ) * r . inv_d . y ; tymax = ( boxminmax [ 1 - sign [ 1 ] ] . y - r . o . y ) * r . inv_d . y ; if ( ( tmin > tymax ) || ( tymin > tmax ) ) return false ; if ( tymin > tmin ) tmin = tymin ; if ( tymax < tmax ) tmax = tymax ; tzmin = ( boxminmax [ sign [ 2 ] ] . z - r . o . z ) * r . inv_d . z ; tzmax = ( boxminmax [ 1 - sign [ 2 ] ] . z - r . o . z ) * r . inv_d . z ; if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false ; if ( tzmin > tmin ) tmin = tzmin ; if ( tzmax < tmax ) tmax = tzmax ; return ( ( tmin < t1 ) && ( tmax > t0 ) ) ; } bool intersectLineBox ( const vec3 & o , const vec3 & d , const vec3 & boxmin , const vec3 & boxmax ) { intersectLineBox_Line line ( o , d ) ; const vec3 boxminmax [ 2 ] = { boxmin , boxmax } ; return intersectLineBox ( line , boxminmax ) ; } SLMATH_END ( ) </DOCUMENT>
<DOCUMENT_ID="cristal/Patch/tree/master/dep/acelite/ace/Parse_Node.cpp"> # include " ace / Parse _ Node . h " # if ( ACE_USES_CLASSIC_SVC_CONF == 1 ) # include " ace / Service _ Config . h " # include " ace / Service _ Repository . h " # include " ace / Service _ Types . h " # include " ace / Task . h " # include " ace / DLL . h " # include " ace / ACE . h " # include " ace / OS _ NS _ string . h " # include " ace / ARGV . h " # include < list > ACE_BEGIN_VERSIONED_NAMESPACE_DECL ACE_ALLOC_HOOK_DEFINE ( ACE_Stream_Node ) void ACE_Stream_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Stream _ Node : : dump " ) ; # endif } void ACE_Stream_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Stream _ Node : : apply " ) ; const ACE_Service_Type * sst = this -> node_ -> record ( config ) ; if ( sst == 0 ) const_cast < ACE_Static_Node * > ( this -> node_ ) -> apply ( config , yyerrno ) ; if ( yyerrno != 0 ) return ; sst = this -> node_ -> record ( config ) ; ACE_Stream_Type * st = dynamic_cast < ACE_Stream_Type * > ( const_cast < ACE_Service_Type_Impl * > ( sst -> type ( ) ) ) ; std :: list < const ACE_Static_Node * > mod_list ; const ACE_Static_Node * module ; for ( module = dynamic_cast < const ACE_Static_Node * > ( this -> mods_ ) ; module != 0 ; module = dynamic_cast < ACE_Static_Node * > ( module -> link ( ) ) ) mod_list . push_front ( module ) ; std :: list < const ACE_Static_Node * > :: const_iterator iter ; for ( iter = mod_list . begin ( ) ; iter != mod_list . end ( ) ; ++ iter ) { module = * iter ; ACE_ARGV args ( module -> parameters ( ) ) ; const ACE_Service_Type * mst = module -> record ( config ) ; if ( mst == 0 ) const_cast < ACE_Static_Node * > ( module ) -> apply ( config , yyerrno ) ; if ( yyerrno != 0 ) { if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " dynamic ▁ initialization ▁ failed ▁ for ▁ Module ▁ % s \n " ) , module -> name ( ) ) ) ; } ++ yyerrno ; continue ; } ACE_Module_Type const * const mt1 = static_cast < ACE_Module_Type const * > ( module -> record ( config ) -> type ( ) ) ; ACE_Module_Type * mt = const_cast < ACE_Module_Type * > ( mt1 ) ; if ( st -> push ( mt ) == - 1 ) { if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " dynamic ▁ initialization ▁ failed ▁ for ▁ Stream ▁ % s \n " ) , this -> node_ -> name ( ) ) ) ; } ++ yyerrno ; } } # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ( % P | % t ) ▁ Did ▁ stream ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> node_ -> name ( ) , yyerrno ) ) ; # endif } ACE_ALLOC_HOOK_DEFINE ( ACE_Parse_Node ) void ACE_Parse_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Parse _ Node : : dump " ) ; # endif } const ACE_TCHAR * ACE_Parse_Node :: name ( void ) const { ACE_TRACE ( " ACE _ Parse _ Node : : name " ) ; return this -> name_ ; } ACE_Parse_Node * ACE_Parse_Node :: link ( void ) const { ACE_TRACE ( " ACE _ Parse _ Node : : link " ) ; return this -> next_ ; } void ACE_Parse_Node :: link ( ACE_Parse_Node * n ) { ACE_TRACE ( " ACE _ Parse _ Node : : link " ) ; ACE_Parse_Node * t = this ; while ( t -> next_ != 0 ) t = t -> next_ ; t -> next_ = n ; } ACE_Stream_Node :: ACE_Stream_Node ( const ACE_Static_Node * str_ops , const ACE_Parse_Node * str_mods ) : ACE_Parse_Node ( ( str_ops == 0 ? ACE_TEXT ( " < unknown > " ) : str_ops -> name ( ) ) ) , node_ ( str_ops ) , mods_ ( str_mods ) { ACE_TRACE ( " ACE _ Stream _ Node : : ACE _ Stream _ Node " ) ; } ACE_Stream_Node :: ~ ACE_Stream_Node ( void ) { ACE_TRACE ( " ACE _ Stream _ Node : : ~ ACE _ Stream _ Node " ) ; ACE_Static_Node * n = const_cast < ACE_Static_Node * > ( this -> node_ ) ; delete n ; ACE_Parse_Node * m = const_cast < ACE_Parse_Node * > ( this -> mods_ ) ; delete m ; } ACE_Parse_Node :: ACE_Parse_Node ( void ) : name_ ( 0 ) , next_ ( 0 ) { ACE_TRACE ( " ACE _ Parse _ Node : : ACE _ Parse _ Node " ) ; } ACE_Parse_Node :: ACE_Parse_Node ( const ACE_TCHAR * nm ) : name_ ( ACE :: strnew ( nm ) ) , next_ ( 0 ) { ACE_TRACE ( " ACE _ Parse _ Node : : ACE _ Parse _ Node " ) ; } void ACE_Parse_Node :: print ( void ) const { ACE_TRACE ( " ACE _ Parse _ Node : : print " ) ; ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " svc ▁ = ▁ % s \n " ) , this -> name ( ) ) ) ; if ( this -> next_ ) this -> next_ -> print ( ) ; } ACE_Parse_Node :: ~ ACE_Parse_Node ( void ) { ACE_TRACE ( " ACE _ Parse _ Node : : ~ ACE _ Parse _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> name_ ) ; delete this -> next_ ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Suspend_Node ) void ACE_Suspend_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Suspend _ Node : : dump " ) ; # endif } ACE_Suspend_Node :: ACE_Suspend_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Suspend _ Node : : ACE _ Suspend _ Node " ) ; } ACE_Suspend_Node :: ~ ACE_Suspend_Node ( void ) { } ACE_ALLOC_HOOK_DEFINE ( ACE_Resume_Node ) void ACE_Resume_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Resume _ Node : : dump " ) ; # endif } ACE_Resume_Node :: ACE_Resume_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Resume _ Node : : ACE _ Resume _ Node " ) ; } ACE_Resume_Node :: ~ ACE_Resume_Node ( void ) { } void ACE_Suspend_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Suspend _ Node : : apply " ) ; if ( config -> suspend ( this -> name ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ suspend ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; # endif } void ACE_Resume_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Resume _ Node : : apply " ) ; if ( config -> resume ( this -> name ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ resume ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; # endif } ACE_ALLOC_HOOK_DEFINE ( ACE_Remove_Node ) void ACE_Remove_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Remove _ Node : : dump " ) ; # endif } ACE_Remove_Node :: ACE_Remove_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Remove _ Node : : ACE _ Remove _ Node " ) ; } ACE_Remove_Node :: ~ ACE_Remove_Node ( void ) { } void ACE_Remove_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Remove _ Node : : apply " ) ; if ( config -> remove ( this -> name ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Remove _ Node : : apply " ) ACE_TEXT ( " ▁ - ▁ did ▁ remove ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; # endif } ACE_Dynamic_Node :: ACE_Dynamic_Node ( ACE_Service_Type_Factory const * stf , ACE_TCHAR * parms ) : ACE_Static_Node ( stf -> name ( ) , parms ) , factory_ ( stf ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : ACE _ Dynamic _ Node " ) ; } void ACE_Dynamic_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : apply " ) ; if ( config -> initialize ( this -> factory_ . get ( ) , this -> parameters ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Dynamic _ Node : : apply " ) ACE_TEXT ( " ▁ - ▁ Did ▁ dynamic ▁ on ▁ % s ▁ ( yyerrno = % d ) \n " ) , this -> name ( ) , yyerrno ) ) ; # endif } ACE_ALLOC_HOOK_DEFINE ( ACE_Dynamic_Node ) void ACE_Dynamic_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Dynamic _ Node : : dump " ) ; # endif } ACE_Dynamic_Node :: ~ ACE_Dynamic_Node ( void ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : ~ ACE _ Dynamic _ Node " ) ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Static_Node ) void ACE_Static_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Static _ Node : : dump " ) ; # endif } ACE_Static_Node :: ACE_Static_Node ( const ACE_TCHAR * nm , ACE_TCHAR * params ) : ACE_Parse_Node ( nm ) , parameters_ ( ACE :: strnew ( params ) ) { ACE_TRACE ( " ACE _ Static _ Node : : ACE _ Static _ Node " ) ; } const ACE_Service_Type * ACE_Static_Node :: record ( const ACE_Service_Gestalt * config ) const { ACE_TRACE ( " ACE _ Static _ Node : : record " ) ; ACE_Service_Type * sr = 0 ; if ( config -> find ( this -> name ( ) , ( const ACE_Service_Type * * ) & sr ) == - 1 ) return 0 ; return sr ; } ACE_TCHAR * ACE_Static_Node :: parameters ( void ) const { ACE_TRACE ( " ACE _ Static _ Node : : parameters " ) ; return this -> parameters_ ; } void ACE_Static_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Static _ Node : : apply " ) ; if ( config -> initialize ( this -> name ( ) , this -> parameters ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Static _ Node : : apply ▁ - " ) ACE_TEXT ( " ▁ Did ▁ static ▁ on ▁ % s ▁ ( yyerrno = % d ) \n " ) , this -> name ( ) , yyerrno ) ) ; # endif } ACE_Static_Node :: ~ ACE_Static_Node ( void ) { ACE_TRACE ( " ACE _ Static _ Node : : ~ ACE _ Static _ Node " ) ; delete [ ] this -> parameters_ ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Location_Node ) void ACE_Location_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Location _ Node : : dump " ) ; # endif } ACE_Location_Node :: ACE_Location_Node ( void ) : pathname_ ( 0 ) , dll_ ( ) , symbol_ ( 0 ) { ACE_TRACE ( " ACE _ Location _ Node : : ACE _ Location _ Node " ) ; } ACE_Location_Node :: ~ ACE_Location_Node ( void ) { ACE_TRACE ( " ACE _ Location _ Node : : ~ ACE _ Location _ Node " ) ; } const ACE_DLL & ACE_Location_Node :: dll ( void ) { return this -> dll_ ; } const ACE_TCHAR * ACE_Location_Node :: pathname ( void ) const { ACE_TRACE ( " ACE _ Location _ Node : : pathname " ) ; return this -> pathname_ ; } void ACE_Location_Node :: pathname ( const ACE_TCHAR * p ) { ACE_TRACE ( " ACE _ Location _ Node : : pathname " ) ; this -> pathname_ = p ; } int ACE_Location_Node :: dispose ( void ) const { ACE_TRACE ( " ACE _ Location _ Node : : dispose " ) ; return this -> must_delete_ ; } int ACE_Location_Node :: open_dll ( int & yyerrno ) { ACE_TRACE ( " ACE _ Location _ Node : : open _ dll " ) ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ LN : : open _ dll ▁ - ▁ path = % s \n " ) , this -> pathname ( ) ) ) ; # endif if ( - 1 == this -> dll_ . open ( this -> pathname ( ) ) ) { ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) { ACE_TCHAR * errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ LN : : open _ dll ▁ - ▁ Failed ▁ to ▁ open ▁ % s : ▁ % s \n " ) , this -> pathname ( ) , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } # endif return - 1 ; } return 0 ; } void ACE_Location_Node :: set_symbol ( void * s ) { ACE_TRACE ( " ACE _ Location _ Node : : set _ symbol " ) ; this -> symbol_ = s ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Object_Node ) void ACE_Object_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Object _ Node : : dump " ) ; # endif } ACE_Object_Node :: ACE_Object_Node ( const ACE_TCHAR * path , const ACE_TCHAR * obj_name ) : object_name_ ( ACE :: strnew ( obj_name ) ) { ACE_TRACE ( " ACE _ Object _ Node : : ACE _ Object _ Node " ) ; this -> pathname ( ACE :: strnew ( path ) ) ; this -> must_delete_ = 0 ; } void * ACE_Object_Node :: symbol ( ACE_Service_Gestalt * , int & yyerrno , ACE_Service_Object_Exterminator * ) { ACE_TRACE ( " ACE _ Object _ Node : : symbol " ) ; if ( this -> open_dll ( yyerrno ) == 0 ) { ACE_TCHAR * object_name = const_cast < ACE_TCHAR * > ( this -> object_name_ ) ; this -> symbol_ = this -> dll_ . symbol ( object_name ) ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) { ACE_TCHAR * errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ DLL : : symbol ▁ - " ) ACE_TEXT ( " ▁ Failed ▁ for ▁ object ▁ % s : ▁ % s \n " ) , object_name , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } # endif return 0 ; } return this -> symbol_ ; } return 0 ; } ACE_Object_Node :: ~ ACE_Object_Node ( void ) { ACE_TRACE ( " ACE _ Object _ Node : : ~ ACE _ Object _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> object_name_ ) ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Function_Node ) void ACE_Function_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Function _ Node : : dump " ) ; # endif } ACE_Function_Node :: ACE_Function_Node ( const ACE_TCHAR * path , const ACE_TCHAR * func_name ) : function_name_ ( make_func_name ( func_name ) ) { ACE_TRACE ( " ACE _ Function _ Node : : ACE _ Function _ Node " ) ; this -> pathname ( ACE :: strnew ( path ) ) ; this -> must_delete_ = 1 ; } ACE_TCHAR * ACE_Function_Node :: make_func_name ( ACE_TCHAR const * func_name ) { # if defined ( ACE_HAS_VERSIONED_NAMESPACE ) && ACE_HAS_VERSIONED_NAMESPACE == 1 # define ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING_IMPL ( NAME ) # NAME # define ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING ( NAME ) ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING_IMPL ( NAME ) # define ACE_VERSIONED_NAMESPACE_NAME_STRING ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING ( ACE_VERSIONED_NAMESPACE_NAME ) static ACE_TCHAR const make_prefix [ ] = ACE_TEXT ( " _ make _ " ) ; static size_t const make_prefix_len = sizeof ( make_prefix ) / sizeof ( make_prefix [ 0 ] ) - 1 ; if ( ACE_OS :: strncmp ( make_prefix , func_name , make_prefix_len ) == 0 ) { static ACE_TCHAR const versioned_namespace_name [ ] = ACE_TEXT ( ACE_VERSIONED_NAMESPACE_NAME_STRING ) ACE_TEXT ( " _ " ) ; static size_t const versioned_namespace_name_len = sizeof ( versioned_namespace_name ) / sizeof ( versioned_namespace_name [ 0 ] ) ; size_t const len = ACE_OS :: strlen ( func_name ) + versioned_namespace_name_len ; ACE_TCHAR * mangled_func_name ; ACE_NEW_RETURN ( mangled_func_name , ACE_TCHAR [ len ] , 0 ) ; ACE_Auto_Basic_Array_Ptr < ACE_TCHAR > safe ( mangled_func_name ) ; ACE_OS :: snprintf ( mangled_func_name , len , ACE_TEXT ( " % s % s % s " ) , make_prefix , versioned_namespace_name , func_name + make_prefix_len ) ; return safe . release ( ) ; } # endif return ACE :: strnew ( func_name ) ; } void * ACE_Function_Node :: symbol ( ACE_Service_Gestalt * , int & yyerrno , ACE_Service_Object_Exterminator * gobbler ) { typedef ACE_Service_Object * ( * ACE_Service_Factory_Ptr ) ( ACE_Service_Object_Exterminator * ) ; ACE_TRACE ( " ACE _ Function _ Node : : symbol " ) ; if ( this -> open_dll ( yyerrno ) == 0 ) { this -> symbol_ = 0 ; ACE_TCHAR * const function_name = const_cast < ACE_TCHAR * > ( this -> function_name_ ) ; void * const func_p = this -> dll_ . symbol ( function_name ) ; if ( func_p == 0 ) { ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) { ACE_TCHAR * const errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " DLL : : symbol ▁ failed ▁ for ▁ function ▁ % s : ▁ " ) ACE_TEXT ( " % s \n " ) , function_name , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } # endif return 0 ; } # if defined ( ACE_OPENVMS ) && ( ! defined ( __INITIAL_POINTER_SIZE ) || ( __INITIAL_POINTER_SIZE < 64 ) ) int const temp_p = reinterpret_cast < int > ( func_p ) ; # else intptr_t const temp_p = reinterpret_cast < intptr_t > ( func_p ) ; # endif ACE_Service_Factory_Ptr func = reinterpret_cast < ACE_Service_Factory_Ptr > ( temp_p ) ; this -> symbol_ = ( * func ) ( gobbler ) ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " % p \n " ) , this -> function_name_ ) ) ; } return 0 ; } } return this -> symbol_ ; } ACE_Function_Node :: ~ ACE_Function_Node ( void ) { ACE_TRACE ( " ACE _ Function _ Node : : ~ ACE _ Function _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( function_name_ ) ; delete [ ] const_cast < ACE_TCHAR * > ( pathname_ ) ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Dummy_Node ) void ACE_Dummy_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Dummy _ Node : : dump " ) ; # endif } ACE_Dummy_Node :: ACE_Dummy_Node ( const ACE_Static_Node * static_node , const ACE_Parse_Node * str_mods ) : ACE_Parse_Node ( static_node -> name ( ) ) , node_ ( static_node ) , mods_ ( str_mods ) { ACE_TRACE ( " ACE _ Dummy _ Node : : ACE _ Dummy _ Node " ) ; } void ACE_Dummy_Node :: apply ( ACE_Service_Gestalt * , int & yyerrno ) { ACE_TRACE ( " ACE _ Dummy _ Node : : apply " ) ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ operations ▁ on ▁ stream ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; # else ACE_UNUSED_ARG ( yyerrno ) ; # endif } ACE_Dummy_Node :: ~ ACE_Dummy_Node ( void ) { ACE_TRACE ( " ACE _ Dummy _ Node : : ~ ACE _ Dummy _ Node " ) ; ACE_Static_Node * n = const_cast < ACE_Static_Node * > ( this -> node_ ) ; delete n ; ACE_Parse_Node * m = const_cast < ACE_Parse_Node * > ( this -> mods_ ) ; delete m ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Static_Function_Node ) void ACE_Static_Function_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Static _ Function _ Node : : dump " ) ; # endif } ACE_Static_Function_Node :: ACE_Static_Function_Node ( const ACE_TCHAR * func_name ) : function_name_ ( ACE :: strnew ( func_name ) ) { ACE_TRACE ( " ACE _ Static _ Function _ Node : : ACE _ Static _ Function _ Node " ) ; this -> must_delete_ = 1 ; } void * ACE_Static_Function_Node :: symbol ( ACE_Service_Gestalt * config , int & yyerrno , ACE_Service_Object_Exterminator * gobbler ) { ACE_TRACE ( " ACE _ Static _ Function _ Node : : symbol " ) ; this -> symbol_ = 0 ; ACE_Static_Svc_Descriptor * ssd = 0 ; if ( config -> find_static_svc_descriptor ( this -> function_name_ , & ssd ) == - 1 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ( % P | % t ) ▁ No ▁ static ▁ service ▁ " ) ACE_TEXT ( " registered ▁ for ▁ function ▁ % s \n " ) , this -> function_name_ ) ) ; } return 0 ; } if ( ssd -> alloc_ == 0 ) { ++ yyerrno ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ( % P | % t ) ▁ No ▁ static ▁ service ▁ factory ▁ " ) ACE_TEXT ( " function ▁ registered ▁ for ▁ function ▁ % s \n " ) , this -> function_name_ ) ) ; } return 0 ; } } this -> symbol_ = ( * ssd -> alloc_ ) ( gobbler ) ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " % p \n " ) , this -> function_name_ ) ) ; } return 0 ; } return this -> symbol_ ; } ACE_Static_Function_Node :: ~ ACE_Static_Function_Node ( void ) { ACE_TRACE ( " ACE _ Static _ Function _ Node : : ~ ACE _ Static _ Function _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> function_name_ ) ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Service_Type_Factory ) ACE_Service_Type_Factory :: ACE_Service_Type_Factory ( ACE_TCHAR const * name , int type , ACE_Location_Node * location , int active ) : name_ ( name ) , type_ ( type ) , location_ ( location ) , is_active_ ( active ) { } ACE_Service_Type_Factory :: ~ ACE_Service_Type_Factory ( void ) { } ACE_Service_Type * ACE_Service_Type_Factory :: make_service_type ( ACE_Service_Gestalt * cfg ) const { ACE_TRACE ( " ACE _ Service _ Type _ Factory : : make _ service _ type " ) ; u_int const flags = ACE_Service_Type :: DELETE_THIS | ( this -> location_ -> dispose ( ) == 0 ? 0 : ACE_Service_Type :: DELETE_OBJ ) ; int yyerrno = 0 ; ACE_Service_Object_Exterminator gobbler = 0 ; void * sym = this -> location_ -> symbol ( cfg , yyerrno , & gobbler ) ; if ( sym != 0 ) { ACE_Service_Type_Impl * stp = ACE_Service_Config :: create_service_type_impl ( this -> name ( ) , this -> type_ , sym , flags , gobbler ) ; if ( stp == 0 ) ++ yyerrno ; ACE_Service_Type * tmp = 0 ; ACE_NEW_RETURN ( tmp , ACE_Service_Type ( this -> name ( ) , stp , this -> location_ -> dll ( ) , this -> is_active_ ) , 0 ) ; return tmp ; } # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Unable ▁ to ▁ create ▁ " ) ACE_TEXT ( " service ▁ object ▁ for ▁ % s \n " ) , this -> name ( ) ) ) ; } # endif ++ yyerrno ; return 0 ; } ACE_TCHAR const * ACE_Service_Type_Factory :: name ( void ) const { return name_ . c_str ( ) ; } ACE_END_VERSIONED_NAMESPACE_DECL # endif </DOCUMENT>
<DOCUMENT_ID="kstripp/LittleBudget/tree/master/src/core/main.cpp"> # include < iostream > # include " lb . h " using std :: cout ; using std :: endl ; using std :: cerr ; # ifndef VERSION # define VERSION "1.0.1" # endif int main ( int argc , const char * argv [ ] ) { try { lb app ( argc , argv ) ; return app . run ( ) ; } catch ( lb_error e ) { cerr << e . what ( ) << endl ; return EXIT_FAILURE ; } catch ( runtime_error e ) { cerr << e . what ( ) << endl ; return EXIT_FAILURE ; } catch ( ... ) { cerr << " Unhandled ▁ exception ▁ in ▁ lb . " << endl ; return EXIT_FAILURE ; } } </DOCUMENT>
<DOCUMENT_ID="KonceptGeek/mosesdecoder/tree/master/mert/TER/infosHasher.cpp"> # include " infosHasher . h " using namespace std ; using namespace TERCPPNS_Tools ; namespace TERCPPNS_HashMapSpace { infosHasher :: infosHasher ( long cle , string cleTxt , vector < int > valueVecInt ) { m_hashKey = cle ; m_key = cleTxt ; m_value = valueVecInt ; } long infosHasher :: getHashKey ( ) { return m_hashKey ; } string infosHasher :: getKey ( ) { return m_key ; } vector < int > infosHasher :: getValue ( ) { return m_value ; } void infosHasher :: setValue ( vector < int > value ) { m_value = value ; } string infosHasher :: toString ( ) { stringstream to_return ; to_return << m_hashKey << " \t " << m_key << " \t " << vectorToString ( m_value , " \t " ) << endl ; return to_return . str ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="hkarim/JUCE-Graph-Component/tree/master/JuceLibraryCode/modules/juce_gui_basics/filebrowser/juce_ImagePreviewComponent.cpp"> ImagePreviewComponent :: ImagePreviewComponent ( ) { } ImagePreviewComponent :: ~ ImagePreviewComponent ( ) { } void ImagePreviewComponent :: getThumbSize ( int & w , int & h ) const { const int availableW = proportionOfWidth ( 0.97f ) ; const int availableH = getHeight ( ) - 13 * 4 ; const double scale = jmin ( 1.0 , availableW / ( double ) w , availableH / ( double ) h ) ; w = roundToInt ( scale * w ) ; h = roundToInt ( scale * h ) ; } void ImagePreviewComponent :: selectedFileChanged ( const File & file ) { if ( fileToLoad != file ) { fileToLoad = file ; startTimer ( 100 ) ; } } void ImagePreviewComponent :: timerCallback ( ) { stopTimer ( ) ; currentThumbnail = Image ( ) ; currentDetails . clear ( ) ; repaint ( ) ; ScopedPointer < FileInputStream > in ( fileToLoad . createInputStream ( ) ) ; if ( in != nullptr ) { if ( ImageFileFormat * const format = ImageFileFormat :: findImageFormatForStream ( * in ) ) { currentThumbnail = format -> decodeImage ( * in ) ; if ( currentThumbnail . isValid ( ) ) { int w = currentThumbnail . getWidth ( ) ; int h = currentThumbnail . getHeight ( ) ; currentDetails << fileToLoad . getFileName ( ) << " \n " << format -> getFormatName ( ) << " \n " << w << " ▁ x ▁ " << h << " ▁ pixels \n " << File :: descriptionOfSizeInBytes ( fileToLoad . getSize ( ) ) ; getThumbSize ( w , h ) ; currentThumbnail = currentThumbnail . rescaled ( w , h ) ; } } } } void ImagePreviewComponent :: paint ( Graphics & g ) { if ( currentThumbnail . isValid ( ) ) { g . setFont ( 13.0f ) ; int w = currentThumbnail . getWidth ( ) ; int h = currentThumbnail . getHeight ( ) ; getThumbSize ( w , h ) ; const int numLines = 4 ; const int totalH = 13 * numLines + h + 4 ; const int y = ( getHeight ( ) - totalH ) / 2 ; g . drawImageWithin ( currentThumbnail , ( getWidth ( ) - w ) / 2 , y , w , h , RectanglePlacement :: centred | RectanglePlacement :: onlyReduceInSize , false ) ; g . drawFittedText ( currentDetails , 0 , y + h + 4 , getWidth ( ) , 100 , Justification :: centredTop , numLines ) ; } } </DOCUMENT>
<DOCUMENT_ID="cndpost/cppidioms/tree/master/bft/bft.cpp"> # include < iostream > # include < vector > # include < queue > using namespace std ; class Tree ; class Tree { public : char data ; bool visited ; std :: vector < Tree * > children ; } ; void bft ( Tree * root ) { if ( root == NULL ) return ; if ( root -> visited ) return ; root -> visited = true ; printf ( " % c ▁ \n " , root -> data ) ; std :: queue < Tree * > * newQue = new std :: queue < Tree * > ( ) ; int Size = root -> children . size ( ) ; for ( int i = 0 ; i < Size ; i ++ ) { Tree * child = root -> children [ i ] ; if ( child != NULL ) newQue -> push ( child ) ; } for ( int i = 0 ; i < Size ; i ++ ) { Tree * child = newQue -> front ( ) ; if ( child != NULL ) bft ( child ) ; newQue -> pop ( ) ; } return ; } ; void insert ( Tree * root , char data ) { Tree * newTree = new Tree ( ) ; newTree -> data = data ; newTree -> visited = false ; root -> children . push_back ( newTree ) ; return ; } ; int main ( ) { Tree * root = new Tree ( ) ; root -> data = ' a ' ; Tree * leftChild = new Tree { } ; leftChild -> data = ' b ' ; Tree * rightChild = new Tree ( ) ; rightChild -> data = ' c ' ; root -> children . push_back ( leftChild ) ; root -> children . push_back ( rightChild ) ; cout << " start ▁ doing ▁ BFT ▁ in ▁ one ▁ way ▁ " << endl ; bft ( root ) ; delete root ; root = new Tree ( ) ; root -> data = ' a ' ; insert ( root , ' d ' ) ; insert ( root , ' e ' ) ; cout << " start ▁ doing ▁ BFT ▁ in ▁ 2nd ▁ way " << endl ; bft ( root ) ; cout << " done ▁ DFT ▁ " << endl ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="tpltnt/uncrustify/tree/master/tests/output/cpp/30920-indent-off.cpp"> struct X { void operator - ( int ) ; void operator + ( int ) ; void operator ( ) ( ) ; } ; struct Y { void operator - ( int ) { } void operator + ( int ) { } void operator ( ) ( ) { } void func ( ) { auto x = " TABSYMBOL test\t ▁ TABSYMBOL ▁ TABSYMBOL ▁ TABSYMBOL TABSYMBOL . . . ▁ ▁ ▁ ? ? ? " ; } } ; struct Y { void operator - ( int ) { } void operator + ( int ) { } void operator ( ) ( ) { } void func ( ) { auto x = " TABSYMBOL test\t ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . . . ▁ ▁ ▁ ? ? ? " ; } } ; </DOCUMENT>
<DOCUMENT_ID="HofiOne/xbmc/tree/master/xbmc/settings/dialogs/GUIDialogLibExportSettings.cpp"> # include < map > # include < memory > # include < string > # include < utility > # include < vector > # include < limits . h > # include " GUIDialogLibExportSettings . h " # include " dialogs / GUIDialogFileBrowser . h " # include " guilib / GUIComponent . h " # include " guilib / GUIWindowManager . h " # include " guilib / LocalizeStrings . h " # include " messaging / helpers / DialogHelper . h " # include " messaging / helpers / DialogOKHelper . h " # include " ServiceBroker . h " # include " settings / SettingUtils . h " # include " settings / lib / Setting . h " # include " settings / Settings . h " # include " settings / windows / GUIControlSettings . h " # include " storage / MediaManager . h " # include " Util . h " # include " utils / log . h " # include " utils / URIUtils . h " # include " filesystem / Directory . h " using namespace ADDON ; using namespace KODI :: MESSAGING ; using KODI :: MESSAGING :: HELPERS :: DialogResponse ; CGUIDialogLibExportSettings :: CGUIDialogLibExportSettings ( ) : CGUIDialogSettingsManualBase ( WINDOW_DIALOG_LIBEXPORT_SETTINGS , " DialogSettings . xml " ) , m_destinationChecked ( false ) { } bool CGUIDialogLibExportSettings :: Show ( CLibExportSettings & settings ) { CGUIDialogLibExportSettings * dialog = CServiceBroker :: GetGUI ( ) -> GetWindowManager ( ) . GetWindow < CGUIDialogLibExportSettings > ( WINDOW_DIALOG_LIBEXPORT_SETTINGS ) ; if ( ! dialog ) return false ; dialog -> m_settings . SetExportType ( CServiceBroker :: GetSettings ( ) . GetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) ) ; dialog -> m_settings . m_strPath = CServiceBroker :: GetSettings ( ) . GetString ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; dialog -> m_settings . SetItemsToExport ( CServiceBroker :: GetSettings ( ) . GetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS ) ) ; dialog -> m_settings . m_unscraped = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED ) ; dialog -> m_settings . m_artwork = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK ) ; dialog -> m_settings . m_skipnfo = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO ) ; dialog -> m_settings . m_overwrite = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE ) ; dialog -> m_destinationChecked = false ; dialog -> Open ( ) ; bool confirmed = dialog -> IsConfirmed ( ) ; if ( confirmed ) { settings = dialog -> m_settings ; } return confirmed ; } void CGUIDialogLibExportSettings :: OnInitWindow ( ) { CGUIDialogSettingsManualBase :: OnInitWindow ( ) ; } void CGUIDialogLibExportSettings :: OnSettingChanged ( std :: shared_ptr < const CSetting > setting ) { if ( ! setting ) return ; CGUIDialogSettingsManualBase :: OnSettingChanged ( setting ) ; const std :: string & settingId = setting -> GetId ( ) ; if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) { m_settings . SetExportType ( std :: static_pointer_cast < const CSettingInt > ( setting ) -> GetValue ( ) ) ; SetupView ( ) ; SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) { m_settings . m_strPath = std :: static_pointer_cast < const CSettingString > ( setting ) -> GetValue ( ) ; UpdateButtons ( ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE ) m_settings . m_overwrite = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS ) m_settings . SetItemsToExport ( GetExportItemsFromSetting ( setting ) ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK ) { m_settings . m_artwork = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED ) m_settings . m_unscraped = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO ) m_settings . m_skipnfo = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; } void CGUIDialogLibExportSettings :: OnSettingAction ( std :: shared_ptr < const CSetting > setting ) { if ( setting == NULL ) return ; CGUIDialogSettingsManualBase :: OnSettingAction ( setting ) ; const std :: string & settingId = setting -> GetId ( ) ; if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) { VECSOURCES shares ; g_mediaManager . GetLocalDrives ( shares ) ; g_mediaManager . GetNetworkLocations ( shares ) ; g_mediaManager . GetRemovableDrives ( shares ) ; std :: string strDirectory = m_settings . m_strPath ; if ( ! strDirectory . empty ( ) ) { URIUtils :: AddSlashAtEnd ( strDirectory ) ; bool bIsSource ; if ( CUtil :: GetMatchingSource ( strDirectory , shares , bIsSource ) < 0 ) { CMediaSource share ; share . strName = g_localizeStrings . Get ( 13278 ) ; share . strPath = strDirectory ; shares . push_back ( share ) ; } } else strDirectory = " default ▁ location " ; if ( CGUIDialogFileBrowser :: ShowAndGetDirectory ( shares , g_localizeStrings . Get ( 661 ) , strDirectory , true ) ) { if ( ! strDirectory . empty ( ) ) { m_destinationChecked = true ; m_settings . m_strPath = strDirectory ; SetLabel2 ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , strDirectory ) ; SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; } } UpdateButtons ( ) ; } } bool CGUIDialogLibExportSettings :: OnMessage ( CGUIMessage & message ) { switch ( message . GetMessage ( ) ) { case GUI_MSG_CLICKED : { int iControl = message . GetSenderId ( ) ; if ( iControl == CONTROL_SETTINGS_OKAY_BUTTON ) { OnOK ( ) ; return true ; } } break ; } return CGUIDialogSettingsManualBase :: OnMessage ( message ) ; } void CGUIDialogLibExportSettings :: OnOK ( ) { if ( m_settings . IsToLibFolders ( ) ) { std :: string path = CServiceBroker :: GetSettings ( ) . GetString ( CSettings :: SETTING_MUSICLIBRARY_ARTISTSFOLDER ) ; if ( path . empty ( ) ) { if ( HELPERS :: ShowYesNoDialogText ( 20223 , 38317 , 186 , 10004 ) == DialogResponse :: YES ) { m_confirmed = false ; Close ( ) ; CServiceBroker :: GetGUI ( ) -> GetWindowManager ( ) . ActivateWindow ( WINDOW_SETTINGS_MEDIA , CSettings :: SETTING_MUSICLIBRARY_ARTISTSFOLDER ) ; } return ; } } else if ( ! m_destinationChecked ) { if ( ! XFILE :: CDirectory :: Exists ( m_settings . m_strPath ) ) { HELPERS :: ShowOKDialogText ( CVariant { 38300 } , CVariant { 38318 } ) ; return ; } } m_confirmed = true ; Save ( ) ; Close ( ) ; } void CGUIDialogLibExportSettings :: Save ( ) { CLog :: Log ( LOGINFO , " CGUIDialogMusicExportSettings : ▁ Save ( ) ▁ called " ) ; CServiceBroker :: GetSettings ( ) . SetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE , m_settings . GetExportType ( ) ) ; CServiceBroker :: GetSettings ( ) . SetString ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , m_settings . m_strPath ) ; CServiceBroker :: GetSettings ( ) . SetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS , m_settings . GetItemsToExport ( ) ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED , m_settings . m_unscraped ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , m_settings . m_overwrite ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , m_settings . m_artwork ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_skipnfo ) ; CServiceBroker :: GetSettings ( ) . Save ( ) ; } void CGUIDialogLibExportSettings :: SetupView ( ) { CGUIDialogSettingsManualBase :: SetupView ( ) ; SetHeading ( 38300 ) ; SET_CONTROL_HIDDEN ( CONTROL_SETTINGS_CUSTOM_BUTTON ) ; SET_CONTROL_LABEL ( CONTROL_SETTINGS_OKAY_BUTTON , 38319 ) ; SET_CONTROL_LABEL ( CONTROL_SETTINGS_CANCEL_BUTTON , 222 ) ; SetLabel2 ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , m_settings . m_strPath ) ; if ( m_settings . IsSingleFile ( ) ) { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , false ) ; } else if ( m_settings . IsSeparateFiles ( ) ) { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } else { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } UpdateButtons ( ) ; } void CGUIDialogLibExportSettings :: UpdateButtons ( ) { bool enableExport ( true ) ; if ( m_settings . IsSingleFile ( ) || m_settings . IsSeparateFiles ( ) ) enableExport = ! m_settings . m_strPath . empty ( ) ; CONTROL_ENABLE_ON_CONDITION ( CONTROL_SETTINGS_OKAY_BUTTON , enableExport ) ; if ( ! enableExport ) SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; } void CGUIDialogLibExportSettings :: InitializeSettings ( ) { CGUIDialogSettingsManualBase :: InitializeSettings ( ) ; std :: shared_ptr < CSettingCategory > category = AddCategory ( " exportsettings " , - 1 ) ; if ( ! category ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : ▁ unable ▁ to ▁ setup ▁ settings " ) ; return ; } std :: shared_ptr < CSettingGroup > groupDetails = AddGroup ( category ) ; if ( ! groupDetails ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : ▁ unable ▁ to ▁ setup ▁ settings " ) ; return ; } TranslatableIntegerSettingOptions entries ; entries . push_back ( std :: make_pair ( 38301 , ELIBEXPORT_SINGLEFILE ) ) ; entries . push_back ( std :: make_pair ( 38302 , ELIBEXPORT_SEPARATEFILES ) ) ; entries . push_back ( std :: make_pair ( 38303 , ELIBEXPORT_TOLIBRARYFOLDER ) ) ; AddList ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE , 38304 , SettingLevel :: Basic , m_settings . GetExportType ( ) , entries , 38304 ) ; AddButton ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , 38305 , SettingLevel :: Basic ) ; entries . clear ( ) ; entries . push_back ( std :: make_pair ( 132 , ELIBEXPORT_ALBUMS ) ) ; entries . push_back ( std :: make_pair ( 38043 , ELIBEXPORT_ALBUMARTISTS ) ) ; entries . push_back ( std :: make_pair ( 38312 , ELIBEXPORT_SONGARTISTS ) ) ; entries . push_back ( std :: make_pair ( 38313 , ELIBEXPORT_OTHERARTISTS ) ) ; AddList ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS , 38306 , SettingLevel :: Basic , m_settings . GetExportItems ( ) , entries , 133 , 1 ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED , 38308 , SettingLevel :: Basic , m_settings . m_unscraped ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , 38307 , SettingLevel :: Basic , m_settings . m_artwork ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , 38309 , SettingLevel :: Basic , m_settings . m_skipnfo ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , 38310 , SettingLevel :: Basic , m_settings . m_overwrite ) ; } void CGUIDialogLibExportSettings :: SetLabel2 ( const std :: string & settingid , const std :: string & label ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) SET_CONTROL_LABEL2 ( settingControl -> GetID ( ) , label ) ; } void CGUIDialogLibExportSettings :: ToggleState ( const std :: string & settingid , bool enabled ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) { if ( enabled ) CONTROL_ENABLE ( settingControl -> GetID ( ) ) ; else CONTROL_DISABLE ( settingControl -> GetID ( ) ) ; } } void CGUIDialogLibExportSettings :: SetFocus ( const std :: string & settingid ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) SET_CONTROL_FOCUS ( settingControl -> GetID ( ) , 0 ) ; } int CGUIDialogLibExportSettings :: GetExportItemsFromSetting ( SettingConstPtr setting ) { std :: shared_ptr < const CSettingList > settingList = std :: static_pointer_cast < const CSettingList > ( setting ) ; if ( settingList -> GetElementType ( ) != SettingType :: Integer ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : : % s ▁ - ▁ wrong ▁ items ▁ element ▁ type " , __FUNCTION__ ) ; return 0 ; } int exportitems = 0 ; std :: vector < CVariant > list = CSettingUtils :: GetList ( settingList ) ; for ( const auto & value : list ) { if ( ! value . isInteger ( ) ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : : % s ▁ - ▁ wrong ▁ items ▁ value ▁ type " , __FUNCTION__ ) ; return 0 ; } exportitems += value . asInteger ( ) ; } return exportitems ; } </DOCUMENT>
<DOCUMENT_ID="punker76/Windows-universal-samples/tree/master/Samples/XamlCloudFontIntegration/cpp/Scenario_Document1.xaml.cpp"> # include " pch . h " # include " Scenario _ Document1 . xaml . h " using namespace SDKTemplate ; using namespace Platform ; using namespace Windows :: Foundation ; using namespace Windows :: Foundation :: Collections ; using namespace Windows :: UI :: Xaml ; using namespace Windows :: UI :: Xaml :: Controls ; using namespace Windows :: UI :: Xaml :: Controls :: Primitives ; using namespace Windows :: UI :: Xaml :: Data ; using namespace Windows :: UI :: Xaml :: Input ; using namespace Windows :: UI :: Xaml :: Media ; using namespace Windows :: UI :: Xaml :: Navigation ; Scenario_Document1 :: Scenario_Document1 ( ) { InitializeComponent ( ) ; } void Scenario_Document1 :: Page_Loaded ( Platform :: Object ^ sender , Windows :: UI :: Xaml :: RoutedEventArgs ^ e ) { this -> FontFamily = ref new Windows :: UI :: Xaml :: Media :: FontFamily ( " Neue ▁ Haas ▁ Grotesk ▁ Text ▁ Pro " ) ; } </DOCUMENT>
<DOCUMENT_ID="victorzhao/miniblink49/tree/master/third_party/WebKit/Source/core/html/HTMLContentElement.cpp"> # include " config . h " # include " core / html / HTMLContentElement . h " # include " core / HTMLNames . h " # include " core / css / SelectorChecker . h " # include " core / css / parser / CSSParser . h " # include " core / dom / QualifiedName . h " # include " core / dom / shadow / ElementShadow . h " # include " core / dom / shadow / ShadowRoot . h " # include " platform / RuntimeEnabledFeatures . h " namespace blink { using namespace HTMLNames ; PassRefPtrWillBeRawPtr < HTMLContentElement > HTMLContentElement :: create ( Document & document , PassOwnPtrWillBeRawPtr < HTMLContentSelectFilter > filter ) { return adoptRefWillBeNoop ( new HTMLContentElement ( document , filter ) ) ; } inline HTMLContentElement :: HTMLContentElement ( Document & document , PassOwnPtrWillBeRawPtr < HTMLContentSelectFilter > filter ) : InsertionPoint ( contentTag , document ) , m_shouldParseSelect ( false ) , m_isValidSelector ( true ) , m_filter ( filter ) { } HTMLContentElement :: ~ HTMLContentElement ( ) { } DEFINE_TRACE ( HTMLContentElement ) { visitor -> trace ( m_filter ) ; InsertionPoint :: trace ( visitor ) ; } void HTMLContentElement :: parseSelect ( ) { ASSERT ( m_shouldParseSelect ) ; CSSParser :: parseSelector ( CSSParserContext ( document ( ) , 0 ) , m_select , m_selectorList ) ; m_shouldParseSelect = false ; m_isValidSelector = validateSelect ( ) ; if ( ! m_isValidSelector ) { CSSSelectorList emptyList ; m_selectorList . adopt ( emptyList ) ; } } void HTMLContentElement :: parseAttribute ( const QualifiedName & name , const AtomicString & value ) { if ( name == selectAttr ) { if ( ShadowRoot * root = containingShadowRoot ( ) ) root -> owner ( ) -> willAffectSelector ( ) ; m_shouldParseSelect = true ; m_select = value ; } else { InsertionPoint :: parseAttribute ( name , value ) ; } } static inline bool includesDisallowedPseudoClass ( const CSSSelector & selector ) { if ( selector . pseudoType ( ) == CSSSelector :: PseudoNot ) { const CSSSelector * subSelector = selector . selectorList ( ) -> first ( ) ; return subSelector -> match ( ) == CSSSelector :: PseudoClass ; } return selector . match ( ) == CSSSelector :: PseudoClass ; } bool HTMLContentElement :: validateSelect ( ) const { ASSERT ( ! m_shouldParseSelect ) ; if ( m_select . isNull ( ) || m_select . isEmpty ( ) ) return true ; if ( ! m_selectorList . isValid ( ) ) return false ; for ( const CSSSelector * selector = m_selectorList . first ( ) ; selector ; selector = m_selectorList . next ( * selector ) ) { if ( ! selector -> isCompound ( ) ) return false ; for ( const CSSSelector * subSelector = selector ; subSelector ; subSelector = subSelector -> tagHistory ( ) ) { if ( includesDisallowedPseudoClass ( * subSelector ) ) return false ; } } return true ; } bool HTMLContentElement :: matchSelector ( Element & element ) const { SelectorChecker selectorChecker ( SelectorChecker :: QueryingRules ) ; SelectorChecker :: SelectorCheckingContext context ( & element , SelectorChecker :: VisitedMatchDisabled ) ; for ( const CSSSelector * selector = selectorList ( ) . first ( ) ; selector ; selector = CSSSelectorList :: next ( * selector ) ) { context . selector = selector ; if ( selectorChecker . match ( context ) ) return true ; } return false ; } } </DOCUMENT>
<DOCUMENT_ID="thivod/forgottenserver/tree/master/src/trashholder.cpp"> # include " otpch . h " # include " trashholder . h " # include " game . h " extern Game g_game ; TrashHolder :: TrashHolder ( uint16_t _type ) : Item ( _type ) { } TrashHolder :: ~ TrashHolder ( ) { } ReturnValue TrashHolder :: __queryAdd ( int32_t , const Thing * , uint32_t , uint32_t , Creature * ) const { return RET_NOERROR ; } ReturnValue TrashHolder :: __queryMaxCount ( int32_t , const Thing * , uint32_t count , uint32_t & maxQueryCount , uint32_t ) const { maxQueryCount = std :: max < uint32_t > ( 1 , count ) ; return RET_NOERROR ; } ReturnValue TrashHolder :: __queryRemove ( const Thing * , uint32_t , uint32_t ) const { return RET_NOTPOSSIBLE ; } Cylinder * TrashHolder :: __queryDestination ( int32_t & , const Thing * , Item * * , uint32_t & ) { return this ; } void TrashHolder :: __addThing ( Thing * thing ) { return __addThing ( 0 , thing ) ; } void TrashHolder :: __addThing ( int32_t , Thing * thing ) { Item * item = thing -> getItem ( ) ; if ( ! item ) { return ; } if ( item == this || ! item -> hasProperty ( CONST_PROP_MOVEABLE ) ) { return ; } if ( item -> isHangable ( ) && isGroundTile ( ) ) { Tile * tile = dynamic_cast < Tile * > ( getParent ( ) ) ; if ( tile && tile -> hasFlag ( TILESTATE_SUPPORTS_HANGABLE ) ) { return ; } } g_game . internalRemoveItem ( item ) ; const ItemType & it = Item :: items [ getID ( ) ] ; if ( it . magicEffect != CONST_ME_NONE ) { g_game . addMagicEffect ( getPosition ( ) , it . magicEffect ) ; } } void TrashHolder :: __updateThing ( Thing * , uint16_t , uint32_t ) { } void TrashHolder :: __replaceThing ( uint32_t , Thing * ) { } void TrashHolder :: __removeThing ( Thing * , uint32_t ) { } void TrashHolder :: postAddNotification ( Thing * thing , const Cylinder * oldParent , int32_t index , cylinderlink_t ) { getParent ( ) -> postAddNotification ( thing , oldParent , index , LINK_PARENT ) ; } void TrashHolder :: postRemoveNotification ( Thing * thing , const Cylinder * newParent , int32_t index , bool isCompleteRemoval , cylinderlink_t ) { getParent ( ) -> postRemoveNotification ( thing , newParent , index , isCompleteRemoval , LINK_PARENT ) ; } </DOCUMENT>
<DOCUMENT_ID="shliujing/TeamTalk/tree/master/server/src/db_proxy_server/business/UserAction.cpp"> # include < list > # include < map > # include " . . / ProxyConn . h " # include " . . / DBPool . h " # include " . . / SyncCenter . h " # include " public _ define . h " # include " UserModel . h " # include " IM . Login . pb . h " # include " IM . Buddy . pb . h " # include " IM . BaseDefine . pb . h " namespace DB_PROXY { void getUserInfo ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMUsersInfoReq msg ; IM :: Buddy :: IMUsersInfoRsp msgResp ; if ( msg . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { CImPdu * pPduRes = new CImPdu ; uint32_t from_user_id = msg . user_id ( ) ; uint32_t userCount = msg . user_id_list_size ( ) ; std :: list < uint32_t > idList ; for ( uint32_t i = 0 ; i < userCount ; ++ i ) { idList . push_back ( msg . user_id_list ( i ) ) ; } std :: list < IM :: BaseDefine :: UserInfo > lsUser ; CUserModel :: getInstance ( ) -> getUsers ( idList , lsUser ) ; msgResp . set_user_id ( from_user_id ) ; for ( list < IM :: BaseDefine :: UserInfo > :: iterator it = lsUser . begin ( ) ; it != lsUser . end ( ) ; ++ it ) { IM :: BaseDefine :: UserInfo * pUser = msgResp . add_user_info_list ( ) ; pUser -> set_user_id ( it -> user_id ( ) ) ; pUser -> set_user_gender ( it -> user_gender ( ) ) ; pUser -> set_user_nick_name ( it -> user_nick_name ( ) ) ; pUser -> set_avatar_url ( it -> avatar_url ( ) ) ; pUser -> set_sign_info ( it -> sign_info ( ) ) ; pUser -> set_department_id ( it -> department_id ( ) ) ; pUser -> set_email ( it -> email ( ) ) ; pUser -> set_user_real_name ( it -> user_real_name ( ) ) ; pUser -> set_user_tel ( it -> user_tel ( ) ) ; pUser -> set_user_domain ( it -> user_domain ( ) ) ; pUser -> set_status ( it -> status ( ) ) ; } log ( " userId = % u , ▁ userCnt = % u " , from_user_id , userCount ) ; msgResp . set_attach_data ( msg . attach_data ( ) ) ; pPduRes -> SetPBMsg ( & msgResp ) ; pPduRes -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pPduRes -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pPduRes -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_USER_INFO_RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pPduRes ) ; } else { log ( " parse ▁ pb ▁ failed " ) ; } } void getChangedUser ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMAllUserReq msg ; IM :: Buddy :: IMAllUserRsp msgResp ; if ( msg . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { CImPdu * pPduRes = new CImPdu ; uint32_t nReqId = msg . user_id ( ) ; uint32_t nLastTime = msg . latest_update_time ( ) ; uint32_t nLastUpdate = CSyncCenter :: getInstance ( ) -> getLastUpdate ( ) ; list < IM :: BaseDefine :: UserInfo > lsUsers ; if ( nLastUpdate > nLastTime ) { list < uint32_t > lsIds ; CUserModel :: getInstance ( ) -> getChangedId ( nLastTime , lsIds ) ; CUserModel :: getInstance ( ) -> getUsers ( lsIds , lsUsers ) ; } msgResp . set_user_id ( nReqId ) ; msgResp . set_latest_update_time ( nLastTime ) ; for ( list < IM :: BaseDefine :: UserInfo > :: iterator it = lsUsers . begin ( ) ; it != lsUsers . end ( ) ; ++ it ) { IM :: BaseDefine :: UserInfo * pUser = msgResp . add_user_list ( ) ; pUser -> set_user_id ( it -> user_id ( ) ) ; pUser -> set_user_gender ( it -> user_gender ( ) ) ; pUser -> set_user_nick_name ( it -> user_nick_name ( ) ) ; pUser -> set_avatar_url ( it -> avatar_url ( ) ) ; pUser -> set_sign_info ( it -> sign_info ( ) ) ; pUser -> set_department_id ( it -> department_id ( ) ) ; pUser -> set_email ( it -> email ( ) ) ; pUser -> set_user_real_name ( it -> user_real_name ( ) ) ; pUser -> set_user_tel ( it -> user_tel ( ) ) ; pUser -> set_user_domain ( it -> user_domain ( ) ) ; pUser -> set_status ( it -> status ( ) ) ; } log ( " userId = % u , nLastUpdate = % u , ▁ last _ time = % u , ▁ userCnt = % u " , nReqId , nLastUpdate , nLastTime , msgResp . user_list_size ( ) ) ; msgResp . set_attach_data ( msg . attach_data ( ) ) ; pPduRes -> SetPBMsg ( & msgResp ) ; pPduRes -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pPduRes -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pPduRes -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_ALL_USER_RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pPduRes ) ; } else { log ( " parse ▁ pb ▁ failed " ) ; } } void changeUserSignInfo ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMChangeSignInfoReq req ; IM :: Buddy :: IMChangeSignInfoRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; const string & sign_info = req . sign_info ( ) ; bool result = CUserModel :: getInstance ( ) -> updateUserSignInfo ( user_id , sign_info ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_sign_info ( sign_info ) ; log ( " changeUserSignInfo ▁ sucess , ▁ user _ id = % u , ▁ sign _ info = % s " , user_id , sign_info . c_str ( ) ) ; } else { log ( " changeUserSignInfo ▁ false , ▁ user _ id = % u , ▁ sign _ info = % s " , user_id , sign_info . c_str ( ) ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " changeUserSignInfo : ▁ IMChangeSignInfoReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } } void doPushShield ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Login :: IMPushShieldReq req ; IM :: Login :: IMPushShieldRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; uint32_t shield_status = req . shield_status ( ) ; bool result = CUserModel :: getInstance ( ) -> updatePushShield ( user_id , shield_status ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_shield_status ( shield_status ) ; log ( " doPushShield ▁ sucess , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } else { log ( " doPushShield ▁ false , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_LOGIN ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_LOGIN_RES_PUSH_SHIELD ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " doPushShield : ▁ IMPushShieldReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } } void doQueryPushShield ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Login :: IMQueryPushShieldReq req ; IM :: Login :: IMQueryPushShieldRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; uint32_t shield_status = 0 ; bool result = CUserModel :: getInstance ( ) -> getPushShield ( user_id , & shield_status ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_shield_status ( shield_status ) ; log ( " doQueryPushShield ▁ sucess , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } else { log ( " doQueryPushShield ▁ false , ▁ user _ id = % u " , user_id ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_LOGIN ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_LOGIN_RES_QUERY_PUSH_SHIELD ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " doQueryPushShield : ▁ IMQueryPushShieldReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } } } ; </DOCUMENT>
<DOCUMENT_ID="PGer/incubator-hawq/tree/master/src/backend/access/parquet/metadatautil_c++/Metadatainterface.cpp"> # include < iostream > # include < stdint . h > # include < boost / shared_ptr . hpp > # include < boost / math_fwd . hpp > # include < thrift / protocol / TBinaryProtocol . h > # include < fcntl . h > # include < fstream > # include < stdio . h > # include < bitset > # include " MetadataUtil . h " using namespace hawq ; using namespace std ; using namespace boost ; extern " C " { # include " postgres . h " # include " utils / palloc . h " int readPageMetadata ( uint8_t * buf , uint32_t * len , int compact , struct PageMetadata_4C * * ppageMetdata ) { * ppageMetdata = ( struct PageMetadata_4C * ) palloc0 ( sizeof ( struct PageMetadata_4C ) ) ; bool compactBool = ( compact == 1 ) ? true : false ; int iret = MetadataUtil :: readPageMetadata ( buf , len , compactBool , * ppageMetdata ) ; return iret ; } int writePageMetadata ( uint8_t * * buf , uint32_t * len , struct PageMetadata_4C * ppageMetadata ) { int iret = MetadataUtil :: writePageMetadata ( buf , len , ppageMetadata ) ; return iret ; } int writeColumnChunkMetadata ( uint8_t * * buf , uint32_t * len , struct ColumnChunkMetadata_4C * blockMetadata ) { int iret = MetadataUtil :: writeColumnChunkMetadata ( buf , len , blockMetadata ) ; return iret ; } } </DOCUMENT>
<DOCUMENT_ID="tectronics/mysql-parallel-replication/tree/master/extra/yassl/taocrypt/src/hash.cpp"> # include " runtime . hpp " # include < string . h > # include < assert . h > # include " hash . hpp " namespace TaoCrypt { HASHwithTransform :: HASHwithTransform ( word32 digSz , word32 buffSz ) { assert ( digSz <= MaxDigestSz ) ; assert ( buffSz <= MaxBufferSz ) ; } void HASHwithTransform :: AddLength ( word32 len ) { HashLengthType tmp = loLen_ ; if ( ( loLen_ += len ) < tmp ) hiLen_ ++ ; hiLen_ += SafeRightShift < 8 * sizeof ( HashLengthType ) > ( len ) ; } void HASHwithTransform :: Update ( const byte * data , word32 len ) { word32 blockSz = getBlockSize ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; while ( len ) { word32 add = min ( len , blockSz - buffLen_ ) ; memcpy ( & local [ buffLen_ ] , data , add ) ; buffLen_ += add ; data += add ; len -= add ; if ( buffLen_ == blockSz ) { ByteReverseIf ( local , local , blockSz , getByteOrder ( ) ) ; Transform ( ) ; AddLength ( blockSz ) ; buffLen_ = 0 ; } } } void HASHwithTransform :: Final ( byte * hash ) { word32 blockSz = getBlockSize ( ) ; word32 digestSz = getDigestSize ( ) ; word32 padSz = getPadSize ( ) ; ByteOrder order = getByteOrder ( ) ; AddLength ( buffLen_ ) ; HashLengthType preLoLen = GetBitCountLo ( ) ; HashLengthType preHiLen = GetBitCountHi ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; local [ buffLen_ ++ ] = 0x80 ; if ( buffLen_ > padSz ) { memset ( & local [ buffLen_ ] , 0 , blockSz - buffLen_ ) ; buffLen_ += blockSz - buffLen_ ; ByteReverseIf ( local , local , blockSz , order ) ; Transform ( ) ; buffLen_ = 0 ; } memset ( & local [ buffLen_ ] , 0 , padSz - buffLen_ ) ; ByteReverseIf ( local , local , blockSz , order ) ; memcpy ( & local [ padSz ] , order ? & preHiLen : & preLoLen , sizeof ( preLoLen ) ) ; memcpy ( & local [ padSz + 4 ] , order ? & preLoLen : & preHiLen , sizeof ( preLoLen ) ) ; Transform ( ) ; ByteReverseIf ( digest_ , digest_ , digestSz , order ) ; memcpy ( hash , digest_ , digestSz ) ; Init ( ) ; } # ifdef WORD64_AVAILABLE HASH64withTransform :: HASH64withTransform ( word32 digSz , word32 buffSz ) { assert ( digSz <= MaxDigestSz ) ; assert ( buffSz <= MaxBufferSz ) ; } void HASH64withTransform :: AddLength ( word32 len ) { HashLengthType tmp = loLen_ ; if ( ( loLen_ += len ) < tmp ) hiLen_ ++ ; hiLen_ += SafeRightShift < 8 * sizeof ( HashLengthType ) > ( len ) ; } void HASH64withTransform :: Update ( const byte * data , word32 len ) { word32 blockSz = getBlockSize ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; while ( len ) { word32 add = min ( len , blockSz - buffLen_ ) ; memcpy ( & local [ buffLen_ ] , data , add ) ; buffLen_ += add ; data += add ; len -= add ; if ( buffLen_ == blockSz ) { ByteReverseIf ( buffer_ , buffer_ , blockSz , getByteOrder ( ) ) ; Transform ( ) ; AddLength ( blockSz ) ; buffLen_ = 0 ; } } } void HASH64withTransform :: Final ( byte * hash ) { word32 blockSz = getBlockSize ( ) ; word32 digestSz = getDigestSize ( ) ; word32 padSz = getPadSize ( ) ; ByteOrder order = getByteOrder ( ) ; AddLength ( buffLen_ ) ; HashLengthType preLoLen = GetBitCountLo ( ) ; HashLengthType preHiLen = GetBitCountHi ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; local [ buffLen_ ++ ] = 0x80 ; if ( buffLen_ > padSz ) { memset ( & local [ buffLen_ ] , 0 , blockSz - buffLen_ ) ; buffLen_ += blockSz - buffLen_ ; ByteReverseIf ( buffer_ , buffer_ , blockSz , order ) ; Transform ( ) ; buffLen_ = 0 ; } memset ( & local [ buffLen_ ] , 0 , padSz - buffLen_ ) ; ByteReverseIf ( buffer_ , buffer_ , padSz , order ) ; buffer_ [ blockSz / sizeof ( word64 ) - 2 ] = order ? preHiLen : preLoLen ; buffer_ [ blockSz / sizeof ( word64 ) - 1 ] = order ? preLoLen : preHiLen ; Transform ( ) ; ByteReverseIf ( digest_ , digest_ , digestSz , order ) ; memcpy ( hash , digest_ , digestSz ) ; Init ( ) ; } # endif } </DOCUMENT>
<DOCUMENT_ID="braska/tdesktop/tree/master/Telegram/SourceFiles/gui/twidget.cpp"> # include " stdafx . h " # include " application . h " namespace { void _sendResizeEvents ( QWidget * target ) { QResizeEvent e ( target -> size ( ) , QSize ( ) ) ; QApplication :: sendEvent ( target , & e ) ; const QObjectList children = target -> children ( ) ; for ( int i = 0 ; i < children . size ( ) ; ++ i ) { QWidget * child = static_cast < QWidget * > ( children . at ( i ) ) ; if ( child -> isWidgetType ( ) && ! child -> isWindow ( ) && child -> testAttribute ( Qt :: WA_PendingResizeEvent ) ) { _sendResizeEvents ( child ) ; } } } } void myEnsureResized ( QWidget * target ) { if ( target && ( target -> testAttribute ( Qt :: WA_PendingResizeEvent ) || ! target -> testAttribute ( Qt :: WA_WState_Created ) ) ) { _sendResizeEvents ( target ) ; } } QPixmap myGrab ( QWidget * target , const QRect & rect ) { if ( ! cRetina ( ) ) return target -> grab ( rect ) ; myEnsureResized ( target ) ; qreal dpr = App :: app ( ) -> devicePixelRatio ( ) ; QPixmap result ( rect . size ( ) * dpr ) ; result . setDevicePixelRatio ( dpr ) ; result . fill ( Qt :: transparent ) ; target -> render ( & result , QPoint ( ) , QRegion ( rect ) , QWidget :: DrawWindowBackground | QWidget :: DrawChildren | QWidget :: IgnoreMask ) ; return result ; } </DOCUMENT>
<DOCUMENT_ID="zeliard/aws-sdk-cpp/tree/master/aws-cpp-sdk-iam/source/model/ListGroupsRequest.cpp"> # include < aws / iam / model / ListGroupsRequest . h > # include < aws / core / utils / StringUtils . h > # include < aws / core / utils / memory / stl / AWSStringStream . h > using namespace Aws :: IAM :: Model ; using namespace Aws :: Utils ; ListGroupsRequest :: ListGroupsRequest ( ) : m_pathPrefixHasBeenSet ( false ) , m_markerHasBeenSet ( false ) , m_maxItems ( 0 ) , m_maxItemsHasBeenSet ( false ) { } Aws :: String ListGroupsRequest :: SerializePayload ( ) const { Aws :: StringStream ss ; ss << " Action = ListGroups & " ; if ( m_pathPrefixHasBeenSet ) { ss << " PathPrefix = " << StringUtils :: URLEncode ( m_pathPrefix . c_str ( ) ) << " & " ; } if ( m_markerHasBeenSet ) { ss << " Marker = " << StringUtils :: URLEncode ( m_marker . c_str ( ) ) << " & " ; } if ( m_maxItemsHasBeenSet ) { ss << " MaxItems = " << m_maxItems << " & " ; } ss << " Version = 2010-05-08" ; return ss . str ( ) ; } </DOCUMENT>
<DOCUMENT_ID="EdisonCodeKeeper/hacker-rank/tree/master/practice/mathematics/geometry/meeting-point/meeting-point.cpp"> # include < iostream > # include < vector > # include < algorithm > using namespace std ; # define M 100 bool pair_compare ( const pair < int , long long > & a , const pair < int , long long > & b ) { return a . second == b . second ? a . first < b . first : a . second < b . second ; } int main ( ) { int N ; cin >> N ; vector < pair < long long , long long > > pos ; long long avg_x = 0 , avg_y = 0 ; for ( int i = 0 ; i < N ; ++ i ) { int x , y ; cin >> x >> y ; pos . push_back ( make_pair ( x , y ) ) ; avg_x += x ; avg_y += y ; } avg_x /= N , avg_y /= N ; vector < pair < int , long long > > ans ; for ( int i = 0 ; i < N ; ++ i ) { long long dis = max ( abs ( pos [ i ] . first - avg_x ) , abs ( pos [ i ] . second - avg_y ) ) ; ans . push_back ( make_pair ( i , dis ) ) ; } sort ( ans . begin ( ) , ans . end ( ) , pair_compare ) ; long long ret = 1e16 ; for ( int i = 0 ; i < min ( M , int ( ans . size ( ) ) ) ; ++ i ) { long long tmp = 0 ; for ( int j = 0 ; j < N ; ++ j ) tmp += max ( abs ( pos [ j ] . first - pos [ ans [ i ] . first ] . first ) , abs ( pos [ j ] . second - pos [ ans [ i ] . first ] . second ) ) ; ret = min ( ret , tmp ) ; } cout << ret << endl ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="dysonltd/gts/tree/master/app/src/tools/core/components/FloorPlanning.cpp"> # include " RoomsCollection . h " # include " CamerasCollection . h " # include " CameraPositionsCollection . h " # include " CalibrationSchema . h " # include " ExtrinsicCalibrationSchema . h " # include " CameraPositionSchema . h " # include " RoomLayoutSchema . h " # include " FloorPlanSchema . h " # include " CalibrationAlgorithm . h " # include " WbConfigTools . h " # include " WbConfig . h " # include " GroundPlaneUtility . h " # include " OpenCvUtility . h " # include " RobotMetrics . h " # include " CameraCalibration . h " # include " FileUtilities . h " # include " FileDialogs . h " # include " Message . h " # include " Logging . h " # include < QFileDialog > # include < QtGlobal > # include < opencv / cv . h > # include < opencv / highgui . h > # include < iostream > # include < algorithm > namespace FloorPlanning { bool LoadFile ( WbConfig config , KeyId cameraPosition , IplImage * * camImg , QString fileName , CvPoint2D32f * offset , bool unWarp ) { bool successful = true ; Collection camerasCollection ( CamerasCollection ( ) ) ; Collection cameraPositionsCollection ( CameraPositionsCollection ( ) ) ; camerasCollection . SetConfig ( config ) ; cameraPositionsCollection . SetConfig ( config ) ; const KeyId camPosId = cameraPosition ; LOG_INFO ( QObject :: tr ( " Camera ▁ position ▁ id : ▁ % 1" ) . arg ( camPosId ) ) ; const WbConfig camPosConfig = cameraPositionsCollection . ElementById ( camPosId ) ; if ( camPosConfig . IsNull ( ) ) successful = false ; CvMat * cameraMtx = cvCreateMat ( 3 , 3 , CV_32F ) ; CvMat * distortionCoeffs = cvCreateMat ( 5 , 1 , CV_32F ) ; CvMat * inverseCoeffs = cvCreateMat ( 5 , 1 , CV_32F ) ; CvMat * rot = cvCreateMat ( 3 , 3 , CV_32F ) ; CvMat * trans = cvCreateMat ( 1 , 3 , CV_32F ) ; if ( successful ) { const KeyId camId = camPosConfig . GetKeyValue ( CameraPositionSchema :: cameraIdKey ) . ToKeyId ( ) ; LOG_INFO ( QObject :: tr ( " Camera ▁ id : ▁ % 1" ) . arg ( camId ) ) ; WbConfig cameraConfig = camerasCollection . ElementById ( camId ) ; if ( cameraConfig . IsNull ( ) ) successful = false ; if ( successful ) { const WbConfig cameraIntrisicConfig ( cameraConfig . GetSubConfig ( CalibrationSchema :: schemaName ) ) ; if ( cameraIntrisicConfig . IsNull ( ) ) successful = false ; if ( successful ) { const bool calibrationWasSuccessful = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: calibrationSuccessfulKey ) . ToBool ( ) ; const bool cameraMtxValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: cameraMatrixKey ) . ToCvMat ( * cameraMtx ) ; const bool distortionCoeffsValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: distortionCoefficientsKey ) . ToCvMat ( * distortionCoeffs ) ; const bool inverseCoeffsValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: invDistortionCoefficientsKey ) . ToCvMat ( * inverseCoeffs ) ; successful = calibrationWasSuccessful && cameraMtxValid && distortionCoeffsValid && inverseCoeffsValid ; } const WbConfig cameraExtrisicConfig ( camPosConfig . GetSubConfig ( ExtrinsicCalibrationSchema :: schemaName ) ) ; if ( cameraExtrisicConfig . IsNull ( ) ) successful = false ; if ( successful ) { const bool rotMatValid = cameraExtrisicConfig . GetKeyValue ( ExtrinsicCalibrationSchema :: rotationMatrixKey ) . ToCvMat ( * rot ) ; const bool transValid = cameraExtrisicConfig . GetKeyValue ( ExtrinsicCalibrationSchema :: translationKey ) . ToCvMat ( * trans ) ; successful = rotMatValid && transValid ; } } } if ( successful ) { IplImage * imgGrey = cvLoadImage ( fileName . toAscii ( ) , CV_LOAD_IMAGE_GRAYSCALE ) ; if ( unWarp ) { * camImg = GroundPlaneUtility :: unwarpGroundPlane ( imgGrey , cameraMtx , distortionCoeffs , inverseCoeffs , rot , trans , offset ) ; } else { * camImg = cvCloneImage ( imgGrey ) ; } cvReleaseImage ( & imgGrey ) ; } cvReleaseMat ( & cameraMtx ) ; cvReleaseMat ( & distortionCoeffs ) ; cvReleaseMat ( & inverseCoeffs ) ; cvReleaseMat ( & rot ) ; cvReleaseMat ( & trans ) ; return successful ; } bool CheckMappingIsComplete ( WbConfig config ) { bool allMapped = true ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; bool found = false ; LOG_INFO ( QObject :: tr ( " Checking ▁ mapping ▁ for ▁ % 1 . " ) . arg ( camPosId ) ) ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( ( camPosId == camera1Id ) || ( camPosId == camera2Id ) ) { found = true ; break ; } } if ( ! found ) { allMapped = false ; break ; } } return allMapped ; } bool IsBase ( WbConfig config , KeyId camId ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; bool base = false ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camId == camera1Id ) { base = true ; break ; } } return base ; } bool IsRef ( WbConfig config , KeyId camId ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; bool ref = false ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camId == camera2Id ) { ref = true ; break ; } } return ref ; } std :: vector < KeyId > FindRoot ( WbConfig config ) { std :: vector < KeyId > rootCamera ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; bool root = true ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camPosId == camera2Id ) { root = false ; break ; } } if ( root && IsBase ( config , camPosId ) ) { rootCamera . push_back ( camPosId ) ; } } return rootCamera ; } std :: vector < KeyId > FindChain ( WbConfig config , KeyId camId , KeyId rootId , std :: vector < KeyId > mappingChain ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; LOG_INFO ( QObject :: tr ( " Camera1 ▁ id ▁ = ▁ % 1 . " ) . arg ( camera1Id ) ) ; LOG_INFO ( QObject :: tr ( " Camera2 ▁ id ▁ = ▁ % 1 . " ) . arg ( camera2Id ) ) ; if ( camId == camera2Id ) { if ( std :: find ( mappingChain . begin ( ) , mappingChain . end ( ) , camera1Id ) == mappingChain . end ( ) ) { mappingChain . push_back ( camera1Id ) ; if ( camera1Id != rootId ) { LOG_INFO ( QObject :: tr ( " Find ▁ chain ▁ for ▁ % 1 ▁ - ▁ % 2 . " ) . arg ( camera1Id ) . arg ( rootId ) ) ; mappingChain = FindChain ( config , camera1Id , rootId , mappingChain ) ; } if ( mappingChain . back ( ) == rootId ) { LOG_INFO ( " Found . " ) ; break ; } else { mappingChain . pop_back ( ) ; } } } } return mappingChain ; } bool CheckRootMapping ( WbConfig config , KeyId rootId ) { bool allMapped = true ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; if ( ( camPosId != rootId ) && IsRef ( config , camPosId ) ) { LOG_INFO ( QObject :: tr ( " Find ▁ chain ▁ for ▁ % 1 ▁ - ▁ % 2 . " ) . arg ( camPosId ) . arg ( rootId ) ) ; std :: vector < KeyId > chain = FindChain ( config , camPosId , rootId , std :: vector < KeyId > ( ) ) ; if ( chain . size ( ) == 0 ) { LOG_INFO ( " Not ▁ found . " ) ; allMapped = false ; break ; } } } return allMapped ; } void ComputeTransform ( WbConfig config , KeyId refId , std :: vector < KeyId > chain , CvMat * transform ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( std :: vector < KeyId > :: iterator elt = chain . begin ( ) ; elt != chain . end ( ) ; ++ elt ) { for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( ( camera1Id == * elt ) && ( camera2Id == refId ) ) { CvMat * homography = cvCreateMat ( 3 , 3 , CV_32F ) ; const bool homographyValid = config . GetKeyValue ( FloorPlanSchema :: homographyKey , it -> id ) . ToCvMat ( * homography ) ; Q_UNUSED ( homographyValid ) ; CvMat * tmp = cvCreateMat ( 3 , 3 , CV_32F ) ; cvMatMul ( homography , transform , tmp ) ; cvmSet ( transform , 0 , 0 , cvmGet ( tmp , 0 , 0 ) ) ; cvmSet ( transform , 0 , 1 , cvmGet ( tmp , 0 , 1 ) ) ; cvmSet ( transform , 0 , 2 , cvmGet ( tmp , 0 , 2 ) ) ; cvmSet ( transform , 1 , 0 , cvmGet ( tmp , 1 , 0 ) ) ; cvmSet ( transform , 1 , 1 , cvmGet ( tmp , 1 , 1 ) ) ; cvmSet ( transform , 1 , 2 , cvmGet ( tmp , 1 , 2 ) ) ; cvmSet ( transform , 2 , 0 , cvmGet ( tmp , 2 , 0 ) ) ; cvmSet ( transform , 2 , 1 , cvmGet ( tmp , 2 , 1 ) ) ; cvmSet ( transform , 2 , 2 , cvmGet ( tmp , 2 , 2 ) ) ; cvReleaseMat ( & tmp ) ; cvReleaseMat ( & homography ) ; refId = * elt ; } } } } } </DOCUMENT>
<DOCUMENT_ID="hkernbach/arangodb/tree/master/3rdParty/boost/1.62.0/libs/phoenix/test/include/core/visit_each.cpp"> # include < boost / phoenix / core / visit_each . hpp > int main ( ) { } </DOCUMENT>
<DOCUMENT_ID="Voyager1/xbmc/tree/master/xbmc/windowing/rpi/GLContextEGL.cpp"> # include " GLContextEGL . h " # include " guilib / IDirtyRegionSolver . h " # include " settings / AdvancedSettings . h " # include " utils / log . h " CGLContextEGL :: CGLContextEGL ( ) : m_eglDisplay ( EGL_NO_DISPLAY ) , m_eglSurface ( EGL_NO_SURFACE ) , m_eglContext ( EGL_NO_CONTEXT ) , m_eglConfig ( 0 ) { } CGLContextEGL :: ~ CGLContextEGL ( ) { Destroy ( ) ; } bool CGLContextEGL :: CreateDisplay ( EGLDisplay display , EGLint renderable_type , EGLint rendering_api ) { EGLint neglconfigs = 0 ; int major , minor ; EGLint surface_type = EGL_WINDOW_BIT ; if ( g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION || g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION ) surface_type |= EGL_SWAP_BEHAVIOR_PRESERVED_BIT ; EGLint attribs [ ] = { EGL_RED_SIZE , 8 , EGL_GREEN_SIZE , 8 , EGL_BLUE_SIZE , 8 , EGL_ALPHA_SIZE , 8 , EGL_DEPTH_SIZE , 16 , EGL_STENCIL_SIZE , 0 , EGL_SAMPLE_BUFFERS , 0 , EGL_SAMPLES , 0 , EGL_SURFACE_TYPE , surface_type , EGL_RENDERABLE_TYPE , renderable_type , EGL_NONE } ; if ( m_eglDisplay == EGL_NO_DISPLAY ) { m_eglDisplay = eglGetDisplay ( ( EGLNativeDisplayType ) display ) ; } if ( m_eglDisplay == EGL_NO_DISPLAY ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ get ▁ EGL ▁ display " ) ; return false ; } if ( ! eglInitialize ( m_eglDisplay , & major , & minor ) ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ initialize ▁ EGL ▁ display " ) ; return false ; } eglBindAPI ( rendering_api ) ; if ( ! eglChooseConfig ( m_eglDisplay , attribs , & m_eglConfig , 1 , & neglconfigs ) ) { CLog :: Log ( LOGERROR , " Failed ▁ to ▁ query ▁ number ▁ of ▁ EGL ▁ configs " ) ; return false ; } if ( neglconfigs <= 0 ) { CLog :: Log ( LOGERROR , " No ▁ suitable ▁ EGL ▁ configs ▁ found " ) ; return false ; } return true ; } bool CGLContextEGL :: CreateContext ( ) { int client_version = 2 ; const EGLint context_attribs [ ] = { EGL_CONTEXT_CLIENT_VERSION , client_version , EGL_NONE } ; if ( m_eglContext == EGL_NO_CONTEXT ) { m_eglContext = eglCreateContext ( m_eglDisplay , m_eglConfig , EGL_NO_CONTEXT , context_attribs ) ; } if ( m_eglContext == EGL_NO_CONTEXT ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ create ▁ EGL ▁ context " ) ; return false ; } return true ; } bool CGLContextEGL :: BindContext ( ) { if ( ! eglMakeCurrent ( m_eglDisplay , m_eglSurface , m_eglSurface , m_eglContext ) ) { CLog :: Log ( LOGERROR , " Failed ▁ to ▁ make ▁ context ▁ current ▁ % p ▁ % p ▁ % p " , m_eglDisplay , m_eglSurface , m_eglContext ) ; return false ; } return true ; } bool CGLContextEGL :: SurfaceAttrib ( ) { if ( g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION || g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION ) { if ( ( m_eglDisplay == EGL_NO_DISPLAY ) || ( m_eglSurface == EGL_NO_SURFACE ) ) { return false ; } if ( ! eglSurfaceAttrib ( m_eglDisplay , m_eglSurface , EGL_SWAP_BEHAVIOR , EGL_BUFFER_PRESERVED ) ) { CLog :: Log ( LOGDEBUG , " % s : ▁ Could ▁ not ▁ set ▁ EGL _ SWAP _ BEHAVIOR " , __FUNCTION__ ) ; } } return true ; } bool CGLContextEGL :: CreateSurface ( EGLNativeWindowType surface ) { m_eglSurface = eglCreateWindowSurface ( m_eglDisplay , m_eglConfig , surface , nullptr ) ; if ( m_eglSurface == EGL_NO_SURFACE ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ create ▁ EGL ▁ window ▁ surface ▁ % d " , eglGetError ( ) ) ; return false ; } return true ; } void CGLContextEGL :: Destroy ( ) { if ( m_eglContext != EGL_NO_CONTEXT ) { eglDestroyContext ( m_eglDisplay , m_eglContext ) ; eglMakeCurrent ( m_eglDisplay , EGL_NO_SURFACE , EGL_NO_SURFACE , EGL_NO_CONTEXT ) ; m_eglContext = EGL_NO_CONTEXT ; } if ( m_eglSurface != EGL_NO_SURFACE ) { eglDestroySurface ( m_eglDisplay , m_eglSurface ) ; m_eglSurface = EGL_NO_SURFACE ; } if ( m_eglDisplay != EGL_NO_DISPLAY ) { eglTerminate ( m_eglDisplay ) ; m_eglDisplay = EGL_NO_DISPLAY ; } } void CGLContextEGL :: Detach ( ) { if ( m_eglContext != EGL_NO_CONTEXT ) { eglMakeCurrent ( m_eglDisplay , EGL_NO_SURFACE , EGL_NO_SURFACE , EGL_NO_CONTEXT ) ; } if ( m_eglSurface != EGL_NO_SURFACE ) { eglDestroySurface ( m_eglDisplay , m_eglSurface ) ; m_eglSurface = EGL_NO_SURFACE ; } } bool CGLContextEGL :: SetVSync ( bool enable ) { if ( ! eglSwapInterval ( m_eglDisplay , enable ) ) { return false ; } return true ; } void CGLContextEGL :: SwapBuffers ( ) { if ( m_eglDisplay == EGL_NO_DISPLAY || m_eglSurface == EGL_NO_SURFACE ) { return ; } eglSwapBuffers ( m_eglDisplay , m_eglSurface ) ; } </DOCUMENT>
<DOCUMENT_ID="rlewis1988/lean/tree/master/src/library/tactic/smt/util.cpp"> # include " library / annotation . h " # include " library / util . h " # include " library / replace _ visitor . h " # include " library / vm / vm . h " # include " library / tactic / smt / congruence _ closure . h " namespace lean { static name * g_cc_proof_name = nullptr ; static macro_definition * g_cc_proof_macro = nullptr ; class cc_proof_macro_cell : public macro_definition_cell { public : virtual name get_name ( ) const { return * g_cc_proof_name ; } virtual expr check_type ( expr const & e , abstract_type_context & ctx , bool ) const { return mk_eq ( ctx , macro_arg ( e , 0 ) , macro_arg ( e , 1 ) ) ; } virtual optional < expr > expand ( expr const & , abstract_type_context & ) const { lean_unreachable ( ) ; } virtual void write ( serializer & ) const { lean_unreachable ( ) ; } virtual bool operator == ( macro_definition_cell const & other ) const { cc_proof_macro_cell const * other_ptr = dynamic_cast < cc_proof_macro_cell const * > ( & other ) ; return other_ptr ; } virtual unsigned hash ( ) const { return 23 ; } } ; expr mk_delayed_cc_eq_proof ( expr const & e1 , expr const & e2 ) { expr args [ 2 ] = { e1 , e2 } ; return mk_macro ( * g_cc_proof_macro , 2 , args ) ; } bool is_delayed_cc_eq_proof ( expr const & e ) { return is_macro ( e ) && dynamic_cast < cc_proof_macro_cell const * > ( macro_def ( e ) . raw ( ) ) ; } static name * g_theory_proof = nullptr ; expr mark_cc_theory_proof ( expr const & pr ) { return mk_annotation ( * g_theory_proof , pr ) ; } bool is_cc_theory_proof ( expr const & e ) { return is_annotation ( e , * g_theory_proof ) ; } expr get_cc_theory_proof_arg ( expr const & pr ) { lean_assert ( is_cc_theory_proof ( pr ) ) ; return get_annotation_arg ( pr ) ; } class expand_delayed_cc_proofs_fn : public replace_visitor { congruence_closure const & m_cc ; expr visit_macro ( expr const & e ) { if ( is_delayed_cc_eq_proof ( e ) ) { expr const & lhs = macro_arg ( e , 0 ) ; expr const & rhs = macro_arg ( e , 1 ) ; return * m_cc . get_eq_proof ( lhs , rhs ) ; } else { return replace_visitor :: visit_macro ( e ) ; } } public : expand_delayed_cc_proofs_fn ( congruence_closure const & cc ) : m_cc ( cc ) { } } ; expr expand_delayed_cc_proofs ( congruence_closure const & cc , expr const & e ) { return expand_delayed_cc_proofs_fn ( cc ) ( e ) ; } void initialize_smt_util ( ) { g_cc_proof_name = new name ( " cc _ proof " ) ; g_cc_proof_macro = new macro_definition ( new cc_proof_macro_cell ( ) ) ; g_theory_proof = new name ( " th _ proof " ) ; register_annotation ( * g_theory_proof ) ; } void finalize_smt_util ( ) { delete g_cc_proof_macro ; delete g_cc_proof_name ; delete g_theory_proof ; } } </DOCUMENT>
<DOCUMENT_ID="sunblithe/qt-everywhere-opensource-src-4.7.1/tree/master/src/gui/kernel/qeventdispatcher_x11.cpp"> # include " qeventdispatcher _ x11 _ p . h " # include " qapplication . h " # include " qx11info _ x11 . h " # include " qt _ x11 _ p . h " # include < private / qeventdispatcher_unix_p . h > QT_BEGIN_NAMESPACE class QEventDispatcherX11Private : public QEventDispatcherUNIXPrivate { Q_DECLARE_PUBLIC ( QEventDispatcherX11 ) public : inline QEventDispatcherX11Private ( ) : xfd ( - 1 ) { } int xfd ; QList < XEvent > queuedUserInputEvents ; } ; QEventDispatcherX11 :: QEventDispatcherX11 ( QObject * parent ) : QEventDispatcherUNIX ( * new QEventDispatcherX11Private , parent ) { } QEventDispatcherX11 :: ~ QEventDispatcherX11 ( ) { } bool QEventDispatcherX11 :: processEvents ( QEventLoop :: ProcessEventsFlags flags ) { Q_D ( QEventDispatcherX11 ) ; d -> interrupt = false ; QApplication :: sendPostedEvents ( ) ; ulong marker = XNextRequest ( X11 -> display ) ; int nevents = 0 ; do { while ( ! d -> interrupt ) { XEvent event ; if ( ! ( flags & QEventLoop :: ExcludeUserInputEvents ) && ! d -> queuedUserInputEvents . isEmpty ( ) ) { event = d -> queuedUserInputEvents . takeFirst ( ) ; } else if ( XEventsQueued ( X11 -> display , QueuedAlready ) ) { XNextEvent ( X11 -> display , & event ) ; if ( flags & QEventLoop :: ExcludeUserInputEvents ) { switch ( event . type ) { case ButtonPress : case ButtonRelease : case MotionNotify : case XKeyPress : case XKeyRelease : case EnterNotify : case LeaveNotify : d -> queuedUserInputEvents . append ( event ) ; continue ; case ClientMessage : if ( event . xclient . format == 32 ) { if ( event . xclient . message_type == ATOM ( WM_PROTOCOLS ) && ( Atom ) event . xclient . data . l [ 0 ] == ATOM ( WM_TAKE_FOCUS ) ) { break ; } else if ( event . xclient . message_type == ATOM ( _QT_SCROLL_DONE ) ) { break ; } } d -> queuedUserInputEvents . append ( event ) ; continue ; default : break ; } } } else { break ; } if ( filterEvent ( & event ) ) continue ; nevents ++ ; if ( qApp -> x11ProcessEvent ( & event ) == 1 ) return true ; if ( event . xany . serial >= marker ) { if ( XEventsQueued ( X11 -> display , QueuedAfterFlush ) ) flags &= ~ QEventLoop :: WaitForMoreEvents ; goto out ; } } } while ( ! d -> interrupt && XEventsQueued ( X11 -> display , QueuedAfterFlush ) ) ; out : if ( ! d -> interrupt ) { const uint exclude_all = QEventLoop :: ExcludeSocketNotifiers | QEventLoop :: X11ExcludeTimers | QEventLoop :: WaitForMoreEvents ; if ( nevents > 0 && ( ( uint ) flags & exclude_all ) == exclude_all ) { QApplication :: sendPostedEvents ( ) ; return nevents > 0 ; } return QEventDispatcherUNIX :: processEvents ( flags ) || ( nevents > 0 ) ; } return nevents > 0 ; } bool QEventDispatcherX11 :: hasPendingEvents ( ) { extern uint qGlobalPostedEventsCount ( ) ; return ( qGlobalPostedEventsCount ( ) || XPending ( X11 -> display ) ) ; } void QEventDispatcherX11 :: flush ( ) { XFlush ( X11 -> display ) ; } void QEventDispatcherX11 :: startingUp ( ) { Q_D ( QEventDispatcherX11 ) ; d -> xfd = XConnectionNumber ( X11 -> display ) ; } void QEventDispatcherX11 :: closingDown ( ) { Q_D ( QEventDispatcherX11 ) ; d -> xfd = - 1 ; } int QEventDispatcherX11 :: select ( int nfds , fd_set * readfds , fd_set * writefds , fd_set * exceptfds , timeval * timeout ) { Q_D ( QEventDispatcherX11 ) ; if ( d -> xfd > 0 ) { nfds = qMax ( nfds - 1 , d -> xfd ) + 1 ; FD_SET ( d -> xfd , readfds ) ; } return QEventDispatcherUNIX :: select ( nfds , readfds , writefds , exceptfds , timeout ) ; } QT_END_NAMESPACE </DOCUMENT>
<DOCUMENT_ID="braingl/braingl/tree/master/src/algos/sdthread.cpp"> # include " sdthread . h " # include " . . / data / datasets / datasetdwi . h " # include " . . / gui / gl / glfunctions . h " SDThread :: SDThread ( DatasetDWI * ds , int id ) : m_dataset ( ds ) , m_id ( id ) { m_dwi = ds -> getData ( ) ; m_bvals = ds -> getBvals ( ) ; m_bvecs = ds -> getBvecs ( ) ; int nx = ds -> properties ( " maingl " ) . get ( Fn :: Property :: D_NX ) . toInt ( ) ; int ny = ds -> properties ( " maingl " ) . get ( Fn :: Property :: D_NY ) . toInt ( ) ; int nz = ds -> properties ( " maingl " ) . get ( Fn :: Property :: D_NZ ) . toInt ( ) ; m_blockSize = nx * ny * nz ; } SDThread :: ~ SDThread ( ) { } void SDThread :: run ( ) { int numThreads = GLFunctions :: idealThreadCount ; int progressCounter = 0 ; for ( int i = m_id ; i < m_blockSize ; i += numThreads ) { calcSD ( i ) ; ++ progressCounter ; if ( progressCounter == 100 ) { emit ( progress ( ) ) ; progressCounter = 0 ; } } emit ( finished ( ) ) ; } ColumnVector SDThread :: calcSD ( int id ) { return ColumnVector ( 20 ) ; } </DOCUMENT>
<DOCUMENT_ID="hoangt/goblin-core/tree/master/riscv/llvm/3.5/llvm-3.5.0.src/lib/Target/Mips/MipsSEFrameLowering.cpp"> # include " MipsSEFrameLowering . h " # include " MCTargetDesc / MipsBaseInfo . h " # include " MipsAnalyzeImmediate . h " # include " MipsMachineFunction . h " # include " MipsSEInstrInfo . h " # include " MipsSubtarget . h " # include " llvm / CodeGen / MachineFrameInfo . h " # include " llvm / CodeGen / MachineFunction . h " # include " llvm / CodeGen / MachineInstrBuilder . h " # include " llvm / CodeGen / MachineModuleInfo . h " # include " llvm / CodeGen / MachineRegisterInfo . h " # include " llvm / CodeGen / RegisterScavenging . h " # include " llvm / IR / DataLayout . h " # include " llvm / IR / Function . h " # include " llvm / Support / CommandLine . h " # include " llvm / Target / TargetOptions . h " using namespace llvm ; namespace { typedef MachineBasicBlock :: iterator Iter ; static std :: pair < unsigned , unsigned > getMFHiLoOpc ( unsigned Src ) { if ( Mips :: ACC64RegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: PseudoMFHI , ( unsigned ) Mips :: PseudoMFLO ) ; if ( Mips :: ACC64DSPRegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: MFHI_DSP , ( unsigned ) Mips :: MFLO_DSP ) ; if ( Mips :: ACC128RegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: PseudoMFHI64 , ( unsigned ) Mips :: PseudoMFLO64 ) ; return std :: make_pair ( 0 , 0 ) ; } class ExpandPseudo { public : ExpandPseudo ( MachineFunction & MF ) ; bool expand ( ) ; private : bool expandInstr ( MachineBasicBlock & MBB , Iter I ) ; void expandLoadCCond ( MachineBasicBlock & MBB , Iter I ) ; void expandStoreCCond ( MachineBasicBlock & MBB , Iter I ) ; void expandLoadACC ( MachineBasicBlock & MBB , Iter I , unsigned RegSize ) ; void expandStoreACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc , unsigned RegSize ) ; bool expandCopy ( MachineBasicBlock & MBB , Iter I ) ; bool expandCopyACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc ) ; bool expandBuildPairF64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool FP64 ) const ; bool expandExtractElementF64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool FP64 ) const ; MachineFunction & MF ; MachineRegisterInfo & MRI ; } ; } ExpandPseudo :: ExpandPseudo ( MachineFunction & MF_ ) : MF ( MF_ ) , MRI ( MF . getRegInfo ( ) ) { } bool ExpandPseudo :: expand ( ) { bool Expanded = false ; for ( MachineFunction :: iterator BB = MF . begin ( ) , BBEnd = MF . end ( ) ; BB != BBEnd ; ++ BB ) for ( Iter I = BB -> begin ( ) , End = BB -> end ( ) ; I != End ; ) Expanded |= expandInstr ( * BB , I ++ ) ; return Expanded ; } bool ExpandPseudo :: expandInstr ( MachineBasicBlock & MBB , Iter I ) { switch ( I -> getOpcode ( ) ) { case Mips :: LOAD_CCOND_DSP : expandLoadCCond ( MBB , I ) ; break ; case Mips :: STORE_CCOND_DSP : expandStoreCCond ( MBB , I ) ; break ; case Mips :: LOAD_ACC64 : case Mips :: LOAD_ACC64DSP : expandLoadACC ( MBB , I , 4 ) ; break ; case Mips :: LOAD_ACC128 : expandLoadACC ( MBB , I , 8 ) ; break ; case Mips :: STORE_ACC64 : expandStoreACC ( MBB , I , Mips :: PseudoMFHI , Mips :: PseudoMFLO , 4 ) ; break ; case Mips :: STORE_ACC64DSP : expandStoreACC ( MBB , I , Mips :: MFHI_DSP , Mips :: MFLO_DSP , 4 ) ; break ; case Mips :: STORE_ACC128 : expandStoreACC ( MBB , I , Mips :: PseudoMFHI64 , Mips :: PseudoMFLO64 , 8 ) ; break ; case Mips :: BuildPairF64 : if ( expandBuildPairF64 ( MBB , I , false ) ) MBB . erase ( I ) ; return false ; case Mips :: BuildPairF64_64 : if ( expandBuildPairF64 ( MBB , I , true ) ) MBB . erase ( I ) ; return false ; case Mips :: ExtractElementF64 : if ( expandExtractElementF64 ( MBB , I , false ) ) MBB . erase ( I ) ; return false ; case Mips :: ExtractElementF64_64 : if ( expandExtractElementF64 ( MBB , I , true ) ) MBB . erase ( I ) ; return false ; case TargetOpcode :: COPY : if ( ! expandCopy ( MBB , I ) ) return false ; break ; default : return false ; } MBB . erase ( I ) ; return true ; } void ExpandPseudo :: expandLoadCCond ( MachineBasicBlock & MBB , Iter I ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( 4 ) ; unsigned VR = MRI . createVirtualRegister ( RC ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; TII . loadRegFromStack ( MBB , I , VR , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , I -> getDebugLoc ( ) , TII . get ( TargetOpcode :: COPY ) , Dst ) . addReg ( VR , RegState :: Kill ) ; } void ExpandPseudo :: expandStoreCCond ( MachineBasicBlock & MBB , Iter I ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( 4 ) ; unsigned VR = MRI . createVirtualRegister ( RC ) ; unsigned Src = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; BuildMI ( MBB , I , I -> getDebugLoc ( ) , TII . get ( TargetOpcode :: COPY ) , VR ) . addReg ( Src , getKillRegState ( I -> getOperand ( 0 ) . isKill ( ) ) ) ; TII . storeRegToStack ( MBB , I , VR , true , FI , RC , & RegInfo , 0 ) ; } void ExpandPseudo :: expandLoadACC ( MachineBasicBlock & MBB , Iter I , unsigned RegSize ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( RegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; unsigned Lo = RegInfo . getSubReg ( Dst , Mips :: sub_lo ) ; unsigned Hi = RegInfo . getSubReg ( Dst , Mips :: sub_hi ) ; DebugLoc DL = I -> getDebugLoc ( ) ; const MCInstrDesc & Desc = TII . get ( TargetOpcode :: COPY ) ; TII . loadRegFromStack ( MBB , I , VR0 , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , DL , Desc , Lo ) . addReg ( VR0 , RegState :: Kill ) ; TII . loadRegFromStack ( MBB , I , VR1 , FI , RC , & RegInfo , RegSize ) ; BuildMI ( MBB , I , DL , Desc , Hi ) . addReg ( VR1 , RegState :: Kill ) ; } void ExpandPseudo :: expandStoreACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc , unsigned RegSize ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( RegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned Src = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; unsigned SrcKill = getKillRegState ( I -> getOperand ( 0 ) . isKill ( ) ) ; DebugLoc DL = I -> getDebugLoc ( ) ; BuildMI ( MBB , I , DL , TII . get ( MFLoOpc ) , VR0 ) . addReg ( Src ) ; TII . storeRegToStack ( MBB , I , VR0 , true , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , DL , TII . get ( MFHiOpc ) , VR1 ) . addReg ( Src , SrcKill ) ; TII . storeRegToStack ( MBB , I , VR1 , true , FI , RC , & RegInfo , RegSize ) ; } bool ExpandPseudo :: expandCopy ( MachineBasicBlock & MBB , Iter I ) { unsigned Src = I -> getOperand ( 1 ) . getReg ( ) ; std :: pair < unsigned , unsigned > Opcodes = getMFHiLoOpc ( Src ) ; if ( ! Opcodes . first ) return false ; return expandCopyACC ( MBB , I , Opcodes . first , Opcodes . second ) ; } bool ExpandPseudo :: expandCopyACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc ) { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , Src = I -> getOperand ( 1 ) . getReg ( ) ; unsigned VRegSize = RegInfo . getMinimalPhysRegClass ( Dst ) -> getSize ( ) / 2 ; const TargetRegisterClass * RC = RegInfo . intRegClass ( VRegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned SrcKill = getKillRegState ( I -> getOperand ( 1 ) . isKill ( ) ) ; unsigned DstLo = RegInfo . getSubReg ( Dst , Mips :: sub_lo ) ; unsigned DstHi = RegInfo . getSubReg ( Dst , Mips :: sub_hi ) ; DebugLoc DL = I -> getDebugLoc ( ) ; BuildMI ( MBB , I , DL , TII . get ( MFLoOpc ) , VR0 ) . addReg ( Src ) ; BuildMI ( MBB , I , DL , TII . get ( TargetOpcode :: COPY ) , DstLo ) . addReg ( VR0 , RegState :: Kill ) ; BuildMI ( MBB , I , DL , TII . get ( MFHiOpc ) , VR1 ) . addReg ( Src , SrcKill ) ; BuildMI ( MBB , I , DL , TII . get ( TargetOpcode :: COPY ) , DstHi ) . addReg ( VR1 , RegState :: Kill ) ; return true ; } bool ExpandPseudo :: expandBuildPairF64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool FP64 ) const { const TargetMachine & TM = MF . getTarget ( ) ; const MipsSubtarget & Subtarget = TM . getSubtarget < MipsSubtarget > ( ) ; if ( ( Subtarget . isABI_FPXX ( ) && ! Subtarget . hasMTHC1 ( ) ) || ( FP64 && ! Subtarget . useOddSPReg ( ) ) ) { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( TM . getInstrInfo ( ) ) ; const MipsRegisterInfo & TRI = * static_cast < const MipsRegisterInfo * > ( TM . getRegisterInfo ( ) ) ; unsigned DstReg = I -> getOperand ( 0 ) . getReg ( ) ; unsigned LoReg = I -> getOperand ( 1 ) . getReg ( ) ; unsigned HiReg = I -> getOperand ( 2 ) . getReg ( ) ; assert ( Subtarget . isGP64bit ( ) || Subtarget . hasMTHC1 ( ) || ! Subtarget . isFP64bit ( ) ) ; const TargetRegisterClass * RC = & Mips :: GPR32RegClass ; const TargetRegisterClass * RC2 = FP64 ? & Mips :: FGR64RegClass : & Mips :: AFGR64RegClass ; int FI = MF . getInfo < MipsFunctionInfo > ( ) -> getMoveF64ViaSpillFI ( RC2 ) ; TII . storeRegToStack ( MBB , I , LoReg , I -> getOperand ( 1 ) . isKill ( ) , FI , RC , & TRI , 0 ) ; TII . storeRegToStack ( MBB , I , HiReg , I -> getOperand ( 2 ) . isKill ( ) , FI , RC , & TRI , 4 ) ; TII . loadRegFromStack ( MBB , I , DstReg , FI , RC2 , & TRI , 0 ) ; return true ; } return false ; } bool ExpandPseudo :: expandExtractElementF64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool FP64 ) const { const TargetMachine & TM = MF . getTarget ( ) ; const MipsSubtarget & Subtarget = TM . getSubtarget < MipsSubtarget > ( ) ; if ( ( Subtarget . isABI_FPXX ( ) && ! Subtarget . hasMTHC1 ( ) ) || ( FP64 && ! Subtarget . useOddSPReg ( ) ) ) { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( TM . getInstrInfo ( ) ) ; const MipsRegisterInfo & TRI = * static_cast < const MipsRegisterInfo * > ( TM . getRegisterInfo ( ) ) ; unsigned DstReg = I -> getOperand ( 0 ) . getReg ( ) ; unsigned SrcReg = I -> getOperand ( 1 ) . getReg ( ) ; unsigned N = I -> getOperand ( 2 ) . getImm ( ) ; assert ( Subtarget . isGP64bit ( ) || Subtarget . hasMTHC1 ( ) || ! Subtarget . isFP64bit ( ) ) ; const TargetRegisterClass * RC = FP64 ? & Mips :: FGR64RegClass : & Mips :: AFGR64RegClass ; const TargetRegisterClass * RC2 = & Mips :: GPR32RegClass ; int FI = MF . getInfo < MipsFunctionInfo > ( ) -> getMoveF64ViaSpillFI ( RC ) ; TII . storeRegToStack ( MBB , I , SrcReg , I -> getOperand ( 1 ) . isKill ( ) , FI , RC , & TRI , 0 ) ; TII . loadRegFromStack ( MBB , I , DstReg , FI , RC2 , & TRI , N * 4 ) ; return true ; } return false ; } MipsSEFrameLowering :: MipsSEFrameLowering ( const MipsSubtarget & STI ) : MipsFrameLowering ( STI , STI . stackAlignment ( ) ) { } unsigned MipsSEFrameLowering :: ehDataReg ( unsigned I ) const { static const unsigned EhDataReg [ ] = { Mips :: A0 , Mips :: A1 , Mips :: A2 , Mips :: A3 } ; static const unsigned EhDataReg64 [ ] = { Mips :: A0_64 , Mips :: A1_64 , Mips :: A2_64 , Mips :: A3_64 } ; return STI . isABI_N64 ( ) ? EhDataReg64 [ I ] : EhDataReg [ I ] ; } void MipsSEFrameLowering :: emitPrologue ( MachineFunction & MF ) const { MachineBasicBlock & MBB = MF . front ( ) ; MachineFrameInfo * MFI = MF . getFrameInfo ( ) ; MipsFunctionInfo * MipsFI = MF . getInfo < MipsFunctionInfo > ( ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; MachineBasicBlock :: iterator MBBI = MBB . begin ( ) ; DebugLoc dl = MBBI != MBB . end ( ) ? MBBI -> getDebugLoc ( ) : DebugLoc ( ) ; unsigned SP = STI . isABI_N64 ( ) ? Mips :: SP_64 : Mips :: SP ; unsigned FP = STI . isABI_N64 ( ) ? Mips :: FP_64 : Mips :: FP ; unsigned ZERO = STI . isABI_N64 ( ) ? Mips :: ZERO_64 : Mips :: ZERO ; unsigned ADDu = STI . isABI_N64 ( ) ? Mips :: DADDu : Mips :: ADDu ; uint64_t StackSize = MFI -> getStackSize ( ) ; if ( StackSize == 0 && ! MFI -> adjustsStack ( ) ) return ; MachineModuleInfo & MMI = MF . getMMI ( ) ; const MCRegisterInfo * MRI = MMI . getContext ( ) . getRegisterInfo ( ) ; MachineLocation DstML , SrcML ; TII . adjustStackPtr ( SP , - StackSize , MBB , MBBI ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createDefCfaOffset ( nullptr , - StackSize ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; const std :: vector < CalleeSavedInfo > & CSI = MFI -> getCalleeSavedInfo ( ) ; if ( CSI . size ( ) ) { for ( unsigned i = 0 ; i < CSI . size ( ) ; ++ i ) ++ MBBI ; for ( std :: vector < CalleeSavedInfo > :: const_iterator I = CSI . begin ( ) , E = CSI . end ( ) ; I != E ; ++ I ) { int64_t Offset = MFI -> getObjectOffset ( I -> getFrameIdx ( ) ) ; unsigned Reg = I -> getReg ( ) ; if ( Mips :: AFGR64RegClass . contains ( Reg ) ) { unsigned Reg0 = MRI -> getDwarfRegNum ( RegInfo . getSubReg ( Reg , Mips :: sub_lo ) , true ) ; unsigned Reg1 = MRI -> getDwarfRegNum ( RegInfo . getSubReg ( Reg , Mips :: sub_hi ) , true ) ; if ( ! STI . isLittle ( ) ) std :: swap ( Reg0 , Reg1 ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg0 , Offset ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg1 , Offset + 4 ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } else if ( Mips :: FGR64RegClass . contains ( Reg ) ) { unsigned Reg0 = MRI -> getDwarfRegNum ( Reg , true ) ; unsigned Reg1 = MRI -> getDwarfRegNum ( Reg , true ) + 1 ; if ( ! STI . isLittle ( ) ) std :: swap ( Reg0 , Reg1 ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg0 , Offset ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg1 , Offset + 4 ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } else { unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , MRI -> getDwarfRegNum ( Reg , 1 ) , Offset ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } } } if ( MipsFI -> callsEhReturn ( ) ) { const TargetRegisterClass * RC = STI . isABI_N64 ( ) ? & Mips :: GPR64RegClass : & Mips :: GPR32RegClass ; for ( int I = 0 ; I < 4 ; ++ I ) { if ( ! MBB . isLiveIn ( ehDataReg ( I ) ) ) MBB . addLiveIn ( ehDataReg ( I ) ) ; TII . storeRegToStackSlot ( MBB , MBBI , ehDataReg ( I ) , false , MipsFI -> getEhDataRegFI ( I ) , RC , & RegInfo ) ; } for ( int I = 0 ; I < 4 ; ++ I ) { int64_t Offset = MFI -> getObjectOffset ( MipsFI -> getEhDataRegFI ( I ) ) ; unsigned Reg = MRI -> getDwarfRegNum ( ehDataReg ( I ) , true ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg , Offset ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } } if ( hasFP ( MF ) ) { BuildMI ( MBB , MBBI , dl , TII . get ( ADDu ) , FP ) . addReg ( SP ) . addReg ( ZERO ) . setMIFlag ( MachineInstr :: FrameSetup ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createDefCfaRegister ( nullptr , MRI -> getDwarfRegNum ( FP , true ) ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } } void MipsSEFrameLowering :: emitEpilogue ( MachineFunction & MF , MachineBasicBlock & MBB ) const { MachineBasicBlock :: iterator MBBI = MBB . getLastNonDebugInstr ( ) ; MachineFrameInfo * MFI = MF . getFrameInfo ( ) ; MipsFunctionInfo * MipsFI = MF . getInfo < MipsFunctionInfo > ( ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; DebugLoc dl = MBBI -> getDebugLoc ( ) ; unsigned SP = STI . isABI_N64 ( ) ? Mips :: SP_64 : Mips :: SP ; unsigned FP = STI . isABI_N64 ( ) ? Mips :: FP_64 : Mips :: FP ; unsigned ZERO = STI . isABI_N64 ( ) ? Mips :: ZERO_64 : Mips :: ZERO ; unsigned ADDu = STI . isABI_N64 ( ) ? Mips :: DADDu : Mips :: ADDu ; if ( hasFP ( MF ) ) { MachineBasicBlock :: iterator I = MBBI ; for ( unsigned i = 0 ; i < MFI -> getCalleeSavedInfo ( ) . size ( ) ; ++ i ) -- I ; BuildMI ( MBB , I , dl , TII . get ( ADDu ) , SP ) . addReg ( FP ) . addReg ( ZERO ) ; } if ( MipsFI -> callsEhReturn ( ) ) { const TargetRegisterClass * RC = STI . isABI_N64 ( ) ? & Mips :: GPR64RegClass : & Mips :: GPR32RegClass ; MachineBasicBlock :: iterator I = MBBI ; for ( unsigned i = 0 ; i < MFI -> getCalleeSavedInfo ( ) . size ( ) ; ++ i ) -- I ; for ( int J = 0 ; J < 4 ; ++ J ) { TII . loadRegFromStackSlot ( MBB , I , ehDataReg ( J ) , MipsFI -> getEhDataRegFI ( J ) , RC , & RegInfo ) ; } } uint64_t StackSize = MFI -> getStackSize ( ) ; if ( ! StackSize ) return ; TII . adjustStackPtr ( SP , StackSize , MBB , MBBI ) ; } bool MipsSEFrameLowering :: spillCalleeSavedRegisters ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator MI , const std :: vector < CalleeSavedInfo > & CSI , const TargetRegisterInfo * TRI ) const { MachineFunction * MF = MBB . getParent ( ) ; MachineBasicBlock * EntryBlock = MF -> begin ( ) ; const TargetInstrInfo & TII = * MF -> getTarget ( ) . getInstrInfo ( ) ; for ( unsigned i = 0 , e = CSI . size ( ) ; i != e ; ++ i ) { unsigned Reg = CSI [ i ] . getReg ( ) ; bool IsRAAndRetAddrIsTaken = ( Reg == Mips :: RA || Reg == Mips :: RA_64 ) && MF -> getFrameInfo ( ) -> isReturnAddressTaken ( ) ; if ( ! IsRAAndRetAddrIsTaken ) EntryBlock -> addLiveIn ( Reg ) ; bool IsKill = ! IsRAAndRetAddrIsTaken ; const TargetRegisterClass * RC = TRI -> getMinimalPhysRegClass ( Reg ) ; TII . storeRegToStackSlot ( * EntryBlock , MI , Reg , IsKill , CSI [ i ] . getFrameIdx ( ) , RC , TRI ) ; } return true ; } bool MipsSEFrameLowering :: hasReservedCallFrame ( const MachineFunction & MF ) const { const MachineFrameInfo * MFI = MF . getFrameInfo ( ) ; return isInt < 16 > ( MFI -> getMaxCallFrameSize ( ) + getStackAlignment ( ) ) && ! MFI -> hasVarSizedObjects ( ) ; } void MipsSEFrameLowering :: eliminateCallFramePseudoInstr ( MachineFunction & MF , MachineBasicBlock & MBB , MachineBasicBlock :: iterator I ) const { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; if ( ! hasReservedCallFrame ( MF ) ) { int64_t Amount = I -> getOperand ( 0 ) . getImm ( ) ; if ( I -> getOpcode ( ) == Mips :: ADJCALLSTACKDOWN ) Amount = - Amount ; unsigned SP = STI . isABI_N64 ( ) ? Mips :: SP_64 : Mips :: SP ; TII . adjustStackPtr ( SP , Amount , MBB , I ) ; } MBB . erase ( I ) ; } void MipsSEFrameLowering :: processFunctionBeforeCalleeSavedScan ( MachineFunction & MF , RegScavenger * RS ) const { MachineRegisterInfo & MRI = MF . getRegInfo ( ) ; MipsFunctionInfo * MipsFI = MF . getInfo < MipsFunctionInfo > ( ) ; unsigned FP = STI . isABI_N64 ( ) ? Mips :: FP_64 : Mips :: FP ; if ( hasFP ( MF ) ) MRI . setPhysRegUsed ( FP ) ; if ( MipsFI -> callsEhReturn ( ) ) MipsFI -> createEhDataRegsFI ( ) ; if ( ExpandPseudo ( MF ) . expand ( ) ) { const TargetRegisterClass * RC = STI . hasMips64 ( ) ? & Mips :: GPR64RegClass : & Mips :: GPR32RegClass ; int FI = MF . getFrameInfo ( ) -> CreateStackObject ( RC -> getSize ( ) , RC -> getAlignment ( ) , false ) ; RS -> addScavengingFrameIndex ( FI ) ; } uint64_t MaxSPOffset = MF . getInfo < MipsFunctionInfo > ( ) -> getIncomingArgSize ( ) + estimateStackSize ( MF ) ; if ( isInt < 16 > ( MaxSPOffset ) ) return ; const TargetRegisterClass * RC = STI . isABI_N64 ( ) ? & Mips :: GPR64RegClass : & Mips :: GPR32RegClass ; int FI = MF . getFrameInfo ( ) -> CreateStackObject ( RC -> getSize ( ) , RC -> getAlignment ( ) , false ) ; RS -> addScavengingFrameIndex ( FI ) ; } const MipsFrameLowering * llvm :: createMipsSEFrameLowering ( const MipsSubtarget & ST ) { return new MipsSEFrameLowering ( ST ) ; } </DOCUMENT>
<DOCUMENT_ID="GreenDamTan/ppsspp/tree/master/Core/MIPS/x86/Asm.cpp"> # include " math / math _ util . h " # include " ABI . h " # include " x64Emitter . h " # include " Core / Core . h " # include " Core / MemMap . h " # include " Core / System . h " # include " Core / MIPS / MIPS . h " # include " Core / CoreTiming . h " # include " Common / MemoryUtil . h " # include " Core / MIPS / JitCommon / JitCommon . h " # include " Core / MIPS / x86 / Asm . h " # include " Core / MIPS / x86 / Jit . h " using namespace Gen ; using namespace X64JitConstants ; static bool enableDebug = false ; extern volatile CoreState coreState ; void ImHere ( ) { DEBUG_LOG ( CPU , " JIT ▁ Here : ▁ % 08x " , currentMIPS -> pc ) ; } void AsmRoutineManager :: Generate ( MIPSState * mips , MIPSComp :: Jit * jit , MIPSComp :: JitOptions * jo ) { enterCode = AlignCode16 ( ) ; ABI_PushAllCalleeSavedRegsAndAdjustStack ( ) ; # ifdef _M_X64 MOV ( 64 , R ( MEMBASEREG ) , ImmPtr ( Memory :: base ) ) ; uintptr_t jitbase = ( uintptr_t ) jit -> GetBasePtr ( ) ; if ( jitbase > 0x7FFFFFFFULL ) { MOV ( 64 , R ( JITBASEREG ) , ImmPtr ( jit -> GetBasePtr ( ) ) ) ; jo -> reserveR15ForAsm = true ; } # endif MOV ( PTRBITS , R ( CTXREG ) , ImmPtr ( & mips -> f [ 0 ] ) ) ; outerLoop = GetCodePtr ( ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_CallFunction ( reinterpret_cast < void * > ( & CoreTiming :: Advance ) ) ; jit -> ApplyRoundingMode ( true , this ) ; FixupBranch skipToRealDispatch = J ( ) ; dispatcherCheckCoreState = GetCodePtr ( ) ; FixupBranch bailCoreState = J_CC ( CC_S , true ) ; CMP ( 32 , M ( & coreState ) , Imm32 ( 0 ) ) ; FixupBranch badCoreState = J_CC ( CC_NZ , true ) ; FixupBranch skipToRealDispatch2 = J ( ) ; dispatcher = GetCodePtr ( ) ; FixupBranch bail = J_CC ( CC_S , true ) ; SetJumpTarget ( skipToRealDispatch ) ; SetJumpTarget ( skipToRealDispatch2 ) ; dispatcherNoCheck = GetCodePtr ( ) ; MOV ( 32 , R ( EAX ) , M ( & mips -> pc ) ) ; dispatcherInEAXNoCheck = GetCodePtr ( ) ; # ifdef _M_IX86 AND ( 32 , R ( EAX ) , Imm32 ( Memory :: MEMVIEW32_MASK ) ) ; _assert_msg_ ( CPU , Memory :: base != 0 , " Memory ▁ base ▁ bogus " ) ; MOV ( 32 , R ( EAX ) , MDisp ( EAX , ( u32 ) Memory :: base ) ) ; # elif _M_X64 MOV ( 32 , R ( EAX ) , MComplex ( MEMBASEREG , RAX , SCALE_1 , 0 ) ) ; # endif MOV ( 32 , R ( EDX ) , R ( EAX ) ) ; _assert_msg_ ( JIT , MIPS_JITBLOCK_MASK == 0xFF000000 , " Hardcoded ▁ assumption ▁ of ▁ emuhack ▁ mask " ) ; SHR ( 32 , R ( EDX ) , Imm8 ( 24 ) ) ; CMP ( 32 , R ( EDX ) , Imm8 ( MIPS_EMUHACK_OPCODE >> 24 ) ) ; FixupBranch notfound = J_CC ( CC_NE ) ; if ( enableDebug ) { ADD ( 32 , M ( & mips -> debugCount ) , Imm8 ( 1 ) ) ; } AND ( 32 , R ( EAX ) , Imm32 ( MIPS_EMUHACK_VALUE_MASK ) ) ; # ifdef _M_IX86 ADD ( 32 , R ( EAX ) , ImmPtr ( jit -> GetBasePtr ( ) ) ) ; # elif _M_X64 if ( jo -> reserveR15ForAsm ) ADD ( 64 , R ( RAX ) , R ( JITBASEREG ) ) ; else ADD ( 64 , R ( EAX ) , Imm32 ( jitbase ) ) ; # endif JMPptr ( R ( EAX ) ) ; SetJumpTarget ( notfound ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_CallFunction ( & MIPSComp :: JitAt ) ; jit -> ApplyRoundingMode ( true , this ) ; JMP ( dispatcherNoCheck , true ) ; SetJumpTarget ( bail ) ; SetJumpTarget ( bailCoreState ) ; CMP ( 32 , M ( & coreState ) , Imm32 ( 0 ) ) ; J_CC ( CC_Z , outerLoop , true ) ; SetJumpTarget ( badCoreState ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_PopAllCalleeSavedRegsAndAdjustStack ( ) ; RET ( ) ; breakpointBailout = GetCodePtr ( ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_PopAllCalleeSavedRegsAndAdjustStack ( ) ; RET ( ) ; } </DOCUMENT>
<DOCUMENT_ID="ostash/qt-creator-i18n-uk/tree/master/src/plugins/help/xbelsupport.cpp"> # include " xbelsupport . h " # include " bookmarkmanager . h " # include < QCoreApplication > using namespace Help :: Internal ; struct Bookmark { QString title ; QString url ; bool folded ; } ; XbelWriter :: XbelWriter ( BookmarkModel * model ) : QXmlStreamWriter ( ) , treeModel ( model ) { setAutoFormatting ( true ) ; } void XbelWriter :: writeToFile ( QIODevice * device ) { setDevice ( device ) ; writeStartDocument ( ) ; writeDTD ( QLatin1String ( " < ! DOCTYPE ▁ xbel > " ) ) ; writeStartElement ( QLatin1String ( " xbel " ) ) ; writeAttribute ( QLatin1String ( " version " ) , QLatin1String ( "1.0" ) ) ; QStandardItem * root = treeModel -> invisibleRootItem ( ) ; for ( int i = 0 ; i < root -> rowCount ( ) ; ++ i ) writeData ( root -> child ( i ) ) ; writeEndDocument ( ) ; } void XbelWriter :: writeData ( QStandardItem * child ) { Bookmark entry ; entry . title = child -> data ( Qt :: DisplayRole ) . toString ( ) ; entry . url = child -> data ( Qt :: UserRole + 10 ) . toString ( ) ; if ( entry . url == QLatin1String ( " Folder " ) ) { writeStartElement ( QLatin1String ( " folder " ) ) ; entry . folded = ! child -> data ( Qt :: UserRole + 11 ) . toBool ( ) ; writeAttribute ( QLatin1String ( " folded " ) , entry . folded ? QLatin1String ( " yes " ) : QLatin1String ( " no " ) ) ; writeTextElement ( QLatin1String ( " title " ) , entry . title ) ; for ( int i = 0 ; i < child -> rowCount ( ) ; ++ i ) writeData ( child -> child ( i ) ) ; writeEndElement ( ) ; } else { writeStartElement ( QLatin1String ( " bookmark " ) ) ; writeAttribute ( QLatin1String ( " href " ) , entry . url ) ; writeTextElement ( QLatin1String ( " title " ) , entry . title ) ; writeEndElement ( ) ; } } XbelReader :: XbelReader ( BookmarkModel * tree , BookmarkModel * list ) : QXmlStreamReader ( ) , treeModel ( tree ) , listModel ( list ) { bookmarkIcon = QIcon ( QLatin1String ( " : / help / images / bookmark . png " ) ) ; folderIcon = QApplication :: style ( ) -> standardIcon ( QStyle :: SP_DirClosedIcon ) ; } bool XbelReader :: readFromFile ( QIODevice * device ) { setDevice ( device ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " xbel " ) && attributes ( ) . value ( QLatin1String ( " version " ) ) == QLatin1String ( "1.0" ) ) { readXBEL ( ) ; } else { raiseError ( QCoreApplication :: translate ( " Help : : Internal : : XbelReader " , " The ▁ file ▁ is ▁ not ▁ an ▁ XBEL ▁ version ▁ 1.0 ▁ file . " ) ) ; } } } return ! error ( ) ; } void XbelReader :: readXBEL ( ) { while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " folder " ) ) readFolder ( 0 ) ; else if ( name ( ) == QLatin1String ( " bookmark " ) ) readBookmark ( 0 ) ; else readUnknownElement ( ) ; } } } void XbelReader :: readUnknownElement ( ) { while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) readUnknownElement ( ) ; } } void XbelReader :: readFolder ( QStandardItem * item ) { QStandardItem * folder = createChildItem ( item ) ; folder -> setIcon ( folderIcon ) ; folder -> setData ( QLatin1String ( " Folder " ) , Qt :: UserRole + 10 ) ; bool expanded = ( attributes ( ) . value ( QLatin1String ( " folded " ) ) != QLatin1String ( " no " ) ) ; folder -> setData ( expanded , Qt :: UserRole + 11 ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " title " ) ) folder -> setText ( readElementText ( ) ) ; else if ( name ( ) == QLatin1String ( " folder " ) ) readFolder ( folder ) ; else if ( name ( ) == QLatin1String ( " bookmark " ) ) readBookmark ( folder ) ; else readUnknownElement ( ) ; } } } void XbelReader :: readBookmark ( QStandardItem * item ) { QStandardItem * bookmark = createChildItem ( item ) ; bookmark -> setIcon ( bookmarkIcon ) ; bookmark -> setText ( QCoreApplication :: translate ( " Help : : Internal : : XbelReader " , " Unknown ▁ title " ) ) ; bookmark -> setData ( attributes ( ) . value ( QLatin1String ( " href " ) ) . toString ( ) , Qt :: UserRole + 10 ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " title " ) ) bookmark -> setText ( readElementText ( ) ) ; else readUnknownElement ( ) ; } } listModel -> appendRow ( bookmark -> clone ( ) ) ; } QStandardItem * XbelReader :: createChildItem ( QStandardItem * item ) { QStandardItem * childItem = new QStandardItem ( ) ; childItem -> setEditable ( false ) ; if ( item ) item -> appendRow ( childItem ) ; else treeModel -> appendRow ( childItem ) ; return childItem ; } </DOCUMENT>
<DOCUMENT_ID="slicer4ever/Lightwave/tree/master/Engine/Source/C++11/LWEProtocols/LWEProtocolWebSocketSecure.cpp"> # include " LWEProtocols / LWEProtocolWebSocketSecure . h " # include " LWEProtocols / LWEProtocolHTTP . h " # include < LWNetwork / LWSocket . h > # include < LWNetwork / LWProtocolManager . h > # include < LWCore / LWAllocator . h > # include < LWCore / LWCrypto . h > # include < LWCore / LWText . h > # include < LWCore / LWByteBuffer . h > # include < iostream > bool LWEProtocolWebSocketSecure :: ProcessRead ( LWSocket & Socket , const char * Buffer , uint32_t BufferLen ) { char Buf [ 256 ] ; char BufB [ 256 ] ; LWEWebSocket * WebSocket = ( LWEWebSocket * ) Socket . GetProtocolData ( m_wProtocolID ) ; if ( ! WebSocket ) { LWEHttpRequest Request ; uint32_t Error = 0 ; Error = Request . Deserialize ( Buffer , BufferLen ) ? 0 : 1 ; Error = Error ? Error : ( * Request . m_SecWebSockKey && Request . m_WebSockVersion == LWEWEBSOCKET_SUPPVER && Request . UpgradeConnection ( ) ) ? 0 : 2 ; if ( ! Error && * Request . m_SecWebSockProto ) { bool ValidProtocol = false ; if ( * m_SubProtocol ) { uint32_t ProtocolLen = ( uint32_t ) strlen ( m_SubProtocol ) ; for ( const char * C = Request . m_SecWebSockProto ; C && ! ValidProtocol ; C = LWText :: FirstToken ( C , ' , ' ) ) { C = LWText :: NextWord ( * C == ' , ' ? C + 1 : C , true ) ; ValidProtocol = LWText :: Compare ( C , m_SubProtocol , ProtocolLen ) ; } } if ( ! ValidProtocol ) Error = 3 ; } if ( Error ) { std :: cout << " Buffer : " << std :: endl << Buffer << std :: endl ; if ( Error == 1 ) std :: cout << " Error ▁ deserializing ▁ websocket ▁ request . " << std :: endl ; else if ( Error == 2 ) std :: cout << " Error ▁ Headers ▁ did ▁ not ▁ include ▁ correct ▁ websocket ▁ data . " << std :: endl ; else if ( Error == 3 ) std :: cout << " Error ▁ protocol ▁ asked ▁ for ▁ is ▁ not ▁ supported . " << std :: endl ; Socket . MarkClosable ( ) ; return false ; } WebSocket = m_Allocator . Allocate < LWEWebSocket > ( nullptr , nullptr ) ; WebSocket -> m_Socket = & Socket ; * Buf = ' \0' ; strncat ( Buf , Request . m_SecWebSockKey , sizeof ( Buf ) ) ; strncat ( Buf , LWEWEBSOCKET_GUID , sizeof ( Buf ) ) ; LWCrypto :: HashSHA1 ( Buf , ( uint32_t ) strlen ( Buf ) , BufB ) ; uint32_t * uBuf = ( uint32_t * ) BufB ; for ( uint32_t i = 0 ; i < 5 ; i ++ ) uBuf [ i ] = ( uBuf [ i ] & 0xFF ) << 24 | ( uBuf [ i ] & 0xFF00 ) << 8 | ( uBuf [ i ] & 0xFF0000 ) >> 8 | ( uBuf [ i ] & 0xFF000000 ) >> 24 ; uint32_t Len = LWCrypto :: Base64Encode ( BufB , 20 , WebSocket -> m_SecKey , sizeof ( WebSocket -> m_SecKey ) ) ; WebSocket -> m_SecKey [ Len ] = ' \0' ; WebSocket -> SetSecProtocols ( m_SubProtocol ) ; WebSocket -> SetHost ( Request . m_Host ) ; WebSocket -> SetPath ( Request . m_Path ) ; WebSocket -> SetOrigin ( Request . m_Origin ) ; WebSocket -> m_Flag |= LWEWebSocket :: CONNECTING_SERVER ; Socket . SetProtocolData ( m_wProtocolID , WebSocket ) ; PushOutPacket ( nullptr , 0 , WebSocket , LWEWebPacket :: CONTROL_CONNECT ) ; return true ; } if ( ! WebSocket -> IsConnected ( ) ) { if ( WebSocket -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_CLIENT ) { LWEHttpRequest Request ; uint32_t Error = 0 ; Error = Request . Deserialize ( Buffer , BufferLen ) ? 0 : 1 ; Error = Error ? Error : ( ( * Request . m_SecWebSockKey && Request . m_Status == LWEHttpRequest :: SwitchingProtocols ) ? 0 : 2 ) ; if ( Error ) { std :: cout << " Buffer : " << std :: endl << Buffer << std :: endl ; if ( Error == 1 ) std :: cout << " Error ▁ deserializing ▁ websocket ▁ request . " << std :: endl ; else if ( Error == 2 ) std :: cout << " Error ▁ headers ▁ did ▁ not ▁ include ▁ correct ▁ websocket ▁ data . " << std :: endl ; Socket . MarkClosable ( ) ; return false ; } WebSocket -> m_Flag = ( WebSocket -> m_Flag & ~ LWEWebSocket :: CONNECTING_CLIENT ) | LWEWebSocket :: CONNECTED_CLIENT ; } return true ; } char IPBuf [ 32 ] ; LWSocket :: MakeAddress ( Socket . GetRemoteIP ( ) , IPBuf , sizeof ( IPBuf ) ) ; if ( BufferLen > 100 ) { } LWEWebPacket * OPack ; uint32_t Target ; uint32_t ReservePos ; uint32_t o = 0 ; while ( o != BufferLen ) { uint32_t Res = WebSocket -> m_ActivePacket . Deserialize ( Buffer + o , BufferLen - o , m_Allocator ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ deserializing ▁ data . " << std :: endl ; return false ; } o += Res ; if ( ! WebSocket -> m_ActivePacket . Finished ( ) ) continue ; if ( WebSocket -> m_ActivePacket . m_DataLen != WebSocket -> m_ActivePacket . m_DataPos ) continue ; if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_CLOSED ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; Socket . MarkClosable ( ) ; return true ; } else if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_PING ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; PushOutPacket ( nullptr , 0 , WebSocket , LWEWebPacket :: CONTROL_PONG ) ; continue ; } else if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_PONG ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; continue ; } WebSocket -> m_ActivePacket . m_WebSocket = WebSocket ; if ( ! m_InPackets . PushStart ( & OPack , Target , ReservePos ) ) return false ; * OPack = std :: move ( WebSocket -> m_ActivePacket ) ; m_InPackets . PushFinished ( Target , ReservePos ) ; } return true ; } LWProtocol & LWEProtocolWebSocketSecure :: SocketClosed ( LWSocket & Socket , LWProtocolManager * Manager ) { LWEProtocolTLS :: SocketClosed ( Socket , Manager ) ; LWEWebSocket * WebSock = ( LWEWebSocket * ) Socket . GetProtocolData ( m_wProtocolID ) ; bool Del = true ; if ( m_WebSocketClosedCallback ) Del = m_WebSocketClosedCallback ( Socket , WebSock , Manager ) ; if ( WebSock ) WebSock -> m_Socket = nullptr ; if ( Del ) LWAllocator :: Destroy ( WebSock ) ; return * this ; } LWProtocol & LWEProtocolWebSocketSecure :: SocketChanged ( LWSocket & Prev , LWSocket & New , LWProtocolManager * Manager ) { LWEProtocolTLS :: SocketChanged ( Prev , New , Manager ) ; LWEWebSocket * WebSocket = ( LWEWebSocket * ) Prev . GetProtocolData ( m_wProtocolID ) ; New . SetProtocolData ( m_wProtocolID , Prev . GetProtocolData ( m_wProtocolID ) ) ; if ( WebSocket ) WebSocket -> m_Socket = & New ; if ( m_WebSocketChangedCallback ) m_WebSocketChangedCallback ( Prev , New , WebSocket , Manager ) ; return * this ; } LWProtocol & LWEProtocolWebSocketSecure :: ProcessTLSData ( LWSocket & Socket , const char * Data , uint32_t DataLen ) { ProcessRead ( Socket , Data , DataLen ) ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: ProcessOutPackets ( void ) { char Buffer [ 1024 * 64 ] ; LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; while ( m_OutPackets . PopStart ( & Pack , Target , ReservePos ) ) { LWEWebPacket RPack = std :: move ( * Pack ) ; m_OutPackets . PopFinshed ( Target , ReservePos ) ; LWEWebSocket * Sock = RPack . m_WebSocket ; if ( ! Sock -> IsConnected ( ) && ( RPack . m_ControlFlag & LWEWebPacket :: CONTROL_CONNECT ) ) { if ( ! Sock -> m_Socket ) return * this ; LWEHttpRequest Request ; Request . SetWebSockKey ( Sock -> m_SecKey ) ; Request . SetWebSockProto ( m_SubProtocol ) ; Request . m_Flag |= LWEHttpRequest :: ConnectionUpgrade | LWEHttpRequest :: UpgradeWebSock ; Request . m_Status = Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_SERVER ? LWEHttpRequest :: SwitchingProtocols : 0 ; if ( Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_CLIENT ) { Request . SetHost ( Sock -> m_Host ) . SetPath ( Sock -> m_Path ) . SetOrigin ( Sock -> m_Origin ) ; Request . m_WebSockVersion = LWEWEBSOCKET_SUPPVER ; } else Sock -> m_Flag = ( Sock -> m_Flag & ~ LWEWebSocket :: CONNECTING_SERVER ) | LWEWebSocket :: CONNECTED_SERVER ; uint32_t Len = Request . Serialize ( Buffer , sizeof ( Buffer ) , Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_CLIENT ? m_UserAgent : m_Server ) ; std :: cout << " Sending ▁ headers ! " << std :: endl ; uint32_t Res = Send ( * Sock -> m_Socket , Buffer , Len ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ sending ▁ data . " << std :: endl ; return * this ; } if ( ! Res ) { if ( Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_SERVER ) Sock -> m_Flag = ( Sock -> m_Flag & ~ LWEWebSocket :: CONNECTING_SERVER ) | LWEWebSocket :: CONNECTING_SERVER ; PushOutPacket ( nullptr , 0 , Sock , LWEWebPacket :: CONTROL_CONNECT ) ; return * this ; } } if ( RPack . m_ControlFlag & LWEWebPacket :: CONTROL_CONNECT ) continue ; if ( ! Sock -> IsConnected ( ) ) { if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) { std :: cout << " Error ▁ re - inserting ▁ packet . " << std :: endl ; return * this ; } * Pack = std :: move ( RPack ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; return * this ; } std :: cout << " Sending ▁ data : ▁ " << RPack . GetOp ( ) << " ▁ Len : ▁ " << RPack . m_DataLen << " ▁ Fin : ▁ " << RPack . m_ControlFlag << std :: endl ; LWSocket * rSock = RPack . m_WebSocket -> m_Socket ; if ( ! rSock ) continue ; uint32_t Len = RPack . Serialize ( Buffer , sizeof ( Buffer ) , Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_CLIENT ) ; std :: cout << " Serialized : ▁ " << Len << std :: endl ; uint32_t Res = Send ( * rSock , Buffer , Len ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ sending ▁ data . " << std :: endl ; return * this ; } if ( ! Res ) { if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) { std :: cout << " Error ▁ re - inserting ▁ packet . " << std :: endl ; return * this ; } * Pack = std :: move ( RPack ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; } } return * this ; } LWEWebSocket * LWEProtocolWebSocketSecure :: OpenSocket ( const char * URI , uint32_t ProtocolID , const char * Origin ) { char Host [ 256 ] ; char Path [ 256 ] ; char Protocol [ 256 ] ; uint16_t Port = LWEHttpRequest :: ParseURI ( URI , Host , sizeof ( Host ) , nullptr , Path , sizeof ( Path ) , nullptr , Protocol , sizeof ( Protocol ) , nullptr ) ; LWSocket Sock ; uint32_t Err = LWSocket :: CreateSocket ( Sock , Host , Port , LWSocket :: Tcp , ProtocolID ) ; if ( Err ) { std :: cout << " Error ▁ creating ▁ socket : ▁ " << Err << std :: endl ; return nullptr ; } LWSocket * S = m_Manager -> PushSocket ( Sock ) ; LWEWebSocket * WebSock = m_Allocator . Allocate < LWEWebSocket > ( URI , Origin ) ; WebSock -> m_Flag |= LWEWebSocket :: CONNECTING_CLIENT ; WebSock -> GenerateKey ( m_KeySeed ++ ) ; S -> SetProtocolData ( m_wProtocolID , WebSock ) ; WebSock -> m_Socket = S ; PushOutPacket ( nullptr , 0 , WebSock , LWEWebPacket :: CONTROL_CONNECT ) ; return WebSock ; } bool LWEProtocolWebSocketSecure :: PushOutPacket ( const char * Buffer , uint32_t BufferLen , LWEWebSocket * Socket , uint32_t ControlFlag ) { LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) return false ; * Pack = LWEWebPacket ( Buffer , BufferLen , m_Allocator , ControlFlag | LWEWebPacket :: CONTROL_FINISHED , Socket ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; return true ; } bool LWEProtocolWebSocketSecure :: GetNextPacket ( LWEWebPacket & Packet ) { LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; if ( ! m_InPackets . PopStart ( & Pack , Target , ReservePos ) ) return false ; Packet = std :: move ( * Pack ) ; m_InPackets . PopFinshed ( Target , ReservePos ) ; return true ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetServer ( const char * Server ) { * m_Server = ' \0' ; strncat ( m_Server , Server , sizeof ( m_Server ) ) ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetUserAgent ( const char * Agent ) { * m_UserAgent = ' \0' ; strncat ( m_UserAgent , Agent , sizeof ( m_UserAgent ) ) ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetSubProtocol ( const char * SubProtocol ) { * m_SubProtocol = ' \0' ; strncat ( m_SubProtocol , SubProtocol , sizeof ( m_SubProtocol ) ) ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetWebSocketClosedCallback ( std :: function < bool ( LWSocket & , LWEWebSocket * , LWProtocolManager * ) > WebSocketClosedCallback ) { m_WebSocketClosedCallback = WebSocketClosedCallback ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetWebSocketChangedCallback ( std :: function < void ( LWSocket & , LWSocket & , LWEWebSocket * , LWProtocolManager * ) > WebSocketChangedCallback ) { m_WebSocketChangedCallback = WebSocketChangedCallback ; return * this ; } LWEProtocolWebSocketSecure :: LWEProtocolWebSocketSecure ( uint32_t ProtocolID , uint32_t TLSProtocolID , LWAllocator & Allocator , LWProtocolManager * Manager , const char * CertFile , const char * KeyFile ) : LWEProtocolTLS ( TLSProtocolID , Allocator , CertFile , KeyFile ) , m_wProtocolID ( ProtocolID ) , m_Allocator ( Allocator ) , m_Manager ( Manager ) , m_KeySeed ( 0 ) { * m_Server = * m_UserAgent = * m_SubProtocol = ' \0' ; m_WebSocketClosedCallback = nullptr ; m_WebSocketChangedCallback = nullptr ; } </DOCUMENT>
<DOCUMENT_ID="ChameleonOS/android_external_skia/tree/master/tests/PathOpsAngleTest.cpp"> # include " PathOpsTestCommon . h " # include " SkOpSegment . h " # include " SkTArray . h " # include " Test . h " static const SkPoint cubics [ ] [ 4 ] = { { { 0 , 1 } , { 2 , 6 } , { 4 , 2 } , { 5 , 3 } } , { { 10 , 234 } , { 10 , 229.581726f } , { 13.5817204f , 226 } , { 18 , 226 } } , { { 132 , 11419 } , { 130.89543151855469f , 11419 } , { 130 , 11418.1044921875f } , { 130 , 11417 } } , { { 130.04275512695312f , 11417.4130859375f } , { 130.23307800292969f , 11418.3193359375f } , { 131.03709411621094f , 11419 } , { 132 , 11419 } } , { { 0 , 1 } , { 0 , 5 } , { 4 , 1 } , { 6 , 4 } } , { { 1 , 5 } , { 4 , 6 } , { 1 , 0 } , { 4 , 0 } } , { { 0 , 1 } , { 0 , 4 } , { 5 , 1 } , { 6 , 4 } } , { { 0 , 1 } , { 1 , 2 } , { 1 , 0 } , { 6 , 1 } } , { { 0 , 3 } , { 0 , 1 } , { 2 , 0 } , { 1 , 0 } } , { { 189 , 7 } , { 189 , 5.3431458473205566f } , { 190.3431396484375f , 4 } , { 192 , 4 } } , { { 0 , 1 } , { 1 , 3 } , { 1 , 0 } , { 6 , 4 } } , { { 0 , 1 } , { 2 , 3 } , { 2 , 1 } , { 4 , 3 } } , { { 1 , 2 } , { 3 , 4 } , { 1 , 0 } , { 3 , 2 } } , { { 0 , 1 } , { 4 , 6 } , { 4 , 3 } , { 5 , 4 } } , { { 806 , 11419 } , { 806.962890625f , 11419 } , { 807.76690673828125f , 11418.3193359375f } , { 807.957275390625f , 11417.4130859375f } } , { { 808 , 11417 } , { 808 , 11418.1044921875f } , { 807.10455322265625f , 11419 } , { 806 , 11419 } } , { { 132 , 11419 } , { 130.89543151855469f , 11419 } , { 130 , 11418.1044921875f } , { 130 , 11417 } } , { { 130.04275512695312f , 11417.4130859375f } , { 130.23312377929687f , 11418.3193359375f } , { 131.03707885742187f , 11419 } , { 132 , 11419 } } , { { 1006.6951293945312f , 291 } , { 1023.263671875f , 291 } , { 1033.8402099609375f , 304.43145751953125f } , { 1030.318359375f , 321 } } , } ; static const SkPoint quads [ ] [ 3 ] = { { { 12.3423996f , 228.342407f } , { 10 , 230.686295f } , { 10 , 234 } } , { { 304.24319458007812f , 591.75677490234375f } , { 306 , 593.51470947265625f } , { 306 , 596 } } , { { 0 , 0 } , { 3 , 1 } , { 0 , 3 } } , { { 0 , 1 } , { 3 , 1 } , { 0 , 2 } } , } ; static const SkPoint lines [ ] [ 2 ] = { { { 6 , 2 } , { 2 , 4 } } , { { 306 , 617 } , { 306 , 590 } } , { { 306 , 596 } , { 306 , 617 } } , { { 6 , 4 } , { 0 , 1 } } , { { 6 , 1 } , { 0 , 1 } } , { { 1 , 0 } , { 0 , 3 } } , { { 246 , 4 } , { 189 , 4 } } , { { 192 , 4 } , { 243 , 4 } } , { { 4 , 3 } , { 0 , 1 } } , { { 3 , 2 } , { 1 , 2 } } , { { 6 , 4 } , { 3 , 4 } } , { { 979.30487060546875f , 561 } , { 1036.695068359375f , 291 } } , } ; struct SortSet { const SkPoint * ptData ; int ptCount ; double tStart ; double tEnd ; SkPoint endPt ; } ; static const SortSet set1 [ ] = { { cubics [ 0 ] , 4 , 0.66666987081928919 , 0.875 , { 0 , 0 } } , { lines [ 0 ] , 2 , 0.574070336 , 0.388888889 , { 0 , 0 } } , { cubics [ 0 ] , 4 , 0.66666987081928919 , 0.4050371120499307 , { 0 , 0 } } , { lines [ 0 ] , 2 , 0.574070336 , 0.9140625 , { 0 , 0 } } , } ; static const SortSet set1a [ ] = { { cubics [ 0 ] , 4 , 0.666666667 , 0.405037112 , { 4.58007812f , 2.83203125f } } , { lines [ 0 ] , 2 , 0.574074074 , 0.9140625 , { 4.44444466f , 2.77777767f } } , } ; static const SortSet set2 [ ] = { { cubics [ 0 ] , 4 , 0.666666667 , 0.875 , { 0 , 0 } } , { lines [ 0 ] , 2 , 0.574074074 , 0.388888889 , { 0 , 0 } } , { cubics [ 0 ] , 4 , 0.666666667 , 0.405037112 , { 0 , 0 } } , { lines [ 0 ] , 2 , 0.574074074 , 0.9140625 , { 0 , 0 } } , } ; static const SortSet set3 [ ] = { { cubics [ 1 ] , 4 , 0 , 1 , { 0 , 0 } } , { quads [ 0 ] , 3 , 1 , 0 , { 0 , 0 } } , } ; static const SortSet set4 [ ] = { { cubics [ 2 ] , 4 , 0.812114222 , 1 , { 0 , 0 } } , { cubics [ 3 ] , 4 , 0.0684734759 , 0 , { 0 , 0 } } , } ; static const SortSet set5 [ ] = { { lines [ 1 ] , 2 , 0.777777778 , 1 , { 0 , 0 } } , { quads [ 1 ] , 3 , 1 , 4.34137342e - 06 , { 0 , 0 } } , { lines [ 2 ] , 2 , 0 , 1 , { 0 , 0 } } , } ; static const SortSet set5a [ ] = { { lines [ 1 ] , 2 , 0.777777778 , 1 , { 306 , 590 } } , { quads [ 1 ] , 3 , 1 , 4.34137342e - 06 , { 304.243195f , 591.756775f } } , { lines [ 2 ] , 2 , 0 , 1 , { 306 , 617 } } , } ; static const SortSet set6 [ ] = { { lines [ 3 ] , 2 , 0.407407407 , 0.554627832 , { 0 , 0 } } , { cubics [ 4 ] , 4 , 0.666666667 , 0.548022446 , { 0 , 0 } } , { lines [ 3 ] , 2 , 0.407407407 , 0 , { 0 , 0 } } , { cubics [ 4 ] , 4 , 0.666666667 , 1 , { 0 , 0 } } , } ; static const SortSet set6a [ ] = { { lines [ 3 ] , 2 , 0.407407407 , 0.554627832 , { 2.6722331f , 2.33611655f } } , { cubics [ 4 ] , 4 , 0.666666667 , 0.548022446 , { 2.61642241f , 2.83718514f } } , { lines [ 3 ] , 2 , 0.407407407 , 0 , { 6 , 4 } } , { cubics [ 4 ] , 4 , 0.666666667 , 1 , { 6 , 4 } } , } ; static const SortSet set7 [ ] = { { cubics [ 5 ] , 4 , 0.545233342 , 0.545454545 , { 0 , 0 } } , { cubics [ 6 ] , 4 , 0.484938134 , 0.484805744 , { 0 , 0 } } , { cubics [ 5 ] , 4 , 0.545233342 , 0 , { 0 , 0 } } , { cubics [ 6 ] , 4 , 0.484938134 , 0.545454545 , { 0 , 0 } } , } ; static const SortSet set8 [ ] = { { cubics [ 7 ] , 4 , 0.5 , 0.522986744 , { 0 , 0 } } , { lines [ 4 ] , 2 , 0.75 , 1 , { 0 , 0 } } , { cubics [ 7 ] , 4 , 0.5 , 0 , { 0 , 0 } } , { lines [ 4 ] , 2 , 0.75 , 0.737654321 , { 0 , 0 } } , } ; static const SortSet set8a [ ] = { { cubics [ 7 ] , 4 , 0.5 , 0.522986744 , { 1.60668361f , 0.965592742f } } , { lines [ 4 ] , 2 , 0.75 , 1 , { 0 , 1 } } , { cubics [ 7 ] , 4 , 0.5 , 0 , { 0 , 1 } } , { lines [ 4 ] , 2 , 0.75 , 0.737654321 , { 1.57407403f , 1 } } , } ; static const SortSet set9 [ ] = { { cubics [ 8 ] , 4 , 0.4 , 1 , { 0 , 0 } } , { lines [ 5 ] , 2 , 0.36 , 0 , { 0 , 0 } } , { cubics [ 8 ] , 4 , 0.4 , 0.394675838 , { 0 , 0 } } , { lines [ 5 ] , 2 , 0.36 , 0.363999782 , { 0 , 0 } } , } ; static const SortSet set10 [ ] = { { lines [ 6 ] , 2 , 0.947368421 , 1 , { 0 , 0 } } , { cubics [ 9 ] , 4 , 1 , 0.500000357 , { 0 , 0 } } , { lines [ 7 ] , 2 , 0 , 1 , { 0 , 0 } } , } ; static const SortSet set11 [ ] = { { lines [ 3 ] , 2 , 0.75 , 1 , { 0 , 0 } } , { cubics [ 10 ] , 4 , 0.5 , 0.228744269 , { 0 , 0 } } , { lines [ 3 ] , 2 , 0.75 , 0.627112191 , { 0 , 0 } } , { cubics [ 10 ] , 4 , 0.5 , 0.6339746 , { 0 , 0 } } , } ; static const SortSet set12 [ ] = { { cubics [ 12 ] , 4 , 0.5 , 1 , { 0 , 0 } } , { lines [ 8 ] , 2 , 0.5 , 1 , { 0 , 0 } } , { cubics [ 11 ] , 4 , 0.5 , 0 , { 0 , 0 } } , { lines [ 9 ] , 2 , 0.5 , 1 , { 0 , 0 } } , { cubics [ 12 ] , 4 , 0.5 , 0 , { 0 , 0 } } , { lines [ 8 ] , 2 , 0.5 , 0 , { 0 , 0 } } , { cubics [ 11 ] , 4 , 0.5 , 1 , { 0 , 0 } } , { lines [ 9 ] , 2 , 0.5 , 0 , { 0 , 0 } } , } ; static const SortSet set13 [ ] = { { cubics [ 13 ] , 4 , 0.5 , 0.400631046 , { 0 , 0 } } , { lines [ 10 ] , 2 , 0.791666667 , 0.928 , { 0 , 0 } } , { lines [ 10 ] , 2 , 0.791666667 , 0.333333333 , { 0 , 0 } } , { cubics [ 13 ] , 4 , 0.5 , 0.866666667 , { 0 , 0 } } , } ; static const SortSet set14 [ ] = { { quads [ 2 ] , 3 , 0.5 , 0.310102051 , { 0 , 0 } } , { quads [ 3 ] , 3 , 0.5 , 0.2 , { 0 , 0 } } , { quads [ 3 ] , 3 , 0.5 , 0.770156212 , { 0 , 0 } } , { quads [ 2 ] , 3 , 0.5 , 0.7 , { 0 , 0 } } , } ; static const SortSet set15 [ ] = { { cubics [ 14 ] , 4 , 0.93081374 , 1 , { 0 , 0 } } , { cubics [ 15 ] , 4 , 0.188518131 , 0 , { 0 , 0 } } , { cubics [ 14 ] , 4 , 0.93081374 , 0 , { 0 , 0 } } , } ; static const SortSet set16 [ ] = { { cubics [ 17 ] , 4 , 0.0682619216 , 0 , { 130.042755f , 11417.4131f } } , { cubics [ 16 ] , 4 , 0.812302088 , 1 , { 130 , 11417 } } , { cubics [ 17 ] , 4 , 0.0682619216 , 1 , { 132 , 11419 } } , } ; static const SortSet set17 [ ] = { { lines [ 11 ] , 2 , 0.888889581 , 1 , { 0 , 0 } } , { cubics [ 18 ] , 4 , 0.999996241 , 0 , { 0 , 0 } } , { lines [ 11 ] , 2 , 0.888889581 , 0 , { 0 , 0 } } , { cubics [ 18 ] , 4 , 0.999996241 , 1 , { 0 , 0 } } , } ; struct SortSetTests { const char * name ; const SortSet * set ; size_t count ; SkPoint startPt ; } ; # define TEST_ENTRY ( name ) # name , name , SK_ARRAY_COUNT ( name ) static const SortSetTests tests [ ] = { { TEST_ENTRY ( set17 ) , { 0 , 0 } } , { TEST_ENTRY ( set16 ) , { 130.090179f , 11417.5957f } } , { TEST_ENTRY ( set14 ) , { 0 , 0 } } , { TEST_ENTRY ( set13 ) , { 0 , 0 } } , { TEST_ENTRY ( set12 ) , { 0 , 0 } } , { TEST_ENTRY ( set11 ) , { 0 , 0 } } , { TEST_ENTRY ( set10 ) , { 0 , 0 } } , { TEST_ENTRY ( set9 ) , { 0 , 0 } } , { TEST_ENTRY ( set6a ) , { 3.55555558f , 2.77777767f } } , { TEST_ENTRY ( set8a ) , { 1.5f , 1 } } , { TEST_ENTRY ( set8 ) , { 0 , 0 } } , { TEST_ENTRY ( set7 ) , { 0 , 0 } } , { TEST_ENTRY ( set6a ) , { 3.55555558f , 2.77777767f } } , { TEST_ENTRY ( set6 ) , { 0 , 0 } } , { TEST_ENTRY ( set5a ) , { 306 , 596 } } , { TEST_ENTRY ( set5 ) , { 0 , 0 } } , { TEST_ENTRY ( set3 ) , { 0 , 0 } } , { TEST_ENTRY ( set2 ) , { 0 , 0 } } , { TEST_ENTRY ( set1 ) , { 0 , 0 } } , } ; # undef TEST_ENTRY static void setup ( const SortSet * set , const size_t idx , SkOpSegment * seg , int * ts , const SkPoint & startPt ) { SkPoint start , end ; const SkPoint * data = set [ idx ] . ptData ; bool useIntersectPt = startPt . fX != 0 || startPt . fY != 0 ; if ( useIntersectPt ) { start = startPt ; end = set [ idx ] . endPt ; } switch ( set [ idx ] . ptCount ) { case 2 : { SkASSERT ( ValidPoints ( data , 2 ) ) ; seg -> addLine ( data , false , false ) ; SkDLine dLine ; dLine . set ( set [ idx ] . ptData ) ; SkASSERT ( ValidLine ( dLine ) ) ; if ( useIntersectPt ) { break ; } start = dLine . ptAtT ( set [ idx ] . tStart ) . asSkPoint ( ) ; end = dLine . ptAtT ( set [ idx ] . tEnd ) . asSkPoint ( ) ; } break ; case 3 : { SkASSERT ( ValidPoints ( data , 3 ) ) ; seg -> addQuad ( data , false , false ) ; SkDQuad dQuad ; dQuad . set ( set [ idx ] . ptData ) ; SkASSERT ( ValidQuad ( dQuad ) ) ; if ( useIntersectPt ) { break ; } start = dQuad . ptAtT ( set [ idx ] . tStart ) . asSkPoint ( ) ; end = dQuad . ptAtT ( set [ idx ] . tEnd ) . asSkPoint ( ) ; } break ; case 4 : { SkASSERT ( ValidPoints ( data , 4 ) ) ; seg -> addCubic ( data , false , false ) ; SkDCubic dCubic ; dCubic . set ( set [ idx ] . ptData ) ; SkASSERT ( ValidCubic ( dCubic ) ) ; if ( useIntersectPt ) { break ; } start = dCubic . ptAtT ( set [ idx ] . tStart ) . asSkPoint ( ) ; end = dCubic . ptAtT ( set [ idx ] . tEnd ) . asSkPoint ( ) ; } break ; } double tStart = set [ idx ] . tStart ; double tEnd = set [ idx ] . tEnd ; seg -> addT ( NULL , start , tStart ) ; seg -> addT ( NULL , end , tEnd ) ; if ( tStart != 0 && tEnd != 0 ) { seg -> addT ( NULL , set [ idx ] . ptData [ 0 ] , 0 ) ; } if ( tStart != 1 && tEnd != 1 ) { seg -> addT ( NULL , set [ idx ] . ptData [ set [ idx ] . ptCount - 1 ] , 1 ) ; } int tIndex = 0 ; ts [ 0 ] = 0 ; ts [ 1 ] = 1 ; do { if ( seg -> t ( tIndex ) == set [ idx ] . tStart ) { ts [ 0 ] = tIndex ; } if ( seg -> t ( tIndex ) == set [ idx ] . tEnd ) { ts [ 1 ] = tIndex ; } if ( seg -> t ( tIndex ) >= 1 ) { break ; } } while ( ++ tIndex ) ; } static void testOne ( skiatest :: Reporter * reporter , const SortSetTests & test ) { SkTDArray < SkOpAngle > angles ; bool unsortable = false ; bool unorderable = false ; SkTArray < SkOpSegment > segs ; for ( size_t idx = 0 ; idx < test . count ; ++ idx ) { int ts [ 2 ] ; const SortSet * set = test . set ; SkOpSegment & seg = segs . push_back ( ) ; setup ( set , idx , & seg , ts , test . startPt ) ; SkOpAngle * angle = angles . append ( ) ; angle -> set ( & seg , ts [ 0 ] , ts [ 1 ] ) ; # if DEBUG_ANGLE angle -> setID ( idx ) ; # endif if ( angle -> unsortable ( ) ) { # if DEBUG_ANGLE SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ angle [ % d ] ▁ unsortable \n " , __FUNCTION__ , test . name , idx ) ; # endif unsortable = true ; } if ( angle -> unorderable ( ) ) { # if DEBUG_ANGLE SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ angle [ % d ] ▁ unorderable \n " , __FUNCTION__ , test . name , idx ) ; # endif unorderable = true ; } reporter -> bumpTestCount ( ) ; } if ( unsortable || unorderable ) { return ; } # if DEBUG_ANGLE SkDebugf ( " % s ▁ test [ % s ] \n " , __FUNCTION__ , test . name ) ; # endif for ( size_t idxL = 0 ; idxL < test . count ; ++ idxL ) { const SkOpAngle & first = angles [ idxL ] ; for ( size_t idxG = 0 ; idxG < test . count ; ++ idxG ) { if ( idxL == idxG ) { continue ; } const SkOpAngle & second = angles [ idxG ] ; bool compare = first < second ; if ( idxL < idxG ) { if ( ! compare ) { SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ first [ % d ] ▁ > ▁ second [ % d ] \n " , __FUNCTION__ , test . name , idxL , idxG ) ; compare = first < second ; } REPORTER_ASSERT ( reporter , compare ) ; } else { SkASSERT ( idxL > idxG ) ; if ( compare ) { SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ first [ % d ] ▁ < ▁ second [ % d ] \n " , __FUNCTION__ , test . name , idxL , idxG ) ; compare = first < second ; } REPORTER_ASSERT ( reporter , ! compare ) ; } compare = second < first ; if ( idxL < idxG ) { if ( compare ) { SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ second [ % d ] ▁ < ▁ first [ % d ] \n " , __FUNCTION__ , test . name , idxL , idxG ) ; compare = second < first ; } REPORTER_ASSERT ( reporter , ! compare ) ; } else { SkASSERT ( idxL > idxG ) ; if ( ! compare ) { SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ second [ % d ] ▁ > ▁ first [ % d ] \n " , __FUNCTION__ , test . name , idxL , idxG ) ; compare = second < first ; } REPORTER_ASSERT ( reporter , compare ) ; } } } } static void PathOpsAngleTest ( skiatest :: Reporter * reporter ) { for ( size_t index = 0 ; index < SK_ARRAY_COUNT ( tests ) ; ++ index ) { const SortSetTests & test = tests [ index ] ; testOne ( reporter , test ) ; reporter -> bumpTestCount ( ) ; } } static void PathOpsAngleTestOne ( skiatest :: Reporter * reporter ) { size_t index = 0 ; const SortSetTests & test = tests [ index ] ; testOne ( reporter , test ) ; } # if 0 static int find_slop ( double x , double y , double rx , double ry ) { int slopBits = 0 ; bool less1 , less2 ; double absX = fabs ( x ) ; double absY = fabs ( y ) ; double length = absX < absY ? absX / 2 + absY : absX + absY / 2 ; int exponent ; ( void ) frexp ( length , & exponent ) ; double epsilon = ldexp ( FLT_EPSILON , exponent ) ; do { double xSlop = epsilon * slopBits ; double ySlop = x * y < 0 ? - xSlop : xSlop ; double x1 = x - xSlop ; double y1 = y + ySlop ; double x_ry1 = x1 * ry ; double rx_y1 = rx * y1 ; less1 = x_ry1 < rx_y1 ; double x2 = x + xSlop ; double y2 = y - ySlop ; double x_ry2 = x2 * ry ; double rx_y2 = rx * y2 ; less2 = x_ry2 < rx_y2 ; } while ( less1 == less2 && ++ slopBits ) ; return slopBits ; } static double diamond_angle ( double y , double x ) { if ( y >= 0 ) return ( x >= 0 ? y / ( x + y ) : 1 - x / ( - x + y ) ) ; else return ( x < 0 ? 2 - y / ( - x - y ) : 3 + x / ( x - y ) ) ; } static const double slopTests [ ] [ 4 ] = { { - 0.058554756452593892 , - 0.18804585843827226 , - 0.018568569646021160 , - 0.059615294434479438 } , { - 0.0013717412948608398 , 0.0041152238845825195 , - 0.00045837944195925573 , 0.0013753175735478074 } , { - 2.1033774145221198 , - 1.4046019261273715e - 008 , - 0.70062688352066704 , - 1.2706324683777995e - 008 } , } ; static void PathOpsAngleFindSlop ( skiatest :: Reporter * reporter ) { for ( size_t index = 0 ; index < SK_ARRAY_COUNT ( slopTests ) ; ++ index ) { const double * slopTest = slopTests [ index ] ; double x = slopTest [ 0 ] ; double y = slopTest [ 1 ] ; double rx = slopTest [ 2 ] ; double ry = slopTest [ 3 ] ; SkDebugf ( " % s ▁ ▁ xy ▁ % d = % d \n " , __FUNCTION__ , ( int ) index , find_slop ( x , y , rx , ry ) ) ; SkDebugf ( " % s ▁ rxy ▁ % d = % d \n " , __FUNCTION__ , ( int ) index , find_slop ( rx , ry , x , y ) ) ; double angle = diamond_angle ( y , x ) ; double rAngle = diamond_angle ( ry , rx ) ; double diff = fabs ( angle - rAngle ) ; SkDebugf ( " % s ▁ diamond ▁ xy = % 1.9g ▁ rxy = % 1.9g ▁ diff = % 1.9g ▁ factor = % d \n " , __FUNCTION__ , angle , rAngle , diff , ( int ) ( diff / FLT_EPSILON ) ) ; } } # endif # include " TestClassDef . h " DEFINE_TESTCLASS_SHORT ( PathOpsAngleTest ) DEFINE_TESTCLASS_SHORT ( PathOpsAngleTestOne ) </DOCUMENT>
<DOCUMENT_ID="mapmapteam/mapmap/tree/master/src/gui/contrib/qtpropertybrowser/src/qtpropertybrowserutils.cpp"> # include " qtpropertybrowserutils _ p . h " # include < QApplication > # include < QPainter > # include < QHBoxLayout > # include < QMouseEvent > # include < QCheckBox > # include < QLineEdit > # include < QMenu > # include < QStyleOption > # if QT_VERSION >= 0x040400 QT_BEGIN_NAMESPACE # endif QtCursorDatabase :: QtCursorDatabase ( ) { appendCursor ( Qt :: ArrowCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Arrow " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - arrow . png " ) ) ) ; appendCursor ( Qt :: UpArrowCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Up ▁ Arrow " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - uparrow . png " ) ) ) ; appendCursor ( Qt :: CrossCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Cross " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - cross . png " ) ) ) ; appendCursor ( Qt :: WaitCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Wait " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - wait . png " ) ) ) ; appendCursor ( Qt :: IBeamCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " IBeam " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - ibeam . png " ) ) ) ; appendCursor ( Qt :: SizeVerCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Vertical " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizev . png " ) ) ) ; appendCursor ( Qt :: SizeHorCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Horizontal " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeh . png " ) ) ) ; appendCursor ( Qt :: SizeFDiagCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Backslash " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizef . png " ) ) ) ; appendCursor ( Qt :: SizeBDiagCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Slash " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeb . png " ) ) ) ; appendCursor ( Qt :: SizeAllCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ All " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeall . png " ) ) ) ; appendCursor ( Qt :: BlankCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Blank " ) , QIcon ( ) ) ; appendCursor ( Qt :: SplitVCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Split ▁ Vertical " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - vsplit . png " ) ) ) ; appendCursor ( Qt :: SplitHCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Split ▁ Horizontal " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - hsplit . png " ) ) ) ; appendCursor ( Qt :: PointingHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Pointing ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - hand . png " ) ) ) ; appendCursor ( Qt :: ForbiddenCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Forbidden " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - forbidden . png " ) ) ) ; appendCursor ( Qt :: OpenHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Open ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - openhand . png " ) ) ) ; appendCursor ( Qt :: ClosedHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Closed ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - closedhand . png " ) ) ) ; appendCursor ( Qt :: WhatsThisCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " What ' s ▁ This " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - whatsthis . png " ) ) ) ; appendCursor ( Qt :: BusyCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Busy " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - busy . png " ) ) ) ; } void QtCursorDatabase :: clear ( ) { m_cursorNames . clear ( ) ; m_cursorIcons . clear ( ) ; m_valueToCursorShape . clear ( ) ; m_cursorShapeToValue . clear ( ) ; } void QtCursorDatabase :: appendCursor ( Qt :: CursorShape shape , const QString & name , const QIcon & icon ) { if ( m_cursorShapeToValue . contains ( shape ) ) return ; const int value = m_cursorNames . count ( ) ; m_cursorNames . append ( name ) ; m_cursorIcons . insert ( value , icon ) ; m_valueToCursorShape . insert ( value , shape ) ; m_cursorShapeToValue . insert ( shape , value ) ; } QStringList QtCursorDatabase :: cursorShapeNames ( ) const { return m_cursorNames ; } QMap < int , QIcon > QtCursorDatabase :: cursorShapeIcons ( ) const { return m_cursorIcons ; } QString QtCursorDatabase :: cursorToShapeName ( const QCursor & cursor ) const { int val = cursorToValue ( cursor ) ; if ( val >= 0 ) return m_cursorNames . at ( val ) ; return QString ( ) ; } QIcon QtCursorDatabase :: cursorToShapeIcon ( const QCursor & cursor ) const { int val = cursorToValue ( cursor ) ; return m_cursorIcons . value ( val ) ; } int QtCursorDatabase :: cursorToValue ( const QCursor & cursor ) const { # ifndef QT_NO_CURSOR Qt :: CursorShape shape = cursor . shape ( ) ; if ( m_cursorShapeToValue . contains ( shape ) ) return m_cursorShapeToValue [ shape ] ; # endif return - 1 ; } # ifndef QT_NO_CURSOR QCursor QtCursorDatabase :: valueToCursor ( int value ) const { if ( m_valueToCursorShape . contains ( value ) ) return QCursor ( m_valueToCursorShape [ value ] ) ; return QCursor ( ) ; } # endif QPixmap QtPropertyBrowserUtils :: brushValuePixmap ( const QBrush & b ) { QImage img ( 16 , 16 , QImage :: Format_ARGB32_Premultiplied ) ; img . fill ( 0 ) ; QPainter painter ( & img ) ; painter . setCompositionMode ( QPainter :: CompositionMode_Source ) ; painter . fillRect ( 0 , 0 , img . width ( ) , img . height ( ) , b ) ; QColor color = b . color ( ) ; if ( color . alpha ( ) != 255 ) { QBrush opaqueBrush = b ; color . setAlpha ( 255 ) ; opaqueBrush . setColor ( color ) ; painter . fillRect ( img . width ( ) / 4 , img . height ( ) / 4 , img . width ( ) / 2 , img . height ( ) / 2 , opaqueBrush ) ; } painter . end ( ) ; return QPixmap :: fromImage ( img ) ; } QIcon QtPropertyBrowserUtils :: brushValueIcon ( const QBrush & b ) { return QIcon ( brushValuePixmap ( b ) ) ; } QString QtPropertyBrowserUtils :: colorValueText ( const QColor & c ) { return QCoreApplication :: translate ( " QtPropertyBrowserUtils " , " [ %1 , ▁ % 2 , ▁ % 3 ] ▁ ( %4 ) " ) . arg ( c . red ( ) ) . arg ( c . green ( ) ) . arg ( c . blue ( ) ) . arg ( c . alpha ( ) ) ; } QPixmap QtPropertyBrowserUtils :: fontValuePixmap ( const QFont & font ) { QFont f = font ; QImage img ( 16 , 16 , QImage :: Format_ARGB32_Premultiplied ) ; img . fill ( 0 ) ; QPainter p ( & img ) ; p . setRenderHint ( QPainter :: TextAntialiasing , true ) ; p . setRenderHint ( QPainter :: Antialiasing , true ) ; f . setPointSize ( 13 ) ; p . setFont ( f ) ; QTextOption t ; t . setAlignment ( Qt :: AlignCenter ) ; p . drawText ( QRect ( 0 , 0 , 16 , 16 ) , QString ( QLatin1Char ( ' A ' ) ) , t ) ; return QPixmap :: fromImage ( img ) ; } QIcon QtPropertyBrowserUtils :: fontValueIcon ( const QFont & f ) { return QIcon ( fontValuePixmap ( f ) ) ; } QString QtPropertyBrowserUtils :: fontValueText ( const QFont & f ) { return QCoreApplication :: translate ( " QtPropertyBrowserUtils " , " [ %1 , ▁ % 2 ] " ) . arg ( f . family ( ) ) . arg ( f . pointSize ( ) ) ; } QtBoolEdit :: QtBoolEdit ( QWidget * parent ) : QWidget ( parent ) , m_checkBox ( new QCheckBox ( this ) ) , m_textVisible ( true ) { QHBoxLayout * lt = new QHBoxLayout ; if ( QApplication :: layoutDirection ( ) == Qt :: LeftToRight ) lt -> setContentsMargins ( 4 , 0 , 0 , 0 ) ; else lt -> setContentsMargins ( 0 , 0 , 4 , 0 ) ; lt -> addWidget ( m_checkBox ) ; setLayout ( lt ) ; connect ( m_checkBox , SIGNAL ( toggled ( bool ) ) , this , SIGNAL ( toggled ( bool ) ) ) ; setFocusProxy ( m_checkBox ) ; m_checkBox -> setText ( tr ( " True " ) ) ; } void QtBoolEdit :: setTextVisible ( bool textVisible ) { if ( m_textVisible == textVisible ) return ; m_textVisible = textVisible ; if ( m_textVisible ) m_checkBox -> setText ( isChecked ( ) ? tr ( " True " ) : tr ( " False " ) ) ; else m_checkBox -> setText ( QString ( ) ) ; } Qt :: CheckState QtBoolEdit :: checkState ( ) const { return m_checkBox -> checkState ( ) ; } void QtBoolEdit :: setCheckState ( Qt :: CheckState state ) { m_checkBox -> setCheckState ( state ) ; } bool QtBoolEdit :: isChecked ( ) const { return m_checkBox -> isChecked ( ) ; } void QtBoolEdit :: setChecked ( bool c ) { m_checkBox -> setChecked ( c ) ; if ( ! m_textVisible ) return ; m_checkBox -> setText ( isChecked ( ) ? tr ( " True " ) : tr ( " False " ) ) ; } bool QtBoolEdit :: blockCheckBoxSignals ( bool block ) { return m_checkBox -> blockSignals ( block ) ; } void QtBoolEdit :: mousePressEvent ( QMouseEvent * event ) { if ( event -> buttons ( ) == Qt :: LeftButton ) { m_checkBox -> click ( ) ; event -> accept ( ) ; } else { QWidget :: mousePressEvent ( event ) ; } } void QtBoolEdit :: paintEvent ( QPaintEvent * ) { QStyleOption opt ; opt . init ( this ) ; QPainter p ( this ) ; style ( ) -> drawPrimitive ( QStyle :: PE_Widget , & opt , & p , this ) ; } QtKeySequenceEdit :: QtKeySequenceEdit ( QWidget * parent ) : QWidget ( parent ) , m_num ( 0 ) , m_lineEdit ( new QLineEdit ( this ) ) { QHBoxLayout * layout = new QHBoxLayout ( this ) ; layout -> addWidget ( m_lineEdit ) ; layout -> setMargin ( 0 ) ; m_lineEdit -> installEventFilter ( this ) ; m_lineEdit -> setReadOnly ( true ) ; m_lineEdit -> setFocusProxy ( this ) ; setFocusPolicy ( m_lineEdit -> focusPolicy ( ) ) ; setAttribute ( Qt :: WA_InputMethodEnabled ) ; } bool QtKeySequenceEdit :: eventFilter ( QObject * o , QEvent * e ) { if ( o == m_lineEdit && e -> type ( ) == QEvent :: ContextMenu ) { QContextMenuEvent * c = static_cast < QContextMenuEvent * > ( e ) ; QMenu * menu = m_lineEdit -> createStandardContextMenu ( ) ; const QList < QAction * > actions = menu -> actions ( ) ; QListIterator < QAction * > itAction ( actions ) ; while ( itAction . hasNext ( ) ) { QAction * action = itAction . next ( ) ; action -> setShortcut ( QKeySequence ( ) ) ; QString actionString = action -> text ( ) ; const int pos = actionString . lastIndexOf ( QLatin1Char ( ' \t ' ) ) ; if ( pos > 0 ) actionString . remove ( pos , actionString . length ( ) - pos ) ; action -> setText ( actionString ) ; } QAction * actionBefore = 0 ; if ( actions . count ( ) > 0 ) actionBefore = actions [ 0 ] ; QAction * clearAction = new QAction ( tr ( " Clear ▁ Shortcut " ) , menu ) ; menu -> insertAction ( actionBefore , clearAction ) ; menu -> insertSeparator ( actionBefore ) ; clearAction -> setEnabled ( ! m_keySequence . isEmpty ( ) ) ; connect ( clearAction , SIGNAL ( triggered ( ) ) , this , SLOT ( slotClearShortcut ( ) ) ) ; menu -> exec ( c -> globalPos ( ) ) ; delete menu ; e -> accept ( ) ; return true ; } return QWidget :: eventFilter ( o , e ) ; } void QtKeySequenceEdit :: slotClearShortcut ( ) { if ( m_keySequence . isEmpty ( ) ) return ; setKeySequence ( QKeySequence ( ) ) ; emit keySequenceChanged ( m_keySequence ) ; } void QtKeySequenceEdit :: handleKeyEvent ( QKeyEvent * e ) { int nextKey = e -> key ( ) ; if ( nextKey == Qt :: Key_Control || nextKey == Qt :: Key_Shift || nextKey == Qt :: Key_Meta || nextKey == Qt :: Key_Alt || nextKey == Qt :: Key_Super_L || nextKey == Qt :: Key_AltGr ) return ; nextKey |= translateModifiers ( e -> modifiers ( ) , e -> text ( ) ) ; int k0 = m_keySequence [ 0 ] ; int k1 = m_keySequence [ 1 ] ; int k2 = m_keySequence [ 2 ] ; int k3 = m_keySequence [ 3 ] ; switch ( m_num ) { case 0 : k0 = nextKey ; k1 = 0 ; k2 = 0 ; k3 = 0 ; break ; case 1 : k1 = nextKey ; k2 = 0 ; k3 = 0 ; break ; case 2 : k2 = nextKey ; k3 = 0 ; break ; case 3 : k3 = nextKey ; break ; default : break ; } ++ m_num ; if ( m_num > 3 ) m_num = 0 ; m_keySequence = QKeySequence ( k0 , k1 , k2 , k3 ) ; m_lineEdit -> setText ( m_keySequence . toString ( QKeySequence :: NativeText ) ) ; e -> accept ( ) ; emit keySequenceChanged ( m_keySequence ) ; } void QtKeySequenceEdit :: setKeySequence ( const QKeySequence & sequence ) { if ( sequence == m_keySequence ) return ; m_num = 0 ; m_keySequence = sequence ; m_lineEdit -> setText ( m_keySequence . toString ( QKeySequence :: NativeText ) ) ; } QKeySequence QtKeySequenceEdit :: keySequence ( ) const { return m_keySequence ; } int QtKeySequenceEdit :: translateModifiers ( Qt :: KeyboardModifiers state , const QString & text ) const { int result = 0 ; if ( ( state & Qt :: ShiftModifier ) && ( text . size ( ) == 0 || ! text . at ( 0 ) . isPrint ( ) || text . at ( 0 ) . isLetter ( ) || text . at ( 0 ) . isSpace ( ) ) ) result |= Qt :: SHIFT ; if ( state & Qt :: ControlModifier ) result |= Qt :: CTRL ; if ( state & Qt :: MetaModifier ) result |= Qt :: META ; if ( state & Qt :: AltModifier ) result |= Qt :: ALT ; return result ; } void QtKeySequenceEdit :: focusInEvent ( QFocusEvent * e ) { m_lineEdit -> event ( e ) ; m_lineEdit -> selectAll ( ) ; QWidget :: focusInEvent ( e ) ; } void QtKeySequenceEdit :: focusOutEvent ( QFocusEvent * e ) { m_num = 0 ; m_lineEdit -> event ( e ) ; QWidget :: focusOutEvent ( e ) ; } void QtKeySequenceEdit :: keyPressEvent ( QKeyEvent * e ) { handleKeyEvent ( e ) ; e -> accept ( ) ; } void QtKeySequenceEdit :: keyReleaseEvent ( QKeyEvent * e ) { m_lineEdit -> event ( e ) ; } void QtKeySequenceEdit :: paintEvent ( QPaintEvent * ) { QStyleOption opt ; opt . init ( this ) ; QPainter p ( this ) ; style ( ) -> drawPrimitive ( QStyle :: PE_Widget , & opt , & p , this ) ; } bool QtKeySequenceEdit :: event ( QEvent * e ) { if ( e -> type ( ) == QEvent :: Shortcut || e -> type ( ) == QEvent :: ShortcutOverride || e -> type ( ) == QEvent :: KeyRelease ) { e -> accept ( ) ; return true ; } return QWidget :: event ( e ) ; } # if QT_VERSION >= 0x040400 QT_END_NAMESPACE # endif </DOCUMENT>
<DOCUMENT_ID="jerrys123111/pcsx2/tree/master/plugins/GSdx_legacy/linux_replay.cpp"> # include " stdafx . h " # include < dlfcn . h > static void * handle ; void help ( ) { fprintf ( stderr , " Loader ▁ gs ▁ file \n " ) ; fprintf ( stderr , " ARG1 ▁ GSdx ▁ plugin \n " ) ; fprintf ( stderr , " ARG2 ▁ . gs ▁ file \n " ) ; fprintf ( stderr , " ARG3 ▁ Ini ▁ directory \n " ) ; if ( handle ) { dlclose ( handle ) ; } exit ( 1 ) ; } char * read_env ( const char * var ) { char * v = getenv ( var ) ; if ( ! v ) { fprintf ( stderr , " Failed ▁ to ▁ get ▁ % s \n " , var ) ; help ( ) ; } return v ; } int main ( int argc , char * argv [ ] ) { if ( argc < 1 ) help ( ) ; char * plugin ; char * gs ; if ( argc > 2 ) { plugin = argv [ 1 ] ; gs = argv [ 2 ] ; } else { plugin = read_env ( " GSDUMP _ SO " ) ; gs = argv [ 1 ] ; } handle = dlopen ( plugin , RTLD_LAZY | RTLD_GLOBAL ) ; if ( handle == NULL ) { fprintf ( stderr , " Failed ▁ to ▁ dlopen ▁ plugin ▁ % s \n " , plugin ) ; help ( ) ; } __attribute__ ( ( stdcall ) ) void ( * GSsetSettingsDir_ptr ) ( const char * ) ; __attribute__ ( ( stdcall ) ) void ( * GSReplay_ptr ) ( char * , int ) ; * ( void * * ) ( & GSsetSettingsDir_ptr ) = dlsym ( handle , " GSsetSettingsDir " ) ; * ( void * * ) ( & GSReplay_ptr ) = dlsym ( handle , " GSReplay " ) ; if ( argc == 2 ) { char * ini = read_env ( " GSDUMP _ CONF " ) ; GSsetSettingsDir_ptr ( ini ) ; } else if ( argc == 4 ) { ( void ) GSsetSettingsDir_ptr ( argv [ 3 ] ) ; } else if ( argc == 3 ) { # ifdef XDG_STD char * val = read_env ( " HOME " ) ; std :: string ini_dir ( val ) ; ini_dir += " / . config / pcsx2 / inis " ; GSsetSettingsDir_ptr ( ini_dir . c_str ( ) ) ; # else fprintf ( stderr , " default ▁ ini ▁ dir ▁ only ▁ supported ▁ on ▁ XDG \n " ) ; help ( ) ; # endif } GSReplay_ptr ( gs , 12 ) ; if ( handle ) { dlclose ( handle ) ; } } </DOCUMENT>
<DOCUMENT_ID="Tomcc/dolphin/tree/master/Source/Core/Core/HW/EXI/EXI_DeviceAGP.cpp"> # include " Core / HW / EXI / EXI _ DeviceAGP . h " # include < algorithm > # include < memory > # include < string > # include < vector > # include " Common / ChunkFile . h " # include " Common / CommonTypes . h " # include " Common / File . h " # include " Common / Logging / Log . h " # include " Common / StringUtil . h " # include " Core / ConfigManager . h " namespace ExpansionInterface { CEXIAgp :: CEXIAgp ( int index ) { m_slot = index ; m_rom_size = 0 ; LoadRom ( ) ; m_address = 0 ; } CEXIAgp :: ~ CEXIAgp ( ) { std :: string path ; std :: string filename ; std :: string ext ; std :: string gbapath ; SplitPath ( m_slot == 0 ? SConfig :: GetInstance ( ) . m_strGbaCartA : SConfig :: GetInstance ( ) . m_strGbaCartB , & path , & filename , & ext ) ; gbapath = path + filename ; SaveFileFromEEPROM ( gbapath + " . sav " ) ; } void CEXIAgp :: CRC8 ( const u8 * data , u32 size ) { for ( u32 it = 0 ; it < size ; it ++ ) { u8 crc = 0 ; m_hash = m_hash ^ data [ it ] ; if ( m_hash & 1 ) crc ^= 0x5e ; if ( m_hash & 2 ) crc ^= 0xbc ; if ( m_hash & 4 ) crc ^= 0x61 ; if ( m_hash & 8 ) crc ^= 0xc2 ; if ( m_hash & 0x10 ) crc ^= 0x9d ; if ( m_hash & 0x20 ) crc ^= 0x23 ; if ( m_hash & 0x40 ) crc ^= 0x46 ; if ( m_hash & 0x80 ) crc ^= 0x8c ; m_hash = crc ; } } void CEXIAgp :: LoadRom ( ) { std :: string path ; std :: string filename ; std :: string ext ; std :: string gbapath ; SplitPath ( m_slot == 0 ? SConfig :: GetInstance ( ) . m_strGbaCartA : SConfig :: GetInstance ( ) . m_strGbaCartB , & path , & filename , & ext ) ; gbapath = path + filename ; LoadFileToROM ( gbapath + ext ) ; INFO_LOG ( EXPANSIONINTERFACE , " Loaded ▁ GBA ▁ rom : ▁ % s ▁ card : ▁ % d " , gbapath . c_str ( ) , m_slot ) ; LoadFileToEEPROM ( gbapath + " . sav " ) ; INFO_LOG ( EXPANSIONINTERFACE , " Loaded ▁ GBA ▁ sav : ▁ % s ▁ card : ▁ % d " , gbapath . c_str ( ) , m_slot ) ; } void CEXIAgp :: LoadFileToROM ( const std :: string & filename ) { File :: IOFile pStream ( filename , " rb " ) ; if ( pStream ) { u64 filesize = pStream . GetSize ( ) ; m_rom_size = filesize & 0xFFFFFFFF ; m_rom_mask = ( m_rom_size - 1 ) ; m_rom . resize ( m_rom_size ) ; pStream . ReadBytes ( m_rom . data ( ) , filesize ) ; } else { m_rom . resize ( 0x2000 ) ; } } void CEXIAgp :: LoadFileToEEPROM ( const std :: string & filename ) { File :: IOFile pStream ( filename , " rb " ) ; if ( pStream ) { u64 filesize = pStream . GetSize ( ) ; m_eeprom_size = filesize & 0xFFFFFFFF ; m_eeprom_mask = ( m_eeprom_size - 1 ) ; m_eeprom . resize ( m_eeprom_size ) ; pStream . ReadBytes ( m_eeprom . data ( ) , filesize ) ; if ( ( m_eeprom_size == 512 ) || ( m_eeprom_size == 8192 ) ) { for ( u32 index = 0 ; index < ( m_eeprom_size / 8 ) ; index ++ ) { u64 NewVal = 0 ; for ( u32 indexb = 0 ; indexb < 8 ; indexb ++ ) NewVal = ( NewVal << 0x8 ) | m_eeprom [ index * 8 + indexb ] ; ( ( u64 * ) ( m_eeprom . data ( ) ) ) [ index ] = NewVal ; } m_eeprom_add_end = ( m_eeprom_size == 512 ? ( 2 + 6 ) : ( 2 + 14 ) ) ; m_eeprom_add_mask = ( m_eeprom_size == 512 ? 0x3F : 0x3FF ) ; m_eeprom_read_mask = ( m_eeprom_size == 512 ? 0x80 : 0x8000 ) ; m_eeprom_status_mask = ( m_rom_size == 0x2000000 ? 0x1FFFF00 : 0x1000000 ) ; } else m_eeprom_status_mask = 0 ; } else { m_eeprom_size = 0 ; m_eeprom . clear ( ) ; } } void CEXIAgp :: SaveFileFromEEPROM ( const std :: string & filename ) { File :: IOFile pStream ( filename , " wb " ) ; if ( pStream ) { if ( ( m_eeprom_size == 512 ) || ( m_eeprom_size == 8192 ) ) { std :: vector < u8 > temp_eeprom ( m_eeprom_size ) ; for ( u32 index = 0 ; index < ( m_eeprom_size / 8 ) ; index ++ ) { u64 NewVal = ( ( u64 * ) ( m_eeprom . data ( ) ) ) [ index ] ; for ( u32 indexb = 0 ; indexb < 8 ; indexb ++ ) temp_eeprom [ index * 8 + ( 7 - indexb ) ] = ( NewVal >> ( indexb * 8 ) ) & 0xFF ; } pStream . WriteBytes ( temp_eeprom . data ( ) , m_eeprom_size ) ; } else { pStream . WriteBytes ( m_eeprom . data ( ) , m_eeprom_size ) ; } } } u32 CEXIAgp :: ImmRead ( u32 _uSize ) { u32 uData = 0 ; u8 RomVal1 , RomVal2 , RomVal3 , RomVal4 ; switch ( m_current_cmd ) { case 0xAE000000 : uData = 0x5AAA5517 ; m_current_cmd = 0 ; break ; case 0xAE010000 : uData = ( m_return_pos == 0 ) ? 0x01020304 : 0xF0020304 ; if ( m_return_pos == 1 ) m_current_cmd = 0 ; else m_return_pos = 1 ; break ; case 0xAE020000 : if ( m_eeprom_write_status && ( ( m_rw_offset & m_eeprom_status_mask ) == m_eeprom_status_mask ) && ( m_eeprom_status_mask != 0 ) ) { RomVal1 = 0x1 ; RomVal2 = 0x0 ; } else { RomVal1 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal2 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; } CRC8 ( & RomVal2 , 1 ) ; CRC8 ( & RomVal1 , 1 ) ; uData = ( RomVal2 << 24 ) | ( RomVal1 << 16 ) | ( m_hash << 8 ) ; m_current_cmd = 0 ; break ; case 0xAE030000 : if ( _uSize == 1 ) { uData = 0xFF000000 ; m_current_cmd = 0 ; } else { RomVal1 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal2 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal3 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal4 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; CRC8 ( & RomVal2 , 1 ) ; CRC8 ( & RomVal1 , 1 ) ; CRC8 ( & RomVal4 , 1 ) ; CRC8 ( & RomVal3 , 1 ) ; uData = ( RomVal2 << 24 ) | ( RomVal1 << 16 ) | ( RomVal4 << 8 ) | ( RomVal3 ) ; } break ; case 0xAE040000 : if ( m_eeprom_size == 0 ) RomVal1 = 0xFF ; else RomVal1 = ( m_eeprom . data ( ) ) [ m_eeprom_pos ] ; CRC8 ( & RomVal1 , 1 ) ; uData = ( RomVal1 << 24 ) | ( m_hash << 16 ) ; m_current_cmd = 0 ; break ; case 0xAE0B0000 : RomVal1 = EE_READ_FALSE ; if ( ( m_eeprom_size != 0 ) && ( m_eeprom_pos >= EE_IGNORE_BITS ) && ( ( ( ( u64 * ) m_eeprom . data ( ) ) [ ( m_eeprom_cmd >> 1 ) & m_eeprom_add_mask ] ) >> ( ( EE_DATA_BITS - 1 ) - ( m_eeprom_pos - EE_IGNORE_BITS ) ) ) & 0x1 ) { RomVal1 = EE_READ_TRUE ; } RomVal2 = 0 ; CRC8 ( & RomVal2 , 1 ) ; CRC8 ( & RomVal1 , 1 ) ; uData = ( RomVal2 << 24 ) | ( RomVal1 << 16 ) | ( m_hash << 8 ) ; m_eeprom_pos ++ ; m_current_cmd = 0 ; break ; case 0xAE070000 : case 0xAE0C0000 : uData = m_hash << 24 ; m_current_cmd = 0 ; break ; default : uData = 0x0 ; m_current_cmd = 0 ; break ; } DEBUG_LOG ( EXPANSIONINTERFACE , " AGP ▁ read ▁ % x " , uData ) ; return uData ; } void CEXIAgp :: ImmWrite ( u32 _uData , u32 _uSize ) { if ( ( _uSize == 1 ) && ( ( _uData & 0xFF000000 ) == 0 ) ) return ; u8 HashCmd ; u64 Mask ; DEBUG_LOG ( EXPANSIONINTERFACE , " AGP ▁ command ▁ % x " , _uData ) ; switch ( m_current_cmd ) { case 0xAE020000 : case 0xAE030000 : m_rw_offset = ( ( _uData & 0xFFFFFF00 ) >> ( 8 - 1 ) ) ; m_return_pos = 0 ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x0000FF00 ) >> 8 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE040000 : m_eeprom_pos = ( ( _uData & 0xFFFF0000 ) >> 0x10 ) & m_eeprom_mask ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE070000 : m_eeprom_pos = ( ( _uData & 0xFFFF0000 ) >> 0x10 ) & m_eeprom_mask ; if ( m_eeprom_size != 0 ) ( ( m_eeprom . data ( ) ) ) [ ( m_eeprom_pos ) ] = ( _uData & 0x0000FF00 ) >> 0x8 ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x0000FF00 ) >> 8 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE0C0000 : if ( ( m_eeprom_pos < m_eeprom_add_end ) || ( m_eeprom_pos == ( ( m_eeprom_cmd & m_eeprom_read_mask ) ? m_eeprom_add_end : m_eeprom_add_end + EE_DATA_BITS ) ) ) { Mask = ( 1ULL << ( m_eeprom_add_end - std :: min ( m_eeprom_pos , m_eeprom_add_end ) ) ) ; if ( ( _uData >> 16 ) & 0x1 ) m_eeprom_cmd |= Mask ; else m_eeprom_cmd &= ~ Mask ; if ( m_eeprom_pos == m_eeprom_add_end + EE_DATA_BITS ) { if ( m_eeprom_size != 0 ) ( ( u64 * ) ( m_eeprom . data ( ) ) ) [ ( m_eeprom_cmd >> 1 ) & m_eeprom_add_mask ] = m_eeprom_data ; m_eeprom_write_status = true ; } } else { Mask = ( 1ULL << ( m_eeprom_add_end + EE_DATA_BITS - 1 - m_eeprom_pos ) ) ; if ( ( _uData >> 16 ) & 0x1 ) m_eeprom_data |= Mask ; else m_eeprom_data &= ~ Mask ; } m_eeprom_pos ++ ; m_return_pos = 0 ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE0B0000 : m_eeprom_write_status = false ; break ; case 0xAE000000 : case 0xAE010000 : case 0xAE090000 : m_eeprom_write_status = false ; case 0xAE0A0000 : m_eeprom_pos = 0 ; default : m_current_cmd = _uData ; m_return_pos = 0 ; m_hash = 0xFF ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; break ; } } void CEXIAgp :: DoState ( PointerWrap & p ) { p . Do ( m_slot ) ; p . Do ( m_address ) ; p . Do ( m_current_cmd ) ; p . Do ( m_eeprom ) ; p . Do ( m_eeprom_cmd ) ; p . Do ( m_eeprom_data ) ; p . Do ( m_eeprom_mask ) ; p . Do ( m_eeprom_pos ) ; p . Do ( m_eeprom_size ) ; p . Do ( m_eeprom_add_end ) ; p . Do ( m_eeprom_add_mask ) ; p . Do ( m_eeprom_read_mask ) ; p . Do ( m_eeprom_status_mask ) ; p . Do ( m_eeprom_write_status ) ; p . Do ( m_hash ) ; p . Do ( m_position ) ; p . Do ( m_return_pos ) ; p . Do ( m_rom ) ; p . Do ( m_rom_mask ) ; p . Do ( m_rom_size ) ; p . Do ( m_rw_offset ) ; } } </DOCUMENT>
<DOCUMENT_ID="kzhong1991/Flight-AR.Drone-2/tree/master/src/3rdparty/Qt4.8.4/src/3rdparty/webkit/Source/WebCore/platform/graphics/mac/GlyphPageTreeNodeMac.cpp"> # include " config . h " # include " GlyphPageTreeNode . h " # include " Font . h " # include " SimpleFontData . h " # include " WebCoreSystemInterface . h " # include < ApplicationServices / ApplicationServices . h > namespace WebCore { static bool shouldUseCoreText ( UChar * buffer , unsigned bufferLength , const SimpleFontData * fontData ) { if ( fontData -> platformData ( ) . widthVariant ( ) != RegularWidth || fontData -> hasVerticalGlyphs ( ) ) { for ( unsigned i = 0 ; i < bufferLength ; ++ i ) { if ( ! Font :: isCJKIdeograph ( buffer [ i ] ) ) return true ; } } return false ; } bool GlyphPage :: fill ( unsigned offset , unsigned length , UChar * buffer , unsigned bufferLength , const SimpleFontData * fontData ) { bool haveGlyphs = false ; if ( ! shouldUseCoreText ( buffer , bufferLength , fontData ) ) { Vector < CGGlyph , 512 > glyphs ( bufferLength ) ; wkGetGlyphsForCharacters ( fontData -> platformData ( ) . cgFont ( ) , buffer , glyphs . data ( ) , bufferLength ) ; for ( unsigned i = 0 ; i < length ; ++ i ) { if ( ! glyphs [ i ] ) setGlyphDataForIndex ( offset + i , 0 , 0 ) ; else { setGlyphDataForIndex ( offset + i , glyphs [ i ] , fontData ) ; haveGlyphs = true ; } } } else { RetainPtr < CFStringRef > string ( AdoptCF , CFStringCreateWithCharactersNoCopy ( kCFAllocatorDefault , buffer , bufferLength , kCFAllocatorNull ) ) ; RetainPtr < CFAttributedStringRef > attributedString ( AdoptCF , CFAttributedStringCreate ( kCFAllocatorDefault , string . get ( ) , fontData -> getCFStringAttributes ( 0 , fontData -> hasVerticalGlyphs ( ) ? Vertical : Horizontal ) ) ) ; RetainPtr < CTLineRef > line ( AdoptCF , CTLineCreateWithAttributedString ( attributedString . get ( ) ) ) ; CFArrayRef runArray = CTLineGetGlyphRuns ( line . get ( ) ) ; CFIndex runCount = CFArrayGetCount ( runArray ) ; for ( unsigned index = 0 ; index < length ; ++ index ) setGlyphDataForIndex ( offset + index , 0 , 0 ) ; Vector < CGGlyph , 512 > glyphVector ; Vector < CFIndex , 512 > indexVector ; bool done = false ; RetainPtr < CGFontRef > cgFont ( AdoptCF , CTFontCopyGraphicsFont ( fontData -> platformData ( ) . ctFont ( ) , 0 ) ) ; for ( CFIndex r = 0 ; r < runCount && ! done ; ++ r ) { CTRunRef ctRun = static_cast < CTRunRef > ( CFArrayGetValueAtIndex ( runArray , r ) ) ; ASSERT ( CFGetTypeID ( ctRun ) == CTRunGetTypeID ( ) ) ; CFDictionaryRef attributes = CTRunGetAttributes ( ctRun ) ; CTFontRef runFont = static_cast < CTFontRef > ( CFDictionaryGetValue ( attributes , kCTFontAttributeName ) ) ; RetainPtr < CGFontRef > runCGFont ( AdoptCF , CTFontCopyGraphicsFont ( runFont , 0 ) ) ; if ( CFEqual ( cgFont . get ( ) , runCGFont . get ( ) ) ) { CFIndex glyphCount = CTRunGetGlyphCount ( ctRun ) ; const CGGlyph * glyphs = CTRunGetGlyphsPtr ( ctRun ) ; if ( ! glyphs ) { glyphVector . resize ( glyphCount ) ; CTRunGetGlyphs ( ctRun , CFRangeMake ( 0 , 0 ) , glyphVector . data ( ) ) ; glyphs = glyphVector . data ( ) ; } const CFIndex * stringIndices = CTRunGetStringIndicesPtr ( ctRun ) ; if ( ! stringIndices ) { indexVector . resize ( glyphCount ) ; CTRunGetStringIndices ( ctRun , CFRangeMake ( 0 , 0 ) , indexVector . data ( ) ) ; stringIndices = indexVector . data ( ) ; } for ( CFIndex i = 0 ; i < glyphCount ; ++ i ) { if ( stringIndices [ i ] >= static_cast < CFIndex > ( length ) ) { done = true ; break ; } if ( glyphs [ i ] ) { setGlyphDataForIndex ( offset + stringIndices [ i ] , glyphs [ i ] , fontData ) ; haveGlyphs = true ; } } } } } return haveGlyphs ; } } </DOCUMENT>
<DOCUMENT_ID="ondra-novak/blink/tree/master/Source/core/svg/SVGFontFaceUriElement.cpp"> # include " config . h " # if ENABLE ( SVG_FONTS ) # include " core / svg / SVGFontFaceUriElement . h " # include " core / XLinkNames . h " # include " core / css / CSSFontFaceSrcValue . h " # include " core / dom / Document . h " # include " core / fetch / FetchRequest . h " # include " core / fetch / ResourceFetcher . h " # include " core / svg / SVGFontFaceElement . h " namespace blink { using namespace SVGNames ; inline SVGFontFaceUriElement :: SVGFontFaceUriElement ( Document & document ) : SVGElement ( font_face_uriTag , document ) { ScriptWrappable :: init ( this ) ; } DEFINE_NODE_FACTORY ( SVGFontFaceUriElement ) SVGFontFaceUriElement :: ~ SVGFontFaceUriElement ( ) { if ( m_resource ) m_resource -> removeClient ( this ) ; } PassRefPtrWillBeRawPtr < CSSFontFaceSrcValue > SVGFontFaceUriElement :: srcValue ( ) const { RefPtrWillBeRawPtr < CSSFontFaceSrcValue > src = CSSFontFaceSrcValue :: create ( getAttribute ( XLinkNames :: hrefAttr ) ) ; AtomicString value ( fastGetAttribute ( formatAttr ) ) ; src -> setFormat ( value . isEmpty ( ) ? " svg " : value ) ; return src . release ( ) ; } void SVGFontFaceUriElement :: parseAttribute ( const QualifiedName & name , const AtomicString & value ) { if ( name . matches ( XLinkNames :: hrefAttr ) ) loadFont ( ) ; else SVGElement :: parseAttribute ( name , value ) ; } void SVGFontFaceUriElement :: childrenChanged ( const ChildrenChange & change ) { SVGElement :: childrenChanged ( change ) ; if ( ! isSVGFontFaceSrcElement ( parentNode ( ) ) ) return ; ContainerNode * grandparent = parentNode ( ) -> parentNode ( ) ; if ( isSVGFontFaceElement ( grandparent ) ) toSVGFontFaceElement ( * grandparent ) . rebuildFontFace ( ) ; } Node :: InsertionNotificationRequest SVGFontFaceUriElement :: insertedInto ( ContainerNode * rootParent ) { loadFont ( ) ; return SVGElement :: insertedInto ( rootParent ) ; } void SVGFontFaceUriElement :: loadFont ( ) { if ( m_resource ) m_resource -> removeClient ( this ) ; const AtomicString & href = getAttribute ( XLinkNames :: hrefAttr ) ; if ( ! href . isNull ( ) ) { ResourceFetcher * fetcher = document ( ) . fetcher ( ) ; FetchRequest request ( ResourceRequest ( document ( ) . completeURL ( href ) ) , localName ( ) ) ; m_resource = fetcher -> fetchFont ( request ) ; if ( m_resource ) { m_resource -> addClient ( this ) ; m_resource -> beginLoadIfNeeded ( fetcher ) ; } } else { m_resource = 0 ; } } } # endif </DOCUMENT>
<DOCUMENT_ID="qtproject/qtwebkit/tree/master/Source/WebCore/html/HTMLFrameSetElement.cpp"> # include " config . h " # include " HTMLFrameSetElement . h " # include " CSSPropertyNames . h " # include " Document . h " # include " ElementIterator . h " # include " Event . h " # include " EventNames . h " # include " Frame . h " # include " FrameLoader . h " # include " FrameLoaderClient . h " # include " HTMLBodyElement . h " # include " HTMLNames . h " # include " Length . h " # include " MouseEvent . h " # include " RenderFrameSet . h " # include " Text . h " namespace WebCore { using namespace HTMLNames ; HTMLFrameSetElement :: HTMLFrameSetElement ( const QualifiedName & tagName , Document & document ) : HTMLElement ( tagName , document ) , m_totalRows ( 1 ) , m_totalCols ( 1 ) , m_border ( 6 ) , m_borderSet ( false ) , m_borderColorSet ( false ) , m_frameborder ( true ) , m_frameborderSet ( false ) , m_noresize ( false ) { ASSERT ( hasTagName ( framesetTag ) ) ; setHasCustomStyleResolveCallbacks ( ) ; } Ref < HTMLFrameSetElement > HTMLFrameSetElement :: create ( const QualifiedName & tagName , Document & document ) { return adoptRef ( * new HTMLFrameSetElement ( tagName , document ) ) ; } bool HTMLFrameSetElement :: isPresentationAttribute ( const QualifiedName & name ) const { if ( name == bordercolorAttr ) return true ; return HTMLElement :: isPresentationAttribute ( name ) ; } void HTMLFrameSetElement :: collectStyleForPresentationAttribute ( const QualifiedName & name , const AtomicString & value , MutableStyleProperties & style ) { if ( name == bordercolorAttr ) addHTMLColorToStyle ( style , CSSPropertyBorderColor , value ) ; else HTMLElement :: collectStyleForPresentationAttribute ( name , value , style ) ; } void HTMLFrameSetElement :: parseAttribute ( const QualifiedName & name , const AtomicString & value ) { if ( name == rowsAttr ) { if ( ! value . isNull ( ) ) { m_rowLengths = newLengthArray ( value . string ( ) , m_totalRows ) ; setNeedsStyleRecalc ( ) ; } return ; } if ( name == colsAttr ) { if ( ! value . isNull ( ) ) { m_colLengths = newLengthArray ( value . string ( ) , m_totalCols ) ; setNeedsStyleRecalc ( ) ; } return ; } if ( name == frameborderAttr ) { if ( ! value . isNull ( ) ) { if ( equalLettersIgnoringASCIICase ( value , " no " ) || value == "0" ) { m_frameborder = false ; m_frameborderSet = true ; } else if ( equalLettersIgnoringASCIICase ( value , " yes " ) || value == "1" ) { m_frameborderSet = true ; } } else { m_frameborder = false ; m_frameborderSet = false ; } return ; } if ( name == noresizeAttr ) { m_noresize = true ; return ; } if ( name == borderAttr ) { if ( ! value . isNull ( ) ) { m_border = value . toInt ( ) ; m_borderSet = true ; } else m_borderSet = false ; return ; } if ( name == bordercolorAttr ) { m_borderColorSet = ! value . isEmpty ( ) ; return ; } auto & eventName = HTMLBodyElement :: eventNameForWindowEventHandlerAttribute ( name ) ; if ( ! eventName . isNull ( ) ) { document ( ) . setWindowAttributeEventListener ( eventName , name , value ) ; return ; } HTMLElement :: parseAttribute ( name , value ) ; } bool HTMLFrameSetElement :: rendererIsNeeded ( const RenderStyle & style ) { return style . isStyleAvailable ( ) ; } RenderPtr < RenderElement > HTMLFrameSetElement :: createElementRenderer ( Ref < RenderStyle > && style , const RenderTreePosition & ) { if ( style . get ( ) . hasContent ( ) ) return RenderElement :: createFor ( * this , WTFMove ( style ) ) ; return createRenderer < RenderFrameSet > ( * this , WTFMove ( style ) ) ; } HTMLFrameSetElement * HTMLFrameSetElement :: findContaining ( Element * descendant ) { return ancestorsOfType < HTMLFrameSetElement > ( * descendant ) . first ( ) ; } void HTMLFrameSetElement :: willAttachRenderers ( ) { const HTMLFrameSetElement * containingFrameSet = findContaining ( this ) ; if ( ! containingFrameSet ) return ; if ( ! m_frameborderSet ) m_frameborder = containingFrameSet -> hasFrameBorder ( ) ; if ( m_frameborder ) { if ( ! m_borderSet ) m_border = containingFrameSet -> border ( ) ; if ( ! m_borderColorSet ) m_borderColorSet = containingFrameSet -> hasBorderColor ( ) ; } if ( ! m_noresize ) m_noresize = containingFrameSet -> noResize ( ) ; } void HTMLFrameSetElement :: defaultEventHandler ( Event * event ) { ASSERT ( event ) ; if ( is < MouseEvent > ( * event ) && ! m_noresize && is < RenderFrameSet > ( renderer ( ) ) ) { if ( downcast < RenderFrameSet > ( * renderer ( ) ) . userResize ( downcast < MouseEvent > ( event ) ) ) { event -> setDefaultHandled ( ) ; return ; } } HTMLElement :: defaultEventHandler ( event ) ; } bool HTMLFrameSetElement :: willRecalcStyle ( Style :: Change ) { if ( needsStyleRecalc ( ) && renderer ( ) ) { renderer ( ) -> setNeedsLayout ( ) ; clearNeedsStyleRecalc ( ) ; } return true ; } Node :: InsertionNotificationRequest HTMLFrameSetElement :: insertedInto ( ContainerNode & insertionPoint ) { HTMLElement :: insertedInto ( insertionPoint ) ; if ( insertionPoint . inDocument ( ) ) { if ( Frame * frame = document ( ) . frame ( ) ) frame -> loader ( ) . client ( ) . dispatchDidBecomeFrameset ( document ( ) . isFrameSet ( ) ) ; } return InsertionDone ; } void HTMLFrameSetElement :: removedFrom ( ContainerNode & insertionPoint ) { HTMLElement :: removedFrom ( insertionPoint ) ; if ( insertionPoint . inDocument ( ) ) { if ( Frame * frame = document ( ) . frame ( ) ) frame -> loader ( ) . client ( ) . dispatchDidBecomeFrameset ( document ( ) . isFrameSet ( ) ) ; } } } </DOCUMENT>
<DOCUMENT_ID="SlavaRa/coreclr/tree/master/src/binder/variables.cpp"> # include " variables . hpp " # include " ex . h " namespace BINDER_SPACE { # ifdef FEATURE_VERSIONING_LOG namespace { HRESULT CheckFileExistence ( LPCWSTR pwzFile , LPDWORD pdwAttrib ) { HRESULT hr = S_FALSE ; DWORD dwRet = 0 ; _ASSERTE ( pwzFile && pdwAttrib ) ; * pdwAttrib = 0 ; dwRet = WszGetFileAttributes ( pwzFile ) ; if ( dwRet == INVALID_FILE_ATTRIBUTES ) { hr = HRESULT_FROM_GetLastError ( ) ; if ( ( hr == HRESULT_FROM_WIN32 ( ERROR_FILE_NOT_FOUND ) ) || ( hr == HRESULT_FROM_WIN32 ( ERROR_PATH_NOT_FOUND ) ) ) { GO_WITH_HRESULT ( S_FALSE ) ; } } else { * pdwAttrib = dwRet ; GO_WITH_HRESULT ( S_OK ) ; } Exit : return hr ; } } ; # endif Variables * g_BinderVariables = NULL ; Variables :: Variables ( ) { } Variables :: ~ Variables ( ) { } HRESULT Variables :: Init ( ) { HRESULT hr = S_OK ; EX_TRY { httpURLPrefix . SetLiteral ( W ( " http : // " ) ) ; architectureMSIL . SetLiteral ( W ( " MSIL " ) ) ; architectureX86 . SetLiteral ( W ( " x86" ) ) ; architectureAMD64 . SetLiteral ( W ( " AMD64" ) ) ; architectureARM . SetLiteral ( W ( " ARM " ) ) ; architectureARM64 . SetLiteral ( W ( " ARM64" ) ) ; cultureNeutral . SetLiteral ( W ( " neutral " ) ) ; mscorlib . SetLiteral ( W ( " mscorlib " ) ) ; emptyString . Clear ( ) ; # ifdef FEATURE_VERSIONING_LOG REGUTIL :: CORConfigLevel kCorConfigLevel = static_cast < REGUTIL :: CORConfigLevel > ( REGUTIL :: COR_CONFIG_ENV | REGUTIL :: COR_CONFIG_FUSION ) ; DWORD dwLoggingNeeded = REGUTIL :: GetConfigDWORD_DontUse_ ( CLRConfig :: EXTERNAL_ForceLog , 0 , kCorConfigLevel , TRUE ) ; fLoggingNeeded = ( dwLoggingNeeded ? TRUE : FALSE ) ; NewArrayHolder < WCHAR > pwzLogDirectory = REGUTIL :: GetConfigString_DontUse_ ( CLRConfig :: INTERNAL_LogPath , TRUE , kCorConfigLevel , FALSE ) ; if ( pwzLogDirectory == NULL ) { fLoggingNeeded = FALSE ; } else { DWORD dwAttr = 0 ; hr = CheckFileExistence ( pwzLogDirectory , & dwAttr ) ; if ( ( hr == S_OK ) && ( ( dwAttr & FILE_ATTRIBUTE_DIRECTORY ) != 0 ) ) { logPath . Set ( pwzLogDirectory ) ; } else { hr = S_OK ; fLoggingNeeded = FALSE ; } } # endif } EX_CATCH_HRESULT ( hr ) ; return hr ; } } ; </DOCUMENT>
<DOCUMENT_ID="YelaSeamless/mysql-server/tree/master/storage/ndb/test/ndbapi/testLimits.cpp"> # include < NDBT . hpp > # include < NDBT_Test . hpp > # include < NdbRestarter . hpp > # define CHECKNOTNULL ( p ) if ( ( p ) == NULL ) { ndbout << " Error ▁ at ▁ line ▁ " << __LINE__ << endl ; NDB_ERR ( trans -> getNdbError ( ) ) ; trans -> close ( ) ; return NDBT_FAILED ; } # define CHECKEQUAL ( v , e ) if ( ( e ) != ( v ) ) { ndbout << " Error ▁ at ▁ line ▁ " << __LINE__ << " ▁ expected ▁ " << v << endl ; NDB_ERR ( trans -> getNdbError ( ) ) ; trans -> close ( ) ; return NDBT_FAILED ; } Uint32 setLongVarchar ( char * where , const char * what , Uint32 sz ) { where [ 0 ] = sz & 0xff ; where [ 1 ] = ( sz >> 8 ) & 0xff ; memcpy ( & where [ 2 ] , what , sz ) ; return ( sz + 2 ) ; } int activateErrorInsert ( NdbTransaction * trans , const NdbRecord * record , const NdbDictionary :: Table * tab , const char * buf , NdbRestarter * restarter , Uint32 val ) { if ( restarter -> insertErrorInAllNodes ( val ) != 0 ) { g_err << " error ▁ insert ▁ 1 ▁ ( " << val << " ) ▁ failed " << endl ; return NDBT_FAILED ; } if ( restarter -> insertErrorInAllNodes ( val ) != 0 ) { g_err << " error ▁ insert ▁ 2 ▁ ( " << val << " ) ▁ failed " << endl ; return NDBT_FAILED ; } NdbOperation * insert = trans -> getNdbOperation ( tab ) ; CHECKNOTNULL ( insert ) ; CHECKEQUAL ( 0 , insert -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , insert -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , buf , 0 ) ) ) ; CHECKEQUAL ( 0 , insert -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , buf , 1 ) ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; return NDBT_OK ; } int testSegmentedSectionPk ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " WIDE _ 2COL " ) != 0 ) return NDBT_OK ; const Uint32 maxRowBytes = NDB_MAX_TUPLE_SIZE_IN_WORDS * sizeof ( Uint32 ) ; const Uint32 maxKeyBytes = NDBT_Tables :: MaxVarTypeKeyBytes ; const Uint32 maxAttrBytes = NDBT_Tables :: MaxKeyMaxVarTypeAttrBytes ; const Uint32 srcBuffBytes = MAX ( maxKeyBytes , maxAttrBytes ) ; char smallKey [ 50 ] ; char srcBuff [ srcBuffBytes ] ; char smallRowBuf [ maxRowBytes ] ; char bigKeyRowBuf [ maxRowBytes ] ; char bigAttrRowBuf [ maxRowBytes ] ; Uint32 smallKeySize = setLongVarchar ( & smallKey [ 0 ] , " ShortKey " , 8 ) ; memset ( srcBuff , ' B ' , srcBuffBytes ) ; const NdbRecord * record = ctx -> getTab ( ) -> getDefaultRecord ( ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , smallRowBuf , 0 ) , " ShortKey " , 8 ) ; NdbDictionary :: setNull ( record , smallRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , smallRowBuf , 1 ) , " ShortData " , 9 ) ; NdbDictionary :: setNull ( record , smallRowBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , bigKeyRowBuf , 0 ) , & srcBuff [ 0 ] , maxKeyBytes ) ; NdbDictionary :: setNull ( record , bigKeyRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , bigKeyRowBuf , 1 ) , " ShortData " , 9 ) ; NdbDictionary :: setNull ( record , bigKeyRowBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , bigAttrRowBuf , 0 ) , " ShortKey " , 8 ) ; NdbDictionary :: setNull ( record , bigAttrRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , bigAttrRowBuf , 1 ) , & srcBuff [ 0 ] , maxAttrBytes ) ; NdbDictionary :: setNull ( record , bigAttrRowBuf , 1 , false ) ; NdbRestarter restarter ; Ndb * pNdb = GETNDB ( step ) ; NdbTransaction * trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ; CHECKNOTNULL ( trans ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , record , ctx -> getTab ( ) , smallRowBuf , & restarter , 8065 ) ) ; const NdbOperation * bigInsert = trans -> insertTuple ( record , bigKeyRowBuf ) ; CHECKNOTNULL ( bigInsert ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsert = trans -> insertTuple ( record , bigAttrRowBuf ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsert = trans -> insertTuple ( record , bigAttrRowBuf ) ) ; const NdbOperation * secondOp ; CHECKNOTNULL ( secondOp = trans -> insertTuple ( record , bigAttrRowBuf ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; NdbOperation * bigInsertOldApi ; CHECKNOTNULL ( bigInsertOldApi = trans -> getNdbOperation ( ctx -> getTab ( ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , bigKeyRowBuf , 0 ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , bigKeyRowBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsertOldApi = trans -> getNdbOperation ( ctx -> getTab ( ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , bigAttrRowBuf , 0 ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , bigAttrRowBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; # if 0 restarter . insertErrorInAllNodes ( 8066 ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsertOldApi = trans -> getNdbOperation ( ctx -> getTab ( ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , smallRowBuf , 0 ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; restarter . insertErrorInAllNodes ( 8067 ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsertOldApi = trans -> getNdbOperation ( ctx -> getTab ( ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , smallRowBuf , 0 ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; # endif CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , record , ctx -> getTab ( ) , smallRowBuf , & restarter , 8068 ) ) ; trans -> execute ( NdbTransaction :: Rollback ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; return NDBT_OK ; } int testSegmentedSectionIx ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " WIDE _ 2COL _ IX " ) != 0 ) return NDBT_OK ; const char * indexName = " WIDE _ 2COL _ IX $ NDBT _ IDX0" ; const Uint32 maxRowBytes = NDB_MAX_TUPLE_SIZE_IN_WORDS * sizeof ( Uint32 ) ; const Uint32 srcBuffBytes = NDBT_Tables :: MaxVarTypeKeyBytes ; const Uint32 maxIndexKeyBytes = NDBT_Tables :: MaxKeyMaxVarTypeAttrBytesIndex ; const Uint32 mediumPrimaryKeyBytes = ( 6 * 60 * 4 ) - 2 ; char smallKey [ 50 ] ; char srcBuff [ srcBuffBytes ] ; char smallRowBuf [ maxRowBytes ] ; char bigKeyIxBuf [ maxRowBytes ] ; char bigAttrIxBuf [ maxRowBytes ] ; char bigKeyRowBuf [ maxRowBytes ] ; char resultSpace [ maxRowBytes ] ; Uint32 smallKeySize = setLongVarchar ( & smallKey [ 0 ] , " ShortKey " , 8 ) ; memset ( srcBuff , ' B ' , srcBuffBytes ) ; Ndb * pNdb = GETNDB ( step ) ; const NdbRecord * baseRecord = ctx -> getTab ( ) -> getDefaultRecord ( ) ; const NdbRecord * ixRecord = pNdb -> getDictionary ( ) -> getIndex ( indexName , ctx -> getTab ( ) -> getName ( ) ) -> getDefaultRecord ( ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 0 ) , " ShortKey " , 8 ) ; NdbDictionary :: setNull ( baseRecord , smallRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 1 ) , " ShortData " , 9 ) ; NdbDictionary :: setNull ( baseRecord , smallRowBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( ixRecord , bigKeyIxBuf , 1 ) , & srcBuff [ 0 ] , maxIndexKeyBytes ) ; NdbDictionary :: setNull ( ixRecord , bigKeyIxBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 0 ) , " ShortIXKey " , 10 ) ; NdbDictionary :: setNull ( baseRecord , bigAttrIxBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 1 ) , & srcBuff [ 0 ] , maxIndexKeyBytes ) ; NdbDictionary :: setNull ( baseRecord , bigAttrIxBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , bigKeyRowBuf , 0 ) , & srcBuff [ 0 ] , mediumPrimaryKeyBytes ) ; NdbDictionary :: setNull ( baseRecord , bigKeyRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , bigKeyRowBuf , 1 ) , " ShortIXKey " , 10 ) ; NdbDictionary :: setNull ( baseRecord , bigKeyRowBuf , 1 , false ) ; NdbTransaction * trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ; CHECKNOTNULL ( trans -> insertTuple ( baseRecord , bigKeyRowBuf ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: Commit ) ) ; NdbRestarter restarter ; trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ; CHECKNOTNULL ( trans ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , baseRecord , ctx -> getTab ( ) , smallRowBuf , & restarter , 8065 ) ) ; const NdbOperation * bigRead = trans -> readTuple ( ixRecord , bigKeyIxBuf , baseRecord , resultSpace ) ; CHECKNOTNULL ( bigRead ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( trans -> readTuple ( ixRecord , bigKeyIxBuf , baseRecord , resultSpace ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( trans -> readTuple ( ixRecord , bigKeyIxBuf , baseRecord , resultSpace ) ) ; CHECKNOTNULL ( trans -> readTuple ( ixRecord , bigKeyIxBuf , baseRecord , resultSpace ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , baseRecord , ctx -> getTab ( ) , smallRowBuf , & restarter , 8066 ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKNOTNULL ( bigRead = trans -> readTuple ( ixRecord , bigAttrIxBuf , baseRecord , resultSpace ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; # if 0 CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; const NdbDictionary :: Index * index ; CHECKNOTNULL ( index = pNdb -> getDictionary ( ) -> getIndex ( indexName , ctx -> getTab ( ) -> getName ( ) ) ) ; NdbIndexOperation * bigReadOldApi ; CHECKNOTNULL ( bigReadOldApi = trans -> getNdbIndexOperation ( index ) ) ; CHECKEQUAL ( 0 , bigReadOldApi -> readTuple ( ) ) ; CHECKEQUAL ( 0 , bigReadOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( ixRecord , bigKeyIxBuf , 1 ) ) ) ; CHECKNOTNULL ( bigReadOldApi -> getValue ( ( Uint32 ) 1 ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; NdbIndexOperation * bigUpdateOldApi ; CHECKNOTNULL ( bigUpdateOldApi = trans -> getNdbIndexOperation ( index ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> updateTuple ( ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> setValue ( ( Uint32 ) 1 , NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; restarter . insertErrorInAllNodes ( 8066 ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigUpdateOldApi = trans -> getNdbIndexOperation ( index ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> updateTuple ( ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> setValue ( ( Uint32 ) 1 , NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; restarter . insertErrorInAllNodes ( 8067 ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigUpdateOldApi = trans -> getNdbIndexOperation ( index ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> updateTuple ( ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> setValue ( ( Uint32 ) 1 , NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; # endif CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , baseRecord , ctx -> getTab ( ) , smallRowBuf , & restarter , 8068 ) ) ; trans -> execute ( NdbTransaction :: Rollback ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; return NDBT_OK ; } int testSegmentedSectionScan ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " WIDE _ 2COL " ) != 0 ) return NDBT_OK ; const Uint32 maxRowBytes = NDB_MAX_TUPLE_SIZE_IN_WORDS * sizeof ( Uint32 ) ; char smallKey [ 50 ] ; char smallRowBuf [ maxRowBytes ] ; Uint32 smallKeySize = setLongVarchar ( & smallKey [ 0 ] , " ShortKey " , 8 ) ; const NdbRecord * record = ctx -> getTab ( ) -> getDefaultRecord ( ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , smallRowBuf , 0 ) , " ShortKey " , 8 ) ; NdbDictionary :: setNull ( record , smallRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , smallRowBuf , 1 ) , " ShortData " , 9 ) ; NdbDictionary :: setNull ( record , smallRowBuf , 1 , false ) ; NdbRestarter restarter ; Ndb * pNdb = GETNDB ( step ) ; NdbTransaction * trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ; CHECKNOTNULL ( trans ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , record , ctx -> getTab ( ) , smallRowBuf , & restarter , 8066 ) ) ; NdbScanOperation * scan = trans -> getNdbScanOperation ( ctx -> getTab ( ) ) ; CHECKNOTNULL ( scan ) ; CHECKEQUAL ( 0 , scan -> readTuples ( ) ) ; NdbInterpretedCode prog ; for ( Uint32 w = 0 ; w < 2500 ; w ++ ) CHECKEQUAL ( 0 , prog . load_const_null ( 1 ) ) ; CHECKEQUAL ( 0 , prog . interpret_exit_ok ( ) ) ; CHECKEQUAL ( 0 , prog . finalise ( ) ) ; CHECKEQUAL ( 0 , scan -> setInterpretedCode ( & prog ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; CHECKEQUAL ( - 1 , scan -> nextResult ( ) ) ; CHECKEQUAL ( 217 , scan -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , record , ctx -> getTab ( ) , smallRowBuf , & restarter , 8068 ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: Rollback ) ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; return NDBT_OK ; } int testDropSignalFragments ( NDBT_Context * ctx , NDBT_Step * step ) { NdbRestarter restarter ; Ndb * pNdb = GETNDB ( step ) ; const Uint32 PROG_WORDS = 16500 ; struct SubCase { Uint32 errorInsertCode ; int expectedRc ; } ; const Uint32 numSubCases = 5 ; const SubCase cases [ numSubCases ] = { { 0 , 874 } , { 8074 , 217 } , { 8075 , 217 } , { 8076 , 217 } , { 8077 , 217 } } ; const Uint32 numIterations = 50 ; Uint32 buff [ PROG_WORDS + 10 ] ; for ( Uint32 iteration = 0 ; iteration < ( numIterations * numSubCases ) ; iteration ++ ) { NdbTransaction * trans = pNdb -> startTransaction ( ) ; CHECKNOTNULL ( trans ) ; SubCase subcase = cases [ iteration % numSubCases ] ; Uint32 errorInsertVal = subcase . errorInsertCode ; CHECKEQUAL ( 0 , restarter . insertErrorInAllNodes ( errorInsertVal ) ) ; CHECKEQUAL ( 0 , restarter . insertErrorInAllNodes ( errorInsertVal ) ) ; NdbScanOperation * scan = trans -> getNdbScanOperation ( ctx -> getTab ( ) ) ; CHECKNOTNULL ( scan ) ; CHECKEQUAL ( 0 , scan -> readTuples ( ) ) ; NdbInterpretedCode prog ( ctx -> getTab ( ) , buff , PROG_WORDS + 10 ) ; for ( Uint32 w = 0 ; w < PROG_WORDS ; w ++ ) CHECKEQUAL ( 0 , prog . load_const_null ( 1 ) ) ; CHECKEQUAL ( 0 , prog . interpret_exit_ok ( ) ) ; CHECKEQUAL ( 0 , prog . finalise ( ) ) ; CHECKEQUAL ( 0 , scan -> setInterpretedCode ( & prog ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; CHECKEQUAL ( - 1 , scan -> nextResult ( ) ) ; int expectedResult = subcase . expectedRc ; CHECKEQUAL ( expectedResult , scan -> getNdbError ( ) . code ) ; scan -> close ( ) ; trans -> close ( ) ; } restarter . insertErrorInAllNodes ( 0 ) ; return NDBT_OK ; } int create100Tables ( NDBT_Context * ctx , NDBT_Step * step ) { Ndb * pNdb = GETNDB ( step ) ; const NdbDictionary :: Table * pTab = ctx -> getTab ( ) ; if ( strcmp ( pTab -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; for ( Uint32 t = 0 ; t < 100 ; t ++ ) { char tabnameBuff [ 10 ] ; snprintf ( tabnameBuff , sizeof ( tabnameBuff ) , " TAB % u " , t ) ; NdbDictionary :: Table tab ; tab . setName ( tabnameBuff ) ; NdbDictionary :: Column pk ; pk . setName ( " PK " ) ; pk . setType ( NdbDictionary :: Column :: Varchar ) ; pk . setLength ( 20 ) ; pk . setNullable ( false ) ; pk . setPrimaryKey ( true ) ; tab . addColumn ( pk ) ; pNdb -> getDictionary ( ) -> dropTable ( tab . getName ( ) ) ; if ( pNdb -> getDictionary ( ) -> createTable ( tab ) != 0 ) { ndbout << " Create ▁ table ▁ failed ▁ with ▁ error ▁ : ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . code << " ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . message << endl ; return NDBT_FAILED ; } ndbout << " Created ▁ table ▁ " << tabnameBuff << endl ; } return NDBT_OK ; } int drop100Tables ( NDBT_Context * ctx , NDBT_Step * step ) { Ndb * pNdb = GETNDB ( step ) ; const NdbDictionary :: Table * pTab = ctx -> getTab ( ) ; if ( strcmp ( pTab -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; for ( Uint32 t = 0 ; t < 100 ; t ++ ) { char tabnameBuff [ 10 ] ; snprintf ( tabnameBuff , sizeof ( tabnameBuff ) , " TAB % u " , t ) ; if ( pNdb -> getDictionary ( ) -> dropTable ( tabnameBuff ) != 0 ) { ndbout << " Drop ▁ table ▁ failed ▁ with ▁ error ▁ : ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . code << " ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . message << endl ; } else { ndbout << " Dropped ▁ table ▁ " << tabnameBuff << endl ; } } return NDBT_OK ; } int dropTable ( NDBT_Context * ctx , NDBT_Step * step , Uint32 num ) { Ndb * pNdb = GETNDB ( step ) ; const NdbDictionary :: Table * pTab = ctx -> getTab ( ) ; if ( strcmp ( pTab -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; char tabnameBuff [ 10 ] ; snprintf ( tabnameBuff , sizeof ( tabnameBuff ) , " TAB % u " , num ) ; if ( pNdb -> getDictionary ( ) -> dropTable ( tabnameBuff ) != 0 ) { ndbout << " Drop ▁ table ▁ failed ▁ with ▁ error ▁ : ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . code << " ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . message << endl ; } else { ndbout << " Dropped ▁ table ▁ " << tabnameBuff << endl ; } return NDBT_OK ; } enum Scenarios { DROP_TABLE , RESTART_MASTER , RESTART_SLAVE , NUM_SCENARIOS } ; enum Tasks { WAIT = 0 , DROP_TABLE_REQ = 1 , MASTER_RESTART_REQ = 2 , SLAVE_RESTART_REQ = 3 } ; int testWorker ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; while ( ! ctx -> isTestStopped ( ) ) { ndbout_c ( " Worker ▁ : ▁ waiting ▁ for ▁ request . . . " ) ; ctx -> getPropertyWait ( " DIHWritesRequest " , 1 ) ; if ( ! ctx -> isTestStopped ( ) ) { Uint32 req = ctx -> getProperty ( " DIHWritesRequestType " , ( Uint32 ) 0 ) ; switch ( ( Tasks ) req ) { case DROP_TABLE_REQ : { ndbout_c ( " Worker ▁ : ▁ dropping ▁ table " ) ; if ( dropTable ( ctx , step , 2 ) != NDBT_OK ) { return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ table ▁ dropped . " ) ; break ; } case MASTER_RESTART_REQ : { ndbout_c ( " Worker ▁ : ▁ restarting ▁ Master " ) ; NdbRestarter restarter ; int master_nodeid = restarter . getMasterNodeId ( ) ; ndbout_c ( " Worker ▁ : ▁ Restarting ▁ Master ▁ ( % d ) . . . " , master_nodeid ) ; if ( restarter . restartOneDbNode2 ( master_nodeid , NdbRestarter :: NRRF_NOSTART | NdbRestarter :: NRRF_FORCE | NdbRestarter :: NRRF_ABORT ) || restarter . waitNodesNoStart ( & master_nodeid , 1 ) || restarter . startAll ( ) ) { ndbout_c ( " Worker ▁ : ▁ Error ▁ restarting ▁ Master . " ) ; return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ Waiting ▁ for ▁ master ▁ to ▁ recover . . . " ) ; if ( restarter . waitNodesStarted ( & master_nodeid , 1 ) ) { ndbout_c ( " Worker ▁ : ▁ Error ▁ waiting ▁ for ▁ Master ▁ restart " ) ; return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ Master ▁ recovered . " ) ; break ; } case SLAVE_RESTART_REQ : { NdbRestarter restarter ; int slave_nodeid = restarter . getRandomNotMasterNodeId ( rand ( ) ) ; ndbout_c ( " Worker ▁ : ▁ Restarting ▁ non - master ▁ ( % d ) . . . " , slave_nodeid ) ; if ( restarter . restartOneDbNode2 ( slave_nodeid , NdbRestarter :: NRRF_NOSTART | NdbRestarter :: NRRF_FORCE | NdbRestarter :: NRRF_ABORT ) || restarter . waitNodesNoStart ( & slave_nodeid , 1 ) || restarter . startAll ( ) ) { ndbout_c ( " Worker ▁ : ▁ Error ▁ restarting ▁ Slave . " ) ; return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ Waiting ▁ for ▁ slave ▁ to ▁ recover . . . " ) ; if ( restarter . waitNodesStarted ( & slave_nodeid , 1 ) ) { ndbout_c ( " Worker ▁ : ▁ Error ▁ waiting ▁ for ▁ Slave ▁ restart " ) ; return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ Slave ▁ recovered . " ) ; break ; } default : { break ; } } } ctx -> setProperty ( " DIHWritesRequestType " , ( Uint32 ) 0 ) ; ctx -> setProperty ( " DIHWritesRequest " , ( Uint32 ) 2 ) ; } ndbout_c ( " Worker , ▁ done . " ) ; return NDBT_OK ; } int testSlowDihFileWrites ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; NdbRestarter restarter ; for ( Uint32 scenario = 0 ; scenario < NUM_SCENARIOS ; scenario ++ ) { ndbout_c ( " Inserting ▁ error ▁ 7235" ) ; restarter . insertErrorInAllNodes ( 7235 ) ; ndbout_c ( " Triggering ▁ LCP " ) ; int dumpArg = 7099 ; restarter . dumpStateAllNodes ( & dumpArg , 1 ) ; const Uint32 periodSeconds = 10 ; Uint32 waitPeriods = 6 ; dumpArg = 7032 ; for ( Uint32 p = 0 ; p < waitPeriods ; p ++ ) { if ( p == 3 ) { switch ( ( Scenarios ) scenario ) { case DROP_TABLE : { ndbout_c ( " Requesting ▁ DROP ▁ TABLE " ) ; ctx -> setProperty ( " DIHWritesRequestType " , ( Uint32 ) DROP_TABLE_REQ ) ; ctx -> setProperty ( " DIHWritesRequest " , ( Uint32 ) 1 ) ; break ; } case RESTART_MASTER : { ndbout_c ( " Requesting ▁ Master ▁ restart " ) ; ctx -> setProperty ( " DIHWritesRequestType " , ( Uint32 ) MASTER_RESTART_REQ ) ; ctx -> setProperty ( " DIHWritesRequest " , ( Uint32 ) 1 ) ; break ; } case RESTART_SLAVE : { ndbout_c ( " Requesting ▁ Slave ▁ restart " ) ; ctx -> setProperty ( " DIHWritesRequestType " , ( Uint32 ) SLAVE_RESTART_REQ ) ; ctx -> setProperty ( " DIHWritesRequest " , ( Uint32 ) 1 ) ; break ; } default : break ; } } ndbout_c ( " Dumping ▁ DIH ▁ page ▁ info ▁ to ▁ ndbd ▁ stdout " ) ; restarter . dumpStateAllNodes ( & dumpArg , 1 ) ; NdbSleep_MilliSleep ( periodSeconds * 1000 ) ; } ndbout_c ( " Clearing ▁ error ▁ insert . . . " ) ; restarter . insertErrorInAllNodes ( 0 ) ; waitPeriods = 2 ; for ( Uint32 p = 0 ; p < waitPeriods ; p ++ ) { ndbout_c ( " Dumping ▁ DIH ▁ page ▁ info ▁ to ▁ ndbd ▁ stdout " ) ; restarter . dumpStateAllNodes ( & dumpArg , 1 ) ; NdbSleep_MilliSleep ( periodSeconds * 1000 ) ; } ndbout_c ( " Waiting ▁ for ▁ worker ▁ to ▁ finish ▁ task . . . " ) ; ctx -> getPropertyWait ( " DIHWritesRequest " , 2 ) ; if ( ctx -> isTestStopped ( ) ) return NDBT_OK ; ndbout_c ( " Done . " ) ; } ctx -> stopTest ( ) ; return NDBT_OK ; } NDBT_TESTSUITE ( testLimits ) ; TESTCASE ( " ExhaustSegmentedSectionPk " , " Test ▁ behaviour ▁ at ▁ Segmented ▁ Section ▁ exhaustion ▁ for ▁ PK " ) { INITIALIZER ( testSegmentedSectionPk ) ; } TESTCASE ( " ExhaustSegmentedSectionIX " , " Test ▁ behaviour ▁ at ▁ Segmented ▁ Section ▁ exhaustion ▁ for ▁ Unique ▁ index " ) { INITIALIZER ( testSegmentedSectionIx ) ; } TESTCASE ( " ExhaustSegmentedSectionScan " , " Test ▁ behaviour ▁ at ▁ Segmented ▁ Section ▁ exhaustion ▁ for ▁ Scan " ) { INITIALIZER ( testSegmentedSectionScan ) ; } TESTCASE ( " DropSignalFragments " , " Test ▁ behaviour ▁ of ▁ Segmented ▁ Section ▁ exhaustion ▁ with ▁ fragmented ▁ signals " ) { INITIALIZER ( testDropSignalFragments ) ; } TESTCASE ( " SlowDihFileWrites " , " Test ▁ behaviour ▁ of ▁ slow ▁ Dih ▁ table ▁ file ▁ writes " ) { INITIALIZER ( create100Tables ) ; STEP ( testWorker ) ; STEP ( testSlowDihFileWrites ) ; FINALIZER ( drop100Tables ) ; } NDBT_TESTSUITE_END ( testLimits ) ; int main ( int argc , const char * * argv ) { ndb_init ( ) ; NDBT_TESTSUITE_INSTANCE ( testLimits ) ; return testLimits . execute ( argc , argv ) ; } </DOCUMENT>
<DOCUMENT_ID="carvalhomb/tsmells/tree/master/sample/poco/poco/Net/src/ICMPPacket.cpp"> # include " Poco / Net / ICMPPacket . h " # include " Poco / Net / ICMPv4PacketImpl . h " # include " Poco / Net / NetException . h " # include " Poco / Timestamp . h " # include " Poco / Timespan . h " # include " Poco / Process . h " # include " Poco / NumberFormatter . h " # include < sstream > using Poco :: InvalidArgumentException ; using Poco :: NotImplementedException ; using Poco :: Timestamp ; using Poco :: Timespan ; using Poco :: Process ; using Poco :: NumberFormatter ; using Poco :: UInt8 ; using Poco :: UInt16 ; using Poco :: Int32 ; namespace Poco { namespace Net { ICMPPacket :: ICMPPacket ( IPAddress :: Family family , int dataSize ) : _pImpl ( 0 ) { if ( family == IPAddress :: IPv4 ) _pImpl = new ICMPv4PacketImpl ( dataSize ) ; # if POCO_HAVE_IPv6 else if ( family == IPAddress :: IPv6 ) throw NotImplementedException ( " ICMPv6 ▁ packets ▁ not ▁ implemented . " ) ; # endif else throw InvalidArgumentException ( " Invalid ▁ or ▁ unsupported ▁ address ▁ family ▁ passed ▁ to ▁ ICMPPacket " ) ; } ICMPPacket :: ~ ICMPPacket ( ) { delete _pImpl ; } void ICMPPacket :: setDataSize ( int dataSize ) { _pImpl -> setDataSize ( dataSize ) ; } int ICMPPacket :: getDataSize ( ) const { return _pImpl -> getDataSize ( ) ; } int ICMPPacket :: packetSize ( ) const { return _pImpl -> packetSize ( ) ; } int ICMPPacket :: maxPacketSize ( ) const { return _pImpl -> maxPacketSize ( ) ; } const Poco :: UInt8 * ICMPPacket :: packet ( ) { return _pImpl -> packet ( ) ; } struct timeval ICMPPacket :: time ( Poco :: UInt8 * buffer , int length ) const { return _pImpl -> time ( buffer , length ) ; } bool ICMPPacket :: validReplyID ( Poco :: UInt8 * buffer , int length ) const { return _pImpl -> validReplyID ( buffer , length ) ; } std :: string ICMPPacket :: errorDescription ( Poco :: UInt8 * buffer , int length ) { return _pImpl -> errorDescription ( buffer , length ) ; } std :: string ICMPPacket :: typeDescription ( int typeId ) { return _pImpl -> typeDescription ( typeId ) ; } } } </DOCUMENT>
<DOCUMENT_ID="asmaurya95/My-ACM-ICPC-Handbook/tree/master/Suffix Array/Naive Implementation.cpp"> # include < iostream > # include < string > # include < map > # include < algorithm > # include < vector > using namespace std ; int main ( ) { string s ; cin >> s ; map < string , int > m ; vector < string > ar ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { string sstr = s . substr ( i , s . size ( ) - i ) ; m [ sstr ] = i ; ar . push_back ( sstr ) ; } sort ( ar . begin ( ) , ar . end ( ) ) ; for ( int i = 0 ; i < ar . size ( ) ; i ++ ) { cout << m [ ar [ i ] ] << endl ; } return 0 ; } </DOCUMENT>
<DOCUMENT_ID="xdajog/samsung_sources_i927/tree/master/external/webkit/Source/WebKit2/Shared/DictionaryPopupInfo.cpp"> # include " config . h " # include " DictionaryPopupInfo . h " # include " WebCoreArgumentCoders . h " # if PLATFORM ( MAC ) # include " ArgumentCodersCF . h " # endif namespace WebKit { void DictionaryPopupInfo :: encode ( CoreIPC :: ArgumentEncoder * encoder ) const { encoder -> encode ( origin ) ; encoder -> encode ( fontInfo ) ; encoder -> encodeEnum ( type ) ; # if PLATFORM ( MAC ) && ! defined ( BUILDING_ON_SNOW_LEOPARD ) CoreIPC :: encode ( encoder , options . get ( ) ) ; # endif } bool DictionaryPopupInfo :: decode ( CoreIPC :: ArgumentDecoder * decoder , DictionaryPopupInfo & result ) { if ( ! decoder -> decode ( result . origin ) ) return false ; if ( ! decoder -> decode ( result . fontInfo ) ) return false ; if ( ! decoder -> decodeEnum ( result . type ) ) return false ; # if PLATFORM ( MAC ) && ! defined ( BUILDING_ON_SNOW_LEOPARD ) if ( ! CoreIPC :: decode ( decoder , result . options ) ) return false ; # endif return true ; } } </DOCUMENT>
<DOCUMENT_ID="fahhem/mbed-os/tree/master/targets/TARGET_NUVOTON/TARGET_M451/device/TOOLCHAIN_ARM_STD/sys.cpp"> # ifdef __cplusplus extern " C " { # endif # include < rt_misc . h > # include < stdint . h > extern char Image$$ARM_LIB_STACK$$ZI$$Limit [ ] ; extern char Image$$ARM_LIB_HEAP$$Base [ ] ; extern char Image$$ARM_LIB_HEAP$$ZI$$Limit [ ] ; extern __value_in_regs struct __initial_stackheap __user_setup_stackheap ( uint32_t R0 , uint32_t R1 , uint32_t R2 , uint32_t R3 ) { struct __initial_stackheap r ; r . heap_base = ( uint32_t ) Image$$ARM_LIB_HEAP$$Base ; r . heap_limit = ( uint32_t ) Image$$ARM_LIB_HEAP$$ZI$$Limit ; return r ; } # ifdef __cplusplus } # endif </DOCUMENT>
<DOCUMENT_ID="Maximus-/WinObjC/tree/master/deps/3rdparty/iculegacy/source/test/intltest/testidna.cpp"> # include " unicode / utypes . h " # if ! UCONFIG_NO_IDNA && ! UCONFIG_NO_TRANSLITERATION # include < time . h > # include < limits . h > # include < stdlib . h > # include < string . h > # include " unicode / localpointer . h " # include " unicode / ustring . h " # include " unicode / usprep . h " # include " unicode / uniset . h " # include " testidna . h " # include " idnaref . h " # include " nptrans . h " # include " unicode / putil . h " # include " idnaconf . h " static const UChar unicodeIn [ ] [ 41 ] = { { 0x0644 , 0x064A , 0x0647 , 0x0645 , 0x0627 , 0x0628 , 0x062A , 0x0643 , 0x0644 , 0x0645 , 0x0648 , 0x0634 , 0x0639 , 0x0631 , 0x0628 , 0x064A , 0x061F , 0x0000 } , { 0x4ED6 , 0x4EEC , 0x4E3A , 0x4EC0 , 0x4E48 , 0x4E0D , 0x8BF4 , 0x4E2D , 0x6587 , 0x0000 } , { 0x0050 , 0x0072 , 0x006F , 0x010D , 0x0070 , 0x0072 , 0x006F , 0x0073 , 0x0074 , 0x011B , 0x006E , 0x0065 , 0x006D , 0x006C , 0x0075 , 0x0076 , 0x00ED , 0x010D , 0x0065 , 0x0073 , 0x006B , 0x0079 , 0x0000 } , { 0x05DC , 0x05DE , 0x05D4 , 0x05D4 , 0x05DD , 0x05E4 , 0x05E9 , 0x05D5 , 0x05D8 , 0x05DC , 0x05D0 , 0x05DE , 0x05D3 , 0x05D1 , 0x05E8 , 0x05D9 , 0x05DD , 0x05E2 , 0x05D1 , 0x05E8 , 0x05D9 , 0x05EA , 0x0000 } , { 0x092F , 0x0939 , 0x0932 , 0x094B , 0x0917 , 0x0939 , 0x093F , 0x0928 , 0x094D , 0x0926 , 0x0940 , 0x0915 , 0x094D , 0x092F , 0x094B , 0x0902 , 0x0928 , 0x0939 , 0x0940 , 0x0902 , 0x092C , 0x094B , 0x0932 , 0x0938 , 0x0915 , 0x0924 , 0x0947 , 0x0939 , 0x0948 , 0x0902 , 0x0000 } , { 0x306A , 0x305C , 0x307F , 0x3093 , 0x306A , 0x65E5 , 0x672C , 0x8A9E , 0x3092 , 0x8A71 , 0x3057 , 0x3066 , 0x304F , 0x308C , 0x306A , 0x3044 , 0x306E , 0x304B , 0x0000 } , { 0x043F , 0x043E , 0x0447 , 0x0435 , 0x043C , 0x0443 , 0x0436 , 0x0435 , 0x043E , 0x043D , 0x0438 , 0x043D , 0x0435 , 0x0433 , 0x043E , 0x0432 , 0x043E , 0x0440 , 0x044F , 0x0442 , 0x043F , 0x043E , 0x0440 , 0x0443 , 0x0441 , 0x0441 , 0x043A , 0x0438 , 0x0000 } , { 0x0050 , 0x006F , 0x0072 , 0x0071 , 0x0075 , 0x00E9 , 0x006E , 0x006F , 0x0070 , 0x0075 , 0x0065 , 0x0064 , 0x0065 , 0x006E , 0x0073 , 0x0069 , 0x006D , 0x0070 , 0x006C , 0x0065 , 0x006D , 0x0065 , 0x006E , 0x0074 , 0x0065 , 0x0068 , 0x0061 , 0x0062 , 0x006C , 0x0061 , 0x0072 , 0x0065 , 0x006E , 0x0045 , 0x0073 , 0x0070 , 0x0061 , 0x00F1 , 0x006F , 0x006C , 0x0000 } , { 0x4ED6 , 0x5011 , 0x7232 , 0x4EC0 , 0x9EBD , 0x4E0D , 0x8AAA , 0x4E2D , 0x6587 , 0x0000 } , { 0x0054 , 0x1EA1 , 0x0069 , 0x0073 , 0x0061 , 0x006F , 0x0068 , 0x1ECD , 0x006B , 0x0068 , 0x00F4 , 0x006E , 0x0067 , 0x0074 , 0x0068 , 0x1EC3 , 0x0063 , 0x0068 , 0x1EC9 , 0x006E , 0x00F3 , 0x0069 , 0x0074 , 0x0069 , 0x1EBF , 0x006E , 0x0067 , 0x0056 , 0x0069 , 0x1EC7 , 0x0074 , 0x0000 } , { 0x0033 , 0x5E74 , 0x0042 , 0x7D44 , 0x91D1 , 0x516B , 0x5148 , 0x751F , 0x0000 } , { 0x5B89 , 0x5BA4 , 0x5948 , 0x7F8E , 0x6075 , 0x002D , 0x0077 , 0x0069 , 0x0074 , 0x0068 , 0x002D , 0x0053 , 0x0055 , 0x0050 , 0x0045 , 0x0052 , 0x002D , 0x004D , 0x004F , 0x004E , 0x004B , 0x0045 , 0x0059 , 0x0053 , 0x0000 } , { 0x0048 , 0x0065 , 0x006C , 0x006C , 0x006F , 0x002D , 0x0041 , 0x006E , 0x006F , 0x0074 , 0x0068 , 0x0065 , 0x0072 , 0x002D , 0x0057 , 0x0061 , 0x0079 , 0x002D , 0x305D , 0x308C , 0x305E , 0x308C , 0x306E , 0x5834 , 0x6240 , 0x0000 } , { 0x3072 , 0x3068 , 0x3064 , 0x5C4B , 0x6839 , 0x306E , 0x4E0B , 0x0032 , 0x0000 } , { 0x004D , 0x0061 , 0x006A , 0x0069 , 0x3067 , 0x004B , 0x006F , 0x0069 , 0x3059 , 0x308B , 0x0035 , 0x79D2 , 0x524D , 0x0000 } , { 0x30D1 , 0x30D5 , 0x30A3 , 0x30FC , 0x0064 , 0x0065 , 0x30EB , 0x30F3 , 0x30D0 , 0x0000 } , { 0x305D , 0x306E , 0x30B9 , 0x30D4 , 0x30FC , 0x30C9 , 0x3067 , 0x0000 } , { 0xD800 , 0xDF00 , 0xD800 , 0xDF01 , 0xD800 , 0xDF02 , 0xD800 , 0xDF03 , 0xD800 , 0xDF05 , 0xD800 , 0xDF06 , 0xD800 , 0xDF07 , 0xD800 , 0xDF09 , 0xD800 , 0xDF0A , 0xD800 , 0xDF0B , 0x0000 } , { 0xD800 , 0xDF0D , 0xD800 , 0xDF0C , 0xD800 , 0xDF1E , 0xD800 , 0xDF0F , 0xD800 , 0xDF16 , 0xD800 , 0xDF15 , 0xD800 , 0xDF14 , 0xD800 , 0xDF12 , 0xD800 , 0xDF10 , 0xD800 , 0xDF20 , 0xD800 , 0xDF21 , 0x0000 } , { 0x03b5 , 0x03bb , 0x03bb , 0x03b7 , 0x03bd , 0x03b9 , 0x03ba , 0x03ac } , { 0x0062 , 0x006f , 0x006e , 0x0121 , 0x0075 , 0x0073 , 0x0061 , 0x0127 , 0x0127 , 0x0061 } , { 0x043f , 0x043e , 0x0447 , 0x0435 , 0x043c , 0x0443 , 0x0436 , 0x0435 , 0x043e , 0x043d , 0x0438 , 0x043d , 0x0435 , 0x0433 , 0x043e , 0x0432 , 0x043e , 0x0440 , 0x044f , 0x0442 , 0x043f , 0x043e , 0x0440 , 0x0443 , 0x0441 , 0x0441 , 0x043a , 0x0438 } , { 0xFB00 , 0xFB01 } } ; static const char * asciiIn [ ] = { " xn - - egbpdaj6bu4bxfgehfvwxn " , " xn - - ihqwcrb4cv8a8dqg056pqjye " , " xn - - Proprostnemluvesky - uyb24dma41a " , " xn - -4dbcagdahymbxekheh6e0a7fei0b " , " xn - - i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd " , " xn - - n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa " , " xn - - b1abfaaepdrnnbgefbaDotcwatmq2g4l " , " xn - - PorqunopuedensimplementehablarenEspaol - fmd56a " , " xn - - ihqwctvzc91f659drss3x8bo0yb " , " xn - - TisaohkhngthchnitingVit - kjcr8268qyxafd2f1b9g " , " xn - -3B - ww4c5e180e575a65lsy2b " , " xn - - - with - SUPER - MONKEYS - pc58ag80a8qai00g7n9n " , " xn - - Hello - Another - Way - - fc4qua05auwb3674vfr0b " , " xn - -2 - u9tlzr9756bt3uc0v " , " xn - - MajiKoi5-783gue6qz075azm5e " , " xn - - de - jg4avhby1noc0d " , " xn - - d9juau41awczczp " , " XN - -097CCDEKGHQJK " , " XN - - db8CBHEJLGH4E0AL " , " xn - - hxargifdar " , " xn - - bonusaa - 5bb1da " , " xn - - b1abfaaepdrnnbgefbadotcwatmq2g4l " , " fffi " } ; static const char * domainNames [ ] = { " slip129-37-118-146 . nc . us . ibm . net " , " saratoga . pe . utexas . edu " , " dial - 120-45 . ots . utexas . edu " , " woo - 085 . dorms . waller . net " , " hd30-049 . hil . compuserve . com " , " pem203-31 . pe . ttu . edu " , "56K - 227 . MaxTNT3 . pdq . net " , " dial - 36-2 . ots . utexas . edu " , " slip129-37-23-152 . ga . us . ibm . net " , " ts45ip119 . cadvision . com " , " sdn - ts - 004txaustP05 . dialsprint . net " , " bar - tnt1s66 . erols . com " , "101 . st - louis - 15 . mo . dial - access . att . net " , " h92-245 . Arco . COM " , " dial - 13-2 . ots . utexas . edu " , " net - redynet29 . datamarkets . com . ar " , " ccs - shiva28 . reacciun . net . ve " , "7 . houston - 11 . tx . dial - access . att . net " , " ingw129-37-120-26 . mo . us . ibm . net " , " dialup6 . austintx . com " , " dns2 . tpao . gov . tr " , " slip129-37-119-194 . nc . us . ibm . net " , " cs7 . dillons . co . uk . 203.119.193 . in - addr . arpa " , " swprd1 . innovplace . saskatoon . sk . ca " , " bikini . bologna . maraut . it " , " node91 . subnet159-198-79 . baxter . com " , " cust19 . max5 . new - york . ny . ms . uu . net " , " balexander . slip . andrew . cmu . edu " , " pool029 . max2 . denver . co . dynip . alter . net " , " cust49 . max9 . new - york . ny . ms . uu . net " , " s61 . abq - dialin2 . hollyberry . com " , " \\u0917\\u0928\\u0947\\u0936 . sanjose . ibm . com " , " www . xn - - vea . com " , " www . \\u00C2\\u00A4 . com " , " www . \\u00C2\\u00A3 . com " , " \\u00C3\\u00BC . com " , } ; typedef struct ErrorCases ErrorCases ; static const struct ErrorCases { UChar unicode [ 100 ] ; const char * ascii ; UErrorCode expected ; UBool useSTD3ASCIIRules ; UBool testToUnicode ; UBool testLabel ; } errorCases [ ] = { { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0xC138 , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0x070F , 0xD55C , 0xAD6D , 0xC5B4 , 0xB97C , 0xC774 , 0xD574 , 0xD55C , 0xB2E4 , 0xBA74 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . XN - -8mb5595fsoa28orucya378bqre2tcwop06c5qbw82a1rffmae0361dea96b . com " , U_IDNA_PROHIBITED_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0xC138 , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0x0221 , 0x0234 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . XN - -6lA2Bz548Fj1GuA391Bf1Gb1N59Ab29A7iA . com " , U_IDNA_UNASSIGNED_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0xC138 , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0x0644 , 0x064A , 0x0647 , 0xD55C , 0xAD6D , 0xC5B4 , 0xB97C , 0xC774 , 0xD574 , 0xD55C , 0xB2E4 , 0xBA74 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . xn - - ghBGI4851OiyA33VqrD6Az86C4qF83CtRv93D5xBk15AzfG0nAgA0578DeA71C . com " , U_IDNA_CHECK_BIDI_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x002D , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0x002E , 0xD55C , 0xAD6D , 0xC5B4 , 0xB97C , 0xC774 , 0xD574 , 0xD55C , 0xB2E4 , 0xBA74 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . xn - - - - b95Ew8SqA315Ao5FbuMlnNmhA . com " , U_IDNA_STD3_ASCII_RULES_ERROR , TRUE , FALSE , FALSE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x0078 , 0x006e , 0x002d , 0x002d , 0x002D , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0x002D , 0xD55C , 0xAD6D , 0xC5B4 , 0xB97C , 0xC774 , 0xD574 , 0xD55C , 0xB2E4 , 0xBA74 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . XY - - - - - b91I0V65S96C2A355Cw1E5yCeQr19CsnP1mFfmAE0361DeA96B . com " , U_IDNA_ACE_PREFIX_ERROR , FALSE , FALSE , FALSE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0xC138 , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0xD55C , 0xAD6D , 0xC5B4 , 0xB97C , 0xC774 , 0xD574 , 0xD55C , 0xB2E4 , 0xBA74 , 0xC5BC , 0xB9C8 , 0xB098 , 0xC88B , 0xC744 , 0xAE4C , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . xn - -989AoMsVi5E83Db1D2A355Cv1E0vAk1DwRv93D5xBh15A0Dt30A5JpSD879Ccm6FeA98C . com " , U_IDNA_LABEL_TOO_LONG_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x0030 , 0x0644 , 0x064A , 0x0647 , 0x0031 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . xn - -01 - tvdmo . com " , U_IDNA_CHECK_BIDI_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x206C , 0x0644 , 0x064A , 0x0647 , 0x206D , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . XN - - ghbgi278xia . com " , U_IDNA_PROHIBITED_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x002D , 0x0041 , 0x0042 , 0x0043 , 0x0044 , 0x0045 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . - abcde . com " , U_IDNA_STD3_ASCII_RULES_ERROR , TRUE , FALSE , FALSE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x0041 , 0x0042 , 0x0043 , 0x0044 , 0x0045 , 0x002D , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . abcde - . com " , U_IDNA_STD3_ASCII_RULES_ERROR , TRUE , FALSE , FALSE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x0041 , 0x0042 , 0x0043 , 0x0044 , 0x0045 , 0x0040 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . abcde @ . com " , U_IDNA_STD3_ASCII_RULES_ERROR , TRUE , FALSE , FALSE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . . com " , U_IDNA_ZERO_LENGTH_LABEL_ERROR , TRUE , FALSE , FALSE } , { { 0 } , NULL , U_ILLEGAL_ARGUMENT_ERROR , TRUE , TRUE , FALSE } } ; # define MAX_DEST_SIZE 300 void TestIDNA :: debug ( const UChar * src , int32_t srcLength , int32_t options ) { UParseError parseError ; UErrorCode transStatus = U_ZERO_ERROR ; UErrorCode prepStatus = U_ZERO_ERROR ; NamePrepTransform * trans = NamePrepTransform :: createInstance ( parseError , transStatus ) ; int32_t prepOptions = ( ( ( options & UIDNA_ALLOW_UNASSIGNED ) != 0 ) ? USPREP_ALLOW_UNASSIGNED : 0 ) ; LocalUStringPrepProfilePointer prep ( usprep_openByType ( USPREP_RFC3491_NAMEPREP , & prepStatus ) ) ; UChar * transOut = NULL , * prepOut = NULL ; int32_t transOutLength = 0 , prepOutLength = 0 ; transOutLength = trans -> process ( src , srcLength , transOut , 0 , prepOptions > 0 , & parseError , transStatus ) ; if ( transStatus == U_BUFFER_OVERFLOW_ERROR ) { transStatus = U_ZERO_ERROR ; transOut = ( UChar * ) malloc ( U_SIZEOF_UCHAR * transOutLength ) ; transOutLength = trans -> process ( src , srcLength , transOut , transOutLength , prepOptions > 0 , & parseError , transStatus ) ; } prepOutLength = usprep_prepare ( prep . getAlias ( ) , src , srcLength , prepOut , 0 , prepOptions , & parseError , & prepStatus ) ; if ( prepStatus == U_BUFFER_OVERFLOW_ERROR ) { prepStatus = U_ZERO_ERROR ; prepOut = ( UChar * ) malloc ( U_SIZEOF_UCHAR * prepOutLength ) ; prepOutLength = usprep_prepare ( prep . getAlias ( ) , src , srcLength , prepOut , prepOutLength , prepOptions , & parseError , & prepStatus ) ; } if ( UnicodeString ( transOut , transOutLength ) != UnicodeString ( prepOut , prepOutLength ) ) { errln ( " Failed . ▁ Expected : ▁ " + prettify ( UnicodeString ( transOut , transOutLength ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( prepOut , prepOutLength ) ) ) ; } free ( transOut ) ; free ( prepOut ) ; delete trans ; } void TestIDNA :: testAPI ( const UChar * src , const UChar * expected , const char * testName , UBool useSTD3ASCIIRules , UErrorCode expectedStatus , UBool doCompare , UBool testUnassigned , TestFunc func , UBool testSTD3ASCIIRules ) { UErrorCode status = U_ZERO_ERROR ; UChar destStack [ MAX_DEST_SIZE ] ; int32_t destLen = 0 ; UChar * dest = NULL ; int32_t expectedLen = ( expected != NULL ) ? u_strlen ( expected ) : 0 ; int32_t options = ( useSTD3ASCIIRules == TRUE ) ? UIDNA_USE_STD3_RULES : UIDNA_DEFAULT ; UParseError parseError ; int32_t tSrcLen = 0 ; UChar * tSrc = NULL ; if ( src != NULL ) { tSrcLen = u_strlen ( src ) ; tSrc = ( UChar * ) malloc ( U_SIZEOF_UCHAR * tSrcLen ) ; memcpy ( tSrc , src , tSrcLen * U_SIZEOF_UCHAR ) ; } destLen = func ( src , - 1 , NULL , 0 , options , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options , & parseError , & status ) ; if ( U_SUCCESS ( status ) && expectedStatus != U_IDNA_STD3_ASCII_RULES_ERROR && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source . ▁ Expected ▁ : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( dest , destLen ) ) ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus ) { errcheckln ( status , " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; free ( tSrc ) ; return ; } if ( testUnassigned ) { status = U_ZERO_ERROR ; destLen = func ( src , - 1 , NULL , 0 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ " + prettify ( src ) + " ▁ with ▁ both ▁ options ▁ set . ▁ Expected : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) + " Got : ▁ " + prettify ( UnicodeString ( dest , destLen ) ) ) ; debug ( src , - 1 , options | UIDNA_ALLOW_UNASSIGNED ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } status = U_ZERO_ERROR ; destLen = func ( tSrc , tSrcLen , NULL , 0 , options , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } if ( testUnassigned ) { status = U_ZERO_ERROR ; destLen = func ( tSrc , tSrcLen , NULL , 0 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length ▁ and ▁ both ▁ options ▁ set . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } status = U_ZERO_ERROR ; if ( testSTD3ASCIIRules == TRUE ) { destLen = func ( src , - 1 , NULL , 0 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ both ▁ options ▁ set . ▁ Expected : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } status = U_ZERO_ERROR ; destLen = func ( tSrc , tSrcLen , NULL , 0 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length ▁ and ▁ both ▁ options ▁ set . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } free ( tSrc ) ; } void TestIDNA :: testCompare ( const UChar * s1 , int32_t s1Len , const UChar * s2 , int32_t s2Len , const char * testName , CompareFunc func , UBool isEqual ) { UErrorCode status = U_ZERO_ERROR ; int32_t retVal = func ( s1 , - 1 , s2 , - 1 , UIDNA_DEFAULT , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ null ▁ termniated ▁ strings . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , - 1 , s2 , - 1 , UIDNA_ALLOW_UNASSIGNED , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ null ▁ termniated ▁ strings ▁ with ▁ options ▁ set . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ and ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , s1Len , s2 , s2Len , UIDNA_DEFAULT , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ string ▁ length . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ with ▁ string ▁ length . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , s1Len , s2 , s2Len , UIDNA_ALLOW_UNASSIGNED , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ string ▁ length ▁ and ▁ options ▁ set . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ with ▁ string ▁ length ▁ and ▁ options ▁ set . ▁ Error : ▁ % s " , u_errorName ( status ) , testName ) ; } } void TestIDNA :: testToASCII ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testAPI ( unicodeIn [ i ] , buf , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; } } void TestIDNA :: testToUnicode ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( asciiIn ) / sizeof ( asciiIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testAPI ( buf , unicodeIn [ i ] , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; } } void TestIDNA :: testIDNToUnicode ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; UErrorCode status = U_ZERO_ERROR ; int32_t bufLen = 0 ; UParseError parseError ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( domainNames ) / sizeof ( domainNames [ 0 ] ) ) ; i ++ ) { bufLen = ( int32_t ) strlen ( domainNames [ i ] ) ; bufLen = u_unescape ( domainNames [ i ] , buf , bufLen + 1 ) ; func ( buf , bufLen , expected , MAX_DEST_SIZE , UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s " , testName , i , u_errorName ( status ) ) ; break ; } testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s ▁ \n " , testName , i , u_errorName ( status ) ) ; break ; } } } void TestIDNA :: testIDNToASCII ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; UErrorCode status = U_ZERO_ERROR ; int32_t bufLen = 0 ; UParseError parseError ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( domainNames ) / sizeof ( domainNames [ 0 ] ) ) ; i ++ ) { bufLen = ( int32_t ) strlen ( domainNames [ i ] ) ; bufLen = u_unescape ( domainNames [ i ] , buf , bufLen + 1 ) ; func ( buf , bufLen , expected , MAX_DEST_SIZE , UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s " , testName , i , u_errorName ( status ) ) ; break ; } testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , FALSE , TRUE , func ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s ▁ \n " , testName , i , u_errorName ( status ) ) ; break ; } } } void TestIDNA :: testCompare ( const char * testName , CompareFunc func ) { int32_t i ; UChar www [ ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UChar com [ ] = { 0x002E , 0x0043 , 0x004F , 0x004D , 0x0000 } ; UChar buf [ MAX_DEST_SIZE ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UnicodeString source ( www ) , uni0 ( www ) , uni1 ( www ) , ascii0 ( www ) , ascii1 ( www ) ; uni0 . append ( unicodeIn [ 0 ] ) ; uni0 . append ( com ) ; uni0 . append ( ( UChar ) 0x0000 ) ; uni1 . append ( unicodeIn [ 1 ] ) ; uni1 . append ( com ) ; uni1 . append ( ( UChar ) 0x0000 ) ; ascii0 . append ( asciiIn [ 0 ] ) ; ascii0 . append ( com ) ; ascii0 . append ( ( UChar ) 0x0000 ) ; ascii1 . append ( asciiIn [ 1 ] ) ; ascii1 . append ( com ) ; ascii1 . append ( ( UChar ) 0x0000 ) ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf + 4 , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; u_strcat ( buf , com ) ; source . truncate ( 4 ) ; source . append ( unicodeIn [ i ] ) ; source . append ( com ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; int32_t srcLen = u_strlen ( src ) ; testCompare ( src , srcLen , src , srcLen , testName , func , TRUE ) ; testCompare ( src , srcLen , buf , u_strlen ( buf ) , testName , func , TRUE ) ; if ( i == 0 ) { testCompare ( src , srcLen , uni1 . getBuffer ( ) , uni1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , uni0 . getBuffer ( ) , uni0 . length ( ) - 1 , testName , func , FALSE ) ; } if ( i == 0 ) { testCompare ( src , srcLen , ascii1 . getBuffer ( ) , ascii1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , ascii0 . getBuffer ( ) , ascii0 . length ( ) - 1 , testName , func , FALSE ) ; } } } # if 0 static int32_t getNextSeperator ( UChar * src , int32_t srcLength , UChar * * limit ) { if ( srcLength == - 1 ) { int32_t i ; for ( i = 0 ; ; i ++ ) { if ( src [ i ] == 0 ) { * limit = src + i ; return i ; } if ( src [ i ] == 0x002e ) { * limit = src + ( i + 1 ) ; return i ; } } if ( i == srcLength ) { * limit = src + srcLength ; } return i ; } else { int32_t i ; for ( i = 0 ; i < srcLength ; i ++ ) { if ( src [ i ] == 0x002e ) { * limit = src + ( i + 1 ) ; return i ; } } if ( i == srcLength ) { * limit = src + srcLength ; } return i ; } } void printPunycodeOutput ( ) { UChar dest [ MAX_DEST_SIZE ] ; int32_t destCapacity = MAX_DEST_SIZE ; UChar * start ; UChar * limit ; int32_t labelLen = 0 ; UBool caseFlags [ MAX_DEST_SIZE ] ; for ( int32_t i = 0 ; i < sizeof ( errorCases ) / sizeof ( errorCases [ 0 ] ) ; i ++ ) { ErrorCases errorCase = errorCases [ i ] ; UErrorCode status = U_ZERO_ERROR ; start = errorCase . unicode ; int32_t srcLen = u_strlen ( start ) ; labelLen = getNextSeperator ( start , srcLen , & limit ) ; start = limit ; labelLen = getNextSeperator ( start , srcLen - labelLen , & limit ) ; int32_t destLen = u_strToPunycode ( dest , destCapacity , start , labelLen , caseFlags , & status ) ; if ( U_FAILURE ( status ) ) { printf ( " u _ strToPunycode ▁ failed ▁ for ▁ index ▁ % i \n " , i ) ; continue ; } for ( int32_t j = 0 ; j < destLen ; j ++ ) { printf ( " % c " , ( char ) dest [ j ] ) ; } printf ( " \n " ) ; } } # endif void TestIDNA :: testErrorCases ( const char * IDNToASCIIName , TestFunc IDNToASCII , const char * IDNToUnicodeName , TestFunc IDNToUnicode ) { UChar buf [ MAX_DEST_SIZE ] ; int32_t bufLen = 0 ; for ( int32_t i = 0 ; i < ( int32_t ) ( sizeof ( errorCases ) / sizeof ( errorCases [ 0 ] ) ) ; i ++ ) { ErrorCases errorCase = errorCases [ i ] ; UChar * src = NULL ; if ( errorCase . ascii != NULL ) { bufLen = ( int32_t ) strlen ( errorCase . ascii ) ; u_charsToUChars ( errorCase . ascii , buf , bufLen + 1 ) ; } else { bufLen = 1 ; memset ( buf , 0 , U_SIZEOF_UCHAR * MAX_DEST_SIZE ) ; } if ( errorCase . unicode [ 0 ] != 0 ) { src = errorCase . unicode ; } testAPI ( src , buf , IDNToASCIIName , errorCase . useSTD3ASCIIRules , errorCase . expected , TRUE , TRUE , IDNToASCII ) ; if ( errorCase . testLabel == TRUE ) { testAPI ( src , buf , IDNToASCIIName , errorCase . useSTD3ASCIIRules , errorCase . expected , FALSE , TRUE , IDNToASCII ) ; } if ( errorCase . testToUnicode == TRUE ) { testAPI ( ( src == NULL ) ? NULL : buf , src , IDNToUnicodeName , errorCase . useSTD3ASCIIRules , errorCase . expected , TRUE , TRUE , IDNToUnicode ) ; } } } void TestIDNA :: testChaining ( const UChar * src , int32_t numIterations , const char * testName , UBool useSTD3ASCIIRules , UBool caseInsensitive , TestFunc func ) { UChar even [ MAX_DEST_SIZE ] ; UChar odd [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; int32_t i = 0 , evenLen = 0 , oddLen = 0 , expectedLen = 0 ; UErrorCode status = U_ZERO_ERROR ; int32_t srcLen = u_strlen ( src ) ; int32_t options = ( useSTD3ASCIIRules == TRUE ) ? UIDNA_USE_STD3_RULES : UIDNA_DEFAULT ; UParseError parseError ; expectedLen = func ( src , - 1 , expected , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , - 1 , even , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , - 1 , odd , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; } } status = U_ZERO_ERROR ; expectedLen = func ( src , - 1 , expected , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , - 1 , even , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , - 1 , odd , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; } } status = U_ZERO_ERROR ; expectedLen = func ( src , srcLen , expected , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , oddLen , even , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , evenLen , odd , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ source ▁ with ▁ source ▁ length ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ source ▁ with ▁ source ▁ length ▁ failed \n " , testName ) ; } } status = U_ZERO_ERROR ; expectedLen = func ( src , srcLen , expected , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , oddLen , even , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , evenLen , odd , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed \n " , testName ) ; } } } void TestIDNA :: testChaining ( const char * toASCIIName , TestFunc toASCII , const char * toUnicodeName , TestFunc toUnicode ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( asciiIn ) / sizeof ( asciiIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testChaining ( buf , 5 , toUnicodeName , FALSE , FALSE , toUnicode ) ; } for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { testChaining ( unicodeIn [ i ] , 5 , toASCIIName , FALSE , TRUE , toASCII ) ; } } void TestIDNA :: testRootLabelSeparator ( const char * testName , CompareFunc func , const char * IDNToASCIIName , TestFunc IDNToASCII , const char * IDNToUnicodeName , TestFunc IDNToUnicode ) { int32_t i ; UChar www [ ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UChar com [ ] = { 0x002E , 0x0043 , 0x004F , 0x004D , 0x002E , 0x0000 } ; UChar buf [ MAX_DEST_SIZE ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UnicodeString source ( www ) , uni0 ( www ) , uni1 ( www ) , ascii0 ( www ) , ascii1 ( www ) ; uni0 . append ( unicodeIn [ 0 ] ) ; uni0 . append ( com ) ; uni0 . append ( ( UChar ) 0x0000 ) ; uni1 . append ( unicodeIn [ 1 ] ) ; uni1 . append ( com ) ; uni1 . append ( ( UChar ) 0x0000 ) ; ascii0 . append ( asciiIn [ 0 ] ) ; ascii0 . append ( com ) ; ascii0 . append ( ( UChar ) 0x0000 ) ; ascii1 . append ( asciiIn [ 1 ] ) ; ascii1 . append ( com ) ; ascii1 . append ( ( UChar ) 0x0000 ) ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf + 4 , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; u_strcat ( buf , com ) ; source . truncate ( 4 ) ; source . append ( unicodeIn [ i ] ) ; source . append ( com ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; int32_t srcLen = u_strlen ( src ) ; testCompare ( src , srcLen , buf , u_strlen ( buf ) , testName , func , TRUE ) ; testCompare ( src , srcLen , src , srcLen , testName , func , TRUE ) ; testAPI ( src , buf , IDNToASCIIName , FALSE , U_ZERO_ERROR , TRUE , TRUE , IDNToASCII ) ; testAPI ( buf , src , IDNToUnicodeName , FALSE , U_ZERO_ERROR , TRUE , TRUE , IDNToUnicode ) ; if ( i == 0 ) { testCompare ( src , srcLen , uni1 . getBuffer ( ) , uni1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , uni0 . getBuffer ( ) , uni0 . length ( ) - 1 , testName , func , FALSE ) ; } if ( i == 0 ) { testCompare ( src , srcLen , ascii1 . getBuffer ( ) , ascii1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , ascii0 . getBuffer ( ) , ascii0 . length ( ) - 1 , testName , func , FALSE ) ; } } } extern IntlTest * createUTS46Test ( ) ; void TestIDNA :: runIndexedTest ( int32_t index , UBool exec , const char * & name , char * par ) { if ( exec ) logln ( ( UnicodeString ) " TestSuite ▁ IDNA ▁ API ▁ " ) ; switch ( index ) { case 0 : name = " TestToASCII " ; if ( exec ) TestToASCII ( ) ; break ; case 1 : name = " TestToUnicode " ; if ( exec ) TestToUnicode ( ) ; break ; case 2 : name = " TestIDNToASCII " ; if ( exec ) TestIDNToASCII ( ) ; break ; case 3 : name = " TestIDNToUnicode " ; if ( exec ) TestIDNToUnicode ( ) ; break ; case 4 : name = " TestCompare " ; if ( exec ) TestCompare ( ) ; break ; case 5 : name = " TestErrorCases " ; if ( exec ) TestErrorCases ( ) ; break ; case 6 : name = " TestChaining " ; if ( exec ) TestChaining ( ) ; break ; case 7 : name = " TestRootLabelSeparator " ; if ( exec ) TestRootLabelSeparator ( ) ; break ; case 8 : name = " TestCompareReferenceImpl " ; if ( exec ) TestCompareReferenceImpl ( ) ; break ; case 9 : name = " TestDataFile " ; if ( exec ) TestDataFile ( ) ; break ; # if ! UCONFIG_NO_FILE_IO && ! UCONFIG_NO_LEGACY_CONVERSION case 10 : name = " TestRefIDNA " ; if ( exec ) TestRefIDNA ( ) ; break ; case 11 : name = " TestIDNAMonkeyTest " ; if ( exec ) TestIDNAMonkeyTest ( ) ; break ; # else case 10 : case 11 : name = " skip " ; break ; # endif case 12 : { name = " TestConformanceTestVectors " ; if ( exec ) { logln ( " TestSuite ▁ IDNA ▁ conf - - - - " ) ; logln ( ) ; IdnaConfTest test ; callTest ( test , par ) ; } break ; } case 13 : name = " UTS46Test " ; if ( exec ) { logln ( " TestSuite ▁ UTS46Test - - - " ) ; logln ( ) ; LocalPointer < IntlTest > test ( createUTS46Test ( ) ) ; callTest ( * test , par ) ; } break ; default : name = " " ; break ; } } void TestIDNA :: TestToASCII ( ) { testToASCII ( " uidna _ toASCII " , uidna_toASCII ) ; } void TestIDNA :: TestToUnicode ( ) { testToUnicode ( " uidna _ toUnicode " , uidna_toUnicode ) ; } void TestIDNA :: TestIDNToASCII ( ) { testIDNToASCII ( " uidna _ IDNToASCII " , uidna_IDNToASCII ) ; } void TestIDNA :: TestIDNToUnicode ( ) { testIDNToUnicode ( " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; } void TestIDNA :: TestCompare ( ) { testCompare ( " uidna _ compare " , uidna_compare ) ; } void TestIDNA :: TestErrorCases ( ) { testErrorCases ( " uidna _ IDNToASCII " , uidna_IDNToASCII , " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; } void TestIDNA :: TestRootLabelSeparator ( ) { testRootLabelSeparator ( " uidna _ compare " , uidna_compare , " uidna _ IDNToASCII " , uidna_IDNToASCII , " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; } void TestIDNA :: TestChaining ( ) { testChaining ( " uidna _ toASCII " , uidna_toASCII , " uidna _ toUnicode " , uidna_toUnicode ) ; } static const int loopCount = 100 ; static const int maxCharCount = 20 ; static const int maxCodePoint = 0x10ffff ; static uint32_t randul ( ) { static UBool initialized = FALSE ; if ( ! initialized ) { srand ( ( unsigned ) time ( NULL ) ) ; initialized = TRUE ; } uint32_t l = 0 ; for ( uint32_t i = 0 ; i < sizeof ( l ) ; ++ i ) ( ( char * ) & l ) [ i ] = ( char ) ( ( rand ( ) & 0x0FF0 ) >> 4 ) ; return l ; } static int32_t rand_uni ( ) { int32_t retVal = ( int32_t ) ( randul ( ) & 0x3FFFF ) ; if ( retVal >= 0x30000 ) { retVal += 0xB0000 ; } return retVal ; } static int32_t randi ( int32_t n ) { return ( int32_t ) ( randul ( ) % ( n + 1 ) ) ; } void getTestSource ( UnicodeString & fillIn ) { int32_t i = 0 ; int32_t charCount = ( randi ( maxCharCount ) + 1 ) ; while ( i < charCount ) { int32_t codepoint = rand_uni ( ) ; if ( codepoint == 0x0000 ) { continue ; } fillIn . append ( ( UChar32 ) codepoint ) ; i ++ ; } } UnicodeString TestIDNA :: testCompareReferenceImpl ( UnicodeString & src , TestFunc refIDNA , const char * refIDNAName , TestFunc uIDNA , const char * uIDNAName , int32_t options ) { const UChar * srcUChars = src . getBuffer ( ) ; UChar exp [ MAX_DEST_SIZE ] = { 0 } ; int32_t expCap = MAX_DEST_SIZE , expLen = 0 ; UErrorCode expStatus = U_ZERO_ERROR ; UParseError parseError ; logln ( " Comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ for ▁ input : ▁ " + prettify ( srcUChars ) ) ; expLen = refIDNA ( srcUChars , src . length ( ) - 1 , exp , expCap , options , & parseError , & expStatus ) ; UChar got [ MAX_DEST_SIZE ] = { 0 } ; int32_t gotCap = MAX_DEST_SIZE , gotLen = 0 ; UErrorCode gotStatus = U_ZERO_ERROR ; gotLen = uIDNA ( srcUChars , src . length ( ) - 1 , got , gotCap , options , & parseError , & gotStatus ) ; if ( expStatus != gotStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ status ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( gotStatus ) ) + " ▁ for ▁ Source : ▁ " + prettify ( srcUChars ) + " ▁ Options : ▁ " + options ) ; return UnicodeString ( " " ) ; } if ( U_SUCCESS ( expStatus ) ) { if ( u_strCompare ( exp , expLen , got , gotLen , TRUE ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ output ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ Expected : ▁ " + prettify ( UnicodeString ( exp , expLen ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( got , gotLen ) ) + " ▁ for ▁ Source : ▁ " + prettify ( srcUChars ) + " ▁ Options : ▁ " + options ) ; } return UnicodeString ( exp , expLen ) ; } else { logln ( " Got ▁ the ▁ same ▁ error ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ for ▁ input : ▁ " + prettify ( srcUChars ) ) ; } return UnicodeString ( " " ) ; } void TestIDNA :: testCompareReferenceImpl ( const UChar * src , int32_t srcLen ) { UnicodeString label ( src , srcLen ) ; label . append ( ( UChar ) 0x0000 ) ; UnicodeString asciiLabel = testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_ALLOW_UNASSIGNED ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_DEFAULT ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_USE_STD3_RULES ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_USE_STD3_RULES | UIDNA_ALLOW_UNASSIGNED ) ; if ( asciiLabel . length ( ) != 0 ) { asciiLabel . append ( ( UChar ) 0x0000 ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_ALLOW_UNASSIGNED ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_DEFAULT ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_USE_STD3_RULES ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_USE_STD3_RULES | UIDNA_ALLOW_UNASSIGNED ) ; } } const char * failures [ ] = { " \\uAA42\\U0001F8DD\\U00019D01\\U000149A3\\uD385\\U000EE0F5\\U00018B92\\U000179D1\\U00018624\\U0002227F\\U000E83C0\\U000E8DCD\\u5460\\U00017F34\\U0001570B\\u43D1\\U0002C9C9\\U000281EC\\u2105\\U000180AE\\uC5D4" , " \\U0002F5A6\\uD638\\u0D0A\\u9E9C\\uFE5B\\U0001FCCB\\u66C4" , } ; void TestIDNA :: TestIDNAMonkeyTest ( ) { UnicodeString source ; UErrorCode status = U_ZERO_ERROR ; int i ; getInstance ( status ) ; if ( U_FAILURE ( status ) ) { dataerrln ( " Test ▁ could ▁ not ▁ initialize . ▁ Got ▁ % s " , u_errorName ( status ) ) ; return ; } for ( i = 0 ; i < loopCount ; i ++ ) { source . truncate ( 0 ) ; getTestSource ( source ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; } for ( i = 0 ; i < ( int ) ( sizeof ( failures ) / sizeof ( failures [ 0 ] ) ) ; i ++ ) { source . truncate ( 0 ) ; source . append ( UnicodeString ( failures [ i ] , - 1 , US_INV ) ) ; source = source . unescape ( ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; } source . truncate ( 0 ) ; source . append ( UNICODE_STRING_SIMPLE ( " \\uCF18\\U00021161\\U000EEF11\\U0002BB82\\U0001D63C " ) ) ; debug ( source . getBuffer ( ) , source . length ( ) , UIDNA_ALLOW_UNASSIGNED ) ; { UnicodeString source ( " \\u043f\\u00AD\\u034f\\u043e\\u0447\\u0435\\u043c\\u0443\\u0436\\u0435\\u043e\\u043d\\u0438\\u043d\\u0435\\u0433\\u043e\\u0432\\u043e\\u0440\\u044f\\u0442\\u043f\\u043e\\u0440\\u0443\\u0441\\u0441\\u043a\\u0438\\u0000" , - 1 , US_INV ) ; source = source . unescape ( ) ; UnicodeString expected ( " \\u043f\\u043e\\u0447\\u0435\\u043c\\u0443\\u0436\\u0435\\u043e\\u043d\\u0438\\u043d\\u0435\\u0433\\u043e\\u0432\\u043e\\u0440\\u044f\\u0442\\u043f\\u043e\\u0440\\u0443\\u0441\\u0441\\u043a\\u0438\\u0000" , - 1 , US_INV ) ; expected = expected . unescape ( ) ; UnicodeString ascii ( " xn - - b1abfaaepdrnnbgefbadotcwatmq2g4l " ) ; ascii . append ( ( UChar ) 0x0000 ) ; testAPI ( source . getBuffer ( ) , ascii . getBuffer ( ) , " uidna _ toASCII " , FALSE , U_ZERO_ERROR , TRUE , TRUE , uidna_toASCII ) ; testAPI ( source . getBuffer ( ) , ascii . getBuffer ( ) , " idnaref _ toASCII " , FALSE , U_ZERO_ERROR , TRUE , TRUE , idnaref_toASCII ) ; testCompareReferenceImpl ( source . getBuffer ( ) , source . length ( ) - 1 ) ; } } void TestIDNA :: TestCompareReferenceImpl ( ) { UChar src [ 2 ] = { 0 , 0 } ; int32_t srcLen = 0 ; for ( int32_t i = 0x40000 ; i < 0x10ffff ; i ++ ) { if ( quick == TRUE && i > 0x1FFFF ) { return ; } if ( i >= 0x30000 && i <= 0xF0000 ) { i += 0xB0000 ; } if ( i > 0xFFFF ) { src [ 0 ] = U16_LEAD ( i ) ; src [ 1 ] = U16_TRAIL ( i ) ; srcLen = 2 ; } else { src [ 0 ] = ( UChar ) i ; src [ 1 ] = 0 ; srcLen = 1 ; } testCompareReferenceImpl ( src , srcLen ) ; } } void TestIDNA :: TestRefIDNA ( ) { UErrorCode status = U_ZERO_ERROR ; getInstance ( status ) ; if ( U_FAILURE ( status ) ) { if ( status == U_FILE_ACCESS_ERROR ) { dataerrln ( " Test ▁ could ▁ not ▁ initialize . ▁ Got ▁ % s " , u_errorName ( status ) ) ; } return ; } testToASCII ( " idnaref _ toASCII " , idnaref_toASCII ) ; testToUnicode ( " idnaref _ toUnicode " , idnaref_toUnicode ) ; testIDNToASCII ( " idnaref _ IDNToASCII " , idnaref_IDNToASCII ) ; testIDNToUnicode ( " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testCompare ( " idnaref _ compare " , idnaref_compare ) ; testErrorCases ( " idnaref _ IDNToASCII " , idnaref_IDNToASCII , " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testChaining ( " idnaref _ toASCII " , idnaref_toASCII , " idnaref _ toUnicode " , idnaref_toUnicode ) ; testRootLabelSeparator ( " idnaref _ compare " , idnaref_compare , " idnaref _ IDNToASCII " , idnaref_IDNToASCII , " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testChaining ( " idnaref _ toASCII " , idnaref_toASCII , " idnaref _ toUnicode " , idnaref_toUnicode ) ; } void TestIDNA :: TestDataFile ( ) { testData ( * this ) ; } TestIDNA :: ~ TestIDNA ( ) { if ( gPrep != NULL ) { delete gPrep ; gPrep = NULL ; } } NamePrepTransform * TestIDNA :: gPrep = NULL ; NamePrepTransform * TestIDNA :: getInstance ( UErrorCode & status ) { if ( TestIDNA :: gPrep == NULL ) { UParseError parseError ; TestIDNA :: gPrep = NamePrepTransform :: createInstance ( parseError , status ) ; if ( TestIDNA :: gPrep == NULL ) { return NULL ; } } return TestIDNA :: gPrep ; } # endif </DOCUMENT>
<DOCUMENT_ID="waddlesplash/DolphinQt/tree/master/Externals/wxWidgets3/src/osx/carbon/textctrl.cpp"> # include " wx / wxprec . h " # if wxUSE_TEXTCTRL # include " wx / textctrl . h " # ifndef WX_PRECOMP # include " wx / intl . h " # include " wx / app . h " # include " wx / utils . h " # include " wx / dc . h " # include " wx / button . h " # include " wx / menu . h " # include " wx / settings . h " # include " wx / msgdlg . h " # include " wx / toplevel . h " # endif # ifdef __DARWIN__ # include < sys / types . h > # include < sys / stat . h > # else # include < stat . h > # endif # if wxUSE_STD_IOSTREAM # if wxUSE_IOSTREAMH # include < fstream . h > # else # include < fstream > # endif # endif # include " wx / filefn . h " # include " wx / sysopt . h " # include " wx / thread . h " # include " wx / osx / private . h " # include " wx / osx / carbon / private / mactext . h " class wxMacFunctor { public : wxMacFunctor ( ) { } virtual ~ wxMacFunctor ( ) { } virtual void * operator ( ) ( ) = 0 ; static void * CallBackProc ( void * param ) { wxMacFunctor * f = ( wxMacFunctor * ) param ; void * result = ( * f ) ( ) ; return result ; } } ; template < typename classtype , typename param1type > class wxMacObjectFunctor1 : public wxMacFunctor { typedef void ( classtype :: * function ) ( param1type p1 ) ; typedef void ( classtype :: * ref_function ) ( const param1type & p1 ) ; public : wxMacObjectFunctor1 ( classtype * obj , function f , param1type p1 ) : wxMacFunctor ( ) { m_object = obj ; m_function = f ; m_param1 = p1 ; } wxMacObjectFunctor1 ( classtype * obj , ref_function f , param1type p1 ) : wxMacFunctor ( ) { m_object = obj ; m_refFunction = f ; m_param1 = p1 ; } virtual ~ wxMacObjectFunctor1 ( ) { } virtual void * operator ( ) ( ) { ( m_object ->* m_function ) ( m_param1 ) ; return NULL ; } private : classtype * m_object ; param1type m_param1 ; union { function m_function ; ref_function m_refFunction ; } ; } ; template < typename classtype , typename param1type > void * wxMacMPRemoteCall ( classtype * object , void ( classtype :: * function ) ( param1type p1 ) , param1type p1 ) { wxMacObjectFunctor1 < classtype , param1type > params ( object , function , p1 ) ; void * result = MPRemoteCall ( wxMacFunctor :: CallBackProc , & params , kMPOwningProcessRemoteContext ) ; return result ; } template < typename classtype , typename param1type > void * wxMacMPRemoteCall ( classtype * object , void ( classtype :: * function ) ( const param1type & p1 ) , param1type p1 ) { wxMacObjectFunctor1 < classtype , param1type > params ( object , function , p1 ) ; void * result = MPRemoteCall ( wxMacFunctor :: CallBackProc , & params , kMPOwningProcessRemoteContext ) ; return result ; } template < typename classtype , typename param1type > void * wxMacMPRemoteGUICall ( classtype * object , void ( classtype :: * function ) ( param1type p1 ) , param1type p1 ) { wxMutexGuiLeave ( ) ; void * result = wxMacMPRemoteCall ( object , function , p1 ) ; wxMutexGuiEnter ( ) ; return result ; } template < typename classtype , typename param1type > void * wxMacMPRemoteGUICall ( classtype * object , void ( classtype :: * function ) ( const param1type & p1 ) , param1type p1 ) { wxMutexGuiLeave ( ) ; void * result = wxMacMPRemoteCall ( object , function , p1 ) ; wxMutexGuiEnter ( ) ; return result ; } class WXDLLEXPORT wxMacPortSaver { wxDECLARE_NO_COPY_CLASS ( wxMacPortSaver ) ; public : wxMacPortSaver ( GrafPtr port ) ; ~ wxMacPortSaver ( ) ; private : GrafPtr m_port ; } ; class WXDLLEXPORT wxMacWindowClipper : public wxMacPortSaver { wxDECLARE_NO_COPY_CLASS ( wxMacWindowClipper ) ; public : wxMacWindowClipper ( const wxWindow * win ) ; ~ wxMacWindowClipper ( ) ; private : GrafPtr m_newPort ; RgnHandle m_formerClip ; RgnHandle m_newClip ; } ; wxMacPortSaver :: wxMacPortSaver ( GrafPtr port ) { :: GetPort ( & m_port ) ; :: SetPort ( port ) ; } wxMacPortSaver :: ~ wxMacPortSaver ( ) { :: SetPort ( m_port ) ; } wxMacWindowClipper :: wxMacWindowClipper ( const wxWindow * win ) : wxMacPortSaver ( ( GrafPtr ) GetWindowPort ( ( WindowRef ) win -> MacGetTopLevelWindowRef ( ) ) ) { m_newPort = ( GrafPtr ) GetWindowPort ( ( WindowRef ) win -> MacGetTopLevelWindowRef ( ) ) ; m_formerClip = NewRgn ( ) ; m_newClip = NewRgn ( ) ; GetClip ( m_formerClip ) ; if ( win ) { if ( win -> GetPeer ( ) ) { int x = 0 , y = 0 ; win -> MacWindowToRootWindow ( & x , & y ) ; HIShapeGetAsQDRgn ( ( ( wxWindow * ) win ) -> MacGetVisibleRegion ( true ) . GetWXHRGN ( ) , m_newClip ) ; if ( ! EmptyRgn ( m_newClip ) ) OffsetRgn ( m_newClip , x , y ) ; } SetClip ( m_newClip ) ; } } wxMacWindowClipper :: ~ wxMacWindowClipper ( ) { SetPort ( m_newPort ) ; SetClip ( m_formerClip ) ; DisposeRgn ( m_newClip ) ; DisposeRgn ( m_formerClip ) ; } class wxMacMLTEControl : public wxMacControl , public wxTextWidgetImpl { public : wxMacMLTEControl ( wxTextCtrl * peer ) ; ~ wxMacMLTEControl ( ) { } virtual bool CanFocus ( ) const { return true ; } virtual wxString GetStringValue ( ) const ; virtual void SetStringValue ( const wxString & str ) ; static TXNFrameOptions FrameOptionsFromWXStyle ( long wxStyle ) ; void AdjustCreationAttributes ( const wxColour & background , bool visible ) ; virtual void SetFont ( const wxFont & font , const wxColour & foreground , long windowStyle , bool ignoreBlack ) ; virtual void SetBackgroundColour ( const wxColour & col ) ; virtual void SetStyle ( long start , long end , const wxTextAttr & style ) ; virtual void Copy ( ) ; virtual void Cut ( ) ; virtual void Paste ( ) ; virtual bool CanPaste ( ) const ; virtual void SetEditable ( bool editable ) ; virtual long GetLastPosition ( ) const ; virtual void Replace ( long from , long to , const wxString & str ) ; virtual void Remove ( long from , long to ) ; virtual void GetSelection ( long * from , long * to ) const ; virtual void SetSelection ( long from , long to ) ; virtual void WriteText ( const wxString & str ) ; virtual bool HasOwnContextMenu ( ) const { TXNCommandEventSupportOptions options ; TXNGetCommandEventSupport ( m_txn , & options ) ; return options & kTXNSupportEditCommandProcessing ; } virtual void CheckSpelling ( bool check ) { TXNSetSpellCheckAsYouType ( m_txn , ( Boolean ) check ) ; } virtual void Clear ( ) ; virtual bool CanUndo ( ) const ; virtual void Undo ( ) ; virtual bool CanRedo ( ) const ; virtual void Redo ( ) ; virtual int GetNumberOfLines ( ) const ; virtual long XYToPosition ( long x , long y ) const ; virtual bool PositionToXY ( long pos , long * x , long * y ) const ; virtual void ShowPosition ( long pos ) ; virtual int GetLineLength ( long lineNo ) const ; virtual wxString GetLineText ( long lineNo ) const ; void SetTXNData ( const wxString & st , TXNOffset start , TXNOffset end ) ; TXNObject GetTXNObject ( ) { return m_txn ; } protected : void TXNSetAttribute ( const wxTextAttr & style , long from , long to ) ; TXNObject m_txn ; } ; class wxMacMLTEHIViewControl : public wxMacMLTEControl { public : wxMacMLTEHIViewControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) ; virtual ~ wxMacMLTEHIViewControl ( ) ; virtual bool SetFocus ( ) ; virtual bool HasFocus ( ) const ; virtual void SetBackgroundColour ( const wxColour & col ) ; protected : HIViewRef m_scrollView ; HIViewRef m_textView ; } ; class wxMacMLTEClassicControl : public wxMacMLTEControl { public : wxMacMLTEClassicControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) ; virtual ~ wxMacMLTEClassicControl ( ) ; virtual void VisibilityChanged ( bool shown ) ; virtual void SuperChangedPosition ( ) ; virtual void MacControlUserPaneDrawProc ( wxInt16 part ) ; virtual wxInt16 MacControlUserPaneHitTestProc ( wxInt16 x , wxInt16 y ) ; virtual wxInt16 MacControlUserPaneTrackingProc ( wxInt16 x , wxInt16 y , void * actionProc ) ; virtual void MacControlUserPaneIdleProc ( ) ; virtual wxInt16 MacControlUserPaneKeyDownProc ( wxInt16 keyCode , wxInt16 charCode , wxInt16 modifiers ) ; virtual void MacControlUserPaneActivateProc ( bool activating ) ; virtual wxInt16 MacControlUserPaneFocusProc ( wxInt16 action ) ; virtual void MacControlUserPaneBackgroundProc ( void * info ) ; virtual bool SetupCursor ( const wxPoint & WXUNUSED ( pt ) ) { MacControlUserPaneIdleProc ( ) ; return true ; } virtual void Move ( int x , int y , int width , int height ) ; protected : OSStatus DoCreate ( ) ; void MacUpdatePosition ( ) ; void MacActivatePaneText ( bool setActive ) ; void MacFocusPaneText ( bool setFocus ) ; void MacSetObjectVisibility ( bool vis ) ; private : TXNFrameID m_txnFrameID ; GrafPtr m_txnPort ; WindowRef m_txnWindow ; Rect m_txnControlBounds ; Rect m_txnVisBounds ; static pascal void TXNScrollActionProc ( ControlRef controlRef , ControlPartCode partCode ) ; static pascal void TXNScrollInfoProc ( SInt32 iValue , SInt32 iMaximumValue , TXNScrollBarOrientation iScrollBarOrientation , SInt32 iRefCon ) ; ControlRef m_sbHorizontal ; SInt32 m_lastHorizontalValue ; ControlRef m_sbVertical ; SInt32 m_lastVerticalValue ; } ; wxWidgetImplType * wxWidgetImpl :: CreateTextControl ( wxTextCtrl * wxpeer , wxWindowMac * WXUNUSED ( parent ) , wxWindowID WXUNUSED ( id ) , const wxString & str , const wxPoint & pos , const wxSize & size , long style , long WXUNUSED ( extraStyle ) ) { return new wxMacMLTEHIViewControl ( wxpeer , str , pos , size , style ) ; } static const EventTypeSpec unicodeTextControlEventList [ ] = { { kEventClassControl , kEventControlSetFocusPart } , } ; static pascal OSStatus wxMacUnicodeTextControlControlEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; wxMacUnicodeTextControl * focus = ( wxMacUnicodeTextControl * ) data ; wxMacCarbonEvent cEvent ( event ) ; switch ( GetEventKind ( event ) ) { case kEventControlSetFocusPart : { ControlPartCode controlPart = cEvent . GetParameter < ControlPartCode > ( kEventParamControlPart , typeControlPartCode ) ; if ( controlPart == kControlFocusNoPart ) { focus -> GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & focus -> m_selection ) ; } result = CallNextEventHandler ( handler , event ) ; if ( controlPart != kControlFocusNoPart ) { focus -> SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & focus -> m_selection ) ; } break ; } default : break ; } return result ; } static pascal OSStatus wxMacUnicodeTextControlEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; switch ( GetEventClass ( event ) ) { case kEventClassControl : result = wxMacUnicodeTextControlControlEventHandler ( handler , event , data ) ; break ; default : break ; } return result ; } DEFINE_ONE_SHOT_HANDLER_GETTER ( wxMacUnicodeTextControlEventHandler ) wxMacUnicodeTextControl :: wxMacUnicodeTextControl ( wxTextCtrl * wxPeer ) : wxMacControl ( wxPeer ) , wxTextWidgetImpl ( wxPeer ) { } wxMacUnicodeTextControl :: wxMacUnicodeTextControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) : wxMacControl ( wxPeer ) , wxTextWidgetImpl ( wxPeer ) { m_font = wxPeer -> GetFont ( ) ; m_windowStyle = style ; m_selection . selStart = m_selection . selEnd = 0 ; Rect bounds = wxMacGetBoundsForControl ( wxPeer , pos , size ) ; wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; m_valueTag = kControlEditTextCFStringTag ; Boolean isPassword = ( m_windowStyle & wxTE_PASSWORD ) != 0 ; if ( isPassword ) { m_valueTag = kControlEditTextPasswordCFStringTag ; } OSStatus err = CreateEditUnicodeTextControl ( MAC_WXHWND ( wxPeer -> MacGetTopLevelWindowRef ( ) ) , & bounds , cf , isPassword , NULL , & m_controlRef ) ; verify_noerr ( err ) ; if ( ! ( m_windowStyle & wxTE_MULTILINE ) ) SetData < Boolean > ( kControlEditTextPart , kControlEditTextSingleLineTag , true ) ; InstallEventHandlers ( ) ; } void wxMacUnicodeTextControl :: InstallEventHandlers ( ) { :: InstallControlEventHandler ( m_controlRef , GetwxMacUnicodeTextControlEventHandlerUPP ( ) , GetEventTypeCount ( unicodeTextControlEventList ) , unicodeTextControlEventList , this , ( EventHandlerRef * ) & m_macTextCtrlEventHandler ) ; } wxMacUnicodeTextControl :: ~ wxMacUnicodeTextControl ( ) { :: RemoveEventHandler ( ( EventHandlerRef ) m_macTextCtrlEventHandler ) ; } void wxMacUnicodeTextControl :: VisibilityChanged ( bool shown ) { if ( ! ( m_windowStyle & wxTE_MULTILINE ) && shown ) { ControlEditTextSelectionRec sel ; CFStringRef value = NULL ; verify_noerr ( GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; verify_noerr ( GetData < CFStringRef > ( 0 , m_valueTag , & value ) ) ; verify_noerr ( SetData < CFStringRef > ( 0 , m_valueTag , & value ) ) ; verify_noerr ( SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; CFRelease ( value ) ; } } wxString wxMacUnicodeTextControl :: GetStringValue ( ) const { wxString result ; CFStringRef value = GetData < CFStringRef > ( 0 , m_valueTag ) ; if ( value ) { wxCFStringRef cf ( value ) ; result = cf . AsString ( ) ; } # if ' \n ' == 10 wxMacConvertNewlines13To10 ( & result ) ; # else wxMacConvertNewlines10To13 ( & result ) ; # endif return result ; } void wxMacUnicodeTextControl :: SetStringValue ( const wxString & str ) { wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; verify_noerr ( SetData < CFStringRef > ( 0 , m_valueTag , cf ) ) ; } void wxMacUnicodeTextControl :: Copy ( ) { SendHICommand ( kHICommandCopy ) ; } void wxMacUnicodeTextControl :: Cut ( ) { SendHICommand ( kHICommandCut ) ; } void wxMacUnicodeTextControl :: Paste ( ) { SendHICommand ( kHICommandPaste ) ; } bool wxMacUnicodeTextControl :: CanPaste ( ) const { return true ; } void wxMacUnicodeTextControl :: SetEditable ( bool WXUNUSED ( editable ) ) { # if 0 SetData < Boolean > ( kControlEditTextPart , kControlEditTextLockedTag , ( Boolean ) ! editable ) ; # endif } void wxMacUnicodeTextControl :: GetSelection ( long * from , long * to ) const { ControlEditTextSelectionRec sel ; if ( HasFocus ( ) ) verify_noerr ( GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; else sel = m_selection ; if ( from ) * from = sel . selStart ; if ( to ) * to = sel . selEnd ; } void wxMacUnicodeTextControl :: SetSelection ( long from , long to ) { ControlEditTextSelectionRec sel ; wxString result ; int textLength = 0 ; CFStringRef value = GetData < CFStringRef > ( 0 , m_valueTag ) ; if ( value ) { wxCFStringRef cf ( value ) ; textLength = cf . AsString ( ) . length ( ) ; } if ( ( from == - 1 ) && ( to == - 1 ) ) { from = 0 ; to = textLength ; } else { from = wxMin ( textLength , wxMax ( from , 0 ) ) ; if ( to == - 1 ) to = textLength ; else to = wxMax ( 0 , wxMin ( textLength , to ) ) ; } sel . selStart = from ; sel . selEnd = to ; if ( HasFocus ( ) ) SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ; else m_selection = sel ; } void wxMacUnicodeTextControl :: WriteText ( const wxString & str ) { if ( ! wxIsMainThread ( ) ) { # if wxOSX_USE_CARBON wxMacMPRemoteGUICall < wxTextCtrl , wxString > ( ( wxTextCtrl * ) GetWXPeer ( ) , & wxTextCtrl :: WriteText , str ) ; # endif return ; } wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; if ( HasFocus ( ) ) { wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; CFStringRef value = cf ; SetData < CFStringRef > ( 0 , kControlEditTextInsertCFStringRefTag , & value ) ; } else { wxString val = GetStringValue ( ) ; long start , end ; GetSelection ( & start , & end ) ; val . Remove ( start , end - start ) ; val . insert ( start , str ) ; SetStringValue ( val ) ; SetSelection ( start + str . length ( ) , start + str . length ( ) ) ; } } class wxMacEditHelper { public : wxMacEditHelper ( TXNObject txn ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; m_txn = txn ; TXNGetTXNObjectControls ( m_txn , 1 , tag , m_data ) ; if ( m_data [ 0 ] . uValue == kTXNReadOnly ) { TXNControlData data [ ] = { { kTXNReadWrite } } ; TXNSetTXNObjectControls ( m_txn , false , 1 , tag , data ) ; } } ~ wxMacEditHelper ( ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; if ( m_data [ 0 ] . uValue == kTXNReadOnly ) TXNSetTXNObjectControls ( m_txn , false , 1 , tag , m_data ) ; } protected : TXNObject m_txn ; TXNControlData m_data [ 1 ] ; } ; wxMacMLTEControl :: wxMacMLTEControl ( wxTextCtrl * peer ) : wxMacControl ( peer ) , wxTextWidgetImpl ( peer ) { SetNeedsFocusRect ( true ) ; } wxString wxMacMLTEControl :: GetStringValue ( ) const { wxString result ; OSStatus err ; Size actualSize = 0 ; { # if wxUSE_UNICODE Handle theText ; err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNUnicodeTextData ) ; if ( err != noErr ) { actualSize = 0 ; } else { actualSize = GetHandleSize ( theText ) / sizeof ( UniChar ) ; if ( actualSize > 0 ) { wxChar * ptr = NULL ; SetHandleSize ( theText , ( actualSize + 1 ) * sizeof ( UniChar ) ) ; HLock ( theText ) ; ( ( ( UniChar * ) * theText ) [ actualSize ] ) = 0 ; wxMBConvUTF16 converter ; size_t noChars = converter . MB2WC ( NULL , ( const char * ) * theText , 0 ) ; wxASSERT_MSG ( noChars != wxCONV_FAILED , wxT ( " Unable ▁ to ▁ count ▁ the ▁ number ▁ of ▁ characters ▁ in ▁ this ▁ string ! " ) ) ; ptr = new wxChar [ noChars + 1 ] ; noChars = converter . MB2WC ( ptr , ( const char * ) * theText , noChars + 1 ) ; wxASSERT_MSG ( noChars != wxCONV_FAILED , wxT ( " Conversion ▁ of ▁ string ▁ failed ! " ) ) ; ptr [ noChars ] = 0 ; HUnlock ( theText ) ; ptr [ actualSize ] = 0 ; result = wxString ( ptr ) ; delete [ ] ptr ; } DisposeHandle ( theText ) ; } # else Handle theText ; err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNTextData ) ; if ( err != noErr ) { actualSize = 0 ; } else { actualSize = GetHandleSize ( theText ) ; if ( actualSize > 0 ) { HLock ( theText ) ; result = wxString ( * theText , wxConvLocal , actualSize ) ; HUnlock ( theText ) ; } DisposeHandle ( theText ) ; } # endif } # if ' \n ' == 10 wxMacConvertNewlines13To10 ( & result ) ; # else wxMacConvertNewlines10To13 ( & result ) ; # endif return result ; } void wxMacMLTEControl :: SetStringValue ( const wxString & str ) { wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif { wxMacEditHelper help ( m_txn ) ; SetTXNData ( st , kTXNStartOffset , kTXNEndOffset ) ; } TXNSetSelection ( m_txn , 0 , 0 ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; } } TXNFrameOptions wxMacMLTEControl :: FrameOptionsFromWXStyle ( long wxStyle ) { TXNFrameOptions frameOptions = kTXNDontDrawCaretWhenInactiveMask ; frameOptions |= kTXNDoFontSubstitutionMask ; if ( ! ( wxStyle & wxTE_NOHIDESEL ) ) frameOptions |= kTXNDontDrawSelectionWhenInactiveMask ; if ( wxStyle & ( wxHSCROLL | wxTE_DONTWRAP ) ) frameOptions |= kTXNWantHScrollBarMask ; if ( wxStyle & wxTE_MULTILINE ) { if ( ! ( wxStyle & wxTE_DONTWRAP ) ) frameOptions |= kTXNAlwaysWrapAtViewEdgeMask ; if ( ! ( wxStyle & wxTE_NO_VSCROLL ) ) { frameOptions |= kTXNWantVScrollBarMask ; } } else { frameOptions |= kTXNSingleLineOnlyMask ; } return frameOptions ; } void wxMacMLTEControl :: AdjustCreationAttributes ( const wxColour & background , bool WXUNUSED ( visible ) ) { TXNControlTag iControlTags [ ] = { kTXNDoFontSubstitution , kTXNWordWrapStateTag , } ; TXNControlData iControlData [ ] = { { true } , { kTXNNoAutoWrap } , } ; int toptag = WXSIZEOF ( iControlTags ) ; if ( m_windowStyle & wxTE_MULTILINE ) { iControlData [ 1 ] . uValue = ( m_windowStyle & wxTE_DONTWRAP ) ? kTXNNoAutoWrap : kTXNAutoWrap ; } OSStatus err = TXNSetTXNObjectControls ( m_txn , false , toptag , iControlTags , iControlData ) ; verify_noerr ( err ) ; Str255 fontName ; SInt16 fontSize ; Style fontStyle ; GetThemeFont ( kThemeSystemFont , GetApplicationScript ( ) , fontName , & fontSize , & fontStyle ) ; TXNTypeAttributes typeAttr [ ] = { { kTXNQDFontNameAttribute , kTXNQDFontNameAttributeSize , { ( void * ) fontName } } , { kTXNQDFontSizeAttribute , kTXNFontSizeAttributeSize , { ( void * ) ( fontSize << 16 ) } } , { kTXNQDFontStyleAttribute , kTXNQDFontStyleAttributeSize , { ( void * ) normal } } , } ; err = TXNSetTypeAttributes ( m_txn , WXSIZEOF ( typeAttr ) , typeAttr , kTXNStartOffset , kTXNEndOffset ) ; verify_noerr ( err ) ; if ( m_windowStyle & wxTE_PASSWORD ) { UniChar c = 0x00A5 ; err = TXNEchoMode ( m_txn , c , 0 , true ) ; verify_noerr ( err ) ; } TXNBackground tback ; tback . bgType = kTXNBackgroundTypeRGB ; background . GetRGBColor ( & tback . bg . color ) ; TXNSetBackground ( m_txn , & tback ) ; TXNCommandEventSupportOptions options ; if ( TXNGetCommandEventSupport ( m_txn , & options ) == noErr ) { options |= kTXNSupportEditCommandProcessing | kTXNSupportEditCommandUpdating | kTXNSupportFontCommandProcessing | kTXNSupportFontCommandUpdating ; bool checkSpelling = false ; if ( ! ( m_windowStyle & wxTE_READONLY ) ) { # if wxUSE_SYSTEM_OPTIONS if ( wxSystemOptions :: HasOption ( wxMAC_TEXTCONTROL_USE_SPELL_CHECKER ) && ( wxSystemOptions :: GetOptionInt ( wxMAC_TEXTCONTROL_USE_SPELL_CHECKER ) == 1 ) ) { checkSpelling = true ; } # endif } if ( checkSpelling ) options |= kTXNSupportSpellCheckCommandProcessing | kTXNSupportSpellCheckCommandUpdating ; TXNSetCommandEventSupport ( m_txn , options ) ; } } void wxMacMLTEControl :: SetBackgroundColour ( const wxColour & col ) { TXNBackground tback ; tback . bgType = kTXNBackgroundTypeRGB ; col . GetRGBColor ( & tback . bg . color ) ; TXNSetBackground ( m_txn , & tback ) ; } static inline int wxConvertToTXN ( int x ) { return static_cast < int > ( x / 254.0 * 72 + 0.5 ) ; } void wxMacMLTEControl :: TXNSetAttribute ( const wxTextAttr & style , long from , long to ) { TXNTypeAttributes typeAttr [ 4 ] ; RGBColor color ; size_t typeAttrCount = 0 ; TXNMargins margins ; TXNControlTag controlTags [ 4 ] ; TXNControlData controlData [ 4 ] ; size_t controlAttrCount = 0 ; TXNTab * tabs = NULL ; bool relayout = false ; wxFont font ; if ( style . HasFont ( ) ) { wxASSERT ( typeAttrCount < WXSIZEOF ( typeAttr ) ) ; font = style . GetFont ( ) ; typeAttr [ typeAttrCount ] . tag = kTXNATSUIStyle ; typeAttr [ typeAttrCount ] . size = kTXNATSUIStyleSize ; typeAttr [ typeAttrCount ] . data . dataPtr = font . MacGetATSUStyle ( ) ; typeAttrCount ++ ; } if ( style . HasTextColour ( ) ) { wxASSERT ( typeAttrCount < WXSIZEOF ( typeAttr ) ) ; style . GetTextColour ( ) . GetRGBColor ( & color ) ; typeAttr [ typeAttrCount ] . tag = kTXNQDFontColorAttribute ; typeAttr [ typeAttrCount ] . size = kTXNQDFontColorAttributeSize ; typeAttr [ typeAttrCount ] . data . dataPtr = ( void * ) & color ; typeAttrCount ++ ; } if ( style . HasAlignment ( ) ) { wxASSERT ( controlAttrCount < WXSIZEOF ( controlTags ) ) ; SInt32 align ; switch ( style . GetAlignment ( ) ) { case wxTEXT_ALIGNMENT_LEFT : align = kTXNFlushLeft ; break ; case wxTEXT_ALIGNMENT_CENTRE : align = kTXNCenter ; break ; case wxTEXT_ALIGNMENT_RIGHT : align = kTXNFlushRight ; break ; case wxTEXT_ALIGNMENT_JUSTIFIED : align = kTXNFullJust ; break ; default : case wxTEXT_ALIGNMENT_DEFAULT : align = kTXNFlushDefault ; break ; } controlTags [ controlAttrCount ] = kTXNJustificationTag ; controlData [ controlAttrCount ] . sValue = align ; controlAttrCount ++ ; } if ( style . HasLeftIndent ( ) || style . HasRightIndent ( ) ) { wxASSERT ( controlAttrCount < WXSIZEOF ( controlTags ) ) ; controlTags [ controlAttrCount ] = kTXNMarginsTag ; controlData [ controlAttrCount ] . marginsPtr = & margins ; verify_noerr ( TXNGetTXNObjectControls ( m_txn , 1 , & controlTags [ controlAttrCount ] , & controlData [ controlAttrCount ] ) ) ; if ( style . HasLeftIndent ( ) ) { margins . leftMargin = wxConvertToTXN ( style . GetLeftIndent ( ) ) ; } if ( style . HasRightIndent ( ) ) { margins . rightMargin = wxConvertToTXN ( style . GetRightIndent ( ) ) ; } controlAttrCount ++ ; } if ( style . HasTabs ( ) ) { const wxArrayInt & tabarray = style . GetTabs ( ) ; controlTags [ controlAttrCount ] = kTXNTabSettingsTag ; if ( tabarray . size ( ) > 0 ) controlData [ controlAttrCount ] . tabValue . value = wxConvertToTXN ( tabarray [ 0 ] ) ; else controlData [ controlAttrCount ] . tabValue . value = 72 ; controlData [ controlAttrCount ] . tabValue . tabType = kTXNLeftTab ; controlAttrCount ++ ; } if ( controlAttrCount > 0 ) { verify_noerr ( TXNSetTXNObjectControls ( m_txn , false , controlAttrCount , controlTags , controlData ) ) ; relayout = true ; } if ( typeAttrCount > 0 ) { verify_noerr ( TXNSetTypeAttributes ( m_txn , typeAttrCount , typeAttr , from , to ) ) ; if ( from != to ) relayout = true ; } if ( tabs != NULL ) { delete [ ] tabs ; } if ( relayout ) { TXNRecalcTextLayout ( m_txn ) ; } } void wxMacMLTEControl :: SetFont ( const wxFont & font , const wxColour & foreground , long WXUNUSED ( windowStyle ) , bool WXUNUSED ( ignoreBlack ) ) { wxMacEditHelper help ( m_txn ) ; TXNSetAttribute ( wxTextAttr ( foreground , wxNullColour , font ) , kTXNStartOffset , kTXNEndOffset ) ; } void wxMacMLTEControl :: SetStyle ( long start , long end , const wxTextAttr & style ) { wxMacEditHelper help ( m_txn ) ; TXNSetAttribute ( style , start , end ) ; } void wxMacMLTEControl :: Copy ( ) { TXNCopy ( m_txn ) ; } void wxMacMLTEControl :: Cut ( ) { TXNCut ( m_txn ) ; } void wxMacMLTEControl :: Paste ( ) { TXNPaste ( m_txn ) ; } bool wxMacMLTEControl :: CanPaste ( ) const { return TXNIsScrapPastable ( ) ; } void wxMacMLTEControl :: SetEditable ( bool editable ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; TXNControlData data [ ] = { { editable ? kTXNReadWrite : kTXNReadOnly } } ; TXNSetTXNObjectControls ( m_txn , false , WXSIZEOF ( tag ) , tag , data ) ; } long wxMacMLTEControl :: GetLastPosition ( ) const { wxTextPos actualsize = 0 ; Handle theText ; # if wxUSE_UNICODE OSErr err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNUnicodeTextData ) ; if ( err == noErr ) { actualsize = GetHandleSize ( theText ) / sizeof ( UniChar ) ; DisposeHandle ( theText ) ; } # else OSErr err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNTextData ) ; if ( err == noErr ) { actualsize = GetHandleSize ( theText ) ; DisposeHandle ( theText ) ; } # endif else { actualsize = 0 ; } return actualsize ; } void wxMacMLTEControl :: Replace ( long from , long to , const wxString & str ) { wxString value = str ; wxMacConvertNewlines10To13 ( & value ) ; wxMacEditHelper help ( m_txn ) ; # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif TXNSetSelection ( m_txn , from , to == - 1 ? kTXNEndOffset : to ) ; TXNClear ( m_txn ) ; SetTXNData ( value , kTXNUseCurrentSelection , kTXNUseCurrentSelection ) ; } void wxMacMLTEControl :: Remove ( long from , long to ) { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif wxMacEditHelper help ( m_txn ) ; TXNSetSelection ( m_txn , from , to ) ; TXNClear ( m_txn ) ; } void wxMacMLTEControl :: GetSelection ( long * from , long * to ) const { TXNOffset f , t ; TXNGetSelection ( m_txn , & f , & t ) ; * from = f ; * to = t ; } void wxMacMLTEControl :: SetSelection ( long from , long to ) { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif if ( ( from == - 1 ) && ( to == - 1 ) ) TXNSelectAll ( m_txn ) ; else TXNSetSelection ( m_txn , from , to == - 1 ? kTXNEndOffset : to ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; } void wxMacMLTEControl :: WriteText ( const wxString & str ) { if ( ! wxIsMainThread ( ) ) { # if wxOSX_USE_CARBON wxMacMPRemoteGUICall < wxTextCtrl , wxString > ( ( wxTextCtrl * ) GetWXPeer ( ) , & wxTextCtrl :: WriteText , str ) ; # endif return ; } wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; long start , end , dummy ; GetSelection ( & start , & dummy ) ; # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif { wxMacEditHelper helper ( m_txn ) ; SetTXNData ( st , kTXNUseCurrentSelection , kTXNUseCurrentSelection ) ; } GetSelection ( & dummy , & end ) ; } void wxMacMLTEControl :: Clear ( ) { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif wxMacEditHelper st ( m_txn ) ; TXNSetSelection ( m_txn , kTXNStartOffset , kTXNEndOffset ) ; TXNClear ( m_txn ) ; } bool wxMacMLTEControl :: CanUndo ( ) const { return TXNCanUndo ( m_txn , NULL ) ; } void wxMacMLTEControl :: Undo ( ) { TXNUndo ( m_txn ) ; } bool wxMacMLTEControl :: CanRedo ( ) const { return TXNCanRedo ( m_txn , NULL ) ; } void wxMacMLTEControl :: Redo ( ) { TXNRedo ( m_txn ) ; } int wxMacMLTEControl :: GetNumberOfLines ( ) const { ItemCount lines = 0 ; TXNGetLineCount ( m_txn , & lines ) ; return lines ; } long wxMacMLTEControl :: XYToPosition ( long x , long y ) const { Point curpt ; wxTextPos lastpos ; long xpos = 0 , ypos = 0 ; int lastHeight = 0 ; ItemCount n ; lastpos = GetLastPosition ( ) ; for ( n = 0 ; n <= ( ItemCount ) lastpos ; ++ n ) { if ( y == ypos && x == xpos ) return n ; TXNOffsetToPoint ( m_txn , n , & curpt ) ; if ( curpt . v > lastHeight ) { xpos = 0 ; if ( n > 0 ) ++ ypos ; lastHeight = curpt . v ; } else ++ xpos ; } return 0 ; } bool wxMacMLTEControl :: PositionToXY ( long pos , long * x , long * y ) const { Point curpt ; wxTextPos lastpos ; if ( y ) * y = 0 ; if ( x ) * x = 0 ; lastpos = GetLastPosition ( ) ; if ( pos <= lastpos ) { long xpos = 0 , ypos = 0 ; int lastHeight = 0 ; ItemCount n ; for ( n = 0 ; n <= ( ItemCount ) pos ; ++ n ) { TXNOffsetToPoint ( m_txn , n , & curpt ) ; if ( curpt . v > lastHeight ) { xpos = 0 ; if ( n > 0 ) ++ ypos ; lastHeight = curpt . v ; } else ++ xpos ; } if ( y ) * y = ypos ; if ( x ) * x = xpos ; } return false ; } void wxMacMLTEControl :: ShowPosition ( long pos ) { Point current , desired ; TXNOffset selstart , selend ; TXNGetSelection ( m_txn , & selstart , & selend ) ; TXNOffsetToPoint ( m_txn , selstart , & current ) ; TXNOffsetToPoint ( m_txn , pos , & desired ) ; OSErr theErr = noErr ; long dv = desired . v - current . v ; long dh = desired . h - current . h ; TXNShowSelection ( m_txn , kTXNShowStart ) ; theErr = TXNScroll ( m_txn , kTXNScrollUnitsInPixels , kTXNScrollUnitsInPixels , & dv , & dh ) ; } void wxMacMLTEControl :: SetTXNData ( const wxString & st , TXNOffset start , TXNOffset end ) { # if wxUSE_UNICODE wxMBConvUTF16 converter ; ByteCount byteBufferLen = converter . WC2MB ( NULL , st . wc_str ( ) , 0 ) ; wxASSERT_MSG ( byteBufferLen != wxCONV_FAILED , wxT ( " Conversion ▁ to ▁ UTF - 16 ▁ unexpectedly ▁ failed " ) ) ; UniChar * unibuf = ( UniChar * ) malloc ( byteBufferLen + 2 ) ; converter . WC2MB ( ( char * ) unibuf , st . wc_str ( ) , byteBufferLen + 2 ) ; TXNSetData ( m_txn , kTXNUnicodeTextData , ( void * ) unibuf , byteBufferLen , start , end ) ; free ( unibuf ) ; # else wxCharBuffer text = st . mb_str ( wxConvLocal ) ; TXNSetData ( m_txn , kTXNTextData , ( void * ) text . data ( ) , strlen ( text ) , start , end ) ; # endif } wxString wxMacMLTEControl :: GetLineText ( long lineNo ) const { wxString line ; if ( lineNo < GetNumberOfLines ( ) ) { Point firstPoint ; Fixed lineWidth , lineHeight , currentHeight ; long ypos ; TXNOffsetToPoint ( m_txn , 0 , & firstPoint ) ; ypos = 0 ; currentHeight = 0 ; while ( ypos < lineNo ) { TXNGetLineMetrics ( m_txn , ypos ++ , & lineWidth , & lineHeight ) ; currentHeight += lineHeight ; } Point thePoint = { firstPoint . v + ( currentHeight >> 16 ) , firstPoint . h + ( 0 ) } ; TXNOffset theOffset ; TXNPointToOffset ( m_txn , thePoint , & theOffset ) ; wxString content = GetStringValue ( ) ; Point currentPoint = thePoint ; while ( thePoint . v == currentPoint . v && theOffset < content . length ( ) ) { line += content [ theOffset ] ; TXNOffsetToPoint ( m_txn , ++ theOffset , & currentPoint ) ; } } return line ; } int wxMacMLTEControl :: GetLineLength ( long lineNo ) const { int theLength = 0 ; if ( lineNo < GetNumberOfLines ( ) ) { Point firstPoint ; Fixed lineWidth , lineHeight , currentHeight ; long ypos ; TXNOffsetToPoint ( m_txn , 0 , & firstPoint ) ; ypos = 0 ; currentHeight = 0 ; while ( ypos < lineNo ) { TXNGetLineMetrics ( m_txn , ypos ++ , & lineWidth , & lineHeight ) ; currentHeight += lineHeight ; } Point thePoint = { firstPoint . v + ( currentHeight >> 16 ) , firstPoint . h + ( 0 ) } ; TXNOffset theOffset ; TXNPointToOffset ( m_txn , thePoint , & theOffset ) ; wxString content = GetStringValue ( ) ; Point currentPoint = thePoint ; while ( thePoint . v == currentPoint . v && theOffset < content . length ( ) ) { ++ theLength ; TXNOffsetToPoint ( m_txn , ++ theOffset , & currentPoint ) ; } } return theLength ; } static const EventTypeSpec eventList [ ] = { { kEventClassTextInput , kEventTextInputUnicodeForKeyEvent } , } ; static pascal OSStatus wxMacUnicodeTextEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; wxMacMLTEHIViewControl * focus = ( wxMacMLTEHIViewControl * ) data ; switch ( GetEventKind ( event ) ) { case kEventTextInputUnicodeForKeyEvent : { TXNOffset from , to ; TXNGetSelection ( focus -> GetTXNObject ( ) , & from , & to ) ; if ( from == to ) TXNShowSelection ( focus -> GetTXNObject ( ) , kTXNShowStart ) ; result = CallNextEventHandler ( handler , event ) ; break ; } default : break ; } return result ; } static pascal OSStatus wxMacTextControlEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; switch ( GetEventClass ( event ) ) { case kEventClassTextInput : result = wxMacUnicodeTextEventHandler ( handler , event , data ) ; break ; default : break ; } return result ; } DEFINE_ONE_SHOT_HANDLER_GETTER ( wxMacTextControlEventHandler ) wxMacMLTEHIViewControl :: wxMacMLTEHIViewControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) : wxMacMLTEControl ( wxPeer ) { m_font = wxPeer -> GetFont ( ) ; m_windowStyle = style ; Rect bounds = wxMacGetBoundsForControl ( wxPeer , pos , size ) ; wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; HIRect hr = { { bounds . left , bounds . top } , { bounds . right - bounds . left , bounds . bottom - bounds . top } } ; m_scrollView = NULL ; TXNFrameOptions frameOptions = FrameOptionsFromWXStyle ( style ) ; if ( ( frameOptions & ( kTXNWantVScrollBarMask | kTXNWantHScrollBarMask ) ) || ( frameOptions & kTXNSingleLineOnlyMask ) ) { if ( frameOptions & ( kTXNWantVScrollBarMask | kTXNWantHScrollBarMask ) ) { HIScrollViewCreate ( ( frameOptions & kTXNWantHScrollBarMask ? kHIScrollViewOptionsHorizScroll : 0 ) | ( frameOptions & kTXNWantVScrollBarMask ? kHIScrollViewOptionsVertScroll : 0 ) , & m_scrollView ) ; } else { HIScrollViewCreate ( kHIScrollViewOptionsVertScroll , & m_scrollView ) ; HIScrollViewSetScrollBarAutoHide ( m_scrollView , true ) ; } HIViewSetFrame ( m_scrollView , & hr ) ; HIViewSetVisible ( m_scrollView , true ) ; } m_textView = NULL ; HITextViewCreate ( NULL , 0 , frameOptions , & m_textView ) ; m_txn = HITextViewGetTXNObject ( m_textView ) ; HIViewSetVisible ( m_textView , true ) ; if ( m_scrollView ) { HIViewAddSubview ( m_scrollView , m_textView ) ; m_controlRef = m_scrollView ; InstallEventHandler ( ( WXWidget ) m_textView ) ; } else { HIViewSetFrame ( m_textView , & hr ) ; m_controlRef = m_textView ; } AdjustCreationAttributes ( * wxWHITE , true ) ; # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif SetTXNData ( st , kTXNStartOffset , kTXNEndOffset ) ; TXNSetSelection ( m_txn , 0 , 0 ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; :: InstallControlEventHandler ( m_textView , GetwxMacTextControlEventHandlerUPP ( ) , GetEventTypeCount ( eventList ) , eventList , this , NULL ) ; } wxMacMLTEHIViewControl :: ~ wxMacMLTEHIViewControl ( ) { } bool wxMacMLTEHIViewControl :: SetFocus ( ) { return SetKeyboardFocus ( GetControlOwner ( m_textView ) , m_textView , kControlFocusNextPart ) == noErr ; } bool wxMacMLTEHIViewControl :: HasFocus ( ) const { ControlRef control ; if ( GetUserFocusWindow ( ) == NULL ) return false ; GetKeyboardFocus ( GetUserFocusWindow ( ) , & control ) ; return control == m_textView ; } void wxMacMLTEHIViewControl :: SetBackgroundColour ( const wxColour & col ) { HITextViewSetBackgroundColor ( m_textView , col . GetPixel ( ) ) ; } # endif </DOCUMENT>
<DOCUMENT_ID="pete318/TrinityCore/tree/master/src/server/scripts/Northrend/FrozenHalls/HallsOfReflection/halls_of_reflection.cpp"> # include " halls _ of _ reflection . h " # include " Creature . h " # include " EventProcessor . h " # include " InstanceScript . h " # include " MotionMaster . h " # include " MoveSplineInit . h " # include " ObjectAccessor . h " # include " ObjectGuid . h " # include " Player . h " # include " ScriptedCreature . h " # include " ScriptedGossip . h " # include " ScriptMgr . h " # include " Spell . h " # include " SpellInfo . h " # include " SpellScript . h " # include " TemporarySummon . h " # include " Transport . h " # include " Unit . h " enum Text { SAY_JAINA_INTRO_1 = 0 , SAY_JAINA_INTRO_2 = 1 , SAY_JAINA_INTRO_3 = 2 , SAY_JAINA_INTRO_4 = 3 , SAY_JAINA_INTRO_5 = 4 , SAY_JAINA_INTRO_6 = 5 , SAY_JAINA_INTRO_7 = 6 , SAY_JAINA_INTRO_8 = 7 , SAY_JAINA_INTRO_9 = 8 , SAY_JAINA_INTRO_10 = 9 , SAY_JAINA_INTRO_11 = 10 , SAY_JAINA_INTRO_END = 11 , SAY_SYLVANAS_INTRO_1 = 0 , SAY_SYLVANAS_INTRO_2 = 1 , SAY_SYLVANAS_INTRO_3 = 2 , SAY_SYLVANAS_INTRO_4 = 3 , SAY_SYLVANAS_INTRO_5 = 4 , SAY_SYLVANAS_INTRO_6 = 5 , SAY_SYLVANAS_INTRO_7 = 6 , SAY_SYLVANAS_INTRO_8 = 7 , SAY_SYLVANAS_INTRO_END = 8 , SAY_UTHER_INTRO_A2_1 = 0 , SAY_UTHER_INTRO_A2_2 = 1 , SAY_UTHER_INTRO_A2_3 = 2 , SAY_UTHER_INTRO_A2_4 = 3 , SAY_UTHER_INTRO_A2_5 = 4 , SAY_UTHER_INTRO_A2_6 = 5 , SAY_UTHER_INTRO_A2_7 = 6 , SAY_UTHER_INTRO_A2_8 = 7 , SAY_UTHER_INTRO_A2_9 = 8 , SAY_UTHER_INTRO_H2_1 = 9 , SAY_UTHER_INTRO_H2_2 = 10 , SAY_UTHER_INTRO_H2_3 = 11 , SAY_UTHER_INTRO_H2_4 = 12 , SAY_UTHER_INTRO_H2_5 = 13 , SAY_UTHER_INTRO_H2_6 = 14 , SAY_UTHER_INTRO_H2_7 = 15 , SAY_LK_INTRO_1 = 0 , SAY_LK_INTRO_2 = 1 , SAY_LK_INTRO_3 = 2 , SAY_LK_JAINA_INTRO_END = 3 , SAY_LK_SYLVANAS_INTRO_END = 4 , SAY_JAINA_SYLVANAS_ESCAPE_1 = 0 , SAY_JAINA_SYLVANAS_ESCAPE_2 = 1 , SAY_JAINA_SYLVANAS_ESCAPE_3 = 2 , SAY_JAINA_SYLVANAS_ESCAPE_4 = 3 , SAY_JAINA_SYLVANAS_ESCAPE_5 = 4 , SAY_JAINA_SYLVANAS_ESCAPE_6 = 5 , SAY_JAINA_SYLVANAS_ESCAPE_7 = 6 , SAY_JAINA_SYLVANAS_ESCAPE_8 = 7 , SAY_JAINA_ESCAPE_9 = 8 , SAY_JAINA_ESCAPE_10 = 9 , SAY_SYLVANAS_ESCAPE_9 = 8 , SAY_LK_ESCAPE_1 = 0 , SAY_LK_ESCAPE_2 = 1 , SAY_LK_ESCAPE_ICEWALL_SUMMONED_1 = 2 , SAY_LK_ESCAPE_ICEWALL_SUMMONED_2 = 3 , SAY_LK_ESCAPE_ICEWALL_SUMMONED_3 = 4 , SAY_LK_ESCAPE_ICEWALL_SUMMONED_4 = 5 , SAY_LK_ESCAPE_GHOULS = 6 , SAY_LK_ESCAPE_ABOMINATION = 7 , SAY_LK_ESCAPE_WINTER = 8 , SAY_LK_ESCAPE_HARVEST_SOUL = 9 , SAY_FALRIC_INTRO_1 = 5 , SAY_FALRIC_INTRO_2 = 6 , SAY_MARWYN_INTRO_1 = 4 } ; enum Events { EVENT_WALK_INTRO1 = 1 , EVENT_WALK_INTRO2 , EVENT_START_INTRO , EVENT_SKIP_INTRO , EVENT_INTRO_A2_1 , EVENT_INTRO_A2_2 , EVENT_INTRO_A2_3 , EVENT_INTRO_A2_4 , EVENT_INTRO_A2_5 , EVENT_INTRO_A2_6 , EVENT_INTRO_A2_7 , EVENT_INTRO_A2_8 , EVENT_INTRO_A2_9 , EVENT_INTRO_A2_10 , EVENT_INTRO_A2_11 , EVENT_INTRO_A2_12 , EVENT_INTRO_A2_13 , EVENT_INTRO_A2_14 , EVENT_INTRO_A2_15 , EVENT_INTRO_A2_16 , EVENT_INTRO_A2_17 , EVENT_INTRO_A2_18 , EVENT_INTRO_A2_19 , EVENT_INTRO_H2_1 , EVENT_INTRO_H2_2 , EVENT_INTRO_H2_3 , EVENT_INTRO_H2_4 , EVENT_INTRO_H2_5 , EVENT_INTRO_H2_6 , EVENT_INTRO_H2_7 , EVENT_INTRO_H2_8 , EVENT_INTRO_H2_9 , EVENT_INTRO_H2_10 , EVENT_INTRO_H2_11 , EVENT_INTRO_H2_12 , EVENT_INTRO_H2_13 , EVENT_INTRO_H2_14 , EVENT_INTRO_H2_15 , EVENT_INTRO_LK_1 , EVENT_INTRO_LK_2 , EVENT_INTRO_LK_3 , EVENT_INTRO_LK_4 , EVENT_INTRO_LK_5 , EVENT_INTRO_LK_6 , EVENT_INTRO_LK_7 , EVENT_INTRO_LK_8 , EVENT_INTRO_LK_9 , EVENT_INTRO_LK_10 , EVENT_INTRO_LK_11 , EVENT_INTRO_END , EVENT_ESCAPE , EVENT_ESCAPE_1 , EVENT_ESCAPE_2 , EVENT_ESCAPE_3 , EVENT_ESCAPE_4 , EVENT_ESCAPE_5 , EVENT_ESCAPE_6 , EVENT_ESCAPE_7 , EVENT_ESCAPE_8 , EVENT_ESCAPE_9 , EVENT_ESCAPE_10 , EVENT_ESCAPE_11 , EVENT_ESCAPE_12 , EVENT_ESCAPE_13 , EVENT_ESCAPE_14 , EVENT_ESCAPE_15 , EVENT_ESCAPE_16 , EVENT_ESCAPE_17 , EVENT_REMORSELESS_WINTER , EVENT_ESCAPE_SUMMON_GHOULS , EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , EVENT_OPEN_IMPENETRABLE_DOOR , EVENT_CLOSE_IMPENETRABLE_DOOR , EVENT_KORELN_LORALEN_DEATH } ; enum Misc { ACTION_START_INTRO , ACTION_SKIP_INTRO , JAINA_SYLVANAS_MAX_HEALTH = 252000 , POINT_SHADOW_THRONE_DOOR = 1 , POINT_ATTACK_ICEWALL = 2 , POINT_TRAP = 3 , SOUND_LK_SLAY_1 = 17214 , SOUND_LK_SLAY_2 = 17215 , SOUND_LK_FURY_OF_FROSTMOURNE = 17224 } ; enum Spells { SPELL_TAKE_FROSTMOURNE = 72729 , SPELL_FROSTMOURNE_DESPAWN = 72726 , SPELL_FROSTMOURNE_VISUAL = 73220 , SPELL_FROSTMOURNE_SOUNDS = 70667 , SPELL_BOSS_SPAWN_AURA = 72712 , SPELL_UTHER_DESPAWN = 70693 , SPELL_CAST_VISUAL = 65633 , SPELL_SUMMON_SOULS = 72711 , SPELL_TAUNT_ARTHAS = 69857 , SPELL_JAINA_ICE_BARRIER = 69787 , SPELL_JAINA_ICE_PRISON = 69708 , SPELL_JAINA_DESTROY_ICE_WALL = 69784 , SPELL_SYLVANAS_CLOAK_OF_DARKNESS = 70188 , SPELL_SYLVANAS_DARK_BINDING = 70194 , SPELL_SYLVANAS_DESTROY_ICE_WALL = 70224 , SPELL_SYLVANAS_BLINDING_RETREAT = 70199 , SPELL_REMORSELESS_WINTER = 69780 , SPELL_SOUL_REAPER = 69409 , SPELL_FURY_OF_FROSTMOURNE = 70063 , SPELL_RAISE_DEAD = 69818 , SPELL_SUMMON_RISEN_WITCH_DOCTOR = 69836 , SPELL_SUMMON_LUMBERING_ABOMINATION = 69835 , SPELL_SUMMON_ICE_WALL = 69768 , SPELL_PAIN_AND_SUFFERING = 74115 , SPELL_STUN_BREAK_JAINA = 69764 , SPELL_STUN_BREAK_SYLVANAS = 70200 , SPELL_HARVEST_SOUL = 69866 , SPELL_FEIGN_DEATH = 29266 , SPELL_GHOUL_JUMP = 70150 , SPELL_RAGING_GHOUL_SPAWN = 69636 , SPELL_CURSE_OF_DOOM = 70144 , SPELL_SHADOW_BOLT_VOLLEY = 70145 , SPELL_SHADOW_BOLT = 70080 , SPELL_RISEN_WITCH_DOCTOR_SPAWN = 69639 , SPELL_CLEAVE = 40505 , SPELL_VOMIT_SPRAY = 70176 } ; enum HorGossipMenu { GOSSIP_MENU_JAINA_FINAL = 10930 , GOSSIP_MENU_SYLVANAS_FINAL = 10931 } ; Position const NpcJainaOrSylvanasEscapeRoute [ ] = { { 5601.217285f , 2207.652832f , 731.541931f , 5.223304f } , { 5607.224375f , 2173.913330f , 731.126038f , 2.608723f } , { 5583.427246f , 2138.784180f , 731.150391f , 4.260901f } , { 5560.281738f , 2104.025635f , 731.410889f , 4.058383f } , { 5510.990723f , 2000.772217f , 734.716064f , 3.973213f } , { 5452.641113f , 1905.762329f , 746.530579f , 4.118834f } , { 5338.126953f , 1768.429810f , 767.237244f , 3.855189f } , { 5259.06f , 1669.27f , 784.3008f , 0.0f } , { 5265.53f , 1681.6f , 784.2947f , 4.13643f } } ; Position const LichKingMoveAwayPos = { 5400.069824f , 2102.7131689f , 707.69525f , 0.843803f } ; Position const LichKingFirstSummon = { 5600.076172f , 2192.270996f , 731.750488f , 4.330935f } ; Position const JainaSylvanasShadowThroneDoor = { 5577.243f , 2235.852f , 733.0128f , 2.209562f } ; Position const LichKingFinalPos = { 5283.742188f , 1706.335693f , 783.293518f , 4.138510f } ; Position const KorelnOrLoralenPos [ ] = { { 5253.061f , 1953.616f , 707.6948f , 0.8377581f } , { 5283.226f , 1992.300f , 707.7445f , 0.8377581f } , { 5360.711f , 2064.797f , 707.6948f , 0.0f } } ; Position const SylvanasIntroPosition [ ] = { { 0.0f , 0.0f , 0.0f , 0.0f } , { 5263.2f , 1950.96f , 707.6948f , 0.8028514f } , { 5306.82f , 1998.17f , 709.341f , 1.239184f } , } ; Position const JainaIntroPosition [ ] = { { 0.0f , 0.0f , 0.0f , 0.0f } , { 5265.89f , 1952.98f , 707.6978f , 0.0f } , { 5306.95f , 1998.49f , 709.3414f , 1.277278f } } ; Position const UtherSpawnPos = { 5307.814f , 2003.168f , 709.4244f , 4.537856f } ; Position const LichKingIntroPosition [ ] = { { 5362.463f , 2062.693f , 707.7781f , 3.944444f } , { 5332.83f , 2031.24f , 707.6948f , 0.0f } , { 5312.93f , 2010.24f , 709.34f , 0.0f } , { 5319.028f , 2016.662f , 707.6948f , 0.0f } , { 5332.285f , 2030.832f , 707.6948f , 0.0f } , { 5355.488f , 2055.149f , 707.6907f , 0.0f } } ; Position const FalricPosition [ ] = { { 5276.583f , 2037.45f , 709.4025f , 5.532694f } , { 5283.95f , 2030.53f , 709.3191f , 0.0f } } ; Position const MarwynPosition [ ] = { { 5342.232f , 1975.696f , 709.4025f , 2.391101f } , { 5335.01f , 1982.37f , 709.3191f , 0.0f } } ; Position const SylvanasShadowThroneDoorPosition = { 5576.79f , 2235.73f , 733.0029f , 2.687807f } ; Position const IceWallTargetPosition [ ] = { { 5547.833f , 2083.701f , 731.4332f , 1.029744f } , { 5503.213f , 1969.547f , 737.0245f , 1.27409f } , { 5439.976f , 1879.005f , 752.7048f , 1.064651f } , { 5318.289f , 1749.184f , 771.9423f , 0.8726646f } } ; class npc_jaina_or_sylvanas_intro_hor : public CreatureScript { public : npc_jaina_or_sylvanas_intro_hor ( ) : CreatureScript ( " npc _ jaina _ or _ sylvanas _ intro _ hor " ) { } struct npc_jaina_or_sylvanas_intro_horAI : public ScriptedAI { npc_jaina_or_sylvanas_intro_horAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; } bool GossipHello ( Player * player ) override { if ( _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) == IN_PROGRESS || _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) == SPECIAL ) { ClearGossipMenuFor ( player ) ; return true ; } return false ; } bool GossipSelect ( Player * player , uint32 , uint32 gossipListId ) override { ClearGossipMenuFor ( player ) ; switch ( gossipListId ) { case 0 : player -> PlayerTalkClass -> SendCloseGossip ( ) ; _events . ScheduleEvent ( EVENT_START_INTRO , 1s ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; case 1 : player -> PlayerTalkClass -> SendCloseGossip ( ) ; _events . ScheduleEvent ( EVENT_SKIP_INTRO , 1s ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; default : break ; } return false ; } void Reset ( ) override { _events . Reset ( ) ; _utherGUID . Clear ( ) ; _lichkingGUID . Clear ( ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; me -> SetStandState ( UNIT_STAND_STATE_STAND ) ; _events . ScheduleEvent ( EVENT_WALK_INTRO1 , 3000 ) ; } void UpdateAI ( uint32 diff ) override { _events . Update ( diff ) ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_WALK_INTRO1 : if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> GetMotionMaster ( ) -> MovePoint ( 0 , KorelnOrLoralenPos [ 0 ] ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) { me -> GetMotionMaster ( ) -> MovePoint ( 0 , JainaIntroPosition [ 1 ] ) ; Talk ( SAY_JAINA_INTRO_1 ) ; _events . ScheduleEvent ( EVENT_WALK_INTRO2 , 7000 ) ; } else { me -> GetMotionMaster ( ) -> MovePoint ( 0 , SylvanasIntroPosition [ 1 ] ) ; Talk ( SAY_SYLVANAS_INTRO_1 ) ; _events . ScheduleEvent ( EVENT_WALK_INTRO2 , 9000 ) ; } break ; case EVENT_WALK_INTRO2 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) Talk ( SAY_JAINA_INTRO_2 ) ; else Talk ( SAY_SYLVANAS_INTRO_2 ) ; me -> SetFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; case EVENT_START_INTRO : if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> GetMotionMaster ( ) -> MovePoint ( 0 , KorelnOrLoralenPos [ 1 ] ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) { me -> GetMotionMaster ( ) -> MovePoint ( 0 , JainaIntroPosition [ 2 ] ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_1 , 0 ) ; } else { me -> GetMotionMaster ( ) -> MovePoint ( 0 , SylvanasIntroPosition [ 2 ] ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_1 , 0 ) ; } break ; case EVENT_INTRO_A2_1 : Talk ( SAY_JAINA_INTRO_3 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_2 , 7000 ) ; break ; case EVENT_INTRO_A2_2 : Talk ( SAY_JAINA_INTRO_4 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_3 , 10000 ) ; break ; case EVENT_INTRO_A2_3 : me -> CastSpell ( me , SPELL_CAST_VISUAL , false ) ; me -> CastSpell ( me , SPELL_FROSTMOURNE_SOUNDS , true ) ; _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_FROSTMOURNE ) , true ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_4 , 10000 ) ; break ; case EVENT_INTRO_A2_4 : if ( Creature * uther = me -> SummonCreature ( NPC_UTHER , UtherSpawnPos , TEMPSUMMON_MANUAL_DESPAWN ) ) _utherGUID = uther -> GetGUID ( ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_5 , 2000 ) ; break ; case EVENT_INTRO_A2_5 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_1 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_6 , 3000 ) ; break ; case EVENT_INTRO_A2_6 : Talk ( SAY_JAINA_INTRO_5 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_7 , 7000 ) ; break ; case EVENT_INTRO_A2_7 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_2 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_8 , 7000 ) ; break ; case EVENT_INTRO_A2_8 : Talk ( SAY_JAINA_INTRO_6 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_9 , 1200 ) ; break ; case EVENT_INTRO_A2_9 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_3 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_10 , 11000 ) ; break ; case EVENT_INTRO_A2_10 : Talk ( SAY_JAINA_INTRO_7 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_11 , 6000 ) ; break ; case EVENT_INTRO_A2_11 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_4 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_12 , 12000 ) ; break ; case EVENT_INTRO_A2_12 : Talk ( SAY_JAINA_INTRO_8 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_13 , 6000 ) ; break ; case EVENT_INTRO_A2_13 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_5 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_14 , 13000 ) ; break ; case EVENT_INTRO_A2_14 : Talk ( SAY_JAINA_INTRO_9 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_15 , 12000 ) ; break ; case EVENT_INTRO_A2_15 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_6 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_16 , 25000 ) ; break ; case EVENT_INTRO_A2_16 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_7 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_17 , 6000 ) ; break ; case EVENT_INTRO_A2_17 : Talk ( SAY_JAINA_INTRO_10 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_18 , 5000 ) ; break ; case EVENT_INTRO_A2_18 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) { uther -> HandleEmoteCommand ( EMOTE_ONESHOT_NO ) ; uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_8 ) ; } _events . ScheduleEvent ( EVENT_INTRO_A2_19 , 12000 ) ; break ; case EVENT_INTRO_A2_19 : Talk ( SAY_JAINA_INTRO_11 ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_1 , 3000 ) ; break ; case EVENT_INTRO_H2_1 : Talk ( SAY_SYLVANAS_INTRO_1 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_2 , 8000 ) ; break ; case EVENT_INTRO_H2_2 : Talk ( SAY_SYLVANAS_INTRO_2 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_3 , 6000 ) ; break ; case EVENT_INTRO_H2_3 : Talk ( SAY_SYLVANAS_INTRO_3 ) ; me -> CastSpell ( me , SPELL_CAST_VISUAL , false ) ; me -> CastSpell ( me , SPELL_FROSTMOURNE_SOUNDS , true ) ; _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_FROSTMOURNE ) , true ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_4 , 6000 ) ; break ; case EVENT_INTRO_H2_4 : if ( Creature * uther = me -> SummonCreature ( NPC_UTHER , UtherSpawnPos , TEMPSUMMON_MANUAL_DESPAWN ) ) _utherGUID = uther -> GetGUID ( ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_5 , 2000 ) ; break ; case EVENT_INTRO_H2_5 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_1 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_6 , 11000 ) ; break ; case EVENT_INTRO_H2_6 : Talk ( SAY_SYLVANAS_INTRO_4 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_7 , 3000 ) ; break ; case EVENT_INTRO_H2_7 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_2 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_8 , 6000 ) ; break ; case EVENT_INTRO_H2_8 : Talk ( SAY_SYLVANAS_INTRO_5 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_9 , 5000 ) ; break ; case EVENT_INTRO_H2_9 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_3 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_10 , 19000 ) ; break ; case EVENT_INTRO_H2_10 : Talk ( SAY_SYLVANAS_INTRO_6 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_11 , 1500 ) ; break ; case EVENT_INTRO_H2_11 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_4 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_12 , 19500 ) ; break ; case EVENT_INTRO_H2_12 : Talk ( SAY_SYLVANAS_INTRO_7 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_13 , 2000 ) ; break ; case EVENT_INTRO_H2_13 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) { uther -> HandleEmoteCommand ( EMOTE_ONESHOT_NO ) ; uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_5 ) ; } _events . ScheduleEvent ( EVENT_INTRO_H2_14 , 12000 ) ; break ; case EVENT_INTRO_H2_14 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_6 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_15 , 8000 ) ; break ; case EVENT_INTRO_H2_15 : Talk ( SAY_SYLVANAS_INTRO_8 ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_1 , 2000 ) ; break ; case EVENT_INTRO_LK_1 : if ( Creature * lichking = me -> SummonCreature ( NPC_THE_LICH_KING_INTRO , LichKingIntroPosition [ 0 ] , TEMPSUMMON_MANUAL_DESPAWN ) ) { lichking -> SetWalk ( true ) ; lichking -> GetMotionMaster ( ) -> MovePoint ( 0 , LichKingIntroPosition [ 2 ] ) ; _lichkingGUID = lichking -> GetGUID ( ) ; _events . ScheduleEvent ( EVENT_OPEN_IMPENETRABLE_DOOR , 0 ) ; _events . ScheduleEvent ( EVENT_CLOSE_IMPENETRABLE_DOOR , 4s ) ; } if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) { uther -> SetUInt32Value ( UNIT_NPC_EMOTESTATE , EMOTE_STATE_COWER ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_9 ) ; else uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_7 ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_2 , 10000 ) ; break ; case EVENT_INTRO_LK_2 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) lichking -> AI ( ) -> Talk ( SAY_LK_INTRO_1 ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_3 , 1000 ) ; break ; case EVENT_INTRO_LK_3 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) { uther -> CastSpell ( uther , SPELL_UTHER_DESPAWN , true ) ; uther -> DespawnOrUnsummon ( 5000 ) ; _utherGUID . Clear ( ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_4 , 9000 ) ; break ; case EVENT_INTRO_LK_4 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) { if ( GameObject * frostmourne = ObjectAccessor :: GetGameObject ( * me , _instance -> GetGuidData ( DATA_FROSTMOURNE ) ) ) frostmourne -> SetPhaseMask ( 2 , true ) ; lichking -> CastSpell ( lichking , SPELL_TAKE_FROSTMOURNE , true ) ; lichking -> CastSpell ( lichking , SPELL_FROSTMOURNE_VISUAL , true ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_5 , 8000 ) ; break ; case EVENT_INTRO_LK_5 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) lichking -> AI ( ) -> Talk ( SAY_LK_INTRO_2 ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_6 , 10000 ) ; break ; case EVENT_INTRO_LK_6 : if ( Creature * falric = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FALRIC ) ) ) { falric -> CastSpell ( falric , SPELL_BOSS_SPAWN_AURA , true ) ; falric -> SetVisible ( true ) ; } if ( Creature * marwyn = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_MARWYN ) ) ) { marwyn -> CastSpell ( marwyn , SPELL_BOSS_SPAWN_AURA , true ) ; marwyn -> SetVisible ( true ) ; } if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) { lichking -> AI ( ) -> Talk ( SAY_LK_INTRO_3 ) ; lichking -> SetWalk ( true ) ; lichking -> GetMotionMaster ( ) -> MovePoint ( 0 , LichKingMoveAwayPos ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_7 , 10000 ) ; _events . ScheduleEvent ( EVENT_OPEN_IMPENETRABLE_DOOR , 5s ) ; break ; case EVENT_INTRO_LK_7 : if ( Creature * marwyn = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_MARWYN ) ) ) { marwyn -> AI ( ) -> Talk ( SAY_MARWYN_INTRO_1 ) ; marwyn -> SetWalk ( true ) ; marwyn -> GetMotionMaster ( ) -> MovePoint ( 0 , MarwynPosition [ 1 ] ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_8 , 1000 ) ; break ; case EVENT_INTRO_LK_8 : if ( Creature * falric = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FALRIC ) ) ) { falric -> AI ( ) -> Talk ( SAY_FALRIC_INTRO_1 ) ; falric -> SetWalk ( true ) ; falric -> GetMotionMaster ( ) -> MovePoint ( 0 , FalricPosition [ 1 ] ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_9 , 5000 ) ; break ; case EVENT_INTRO_LK_9 : if ( Creature * falric = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FALRIC ) ) ) falric -> AI ( ) -> Talk ( SAY_FALRIC_INTRO_2 ) ; _instance -> ProcessEvent ( 0 , EVENT_SPAWN_WAVES ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_10 , 4000 ) ; break ; case EVENT_INTRO_LK_10 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) Talk ( SAY_JAINA_INTRO_END ) ; else Talk ( SAY_SYLVANAS_INTRO_END ) ; me -> GetMotionMaster ( ) -> MovePoint ( 0 , LichKingMoveAwayPos ) ; if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> GetMotionMaster ( ) -> MovePoint ( 1 , KorelnOrLoralenPos [ 2 ] ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_11 , 5000 ) ; break ; case EVENT_INTRO_LK_11 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) { if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) lichking -> AI ( ) -> Talk ( SAY_LK_JAINA_INTRO_END ) ; else lichking -> AI ( ) -> Talk ( SAY_LK_SYLVANAS_INTRO_END ) ; } _events . ScheduleEvent ( EVENT_INTRO_END , 5s ) ; break ; case EVENT_INTRO_END : _instance -> SetData ( DATA_INTRO_EVENT , DONE ) ; _events . ScheduleEvent ( EVENT_KORELN_LORALEN_DEATH , 8s ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) { lichking -> DespawnOrUnsummon ( 5000 ) ; _lichkingGUID . Clear ( ) ; } me -> DespawnOrUnsummon ( 10000 ) ; _events . ScheduleEvent ( EVENT_CLOSE_IMPENETRABLE_DOOR , 7s ) ; break ; case EVENT_SKIP_INTRO : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) me -> GetMotionMaster ( ) -> MovePoint ( 0 , JainaIntroPosition [ 2 ] ) ; else me -> GetMotionMaster ( ) -> MovePoint ( 0 , SylvanasIntroPosition [ 2 ] ) ; if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> GetMotionMaster ( ) -> MovePoint ( 0 , KorelnOrLoralenPos [ 1 ] ) ; if ( Creature * lichking = me -> SummonCreature ( NPC_THE_LICH_KING_INTRO , LichKingIntroPosition [ 0 ] , TEMPSUMMON_MANUAL_DESPAWN ) ) { lichking -> SetWalk ( true ) ; lichking -> GetMotionMaster ( ) -> MovePoint ( 0 , LichKingIntroPosition [ 2 ] ) ; lichking -> SetReactState ( REACT_PASSIVE ) ; _lichkingGUID = lichking -> GetGUID ( ) ; _events . ScheduleEvent ( EVENT_OPEN_IMPENETRABLE_DOOR , 0 ) ; _events . ScheduleEvent ( EVENT_CLOSE_IMPENETRABLE_DOOR , 4s ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_4 , 15000 ) ; break ; case EVENT_OPEN_IMPENETRABLE_DOOR : _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_IMPENETRABLE_DOOR ) , true ) ; break ; case EVENT_CLOSE_IMPENETRABLE_DOOR : _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_IMPENETRABLE_DOOR ) , false ) ; break ; case EVENT_KORELN_LORALEN_DEATH : if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> CastSpell ( korelnOrLoralen , SPELL_FEIGN_DEATH ) ; break ; default : break ; } } private : InstanceScript * _instance ; EventMap _events ; ObjectGuid _utherGUID ; ObjectGuid _lichkingGUID ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_jaina_or_sylvanas_intro_horAI > ( creature ) ; } } ; class HoRGameObjectDeleteDelayEvent : public BasicEvent { public : explicit HoRGameObjectDeleteDelayEvent ( Unit * owner , ObjectGuid gameObjectGUID ) : _owner ( owner ) , _gameObjectGUID ( gameObjectGUID ) { } void DeleteGameObject ( ) { if ( GameObject * go = ObjectAccessor :: GetGameObject ( * _owner , _gameObjectGUID ) ) go -> Delete ( ) ; } bool Execute ( uint64 , uint32 ) override { DeleteGameObject ( ) ; return true ; } void Abort ( uint64 ) override { DeleteGameObject ( ) ; } private : Unit * _owner ; ObjectGuid _gameObjectGUID ; } ; class npc_jaina_or_sylvanas_escape_hor : public CreatureScript { public : npc_jaina_or_sylvanas_escape_hor ( ) : CreatureScript ( " npc _ jaina _ or _ sylvanas _ escape _ hor " ) { } struct npc_jaina_or_sylvanas_escape_horAI : public ScriptedAI { npc_jaina_or_sylvanas_escape_horAI ( Creature * creature ) : ScriptedAI ( creature ) , _instance ( creature -> GetInstanceScript ( ) ) , _icewall ( 0 ) , _prefight ( false ) , _invincibility ( true ) { } void Reset ( ) override { _events . Reset ( ) ; _icewall = 0 ; _events . ScheduleEvent ( EVENT_ESCAPE , 1s ) ; _instance -> DoStopTimedAchievement ( ACHIEVEMENT_TIMED_TYPE_EVENT , ACHIEV_NOT_RETREATING_EVENT ) ; } void JustDied ( Unit * ) override { if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> AI ( ) -> EnterEvadeMode ( ) ; } void DamageTaken ( Unit * , uint32 & damage ) override { if ( damage >= me -> GetHealth ( ) && _invincibility ) damage = me -> GetHealth ( ) - 1 ; } void DoAction ( int32 actionId ) override { switch ( actionId ) { case ACTION_START_PREFIGHT : if ( _prefight ) return ; _prefight = true ; _events . ScheduleEvent ( EVENT_ESCAPE_1 , 1000 ) ; break ; case ACTION_WALL_BROKEN : ++ _icewall ; if ( _icewall < 4 ) _events . ScheduleEvent ( EVENT_ESCAPE_13 , 3000 ) ; else _events . ScheduleEvent ( EVENT_ESCAPE_15 , 3000 ) ; break ; case ACTION_GUNSHIP_ARRIVAL : _events . ScheduleEvent ( EVENT_ESCAPE_16 , 5000 ) ; break ; case ACTION_GUNSHIP_ARRIVAL_2 : _events . ScheduleEvent ( EVENT_ESCAPE_17 , 5000 ) ; break ; default : break ; } } bool GossipHello ( Player * player ) override { if ( _instance -> GetBossState ( DATA_THE_LICH_KING_ESCAPE ) == DONE ) { player -> PrepareGossipMenu ( me , me -> GetEntry ( ) == NPC_JAINA_ESCAPE ? GOSSIP_MENU_JAINA_FINAL : GOSSIP_MENU_SYLVANAS_FINAL , true ) ; player -> SendPreparedGossip ( me ) ; return true ; } return false ; } bool GossipSelect ( Player * player , uint32 , uint32 gossipListId ) override { ClearGossipMenuFor ( player ) ; switch ( gossipListId ) { case 0 : player -> PlayerTalkClass -> SendCloseGossip ( ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP ) ; _events . ScheduleEvent ( EVENT_ESCAPE_6 , 0 ) ; break ; default : break ; } return false ; } void DestroyIceWall ( ) { if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) me -> RemoveAurasDueToSpell ( SPELL_JAINA_DESTROY_ICE_WALL ) ; else me -> RemoveAurasDueToSpell ( SPELL_SYLVANAS_DESTROY_ICE_WALL ) ; _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_ICEWALL ) , true ) ; me -> m_Events . AddEvent ( new HoRGameObjectDeleteDelayEvent ( me , _instance -> GetGuidData ( DATA_ICEWALL ) ) , me -> m_Events . CalculateTime ( 5000 ) ) ; if ( Creature * wallTarget = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ICEWALL_TARGET ) ) ) wallTarget -> DespawnOrUnsummon ( ) ; } void SummonIceWall ( ) { if ( _icewall < 4 ) { if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> StopMoving ( ) ; if ( Creature * wallTarget = me -> SummonCreature ( NPC_ICE_WALL_TARGET , IceWallTargetPosition [ _icewall ] , TEMPSUMMON_MANUAL_DESPAWN , 720000 ) ) lichking -> CastSpell ( wallTarget , SPELL_SUMMON_ICE_WALL ) ; lichking -> AI ( ) -> SetData ( DATA_ICEWALL , _icewall ) ; } } } void AttackIceWall ( ) { if ( _icewall < 4 ) Talk ( SAY_JAINA_SYLVANAS_ESCAPE_2 + _icewall ) ; if ( Creature * wallTarget = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ICEWALL_TARGET ) ) ) me -> SetFacingToObject ( wallTarget ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_JAINA_DESTROY_ICE_WALL , true ) ; else DoCast ( me , SPELL_SYLVANAS_DESTROY_ICE_WALL , true ) ; } void MovementInform ( uint32 type , uint32 pointId ) override { if ( type != POINT_MOTION_TYPE ) return ; switch ( pointId ) { case POINT_SHADOW_THRONE_DOOR : if ( me -> GetEntry ( ) == NPC_JAINA_ESCAPE ) me -> RemoveAurasDueToSpell ( SPELL_JAINA_ICE_BARRIER ) ; else me -> RemoveAurasDueToSpell ( SPELL_SYLVANAS_CLOAK_OF_DARKNESS ) ; me -> SetFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP ) ; me -> SetHealth ( JAINA_SYLVANAS_MAX_HEALTH ) ; me -> SetFacingTo ( SylvanasShadowThroneDoorPosition . GetOrientation ( ) ) ; break ; case POINT_ATTACK_ICEWALL : AttackIceWall ( ) ; break ; case POINT_TRAP : Talk ( SAY_JAINA_SYLVANAS_ESCAPE_8 ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) me -> SetFacingToObject ( lichking ) ; break ; default : break ; } } void DeleteAllFromThreatList ( Unit * target , ObjectGuid except ) { for ( ThreatReference * ref : target -> GetThreatManager ( ) . GetModifiableThreatList ( ) ) if ( ref -> GetVictim ( ) -> GetGUID ( ) != except ) ref -> ClearThreat ( ) ; } void UpdateAI ( uint32 diff ) override { _events . Update ( diff ) ; while ( uint32 event = _events . ExecuteEvent ( ) ) { switch ( event ) { case EVENT_ESCAPE : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_JAINA_ICE_BARRIER ) ; else DoCast ( me , SPELL_SYLVANAS_CLOAK_OF_DARKNESS ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { me -> CastSpell ( lichking , SPELL_TAUNT_ARTHAS , true ) ; lichking -> ApplySpellImmune ( 0 , IMMUNITY_STATE , SPELL_AURA_MOD_TAUNT , true ) ; lichking -> ApplySpellImmune ( 0 , IMMUNITY_EFFECT , SPELL_EFFECT_ATTACK_ME , true ) ; AttackStart ( lichking ) ; lichking -> AI ( ) -> AttackStart ( me ) ; } me -> SetHealth ( JAINA_SYLVANAS_MAX_HEALTH ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; case EVENT_ESCAPE_1 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) lichking -> AI ( ) -> Talk ( SAY_LK_ESCAPE_1 ) ; else lichking -> AI ( ) -> Talk ( SAY_LK_ESCAPE_2 ) ; _events . ScheduleEvent ( EVENT_ESCAPE_2 , 8000 ) ; } break ; case EVENT_ESCAPE_2 : me -> AttackStop ( ) ; me -> StopMoving ( ) ; me -> SetReactState ( REACT_PASSIVE ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_JAINA_ICE_PRISON , false ) ; else DoCast ( me , SPELL_SYLVANAS_BLINDING_RETREAT , true ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> SetReactState ( REACT_PASSIVE ) ; lichking -> SetFlag ( UNIT_FIELD_FLAGS , UNIT_FLAG_PACIFIED ) ; } _events . ScheduleEvent ( EVENT_ESCAPE_3 , 1500 ) ; break ; case EVENT_ESCAPE_3 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == HORDE ) DoCastAOE ( SPELL_SYLVANAS_DARK_BINDING , true ) ; _events . ScheduleEvent ( EVENT_ESCAPE_4 , 1000 ) ; break ; case EVENT_ESCAPE_4 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_CREDIT_FINDING_JAINA ) ; else DoCast ( me , SPELL_CREDIT_FINDING_SYLVANAS ) ; Talk ( SAY_JAINA_SYLVANAS_ESCAPE_1 ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> SetImmuneToPC ( true ) ; lichking -> RemoveAllAttackers ( ) ; DeleteAllFromThreatList ( lichking , me -> GetGUID ( ) ) ; } _events . ScheduleEvent ( EVENT_ESCAPE_5 , 2000 ) ; break ; case EVENT_ESCAPE_5 : me -> GetMotionMaster ( ) -> MovePoint ( POINT_SHADOW_THRONE_DOOR , SylvanasShadowThroneDoorPosition ) ; break ; case EVENT_ESCAPE_6 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> RemoveFlag ( UNIT_FIELD_FLAGS , UNIT_FLAG_PACIFIED ) ; lichking -> SetImmuneToPC ( false ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) { lichking -> CastSpell ( lichking , SPELL_STUN_BREAK_JAINA ) ; lichking -> RemoveAurasDueToSpell ( SPELL_JAINA_ICE_PRISON ) ; } else { lichking -> CastSpell ( lichking , SPELL_STUN_BREAK_SYLVANAS ) ; lichking -> RemoveAurasDueToSpell ( SPELL_SYLVANAS_DARK_BINDING ) ; } } _invincibility = false ; _instance -> DoStartTimedAchievement ( ACHIEVEMENT_TIMED_TYPE_EVENT , ACHIEV_NOT_RETREATING_EVENT ) ; _events . ScheduleEvent ( EVENT_ESCAPE_7 , 1000 ) ; break ; case EVENT_ESCAPE_7 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> HandleEmoteCommand ( TEXT_EMOTE_ROAR ) ; me -> GetMotionMaster ( ) -> MovePoint ( 0 , NpcJainaOrSylvanasEscapeRoute [ 0 ] ) ; _events . ScheduleEvent ( EVENT_ESCAPE_8 , 3000 ) ; break ; case EVENT_ESCAPE_8 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> GetMotionMaster ( ) -> MovePoint ( 0 , NpcJainaOrSylvanasEscapeRoute [ 0 ] ) ; _events . ScheduleEvent ( EVENT_ESCAPE_9 , 1000 ) ; break ; case EVENT_ESCAPE_9 : me -> GetMotionMaster ( ) -> MovePoint ( 0 , NpcJainaOrSylvanasEscapeRoute [ 1 ] ) ; _events . ScheduleEvent ( EVENT_ESCAPE_10 , 5000 ) ; break ; case EVENT_ESCAPE_10 : me -> GetMotionMaster ( ) -> MovePoint ( 0 , NpcJainaOrSylvanasEscapeRoute [ 2 ] ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> GetMotionMaster ( ) -> MovePoint ( 1 , LichKingFirstSummon ) ; _events . ScheduleEvent ( EVENT_ESCAPE_11 , 6000 ) ; break ; case EVENT_ESCAPE_11 : SummonIceWall ( ) ; _events . ScheduleEvent ( EVENT_ESCAPE_12 , 4000 ) ; break ; case EVENT_ESCAPE_12 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> CastSpell ( lichking , SPELL_PAIN_AND_SUFFERING , true ) ; me -> GetMotionMaster ( ) -> MovePoint ( POINT_ATTACK_ICEWALL , NpcJainaOrSylvanasEscapeRoute [ 3 ] ) ; break ; case EVENT_ESCAPE_13 : DestroyIceWall ( ) ; if ( _icewall && _icewall < 4 ) me -> GetMotionMaster ( ) -> MovePoint ( POINT_ATTACK_ICEWALL , NpcJainaOrSylvanasEscapeRoute [ _icewall + 3 ] ) ; _events . ScheduleEvent ( EVENT_ESCAPE_14 , 8000 ) ; break ; case EVENT_ESCAPE_14 : SummonIceWall ( ) ; break ; case EVENT_ESCAPE_15 : DestroyIceWall ( ) ; Talk ( SAY_JAINA_SYLVANAS_ESCAPE_6 ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> GetMotionMaster ( ) -> MovePoint ( 2 , LichKingFinalPos ) ; lichking -> RemoveAurasDueToSpell ( SPELL_REMORSELESS_WINTER ) ; } me -> GetMotionMaster ( ) -> MovePoint ( POINT_TRAP , NpcJainaOrSylvanasEscapeRoute [ 7 ] ) ; break ; case EVENT_ESCAPE_16 : me -> RemoveAurasDueToSpell ( SPELL_HARVEST_SOUL ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) Talk ( SAY_JAINA_ESCAPE_9 ) ; if ( Transport * gunship = ObjectAccessor :: GetTransport ( * me , _instance -> GetGuidData ( DATA_GUNSHIP ) ) ) gunship -> EnableMovement ( true ) ; _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , DONE ) ; break ; case EVENT_ESCAPE_17 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) Talk ( SAY_JAINA_ESCAPE_10 ) ; else Talk ( SAY_SYLVANAS_ESCAPE_9 ) ; DoCast ( me , SPELL_CREDIT_ESCAPING_ARTHAS ) ; me -> SetFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } private : InstanceScript * _instance ; EventMap _events ; uint32 _icewall ; bool _prefight ; bool _invincibility ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_jaina_or_sylvanas_escape_horAI > ( creature ) ; } } ; class npc_the_lich_king_escape_hor : public CreatureScript { public : npc_the_lich_king_escape_hor ( ) : CreatureScript ( " npc _ the _ lich _ king _ escape _ hor " ) { } struct npc_the_lich_king_escape_horAI : public ScriptedAI { npc_the_lich_king_escape_horAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , NOT_STARTED ) ; _summonsCount = 0 ; _icewall = 0 ; _despawn = false ; } void DamageTaken ( Unit * , uint32 & damage ) override { if ( damage >= me -> GetHealth ( ) ) damage = me -> GetHealth ( ) - 1 ; } void MovementInform ( uint32 type , uint32 pointId ) override { if ( type == POINT_MOTION_TYPE ) { switch ( pointId ) { case 1 : if ( Creature * target = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ESCAPE_LEADER ) ) ) me -> GetMotionMaster ( ) -> MoveChase ( target ) ; break ; case 2 : Talk ( SAY_LK_ESCAPE_HARVEST_SOUL ) ; if ( Creature * target = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ESCAPE_LEADER ) ) ) DoCast ( target , SPELL_HARVEST_SOUL ) ; if ( Transport * gunship = ObjectAccessor :: GetTransport ( * me , _instance -> GetGuidData ( DATA_GUNSHIP ) ) ) gunship -> EnableMovement ( true ) ; break ; default : break ; } } } void JustSummoned ( Creature * ) override { ++ _summonsCount ; } void SummonedCreatureDies ( Creature * , Unit * ) override { if ( ! _summonsCount ) return ; -- _summonsCount ; if ( ! _summonsCount && _events . Empty ( ) ) { if ( Creature * jainaOrSylvanas = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ESCAPE_LEADER ) ) ) jainaOrSylvanas -> AI ( ) -> DoAction ( ACTION_WALL_BROKEN ) ; } } void KilledUnit ( Unit * who ) override { if ( who -> GetTypeId ( ) == TYPEID_PLAYER ) DoPlaySoundToSet ( me , RAND ( SOUND_LK_SLAY_1 , SOUND_LK_SLAY_2 ) ) ; } void SetData ( uint32 type , uint32 data ) override { if ( type != DATA_ICEWALL ) return ; _icewall = data ; switch ( _icewall ) { case 0 : DoZoneInCombat ( ) ; _events . ScheduleEvent ( EVENT_REMORSELESS_WINTER , 0 ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 8s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 14s ) ; Talk ( SAY_LK_ESCAPE_ICEWALL_SUMMONED_1 ) ; break ; case 1 : _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 8s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 13s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 15s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 18s ) ; Talk ( SAY_LK_ESCAPE_ICEWALL_SUMMONED_2 ) ; break ; case 2 : _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 9s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 14s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 15s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 19s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 39s ) ; Talk ( SAY_LK_ESCAPE_ICEWALL_SUMMONED_3 ) ; break ; case 3 : _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 9s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 15s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 19s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 40s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 45s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 55s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 62s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 65s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 14s ) ; Talk ( SAY_LK_ESCAPE_ICEWALL_SUMMONED_4 ) ; break ; default : break ; } } void EnterEvadeMode ( EvadeReason ) override { if ( _despawn ) return ; _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , FAIL ) ; me -> StopMoving ( ) ; DoPlaySoundToSet ( me , SOUND_LK_FURY_OF_FROSTMOURNE ) ; DoCastAOE ( SPELL_FURY_OF_FROSTMOURNE ) ; me -> DespawnOrUnsummon ( 12000 ) ; _despawn = true ; } void UpdateAI ( uint32 diff ) override { if ( ! SelectVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; while ( uint32 event = _events . ExecuteEvent ( ) ) { switch ( event ) { case EVENT_REMORSELESS_WINTER : me -> StopMoving ( ) ; Talk ( SAY_LK_ESCAPE_WINTER ) ; DoCast ( me , SPELL_REMORSELESS_WINTER ) ; break ; case EVENT_ESCAPE_SUMMON_GHOULS : me -> StopMoving ( ) ; Talk ( SAY_LK_ESCAPE_GHOULS ) ; DoCast ( me , SPELL_RAISE_DEAD ) ; break ; case EVENT_ESCAPE_SUMMON_WITCH_DOCTOR : DoCast ( me , SPELL_SUMMON_RISEN_WITCH_DOCTOR ) ; break ; case EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION : Talk ( SAY_LK_ESCAPE_ABOMINATION ) ; DoCast ( me , SPELL_SUMMON_LUMBERING_ABOMINATION ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } private : bool SelectVictim ( ) { if ( ! me -> IsInCombat ( ) ) return false ; if ( ! me -> HasReactState ( REACT_PASSIVE ) ) { if ( Unit * victim = me -> SelectVictim ( ) ) if ( ! me -> HasSpellFocus ( ) && victim != me -> GetVictim ( ) ) AttackStart ( victim ) ; return me -> GetVictim ( ) != nullptr ; } else if ( me -> GetCombatManager ( ) . GetPvECombatRefs ( ) . size ( ) < 2 && me -> HasAura ( SPELL_REMORSELESS_WINTER ) ) { EnterEvadeMode ( EVADE_REASON_OTHER ) ; return false ; } return true ; } InstanceScript * _instance ; EventMap _events ; uint8 _icewall ; uint32 _summonsCount ; bool _despawn ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_the_lich_king_escape_horAI > ( creature ) ; } } ; enum TrashSpells { SPELL_SHADOW_WORD_PAIN = 72318 , SPELL_CIRCLE_OF_DESTRUCTION = 72320 , SPELL_COWER_IN_FEAR = 72321 , SPELL_DARK_MENDING = 72322 , SPELL_FIREBALL = 72163 , SPELL_FLAMESTRIKE = 72169 , SPELL_FROSTBOLT = 72166 , SPELL_CHAINS_OF_ICE = 72121 , SPELL_HALLUCINATION = 72342 , AURA_HALLUCINATION = 72343 , SPELL_HALLUCINATION_2 = 72344 , SPELL_SHADOW_STEP = 72326 , SPELL_DEADLY_POISON = 72329 , SPELL_ENVENOMED_DAGGER_THROW = 72333 , SPELL_KIDNEY_SHOT = 72335 , SPELL_SPECTRAL_STRIKE = 72198 , SPELL_SHIELD_BASH = 72194 , SPELL_TORTURED_ENRAGE = 72203 , SPELL_SHOOT = 72208 , SPELL_CURSED_ARROW = 72222 , SPELL_FROST_TRAP = 72215 , SPELL_ICE_SHOT = 72268 } ; enum TrashEvents { EVENT_TRASH_NONE , EVENT_SHADOW_WORD_PAIN , EVENT_CIRCLE_OF_DESTRUCTION , EVENT_COWER_IN_FEAR , EVENT_DARK_MENDING , EVENT_FIREBALL , EVENT_FLAMESTRIKE , EVENT_FROSTBOLT , EVENT_CHAINS_OF_ICE , EVENT_HALLUCINATION , EVENT_SHADOW_STEP , EVENT_DEADLY_POISON , EVENT_ENVENOMED_DAGGER_THROW , EVENT_KIDNEY_SHOT , EVENT_SPECTRAL_STRIKE , EVENT_SHIELD_BASH , EVENT_TORTURED_ENRAGE , EVENT_SHOOT , EVENT_CURSED_ARROW , EVENT_FROST_TRAP , EVENT_ICE_SHOT } ; struct npc_gauntlet_trash : public ScriptedAI { npc_gauntlet_trash ( Creature * creature ) : ScriptedAI ( creature ) , _instance ( creature -> GetInstanceScript ( ) ) , InternalWaveId ( 0 ) { } void Reset ( ) override { me -> CastSpell ( me , SPELL_WELL_OF_SOULS , true ) ; _events . Reset ( ) ; } void EnterEvadeMode ( EvadeReason ) override { if ( _instance -> GetData ( DATA_WAVE_COUNT ) != NOT_STARTED ) _instance -> SetData ( DATA_WAVE_COUNT , NOT_STARTED ) ; } void SetData ( uint32 type , uint32 value ) override { if ( type ) return ; InternalWaveId = value ; } uint32 GetData ( uint32 type ) const override { if ( type ) return 0 ; return InternalWaveId ; } protected : EventMap _events ; InstanceScript * _instance ; uint32 InternalWaveId ; } ; class npc_ghostly_priest : public CreatureScript { public : npc_ghostly_priest ( ) : CreatureScript ( " npc _ ghostly _ priest " ) { } struct npc_ghostly_priestAI : public npc_gauntlet_trash { npc_ghostly_priestAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_SHADOW_WORD_PAIN , 6s , 15s ) ; _events . ScheduleEvent ( EVENT_CIRCLE_OF_DESTRUCTION , 12s ) ; _events . ScheduleEvent ( EVENT_COWER_IN_FEAR , 10s ) ; _events . ScheduleEvent ( EVENT_DARK_MENDING , 20s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_SHADOW_WORD_PAIN : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_SHADOW_WORD_PAIN ) ; _events . ScheduleEvent ( EVENT_SHADOW_WORD_PAIN , 6s , 15s ) ; break ; case EVENT_CIRCLE_OF_DESTRUCTION : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 10.0f , true ) ) DoCast ( target , SPELL_CIRCLE_OF_DESTRUCTION ) ; _events . ScheduleEvent ( EVENT_CIRCLE_OF_DESTRUCTION , 12s ) ; break ; case EVENT_COWER_IN_FEAR : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 20.0f , true ) ) DoCast ( target , SPELL_COWER_IN_FEAR ) ; _events . ScheduleEvent ( EVENT_COWER_IN_FEAR , 10s ) ; break ; case EVENT_DARK_MENDING : if ( Unit * target = DoSelectLowestHpFriendly ( 40 , DUNGEON_MODE ( 30000 , 50000 ) ) ) { DoCast ( target , SPELL_DARK_MENDING ) ; _events . ScheduleEvent ( EVENT_DARK_MENDING , 20s ) ; } else { _events . ScheduleEvent ( EVENT_DARK_MENDING , 5s ) ; } break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_ghostly_priestAI > ( creature ) ; } } ; class npc_phantom_mage : public CreatureScript { public : npc_phantom_mage ( ) : CreatureScript ( " npc _ phantom _ mage " ) { } struct npc_phantom_mageAI : public npc_gauntlet_trash { npc_phantom_mageAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void EnterEvadeMode ( EvadeReason why ) override { if ( ! me -> HasAura ( AURA_HALLUCINATION ) ) npc_gauntlet_trash :: EnterEvadeMode ( why ) ; } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_FIREBALL , 3s ) ; _events . ScheduleEvent ( EVENT_FLAMESTRIKE , 6s ) ; _events . ScheduleEvent ( EVENT_FROSTBOLT , 9s ) ; _events . ScheduleEvent ( EVENT_CHAINS_OF_ICE , 12s ) ; _events . ScheduleEvent ( EVENT_HALLUCINATION , 40s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_FIREBALL : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_FIREBALL ) ; _events . ScheduleEvent ( EVENT_FIREBALL , 15s ) ; break ; case EVENT_FLAMESTRIKE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_FLAMESTRIKE ) ; _events . ScheduleEvent ( EVENT_FLAMESTRIKE , 15s ) ; break ; case EVENT_FROSTBOLT : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_FROSTBOLT ) ; _events . ScheduleEvent ( EVENT_FROSTBOLT , 15s ) ; break ; case EVENT_CHAINS_OF_ICE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM ) ) DoCast ( target , SPELL_CHAINS_OF_ICE ) ; _events . ScheduleEvent ( EVENT_CHAINS_OF_ICE , 15s ) ; break ; case EVENT_HALLUCINATION : me -> RemoveAllAuras ( ) ; DoCast ( me , SPELL_HALLUCINATION ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_phantom_mageAI > ( creature ) ; } } ; class npc_phantom_hallucination : public CreatureScript { public : npc_phantom_hallucination ( ) : CreatureScript ( " npc _ phantom _ hallucination " ) { } struct npc_phantom_hallucinationAI : public npc_phantom_mage :: npc_phantom_mageAI { npc_phantom_hallucinationAI ( Creature * creature ) : npc_phantom_mage :: npc_phantom_mageAI ( creature ) { } void Reset ( ) override { DoZoneInCombat ( me ) ; } void EnterEvadeMode ( EvadeReason why ) override { if ( me -> GetOwner ( ) && ! me -> GetOwner ( ) -> HasAura ( AURA_HALLUCINATION ) ) npc_phantom_mage :: npc_phantom_mageAI :: EnterEvadeMode ( why ) ; } void JustDied ( Unit * ) override { DoCastAOE ( SPELL_HALLUCINATION_2 ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_phantom_hallucinationAI > ( creature ) ; } } ; class npc_shadowy_mercenary : public CreatureScript { public : npc_shadowy_mercenary ( ) : CreatureScript ( " npc _ shadowy _ mercenary " ) { } struct npc_shadowy_mercenaryAI : public npc_gauntlet_trash { npc_shadowy_mercenaryAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_SHADOW_STEP , 23s ) ; _events . ScheduleEvent ( EVENT_DEADLY_POISON , 5s ) ; _events . ScheduleEvent ( EVENT_ENVENOMED_DAGGER_THROW , 10s ) ; _events . ScheduleEvent ( EVENT_KIDNEY_SHOT , 12s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_SHADOW_STEP : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 100.0f , true ) ) DoCast ( target , SPELL_SHADOW_STEP ) ; _events . ScheduleEvent ( EVENT_SHADOW_STEP , 8s ) ; break ; case EVENT_DEADLY_POISON : DoCastVictim ( SPELL_DEADLY_POISON ) ; _events . ScheduleEvent ( EVENT_DEADLY_POISON , 10s ) ; break ; case EVENT_ENVENOMED_DAGGER_THROW : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_ENVENOMED_DAGGER_THROW ) ; _events . ScheduleEvent ( EVENT_ENVENOMED_DAGGER_THROW , 10s ) ; break ; case EVENT_KIDNEY_SHOT : DoCastVictim ( SPELL_KIDNEY_SHOT ) ; _events . ScheduleEvent ( EVENT_KIDNEY_SHOT , 10s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_shadowy_mercenaryAI > ( creature ) ; } } ; class npc_spectral_footman : public CreatureScript { public : npc_spectral_footman ( ) : CreatureScript ( " npc _ spectral _ footman " ) { } struct npc_spectral_footmanAI : public npc_gauntlet_trash { npc_spectral_footmanAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_SPECTRAL_STRIKE , 14s ) ; _events . ScheduleEvent ( EVENT_SHIELD_BASH , 10s ) ; _events . ScheduleEvent ( EVENT_TORTURED_ENRAGE , 15s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_SPECTRAL_STRIKE : DoCastVictim ( SPELL_SPECTRAL_STRIKE ) ; _events . ScheduleEvent ( EVENT_SPECTRAL_STRIKE , 5s ) ; break ; case EVENT_SHIELD_BASH : DoCastVictim ( SPELL_SHIELD_BASH ) ; _events . ScheduleEvent ( EVENT_SHIELD_BASH , 5s ) ; break ; case EVENT_TORTURED_ENRAGE : DoCast ( me , SPELL_TORTURED_ENRAGE ) ; _events . ScheduleEvent ( EVENT_TORTURED_ENRAGE , 15s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_spectral_footmanAI > ( creature ) ; } } ; class npc_tortured_rifleman : public CreatureScript { public : npc_tortured_rifleman ( ) : CreatureScript ( " npc _ tortured _ rifleman " ) { } struct npc_tortured_riflemanAI : public npc_gauntlet_trash { npc_tortured_riflemanAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_SHOOT , 1 ) ; _events . ScheduleEvent ( EVENT_CURSED_ARROW , 7s ) ; _events . ScheduleEvent ( EVENT_FROST_TRAP , 10s ) ; _events . ScheduleEvent ( EVENT_ICE_SHOT , 15s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_SHOOT : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_SHOOT ) ; _events . ScheduleEvent ( EVENT_SHOOT , 2s ) ; break ; case EVENT_CURSED_ARROW : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_CURSED_ARROW ) ; _events . ScheduleEvent ( EVENT_CURSED_ARROW , 10s ) ; break ; case EVENT_FROST_TRAP : DoCast ( me , SPELL_FROST_TRAP ) ; _events . ScheduleEvent ( EVENT_FROST_TRAP , 30s ) ; break ; case EVENT_ICE_SHOT : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_ICE_SHOT ) ; _events . ScheduleEvent ( EVENT_ICE_SHOT , 15s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_tortured_riflemanAI > ( creature ) ; } } ; enum FrostswornGeneral { EVENT_SHIELD = 1 , EVENT_SPIKE = 2 , EVENT_CLONE = 3 , SAY_AGGRO = 0 , SAY_DEATH = 1 , SPELL_SHIELD_THROWN = 69222 , SPELL_SPIKE = 69184 , SPELL_CLONE = 69828 , SPELL_GHOST_VISUAL = 69861 , EVENT_BALEFUL_STRIKE = 1 , SPELL_BALEFUL_STRIKE = 69933 , SPELL_SPIRIT_BURST = 69900 } ; class npc_frostsworn_general : public CreatureScript { public : npc_frostsworn_general ( ) : CreatureScript ( " npc _ frostsworn _ general " ) { } struct npc_frostsworn_generalAI : public ScriptedAI { npc_frostsworn_generalAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = creature -> GetInstanceScript ( ) ; } void Reset ( ) override { _events . Reset ( ) ; _instance -> SetData ( DATA_FROSTSWORN_GENERAL , NOT_STARTED ) ; } void JustDied ( Unit * ) override { Talk ( SAY_DEATH ) ; _events . Reset ( ) ; _instance -> SetData ( DATA_FROSTSWORN_GENERAL , DONE ) ; } void JustEngagedWith ( Unit * ) override { Talk ( SAY_AGGRO ) ; DoZoneInCombat ( ) ; _events . ScheduleEvent ( EVENT_SHIELD , 5s ) ; _events . ScheduleEvent ( EVENT_SPIKE , 14s ) ; _events . ScheduleEvent ( EVENT_CLONE , 22s ) ; _instance -> SetData ( DATA_FROSTSWORN_GENERAL , IN_PROGRESS ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; while ( uint32 event = _events . ExecuteEvent ( ) ) { switch ( event ) { case EVENT_SHIELD : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 45.0f , true ) ) DoCast ( target , SPELL_SHIELD_THROWN ) ; _events . ScheduleEvent ( EVENT_SHIELD , 8s , 12s ) ; break ; case EVENT_SPIKE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 45.0f , true ) ) DoCast ( target , SPELL_SPIKE ) ; _events . ScheduleEvent ( EVENT_SPIKE , 15s , 20s ) ; break ; case EVENT_CLONE : SummonClones ( ) ; _events . ScheduleEvent ( EVENT_CLONE , 1min ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } void SummonClones ( ) { std :: list < Unit * > playerList ; SelectTargetList ( playerList , 5 , SELECT_TARGET_MAXTHREAT , 0 , 0.0f , true ) ; for ( Unit * target : playerList ) { if ( Creature * reflection = me -> SummonCreature ( NPC_REFLECTION , * target , TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT , 3000 ) ) { reflection -> SetImmuneToPC ( false ) ; target -> CastSpell ( reflection , SPELL_CLONE , true ) ; target -> CastSpell ( reflection , SPELL_GHOST_VISUAL , true ) ; reflection -> AI ( ) -> AttackStart ( target ) ; } } } private : InstanceScript * _instance ; EventMap _events ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_frostsworn_generalAI > ( creature ) ; } } ; class npc_spiritual_reflection : public CreatureScript { public : npc_spiritual_reflection ( ) : CreatureScript ( " npc _ spiritual _ reflection " ) { } struct npc_spiritual_reflectionAI : public ScriptedAI { npc_spiritual_reflectionAI ( Creature * creature ) : ScriptedAI ( creature ) { } void Reset ( ) override { _events . Reset ( ) ; } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_BALEFUL_STRIKE , 3s ) ; } void JustDied ( Unit * ) override { DoCastAOE ( SPELL_SPIRIT_BURST ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_BALEFUL_STRIKE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 8.0f , true ) ) DoCast ( target , SPELL_BALEFUL_STRIKE ) ; _events . ScheduleEvent ( EVENT_BALEFUL_STRIKE , 3s , 8s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } private : EventMap _events ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_spiritual_reflectionAI > ( creature ) ; } } ; class at_hor_intro_start : public AreaTriggerScript { public : at_hor_intro_start ( ) : AreaTriggerScript ( " at _ hor _ intro _ start " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetData ( DATA_INTRO_EVENT ) == NOT_STARTED ) _instance -> SetData ( DATA_INTRO_EVENT , IN_PROGRESS ) ; if ( player -> HasAura ( SPELL_QUEL_DELAR_COMPULSION ) && ( player -> GetQuestStatus ( QUEST_HALLS_OF_REFLECTION_ALLIANCE ) == QUEST_STATUS_INCOMPLETE || player -> GetQuestStatus ( QUEST_HALLS_OF_REFLECTION_HORDE ) == QUEST_STATUS_INCOMPLETE ) && _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) == NOT_STARTED ) { _instance -> SetData ( DATA_QUEL_DELAR_EVENT , IN_PROGRESS ) ; _instance -> SetGuidData ( DATA_QUEL_DELAR_INVOKER , player -> GetGUID ( ) ) ; } return true ; } } ; class at_hor_waves_restarter : public AreaTriggerScript { public : at_hor_waves_restarter ( ) : AreaTriggerScript ( " at _ hor _ waves _ restarter " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetData ( DATA_WAVE_COUNT ) ) return true ; if ( _instance -> GetData ( DATA_INTRO_EVENT ) == DONE && _instance -> GetBossState ( DATA_MARWYN ) != DONE ) { _instance -> ProcessEvent ( 0 , EVENT_SPAWN_WAVES ) ; if ( Creature * falric = ObjectAccessor :: GetCreature ( * player , _instance -> GetGuidData ( DATA_FALRIC ) ) ) { falric -> CastSpell ( falric , SPELL_BOSS_SPAWN_AURA , true ) ; falric -> SetVisible ( true ) ; } if ( Creature * marwyn = ObjectAccessor :: GetCreature ( * player , _instance -> GetGuidData ( DATA_MARWYN ) ) ) { marwyn -> CastSpell ( marwyn , SPELL_BOSS_SPAWN_AURA , true ) ; marwyn -> SetVisible ( true ) ; } } return true ; } } ; class at_hor_impenetrable_door : public AreaTriggerScript { public : at_hor_impenetrable_door ( ) : AreaTriggerScript ( " at _ hor _ impenetrable _ door " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetBossState ( DATA_MARWYN ) == DONE ) return true ; return false ; } } ; class at_hor_shadow_throne : public AreaTriggerScript { public : at_hor_shadow_throne ( ) : AreaTriggerScript ( " at _ hor _ shadow _ throne " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetBossState ( DATA_THE_LICH_KING_ESCAPE ) == NOT_STARTED ) _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , IN_PROGRESS ) ; return true ; } } ; enum EscapeEvents { EVENT_RAGING_GHOUL_JUMP = 1 , EVENT_RISEN_WITCH_DOCTOR_CURSE , EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT , EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY , EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY , EVENT_LUMBERING_ABOMINATION_CLEAVE } ; class HoRStartMovementEvent : public BasicEvent { public : explicit HoRStartMovementEvent ( Creature * owner ) : _owner ( owner ) { } bool Execute ( uint64 , uint32 ) override { _owner -> SetReactState ( REACT_AGGRESSIVE ) ; if ( Unit * target = _owner -> AI ( ) -> SelectTarget ( SELECT_TARGET_RANDOM , 0 , 0.0f , true ) ) _owner -> AI ( ) -> AttackStart ( target ) ; return true ; } private : Creature * _owner ; } ; struct npc_escape_event_trash : public ScriptedAI { npc_escape_event_trash ( Creature * creature ) : ScriptedAI ( creature ) , _instance ( creature -> GetInstanceScript ( ) ) { } void Reset ( ) override { _events . Reset ( ) ; } void UpdateAI ( uint32 ) override { if ( _instance -> GetBossState ( DATA_THE_LICH_KING_ESCAPE ) == FAIL || _instance -> GetBossState ( DATA_THE_LICH_KING_ESCAPE ) == NOT_STARTED ) me -> DespawnOrUnsummon ( ) ; } void IsSummonedBy ( WorldObject * ) override { DoZoneInCombat ( me ) ; if ( Creature * leader = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ESCAPE_LEADER ) ) ) { me -> SetImmuneToPC ( false ) ; me -> SetInCombatWith ( leader ) ; leader -> SetInCombatWith ( me ) ; AddThreat ( leader , 0.0f ) ; } } protected : EventMap _events ; InstanceScript * _instance ; } ; class npc_raging_ghoul : public CreatureScript { public : npc_raging_ghoul ( ) : CreatureScript ( " npc _ raging _ ghoul " ) { } struct npc_raging_ghoulAI : public npc_escape_event_trash { npc_raging_ghoulAI ( Creature * creature ) : npc_escape_event_trash ( creature ) { } void Reset ( ) override { npc_escape_event_trash :: Reset ( ) ; _events . ScheduleEvent ( EVENT_RAGING_GHOUL_JUMP , 5s ) ; } void IsSummonedBy ( WorldObject * summoner ) override { me -> CastSpell ( me , SPELL_RAGING_GHOUL_SPAWN , true ) ; me -> SetReactState ( REACT_PASSIVE ) ; me -> HandleEmoteCommand ( EMOTE_ONESHOT_EMERGE ) ; me -> m_Events . AddEvent ( new HoRStartMovementEvent ( me ) , me -> m_Events . CalculateTime ( 5000 ) ) ; npc_escape_event_trash :: IsSummonedBy ( summoner ) ; } void UpdateAI ( uint32 diff ) override { npc_escape_event_trash :: UpdateAI ( diff ) ; if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_RAGING_GHOUL_JUMP : if ( Unit * victim = me -> GetVictim ( ) ) { if ( me -> IsInRange ( victim , 5.0f , 30.0f ) ) { DoCast ( victim , SPELL_GHOUL_JUMP ) ; return ; } } _events . ScheduleEvent ( EVENT_RAGING_GHOUL_JUMP , 500ms ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_raging_ghoulAI > ( creature ) ; } } ; class npc_risen_witch_doctor : public CreatureScript { public : npc_risen_witch_doctor ( ) : CreatureScript ( " npc _ risen _ witch _ doctor " ) { } struct npc_risen_witch_doctorAI : public npc_escape_event_trash { npc_risen_witch_doctorAI ( Creature * creature ) : npc_escape_event_trash ( creature ) { } void Reset ( ) override { npc_escape_event_trash :: Reset ( ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT , 6s ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY , 15s ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_CURSE , 7s ) ; } void IsSummonedBy ( WorldObject * summoner ) override { me -> CastSpell ( me , SPELL_RISEN_WITCH_DOCTOR_SPAWN , true ) ; me -> SetReactState ( REACT_PASSIVE ) ; me -> HandleEmoteCommand ( EMOTE_ONESHOT_EMERGE ) ; me -> m_Events . AddEvent ( new HoRStartMovementEvent ( me ) , me -> m_Events . CalculateTime ( 5000 ) ) ; npc_escape_event_trash :: IsSummonedBy ( summoner ) ; } void UpdateAI ( uint32 diff ) override { npc_escape_event_trash :: UpdateAI ( diff ) ; if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_RISEN_WITCH_DOCTOR_CURSE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 30.0f , true ) ) DoCast ( target , SPELL_CURSE_OF_DOOM ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_CURSE , 10s , 15s ) ; break ; case EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT : if ( Unit * target = SelectTarget ( SELECT_TARGET_MAXTHREAT , 0 , 20.0f , true ) ) DoCast ( target , SPELL_SHADOW_BOLT ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT , 2s , 3s ) ; break ; case EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY : if ( SelectTarget ( SELECT_TARGET_RANDOM , 0 , 30.0f , true ) ) DoCastAOE ( SPELL_SHADOW_BOLT_VOLLEY ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY , 15s , 22s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_risen_witch_doctorAI > ( creature ) ; } } ; class npc_lumbering_abomination : public CreatureScript { public : npc_lumbering_abomination ( ) : CreatureScript ( " npc _ lumbering _ abomination " ) { } struct npc_lumbering_abominationAI : public npc_escape_event_trash { npc_lumbering_abominationAI ( Creature * creature ) : npc_escape_event_trash ( creature ) { } void Reset ( ) override { npc_escape_event_trash :: Reset ( ) ; _events . ScheduleEvent ( EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY , 15s ) ; _events . ScheduleEvent ( EVENT_LUMBERING_ABOMINATION_CLEAVE , 6s ) ; } void UpdateAI ( uint32 diff ) override { npc_escape_event_trash :: UpdateAI ( diff ) ; if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY : DoCastVictim ( SPELL_VOMIT_SPRAY ) ; _events . ScheduleEvent ( EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY , 15s , 20s ) ; break ; case EVENT_LUMBERING_ABOMINATION_CLEAVE : DoCastVictim ( SPELL_CLEAVE ) ; _events . ScheduleEvent ( EVENT_LUMBERING_ABOMINATION_CLEAVE , 7s , 9s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_lumbering_abominationAI > ( creature ) ; } } ; enum QuelDelarUther { ACTION_UTHER_START_SCREAM = 1 , ACTION_UTHER_OUTRO = 2 , EVENT_UTHER_1 = 1 , EVENT_UTHER_2 = 2 , EVENT_UTHER_3 = 3 , EVENT_UTHER_4 = 4 , EVENT_UTHER_5 = 5 , EVENT_UTHER_6 = 6 , EVENT_UTHER_7 = 7 , EVENT_UTHER_8 = 8 , EVENT_UTHER_9 = 9 , EVENT_UTHER_10 = 10 , EVENT_UTHER_11 = 11 , EVENT_UTHER_FACING = 12 , EVENT_UTHER_KNEEL = 13 , SAY_UTHER_QUEL_DELAR_1 = 16 , SAY_UTHER_QUEL_DELAR_2 = 17 , SAY_UTHER_QUEL_DELAR_3 = 18 , SAY_UTHER_QUEL_DELAR_4 = 19 , SAY_UTHER_QUEL_DELAR_5 = 20 , SAY_UTHER_QUEL_DELAR_6 = 21 , SPELL_ESSENCE_OF_CAPTURED_1 = 73036 } ; enum QuelDelarSword { SPELL_WHIRLWIND_VISUAL = 70300 , SPELL_HEROIC_STRIKE = 29426 , SPELL_WHIRLWIND = 67716 , SPELL_BLADESTORM = 67541 , NPC_QUEL_DELAR = 37158 , POINT_TAKE_OFF = 1 , EVENT_QUEL_DELAR_INIT = 1 , EVENT_QUEL_DELAR_FLIGHT_INIT = 2 , EVENT_QUEL_DELAR_FLIGHT = 3 , EVENT_QUEL_DELAR_LAND = 4 , EVENT_QUEL_DELAR_FIGHT = 5 , EVENT_QUEL_DELAR_BLADESTORM = 6 , EVENT_QUEL_DELAR_HEROIC_STRIKE = 7 , EVENT_QUEL_DELAR_WHIRLWIND = 8 , SAY_QUEL_DELAR_SWORD = 0 } ; enum QuelDelarMisc { SAY_FROSTMOURNE_BUNNY = 0 , SPELL_QUEL_DELAR_WILL = 70698 } ; Position const QuelDelarCenterPos = { 5309.259f , 2006.390f , 718.046f , 0.0f } ; Position const QuelDelarSummonPos = { 5298.473f , 1994.852f , 709.424f , 3.979351f } ; Position const QuelDelarMovement [ ] = { { 5292.870f , 1998.950f , 718.046f , 0.0f } , { 5295.819f , 1991.912f , 707.707f , 0.0f } , { 5295.301f , 1989.782f , 708.696f , 0.0f } } ; Position const UtherQuelDelarMovement [ ] = { { 5336.830f , 1981.700f , 709.319f , 0.0f } , { 5314.350f , 1993.440f , 707.726f , 0.0f } } ; class npc_uther_quel_delar : public CreatureScript { public : npc_uther_quel_delar ( ) : CreatureScript ( " npc _ uther _ quel _ delar " ) { } struct npc_uther_quel_delarAI : public ScriptedAI { npc_uther_quel_delarAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; } void Reset ( ) override { if ( _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) != IN_PROGRESS && _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) != SPECIAL ) return ; _events . Reset ( ) ; _events . ScheduleEvent ( EVENT_UTHER_1 , 1 ) ; } void DamageTaken ( Unit * , uint32 & damage ) override { if ( damage >= me -> GetHealth ( ) ) damage = me -> GetHealth ( ) - 1 ; } void DoAction ( int32 action ) override { switch ( action ) { case ACTION_UTHER_START_SCREAM : _instance -> SetData ( DATA_QUEL_DELAR_EVENT , SPECIAL ) ; _events . ScheduleEvent ( EVENT_UTHER_2 , 0 ) ; break ; case ACTION_UTHER_OUTRO : _events . ScheduleEvent ( EVENT_UTHER_6 , 0 ) ; break ; default : break ; } } void MovementInform ( uint32 , uint32 pointId ) override { switch ( pointId ) { case 1 : _events . ScheduleEvent ( EVENT_UTHER_FACING , 1s ) ; break ; default : break ; } } void UpdateAI ( uint32 diff ) override { if ( _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) != IN_PROGRESS && _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) != SPECIAL ) return ; _events . Update ( diff ) ; while ( uint32 eventId = _events . ExecuteEvent ( ) ) { switch ( eventId ) { case EVENT_UTHER_1 : Talk ( SAY_UTHER_QUEL_DELAR_1 ) ; break ; case EVENT_UTHER_2 : if ( Creature * bunny = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FROSTMOURNE_ALTAR_BUNNY ) ) ) if ( Unit * target = ObjectAccessor :: GetPlayer ( * me , _instance -> GetGuidData ( DATA_QUEL_DELAR_INVOKER ) ) ) bunny -> CastSpell ( target , SPELL_QUEL_DELAR_WILL , true ) ; _events . ScheduleEvent ( EVENT_UTHER_3 , 2000 ) ; break ; case EVENT_UTHER_3 : me -> SummonCreature ( NPC_QUEL_DELAR , QuelDelarSummonPos ) ; _events . ScheduleEvent ( EVENT_UTHER_4 , 2000 ) ; break ; case EVENT_UTHER_4 : Talk ( SAY_UTHER_QUEL_DELAR_2 ) ; _events . ScheduleEvent ( EVENT_UTHER_5 , 8000 ) ; break ; case EVENT_UTHER_5 : me -> GetMotionMaster ( ) -> MovePoint ( 1 , UtherQuelDelarMovement [ 0 ] ) ; break ; case EVENT_UTHER_6 : me -> SetWalk ( true ) ; me -> GetMotionMaster ( ) -> MovePoint ( 0 , UtherQuelDelarMovement [ 1 ] ) ; _events . ScheduleEvent ( EVENT_UTHER_7 , 5000 ) ; break ; case EVENT_UTHER_7 : Talk ( SAY_UTHER_QUEL_DELAR_3 ) ; _events . ScheduleEvent ( EVENT_UTHER_8 , 12000 ) ; break ; case EVENT_UTHER_8 : Talk ( SAY_UTHER_QUEL_DELAR_4 ) ; _events . ScheduleEvent ( EVENT_UTHER_9 , 7000 ) ; break ; case EVENT_UTHER_9 : Talk ( SAY_UTHER_QUEL_DELAR_5 ) ; _events . ScheduleEvent ( EVENT_UTHER_10 , 10000 ) ; break ; case EVENT_UTHER_10 : Talk ( SAY_UTHER_QUEL_DELAR_6 ) ; _events . ScheduleEvent ( EVENT_UTHER_11 , 5000 ) ; break ; case EVENT_UTHER_11 : DoCast ( me , SPELL_ESSENCE_OF_CAPTURED_1 , true ) ; me -> DespawnOrUnsummon ( 3000 ) ; _instance -> SetData ( DATA_QUEL_DELAR_EVENT , DONE ) ; break ; case EVENT_UTHER_FACING : if ( Creature * bunny = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FROSTMOURNE_ALTAR_BUNNY ) ) ) me -> SetFacingToObject ( bunny ) ; _events . ScheduleEvent ( EVENT_UTHER_KNEEL , 1s ) ; break ; case EVENT_UTHER_KNEEL : me -> HandleEmoteCommand ( EMOTE_STATE_KNEEL ) ; break ; default : break ; } } } private : EventMap _events ; InstanceScript * _instance ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_uther_quel_delarAI > ( creature ) ; } } ; class npc_quel_delar_sword : public CreatureScript { public : npc_quel_delar_sword ( ) : CreatureScript ( " npc _ quel _ delar _ sword " ) { } struct npc_quel_delar_swordAI : public ScriptedAI { npc_quel_delar_swordAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; me -> SetDisplayId ( me -> GetCreatureTemplate ( ) -> Modelid2 ) ; _intro = true ; } void Reset ( ) override { _events . Reset ( ) ; me -> SetSpeedRate ( MOVE_FLIGHT , 4.5f ) ; DoCast ( SPELL_WHIRLWIND_VISUAL ) ; if ( _intro ) _events . ScheduleEvent ( EVENT_QUEL_DELAR_INIT , 0 ) ; else me -> SetImmuneToAll ( false ) ; } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_QUEL_DELAR_HEROIC_STRIKE , 4s ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_BLADESTORM , 6s ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_WHIRLWIND , 6s ) ; } void JustDied ( Unit * ) override { if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_UTHER_QUEL_DELAR ) ) ) uther -> AI ( ) -> DoAction ( ACTION_UTHER_OUTRO ) ; } void MovementInform ( uint32 type , uint32 pointId ) override { if ( type != EFFECT_MOTION_TYPE ) return ; switch ( pointId ) { case POINT_TAKE_OFF : _events . ScheduleEvent ( EVENT_QUEL_DELAR_FLIGHT , 0 ) ; break ; default : break ; } } void UpdateAI ( uint32 diff ) override { _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; if ( ! UpdateVictim ( ) ) { while ( uint32 eventId = _events . ExecuteEvent ( ) ) { switch ( eventId ) { case EVENT_QUEL_DELAR_INIT : if ( Creature * bunny = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FROSTMOURNE_ALTAR_BUNNY ) ) ) bunny -> AI ( ) -> Talk ( SAY_FROSTMOURNE_BUNNY ) ; _intro = false ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_FLIGHT_INIT , 2500ms ) ; break ; case EVENT_QUEL_DELAR_FLIGHT_INIT : me -> GetMotionMaster ( ) -> MoveTakeoff ( POINT_TAKE_OFF , QuelDelarMovement [ 0 ] ) ; break ; case EVENT_QUEL_DELAR_FLIGHT : { me -> GetMotionMaster ( ) -> MoveCirclePath ( QuelDelarCenterPos . GetPositionX ( ) , QuelDelarCenterPos . GetPositionY ( ) , 718.046f , 18.0f , true , 16 ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_LAND , 15s ) ; break ; } case EVENT_QUEL_DELAR_LAND : me -> StopMoving ( ) ; me -> GetMotionMaster ( ) -> Clear ( ) ; me -> GetMotionMaster ( ) -> MoveLand ( 0 , QuelDelarMovement [ 1 ] ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_FIGHT , 6s ) ; break ; case EVENT_QUEL_DELAR_FIGHT : Talk ( SAY_QUEL_DELAR_SWORD ) ; me -> GetMotionMaster ( ) -> MovePoint ( 0 , QuelDelarMovement [ 2 ] ) ; me -> SetImmuneToAll ( false ) ; break ; default : break ; } } } else { while ( uint32 eventId = _events . ExecuteEvent ( ) ) { switch ( eventId ) { case EVENT_QUEL_DELAR_BLADESTORM : DoCast ( me , SPELL_BLADESTORM ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_BLADESTORM , 10s ) ; break ; case EVENT_QUEL_DELAR_HEROIC_STRIKE : DoCastVictim ( SPELL_HEROIC_STRIKE ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_HEROIC_STRIKE , 6s ) ; break ; case EVENT_QUEL_DELAR_WHIRLWIND : DoCastAOE ( SPELL_WHIRLWIND ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_WHIRLWIND , 1s ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } } private : EventMap _events ; InstanceScript * _instance ; bool _intro ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_quel_delar_swordAI > ( creature ) ; } } ; class at_hor_uther_quel_delar_start : public AreaTriggerScript { public : at_hor_uther_quel_delar_start ( ) : AreaTriggerScript ( " at _ hor _ uther _ quel _ delar _ start " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) == IN_PROGRESS ) if ( Creature * uther = ObjectAccessor :: GetCreature ( * player , _instance -> GetGuidData ( DATA_UTHER_QUEL_DELAR ) ) ) uther -> AI ( ) -> DoAction ( ACTION_UTHER_START_SCREAM ) ; return true ; } } ; class spell_hor_start_halls_of_reflection_quest_ae : public SpellScriptLoader { public : spell_hor_start_halls_of_reflection_quest_ae ( ) : SpellScriptLoader ( " spell _ hor _ start _ halls _ of _ reflection _ quest _ ae " ) { } class spell_hor_start_halls_of_reflection_quest_ae_SpellScript : public SpellScript { PrepareSpellScript ( spell_hor_start_halls_of_reflection_quest_ae_SpellScript ) ; void StartQuests ( SpellEffIndex ) { if ( Player * target = GetHitPlayer ( ) ) { if ( target -> GetTeam ( ) == ALLIANCE ) target -> CastSpell ( target , SPELL_START_HALLS_OF_REFLECTION_QUEST_A , true ) ; else target -> CastSpell ( target , SPELL_START_HALLS_OF_REFLECTION_QUEST_H , true ) ; } } void Register ( ) override { OnEffectHitTarget += SpellEffectFn ( spell_hor_start_halls_of_reflection_quest_ae_SpellScript :: StartQuests , EFFECT_0 , SPELL_EFFECT_SCRIPT_EFFECT ) ; } } ; SpellScript * GetSpellScript ( ) const override { return new spell_hor_start_halls_of_reflection_quest_ae_SpellScript ( ) ; } } ; class spell_hor_evasion : public SpellScriptLoader { public : spell_hor_evasion ( ) : SpellScriptLoader ( " spell _ hor _ evasion " ) { } class spell_hor_evasion_SpellScript : public SpellScript { PrepareSpellScript ( spell_hor_evasion_SpellScript ) ; bool Load ( ) override { return GetCaster ( ) -> GetTypeId ( ) == TYPEID_UNIT ; } void SetDest ( SpellDestination & dest ) { WorldObject * target = GetExplTargetWorldObject ( ) ; Position pos ( * target ) ; Position home = GetCaster ( ) -> ToCreature ( ) -> GetHomePosition ( ) ; if ( pos . IsInDist2d ( & home , 15.0f ) ) return ; float angle = pos . GetAbsoluteAngle ( & home ) ; float dist = GetSpellInfo ( ) -> Effects [ EFFECT_0 ] . CalcRadius ( GetCaster ( ) ) ; target -> MovePosition ( pos , dist , angle ) ; dest . Relocate ( pos ) ; } void Register ( ) override { OnDestinationTargetSelect += SpellDestinationTargetSelectFn ( spell_hor_evasion_SpellScript :: SetDest , EFFECT_0 , TARGET_DEST_TARGET_RADIUS ) ; } } ; SpellScript * GetSpellScript ( ) const override { return new spell_hor_evasion_SpellScript ( ) ; } } ; class spell_hor_gunship_cannon_fire : public SpellScriptLoader { public : spell_hor_gunship_cannon_fire ( ) : SpellScriptLoader ( " spell _ hor _ gunship _ cannon _ fire " ) { } class spell_hor_gunship_cannon_fire_AuraScript : public AuraScript { PrepareAuraScript ( spell_hor_gunship_cannon_fire_AuraScript ) ; void HandlePeriodic ( AuraEffect const * ) { if ( ! urand ( 0 , 2 ) ) { if ( GetTarget ( ) -> GetEntry ( ) == NPC_GUNSHIP_CANNON_HORDE ) GetTarget ( ) -> CastSpell ( nullptr , SPELL_GUNSHIP_CANNON_FIRE_MISSILE_HORDE , true ) ; else GetTarget ( ) -> CastSpell ( nullptr , SPELL_GUNSHIP_CANNON_FIRE_MISSILE_ALLIANCE , true ) ; } } void Register ( ) override { OnEffectPeriodic += AuraEffectPeriodicFn ( spell_hor_gunship_cannon_fire_AuraScript :: HandlePeriodic , EFFECT_0 , SPELL_AURA_PERIODIC_TRIGGER_SPELL ) ; } } ; AuraScript * GetAuraScript ( ) const override { return new spell_hor_gunship_cannon_fire_AuraScript ( ) ; } } ; class spell_hor_quel_delars_will : public SpellScript { PrepareSpellScript ( spell_hor_quel_delars_will ) ; bool Validate ( SpellInfo const * spellInfo ) override { return ValidateSpellInfo ( { spellInfo -> Effects [ EFFECT_0 ] . TriggerSpell } ) ; } void HandleReagent ( SpellEffIndex effIndex ) { PreventHitDefaultEffect ( effIndex ) ; GetHitUnit ( ) -> CastSpell ( GetCaster ( ) , GetSpellInfo ( ) -> Effects [ effIndex ] . TriggerSpell , TriggerCastFlags ( TRIGGERED_FULL_MASK & ~ TRIGGERED_IGNORE_POWER_AND_REAGENT_COST ) ) ; } void Register ( ) override { OnEffectHitTarget += SpellEffectFn ( spell_hor_quel_delars_will :: HandleReagent , EFFECT_0 , SPELL_EFFECT_FORCE_CAST ) ; } } ; void AddSC_halls_of_reflection ( ) { new at_hor_intro_start ( ) ; new at_hor_waves_restarter ( ) ; new at_hor_impenetrable_door ( ) ; new at_hor_shadow_throne ( ) ; new at_hor_uther_quel_delar_start ( ) ; new npc_jaina_or_sylvanas_intro_hor ( ) ; new npc_jaina_or_sylvanas_escape_hor ( ) ; new npc_the_lich_king_escape_hor ( ) ; new npc_ghostly_priest ( ) ; new npc_phantom_mage ( ) ; new npc_phantom_hallucination ( ) ; new npc_shadowy_mercenary ( ) ; new npc_spectral_footman ( ) ; new npc_tortured_rifleman ( ) ; new npc_frostsworn_general ( ) ; new npc_spiritual_reflection ( ) ; new npc_raging_ghoul ( ) ; new npc_risen_witch_doctor ( ) ; new npc_lumbering_abomination ( ) ; new npc_uther_quel_delar ( ) ; new npc_quel_delar_sword ( ) ; new spell_hor_start_halls_of_reflection_quest_ae ( ) ; new spell_hor_evasion ( ) ; new spell_hor_gunship_cannon_fire ( ) ; RegisterSpellScript ( spell_hor_quel_delars_will ) ; } </DOCUMENT>
<DOCUMENT_ID="esqudo/cymrucoin/tree/master/src/qt/aboutdialog.cpp"> # include " aboutdialog . h " # include " ui _ aboutdialog . h " # include " clientmodel . h " # include " clientversion . h " const int ABOUTDIALOG_COPYRIGHT_YEAR = 2014 ; AboutDialog :: AboutDialog ( QWidget * parent ) : QDialog ( parent ) , ui ( new Ui :: AboutDialog ) { ui -> setupUi ( this ) ; ui -> copyrightLabel -> setText ( tr ( " Copyright " ) + QString ( " ▁ & copy ; ▁ 2009 - % 1 ▁ " ) . arg ( COPYRIGHT_YEAR ) + tr ( " The ▁ Bitcoin ▁ developers " ) + QString ( " < br > " ) + tr ( " Copyright " ) + QString ( " ▁ & copy ; ▁ " ) + tr ( " % 1 ▁ StartJOIN " ) . arg ( ABOUTDIALOG_COPYRIGHT_YEAR ) ) ; } void AboutDialog :: setModel ( ClientModel * model ) { if ( model ) { ui -> versionLabel -> setText ( model -> formatFullVersion ( ) ) ; } } AboutDialog :: ~ AboutDialog ( ) { delete ui ; } void AboutDialog :: on_buttonBox_accepted ( ) { close ( ) ; } </DOCUMENT>
<DOCUMENT_ID="Shutok/OregonCustom/tree/master/dep/g3dlite/source/Color3.cpp"> # include " G3D / platform . h " # include < stdlib . h > # include " G3D / Color3 . h " # include " G3D / Vector3 . h " # include " G3D / format . h " # include " G3D / BinaryInput . h " # include " G3D / BinaryOutput . h " # include " G3D / Color3uint8 . h " # include " G3D / Any . h " # include " G3D / stringutils . h " namespace G3D { Color3 :: Color3 ( const Any & any ) { * this = Color3 :: zero ( ) ; any . verifyName ( " Color3" ) ; std :: string name = toLower ( any . name ( ) ) ; switch ( any . type ( ) ) { case Any :: TABLE : for ( Any :: AnyTable :: Iterator it = any . table ( ) . begin ( ) ; it . hasMore ( ) ; ++ it ) { const std :: string & key = toLower ( it -> key ) ; if ( key == " r " ) { r = it -> value ; } else if ( key == " g " ) { g = it -> value ; } else if ( key == " b " ) { b = it -> value ; } else { any . verify ( false , " Illegal ▁ key : ▁ " + it -> key ) ; } } break ; case Any :: ARRAY : if ( name == " color3" ) { any . verifySize ( 3 ) ; r = any [ 0 ] ; g = any [ 1 ] ; b = any [ 2 ] ; } else if ( name == " color3 : : one " ) { any . verifySize ( 0 ) ; * this = one ( ) ; } else if ( name == " color3 : : zero " ) { any . verifySize ( 0 ) ; * this = zero ( ) ; } else if ( name == " color3 : : fromargb " ) { * this = Color3 :: fromARGB ( ( int ) any [ 0 ] . number ( ) ) ; } else { any . verify ( false , " Expected ▁ Color3 ▁ constructor " ) ; } break ; default : any . verify ( false , " Bad ▁ Color3 ▁ constructor " ) ; } } Color3 :: operator Any ( ) const { Any a ( Any :: ARRAY , " Color3" ) ; a . append ( r , g , b ) ; return a ; } Color3 Color3 :: ansiMap ( uint32 i ) { static const Color3 map [ ] = { Color3 :: black ( ) , Color3 :: red ( ) * 0.75f , Color3 :: green ( ) * 0.75f , Color3 :: yellow ( ) * 0.75f , Color3 :: blue ( ) * 0.75f , Color3 :: purple ( ) * 0.75f , Color3 :: cyan ( ) * 0.75f , Color3 :: white ( ) * 0.75f , Color3 :: white ( ) * 0.90f , Color3 :: red ( ) , Color3 :: green ( ) , Color3 :: yellow ( ) , Color3 :: blue ( ) , Color3 :: purple ( ) , Color3 :: cyan ( ) , Color3 :: white ( ) } ; return map [ i & 15 ] ; } Color3 Color3 :: pastelMap ( uint32 i ) { uint32 x = Crypto :: crc32 ( & i , sizeof ( uint32 ) ) ; Vector3 v ( ( ( x >> 22 ) & 1023 ) / 1023.0f , ( ( ( x >> 11 ) & 2047 ) / 2047.0f ) * 0.5f + 0.25f , ( ( x & 2047 ) / 2047.0f ) * 0.75f + 0.25f ) ; return Color3 :: fromHSV ( v ) ; } const Color3 & Color3 :: red ( ) { static Color3 c ( 1.0f , 0.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: green ( ) { static Color3 c ( 0.0f , 1.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: blue ( ) { static Color3 c ( 0.0f , 0.0f , 1.0f ) ; return c ; } const Color3 & Color3 :: purple ( ) { static Color3 c ( 0.7f , 0.0f , 1.0f ) ; return c ; } const Color3 & Color3 :: cyan ( ) { static Color3 c ( 0.0f , 0.7f , 1.0f ) ; return c ; } const Color3 & Color3 :: yellow ( ) { static Color3 c ( 1.0f , 1.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: brown ( ) { static Color3 c ( 0.5f , 0.5f , 0.0f ) ; return c ; } const Color3 & Color3 :: orange ( ) { static Color3 c ( 1.0f , 0.5f , 0.0f ) ; return c ; } const Color3 & Color3 :: black ( ) { static Color3 c ( 0.0f , 0.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: zero ( ) { static Color3 c ( 0.0f , 0.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: one ( ) { static Color3 c ( 1.0f , 1.0f , 1.0f ) ; return c ; } const Color3 & Color3 :: gray ( ) { static Color3 c ( 0.7f , 0.7f , 0.7f ) ; return c ; } const Color3 & Color3 :: white ( ) { static Color3 c ( 1 , 1 , 1 ) ; return c ; } bool Color3 :: isFinite ( ) const { return G3D :: isFinite ( r ) && G3D :: isFinite ( g ) && G3D :: isFinite ( b ) ; } Color3 :: Color3 ( BinaryInput & bi ) { deserialize ( bi ) ; } void Color3 :: deserialize ( BinaryInput & bi ) { r = bi . readFloat32 ( ) ; g = bi . readFloat32 ( ) ; b = bi . readFloat32 ( ) ; } void Color3 :: serialize ( BinaryOutput & bo ) const { bo . writeFloat32 ( r ) ; bo . writeFloat32 ( g ) ; bo . writeFloat32 ( b ) ; } const Color3 & Color3 :: wheelRandom ( ) { static const Color3 colorArray [ 8 ] = { Color3 :: blue ( ) , Color3 :: red ( ) , Color3 :: green ( ) , Color3 :: orange ( ) , Color3 :: yellow ( ) , Color3 :: cyan ( ) , Color3 :: purple ( ) , Color3 :: brown ( ) } ; return colorArray [ iRandom ( 0 , 7 ) ] ; } size_t Color3 :: hashCode ( ) const { unsigned int rhash = ( * ( int * ) ( void * ) ( & r ) ) ; unsigned int ghash = ( * ( int * ) ( void * ) ( & g ) ) ; unsigned int bhash = ( * ( int * ) ( void * ) ( & b ) ) ; return rhash + ( ghash * 37 ) + ( bhash * 101 ) ; } Color3 :: Color3 ( const Vector3 & v ) { r = v . x ; g = v . y ; b = v . z ; } Color3 :: Color3 ( const class Color3uint8 & other ) { r = other . r / 255.0f ; g = other . g / 255.0f ; b = other . b / 255.0f ; } Color3 Color3 :: fromARGB ( uint32 x ) { return Color3 ( ( float ) ( ( x >> 16 ) & 0xFF ) , ( float ) ( ( x >> 8 ) & 0xFF ) , ( float ) ( x & 0xFF ) ) / 255.0f ; } Color3 Color3 :: random ( ) { return Color3 ( uniformRandom ( ) , uniformRandom ( ) , uniformRandom ( ) ) . direction ( ) ; } Color3 & Color3 :: operator /= ( float fScalar ) { if ( fScalar != 0.0f ) { float fInvScalar = 1.0f / fScalar ; r *= fInvScalar ; g *= fInvScalar ; b *= fInvScalar ; } else { r = ( float ) G3D :: finf ( ) ; g = ( float ) G3D :: finf ( ) ; b = ( float ) G3D :: finf ( ) ; } return * this ; } float Color3 :: unitize ( float fTolerance ) { float fLength = length ( ) ; if ( fLength > fTolerance ) { float fInvLength = 1.0f / fLength ; r *= fInvLength ; g *= fInvLength ; b *= fInvLength ; } else { fLength = 0.0f ; } return fLength ; } Color3 Color3 :: fromHSV ( const Vector3 & _hsv ) { debugAssertM ( ( _hsv . x <= 1.0f && _hsv . x >= 0.0f ) && ( _hsv . y <= 1.0f && _hsv . y >= 0.0f ) && ( _hsv . z <= 1.0f && _hsv . z >= 0.0f ) , " H , S , V ▁ must ▁ be ▁ between ▁ [ 0,1 ] " ) ; const int i = iMin ( 5 , G3D :: iFloor ( 6.0 * _hsv . x ) ) ; const float f = 6.0f * _hsv . x - i ; const float m = _hsv . z * ( 1.0f - ( _hsv . y ) ) ; const float n = _hsv . z * ( 1.0f - ( _hsv . y * f ) ) ; const float k = _hsv . z * ( 1.0f - ( _hsv . y * ( 1 - f ) ) ) ; switch ( i ) { case 0 : return Color3 ( _hsv . z , k , m ) ; case 1 : return Color3 ( n , _hsv . z , m ) ; case 2 : return Color3 ( m , _hsv . z , k ) ; case 3 : return Color3 ( m , n , _hsv . z ) ; case 4 : return Color3 ( k , m , _hsv . z ) ; case 5 : return Color3 ( _hsv . z , m , n ) ; default : debugAssertM ( false , " fell ▁ through ▁ switch . . " ) ; } return Color3 :: black ( ) ; } Vector3 Color3 :: toHSV ( const Color3 & _rgb ) { debugAssertM ( ( _rgb . r <= 1.0f && _rgb . r >= 0.0f ) && ( _rgb . g <= 1.0f && _rgb . g >= 0.0f ) && ( _rgb . b <= 1.0f && _rgb . b >= 0.0f ) , " R , G , B ▁ must ▁ be ▁ between ▁ [ 0,1 ] " ) ; Vector3 hsv = Vector3 :: zero ( ) ; hsv . z = G3D :: max ( G3D :: max ( _rgb . r , _rgb . g ) , _rgb . b ) ; if ( G3D :: fuzzyEq ( hsv . z , 0.0f ) ) { return hsv ; } const float x = G3D :: min ( G3D :: min ( _rgb . r , _rgb . g ) , _rgb . b ) ; hsv . y = ( hsv . z - x ) / hsv . z ; if ( G3D :: fuzzyEq ( hsv . y , 0.0f ) ) { return hsv ; } Vector3 rgbN ; rgbN . x = ( hsv . z - _rgb . r ) / ( hsv . z - x ) ; rgbN . y = ( hsv . z - _rgb . g ) / ( hsv . z - x ) ; rgbN . z = ( hsv . z - _rgb . b ) / ( hsv . z - x ) ; if ( _rgb . r == hsv . z ) { hsv . x = ( _rgb . g == x ) ? 5.0f + rgbN . z : 1.0f - rgbN . y ; } else if ( _rgb . g == hsv . z ) { hsv . x = ( _rgb . b == x ) ? 1.0f + rgbN . x : 3.0f - rgbN . z ; } else { hsv . x = ( _rgb . r == x ) ? 3.0f + rgbN . y : 5.0f - rgbN . x ; } hsv . x /= 6.0f ; return hsv ; } Color3 Color3 :: jetColorMap ( const float & val ) { debugAssertM ( val <= 1.0f && val >= 0.0f , " value ▁ should ▁ be ▁ in ▁ [ 0,1 ] " ) ; Color3 jet ; jet . r = G3D :: min ( 4.0f * val - 1.5f , - 4.0f * val + 4.5f ) ; jet . g = G3D :: min ( 4.0f * val - 0.5f , - 4.0f * val + 3.5f ) ; jet . b = G3D :: min ( 4.0f * val + 0.5f , - 4.0f * val + 2.5f ) ; jet . r = G3D :: clamp ( jet . r , 0.0f , 1.0f ) ; jet . g = G3D :: clamp ( jet . g , 0.0f , 1.0f ) ; jet . b = G3D :: clamp ( jet . b , 0.0f , 1.0f ) ; return jet ; } std :: string Color3 :: toString ( ) const { return G3D :: format ( " ( % g , ▁ % g , ▁ % g ) " , r , g , b ) ; } Color3 Color3 :: rainbowColorMap ( float hue ) { return fromHSV ( Vector3 ( hue , 1.0f , 1.0f ) ) ; } } ; </DOCUMENT>
<DOCUMENT_ID="erdincay/clamav-devel/tree/master/libclamav/c++/llvm/lib/Target/PowerPC/PPCSelectionDAGInfo.cpp"> # define DEBUG_TYPE " powerpc - selectiondag - info " # include " PPCTargetMachine . h " using namespace llvm ; PPCSelectionDAGInfo :: PPCSelectionDAGInfo ( const PPCTargetMachine & TM ) : TargetSelectionDAGInfo ( TM ) { } PPCSelectionDAGInfo :: ~ PPCSelectionDAGInfo ( ) { } </DOCUMENT>
<DOCUMENT_ID="lthall/Leonard_ardupilot/tree/master/libraries/AP_NavEKF/AP_NavEKF_core_common.cpp"> # include " AP _ NavEKF _ core _ common . h " NavEKF_core_common :: Matrix24 NavEKF_core_common :: KH ; NavEKF_core_common :: Matrix24 NavEKF_core_common :: KHP ; NavEKF_core_common :: Matrix24 NavEKF_core_common :: nextP ; NavEKF_core_common :: Vector28 NavEKF_core_common :: Kfusion ; void NavEKF_core_common :: fill_scratch_variables ( void ) { # if CONFIG_HAL_BOARD == HAL_BOARD_SITL fill_nanf ( & KH [ 0 ] [ 0 ] , sizeof ( KH ) / sizeof ( float ) ) ; fill_nanf ( & KHP [ 0 ] [ 0 ] , sizeof ( KHP ) / sizeof ( float ) ) ; fill_nanf ( & nextP [ 0 ] [ 0 ] , sizeof ( nextP ) / sizeof ( float ) ) ; fill_nanf ( & Kfusion [ 0 ] , sizeof ( Kfusion ) / sizeof ( float ) ) ; # endif } </DOCUMENT>
<DOCUMENT_ID="sofa-framework/sofa/tree/master/applications/plugins/SofaPython/PythonScriptController.cpp"> # include " PythonMacros . h " # include " PythonScriptController . h " # include < sofa / core / ObjectFactory . h > # include < sofa / helper / AdvancedTimer . h > using sofa :: helper :: AdvancedTimer ; using sofa :: core :: objectmodel :: Base ; using sofa :: simulation :: Node ; # include " Binding _ PythonScriptController . h " using sofa :: simulation :: PythonEnvironment ; # include " PythonScriptEvent . h " using sofa :: core :: objectmodel :: PythonScriptEvent ; # include < sofa / helper / system / FileMonitor . h > using sofa :: helper :: system :: FileMonitor ; using sofa :: helper :: system :: FileEventListener ; # include < sofa / core / objectmodel / IdleEvent . h > using sofa :: core :: objectmodel :: IdleEvent ; # include " PythonFactory . h " struct ActivableScopedAdvancedTimer { const char * message ; bool m_active ; Base * m_base ; ActivableScopedAdvancedTimer ( bool active , const char * message , Base * base ) : message ( message ) , m_active ( active ) , m_base ( base ) { if ( m_active ) AdvancedTimer :: stepBegin ( message , m_base ) ; } ~ ActivableScopedAdvancedTimer ( ) { if ( m_active ) AdvancedTimer :: stepEnd ( message , m_base ) ; } } ; namespace sofa { namespace component { namespace controller { class MyFileEventListener : public FileEventListener { PythonScriptController * m_controller ; public : MyFileEventListener ( PythonScriptController * psc ) { m_controller = psc ; } ~ MyFileEventListener ( ) override { } virtual void fileHasChanged ( const std :: string & filepath ) override { PythonEnvironment :: gil lock { __func__ } ; if ( ! m_controller -> scriptControllerInstance ( ) ) { m_controller -> doLoadScript ( ) ; } else { PythonEnvironment :: gil state { __func__ } ; std :: string file = filepath ; SP_CALL_FILEFUNC ( const_cast < char * > ( " onReimpAFile " ) , const_cast < char * > ( " s " ) , const_cast < char * > ( file . data ( ) ) ) ; m_controller -> refreshBinding ( ) ; } } } ; int PythonScriptControllerClass = core :: RegisterObject ( " A ▁ Sofa ▁ controller ▁ scripted ▁ in ▁ python " ) . add < PythonScriptController > ( ) ; PythonScriptController :: PythonScriptController ( ) : ScriptController ( ) , m_filename ( initData ( & m_filename , " filename " , " Python ▁ script ▁ filename " ) ) , m_classname ( initData ( & m_classname , " classname " , " Python ▁ class ▁ implemented ▁ in ▁ the ▁ script ▁ to ▁ instanciate ▁ for ▁ the ▁ controller " ) ) , m_variables ( initData ( & m_variables , " variables " , " Array ▁ of ▁ string ▁ variables ▁ ( equivalent ▁ to ▁ a ▁ c - like ▁ argv ) " ) ) , m_timingEnabled ( initData ( & m_timingEnabled , true , " timingEnabled " , " Set ▁ this ▁ attribute ▁ to ▁ true ▁ or ▁ false ▁ to ▁ activate / deactivate ▁ the ▁ gathering " " ▁ of ▁ timing ▁ statistics ▁ on ▁ the ▁ python ▁ execution ▁ time . ▁ Default ▁ value ▁ is ▁ set " " to ▁ true . " ) ) , m_doAutoReload ( initData ( & m_doAutoReload , false , " autoreload " , " Automatically ▁ reload ▁ the ▁ file ▁ when ▁ the ▁ source ▁ code ▁ is ▁ changed . ▁ " " Default ▁ value ▁ is ▁ set ▁ to ▁ false " ) ) , m_ScriptControllerClass ( nullptr ) , m_ScriptControllerInstance ( nullptr ) { m_filelistener = new MyFileEventListener ( this ) ; } PythonScriptController :: ~ PythonScriptController ( ) { if ( m_filelistener ) { FileMonitor :: removeListener ( m_filelistener ) ; delete m_filelistener ; } } void PythonScriptController :: setInstance ( PyObject * instance ) { PythonEnvironment :: gil lock ( __func__ ) ; if ( m_ScriptControllerInstance ) { Py_DECREF ( m_ScriptControllerInstance ) ; } m_ScriptControllerInstance = instance ; m_ScriptControllerClass = ( PyObject * ) instance -> ob_type ; Py_INCREF ( instance ) ; refreshBinding ( ) ; } void PythonScriptController :: refreshBinding ( ) { BIND_OBJECT_METHOD ( onLoaded ) BIND_OBJECT_METHOD ( createGraph ) BIND_OBJECT_METHOD ( initGraph ) BIND_OBJECT_METHOD ( bwdInitGraph ) BIND_OBJECT_METHOD ( onKeyPressed ) BIND_OBJECT_METHOD ( onKeyReleased ) BIND_OBJECT_METHOD ( onMouseMove ) BIND_OBJECT_METHOD ( onMouseButtonLeft ) BIND_OBJECT_METHOD ( onMouseButtonRight ) BIND_OBJECT_METHOD ( onMouseButtonMiddle ) BIND_OBJECT_METHOD ( onMouseWheel ) BIND_OBJECT_METHOD ( onBeginAnimationStep ) BIND_OBJECT_METHOD ( onEndAnimationStep ) BIND_OBJECT_METHOD ( storeResetState ) BIND_OBJECT_METHOD ( reset ) BIND_OBJECT_METHOD ( cleanup ) BIND_OBJECT_METHOD ( onGUIEvent ) BIND_OBJECT_METHOD ( onScriptEvent ) BIND_OBJECT_METHOD ( draw ) BIND_OBJECT_METHOD ( onIdle ) } bool PythonScriptController :: isDerivedFrom ( const std :: string & name , const std :: string & module ) { PythonEnvironment :: gil lock ( __func__ ) ; PyObject * moduleDict = PyModule_GetDict ( PyImport_AddModule ( module . c_str ( ) ) ) ; PyObject * controllerClass = PyDict_GetItemString ( moduleDict , name . c_str ( ) ) ; return 1 == PyObject_IsInstance ( m_ScriptControllerInstance , controllerClass ) ; } void PythonScriptController :: loadScript ( ) { PythonEnvironment :: gil lock ( __func__ ) ; if ( m_doAutoReload . getValue ( ) ) { FileMonitor :: addFile ( m_filename . getFullPath ( ) , m_filelistener ) ; } if ( m_filename . isSet ( ) && ! m_filename . getRelativePath ( ) . empty ( ) && ! PythonEnvironment :: runFile ( m_filename . getFullPath ( ) . c_str ( ) ) ) { msg_error ( ) << " ▁ load ▁ error ▁ ( file ▁ ' " << m_filename . getFullPath ( ) . c_str ( ) << " ' ▁ not ▁ parsable ) " ; return ; } PyObject * pDict = PyModule_GetDict ( PyImport_AddModule ( " _ _ main _ _ " ) ) ; m_ScriptControllerClass = PyDict_GetItemString ( pDict , m_classname . getValueString ( ) . c_str ( ) ) ; if ( ! m_ScriptControllerClass ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ not ▁ found ) . " ; return ; } if ( 1 != PyObject_IsSubclass ( m_ScriptControllerClass , ( PyObject * ) & SP_SOFAPYTYPEOBJECT ( PythonScriptController ) ) ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ does ▁ not ▁ inherit ▁ from ▁ ' Sofa . PythonScriptController ' ) . " ; return ; } m_ScriptControllerInstance = BuildPySPtr < Base > ( this , ( PyTypeObject * ) m_ScriptControllerClass ) ; if ( ! m_ScriptControllerInstance ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ instanciation ▁ error ) . " ; return ; } refreshBinding ( ) ; } void PythonScriptController :: doLoadScript ( ) { loadScript ( ) ; } void PythonScriptController :: script_onIdleEvent ( const IdleEvent * ) { FileMonitor :: updates ( 0 ) ; { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_onIdle ) ; } std :: cout . flush ( ) ; std :: cerr . flush ( ) ; } void PythonScriptController :: script_onLoaded ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onLoaded , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) } void PythonScriptController :: script_createGraph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_createGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) } void PythonScriptController :: script_initGraph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_initGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) } void PythonScriptController :: script_bwdInitGraph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_bwdInitGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) } bool PythonScriptController :: script_onKeyPressed ( const char c ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onKeyPressed " , this ) ; bool b = false ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEBOOLFUNC ( m_Func_onKeyPressed , " ( c ) " , c ) ; return b ; } bool PythonScriptController :: script_onKeyReleased ( const char c ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onKeyReleased " , this ) ; bool b = false ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEBOOLFUNC ( m_Func_onKeyReleased , " ( c ) " , c ) ; return b ; } void PythonScriptController :: script_onMouseMove ( const int posX , const int posY ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseMove " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onMouseMove , " ( ii ) " , posX , posY ) ; } void PythonScriptController :: script_onMouseButtonLeft ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonLeft " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonLeft , " ( iiO ) " , posX , posY , pyPressed ) } void PythonScriptController :: script_onMouseButtonRight ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonRight " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonRight , " ( iiO ) " , posX , posY , pyPressed ) } void PythonScriptController :: script_onMouseButtonMiddle ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonMiddle " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonMiddle , " ( iiO ) " , posX , posY , pyPressed ) } void PythonScriptController :: script_onMouseWheel ( const int posX , const int posY , const int delta ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseWheel " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onMouseWheel , " ( iii ) " , posX , posY , delta ) } void PythonScriptController :: script_onBeginAnimationStep ( const double dt ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onBeginAnimationStep " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onBeginAnimationStep , " ( d ) " , dt ) } void PythonScriptController :: script_onEndAnimationStep ( const double dt ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onEndAnimationStep " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onEndAnimationStep , " ( d ) " , dt ) } void PythonScriptController :: script_storeResetState ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_storeResetState ) } void PythonScriptController :: script_reset ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_reset ) } void PythonScriptController :: script_cleanup ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_cleanup ) } void PythonScriptController :: script_onGUIEvent ( const char * controlID , const char * valueName , const char * value ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onGUIEvent " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onGUIEvent , " ( sss ) " , controlID , valueName , value ) ; } void PythonScriptController :: script_onScriptEvent ( core :: objectmodel :: ScriptEvent * event ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onScriptEvent " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PythonScriptEvent * pyEvent = static_cast < PythonScriptEvent * > ( event ) ; SP_CALL_MODULEFUNC ( m_Func_onScriptEvent , " ( OsO ) " , sofa :: PythonFactory :: toPython ( pyEvent -> getSender ( ) . get ( ) ) , pyEvent -> getEventName ( ) . c_str ( ) , pyEvent -> getUserData ( ) ) ; } void PythonScriptController :: script_draw ( const core :: visual :: VisualParams * ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ draw " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_draw ) ; } void PythonScriptController :: handleEvent ( core :: objectmodel :: Event * event ) { if ( PythonScriptEvent :: checkEventType ( event ) ) { script_onScriptEvent ( static_cast < PythonScriptEvent * > ( event ) ) ; } else { ScriptController :: handleEvent ( event ) ; } } } } } </DOCUMENT>
<DOCUMENT_ID="thiphariel/navitia/tree/master/source/kraken/tests/data_manager_test.cpp"> # define BOOST_TEST_DYN_LINK # define BOOST_TEST_MODULE data_manager_test # include < boost / test / unit_test . hpp > # include < boost / optional . hpp > # include " kraken / data _ manager . h " # include < atomic > class Data { public : bool load ( const std :: string & , const boost :: optional < std :: string > & , const std :: vector < std :: string > & ) { return load_status ; } mutable std :: atomic < bool > is_connected_to_rabbitmq ; static bool load_status ; static bool destructor_called ; size_t data_identifier ; Data ( size_t data_identifier = 0 ) : data_identifier ( data_identifier ) { is_connected_to_rabbitmq = false ; } ~ Data ( ) { Data :: destructor_called = true ; } } ; bool Data :: load_status = true ; bool Data :: destructor_called = false ; struct fixture { fixture ( ) { Data :: load_status = true ; Data :: destructor_called = false ; } } ; BOOST_FIXTURE_TEST_SUITE ( s , fixture ) BOOST_AUTO_TEST_CASE ( get_data ) { DataManager < Data > data_manager ; auto data = data_manager . get_data ( ) ; BOOST_REQUIRE ( data ) ; BOOST_CHECK_EQUAL ( Data :: destructor_called , false ) ; } BOOST_AUTO_TEST_CASE ( load_success ) { DataManager < Data > data_manager ; auto first_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , data_manager . get_data ( ) ) ; BOOST_CHECK ( data_manager . load ( " " ) ) ; auto second_data = data_manager . get_data ( ) ; BOOST_CHECK_NE ( first_data , second_data ) ; BOOST_CHECK_EQUAL ( Data :: destructor_called , false ) ; } BOOST_AUTO_TEST_CASE ( load_fail ) { DataManager < Data > data_manager ; auto first_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , data_manager . get_data ( ) ) ; Data :: load_status = false ; BOOST_CHECK ( ! data_manager . load ( " " ) ) ; Data :: load_status = true ; auto second_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , second_data ) ; } BOOST_AUTO_TEST_CASE ( destructor_called ) { DataManager < Data > data_manager ; { auto first_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , data_manager . get_data ( ) ) ; BOOST_CHECK ( data_manager . load ( " " ) ) ; auto second_data = data_manager . get_data ( ) ; BOOST_CHECK_NE ( first_data , second_data ) ; BOOST_CHECK_EQUAL ( Data :: destructor_called , false ) ; first_data = boost :: shared_ptr < Data > ( ) ; } BOOST_CHECK_EQUAL ( Data :: destructor_called , true ) ; BOOST_CHECK ( data_manager . get_data ( ) ) ; } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
<DOCUMENT_ID="wayfinder/Wayfinder-S60-Navigator/tree/master/CPP/Shared/GuiProt/GeneralParamReceiver.cpp"> # include " arch . h " # include " GuiProt / GuiParameterEnums . h " # include " GuiProt / GuiProtEnums . h " # include " GuiProt / GuiProtMess . h " # include " GuiProt / GeneralParamReceiver . h " # include " GuiProt / GuiProtMessageHandler . h " # include " GenericSettingsData . h " namespace isab { GeneralParamReceiver :: ~ GeneralParamReceiver ( ) { m_guiProtHandler -> DeregisterReceiver ( this , isab :: GuiProtEnums :: SET_GENERAL_PARAMETER ) ; m_guiProtHandler -> DeregisterReceiver ( this , isab :: GuiProtEnums :: GET_GENERAL_PARAMETER ) ; } void GeneralParamReceiver :: init ( ) { m_guiProtHandler -> RegisterReceiver ( this , isab :: GuiProtEnums :: SET_GENERAL_PARAMETER ) ; m_guiProtHandler -> RegisterReceiver ( this , isab :: GuiProtEnums :: GET_GENERAL_PARAMETER ) ; } bool GeneralParamReceiver :: decodedParamNoValue ( uint32 paramId ) { return false ; } bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const float * data , int32 numEntries ) { return false ; } bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const uint8 * data , int32 numEntries ) { return false ; } bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const char * * data , int32 numEntries ) { return false ; } bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const int32 * data , int32 numEntries ) { switch ( paramId ) { case GuiProtEnums :: paramAutoReroute : { m_settingsData -> m_autoReroute = data [ 0 ] ; } break ; case GuiProtEnums :: paramBacklightStrategy : { m_settingsData -> m_backlightStrategy = data [ 0 ] ; } break ; case GuiProtEnums :: paramAutoTracking : { m_settingsData -> m_autoTracking = data [ 0 ] ; } break ; case GuiProtEnums :: paramDistanceMode : { m_settingsData -> m_distanceMode = data [ 0 ] ; } break ; case GuiProtEnums :: paramFavoriteShow : { m_settingsData -> m_favoriteShowInMap = data [ 0 ] ; } break ; case GuiProtEnums :: paramHighways : { m_settingsData -> m_routeHighways = data [ 0 ] ; } break ; case GuiProtEnums :: paramTollRoads : { m_settingsData -> m_routeTollRoads = data [ 0 ] ; } break ; case GuiProtEnums :: paramTimeDist : { m_settingsData -> m_routeCostType = data [ 0 ] ; } break ; case GuiProtEnums :: paramTrackingLevel : { m_settingsData -> m_trackingLevel = data [ 0 ] ; } break ; case GuiProtEnums :: paramTransportationType : { m_settingsData -> m_transportationType = data [ 0 ] ; } break ; case GuiProtEnums :: paramTurnSoundsLevel : { m_settingsData -> m_turnSoundsLevel = data [ 0 ] ; } break ; case GuiProtEnums :: userTrafficUpdatePeriod : { int32 val = data [ 0 ] ; m_settingsData -> m_trafficUpdatePeriod = 0xbfffffff & val ; m_settingsData -> m_trafficOldUpdatePeriod = 0xbfffffff & val ; m_settingsData -> m_trafficUpdate = 0x40000000 & val ? 0 : 1 ; m_settingsData -> m_trafficOldUpdate = 0x40000000 & val ? 0 : 1 ; } break ; case GuiProtEnums :: paramAutomaticRouteOnSMSDest : { m_settingsData -> m_autoRouteOnSMSDest = data [ 0 ] ; } break ; case GuiProtEnums :: paramKeepSMSDestInInbox : { m_settingsData -> m_keepSMSDestInInbox = data [ 0 ] ; } break ; case GuiProtEnums :: paramStoreSMSDestInMyDest : { m_settingsData -> m_storeSMSDestInFavorites = data [ 0 ] ; } break ; case GuiProtEnums :: paramPositionSymbol : { m_settingsData -> m_positionSymbol = data [ 0 ] ; } break ; case GuiProtEnums :: paramCheckForUpdates : { m_settingsData -> m_checkForUpdates = data [ 0 ] ; } break ; default : return false ; break ; } return true ; } bool GeneralParamReceiver :: GuiProtReceiveMessage ( class GuiProtMess * mess ) { GuiProtEnums :: MessageType type = mess -> getMessageType ( ) ; if ( type == GuiProtEnums :: GET_GENERAL_PARAMETER ) { isab :: GeneralParameterMess * gpm = ( isab :: GeneralParameterMess * ) mess ; return decodedParamNoValue ( gpm -> getParamId ( ) ) ; } else if ( type == GuiProtEnums :: SET_GENERAL_PARAMETER ) { isab :: GeneralParameterMess * gpm = ( isab :: GeneralParameterMess * ) mess ; switch ( gpm -> getParamType ( ) ) { case isab :: GuiProtEnums :: paramTypeInt32 : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getIntegerData ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramTypeFloat : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getFloatData ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramTypeBinary : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getBinaryData ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramTypeString : return decodedParamValue ( gpm -> getParamId ( ) , ( const char * * ) gpm -> getStringData ( ) , gpm -> getNumEntries ( ) ) ; break ; default : case isab :: GuiProtEnums :: paramTypeInvalid : return false ; break ; } } return false ; } } </DOCUMENT>
<DOCUMENT_ID="slitvinov/lammps-sph-multiphase/tree/master/src/ASPHERE/compute_temp_asphere.cpp"> # include " mpi . h " # include " string . h " # include " compute _ temp _ asphere . h " # include " math _ extra . h " # include " atom . h " # include " atom _ vec _ ellipsoid . h " # include " update . h " # include " force . h " # include " domain . h " # include " modify . h " # include " group . h " # include " memory . h " # include " error . h " using namespace LAMMPS_NS ; enum { ROTATE , ALL } ; # define INERTIA 0.2 ComputeTempAsphere :: ComputeTempAsphere ( LAMMPS * lmp , int narg , char * * arg ) : Compute ( lmp , narg , arg ) { if ( narg < 3 ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; scalar_flag = vector_flag = 1 ; size_vector = 6 ; extscalar = 0 ; extvector = 1 ; tempflag = 1 ; tempbias = 0 ; id_bias = NULL ; mode = ALL ; int iarg = 3 ; while ( iarg < narg ) { if ( strcmp ( arg [ iarg ] , " bias " ) == 0 ) { if ( iarg + 2 > narg ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; tempbias = 1 ; int n = strlen ( arg [ iarg + 1 ] ) + 1 ; id_bias = new char [ n ] ; strcpy ( id_bias , arg [ iarg + 1 ] ) ; iarg += 2 ; } else if ( strcmp ( arg [ iarg ] , " dof " ) == 0 ) { if ( iarg + 2 > narg ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; if ( strcmp ( arg [ iarg + 1 ] , " rotate " ) == 0 ) mode = ROTATE ; else if ( strcmp ( arg [ iarg + 1 ] , " all " ) == 0 ) mode = ALL ; else error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; iarg += 2 ; } else error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; } vector = new double [ 6 ] ; } ComputeTempAsphere :: ~ ComputeTempAsphere ( ) { delete [ ] id_bias ; delete [ ] vector ; } void ComputeTempAsphere :: init ( ) { avec = ( AtomVecEllipsoid * ) atom -> style_match ( " ellipsoid " ) ; if ( ! avec ) error -> all ( FLERR , " Compute ▁ temp / asphere ▁ requires ▁ atom ▁ style ▁ ellipsoid " ) ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) if ( ellipsoid [ i ] < 0 ) error -> one ( FLERR , " Compute ▁ temp / asphere ▁ requires ▁ extended ▁ particles " ) ; if ( tempbias ) { int i = modify -> find_compute ( id_bias ) ; if ( i < 0 ) error -> all ( FLERR , " Could ▁ not ▁ find ▁ compute ▁ ID ▁ for ▁ temperature ▁ bias " ) ; tbias = modify -> compute [ i ] ; if ( tbias -> tempflag == 0 ) error -> all ( FLERR , " Bias ▁ compute ▁ does ▁ not ▁ calculate ▁ temperature " ) ; if ( tbias -> tempbias == 0 ) error -> all ( FLERR , " Bias ▁ compute ▁ does ▁ not ▁ calculate ▁ a ▁ velocity ▁ bias " ) ; if ( tbias -> igroup != igroup ) error -> all ( FLERR , " Bias ▁ compute ▁ group ▁ does ▁ not ▁ match ▁ compute ▁ group " ) ; tbias -> init ( ) ; tbias -> setup ( ) ; if ( strcmp ( tbias -> style , " temp / region " ) == 0 ) tempbias = 2 ; else tempbias = 1 ; } } void ComputeTempAsphere :: setup ( ) { fix_dof = - 1 ; dof_compute ( ) ; } void ComputeTempAsphere :: dof_compute ( ) { if ( fix_dof ) adjust_dof_fix ( ) ; double natoms = group -> count ( igroup ) ; int nper ; if ( domain -> dimension == 3 ) { if ( mode == ALL ) nper = 6 ; else nper = 3 ; } else { if ( mode == ALL ) nper = 3 ; else nper = 1 ; } dof = nper * natoms ; if ( tempbias == 1 ) { if ( mode == ALL ) dof -= tbias -> dof_remove ( - 1 ) * natoms ; } else if ( tempbias == 2 ) { int * mask = atom -> mask ; int nlocal = atom -> nlocal ; tbias -> dof_remove_pre ( ) ; int count = 0 ; for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) if ( tbias -> dof_remove ( i ) ) count ++ ; int count_all ; MPI_Allreduce ( & count , & count_all , 1 , MPI_INT , MPI_SUM , world ) ; dof -= nper * count_all ; } dof -= extra_dof + fix_dof ; if ( dof > 0 ) tfactor = force -> mvv2e / ( dof * force -> boltz ) ; else tfactor = 0.0 ; } double ComputeTempAsphere :: compute_scalar ( ) { invoked_scalar = update -> ntimestep ; if ( tempbias ) { if ( tbias -> invoked_scalar != update -> ntimestep ) tbias -> compute_scalar ( ) ; tbias -> remove_bias_all ( ) ; } AtomVecEllipsoid :: Bonus * bonus = avec -> bonus ; double * * v = atom -> v ; double * * angmom = atom -> angmom ; double * rmass = atom -> rmass ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; double * shape , * quat ; double wbody [ 3 ] , inertia [ 3 ] ; double rot [ 3 ] [ 3 ] ; double t = 0.0 ; if ( mode == ALL ) { for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { t += ( v [ i ] [ 0 ] * v [ i ] [ 0 ] + v [ i ] [ 1 ] * v [ i ] [ 1 ] + v [ i ] [ 2 ] * v [ i ] [ 2 ] ) * rmass [ i ] ; shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * rmass [ i ] * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] + inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] + inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; } } else { for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * rmass [ i ] * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] + inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] + inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; } } if ( tempbias ) tbias -> restore_bias_all ( ) ; MPI_Allreduce ( & t , & scalar , 1 , MPI_DOUBLE , MPI_SUM , world ) ; if ( dynamic || tempbias == 2 ) dof_compute ( ) ; scalar *= tfactor ; return scalar ; } void ComputeTempAsphere :: compute_vector ( ) { int i ; invoked_vector = update -> ntimestep ; if ( tempbias ) { if ( tbias -> invoked_vector != update -> ntimestep ) tbias -> compute_vector ( ) ; tbias -> remove_bias_all ( ) ; } AtomVecEllipsoid :: Bonus * bonus = avec -> bonus ; double * * v = atom -> v ; double * * angmom = atom -> angmom ; double * rmass = atom -> rmass ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; double * shape , * quat ; double wbody [ 3 ] , inertia [ 3 ] , t [ 6 ] ; double rot [ 3 ] [ 3 ] ; double massone ; for ( i = 0 ; i < 6 ; i ++ ) t [ i ] = 0.0 ; if ( mode == ALL ) { for ( i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { massone = rmass [ i ] ; t [ 0 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 0 ] ; t [ 1 ] += massone * v [ i ] [ 1 ] * v [ i ] [ 1 ] ; t [ 2 ] += massone * v [ i ] [ 2 ] * v [ i ] [ 2 ] ; t [ 3 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 1 ] ; t [ 4 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 2 ] ; t [ 5 ] += massone * v [ i ] [ 1 ] * v [ i ] [ 2 ] ; shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * massone * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t [ 0 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] ; t [ 1 ] += inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] ; t [ 2 ] += inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; t [ 3 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 1 ] ; t [ 4 ] += inertia [ 1 ] * wbody [ 0 ] * wbody [ 2 ] ; t [ 5 ] += inertia [ 2 ] * wbody [ 1 ] * wbody [ 2 ] ; } } else { for ( i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; massone = rmass [ i ] ; inertia [ 0 ] = INERTIA * massone * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t [ 0 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] ; t [ 1 ] += inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] ; t [ 2 ] += inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; t [ 3 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 1 ] ; t [ 4 ] += inertia [ 1 ] * wbody [ 0 ] * wbody [ 2 ] ; t [ 5 ] += inertia [ 2 ] * wbody [ 1 ] * wbody [ 2 ] ; } } if ( tempbias ) tbias -> restore_bias_all ( ) ; MPI_Allreduce ( t , vector , 6 , MPI_DOUBLE , MPI_SUM , world ) ; for ( i = 0 ; i < 6 ; i ++ ) vector [ i ] *= force -> mvv2e ; } void ComputeTempAsphere :: remove_bias ( int i , double * v ) { if ( tbias ) tbias -> remove_bias ( i , v ) ; } void ComputeTempAsphere :: restore_bias ( int i , double * v ) { if ( tbias ) tbias -> restore_bias ( i , v ) ; } </DOCUMENT>
<DOCUMENT_ID="SingularityCore/Singularity/tree/master/dep/acelite/ace/Log_Msg_IPC.cpp"> # include " ace / Log _ Msg _ IPC . h " # include " ace / Log _ Record . h " # include " ace / CDR _ Stream . h " # include " ace / Truncate . h " ACE_BEGIN_VERSIONED_NAMESPACE_DECL ACE_Log_Msg_IPC :: ACE_Log_Msg_IPC ( void ) { } ACE_Log_Msg_IPC :: ~ ACE_Log_Msg_IPC ( void ) { ( void ) this -> close ( ) ; } int ACE_Log_Msg_IPC :: open ( const ACE_TCHAR * logger_key ) { ACE_LOG_MSG_IPC_CONNECTOR con ; return con . connect ( this -> message_queue_ , ACE_LOG_MSG_IPC_ADDR ( logger_key ) ) ; } int ACE_Log_Msg_IPC :: reset ( void ) { if ( this -> message_queue_ . get_handle ( ) != ACE_INVALID_HANDLE ) { return this -> close ( ) ; } return 0 ; } int ACE_Log_Msg_IPC :: close ( void ) { return this -> message_queue_ . close ( ) ; } ssize_t ACE_Log_Msg_IPC :: log ( ACE_Log_Record & log_record ) { size_t const max_payload_size = 4 + 4 + 12 + 4 + 4 # if defined ( ACE_USES_WCHAR ) + ( log_record . msg_data_len ( ) * ACE_OutputCDR :: wchar_maxbytes ( ) ) # else + log_record . msg_data_len ( ) # endif + ACE_CDR :: MAX_ALIGNMENT ; ACE_OutputCDR payload ( max_payload_size ) ; if ( ! ( payload << log_record ) ) return - 1 ; ACE_CDR :: ULong const length = ACE_Utils :: truncate_cast < ACE_CDR :: ULong > ( payload . total_length ( ) ) ; ACE_OutputCDR header ( ACE_CDR :: MAX_ALIGNMENT + 8 ) ; if ( ! ( header << ACE_OutputCDR :: from_boolean ( ACE_CDR_BYTE_ORDER ) ) ) return - 1 ; if ( ! ( header << ACE_CDR :: ULong ( length ) ) ) return - 1 ; iovec iov [ 2 ] ; iov [ 0 ] . iov_base = header . begin ( ) -> rd_ptr ( ) ; iov [ 0 ] . iov_len = 8 ; iov [ 1 ] . iov_base = payload . begin ( ) -> rd_ptr ( ) ; iov [ 1 ] . iov_len = length ; # if ( ACE_HAS_STREAM_LOG_MSG_IPC == 1 ) ACE_Str_Buf header_msg ( static_cast < void * > ( header . begin ( ) -> rd_ptr ( ) ) , static_cast < int > ( 8 ) ) ; ACE_Str_Buf payload_msg ( static_cast < void * > ( payload . begin ( ) -> rd_ptr ( ) ) , static_cast < int > ( length ) ) ; return this -> message_queue_ . send ( & header_msg , & payload_msg , static_cast < int > ( log_record . priority ( ) ) , MSG_BAND ) ; # else return this -> message_queue_ . sendv_n ( iov , 2 ) ; # endif } ACE_END_VERSIONED_NAMESPACE_DECL </DOCUMENT>
<DOCUMENT_ID="biojppm/c4stl/tree/master/bm/list/push_back/flat_fwd_list__paged__NumBytes_64___int32_t.cpp"> # include " benchmark / benchmark . h " # include " c4 / log . hpp " # include " c4 / allocator . hpp " # include " . . / list _ types . hpp " namespace bm = benchmark ; namespace c4 { template < class List > void BM_ListPushBack ( bm :: State & st ) { List li ; using T = typename List :: value_type ; T v { } ; size_t count = 0 ; while ( st . KeepRunning ( ) ) { for ( int i = 0 , e = st . range ( 0 ) ; i < e ; ++ i ) { if ( li . size ( ) == li . max_size ( ) ) li . clear ( ) ; li . push_back ( v ) ; ++ count ; } li . clear ( ) ; } st . SetComplexityN ( st . range ( 0 ) ) ; st . SetItemsProcessed ( count ) ; st . SetBytesProcessed ( count * sizeof ( T ) ) ; } BENCHMARK_TEMPLATE ( BM_ListPushBack , flat_fwd_list__paged < NumBytes < 64 > C4_COMMA int32_t > ) -> RangeMultiplier ( 2 ) -> Range ( 4 , 1 << 19 ) -> Complexity ( ) ; } BENCHMARK_MAIN ( ) </DOCUMENT>
<DOCUMENT_ID="aybassiouny/wincaffe-cmake/tree/master/src/caffe/test/test_power_layer.cpp"> # include < algorithm > # include < vector > # include " cuda _ runtime . h " # include " gtest / gtest . h " # include " caffe / blob . hpp " # include " caffe / common . hpp " # include " caffe / filler . hpp " # include " caffe / vision _ layers . hpp " # include " caffe / test / test _ gradient _ check _ util . hpp " # include " caffe / test / test _ caffe _ main . hpp " using std :: isnan ; namespace caffe { extern cudaDeviceProp CAFFE_TEST_CUDA_PROP ; template < typename Dtype > class PowerLayerTest : public :: testing :: Test { protected : PowerLayerTest ( ) : blob_bottom_ ( new Blob < Dtype > ( 2 , 3 , 4 , 5 ) ) , blob_top_ ( new Blob < Dtype > ( ) ) { Caffe :: set_random_seed ( 1701 ) ; FillerParameter filler_param ; GaussianFiller < Dtype > filler ( filler_param ) ; filler . Fill ( this -> blob_bottom_ ) ; blob_bottom_vec_ . push_back ( blob_bottom_ ) ; blob_top_vec_ . push_back ( blob_top_ ) ; } virtual ~ PowerLayerTest ( ) { delete blob_bottom_ ; delete blob_top_ ; } void TestForward ( Dtype power , Dtype scale , Dtype shift ) { LayerParameter layer_param ; layer_param . mutable_power_param ( ) -> set_power ( power ) ; layer_param . mutable_power_param ( ) -> set_scale ( scale ) ; layer_param . mutable_power_param ( ) -> set_shift ( shift ) ; PowerLayer < Dtype > layer ( layer_param ) ; layer . SetUp ( this -> blob_bottom_vec_ , & ( this -> blob_top_vec_ ) ) ; layer . Forward ( this -> blob_bottom_vec_ , & ( this -> blob_top_vec_ ) ) ; const Dtype * bottom_data = this -> blob_bottom_ -> cpu_data ( ) ; const Dtype * top_data = this -> blob_top_ -> cpu_data ( ) ; const Dtype min_precision = 1e - 5 ; for ( int i = 0 ; i < this -> blob_bottom_ -> count ( ) ; ++ i ) { Dtype expected_value = pow ( shift + scale * bottom_data [ i ] , power ) ; if ( power == Dtype ( 0 ) || power == Dtype ( 1 ) || power == Dtype ( 2 ) ) { EXPECT_FALSE ( isnan ( top_data [ i ] ) ) ; } if ( isnan ( expected_value ) ) { EXPECT_TRUE ( isnan ( top_data [ i ] ) ) ; } else { Dtype precision = max ( Dtype ( abs ( expected_value * 0.0001 ) ) , min_precision ) ; EXPECT_NEAR ( expected_value , top_data [ i ] , precision ) ; } } } void TestBackward ( Dtype power , Dtype scale , Dtype shift ) { LayerParameter layer_param ; layer_param . mutable_power_param ( ) -> set_power ( power ) ; layer_param . mutable_power_param ( ) -> set_scale ( scale ) ; layer_param . mutable_power_param ( ) -> set_shift ( shift ) ; PowerLayer < Dtype > layer ( layer_param ) ; if ( power != Dtype ( 0 ) && power != Dtype ( 1 ) && power != Dtype ( 2 ) ) { Dtype * bottom_data = this -> blob_bottom_ -> mutable_cpu_data ( ) ; Dtype min_value = - shift / scale ; for ( int i = 0 ; i < this -> blob_bottom_ -> count ( ) ; ++ i ) { if ( bottom_data [ i ] < min_value ) { bottom_data [ i ] = min_value + ( min_value - bottom_data [ i ] ) ; } } } GradientChecker < Dtype > checker ( 1e - 2 , 1e - 2 , 1701 , 0. , 0.01 ) ; checker . CheckGradientEltwise ( & layer , & ( this -> blob_bottom_vec_ ) , & ( this -> blob_top_vec_ ) ) ; } Blob < Dtype > * const blob_bottom_ ; Blob < Dtype > * const blob_top_ ; vector < Blob < Dtype > * > blob_bottom_vec_ ; vector < Blob < Dtype > * > blob_top_vec_ ; } ; typedef :: testing :: Types < float , double > Dtypes ; TYPED_TEST_CASE ( PowerLayerTest , Dtypes ) ; TYPED_TEST ( PowerLayerTest , TestPowerCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGradientShiftZeroCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = 0.0 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerZeroCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerZeroGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerOneCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerOneGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.34 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoScaleHalfGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.5 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGradientShiftZeroGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = 0.0 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerZeroGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerZeroGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerOneGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerOneGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.34 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoScaleHalfGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.5 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } } </DOCUMENT>
<DOCUMENT_ID="KDE/koffice/tree/master/kcells/dialogs/StyleManagerDialog.cpp"> # include " StyleManagerDialog . h " # include < QMap > # include < QTreeWidget > # include < QVBoxLayout > # include < kcombobox . h > # include < kdebug . h > # include < klocale . h > # include " KCCell . h " # include " LayoutDialog . h " # include " ui / Selection . h " # include " KCSheet . h " # include " KCStyle . h " # include " KCStyleManager . h " # include " commands / KCStyleCommand . h " StyleManagerDialog :: StyleManagerDialog ( QWidget * parent , Selection * selection , KCStyleManager * manager ) : KDialog ( parent ) , m_selection ( selection ) , m_styleManager ( manager ) { setButtons ( Apply | User1 | User2 | User3 | Close ) ; setButtonText ( User3 , i18n ( " & New . . . " ) ) ; setButtonText ( User2 , i18n ( " & Modify . . . " ) ) ; setButtonText ( User1 , i18n ( " & Delete . . . " ) ) ; setButtonsOrientation ( Qt :: Vertical ) ; setCaption ( i18n ( " Style ▁ Manager " ) ) ; QWidget * widget = new QWidget ( this ) ; setMainWidget ( widget ) ; QVBoxLayout * layout = new QVBoxLayout ( widget ) ; m_styleList = new QTreeWidget ( this ) ; m_styleList -> setHeaderLabel ( i18n ( " Style " ) ) ; layout -> addWidget ( m_styleList ) ; m_displayBox = new KComboBox ( false , this ) ; m_displayBox -> insertItem ( 0 , i18n ( " All ▁ Styles " ) ) ; m_displayBox -> insertItem ( 1 , i18n ( " Custom ▁ Styles " ) ) ; m_displayBox -> insertItem ( 2 , i18n ( " Hierarchical " ) ) ; layout -> addWidget ( m_displayBox ) ; slotDisplayMode ( 0 ) ; enableButton ( KDialog :: User3 , true ) ; enableButton ( KDialog :: User2 , true ) ; enableButton ( KDialog :: User1 , false ) ; connect ( m_displayBox , SIGNAL ( activated ( int ) ) , this , SLOT ( slotDisplayMode ( int ) ) ) ; connect ( this , SIGNAL ( applyClicked ( ) ) , this , SLOT ( slotOk ( ) ) ) ; connect ( this , SIGNAL ( user3Clicked ( ) ) , this , SLOT ( slotNew ( ) ) ) ; connect ( this , SIGNAL ( user2Clicked ( ) ) , this , SLOT ( slotEdit ( ) ) ) ; connect ( this , SIGNAL ( user1Clicked ( ) ) , this , SLOT ( slotRemove ( ) ) ) ; connect ( m_styleList , SIGNAL ( itemDoubleClicked ( QTreeWidgetItem * , int ) ) , this , SLOT ( slotEdit ( ) ) ) ; connect ( m_styleList , SIGNAL ( currentItemChanged ( QTreeWidgetItem * , QTreeWidgetItem * ) ) , this , SLOT ( selectionChanged ( QTreeWidgetItem * ) ) ) ; } StyleManagerDialog :: ~ StyleManagerDialog ( ) { } void StyleManagerDialog :: fillComboBox ( ) { typedef QMap < KCCustomStyle * , QTreeWidgetItem * > KCMap ; KCMap entries ; entries . clear ( ) ; entries [ m_styleManager -> defaultStyle ( ) ] = new QTreeWidgetItem ( m_styleList , QStringList ( i18n ( " Default " ) ) ) ; CustomStyles :: const_iterator iter = m_styleManager -> m_styles . constBegin ( ) ; CustomStyles :: const_iterator end = m_styleManager -> m_styles . constEnd ( ) ; while ( entries . count ( ) != m_styleManager -> m_styles . count ( ) + 1 ) { if ( entries . find ( iter . value ( ) ) == entries . end ( ) ) { if ( iter . value ( ) -> parentName ( ) . isNull ( ) ) entries [ iter . value ( ) ] = new QTreeWidgetItem ( entries [ m_styleManager -> defaultStyle ( ) ] , QStringList ( iter . value ( ) -> name ( ) ) ) ; else { KCCustomStyle * parentStyle = m_styleManager -> style ( iter . value ( ) -> parentName ( ) ) ; if ( parentStyle ) { KCMap :: const_iterator i = entries . constFind ( parentStyle ) ; if ( i != entries . constEnd ( ) ) entries [ iter . value ( ) ] = new QTreeWidgetItem ( i . value ( ) , QStringList ( iter . value ( ) -> name ( ) ) ) ; } } } ++ iter ; if ( iter == end ) iter = m_styleManager -> m_styles . constBegin ( ) ; } entries . clear ( ) ; } void StyleManagerDialog :: slotDisplayMode ( int mode ) { m_styleList -> clear ( ) ; if ( mode != 2 ) m_styleList -> setRootIsDecorated ( false ) ; else { m_styleList -> setRootIsDecorated ( true ) ; fillComboBox ( ) ; return ; } if ( mode != 1 ) new QTreeWidgetItem ( m_styleList , QStringList ( i18n ( " Default " ) ) ) ; CustomStyles :: iterator iter = m_styleManager -> m_styles . begin ( ) ; CustomStyles :: iterator end = m_styleManager -> m_styles . end ( ) ; while ( iter != end ) { KCCustomStyle * styleData = iter . value ( ) ; if ( ! styleData || styleData -> name ( ) . isEmpty ( ) ) { ++ iter ; continue ; } if ( mode == 1 ) { if ( styleData -> type ( ) == KCStyle :: CUSTOM ) new QTreeWidgetItem ( m_styleList , QStringList ( styleData -> name ( ) ) ) ; } else new QTreeWidgetItem ( m_styleList , QStringList ( styleData -> name ( ) ) ) ; ++ iter ; } } void StyleManagerDialog :: slotOk ( ) { kDebug ( ) ; QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) { accept ( ) ; return ; } QString name ( item -> text ( 0 ) ) ; if ( name == i18n ( " Default " ) ) { KCStyleCommand * command = new KCStyleCommand ( ) ; command -> setSheet ( m_selection -> activeSheet ( ) ) ; command -> setDefault ( ) ; command -> add ( * m_selection ) ; command -> execute ( m_selection -> canvas ( ) ) ; } else { KCStyleCommand * command = new KCStyleCommand ( ) ; command -> setSheet ( m_selection -> activeSheet ( ) ) ; command -> setParentName ( name ) ; command -> add ( * m_selection ) ; command -> execute ( m_selection -> canvas ( ) ) ; } accept ( ) ; } void StyleManagerDialog :: slotNew ( ) { KCCustomStyle * parentStyle = 0 ; QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( item ) { const QString name = item -> text ( 0 ) ; if ( name == i18n ( " Default " ) ) parentStyle = m_styleManager -> defaultStyle ( ) ; else parentStyle = m_styleManager -> style ( name ) ; } else parentStyle = m_styleManager -> defaultStyle ( ) ; int i = 1 ; QString newName ( i18n ( " style % 1" , m_styleManager -> count ( ) + i ) ) ; while ( m_styleManager -> style ( newName ) != 0 ) { ++ i ; newName = i18n ( " style % 1" , m_styleManager -> count ( ) + i ) ; } KCCustomStyle * style = new KCCustomStyle ( newName , parentStyle ) ; style -> setType ( KCStyle :: TENTATIVE ) ; QPointer < CellFormatDialog > dialog = new CellFormatDialog ( this , m_selection , style , m_styleManager ) ; dialog -> exec ( ) ; delete dialog ; if ( style -> type ( ) == KCStyle :: TENTATIVE ) { delete style ; return ; } m_styleManager -> m_styles [ style -> name ( ) ] = style ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; } void StyleManagerDialog :: slotEdit ( ) { QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) return ; KCCustomStyle * style = 0 ; QString name ( item -> text ( 0 ) ) ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) return ; QPointer < CellFormatDialog > dialog = new CellFormatDialog ( this , m_selection , style , m_styleManager ) ; dialog -> exec ( ) ; if ( dialog -> result ( ) == Accepted ) m_selection -> emitRefreshSheetViews ( ) ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; delete dialog ; } void StyleManagerDialog :: slotRemove ( ) { QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) return ; const QString name = item -> text ( 0 ) ; KCCustomStyle * style = 0 ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) return ; if ( style -> type ( ) != KCStyle :: CUSTOM ) return ; m_styleManager -> takeStyle ( style ) ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; } void StyleManagerDialog :: selectionChanged ( QTreeWidgetItem * item ) { if ( ! item ) return ; const QString name = item -> text ( 0 ) ; KCCustomStyle * style = 0 ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) { enableButton ( KDialog :: User1 , false ) ; return ; } if ( style -> type ( ) == KCStyle :: BUILTIN ) enableButton ( KDialog :: User1 , false ) ; else enableButton ( KDialog :: User1 , true ) ; } # include " StyleManagerDialog . moc " </DOCUMENT>
<DOCUMENT_ID="nawawi/wkhtmltopdf/tree/master/webkit/Source/WebCore/bindings/js/JSDocumentCustom.cpp"> # include " config . h " # include " JSDocument . h " # include " ExceptionCode . h " # include " Frame . h " # include " FrameLoader . h " # include " HTMLDocument . h " # include " JSCanvasRenderingContext2D . h " # if ENABLE ( WEBGL ) # include " JSWebGLRenderingContext . h " # endif # include " JSDOMWindowCustom . h " # include " JSHTMLDocument . h " # include " JSLocation . h " # include " JSTouch . h " # include " JSTouchList . h " # include " Location . h " # include " ScriptController . h " # include " TouchList . h " # if ENABLE ( SVG ) # include " JSSVGDocument . h " # include " SVGDocument . h " # endif # include < wtf / GetPtr . h > using namespace JSC ; namespace WebCore { JSValue JSDocument :: location ( ExecState * exec ) const { Frame * frame = static_cast < Document * > ( impl ( ) ) -> frame ( ) ; if ( ! frame ) return jsNull ( ) ; Location * location = frame -> document ( ) -> domWindow ( ) -> location ( ) ; if ( JSDOMWrapper * wrapper = getCachedWrapper ( currentWorld ( exec ) , location ) ) return wrapper ; JSLocation * jsLocation = JSLocation :: create ( getDOMStructure < JSLocation > ( exec , globalObject ( ) ) , globalObject ( ) , location ) ; cacheWrapper ( currentWorld ( exec ) , location , jsLocation ) ; return jsLocation ; } void JSDocument :: setLocation ( ExecState * exec , JSValue value ) { Frame * frame = static_cast < Document * > ( impl ( ) ) -> frame ( ) ; if ( ! frame ) return ; String locationString = value . toString ( exec ) -> value ( exec ) ; if ( exec -> hadException ( ) ) return ; if ( Location * location = frame -> document ( ) -> domWindow ( ) -> location ( ) ) location -> setHref ( locationString , activeDOMWindow ( exec ) , firstDOMWindow ( exec ) ) ; } JSValue toJS ( ExecState * exec , JSDOMGlobalObject * globalObject , Document * document ) { if ( ! document ) return jsNull ( ) ; JSDOMWrapper * wrapper = getCachedWrapper ( currentWorld ( exec ) , document ) ; if ( wrapper ) return wrapper ; if ( DOMWindow * domWindow = document -> domWindow ( ) ) { globalObject = toJSDOMWindow ( toJS ( exec , domWindow ) ) ; wrapper = getCachedWrapper ( currentWorld ( exec ) , document ) ; if ( wrapper ) return wrapper ; } if ( document -> isHTMLDocument ( ) ) wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , HTMLDocument , document ) ; # if ENABLE ( SVG ) else if ( document -> isSVGDocument ( ) ) wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , SVGDocument , document ) ; # endif else wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , Document , document ) ; if ( ! document -> frame ( ) ) { size_t nodeCount = 0 ; for ( Node * n = document ; n ; n = n -> traverseNextNode ( ) ) nodeCount ++ ; exec -> heap ( ) -> reportExtraMemoryCost ( nodeCount * sizeof ( Node ) ) ; } return wrapper ; } # if ENABLE ( TOUCH_EVENTS ) JSValue JSDocument :: createTouchList ( ExecState * exec ) { RefPtr < TouchList > touchList = TouchList :: create ( ) ; for ( size_t i = 0 ; i < exec -> argumentCount ( ) ; i ++ ) touchList -> append ( toTouch ( exec -> argument ( i ) ) ) ; return toJS ( exec , globalObject ( ) , touchList . release ( ) ) ; } # endif } </DOCUMENT>
<DOCUMENT_ID="makhdumi/robomongo/tree/master/src/third-party/mongodb/src/mongo/db/pipeline/accumulator.cpp"> # include " pch . h " # include " db / pipeline / accumulator . h " # include " db / jsobj . h " # include " util / mongoutils / str . h " namespace mongo { using namespace mongoutils ; void Accumulator :: addOperand ( const intrusive_ptr < Expression > & pExpression ) { uassert ( 15943 , str :: stream ( ) << " group ▁ accumulator ▁ " << getOpName ( ) << " ▁ only ▁ accepts ▁ one ▁ operand " , vpOperand . size ( ) < 1 ) ; ExpressionNary :: addOperand ( pExpression ) ; } Accumulator :: Accumulator ( ) : ExpressionNary ( ) { } void Accumulator :: opToBson ( BSONObjBuilder * pBuilder , StringData opName , StringData fieldName , bool requireExpression ) const { verify ( vpOperand . size ( ) == 1 ) ; BSONObjBuilder builder ; vpOperand [ 0 ] -> addToBsonObj ( & builder , opName , requireExpression ) ; pBuilder -> append ( fieldName , builder . done ( ) ) ; } void Accumulator :: addToBsonObj ( BSONObjBuilder * pBuilder , StringData fieldName , bool requireExpression ) const { opToBson ( pBuilder , getOpName ( ) , fieldName , requireExpression ) ; } void Accumulator :: addToBsonArray ( BSONArrayBuilder * pBuilder ) const { verify ( false ) ; } void agg_framework_reservedErrors ( ) { uassert ( 16030 , " reserved ▁ error " , false ) ; uassert ( 16031 , " reserved ▁ error " , false ) ; uassert ( 16032 , " reserved ▁ error " , false ) ; uassert ( 16033 , " reserved ▁ error " , false ) ; uassert ( 16036 , " reserved ▁ error " , false ) ; uassert ( 16037 , " reserved ▁ error " , false ) ; uassert ( 16038 , " reserved ▁ error " , false ) ; uassert ( 16039 , " reserved ▁ error " , false ) ; uassert ( 16040 , " reserved ▁ error " , false ) ; uassert ( 16041 , " reserved ▁ error " , false ) ; uassert ( 16042 , " reserved ▁ error " , false ) ; uassert ( 16043 , " reserved ▁ error " , false ) ; uassert ( 16044 , " reserved ▁ error " , false ) ; uassert ( 16045 , " reserved ▁ error " , false ) ; uassert ( 16046 , " reserved ▁ error " , false ) ; uassert ( 16047 , " reserved ▁ error " , false ) ; uassert ( 16048 , " reserved ▁ error " , false ) ; uassert ( 16049 , " reserved ▁ error " , false ) ; } } </DOCUMENT>
<DOCUMENT_ID="doorxp/ccjson/tree/master/cocos2d/cocos/audio/android/AudioResampler.cpp"> # define LOG_TAG " AudioResampler " # include < stdint . h > # include < stdlib . h > # include < sys / types . h > # include < pthread . h > # include < new > # include " audio / android / cutils / log . h " # include " audio / android / utils / Utils . h " # include " audio / android / audio _ utils / include / audio _ utils / primitives . h " # include " audio / android / AudioResampler . h " # include " audio / android / AudioResamplerCubic . h " namespace cocos2d { namespace experimental { class AudioResamplerOrder1 : public AudioResampler { public : AudioResamplerOrder1 ( int inChannelCount , int32_t sampleRate ) : AudioResampler ( inChannelCount , sampleRate , LOW_QUALITY ) , mX0L ( 0 ) , mX0R ( 0 ) { } virtual size_t resample ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) ; private : static const int kNumInterpBits = 15 ; static const int kPreInterpShift = kNumPhaseBits - kNumInterpBits ; void init ( ) { } size_t resampleMono16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) ; size_t resampleStereo16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) ; # ifdef ASM_ARM_RESAMP1 void AsmMono16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) ; void AsmStereo16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) ; # endif static inline int32_t Interp ( int32_t x0 , int32_t x1 , uint32_t f ) { return x0 + ( ( ( x1 - x0 ) * ( int32_t ) ( f >> kPreInterpShift ) ) >> kNumInterpBits ) ; } static inline void Advance ( size_t * index , uint32_t * frac , uint32_t inc ) { * frac += inc ; * index += ( size_t ) ( * frac >> kNumPhaseBits ) ; * frac &= kPhaseMask ; } int mX0L ; int mX0R ; } ; const double AudioResampler :: kPhaseMultiplier = 1L << AudioResampler :: kNumPhaseBits ; bool AudioResampler :: qualityIsSupported ( src_quality quality ) { switch ( quality ) { case DEFAULT_QUALITY : case LOW_QUALITY : case MED_QUALITY : case HIGH_QUALITY : case VERY_HIGH_QUALITY : return true ; default : return false ; } } static pthread_once_t once_control = PTHREAD_ONCE_INIT ; static AudioResampler :: src_quality defaultQuality = AudioResampler :: DEFAULT_QUALITY ; void AudioResampler :: init_routine ( ) { } uint32_t AudioResampler :: qualityMHz ( src_quality quality ) { switch ( quality ) { default : case DEFAULT_QUALITY : case LOW_QUALITY : return 3 ; case MED_QUALITY : return 6 ; case HIGH_QUALITY : return 20 ; case VERY_HIGH_QUALITY : return 34 ; } } static const uint32_t maxMHz = 130 ; static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER ; static uint32_t currentMHz = 0 ; AudioResampler * AudioResampler :: create ( audio_format_t format , int inChannelCount , int32_t sampleRate , src_quality quality ) { bool atFinalQuality ; if ( quality == DEFAULT_QUALITY ) { int ok = pthread_once ( & once_control , init_routine ) ; if ( ok != 0 ) { ALOGE ( " % s ▁ pthread _ once ▁ failed : ▁ % d " , __func__ , ok ) ; } quality = defaultQuality ; atFinalQuality = false ; } else { atFinalQuality = true ; } if ( quality == DEFAULT_QUALITY ) { } pthread_mutex_lock ( & mutex ) ; for ( ; ; ) { uint32_t deltaMHz = qualityMHz ( quality ) ; uint32_t newMHz = currentMHz + deltaMHz ; if ( ( qualityIsSupported ( quality ) && newMHz <= maxMHz ) || atFinalQuality ) { ALOGV ( " resampler ▁ load ▁ % u ▁ - > ▁ % u ▁ MHz ▁ due ▁ to ▁ delta ▁ + % u ▁ MHz ▁ from ▁ quality ▁ % d " , currentMHz , newMHz , deltaMHz , quality ) ; currentMHz = newMHz ; break ; } switch ( quality ) { default : case LOW_QUALITY : atFinalQuality = true ; break ; case MED_QUALITY : quality = LOW_QUALITY ; break ; case HIGH_QUALITY : quality = MED_QUALITY ; break ; case VERY_HIGH_QUALITY : quality = HIGH_QUALITY ; break ; } } pthread_mutex_unlock ( & mutex ) ; AudioResampler * resampler ; switch ( quality ) { default : case LOW_QUALITY : ALOGV ( " Create ▁ linear ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; resampler = new ( std :: nothrow ) AudioResamplerOrder1 ( inChannelCount , sampleRate ) ; break ; case MED_QUALITY : ALOGV ( " Create ▁ cubic ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; resampler = new ( std :: nothrow ) AudioResamplerCubic ( inChannelCount , sampleRate ) ; break ; case HIGH_QUALITY : ALOGV ( " Create ▁ HIGH _ QUALITY ▁ sinc ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; ALOG_ASSERT ( false , " HIGH _ QUALITY ▁ isn ' t ▁ supported " ) ; break ; case VERY_HIGH_QUALITY : ALOGV ( " Create ▁ VERY _ HIGH _ QUALITY ▁ sinc ▁ Resampler ▁ = ▁ % d " , quality ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; ALOG_ASSERT ( false , " VERY _ HIGH _ QUALITY ▁ isn ' t ▁ supported " ) ; break ; } resampler -> init ( ) ; return resampler ; } AudioResampler :: AudioResampler ( int inChannelCount , int32_t sampleRate , src_quality quality ) : mChannelCount ( inChannelCount ) , mSampleRate ( sampleRate ) , mInSampleRate ( sampleRate ) , mInputIndex ( 0 ) , mPhaseFraction ( 0 ) , mLocalTimeFreq ( 0 ) , mPTS ( AudioBufferProvider :: kInvalidPTS ) , mQuality ( quality ) { const int maxChannels = 2 ; if ( inChannelCount < 1 || inChannelCount > maxChannels ) { LOG_ALWAYS_FATAL ( " Unsupported ▁ sample ▁ format ▁ % d ▁ quality ▁ % d ▁ channels " , quality , inChannelCount ) ; } if ( sampleRate <= 0 ) { LOG_ALWAYS_FATAL ( " Unsupported ▁ sample ▁ rate ▁ % d ▁ Hz " , sampleRate ) ; } mVolume [ 0 ] = mVolume [ 1 ] = 0 ; mBuffer . frameCount = 0 ; } AudioResampler :: ~ AudioResampler ( ) { pthread_mutex_lock ( & mutex ) ; src_quality quality = getQuality ( ) ; uint32_t deltaMHz = qualityMHz ( quality ) ; int32_t newMHz = currentMHz - deltaMHz ; ALOGV ( " resampler ▁ load ▁ % u ▁ - > ▁ % d ▁ MHz ▁ due ▁ to ▁ delta ▁ - % u ▁ MHz ▁ from ▁ quality ▁ % d " , currentMHz , newMHz , deltaMHz , quality ) ; LOG_ALWAYS_FATAL_IF ( newMHz < 0 , " negative ▁ resampler ▁ load ▁ % d ▁ MHz " , newMHz ) ; currentMHz = newMHz ; pthread_mutex_unlock ( & mutex ) ; } void AudioResampler :: setSampleRate ( int32_t inSampleRate ) { mInSampleRate = inSampleRate ; mPhaseIncrement = ( uint32_t ) ( ( kPhaseMultiplier * inSampleRate ) / mSampleRate ) ; } void AudioResampler :: setVolume ( float left , float right ) { mVolume [ 0 ] = u4_12_from_float ( clampFloatVol ( left ) ) ; mVolume [ 1 ] = u4_12_from_float ( clampFloatVol ( right ) ) ; } void AudioResampler :: setLocalTimeFreq ( uint64_t freq ) { mLocalTimeFreq = freq ; } void AudioResampler :: setPTS ( int64_t pts ) { mPTS = pts ; } int64_t AudioResampler :: calculateOutputPTS ( int outputFrameIndex ) { if ( mPTS == AudioBufferProvider :: kInvalidPTS ) { return AudioBufferProvider :: kInvalidPTS ; } else { return mPTS + ( ( outputFrameIndex * mLocalTimeFreq ) / mSampleRate ) ; } } void AudioResampler :: reset ( ) { mInputIndex = 0 ; mPhaseFraction = 0 ; mBuffer . frameCount = 0 ; } size_t AudioResamplerOrder1 :: resample ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { switch ( mChannelCount ) { case 1 : return resampleMono16 ( out , outFrameCount , provider ) ; case 2 : return resampleStereo16 ( out , outFrameCount , provider ) ; default : LOG_ALWAYS_FATAL ( " invalid ▁ channel ▁ count : ▁ % d " , mChannelCount ) ; return 0 ; } } size_t AudioResamplerOrder1 :: resampleStereo16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { int32_t vl = mVolume [ 0 ] ; int32_t vr = mVolume [ 1 ] ; size_t inputIndex = mInputIndex ; uint32_t phaseFraction = mPhaseFraction ; uint32_t phaseIncrement = mPhaseIncrement ; size_t outputIndex = 0 ; size_t outputSampleCount = outFrameCount * 2 ; size_t inFrameCount = getInFrameCountRequired ( outFrameCount ) ; while ( outputIndex < outputSampleCount ) { while ( mBuffer . frameCount == 0 ) { mBuffer . frameCount = inFrameCount ; provider -> getNextBuffer ( & mBuffer , calculateOutputPTS ( outputIndex / 2 ) ) ; if ( mBuffer . raw == NULL ) { goto resampleStereo16_exit ; } if ( mBuffer . frameCount > inputIndex ) break ; inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount * 2 - 2 ] ; mX0R = mBuffer . i16 [ mBuffer . frameCount * 2 - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } int16_t * in = mBuffer . i16 ; while ( inputIndex == 0 ) { out [ outputIndex ++ ] += vl * Interp ( mX0L , in [ 0 ] , phaseFraction ) ; out [ outputIndex ++ ] += vr * Interp ( mX0R , in [ 1 ] , phaseFraction ) ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; if ( outputIndex == outputSampleCount ) { break ; } } # ifdef ASM_ARM_RESAMP1 if ( inputIndex + 2 < mBuffer . frameCount ) { int32_t * maxOutPt ; int32_t maxInIdx ; maxOutPt = out + ( outputSampleCount - 2 ) ; maxInIdx = mBuffer . frameCount - 2 ; AsmStereo16Loop ( in , maxOutPt , maxInIdx , outputIndex , out , inputIndex , vl , vr , phaseFraction , phaseIncrement ) ; } # endif while ( outputIndex < outputSampleCount && inputIndex < mBuffer . frameCount ) { out [ outputIndex ++ ] += vl * Interp ( in [ inputIndex * 2 - 2 ] , in [ inputIndex * 2 ] , phaseFraction ) ; out [ outputIndex ++ ] += vr * Interp ( in [ inputIndex * 2 - 1 ] , in [ inputIndex * 2 + 1 ] , phaseFraction ) ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; } if ( inputIndex >= mBuffer . frameCount ) { inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount * 2 - 2 ] ; mX0R = mBuffer . i16 [ mBuffer . frameCount * 2 - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } } resampleStereo16_exit : mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; return outputIndex / 2 ; } size_t AudioResamplerOrder1 :: resampleMono16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { int32_t vl = mVolume [ 0 ] ; int32_t vr = mVolume [ 1 ] ; size_t inputIndex = mInputIndex ; uint32_t phaseFraction = mPhaseFraction ; uint32_t phaseIncrement = mPhaseIncrement ; size_t outputIndex = 0 ; size_t outputSampleCount = outFrameCount * 2 ; size_t inFrameCount = getInFrameCountRequired ( outFrameCount ) ; while ( outputIndex < outputSampleCount ) { while ( mBuffer . frameCount == 0 ) { mBuffer . frameCount = inFrameCount ; provider -> getNextBuffer ( & mBuffer , calculateOutputPTS ( outputIndex / 2 ) ) ; if ( mBuffer . raw == NULL ) { mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; goto resampleMono16_exit ; } if ( mBuffer . frameCount > inputIndex ) break ; inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } int16_t * in = mBuffer . i16 ; while ( inputIndex == 0 ) { int32_t sample = Interp ( mX0L , in [ 0 ] , phaseFraction ) ; out [ outputIndex ++ ] += vl * sample ; out [ outputIndex ++ ] += vr * sample ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; if ( outputIndex == outputSampleCount ) { break ; } } # ifdef ASM_ARM_RESAMP1 if ( inputIndex + 2 < mBuffer . frameCount ) { int32_t * maxOutPt ; int32_t maxInIdx ; maxOutPt = out + ( outputSampleCount - 2 ) ; maxInIdx = ( int32_t ) mBuffer . frameCount - 2 ; AsmMono16Loop ( in , maxOutPt , maxInIdx , outputIndex , out , inputIndex , vl , vr , phaseFraction , phaseIncrement ) ; } # endif while ( outputIndex < outputSampleCount && inputIndex < mBuffer . frameCount ) { int32_t sample = Interp ( in [ inputIndex - 1 ] , in [ inputIndex ] , phaseFraction ) ; out [ outputIndex ++ ] += vl * sample ; out [ outputIndex ++ ] += vr * sample ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; } if ( inputIndex >= mBuffer . frameCount ) { inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } } resampleMono16_exit : mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; return outputIndex ; } # ifdef ASM_ARM_RESAMP1 __attribute__ ( ( noinline ) ) void AudioResamplerOrder1 :: AsmMono16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) { ( void ) maxOutPt ; ( void ) maxInIdx ; ( void ) outputIndex ; ( void ) out ; ( void ) inputIndex ; ( void ) vl ; ( void ) vr ; ( void ) phaseFraction ; ( void ) phaseIncrement ; ( void ) in ; # define MO_PARAM5 "36" asm ( " stmfd ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ lr } \n " " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 20 ] \n " " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ r6 ] \n " " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 8 ] \n " " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ r7 ] \n " " ▁ ▁ ▁ ldr ▁ r8 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 4 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ r0 ] \n " " ▁ ▁ ▁ add ▁ r8 , ▁ r8 , ▁ r0 , ▁ asl ▁ # 2 \n " " ▁ ▁ ▁ ldr ▁ r9 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 24 ] \n " " ▁ ▁ ▁ ldr ▁ r10 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 12 ] \n " " ▁ ▁ ▁ ldr ▁ r11 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 16 ] \n " "1 : \n " " ▁ ▁ ▁ cmp ▁ r8 , ▁ r2 \n " " ▁ ▁ ▁ bcs ▁ 2f \n " # define MO_ONE_FRAME " ▁ ▁ ▁ add ▁ r0 , ▁ r1 , ▁ r7 , ▁ asl ▁ # 1 \n " " ▁ ▁ ▁ ldrsh ▁ r4 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r5 , ▁ [ r8 ] \n " " ▁ ▁ ▁ ldrsh ▁ r0 , ▁ [ r0 , ▁ # -2 ] \n " " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " " ▁ ▁ ▁ sub ▁ r4 , ▁ r4 , ▁ r0 \n " " ▁ ▁ ▁ mov ▁ r4 , ▁ r4 , ▁ lsl ▁ # 2 \n " " ▁ ▁ ▁ smulwt ▁ r4 , ▁ r4 , ▁ r6 \n " " ▁ ▁ ▁ add ▁ r6 , ▁ r6 , ▁ r9 \n " " ▁ ▁ ▁ add ▁ r0 , ▁ r0 , ▁ r4 \n " " ▁ ▁ ▁ mla ▁ r5 , ▁ r0 , ▁ r10 , ▁ r5 \n " " ▁ ▁ ▁ ldr ▁ r4 , ▁ [ r8 , ▁ # 4 ] \n " " ▁ ▁ ▁ str ▁ r5 , ▁ [ r8 ] , ▁ # 4 \n " " ▁ ▁ ▁ mla ▁ r4 , ▁ r0 , ▁ r11 , ▁ r4 \n " " ▁ ▁ ▁ add ▁ r7 , ▁ r7 , ▁ r6 , ▁ lsr ▁ # 30 \n " " ▁ ▁ ▁ str ▁ r4 , ▁ [ r8 ] , ▁ # 4 \n " MO_ONE_FRAME MO_ONE_FRAME " ▁ ▁ ▁ cmp ▁ r7 , ▁ r3 \n " " ▁ ▁ ▁ bcc ▁ 1b \n " "2 : \n " " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 20 ] \n " " ▁ ▁ ▁ str ▁ r6 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 8 ] \n " " ▁ ▁ ▁ str ▁ r7 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 4 ] \n " " ▁ ▁ ▁ sub ▁ r8 , ▁ r0 \n " " ▁ ▁ ▁ asr ▁ r8 , ▁ # 2 \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 0 ] \n " " ▁ ▁ ▁ str ▁ r8 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldmfd ▁ ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ pc } \n " ) ; } __attribute__ ( ( noinline ) ) void AudioResamplerOrder1 :: AsmStereo16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) { ( void ) maxOutPt ; ( void ) maxInIdx ; ( void ) outputIndex ; ( void ) out ; ( void ) inputIndex ; ( void ) vl ; ( void ) vr ; ( void ) phaseFraction ; ( void ) phaseIncrement ; ( void ) in ; # define ST_PARAM5 "40" asm ( " stmfd ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ r12 , ▁ lr } \n " " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 20 ] \n " " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ r6 ] \n " " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 8 ] \n " " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ r7 ] \n " " ▁ ▁ ▁ ldr ▁ r8 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 4 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ r0 ] \n " " ▁ ▁ ▁ add ▁ r8 , ▁ r8 , ▁ r0 , ▁ asl ▁ # 2 \n " " ▁ ▁ ▁ ldr ▁ r9 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 24 ] \n " " ▁ ▁ ▁ ldr ▁ r10 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 12 ] \n " " ▁ ▁ ▁ ldr ▁ r11 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 16 ] \n " "3 : \n " " ▁ ▁ ▁ cmp ▁ r8 , ▁ r2 \n " " ▁ ▁ ▁ bcs ▁ 4f \n " # define ST_ONE_FRAME " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " " ▁ ▁ ▁ add ▁ r0 , ▁ r1 , ▁ r7 , ▁ asl ▁ # 2 \n " " ▁ ▁ ▁ ldrsh ▁ r4 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r5 , ▁ [ r8 ] \n " " ▁ ▁ ▁ ldrsh ▁ r12 , ▁ [ r0 , ▁ # -4 ] \n " " ▁ ▁ ▁ sub ▁ r4 , ▁ r4 , ▁ r12 \n " " ▁ ▁ ▁ mov ▁ r4 , ▁ r4 , ▁ lsl ▁ # 2 \n " " ▁ ▁ ▁ smulwt ▁ r4 , ▁ r4 , ▁ r6 \n " " ▁ ▁ ▁ add ▁ r12 , ▁ r12 , ▁ r4 \n " " ▁ ▁ ▁ mla ▁ r5 , ▁ r12 , ▁ r10 , ▁ r5 \n " " ▁ ▁ ▁ ldr ▁ r4 , ▁ [ r8 , ▁ # 4 ] \n " " ▁ ▁ ▁ str ▁ r5 , ▁ [ r8 ] , ▁ # 4 \n " " ▁ ▁ ▁ ldrsh ▁ r12 , ▁ [ r0 , ▁ # + 2 ] \n " " ▁ ▁ ▁ ldrsh ▁ r0 , ▁ [ r0 , ▁ # -2 ] \n " " ▁ ▁ ▁ sub ▁ r12 , ▁ r12 , ▁ r0 \n " " ▁ ▁ ▁ mov ▁ r12 , ▁ r12 , ▁ lsl ▁ # 2 \n " " ▁ ▁ ▁ smulwt ▁ r12 , ▁ r12 , ▁ r6 \n " " ▁ ▁ ▁ add ▁ r12 , ▁ r0 , ▁ r12 \n " " ▁ ▁ ▁ mla ▁ r4 , ▁ r12 , ▁ r11 , ▁ r4 \n " " ▁ ▁ ▁ str ▁ r4 , ▁ [ r8 ] , ▁ # 4 \n " " ▁ ▁ ▁ add ▁ r6 , ▁ r6 , ▁ r9 \n " " ▁ ▁ ▁ add ▁ r7 , ▁ r7 , ▁ r6 , ▁ lsr ▁ # 30 \n " ST_ONE_FRAME ST_ONE_FRAME " ▁ ▁ ▁ cmp ▁ r7 , ▁ r3 \n " " ▁ ▁ ▁ bcc ▁ 3b \n " "4 : \n " " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 20 ] \n " " ▁ ▁ ▁ str ▁ r6 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 8 ] \n " " ▁ ▁ ▁ str ▁ r7 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 4 ] \n " " ▁ ▁ ▁ sub ▁ r8 , ▁ r0 \n " " ▁ ▁ ▁ asr ▁ r8 , ▁ # 2 \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 0 ] \n " " ▁ ▁ ▁ str ▁ r8 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldmfd ▁ ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ r12 , ▁ pc } \n " ) ; } # endif } } </DOCUMENT>
<DOCUMENT_ID="yxcoin/yxcoin/tree/master/src/boost_1_55_0/libs/phoenix/test/include/stl/algorithm/querying.cpp"> # include < boost / phoenix / stl / algorithm / querying . hpp > int main ( ) { } </DOCUMENT>
<DOCUMENT_ID="LiveAsynchronousVisualizedArchitecture/lava/tree/master/nuklear/unified.cpp"> # define LAVA_INDEXED_VERTS_IMPL # include " IndexedVerts . h " # include " nanogui / src / screen . cpp " # include " main . cpp " </DOCUMENT>
<DOCUMENT_ID="ellipsis14/dolfin/tree/master/test/unit/la/cpp/Vector.cpp"> # include < dolfin . h > # include < dolfin / common / unittest . h > using namespace dolfin ; class TestVector : public CppUnit :: TestFixture { CPPUNIT_TEST_SUITE ( TestVector ) ; CPPUNIT_TEST ( test_backends ) ; CPPUNIT_TEST ( test_init ) ; CPPUNIT_TEST ( test_get_local_empty ) ; CPPUNIT_TEST_SUITE_END ( ) ; public : void test_backends ( ) { parameters [ " linear _ algebra _ backend " ] = " Eigen " ; _test_operators ( MPI_COMM_SELF ) ; # ifdef HAS_PETSC parameters [ " linear _ algebra _ backend " ] = " PETSc " ; _test_operators ( MPI_COMM_WORLD ) ; # endif } void _test_operators ( MPI_Comm comm ) { Vector v ( comm , 10 ) , u ( comm , 10 ) ; v = 0.0 ; u = 0.0 ; CPPUNIT_ASSERT ( v . sum ( ) == 0.0 ) ; v = 1.0 ; CPPUNIT_ASSERT ( v . sum ( ) == v . size ( ) ) ; u = v ; CPPUNIT_ASSERT ( u . sum ( ) == u . size ( ) ) ; u += v ; CPPUNIT_ASSERT ( u . sum ( ) == 2 * u . size ( ) ) ; u -= v ; u -= v ; CPPUNIT_ASSERT ( u . sum ( ) == 0.0 ) ; v *= 5.0 ; CPPUNIT_ASSERT ( v . sum ( ) == v . size ( ) * 5.0 ) ; v /= 2.0 ; CPPUNIT_ASSERT ( v . sum ( ) == 2.5 * v . size ( ) ) ; u = 2.0 ; v *= u ; CPPUNIT_ASSERT ( v . sum ( ) == v . size ( ) * 5.0 ) ; } void test_init ( ) { const std :: vector < std :: size_t > dims ( 1 , 203 ) ; TensorLayout layout_local ( 0 , false ) ; std :: vector < std :: pair < std :: size_t , std :: size_t > > local_range ( 1 , std :: make_pair ( 0 , 203 ) ) ; layout_local . init ( MPI_COMM_SELF , dims , 1 , local_range ) ; TensorLayout layout_distributed ( 0 , false ) ; std :: vector < std :: pair < std :: size_t , std :: size_t > > ownership_range ( 1 , dolfin :: MPI :: local_range ( MPI_COMM_WORLD , 203 ) ) ; layout_distributed . init ( MPI_COMM_WORLD , dims , 1 , ownership_range ) ; # ifdef HAS_PETSC parameters [ " linear _ algebra _ backend " ] = " PETSc " ; { Vector x ; x . init ( layout_local ) ; CPPUNIT_ASSERT ( x . size ( ) == 203 ) ; Vector y ; y . init ( layout_distributed ) ; CPPUNIT_ASSERT ( y . size ( ) == 203 ) ; } # endif { EigenVector x ; x . init ( layout_local ) ; CPPUNIT_ASSERT ( x . size ( ) == 203 ) ; } # ifdef HAS_PETSC { PETScVector x ; x . init ( layout_local ) ; CPPUNIT_ASSERT ( x . size ( ) == 203 ) ; PETScVector y ; y . init ( layout_distributed ) ; CPPUNIT_ASSERT ( y . size ( ) == 203 ) ; } # endif } void test_get_local_empty ( ) { const std :: vector < std :: size_t > dims ( 1 , 203 ) ; TensorLayout layout_local ( 0 , false ) ; std :: vector < std :: pair < std :: size_t , std :: size_t > > local_range ( 1 , std :: make_pair ( 0 , 203 ) ) ; layout_local . init ( MPI_COMM_SELF , dims , 1 , local_range ) ; TensorLayout layout_distributed ( 0 , false ) ; std :: vector < std :: pair < std :: size_t , std :: size_t > > ownership_range ( 1 , dolfin :: MPI :: local_range ( MPI_COMM_WORLD , 203 ) ) ; layout_distributed . init ( MPI_COMM_WORLD , dims , 1 , ownership_range ) ; # ifdef HAS_PETSC parameters [ " linear _ algebra _ backend " ] = " PETSc " ; { Vector x ; x . init ( layout_local ) ; CPPUNIT_ASSERT ( x . size ( ) == 203 ) ; Vector y ; y . init ( layout_distributed ) ; CPPUNIT_ASSERT ( y . size ( ) == 203 ) ; double * block = NULL ; dolfin :: la_index * rows = NULL ; x . get_local ( block , 0 , rows ) ; y . get_local ( block , 0 , rows ) ; } # endif } } ; CPPUNIT_TEST_SUITE_REGISTRATION ( TestVector ) ; int main ( ) { DOLFIN_TEST ; } </DOCUMENT>
<DOCUMENT_ID="PKRoma/poedit/tree/master/deps/boost/libs/phoenix/test/container/container_tests8a.cpp"> # include " container _ tests . hpp " # include < boost / static_assert . hpp > std :: set < int > const build_set ( ) { typedef std :: set < int > int_set ; typedef std :: vector < int > int_vector ; int_set result ; int_vector const data = build_vector ( ) ; int_vector :: const_iterator it = data . begin ( ) ; int_vector :: const_iterator const end = data . end ( ) ; result . insert ( it , end ) ; return result ; } std :: multiset < int > const build_multiset ( ) { typedef std :: set < int > int_set ; typedef std :: multiset < int > int_multiset ; int_set const data = build_set ( ) ; return int_multiset ( data . begin ( ) , data . end ( ) ) ; } std :: vector < int > const init_vector ( ) { typedef std :: vector < int > int_vector ; int const data [ ] = { - 4 , - 3 , - 2 , - 1 , 0 } ; int_vector :: size_type const data_size = sizeof ( data ) / sizeof ( data [ 0 ] ) ; return int_vector ( data , data + data_size ) ; } std :: vector < int > const build_vector ( ) { typedef std :: vector < int > int_vector ; static int_vector data = init_vector ( ) ; int_vector :: size_type const size = data . size ( ) ; int_vector :: iterator it = data . begin ( ) ; int_vector :: iterator const end = data . end ( ) ; for ( ; it != end ; ++ it ) * it += size ; return data ; } int main ( ) { BOOST_STATIC_ASSERT ( ( ! phx :: stl :: has_mapped_type < std :: multiset < int > > :: value ) ) ; BOOST_STATIC_ASSERT ( ( phx :: stl :: has_key_type < std :: multiset < int > > :: value ) ) ; std :: multiset < int > const data = build_multiset ( ) ; test_begin ( data ) ; test_clear ( data ) ; test_empty ( data ) ; test_end ( data ) ; test_set_erase ( data ) ; test_get_allocator ( data ) ; return boost :: report_errors ( ) ; } </DOCUMENT>
<DOCUMENT_ID="alejocb/rgbdtam/tree/master/ThirdParty/g2o/g2o/core/marginal_covariance_cholesky.cpp"> # include " marginal _ covariance _ cholesky . h " # include < algorithm > # include < cassert > using namespace std ; namespace g2o { struct MatrixElem { int r , c ; MatrixElem ( int r_ , int c_ ) : r ( r_ ) , c ( c_ ) { } bool operator < ( const MatrixElem & other ) const { return c > other . c || ( c == other . c && r > other . r ) ; } } ; MarginalCovarianceCholesky :: MarginalCovarianceCholesky ( ) : _n ( 0 ) , _Ap ( 0 ) , _Ai ( 0 ) , _Ax ( 0 ) , _perm ( 0 ) { } MarginalCovarianceCholesky :: ~ MarginalCovarianceCholesky ( ) { } void MarginalCovarianceCholesky :: setCholeskyFactor ( int n , int * Lp , int * Li , double * Lx , int * permInv ) { _n = n ; _Ap = Lp ; _Ai = Li ; _Ax = Lx ; _perm = permInv ; _diag . resize ( n ) ; for ( int r = 0 ; r < n ; ++ r ) { const int & sc = _Ap [ r ] ; assert ( r == _Ai [ sc ] && " Error ▁ in ▁ CCS ▁ storage ▁ of ▁ L " ) ; _diag [ r ] = 1.0 / _Ax [ sc ] ; } } double MarginalCovarianceCholesky :: computeEntry ( int r , int c ) { assert ( r <= c ) ; int idx = computeIndex ( r , c ) ; LookupMap :: const_iterator foundIt = _map . find ( idx ) ; if ( foundIt != _map . end ( ) ) { return foundIt -> second ; } double s = 0. ; const int & sc = _Ap [ r ] ; const int & ec = _Ap [ r + 1 ] ; for ( int j = sc + 1 ; j < ec ; ++ j ) { const int & rr = _Ai [ j ] ; double val = rr < c ? computeEntry ( rr , c ) : computeEntry ( c , rr ) ; s += val * _Ax [ j ] ; } double result ; if ( r == c ) { const double & diagElem = _diag [ r ] ; result = diagElem * ( diagElem - s ) ; } else { result = - s * _diag [ r ] ; } _map [ idx ] = result ; return result ; } void MarginalCovarianceCholesky :: computeCovariance ( double * * covBlocks , const std :: vector < int > & blockIndices ) { _map . clear ( ) ; int base = 0 ; vector < MatrixElem > elemsToCompute ; for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int nbase = blockIndices [ i ] ; int vdim = nbase - base ; for ( int rr = 0 ; rr < vdim ; ++ rr ) for ( int cc = rr ; cc < vdim ; ++ cc ) { int r = _perm ? _perm [ rr + base ] : rr + base ; int c = _perm ? _perm [ cc + base ] : cc + base ; if ( r > c ) swap ( r , c ) ; elemsToCompute . push_back ( MatrixElem ( r , c ) ) ; } base = nbase ; } sort ( elemsToCompute . begin ( ) , elemsToCompute . end ( ) ) ; for ( size_t i = 0 ; i < elemsToCompute . size ( ) ; ++ i ) { const MatrixElem & me = elemsToCompute [ i ] ; computeEntry ( me . r , me . c ) ; } base = 0 ; for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int nbase = blockIndices [ i ] ; int vdim = nbase - base ; double * cov = covBlocks [ i ] ; for ( int rr = 0 ; rr < vdim ; ++ rr ) for ( int cc = rr ; cc < vdim ; ++ cc ) { int r = _perm ? _perm [ rr + base ] : rr + base ; int c = _perm ? _perm [ cc + base ] : cc + base ; if ( r > c ) swap ( r , c ) ; int idx = computeIndex ( r , c ) ; LookupMap :: const_iterator foundIt = _map . find ( idx ) ; assert ( foundIt != _map . end ( ) ) ; cov [ rr * vdim + cc ] = foundIt -> second ; if ( rr != cc ) cov [ cc * vdim + rr ] = foundIt -> second ; } base = nbase ; } } void MarginalCovarianceCholesky :: computeCovariance ( SparseBlockMatrix < MatrixXd > & spinv , const std :: vector < int > & rowBlockIndices , const std :: vector < std :: pair < int , int > > & blockIndices ) { spinv = SparseBlockMatrix < MatrixXd > ( & rowBlockIndices [ 0 ] , & rowBlockIndices [ 0 ] , rowBlockIndices . size ( ) , rowBlockIndices . size ( ) , true ) ; _map . clear ( ) ; vector < MatrixElem > elemsToCompute ; for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int blockRow = blockIndices [ i ] . first ; int blockCol = blockIndices [ i ] . second ; assert ( blockRow >= 0 ) ; assert ( blockRow < ( int ) rowBlockIndices . size ( ) ) ; assert ( blockCol >= 0 ) ; assert ( blockCol < ( int ) rowBlockIndices . size ( ) ) ; int rowBase = spinv . rowBaseOfBlock ( blockRow ) ; int colBase = spinv . colBaseOfBlock ( blockCol ) ; MatrixXd * block = spinv . block ( blockRow , blockCol , true ) ; assert ( block ) ; for ( int iRow = 0 ; iRow < block -> rows ( ) ; ++ iRow ) for ( int iCol = 0 ; iCol < block -> cols ( ) ; ++ iCol ) { int rr = rowBase + iRow ; int cc = colBase + iCol ; int r = _perm ? _perm [ rr ] : rr ; int c = _perm ? _perm [ cc ] : cc ; if ( r > c ) swap ( r , c ) ; elemsToCompute . push_back ( MatrixElem ( r , c ) ) ; } } sort ( elemsToCompute . begin ( ) , elemsToCompute . end ( ) ) ; for ( size_t i = 0 ; i < elemsToCompute . size ( ) ; ++ i ) { const MatrixElem & me = elemsToCompute [ i ] ; computeEntry ( me . r , me . c ) ; } for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int blockRow = blockIndices [ i ] . first ; int blockCol = blockIndices [ i ] . second ; int rowBase = spinv . rowBaseOfBlock ( blockRow ) ; int colBase = spinv . colBaseOfBlock ( blockCol ) ; MatrixXd * block = spinv . block ( blockRow , blockCol ) ; assert ( block ) ; for ( int iRow = 0 ; iRow < block -> rows ( ) ; ++ iRow ) for ( int iCol = 0 ; iCol < block -> cols ( ) ; ++ iCol ) { int rr = rowBase + iRow ; int cc = colBase + iCol ; int r = _perm ? _perm [ rr ] : rr ; int c = _perm ? _perm [ cc ] : cc ; if ( r > c ) swap ( r , c ) ; int idx = computeIndex ( r , c ) ; LookupMap :: const_iterator foundIt = _map . find ( idx ) ; assert ( foundIt != _map . end ( ) ) ; ( * block ) ( iRow , iCol ) = foundIt -> second ; } } } } </DOCUMENT>
<DOCUMENT_ID="sjsinju/coreclr/tree/master/src/pal/tests/palsuite/c_runtime/fmod/test1/test1.cpp"> # include < palsuite . h > # define PAL_EPSILON 8.8817841970012523e - 16 # define PAL_NAN sqrt ( - 1.0 ) # define PAL_POSINF - log ( 0.0 ) # define PAL_NEGINF log ( 0.0 ) struct test { double numerator ; double denominator ; double expected ; double variance ; } ; void __cdecl validate ( double numerator , double denominator , double expected , double variance ) { double result = fmod ( numerator , denominator ) ; double delta = fabs ( result - expected ) ; if ( delta > variance ) { Fail ( " fmod ( % g , ▁ % g ) ▁ returned ▁ % 20.17g ▁ when ▁ it ▁ should ▁ have ▁ returned ▁ % 20.17g " , numerator , denominator , result , expected ) ; } } void __cdecl validate_isnan ( double numerator , double denominator ) { double result = fmod ( numerator , denominator ) ; if ( ! _isnan ( result ) ) { Fail ( " fmod ( % g , ▁ % g ) ▁ returned ▁ % 20.17g ▁ when ▁ it ▁ should ▁ have ▁ returned ▁ % 20.17g " , numerator , denominator , result , PAL_NAN ) ; } } INT __cdecl main ( INT argc , CHAR * * argv ) { struct test tests [ ] = { { 0 , PAL_POSINF , 0 , PAL_EPSILON } , { 0.31296179620778659 , 0.94976571538163866 , 0.31296179620778658 , PAL_EPSILON } , { 0.42077048331375735 , 0.90716712923909839 , 0.42077048331375733 , PAL_EPSILON } , { 0.59448076852482208 , 0.80410982822879171 , 0.59448076852482212 , PAL_EPSILON } , { 0.63896127631363480 , 0.76923890136397213 , 0.63896127631363475 , PAL_EPSILON } , { 0.64963693908006244 , 0.76024459707563015 , 0.64963693908006248 , PAL_EPSILON } , { 0.70710678118654752 , 0.70710678118654752 , 0 , PAL_EPSILON } , { 1 , 1 , 0 , PAL_EPSILON } , { 0.84147098480789651 , 0.54030230586813972 , 0.30116867893975674 , PAL_EPSILON } , { 0.90371945743584630 , 0.42812514788535792 , 0.047469161665130377 , PAL_EPSILON / 10 } , { 0.98776594599273553 , 0.15594369476537447 , 0.052103777400488605 , PAL_EPSILON / 10 } , { 0.99180624439366372 , 0.12775121753523991 , 0.097547721646984359 , PAL_EPSILON / 10 } , { 0.74398033695749319 , - 0.66820151019031295 , 0.075778826767180285 , PAL_EPSILON / 10 } , { 0.41078129050290870 , - 0.91173391478696510 , 0.41078129050290868 , PAL_EPSILON } , { 0 , - 1 , 0 , PAL_EPSILON } , { 1 , PAL_POSINF , 1 , PAL_EPSILON * 10 } , } ; if ( PAL_Initialize ( argc , argv ) != 0 ) { return FAIL ; } for ( int i = 0 ; i < ( sizeof ( tests ) / sizeof ( struct test ) ) ; i ++ ) { validate ( tests [ i ] . numerator , tests [ i ] . denominator , tests [ i ] . expected , tests [ i ] . variance ) ; validate ( - tests [ i ] . numerator , tests [ i ] . denominator , - tests [ i ] . expected , tests [ i ] . variance ) ; validate ( tests [ i ] . numerator , - tests [ i ] . denominator , tests [ i ] . expected , tests [ i ] . variance ) ; validate ( - tests [ i ] . numerator , - tests [ i ] . denominator , - tests [ i ] . expected , tests [ i ] . variance ) ; } validate_isnan ( 0 , 0 ) ; validate_isnan ( - 0.0 , 0 ) ; validate_isnan ( 0 , - 0.0 ) ; validate_isnan ( - 0.0 , - 0.0 ) ; validate_isnan ( 1 , 0 ) ; validate_isnan ( - 1.0 , 0 ) ; validate_isnan ( 1 , - 0.0 ) ; validate_isnan ( - 1.0 , - 0.0 ) ; validate_isnan ( PAL_POSINF , PAL_POSINF ) ; validate_isnan ( PAL_NEGINF , PAL_POSINF ) ; validate_isnan ( PAL_POSINF , PAL_NEGINF ) ; validate_isnan ( PAL_NEGINF , PAL_NEGINF ) ; validate_isnan ( PAL_POSINF , 0 ) ; validate_isnan ( PAL_NEGINF , 0 ) ; validate_isnan ( PAL_POSINF , - 0.0 ) ; validate_isnan ( PAL_NEGINF , - 0.0 ) ; validate_isnan ( PAL_POSINF , 1 ) ; validate_isnan ( PAL_NEGINF , 1 ) ; validate_isnan ( PAL_POSINF , - 1.0 ) ; validate_isnan ( PAL_NEGINF , - 1.0 ) ; PAL_Terminate ( ) ; return PASS ; } </DOCUMENT>
<DOCUMENT_ID="xlmbn/trscoin/tree/master/src/test/multisig_tests.cpp"> # include < boost / assert . hpp > # include < boost / assign / list_of . hpp > # include < boost / assign / list_inserter . hpp > # include < boost / assign / std / vector . hpp > # include < boost / test / unit_test . hpp > # include < boost / foreach . hpp > # include < boost / tuple / tuple . hpp > # include < openssl / ec . h > # include < openssl / err . h > # include " keystore . h " # include " main . h " # include " script . h " # include " wallet . h " using namespace std ; using namespace boost :: assign ; typedef vector < unsigned char > valtype ; extern uint256 SignatureHash ( CScript scriptCode , const CTransaction & txTo , unsigned int nIn , int nHashType ) ; BOOST_AUTO_TEST_SUITE ( multisig_tests ) CScript sign_multisig ( CScript scriptPubKey , vector < CKey > keys , CTransaction transaction , int whichIn ) { uint256 hash = SignatureHash ( scriptPubKey , transaction , whichIn , SIGHASH_ALL ) ; CScript result ; result << OP_0 ; BOOST_FOREACH ( const CKey & key , keys ) { vector < unsigned char > vchSig ; BOOST_CHECK ( key . Sign ( hash , vchSig ) ) ; vchSig . push_back ( ( unsigned char ) SIGHASH_ALL ) ; result << vchSig ; } return result ; } BOOST_AUTO_TEST_CASE ( multisig_verify ) { unsigned int flags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) key [ i ] . MakeNewKey ( true ) ; CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; CTransaction txFrom ; txFrom . vout . resize ( 3 ) ; txFrom . vout [ 0 ] . scriptPubKey = a_and_b ; txFrom . vout [ 1 ] . scriptPubKey = a_or_b ; txFrom . vout [ 2 ] . scriptPubKey = escrow ; CTransaction txTo [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { txTo [ i ] . vin . resize ( 1 ) ; txTo [ i ] . vout . resize ( 1 ) ; txTo [ i ] . vin [ 0 ] . prevout . n = i ; txTo [ i ] . vin [ 0 ] . prevout . hash = txFrom . GetHash ( ) ; txTo [ i ] . vout [ 0 ] . nValue = 1 ; } vector < CKey > keys ; CScript s ; keys . clear ( ) ; keys += key [ 0 ] , key [ 1 ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK ( VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) { keys . clear ( ) ; keys += key [ i ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) , strprintf ( " a & b ▁ 1 : ▁ % d " , i ) ) ; keys . clear ( ) ; keys += key [ 1 ] , key [ i ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) , strprintf ( " a & b ▁ 2 : ▁ % d " , i ) ) ; } for ( int i = 0 ; i < 4 ; i ++ ) { keys . clear ( ) ; keys += key [ i ] ; s = sign_multisig ( a_or_b , keys , txTo [ 1 ] , 0 ) ; if ( i == 0 || i == 1 ) BOOST_CHECK_MESSAGE ( VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) , strprintf ( " a | b : ▁ % d " , i ) ) ; else BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) , strprintf ( " a | b : ▁ % d " , i ) ) ; } s . clear ( ) ; s << OP_0 << OP_0 ; BOOST_CHECK ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) ) ; s . clear ( ) ; s << OP_0 << OP_1 ; BOOST_CHECK ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) { keys . clear ( ) ; keys += key [ i ] , key [ j ] ; s = sign_multisig ( escrow , keys , txTo [ 2 ] , 0 ) ; if ( i < j && i < 3 && j < 3 ) BOOST_CHECK_MESSAGE ( VerifyScript ( s , escrow , txTo [ 2 ] , 0 , flags , 0 ) , strprintf ( " escrow ▁ 1 : ▁ % d ▁ % d " , i , j ) ) ; else BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , escrow , txTo [ 2 ] , 0 , flags , 0 ) , strprintf ( " escrow ▁ 2 : ▁ % d ▁ % d " , i , j ) ) ; } } BOOST_AUTO_TEST_CASE ( multisig_IsStandard ) { CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) key [ i ] . MakeNewKey ( true ) ; CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( a_and_b ) ) ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( a_or_b ) ) ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( escrow ) ) ; CScript one_of_four ; one_of_four << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << key [ 3 ] . GetPubKey ( ) << OP_4 << OP_CHECKMULTISIG ; BOOST_CHECK ( ! :: IsStandard ( one_of_four ) ) ; CScript malformed [ 6 ] ; malformed [ 0 ] << OP_3 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; malformed [ 1 ] << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; malformed [ 2 ] << OP_0 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; malformed [ 3 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_0 << OP_CHECKMULTISIG ; malformed [ 4 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_CHECKMULTISIG ; malformed [ 5 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) ; for ( int i = 0 ; i < 6 ; i ++ ) BOOST_CHECK ( ! :: IsStandard ( malformed [ i ] ) ) ; } BOOST_AUTO_TEST_CASE ( multisig_Solver1 ) { CBasicKeyStore keystore , emptykeystore , partialkeystore ; CKey key [ 3 ] ; CTxDestination keyaddr [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { key [ i ] . MakeNewKey ( true ) ; keystore . AddKey ( key [ i ] ) ; keyaddr [ i ] = key [ i ] . GetPubKey ( ) . GetID ( ) ; } partialkeystore . AddKey ( key [ 0 ] ) ; { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << key [ 0 ] . GetPubKey ( ) << OP_CHECKSIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 1 ) ; CTxDestination addr ; BOOST_CHECK ( ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( addr == keyaddr [ 0 ] ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_DUP << OP_HASH160 << key [ 0 ] . GetPubKey ( ) . GetID ( ) << OP_EQUALVERIFY << OP_CHECKSIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 1 ) ; CTxDestination addr ; BOOST_CHECK ( ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( addr == keyaddr [ 0 ] ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK_EQUAL ( solutions . size ( ) , 4U ) ; CTxDestination addr ; BOOST_CHECK ( ! ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; BOOST_CHECK ( ! IsMine ( partialkeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK_EQUAL ( solutions . size ( ) , 4U ) ; vector < CTxDestination > addrs ; int nRequired ; BOOST_CHECK ( ExtractDestinations ( s , whichType , addrs , nRequired ) ) ; BOOST_CHECK ( addrs [ 0 ] == keyaddr [ 0 ] ) ; BOOST_CHECK ( addrs [ 1 ] == keyaddr [ 1 ] ) ; BOOST_CHECK ( nRequired == 1 ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; BOOST_CHECK ( ! IsMine ( partialkeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 5 ) ; } } BOOST_AUTO_TEST_CASE ( multisig_Sign ) { CBasicKeyStore keystore ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { key [ i ] . MakeNewKey ( true ) ; keystore . AddKey ( key [ i ] ) ; } CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; CTransaction txFrom ; txFrom . vout . resize ( 3 ) ; txFrom . vout [ 0 ] . scriptPubKey = a_and_b ; txFrom . vout [ 1 ] . scriptPubKey = a_or_b ; txFrom . vout [ 2 ] . scriptPubKey = escrow ; CTransaction txTo [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { txTo [ i ] . vin . resize ( 1 ) ; txTo [ i ] . vout . resize ( 1 ) ; txTo [ i ] . vin [ 0 ] . prevout . n = i ; txTo [ i ] . vin [ 0 ] . prevout . hash = txFrom . GetHash ( ) ; txTo [ i ] . vout [ 0 ] . nValue = 1 ; } for ( int i = 0 ; i < 3 ; i ++ ) { BOOST_CHECK_MESSAGE ( SignSignature ( keystore , txFrom , txTo [ i ] , 0 ) , strprintf ( " SignSignature ▁ % d " , i ) ) ; } } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
<DOCUMENT_ID="goldcoin/gldcoin/tree/master/BuildDeps/deps/boost/libs/polygon/example/voronoi_visualizer.cpp"> # include < iostream > # include < vector > # include < QtOpenGL / QGLWidget > # include < QtGui / QtGui > # include < boost / polygon / polygon . hpp > # include < boost / polygon / voronoi . hpp > using namespace boost :: polygon ; # include " voronoi _ visual _ utils . hpp " class GLWidget : public QGLWidget { Q_OBJECT public : explicit GLWidget ( QMainWindow * parent = NULL ) : QGLWidget ( QGLFormat ( QGL :: SampleBuffers ) , parent ) , primary_edges_only_ ( false ) , internal_edges_only_ ( false ) { startTimer ( 40 ) ; } QSize sizeHint ( ) const { return QSize ( 600 , 600 ) ; } void build ( const QString & file_path ) { clear ( ) ; read_data ( file_path ) ; if ( ! brect_initialized_ ) { return ; } construct_brect ( ) ; construct_voronoi ( point_data_ . begin ( ) , point_data_ . end ( ) , segment_data_ . begin ( ) , segment_data_ . end ( ) , & vd_ ) ; for ( const_edge_iterator it = vd_ . edges ( ) . begin ( ) ; it != vd_ . edges ( ) . end ( ) ; ++ it ) { if ( ! it -> is_finite ( ) ) { color_exterior ( & ( * it ) ) ; } } update_view_port ( ) ; } void show_primary_edges_only ( ) { primary_edges_only_ ^= true ; } void show_internal_edges_only ( ) { internal_edges_only_ ^= true ; } protected : void initializeGL ( ) { glHint ( GL_POINT_SMOOTH_HINT , GL_NICEST ) ; glBlendFunc ( GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA ) ; glEnable ( GL_BLEND ) ; glEnable ( GL_POINT_SMOOTH ) ; } void paintGL ( ) { qglClearColor ( QColor :: fromRgb ( 255 , 255 , 255 ) ) ; glClear ( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT ) ; draw_points ( ) ; draw_segments ( ) ; draw_vertices ( ) ; draw_edges ( ) ; } void resizeGL ( int width , int height ) { int side = qMin ( width , height ) ; glViewport ( ( width - side ) / 2 , ( height - side ) / 2 , side , side ) ; } void timerEvent ( QTimerEvent * e ) { update ( ) ; } private : typedef double coordinate_type ; typedef point_data < coordinate_type > point_type ; typedef segment_data < coordinate_type > segment_type ; typedef rectangle_data < coordinate_type > rect_type ; typedef voronoi_builder < int > VB ; typedef voronoi_diagram < coordinate_type > VD ; typedef VD :: cell_type cell_type ; typedef VD :: cell_type :: source_index_type source_index_type ; typedef VD :: cell_type :: source_category_type source_category_type ; typedef VD :: edge_type edge_type ; typedef VD :: cell_container_type cell_container_type ; typedef VD :: cell_container_type vertex_container_type ; typedef VD :: edge_container_type edge_container_type ; typedef VD :: const_cell_iterator const_cell_iterator ; typedef VD :: const_vertex_iterator const_vertex_iterator ; typedef VD :: const_edge_iterator const_edge_iterator ; static const std :: size_t EXTERNAL_COLOR = 1 ; void clear ( ) { brect_initialized_ = false ; point_data_ . clear ( ) ; segment_data_ . clear ( ) ; vd_ . clear ( ) ; } void read_data ( const QString & file_path ) { QFile data ( file_path ) ; if ( ! data . open ( QFile :: ReadOnly ) ) { QMessageBox :: warning ( this , tr ( " Voronoi ▁ Visualizer " ) , tr ( " Disable ▁ to ▁ open ▁ file ▁ " ) + file_path ) ; } QTextStream in_stream ( & data ) ; std :: size_t num_points , num_segments ; int x1 , y1 , x2 , y2 ; in_stream >> num_points ; for ( std :: size_t i = 0 ; i < num_points ; ++ i ) { in_stream >> x1 >> y1 ; point_type p ( x1 , y1 ) ; update_brect ( p ) ; point_data_ . push_back ( p ) ; } in_stream >> num_segments ; for ( std :: size_t i = 0 ; i < num_segments ; ++ i ) { in_stream >> x1 >> y1 >> x2 >> y2 ; point_type lp ( x1 , y1 ) ; point_type hp ( x2 , y2 ) ; update_brect ( lp ) ; update_brect ( hp ) ; segment_data_ . push_back ( segment_type ( lp , hp ) ) ; } in_stream . flush ( ) ; } void update_brect ( const point_type & point ) { if ( brect_initialized_ ) { encompass ( brect_ , point ) ; } else { set_points ( brect_ , point , point ) ; brect_initialized_ = true ; } } void construct_brect ( ) { double side = ( std :: max ) ( xh ( brect_ ) - xl ( brect_ ) , yh ( brect_ ) - yl ( brect_ ) ) ; center ( shift_ , brect_ ) ; set_points ( brect_ , shift_ , shift_ ) ; bloat ( brect_ , side * 1.2 ) ; } void color_exterior ( const VD :: edge_type * edge ) { if ( edge -> color ( ) == EXTERNAL_COLOR ) { return ; } edge -> color ( EXTERNAL_COLOR ) ; edge -> twin ( ) -> color ( EXTERNAL_COLOR ) ; const VD :: vertex_type * v = edge -> vertex1 ( ) ; if ( v == NULL || ! edge -> is_primary ( ) ) { return ; } v -> color ( EXTERNAL_COLOR ) ; const VD :: edge_type * e = v -> incident_edge ( ) ; do { color_exterior ( e ) ; e = e -> rot_next ( ) ; } while ( e != v -> incident_edge ( ) ) ; } void update_view_port ( ) { glMatrixMode ( GL_PROJECTION ) ; glLoadIdentity ( ) ; rect_type view_rect = brect_ ; deconvolve ( view_rect , shift_ ) ; glOrtho ( xl ( view_rect ) , xh ( view_rect ) , yl ( view_rect ) , yh ( view_rect ) , - 1.0 , 1.0 ) ; glMatrixMode ( GL_MODELVIEW ) ; } void draw_points ( ) { glColor3f ( 0.0f , 0.5f , 1.0f ) ; glPointSize ( 9 ) ; glBegin ( GL_POINTS ) ; for ( std :: size_t i = 0 ; i < point_data_ . size ( ) ; ++ i ) { point_type point = point_data_ [ i ] ; deconvolve ( point , shift_ ) ; glVertex2f ( point . x ( ) , point . y ( ) ) ; } for ( std :: size_t i = 0 ; i < segment_data_ . size ( ) ; ++ i ) { point_type lp = low ( segment_data_ [ i ] ) ; lp = deconvolve ( lp , shift_ ) ; glVertex2f ( lp . x ( ) , lp . y ( ) ) ; point_type hp = high ( segment_data_ [ i ] ) ; hp = deconvolve ( hp , shift_ ) ; glVertex2f ( hp . x ( ) , hp . y ( ) ) ; } glEnd ( ) ; } void draw_segments ( ) { glColor3f ( 0.0f , 0.5f , 1.0f ) ; glLineWidth ( 2.7f ) ; glBegin ( GL_LINES ) ; for ( std :: size_t i = 0 ; i < segment_data_ . size ( ) ; ++ i ) { point_type lp = low ( segment_data_ [ i ] ) ; lp = deconvolve ( lp , shift_ ) ; glVertex2f ( lp . x ( ) , lp . y ( ) ) ; point_type hp = high ( segment_data_ [ i ] ) ; hp = deconvolve ( hp , shift_ ) ; glVertex2f ( hp . x ( ) , hp . y ( ) ) ; } glEnd ( ) ; } void draw_vertices ( ) { glColor3f ( 0.0f , 0.0f , 0.0f ) ; glPointSize ( 6 ) ; glBegin ( GL_POINTS ) ; for ( const_vertex_iterator it = vd_ . vertices ( ) . begin ( ) ; it != vd_ . vertices ( ) . end ( ) ; ++ it ) { if ( internal_edges_only_ && ( it -> color ( ) == EXTERNAL_COLOR ) ) { continue ; } point_type vertex ( it -> x ( ) , it -> y ( ) ) ; vertex = deconvolve ( vertex , shift_ ) ; glVertex2f ( vertex . x ( ) , vertex . y ( ) ) ; } glEnd ( ) ; } void draw_edges ( ) { glColor3f ( 0.0f , 0.0f , 0.0f ) ; glLineWidth ( 1.7f ) ; for ( const_edge_iterator it = vd_ . edges ( ) . begin ( ) ; it != vd_ . edges ( ) . end ( ) ; ++ it ) { if ( primary_edges_only_ && ! it -> is_primary ( ) ) { continue ; } if ( internal_edges_only_ && ( it -> color ( ) == EXTERNAL_COLOR ) ) { continue ; } std :: vector < point_type > samples ; if ( ! it -> is_finite ( ) ) { clip_infinite_edge ( * it , & samples ) ; } else { point_type vertex0 ( it -> vertex0 ( ) -> x ( ) , it -> vertex0 ( ) -> y ( ) ) ; samples . push_back ( vertex0 ) ; point_type vertex1 ( it -> vertex1 ( ) -> x ( ) , it -> vertex1 ( ) -> y ( ) ) ; samples . push_back ( vertex1 ) ; if ( it -> is_curved ( ) ) { sample_curved_edge ( * it , & samples ) ; } } glBegin ( GL_LINE_STRIP ) ; for ( std :: size_t i = 0 ; i < samples . size ( ) ; ++ i ) { point_type vertex = deconvolve ( samples [ i ] , shift_ ) ; glVertex2f ( vertex . x ( ) , vertex . y ( ) ) ; } glEnd ( ) ; } } void clip_infinite_edge ( const edge_type & edge , std :: vector < point_type > * clipped_edge ) { const cell_type & cell1 = * edge . cell ( ) ; const cell_type & cell2 = * edge . twin ( ) -> cell ( ) ; point_type origin , direction ; if ( cell1 . contains_point ( ) && cell2 . contains_point ( ) ) { point_type p1 = retrieve_point ( cell1 ) ; point_type p2 = retrieve_point ( cell2 ) ; origin . x ( ( p1 . x ( ) + p2 . x ( ) ) * 0.5 ) ; origin . y ( ( p1 . y ( ) + p2 . y ( ) ) * 0.5 ) ; direction . x ( p1 . y ( ) - p2 . y ( ) ) ; direction . y ( p2 . x ( ) - p1 . x ( ) ) ; } else { origin = cell1 . contains_segment ( ) ? retrieve_point ( cell2 ) : retrieve_point ( cell1 ) ; segment_type segment = cell1 . contains_segment ( ) ? retrieve_segment ( cell1 ) : retrieve_segment ( cell2 ) ; coordinate_type dx = high ( segment ) . x ( ) - low ( segment ) . x ( ) ; coordinate_type dy = high ( segment ) . y ( ) - low ( segment ) . y ( ) ; if ( ( low ( segment ) == origin ) ^ cell1 . contains_point ( ) ) { direction . x ( dy ) ; direction . y ( - dx ) ; } else { direction . x ( - dy ) ; direction . y ( dx ) ; } } coordinate_type side = xh ( brect_ ) - xl ( brect_ ) ; coordinate_type koef = side / ( std :: max ) ( fabs ( direction . x ( ) ) , fabs ( direction . y ( ) ) ) ; if ( edge . vertex0 ( ) == NULL ) { clipped_edge -> push_back ( point_type ( origin . x ( ) - direction . x ( ) * koef , origin . y ( ) - direction . y ( ) * koef ) ) ; } else { clipped_edge -> push_back ( point_type ( edge . vertex0 ( ) -> x ( ) , edge . vertex0 ( ) -> y ( ) ) ) ; } if ( edge . vertex1 ( ) == NULL ) { clipped_edge -> push_back ( point_type ( origin . x ( ) + direction . x ( ) * koef , origin . y ( ) + direction . y ( ) * koef ) ) ; } else { clipped_edge -> push_back ( point_type ( edge . vertex1 ( ) -> x ( ) , edge . vertex1 ( ) -> y ( ) ) ) ; } } void sample_curved_edge ( const edge_type & edge , std :: vector < point_type > * sampled_edge ) { coordinate_type max_dist = 1E - 3 * ( xh ( brect_ ) - xl ( brect_ ) ) ; point_type point = edge . cell ( ) -> contains_point ( ) ? retrieve_point ( * edge . cell ( ) ) : retrieve_point ( * edge . twin ( ) -> cell ( ) ) ; segment_type segment = edge . cell ( ) -> contains_point ( ) ? retrieve_segment ( * edge . twin ( ) -> cell ( ) ) : retrieve_segment ( * edge . cell ( ) ) ; voronoi_visual_utils < coordinate_type > :: discretize ( point , segment , max_dist , sampled_edge ) ; } point_type retrieve_point ( const cell_type & cell ) { source_index_type index = cell . source_index ( ) ; source_category_type category = cell . source_category ( ) ; if ( category == SOURCE_CATEGORY_SINGLE_POINT ) { return point_data_ [ index ] ; } index -= point_data_ . size ( ) ; if ( category == SOURCE_CATEGORY_SEGMENT_START_POINT ) { return low ( segment_data_ [ index ] ) ; } else { return high ( segment_data_ [ index ] ) ; } } segment_type retrieve_segment ( const cell_type & cell ) { source_index_type index = cell . source_index ( ) - point_data_ . size ( ) ; return segment_data_ [ index ] ; } point_type shift_ ; std :: vector < point_type > point_data_ ; std :: vector < segment_type > segment_data_ ; rect_type brect_ ; VB vb_ ; VD vd_ ; bool brect_initialized_ ; bool primary_edges_only_ ; bool internal_edges_only_ ; } ; class MainWindow : public QWidget { Q_OBJECT public : MainWindow ( ) { glWidget_ = new GLWidget ( ) ; file_dir_ = QDir ( QDir :: currentPath ( ) , tr ( " * . txt " ) ) ; file_name_ = tr ( " " ) ; QHBoxLayout * centralLayout = new QHBoxLayout ; centralLayout -> addWidget ( glWidget_ ) ; centralLayout -> addLayout ( create_file_layout ( ) ) ; setLayout ( centralLayout ) ; update_file_list ( ) ; setWindowTitle ( tr ( " Voronoi ▁ Visualizer " ) ) ; layout ( ) -> setSizeConstraint ( QLayout :: SetFixedSize ) ; } private slots : void primary_edges_only ( ) { glWidget_ -> show_primary_edges_only ( ) ; } void internal_edges_only ( ) { glWidget_ -> show_internal_edges_only ( ) ; } void browse ( ) { QString new_path = QFileDialog :: getExistingDirectory ( 0 , tr ( " Choose ▁ Directory " ) , file_dir_ . absolutePath ( ) ) ; if ( new_path . isEmpty ( ) ) { return ; } file_dir_ . setPath ( new_path ) ; update_file_list ( ) ; } void build ( ) { file_name_ = file_list_ -> currentItem ( ) -> text ( ) ; QString file_path = file_dir_ . filePath ( file_name_ ) ; message_label_ -> setText ( " Building . . . " ) ; glWidget_ -> build ( file_path ) ; message_label_ -> setText ( " Double ▁ click ▁ the ▁ item ▁ to ▁ build ▁ voronoi ▁ diagram : " ) ; setWindowTitle ( tr ( " Voronoi ▁ Visualizer ▁ - ▁ " ) + file_path ) ; } void print_scr ( ) { if ( ! file_name_ . isEmpty ( ) ) { QImage screenshot = glWidget_ -> grabFrameBuffer ( true ) ; QString output_file = file_dir_ . absolutePath ( ) + tr ( " / " ) + file_name_ . left ( file_name_ . indexOf ( ' . ' ) ) + tr ( " . png " ) ; screenshot . save ( output_file , 0 , - 1 ) ; } } private : QGridLayout * create_file_layout ( ) { QGridLayout * file_layout = new QGridLayout ; message_label_ = new QLabel ( " Double ▁ click ▁ item ▁ to ▁ build ▁ voronoi ▁ diagram : " ) ; file_list_ = new QListWidget ( ) ; file_list_ -> connect ( file_list_ , SIGNAL ( itemDoubleClicked ( QListWidgetItem * ) ) , this , SLOT ( build ( ) ) ) ; QCheckBox * primary_checkbox = new QCheckBox ( " Show ▁ primary ▁ edges ▁ only . " ) ; connect ( primary_checkbox , SIGNAL ( clicked ( ) ) , this , SLOT ( primary_edges_only ( ) ) ) ; QCheckBox * internal_checkbox = new QCheckBox ( " Show ▁ internal ▁ edges ▁ only . " ) ; connect ( internal_checkbox , SIGNAL ( clicked ( ) ) , this , SLOT ( internal_edges_only ( ) ) ) ; QPushButton * browse_button = new QPushButton ( tr ( " Browse ▁ Input ▁ Directory " ) ) ; connect ( browse_button , SIGNAL ( clicked ( ) ) , this , SLOT ( browse ( ) ) ) ; browse_button -> setMinimumHeight ( 50 ) ; QPushButton * print_scr_button = new QPushButton ( tr ( " Make ▁ Screenshot " ) ) ; connect ( print_scr_button , SIGNAL ( clicked ( ) ) , this , SLOT ( print_scr ( ) ) ) ; print_scr_button -> setMinimumHeight ( 50 ) ; file_layout -> addWidget ( message_label_ , 0 , 0 ) ; file_layout -> addWidget ( file_list_ , 1 , 0 ) ; file_layout -> addWidget ( primary_checkbox , 2 , 0 ) ; file_layout -> addWidget ( internal_checkbox , 3 , 0 ) ; file_layout -> addWidget ( browse_button , 4 , 0 ) ; file_layout -> addWidget ( print_scr_button , 5 , 0 ) ; return file_layout ; } void update_file_list ( ) { QFileInfoList list = file_dir_ . entryInfoList ( ) ; file_list_ -> clear ( ) ; if ( file_dir_ . count ( ) == 0 ) { return ; } QFileInfoList :: const_iterator it ; for ( it = list . begin ( ) ; it != list . end ( ) ; it ++ ) { file_list_ -> addItem ( it -> fileName ( ) ) ; } file_list_ -> setCurrentRow ( 0 ) ; } QDir file_dir_ ; QString file_name_ ; GLWidget * glWidget_ ; QListWidget * file_list_ ; QLabel * message_label_ ; } ; int main ( int argc , char * argv [ ] ) { QApplication app ( argc , argv ) ; MainWindow window ; window . show ( ) ; return app . exec ( ) ; } # include " voronoi _ visualizer . moc " </DOCUMENT>
<DOCUMENT_ID="RazZziel/sc_pong/tree/master/src/scfont.cpp"> # include < stdlib . h > # include < string . h > # include " SDL / SDL . h " # include " SDL / SDL _ image . h " # include " scfont . h " ScFont * ScLoadFont ( const char * filename ) { ScFont * font = ( ScFont * ) malloc ( sizeof ( ScFont ) ) ; FILE * file = fopen ( filename , " r " ) ; fread ( ( void * ) & font -> header , sizeof ( ScFontHeader ) , 1 , file ) ; int n_offsets = font -> header . highIndex - font -> header . lowIndex ; Uint32 * offsets = ( Uint32 * ) malloc ( sizeof ( Uint32 ) * ( n_offsets + 1 ) ) ; fseek ( file , sizeof ( ScFontHeader ) , SEEK_SET ) ; fread ( ( void * ) offsets , sizeof ( Uint32 ) , n_offsets , file ) ; fseek ( file , 0 , SEEK_END ) ; offsets [ n_offsets ] = ftell ( file ) ; font -> letters = ( ScLetter * ) malloc ( sizeof ( ScLetter ) * ( n_offsets + 1 ) ) ; for ( int i = 1 ; i <= n_offsets ; i ++ ) { if ( offsets [ i - 1 ] ) { fseek ( file , offsets [ i - 1 ] , SEEK_SET ) ; fread ( ( void * ) & font -> letters [ i ] . header , sizeof ( ScLetterHeader ) , 1 , file ) ; int next_offset = offsets [ i ] ; for ( int o = 0 ; ! next_offset ; o ++ ) { next_offset = offsets [ i + o ] ; } font -> letters [ i ] . n_pixels = next_offset - ( offsets [ i - 1 ] + sizeof ( ScLetterHeader ) ) - 1 ; font -> letters [ i ] . pixels = ( Uint8 * ) malloc ( sizeof ( Uint8 ) * font -> letters [ i ] . n_pixels ) ; fseek ( file , ( offsets [ i - 1 ] + sizeof ( ScLetterHeader ) ) , SEEK_SET ) ; fread ( ( void * ) font -> letters [ i ] . pixels , sizeof ( Uint8 ) , font -> letters [ i ] . n_pixels , file ) ; } else font -> letters [ i ] . n_pixels = - 1 ; } font -> letters [ 0 ] . n_pixels = 0 ; font -> letters [ 0 ] . header . x = 0 ; font -> letters [ 0 ] . header . y = 0 ; font -> letters [ 0 ] . header . h = 0 ; font -> letters [ 0 ] . header . w = font -> header . maxWidth / 2 ; free ( offsets ) ; fclose ( file ) ; return font ; } ScPalette * ScLoadPalette ( const char * filename ) { ScPalette * palette = ( ScPalette * ) malloc ( sizeof ( ScPalette ) ) ; SDL_Surface * s_palette ; if ( ( s_palette = SDL_DisplayFormat ( IMG_Load ( filename ) ) ) == NULL ) { fprintf ( stderr , " ERROR : ▁ Cannot ▁ load ▁ palette ▁ ' % s ' " , filename ) ; exit ( 1 ) ; } memcpy ( * palette , s_palette -> pixels , s_palette -> format -> BytesPerPixel * s_palette -> w ) ; SDL_FreeSurface ( s_palette ) ; return palette ; } SDL_Surface * ScRenderChar ( unsigned const char car , ScFont * font , ScColor * color ) { SDL_Surface * screen = SDL_GetVideoSurface ( ) ; int index = car - font -> header . lowIndex ; if ( ( car < font -> header . lowIndex ) || ( car > font -> header . highIndex ) || ( font -> letters [ index ] . n_pixels < 0 ) ) { fprintf ( stderr , " ERROR ▁ ( ScRenderChar ) : ▁ Invalid ▁ character ▁ index ▁ % d \n " , car ) ; return NULL ; } SDL_Surface * letter = SDL_CreateRGBSurface ( SDL_SWSURFACE , font -> letters [ index ] . header . w , font -> letters [ index ] . header . h , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; if ( font -> letters [ index ] . header . h > 0 ) { char * pixels = ( char * ) letter -> pixels - letter -> format -> BytesPerPixel ; for ( int p = 0 ; p < font -> letters [ index ] . n_pixels ; p ++ ) { Uint8 skip = font -> letters [ index ] . pixels [ p ] >> 3 ; Uint8 gamma = font -> letters [ index ] . pixels [ p ] & 7 ; pixels += skip * letter -> format -> BytesPerPixel + letter -> format -> BytesPerPixel ; memcpy ( pixels , * color + gamma , letter -> format -> BytesPerPixel ) ; } SDL_SetColorKey ( letter , SDL_SRCCOLORKEY | SDL_RLEACCEL , 0 ) ; } SDL_Surface * final_letter = SDL_CreateRGBSurface ( SDL_SWSURFACE , font -> letters [ index ] . header . w , font -> header . maxHeight , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; SDL_Rect offset = { font -> letters [ index ] . header . x , font -> letters [ index ] . header . y , 0 , 0 } ; SDL_BlitSurface ( letter , NULL , final_letter , & offset ) ; SDL_FreeSurface ( letter ) ; SDL_SetColorKey ( final_letter , SDL_SRCCOLORKEY | SDL_RLEACCEL , 0 ) ; return final_letter ; } int calculateWidth ( const unsigned char * text , ScFont * font , char delim ) { int width = 0 ; while ( * text ) { if ( * text != delim ) width += font -> letters [ * text - font -> header . lowIndex ] . header . w + 1 ; text ++ ; } return width - 1 ; } SDL_Surface * ScRenderText ( const char * text , ScFont * font , ScColor * color , ScColor * color_hi , char delim ) { SDL_Surface * screen = SDL_GetVideoSurface ( ) ; SDL_Surface * s_text = SDL_CreateRGBSurface ( SDL_SWSURFACE , calculateWidth ( ( unsigned char * ) text , font , delim ) , font -> header . maxHeight , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; SDL_SetColorKey ( s_text , SDL_SRCCOLORKEY | SDL_RLEACCEL , 0 ) ; SDL_Surface * s_char ; SDL_Rect offset = { 0 , 0 , 0 , 0 } ; if ( color_hi ) { ScColor * actual_color = color ; while ( * text ) { if ( * text == delim ) { if ( actual_color == color ) actual_color = color_hi ; else actual_color = color ; } else { if ( ( s_char = ScRenderChar ( * text , font , actual_color ) ) ) { SDL_BlitSurface ( s_char , NULL , s_text , & offset ) ; offset . x += s_char -> w + 1 ; SDL_FreeSurface ( s_char ) ; } } text ++ ; } } else { while ( * text ) { if ( * text != delim ) { if ( ( s_char = ScRenderChar ( * text , font , color ) ) ) { SDL_BlitSurface ( s_char , NULL , s_text , & offset ) ; offset . x += s_char -> w + 1 ; SDL_FreeSurface ( s_char ) ; } } text ++ ; } } return s_text ; } ScColor * ScGetColor ( const ScPalette * palette , int index ) { ScColor * color = ( ScColor * ) malloc ( sizeof ( ScColor ) ) ; memcpy ( * color , * palette + ( index * MAX_GAMMA ) , sizeof ( ScColor ) ) ; return color ; } void ScTestFont ( ScFont * font , ScPalette * palette ) { # define TEST_SDL SDL_Surface * screen = SDL_GetVideoSurface ( ) ; SDL_FillRect ( screen , NULL , SDL_MapRGB ( SDL_GetVideoSurface ( ) -> format , 255 , 255 , 255 ) ) ; SDL_Flip ( screen ) ; # ifdef TEST_SDL SDL_Rect offset = { 10 , 10 , 0 , 0 } ; SDL_BlitSurface ( ScRenderText ( " El ▁ veloz ▁ murci � ago ▁ hind " , font , ScGetColor ( palette , 1 ) ) , NULL , screen , & offset ) ; offset . y += font -> header . maxHeight + 2 ; SDL_BlitSurface ( ScRenderText ( " Juiporentenderlas " , font , ScGetColor ( palette , 5 ) ) , NULL , screen , & offset ) ; offset . y += font -> header . maxHeight + 2 ; SDL_BlitSurface ( ScRenderText ( " _ S _ ingle ▁ Player " , font , ScGetColor ( palette , 1 ) , ScGetColor ( palette , 2 ) , ' _ ' ) , NULL , screen , & offset ) ; offset . y += font -> header . maxHeight + 2 ; # endif for ( int i = font -> header . lowIndex ; i <= font -> header . highIndex ; i ++ ) { # ifdef TEST_SDL SDL_Surface * s_char = ScRenderChar ( i , font , ScGetColor ( palette , 2 ) ) ; if ( s_char ) { SDL_BlitSurface ( s_char , NULL , screen , & offset ) ; SDL_FreeSurface ( s_char ) ; } if ( ( offset . x += font -> header . maxWidth + 2 ) > ( screen -> w - font -> header . maxWidth - 10 ) ) { offset . x = 10 ; offset . y += font -> header . maxHeight + 2 ; } # else int index = i - font -> header . lowIndex ; int x = 1 ; for ( int p = 0 ; p < font -> letters [ index ] . n_pixels ; p ++ ) printf ( " % d ▁ " , ( font -> letters [ i ] . pixels [ p ] >> 3 ) ) ; printf ( " \n " ) ; for ( int p = 0 ; p < font -> letters [ index ] . n_pixels ; p ++ ) { Uint8 skip = font -> letters [ index ] . pixels [ p ] >> 3 ; Uint8 color = font -> letters [ index ] . pixels [ p ] & 7 ; for ( int j = 0 ; j < skip ; j ++ ) { printf ( " ▁ " ) ; if ( x ++ == font -> letters [ index ] . header . w ) { printf ( " \n " ) ; x = 1 ; } } printf ( " % d " , color ) ; if ( x ++ == font -> letters [ index ] . header . w ) { printf ( " \n " ) ; x = 1 ; } } printf ( " \n test ▁ end \n " ) ; getchar ( ) ; # endif } SDL_Flip ( screen ) ; * screen = * SDL_CreateRGBSurface ( SDL_SWSURFACE , screen -> w , screen -> h , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; getchar ( ) ; } </DOCUMENT>
<DOCUMENT_ID="phamelin/ardupilot/tree/master/libraries/AP_Frsky_Telem/AP_Frsky_Telem.cpp"> # include " AP _ Frsky _ Telem . h " # include < AP_InertialSensor / AP_InertialSensor . h > # include < GCS_MAVLink / GCS . h > # include < stdio . h > extern const AP_HAL :: HAL & hal ; ObjectArray < mavlink_statustext_t > AP_Frsky_Telem :: _statustext_queue ( FRSKY_TELEM_PAYLOAD_STATUS_CAPACITY ) ; AP_Frsky_Telem :: AP_Frsky_Telem ( AP_AHRS & ahrs , const AP_BattMonitor & battery , const RangeFinder & rng ) : _ahrs ( ahrs ) , _battery ( battery ) , _rng ( rng ) { } void AP_Frsky_Telem :: init ( const AP_SerialManager & serial_manager , const uint8_t mav_type , const uint32_t * ap_valuep ) { if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_D , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_D ; } else if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_SPort , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_SPort ; } else if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough ; gcs ( ) . register_frsky_telemetry_callback ( this ) ; if ( _frame_string == nullptr ) { queue_message ( MAV_SEVERITY_INFO , AP :: fwversion ( ) . fw_string ) ; } else { char firmware_buf [ MAVLINK_MSG_STATUSTEXT_FIELD_TEXT_LEN + 1 ] ; snprintf ( firmware_buf , sizeof ( firmware_buf ) , " % s ▁ % s " , AP :: fwversion ( ) . fw_string , _frame_string ) ; queue_message ( MAV_SEVERITY_INFO , firmware_buf ) ; } _params . mav_type = mav_type ; if ( ap_valuep == nullptr ) { _ap . value = 0x2000 ; _ap . valuep = & _ap . value ; } else { _ap . valuep = ap_valuep ; } } if ( _port != nullptr ) { hal . scheduler -> register_io_process ( FUNCTOR_BIND_MEMBER ( & AP_Frsky_Telem :: tick , void ) ) ; _port -> set_flow_control ( AP_HAL :: UARTDriver :: FLOW_CONTROL_DISABLE ) ; } } void AP_Frsky_Telem :: send_SPort_Passthrough ( void ) { int16_t numc ; numc = _port -> available ( ) ; if ( numc < 0 ) { return ; } if ( _port -> txspace ( ) < 19 ) { return ; } uint8_t prev_byte = 0 ; for ( int16_t i = 0 ; i < numc ; i ++ ) { prev_byte = _passthrough . new_byte ; _passthrough . new_byte = _port -> read ( ) ; } if ( ( prev_byte == START_STOP_SPORT ) && ( _passthrough . new_byte == SENSOR_ID_28 ) ) { if ( _passthrough . send_attiandrng ) { _passthrough . send_attiandrng = false ; } else { _passthrough . send_attiandrng = true ; uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - _passthrough . params_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 7 , calc_param ( ) ) ; _passthrough . params_timer = AP_HAL :: millis ( ) ; return ; } check_sensor_status_flags ( ) ; check_ekf_status ( ) ; if ( get_next_msg_chunk ( ) ) { send_uint32 ( DIY_FIRST_ID , _msg_chunk . chunk ) ; return ; } if ( ( now - _passthrough . ap_status_timer ) >= 500 ) { if ( ( ( * _ap . valuep ) & AP_INITIALIZED_FLAG ) > 0 ) { send_uint32 ( DIY_FIRST_ID + 1 , calc_ap_status ( ) ) ; _passthrough . ap_status_timer = AP_HAL :: millis ( ) ; } return ; } if ( ( now - _passthrough . batt_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 3 , calc_batt ( 0 ) ) ; _passthrough . batt_timer = AP_HAL :: millis ( ) ; return ; } if ( _battery . num_instances ( ) > 1 ) { if ( ( now - _passthrough . batt_timer2 ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 8 , calc_batt ( 1 ) ) ; _passthrough . batt_timer2 = AP_HAL :: millis ( ) ; return ; } } if ( ( now - _passthrough . gps_status_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 2 , calc_gps_status ( ) ) ; _passthrough . gps_status_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . home_timer ) >= 500 ) { send_uint32 ( DIY_FIRST_ID + 4 , calc_home ( ) ) ; _passthrough . home_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . velandyaw_timer ) >= 500 ) { send_uint32 ( DIY_FIRST_ID + 5 , calc_velandyaw ( ) ) ; _passthrough . velandyaw_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . gps_latlng_timer ) >= 1000 ) { send_uint32 ( GPS_LONG_LATI_FIRST_ID , calc_gps_latlng ( & _passthrough . send_latitude ) ) ; if ( ! _passthrough . send_latitude ) { _passthrough . gps_latlng_timer = AP_HAL :: millis ( ) ; } return ; } } send_uint32 ( DIY_FIRST_ID + 6 , calc_attiandrng ( ) ) ; } } void AP_Frsky_Telem :: send_SPort ( void ) { int16_t numc ; numc = _port -> available ( ) ; if ( numc < 0 ) { return ; } if ( _port -> txspace ( ) < 19 ) { return ; } for ( int16_t i = 0 ; i < numc ; i ++ ) { int16_t readbyte = _port -> read ( ) ; if ( _SPort . sport_status == false ) { if ( readbyte == START_STOP_SPORT ) { _SPort . sport_status = true ; } } else { switch ( readbyte ) { case SENSOR_ID_FAS : switch ( _SPort . fas_call ) { case 0 : send_uint32 ( DATA_ID_FUEL , ( uint16_t ) roundf ( _battery . capacity_remaining_pct ( ) ) ) ; break ; case 1 : send_uint32 ( DATA_ID_VFAS , ( uint16_t ) roundf ( _battery . voltage ( ) * 10.0f ) ) ; break ; case 2 : send_uint32 ( DATA_ID_CURRENT , ( uint16_t ) roundf ( _battery . current_amps ( ) * 10.0f ) ) ; break ; } if ( _SPort . fas_call ++ > 2 ) _SPort . fas_call = 0 ; break ; case SENSOR_ID_GPS : switch ( _SPort . gps_call ) { case 0 : calc_gps_position ( ) ; send_uint32 ( DATA_ID_GPS_LAT_BP , _gps . latdddmm ) ; break ; case 1 : send_uint32 ( DATA_ID_GPS_LAT_AP , _gps . latmmmm ) ; break ; case 2 : send_uint32 ( DATA_ID_GPS_LAT_NS , _gps . lat_ns ) ; break ; case 3 : send_uint32 ( DATA_ID_GPS_LONG_BP , _gps . londddmm ) ; break ; case 4 : send_uint32 ( DATA_ID_GPS_LONG_AP , _gps . lonmmmm ) ; break ; case 5 : send_uint32 ( DATA_ID_GPS_LONG_EW , _gps . lon_ew ) ; break ; case 6 : send_uint32 ( DATA_ID_GPS_SPEED_BP , _gps . speed_in_meter ) ; break ; case 7 : send_uint32 ( DATA_ID_GPS_SPEED_AP , _gps . speed_in_centimeter ) ; break ; case 8 : send_uint32 ( DATA_ID_GPS_ALT_BP , _gps . alt_gps_meters ) ; break ; case 9 : send_uint32 ( DATA_ID_GPS_ALT_AP , _gps . alt_gps_cm ) ; break ; case 10 : send_uint32 ( DATA_ID_GPS_COURS_BP , ( uint16_t ) ( ( _ahrs . yaw_sensor / 100 ) % 360 ) ) ; break ; } if ( _SPort . gps_call ++ > 10 ) _SPort . gps_call = 0 ; break ; case SENSOR_ID_VARIO : switch ( _SPort . vario_call ) { case 0 : calc_nav_alt ( ) ; send_uint32 ( DATA_ID_BARO_ALT_BP , _gps . alt_nav_meters ) ; break ; case 1 : send_uint32 ( DATA_ID_BARO_ALT_AP , _gps . alt_nav_cm ) ; break ; } if ( _SPort . vario_call ++ > 1 ) _SPort . vario_call = 0 ; break ; case SENSOR_ID_SP2UR : switch ( _SPort . various_call ) { case 0 : send_uint32 ( DATA_ID_TEMP2 , ( uint16_t ) ( AP :: gps ( ) . num_sats ( ) * 10 + AP :: gps ( ) . status ( ) ) ) ; break ; case 1 : send_uint32 ( DATA_ID_TEMP1 , _ap . control_mode ) ; break ; } if ( _SPort . various_call ++ > 1 ) _SPort . various_call = 0 ; break ; } _SPort . sport_status = false ; } } } void AP_Frsky_Telem :: send_D ( void ) { uint32_t now = AP_HAL :: millis ( ) ; if ( now - _D . last_200ms_frame >= 200 ) { _D . last_200ms_frame = now ; send_uint16 ( DATA_ID_TEMP2 , ( uint16_t ) ( AP :: gps ( ) . num_sats ( ) * 10 + AP :: gps ( ) . status ( ) ) ) ; send_uint16 ( DATA_ID_TEMP1 , _ap . control_mode ) ; send_uint16 ( DATA_ID_FUEL , ( uint16_t ) roundf ( _battery . capacity_remaining_pct ( ) ) ) ; send_uint16 ( DATA_ID_VFAS , ( uint16_t ) roundf ( _battery . voltage ( ) * 10.0f ) ) ; send_uint16 ( DATA_ID_CURRENT , ( uint16_t ) roundf ( _battery . current_amps ( ) * 10.0f ) ) ; calc_nav_alt ( ) ; send_uint16 ( DATA_ID_BARO_ALT_BP , _gps . alt_nav_meters ) ; send_uint16 ( DATA_ID_BARO_ALT_AP , _gps . alt_nav_cm ) ; } if ( now - _D . last_1000ms_frame >= 1000 ) { _D . last_1000ms_frame = now ; send_uint16 ( DATA_ID_GPS_COURS_BP , ( uint16_t ) ( ( _ahrs . yaw_sensor / 100 ) % 360 ) ) ; calc_gps_position ( ) ; if ( AP :: gps ( ) . status ( ) >= 3 ) { send_uint16 ( DATA_ID_GPS_LAT_BP , _gps . latdddmm ) ; send_uint16 ( DATA_ID_GPS_LAT_AP , _gps . latmmmm ) ; send_uint16 ( DATA_ID_GPS_LAT_NS , _gps . lat_ns ) ; send_uint16 ( DATA_ID_GPS_LONG_BP , _gps . londddmm ) ; send_uint16 ( DATA_ID_GPS_LONG_AP , _gps . lonmmmm ) ; send_uint16 ( DATA_ID_GPS_LONG_EW , _gps . lon_ew ) ; send_uint16 ( DATA_ID_GPS_SPEED_BP , _gps . speed_in_meter ) ; send_uint16 ( DATA_ID_GPS_SPEED_AP , _gps . speed_in_centimeter ) ; send_uint16 ( DATA_ID_GPS_ALT_BP , _gps . alt_gps_meters ) ; send_uint16 ( DATA_ID_GPS_ALT_AP , _gps . alt_gps_cm ) ; } } } void AP_Frsky_Telem :: tick ( void ) { if ( ! _initialised_uart ) { if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { _port -> begin ( AP_SERIALMANAGER_FRSKY_D_BAUD , AP_SERIALMANAGER_FRSKY_BUFSIZE_RX , AP_SERIALMANAGER_FRSKY_BUFSIZE_TX ) ; } else { _port -> begin ( AP_SERIALMANAGER_FRSKY_SPORT_BAUD , AP_SERIALMANAGER_FRSKY_BUFSIZE_RX , AP_SERIALMANAGER_FRSKY_BUFSIZE_TX ) ; } _initialised_uart = true ; } if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { send_D ( ) ; } else if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_SPort ) { send_SPort ( ) ; } else if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough ) { send_SPort_Passthrough ( ) ; } } void AP_Frsky_Telem :: calc_crc ( uint8_t byte ) { _crc += byte ; _crc += _crc >> 8 ; _crc &= 0xFF ; } void AP_Frsky_Telem :: send_crc ( void ) { send_byte ( 0xFF - _crc ) ; _crc = 0 ; } void AP_Frsky_Telem :: send_byte ( uint8_t byte ) { if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { if ( byte == START_STOP_D ) { _port -> write ( 0x5D ) ; _port -> write ( 0x3E ) ; } else if ( byte == BYTESTUFF_D ) { _port -> write ( 0x5D ) ; _port -> write ( 0x3D ) ; } else { _port -> write ( byte ) ; } } else { if ( byte == START_STOP_SPORT ) { _port -> write ( 0x7D ) ; _port -> write ( 0x5E ) ; } else if ( byte == BYTESTUFF_SPORT ) { _port -> write ( 0x7D ) ; _port -> write ( 0x5D ) ; } else { _port -> write ( byte ) ; } calc_crc ( byte ) ; } } void AP_Frsky_Telem :: send_uint32 ( uint16_t id , uint32_t data ) { send_byte ( 0x10 ) ; uint8_t * bytes = ( uint8_t * ) & id ; send_byte ( bytes [ 0 ] ) ; send_byte ( bytes [ 1 ] ) ; bytes = ( uint8_t * ) & data ; send_byte ( bytes [ 0 ] ) ; send_byte ( bytes [ 1 ] ) ; send_byte ( bytes [ 2 ] ) ; send_byte ( bytes [ 3 ] ) ; send_crc ( ) ; } void AP_Frsky_Telem :: send_uint16 ( uint16_t id , uint16_t data ) { _port -> write ( START_STOP_D ) ; uint8_t * bytes = ( uint8_t * ) & id ; send_byte ( bytes [ 0 ] ) ; bytes = ( uint8_t * ) & data ; send_byte ( bytes [ 0 ] ) ; send_byte ( bytes [ 1 ] ) ; } bool AP_Frsky_Telem :: get_next_msg_chunk ( void ) { if ( _statustext_queue . empty ( ) ) { return false ; } if ( _msg_chunk . repeats == 0 ) { uint8_t character = 0 ; _msg_chunk . chunk = 0 ; for ( int i = 3 ; i > - 1 && _msg_chunk . char_index < sizeof ( _statustext_queue [ 0 ] -> text ) ; i -- ) { character = _statustext_queue [ 0 ] -> text [ _msg_chunk . char_index ++ ] ; if ( ! character ) { break ; } _msg_chunk . chunk |= character << i * 8 ; } if ( ! character || ( _msg_chunk . char_index == sizeof ( _statustext_queue [ 0 ] -> text ) ) ) { _msg_chunk . char_index = 0 ; _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x4 ) << 21 ; _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x2 ) << 14 ; _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x1 ) << 7 ; } } if ( _msg_chunk . repeats ++ > 2 ) { _msg_chunk . repeats = 0 ; if ( _msg_chunk . char_index == 0 ) { _statustext_queue . remove ( 0 ) ; } } return true ; } void AP_Frsky_Telem :: queue_message ( MAV_SEVERITY severity , const char * text ) { mavlink_statustext_t statustext { } ; statustext . severity = severity ; strncpy ( statustext . text , text , sizeof ( statustext . text ) ) ; _statustext_queue . push_force ( statustext ) ; } void AP_Frsky_Telem :: check_sensor_status_flags ( void ) { uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - check_sensor_status_timer ) >= 5000 ) { if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_GPS ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ GPS ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_GYRO ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Gyro ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_ACCEL ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Accel ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_MAG ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Compass ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Baro ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_LASER_POSITION ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ LiDAR ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ OptFlow ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_TERRAIN ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ or ▁ No ▁ Terrain ▁ Data " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_GEOFENCE ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Geofence ▁ Breach " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_AHRS ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ AHRS " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_RC_RECEIVER ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " No ▁ RC ▁ Receiver " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_LOGGING ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Logging " ) ; check_sensor_status_timer = now ; } } } void AP_Frsky_Telem :: check_ekf_status ( void ) { float velVar , posVar , hgtVar , tasVar ; Vector3f magVar ; Vector2f offset ; if ( _ahrs . get_variances ( velVar , posVar , hgtVar , magVar , tasVar , offset ) ) { uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - check_ekf_status_timer ) >= 10000 ) { if ( velVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ velocity ▁ variance " ) ; check_ekf_status_timer = now ; } if ( posVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ pos ▁ horiz ▁ variance " ) ; check_ekf_status_timer = now ; } if ( hgtVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ pos ▁ vert ▁ variance " ) ; check_ekf_status_timer = now ; } if ( magVar . length ( ) >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ compass ▁ variance " ) ; check_ekf_status_timer = now ; } if ( tasVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ terrain ▁ alt ▁ variance " ) ; check_ekf_status_timer = now ; } } } } uint32_t AP_Frsky_Telem :: calc_param ( void ) { uint32_t param = 0 ; if ( _paramID >= 5 ) { _paramID = 0 ; } _paramID ++ ; switch ( _paramID ) { case 1 : param = _params . mav_type ; break ; case 2 : case 3 : break ; case 4 : param = ( uint32_t ) roundf ( _battery . pack_capacity_mah ( 0 ) ) ; break ; case 5 : param = ( uint32_t ) roundf ( _battery . pack_capacity_mah ( 1 ) ) ; break ; } param = ( _paramID << PARAM_ID_OFFSET ) | ( param & PARAM_VALUE_LIMIT ) ; return param ; } uint32_t AP_Frsky_Telem :: calc_gps_latlng ( bool * send_latitude ) { uint32_t latlng ; const Location & loc = AP :: gps ( ) . location ( 0 ) ; if ( ( * send_latitude ) == true ) { if ( loc . lat < 0 ) { latlng = ( ( labs ( loc . lat ) / 100 ) * 6 ) | 0x40000000 ; } else { latlng = ( ( labs ( loc . lat ) / 100 ) * 6 ) ; } ( * send_latitude ) = false ; } else { if ( loc . lng < 0 ) { latlng = ( ( labs ( loc . lng ) / 100 ) * 6 ) | 0xC0000000 ; } else { latlng = ( ( labs ( loc . lng ) / 100 ) * 6 ) | 0x80000000 ; } ( * send_latitude ) = true ; } return latlng ; } uint32_t AP_Frsky_Telem :: calc_gps_status ( void ) { const AP_GPS & gps = AP :: gps ( ) ; uint32_t gps_status ; gps_status = ( gps . num_sats ( ) < GPS_SATS_LIMIT ) ? gps . num_sats ( ) : GPS_SATS_LIMIT ; gps_status |= ( ( gps . status ( ) < GPS_STATUS_LIMIT ) ? gps . status ( ) : GPS_STATUS_LIMIT ) << GPS_STATUS_OFFSET ; gps_status |= prep_number ( roundf ( gps . get_hdop ( ) * 0.1f ) , 2 , 1 ) << GPS_HDOP_OFFSET ; gps_status |= ( ( gps . status ( ) > GPS_STATUS_LIMIT ) ? gps . status ( ) - GPS_STATUS_LIMIT : 0 ) << GPS_ADVSTATUS_OFFSET ; const Location & loc = gps . location ( ) ; gps_status |= prep_number ( roundf ( loc . alt * 0.1f ) , 2 , 2 ) << GPS_ALTMSL_OFFSET ; return gps_status ; } uint32_t AP_Frsky_Telem :: calc_batt ( uint8_t instance ) { uint32_t batt ; batt = ( ( ( uint16_t ) roundf ( _battery . voltage ( instance ) * 10.0f ) ) & BATT_VOLTAGE_LIMIT ) ; batt |= prep_number ( roundf ( _battery . current_amps ( instance ) * 10.0f ) , 2 , 1 ) << BATT_CURRENT_OFFSET ; batt |= ( ( _battery . consumed_mah ( instance ) < BATT_TOTALMAH_LIMIT ) ? ( ( uint16_t ) roundf ( _battery . consumed_mah ( instance ) ) & BATT_TOTALMAH_LIMIT ) : BATT_TOTALMAH_LIMIT ) << BATT_TOTALMAH_OFFSET ; return batt ; } uint32_t AP_Frsky_Telem :: calc_ap_status ( void ) { uint32_t ap_status ; uint8_t imu_temp = ( uint8_t ) roundf ( constrain_float ( AP :: ins ( ) . get_temperature ( 0 ) , AP_IMU_TEMP_MIN , AP_IMU_TEMP_MAX ) - AP_IMU_TEMP_MIN ) ; ap_status = ( uint8_t ) ( ( _ap . control_mode + 1 ) & AP_CONTROL_MODE_LIMIT ) ; ap_status |= ( uint8_t ) ( ( * _ap . valuep ) & AP_SSIMPLE_FLAGS ) << AP_SSIMPLE_OFFSET ; ap_status |= ( uint8_t ) ( ( ( * _ap . valuep ) & AP_LANDCOMPLETE_FLAG ) ^ AP_LANDCOMPLETE_FLAG ) ; ap_status |= ( uint8_t ) ( AP_Notify :: flags . armed ) << AP_ARMED_OFFSET ; ap_status |= ( uint8_t ) ( AP_Notify :: flags . failsafe_battery ) << AP_BATT_FS_OFFSET ; ap_status |= ( uint8_t ) ( AP_Notify :: flags . ekf_bad ) << AP_EKF_FS_OFFSET ; ap_status |= imu_temp << AP_IMU_TEMP_OFFSET ; return ap_status ; } uint32_t AP_Frsky_Telem :: calc_home ( void ) { uint32_t home = 0 ; Location loc ; float _relative_home_altitude = 0 ; if ( _ahrs . get_position ( loc ) ) { const Location & home_loc = _ahrs . get_home ( ) ; if ( home_loc . lat != 0 || home_loc . lng != 0 ) { home = prep_number ( roundf ( get_distance ( home_loc , loc ) ) , 3 , 2 ) ; home |= ( ( ( uint8_t ) roundf ( get_bearing_cd ( loc , home_loc ) * 0.00333f ) ) & HOME_BEARING_LIMIT ) << HOME_BEARING_OFFSET ; } _relative_home_altitude = loc . alt ; if ( ! loc . flags . relative_alt ) { _relative_home_altitude -= _ahrs . get_home ( ) . alt ; } } home |= prep_number ( roundf ( _relative_home_altitude * 0.1f ) , 3 , 2 ) << HOME_ALT_OFFSET ; return home ; } uint32_t AP_Frsky_Telem :: calc_velandyaw ( void ) { uint32_t velandyaw ; Vector3f velNED { } ; _ahrs . get_velocity_NED ( velNED ) ; velandyaw = prep_number ( roundf ( - velNED . z * 10 ) , 2 , 1 ) ; const AP_Airspeed * aspeed = _ahrs . get_airspeed ( ) ; if ( aspeed && aspeed -> enabled ( ) ) { velandyaw |= prep_number ( roundf ( aspeed -> get_airspeed ( ) * 10 ) , 2 , 1 ) << VELANDYAW_XYVEL_OFFSET ; } else { velandyaw |= prep_number ( roundf ( _ahrs . groundspeed ( ) * 10 ) , 2 , 1 ) << VELANDYAW_XYVEL_OFFSET ; } velandyaw |= ( ( uint16_t ) roundf ( _ahrs . yaw_sensor * 0.05f ) & VELANDYAW_YAW_LIMIT ) << VELANDYAW_YAW_OFFSET ; return velandyaw ; } uint32_t AP_Frsky_Telem :: calc_attiandrng ( void ) { uint32_t attiandrng ; attiandrng = ( ( uint16_t ) roundf ( ( _ahrs . roll_sensor + 18000 ) * 0.05f ) & ATTIANDRNG_ROLL_LIMIT ) ; attiandrng |= ( ( uint16_t ) roundf ( ( _ahrs . pitch_sensor + 9000 ) * 0.05f ) & ATTIANDRNG_PITCH_LIMIT ) << ATTIANDRNG_PITCH_OFFSET ; attiandrng |= prep_number ( _rng . distance_cm_orient ( ROTATION_PITCH_270 ) , 3 , 1 ) << ATTIANDRNG_RNGFND_OFFSET ; return attiandrng ; } uint16_t AP_Frsky_Telem :: prep_number ( int32_t number , uint8_t digits , uint8_t power ) { uint16_t res = 0 ; uint32_t abs_number = abs ( number ) ; if ( ( digits == 2 ) && ( power == 1 ) ) { if ( abs_number < 100 ) { res = abs_number << 1 ; } else if ( abs_number < 1270 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.1f ) << 1 ) | 0x1 ; } else { res = 0xFF ; } if ( number < 0 ) { res |= 0x1 << 8 ; } } else if ( ( digits == 2 ) && ( power == 2 ) ) { if ( abs_number < 100 ) { res = abs_number << 2 ; } else if ( abs_number < 1000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.1f ) << 2 ) | 0x1 ; } else if ( abs_number < 10000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.01f ) << 2 ) | 0x2 ; } else if ( abs_number < 127000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.001f ) << 2 ) | 0x3 ; } else { res = 0x1FF ; } if ( number < 0 ) { res |= 0x1 << 9 ; } } else if ( ( digits == 3 ) && ( power == 1 ) ) { if ( abs_number < 1000 ) { res = abs_number << 1 ; } else if ( abs_number < 10240 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.1f ) << 1 ) | 0x1 ; } else { res = 0x7FF ; } if ( number < 0 ) { res |= 0x1 << 11 ; } } else if ( ( digits == 3 ) && ( power == 2 ) ) { if ( abs_number < 1000 ) { res = abs_number << 2 ; } else if ( abs_number < 10000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.1f ) << 2 ) | 0x1 ; } else if ( abs_number < 100000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.01f ) << 2 ) | 0x2 ; } else if ( abs_number < 1024000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.001f ) << 2 ) | 0x3 ; } else { res = 0xFFF ; } if ( number < 0 ) { res |= 0x1 << 12 ; } } return res ; } void AP_Frsky_Telem :: calc_nav_alt ( void ) { Location loc ; float current_height = 0 ; if ( _ahrs . get_position ( loc ) ) { current_height = loc . alt * 0.01f ; if ( ! loc . flags . relative_alt ) { current_height -= _ahrs . get_home ( ) . alt * 0.01f ; } } _gps . alt_nav_meters = ( int16_t ) current_height ; _gps . alt_nav_cm = ( current_height - _gps . alt_nav_meters ) * 100 ; } float AP_Frsky_Telem :: format_gps ( float dec ) { uint8_t dm_deg = ( uint8_t ) dec ; return ( dm_deg * 100.0f ) + ( dec - dm_deg ) * 60 ; } void AP_Frsky_Telem :: calc_gps_position ( void ) { float lat ; float lon ; float alt ; float speed ; if ( AP :: gps ( ) . status ( ) >= 3 ) { const Location & loc = AP :: gps ( ) . location ( ) ; lat = format_gps ( fabsf ( loc . lat / 10000000.0f ) ) ; _gps . latdddmm = lat ; _gps . latmmmm = ( lat - _gps . latdddmm ) * 10000 ; _gps . lat_ns = ( loc . lat < 0 ) ? ' S ' : ' N ' ; lon = format_gps ( fabsf ( loc . lng / 10000000.0f ) ) ; _gps . londddmm = lon ; _gps . lonmmmm = ( lon - _gps . londddmm ) * 10000 ; _gps . lon_ew = ( loc . lng < 0 ) ? ' W ' : ' E ' ; alt = loc . alt * 0.01f ; _gps . alt_gps_meters = ( int16_t ) alt ; _gps . alt_gps_cm = ( alt - _gps . alt_gps_meters ) * 100 ; speed = AP :: gps ( ) . ground_speed ( ) ; _gps . speed_in_meter = speed ; _gps . speed_in_centimeter = ( speed - _gps . speed_in_meter ) * 100 ; } else { _gps . latdddmm = 0 ; _gps . latmmmm = 0 ; _gps . lat_ns = 0 ; _gps . londddmm = 0 ; _gps . lonmmmm = 0 ; _gps . alt_gps_meters = 0 ; _gps . alt_gps_cm = 0 ; _gps . speed_in_meter = 0 ; _gps . speed_in_centimeter = 0 ; } } </DOCUMENT>
<DOCUMENT_ID="Eagle-X/folly/tree/master/folly/test/IPAddressBenchmark.cpp"> # include < folly / IPAddress . h > # include < glog / logging . h > # include < folly / Benchmark . h > using namespace folly ; using std :: string ; BENCHMARK ( ipv4_to_string_inet_ntop , iters ) { folly :: IPAddressV4 ipv4Addr ( "127.0.0.1" ) ; in_addr ip = ipv4Addr . toAddr ( ) ; char outputString [ INET_ADDRSTRLEN ] = { 0 } ; while ( iters -- ) { const char * val = inet_ntop ( AF_INET , & ip , outputString , sizeof ( outputString ) ) ; } } BENCHMARK_RELATIVE ( ipv4_to_fully_qualified , iters ) { IPAddressV4 ip ( "127.0.0.1" ) ; while ( iters -- ) { string outputString = ip . toFullyQualified ( ) ; } } BENCHMARK_DRAW_LINE ( ) BENCHMARK ( ipv6_to_string_inet_ntop , iters ) { IPAddressV6 ipv6Addr ( " F1E0:0ACE : FB94:7ADF : 22E8:6DE6:9672:3725" ) ; in6_addr ip = ipv6Addr . toAddr ( ) ; char outputString [ INET6_ADDRSTRLEN ] = { 0 } ; bool checkResult = ( iters == 1 ) ; while ( iters -- ) { const char * val = inet_ntop ( AF_INET6 , & ip , outputString , sizeof ( outputString ) ) ; } } BENCHMARK_RELATIVE ( ipv6_to_fully_qualified , iters ) { IPAddressV6 ip ( " F1E0:0ACE : FB94:7ADF : 22E8:6DE6:9672:3725" ) ; string outputString ; while ( iters -- ) { outputString = ip . toFullyQualified ( ) ; } } int main ( int argc , char * argv [ ] ) { gflags :: ParseCommandLineFlags ( & argc , & argv , true ) ; runBenchmarks ( ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="eugene1g/phantomjs/tree/master/src/qt/qtbase/src/corelib/doc/snippets/code/src_corelib_io_qfile.cpp"> QFile file ; QDir :: setCurrent ( " / tmp " ) ; file . setFileName ( " readme . txt " ) ; QDir :: setCurrent ( " / home " ) ; file . open ( QIODevice :: ReadOnly ) ; QByteArray myEncoderFunc ( const QString & fileName ) ; QString myDecoderFunc ( const QByteArray & localFileName ) ; # include < stdio . h > void printError ( const char * msg ) { QFile file ; file . open ( stderr , QIODevice :: WriteOnly ) ; file . write ( msg , qstrlen ( msg ) ) ; file . close ( ) ; } CONFIG += console </DOCUMENT>
<DOCUMENT_ID="mantidproject/cxxtest/tree/master/cxxtest/TestTracker.cpp"> # ifndef __cxxtest__TestTracker_cpp__ # define __cxxtest__TestTracker_cpp__ # include < cxxtest / TestTracker . h > namespace CxxTest { bool TestTracker :: _created = false ; bool TestTracker :: print_tracing = false ; TestTracker :: TestTracker ( ) { if ( ! _created ) { initialize ( ) ; setListener ( 0 ) ; _created = true ; } } TestTracker :: ~ TestTracker ( ) { } TestTracker & TestTracker :: tracker ( ) { static TestTracker theTracker ; return theTracker ; } void TestTracker :: initialize ( ) { _warnings = 0 ; _skippedTests = 0 ; _testSkipped = false ; _failedTests = 0 ; _testFailedAsserts = 0 ; _suiteFailedTests = 0 ; _failedSuites = 0 ; _world = 0 ; _suite = 0 ; _test = 0 ; } const TestDescription * TestTracker :: fixTest ( const TestDescription * d ) const { return d ? d : & dummyTest ( ) ; } const SuiteDescription * TestTracker :: fixSuite ( const SuiteDescription * d ) const { return d ? d : & dummySuite ( ) ; } const WorldDescription * TestTracker :: fixWorld ( const WorldDescription * d ) const { return d ? d : & dummyWorld ( ) ; } const TestDescription & TestTracker :: dummyTest ( ) const { return dummySuite ( ) . testDescription ( 0 ) ; } const SuiteDescription & TestTracker :: dummySuite ( ) const { return dummyWorld ( ) . suiteDescription ( 0 ) ; } const WorldDescription & TestTracker :: dummyWorld ( ) const { return _dummyWorld ; } void TestTracker :: setListener ( TestListener * l ) { _l = l ? l : & _dummyListener ; } void TestTracker :: enterWorld ( const WorldDescription & wd ) { setWorld ( & wd ) ; _warnings = _skippedTests = _failedTests = _testFailedAsserts = _suiteFailedTests = _failedSuites = 0 ; _testSkipped = false ; _l -> enterWorld ( wd ) ; } void TestTracker :: enterSuite ( const SuiteDescription & sd ) { setSuite ( & sd ) ; _testFailedAsserts = _suiteFailedTests = 0 ; _testSkipped = false ; _l -> enterSuite ( sd ) ; } void TestTracker :: enterTest ( const TestDescription & td ) { setTest ( & td ) ; _testFailedAsserts = false ; _testSkipped = false ; _l -> enterTest ( td ) ; } void TestTracker :: leaveTest ( const TestDescription & td ) { _l -> leaveTest ( td ) ; setTest ( 0 ) ; } void TestTracker :: leaveSuite ( const SuiteDescription & sd ) { _l -> leaveSuite ( sd ) ; setSuite ( 0 ) ; } void TestTracker :: leaveWorld ( const WorldDescription & wd ) { _l -> leaveWorld ( wd ) ; setWorld ( 0 ) ; } void TestTracker :: trace ( const char * file , int line , const char * expression ) { _l -> trace ( file , line , expression ) ; } void TestTracker :: warning ( const char * file , int line , const char * expression ) { countWarning ( ) ; _l -> warning ( file , line , expression ) ; } void TestTracker :: skippedTest ( const char * file , int line , const char * expression ) { countSkipped ( ) ; _testSkipped = true ; _l -> skippedTest ( file , line , expression ) ; } void TestTracker :: failedTest ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedTest ( file , line , expression ) ; } void TestTracker :: failedAssert ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedAssert ( file , line , expression ) ; } void TestTracker :: failedAssertEquals ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertEquals ( file , line , xStr , yStr , x , y ) ; } void TestTracker :: failedAssertSameData ( const char * file , int line , const char * xStr , const char * yStr , const char * sizeStr , const void * x , const void * y , unsigned size ) { countFailure ( ) ; _l -> failedAssertSameData ( file , line , xStr , yStr , sizeStr , x , y , size ) ; } void TestTracker :: failedAssertDelta ( const char * file , int line , const char * xStr , const char * yStr , const char * dStr , const char * x , const char * y , const char * d ) { countFailure ( ) ; _l -> failedAssertDelta ( file , line , xStr , yStr , dStr , x , y , d ) ; } void TestTracker :: failedAssertDiffers ( const char * file , int line , const char * xStr , const char * yStr , const char * value ) { countFailure ( ) ; _l -> failedAssertDiffers ( file , line , xStr , yStr , value ) ; } void TestTracker :: failedAssertLessThan ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertLessThan ( file , line , xStr , yStr , x , y ) ; } void TestTracker :: failedAssertLessThanEquals ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertLessThanEquals ( file , line , xStr , yStr , x , y ) ; } void TestTracker :: failedAssertPredicate ( const char * file , int line , const char * predicate , const char * xStr , const char * x ) { countFailure ( ) ; _l -> failedAssertPredicate ( file , line , predicate , xStr , x ) ; } void TestTracker :: failedAssertRelation ( const char * file , int line , const char * relation , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertRelation ( file , line , relation , xStr , yStr , x , y ) ; } void TestTracker :: failedAssertThrows ( const char * file , int line , const char * expression , const char * type , bool otherThrown ) { countFailure ( ) ; _l -> failedAssertThrows ( file , line , expression , type , otherThrown ) ; } void TestTracker :: failedAssertThrowsNot ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedAssertThrowsNot ( file , line , expression ) ; } void TestTracker :: failedAssertSameFiles ( const char * file , int line , const char * file1 , const char * file2 , const char * explanation ) { countFailure ( ) ; _l -> failedAssertSameFiles ( file , line , file1 , file2 , explanation ) ; } void TestTracker :: setWorld ( const WorldDescription * w ) { _world = fixWorld ( w ) ; setSuite ( 0 ) ; } void TestTracker :: setSuite ( const SuiteDescription * s ) { _suite = fixSuite ( s ) ; setTest ( 0 ) ; } void TestTracker :: setTest ( const TestDescription * t ) { _test = fixTest ( t ) ; } void TestTracker :: countWarning ( ) { ++ _warnings ; } void TestTracker :: countSkipped ( ) { ++ _skippedTests ; } void TestTracker :: countFailure ( ) { if ( ++ _testFailedAsserts == 1 ) { ++ _failedTests ; if ( ++ _suiteFailedTests == 1 ) { ++ _failedSuites ; } } } } # endif </DOCUMENT>
<DOCUMENT_ID="domin1101/malmo-challenge/tree/master/cpp/src/main.cpp"> # include " LightBulbApp / App . hpp " # include < wx / wxprec . h > # include " PigChase / PigChaseEvolution . hpp " # include " PigChase / TensorflowExporter . hpp " int main ( int argc , char * * argv ) { LightBulb :: App * app = new LightBulb :: App ( ) ; app -> addTrainingPlan ( new PigChaseEvolution ( ) ) ; app -> addExporter ( new TensorflowExporter ( ) ) ; wxApp :: SetInstance ( app ) ; wxEntry ( argc , argv ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="SuperHex/psychic-aero/tree/master/base/HAL.cpp"> # ifndef __HAL__ # define __HAL__ # include . . / config / config . h # include < avr / io . h > namespace base { template < class init_traits , class rw_traits > struct hal { typedef init_traits I ; typedef rw_traits RW ; public : hal ( ) { I :: init ( ) ; } virtual ~ hal ( ) ; virtual void write ( const unsigned char data ) { RW :: write ( data ) ; } virtual unsigned char read ( ) { return RW :: read ( ) ; } } ; struct skip_init { static void init ( ) { } } ; struct USART_default_init { static void init ( const long baudRate ) { long ubrr = F_CPU / 16 / baudRate - 1 ; UBRR0H = ubrr >> 8 ; UBRR0L = ubrr ; UCSR0B = ( 1 << RXEN0 ) | ( 1 << TXEN0 ) ; UCSR0C = ( 3 << UCSZ00 ) ; } } ; struct USART_8N1_RW { public : static void write ( const unsigned char data ) { while ( ! ( UCSR0A & ( 1 << UDRE0 ) ) ) ; UDR0 = data ; } static unsigned char read ( ) { while ( ! ( UCSR0A & ( 1 << RXC0 ) ) ) ; return UDR0 ; } } ; struct SPI_RW { static void write ( unsigned char data ) { SPDR = data ; while ( ! ( SPSR & ( 1 << SPIF ) ) ) ; } static unsigned char read ( ) { while ( ! ( SPSR & ( 1 << SPIF ) ) ) ; return SPDR ; } } ; struct SPI_master_init { static void init ( ) { DDRB |= ( 1 << PB3 ) | ( 1 << PB5 ) | ( 1 << PB2 ) ; SPCR = ( 1 << SPE ) | ( 1 << MSTR ) | ( 1 << SPR0 ) ; } } ; struct SPI_slave_init { static void init ( ) { DDRB |= ( 1 << PB4 ) ; SPCR = ( 1 << SPE ) ; } } ; template < class T = USART_default_init > struct USART : public hal < skip_init , USART_8N1_RW > { public : USART ( const long Rate ) { T :: init ( Rate ) ; } virtual ~ USART ( ) ; } ; typedef USART < > Serial ; template < class T > struct SPI : public hal < T , SPI_RW > { } ; typedef SPI < SPI_master_init > SPIMaster ; typedef SPI < SPI_slave_init > SPISlave ; } # endif </DOCUMENT>
<DOCUMENT_ID="peak3d/inputstream.adaptive/tree/master/lib/libbento4/Core/Ap4.cpp"> # include " Ap4 . h " static AP4 AP4_LoaderCheck ; AP4 :: AP4 ( ) : m_ConstructedByLoader ( true ) { } AP4_Result AP4 :: Initialize ( ) { AP4_Result result = AP4_SUCCESS ; # if defined ( AP4_CONFIG_CONSTRUCT_STATICS_ON_INITIALIZE ) if ( ! AP4_DefaultAtomFactory :: Instance . m_Initialized ) { result = AP4_DefaultAtomFactory :: Instance . Initialize ( ) ; if ( AP4_FAILED ( result ) ) return result ; } if ( ! AP4_DefaultBlockCipherFactory :: Instance . m_Initialized ) { result = AP4_DefaultBlockCipherFactory :: Instance . Initialize ( ) ; if ( AP4_FAILED ( result ) ) return result ; } if ( ! AP4_MetaData :: Initialized ( ) ) { AP4_MetaData :: Initialize ( ) ; } # endif return result ; } AP4_Result AP4 :: Terminate ( ) { # if defined ( AP4_CONFIG_DESTRUCT_STATICS_ON_TERMINATE ) if ( ! AP4_LoaderCheck . m_ConstructedByLoader ) { if ( AP4_DefaultAtomFactory :: Instance . m_Initialized ) { AP4_DefaultAtomFactory :: Instance . ~ AP4_DefaultAtomFactory ( ) ; } if ( AP4_DefaultBlockCipherFactory :: Instance . m_Initialized ) { AP4_DefaultBlockCipherFactory :: Instance . ~ AP4_DefaultBlockCipherFactory ( ) ; } if ( AP4_MetaData :: Initialized ( ) ) { AP4_MetaData :: UnInitialize ( ) ; } } # endif return AP4_SUCCESS ; } </DOCUMENT>
<DOCUMENT_ID="xhochy/arrow/tree/master/ruby/red-arrow/ext/arrow/raw-records.cpp"> # include " converters . hpp " namespace red_arrow { namespace { class RawRecordsBuilder : private Converter , public arrow :: ArrayVisitor { public : explicit RawRecordsBuilder ( VALUE records , int n_columns ) : Converter ( ) , records_ ( records ) , n_columns_ ( n_columns ) { } void build ( const arrow :: RecordBatch & record_batch ) { rb :: protect ( [ & ] { const auto n_rows = record_batch . num_rows ( ) ; for ( int64_t i = 0 ; i < n_rows ; ++ i ) { auto record = rb_ary_new_capa ( n_columns_ ) ; rb_ary_push ( records_ , record ) ; } row_offset_ = 0 ; for ( int i = 0 ; i < n_columns_ ; ++ i ) { const auto array = record_batch . column ( i ) . get ( ) ; column_index_ = i ; check_status ( array -> Accept ( this ) , " [ record - batch ] [ raw - records ] " ) ; } return Qnil ; } ) ; } void build ( const arrow :: Table & table ) { rb :: protect ( [ & ] { const auto n_rows = table . num_rows ( ) ; for ( int64_t i = 0 ; i < n_rows ; ++ i ) { auto record = rb_ary_new_capa ( n_columns_ ) ; rb_ary_push ( records_ , record ) ; } for ( int i = 0 ; i < n_columns_ ; ++ i ) { const auto & chunked_array = table . column ( i ) . get ( ) ; column_index_ = i ; row_offset_ = 0 ; for ( const auto array : chunked_array -> chunks ( ) ) { check_status ( array -> Accept ( this ) , " [ table ] [ raw - records ] " ) ; row_offset_ += array -> length ( ) ; } } return Qnil ; } ) ; } # define VISIT ( TYPE ) arrow :: Status Visit ( const arrow :: TYPE ## Array & array ) override { convert ( array ) ; return arrow :: Status :: OK ( ) ; } VISIT ( Null ) VISIT ( Boolean ) VISIT ( Int8 ) VISIT ( Int16 ) VISIT ( Int32 ) VISIT ( Int64 ) VISIT ( UInt8 ) VISIT ( UInt16 ) VISIT ( UInt32 ) VISIT ( UInt64 ) VISIT ( Float ) VISIT ( Double ) VISIT ( Binary ) VISIT ( String ) VISIT ( FixedSizeBinary ) VISIT ( Date32 ) VISIT ( Date64 ) VISIT ( Time32 ) VISIT ( Time64 ) VISIT ( Timestamp ) VISIT ( List ) VISIT ( Struct ) VISIT ( Union ) VISIT ( Dictionary ) VISIT ( Decimal128 ) # undef VISIT private : template < typename ArrayType > void convert ( const ArrayType & array ) { const auto n = array . length ( ) ; if ( array . null_count ( ) > 0 ) { for ( int64_t i = 0 , ii = row_offset_ ; i < n ; ++ i , ++ ii ) { auto value = Qnil ; if ( ! array . IsNull ( i ) ) { value = convert_value ( array , i ) ; } auto record = rb_ary_entry ( records_ , ii ) ; rb_ary_store ( record , column_index_ , value ) ; } } else { for ( int64_t i = 0 , ii = row_offset_ ; i < n ; ++ i , ++ ii ) { auto record = rb_ary_entry ( records_ , ii ) ; rb_ary_store ( record , column_index_ , convert_value ( array , i ) ) ; } } } VALUE records_ ; int column_index_ ; int64_t row_offset_ ; const int n_columns_ ; } ; } VALUE record_batch_raw_records ( VALUE rb_record_batch ) { auto garrow_record_batch = GARROW_RECORD_BATCH ( RVAL2GOBJ ( rb_record_batch ) ) ; auto record_batch = garrow_record_batch_get_raw ( garrow_record_batch ) . get ( ) ; const auto n_rows = record_batch -> num_rows ( ) ; const auto n_columns = record_batch -> num_columns ( ) ; auto records = rb_ary_new_capa ( n_rows ) ; try { RawRecordsBuilder builder ( records , n_columns ) ; builder . build ( * record_batch ) ; } catch ( rb :: State & state ) { state . jump ( ) ; } return records ; } VALUE table_raw_records ( VALUE rb_table ) { auto garrow_table = GARROW_TABLE ( RVAL2GOBJ ( rb_table ) ) ; auto table = garrow_table_get_raw ( garrow_table ) . get ( ) ; const auto n_rows = table -> num_rows ( ) ; const auto n_columns = table -> num_columns ( ) ; auto records = rb_ary_new_capa ( n_rows ) ; try { RawRecordsBuilder builder ( records , n_columns ) ; builder . build ( * table ) ; } catch ( rb :: State & state ) { state . jump ( ) ; } return records ; } } </DOCUMENT>
<DOCUMENT_ID="BillHally/boo/tree/master/lib/antlr-2.7.5/lib/cpp/src/TreeParser.cpp"> # include < iostream > # include " antlr / TreeParser . hpp " # include " antlr / ASTNULLType . hpp " # ifdef ANTLR_CXX_SUPPORTS_NAMESPACE namespace antlr { # endif RefAST TreeParser :: ASTNULL ( new ASTNULLType ) ; void TreeParser :: reportError ( const RecognitionException & ex ) { ANTLR_USE_NAMESPACE ( std ) cerr << ex . toString ( ) . c_str ( ) << ANTLR_USE_NAMESPACE ( std ) endl ; } void TreeParser :: reportError ( const ANTLR_USE_NAMESPACE ( std ) string & s ) { ANTLR_USE_NAMESPACE ( std ) cerr << " error : ▁ " << s . c_str ( ) << ANTLR_USE_NAMESPACE ( std ) endl ; } void TreeParser :: reportWarning ( const ANTLR_USE_NAMESPACE ( std ) string & s ) { ANTLR_USE_NAMESPACE ( std ) cerr << " warning : ▁ " << s . c_str ( ) << ANTLR_USE_NAMESPACE ( std ) endl ; } void TreeParser :: traceIndent ( ) { for ( int i = 0 ; i < traceDepth ; i ++ ) ANTLR_USE_NAMESPACE ( std ) cout << " ▁ " ; } void TreeParser :: traceIn ( const char * rname , RefAST t ) { traceDepth ++ ; traceIndent ( ) ; ANTLR_USE_NAMESPACE ( std ) cout << " > ▁ " << rname << " ( " << ( t ? t -> toString ( ) . c_str ( ) : " null " ) << " ) " << ( ( inputState -> guessing > 0 ) ? " ▁ [ guessing ] " : " " ) << ANTLR_USE_NAMESPACE ( std ) endl ; } void TreeParser :: traceOut ( const char * rname , RefAST t ) { traceIndent ( ) ; ANTLR_USE_NAMESPACE ( std ) cout << " < ▁ " << rname << " ( " << ( t ? t -> toString ( ) . c_str ( ) : " null " ) << " ) " << ( ( inputState -> guessing > 0 ) ? " ▁ [ guessing ] " : " " ) << ANTLR_USE_NAMESPACE ( std ) endl ; traceDepth -- ; } # ifdef ANTLR_CXX_SUPPORTS_NAMESPACE } # endif </DOCUMENT>
<DOCUMENT_ID="ricardogsilva/QGIS/tree/master/src/core/qgsproxyprogresstask.cpp"> # include " qgsproxyprogresstask . h " QgsProxyProgressTask :: QgsProxyProgressTask ( const QString & description ) : QgsTask ( description , QgsTask :: Flags ( ) ) { } void QgsProxyProgressTask :: finalize ( bool result ) { mResult = result ; mNotFinishedWaitCondition . wakeAll ( ) ; } bool QgsProxyProgressTask :: run ( ) { mNotFinishedMutex . lock ( ) ; mNotFinishedWaitCondition . wait ( & mNotFinishedMutex ) ; mNotFinishedMutex . unlock ( ) ; return mResult ; } void QgsProxyProgressTask :: setProxyProgress ( double progress ) { QMetaObject :: invokeMethod ( this , " setProgress " , Qt :: AutoConnection , Q_ARG ( double , progress ) ) ; } QgsScopedProxyProgressTask :: QgsScopedProxyProgressTask ( const QString & description ) : mTask ( new QgsProxyProgressTask ( description ) ) { QgsApplication :: taskManager ( ) -> addTask ( mTask ) ; } QgsScopedProxyProgressTask :: ~ QgsScopedProxyProgressTask ( ) { mTask -> finalize ( true ) ; } void QgsScopedProxyProgressTask :: setProgress ( double progress ) { mTask -> setProxyProgress ( progress ) ; } </DOCUMENT>
<DOCUMENT_ID="braindx/scummvm/tree/master/engines/titanic/gfx/icon_nav_receive.cpp"> # include " titanic / gfx / icon _ nav _ receive . h " namespace Titanic { EMPTY_MESSAGE_MAP ( CIconNavReceive , CPetGraphic ) ; void CIconNavReceive :: save ( SimpleFile * file , int indent ) { file -> writeNumberLine ( 1 , indent ) ; CPetGraphic :: save ( file , indent ) ; } void CIconNavReceive :: load ( SimpleFile * file ) { file -> readNumber ( ) ; CPetGraphic :: load ( file ) ; } } </DOCUMENT>
<DOCUMENT_ID="kingvuplus/enigma2/tree/master/lib/gui/einputstring.cpp"> # include < lib / gui / einputstring . h > DEFINE_REF ( eInputContentString ) ; eInputContentString :: eInputContentString ( ) { m_string = " bla " ; m_cursor = 0 ; m_input = 0 ; m_len = m_string . size ( ) ; } void eInputContentString :: getDisplay ( std :: string & res , int & cursor ) { res = m_string ; cursor = m_cursor ; } void eInputContentString :: moveCursor ( int dir ) { int old_cursor = m_cursor ; switch ( dir ) { case dirLeft : -- m_cursor ; break ; case dirRight : ++ m_cursor ; break ; case dirHome : m_cursor = 0 ; break ; case dirEnd : m_cursor = m_len ; break ; } if ( m_cursor < 0 ) m_cursor = 0 ; if ( m_cursor > m_len ) m_cursor = m_len ; if ( m_cursor != old_cursor ) if ( m_input ) m_input -> invalidate ( ) ; } int eInputContentString :: haveKey ( int code , int overwrite ) { int have_char = - 1 ; if ( code >= 0x8020 ) have_char = code & ~ 0x8000 ; if ( have_char != - 1 ) { if ( overwrite && m_cursor < m_len ) m_string [ m_cursor ] = have_char ; else { m_string . insert ( m_cursor , 1 , have_char ) ; ++ m_len ; } m_cursor ++ ; ASSERT ( m_cursor <= m_len ) ; if ( m_input ) m_input -> invalidate ( ) ; return 1 ; } return 0 ; } void eInputContentString :: deleteChar ( int dir ) { if ( dir == deleteForward ) { eDebug ( " forward " ) ; if ( m_cursor != m_len ) ++ m_cursor ; else return ; } if ( ! m_cursor ) return ; if ( ! m_len ) return ; m_string . erase ( m_cursor - 1 , m_cursor ) ; m_len -- ; m_cursor -- ; if ( m_input ) m_input -> invalidate ( ) ; } int eInputContentString :: isValid ( ) { return 1 ; } void eInputContentString :: validate ( ) { } void eInputContentString :: setText ( const std :: string & str ) { m_string = str ; m_len = m_string . size ( ) ; if ( m_cursor > m_len ) m_cursor = m_len ; if ( m_input ) m_input -> invalidate ( ) ; } std :: string eInputContentString :: getText ( ) { return m_string ; } </DOCUMENT>
<DOCUMENT_ID="ichu501/WinObjC/tree/master/deps/3rdparty/icu/icu/source/test/intltest/tsmthred.cpp"> # if defined ( hpux ) # ifndef _INCLUDE_POSIX_SOURCE # define _INCLUDE_POSIX_SOURCE # endif # endif # include " simplethread . h " # include " unicode / utypes . h " # include " unicode / ustring . h " # include " umutex . h " # include " cmemory . h " # include " cstring . h " # include " uparse . h " # include " unicode / localpointer . h " # include " unicode / resbund . h " # include " unicode / udata . h " # include " unicode / uloc . h " # include " unicode / locid . h " # include " putilimp . h " # include " intltest . h " # include " tsmthred . h " # include " unicode / ushape . h " # include " unicode / translit . h " # include " sharedobject . h " # include " unifiedcache . h " # include " uassert . h " # if U_PLATFORM_USES_ONLY_WIN32_API # undef POSIX # elif U_PLATFORM_IMPLEMENTS_POSIX # define POSIX # else # undef POSIX # endif # if U_PLATFORM == U_PF_OS390 # define __DOT1 1 # define __UU # ifndef _XPG4_2 # define _XPG4_2 # endif # include < unistd . h > # endif # if defined ( POSIX ) # define HAVE_IMP # if ( ICU_USE_THREADS == 1 ) # include < pthread . h > # endif # if defined ( __hpux ) && defined ( HPUX_CMA ) # if defined ( read ) # undef read # endif # endif # ifndef __EXTENSIONS__ # define __EXTENSIONS__ # endif # if U_PLATFORM == U_PF_OS390 # include < sys / types . h > # endif # if U_PLATFORM != U_PF_OS390 # include < signal . h > # endif # ifndef _XPG4_2 # define _XPG4_2 # endif # ifndef __USE_XOPEN_EXTENDED # define __USE_XOPEN_EXTENDED # endif # ifndef _INCLUDE_XOPEN_SOURCE_EXTENDED # define _INCLUDE_XOPEN_SOURCE_EXTENDED # endif # include < unistd . h > # endif # ifdef sleep # undef sleep # endif # define TSMTHREAD_FAIL ( msg ) errln ( " % s ▁ at ▁ file ▁ % s , ▁ line ▁ % d " , msg , __FILE__ , __LINE__ ) # define TSMTHREAD_ASSERT ( expr ) { if ( ! ( expr ) ) { TSMTHREAD_FAIL ( " Fail " ) ; } } MultithreadTest :: MultithreadTest ( ) { } MultithreadTest :: ~ MultithreadTest ( ) { } # if ( ICU_USE_THREADS == 0 ) void MultithreadTest :: runIndexedTest ( int32_t index , UBool exec , const char * & name , char * ) { if ( exec ) logln ( " TestSuite ▁ MultithreadTest : ▁ " ) ; if ( index == 0 ) name = " NO _ THREADED _ TESTS " ; else name = " " ; if ( exec ) { logln ( " MultithreadTest ▁ - ▁ test ▁ DISABLED . ▁ ▁ ICU _ USE _ THREADS ▁ set ▁ to ▁ 0 , ▁ check ▁ your ▁ configuration ▁ if ▁ this ▁ is ▁ a ▁ problem . . " ) ; } } # else # include < stdio . h > # include < string . h > # include < ctype . h > # include " unicode / putil . h " # include " unicode / numfmt . h " # include " unicode / choicfmt . h " # include " unicode / msgfmt . h " # include " unicode / locid . h " # include " unicode / coll . h " # include " unicode / calendar . h " # include " ucaconf . h " void SimpleThread :: errorFunc ( ) { } void MultithreadTest :: runIndexedTest ( int32_t index , UBool exec , const char * & name , char * ) { if ( exec ) logln ( " TestSuite ▁ MultithreadTest : ▁ " ) ; switch ( index ) { case 0 : name = " TestThreads " ; if ( exec ) TestThreads ( ) ; break ; case 1 : name = " TestMutex " ; if ( exec ) TestMutex ( ) ; break ; case 2 : name = " TestThreadedIntl " ; # if ! UCONFIG_NO_FORMATTING if ( exec ) { TestThreadedIntl ( ) ; } # endif break ; case 3 : name = " TestCollators " ; # if ! UCONFIG_NO_COLLATION if ( exec ) { TestCollators ( ) ; } # endif break ; case 4 : name = " TestString " ; if ( exec ) { TestString ( ) ; } break ; case 5 : name = " TestArabicShapingThreads " ; if ( exec ) { TestArabicShapingThreads ( ) ; } break ; case 6 : name = " TestAnyTranslit " ; if ( exec ) { TestAnyTranslit ( ) ; } break ; case 7 : name = " TestConditionVariables " ; if ( exec ) { TestConditionVariables ( ) ; } break ; case 8 : name = " TestUnifiedCache " ; if ( exec ) { TestUnifiedCache ( ) ; } break ; default : name = " " ; break ; } } # define THREADTEST_NRTHREADS 8 # define ARABICSHAPE_THREADTEST 30 class TestThreadsThread : public SimpleThread { public : TestThreadsThread ( char * whatToChange ) { fWhatToChange = whatToChange ; } virtual void run ( ) { SimpleThread :: sleep ( 1000 ) ; Mutex m ; * fWhatToChange = ' * ' ; } private : char * fWhatToChange ; } ; class TestArabicShapeThreads : public SimpleThread { public : TestArabicShapeThreads ( char * whatToChange ) { fWhatToChange = whatToChange ; } virtual void run ( ) { if ( doTailTest ( ) == TRUE ) * fWhatToChange = ' * ' ; } private : char * fWhatToChange ; UBool doTailTest ( void ) { static const UChar src [ ] = { 0x0020 , 0x0633 , 0 } ; static const UChar dst_old [ ] = { 0xFEB1 , 0x200B , 0 } ; static const UChar dst_new [ ] = { 0xFEB1 , 0xFE73 , 0 } ; UChar dst [ 3 ] = { 0x0000 , 0x0000 , 0 } ; int32_t length ; UErrorCode status ; IntlTest inteltst = IntlTest ( ) ; status = U_ZERO_ERROR ; length = u_shapeArabic ( src , - 1 , dst , UPRV_LENGTHOF ( dst ) , U_SHAPE_LETTERS_SHAPE | U_SHAPE_SEEN_TWOCELL_NEAR , & status ) ; if ( U_FAILURE ( status ) ) { inteltst . errln ( " Fail : ▁ status ▁ % s \n " , u_errorName ( status ) ) ; return FALSE ; } else if ( length != 2 ) { inteltst . errln ( " Fail : ▁ len ▁ % d ▁ expected ▁ 3 \n " , length ) ; return FALSE ; } else if ( u_strncmp ( dst , dst_old , UPRV_LENGTHOF ( dst ) ) ) { inteltst . errln ( " Fail : ▁ got ▁ U + % 04X ▁ U + % 04X ▁ expected ▁ U + % 04X ▁ U + % 04X \n " , dst [ 0 ] , dst [ 1 ] , dst_old [ 0 ] , dst_old [ 1 ] ) ; return FALSE ; } status = U_ZERO_ERROR ; length = u_shapeArabic ( src , - 1 , dst , UPRV_LENGTHOF ( dst ) , U_SHAPE_LETTERS_SHAPE | U_SHAPE_SEEN_TWOCELL_NEAR | U_SHAPE_TAIL_NEW_UNICODE , & status ) ; if ( U_FAILURE ( status ) ) { inteltst . errln ( " Fail : ▁ status ▁ % s \n " , u_errorName ( status ) ) ; return FALSE ; } else if ( length != 2 ) { inteltst . errln ( " Fail : ▁ len ▁ % d ▁ expected ▁ 3 \n " , length ) ; return FALSE ; } else if ( u_strncmp ( dst , dst_new , UPRV_LENGTHOF ( dst ) ) ) { inteltst . errln ( " Fail : ▁ got ▁ U + % 04X ▁ U + % 04X ▁ expected ▁ U + % 04X ▁ U + % 04X \n " , dst [ 0 ] , dst [ 1 ] , dst_new [ 0 ] , dst_new [ 1 ] ) ; return FALSE ; } return TRUE ; } } ; void MultithreadTest :: TestThreads ( ) { char threadTestChars [ THREADTEST_NRTHREADS + 1 ] ; SimpleThread * threads [ THREADTEST_NRTHREADS ] ; int32_t numThreadsStarted = 0 ; int32_t i ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { threadTestChars [ i ] = ' ▁ ' ; threads [ i ] = new TestThreadsThread ( & threadTestChars [ i ] ) ; } threadTestChars [ THREADTEST_NRTHREADS ] = ' \0' ; logln ( " - > " + UnicodeString ( threadTestChars ) + " < - ▁ Firing ▁ off ▁ threads . . ▁ " ) ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { if ( threads [ i ] -> start ( ) != 0 ) { errln ( " Error ▁ starting ▁ thread ▁ % d " , i ) ; } else { numThreadsStarted ++ ; } SimpleThread :: sleep ( 100 ) ; logln ( " ▁ Subthread ▁ started . " ) ; } logln ( " Waiting ▁ for ▁ threads ▁ to ▁ be ▁ set . . " ) ; if ( numThreadsStarted == 0 ) { errln ( " No ▁ threads ▁ could ▁ be ▁ started ▁ for ▁ testing ! " ) ; return ; } int32_t patience = 40 ; while ( patience -- ) { int32_t count = 0 ; umtx_lock ( NULL ) ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { if ( threadTestChars [ i ] == ' * ' ) { count ++ ; } } umtx_unlock ( NULL ) ; if ( count == THREADTEST_NRTHREADS ) { logln ( " - > " + UnicodeString ( threadTestChars ) + " < - ▁ Got ▁ all ▁ threads ! ▁ cya " ) ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { delete threads [ i ] ; } return ; } logln ( " - > " + UnicodeString ( threadTestChars ) + " < - ▁ Waiting . . " ) ; SimpleThread :: sleep ( 500 ) ; } errln ( " - > " + UnicodeString ( threadTestChars ) + " < - ▁ PATIENCE ▁ EXCEEDED ! ! ▁ Still ▁ missing ▁ some . " ) ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { delete threads [ i ] ; } } void MultithreadTest :: TestArabicShapingThreads ( ) { char threadTestChars [ ARABICSHAPE_THREADTEST + 1 ] ; SimpleThread * threads [ ARABICSHAPE_THREADTEST ] ; int32_t numThreadsStarted = 0 ; int32_t i ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { threadTestChars [ i ] = ' ▁ ' ; threads [ i ] = new TestArabicShapeThreads ( & threadTestChars [ i ] ) ; } threadTestChars [ ARABICSHAPE_THREADTEST ] = ' \0' ; logln ( " - > ▁ do ▁ TestArabicShapingThreads ▁ < - ▁ Firing ▁ off ▁ threads . . ▁ " ) ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { if ( threads [ i ] -> start ( ) != 0 ) { errln ( " Error ▁ starting ▁ thread ▁ % d " , i ) ; } else { numThreadsStarted ++ ; } logln ( " ▁ Subthread ▁ started . " ) ; } logln ( " Waiting ▁ for ▁ threads ▁ to ▁ be ▁ set . . " ) ; if ( numThreadsStarted == 0 ) { errln ( " No ▁ threads ▁ could ▁ be ▁ started ▁ for ▁ testing ! " ) ; return ; } int32_t patience = 100 ; while ( patience -- ) { int32_t count = 0 ; umtx_lock ( NULL ) ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { if ( threadTestChars [ i ] == ' * ' ) { count ++ ; } } umtx_unlock ( NULL ) ; if ( count == ARABICSHAPE_THREADTEST ) { logln ( " - > TestArabicShapingThreads ▁ < - ▁ Got ▁ all ▁ threads ! ▁ cya " ) ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { delete threads [ i ] ; } return ; } logln ( " - > ▁ TestArabicShapingThreads ▁ < - ▁ Waiting . . " ) ; SimpleThread :: sleep ( 500 ) ; } errln ( " - > ▁ TestArabicShapingThreads ▁ < - ▁ PATIENCE ▁ EXCEEDED ! ! ▁ Still ▁ missing ▁ some . " ) ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { delete threads [ i ] ; } } static UMutex gTestMutexA = U_MUTEX_INITIALIZER ; static UMutex gTestMutexB = U_MUTEX_INITIALIZER ; static int gThreadsStarted = 0 ; static int gThreadsInMiddle = 0 ; static int gThreadsDone = 0 ; static const int TESTMUTEX_THREAD_COUNT = 4 ; static int safeIncr ( int & var , int amt ) { Mutex m ; var += amt ; return var ; } class TestMutexThread : public SimpleThread { public : virtual void run ( ) { safeIncr ( gThreadsStarted , 1 ) ; umtx_lock ( & gTestMutexA ) ; umtx_unlock ( & gTestMutexA ) ; safeIncr ( gThreadsInMiddle , 1 ) ; umtx_lock ( & gTestMutexB ) ; umtx_unlock ( & gTestMutexB ) ; safeIncr ( gThreadsDone , 1 ) ; } } ; void MultithreadTest :: TestMutex ( ) { gThreadsStarted = 0 ; gThreadsInMiddle = 0 ; gThreadsDone = 0 ; umtx_lock ( & gTestMutexA ) ; TestMutexThread * threads [ TESTMUTEX_THREAD_COUNT ] ; int i ; int32_t numThreadsStarted = 0 ; for ( i = 0 ; i < TESTMUTEX_THREAD_COUNT ; i ++ ) { threads [ i ] = new TestMutexThread ; if ( threads [ i ] -> start ( ) != 0 ) { errln ( " Error ▁ starting ▁ thread ▁ % d " , i ) ; } else { numThreadsStarted ++ ; } } if ( numThreadsStarted == 0 ) { errln ( " No ▁ threads ▁ could ▁ be ▁ started ▁ for ▁ testing ! " ) ; return ; } int patience = 0 ; while ( safeIncr ( gThreadsStarted , 0 ) != TESTMUTEX_THREAD_COUNT ) { if ( patience ++ > 24 ) { TSMTHREAD_FAIL ( " Patience ▁ Exceeded " ) ; return ; } SimpleThread :: sleep ( 500 ) ; } TSMTHREAD_ASSERT ( gThreadsInMiddle == 0 ) ; TSMTHREAD_ASSERT ( gThreadsDone == 0 ) ; umtx_lock ( & gTestMutexB ) ; umtx_unlock ( & gTestMutexA ) ; patience = 0 ; while ( safeIncr ( gThreadsInMiddle , 0 ) != TESTMUTEX_THREAD_COUNT ) { if ( patience ++ > 24 ) { TSMTHREAD_FAIL ( " Patience ▁ Exceeded " ) ; return ; } SimpleThread :: sleep ( 500 ) ; } TSMTHREAD_ASSERT ( gThreadsDone == 0 ) ; umtx_unlock ( & gTestMutexB ) ; patience = 0 ; while ( safeIncr ( gThreadsDone , 0 ) != TESTMUTEX_THREAD_COUNT ) { if ( patience ++ > 24 ) { TSMTHREAD_FAIL ( " Patience ▁ Exceeded " ) ; return ; } SimpleThread :: sleep ( 500 ) ; } for ( i = 0 ; i < TESTMUTEX_THREAD_COUNT ; i ++ ) { delete threads [ i ] ; } } class ThreadWithStatus : public SimpleThread { public : UBool getError ( ) { return ( fErrors > 0 ) ; } UBool getError ( UnicodeString & fillinError ) { fillinError = fErrorString ; return ( fErrors > 0 ) ; } virtual ~ ThreadWithStatus ( ) { } protected : ThreadWithStatus ( ) : fErrors ( 0 ) { } void error ( const UnicodeString & error ) { fErrors ++ ; fErrorString = error ; SimpleThread :: errorFunc ( ) ; } void error ( ) { error ( " An ▁ error ▁ occured . " ) ; } private : int32_t fErrors ; UnicodeString fErrorString ; } ; UnicodeString showDifference ( const UnicodeString & expected , const UnicodeString & result ) { UnicodeString res ; res = expected + " < Expected \n " ; if ( expected . length ( ) != result . length ( ) ) res += " ▁ [ ▁ Different ▁ lengths ▁ ] ▁ \n " ; else { for ( int32_t i = 0 ; i < expected . length ( ) ; i ++ ) { if ( expected [ i ] == result [ i ] ) { res += " ▁ " ; } else { res += " | " ; } } res += " < Differences " ; res += " \n " ; } res += result + " < Result \n " ; return res ; } const int kFormatThreadIterations = 100 ; const int kFormatThreadThreads = 10 ; # if ! UCONFIG_NO_FORMATTING struct FormatThreadTestData { double number ; UnicodeString string ; FormatThreadTestData ( double a , const UnicodeString & b ) : number ( a ) , string ( b ) { } } ; static void formatErrorMessage ( UErrorCode & realStatus , const UnicodeString & pattern , const Locale & theLocale , UErrorCode inStatus0 , const Locale & inCountry2 , double currency3 , UnicodeString & result ) { if ( U_FAILURE ( realStatus ) ) return ; UnicodeString errString1 ( u_errorName ( inStatus0 ) ) ; UnicodeString countryName2 ; inCountry2 . getDisplayCountry ( theLocale , countryName2 ) ; Formattable myArgs [ ] = { Formattable ( ( int32_t ) inStatus0 ) , Formattable ( errString1 ) , Formattable ( countryName2 ) , Formattable ( currency3 ) } ; MessageFormat * fmt = new MessageFormat ( " MessageFormat ' s ▁ API ▁ is ▁ broken ! ! ! ! ! ! ! ! ! ! ! " , realStatus ) ; fmt -> setLocale ( theLocale ) ; fmt -> applyPattern ( pattern , realStatus ) ; if ( U_FAILURE ( realStatus ) ) { delete fmt ; return ; } FieldPosition ignore = 0 ; fmt -> format ( myArgs , 4 , result , ignore , realStatus ) ; delete fmt ; } class ThreadSafeFormatSharedData { public : ThreadSafeFormatSharedData ( UErrorCode & status ) ; ~ ThreadSafeFormatSharedData ( ) ; LocalPointer < NumberFormat > fFormat ; Formattable fYDDThing ; Formattable fBBDThing ; UnicodeString fYDDStr ; UnicodeString fBBDStr ; } ; const ThreadSafeFormatSharedData * gSharedData = NULL ; ThreadSafeFormatSharedData :: ThreadSafeFormatSharedData ( UErrorCode & status ) { fFormat . adoptInstead ( NumberFormat :: createCurrencyInstance ( Locale :: getUS ( ) , status ) ) ; static const UChar kYDD [ ] = { 0x59 , 0x44 , 0x44 , 0x00 } ; static const UChar kBBD [ ] = { 0x42 , 0x42 , 0x44 , 0x00 } ; fYDDThing . adoptObject ( new CurrencyAmount ( 123.456 , kYDD , status ) ) ; fBBDThing . adoptObject ( new CurrencyAmount ( 987.654 , kBBD , status ) ) ; if ( U_FAILURE ( status ) ) { return ; } fFormat -> format ( fYDDThing , fYDDStr , NULL , status ) ; fFormat -> format ( fBBDThing , fBBDStr , NULL , status ) ; gSharedData = this ; } ThreadSafeFormatSharedData :: ~ ThreadSafeFormatSharedData ( ) { gSharedData = NULL ; } class ThreadSafeFormat { public : ThreadSafeFormat ( UErrorCode & status ) ; UBool doStuff ( int32_t offset , UnicodeString & appendErr , UErrorCode & status ) const ; private : LocalPointer < NumberFormat > fFormat ; } ; ThreadSafeFormat :: ThreadSafeFormat ( UErrorCode & status ) { fFormat . adoptInstead ( NumberFormat :: createCurrencyInstance ( Locale :: getUS ( ) , status ) ) ; } static const UChar kUSD [ ] = { 0x55 , 0x53 , 0x44 , 0x00 } ; UBool ThreadSafeFormat :: doStuff ( int32_t offset , UnicodeString & appendErr , UErrorCode & status ) const { UBool okay = TRUE ; if ( u_strcmp ( fFormat -> getCurrency ( ) , kUSD ) ) { appendErr . append ( " fFormat ▁ currency ▁ ! = ▁ " ) . append ( kUSD ) . append ( " , ▁ = " ) . append ( fFormat -> getCurrency ( ) ) . append ( " ! ▁ " ) ; okay = FALSE ; } if ( u_strcmp ( gSharedData -> fFormat -> getCurrency ( ) , kUSD ) ) { appendErr . append ( " gFormat ▁ currency ▁ ! = ▁ " ) . append ( kUSD ) . append ( " , ▁ = " ) . append ( gSharedData -> fFormat -> getCurrency ( ) ) . append ( " ! ▁ " ) ; okay = FALSE ; } UnicodeString str ; const UnicodeString * o = NULL ; Formattable f ; const NumberFormat * nf = NULL ; switch ( offset % 4 ) { case 0 : f = gSharedData -> fYDDThing ; o = & gSharedData -> fYDDStr ; nf = gSharedData -> fFormat . getAlias ( ) ; break ; case 1 : f = gSharedData -> fBBDThing ; o = & gSharedData -> fBBDStr ; nf = gSharedData -> fFormat . getAlias ( ) ; break ; case 2 : f = gSharedData -> fYDDThing ; o = & gSharedData -> fYDDStr ; nf = fFormat . getAlias ( ) ; break ; case 3 : f = gSharedData -> fBBDThing ; o = & gSharedData -> fBBDStr ; nf = fFormat . getAlias ( ) ; break ; } nf -> format ( f , str , NULL , status ) ; if ( * o != str ) { appendErr . append ( showDifference ( * o , str ) ) ; okay = FALSE ; } return okay ; } UBool U_CALLCONV isAcceptable ( void * , const char * , const char * , const UDataInfo * ) { return TRUE ; } class FormatThreadTest : public ThreadWithStatus { public : int fNum ; int fTraceInfo ; LocalPointer < ThreadSafeFormat > fTSF ; FormatThreadTest ( ) : ThreadWithStatus ( ) , fNum ( 0 ) , fTraceInfo ( 0 ) , fTSF ( NULL ) , fOffset ( 0 ) { UErrorCode status = U_ZERO_ERROR ; fTSF . adoptInstead ( new ThreadSafeFormat ( status ) ) ; static int32_t fgOffset = 0 ; fgOffset += 3 ; fOffset = fgOffset ; } virtual void run ( ) { fTraceInfo = 1 ; LocalPointer < NumberFormat > percentFormatter ; UErrorCode status = U_ZERO_ERROR ; # if 0 for ( int i = 0 ; i < 4000 ; i ++ ) { status = U_ZERO_ERROR ; UDataMemory * data1 = udata_openChoice ( 0 , " res " , " en _ US " , isAcceptable , 0 , & status ) ; UDataMemory * data2 = udata_openChoice ( 0 , " res " , " fr " , isAcceptable , 0 , & status ) ; udata_close ( data1 ) ; udata_close ( data2 ) ; if ( U_FAILURE ( status ) ) { error ( " udata _ openChoice ▁ failed . \n " ) ; break ; } } return ; # endif # if 0 int m ; for ( m = 0 ; m < 4000 ; m ++ ) { status = U_ZERO_ERROR ; UResourceBundle * res = NULL ; const char * localeName = NULL ; Locale loc = Locale :: getEnglish ( ) ; localeName = loc . getName ( ) ; res = ures_open ( NULL , localeName , & status ) ; ures_close ( res ) ; if ( U_FAILURE ( status ) ) { error ( " Resource ▁ bundle ▁ construction ▁ failed . \n " ) ; break ; } } return ; # endif FormatThreadTestData kNumberFormatTestData [ ] = { FormatThreadTestData ( ( double ) 5.0 , UnicodeString ( "5" , " " ) ) , FormatThreadTestData ( 6.0 , UnicodeString ( "6" , " " ) ) , FormatThreadTestData ( 20.0 , UnicodeString ( "20" , " " ) ) , FormatThreadTestData ( 8.0 , UnicodeString ( "8" , " " ) ) , FormatThreadTestData ( 8.3 , UnicodeString ( "8.3" , " " ) ) , FormatThreadTestData ( 12345 , UnicodeString ( "12,345" , " " ) ) , FormatThreadTestData ( 81890.23 , UnicodeString ( "81,890.23" , " " ) ) , } ; int32_t kNumberFormatTestDataLength = UPRV_LENGTHOF ( kNumberFormatTestData ) ; FormatThreadTestData kPercentFormatTestData [ ] = { FormatThreadTestData ( ( double ) 5.0 , CharsToUnicodeString ( "500\\u00a0 % " ) ) , FormatThreadTestData ( 1.0 , CharsToUnicodeString ( "100\\u00a0 % " ) ) , FormatThreadTestData ( 0.26 , CharsToUnicodeString ( "26\\u00a0 % " ) ) , FormatThreadTestData ( 16384.99 , CharsToUnicodeString ( "1\\u00a0638\\u00a0499\\u00a0 % " ) ) , FormatThreadTestData ( 81890.23 , CharsToUnicodeString ( "8\\u00a0189\\u00a0023\\u00a0 % " ) ) , } ; int32_t kPercentFormatTestDataLength = UPRV_LENGTHOF ( kPercentFormatTestData ) ; int32_t iteration ; status = U_ZERO_ERROR ; LocalPointer < NumberFormat > formatter ( NumberFormat :: createInstance ( Locale :: getEnglish ( ) , status ) ) ; if ( U_FAILURE ( status ) ) { error ( " Error ▁ on ▁ NumberFormat : : createInstance ( ) . " ) ; goto cleanupAndReturn ; } percentFormatter . adoptInstead ( NumberFormat :: createPercentInstance ( Locale :: getFrench ( ) , status ) ) ; if ( U_FAILURE ( status ) ) { error ( " Error ▁ on ▁ NumberFormat : : createPercentInstance ( ) . " ) ; goto cleanupAndReturn ; } for ( iteration = 0 ; ! getError ( ) && iteration < kFormatThreadIterations ; iteration ++ ) { int32_t whichLine = ( iteration + fOffset ) % kNumberFormatTestDataLength ; UnicodeString output ; formatter -> format ( kNumberFormatTestData [ whichLine ] . number , output ) ; if ( 0 != output . compare ( kNumberFormatTestData [ whichLine ] . string ) ) { error ( " format ( ) . . ▁ expected ▁ " + kNumberFormatTestData [ whichLine ] . string + " ▁ got ▁ " + output ) ; goto cleanupAndReturn ; } output . remove ( ) ; whichLine = ( iteration + fOffset ) % kPercentFormatTestDataLength ; percentFormatter -> format ( kPercentFormatTestData [ whichLine ] . number , output ) ; if ( 0 != output . compare ( kPercentFormatTestData [ whichLine ] . string ) ) { error ( " percent ▁ format ( ) . . ▁ \n " + showDifference ( kPercentFormatTestData [ whichLine ] . string , output ) ) ; goto cleanupAndReturn ; } const int kNumberOfMessageTests = 3 ; UErrorCode statusToCheck ; UnicodeString patternToCheck ; Locale messageLocale ; Locale countryToCheck ; double currencyToCheck ; UnicodeString expected ; switch ( ( iteration + fOffset ) % kNumberOfMessageTests ) { default : case 0 : statusToCheck = U_FILE_ACCESS_ERROR ; patternToCheck = "0 : Someone ▁ from ▁ { 2 } ▁ is ▁ receiving ▁ a ▁ # {0 } " " ▁ error ▁ - ▁ { 1 } . ▁ Their ▁ telephone ▁ call ▁ is ▁ costing ▁ " " { 3 , number , currency } . " ; messageLocale = Locale ( " en " , " US " ) ; countryToCheck = Locale ( " " , " HR " ) ; currencyToCheck = 8192.77 ; expected = "0 : Someone ▁ from ▁ Croatia ▁ is ▁ receiving ▁ a ▁ # 4 ▁ error ▁ - ▁ " " U _ FILE _ ACCESS _ ERROR . ▁ Their ▁ telephone ▁ call ▁ is ▁ costing ▁ $ 8,192.77 . " ; break ; case 1 : statusToCheck = U_INDEX_OUTOFBOUNDS_ERROR ; patternToCheck = "1 : A ▁ customer ▁ in ▁ { 2 } ▁ is ▁ receiving ▁ a ▁ # {0 } ▁ error ▁ - ▁ { 1 } . ▁ " " Their ▁ telephone ▁ call ▁ is ▁ costing ▁ { 3 , number , currency } . " ; messageLocale = Locale ( " de " , " DE @ currency = DEM " ) ; countryToCheck = Locale ( " " , " BF " ) ; currencyToCheck = 2.32 ; expected = CharsToUnicodeString ( "1 : A ▁ customer ▁ in ▁ Burkina ▁ Faso ▁ is ▁ receiving ▁ a ▁ # 8 ▁ error ▁ - ▁ U _ INDEX _ OUTOFBOUNDS _ ERROR . ▁ " " Their ▁ telephone ▁ call ▁ is ▁ costing ▁ 2,32\\u00A0DM . " ) ; break ; case 2 : statusToCheck = U_MEMORY_ALLOCATION_ERROR ; patternToCheck = "2 : user ▁ in ▁ { 2 } ▁ is ▁ receiving ▁ a ▁ # {0 } ▁ error ▁ - ▁ { 1 } . ▁ " " They ▁ insist ▁ they ▁ just ▁ spent ▁ { 3 , number , currency } ▁ " " on ▁ memory . " ; messageLocale = Locale ( " de " , " AT @ currency = ATS " ) ; countryToCheck = Locale ( " " , " US " ) ; currencyToCheck = 40193.12 ; expected = CharsToUnicodeString ( "2 : user ▁ in ▁ Vereinigte ▁ Staaten ▁ is ▁ receiving ▁ a ▁ # 7 ▁ error " " ▁ - ▁ U _ MEMORY _ ALLOCATION _ ERROR . ▁ They ▁ insist ▁ they ▁ just ▁ spent " " ▁ \\u00f6S\\u00A040.193,12 ▁ on ▁ memory . " ) ; break ; } UnicodeString result ; UErrorCode status = U_ZERO_ERROR ; formatErrorMessage ( status , patternToCheck , messageLocale , statusToCheck , countryToCheck , currencyToCheck , result ) ; if ( U_FAILURE ( status ) ) { UnicodeString tmp ( u_errorName ( status ) ) ; error ( " Failure ▁ on ▁ message ▁ format , ▁ pattern = " + patternToCheck + " , ▁ error ▁ = ▁ " + tmp ) ; goto cleanupAndReturn ; } if ( result != expected ) { error ( " PatternFormat : ▁ \n " + showDifference ( expected , result ) ) ; goto cleanupAndReturn ; } UnicodeString appendErr ; if ( ! fTSF -> doStuff ( fNum , appendErr , status ) ) { error ( appendErr ) ; goto cleanupAndReturn ; } } cleanupAndReturn : fTraceInfo = 2 ; } private : int32_t fOffset ; } ; void MultithreadTest :: TestThreadedIntl ( ) { int i ; UnicodeString theErr ; UBool haveDisplayedInfo [ kFormatThreadThreads ] ; static const int32_t PATIENCE_SECONDS = 45 ; UErrorCode threadSafeErr = U_ZERO_ERROR ; ThreadSafeFormatSharedData sharedData ( threadSafeErr ) ; assertSuccess ( " initializing ▁ ThreadSafeFormat " , threadSafeErr , TRUE ) ; logln ( " Spawning : ▁ % d ▁ threads ▁ * ▁ % d ▁ iterations ▁ each . " , kFormatThreadThreads , kFormatThreadIterations ) ; LocalArray < FormatThreadTest > tests ( new FormatThreadTest [ kFormatThreadThreads ] ) ; for ( int32_t j = 0 ; j < kFormatThreadThreads ; j ++ ) { tests [ j ] . fNum = j ; int32_t threadStatus = tests [ j ] . start ( ) ; if ( threadStatus != 0 ) { errln ( " System ▁ Error ▁ % d ▁ starting ▁ thread ▁ number ▁ % d . " , threadStatus , j ) ; SimpleThread :: errorFunc ( ) ; return ; } haveDisplayedInfo [ j ] = FALSE ; } UBool stillRunning ; UDate startTime , endTime ; startTime = Calendar :: getNow ( ) ; double lastComplaint = 0 ; do { stillRunning = FALSE ; endTime = Calendar :: getNow ( ) ; double elapsedSeconds = ( ( int32_t ) ( endTime - startTime ) / U_MILLIS_PER_SECOND ) ; if ( elapsedSeconds > PATIENCE_SECONDS ) { errln ( " Patience ▁ exceeded . ▁ Test ▁ is ▁ taking ▁ too ▁ long . " ) ; return ; } else if ( ( elapsedSeconds - lastComplaint ) > 2.0 ) { infoln ( " % .1f ▁ seconds ▁ elapsed ▁ ( still ▁ waiting . . ) " , elapsedSeconds ) ; lastComplaint = elapsedSeconds ; } SimpleThread :: sleep ( 1 ) ; for ( i = 0 ; i < kFormatThreadThreads ; i ++ ) { if ( tests [ i ] . isRunning ( ) ) { stillRunning = TRUE ; } else if ( haveDisplayedInfo [ i ] == FALSE ) { logln ( " Thread ▁ # ▁ % d ▁ is ▁ complete . . " , i ) ; if ( tests [ i ] . getError ( theErr ) ) { dataerrln ( UnicodeString ( " # " ) + i + " : ▁ " + theErr ) ; SimpleThread :: errorFunc ( ) ; } haveDisplayedInfo [ i ] = TRUE ; } } } while ( stillRunning ) ; assertSuccess ( " finalizing ▁ ThreadSafeFormat " , threadSafeErr , TRUE ) ; } # endif # if ! UCONFIG_NO_COLLATION # define kCollatorThreadThreads 10 # define kCollatorThreadPatience kCollatorThreadThreads * 30 struct Line { UChar buff [ 25 ] ; int32_t buflen ; } ; static UBool skipLineBecauseOfBug ( const UChar * s , int32_t length ) { if ( length >= 3 && ( s [ 0 ] == 0xfb2 || s [ 0 ] == 0xfb3 ) && s [ 1 ] == 0x334 && ( s [ 2 ] == 0xf73 || s [ 2 ] == 0xf75 || s [ 2 ] == 0xf81 ) ) { return TRUE ; } return FALSE ; } static UCollationResult normalizeResult ( int32_t result ) { return result < 0 ? UCOL_LESS : result == 0 ? UCOL_EQUAL : UCOL_GREATER ; } class CollatorThreadTest : public ThreadWithStatus { private : const Collator * coll ; const Line * lines ; int32_t noLines ; UBool isAtLeastUCA62 ; public : CollatorThreadTest ( ) : ThreadWithStatus ( ) , coll ( NULL ) , lines ( NULL ) , noLines ( 0 ) , isAtLeastUCA62 ( TRUE ) { } ; void setCollator ( Collator * c , Line * l , int32_t nl , UBool atLeastUCA62 ) { coll = c ; lines = l ; noLines = nl ; isAtLeastUCA62 = atLeastUCA62 ; } virtual void run ( ) { uint8_t sk1 [ 1024 ] , sk2 [ 1024 ] ; uint8_t * oldSk = NULL , * newSk = sk1 ; int32_t oldLen = 0 ; int32_t prev = 0 ; int32_t i = 0 ; for ( i = 0 ; i < noLines ; i ++ ) { if ( lines [ i ] . buflen == 0 ) { continue ; } if ( skipLineBecauseOfBug ( lines [ i ] . buff , lines [ i ] . buflen ) ) { continue ; } int32_t resLen = coll -> getSortKey ( lines [ i ] . buff , lines [ i ] . buflen , newSk , 1024 ) ; if ( oldSk != NULL ) { int32_t skres = strcmp ( ( char * ) oldSk , ( char * ) newSk ) ; int32_t cmpres = coll -> compare ( lines [ prev ] . buff , lines [ prev ] . buflen , lines [ i ] . buff , lines [ i ] . buflen ) ; int32_t cmpres2 = coll -> compare ( lines [ i ] . buff , lines [ i ] . buflen , lines [ prev ] . buff , lines [ prev ] . buflen ) ; if ( cmpres != - cmpres2 ) { error ( UnicodeString ( " Compare ▁ result ▁ not ▁ symmetrical ▁ on ▁ line ▁ " ) + ( i + 1 ) ) ; break ; } if ( cmpres != normalizeResult ( skres ) ) { error ( UnicodeString ( " Difference ▁ between ▁ coll - > compare ▁ and ▁ sortkey ▁ compare ▁ on ▁ line ▁ " ) + ( i + 1 ) ) ; break ; } int32_t res = cmpres ; if ( res == 0 && ! isAtLeastUCA62 ) { res = u_strcmpCodePointOrder ( lines [ prev ] . buff , lines [ i ] . buff ) ; } if ( res > 0 ) { error ( UnicodeString ( " Line ▁ is ▁ not ▁ greater ▁ or ▁ equal ▁ than ▁ previous ▁ line , ▁ for ▁ line ▁ " ) + ( i + 1 ) ) ; break ; } } oldSk = newSk ; oldLen = resLen ; ( void ) oldLen ; prev = i ; newSk = ( newSk == sk1 ) ? sk2 : sk1 ; } } } ; void MultithreadTest :: TestCollators ( ) { UErrorCode status = U_ZERO_ERROR ; FILE * testFile = NULL ; char testDataPath [ 1024 ] ; strcpy ( testDataPath , IntlTest :: getSourceTestData ( status ) ) ; if ( U_FAILURE ( status ) ) { errln ( " ERROR : ▁ could ▁ not ▁ open ▁ test ▁ data ▁ % s " , u_errorName ( status ) ) ; return ; } strcat ( testDataPath , " CollationTest _ " ) ; const char * type = " NON _ IGNORABLE " ; const char * ext = " . txt " ; if ( testFile ) { fclose ( testFile ) ; } char buffer [ 1024 ] ; strcpy ( buffer , testDataPath ) ; strcat ( buffer , type ) ; size_t bufLen = strlen ( buffer ) ; strcpy ( buffer + bufLen , ext ) ; testFile = fopen ( buffer , " rb " ) ; if ( testFile == 0 ) { strcpy ( buffer + bufLen , " _ SHORT " ) ; strcat ( buffer , ext ) ; testFile = fopen ( buffer , " rb " ) ; if ( testFile == 0 ) { strcpy ( buffer + bufLen , " _ STUB " ) ; strcat ( buffer , ext ) ; testFile = fopen ( buffer , " rb " ) ; if ( testFile == 0 ) { * ( buffer + bufLen ) = 0 ; dataerrln ( " could ▁ not ▁ open ▁ any ▁ of ▁ the ▁ conformance ▁ test ▁ files , ▁ tried ▁ opening ▁ base ▁ % s " , buffer ) ; return ; } else { infoln ( " INFO : ▁ Working ▁ with ▁ the ▁ stub ▁ file . \n " " If ▁ you ▁ need ▁ the ▁ full ▁ conformance ▁ test , ▁ please \n " " download ▁ the ▁ appropriate ▁ data ▁ files ▁ from : \n " " http : // source . icu - project . org / repos / icu / tools / trunk / unicodetools / com / ibm / text / data / " ) ; } } } LocalArray < Line > lines ( new Line [ 200000 ] ) ; memset ( lines . getAlias ( ) , 0 , sizeof ( Line ) * 200000 ) ; int32_t lineNum = 0 ; UChar bufferU [ 1024 ] ; uint32_t first = 0 ; while ( fgets ( buffer , 1024 , testFile ) != NULL ) { if ( * buffer == 0 || buffer [ 0 ] == ' # ' ) { lines [ lineNum ] . buflen = 0 ; lines [ lineNum ] . buff [ 0 ] = 0 ; } else { int32_t buflen = u_parseString ( buffer , bufferU , 1024 , & first , & status ) ; lines [ lineNum ] . buflen = buflen ; u_memcpy ( lines [ lineNum ] . buff , bufferU , buflen ) ; lines [ lineNum ] . buff [ buflen ] = 0 ; } lineNum ++ ; } fclose ( testFile ) ; if ( U_FAILURE ( status ) ) { dataerrln ( " Couldn ' t ▁ read ▁ the ▁ test ▁ file ! " ) ; return ; } UVersionInfo uniVersion ; static const UVersionInfo v62 = { 6 , 2 , 0 , 0 } ; u_getUnicodeVersion ( uniVersion ) ; UBool isAtLeastUCA62 = uprv_memcmp ( uniVersion , v62 , 4 ) >= 0 ; LocalPointer < Collator > coll ( Collator :: createInstance ( Locale :: getRoot ( ) , status ) ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " Couldn ' t ▁ open ▁ UCA ▁ collator " ) ; return ; } coll -> setAttribute ( UCOL_NORMALIZATION_MODE , UCOL_ON , status ) ; coll -> setAttribute ( UCOL_CASE_FIRST , UCOL_OFF , status ) ; coll -> setAttribute ( UCOL_CASE_LEVEL , UCOL_OFF , status ) ; coll -> setAttribute ( UCOL_STRENGTH , isAtLeastUCA62 ? UCOL_IDENTICAL : UCOL_TERTIARY , status ) ; coll -> setAttribute ( UCOL_ALTERNATE_HANDLING , UCOL_NON_IGNORABLE , status ) ; int32_t noSpawned = 0 ; int32_t spawnResult = 0 ; LocalArray < CollatorThreadTest > tests ( new CollatorThreadTest [ kCollatorThreadThreads ] ) ; logln ( UnicodeString ( " Spawning : ▁ " ) + kCollatorThreadThreads + " ▁ threads ▁ * ▁ " + kFormatThreadIterations + " ▁ iterations ▁ each . " ) ; int32_t j = 0 ; for ( j = 0 ; j < kCollatorThreadThreads ; j ++ ) { tests [ j ] . setCollator ( coll . getAlias ( ) , lines . getAlias ( ) , lineNum , isAtLeastUCA62 ) ; } for ( j = 0 ; j < kCollatorThreadThreads ; j ++ ) { log ( " % i ▁ " , j ) ; spawnResult = tests [ j ] . start ( ) ; if ( spawnResult != 0 ) { infoln ( " THREAD ▁ INFO : ▁ Couldn ' t ▁ spawn ▁ more ▁ than ▁ % i ▁ threads " , noSpawned ) ; break ; } noSpawned ++ ; } logln ( " Spawned ▁ all " ) ; if ( noSpawned == 0 ) { errln ( " No ▁ threads ▁ could ▁ be ▁ spawned . " ) ; return ; } for ( int32_t patience = kCollatorThreadPatience ; patience > 0 ; patience -- ) { logln ( " Waiting . . . " ) ; int32_t i ; int32_t terrs = 0 ; int32_t completed = 0 ; for ( i = 0 ; i < kCollatorThreadThreads ; i ++ ) { if ( tests [ i ] . isRunning ( ) == FALSE ) { completed ++ ; UnicodeString theErr ; if ( tests [ i ] . getError ( theErr ) ) { terrs ++ ; errln ( UnicodeString ( " # " ) + i + " : ▁ " + theErr ) ; } } } logln ( " Completed ▁ % i ▁ tests " , completed ) ; if ( completed == noSpawned ) { logln ( " Done ! ▁ All ▁ % i ▁ tests ▁ are ▁ finished " , noSpawned ) ; if ( terrs ) { errln ( " There ▁ were ▁ errors . " ) ; SimpleThread :: errorFunc ( ) ; } return ; } SimpleThread :: sleep ( 900 ) ; } errln ( " patience ▁ exceeded . ▁ " ) ; SimpleThread :: errorFunc ( ) ; } # endif const int kStringThreadIterations = 2500 ; const int kStringThreadThreads = 10 ; const int kStringThreadPatience = 120 ; class StringThreadTest2 : public ThreadWithStatus { public : int fNum ; int fTraceInfo ; const UnicodeString * fSharedString ; StringThreadTest2 ( const UnicodeString * sharedString , int num ) : ThreadWithStatus ( ) , fNum ( num ) , fTraceInfo ( 0 ) , fSharedString ( sharedString ) { } ; virtual void run ( ) { fTraceInfo = 1 ; int loopCount = 0 ; for ( loopCount = 0 ; loopCount < kStringThreadIterations ; loopCount ++ ) { if ( * fSharedString != " This ▁ is ▁ the ▁ original ▁ test ▁ string . " ) { error ( " Original ▁ string ▁ is ▁ corrupt . " ) ; break ; } UnicodeString s1 = * fSharedString ; s1 += " cat ▁ this " ; UnicodeString s2 ( s1 ) ; UnicodeString s3 = * fSharedString ; s2 = s3 ; s3 . truncate ( 12 ) ; s2 . truncate ( 0 ) ; } fTraceInfo = 2 ; } } ; void MultithreadTest :: TestString ( ) { int patience ; int terrs = 0 ; int j ; UnicodeString * testString = new UnicodeString ( " This ▁ is ▁ the ▁ original ▁ test ▁ string . " ) ; StringThreadTest2 * tests [ kStringThreadThreads ] ; for ( j = 0 ; j < kStringThreadThreads ; j ++ ) { tests [ j ] = new StringThreadTest2 ( testString , j ) ; } logln ( UnicodeString ( " Spawning : ▁ " ) + kStringThreadThreads + " ▁ threads ▁ * ▁ " + kStringThreadIterations + " ▁ iterations ▁ each . " ) ; for ( j = 0 ; j < kStringThreadThreads ; j ++ ) { int32_t threadStatus = tests [ j ] -> start ( ) ; if ( threadStatus != 0 ) { errln ( " System ▁ Error ▁ % d ▁ starting ▁ thread ▁ number ▁ % d . " , threadStatus , j ) ; SimpleThread :: errorFunc ( ) ; goto cleanupAndReturn ; } } for ( patience = kStringThreadPatience ; patience > 0 ; patience -- ) { logln ( " Waiting . . . " ) ; int32_t i ; terrs = 0 ; int32_t completed = 0 ; for ( i = 0 ; i < kStringThreadThreads ; i ++ ) { if ( tests [ i ] -> isRunning ( ) == FALSE ) { completed ++ ; logln ( UnicodeString ( " Test ▁ # " ) + i + " ▁ is ▁ complete . . ▁ " ) ; UnicodeString theErr ; if ( tests [ i ] -> getError ( theErr ) ) { terrs ++ ; errln ( UnicodeString ( " # " ) + i + " : ▁ " + theErr ) ; } } } if ( completed == kStringThreadThreads ) { logln ( " Done ! " ) ; if ( terrs ) { errln ( " There ▁ were ▁ errors . " ) ; } break ; } SimpleThread :: sleep ( 900 ) ; } if ( patience <= 0 ) { errln ( " patience ▁ exceeded . ▁ " ) ; terrs ++ ; } if ( terrs > 0 ) { SimpleThread :: errorFunc ( ) ; } cleanupAndReturn : if ( terrs == 0 ) { for ( j = 0 ; j < kStringThreadThreads ; j ++ ) { delete tests [ j ] ; } delete testString ; } } # if ! UCONFIG_NO_TRANSLITERATION class TxThread : public SimpleThread { private : Transliterator * fSharedTranslit ; public : UBool fSuccess ; TxThread ( Transliterator * tx ) : fSharedTranslit ( tx ) , fSuccess ( FALSE ) { } ; ~ TxThread ( ) ; void run ( ) ; } ; TxThread :: ~ TxThread ( ) { } void TxThread :: run ( ) { UnicodeString greekString ( " \\u03B4\\u03B9\\u03B1\\u03C6\\u03BF\\u03C1\\u03B5\\u03C4\\u03B9\\u03BA\\u03BF\\u03CD\\u03C2" ) ; greekString = greekString . unescape ( ) ; fSharedTranslit -> transliterate ( greekString ) ; fSuccess = greekString [ 0 ] == 0x64 ; } # endif void MultithreadTest :: TestAnyTranslit ( ) { # if ! UCONFIG_NO_TRANSLITERATION UErrorCode status = U_ZERO_ERROR ; LocalPointer < Transliterator > tx ( Transliterator :: createInstance ( " Any - Latin " , UTRANS_FORWARD , status ) ) ; if ( U_FAILURE ( status ) ) { dataerrln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ status ▁ = ▁ % s " , __FILE__ , __LINE__ , u_errorName ( status ) ) ; return ; } TxThread * threads [ 4 ] ; int32_t i ; for ( i = 0 ; i < 4 ; i ++ ) { threads [ i ] = new TxThread ( tx . getAlias ( ) ) ; } for ( i = 0 ; i < 4 ; i ++ ) { threads [ i ] -> start ( ) ; } int32_t patience = 100 ; UBool success ; UBool someThreadRunning ; do { someThreadRunning = FALSE ; success = TRUE ; for ( i = 0 ; i < 4 ; i ++ ) { if ( threads [ i ] -> isRunning ( ) ) { someThreadRunning = TRUE ; SimpleThread :: sleep ( 10 ) ; break ; } else { if ( threads [ i ] -> fSuccess == FALSE ) { success = FALSE ; } } } } while ( someThreadRunning && -- patience > 0 ) ; if ( patience <= 0 ) { errln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ one ▁ or ▁ more ▁ threads ▁ did ▁ not ▁ complete . " , __FILE__ , __LINE__ ) ; } if ( success == FALSE ) { errln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ transliteration ▁ result ▁ incorrect . " , __FILE__ , __LINE__ ) ; } for ( i = 0 ; i < 4 ; i ++ ) { delete threads [ i ] ; } # endif } class CondThread : public SimpleThread { public : CondThread ( ) : fFinished ( false ) { } ; ~ CondThread ( ) { } ; void run ( ) ; bool fFinished ; } ; static UMutex gCTMutex = U_MUTEX_INITIALIZER ; static UConditionVar gCTConditionVar = U_CONDITION_INITIALIZER ; int gConditionTestOne = 1 ; int gStartedThreads ; int gFinishedThreads ; static const int NUMTHREADS = 10 ; static MultithreadTest * gThisTest = NULL ; void CondThread :: run ( ) { umtx_lock ( & gCTMutex ) ; gStartedThreads += gConditionTestOne ; umtx_condBroadcast ( & gCTConditionVar ) ; while ( gStartedThreads < NUMTHREADS ) { if ( gFinishedThreads != 0 ) { gThisTest -> errln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ gStartedThreads ▁ = ▁ % d , ▁ gFinishedThreads ▁ = ▁ % d " , __FILE__ , __LINE__ , gStartedThreads , gFinishedThreads ) ; } umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } gFinishedThreads += gConditionTestOne ; fFinished = true ; umtx_condBroadcast ( & gCTConditionVar ) ; while ( gFinishedThreads < NUMTHREADS ) { umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } umtx_unlock ( & gCTMutex ) ; } void MultithreadTest :: TestConditionVariables ( ) { gThisTest = this ; gStartedThreads = 0 ; gFinishedThreads = 0 ; int i ; umtx_lock ( & gCTMutex ) ; CondThread * threads [ NUMTHREADS ] ; for ( i = 0 ; i < NUMTHREADS ; ++ i ) { threads [ i ] = new CondThread ; threads [ i ] -> start ( ) ; } while ( gStartedThreads < NUMTHREADS ) { umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } while ( gFinishedThreads < NUMTHREADS ) { umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } umtx_unlock ( & gCTMutex ) ; for ( i = 0 ; i < NUMTHREADS ; ++ i ) { if ( ! threads [ i ] -> fFinished ) { errln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ threads [ % d ] - > fFinished ▁ = = ▁ false " , __FILE__ , __LINE__ , i ) ; } delete threads [ i ] ; } } static const char * gCacheLocales [ ] = { " en _ US " , " en _ GB " , " fr _ FR " , " fr " } ; static int32_t gObjectsCreated = 0 ; static const int32_t CACHE_LOAD = 3 ; class UCTMultiThreadItem : public SharedObject { public : char * value ; UCTMultiThreadItem ( const char * x ) : value ( NULL ) { value = uprv_strdup ( x ) ; } virtual ~ UCTMultiThreadItem ( ) { uprv_free ( value ) ; } } ; U_NAMESPACE_BEGIN template < > U_EXPORT const UCTMultiThreadItem * LocaleCacheKey < UCTMultiThreadItem > :: createObject ( const void * , UErrorCode & ) const { umtx_lock ( & gCTMutex ) ; if ( gObjectsCreated != 0 ) { gThisTest -> errln ( " Expected ▁ no ▁ objects ▁ to ▁ be ▁ created ▁ yet . " ) ; } umtx_unlock ( & gCTMutex ) ; SimpleThread :: sleep ( 1000 ) ; umtx_lock ( & gCTMutex ) ; ++ gObjectsCreated ; umtx_unlock ( & gCTMutex ) ; UCTMultiThreadItem * result = new UCTMultiThreadItem ( fLoc . getName ( ) ) ; result -> addRef ( ) ; return result ; } U_NAMESPACE_END class UnifiedCacheThread : public SimpleThread { public : UnifiedCacheThread ( const char * loc ) : fLoc ( loc ) { } ; ~ UnifiedCacheThread ( ) { } ; void run ( ) ; const char * fLoc ; } ; void UnifiedCacheThread :: run ( ) { UErrorCode status = U_ZERO_ERROR ; const UnifiedCache * cache = UnifiedCache :: getInstance ( status ) ; U_ASSERT ( status == U_ZERO_ERROR ) ; const UCTMultiThreadItem * item = NULL ; cache -> get ( LocaleCacheKey < UCTMultiThreadItem > ( fLoc ) , item , status ) ; U_ASSERT ( item != NULL ) ; if ( uprv_strcmp ( fLoc , item -> value ) ) { gThisTest -> errln ( " Expected ▁ % s , ▁ got ▁ % s " , fLoc , item -> value ) ; } item -> removeRef ( ) ; umtx_lock ( & gCTMutex ) ; ++ gFinishedThreads ; umtx_condBroadcast ( & gCTConditionVar ) ; umtx_unlock ( & gCTMutex ) ; } void MultithreadTest :: TestUnifiedCache ( ) { UErrorCode status = U_ZERO_ERROR ; const UnifiedCache * cache = UnifiedCache :: getInstance ( status ) ; U_ASSERT ( cache != NULL ) ; cache -> flush ( ) ; gThisTest = this ; gFinishedThreads = 0 ; gObjectsCreated = 0 ; UnifiedCacheThread * threads [ CACHE_LOAD ] [ UPRV_LENGTHOF ( gCacheLocales ) ] ; for ( int32_t i = 0 ; i < CACHE_LOAD ; ++ i ) { for ( int32_t j = 0 ; j < UPRV_LENGTHOF ( gCacheLocales ) ; ++ j ) { threads [ i ] [ j ] = new UnifiedCacheThread ( gCacheLocales [ j ] ) ; threads [ i ] [ j ] -> start ( ) ; } } umtx_lock ( & gCTMutex ) ; while ( gFinishedThreads < CACHE_LOAD * UPRV_LENGTHOF ( gCacheLocales ) ) { umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } assertEquals ( " Objects ▁ created " , UPRV_LENGTHOF ( gCacheLocales ) , gObjectsCreated ) ; umtx_unlock ( & gCTMutex ) ; for ( int32_t i = 0 ; i < CACHE_LOAD ; ++ i ) { for ( int32_t j = 0 ; j < UPRV_LENGTHOF ( gCacheLocales ) ; ++ j ) { delete threads [ i ] [ j ] ; } } } # endif </DOCUMENT>
<DOCUMENT_ID="didoutheone/MangosOneDidou/tree/master/dep/recastnavigation/RecastDemo/Source/CrowdManager.cpp"> # define _USE_MATH_DEFINES # include < math . h > # include < stdio . h > # include < stdlib . h > # include < string . h > # include < float . h > # include " DetourNavMesh . h " # include " DetourNavMeshQuery . h " # include " DetourObstacleAvoidance . h " # include " DetourCommon . h " # include " CrowdManager . h " # include " SampleInterfaces . h " # include " DetourAssert . h " # include " DetourAlloc . h " static const int VO_ADAPTIVE_DIVS = 7 ; static const int VO_ADAPTIVE_RINGS = 2 ; static const int VO_ADAPTIVE_DEPTH = 5 ; static const int VO_GRID_SIZE = 33 ; inline int hashPos2 ( int x , int y , int n ) { return ( ( x * 73856093 ) ^ ( y * 19349663 ) ) & ( n - 1 ) ; } ProximityGrid :: ProximityGrid ( ) : m_maxItems ( 0 ) , m_cellSize ( 0 ) , m_pool ( 0 ) , m_poolHead ( 0 ) , m_poolSize ( 0 ) , m_buckets ( 0 ) , m_bucketsSize ( 0 ) { } ProximityGrid :: ~ ProximityGrid ( ) { dtFree ( m_buckets ) ; dtFree ( m_pool ) ; } bool ProximityGrid :: init ( const int maxItems , const float cellSize ) { dtAssert ( maxItems > 0 ) ; dtAssert ( cellSize > 0.0f ) ; m_cellSize = cellSize ; m_invCellSize = 1.0f / m_cellSize ; m_bucketsSize = dtNextPow2 ( maxItems ) ; m_buckets = ( unsigned short * ) dtAlloc ( sizeof ( unsigned short ) * m_bucketsSize , DT_ALLOC_PERM ) ; if ( ! m_buckets ) return false ; m_poolSize = maxItems * 4 ; m_poolHead = 0 ; m_pool = ( Item * ) dtAlloc ( sizeof ( Item ) * m_poolSize , DT_ALLOC_PERM ) ; if ( ! m_pool ) return false ; clear ( ) ; return true ; } void ProximityGrid :: clear ( ) { memset ( m_buckets , 0xff , sizeof ( unsigned short ) * m_bucketsSize ) ; m_poolHead = 0 ; m_bounds [ 0 ] = 0xffff ; m_bounds [ 1 ] = 0xffff ; m_bounds [ 2 ] = - 0xffff ; m_bounds [ 3 ] = - 0xffff ; } void ProximityGrid :: addItem ( const unsigned short id , const float minx , const float miny , const float maxx , const float maxy ) { const int iminx = ( int ) floorf ( minx * m_invCellSize ) ; const int iminy = ( int ) floorf ( miny * m_invCellSize ) ; const int imaxx = ( int ) floorf ( maxx * m_invCellSize ) ; const int imaxy = ( int ) floorf ( maxy * m_invCellSize ) ; m_bounds [ 0 ] = dtMin ( m_bounds [ 0 ] , iminx ) ; m_bounds [ 1 ] = dtMin ( m_bounds [ 1 ] , iminy ) ; m_bounds [ 2 ] = dtMax ( m_bounds [ 2 ] , imaxx ) ; m_bounds [ 3 ] = dtMax ( m_bounds [ 3 ] , imaxy ) ; for ( int y = iminy ; y <= imaxy ; ++ y ) { for ( int x = iminx ; x <= imaxx ; ++ x ) { if ( m_poolHead < m_poolSize ) { const int h = hashPos2 ( x , y , m_bucketsSize ) ; const unsigned short idx = ( unsigned short ) m_poolHead ; m_poolHead ++ ; Item & item = m_pool [ idx ] ; item . x = ( short ) x ; item . y = ( short ) y ; item . id = id ; item . next = m_buckets [ h ] ; m_buckets [ h ] = idx ; } } } } int ProximityGrid :: queryItems ( const float minx , const float miny , const float maxx , const float maxy , unsigned short * ids , const int maxIds ) const { const int iminx = ( int ) floorf ( minx * m_invCellSize ) ; const int iminy = ( int ) floorf ( miny * m_invCellSize ) ; const int imaxx = ( int ) floorf ( maxx * m_invCellSize ) ; const int imaxy = ( int ) floorf ( maxy * m_invCellSize ) ; int n = 0 ; for ( int y = iminy ; y <= imaxy ; ++ y ) { for ( int x = iminx ; x <= imaxx ; ++ x ) { const int h = hashPos2 ( x , y , m_bucketsSize ) ; unsigned short idx = m_buckets [ h ] ; while ( idx != 0xffff ) { Item & item = m_pool [ idx ] ; if ( ( int ) item . x == x && ( int ) item . y == y ) { const unsigned short * end = ids + n ; unsigned short * i = ids ; while ( i != end && * i != item . id ) ++ i ; if ( i == end ) { if ( n >= maxIds ) return n ; ids [ n ++ ] = item . id ; } } idx = item . next ; } } } return n ; } int ProximityGrid :: getItemCountAt ( const int x , const int y ) const { int n = 0 ; const int h = hashPos2 ( x , y , m_bucketsSize ) ; unsigned short idx = m_buckets [ h ] ; while ( idx != 0xffff ) { Item & item = m_pool [ idx ] ; if ( ( int ) item . x == x && ( int ) item . y == y ) n ++ ; idx = item . next ; } return n ; } PathQueue :: PathQueue ( ) : m_nextHandle ( 1 ) , m_delay ( 0 ) { for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) m_queue [ i ] . ref = PATHQ_INVALID ; } PathQueue :: ~ PathQueue ( ) { } void PathQueue :: update ( dtNavMeshQuery * navquery ) { m_delay ++ ; if ( ( m_delay % 4 ) == 0 ) { for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { PathQuery & q = m_queue [ i ] ; if ( q . ref == PATHQ_INVALID ) continue ; navquery -> findPath ( q . startRef , q . endRef , q . startPos , q . endPos , q . filter , q . path , & q . npath , PQ_MAX_PATH ) ; q . ready = true ; break ; } } for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { PathQuery & q = m_queue [ i ] ; if ( q . ref != PATHQ_INVALID && q . ready ) { q . keepalive ++ ; if ( q . keepalive > 2 ) q . ref = PATHQ_INVALID ; } } } PathQueueRef PathQueue :: request ( dtPolyRef startRef , dtPolyRef endRef , const float * startPos , const float * endPos , const dtQueryFilter * filter ) { int slot = - 1 ; for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { if ( m_queue [ i ] . ref == PATHQ_INVALID ) { slot = i ; break ; } } if ( slot == - 1 ) return PATHQ_INVALID ; PathQueueRef ref = m_nextHandle ++ ; if ( m_nextHandle == PATHQ_INVALID ) m_nextHandle ++ ; PathQuery & q = m_queue [ slot ] ; q . ref = ref ; dtVcopy ( q . startPos , startPos ) ; q . startRef = startRef ; dtVcopy ( q . endPos , endPos ) ; q . endRef = endRef ; q . ready = false ; q . npath = 0 ; q . filter = filter ; q . keepalive = 0 ; return ref ; } int PathQueue :: getRequestState ( PathQueueRef ref ) { for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { if ( m_queue [ i ] . ref == ref ) return m_queue [ i ] . ready ? PATHQ_STATE_READY : PATHQ_STATE_WORKING ; } return PATHQ_STATE_INVALID ; } int PathQueue :: getPathResult ( PathQueueRef ref , dtPolyRef * path , const int maxPath ) { for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { if ( m_queue [ i ] . ref == ref ) { PathQuery & q = m_queue [ i ] ; q . ref = PATHQ_INVALID ; int n = 0 ; for ( int j = 0 ; j < q . npath && j < maxPath ; ++ j ) path [ n ++ ] = q . path [ j ] ; return n ; } } return 0 ; } static int fixupCorridor ( dtPolyRef * path , const int npath , const int maxPath , const dtPolyRef * visited , const int nvisited ) { int furthestPath = - 1 ; int furthestVisited = - 1 ; for ( int i = npath - 1 ; i >= 0 ; -- i ) { bool found = false ; for ( int j = nvisited - 1 ; j >= 0 ; -- j ) { if ( path [ i ] == visited [ j ] ) { furthestPath = i ; furthestVisited = j ; found = true ; } } if ( found ) break ; } if ( furthestPath == - 1 || furthestVisited == - 1 ) return npath ; const int req = nvisited - furthestVisited ; const int orig = dtMin ( furthestPath + 1 , npath ) ; int size = dtMax ( 0 , npath - orig ) ; if ( req + size > maxPath ) size = maxPath - req ; if ( size ) memmove ( path + req , path + orig , size * sizeof ( dtPolyRef ) ) ; for ( int i = 0 ; i < req ; ++ i ) path [ i ] = visited [ ( nvisited - 1 ) - i ] ; return req + size ; } static int fixupCorridorEnd ( dtPolyRef * path , const int npath , const int maxPath , const dtPolyRef * visited , const int nvisited ) { int furthestPath = - 1 ; int furthestVisited = - 1 ; for ( int i = 0 ; i < npath ; ++ i ) { bool found = false ; for ( int j = nvisited - 1 ; j >= 0 ; -- j ) { if ( path [ i ] == visited [ j ] ) { furthestPath = i ; furthestVisited = j ; found = true ; } } if ( found ) break ; } if ( furthestPath == - 1 || furthestVisited == - 1 ) return npath ; const int ppos = furthestPath + 1 ; const int vpos = furthestVisited + 1 ; const int count = dtMin ( nvisited - vpos , maxPath - ppos ) ; dtAssert ( ppos + count <= maxPath ) ; if ( count ) memcpy ( path + ppos , visited + vpos , sizeof ( dtPolyRef ) * count ) ; return ppos + count ; } static int mergeCorridor ( dtPolyRef * path , const int npath , const int maxPath , const dtPolyRef * visited , const int nvisited ) { int furthestPath = - 1 ; int furthestVisited = - 1 ; for ( int i = npath - 1 ; i >= 0 ; -- i ) { bool found = false ; for ( int j = nvisited - 1 ; j >= 0 ; -- j ) { if ( path [ i ] == visited [ j ] ) { furthestPath = i ; furthestVisited = j ; found = true ; } } if ( found ) break ; } if ( furthestPath == - 1 || furthestVisited == - 1 ) return npath ; const int req = furthestVisited ; if ( req <= 0 ) return npath ; const int orig = furthestPath ; int size = dtMax ( 0 , npath - orig ) ; if ( req + size > maxPath ) size = maxPath - req ; if ( size ) memmove ( path + req , path + orig , size * sizeof ( dtPolyRef ) ) ; for ( int i = 0 ; i < req ; ++ i ) path [ i ] = visited [ i ] ; return req + size ; } PathCorridor :: PathCorridor ( ) : m_path ( 0 ) , m_npath ( 0 ) , m_maxPath ( 0 ) { } PathCorridor :: ~ PathCorridor ( ) { dtFree ( m_path ) ; } bool PathCorridor :: init ( const int maxPath ) { dtAssert ( ! m_path ) ; m_path = ( dtPolyRef * ) dtAlloc ( sizeof ( dtPolyRef ) * maxPath , DT_ALLOC_PERM ) ; if ( ! m_path ) return false ; m_npath = 0 ; m_maxPath = maxPath ; return true ; } void PathCorridor :: reset ( dtPolyRef ref , const float * pos ) { dtAssert ( m_path ) ; dtVcopy ( m_pos , pos ) ; dtVcopy ( m_target , pos ) ; m_path [ 0 ] = ref ; m_npath = 1 ; } int PathCorridor :: findCorners ( float * cornerVerts , unsigned char * cornerFlags , dtPolyRef * cornerPolys , const int maxCorners , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; dtAssert ( m_npath ) ; static const float MIN_TARGET_DIST = 0.01f ; int ncorners = 0 ; navquery -> findStraightPath ( m_pos , m_target , m_path , m_npath , cornerVerts , cornerFlags , cornerPolys , & ncorners , maxCorners ) ; while ( ncorners ) { if ( ( cornerFlags [ 0 ] & DT_STRAIGHTPATH_OFFMESH_CONNECTION ) || dtVdist2DSqr ( & cornerVerts [ 0 ] , m_pos ) > dtSqr ( MIN_TARGET_DIST ) ) break ; ncorners -- ; if ( ncorners ) { memmove ( cornerFlags , cornerFlags + 1 , sizeof ( unsigned char ) * ncorners ) ; memmove ( cornerPolys , cornerPolys + 1 , sizeof ( dtPolyRef ) * ncorners ) ; memmove ( cornerVerts , cornerVerts + 3 , sizeof ( float ) * 3 * ncorners ) ; } } for ( int i = 0 ; i < ncorners ; ++ i ) { if ( cornerFlags [ i ] & DT_STRAIGHTPATH_OFFMESH_CONNECTION ) { ncorners = i + 1 ; break ; } } return ncorners ; } void PathCorridor :: optimizePathVisibility ( const float * next , const float pathOptimizationRange , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; float goal [ 3 ] ; dtVcopy ( goal , next ) ; float dist = dtVdist2D ( m_pos , goal ) ; if ( dist < 0.01f ) return ; dist = dtMin ( dist + 0.01f , pathOptimizationRange ) ; float delta [ 3 ] ; dtVsub ( delta , goal , m_pos ) ; dtVmad ( goal , m_pos , delta , pathOptimizationRange / dist ) ; static const int MAX_RES = 32 ; dtPolyRef res [ MAX_RES ] ; float t , norm [ 3 ] ; int nres = 0 ; navquery -> raycast ( m_path [ 0 ] , m_pos , goal , filter , & t , norm , res , & nres , MAX_RES ) ; if ( nres > 1 && t > 0.99f ) { m_npath = mergeCorridor ( m_path , m_npath , m_maxPath , res , nres ) ; } } bool PathCorridor :: optimizePathTopology ( dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; if ( m_npath < 3 ) return false ; static const int MAX_ITER = 32 ; static const int MAX_RES = 32 ; dtPolyRef res [ MAX_RES ] ; int nres = 0 ; navquery -> initSlicedFindPath ( m_path [ 0 ] , m_path [ m_npath - 1 ] , m_pos , m_target , filter ) ; navquery -> updateSlicedFindPath ( MAX_ITER ) ; dtStatus status = navquery -> finalizeSlicedFindPathPartial ( m_path , m_npath , res , & nres , MAX_RES ) ; if ( status == DT_SUCCESS && nres > 0 ) { m_npath = mergeCorridor ( m_path , m_npath , m_maxPath , res , nres ) ; return true ; } return false ; } void PathCorridor :: movePosition ( const float * npos , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; dtAssert ( m_npath ) ; float result [ 3 ] ; static const int MAX_VISITED = 16 ; dtPolyRef visited [ MAX_VISITED ] ; int nvisited = 0 ; navquery -> moveAlongSurface ( m_path [ 0 ] , m_pos , npos , filter , result , visited , & nvisited , MAX_VISITED ) ; m_npath = fixupCorridor ( m_path , m_npath , m_maxPath , visited , nvisited ) ; float h = m_pos [ 1 ] ; navquery -> getPolyHeight ( m_path [ 0 ] , result , & h ) ; result [ 1 ] = h ; dtVcopy ( m_pos , result ) ; } void PathCorridor :: moveTargetPosition ( const float * npos , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; dtAssert ( m_npath ) ; float result [ 3 ] ; static const int MAX_VISITED = 16 ; dtPolyRef visited [ MAX_VISITED ] ; int nvisited = 0 ; navquery -> moveAlongSurface ( m_path [ m_npath - 1 ] , m_target , npos , filter , result , visited , & nvisited , MAX_VISITED ) ; m_npath = fixupCorridorEnd ( m_path , m_npath , m_maxPath , visited , nvisited ) ; dtVcopy ( m_target , result ) ; } void PathCorridor :: setCorridor ( const float * target , const dtPolyRef * path , const int npath ) { dtAssert ( m_path ) ; dtAssert ( npath > 0 ) ; dtAssert ( npath < m_maxPath ) ; dtVcopy ( m_target , target ) ; memcpy ( m_path , path , sizeof ( dtPolyRef ) * npath ) ; m_npath = npath ; } void Agent :: integrate ( const float maxAcc , const float dt ) { const float maxDelta = maxAcc * dt ; float dv [ 3 ] ; dtVsub ( dv , nvel , vel ) ; float ds = dtVlen ( dv ) ; if ( ds > maxDelta ) dtVscale ( dv , dv , maxDelta / ds ) ; dtVadd ( vel , vel , dv ) ; if ( dtVlen ( vel ) > 0.0001f ) dtVmad ( npos , npos , vel , dt ) ; else dtVset ( vel , 0 , 0 , 0 ) ; } float Agent :: getDistanceToGoal ( const float range ) const { if ( ! ncorners ) return range ; const bool endOfPath = ( cornerFlags [ ncorners - 1 ] & DT_STRAIGHTPATH_END ) ? true : false ; const bool offMeshConnection = ( cornerFlags [ ncorners - 1 ] & DT_STRAIGHTPATH_OFFMESH_CONNECTION ) ? true : false ; if ( endOfPath || offMeshConnection ) return dtMin ( dtVdist2D ( npos , & cornerVerts [ ( ncorners - 1 ) * 3 ] ) , range ) ; return range ; } void Agent :: calcSmoothSteerDirection ( float * dir ) { if ( ! ncorners ) { dtVset ( dir , 0 , 0 , 0 ) ; return ; } const int ip0 = 0 ; const int ip1 = dtMin ( 1 , ncorners - 1 ) ; const float * p0 = & cornerVerts [ ip0 * 3 ] ; const float * p1 = & cornerVerts [ ip1 * 3 ] ; float dir0 [ 3 ] , dir1 [ 3 ] ; dtVsub ( dir0 , p0 , npos ) ; dtVsub ( dir1 , p1 , npos ) ; dir0 [ 1 ] = 0 ; dir1 [ 1 ] = 0 ; float len0 = dtVlen ( dir0 ) ; float len1 = dtVlen ( dir1 ) ; if ( len1 > 0.001f ) dtVscale ( dir1 , dir1 , 1.0f / len1 ) ; dir [ 0 ] = dir0 [ 0 ] - dir1 [ 0 ] * len0 * 0.5f ; dir [ 1 ] = 0 ; dir [ 2 ] = dir0 [ 2 ] - dir1 [ 2 ] * len0 * 0.5f ; dtVnormalize ( dir ) ; } void Agent :: calcStraightSteerDirection ( float * dir ) { if ( ! ncorners ) { dtVset ( dir , 0 , 0 , 0 ) ; return ; } dtVsub ( dir , & cornerVerts [ 0 ] , npos ) ; dir [ 1 ] = 0 ; dtVnormalize ( dir ) ; } LocalBoundary :: LocalBoundary ( ) : m_nsegs ( 0 ) { dtVset ( m_center , FLT_MAX , FLT_MAX , FLT_MAX ) ; } LocalBoundary :: ~ LocalBoundary ( ) { } void LocalBoundary :: reset ( ) { dtVset ( m_center , FLT_MAX , FLT_MAX , FLT_MAX ) ; m_nsegs = 0 ; } void LocalBoundary :: addSegment ( const float dist , const float * s ) { Segment * seg = 0 ; if ( ! m_nsegs ) { seg = & m_segs [ 0 ] ; } else if ( dist >= m_segs [ m_nsegs - 1 ] . d ) { if ( m_nsegs >= MAX_SEGS ) return ; seg = & m_segs [ m_nsegs ] ; } else { int i ; for ( i = 0 ; i < m_nsegs ; ++ i ) if ( dist <= m_segs [ i ] . d ) break ; const int tgt = i + 1 ; const int n = dtMin ( m_nsegs - i , MAX_SEGS - tgt ) ; dtAssert ( tgt + n <= MAX_SEGS ) ; if ( n > 0 ) memmove ( & m_segs [ tgt ] , & m_segs [ i ] , sizeof ( Segment ) * n ) ; seg = & m_segs [ i ] ; } seg -> d = dist ; memcpy ( seg -> s , s , sizeof ( float ) * 6 ) ; if ( m_nsegs < MAX_SEGS ) m_nsegs ++ ; } void LocalBoundary :: update ( dtPolyRef ref , const float * pos , const float collisionQueryRange , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { static const int MAX_LOCAL_POLYS = 16 ; static const int MAX_SEGS_PER_POLY = DT_VERTS_PER_POLYGON * 2 ; if ( ! ref ) { dtVset ( m_center , FLT_MAX , FLT_MAX , FLT_MAX ) ; m_nsegs = 0 ; return ; } dtVcopy ( m_center , pos ) ; dtPolyRef locals [ MAX_LOCAL_POLYS ] ; int nlocals = 0 ; navquery -> findLocalNeighbourhood ( ref , pos , collisionQueryRange , filter , locals , 0 , & nlocals , MAX_LOCAL_POLYS ) ; m_nsegs = 0 ; float segs [ MAX_SEGS_PER_POLY * 6 ] ; int nsegs = 0 ; for ( int j = 0 ; j < nlocals ; ++ j ) { navquery -> getPolyWallSegments ( locals [ j ] , filter , segs , & nsegs , MAX_SEGS_PER_POLY ) ; for ( int k = 0 ; k < nsegs ; ++ k ) { const float * s = & segs [ k * 6 ] ; float tseg ; const float distSqr = dtDistancePtSegSqr2D ( pos , s , s + 3 , tseg ) ; if ( distSqr > dtSqr ( collisionQueryRange ) ) continue ; addSegment ( distSqr , s ) ; } } } CrowdManager :: CrowdManager ( ) : m_obstacleQuery ( 0 ) , m_pathResult ( 0 ) , m_maxPathResult ( 0 ) , m_totalTime ( 0 ) , m_rvoTime ( 0 ) , m_sampleCount ( 0 ) , m_moveRequestCount ( 0 ) { dtVset ( m_ext , 2 , 4 , 2 ) ; m_obstacleQuery = dtAllocObstacleAvoidanceQuery ( ) ; m_obstacleQuery -> init ( 6 , 8 ) ; m_obstacleQuery -> setDesiredVelocityWeight ( 2.0f ) ; m_obstacleQuery -> setCurrentVelocityWeight ( 0.75f ) ; m_obstacleQuery -> setPreferredSideWeight ( 0.75f ) ; m_obstacleQuery -> setCollisionTimeWeight ( 2.5f ) ; m_obstacleQuery -> setTimeHorizon ( 2.5f ) ; m_obstacleQuery -> setVelocitySelectionBias ( 0.4f ) ; memset ( m_vodebug , 0 , sizeof ( m_vodebug ) ) ; const int maxAdaptiveSamples = ( VO_ADAPTIVE_DIVS * VO_ADAPTIVE_RINGS + 1 ) * VO_ADAPTIVE_DEPTH ; const int maxGridSamples = VO_GRID_SIZE * VO_GRID_SIZE ; const int sampleCount = dtMax ( maxAdaptiveSamples , maxGridSamples ) ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) { m_vodebug [ i ] = dtAllocObstacleAvoidanceDebugData ( ) ; m_vodebug [ i ] -> init ( sampleCount ) ; } m_maxPathResult = 256 ; m_pathResult = ( dtPolyRef * ) dtAlloc ( sizeof ( dtPolyRef ) * m_maxPathResult , DT_ALLOC_PERM ) ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) { m_agents [ i ] . corridor . init ( m_maxPathResult ) ; } m_grid . init ( 100 , 1.0f ) ; reset ( ) ; } CrowdManager :: ~ CrowdManager ( ) { delete [ ] m_pathResult ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) dtFreeObstacleAvoidanceDebugData ( m_vodebug [ i ] ) ; dtFreeObstacleAvoidanceQuery ( m_obstacleQuery ) ; } void CrowdManager :: reset ( ) { for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) m_agents [ i ] . active = 0 ; } const int CrowdManager :: getAgentCount ( ) const { return MAX_AGENTS ; } const Agent * CrowdManager :: getAgent ( const int idx ) { return & m_agents [ idx ] ; } int CrowdManager :: addAgent ( const float * pos , const float radius , const float height , dtNavMeshQuery * navquery ) { int idx = - 1 ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) { if ( ! m_agents [ i ] . active ) { idx = i ; break ; } } if ( idx == - 1 ) return - 1 ; Agent * ag = & m_agents [ idx ] ; float nearest [ 3 ] ; dtPolyRef ref ; navquery -> findNearestPoly ( pos , m_ext , & m_filter , & ref , nearest ) ; if ( ! ref ) { return - 1 ; } ag -> corridor . reset ( ref , nearest ) ; ag -> boundary . reset ( ) ; ag -> radius = radius ; ag -> height = height ; ag -> collisionQueryRange = radius * 8 ; ag -> pathOptimizationRange = radius * 30 ; ag -> topologyOptTime = 0 ; ag -> nneis = 0 ; dtVset ( ag -> dvel , 0 , 0 , 0 ) ; dtVset ( ag -> nvel , 0 , 0 , 0 ) ; dtVset ( ag -> vel , 0 , 0 , 0 ) ; dtVcopy ( ag -> npos , nearest ) ; ag -> maxspeed = 0 ; ag -> t = 0 ; dtVset ( ag -> opts , 0 , 0 , 0 ) ; dtVset ( ag -> opte , 0 , 0 , 0 ) ; ag -> active = 1 ; ag -> var = ( rand ( ) % 10 ) / 9.0f ; for ( int i = 0 ; i < AGENT_MAX_TRAIL ; ++ i ) dtVcopy ( & ag -> trail [ i * 3 ] , ag -> corridor . getPos ( ) ) ; ag -> htrail = 0 ; return idx ; } void CrowdManager :: removeAgent ( const int idx ) { if ( idx >= 0 && idx < MAX_AGENTS ) { m_agents [ idx ] . active = 0 ; } } bool CrowdManager :: requestMoveTarget ( const int idx , dtPolyRef ref , const float * pos ) { if ( idx < 0 || idx > MAX_AGENTS ) return false ; if ( ! ref ) return false ; MoveRequest * req = 0 ; for ( int i = 0 ; i < m_moveRequestCount ; ++ i ) { if ( m_moveRequests [ i ] . idx == idx ) { req = & m_moveRequests [ i ] ; break ; } } if ( ! req ) { if ( m_moveRequestCount >= MAX_AGENTS ) return false ; req = & m_moveRequests [ m_moveRequestCount ++ ] ; memset ( req , 0 , sizeof ( MoveRequest ) ) ; } req -> idx = idx ; req -> ref = ref ; dtVcopy ( req -> pos , pos ) ; req -> pathqRef = PATHQ_INVALID ; req -> state = MR_TARGET_REQUESTING ; req -> temp [ 0 ] = ref ; req -> ntemp = 1 ; return true ; } bool CrowdManager :: adjustMoveTarget ( const int idx , dtPolyRef ref , const float * pos ) { if ( idx < 0 || idx > MAX_AGENTS ) return false ; if ( ! ref ) return false ; MoveRequest * req = 0 ; for ( int i = 0 ; i < m_moveRequestCount ; ++ i ) { if ( m_moveRequests [ i ] . idx == idx ) { req = & m_moveRequests [ i ] ; break ; } } if ( ! req ) { if ( m_moveRequestCount >= MAX_AGENTS ) return false ; req = & m_moveRequests [ m_moveRequestCount ++ ] ; memset ( req , 0 , sizeof ( MoveRequest ) ) ; req -> state = MR_TARGET_ADJUST ; req -> idx = idx ; } req -> aref = ref ; dtVcopy ( req -> apos , pos ) ; return true ; } int CrowdManager :: getActiveAgents ( Agent * * agents , const int maxAgents ) { int n = 0 ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) { if ( ! m_agents [ i ] . active ) continue ; if ( n < maxAgents ) agents [ n ++ ] = & m_agents [ i ] ; } return n ; } static int addNeighbour ( const int idx , const float dist , Neighbour * neis , const int nneis , const int maxNeis ) { Neighbour * nei = 0 ; if ( ! nneis ) { nei = & neis [ nneis ] ; } else if ( dist >= neis [ nneis - 1 ] . dist ) { if ( nneis >= maxNeis ) return nneis ; nei = & neis [ nneis ] ; } else { int i ; for ( i = 0 ; i < nneis ; ++ i ) if ( dist <= neis [ i ] . dist ) break ; const int tgt = i + 1 ; const int n = dtMin ( nneis - i , maxNeis - tgt ) ; dtAssert ( tgt + n <= maxNeis ) ; if ( n > 0 ) memmove ( & neis [ tgt ] , & neis [ i ] , sizeof ( Neighbour ) * n ) ; nei = & neis [ i ] ; } memset ( nei , 0 , sizeof ( Neighbour ) ) ; nei -> idx = idx ; nei -> dist = dist ; return dtMin ( nneis + 1 , maxNeis ) ; } int CrowdManager :: getNeighbours ( const float * pos , const float height , const float range , const Agent * skip , Neighbour * result , const int maxResult ) { int n = 0 ; unsigned short ids [ MAX_AGENTS ] ; int nids = m_grid . queryItems ( pos [ 0 ] - range , pos [ 2 ] - range , pos [ 0 ] + range , pos [ 2 ] + range , ids , MAX_AGENTS ) ; for ( int i = 0 ; i < nids ; ++ i ) { Agent * ag = & m_agents [ ids [ i ] ] ; if ( ag == skip ) continue ; float diff [ 3 ] ; dtVsub ( diff , pos , ag -> npos ) ; if ( fabsf ( diff [ 1 ] ) >= ( height + ag -> height ) / 2.0f ) continue ; diff [ 1 ] = 0 ; const float distSqr = dtVlenSqr ( diff ) ; if ( distSqr > dtSqr ( range ) ) continue ; n = addNeighbour ( ids [ i ] , distSqr , result , n , maxResult ) ; } return n ; } void CrowdManager :: updateMoveRequest ( const float dt , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { for ( int i = 0 ; i < m_moveRequestCount ; ++ i ) { MoveRequest * req = & m_moveRequests [ i ] ; Agent * ag = & m_agents [ req -> idx ] ; if ( ! ag -> active ) req -> state = MR_TARGET_FAILED ; if ( req -> aref ) { if ( req -> state == MR_TARGET_ADJUST ) { ag -> corridor . moveTargetPosition ( req -> apos , navquery , filter ) ; req -> state = MR_TARGET_VALID ; } else { float result [ 3 ] ; static const int MAX_VISITED = 16 ; dtPolyRef visited [ MAX_VISITED ] ; int nvisited = 0 ; navquery -> moveAlongSurface ( req -> temp [ req -> ntemp - 1 ] , req -> pos , req -> apos , filter , result , visited , & nvisited , MAX_VISITED ) ; req -> ntemp = fixupCorridorEnd ( req -> temp , req -> ntemp , MAX_TEMP_PATH , visited , nvisited ) ; dtVcopy ( req -> pos , result ) ; dtVset ( req -> apos , 0 , 0 , 0 ) ; req -> aref = 0 ; } } if ( req -> state == MR_TARGET_REQUESTING ) { const dtPolyRef * path = ag -> corridor . getPath ( ) ; const int npath = ag -> corridor . getPathCount ( ) ; dtAssert ( npath ) ; float reqPos [ 3 ] ; dtVcopy ( reqPos , ag -> corridor . getPos ( ) ) ; dtPolyRef reqPath [ 8 ] ; reqPath [ 0 ] = path [ 0 ] ; int reqPathCount = 1 ; req -> pathqRef = m_pathq . request ( reqPath [ reqPathCount - 1 ] , req -> ref , reqPos , req -> pos , & m_filter ) ; if ( req -> pathqRef != PATHQ_INVALID ) { ag -> corridor . setCorridor ( reqPos , reqPath , reqPathCount ) ; req -> state = MR_TARGET_WAITING_FOR_PATH ; } } } m_pathq . update ( navquery ) ; for ( int i = 0 ; i < m_moveRequestCount ; ++ i ) { MoveRequest * req = & m_moveRequests [ i ] ; Agent * ag = & m_agents [ req -> idx ] ; if ( req -> state == MR_TARGET_WAITING_FOR_PATH ) { int state = m_pathq . getRequestState ( req -> pathqRef ) ; if ( state == PATHQ_STATE_INVALID ) { req -> pathqRef = PATHQ_INVALID ; req -> state = MR_TARGET_FAILED ; } else if ( state == PATHQ_STATE_READY ) { const dtPolyRef * path = ag -> corridor . getPath ( ) ; const int npath = ag -> corridor . getPathCount ( ) ; dtAssert ( npath ) ; float targetPos [ 3 ] ; dtVcopy ( targetPos , req -> pos ) ; dtPolyRef * res = m_pathResult ; bool valid = true ; int nres = m_pathq . getPathResult ( req -> pathqRef , res , m_maxPathResult ) ; if ( ! nres ) valid = false ; if ( req -> ntemp > 1 ) { nres = fixupCorridorEnd ( res , nres , m_maxPathResult , req -> temp , req -> ntemp ) ; } if ( valid && path [ npath - 1 ] != res [ 0 ] ) valid = false ; if ( valid ) { if ( npath > 1 ) { if ( ( npath - 1 ) + nres > m_maxPathResult ) nres = m_maxPathResult - ( npath - 1 ) ; memmove ( res + npath - 1 , res , sizeof ( dtPolyRef ) * nres ) ; memcpy ( res , path , sizeof ( dtPolyRef ) * ( npath - 1 ) ) ; nres += npath - 1 ; } if ( res [ nres - 1 ] != req -> ref ) { float nearest [ 3 ] ; if ( navquery -> closestPointOnPoly ( res [ nres - 1 ] , targetPos , nearest ) == DT_SUCCESS ) dtVcopy ( targetPos , nearest ) ; else valid = false ; } } if ( valid ) { ag -> corridor . setCorridor ( targetPos , res , nres ) ; req -> state = MR_TARGET_VALID ; } else { req -> state = MR_TARGET_FAILED ; } } } if ( req -> state == MR_TARGET_VALID || req -> state == MR_TARGET_FAILED ) { m_moveRequestCount -- ; if ( i != m_moveRequestCount ) memcpy ( & m_moveRequests [ i ] , & m_moveRequests [ m_moveRequestCount ] , sizeof ( MoveRequest ) ) ; -- i ; } } } static int addToOptQueue ( Agent * newag , Agent * * agents , const int nagents , const int maxAgents ) { int slot = 0 ; if ( ! nagents ) { slot = nagents ; } else if ( newag -> topologyOptTime <= agents [ nagents - 1 ] -> topologyOptTime ) { if ( nagents >= maxAgents ) return nagents ; slot = nagents ; } else { int i ; for ( i = 0 ; i < nagents ; ++ i ) if ( newag -> topologyOptTime >= agents [ i ] -> topologyOptTime ) break ; const int tgt = i + 1 ; const int n = dtMin ( nagents - i , maxAgents - tgt ) ; dtAssert ( tgt + n <= maxAgents ) ; if ( n > 0 ) memmove ( & agents [ tgt ] , & agents [ i ] , sizeof ( Agent * ) * n ) ; slot = i ; } agents [ slot ] = newag ; return dtMin ( nagents + 1 , maxAgents ) ; } void CrowdManager :: updateTopologyOptimization ( const float dt , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { Agent * agents [ MAX_AGENTS ] ; int nagents = getActiveAgents ( agents , MAX_AGENTS ) ; if ( ! nagents ) return ; const float OPT_TIME_THR = 0.5f ; const int OPT_MAX_AGENTS = 1 ; Agent * queue [ OPT_MAX_AGENTS ] ; int nqueue = 0 ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; ag -> topologyOptTime += dt ; if ( ag -> topologyOptTime >= OPT_TIME_THR ) { nqueue = addToOptQueue ( ag , queue , nqueue , OPT_MAX_AGENTS ) ; } } for ( int i = 0 ; i < nqueue ; ++ i ) { Agent * ag = queue [ i ] ; ag -> corridor . optimizePathTopology ( navquery , filter ) ; ag -> topologyOptTime = 0 ; } } void CrowdManager :: update ( const float dt , unsigned int flags , dtNavMeshQuery * navquery ) { m_sampleCount = 0 ; m_totalTime = 0 ; m_rvoTime = 0 ; if ( ! navquery ) return ; TimeVal startTime = getPerfTime ( ) ; Agent * agents [ MAX_AGENTS ] ; int nagents = getActiveAgents ( agents , MAX_AGENTS ) ; static const float MAX_ACC = 8.0f ; static const float MAX_SPEED = 3.5f ; updateMoveRequest ( dt , navquery , & m_filter ) ; if ( flags & CROWDMAN_OPTIMIZE_TOPO ) updateTopologyOptimization ( dt , navquery , & m_filter ) ; m_grid . clear ( ) ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; const float * p = ag -> npos ; const float r = ag -> radius ; m_grid . addItem ( ( unsigned short ) i , p [ 0 ] - r , p [ 2 ] - r , p [ 0 ] + r , p [ 2 ] + r ) ; } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; if ( dtVdist2DSqr ( ag -> npos , ag -> boundary . getCenter ( ) ) > dtSqr ( ag -> collisionQueryRange * 0.25f ) ) ag -> boundary . update ( ag -> corridor . getFirstPoly ( ) , ag -> npos , ag -> collisionQueryRange , navquery , & m_filter ) ; ag -> nneis = getNeighbours ( ag -> npos , ag -> height , ag -> collisionQueryRange , ag , ag -> neis , AGENT_MAX_NEIGHBOURS ) ; } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; ag -> ncorners = ag -> corridor . findCorners ( ag -> cornerVerts , ag -> cornerFlags , ag -> cornerPolys , AGENT_MAX_CORNERS , navquery , & m_filter ) ; if ( ( flags & CROWDMAN_OPTIMIZE_VIS ) && ag -> ncorners > 0 ) { const float * target = & ag -> cornerVerts [ dtMin ( 1 , ag -> ncorners - 1 ) * 3 ] ; dtVcopy ( ag -> opts , ag -> corridor . getPos ( ) ) ; dtVcopy ( ag -> opte , target ) ; ag -> corridor . optimizePathVisibility ( target , ag -> pathOptimizationRange , navquery , & m_filter ) ; } else { dtVset ( ag -> opts , 0 , 0 , 0 ) ; dtVset ( ag -> opte , 0 , 0 , 0 ) ; } } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; float dvel [ 3 ] = { 0 , 0 , 0 } ; if ( flags & CROWDMAN_ANTICIPATE_TURNS ) ag -> calcSmoothSteerDirection ( dvel ) ; else ag -> calcStraightSteerDirection ( dvel ) ; const float slowDownRadius = ag -> radius * 2 ; const float speedScale = ag -> getDistanceToGoal ( slowDownRadius ) / slowDownRadius ; if ( flags & CROWDMAN_DRUNK ) { ag -> t += dt * ( 1.0f - ag -> var * 0.25f ) ; ag -> maxspeed = MAX_SPEED * ( 1 + dtSqr ( cosf ( ag -> t * 2.0f ) ) * 0.3f ) ; dtVscale ( dvel , dvel , ag -> maxspeed * speedScale ) ; const float amp = cosf ( ag -> var * 13.69f + ag -> t * 3.123f ) * 0.2f ; const float nx = - dvel [ 2 ] ; const float nz = dvel [ 0 ] ; dvel [ 0 ] += nx * amp ; dvel [ 2 ] += nz * amp ; } else { ag -> maxspeed = MAX_SPEED ; dtVscale ( dvel , dvel , ag -> maxspeed * speedScale ) ; } dtVcopy ( ag -> dvel , dvel ) ; } TimeVal rvoStartTime = getPerfTime ( ) ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; if ( flags & CROWDMAN_USE_VO ) { m_obstacleQuery -> reset ( ) ; for ( int j = 0 ; j < ag -> nneis ; ++ j ) { const Agent * nei = & m_agents [ ag -> neis [ j ] . idx ] ; m_obstacleQuery -> addCircle ( nei -> npos , nei -> radius , nei -> vel , nei -> dvel ) ; } for ( int j = 0 ; j < ag -> boundary . getSegmentCount ( ) ; ++ j ) { const float * s = ag -> boundary . getSegment ( j ) ; if ( dtTriArea2D ( ag -> npos , s , s + 3 ) < 0.0f ) continue ; m_obstacleQuery -> addSegment ( s , s + 3 ) ; } bool adaptive = true ; if ( adaptive ) { m_obstacleQuery -> sampleVelocityAdaptive ( ag -> npos , ag -> radius , ag -> maxspeed , ag -> vel , ag -> dvel , ag -> nvel , VO_ADAPTIVE_DIVS , VO_ADAPTIVE_RINGS , VO_ADAPTIVE_DEPTH , m_vodebug [ i ] ) ; } else { m_obstacleQuery -> sampleVelocityGrid ( ag -> npos , ag -> radius , ag -> maxspeed , ag -> vel , ag -> dvel , ag -> nvel , VO_GRID_SIZE , m_vodebug [ i ] ) ; } } else { dtVcopy ( ag -> nvel , ag -> dvel ) ; } } TimeVal rvoEndTime = getPerfTime ( ) ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; ag -> integrate ( MAX_ACC , dt ) ; } for ( int iter = 0 ; iter < 4 ; ++ iter ) { for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; dtVset ( ag -> disp , 0 , 0 , 0 ) ; float w = 0 ; for ( int j = 0 ; j < ag -> nneis ; ++ j ) { const Agent * nei = & m_agents [ ag -> neis [ j ] . idx ] ; float diff [ 3 ] ; dtVsub ( diff , ag -> npos , nei -> npos ) ; if ( fabsf ( diff [ 1 ] ) >= ( ag -> height + nei -> height ) / 2.0f ) continue ; diff [ 1 ] = 0 ; float dist = dtVlenSqr ( diff ) ; if ( dist > dtSqr ( ag -> radius + nei -> radius ) ) continue ; dist = sqrtf ( dist ) ; float pen = ( ag -> radius + nei -> radius ) - dist ; if ( dist > 0.0001f ) pen = ( 1.0f / dist ) * ( pen * 0.5f ) * 0.7f ; dtVmad ( ag -> disp , ag -> disp , diff , pen ) ; w += 1.0f ; } if ( w > 0.0001f ) { const float iw = 1.0f / w ; dtVscale ( ag -> disp , ag -> disp , iw ) ; } } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; dtVadd ( ag -> npos , ag -> npos , ag -> disp ) ; } } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; ag -> corridor . movePosition ( ag -> npos , navquery , & m_filter ) ; dtVcopy ( ag -> npos , ag -> corridor . getPos ( ) ) ; } TimeVal endTime = getPerfTime ( ) ; int ns = 0 ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; if ( flags & CROWDMAN_USE_VO ) { m_vodebug [ i ] -> normalizeSamples ( ) ; ns += m_vodebug [ i ] -> getSampleCount ( ) ; } ag -> htrail = ( ag -> htrail + 1 ) % AGENT_MAX_TRAIL ; dtVcopy ( & ag -> trail [ ag -> htrail * 3 ] , ag -> npos ) ; } m_sampleCount = ns ; m_rvoTime = getPerfDeltaTimeUsec ( rvoStartTime , rvoEndTime ) ; m_totalTime = getPerfDeltaTimeUsec ( startTime , endTime ) ; } </DOCUMENT>
<DOCUMENT_ID="einon/affymetrix-power-tools/tree/master/sdk/calvin_files/parameter/test/ParameterFileDataTest.cpp"> # include " calvin _ files / parameter / src / ParameterFileData . h " # include < cppunit / extensions / HelperMacros . h > using namespace affymetrix_calvin_parameter ; class ParameterFileDataTest : public CPPUNIT_NS :: TestFixture { CPPUNIT_TEST_SUITE ( ParameterFileDataTest ) ; CPPUNIT_TEST ( testAccess ) ; CPPUNIT_TEST_SUITE_END ( ) ; public : void setUp ( ) ; void tearDown ( ) ; void testAccess ( ) ; } ; CPPUNIT_TEST_SUITE_REGISTRATION ( ParameterFileDataTest ) ; void ParameterFileDataTest :: setUp ( ) { } void ParameterFileDataTest :: tearDown ( ) { } void ParameterFileDataTest :: testAccess ( ) { ParameterFileData d ; d . ImplementationAttributes ( ) . description = L " d " ; d . ImplementationAttributes ( ) . executableFileName = L " e " ; d . ImplementationAttributes ( ) . name = L " n " ; d . ImplementationAttributes ( ) . version = L " v " ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . description == L " d " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . executableFileName == L " e " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . name == L " n " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . version == L " v " ) ; d . ParameterFileAttributes ( ) . company = L " c " ; d . ParameterFileAttributes ( ) . userName = L " u " ; d . ParameterFileAttributes ( ) . contentVersion = L " cv " ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . company == L " c " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . userName == L " u " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . contentVersion == L " cv " ) ; ParameterType p ; p . name = L " n " ; p . index = L " i " ; p . displayName = L " d " ; p . category = L " c " ; p . isEditable = L " is " ; p . type = L " t " ; p . currentValue = L " cv " ; p . minValue = L " mv " ; p . maxValue = L " xv " ; p . defaultValue = L " dv " ; p . precision = L " p " ; p . maxLength = L " l " ; p . description = L " de " ; CPPUNIT_ASSERT ( p . name == L " n " ) ; CPPUNIT_ASSERT ( p . index == L " i " ) ; CPPUNIT_ASSERT ( p . displayName == L " d " ) ; CPPUNIT_ASSERT ( p . category == L " c " ) ; CPPUNIT_ASSERT ( p . isEditable == L " is " ) ; CPPUNIT_ASSERT ( p . type == L " t " ) ; CPPUNIT_ASSERT ( p . currentValue == L " cv " ) ; CPPUNIT_ASSERT ( p . minValue == L " mv " ) ; CPPUNIT_ASSERT ( p . maxValue == L " xv " ) ; CPPUNIT_ASSERT ( p . defaultValue == L " dv " ) ; CPPUNIT_ASSERT ( p . precision == L " p " ) ; CPPUNIT_ASSERT ( p . maxLength == L " l " ) ; CPPUNIT_ASSERT ( p . description == L " de " ) ; d . Parameters ( ) . push_back ( p ) ; p . name . clear ( ) ; p . index . clear ( ) ; CPPUNIT_ASSERT ( d . Parameters ( ) . size ( ) == 1 ) ; d . Clear ( ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . description == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . executableFileName == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . name == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . version == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . company == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . userName == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . contentVersion == L " " ) ; CPPUNIT_ASSERT ( d . Parameters ( ) . size ( ) == 0 ) ; } </DOCUMENT>
<DOCUMENT_ID="MorcoFreeCode/2015__MorcoEngine3D/tree/master/MorcoEngine3D v0.13/Source/Libraries/glm/Include/detail/glm.cpp"> # include < glm / glm . hpp > # include < glm / gtc / quaternion . hpp > # include < glm / gtx / dual_quaternion . hpp > namespace glm { namespace detail { template struct tvec2 < uint8 , lowp > ; template struct tvec2 < uint16 , lowp > ; template struct tvec2 < uint32 , lowp > ; template struct tvec2 < uint64 , lowp > ; template struct tvec2 < int8 , lowp > ; template struct tvec2 < int16 , lowp > ; template struct tvec2 < int32 , lowp > ; template struct tvec2 < int64 , lowp > ; template struct tvec2 < float32 , lowp > ; template struct tvec2 < float64 , lowp > ; template struct tvec2 < uint8 , mediump > ; template struct tvec2 < uint16 , mediump > ; template struct tvec2 < uint32 , mediump > ; template struct tvec2 < uint64 , mediump > ; template struct tvec2 < int8 , mediump > ; template struct tvec2 < int16 , mediump > ; template struct tvec2 < int32 , mediump > ; template struct tvec2 < int64 , mediump > ; template struct tvec2 < float32 , mediump > ; template struct tvec2 < float64 , mediump > ; template struct tvec2 < uint8 , highp > ; template struct tvec2 < uint16 , highp > ; template struct tvec2 < uint32 , highp > ; template struct tvec2 < uint64 , highp > ; template struct tvec2 < int8 , highp > ; template struct tvec2 < int16 , highp > ; template struct tvec2 < int32 , highp > ; template struct tvec2 < int64 , highp > ; template struct tvec2 < float32 , highp > ; template struct tvec2 < float64 , highp > ; template struct tvec3 < uint8 , lowp > ; template struct tvec3 < uint16 , lowp > ; template struct tvec3 < uint32 , lowp > ; template struct tvec3 < uint64 , lowp > ; template struct tvec3 < int8 , lowp > ; template struct tvec3 < int16 , lowp > ; template struct tvec3 < int32 , lowp > ; template struct tvec3 < int64 , lowp > ; template struct tvec3 < float32 , lowp > ; template struct tvec3 < float64 , lowp > ; template struct tvec3 < uint8 , mediump > ; template struct tvec3 < uint16 , mediump > ; template struct tvec3 < uint32 , mediump > ; template struct tvec3 < uint64 , mediump > ; template struct tvec3 < int8 , mediump > ; template struct tvec3 < int16 , mediump > ; template struct tvec3 < int32 , mediump > ; template struct tvec3 < int64 , mediump > ; template struct tvec3 < float32 , mediump > ; template struct tvec3 < float64 , mediump > ; template struct tvec3 < uint8 , highp > ; template struct tvec3 < uint16 , highp > ; template struct tvec3 < uint32 , highp > ; template struct tvec3 < uint64 , highp > ; template struct tvec3 < int8 , highp > ; template struct tvec3 < int16 , highp > ; template struct tvec3 < int32 , highp > ; template struct tvec3 < int64 , highp > ; template struct tvec3 < float32 , highp > ; template struct tvec3 < float64 , highp > ; template struct tvec4 < uint8 , lowp > ; template struct tvec4 < uint16 , lowp > ; template struct tvec4 < uint32 , lowp > ; template struct tvec4 < uint64 , lowp > ; template struct tvec4 < int8 , lowp > ; template struct tvec4 < int16 , lowp > ; template struct tvec4 < int32 , lowp > ; template struct tvec4 < int64 , lowp > ; template struct tvec4 < float32 , lowp > ; template struct tvec4 < float64 , lowp > ; template struct tvec4 < uint8 , mediump > ; template struct tvec4 < uint16 , mediump > ; template struct tvec4 < uint32 , mediump > ; template struct tvec4 < uint64 , mediump > ; template struct tvec4 < int8 , mediump > ; template struct tvec4 < int16 , mediump > ; template struct tvec4 < int32 , mediump > ; template struct tvec4 < int64 , mediump > ; template struct tvec4 < float32 , mediump > ; template struct tvec4 < float64 , mediump > ; template struct tvec4 < uint8 , highp > ; template struct tvec4 < uint16 , highp > ; template struct tvec4 < uint32 , highp > ; template struct tvec4 < uint64 , highp > ; template struct tvec4 < int8 , highp > ; template struct tvec4 < int16 , highp > ; template struct tvec4 < int32 , highp > ; template struct tvec4 < int64 , highp > ; template struct tvec4 < float32 , highp > ; template struct tvec4 < float64 , highp > ; template struct tmat2x2 < float32 , lowp > ; template struct tmat2x2 < float64 , lowp > ; template struct tmat2x2 < float32 , mediump > ; template struct tmat2x2 < float64 , mediump > ; template struct tmat2x2 < float32 , highp > ; template struct tmat2x2 < float64 , highp > ; template struct tmat2x3 < float32 , lowp > ; template struct tmat2x3 < float64 , lowp > ; template struct tmat2x3 < float32 , mediump > ; template struct tmat2x3 < float64 , mediump > ; template struct tmat2x3 < float32 , highp > ; template struct tmat2x3 < float64 , highp > ; template struct tmat2x4 < float32 , lowp > ; template struct tmat2x4 < float64 , lowp > ; template struct tmat2x4 < float32 , mediump > ; template struct tmat2x4 < float64 , mediump > ; template struct tmat2x4 < float32 , highp > ; template struct tmat2x4 < float64 , highp > ; template struct tmat3x2 < float32 , lowp > ; template struct tmat3x2 < float64 , lowp > ; template struct tmat3x2 < float32 , mediump > ; template struct tmat3x2 < float64 , mediump > ; template struct tmat3x2 < float32 , highp > ; template struct tmat3x2 < float64 , highp > ; template struct tmat3x3 < float32 , lowp > ; template struct tmat3x3 < float64 , lowp > ; template struct tmat3x3 < float32 , mediump > ; template struct tmat3x3 < float64 , mediump > ; template struct tmat3x3 < float32 , highp > ; template struct tmat3x3 < float64 , highp > ; template struct tmat3x4 < float32 , lowp > ; template struct tmat3x4 < float64 , lowp > ; template struct tmat3x4 < float32 , mediump > ; template struct tmat3x4 < float64 , mediump > ; template struct tmat3x4 < float32 , highp > ; template struct tmat3x4 < float64 , highp > ; template struct tmat4x2 < float32 , lowp > ; template struct tmat4x2 < float64 , lowp > ; template struct tmat4x2 < float32 , mediump > ; template struct tmat4x2 < float64 , mediump > ; template struct tmat4x2 < float32 , highp > ; template struct tmat4x2 < float64 , highp > ; template struct tmat4x3 < float32 , lowp > ; template struct tmat4x3 < float64 , lowp > ; template struct tmat4x3 < float32 , mediump > ; template struct tmat4x3 < float64 , mediump > ; template struct tmat4x3 < float32 , highp > ; template struct tmat4x3 < float64 , highp > ; template struct tmat4x4 < float32 , lowp > ; template struct tmat4x4 < float64 , lowp > ; template struct tmat4x4 < float32 , mediump > ; template struct tmat4x4 < float64 , mediump > ; template struct tmat4x4 < float32 , highp > ; template struct tmat4x4 < float64 , highp > ; template struct tquat < float32 , lowp > ; template struct tquat < float64 , lowp > ; template struct tquat < float32 , mediump > ; template struct tquat < float64 , mediump > ; template struct tquat < float32 , highp > ; template struct tquat < float64 , highp > ; template struct tdualquat < float32 , lowp > ; template struct tdualquat < float64 , lowp > ; template struct tdualquat < float32 , mediump > ; template struct tdualquat < float64 , mediump > ; template struct tdualquat < float32 , highp > ; template struct tdualquat < float64 , highp > ; } } </DOCUMENT>
<DOCUMENT_ID="fstudio/Phoenix/tree/master/test/Experimental/libcxx/test/std/strings/char.traits/char.traits.specializations/char.traits.specializations.char16_t/eof.pass.cpp"> # include < string > # include < cassert > int main ( ) { # ifndef _LIBCPP_HAS_NO_UNICODE_CHARS std :: char_traits < char16_t > :: int_type i = std :: char_traits < char16_t > :: eof ( ) ; # endif } </DOCUMENT>
<DOCUMENT_ID="CodeDJ/qt5-hidpi/tree/master/qt/qtdeclarative/src/quick/util/qquickanimatorcontroller.cpp"> # include " qquickanimatorcontroller _ p . h " # include < private / qquickwindow_p . h > # include < private / qsgrenderloop_p . h > # include < private / qanimationgroupjob_p . h > # include < QtGui / qscreen . h > # include < QtCore / qcoreapplication . h > QT_BEGIN_NAMESPACE QQuickAnimatorController :: QQuickAnimatorController ( ) : m_window ( 0 ) { } QQuickAnimatorController :: ~ QQuickAnimatorController ( ) { foreach ( QAbstractAnimationJob * job , m_deleting ) { m_starting . take ( job ) ; m_stopping . take ( job ) ; m_animatorRoots . take ( job ) ; delete job ; } foreach ( QQuickAnimatorProxyJob * proxy , m_animatorRoots ) proxy -> controllerWasDeleted ( ) ; qDeleteAll ( m_animatorRoots . keys ( ) ) ; foreach ( QAbstractAnimationJob * job , m_starting . keys ( ) ) { if ( ! m_animatorRoots . contains ( job ) ) delete job ; } } void QQuickAnimatorController :: itemDestroyed ( QObject * o ) { m_deletedSinceLastFrame << ( QQuickItem * ) o ; } void QQuickAnimatorController :: advance ( ) { bool running = false ; for ( QHash < QAbstractAnimationJob * , QQuickAnimatorProxyJob * > :: const_iterator it = m_animatorRoots . constBegin ( ) ; ! running && it != m_animatorRoots . constEnd ( ) ; ++ it ) { if ( it . key ( ) -> isRunning ( ) ) running = true ; } lock ( ) ; for ( QHash < QQuickItem * , QQuickTransformAnimatorJob :: Helper * > :: const_iterator it = m_transforms . constBegin ( ) ; it != m_transforms . constEnd ( ) ; ++ it ) { QQuickTransformAnimatorJob :: Helper * xform = * it ; if ( ! xform -> item ) continue ; ( * it ) -> apply ( ) ; } unlock ( ) ; if ( running ) m_window -> update ( ) ; } static void qquick_initialize_helper ( QAbstractAnimationJob * job , QQuickAnimatorController * c ) { if ( job -> isRenderThreadJob ( ) ) { QQuickAnimatorJob * j = static_cast < QQuickAnimatorJob * > ( job ) ; if ( ! j -> target ( ) ) { return ; } else if ( c -> m_deletedSinceLastFrame . contains ( j -> target ( ) ) ) { j -> targetWasDeleted ( ) ; } else { j -> addAnimationChangeListener ( c , QAbstractAnimationJob :: StateChange ) ; j -> initialize ( c ) ; } } else if ( job -> isGroup ( ) ) { QAnimationGroupJob * g = static_cast < QAnimationGroupJob * > ( job ) ; for ( QAbstractAnimationJob * a = g -> firstChild ( ) ; a ; a = a -> nextSibling ( ) ) qquick_initialize_helper ( a , c ) ; } } void QQuickAnimatorController :: beforeNodeSync ( ) { foreach ( QAbstractAnimationJob * job , m_deleting ) { m_starting . take ( job ) ; m_stopping . take ( job ) ; m_animatorRoots . take ( job ) ; job -> stop ( ) ; delete job ; } m_deleting . clear ( ) ; if ( m_starting . size ( ) ) m_window -> update ( ) ; foreach ( QQuickAnimatorProxyJob * proxy , m_starting ) { QAbstractAnimationJob * job = proxy -> job ( ) ; job -> addAnimationChangeListener ( this , QAbstractAnimationJob :: Completion ) ; qquick_initialize_helper ( job , this ) ; m_animatorRoots [ job ] = proxy ; job -> start ( ) ; proxy -> startedByController ( ) ; } m_starting . clear ( ) ; foreach ( QQuickAnimatorProxyJob * proxy , m_stopping ) { QAbstractAnimationJob * job = proxy -> job ( ) ; job -> stop ( ) ; } m_stopping . clear ( ) ; foreach ( QQuickAnimatorJob * job , m_activeLeafAnimations ) { if ( ! job -> target ( ) ) continue ; else if ( m_deletedSinceLastFrame . contains ( job -> target ( ) ) ) job -> targetWasDeleted ( ) ; else if ( job -> isTransform ( ) ) { QQuickTransformAnimatorJob * xform = static_cast < QQuickTransformAnimatorJob * > ( job ) ; xform -> transformHelper ( ) -> sync ( ) ; } } foreach ( QQuickItem * wiped , m_deletedSinceLastFrame ) { QQuickTransformAnimatorJob :: Helper * helper = m_transforms . value ( wiped ) ; if ( helper ) helper -> item = 0 ; } m_deletedSinceLastFrame . clear ( ) ; } void QQuickAnimatorController :: afterNodeSync ( ) { foreach ( QQuickAnimatorJob * job , m_activeLeafAnimations ) { if ( job -> isUniform ( ) && job -> target ( ) ) static_cast < QQuickUniformAnimatorJob * > ( job ) -> afterNodeSync ( ) ; } } void QQuickAnimatorController :: animationFinished ( QAbstractAnimationJob * job ) { if ( ! m_deleting . contains ( job ) ) { QQuickAnimatorProxyJob * proxy = m_animatorRoots [ job ] ; if ( proxy ) QCoreApplication :: postEvent ( proxy , new QEvent ( QEvent :: User ) ) ; } } void QQuickAnimatorController :: animationStateChanged ( QAbstractAnimationJob * job , QAbstractAnimationJob :: State newState , QAbstractAnimationJob :: State oldState ) { Q_ASSERT ( job -> isRenderThreadJob ( ) ) ; QQuickAnimatorJob * animator = static_cast < QQuickAnimatorJob * > ( job ) ; if ( newState == QAbstractAnimationJob :: Running ) { m_activeLeafAnimations << animator ; animator -> setHasBeenRunning ( true ) ; } else if ( oldState == QAbstractAnimationJob :: Running ) { m_activeLeafAnimations . remove ( animator ) ; } } void QQuickAnimatorController :: requestSync ( ) { m_window -> maybeUpdate ( ) ; } void QQuickAnimatorController :: startJob ( QQuickAnimatorProxyJob * proxy , QAbstractAnimationJob * job ) { m_starting [ job ] = proxy ; requestSync ( ) ; } void QQuickAnimatorController :: stopJob ( QQuickAnimatorProxyJob * proxy , QAbstractAnimationJob * job ) { m_stopping [ job ] = proxy ; requestSync ( ) ; } void QQuickAnimatorController :: deleteJob ( QAbstractAnimationJob * job ) { lock ( ) ; m_deleting << job ; requestSync ( ) ; unlock ( ) ; } QT_END_NAMESPACE </DOCUMENT>
<DOCUMENT_ID="bredelings/BAli-Phy/tree/master/external/range-v3/0.4.0/test/algorithm/minmax.cpp"> # include < range / v3 / algorithm / minmax . hpp > # include < memory > # include < numeric > # include < random > # include < algorithm > # include " . . / simple _ test . hpp " # include " . . / test _ utils . hpp " # include " . . / test _ iterators . hpp " RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS namespace { std :: mt19937 gen ; template < class Iter , class Sent = Iter > void test_iter ( Iter first , Sent last ) { RANGES_ENSURE ( first != last ) ; auto rng = ranges :: make_iterator_range ( first , last ) ; auto res = ranges :: minmax ( rng ) ; for ( Iter i = first ; i != last ; ++ i ) { CHECK ( ! ( * i < res . first ) ) ; CHECK ( ! ( res . second < * i ) ) ; } } template < class Iter , class Sent = Iter > void test_iter ( unsigned N ) { RANGES_ENSURE ( N > 0 ) ; std :: unique_ptr < int [ ] > a { new int [ N ] } ; std :: iota ( a . get ( ) , a . get ( ) + N , 0 ) ; std :: shuffle ( a . get ( ) , a . get ( ) + N , gen ) ; test_iter ( Iter ( a . get ( ) ) , Sent ( a . get ( ) + N ) ) ; } template < class Iter , class Sent = Iter > void test_iter ( ) { test_iter < Iter , Sent > ( 1 ) ; test_iter < Iter , Sent > ( 2 ) ; test_iter < Iter , Sent > ( 3 ) ; test_iter < Iter , Sent > ( 10 ) ; test_iter < Iter , Sent > ( 1000 ) ; } template < class Iter , class Sent = Iter > void test_iter_comp ( Iter first , Sent last ) { RANGES_ENSURE ( first != last ) ; typedef std :: greater < int > Compare ; Compare comp ; auto rng = ranges :: make_iterator_range ( first , last ) ; auto res = ranges :: minmax ( rng , comp ) ; for ( Iter i = first ; i != last ; ++ i ) { CHECK ( ! comp ( * i , res . first ) ) ; CHECK ( ! comp ( res . second , * i ) ) ; } } template < class Iter , class Sent = Iter > void test_iter_comp ( unsigned N ) { RANGES_ENSURE ( N > 0 ) ; std :: unique_ptr < int [ ] > a { new int [ N ] } ; std :: iota ( a . get ( ) , a . get ( ) + N , 0 ) ; std :: shuffle ( a . get ( ) , a . get ( ) + N , gen ) ; test_iter_comp ( Iter ( a . get ( ) ) , Sent ( a . get ( ) + N ) ) ; } template < class Iter , class Sent = Iter > void test_iter_comp ( ) { test_iter_comp < Iter , Sent > ( 1 ) ; test_iter_comp < Iter , Sent > ( 2 ) ; test_iter_comp < Iter , Sent > ( 3 ) ; test_iter_comp < Iter , Sent > ( 10 ) ; test_iter_comp < Iter , Sent > ( 1000 ) ; } struct S { int value ; int index ; } ; } int main ( ) { test_iter < input_iterator < const int * > > ( ) ; test_iter < forward_iterator < const int * > > ( ) ; test_iter < bidirectional_iterator < const int * > > ( ) ; test_iter < random_access_iterator < const int * > > ( ) ; test_iter < const int * > ( ) ; test_iter < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < input_iterator < const int * > > ( ) ; test_iter < forward_iterator < const int * > > ( ) ; test_iter < bidirectional_iterator < const int * > > ( ) ; test_iter < random_access_iterator < const int * > > ( ) ; test_iter < const int * > ( ) ; test_iter < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < input_iterator < const int * > > ( ) ; test_iter_comp < forward_iterator < const int * > > ( ) ; test_iter_comp < bidirectional_iterator < const int * > > ( ) ; test_iter_comp < random_access_iterator < const int * > > ( ) ; test_iter_comp < const int * > ( ) ; test_iter_comp < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < input_iterator < const int * > > ( ) ; test_iter_comp < forward_iterator < const int * > > ( ) ; test_iter_comp < bidirectional_iterator < const int * > > ( ) ; test_iter_comp < random_access_iterator < const int * > > ( ) ; test_iter_comp < const int * > ( ) ; test_iter_comp < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; S s [ ] = { S { 1 , 0 } , S { 2 , 1 } , S { 3 , 2 } , S { 4 , 3 } , S { - 4 , 4 } , S { 40 , 5 } , S { - 4 , 6 } , S { 40 , 7 } , S { 7 , 8 } , S { 8 , 9 } , S { 9 , 10 } } ; auto res = ranges :: minmax ( s , std :: less < int > { } , & S :: value ) ; CHECK ( res . first . value == - 4 ) ; CHECK ( res . first . index == 4 ) ; CHECK ( res . second . value == 40 ) ; CHECK ( res . second . index == 7 ) ; return test_result ( ) ; } </DOCUMENT>
<DOCUMENT_ID="samdnic/Tarantula/tree/master/boost/libs/coroutine/src/detail/standard_stack_allocator_posix.cpp"> # define BOOST_COROUTINES_SOURCE # include " boost / coroutine / detail / standard _ stack _ allocator . hpp " extern " C " { # include < fcntl . h > # include < signal . h > # include < sys / mman . h > # include < sys / resource . h > # include < sys / stat . h > # include < sys / time . h > # include < sys / types . h > # include < unistd . h > } # include < algorithm > # include < cmath > # include < cstring > # include < stdexcept > # include < boost / assert . hpp > # include < boost / context / fcontext . hpp > # include < boost / coroutine / stack_context . hpp > # if ! defined ( SIGSTKSZ ) # define SIGSTKSZ ( 8 * 1024 ) # define UDEF_SIGSTKSZ # endif # ifdef BOOST_HAS_ABI_HEADERS # include BOOST_ABI_PREFIX # endif namespace boost { namespace coroutines { namespace detail { std :: size_t pagesize ( ) { static std :: size_t size = :: sysconf ( _SC_PAGESIZE ) ; return size ; } rlimit stacksize_limit_ ( ) { rlimit limit ; # if defined ( BOOST_DISABLE_ASSERTS ) :: getrlimit ( RLIMIT_STACK , & limit ) ; # else const int result = :: getrlimit ( RLIMIT_STACK , & limit ) ; BOOST_ASSERT ( 0 == result ) ; # endif return limit ; } rlimit stacksize_limit ( ) { static rlimit limit = stacksize_limit_ ( ) ; return limit ; } std :: size_t page_count ( std :: size_t stacksize ) { return static_cast < std :: size_t > ( std :: ceil ( static_cast < float > ( stacksize ) / pagesize ( ) ) ) ; } bool standard_stack_allocator :: is_stack_unbound ( ) { return RLIM_INFINITY == detail :: stacksize_limit ( ) . rlim_max ; } std :: size_t standard_stack_allocator :: default_stacksize ( ) { std :: size_t size = 8 * minimum_stacksize ( ) ; if ( is_stack_unbound ( ) ) return size ; BOOST_ASSERT ( maximum_stacksize ( ) >= minimum_stacksize ( ) ) ; return maximum_stacksize ( ) == size ? size : ( std :: min ) ( size , maximum_stacksize ( ) ) ; } std :: size_t standard_stack_allocator :: minimum_stacksize ( ) { return SIGSTKSZ + sizeof ( context :: fcontext_t ) + 15 ; } std :: size_t standard_stack_allocator :: maximum_stacksize ( ) { BOOST_ASSERT ( ! is_stack_unbound ( ) ) ; return static_cast < std :: size_t > ( detail :: stacksize_limit ( ) . rlim_max ) ; } void standard_stack_allocator :: allocate ( stack_context & ctx , std :: size_t size ) { BOOST_ASSERT ( minimum_stacksize ( ) <= size ) ; BOOST_ASSERT ( is_stack_unbound ( ) || ( maximum_stacksize ( ) >= size ) ) ; const std :: size_t pages ( detail :: page_count ( size ) + 1 ) ; const std :: size_t size_ ( pages * detail :: pagesize ( ) ) ; BOOST_ASSERT ( 0 < size && 0 < size_ ) ; const int fd ( :: open ( " / dev / zero " , O_RDONLY ) ) ; BOOST_ASSERT ( - 1 != fd ) ; void * limit = # if defined ( macintosh ) || defined ( __APPLE__ ) || defined ( __APPLE_CC__ ) :: mmap ( 0 , size_ , PROT_READ | PROT_WRITE , MAP_PRIVATE | MAP_ANON , - 1 , 0 ) ; # else :: mmap ( 0 , size_ , PROT_READ | PROT_WRITE , MAP_PRIVATE , fd , 0 ) ; # endif :: close ( fd ) ; if ( ! limit ) throw std :: bad_alloc ( ) ; std :: memset ( limit , ' \0' , size_ ) ; # if defined ( BOOST_DISABLE_ASSERTS ) :: mprotect ( limit , detail :: pagesize ( ) , PROT_NONE ) ; # else const int result ( :: mprotect ( limit , detail :: pagesize ( ) , PROT_NONE ) ) ; BOOST_ASSERT ( 0 == result ) ; # endif ctx . size = size_ ; ctx . sp = static_cast < char * > ( limit ) + ctx . size ; } void standard_stack_allocator :: deallocate ( stack_context & ctx ) { BOOST_ASSERT ( ctx . sp ) ; BOOST_ASSERT ( minimum_stacksize ( ) <= ctx . size ) ; BOOST_ASSERT ( is_stack_unbound ( ) || ( maximum_stacksize ( ) >= ctx . size ) ) ; void * limit = static_cast < char * > ( ctx . sp ) - ctx . size ; :: munmap ( limit , ctx . size ) ; } } } } # ifdef BOOST_HAS_ABI_HEADERS # include BOOST_ABI_SUFFIX # endif # ifdef UDEF_SIGSTKSZ # undef SIGSTKSZ # endif </DOCUMENT>
<DOCUMENT_ID="cryptometh/cryptometh_1/tree/master/src/cryptopp/vmac.cpp"> # include " pch . h " # include " vmac . h " # include " argnames . h " # include " cpu . h " NAMESPACE_BEGIN ( CryptoPP ) # if defined ( _MSC_VER ) && ! CRYPTOPP_BOOL_SLOW_WORD64 # include < intrin . h > # endif # define VMAC_BOOL_WORD128 ( defined ( CRYPTOPP_WORD128_AVAILABLE ) && ! defined ( CRYPTOPP_X64_ASM_AVAILABLE ) ) # ifdef __BORLANDC__ # define const # endif static const word64 p64 = W64LIT ( 0xfffffffffffffeff ) ; static const word64 m62 = W64LIT ( 0x3fffffffffffffff ) ; static const word64 m63 = W64LIT ( 0x7fffffffffffffff ) ; static const word64 m64 = W64LIT ( 0xffffffffffffffff ) ; static const word64 mpoly = W64LIT ( 0x1fffffff1fffffff ) ; # ifdef __BORLANDC__ # undef const # endif # if VMAC_BOOL_WORD128 # ifdef __powerpc__ # define m126 ( ( word128 ( m62 ) << 64 ) | m64 ) # else static const word128 m126 = ( word128 ( m62 ) << 64 ) | m64 ; # endif # endif void VMAC_Base :: UncheckedSetKey ( const byte * userKey , unsigned int keylength , const NameValuePairs & params ) { int digestLength = params . GetIntValueWithDefault ( Name :: DigestSize ( ) , DefaultDigestSize ( ) ) ; if ( digestLength != 8 && digestLength != 16 ) throw InvalidArgument ( " VMAC : ▁ DigestSize ▁ must ▁ be ▁ 8 ▁ or ▁ 16" ) ; m_is128 = digestLength == 16 ; m_L1KeyLength = params . GetIntValueWithDefault ( Name :: L1KeyLength ( ) , 128 ) ; if ( m_L1KeyLength <= 0 || m_L1KeyLength % 128 != 0 ) throw InvalidArgument ( " VMAC : ▁ L1KeyLength ▁ must ▁ be ▁ a ▁ positive ▁ multiple ▁ of ▁ 128" ) ; AllocateBlocks ( ) ; BlockCipher & cipher = AccessCipher ( ) ; cipher . SetKey ( userKey , keylength , params ) ; unsigned int blockSize = cipher . BlockSize ( ) ; unsigned int blockSizeInWords = blockSize / sizeof ( word64 ) ; SecBlock < word64 > out ( blockSizeInWords ) ; SecByteBlock in ; in . CleanNew ( blockSize ) ; size_t i ; in [ 0 ] = 0x80 ; cipher . AdvancedProcessBlocks ( in , NULL , ( byte * ) m_nhKey ( ) , m_nhKeySize ( ) * sizeof ( word64 ) , cipher . BT_InBlockIsCounter ) ; ConditionalByteReverse < word64 > ( BIG_ENDIAN_ORDER , m_nhKey ( ) , m_nhKey ( ) , m_nhKeySize ( ) * sizeof ( word64 ) ) ; in [ 0 ] = 0xC0 ; in [ 15 ] = 0 ; for ( i = 0 ; i <= ( size_t ) m_is128 ; i ++ ) { cipher . ProcessBlock ( in , out . BytePtr ( ) ) ; m_polyState ( ) [ i * 4 + 2 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) ) & mpoly ; m_polyState ( ) [ i * 4 + 3 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) + 8 ) & mpoly ; in [ 15 ] ++ ; } in [ 0 ] = 0xE0 ; in [ 15 ] = 0 ; word64 * l3Key = m_l3Key ( ) ; for ( i = 0 ; i <= ( size_t ) m_is128 ; i ++ ) do { cipher . ProcessBlock ( in , out . BytePtr ( ) ) ; l3Key [ i * 2 + 0 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) ) ; l3Key [ i * 2 + 1 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) + 8 ) ; in [ 15 ] ++ ; } while ( ( l3Key [ i * 2 + 0 ] >= p64 ) || ( l3Key [ i * 2 + 1 ] >= p64 ) ) ; m_padCached = false ; size_t nonceLength ; const byte * nonce = GetIVAndThrowIfInvalid ( params , nonceLength ) ; Resynchronize ( nonce , ( int ) nonceLength ) ; } void VMAC_Base :: GetNextIV ( RandomNumberGenerator & rng , byte * IV ) { SimpleKeyingInterface :: GetNextIV ( rng , IV ) ; IV [ 0 ] &= 0x7f ; } void VMAC_Base :: Resynchronize ( const byte * nonce , int len ) { size_t length = ThrowIfInvalidIVLength ( len ) ; size_t s = IVSize ( ) ; byte * storedNonce = m_nonce ( ) ; if ( m_is128 ) { memset ( storedNonce , 0 , s - length ) ; memcpy ( storedNonce + s - length , nonce , length ) ; AccessCipher ( ) . ProcessBlock ( storedNonce , m_pad ( ) ) ; } else { if ( m_padCached && ( storedNonce [ s - 1 ] | 1 ) == ( nonce [ length - 1 ] | 1 ) ) { m_padCached = VerifyBufsEqual ( storedNonce + s - length , nonce , length - 1 ) ; for ( size_t i = 0 ; m_padCached && i < s - length ; i ++ ) m_padCached = ( storedNonce [ i ] == 0 ) ; } if ( ! m_padCached ) { memset ( storedNonce , 0 , s - length ) ; memcpy ( storedNonce + s - length , nonce , length - 1 ) ; storedNonce [ s - 1 ] = nonce [ length - 1 ] & 0xfe ; AccessCipher ( ) . ProcessBlock ( storedNonce , m_pad ( ) ) ; m_padCached = true ; } storedNonce [ s - 1 ] = nonce [ length - 1 ] ; } m_isFirstBlock = true ; Restart ( ) ; } void VMAC_Base :: HashEndianCorrectedBlock ( const word64 * data ) { assert ( false ) ; throw 0 ; } # if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86 # pragma warning ( disable : 4731 ) void # ifdef __GNUC__ __attribute__ ( ( noinline ) ) # endif VMAC_Base :: VHASH_Update_SSE2 ( const word64 * data , size_t blocksRemainingInWord64 , int tagPart ) { const word64 * nhK = m_nhKey ( ) ; word64 * polyS = m_polyState ( ) ; word32 L1KeyLength = m_L1KeyLength ; # ifdef __GNUC__ word32 temp ; __asm__ __volatile__ ( AS2 ( mov % % ebx , % 0 ) AS2 ( mov % 1 , % % ebx ) " . intel _ syntax ▁ noprefix ; " # else # if _MSC_VER < 1300 || defined ( __INTEL_COMPILER ) char isFirstBlock = m_isFirstBlock ; AS2 ( mov ebx , [ L1KeyLength ] ) AS2 ( mov dl , [ isFirstBlock ] ) # else AS2 ( mov ecx , this ) AS2 ( mov ebx , [ ecx + m_L1KeyLength ] ) AS2 ( mov dl , [ ecx + m_isFirstBlock ] ) # endif AS2 ( mov eax , tagPart ) AS2 ( shl eax , 4 ) AS2 ( mov edi , nhK ) AS2 ( add edi , eax ) AS2 ( add eax , eax ) AS2 ( add eax , polyS ) AS2 ( mov esi , data ) AS2 ( mov ecx , blocksRemainingInWord64 ) # endif AS2 ( shr ebx , 3 ) AS1 ( push ebp ) AS2 ( sub esp , 12 ) ASL ( 4 ) AS2 ( mov ebp , ebx ) AS2 ( cmp ecx , ebx ) AS2 ( cmovl ebp , ecx ) AS2 ( sub ecx , ebp ) AS2 ( lea ebp , [ edi + 8 * ebp ] ) AS2 ( movq mm6 , [ esi ] ) AS2 ( paddq mm6 , [ edi ] ) AS2 ( movq mm5 , [ esi + 8 ] ) AS2 ( paddq mm5 , [ edi + 8 ] ) AS2 ( add esi , 16 ) AS2 ( add edi , 16 ) AS2 ( movq mm4 , mm6 ) ASS ( pshufw mm2 , mm6 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm6 , mm5 ) ASS ( pshufw mm3 , mm5 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm5 , mm2 ) AS2 ( pmuludq mm2 , mm3 ) AS2 ( pmuludq mm3 , mm4 ) AS2 ( pxor mm7 , mm7 ) AS2 ( movd [ esp ] , mm6 ) AS2 ( psrlq mm6 , 32 ) AS2 ( movd [ esp + 4 ] , mm5 ) AS2 ( psrlq mm5 , 32 ) AS2 ( cmp edi , ebp ) ASJ ( je , 1 , f ) ASL ( 0 ) AS2 ( movq mm0 , [ esi ] ) AS2 ( paddq mm0 , [ edi ] ) AS2 ( movq mm1 , [ esi + 8 ] ) AS2 ( paddq mm1 , [ edi + 8 ] ) AS2 ( add esi , 16 ) AS2 ( add edi , 16 ) AS2 ( movq mm4 , mm0 ) AS2 ( paddq mm5 , mm2 ) ASS ( pshufw mm2 , mm0 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm0 , mm1 ) AS2 ( movd [ esp + 8 ] , mm3 ) AS2 ( psrlq mm3 , 32 ) AS2 ( paddq mm5 , mm3 ) ASS ( pshufw mm3 , mm1 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm1 , mm2 ) AS2 ( pmuludq mm2 , mm3 ) AS2 ( pmuludq mm3 , mm4 ) AS2 ( movd mm4 , [ esp ] ) AS2 ( paddq mm7 , mm4 ) AS2 ( movd mm4 , [ esp + 4 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( movd mm4 , [ esp + 8 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( movd [ esp ] , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( paddq mm6 , mm0 ) AS2 ( movd [ esp + 4 ] , mm1 ) AS2 ( psrlq mm1 , 32 ) AS2 ( paddq mm5 , mm1 ) AS2 ( cmp edi , ebp ) ASJ ( jne , 0 , b ) ASL ( 1 ) AS2 ( paddq mm5 , mm2 ) AS2 ( movd [ esp + 8 ] , mm3 ) AS2 ( psrlq mm3 , 32 ) AS2 ( paddq mm5 , mm3 ) AS2 ( movd mm4 , [ esp ] ) AS2 ( paddq mm7 , mm4 ) AS2 ( movd mm4 , [ esp + 4 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( movd mm4 , [ esp + 8 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( lea ebp , [ 8 * ebx ] ) AS2 ( sub edi , ebp ) AS2 ( movd [ esp ] , mm7 ) AS2 ( psrlq mm7 , 32 ) AS2 ( paddq mm6 , mm7 ) AS2 ( movd [ esp + 4 ] , mm6 ) AS2 ( psrlq mm6 , 32 ) AS2 ( paddq mm5 , mm6 ) AS2 ( psllq mm5 , 2 ) AS2 ( psrlq mm5 , 2 ) # define a0 [ eax + 2 * 4 ] # define a1 [ eax + 3 * 4 ] # define a2 [ eax + 0 * 4 ] # define a3 [ eax + 1 * 4 ] # define k0 [ eax + 2 * 8 + 2 * 4 ] # define k1 [ eax + 2 * 8 + 3 * 4 ] # define k2 [ eax + 2 * 8 + 0 * 4 ] # define k3 [ eax + 2 * 8 + 1 * 4 ] AS2 ( test dl , dl ) ASJ ( jz , 2 , f ) AS2 ( movd mm1 , k0 ) AS2 ( movd mm0 , [ esp ] ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd a0 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( movd mm1 , k1 ) AS2 ( movd mm2 , [ esp + 4 ] ) AS2 ( paddq mm1 , mm2 ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd a1 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( paddq mm5 , k2 ) AS2 ( paddq mm0 , mm5 ) AS2 ( movq a2 , mm0 ) AS2 ( xor edx , edx ) ASJ ( jmp , 3 , f ) ASL ( 2 ) AS2 ( movd mm0 , a3 ) AS2 ( movq mm4 , mm0 ) AS2 ( pmuludq mm0 , k3 ) AS2 ( movd mm1 , a0 ) AS2 ( pmuludq mm1 , k2 ) AS2 ( movd mm2 , a1 ) AS2 ( movd mm6 , k1 ) AS2 ( pmuludq mm2 , mm6 ) AS2 ( movd mm3 , a2 ) AS2 ( psllq mm0 , 1 ) AS2 ( paddq mm0 , mm5 ) AS2 ( movq mm5 , mm3 ) AS2 ( movd mm7 , k0 ) AS2 ( pmuludq mm3 , mm7 ) AS2 ( pmuludq mm4 , mm7 ) AS2 ( pmuludq mm5 , mm6 ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd mm1 , a1 ) AS2 ( paddq mm4 , mm5 ) AS2 ( movq mm5 , mm1 ) AS2 ( pmuludq mm1 , k2 ) AS2 ( paddq mm0 , mm2 ) AS2 ( movd mm2 , a0 ) AS2 ( paddq mm0 , mm3 ) AS2 ( movq mm3 , mm2 ) AS2 ( pmuludq mm2 , k3 ) AS2 ( pmuludq mm3 , mm7 ) AS2 ( movd [ esp + 8 ] , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( pmuludq mm7 , mm5 ) AS2 ( pmuludq mm5 , k3 ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd mm1 , a2 ) AS2 ( pmuludq mm1 , k2 ) AS2 ( paddq mm0 , mm2 ) AS2 ( paddq mm0 , mm4 ) AS2 ( movq mm4 , mm0 ) AS2 ( movd mm2 , a3 ) AS2 ( pmuludq mm2 , mm6 ) AS2 ( pmuludq mm6 , a0 ) AS2 ( psrlq mm0 , 31 ) AS2 ( paddq mm0 , mm3 ) AS2 ( movd mm3 , [ esp ] ) AS2 ( paddq mm0 , mm3 ) AS2 ( movd mm3 , a2 ) AS2 ( pmuludq mm3 , k3 ) AS2 ( paddq mm5 , mm1 ) AS2 ( movd mm1 , a3 ) AS2 ( pmuludq mm1 , k2 ) AS2 ( paddq mm5 , mm2 ) AS2 ( movd mm2 , [ esp + 4 ] ) AS2 ( psllq mm5 , 1 ) AS2 ( paddq mm0 , mm5 ) AS2 ( psllq mm4 , 33 ) AS2 ( movd a0 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( paddq mm6 , mm7 ) AS2 ( movd mm7 , [ esp + 8 ] ) AS2 ( paddq mm0 , mm6 ) AS2 ( paddq mm0 , mm2 ) AS2 ( paddq mm3 , mm1 ) AS2 ( psllq mm3 , 1 ) AS2 ( paddq mm0 , mm3 ) AS2 ( psrlq mm4 , 1 ) AS2 ( movd a1 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( por mm4 , mm7 ) AS2 ( paddq mm0 , mm4 ) AS2 ( movq a2 , mm0 ) # undef a0 # undef a1 # undef a2 # undef a3 # undef k0 # undef k1 # undef k2 # undef k3 ASL ( 3 ) AS2 ( test ecx , ecx ) ASJ ( jnz , 4 , b ) AS2 ( add esp , 12 ) AS1 ( pop ebp ) AS1 ( emms ) # ifdef __GNUC__ " . att _ syntax ▁ prefix ; " AS2 ( mov % 0 , % % ebx ) : " = m " ( temp ) : " m " ( L1KeyLength ) , " c " ( blocksRemainingInWord64 ) , " S " ( data ) , " D " ( nhK + tagPart * 2 ) , " d " ( m_isFirstBlock ) , " a " ( polyS + tagPart * 4 ) : " memory " , " cc " ) ; # endif } # endif # if VMAC_BOOL_WORD128 # define DeclareNH ( a ) word128 a = 0 # define MUL64 ( rh , rl , i1 , i2 ) { word128 p = word128 ( i1 ) * ( i2 ) ; rh = word64 ( p >> 64 ) ; rl = word64 ( p ) ; } # define AccumulateNH ( a , b , c ) a += word128 ( b ) * ( c ) # define Multiply128 ( r , i1 , i2 ) r = word128 ( word64 ( i1 ) ) * word64 ( i2 ) # else # if _MSC_VER >= 1400 && ! defined ( __INTEL_COMPILER ) # define MUL32 ( a , b ) __emulu ( word32 ( a ) , word32 ( b ) ) # else # define MUL32 ( a , b ) ( ( word64 ) ( ( word32 ) ( a ) ) * ( word32 ) ( b ) ) # endif # if defined ( CRYPTOPP_X64_ASM_AVAILABLE ) # define DeclareNH ( a ) word64 a ## 0 = 0 , a ## 1 = 0 # define MUL64 ( rh , rl , i1 , i2 ) asm ( " mulq ▁ % 3" : " = a " ( rl ) , " = d " ( rh ) : " a " ( i1 ) , " g " ( i2 ) : " cc " ) ; # define AccumulateNH ( a , b , c ) asm ( " mulq ▁ % 3 ; ▁ addq ▁ % % rax , ▁ % 0 ; ▁ adcq ▁ % % rdx , ▁ % 1" : " + r " ( a ## 0 ) , " + r " ( a ## 1 ) : " a " ( b ) , " g " ( c ) : " % rdx " , " cc " ) ; # define ADD128 ( rh , rl , ih , il ) asm ( " addq ▁ % 3 , ▁ % 1 ; ▁ adcq ▁ % 2 , ▁ % 0" : " + r " ( rh ) , " + r " ( rl ) : " r " ( ih ) , " r " ( il ) : " cc " ) ; # elif defined ( _MSC_VER ) && ! CRYPTOPP_BOOL_SLOW_WORD64 # define DeclareNH ( a ) word64 a ## 0 = 0 , a ## 1 = 0 # define MUL64 ( rh , rl , i1 , i2 ) ( rl ) = _umul128 ( i1 , i2 , & ( rh ) ) ; # define AccumulateNH ( a , b , c ) { word64 ph , pl ; pl = _umul128 ( b , c , & ph ) ; a ## 0 += pl ; a ## 1 += ph + ( a ## 0 < pl ) ; } # else # define VMAC_BOOL_32BIT 1 # define DeclareNH ( a ) word64 a ## 0 = 0 , a ## 1 = 0 , a ## 2 = 0 # define MUL64 ( rh , rl , i1 , i2 ) { word64 _i1 = ( i1 ) , _i2 = ( i2 ) ; word64 m1 = MUL32 ( _i1 , _i2 >> 32 ) ; word64 m2 = MUL32 ( _i1 >> 32 , _i2 ) ; rh = MUL32 ( _i1 >> 32 , _i2 >> 32 ) ; rl = MUL32 ( _i1 , _i2 ) ; ADD128 ( rh , rl , ( m1 >> 32 ) , ( m1 << 32 ) ) ; ADD128 ( rh , rl , ( m2 >> 32 ) , ( m2 << 32 ) ) ; } # define AccumulateNH ( a , b , c ) { word64 p = MUL32 ( b , c ) ; a ## 1 += word32 ( ( p ) >> 32 ) ; a ## 0 += word32 ( p ) ; p = MUL32 ( ( b ) >> 32 , c ) ; a ## 2 += word32 ( ( p ) >> 32 ) ; a ## 1 += word32 ( p ) ; p = MUL32 ( ( b ) >> 32 , ( c ) >> 32 ) ; a ## 2 += p ; p = MUL32 ( b , ( c ) >> 32 ) ; a ## 1 += word32 ( p ) ; a ## 2 += word32 ( p >> 32 ) ; } # endif # endif # ifndef VMAC_BOOL_32BIT # define VMAC_BOOL_32BIT 0 # endif # ifndef ADD128 # define ADD128 ( rh , rl , ih , il ) { word64 _il = ( il ) ; ( rl ) += ( _il ) ; ( rh ) += ( ih ) + ( ( rl ) < ( _il ) ) ; } # endif # if ! ( defined ( _MSC_VER ) && _MSC_VER < 1300 ) template < bool T_128BitTag > # endif void VMAC_Base :: VHASH_Update_Template ( const word64 * data , size_t blocksRemainingInWord64 ) { # define INNER_LOOP_ITERATION ( j ) { word64 d0 = ConditionalByteReverse ( LITTLE_ENDIAN_ORDER , data [ i + 2 * j + 0 ] ) ; word64 d1 = ConditionalByteReverse ( LITTLE_ENDIAN_ORDER , data [ i + 2 * j + 1 ] ) ; AccumulateNH ( nhA , d0 + nhK [ i + 2 * j + 0 ] , d1 + nhK [ i + 2 * j + 1 ] ) ; if ( T_128BitTag ) AccumulateNH ( nhB , d0 + nhK [ i + 2 * j + 2 ] , d1 + nhK [ i + 2 * j + 3 ] ) ; } # if ( defined ( _MSC_VER ) && _MSC_VER < 1300 ) bool T_128BitTag = m_is128 ; # endif size_t L1KeyLengthInWord64 = m_L1KeyLength / 8 ; size_t innerLoopEnd = L1KeyLengthInWord64 ; const word64 * nhK = m_nhKey ( ) ; word64 * polyS = m_polyState ( ) ; bool isFirstBlock = true ; size_t i ; # if ! VMAC_BOOL_32BIT # if VMAC_BOOL_WORD128 word128 a1 , a2 ; # else word64 ah1 , al1 , ah2 , al2 ; # endif word64 kh1 , kl1 , kh2 , kl2 ; kh1 = ( polyS + 0 * 4 + 2 ) [ 0 ] ; kl1 = ( polyS + 0 * 4 + 2 ) [ 1 ] ; if ( T_128BitTag ) { kh2 = ( polyS + 1 * 4 + 2 ) [ 0 ] ; kl2 = ( polyS + 1 * 4 + 2 ) [ 1 ] ; } # endif do { DeclareNH ( nhA ) ; DeclareNH ( nhB ) ; i = 0 ; if ( blocksRemainingInWord64 < L1KeyLengthInWord64 ) { if ( blocksRemainingInWord64 % 8 ) { innerLoopEnd = blocksRemainingInWord64 % 8 ; for ( ; i < innerLoopEnd ; i += 2 ) INNER_LOOP_ITERATION ( 0 ) ; } innerLoopEnd = blocksRemainingInWord64 ; } for ( ; i < innerLoopEnd ; i += 8 ) { INNER_LOOP_ITERATION ( 0 ) ; INNER_LOOP_ITERATION ( 1 ) ; INNER_LOOP_ITERATION ( 2 ) ; INNER_LOOP_ITERATION ( 3 ) ; } blocksRemainingInWord64 -= innerLoopEnd ; data += innerLoopEnd ; # if VMAC_BOOL_32BIT word32 nh0 [ 2 ] , nh1 [ 2 ] ; word64 nh2 [ 2 ] ; nh0 [ 0 ] = word32 ( nhA0 ) ; nhA1 += ( nhA0 >> 32 ) ; nh1 [ 0 ] = word32 ( nhA1 ) ; nh2 [ 0 ] = ( nhA2 + ( nhA1 >> 32 ) ) & m62 ; if ( T_128BitTag ) { nh0 [ 1 ] = word32 ( nhB0 ) ; nhB1 += ( nhB0 >> 32 ) ; nh1 [ 1 ] = word32 ( nhB1 ) ; nh2 [ 1 ] = ( nhB2 + ( nhB1 >> 32 ) ) & m62 ; } # define a0 ( ( ( word32 * ) ( polyS + i * 4 ) ) [ 2 + NativeByteOrder :: ToEnum ( ) ] ) # define a1 ( * ( ( ( word32 * ) ( polyS + i * 4 ) ) + 3 - NativeByteOrder :: ToEnum ( ) ) ) # define a2 ( ( ( word32 * ) ( polyS + i * 4 ) ) [ 0 + NativeByteOrder :: ToEnum ( ) ] ) # define a3 ( * ( ( ( word32 * ) ( polyS + i * 4 ) ) + 1 - NativeByteOrder :: ToEnum ( ) ) ) # define aHi ( ( polyS + i * 4 ) [ 0 ] ) # define k0 ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) [ 2 + NativeByteOrder :: ToEnum ( ) ] ) # define k1 ( * ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) + 3 - NativeByteOrder :: ToEnum ( ) ) ) # define k2 ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) [ 0 + NativeByteOrder :: ToEnum ( ) ] ) # define k3 ( * ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) + 1 - NativeByteOrder :: ToEnum ( ) ) ) # define kHi ( ( polyS + i * 4 + 2 ) [ 0 ] ) if ( isFirstBlock ) { isFirstBlock = false ; if ( m_isFirstBlock ) { m_isFirstBlock = false ; for ( i = 0 ; i <= ( size_t ) T_128BitTag ; i ++ ) { word64 t = ( word64 ) nh0 [ i ] + k0 ; a0 = ( word32 ) t ; t = ( t >> 32 ) + nh1 [ i ] + k1 ; a1 = ( word32 ) t ; aHi = ( t >> 32 ) + nh2 [ i ] + kHi ; } continue ; } } for ( i = 0 ; i <= ( size_t ) T_128BitTag ; i ++ ) { word64 p , t ; word32 t2 ; p = MUL32 ( a3 , 2 * k3 ) ; p += nh2 [ i ] ; p += MUL32 ( a0 , k2 ) ; p += MUL32 ( a1 , k1 ) ; p += MUL32 ( a2 , k0 ) ; t2 = ( word32 ) p ; p >>= 32 ; p += MUL32 ( a0 , k3 ) ; p += MUL32 ( a1 , k2 ) ; p += MUL32 ( a2 , k1 ) ; p += MUL32 ( a3 , k0 ) ; t = ( word64 ( word32 ( p ) & 0x7fffffff ) << 32 ) | t2 ; p >>= 31 ; p += nh0 [ i ] ; p += MUL32 ( a0 , k0 ) ; p += MUL32 ( a1 , 2 * k3 ) ; p += MUL32 ( a2 , 2 * k2 ) ; p += MUL32 ( a3 , 2 * k1 ) ; t2 = ( word32 ) p ; p >>= 32 ; p += nh1 [ i ] ; p += MUL32 ( a0 , k1 ) ; p += MUL32 ( a1 , k0 ) ; p += MUL32 ( a2 , 2 * k3 ) ; p += MUL32 ( a3 , 2 * k2 ) ; a0 = t2 ; a1 = ( word32 ) p ; aHi = ( p >> 32 ) + t ; } # undef a0 # undef a1 # undef a2 # undef a3 # undef aHi # undef k0 # undef k1 # undef k2 # undef k3 # undef kHi # else if ( isFirstBlock ) { isFirstBlock = false ; if ( m_isFirstBlock ) { m_isFirstBlock = false ; # if VMAC_BOOL_WORD128 # define first_poly_step ( a , kh , kl , m ) a = ( m & m126 ) + ( ( word128 ( kh ) << 64 ) | kl ) first_poly_step ( a1 , kh1 , kl1 , nhA ) ; if ( T_128BitTag ) first_poly_step ( a2 , kh2 , kl2 , nhB ) ; # else # define first_poly_step ( ah , al , kh , kl , mh , ml ) { mh &= m62 ; ADD128 ( mh , ml , kh , kl ) ; ah = mh ; al = ml ; } first_poly_step ( ah1 , al1 , kh1 , kl1 , nhA1 , nhA0 ) ; if ( T_128BitTag ) first_poly_step ( ah2 , al2 , kh2 , kl2 , nhB1 , nhB0 ) ; # endif continue ; } else { # if VMAC_BOOL_WORD128 a1 = ( word128 ( ( polyS + 0 * 4 ) [ 0 ] ) << 64 ) | ( polyS + 0 * 4 ) [ 1 ] ; # else ah1 = ( polyS + 0 * 4 ) [ 0 ] ; al1 = ( polyS + 0 * 4 ) [ 1 ] ; # endif if ( T_128BitTag ) { # if VMAC_BOOL_WORD128 a2 = ( word128 ( ( polyS + 1 * 4 ) [ 0 ] ) << 64 ) | ( polyS + 1 * 4 ) [ 1 ] ; # else ah2 = ( polyS + 1 * 4 ) [ 0 ] ; al2 = ( polyS + 1 * 4 ) [ 1 ] ; # endif } } } # if VMAC_BOOL_WORD128 # define poly_step ( a , kh , kl , m ) { word128 t1 , t2 , t3 , t4 ; Multiply128 ( t2 , a >> 64 , kl ) ; Multiply128 ( t3 , a , kh ) ; Multiply128 ( t1 , a , kl ) ; Multiply128 ( t4 , a >> 64 , 2 * kh ) ; t2 += t3 ; t4 += t1 ; t2 += t4 >> 64 ; a = ( word128 ( word64 ( t2 ) & m63 ) << 64 ) | word64 ( t4 ) ; t2 *= 2 ; a += m & m126 ; a += t2 >> 64 ; } poly_step ( a1 , kh1 , kl1 , nhA ) ; if ( T_128BitTag ) poly_step ( a2 , kh2 , kl2 , nhB ) ; # else # define poly_step ( ah , al , kh , kl , mh , ml ) { word64 t1h , t1l , t2h , t2l , t3h , t3l , z = 0 ; MUL64 ( t2h , t2l , ah , kl ) ; MUL64 ( t3h , t3l , al , kh ) ; MUL64 ( t1h , t1l , ah , 2 * kh ) ; MUL64 ( ah , al , al , kl ) ; ADD128 ( t2h , t2l , t3h , t3l ) ; ADD128 ( ah , al , t1h , t1l ) ; ADD128 ( t2h , ah , z , t2l ) ; t2h += t2h + ( ah >> 63 ) ; ah &= m63 ; mh &= m62 ; ADD128 ( ah , al , mh , ml ) ; ADD128 ( ah , al , z , t2h ) ; } poly_step ( ah1 , al1 , kh1 , kl1 , nhA1 , nhA0 ) ; if ( T_128BitTag ) poly_step ( ah2 , al2 , kh2 , kl2 , nhB1 , nhB0 ) ; # endif # endif } while ( blocksRemainingInWord64 ) ; # if VMAC_BOOL_WORD128 ( polyS + 0 * 4 ) [ 0 ] = word64 ( a1 >> 64 ) ; ( polyS + 0 * 4 ) [ 1 ] = word64 ( a1 ) ; if ( T_128BitTag ) { ( polyS + 1 * 4 ) [ 0 ] = word64 ( a2 >> 64 ) ; ( polyS + 1 * 4 ) [ 1 ] = word64 ( a2 ) ; } # elif ! VMAC_BOOL_32BIT ( polyS + 0 * 4 ) [ 0 ] = ah1 ; ( polyS + 0 * 4 ) [ 1 ] = al1 ; if ( T_128BitTag ) { ( polyS + 1 * 4 ) [ 0 ] = ah2 ; ( polyS + 1 * 4 ) [ 1 ] = al2 ; } # endif } inline void VMAC_Base :: VHASH_Update ( const word64 * data , size_t blocksRemainingInWord64 ) { # if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86 if ( HasSSE2 ( ) ) { VHASH_Update_SSE2 ( data , blocksRemainingInWord64 , 0 ) ; if ( m_is128 ) VHASH_Update_SSE2 ( data , blocksRemainingInWord64 , 1 ) ; m_isFirstBlock = false ; } else # endif { # if defined ( _MSC_VER ) && _MSC_VER < 1300 VHASH_Update_Template ( data , blocksRemainingInWord64 ) ; # else if ( m_is128 ) VHASH_Update_Template < true > ( data , blocksRemainingInWord64 ) ; else VHASH_Update_Template < false > ( data , blocksRemainingInWord64 ) ; # endif } } size_t VMAC_Base :: HashMultipleBlocks ( const word64 * data , size_t length ) { size_t remaining = ModPowerOf2 ( length , m_L1KeyLength ) ; VHASH_Update ( data , ( length - remaining ) / 8 ) ; return remaining ; } static word64 L3Hash ( const word64 * input , const word64 * l3Key , size_t len ) { word64 rh , rl , t , z = 0 ; word64 p1 = input [ 0 ] , p2 = input [ 1 ] ; word64 k1 = l3Key [ 0 ] , k2 = l3Key [ 1 ] ; t = p1 >> 63 ; p1 &= m63 ; ADD128 ( p1 , p2 , len , t ) ; t = ( p1 > m63 ) + ( ( p1 == m63 ) & ( p2 == m64 ) ) ; ADD128 ( p1 , p2 , z , t ) ; p1 &= m63 ; t = p1 + ( p2 >> 32 ) ; t += ( t >> 32 ) ; t += ( word32 ) t > 0xfffffffeU ; p1 += ( t >> 32 ) ; p2 += ( p1 << 32 ) ; p1 += k1 ; p1 += ( 0 - ( p1 < k1 ) ) & 257 ; p2 += k2 ; p2 += ( 0 - ( p2 < k2 ) ) & 257 ; MUL64 ( rh , rl , p1 , p2 ) ; t = rh >> 56 ; ADD128 ( t , rl , z , rh ) ; rh <<= 8 ; ADD128 ( t , rl , z , rh ) ; t += t << 8 ; rl += t ; rl += ( 0 - ( rl < t ) ) & 257 ; rl += ( 0 - ( rl > p64 - 1 ) ) & 257 ; return rl ; } void VMAC_Base :: TruncatedFinal ( byte * mac , size_t size ) { size_t len = ModPowerOf2 ( GetBitCountLo ( ) / 8 , m_L1KeyLength ) ; if ( len ) { memset ( m_data ( ) + len , 0 , ( 0 - len ) % 16 ) ; VHASH_Update ( DataBuf ( ) , ( ( len + 15 ) / 16 ) * 2 ) ; len *= 8 ; } else if ( m_isFirstBlock ) { m_polyState ( ) [ 0 ] = m_polyState ( ) [ 2 ] ; m_polyState ( ) [ 1 ] = m_polyState ( ) [ 3 ] ; if ( m_is128 ) { m_polyState ( ) [ 4 ] = m_polyState ( ) [ 6 ] ; m_polyState ( ) [ 5 ] = m_polyState ( ) [ 7 ] ; } } if ( m_is128 ) { word64 t [ 2 ] ; t [ 0 ] = L3Hash ( m_polyState ( ) , m_l3Key ( ) , len ) + GetWord < word64 > ( true , BIG_ENDIAN_ORDER , m_pad ( ) ) ; t [ 1 ] = L3Hash ( m_polyState ( ) + 4 , m_l3Key ( ) + 2 , len ) + GetWord < word64 > ( true , BIG_ENDIAN_ORDER , m_pad ( ) + 8 ) ; if ( size == 16 ) { PutWord ( false , BIG_ENDIAN_ORDER , mac , t [ 0 ] ) ; PutWord ( false , BIG_ENDIAN_ORDER , mac + 8 , t [ 1 ] ) ; } else { t [ 0 ] = ConditionalByteReverse ( BIG_ENDIAN_ORDER , t [ 0 ] ) ; t [ 1 ] = ConditionalByteReverse ( BIG_ENDIAN_ORDER , t [ 1 ] ) ; memcpy ( mac , t , size ) ; } } else { word64 t = L3Hash ( m_polyState ( ) , m_l3Key ( ) , len ) ; t += GetWord < word64 > ( true , BIG_ENDIAN_ORDER , m_pad ( ) + ( m_nonce ( ) [ IVSize ( ) - 1 ] & 1 ) * 8 ) ; if ( size == 8 ) PutWord ( false , BIG_ENDIAN_ORDER , mac , t ) ; else { t = ConditionalByteReverse ( BIG_ENDIAN_ORDER , t ) ; memcpy ( mac , & t , size ) ; } } } NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="lassoan/CTK/tree/master/Plugins/org.commontk.plugingenerator.ui/ctkPluginGeneratorUiPlugin.cpp"> # include " ctkPluginGeneratorUiPlugin _ p . h " # include " ctkPluginGeneratorMainExtension . h " # include < ctkPluginConstants . h > # include < QtPlugin > # include < QDebug > void ctkPluginGeneratorUiPlugin :: start ( ctkPluginContext * context ) { mainExtension = new ctkPluginGeneratorMainExtension ( ) ; ctkDictionary props ; props . insert ( ctkPluginConstants :: SERVICE_RANKING , 0 ) ; context -> registerService ( QStringList ( " ctkPluginGeneratorAbstractUiExtension " ) , mainExtension , props ) ; qDebug ( ) << " Registered ▁ Main ▁ Extension " ; } void ctkPluginGeneratorUiPlugin :: stop ( ctkPluginContext * context ) { Q_UNUSED ( context ) delete mainExtension ; } Q_EXPORT_PLUGIN2 ( org_commontk_plugingenerator_ui , ctkPluginGeneratorUiPlugin ) </DOCUMENT>
<DOCUMENT_ID="NeuroRoboticTech/AnimatLabPublicSource/tree/master/Libraries/AnimatCarlSimCUDA/CsClassFactory.cpp"> # include " StdAfx . h " # include " CsNeuralModule . h " # include " CsNeuronGroup . h " # include " CsSpikeGeneratorGroup . h " # include " CsSynapseGroup . h " # include " CsSynapseOneToOne . h " # include " CsSynapseFull . h " # include " CsSynapseRandom . h " # include " CsSynapseIndividual . h " # include " CsSpikingCurrentSynapse . h " # include " CsFiringRateStimulus . h " # include " CsNeuronDataColumn . h " # include " CsAdapter . h " # include " CsClassFactory . h " namespace AnimatCarlSim { CsClassFactory :: CsClassFactory ( ) { } CsClassFactory :: ~ CsClassFactory ( ) { } Node * CsClassFactory :: CreateNeuron ( std :: string strType , bool bThrowError ) { Node * lpNeuron = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NEURONGROUP " ) lpNeuron = new CsNeuronGroup ; else if ( strType == " SPIKEGENERATORGROUP " ) lpNeuron = new CsSpikeGeneratorGroup ; else { lpNeuron = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Cs_Err_lInvalidNeuronType , Cs_Err_strInvalidNeuronType , " NeuronType " , strType ) ; } return lpNeuron ; } catch ( CStdErrorInfo oError ) { if ( lpNeuron ) delete lpNeuron ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpNeuron ) delete lpNeuron ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } AnimatSim :: Link * CsClassFactory :: CreateSynapse ( std :: string strType , bool bThrowError ) { AnimatSim :: Link * lpSynapse = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " ONETOONESYNAPSE " ) lpSynapse = new CsSynapseOneToOne ; else if ( strType == " FULLSYNAPSE " ) lpSynapse = new CsSynapseFull ; else if ( strType == " RANDOMSYNAPSE " ) lpSynapse = new CsSynapseRandom ; else if ( strType == " INDIVIDUALSYNAPSE " ) lpSynapse = new CsSynapseIndividual ; else if ( strType == " SPIKINGCURRENTSYNAPSE " ) lpSynapse = new CsSpikingCurrentSynapse ; else { lpSynapse = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Cs_Err_lInvalidSynapseType , Cs_Err_strInvalidSynapseType , " SynapseType " , strType ) ; } return lpSynapse ; } catch ( CStdErrorInfo oError ) { if ( lpSynapse ) delete lpSynapse ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpSynapse ) delete lpSynapse ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } NeuralModule * CsClassFactory :: CreateNeuralModule ( std :: string strType , bool bThrowError ) { NeuralModule * lpModule = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " CARLSIMNEURALMODULE " ) lpModule = new CsNeuralModule ; else { lpModule = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalidNeuralModuleType , Al_Err_strInvalidNeuralModuleType , " NeuralModule " , strType ) ; } return lpModule ; } catch ( CStdErrorInfo oError ) { if ( lpModule ) delete lpModule ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpModule ) delete lpModule ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } ExternalStimulus * CsClassFactory :: CreateExternalStimulus ( std :: string strType , bool bThrowError ) { ExternalStimulus * lpStimulus = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " FIRINGRATE " ) lpStimulus = new CsFiringRateStimulus ; else { lpStimulus = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalidExternalStimulusType , Al_Err_strInvalidExternalStimulusType , " ExternalStimulusType " , strType ) ; } return lpStimulus ; } catch ( CStdErrorInfo oError ) { if ( lpStimulus ) delete lpStimulus ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpStimulus ) delete lpStimulus ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } DataColumn * CsClassFactory :: CreateDataColumn ( std :: string strType , bool bThrowError ) { DataColumn * lpColumn = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NEURONDATACOLUMN " ) lpColumn = new CsNeuronDataColumn ; else { lpColumn = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalidDataColumnType , Al_Err_strInvalidDataColumnType , " DataColumnType " , strType ) ; } return lpColumn ; } catch ( CStdErrorInfo oError ) { if ( lpColumn ) delete lpColumn ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpColumn ) delete lpColumn ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } Adapter * CsClassFactory :: CreateAdapter ( std :: string strType , bool bThrowError ) { Adapter * lpAdapter = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NODETONODE " ) lpAdapter = new CsAdapter ; else if ( strType == " PHYSICALTONODE " ) lpAdapter = new CsAdapter ; else { lpAdapter = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalidAdapterType , Al_Err_strInvalidAdapterType , " AdapterType " , strType ) ; } return lpAdapter ; } catch ( CStdErrorInfo oError ) { if ( lpAdapter ) delete lpAdapter ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpAdapter ) delete lpAdapter ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } CStdSerialize * CsClassFactory :: CreateObject ( std :: string strClassType , std :: string strObjectType , bool bThrowError ) { CStdSerialize * lpObject = NULL ; strClassType = Std_ToUpper ( Std_Trim ( strClassType ) ) ; if ( strClassType == " NEURON " ) lpObject = CreateNeuron ( strObjectType , bThrowError ) ; else if ( strClassType == " SYNAPSE " ) lpObject = CreateSynapse ( strObjectType , bThrowError ) ; else if ( strClassType == " NEURALMODULE " ) lpObject = CreateNeuralModule ( strObjectType , bThrowError ) ; else if ( strClassType == " EXTERNALSTIMULUS " ) lpObject = CreateExternalStimulus ( strObjectType , bThrowError ) ; else if ( strClassType == " DATACOLUMN " ) lpObject = CreateDataColumn ( strObjectType , bThrowError ) ; else if ( strClassType == " ADAPTER " ) lpObject = CreateAdapter ( strObjectType , bThrowError ) ; else { lpObject = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Std_Err_lInvalidClassType , Std_Err_strInvalidClassType , " ClassType " , strClassType ) ; } return lpObject ; } } # ifdef WIN32 extern " C " __declspec ( dllexport ) IStdClassFactory * __cdecl GetStdClassFactory ( ) # else extern " C " IStdClassFactory * GetStdClassFactory ( ) # endif { IStdClassFactory * lpFactory = new CsClassFactory ; return lpFactory ; } </DOCUMENT>
<DOCUMENT_ID="Hual/SA-MP-Plus/tree/master/Common/RakNet/VariableDeltaSerializer.cpp"> # include " VariableDeltaSerializer . h " using namespace RakNet ; VariableDeltaSerializer :: VariableDeltaSerializer ( ) { didComparisonThisTick = false ; } VariableDeltaSerializer :: ~ VariableDeltaSerializer ( ) { RemoveRemoteSystemVariableHistory ( ) ; } VariableDeltaSerializer :: SerializationContext :: SerializationContext ( ) { variableHistoryIdentical = 0 ; variableHistoryUnique = 0 ; } VariableDeltaSerializer :: SerializationContext :: ~ SerializationContext ( ) { } void VariableDeltaSerializer :: OnMessageReceipt ( RakNetGUID guid , uint32_t receiptId , bool messageArrived ) { if ( messageArrived ) FreeVarsAssociatedWithReceipt ( guid , receiptId ) ; else DirtyAndFreeVarsAssociatedWithReceipt ( guid , receiptId ) ; } void VariableDeltaSerializer :: BeginUnreliableAckedSerialize ( SerializationContext * context , RakNetGUID _guid , BitStream * _bitStream , uint32_t _sendReceipt ) { RakAssert ( _guid != UNASSIGNED_RAKNET_GUID ) ; context -> anyVariablesWritten = false ; context -> guid = _guid ; context -> bitStream = _bitStream ; if ( context -> variableHistoryUnique == 0 ) context -> variableHistoryUnique = StartVariableHistoryWrite ( _guid ) ; context -> variableHistory = context -> variableHistoryUnique ; context -> sendReceipt = _sendReceipt ; context -> changedVariables = AllocChangedVariablesList ( ) ; context -> newSystemSend = false ; context -> serializationMode = UNRELIABLE_WITH_ACK_RECEIPT ; } void VariableDeltaSerializer :: BeginUniqueSerialize ( SerializationContext * context , RakNetGUID _guid , BitStream * _bitStream ) { RakAssert ( _guid != UNASSIGNED_RAKNET_GUID ) ; context -> anyVariablesWritten = false ; context -> guid = _guid ; context -> bitStream = _bitStream ; if ( context -> variableHistoryUnique == 0 ) context -> variableHistoryUnique = StartVariableHistoryWrite ( _guid ) ; context -> variableHistory = context -> variableHistoryUnique ; context -> newSystemSend = false ; context -> serializationMode = RELIABLE ; } void VariableDeltaSerializer :: BeginIdenticalSerialize ( SerializationContext * context , bool _isFirstSendToRemoteSystem , BitStream * _bitStream ) { context -> anyVariablesWritten = false ; context -> guid = UNASSIGNED_RAKNET_GUID ; context -> bitStream = _bitStream ; context -> serializationMode = RELIABLE ; if ( context -> variableHistoryIdentical == 0 ) context -> variableHistoryIdentical = StartVariableHistoryWrite ( UNASSIGNED_RAKNET_GUID ) ; context -> variableHistory = context -> variableHistoryIdentical ; context -> newSystemSend = _isFirstSendToRemoteSystem ; } void VariableDeltaSerializer :: EndSerialize ( SerializationContext * context ) { if ( context -> serializationMode == UNRELIABLE_WITH_ACK_RECEIPT ) { if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; FreeChangedVariablesList ( context -> changedVariables ) ; return ; } StoreChangedVariablesList ( context -> variableHistory , context -> changedVariables , context -> sendReceipt ) ; } else { if ( context -> variableHistoryIdentical ) { if ( didComparisonThisTick == false ) { didComparisonThisTick = true ; identicalSerializationBs . Reset ( ) ; if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; return ; } identicalSerializationBs . Write ( context -> bitStream ) ; context -> bitStream -> ResetReadPointer ( ) ; } else { context -> bitStream -> Write ( & identicalSerializationBs ) ; identicalSerializationBs . ResetReadPointer ( ) ; } } else if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; return ; } } } void VariableDeltaSerializer :: BeginDeserialize ( DeserializationContext * context , BitStream * _bitStream ) { context -> bitStream = _bitStream ; } void VariableDeltaSerializer :: EndDeserialize ( DeserializationContext * context ) { ( void ) context ; } void VariableDeltaSerializer :: AddRemoteSystemVariableHistory ( RakNetGUID guid ) { ( void ) guid ; } void VariableDeltaSerializer :: RemoveRemoteSystemVariableHistory ( RakNetGUID guid ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) { for ( idx2 = 0 ; idx2 < remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory . Size ( ) ; idx2 ++ ) { FreeChangedVariablesList ( remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory [ idx2 ] ) ; } delete remoteSystemVariableHistoryList [ idx ] ; remoteSystemVariableHistoryList . RemoveAtIndexFast ( idx ) ; return ; } } int RakNet :: VariableDeltaSerializer :: UpdatedVariablesListPtrComp ( const uint32_t & key , ChangedVariablesList * const & data ) { if ( key < data -> sendReceipt ) return - 1 ; if ( key == data -> sendReceipt ) return 0 ; return 1 ; } void VariableDeltaSerializer :: FreeVarsAssociatedWithReceipt ( RakNetGUID guid , uint32_t receiptId ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; RemoteSystemVariableHistory * vprs = remoteSystemVariableHistoryList [ idx ] ; bool objectExists ; idx2 = vprs -> updatedVariablesHistory . GetIndexFromKey ( receiptId , & objectExists ) ; if ( objectExists ) { FreeChangedVariablesList ( vprs -> updatedVariablesHistory [ idx2 ] ) ; vprs -> updatedVariablesHistory . RemoveAtIndex ( idx2 ) ; } } void VariableDeltaSerializer :: DirtyAndFreeVarsAssociatedWithReceipt ( RakNetGUID guid , uint32_t receiptId ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; RemoteSystemVariableHistory * vprs = remoteSystemVariableHistoryList [ idx ] ; bool objectExists ; idx2 = vprs -> updatedVariablesHistory . GetIndexFromKey ( receiptId , & objectExists ) ; if ( objectExists ) { vprs -> variableListDeltaTracker . FlagDirtyFromBitArray ( vprs -> updatedVariablesHistory [ idx2 ] -> bitField ) ; FreeChangedVariablesList ( vprs -> updatedVariablesHistory [ idx2 ] ) ; vprs -> updatedVariablesHistory . RemoveAtIndex ( idx2 ) ; } } unsigned int VariableDeltaSerializer :: GetVarsWrittenPerRemoteSystemListIndex ( RakNetGUID guid ) { unsigned int idx ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) return idx ; } return ( unsigned int ) - 1 ; } void VariableDeltaSerializer :: RemoveRemoteSystemVariableHistory ( void ) { unsigned int idx , idx2 ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { for ( idx2 = 0 ; idx2 < remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory . Size ( ) ; idx2 ++ ) { FreeChangedVariablesList ( remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory [ idx2 ] ) ; } delete remoteSystemVariableHistoryList [ idx ] ; } remoteSystemVariableHistoryList . Clear ( false , _FILE_AND_LINE_ ) ; } VariableDeltaSerializer :: RemoteSystemVariableHistory * VariableDeltaSerializer :: GetRemoteSystemVariableHistory ( RakNetGUID guid ) { unsigned int rshli = GetRemoteSystemHistoryListIndex ( guid ) ; return remoteSystemVariableHistoryList [ rshli ] ; } VariableDeltaSerializer :: ChangedVariablesList * VariableDeltaSerializer :: AllocChangedVariablesList ( void ) { VariableDeltaSerializer :: ChangedVariablesList * p = updatedVariablesMemoryPool . Allocate ( _FILE_AND_LINE_ ) ; p -> bitWriteIndex = 0 ; p -> bitField [ 0 ] = 0 ; return p ; } void VariableDeltaSerializer :: FreeChangedVariablesList ( ChangedVariablesList * changedVariables ) { updatedVariablesMemoryPool . Release ( changedVariables , _FILE_AND_LINE_ ) ; } void VariableDeltaSerializer :: StoreChangedVariablesList ( RemoteSystemVariableHistory * variableHistory , ChangedVariablesList * changedVariables , uint32_t sendReceipt ) { changedVariables -> sendReceipt = sendReceipt ; variableHistory -> updatedVariablesHistory . Insert ( changedVariables -> sendReceipt , changedVariables , true , _FILE_AND_LINE_ ) ; } VariableDeltaSerializer :: RemoteSystemVariableHistory * VariableDeltaSerializer :: StartVariableHistoryWrite ( RakNetGUID guid ) { RemoteSystemVariableHistory * variableHistory ; unsigned int rshli = GetRemoteSystemHistoryListIndex ( guid ) ; if ( rshli == ( unsigned int ) - 1 ) { variableHistory = new RemoteSystemVariableHistory ; variableHistory -> guid = guid ; remoteSystemVariableHistoryList . Push ( variableHistory , _FILE_AND_LINE_ ) ; } else { variableHistory = remoteSystemVariableHistoryList [ rshli ] ; } variableHistory -> variableListDeltaTracker . StartWrite ( ) ; return variableHistory ; } unsigned int VariableDeltaSerializer :: GetRemoteSystemHistoryListIndex ( RakNetGUID guid ) { unsigned int idx ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) { return idx ; } } return ( unsigned int ) - 1 ; } void VariableDeltaSerializer :: OnPreSerializeTick ( void ) { didComparisonThisTick = false ; } </DOCUMENT>
<DOCUMENT_ID="fedech/ldpc_sim/tree/master/src/Simulation.cpp"> # include < iostream > # include < fstream > # include < string > # include < boost / numeric / ublas / matrix . hpp > # include < boost / random . hpp > # include < boost / random / normal_distribution . hpp > # include " LDPCEncoder . h " # include " LDPCDecoder . h " int main ( ) { int n = 648 ; int k = 432 ; int p = n - k ; std :: string file = " n648r23" ; int passes = 50 ; bool qam = true ; int symbols = 4 ; double step = 0.25 ; int minsnr = 0 ; double maxsnr = 4.1 ; int maxPackets = 1E6 ; int minErrors = 100 ; int printInterval = maxPackets / 1000 ; std :: string matrixFolder = " . / matrices / " ; std :: string extIn = " . csv " ; std :: string resultsFolder = " . / results / " ; std :: string extOut = " . dat " ; std :: string encoding = matrixFolder + " enc " + file + extIn ; std :: string decoding = matrixFolder + " dec " + file + extIn ; std :: stringstream ss ; if ( qam ) { ss << " qam " << symbols ; } ss << " _ " << passes ; std :: string output = resultsFolder + file + ss . str ( ) + extOut ; std :: ifstream enc ; enc . open ( encoding . c_str ( ) ) ; std :: ifstream dec ; dec . open ( decoding . c_str ( ) ) ; std :: ofstream out ; out . open ( output . c_str ( ) ) ; out << " # LDPC , ▁ n ▁ = ▁ " << n << " , ▁ k ▁ = ▁ " << k << " \n " ; out << " # SNR ▁ ( dB ) ▁ - ▁ BER ▁ - ▁ PER \n " ; std :: vector < double > snrdb ; std :: vector < int > errors ; std :: vector < int > pktErrors ; std :: vector < int > packets ; boost :: numeric :: ublas :: matrix < int > parityMatrix ( p , n ) ; boost :: numeric :: ublas :: matrix < int > encodingMatrix ( n , k ) ; for ( int i = 0 ; i < p ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dec >> parityMatrix ( i , j ) ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < k ; j ++ ) { enc >> encodingMatrix ( i , j ) ; } } for ( double snr = minsnr ; snr < maxsnr ; snr += step ) { snrdb . push_back ( snr ) ; errors . push_back ( 0 ) ; pktErrors . push_back ( 0 ) ; packets . push_back ( 0 ) ; } boost :: mt19937 rng = boost :: mt19937 ( time ( 0 ) ) ; boost :: variate_generator < boost :: mt19937 & , boost :: normal_distribution < > > generator ( rng , boost :: normal_distribution < > ( ) ) ; LDPCEncoder * encoder = new LDPCEncoder ( k , n , encodingMatrix , symbols ) ; LDPCDecoder * decoder = new LDPCDecoder ( k , n , parityMatrix , passes , symbols ) ; std :: cout << std :: time ( NULL ) << " Created ! \n " ; boost :: numeric :: ublas :: matrix < double > results ( snrdb . size ( ) , 26 ) ; for ( int i = 0 ; i < snrdb . size ( ) ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { results ( i , j ) = 0 ; } } for ( int packet = 0 ; packet < maxPackets ; packet ++ ) { if ( packet % printInterval == 0 ) { std :: cout << packet << " ▁ " << std :: time ( NULL ) << " \n " ; } std :: vector < int > uncoded ; std :: vector < double > w ; std :: vector < double > w_q ; for ( int i = 0 ; i < n ; i ++ ) { w . push_back ( generator ( ) ) ; if ( qam ) { w_q . push_back ( generator ( ) ) ; } } for ( int i = 0 ; i < k ; i ++ ) { uncoded . push_back ( rand ( ) % 2 ) ; } std :: vector < int > coded = encoder -> encode ( uncoded ) ; int counter = 0 ; for ( double snr = minsnr ; snr < maxsnr ; snr += step ) { if ( packets . at ( counter ) == 0 ) { double n0 = 1 / pow ( 10 , snr / 10 ) / log2 ( symbols ) / 2 ; std :: vector < double > received ; std :: vector < LDPCEncoder :: symbol > modulated ; if ( ! qam ) { for ( int i = 0 ; i < n ; i ++ ) { double rec = 2 * coded . at ( i ) - 1 + w . at ( i ) * sqrt ( n0 ) ; received . push_back ( rec ) ; } for ( int i = 0 ; i < n ; i ++ ) { double llr = - 2 * received . at ( i ) / n0 ; received . at ( i ) = llr ; } } else { modulated = encoder -> modulate ( coded ) ; std :: vector < double > phase ; std :: vector < double > quad ; for ( int i = 0 ; i < modulated . size ( ) ; i ++ ) { phase . push_back ( modulated . at ( i ) . phase + w . at ( i ) * sqrt ( n0 ) ) ; quad . push_back ( modulated . at ( i ) . quad + w_q . at ( i ) * sqrt ( n0 ) ) ; } received = decoder -> deModLlr ( phase , quad , n0 ) ; } while ( received . size ( ) > n ) { received . pop_back ( ) ; } std :: vector < int > decoded = decoder -> decode ( received ) ; int error = 0 ; bool correct = true ; for ( int i = 0 ; i < k ; i ++ ) { if ( decoded . at ( i ) != coded . at ( i ) ) { if ( correct ) { correct = false ; pktErrors . at ( counter ) ++ ; } error ++ ; } } errors . at ( counter ) += error ; if ( pktErrors . at ( counter ) > minErrors ) { packets . at ( counter ) = packet + 1 ; } } counter ++ ; } } std :: cout << std :: time ( NULL ) << " Finished ! \n " ; int counter = 0 ; for ( double snr = minsnr ; snr < maxsnr ; snr += step ) { double nPackets = maxPackets ; if ( packets . at ( counter ) != 0 ) { nPackets = packets . at ( counter ) ; } double per = pktErrors . at ( counter ) / nPackets ; double ber = errors . at ( counter ) / ( nPackets * k ) ; out << snr << " ▁ " << ber << " ▁ " << per << " \n " ; counter ++ ; } enc . close ( ) ; dec . close ( ) ; out . close ( ) ; delete encoder ; delete decoder ; } </DOCUMENT>
<DOCUMENT_ID="Distrotech/xbmc/tree/master/xbmc/android/jni/BaseColumns.cpp"> # include " BaseColumns . h " # include " jutils / jutils - details . hpp " using namespace jni ; std :: string CJNIBaseColumns :: _ID ; std :: string CJNIBaseColumns :: _COUNT ; void CJNIBaseColumns :: PopulateStaticFields ( ) { jhclass clazz = find_class ( " android / provider / BaseColumns " ) ; _ID = ( jcast < std :: string > ( get_static_field < jhstring > ( clazz , " _ ID " ) ) ) ; _COUNT = ( jcast < std :: string > ( get_static_field < jhstring > ( clazz , " _ COUNT " ) ) ) ; } </DOCUMENT>
<DOCUMENT_ID="jeppeter/mysql56/tree/master/storage/ndb/src/cw/cpcd/Monitor.cpp"> # include < ndb_global . h > # include < NdbThread . h > # include < NdbOut . hpp > # include < NdbSleep . h > # include " CPCD . hpp " # include " common . hpp " static void * monitor_thread_create_wrapper ( void * arg ) { CPCD :: Monitor * mon = ( CPCD :: Monitor * ) arg ; mon -> run ( ) ; return NULL ; } CPCD :: Monitor :: Monitor ( CPCD * cpcd , int poll ) { m_cpcd = cpcd ; m_pollingInterval = poll ; m_changeCondition = NdbCondition_Create ( ) ; m_changeMutex = NdbMutex_Create ( ) ; m_monitorThread = NdbThread_Create ( monitor_thread_create_wrapper , ( NDB_THREAD_ARG * ) this , 0 , " ndb _ cpcd _ monitor " , NDB_THREAD_PRIO_MEAN ) ; m_monitorThreadQuitFlag = false ; } CPCD :: Monitor :: ~ Monitor ( ) { NdbThread_Destroy ( & m_monitorThread ) ; NdbCondition_Destroy ( m_changeCondition ) ; NdbMutex_Destroy ( m_changeMutex ) ; } void CPCD :: Monitor :: run ( ) { while ( 1 ) { NdbMutex_Lock ( m_changeMutex ) ; NdbCondition_WaitTimeout ( m_changeCondition , m_changeMutex , m_pollingInterval * 1000 ) ; MutexVector < CPCD :: Process * > & proc = * m_cpcd -> getProcessList ( ) ; proc . lock ( ) ; for ( size_t i = 0 ; i < proc . size ( ) ; i ++ ) { proc [ i ] -> monitor ( ) ; } proc . unlock ( ) ; NdbMutex_Unlock ( m_changeMutex ) ; } } void CPCD :: Monitor :: signal ( ) { NdbCondition_Signal ( m_changeCondition ) ; } template class MutexVector < CPCD :: Process * > ; </DOCUMENT>
<DOCUMENT_ID="pcolby/libqtaws/tree/master/src/ssm/describeinstancepatchstatesresponse.cpp"> # include " describeinstancepatchstatesresponse . h " # include " describeinstancepatchstatesresponse _ p . h " # include < QDebug > # include < QNetworkReply > # include < QXmlStreamReader > namespace QtAws { namespace SSM { DescribeInstancePatchStatesResponse :: DescribeInstancePatchStatesResponse ( const DescribeInstancePatchStatesRequest & request , QNetworkReply * const reply , QObject * const parent ) : SsmResponse ( new DescribeInstancePatchStatesResponsePrivate ( this ) , parent ) { setRequest ( new DescribeInstancePatchStatesRequest ( request ) ) ; setReply ( reply ) ; } const DescribeInstancePatchStatesRequest * DescribeInstancePatchStatesResponse :: request ( ) const { Q_D ( const DescribeInstancePatchStatesResponse ) ; return static_cast < const DescribeInstancePatchStatesRequest * > ( d -> request ) ; } void DescribeInstancePatchStatesResponse :: parseSuccess ( QIODevice & response ) { QXmlStreamReader xml ( & response ) ; } DescribeInstancePatchStatesResponsePrivate :: DescribeInstancePatchStatesResponsePrivate ( DescribeInstancePatchStatesResponse * const q ) : SsmResponsePrivate ( q ) { } void DescribeInstancePatchStatesResponsePrivate :: parseDescribeInstancePatchStatesResponse ( QXmlStreamReader & xml ) { Q_ASSERT ( xml . name ( ) == QLatin1String ( " DescribeInstancePatchStatesResponse " ) ) ; Q_UNUSED ( xml ) } } } </DOCUMENT>
<DOCUMENT_ID="jobermayr/pcsx2/tree/master/3rdparty/wxwidgets3.0/src/common/filectrlcmn.cpp"> # include " wx / wxprec . h " # ifdef __BORLANDC__ # pragma hdrstop # endif # if wxUSE_FILECTRL # include " wx / filectrl . h " # ifndef WX_PRECOMP # include " wx / debug . h " # endif const char wxFileCtrlNameStr [ ] = " wxfilectrl " ; wxDEFINE_EVENT ( wxEVT_FILECTRL_SELECTIONCHANGED , wxFileCtrlEvent ) ; wxDEFINE_EVENT ( wxEVT_FILECTRL_FILEACTIVATED , wxFileCtrlEvent ) ; wxDEFINE_EVENT ( wxEVT_FILECTRL_FOLDERCHANGED , wxFileCtrlEvent ) ; wxDEFINE_EVENT ( wxEVT_FILECTRL_FILTERCHANGED , wxFileCtrlEvent ) ; IMPLEMENT_DYNAMIC_CLASS ( wxFileCtrlEvent , wxCommandEvent ) void GenerateFilterChangedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_FILTERCHANGED , wnd , wnd -> GetId ( ) ) ; event . SetFilterIndex ( fileCtrl -> GetFilterIndex ( ) ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } void GenerateFolderChangedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_FOLDERCHANGED , wnd , wnd -> GetId ( ) ) ; event . SetDirectory ( fileCtrl -> GetDirectory ( ) ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } void GenerateSelectionChangedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_SELECTIONCHANGED , wnd , wnd -> GetId ( ) ) ; event . SetDirectory ( fileCtrl -> GetDirectory ( ) ) ; wxArrayString filenames ; fileCtrl -> GetFilenames ( filenames ) ; event . SetFiles ( filenames ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } void GenerateFileActivatedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd , const wxString filename ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_FILEACTIVATED , wnd , wnd -> GetId ( ) ) ; event . SetDirectory ( fileCtrl -> GetDirectory ( ) ) ; wxArrayString filenames ; if ( filename . empty ( ) ) { fileCtrl -> GetFilenames ( filenames ) ; } else { filenames . Add ( filename ) ; } event . SetFiles ( filenames ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } wxString wxFileCtrlEvent :: GetFile ( ) const { wxASSERT_MSG ( ! wxDynamicCast ( GetEventObject ( ) , wxFileCtrl ) -> HasMultipleFileSelection ( ) , wxT ( " Please ▁ use ▁ GetFiles ( ) ▁ to ▁ get ▁ all ▁ files ▁ instead ▁ of ▁ this ▁ function " ) ) ; wxString string ; if ( m_files . Count ( ) != 0 ) string = m_files [ 0 ] ; return string ; } # endif </DOCUMENT>
<DOCUMENT_ID="ShiftMediaProject/game-music-emu/tree/master/gme/Ay_Apu.cpp"> # include " Ay _ Apu . h " # include " blargg _ source . h " unsigned const inaudible_freq = 16384 ; int const period_factor = 16 ; static byte const amp_table [ 16 ] = { # define ENTRY ( n ) byte ( n * Ay_Apu :: amp_range + 0.5 ) ENTRY ( 0.000000 ) , ENTRY ( 0.007813 ) , ENTRY ( 0.011049 ) , ENTRY ( 0.015625 ) , ENTRY ( 0.022097 ) , ENTRY ( 0.031250 ) , ENTRY ( 0.044194 ) , ENTRY ( 0.062500 ) , ENTRY ( 0.088388 ) , ENTRY ( 0.125000 ) , ENTRY ( 0.176777 ) , ENTRY ( 0.250000 ) , ENTRY ( 0.353553 ) , ENTRY ( 0.500000 ) , ENTRY ( 0.707107 ) , ENTRY ( 1.000000 ) , # undef ENTRY } ; static byte const modes [ 8 ] = { # define MODE ( a0 , a1 , b0 , b1 , c0 , c1 ) ( a0 | a1 << 1 | b0 << 2 | b1 << 3 | c0 << 4 | c1 << 5 ) MODE ( 1 , 0 , 1 , 0 , 1 , 0 ) , MODE ( 1 , 0 , 0 , 0 , 0 , 0 ) , MODE ( 1 , 0 , 0 , 1 , 1 , 0 ) , MODE ( 1 , 0 , 1 , 1 , 1 , 1 ) , MODE ( 0 , 1 , 0 , 1 , 0 , 1 ) , MODE ( 0 , 1 , 1 , 1 , 1 , 1 ) , MODE ( 0 , 1 , 1 , 0 , 0 , 1 ) , MODE ( 0 , 1 , 0 , 0 , 0 , 0 ) , } ; Ay_Apu :: Ay_Apu ( ) { for ( int m = 8 ; m -- ; ) { byte * out = env . modes [ m ] ; int flags = modes [ m ] ; for ( int x = 3 ; -- x >= 0 ; ) { int amp = flags & 1 ; int end = flags >> 1 & 1 ; int step = end - amp ; amp *= 15 ; for ( int y = 16 ; -- y >= 0 ; ) { * out ++ = amp_table [ amp ] ; amp += step ; } flags >>= 2 ; } } output ( 0 ) ; volume ( 1.0 ) ; reset ( ) ; } void Ay_Apu :: reset ( ) { last_time = 0 ; noise . delay = 0 ; noise . lfsr = 1 ; osc_t * osc = & oscs [ osc_count ] ; do { osc -- ; osc -> period = period_factor ; osc -> delay = 0 ; osc -> last_amp = 0 ; osc -> phase = 0 ; } while ( osc != oscs ) ; for ( int i = sizeof regs ; -- i >= 0 ; ) regs [ i ] = 0 ; regs [ 7 ] = 0xFF ; write_data_ ( 13 , 0 ) ; } void Ay_Apu :: write_data_ ( int addr , int data ) { assert ( ( unsigned ) addr < reg_count ) ; if ( ( unsigned ) addr >= 14 ) { # ifdef debug_printf debug_printf ( " Wrote ▁ to ▁ I / O ▁ port ▁ % 02X \n " , ( int ) addr ) ; # endif } if ( addr == 13 ) { if ( ! ( data & 8 ) ) data = ( data & 4 ) ? 15 : 9 ; env . wave = env . modes [ data - 7 ] ; env . pos = - 48 ; env . delay = 0 ; } regs [ addr ] = data ; int i = addr >> 1 ; if ( i < osc_count ) { blip_time_t period = ( regs [ i * 2 + 1 ] & 0x0F ) * ( 0x100L * period_factor ) + regs [ i * 2 ] * period_factor ; if ( ! period ) period = period_factor ; osc_t & osc = oscs [ i ] ; if ( ( osc . delay += period - osc . period ) < 0 ) osc . delay = 0 ; osc . period = period ; } } int const noise_off = 0x08 ; int const tone_off = 0x01 ; void Ay_Apu :: run_until ( blip_time_t final_end_time ) { require ( final_end_time >= last_time ) ; blip_time_t const noise_period_factor = period_factor * 2 ; blip_time_t noise_period = ( regs [ 6 ] & 0x1F ) * noise_period_factor ; if ( ! noise_period ) noise_period = noise_period_factor ; blip_time_t const old_noise_delay = noise . delay ; blargg_ulong const old_noise_lfsr = noise . lfsr ; blip_time_t const env_period_factor = period_factor * 2 ; blip_time_t env_period = ( regs [ 12 ] * 0x100L + regs [ 11 ] ) * env_period_factor ; if ( ! env_period ) env_period = env_period_factor ; if ( ! env . delay ) env . delay = env_period ; for ( int index = 0 ; index < osc_count ; index ++ ) { osc_t * const osc = & oscs [ index ] ; int osc_mode = regs [ 7 ] >> index ; Blip_Buffer * const osc_output = osc -> output ; if ( ! osc_output ) continue ; osc_output -> set_modified ( ) ; int half_vol = 0 ; blip_time_t inaudible_period = ( blargg_ulong ) ( osc_output -> clock_rate ( ) + inaudible_freq ) / ( inaudible_freq * 2 ) ; if ( osc -> period <= inaudible_period && ! ( osc_mode & tone_off ) ) { half_vol = 1 ; osc_mode |= tone_off ; } blip_time_t start_time = last_time ; blip_time_t end_time = final_end_time ; int const vol_mode = regs [ 0x08 + index ] ; int volume = amp_table [ vol_mode & 0x0F ] >> half_vol ; int osc_env_pos = env . pos ; if ( vol_mode & 0x10 ) { volume = env . wave [ osc_env_pos ] >> half_vol ; if ( ! ( regs [ 13 ] & 1 ) || osc_env_pos < - 32 ) { end_time = start_time + env . delay ; if ( end_time >= final_end_time ) end_time = final_end_time ; } else if ( ! volume ) { osc_mode = noise_off | tone_off ; } } else if ( ! volume ) { osc_mode = noise_off | tone_off ; } blip_time_t const period = osc -> period ; blip_time_t time = start_time + osc -> delay ; if ( osc_mode & tone_off ) { blargg_long count = ( final_end_time - time + period - 1 ) / period ; time += count * period ; osc -> phase ^= count & 1 ; } blip_time_t ntime = final_end_time ; blargg_ulong noise_lfsr = 1 ; if ( ! ( osc_mode & noise_off ) ) { ntime = start_time + old_noise_delay ; noise_lfsr = old_noise_lfsr ; } while ( 1 ) { int amp = 0 ; if ( ( osc_mode | osc -> phase ) & 1 & ( osc_mode >> 3 | noise_lfsr ) ) amp = volume ; { int delta = amp - osc -> last_amp ; if ( delta ) { osc -> last_amp = amp ; synth_ . offset ( start_time , delta , osc_output ) ; } } if ( ntime < end_time || time < end_time ) { int delta = amp * 2 - volume ; int delta_non_zero = delta != 0 ; int phase = osc -> phase | ( osc_mode & tone_off ) ; assert ( tone_off == 0x01 ) ; do { blip_time_t end = end_time ; if ( end_time > time ) end = time ; if ( phase & delta_non_zero ) { while ( ntime <= end ) { int changed = noise_lfsr + 1 ; noise_lfsr = ( - ( noise_lfsr & 1 ) & 0x12000 ) ^ ( noise_lfsr >> 1 ) ; if ( changed & 2 ) { delta = - delta ; synth_ . offset ( ntime , delta , osc_output ) ; } ntime += noise_period ; } } else { blargg_long remain = end - ntime ; blargg_long count = remain / noise_period ; if ( remain >= 0 ) ntime += noise_period + count * noise_period ; } end = end_time ; if ( end_time > ntime ) end = ntime ; if ( noise_lfsr & delta_non_zero ) { while ( time < end ) { delta = - delta ; synth_ . offset ( time , delta , osc_output ) ; time += period ; } phase = unsigned ( - delta ) >> ( CHAR_BIT * sizeof ( unsigned ) - 1 ) ; } else { while ( time < end ) { time += period ; phase ^= 1 ; } } } while ( time < end_time || ntime < end_time ) ; osc -> last_amp = ( delta + volume ) >> 1 ; if ( ! ( osc_mode & tone_off ) ) osc -> phase = phase ; } if ( end_time >= final_end_time ) break ; if ( ++ osc_env_pos >= 0 ) osc_env_pos -= 32 ; volume = env . wave [ osc_env_pos ] >> half_vol ; start_time = end_time ; end_time += env_period ; if ( end_time > final_end_time ) end_time = final_end_time ; } osc -> delay = time - final_end_time ; if ( ! ( osc_mode & noise_off ) ) { noise . delay = ntime - final_end_time ; noise . lfsr = noise_lfsr ; } } blip_time_t remain = final_end_time - last_time - env . delay ; if ( remain >= 0 ) { blargg_long count = ( remain + env_period ) / env_period ; env . pos += count ; if ( env . pos >= 0 ) env . pos = ( env . pos & 31 ) - 32 ; remain -= count * env_period ; assert ( - remain <= env_period ) ; } env . delay = - remain ; assert ( env . delay > 0 ) ; assert ( env . pos < 0 ) ; last_time = final_end_time ; } </DOCUMENT>
<DOCUMENT_ID="dodamn/pkg-dosbox/tree/master/src/hardware/mixer.cpp"> # include < string . h > # include < sys / types . h > # include < math . h > # if defined ( WIN32 ) # ifndef WIN32_LEAN_AND_MEAN # define WIN32_LEAN_AND_MEAN # endif # include < windows . h > # include < mmsystem . h > # endif # include " SDL . h " # include " mem . h " # include " pic . h " # include " dosbox . h " # include " mixer . h " # include " timer . h " # include " setup . h " # include " cross . h " # include " support . h " # include " mapper . h " # include " hardware . h " # include " programs . h " # define MIXER_SSIZE 4 # define MIXER_SHIFT 14 # define MIXER_REMAIN ( ( 1 << MIXER_SHIFT ) - 1 ) # define MIXER_VOLSHIFT 13 static INLINE Bit16s MIXER_CLIP ( Bits SAMP ) { if ( SAMP < MAX_AUDIO ) { if ( SAMP > MIN_AUDIO ) return SAMP ; else return MIN_AUDIO ; } else return MAX_AUDIO ; } static struct { Bit32s work [ MIXER_BUFSIZE ] [ 2 ] ; Bitu pos , done ; Bitu needed , min_needed , max_needed ; Bit32u tick_add , tick_remain ; float mastervol [ 2 ] ; MixerChannel * channels ; bool nosound ; Bit32u freq ; Bit32u blocksize ; } mixer ; Bit8u MixTemp [ MIXER_BUFSIZE ] ; MixerChannel * MIXER_AddChannel ( MIXER_Handler handler , Bitu freq , const char * name ) { MixerChannel * chan = new MixerChannel ( ) ; chan -> scale = 1.0 ; chan -> handler = handler ; chan -> name = name ; chan -> SetFreq ( freq ) ; chan -> next = mixer . channels ; chan -> SetVolume ( 1 , 1 ) ; chan -> enabled = false ; mixer . channels = chan ; return chan ; } MixerChannel * MIXER_FindChannel ( const char * name ) { MixerChannel * chan = mixer . channels ; while ( chan ) { if ( ! strcasecmp ( chan -> name , name ) ) break ; chan = chan -> next ; } return chan ; } void MIXER_DelChannel ( MixerChannel * delchan ) { MixerChannel * chan = mixer . channels ; MixerChannel * * where = & mixer . channels ; while ( chan ) { if ( chan == delchan ) { * where = chan -> next ; delete delchan ; return ; } where = & chan -> next ; chan = chan -> next ; } } void MixerChannel :: UpdateVolume ( void ) { volmul [ 0 ] = ( Bits ) ( ( 1 << MIXER_VOLSHIFT ) * scale * volmain [ 0 ] * mixer . mastervol [ 0 ] ) ; volmul [ 1 ] = ( Bits ) ( ( 1 << MIXER_VOLSHIFT ) * scale * volmain [ 1 ] * mixer . mastervol [ 1 ] ) ; } void MixerChannel :: SetVolume ( float _left , float _right ) { volmain [ 0 ] = _left ; volmain [ 1 ] = _right ; UpdateVolume ( ) ; } void MixerChannel :: SetScale ( float f ) { scale = f ; UpdateVolume ( ) ; } void MixerChannel :: Enable ( bool _yesno ) { if ( _yesno == enabled ) return ; enabled = _yesno ; if ( enabled ) { freq_index = MIXER_REMAIN ; SDL_LockAudio ( ) ; if ( done < mixer . done ) done = mixer . done ; SDL_UnlockAudio ( ) ; } } void MixerChannel :: SetFreq ( Bitu _freq ) { freq_add = ( _freq << MIXER_SHIFT ) / mixer . freq ; } void MixerChannel :: Mix ( Bitu _needed ) { needed = _needed ; while ( enabled && needed > done ) { Bitu todo = needed - done ; todo *= freq_add ; if ( todo & MIXER_REMAIN ) { todo = ( todo >> MIXER_SHIFT ) + 1 ; } else { todo = ( todo >> MIXER_SHIFT ) ; } handler ( todo ) ; } } void MixerChannel :: AddSilence ( void ) { if ( done < needed ) { done = needed ; last [ 0 ] = last [ 1 ] = 0 ; freq_index = MIXER_REMAIN ; } } template < class Type , bool stereo , bool signeddata , bool nativeorder > inline void MixerChannel :: AddSamples ( Bitu len , const Type * data ) { Bits diff [ 2 ] ; Bitu mixpos = mixer . pos + done ; freq_index &= MIXER_REMAIN ; Bitu pos = 0 ; Bitu new_pos ; goto thestart ; for ( ; ; ) { new_pos = freq_index >> MIXER_SHIFT ; if ( pos < new_pos ) { last [ 0 ] += diff [ 0 ] ; if ( stereo ) last [ 1 ] += diff [ 1 ] ; pos = new_pos ; thestart : if ( pos >= len ) return ; if ( sizeof ( Type ) == 1 ) { if ( ! signeddata ) { if ( stereo ) { diff [ 0 ] = ( ( ( Bit8s ) ( data [ pos * 2 + 0 ] ^ 0x80 ) ) << 8 ) - last [ 0 ] ; diff [ 1 ] = ( ( ( Bit8s ) ( data [ pos * 2 + 1 ] ^ 0x80 ) ) << 8 ) - last [ 1 ] ; } else { diff [ 0 ] = ( ( ( Bit8s ) ( data [ pos ] ^ 0x80 ) ) << 8 ) - last [ 0 ] ; } } else { if ( stereo ) { diff [ 0 ] = ( data [ pos * 2 + 0 ] << 8 ) - last [ 0 ] ; diff [ 1 ] = ( data [ pos * 2 + 1 ] << 8 ) - last [ 1 ] ; } else { diff [ 0 ] = ( data [ pos ] << 8 ) - last [ 0 ] ; } } } else { if ( signeddata ) { if ( stereo ) { if ( nativeorder ) { diff [ 0 ] = data [ pos * 2 + 0 ] - last [ 0 ] ; diff [ 1 ] = data [ pos * 2 + 1 ] - last [ 1 ] ; } else { if ( sizeof ( Type ) == 2 ) { diff [ 0 ] = ( Bit16s ) host_readw ( ( HostPt ) & data [ pos * 2 + 0 ] ) - last [ 0 ] ; diff [ 1 ] = ( Bit16s ) host_readw ( ( HostPt ) & data [ pos * 2 + 1 ] ) - last [ 1 ] ; } else { diff [ 0 ] = ( Bit32s ) host_readd ( ( HostPt ) & data [ pos * 2 + 0 ] ) - last [ 0 ] ; diff [ 1 ] = ( Bit32s ) host_readd ( ( HostPt ) & data [ pos * 2 + 1 ] ) - last [ 1 ] ; } } } else { if ( nativeorder ) { diff [ 0 ] = data [ pos ] - last [ 0 ] ; } else { if ( sizeof ( Type ) == 2 ) { diff [ 0 ] = ( Bit16s ) host_readw ( ( HostPt ) & data [ pos ] ) - last [ 0 ] ; } else { diff [ 0 ] = ( Bit32s ) host_readd ( ( HostPt ) & data [ pos ] ) - last [ 0 ] ; } } } } else { if ( stereo ) { if ( nativeorder ) { diff [ 0 ] = ( Bits ) data [ pos * 2 + 0 ] - 32768 - last [ 0 ] ; diff [ 1 ] = ( Bits ) data [ pos * 2 + 1 ] - 32768 - last [ 1 ] ; } else { if ( sizeof ( Type ) == 2 ) { diff [ 0 ] = ( Bits ) host_readw ( ( HostPt ) & data [ pos * 2 + 0 ] ) - 32768 - last [ 0 ] ; diff [ 1 ] = ( Bits ) host_readw ( ( HostPt ) & data [ pos * 2 + 1 ] ) - 32768 - last [ 1 ] ; } else { diff [ 0 ] = ( Bits ) host_readd ( ( HostPt ) & data [ pos * 2 + 0 ] ) - 32768 - last [ 0 ] ; diff [ 1 ] = ( Bits ) host_readd ( ( HostPt ) & data [ pos * 2 + 1 ] ) - 32768 - last [ 1 ] ; } } } else { if ( nativeorder ) { diff [ 0 ] = ( Bits ) data [ pos ] - 32768 - last [ 0 ] ; } else { if ( sizeof ( Type ) == 2 ) { diff [ 0 ] = ( Bits ) host_readw ( ( HostPt ) & data [ pos ] ) - 32768 - last [ 0 ] ; } else { diff [ 0 ] = ( Bits ) host_readd ( ( HostPt ) & data [ pos ] ) - 32768 - last [ 0 ] ; } } } } } } Bits diff_mul = freq_index & MIXER_REMAIN ; freq_index += freq_add ; mixpos &= MIXER_BUFMASK ; Bits sample = last [ 0 ] + ( ( diff [ 0 ] * diff_mul ) >> MIXER_SHIFT ) ; mixer . work [ mixpos ] [ 0 ] += sample * volmul [ 0 ] ; if ( stereo ) sample = last [ 1 ] + ( ( diff [ 1 ] * diff_mul ) >> MIXER_SHIFT ) ; mixer . work [ mixpos ] [ 1 ] += sample * volmul [ 1 ] ; mixpos ++ ; done ++ ; } } void MixerChannel :: AddStretched ( Bitu len , Bit16s * data ) { if ( done >= needed ) { LOG_MSG ( " Can ' t ▁ add , ▁ buffer ▁ full " ) ; return ; } Bitu outlen = needed - done ; Bits diff ; freq_index = 0 ; Bitu temp_add = ( len << MIXER_SHIFT ) / outlen ; Bitu mixpos = mixer . pos + done ; done = needed ; Bitu pos = 0 ; diff = data [ 0 ] - last [ 0 ] ; while ( outlen -- ) { Bitu new_pos = freq_index >> MIXER_SHIFT ; if ( pos < new_pos ) { pos = new_pos ; last [ 0 ] += diff ; diff = data [ pos ] - last [ 0 ] ; } Bits diff_mul = freq_index & MIXER_REMAIN ; freq_index += temp_add ; mixpos &= MIXER_BUFMASK ; Bits sample = last [ 0 ] + ( ( diff * diff_mul ) >> MIXER_SHIFT ) ; mixer . work [ mixpos ] [ 0 ] += sample * volmul [ 0 ] ; mixer . work [ mixpos ] [ 1 ] += sample * volmul [ 1 ] ; mixpos ++ ; } } void MixerChannel :: AddSamples_m8 ( Bitu len , const Bit8u * data ) { AddSamples < Bit8u , false , false , true > ( len , data ) ; } void MixerChannel :: AddSamples_s8 ( Bitu len , const Bit8u * data ) { AddSamples < Bit8u , true , false , true > ( len , data ) ; } void MixerChannel :: AddSamples_m8s ( Bitu len , const Bit8s * data ) { AddSamples < Bit8s , false , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_s8s ( Bitu len , const Bit8s * data ) { AddSamples < Bit8s , true , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_m16 ( Bitu len , const Bit16s * data ) { AddSamples < Bit16s , false , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_s16 ( Bitu len , const Bit16s * data ) { AddSamples < Bit16s , true , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_m16u ( Bitu len , const Bit16u * data ) { AddSamples < Bit16u , false , false , true > ( len , data ) ; } void MixerChannel :: AddSamples_s16u ( Bitu len , const Bit16u * data ) { AddSamples < Bit16u , true , false , true > ( len , data ) ; } void MixerChannel :: AddSamples_m32 ( Bitu len , const Bit32s * data ) { AddSamples < Bit32s , false , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_s32 ( Bitu len , const Bit32s * data ) { AddSamples < Bit32s , true , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_m16_nonnative ( Bitu len , const Bit16s * data ) { AddSamples < Bit16s , false , true , false > ( len , data ) ; } void MixerChannel :: AddSamples_s16_nonnative ( Bitu len , const Bit16s * data ) { AddSamples < Bit16s , true , true , false > ( len , data ) ; } void MixerChannel :: AddSamples_m16u_nonnative ( Bitu len , const Bit16u * data ) { AddSamples < Bit16u , false , false , false > ( len , data ) ; } void MixerChannel :: AddSamples_s16u_nonnative ( Bitu len , const Bit16u * data ) { AddSamples < Bit16u , true , false , false > ( len , data ) ; } void MixerChannel :: AddSamples_m32_nonnative ( Bitu len , const Bit32s * data ) { AddSamples < Bit32s , false , true , false > ( len , data ) ; } void MixerChannel :: AddSamples_s32_nonnative ( Bitu len , const Bit32s * data ) { AddSamples < Bit32s , true , true , false > ( len , data ) ; } void MixerChannel :: FillUp ( void ) { SDL_LockAudio ( ) ; if ( ! enabled || done < mixer . done ) { SDL_UnlockAudio ( ) ; return ; } float index = PIC_TickIndex ( ) ; Mix ( ( Bitu ) ( index * mixer . needed ) ) ; SDL_UnlockAudio ( ) ; } extern bool ticksLocked ; static inline bool Mixer_irq_important ( void ) { return ( ticksLocked || ( CaptureState & ( CAPTURE_WAVE | CAPTURE_VIDEO ) ) ) ; } static void MIXER_MixData ( Bitu needed ) { MixerChannel * chan = mixer . channels ; while ( chan ) { chan -> Mix ( needed ) ; chan = chan -> next ; } if ( CaptureState & ( CAPTURE_WAVE | CAPTURE_VIDEO ) ) { Bit16s convert [ 1024 ] [ 2 ] ; Bitu added = needed - mixer . done ; if ( added > 1024 ) added = 1024 ; Bitu readpos = ( mixer . pos + mixer . done ) & MIXER_BUFMASK ; for ( Bitu i = 0 ; i < added ; i ++ ) { Bits sample = mixer . work [ readpos ] [ 0 ] >> MIXER_VOLSHIFT ; convert [ i ] [ 0 ] = MIXER_CLIP ( sample ) ; sample = mixer . work [ readpos ] [ 1 ] >> MIXER_VOLSHIFT ; convert [ i ] [ 1 ] = MIXER_CLIP ( sample ) ; readpos = ( readpos + 1 ) & MIXER_BUFMASK ; } CAPTURE_AddWave ( mixer . freq , added , ( Bit16s * ) convert ) ; } if ( Mixer_irq_important ( ) ) mixer . tick_add = ( ( mixer . freq ) << MIXER_SHIFT ) / 1000 ; mixer . done = needed ; } static void MIXER_Mix ( void ) { SDL_LockAudio ( ) ; MIXER_MixData ( mixer . needed ) ; mixer . tick_remain += mixer . tick_add ; mixer . needed += ( mixer . tick_remain >> MIXER_SHIFT ) ; mixer . tick_remain &= MIXER_REMAIN ; SDL_UnlockAudio ( ) ; } static void MIXER_Mix_NoSound ( void ) { MIXER_MixData ( mixer . needed ) ; for ( Bitu i = 0 ; i < mixer . needed ; i ++ ) { mixer . work [ mixer . pos ] [ 0 ] = 0 ; mixer . work [ mixer . pos ] [ 1 ] = 0 ; mixer . pos = ( mixer . pos + 1 ) & MIXER_BUFMASK ; } for ( MixerChannel * chan = mixer . channels ; chan ; chan = chan -> next ) { if ( chan -> done > mixer . needed ) chan -> done -= mixer . needed ; else chan -> done = 0 ; } mixer . tick_remain += mixer . tick_add ; mixer . needed = mixer . tick_remain >> MIXER_SHIFT ; mixer . tick_remain &= MIXER_REMAIN ; mixer . done = 0 ; } static void MIXER_CallBack ( void * userdata , Uint8 * stream , int len ) { Bitu need = ( Bitu ) len / MIXER_SSIZE ; Bit16s * output = ( Bit16s * ) stream ; Bitu reduce ; Bitu pos , index , index_add ; Bits sample ; if ( mixer . done < need ) { if ( ( need - mixer . done ) > ( need >> 7 ) ) return ; reduce = mixer . done ; index_add = ( reduce << MIXER_SHIFT ) / need ; mixer . tick_add = ( ( mixer . freq + mixer . min_needed ) << MIXER_SHIFT ) / 1000 ; } else if ( mixer . done < mixer . max_needed ) { Bitu left = mixer . done - need ; if ( left < mixer . min_needed ) { if ( ! Mixer_irq_important ( ) ) { Bitu needed = mixer . needed - need ; Bitu diff = ( mixer . min_needed > needed ? mixer . min_needed : needed ) - left ; mixer . tick_add = ( ( mixer . freq + ( diff * 3 ) ) << MIXER_SHIFT ) / 1000 ; left = 0 ; } else { left = ( mixer . min_needed - left ) ; left = 1 + ( 2 * left ) / mixer . min_needed ; } reduce = need - left ; index_add = ( reduce << MIXER_SHIFT ) / need ; } else { reduce = need ; index_add = ( 1 << MIXER_SHIFT ) ; Bitu diff = left - mixer . min_needed ; if ( diff > ( mixer . min_needed << 1 ) ) diff = mixer . min_needed << 1 ; if ( diff > ( mixer . min_needed >> 1 ) ) mixer . tick_add = ( ( mixer . freq - ( diff / 5 ) ) << MIXER_SHIFT ) / 1000 ; else if ( diff > ( mixer . min_needed >> 4 ) ) mixer . tick_add = ( ( mixer . freq - ( diff >> 3 ) ) << MIXER_SHIFT ) / 1000 ; else mixer . tick_add = ( mixer . freq << MIXER_SHIFT ) / 1000 ; } } else { if ( mixer . done > MIXER_BUFSIZE ) index_add = MIXER_BUFSIZE - 2 * mixer . min_needed ; else index_add = mixer . done - 2 * mixer . min_needed ; index_add = ( index_add << MIXER_SHIFT ) / need ; reduce = mixer . done - 2 * mixer . min_needed ; mixer . tick_add = ( ( mixer . freq - ( mixer . min_needed / 5 ) ) << MIXER_SHIFT ) / 1000 ; } for ( MixerChannel * chan = mixer . channels ; chan ; chan = chan -> next ) { if ( chan -> done > reduce ) chan -> done -= reduce ; else chan -> done = 0 ; } if ( Mixer_irq_important ( ) ) mixer . tick_add = ( mixer . freq << MIXER_SHIFT ) / 1000 ; mixer . done -= reduce ; mixer . needed -= reduce ; pos = mixer . pos ; mixer . pos = ( mixer . pos + reduce ) & MIXER_BUFMASK ; index = 0 ; if ( need != reduce ) { while ( need -- ) { Bitu i = ( pos + ( index >> MIXER_SHIFT ) ) & MIXER_BUFMASK ; index += index_add ; sample = mixer . work [ i ] [ 0 ] >> MIXER_VOLSHIFT ; * output ++ = MIXER_CLIP ( sample ) ; sample = mixer . work [ i ] [ 1 ] >> MIXER_VOLSHIFT ; * output ++ = MIXER_CLIP ( sample ) ; } while ( reduce -- ) { pos &= MIXER_BUFMASK ; mixer . work [ pos ] [ 0 ] = 0 ; mixer . work [ pos ] [ 1 ] = 0 ; pos ++ ; } } else { while ( reduce -- ) { pos &= MIXER_BUFMASK ; sample = mixer . work [ pos ] [ 0 ] >> MIXER_VOLSHIFT ; * output ++ = MIXER_CLIP ( sample ) ; sample = mixer . work [ pos ] [ 1 ] >> MIXER_VOLSHIFT ; * output ++ = MIXER_CLIP ( sample ) ; mixer . work [ pos ] [ 0 ] = 0 ; mixer . work [ pos ] [ 1 ] = 0 ; pos ++ ; } } } static void MIXER_Stop ( Section * sec ) { } class MIXER : public Program { public : void MakeVolume ( char * scan , float & vol0 , float & vol1 ) { Bitu w = 0 ; bool db = ( toupper ( * scan ) == ' D ' ) ; if ( db ) scan ++ ; while ( * scan ) { if ( * scan == ' : ' ) { ++ scan ; w = 1 ; } char * before = scan ; float val = ( float ) strtod ( scan , & scan ) ; if ( before == scan ) { ++ scan ; continue ; } if ( ! db ) val /= 100 ; else val = powf ( 10.0f , ( float ) val / 20.0f ) ; if ( val < 0 ) val = 1.0f ; if ( ! w ) { vol0 = val ; } else { vol1 = val ; } } if ( ! w ) vol1 = vol0 ; } void Run ( void ) { if ( cmd -> FindExist ( " / LISTMIDI " ) ) { ListMidi ( ) ; return ; } if ( cmd -> FindString ( " MASTER " , temp_line , false ) ) { MakeVolume ( ( char * ) temp_line . c_str ( ) , mixer . mastervol [ 0 ] , mixer . mastervol [ 1 ] ) ; } MixerChannel * chan = mixer . channels ; while ( chan ) { if ( cmd -> FindString ( chan -> name , temp_line , false ) ) { MakeVolume ( ( char * ) temp_line . c_str ( ) , chan -> volmain [ 0 ] , chan -> volmain [ 1 ] ) ; } chan -> UpdateVolume ( ) ; chan = chan -> next ; } if ( cmd -> FindExist ( " / NOSHOW " ) ) return ; chan = mixer . channels ; WriteOut ( " Channel ▁ ▁ Main ▁ ▁ ▁ ▁ Main ( dB ) \n " ) ; ShowVolume ( " MASTER " , mixer . mastervol [ 0 ] , mixer . mastervol [ 1 ] ) ; for ( chan = mixer . channels ; chan ; chan = chan -> next ) ShowVolume ( chan -> name , chan -> volmain [ 0 ] , chan -> volmain [ 1 ] ) ; } private : void ShowVolume ( const char * name , float vol0 , float vol1 ) { WriteOut ( " % -8s ▁ % 3.0f : % - 3.0f ▁ ▁ % + 3.2f : % - + 3.2f ▁ \n " , name , vol0 * 100 , vol1 * 100 , 20 * log ( vol0 ) / log ( 10.0f ) , 20 * log ( vol1 ) / log ( 10.0f ) ) ; } void ListMidi ( ) { # if defined ( WIN32 ) unsigned int total = midiOutGetNumDevs ( ) ; for ( unsigned int i = 0 ; i < total ; i ++ ) { MIDIOUTCAPS mididev ; midiOutGetDevCaps ( i , & mididev , sizeof ( MIDIOUTCAPS ) ) ; WriteOut ( " % 2d\t ▁ \ " % s\ " \n " , i , mididev . szPname ) ; } # endif return ; } ; } ; static void MIXER_ProgramStart ( Program * * make ) { * make = new MIXER ; } MixerChannel * MixerObject :: Install ( MIXER_Handler handler , Bitu freq , const char * name ) { if ( ! installed ) { if ( strlen ( name ) > 31 ) E_Exit ( " Too ▁ long ▁ mixer ▁ channel ▁ name " ) ; safe_strncpy ( m_name , name , 32 ) ; installed = true ; return MIXER_AddChannel ( handler , freq , name ) ; } else { E_Exit ( " allready ▁ added ▁ mixer ▁ channel . " ) ; return 0 ; } } MixerObject :: ~ MixerObject ( ) { if ( ! installed ) return ; MIXER_DelChannel ( MIXER_FindChannel ( m_name ) ) ; } void MIXER_Init ( Section * sec ) { sec -> AddDestroyFunction ( & MIXER_Stop ) ; Section_prop * section = static_cast < Section_prop * > ( sec ) ; mixer . freq = section -> Get_int ( " rate " ) ; mixer . nosound = section -> Get_bool ( " nosound " ) ; mixer . blocksize = section -> Get_int ( " blocksize " ) ; mixer . channels = 0 ; mixer . pos = 0 ; mixer . done = 0 ; memset ( mixer . work , 0 , sizeof ( mixer . work ) ) ; mixer . mastervol [ 0 ] = 1.0f ; mixer . mastervol [ 1 ] = 1.0f ; SDL_AudioSpec spec ; SDL_AudioSpec obtained ; spec . freq = mixer . freq ; spec . format = AUDIO_S16SYS ; spec . channels = 2 ; spec . callback = MIXER_CallBack ; spec . userdata = NULL ; spec . samples = ( Uint16 ) mixer . blocksize ; mixer . tick_remain = 0 ; if ( mixer . nosound ) { LOG_MSG ( " MIXER : No ▁ Sound ▁ Mode ▁ Selected . " ) ; mixer . tick_add = ( ( mixer . freq ) << MIXER_SHIFT ) / 1000 ; TIMER_AddTickHandler ( MIXER_Mix_NoSound ) ; } else if ( SDL_OpenAudio ( & spec , & obtained ) < 0 ) { mixer . nosound = true ; LOG_MSG ( " MIXER : Can ' t ▁ open ▁ audio : ▁ % s ▁ , ▁ running ▁ in ▁ nosound ▁ mode . " , SDL_GetError ( ) ) ; mixer . tick_add = ( ( mixer . freq ) << MIXER_SHIFT ) / 1000 ; TIMER_AddTickHandler ( MIXER_Mix_NoSound ) ; } else { mixer . freq = obtained . freq ; mixer . blocksize = obtained . samples ; mixer . tick_add = ( mixer . freq << MIXER_SHIFT ) / 1000 ; TIMER_AddTickHandler ( MIXER_Mix ) ; SDL_PauseAudio ( 0 ) ; } mixer . min_needed = section -> Get_int ( " prebuffer " ) ; if ( mixer . min_needed > 100 ) mixer . min_needed = 100 ; mixer . min_needed = ( mixer . freq * mixer . min_needed ) / 1000 ; mixer . max_needed = mixer . blocksize * 2 + 2 * mixer . min_needed ; mixer . needed = mixer . min_needed + 1 ; PROGRAMS_MakeFile ( " MIXER . COM " , MIXER_ProgramStart ) ; } </DOCUMENT>
<DOCUMENT_ID="wakashige/TrinityCore/tree/master/src/server/scripts/EasternKingdoms/zone_arathi_highlands.cpp"> # include " ScriptMgr . h " # include " ScriptedCreature . h " # include " ScriptedEscortAI . h " # include " Player . h " enum ProfessorPhizzlethorpe { SAY_PROGRESS_1 = 0 , SAY_PROGRESS_2 = 1 , SAY_PROGRESS_3 = 2 , EMOTE_PROGRESS_4 = 3 , SAY_AGGRO = 4 , SAY_PROGRESS_5 = 5 , SAY_PROGRESS_6 = 6 , SAY_PROGRESS_7 = 7 , EMOTE_PROGRESS_8 = 8 , SAY_PROGRESS_9 = 9 , EVENT_SAY_3 = 1 , EVENT_SAY_6 = 2 , EVENT_SAY_8 = 3 , QUEST_SUNKEN_TREASURE = 665 , QUEST_GOGGLE_BOGGLE = 26050 , NPC_VENGEFUL_SURGE = 2776 , FACTION_SUNKEN_TREASURE = 113 } ; class npc_professor_phizzlethorpe : public CreatureScript { public : npc_professor_phizzlethorpe ( ) : CreatureScript ( " npc _ professor _ phizzlethorpe " ) { } struct npc_professor_phizzlethorpeAI : public npc_escortAI { npc_professor_phizzlethorpeAI ( Creature * creature ) : npc_escortAI ( creature ) { } void WaypointReached ( uint32 waypointId ) override { Player * player = GetPlayerForEscort ( ) ; if ( ! player ) return ; switch ( waypointId ) { case 6 : Talk ( SAY_PROGRESS_2 , player ) ; events . ScheduleEvent ( EVENT_SAY_3 , 3000 ) ; break ; case 8 : Talk ( EMOTE_PROGRESS_4 ) ; me -> SummonCreature ( NPC_VENGEFUL_SURGE , - 2065.505f , - 2136.88f , 22.20362f , 1.0f , TEMPSUMMON_CORPSE_DESPAWN , 0 ) ; me -> SummonCreature ( NPC_VENGEFUL_SURGE , - 2059.249f , - 2134.88f , 21.51582f , 1.0f , TEMPSUMMON_CORPSE_DESPAWN , 0 ) ; break ; case 11 : Talk ( SAY_PROGRESS_5 , player ) ; events . ScheduleEvent ( EVENT_SAY_6 , 11000 ) ; break ; case 17 : Talk ( SAY_PROGRESS_7 , player ) ; events . ScheduleEvent ( EVENT_SAY_8 , 6000 ) ; break ; } } void JustSummoned ( Creature * summoned ) override { summoned -> AI ( ) -> AttackStart ( me ) ; } void EnterCombat ( Unit * ) override { Talk ( SAY_AGGRO ) ; } void sQuestAccept ( Player * player , Quest const * quest ) override { if ( quest -> GetQuestId ( ) == QUEST_SUNKEN_TREASURE ) { Talk ( SAY_PROGRESS_1 , player ) ; npc_escortAI :: Start ( false , false , player -> GetGUID ( ) , quest ) ; me -> setFaction ( FACTION_SUNKEN_TREASURE ) ; } } void UpdateAI ( uint32 diff ) override { Player * player = GetPlayerForEscort ( ) ; if ( ! player ) return ; events . Update ( diff ) ; while ( uint32 event = events . ExecuteEvent ( ) ) { switch ( event ) { case EVENT_SAY_3 : Talk ( SAY_PROGRESS_3 , player ) ; break ; case EVENT_SAY_6 : Talk ( SAY_PROGRESS_6 , player ) ; SetRun ( ) ; break ; case EVENT_SAY_8 : Talk ( EMOTE_PROGRESS_8 ) ; Talk ( SAY_PROGRESS_9 , player ) ; player -> GroupEventHappens ( QUEST_GOGGLE_BOGGLE , me ) ; break ; } } npc_escortAI :: UpdateAI ( diff ) ; } EventMap events ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return new npc_professor_phizzlethorpeAI ( creature ) ; } } ; void AddSC_arathi_highlands ( ) { new npc_professor_phizzlethorpe ( ) ; } </DOCUMENT>
<DOCUMENT_ID="plexinc/plex-home-theater-public/tree/master/plex/Update-Installer/external/win32cpp/tutorials/Tutorial8/View.cpp"> # include " view . h " # include " GDI . h " # include " file . h " # include " resource . h " using namespace std ; CView :: CView ( ) : m_PenColor ( RGB ( 0 , 0 , 0 ) ) { m_Brush . CreateSolidBrush ( RGB ( 255 , 255 , 230 ) ) ; } CView :: ~ CView ( ) { } void CView :: ClearPoints ( ) { m_points . clear ( ) ; Invalidate ( ) ; } void CView :: DrawLine ( int x , int y ) { CClientDC dcClient ( this ) ; dcClient . CreatePen ( PS_SOLID , 1 , m_points . back ( ) . color ) ; dcClient . MoveTo ( m_points . back ( ) . x , m_points . back ( ) . y ) ; dcClient . LineTo ( x , y ) ; } void CView :: OnDraw ( CDC * pDC ) { if ( m_points . size ( ) > 0 ) { bool bDraw = false ; for ( unsigned int i = 0 ; i < m_points . size ( ) ; i ++ ) { pDC -> CreatePen ( PS_SOLID , 1 , m_points [ i ] . color ) ; if ( bDraw ) pDC -> LineTo ( m_points [ i ] . x , m_points [ i ] . y ) ; else pDC -> MoveTo ( m_points [ i ] . x , m_points [ i ] . y ) ; bDraw = m_points [ i ] . PenDown ; } } } void CView :: PreCreate ( CREATESTRUCT & cs ) { cs . dwExStyle = WS_EX_CLIENTEDGE ; } void CView :: PreRegisterClass ( WNDCLASS & wc ) { wc . hbrBackground = m_Brush ; wc . lpszClassName = _T ( " Scribble ▁ Window " ) ; wc . hCursor = :: LoadCursor ( GetApp ( ) -> GetInstanceHandle ( ) , MAKEINTRESOURCE ( IDC_CURSOR1 ) ) ; } BOOL CView :: FileOpen ( LPCTSTR szFilename ) { m_points . clear ( ) ; DWORD nBytesRead ; BOOL bResult = FALSE ; CFile File ; if ( File . Open ( szFilename , OPEN_EXISTING ) ) { do { PlotPoint pp ; nBytesRead = File . Read ( & pp , sizeof ( PlotPoint ) ) ; if ( nBytesRead == sizeof ( PlotPoint ) ) m_points . push_back ( pp ) ; } while ( nBytesRead == sizeof ( PlotPoint ) ) ; if ( ( 0 != nBytesRead ) || ( m_points . empty ( ) ) ) { m_points . clear ( ) ; :: MessageBox ( 0 , _T ( " Invalid ▁ data ▁ in ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; } else bResult = TRUE ; } else { tString tsErrMsg = _T ( " Failed ▁ to ▁ open ▁ file ▁ " ) ; tsErrMsg += szFilename ; :: MessageBox ( 0 , tsErrMsg . c_str ( ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; } Invalidate ( ) ; return bResult ; } BOOL CView :: FileSave ( LPCTSTR szFilename ) { BOOL bResult = TRUE ; CFile hFile ; if ( ! hFile . Open ( szFilename , CREATE_ALWAYS ) ) { :: MessageBox ( 0 , _T ( " Failed ▁ to ▁ open ▁ file ▁ for ▁ writing " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; } if ( bResult ) { for ( size_t i = 0 ; i < m_points . size ( ) ; ++ i ) { if ( ! hFile . Write ( & m_points [ i ] , sizeof ( PlotPoint ) ) ) { :: MessageBox ( 0 , _T ( " Error ▁ while ▁ writing ▁ to ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; break ; } } if ( hFile . GetLength ( ) != m_points . size ( ) * sizeof ( PlotPoint ) ) { :: MessageBox ( 0 , _T ( " Error ▁ while ▁ writing ▁ to ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; } } return bResult ; } void CView :: SetPen ( COLORREF color ) { m_PenColor = color ; } void CView :: StorePoint ( int x , int y , bool PenDown ) { PlotPoint P1 ; P1 . x = x ; P1 . y = y ; P1 . PenDown = PenDown ; P1 . color = m_PenColor ; m_points . push_back ( P1 ) ; } void CView :: OnLButtonDown ( LPARAM lParam ) { SetCapture ( ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , true ) ; } void CView :: OnLButtonUp ( LPARAM lParam ) { { ReleaseCapture ( ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , false ) ; } } void CView :: OnMouseMove ( WPARAM wParam , LPARAM lParam ) { if ( ( wParam & MK_LBUTTON ) && ( GetCapture ( ) == this ) ) { DrawLine ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , true ) ; } } LRESULT CView :: WndProc ( UINT uMsg , WPARAM wParam , LPARAM lParam ) { switch ( uMsg ) { case WM_LBUTTONDOWN : OnLButtonDown ( lParam ) ; break ; case WM_MOUSEMOVE : OnMouseMove ( wParam , lParam ) ; break ; case WM_LBUTTONUP : OnLButtonUp ( lParam ) ; break ; } return WndProcDefault ( uMsg , wParam , lParam ) ; } </DOCUMENT>
<DOCUMENT_ID="Baha/z3/tree/master/src/qe/qe_arith_plugin.cpp"> # include " qe . h " # include " ast _ pp . h " # include " expr _ safe _ replace . h " # include " bool _ rewriter . h " # include " bv _ decl _ plugin . h " # include " arith _ decl _ plugin . h " # include " arith _ eq _ solver . h " # include " arith _ rewriter . h " # include " th _ rewriter . h " # include " factor _ rewriter . h " # include " obj _ pair _ hashtable . h " # include " nlarith _ util . h " # include " model _ evaluator . h " # include " smt _ kernel . h " namespace qe { class bound { rational m_coeff ; expr_ref m_term ; bool m_is_strict ; public : bound ( ast_manager & m , rational const & n , expr * t , bool is_strict ) : m_coeff ( n ) , m_term ( t , m ) , m_is_strict ( is_strict ) { } bool is_strict ( ) const { return m_is_strict ; } expr * term ( ) const { return m_term . get ( ) ; } rational const & coeff ( ) const { return m_coeff ; } void update ( rational const & k , expr * t ) { m_coeff = k ; m_term = t ; } void pp ( std :: ostream & out , app * x ) { ast_manager & m = m_term . get_manager ( ) ; out << " ( < = ▁ ( + ▁ ( * ▁ " << coeff ( ) << " ▁ " << mk_pp ( x , m ) << " ) ▁ " << mk_pp ( term ( ) , m ) << " ) ▁ 0 ) " ; } } ; typedef rational numeral ; class div_constraint { numeral m_k ; numeral m_a ; expr * m_term ; public : div_constraint ( numeral const & k , numeral const & a , expr * t ) : m_k ( k ) , m_a ( a ) , m_term ( t ) { } numeral const & a ( ) const { return m_a ; } numeral const & k ( ) const { return m_k ; } expr * t ( ) const { return m_term ; } numeral & a_ref ( ) { return m_a ; } numeral & k_ref ( ) { return m_k ; } expr * & t_ref ( ) { return m_term ; } } ; typedef vector < div_constraint > div_constraints ; class arith_qe_util { ast_manager & m ; i_solver_context & m_ctx ; public : arith_util m_arith ; th_rewriter simplify ; private : arith_eq_solver m_arith_solver ; bv_util m_bv ; expr_ref m_zero_i ; expr_ref m_one_i ; expr_ref m_minus_one_i ; expr_ref m_zero_r ; expr_ref m_one_r ; expr_ref m_tmp ; public : expr_safe_replace m_replace ; bool_rewriter m_bool_rewriter ; arith_rewriter m_arith_rewriter ; arith_qe_util ( ast_manager & m , smt_params & p , i_solver_context & ctx ) : m ( m ) , m_ctx ( ctx ) , m_arith ( m ) , simplify ( m ) , m_arith_solver ( m ) , m_bv ( m ) , m_zero_i ( m_arith . mk_numeral ( numeral ( 0 ) , true ) , m ) , m_one_i ( m_arith . mk_numeral ( numeral ( 1 ) , true ) , m ) , m_minus_one_i ( m_arith . mk_numeral ( numeral ( - 1 ) , true ) , m ) , m_zero_r ( m_arith . mk_numeral ( numeral ( 0 ) , false ) , m ) , m_one_r ( m_arith . mk_numeral ( numeral ( 1 ) , false ) , m ) , m_tmp ( m ) , m_replace ( m ) , m_bool_rewriter ( m ) , m_arith_rewriter ( m ) { } ast_manager & get_manager ( ) { return m ; } bool get_coeff ( contains_app & contains_x , expr * p , rational & k , expr_ref & rest ) { app * x = contains_x . x ( ) ; ptr_vector < expr > restl , todo ; todo . push_back ( p ) ; bool found = false ; expr * e1 , * e2 ; while ( ! todo . empty ( ) ) { expr * e = todo . back ( ) ; todo . pop_back ( ) ; if ( m_arith . is_add ( e ) ) { for ( unsigned i = 0 ; i < to_app ( e ) -> get_num_args ( ) ; ++ i ) { todo . push_back ( to_app ( e ) -> get_arg ( i ) ) ; } } else if ( e == x ) { k = numeral ( 1 ) ; found = true ; break ; } else if ( m_arith . is_mul ( e , e1 , e2 ) && e1 == x && m_arith . is_numeral ( e2 , k ) ) { found = true ; break ; } else if ( m_arith . is_mul ( e , e1 , e2 ) && e2 == x && m_arith . is_numeral ( e1 , k ) ) { found = true ; break ; } else { restl . push_back ( e ) ; } } if ( ! found ) { TRACE ( " qe _ verbose " , tout << " Did ▁ not ▁ find : ▁ " << mk_pp ( x , m ) << " ▁ in ▁ " << mk_pp ( p , m ) << " \n " ; ) ; return false ; } while ( ! todo . empty ( ) ) { restl . push_back ( todo . back ( ) ) ; todo . pop_back ( ) ; } if ( restl . empty ( ) ) { rest = mk_zero ( x ) ; } else { rest = m_arith . mk_add ( restl . size ( ) , restl . c_ptr ( ) ) ; } if ( contains_x ( rest ) ) { return false ; } TRACE ( " qe _ verbose " , tout << mk_pp ( p , m ) << " ▁ = ▁ " << " ( + ▁ ( * ▁ " << k << " ▁ " << mk_pp ( x , m ) << " ) ▁ " << mk_pp ( rest , m ) << " ) \n " ; ) ; return true ; } void get_const ( expr * p , rational & k , expr_ref & rest ) { ptr_vector < expr > todo , restl ; todo . push_back ( p ) ; k = numeral ( 0 ) ; while ( ! todo . empty ( ) ) { p = todo . back ( ) ; todo . pop_back ( ) ; if ( m_arith . is_add ( p ) ) { for ( unsigned i = 0 ; i < to_app ( p ) -> get_num_args ( ) ; ++ i ) { todo . push_back ( to_app ( p ) -> get_arg ( i ) ) ; } } else if ( m_arith . is_numeral ( p , k ) ) { break ; } else { restl . push_back ( p ) ; } } while ( ! todo . empty ( ) ) { restl . push_back ( todo . back ( ) ) ; todo . pop_back ( ) ; } if ( restl . empty ( ) ) { rest = mk_zero ( p ) ; } else { rest = m_arith . mk_add ( restl . size ( ) , restl . c_ptr ( ) ) ; } } bool is_neg ( app * e , expr_ref & ne ) { if ( m . is_not ( e ) ) { ne = to_app ( e ) -> get_arg ( 0 ) ; return true ; } return false ; } bool is_le ( app * e , expr_ref & p ) { return is_le_ge_core < 1 > ( e , p ) ; } bool is_ge ( app * e , expr_ref & p ) { return is_le_ge_core < 0 > ( e , p ) ; } bool is_lt ( app * e , expr_ref & p ) { numeral k ; expr * a1 , * a2 ; if ( m_arith . is_lt ( e , a1 , a2 ) || m_arith . is_gt ( e , a2 , a1 ) ) { p = a1 ; if ( m_arith . is_numeral ( a2 , k ) && k . is_zero ( ) ) { return true ; } } else { return false ; } p = mk_sub ( p , a2 ) ; simplify ( p ) ; return true ; } bool is_divides ( app * e , numeral & k , expr_ref & p ) { expr * e1 , * e2 ; if ( ! m . is_eq ( e , e1 , e2 ) ) { return false ; } return is_divides ( e1 , e2 , k , p ) || is_divides ( e2 , e1 , k , p ) ; } bool is_divides ( expr * e1 , expr * e2 , numeral & k , expr_ref & p ) { if ( m_arith . is_mod ( e2 ) && m_arith . is_numeral ( e1 , k ) && k . is_zero ( ) && m_arith . is_numeral ( to_app ( e2 ) -> get_arg ( 1 ) , k ) ) { p = to_app ( e2 ) -> get_arg ( 0 ) ; return true ; } return false ; } bool is_not_divides ( app * e , app_ref & n , numeral & k , expr_ref & p ) { if ( ! m . is_not ( e ) ) { return false ; } if ( ! is_app ( to_app ( e ) -> get_arg ( 0 ) ) ) { return false ; } n = to_app ( to_app ( e ) -> get_arg ( 0 ) ) ; return is_divides ( n , k , p ) ; } bool is_real ( app * x ) const { return m_arith . is_real ( x ) ; } template < bool is_strict > void mk_bound_aux ( rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { SASSERT ( a . is_neg ( ) == b . is_neg ( ) ) ; expr_ref tt ( t , m ) , ss ( s , m ) , e ( m ) ; rational abs_a ( a ) ; rational abs_b ( b ) ; if ( abs_a . is_neg ( ) ) abs_a . neg ( ) ; if ( abs_b . is_neg ( ) ) abs_b . neg ( ) ; ss = mk_mul ( abs_a , ss ) ; tt = mk_mul ( abs_b , tt ) ; if ( a . is_neg ( ) ) { e = mk_sub ( tt , ss ) ; if ( is_strict ) { if ( m_arith . is_int ( e ) ) { e = mk_add ( e , m_one_i ) ; mk_le ( e , result ) ; } else { mk_lt ( e , result ) ; } } else { mk_le ( e , result ) ; } } else { e = mk_sub ( ss , tt ) ; if ( is_strict ) { if ( m_arith . is_int ( e ) ) { e = mk_add ( e , m_one_i ) ; mk_le ( e , result ) ; } else { mk_lt ( e , result ) ; } } else { mk_le ( e , result ) ; } } } void mk_bound ( rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { mk_bound_aux < false > ( a , t , b , s , result ) ; } void mk_strict_bound ( rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { mk_bound_aux < true > ( a , t , b , s , result ) ; } void mk_divides ( numeral n , expr * e , expr_ref & result ) { SASSERT ( n . is_int ( ) ) ; expr_ref tmp1 ( e , m ) , tmp2 ( m ) ; simplify ( tmp1 ) ; m_arith_rewriter . mk_mod ( tmp1 , mk_numeral ( n ) , tmp2 ) ; m_bool_rewriter . mk_eq ( m_zero_i , tmp2 , result ) ; } void mk_div ( expr * a , numeral const & k , expr_ref & result ) { result = m_arith . mk_div ( a , m_arith . mk_numeral ( k , false ) ) ; simplify ( result ) ; } expr * mk_numeral ( numeral const & k , bool is_int = true ) { return m_arith . mk_numeral ( k , is_int ) ; } expr * mk_numeral ( int k , bool is_int ) { return mk_numeral ( numeral ( k ) , is_int ) ; } expr * mk_uminus ( expr * e ) { return m_arith . mk_uminus ( e ) ; } expr * mk_abs ( expr * e ) { rational val ; if ( m_arith . is_numeral ( e , val ) ) { if ( val . is_neg ( ) ) { return m_arith . mk_uminus ( e ) ; } else { return e ; } } else { return m . mk_ite ( m_arith . mk_le ( mk_zero ( e ) , e ) , e , m_arith . mk_uminus ( e ) ) ; } } template < bool is_max > expr_ref mk_min_max ( unsigned num_args , expr * const * args ) { SASSERT ( num_args > 0 ) ; if ( num_args == 1 ) { return expr_ref ( args [ 0 ] , m ) ; } else { expr_ref e2 = mk_min_max < is_max > ( num_args - 1 , args + 1 ) ; expr * e1 = args [ 0 ] ; expr * cmp = is_max ? m_arith . mk_le ( e1 , e2 ) : m_arith . mk_le ( e2 , e1 ) ; return expr_ref ( m . mk_ite ( cmp , e2 , e1 ) , m ) ; } } expr_ref mk_max ( unsigned num_args , expr * const * args ) { return mk_min_max < true > ( num_args , args ) ; } expr_ref mk_min ( unsigned num_args , expr * const * args ) { return mk_min_max < false > ( num_args , args ) ; } expr * mk_mul ( expr * a , expr * b ) { return m_arith . mk_mul ( a , b ) ; } expr * mk_add ( expr * a , expr * b ) { return m_arith . mk_add ( a , b ) ; } expr * mk_sub ( expr * a , expr * b ) { return m_arith . mk_sub ( a , b ) ; } expr * mk_mul ( numeral const & a , expr * b ) { if ( a . is_one ( ) ) return b ; return m_arith . mk_mul ( mk_numeral ( a , m_arith . is_int ( b ) ) , b ) ; } expr * mk_zero ( sort * s ) { return m_arith . is_int ( s ) ? m_zero_i : m_zero_r ; } expr * mk_zero ( expr * e ) { return m_arith . is_int ( e ) ? m_zero_i : m_zero_r ; } expr * mk_one ( sort * s ) { return m_arith . is_int ( s ) ? m_one_i : m_one_r ; } expr * mk_one ( expr * e ) { return m_arith . is_int ( e ) ? m_one_i : m_one_r ; } void mk_le ( expr * e , expr_ref & result ) { expr_ref tmp ( e , m ) ; simplify ( tmp ) ; m_arith_rewriter . mk_le ( tmp , mk_zero ( e ) , result ) ; } void mk_lt ( expr * e , expr_ref & result ) { rational r ; if ( m_arith . is_numeral ( e , r ) ) { if ( r . is_neg ( ) ) { result = m . mk_true ( ) ; } else { result = m . mk_false ( ) ; } } else if ( m_arith . is_int ( e ) ) { result = m_arith . mk_le ( e , m_minus_one_i ) ; } else { result = m . mk_not ( m_arith . mk_le ( mk_zero ( e ) , e ) ) ; } simplify ( result ) ; TRACE ( " qe _ verbose " , tout << " mk _ lt ▁ " << mk_pp ( result , m ) << " \n " ; ) ; } void mk_eq ( rational const & a , app * x , expr * t , expr_ref & result ) { result = m_arith . mk_eq ( mk_add ( mk_mul ( a , x ) , t ) , mk_zero ( x ) ) ; } void mk_and ( unsigned sz , expr * const * args , expr_ref & result ) { m_bool_rewriter . mk_and ( sz , args , result ) ; } void mk_and ( expr * e1 , expr * e2 , expr_ref & result ) { m_bool_rewriter . mk_and ( e1 , e2 , result ) ; } void add_and ( expr * e , ptr_vector < expr > & conjs ) { if ( m . is_and ( e ) ) { conjs . append ( to_app ( e ) -> get_num_args ( ) , to_app ( e ) -> get_args ( ) ) ; } else { conjs . push_back ( e ) ; } } void mk_flat_and ( expr * e1 , expr * e2 , expr_ref & result ) { ptr_vector < expr > conjs ; add_and ( e1 , conjs ) ; add_and ( e2 , conjs ) ; m_bool_rewriter . mk_and ( conjs . size ( ) , conjs . c_ptr ( ) , result ) ; } void mk_or ( unsigned sz , expr * const * args , expr_ref & result ) { m_bool_rewriter . mk_or ( sz , args , result ) ; } void mk_or ( expr * e1 , expr * e2 , expr_ref & result ) { m_bool_rewriter . mk_or ( e1 , e2 , result ) ; } void mk_resolve ( app * x , bool is_strict , rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { rational abs_a ( abs ( a ) ) , abs_b ( abs ( b ) ) ; SASSERT ( a . is_neg ( ) == b . is_pos ( ) ) ; SASSERT ( ! is_strict || ( abs_a . is_one ( ) && abs_b . is_one ( ) ) ) ; expr_ref bt ( mk_mul ( abs_b , t ) , m ) ; expr_ref as ( mk_mul ( abs_a , s ) , m ) ; expr_ref as_bt ( mk_add ( as , bt ) , m ) ; if ( is_strict ) { mk_lt ( as_bt , result ) ; } else { mk_le ( as_bt , result ) ; } if ( ! abs_a . is_one ( ) && ! abs_b . is_one ( ) ) { SASSERT ( ! is_strict ) ; SASSERT ( abs_a > rational :: one ( ) && abs_b > rational :: one ( ) ) ; expr_ref slack ( mk_numeral ( ( abs_a - numeral ( 1 ) ) * ( abs_b - numeral ( 1 ) ) , true ) , m ) ; expr_ref result1 ( m ) , result2 ( m ) ; expr_ref as_bt_le_0 ( result , m ) , tmp2 ( m ) , asz_bt_le_0 ( m ) , tmp3 ( m ) , tmp4 ( m ) ; expr_ref b_divides_sz ( m ) ; tmp2 = m_arith . mk_add ( as_bt , slack ) ; mk_le ( tmp2 , result1 ) ; rational a1 = a , b1 = b ; if ( abs_a < abs_b ) { std :: swap ( abs_a , abs_b ) ; std :: swap ( a1 , b1 ) ; std :: swap ( s , t ) ; std :: swap ( as , bt ) ; } SASSERT ( abs_a >= abs_b ) ; expr_ref sz ( mk_add ( s , x ) , m ) ; if ( b1 . is_pos ( ) ) { sz = m_arith . mk_uminus ( sz ) ; } tmp4 = mk_add ( mk_mul ( a1 , sz ) , bt ) ; mk_le ( tmp4 , asz_bt_le_0 ) ; if ( to_app ( asz_bt_le_0 ) -> get_arg ( 0 ) == x && m_arith . is_zero ( to_app ( asz_bt_le_0 ) -> get_arg ( 1 ) ) ) { mk_divides ( abs_b , s , tmp2 ) ; } else { mk_divides ( abs_b , sz , b_divides_sz ) ; mk_and ( b_divides_sz , asz_bt_le_0 , tmp4 ) ; mk_big_or ( abs_b - numeral ( 2 ) , x , tmp4 , tmp2 ) ; TRACE ( " qe " , tout << " b ▁ | ▁ s ▁ + ▁ z : ▁ " << mk_pp ( b_divides_sz , m ) << " \n " ; tout << " a ( s + z ) ▁ + ▁ bt ▁ < = ▁ 0 : ▁ " << mk_pp ( asz_bt_le_0 , m ) << " \n " ; ) ; } mk_flat_and ( as_bt_le_0 , tmp2 , result2 ) ; mk_or ( result1 , result2 , result ) ; simplify ( result ) ; } TRACE ( " qe " , { tout << ( is_strict ? " strict " : " non - strict " ) << " \n " ; bound ( m , a , t , false ) . pp ( tout , x ) ; tout << " \n " ; bound ( m , b , s , false ) . pp ( tout , x ) ; tout << " \n " ; tout << mk_pp ( result , m ) << " \n " ; } ) ; } struct mul_lt { arith_util & u ; mul_lt ( arith_qe_util & u ) : u ( u . m_arith ) { } bool operator ( ) ( expr * n1 , expr * n2 ) const { expr * x , * y ; if ( u . is_mul ( n1 , x , y ) && u . is_numeral ( x ) ) { n1 = y ; } if ( u . is_mul ( n2 , x , y ) && u . is_numeral ( x ) ) { n2 = y ; } return n1 -> get_id ( ) < n2 -> get_id ( ) ; } } ; void normalize_sum ( expr_ref & p ) { simplify ( p ) ; if ( ! m_arith . is_add ( p ) ) { return ; } unsigned sz = to_app ( p ) -> get_num_args ( ) ; ptr_buffer < expr > args ; for ( unsigned i = 0 ; i < sz ; ++ i ) { args . push_back ( to_app ( p ) -> get_arg ( i ) ) ; } std :: sort ( args . begin ( ) , args . end ( ) , mul_lt ( * this ) ) ; p = m_arith . mk_add ( args . size ( ) , args . c_ptr ( ) ) ; } void pp_div ( std :: ostream & out , app * x , div_constraint const & div ) { out << div . k ( ) << " ▁ | ▁ ( " << div . a ( ) << " * " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( div . t ( ) , m ) << " ) ▁ " ; } void pp_divs ( std :: ostream & out , app * x , div_constraints const & divs ) { for ( unsigned i = 0 ; i < divs . size ( ) ; ++ i ) { pp_div ( out , x , divs [ i ] ) ; out << " ▁ " ; } } bool mk_atom ( expr * e , bool p , expr_ref & result ) { if ( ! is_app ( e ) ) { return false ; } app * a = to_app ( e ) ; expr_ref t1 ( m ) , t2 ( m ) ; expr_ref tmp1 ( m ) , tmp2 ( m ) ; rational k ; expr * a0 , * a1 ; if ( p && is_divides ( a , k , tmp1 ) ) { result = e ; } else if ( ! p && is_divides ( a , k , tmp1 ) ) { m_bool_rewriter . mk_not ( e , result ) ; } else if ( p && m . is_eq ( e , a0 , a1 ) && is_arith ( a0 ) ) { t1 = mk_sub ( a0 , a1 ) ; simplify ( t1 ) ; t2 = mk_sub ( a1 , a0 ) ; simplify ( t2 ) ; mk_le ( t1 , tmp1 ) ; mk_le ( t2 , tmp2 ) ; mk_and ( tmp1 , tmp2 , result ) ; } else if ( ! p && m . is_eq ( e , a0 , a1 ) && m_arith . is_int ( a0 ) ) { tmp1 = mk_sub ( a0 , a1 ) ; t1 = mk_add ( mk_one ( a0 ) , tmp1 ) ; simplify ( t1 ) ; t2 = mk_sub ( mk_one ( a0 ) , tmp1 ) ; simplify ( t2 ) ; mk_le ( t1 , tmp1 ) ; mk_le ( t2 , tmp2 ) ; mk_or ( tmp1 , tmp2 , result ) ; } else if ( ! p && m . is_eq ( e , a0 , a1 ) && m_arith . is_real ( a0 ) ) { t1 = mk_sub ( a0 , a1 ) ; simplify ( t1 ) ; t2 = mk_sub ( a1 , a0 ) ; simplify ( t2 ) ; mk_lt ( t1 , tmp1 ) ; mk_lt ( t2 , tmp2 ) ; mk_or ( tmp1 , tmp2 , result ) ; } else if ( ! p && ( m_arith . is_le ( e , a0 , a1 ) || m_arith . is_ge ( e , a1 , a0 ) ) ) { tmp1 = mk_sub ( a1 , a0 ) ; mk_lt ( tmp1 , result ) ; } else if ( p && ( m_arith . is_le ( e ) || m_arith . is_ge ( e ) ) ) { result = e ; } else if ( p && ( m_arith . is_lt ( e , a0 , a1 ) || m_arith . is_gt ( e , a1 , a0 ) ) ) { tmp1 = mk_sub ( a0 , a1 ) ; mk_lt ( tmp1 , result ) ; } else if ( ! p && ( m_arith . is_lt ( e , a0 , a1 ) || m_arith . is_gt ( e , a1 , a0 ) ) ) { tmp1 = mk_sub ( a1 , a0 ) ; mk_le ( tmp1 , result ) ; } else { return false ; } TRACE ( " qe _ verbose " , tout << " Atom : ▁ " << mk_pp ( result , m ) << " \n " ; ) ; return true ; } void mk_bounded_var ( rational const & n , app_ref & z_bv , app_ref & z ) { rational two ( 2 ) , b ( n ) ; unsigned sz = 0 ; do { ++ sz ; b = div ( b , two ) ; } while ( b . is_pos ( ) ) ; sort * s = m_bv . mk_sort ( sz ) ; z_bv = m . mk_fresh_const ( " z " , s ) ; expr_ref tmp ( m ) ; z = m_bv . mk_bv2int ( z_bv ) ; } bool solve ( conj_enum & conjs , expr * fml ) { expr_ref_vector eqs ( m ) ; extract_equalities ( conjs , eqs ) ; return reduce_equations ( eqs . size ( ) , eqs . c_ptr ( ) , fml ) ; } void extract_equalities ( conj_enum & conjs , expr_ref_vector & eqs ) { obj_hashtable < expr > leqs ; expr_ref_vector trail ( m ) ; expr_ref tmp1 ( m ) , tmp2 ( m ) ; expr * a0 , * a1 ; eqs . reset ( ) ; conj_enum :: iterator it = conjs . begin ( ) , end = conjs . end ( ) ; for ( ; it != end ; ++ it ) { expr * e = * it ; bool is_leq = false ; if ( m . is_eq ( e , a0 , a1 ) && is_arith ( a0 ) ) { m_arith_rewriter . mk_sub ( a0 , a1 , tmp1 ) ; simplify ( tmp1 ) ; eqs . push_back ( tmp1 ) ; } else if ( m_arith . is_le ( e , a0 , a1 ) || m_arith . is_ge ( e , a1 , a0 ) ) { m_arith_rewriter . mk_sub ( a0 , a1 , tmp1 ) ; is_leq = true ; } else { } if ( is_leq ) { normalize_sum ( tmp1 ) ; tmp2 = m_arith . mk_uminus ( tmp1 ) ; normalize_sum ( tmp2 ) ; if ( leqs . contains ( tmp2 ) ) { eqs . push_back ( tmp1 ) ; TRACE ( " qe " , tout << " found : ▁ ▁ " << mk_pp ( tmp1 , m ) << " \n " ; ) ; } else { trail . push_back ( tmp1 ) ; leqs . insert ( tmp1 ) ; TRACE ( " qe _ verbose " , tout << " insert : ▁ " << mk_pp ( tmp1 , m ) << " \n " ; ) ; } } } } private : template < unsigned IS_LE > bool is_le_ge_core ( app * e , expr_ref & p ) { numeral k ; expr_ref tmp ( m ) ; expr * a2 ; if ( m_arith . is_le ( e ) ) { p = e -> get_arg ( 1 - IS_LE ) ; a2 = e -> get_arg ( IS_LE ) ; if ( m_arith . is_numeral ( a2 , k ) && k . is_zero ( ) ) { return true ; } } else if ( m_arith . is_ge ( e ) ) { p = e -> get_arg ( IS_LE ) ; a2 = e -> get_arg ( 1 - IS_LE ) ; if ( m_arith . is_numeral ( a2 , k ) && k . is_zero ( ) ) { return true ; } } else { return false ; } p = mk_sub ( p , a2 ) ; simplify ( p ) ; return true ; } bool is_arith ( expr * e ) { return m_arith . is_int ( e ) || m_arith . is_real ( e ) ; } void mk_big_or ( numeral up , app * x , expr * body , expr_ref & result ) { TRACE ( " qe " , tout << mk_pp ( x , m ) << " ▁ " << mk_pp ( body , m ) << " \n " ; ) ; if ( numeral ( 1 ) >= up ) { mk_big_or_blast ( up , x , body , result ) ; } else { mk_big_or_symbolic_blast ( up , x , body , result ) ; } } void mk_big_or_blast ( numeral up , app * x , expr * body , expr_ref & result ) { expr_ref_vector ors ( m ) ; numeral index ( 0 ) ; while ( index <= up ) { expr * n = mk_numeral ( index ) ; result = body ; m_replace . apply_substitution ( x , n , result ) ; ors . push_back ( result ) ; ++ index ; } mk_or ( ors . size ( ) , ors . c_ptr ( ) , result ) ; TRACE ( " qe " , tout << " [ 0 ▁ " << up << " ] ▁ " << mk_pp ( x , m ) << " \n " << mk_pp ( body , m ) << " \n " << mk_pp ( result , m ) << " \n " ; ) ; } void mk_big_or_symbolic ( numeral up , app * x , expr * body , expr_ref & result ) { app_ref z_bv ( m ) ; mk_big_or_symbolic ( up , x , body , z_bv , result ) ; m_ctx . add_var ( z_bv ) ; } void mk_big_or_symbolic_blast ( numeral up , app * x , expr * body , expr_ref & result ) { app_ref z_bv ( m ) ; mk_big_or_symbolic ( up , x , body , z_bv , result ) ; m_ctx . blast_or ( z_bv , result ) ; } void mk_big_or_symbolic ( numeral up , app * x , expr * body , app_ref & z_bv , expr_ref & result ) { expr * e1 = m_arith . mk_le ( x , m_arith . mk_numeral ( up , true ) ) ; mk_flat_and ( e1 , body , result ) ; app_ref z ( m ) ; mk_bounded_var ( up , z_bv , z ) ; m_replace . apply_substitution ( x , z , result ) ; } bool isolate_x ( expr * p , app * x , contains_app & contains_x , numeral & coeff ) { numeral k ; while ( m_arith . is_add ( p ) ) { bool found_x = false ; expr * next_p = 0 ; for ( unsigned i = 0 ; i < to_app ( p ) -> get_num_args ( ) ; ++ i ) { expr * arg = to_app ( p ) -> get_arg ( i ) ; if ( contains_x ( arg ) ) { if ( found_x ) { return false ; } found_x = true ; next_p = arg ; } } if ( ! next_p ) { return false ; } p = next_p ; } expr * e1 , * e2 ; if ( p == x ) { coeff = numeral ( 1 ) ; return true ; } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e1 , k ) && e2 == x ) { coeff = k ; return true ; } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e2 , k ) && e1 == x ) { coeff = k ; return true ; } return false ; } bool reduce_equations ( unsigned num_eqs , expr * const * eqs , expr * fml ) { for ( unsigned i = 0 ; i < num_eqs ; ++ i ) { if ( reduce_equation ( eqs [ i ] , fml ) ) { return true ; } } return false ; } bool solve_singular ( unsigned var_idx , expr * p , expr * fml ) { rational k ; expr_ref e ( m ) , tmp ( m ) ; app * x = m_ctx . get_var ( var_idx ) ; if ( ! isolate_x ( p , x , m_ctx . contains ( var_idx ) , k ) ) { return false ; } if ( m_arith . is_int ( x ) && ! ( abs ( k ) . is_one ( ) ) ) { return false ; } if ( abs ( k ) . is_one ( ) ) { if ( k . is_neg ( ) ) { e = m_arith . mk_add ( p , x ) ; } else { e = m_arith . mk_sub ( x , p ) ; } } else { SASSERT ( ! m_arith . is_int ( x ) ) ; expr * ke = m_arith . mk_numeral ( - k , false ) ; tmp = m_arith . mk_mul ( ke , x ) ; tmp = m_arith . mk_add ( p , tmp ) ; e = m_arith . mk_div ( tmp , ke ) ; } TRACE ( " qe " , tout << " is ▁ singular : \n " << mk_pp ( p , m ) << " \n " << mk_pp ( fml , m ) << " \n " << mk_pp ( x , m ) << " ▁ = ▁ " << mk_pp ( e , m ) << " \n " ; ) ; expr_ref result ( fml , m ) ; m_replace . apply_substitution ( x , e , result ) ; simplify ( result ) ; TRACE ( " qe " , tout << " singular ▁ solved : \n " << mk_pp ( result , m ) << " \n " ; ) ; m_ctx . elim_var ( var_idx , result , e ) ; return true ; } bool solve_singular ( expr * p , expr * fml ) { unsigned num_vars = m_ctx . get_num_vars ( ) ; for ( unsigned i = 0 ; i < num_vars ; ++ i ) { if ( solve_singular ( i , p , fml ) ) { return true ; } } return false ; } bool solve_linear ( expr * p , expr * fml ) { vector < numeral > values ; unsigned num_vars = m_ctx . get_num_vars ( ) ; app * const * vars_ptr = m_ctx . get_vars ( ) ; if ( ! is_linear ( p , num_vars , vars_ptr , values ) ) { return false ; } TRACE ( " qe " , tout << " is ▁ linear : ▁ " << mk_pp ( p , m ) << " \n " ; ) ; SASSERT ( values . size ( ) == num_vars + 1 ) ; SASSERT ( num_vars > 0 ) ; unsigned index ; bool is_aux ; VERIFY ( m_arith_solver . solve_integer_equation ( values , index , is_aux ) ) ; SASSERT ( 1 <= index && index <= num_vars ) ; app_ref x ( m_ctx . get_var ( index - 1 ) , m ) ; app_ref z ( m ) ; expr_ref p1 ( m ) ; if ( is_aux ) { SASSERT ( values [ index ] >= rational ( 3 ) ) ; z = m . mk_fresh_const ( " x " , m_arith . mk_int ( ) ) ; m_ctx . add_var ( z ) ; p1 = m_arith . mk_mul ( m_arith . mk_numeral ( values [ index ] , true ) , z ) ; } else { p1 = m_arith . mk_numeral ( numeral ( 0 ) , true ) ; } for ( unsigned i = 1 ; i <= num_vars ; ++ i ) { numeral k = values [ i ] ; if ( ! k . is_zero ( ) && i != index ) { p1 = m_arith . mk_add ( p1 , m_arith . mk_mul ( m_arith . mk_numeral ( k , true ) , m_ctx . get_var ( i - 1 ) ) ) ; } } p1 = m_arith . mk_add ( p1 , m_arith . mk_numeral ( values [ 0 ] , true ) ) ; TRACE ( " qe " , tout << " is ▁ linear : \n " << mk_pp ( fml , m ) << " \n " << mk_pp ( p , m ) << " \n " << mk_pp ( x , m ) << " ▁ = ▁ " << mk_pp ( p1 , m ) << " \n " ; tout << values [ 0 ] << " ▁ + ▁ " ; for ( unsigned i = 0 ; i < num_vars ; ++ i ) { tout << " ▁ + ▁ " << values [ i + 1 ] << " ▁ * ▁ " << mk_pp ( m_ctx . get_var ( i ) , m ) << " ▁ " ; } tout << " ▁ = ▁ 0 \n " ; ) ; expr_ref result ( fml , m ) ; m_replace . apply_substitution ( x , p1 , result ) ; simplify ( result ) ; m_ctx . elim_var ( index - 1 , result , p1 ) ; TRACE ( " qe " , tout << " Reduced : ▁ " << mk_pp ( result , m ) << " \n " ; ) ; return true ; } bool reduce_equation ( expr * p , expr * fml ) { numeral k ; if ( m_arith . is_numeral ( p , k ) && k . is_zero ( ) ) { return false ; } return solve_singular ( p , fml ) || solve_linear ( p , fml ) ; } bool find_variable ( expr * p , unsigned num_vars , app * const * vars , numeral * values , numeral const & k ) { if ( ! is_app ( p ) || to_app ( p ) -> get_num_args ( ) > 0 ) { return false ; } for ( unsigned i = 0 ; i < num_vars ; ++ i ) { if ( p == vars [ i ] ) { values [ i ] += k ; return true ; } } return false ; } bool is_linear ( expr * p , unsigned num_vars , app * const * vars , vector < numeral > & values ) { if ( num_vars == 0 ) { return false ; } values . reset ( ) ; for ( unsigned i = 0 ; i <= num_vars ; ++ i ) { values . push_back ( numeral ( 0 ) ) ; } numeral * vars_ptr = values . c_ptr ( ) + 1 ; ptr_vector < expr > todo ; numeral k ; expr * e1 , * e2 ; todo . push_back ( p ) ; while ( ! todo . empty ( ) ) { p = todo . back ( ) ; todo . pop_back ( ) ; if ( m_arith . is_add ( p ) ) { for ( unsigned i = 0 ; i < to_app ( p ) -> get_num_args ( ) ; ++ i ) { todo . push_back ( to_app ( p ) -> get_arg ( i ) ) ; } } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e1 , k ) && find_variable ( e2 , num_vars , vars , vars_ptr , k ) ) { } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e2 , k ) && find_variable ( e1 , num_vars , vars , vars_ptr , k ) ) { } else if ( find_variable ( p , num_vars , vars , vars_ptr , k ) ) { } else if ( m_arith . is_numeral ( p , k ) ) { values [ 0 ] += k ; } else { TRACE ( " qe _ verbose " , tout << " non - linear ▁ " << mk_pp ( p , m ) << " \n " ; ) ; return false ; } } return true ; } } ; class bounds_proc { arith_qe_util & m_util ; ast_mark m_mark ; expr_ref_vector m_le_terms , m_ge_terms , m_lt_terms , m_gt_terms ; vector < rational > m_le_coeffs , m_ge_coeffs , m_lt_coeffs , m_gt_coeffs ; app_ref_vector m_le_atoms , m_ge_atoms , m_lt_atoms , m_gt_atoms ; expr_ref_vector m_div_terms ; vector < rational > m_div_coeffs , m_div_divisors ; app_ref_vector m_div_atoms ; app_ref m_div_z ; expr_ref_vector m_nested_div_terms ; vector < rational > m_nested_div_coeffs , m_nested_div_divisors ; app_ref_vector m_nested_div_atoms ; app_ref_vector m_nested_div_z ; rational m_d ; public : bounds_proc ( arith_qe_util & u ) : m_util ( u ) , m_le_terms ( u . get_manager ( ) ) , m_ge_terms ( u . get_manager ( ) ) , m_lt_terms ( u . get_manager ( ) ) , m_gt_terms ( u . get_manager ( ) ) , m_le_atoms ( u . get_manager ( ) ) , m_ge_atoms ( u . get_manager ( ) ) , m_lt_atoms ( u . get_manager ( ) ) , m_gt_atoms ( u . get_manager ( ) ) , m_div_terms ( u . get_manager ( ) ) , m_div_atoms ( u . get_manager ( ) ) , m_div_z ( u . get_manager ( ) ) , m_nested_div_terms ( u . get_manager ( ) ) , m_nested_div_atoms ( u . get_manager ( ) ) , m_nested_div_z ( u . get_manager ( ) ) { reset ( ) ; } bool get_bound ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; app * x = contains_x . x ( ) ; if ( m_mark . is_marked ( a ) || get_le_bound ( contains_x , a ) || get_lt_bound ( contains_x , a ) || get_divides ( contains_x , a ) || get_nested_divs ( contains_x , a ) ) { TRACE ( " qe _ verbose " , tout << " Bound ▁ for ▁ " << mk_pp ( x , m ) << " ▁ within ▁ " << mk_pp ( a , m ) << " \n " ; ) ; m_mark . mark ( a , true ) ; return true ; } else { TRACE ( " qe " , tout << " No ▁ bound ▁ for ▁ " << mk_pp ( x , m ) << " ▁ within ▁ " << mk_pp ( a , m ) << " \n " ; ) ; return false ; } } unsigned lt_size ( ) { return m_lt_terms . size ( ) ; } unsigned le_size ( ) { return m_le_terms . size ( ) ; } unsigned gt_size ( ) { return m_gt_terms . size ( ) ; } unsigned ge_size ( ) { return m_ge_terms . size ( ) ; } unsigned t_size ( bool is_l ) { return is_l ? lt_size ( ) : gt_size ( ) ; } unsigned e_size ( bool is_l ) { return is_l ? le_size ( ) : ge_size ( ) ; } unsigned size ( bool is_strict , bool is_l ) { return is_strict ? t_size ( is_l ) : e_size ( is_l ) ; } expr * const * lt ( ) { return m_lt_terms . c_ptr ( ) ; } expr * const * le ( ) { return m_le_terms . c_ptr ( ) ; } expr * const * gt ( ) { return m_gt_terms . c_ptr ( ) ; } expr * const * ge ( ) { return m_ge_terms . c_ptr ( ) ; } expr * const * t ( bool is_l ) { return is_l ? lt ( ) : gt ( ) ; } expr * const * e ( bool is_l ) { return is_l ? le ( ) : ge ( ) ; } expr * const * exprs ( bool is_strict , bool is_l ) { return is_strict ? t ( is_l ) : e ( is_l ) ; } rational const * lt_coeffs ( ) { return m_lt_coeffs . c_ptr ( ) ; } rational const * le_coeffs ( ) { return m_le_coeffs . c_ptr ( ) ; } rational const * gt_coeffs ( ) { return m_gt_coeffs . c_ptr ( ) ; } rational const * ge_coeffs ( ) { return m_ge_coeffs . c_ptr ( ) ; } rational const * t_coeffs ( bool is_l ) { return is_l ? lt_coeffs ( ) : gt_coeffs ( ) ; } rational const * e_coeffs ( bool is_l ) { return is_l ? le_coeffs ( ) : ge_coeffs ( ) ; } rational const * coeffs ( bool is_strict , bool is_l ) { return is_strict ? t_coeffs ( is_l ) : e_coeffs ( is_l ) ; } app * const * lt_atoms ( ) { return m_lt_atoms . c_ptr ( ) ; } app * const * le_atoms ( ) { return m_le_atoms . c_ptr ( ) ; } app * const * gt_atoms ( ) { return m_gt_atoms . c_ptr ( ) ; } app * const * ge_atoms ( ) { return m_ge_atoms . c_ptr ( ) ; } app * const * t_atoms ( bool is_l ) { return is_l ? lt_atoms ( ) : gt_atoms ( ) ; } app * const * e_atoms ( bool is_l ) { return is_l ? le_atoms ( ) : ge_atoms ( ) ; } app * const * atoms ( bool is_strict , bool is_l ) { return is_strict ? t_atoms ( is_l ) : e_atoms ( is_l ) ; } unsigned div_size ( ) const { return m_div_terms . size ( ) ; } app * const * div_atoms ( ) { return m_div_atoms . c_ptr ( ) ; } rational const * div_coeffs ( ) { return m_div_coeffs . c_ptr ( ) ; } expr * const * div_terms ( ) { return m_div_terms . c_ptr ( ) ; } rational const * divisors ( ) { return m_div_divisors . c_ptr ( ) ; } bool div_z ( rational & d , app_ref & z_bv , app_ref & z ) { if ( m_div_z . get ( ) ) { z = m_div_z ; z_bv = to_app ( z -> get_arg ( 0 ) ) ; d = m_d ; return true ; } if ( m_div_terms . empty ( ) && m_nested_div_terms . empty ( ) ) { return false ; } m_d = rational ( 1 ) ; for ( unsigned i = 0 ; i < m_div_divisors . size ( ) ; ++ i ) { m_d = lcm ( m_div_divisors [ i ] , m_d ) ; } for ( unsigned i = 0 ; i < m_nested_div_divisors . size ( ) ; ++ i ) { m_d = lcm ( m_nested_div_divisors [ i ] , m_d ) ; } if ( abs ( m_d ) . is_one ( ) ) { return false ; } m_util . mk_bounded_var ( m_d , z_bv , m_div_z ) ; z = m_div_z ; d = m_d ; return true ; } unsigned nested_div_size ( ) const { return m_nested_div_terms . size ( ) ; } app * nested_div_atom ( unsigned idx ) { return m_nested_div_atoms [ idx ] . get ( ) ; } rational const & nested_div_coeff ( unsigned idx ) { return m_nested_div_coeffs [ idx ] ; } expr * nested_div_term ( unsigned idx ) { return m_nested_div_terms [ idx ] . get ( ) ; } rational const & nested_divisor ( unsigned idx ) { return m_nested_div_divisors [ idx ] ; } app * nested_div_z ( unsigned idx ) { return m_nested_div_z [ idx ] . get ( ) ; } app * nested_div_z_bv ( unsigned idx ) { return to_app ( m_nested_div_z [ idx ] -> get_arg ( 0 ) ) ; } void reset ( ) { m_lt_terms . reset ( ) ; m_gt_terms . reset ( ) ; m_ge_terms . reset ( ) ; m_le_terms . reset ( ) ; m_gt_coeffs . reset ( ) ; m_lt_coeffs . reset ( ) ; m_ge_coeffs . reset ( ) ; m_le_coeffs . reset ( ) ; m_lt_atoms . reset ( ) ; m_gt_atoms . reset ( ) ; m_le_atoms . reset ( ) ; m_ge_atoms . reset ( ) ; m_div_terms . reset ( ) ; m_div_coeffs . reset ( ) ; m_div_divisors . reset ( ) ; m_div_atoms . reset ( ) ; m_div_z = 0 ; m_nested_div_terms . reset ( ) ; m_nested_div_coeffs . reset ( ) ; m_nested_div_divisors . reset ( ) ; m_nested_div_atoms . reset ( ) ; m_nested_div_z . reset ( ) ; } private : bool get_nested_divs ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; ptr_vector < expr > todo ; todo . push_back ( a ) ; rational k1 , k2 ; expr_ref rest ( m ) ; while ( ! todo . empty ( ) ) { expr * e = todo . back ( ) ; todo . pop_back ( ) ; if ( m_mark . is_marked ( e ) ) { continue ; } m_mark . mark ( e , true ) ; if ( ! contains_x ( e ) ) { continue ; } if ( contains_x . x ( ) == e ) { return false ; } if ( ! is_app ( e ) ) { return false ; } a = to_app ( e ) ; if ( m_util . m_arith . is_mod ( e ) && m_util . m_arith . is_numeral ( to_app ( e ) -> get_arg ( 1 ) , k1 ) && m_util . get_coeff ( contains_x , to_app ( e ) -> get_arg ( 0 ) , k2 , rest ) ) { app_ref z ( m ) , z_bv ( m ) ; m_util . mk_bounded_var ( k1 , z_bv , z ) ; m_nested_div_terms . push_back ( rest ) ; m_nested_div_divisors . push_back ( k1 ) ; m_nested_div_coeffs . push_back ( k2 ) ; m_nested_div_atoms . push_back ( a ) ; m_nested_div_z . push_back ( z ) ; continue ; } unsigned num_args = a -> get_num_args ( ) ; for ( unsigned i = 0 ; i < num_args ; ++ i ) { todo . push_back ( a -> get_arg ( i ) ) ; } } return true ; } bool get_le_bound ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; expr_ref p ( m ) , rest ( m ) ; rational k ; if ( m_util . is_le ( a , p ) && m_util . get_coeff ( contains_x , p , k , rest ) ) { if ( m_util . is_real ( contains_x . x ( ) ) ) { m_util . mk_div ( rest , abs ( k ) , rest ) ; k = k . is_pos ( ) ? rational :: one ( ) : rational :: minus_one ( ) ; } if ( k . is_neg ( ) ) { m_le_terms . push_back ( rest ) ; m_le_coeffs . push_back ( k ) ; m_le_atoms . push_back ( a ) ; } else { m_ge_terms . push_back ( rest ) ; m_ge_coeffs . push_back ( k ) ; m_ge_atoms . push_back ( a ) ; } return true ; } return false ; } bool get_lt_bound ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; expr_ref p ( m ) , rest ( m ) , na ( m ) ; rational k ; if ( m_util . is_lt ( a , p ) && m_util . get_coeff ( contains_x , p , k , rest ) ) { } else if ( m_util . is_neg ( a , na ) && is_app ( na ) && m_util . is_ge ( to_app ( na ) , p ) && m_util . get_coeff ( contains_x , p , k , rest ) ) { } else { return false ; } SASSERT ( m_util . is_real ( contains_x . x ( ) ) ) ; m_util . mk_div ( rest , abs ( k ) , rest ) ; if ( k . is_neg ( ) ) { m_lt_terms . push_back ( rest ) ; m_lt_coeffs . push_back ( rational :: minus_one ( ) ) ; m_lt_atoms . push_back ( a ) ; } else { m_gt_terms . push_back ( rest ) ; m_gt_coeffs . push_back ( rational :: one ( ) ) ; m_gt_atoms . push_back ( a ) ; } return true ; } bool get_divides ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; expr_ref p ( m ) , rest ( m ) ; app_ref a2 ( m ) ; numeral k , k2 ; if ( m_util . is_divides ( a , k , p ) && m_util . get_coeff ( contains_x , p , k2 , rest ) ) { m_div_terms . push_back ( rest ) ; m_div_divisors . push_back ( k ) ; m_div_coeffs . push_back ( k2 ) ; m_div_atoms . push_back ( a ) ; return true ; } if ( m_util . is_not_divides ( a , a2 , k , p ) && m_util . get_coeff ( contains_x , p , k2 , rest ) ) { m_div_terms . push_back ( rest ) ; m_div_divisors . push_back ( k ) ; m_div_coeffs . push_back ( k2 ) ; m_div_atoms . push_back ( a2 ) ; return true ; } return false ; } public : void display ( std :: ostream & out ) { ast_manager & m = m_util . get_manager ( ) ; for ( unsigned i = 0 ; i < lt_size ( ) ; ++ i ) { out << mk_pp ( lt ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } for ( unsigned i = 0 ; i < le_size ( ) ; ++ i ) { out << mk_pp ( le ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } for ( unsigned i = 0 ; i < gt_size ( ) ; ++ i ) { out << mk_pp ( gt ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } for ( unsigned i = 0 ; i < ge_size ( ) ; ++ i ) { out << mk_pp ( ge ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } } } ; class x_subst { arith_qe_util & m_super ; expr_ref m_t ; rational m_coeff ; public : x_subst ( arith_qe_util & s ) : m_super ( s ) , m_t ( s . get_manager ( ) ) , m_coeff ( rational :: one ( ) ) { } void set_term ( expr * t ) { m_t = t ; } void set_coeff ( rational const & k ) { m_coeff = k ; } expr * get_term ( ) const { return m_t ; } rational get_coeff ( ) const { return m_coeff ; } expr_ref mk_term ( rational const & c , expr * t ) { ast_manager & m = m_super . get_manager ( ) ; if ( m_t . get ( ) ) { return expr_ref ( m_super . mk_add ( m_super . mk_mul ( c , m_t ) , t ) , m ) ; } else { return expr_ref ( t , m ) ; } } rational mk_coeff ( rational const & k ) { return k * m_coeff ; } } ; struct branch_formula { expr * m_fml ; app * m_var ; unsigned m_branch ; expr * m_result ; rational m_coeff ; expr * m_term ; branch_formula ( ) : m_fml ( 0 ) , m_var ( 0 ) , m_branch ( 0 ) , m_result ( 0 ) , m_term ( 0 ) { } branch_formula ( expr * fml , app * var , unsigned b , expr * r , rational coeff , expr * term ) : m_fml ( fml ) , m_var ( var ) , m_branch ( b ) , m_result ( r ) , m_coeff ( coeff ) , m_term ( term ) { } unsigned mk_hash ( ) const { return mk_mix ( m_fml ? m_fml -> hash ( ) : 0 , m_var ? m_var -> hash ( ) : 0 , m_branch ) ; } bool mk_eq ( branch_formula const & other ) const { return m_fml == other . m_fml && m_var == other . m_var && m_branch == other . m_branch ; } struct hash { typedef branch_formula data ; unsigned operator ( ) ( data const & d ) const { return d . mk_hash ( ) ; } } ; struct eq { typedef branch_formula data ; bool operator ( ) ( data const & x , data const & y ) const { return x . mk_eq ( y ) ; } } ; } ; class arith_plugin : public qe_solver_plugin { typedef obj_pair_map < app , expr , bounds_proc * > bounds_cache ; typedef obj_pair_map < expr , expr , expr * > resolve_cache ; typedef hashtable < branch_formula , branch_formula :: hash , branch_formula :: eq > subst_cache ; arith_qe_util m_util ; expr_ref_vector m_trail ; bounds_cache m_bounds_cache ; subst_cache m_subst ; public : arith_plugin ( i_solver_context & ctx , ast_manager & m , smt_params & p ) : qe_solver_plugin ( m , m . mk_family_id ( " arith " ) , ctx ) , m_util ( m , p , ctx ) , m_trail ( m ) { } ~ arith_plugin ( ) { bounds_cache :: iterator it = m_bounds_cache . begin ( ) , end = m_bounds_cache . end ( ) ; for ( ; it != end ; ++ it ) { dealloc ( it -> get_value ( ) ) ; } } virtual void assign ( contains_app & contains_x , expr * fml , rational const & vl ) { SASSERT ( vl . is_unsigned ( ) ) ; app * x = contains_x . x ( ) ; unsigned v = vl . get_unsigned ( ) ; expr_ref result ( fml , m ) ; unsigned t_size , e_size ; x_subst x_t ( m_util ) ; if ( get_cache ( x , fml , v , result ) ) { return ; } bounds_proc & bounds = get_bounds ( x , fml ) ; bool is_lower = get_bound_sizes ( bounds , x , t_size , e_size ) ; assign_nested_divs ( contains_x , bounds , result ) ; assign_divs ( contains_x , bounds , x_t , result ) ; if ( v == 0 ) { mk_non_bounds ( bounds , true , is_lower , result ) ; mk_non_bounds ( bounds , false , is_lower , result ) ; mk_non_resolve ( bounds , true , is_lower , result ) ; mk_non_resolve ( bounds , false , is_lower , result ) ; m_util . simplify ( result ) ; add_cache ( x , fml , v , result , x_t . get_coeff ( ) , x_t . get_term ( ) ) ; TRACE ( " qe " , tout << vl << " ▁ " << mk_pp ( x , m ) << " ▁ infinite ▁ case \n " ; tout << mk_pp ( fml , m ) << " \n " ; tout << mk_pp ( result , m ) << " \n " ; ) ; return ; } unsigned index = v - 1 ; bool is_strict = e_size <= index ; bool is_eq = false ; SASSERT ( index < t_size + e_size ) ; if ( is_strict ) { index -= e_size ; TRACE ( " qe _ verbose " , bounds . display ( tout ) ; ) ; } else if ( m_util . is_real ( x ) ) { SASSERT ( 0 == ( e_size & 0x1 ) ) ; is_eq = ( 0 == ( index & 0x1 ) ) ; index /= 2 ; e_size /= 2 ; } SASSERT ( is_strict || index < e_size ) ; SASSERT ( ! is_strict || index < t_size ) ; SASSERT ( index < bounds . size ( is_strict , is_lower ) ) ; expr_ref t ( bounds . exprs ( is_strict , is_lower ) [ index ] , m ) ; rational a = bounds . coeffs ( is_strict , is_lower ) [ index ] ; mk_bounds ( bounds , x , true , is_eq , is_strict , is_lower , index , a , t , result ) ; mk_bounds ( bounds , x , false , is_eq , is_strict , is_lower , index , a , t , result ) ; t = x_t . mk_term ( a , t ) ; a = x_t . mk_coeff ( a ) ; mk_resolve ( bounds , x , x_t , true , is_eq , is_strict , is_lower , index , a , t , result ) ; mk_resolve ( bounds , x , x_t , false , is_eq , is_strict , is_lower , index , a , t , result ) ; m_util . simplify ( result ) ; add_cache ( x , fml , v , result , x_t . get_coeff ( ) , x_t . get_term ( ) ) ; TRACE ( " qe " , { tout << vl << " ▁ " << mk_pp ( bounds . atoms ( is_strict , is_lower ) [ index ] , m ) << " \n " ; tout << mk_pp ( fml , m ) << " \n " ; tout << mk_pp ( result , m ) << " \n " ; } ) ; } virtual bool get_num_branches ( contains_app & contains_x , expr * fml , rational & nb ) { app * x = contains_x . x ( ) ; if ( ! update_bounds ( contains_x , fml ) ) { return false ; } bounds_proc & bounds = get_bounds ( x , fml ) ; unsigned t_size , e_size ; get_bound_sizes ( bounds , x , t_size , e_size ) ; nb = rational ( t_size + e_size + 1 ) ; return true ; } virtual void subst ( contains_app & contains_x , rational const & vl , expr_ref & fml , expr_ref * def ) { SASSERT ( vl . is_unsigned ( ) ) ; if ( def ) { get_def ( contains_x , vl . get_unsigned ( ) , fml , * def ) ; } VERIFY ( get_cache ( contains_x . x ( ) , fml , vl . get_unsigned ( ) , fml ) ) ; TRACE ( " qe " , tout << mk_pp ( contains_x . x ( ) , m ) << " ▁ " << vl << " \n " << mk_pp ( fml , m ) << " \n " ; ) ; } virtual bool project ( contains_app & x , model_ref & model , expr_ref & fml ) { if ( ! update_bounds ( x , fml ) ) { TRACE ( " qe " , tout << mk_pp ( x . x ( ) , m ) << " ▁ failed ▁ to ▁ update ▁ bounds \n " ; ) ; return false ; } if ( m_util . m_arith . is_real ( x . x ( ) ) ) { return project_real ( x , model , fml ) ; } else { return project_int ( x , model , fml ) ; } } virtual unsigned get_weight ( contains_app & contains_x , expr * fml ) { return 2 ; } virtual bool solve ( conj_enum & conjs , expr * fml ) { return m_util . solve ( conjs , fml ) ; } virtual bool mk_atom ( expr * e , bool p , expr_ref & result ) { return m_util . mk_atom ( e , p , result ) ; } virtual bool is_uninterpreted ( app * f ) { switch ( f -> get_decl_kind ( ) ) { case OP_NUM : case OP_LE : case OP_LT : case OP_GE : case OP_GT : case OP_ADD : case OP_SUB : case OP_UMINUS : return false ; case OP_MOD : if ( m_util . m_arith . is_numeral ( f -> get_arg ( 1 ) ) ) { return false ; } return true ; case OP_MUL : { arith_util & a = m_util . m_arith ; expr * m , * n ; if ( a . is_mul ( f , m , n ) && ( a . is_numeral ( m ) || a . is_numeral ( n ) ) ) { return false ; } return true ; } default : return true ; } } private : expr_ref mk_idiv ( expr * e , numeral k ) { SASSERT ( ! k . is_zero ( ) ) ; arith_util & a = m_util . m_arith ; if ( k . is_one ( ) ) { return expr_ref ( e , m ) ; } if ( k . is_minus_one ( ) ) { return expr_ref ( a . mk_uminus ( e ) , m ) ; } SASSERT ( a . is_int ( e ) ) ; return expr_ref ( a . mk_idiv ( e , a . mk_numeral ( k , true ) ) , m ) ; } void get_def ( contains_app & contains_x , unsigned v , expr * fml , expr_ref & def ) { app * x = contains_x . x ( ) ; x_subst x_t ( m_util ) ; bounds_proc & bounds = get_bounds ( x , fml ) ; branch_formula bf ; VERIFY ( m_subst . find ( branch_formula ( fml , x , v , 0 , rational :: zero ( ) , 0 ) , bf ) ) ; x_t . set_term ( bf . m_term ) ; x_t . set_coeff ( bf . m_coeff ) ; CTRACE ( " qe " , x_t . get_term ( ) , tout << x_t . get_coeff ( ) << " ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; unsigned t_size , e_size , sz ; bool is_lower = get_bound_sizes ( bounds , x , t_size , e_size ) ; bool is_strict ; if ( v == 0 ) { is_strict = false ; sz = bounds . size ( is_strict , ! is_lower ) ; expr_ref_vector terms ( m ) ; if ( sz == 0 ) { terms . push_back ( m_util . mk_zero ( x ) ) ; } for ( unsigned i = 0 ; i < sz ; ++ i ) { expr_ref term ( bounds . exprs ( is_strict , ! is_lower ) [ i ] , m ) ; rational a = bounds . coeffs ( is_strict , ! is_lower ) [ i ] ; if ( x_t . get_term ( ) ) { TRACE ( " qe " , tout << x_t . get_coeff ( ) << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; SASSERT ( x_t . get_coeff ( ) . is_pos ( ) ) ; term = m_util . mk_add ( term , m_util . mk_mul ( a , x_t . get_term ( ) ) ) ; a = a * x_t . get_coeff ( ) ; } TRACE ( " qe " , tout << a << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( term , m ) << " ▁ < = ▁ 0 \n " ; ) ; SASSERT ( a . is_int ( ) ) ; SASSERT ( is_lower == a . is_pos ( ) ) ; term = m_util . mk_uminus ( term ) ; term = mk_idiv ( term , a ) ; terms . push_back ( term ) ; TRACE ( " qe " , tout << " a : ▁ " << a << " ▁ term : ▁ " << mk_pp ( term , m ) << " \n " ; ) ; } is_strict = true ; sz = bounds . size ( is_strict , ! is_lower ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { expr_ref term ( bounds . exprs ( is_strict , ! is_lower ) [ i ] , m ) ; SASSERT ( abs ( bounds . coeffs ( is_strict , ! is_lower ) [ i ] ) . is_one ( ) ) ; if ( is_lower ) { term = m_util . mk_uminus ( m_util . mk_add ( term , m_util . mk_one ( x ) ) ) ; } else { term = m_util . mk_add ( term , m_util . mk_one ( x ) ) ; } terms . push_back ( term ) ; } if ( is_lower ) { def = m_util . mk_min ( terms . size ( ) , terms . c_ptr ( ) ) ; } else { def = m_util . mk_max ( terms . size ( ) , terms . c_ptr ( ) ) ; } if ( x_t . get_term ( ) ) { TRACE ( " qe " , tout << x_t . get_coeff ( ) << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; def = m_util . mk_add ( m_util . mk_mul ( x_t . get_coeff ( ) , def ) , x_t . get_term ( ) ) ; } m_util . simplify ( def ) ; return ; } -- v ; is_strict = e_size <= v ; SASSERT ( v < t_size + e_size ) ; if ( is_strict ) { v -= e_size ; TRACE ( " qe _ verbose " , bounds . display ( tout ) ; ) ; } else if ( m_util . is_real ( x ) ) { SASSERT ( 0 == ( e_size & 0x1 ) ) ; v /= 2 ; e_size /= 2 ; } SASSERT ( is_strict || v < e_size ) ; SASSERT ( ! is_strict || v < t_size ) ; SASSERT ( v < bounds . size ( is_strict , is_lower ) ) ; def = bounds . exprs ( is_strict , is_lower ) [ v ] ; rational a = bounds . coeffs ( is_strict , is_lower ) [ v ] ; if ( x_t . get_term ( ) ) { TRACE ( " qe " , tout << x_t . get_coeff ( ) << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; SASSERT ( x_t . get_coeff ( ) . is_pos ( ) ) ; def = m_util . mk_add ( def , m_util . mk_mul ( a , x_t . get_term ( ) ) ) ; a = a * x_t . get_coeff ( ) ; } SASSERT ( a . is_int ( ) ) ; SASSERT ( is_lower != a . is_pos ( ) ) ; def = m_util . mk_uminus ( def ) ; def = mk_idiv ( def , a ) ; if ( x_t . get_term ( ) ) { def = m_util . mk_add ( m_util . mk_mul ( x_t . get_coeff ( ) , def ) , x_t . get_term ( ) ) ; } if ( is_strict ) { SASSERT ( m_util . m_arith . is_real ( x ) ) ; def = m_util . mk_sub ( def , m_util . mk_one ( x ) ) ; } m_util . simplify ( def ) ; TRACE ( " qe " , tout << " TBD ▁ ( for ▁ Real ) : ▁ " << a << " ▁ " << mk_pp ( def , m ) << " \n " ; ) ; } expr_ref mk_not ( expr * e ) { expr * r ; if ( m . is_not ( e , r ) ) { return expr_ref ( r , m ) ; } return expr_ref ( m . mk_not ( e ) , m ) ; } bool project_real ( contains_app & x , model_ref & model , expr_ref & fml ) { SASSERT ( m_util . m_arith . is_real ( x . x ( ) ) ) ; model_evaluator model_eval ( * model ) ; bounds_proc & bounds = get_bounds ( x . x ( ) , fml ) ; bool is_lower = bounds . le_size ( ) + bounds . lt_size ( ) < bounds . ge_size ( ) + bounds . gt_size ( ) ; unsigned e_size = bounds . e_size ( is_lower ) ; numeral bound1 , bound2 , vl , x_val ; unsigned idx1 , idx2 ; bool found1 = find_min_max ( is_lower , false , bounds , model_eval , bound1 , idx1 ) ; bool found2 = find_min_max ( is_lower , true , bounds , model_eval , bound2 , idx2 ) ; if ( ! found1 && ! found2 ) { vl = numeral ( 0 ) ; } else if ( found2 && ( ! found1 || bound2 <= bound1 ) ) { vl = numeral ( 1 + 2 * e_size + idx2 ) ; } else if ( found1 && ( ! found2 || bound1 < bound2 ) ) { expr_ref val_x ( m ) ; model_eval ( x . x ( ) , val_x ) ; VERIFY ( m_util . m_arith . is_numeral ( val_x , x_val ) ) ; if ( x_val == bound1 ) { vl = numeral ( 1 + 2 * idx1 ) ; } else { vl = numeral ( 1 + 2 * idx1 + 1 ) ; } } assign ( x , fml , vl ) ; subst ( x , vl , fml , 0 ) ; TRACE ( " qe " , tout << mk_pp ( fml , m ) << " \n " ; ) ; return true ; } bool project_int ( contains_app & x , model_ref & model , expr_ref & fml ) { model_evaluator model_eval ( * model ) ; bounds_proc & bounds = get_bounds ( x . x ( ) , fml ) ; SASSERT ( m_util . m_arith . is_int ( x . x ( ) ) ) ; SASSERT ( bounds . lt_size ( ) == 0 && bounds . gt_size ( ) == 0 ) ; bool is_lower = bounds . le_size ( ) < bounds . ge_size ( ) ; numeral bound , vl , x_val ; unsigned idx = bounds . le_size ( ) + bounds . ge_size ( ) ; bool found = find_min_max ( is_lower , false , bounds , model_eval , bound , idx ) ; if ( found ) { SASSERT ( idx < bounds . size ( false , is_lower ) ) ; vl = numeral ( 1 + idx ) ; } else { vl = numeral ( 0 ) ; } assign ( x , fml , vl ) ; subst ( x , vl , fml , 0 ) ; TRACE ( " qe " , tout << mk_pp ( fml , m ) << " \n " ; ) ; return true ; } bool find_min_max ( bool is_lower , bool is_strict , bounds_proc & bounds , model_evaluator & eval , rational & bound , unsigned & idx ) { bool found = false ; unsigned num_bounds = bounds . size ( is_strict , is_lower ) ; rational num ; for ( unsigned i = 0 ; i < num_bounds ; ++ i ) { expr_ref vl ( m ) ; eval ( bounds . atoms ( is_strict , is_lower ) [ i ] , vl ) ; if ( ! m . is_true ( vl ) ) { continue ; } eval ( bounds . exprs ( is_strict , is_lower ) [ i ] , vl ) ; VERIFY ( m_util . m_arith . is_numeral ( vl , num ) ) ; num /= abs ( bounds . coeffs ( is_strict , is_lower ) [ i ] ) ; if ( found ) { if ( is_lower ? ( num < bound ) : ( num > bound ) ) { bound = num ; idx = i ; } } else { found = true ; idx = i ; bound = num ; } } return found ; } bool get_bound_sizes ( bounds_proc & bounds , app * x , unsigned & t_size , unsigned & e_size ) { unsigned le_size = bounds . le_size ( ) ; unsigned ge_size = bounds . ge_size ( ) ; if ( m_util . is_real ( x ) ) { le_size *= 2 ; ge_size *= 2 ; } if ( le_size + bounds . lt_size ( ) < ge_size + bounds . gt_size ( ) ) { e_size = le_size ; t_size = bounds . lt_size ( ) ; return true ; } else { e_size = ge_size ; t_size = bounds . gt_size ( ) ; return false ; } } void add_cache ( app * x , expr * fml , unsigned v , expr * result , rational coeff , expr * term ) { m_trail . push_back ( x ) ; m_trail . push_back ( fml ) ; m_trail . push_back ( result ) ; if ( term ) m_trail . push_back ( term ) ; m_subst . insert ( branch_formula ( fml , x , v , result , coeff , term ) ) ; } bool get_cache ( app * x , expr * fml , unsigned v , expr_ref & result ) { branch_formula bf ; if ( ! m_subst . find ( branch_formula ( fml , x , v , 0 , rational :: zero ( ) , 0 ) , bf ) ) { return false ; } SASSERT ( bf . m_result ) ; result = bf . m_result ; return true ; } void assign_divs ( contains_app & contains_x , bounds_proc & bounds , x_subst & x_t , expr_ref & result ) { app * x = contains_x . x ( ) ; app_ref z ( m ) , z_bv ( m ) ; rational d ; if ( ! bounds . div_z ( d , z_bv , z ) ) { return ; } m_ctx . add_var ( z_bv ) ; expr * z_lt_d = m_util . m_arith . mk_le ( z , m_util . m_arith . mk_numeral ( d - rational ( 1 ) , true ) ) ; m_ctx . add_constraint ( false , z_lt_d ) ; SASSERT ( ! abs ( d ) . is_one ( ) ) ; rational d1 = d - rational ( 1 ) ; expr_ref tmp ( m ) ; m_util . m_arith_rewriter . mk_le ( z , m_util . m_arith . mk_numeral ( d1 , true ) , tmp ) ; m_util . m_bool_rewriter . mk_and ( result , tmp , result ) ; expr_ref t1 ( m ) , new_atom ( m ) ; t1 = m_util . mk_sub ( x , z ) ; m_util . mk_divides ( d , t1 , new_atom ) ; m_ctx . add_constraint ( false , new_atom ) ; mk_div_equivs ( bounds , z , result ) ; x_t . set_term ( z ) ; x_t . set_coeff ( d ) ; } void mk_div_equivs ( bounds_proc & bounds , expr * z , expr_ref & result ) { unsigned sz = bounds . div_size ( ) ; app * const * atoms = bounds . div_atoms ( ) ; rational const * coeffs = bounds . div_coeffs ( ) ; expr * const * terms = bounds . div_terms ( ) ; rational const * divisors = bounds . divisors ( ) ; expr_ref new_atom ( m ) , t1 ( m ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * atm = atoms [ i ] ; t1 = m_util . mk_add ( m_util . mk_mul ( coeffs [ i ] , z ) , terms [ i ] ) ; m_util . mk_divides ( divisors [ i ] , t1 , new_atom ) ; m_util . m_replace . apply_substitution ( atm , new_atom . get ( ) , result ) ; m_ctx . add_constraint ( false , mk_not ( atm ) , new_atom ) ; m_ctx . add_constraint ( false , mk_not ( new_atom ) , atm ) ; } } void assign_nested_divs ( contains_app & contains_x , bounds_proc & bounds , expr_ref & result ) { unsigned num_nested_divs = bounds . nested_div_size ( ) ; if ( num_nested_divs == 0 ) { return ; } app_ref z ( m ) , z_bv ( m ) ; rational d ; VERIFY ( bounds . div_z ( d , z_bv , z ) ) ; for ( unsigned i = 0 ; i < num_nested_divs ; ++ i ) { app * atm = bounds . nested_div_atom ( i ) ; rational const & k = bounds . nested_divisor ( i ) ; app * z1_bv = bounds . nested_div_z_bv ( i ) ; app * z1 = bounds . nested_div_z ( i ) ; m_ctx . add_var ( z1_bv ) ; expr * z_lt_k = m_util . m_arith . mk_le ( z1 , m_util . m_arith . mk_numeral ( k - rational ( 1 ) , true ) ) ; m_ctx . add_constraint ( false , z_lt_k ) ; expr * e1 = m_util . m_arith . mk_sub ( atm -> get_arg ( 0 ) , z1 ) ; expr * e2 = atm -> get_arg ( 1 ) ; expr_ref mod_term2 ( m_util . m_arith . mk_mod ( e1 , e2 ) , m ) ; m_util . simplify ( mod_term2 ) ; m_ctx . add_constraint ( false , m . mk_eq ( mod_term2 , m_util . mk_zero ( mod_term2 ) ) ) ; m_util . m_replace . apply_substitution ( atm , z1 , result ) ; expr_ref mod_eq ( m ) , tmp1 ( m ) , tmp2 ( m ) ; tmp2 = m_util . mk_numeral ( bounds . nested_div_coeff ( i ) , true ) ; tmp1 = m_util . m_arith . mk_mul ( tmp2 , z1 ) ; tmp2 = m_util . m_arith . mk_sub ( bounds . nested_div_term ( i ) , z ) ; tmp2 = m_util . m_arith . mk_add ( tmp1 , tmp2 ) ; tmp1 = m_util . m_arith . mk_mod ( tmp2 , bounds . nested_div_atom ( i ) -> get_arg ( 1 ) ) ; mod_eq = m . mk_eq ( tmp1 , m_util . mk_zero ( z ) ) ; m_util . simplify ( mod_eq ) ; result = m . mk_and ( result , mod_eq ) ; TRACE ( " qe " , tout << mk_pp ( mod_eq , m ) << " \n " ; ) ; } } bounds_proc & get_bounds ( app * x , expr * fml ) { bounds_proc * result = 0 ; VERIFY ( m_bounds_cache . find ( x , fml , result ) ) ; return * result ; } void mk_non_bounds ( bounds_proc & bounds , bool is_strict , bool is_lower , expr_ref & result ) { unsigned sz = bounds . size ( is_strict , is_lower ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , is_lower ) [ i ] ; m_ctx . add_constraint ( true , mk_not ( e ) ) ; m_util . m_replace . apply_substitution ( e , m . mk_false ( ) , result ) ; } } void mk_non_resolve ( bounds_proc & bounds , bool is_strict , bool is_lower , expr_ref & result ) { unsigned sz = bounds . size ( is_strict , ! is_lower ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , ! is_lower ) [ i ] ; m_ctx . add_constraint ( true , e ) ; m_util . m_replace . apply_substitution ( e , m . mk_true ( ) , result ) ; } } void mk_bound ( bool is_strict , bool is_lower , rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { if ( is_strict ) { if ( is_lower ) { m_util . mk_strict_bound ( b , s , a , t , result ) ; } else { m_util . mk_strict_bound ( a , t , b , s , result ) ; } } else { if ( is_lower ) { m_util . mk_bound ( b , s , a , t , result ) ; } else { m_util . mk_bound ( a , t , b , s , result ) ; } } m_util . simplify ( result ) ; TRACE ( " qe " , tout << ( is_strict ? " strict " : " non - strict " ) << " \n " ; tout << ( is_lower ? " is - lower " : " is - upper " ) << " \n " ; tout << " a : ▁ " << a << " ▁ " << mk_pp ( t , m ) << " \n " ; tout << " b : ▁ " << b << " ▁ " << mk_pp ( s , m ) << " \n " ; tout << mk_pp ( result , m ) << " \n " ; ) ; } void mk_bounds ( bounds_proc & bounds , app * x , bool is_strict , bool is_eq_ctx , bool is_strict_ctx , bool is_lower , unsigned index , rational const & a , expr * t , expr_ref & result ) { TRACE ( " qe " , tout << mk_pp ( t , m ) << " \n " ; ) ; SASSERT ( ! is_eq_ctx || ! is_strict_ctx ) ; unsigned sz = bounds . size ( is_strict , is_lower ) ; expr_ref tmp ( m ) , eq ( m ) ; bool same_strict = ( is_strict == is_strict_ctx ) ; bool non_strict_real = m_util . is_real ( x ) && ! is_strict_ctx ; app * atm = bounds . atoms ( is_strict_ctx , is_lower ) [ index ] ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , is_lower ) [ i ] ; expr_ref s ( bounds . exprs ( is_strict , is_lower ) [ i ] , m ) ; rational b = bounds . coeffs ( is_strict , is_lower ) [ i ] ; if ( same_strict && i == index ) { if ( non_strict_real ) { m_util . mk_eq ( a , x , t , eq ) ; TRACE ( " qe " , tout << " a : " << a << " ▁ x : ▁ " << mk_pp ( x , m ) << " t : ▁ " << mk_pp ( t , m ) << " ▁ eq : ▁ " << mk_pp ( eq , m ) << " \n " ; ) ; if ( is_eq_ctx ) { m_ctx . add_constraint ( true , eq ) ; } else { m_ctx . add_constraint ( true , mk_not ( eq ) ) ; m_ctx . add_constraint ( true , e ) ; } } else { m_ctx . add_constraint ( true , e ) ; } m_util . m_replace . apply_substitution ( atm , m . mk_true ( ) , result ) ; continue ; } bool result_is_strict = ( non_strict_real && is_eq_ctx && is_strict ) || ( same_strict && i < index ) ; mk_bound ( result_is_strict , is_lower , a , t , b , s , tmp ) ; m_util . m_replace . apply_substitution ( e , tmp . get ( ) , result ) ; TRACE ( " qe " , tout << ( result_is_strict ? " strict ▁ result " : " non - strict ▁ result " ) << " \n " ; tout << ( is_strict ? " strict " : " non - strict " ) << " \n " ; tout << mk_pp ( atm , m ) << " ▁ & ▁ " ; tout << mk_pp ( e , m ) << " ▁ - - > ▁ " ; tout << mk_pp ( tmp . get ( ) , m ) << " \n " ; ) ; m_ctx . add_constraint ( true , mk_not ( e ) , tmp ) ; } } void mk_resolve ( bounds_proc & bounds , app * x , x_subst & x_t , bool is_strict , bool is_eq_ctx , bool is_strict_ctx , bool is_lower , unsigned index , rational const & a , expr * t , expr_ref & result ) { expr_ref tmp ( m ) ; unsigned sz = bounds . size ( is_strict , ! is_lower ) ; bool is_strict_real = ! is_eq_ctx && m_util . is_real ( x ) && ! is_strict_ctx ; bool strict_resolve = is_strict || is_strict_ctx || is_strict_real ; app * atm = bounds . atoms ( is_strict_ctx , is_lower ) [ index ] ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , ! is_lower ) [ i ] ; expr_ref s ( bounds . exprs ( is_strict , ! is_lower ) [ i ] , m ) ; rational b = bounds . coeffs ( is_strict , ! is_lower ) [ i ] ; SASSERT ( ! b . is_zero ( ) ) ; SASSERT ( b . is_pos ( ) != a . is_pos ( ) ) ; s = x_t . mk_term ( b , s ) ; b = x_t . mk_coeff ( b ) ; m_util . mk_resolve ( x , strict_resolve , a , t , b , s , tmp ) ; expr_ref save_result ( result ) ; m_util . m_replace . apply_substitution ( e , tmp . get ( ) , result ) ; m_ctx . add_constraint ( true , mk_not ( e ) , tmp ) ; TRACE ( " qe _ verbose " , tout << mk_pp ( atm , m ) << " ▁ " ; tout << mk_pp ( e , m ) << " ▁ = = > \n " ; tout << mk_pp ( tmp , m ) << " \n " ; tout << " old ▁ fml : ▁ " << mk_pp ( save_result , m ) << " \n " ; tout << " new ▁ fml : ▁ " << mk_pp ( result , m ) << " \n " ; ) ; } } bool update_bounds ( bounds_proc & bounds , contains_app & contains_x , expr * fml , atom_set const & tbl , bool is_pos ) { app_ref tmp ( m ) ; atom_set :: iterator it = tbl . begin ( ) , end = tbl . end ( ) ; for ( ; it != end ; ++ it ) { app * e = * it ; if ( ! contains_x ( e ) ) { continue ; } if ( ! is_pos ) { SASSERT ( ! m . is_not ( e ) ) ; tmp = m . mk_not ( e ) ; e = tmp ; } if ( ! bounds . get_bound ( contains_x , e ) ) { return false ; } } return true ; } bool update_bounds ( contains_app & contains_x , expr * fml ) { bounds_proc * bounds = 0 ; if ( m_bounds_cache . find ( contains_x . x ( ) , fml , bounds ) ) { return true ; } bounds = alloc ( bounds_proc , m_util ) ; if ( ! update_bounds ( * bounds , contains_x , fml , m_ctx . pos_atoms ( ) , true ) ) { dealloc ( bounds ) ; return false ; } if ( ! update_bounds ( * bounds , contains_x , fml , m_ctx . neg_atoms ( ) , false ) ) { dealloc ( bounds ) ; return false ; } m_trail . push_back ( contains_x . x ( ) ) ; m_trail . push_back ( fml ) ; m_bounds_cache . insert ( contains_x . x ( ) , fml , bounds ) ; return true ; } } ; class nlarith_plugin : public qe_solver_plugin { typedef obj_map < app , unsigned > weight_m ; typedef obj_pair_map < expr , expr , nlarith :: branch_conditions * > bcs_t ; typedef obj_map < expr , weight_m * > weights_t ; bcs_t m_cache ; weights_t m_weights ; th_rewriter m_rewriter ; nlarith :: util m_util ; expr_safe_replace m_replace ; expr_ref_vector m_trail ; factor_rewriter_star m_factor_rw ; bool m_produce_models ; public : nlarith_plugin ( i_solver_context & ctx , ast_manager & m , bool produce_models ) : qe_solver_plugin ( m , m . mk_family_id ( " arith " ) , ctx ) , m_rewriter ( m ) , m_util ( m ) , m_replace ( m ) , m_trail ( m ) , m_factor_rw ( m ) , m_produce_models ( produce_models ) { TRACE ( " qe " , tout << " produce ▁ models : ▁ " << produce_models << " \n " ; ) ; m_util . set_enable_linear ( true ) ; } virtual ~ nlarith_plugin ( ) { bcs_t :: iterator it = m_cache . begin ( ) , end = m_cache . end ( ) ; for ( ; it != end ; ++ it ) { dealloc ( it -> get_value ( ) ) ; } weights_t :: iterator it2 = m_weights . begin ( ) , e2 = m_weights . end ( ) ; for ( ; it2 != e2 ; ++ it2 ) { dealloc ( it2 -> get_value ( ) ) ; } } virtual bool simplify ( expr_ref & fml ) { expr_ref tmp ( m ) , tmp2 ( m ) ; m_factor_rw ( fml , tmp ) ; m_rewriter ( tmp , tmp2 ) ; if ( fml . get ( ) != tmp2 . get ( ) ) { fml = tmp2 ; return true ; } return false ; } virtual void assign ( contains_app & x , expr * fml , rational const & vl ) { nlarith :: branch_conditions * brs ; VERIFY ( m_cache . find ( x . x ( ) , fml , brs ) ) ; SASSERT ( vl . is_unsigned ( ) ) ; SASSERT ( vl . get_unsigned ( ) < brs -> size ( ) ) ; expr * branch_fml = brs -> branches ( vl . get_unsigned ( ) ) ; expr_ref result ( m ) , tmp ( m ) ; m_factor_rw ( branch_fml , tmp ) ; m_rewriter ( tmp , result ) ; TRACE ( " qe " , tout << vl << " ▁ " << mk_pp ( result . get ( ) , m ) << " \n " ; ) ; m_ctx . add_constraint ( true , result ) ; } virtual bool get_num_branches ( contains_app & x , expr * fml , rational & num_branches ) { nlarith :: branch_conditions * brs ; if ( m_cache . find ( x . x ( ) , fml , brs ) ) { num_branches = rational ( brs -> size ( ) ) ; return true ; } expr_ref_vector lits ( m ) ; update_bounds ( lits , m_ctx . pos_atoms ( ) , true ) ; update_bounds ( lits , m_ctx . neg_atoms ( ) , false ) ; brs = alloc ( nlarith :: branch_conditions , m ) ; TRACE ( " nlarith " , tout << mk_pp ( fml , m ) << " \n " ; ) ; if ( ! m_util . create_branches ( x . x ( ) , lits . size ( ) , lits . c_ptr ( ) , * brs ) ) { TRACE ( " nlarith " , tout << " no ▁ branches ▁ for ▁ " << mk_pp ( x . x ( ) , m ) << " \n " ; ) ; dealloc ( brs ) ; return false ; } num_branches = rational ( brs -> size ( ) ) ; insert_cache ( x . x ( ) , fml , brs ) ; return true ; } virtual void subst ( contains_app & x , rational const & vl , expr_ref & fml , expr_ref * def ) { nlarith :: branch_conditions * brs ; VERIFY ( m_cache . find ( x . x ( ) , fml , brs ) ) ; SASSERT ( vl . is_unsigned ( ) ) ; SASSERT ( vl . get_unsigned ( ) < brs -> size ( ) ) ; unsigned j = vl . get_unsigned ( ) ; m_replace . reset ( ) ; for ( unsigned i = 0 ; i < brs -> preds ( ) . size ( ) ; ++ i ) { m_replace . insert ( brs -> preds ( i ) , brs -> subst ( j ) [ i ] ) ; } m_replace ( fml ) ; expr_ref tmp ( m . mk_and ( brs -> constraints ( j ) , fml ) , m ) ; m_factor_rw ( tmp , fml ) ; if ( def ) { m_factor_rw ( brs -> def ( j ) , * def ) ; } } virtual unsigned get_weight ( contains_app & x , expr * fml ) { obj_map < app , unsigned > * weights = 0 ; unsigned weight = 0 ; if ( ! m_weights . find ( fml , weights ) ) { weights = alloc ( weight_m ) ; m_weights . insert ( fml , weights ) ; m_trail . push_back ( fml ) ; ptr_vector < app > nl_vars ; m_util . extract_non_linear ( to_app ( fml ) , nl_vars ) ; for ( unsigned i = 0 ; i < nl_vars . size ( ) ; ++ i ) { weights -> insert ( nl_vars [ i ] , 100 ) ; } } if ( weights -> find ( x . x ( ) , weight ) ) { return weight ; } return UINT_MAX ; } virtual bool solve ( conj_enum & conjs , expr * fml ) { return false ; } virtual bool mk_atom ( expr * e , bool p , expr_ref & result ) { return false ; } virtual bool is_uninterpreted ( app * f ) { if ( m_produce_models ) { return true ; } switch ( f -> get_decl_kind ( ) ) { case OP_NUM : case OP_LE : case OP_LT : case OP_GE : case OP_GT : case OP_ADD : case OP_SUB : case OP_UMINUS : return false ; case OP_MUL : { arith_util a ( m ) ; expr * m , * n ; if ( a . is_mul ( f , m , n ) && ( a . is_numeral ( m ) || a . is_numeral ( n ) ) ) { return false ; } return true ; } default : return true ; } return true ; } private : void insert_cache ( app * x , expr * e , nlarith :: branch_conditions * brs ) { m_trail . push_back ( x ) ; m_trail . push_back ( e ) ; m_cache . insert ( x , e , brs ) ; } void update_bounds ( expr_ref_vector & lits , atom_set const & tbl , bool is_pos ) { atom_set :: iterator it = tbl . begin ( ) , end = tbl . end ( ) ; for ( ; it != end ; ++ it ) { app * e = * it ; lits . push_back ( is_pos ? e : m . mk_not ( e ) ) ; } } } ; qe_solver_plugin * mk_arith_plugin ( i_solver_context & ctx , bool produce_models , smt_params & p ) { if ( p . m_nlquant_elim ) { return alloc ( nlarith_plugin , ctx , ctx . get_manager ( ) , produce_models ) ; } else { return alloc ( arith_plugin , ctx , ctx . get_manager ( ) , p ) ; } } } </DOCUMENT>
<DOCUMENT_ID="JoseBarrales/mlnc/tree/master/src/test/rpc_tests.cpp"> # include < boost / test / unit_test . hpp > # include < boost / foreach . hpp > # include " base58 . h " # include " util . h " # include " bitcoinrpc . h " using namespace std ; using namespace json_spirit ; BOOST_AUTO_TEST_SUITE ( rpc_tests ) static Array createArgs ( int nRequired , const char * address1 = NULL , const char * address2 = NULL ) { Array result ; result . push_back ( nRequired ) ; Array addresses ; if ( address1 ) addresses . push_back ( address1 ) ; if ( address2 ) addresses . push_back ( address1 ) ; result . push_back ( addresses ) ; return result ; } struct TestNetFixture { TestNetFixture ( ) { fTestNet = true ; } ~ TestNetFixture ( ) { fTestNet = false ; } } ; BOOST_FIXTURE_TEST_CASE ( rpc_addmultisig , TestNetFixture ) { rpcfn_type addmultisig = tableRPC [ " addmultisigaddress " ] -> actor ; const char * address1Hex = "0434e3e09f49ea168c5bbf53f877ff4206923858aab7c7e1df25bc263978107c95e35065a27ef6f1b27222db0ec97e0e895eaca603d3ee0d4c060ce3d8a00286c8" ; const char * address2Hex = "0388c2037017c62240b6b72ac1a2a5f94da790596ebd06177c8572752922165cb4" ; Value v ; CBitcoinAddress address ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 1 , address1Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 1 , address1Hex , address2Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 2 , address1Hex , address2Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 0 ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , address1Hex ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 , " " ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 , " NotAValidPubkey " ) , false ) , runtime_error ) ; string short1 ( address1Hex , address1Hex + sizeof ( address1Hex ) - 2 ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , short1 . c_str ( ) ) , false ) , runtime_error ) ; string short2 ( address1Hex + 2 , address1Hex + sizeof ( address1Hex ) ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , short2 . c_str ( ) ) , false ) , runtime_error ) ; } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
<DOCUMENT_ID="Poxleit/s-core/tree/master/src/scriptdev2/scripts/eastern_kingdoms/shadowfang_keep/instance_shadowfang_keep.cpp"> # include " precompiled . h " # include " shadowfang _ keep . h " instance_shadowfang_keep :: instance_shadowfang_keep ( Map * pMap ) : ScriptedInstance ( pMap ) { Initialize ( ) ; } void instance_shadowfang_keep :: Initialize ( ) { memset ( & m_auiEncounter , 0 , sizeof ( m_auiEncounter ) ) ; } void instance_shadowfang_keep :: OnCreatureCreate ( Creature * pCreature ) { switch ( pCreature -> GetEntry ( ) ) { case NPC_ASH : case NPC_ADA : case NPC_FENRUS : break ; case NPC_VINCENT : if ( m_auiEncounter [ 4 ] == DONE ) pCreature -> SetStandState ( UNIT_STAND_STATE_DEAD ) ; break ; default : return ; } m_mNpcEntryGuidStore [ pCreature -> GetEntry ( ) ] = pCreature -> GetObjectGuid ( ) ; } void instance_shadowfang_keep :: OnObjectCreate ( GameObject * pGo ) { switch ( pGo -> GetEntry ( ) ) { case GO_COURTYARD_DOOR : if ( m_auiEncounter [ 0 ] == DONE ) pGo -> SetGoState ( GO_STATE_ACTIVE ) ; break ; case GO_SORCERER_DOOR : if ( m_auiEncounter [ 2 ] == DONE ) pGo -> SetGoState ( GO_STATE_ACTIVE ) ; break ; case GO_ARUGAL_DOOR : if ( m_auiEncounter [ 3 ] == DONE ) pGo -> SetGoState ( GO_STATE_ACTIVE ) ; break ; case GO_ARUGAL_FOCUS : break ; default : return ; } m_mGoEntryGuidStore [ pGo -> GetEntry ( ) ] = pGo -> GetObjectGuid ( ) ; } void instance_shadowfang_keep :: DoSpeech ( ) { Creature * pAda = GetSingleCreatureFromStorage ( NPC_ADA ) ; Creature * pAsh = GetSingleCreatureFromStorage ( NPC_ASH ) ; if ( pAda && pAda -> isAlive ( ) && pAsh && pAsh -> isAlive ( ) ) { DoScriptText ( SAY_BOSS_DIE_AD , pAda ) ; DoScriptText ( SAY_BOSS_DIE_AS , pAsh ) ; } } void instance_shadowfang_keep :: SetData ( uint32 uiType , uint32 uiData ) { switch ( uiType ) { case TYPE_FREE_NPC : if ( uiData == DONE ) DoUseDoorOrButton ( GO_COURTYARD_DOOR ) ; m_auiEncounter [ 0 ] = uiData ; break ; case TYPE_RETHILGORE : if ( uiData == DONE ) DoSpeech ( ) ; m_auiEncounter [ 1 ] = uiData ; break ; case TYPE_FENRUS : if ( uiData == DONE ) { if ( Creature * pFenrus = GetSingleCreatureFromStorage ( NPC_FENRUS ) ) pFenrus -> SummonCreature ( NPC_ARCHMAGE_ARUGAL , - 136.89f , 2169.17f , 136.58f , 2.794f , TEMPSUMMON_TIMED_DESPAWN , 30000 ) ; } m_auiEncounter [ 2 ] = uiData ; break ; case TYPE_NANDOS : if ( uiData == DONE ) DoUseDoorOrButton ( GO_ARUGAL_DOOR ) ; m_auiEncounter [ 3 ] = uiData ; break ; case TYPE_INTRO : m_auiEncounter [ 4 ] = uiData ; break ; case TYPE_VOIDWALKER : if ( uiData == DONE ) { m_auiEncounter [ 5 ] ++ ; if ( m_auiEncounter [ 5 ] > 3 ) DoUseDoorOrButton ( GO_SORCERER_DOOR ) ; } break ; } if ( uiData == DONE ) { OUT_SAVE_INST_DATA ; std :: ostringstream saveStream ; saveStream << m_auiEncounter [ 0 ] << " ▁ " << m_auiEncounter [ 1 ] << " ▁ " << m_auiEncounter [ 2 ] << " ▁ " << m_auiEncounter [ 3 ] << " ▁ " << m_auiEncounter [ 4 ] << " ▁ " << m_auiEncounter [ 5 ] ; m_strInstData = saveStream . str ( ) ; SaveToDB ( ) ; OUT_SAVE_INST_DATA_COMPLETE ; } } uint32 instance_shadowfang_keep :: GetData ( uint32 uiType ) const { switch ( uiType ) { case TYPE_FREE_NPC : return m_auiEncounter [ 0 ] ; case TYPE_RETHILGORE : return m_auiEncounter [ 1 ] ; case TYPE_FENRUS : return m_auiEncounter [ 2 ] ; case TYPE_NANDOS : return m_auiEncounter [ 3 ] ; case TYPE_INTRO : return m_auiEncounter [ 4 ] ; default : return 0 ; } } void instance_shadowfang_keep :: Load ( const char * chrIn ) { if ( ! chrIn ) { OUT_LOAD_INST_DATA_FAIL ; return ; } OUT_LOAD_INST_DATA ( chrIn ) ; std :: istringstream loadStream ( chrIn ) ; loadStream >> m_auiEncounter [ 0 ] >> m_auiEncounter [ 1 ] >> m_auiEncounter [ 2 ] >> m_auiEncounter [ 3 ] >> m_auiEncounter [ 4 ] >> m_auiEncounter [ 5 ] ; for ( uint8 i = 0 ; i < MAX_ENCOUNTER ; ++ i ) { if ( m_auiEncounter [ i ] == IN_PROGRESS ) m_auiEncounter [ i ] = NOT_STARTED ; } OUT_LOAD_INST_DATA_COMPLETE ; } InstanceData * GetInstanceData_instance_shadowfang_keep ( Map * pMap ) { return new instance_shadowfang_keep ( pMap ) ; } void AddSC_instance_shadowfang_keep ( ) { Script * pNewScript ; pNewScript = new Script ; pNewScript -> Name = " instance _ shadowfang _ keep " ; pNewScript -> GetInstanceData = & GetInstanceData_instance_shadowfang_keep ; pNewScript -> RegisterSelf ( ) ; } </DOCUMENT>
<DOCUMENT_ID="geodynamics/gale/tree/master/boost/libs/regex/performance/time_greta.cpp"> # include " regex _ comparison . hpp " # if defined ( BOOST_HAS_GRETA ) # include < cassert > # include < boost / timer . hpp > # include " regexpr2 . h " namespace g { double time_match ( const std :: string & re , const std :: string & text , bool icase ) { regex :: rpattern e ( re , ( icase ? regex :: MULTILINE | regex :: NORMALIZE | regex :: NOCASE : regex :: MULTILINE | regex :: NORMALIZE ) ) ; regex :: match_results what ; boost :: timer tim ; int iter = 1 ; int counter , repeats ; double result = 0 ; double run ; assert ( e . match ( text , what ) ) ; do { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text , what ) ; } result = tim . elapsed ( ) ; iter *= 2 ; } while ( result < 0.5 ) ; iter /= 2 ; for ( repeats = 0 ; repeats < REPEAT_COUNT ; ++ repeats ) { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text , what ) ; } run = tim . elapsed ( ) ; result = ( std :: min ) ( run , result ) ; } return result / iter ; } double time_find_all ( const std :: string & re , const std :: string & text , bool icase ) { regex :: rpattern e ( re , ( icase ? regex :: MULTILINE | regex :: NORMALIZE | regex :: NOCASE : regex :: MULTILINE | regex :: NORMALIZE ) ) ; regex :: match_results what ; boost :: timer tim ; int iter = 1 ; int counter , repeats ; double result = 0 ; double run ; do { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text . begin ( ) , text . end ( ) , what ) ; while ( what . backref ( 0 ) . matched ) { e . match ( what . backref ( 0 ) . end ( ) , text . end ( ) , what ) ; } } result = tim . elapsed ( ) ; iter *= 2 ; } while ( result < 0.5 ) ; iter /= 2 ; if ( result > 10 ) return result / iter ; for ( repeats = 0 ; repeats < REPEAT_COUNT ; ++ repeats ) { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text . begin ( ) , text . end ( ) , what ) ; while ( what . backref ( 0 ) . matched ) { e . match ( what . backref ( 0 ) . end ( ) , text . end ( ) , what ) ; } } run = tim . elapsed ( ) ; result = ( std :: min ) ( run , result ) ; } return result / iter ; } } # else namespace g { double time_match ( const std :: string & re , const std :: string & text , bool icase ) { return - 1 ; } double time_find_all ( const std :: string & re , const std :: string & text , bool icase ) { return - 1 ; } } # endif </DOCUMENT>
<DOCUMENT_ID="DLR-SC/tigl/tree/master/src/generated/CPACSFarField.cpp"> # include " CPACSFarField . h " # include " CTiglError . h " # include " CTiglLogging . h " # include " TixiHelper . h " namespace tigl { namespace generated { CPACSFarField :: CPACSFarField ( ) : m_referenceLength ( 0 ) , m_multiplier ( 0 ) { } CPACSFarField :: ~ CPACSFarField ( ) { } void CPACSFarField :: ReadCPACS ( const TixiDocumentHandle & tixiHandle , const std :: string & xpath ) { if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / type " ) ) { m_type = stringToTiglFarFieldType ( tixi :: TixiGetElement < std :: string > ( tixiHandle , xpath + " / type " ) ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ type ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / referenceLength " ) ) { m_referenceLength = tixi :: TixiGetElement < double > ( tixiHandle , xpath + " / referenceLength " ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ referenceLength ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / multiplier " ) ) { m_multiplier = tixi :: TixiGetElement < double > ( tixiHandle , xpath + " / multiplier " ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ multiplier ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } } void CPACSFarField :: WriteCPACS ( const TixiDocumentHandle & tixiHandle , const std :: string & xpath ) const { tixi :: TixiCreateElementIfNotExists ( tixiHandle , xpath + " / type " ) ; tixi :: TixiSaveElement ( tixiHandle , xpath + " / type " , TiglFarFieldTypeToString ( m_type ) ) ; tixi :: TixiCreateElementIfNotExists ( tixiHandle , xpath + " / referenceLength " ) ; tixi :: TixiSaveElement ( tixiHandle , xpath + " / referenceLength " , m_referenceLength ) ; tixi :: TixiCreateElementIfNotExists ( tixiHandle , xpath + " / multiplier " ) ; tixi :: TixiSaveElement ( tixiHandle , xpath + " / multiplier " , m_multiplier ) ; } const TiglFarFieldType & CPACSFarField :: GetType ( ) const { return m_type ; } void CPACSFarField :: SetType ( const TiglFarFieldType & value ) { m_type = value ; } const double & CPACSFarField :: GetReferenceLength ( ) const { return m_referenceLength ; } void CPACSFarField :: SetReferenceLength ( const double & value ) { m_referenceLength = value ; } const double & CPACSFarField :: GetMultiplier ( ) const { return m_multiplier ; } void CPACSFarField :: SetMultiplier ( const double & value ) { m_multiplier = value ; } } } </DOCUMENT>
<DOCUMENT_ID="Earlz/dobbscoin-source/tree/master/src/test/transaction_tests.cpp"> # include " data / tx _ invalid . json . h " # include " data / tx _ valid . json . h " # include " clientversion . h " # include " key . h " # include " keystore . h " # include " main . h " # include " script / script . h " # include " script / script _ error . h " # include " core _ io . h " # include < map > # include < string > # include < boost / algorithm / string / classification . hpp > # include < boost / algorithm / string / split . hpp > # include < boost / test / unit_test . hpp > # include < boost / assign / list_of . hpp > # include " json / json _ spirit _ writer _ template . h " using namespace std ; using namespace json_spirit ; using namespace boost :: algorithm ; extern Array read_json ( const std :: string & jsondata ) ; static std :: map < string , unsigned int > mapFlagNames = boost :: assign :: map_list_of ( string ( " NONE " ) , ( unsigned int ) SCRIPT_VERIFY_NONE ) ( string ( " P2SH " ) , ( unsigned int ) SCRIPT_VERIFY_P2SH ) ( string ( " STRICTENC " ) , ( unsigned int ) SCRIPT_VERIFY_STRICTENC ) ( string ( " DERSIG " ) , ( unsigned int ) SCRIPT_VERIFY_DERSIG ) ( string ( " LOW _ S " ) , ( unsigned int ) SCRIPT_VERIFY_LOW_S ) ( string ( " SIGPUSHONLY " ) , ( unsigned int ) SCRIPT_VERIFY_SIGPUSHONLY ) ( string ( " MINIMALDATA " ) , ( unsigned int ) SCRIPT_VERIFY_MINIMALDATA ) ( string ( " NULLDUMMY " ) , ( unsigned int ) SCRIPT_VERIFY_NULLDUMMY ) ( string ( " DISCOURAGE _ UPGRADABLE _ NOPS " ) , ( unsigned int ) SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS ) ; unsigned int ParseScriptFlags ( string strFlags ) { if ( strFlags . empty ( ) ) { return 0 ; } unsigned int flags = 0 ; vector < string > words ; split ( words , strFlags , is_any_of ( " , " ) ) ; BOOST_FOREACH ( string word , words ) { if ( ! mapFlagNames . count ( word ) ) BOOST_ERROR ( " Bad ▁ test : ▁ unknown ▁ verification ▁ flag ▁ ' " << word << " ' " ) ; flags |= mapFlagNames [ word ] ; } return flags ; } string FormatScriptFlags ( unsigned int flags ) { if ( flags == 0 ) { return " " ; } string ret ; std :: map < string , unsigned int > :: const_iterator it = mapFlagNames . begin ( ) ; while ( it != mapFlagNames . end ( ) ) { if ( flags & it -> second ) { ret += it -> first + " , " ; } it ++ ; } return ret . substr ( 0 , ret . size ( ) - 1 ) ; } BOOST_AUTO_TEST_SUITE ( transaction_tests ) BOOST_AUTO_TEST_CASE ( tx_valid ) { Array tests = read_json ( std :: string ( json_tests :: tx_valid , json_tests :: tx_valid + sizeof ( json_tests :: tx_valid ) ) ) ; ScriptError err ; BOOST_FOREACH ( Value & tv , tests ) { Array test = tv . get_array ( ) ; string strTest = write_string ( tv , false ) ; if ( test [ 0 ] . type ( ) == array_type ) { if ( test . size ( ) != 3 || test [ 1 ] . type ( ) != str_type || test [ 2 ] . type ( ) != str_type ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } map < COutPoint , CScript > mapprevOutScriptPubKeys ; Array inputs = test [ 0 ] . get_array ( ) ; bool fValid = true ; BOOST_FOREACH ( Value & input , inputs ) { if ( input . type ( ) != array_type ) { fValid = false ; break ; } Array vinput = input . get_array ( ) ; if ( vinput . size ( ) != 3 ) { fValid = false ; break ; } mapprevOutScriptPubKeys [ COutPoint ( uint256 ( vinput [ 0 ] . get_str ( ) ) , vinput [ 1 ] . get_int ( ) ) ] = ParseScript ( vinput [ 2 ] . get_str ( ) ) ; } if ( ! fValid ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } string transaction = test [ 1 ] . get_str ( ) ; CDataStream stream ( ParseHex ( transaction ) , SER_NETWORK , PROTOCOL_VERSION ) ; CTransaction tx ; stream >> tx ; CValidationState state ; BOOST_CHECK_MESSAGE ( CheckTransaction ( tx , state ) , strTest ) ; BOOST_CHECK ( state . IsValid ( ) ) ; for ( unsigned int i = 0 ; i < tx . vin . size ( ) ; i ++ ) { if ( ! mapprevOutScriptPubKeys . count ( tx . vin [ i ] . prevout ) ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; break ; } unsigned int verify_flags = ParseScriptFlags ( test [ 2 ] . get_str ( ) ) ; BOOST_CHECK_MESSAGE ( VerifyScript ( tx . vin [ i ] . scriptSig , mapprevOutScriptPubKeys [ tx . vin [ i ] . prevout ] , verify_flags , TransactionSignatureChecker ( & tx , i ) , & err ) , strTest ) ; BOOST_CHECK_MESSAGE ( err == SCRIPT_ERR_OK , ScriptErrorString ( err ) ) ; } } } } BOOST_AUTO_TEST_CASE ( tx_invalid ) { Array tests = read_json ( std :: string ( json_tests :: tx_invalid , json_tests :: tx_invalid + sizeof ( json_tests :: tx_invalid ) ) ) ; ScriptError err ; BOOST_FOREACH ( Value & tv , tests ) { Array test = tv . get_array ( ) ; string strTest = write_string ( tv , false ) ; if ( test [ 0 ] . type ( ) == array_type ) { if ( test . size ( ) != 3 || test [ 1 ] . type ( ) != str_type || test [ 2 ] . type ( ) != str_type ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } map < COutPoint , CScript > mapprevOutScriptPubKeys ; Array inputs = test [ 0 ] . get_array ( ) ; bool fValid = true ; BOOST_FOREACH ( Value & input , inputs ) { if ( input . type ( ) != array_type ) { fValid = false ; break ; } Array vinput = input . get_array ( ) ; if ( vinput . size ( ) != 3 ) { fValid = false ; break ; } mapprevOutScriptPubKeys [ COutPoint ( uint256 ( vinput [ 0 ] . get_str ( ) ) , vinput [ 1 ] . get_int ( ) ) ] = ParseScript ( vinput [ 2 ] . get_str ( ) ) ; } if ( ! fValid ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } string transaction = test [ 1 ] . get_str ( ) ; CDataStream stream ( ParseHex ( transaction ) , SER_NETWORK , PROTOCOL_VERSION ) ; CTransaction tx ; stream >> tx ; CValidationState state ; fValid = CheckTransaction ( tx , state ) && state . IsValid ( ) ; for ( unsigned int i = 0 ; i < tx . vin . size ( ) && fValid ; i ++ ) { if ( ! mapprevOutScriptPubKeys . count ( tx . vin [ i ] . prevout ) ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; break ; } unsigned int verify_flags = ParseScriptFlags ( test [ 2 ] . get_str ( ) ) ; fValid = VerifyScript ( tx . vin [ i ] . scriptSig , mapprevOutScriptPubKeys [ tx . vin [ i ] . prevout ] , verify_flags , TransactionSignatureChecker ( & tx , i ) , & err ) ; } BOOST_CHECK_MESSAGE ( ! fValid , strTest ) ; BOOST_CHECK_MESSAGE ( err != SCRIPT_ERR_OK , ScriptErrorString ( err ) ) ; } } } BOOST_AUTO_TEST_CASE ( basic_transaction_tests ) { unsigned char ch [ ] = { 0x01 , 0x00 , 0x00 , 0x00 , 0x01 , 0x6b , 0xff , 0x7f , 0xcd , 0x4f , 0x85 , 0x65 , 0xef , 0x40 , 0x6d , 0xd5 , 0xd6 , 0x3d , 0x4f , 0xf9 , 0x4f , 0x31 , 0x8f , 0xe8 , 0x20 , 0x27 , 0xfd , 0x4d , 0xc4 , 0x51 , 0xb0 , 0x44 , 0x74 , 0x01 , 0x9f , 0x74 , 0xb4 , 0x00 , 0x00 , 0x00 , 0x00 , 0x8c , 0x49 , 0x30 , 0x46 , 0x02 , 0x21 , 0x00 , 0xda , 0x0d , 0xc6 , 0xae , 0xce , 0xfe , 0x1e , 0x06 , 0xef , 0xdf , 0x05 , 0x77 , 0x37 , 0x57 , 0xde , 0xb1 , 0x68 , 0x82 , 0x09 , 0x30 , 0xe3 , 0xb0 , 0xd0 , 0x3f , 0x46 , 0xf5 , 0xfc , 0xf1 , 0x50 , 0xbf , 0x99 , 0x0c , 0x02 , 0x21 , 0x00 , 0xd2 , 0x5b , 0x5c , 0x87 , 0x04 , 0x00 , 0x76 , 0xe4 , 0xf2 , 0x53 , 0xf8 , 0x26 , 0x2e , 0x76 , 0x3e , 0x2d , 0xd5 , 0x1e , 0x7f , 0xf0 , 0xbe , 0x15 , 0x77 , 0x27 , 0xc4 , 0xbc , 0x42 , 0x80 , 0x7f , 0x17 , 0xbd , 0x39 , 0x01 , 0x41 , 0x04 , 0xe6 , 0xc2 , 0x6e , 0xf6 , 0x7d , 0xc6 , 0x10 , 0xd2 , 0xcd , 0x19 , 0x24 , 0x84 , 0x78 , 0x9a , 0x6c , 0xf9 , 0xae , 0xa9 , 0x93 , 0x0b , 0x94 , 0x4b , 0x7e , 0x2d , 0xb5 , 0x34 , 0x2b , 0x9d , 0x9e , 0x5b , 0x9f , 0xf7 , 0x9a , 0xff , 0x9a , 0x2e , 0xe1 , 0x97 , 0x8d , 0xd7 , 0xfd , 0x01 , 0xdf , 0xc5 , 0x22 , 0xee , 0x02 , 0x28 , 0x3d , 0x3b , 0x06 , 0xa9 , 0xd0 , 0x3a , 0xcf , 0x80 , 0x96 , 0x96 , 0x8d , 0x7d , 0xbb , 0x0f , 0x91 , 0x78 , 0xff , 0xff , 0xff , 0xff , 0x02 , 0x8b , 0xa7 , 0x94 , 0x0e , 0x00 , 0x00 , 0x00 , 0x00 , 0x19 , 0x76 , 0xa9 , 0x14 , 0xba , 0xde , 0xec , 0xfd , 0xef , 0x05 , 0x07 , 0x24 , 0x7f , 0xc8 , 0xf7 , 0x42 , 0x41 , 0xd7 , 0x3b , 0xc0 , 0x39 , 0x97 , 0x2d , 0x7b , 0x88 , 0xac , 0x40 , 0x94 , 0xa8 , 0x02 , 0x00 , 0x00 , 0x00 , 0x00 , 0x19 , 0x76 , 0xa9 , 0x14 , 0xc1 , 0x09 , 0x32 , 0x48 , 0x3f , 0xec , 0x93 , 0xed , 0x51 , 0xf5 , 0xfe , 0x95 , 0xe7 , 0x25 , 0x59 , 0xf2 , 0xcc , 0x70 , 0x43 , 0xf9 , 0x88 , 0xac , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 } ; vector < unsigned char > vch ( ch , ch + sizeof ( ch ) - 1 ) ; CDataStream stream ( vch , SER_DISK , CLIENT_VERSION ) ; CMutableTransaction tx ; stream >> tx ; CValidationState state ; BOOST_CHECK_MESSAGE ( CheckTransaction ( tx , state ) && state . IsValid ( ) , " Simple ▁ deserialized ▁ transaction ▁ should ▁ be ▁ valid . " ) ; tx . vin . push_back ( tx . vin [ 0 ] ) ; BOOST_CHECK_MESSAGE ( ! CheckTransaction ( tx , state ) || ! state . IsValid ( ) , " Transaction ▁ with ▁ duplicate ▁ txins ▁ should ▁ be ▁ invalid . " ) ; } static std :: vector < CMutableTransaction > SetupDummyInputs ( CBasicKeyStore & keystoreRet , CCoinsViewCache & coinsRet ) { std :: vector < CMutableTransaction > dummyTransactions ; dummyTransactions . resize ( 2 ) ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { key [ i ] . MakeNewKey ( i % 2 ) ; keystoreRet . AddKey ( key [ i ] ) ; } dummyTransactions [ 0 ] . vout . resize ( 2 ) ; dummyTransactions [ 0 ] . vout [ 0 ] . nValue = 11 * CENT ; dummyTransactions [ 0 ] . vout [ 0 ] . scriptPubKey << ToByteVector ( key [ 0 ] . GetPubKey ( ) ) << OP_CHECKSIG ; dummyTransactions [ 0 ] . vout [ 1 ] . nValue = 50 * CENT ; dummyTransactions [ 0 ] . vout [ 1 ] . scriptPubKey << ToByteVector ( key [ 1 ] . GetPubKey ( ) ) << OP_CHECKSIG ; coinsRet . ModifyCoins ( dummyTransactions [ 0 ] . GetHash ( ) ) -> FromTx ( dummyTransactions [ 0 ] , 0 ) ; dummyTransactions [ 1 ] . vout . resize ( 2 ) ; dummyTransactions [ 1 ] . vout [ 0 ] . nValue = 21 * CENT ; dummyTransactions [ 1 ] . vout [ 0 ] . scriptPubKey = GetScriptForDestination ( key [ 2 ] . GetPubKey ( ) . GetID ( ) ) ; dummyTransactions [ 1 ] . vout [ 1 ] . nValue = 22 * CENT ; dummyTransactions [ 1 ] . vout [ 1 ] . scriptPubKey = GetScriptForDestination ( key [ 3 ] . GetPubKey ( ) . GetID ( ) ) ; coinsRet . ModifyCoins ( dummyTransactions [ 1 ] . GetHash ( ) ) -> FromTx ( dummyTransactions [ 1 ] , 0 ) ; return dummyTransactions ; } BOOST_AUTO_TEST_CASE ( test_Get ) { CBasicKeyStore keystore ; CCoinsView coinsDummy ; CCoinsViewCache coins ( & coinsDummy ) ; std :: vector < CMutableTransaction > dummyTransactions = SetupDummyInputs ( keystore , coins ) ; CMutableTransaction t1 ; t1 . vin . resize ( 3 ) ; t1 . vin [ 0 ] . prevout . hash = dummyTransactions [ 0 ] . GetHash ( ) ; t1 . vin [ 0 ] . prevout . n = 1 ; t1 . vin [ 0 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) ; t1 . vin [ 1 ] . prevout . hash = dummyTransactions [ 1 ] . GetHash ( ) ; t1 . vin [ 1 ] . prevout . n = 0 ; t1 . vin [ 1 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) << std :: vector < unsigned char > ( 33 , 4 ) ; t1 . vin [ 2 ] . prevout . hash = dummyTransactions [ 1 ] . GetHash ( ) ; t1 . vin [ 2 ] . prevout . n = 1 ; t1 . vin [ 2 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) << std :: vector < unsigned char > ( 33 , 4 ) ; t1 . vout . resize ( 2 ) ; t1 . vout [ 0 ] . nValue = 90 * CENT ; t1 . vout [ 0 ] . scriptPubKey << OP_1 ; BOOST_CHECK ( AreInputsStandard ( t1 , coins ) ) ; BOOST_CHECK_EQUAL ( coins . GetValueIn ( t1 ) , ( 50 + 21 + 22 ) * CENT ) ; t1 . vin [ 0 ] . scriptSig << OP_11 ; BOOST_CHECK ( ! AreInputsStandard ( t1 , coins ) ) ; t1 . vin [ 0 ] . scriptSig = CScript ( ) ; BOOST_CHECK ( ! AreInputsStandard ( t1 , coins ) ) ; } BOOST_AUTO_TEST_CASE ( test_IsStandard ) { LOCK ( cs_main ) ; CBasicKeyStore keystore ; CCoinsView coinsDummy ; CCoinsViewCache coins ( & coinsDummy ) ; std :: vector < CMutableTransaction > dummyTransactions = SetupDummyInputs ( keystore , coins ) ; CMutableTransaction t ; t . vin . resize ( 1 ) ; t . vin [ 0 ] . prevout . hash = dummyTransactions [ 0 ] . GetHash ( ) ; t . vin [ 0 ] . prevout . n = 1 ; t . vin [ 0 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) ; t . vout . resize ( 1 ) ; t . vout [ 0 ] . nValue = 90 * CENT ; CKey key ; key . MakeNewKey ( true ) ; t . vout [ 0 ] . scriptPubKey = GetScriptForDestination ( key . GetPubKey ( ) . GetID ( ) ) ; string reason ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . nValue = 501 ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . nValue = 601 ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_1 ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3800" ) ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout . resize ( 1 ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout . resize ( 2 ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; t . vout [ 1 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; t . vout [ 1 ] . scriptPubKey = CScript ( ) << OP_RETURN ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN ; t . vout [ 1 ] . scriptPubKey = CScript ( ) << OP_RETURN ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
<DOCUMENT_ID="atidot3/Orizon-510/tree/master/src/server/authserver/Main.cpp"> # include < ace / Dev_Poll_Reactor . h > # include < ace / TP_Reactor . h > # include < ace / ACE . h > # include < ace / Sig_Handler . h > # include < openssl / opensslv . h > # include < openssl / crypto . h > # include " Common . h " # include " Database / DatabaseEnv . h " # include " Configuration / Config . h " # include " Log . h " # include " SystemConfig . h " # include " Util . h " # include " SignalHandler . h " # include " RealmList . h " # include " RealmAcceptor . h " # ifndef _TRINITY_REALM_CONFIG # define _TRINITY_REALM_CONFIG " authserver . conf " # endif bool StartDB ( ) ; void StopDB ( ) ; bool stopEvent = false ; LoginDatabaseWorkerPool LoginDatabase ; class AuthServerSignalHandler : public Trinity :: SignalHandler { public : virtual void HandleSignal ( int SigNum ) { switch ( SigNum ) { case SIGINT : case SIGTERM : stopEvent = true ; break ; } } } ; void usage ( const char * prog ) { sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Usage : ▁ \n ▁ % s ▁ [ < options > ] \n " " ▁ ▁ ▁ ▁ - c ▁ config _ file ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ use ▁ config _ file ▁ as ▁ configuration ▁ file \n " , prog ) ; } extern int main ( int argc , char * * argv ) { char const * cfg_file = _TRINITY_REALM_CONFIG ; int c = 1 ; while ( c < argc ) { if ( strcmp ( argv [ c ] , " - c " ) == 0 ) { if ( ++ c >= argc ) { printf ( " Runtime - Error : ▁ - c ▁ option ▁ requires ▁ an ▁ input ▁ argument \n " ) ; usage ( argv [ 0 ] ) ; return 1 ; } else cfg_file = argv [ c ] ; } ++ c ; } if ( ! ConfigMgr :: Load ( cfg_file ) ) { printf ( " Invalid ▁ or ▁ missing ▁ configuration ▁ file ▁ : ▁ % s \n " , cfg_file ) ; printf ( " Verify ▁ that ▁ the ▁ file ▁ exists ▁ and ▁ has ▁ \ ' [ authserver ] \ ' ▁ written ▁ in ▁ the ▁ top ▁ of ▁ the ▁ file ! \n " ) ; return 1 ; } sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " % s ▁ ( authserver ) " , _FULLVERSION ) ; sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " < Ctrl - C > ▁ to ▁ stop . \n " ) ; sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Using ▁ configuration ▁ file ▁ % s . " , cfg_file ) ; sLog -> outWarn ( LOG_FILTER_AUTHSERVER , " % s ▁ ( Library : ▁ % s ) " , OPENSSL_VERSION_TEXT , SSLeay_version ( SSLEAY_VERSION ) ) ; # if defined ( ACE_HAS_EVENT_POLL ) || defined ( ACE_HAS_DEV_POLL ) ACE_Reactor :: instance ( new ACE_Reactor ( new ACE_Dev_Poll_Reactor ( ACE :: max_handles ( ) , 1 ) , 1 ) , true ) ; # else ACE_Reactor :: instance ( new ACE_Reactor ( new ACE_TP_Reactor ( ) , true ) , true ) ; # endif sLog -> outDebug ( LOG_FILTER_AUTHSERVER , " Max ▁ allowed ▁ open ▁ files ▁ is ▁ % d " , ACE :: max_handles ( ) ) ; std :: string pidfile = ConfigMgr :: GetStringDefault ( " PidFile " , " " ) ; if ( ! pidfile . empty ( ) ) { uint32 pid = CreatePIDFile ( pidfile ) ; if ( ! pid ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Cannot ▁ create ▁ PID ▁ file ▁ % s . \n " , pidfile . c_str ( ) ) ; return 1 ; } sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Daemon ▁ PID : ▁ % u \n " , pid ) ; } if ( ! StartDB ( ) ) return 1 ; sLog -> SetRealmID ( 0 ) ; sRealmList -> Initialize ( ConfigMgr :: GetIntDefault ( " RealmsStateUpdateDelay " , 20 ) ) ; if ( sRealmList -> size ( ) == 0 ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " No ▁ valid ▁ realms ▁ specified . " ) ; return 1 ; } RealmAcceptor acceptor ; int32 rmport = ConfigMgr :: GetIntDefault ( " RealmServerPort " , 3724 ) ; if ( rmport < 0 || rmport > 0xFFFF ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Specified ▁ port ▁ out ▁ of ▁ allowed ▁ range ▁ ( 1-65535 ) " ) ; return 1 ; } std :: string bind_ip = ConfigMgr :: GetStringDefault ( " BindIP " , "0.0.0.0" ) ; ACE_INET_Addr bind_addr ( uint16 ( rmport ) , bind_ip . c_str ( ) ) ; if ( acceptor . open ( bind_addr , ACE_Reactor :: instance ( ) , ACE_NONBLOCK ) == - 1 ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Auth ▁ server ▁ can ▁ not ▁ bind ▁ to ▁ % s : % d " , bind_ip . c_str ( ) , rmport ) ; return 1 ; } AuthServerSignalHandler SignalINT , SignalTERM ; ACE_Sig_Handler Handler ; Handler . register_handler ( SIGINT , & SignalINT ) ; Handler . register_handler ( SIGTERM , & SignalTERM ) ; # ifdef _WIN32 { HANDLE hProcess = GetCurrentProcess ( ) ; uint32 Aff = ConfigMgr :: GetIntDefault ( " UseProcessors " , 0 ) ; if ( Aff > 0 ) { ULONG_PTR appAff ; ULONG_PTR sysAff ; if ( GetProcessAffinityMask ( hProcess , & appAff , & sysAff ) ) { ULONG_PTR curAff = Aff & appAff ; if ( ! curAff ) sLog -> outError ( LOG_FILTER_AUTHSERVER , " Processors ▁ marked ▁ in ▁ UseProcessors ▁ bitmask ▁ ( hex ) ▁ % x ▁ not ▁ accessible ▁ for ▁ authserver . ▁ Accessible ▁ processors ▁ bitmask ▁ ( hex ) : ▁ % x " , Aff , appAff ) ; else if ( SetProcessAffinityMask ( hProcess , curAff ) ) sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Using ▁ processors ▁ ( bitmask , ▁ hex ) : ▁ % x " , curAff ) ; else sLog -> outError ( LOG_FILTER_AUTHSERVER , " Can ' t ▁ set ▁ used ▁ processors ▁ ( hex ) : ▁ % x " , curAff ) ; } } bool Prio = ConfigMgr :: GetBoolDefault ( " ProcessPriority " , false ) ; if ( Prio ) { if ( SetPriorityClass ( hProcess , HIGH_PRIORITY_CLASS ) ) sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " The ▁ auth ▁ server ▁ process ▁ priority ▁ class ▁ has ▁ been ▁ set ▁ to ▁ HIGH " ) ; else sLog -> outError ( LOG_FILTER_AUTHSERVER , " Can ' t ▁ set ▁ auth ▁ server ▁ process ▁ priority ▁ class . " ) ; } } # endif uint32 numLoops = ( ConfigMgr :: GetIntDefault ( " MaxPingTime " , 30 ) * ( MINUTE * 1000000 / 100000 ) ) ; uint32 loopCounter = 0 ; while ( ! stopEvent ) { ACE_Time_Value interval ( 0 , 100000 ) ; if ( ACE_Reactor :: instance ( ) -> run_reactor_event_loop ( interval ) == - 1 ) break ; if ( ( ++ loopCounter ) == numLoops ) { loopCounter = 0 ; sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Ping ▁ MySQL ▁ to ▁ keep ▁ connection ▁ alive " ) ; LoginDatabase . KeepAlive ( ) ; } } StopDB ( ) ; sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Halting ▁ process . . . " ) ; return 0 ; } bool StartDB ( ) { MySQL :: Library_Init ( ) ; std :: string dbstring = ConfigMgr :: GetStringDefault ( " LoginDatabaseInfo " , " " ) ; if ( dbstring . empty ( ) ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Database ▁ not ▁ specified " ) ; return false ; } int32 worker_threads = ConfigMgr :: GetIntDefault ( " LoginDatabase . WorkerThreads " , 1 ) ; if ( worker_threads < 1 || worker_threads > 32 ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Improper ▁ value ▁ specified ▁ for ▁ LoginDatabase . WorkerThreads , ▁ defaulting ▁ to ▁ 1 . " ) ; worker_threads = 1 ; } int32 synch_threads = ConfigMgr :: GetIntDefault ( " LoginDatabase . SynchThreads " , 1 ) ; if ( synch_threads < 1 || synch_threads > 32 ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Improper ▁ value ▁ specified ▁ for ▁ LoginDatabase . SynchThreads , ▁ defaulting ▁ to ▁ 1 . " ) ; synch_threads = 1 ; } if ( ! LoginDatabase . Open ( dbstring . c_str ( ) , uint8 ( worker_threads ) , uint8 ( synch_threads ) ) ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Cannot ▁ connect ▁ to ▁ database " ) ; return false ; } sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Started ▁ auth ▁ database ▁ connection ▁ pool . " ) ; sLog -> EnableDBAppenders ( ) ; return true ; } void StopDB ( ) { LoginDatabase . Close ( ) ; MySQL :: Library_End ( ) ; } </DOCUMENT>
<DOCUMENT_ID="Soverance/EtherealLegends/tree/master/Ethereal/Private/Gear/Weapons/Ranged/Annihilator.cpp"> # include " Ethereal . h " # include " Annihilator . h " # define LOCTEXT_NAMESPACE " EtherealText " AAnnihilator :: AAnnihilator ( const FObjectInitializer & ObjectInitializer ) : Super ( ObjectInitializer ) { static ConstructorHelpers :: FObjectFinder < USkeletalMesh > SkeletalMeshObject ( TEXT ( " SkeletalMesh ' / Game / VFX / sphere _ skeletal . sphere _ skeletal ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UStaticMesh > StaticMeshObject ( TEXT ( " StaticMesh ' / Game / Weapons / Ranged / Anni . Anni ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UStaticMesh > OffhandMeshObject ( TEXT ( " StaticMesh ' / Game / VFX / sphere . sphere ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UTexture2D > LargeIconObject ( TEXT ( " Texture2D ' / Game / Blueprints / Widgets / UI - Images / Icons _ Gear / WeaponIcon _ Annihilator . WeaponIcon _ Annihilator ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UTexture2D > SmallIconObject ( TEXT ( " Texture2D ' / Game / Blueprints / Widgets / UI - Images / Icons _ Gear / WeaponIcon _ Annihilator - small . WeaponIcon _ Annihilator - small ' " ) ) ; Name = EMasterGearList :: GL_Annihilator ; NameText = LOCTEXT ( " AnnihilatorName " , " Annihilator " ) ; Type = EMasterGearTypes :: GT_Ranged ; TypeText = LOCTEXT ( " AnnihilatorType " , " Ranged " ) ; Description = " An ▁ embodiment ▁ of ▁ the ▁ Ethereal ▁ Virtue : ▁ Wrath . " ; Price = 40000 ; MPCost = 0.0f ; ATK = 50.0f ; DEF = 40.0f ; SPD = 20.0f ; HP = 500.0f ; MP = 250.0f ; LargeIcon = LargeIconObject . Object ; SmallIcon = SmallIconObject . Object ; SK_WeaponSkeletalMesh = SkeletalMeshObject . Object ; SM_WeaponStaticMesh = StaticMeshObject . Object ; SM_WeaponOffhandMesh = StaticMeshObject . Object ; WeaponSkeletalMesh -> SetSkeletalMesh ( SK_WeaponSkeletalMesh ) ; WeaponSkeletalMesh -> SetHiddenInGame ( true ) ; WeaponStaticMesh -> SetStaticMesh ( SM_WeaponStaticMesh ) ; WeaponStaticMesh -> SetWorldScale3D ( FVector ( 0.15f , 0.15f , 0.15f ) ) ; WeaponStaticMesh -> SetRelativeLocation ( FVector ( 20 , - 2 , - 2 ) ) ; WeaponStaticMesh -> SetRelativeRotation ( FRotator ( - 12 , - 90 , - 75 ) ) ; WeaponOffhandMesh -> SetStaticMesh ( SM_WeaponOffhandMesh ) ; WeaponOffhandMesh -> SetHiddenInGame ( true ) ; } void AAnnihilator :: BeginPlay ( ) { Super :: BeginPlay ( ) ; OnBindGear . AddDynamic ( this , & AAnnihilator :: BindWeapon ) ; } void AAnnihilator :: BindWeapon ( ) { if ( IsShown ) { ShowWeapon ( false , true , false ) ; } } # undef LOCTEXT_NAMESPACE </DOCUMENT>
<DOCUMENT_ID="ThomasXBMC/XCSoar/tree/master/src/Engine/Task/Computer/DistanceStatComputer.cpp"> # include " DistanceStatComputer . hpp " # include " Task / Stats / DistanceStat . hpp " void DistanceStatComputer :: CalcSpeed ( DistanceStat & data , fixed time ) { if ( positive ( time ) && data . IsDefined ( ) ) data . speed = data . GetDistance ( ) / time ; else data . speed = fixed ( 0 ) ; } </DOCUMENT>
<DOCUMENT_ID="cppisfun/GameEngine/tree/master/foreign/boost/libs/multi_array/example/subview2.cpp"> # include " boost / multi _ array . hpp " # include " boost / cstdlib . hpp " int main ( ) { using boost :: extents ; using boost :: indices ; typedef boost :: multi_array < int , 3 > array ; int data [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 } ; const int data_size = 24 ; array myarray ( extents [ 2 ] [ 3 ] [ 4 ] ) ; myarray . assign ( data , data + data_size ) ; typedef boost :: multi_array_types :: index_range range ; array :: array_view < 3 > :: type myview = myarray [ indices [ range ( 0 , 2 ) ] [ range ( 1 , 3 ) ] [ range ( 0 , 4 , 2 ) ] ] ; for ( array :: index i = 0 ; i != 2 ; ++ i ) for ( array :: index j = 0 ; j != 2 ; ++ j ) for ( array :: index k = 0 ; k != 2 ; ++ k ) assert ( myview [ i ] [ j ] [ k ] == myarray [ i ] [ j + 1 ] [ k * 2 ] ) ; return boost :: exit_success ; } </DOCUMENT>
<DOCUMENT_ID="hacklab-turku/luumuhillo/tree/master/source/main.cpp"> # include " game . hpp " # include " server . hpp " # ifdef _WIN32 # include < Windows . h > # endif int main ( int argc , char * * argv ) { if ( game . start ( ) != 0 ) return - 1 ; int retcode = game . getServer ( ) -> start ( ) ; if ( retcode == 0 ) { # ifdef _WIN32 TerminateProcess ( GetCurrentProcess ( ) , EXIT_SUCCESS ) ; # endif return 0 ; } else return retcode ; } </DOCUMENT>
<DOCUMENT_ID="leighleighleigh/smol-pong/tree/master/smol_pong/DNSServer.cpp"> # include " . / DNSServer . h " # include < lwip / def . h > # include < Arduino . h > # define DEBUG # define DEBUG_OUTPUT Serial DNSServer :: DNSServer ( ) { _ttl = htonl ( 60 ) ; _errorReplyCode = DNSReplyCode :: NonExistentDomain ; } bool DNSServer :: start ( const uint16_t & port , const String & domainName , const IPAddress & resolvedIP ) { _port = port ; _domainName = domainName ; _resolvedIP [ 0 ] = resolvedIP [ 0 ] ; _resolvedIP [ 1 ] = resolvedIP [ 1 ] ; _resolvedIP [ 2 ] = resolvedIP [ 2 ] ; _resolvedIP [ 3 ] = resolvedIP [ 3 ] ; downcaseAndRemoveWwwPrefix ( _domainName ) ; return _udp . begin ( _port ) == 1 ; } void DNSServer :: setErrorReplyCode ( const DNSReplyCode & replyCode ) { _errorReplyCode = replyCode ; } void DNSServer :: setTTL ( const uint32_t & ttl ) { _ttl = htonl ( ttl ) ; } void DNSServer :: stop ( ) { _udp . stop ( ) ; } void DNSServer :: downcaseAndRemoveWwwPrefix ( String & domainName ) { domainName . toLowerCase ( ) ; domainName . replace ( " www . " , " " ) ; } void DNSServer :: processNextRequest ( ) { _currentPacketSize = _udp . parsePacket ( ) ; if ( _currentPacketSize ) { _buffer = ( unsigned char * ) malloc ( _currentPacketSize * sizeof ( char ) ) ; _udp . read ( _buffer , _currentPacketSize ) ; _dnsHeader = ( DNSHeader * ) _buffer ; if ( _dnsHeader -> QR == DNS_QR_QUERY && _dnsHeader -> OPCode == DNS_OPCODE_QUERY && requestIncludesOnlyOneQuestion ( ) && ( _domainName == " * " || getDomainNameWithoutWwwPrefix ( ) == _domainName ) ) { replyWithIP ( ) ; } else if ( _dnsHeader -> QR == DNS_QR_QUERY ) { replyWithCustomCode ( ) ; } free ( _buffer ) ; } } bool DNSServer :: requestIncludesOnlyOneQuestion ( ) { return ntohs ( _dnsHeader -> QDCount ) == 1 && _dnsHeader -> ANCount == 0 && _dnsHeader -> NSCount == 0 && _dnsHeader -> ARCount == 0 ; } String DNSServer :: getDomainNameWithoutWwwPrefix ( ) { String parsedDomainName = " " ; unsigned char * start = _buffer + 12 ; if ( * start == 0 ) { return parsedDomainName ; } int pos = 0 ; while ( true ) { unsigned char labelLength = * ( start + pos ) ; for ( int i = 0 ; i < labelLength ; i ++ ) { pos ++ ; parsedDomainName += ( char ) * ( start + pos ) ; } pos ++ ; if ( * ( start + pos ) == 0 ) { downcaseAndRemoveWwwPrefix ( parsedDomainName ) ; return parsedDomainName ; } else { parsedDomainName += " . " ; } } } void DNSServer :: replyWithIP ( ) { _dnsHeader -> QR = DNS_QR_RESPONSE ; _dnsHeader -> ANCount = _dnsHeader -> QDCount ; _dnsHeader -> QDCount = _dnsHeader -> QDCount ; _udp . beginPacket ( _udp . remoteIP ( ) , _udp . remotePort ( ) ) ; _udp . write ( _buffer , _currentPacketSize ) ; _udp . write ( ( uint8_t ) 192 ) ; _udp . write ( ( uint8_t ) 12 ) ; _udp . write ( ( uint8_t ) 0 ) ; _udp . write ( ( uint8_t ) 1 ) ; _udp . write ( ( uint8_t ) 0 ) ; _udp . write ( ( uint8_t ) 1 ) ; _udp . write ( ( unsigned char * ) & _ttl , 4 ) ; _udp . write ( ( uint8_t ) 0 ) ; _udp . write ( ( uint8_t ) 4 ) ; _udp . write ( _resolvedIP , sizeof ( _resolvedIP ) ) ; _udp . endPacket ( ) ; # ifdef DEBUG DEBUG_OUTPUT . print ( " DNS ▁ responds : ▁ " ) ; DEBUG_OUTPUT . print ( _resolvedIP [ 0 ] ) ; DEBUG_OUTPUT . print ( " . " ) ; DEBUG_OUTPUT . print ( _resolvedIP [ 1 ] ) ; DEBUG_OUTPUT . print ( " . " ) ; DEBUG_OUTPUT . print ( _resolvedIP [ 2 ] ) ; DEBUG_OUTPUT . print ( " . " ) ; DEBUG_OUTPUT . print ( _resolvedIP [ 3 ] ) ; DEBUG_OUTPUT . print ( " ▁ for ▁ " ) ; DEBUG_OUTPUT . println ( getDomainNameWithoutWwwPrefix ( ) ) ; # endif } void DNSServer :: replyWithCustomCode ( ) { _dnsHeader -> QR = DNS_QR_RESPONSE ; _dnsHeader -> RCode = ( unsigned char ) _errorReplyCode ; _dnsHeader -> QDCount = 0 ; _udp . beginPacket ( _udp . remoteIP ( ) , _udp . remotePort ( ) ) ; _udp . write ( _buffer , sizeof ( DNSHeader ) ) ; _udp . endPacket ( ) ; } </DOCUMENT>
<DOCUMENT_ID="alessonrenato/TrinityCore/tree/master/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp"> # include " BattlegroundAB . h " # include " WorldPacket . h " # include " BattlegroundMgr . h " # include " Creature . h " # include " Language . h " # include " Player . h " # include " Util . h " # include " WorldSession . h " BattlegroundAB :: BattlegroundAB ( ) { m_IsInformedNearVictory = false ; m_BuffChange = true ; BgObjects . resize ( BG_AB_OBJECT_MAX ) ; BgCreatures . resize ( BG_AB_ALL_NODES_COUNT + 5 ) ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { m_Nodes [ i ] = 0 ; m_prevNodes [ i ] = 0 ; m_NodeTimers [ i ] = 0 ; m_BannerTimers [ i ] . timer = 0 ; m_BannerTimers [ i ] . type = 0 ; m_BannerTimers [ i ] . teamIndex = 0 ; } for ( uint8 i = 0 ; i < BG_TEAMS_COUNT ; ++ i ) { m_lastTick [ i ] = 0 ; m_HonorScoreTics [ i ] = 0 ; m_ReputationScoreTics [ i ] = 0 ; m_TeamScores500Disadvantage [ i ] = false ; } m_HonorTics = 0 ; m_ReputationTics = 0 ; StartMessageIds [ BG_STARTING_EVENT_FIRST ] = LANG_BG_AB_START_TWO_MINUTES ; StartMessageIds [ BG_STARTING_EVENT_SECOND ] = LANG_BG_AB_START_ONE_MINUTE ; StartMessageIds [ BG_STARTING_EVENT_THIRD ] = LANG_BG_AB_START_HALF_MINUTE ; StartMessageIds [ BG_STARTING_EVENT_FOURTH ] = LANG_BG_AB_HAS_BEGUN ; } BattlegroundAB :: ~ BattlegroundAB ( ) { } void BattlegroundAB :: PostUpdateImpl ( uint32 diff ) { if ( GetStatus ( ) == STATUS_IN_PROGRESS ) { int team_points [ BG_TEAMS_COUNT ] = { 0 , 0 } ; for ( int node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) { if ( m_BannerTimers [ node ] . timer ) { if ( m_BannerTimers [ node ] . timer > diff ) m_BannerTimers [ node ] . timer -= diff ; else { m_BannerTimers [ node ] . timer = 0 ; _CreateBanner ( node , m_BannerTimers [ node ] . type , m_BannerTimers [ node ] . teamIndex , false ) ; } } if ( m_NodeTimers [ node ] ) { if ( m_NodeTimers [ node ] > diff ) m_NodeTimers [ node ] -= diff ; else { m_NodeTimers [ node ] = 0 ; uint8 teamIndex = m_Nodes [ node ] - 1 ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] += 2 ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; _NodeOccupied ( node , ( teamIndex == 0 ) ? ALLIANCE : HORDE ) ; if ( teamIndex == 0 ) { SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_ALLIANCE , NULL , LANG_BG_AB_ALLY , _GetNodeNameId ( node ) ) ; PlaySoundToAll ( BG_AB_SOUND_NODE_CAPTURED_ALLIANCE ) ; } else { SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_HORDE , NULL , LANG_BG_AB_HORDE , _GetNodeNameId ( node ) ) ; PlaySoundToAll ( BG_AB_SOUND_NODE_CAPTURED_HORDE ) ; } } } for ( int team = 0 ; team < BG_TEAMS_COUNT ; ++ team ) if ( m_Nodes [ node ] == team + BG_AB_NODE_TYPE_OCCUPIED ) ++ team_points [ team ] ; } for ( int team = 0 ; team < BG_TEAMS_COUNT ; ++ team ) { int points = team_points [ team ] ; if ( ! points ) continue ; m_lastTick [ team ] += diff ; if ( m_lastTick [ team ] > BG_AB_TickIntervals [ points ] ) { m_lastTick [ team ] -= BG_AB_TickIntervals [ points ] ; m_TeamScores [ team ] += BG_AB_TickPoints [ points ] ; m_HonorScoreTics [ team ] += BG_AB_TickPoints [ points ] ; m_ReputationScoreTics [ team ] += BG_AB_TickPoints [ points ] ; if ( m_ReputationScoreTics [ team ] >= m_ReputationTics ) { ( team == TEAM_ALLIANCE ) ? RewardReputationToTeam ( 509 , 10 , ALLIANCE ) : RewardReputationToTeam ( 510 , 10 , HORDE ) ; m_ReputationScoreTics [ team ] -= m_ReputationTics ; } if ( m_HonorScoreTics [ team ] >= m_HonorTics ) { RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ( team == TEAM_ALLIANCE ) ? ALLIANCE : HORDE ) ; m_HonorScoreTics [ team ] -= m_HonorTics ; } if ( ! m_IsInformedNearVictory && m_TeamScores [ team ] > BG_AB_WARNING_NEAR_VICTORY_SCORE ) { if ( team == TEAM_ALLIANCE ) SendMessageToAll ( LANG_BG_AB_A_NEAR_VICTORY , CHAT_MSG_BG_SYSTEM_NEUTRAL ) ; else SendMessageToAll ( LANG_BG_AB_H_NEAR_VICTORY , CHAT_MSG_BG_SYSTEM_NEUTRAL ) ; PlaySoundToAll ( BG_AB_SOUND_NEAR_VICTORY ) ; m_IsInformedNearVictory = true ; } if ( m_TeamScores [ team ] > BG_AB_MAX_TEAM_SCORE ) m_TeamScores [ team ] = BG_AB_MAX_TEAM_SCORE ; if ( team == TEAM_ALLIANCE ) UpdateWorldState ( BG_AB_OP_RESOURCES_ALLY , m_TeamScores [ team ] ) ; else if ( team == TEAM_HORDE ) UpdateWorldState ( BG_AB_OP_RESOURCES_HORDE , m_TeamScores [ team ] ) ; uint8 otherTeam = ( team + 1 ) % BG_TEAMS_COUNT ; if ( m_TeamScores [ team ] > m_TeamScores [ otherTeam ] + 500 ) m_TeamScores500Disadvantage [ otherTeam ] = true ; } } if ( m_TeamScores [ TEAM_ALLIANCE ] >= BG_AB_MAX_TEAM_SCORE ) EndBattleground ( ALLIANCE ) ; else if ( m_TeamScores [ TEAM_HORDE ] >= BG_AB_MAX_TEAM_SCORE ) EndBattleground ( HORDE ) ; } } void BattlegroundAB :: StartingEventCloseDoors ( ) { for ( int obj = BG_AB_OBJECT_BANNER_NEUTRAL ; obj < BG_AB_DYNAMIC_NODES_COUNT * 8 ; ++ obj ) SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT * 3 ; ++ i ) SpawnBGObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + i , RESPAWN_ONE_DAY ) ; DoorClose ( BG_AB_OBJECT_GATE_A ) ; DoorClose ( BG_AB_OBJECT_GATE_H ) ; SpawnBGObject ( BG_AB_OBJECT_GATE_A , RESPAWN_IMMEDIATELY ) ; SpawnBGObject ( BG_AB_OBJECT_GATE_H , RESPAWN_IMMEDIATELY ) ; _NodeOccupied ( BG_AB_SPIRIT_ALIANCE , ALLIANCE ) ; _NodeOccupied ( BG_AB_SPIRIT_HORDE , HORDE ) ; } void BattlegroundAB :: StartingEventOpenDoors ( ) { for ( int banner = BG_AB_OBJECT_BANNER_NEUTRAL , i = 0 ; i < 5 ; banner += 8 , ++ i ) SpawnBGObject ( banner , RESPAWN_IMMEDIATELY ) ; for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { uint8 buff = urand ( 0 , 2 ) ; SpawnBGObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + buff + i * 3 , RESPAWN_IMMEDIATELY ) ; } DoorOpen ( BG_AB_OBJECT_GATE_A ) ; DoorOpen ( BG_AB_OBJECT_GATE_H ) ; StartTimedAchievement ( ACHIEVEMENT_TIMED_TYPE_EVENT , AB_EVENT_START_BATTLE ) ; } void BattlegroundAB :: AddPlayer ( Player * player ) { Battleground :: AddPlayer ( player ) ; PlayerScores [ player -> GetGUID ( ) ] = new BattlegroundABScore ( player -> GetGUID ( ) , player -> GetBGTeam ( ) ) ; } void BattlegroundAB :: RemovePlayer ( Player * , ObjectGuid , uint32 ) { } void BattlegroundAB :: HandleAreaTrigger ( Player * player , uint32 trigger , bool entered ) { if ( GetStatus ( ) != STATUS_IN_PROGRESS ) return ; switch ( trigger ) { case 3948 : if ( player -> GetTeam ( ) != ALLIANCE ) player -> GetSession ( ) -> SendNotification ( " Only ▁ The ▁ Alliance ▁ can ▁ use ▁ that ▁ portal " ) ; else player -> LeaveBattleground ( ) ; break ; case 3949 : if ( player -> GetTeam ( ) != HORDE ) player -> GetSession ( ) -> SendNotification ( " Only ▁ The ▁ Horde ▁ can ▁ use ▁ that ▁ portal " ) ; else player -> LeaveBattleground ( ) ; break ; case 3866 : case 3869 : case 3867 : case 3868 : case 3870 : case 4020 : case 4021 : case 4674 : default : Battleground :: HandleAreaTrigger ( player , trigger , entered ) ; break ; } } void BattlegroundAB :: _CreateBanner ( uint8 node , uint8 type , uint8 teamIndex , bool delay ) { if ( delay ) { m_BannerTimers [ node ] . timer = 2000 ; m_BannerTimers [ node ] . type = type ; m_BannerTimers [ node ] . teamIndex = teamIndex ; return ; } uint8 obj = node * 8 + type + teamIndex ; SpawnBGObject ( obj , RESPAWN_IMMEDIATELY ) ; if ( ! type ) return ; obj = node * 8 + ( ( type == BG_AB_NODE_TYPE_OCCUPIED ) ? ( 5 + teamIndex ) : 7 ) ; SpawnBGObject ( obj , RESPAWN_IMMEDIATELY ) ; } void BattlegroundAB :: _DelBanner ( uint8 node , uint8 type , uint8 teamIndex ) { uint8 obj = node * 8 + type + teamIndex ; SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; if ( ! type ) return ; obj = node * 8 + ( ( type == BG_AB_NODE_TYPE_OCCUPIED ) ? ( 5 + teamIndex ) : 7 ) ; SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; } int32 BattlegroundAB :: _GetNodeNameId ( uint8 node ) { switch ( node ) { case BG_AB_NODE_STABLES : return LANG_BG_AB_NODE_STABLES ; case BG_AB_NODE_BLACKSMITH : return LANG_BG_AB_NODE_BLACKSMITH ; case BG_AB_NODE_FARM : return LANG_BG_AB_NODE_FARM ; case BG_AB_NODE_LUMBER_MILL : return LANG_BG_AB_NODE_LUMBER_MILL ; case BG_AB_NODE_GOLD_MINE : return LANG_BG_AB_NODE_GOLD_MINE ; default : ABORT ( ) ; } return 0 ; } void BattlegroundAB :: FillInitialWorldStates ( WorldPackets :: WorldState :: InitWorldStates & packet ) { const uint8 plusArray [ ] = { 0 , 2 , 3 , 0 , 1 } ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_NODEICONS [ node ] ) , int32 ( ( m_Nodes [ node ] == 0 ) ? 1 : 0 ) ) ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) for ( uint8 i = 1 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_NODESTATES [ node ] + plusArray [ i ] ) , int32 ( ( m_Nodes [ node ] == i ) ? 1 : 0 ) ) ; uint8 ally = 0 , horde = 0 ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) if ( m_Nodes [ node ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ node ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_OCCUPIED_BASES_ALLY ) , int32 ( ally ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_OCCUPIED_BASES_HORDE ) , int32 ( horde ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_MAX ) , int32 ( BG_AB_MAX_TEAM_SCORE ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_WARNING ) , int32 ( BG_AB_WARNING_NEAR_VICTORY_SCORE ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_ALLY ) , int32 ( m_TeamScores [ TEAM_ALLIANCE ] ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_HORDE ) , int32 ( m_TeamScores [ TEAM_HORDE ] ) ) ; packet . Worldstates . emplace_back ( uint32 ( 0x745 ) , 0x2 ) ; } void BattlegroundAB :: _SendNodeUpdate ( uint8 node ) { const uint8 plusArray [ ] = { 0 , 2 , 3 , 0 , 1 } ; if ( m_prevNodes [ node ] ) UpdateWorldState ( BG_AB_OP_NODESTATES [ node ] + plusArray [ m_prevNodes [ node ] ] , 0 ) ; else UpdateWorldState ( BG_AB_OP_NODEICONS [ node ] , 0 ) ; UpdateWorldState ( BG_AB_OP_NODESTATES [ node ] + plusArray [ m_Nodes [ node ] ] , 1 ) ; uint8 ally = 0 , horde = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; UpdateWorldState ( BG_AB_OP_OCCUPIED_BASES_ALLY , ally ) ; UpdateWorldState ( BG_AB_OP_OCCUPIED_BASES_HORDE , horde ) ; } void BattlegroundAB :: _NodeOccupied ( uint8 node , Team team ) { if ( ! AddSpiritGuide ( node , BG_AB_SpiritGuidePos [ node ] , GetTeamIndexByTeamId ( team ) ) ) TC_LOG_ERROR ( " bg . battleground " , " Failed ▁ to ▁ spawn ▁ spirit ▁ guide ! ▁ point : ▁ % u , ▁ team : ▁ % u , ▁ " , node , team ) ; if ( node >= BG_AB_DYNAMIC_NODES_COUNT ) return ; uint8 capturedNodes = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == GetTeamIndexByTeamId ( team ) + BG_AB_NODE_TYPE_OCCUPIED && ! m_NodeTimers [ i ] ) ++ capturedNodes ; if ( capturedNodes >= 5 ) CastSpellOnTeam ( SPELL_AB_QUEST_REWARD_5_BASES , team ) ; if ( capturedNodes >= 4 ) CastSpellOnTeam ( SPELL_AB_QUEST_REWARD_4_BASES , team ) ; Creature * trigger = ! BgCreatures [ node + 7 ] ? GetBGCreature ( node + 7 ) : NULL ; if ( ! trigger ) trigger = AddCreature ( WORLD_TRIGGER , node + 7 , BG_AB_NodePositions [ node ] , GetTeamIndexByTeamId ( team ) ) ; if ( trigger ) { trigger -> setFaction ( team == ALLIANCE ? 84 : 83 ) ; trigger -> CastSpell ( trigger , SPELL_HONORABLE_DEFENDER_25Y , false ) ; } } void BattlegroundAB :: _NodeDeOccupied ( uint8 node ) { if ( node >= BG_AB_DYNAMIC_NODES_COUNT ) return ; if ( node < BG_AB_DYNAMIC_NODES_COUNT ) DelCreature ( node + 7 ) ; RelocateDeadPlayers ( BgCreatures [ node ] ) ; DelCreature ( node ) ; } void BattlegroundAB :: EventPlayerClickedOnFlag ( Player * source , GameObject * ) { if ( GetStatus ( ) != STATUS_IN_PROGRESS ) return ; uint8 node = BG_AB_NODE_STABLES ; GameObject * obj = GetBgMap ( ) -> GetGameObject ( BgObjects [ node * 8 + 7 ] ) ; while ( ( node < BG_AB_DYNAMIC_NODES_COUNT ) && ( ( ! obj ) || ( ! source -> IsWithinDistInMap ( obj , 10 ) ) ) ) { ++ node ; obj = GetBgMap ( ) -> GetGameObject ( BgObjects [ node * 8 + BG_AB_OBJECT_AURA_CONTESTED ] ) ; } if ( node == BG_AB_DYNAMIC_NODES_COUNT ) { return ; } TeamId teamIndex = GetTeamIndexByTeamId ( source -> GetTeam ( ) ) ; if ( ! ( m_Nodes [ node ] == 0 || teamIndex == m_Nodes [ node ] % 2 ) ) return ; source -> RemoveAurasWithInterruptFlags ( AURA_INTERRUPT_FLAG_ENTER_PVP_COMBAT ) ; uint32 sound = 0 ; if ( m_Nodes [ node ] == BG_AB_NODE_TYPE_NEUTRAL ) { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + 1 ; _DelBanner ( node , BG_AB_NODE_TYPE_NEUTRAL , 0 ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == 0 ) SendMessage2ToAll ( LANG_BG_AB_NODE_CLAIMED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) , LANG_BG_AB_ALLY ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_CLAIMED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) , LANG_BG_AB_HORDE ) ; sound = BG_AB_SOUND_NODE_CLAIMED ; } else if ( ( m_Nodes [ node ] == BG_AB_NODE_STATUS_ALLY_CONTESTED ) || ( m_Nodes [ node ] == BG_AB_NODE_STATUS_HORDE_CONTESTED ) ) { if ( m_prevNodes [ node ] < BG_AB_NODE_TYPE_OCCUPIED ) { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_CONTESTED ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; } else { UpdatePlayerScore ( source , SCORE_BASES_DEFENDED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_OCCUPIED ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = 0 ; _NodeOccupied ( node , ( teamIndex == TEAM_ALLIANCE ) ? ALLIANCE : HORDE ) ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_DEFENDED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_DEFENDED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; } sound = ( teamIndex == TEAM_ALLIANCE ) ? BG_AB_SOUND_NODE_ASSAULTED_ALLIANCE : BG_AB_SOUND_NODE_ASSAULTED_HORDE ; } else { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_CONTESTED ; _DelBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; _NodeDeOccupied ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; sound = ( teamIndex == TEAM_ALLIANCE ) ? BG_AB_SOUND_NODE_ASSAULTED_ALLIANCE : BG_AB_SOUND_NODE_ASSAULTED_HORDE ; } if ( m_Nodes [ node ] >= BG_AB_NODE_TYPE_OCCUPIED ) { if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_ALLIANCE , NULL , LANG_BG_AB_ALLY , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_HORDE , NULL , LANG_BG_AB_HORDE , _GetNodeNameId ( node ) ) ; } PlaySoundToAll ( sound ) ; } uint32 BattlegroundAB :: GetPrematureWinner ( ) { uint8 ally = 0 , horde = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; if ( ally > horde ) return ALLIANCE ; else if ( horde > ally ) return HORDE ; return Battleground :: GetPrematureWinner ( ) ; } bool BattlegroundAB :: SetupBattleground ( ) { for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { if ( ! AddObject ( BG_AB_OBJECT_BANNER_NEUTRAL + 8 * i , BG_AB_OBJECTID_NODE_BANNER_0 + i , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_CONT_A + 8 * i , BG_AB_OBJECTID_BANNER_CONT_A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_CONT_H + 8 * i , BG_AB_OBJECTID_BANNER_CONT_H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_ALLY + 8 * i , BG_AB_OBJECTID_BANNER_A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_HORDE + 8 * i , BG_AB_OBJECTID_BANNER_H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_ALLY + 8 * i , BG_AB_OBJECTID_AURA_A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_HORDE + 8 * i , BG_AB_OBJECTID_AURA_H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_CONTESTED + 8 * i , BG_AB_OBJECTID_AURA_C , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) ) { TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ some ▁ object ▁ Battleground ▁ not ▁ created ! " ) ; return false ; } } if ( ! AddObject ( BG_AB_OBJECT_GATE_A , BG_AB_OBJECTID_GATE_A , BG_AB_DoorPositions [ 0 ] [ 0 ] , BG_AB_DoorPositions [ 0 ] [ 1 ] , BG_AB_DoorPositions [ 0 ] [ 2 ] , BG_AB_DoorPositions [ 0 ] [ 3 ] , BG_AB_DoorPositions [ 0 ] [ 4 ] , BG_AB_DoorPositions [ 0 ] [ 5 ] , BG_AB_DoorPositions [ 0 ] [ 6 ] , BG_AB_DoorPositions [ 0 ] [ 7 ] , RESPAWN_IMMEDIATELY ) || ! AddObject ( BG_AB_OBJECT_GATE_H , BG_AB_OBJECTID_GATE_H , BG_AB_DoorPositions [ 1 ] [ 0 ] , BG_AB_DoorPositions [ 1 ] [ 1 ] , BG_AB_DoorPositions [ 1 ] [ 2 ] , BG_AB_DoorPositions [ 1 ] [ 3 ] , BG_AB_DoorPositions [ 1 ] [ 4 ] , BG_AB_DoorPositions [ 1 ] [ 5 ] , BG_AB_DoorPositions [ 1 ] [ 6 ] , BG_AB_DoorPositions [ 1 ] [ 7 ] , RESPAWN_IMMEDIATELY ) ) { TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ door ▁ object ▁ Battleground ▁ not ▁ created ! " ) ; return false ; } for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { if ( ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i , Buff_Entries [ 0 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i + 1 , Buff_Entries [ 1 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i + 2 , Buff_Entries [ 2 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) ) TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ buff ▁ object ! " ) ; } return true ; } void BattlegroundAB :: Reset ( ) { Battleground :: Reset ( ) ; m_TeamScores [ TEAM_ALLIANCE ] = 0 ; m_TeamScores [ TEAM_HORDE ] = 0 ; m_lastTick [ TEAM_ALLIANCE ] = 0 ; m_lastTick [ TEAM_HORDE ] = 0 ; m_HonorScoreTics [ TEAM_ALLIANCE ] = 0 ; m_HonorScoreTics [ TEAM_HORDE ] = 0 ; m_ReputationScoreTics [ TEAM_ALLIANCE ] = 0 ; m_ReputationScoreTics [ TEAM_HORDE ] = 0 ; m_IsInformedNearVictory = false ; bool isBGWeekend = sBattlegroundMgr -> IsBGWeekend ( GetTypeID ( ) ) ; m_HonorTics = ( isBGWeekend ) ? BG_AB_ABBGWeekendHonorTicks : BG_AB_NotABBGWeekendHonorTicks ; m_ReputationTics = ( isBGWeekend ) ? BG_AB_ABBGWeekendReputationTicks : BG_AB_NotABBGWeekendReputationTicks ; m_TeamScores500Disadvantage [ TEAM_ALLIANCE ] = false ; m_TeamScores500Disadvantage [ TEAM_HORDE ] = false ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { m_Nodes [ i ] = 0 ; m_prevNodes [ i ] = 0 ; m_NodeTimers [ i ] = 0 ; m_BannerTimers [ i ] . timer = 0 ; } for ( uint8 i = 0 ; i < BG_AB_ALL_NODES_COUNT + 5 ; ++ i ) if ( ! BgCreatures [ i ] . IsEmpty ( ) ) DelCreature ( i ) ; } void BattlegroundAB :: EndBattleground ( uint32 winner ) { if ( winner == ALLIANCE ) RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ALLIANCE ) ; if ( winner == HORDE ) RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , HORDE ) ; RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , HORDE ) ; RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ALLIANCE ) ; Battleground :: EndBattleground ( winner ) ; } WorldSafeLocsEntry const * BattlegroundAB :: GetClosestGraveYard ( Player * player ) { TeamId teamIndex = GetTeamIndexByTeamId ( player -> GetTeam ( ) ) ; std :: vector < uint8 > nodes ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == teamIndex + 3 ) nodes . push_back ( i ) ; WorldSafeLocsEntry const * good_entry = NULL ; if ( ! nodes . empty ( ) ) { float plr_x = player -> GetPositionX ( ) ; float plr_y = player -> GetPositionY ( ) ; float mindist = 999999.0f ; for ( uint8 i = 0 ; i < nodes . size ( ) ; ++ i ) { WorldSafeLocsEntry const * entry = sWorldSafeLocsStore . LookupEntry ( BG_AB_GraveyardIds [ nodes [ i ] ] ) ; if ( ! entry ) continue ; float dist = ( entry -> Loc . X - plr_x ) * ( entry -> Loc . X - plr_x ) + ( entry -> Loc . Y - plr_y ) * ( entry -> Loc . Y - plr_y ) ; if ( mindist > dist ) { mindist = dist ; good_entry = entry ; } } nodes . clear ( ) ; } if ( ! good_entry ) good_entry = sWorldSafeLocsStore . LookupEntry ( BG_AB_GraveyardIds [ teamIndex + 5 ] ) ; return good_entry ; } bool BattlegroundAB :: UpdatePlayerScore ( Player * player , uint32 type , uint32 value , bool doAddHonor ) { if ( ! Battleground :: UpdatePlayerScore ( player , type , value , doAddHonor ) ) return false ; switch ( type ) { case SCORE_BASES_ASSAULTED : player -> UpdateAchievementCriteria ( ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE , AB_OBJECTIVE_ASSAULT_BASE ) ; break ; case SCORE_BASES_DEFENDED : player -> UpdateAchievementCriteria ( ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE , AB_OBJECTIVE_DEFEND_BASE ) ; break ; default : break ; } return true ; } bool BattlegroundAB :: IsAllNodesControlledByTeam ( uint32 team ) const { uint32 count = 0 ; for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( ( team == ALLIANCE && m_Nodes [ i ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) || ( team == HORDE && m_Nodes [ i ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ) ++ count ; return count == BG_AB_DYNAMIC_NODES_COUNT ; } bool BattlegroundAB :: CheckAchievementCriteriaMeet ( uint32 criteriaId , Player const * player , Unit const * target , uint32 miscvalue ) { switch ( criteriaId ) { case BG_CRITERIA_CHECK_RESILIENT_VICTORY : return m_TeamScores500Disadvantage [ GetTeamIndexByTeamId ( player -> GetTeam ( ) ) ] ; } return Battleground :: CheckAchievementCriteriaMeet ( criteriaId , player , target , miscvalue ) ; } </DOCUMENT>
<DOCUMENT_ID="lassoan/CTK/tree/master/Libs/Core/ctkWorkflowStep.cpp"> # include < QDebug > # include < QMetaType > # include < QObject > # include < QState > # include " ctkWorkflowStep . h " # include " ctkWorkflowStep _ p . h " # include " ctkWorkflow . h " # include " ctkLogger . h " # include < iostream > static ctkLogger logger ( " org . commontk . core . ctkWorkflowStep " ) ; ctkWorkflowStepPrivate :: ctkWorkflowStepPrivate ( ctkWorkflowStep & object ) : q_ptr ( & object ) { qRegisterMetaType < ctkWorkflowStep * > ( " ctkWorkflowStep * " ) ; this -> Workflow = 0 ; this -> WidgetType = false ; this -> HasValidateCommand = false ; this -> HasOnEntryCommand = false ; this -> HasOnExitCommand = false ; this -> ProcessingState = new QState ( ) ; this -> ValidationState = new QState ( ) ; this -> ValidationTransition = new ctkWorkflowIntrastepTransition ( ctkWorkflowIntrastepTransition :: ValidationTransition ) ; this -> ValidationTransition -> setTargetState ( this -> ValidationState ) ; this -> ProcessingState -> addTransition ( this -> ValidationTransition ) ; this -> ValidationFailedTransition = 0 ; this -> ValidationFailedTransition = new ctkWorkflowIntrastepTransition ( ctkWorkflowIntrastepTransition :: ValidationFailedTransition ) ; this -> ValidationFailedTransition -> setTargetState ( this -> ProcessingState ) ; this -> ValidationState -> addTransition ( this -> ValidationFailedTransition ) ; } ctkWorkflowStepPrivate :: ~ ctkWorkflowStepPrivate ( ) { if ( ! this -> ValidationState . isNull ( ) ) { delete this -> ValidationState ; } if ( ! this -> ProcessingState . isNull ( ) ) { delete this -> ProcessingState ; } } void ctkWorkflowStepPrivate :: validationCompleteInternal ( bool validationResults , const QString & branchId ) const { emit validationComplete ( validationResults , branchId ) ; } void ctkWorkflowStepPrivate :: onEntryCompleteInternal ( ) const { emit onEntryComplete ( ) ; } void ctkWorkflowStepPrivate :: onExitCompleteInternal ( ) const { emit onExitComplete ( ) ; } void ctkWorkflowStepPrivate :: invokeValidateCommandInternal ( const QString & desiredBranchId ) const { emit invokeValidateCommand ( desiredBranchId ) ; } void ctkWorkflowStepPrivate :: invokeOnEntryCommandInternal ( const ctkWorkflowStep * comingFrom , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) const { emit invokeOnEntryCommand ( comingFrom , transitionType ) ; } void ctkWorkflowStepPrivate :: invokeOnExitCommandInternal ( const ctkWorkflowStep * goingTo , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) const { emit invokeOnExitCommand ( goingTo , transitionType ) ; } ctkWorkflowStep :: ctkWorkflowStep ( ) : d_ptr ( new ctkWorkflowStepPrivate ( * this ) ) { } ctkWorkflowStep :: ctkWorkflowStep ( const QString & newId ) : d_ptr ( new ctkWorkflowStepPrivate ( * this ) ) { Q_D ( ctkWorkflowStep ) ; d -> Id = newId ; } ctkWorkflowStep :: ctkWorkflowStep ( ctkWorkflowStepPrivate * pimpl , const QString & newId ) : d_ptr ( pimpl ) { Q_D ( ctkWorkflowStep ) ; d -> Id = newId ; } ctkWorkflowStep :: ~ ctkWorkflowStep ( ) { } CTK_GET_CPP ( ctkWorkflowStep , ctkWorkflow * , workflow , Workflow ) ; CTK_SET_CPP ( ctkWorkflowStep , ctkWorkflow * , setWorkflow , Workflow ) ; CTK_GET_CPP ( ctkWorkflowStep , QString , id , Id ) ; void ctkWorkflowStep :: setId ( const QString & newId ) { Q_D ( ctkWorkflowStep ) ; if ( d -> Workflow && d -> Workflow -> hasStep ( newId ) && ! this -> id ( ) . isEmpty ( ) ) { logger . error ( QString ( " ctkWorkflowStep ▁ - ▁ Failed ▁ to ▁ change ▁ id ▁ from ▁ ' %1 ' ▁ to ▁ ' %2 ' ▁ - ▁ " " Step ▁ already ▁ added ▁ to ▁ a ▁ workflow ▁ ! " ) . arg ( this -> id ( ) ) . arg ( newId ) ) ; return ; } d -> Id = newId ; } CTK_GET_CPP ( ctkWorkflowStep , QString , name , Name ) ; CTK_SET_CPP ( ctkWorkflowStep , const QString & , setName , Name ) ; CTK_GET_CPP ( ctkWorkflowStep , QString , description , Description ) ; CTK_SET_CPP ( ctkWorkflowStep , const QString & , setDescription , Description ) ; CTK_GET_CPP ( ctkWorkflowStep , QString , statusText , StatusText ) ; CTK_SET_CPP ( ctkWorkflowStep , const QString & , setStatusText , StatusText ) ; CTK_GET_CPP ( ctkWorkflowStep , bool , hasValidateCommand , HasValidateCommand ) ; CTK_SET_CPP ( ctkWorkflowStep , bool , setHasValidateCommand , HasValidateCommand ) ; CTK_GET_CPP ( ctkWorkflowStep , bool , hasOnEntryCommand , HasOnEntryCommand ) ; CTK_SET_CPP ( ctkWorkflowStep , bool , setHasOnEntryCommand , HasOnEntryCommand ) ; CTK_GET_CPP ( ctkWorkflowStep , bool , hasOnExitCommand , HasOnExitCommand ) ; CTK_SET_CPP ( ctkWorkflowStep , bool , setHasOnExitCommand , HasOnExitCommand ) ; CTK_GET_CPP ( ctkWorkflowStep , QState * , processingState , ProcessingState ) ; CTK_GET_CPP ( ctkWorkflowStep , QState * , validationState , ValidationState ) ; CTK_GET_CPP ( ctkWorkflowStep , ctkWorkflowIntrastepTransition * , validationTransition , ValidationTransition ) ; CTK_GET_CPP ( ctkWorkflowStep , ctkWorkflowIntrastepTransition * , validationFailedTransition , ValidationFailedTransition ) ; CTK_GET_CPP ( ctkWorkflowStep , bool , isWidgetType , WidgetType ) ; QObject * ctkWorkflowStep :: ctkWorkflowStepQObject ( ) { Q_D ( ctkWorkflowStep ) ; return d ; } void ctkWorkflowStep :: validationComplete ( bool validationResults , const QString & branchId ) const { Q_D ( const ctkWorkflowStep ) ; d -> validationCompleteInternal ( validationResults , branchId ) ; } void ctkWorkflowStep :: onEntryComplete ( ) const { Q_D ( const ctkWorkflowStep ) ; d -> onEntryCompleteInternal ( ) ; } void ctkWorkflowStep :: onExitComplete ( ) const { Q_D ( const ctkWorkflowStep ) ; d -> onExitCompleteInternal ( ) ; } void ctkWorkflowStep :: invokeValidateCommand ( const QString & desiredBranchId ) const { Q_D ( const ctkWorkflowStep ) ; d -> invokeValidateCommandInternal ( desiredBranchId ) ; } void ctkWorkflowStep :: invokeOnEntryCommand ( const ctkWorkflowStep * comingFrom , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) const { Q_D ( const ctkWorkflowStep ) ; d -> invokeOnEntryCommandInternal ( comingFrom , transitionType ) ; } void ctkWorkflowStep :: invokeOnExitCommand ( const ctkWorkflowStep * goingTo , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) const { Q_D ( const ctkWorkflowStep ) ; d -> invokeOnExitCommandInternal ( goingTo , transitionType ) ; } void ctkWorkflowStep :: validate ( const QString & desiredBranchId ) { Q_D ( ctkWorkflowStep ) ; logger . info ( QString ( " validate ▁ - ▁ validating ▁ the ▁ input ▁ from ▁ % 1" ) . arg ( d -> Name ) ) ; this -> validationComplete ( true , desiredBranchId ) ; } void ctkWorkflowStep :: onEntry ( const ctkWorkflowStep * comingFrom , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) { Q_UNUSED ( comingFrom ) ; Q_UNUSED ( transitionType ) ; this -> onEntryComplete ( ) ; } void ctkWorkflowStep :: onExit ( const ctkWorkflowStep * goingTo , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) { Q_UNUSED ( goingTo ) ; Q_UNUSED ( transitionType ) ; this -> onExitComplete ( ) ; } </DOCUMENT>
<DOCUMENT_ID="SuslikV/obs-studio/tree/master/plugins/win-capture/graphics-hook/d3d9-capture.cpp"> # define _CRT_SECURE_NO_WARNINGS # include < d3d9 . h > # include < d3d11 . h > # include < dxgi . h > # include " graphics - hook . h " # include " . . / funchook . h " # include " d3d9 - patches . hpp " typedef HRESULT ( STDMETHODCALLTYPE * present_t ) ( IDirect3DDevice9 * , CONST RECT * , CONST RECT * , HWND , CONST RGNDATA * ) ; typedef HRESULT ( STDMETHODCALLTYPE * present_ex_t ) ( IDirect3DDevice9 * , CONST RECT * , CONST RECT * , HWND , CONST RGNDATA * , DWORD ) ; typedef HRESULT ( STDMETHODCALLTYPE * present_swap_t ) ( IDirect3DSwapChain9 * , CONST RECT * , CONST RECT * , HWND , CONST RGNDATA * , DWORD ) ; typedef HRESULT ( STDMETHODCALLTYPE * reset_t ) ( IDirect3DDevice9 * , D3DPRESENT_PARAMETERS * ) ; typedef HRESULT ( STDMETHODCALLTYPE * reset_ex_t ) ( IDirect3DDevice9 * , D3DPRESENT_PARAMETERS * , D3DDISPLAYMODEEX * ) ; typedef HRESULT ( WINAPI * createfactory1_t ) ( REFIID , void * * ) ; static struct func_hook present ; static struct func_hook present_ex ; static struct func_hook present_swap ; static struct func_hook reset ; static struct func_hook reset_ex ; struct d3d9_data { HMODULE d3d9 ; IDirect3DDevice9 * device ; uint32_t cx ; uint32_t cy ; D3DFORMAT d3d9_format ; DXGI_FORMAT dxgi_format ; bool using_shtex : 1 ; bool using_scale : 1 ; volatile bool issued_queries [ NUM_BUFFERS ] ; union { struct { IDirect3DSurface9 * d3d9_copytex ; ID3D11Device * d3d11_device ; ID3D11DeviceContext * d3d11_context ; ID3D11Resource * d3d11_tex ; struct shtex_data * shtex_info ; HANDLE handle ; int patch ; } ; struct { IDirect3DSurface9 * copy_surfaces [ NUM_BUFFERS ] ; IDirect3DSurface9 * render_targets [ NUM_BUFFERS ] ; IDirect3DQuery9 * queries [ NUM_BUFFERS ] ; struct shmem_data * shmem_info ; bool texture_mapped [ NUM_BUFFERS ] ; uint32_t pitch ; int cur_tex ; int copy_wait ; } ; } ; } ; static struct d3d9_data data = { } ; static void d3d9_free ( ) { capture_free ( ) ; if ( data . using_shtex ) { if ( data . d3d11_tex ) data . d3d11_tex -> Release ( ) ; if ( data . d3d11_context ) data . d3d11_context -> Release ( ) ; if ( data . d3d11_device ) data . d3d11_device -> Release ( ) ; if ( data . d3d9_copytex ) data . d3d9_copytex -> Release ( ) ; } else { for ( size_t i = 0 ; i < NUM_BUFFERS ; i ++ ) { if ( data . copy_surfaces [ i ] ) { if ( data . texture_mapped [ i ] ) data . copy_surfaces [ i ] -> UnlockRect ( ) ; data . copy_surfaces [ i ] -> Release ( ) ; } if ( data . render_targets [ i ] ) data . render_targets [ i ] -> Release ( ) ; if ( data . queries [ i ] ) data . queries [ i ] -> Release ( ) ; } } memset ( & data , 0 , sizeof ( data ) ) ; hlog ( " - - - - - - - - - - - - - - - - - ▁ d3d9 ▁ capture ▁ freed ▁ - - - - - - - - - - - - - - - - - " ) ; } static DXGI_FORMAT d3d9_to_dxgi_format ( D3DFORMAT format ) { switch ( ( unsigned long ) format ) { case D3DFMT_A2B10G10R10 : return DXGI_FORMAT_R10G10B10A2_UNORM ; case D3DFMT_A8R8G8B8 : return DXGI_FORMAT_B8G8R8A8_UNORM ; case D3DFMT_X8R8G8B8 : return DXGI_FORMAT_B8G8R8X8_UNORM ; } return DXGI_FORMAT_UNKNOWN ; } const static D3D_FEATURE_LEVEL feature_levels [ ] = { D3D_FEATURE_LEVEL_11_0 , D3D_FEATURE_LEVEL_10_1 , D3D_FEATURE_LEVEL_10_0 , D3D_FEATURE_LEVEL_9_3 , } ; static inline bool shex_init_d3d11 ( ) { PFN_D3D11_CREATE_DEVICE create_device ; createfactory1_t create_factory ; D3D_FEATURE_LEVEL level_used ; IDXGIFactory * factory ; IDXGIAdapter * adapter ; HMODULE d3d11 ; HMODULE dxgi ; HRESULT hr ; d3d11 = load_system_library ( " d3d11 . dll " ) ; if ( ! d3d11 ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ load ▁ D3D11" ) ; return false ; } dxgi = load_system_library ( " dxgi . dll " ) ; if ( ! dxgi ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ load ▁ DXGI " ) ; return false ; } create_factory = ( createfactory1_t ) GetProcAddress ( dxgi , " CreateDXGIFactory1" ) ; if ( ! create_factory ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ get ▁ CreateDXGIFactory1 ▁ address " ) ; return false ; } create_device = ( PFN_D3D11_CREATE_DEVICE ) GetProcAddress ( d3d11 , " D3D11CreateDevice " ) ; if ( ! create_device ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ get ▁ D3D11CreateDevice ▁ address " ) ; return false ; } hr = create_factory ( __uuidof ( IDXGIFactory1 ) , ( void * * ) & factory ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init : ▁ Failed ▁ to ▁ create ▁ factory ▁ object " , hr ) ; return false ; } hr = factory -> EnumAdapters ( 0 , & adapter ) ; factory -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init : ▁ Failed ▁ to ▁ get ▁ adapter " , hr ) ; return false ; } hr = create_device ( adapter , D3D_DRIVER_TYPE_UNKNOWN , nullptr , 0 , feature_levels , sizeof ( feature_levels ) / sizeof ( D3D_FEATURE_LEVEL ) , D3D11_SDK_VERSION , & data . d3d11_device , & level_used , & data . d3d11_context ) ; adapter -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init : ▁ Failed ▁ to ▁ create ▁ D3D11 ▁ device " , hr ) ; return false ; } return true ; } static inline bool d3d9_shtex_init_shtex ( ) { IDXGIResource * res ; HRESULT hr ; D3D11_TEXTURE2D_DESC desc = { } ; desc . Width = data . cx ; desc . Height = data . cy ; desc . Format = data . dxgi_format ; desc . MipLevels = 1 ; desc . ArraySize = 1 ; desc . SampleDesc . Count = 1 ; desc . Usage = D3D11_USAGE_DEFAULT ; desc . MiscFlags = D3D11_RESOURCE_MISC_SHARED ; desc . BindFlags = D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE ; hr = data . d3d11_device -> CreateTexture2D ( & desc , nullptr , ( ID3D11Texture2D * * ) & data . d3d11_tex ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ shtex : ▁ Failed ▁ to ▁ create ▁ D3D11 ▁ texture " , hr ) ; return false ; } hr = data . d3d11_tex -> QueryInterface ( __uuidof ( IDXGIResource ) , ( void * * ) & res ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ shtex : ▁ Failed ▁ to ▁ query ▁ IDXGIResource " , hr ) ; return false ; } hr = res -> GetSharedHandle ( & data . handle ) ; res -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ shtex : ▁ Failed ▁ to ▁ get ▁ shared ▁ handle " , hr ) ; return false ; } return true ; } static inline bool d3d9_shtex_init_copytex ( ) { uint8_t * patch_addr = get_d3d9_patch_addr ( data . d3d9 , data . patch ) ; uint8_t saved_data [ MAX_PATCH_SIZE ] ; size_t patch_size = 0 ; IDirect3DTexture9 * tex ; DWORD protect_val ; HRESULT hr ; if ( patch_addr ) { patch_size = patch [ data . patch ] . size ; VirtualProtect ( patch_addr , patch_size , PAGE_EXECUTE_READWRITE , & protect_val ) ; memcpy ( saved_data , patch_addr , patch_size ) ; memcpy ( patch_addr , patch [ data . patch ] . data , patch_size ) ; } hr = data . device -> CreateTexture ( data . cx , data . cy , 1 , D3DUSAGE_RENDERTARGET , data . d3d9_format , D3DPOOL_DEFAULT , & tex , & data . handle ) ; if ( patch_addr && patch_size ) { memcpy ( patch_addr , saved_data , patch_size ) ; VirtualProtect ( patch_addr , patch_size , protect_val , & protect_val ) ; } if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ copytex : ▁ Failed ▁ to ▁ create ▁ shared ▁ texture " , hr ) ; return false ; } hr = tex -> GetSurfaceLevel ( 0 , & data . d3d9_copytex ) ; tex -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ copytex : ▁ Failed ▁ to ▁ get ▁ surface ▁ level " , hr ) ; return false ; } return true ; } static bool d3d9_shtex_init ( uint32_t cx , uint32_t cy , HWND window ) { data . using_shtex = true ; if ( ! shex_init_d3d11 ( ) ) { return false ; } if ( ! d3d9_shtex_init_shtex ( ) ) { return false ; } if ( ! d3d9_shtex_init_copytex ( ) ) { return false ; } if ( ! capture_init_shtex ( & data . shtex_info , window , cx , cy , data . cx , data . cy , data . dxgi_format , false , ( uintptr_t ) data . handle ) ) { return false ; } hlog ( " d3d9 ▁ shared ▁ texture ▁ capture ▁ successful " ) ; return true ; } static bool d3d9_shmem_init_buffers ( size_t buffer ) { HRESULT hr ; hr = data . device -> CreateOffscreenPlainSurface ( data . cx , data . cy , data . d3d9_format , D3DPOOL_SYSTEMMEM , & data . copy_surfaces [ buffer ] , nullptr ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ create ▁ surface " , hr ) ; return false ; } if ( buffer == 0 ) { D3DLOCKED_RECT rect ; hr = data . copy_surfaces [ buffer ] -> LockRect ( & rect , nullptr , D3DLOCK_READONLY ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ lock ▁ " " buffer " , hr ) ; return false ; } data . pitch = rect . Pitch ; data . copy_surfaces [ buffer ] -> UnlockRect ( ) ; } hr = data . device -> CreateRenderTarget ( data . cx , data . cy , data . d3d9_format , D3DMULTISAMPLE_NONE , 0 , false , & data . render_targets [ buffer ] , nullptr ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ create ▁ render ▁ " " target " , hr ) ; return false ; } hr = data . device -> CreateQuery ( D3DQUERYTYPE_EVENT , & data . queries [ buffer ] ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ create ▁ query " , hr ) ; return false ; } return true ; } static bool d3d9_shmem_init ( uint32_t cx , uint32_t cy , HWND window ) { data . using_shtex = false ; for ( size_t i = 0 ; i < NUM_BUFFERS ; i ++ ) { if ( ! d3d9_shmem_init_buffers ( i ) ) { return false ; } } if ( ! capture_init_shmem ( & data . shmem_info , window , cx , cy , data . cx , data . cy , data . pitch , data . dxgi_format , false ) ) { return false ; } hlog ( " d3d9 ▁ memory ▁ capture ▁ successful " ) ; return true ; } static bool d3d9_get_swap_desc ( D3DPRESENT_PARAMETERS & pp ) { IDirect3DSwapChain9 * swap = nullptr ; HRESULT hr ; hr = data . device -> GetSwapChain ( 0 , & swap ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ get _ swap _ desc : ▁ Failed ▁ to ▁ get ▁ swap ▁ chain " , hr ) ; return false ; } hr = swap -> GetPresentParameters ( & pp ) ; swap -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ get _ swap _ desc : ▁ Failed ▁ to ▁ get ▁ " " presentation ▁ parameters " , hr ) ; return false ; } return true ; } static bool d3d9_init_format_backbuffer ( uint32_t & cx , uint32_t & cy , HWND & window ) { IDirect3DSurface9 * back_buffer = nullptr ; D3DPRESENT_PARAMETERS pp ; D3DSURFACE_DESC desc ; HRESULT hr ; if ( ! d3d9_get_swap_desc ( pp ) ) { return false ; } hr = data . device -> GetRenderTarget ( 0 , & back_buffer ) ; if ( FAILED ( hr ) ) { return false ; } hr = back_buffer -> GetDesc ( & desc ) ; back_buffer -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init _ format _ backbuffer : ▁ Failed ▁ to ▁ get ▁ " " backbuffer ▁ descriptor " , hr ) ; return false ; } data . d3d9_format = desc . Format ; data . dxgi_format = d3d9_to_dxgi_format ( desc . Format ) ; data . using_scale = global_hook_info -> use_scale ; window = pp . hDeviceWindow ; cx = desc . Width ; cy = desc . Height ; if ( data . using_scale ) { data . cx = global_hook_info -> cx ; data . cy = global_hook_info -> cy ; } else { data . cx = desc . Width ; data . cy = desc . Height ; } return true ; } static bool d3d9_init_format_swapchain ( uint32_t & cx , uint32_t & cy , HWND & window ) { D3DPRESENT_PARAMETERS pp ; if ( ! d3d9_get_swap_desc ( pp ) ) { return false ; } data . dxgi_format = d3d9_to_dxgi_format ( pp . BackBufferFormat ) ; data . d3d9_format = pp . BackBufferFormat ; data . using_scale = global_hook_info -> use_scale ; window = pp . hDeviceWindow ; cx = pp . BackBufferWidth ; cy = pp . BackBufferHeight ; if ( data . using_scale ) { data . cx = global_hook_info -> cx ; data . cy = global_hook_info -> cy ; } else { data . cx = pp . BackBufferWidth ; data . cy = pp . BackBufferHeight ; } return true ; } static void d3d9_init ( IDirect3DDevice9 * device ) { IDirect3DDevice9Ex * d3d9ex = nullptr ; bool success ; uint32_t cx = 0 ; uint32_t cy = 0 ; HWND window = nullptr ; HRESULT hr ; data . d3d9 = get_system_module ( " d3d9 . dll " ) ; data . device = device ; hr = device -> QueryInterface ( __uuidof ( IDirect3DDevice9Ex ) , ( void * * ) & d3d9ex ) ; if ( SUCCEEDED ( hr ) ) { d3d9ex -> Release ( ) ; data . patch = - 1 ; } else { data . patch = get_d3d9_patch ( data . d3d9 ) ; } if ( ! d3d9_init_format_backbuffer ( cx , cy , window ) ) { if ( ! d3d9_init_format_swapchain ( cx , cy , window ) ) { return ; } } if ( global_hook_info -> force_shmem || ( ! d3d9ex && data . patch == - 1 ) ) { success = d3d9_shmem_init ( cx , cy , window ) ; } else { success = d3d9_shtex_init ( cx , cy , window ) ; } if ( ! success ) d3d9_free ( ) ; } static inline HRESULT get_backbuffer ( IDirect3DDevice9 * device , IDirect3DSurface9 * * surface ) { static bool use_backbuffer = false ; static bool checked_exceptions = false ; if ( ! checked_exceptions ) { if ( _strcmpi ( get_process_name ( ) , " hotd _ ng . exe " ) == 0 ) use_backbuffer = true ; checked_exceptions = true ; } if ( use_backbuffer ) { return device -> GetBackBuffer ( 0 , 0 , D3DBACKBUFFER_TYPE_MONO , surface ) ; } else { return device -> GetRenderTarget ( 0 , surface ) ; } } static inline void d3d9_shtex_capture ( IDirect3DSurface9 * backbuffer ) { D3DTEXTUREFILTERTYPE filter ; HRESULT hr ; filter = data . using_scale ? D3DTEXF_LINEAR : D3DTEXF_NONE ; hr = data . device -> StretchRect ( backbuffer , nullptr , data . d3d9_copytex , nullptr , filter ) ; if ( FAILED ( hr ) ) hlog_hr ( " d3d9 _ shtex _ capture : ▁ StretchRect ▁ failed " , hr ) ; } static inline void d3d9_shmem_capture_queue_copy ( ) { for ( int i = 0 ; i < NUM_BUFFERS ; i ++ ) { IDirect3DSurface9 * target = data . copy_surfaces [ i ] ; D3DLOCKED_RECT rect ; HRESULT hr ; if ( ! data . issued_queries [ i ] ) { continue ; } if ( data . queries [ i ] -> GetData ( 0 , 0 , 0 ) != S_OK ) { continue ; } data . issued_queries [ i ] = false ; hr = target -> LockRect ( & rect , nullptr , D3DLOCK_READONLY ) ; if ( SUCCEEDED ( hr ) ) { data . texture_mapped [ i ] = true ; shmem_copy_data ( i , rect . pBits ) ; } break ; } } static inline void d3d9_shmem_capture ( IDirect3DSurface9 * backbuffer ) { D3DTEXTUREFILTERTYPE filter ; IDirect3DSurface9 * copy ; int next_tex ; HRESULT hr ; d3d9_shmem_capture_queue_copy ( ) ; next_tex = ( data . cur_tex == NUM_BUFFERS - 1 ) ? 0 : data . cur_tex + 1 ; filter = data . using_scale ? D3DTEXF_LINEAR : D3DTEXF_NONE ; copy = data . render_targets [ data . cur_tex ] ; hr = data . device -> StretchRect ( backbuffer , nullptr , copy , nullptr , filter ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ capture : ▁ StretchRect ▁ failed " , hr ) ; return ; } if ( data . copy_wait < NUM_BUFFERS - 1 ) { data . copy_wait ++ ; } else { IDirect3DSurface9 * src = data . render_targets [ next_tex ] ; IDirect3DSurface9 * dst = data . copy_surfaces [ next_tex ] ; if ( shmem_texture_data_lock ( next_tex ) ) { dst -> UnlockRect ( ) ; data . texture_mapped [ next_tex ] = false ; shmem_texture_data_unlock ( next_tex ) ; } hr = data . device -> GetRenderTargetData ( src , dst ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ capture : ▁ GetRenderTargetData ▁ " " failed " , hr ) ; } data . queries [ next_tex ] -> Issue ( D3DISSUE_END ) ; data . issued_queries [ next_tex ] = true ; } data . cur_tex = next_tex ; } static void d3d9_capture ( IDirect3DDevice9 * device , IDirect3DSurface9 * backbuffer ) { if ( capture_should_stop ( ) ) { d3d9_free ( ) ; } if ( capture_should_init ( ) ) { d3d9_init ( device ) ; } if ( capture_ready ( ) ) { if ( data . using_shtex ) d3d9_shtex_capture ( backbuffer ) ; else d3d9_shmem_capture ( backbuffer ) ; } } static int present_recurse = 0 ; static inline void present_begin ( IDirect3DDevice9 * device , IDirect3DSurface9 * & backbuffer ) { HRESULT hr ; if ( ! present_recurse ) { hr = get_backbuffer ( device , & backbuffer ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ capture : ▁ Failed ▁ to ▁ get ▁ " " backbuffer " , hr ) ; } if ( ! global_hook_info -> capture_overlay ) { d3d9_capture ( device , backbuffer ) ; } } present_recurse ++ ; } static inline void present_end ( IDirect3DDevice9 * device , IDirect3DSurface9 * backbuffer ) { present_recurse -- ; if ( ! present_recurse ) { if ( global_hook_info -> capture_overlay ) { if ( ! present_recurse ) d3d9_capture ( device , backbuffer ) ; } if ( backbuffer ) backbuffer -> Release ( ) ; } } static bool hooked_reset = false ; static void setup_reset_hooks ( IDirect3DDevice9 * device ) ; static HRESULT STDMETHODCALLTYPE hook_present ( IDirect3DDevice9 * device , CONST RECT * src_rect , CONST RECT * dst_rect , HWND override_window , CONST RGNDATA * dirty_region ) { IDirect3DSurface9 * backbuffer = nullptr ; HRESULT hr ; if ( ! hooked_reset ) setup_reset_hooks ( device ) ; present_begin ( device , backbuffer ) ; unhook ( & present ) ; present_t call = ( present_t ) present . call_addr ; hr = call ( device , src_rect , dst_rect , override_window , dirty_region ) ; rehook ( & present ) ; present_end ( device , backbuffer ) ; return hr ; } static HRESULT STDMETHODCALLTYPE hook_present_ex ( IDirect3DDevice9 * device , CONST RECT * src_rect , CONST RECT * dst_rect , HWND override_window , CONST RGNDATA * dirty_region , DWORD flags ) { IDirect3DSurface9 * backbuffer = nullptr ; HRESULT hr ; if ( ! hooked_reset ) setup_reset_hooks ( device ) ; present_begin ( device , backbuffer ) ; unhook ( & present_ex ) ; present_ex_t call = ( present_ex_t ) present_ex . call_addr ; hr = call ( device , src_rect , dst_rect , override_window , dirty_region , flags ) ; rehook ( & present_ex ) ; present_end ( device , backbuffer ) ; return hr ; } static HRESULT STDMETHODCALLTYPE hook_present_swap ( IDirect3DSwapChain9 * swap , CONST RECT * src_rect , CONST RECT * dst_rect , HWND override_window , CONST RGNDATA * dirty_region , DWORD flags ) { IDirect3DSurface9 * backbuffer = nullptr ; IDirect3DDevice9 * device = nullptr ; HRESULT hr ; if ( ! present_recurse ) { hr = swap -> GetDevice ( & device ) ; if ( SUCCEEDED ( hr ) ) { device -> Release ( ) ; } } if ( device ) { if ( ! hooked_reset ) setup_reset_hooks ( device ) ; present_begin ( device , backbuffer ) ; } unhook ( & present_swap ) ; present_swap_t call = ( present_swap_t ) present_swap . call_addr ; hr = call ( swap , src_rect , dst_rect , override_window , dirty_region , flags ) ; rehook ( & present_swap ) ; if ( device ) present_end ( device , backbuffer ) ; return hr ; } static HRESULT STDMETHODCALLTYPE hook_reset ( IDirect3DDevice9 * device , D3DPRESENT_PARAMETERS * params ) { HRESULT hr ; if ( capture_active ( ) ) d3d9_free ( ) ; unhook ( & reset ) ; reset_t call = ( reset_t ) reset . call_addr ; hr = call ( device , params ) ; rehook ( & reset ) ; return hr ; } static HRESULT STDMETHODCALLTYPE hook_reset_ex ( IDirect3DDevice9 * device , D3DPRESENT_PARAMETERS * params , D3DDISPLAYMODEEX * dmex ) { HRESULT hr ; if ( capture_active ( ) ) d3d9_free ( ) ; unhook ( & reset_ex ) ; reset_ex_t call = ( reset_ex_t ) reset_ex . call_addr ; hr = call ( device , params , dmex ) ; rehook ( & reset_ex ) ; return hr ; } static void setup_reset_hooks ( IDirect3DDevice9 * device ) { IDirect3DDevice9Ex * d3d9ex = nullptr ; uintptr_t * vtable = * ( uintptr_t * * ) device ; HRESULT hr ; hook_init ( & reset , ( void * ) vtable [ 16 ] , ( void * ) hook_reset , " IDirect3DDevice9 : : Reset " ) ; rehook ( & reset ) ; hr = device -> QueryInterface ( __uuidof ( IDirect3DDevice9Ex ) , ( void * * ) & d3d9ex ) ; if ( SUCCEEDED ( hr ) ) { hook_init ( & reset_ex , ( void * ) vtable [ 132 ] , ( void * ) hook_reset_ex , " IDirect3DDevice9Ex : : ResetEx " ) ; rehook ( & reset_ex ) ; d3d9ex -> Release ( ) ; } hooked_reset = true ; } typedef HRESULT ( WINAPI * d3d9create_ex_t ) ( UINT , IDirect3D9Ex * * ) ; static bool manually_get_d3d9_addrs ( HMODULE d3d9_module , void * * present_addr , void * * present_ex_addr , void * * present_swap_addr ) { d3d9create_ex_t create_ex ; D3DPRESENT_PARAMETERS pp ; HRESULT hr ; IDirect3DDevice9Ex * device ; IDirect3D9Ex * d3d9ex ; hlog ( " D3D9 ▁ values ▁ invalid , ▁ manually ▁ obtaining " ) ; create_ex = ( d3d9create_ex_t ) GetProcAddress ( d3d9_module , " Direct3DCreate9Ex " ) ; if ( ! create_ex ) { hlog ( " Failed ▁ to ▁ load ▁ Direct3DCreate9Ex " ) ; return false ; } if ( FAILED ( create_ex ( D3D_SDK_VERSION , & d3d9ex ) ) ) { hlog ( " Failed ▁ to ▁ create ▁ D3D9 ▁ context " ) ; return false ; } memset ( & pp , 0 , sizeof ( pp ) ) ; pp . Windowed = 1 ; pp . SwapEffect = D3DSWAPEFFECT_FLIP ; pp . BackBufferFormat = D3DFMT_A8R8G8B8 ; pp . BackBufferCount = 1 ; pp . hDeviceWindow = ( HWND ) dummy_window ; pp . PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE ; hr = d3d9ex -> CreateDeviceEx ( D3DADAPTER_DEFAULT , D3DDEVTYPE_HAL , dummy_window , D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_NOWINDOWCHANGES , & pp , NULL , & device ) ; d3d9ex -> Release ( ) ; if ( SUCCEEDED ( hr ) ) { uintptr_t * vtable = * ( uintptr_t * * ) device ; IDirect3DSwapChain9 * swap ; * present_addr = ( void * ) vtable [ 17 ] ; * present_ex_addr = ( void * ) vtable [ 121 ] ; hr = device -> GetSwapChain ( 0 , & swap ) ; if ( SUCCEEDED ( hr ) ) { vtable = * ( uintptr_t * * ) swap ; * present_swap_addr = ( void * ) vtable [ 3 ] ; swap -> Release ( ) ; } device -> Release ( ) ; } else { hlog ( " Failed ▁ to ▁ create ▁ D3D9 ▁ device " ) ; return false ; } return true ; } bool hook_d3d9 ( void ) { HMODULE d3d9_module = get_system_module ( " d3d9 . dll " ) ; uint32_t d3d9_size ; void * present_addr = nullptr ; void * present_ex_addr = nullptr ; void * present_swap_addr = nullptr ; if ( ! d3d9_module ) { return false ; } d3d9_size = module_size ( d3d9_module ) ; if ( global_hook_info -> offsets . d3d9 . present < d3d9_size && global_hook_info -> offsets . d3d9 . present_ex < d3d9_size && global_hook_info -> offsets . d3d9 . present_swap < d3d9_size ) { present_addr = get_offset_addr ( d3d9_module , global_hook_info -> offsets . d3d9 . present ) ; present_ex_addr = get_offset_addr ( d3d9_module , global_hook_info -> offsets . d3d9 . present_ex ) ; present_swap_addr = get_offset_addr ( d3d9_module , global_hook_info -> offsets . d3d9 . present_swap ) ; } else { if ( ! dummy_window ) { return false ; } if ( ! manually_get_d3d9_addrs ( d3d9_module , & present_addr , & present_ex_addr , & present_swap_addr ) ) { hlog ( " Failed ▁ to ▁ get ▁ D3D9 ▁ values " ) ; return true ; } } if ( ! present_addr && ! present_ex_addr && ! present_swap_addr ) { hlog ( " Invalid ▁ D3D9 ▁ values " ) ; return true ; } if ( present_swap_addr ) { hook_init ( & present_swap , present_swap_addr , ( void * ) hook_present_swap , " IDirect3DSwapChain9 : : Present " ) ; rehook ( & present_swap ) ; } if ( present_ex_addr ) { hook_init ( & present_ex , present_ex_addr , ( void * ) hook_present_ex , " IDirect3DDevice9Ex : : PresentEx " ) ; rehook ( & present_ex ) ; } if ( present_addr ) { hook_init ( & present , present_addr , ( void * ) hook_present , " IDirect3DDevice9 : : Present " ) ; rehook ( & present ) ; } hlog ( " Hooked ▁ D3D9" ) ; return true ; } </DOCUMENT>
<DOCUMENT_ID="uwafsl/ardupilot/tree/master/libraries/AP_HAL_Linux/Util.cpp"> # include < AP_HAL / AP_HAL . h > # if CONFIG_HAL_BOARD == HAL_BOARD_LINUX # include < stdio . h > # include < stdarg . h > # include < sys / stat . h > # include < unistd . h > # include < stdlib . h > # include < errno . h > # include < time . h > # include < fcntl . h > extern const AP_HAL :: HAL & hal ; # include " ToneAlarm _ Raspilot . h " # include " Util . h " # include " Heat _ Pwm . h " using namespace Linux ; static int state ; # if CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_RASPILOT ToneAlarm_Raspilot Util :: _toneAlarm ; # else ToneAlarm Util :: _toneAlarm ; # endif void Util :: init ( int argc , char * const * argv ) { saved_argc = argc ; saved_argv = argv ; # ifdef HAL_UTILS_HEAT # if HAL_UTILS_HEAT == HAL_LINUX_HEAT_PWM _heat = new Linux :: HeatPwm ( HAL_LINUX_HEAT_PWM_NUM , HAL_LINUX_HEAT_KP , HAL_LINUX_HEAT_KI , HAL_LINUX_HEAT_PERIOD_NS , HAL_LINUX_HEAT_TARGET_TEMP ) ; # else # error Unrecognized Heat # endif # else _heat = new Linux :: Heat ( ) ; # endif } void Util :: set_imu_temp ( float current ) { _heat -> set_imu_temp ( current ) ; } void Util :: commandline_arguments ( uint8_t & argc , char * const * & argv ) { argc = saved_argc ; argv = saved_argv ; } bool Util :: toneAlarm_init ( ) { return _toneAlarm . init ( ) ; } void Util :: toneAlarm_set_tune ( uint8_t tone ) { _toneAlarm . set_tune ( tone ) ; } void Util :: _toneAlarm_timer_tick ( ) { if ( state == 0 ) { state = state + _toneAlarm . init_tune ( ) ; } else if ( state == 1 ) { state = state + _toneAlarm . set_note ( ) ; } if ( state == 2 ) { state = state + _toneAlarm . play ( ) ; } else if ( state == 3 ) { state = 1 ; } if ( _toneAlarm . is_tune_comp ( ) ) { state = 0 ; } } void Util :: set_system_clock ( uint64_t time_utc_usec ) { # if CONFIG_HAL_BOARD_SUBTYPE != HAL_BOARD_SUBTYPE_LINUX_NONE timespec ts ; ts . tv_sec = time_utc_usec / 1.0e6 ; ts . tv_nsec = ( time_utc_usec % 1000000 ) * 1000 ; clock_settime ( CLOCK_REALTIME , & ts ) ; # endif } bool Util :: is_chardev_node ( const char * path ) { struct stat st ; if ( ! path || lstat ( path , & st ) < 0 ) return false ; return S_ISCHR ( st . st_mode ) ; } uint32_t Util :: available_memory ( void ) { return 256 * 1024 ; } int Util :: write_file ( const char * path , const char * fmt , ... ) { errno = 0 ; int fd = :: open ( path , O_WRONLY | O_CLOEXEC ) ; if ( fd == - 1 ) { return - errno ; } va_list args ; va_start ( args , fmt ) ; int ret = :: vdprintf ( fd , fmt , args ) ; int errno_bkp = errno ; :: close ( fd ) ; va_end ( args ) ; if ( ret < 1 ) { return - errno_bkp ; } return ret ; } int Util :: read_file ( const char * path , const char * fmt , ... ) { errno = 0 ; FILE * file = :: fopen ( path , " re " ) ; if ( ! file ) return - errno ; va_list args ; va_start ( args , fmt ) ; int ret = :: vfscanf ( file , fmt , args ) ; int errno_bkp = errno ; :: fclose ( file ) ; va_end ( args ) ; if ( ret < 1 ) return - errno_bkp ; return ret ; } const char * Linux :: Util :: _hw_names [ UTIL_NUM_HARDWARES ] = { [ UTIL_HARDWARE_RPI1 ] = " BCM2708" , [ UTIL_HARDWARE_RPI2 ] = " BCM2709" , [ UTIL_HARDWARE_BEBOP ] = " Mykonos3 ▁ board " , [ UTIL_HARDWARE_BEBOP2 ] = " Milos ▁ board " , } ; # define MAX_SIZE_LINE 50 int Util :: get_hw_arm32 ( ) { int ret = - ENOENT ; char buffer [ MAX_SIZE_LINE ] ; const char * hardware_description_entry = " Hardware " ; char * flag ; FILE * f ; f = fopen ( " / proc / cpuinfo " , " r " ) ; if ( f == NULL ) { ret = - errno ; goto end ; } while ( fgets ( buffer , MAX_SIZE_LINE , f ) != NULL ) { flag = strstr ( buffer , hardware_description_entry ) ; if ( flag != NULL ) { for ( uint8_t i = 0 ; i < UTIL_NUM_HARDWARES ; i ++ ) { if ( strstr ( buffer , _hw_names [ i ] ) != 0 ) { ret = i ; goto close_end ; } } } } close_end : fclose ( f ) ; end : return ret ; } # endif </DOCUMENT>
<DOCUMENT_ID="geocool/libtmx-parser/tree/master/src/tmxparser.cpp"> # include " tmxparser . h " # include " base64 . h " # if ( defined ( _WIN32 ) ) # include < string . h > # endif # if ( ( defined ( ANDROID ) ) ) # include < android / log . h > # include < string . h > # else # include < cstdlib > # include < cstdio > # endif # include < algorithm > # include < string > # include < sstream > # ifndef LOG_TAG # define LOG_TAG " libtmxparser " # endif # if defined ( WIN32 ) || defined ( _WIN32 ) # define PATH_SEPARATOR " \\ " # define PATH_SEPARATOR_ALT " / " # else # define PATH_SEPARATOR " / " # define PATH_SEPARATOR_ALT " / " # endif # define QUOTEME_ ( x ) # x # define QUOTEME ( x ) QUOTEME_ ( x ) # define WHERESTR " [ file ▁ % s , ▁ line ▁ % d ] : ▁ " # define WHEREARG __FILE__ , __LINE__ # if ( ( defined ( ANDROID ) ) ) # ifdef DEBUG # define LOGD ( ... ) __android_log_print ( ANDROID_LOG_DEBUG , LOG_TAG , " ▁ ( " __FILE__ " : " QUOTEME ( __LINE__ ) " ) ▁ " __VA_ARGS__ ) # else # define LOGD ( ... ) # endif # define LOGI ( ... ) __android_log_print ( ANDROID_LOG_INFO , LOG_TAG , " " __VA_ARGS__ ) # define LOGE ( ... ) __android_log_print ( ANDROID_LOG_ERROR , LOG_TAG , __VA_ARGS__ ) # define LOGW ( ... ) __android_log_print ( ANDROID_LOG_WARN , LOG_TAG , __VA_ARGS__ ) # else # ifdef DEBUG # define LOGD ( ... ) fprintf ( stderr , " D / " LOG_TAG " ▁ ( " __FILE__ " : " QUOTEME ( __LINE__ ) " ) : ▁ " __VA_ARGS__ ) ; fprintf ( stderr , " \n " ) ; # else # define LOGD ( ... ) # endif # define LOGI ( ... ) fprintf ( stdout , " I / " QUOTEME ( LOG_TAG ) " ( " " ) " __VA_ARGS__ ) ; fprintf ( stdout , " \n " ) ; # define LOGE ( ... ) fprintf ( stderr , " E / " QUOTEME ( LOG_TAG ) " ( " " ) " __VA_ARGS__ ) ; fprintf ( stderr , " \n " ) ; # define LOGW ( ... ) fprintf ( stderr , " W / " QUOTEME ( LOG_TAG ) " ( " " ) " __VA_ARGS__ ) ; fprintf ( stderr , " \n " ) ; # endif namespace tmxparser { # define CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( XMLELEMENT , ATTRIBNAME , LHS ) if ( XMLELEMENT -> Attribute ( ATTRIBNAME ) != NULL ) { LHS = XMLELEMENT -> Attribute ( ATTRIBNAME ) ; } else { LHS = ' \0' ; } # define CHECK_AND_RETRIEVE_REQ_ATTRIBUTE_STRING ( XMLELEMENT , ATTRIBNAME , LHS ) LHS = XMLELEMENT -> Attribute ( ATTRIBNAME ) ; if ( LHS . size ( ) == 0 ) { LOGE ( " Missing ▁ required ▁ attribute ▁ [ % s ] " , ATTRIBNAME ) ; return TmxReturn :: kMissingRequiredAttribute ; } # define CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( FUNC , ATTRIBNAME , OUT ) if ( FUNC ( ATTRIBNAME , OUT ) == tinyxml2 :: XML_NO_ATTRIBUTE ) { LOGE ( " Missing ▁ required ▁ attribute ▁ [ % s ] " , ATTRIBNAME ) ; return kMissingRequiredAttribute ; } TmxReturn _parseStart ( tinyxml2 :: XMLElement * element , TmxMap * outMap , const std :: string & tilesetPath ) ; TmxReturn _parseEnd ( TmxMap * outMap , const std :: string & tilesetPath ) ; void _parseEndHelper ( TmxImage & image , const std :: string & tilesetPath ) ; TmxReturn _parseMapNode ( tinyxml2 :: XMLElement * element , TmxMap * outMap ) ; TmxReturn _parsePropertyNode ( tinyxml2 :: XMLElement * element , TmxPropertyMap_t * outPropertyMap ) ; TmxReturn _parseImageNode ( tinyxml2 :: XMLElement * element , TmxImage * outImage ) ; TmxReturn _parseTilesetNode ( tinyxml2 :: XMLElement * element , TmxTileset * outTileset ) ; TmxReturn _parseTileDefinitionNode ( tinyxml2 :: XMLElement * element , TmxTileDefinition * outTileDefinition ) ; TmxReturn _parseTileAnimationNode ( tinyxml2 :: XMLElement * element , TmxAnimationFrameCollection_t * outAnimationCollection ) ; TmxReturn _parseLayerNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayer * outLayer ) ; TmxReturn _parseLayerDataNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayerTileCollection_t * outTileCollection ) ; TmxReturn _parseLayerXmlTileNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayerTile * outTile ) ; TmxReturn _calculateTileIndices ( const TmxTilesetCollection_t & tilesets , TmxLayerTile * outTile ) ; TmxReturn _parseObjectGroupNode ( tinyxml2 :: XMLElement * element , TmxObjectGroup * outObjectGroup ) ; TmxReturn _parseObjectNode ( tinyxml2 :: XMLElement * element , TmxObject * outObj ) ; TmxReturn _parseOffsetNode ( tinyxml2 :: XMLElement * element , TmxOffset * offset ) ; TmxReturn _parseImageLayerNode ( tinyxml2 :: XMLElement * element , TmxImageLayer * outImageLayer ) ; TmxReturn parseFromFile ( const std :: string & fileName , TmxMap * outMap , const std :: string & tilesetPath ) { tinyxml2 :: XMLDocument doc ; if ( doc . LoadFile ( fileName . c_str ( ) ) != tinyxml2 :: XML_SUCCESS ) { LOGE ( " Cannot ▁ read ▁ xml ▁ file " ) ; return TmxReturn :: kErrorParsing ; } return _parseStart ( doc . FirstChildElement ( " map " ) , outMap , tilesetPath ) ; } TmxReturn parseFromMemory ( void * data , size_t length , TmxMap * outMap , const std :: string & tilesetPath ) { tinyxml2 :: XMLDocument doc ; if ( doc . Parse ( ( char * ) data , length ) ) { LOGE ( " Cannot ▁ parse ▁ xml ▁ memory ▁ file . . . " ) ; return TmxReturn :: kErrorParsing ; } return _parseStart ( doc . FirstChildElement ( " map " ) , outMap , tilesetPath ) ; } TmxReturn _parseStart ( tinyxml2 :: XMLElement * element , TmxMap * outMap , const std :: string & tilesetPath ) { TmxReturn retVal = _parseMapNode ( element , outMap ) ; return ( retVal == TmxReturn :: kSuccess ) ? _parseEnd ( outMap , tilesetPath ) : retVal ; } TmxReturn _parseEnd ( TmxMap * outMap , const std :: string & tilesetPath ) { for ( auto tileIt = outMap -> tilesetCollection . begin ( ) ; tileIt != outMap -> tilesetCollection . end ( ) ; ++ tileIt ) _parseEndHelper ( tileIt -> image , tilesetPath ) ; for ( auto tileIt = outMap -> imageLayerCollection . begin ( ) ; tileIt != outMap -> imageLayerCollection . end ( ) ; ++ tileIt ) _parseEndHelper ( tileIt -> image , tilesetPath ) ; return TmxReturn :: kSuccess ; } void _parseEndHelper ( TmxImage & image , const std :: string & tilesetPath ) { auto pathSeperatorMissing = ( image . source . find ( PATH_SEPARATOR ) == std :: string :: npos ) ; auto pathSeperatorAltMissing = ( image . source . find ( PATH_SEPARATOR_ALT ) == std :: string :: npos ) ; if ( pathSeperatorMissing && pathSeperatorAltMissing ) { std :: string baseFilename = image . source . substr ( image . source . find_last_of ( PATH_SEPARATOR ) + 1 ) ; auto seperatorThere = ( tilesetPath . find ( PATH_SEPARATOR ) != std :: string :: npos ) ; auto seperatorAltThere = ( tilesetPath . find ( PATH_SEPARATOR_ALT ) != std :: string :: npos ) ; auto tileSetPathSeparator = PATH_SEPARATOR ; if ( ! seperatorThere && seperatorAltThere ) tileSetPathSeparator = PATH_SEPARATOR_ALT ; image . source = tilesetPath + tileSetPathSeparator + baseFilename ; } } TmxReturn _parseMapNode ( tinyxml2 :: XMLElement * element , TmxMap * outMap ) { if ( element == NULL ) { return TmxReturn :: kMissingMapNode ; } outMap -> version = element -> Attribute ( " version " ) ; const char * orientation = element -> Attribute ( " orientation " ) ; if ( orientation != NULL ) { if ( strcmp ( orientation , " orthogonal " ) == 0 ) { outMap -> orientation = TmxOrientation :: kOrthogonal ; } else if ( strcmp ( orientation , " isometric " ) == 0 ) { outMap -> orientation = TmxOrientation :: kIsometric ; } else if ( strcmp ( orientation , " staggered " ) == 0 ) { outMap -> orientation = TmxOrientation :: kStaggered ; } } else { LOGW ( " Missing ▁ orientation ▁ attribute " ) ; } CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " width " , & outMap -> width ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " height " , & outMap -> height ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " tilewidth " , & outMap -> tileWidth ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " tileheight " , & outMap -> tileHeight ) ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " backgroundcolor " , outMap -> backgroundColor ) ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " renderorder " , outMap -> renderOrder ) ; TmxReturn error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outMap -> propertyMap ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ map ▁ properties . . . " ) ; return error ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " tileset " ) ; child != NULL ; child = child -> NextSiblingElement ( " tileset " ) ) { TmxTileset set ; error = _parseTilesetNode ( child , & set ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ tileset ▁ node . . . " ) ; return error ; } outMap -> tilesetCollection . push_back ( set ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " layer " ) ; child != NULL ; child = child -> NextSiblingElement ( " layer " ) ) { TmxLayer layer ; error = _parseLayerNode ( child , outMap -> tilesetCollection , & layer ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ layer ▁ node . . . " ) ; return error ; } outMap -> layerCollection . push_back ( layer ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " objectgroup " ) ; child != NULL ; child = child -> NextSiblingElement ( " objectgroup " ) ) { TmxObjectGroup group ; error = _parseObjectGroupNode ( child , & group ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ objectgroup ▁ node . . . " ) ; return error ; } outMap -> objectGroupCollection . push_back ( group ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " imagelayer " ) ; child != NULL ; child = child -> NextSiblingElement ( " imagelayer " ) ) { TmxImageLayer imageLayer ; error = _parseImageLayerNode ( child , & imageLayer ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ imagelayer ▁ node . . . " ) ; return error ; } outMap -> imageLayerCollection . push_back ( imageLayer ) ; } return error ; } TmxReturn _parsePropertyNode ( tinyxml2 :: XMLElement * element , TmxPropertyMap_t * outPropertyMap ) { if ( element == NULL ) { return TmxReturn :: kSuccess ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " property " ) ; child != NULL ; child = child -> NextSiblingElement ( " property " ) ) { if ( strcmp ( child -> Name ( ) , " property " ) == 0 ) { if ( child -> Attribute ( " name " ) != NULL && child -> Attribute ( " value " ) != NULL ) { ( * outPropertyMap ) [ child -> Attribute ( " name " ) ] = child -> Attribute ( " value " ) ; } else { return TmxReturn :: kMalformedPropertyNode ; } } } return TmxReturn :: kSuccess ; } TmxReturn _parseImageNode ( tinyxml2 :: XMLElement * element , TmxImage * outImage ) { CHECK_AND_RETRIEVE_REQ_ATTRIBUTE_STRING ( element , " source " , outImage -> source ) ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " format " , outImage -> format ) ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " trans " , outImage -> transparentColor ) ; outImage -> width = element -> UnsignedAttribute ( " width " ) ; outImage -> height = element -> UnsignedAttribute ( " height " ) ; return TmxReturn :: kSuccess ; } TmxReturn _parseTilesetNode ( tinyxml2 :: XMLElement * element , TmxTileset * outTileset ) { if ( strcmp ( element -> Name ( ) , " tileset " ) == 0 ) { CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " firstgid " , & outTileset -> firstgid ) ; outTileset -> name = element -> Attribute ( " name " ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " tilewidth " , & outTileset -> tileWidth ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " tileheight " , & outTileset -> tileHeight ) ; outTileset -> tileSpacingInImage = element -> UnsignedAttribute ( " spacing " ) ; outTileset -> tileMarginInImage = element -> UnsignedAttribute ( " margin " ) ; if ( element -> FirstChildElement ( " image " ) == NULL ) { LOGE ( " We ▁ do ▁ not ▁ support ▁ maps ▁ with ▁ tilesets ▁ that ▁ have ▁ no ▁ image ▁ associated ▁ currently . . . " ) ; return kErrorParsing ; } TmxImage image ; TmxReturn error = _parseImageNode ( element -> FirstChildElement ( " image " ) , & outTileset -> image ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ image ▁ node . . . " ) ; return error ; } outTileset -> offset . x = 0 ; outTileset -> offset . y = 0 ; if ( element -> FirstChildElement ( " tileoffset " ) != NULL ) { error = _parseOffsetNode ( element -> FirstChildElement ( " tileoffset " ) , & outTileset -> offset ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " tile " ) ; child != NULL ; child = child -> NextSiblingElement ( " tile " ) ) { TmxTileDefinition tileDef ; tileDef . id = 0 ; error = _parseTileDefinitionNode ( child , & tileDef ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ tile ▁ definition " ) ; return error ; } outTileset -> tileDefinitions [ tileDef . id ] = tileDef ; } outTileset -> colCount = ( outTileset -> image . width - outTileset -> tileMarginInImage ) / ( outTileset -> tileWidth + outTileset -> tileSpacingInImage ) ; outTileset -> rowCount = ( outTileset -> image . height - outTileset -> tileMarginInImage ) / ( outTileset -> tileHeight + outTileset -> tileSpacingInImage ) ; } return TmxReturn :: kSuccess ; } TmxReturn _parseTileDefinitionNode ( tinyxml2 :: XMLElement * element , TmxTileDefinition * outTileDefinition ) { TmxReturn error = TmxReturn :: kSuccess ; outTileDefinition -> id = element -> UnsignedAttribute ( " id " ) ; error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outTileDefinition -> propertyMap ) ; if ( error ) { return error ; } if ( element -> FirstChildElement ( " animation " ) != NULL ) { error = _parseTileAnimationNode ( element -> FirstChildElement ( " animation " ) , & outTileDefinition -> animations ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " objectgroup " ) ; child != NULL ; child = child -> NextSiblingElement ( " objectgroup " ) ) { TmxObjectGroup group ; error = _parseObjectGroupNode ( child , & group ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ objectgroup ▁ node . . . " ) ; return error ; } outTileDefinition -> objectgroups . push_back ( group ) ; } return error ; } TmxReturn _parseTileAnimationNode ( tinyxml2 :: XMLElement * element , TmxAnimationFrameCollection_t * outAnimationCollection ) { for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " frame " ) ; child != NULL ; child = child -> NextSiblingElement ( " frame " ) ) { TmxAnimationFrame frame ; frame . duration = child -> FloatAttribute ( " duration " ) ; frame . tileId = child -> UnsignedAttribute ( " tileid " ) ; outAnimationCollection -> push_back ( frame ) ; } return kSuccess ; } TmxReturn _parseLayerNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayer * outLayer ) { TmxReturn error = TmxReturn :: kSuccess ; outLayer -> name = element -> Attribute ( " name " ) ; if ( element -> Attribute ( " opacity " ) ) outLayer -> opacity = element -> FloatAttribute ( " opacity " ) ; else outLayer -> opacity = 1 . f ; if ( element -> Attribute ( " visible " ) ) outLayer -> visible = ( element -> IntAttribute ( " visible " ) == 1 ? true : false ) ; else outLayer -> visible = true ; outLayer -> width = element -> UnsignedAttribute ( " width " ) ; outLayer -> height = element -> UnsignedAttribute ( " height " ) ; error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outLayer -> propertyMap ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ layer ▁ property ▁ node . . . " ) ; return error ; } tinyxml2 :: XMLElement * dataElement = element -> FirstChildElement ( " data " ) ; if ( dataElement != NULL ) { error = _parseLayerDataNode ( dataElement , tilesets , & outLayer -> tiles ) ; } else { LOGE ( " Layer ▁ missing ▁ data ▁ node . . . " ) ; return TmxReturn :: kMissingDataNode ; } return error ; } TmxReturn _parseLayerDataNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayerTileCollection_t * outTileCollection ) { TmxReturn error = TmxReturn :: kSuccess ; const char * encoding = element -> Attribute ( " encoding " ) ; const char * compression = element -> Attribute ( " compression " ) ; if ( compression != NULL ) { LOGE ( " Does ▁ not ▁ support ▁ compression ▁ yet . . . " ) ; return TmxReturn :: kErrorParsing ; } if ( encoding == NULL ) { for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " tile " ) ; child != NULL ; child = child -> NextSiblingElement ( " tile " ) ) { TmxLayerTile tile ; error = _parseLayerXmlTileNode ( child , tilesets , & tile ) ; outTileCollection -> push_back ( tile ) ; } } else if ( strcmp ( encoding , " csv " ) == 0 ) { std :: stringstream csvss ( element -> FirstChild ( ) -> Value ( ) ) ; unsigned int gid = 0 ; while ( csvss >> gid ) { if ( csvss . peek ( ) == ' , ' || csvss . peek ( ) == ' \n ' ) { csvss . ignore ( ) ; } TmxLayerTile tile ; tile . gid = gid ; error = _calculateTileIndices ( tilesets , & tile ) ; if ( error == TmxReturn :: kErrorParsing ) { return error ; } outTileCollection -> push_back ( tile ) ; } } else if ( strcmp ( encoding , " base64" ) == 0 ) { std :: string csvbase64 = element -> FirstChild ( ) -> Value ( ) ; csvbase64 . erase ( std :: remove ( csvbase64 . begin ( ) , csvbase64 . end ( ) , ' \n ' ) , csvbase64 . end ( ) ) ; csvbase64 . erase ( std :: remove ( csvbase64 . begin ( ) , csvbase64 . end ( ) , '' ) , csvbase64 . end ( ) ) ; csvbase64 . erase ( std :: remove ( csvbase64 . begin ( ) , csvbase64 . end ( ) , ' ▁ ' ) , csvbase64 . end ( ) ) ; std :: string csv = base64_decode ( csvbase64 ) ; unsigned int length = csv . size ( ) / sizeof ( unsigned int ) ; unsigned int * p = ( unsigned int * ) csv . c_str ( ) ; for ( unsigned int i = 0 ; i < length ; i ++ ) { TmxLayerTile tile ; tile . gid = p [ i ] ; error = _calculateTileIndices ( tilesets , & tile ) ; if ( error == TmxReturn :: kErrorParsing ) { return error ; } outTileCollection -> push_back ( tile ) ; } } else { LOGE ( " Unsupported ▁ layer ▁ compression ▁ [ % s ] . . . ▁ coming ▁ soon . . . " , encoding ) ; return TmxReturn :: kErrorParsing ; } return error ; } TmxReturn _parseLayerXmlTileNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayerTile * outTile ) { TmxReturn error = TmxReturn :: kSuccess ; unsigned int gid = element -> UnsignedAttribute ( " gid " ) ; unsigned int flipXFlag = 0x80000000 ; unsigned int flipYFlag = 0x40000000 ; unsigned int flipDiagonalFlag = 0x20000000 ; outTile -> flipX = ( gid & flipXFlag ? true : false ) ; outTile -> flipY = ( gid & flipYFlag ? true : false ) ; outTile -> flipDiagonal = ( gid & flipDiagonalFlag ? true : false ) ; outTile -> gid = ( gid & ~ ( flipXFlag | flipYFlag | flipDiagonalFlag ) ) ; return _calculateTileIndices ( tilesets , outTile ) ; } TmxReturn _calculateTileIndices ( const TmxTilesetCollection_t & tilesets , TmxLayerTile * outTile ) { outTile -> tilesetIndex = 0 ; outTile -> tileFlatIndex = 0 ; if ( outTile -> gid == 0 ) { return TmxReturn :: kSuccess ; } unsigned int index = 0 ; unsigned int lastEndIndex = 1 ; for ( auto it = tilesets . begin ( ) ; it != tilesets . end ( ) ; ++ it ) { unsigned int colCount = it -> colCount ; unsigned int rowCount = it -> rowCount ; unsigned int startIndex = it -> firstgid ; unsigned int endIndex = it -> firstgid + ( colCount * rowCount ) ; if ( outTile -> gid >= startIndex && outTile -> gid < endIndex ) { outTile -> tilesetIndex = index ; outTile -> tileFlatIndex = ( outTile -> gid ) - lastEndIndex ; return TmxReturn :: kSuccess ; } lastEndIndex = endIndex ; index ++ ; } return TmxReturn :: kUnknownTileIndices ; } TmxReturn _parseObjectGroupNode ( tinyxml2 :: XMLElement * element , TmxObjectGroup * outObjectGroup ) { TmxReturn error = TmxReturn :: kSuccess ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " name " , outObjectGroup -> name ) ; if ( element -> Attribute ( " opacity " ) != NULL ) { outObjectGroup -> opacity = element -> FloatAttribute ( " opacity " ) ; } else { outObjectGroup -> opacity = 1.0f ; } if ( element -> Attribute ( " visible " ) != NULL ) { outObjectGroup -> visible = element -> BoolAttribute ( " visible " ) ; } else { outObjectGroup -> visible = true ; } error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outObjectGroup -> propertyMap ) ; if ( error ) { return error ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " object " ) ; child != NULL ; child = child -> NextSiblingElement ( " object " ) ) { TmxObject obj ; error = _parseObjectNode ( child , & obj ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ object ▁ node . . . " ) ; return TmxReturn :: kErrorParsing ; } outObjectGroup -> objects . push_back ( obj ) ; } return error ; } TmxReturn _parseObjectNode ( tinyxml2 :: XMLElement * element , TmxObject * outObj ) { TmxReturn error = TmxReturn :: kSuccess ; if ( element -> Attribute ( " name " ) ) { outObj -> name = element -> Attribute ( " name " ) ; } if ( element -> Attribute ( " type " ) ) { outObj -> type = element -> Attribute ( " type " ) ; } outObj -> x = element -> FloatAttribute ( " x " ) ; outObj -> y = element -> FloatAttribute ( " y " ) ; outObj -> width = element -> FloatAttribute ( " width " ) ; outObj -> height = element -> FloatAttribute ( " height " ) ; outObj -> rotation = element -> FloatAttribute ( " rotation " ) ; outObj -> referenceGid = element -> UnsignedAttribute ( " gid " ) ; outObj -> visible = element -> BoolAttribute ( " visible " ) ; error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outObj -> propertyMap ) ; if ( error ) { return error ; } tinyxml2 :: XMLElement * shapeElement = NULL ; if ( ( shapeElement = element -> FirstChildElement ( " ellipse " ) ) != NULL ) { outObj -> shapeType = kEllipse ; } else if ( ( shapeElement = element -> FirstChildElement ( " polygon " ) ) != NULL ) { outObj -> shapeType = kPolygon ; } else if ( ( shapeElement = element -> FirstChildElement ( " polyline " ) ) != NULL ) { outObj -> shapeType = kPolyline ; } else { outObj -> shapeType = kSquare ; } if ( ( outObj -> shapeType == kPolygon || outObj -> shapeType == kPolyline ) && shapeElement != NULL ) { if ( shapeElement -> Attribute ( " points " ) == NULL ) { LOGE ( " Missing ▁ points ▁ attribute ▁ for ▁ shape ▁ requiring ▁ one . . . " ) ; return TmxReturn :: kErrorParsing ; } std :: string pointString = shapeElement -> Attribute ( " points " ) ; std :: istringstream pairStringStream ( pointString ) ; std :: string pairToken ; while ( std :: getline ( pairStringStream , pairToken , ' ▁ ' ) ) { TmxShapePoint pair ; std :: istringstream pointStringString ( pairToken ) ; std :: string pointToken ; std :: getline ( pointStringString , pointToken , ' , ' ) ; pair . first = ( float ) atof ( pointToken . c_str ( ) ) ; std :: getline ( pointStringString , pointToken , ' , ' ) ; pair . second = ( float ) atof ( pointToken . c_str ( ) ) ; outObj -> shapePoints . push_back ( pair ) ; } } return error ; } TmxReturn calculateTileCoordinatesUV ( const TmxTileset & tileset , unsigned int tileFlatIndex , float pixelCorrection , bool flipY , TmxRect & outRect ) { if ( tileFlatIndex >= tileset . colCount * tileset . rowCount ) { return TmxReturn :: kInvalidTileIndex ; } TileId_t xIndex = tileFlatIndex % tileset . colCount ; TileId_t yIndex = tileFlatIndex / tileset . colCount ; unsigned int widthDelta = tileset . tileSpacingInImage + tileset . tileMarginInImage * xIndex ; unsigned int heightDelta = tileset . tileSpacingInImage + tileset . tileMarginInImage * yIndex ; float u = ( float ) ( ( xIndex * tileset . tileWidth ) + widthDelta + pixelCorrection ) / ( float ) tileset . image . width ; float v = ( float ) ( ( yIndex * tileset . tileHeight ) + heightDelta + pixelCorrection ) / ( float ) tileset . image . height ; float u2 = ( float ) ( ( ( ( xIndex + 1 ) * tileset . tileWidth ) + widthDelta ) - pixelCorrection ) / ( float ) tileset . image . width ; float v2 = ( float ) ( ( ( ( yIndex + 1 ) * tileset . tileHeight ) + heightDelta ) - pixelCorrection ) / ( float ) tileset . image . height ; if ( flipY ) { float tmpV = v ; v = 1 . f - v2 ; v2 = 1 . f - tmpV ; } outRect . u = u ; outRect . v = v ; outRect . u2 = u2 ; outRect . v2 = v2 ; return kSuccess ; } tmxparser :: TmxReturn _parseOffsetNode ( tinyxml2 :: XMLElement * element , TmxOffset * offset ) { TmxReturn error = TmxReturn :: kSuccess ; offset -> x = 0 ; offset -> y = 0 ; if ( element -> Attribute ( " x " ) ) { offset -> x = element -> IntAttribute ( " x " ) ; } if ( element -> Attribute ( " y " ) ) { offset -> y = element -> IntAttribute ( " y " ) ; } return error ; } tmxparser :: TmxReturn _parseImageLayerNode ( tinyxml2 :: XMLElement * element , TmxImageLayer * outImageLayer ) { TmxReturn error = TmxReturn :: kSuccess ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE_STRING ( element , " name " , outImageLayer -> name ) ; if ( element -> QueryUnsignedAttribute ( " x " , & outImageLayer -> x ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> x = 0U ; if ( element -> QueryUnsignedAttribute ( " y " , & outImageLayer -> y ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> y = 0U ; if ( element -> QueryUnsignedAttribute ( " width " , & outImageLayer -> widthInTiles ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> widthInTiles = 0U ; if ( element -> QueryUnsignedAttribute ( " height " , & outImageLayer -> heightInTiles ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> heightInTiles = 0U ; if ( element -> QueryFloatAttribute ( " opacity " , & outImageLayer -> opacity ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> opacity = 1 . f ; if ( element -> QueryBoolAttribute ( " visible " , & outImageLayer -> visible ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> visible = true ; if ( element -> FirstChildElement ( " properties " ) != NULL ) { error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outImageLayer -> propertyMap ) ; if ( error != kSuccess ) { LOGE ( " Error ▁ parsing ▁ image ▁ layer ▁ property ▁ node . . . " ) ; return error ; } } if ( element -> FirstChildElement ( " image " ) != NULL ) { error = _parseImageNode ( element -> FirstChildElement ( " image " ) , & outImageLayer -> image ) ; if ( error != kSuccess ) return error ; } return error ; } } </DOCUMENT>
<DOCUMENT_ID="osgcc/ryzom/tree/master/ryzom/tools/leveldesign/georges_dll/form_dialog.cpp"> # include " stdafx . h " # include " georges _ edit . h " # include " georges _ edit _ view . h " # include " georges _ edit _ doc . h " # include " form _ dialog . h " # include " action . h " # include " left _ view . h " # include " nel / misc / path . h " # include " nel / georges / type . h " # include " nel / georges / form _ elm . h " using namespace std ; using namespace NLMISC ; using namespace NLGEORGES ; CFormDialog :: CFormDialog ( ) : CBaseDialog ( IDR_MAINFRAME ) { View = NULL ; WidgetIndexCount = 0 ; WidgetFocused = 0xffffffff ; } CFormDialog :: ~ CFormDialog ( ) { clear ( ) ; } void CFormDialog :: clear ( ) { unRegisterLastControl ( ) ; for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) delete Widgets [ i ] ; Widgets . clear ( ) ; WidgetFocused = 0xffffffff ; WidgetIndexCount = 0 ; } void CFormDialog :: DoDataExchange ( CDataExchange * pDX ) { CDialog :: DoDataExchange ( pDX ) ; } BEGIN_MESSAGE_MAP ( CFormDialog , CDialog ) ON_WM_SIZE ( ) ON_WM_LBUTTONDOWN ( ) ON_WM_SETFOCUS ( ) ON_WM_KILLFOCUS ( ) END_MESSAGE_MAP ( ) void CFormDialog :: OnSize ( UINT nType , int cx , int cy ) { CBaseDialog :: OnSize ( nType , cx , cy ) ; } BOOL CFormDialog :: OnInitDialog ( ) { CBaseDialog :: OnInitDialog ( ) ; SetDefID ( 0xffffffff ) ; UpdateData ( FALSE ) ; return TRUE ; } void CFormDialog :: OnOK ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateData ( ) ; if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onOk ( ) ; } } } void CFormDialog :: OnCancel ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateData ( ) ; if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onCancel ( ) ; return ; } } CBaseDialog :: OnCancel ( ) ; } CWnd * CFormDialog :: addTypeWidget ( const NLGEORGES :: CType & type , uint elmIndex , const char * title , const char * atomName , const char * typeFilename , RECT & currentPos , CForm & form , IFormWidget :: TTypeSrc typeWidget , const char * filenameExt , uint slot ) { switch ( type . UIType ) { case CType :: FileBrowser : case CType :: Edit : case CType :: EditSpin : { CFormMemCombo * memCombo = new CFormMemCombo ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; string tfn = typeFilename ; string key = GEORGES_EDIT_BASE_REG_KEY " \\ " + strlwr ( typeFilename ) + " ▁ MemCombo " ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title , key . c_str ( ) , type . UIType == CType :: EditSpin , type . UIType == CType :: FileBrowser , filenameExt ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Combo ; } break ; case CType :: NonEditableCombo : { CFormCombo * memCombo = new CFormCombo ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Combo ; } break ; case CType :: BigEdit : { CFormBigEdit * memCombo = new CFormBigEdit ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Edit ; } break ; case CType :: ColorEdit : { CColorEdit * memCombo = new CColorEdit ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Color ; } break ; } return NULL ; } void CFormDialog :: getVirtualDfnFromDocument ( const NLGEORGES :: CFormDfn * _dfn , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; CFormMemCombo * memCombo = new CFormMemCombo ( this , 0xffffffff , structName , IFormWidget :: TypeVirtualDfn , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Dfn : " , GEORGES_EDIT_BASE_REG_KEY " \\Virtual ▁ Dfn ▁ MemCombo " , false , true , " * . dfn " ) ; memCombo -> getFromDocument ( * doc -> getFormPtr ( ) ) ; if ( _dfn ) { std :: vector < const CFormDfn * > arrayDfn ; arrayDfn . reserve ( _dfn -> countParentDfn ( ) ) ; _dfn -> getParentDfn ( arrayDfn ) ; uint elmIndex = 0 ; for ( uint dfnIndex = 0 ; dfnIndex < arrayDfn . size ( ) ; dfnIndex ++ ) { nlassert ( arrayDfn [ dfnIndex ] ) ; const CFormDfn & dfn = * arrayDfn [ dfnIndex ] ; for ( uint i = 0 ; i < dfn . getNumEntry ( ) ; i ++ ) { const CFormDfn :: CEntry & entry = dfn . getEntry ( i ) ; if ( entry . getType ( ) == UFormDfn :: EntryType && ! entry . getArrayFlag ( ) ) { string title = entry . getName ( ) + " : " ; string atomName = string ( structName ) + " . " + entry . getName ( ) ; addTypeWidget ( * entry . getTypePtr ( ) , elmIndex , title . c_str ( ) , atomName . c_str ( ) , entry . getFilename ( ) . c_str ( ) , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeForm , entry . getFilenameExt ( ) . c_str ( ) , slot ) ; } elmIndex ++ ; } } } registerLastControl ( ) ; } } } void CFormDialog :: getDfnFromDocument ( const NLGEORGES :: CFormDfn & _dfn , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; std :: vector < const CFormDfn * > arrayDfn ; arrayDfn . reserve ( _dfn . countParentDfn ( ) ) ; _dfn . getParentDfn ( arrayDfn ) ; if ( strcmp ( structName , " " ) == 0 ) { CListWidget * listWidget = new CListWidget ( this , 0xffffffff , " " , IFormWidget :: TypeFormParent , slot ) ; Widgets . push_back ( listWidget ) ; listWidget -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Parent ▁ Form : " , GEORGES_EDIT_BASE_REG_KEY " \\Parent ▁ Form ▁ MemCombo " , 1 ) ; listWidget -> addColumn ( " Parent ▁ filename " ) ; listWidget -> getFromDocument ( * doc -> getFormPtr ( ) ) ; } CWnd * pWnd = NULL ; CWnd * pWndIcon = NULL ; CWnd * pWndIconColor = NULL ; CWnd * pWndIconBack = NULL ; CWnd * pWndIconBackColor = NULL ; CWnd * pWndIconOver = NULL ; CWnd * pWndIconOverColor = NULL ; CWnd * pWndIconOver2 = NULL ; CWnd * pWndIconOver2Color = NULL ; uint elmIndex = 0 ; for ( uint dfnIndex = 0 ; dfnIndex < arrayDfn . size ( ) ; dfnIndex ++ ) { nlassert ( arrayDfn [ dfnIndex ] ) ; const CFormDfn & dfn = * arrayDfn [ dfnIndex ] ; for ( uint i = 0 ; i < dfn . getNumEntry ( ) ; i ++ ) { const CFormDfn :: CEntry & entry = dfn . getEntry ( i ) ; if ( entry . getType ( ) == UFormDfn :: EntryType && ! entry . getArrayFlag ( ) ) { string title = entry . getName ( ) + " : " ; string atomName = string ( structName ) + " . " + entry . getName ( ) ; pWnd = addTypeWidget ( * entry . getTypePtr ( ) , elmIndex , title . c_str ( ) , atomName . c_str ( ) , entry . getFilename ( ) . c_str ( ) , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeForm , entry . getFilenameExt ( ) . c_str ( ) , slot ) ; if ( entry . getName ( ) == " Icon " || entry . getName ( ) == " icon " ) pWndIcon = pWnd ; else if ( entry . getName ( ) == " IconColor " ) pWndIconColor = pWnd ; else if ( entry . getName ( ) == " IconBack " || entry . getName ( ) == " icon ▁ background " ) pWndIconBack = pWnd ; else if ( entry . getName ( ) == " IconBackColor " ) pWndIconBackColor = pWnd ; else if ( entry . getName ( ) == " IconOver " || entry . getName ( ) == " icon ▁ overlay " ) pWndIconOver = pWnd ; else if ( entry . getName ( ) == " IconOverColor " ) pWndIconOverColor = pWnd ; else if ( entry . getName ( ) == " IconOver2" || entry . getName ( ) == " icon ▁ overlay2" ) pWndIconOver2 = pWnd ; else if ( entry . getName ( ) == " IconOver2Color " ) pWndIconOver2Color = pWnd ; } elmIndex ++ ; } } if ( ( string ( structName ) == " . Client " ) || ( string ( structName ) == " . 3d " ) ) { string title = " Icon ▁ bitmap : " ; CIconWidget * w = new CIconWidget ( this , elmIndex , " " , IFormWidget :: TypeFormParent , slot ) ; Widgets . push_back ( w ) ; w -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title . c_str ( ) ) ; w -> Icon . pWndIcon = pWndIcon ; w -> Icon . pWndIconColor = pWndIconColor ; w -> Icon . pWndIconBack = pWndIconBack ; w -> Icon . pWndIconBackColor = pWndIconBackColor ; w -> Icon . pWndIconOver = pWndIconOver ; w -> Icon . pWndIconOverColor = pWndIconOverColor ; w -> Icon . pWndIconOver2 = pWndIconOver2 ; w -> Icon . pWndIconOver2Color = pWndIconOver2Color ; } registerLastControl ( ) ; } } } void CFormDialog :: getArrayFromDocument ( const char * structName , uint structId , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; CFormMemCombo * memCombo = new CFormMemCombo ( this , structId , structName , IFormWidget :: TypeArray , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Array ▁ size : " , GEORGES_EDIT_BASE_REG_KEY " \\Array ▁ Size ▁ MemCombo " , true , false , NULL ) ; memCombo -> getFromDocument ( * doc -> getFormPtr ( ) ) ; registerLastControl ( ) ; } } } void CFormDialog :: getTypeFromDocument ( const NLGEORGES :: CType & _type , const char * name , const char * typeFilename , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; addTypeWidget ( _type , 0xffffffff , name , structName , typeFilename , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeType , NULL , slot ) ; registerLastControl ( ) ; } } } void CFormDialog :: updateLabels ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateLabel ( ) ; } } void CFormDialog :: updateValues ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateLabel ( ) ; Widgets [ i ] -> getFromDocument ( * ( View -> GetDocument ( ) -> getFormPtr ( ) ) ) ; } } void CFormDialog :: setToDocument ( uint widget ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { CIconWidget * iconWidget = dynamic_cast < CIconWidget * > ( Widgets [ widget ] ) ; if ( iconWidget ) return ; if ( Widgets [ widget ] -> getFormName ( ) != " NULL " ) { const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( Widgets [ widget ] -> getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( Widgets [ widget ] -> getFormName ( ) . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; if ( parentVDfnArray ) { if ( ! theApp . yesNo ( " Warning , ▁ this ▁ action ▁ will ▁ create ▁ an ▁ array / virtual ▁ dfn ▁ over ▁ an ▁ inherited ▁ array / virtual ▁ dfn . \n Do ▁ you ▁ want ▁ to ▁ continue ▁ ? " ) ) return ; } } IFormWidget :: TTypeSrc typeSrc = Widgets [ widget ] -> getSrcType ( ) ; if ( typeSrc == IFormWidget :: TypeForm ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionString ( IAction :: FormValue , result . c_str ( ) , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeFormParent ) { CForm * form = doc -> getFormPtr ( ) ; uint count = Widgets [ widget ] -> getNumValue ( ) ; vector < string > stringVector ( count ) ; for ( uint value = 0 ; value < count ; value ++ ) { Widgets [ widget ] -> getValue ( stringVector [ value ] , value ) ; } doc -> modify ( new CActionStringVector ( IAction :: FormParents , stringVector , * doc , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeArray ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionBuffer ( IAction :: FormArraySize , NULL , 0 , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , result . c_str ( ) , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeType ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionString ( IAction :: FormTypeValue , result . c_str ( ) , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeVirtualDfn ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionBuffer ( IAction :: FormVirtualDfnName , NULL , 0 , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , result . c_str ( ) , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } } if ( ! Widgets [ widget ] -> getFormName ( ) . empty ( ) ) doc -> notifyPlugins ( Widgets [ widget ] -> getFormName ( ) . c_str ( ) ) ; } LRESULT CFormDialog :: WindowProc ( UINT message , WPARAM wParam , LPARAM lParam ) { switch ( message ) { case CL_CHANGED : { uint widgetId = getWidget ( wParam ) ; CColorEdit * colorEdit = safe_cast < CColorEdit * > ( Widgets [ widgetId ] ) ; colorEdit -> Empty = false ; setToDocument ( getWidget ( wParam ) ) ; } break ; case MC_STRINGCHANGE : { setToDocument ( getWidget ( wParam ) ) ; } break ; case CBN_CHANGED : { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { CIconWidget * iconWidget = dynamic_cast < CIconWidget * > ( Widgets [ i ] ) ; if ( iconWidget ) iconWidget -> Icon . Invalidate ( ) ; } } break ; } return CDialog :: WindowProc ( message , wParam , lParam ) ; } void CFormDialog :: onOpenSelected ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onOpenSelected ( ) ; } } } CWnd * CFormDialog :: GetNextDlgTabItem ( CWnd * pWndCtl , BOOL bPrevious ) const { return NULL ; } void CFormDialog :: onFirstFocus ( ) { View -> SetFocus ( ) ; WidgetFocused = 0xffffffff ; } void CFormDialog :: onLastFocus ( ) { View -> setFocusLeftView ( ) ; WidgetFocused = 0xffffffff ; } int CFormDialog :: getWidget ( uint dialogId ) const { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { if ( Widgets [ i ] -> isDialog ( dialogId ) ) return i ; } return - 1 ; } BOOL CFormDialog :: OnCommand ( WPARAM wParam , LPARAM lParam ) { switch ( HIWORD ( wParam ) ) { case CBN_SETFOCUS : { onGetSubFocus ( LOWORD ( wParam ) ) ; } return TRUE ; case EN_SETFOCUS : { onGetSubFocus ( LOWORD ( wParam ) ) ; } return TRUE ; case CBN_SELCHANGE : { int widgetId = getWidget ( LOWORD ( wParam ) ) ; if ( widgetId != - 1 ) setToDocument ( widgetId ) ; } return TRUE ; case EN_CHANGE : { int widgetId = getWidget ( LOWORD ( wParam ) ) ; if ( widgetId != - 1 ) { CColorEdit * colorEdit = dynamic_cast < CColorEdit * > ( Widgets [ widgetId ] ) ; if ( colorEdit ) { CString str ; colorEdit -> Edit . GetWindowText ( str ) ; sint r , g , b ; if ( sscanf ( str , " % d , % d , % d " , & r , & g , & b ) == 3 ) { clamp ( r , 0 , 255 ) ; clamp ( g , 0 , 255 ) ; clamp ( b , 0 , 255 ) ; CRGBA color ( r , g , b ) ; colorEdit -> Color . setColor ( color ) ; if ( r != 255 && g != 255 && b != 255 ) colorEdit -> Empty = false ; } } } } return TRUE ; case BN_CLICKED : { int widgetId = getWidget ( LOWORD ( wParam ) ) ; if ( widgetId != - 1 ) { if ( ( Widgets [ widgetId ] -> getSrcType ( ) == IFormWidget :: TypeForm ) || ( Widgets [ widgetId ] -> getSrcType ( ) == IFormWidget :: TypeType ) ) { CFormMemCombo * combo = dynamic_cast < CFormMemCombo * > ( Widgets [ widgetId ] ) ; if ( combo && IsWindow ( combo -> Browse ) ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( Widgets [ widgetId ] -> getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( Widgets [ widgetId ] -> getFormName ( ) . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; nlassert ( parentDfn ) ; string ext = parentDfn -> getEntry ( indexDfn ) . getFilenameExt ( ) ; char typeName [ 512 ] ; smprintf ( typeName , 512 , " % s " , strlwr ( ext ) . c_str ( ) ) ; uint i = 0 ; while ( ( typeName [ i ] == ' . ' ) || ( typeName [ i ] == ' * ' ) ) i ++ ; if ( typeName [ i ] ) typeName [ i ] = toupper ( typeName [ i ] ) ; char filter [ 512 ] ; smprintf ( filter , 512 , " % s ▁ Files ▁ ( % s ) | % s | All ▁ Files ( * . * ) | * . * | " , typeName + i , ext . c_str ( ) , ext . c_str ( ) ) ; CFileDialog dlgFile ( TRUE , ext . c_str ( ) , ext . c_str ( ) , OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT , filter , theApp . m_pMainWnd ) ; if ( dlgFile . DoModal ( ) == IDOK ) { combo -> Combo . UpdateData ( ) ; combo -> Combo . SetWindowText ( dlgFile . GetFileName ( ) ) ; combo -> Combo . UpdateData ( FALSE ) ; setToDocument ( widgetId ) ; PostMessage ( CBN_CHANGED , 0 , 0 ) ; } } } else { CColorEdit * colorEdit = dynamic_cast < CColorEdit * > ( Widgets [ widgetId ] ) ; if ( colorEdit && IsWindow ( colorEdit -> Color ) ) { colorEdit -> Empty = true ; colorEdit -> Edit . SetWindowText ( " " ) ; setToDocument ( getWidget ( wParam ) ) ; updateValues ( ) ; } } } else if ( Widgets [ widgetId ] -> getSrcType ( ) == IFormWidget :: TypeVirtualDfn ) { CFormMemCombo * combo = dynamic_cast < CFormMemCombo * > ( Widgets [ widgetId ] ) ; if ( combo && IsWindow ( combo -> Browse ) ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { char filter [ 512 ] ; smprintf ( filter , 512 , " Dfn ▁ Files ▁ ( * . dfn ) | * . dfn | All ▁ Files ( * . * ) | * . * | " ) ; CFileDialog dlgFile ( TRUE , " * . dfn " , " * . dfn " , OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT , filter , theApp . m_pMainWnd ) ; if ( dlgFile . DoModal ( ) == IDOK ) { combo -> Combo . UpdateData ( ) ; combo -> Combo . SetWindowText ( dlgFile . GetFileName ( ) ) ; combo -> Combo . UpdateData ( FALSE ) ; setToDocument ( widgetId ) ; } } } } else if ( Widgets [ widgetId ] -> getSrcType ( ) == IFormWidget :: TypeFormParent ) { setToDocument ( widgetId ) ; } } } return TRUE ; } return CWnd :: OnCommand ( wParam , lParam ) ; } BOOL CFormDialog :: OnNotify ( WPARAM wParam , LPARAM lParam , LRESULT * pResult ) { LPNMHDR pnmh = ( LPNMHDR ) lParam ; int idCtrl = ( int ) wParam ; switch ( pnmh -> code ) { case NM_SETFOCUS : { onGetSubFocus ( idCtrl ) ; } break ; case UDN_DELTAPOS : { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { if ( Widgets [ i ] -> isDialog ( idCtrl ) ) { Widgets [ i ] -> getFormName ( ) ; LPNMUPDOWN lpnmud = ( LPNMUPDOWN ) lParam ; CFormMemCombo * combo = ( CFormMemCombo * ) Widgets [ i ] ; float value ; CString str ; combo -> Combo . UpdateData ( ) ; combo -> Combo . GetWindowText ( str ) ; if ( sscanf ( str , " % f " , & value ) == 1 ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { const CFormDfn * parentDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; uint lastElement ; bool array ; bool parentVDfnArray ; UFormDfn :: TEntryType type ; nlverify ( ( const CFormElm * ) ( doc -> getRootNode ( Widgets [ i ] -> getSlot ( ) ) ) -> getNodeByName ( Widgets [ i ] -> getFormName ( ) . c_str ( ) , & parentDfn , lastElement , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; float increment = 1 ; if ( nodeType ) sscanf ( nodeType -> Increment . c_str ( ) , " % f " , & increment ) ; value -= ( float ) ( lpnmud -> iDelta ) * increment ; char result [ 512 ] ; sprintf ( result , " % g " , value ) ; combo -> Combo . SetWindowText ( result ) ; combo -> Combo . UpdateData ( FALSE ) ; setToDocument ( i ) ; } } break ; } } } break ; } return CDialog :: OnNotify ( wParam , lParam , pResult ) ; } void CFormDialog :: resizeWidgets ( ) { if ( Widgets . size ( ) ) { RECT viewRect ; View -> GetClientRect ( & viewRect ) ; uint virtualWidth = std :: max ( ( uint ) MinViewWidth , ( uint ) ( viewRect . right - viewRect . left ) ) ; CBaseDialog :: resizeWidgets ( virtualWidth , 0 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; uint bigWidgetCount [ 2 ] = { 0 , 0 } ; uint i ; uint biggestBottom [ 2 ] = { 0 , 0 } ; uint nextSplit = Widgets . size ( ) / 2 ; for ( i = 0 ; i < Widgets . size ( ) ; i ++ ) { uint column = ( i > nextSplit ) ? 1 : 0 ; Widgets [ i ] -> resizeScan ( currentPos , bigWidgetCount [ column ] , 0 , false ) ; if ( currentPos . bottom > ( int ) biggestBottom [ column ] ) { biggestBottom [ column ] = currentPos . bottom ; } if ( nextSplit == i ) { getNextColumn ( currentPos ) ; currentPos . top = 0 ; } } uint adjust [ 2 ] ; CBaseDialog :: resizeWidgets ( virtualWidth , biggestBottom [ 0 ] ) ; adjust [ 0 ] = AdjusteHeight ; CBaseDialog :: resizeWidgets ( virtualWidth , biggestBottom [ 1 ] ) ; adjust [ 1 ] = AdjusteHeight ; currentPos ; getFirstItemPos ( currentPos ) ; uint adjustSum [ 2 ] = { bigWidgetCount [ 0 ] ? adjust [ 0 ] / bigWidgetCount [ 0 ] : 0 , bigWidgetCount [ 1 ] ? adjust [ 1 ] / bigWidgetCount [ 1 ] : 0 } ; biggestBottom [ 0 ] = 0 ; biggestBottom [ 1 ] = 0 ; for ( i = 0 ; i < Widgets . size ( ) - 1 ; i ++ ) { uint column = ( i > nextSplit ) ? 1 : 0 ; if ( Widgets [ i ] -> extendableHeight ( ) ) { Widgets [ i ] -> resizeScan ( currentPos , bigWidgetCount [ column ] , adjustSum [ column ] , true ) ; adjust [ column ] -= adjustSum [ column ] ; } else Widgets [ i ] -> resizeScan ( currentPos , bigWidgetCount [ column ] , 0 , true ) ; if ( currentPos . bottom > ( int ) biggestBottom [ column ] ) { biggestBottom [ column ] = currentPos . bottom ; } if ( nextSplit == i ) { getNextColumn ( currentPos ) ; currentPos . top = 0 ; } } uint column = ( i > nextSplit ) ? 1 : 0 ; Widgets [ i ] -> resizeScan ( currentPos , bigWidgetCount [ column ] , adjust [ column ] , true ) ; if ( currentPos . bottom > ( int ) biggestBottom [ column ] ) { biggestBottom [ column ] = currentPos . bottom ; } View -> setViewSize ( virtualWidth , std :: max ( biggestBottom [ 0 ] , biggestBottom [ 1 ] ) + CGeorgesEditView :: WidgetTopMargin + CGeorgesEditView :: WidgetBottomMargin ) ; } } void CFormDialog :: getFromDocument ( ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { uint widgetFocus ; for ( widgetFocus = 0 ; widgetFocus < Widgets . size ( ) ; widgetFocus ++ ) { if ( Widgets [ widgetFocus ] -> haveFocus ( ) ) break ; } CGeorgesEditDocSub * subObject = doc -> getSelectedObject ( ) ; const CFormDfn * parentDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; uint lastElement ; bool array ; bool parentVDfnArray ; UFormDfn :: TEntryType type ; nlverify ( ( ( const CFormElm * ) ( doc -> getRootNode ( subObject -> getSlot ( ) ) ) ) -> getNodeByName ( subObject -> getFormName ( ) . c_str ( ) , & parentDfn , lastElement , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; if ( parentDfn ) { if ( array ) { nlassert ( ( type == UFormDfn :: EntryDfn ) || ( type == UFormDfn :: EntryType ) ) ; getArrayFromDocument ( subObject -> getFormName ( ) . c_str ( ) , lastElement , subObject -> getSlot ( ) ) ; } else { switch ( parentDfn -> getEntry ( lastElement ) . getType ( ) ) { case UFormDfn :: EntryType : nlassert ( ! array ) ; nlassert ( nodeType ) ; nlassert ( parentDfn ) ; nlassert ( type == UFormDfn :: EntryType ) ; getTypeFromDocument ( * nodeType , ( parentDfn -> getEntry ( lastElement ) . getName ( ) + " : " ) . c_str ( ) , parentDfn -> getEntry ( lastElement ) . getFilename ( ) . c_str ( ) , subObject -> getFormName ( ) . c_str ( ) , subObject -> getSlot ( ) ) ; break ; case UFormDfn :: EntryDfn : nlassert ( ! array ) ; nlassert ( ( nodeDfn ) && ( type == UFormDfn :: EntryDfn ) ) ; getDfnFromDocument ( * nodeDfn , subObject -> getFormName ( ) . c_str ( ) , subObject -> getSlot ( ) ) ; break ; case UFormDfn :: EntryVirtualDfn : nlassert ( ! array ) ; getVirtualDfnFromDocument ( nodeDfn , subObject -> getFormName ( ) . c_str ( ) , subObject -> getSlot ( ) ) ; break ; } } } else { nlassert ( ! array ) ; nlassert ( ( nodeDfn ) && ( type == UFormDfn :: EntryDfn ) ) ; getDfnFromDocument ( * nodeDfn , subObject -> getFormName ( ) . c_str ( ) , subObject -> getSlot ( ) ) ; } for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateLabel ( ) ; } if ( widgetFocus < Widgets . size ( ) ) { Widgets [ widgetFocus ] -> setFocus ( ) ; } resizeWidgets ( ) ; } } void CFormDialog :: getDfnName ( string & result ) const { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { CString str = doc -> GetPathName ( ) ; char extension [ 512 ] ; _splitpath ( str , NULL , NULL , NULL , extension ) ; result = ( * extension == ' . ' ) ? extension + 1 : extension ; } else result = " " ; } void CFormDialog :: OnLButtonDown ( UINT nFlags , CPoint point ) { View -> TabCtrl . SetFocus ( ) ; CDialog :: OnLButtonDown ( nFlags , point ) ; } void CFormDialog :: onGetSubFocus ( uint id ) { int widget = getWidget ( id ) ; WidgetFocused = widget ; RECT widgetRect ; if ( Widgets [ widget ] -> getWindowRect ( widgetRect ) ) { View -> ScreenToClient ( & widgetRect ) ; RECT viewRect ; View -> GetClientRect ( & viewRect ) ; int bottom = viewRect . bottom - viewRect . top ; if ( widgetRect . bottom > bottom ) { CPoint pt = View -> GetScrollPosition ( ) ; View -> ScrollToPosition ( CPoint ( pt . x , pt . y + widgetRect . bottom - bottom + 10 ) ) ; } if ( widgetRect . top < 0 ) { CPoint pt = View -> GetScrollPosition ( ) ; View -> ScrollToPosition ( CPoint ( pt . x , pt . y + widgetRect . top - 10 ) ) ; } } } void CFormDialog :: OnSetFocus ( CWnd * pNewWnd ) { CDialog :: OnSetFocus ( pNewWnd ) ; if ( WidgetFocused != 0xffffffff ) Widgets [ WidgetFocused ] -> setFocus ( ) ; } void CFormDialog :: OnKillFocus ( CWnd * pNewWnd ) { CDialog :: OnKillFocus ( pNewWnd ) ; } IFormWidget :: IFormWidget ( CFormDialog * dialog , uint structId , const char * atomName , TTypeSrc typeSrc , uint slot ) { FormName = atomName ; Dialog = dialog ; StructId = structId ; SrcType = typeSrc ; Slot = slot ; } bool IFormWidget :: isDialog ( uint id ) const { return ( id >= FirstId ) && ( id <= LastId ) ; } ; uint IFormWidget :: getSlot ( ) const { return Slot ; } ; uint IFormWidget :: getStructId ( ) const { return StructId ; } void IFormWidget :: updateLabel ( ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; if ( doc ) { if ( IsWindow ( Label ) ) { if ( SrcType != TypeFormParent ) { if ( ( SrcType == TypeForm ) || ( SrcType == TypeType ) ) { std :: string result ; UFormElm :: TWhereIsValue where ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; nlverify ( elm -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , & where ) ) ; std :: string resultEvaluated ; # ifdef TEST_EVAL_FORMULA bool error = ! elm -> getValueByName ( resultEvaluated , FormName . c_str ( ) , UFormElm :: Formula , & where ) ; # else bool error = ! elm -> getValueByName ( resultEvaluated , FormName . c_str ( ) , UFormElm :: Eval , & where ) ; # endif string comp ; if ( error ) comp = " ▁ ( Value ▁ = ▁ Error ) " ; else { if ( resultEvaluated != result ) comp = " ▁ ( Value ▁ = ▁ \ " " + resultEvaluated + " \ " ) " ; } switch ( where ) { case UFormElm :: ValueForm : Label . SetWindowText ( ( SavedLabel + comp ) . c_str ( ) ) ; break ; case UFormElm :: ValueParentForm : Label . SetWindowText ( ( SavedLabel + " ▁ ( in ▁ parent ▁ form ) " + comp ) . c_str ( ) ) ; break ; case UFormElm :: ValueDefaultDfn : Label . SetWindowText ( ( SavedLabel + " ▁ ( default ▁ DFN ▁ value ) " + comp ) . c_str ( ) ) ; break ; case UFormElm :: ValueDefaultType : Label . SetWindowText ( ( SavedLabel + " ▁ ( default ▁ TYPE ▁ value ) " + comp ) . c_str ( ) ) ; break ; } } else { const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( FormName . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; if ( node ) { if ( node -> getForm ( ) == doc -> getFormPtr ( ) ) { Label . SetWindowText ( SavedLabel . c_str ( ) ) ; } else { Label . SetWindowText ( ( SavedLabel + " ▁ ( in ▁ parent ▁ form ) " ) . c_str ( ) ) ; } } else { Label . SetWindowText ( ( SavedLabel + " ▁ ( undefined ) " ) . c_str ( ) ) ; } } Label . UpdateData ( FALSE ) ; } } } } IFormWidget :: TTypeSrc IFormWidget :: getSrcType ( ) const { return SrcType ; } bool IFormWidget :: extendableHeight ( ) const { return false ; } bool IFormWidget :: getNode ( const CFormDfn * * parentDfn , uint & lastElement , const CFormDfn * * nodeDfn , const CType * * nodeType , CFormElm * * node , UFormDfn :: TEntryType & type , bool & array ) const { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; if ( doc ) { bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; return ( elm -> getNodeByName ( FormName . c_str ( ) , parentDfn , lastElement , nodeDfn , nodeType , node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; } return false ; } CFormElm * IFormWidget :: getFormElmNode ( ) const { const CFormDfn * parentDfn ; uint parentDfnIndex ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; if ( getNode ( & parentDfn , parentDfnIndex , & nodeDfn , & nodeType , & node , type , array ) ) { return node ; } return NULL ; } CFormElmStruct * IFormWidget :: getFormElmStructNode ( ) const { CFormElm * elm = getFormElmNode ( ) ; return elm ? safe_cast < CFormElmStruct * > ( elm ) : NULL ; } CFormElmVirtualStruct * IFormWidget :: getFormElmVirtualStructNode ( ) const { CFormElm * elm = getFormElmNode ( ) ; return elm ? safe_cast < CFormElmVirtualStruct * > ( elm ) : NULL ; } CFormElmArray * IFormWidget :: getFormElmArrayNode ( ) const { CFormElm * elm = getFormElmNode ( ) ; return elm ? safe_cast < CFormElmArray * > ( elm ) : NULL ; } CFormElmAtom * IFormWidget :: getFormElmAtomNode ( ) const { CFormElm * elm = getFormElmNode ( ) ; return elm ? safe_cast < CFormElmAtom * > ( elm ) : NULL ; } const string & IFormWidget :: getFormName ( ) const { return FormName ; } uint IFormWidget :: getNumValue ( ) { nlstop ; return 0 ; } void IFormWidget :: getValue ( std :: string & result ) { nlstop ; } void IFormWidget :: getValue ( std :: string & result , uint value ) { nlstop ; } bool IFormWidget :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Label ) ) { Label . GetWindowRect ( & rect ) ; return true ; } else return false ; } void IFormWidget :: onOpenSelected ( ) { string str ; getValue ( str ) ; std :: string str2 = CPath :: lookup ( str . c_str ( ) , false , false ) ; if ( str2 . empty ( ) ) str2 = str . c_str ( ) ; theApp . OpenDocumentFile ( str2 . c_str ( ) ) ; } CFormMemCombo :: CFormMemCombo ( CFormDialog * dialog , uint structId , const char * atomName , TTypeSrc typeSrc , uint slot ) : IFormWidget ( dialog , structId , atomName , typeSrc , slot ) { UseSpinner = false ; FileBrowser = false ; } CFormMemCombo :: ~ CFormMemCombo ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( Combo ) ) Combo . DestroyWindow ( ) ; if ( IsWindow ( Spin ) ) Spin . DestroyWindow ( ) ; if ( IsWindow ( Browse ) ) Browse . DestroyWindow ( ) ; } void CFormMemCombo :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label , const char * reg , bool useSpinner , bool fileBrowser , const char * filenameExt ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType = NULL ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( FormName . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; FirstId = dialog_index ; LastId = FirstId + 1 ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; UseSpinner = useSpinner ; FileBrowser = fileBrowser ; if ( useSpinner ) { parent -> setComboSpinSize ( currentPos ) ; Combo . create ( WS_CHILD | WS_TABSTOP , currentPos , parent , dialog_index , reg , theApp . RememberListSize ) ; parent -> initWidget ( Combo ) ; RECT spinPos = currentPos ; parent -> getNextSpinPos ( spinPos ) ; parent -> setSpinSize ( spinPos ) ; Spin . Create ( WS_CHILD | WS_VISIBLE , spinPos , parent , dialog_index + 1 ) ; parent -> getNextPos ( currentPos ) ; } else if ( fileBrowser ) { parent -> setComboBrowseSize ( currentPos ) ; Combo . create ( WS_CHILD | WS_TABSTOP , currentPos , parent , dialog_index , reg , theApp . RememberListSize ) ; parent -> initWidget ( Combo ) ; RECT spinPos = currentPos ; parent -> getNextBrowsePos ( spinPos ) ; parent -> setBrowseSize ( spinPos ) ; Browse . Create ( " . . . " , WS_CHILD | WS_VISIBLE | WS_TABSTOP , spinPos , parent , dialog_index + 1 ) ; parent -> initWidget ( Browse ) ; parent -> getNextPos ( currentPos ) ; if ( filenameExt ) { if ( strcmp ( filenameExt , " * . * " ) != 0 ) Combo . enableAutoCompleteExtension ( true , filenameExt ) ; } } else { parent -> setComboSize ( currentPos , parent -> SmallWidget ) ; Combo . create ( WS_CHILD | WS_TABSTOP , currentPos , parent , dialog_index , reg , theApp . RememberListSize ) ; parent -> initWidget ( Combo ) ; parent -> getNextPos ( currentPos ) ; } if ( nodeType ) { for ( uint predef = 0 ; predef < nodeType -> Definitions . size ( ) ; predef ++ ) { Combo . addStaticStrings ( nodeType -> Definitions [ predef ] . Label . c_str ( ) ) ; } } dialog_index += 2 ; } void CFormMemCombo :: updateData ( bool update ) { Combo . UpdateData ( update ? TRUE : FALSE ) ; } bool CFormMemCombo :: haveFocus ( ) { return ( Combo . haveFocus ( ) ) ; } void CFormMemCombo :: setFocus ( ) { Combo . SetFocus ( ) ; } void CFormMemCombo :: onOk ( ) { Combo . onOK ( ) ; } void CFormMemCombo :: getValue ( std :: string & result ) { Combo . UpdateData ( ) ; CString str ; Combo . GetWindowText ( str ) ; Combo . UpdateData ( FALSE ) ; result = ( const char * ) str ; } void CFormMemCombo :: getFromDocument ( CForm & form ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; if ( ( SrcType == TypeForm ) || ( SrcType == TypeType ) ) { string result ; if ( doc -> getRootNode ( getSlot ( ) ) -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , NULL ) ) { Combo . UpdateData ( ) ; Combo . SetWindowText ( result . c_str ( ) ) ; Combo . UpdateData ( FALSE ) ; updateLabel ( ) ; } else { nlstop ; } } else if ( SrcType == TypeArray ) { const CFormDfn * parentDfn ; uint lastElement ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; nlverify ( ( ( const CFormElm * ) doc -> getRootNode ( getSlot ( ) ) ) -> getNodeByName ( FormName . c_str ( ) , & parentDfn , lastElement , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; nlassert ( array ) ; Combo . UpdateData ( ) ; if ( node ) { CFormElmArray * arrayNode = safe_cast < CFormElmArray * > ( node ) ; char label [ 512 ] ; smprintf ( label , 512 , " % d " , arrayNode -> Elements . size ( ) ) ; Combo . SetWindowText ( label ) ; if ( arrayNode -> getForm ( ) == & form ) Label . SetWindowText ( " Array ▁ size : " ) ; else Label . SetWindowText ( " Array ▁ size : ▁ ( in ▁ parent ▁ form ) " ) ; } else { Combo . SetWindowText ( "0" ) ; } Combo . UpdateData ( FALSE ) ; } else if ( SrcType == TypeVirtualDfn ) { const CFormDfn * parentDfn ; uint lastElement ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; nlverify ( ( ( const CFormElm * ) doc -> getRootNode ( getSlot ( ) ) ) -> getNodeByName ( FormName . c_str ( ) , & parentDfn , lastElement , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; nlassert ( ! array ) ; Combo . UpdateData ( ) ; if ( node ) { CFormElmVirtualStruct * virtualNode = safe_cast < CFormElmVirtualStruct * > ( node ) ; Combo . SetWindowText ( virtualNode -> DfnFilename . c_str ( ) ) ; } else { Combo . SetWindowText ( " " ) ; } Combo . UpdateData ( FALSE ) ; } } bool CFormMemCombo :: isWnd ( const CWnd * wnd ) const { return Combo . isWnd ( wnd ) ; } void CFormMemCombo :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; if ( UseSpinner ) { Dialog -> setComboSpinSize ( currentPos ) ; if ( resize ) { Combo . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } RECT spinPos = currentPos ; Dialog -> getNextSpinPos ( spinPos ) ; Dialog -> setSpinSize ( spinPos ) ; if ( resize ) { Spin . SetWindowPos ( NULL , spinPos . left , spinPos . top , spinPos . right - spinPos . left , spinPos . bottom - spinPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } } else if ( FileBrowser ) { Dialog -> setComboBrowseSize ( currentPos ) ; if ( resize ) { Combo . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } RECT spinPos = currentPos ; Dialog -> getNextBrowsePos ( spinPos ) ; Dialog -> setBrowseSize ( spinPos ) ; if ( resize ) { Browse . SetWindowPos ( NULL , spinPos . left , spinPos . top , spinPos . right - spinPos . left , spinPos . bottom - spinPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } } else { Dialog -> setComboSize ( currentPos , Dialog -> SmallWidget ) ; if ( resize ) { Combo . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } } Dialog -> getNextPos ( currentPos ) ; } bool CFormMemCombo :: getWindowRect ( RECT & rect ) const { if ( Combo ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; Combo . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } CFormCombo :: CFormCombo ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { } CFormCombo :: ~ CFormCombo ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( Combo ) ) Combo . DestroyWindow ( ) ; } void CFormCombo :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; FirstId = dialog_index ; LastId = FirstId ; const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( FormName . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setComboSize ( currentPos , parent -> SmallWidget ) ; RECT comboPos = currentPos ; parent -> adjusteComboSize ( comboPos ) ; Combo . Create ( WS_CHILD | WS_VSCROLL | WS_VISIBLE | CBS_DROPDOWNLIST | CBS_HASSTRINGS | WS_CHILD | WS_TABSTOP , comboPos , parent , dialog_index ) ; parent -> initWidget ( Combo ) ; parent -> getNextPos ( currentPos ) ; if ( nodeType ) { Combo . InsertString ( 0 , " " ) ; for ( uint predef = 0 ; predef < nodeType -> Definitions . size ( ) ; predef ++ ) { Combo . InsertString ( predef + 1 , nodeType -> Definitions [ predef ] . Label . c_str ( ) ) ; } } dialog_index += 1 ; } void CFormCombo :: updateData ( bool update ) { Combo . UpdateData ( update ? TRUE : FALSE ) ; } bool CFormCombo :: haveFocus ( ) { CWnd * focus = CWnd :: GetFocus ( ) ; if ( focus ) { return ( focus == & Combo ) ; } return false ; } void CFormCombo :: setFocus ( ) { Combo . SetFocus ( ) ; } void CFormCombo :: onOk ( ) { } void CFormCombo :: getValue ( std :: string & result ) { Combo . UpdateData ( ) ; CString str ; Combo . GetWindowText ( str ) ; Combo . UpdateData ( FALSE ) ; result = ( const char * ) str ; } void CFormCombo :: getFromDocument ( CForm & form ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; string result ; if ( doc -> getRootNode ( getSlot ( ) ) -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , NULL ) ) { Combo . UpdateData ( ) ; uint itemCount = Combo . GetCount ( ) ; for ( uint i = 0 ; i < itemCount ; i ++ ) { CString item ; Combo . GetLBText ( i , item ) ; if ( item == result . c_str ( ) ) { Combo . SetCurSel ( i ) ; break ; } } Combo . UpdateData ( FALSE ) ; updateLabel ( ) ; } else { nlstop ; } } bool CFormCombo :: isWnd ( const CWnd * wnd ) const { return & Combo == ( const CWnd * ) wnd ; } void CFormCombo :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setComboSize ( currentPos , Dialog -> SmallWidget ) ; if ( resize ) { RECT comboPos = currentPos ; Dialog -> adjusteComboSize ( comboPos ) ; Combo . SetWindowPos ( NULL , comboPos . left , comboPos . top , comboPos . right - comboPos . left , comboPos . bottom - comboPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CFormCombo :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Combo ) ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; Combo . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } CFormBigEdit :: CFormBigEdit ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { } CFormBigEdit :: ~ CFormBigEdit ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( Edit ) ) Edit . DestroyWindow ( ) ; } void CFormBigEdit :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label ) { FirstId = dialog_index ; LastId = FirstId ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setBigEditSize ( currentPos , parent -> SmallWidget ) ; Edit . CreateEx ( WS_EX_CLIENTEDGE , _T ( " EDIT " ) , " " , WS_VSCROLL | ES_OEMCONVERT | ES_MULTILINE | ES_WANTRETURN | WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_AUTOHSCROLL | ES_AUTOVSCROLL , currentPos , parent , dialog_index ) ; parent -> initWidget ( Edit ) ; parent -> getNextPos ( currentPos ) ; dialog_index += 1 ; } void CFormBigEdit :: updateData ( bool update ) { Edit . UpdateData ( update ? TRUE : FALSE ) ; } bool CFormBigEdit :: haveFocus ( ) { CWnd * focus = CWnd :: GetFocus ( ) ; if ( focus ) { return ( focus == & Edit ) ; } return false ; } void CFormBigEdit :: setFocus ( ) { Edit . SetFocus ( ) ; } void CFormBigEdit :: onOk ( ) { } void CFormBigEdit :: getValue ( std :: string & result ) { Edit . UpdateData ( ) ; CString str ; Edit . GetWindowText ( str ) ; Edit . UpdateData ( FALSE ) ; result = ( const char * ) str ; } void CFormBigEdit :: getFromDocument ( CForm & form ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; string result ; if ( doc -> getRootNode ( getSlot ( ) ) -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , NULL ) ) { Edit . UpdateData ( ) ; Dialog -> setEditTextMultiLine ( Edit , result . c_str ( ) ) ; Edit . UpdateData ( FALSE ) ; updateLabel ( ) ; } else { nlstop ; } } bool CFormBigEdit :: isWnd ( const CWnd * wnd ) const { return & Edit == wnd ; } void CFormBigEdit :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { if ( ! resize ) widgetCount ++ ; Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setBigEditSize ( currentPos , Dialog -> SmallWidgetNotLimited , Dialog -> BigEditHeight + adjust ) ; if ( resize ) { Edit . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CFormBigEdit :: extendableHeight ( ) const { return true ; } bool CFormBigEdit :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Edit ) ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; Edit . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } CColorEdit :: CColorEdit ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { Empty = true ; } CColorEdit :: ~ CColorEdit ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( Color ) ) Color . DestroyWindow ( ) ; if ( IsWindow ( Edit ) ) Edit . DestroyWindow ( ) ; } void CColorEdit :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label ) { FirstId = dialog_index ; LastId = FirstId + 2 ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setColorSize ( currentPos , parent -> SmallWidget ) ; Color . create ( WS_CHILD | WS_VISIBLE | WS_TABSTOP , currentPos , parent , dialog_index ) ; parent -> initWidget ( Color ) ; RECT resetPos = currentPos ; parent -> getNextColorPos ( resetPos ) ; parent -> setResetColorSize ( resetPos ) ; Reset . Create ( " Reset " , WS_CHILD | WS_VISIBLE | WS_TABSTOP , resetPos , parent , dialog_index + 1 ) ; parent -> initWidget ( Reset ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setBigEditSize ( currentPos , parent -> SmallWidget ) ; Edit . CreateEx ( WS_EX_CLIENTEDGE , _T ( " EDIT " ) , " " , ES_OEMCONVERT | ES_WANTRETURN | WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_AUTOHSCROLL , currentPos , parent , dialog_index + 2 ) ; parent -> initWidget ( Edit ) ; parent -> getNextPos ( currentPos ) ; Color . setEdit ( & Edit ) ; dialog_index += 3 ; } void CColorEdit :: updateData ( bool update ) { Color . UpdateData ( update ? TRUE : FALSE ) ; Edit . UpdateData ( update ? TRUE : FALSE ) ; } bool CColorEdit :: haveFocus ( ) { CWnd * focus = CWnd :: GetFocus ( ) ; if ( focus ) { return ( focus == & Color ) ; } return false ; } void CColorEdit :: setFocus ( ) { Color . SetFocus ( ) ; } void CColorEdit :: onOk ( ) { } void CColorEdit :: getValue ( std :: string & result ) { if ( ! Empty ) { Color . UpdateData ( ) ; CRGBA color = Color . getColor ( ) ; char colorName [ 512 ] ; smprintf ( colorName , 512 , " % d , % d , % d " , color . R , color . G , color . B ) ; result = colorName ; } else { result = " " ; } } void CColorEdit :: getFromDocument ( CForm & form ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; string result ; if ( doc -> getRootNode ( getSlot ( ) ) -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , NULL ) ) { Color . UpdateData ( ) ; sint r , g , b ; if ( sscanf ( result . c_str ( ) , " % d , % d , % d " , & r , & g , & b ) == 3 ) { clamp ( r , 0 , 255 ) ; clamp ( g , 0 , 255 ) ; clamp ( b , 0 , 255 ) ; CRGBA color ( r , g , b ) ; Color . setColor ( color ) ; if ( r != 255 && g != 255 && b != 255 ) Color . updateEdit ( ) ; } else { Color . setColor ( CRGBA :: Black ) ; Color . updateEdit ( ) ; } Color . UpdateData ( FALSE ) ; updateLabel ( ) ; } else { nlstop ; } } bool CColorEdit :: isWnd ( const CWnd * wnd ) const { return & Color == wnd ; } void CColorEdit :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setColorSize ( currentPos , Dialog -> SmallWidget ) ; if ( resize ) { Color . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } RECT resetPos = currentPos ; Dialog -> getNextColorPos ( resetPos ) ; Dialog -> setResetColorSize ( resetPos ) ; if ( resize ) { Reset . SetWindowPos ( NULL , resetPos . left , resetPos . top , resetPos . right - resetPos . left , resetPos . bottom - resetPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setEditSize ( currentPos , Dialog -> SmallWidget , Dialog -> EditHeight ) ; if ( resize ) { Edit . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CColorEdit :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Color ) ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; Color . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } CListWidget :: CListWidget ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { ListCtrl . Ctrl = this ; } CListWidget :: ~ CListWidget ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( ListCtrl ) ) ListCtrl . DestroyWindow ( ) ; if ( IsWindow ( Button ) ) Button . DestroyWindow ( ) ; } void CListWidget :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label , const char * reg , uint divid ) { FirstId = dialog_index ; LastId = FirstId + 1 ; Divid = divid ; RegAdr = reg ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setListSize ( currentPos , parent -> SmallWidget ) ; ListCtrl . create ( WS_CHILD | WS_VISIBLE | WS_TABSTOP , currentPos , parent , dialog_index ) ; parent -> initWidget ( ListCtrl ) ; parent -> getNextPos ( currentPos ) ; parent -> setButtonSize ( currentPos , parent -> SmallWidget ) ; Button . Create ( " Assign ▁ parents " , WS_CHILD | WS_VISIBLE | WS_TABSTOP , currentPos , parent , dialog_index + 1 ) ; parent -> initWidget ( Button ) ; parent -> getNextPos ( currentPos ) ; dialog_index += 2 ; } void CListWidget :: addColumn ( const char * name ) { ListCtrl . insertColumn ( 0 , name ) ; ListCtrl . recalcColumn ( ) ; } void CListWidget :: onOk ( ) { ListCtrl . onOK ( ) ; } void CListWidget :: updateData ( bool update ) { ListCtrl . UpdateData ( update ) ; } bool CListWidget :: haveFocus ( ) { CWnd * wnd = Dialog -> GetFocus ( ) ; if ( wnd ) { return ( wnd -> GetParent ( ) == & ListCtrl ) ; } return false ; } void CListWidget :: setFocus ( ) { ListCtrl . SetFocus ( ) ; } void CListWidget :: getFromDocument ( NLGEORGES :: CForm & form ) { ListCtrl . ListCtrl . DeleteAllItems ( ) ; for ( uint parent = 0 ; parent < form . getParentCount ( ) ; parent ++ ) { string filename = form . getParentFilename ( parent ) ; ListCtrl . ListCtrl . InsertItem ( parent , filename . c_str ( ) ) ; ListCtrl . ListCtrl . UpdateData ( FALSE ) ; updateLabel ( ) ; } } uint CListWidget :: getNumValue ( ) { return ListCtrl . ListCtrl . GetItemCount ( ) ; } void CListWidget :: getValue ( std :: string & result , uint value ) { CString str = ListCtrl . ListCtrl . GetItemText ( value , 0 ) ; result = str ; } bool CListWidget :: isWnd ( const CWnd * wnd ) const { return ( ( ( & ListCtrl ) == wnd ) || ( ( & ListCtrl . ListCtrl ) == wnd ) ) ; } void CListWidget :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { if ( ! resize ) widgetCount ++ ; Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setListSize ( currentPos , Dialog -> SmallWidgetNotLimited / Divid , Dialog -> ListHeight + adjust ) ; if ( resize ) { ListCtrl . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; ListCtrl . recalcColumn ( ) ; } Dialog -> getNextPos ( currentPos ) ; Dialog -> setButtonSize ( currentPos , Dialog -> SmallWidget ) ; if ( resize ) { Button . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CListWidget :: extendableHeight ( ) const { return true ; } CEditListCtrl :: TItemEdit CListWidget :: CMyEditListCtrl :: getItemEditMode ( uint item , uint subItem ) { return CEditListCtrl :: EditMemCombo ; } void CListWidget :: CMyEditListCtrl :: getMemComboBoxProp ( uint item , uint subItem , std :: string & regAdr , bool & browse ) { regAdr = Ctrl -> RegAdr ; browse = true ; } void CListWidget :: CMyEditListCtrl :: getNewItemText ( uint item , uint subItem , std :: string & ret ) { Ctrl -> Dialog -> getDfnName ( ret ) ; ret = " default . " + ret ; } void CListWidget :: CMyEditListCtrl :: getBrowseInfo ( uint item , uint subItem , std :: string & defExt , std :: string & defFilename , std :: string & defDir , std :: string & filter ) { string ret ; Ctrl -> Dialog -> getDfnName ( ret ) ; defExt = " * . " + ret ; defFilename = defExt ; filter = " Form ▁ Files ▁ ( * . " + ret + " ) | * . " + ret + " | All ▁ Files ▁ ( * . * ) | * . * | | " ; defDir = theApp . RootSearchPath ; } bool CListWidget :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( ListCtrl ) ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; ListCtrl . ListCtrl . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } void CListWidget :: onOpenSelected ( ) { POSITION pos = ListCtrl . ListCtrl . GetFirstSelectedItemPosition ( ) ; while ( pos ) { int nItem = ListCtrl . ListCtrl . GetNextSelectedItem ( pos ) ; CString str = ListCtrl . ListCtrl . GetItemText ( nItem , 0 ) ; if ( str != " " ) { string name = CPath :: lookup ( ( const char * ) str , false , false ) ; if ( name . empty ( ) ) name = str ; theApp . OpenDocumentFile ( name . c_str ( ) ) ; } } } CIconWidget :: CIconWidget ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { } CIconWidget :: ~ CIconWidget ( ) { if ( IsWindow ( Icon ) ) Icon . DestroyWindow ( ) ; } void CIconWidget :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label ) { FirstId = dialog_index ; LastId = FirstId ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setEditSize ( currentPos , parent -> IconHeight , parent -> IconHeight ) ; Icon . create ( WS_CHILD | WS_VISIBLE | WS_TABSTOP , currentPos , parent , dialog_index ) ; parent -> initWidget ( Icon ) ; parent -> getNextPos ( currentPos ) ; dialog_index += 1 ; } void CIconWidget :: updateData ( bool update ) { Icon . UpdateData ( update ? TRUE : FALSE ) ; } bool CIconWidget :: haveFocus ( ) { CWnd * focus = CWnd :: GetFocus ( ) ; if ( focus ) { return ( focus == & Icon ) ; } return false ; } void CIconWidget :: setFocus ( ) { Icon . SetFocus ( ) ; } void CIconWidget :: onOk ( ) { } void CIconWidget :: getValue ( std :: string & result ) { result = " " ; } void CIconWidget :: getFromDocument ( CForm & form ) { } bool CIconWidget :: isWnd ( const CWnd * wnd ) const { return & Icon == wnd ; } void CIconWidget :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setEditSize ( currentPos , Dialog -> IconHeight , Dialog -> IconHeight ) ; if ( resize ) { Icon . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CIconWidget :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Icon ) ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; Icon . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } </DOCUMENT>
<DOCUMENT_ID="regneq/TrinityCore/tree/master/src/server/game/Miscellaneous/CommonPredicates.cpp"> # include " CommonPredicates . h " # include " Common . h " # include " Unit . h " # include " SharedDefines . h " Trinity :: Predicates :: IsVictimOf :: IsVictimOf ( Unit const * attacker ) : _victim ( attacker ? attacker -> GetVictim ( ) : nullptr ) { } </DOCUMENT>
<DOCUMENT_ID="Maximus-/WinObjC/tree/master/deps/3rdparty/icu/icu/source/layout/TibetanReordering.cpp"> # include " LETypes . h " # include " OpenTypeTables . h " # include " TibetanReordering . h " # include " LEGlyphStorage . h " U_NAMESPACE_BEGIN enum { C_DOTTED_CIRCLE = 0x25CC , C_PRE_NUMBER_MARK = 0x0F3F } ; enum { _xx = TibetanClassTable :: CC_RESERVED , _ba = TibetanClassTable :: CC_BASE , _sj = TibetanClassTable :: CC_SUBJOINED | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _tp = TibetanClassTable :: CC_TSA_PHRU | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _ac = TibetanClassTable :: CC_A_CHUNG | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _cs = TibetanClassTable :: CC_COMP_SANSKRIT | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _ha = TibetanClassTable :: CC_HALANTA | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _bv = TibetanClassTable :: CC_BELOW_VOWEL | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _av = TibetanClassTable :: CC_ABOVE_VOWEL | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _an = TibetanClassTable :: CC_ANUSVARA | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _cb = TibetanClassTable :: CC_CANDRABINDU | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _vs = TibetanClassTable :: CC_VISARGA | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_AFTER , _as = TibetanClassTable :: CC_ABOVE_S_MARK | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _bs = TibetanClassTable :: CC_BELOW_S_MARK | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _di = TibetanClassTable :: CC_DIGIT | TibetanClassTable :: CF_DIGIT , _pd = TibetanClassTable :: CC_PRE_DIGIT_MARK | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_PREDIGIT | TibetanClassTable :: CF_POS_BEFORE , _bd = TibetanClassTable :: CC_POST_BELOW_DIGIT_M | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_AFTER } ; static const TibetanClassTable :: CharClass tibetanCharClasses [ ] = { _xx , _ba , _xx , _xx , _ba , _ba , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _bd , _bd , _xx , _xx , _xx , _xx , _xx , _xx , _di , _di , _di , _di , _di , _di , _di , _di , _di , _di , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _bs , _xx , _bs , _xx , _tp , _xx , _xx , _xx , _xx , _bd , _pd , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _xx , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _xx , _xx , _xx , _xx , _xx , _xx , _ac , _av , _cs , _bv , _bv , _cs , _cs , _cs , _cs , _av , _av , _av , _av , _an , _vs , _av , _cs , _cb , _cb , _ha , _xx , _as , _as , _ba , _ba , _ba , _ba , _xx , _xx , _xx , _xx , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _xx , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _xx , _sj , _sj , _xx , _xx , _xx , _xx , _xx , _xx , _bs , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , } ; static const TibetanClassTable tibetanClassTable = { 0x0F00 , 0x0FFF , tibetanCharClasses } ; TibetanClassTable :: CharClass TibetanClassTable :: getCharClass ( LEUnicode ch ) const { if ( ch < firstChar || ch > lastChar ) { return CC_RESERVED ; } return classTable [ ch - firstChar ] ; } const TibetanClassTable * TibetanClassTable :: getTibetanClassTable ( ) { return & tibetanClassTable ; } class TibetanReorderingOutput : public UMemory { private : le_int32 fSyllableCount ; le_int32 fOutIndex ; LEUnicode * fOutChars ; LEGlyphStorage & fGlyphStorage ; public : TibetanReorderingOutput ( LEUnicode * outChars , LEGlyphStorage & glyphStorage ) : fSyllableCount ( 0 ) , fOutIndex ( 0 ) , fOutChars ( outChars ) , fGlyphStorage ( glyphStorage ) { } ~ TibetanReorderingOutput ( ) { } void reset ( ) { fSyllableCount += 1 ; } void writeChar ( LEUnicode ch , le_uint32 charIndex , FeatureMask featureMask ) { LEErrorCode success = LE_NO_ERROR ; fOutChars [ fOutIndex ] = ch ; fGlyphStorage . setCharIndex ( fOutIndex , charIndex , success ) ; fGlyphStorage . setAuxData ( fOutIndex , featureMask , success ) ; fOutIndex += 1 ; } le_int32 getOutputIndex ( ) { return fOutIndex ; } } ; # define ccmpFeatureTag LE_CCMP_FEATURE_TAG # define blwfFeatureTag LE_BLWF_FEATURE_TAG # define pstfFeatureTag LE_PSTF_FEATURE_TAG # define presFeatureTag LE_PRES_FEATURE_TAG # define blwsFeatureTag LE_BLWS_FEATURE_TAG # define abvsFeatureTag LE_ABVS_FEATURE_TAG # define pstsFeatureTag LE_PSTS_FEATURE_TAG # define blwmFeatureTag LE_BLWM_FEATURE_TAG # define abvmFeatureTag LE_ABVM_FEATURE_TAG # define distFeatureTag LE_DIST_FEATURE_TAG # define prefFeatureTag LE_PREF_FEATURE_TAG # define abvfFeatureTag LE_ABVF_FEATURE_TAG # define cligFeatureTag LE_CLIG_FEATURE_TAG # define mkmkFeatureTag LE_MKMK_FEATURE_TAG # define prefFeatureMask 0x80000000UL # define blwfFeatureMask 0x40000000UL # define abvfFeatureMask 0x20000000UL # define pstfFeatureMask 0x10000000UL # define presFeatureMask 0x08000000UL # define blwsFeatureMask 0x04000000UL # define abvsFeatureMask 0x02000000UL # define pstsFeatureMask 0x01000000UL # define cligFeatureMask 0x00800000UL # define ccmpFeatureMask 0x00040000UL # define distFeatureMask 0x00400000UL # define blwmFeatureMask 0x00200000UL # define abvmFeatureMask 0x00100000UL # define mkmkFeatureMask 0x00080000UL # define tagPref ( ccmpFeatureMask | prefFeatureMask | presFeatureMask | cligFeatureMask | distFeatureMask ) # define tagAbvf ( ccmpFeatureMask | abvfFeatureMask | abvsFeatureMask | cligFeatureMask | distFeatureMask | abvmFeatureMask | mkmkFeatureMask ) # define tagPstf ( ccmpFeatureMask | blwfFeatureMask | blwsFeatureMask | prefFeatureMask | presFeatureMask | pstfFeatureMask | pstsFeatureMask | cligFeatureMask | distFeatureMask | blwmFeatureMask ) # define tagBlwf ( ccmpFeatureMask | blwfFeatureMask | blwsFeatureMask | cligFeatureMask | distFeatureMask | blwmFeatureMask | mkmkFeatureMask ) # define tagDefault ( ccmpFeatureMask | prefFeatureMask | blwfFeatureMask | presFeatureMask | blwsFeatureMask | cligFeatureMask | distFeatureMask | abvmFeatureMask | blwmFeatureMask | mkmkFeatureMask ) static const FeatureMap featureMap [ ] = { { ccmpFeatureTag , ccmpFeatureMask } , { prefFeatureTag , prefFeatureMask } , { blwfFeatureTag , blwfFeatureMask } , { abvfFeatureTag , abvfFeatureMask } , { pstfFeatureTag , pstfFeatureMask } , { presFeatureTag , presFeatureMask } , { blwsFeatureTag , blwsFeatureMask } , { abvsFeatureTag , abvsFeatureMask } , { pstsFeatureTag , pstsFeatureMask } , { cligFeatureTag , cligFeatureMask } , { distFeatureTag , distFeatureMask } , { blwmFeatureTag , blwmFeatureMask } , { abvmFeatureTag , abvmFeatureMask } , { mkmkFeatureTag , mkmkFeatureMask } , } ; static const le_int32 featureMapCount = LE_ARRAY_SIZE ( featureMap ) ; static const le_int8 tibetanStateTable [ ] [ TibetanClassTable :: CC_COUNT ] = { { 1 , 2 , 4 , 3 , 8 , 7 , 9 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , 20 , 21 , 21 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , 4 , 3 , 8 , 7 , 9 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , 5 , - 1 , 8 , 7 , - 1 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , 4 , 6 , 8 , 7 , 9 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , 5 , - 1 , 8 , 7 , - 1 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , 8 , 7 , - 1 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 14 , 13 , 17 , - 1 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 11 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 12 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 14 , 17 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 15 , 17 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 16 , 17 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 17 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 21 , 21 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , } , } ; const FeatureMap * TibetanReordering :: getFeatureMap ( le_int32 & count ) { count = featureMapCount ; return featureMap ; } le_int32 TibetanReordering :: findSyllable ( const TibetanClassTable * classTable , const LEUnicode * chars , le_int32 prev , le_int32 charCount ) { le_int32 cursor = prev ; le_int8 state = 0 ; while ( cursor < charCount ) { TibetanClassTable :: CharClass charClass = ( classTable -> getCharClass ( chars [ cursor ] ) & TibetanClassTable :: CF_CLASS_MASK ) ; state = tibetanStateTable [ state ] [ charClass ] ; if ( state < 0 ) { break ; } cursor += 1 ; } return cursor ; } le_int32 TibetanReordering :: reorder ( const LEUnicode * chars , le_int32 charCount , le_int32 , LEUnicode * outChars , LEGlyphStorage & glyphStorage ) { const TibetanClassTable * classTable = TibetanClassTable :: getTibetanClassTable ( ) ; TibetanReorderingOutput output ( outChars , glyphStorage ) ; TibetanClassTable :: CharClass charClass ; le_int32 i , prev = 0 ; while ( prev < charCount ) { le_int32 syllable = findSyllable ( classTable , chars , prev , charCount ) ; output . reset ( ) ; if ( classTable -> getCharClass ( chars [ prev ] ) & TibetanClassTable :: CF_DOTTED_CIRCLE ) { output . writeChar ( C_DOTTED_CIRCLE , prev , tagDefault ) ; } for ( i = prev ; i < syllable ; i += 1 ) { charClass = classTable -> getCharClass ( chars [ i ] ) ; if ( ( TibetanClassTable :: CF_DIGIT & charClass ) && ( classTable -> getCharClass ( chars [ i + 1 ] ) & TibetanClassTable :: CF_PREDIGIT ) ) { output . writeChar ( C_PRE_NUMBER_MARK , i , tagPref ) ; output . writeChar ( chars [ i ] , i + 1 , tagPref ) ; i += 1 ; } else { switch ( charClass & TibetanClassTable :: CF_POS_MASK ) { case TibetanClassTable :: CF_POS_ABOVE : output . writeChar ( chars [ i ] , i , tagAbvf ) ; break ; case TibetanClassTable :: CF_POS_AFTER : output . writeChar ( chars [ i ] , i , tagPstf ) ; break ; case TibetanClassTable :: CF_POS_BELOW : output . writeChar ( chars [ i ] , i , tagBlwf ) ; break ; default : output . writeChar ( chars [ i ] , i , tagDefault ) ; break ; } } } prev = syllable ; } return output . getOutputIndex ( ) ; } U_NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="yantrabuddhi/FreeCAD/tree/master/src/3rdParty/salomesmesh/src/Driver/Driver_Document.cpp"> # include " Driver _ Document . h " Driver_Document :: Driver_Document ( ) : myDocument ( NULL ) { } void Driver_Document :: SetFile ( const std :: string & theFileName ) { myFile = theFileName ; } void Driver_Document :: SetDocument ( SMESHDS_Document * theDocument ) { myDocument = theDocument ; } </DOCUMENT>
<DOCUMENT_ID="fbergmann/libSEDML/tree/master/sedml/SedDocument.cpp"> # include < sedml / SedDocument . h > # include < sedml / SedTypes . h > # include < sbml / xml / XMLInputStream . h > using namespace std ; LIBSEDML_CPP_NAMESPACE_BEGIN SedDocument :: SedDocument ( unsigned int level , unsigned int version ) : SedBase ( level , version ) , mLevel ( SEDML_INT_MAX ) , mIsSetLevel ( false ) , mVersion ( SEDML_INT_MAX ) , mIsSetVersion ( false ) , mDataDescriptions ( level , version ) , mSimulations ( level , version ) , mModels ( level , version ) , mTasks ( level , version ) , mDataGenerators ( level , version ) , mOutputs ( level , version ) { mLevel = level ; mIsSetLevel = true ; mVersion = version ; mIsSetVersion = true ; setSedDocument ( this ) ; setSedNamespacesAndOwn ( new SedNamespaces ( level , version ) ) ; connectToChild ( ) ; } SedDocument :: SedDocument ( SedNamespaces * sedns ) : SedBase ( sedns ) , mLevel ( SEDML_INT_MAX ) , mIsSetLevel ( false ) , mVersion ( SEDML_INT_MAX ) , mIsSetVersion ( false ) , mDataDescriptions ( sedns ) , mSimulations ( sedns ) , mModels ( sedns ) , mTasks ( sedns ) , mDataGenerators ( sedns ) , mOutputs ( sedns ) { mLevel = sedns -> getLevel ( ) ; mIsSetLevel = true ; mVersion = sedns -> getVersion ( ) ; mIsSetVersion = true ; setSedDocument ( this ) ; setElementNamespace ( sedns -> getURI ( ) ) ; connectToChild ( ) ; } SedDocument :: SedDocument ( const SedDocument & orig ) : SedBase ( orig ) { setSedDocument ( this ) ; mLevel = orig . mLevel ; mIsSetLevel = orig . mIsSetLevel ; mVersion = orig . mVersion ; mIsSetVersion = orig . mIsSetVersion ; mDataDescriptions = orig . mDataDescriptions ; mSimulations = orig . mSimulations ; mModels = orig . mModels ; mTasks = orig . mTasks ; mDataGenerators = orig . mDataGenerators ; mOutputs = orig . mOutputs ; connectToChild ( ) ; } SedDocument & SedDocument :: operator = ( const SedDocument & rhs ) { if ( & rhs != this ) { SedBase :: operator = ( rhs ) ; setSedDocument ( this ) ; mLevel = rhs . mLevel ; mIsSetLevel = rhs . mIsSetLevel ; mVersion = rhs . mVersion ; mIsSetVersion = rhs . mIsSetVersion ; mDataDescriptions = rhs . mDataDescriptions ; mSimulations = rhs . mSimulations ; mModels = rhs . mModels ; mTasks = rhs . mTasks ; mDataGenerators = rhs . mDataGenerators ; mOutputs = rhs . mOutputs ; connectToChild ( ) ; } return * this ; } SedDocument * SedDocument :: clone ( ) const { return new SedDocument ( * this ) ; } SedDocument :: ~ SedDocument ( ) { } const int SedDocument :: getLevel ( ) const { return mLevel ; } const int SedDocument :: getVersion ( ) const { return mVersion ; } bool SedDocument :: isSetLevel ( ) const { return mIsSetLevel ; } bool SedDocument :: isSetVersion ( ) const { return mIsSetVersion ; } int SedDocument :: setLevel ( int level ) { mLevel = level ; mIsSetLevel = true ; return LIBSEDML_OPERATION_SUCCESS ; } int SedDocument :: setVersion ( int version ) { mVersion = version ; mIsSetVersion = true ; return LIBSEDML_OPERATION_SUCCESS ; } int SedDocument :: unsetLevel ( ) { mLevel = SEDML_INT_MAX ; mIsSetLevel = false ; if ( isSetLevel ( ) == false ) { return LIBSEDML_OPERATION_SUCCESS ; } else { return LIBSEDML_OPERATION_FAILED ; } } int SedDocument :: unsetVersion ( ) { mVersion = SEDML_INT_MAX ; mIsSetVersion = false ; if ( isSetVersion ( ) == false ) { return LIBSEDML_OPERATION_SUCCESS ; } else { return LIBSEDML_OPERATION_FAILED ; } } const SedListOfDataDescriptions * SedDocument :: getListOfDataDescriptions ( ) const { return & mDataDescriptions ; } SedDataDescription * SedDocument :: removeDataDescription ( unsigned int n ) { return mDataDescriptions . remove ( n ) ; } SedDataDescription * SedDocument :: removeDataDescription ( const std :: string & sid ) { return mDataDescriptions . remove ( sid ) ; } SedDataDescription * SedDocument :: getDataDescription ( unsigned int n ) { return mDataDescriptions . get ( n ) ; } const SedDataDescription * SedDocument :: getDataDescription ( unsigned int n ) const { return mDataDescriptions . get ( n ) ; } SedDataDescription * SedDocument :: getDataDescription ( const std :: string & sid ) { return mDataDescriptions . get ( sid ) ; } const SedDataDescription * SedDocument :: getDataDescription ( const std :: string & sid ) const { return mDataDescriptions . get ( sid ) ; } int SedDocument :: addDataDescription ( const SedDataDescription * sdd ) { if ( sdd == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mDataDescriptions . append ( sdd ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumDataDescriptions ( ) const { return mDataDescriptions . size ( ) ; } SedDataDescription * SedDocument :: createDataDescription ( ) { SedDataDescription * temp = new SedDataDescription ( ) ; if ( temp != NULL ) mDataDescriptions . appendAndOwn ( temp ) ; return temp ; } const SedListOfSimulations * SedDocument :: getListOfSimulations ( ) const { return & mSimulations ; } SedSimulation * SedDocument :: removeSimulation ( unsigned int n ) { return mSimulations . remove ( n ) ; } SedSimulation * SedDocument :: removeSimulation ( const std :: string & sid ) { return mSimulations . remove ( sid ) ; } SedSimulation * SedDocument :: getSimulation ( unsigned int n ) { return mSimulations . get ( n ) ; } const SedSimulation * SedDocument :: getSimulation ( unsigned int n ) const { return mSimulations . get ( n ) ; } SedSimulation * SedDocument :: getSimulation ( const std :: string & sid ) { return mSimulations . get ( sid ) ; } const SedSimulation * SedDocument :: getSimulation ( const std :: string & sid ) const { return mSimulations . get ( sid ) ; } int SedDocument :: addSimulation ( const SedSimulation * ss ) { if ( ss == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mSimulations . append ( ss ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumSimulations ( ) const { return mSimulations . size ( ) ; } SedUniformTimeCourse * SedDocument :: createUniformTimeCourse ( ) { SedUniformTimeCourse * temp = new SedUniformTimeCourse ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; } SedOneStep * SedDocument :: createOneStep ( ) { SedOneStep * temp = new SedOneStep ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; } SedSteadyState * SedDocument :: createSteadyState ( ) { SedSteadyState * temp = new SedSteadyState ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; } const SedListOfModels * SedDocument :: getListOfModels ( ) const { return & mModels ; } SedModel * SedDocument :: removeModel ( unsigned int n ) { return mModels . remove ( n ) ; } SedModel * SedDocument :: removeModel ( const std :: string & sid ) { return mModels . remove ( sid ) ; } SedModel * SedDocument :: getModel ( unsigned int n ) { return mModels . get ( n ) ; } const SedModel * SedDocument :: getModel ( unsigned int n ) const { return mModels . get ( n ) ; } SedModel * SedDocument :: getModel ( const std :: string & sid ) { return mModels . get ( sid ) ; } const SedModel * SedDocument :: getModel ( const std :: string & sid ) const { return mModels . get ( sid ) ; } int SedDocument :: addModel ( const SedModel * sm ) { if ( sm == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mModels . append ( sm ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumModels ( ) const { return mModels . size ( ) ; } SedModel * SedDocument :: createModel ( ) { SedModel * temp = new SedModel ( ) ; if ( temp != NULL ) mModels . appendAndOwn ( temp ) ; return temp ; } const SedListOfTasks * SedDocument :: getListOfTasks ( ) const { return & mTasks ; } SedTask * SedDocument :: removeTask ( unsigned int n ) { return mTasks . remove ( n ) ; } SedTask * SedDocument :: removeTask ( const std :: string & sid ) { return mTasks . remove ( sid ) ; } SedTask * SedDocument :: getTask ( unsigned int n ) { return mTasks . get ( n ) ; } const SedTask * SedDocument :: getTask ( unsigned int n ) const { return mTasks . get ( n ) ; } SedTask * SedDocument :: getTask ( const std :: string & sid ) { return mTasks . get ( sid ) ; } const SedTask * SedDocument :: getTask ( const std :: string & sid ) const { return mTasks . get ( sid ) ; } int SedDocument :: addTask ( const SedTask * st ) { if ( st == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mTasks . append ( st ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumTasks ( ) const { return mTasks . size ( ) ; } SedTask * SedDocument :: createTask ( ) { SedTask * temp = new SedTask ( ) ; if ( temp != NULL ) mTasks . appendAndOwn ( temp ) ; return temp ; } SedRepeatedTask * SedDocument :: createRepeatedTask ( ) { SedRepeatedTask * temp = new SedRepeatedTask ( ) ; if ( temp != NULL ) mTasks . appendAndOwn ( temp ) ; return temp ; } const SedListOfDataGenerators * SedDocument :: getListOfDataGenerators ( ) const { return & mDataGenerators ; } SedDataGenerator * SedDocument :: removeDataGenerator ( unsigned int n ) { return mDataGenerators . remove ( n ) ; } SedDataGenerator * SedDocument :: removeDataGenerator ( const std :: string & sid ) { return mDataGenerators . remove ( sid ) ; } SedDataGenerator * SedDocument :: getDataGenerator ( unsigned int n ) { return mDataGenerators . get ( n ) ; } const SedDataGenerator * SedDocument :: getDataGenerator ( unsigned int n ) const { return mDataGenerators . get ( n ) ; } SedDataGenerator * SedDocument :: getDataGenerator ( const std :: string & sid ) { return mDataGenerators . get ( sid ) ; } const SedDataGenerator * SedDocument :: getDataGenerator ( const std :: string & sid ) const { return mDataGenerators . get ( sid ) ; } int SedDocument :: addDataGenerator ( const SedDataGenerator * sdg ) { if ( sdg == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mDataGenerators . append ( sdg ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumDataGenerators ( ) const { return mDataGenerators . size ( ) ; } SedDataGenerator * SedDocument :: createDataGenerator ( ) { SedDataGenerator * temp = new SedDataGenerator ( ) ; if ( temp != NULL ) mDataGenerators . appendAndOwn ( temp ) ; return temp ; } const SedListOfOutputs * SedDocument :: getListOfOutputs ( ) const { return & mOutputs ; } SedOutput * SedDocument :: removeOutput ( unsigned int n ) { return mOutputs . remove ( n ) ; } SedOutput * SedDocument :: removeOutput ( const std :: string & sid ) { return mOutputs . remove ( sid ) ; } SedOutput * SedDocument :: getOutput ( unsigned int n ) { return mOutputs . get ( n ) ; } const SedOutput * SedDocument :: getOutput ( unsigned int n ) const { return mOutputs . get ( n ) ; } SedOutput * SedDocument :: getOutput ( const std :: string & sid ) { return mOutputs . get ( sid ) ; } const SedOutput * SedDocument :: getOutput ( const std :: string & sid ) const { return mOutputs . get ( sid ) ; } int SedDocument :: addOutput ( const SedOutput * so ) { if ( so == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mOutputs . append ( so ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumOutputs ( ) const { return mOutputs . size ( ) ; } SedReport * SedDocument :: createReport ( ) { SedReport * temp = new SedReport ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; } SedPlot2D * SedDocument :: createPlot2D ( ) { SedPlot2D * temp = new SedPlot2D ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; } SedPlot3D * SedDocument :: createPlot3D ( ) { SedPlot3D * temp = new SedPlot3D ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; } const std :: string & SedDocument :: getElementName ( ) const { static const string name = " sedML " ; return name ; } SedBase * SedDocument :: createObject ( XMLInputStream & stream ) { SedBase * object = NULL ; const string & name = stream . peek ( ) . getName ( ) ; if ( name == " listOfDataDescriptions " ) { object = & mDataDescriptions ; } if ( name == " listOfSimulations " ) { object = & mSimulations ; } if ( name == " listOfModels " ) { object = & mModels ; } if ( name == " listOfTasks " ) { object = & mTasks ; } if ( name == " listOfDataGenerators " ) { object = & mDataGenerators ; } if ( name == " listOfOutputs " ) { object = & mOutputs ; } connectToChild ( ) ; return object ; } void SedDocument :: connectToChild ( ) { SedBase :: connectToChild ( ) ; mDataDescriptions . connectToParent ( this ) ; mSimulations . connectToParent ( this ) ; mModels . connectToParent ( this ) ; mTasks . connectToParent ( this ) ; mDataGenerators . connectToParent ( this ) ; mOutputs . connectToParent ( this ) ; } int SedDocument :: getTypeCode ( ) const { return SEDML_DOCUMENT ; } bool SedDocument :: hasRequiredAttributes ( ) const { bool allPresent = true ; if ( isSetLevel ( ) == false ) allPresent = false ; if ( isSetVersion ( ) == false ) allPresent = false ; return allPresent ; } bool SedDocument :: hasRequiredElements ( ) const { bool allPresent = true ; return allPresent ; } void SedDocument :: writeElements ( XMLOutputStream & stream ) const { SedBase :: writeElements ( stream ) ; if ( getNumDataDescriptions ( ) > 0 ) { mDataDescriptions . write ( stream ) ; } if ( getNumSimulations ( ) > 0 ) { mSimulations . write ( stream ) ; } if ( getNumModels ( ) > 0 ) { mModels . write ( stream ) ; } if ( getNumTasks ( ) > 0 ) { mTasks . write ( stream ) ; } if ( getNumDataGenerators ( ) > 0 ) { mDataGenerators . write ( stream ) ; } if ( getNumOutputs ( ) > 0 ) { mOutputs . write ( stream ) ; } } bool SedDocument :: accept ( SedVisitor & v ) const { return false ; } void SedDocument :: setSedDocument ( SedDocument * d ) { SedBase :: setSedDocument ( d ) ; mDataDescriptions . setSedDocument ( d ) ; mSimulations . setSedDocument ( d ) ; mModels . setSedDocument ( d ) ; mTasks . setSedDocument ( d ) ; mDataGenerators . setSedDocument ( d ) ; mOutputs . setSedDocument ( d ) ; } void SedDocument :: addExpectedAttributes ( ExpectedAttributes & attributes ) { SedBase :: addExpectedAttributes ( attributes ) ; attributes . add ( " level " ) ; attributes . add ( " version " ) ; } void SedDocument :: readAttributes ( const XMLAttributes & attributes , const ExpectedAttributes & expectedAttributes ) { SedBase :: readAttributes ( attributes , expectedAttributes ) ; bool assigned = false ; mIsSetLevel = attributes . readInto ( " level " , mLevel , getErrorLog ( ) , true ) ; mIsSetVersion = attributes . readInto ( " version " , mVersion , getErrorLog ( ) , true ) ; } void SedDocument :: writeAttributes ( XMLOutputStream & stream ) const { SedBase :: writeAttributes ( stream ) ; if ( isSetLevel ( ) == true ) stream . writeAttribute ( " level " , getPrefix ( ) , mLevel ) ; if ( isSetVersion ( ) == true ) stream . writeAttribute ( " version " , getPrefix ( ) , mVersion ) ; } const SedError * SedDocument :: getError ( unsigned int n ) const { return mErrorLog . getError ( n ) ; } unsigned int SedDocument :: getNumErrors ( ) const { return mErrorLog . getNumErrors ( ) ; } unsigned int SedDocument :: getNumErrors ( unsigned int severity ) const { return getErrorLog ( ) -> getNumFailsWithSeverity ( severity ) ; } SedErrorLog * SedDocument :: getErrorLog ( ) { return & mErrorLog ; } const SedErrorLog * SedDocument :: getErrorLog ( ) const { return & mErrorLog ; } void SedDocument :: writeXMLNS ( XMLOutputStream & stream ) const { XMLNamespaces * thisNs = this -> getNamespaces ( ) ; if ( thisNs == NULL ) { XMLNamespaces xmlns ; if ( getVersion ( ) == 1 ) xmlns . add ( SEDML_XMLNS_L1V1 ) ; else xmlns . add ( SEDML_XMLNS_L1V2 ) ; mSedNamespaces -> setNamespaces ( & xmlns ) ; thisNs = getNamespaces ( ) ; } else if ( thisNs -> getLength ( ) == 0 ) { if ( getVersion ( ) == 1 ) thisNs -> add ( SEDML_XMLNS_L1V1 ) ; else if ( getVersion ( ) == 2 ) thisNs -> add ( SEDML_XMLNS_L1V2 ) ; else thisNs -> add ( SEDML_XMLNS_L1V3 ) ; } else { std :: string sedmlURI = SedNamespaces :: getSedNamespaceURI ( getLevel ( ) , getVersion ( ) ) ; std :: string sedmlPrefix = thisNs -> getPrefix ( sedmlURI ) ; if ( thisNs -> hasNS ( sedmlURI , sedmlPrefix ) == false ) { std :: string other = thisNs -> getURI ( sedmlPrefix ) ; if ( other . empty ( ) == false ) { thisNs -> remove ( sedmlPrefix ) ; thisNs -> add ( sedmlURI , sedmlPrefix ) ; thisNs -> add ( other , " addedPrefix " ) ; } else { thisNs -> add ( sedmlURI , sedmlPrefix ) ; } } } XMLNamespaces * xmlns = thisNs -> clone ( ) ; if ( xmlns != NULL ) { stream << * ( xmlns ) ; delete xmlns ; } } XMLNamespaces * SedDocument :: getNamespaces ( ) const { return mSedNamespaces -> getNamespaces ( ) ; } LIBSEDML_EXTERN SedDocument_t * SedDocument_create ( unsigned int level , unsigned int version ) { return new SedDocument ( level , version ) ; } LIBSEDML_EXTERN void SedDocument_free ( SedDocument_t * sd ) { if ( sd != NULL ) delete sd ; } LIBSEDML_EXTERN SedDocument_t * SedDocument_clone ( SedDocument_t * sd ) { if ( sd != NULL ) { return static_cast < SedDocument_t * > ( sd -> clone ( ) ) ; } else { return NULL ; } } LIBSEDML_EXTERN int SedDocument_getLevel ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getLevel ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN int SedDocument_getVersion ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getVersion ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN int SedDocument_isSetLevel ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> isSetLevel ( ) ) : 0 ; } LIBSEDML_EXTERN int SedDocument_isSetVersion ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> isSetVersion ( ) ) : 0 ; } LIBSEDML_EXTERN int SedDocument_setLevel ( SedDocument_t * sd , int level ) { return ( sd != NULL ) ? sd -> setLevel ( level ) : LIBSEDML_INVALID_OBJECT ; } LIBSEDML_EXTERN int SedDocument_setVersion ( SedDocument_t * sd , int version ) { return ( sd != NULL ) ? sd -> setVersion ( version ) : LIBSEDML_INVALID_OBJECT ; } LIBSEDML_EXTERN int SedDocument_unsetLevel ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> unsetLevel ( ) : LIBSEDML_INVALID_OBJECT ; } LIBSEDML_EXTERN int SedDocument_unsetVersion ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> unsetVersion ( ) : LIBSEDML_INVALID_OBJECT ; } LIBSEDML_EXTERN int SedDocument_addDataDescription ( SedDocument_t * sd , SedDataDescription_t * sdd ) { return ( sd != NULL ) ? sd -> addDataDescription ( sdd ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_createDataDescription ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createDataDescription ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfDataDescriptions ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfDataDescriptions ( ) : NULL ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_getDataDescription ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getDataDescription ( n ) : NULL ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_getDataDescriptionById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getDataDescription ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumDataDescriptions ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumDataDescriptions ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_removeDataDescription ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeDataDescription ( n ) : NULL ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_removeDataDescriptionById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeDataDescription ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_addSimulation ( SedDocument_t * sd , SedSimulation_t * ss ) { return ( sd != NULL ) ? sd -> addSimulation ( ss ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedUniformTimeCourse_t * SedDocument_createUniformTimeCourse ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createUniformTimeCourse ( ) : NULL ; } LIBSEDML_EXTERN SedOneStep_t * SedDocument_createOneStep ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createOneStep ( ) : NULL ; } LIBSEDML_EXTERN SedSteadyState_t * SedDocument_createSteadyState ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createSteadyState ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfSimulations ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfSimulations ( ) : NULL ; } LIBSEDML_EXTERN SedSimulation_t * SedDocument_getSimulation ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getSimulation ( n ) : NULL ; } LIBSEDML_EXTERN SedSimulation_t * SedDocument_getSimulationById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getSimulation ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumSimulations ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumSimulations ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedSimulation_t * SedDocument_removeSimulation ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeSimulation ( n ) : NULL ; } LIBSEDML_EXTERN SedSimulation_t * SedDocument_removeSimulationById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeSimulation ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_addModel ( SedDocument_t * sd , SedModel_t * sm ) { return ( sd != NULL ) ? sd -> addModel ( sm ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedModel_t * SedDocument_createModel ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createModel ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfModels ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfModels ( ) : NULL ; } LIBSEDML_EXTERN SedModel_t * SedDocument_getModel ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getModel ( n ) : NULL ; } LIBSEDML_EXTERN SedModel_t * SedDocument_getModelById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getModel ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumModels ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumModels ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedModel_t * SedDocument_removeModel ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeModel ( n ) : NULL ; } LIBSEDML_EXTERN SedModel_t * SedDocument_removeModelById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeModel ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_addTask ( SedDocument_t * sd , SedTask_t * st ) { return ( sd != NULL ) ? sd -> addTask ( st ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedTask_t * SedDocument_createTask ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createTask ( ) : NULL ; } LIBSEDML_EXTERN SedRepeatedTask_t * SedDocument_createRepeatedTask ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createRepeatedTask ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfTasks ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfTasks ( ) : NULL ; } LIBSEDML_EXTERN SedTask_t * SedDocument_getTask ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getTask ( n ) : NULL ; } LIBSEDML_EXTERN SedTask_t * SedDocument_getTaskById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getTask ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumTasks ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumTasks ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedTask_t * SedDocument_removeTask ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeTask ( n ) : NULL ; } LIBSEDML_EXTERN SedTask_t * SedDocument_removeTaskById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeTask ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_addDataGenerator ( SedDocument_t * sd , SedDataGenerator_t * sdg ) { return ( sd != NULL ) ? sd -> addDataGenerator ( sdg ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_createDataGenerator ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createDataGenerator ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfDataGenerators ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfDataGenerators ( ) : NULL ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_getDataGenerator ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getDataGenerator ( n ) : NULL ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_getDataGeneratorById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getDataGenerator ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumDataGenerators ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumDataGenerators ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_removeDataGenerator ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeDataGenerator ( n ) : NULL ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_removeDataGeneratorById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeDataGenerator ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_addOutput ( SedDocument_t * sd , SedOutput_t * so ) { return ( sd != NULL ) ? sd -> addOutput ( so ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedReport_t * SedDocument_createReport ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createReport ( ) : NULL ; } LIBSEDML_EXTERN SedPlot2D_t * SedDocument_createPlot2D ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createPlot2D ( ) : NULL ; } LIBSEDML_EXTERN SedPlot3D_t * SedDocument_createPlot3D ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createPlot3D ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfOutputs ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfOutputs ( ) : NULL ; } LIBSEDML_EXTERN SedOutput_t * SedDocument_getOutput ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getOutput ( n ) : NULL ; } LIBSEDML_EXTERN SedOutput_t * SedDocument_getOutputById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getOutput ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumOutputs ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumOutputs ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedOutput_t * SedDocument_removeOutput ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeOutput ( n ) : NULL ; } LIBSEDML_EXTERN SedOutput_t * SedDocument_removeOutputById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeOutput ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_hasRequiredAttributes ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> hasRequiredAttributes ( ) ) : 0 ; } LIBSEDML_EXTERN int SedDocument_hasRequiredElements ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> hasRequiredElements ( ) ) : 0 ; } LIBSEDML_CPP_NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="wiltonlazary/arangodb/tree/master/3rdParty/boost/1.61.0/libs/math/test/compile_test/sf_hypot_incl_test.cpp"> # include < boost / math / special_functions / hypot . hpp > # include " test _ compile _ result . hpp " void compile_and_link_test ( ) { check_result < float > ( boost :: math :: hypot < float > ( f , f ) ) ; check_result < double > ( boost :: math :: hypot < double > ( d , d ) ) ; # ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS check_result < long double > ( boost :: math :: hypot < long double > ( l , l ) ) ; # endif } </DOCUMENT>
<DOCUMENT_ID="pduuubs/render3D/tree/master/libs/eigen/test/geo_transformations.cpp"> # include " main . h " # include < Eigen / Geometry > # include < Eigen / LU > # include < Eigen / SVD > template < typename T > Matrix < T , 2 , 1 > angleToVec ( T a ) { return Matrix < T , 2 , 1 > ( std :: cos ( a ) , std :: sin ( a ) ) ; } template < typename T > EIGEN_DONT_INLINE void dont_over_optimize ( T & x ) { volatile typename T :: Scalar tmp = x ( 0 ) ; x ( 0 ) = tmp ; } template < typename Scalar , int Mode , int Options > void non_projective_only ( ) { typedef Matrix < Scalar , 3 , 1 > Vector3 ; typedef Quaternion < Scalar > Quaternionx ; typedef AngleAxis < Scalar > AngleAxisx ; typedef Transform < Scalar , 3 , Mode , Options > Transform3 ; typedef DiagonalMatrix < Scalar , 3 > AlignedScaling3 ; typedef Translation < Scalar , 3 > Translation3 ; Vector3 v0 = Vector3 :: Random ( ) , v1 = Vector3 :: Random ( ) ; Transform3 t0 , t1 , t2 ; Scalar a = internal :: random < Scalar > ( - Scalar ( EIGEN_PI ) , Scalar ( EIGEN_PI ) ) ; Quaternionx q1 , q2 ; q1 = AngleAxisx ( a , v0 . normalized ( ) ) ; t0 = Transform3 :: Identity ( ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , Transform3 :: MatrixType :: Identity ( ) ) ; t0 . linear ( ) = q1 . toRotationMatrix ( ) ; v0 << 50 , 2 , 1 ; t0 . scale ( v0 ) ; VERIFY_IS_APPROX ( ( t0 * Vector3 ( 1 , 0 , 0 ) ) . template head < 3 > ( ) . norm ( ) , v0 . x ( ) ) ; t0 . setIdentity ( ) ; t1 . setIdentity ( ) ; v1 << 1 , 2 , 3 ; t0 . linear ( ) = q1 . toRotationMatrix ( ) ; t0 . pretranslate ( v0 ) ; t0 . scale ( v1 ) ; t1 . linear ( ) = q1 . conjugate ( ) . toRotationMatrix ( ) ; t1 . prescale ( v1 . cwiseInverse ( ) ) ; t1 . translate ( - v0 ) ; VERIFY ( ( t0 * t1 ) . matrix ( ) . isIdentity ( test_precision < Scalar > ( ) ) ) ; t1 . fromPositionOrientationScale ( v0 , q1 , v1 ) ; VERIFY_IS_APPROX ( t1 . matrix ( ) , t0 . matrix ( ) ) ; VERIFY_IS_APPROX ( t1 * v1 , t0 * v1 ) ; t0 . setIdentity ( ) ; t0 . translate ( v0 ) ; VERIFY_IS_APPROX ( ( t0 * v1 ) . template head < 3 > ( ) , Translation3 ( v0 ) * v1 ) ; t0 . setIdentity ( ) ; t0 . scale ( v0 ) ; VERIFY_IS_APPROX ( ( t0 * v1 ) . template head < 3 > ( ) , AlignedScaling3 ( v0 ) * v1 ) ; } template < typename Scalar , int Mode , int Options > void transformations ( ) { using std :: cos ; using std :: abs ; typedef Matrix < Scalar , 3 , 3 > Matrix3 ; typedef Matrix < Scalar , 4 , 4 > Matrix4 ; typedef Matrix < Scalar , 2 , 1 > Vector2 ; typedef Matrix < Scalar , 3 , 1 > Vector3 ; typedef Matrix < Scalar , 4 , 1 > Vector4 ; typedef Quaternion < Scalar > Quaternionx ; typedef AngleAxis < Scalar > AngleAxisx ; typedef Transform < Scalar , 2 , Mode , Options > Transform2 ; typedef Transform < Scalar , 3 , Mode , Options > Transform3 ; typedef typename Transform3 :: MatrixType MatrixType ; typedef DiagonalMatrix < Scalar , 3 > AlignedScaling3 ; typedef Translation < Scalar , 2 > Translation2 ; typedef Translation < Scalar , 3 > Translation3 ; Vector3 v0 = Vector3 :: Random ( ) , v1 = Vector3 :: Random ( ) ; Matrix3 matrot1 , m ; Scalar a = internal :: random < Scalar > ( - Scalar ( EIGEN_PI ) , Scalar ( EIGEN_PI ) ) ; Scalar s0 = internal :: random < Scalar > ( ) , s1 = internal :: random < Scalar > ( ) ; while ( v0 . norm ( ) < test_precision < Scalar > ( ) ) v0 = Vector3 :: Random ( ) ; while ( v1 . norm ( ) < test_precision < Scalar > ( ) ) v1 = Vector3 :: Random ( ) ; VERIFY_IS_APPROX ( v0 , AngleAxisx ( a , v0 . normalized ( ) ) * v0 ) ; VERIFY_IS_APPROX ( - v0 , AngleAxisx ( Scalar ( EIGEN_PI ) , v0 . unitOrthogonal ( ) ) * v0 ) ; if ( abs ( cos ( a ) ) > test_precision < Scalar > ( ) ) { VERIFY_IS_APPROX ( cos ( a ) * v0 . squaredNorm ( ) , v0 . dot ( AngleAxisx ( a , v0 . unitOrthogonal ( ) ) * v0 ) ) ; } m = AngleAxisx ( a , v0 . normalized ( ) ) . toRotationMatrix ( ) . adjoint ( ) ; VERIFY_IS_APPROX ( Matrix3 :: Identity ( ) , m * AngleAxisx ( a , v0 . normalized ( ) ) ) ; VERIFY_IS_APPROX ( Matrix3 :: Identity ( ) , AngleAxisx ( a , v0 . normalized ( ) ) * m ) ; Quaternionx q1 , q2 ; q1 = AngleAxisx ( a , v0 . normalized ( ) ) ; q2 = AngleAxisx ( a , v1 . normalized ( ) ) ; matrot1 = AngleAxisx ( Scalar ( 0.1 ) , Vector3 :: UnitX ( ) ) * AngleAxisx ( Scalar ( 0.2 ) , Vector3 :: UnitY ( ) ) * AngleAxisx ( Scalar ( 0.3 ) , Vector3 :: UnitZ ( ) ) ; VERIFY_IS_APPROX ( matrot1 * v1 , AngleAxisx ( Scalar ( 0.1 ) , Vector3 ( 1 , 0 , 0 ) ) . toRotationMatrix ( ) * ( AngleAxisx ( Scalar ( 0.2 ) , Vector3 ( 0 , 1 , 0 ) ) . toRotationMatrix ( ) * ( AngleAxisx ( Scalar ( 0.3 ) , Vector3 ( 0 , 0 , 1 ) ) . toRotationMatrix ( ) * v1 ) ) ) ; AngleAxisx aa = AngleAxisx ( q1 ) ; VERIFY_IS_APPROX ( q1 * v1 , Quaternionx ( aa ) * v1 ) ; if ( ( abs ( aa . angle ( ) ) > test_precision < Scalar > ( ) ) && ( abs ( aa . axis ( ) . dot ( v1 . normalized ( ) ) ) < ( Scalar ( 1 ) - Scalar ( 4 ) * test_precision < Scalar > ( ) ) ) ) { VERIFY ( ! ( q1 * v1 ) . isApprox ( Quaternionx ( AngleAxisx ( aa . angle ( ) * 2 , aa . axis ( ) ) ) * v1 ) ) ; } aa . fromRotationMatrix ( aa . toRotationMatrix ( ) ) ; VERIFY_IS_APPROX ( q1 * v1 , Quaternionx ( aa ) * v1 ) ; if ( ( abs ( aa . angle ( ) ) > test_precision < Scalar > ( ) ) && ( abs ( aa . axis ( ) . dot ( v1 . normalized ( ) ) ) < ( Scalar ( 1 ) - Scalar ( 4 ) * test_precision < Scalar > ( ) ) ) ) { VERIFY ( ! ( q1 * v1 ) . isApprox ( Quaternionx ( AngleAxisx ( aa . angle ( ) * 2 , aa . axis ( ) ) ) * v1 ) ) ; } VERIFY_IS_APPROX ( AngleAxisx ( a , v1 . normalized ( ) ) . toRotationMatrix ( ) , Quaternionx ( AngleAxisx ( a , v1 . normalized ( ) ) ) . toRotationMatrix ( ) ) ; AngleAxisx aa1 ; m = q1 . toRotationMatrix ( ) ; aa1 = m ; VERIFY_IS_APPROX ( AngleAxisx ( m ) . toRotationMatrix ( ) , Quaternionx ( m ) . toRotationMatrix ( ) ) ; a = 0 ; while ( abs ( a ) < Scalar ( 0.1 ) ) a = internal :: random < Scalar > ( - Scalar ( 0.4 ) * Scalar ( EIGEN_PI ) , Scalar ( 0.4 ) * Scalar ( EIGEN_PI ) ) ; q1 = AngleAxisx ( a , v0 . normalized ( ) ) ; Transform3 t0 , t1 , t2 ; t0 . setIdentity ( ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , Transform3 :: MatrixType :: Identity ( ) ) ; t0 . matrix ( ) . setZero ( ) ; t0 = Transform3 :: Identity ( ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , Transform3 :: MatrixType :: Identity ( ) ) ; t0 . setIdentity ( ) ; t1 . setIdentity ( ) ; v1 << 1 , 2 , 3 ; t0 . linear ( ) = q1 . toRotationMatrix ( ) ; t0 . pretranslate ( v0 ) ; t0 . scale ( v1 ) ; t1 . linear ( ) = q1 . conjugate ( ) . toRotationMatrix ( ) ; t1 . prescale ( v1 . cwiseInverse ( ) ) ; t1 . translate ( - v0 ) ; VERIFY ( ( t0 * t1 ) . matrix ( ) . isIdentity ( test_precision < Scalar > ( ) ) ) ; t1 . fromPositionOrientationScale ( v0 , q1 , v1 ) ; VERIFY_IS_APPROX ( t1 . matrix ( ) , t0 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . scale ( v0 ) . rotate ( q1 . toRotationMatrix ( ) ) ; t1 . setIdentity ( ) ; t1 . scale ( v0 ) . rotate ( q1 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . scale ( v0 ) . rotate ( AngleAxisx ( q1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; VERIFY_IS_APPROX ( t0 . scale ( a ) . matrix ( ) , t1 . scale ( Vector3 :: Constant ( a ) ) . matrix ( ) ) ; VERIFY_IS_APPROX ( t0 . prescale ( a ) . matrix ( ) , t1 . prescale ( Vector3 :: Constant ( a ) ) . matrix ( ) ) ; Matrix3 mat3 = Matrix3 :: Random ( ) ; Matrix4 mat4 ; mat4 << mat3 , Vector3 :: Zero ( ) , Vector4 :: Zero ( ) . transpose ( ) ; Transform3 tmat3 ( mat3 ) , tmat4 ( mat4 ) ; if ( Mode != int ( AffineCompact ) ) tmat4 . matrix ( ) ( 3 , 3 ) = Scalar ( 1 ) ; VERIFY_IS_APPROX ( tmat3 . matrix ( ) , tmat4 . matrix ( ) ) ; Scalar a3 = internal :: random < Scalar > ( - Scalar ( EIGEN_PI ) , Scalar ( EIGEN_PI ) ) ; Vector3 v3 = Vector3 :: Random ( ) . normalized ( ) ; AngleAxisx aa3 ( a3 , v3 ) ; Transform3 t3 ( aa3 ) ; Transform3 t4 ; t4 = aa3 ; VERIFY_IS_APPROX ( t3 . matrix ( ) , t4 . matrix ( ) ) ; t4 . rotate ( AngleAxisx ( - a3 , v3 ) ) ; VERIFY_IS_APPROX ( t4 . matrix ( ) , MatrixType :: Identity ( ) ) ; t4 *= aa3 ; VERIFY_IS_APPROX ( t3 . matrix ( ) , t4 . matrix ( ) ) ; do { v3 = Vector3 :: Random ( ) ; dont_over_optimize ( v3 ) ; } while ( v3 . cwiseAbs ( ) . minCoeff ( ) < NumTraits < Scalar > :: epsilon ( ) ) ; Translation3 tv3 ( v3 ) ; Transform3 t5 ( tv3 ) ; t4 = tv3 ; VERIFY_IS_APPROX ( t5 . matrix ( ) , t4 . matrix ( ) ) ; t4 . translate ( ( - v3 ) . eval ( ) ) ; VERIFY_IS_APPROX ( t4 . matrix ( ) , MatrixType :: Identity ( ) ) ; t4 *= tv3 ; VERIFY_IS_APPROX ( t5 . matrix ( ) , t4 . matrix ( ) ) ; AlignedScaling3 sv3 ( v3 ) ; Transform3 t6 ( sv3 ) ; t4 = sv3 ; VERIFY_IS_APPROX ( t6 . matrix ( ) , t4 . matrix ( ) ) ; t4 . scale ( v3 . cwiseInverse ( ) ) ; VERIFY_IS_APPROX ( t4 . matrix ( ) , MatrixType :: Identity ( ) ) ; t4 *= sv3 ; VERIFY_IS_APPROX ( t6 . matrix ( ) , t4 . matrix ( ) ) ; VERIFY_IS_APPROX ( ( t3 . matrix ( ) * t4 ) . matrix ( ) , ( t3 * t4 ) . matrix ( ) ) ; VERIFY_IS_APPROX ( ( ( t3 * t4 ) * t5 ) . matrix ( ) , ( t3 * ( t4 * t5 ) ) . matrix ( ) ) ; t5 = t4 ; t5 = t5 * t5 ; VERIFY_IS_APPROX ( t5 , t4 * t4 ) ; Transform2 t20 , t21 ; Vector2 v20 = Vector2 :: Random ( ) ; Vector2 v21 = Vector2 :: Random ( ) ; for ( int k = 0 ; k < 2 ; ++ k ) if ( abs ( v21 [ k ] ) < Scalar ( 1e - 3 ) ) v21 [ k ] = Scalar ( 1e - 3 ) ; t21 . setIdentity ( ) ; t21 . linear ( ) = Rotation2D < Scalar > ( a ) . toRotationMatrix ( ) ; VERIFY_IS_APPROX ( t20 . fromPositionOrientationScale ( v20 , a , v21 ) . matrix ( ) , t21 . pretranslate ( v20 ) . scale ( v21 ) . matrix ( ) ) ; t21 . setIdentity ( ) ; t21 . linear ( ) = Rotation2D < Scalar > ( - a ) . toRotationMatrix ( ) ; VERIFY ( ( t20 . fromPositionOrientationScale ( v20 , a , v21 ) * ( t21 . prescale ( v21 . cwiseInverse ( ) ) . translate ( - v20 ) ) ) . matrix ( ) . isIdentity ( test_precision < Scalar > ( ) ) ) ; t0 . setIdentity ( ) ; t0 . rotate ( q1 ) . scale ( v0 ) . translate ( v0 ) ; t1 = ( Matrix3 ( q1 ) * AlignedScaling3 ( v0 ) ) * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = ( Matrix3 ( q1 ) * Eigen :: Scaling ( v0 ) ) * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = ( q1 * Eigen :: Scaling ( v0 ) ) * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = Matrix3 ( q1 ) * ( AlignedScaling3 ( v0 ) * Translation3 ( v0 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . scale ( s0 ) . translate ( v0 ) ; t1 = Eigen :: Scaling ( s0 ) * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . prescale ( s0 ) ; t1 = Eigen :: Scaling ( s0 ) * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 = t3 ; t0 . scale ( s0 ) ; t1 = t3 * Eigen :: Scaling ( s0 , s0 , s0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . prescale ( s0 ) ; t1 = Eigen :: Scaling ( s0 , s0 , s0 ) * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 = t3 ; t0 . scale ( s0 ) ; t1 = t3 * Eigen :: Scaling ( s0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . prescale ( s0 ) ; t1 = Eigen :: Scaling ( s0 ) * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . prerotate ( q1 ) . prescale ( v0 ) . pretranslate ( v0 ) ; t1 = ( Translation3 ( v0 ) * AlignedScaling3 ( v0 ) ) * Transform3 ( q1 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = Translation3 ( v0 ) * ( AlignedScaling3 ( v0 ) * Transform3 ( q1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . scale ( v0 ) . translate ( v0 ) . rotate ( q1 ) ; t1 = AlignedScaling3 ( v0 ) * ( Translation3 ( v0 ) * Transform3 ( q1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . scale ( v0 ) ; t1 *= AlignedScaling3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = AlignedScaling3 ( v0 ) * ( Translation3 ( v0 ) * Transform3 ( q1 ) ) ; t1 = t1 * v0 . asDiagonal ( ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . translate ( v0 ) ; t1 = t1 * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . pretranslate ( v0 ) ; t1 = Translation3 ( v0 ) * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . rotate ( q1 ) ; t1 = t1 * q1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . translate ( v1 ) . rotate ( q1 ) ; t1 = t1 * ( Translation3 ( v1 ) * q1 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . scale ( v1 ) . rotate ( q1 ) ; t1 = t1 * ( AlignedScaling3 ( v1 ) * q1 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . prerotate ( q1 ) ; t1 = q1 * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . rotate ( q1 ) . translate ( v1 ) ; t1 = t1 * ( q1 * Translation3 ( v1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . rotate ( q1 ) . scale ( v1 ) ; t1 = t1 * ( q1 * AlignedScaling3 ( v1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . translate ( v0 ) ; do { t0 . linear ( ) . setRandom ( ) ; } while ( t0 . linear ( ) . jacobiSvd ( ) . singularValues ( ) ( 2 ) < test_precision < Scalar > ( ) ) ; Matrix4 t044 = Matrix4 :: Zero ( ) ; t044 ( 3 , 3 ) = 1 ; t044 . block ( 0 , 0 , t0 . matrix ( ) . rows ( ) , 4 ) = t0 . matrix ( ) ; VERIFY_IS_APPROX ( t0 . inverse ( Affine ) . matrix ( ) , t044 . inverse ( ) . block ( 0 , 0 , t0 . matrix ( ) . rows ( ) , 4 ) ) ; t0 . setIdentity ( ) ; t0 . translate ( v0 ) . rotate ( q1 ) ; t044 = Matrix4 :: Zero ( ) ; t044 ( 3 , 3 ) = 1 ; t044 . block ( 0 , 0 , t0 . matrix ( ) . rows ( ) , 4 ) = t0 . matrix ( ) ; VERIFY_IS_APPROX ( t0 . inverse ( Isometry ) . matrix ( ) , t044 . inverse ( ) . block ( 0 , 0 , t0 . matrix ( ) . rows ( ) , 4 ) ) ; Matrix3 mat_rotation , mat_scaling ; t0 . setIdentity ( ) ; t0 . translate ( v0 ) . rotate ( q1 ) . scale ( v1 ) ; t0 . computeRotationScaling ( & mat_rotation , & mat_scaling ) ; VERIFY_IS_APPROX ( t0 . linear ( ) , mat_rotation * mat_scaling ) ; VERIFY_IS_APPROX ( mat_rotation * mat_rotation . adjoint ( ) , Matrix3 :: Identity ( ) ) ; VERIFY_IS_APPROX ( mat_rotation . determinant ( ) , Scalar ( 1 ) ) ; t0 . computeScalingRotation ( & mat_scaling , & mat_rotation ) ; VERIFY_IS_APPROX ( t0 . linear ( ) , mat_scaling * mat_rotation ) ; VERIFY_IS_APPROX ( mat_rotation * mat_rotation . adjoint ( ) , Matrix3 :: Identity ( ) ) ; VERIFY_IS_APPROX ( mat_rotation . determinant ( ) , Scalar ( 1 ) ) ; Transform < float , 3 , Mode > t1f = t1 . template cast < float > ( ) ; VERIFY_IS_APPROX ( t1f . template cast < Scalar > ( ) , t1 ) ; Transform < double , 3 , Mode > t1d = t1 . template cast < double > ( ) ; VERIFY_IS_APPROX ( t1d . template cast < Scalar > ( ) , t1 ) ; Translation3 tr1 ( v0 ) ; Translation < float , 3 > tr1f = tr1 . template cast < float > ( ) ; VERIFY_IS_APPROX ( tr1f . template cast < Scalar > ( ) , tr1 ) ; Translation < double , 3 > tr1d = tr1 . template cast < double > ( ) ; VERIFY_IS_APPROX ( tr1d . template cast < Scalar > ( ) , tr1 ) ; AngleAxis < float > aa1f = aa1 . template cast < float > ( ) ; VERIFY_IS_APPROX ( aa1f . template cast < Scalar > ( ) , aa1 ) ; AngleAxis < double > aa1d = aa1 . template cast < double > ( ) ; VERIFY_IS_APPROX ( aa1d . template cast < Scalar > ( ) , aa1 ) ; Rotation2D < Scalar > r2d1 ( internal :: random < Scalar > ( ) ) ; Rotation2D < float > r2d1f = r2d1 . template cast < float > ( ) ; VERIFY_IS_APPROX ( r2d1f . template cast < Scalar > ( ) , r2d1 ) ; Rotation2D < double > r2d1d = r2d1 . template cast < double > ( ) ; VERIFY_IS_APPROX ( r2d1d . template cast < Scalar > ( ) , r2d1 ) ; for ( int k = 0 ; k < 100 ; ++ k ) { Scalar angle = internal :: random < Scalar > ( - 100 , 100 ) ; Rotation2D < Scalar > rot2 ( angle ) ; VERIFY ( rot2 . smallestPositiveAngle ( ) >= 0 ) ; VERIFY ( rot2 . smallestPositiveAngle ( ) <= Scalar ( 2 ) * Scalar ( EIGEN_PI ) ) ; VERIFY_IS_APPROX ( angleToVec ( rot2 . smallestPositiveAngle ( ) ) , angleToVec ( rot2 . angle ( ) ) ) ; VERIFY ( rot2 . smallestAngle ( ) >= - Scalar ( EIGEN_PI ) ) ; VERIFY ( rot2 . smallestAngle ( ) <= Scalar ( EIGEN_PI ) ) ; VERIFY_IS_APPROX ( angleToVec ( rot2 . smallestAngle ( ) ) , angleToVec ( rot2 . angle ( ) ) ) ; Matrix < Scalar , 2 , 2 > rot2_as_mat ( rot2 ) ; Rotation2D < Scalar > rot3 ( rot2_as_mat ) ; VERIFY_IS_APPROX ( angleToVec ( rot2 . smallestAngle ( ) ) , angleToVec ( rot3 . angle ( ) ) ) ; } s0 = internal :: random < Scalar > ( - 100 , 100 ) ; s1 = internal :: random < Scalar > ( - 100 , 100 ) ; Rotation2D < Scalar > R0 ( s0 ) , R1 ( s1 ) ; t20 = Translation2 ( v20 ) * ( R0 * Eigen :: Scaling ( s0 ) ) ; t21 = Translation2 ( v20 ) * R0 * Eigen :: Scaling ( s0 ) ; VERIFY_IS_APPROX ( t20 , t21 ) ; t20 = Translation2 ( v20 ) * ( R0 * R0 . inverse ( ) * Eigen :: Scaling ( s0 ) ) ; t21 = Translation2 ( v20 ) * Eigen :: Scaling ( s0 ) ; VERIFY_IS_APPROX ( t20 , t21 ) ; VERIFY_IS_APPROX ( s0 , ( R0 . slerp ( 0 , R1 ) ) . angle ( ) ) ; VERIFY_IS_APPROX ( angleToVec ( R1 . smallestPositiveAngle ( ) ) , angleToVec ( ( R0 . slerp ( 1 , R1 ) ) . smallestPositiveAngle ( ) ) ) ; VERIFY_IS_APPROX ( R0 . smallestPositiveAngle ( ) , ( R0 . slerp ( 0.5 , R0 ) ) . smallestPositiveAngle ( ) ) ; if ( std :: cos ( s0 ) > 0 ) VERIFY_IS_MUCH_SMALLER_THAN ( ( R0 . slerp ( 0.5 , R0 . inverse ( ) ) ) . smallestAngle ( ) , Scalar ( 1 ) ) ; else VERIFY_IS_APPROX ( Scalar ( EIGEN_PI ) , ( R0 . slerp ( 0.5 , R0 . inverse ( ) ) ) . smallestPositiveAngle ( ) ) ; Scalar l = 0 ; int path_steps = 100 ; for ( int k = 0 ; k < path_steps ; ++ k ) { Scalar a1 = R0 . slerp ( Scalar ( k ) / Scalar ( path_steps ) , R1 ) . angle ( ) ; Scalar a2 = R0 . slerp ( Scalar ( k + 1 ) / Scalar ( path_steps ) , R1 ) . angle ( ) ; l += std :: abs ( a2 - a1 ) ; } VERIFY ( l <= Scalar ( EIGEN_PI ) * ( Scalar ( 1 ) + NumTraits < Scalar > :: epsilon ( ) * Scalar ( path_steps / 2 ) ) ) ; { Rotation2D < Scalar > r1 ; r1 = Rotation2D < Scalar > ( s0 ) ; VERIFY_IS_APPROX ( r1 . angle ( ) , s0 ) ; Rotation2D < Scalar > r2 ( r1 ) ; VERIFY_IS_APPROX ( r2 . angle ( ) , s0 ) ; } { Transform3 t32 ( Matrix4 :: Random ( ) ) , t33 , t34 ; t34 = t33 = t32 ; t32 . scale ( v0 ) ; t33 *= AlignedScaling3 ( v0 ) ; VERIFY_IS_APPROX ( t32 . matrix ( ) , t33 . matrix ( ) ) ; t33 = t34 * AlignedScaling3 ( v0 ) ; VERIFY_IS_APPROX ( t32 . matrix ( ) , t33 . matrix ( ) ) ; } } template < typename A1 , typename A2 , typename P , typename Q , typename V , typename H > void transform_associativity_left ( const A1 & a1 , const A2 & a2 , const P & p , const Q & q , const V & v , const H & h ) { VERIFY_IS_APPROX ( q * ( a1 * v ) , ( q * a1 ) * v ) ; VERIFY_IS_APPROX ( q * ( a2 * v ) , ( q * a2 ) * v ) ; VERIFY_IS_APPROX ( q * ( p * h ) . hnormalized ( ) , ( ( q * p ) * h ) . hnormalized ( ) ) ; } template < typename A1 , typename A2 , typename P , typename Q , typename V , typename H > void transform_associativity2 ( const A1 & a1 , const A2 & a2 , const P & p , const Q & q , const V & v , const H & h ) { VERIFY_IS_APPROX ( a1 * ( q * v ) , ( a1 * q ) * v ) ; VERIFY_IS_APPROX ( a2 * ( q * v ) , ( a2 * q ) * v ) ; VERIFY_IS_APPROX ( p * ( q * v ) . homogeneous ( ) , ( p * q ) * v . homogeneous ( ) ) ; transform_associativity_left ( a1 , a2 , p , q , v , h ) ; } template < typename Scalar , int Dim , int Options , typename RotationType > void transform_associativity ( const RotationType & R ) { typedef Matrix < Scalar , Dim , 1 > VectorType ; typedef Matrix < Scalar , Dim + 1 , 1 > HVectorType ; typedef Matrix < Scalar , Dim , Dim > LinearType ; typedef Matrix < Scalar , Dim + 1 , Dim + 1 > MatrixType ; typedef Transform < Scalar , Dim , AffineCompact , Options > AffineCompactType ; typedef Transform < Scalar , Dim , Affine , Options > AffineType ; typedef Transform < Scalar , Dim , Projective , Options > ProjectiveType ; typedef DiagonalMatrix < Scalar , Dim > ScalingType ; typedef Translation < Scalar , Dim > TranslationType ; AffineCompactType A1c ; A1c . matrix ( ) . setRandom ( ) ; AffineCompactType A2c ; A2c . matrix ( ) . setRandom ( ) ; AffineType A1 ( A1c ) ; AffineType A2 ( A2c ) ; ProjectiveType P1 ; P1 . matrix ( ) . setRandom ( ) ; VectorType v1 = VectorType :: Random ( ) ; VectorType v2 = VectorType :: Random ( ) ; HVectorType h1 = HVectorType :: Random ( ) ; Scalar s1 = internal :: random < Scalar > ( ) ; LinearType L = LinearType :: Random ( ) ; MatrixType M = MatrixType :: Random ( ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , A2 , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , A2c , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , v1 . asDiagonal ( ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , ScalingType ( v1 ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , Scaling ( v1 ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , Scaling ( s1 ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , TranslationType ( v1 ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity_left ( A1c , A1 , P1 , L , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , R , v2 , h1 ) ) ; VERIFY_IS_APPROX ( A1 * ( M * h1 ) , ( A1 * M ) * h1 ) ; VERIFY_IS_APPROX ( A1c * ( M * h1 ) , ( A1c * M ) * h1 ) ; VERIFY_IS_APPROX ( P1 * ( M * h1 ) , ( P1 * M ) * h1 ) ; VERIFY_IS_APPROX ( M * ( A1 * h1 ) , ( M * A1 ) * h1 ) ; VERIFY_IS_APPROX ( M * ( A1c * h1 ) , ( M * A1c ) * h1 ) ; VERIFY_IS_APPROX ( M * ( P1 * h1 ) , ( ( M * P1 ) * h1 ) ) ; } template < typename Scalar > void transform_alignment ( ) { typedef Transform < Scalar , 3 , Projective , AutoAlign > Projective3a ; typedef Transform < Scalar , 3 , Projective , DontAlign > Projective3u ; EIGEN_ALIGN_MAX Scalar array1 [ 16 ] ; EIGEN_ALIGN_MAX Scalar array2 [ 16 ] ; EIGEN_ALIGN_MAX Scalar array3 [ 16 + 1 ] ; Scalar * array3u = array3 + 1 ; Projective3a * p1 = :: new ( reinterpret_cast < void * > ( array1 ) ) Projective3a ; Projective3u * p2 = :: new ( reinterpret_cast < void * > ( array2 ) ) Projective3u ; Projective3u * p3 = :: new ( reinterpret_cast < void * > ( array3u ) ) Projective3u ; p1 -> matrix ( ) . setRandom ( ) ; * p2 = * p1 ; * p3 = * p1 ; VERIFY_IS_APPROX ( p1 -> matrix ( ) , p2 -> matrix ( ) ) ; VERIFY_IS_APPROX ( p1 -> matrix ( ) , p3 -> matrix ( ) ) ; VERIFY_IS_APPROX ( ( * p1 ) * ( * p1 ) , ( * p2 ) * ( * p3 ) ) ; # if defined ( EIGEN_VECTORIZE ) && EIGEN_MAX_STATIC_ALIGN_BYTES > 0 if ( internal :: packet_traits < Scalar > :: Vectorizable ) VERIFY_RAISES_ASSERT ( ( :: new ( reinterpret_cast < void * > ( array3u ) ) Projective3a ) ) ; # endif } template < typename Scalar , int Dim , int Options > void transform_products ( ) { typedef Matrix < Scalar , Dim + 1 , Dim + 1 > Mat ; typedef Transform < Scalar , Dim , Projective , Options > Proj ; typedef Transform < Scalar , Dim , Affine , Options > Aff ; typedef Transform < Scalar , Dim , AffineCompact , Options > AffC ; Proj p ; p . matrix ( ) . setRandom ( ) ; Aff a ; a . linear ( ) . setRandom ( ) ; a . translation ( ) . setRandom ( ) ; AffC ac = a ; Mat p_m ( p . matrix ( ) ) , a_m ( a . matrix ( ) ) ; VERIFY_IS_APPROX ( ( p * p ) . matrix ( ) , p_m * p_m ) ; VERIFY_IS_APPROX ( ( a * a ) . matrix ( ) , a_m * a_m ) ; VERIFY_IS_APPROX ( ( p * a ) . matrix ( ) , p_m * a_m ) ; VERIFY_IS_APPROX ( ( a * p ) . matrix ( ) , a_m * p_m ) ; VERIFY_IS_APPROX ( ( ac * a ) . matrix ( ) , a_m * a_m ) ; VERIFY_IS_APPROX ( ( a * ac ) . matrix ( ) , a_m * a_m ) ; VERIFY_IS_APPROX ( ( p * ac ) . matrix ( ) , p_m * a_m ) ; VERIFY_IS_APPROX ( ( ac * p ) . matrix ( ) , a_m * p_m ) ; } void test_geo_transformations ( ) { for ( int i = 0 ; i < g_repeat ; i ++ ) { CALL_SUBTEST_1 ( ( transformations < double , Affine , AutoAlign > ( ) ) ) ; CALL_SUBTEST_1 ( ( non_projective_only < double , Affine , AutoAlign > ( ) ) ) ; CALL_SUBTEST_2 ( ( transformations < float , AffineCompact , AutoAlign > ( ) ) ) ; CALL_SUBTEST_2 ( ( non_projective_only < float , AffineCompact , AutoAlign > ( ) ) ) ; CALL_SUBTEST_2 ( ( transform_alignment < float > ( ) ) ) ; CALL_SUBTEST_3 ( ( transformations < double , Projective , AutoAlign > ( ) ) ) ; CALL_SUBTEST_3 ( ( transformations < double , Projective , DontAlign > ( ) ) ) ; CALL_SUBTEST_3 ( ( transform_alignment < double > ( ) ) ) ; CALL_SUBTEST_4 ( ( transformations < float , Affine , RowMajor | AutoAlign > ( ) ) ) ; CALL_SUBTEST_4 ( ( non_projective_only < float , Affine , RowMajor > ( ) ) ) ; CALL_SUBTEST_5 ( ( transformations < double , AffineCompact , RowMajor | AutoAlign > ( ) ) ) ; CALL_SUBTEST_5 ( ( non_projective_only < double , AffineCompact , RowMajor > ( ) ) ) ; CALL_SUBTEST_6 ( ( transformations < double , Projective , RowMajor | AutoAlign > ( ) ) ) ; CALL_SUBTEST_6 ( ( transformations < double , Projective , RowMajor | DontAlign > ( ) ) ) ; CALL_SUBTEST_7 ( ( transform_products < double , 3 , RowMajor | AutoAlign > ( ) ) ) ; CALL_SUBTEST_7 ( ( transform_products < float , 2 , AutoAlign > ( ) ) ) ; CALL_SUBTEST_8 ( ( transform_associativity < double , 2 , ColMajor > ( Rotation2D < double > ( internal :: random < double > ( ) * double ( EIGEN_PI ) ) ) ) ) ; CALL_SUBTEST_8 ( ( transform_associativity < double , 3 , ColMajor > ( Quaterniond :: UnitRandom ( ) ) ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="twalpole/selenium/tree/master/cpp/iedriver/CommandHandlers/MaximizeWindowCommandHandler.cpp"> # include " MaximizeWindowCommandHandler . h " # include " errorcodes . h " # include " . . / Browser . h " # include " . . / IECommandExecutor . h " namespace webdriver { MaximizeWindowCommandHandler :: MaximizeWindowCommandHandler ( void ) { } MaximizeWindowCommandHandler :: ~ MaximizeWindowCommandHandler ( void ) { } void MaximizeWindowCommandHandler :: ExecuteInternal ( const IECommandExecutor & executor , const ParametersMap & command_parameters , Response * response ) { int status_code = WD_SUCCESS ; BrowserHandle browser_wrapper ; status_code = executor . GetCurrentBrowser ( & browser_wrapper ) ; if ( status_code != WD_SUCCESS ) { response -> SetErrorResponse ( ERROR_NO_SUCH_WINDOW , " Error ▁ retrieving ▁ window " ) ; return ; } HWND window_handle = browser_wrapper -> GetTopLevelWindowHandle ( ) ; if ( ! :: IsZoomed ( window_handle ) ) { browser_wrapper -> Restore ( ) ; :: ShowWindow ( window_handle , SW_MAXIMIZE ) ; } RECT window_rect ; :: GetWindowRect ( window_handle , & window_rect ) ; Json :: Value response_value ; response_value [ " width " ] = window_rect . right - window_rect . left ; response_value [ " height " ] = window_rect . bottom - window_rect . top ; response_value [ " x " ] = window_rect . left ; response_value [ " y " ] = window_rect . top ; response -> SetSuccessResponse ( response_value ) ; } } </DOCUMENT>
<DOCUMENT_ID="taiki-okano/Algorithm/tree/master/AOJ/AOJ0554.cpp"> # include < cstdio > int main ( ) { int sum = 0 ; for ( int i = 0 ; i < 4 ; ++ i ) { int in ; scanf ( " % d " , & in ) ; sum += in ; } printf ( " % d \n " , sum / 60 ) ; printf ( " % d \n " , sum % 60 ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="MestreLion/boinc-debian/tree/master/clientgui/BOINCGUIApp.cpp"> # if defined ( __GNUG__ ) && ! defined ( __APPLE__ ) # pragma implementation " BOINCGUIApp . h " # endif # ifdef __WXMAC__ # include < Carbon / Carbon . h > # include " filesys . h " # include " util . h " # if ( defined ( SANDBOX ) && defined ( _DEBUG ) ) # include " SetupSecurity . h " # endif # include " sandbox . h " # endif # include " stdwx . h " # include " diagnostics . h " # include " network . h " # include " util . h " # include " mfile . h " # include " miofile . h " # include " parse . h " # include " idlemon . h " # include " Events . h " # include " common / wxFlatNotebook . h " # include " BOINCInternetFSHandler . h " # include " LogBOINC . h " # include " BOINCGUIApp . h " # include " SkinManager . h " # include " MainDocument . h " # include " BOINCClientManager . h " # include " BOINCTaskBar . h " # include " BOINCBaseFrame . h " # include " AdvancedFrame . h " # include " DlgExitMessage . h " # include " DlgEventLog . h " # include " procinfo . h " # include " sg _ BoincSimpleFrame . h " DEFINE_EVENT_TYPE ( wxEVT_RPC_FINISHED ) IMPLEMENT_APP ( CBOINCGUIApp ) IMPLEMENT_DYNAMIC_CLASS ( CBOINCGUIApp , wxApp ) BEGIN_EVENT_TABLE ( CBOINCGUIApp , wxApp ) EVT_ACTIVATE_APP ( CBOINCGUIApp :: OnActivateApp ) EVT_RPC_FINISHED ( CBOINCGUIApp :: OnRPCFinished ) END_EVENT_TABLE ( ) bool s_bSkipExitConfirmation = false ; # ifdef __WXMAC__ OSErr QuitAppleEventHandler ( const AppleEvent * appleEvt , AppleEvent * reply , UInt32 refcon ) { DescType senderType ; Size actualSize ; ProcessSerialNumber SenderPSN ; ProcessInfoRec pInfo ; FSSpec fileSpec ; OSStatus anErr ; if ( wxGetApp ( ) . IsModalDialogDisplayed ( ) ) { SysBeep ( 4 ) ; return userCanceledErr ; } anErr = AEGetAttributePtr ( appleEvt , keyAddressAttr , typeProcessSerialNumber , & senderType , & SenderPSN , sizeof ( SenderPSN ) , & actualSize ) ; if ( anErr == noErr ) { pInfo . processInfoLength = sizeof ( ProcessInfoRec ) ; pInfo . processName = NULL ; pInfo . processAppSpec = & fileSpec ; anErr = GetProcessInformation ( & SenderPSN , & pInfo ) ; if ( ( pInfo . processSignature != ' dock ' ) && ( pInfo . processSignature != ' BNC ! ' ) ) { s_bSkipExitConfirmation = true ; wxGetApp ( ) . ExitMainLoop ( ) ; } } return wxGetApp ( ) . MacHandleAEQuit ( ( AppleEvent * ) appleEvt , reply ) ; } # endif bool CBOINCGUIApp :: OnInit ( ) { # ifdef SANDBOX g_use_sandbox = true ; # else g_use_sandbox = false ; # endif s_bSkipExitConfirmation = false ; m_bFilterEvents = false ; m_pLocale = NULL ; m_pSkinManager = NULL ; m_pFrame = NULL ; m_pDocument = NULL ; m_pTaskBarIcon = NULL ; m_pEventLog = NULL ; # ifdef __WXMAC__ m_pMacSystemMenu = NULL ; # endif m_strBOINCMGRExecutableName = wxEmptyString ; m_strBOINCMGRRootDirectory = wxEmptyString ; m_strBOINCMGRDataDirectory = wxEmptyString ; m_strHostNameArg = wxEmptyString ; m_strPasswordArg = wxEmptyString ; m_iRPCPortArg = GUI_RPC_PORT ; m_strBOINCArguments = wxEmptyString ; m_bGUIVisible = true ; m_bDebugSkins = false ; m_bMultipleInstancesOK = false ; m_bBOINCMGRAutoStarted = false ; m_iBOINCMGRDisableAutoStart = 0 ; m_iShutdownCoreClient = 0 ; m_iDisplayExitDialog = 1 ; m_iGUISelected = BOINC_SIMPLEGUI ; m_bSafeMessageBoxDisplayed = 0 ; # ifdef __WXMSW__ m_hClientLibraryDll = NULL ; # endif int iErrorCode = 0 ; int iSelectedLanguage = 0 ; bool bOpenEventLog = false ; wxString strDesiredSkinName = wxEmptyString ; wxString strDialogMessage = wxEmptyString ; bool success = false ; # ifdef __WXMSW__ wxSystemOptions :: SetOption ( wxT ( " msw . staticbox . optimized - paint " ) , 0 ) ; # endif # ifdef __WXMAC__ wxSystemOptions :: SetOption ( wxT ( " mac . listctrl . always _ use _ generic " ) , 1 ) ; AEInstallEventHandler ( kCoreEventClass , kAEQuitApplication , NewAEEventHandlerUPP ( ( AEEventHandlerProcPtr ) QuitAppleEventHandler ) , 0 , false ) ; GetCurrentProcess ( & m_psnCurrentProcess ) ; # endif if ( ! wxApp :: OnInit ( ) ) { return false ; } if ( g_use_sandbox ) { wxCHANGE_UMASK ( 2 ) ; } SetAppName ( wxT ( " BOINC ▁ Manager " ) ) ; SetVendorName ( wxT ( " Space ▁ Sciences ▁ Laboratory , ▁ U . C . ▁ Berkeley " ) ) ; m_pConfig = new wxConfig ( GetAppName ( ) ) ; wxConfigBase :: Set ( m_pConfig ) ; wxASSERT ( m_pConfig ) ; m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Read ( wxT ( " AutomaticallyShutdownClient " ) , & m_iShutdownCoreClient , 0L ) ; m_pConfig -> Read ( wxT ( " DisplayShutdownClientDialog " ) , & m_iDisplayExitDialog , 1L ) ; m_pConfig -> Read ( wxT ( " DisableAutoStart " ) , & m_iBOINCMGRDisableAutoStart , 0L ) ; m_pConfig -> Read ( wxT ( " Language " ) , & iSelectedLanguage , 0L ) ; m_pConfig -> Read ( wxT ( " GUISelection " ) , & m_iGUISelected , BOINC_SIMPLEGUI ) ; m_pConfig -> Read ( wxT ( " EventLogOpen " ) , & bOpenEventLog ) ; if ( m_bBOINCMGRAutoStarted && m_iBOINCMGRDisableAutoStart ) { return false ; } DetectExecutableName ( ) ; DetectRootDirectory ( ) ; DetectDataDirectory ( ) ; if ( ! GetDataDirectory ( ) . IsEmpty ( ) ) { success = wxSetWorkingDirectory ( GetDataDirectory ( ) ) ; if ( ! success ) { if ( ! g_use_sandbox ) { if ( ! wxDirExists ( GetDataDirectory ( ) ) ) { success = wxMkdir ( GetDataDirectory ( ) , 0777 ) ; } } } } if ( ! success ) iErrorCode = - 1016 ; int dwDiagnosticsFlags = BOINC_DIAG_DUMPCALLSTACKENABLED | BOINC_DIAG_HEAPCHECKENABLED | BOINC_DIAG_MEMORYLEAKCHECKENABLED | # if defined ( __WXMSW__ ) || defined ( __WXMAC__ ) BOINC_DIAG_REDIRECTSTDERR | BOINC_DIAG_REDIRECTSTDOUT | # endif BOINC_DIAG_TRACETOSTDOUT ; diagnostics_init ( dwDiagnosticsFlags , " stdoutgui " , " stderrgui " ) ; m_pLog = new wxLogBOINC ( ) ; wxLog :: SetActiveTarget ( m_pLog ) ; m_pLog -> AddTraceMask ( wxT ( " Function ▁ Start / End " ) ) ; m_pLog -> AddTraceMask ( wxT ( " Function ▁ Status " ) ) ; # ifdef __WXMSW__ _configthreadlocale ( _ENABLE_PER_THREAD_LOCALE ) ; # endif m_pLocale = new wxLocale ( ) ; wxASSERT ( m_pLocale ) ; m_pLocale -> Init ( iSelectedLanguage ) ; if ( ! m_strBOINCMGRRootDirectory . IsEmpty ( ) ) { m_pLocale -> AddCatalogLookupPathPrefix ( wxString ( m_strBOINCMGRRootDirectory + wxT ( " locale " ) ) ) ; } m_pLocale -> AddCatalogLookupPathPrefix ( wxT ( " locale " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Manager " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Client " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Web " ) ) ; InitSupportedLanguages ( ) ; wxHelpProvider :: Set ( new wxHelpControllerHelpProvider ( ) ) ; wxInitAllImageHandlers ( ) ; wxFileSystem :: AddHandler ( new wxMemoryFSHandler ) ; m_pInternetFSHandler = new CBOINCInternetFSHandler ; wxFileSystem :: AddHandler ( m_pInternetFSHandler ) ; m_pSkinManager = new CSkinManager ( m_bDebugSkins ) ; wxASSERT ( m_pSkinManager ) ; m_pConfig -> Read ( wxT ( " Skin " ) , & strDesiredSkinName , m_pSkinManager -> GetDefaultSkinName ( ) ) ; m_pSkinManager -> ReloadSkin ( strDesiredSkinName ) ; # ifdef SANDBOX char path_to_error [ MAXPATHLEN ] ; path_to_error [ 0 ] = ' \0' ; if ( ! iErrorCode ) { # if ( defined ( __WXMAC__ ) && defined ( _DEBUG ) ) if ( check_security ( g_use_sandbox , true ) ) { CreateBOINCUsersAndGroups ( ) ; SetBOINCDataOwnersGroupsAndPermissions ( ) ; SetBOINCAppOwnersGroupsAndPermissions ( NULL ) ; } # endif iErrorCode = check_security ( g_use_sandbox , true , path_to_error ) ; } if ( iErrorCode ) { ShowApplication ( true ) ; if ( iErrorCode == - 1099 ) { strDialogMessage . Printf ( _ ( " You ▁ currently ▁ are ▁ not ▁ authorized ▁ to ▁ manage ▁ the ▁ client . \n \n To ▁ run ▁ % s ▁ as ▁ this ▁ user , ▁ please : \n ▁ ▁ - ▁ reinstall ▁ % s ▁ answering ▁ \ " Yes\ " ▁ to ▁ the ▁ question ▁ about \n ▁ ▁ ▁ ▁ ▁ non - administrative ▁ users \n ▁ or \n ▁ ▁ - ▁ contact ▁ your ▁ administrator ▁ to ▁ add ▁ you ▁ to ▁ the ▁ ' boinc _ master ' \n ▁ ▁ ▁ ▁ ▁ user ▁ group . " ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) ) ; } else { strDialogMessage . Printf ( _ ( " % s ▁ ownership ▁ or ▁ permissions ▁ are ▁ not ▁ set ▁ properly ; ▁ please ▁ reinstall ▁ % s . \n ( Error ▁ code ▁ % d " ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , iErrorCode ) ; if ( path_to_error [ 0 ] ) { strDialogMessage += _ ( " ▁ at ▁ " ) ; strDialogMessage += wxString :: FromUTF8 ( path_to_error ) ; } strDialogMessage += _ ( " ) " ) ; fprintf ( stderr , " % ls ▁ ownership ▁ or ▁ permissions ▁ are ▁ not ▁ set ▁ properly ; ▁ please ▁ reinstall ▁ % ls . \n ( Error ▁ code ▁ % d ▁ at ▁ % s ) " , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , iErrorCode , path_to_error ) ; } wxMessageDialog * pDlg = new wxMessageDialog ( NULL , strDialogMessage , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , wxOK ) ; pDlg -> ShowModal ( ) ; if ( pDlg ) pDlg -> Destroy ( ) ; return false ; } # endif # ifdef __WXMSW__ wxString strRebootPendingFile = GetRootDirectory ( ) + wxFileName :: GetPathSeparator ( ) + wxT ( " RebootPending . txt " ) ; if ( wxFile :: Exists ( strRebootPendingFile ) ) { wxMessageDialog dialog ( NULL , _ ( " A ▁ reboot ▁ is ▁ required ▁ in ▁ order ▁ for ▁ BOINC ▁ to ▁ run ▁ properly . \n Please ▁ reboot ▁ your ▁ computer ▁ and ▁ try ▁ again . " ) , _ ( " BOINC ▁ Manager " ) , wxOK | wxICON_ERROR ) ; dialog . ShowModal ( ) ; return false ; } # endif if ( ! m_bMultipleInstancesOK ) { if ( DetectDuplicateInstance ( ) ) { return false ; } } m_pDocument = new CMainDocument ( ) ; wxASSERT ( m_pDocument ) ; m_pDocument -> OnInit ( ) ; if ( BOINC_SIMPLEGUI == m_iGUISelected ) { if ( wxGetDisplaySize ( ) . GetHeight ( ) < 600 ) { m_iGUISelected = BOINC_ADVANCEDGUI ; } } m_pTaskBarIcon = new CTaskBarIcon ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationDisconnectedIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationSnoozeIcon ( ) ) ; wxASSERT ( m_pTaskBarIcon ) ; # ifdef __WXMAC__ m_pMacSystemMenu = new CMacSystemMenu ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationDisconnectedIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationSnoozeIcon ( ) ) ; wxASSERT ( m_pMacSystemMenu ) ; # endif IdleTrackerAttach ( ) ; # ifdef __WXMAC__ ProcessSerialNumber psn ; ProcessInfoRec pInfo ; OSStatus err ; memset ( & pInfo , 0 , sizeof ( pInfo ) ) ; pInfo . processInfoLength = sizeof ( ProcessInfoRec ) ; err = GetProcessInformation ( & m_psnCurrentProcess , & pInfo ) ; if ( ! err ) { psn = pInfo . processLauncher ; memset ( & pInfo , 0 , sizeof ( pInfo ) ) ; pInfo . processInfoLength = sizeof ( ProcessInfoRec ) ; err = GetProcessInformation ( & psn , & pInfo ) ; } if ( pInfo . processSignature == ' lgnw ' ) { m_bGUIVisible = false ; sleep ( 10 ) ; } # endif SetActiveGUI ( m_iGUISelected , false ) ; if ( m_bGUIVisible ) { SetActiveGUI ( m_iGUISelected ) ; } else { ShowApplication ( false ) ; } if ( bOpenEventLog ) { DisplayEventLog ( m_bGUIVisible ) ; m_pFrame -> Raise ( ) ; } return true ; } int CBOINCGUIApp :: OnExit ( ) { IdleTrackerDetach ( ) ; if ( m_pDocument ) { m_pDocument -> OnExit ( ) ; delete m_pDocument ; m_pDocument = NULL ; } m_pConfig -> SetPath ( wxT ( " / " ) ) ; if ( m_pSkinManager ) { m_pConfig -> Write ( wxT ( " Skin " ) , m_pSkinManager -> GetSelectedSkin ( ) ) ; delete m_pSkinManager ; } if ( m_pLocale ) { delete m_pLocale ; m_pLocale = NULL ; } if ( m_pEventLog ) { m_pEventLog -> Destroy ( ) ; m_pEventLog = NULL ; } m_pConfig -> Write ( wxT ( " AutomaticallyShutdownClient " ) , m_iShutdownCoreClient ) ; m_pConfig -> Write ( wxT ( " DisplayShutdownClientDialog " ) , m_iDisplayExitDialog ) ; m_pConfig -> Write ( wxT ( " DisableAutoStart " ) , m_iBOINCMGRDisableAutoStart ) ; diagnostics_finish ( ) ; return wxApp :: OnExit ( ) ; } void CBOINCGUIApp :: OnInitCmdLine ( wxCmdLineParser & parser ) { wxApp :: OnInitCmdLine ( parser ) ; static const wxCmdLineEntryDesc cmdLineDesc [ ] = { { wxCMD_LINE_SWITCH , wxT ( " a " ) , wxT ( " autostart " ) , _ ( " BOINC ▁ Manager ▁ was ▁ started ▁ by ▁ the ▁ operating ▁ system ▁ automatically " ) } , # if defined ( __WXMSW__ ) || defined ( __WXMAC__ ) { wxCMD_LINE_SWITCH , wxT ( " s " ) , wxT ( " systray " ) , _ ( " Startup ▁ BOINC ▁ so ▁ only ▁ the ▁ system ▁ tray ▁ icon ▁ is ▁ visible " ) } , # else { wxCMD_LINE_OPTION , wxT ( " e " ) , wxT ( " clientdir " ) , _ ( " Directory ▁ containing ▁ the ▁ BOINC ▁ Client ▁ executable " ) } , { wxCMD_LINE_OPTION , wxT ( " d " ) , wxT ( " datadir " ) , _ ( " BOINC ▁ data ▁ directory " ) } , # endif { wxCMD_LINE_OPTION , wxT ( " n " ) , wxT ( " namehost " ) , _ ( " Host ▁ name ▁ or ▁ IP ▁ address " ) } , { wxCMD_LINE_OPTION , wxT ( " g " ) , wxT ( " gui _ rpc _ port " ) , _ ( " GUI ▁ RPC ▁ port ▁ number " ) } , { wxCMD_LINE_OPTION , wxT ( " p " ) , wxT ( " password " ) , _ ( " Password " ) } , { wxCMD_LINE_OPTION , wxT ( " b " ) , wxT ( " boincargs " ) , _ ( " Startup ▁ BOINC ▁ with ▁ these ▁ optional ▁ arguments " ) } , { wxCMD_LINE_SWITCH , wxT ( " i " ) , wxT ( " insecure " ) , _ ( " disable ▁ BOINC ▁ security ▁ users ▁ and ▁ permissions " ) } , { wxCMD_LINE_SWITCH , wxT ( " c " ) , wxT ( " checkskins " ) , _ ( " set ▁ skin ▁ debugging ▁ mode ▁ to ▁ enable ▁ skin ▁ manager ▁ error ▁ messages " ) } , { wxCMD_LINE_SWITCH , wxT ( " m " ) , wxT ( " multiple " ) , _ ( " multiple ▁ instances ▁ of ▁ BOINC ▁ Manager ▁ allowed " ) } , # if ( defined ( __WXMAC__ ) && defined ( _DEBUG ) ) { wxCMD_LINE_OPTION , wxT ( " NSDocumentRevisionsDebugMode " ) , NULL , _ ( " Not ▁ used : ▁ workaround ▁ for ▁ bug ▁ in ▁ XCode ▁ 4.2" ) } , # endif { wxCMD_LINE_NONE } } ; parser . SetDesc ( cmdLineDesc ) ; } bool CBOINCGUIApp :: OnCmdLineParsed ( wxCmdLineParser & parser ) { wxApp :: OnCmdLineParsed ( parser ) ; wxString portNum = wxEmptyString ; long longPort ; bool hostNameSpecified = false ; bool passwordSpecified = false ; parser . Found ( wxT ( " boincargs " ) , & m_strBOINCArguments ) ; if ( parser . Found ( wxT ( " autostart " ) ) ) { m_bBOINCMGRAutoStarted = true ; } # if defined ( __WXMSW__ ) || defined ( __WXMAC__ ) if ( parser . Found ( wxT ( " systray " ) ) ) { m_bGUIVisible = false ; } # endif if ( parser . Found ( wxT ( " insecure " ) ) ) { g_use_sandbox = false ; } if ( parser . Found ( wxT ( " checkskins " ) ) ) { m_bDebugSkins = true ; } if ( parser . Found ( wxT ( " multiple " ) ) ) { m_bMultipleInstancesOK = true ; } # if ! ( defined ( __WXMSW__ ) || defined ( __WXMAC__ ) ) if ( ! parser . Found ( wxT ( " clientdir " ) , & m_strBOINCMGRRootDirectory ) ) { m_strBOINCMGRRootDirectory = :: wxGetCwd ( ) ; } if ( m_strBOINCMGRRootDirectory . Last ( ) != ' / ' ) { m_strBOINCMGRRootDirectory . Append ( ' / ' ) ; } if ( ! parser . Found ( wxT ( " datadir " ) , & m_strBOINCMGRDataDirectory ) ) { m_strBOINCMGRDataDirectory = m_strBOINCMGRRootDirectory ; } if ( m_strBOINCMGRDataDirectory . Last ( ) != ' / ' ) { m_strBOINCMGRDataDirectory . Append ( ' / ' ) ; } # endif if ( parser . Found ( wxT ( " namehost " ) , & m_strHostNameArg ) ) { hostNameSpecified = true ; } else { m_strHostNameArg = wxT ( " localhost " ) ; } if ( parser . Found ( wxT ( " gui _ rpc _ port " ) , & portNum ) ) { if ( portNum . ToLong ( & longPort ) ) { m_iRPCPortArg = longPort ; } else { m_iRPCPortArg = GUI_RPC_PORT ; } } else { m_iRPCPortArg = GUI_RPC_PORT ; } if ( parser . Found ( wxT ( " password " ) , & m_strPasswordArg ) ) { passwordSpecified = true ; } else { m_strPasswordArg = wxEmptyString ; } if ( hostNameSpecified && passwordSpecified ) { m_bMultipleInstancesOK = true ; } return true ; } bool CBOINCGUIApp :: DetectDuplicateInstance ( ) { # ifdef __WXMSW__ if ( CTaskBarIcon :: FireAppRestore ( ) ) { return true ; } # endif # ifdef __WXMAC__ ProcessSerialNumber PSN ; int iInstanceID = wxGetApp ( ) . IsAnotherInstanceRunning ( ) ; if ( iInstanceID ) { OSStatus err = GetProcessForPID ( iInstanceID , & PSN ) ; if ( ! err ) SetFrontProcess ( & PSN ) ; return true ; } # endif return false ; } void CBOINCGUIApp :: DetectExecutableName ( ) { # ifdef __WXMSW__ TCHAR szPath [ MAX_PATH - 1 ] ; GetModuleFileName ( NULL , szPath , ( sizeof ( szPath ) / sizeof ( TCHAR ) ) ) ; TCHAR * pszProg = _tcsrchr ( szPath , ' \\ ' ) ; if ( pszProg ) { pszProg ++ ; } m_strBOINCMGRExecutableName = pszProg ; # endif } void CBOINCGUIApp :: DetectRootDirectory ( ) { # ifdef __WXMSW__ TCHAR szPath [ MAX_PATH - 1 ] ; GetModuleFileName ( NULL , szPath , ( sizeof ( szPath ) / sizeof ( TCHAR ) ) ) ; TCHAR * pszProg = _tcsrchr ( szPath , ' \\ ' ) ; if ( pszProg ) { szPath [ pszProg - szPath + 1 ] = 0 ; } m_strBOINCMGRRootDirectory = szPath ; # endif } void CBOINCGUIApp :: DetectDataDirectory ( ) { # ifdef __WXMSW__ LONG lReturnValue ; HKEY hkSetupHive ; LPTSTR lpszRegistryValue = NULL ; DWORD dwSize = 0 ; lReturnValue = RegOpenKeyEx ( HKEY_LOCAL_MACHINE , _T ( " SOFTWARE\\Space ▁ Sciences ▁ Laboratory , ▁ U . C . ▁ Berkeley\\BOINC ▁ Setup " ) , 0 , KEY_READ , & hkSetupHive ) ; if ( lReturnValue == ERROR_SUCCESS ) { lReturnValue = RegQueryValueEx ( hkSetupHive , _T ( " DATADIR " ) , NULL , NULL , NULL , & dwSize ) ; if ( lReturnValue != ERROR_FILE_NOT_FOUND ) { lpszRegistryValue = ( LPTSTR ) malloc ( dwSize ) ; ( * lpszRegistryValue ) = NULL ; lReturnValue = RegQueryValueEx ( hkSetupHive , _T ( " DATADIR " ) , NULL , NULL , ( LPBYTE ) lpszRegistryValue , & dwSize ) ; m_strBOINCMGRDataDirectory = lpszRegistryValue ; } } if ( hkSetupHive ) RegCloseKey ( hkSetupHive ) ; if ( lpszRegistryValue ) free ( lpszRegistryValue ) ; # endif # ifdef __WXMAC__ m_strBOINCMGRDataDirectory = wxT ( " / Library / Application ▁ Support / BOINC ▁ Data " ) ; # endif } void CBOINCGUIApp :: InitSupportedLanguages ( ) { wxInt32 iIndex = 0 ; const wxLanguageInfo * liLanguage = NULL ; m_astrLanguages . Insert ( wxEmptyString , 0 , wxLANGUAGE_USER_DEFINED + 1 ) ; m_astrLanguages [ wxLANGUAGE_DEFAULT ] = _ ( " ( Automatic ▁ Detection ) " ) ; m_astrLanguages [ wxLANGUAGE_UNKNOWN ] = _ ( " ( Unknown ) " ) ; m_astrLanguages [ wxLANGUAGE_USER_DEFINED ] = _ ( " ( User ▁ Defined ) " ) ; for ( iIndex = 0 ; iIndex <= wxLANGUAGE_USER_DEFINED ; iIndex ++ ) { liLanguage = wxLocale :: GetLanguageInfo ( iIndex ) ; if ( liLanguage ) { m_astrLanguages [ iIndex ] = liLanguage -> Description ; } } } int CBOINCGUIApp :: IdleTrackerAttach ( ) { # ifdef __WXMSW__ :: attach_idle_monitor ( ) ; # endif return 0 ; } int CBOINCGUIApp :: IdleTrackerDetach ( ) { # ifdef __WXMSW__ :: detach_idle_monitor ( ) ; # endif return 0 ; } void CBOINCGUIApp :: OnActivateApp ( wxActivateEvent & event ) { # ifdef __WXMAC__ if ( IsModalDialogDisplayed ( ) ) { event . Skip ( ) ; return ; } # endif if ( event . GetActive ( ) ) { if ( m_pEventLog && ! m_pEventLog -> IsIconized ( ) ) { m_pEventLog -> Raise ( ) ; } if ( m_pFrame ) m_pFrame -> Raise ( ) ; } event . Skip ( ) ; } void CBOINCGUIApp :: OnRPCFinished ( CRPCFinishedEvent & event ) { CMainDocument * pDoc = wxGetApp ( ) . GetDocument ( ) ; wxASSERT ( pDoc ) ; wxASSERT ( wxDynamicCast ( pDoc , CMainDocument ) ) ; pDoc -> OnRPCComplete ( event ) ; } int CBOINCGUIApp :: UpdateSystemIdleDetection ( ) { # ifdef __WXMSW__ return get_idle_tick_count ( ) ; # else return TRUE ; # endif } int CBOINCGUIApp :: StartBOINCScreensaverTest ( ) { # ifdef __WXMSW__ wxString strExecute = wxEmptyString ; wxChar szExecutableDirectory [ 4096 ] ; memset ( szExecutableDirectory , 0 , sizeof ( szExecutableDirectory ) ) ; GetWindowsDirectory ( szExecutableDirectory , ( sizeof ( szExecutableDirectory ) / sizeof ( wxChar ) ) ) ; strExecute = wxT ( " \ " " ) + wxString ( szExecutableDirectory ) + wxT ( " \\boinc . scr\ " ▁ / t " ) ; :: wxExecute ( strExecute ) ; # endif return 0 ; } int CBOINCGUIApp :: StartBOINCDefaultScreensaverTest ( ) { # ifdef __WXMSW__ wxString strExecute = wxEmptyString ; strExecute = wxT ( " \ " " ) + m_strBOINCMGRRootDirectory + wxT ( " \\boincscr . exe\ " ▁ - - test " ) ; :: wxExecute ( strExecute ) ; # endif return 0 ; } void CBOINCGUIApp :: DisplayEventLog ( bool bShowWindow ) { if ( m_pEventLog ) { if ( bShowWindow ) { if ( m_pEventLog -> IsIconized ( ) ) { m_pEventLog -> Iconize ( false ) ; } m_pEventLog -> Raise ( ) ; } } else { m_pEventLog = new CDlgEventLog ( ) ; if ( m_pEventLog ) { m_pEventLog -> Show ( bShowWindow ) ; if ( bShowWindow ) { m_pEventLog -> Raise ( ) ; } if ( m_pFrame ) { m_pFrame -> UpdateRefreshTimerInterval ( ) ; } } } } void CBOINCGUIApp :: OnEventLogClose ( ) { m_pEventLog = NULL ; if ( m_pFrame ) { m_pFrame -> UpdateRefreshTimerInterval ( ) ; } } void CBOINCGUIApp :: FireReloadSkin ( ) { if ( m_pFrame ) { m_pFrame -> FireReloadSkin ( ) ; } if ( m_pTaskBarIcon ) { m_pTaskBarIcon -> FireReloadSkin ( ) ; } } bool CBOINCGUIApp :: SetActiveGUI ( int iGUISelection , bool bShowWindow ) { wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ Function ▁ Begin " ) ) ; wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ GUI ▁ Selection : ▁ ' % d ' , ▁ Show : ▁ % d ' " ) , iGUISelection , ( int ) bShowWindow ) ; CBOINCBaseFrame * pNewFrame = NULL ; CBOINCBaseFrame * pOldFrame = m_pFrame ; wxInt32 iTop = 0 ; wxInt32 iLeft = 0 ; wxInt32 iHeight = 0 ; wxInt32 iWidth = 0 ; if ( ( iGUISelection != m_iGUISelected ) || ! m_pFrame ) { if ( BOINC_ADVANCEDGUI == iGUISelection ) { m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Read ( wxT ( " YPos " ) , & iTop , 30 ) ; m_pConfig -> Read ( wxT ( " XPos " ) , & iLeft , 30 ) ; m_pConfig -> Read ( wxT ( " Width " ) , & iWidth , 800 ) ; m_pConfig -> Read ( wxT ( " Height " ) , & iHeight , 600 ) ; } else { m_pConfig -> SetPath ( wxT ( " / Simple " ) ) ; m_pConfig -> Read ( wxT ( " YPos " ) , & iTop , 30 ) ; m_pConfig -> Read ( wxT ( " XPos " ) , & iLeft , 30 ) ; # ifdef __WXMAC__ iWidth = 409 ; iHeight = 561 ; # else iWidth = 416 ; iHeight = 570 ; # endif } # ifdef __WXMAC__ if ( ! IsWindowOnScreen ( iLeft , iTop , iWidth , iHeight ) ) { iTop = iLeft = 30 ; } # else if ( iLeft < 0 ) iLeft = 30 ; if ( iTop < 0 ) iTop = 30 ; wxInt32 iMaxWidth = wxSystemSettings :: GetMetric ( wxSYS_SCREEN_X ) ; wxInt32 iMaxHeight = wxSystemSettings :: GetMetric ( wxSYS_SCREEN_Y ) ; if ( iLeft + iWidth > iMaxWidth ) iLeft = iMaxWidth - iWidth ; if ( iTop + iHeight > iMaxHeight ) iTop = iMaxHeight - iHeight ; # endif if ( BOINC_ADVANCEDGUI == iGUISelection ) { pNewFrame = new CAdvancedFrame ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon32 ( ) , wxPoint ( iLeft , iTop ) , wxSize ( iWidth , iHeight ) ) ; } else { pNewFrame = new CSimpleFrame ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon32 ( ) , wxPoint ( iLeft , iTop ) , wxSize ( iWidth , iHeight ) ) ; } wxASSERT ( pNewFrame ) ; if ( pNewFrame ) { SetTopWindow ( pNewFrame ) ; m_pFrame = pNewFrame ; if ( pOldFrame ) pOldFrame -> Hide ( ) ; if ( pOldFrame ) pOldFrame -> Destroy ( ) ; } } if ( m_pFrame && bShowWindow ) { if ( m_pEventLog ) { m_pEventLog -> Show ( ) ; m_pEventLog -> Raise ( ) ; # ifdef __WXMSW__ :: SetForegroundWindow ( ( HWND ) m_pEventLog -> GetHWND ( ) ) ; # endif } if ( ! m_pFrame -> IsShown ( ) ) { m_pFrame -> Show ( ) ; } if ( m_pFrame -> IsIconized ( ) ) { m_pFrame -> Maximize ( false ) ; } m_pFrame -> Raise ( ) ; # ifdef __WXMSW__ :: SetForegroundWindow ( ( HWND ) m_pFrame -> GetHWND ( ) ) ; # endif } m_iGUISelected = iGUISelection ; m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Write ( wxT ( " GUISelection " ) , iGUISelection ) ; wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ Function ▁ End " ) ) ; return true ; } int CBOINCGUIApp :: ConfirmExit ( ) { CSkinAdvanced * pSkinAdvanced = wxGetApp ( ) . GetSkinManager ( ) -> GetAdvanced ( ) ; CMainDocument * pDoc = wxGetApp ( ) . GetDocument ( ) ; wxString strConnectedCompter = wxEmptyString ; bool bWasVisible ; int retval = 0 ; wxASSERT ( pDoc ) ; wxASSERT ( pSkinAdvanced ) ; wxASSERT ( wxDynamicCast ( pDoc , CMainDocument ) ) ; wxASSERT ( wxDynamicCast ( pSkinAdvanced , CSkinAdvanced ) ) ; pDoc -> GetConnectedComputerName ( strConnectedCompter ) ; if ( ! pDoc -> IsComputerNameLocal ( strConnectedCompter ) ) { return 1 ; } if ( s_bSkipExitConfirmation ) return 1 ; if ( IsMgrMultipleInstance ( ) ) return 1 ; if ( ! m_iDisplayExitDialog ) { return 1 ; } bWasVisible = IsApplicationVisible ( ) ; ShowApplication ( true ) ; CDlgExitMessage dlg ( NULL ) ; if ( ! pSkinAdvanced -> GetExitMessage ( ) . IsEmpty ( ) ) { dlg . m_DialogExitMessage -> SetLabel ( pSkinAdvanced -> GetExitMessage ( ) ) ; } # ifdef __WXMSW__ if ( m_iShutdownCoreClient ) { dlg . m_DialogShutdownCoreClient -> SetValue ( TRUE ) ; } # endif if ( m_iDisplayExitDialog ) { dlg . m_DialogDisplay -> SetValue ( FALSE ) ; } dlg . Fit ( ) ; dlg . Centre ( ) ; if ( wxID_OK == dlg . ShowModal ( ) ) { # ifdef __WXMAC__ s_bSkipExitConfirmation = true ; # else m_iShutdownCoreClient = dlg . m_DialogShutdownCoreClient -> GetValue ( ) ; # endif m_iDisplayExitDialog = ! dlg . m_DialogDisplay -> GetValue ( ) ; retval = true ; } if ( ! bWasVisible ) { ShowApplication ( false ) ; } return retval ; } int CBOINCGUIApp :: SafeMessageBox ( const wxString & message , const wxString & caption , long style , wxWindow * parent , int x , int y ) { int retval ; m_bSafeMessageBoxDisplayed ++ ; retval = wxMessageBox ( message , caption , style , parent , x , y ) ; m_bSafeMessageBoxDisplayed -- ; return retval ; } int CBOINCGUIApp :: IsAnotherInstanceRunning ( ) { PROC_MAP pm ; int retval ; char myName [ 256 ] ; int otherInstanceID = 0 ; int myPid ; retval = procinfo_setup ( pm ) ; if ( retval ) return false ; # ifdef _WIN32 myPid = ( int ) GetCurrentProcessId ( ) ; # else myPid = getpid ( ) ; # endif myName [ 0 ] = 0 ; PROC_MAP :: iterator i ; for ( i = pm . begin ( ) ; i != pm . end ( ) ; i ++ ) { PROCINFO & pi = i -> second ; if ( pi . id == myPid ) { strncpy ( myName , pi . command , sizeof ( myName ) ) ; break ; } } if ( myName [ 0 ] == 0 ) { return false ; } for ( i = pm . begin ( ) ; i != pm . end ( ) ; i ++ ) { PROCINFO & pi = i -> second ; if ( pi . id == myPid ) continue ; if ( ! strcmp ( pi . command , myName ) ) { otherInstanceID = pi . id ; break ; } } return otherInstanceID ; } bool CBOINCGUIApp :: IsApplicationVisible ( ) { # ifdef __WXMAC__ if ( IsProcessVisible ( & m_psnCurrentProcess ) ) { return true ; } # endif return false ; } # ifdef __WXMAC__ void CBOINCGUIApp :: ShowApplication ( bool bShow ) { if ( bShow ) { SetFrontProcess ( & m_psnCurrentProcess ) ; } else { ShowHideProcess ( & m_psnCurrentProcess , false ) ; } } # else void CBOINCGUIApp :: ShowApplication ( bool ) { } # endif bool CBOINCGUIApp :: ShowInterface ( ) { return SetActiveGUI ( m_iGUISelected , true ) ; } bool CBOINCGUIApp :: ShowNotifications ( ) { bool retval = false ; retval = SetActiveGUI ( m_iGUISelected , true ) ; if ( retval ) { GetFrame ( ) -> FireNotification ( ) ; GetDocument ( ) -> UpdateUnreadNoticeState ( ) ; } return retval ; } bool CBOINCGUIApp :: IsModalDialogDisplayed ( ) { if ( m_bSafeMessageBoxDisplayed ) return true ; if ( wxDynamicCast ( wxWindow :: FindWindowById ( ID_ANYDIALOG ) , wxDialog ) ) { return true ; } if ( m_pDocument ) { if ( m_pDocument -> WaitingForRPC ( ) ) { return true ; } } return false ; } void CBOINCGUIApp :: DeleteTaskBarIcon ( ) { if ( m_pTaskBarIcon ) { delete m_pTaskBarIcon ; } m_pTaskBarIcon = NULL ; } # ifdef __WXMAC__ void CBOINCGUIApp :: DeleteMacSystemMenu ( ) { if ( m_pMacSystemMenu ) { delete m_pMacSystemMenu ; } m_pMacSystemMenu = NULL ; } # endif int CBOINCGUIApp :: FilterEvent ( wxEvent & event ) { int theEventType ; wxDialog * theRPCWaitDialog ; wxObject * theObject ; if ( ! m_pDocument ) return - 1 ; theEventType = event . GetEventType ( ) ; if ( m_pDocument -> WaitingForRPC ( ) ) { if ( ( theEventType == wxEVT_COMMAND_MENU_SELECTED ) && ( event . GetId ( ) == wxID_OPEN ) ) { return - 1 ; } theRPCWaitDialog = m_pDocument -> GetRPCWaitDialog ( ) ; theObject = event . GetEventObject ( ) ; while ( theObject ) { if ( ! theObject -> IsKindOf ( CLASSINFO ( wxWindow ) ) ) break ; if ( theObject == theRPCWaitDialog ) return - 1 ; theObject = ( ( wxWindow * ) theObject ) -> GetParent ( ) ; } } else { if ( ! m_bFilterEvents ) return - 1 ; } if ( event . IsCommandEvent ( ) ) { return false ; } if ( theEventType == wxEVT_TIMER ) { return false ; } # ifdef __WXMSW__ if ( theEventType == wxEVT_TASKBAR_MOVE ) { return false ; } # endif return - 1 ; } </DOCUMENT>
<DOCUMENT_ID="eugene1g/phantomjs/tree/master/src/qt/qtwebkit/Source/WebCore/css/CSSSupportsRule.cpp"> # include " config . h " # include " CSSSupportsRule . h " # include " CSSParser . h " # include " CSSRule . h " # include " CSSRuleList . h " # include " CSSStyleSheet . h " # include " ExceptionCode . h " # include " StyleRule . h " # include < wtf / text / StringBuilder . h > # if ENABLE ( CSS3_CONDITIONAL_RULES ) namespace WebCore { CSSSupportsRule :: CSSSupportsRule ( StyleRuleSupports * supportsRule , CSSStyleSheet * parent ) : CSSGroupingRule ( supportsRule , parent ) { } String CSSSupportsRule :: cssText ( ) const { StringBuilder result ; result . append ( " @ supports ▁ " ) ; result . append ( conditionText ( ) ) ; result . append ( " ▁ { \n " ) ; appendCssTextForItems ( result ) ; result . append ( ' } ' ) ; return result . toString ( ) ; } String CSSSupportsRule :: conditionText ( ) const { return toStyleRuleSupports ( m_groupRule . get ( ) ) -> conditionText ( ) ; } } # endif </DOCUMENT>
<DOCUMENT_ID="poixen/Cockatrice/tree/master/cockatrice/src/dlg_edit_user.cpp"> # include < QSettings > # include < QLabel > # include < QGridLayout > # include < QHBoxLayout > # include < QDialogButtonBox > # include < QDebug > # include " dlg _ edit _ user . h " # include " settingscache . h " DlgEditUser :: DlgEditUser ( QWidget * parent , QString email , int gender , QString country , QString realName ) : QDialog ( parent ) { emailLabel = new QLabel ( tr ( " Email : " ) ) ; emailEdit = new QLineEdit ( ) ; emailLabel -> setBuddy ( emailEdit ) ; emailEdit -> setText ( email ) ; genderLabel = new QLabel ( tr ( " Pronouns : " ) ) ; genderEdit = new QComboBox ( ) ; genderLabel -> setBuddy ( genderEdit ) ; genderEdit -> insertItem ( 0 , QIcon ( " : / resources / genders / unknown . svg " ) , tr ( " Neutral " ) ) ; genderEdit -> insertItem ( 1 , QIcon ( " : / resources / genders / male . svg " ) , tr ( " Masculine " ) ) ; genderEdit -> insertItem ( 2 , QIcon ( " : / resources / genders / female . svg " ) , tr ( " Feminine " ) ) ; genderEdit -> setCurrentIndex ( gender + 1 ) ; countryLabel = new QLabel ( tr ( " Country : " ) ) ; countryEdit = new QComboBox ( ) ; countryLabel -> setBuddy ( countryEdit ) ; countryEdit -> insertItem ( 0 , tr ( " Undefined " ) ) ; countryEdit -> setCurrentIndex ( 0 ) ; QStringList countries = settingsCache -> getCountries ( ) ; int i = 1 ; foreach ( QString c , countries ) { countryEdit -> addItem ( QPixmap ( " : / resources / countries / " + c + " . svg " ) , c ) ; if ( c == country ) countryEdit -> setCurrentIndex ( i ) ; ++ i ; } realnameLabel = new QLabel ( tr ( " Real ▁ name : " ) ) ; realnameEdit = new QLineEdit ( ) ; realnameLabel -> setBuddy ( realnameEdit ) ; realnameEdit -> setText ( realName ) ; QGridLayout * grid = new QGridLayout ; grid -> addWidget ( emailLabel , 0 , 0 ) ; grid -> addWidget ( emailEdit , 0 , 1 ) ; grid -> addWidget ( genderLabel , 1 , 0 ) ; grid -> addWidget ( genderEdit , 1 , 1 ) ; grid -> addWidget ( countryLabel , 2 , 0 ) ; grid -> addWidget ( countryEdit , 2 , 1 ) ; grid -> addWidget ( realnameLabel , 3 , 0 ) ; grid -> addWidget ( realnameEdit , 3 , 1 ) ; QDialogButtonBox * buttonBox = new QDialogButtonBox ( QDialogButtonBox :: Ok | QDialogButtonBox :: Cancel ) ; connect ( buttonBox , SIGNAL ( accepted ( ) ) , this , SLOT ( actOk ( ) ) ) ; connect ( buttonBox , SIGNAL ( rejected ( ) ) , this , SLOT ( actCancel ( ) ) ) ; QVBoxLayout * mainLayout = new QVBoxLayout ; mainLayout -> addLayout ( grid ) ; mainLayout -> addWidget ( buttonBox ) ; setLayout ( mainLayout ) ; setWindowTitle ( tr ( " Edit ▁ user ▁ profile " ) ) ; setFixedHeight ( sizeHint ( ) . height ( ) ) ; setMinimumWidth ( 300 ) ; } void DlgEditUser :: actOk ( ) { accept ( ) ; } void DlgEditUser :: actCancel ( ) { reject ( ) ; } </DOCUMENT>
<DOCUMENT_ID="imAArtist/simIr/tree/master/Data/singleFile/code_721.cpp"> int candy ( vector < int > & ratings ) { int size = ratings . size ( ) ; if ( size <= 1 ) return size ; vector < int > num ( size , 1 ) ; for ( int i = 1 ; i < size ; i ++ ) { if ( ratings [ i ] > ratings [ i - 1 ] ) num [ i ] = num [ i - 1 ] + 1 ; } for ( int i = size - 1 ; i > 0 ; i -- ) { if ( ratings [ i - 1 ] > ratings [ i ] ) num [ i - 1 ] = max ( num [ i ] + 1 , num [ i - 1 ] ) ; } int result = 0 ; for ( int i = 0 ; i < size ; i ++ ) { result += num [ i ] ; } return result ; } 1 , 3 , 3 , 3 , 21 , 2 , 1 , 2 , 1public int candy ( int [ ] ratings ) { int len = ratings . length ; int [ ] candy = new int [ len ] ; candy [ 0 ] = 1 ; for ( int i = 1 ; i < len ; ++ i ) { if ( ratings [ i ] > ratings [ i - 1 ] ) { candy [ i ] = candy [ i - 1 ] + 1 ; } else { candy [ i ] = 1 ; } } int total = candy [ len - 1 ] ; for ( int i = len - 2 ; i >= 0 ; -- i ) { if ( ratings [ i ] > ratings [ i + 1 ] && candy [ i ] <= candy [ i + 1 ] ) { candy [ i ] = candy [ i + 1 ] + 1 ; } total += candy [ i ] ; } return total ; } </DOCUMENT>
<DOCUMENT_ID="tjaffri/msiot-samples/tree/master/AllJoyn/Samples/ZWaveAdapter/open-zwave/cpp/src/command_classes/UserCode.cpp"> # include " tinyxml . h " # include " command _ classes / CommandClasses . h " # include " command _ classes / UserCode . h " # include " Node . h " # include " Options . h " # include " platform / Log . h " # include " value _ classes / ValueByte . h " # include " value _ classes / ValueRaw . h " using namespace OpenZWave ; enum UserCodeCmd { UserCodeCmd_Set = 0x01 , UserCodeCmd_Get = 0x02 , UserCodeCmd_Report = 0x03 , UserNumberCmd_Get = 0x04 , UserNumberCmd_Report = 0x05 } ; enum { UserCodeIndex_Refresh = 254 , UserCodeIndex_Count = 255 } ; const uint8 UserCodeLength = 10 ; UserCode :: UserCode ( uint32 const _homeId , uint8 const _nodeId ) : CommandClass ( _homeId , _nodeId ) , m_queryAll ( false ) , m_currentCode ( 0 ) , m_userCodeCount ( 0 ) , m_refreshUserCodes ( false ) { SetStaticRequest ( StaticRequest_Values ) ; memset ( m_userCodesStatus , 0xff , sizeof ( m_userCodesStatus ) ) ; Options :: Get ( ) -> GetOptionAsBool ( " RefreshAllUserCodes " , & m_refreshUserCodes ) ; } void UserCode :: ReadXML ( TiXmlElement const * _ccElement ) { int32 intVal ; CommandClass :: ReadXML ( _ccElement ) ; if ( TIXML_SUCCESS == _ccElement -> QueryIntAttribute ( " codes " , & intVal ) ) { m_userCodeCount = intVal ; } } void UserCode :: WriteXML ( TiXmlElement * _ccElement ) { char str [ 32 ] ; CommandClass :: WriteXML ( _ccElement ) ; snprintf ( str , sizeof ( str ) , " % d " , m_userCodeCount ) ; _ccElement -> SetAttribute ( " codes " , str ) ; } bool UserCode :: RequestState ( uint32 const _requestFlags , uint8 const _instance , Driver :: MsgQueue const _queue ) { bool requests = false ; if ( ( _requestFlags & RequestFlag_Static ) && HasStaticRequest ( StaticRequest_Values ) ) { requests |= RequestValue ( _requestFlags , UserCodeIndex_Count , _instance , _queue ) ; } if ( _requestFlags & RequestFlag_Session ) { if ( m_userCodeCount > 0 ) { m_queryAll = true ; m_currentCode = 1 ; requests |= RequestValue ( _requestFlags , m_currentCode , _instance , _queue ) ; } } return requests ; } bool UserCode :: RequestValue ( uint32 const _requestFlags , uint8 const _userCodeIdx , uint8 const _instance , Driver :: MsgQueue const _queue ) { if ( _instance != 1 ) { return false ; } if ( ! IsGetSupported ( ) ) { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " UserNumberCmd _ Get ▁ Not ▁ Supported ▁ on ▁ this ▁ node " ) ; return false ; } if ( _userCodeIdx == UserCodeIndex_Count ) { Msg * msg = new Msg ( " UserNumberCmd _ Get " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true , true , FUNC_ID_APPLICATION_COMMAND_HANDLER , GetCommandClassId ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 2 ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserNumberCmd_Get ) ; msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , _queue ) ; return true ; } if ( _userCodeIdx == 0 ) { Log :: Write ( LogLevel_Warning , GetNodeId ( ) , " UserCodeCmd _ Get ▁ with ▁ Index ▁ 0 ▁ not ▁ Supported " ) ; return false ; } Msg * msg = new Msg ( " UserCodeCmd _ Get " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true , true , FUNC_ID_APPLICATION_COMMAND_HANDLER , GetCommandClassId ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 3 ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserCodeCmd_Get ) ; msg -> Append ( _userCodeIdx ) ; msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , _queue ) ; return true ; } bool UserCode :: HandleMsg ( uint8 const * _data , uint32 const _length , uint32 const _instance ) { if ( UserNumberCmd_Report == ( UserCodeCmd ) _data [ 0 ] ) { m_userCodeCount = _data [ 1 ] ; if ( m_userCodeCount > 254 ) { m_userCodeCount = 254 ; } ClearStaticRequest ( StaticRequest_Values ) ; if ( m_userCodeCount == 0 ) { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Number ▁ report ▁ from ▁ node ▁ % d : ▁ Not ▁ supported " , GetNodeId ( ) ) ; } else { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Number ▁ report ▁ from ▁ node ▁ % d : ▁ Supported ▁ Codes ▁ % d ▁ ( % d ) " , GetNodeId ( ) , m_userCodeCount , _data [ 1 ] ) ; } if ( ValueByte * value = static_cast < ValueByte * > ( GetValue ( _instance , UserCodeIndex_Count ) ) ) { value -> OnValueRefreshed ( m_userCodeCount ) ; value -> Release ( ) ; } if ( Node * node = GetNodeUnsafe ( ) ) { uint8 data [ UserCodeLength ] ; memset ( data , 0 , UserCodeLength ) ; for ( uint8 i = 0 ; i <= m_userCodeCount ; i ++ ) { char str [ 16 ] ; if ( i == 0 ) { snprintf ( str , sizeof ( str ) , " Enrollment ▁ Code " ) ; node -> CreateValueRaw ( ValueID :: ValueGenre_User , GetCommandClassId ( ) , _instance , i , str , " " , true , false , data , UserCodeLength , 0 ) ; } else { snprintf ( str , sizeof ( str ) , " Code ▁ % d : " , i ) ; node -> CreateValueRaw ( ValueID :: ValueGenre_User , GetCommandClassId ( ) , _instance , i , str , " " , false , false , data , UserCodeLength , 0 ) ; } } } return true ; } else if ( UserCodeCmd_Report == ( UserCodeCmd ) _data [ 0 ] ) { int i = _data [ 1 ] ; if ( ValueRaw * value = static_cast < ValueRaw * > ( GetValue ( _instance , i ) ) ) { uint8 data [ UserCodeLength ] ; uint8 size = _length - 4 ; if ( size > UserCodeLength ) { Log :: Write ( LogLevel_Warning , GetNodeId ( ) , " User ▁ Code ▁ length ▁ % d ▁ is ▁ larger ▁ then ▁ maximum ▁ % d " , size , UserCodeLength ) ; size = UserCodeLength ; } m_userCodesStatus [ i ] = _data [ 2 ] ; memcpy ( data , & _data [ 3 ] , size ) ; value -> OnValueRefreshed ( data , size ) ; value -> Release ( ) ; } Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Code ▁ Report ▁ from ▁ node ▁ % d ▁ for ▁ User ▁ Code ▁ % d ▁ ( % s ) " , GetNodeId ( ) , i , CodeStatus ( _data [ 2 ] ) . c_str ( ) ) ; if ( m_queryAll && i == m_currentCode ) { if ( m_refreshUserCodes || ( _data [ 2 ] != UserCode_Available ) ) { if ( ++ i <= m_userCodeCount ) { m_currentCode = i ; RequestValue ( 0 , m_currentCode , _instance , Driver :: MsgQueue_Query ) ; } else { m_queryAll = false ; Options :: Get ( ) -> GetOptionAsBool ( " RefreshAllUserCodes " , & m_refreshUserCodes ) ; } } else { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Not ▁ Requesting ▁ additional ▁ UserCode ▁ Slots ▁ as ▁ RefreshAllUserCodes ▁ is ▁ false , ▁ and ▁ slot ▁ % d ▁ is ▁ available " , i ) ; m_queryAll = false ; } } return true ; } return false ; } bool UserCode :: SetValue ( Value const & _value ) { if ( ( ValueID :: ValueType_Raw == _value . GetID ( ) . GetType ( ) ) && ( _value . GetID ( ) . GetIndex ( ) < UserCodeIndex_Refresh ) ) { ValueRaw const * value = static_cast < ValueRaw const * > ( & _value ) ; uint8 * s = value -> GetValue ( ) ; uint8 len = value -> GetLength ( ) ; if ( len > UserCodeLength ) { return false ; } m_userCodesStatus [ value -> GetID ( ) . GetIndex ( ) ] = UserCode_Occupied ; Msg * msg = new Msg ( " UserCodeCmd _ Set " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true ) ; msg -> SetInstance ( this , _value . GetID ( ) . GetInstance ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 4 + len ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserCodeCmd_Set ) ; msg -> Append ( value -> GetID ( ) . GetIndex ( ) ) ; msg -> Append ( UserCode_Occupied ) ; for ( uint8 i = 0 ; i < len ; i ++ ) { msg -> Append ( s [ i ] ) ; } msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , Driver :: MsgQueue_Send ) ; return true ; } if ( ( ValueID :: ValueType_Button == _value . GetID ( ) . GetType ( ) ) && ( _value . GetID ( ) . GetIndex ( ) == UserCodeIndex_Refresh ) ) { m_refreshUserCodes = true ; m_currentCode = 1 ; m_queryAll = true ; RequestValue ( 0 , m_currentCode , _value . GetID ( ) . GetInstance ( ) , Driver :: MsgQueue_Query ) ; return true ; } return false ; } void UserCode :: CreateVars ( uint8 const _instance ) { if ( Node * node = GetNodeUnsafe ( ) ) { node -> CreateValueByte ( ValueID :: ValueGenre_System , GetCommandClassId ( ) , _instance , UserCodeIndex_Count , " Code ▁ Count " , " " , true , false , 0 , 0 ) ; node -> CreateValueButton ( ValueID :: ValueGenre_System , GetCommandClassId ( ) , _instance , UserCodeIndex_Refresh , " Refresh ▁ All ▁ UserCodes " , 0 ) ; } } </DOCUMENT>
<DOCUMENT_ID="dgrat/ANNetGPGPU/tree/master/examples/designer/ANNetDesigner.cpp"> # include < QApplication > # include " gui / QMainWindow . h " int main ( int argc , char * argv [ ] ) { QApplication a ( argc , argv ) ; MainWindow w ; w . show ( ) ; return a . exec ( ) ; } </DOCUMENT>
<DOCUMENT_ID="hyuk-kim-tmax/OFASM-test/tree/master/Mtest/UNKNOWN/MVI01/main.cpp"> # include < stdlib . h > # include < string . h > extern int MVI01 ( char * p_0 , char * p_1 , char * p_2 ) ; int main ( ) { char * p_0 = ( char * ) malloc ( sizeof ( char ) * 7 ) ; char * p_1_0 = ( char * ) malloc ( sizeof ( char ) * 7 ) ; char * p_1 = ( char * ) & p_1_0 ; char * p_2 = ( char * ) malloc ( sizeof ( char ) * 3 ) ; strcpy ( p_0 , " HELLO ▁ " ) ; strcpy ( p_1_0 , " WORLD ▁ " ) ; strcpy ( p_2 , " ! ! " ) ; MVI01 ( p_0 , p_1 , p_2 ) ; MVI01 ( p_0 , p_1 , p_2 ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="kyoungchinseo/aws-sdk-cpp/tree/master/aws-cpp-sdk-s3/source/model/Delete.cpp"> # include < aws / s3 / model / Delete . h > # include < aws / core / utils / xml / XmlSerializer . h > # include < aws / core / utils / StringUtils . h > # include < aws / core / utils / memory / stl / AWSStringStream . h > # include < utility > using namespace Aws :: S3 :: Model ; using namespace Aws :: Utils :: Xml ; using namespace Aws :: Utils ; Delete :: Delete ( ) : m_objectsHasBeenSet ( false ) , m_quiet ( false ) , m_quietHasBeenSet ( false ) { } Delete :: Delete ( const XmlNode & xmlNode ) : m_objectsHasBeenSet ( false ) , m_quiet ( false ) , m_quietHasBeenSet ( false ) { * this = xmlNode ; } Delete & Delete :: operator = ( const XmlNode & xmlNode ) { XmlNode resultNode = xmlNode ; if ( ! resultNode . IsNull ( ) ) { XmlNode objectsNode = resultNode . FirstChild ( " Objects " ) ; if ( ! objectsNode . IsNull ( ) ) { XmlNode objectsMember = objectsNode ; while ( ! objectsMember . IsNull ( ) ) { m_objects . push_back ( objectsMember ) ; objectsMember = objectsMember . NextNode ( " Object " ) ; } m_objectsHasBeenSet = true ; } XmlNode quietNode = resultNode . FirstChild ( " Quiet " ) ; if ( quietNode . IsNull ( ) ) { quietNode = resultNode ; } if ( ! quietNode . IsNull ( ) ) { m_quiet = StringUtils :: ConvertToBool ( StringUtils :: Trim ( quietNode . GetText ( ) . c_str ( ) ) . c_str ( ) ) ; m_quietHasBeenSet = true ; } } return * this ; } void Delete :: AddToNode ( XmlNode & parentNode ) const { Aws :: StringStream ss ; if ( m_objectsHasBeenSet ) { for ( const auto & item : m_objects ) { XmlNode objectsNode = parentNode . CreateChildElement ( " Object " ) ; item . AddToNode ( objectsNode ) ; } } if ( m_quietHasBeenSet ) { XmlNode quietNode = parentNode . CreateChildElement ( " Object " ) ; ss << m_quiet ; quietNode . SetText ( ss . str ( ) ) ; ss . str ( " " ) ; } } </DOCUMENT>
<DOCUMENT_ID="babymannen/theforgottenserver-7.4/tree/master/src/items.cpp"> # include " otpch . h " # include " items . h " # include " spells . h " # include " movement . h " # include " weapons . h " # include " pugicast . h " uint32_t Items :: dwMajorVersion = 0 ; uint32_t Items :: dwMinorVersion = 0 ; uint32_t Items :: dwBuildNumber = 0 ; extern MoveEvents * g_moveEvents ; extern Weapons * g_weapons ; ItemType :: ItemType ( ) : group ( ITEM_GROUP_NONE ) , type ( ITEM_TYPE_NONE ) , id ( 0 ) , clientId ( 0 ) , stackable ( false ) , isAnimation ( false ) , weight ( 0 ) , levelDoor ( 0 ) , decayTime ( 0 ) , wieldInfo ( 0 ) , minReqLevel ( 0 ) , minReqMagicLevel ( 0 ) , charges ( 0 ) , maxHitChance ( - 1 ) , decayTo ( - 1 ) , attack ( 0 ) , defense ( 0 ) , extraDefense ( 0 ) , armor ( 0 ) , rotateTo ( 0 ) , runeMagLevel ( 0 ) , runeLevel ( 0 ) , combatType ( COMBAT_NONE ) , transformToOnUse ( 0 ) , transformToFree ( 0 ) , destroyTo ( 0 ) , maxTextLen ( 0 ) , writeOnceItemId ( 0 ) , transformEquipTo ( 0 ) , transformDeEquipTo ( 0 ) , maxItems ( 8 ) , slotPosition ( SLOTP_HAND ) , speed ( 0 ) , wareId ( 0 ) , magicEffect ( CONST_ME_NONE ) , bedPartnerDir ( DIRECTION_NONE ) , weaponType ( WEAPON_NONE ) , ammoType ( AMMO_NONE ) , shootType ( CONST_ANI_NONE ) , corpseType ( RACE_NONE ) , fluidSource ( FLUID_NONE ) , floorChange ( 0 ) , alwaysOnTopOrder ( 0 ) , lightLevel ( 0 ) , lightColor ( 0 ) , shootRange ( 1 ) , hitChance ( 0 ) , forceUse ( false ) , hasHeight ( false ) , walkStack ( true ) , blockSolid ( false ) , blockPickupable ( false ) , blockProjectile ( false ) , blockPathFind ( false ) , allowPickupable ( false ) , showDuration ( false ) , showCharges ( false ) , showAttributes ( false ) , replaceable ( true ) , pickupable ( false ) , rotatable ( false ) , useable ( false ) , moveable ( false ) , alwaysOnTop ( false ) , canReadText ( false ) , canWriteText ( false ) , isVertical ( false ) , isHorizontal ( false ) , isHangable ( false ) , allowDistRead ( false ) , lookThrough ( false ) , stopTime ( false ) , showCount ( true ) { } Items :: Items ( ) { items . reserve ( 20000 ) ; } Items :: ~ Items ( ) { clear ( ) ; } void Items :: clear ( ) { items . clear ( ) ; } bool Items :: reload ( ) { clear ( ) ; loadFromOtb ( " data / items / items . otb " ) ; if ( ! loadFromXml ( ) ) { return false ; } g_moveEvents -> reload ( ) ; g_weapons -> reload ( ) ; g_weapons -> loadDefaults ( ) ; return true ; } FILELOADER_ERRORS Items :: loadFromOtb ( const std :: string & file ) { FileLoader f ; if ( ! f . openFile ( file . c_str ( ) , " OTBI " ) ) { return f . getError ( ) ; } uint32_t type ; NODE node = f . getChildNode ( NO_NODE , type ) ; PropStream props ; if ( f . getProps ( node , props ) ) { uint32_t flags ; if ( ! props . read < uint32_t > ( flags ) ) { return ERROR_INVALID_FORMAT ; } uint8_t attr ; if ( ! props . read < uint8_t > ( attr ) ) { return ERROR_INVALID_FORMAT ; } if ( attr == ROOT_ATTR_VERSION ) { uint16_t datalen ; if ( ! props . read < uint16_t > ( datalen ) ) { return ERROR_INVALID_FORMAT ; } if ( datalen != sizeof ( VERSIONINFO ) ) { return ERROR_INVALID_FORMAT ; } VERSIONINFO vi ; if ( ! props . read ( vi ) ) { return ERROR_INVALID_FORMAT ; } Items :: dwMajorVersion = vi . dwMajorVersion ; Items :: dwMinorVersion = vi . dwMinorVersion ; Items :: dwBuildNumber = vi . dwBuildNumber ; } } if ( Items :: dwMajorVersion == 0xFFFFFFFF ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromOtb ] ▁ items . otb ▁ using ▁ generic ▁ client ▁ version . " << std :: endl ; } else if ( Items :: dwMajorVersion > 2 ) { std :: cout << " New ▁ version ▁ detected , ▁ an ▁ older ▁ version ▁ of ▁ items . otb ▁ is ▁ required . " << std :: endl ; return ERROR_INVALID_FORMAT ; } else if ( Items :: dwMinorVersion < CLIENT_VERSION_740 ) { std :: cout << " A ▁ newer ▁ version ▁ of ▁ items . otb ▁ is ▁ required . " << std :: endl ; return ERROR_INVALID_FORMAT ; } node = f . getChildNode ( node , type ) ; while ( node != NO_NODE ) { PropStream stream ; if ( ! f . getProps ( node , stream ) ) { return f . getError ( ) ; } uint32_t flags ; if ( ! stream . read < uint32_t > ( flags ) ) { return ERROR_INVALID_FORMAT ; } uint16_t serverId = 0 ; uint16_t clientId = 0 ; uint16_t speed = 0 ; uint16_t wareId = 0 ; uint8_t lightLevel = 0 ; uint8_t lightColor = 0 ; uint8_t alwaysOnTopOrder = 0 ; uint8_t attrib ; while ( stream . read < uint8_t > ( attrib ) ) { uint16_t datalen ; if ( ! stream . read < uint16_t > ( datalen ) ) { return ERROR_INVALID_FORMAT ; } switch ( attrib ) { case ITEM_ATTR_SERVERID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( serverId ) ) { return ERROR_INVALID_FORMAT ; } if ( serverId > 20000 && serverId < 20100 ) { serverId -= 20000 ; } break ; } case ITEM_ATTR_CLIENTID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( clientId ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_SPEED : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( speed ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_LIGHT2 : { if ( datalen != sizeof ( lightBlock2 ) ) { return ERROR_INVALID_FORMAT ; } lightBlock2 lb2 ; if ( ! stream . read ( lb2 ) ) { return ERROR_INVALID_FORMAT ; } lightLevel = static_cast < uint8_t > ( lb2 . lightLevel ) ; lightColor = static_cast < uint8_t > ( lb2 . lightColor ) ; break ; } case ITEM_ATTR_TOPORDER : { if ( datalen != sizeof ( uint8_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint8_t > ( alwaysOnTopOrder ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_WAREID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( wareId ) ) { return ERROR_INVALID_FORMAT ; } break ; } default : { if ( ! stream . skip ( datalen ) ) { return ERROR_INVALID_FORMAT ; } break ; } } } reverseItemMap . emplace ( clientId , serverId ) ; if ( serverId >= items . size ( ) ) { items . resize ( serverId + 1 ) ; } ItemType & iType = items [ serverId ] ; iType . group = static_cast < itemgroup_t > ( type ) ; switch ( type ) { case ITEM_GROUP_CONTAINER : iType . type = ITEM_TYPE_CONTAINER ; break ; case ITEM_GROUP_DOOR : iType . type = ITEM_TYPE_DOOR ; break ; case ITEM_GROUP_MAGICFIELD : iType . type = ITEM_TYPE_MAGICFIELD ; break ; case ITEM_GROUP_TELEPORT : iType . type = ITEM_TYPE_TELEPORT ; break ; case ITEM_GROUP_NONE : case ITEM_GROUP_GROUND : case ITEM_GROUP_SPLASH : case ITEM_GROUP_FLUID : case ITEM_GROUP_CHARGES : case ITEM_GROUP_DEPRECATED : break ; default : return ERROR_INVALID_FORMAT ; } iType . blockSolid = hasBitSet ( FLAG_BLOCK_SOLID , flags ) ; iType . blockProjectile = hasBitSet ( FLAG_BLOCK_PROJECTILE , flags ) ; iType . blockPathFind = hasBitSet ( FLAG_BLOCK_PATHFIND , flags ) ; iType . hasHeight = hasBitSet ( FLAG_HAS_HEIGHT , flags ) ; iType . useable = hasBitSet ( FLAG_USEABLE , flags ) ; iType . pickupable = hasBitSet ( FLAG_PICKUPABLE , flags ) ; iType . moveable = hasBitSet ( FLAG_MOVEABLE , flags ) ; iType . stackable = hasBitSet ( FLAG_STACKABLE , flags ) ; iType . alwaysOnTop = hasBitSet ( FLAG_ALWAYSONTOP , flags ) ; iType . isVertical = hasBitSet ( FLAG_VERTICAL , flags ) ; iType . isHorizontal = hasBitSet ( FLAG_HORIZONTAL , flags ) ; iType . isHangable = hasBitSet ( FLAG_HANGABLE , flags ) ; iType . allowDistRead = hasBitSet ( FLAG_ALLOWDISTREAD , flags ) ; iType . rotatable = hasBitSet ( FLAG_ROTATABLE , flags ) ; iType . canReadText = hasBitSet ( FLAG_READABLE , flags ) ; iType . lookThrough = hasBitSet ( FLAG_LOOKTHROUGH , flags ) ; iType . forceUse = hasBitSet ( FLAG_FORCEUSE , flags ) ; iType . id = serverId ; iType . clientId = clientId ; iType . speed = speed ; iType . lightLevel = lightLevel ; iType . lightColor = lightColor ; iType . wareId = wareId ; iType . alwaysOnTopOrder = alwaysOnTopOrder ; node = f . getNextNode ( node , type ) ; } items . shrink_to_fit ( ) ; return ERROR_NONE ; } bool Items :: loadFromXml ( ) { pugi :: xml_document doc ; pugi :: xml_parse_result result = doc . load_file ( " data / items / items . xml " ) ; if ( ! result ) { printXMLError ( " Error ▁ - ▁ Items : : loadFromXml " , " data / items / items . xml " , result ) ; return false ; } for ( auto itemNode : doc . child ( " items " ) . children ( ) ) { pugi :: xml_attribute idAttribute = itemNode . attribute ( " id " ) ; if ( idAttribute ) { parseItemNode ( itemNode , pugi :: cast < uint16_t > ( idAttribute . value ( ) ) ) ; continue ; } pugi :: xml_attribute fromIdAttribute = itemNode . attribute ( " fromid " ) ; if ( ! fromIdAttribute ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromXml ] ▁ No ▁ item ▁ id ▁ found " << std :: endl ; continue ; } pugi :: xml_attribute toIdAttribute = itemNode . attribute ( " toid " ) ; if ( ! toIdAttribute ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromXml ] ▁ fromid ▁ ( " << fromIdAttribute . value ( ) << " ) ▁ without ▁ toid " << std :: endl ; continue ; } uint16_t id = pugi :: cast < uint16_t > ( fromIdAttribute . value ( ) ) ; uint16_t toId = pugi :: cast < uint16_t > ( toIdAttribute . value ( ) ) ; while ( id <= toId ) { parseItemNode ( itemNode , id ++ ) ; } } return true ; } void Items :: parseItemNode ( const pugi :: xml_node & itemNode , uint16_t id ) { if ( id > 20000 && id < 20100 ) { id -= 20000 ; if ( id >= items . size ( ) ) { items . resize ( id + 1 ) ; } ItemType & iType = items [ id ] ; iType . id = id ; } ItemType & it = getItemType ( id ) ; if ( it . id == 0 ) { return ; } it . name = itemNode . attribute ( " name " ) . as_string ( ) ; pugi :: xml_attribute articleAttribute = itemNode . attribute ( " article " ) ; if ( articleAttribute ) { it . article = articleAttribute . as_string ( ) ; } pugi :: xml_attribute pluralAttribute = itemNode . attribute ( " plural " ) ; if ( pluralAttribute ) { it . pluralName = pluralAttribute . as_string ( ) ; } for ( auto attributeNode : itemNode . children ( ) ) { pugi :: xml_attribute keyAttribute = attributeNode . attribute ( " key " ) ; if ( ! keyAttribute ) { continue ; } pugi :: xml_attribute valueAttribute = attributeNode . attribute ( " value " ) ; if ( ! valueAttribute ) { continue ; } std :: string tmpStrValue = asLowerCaseString ( keyAttribute . as_string ( ) ) ; if ( tmpStrValue == " type " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " key " ) { it . type = ITEM_TYPE_KEY ; } else if ( tmpStrValue == " magicfield " ) { it . type = ITEM_TYPE_MAGICFIELD ; } else if ( tmpStrValue == " container " ) { it . group = ITEM_GROUP_CONTAINER ; it . type = ITEM_TYPE_CONTAINER ; } else if ( tmpStrValue == " depot " ) { it . type = ITEM_TYPE_DEPOT ; } else if ( tmpStrValue == " mailbox " ) { it . type = ITEM_TYPE_MAILBOX ; } else if ( tmpStrValue == " trashholder " ) { it . type = ITEM_TYPE_TRASHHOLDER ; } else if ( tmpStrValue == " teleport " ) { it . type = ITEM_TYPE_TELEPORT ; } else if ( tmpStrValue == " door " ) { it . type = ITEM_TYPE_DOOR ; } else if ( tmpStrValue == " bed " ) { it . type = ITEM_TYPE_BED ; } else if ( tmpStrValue == " rune " ) { it . type = ITEM_TYPE_RUNE ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ type : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " description " ) { it . description = valueAttribute . as_string ( ) ; } else if ( tmpStrValue == " runespellname " ) { it . runeSpellName = valueAttribute . as_string ( ) ; } else if ( tmpStrValue == " weight " ) { it . weight = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showcount " ) { it . showCount = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " armor " ) { it . armor = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " defense " ) { it . defense = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " extradef " ) { it . extraDefense = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " attack " ) { it . attack = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " rotateto " ) { it . rotateTo = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " moveable " || tmpStrValue == " movable " ) { it . moveable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " blockprojectile " ) { it . blockProjectile = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " allowpickupable " || tmpStrValue == " pickupable " ) { it . allowPickupable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " floorchange " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " down " ) { it . floorChange = TILESTATE_FLOORCHANGE_DOWN ; } else if ( tmpStrValue == " north " ) { it . floorChange = TILESTATE_FLOORCHANGE_NORTH ; } else if ( tmpStrValue == " south " ) { it . floorChange = TILESTATE_FLOORCHANGE_SOUTH ; } else if ( tmpStrValue == " southalt " ) { it . floorChange = TILESTATE_FLOORCHANGE_SOUTH_ALT ; } else if ( tmpStrValue == " west " ) { it . floorChange = TILESTATE_FLOORCHANGE_WEST ; } else if ( tmpStrValue == " east " ) { it . floorChange = TILESTATE_FLOORCHANGE_EAST ; } else if ( tmpStrValue == " eastalt " ) { it . floorChange = TILESTATE_FLOORCHANGE_EAST_ALT ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ floorChange : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " corpsetype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " venom " ) { it . corpseType = RACE_VENOM ; } else if ( tmpStrValue == " blood " ) { it . corpseType = RACE_BLOOD ; } else if ( tmpStrValue == " undead " ) { it . corpseType = RACE_UNDEAD ; } else if ( tmpStrValue == " fire " ) { it . corpseType = RACE_FIRE ; } else if ( tmpStrValue == " energy " ) { it . corpseType = RACE_ENERGY ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ corpseType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " containersize " ) { it . maxItems = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fluidsource " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " water " ) { it . fluidSource = FLUID_WATER ; } else if ( tmpStrValue == " blood " ) { it . fluidSource = FLUID_BLOOD ; } else if ( tmpStrValue == " beer " ) { it . fluidSource = FLUID_BEER ; } else if ( tmpStrValue == " slime " ) { it . fluidSource = FLUID_SLIME ; } else if ( tmpStrValue == " lemonade " ) { it . fluidSource = FLUID_LEMONADE ; } else if ( tmpStrValue == " milk " ) { it . fluidSource = FLUID_MILK ; } else if ( tmpStrValue == " mana " ) { it . fluidSource = FLUID_MANA ; } else if ( tmpStrValue == " life " ) { it . fluidSource = FLUID_LIFE ; } else if ( tmpStrValue == " oil " ) { it . fluidSource = FLUID_OIL ; } else if ( tmpStrValue == " urine " ) { it . fluidSource = FLUID_URINE ; } else if ( tmpStrValue == " coconut " ) { it . fluidSource = FLUID_COCONUTMILK ; } else if ( tmpStrValue == " wine " ) { it . fluidSource = FLUID_WINE ; } else if ( tmpStrValue == " mud " ) { it . fluidSource = FLUID_MUD ; } else if ( tmpStrValue == " fruitjuice " ) { it . fluidSource = FLUID_FRUITJUICE ; } else if ( tmpStrValue == " lava " ) { it . fluidSource = FLUID_LAVA ; } else if ( tmpStrValue == " rum " ) { it . fluidSource = FLUID_RUM ; } else if ( tmpStrValue == " swamp " ) { it . fluidSource = FLUID_SWAMP ; } else if ( tmpStrValue == " tea " ) { it . fluidSource = FLUID_TEA ; } else if ( tmpStrValue == " mead " ) { it . fluidSource = FLUID_MEAD ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ fluidSource : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " readable " ) { it . canReadText = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " writeable " ) { it . canWriteText = valueAttribute . as_bool ( ) ; it . canReadText = it . canWriteText ; } else if ( tmpStrValue == " maxtextlen " ) { it . maxTextLen = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " writeonceitemid " ) { it . writeOnceItemId = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " weapontype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " sword " ) { it . weaponType = WEAPON_SWORD ; } else if ( tmpStrValue == " club " ) { it . weaponType = WEAPON_CLUB ; } else if ( tmpStrValue == " axe " ) { it . weaponType = WEAPON_AXE ; } else if ( tmpStrValue == " shield " ) { it . weaponType = WEAPON_SHIELD ; } else if ( tmpStrValue == " distance " ) { it . weaponType = WEAPON_DISTANCE ; } else if ( tmpStrValue == " wand " ) { it . weaponType = WEAPON_WAND ; } else if ( tmpStrValue == " ammunition " ) { it . weaponType = WEAPON_AMMO ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ weaponType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " slottype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " head " ) { it . slotPosition |= SLOTP_HEAD ; } else if ( tmpStrValue == " body " ) { it . slotPosition |= SLOTP_ARMOR ; } else if ( tmpStrValue == " legs " ) { it . slotPosition |= SLOTP_LEGS ; } else if ( tmpStrValue == " feet " ) { it . slotPosition |= SLOTP_FEET ; } else if ( tmpStrValue == " backpack " ) { it . slotPosition |= SLOTP_BACKPACK ; } else if ( tmpStrValue == " two - handed " ) { it . slotPosition |= SLOTP_TWO_HAND ; } else if ( tmpStrValue == " right - hand " ) { it . slotPosition &= ~ SLOTP_LEFT ; } else if ( tmpStrValue == " left - hand " ) { it . slotPosition &= ~ SLOTP_RIGHT ; } else if ( tmpStrValue == " necklace " ) { it . slotPosition |= SLOTP_NECKLACE ; } else if ( tmpStrValue == " ring " ) { it . slotPosition |= SLOTP_RING ; } else if ( tmpStrValue == " ammo " ) { it . slotPosition |= SLOTP_AMMO ; } else if ( tmpStrValue == " hand " ) { it . slotPosition |= SLOTP_HAND ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ slotType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " ammotype " ) { it . ammoType = getAmmoType ( valueAttribute . as_string ( ) ) ; if ( it . ammoType == AMMO_NONE ) { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ ammoType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " shoottype " ) { ShootType_t shoot = getShootType ( valueAttribute . as_string ( ) ) ; if ( shoot != CONST_ANI_NONE ) { it . shootType = shoot ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ shootType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " effect " ) { MagicEffectClasses effect = getMagicEffect ( valueAttribute . as_string ( ) ) ; if ( effect != CONST_ME_NONE ) { it . magicEffect = effect ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ effect : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " range " ) { it . shootRange = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " stopduration " ) { it . stopTime = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " decayto " ) { it . decayTo = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " transformequipto " ) { it . transformEquipTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " transformdeequipto " ) { it . transformDeEquipTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " duration " ) { it . decayTime = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showduration " ) { it . showDuration = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " charges " ) { it . charges = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showcharges " ) { it . showCharges = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " showattributes " ) { it . showAttributes = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " hitchance " ) { it . hitChance = std :: min < int8_t > ( 100 , std :: max < int8_t > ( - 100 , pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ) ) ; } else if ( tmpStrValue == " maxhitchance " ) { it . maxHitChance = std :: min < uint32_t > ( 100 , pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " invisible " ) { it . getAbilities ( ) . invisible = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " speed " ) { it . getAbilities ( ) . speed = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " healthgain " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . healthGain = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " healthticks " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . healthTicks = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " managain " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . manaGain = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " manaticks " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . manaTicks = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " manashield " ) { it . getAbilities ( ) . manaShield = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " skillsword " ) { it . getAbilities ( ) . skills [ SKILL_SWORD ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillaxe " ) { it . getAbilities ( ) . skills [ SKILL_AXE ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillclub " ) { it . getAbilities ( ) . skills [ SKILL_CLUB ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skilldist " ) { it . getAbilities ( ) . skills [ SKILL_DISTANCE ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillfish " ) { it . getAbilities ( ) . skills [ SKILL_FISHING ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillshield " ) { it . getAbilities ( ) . skills [ SKILL_SHIELD ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillfist " ) { it . getAbilities ( ) . skills [ SKILL_FIST ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxhitpoints " ) { it . getAbilities ( ) . stats [ STAT_MAXHITPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxhitpointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAXHITPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxmanapoints " ) { it . getAbilities ( ) . stats [ STAT_MAXMANAPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxmanapointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAXMANAPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " magicpoints " || tmpStrValue == " magiclevelpoints " ) { it . getAbilities ( ) . stats [ STAT_MAGICPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " magicpointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAGICPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercentenergy " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercentfire " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercentpoison " || tmpStrValue == " fieldabsorpercentearth " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentall " || tmpStrValue == " absorbpercentallelements " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; for ( size_t i = 0 ; i < COMBAT_COUNT ; ++ i ) { abilities . absorbPercent [ i ] += value ; } } else if ( tmpStrValue == " absorbpercentelements " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += value ; } else if ( tmpStrValue == " absorbpercentmagic " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += value ; } else if ( tmpStrValue == " absorbpercentenergy " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentfire " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentpoison " || tmpStrValue == " absorbpercentearth " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentlifedrain " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_LIFEDRAIN ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentmanadrain " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_MANADRAIN ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentphysical " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_PHYSICALDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercenthealing " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_HEALING ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentundefined " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_UNDEFINEDDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " suppressdrunk " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_DRUNK ; } } else if ( tmpStrValue == " suppressenergy " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_ENERGY ; } } else if ( tmpStrValue == " suppressfire " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_FIRE ; } } else if ( tmpStrValue == " suppresspoison " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_POISON ; } } else if ( tmpStrValue == " suppressphysical " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_BLEEDING ; } } else if ( tmpStrValue == " field " ) { it . group = ITEM_GROUP_MAGICFIELD ; it . type = ITEM_TYPE_MAGICFIELD ; CombatType_t combatType = COMBAT_NONE ; ConditionDamage * conditionDamage = nullptr ; tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " fire " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_FIRE ) ; combatType = COMBAT_FIREDAMAGE ; } else if ( tmpStrValue == " energy " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_ENERGY ) ; combatType = COMBAT_ENERGYDAMAGE ; } else if ( tmpStrValue == " poison " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_POISON ) ; combatType = COMBAT_EARTHDAMAGE ; } else if ( tmpStrValue == " physical " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_BLEEDING ) ; combatType = COMBAT_PHYSICALDAMAGE ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ field ▁ value : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } if ( combatType != COMBAT_NONE ) { it . combatType = combatType ; it . conditionDamage . reset ( conditionDamage ) ; uint32_t ticks = 0 ; int32_t damage = 0 ; int32_t start = 0 ; int32_t count = 1 ; for ( auto subAttributeNode : attributeNode . children ( ) ) { pugi :: xml_attribute subKeyAttribute = subAttributeNode . attribute ( " key " ) ; if ( ! subKeyAttribute ) { continue ; } pugi :: xml_attribute subValueAttribute = subAttributeNode . attribute ( " value " ) ; if ( ! subValueAttribute ) { continue ; } tmpStrValue = asLowerCaseString ( subKeyAttribute . as_string ( ) ) ; if ( tmpStrValue == " ticks " ) { ticks = pugi :: cast < uint32_t > ( subValueAttribute . value ( ) ) ; } else if ( tmpStrValue == " count " ) { count = std :: max < int32_t > ( 1 , pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " start " ) { start = std :: max < int32_t > ( 0 , pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " damage " ) { damage = - pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ; if ( start > 0 ) { std :: list < int32_t > damageList ; ConditionDamage :: generateDamageList ( damage , start , damageList ) ; for ( int32_t damageValue : damageList ) { conditionDamage -> addDamage ( 1 , ticks , - damageValue ) ; } start = 0 ; } else { conditionDamage -> addDamage ( count , ticks , damage ) ; } } } conditionDamage -> setParam ( CONDITION_PARAM_FIELD , 1 ) ; if ( conditionDamage -> getTotalDamage ( ) > 0 ) { conditionDamage -> setParam ( CONDITION_PARAM_FORCEUPDATE , 1 ) ; } } } else if ( tmpStrValue == " replaceable " ) { it . replaceable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " partnerdirection " ) { it . bedPartnerDir = getDirection ( valueAttribute . as_string ( ) ) ; } else if ( tmpStrValue == " leveldoor " ) { it . levelDoor = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " sleeper " ) { uint16_t value = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; it . transformToOnUse = value ; ItemType & other = getItemType ( value ) ; if ( other . transformToFree == 0 ) { other . transformToFree = it . id ; } if ( it . transformToOnUse == 0 ) { it . transformToOnUse = value ; } } else if ( tmpStrValue == " transformto " ) { it . transformToFree = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " destroyto " ) { it . destroyTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " elementearth " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_EARTHDAMAGE ; } else if ( tmpStrValue == " elementfire " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_FIREDAMAGE ; } else if ( tmpStrValue == " elementenergy " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_ENERGYDAMAGE ; } else if ( tmpStrValue == " walkstack " ) { it . walkStack = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " blocking " ) { it . blockSolid = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " allowdistread " ) { it . allowDistRead = booleanString ( valueAttribute . as_string ( ) ) ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ key ▁ value : ▁ " << keyAttribute . as_string ( ) << std :: endl ; } } if ( ( it . transformToFree != 0 || it . transformToOnUse != 0 || it . transformToOnUse != 0 ) && it . type != ITEM_TYPE_BED ) { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Item ▁ " << it . id << " ▁ is ▁ not ▁ set ▁ as ▁ a ▁ bed - type " << std :: endl ; } } ItemType & Items :: getItemType ( size_t id ) { if ( id < items . size ( ) ) { return items [ id ] ; } return items . front ( ) ; } const ItemType & Items :: getItemType ( size_t id ) const { if ( id < items . size ( ) ) { return items [ id ] ; } return items . front ( ) ; } const ItemType & Items :: getItemIdByClientId ( uint16_t spriteId ) const { auto it = reverseItemMap . find ( spriteId ) ; if ( it != reverseItemMap . end ( ) ) { return getItemType ( it -> second ) ; } return items . front ( ) ; } uint16_t Items :: getItemIdByName ( const std :: string & name ) { if ( name . empty ( ) ) { return 0 ; } const char * itemName = name . c_str ( ) ; for ( size_t i = 100 , size = items . size ( ) ; i < size ; ++ i ) { if ( strcasecmp ( itemName , items [ i ] . name . c_str ( ) ) == 0 ) { return i ; } } return 0 ; } </DOCUMENT>
<DOCUMENT_ID="Horizon-Blue/playground/tree/master/Solutions-to-OJs/USACO/Chapter1/1.1/02_your-ride-is-here.cpp"> # include < iostream > # include < fstream > # include < string > using namespace std ; int main ( ) { ofstream fout ( " ride . out " ) ; ifstream fin ( " ride . in " ) ; string a , b ; fin >> a >> b ; int anum = 1 , bnum = 1 ; for ( char c : a ) anum *= c - ' A ' + 1 ; for ( char c : b ) bnum *= c - ' A ' + 1 ; if ( anum % 47 == bnum % 47 ) fout << " GO " << endl ; else fout << " STAY " << endl ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="Chilledheart/vbox/tree/master/src/libs/xpcom18a4/nsprpub/pr/src/cplus/rcinrval.cpp"> # include " rcinrval . h " RCInterval :: ~ RCInterval ( ) { } RCInterval :: RCInterval ( RCInterval :: RCReservedInterval special ) : RCBase ( ) { switch ( special ) { case RCInterval :: now : interval = PR_IntervalNow ( ) ; break ; case RCInterval :: no_timeout : interval = PR_INTERVAL_NO_TIMEOUT ; break ; case RCInterval :: no_wait : interval = PR_INTERVAL_NO_WAIT ; break ; default : break ; } } </DOCUMENT>
<DOCUMENT_ID="gavoski/audacity/tree/master/lib-src/taglib/tests/test_map.cpp"> # include < cppunit / extensions / HelperMacros . h > # include < tstring . h > # include < tmap . h > using namespace std ; using namespace TagLib ; class TestMap : public CppUnit :: TestFixture { CPPUNIT_TEST_SUITE ( TestMap ) ; CPPUNIT_TEST ( testInsert ) ; CPPUNIT_TEST_SUITE_END ( ) ; public : void testInsert ( ) { Map < String , int > m ; m . insert ( " foo " , 3 ) ; CPPUNIT_ASSERT_EQUAL ( 3 , m [ " foo " ] ) ; m . insert ( " foo " , 7 ) ; CPPUNIT_ASSERT_EQUAL ( 7 , m [ " foo " ] ) ; } } ; CPPUNIT_TEST_SUITE_REGISTRATION ( TestMap ) ; </DOCUMENT>
<DOCUMENT_ID="dandan94/OpenGLTest/tree/master/finalOpenGL/HelloGLFW/lib/boost_1_59_0/libs/lexical_cast/test/lexical_cast_iterator_range_test.cpp"> # include < boost / config . hpp > # if defined ( __INTEL_COMPILER ) # pragma warning ( disable : 193 383 488 981 1418 1419 ) # elif defined ( BOOST_MSVC ) # pragma warning ( disable : 4097 4100 4121 4127 4146 4244 4245 4511 4512 4701 4800 ) # endif # include < boost / lexical_cast . hpp > # include < boost / test / unit_test . hpp > # include < boost / range / iterator_range . hpp > using namespace boost ; # if defined ( BOOST_NO_STRINGSTREAM ) || defined ( BOOST_NO_STD_WSTRING ) # define BOOST_LCAST_NO_WCHAR_T # endif # if ! defined ( BOOST_NO_CXX11_CHAR16_T ) && ! defined ( BOOST_NO_CXX11_UNICODE_LITERALS ) && ! defined ( _LIBCPP_VERSION ) # define BOOST_LC_RUNU16 # endif # if ! defined ( BOOST_NO_CXX11_CHAR32_T ) && ! defined ( BOOST_NO_CXX11_UNICODE_LITERALS ) && ! defined ( _LIBCPP_VERSION ) # define BOOST_LC_RUNU32 # endif struct class_with_user_defined_sream_operators { int i ; operator int ( ) const { return i ; } } ; template < class CharT > inline std :: basic_istream < CharT > & operator >> ( std :: basic_istream < CharT > & istr , class_with_user_defined_sream_operators & rhs ) { return istr >> rhs . i ; } template < class RngT > void do_test_iterator_range_impl ( const RngT & rng ) { BOOST_CHECK_EQUAL ( lexical_cast < int > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < int > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned int > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned int > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < short > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < short > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned short > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned short > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < long int > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < long int > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned long int > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned long int > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; # ifdef BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng . begin ( ) , rng . size ( ) ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng ) , 1.0 ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng . begin ( ) , rng . size ( ) ) , 1.0 ) ; # ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng ) , 1.0L ) ; BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng . begin ( ) , rng . size ( ) ) , 1.0L ) ; # endif BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( rng ) , 1 ) ; # endif # if defined ( BOOST_HAS_LONG_LONG ) BOOST_CHECK_EQUAL ( lexical_cast < boost :: ulong_long_type > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: ulong_long_type > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: long_long_type > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: long_long_type > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; # elif defined ( BOOST_HAS_MS_INT64 ) BOOST_CHECK_EQUAL ( lexical_cast < unsigned __int64 > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned __int64 > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < __int64 > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < __int64 > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; # endif } template < class CharT > void test_it_range_using_any_chars ( CharT * one , CharT * eleven ) { typedef CharT test_char_type ; iterator_range < test_char_type * > rng1 ( one , one + 1 ) ; do_test_iterator_range_impl ( rng1 ) ; iterator_range < const test_char_type * > crng1 ( one , one + 1 ) ; do_test_iterator_range_impl ( crng1 ) ; iterator_range < test_char_type * > rng2 ( eleven , eleven + 1 ) ; do_test_iterator_range_impl ( rng2 ) ; iterator_range < const test_char_type * > crng2 ( eleven , eleven + 1 ) ; do_test_iterator_range_impl ( crng2 ) ; } template < class CharT > void test_it_range_using_char ( CharT * one , CharT * eleven ) { typedef CharT test_char_type ; iterator_range < test_char_type * > rng1 ( one , one + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( rng1 ) , "1" ) ; iterator_range < const test_char_type * > crng1 ( one , one + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( crng1 ) , "1" ) ; iterator_range < test_char_type * > rng2 ( eleven , eleven + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( rng2 ) , "1" ) ; iterator_range < const test_char_type * > crng2 ( eleven , eleven + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( crng2 ) , "1" ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng1 ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng1 ) , 1.0 ) ; # ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng1 ) , 1.0L ) ; # endif BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( rng1 ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( crng2 ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( crng2 ) , 1.0 ) ; # ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS BOOST_CHECK_EQUAL ( lexical_cast < long double > ( crng2 ) , 1.0L ) ; # endif BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( crng2 ) , 1 ) ; # ifndef BOOST_LCAST_NO_WCHAR_T BOOST_CHECK ( lexical_cast < std :: wstring > ( rng1 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( crng1 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( rng2 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( crng2 ) == L " 1" ) ; # endif # if defined ( BOOST_LC_RUNU16 ) && defined ( BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES ) typedef std :: basic_string < char16_t > my_char16_string ; BOOST_CHECK ( lexical_cast < my_char16_string > ( rng1 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( crng1 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( rng2 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( crng2 ) == u " 1" ) ; # endif # if defined ( BOOST_LC_RUNU32 ) && defined ( BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES ) typedef std :: basic_string < char32_t > my_char32_string ; BOOST_CHECK ( lexical_cast < my_char32_string > ( rng1 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( crng1 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( rng2 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( crng2 ) == U " 1" ) ; # endif } void test_char_iterator_ranges ( ) { typedef char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; } void test_unsigned_char_iterator_ranges ( ) { typedef unsigned char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; } void test_signed_char_iterator_ranges ( ) { typedef signed char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; } void test_wchar_iterator_ranges ( ) { # ifndef BOOST_LCAST_NO_WCHAR_T typedef wchar_t test_char_type ; test_char_type data1 [ ] = L " 1" ; test_char_type data2 [ ] = L " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; # endif BOOST_CHECK ( true ) ; } void test_char16_iterator_ranges ( ) { # if defined ( BOOST_LC_RUNU16 ) typedef char16_t test_char_type ; test_char_type data1 [ ] = u " 1" ; test_char_type data2 [ ] = u " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; # endif BOOST_CHECK ( true ) ; } void test_char32_iterator_ranges ( ) { # if defined ( BOOST_LC_RUNU32 ) typedef char32_t test_char_type ; test_char_type data1 [ ] = U " 1" ; test_char_type data2 [ ] = U " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; # endif BOOST_CHECK ( true ) ; } unit_test :: test_suite * init_unit_test_suite ( int , char * [ ] ) { unit_test :: test_suite * suite = BOOST_TEST_SUITE ( " lexical _ cast . ▁ Testing ▁ conversions ▁ using ▁ iterator _ range < > " ) ; suite -> add ( BOOST_TEST_CASE ( & test_char_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_unsigned_char_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_signed_char_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_wchar_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_char16_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_char32_iterator_ranges ) ) ; return suite ; } </DOCUMENT>
<DOCUMENT_ID="NickelMedia/phantomjs/tree/master/src/qt/qtbase/config.tests/unix/evdev/evdev.cpp"> # include < linux / input . h > # include < linux / kd . h > enum { e1 = ABS_PRESSURE , e2 = ABS_X , e3 = REL_X , e4 = SYN_REPORT , } ; int main ( ) { :: input_event buf [ 32 ] ; ( void ) buf ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="zaclimon/android_kernel_samsung_kylepro/tree/master/tools/gator/daemon/LocalCapture.cpp"> # include < sys / stat . h > # include < sys / types . h > # include < dirent . h > # include < string . h > # include < stdlib . h > # include < unistd . h > # include " LocalCapture . h " # include " SessionData . h " # include " Logging . h " # include " OlyUtility . h " # include " EventsXML . h " LocalCapture :: LocalCapture ( ) { } LocalCapture :: ~ LocalCapture ( ) { } void LocalCapture :: createAPCDirectory ( char * target_path ) { gSessionData -> mAPCDir = createUniqueDirectory ( target_path , " . apc " ) ; if ( ( removeDirAndAllContents ( gSessionData -> mAPCDir ) != 0 || mkdir ( gSessionData -> mAPCDir , S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH ) != 0 ) ) { logg -> logError ( __FILE__ , __LINE__ , " Unable ▁ to ▁ create ▁ directory ▁ % s " , gSessionData -> mAPCDir ) ; handleException ( ) ; } } void LocalCapture :: write ( char * string ) { char file [ PATH_MAX ] ; snprintf ( file , PATH_MAX , " % s / session . xml " , gSessionData -> mAPCDir ) ; if ( util -> writeToDisk ( file , string ) < 0 ) { logg -> logError ( __FILE__ , __LINE__ , " Error ▁ writing ▁ % s \n Please ▁ verify ▁ the ▁ path . " , file ) ; handleException ( ) ; } EventsXML eventsXML ; eventsXML . write ( gSessionData -> mAPCDir ) ; } char * LocalCapture :: createUniqueDirectory ( const char * initialPath , const char * ending ) { char * output ; char path [ PATH_MAX ] ; if ( initialPath == 0 || strlen ( initialPath ) == 0 ) { logg -> logError ( __FILE__ , __LINE__ , " Missing ▁ - o ▁ command ▁ line ▁ option ▁ required ▁ for ▁ a ▁ local ▁ capture . " ) ; handleException ( ) ; } else if ( initialPath [ 0 ] != ' / ' ) { if ( getcwd ( path , PATH_MAX ) == 0 ) { logg -> logMessage ( " Unable ▁ to ▁ retrieve ▁ the ▁ current ▁ working ▁ directory " ) ; } strncat ( path , " / " , PATH_MAX - strlen ( path ) - 1 ) ; strncat ( path , initialPath , PATH_MAX - strlen ( path ) - 1 ) ; } else { strncpy ( path , initialPath , PATH_MAX ) ; path [ PATH_MAX - 1 ] = 0 ; } if ( strcmp ( & path [ strlen ( path ) - strlen ( ending ) ] , ending ) != 0 ) { strncat ( path , ending , PATH_MAX - strlen ( path ) - 1 ) ; } output = strdup ( path ) ; return output ; } int LocalCapture :: removeDirAndAllContents ( char * path ) { int error = 0 ; struct stat mFileInfo ; if ( stat ( path , & mFileInfo ) == 0 ) { if ( mFileInfo . st_mode & S_IFDIR ) { DIR * dir = opendir ( path ) ; dirent * entry = readdir ( dir ) ; while ( entry ) { if ( strcmp ( entry -> d_name , " . " ) != 0 && strcmp ( entry -> d_name , " . . " ) != 0 ) { char * newpath = ( char * ) malloc ( strlen ( path ) + strlen ( entry -> d_name ) + 2 ) ; sprintf ( newpath , " % s / % s " , path , entry -> d_name ) ; error = removeDirAndAllContents ( newpath ) ; free ( newpath ) ; if ( error ) { break ; } } entry = readdir ( dir ) ; } closedir ( dir ) ; if ( error == 0 ) { error = rmdir ( path ) ; } } else { error = remove ( path ) ; } } return error ; } void LocalCapture :: copyImages ( ImageLinkList * ptr ) { char dstfilename [ PATH_MAX ] ; while ( ptr ) { strncpy ( dstfilename , gSessionData -> mAPCDir , PATH_MAX ) ; dstfilename [ PATH_MAX - 1 ] = 0 ; if ( gSessionData -> mAPCDir [ strlen ( gSessionData -> mAPCDir ) - 1 ] != ' / ' ) { strncat ( dstfilename , " / " , PATH_MAX - strlen ( dstfilename ) - 1 ) ; } strncat ( dstfilename , util -> getFilePart ( ptr -> path ) , PATH_MAX - strlen ( dstfilename ) - 1 ) ; if ( util -> copyFile ( ptr -> path , dstfilename ) ) { logg -> logMessage ( " copied ▁ file ▁ % s ▁ to ▁ % s " , ptr -> path , dstfilename ) ; } else { logg -> logMessage ( " copy ▁ of ▁ file ▁ % s ▁ to ▁ % s ▁ failed " , ptr -> path , dstfilename ) ; } ptr = ptr -> next ; } } </DOCUMENT>
<DOCUMENT_ID="jamesfowkes/DataLogger/tree/master/libraries/DLDataField/DLDataField.Manager.cpp"> # ifdef ARDUINO # include < Arduino . h > # else # include < stdint . h > # include < stdio . h > # include < string . h > # endif # ifdef TEST # include < iostream > # endif # include " DLUtility . Averager . h " # include " DLDataField . Types . h " # include " DLDataField . h " # include " DLDataField . Manager . h " # include " DLSettings . Reader . Errors . h " # include " DLSettings . DataChannels . h " # include " DLUtility . h " # include " DLUtility . ArrayFunctions . h " # include " DLPlatform . h " DataFieldManager :: DataFieldManager ( uint32_t dataSize , uint32_t averagerSize ) { m_dataSize = dataSize ; m_averagerSize = averagerSize ; m_fieldCount = 0 ; m_dataCount = 0 ; uint8_t i = 0 ; for ( i = 0 ; i < MAX_FIELDS ; i ++ ) { m_fields [ i ] = NULL ; } } uint8_t DataFieldManager :: fieldCount ( ) { return m_fieldCount ; } bool DataFieldManager :: addField ( NumericDataField * field ) { if ( ! field ) { return false ; } if ( m_fieldCount == MAX_FIELDS ) { return false ; } PLATFORM_specialFieldSetup ( field ) ; field -> setDataSizes ( m_dataSize , m_averagerSize ) ; m_fields [ m_fieldCount ] = field ; m_channelNumbers [ m_fieldCount ] = field -> getChannelNumber ( ) ; m_fieldCount ++ ; return true ; } bool DataFieldManager :: addField ( StringDataField * field ) { if ( ! field ) { return false ; } if ( m_fieldCount == MAX_FIELDS ) { return false ; } m_fields [ m_fieldCount ] = field ; m_channelNumbers [ m_fieldCount ] = field -> getChannelNumber ( ) ; m_fieldCount ++ ; return true ; } void DataFieldManager :: storeDataArray ( int32_t * data ) { uint16_t field = 0 ; uint16_t dataIndex ; bool newAverageStored = false ; for ( field = 0 ; field < m_fieldCount ; field ++ ) { NumericDataField * pField = ( NumericDataField * ) m_fields [ field ] ; if ( pField ) { dataIndex = m_channelNumbers [ field ] - 1 ; newAverageStored |= pField -> storeData ( data [ dataIndex ] ) ; } } if ( newAverageStored ) { m_dataCount ++ ; } } void DataFieldManager :: getDataArray ( float * buffer , bool converted , bool alsoRemove ) { uint16_t field ; for ( field = 0 ; field < m_fieldCount ; ++ field ) { if ( converted ) { buffer [ field ] = ( ( NumericDataField * ) m_fields [ field ] ) -> getConvData ( alsoRemove ) ; } else { buffer [ field ] = ( ( NumericDataField * ) m_fields [ field ] ) -> getRawData ( alsoRemove ) ; } } if ( alsoRemove ) { m_dataCount -- ; } } DataField * DataFieldManager :: getChannel ( uint8_t channel ) { int32_t actualIndex = indexOf ( m_channelNumbers , ( uint32_t ) channel , m_fieldCount ) ; return actualIndex >= 0 ? m_fields [ actualIndex ] : NULL ; } DataField * DataFieldManager :: getField ( uint8_t index ) { return m_fields [ index ] ; } DataField * * DataFieldManager :: getFields ( void ) { return m_fields ; } uint32_t DataFieldManager :: writeHeadersToBuffer ( char * buffer , uint8_t bufferLength ) { if ( ! buffer ) { return 0 ; } uint8_t i ; FixedLengthAccumulator headerAccumulator ( buffer , bufferLength ) ; for ( i = 0 ; i < m_fieldCount ; ++ i ) { headerAccumulator . writeString ( m_fields [ i ] -> getTypeString ( ) ) ; if ( ! lastinloop ( i , m_fieldCount ) ) { headerAccumulator . writeString ( " , ▁ " ) ; } } headerAccumulator . writeString ( " \n " ) ; return headerAccumulator . length ( ) ; } void DataFieldManager :: setupAllValidChannels ( void ) { uint8_t ch ; NumericDataField * field ; FIELD_TYPE type ; void * data ; uint32_t maxChannels = Settings_GetMaxChannels ( ) ; for ( ch = 1 ; ch < maxChannels ; ch ++ ) { if ( Settings_ChannelSettingIsValid ( ch ) ) { type = Settings_GetChannelType ( ch ) ; data = Settings_GetData ( ch ) ; switch ( type ) { case VOLTAGE : case CURRENT : case TEMPERATURE_C : case TEMPERATURE_K : case TEMPERATURE_F : field = new NumericDataField ( type , data , ch ) ; # ifdef TEST std :: cout << " Adding ▁ channel ▁ " << ( int ) ch << " , ▁ type ▁ " << field -> getTypeString ( ) << std :: endl ; # endif addField ( field ) ; break ; default : break ; } } } } bool DataFieldManager :: hasData ( void ) { uint8_t i = 0 ; bool atLeastOneFieldHasData = false ; for ( i = 0 ; i < m_fieldCount ; i ++ ) { atLeastOneFieldHasData |= m_fields [ i ] -> hasData ( ) ; } return atLeastOneFieldHasData ; } uint32_t DataFieldManager :: count ( void ) { return m_dataCount ; } uint32_t * DataFieldManager :: getChannelNumbers ( void ) { return m_channelNumbers ; } </DOCUMENT>
<DOCUMENT_ID="llvm-mirror/clang/tree/master/unittests/Frontend/CodeGenActionTest.cpp"> # include " clang / CodeGen / CodeGenAction . h " # include " clang / Basic / LangStandard . h " # include " clang / CodeGen / BackendUtil . h " # include " clang / Frontend / CompilerInstance . h " # include " clang / Lex / PreprocessorOptions . h " # include " gtest / gtest . h " using namespace llvm ; using namespace clang ; using namespace clang :: frontend ; namespace { class NullCodeGenAction : public CodeGenAction { public : NullCodeGenAction ( llvm :: LLVMContext * _VMContext = nullptr ) : CodeGenAction ( Backend_EmitMCNull , _VMContext ) { } void ExecuteAction ( ) override { CompilerInstance & CI = getCompilerInstance ( ) ; if ( ! CI . hasPreprocessor ( ) ) return ; if ( ! CI . hasSema ( ) ) CI . createSema ( getTranslationUnitKind ( ) , nullptr ) ; } } ; TEST ( CodeGenTest , TestNullCodeGen ) { auto Invocation = std :: make_shared < CompilerInvocation > ( ) ; Invocation -> getPreprocessorOpts ( ) . addRemappedFile ( " test . cc " , MemoryBuffer :: getMemBuffer ( " " ) . release ( ) ) ; Invocation -> getFrontendOpts ( ) . Inputs . push_back ( FrontendInputFile ( " test . cc " , Language :: CXX ) ) ; Invocation -> getFrontendOpts ( ) . ProgramAction = EmitLLVM ; Invocation -> getTargetOpts ( ) . Triple = " i386 - unknown - linux - gnu " ; CompilerInstance Compiler ; Compiler . setInvocation ( std :: move ( Invocation ) ) ; Compiler . createDiagnostics ( ) ; EXPECT_TRUE ( Compiler . hasDiagnostics ( ) ) ; std :: unique_ptr < FrontendAction > Act ( new NullCodeGenAction ) ; bool Success = Compiler . ExecuteAction ( * Act ) ; EXPECT_TRUE ( Success ) ; } } </DOCUMENT>
<DOCUMENT_ID="patmarion/PCL/tree/master/sample_consensus/src/ransac.cpp"> # include < pcl / impl / instantiate . hpp > # include < pcl / point_types . h > # include < pcl / sample_consensus / ransac . h > # include < pcl / sample_consensus / impl / ransac . hpp > # ifdef PCL_ONLY_CORE_POINT_TYPES PCL_INSTANTIATE ( RandomSampleConsensus , ( pcl :: PointXYZ ) ( pcl :: PointXYZI ) ( pcl :: PointXYZRGBA ) ( pcl :: PointXYZRGB ) ) # else PCL_INSTANTIATE ( RandomSampleConsensus , PCL_XYZ_POINT_TYPES ) # endif </DOCUMENT>
<DOCUMENT_ID="m039/Void/tree/master/third-party/void-boost/libs/config/test/has_part_alloc_fail.cpp"> # ifdef BOOST_ASSERT_CONFIG # undef BOOST_ASSERT_CONFIG # endif # include < boost / config . hpp > # include " test . hpp " # ifndef BOOST_HAS_PARTIAL_STD_ALLOCATOR # include " boost _ has _ part _ alloc . ipp " # else # error " this ▁ file ▁ should ▁ not ▁ compile " # endif int main ( int , char * [ ] ) { return boost_has_partial_std_allocator :: test ( ) ; } </DOCUMENT>
<DOCUMENT_ID="lucafavatella/intellij-community/tree/master/platform/platform-api/src/com/intellij/openapi/ide/KillRingTransferable.java"> package com . intellij . openapi . ide ; import com . intellij . openapi . editor . Document ; import org . jetbrains . annotations . NotNull ; import org . jetbrains . annotations . Nullable ; import java . awt . datatransfer . DataFlavor ; import java . awt . datatransfer . StringSelection ; import java . awt . datatransfer . Transferable ; import java . awt . datatransfer . UnsupportedFlavorException ; import java . io . IOException ; import java . lang . ref . WeakReference ; public class KillRingTransferable implements Transferable { private static final DataFlavor [ ] DATA_FLAVORS = { DataFlavor . stringFlavor } ; private final String myData ; private final WeakReference < Document > myDocument ; private final int myStartOffset ; private final int myEndOffset ; private final boolean myCut ; private volatile boolean myReadyToCombine = true ; public KillRingTransferable ( @ NotNull String data , @ NotNull Document document , int startOffset , int endOffset , boolean cut ) { myData = data ; myDocument = new WeakReference < Document > ( document ) ; myStartOffset = startOffset ; myEndOffset = endOffset ; myCut = cut ; } @ Override public DataFlavor [ ] getTransferDataFlavors ( ) { return DATA_FLAVORS ; } @ Override public boolean isDataFlavorSupported ( DataFlavor flavor ) { return flavor == DataFlavor . stringFlavor ; } @ Nullable @ Override public Object getTransferData ( DataFlavor flavor ) throws UnsupportedFlavorException , IOException { return isDataFlavorSupported ( flavor ) ? myData : null ; } @ Nullable public Document getDocument ( ) { return myDocument . get ( ) ; } public int getStartOffset ( ) { return myStartOffset ; } public int getEndOffset ( ) { return myEndOffset ; } public boolean isCut ( ) { return myCut ; } public boolean isReadyToCombine ( ) { return myReadyToCombine ; } public void setReadyToCombine ( boolean readyToCombine ) { myReadyToCombine = readyToCombine ; } @ Override public String toString ( ) { return " data = ' " + myData + " ' , ▁ startOffset = " + myStartOffset + " , ▁ endOffset = " + myEndOffset + " , ▁ cut = " + myCut ; } } </DOCUMENT>
<DOCUMENT_ID="fitermay/intellij-community/tree/master/plugins/InspectionGadgets/test/com/siyeh/igtest/bugs/MisspelledToStringInsspection.java"> package com . siyeh . igtest . bugs ; public class MisspelledToStringInsspection { private int m_bar ; public MisspelledToStringInsspection ( ) { m_bar = 0 ; } public String tostring ( ) { return String . valueOf ( m_bar == 3 ) ; } } </DOCUMENT>
<DOCUMENT_ID="nuwanw/product-apim-2015-09-04/tree/master/modules/integration/tests-common/backend-service/src/main/java/org/wso2/am/integration.services/jaxrs/peoplesample/AppConfig.java"> package org . wso2 . am . integration . services . jaxrs . peoplesample ; import org . apache . cxf . bus . spring . SpringBus ; import org . apache . cxf . endpoint . Server ; import org . apache . cxf . jaxrs . JAXRSServerFactoryBean ; import org . codehaus . jackson . jaxrs . JacksonJsonProvider ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import javax . ws . rs . ext . RuntimeDelegate ; import java . util . Arrays ; @ Configuration public class AppConfig { @ Bean ( destroyMethod = " shutdown " ) public SpringBus cxf ( ) { return new SpringBus ( ) ; } @ Bean public Server jaxRsServer ( ) { JAXRSServerFactoryBean factory = RuntimeDelegate . getInstance ( ) . createEndpoint ( jaxRsApiApplication ( ) , JAXRSServerFactoryBean . class ) ; factory . setServiceBeans ( Arrays . < Object > asList ( peopleRestService ( ) ) ) ; factory . setAddress ( " / " + factory . getAddress ( ) ) ; factory . setProviders ( Arrays . < Object > asList ( jsonProvider ( ) ) ) ; return factory . create ( ) ; } @ Bean public JaxRsApiApplication jaxRsApiApplication ( ) { return new JaxRsApiApplication ( ) ; } @ Bean public PeopleRestService peopleRestService ( ) { return new PeopleRestService ( ) ; } @ Bean public PeopleService peopleService ( ) { return new PeopleService ( ) ; } @ Bean public JacksonJsonProvider jsonProvider ( ) { return new JacksonJsonProvider ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="jrversteegh/softsailor/tree/master/deps/swig-2.0.4/Examples/ruby/java/Example.java"> public class Example { public int mPublicInt ; public Example ( ) { mPublicInt = 0 ; } public Example ( int IntVal ) { mPublicInt = IntVal ; } public int Add ( int a , int b ) { return ( a + b ) ; } public float Add ( float a , float b ) { return ( a + b ) ; } public String Add ( String a , String b ) { return ( a + b ) ; } public Example Add ( Example a , Example b ) { return new Example ( a . mPublicInt + b . mPublicInt ) ; } } </DOCUMENT>
<DOCUMENT_ID="Rachels-Courses/Course-Common-Files/tree/master/STUDENT_REFERENCE/EXAMPLE_CODE/File IO/Java/OutputCSV/FileOutputter.java"> import java . io . * ; public class FileOutputter { private BufferedWriter m_writer ; private String m_filename ; public static void print ( String filename , String text ) { try { File file = new File ( filename ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( file . getAbsoluteFile ( ) , true ) ) ; bw . write ( text ) ; bw . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static void println ( String filename , String text ) { print ( filename , text + " \n " ) ; } public FileOutputter ( ) { m_filename = " default . txt " ; } public FileOutputter ( String filename ) { m_filename = filename ; } public void print ( String text ) { openFile ( m_filename ) ; try { m_writer . write ( text ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } closeFile ( ) ; } public void println ( String text ) { print ( text + " \n " ) ; } private void openFile ( String filename ) { try { File file = new File ( filename ) ; m_writer = new BufferedWriter ( new FileWriter ( file . getAbsoluteFile ( ) , true ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } private void closeFile ( ) { try { m_writer . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } </DOCUMENT>
<DOCUMENT_ID="qqming113/hadoop/tree/master/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/webapp/dao/TaskAttemptsInfo.java"> package org . apache . hadoop . mapreduce . v2 . app . webapp . dao ; import java . util . ArrayList ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = " taskAttempts " ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class TaskAttemptsInfo { protected ArrayList < TaskAttemptInfo > taskAttempt = new ArrayList < TaskAttemptInfo > ( ) ; public TaskAttemptsInfo ( ) { } public void add ( TaskAttemptInfo taskattemptInfo ) { taskAttempt . add ( taskattemptInfo ) ; } public ArrayList < TaskAttemptInfo > getTaskAttempts ( ) { return taskAttempt ; } } </DOCUMENT>
<DOCUMENT_ID="popstr/undertow/tree/master/core/src/main/java/io/undertow/util/CanonicalPathUtils.java"> package io . undertow . util ; import java . util . ArrayList ; import java . util . List ; public class CanonicalPathUtils { public static String canonicalize ( final String path ) { int state = START ; for ( int i = path . length ( ) - 1 ; i >= 0 ; -- i ) { final char c = path . charAt ( i ) ; switch ( c ) { case ' / ' : if ( state == FIRST_SLASH ) { return realCanonicalize ( path , i + 1 , FIRST_SLASH ) ; } else if ( state == ONE_DOT ) { return realCanonicalize ( path , i + 2 , FIRST_SLASH ) ; } else if ( state == TWO_DOT ) { return realCanonicalize ( path , i + 3 , FIRST_SLASH ) ; } state = FIRST_SLASH ; break ; case ' . ' : if ( state == FIRST_SLASH || state == START ) { state = ONE_DOT ; } else if ( state == ONE_DOT ) { state = TWO_DOT ; } else { state = NORMAL ; } break ; default : state = NORMAL ; break ; } } return path ; } static final int START = - 1 ; static final int NORMAL = 0 ; static final int FIRST_SLASH = 1 ; static final int ONE_DOT = 2 ; static final int TWO_DOT = 3 ; private static String realCanonicalize ( final String path , final int lastDot , final int initialState ) { int state = initialState ; int eatCount = 0 ; int tokenEnd = path . length ( ) ; final List < String > parts = new ArrayList < > ( ) ; for ( int i = lastDot - 1 ; i >= 0 ; -- i ) { final char c = path . charAt ( i ) ; switch ( state ) { case NORMAL : { if ( c == ' / ' ) { state = FIRST_SLASH ; if ( eatCount > 0 ) { -- eatCount ; tokenEnd = i ; } } break ; } case FIRST_SLASH : { if ( c == ' . ' ) { state = ONE_DOT ; } else if ( c == ' / ' ) { if ( eatCount > 0 ) { -- eatCount ; tokenEnd = i ; } else { parts . add ( path . substring ( i + 1 , tokenEnd ) ) ; tokenEnd = i ; } } else { state = NORMAL ; } break ; } case ONE_DOT : { if ( c == ' . ' ) { state = TWO_DOT ; } else if ( c == ' / ' ) { if ( i + 2 != tokenEnd ) { parts . add ( path . substring ( i + 2 , tokenEnd ) ) ; } tokenEnd = i ; state = FIRST_SLASH ; } else { state = NORMAL ; } break ; } case TWO_DOT : { if ( c == ' / ' ) { if ( i + 3 != tokenEnd ) { parts . add ( path . substring ( i + 3 , tokenEnd ) ) ; } tokenEnd = i ; eatCount ++ ; state = FIRST_SLASH ; } else { state = NORMAL ; } } } } final StringBuilder result = new StringBuilder ( ) ; if ( tokenEnd != 0 ) { result . append ( path . substring ( 0 , tokenEnd ) ) ; } for ( int i = parts . size ( ) - 1 ; i >= 0 ; -- i ) { result . append ( parts . get ( i ) ) ; } if ( result . length ( ) == 0 ) { return " / " ; } return result . toString ( ) ; } private CanonicalPathUtils ( ) { } } </DOCUMENT>
<DOCUMENT_ID="forever342/dubbo/tree/master/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/BroadcastCluster.java"> package com . alibaba . dubbo . rpc . cluster . support ; import com . alibaba . dubbo . rpc . Invoker ; import com . alibaba . dubbo . rpc . RpcException ; import com . alibaba . dubbo . rpc . cluster . Cluster ; import com . alibaba . dubbo . rpc . cluster . Directory ; public class BroadcastCluster implements Cluster { public < T > Invoker < T > join ( Directory < T > directory ) throws RpcException { return new BroadcastClusterInvoker < T > ( directory ) ; } } </DOCUMENT>
<DOCUMENT_ID="noonehide/CoolW/tree/master/app/src/main/java/bauhinia/coolw/beans/City.java"> package bauhinia . coolw . beans ; import com . lidroid . xutils . db . annotation . Column ; import com . lidroid . xutils . db . annotation . Id ; import com . lidroid . xutils . db . annotation . Table ; @ Table ( name = " city " ) public class City { @ Id ( column = " _ id " ) int id ; @ Column ( column = " province _ name " ) String city_name ; @ Column ( column = " province _ code " ) String city_code ; @ Column ( column = " province _ id " ) int province_id ; public City ( ) { } public City ( String city_name , String city_code , int province_id ) { this . city_name = city_name ; this . city_code = city_code ; this . province_id = province_id ; } public int getProvince_id ( ) { return province_id ; } public void setProvince_id ( int province_id ) { this . province_id = province_id ; } public int getId ( ) { return id ; } public void setId ( int id ) { this . id = id ; } public String getCity_name ( ) { return city_name ; } public void setCity_name ( String city_name ) { this . city_name = city_name ; } public String getCity_code ( ) { return city_code ; } public void setCity_code ( String city_code ) { this . city_code = city_code ; } } </DOCUMENT>
<DOCUMENT_ID="Metaswitch/jitsi/tree/master/src/net/java/sip/communicator/impl/protocol/rss/ContactGroupRssImpl.java"> package net . java . sip . communicator . impl . protocol . rss ; import java . util . * ; import net . java . sip . communicator . service . protocol . * ; public class ContactGroupRssImpl implements ContactGroup { private String groupName = null ; private Vector < Contact > contacts = new Vector < Contact > ( ) ; private Vector < ContactGroup > subGroups = new Vector < ContactGroup > ( ) ; private ContactGroupRssImpl parentGroup = null ; private boolean isPersistent = true ; private ProtocolProviderServiceRssImpl parentProvider = null ; private boolean isResolved = true ; private String uid = null ; private static final String UID_SUFFIX = " . uid " ; public ContactGroupRssImpl ( String groupName , ProtocolProviderServiceRssImpl parentProvider ) { this . groupName = groupName ; this . uid = groupName + UID_SUFFIX ; this . parentProvider = parentProvider ; } public boolean canContainSubgroups ( ) { return true ; } public ProtocolProviderService getProtocolProvider ( ) { return parentProvider ; } public Iterator < Contact > contacts ( ) { return contacts . iterator ( ) ; } public void addContact ( ContactRssImpl contactToAdd ) { this . contacts . add ( contactToAdd ) ; contactToAdd . setParentGroup ( this ) ; } public int countContacts ( ) { return contacts . size ( ) ; } public int countSubgroups ( ) { return subGroups . size ( ) ; } public void addSubgroup ( ContactGroupRssImpl subgroup ) { this . subGroups . add ( subgroup ) ; subgroup . setParentGroup ( this ) ; } void setParentGroup ( ContactGroupRssImpl parent ) { this . parentGroup = parent ; } public ContactGroup getParentContactGroup ( ) { return this . parentGroup ; } public void removeSubGroup ( ContactGroupRssImpl subgroup ) { this . subGroups . remove ( subgroup ) ; subgroup . setParentGroup ( null ) ; } public ContactGroupRssImpl findGroupParent ( ContactGroupRssImpl rssGroup ) { if ( subGroups . contains ( rssGroup ) ) return this ; Iterator < ContactGroup > subGroupsIter = subgroups ( ) ; while ( subGroupsIter . hasNext ( ) ) { ContactGroupRssImpl subgroup = ( ContactGroupRssImpl ) subGroupsIter . next ( ) ; ContactGroupRssImpl parent = subgroup . findGroupParent ( rssGroup ) ; if ( parent != null ) return parent ; } return null ; } public ContactGroupRssImpl findContactParent ( ContactRssImpl rssContact ) { if ( contacts . contains ( rssContact ) ) return this ; Iterator < ContactGroup > subGroupsIter = subgroups ( ) ; while ( subGroupsIter . hasNext ( ) ) { ContactGroupRssImpl subgroup = ( ContactGroupRssImpl ) subGroupsIter . next ( ) ; ContactGroupRssImpl parent = subgroup . findContactParent ( rssContact ) ; if ( parent != null ) return parent ; } return null ; } public Contact getContact ( String id ) { Iterator < Contact > contactsIter = contacts ( ) ; while ( contactsIter . hasNext ( ) ) { ContactRssImpl contact = ( ContactRssImpl ) contactsIter . next ( ) ; if ( contact . getAddress ( ) . equals ( id ) ) return contact ; } return null ; } public ContactGroup getGroup ( int index ) { return subGroups . get ( index ) ; } public ContactGroup getGroup ( String groupName ) { Iterator < ContactGroup > groupsIter = subgroups ( ) ; while ( groupsIter . hasNext ( ) ) { ContactGroupRssImpl contactGroup = ( ContactGroupRssImpl ) groupsIter . next ( ) ; if ( contactGroup . getGroupName ( ) . equals ( groupName ) ) return contactGroup ; } return null ; } public String getGroupName ( ) { return this . groupName ; } public void setGroupName ( String newGrpName ) { this . groupName = newGrpName ; } public Iterator < ContactGroup > subgroups ( ) { return subGroups . iterator ( ) ; } public void removeContact ( ContactRssImpl contact ) { this . contacts . remove ( contact ) ; } public ContactRssImpl findContactByID ( String id ) { Iterator < Contact > contactsIter = contacts ( ) ; while ( contactsIter . hasNext ( ) ) { ContactRssImpl mContact = ( ContactRssImpl ) contactsIter . next ( ) ; if ( mContact . getAddress ( ) . equals ( id ) ) return mContact ; } Iterator < ContactGroup > groupsIter = subgroups ( ) ; while ( groupsIter . hasNext ( ) ) { ContactGroupRssImpl mGroup = ( ContactGroupRssImpl ) groupsIter . next ( ) ; ContactRssImpl mContact = mGroup . findContactByID ( id ) ; if ( mContact != null ) return mContact ; } return null ; } @ Override public String toString ( ) { StringBuffer buff = new StringBuffer ( getGroupName ( ) ) ; buff . append ( " . subGroups = " + countSubgroups ( ) + " : \n " ) ; Iterator < ContactGroup > subGroups = subgroups ( ) ; while ( subGroups . hasNext ( ) ) { ContactGroupRssImpl group = ( ContactGroupRssImpl ) subGroups . next ( ) ; buff . append ( group . toString ( ) ) ; if ( subGroups . hasNext ( ) ) buff . append ( " \n " ) ; } buff . append ( " \n ChildContacts = " + countContacts ( ) + " : [ " ) ; Iterator < Contact > contacts = contacts ( ) ; while ( contacts . hasNext ( ) ) { ContactRssImpl contact = ( ContactRssImpl ) contacts . next ( ) ; buff . append ( contact . toString ( ) ) ; if ( contacts . hasNext ( ) ) buff . append ( " , ▁ " ) ; } return buff . append ( " ] " ) . toString ( ) ; } public void getRssURLList ( List < ContactRssImpl > rssURLList ) { Iterator < ContactGroup > subGroups = subgroups ( ) ; while ( subGroups . hasNext ( ) ) { ContactGroupRssImpl group = ( ContactGroupRssImpl ) subGroups . next ( ) ; group . getRssURLList ( rssURLList ) ; } Iterator < Contact > contacts = contacts ( ) ; while ( contacts . hasNext ( ) ) { ContactRssImpl contact = ( ContactRssImpl ) contacts . next ( ) ; rssURLList . add ( contact ) ; } } public void setPersistent ( boolean isPersistent ) { this . isPersistent = isPersistent ; } public boolean isPersistent ( ) { return isPersistent ; } public String getPersistentData ( ) { return null ; } public boolean isResolved ( ) { return isResolved ; } public void setResolved ( boolean resolved ) { this . isResolved = resolved ; } public String getUID ( ) { return uid ; } static String createNameFromUID ( String uid ) { return uid . substring ( 0 , uid . length ( ) - ( UID_SUFFIX . length ( ) ) ) ; } @ Override public boolean equals ( Object obj ) { if ( obj == null || ! ( obj instanceof ContactGroupRssImpl ) ) return false ; ContactGroupRssImpl rssGroup = ( ContactGroupRssImpl ) obj ; if ( ! rssGroup . getGroupName ( ) . equals ( getGroupName ( ) ) || ! rssGroup . getUID ( ) . equals ( getUID ( ) ) || rssGroup . countContacts ( ) != countContacts ( ) || rssGroup . countSubgroups ( ) != countSubgroups ( ) ) return false ; Iterator < Contact > theirContacts = rssGroup . contacts ( ) ; while ( theirContacts . hasNext ( ) ) { ContactRssImpl theirContact = ( ContactRssImpl ) theirContacts . next ( ) ; ContactRssImpl ourContact = ( ContactRssImpl ) getContact ( theirContact . getAddress ( ) ) ; if ( ourContact == null || ! ourContact . equals ( theirContact ) ) return false ; } Iterator < ContactGroup > theirSubgroups = rssGroup . subgroups ( ) ; while ( theirSubgroups . hasNext ( ) ) { ContactGroupRssImpl theirSubgroup = ( ContactGroupRssImpl ) theirSubgroups . next ( ) ; ContactGroupRssImpl ourSubgroup = ( ContactGroupRssImpl ) getGroup ( theirSubgroup . getGroupName ( ) ) ; if ( ourSubgroup == null || ! ourSubgroup . equals ( theirSubgroup ) ) return false ; } return true ; } } </DOCUMENT>
<DOCUMENT_ID="pkdevbox/Kundera/tree/master/src/kundera-cassandra/cassandra-ds-driver/src/main/java/com/impetus/kundera/client/cassandra/dsdriver/DSIdGenerator.java"> package com . impetus . kundera . client . cassandra . dsdriver ; import java . util . UUID ; import com . datastax . driver . core . ResultSet ; import com . impetus . kundera . client . Client ; import com . impetus . kundera . generator . AutoGenerator ; public class DSIdGenerator implements AutoGenerator { @ Override public Object generate ( Client < ? > client , String dataType ) { final String generatedId = " Select ▁ now ( ) ▁ from ▁ system . schema _ columns " ; ResultSet rSet = ( ( DSClient ) client ) . execute ( generatedId , null ) ; UUID uuid = rSet . iterator ( ) . next ( ) . getUUID ( 0 ) ; return uuid ; } } </DOCUMENT>
<DOCUMENT_ID="lowiki-org/localwiki-backend-server/tree/master/sapling-daisydiff/src/java/org/eclipse/compare/rangedifferencer/DifferencesIterator.java"> package org . eclipse . compare . rangedifferencer ; import java . util . ArrayList ; import java . util . List ; class DifferencesIterator { List fRange ; int fIndex ; RangeDifference [ ] fArray ; RangeDifference fDifference ; DifferencesIterator ( RangeDifference [ ] differenceRanges ) { fArray = differenceRanges ; fIndex = 0 ; fRange = new ArrayList ( ) ; if ( fIndex < fArray . length ) fDifference = fArray [ fIndex ++ ] ; else fDifference = null ; } int getCount ( ) { return fRange . size ( ) ; } void next ( ) { fRange . add ( fDifference ) ; if ( fDifference != null ) { if ( fIndex < fArray . length ) fDifference = fArray [ fIndex ++ ] ; else fDifference = null ; } } DifferencesIterator other ( DifferencesIterator right , DifferencesIterator left ) { if ( this == right ) return left ; return right ; } void removeAll ( ) { fRange . clear ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="pressgang-ccms/PressGangCCMSCommonUtilities/tree/master/src/main/java/org/jboss/pressgang/ccms/utils/common/ExceptionUtilities.java"> package org . jboss . pressgang . ccms . utils . common ; import java . io . PrintWriter ; import java . io . StringWriter ; public class ExceptionUtilities { public static String getStackTrace ( final Throwable ex ) { final StringWriter sw = new StringWriter ( ) ; final PrintWriter pw = new PrintWriter ( sw , true ) ; ex . printStackTrace ( pw ) ; pw . flush ( ) ; sw . flush ( ) ; return sw . toString ( ) ; } public static Throwable getRootCause ( Throwable throwable ) { if ( throwable . getCause ( ) != null ) return getRootCause ( throwable . getCause ( ) ) ; return throwable ; } } </DOCUMENT>
<DOCUMENT_ID="34benma/openjdk/tree/master/nashorn/test/src/jdk/nashorn/internal/runtime/test/LexicalBindingTest.java"> package jdk . nashorn . internal . runtime . test ; import jdk . nashorn . api . scripting . NashornScriptEngineFactory ; import org . testng . annotations . Test ; import javax . script . Bindings ; import javax . script . ScriptContext ; import javax . script . ScriptEngine ; import javax . script . ScriptException ; import javax . script . SimpleScriptContext ; import static org . testng . Assert . assertEquals ; @ SuppressWarnings ( " javadoc " ) public class LexicalBindingTest { final static String LANGUAGE_ES6 = " - - language = es6" ; final static int NUMBER_OF_CONTEXTS = 20 ; final static int MEGAMORPHIC_LOOP_COUNT = 20 ; @ Test public static void megamorphicVarTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( ) ; final ScriptContext [ ] contexts = new ScriptContext [ NUMBER_OF_CONTEXTS ] ; final String sharedScript = " foo " ; for ( int i = 0 ; i < NUMBER_OF_CONTEXTS ; i ++ ) { final ScriptContext context = contexts [ i ] = new SimpleScriptContext ( ) ; final Bindings b = e . createBindings ( ) ; context . setBindings ( b , ScriptContext . ENGINE_SCOPE ) ; assertEquals ( e . eval ( " var ▁ foo ▁ = ▁ ' " + i + " ' ; " , context ) , null ) ; } for ( int i = 0 ; i < NUMBER_OF_CONTEXTS ; i ++ ) { final ScriptContext context = contexts [ i ] ; assertEquals ( e . eval ( sharedScript , context ) , String . valueOf ( i ) ) ; } } @ Test public static void megamorphicMultiGlobalLetTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( LANGUAGE_ES6 ) ; final ScriptContext [ ] contexts = new ScriptContext [ NUMBER_OF_CONTEXTS ] ; final String sharedScript = " foo " ; for ( int i = 0 ; i < NUMBER_OF_CONTEXTS ; i ++ ) { final ScriptContext context = contexts [ i ] = new SimpleScriptContext ( ) ; final Bindings b = e . createBindings ( ) ; context . setBindings ( b , ScriptContext . ENGINE_SCOPE ) ; assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' " + i + " ' ; " , context ) , null ) ; } for ( int i = 0 ; i < NUMBER_OF_CONTEXTS ; i ++ ) { final ScriptContext context = contexts [ i ] ; assertEquals ( e . eval ( sharedScript , context ) , String . valueOf ( i ) ) ; } } @ Test public static void megamorphicSingleGlobalLetTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( LANGUAGE_ES6 ) ; final String sharedGetterScript = " foo " ; final String sharedSetterScript = " foo ▁ = ▁ 1" ; for ( int i = 0 ; i < MEGAMORPHIC_LOOP_COUNT ; i ++ ) { assertEquals ( e . eval ( sharedSetterScript ) , 1 ) ; assertEquals ( e . eval ( sharedGetterScript ) , 1 ) ; assertEquals ( e . eval ( " delete ▁ foo ; ▁ a " + i + " ▁ = ▁ 1 ; ▁ foo ▁ = ▁ " + i + " ; " ) , i ) ; assertEquals ( e . eval ( sharedGetterScript ) , i ) ; } assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' foo ' ; " ) , null ) ; assertEquals ( e . eval ( sharedGetterScript ) , " foo " ) ; assertEquals ( e . eval ( sharedSetterScript ) , 1 ) ; assertEquals ( e . eval ( sharedGetterScript ) , 1 ) ; assertEquals ( e . eval ( " this . foo " ) , MEGAMORPHIC_LOOP_COUNT - 1 ) ; } @ Test public static void megamorphicInheritedGlobalLetTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( LANGUAGE_ES6 ) ; final String sharedGetterScript = " foo " ; final String sharedSetterScript = " foo ▁ = ▁ 1" ; for ( int i = 0 ; i < MEGAMORPHIC_LOOP_COUNT ; i ++ ) { assertEquals ( e . eval ( sharedSetterScript ) , 1 ) ; assertEquals ( e . eval ( sharedGetterScript ) , 1 ) ; assertEquals ( e . eval ( " delete ▁ foo ; ▁ a " + i + " ▁ = ▁ 1 ; ▁ Object . prototype . foo ▁ = ▁ " + i + " ; " ) , i ) ; assertEquals ( e . eval ( sharedGetterScript ) , i ) ; } assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' foo ' ; " ) , null ) ; assertEquals ( e . eval ( sharedGetterScript ) , " foo " ) ; assertEquals ( e . eval ( sharedSetterScript ) , 1 ) ; assertEquals ( e . eval ( sharedGetterScript ) , 1 ) ; assertEquals ( e . eval ( " this . foo " ) , MEGAMORPHIC_LOOP_COUNT - 1 ) ; } @ Test public static void multiThreadedLetTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( LANGUAGE_ES6 ) ; final Bindings b = e . createBindings ( ) ; final ScriptContext origContext = e . getContext ( ) ; final ScriptContext newCtxt = new SimpleScriptContext ( ) ; newCtxt . setBindings ( b , ScriptContext . ENGINE_SCOPE ) ; final String sharedScript = " foo " ; assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' original ▁ context ' ; " , origContext ) , null ) ; assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' new ▁ context ' ; " , newCtxt ) , null ) ; final Thread t1 = new Thread ( new ScriptRunner ( e , origContext , sharedScript , " original ▁ context " , 1000 ) ) ; final Thread t2 = new Thread ( new ScriptRunner ( e , newCtxt , sharedScript , " new ▁ context " , 1000 ) ) ; t1 . start ( ) ; t2 . start ( ) ; t1 . join ( ) ; t2 . join ( ) ; assertEquals ( e . eval ( " foo ▁ = ▁ ' newer ▁ context ' ; " , newCtxt ) , " newer ▁ context " ) ; final Thread t3 = new Thread ( new ScriptRunner ( e , origContext , sharedScript , " original ▁ context " , 1000 ) ) ; final Thread t4 = new Thread ( new ScriptRunner ( e , newCtxt , sharedScript , " newer ▁ context " , 1000 ) ) ; t3 . start ( ) ; t4 . start ( ) ; t3 . join ( ) ; t4 . join ( ) ; assertEquals ( e . eval ( sharedScript ) , " original ▁ context " ) ; assertEquals ( e . eval ( sharedScript , newCtxt ) , " newer ▁ context " ) ; } private static class ScriptRunner implements Runnable { final ScriptEngine engine ; final ScriptContext context ; final String source ; final Object expected ; final int iterations ; ScriptRunner ( final ScriptEngine engine , final ScriptContext context , final String source , final Object expected , final int iterations ) { this . engine = engine ; this . context = context ; this . source = source ; this . expected = expected ; this . iterations = iterations ; } @ Override public void run ( ) { try { for ( int i = 0 ; i < iterations ; i ++ ) { assertEquals ( engine . eval ( source , context ) , expected ) ; } } catch ( final ScriptException se ) { throw new RuntimeException ( se ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="tuchida/rhino/tree/master/testsrc/org/mozilla/javascript/tests/Bug688021Test.java"> package org . mozilla . javascript . tests ; import static org . junit . Assert . assertEquals ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . mozilla . javascript . CompilerEnvirons ; import org . mozilla . javascript . Context ; import org . mozilla . javascript . ErrorReporter ; import org . mozilla . javascript . Parser ; import org . mozilla . javascript . ast . AstRoot ; public class Bug688021Test { private Context cx ; @ Before public void setUp ( ) { cx = Context . enter ( ) ; cx . setLanguageVersion ( Context . VERSION_1_8 ) ; } @ After public void tearDown ( ) { Context . exit ( ) ; } private AstRoot parse ( CharSequence cs ) { CompilerEnvirons compilerEnv = new CompilerEnvirons ( ) ; compilerEnv . initFromContext ( cx ) ; ErrorReporter compilationErrorReporter = compilerEnv . getErrorReporter ( ) ; Parser p = new Parser ( compilerEnv , compilationErrorReporter ) ; return p . parse ( cs . toString ( ) , " < eval > " , 1 ) ; } private String toSource ( CharSequence cs ) { return parse ( cs ) . toSource ( ) ; } @ Test public void testToSource ( ) { assertEquals ( " debugger ; \n " , toSource ( " debugger " ) ) ; assertEquals ( " debugger ; \n " , toSource ( " debugger ; " ) ) ; assertEquals ( " debugger ; \n " , toSource ( " debugger ; \n " ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="aporter/coursera-android/tree/master/Examples/BluetoothSetupAndTransferData/src/course/examples/bluetooth/setupandtransferdata/ConnectionThread.java"> package course . examples . bluetooth . setupandtransferdata ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import android . bluetooth . BluetoothSocket ; import android . os . Handler ; public class ConnectionThread extends Thread { BluetoothSocket mBluetoothSocket ; private final Handler mHandler ; private InputStream mInStream ; private OutputStream mOutStream ; ConnectionThread ( BluetoothSocket socket , Handler handler ) { super ( ) ; mBluetoothSocket = socket ; mHandler = handler ; try { mInStream = mBluetoothSocket . getInputStream ( ) ; mOutStream = mBluetoothSocket . getOutputStream ( ) ; } catch ( IOException e ) { } } @ Override public void run ( ) { byte [ ] buffer = new byte [ 1024 ] ; int bytes ; while ( true ) { try { bytes = mInStream . read ( buffer ) ; String data = new String ( buffer , 0 , bytes ) ; mHandler . obtainMessage ( DataTransferActivity . DATA_RECEIVED , data ) . sendToTarget ( ) ; } catch ( IOException e ) { break ; } } } public void write ( byte [ ] bytes ) { try { mOutStream . write ( bytes ) ; } catch ( IOException e ) { } } } </DOCUMENT>
<DOCUMENT_ID="karianna/jdk8_tl/tree/master/hotspot/test/compiler/5091921/Test6850611.java"> public class Test6850611 { public static void main ( String [ ] args ) { test ( ) ; } private static void test ( ) { for ( int j = 0 ; j < 5 ; ++ j ) { long x = 0 ; for ( int i = Integer . MIN_VALUE ; i < Integer . MAX_VALUE ; ++ i ) { x += i ; } System . out . println ( " sum : ▁ " + x ) ; if ( x != - 4294967295l ) { System . out . println ( " FAILED " ) ; System . exit ( 97 ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="agibsonccc/cloud-bigtable-client/tree/master/bigtable-hbase/src/main/java/com/google/cloud/bigtable/hbase/adapters/BigtableResultScannerAdapter.java"> package com . google . cloud . bigtable . hbase . adapters ; import com . google . api . client . util . Throwables ; import com . google . bigtable . v1 . Row ; import org . apache . hadoop . hbase . client . AbstractClientScanner ; import org . apache . hadoop . hbase . client . Result ; import org . apache . hadoop . hbase . client . ResultScanner ; import java . io . IOException ; public class BigtableResultScannerAdapter { final ResponseAdapter < Row , Result > rowAdapter ; public BigtableResultScannerAdapter ( ResponseAdapter < Row , Result > rowAdapter ) { this . rowAdapter = rowAdapter ; } public ResultScanner adapt ( final com . google . cloud . bigtable . grpc . scanner . ResultScanner < Row > bigtableResultScanner ) { return new AbstractClientScanner ( ) { @ Override public Result next ( ) throws IOException { Row row = bigtableResultScanner . next ( ) ; if ( row == null ) { return null ; } return rowAdapter . adaptResponse ( row ) ; } @ Override public void close ( ) { try { bigtableResultScanner . close ( ) ; } catch ( IOException ioe ) { throw Throwables . propagate ( ioe ) ; } } } ; } } </DOCUMENT>
<DOCUMENT_ID="scnakandala/derby/tree/master/java/engine/org/apache/derby/iapi/services/crypto/CipherProvider.java"> package org . apache . derby . iapi . services . crypto ; import java . security . Key ; import org . apache . derby . iapi . error . StandardException ; public interface CipherProvider { int encrypt ( byte [ ] cleartext , int offset , int length , byte [ ] ciphertext , int outputOffset ) throws StandardException ; int decrypt ( byte [ ] ciphertext , int offset , int length , byte [ ] cleartext , int outputOffset ) throws StandardException ; public int getEncryptionBlockSize ( ) ; } </DOCUMENT>
<DOCUMENT_ID="dslomov/intellij-community/tree/master/java/java-tests/testData/inspection/deadCode/junitAbstractClassWithInheritor/src/ChildTest.java"> public class ChildTest extends AbstractTest { } </DOCUMENT>
<DOCUMENT_ID="elijah513/ice/tree/master/java/test/src/main/java/test/Ice/location/ServerLocatorRegistry.java"> package test . Ice . location ; import test . Ice . location . Test . _TestLocatorRegistryDisp ; public class ServerLocatorRegistry extends _TestLocatorRegistryDisp { @ Override public void setAdapterDirectProxy_async ( Ice . AMD_LocatorRegistry_setAdapterDirectProxy cb , String adapter , Ice . ObjectPrx object , Ice . Current current ) { if ( object != null ) { _adapters . put ( adapter , object ) ; } else { _adapters . remove ( adapter ) ; } cb . ice_response ( ) ; } @ Override public void setReplicatedAdapterDirectProxy_async ( Ice . AMD_LocatorRegistry_setReplicatedAdapterDirectProxy cb , String adapter , String replica , Ice . ObjectPrx object , Ice . Current current ) { if ( object != null ) { _adapters . put ( adapter , object ) ; _adapters . put ( replica , object ) ; } else { _adapters . remove ( adapter ) ; _adapters . remove ( replica ) ; } cb . ice_response ( ) ; } @ Override public void setServerProcessProxy_async ( Ice . AMD_LocatorRegistry_setServerProcessProxy cb , String id , Ice . ProcessPrx proxy , Ice . Current current ) { } @ Override public void addObject ( Ice . ObjectPrx object , Ice . Current current ) { _objects . put ( object . ice_getIdentity ( ) , object ) ; } public Ice . ObjectPrx getAdapter ( String adapter ) throws Ice . AdapterNotFoundException { Ice . ObjectPrx obj = _adapters . get ( adapter ) ; if ( obj == null ) { throw new Ice . AdapterNotFoundException ( ) ; } return obj ; } public Ice . ObjectPrx getObject ( Ice . Identity id ) throws Ice . ObjectNotFoundException { Ice . ObjectPrx obj = _objects . get ( id ) ; if ( obj == null ) { throw new Ice . ObjectNotFoundException ( ) ; } return obj ; } private java . util . HashMap < String , Ice . ObjectPrx > _adapters = new java . util . HashMap < String , Ice . ObjectPrx > ( ) ; private java . util . HashMap < Ice . Identity , Ice . ObjectPrx > _objects = new java . util . HashMap < Ice . Identity , Ice . ObjectPrx > ( ) ; } </DOCUMENT>
<DOCUMENT_ID="iamjakob/elasticsearch/tree/master/core/src/test/java/org/elasticsearch/benchmark/search/aggregations/GlobalOrdinalsBenchmark.java"> package org . elasticsearch . benchmark . search . aggregations ; import com . carrotsearch . hppc . IntIntHashMap ; import com . carrotsearch . hppc . ObjectHashSet ; import com . carrotsearch . randomizedtesting . generators . RandomStrings ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . action . admin . cluster . stats . ClusterStatsResponse ; import org . elasticsearch . action . bulk . BulkRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . benchmark . search . aggregations . TermsAggregationSearchBenchmark . StatsResult ; import org . elasticsearch . bootstrap . BootstrapForTesting ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . unit . SizeValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . discovery . Discovery ; import org . elasticsearch . indices . IndexAlreadyExistsException ; import org . elasticsearch . node . Node ; import org . elasticsearch . search . aggregations . AggregationBuilders ; import org . elasticsearch . transport . TransportModule ; import java . util . * ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_REPLICAS ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_SHARDS ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . node . NodeBuilder . nodeBuilder ; public class GlobalOrdinalsBenchmark { private static final String INDEX_NAME = " index " ; private static final String TYPE_NAME = " type " ; private static final int QUERY_WARMUP = 25 ; private static final int QUERY_COUNT = 100 ; private static final int FIELD_START = 1 ; private static final int FIELD_LIMIT = 1 << 22 ; private static final boolean USE_DOC_VALUES = false ; static long COUNT = SizeValue . parseSizeValue ( "5m " ) . singles ( ) ; static Node node ; static Client client ; public static void main ( String [ ] args ) throws Exception { System . setProperty ( " es . logger . prefix " , " " ) ; BootstrapForTesting . ensureInitialized ( ) ; Random random = new Random ( ) ; Settings settings = settingsBuilder ( ) . put ( " index . refresh _ interval " , " - 1" ) . put ( SETTING_NUMBER_OF_SHARDS , 1 ) . put ( SETTING_NUMBER_OF_REPLICAS , 0 ) . put ( TransportModule . TRANSPORT_TYPE_KEY , " local " ) . build ( ) ; String clusterName = GlobalOrdinalsBenchmark . class . getSimpleName ( ) ; node = nodeBuilder ( ) . clusterName ( clusterName ) . settings ( settingsBuilder ( ) . put ( settings ) ) . node ( ) ; client = node . client ( ) ; try { client . admin ( ) . indices ( ) . prepareCreate ( INDEX_NAME ) . addMapping ( TYPE_NAME , jsonBuilder ( ) . startObject ( ) . startObject ( TYPE_NAME ) . startArray ( " dynamic _ templates " ) . startObject ( ) . startObject ( " default " ) . field ( " match " , " * " ) . field ( " match _ mapping _ type " , " string " ) . startObject ( " mapping " ) . field ( " type " , " string " ) . field ( " index " , " not _ analyzed " ) . startObject ( " fields " ) . startObject ( " doc _ values " ) . field ( " type " , " string " ) . field ( " index " , " no " ) . startObject ( " fielddata " ) . field ( " format " , " doc _ values " ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endArray ( ) . endObject ( ) . endObject ( ) ) . get ( ) ; ObjectHashSet < String > uniqueTerms = new ObjectHashSet < > ( ) ; for ( int i = 0 ; i < FIELD_LIMIT ; i ++ ) { boolean added ; do { added = uniqueTerms . add ( RandomStrings . randomAsciiOfLength ( random , 16 ) ) ; } while ( ! added ) ; } String [ ] sValues = uniqueTerms . toArray ( String . class ) ; uniqueTerms = null ; BulkRequestBuilder builder = client . prepareBulk ( ) ; IntIntHashMap tracker = new IntIntHashMap ( ) ; for ( int i = 0 ; i < COUNT ; i ++ ) { Map < String , Object > fieldValues = new HashMap < > ( ) ; for ( int fieldSuffix = 1 ; fieldSuffix <= FIELD_LIMIT ; fieldSuffix <<= 1 ) { int index = tracker . putOrAdd ( fieldSuffix , 0 , 0 ) ; if ( index >= fieldSuffix ) { index = random . nextInt ( fieldSuffix ) ; fieldValues . put ( " field _ " + fieldSuffix , sValues [ index ] ) ; } else { fieldValues . put ( " field _ " + fieldSuffix , sValues [ index ] ) ; tracker . put ( fieldSuffix , ++ index ) ; } } builder . add ( client . prepareIndex ( INDEX_NAME , TYPE_NAME , String . valueOf ( i ) ) . setSource ( fieldValues ) ) ; if ( builder . numberOfActions ( ) >= 1000 ) { builder . get ( ) ; builder = client . prepareBulk ( ) ; } } if ( builder . numberOfActions ( ) > 0 ) { builder . get ( ) ; } } catch ( IndexAlreadyExistsException e ) { System . out . println ( " - - > ▁ Index ▁ already ▁ exists , ▁ ignoring ▁ indexing ▁ phase , ▁ waiting ▁ for ▁ green " ) ; ClusterHealthResponse clusterHealthResponse = client . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForGreenStatus ( ) . setTimeout ( "10m " ) . execute ( ) . actionGet ( ) ; if ( clusterHealthResponse . isTimedOut ( ) ) { System . err . println ( " - - > ▁ Timed ▁ out ▁ waiting ▁ for ▁ cluster ▁ health " ) ; } } client . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( Settings . builder ( ) . put ( " logger . index . fielddata . ordinals " , " DEBUG " ) ) . get ( ) ; client . admin ( ) . indices ( ) . prepareRefresh ( INDEX_NAME ) . execute ( ) . actionGet ( ) ; COUNT = client . prepareCount ( INDEX_NAME ) . setQuery ( matchAllQuery ( ) ) . execute ( ) . actionGet ( ) . getCount ( ) ; System . out . println ( " - - > ▁ Number ▁ of ▁ docs ▁ in ▁ index : ▁ " + COUNT ) ; List < StatsResult > stats = new ArrayList < > ( ) ; for ( int fieldSuffix = FIELD_START ; fieldSuffix <= FIELD_LIMIT ; fieldSuffix <<= 1 ) { String fieldName = " field _ " + fieldSuffix ; String name = " global _ ordinals - " + fieldName ; if ( USE_DOC_VALUES ) { fieldName = fieldName + " . doc _ values " ; name = name + " _ doc _ values " ; } stats . add ( terms ( name , fieldName , " global _ ordinals _ low _ cardinality " ) ) ; } for ( int fieldSuffix = FIELD_START ; fieldSuffix <= FIELD_LIMIT ; fieldSuffix <<= 1 ) { String fieldName = " field _ " + fieldSuffix ; String name = " ordinals - " + fieldName ; if ( USE_DOC_VALUES ) { fieldName = fieldName + " . doc _ values " ; name = name + " _ doc _ values " ; } stats . add ( terms ( name , fieldName , " ordinals " ) ) ; } System . out . println ( " - - - - - - - - - - - - - - - - - - ▁ SUMMARY ▁ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " ) ; System . out . format ( Locale . ENGLISH , " % 30s % 10s % 10s % 15s \n " , " name " , " took " , " millis " , " fieldata ▁ size " ) ; for ( StatsResult stat : stats ) { System . out . format ( Locale . ENGLISH , " % 30s % 10s % 10d % 15s \n " , stat . name , TimeValue . timeValueMillis ( stat . took ) , ( stat . took / QUERY_COUNT ) , stat . fieldDataMemoryUsed ) ; } System . out . println ( " - - - - - - - - - - - - - - - - - - ▁ SUMMARY ▁ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " ) ; client . close ( ) ; node . close ( ) ; } private static StatsResult terms ( String name , String field , String executionHint ) { long totalQueryTime ; client . admin ( ) . indices ( ) . prepareClearCache ( ) . setFieldDataCache ( true ) . execute ( ) . actionGet ( ) ; System . gc ( ) ; System . out . println ( " - - > ▁ Warmup ▁ ( " + name + " ) . . . " ) ; for ( int j = 0 ; j < QUERY_WARMUP ; j ++ ) { SearchResponse searchResponse = client . prepareSearch ( INDEX_NAME ) . setSize ( 0 ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( AggregationBuilders . terms ( name ) . field ( field ) . executionHint ( executionHint ) ) . get ( ) ; if ( j == 0 ) { System . out . println ( " - - > ▁ Loading ▁ ( " + field + " ) : ▁ took : ▁ " + searchResponse . getTook ( ) ) ; } if ( searchResponse . getHits ( ) . totalHits ( ) != COUNT ) { System . err . println ( " - - > ▁ mismatch ▁ on ▁ hits " ) ; } } System . out . println ( " - - > ▁ Warmup ▁ ( " + name + " ) ▁ DONE " ) ; System . out . println ( " - - > ▁ Running ▁ ( " + name + " ) . . . " ) ; totalQueryTime = 0 ; for ( int j = 0 ; j < QUERY_COUNT ; j ++ ) { SearchResponse searchResponse = client . prepareSearch ( INDEX_NAME ) . setSize ( 0 ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( AggregationBuilders . terms ( name ) . field ( field ) . executionHint ( executionHint ) ) . get ( ) ; if ( searchResponse . getHits ( ) . totalHits ( ) != COUNT ) { System . err . println ( " - - > ▁ mismatch ▁ on ▁ hits " ) ; } totalQueryTime += searchResponse . getTookInMillis ( ) ; } System . out . println ( " - - > ▁ Terms ▁ Agg ▁ ( " + name + " ) : ▁ " + ( totalQueryTime / QUERY_COUNT ) + " ms " ) ; String nodeId = node . injector ( ) . getInstance ( Discovery . class ) . localNode ( ) . getId ( ) ; ClusterStatsResponse clusterStateResponse = client . admin ( ) . cluster ( ) . prepareClusterStats ( ) . setNodesIds ( nodeId ) . get ( ) ; System . out . println ( " - - > ▁ Heap ▁ used : ▁ " + clusterStateResponse . getNodesStats ( ) . getJvm ( ) . getHeapUsed ( ) ) ; ByteSizeValue fieldDataMemoryUsed = clusterStateResponse . getIndicesStats ( ) . getFieldData ( ) . getMemorySize ( ) ; System . out . println ( " - - > ▁ Fielddata ▁ memory ▁ size : ▁ " + fieldDataMemoryUsed ) ; return new StatsResult ( name , totalQueryTime , fieldDataMemoryUsed ) ; } } </DOCUMENT>
<DOCUMENT_ID="beano/gocd/tree/master/plugin-infra/go-plugin-infra/test/com/thoughtworks/go/plugin/infra/MultipleExtensionPluginWithPluginManagerIntegrationTest.java"> package com . thoughtworks . go . plugin . infra ; import java . io . File ; import java . io . IOException ; import com . thoughtworks . go . util . SystemEnvironment ; import com . thoughtworks . go . plugin . activation . DefaultGoPluginActivator ; import com . thoughtworks . go . plugin . infra . listeners . DefaultPluginJarChangeListener ; import com . thoughtworks . go . plugin . infra . monitor . PluginFileDetails ; import com . thoughtworks . go . plugin . infra . plugininfo . GoPluginDescriptor ; import org . apache . commons . io . FileUtils ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . test . context . ContextConfiguration ; import org . springframework . test . context . junit4 . SpringJUnit4ClassRunner ; import static com . thoughtworks . go . util . SystemEnvironment . PLUGIN_ACTIVATOR_JAR_PATH ; import static com . thoughtworks . go . util . SystemEnvironment . PLUGIN_BUNDLE_PATH ; import static com . thoughtworks . go . util . SystemEnvironment . PLUGIN_FRAMEWORK_ENABLED ; import static org . hamcrest . CoreMatchers . is ; import static org . hamcrest . MatcherAssert . assertThat ; @ RunWith ( SpringJUnit4ClassRunner . class ) @ ContextConfiguration ( locations = { " classpath : / applicationContext - plugin - infra . xml " } ) public class MultipleExtensionPluginWithPluginManagerIntegrationTest { public static final String PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_1 = " testplugin . multiple . extension . DescriptorPlugin1 . setPluginDescriptor . invoked " ; public static final String PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_2 = " testplugin . multiple . extension . DescriptorPlugin2 . setPluginDescriptor . invoked " ; private static final String PLUGIN_DIR_NAME = " . / tmp - DefPlgnMgrIntTest " ; private static final String BUNDLE_DIR_NAME = " . / tmp - bundles - DefPlgnMgrIntTest " ; private static final File PLUGIN_DIR = new File ( PLUGIN_DIR_NAME ) ; private static final File BUNDLE_DIR = new File ( BUNDLE_DIR_NAME ) ; private static final String PLUGIN_ID = " testplugin . multiple . extension " ; @ Autowired DefaultPluginManager pluginManager ; @ Autowired DefaultPluginJarChangeListener jarChangeListener ; @ Autowired SystemEnvironment systemEnvironment ; static { System . setProperty ( PLUGIN_ACTIVATOR_JAR_PATH . propertyName ( ) , " defaultFiles / go - plugin - activator . jar " ) ; System . setProperty ( PLUGIN_BUNDLE_PATH . propertyName ( ) , BUNDLE_DIR_NAME ) ; System . setProperty ( PLUGIN_FRAMEWORK_ENABLED . propertyName ( ) , " Y " ) ; } private static File pathOfFileInDefaultFiles ( String filePath ) { return new File ( MultipleExtensionPluginWithPluginManagerIntegrationTest . class . getClassLoader ( ) . getResource ( " defaultFiles / " + filePath ) . getFile ( ) ) ; } @ Test public void shouldProvideDescriptorToMultipleExtensionsImplementingThePluginDescriptorAwareInterface ( ) throws Exception { GoPluginDescriptor plugin = pluginManager . getPluginDescriptorFor ( PLUGIN_ID ) ; assertThat ( plugin . id ( ) , is ( PLUGIN_ID ) ) ; assertThat ( plugin . bundleSymbolicName ( ) , is ( PLUGIN_ID ) ) ; assertThat ( plugin . bundleClassPath ( ) , is ( " lib / go - plugin - activator . jar , . " ) ) ; assertThat ( plugin . bundleActivator ( ) , is ( DefaultGoPluginActivator . class . getCanonicalName ( ) ) ) ; assertThat ( plugin . isInvalid ( ) , is ( false ) ) ; assertThat ( System . getProperty ( PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_1 ) , is ( plugin . toString ( ) ) ) ; assertThat ( System . getProperty ( PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_2 ) , is ( plugin . toString ( ) ) ) ; } @ Before public void setUpPluginInfrastructure ( ) throws IOException { PLUGIN_DIR . mkdirs ( ) ; BUNDLE_DIR . mkdirs ( ) ; try { pluginManager . startInfrastructure ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } jarChangeListener . pluginJarAdded ( new PluginFileDetails ( pathOfFileInDefaultFiles ( " plugin - with - multiple - extensions . jar " ) , false ) ) ; } @ After public void tearDown ( ) throws Exception { System . clearProperty ( PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_1 ) ; System . clearProperty ( PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_2 ) ; FileUtils . deleteQuietly ( PLUGIN_DIR ) ; FileUtils . deleteQuietly ( BUNDLE_DIR ) ; pluginManager . stopInfrastructure ( ) ; FileUtils . deleteQuietly ( PLUGIN_DIR ) ; FileUtils . deleteQuietly ( BUNDLE_DIR ) ; } } </DOCUMENT>
<DOCUMENT_ID="likaiwalkman/hadoop/tree/master/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/webapp/dao/TaskAttemptsInfo.java"> package org . apache . hadoop . mapreduce . v2 . app . webapp . dao ; import java . util . ArrayList ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = " taskAttempts " ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class TaskAttemptsInfo { protected ArrayList < TaskAttemptInfo > taskAttempt = new ArrayList < TaskAttemptInfo > ( ) ; public TaskAttemptsInfo ( ) { } public void add ( TaskAttemptInfo taskattemptInfo ) { taskAttempt . add ( taskattemptInfo ) ; } public ArrayList < TaskAttemptInfo > getTaskAttempts ( ) { return taskAttempt ; } } </DOCUMENT>
<DOCUMENT_ID="seanzwx/tmp/tree/master/shop/android/imageloader/src/com/nostra13/universalimageloader/cache/memory/impl/LimitedAgeMemoryCache.java"> package com . nostra13 . universalimageloader . cache . memory . impl ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import com . nostra13 . universalimageloader . cache . memory . MemoryCacheAware ; public class LimitedAgeMemoryCache < K , V > implements MemoryCacheAware < K , V > { private final MemoryCacheAware < K , V > cache ; private final long maxAge ; private final Map < K , Long > loadingDates = Collections . synchronizedMap ( new HashMap < K , Long > ( ) ) ; public LimitedAgeMemoryCache ( MemoryCacheAware < K , V > cache , long maxAge ) { this . cache = cache ; this . maxAge = maxAge * 1000 ; } @ Override public boolean put ( K key , V value ) { boolean putSuccesfully = cache . put ( key , value ) ; if ( putSuccesfully ) { loadingDates . put ( key , System . currentTimeMillis ( ) ) ; } return putSuccesfully ; } @ Override public V get ( K key ) { Long loadingDate = loadingDates . get ( key ) ; if ( loadingDate != null && System . currentTimeMillis ( ) - loadingDate > maxAge ) { cache . remove ( key ) ; loadingDates . remove ( key ) ; } return cache . get ( key ) ; } @ Override public void remove ( K key ) { cache . remove ( key ) ; loadingDates . remove ( key ) ; } @ Override public Collection < K > keys ( ) { return cache . keys ( ) ; } @ Override public void clear ( ) { cache . clear ( ) ; loadingDates . clear ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="didoupimpon/CC152/tree/master/src/main/java/net/minecraft/server/ItemReed.java"> package net . minecraft . server ; import org . bukkit . block . BlockState ; import org . bukkit . craftbukkit . block . CraftBlockState ; import org . bukkit . craftbukkit . event . CraftEventFactory ; import org . bukkit . event . block . BlockPlaceEvent ; public class ItemReed extends Item { private int id ; public ItemReed ( int i , Block block ) { super ( i ) ; this . id = block . id ; } public boolean a ( ItemStack itemstack , EntityHuman entityhuman , World world , int i , int j , int k , int l ) { int clickedX = i , clickedY = j , clickedZ = k ; if ( world . getTypeId ( i , j , k ) == Block . SNOW . id ) { l = 0 ; } else { if ( l == 0 ) { -- j ; } if ( l == 1 ) { ++ j ; } if ( l == 2 ) { -- k ; } if ( l == 3 ) { ++ k ; } if ( l == 4 ) { -- i ; } if ( l == 5 ) { ++ i ; } } if ( itemstack . count == 0 ) { return false ; } else { if ( world . a ( this . id , i , j , k , false ) ) { Block block = Block . byId [ this . id ] ; BlockState replacedBlockState = CraftBlockState . getBlockState ( world , i , j , k ) ; if ( world . setRawTypeId ( i , j , k , this . id ) ) { BlockPlaceEvent event = CraftEventFactory . callBlockPlaceEvent ( world , entityhuman , replacedBlockState , clickedX , clickedY , clickedZ , block ) ; if ( event . isCancelled ( ) || ! event . canBuild ( ) ) { world . setTypeIdAndData ( i , j , k , replacedBlockState . getTypeId ( ) , replacedBlockState . getRawData ( ) ) ; } else { world . update ( i , j , k , this . id ) ; Block . byId [ this . id ] . postPlace ( world , i , j , k , l ) ; Block . byId [ this . id ] . postPlace ( world , i , j , k , entityhuman ) ; world . makeSound ( ( double ) ( ( float ) i + 0.5F ) , ( double ) ( ( float ) j + 0.5F ) , ( double ) ( ( float ) k + 0.5F ) , block . stepSound . getName ( ) , ( block . stepSound . getVolume1 ( ) + 1.0F ) / 2.0F , block . stepSound . getVolume2 ( ) * 0.8F ) ; -- itemstack . count ; } } } return true ; } } } </DOCUMENT>
<DOCUMENT_ID="volyrique/FrameworkBenchmarks/tree/master/frameworks/Java/dropwizard/src/main/java/com/example/helloworld/HelloJDBIService.java"> package com . example . helloworld ; import com . example . helloworld . db . jdbi . FortuneRepository ; import io . dropwizard . Application ; import io . dropwizard . jdbi3 . JdbiFactory ; import io . dropwizard . jdbi3 . bundles . JdbiExceptionsBundle ; import io . dropwizard . setup . Bootstrap ; import io . dropwizard . setup . Environment ; import io . dropwizard . views . ViewBundle ; import org . jdbi . v3 . core . Jdbi ; import com . example . helloworld . config . HelloWorldConfiguration ; import com . example . helloworld . db . jdbi . WorldRepository ; import com . example . helloworld . resources . FortuneResource ; import com . example . helloworld . resources . WorldResource ; public class HelloJDBIService extends Application < HelloWorldConfiguration > { public static void main ( String [ ] args ) throws Exception { new HelloJDBIService ( ) . run ( args ) ; } @ Override public void initialize ( Bootstrap < HelloWorldConfiguration > bootstrap ) { bootstrap . addBundle ( new ViewBundle < > ( ) ) ; bootstrap . addBundle ( new JdbiExceptionsBundle ( ) ) ; } @ Override public void run ( HelloWorldConfiguration config , Environment environment ) { final JdbiFactory factory = new JdbiFactory ( ) ; final Jdbi jdbi = factory . build ( environment , config . getDatabaseConfiguration ( ) , " RDBMS " ) ; environment . jersey ( ) . register ( new WorldResource ( new WorldRepository ( jdbi ) ) ) ; environment . jersey ( ) . register ( new FortuneResource ( new FortuneRepository ( jdbi ) ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="mayonghui2112/helloWorld/tree/master/sourceCode/OnJava8-Examples-master/patterns/trash/Paper.java"> package patterns . trash ; public class Paper extends Trash { private static double val = 0.10f ; public Paper ( double wt ) { super ( wt ) ; } @ Override public double value ( ) { return val ; } public static void value ( double newVal ) { val = newVal ; } } </DOCUMENT>
<DOCUMENT_ID="signed/intellij-community/tree/master/java/java-tests/testData/psi/parser-full/declarationParsing/class/NoType.java"> class ClassName { new X ( ) ; } </DOCUMENT>
<DOCUMENT_ID="poiru/uni-spiffer/tree/master/spiffer/src/test/java/com/mohanathas/spiffer/algorithm/NodeTest.java"> package com . mohanathas . spiffer . algorithm ; import com . mohanathas . spiffer . util . Point ; import org . junit . Test ; import static org . junit . Assert . * ; public class NodeTest { public NodeTest ( ) { } @ Test public void testConstructor ( ) { final Node node = new Node ( 1 , 2 ) ; assertEquals ( 1 , node . getX ( ) ) ; assertEquals ( 2 , node . getY ( ) ) ; assertEquals ( new Point ( 1 , 2 ) , node . getPoint ( ) ) ; assertEquals ( Float . MAX_VALUE , node . getStartDistance ( ) , 0.001f ) ; assertEquals ( 0.0f , node . getGoalDistance ( ) , 0.001f ) ; } @ Test public void testCompareTo ( ) { final Node node1 = new Node ( 0 , 0 ) ; final Node node2 = new Node ( 0 , 0 ) ; node1 . setStartDistance ( 1.0f ) ; node1 . setGoalDistance ( 2.0f ) ; node2 . setStartDistance ( 2.0f ) ; node2 . setGoalDistance ( 1.0f ) ; assertEquals ( 0 , node1 . compareTo ( node2 ) ) ; node2 . setGoalDistance ( 3.0f ) ; assertEquals ( - 1 , node1 . compareTo ( node2 ) ) ; } @ Test public void testToString ( ) { final Node node = new Node ( 1 , 2 ) ; assertEquals ( " ( 1 , ▁ 2 ) " , node . toString ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="fengyouchao/sockslib/tree/master/src/main/java/sockslib/client/CommandReplyMessage.java"> package sockslib . client ; import sockslib . common . AddressType ; import sockslib . utils . SocksUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . net . UnknownHostException ; public class CommandReplyMessage implements SocksMessage { protected Logger logger = LoggerFactory . getLogger ( CommandReplyMessage . class ) ; private byte [ ] replyBytes ; public CommandReplyMessage ( byte [ ] replyBytes ) { this . replyBytes = replyBytes ; } public boolean isSuccess ( ) { if ( replyBytes . length < 10 ) { return false ; } return replyBytes [ 1 ] == 0 ; } public InetAddress getIp ( ) throws UnknownHostException { byte [ ] addressBytes = null ; if ( replyBytes [ 3 ] == AddressType . IPV4 ) { addressBytes = new byte [ 4 ] ; } else if ( replyBytes [ 3 ] == AddressType . IPV6 ) { addressBytes = new byte [ 16 ] ; } System . arraycopy ( replyBytes , 4 , addressBytes , 0 , addressBytes . length ) ; return InetAddress . getByAddress ( addressBytes ) ; } public int getPort ( ) { return SocksUtil . bytesToInt ( replyBytes [ replyBytes . length - 2 ] , replyBytes [ replyBytes . length - 1 ] ) ; } public byte [ ] getReplyBytes ( ) { return replyBytes ; } public void setReplyBytes ( byte [ ] replyBytes ) { this . replyBytes = replyBytes ; } public SocketAddress getSocketAddress ( ) { try { return new InetSocketAddress ( getIp ( ) , getPort ( ) ) ; } catch ( UnknownHostException e ) { logger . error ( e . getMessage ( ) , e ) ; } return null ; } } </DOCUMENT>
<DOCUMENT_ID="dotunolafunmiloye/hadoop-common/tree/master/src/test/core/org/apache/hadoop/io/file/tfile/Timer.java"> package org . apache . hadoop . io . file . tfile ; import java . io . IOException ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; public class Timer { long startTimeEpoch ; long finishTimeEpoch ; private DateFormat formatter = new SimpleDateFormat ( " yyyy - MM - dd ▁ HH : mm : ss " ) ; public void startTime ( ) throws IOException { startTimeEpoch = System . currentTimeMillis ( ) ; } public void stopTime ( ) throws IOException { finishTimeEpoch = System . currentTimeMillis ( ) ; } public long getIntervalMillis ( ) throws IOException { return finishTimeEpoch - startTimeEpoch ; } public void printlnWithTimestamp ( String message ) throws IOException { System . out . println ( formatCurrentTime ( ) + " ▁ ▁ " + message ) ; } public String formatTime ( long millis ) { return formatter . format ( millis ) ; } public String getIntervalString ( ) throws IOException { long time = getIntervalMillis ( ) ; return formatTime ( time ) ; } public String formatCurrentTime ( ) { return formatTime ( System . currentTimeMillis ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="iweiss/activemq-artemis/tree/master/tests/activemq5-unit-tests/src/test/java/org/apache/activemq/spring/SpringConsumer.java"> package org . apache . activemq . spring ; import javax . jms . Connection ; import javax . jms . ConnectionFactory ; import javax . jms . Destination ; import javax . jms . JMSException ; import javax . jms . Message ; import javax . jms . MessageConsumer ; import javax . jms . MessageListener ; import javax . jms . Session ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . jms . core . JmsTemplate ; public class SpringConsumer extends ConsumerBean implements MessageListener { private static final Logger LOG = LoggerFactory . getLogger ( SpringConsumer . class ) ; private JmsTemplate template ; private String myId = " foo " ; private Destination destination ; private Connection connection ; private Session session ; private MessageConsumer consumer ; public void start ( ) throws JMSException { String selector = " next ▁ = ▁ ' " + myId + " ' " ; try { ConnectionFactory factory = template . getConnectionFactory ( ) ; final Connection c = connection = factory . createConnection ( ) ; synchronized ( c ) { if ( c . getClientID ( ) == null ) { c . setClientID ( myId ) ; } } connection . start ( ) ; session = connection . createSession ( true , Session . CLIENT_ACKNOWLEDGE ) ; consumer = session . createConsumer ( destination , selector , false ) ; consumer . setMessageListener ( this ) ; } catch ( JMSException ex ) { LOG . error ( " " , ex ) ; throw ex ; } } public void stop ( ) throws JMSException { if ( consumer != null ) { consumer . close ( ) ; } if ( session != null ) { session . close ( ) ; } if ( connection != null ) { connection . close ( ) ; } } @ Override public void onMessage ( Message message ) { super . onMessage ( message ) ; try { message . acknowledge ( ) ; } catch ( JMSException e ) { LOG . error ( " Failed ▁ to ▁ acknowledge : ▁ " + e , e ) ; } } public Destination getDestination ( ) { return destination ; } public void setDestination ( Destination destination ) { this . destination = destination ; } public String getMyId ( ) { return myId ; } public void setMyId ( String myId ) { this . myId = myId ; } public JmsTemplate getTemplate ( ) { return template ; } public void setTemplate ( JmsTemplate template ) { this . template = template ; } } </DOCUMENT>
<DOCUMENT_ID="apixandru/intellij-community/tree/master/java/java-tests/testData/psi/parser-full/declarationParsing/class/NoType.java"> class ClassName { new X ( ) ; } </DOCUMENT>
<DOCUMENT_ID="davidzchen/bazel/tree/master/third_party/java/proguard/proguard5.3.3/src/proguard/optimize/info/InstanceofClassMarker.java"> package proguard . optimize . info ; import proguard . classfile . * ; import proguard . classfile . attribute . CodeAttribute ; import proguard . classfile . constant . ClassConstant ; import proguard . classfile . constant . visitor . ConstantVisitor ; import proguard . classfile . instruction . * ; import proguard . classfile . instruction . visitor . InstructionVisitor ; import proguard . classfile . util . SimplifiedVisitor ; import proguard . classfile . visitor . ClassVisitor ; public class InstanceofClassMarker extends SimplifiedVisitor implements InstructionVisitor , ConstantVisitor , ClassVisitor { public void visitAnyInstruction ( Clazz clazz , Method method , CodeAttribute codeAttribute , int offset , Instruction instruction ) { } public void visitConstantInstruction ( Clazz clazz , Method method , CodeAttribute codeAttribute , int offset , ConstantInstruction constantInstruction ) { if ( constantInstruction . opcode == InstructionConstants . OP_INSTANCEOF ) { clazz . constantPoolEntryAccept ( constantInstruction . constantIndex , this ) ; } } public void visitClassConstant ( Clazz clazz , ClassConstant classConstant ) { classConstant . referencedClassAccept ( this ) ; } public void visitLibraryClass ( LibraryClass libraryClass ) { } public void visitProgramClass ( ProgramClass programClass ) { setInstanceofed ( programClass ) ; } private static void setInstanceofed ( Clazz clazz ) { ClassOptimizationInfo info = ClassOptimizationInfo . getClassOptimizationInfo ( clazz ) ; if ( info != null ) { info . setInstanceofed ( ) ; } } public static boolean isInstanceofed ( Clazz clazz ) { ClassOptimizationInfo info = ClassOptimizationInfo . getClassOptimizationInfo ( clazz ) ; return info == null || info . isInstanceofed ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="elastic-grid/Elastic-Grid/tree/master/modules/replicated-storage/src/main/java/com/elasticgrid/storage/replicated/ReplicatedContainer.java"> package com . elasticgrid . storage . replicated ; import com . elasticgrid . storage . Container ; import com . elasticgrid . storage . Storable ; import com . elasticgrid . storage . StorageException ; import com . elasticgrid . storage . StorableNotFoundException ; import java . util . Arrays ; import java . util . List ; import java . util . logging . Logger ; import java . io . File ; import java . io . InputStream ; public class ReplicatedContainer implements Container { private final Container preferred ; private final List < Container > otherContainers ; private static final Logger logger = Logger . getLogger ( ReplicatedContainer . class . getName ( ) ) ; public ReplicatedContainer ( Container preferred , List < Container > otherContainers ) { this . preferred = preferred ; this . otherContainers = otherContainers ; } public String getName ( ) { return null ; } public List < Storable > listStorables ( ) throws StorageException { return null ; } public Storable findStorableByName ( String name ) throws StorableNotFoundException , StorageException { return null ; } public Storable uploadStorable ( File file ) throws StorageException { return null ; } public Storable uploadStorable ( String name , File file ) throws StorageException { return null ; } public Storable uploadStorable ( String name , InputStream stream , String mimeType ) throws StorageException { return null ; } public void deleteStorable ( String name ) throws StorageException { } } </DOCUMENT>
<DOCUMENT_ID="AtwooTM/cassandra/tree/master/src/java/org/apache/cassandra/cql3/UTName.java"> package org . apache . cassandra . cql3 ; import java . nio . ByteBuffer ; public class UTName { private String ksName ; private final ColumnIdentifier utName ; public UTName ( ColumnIdentifier ksName , ColumnIdentifier utName ) { this . ksName = ksName == null ? null : ksName . toString ( ) ; this . utName = utName ; } public boolean hasKeyspace ( ) { return ksName != null ; } public void setKeyspace ( String keyspace ) { this . ksName = keyspace ; } public String getKeyspace ( ) { return ksName ; } public ByteBuffer getUserTypeName ( ) { return utName . bytes ; } public String getStringTypeName ( ) { return utName . toString ( ) ; } @ Override public String toString ( ) { return ( hasKeyspace ( ) ? ( ksName + " . " ) : " " ) + utName ; } } </DOCUMENT>
<DOCUMENT_ID="WelcomeHUME/svn-caucho-com-resin/tree/master/modules/jca/src/javax/resource/cci/ResourceAdapterMetaData.java"> package javax . resource . cci ; public interface ResourceAdapterMetaData { public String getAdapterVersion ( ) ; public String getAdapterVendorName ( ) ; public String getAdapterName ( ) ; public String getAdapterShortDescription ( ) ; public String getSpecVersion ( ) ; public String [ ] getInteractionSpecsSupported ( ) ; public boolean supportsExecuteWithInputAndOutputRecord ( ) ; public boolean supportsExecuteWithInputRecordOnly ( ) ; public boolean supportsLocalTransactionDemarcation ( ) ; } </DOCUMENT>
<DOCUMENT_ID="tharindum/opennms_dashboard/tree/master/opennms-webapp/src/main/java/org/opennms/web/report/database/ReportParametersValidator.java"> package org . opennms . web . report . database ; import java . util . Iterator ; import java . util . List ; import org . opennms . api . reporting . parameter . ReportDoubleParm ; import org . opennms . api . reporting . parameter . ReportFloatParm ; import org . opennms . api . reporting . parameter . ReportParameters ; import org . opennms . api . reporting . parameter . ReportDateParm ; import org . opennms . api . reporting . parameter . ReportIntParm ; import org . opennms . api . reporting . parameter . ReportStringParm ; import org . springframework . binding . message . MessageBuilder ; import org . springframework . binding . message . MessageContext ; import org . springframework . binding . validation . ValidationContext ; public class ReportParametersValidator { public void validateReportParameters ( ReportParameters reportCriteria , ValidationContext context ) { MessageContext messages = context . getMessageContext ( ) ; List < ReportDateParm > dateParms = reportCriteria . getDateParms ( ) ; for ( Iterator < ReportDateParm > dateParmIter = dateParms . iterator ( ) ; dateParmIter . hasNext ( ) ; ) { ReportDateParm dateParm = dateParmIter . next ( ) ; if ( dateParm . getDate ( ) == null ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " date ▁ parms " ) . defaultText ( " cannot ▁ have ▁ null ▁ date ▁ field " + dateParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportStringParm > stringParms = reportCriteria . getStringParms ( ) ; for ( Iterator < ReportStringParm > stringParmIter = stringParms . iterator ( ) ; stringParmIter . hasNext ( ) ; ) { ReportStringParm stringParm = stringParmIter . next ( ) ; if ( stringParm . getValue ( ) == " " ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " string ▁ parms " ) . defaultText ( " cannot ▁ have ▁ empty ▁ string ▁ field " + stringParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportIntParm > intParms = reportCriteria . getIntParms ( ) ; for ( Iterator < ReportIntParm > intParmIter = intParms . iterator ( ) ; intParmIter . hasNext ( ) ; ) { ReportIntParm intParm = intParmIter . next ( ) ; if ( intParm . getValue ( ) == 0 ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " int ▁ parms " ) . defaultText ( " cannot ▁ have ▁ zero ▁ integer ▁ field " + intParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportFloatParm > floatParms = reportCriteria . getFloatParms ( ) ; for ( Iterator < ReportFloatParm > floatParmIter = floatParms . iterator ( ) ; floatParmIter . hasNext ( ) ; ) { ReportFloatParm floatParm = floatParmIter . next ( ) ; if ( floatParm . getValue ( ) == null ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " float ▁ parms " ) . defaultText ( " cannot ▁ have ▁ null ▁ float ▁ field " + floatParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportDoubleParm > doubleParms = reportCriteria . getDoubleParms ( ) ; for ( Iterator < ReportDoubleParm > doubleParmIter = doubleParms . iterator ( ) ; doubleParmIter . hasNext ( ) ; ) { ReportDoubleParm doubleParm = doubleParmIter . next ( ) ; if ( doubleParm . getValue ( ) == null ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " double ▁ parms " ) . defaultText ( " cannot ▁ have ▁ null ▁ double ▁ field " + doubleParm . getDisplayName ( ) ) . build ( ) ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="tuxillo/aarch64-dragonfly-gcc/tree/master/libjava/classpath/gnu/java/net/protocol/jar/Handler.java"> package gnu . java . net . protocol . jar ; import gnu . java . lang . CPStringBuilder ; import gnu . java . net . URLParseError ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLConnection ; import java . net . URLStreamHandler ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . StringTokenizer ; public class Handler extends URLStreamHandler { public Handler ( ) { } protected URLConnection openConnection ( URL url ) throws IOException { return new Connection ( url ) ; } protected void parseURL ( URL url , String url_string , int start , int end ) { String file = url . getFile ( ) ; if ( ! file . equals ( " " ) ) { url_string = url_string . substring ( start , end ) ; if ( url_string . startsWith ( " / " ) ) { int idx = file . lastIndexOf ( " ! / " ) ; if ( idx < 0 ) throw new URLParseError ( " no ▁ ! / ▁ in ▁ spec " ) ; file = file . substring ( 0 , idx + 1 ) + url_string ; } else if ( url_string . length ( ) > 0 ) { int idx = file . lastIndexOf ( " / " ) ; if ( idx == - 1 ) file = " / " + url_string ; else if ( idx == ( file . length ( ) - 1 ) ) file = file + url_string ; else file = file . substring ( 0 , idx + 1 ) + url_string ; } setURL ( url , " jar " , url . getHost ( ) , url . getPort ( ) , flat ( file ) , null ) ; return ; } if ( end < start ) return ; if ( end - start < 2 ) return ; if ( start > url_string . length ( ) ) return ; url_string = url_string . substring ( start , end ) ; int jar_stop ; if ( ( jar_stop = url_string . indexOf ( " ! / " ) ) < 0 ) throw new URLParseError ( " no ▁ ! / ▁ in ▁ spec " ) ; try { new URL ( url_string . substring ( 0 , jar_stop ) ) ; } catch ( MalformedURLException e ) { throw new URLParseError ( " invalid ▁ inner ▁ URL : ▁ " + e . getMessage ( ) ) ; } if ( ! url . getProtocol ( ) . equals ( " jar " ) ) throw new URLParseError ( " unexpected ▁ protocol ▁ " + url . getProtocol ( ) ) ; setURL ( url , " jar " , url . getHost ( ) , url . getPort ( ) , url_string , null ) ; } private static String flat ( String url_string ) { int jar_stop = url_string . indexOf ( " ! / " ) ; String jar_path = url_string . substring ( jar_stop + 1 , url_string . length ( ) ) ; if ( jar_path . indexOf ( " / . " ) < 0 ) return url_string ; ArrayList < String > tokens = new ArrayList < String > ( ) ; StringTokenizer st = new StringTokenizer ( jar_path , " / " ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; if ( token . equals ( " . " ) ) continue ; else if ( token . equals ( " . . " ) ) { if ( ! tokens . isEmpty ( ) ) tokens . remove ( tokens . size ( ) - 1 ) ; } else tokens . add ( token ) ; } CPStringBuilder path = new CPStringBuilder ( url_string . length ( ) ) ; path . append ( url_string . substring ( 0 , jar_stop + 1 ) ) ; Iterator < String > it = tokens . iterator ( ) ; while ( it . hasNext ( ) ) path . append ( ' / ' ) . append ( it . next ( ) ) ; return path . toString ( ) ; } protected String toExternalForm ( URL url ) { String file = url . getFile ( ) ; String ref = url . getRef ( ) ; CPStringBuilder sb = new CPStringBuilder ( file . length ( ) + 5 ) ; sb . append ( " jar : " ) ; sb . append ( file ) ; if ( ref != null ) sb . append ( ' # ' ) . append ( ref ) ; return sb . toString ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="iliat/gatk-tools-java/tree/master/src/main/java/com/google/cloud/genomics/gatk/common/GenomicsConverterBase.java"> package com . google . cloud . genomics . gatk . common ; import htsjdk . samtools . SAMFileHeader ; import htsjdk . samtools . SAMRecord ; import java . util . List ; public abstract class GenomicsConverterBase < Read , ReadGroupSet , Reference > implements GenomicsConverter < Read , ReadGroupSet , Reference > { @ Override public SAMRecord makeSAMRecord ( Read read , ReadGroupSet readGroupSet , List < Reference > references , boolean forceSetMatePositionToThisPosition ) { return makeSAMRecord ( read , makeSAMFileHeader ( readGroupSet , references ) ) ; } @ Override public SAMRecord makeSAMRecord ( Read read , boolean forceSetMatePositionToThisPosition ) { return makeSAMRecord ( read , new SAMFileHeader ( ) ) ; } @ Override public abstract SAMFileHeader makeSAMFileHeader ( ReadGroupSet readGroupSet , List < Reference > references ) ; @ Override public abstract SAMRecord makeSAMRecord ( Read read , SAMFileHeader header ) ; } </DOCUMENT>
<DOCUMENT_ID="skyHALud/codenameone/tree/master/Ports/iOSPort/xmlvm/apache-harmony-6.0-src-r991881/classlib/modules/luni/src/test/api/common/org/apache/harmony/luni/tests/java/lang/ThreadTest.java"> package org . apache . harmony . luni . tests . java . lang ; import java . lang . Thread . UncaughtExceptionHandler ; import java . security . Permission ; import java . util . Map ; public class ThreadTest extends junit . framework . TestCase { static class SimpleThread implements Runnable { int delay ; public void run ( ) { try { synchronized ( this ) { this . notify ( ) ; this . wait ( delay ) ; } } catch ( InterruptedException e ) { return ; } } public SimpleThread ( int d ) { if ( d >= 0 ) delay = d ; } } static class YieldThread implements Runnable { volatile int delay ; public void run ( ) { int x = 0 ; while ( true ) { ++ x ; } } public YieldThread ( int d ) { if ( d >= 0 ) delay = d ; } } static class ResSupThread implements Runnable { Thread parent ; volatile int checkVal = - 1 ; public void run ( ) { try { synchronized ( this ) { this . notify ( ) ; } while ( true ) { checkVal ++ ; zz ( ) ; Thread . sleep ( 100 ) ; } } catch ( InterruptedException e ) { return ; } catch ( BogusException e ) { try { Thread . sleep ( 500 ) ; } catch ( InterruptedException x ) { } parent . interrupt ( ) ; while ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { try { Thread . sleep ( 50 ) ; } catch ( InterruptedException x ) { break ; } } } } public void zz ( ) throws BogusException { } public ResSupThread ( Thread t ) { parent = t ; } public synchronized int getCheckVal ( ) { return checkVal ; } } static class BogusException extends Throwable { private static final long serialVersionUID = 1L ; public BogusException ( String s ) { super ( s ) ; } } Thread st , ct , spinner ; static boolean calledMySecurityManager = false ; public void test_Constructor ( ) { Thread t ; SecurityManager m = new SecurityManager ( ) { @ Override public ThreadGroup getThreadGroup ( ) { calledMySecurityManager = true ; return Thread . currentThread ( ) . getThreadGroup ( ) ; } @ Override public void checkPermission ( Permission permission ) { if ( permission . getName ( ) . equals ( " setSecurityManager " ) ) { return ; } super . checkPermission ( permission ) ; } } ; try { System . setSecurityManager ( m ) ; t = new Thread ( ) ; } finally { System . setSecurityManager ( null ) ; } assertTrue ( " Did ▁ not ▁ call ▁ SecurityManager . getThreadGroup ▁ ( ) " , calledMySecurityManager ) ; t . start ( ) ; } public void test_ConstructorLjava_lang_Runnable ( ) { ct = new Thread ( new SimpleThread ( 10 ) ) ; ct . start ( ) ; } public void test_ConstructorLjava_lang_RunnableLjava_lang_String ( ) { Thread st1 = new Thread ( new SimpleThread ( 1 ) , " SimpleThread1" ) ; assertEquals ( " Constructed ▁ thread ▁ with ▁ incorrect ▁ thread ▁ name " , " SimpleThread1" , st1 . getName ( ) ) ; st1 . start ( ) ; } public void test_ConstructorLjava_lang_String ( ) { Thread t = new Thread ( " Testing " ) ; assertEquals ( " Created ▁ tread ▁ with ▁ incorrect ▁ name " , " Testing " , t . getName ( ) ) ; t . start ( ) ; } public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_Runnable ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group1" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread2" ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ group " , st . getThreadGroup ( ) == tg ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; } public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_RunnableLjava_lang_String ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group2" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread3" ) ; assertTrue ( " Constructed ▁ incorrect ▁ thread " , ( st . getThreadGroup ( ) == tg ) && st . getName ( ) . equals ( " SimpleThread3" ) ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; Runnable r = new Runnable ( ) { public void run ( ) { } } ; ThreadGroup foo = null ; try { new Thread ( foo = new ThreadGroup ( " foo " ) , r , null ) ; fail ( " Null ▁ cannot ▁ be ▁ accepted ▁ as ▁ Thread ▁ name " ) ; } catch ( NullPointerException npe ) { assertTrue ( " Null ▁ cannot ▁ be ▁ accepted ▁ as ▁ Thread ▁ name " , true ) ; foo . destroy ( ) ; } } public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_String ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread4" ) ; assertEquals ( " Returned ▁ incorrect ▁ thread ▁ name " , " SimpleThread4" , st . getName ( ) ) ; st . start ( ) ; } public void test_activeCount ( ) { Thread t = new Thread ( new SimpleThread ( 10 ) ) ; int active = 0 ; synchronized ( t ) { t . start ( ) ; active = Thread . activeCount ( ) ; } assertTrue ( " Incorrect ▁ activeCount ▁ for ▁ current ▁ group : ▁ " + active , active > 1 ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { } } public void test_checkAccess ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group3" ) ; try { st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread5" ) ; st . checkAccess ( ) ; assertTrue ( " CheckAccess ▁ passed " , true ) ; } catch ( SecurityException e ) { fail ( " CheckAccess ▁ failed ▁ : ▁ " + e . getMessage ( ) ) ; } st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; } @ SuppressWarnings ( " deprecation " ) public void test_countStackFrames ( ) { Thread . currentThread ( ) . countStackFrames ( ) ; } public void test_currentThread ( ) { assertNotNull ( Thread . currentThread ( ) ) ; } @ SuppressWarnings ( " deprecation " ) public void test_destroy ( ) { try { new Thread ( ) . destroy ( ) ; } catch ( NoSuchMethodError e ) { } } public void test_enumerate$Ljava_lang_Thread ( ) { class MyThread extends Thread { MyThread ( ThreadGroup tg , String name ) { super ( tg , name ) ; } boolean failed = false ; String failMessage = null ; public void run ( ) { SimpleThread st1 = null ; SimpleThread st2 = null ; ThreadGroup mytg = null ; Thread firstOne = null ; Thread secondOne = null ; try { int arrayLength = 10 ; Thread [ ] tarray = new Thread [ arrayLength ] ; st1 = new SimpleThread ( - 1 ) ; st2 = new SimpleThread ( - 1 ) ; mytg = new ThreadGroup ( " jp " ) ; firstOne = new Thread ( mytg , st1 , " firstOne2" ) ; secondOne = new Thread ( mytg , st2 , " secondOne1" ) ; int count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned1" , 1 , count ) ; synchronized ( st1 ) { firstOne . start ( ) ; try { st1 . wait ( ) ; } catch ( InterruptedException e ) { } } count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned2" , 2 , count ) ; synchronized ( st2 ) { secondOne . start ( ) ; try { st2 . wait ( ) ; } catch ( InterruptedException e ) { } } count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned3" , 3 , count ) ; } catch ( junit . framework . AssertionFailedError e ) { failed = true ; failMessage = e . getMessage ( ) ; } finally { synchronized ( st1 ) { firstOne . interrupt ( ) ; } synchronized ( st2 ) { secondOne . interrupt ( ) ; } try { firstOne . join ( ) ; secondOne . join ( ) ; } catch ( InterruptedException e ) { } mytg . destroy ( ) ; } } } ; ThreadGroup tg = new ThreadGroup ( " tg " ) ; MyThread t = new MyThread ( tg , " top " ) ; t . start ( ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt " ) ; } finally { tg . destroy ( ) ; } assertFalse ( t . failMessage , t . failed ) ; } public void test_getContextClassLoader ( ) { Thread t = new Thread ( ) ; assertTrue ( " Incorrect ▁ class ▁ loader ▁ returned " , t . getContextClassLoader ( ) == Thread . currentThread ( ) . getContextClassLoader ( ) ) ; t . start ( ) ; } public void test_getName ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread6" ) ; assertEquals ( " Returned ▁ incorrect ▁ thread ▁ name " , " SimpleThread6" , st . getName ( ) ) ; st . start ( ) ; } public void test_getPriority ( ) { st = new Thread ( new SimpleThread ( 1 ) ) ; st . setPriority ( Thread . MAX_PRIORITY ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ priority " , st . getPriority ( ) == Thread . MAX_PRIORITY ) ; st . start ( ) ; } public void test_getThreadGroup ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group4" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread8" ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ group " , st . getThreadGroup ( ) == tg ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } assertNull ( " group ▁ should ▁ be ▁ null " , st . getThreadGroup ( ) ) ; assertNotNull ( " toString ( ) ▁ should ▁ not ▁ be ▁ null " , st . toString ( ) ) ; tg . destroy ( ) ; final Object lock = new Object ( ) ; Thread t = new Thread ( ) { @ Override public void run ( ) { synchronized ( lock ) { lock . notifyAll ( ) ; } } } ; synchronized ( lock ) { t . start ( ) ; try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } int running = 0 ; while ( t . isAlive ( ) ) running ++ ; ThreadGroup group = t . getThreadGroup ( ) ; assertNull ( " ThreadGroup ▁ is ▁ not ▁ null " , group ) ; } public void test_interrupt ( ) { final Object lock = new Object ( ) ; class ChildThread1 extends Thread { Thread parent ; boolean sync ; @ Override public void run ( ) { if ( sync ) { synchronized ( lock ) { lock . notify ( ) ; try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } } parent . interrupt ( ) ; } public ChildThread1 ( Thread p , String name , boolean sync ) { super ( name ) ; parent = p ; this . sync = sync ; } } boolean interrupted = false ; try { ct = new ChildThread1 ( Thread . currentThread ( ) , " Interrupt ▁ Test1" , false ) ; synchronized ( lock ) { ct . start ( ) ; lock . wait ( ) ; } } catch ( InterruptedException e ) { interrupted = true ; } assertTrue ( " Failed ▁ to ▁ Interrupt ▁ thread1" , interrupted ) ; interrupted = false ; try { ct = new ChildThread1 ( Thread . currentThread ( ) , " Interrupt ▁ Test2" , true ) ; synchronized ( lock ) { ct . start ( ) ; lock . wait ( ) ; lock . notify ( ) ; } Thread . sleep ( 20000 ) ; } catch ( InterruptedException e ) { interrupted = true ; } assertTrue ( " Failed ▁ to ▁ Interrupt ▁ thread2" , interrupted ) ; } public void test_interrupted ( ) { assertFalse ( " Interrupted ▁ returned ▁ true ▁ for ▁ non - interrupted ▁ thread " , Thread . interrupted ( ) ) ; Thread . currentThread ( ) . interrupt ( ) ; assertTrue ( " Interrupted ▁ returned ▁ true ▁ for ▁ non - interrupted ▁ thread " , Thread . interrupted ( ) ) ; assertFalse ( " Failed ▁ to ▁ clear ▁ interrupted ▁ flag " , Thread . interrupted ( ) ) ; } public void test_isAlive ( ) { SimpleThread simple ; st = new Thread ( simple = new SimpleThread ( 500 ) ) ; assertFalse ( " A ▁ thread ▁ that ▁ wasn ' t ▁ started ▁ is ▁ alive . " , st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; try { simple . wait ( ) ; } catch ( InterruptedException e ) { } } assertTrue ( " Started ▁ thread ▁ returned ▁ false " , st . isAlive ( ) ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { fail ( " Thread ▁ did ▁ not ▁ die " ) ; } assertTrue ( " Stopped ▁ thread ▁ returned ▁ true " , ! st . isAlive ( ) ) ; } public void test_isDaemon ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread10" ) ; assertTrue ( " Non - Daemon ▁ thread ▁ returned ▁ true " , ! st . isDaemon ( ) ) ; st . setDaemon ( true ) ; assertTrue ( " Daemon ▁ thread ▁ returned ▁ false " , st . isDaemon ( ) ) ; st . start ( ) ; } public void test_isInterrupted ( ) { class SpinThread implements Runnable { public volatile boolean done = false ; public void run ( ) { while ( ! Thread . currentThread ( ) . isInterrupted ( ) ) ; while ( ! done ) ; } } SpinThread spin = new SpinThread ( ) ; spinner = new Thread ( spin ) ; spinner . start ( ) ; Thread . yield ( ) ; try { assertTrue ( " Non - Interrupted ▁ thread ▁ returned ▁ true " , ! spinner . isInterrupted ( ) ) ; spinner . interrupt ( ) ; assertTrue ( " Interrupted ▁ thread ▁ returned ▁ false " , spinner . isInterrupted ( ) ) ; spin . done = true ; } finally { spinner . interrupt ( ) ; spin . done = true ; } } public void test_join ( ) { SimpleThread simple ; try { st = new Thread ( simple = new SimpleThread ( 100 ) ) ; assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ " ) ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! st . isAlive ( ) ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { th . join ( ) ; } catch ( InterruptedException e ) { result = false ; } assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; } public void test_joinJ ( ) { SimpleThread simple ; try { st = new Thread ( simple = new SimpleThread ( 1000 ) , " SimpleThread12" ) ; assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( 10 ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ " ) ; } assertTrue ( " Join ▁ failed ▁ to ▁ timeout " , st . isAlive ( ) ) ; st . interrupt ( ) ; try { st = new Thread ( simple = new SimpleThread ( 100 ) , " SimpleThread13" ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( 1000 ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ : ▁ " + e . getMessage ( ) ) ; return ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! st . isAlive ( ) ) ; final Object lock = new Object ( ) ; final Thread main = Thread . currentThread ( ) ; Thread killer = new Thread ( new Runnable ( ) { public void run ( ) { try { synchronized ( lock ) { lock . notify ( ) ; } Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { return ; } main . interrupt ( ) ; } } ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { synchronized ( lock ) { killer . start ( ) ; lock . wait ( ) ; } th . join ( 200 ) ; } catch ( InterruptedException e ) { result = false ; } killer . interrupt ( ) ; assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; } public void test_joinJI ( ) throws Exception { SimpleThread simple ; st = new Thread ( simple = new SimpleThread ( 1000 ) , " Squawk1" ) ; assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } long firstRead = System . currentTimeMillis ( ) ; st . join ( 100 , 999999 ) ; long secondRead = System . currentTimeMillis ( ) ; assertTrue ( " Did ▁ not ▁ join ▁ by ▁ appropriate ▁ time : ▁ " + secondRead + " - " + firstRead + " = " + ( secondRead - firstRead ) , secondRead - firstRead <= 300 ) ; assertTrue ( " Joined ▁ thread ▁ is ▁ not ▁ alive " , st . isAlive ( ) ) ; st . interrupt ( ) ; final Object lock = new Object ( ) ; final Thread main = Thread . currentThread ( ) ; Thread killer = new Thread ( new Runnable ( ) { public void run ( ) { try { synchronized ( lock ) { lock . notify ( ) ; } Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { return ; } main . interrupt ( ) ; } } ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { synchronized ( lock ) { killer . start ( ) ; lock . wait ( ) ; } th . join ( 200 , 20 ) ; } catch ( InterruptedException e ) { result = false ; } killer . interrupt ( ) ; assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; } @ SuppressWarnings ( " deprecation " ) public void test_resume ( ) { int orgval ; ResSupThread t ; try { t = new ResSupThread ( Thread . currentThread ( ) ) ; synchronized ( t ) { ct = new Thread ( t , " Interrupt ▁ Test2" ) ; ct . start ( ) ; t . wait ( ) ; } ct . suspend ( ) ; Thread . sleep ( 500 ) ; orgval = t . getCheckVal ( ) ; Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ suspend ▁ thread " , orgval == t . getCheckVal ( ) ) ; ct . resume ( ) ; Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ resume ▁ thread " , orgval != t . getCheckVal ( ) ) ; ct . interrupt ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ occurred ▁ : ▁ " + e . getMessage ( ) ) ; } } public void test_run ( ) { class RunThread implements Runnable { boolean didThreadRun = false ; public void run ( ) { didThreadRun = true ; } } RunThread rt = new RunThread ( ) ; Thread t = new Thread ( rt ) ; try { t . start ( ) ; int count = 0 ; while ( ! rt . didThreadRun && count < 20 ) { Thread . sleep ( 100 ) ; count ++ ; } assertTrue ( " Thread ▁ did ▁ not ▁ run " , rt . didThreadRun ) ; t . join ( ) ; } catch ( InterruptedException e ) { assertTrue ( " Joined ▁ thread ▁ was ▁ interrupted " , true ) ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! t . isAlive ( ) ) ; } public void test_setDaemonZ ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread14" ) ; st . setDaemon ( true ) ; assertTrue ( " Failed ▁ to ▁ set ▁ thread ▁ as ▁ daemon ▁ thread " , st . isDaemon ( ) ) ; st . start ( ) ; } public void test_setNameLjava_lang_String ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread15" ) ; st . setName ( " Bogus ▁ Name " ) ; assertEquals ( " Failed ▁ to ▁ set ▁ thread ▁ name " , " Bogus ▁ Name " , st . getName ( ) ) ; try { st . setName ( null ) ; fail ( " Null ▁ should ▁ not ▁ be ▁ accepted ▁ as ▁ a ▁ valid ▁ name " ) ; } catch ( NullPointerException e ) { assertTrue ( " Null ▁ should ▁ not ▁ be ▁ accepted ▁ as ▁ a ▁ valid ▁ name " , true ) ; } st . start ( ) ; } public void test_setPriorityI ( ) { st = new Thread ( new SimpleThread ( 1 ) ) ; st . setPriority ( Thread . MAX_PRIORITY ) ; assertTrue ( " Failed ▁ to ▁ set ▁ priority " , st . getPriority ( ) == Thread . MAX_PRIORITY ) ; st . start ( ) ; } public void test_sleepJ ( ) { long stime = 0 , ftime = 0 ; try { stime = System . currentTimeMillis ( ) ; Thread . sleep ( 1000 ) ; ftime = System . currentTimeMillis ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ received " ) ; } assertTrue ( " Failed ▁ to ▁ sleep ▁ long ▁ enough " , ( ftime - stime ) >= 800 ) ; } public void test_sleepJI ( ) { long stime = 0 , ftime = 0 ; try { stime = System . currentTimeMillis ( ) ; Thread . sleep ( 1000 , 999999 ) ; ftime = System . currentTimeMillis ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ received " ) ; } long result = ftime - stime ; assertTrue ( " Failed ▁ to ▁ sleep ▁ long ▁ enough : ▁ " + result , result >= 900 && result <= 1100 ) ; } public void test_start ( ) { try { ResSupThread t = new ResSupThread ( Thread . currentThread ( ) ) ; synchronized ( t ) { ct = new Thread ( t , " Interrupt ▁ Test4" ) ; ct . start ( ) ; t . wait ( ) ; } assertTrue ( " Thread ▁ is ▁ not ▁ running1" , ct . isAlive ( ) ) ; int orgval = t . getCheckVal ( ) ; Thread . sleep ( 150 ) ; assertTrue ( " Thread ▁ is ▁ not ▁ running2" , orgval != t . getCheckVal ( ) ) ; ct . interrupt ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ occurred " ) ; } } @ SuppressWarnings ( " deprecation " ) public void test_stop ( ) { try { Runnable r = new ResSupThread ( null ) ; synchronized ( r ) { st = new Thread ( r , " Interupt ▁ Test5" ) ; st . start ( ) ; r . wait ( ) ; } } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ received " ) ; } st . stop ( ) ; try { st . join ( 10000 ) ; } catch ( InterruptedException e1 ) { st . interrupt ( ) ; fail ( " Failed ▁ to ▁ stopThread ▁ before ▁ 10000 ▁ timeout " ) ; } assertTrue ( " Failed ▁ to ▁ stopThread " , ! st . isAlive ( ) ) ; } @ SuppressWarnings ( " deprecation " ) public void test_stop_subtest0 ( ) { Thread t = new Thread ( " t " ) ; class MySecurityManager extends SecurityManager { public boolean intest = false ; @ Override public void checkAccess ( Thread t ) { if ( intest ) { fail ( " checkAccess ▁ called " ) ; } } @ Override public void checkPermission ( Permission permission ) { if ( permission . getName ( ) . equals ( " setSecurityManager " ) ) { return ; } super . checkPermission ( permission ) ; } } MySecurityManager sm = new MySecurityManager ( ) ; System . setSecurityManager ( sm ) ; try { sm . intest = true ; try { t . stop ( ) ; } catch ( SecurityException e ) { } sm . intest = false ; t . start ( ) ; try { t . join ( 2000 ) ; } catch ( InterruptedException e ) { } sm . intest = true ; try { t . stop ( ) ; } catch ( SecurityException e ) { } sm . intest = false ; } finally { System . setSecurityManager ( null ) ; } } @ SuppressWarnings ( " deprecation " ) public void test_stopLjava_lang_Throwable_subtest0 ( ) { Thread t = new Thread ( " t " ) ; class MySecurityManager extends SecurityManager { public boolean intest = false ; public boolean checkAccess = false ; @ Override public void checkAccess ( Thread t ) { if ( intest ) { checkAccess = true ; } } @ Override public void checkPermission ( Permission permission ) { if ( permission . getName ( ) . equals ( " setSecurityManager " ) ) { return ; } super . checkPermission ( permission ) ; } } MySecurityManager sm = new MySecurityManager ( ) ; System . setSecurityManager ( sm ) ; try { sm . intest = true ; try { t . stop ( new ThreadDeath ( ) ) ; } catch ( SecurityException e ) { } sm . intest = false ; assertTrue ( " no ▁ checkAccess ▁ 1" , sm . checkAccess ) ; t . start ( ) ; try { t . join ( 2000 ) ; } catch ( InterruptedException e ) { } sm . intest = true ; sm . checkAccess = false ; try { t . stop ( new ThreadDeath ( ) ) ; } catch ( SecurityException e ) { } assertTrue ( " no ▁ checkAccess ▁ 2" , sm . checkAccess ) ; sm . intest = false ; } finally { System . setSecurityManager ( null ) ; } } @ SuppressWarnings ( " deprecation " ) public void test_stopLjava_lang_Throwable ( ) { ResSupThread t = new ResSupThread ( Thread . currentThread ( ) ) ; synchronized ( t ) { st = new Thread ( t , " StopThread " ) ; st . setPriority ( Thread . MAX_PRIORITY ) ; st . start ( ) ; try { t . wait ( ) ; } catch ( InterruptedException e ) { } } try { st . stop ( new BogusException ( " Bogus " ) ) ; Thread . sleep ( 20000 ) ; } catch ( InterruptedException e ) { assertTrue ( " Stopped ▁ child ▁ with ▁ exception ▁ not ▁ alive " , st . isAlive ( ) ) ; st . interrupt ( ) ; return ; } st . interrupt ( ) ; fail ( " Stopped ▁ child ▁ did ▁ not ▁ throw ▁ exception " ) ; } @ SuppressWarnings ( " deprecation " ) public void test_suspend ( ) { int orgval ; ResSupThread t = new ResSupThread ( Thread . currentThread ( ) ) ; try { synchronized ( t ) { ct = new Thread ( t , " Interupt ▁ Test6" ) ; ct . start ( ) ; t . wait ( ) ; } ct . suspend ( ) ; Thread . sleep ( 500 ) ; orgval = t . getCheckVal ( ) ; Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ suspend ▁ thread " , orgval == t . getCheckVal ( ) ) ; ct . resume ( ) ; Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ resume ▁ thread " , orgval != t . getCheckVal ( ) ) ; ct . interrupt ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ occurred " ) ; } final Object notify = new Object ( ) ; Thread t1 = new Thread ( new Runnable ( ) { public void run ( ) { synchronized ( notify ) { notify . notify ( ) ; } Thread . currentThread ( ) . suspend ( ) ; } } ) ; try { synchronized ( notify ) { t1 . start ( ) ; notify . wait ( ) ; } Thread . sleep ( 500 ) ; assertTrue ( " Thread ▁ should ▁ be ▁ alive " , t1 . isAlive ( ) ) ; t1 . resume ( ) ; t1 . join ( ) ; } catch ( InterruptedException e ) { } } public void test_toString ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group5" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread17" ) ; final String stString = st . toString ( ) ; final String expected = " Thread [ SimpleThread17,5 , Test ▁ Group5 ] " ; assertTrue ( " Returned ▁ incorrect ▁ string : ▁ " + stString + " \t ( expecting ▁ : " + expected + " ) " , stString . equals ( expected ) ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; } public void test_getAllStackTraces ( ) { Map < Thread , StackTraceElement [ ] > stMap = Thread . getAllStackTraces ( ) ; assertNotNull ( stMap ) ; } public void test_get_setDefaultUncaughtExceptionHandler ( ) { class Handler implements UncaughtExceptionHandler { public void uncaughtException ( Thread thread , Throwable ex ) { } } final Handler handler = new Handler ( ) ; Thread . setDefaultUncaughtExceptionHandler ( handler ) ; assertSame ( handler , Thread . getDefaultUncaughtExceptionHandler ( ) ) ; Thread . setDefaultUncaughtExceptionHandler ( null ) ; assertNull ( Thread . getDefaultUncaughtExceptionHandler ( ) ) ; } public void test_getStackTrace ( ) { StackTraceElement [ ] stackTrace = Thread . currentThread ( ) . getStackTrace ( ) ; assertNotNull ( stackTrace ) ; stack_trace_loop : { for ( int i = 0 ; i < stackTrace . length ; i ++ ) { StackTraceElement e = stackTrace [ i ] ; if ( getClass ( ) . getName ( ) . equals ( e . getClassName ( ) ) ) { if ( " test _ getStackTrace " . equals ( e . getMethodName ( ) ) ) { break stack_trace_loop ; } } } fail ( " class ▁ and ▁ method ▁ not ▁ found ▁ in ▁ stack ▁ trace " ) ; } } public void test_getState ( ) { Thread . State state = Thread . currentThread ( ) . getState ( ) ; assertNotNull ( state ) ; assertEquals ( Thread . State . RUNNABLE , state ) ; } public void test_get_setUncaughtExceptionHandler ( ) { class Handler implements UncaughtExceptionHandler { public void uncaughtException ( Thread thread , Throwable ex ) { } } final Handler handler = new Handler ( ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( handler ) ; assertSame ( handler , Thread . currentThread ( ) . getUncaughtExceptionHandler ( ) ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( null ) ; } public void test_getId ( ) { assertTrue ( " current ▁ thread ' s ▁ ID ▁ is ▁ not ▁ positive " , Thread . currentThread ( ) . getId ( ) > 0 ) ; Map < Thread , StackTraceElement [ ] > stMap = Thread . getAllStackTraces ( ) ; for ( Thread thread : stMap . keySet ( ) ) { assertTrue ( " thread ' s ▁ ID ▁ is ▁ not ▁ positive : ▁ " + thread . getName ( ) , thread . getId ( ) > 0 ) ; } } @ Override protected void tearDown ( ) { try { if ( st != null ) st . interrupt ( ) ; } catch ( Exception e ) { } try { if ( spinner != null ) spinner . interrupt ( ) ; } catch ( Exception e ) { } try { if ( ct != null ) ct . interrupt ( ) ; } catch ( Exception e ) { } try { spinner = null ; st = null ; ct = null ; System . runFinalization ( ) ; } catch ( Exception e ) { } } } </DOCUMENT>
<DOCUMENT_ID="mstine/polyglot-osgi/tree/master/lib/osgi/felix/org.apache.felix.framework-1.8.1/src/main/java/org/apache/felix/framework/util/JarFileX.java"> package org . apache . felix . framework . util ; import java . io . File ; import java . io . IOException ; import java . util . jar . JarEntry ; import java . util . jar . JarFile ; import java . util . zip . ZipEntry ; public class JarFileX extends JarFile { public JarFileX ( File file ) throws IOException { super ( file ) ; } public JarFileX ( File file , boolean verify ) throws IOException { super ( file , verify ) ; } public JarFileX ( File file , boolean verify , int mode ) throws IOException { super ( file , verify , mode ) ; } public JarFileX ( String name ) throws IOException { super ( name ) ; } public JarFileX ( String name , boolean verify ) throws IOException { super ( name , verify ) ; } public ZipEntry getEntry ( String name ) { ZipEntry entry = super . getEntry ( name ) ; if ( ( entry != null ) && ( entry . getSize ( ) == 0 ) && ! entry . isDirectory ( ) ) { ZipEntry dirEntry = super . getEntry ( name + ' / ' ) ; if ( dirEntry != null ) { entry = dirEntry ; } } return entry ; } public JarEntry getJarEntry ( String name ) { JarEntry entry = super . getJarEntry ( name ) ; if ( ( entry != null ) && ( entry . getSize ( ) == 0 ) && ! entry . isDirectory ( ) ) { JarEntry dirEntry = super . getJarEntry ( name + ' / ' ) ; if ( dirEntry != null ) { entry = dirEntry ; } } return entry ; } } </DOCUMENT>
<DOCUMENT_ID="moosbusch/xbLIDO/tree/master/src/net/opengis/gml/GridCoverageDocument.java"> package net . opengis . gml ; public interface GridCoverageDocument extends net . opengis . gml . DiscreteCoverageDocument { public static final org . apache . xmlbeans . SchemaType type = ( org . apache . xmlbeans . SchemaType ) org . apache . xmlbeans . XmlBeans . typeSystemForClassLoader ( GridCoverageDocument . class . getClassLoader ( ) , " schemaorg _ apache _ xmlbeans . system . s6E28D279B6C224D74769DB8B98AF1665" ) . resolveHandle ( " gridcoveragea6fddoctype " ) ; net . opengis . gml . GridCoverageType getGridCoverage ( ) ; void setGridCoverage ( net . opengis . gml . GridCoverageType gridCoverage ) ; net . opengis . gml . GridCoverageType addNewGridCoverage ( ) ; public static final class Factory { public static net . opengis . gml . GridCoverageDocument newInstance ( ) { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . newInstance ( type , null ) ; } public static net . opengis . gml . GridCoverageDocument newInstance ( org . apache . xmlbeans . XmlOptions options ) { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . newInstance ( type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . lang . String xmlAsString ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( xmlAsString , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . lang . String xmlAsString , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( xmlAsString , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . File file ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( file , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . File file , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( file , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . net . URL u ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( u , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . net . URL u , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( u , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . InputStream is ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( is , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . InputStream is , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( is , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . Reader r ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( r , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . Reader r , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( r , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( javax . xml . stream . XMLStreamReader sr ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( sr , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( javax . xml . stream . XMLStreamReader sr , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( sr , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( org . w3c . dom . Node node ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( node , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( org . w3c . dom . Node node , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( node , type , options ) ; } @ Deprecated public static net . opengis . gml . GridCoverageDocument parse ( org . apache . xmlbeans . xml . stream . XMLInputStream xis ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( xis , type , null ) ; } @ Deprecated public static net . opengis . gml . GridCoverageDocument parse ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( xis , type , options ) ; } @ Deprecated public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , null ) ; } @ Deprecated public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , options ) ; } private Factory ( ) { } } } </DOCUMENT>
<DOCUMENT_ID="innerverse/libjitsi/tree/master/src/org/jitsi/util/xml/DOMElementWriter.java"> package org . jitsi . util . xml ; import java . io . * ; import org . w3c . dom . * ; public class DOMElementWriter { private static final String lSep = System . getProperty ( " line . separator " ) ; public static String decodeName ( String name ) { int length = name . length ( ) ; StringBuilder value = new StringBuilder ( length ) ; for ( int i = 0 ; i < length ; ) { int start = name . indexOf ( ' _ ' , i ) ; if ( start == - 1 ) { value . append ( name , i , length ) ; break ; } if ( i != start ) value . append ( name , i , start ) ; int end = start + 6 ; if ( ( end < length ) && ( name . charAt ( start + 1 ) == ' x ' ) && ( name . charAt ( end ) == ' _ ' ) && isHexDigit ( name . charAt ( start + 2 ) ) && isHexDigit ( name . charAt ( start + 3 ) ) && isHexDigit ( name . charAt ( start + 4 ) ) && isHexDigit ( name . charAt ( start + 5 ) ) ) { char c = ( char ) Integer . parseInt ( name . substring ( start + 2 , end ) , 16 ) ; if ( ( start == 0 ) ? ! isNameStartChar ( c ) : ! isNameChar ( c ) ) { value . append ( c ) ; i = end + 1 ; continue ; } } value . append ( name . charAt ( start ) ) ; i = start + 1 ; } return value . toString ( ) ; } public static String encodeName ( String value ) { int length = value . length ( ) ; StringBuilder name = new StringBuilder ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char c = value . charAt ( i ) ; if ( i == 0 ) { if ( isNameStartChar ( c ) ) { name . append ( c ) ; continue ; } } else if ( isNameChar ( c ) ) { name . append ( c ) ; continue ; } name . append ( " _ x " ) ; if ( c <= 0x000F ) name . append ( "000" ) ; else if ( c <= 0x00FF ) name . append ( "00" ) ; else if ( c <= 0x0FFF ) name . append ( '0' ) ; name . append ( Integer . toHexString ( c ) . toUpperCase ( ) ) ; name . append ( ' _ ' ) ; } return name . toString ( ) ; } private static boolean isHexDigit ( char c ) { return ( ( '0' <= c ) && ( c <= '9' ) ) || ( ( ' A ' <= c ) && ( c <= ' F ' ) ) || ( ( ' a ' <= c ) && ( c <= ' f ' ) ) ; } private static boolean isNameChar ( char c ) { if ( isNameStartChar ( c ) ) return true ; else if ( ( c == ' - ' ) || ( c == ' . ' ) ) return true ; else if ( ( '0' <= c ) && ( c <= '9' ) ) return true ; else if ( c == 0xB7 ) return true ; else if ( c < 0x0300 ) return false ; else if ( c <= 0x036F ) return true ; else if ( c < 0x203F ) return false ; else if ( c <= 0x2040 ) return true ; else return false ; } private static boolean isNameStartChar ( char c ) { if ( ( c == ' : ' ) || ( c == ' _ ' ) ) return true ; else if ( ( ' A ' <= c ) && ( c <= ' Z ' ) ) return true ; else if ( ( ' a ' <= c ) && ( c <= ' z ' ) ) return true ; else if ( c < 0xC0 ) return false ; else if ( c <= 0xD6 ) return true ; else if ( c < 0xD8 ) return false ; else if ( c <= 0xF6 ) return true ; else if ( c < 0xF8 ) return false ; else if ( c <= 0x2FF ) return true ; else if ( c < 0x370 ) return false ; else if ( c <= 0x37D ) return true ; else if ( c < 0x37F ) return false ; else if ( c <= 0x1FFF ) return true ; else if ( c < 0x200C ) return false ; else if ( c <= 0x200D ) return true ; else if ( c < 0x2070 ) return false ; else if ( c <= 0x218F ) return true ; else if ( c < 0x2C00 ) return false ; else if ( c <= 0x2FEF ) return true ; else if ( c < 0x3001 ) return false ; else if ( c <= 0xD7FF ) return true ; else if ( c < 0xF900 ) return false ; else if ( c <= 0xFDCF ) return true ; else if ( c < 0xFDF0 ) return false ; else if ( c <= 0xFFFD ) return true ; else return false ; } protected String [ ] knownEntities = { " gt " , " amp " , " lt " , " apos " , " quot " } ; public void write ( Element root , OutputStream out ) throws IOException { Writer wri = new OutputStreamWriter ( out , " UTF - 8" ) ; wri . write ( " < ? xml ▁ version = \ " 1.0\ " ▁ encoding = \ " UTF - 8\ " ? > " + lSep ) ; write ( root , wri , 0 , " ▁ ▁ " ) ; wri . flush ( ) ; } public void write ( Node element , Writer out , int indent , String indentWith ) throws IOException { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } if ( element . getNodeType ( ) == Node . COMMENT_NODE ) { out . write ( " < ! - - " ) ; out . write ( encode ( element . getNodeValue ( ) ) ) ; out . write ( " - - > " ) ; } else { out . write ( " < " ) ; out . write ( ( ( Element ) element ) . getTagName ( ) ) ; NamedNodeMap attrs = element . getAttributes ( ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; out . write ( " ▁ " ) ; out . write ( attr . getName ( ) ) ; out . write ( " = \ " " ) ; out . write ( encode ( attr . getValue ( ) ) ) ; out . write ( " \ " " ) ; } out . write ( " > " ) ; } boolean hasChildren = false ; NodeList children = element . getChildNodes ( ) ; for ( int i = 0 ; element . hasChildNodes ( ) && i < children . getLength ( ) ; i ++ ) { Node child = children . item ( i ) ; switch ( child . getNodeType ( ) ) { case Node . ELEMENT_NODE : case Node . COMMENT_NODE : if ( ! hasChildren ) { out . write ( lSep ) ; hasChildren = true ; } write ( child , out , indent + 1 , indentWith ) ; break ; case Node . TEXT_NODE : if ( child . getNodeValue ( ) != null && ( child . getNodeValue ( ) . indexOf ( " \n " ) == - 1 || child . getNodeValue ( ) . trim ( ) . length ( ) != 0 ) ) out . write ( encode ( child . getNodeValue ( ) ) ) ; break ; case Node . CDATA_SECTION_NODE : out . write ( " < ! [ CDATA [ " ) ; out . write ( encodedata ( ( ( Text ) child ) . getData ( ) ) ) ; out . write ( " ] ] > " ) ; break ; case Node . ENTITY_REFERENCE_NODE : out . write ( ' & ' ) ; out . write ( child . getNodeName ( ) ) ; out . write ( ' ; ' ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : out . write ( " < ? " ) ; out . write ( child . getNodeName ( ) ) ; String data = child . getNodeValue ( ) ; if ( data != null && data . length ( ) > 0 ) { out . write ( ' ▁ ' ) ; out . write ( data ) ; } out . write ( " ? > " ) ; break ; } } if ( hasChildren ) { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } } if ( element . getNodeType ( ) == Node . ELEMENT_NODE ) { out . write ( " < / " ) ; out . write ( ( ( Element ) element ) . getTagName ( ) ) ; out . write ( " > " ) ; } out . write ( lSep ) ; out . flush ( ) ; } public String encode ( String value ) { StringBuffer sb = new StringBuffer ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = value . charAt ( i ) ; switch ( c ) { case ' < ' : sb . append ( " & lt ; " ) ; break ; case ' > ' : sb . append ( " & gt ; " ) ; break ; case ' \ ' ' : sb . append ( " & apos ; " ) ; break ; case ' \ " ' : sb . append ( " & quot ; " ) ; break ; case ' & ' : int nextSemi = value . indexOf ( " ; " , i ) ; if ( ( nextSemi < 0 ) || ! isReference ( value . substring ( i , nextSemi + 1 ) ) ) sb . append ( " & amp ; " ) ; else sb . append ( ' & ' ) ; break ; default : if ( isLegalCharacter ( c ) ) sb . append ( c ) ; break ; } } return sb . substring ( 0 ) ; } public String encodedata ( final String value ) { StringBuffer sb = new StringBuffer ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; ++ i ) { char c = value . charAt ( i ) ; if ( isLegalCharacter ( c ) ) { sb . append ( c ) ; } } String result = sb . substring ( 0 ) ; int cdEnd = result . indexOf ( " ] ] > " ) ; while ( cdEnd != - 1 ) { sb . setLength ( cdEnd ) ; sb . append ( " & # x5d ; & # x5d ; & gt ; " ) . append ( result . substring ( cdEnd + 3 ) ) ; result = sb . substring ( 0 ) ; cdEnd = result . indexOf ( " ] ] > " ) ; } return result ; } public boolean isReference ( String ent ) { if ( ! ( ent . charAt ( 0 ) == ' & ' ) || ! ent . endsWith ( " ; " ) ) return false ; if ( ent . charAt ( 1 ) == ' # ' ) { if ( ent . charAt ( 2 ) == ' x ' ) { try { Integer . parseInt ( ent . substring ( 3 , ent . length ( ) - 1 ) , 16 ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } else { try { Integer . parseInt ( ent . substring ( 2 , ent . length ( ) - 1 ) ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } } String name = ent . substring ( 1 , ent . length ( ) - 1 ) ; for ( int i = 0 ; i < knownEntities . length ; i ++ ) { if ( name . equals ( knownEntities [ i ] ) ) { return true ; } } return false ; } public boolean isLegalCharacter ( char c ) { if ( c == 0x9 || c == 0xA || c == 0xD ) { return true ; } else if ( c < 0x20 ) { return false ; } else if ( c <= 0xD7FF ) { return true ; } else if ( c < 0xE000 ) { return false ; } else if ( c <= 0xFFFD ) { return true ; } return false ; } } </DOCUMENT>
<DOCUMENT_ID="nezuvian/Library-webapp/tree/master/src/test/java/top2lz/libapp/web/rest/TestUtil.java"> package top2lz . libapp . web . rest ; import com . fasterxml . jackson . annotation . JsonInclude ; import com . fasterxml . jackson . databind . ObjectMapper ; import com . fasterxml . jackson . datatype . joda . JodaModule ; import com . fasterxml . jackson . datatype . joda . ser . DateTimeSerializer ; import com . fasterxml . jackson . datatype . joda . ser . JacksonJodaFormat ; import org . joda . time . DateTime ; import org . springframework . format . annotation . DateTimeFormat ; import org . springframework . format . datetime . joda . DateTimeFormatterFactory ; import org . springframework . http . MediaType ; import java . io . IOException ; import java . nio . charset . Charset ; public class TestUtil { public static final MediaType APPLICATION_JSON_UTF8 = new MediaType ( MediaType . APPLICATION_JSON . getType ( ) , MediaType . APPLICATION_JSON . getSubtype ( ) , Charset . forName ( " utf8" ) ) ; public static byte [ ] convertObjectToJsonBytes ( Object object ) throws IOException { ObjectMapper mapper = new ObjectMapper ( ) ; mapper . setSerializationInclusion ( JsonInclude . Include . NON_NULL ) ; JodaModule module = new JodaModule ( ) ; DateTimeFormatterFactory formatterFactory = new DateTimeFormatterFactory ( ) ; formatterFactory . setIso ( DateTimeFormat . ISO . DATE ) ; module . addSerializer ( DateTime . class , new DateTimeSerializer ( new JacksonJodaFormat ( formatterFactory . createDateTimeFormatter ( ) . withZoneUTC ( ) ) ) ) ; mapper . registerModule ( module ) ; return mapper . writeValueAsBytes ( object ) ; } } </DOCUMENT>
<DOCUMENT_ID="skofra0/pentaho-kettle/tree/master/engine/src/org/pentaho/di/job/JobEntryListener.java"> package org . pentaho . di . job ; import org . pentaho . di . core . Result ; import org . pentaho . di . job . entry . JobEntryCopy ; import org . pentaho . di . job . entry . JobEntryInterface ; public interface JobEntryListener { public void beforeExecution ( Job job , JobEntryCopy jobEntryCopy , JobEntryInterface jobEntryInterface ) ; public void afterExecution ( Job job , JobEntryCopy jobEntryCopy , JobEntryInterface jobEntryInterface , Result result ) ; } </DOCUMENT>
<DOCUMENT_ID="idea4bsd/idea4bsd/tree/master/java/java-psi-api/src/com/intellij/psi/PsiVariable.java"> package com . intellij . psi ; import com . intellij . pom . PomRenameableTarget ; import com . intellij . util . IncorrectOperationException ; import org . jetbrains . annotations . NotNull ; import org . jetbrains . annotations . Nullable ; import org . jetbrains . annotations . NonNls ; public interface PsiVariable extends PsiModifierListOwner , PsiNameIdentifierOwner , PsiTarget , PomRenameableTarget < PsiElement > { @ NotNull PsiType getType ( ) ; @ Nullable PsiTypeElement getTypeElement ( ) ; @ Nullable PsiExpression getInitializer ( ) ; boolean hasInitializer ( ) ; void normalizeDeclaration ( ) throws IncorrectOperationException ; @ Nullable Object computeConstantValue ( ) ; @ Override @ Nullable PsiIdentifier getNameIdentifier ( ) ; @ Override PsiElement setName ( @ NonNls @ NotNull String name ) throws IncorrectOperationException ; } </DOCUMENT>
<DOCUMENT_ID="huangbop/takeout/tree/master/app/src/main/java/com/huangbop/takeout/IndexActivity.java"> package com . huangbop . takeout ; import android . app . Activity ; import android . app . AlertDialog ; import android . content . DialogInterface ; import android . content . Intent ; import android . os . Bundle ; import android . view . KeyEvent ; import android . view . View ; import android . widget . Button ; import android . widget . Toast ; public class IndexActivity extends Activity { private Button btnIndex0 ; private Button btnIndex1 ; private Button btnIndex2 ; private ButtonListener listener ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_index ) ; listener = new ButtonListener ( ) ; findButtons ( ) ; setClickListener ( ) ; } private long exitTime = 0 ; @ Override public boolean onKeyDown ( int keyCode , KeyEvent event ) { if ( keyCode == KeyEvent . KEYCODE_BACK && event . getAction ( ) == KeyEvent . ACTION_DOWN ) { if ( ( System . currentTimeMillis ( ) - exitTime ) > 2000 ) { Toast . makeText ( this , " Press ▁ again ▁ to ▁ exit . " , Toast . LENGTH_SHORT ) . show ( ) ; exitTime = System . currentTimeMillis ( ) ; } else { finish ( ) ; System . exit ( 0 ) ; } return true ; } return super . onKeyDown ( keyCode , event ) ; } private void setClickListener ( ) { btnIndex0 . setOnClickListener ( listener ) ; btnIndex1 . setOnClickListener ( listener ) ; btnIndex2 . setOnClickListener ( listener ) ; } private void findButtons ( ) { btnIndex0 = ( Button ) findViewById ( R . id . btnIndex0 ) ; btnIndex1 = ( Button ) findViewById ( R . id . btnIndex1 ) ; btnIndex2 = ( Button ) findViewById ( R . id . btnIndex2 ) ; } private class ButtonListener implements View . OnClickListener { @ Override public void onClick ( View v ) { switch ( v . getId ( ) ) { case R . id . btnIndex0 : Intent intent0 = new Intent ( IndexActivity . this , MainActivity . class ) ; startActivity ( intent0 ) ; break ; case R . id . btnIndex1 : Intent intent1 = new Intent ( IndexActivity . this , SecondActivity . class ) ; startActivity ( intent1 ) ; break ; case R . id . btnIndex2 : Intent intent2 = new Intent ( IndexActivity . this , LifeCycle . class ) ; startActivity ( intent2 ) ; break ; } } } } </DOCUMENT>
<DOCUMENT_ID="HasanAliKaraca/Telegram/tree/master/TMessagesProj/src/main/java/org/telegram/ui/Adapters/MentionsAdapter.java"> package org . telegram . ui . Adapters ; import android . content . Context ; import android . view . View ; import android . view . ViewGroup ; import org . telegram . android . MessageObject ; import org . telegram . android . MessagesController ; import org . telegram . android . UserObject ; import org . telegram . messenger . TLRPC ; import org . telegram . ui . Cells . MentionCell ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; public class MentionsAdapter extends BaseSearchAdapter { public interface MentionsAdapterDelegate { void needChangePanelVisibility ( boolean show ) ; } private Context mContext ; private TLRPC . ChatParticipants info ; private ArrayList < TLRPC . User > searchResultUsernames ; private ArrayList < String > searchResultHashtags ; private ArrayList < String > searchResultCommands ; private ArrayList < String > searchResultCommandsHelp ; private ArrayList < TLRPC . User > searchResultCommandsUsers ; private MentionsAdapterDelegate delegate ; private HashMap < Integer , TLRPC . BotInfo > botInfo ; private int resultStartPosition ; private int resultLength ; private String lastText ; private int lastPosition ; private ArrayList < MessageObject > messages ; private boolean needUsernames = true ; private boolean isDarkTheme ; private int botsCount ; public MentionsAdapter ( Context context , boolean isDarkTheme , MentionsAdapterDelegate delegate ) { mContext = context ; this . delegate = delegate ; this . isDarkTheme = isDarkTheme ; } public void setChatInfo ( TLRPC . ChatParticipants chatParticipants ) { info = chatParticipants ; if ( lastText != null ) { searchUsernameOrHashtag ( lastText , lastPosition , messages ) ; } } public void setNeedUsernames ( boolean value ) { needUsernames = value ; } public void setBotInfo ( HashMap < Integer , TLRPC . BotInfo > info ) { botInfo = info ; } public void setBotsCount ( int count ) { botsCount = count ; } @ Override public void clearRecentHashtags ( ) { super . clearRecentHashtags ( ) ; searchResultHashtags . clear ( ) ; notifyDataSetChanged ( ) ; if ( delegate != null ) { delegate . needChangePanelVisibility ( false ) ; } } @ Override protected void setHashtags ( ArrayList < HashtagObject > arrayList , HashMap < String , HashtagObject > hashMap ) { super . setHashtags ( arrayList , hashMap ) ; if ( lastText != null ) { searchUsernameOrHashtag ( lastText , lastPosition , messages ) ; } } public void searchUsernameOrHashtag ( String text , int position , ArrayList < MessageObject > messageObjects ) { if ( text == null || text . length ( ) == 0 ) { delegate . needChangePanelVisibility ( false ) ; lastText = null ; return ; } int searchPostion = position ; if ( text . length ( ) > 0 ) { searchPostion -- ; } lastText = null ; StringBuilder result = new StringBuilder ( ) ; int foundType = - 1 ; boolean hasIllegalUsernameCharacters = false ; for ( int a = searchPostion ; a >= 0 ; a -- ) { if ( a >= text . length ( ) ) { continue ; } char ch = text . charAt ( a ) ; if ( a == 0 || text . charAt ( a - 1 ) == ' ▁ ' || text . charAt ( a - 1 ) == ' \n ' ) { if ( needUsernames && ch == ' @ ' ) { if ( hasIllegalUsernameCharacters ) { delegate . needChangePanelVisibility ( false ) ; return ; } if ( info == null ) { lastText = text ; lastPosition = position ; messages = messageObjects ; delegate . needChangePanelVisibility ( false ) ; return ; } foundType = 0 ; resultStartPosition = a ; resultLength = result . length ( ) + 1 ; break ; } else if ( ch == ' # ' ) { if ( ! hashtagsLoadedFromDb ) { loadRecentHashtags ( ) ; lastText = text ; lastPosition = position ; messages = messageObjects ; delegate . needChangePanelVisibility ( false ) ; return ; } foundType = 1 ; resultStartPosition = a ; resultLength = result . length ( ) + 1 ; result . insert ( 0 , ch ) ; break ; } else if ( a == 0 && botInfo != null && ch == ' / ' ) { foundType = 2 ; resultStartPosition = a ; resultLength = result . length ( ) + 1 ; break ; } } if ( ! ( ch >= '0' && ch <= '9' || ch >= ' a ' && ch <= ' z ' || ch >= ' A ' && ch <= ' Z ' || ch == ' _ ' ) ) { hasIllegalUsernameCharacters = true ; } result . insert ( 0 , ch ) ; } if ( foundType == - 1 ) { delegate . needChangePanelVisibility ( false ) ; return ; } if ( foundType == 0 ) { final ArrayList < Integer > users = new ArrayList < > ( ) ; for ( int a = 0 ; a < Math . min ( 100 , messageObjects . size ( ) ) ; a ++ ) { int from_id = messageObjects . get ( a ) . messageOwner . from_id ; if ( ! users . contains ( from_id ) ) { users . add ( from_id ) ; } } String usernameString = result . toString ( ) . toLowerCase ( ) ; ArrayList < TLRPC . User > newResult = new ArrayList < > ( ) ; for ( TLRPC . TL_chatParticipant chatParticipant : info . participants ) { TLRPC . User user = MessagesController . getInstance ( ) . getUser ( chatParticipant . user_id ) ; if ( user == null || UserObject . isUserSelf ( user ) ) { continue ; } if ( user . username != null && user . username . length ( ) > 0 && ( usernameString . length ( ) > 0 && user . username . toLowerCase ( ) . startsWith ( usernameString ) || usernameString . length ( ) == 0 ) ) { newResult . add ( user ) ; } } searchResultHashtags = null ; searchResultCommands = null ; searchResultCommandsHelp = null ; searchResultCommandsUsers = null ; searchResultUsernames = newResult ; Collections . sort ( searchResultUsernames , new Comparator < TLRPC . User > ( ) { @ Override public int compare ( TLRPC . User lhs , TLRPC . User rhs ) { int lhsNum = users . indexOf ( lhs . id ) ; int rhsNum = users . indexOf ( rhs . id ) ; if ( lhsNum != - 1 && rhsNum != - 1 ) { return lhsNum < rhsNum ? - 1 : ( lhsNum == rhsNum ? 0 : 1 ) ; } else if ( lhsNum != - 1 && rhsNum == - 1 ) { return - 1 ; } else if ( lhsNum == - 1 && rhsNum != - 1 ) { return 1 ; } return 0 ; } } ) ; notifyDataSetChanged ( ) ; delegate . needChangePanelVisibility ( ! newResult . isEmpty ( ) ) ; } else if ( foundType == 1 ) { ArrayList < String > newResult = new ArrayList < > ( ) ; String hashtagString = result . toString ( ) . toLowerCase ( ) ; for ( HashtagObject hashtagObject : hashtags ) { if ( hashtagObject != null && hashtagObject . hashtag != null && hashtagObject . hashtag . startsWith ( hashtagString ) ) { newResult . add ( hashtagObject . hashtag ) ; } } searchResultHashtags = newResult ; searchResultUsernames = null ; searchResultCommands = null ; searchResultCommandsHelp = null ; searchResultCommandsUsers = null ; notifyDataSetChanged ( ) ; delegate . needChangePanelVisibility ( ! newResult . isEmpty ( ) ) ; } else if ( foundType == 2 ) { ArrayList < String > newResult = new ArrayList < > ( ) ; ArrayList < String > newResultHelp = new ArrayList < > ( ) ; ArrayList < TLRPC . User > newResultUsers = new ArrayList < > ( ) ; String command = result . toString ( ) . toLowerCase ( ) ; for ( HashMap . Entry < Integer , TLRPC . BotInfo > entry : botInfo . entrySet ( ) ) { for ( TLRPC . TL_botCommand botCommand : entry . getValue ( ) . commands ) { if ( botCommand != null && botCommand . command != null && botCommand . command . startsWith ( command ) ) { newResult . add ( " / " + botCommand . command ) ; newResultHelp . add ( botCommand . description ) ; newResultUsers . add ( MessagesController . getInstance ( ) . getUser ( entry . getValue ( ) . user_id ) ) ; } } } searchResultHashtags = null ; searchResultUsernames = null ; searchResultCommands = newResult ; searchResultCommandsHelp = newResultHelp ; searchResultCommandsUsers = newResultUsers ; notifyDataSetChanged ( ) ; delegate . needChangePanelVisibility ( ! newResult . isEmpty ( ) ) ; } } public int getResultStartPosition ( ) { return resultStartPosition ; } public int getResultLength ( ) { return resultLength ; } @ Override public int getViewTypeCount ( ) { return 1 ; } @ Override public int getCount ( ) { if ( searchResultUsernames != null ) { return searchResultUsernames . size ( ) ; } else if ( searchResultHashtags != null ) { return searchResultHashtags . size ( ) ; } else if ( searchResultCommands != null ) { return searchResultCommands . size ( ) ; } return 0 ; } @ Override public boolean isEmpty ( ) { if ( searchResultUsernames != null ) { return searchResultUsernames . isEmpty ( ) ; } else if ( searchResultHashtags != null ) { return searchResultHashtags . isEmpty ( ) ; } else if ( searchResultCommands != null ) { return searchResultCommands . isEmpty ( ) ; } return true ; } @ Override public int getItemViewType ( int position ) { return 0 ; } @ Override public boolean hasStableIds ( ) { return true ; } @ Override public boolean areAllItemsEnabled ( ) { return true ; } @ Override public boolean isEnabled ( int position ) { return true ; } @ Override public Object getItem ( int i ) { if ( searchResultUsernames != null ) { if ( i < 0 || i >= searchResultUsernames . size ( ) ) { return null ; } return searchResultUsernames . get ( i ) ; } else if ( searchResultHashtags != null ) { if ( i < 0 || i >= searchResultHashtags . size ( ) ) { return null ; } return searchResultHashtags . get ( i ) ; } else if ( searchResultCommands != null ) { if ( i < 0 || i >= searchResultCommands . size ( ) ) { return null ; } if ( searchResultCommandsUsers != null && botsCount != 1 ) { return String . format ( " % s @ % s " , searchResultCommands . get ( i ) , searchResultCommandsUsers . get ( i ) . username ) ; } return searchResultCommands . get ( i ) ; } return null ; } public boolean isLongClickEnabled ( ) { return searchResultHashtags != null ; } public boolean isBotCommands ( ) { return searchResultCommands != null ; } @ Override public View getView ( int i , View view , ViewGroup viewGroup ) { if ( view == null ) { view = new MentionCell ( mContext ) ; ( ( MentionCell ) view ) . setIsDarkTheme ( isDarkTheme ) ; } if ( searchResultUsernames != null ) { ( ( MentionCell ) view ) . setUser ( searchResultUsernames . get ( i ) ) ; } else if ( searchResultHashtags != null ) { ( ( MentionCell ) view ) . setText ( searchResultHashtags . get ( i ) ) ; } else if ( searchResultCommands != null ) { ( ( MentionCell ) view ) . setBotCommand ( searchResultCommands . get ( i ) , searchResultCommandsHelp . get ( i ) , searchResultCommandsUsers . get ( i ) ) ; } return view ; } } </DOCUMENT>
<DOCUMENT_ID="weebl2000/modeshape/tree/master/modeshape-jcr/src/main/java/org/modeshape/jcr/ModeShape.java"> package org . modeshape . jcr ; import java . io . IOException ; import java . io . InputStream ; import java . util . Properties ; import org . modeshape . common . collection . UnmodifiableProperties ; import org . modeshape . common . logging . Logger ; public final class ModeShape { private static final Properties bundleProperties = loadBundleProperties ( ) ; private static Properties loadBundleProperties ( ) { InputStream stream = null ; try { stream = JcrRepository . class . getClassLoader ( ) . getResourceAsStream ( " org / modeshape / jcr / repository . properties " ) ; assert stream != null ; Properties props = new Properties ( ) ; props . load ( stream ) ; return new UnmodifiableProperties ( props ) ; } catch ( IOException e ) { throw new IllegalStateException ( JcrI18n . failedToReadPropertiesFromManifest . text ( e . getLocalizedMessage ( ) ) , e ) ; } finally { if ( stream != null ) { try { stream . close ( ) ; } catch ( IOException e ) { } finally { stream = null ; } } } } static { Logger . getLogger ( JcrRepository . class ) . info ( JcrI18n . initializing , getName ( ) , getVersion ( ) ) ; } public static final String getName ( ) { return bundleProperties . getProperty ( " name " ) ; } public static final String getVendor ( ) { return bundleProperties . getProperty ( " vendor " ) ; } public static final String getUrl ( ) { return bundleProperties . getProperty ( " url " ) ; } public static final String getVersion ( ) { return bundleProperties . getProperty ( " version " ) ; } } </DOCUMENT>
<DOCUMENT_ID="Maccimo/intellij-community/tree/master/java/java-tests/testData/codeInsight/daemonCodeAnalyzer/quickFix/explicit2var/beforeAnonymous.java"> class MyTest { private void m ( ) { Ru < caret > nnable r = new Runnable ( ) { @ Override public void run ( ) { } } ; } } </DOCUMENT>
<DOCUMENT_ID="telerik/platform-friends-android/tree/master/Friends/facebook/src/main/java/com/facebook/internal/ImageResponseCache.java"> package com . facebook . internal ; import android . content . Context ; import android . util . Log ; import com . facebook . LoggingBehavior ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . HttpURLConnection ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; class ImageResponseCache { static final String TAG = ImageResponseCache . class . getSimpleName ( ) ; private volatile static FileLruCache imageCache ; synchronized static FileLruCache getCache ( Context context ) throws IOException { if ( imageCache == null ) { imageCache = new FileLruCache ( context . getApplicationContext ( ) , TAG , new FileLruCache . Limits ( ) ) ; } return imageCache ; } static InputStream getCachedImageStream ( URI url , Context context ) { InputStream imageStream = null ; if ( url != null ) { if ( isCDNURL ( url ) ) { try { FileLruCache cache = getCache ( context ) ; imageStream = cache . get ( url . toString ( ) ) ; } catch ( IOException e ) { Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , e . toString ( ) ) ; } } } return imageStream ; } static InputStream interceptAndCacheImageStream ( Context context , HttpURLConnection connection ) throws IOException { InputStream stream = null ; if ( connection . getResponseCode ( ) == HttpURLConnection . HTTP_OK ) { URL url = connection . getURL ( ) ; stream = connection . getInputStream ( ) ; try { if ( isCDNURL ( url . toURI ( ) ) ) { FileLruCache cache = getCache ( context ) ; stream = cache . interceptAndPut ( url . toString ( ) , new BufferedHttpInputStream ( stream , connection ) ) ; } } catch ( IOException e ) { } catch ( URISyntaxException e ) { } } return stream ; } private static boolean isCDNURL ( URI url ) { if ( url != null ) { String uriHost = url . getHost ( ) ; if ( uriHost . endsWith ( " fbcdn . net " ) ) { return true ; } if ( uriHost . startsWith ( " fbcdn " ) && uriHost . endsWith ( " akamaihd . net " ) ) { return true ; } } return false ; } static void clearCache ( Context context ) { try { getCache ( context ) . clearCache ( ) ; } catch ( IOException e ) { Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , " clearCache ▁ failed ▁ " + e . getMessage ( ) ) ; } } private static class BufferedHttpInputStream extends BufferedInputStream { HttpURLConnection connection ; BufferedHttpInputStream ( InputStream stream , HttpURLConnection connection ) { super ( stream , Utility . DEFAULT_STREAM_BUFFER_SIZE ) ; this . connection = connection ; } @ Override public void close ( ) throws IOException { super . close ( ) ; Utility . disconnectQuietly ( connection ) ; } } } </DOCUMENT>
<DOCUMENT_ID="13366348079/Dubbo/tree/master/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/BroadcastCluster.java"> package com . alibaba . dubbo . rpc . cluster . support ; import com . alibaba . dubbo . rpc . Invoker ; import com . alibaba . dubbo . rpc . RpcException ; import com . alibaba . dubbo . rpc . cluster . Cluster ; import com . alibaba . dubbo . rpc . cluster . Directory ; public class BroadcastCluster implements Cluster { public < T > Invoker < T > join ( Directory < T > directory ) throws RpcException { return new BroadcastClusterInvoker < T > ( directory ) ; } } </DOCUMENT>
<DOCUMENT_ID="lumenrobot/relex-id/tree/master/core/src/main/java/id/ac/itb/ee/lskk/relexid/core/PartOfSpeech.java"> package id . ac . itb . ee . lskk . relexid . core ; import java . util . Locale ; import java . util . Map ; import javax . xml . namespace . QName ; import org . eclipse . emf . ecore . EObject ; public interface PartOfSpeech extends EObject { String getLiteral ( ) ; void setLiteral ( String value ) ; QName getResource ( ) ; void setResource ( QName value ) ; QName getWord ( ) ; void setWord ( QName value ) ; String getName ( ) ; void setName ( String value ) ; GeneratedLiteral generate ( Locale locale , Map < String , String > dict , Translator translator ) ; } </DOCUMENT>
<DOCUMENT_ID="bobocop/gsn35/tree/master/src/endymion/alarm/senders/GSNAlarmSender.java"> package endymion . alarm . senders ; import endymion . exception . EndymionException ; public abstract class GSNAlarmSender { public abstract void setSendParameters ( String ... parameters ) throws EndymionException ; public abstract void sendAlarm ( String subjectLine , String alarmMessage ) throws EndymionException ; } </DOCUMENT>
<DOCUMENT_ID="iLoop2/openmrs-core/tree/master/api/src/test/java/org/openmrs/PersonAttributeTest.java"> package org . openmrs ; import java . util . Date ; import org . junit . Assert ; import org . junit . Test ; import org . openmrs . api . context . Context ; import org . openmrs . test . BaseContextSensitiveTest ; import org . openmrs . test . Verifies ; public class PersonAttributeTest extends BaseContextSensitiveTest { @ Test @ Verifies ( value = " should ▁ return ▁ toString ▁ of ▁ hydrated ▁ value " , method = " toString ( ) " ) public void toString_shouldReturnToStringOfHydratedValue ( ) throws Exception { PersonAttributeType type = Context . getPersonService ( ) . getPersonAttributeType ( 8 ) ; PersonAttribute attr = new PersonAttribute ( type , "6" ) ; Assert . assertEquals ( " MARRIED " , attr . toString ( ) ) ; } @ Test @ Verifies ( value = " should ▁ return ▁ negative ▁ if ▁ other ▁ attribute ▁ is ▁ voided " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldReturnNegativeIfOtherAttributeIsVoided ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; PersonAttribute other = new PersonAttribute ( ) ; other . setVoided ( true ) ; Assert . assertTrue ( pa . compareTo ( other ) < 0 ) ; } @ Test @ Verifies ( value = " should ▁ return ▁ negative ▁ if ▁ other ▁ attribute ▁ has ▁ earlier ▁ date ▁ created " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldReturnNegativeIfOtherAttributeHasEarlierDateCreated ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; pa . setDateCreated ( new Date ( ) ) ; PersonAttribute other = new PersonAttribute ( ) ; pa . setDateCreated ( new Date ( pa . getDateCreated ( ) . getTime ( ) - 1000 ) ) ; Assert . assertTrue ( pa . compareTo ( other ) < 0 ) ; } @ Test @ Verifies ( value = " should ▁ return ▁ negative ▁ if ▁ this ▁ attribute ▁ has ▁ lower ▁ attribute ▁ type ▁ than ▁ argument " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldReturnNegativeIfThisAttributeHasLowerAttributeTypeThanArgument ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; PersonAttribute other = new PersonAttribute ( ) ; other . setAttributeType ( new PersonAttributeType ( 2 ) ) ; Assert . assertTrue ( pa . compareTo ( other ) < 0 ) ; } @ Test @ Verifies ( value = " should ▁ not ▁ throw ▁ exception ▁ if ▁ attribute ▁ type ▁ is ▁ null " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldNotThrowExceptionIfAttributeTypeIdIsNull ( ) throws Exception { Assert . assertTrue ( new PersonAttribute ( 1 ) . compareTo ( new PersonAttribute ( 1 ) ) == 0 ) ; } @ Test @ Verifies ( value = " should ▁ return ▁ negative ▁ if ▁ other ▁ attribute ▁ has ▁ lower ▁ value " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldReturnNegativeIfOtherAttributeHasLowerValue ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; pa . setValue ( "2" ) ; PersonAttribute other = new PersonAttribute ( ) ; other . setAttributeType ( new PersonAttributeType ( 1 ) ) ; other . setValue ( "1" ) ; Assert . assertTrue ( pa . compareTo ( other ) > 0 ) ; } @ Test @ Verifies ( value = " should ▁ return ▁ negative ▁ if ▁ this ▁ attribute ▁ has ▁ lower ▁ attribute ▁ id ▁ than ▁ argument " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldReturnNegativeIfThisAttributeHasLowerAttributeIdThanArgument ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( 1 ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; PersonAttribute other = new PersonAttribute ( 2 ) ; other . setAttributeType ( new PersonAttributeType ( 1 ) ) ; Assert . assertTrue ( pa . compareTo ( other ) < 0 ) ; } @ Test @ Verifies ( value = " should ▁ return ▁ true ▁ if ▁ attributeType ▁ value ▁ and ▁ void ▁ status ▁ are ▁ the ▁ same " , method = " equalsContent ( PersonAttribute ) " ) public void equalsContent_shouldReturnTrueIfAttributeTypeValueAndVoidStatusAreTheSame ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; pa . setValue ( "1" ) ; pa . setVoided ( false ) ; PersonAttribute other = new PersonAttribute ( 1 ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; pa . setValue ( "1" ) ; pa . setVoided ( false ) ; Assert . assertTrue ( pa . equalsContent ( other ) ) ; } @ Test @ Verifies ( value = " should ▁ load ▁ class ▁ in ▁ format ▁ property " , method = " getHydratedObject ( ) " ) public void getHydratedObject_shouldLoadClassInFormatProperty ( ) throws Exception { PersonAttributeType type = new PersonAttributeType ( ) ; type . setFormat ( " org . openmrs . Concept " ) ; PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . setAttributeType ( type ) ; pa . setValue ( "5089" ) ; Concept concept = ( Concept ) pa . getHydratedObject ( ) ; Assert . assertEquals ( 5089 , concept . getConceptId ( ) . intValue ( ) ) ; } @ Test @ Verifies ( value = " should ▁ load ▁ user ▁ class ▁ in ▁ format ▁ property " , method = " getHydratedObject ( ) " ) public void getHydratedObject_shouldLoadUserClassInFormatProperty ( ) throws Exception { PersonAttributeType type = new PersonAttributeType ( ) ; type . setFormat ( " org . openmrs . User " ) ; PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . setAttributeType ( type ) ; pa . setValue ( "1" ) ; Object value = pa . getHydratedObject ( ) ; Assert . assertTrue ( " should ▁ load ▁ user ▁ class ▁ in ▁ format ▁ property " , ( value instanceof User ) ) ; } @ Test @ Verifies ( value = " should ▁ still ▁ load ▁ class ▁ in ▁ format ▁ property ▁ if ▁ not ▁ Attributable " , method = " getHydratedObject ( ) " ) public void getHydratedObject_shouldStillLoadClassInFormatPropertyIfNotAttributable ( ) throws Exception { PersonAttributeType type = new PersonAttributeType ( ) ; type . setFormat ( " java . lang . String " ) ; PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . setAttributeType ( type ) ; pa . setValue ( " lalapalooza " ) ; String value = ( String ) pa . getHydratedObject ( ) ; Assert . assertEquals ( " lalapalooza " , value ) ; } @ Test @ Verifies ( value = " should ▁ set ▁ voided ▁ bit ▁ to ▁ true " , method = " voidAttribute ( String ) " ) public void voidAttribute_shouldSetVoidedBitToTrue ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . setVoided ( false ) ; pa . voidAttribute ( " Because " ) ; Assert . assertTrue ( pa . isVoided ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="kingargyle/adt-leanback-support/tree/master/leanback-v17/src/main/java/android/support/v17/leanback/app/HeadersFragment.java"> package android . support . v17 . leanback . app ; import android . content . Context ; import android . graphics . Color ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . os . Bundle ; import android . support . v17 . leanback . R ; import android . support . v17 . leanback . widget . FocusHighlightHelper ; import android . support . v17 . leanback . widget . ItemBridgeAdapter ; import android . support . v17 . leanback . widget . PresenterSelector ; import android . support . v17 . leanback . widget . OnItemSelectedListener ; import android . support . v17 . leanback . widget . Row ; import android . support . v17 . leanback . widget . RowHeaderPresenter ; import android . support . v17 . leanback . widget . SinglePresenterSelector ; import android . support . v17 . leanback . widget . VerticalGridView ; import android . util . TypedValue ; import android . view . View ; import android . view . ViewGroup ; import android . view . View . OnLayoutChangeListener ; import android . widget . FrameLayout ; public class HeadersFragment extends BaseRowFragment { interface OnHeaderClickedListener { void onHeaderClicked ( ) ; } private OnItemSelectedListener mOnItemSelectedListener ; private OnHeaderClickedListener mOnHeaderClickedListener ; private boolean mHeadersEnabled = true ; private boolean mHeadersGone = false ; private int mBackgroundColor ; private boolean mBackgroundColorSet ; private static final PresenterSelector sHeaderPresenter = new SinglePresenterSelector ( new RowHeaderPresenter ( R . layout . lb_header ) ) ; public HeadersFragment ( ) { setPresenterSelector ( sHeaderPresenter ) ; } public void setOnHeaderClickedListener ( OnHeaderClickedListener listener ) { mOnHeaderClickedListener = listener ; } public void setOnItemSelectedListener ( OnItemSelectedListener listener ) { mOnItemSelectedListener = listener ; } @ Override protected VerticalGridView findGridViewFromRoot ( View view ) { return ( VerticalGridView ) view . findViewById ( R . id . browse_headers ) ; } @ Override protected void onRowSelected ( ViewGroup parent , View view , int position , long id ) { if ( mOnItemSelectedListener != null ) { if ( position >= 0 ) { Row row = ( Row ) getAdapter ( ) . get ( position ) ; mOnItemSelectedListener . onItemSelected ( null , row ) ; } else { mOnItemSelectedListener . onItemSelected ( null , null ) ; } } } private final ItemBridgeAdapter . AdapterListener mAdapterListener = new ItemBridgeAdapter . AdapterListener ( ) { @ Override public void onCreate ( ItemBridgeAdapter . ViewHolder viewHolder ) { View headerView = viewHolder . getViewHolder ( ) . view ; headerView . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { if ( mOnHeaderClickedListener != null ) { mOnHeaderClickedListener . onHeaderClicked ( ) ; } } } ) ; headerView . setFocusable ( true ) ; headerView . setFocusableInTouchMode ( true ) ; if ( mWrapper != null ) { viewHolder . itemView . addOnLayoutChangeListener ( sLayoutChangeListener ) ; } else { headerView . addOnLayoutChangeListener ( sLayoutChangeListener ) ; } } } ; private static OnLayoutChangeListener sLayoutChangeListener = new OnLayoutChangeListener ( ) { @ Override public void onLayoutChange ( View v , int left , int top , int right , int bottom , int oldLeft , int oldTop , int oldRight , int oldBottom ) { v . setPivotX ( 0 ) ; v . setPivotY ( v . getMeasuredHeight ( ) / 2 ) ; } } ; @ Override protected int getLayoutResourceId ( ) { return R . layout . lb_headers_fragment ; } @ Override public void onViewCreated ( View view , Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; final VerticalGridView listView = getVerticalGridView ( ) ; if ( listView == null ) { return ; } if ( getBridgeAdapter ( ) != null ) { FocusHighlightHelper . setupHeaderItemFocusHighlight ( listView ) ; } view . setBackgroundColor ( getBackgroundColor ( ) ) ; updateFadingEdgeToBrandColor ( getBackgroundColor ( ) ) ; updateListViewVisibility ( ) ; } private void updateListViewVisibility ( ) { final VerticalGridView listView = getVerticalGridView ( ) ; if ( listView != null ) { getView ( ) . setVisibility ( mHeadersGone ? View . GONE : View . VISIBLE ) ; if ( ! mHeadersGone ) { if ( mHeadersEnabled ) { listView . setChildrenVisibility ( View . VISIBLE ) ; } else { listView . setChildrenVisibility ( View . INVISIBLE ) ; } } } } void setHeadersEnabled ( boolean enabled ) { mHeadersEnabled = enabled ; updateListViewVisibility ( ) ; } void setHeadersGone ( boolean gone ) { mHeadersGone = gone ; updateListViewVisibility ( ) ; } static class NoOverlappingFrameLayout extends FrameLayout { public NoOverlappingFrameLayout ( Context context ) { super ( context ) ; } @ Override public boolean hasOverlappingRendering ( ) { return false ; } } private final ItemBridgeAdapter . Wrapper mWrapper = new ItemBridgeAdapter . Wrapper ( ) { @ Override public void wrap ( View wrapper , View wrapped ) { ( ( FrameLayout ) wrapper ) . addView ( wrapped ) ; } @ Override public View createWrapper ( View root ) { return new NoOverlappingFrameLayout ( root . getContext ( ) ) ; } } ; @ Override protected void updateAdapter ( ) { super . updateAdapter ( ) ; ItemBridgeAdapter adapter = getBridgeAdapter ( ) ; if ( adapter != null ) { adapter . setAdapterListener ( mAdapterListener ) ; adapter . setWrapper ( mWrapper ) ; } if ( adapter != null && getVerticalGridView ( ) != null ) { FocusHighlightHelper . setupHeaderItemFocusHighlight ( getVerticalGridView ( ) ) ; } } void setBackgroundColor ( int color ) { mBackgroundColor = color ; mBackgroundColorSet = true ; if ( getView ( ) != null ) { getView ( ) . setBackgroundColor ( mBackgroundColor ) ; updateFadingEdgeToBrandColor ( mBackgroundColor ) ; } } private void updateFadingEdgeToBrandColor ( int backgroundColor ) { View fadingView = getView ( ) . findViewById ( R . id . fade_out_edge ) ; Drawable background = fadingView . getBackground ( ) ; if ( background instanceof GradientDrawable ) { background . mutate ( ) ; ( ( GradientDrawable ) background ) . setColors ( new int [ ] { Color . TRANSPARENT , backgroundColor } ) ; } } int getBackgroundColor ( ) { if ( getActivity ( ) == null ) { throw new IllegalStateException ( " Activity ▁ must ▁ be ▁ attached " ) ; } if ( mBackgroundColorSet ) { return mBackgroundColor ; } TypedValue outValue = new TypedValue ( ) ; getActivity ( ) . getTheme ( ) . resolveAttribute ( R . attr . defaultBrandColor , outValue , true ) ; return getResources ( ) . getColor ( outValue . resourceId ) ; } @ Override void onTransitionStart ( ) { super . onTransitionStart ( ) ; if ( ! mHeadersEnabled ) { final VerticalGridView listView = getVerticalGridView ( ) ; if ( listView != null ) { listView . setDescendantFocusability ( ViewGroup . FOCUS_BEFORE_DESCENDANTS ) ; if ( listView . hasFocus ( ) ) { listView . requestFocus ( ) ; } } } } @ Override void onTransitionEnd ( ) { if ( mHeadersEnabled ) { final VerticalGridView listView = getVerticalGridView ( ) ; if ( listView != null ) { listView . setDescendantFocusability ( ViewGroup . FOCUS_AFTER_DESCENDANTS ) ; if ( listView . hasFocus ( ) ) { listView . requestFocus ( ) ; } } } super . onTransitionEnd ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="bogeo/simsamples/tree/master/src/de/hsbo/geo/simsamples/applications/PubExample.java"> package de . hsbo . geo . simsamples . applications ; import de . hsbo . geo . simsamples . common . RandomValueGenerator ; import de . hsbo . geo . simsamples . eventqueues . servercustomer . Customer ; import de . hsbo . geo . simsamples . eventqueues . servercustomer . CustomerQueue ; import de . hsbo . geo . simsamples . eventqueues . servercustomer . Server ; import de . hsbo . geo . simsamples . eventqueues . servercustomer . ServerQueue ; import de . hsbo . geo . simsamples . eventqueues . servercustomer . SimpleServerCustomerSimulator ; public class PubExample { public static void main ( String [ ] args ) throws Exception { new PubExample ( ) . run ( ) ; } private void run ( ) throws Exception { Drinker peter = new Drinker ( " Peter " , 15. ) , paul = new Drinker ( " Paul " , 20. ) , harry = new Drinker ( " Harry " , 30. ) ; Barmaid elke = new Barmaid ( " Elke " , 2. ) ; CustomerQueue drinking = new CustomerQueue ( " . " ) ; CustomerQueue thursty = new CustomerQueue ( " ? " ) ; thursty . enqueue ( peter , paul , harry ) ; ServerQueue tapping = new ServerQueue ( " X " ) ; ServerQueue free = new ServerQueue ( " . " ) ; free . enqueue ( elke ) ; SimpleServerCustomerSimulator sim = new SimpleServerCustomerSimulator ( free , tapping , thursty , drinking ) ; sim . setConsoleDump ( false ) ; double M = 120. ; sim . execute ( M ) ; } protected class Drinker extends Customer { private double dt ; protected Drinker ( String name , double drinkingTime ) { super ( name ) ; this . dt = drinkingTime ; } @ Override public double getDuration ( ) { double var = RandomValueGenerator . number ( - 2. , + 2. , 0. , 1. ) ; return dt + var ; } } protected class Barmaid extends Server { private double dt ; protected Barmaid ( String name , double serviceTime ) { super ( name ) ; this . dt = serviceTime ; } public double getDuration ( ) { return dt + RandomValueGenerator . number ( - 1. , + 1. , 0. , 1. ) ; } } } </DOCUMENT>
<DOCUMENT_ID="nafae/developer/tree/master/modules/dfp_axis/src/main/java/com/google/api/ads/dfp/axis/v201308/ActivityGroupPage.java"> package com . google . api . ads . dfp . axis . v201308 ; public class ActivityGroupPage implements java . io . Serializable { private java . lang . Integer totalResultSetSize ; private java . lang . Integer startIndex ; private com . google . api . ads . dfp . axis . v201308 . ActivityGroup [ ] results ; public ActivityGroupPage ( ) { } public ActivityGroupPage ( java . lang . Integer totalResultSetSize , java . lang . Integer startIndex , com . google . api . ads . dfp . axis . v201308 . ActivityGroup [ ] results ) { this . totalResultSetSize = totalResultSetSize ; this . startIndex = startIndex ; this . results = results ; } public java . lang . Integer getTotalResultSetSize ( ) { return totalResultSetSize ; } public void setTotalResultSetSize ( java . lang . Integer totalResultSetSize ) { this . totalResultSetSize = totalResultSetSize ; } public java . lang . Integer getStartIndex ( ) { return startIndex ; } public void setStartIndex ( java . lang . Integer startIndex ) { this . startIndex = startIndex ; } public com . google . api . ads . dfp . axis . v201308 . ActivityGroup [ ] getResults ( ) { return results ; } public void setResults ( com . google . api . ads . dfp . axis . v201308 . ActivityGroup [ ] results ) { this . results = results ; } public com . google . api . ads . dfp . axis . v201308 . ActivityGroup getResults ( int i ) { return this . results [ i ] ; } public void setResults ( int i , com . google . api . ads . dfp . axis . v201308 . ActivityGroup _value ) { this . results [ i ] = _value ; } private java . lang . Object __equalsCalc = null ; public synchronized boolean equals ( java . lang . Object obj ) { if ( ! ( obj instanceof ActivityGroupPage ) ) return false ; ActivityGroupPage other = ( ActivityGroupPage ) obj ; if ( obj == null ) return false ; if ( this == obj ) return true ; if ( __equalsCalc != null ) { return ( __equalsCalc == obj ) ; } __equalsCalc = obj ; boolean _equals ; _equals = true && ( ( this . totalResultSetSize == null && other . getTotalResultSetSize ( ) == null ) || ( this . totalResultSetSize != null && this . totalResultSetSize . equals ( other . getTotalResultSetSize ( ) ) ) ) && ( ( this . startIndex == null && other . getStartIndex ( ) == null ) || ( this . startIndex != null && this . startIndex . equals ( other . getStartIndex ( ) ) ) ) && ( ( this . results == null && other . getResults ( ) == null ) || ( this . results != null && java . util . Arrays . equals ( this . results , other . getResults ( ) ) ) ) ; __equalsCalc = null ; return _equals ; } private boolean __hashCodeCalc = false ; public synchronized int hashCode ( ) { if ( __hashCodeCalc ) { return 0 ; } __hashCodeCalc = true ; int _hashCode = 1 ; if ( getTotalResultSetSize ( ) != null ) { _hashCode += getTotalResultSetSize ( ) . hashCode ( ) ; } if ( getStartIndex ( ) != null ) { _hashCode += getStartIndex ( ) . hashCode ( ) ; } if ( getResults ( ) != null ) { for ( int i = 0 ; i < java . lang . reflect . Array . getLength ( getResults ( ) ) ; i ++ ) { java . lang . Object obj = java . lang . reflect . Array . get ( getResults ( ) , i ) ; if ( obj != null && ! obj . getClass ( ) . isArray ( ) ) { _hashCode += obj . hashCode ( ) ; } } } __hashCodeCalc = false ; return _hashCode ; } private static org . apache . axis . description . TypeDesc typeDesc = new org . apache . axis . description . TypeDesc ( ActivityGroupPage . class , true ) ; static { typeDesc . setXmlType ( new javax . xml . namespace . QName ( " https : // www . google . com / apis / ads / publisher / v201308" , " ActivityGroupPage " ) ) ; org . apache . axis . description . ElementDesc elemField = new org . apache . axis . description . ElementDesc ( ) ; elemField . setFieldName ( " totalResultSetSize " ) ; elemField . setXmlName ( new javax . xml . namespace . QName ( " https : // www . google . com / apis / ads / publisher / v201308" , " totalResultSetSize " ) ) ; elemField . setXmlType ( new javax . xml . namespace . QName ( " http : // www . w3 . org / 2001 / XMLSchema " , " int " ) ) ; elemField . setMinOccurs ( 0 ) ; elemField . setNillable ( false ) ; typeDesc . addFieldDesc ( elemField ) ; elemField = new org . apache . axis . description . ElementDesc ( ) ; elemField . setFieldName ( " startIndex " ) ; elemField . setXmlName ( new javax . xml . namespace . QName ( " https : // www . google . com / apis / ads / publisher / v201308" , " startIndex " ) ) ; elemField . setXmlType ( new javax . xml . namespace . QName ( " http : // www . w3 . org / 2001 / XMLSchema " , " int " ) ) ; elemField . setMinOccurs ( 0 ) ; elemField . setNillable ( false ) ; typeDesc . addFieldDesc ( elemField ) ; elemField = new org . apache . axis . description . ElementDesc ( ) ; elemField . setFieldName ( " results " ) ; elemField . setXmlName ( new javax . xml . namespace . QName ( " https : // www . google . com / apis / ads / publisher / v201308" , " results " ) ) ; elemField . setXmlType ( new javax . xml . namespace . QName ( " https : // www . google . com / apis / ads / publisher / v201308" , " ActivityGroup " ) ) ; elemField . setMinOccurs ( 0 ) ; elemField . setNillable ( false ) ; elemField . setMaxOccursUnbounded ( true ) ; typeDesc . addFieldDesc ( elemField ) ; } public static org . apache . axis . description . TypeDesc getTypeDesc ( ) { return typeDesc ; } public static org . apache . axis . encoding . Serializer getSerializer ( java . lang . String mechType , java . lang . Class _javaType , javax . xml . namespace . QName _xmlType ) { return new org . apache . axis . encoding . ser . BeanSerializer ( _javaType , _xmlType , typeDesc ) ; } public static org . apache . axis . encoding . Deserializer getDeserializer ( java . lang . String mechType , java . lang . Class _javaType , javax . xml . namespace . QName _xmlType ) { return new org . apache . axis . encoding . ser . BeanDeserializer ( _javaType , _xmlType , typeDesc ) ; } } </DOCUMENT>
<DOCUMENT_ID="victos/opencms-core/tree/master/src-gwt/org/opencms/gwt/client/ui/history/CmsResourceHistoryTable.java"> package org . opencms . gwt . client . ui . history ; import org . opencms . gwt . client . CmsCoreProvider ; import org . opencms . gwt . client . ui . css . I_CmsCellTableResources ; import org . opencms . gwt . client . ui . css . I_CmsImageBundle ; import org . opencms . gwt . shared . CmsHistoryResourceBean ; import org . opencms . gwt . shared . CmsHistoryResourceCollection ; import com . google . common . base . Predicate ; import com . google . gwt . cell . client . AbstractCell ; import com . google . gwt . cell . client . ActionCell ; import com . google . gwt . core . client . GWT ; import com . google . gwt . dom . client . Style . Unit ; import com . google . gwt . safehtml . client . SafeHtmlTemplates ; import com . google . gwt . safehtml . shared . SafeHtml ; import com . google . gwt . user . cellview . client . CellTable ; import com . google . gwt . user . cellview . client . Column ; import com . google . gwt . user . cellview . client . IdentityColumn ; import com . google . gwt . user . cellview . client . TextColumn ; import com . google . gwt . view . client . ListDataProvider ; import com . google . gwt . view . client . ProvidesKey ; public class CmsResourceHistoryTable extends CellTable < CmsHistoryResourceBean > { static interface Templates extends SafeHtmlTemplates { @ Template ( " < span ▁ class = \ " {1 } \ " ▁ title = \ " {0 } \ " > < / span > " ) SafeHtml button ( String title , String cssClass ) ; @ Template ( " < span ▁ title = \ " {1 } \ " > { 0 } < / span > " ) SafeHtml textSpanWithTitle ( String text , String title ) ; } static Templates templates = GWT . create ( Templates . class ) ; private I_CmsHistoryActionHandler m_handler ; public CmsResourceHistoryTable ( CmsHistoryResourceCollection data , I_CmsHistoryActionHandler handler ) { super ( Integer . MAX_VALUE , ( CellTable . Resources ) GWT . create ( I_CmsCellTableResources . class ) , new ProvidesKey < CmsHistoryResourceBean > ( ) { public Object getKey ( CmsHistoryResourceBean item ) { return item . getStructureId ( ) + " _ " + item . getVersion ( ) ; } } ) ; m_handler = handler ; setWidth ( "100 % " , true ) ; setTableLayoutFixed ( true ) ; addVersionColumn ( ) ; addPreviewColumn ( ) ; addRevertColumn ( ) ; addPathColumn ( ) ; addSizeColumn ( ) ; addModificationDateColumn ( ) ; addUserLastModifiedColumn ( ) ; addPublishDateColumn ( ) ; ListDataProvider < CmsHistoryResourceBean > dataProvider = new ListDataProvider < CmsHistoryResourceBean > ( ) ; dataProvider . addDataDisplay ( this ) ; dataProvider . setList ( data . getResources ( ) ) ; } private void addColumn ( String label , int width , Column < CmsHistoryResourceBean , ? > col ) { addColumn ( col , label ) ; setColumnWidth ( col , width , Unit . PX ) ; } private void addModificationDateColumn ( ) { addColumn ( CmsHistoryMessages . columnModificationDate ( ) , 190 , new TextColumn < CmsHistoryResourceBean > ( ) { @ Override public String getValue ( CmsHistoryResourceBean historyRes ) { return historyRes . getModificationDate ( ) . getDateText ( ) ; } } ) ; } private void addPathColumn ( ) { Column < CmsHistoryResourceBean , ? > col = new TextColumn < CmsHistoryResourceBean > ( ) { @ Override public String getValue ( CmsHistoryResourceBean historyRes ) { String path = historyRes . getRootPath ( ) ; String siteRoot = CmsCoreProvider . get ( ) . getSiteRoot ( ) ; if ( path . startsWith ( siteRoot ) ) { path = path . substring ( siteRoot . length ( ) ) ; if ( ! path . startsWith ( " / " ) ) { path = " / " + path ; } } return path ; } } ; addColumn ( col , CmsHistoryMessages . columnPath ( ) ) ; setColumnWidth ( col , 100 , Unit . PCT ) ; } private void addPreviewColumn ( ) { CmsButtonCell < CmsHistoryResourceBean > previewCell = new CmsButtonCell < CmsHistoryResourceBean > ( CmsHistoryMessages . titlePreview ( ) , I_CmsImageBundle . INSTANCE . style ( ) . tablePreviewIcon ( ) , new ActionCell . Delegate < CmsHistoryResourceBean > ( ) { @ SuppressWarnings ( " synthetic - access " ) public void execute ( CmsHistoryResourceBean historyRes ) { m_handler . showPreview ( historyRes ) ; } } , new Predicate < CmsHistoryResourceBean > ( ) { public boolean apply ( CmsHistoryResourceBean bean ) { return true ; } } ) ; addColumn ( CmsHistoryMessages . columnPreview ( ) , 30 , new IdentityColumn < CmsHistoryResourceBean > ( previewCell ) ) ; } private void addPublishDateColumn ( ) { addColumn ( CmsHistoryMessages . columnPublishDate ( ) , 190 , new TextColumn < CmsHistoryResourceBean > ( ) { @ Override public String getValue ( CmsHistoryResourceBean historyRes ) { if ( historyRes . getPublishDate ( ) != null ) { return historyRes . getPublishDate ( ) . getDateText ( ) ; } return " - " ; } } ) ; } private void addRevertColumn ( ) { CmsButtonCell < CmsHistoryResourceBean > replaceCell = new CmsButtonCell < CmsHistoryResourceBean > ( CmsHistoryMessages . titleRevert ( ) , I_CmsImageBundle . INSTANCE . style ( ) . tableReplaceIcon ( ) , new ActionCell . Delegate < CmsHistoryResourceBean > ( ) { @ SuppressWarnings ( " synthetic - access " ) public void execute ( CmsHistoryResourceBean historyRes ) { m_handler . revert ( historyRes ) ; } } , new Predicate < CmsHistoryResourceBean > ( ) { public boolean apply ( CmsHistoryResourceBean bean ) { return bean . getVersion ( ) . getVersionNumber ( ) != null ; } } ) ; addColumn ( CmsHistoryMessages . columnReplace ( ) , 30 , new IdentityColumn < CmsHistoryResourceBean > ( replaceCell ) ) ; } private void addSizeColumn ( ) { Column < CmsHistoryResourceBean , ? > col = new TextColumn < CmsHistoryResourceBean > ( ) { @ Override public String getValue ( CmsHistoryResourceBean historyRes ) { return " " + historyRes . getSize ( ) ; } } ; addColumn ( col , CmsHistoryMessages . columnSize ( ) ) ; setColumnWidth ( col , 100 , Unit . PX ) ; } private void addUserLastModifiedColumn ( ) { addColumn ( CmsHistoryMessages . columnUserLastModified ( ) , 120 , new TextColumn < CmsHistoryResourceBean > ( ) { @ Override public String getValue ( CmsHistoryResourceBean historyRes ) { return historyRes . getUserLastModified ( ) ; } } ) ; } private void addVersionColumn ( ) { AbstractCell < CmsHistoryResourceBean > cell = new CmsVersionCell ( ) ; addColumn ( CmsHistoryMessages . columnVersion ( ) , 40 , new IdentityColumn < CmsHistoryResourceBean > ( cell ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="bhaveshdt/camel/tree/master/components/camel-freemarker/src/test/java/org/apache/camel/component/freemarker/FruitFilter.java"> package org . apache . camel . component . freemarker ; public class FruitFilter { public boolean isApple ( String body ) { return " apple " . equalsIgnoreCase ( body ) ; } public boolean isOrange ( String body ) { return " orange " . equalsIgnoreCase ( body ) ; } } </DOCUMENT>
<DOCUMENT_ID="davidfestal/che/tree/master/plugins/plugin-java/che-plugin-java-ext-lang-server/src/test/resources/RenamePackage/testFail10/in/r/A.java"> package r ; class C { } </DOCUMENT>
<DOCUMENT_ID="crockpotveggies/deeplearning4j/tree/master/deeplearning4j-ui-parent/deeplearning4j-ui/src/test/java/org/deeplearning4j/ui/weights/HistogramBinTest.java"> package org . deeplearning4j . ui . weights ; import org . junit . Before ; import org . junit . Test ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . factory . Nd4j ; import java . math . BigDecimal ; import static org . junit . Assert . assertEquals ; public class HistogramBinTest { @ Before public void setUp ( ) throws Exception { } @ Test public void testGetBins ( ) throws Exception { INDArray array = Nd4j . create ( new double [ ] { 0.1 , 0.2 , 0.3 , 0.4 , 0.5 , 0.6 , 0.7 , 0.8 , 0.9 , 1.0 , 1.0 } ) ; HistogramBin histogram = new HistogramBin . Builder ( array ) . setBinCount ( 10 ) . build ( ) ; assertEquals ( 0.1 , histogram . getMin ( ) , 0.001 ) ; assertEquals ( 1.0 , histogram . getMax ( ) , 0.001 ) ; System . out . println ( " Result : ▁ " + histogram . getBins ( ) ) ; assertEquals ( 2 , histogram . getBins ( ) . getDouble ( 9 ) , 0.001 ) ; } @ Test public void testGetData1 ( ) throws Exception { INDArray array = Nd4j . create ( new double [ ] { 0.1 , 0.2 , 0.3 , 0.4 , 0.5 , 0.6 , 0.7 , 0.8 , 0.9 , 1.0 , 1.0 } ) ; HistogramBin histogram = new HistogramBin . Builder ( array ) . setBinCount ( 10 ) . build ( ) ; assertEquals ( 0.1 , histogram . getMin ( ) , 0.001 ) ; assertEquals ( 1.0 , histogram . getMax ( ) , 0.001 ) ; System . out . println ( " Result : ▁ " + histogram . getData ( ) ) ; assertEquals ( 10 , histogram . getData ( ) . size ( ) ) ; } @ Test public void testGetData2 ( ) throws Exception { INDArray array = Nd4j . create ( new double [ ] { - 1.0f , - 0.50f , 0.0f , 0.50f , 1.0f , - 1.0f , - 0.50f , 0.0f , 0.50f , 1.0f } ) ; HistogramBin histogram = new HistogramBin . Builder ( array ) . setBinCount ( 10 ) . build ( ) ; assertEquals ( - 1.0 , histogram . getMin ( ) , 0.001 ) ; assertEquals ( 1.0 , histogram . getMax ( ) , 0.001 ) ; System . out . println ( " Result : ▁ " + histogram . getData ( ) ) ; assertEquals ( 10 , histogram . getData ( ) . size ( ) ) ; assertEquals ( 2 , histogram . getData ( ) . get ( new BigDecimal ( "1.00" ) ) . get ( ) ) ; } @ Test public void testGetData4 ( ) throws Exception { INDArray array = Nd4j . create ( new double [ ] { - 1.0f , - 0.50f , 0.0f , 0.50f , 1.0f , - 1.0f , - 0.50f , 0.0f , 0.50f , 1.0f } ) ; HistogramBin histogram = new HistogramBin . Builder ( array ) . setBinCount ( 50 ) . build ( ) ; assertEquals ( - 1.0 , histogram . getMin ( ) , 0.001 ) ; assertEquals ( 1.0 , histogram . getMax ( ) , 0.001 ) ; System . out . println ( " Result : ▁ " + histogram . getData ( ) ) ; assertEquals ( 50 , histogram . getData ( ) . size ( ) ) ; assertEquals ( 2 , histogram . getData ( ) . get ( new BigDecimal ( "1.00" ) ) . get ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="farkas-arpad/KROKI-mockup-tool/tree/master/GraphEdit/src/graphedit/state/SelectionState.java"> package graphedit . state ; import graphedit . actions . popup . LinkPopupMenu ; import graphedit . app . MainFrame ; import graphedit . command . ChangeAssociationPropertiesCommand ; import graphedit . command . ChangeElementPropertiesCommand ; import graphedit . command . ChangeLinkTypeCommand ; import graphedit . command . Command ; import graphedit . gui . dialog . AssociationLinkDialog ; import graphedit . gui . dialog . ClassElementDialog ; import graphedit . model . components . AggregationLink ; import graphedit . model . components . AssociationLink ; import graphedit . model . components . Class ; import graphedit . model . components . CompositionLink ; import graphedit . model . components . GraphElement ; import graphedit . model . components . Link ; import graphedit . model . components . LinkNode ; import graphedit . model . components . Package ; import graphedit . model . properties . PropertyEnums . GraphElementProperties ; import graphedit . view . AggregationLinkPainter ; import graphedit . view . AssociationLinkPainter ; import graphedit . view . CompositionLinkPainter ; import graphedit . view . ElementPainter ; import graphedit . view . LinkPainter ; import java . awt . Cursor ; import java . awt . event . KeyEvent ; import java . awt . event . MouseEvent ; import java . awt . geom . Dimension2D ; import java . awt . geom . Point2D ; import java . util . ArrayList ; import java . util . List ; import javax . swing . SwingUtilities ; public class SelectionState extends State { private Point2D popupPoint ; public SelectionState ( ) { super ( ) ; } @ Override public void mouseReleased ( MouseEvent e ) { GraphElement hitElement = controller . getCurrentElement ( ) ; Link hitLink = controller . getCurrentLink ( ) ; LinkNode hitNode = controller . getCurrentLinkNode ( ) ; if ( SwingUtilities . isRightMouseButton ( e ) ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; if ( hitElement != null ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . addSelectedElement ( hitElement ) ; showGraphElementPopup ( e ) ; } else if ( hitLink != null || hitNode != null ) { showLinkElementPopup ( e ) ; } else showGraphElementPopup ( e ) ; view . repaint ( ) ; } } @ Override public void mousePressed ( MouseEvent e ) { Link hitLink = controller . getCurrentLink ( ) ; view . getSelectionModel ( ) . setSelectedNode ( null ) ; GraphElement hitElement = controller . getCurrentElement ( ) ; LinkNode hitNode = controller . getCurrentLinkNode ( ) ; if ( SwingUtilities . isLeftMouseButton ( e ) ) { if ( hitNode != null ) view . getSelectionModel ( ) . setSelectedNode ( hitNode ) ; else { view . getSelectionModel ( ) . setSelectedLink ( null ) ; if ( hitElement != null ) { if ( e . isControlDown ( ) ) { if ( view . getSelectionModel ( ) . getSelectedElements ( ) . contains ( hitElement ) ) { view . getSelectionModel ( ) . removeSelectedElement ( hitElement ) ; } else { view . getSelectionModel ( ) . addSelectedElement ( hitElement ) ; } } else { if ( ! view . getSelectionModel ( ) . getSelectedElements ( ) . contains ( hitElement ) ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . addSelectedElement ( hitElement ) ; } } } else if ( hitLink != null ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . setSelectedLink ( hitLink ) ; hitNode = view . getSelectedLinkNode ( hitLink , e . getPoint ( ) ) ; view . getSelectionModel ( ) . setSelectedNode ( hitNode ) ; } else { if ( ! e . isControlDown ( ) ) view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; } } } else if ( SwingUtilities . isRightMouseButton ( e ) ) { if ( hitElement != null ) { view . getSelectionModel ( ) . setSelectedLink ( null ) ; view . getSelectionModel ( ) . addSelectedElement ( hitElement ) ; } else if ( hitNode != null ) { view . getSelectionModel ( ) . setSelectedNode ( hitNode ) ; } else if ( hitLink != null ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . setSelectedLink ( hitLink ) ; hitNode = view . getSelectedLinkNode ( hitLink , e . getPoint ( ) ) ; view . getSelectionModel ( ) . setSelectedNode ( hitNode ) ; } else { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . setSelectedNode ( null ) ; view . getSelectionModel ( ) . setSelectedNode ( null ) ; } } view . repaint ( ) ; } @ Override public void mouseDragged ( MouseEvent e ) { GraphElement hitElement = controller . getCurrentElement ( ) ; Link hitLink = controller . getCurrentLink ( ) ; LinkNode hitNode = view . getSelectionModel ( ) . getSelectedNode ( ) ; if ( SwingUtilities . isLeftMouseButton ( e ) ) { if ( hitNode != null || ( hitLink != null && hitElement == null ) ) { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getMoveElementState ( ) ; state . setView ( view ) ; state . setController ( controller ) ; state . setCursor ( Cursor . getPredefinedCursor ( Cursor . MOVE_CURSOR ) ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; state . mousePressed ( e ) ; } else if ( hitElement != null ) { if ( MainFrame . getInstance ( ) . getCurrentView ( ) . getSelectionModel ( ) . getSelectedElements ( ) . contains ( hitElement ) ) { if ( e . isControlDown ( ) ) { } if ( view . getCursor ( ) . getName ( ) . equals ( Cursor . getDefaultCursor ( ) . getName ( ) ) ) { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getMoveElementState ( ) ; state . mousePressed ( e ) ; state . setView ( view ) ; state . setController ( controller ) ; state . setCursor ( Cursor . getPredefinedCursor ( Cursor . MOVE_CURSOR ) ) ; ( ( MoveElementState ) state ) . setElements ( view . getSelectionModel ( ) . getSelectedElements ( ) ) ; ( ( MoveElementState ) state ) . setRightMove ( false ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; } else { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getResizeState ( ) ; state . setView ( view ) ; state . setController ( controller ) ; state . mousePressed ( e ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; } } } else { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getLassoSelectionState ( ) ; state . setView ( view ) ; state . setController ( controller ) ; state . setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; } } else if ( SwingUtilities . isRightMouseButton ( e ) && hitElement != null ) { if ( view . getCursor ( ) . getName ( ) . equals ( Cursor . getDefaultCursor ( ) . getName ( ) ) ) { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getMoveElementState ( ) ; state . mousePressed ( e ) ; state . setView ( view ) ; state . setController ( controller ) ; state . setCursor ( Cursor . getPredefinedCursor ( Cursor . MOVE_CURSOR ) ) ; List < GraphElement > shadowElements = new ArrayList < GraphElement > ( ) ; List < ElementPainter > shadowPainters = new ArrayList < ElementPainter > ( ) ; for ( GraphElement element : view . getSelectionModel ( ) . getSelectedElements ( ) ) { try { GraphElement clone = ( GraphElement ) element . clone ( ) ; clone . setShadowElement ( true ) ; ElementPainter clonePainter = ( ElementPainter ) view . getElementPainter ( element ) . clone ( ) ; clonePainter . setElement ( clone ) ; shadowElements . add ( clone ) ; shadowPainters . add ( clonePainter ) ; } catch ( CloneNotSupportedException e1 ) { e1 . printStackTrace ( ) ; } } view . setShadowPainters ( shadowPainters ) ; ( ( MoveElementState ) state ) . setElements ( shadowElements ) ; ( ( MoveElementState ) state ) . setRightMove ( true ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; } } else { if ( hitElement != null ) { if ( view . getSelectionModel ( ) . getSelectedElements ( ) . contains ( hitElement ) ) { } } } } @ Override public void mouseMoved ( MouseEvent e ) { int xPos = e . getX ( ) ; int yPos = e . getY ( ) ; MainFrame . getInstance ( ) . setPositionTrack ( xPos , yPos ) ; if ( view . getSelectionModel ( ) . getSelectedElements ( ) . size ( ) == 1 ) { GraphElement selectedElement = view . getSelectionModel ( ) . getSelectedElements ( ) . get ( 0 ) ; Dimension2D size = ( Dimension2D ) selectedElement . getProperty ( GraphElementProperties . SIZE ) ; Point2D position = new Point2D . Double ( ( ( Point2D ) selectedElement . getProperty ( GraphElementProperties . POSITION ) ) . getX ( ) - size . getWidth ( ) / 2 , ( ( Point2D ) selectedElement . getProperty ( GraphElementProperties . POSITION ) ) . getY ( ) - size . getHeight ( ) / 2 ) ; if ( position . getX ( ) <= xPos && xPos <= position . getX ( ) + 4 ) { if ( position . getY ( ) <= yPos && yPos <= position . getY ( ) + 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . NW_RESIZE_CURSOR ) ) ; } else if ( position . getY ( ) + 4 < yPos && yPos < position . getY ( ) + size . getHeight ( ) - 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . W_RESIZE_CURSOR ) ) ; } else if ( position . getY ( ) + size . getHeight ( ) - 4 <= yPos && yPos <= position . getY ( ) + size . getHeight ( ) ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . SW_RESIZE_CURSOR ) ) ; } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } else if ( position . getX ( ) + 4 < xPos && xPos < position . getX ( ) + size . getWidth ( ) - 4 ) { if ( position . getY ( ) <= yPos && yPos <= position . getY ( ) + 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . N_RESIZE_CURSOR ) ) ; } else if ( position . getY ( ) + size . getHeight ( ) - 4 <= yPos && yPos <= position . getY ( ) + size . getHeight ( ) ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . S_RESIZE_CURSOR ) ) ; } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } else if ( position . getX ( ) + size . getWidth ( ) - 4 <= xPos && xPos <= position . getX ( ) + size . getWidth ( ) ) { if ( position . getY ( ) <= yPos && yPos <= position . getY ( ) + 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . NE_RESIZE_CURSOR ) ) ; } else if ( position . getY ( ) + 4 < yPos && yPos < position . getY ( ) + size . getHeight ( ) - 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . E_RESIZE_CURSOR ) ) ; } else if ( position . getY ( ) + size . getHeight ( ) - 4 <= yPos && yPos <= position . getY ( ) + size . getHeight ( ) ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . SE_RESIZE_CURSOR ) ) ; } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } @ Override public void keyPressed ( KeyEvent e ) { if ( e . isControlDown ( ) && e . getKeyCode ( ) == KeyEvent . VK_ENTER ) { if ( view . getSelectionModel ( ) . getSelectedElements ( ) . size ( ) > 0 ) { } } } @ Override public void mouseClicked ( MouseEvent e ) { if ( SwingUtilities . isLeftMouseButton ( e ) ) if ( e . getClickCount ( ) == 2 ) { Link hitLink = controller . getCurrentLink ( ) ; if ( hitLink != null ) { if ( hitLink instanceof AssociationLink ) { AssociationLinkDialog d = new AssociationLinkDialog ( ( AssociationLink ) hitLink ) ; d . setVisible ( true ) ; if ( d . isSomethingChanged ( ) ) { if ( d . isCreateNewLink ( ) ) { AssociationLink newLink ; LinkPainter painter = null ; if ( d . isAssociation ( ) ) { newLink = new AssociationLink ( hitLink . getNodes ( ) , d . getSourceCardinality ( ) , d . getDestinationCardinality ( ) , d . getSourceRole ( ) , d . getDestinationRole ( ) , " AssociationLink " + ( ( AssociationLink ) hitLink ) . getCurrentCount ( ) , d . isSourceNavigable ( ) , d . isDestinationNavigable ( ) , d . isShowSourceRole ( ) , d . isShowDestinationRole ( ) , MainFrame . getInstance ( ) . incrementLinkCounter ( ) ) ; painter = new AssociationLinkPainter ( newLink ) ; } else if ( d . isAggregation ( ) ) { newLink = new AggregationLink ( hitLink . getNodes ( ) , d . getSourceCardinality ( ) , d . getDestinationCardinality ( ) , d . getSourceRole ( ) , d . getDestinationRole ( ) , " AggregationLink " + ( ( AssociationLink ) hitLink ) . getCurrentCount ( ) , d . isSourceNavigable ( ) , d . isDestinationNavigable ( ) , d . isShowSourceRole ( ) , d . isShowDestinationRole ( ) , MainFrame . getInstance ( ) . incrementLinkCounter ( ) ) ; painter = new AggregationLinkPainter ( newLink ) ; } else { newLink = new CompositionLink ( hitLink . getNodes ( ) , d . getSourceCardinality ( ) , d . getDestinationCardinality ( ) , d . getSourceRole ( ) , d . getDestinationRole ( ) , " CompositionLink " + ( ( AssociationLink ) hitLink ) . getCurrentCount ( ) , d . isSourceNavigable ( ) , d . isDestinationNavigable ( ) , d . isShowSourceRole ( ) , d . isShowDestinationRole ( ) , MainFrame . getInstance ( ) . incrementLinkCounter ( ) ) ; painter = new CompositionLinkPainter ( newLink ) ; } Command command = new ChangeLinkTypeCommand ( view , hitLink , newLink , painter ) ; view . getModel ( ) . getCommandManager ( ) . executeCommand ( command ) ; newLink . getSourceConnector ( ) . setLink ( newLink ) ; newLink . getDestinationConnector ( ) . setLink ( newLink ) ; } else { Command command = new ChangeAssociationPropertiesCommand ( view , d . getSourceCardinality ( ) , d . getDestinationCardinality ( ) , d . getSourceRole ( ) , d . getDestinationRole ( ) , d . isSourceNavigable ( ) , d . isDestinationNavigable ( ) , d . isShowSourceRole ( ) , d . isShowDestinationRole ( ) , ( AssociationLink ) hitLink ) ; view . getModel ( ) . getCommandManager ( ) . executeCommand ( command ) ; } view . repaint ( ) ; } } } else { GraphElement element = controller . getCurrentElement ( ) ; if ( element instanceof Package ) MainFrame . getInstance ( ) . showDiagram ( ( ( Package ) element ) . getHierarchyPackage ( ) . getDiagram ( ) ) ; else if ( element instanceof graphedit . model . components . Class ) { ClassElementDialog dialog = new ClassElementDialog ( ( Class ) element ) ; dialog . setVisible ( true ) ; if ( dialog . isOk ( ) ) { Command command = new ChangeElementPropertiesCommand ( view , dialog . getName ( ) , dialog . getStereotype ( ) , element ) ; view . getModel ( ) . getCommandManager ( ) . executeCommand ( command ) ; view . repaint ( ) ; } } } } } public void showGraphElementPopup ( MouseEvent e ) { MainFrame . getInstance ( ) . getViewPopupMenu ( ) . show ( e . getComponent ( ) , e . getX ( ) , e . getY ( ) ) ; } public void showLinkElementPopup ( MouseEvent e ) { LinkPopupMenu popup = MainFrame . getInstance ( ) . getLinkPopupMenu ( ) ; popup . preparePopup ( ) ; popup . setActionPoint ( e . getPoint ( ) ) ; popup . show ( e . getComponent ( ) , e . getX ( ) , e . getY ( ) ) ; } @ Override public boolean isAutoScrollOnDragEnabled ( ) { return false ; } @ Override public boolean isAutoScrollOnMoveEnabled ( ) { return false ; } public Point2D getPopupPoint ( ) { return popupPoint ; } public void setPopupPoint ( Point2D popupPoint ) { this . popupPoint = popupPoint ; } } </DOCUMENT>
<DOCUMENT_ID="dslomov/intellij-community/tree/master/java/compiler/impl/src/com/intellij/compiler/impl/javaCompiler/javac/JavacCompiler.java"> package com . intellij . compiler . impl . javaCompiler . javac ; import com . intellij . compiler . impl . javaCompiler . BackendCompiler ; import com . intellij . openapi . compiler . CompilerBundle ; import com . intellij . openapi . fileTypes . FileType ; import com . intellij . openapi . fileTypes . StdFileTypes ; import com . intellij . openapi . options . Configurable ; import com . intellij . openapi . project . Project ; import org . jetbrains . annotations . NonNls ; import org . jetbrains . annotations . NotNull ; import org . jetbrains . jps . model . java . compiler . JavaCompilers ; import java . util . Collections ; import java . util . Set ; public class JavacCompiler implements BackendCompiler { private final Project myProject ; public JavacCompiler ( Project project ) { myProject = project ; } @ NotNull @ NonNls public String getId ( ) { return JavaCompilers . JAVAC_ID ; } @ NotNull public String getPresentableName ( ) { return CompilerBundle . message ( " compiler . javac . name " ) ; } @ NotNull public Configurable createConfigurable ( ) { return new JavacConfigurable ( JavacConfiguration . getOptions ( myProject , JavacConfiguration . class ) ) ; } @ NotNull public Set < FileType > getCompilableFileTypes ( ) { return Collections . < FileType > singleton ( StdFileTypes . JAVA ) ; } } </DOCUMENT>
<DOCUMENT_ID="jondong/crosswalk/tree/master/third_party/lzma_sdk/src/SevenZip/LzmaAlone.java"> package SevenZip ; public class LzmaAlone { static public class CommandLine { public static final int kEncode = 0 ; public static final int kDecode = 1 ; public static final int kBenchmak = 2 ; public int Command = - 1 ; public int NumBenchmarkPasses = 10 ; public int DictionarySize = 1 << 23 ; public boolean DictionarySizeIsDefined = false ; public int Lc = 3 ; public int Lp = 0 ; public int Pb = 2 ; public int Fb = 128 ; public boolean FbIsDefined = false ; public boolean Eos = false ; public int Algorithm = 2 ; public int MatchFinder = 1 ; public String InFile ; public String OutFile ; boolean ParseSwitch ( String s ) { if ( s . startsWith ( " d " ) ) { DictionarySize = 1 << Integer . parseInt ( s . substring ( 1 ) ) ; DictionarySizeIsDefined = true ; } else if ( s . startsWith ( " fb " ) ) { Fb = Integer . parseInt ( s . substring ( 2 ) ) ; FbIsDefined = true ; } else if ( s . startsWith ( " a " ) ) Algorithm = Integer . parseInt ( s . substring ( 1 ) ) ; else if ( s . startsWith ( " lc " ) ) Lc = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " lp " ) ) Lp = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " pb " ) ) Pb = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " eos " ) ) Eos = true ; else if ( s . startsWith ( " mf " ) ) { String mfs = s . substring ( 2 ) ; if ( mfs . equals ( " bt2" ) ) MatchFinder = 0 ; else if ( mfs . equals ( " bt4" ) ) MatchFinder = 1 ; else if ( mfs . equals ( " bt4b " ) ) MatchFinder = 2 ; else return false ; } else return false ; return true ; } public boolean Parse ( String [ ] args ) throws Exception { int pos = 0 ; boolean switchMode = true ; for ( int i = 0 ; i < args . length ; i ++ ) { String s = args [ i ] ; if ( s . length ( ) == 0 ) return false ; if ( switchMode ) { if ( s . compareTo ( " - - " ) == 0 ) { switchMode = false ; continue ; } if ( s . charAt ( 0 ) == ' - ' ) { String sw = s . substring ( 1 ) . toLowerCase ( ) ; if ( sw . length ( ) == 0 ) return false ; try { if ( ! ParseSwitch ( sw ) ) return false ; } catch ( NumberFormatException e ) { return false ; } continue ; } } if ( pos == 0 ) { if ( s . equalsIgnoreCase ( " e " ) ) Command = kEncode ; else if ( s . equalsIgnoreCase ( " d " ) ) Command = kDecode ; else if ( s . equalsIgnoreCase ( " b " ) ) Command = kBenchmak ; else return false ; } else if ( pos == 1 ) { if ( Command == kBenchmak ) { try { NumBenchmarkPasses = Integer . parseInt ( s ) ; if ( NumBenchmarkPasses < 1 ) return false ; } catch ( NumberFormatException e ) { return false ; } } else InFile = s ; } else if ( pos == 2 ) OutFile = s ; else return false ; pos ++ ; continue ; } return true ; } } static void PrintHelp ( ) { System . out . println ( " \n Usage : ▁ ▁ LZMA ▁ < e | d > ▁ [ < switches > . . . ] ▁ inputFile ▁ outputFile \n " + " ▁ ▁ e : ▁ encode ▁ file \n " + " ▁ ▁ d : ▁ decode ▁ file \n " + " ▁ ▁ b : ▁ Benchmark \n " + " < Switches > \n " + " ▁ ▁ - d { N } : ▁ ▁ set ▁ dictionary ▁ - ▁ [ 0,28 ] , ▁ default : ▁ 23 ▁ ( 8MB ) \n " + " ▁ ▁ - fb { N } : ▁ set ▁ number ▁ of ▁ fast ▁ bytes ▁ - ▁ [ 5 , ▁ 273 ] , ▁ default : ▁ 128 \n " + " ▁ ▁ - lc { N } : ▁ set ▁ number ▁ of ▁ literal ▁ context ▁ bits ▁ - ▁ [ 0 , ▁ 8 ] , ▁ default : ▁ 3 \n " + " ▁ ▁ - lp { N } : ▁ set ▁ number ▁ of ▁ literal ▁ pos ▁ bits ▁ - ▁ [ 0 , ▁ 4 ] , ▁ default : ▁ 0 \n " + " ▁ ▁ - pb { N } : ▁ set ▁ number ▁ of ▁ pos ▁ bits ▁ - ▁ [ 0 , ▁ 4 ] , ▁ default : ▁ 2 \n " + " ▁ ▁ - mf { MF _ ID } : ▁ set ▁ Match ▁ Finder : ▁ [ bt2 , ▁ bt4 ] , ▁ default : ▁ bt4 \n " + " ▁ ▁ - eos : ▁ ▁ ▁ write ▁ End ▁ Of ▁ Stream ▁ marker \n " ) ; } public static void main ( String [ ] args ) throws Exception { System . out . println ( " \n LZMA ▁ ( Java ) ▁ 4.61 ▁ ▁ 2008-11-23 \n " ) ; if ( args . length < 1 ) { PrintHelp ( ) ; return ; } CommandLine params = new CommandLine ( ) ; if ( ! params . Parse ( args ) ) { System . out . println ( " \n Incorrect ▁ command " ) ; return ; } if ( params . Command == CommandLine . kBenchmak ) { int dictionary = ( 1 << 21 ) ; if ( params . DictionarySizeIsDefined ) dictionary = params . DictionarySize ; if ( params . MatchFinder > 1 ) throw new Exception ( " Unsupported ▁ match ▁ finder " ) ; SevenZip . LzmaBench . LzmaBenchmark ( params . NumBenchmarkPasses , dictionary ) ; } else if ( params . Command == CommandLine . kEncode || params . Command == CommandLine . kDecode ) { java . io . File inFile = new java . io . File ( params . InFile ) ; java . io . File outFile = new java . io . File ( params . OutFile ) ; java . io . BufferedInputStream inStream = new java . io . BufferedInputStream ( new java . io . FileInputStream ( inFile ) ) ; java . io . BufferedOutputStream outStream = new java . io . BufferedOutputStream ( new java . io . FileOutputStream ( outFile ) ) ; boolean eos = false ; if ( params . Eos ) eos = true ; if ( params . Command == CommandLine . kEncode ) { SevenZip . Compression . LZMA . Encoder encoder = new SevenZip . Compression . LZMA . Encoder ( ) ; if ( ! encoder . SetAlgorithm ( params . Algorithm ) ) throw new Exception ( " Incorrect ▁ compression ▁ mode " ) ; if ( ! encoder . SetDictionarySize ( params . DictionarySize ) ) throw new Exception ( " Incorrect ▁ dictionary ▁ size " ) ; if ( ! encoder . SetNumFastBytes ( params . Fb ) ) throw new Exception ( " Incorrect ▁ - fb ▁ value " ) ; if ( ! encoder . SetMatchFinder ( params . MatchFinder ) ) throw new Exception ( " Incorrect ▁ - mf ▁ value " ) ; if ( ! encoder . SetLcLpPb ( params . Lc , params . Lp , params . Pb ) ) throw new Exception ( " Incorrect ▁ - lc ▁ or ▁ - lp ▁ or ▁ - pb ▁ value " ) ; encoder . SetEndMarkerMode ( eos ) ; encoder . WriteCoderProperties ( outStream ) ; long fileSize ; if ( eos ) fileSize = - 1 ; else fileSize = inFile . length ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) outStream . write ( ( int ) ( fileSize > > > ( 8 * i ) ) & 0xFF ) ; encoder . Code ( inStream , outStream , - 1 , - 1 , null ) ; } else { int propertiesSize = 5 ; byte [ ] properties = new byte [ propertiesSize ] ; if ( inStream . read ( properties , 0 , propertiesSize ) != propertiesSize ) throw new Exception ( " input ▁ . lzma ▁ file ▁ is ▁ too ▁ short " ) ; SevenZip . Compression . LZMA . Decoder decoder = new SevenZip . Compression . LZMA . Decoder ( ) ; if ( ! decoder . SetDecoderProperties ( properties ) ) throw new Exception ( " Incorrect ▁ stream ▁ properties " ) ; long outSize = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int v = inStream . read ( ) ; if ( v < 0 ) throw new Exception ( " Can ' t ▁ read ▁ stream ▁ size " ) ; outSize |= ( ( long ) v ) << ( 8 * i ) ; } if ( ! decoder . Code ( inStream , outStream , outSize ) ) throw new Exception ( " Error ▁ in ▁ data ▁ stream " ) ; } outStream . flush ( ) ; outStream . close ( ) ; inStream . close ( ) ; } else throw new Exception ( " Incorrect ▁ command " ) ; return ; } } </DOCUMENT>
<DOCUMENT_ID="ajhalani/elasticsearch/tree/master/src/main/java/org/elasticsearch/common/logging/log4j/LogConfigurator.java"> package org . elasticsearch . common . logging . log4j ; import com . google . common . collect . ImmutableMap ; import org . apache . log4j . PropertyConfigurator ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . collect . MapBuilder ; import org . elasticsearch . common . settings . ImmutableSettings ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . Environment ; import org . elasticsearch . env . FailedToResolveConfigException ; import java . io . IOException ; import java . net . MalformedURLException ; import java . nio . file . * ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . EnumSet ; import java . util . Map ; import java . util . Properties ; import static org . elasticsearch . common . settings . ImmutableSettings . settingsBuilder ; public class LogConfigurator { private static boolean loaded ; private static ImmutableMap < String , String > replacements = new MapBuilder < String , String > ( ) . put ( " console " , " org . elasticsearch . common . logging . log4j . ConsoleAppender " ) . put ( " async " , " org . apache . log4j . AsyncAppender " ) . put ( " dailyRollingFile " , " org . apache . log4j . DailyRollingFileAppender " ) . put ( " externallyRolledFile " , " org . apache . log4j . ExternallyRolledFileAppender " ) . put ( " file " , " org . apache . log4j . FileAppender " ) . put ( " jdbc " , " org . apache . log4j . jdbc . JDBCAppender " ) . put ( " jms " , " org . apache . log4j . net . JMSAppender " ) . put ( " lf5" , " org . apache . log4j . lf5 . LF5Appender " ) . put ( " ntevent " , " org . apache . log4j . nt . NTEventLogAppender " ) . put ( " null " , " org . apache . log4j . NullAppender " ) . put ( " rollingFile " , " org . apache . log4j . RollingFileAppender " ) . put ( " smtp " , " org . apache . log4j . net . SMTPAppender " ) . put ( " socket " , " org . apache . log4j . net . SocketAppender " ) . put ( " socketHub " , " org . apache . log4j . net . SocketHubAppender " ) . put ( " syslog " , " org . apache . log4j . net . SyslogAppender " ) . put ( " telnet " , " org . apache . log4j . net . TelnetAppender " ) . put ( " simple " , " org . apache . log4j . SimpleLayout " ) . put ( " html " , " org . apache . log4j . HTMLLayout " ) . put ( " pattern " , " org . apache . log4j . PatternLayout " ) . put ( " consolePattern " , " org . apache . log4j . PatternLayout " ) . put ( " ttcc " , " org . apache . log4j . TTCCLayout " ) . put ( " xml " , " org . apache . log4j . XMLLayout " ) . immutableMap ( ) ; public static void configure ( Settings settings ) { if ( loaded ) { return ; } loaded = true ; Environment environment = new Environment ( settings ) ; ImmutableSettings . Builder settingsBuilder = settingsBuilder ( ) . put ( settings ) ; resolveConfig ( environment , settingsBuilder ) ; settingsBuilder . putProperties ( " elasticsearch . " , System . getProperties ( ) ) . putProperties ( " es . " , System . getProperties ( ) ) . replacePropertyPlaceholders ( ) ; Properties props = new Properties ( ) ; for ( Map . Entry < String , String > entry : settingsBuilder . build ( ) . getAsMap ( ) . entrySet ( ) ) { String key = " log4j . " + entry . getKey ( ) ; String value = entry . getValue ( ) ; if ( replacements . containsKey ( value ) ) { value = replacements . get ( value ) ; } if ( key . endsWith ( " . value " ) ) { props . setProperty ( key . substring ( 0 , key . length ( ) - " . value " . length ( ) ) , value ) ; } else if ( key . endsWith ( " . type " ) ) { props . setProperty ( key . substring ( 0 , key . length ( ) - " . type " . length ( ) ) , value ) ; } else { props . setProperty ( key , value ) ; } } PropertyConfigurator . configure ( props ) ; } public static void resolveConfig ( Environment env , final ImmutableSettings . Builder settingsBuilder ) { try { Files . walkFileTree ( env . configFile ( ) . toPath ( ) , EnumSet . of ( FileVisitOption . FOLLOW_LINKS ) , Integer . MAX_VALUE , new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { if ( file . getFileName ( ) . toString ( ) . startsWith ( " logging . " ) ) { loadConfig ( file , settingsBuilder ) ; } return FileVisitResult . CONTINUE ; } } ) ; } catch ( IOException ioe ) { throw new ElasticsearchException ( " Failed ▁ to ▁ load ▁ logging ▁ configuration " , ioe ) ; } } public static void loadConfig ( Path file , ImmutableSettings . Builder settingsBuilder ) { try { settingsBuilder . loadFromUrl ( file . toUri ( ) . toURL ( ) ) ; } catch ( FailedToResolveConfigException | NoClassDefFoundError | MalformedURLException e ) { } } } </DOCUMENT>
<DOCUMENT_ID="rsf/RSFUtil/tree/master/src/uk/org/ponder/rsf/flow/jsfnav/support/NavigationRule.java"> package uk . org . ponder . rsf . flow . jsfnav . support ; import java . util . List ; import uk . org . ponder . rsf . viewstate . ViewParameters ; public class NavigationRule { public ViewParameters fromViewId ; public List navigationCases ; } </DOCUMENT>
<DOCUMENT_ID="IllusionRom-deprecated/android_platform_tools_idea/tree/master/java/java-analysis-impl/src/com/intellij/codeInspection/NumericOverflowInspection.java"> package com . intellij . codeInspection ; import com . intellij . codeInsight . daemon . GroupNames ; import com . intellij . codeInsight . daemon . JavaErrorMessages ; import com . intellij . openapi . project . Project ; import com . intellij . openapi . util . Key ; import com . intellij . psi . * ; import com . intellij . psi . util . ConstantEvaluationOverflowException ; import com . intellij . psi . util . TypeConversionUtil ; import org . jetbrains . annotations . Nls ; import org . jetbrains . annotations . NotNull ; public class NumericOverflowInspection extends BaseJavaBatchLocalInspectionTool { private static final Key < String > HAS_OVERFLOW_IN_CHILD = Key . create ( " HAS _ OVERFLOW _ IN _ CHILD " ) ; @ Nls @ NotNull @ Override public String getGroupDisplayName ( ) { return GroupNames . NUMERIC_GROUP_NAME ; } @ Nls @ NotNull @ Override public String getDisplayName ( ) { return " Numeric ▁ overflow " ; } @ NotNull @ Override public String getShortName ( ) { return " NumericOverflow " ; } @ NotNull @ Override public PsiElementVisitor buildVisitor ( @ NotNull final ProblemsHolder holder , boolean isOnTheFly ) { return new JavaElementVisitor ( ) { @ Override public void visitReferenceExpression ( PsiReferenceExpression expression ) { visitExpression ( expression ) ; } @ Override public void visitExpression ( PsiExpression expression ) { boolean info = hasOverflow ( expression , holder . getProject ( ) ) ; if ( info ) { holder . registerProblem ( expression , JavaErrorMessages . message ( " numeric . overflow . in . expression " ) , ProblemHighlightType . GENERIC_ERROR_OR_WARNING ) ; } } } ; } private static boolean hasOverflow ( PsiExpression expr , @ NotNull Project project ) { if ( ! TypeConversionUtil . isNumericType ( expr . getType ( ) ) ) return false ; boolean overflow = false ; try { if ( expr . getUserData ( HAS_OVERFLOW_IN_CHILD ) == null ) { JavaPsiFacade . getInstance ( project ) . getConstantEvaluationHelper ( ) . computeConstantExpression ( expr , true ) ; } else { overflow = true ; } } catch ( ConstantEvaluationOverflowException e ) { overflow = true ; } finally { PsiElement parent = expr . getParent ( ) ; if ( overflow && parent instanceof PsiExpression ) { parent . putUserData ( HAS_OVERFLOW_IN_CHILD , " " ) ; } } return overflow ; } } </DOCUMENT>
<DOCUMENT_ID="yuanke/hadoop-hbase/tree/master/src/test/org/apache/hadoop/mapred/TestKillCompletedJob.java"> package org . apache . hadoop . mapred ; import java . io . * ; import java . net . * ; import junit . framework . TestCase ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . hdfs . MiniDFSCluster ; import org . apache . hadoop . fs . FileSystem ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . io . IntWritable ; import org . apache . hadoop . io . Text ; public class TestKillCompletedJob extends TestCase { static Boolean launchWordCount ( String fileSys , String jobTracker , JobConf conf , String input , int numMaps , int numReduces ) throws IOException { final Path inDir = new Path ( " / testing / wc / input " ) ; final Path outDir = new Path ( " / testing / wc / output " ) ; FileSystem fs = FileSystem . get ( URI . create ( fileSys ) , conf ) ; fs . delete ( outDir , true ) ; if ( ! fs . mkdirs ( inDir ) ) { throw new IOException ( " Mkdirs ▁ failed ▁ to ▁ create ▁ " + inDir . toString ( ) ) ; } { DataOutputStream file = fs . create ( new Path ( inDir , " part - 0" ) ) ; file . writeBytes ( input ) ; file . close ( ) ; } FileSystem . setDefaultUri ( conf , fileSys ) ; conf . set ( " mapred . job . tracker " , jobTracker ) ; conf . setJobName ( " wordcount " ) ; conf . setInputFormat ( TextInputFormat . class ) ; conf . setOutputKeyClass ( Text . class ) ; conf . setOutputValueClass ( IntWritable . class ) ; conf . setMapperClass ( WordCount . MapClass . class ) ; conf . setCombinerClass ( WordCount . Reduce . class ) ; conf . setReducerClass ( WordCount . Reduce . class ) ; FileInputFormat . setInputPaths ( conf , inDir ) ; FileOutputFormat . setOutputPath ( conf , outDir ) ; conf . setNumMapTasks ( numMaps ) ; conf . setNumReduceTasks ( numReduces ) ; RunningJob rj = JobClient . runJob ( conf ) ; JobID jobId = rj . getID ( ) ; if ( rj . isSuccessful ( ) ) { System . out . println ( " Job ▁ Id : " + jobId + " ▁ completed ▁ successfully . ▁ Killing ▁ it ▁ now " ) ; rj . killJob ( ) ; } return rj . isSuccessful ( ) ; } public void testKillCompJob ( ) throws IOException { String namenode = null ; MiniDFSCluster dfs = null ; MiniMRCluster mr = null ; FileSystem fileSys = null ; try { final int taskTrackers = 1 ; Configuration conf = new Configuration ( ) ; dfs = new MiniDFSCluster ( conf , 1 , true , null ) ; fileSys = dfs . getFileSystem ( ) ; namenode = fileSys . getUri ( ) . toString ( ) ; mr = new MiniMRCluster ( taskTrackers , namenode , 3 ) ; JobConf jobConf = new JobConf ( ) ; Boolean result ; final String jobTrackerName = " localhost : " + mr . getJobTrackerPort ( ) ; result = launchWordCount ( namenode , jobTrackerName , jobConf , " Small ▁ text \n " , 1 , 0 ) ; assertTrue ( result ) ; } finally { if ( dfs != null ) { dfs . shutdown ( ) ; } if ( mr != null ) { mr . shutdown ( ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="Communote/communote-server/tree/master/communote/persistence/src/main/java/com/communote/server/core/tag/TagStoreNotFoundException.java"> package com . communote . server . core . tag ; import com . communote . server . api . core . common . NotFoundException ; public class TagStoreNotFoundException extends NotFoundException { private static final long serialVersionUID = - 5089679368783279854L ; public TagStoreNotFoundException ( String message ) { super ( message ) ; } } </DOCUMENT>
