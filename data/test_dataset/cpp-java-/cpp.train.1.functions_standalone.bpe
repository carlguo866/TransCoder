int readPageMetadata ( uint8_t * buf , uint32_t * len , int compact , struct PageMetadata_4C * * ppageMetdata ) { * ppageMetdata = ( struct PageMetadata_4C * ) palloc0 ( sizeof ( struct PageMetadata_4C ) ) ; bool compactBool = ( compact == 1 ) ? true : false ; int iret = MetadataUtil :: readPageMetadata ( buf , len , compactBool , * ppageMetdata ) ; return iret ; }
int writePageMetadata ( uint8_t * * buf , uint32_t * len , struct PageMetadata_4C * ppageMetadata ) { int iret = MetadataUtil :: writePageMetadata ( buf , len , ppageMetadata ) ; return iret ; }
int writeColumnChunkMetadata ( uint8_t * * buf , uint32_t * len , struct ColumnChunkMetadata_4C * blockMetadata ) { int iret = MetadataUtil :: writeColumnChunkMetadata ( buf , len , blockMetadata ) ; return iret ; }
void func ( ) { auto x = " TABSYMBOL test\t ▁ TABSYMBOL ▁ TABSYMBOL ▁ TABSYMBOL TABSYMBOL . . . ▁ ▁ ▁ ? ? ? " ; }
void func ( ) { auto x = " TABSYMBOL test\t ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . . . ▁ ▁ ▁ ? ? ? " ; }
expr mk_delayed_cc_eq_proof ( expr const & e1 , expr const & e2 ) { expr args [ 2 ] = { e1 , e2 } ; return mk_macro ( * g_cc_proof_macro , 2 , args ) ; }
bool is_delayed_cc_eq_proof ( expr const & e ) { return is_macro ( e ) && dynamic_cast < cc_proof_macro_cell const * > ( macro_def ( e ) . raw ( ) ) ; }
expr mark_cc_theory_proof ( expr const & pr ) { return mk_annotation ( * g_theory_proof , pr ) ; }
bool is_cc_theory_proof ( expr const & e ) { return is_annotation ( e , * g_theory_proof ) ; }
expr get_cc_@@ theory_proof_arg ( expr const & pr ) { lean_assert ( is_cc_theory_proof ( pr ) ) ; return get_annot@@ ation_arg ( pr ) ; }
expr visit_macro ( expr const & e ) { if ( is_delayed_cc_eq_proof ( e ) ) { expr const & lhs = macro_arg ( e , 0 ) ; expr const & rhs = macro_arg ( e , 1 ) ; return * m_cc . get_eq_proof ( lhs , rhs ) ; } else { return replace_visitor :: visit_macro ( e ) ; } }
expr expand_delayed_cc_proofs ( congruence_closure const & cc , expr const & e ) { return expand_delayed_cc_proofs_fn ( cc ) ( e ) ; }
void initialize_smt_util ( ) { g_cc_proof_name = new name ( " cc _ proof " ) ; g_cc_proof_macro = new macro_definition ( new cc_proof_macro_cell ( ) ) ; g_theory_proof = new name ( " th _ proof " ) ; register_annotation ( * g_theory_proof ) ; }
void finalize_smt_util ( ) { delete g_cc_proof_macro ; delete g_cc_proof_name ; delete g_theory_proof ; }
bool pair_compare ( const pair < int , long long > & a , const pair < int , long long > & b ) { return a . second == b . second ? a . first < b . first : a . second < b . second ; }
int main ( ) { int N ; cin >> N ; vector < pair < long long , long long > > pos ; long long avg_x = 0 , avg_y = 0 ; for ( int i = 0 ; i < N ; ++ i ) { int x , y ; cin >> x >> y ; pos . push_back ( make_pair ( x , y ) ) ; avg_x += x ; avg_y += y ; } avg_x /= N , avg_y /= N ; vector < pair < int , long long > > ans ; for ( int i = 0 ; i < N ; ++ i ) { long long dis = max ( abs ( pos [ i ] . first - avg_x ) , abs ( pos [ i ] . second - avg_y ) ) ; ans . push_back ( make_pair ( i , dis ) ) ; } sort ( ans . begin ( ) , ans . end ( ) , pair_compare ) ; long long ret = 1e16 ; for ( int i = 0 ; i < min ( M , int ( ans . size ( ) ) ) ; ++ i ) { long long tmp = 0 ; for ( int j = 0 ; j < N ; ++ j ) tmp += max ( abs ( pos [ j ] . first - pos [ ans [ i ] . first ] . first ) , abs ( pos [ j ] . second - pos [ ans [ i ] . first ] . second ) ) ; ret = min ( ret , tmp ) ; } cout << ret << endl ; return 0 ; }
void bft ( Tree * root ) { if ( root == NULL ) return ; if ( root -> visited ) return ; root -> visited = true ; printf ( " % c ▁ \n " , root -> data ) ; std :: queue < Tree * > * newQue = new std :: queue < Tree * > ( ) ; int Size = root -> children . size ( ) ; for ( int i = 0 ; i < Size ; i ++ ) { Tree * child = root -> children [ i ] ; if ( child != NULL ) newQue -> push ( child ) ; } for ( int i = 0 ; i < Size ; i ++ ) { Tree * child = newQue -> front ( ) ; if ( child != NULL ) bft ( child ) ; newQue -> pop ( ) ; } return ; }
void insert ( Tree * root , char data ) { Tree * newTree = new Tree ( ) ; newTree -> data = data ; newTree -> visited = false ; root -> children . push_back ( newTree ) ; return ; }
int main ( ) { Tree * root = new Tree ( ) ; root -> data = ' a ' ; Tree * leftChild = new Tree { } ; leftChild -> data = ' b ' ; Tree * rightChild = new Tree ( ) ; rightChild -> data = ' c ' ; root -> children . push_back ( leftChild ) ; root -> children . push_back ( rightChild ) ; cout << " start ▁ doing ▁ BFT ▁ in ▁ one ▁ way ▁ " << endl ; bft ( root ) ; delete root ; root = new Tree ( ) ; root -> data = ' a ' ; insert ( root , ' d ' ) ; insert ( root , ' e ' ) ; cout << " start ▁ doing ▁ BFT ▁ in ▁ 2nd ▁ way " << endl ; bft ( root ) ; cout << " done ▁ DFT ▁ " << endl ; return 0 ; }
void help ( ) { fprintf ( stderr , " Loader ▁ gs ▁ file \n " ) ; fprintf ( stderr , " ARG1 ▁ GSdx ▁ plugin \n " ) ; fprintf ( stderr , " ARG2 ▁ . gs ▁ file \n " ) ; fprintf ( stderr , " ARG3 ▁ Ini ▁ directory \n " ) ; if ( handle ) { dlclose ( handle ) ; } exit ( 1 ) ; }
char * read_env ( const char * var ) { char * v = getenv ( var ) ; if ( ! v ) { fprintf ( stderr , " Failed ▁ to ▁ get ▁ % s \n " , var ) ; help ( ) ; } return v ; }
int main ( int argc , char * argv [ ] ) { if ( argc < 1 ) help ( ) ; char * plugin ; char * gs ; if ( argc > 2 ) { plugin = argv [ 1 ] ; gs = argv [ 2 ] ; } else { plugin = read_env ( " GSDUMP _ SO " ) ; gs = argv [ 1 ] ; } handle = dlopen ( plugin , RTLD_LAZY | RTLD_GLOBAL ) ; if ( handle == NULL ) { fprintf ( stderr , " Failed ▁ to ▁ dlopen ▁ plugin ▁ % s \n " , plugin ) ; help ( ) ; } __attribute__ ( ( stdcall ) ) void ( * GSsetSettingsDir_ptr ) ( const char * ) ; __attribute__ ( ( stdcall ) ) void ( * GSReplay_ptr ) ( char * , int ) ; * ( void * * ) ( & GSsetSettingsDir_ptr ) = dlsym ( handle , " GSsetSettingsDir " ) ; * ( void * * ) ( & GSReplay_ptr ) = dlsym ( handle , " GSReplay " ) ; if ( argc == 2 ) { char * ini = read_env ( " GSDUMP _ CONF " ) ; GSsetSettingsDir_ptr ( ini ) ; } else if ( argc == 4 ) { ( void ) GSsetSettingsDir_ptr ( argv [ 3 ] ) ; } else if ( argc == 3 ) { char * val = read_env ( " HOME " ) ; std :: string ini_dir ( val ) ; ini_dir += " / . config / pcsx2 / inis " ; GSsetSettingsDir_ptr ( ini_dir . c_str ( ) ) ; fprintf ( stderr , " default ▁ ini ▁ dir ▁ only ▁ supported ▁ on ▁ XDG \n " ) ; help ( ) ; } GSReplay_ptr ( gs , 12 ) ; if ( handle ) { dlclose ( handle ) ; } }
DEFINE_TRACE ( HTMLContentElement ) { visitor -> trace ( m_filter ) ; InsertionPoint :: trace ( visitor ) ; }
static inline bool includesDisallowedPseudoClass ( const CSSSelector & selector ) { if ( selector . pseudoType ( ) == CSSSelector :: PseudoNot ) { const CSSSelector * subSelector = selector . selectorList ( ) -> first ( ) ; return subSelector -> match ( ) == CSSSelector :: PseudoClass ; } return selector . match ( ) == CSSSelector :: PseudoClass ; }
selector = m_selectorList . next ( * selector ) ) { if ( ! selector -> isCompound ( ) ) return false ; for ( const CSSSelector * subSelector = selector ; subSelector ; subSelector = subSelector -> tagHistory ( ) ) { if ( includesDisallowedPseudoClass ( * subSelector ) ) return false ; } }
void ImHere ( ) { DEBUG_LOG ( CPU , " JIT ▁ Here : ▁ % 08x " , currentMIPS -> pc ) ; }
static bool shouldUseCoreText ( UChar * buffer , unsigned bufferLength , const SimpleFontData * fontData ) { if ( fontData -> platformData ( ) . widthVariant ( ) != Regular@@ Width || fontData -> hasVerticalGlyphs ( ) ) { for ( unsigned i = 0 ; i < bufferLength ; ++ i ) { if ( ! Font :: isCJKIdeograph ( buffer [ i ] ) ) return true ; } } return false ; }
void _sendResizeEvents ( QWidget * target ) { QResizeEvent e ( target -> size ( ) , QSize ( ) ) ; QApplication :: sendEvent ( target , & e ) ; const QObjectList children = target -> children ( ) ; for ( int i = 0 ; i < children . size ( ) ; ++ i ) { QWidget * child = static_cast < QWidget * > ( children . at ( i ) ) ; if ( child -> isWidgetType ( ) && ! child -> isWindow ( ) && child -> testAttribute ( Qt :: WA_PendingResizeEvent ) ) { _sendResizeEvents ( child ) ; } } }
void myEnsureResized ( QWidget * target ) { if ( target && ( target -> testAttribute ( Qt :: WA_PendingResizeEvent ) || ! target -> testAttribute ( Qt :: WA_WState@@ _Created ) ) ) { _sendResizeEvents ( target ) ; } }
QPixmap myGra@@ b ( QWidget * target , const QRect & rect ) { if ( ! cRetina ( ) ) return target -> grab ( rect ) ; myEnsureResized ( target ) ; qreal dpr = App :: app ( ) -> devicePixelRatio ( ) ; QPixmap result ( rect . size ( ) * dpr ) ; result . setDevicePixelRatio ( dpr ) ; result . fill ( Qt :: transparent ) ; target -> render ( & result , QPoint ( ) , QRegion ( rect ) , QWidget :: DrawWindowBackground | QWidget :: DrawChildren | QWidget :: IgnoreMask ) ; return result ; }
DEFINE_NODE_FACTORY ( SVGFontFaceUriElement ) SVGFontFaceUriElement :: ~ SVGFontFaceUriElement ( ) { if ( m_resource ) m_resource -> removeClient ( this ) ; }
void getUserInfo ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMUsersInfoReq msg ; IM :: Buddy :: IMUsersInfoRsp msgResp ; if ( msg . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { CImPdu * pPduRes = new CImPdu ; uint32_t from_user_id = msg . user_id ( ) ; uint32_t userCount = msg . user_id_list_size ( ) ; std :: list < uint32_t > idList ; for ( uint32_t i = 0 ; i < userCount ; ++ i ) { idList . push_back ( msg . user_id_list ( i ) ) ; } std :: list < IM :: BaseDefine :: UserInfo > lsUser ; CUserModel :: getInstance ( ) -> getUsers ( idList , lsUser ) ; msgResp . set_user_id ( from_user_id ) ; for ( list < IM :: BaseDefine :: UserInfo > :: iterator it = lsUser . begin ( ) ; it != lsUser . end ( ) ; ++ it ) { IM :: BaseDefine :: UserInfo * pUser = msgResp . add_user_info@@ _list ( ) ; pUser -> set_user_id ( it -> user_id ( ) ) ; pUser -> set_user_gender ( it -> user_gender ( ) ) ; pUser -> set_user_nick_name ( it -> user_nick_name ( ) ) ; pUser -> set_avatar_url ( it -> avatar_url ( ) ) ; pUser -> set_sign_info ( it -> sign_info ( ) ) ; pUser -> set_department_id ( it -> department_id ( ) ) ; pUser -> set_email ( it -> email ( ) ) ; pUser -> set_user_real_name ( it -> user_real_name ( ) ) ; pUser -> set_user_tel ( it -> user_tel ( ) ) ; pUser -> set_user_domain ( it -> user_domain ( ) ) ; pUser -> set_status ( it -> status ( ) ) ; } log ( " userId = % u , ▁ userCnt = % u " , from_user_id , userCount ) ; msgResp . set_attach_data ( msg . attach_data ( ) ) ; pPduRes -> SetPBMsg ( & msgResp ) ; pPduRes -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pPduRes -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pPduRes -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_USER_INFO_RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pPduRes ) ; } else { log ( " parse ▁ pb ▁ failed " ) ; } }
void getChangedUser ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMAllUserReq msg ; IM :: Buddy :: IMAllUserRsp msgResp ; if ( msg . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { CImPdu * pPduRes = new CImPdu ; uint32_t nReqId = msg . user_id ( ) ; uint32_t nLastTime = msg . latest_update_time ( ) ; uint32_t nLastUpdate = CSyncCenter :: getInstance ( ) -> getLastUpdate ( ) ; list < IM :: BaseDefine :: UserInfo > lsUsers ; if ( nLastUpdate > nLastTime ) { list < uint32_t > lsIds ; CUserModel :: getInstance ( ) -> getChangedId ( nLastTime , lsIds ) ; CUserModel :: getInstance ( ) -> getUsers ( lsIds , lsUsers ) ; } msgResp . set_user_id ( nReqId ) ; msgResp . set_latest_update_time ( nLastTime ) ; for ( list < IM :: BaseDefine :: UserInfo > :: iterator it = lsUsers . begin ( ) ; it != lsUsers . end ( ) ; ++ it ) { IM :: BaseDefine :: UserInfo * pUser = msgResp . add_user_list ( ) ; pUser -> set_user_id ( it -> user_id ( ) ) ; pUser -> set_user_gender ( it -> user_gender ( ) ) ; pUser -> set_user_nick_name ( it -> user_nick_name ( ) ) ; pUser -> set_avatar_url ( it -> avatar_url ( ) ) ; pUser -> set_sign_info ( it -> sign_info ( ) ) ; pUser -> set_department_id ( it -> department_id ( ) ) ; pUser -> set_email ( it -> email ( ) ) ; pUser -> set_user_real_name ( it -> user_real_name ( ) ) ; pUser -> set_user_tel ( it -> user_tel ( ) ) ; pUser -> set_user_domain ( it -> user_domain ( ) ) ; pUser -> set_status ( it -> status ( ) ) ; } log ( " userId = % u , nLastUpdate = % u , ▁ last _ time = % u , ▁ userCnt = % u " , nReqId , nLastUpdate , nLastTime , msgResp . user_list_size ( ) ) ; msgResp . set_attach_data ( msg . attach_data ( ) ) ; pPduRes -> SetPBMsg ( & msgResp ) ; pPduRes -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pPduRes -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pPduRes -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_ALL_USER_@@ RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pPduRes ) ; } else { log ( " parse ▁ pb ▁ failed " ) ; } }
void changeUserSignInfo ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMChangeSignInfoReq req ; IM :: Buddy :: IMChangeSignInfoRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; const string & sign_info = req . sign_info ( ) ; bool result = CUserModel :: getInstance ( ) -> updateUserSignInfo ( user_id , sign_info ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_sign_info ( sign_info ) ; log ( " changeUserSignInfo ▁ sucess , ▁ user _ id = % u , ▁ sign _ info = % s " , user_id , sign_info . c_str ( ) ) ; } else { log ( " changeUserSignInfo ▁ false , ▁ user _ id = % u , ▁ sign _ info = % s " , user_id , sign_info . c_str ( ) ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " changeUserSignInfo : ▁ IMChangeSignInfoReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } }
void doPushShield ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Login :: IMPushShieldReq req ; IM :: Login :: IMPushShieldRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; uint32_t shield_status = req . shield_status ( ) ; bool result = CUserModel :: getInstance ( ) -> updatePushShield ( user_id , shield_status ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_shield_status ( shield_status ) ; log ( " doPushShield ▁ sucess , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } else { log ( " doPushShield ▁ false , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_LOGIN ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_LOGIN_RES_PUSH_SHIELD ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " doPushShield : ▁ IMPushShieldReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } }
void doQueryPushShield ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Login :: IMQueryPushShieldReq req ; IM :: Login :: IMQueryPushShieldRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; uint32_t shield_status = 0 ; bool result = CUserModel :: getInstance ( ) -> getPushShield ( user_id , & shield_status ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_shield_status ( shield_status ) ; log ( " doQueryPushShield ▁ sucess , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } else { log ( " doQueryPushShield ▁ false , ▁ user _ id = % u " , user_id ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_LOGIN ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_LOGIN_RES_QUERY_PUSH_SHIELD ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " doQueryPushShield : ▁ IMQueryPushShieldReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } }
bool LoadFile ( WbConfig config , KeyId cameraPosition , IplImage * * camImg , QString fileName , CvPoint2D@@ 32f * offset , bool unWarp ) { bool successful = true ; Collection camerasCollection ( CamerasCollection ( ) ) ; Collection cameraPositionsCollection ( CameraPositionsCollection ( ) ) ; camerasCollection . SetConfig ( config ) ; cameraPositionsCollection . SetConfig ( config ) ; const KeyId camPosId = cameraPosition ; LOG_INFO ( QObject :: tr ( " Camera ▁ position ▁ id : ▁ % 1" ) . arg ( camPosId ) ) ; const WbConfig camPosConfig = cameraPositionsCollection . ElementById ( camPosId ) ; if ( camPosConfig . IsNull ( ) ) successful = false ; CvMat * cameraMtx = cvCreateMat ( 3 , 3 , CV_32F ) ; CvMat * distortionCoeffs = cvCreateMat ( 5 , 1 , CV_32F ) ; CvMat * inverseCoeffs = cvCreateMat ( 5 , 1 , CV_32F ) ; CvMat * rot = cvCreateMat ( 3 , 3 , CV_32F ) ; CvMat * trans = cvCreateMat ( 1 , 3 , CV_32F ) ; if ( successful ) { const KeyId camId = camPosConfig . GetKeyValue ( CameraPositionSchema :: cameraIdKey ) . ToKeyId ( ) ; LOG_INFO ( QObject :: tr ( " Camera ▁ id : ▁ % 1" ) . arg ( camId ) ) ; WbConfig cameraConfig = camerasCollection . ElementById ( camId ) ; if ( cameraConfig . IsNull ( ) ) successful = false ; if ( successful ) { const WbConfig cameraIntrisicConfig ( cameraConfig . GetSubConfig ( CalibrationSchema :: schemaName ) ) ; if ( cameraIntrisicConfig . IsNull ( ) ) successful = false ; if ( successful ) { const bool calibrationWasSuccessful = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: calibrationSuccessf@@ ulKey ) . ToBool ( ) ; const bool cameraMtxValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: cameraMatrixKey ) . ToCvMat ( * cameraMtx ) ; const bool distortionCoeffsValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: distortionCoefficientsKey ) . ToCvMat ( * distortionCoeffs ) ; const bool inverseCoeffsValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: invDistortion@@ CoefficientsKey ) . ToCvMat ( * inverseCoeffs ) ; successful = calibrationWasSuccessful && cameraMtxValid && distortionCoeffsValid && inverseCoeffsValid ; } const WbConfig cameraExtrisicConfig ( camPosConfig . GetSubConfig ( ExtrinsicCalibrationSchema :: schemaName ) ) ; if ( cameraExtrisicConfig . IsNull ( ) ) successful = false ; if ( successful ) { const bool rotMatValid = cameraExtrisicConfig . GetKeyValue ( ExtrinsicCalibrationSchema :: rotationMatrixKey ) . ToCvMat ( * rot ) ; const bool transValid = cameraExtrisicConfig . GetKeyValue ( ExtrinsicCalibrationSchema :: translationKey ) . ToCvMat ( * trans ) ; successful = rotMatValid && transValid ; } } } if ( successful ) { IplImage * imgGrey = cvLoadImage ( fileName . toAscii ( ) , CV_LOAD_@@ IMAGE_GRAY@@ SCALE ) ; if ( unWarp ) { * camImg = GroundPlaneUtility :: unwarpGroundPlane ( imgGrey , cameraMtx , distortionCoeffs , inverseCoeffs , rot , trans , offset ) ; } else { * camImg = cvClone@@ Image ( imgGrey ) ; } cvReleaseImage ( & imgGrey ) ; } cvReleaseMat ( & cameraMtx ) ; cvReleaseMat ( & distortionCoeffs ) ; cvReleaseMat ( & inverseCoeffs ) ; cvReleaseMat ( & rot ) ; cvReleaseMat ( & trans ) ; return successful ; }
bool CheckMapping@@ IsComplete ( WbConfig config ) { bool allMapped = true ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; bool found = false ; LOG_INFO ( QObject :: tr ( " Checking ▁ mapping ▁ for ▁ % 1 . " ) . arg ( camPosId ) ) ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( ( camPosId == camera1Id ) || ( camPosId == camera2Id ) ) { found = true ; break ; } } if ( ! found ) { allMapped = false ; break ; } } return allMapped ; }
bool IsBase ( WbConfig config , KeyId camId ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; bool base = false ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camId == camera1Id ) { base = true ; break ; } } return base ; }
bool IsRef ( WbConfig config , KeyId camId ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; bool ref = false ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camId == camera2Id ) { ref = true ; break ; } } return ref ; }
bool CheckRoot@@ Mapping ( WbConfig config , KeyId rootId ) { bool allMapped = true ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; if ( ( camPosId != rootId ) && IsRef ( config , camPosId ) ) { LOG_INFO ( QObject :: tr ( " Find ▁ chain ▁ for ▁ % 1 ▁ - ▁ % 2 . " ) . arg ( camPosId ) . arg ( rootId ) ) ; std :: vector < KeyId > chain = FindChain ( config , camPosId , rootId , std :: vector < KeyId > ( ) ) ; if ( chain . size ( ) == 0 ) { LOG_INFO ( " Not ▁ found . " ) ; allMapped = false ; break ; } } } return allMapped ; }
void ComputeTransform ( WbConfig config , KeyId refId , std :: vector < KeyId > chain , CvMat * transform ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( std :: vector < KeyId > :: iterator elt = chain . begin ( ) ; elt != chain . end ( ) ; ++ elt ) { for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( ( camera1Id == * elt ) && ( camera2Id == refId ) ) { CvMat * homography = cvCreateMat ( 3 , 3 , CV_32F ) ; const bool homographyValid = config . GetKeyValue ( FloorPlanSchema :: homographyKey , it -> id ) . ToCvMat ( * homography ) ; Q_UNUSED ( homographyValid ) ; CvMat * tmp = cvCreateMat ( 3 , 3 , CV_32F ) ; cvMatMul ( homography , transform , tmp ) ; cvmSet ( transform , 0 , 0 , cvmGet ( tmp , 0 , 0 ) ) ; cvmSet ( transform , 0 , 1 , cvmGet ( tmp , 0 , 1 ) ) ; cvmSet ( transform , 0 , 2 , cvmGet ( tmp , 0 , 2 ) ) ; cvmSet ( transform , 1 , 0 , cvmGet ( tmp , 1 , 0 ) ) ; cvmSet ( transform , 1 , 1 , cvmGet ( tmp , 1 , 1 ) ) ; cvmSet ( transform , 1 , 2 , cvmGet ( tmp , 1 , 2 ) ) ; cvmSet ( transform , 2 , 0 , cvmGet ( tmp , 2 , 0 ) ) ; cvmSet ( transform , 2 , 1 , cvmGet ( tmp , 2 , 1 ) ) ; cvmSet ( transform , 2 , 2 , cvmGet ( tmp , 2 , 2 ) ) ; cvReleaseMat ( & tmp ) ; cvReleaseMat ( & homography ) ; refId = * elt ; } } } }
static std :: pair < unsigned , unsigned > getMFHiLoOpc ( unsigned Src ) { if ( Mips :: ACC64RegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: PseudoMFHI , ( unsigned ) Mips :: PseudoMFLO ) ; if ( Mips :: ACC64DSP@@ RegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: MFHI_DSP , ( unsigned ) Mips :: MFLO_DSP ) ; if ( Mips :: ACC128@@ RegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: PseudoMFHI64 , ( unsigned ) Mips :: PseudoMFLO64 ) ; return std :: make_pair ( 0 , 0 ) ; }
