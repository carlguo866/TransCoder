View@@ Provid@@ er@@ Tr@@ aj@@ ect@@ ory :: ~ View@@ Provid@@ er@@ Tr@@ aj@@ ect@@ ory ( ) { pc@@ Tr@@ aj@@ ect@@ ory@@ Root -> un@@ ref ( ) ; pc@@ Co@@ ords -> un@@ ref ( ) ; pc@@ Draw@@ Style -> un@@ ref ( ) ; pc@@ Lines -> un@@ ref ( ) ; }
void View@@ Provid@@ er@@ Tr@@ aj@@ ect@@ ory :: attach ( App :: Document@@ Object * pc@@ Obj ) { View@@ Provid@@ er@@ Document@@ Object :: attach ( pc@@ Obj ) ; So@@ Separator * lines@@ ep = new So@@ Separator ; So@@ Base@@ Color * bas@@ ec@@ ol = new So@@ Base@@ Color ; bas@@ ec@@ ol -> r@@ gb . setValue ( 1.0f , 0.5f , 0.0f ) ; lines@@ ep -> addChild ( bas@@ ec@@ ol ) ; lines@@ ep -> addChild ( pc@@ Co@@ ords ) ; lines@@ ep -> addChild ( pc@@ Lines ) ; So@@ Base@@ Color * mark@@ col = new So@@ Base@@ Color ; mark@@ col -> r@@ gb . setValue ( 1.0f , 1.0f , 0.0f ) ; So@@ Mark@@ er@@ Set * marker = new So@@ Mark@@ er@@ Set ; marker -> mark@@ er@@ Index = So@@ Mark@@ er@@ Set :: CRO@@ SS_@@ 5@@ _@@ 5 ; lines@@ ep -> addChild ( mark@@ col ) ; lines@@ ep -> addChild ( marker ) ; pc@@ Tr@@ aj@@ ect@@ ory@@ Root -> addChild ( lines@@ ep ) ; add@@ Display@@ Mask@@ Mode ( pc@@ Tr@@ aj@@ ect@@ ory@@ Root , " Wa@@ ypo@@ ints " ) ; pc@@ Tr@@ aj@@ ect@@ ory@@ Root -> object@@ Name = pc@@ Obj -> getName@@ In@@ Document ( ) ; pc@@ Tr@@ aj@@ ect@@ ory@@ Root -> d@@ ocum@@ ent@@ Name = pc@@ Obj -> getDocument ( ) -> getName ( ) ; pc@@ Tr@@ aj@@ ect@@ ory@@ Root -> sub@@ Element@@ Name = " Main " ; }
void View@@ Provid@@ er@@ Tr@@ aj@@ ect@@ ory :: set@@ DisplayMode ( const char * Mode@@ Name ) { if ( strcmp ( " Wa@@ ypo@@ ints " , Mode@@ Name ) == 0 ) set@@ Display@@ Mask@@ Mode ( " Wa@@ ypo@@ ints " ) ; View@@ Provid@@ er@@ Ge@@ ometr@@ y@@ Object :: set@@ DisplayMode ( Mode@@ Name ) ; }
void View@@ Provid@@ er@@ Tr@@ aj@@ ect@@ ory :: updateData ( const App :: Property * prop ) { Ro@@ bo@@ t :: Tr@@ aj@@ ect@@ ory@@ Object * pc@@ Tr@@ ac@@ Obj = static_cast < Ro@@ bo@@ t :: Tr@@ aj@@ ect@@ ory@@ Object * > ( pc@@ Object ) ; if ( prop == & pc@@ Tr@@ ac@@ Obj -> Tr@@ aj@@ ect@@ ory ) { const Tr@@ aj@@ ect@@ ory & tra@@ k = pc@@ Tr@@ ac@@ Obj -> Tr@@ aj@@ ect@@ ory . getValue ( ) ; pc@@ Co@@ ords -> point . delete@@ Values ( 0 ) ; pc@@ Co@@ ords -> point . setNum ( tra@@ k . getSize ( ) ) ; for ( unsigned int i = 0 ; i < tra@@ k . getSize ( ) ; ++ i ) { Base :: Vector@@ 3d pos = tra@@ k . get@@ Wa@@ ypo@@ int ( i ) . End@@ Pos . getPosition ( ) ; pc@@ Co@@ ords -> point . set@@ 1@@ Value ( i , pos . x , pos . y , pos . z ) ; } pc@@ Lines -> num@@ Ver@@ tices . set@@ 1@@ Value ( 0 , tra@@ k . getSize ( ) ) ; } else if ( prop == & pc@@ Tr@@ ac@@ Obj -> Base ) { Base :: Pl@@ acement loc = * ( & pc@@ Tr@@ ac@@ Obj -> Base . getValue ( ) ) ; } }
g@@ SD@@ LD@@ C :: g@@ SD@@ LD@@ C ( ) : m_p@@ ump ( e@@ App , 1 ) { if ( SDL_@@ Init ( SDL_@@ INIT_@@ VIDEO ) < 0 ) { e@@ Warning ( " [ g@@ SD@@ LD@@ C ] ▁ Could ▁ not ▁ initialize ▁ SDL : ▁ % s " , SDL_GetError ( ) ) ; return ; } set@@ Res@@ o@@ lution ( 72@@ 0 , 5@@ 76 ) ; CONN@@ ECT ( m_p@@ ump . rec@@ v_@@ msg , g@@ SD@@ LD@@ C :: p@@ ump@@ Event ) ; m_@@ surface . type = 0 ; m_@@ surface . clu@@ t . colors = 256 ; m_@@ surface . clu@@ t . data = new g@@ RGB [ m_@@ surface . clu@@ t . colors ] ; m_p@@ ix@@ map = new g@@ Pixmap ( & m_@@ surface ) ; memset ( m_@@ surface . clu@@ t . data , 0 , sizeof ( * m_@@ surface . clu@@ t . data ) * m_@@ surface . clu@@ t . colors ) ; run ( ) ; }
g@@ SD@@ LD@@ C :: ~ g@@ SD@@ LD@@ C ( ) { push@@ Event ( EV@@ _@@ QU@@ IT ) ; k@@ ill ( ) ; SDL_@@ Quit ( ) ; }
void g@@ SD@@ LD@@ C :: key@@ Event ( const SDL_@@ Event & event ) { e@@ SD@@ L@@ Input@@ Driver * driver = e@@ SD@@ L@@ Input@@ Driver :: getInstance ( ) ; eDebug ( " [ g@@ SD@@ LD@@ C ] ▁ Key ▁ % s : ▁ key = % d " , ( event . type == SDL_@@ KE@@ Y@@ DOWN ) ? " Down " : " Up " , event . key . key@@ sym . sym ) ; if ( driver ) driver -> keyPressed ( & event . key ) ; }
void g@@ SD@@ LD@@ C :: p@@ ump@@ Event ( const SDL_@@ Event & event ) { switch ( event . type ) { case SDL_@@ KE@@ Y@@ DOWN : case SDL_@@ KE@@ Y@@ UP : key@@ Event ( event ) ; break ; case SDL_@@ QU@@ IT : eDebug ( " [ g@@ SD@@ LD@@ C ] ▁ Quit " ) ; extern void qu@@ it@@ Main@@ loop ( int exit_@@ code ) ; qu@@ it@@ Main@@ loop ( 0 ) ; break ; } }
void g@@ SD@@ LD@@ C :: push@@ Event ( enum event code , void * data1 , void * data2 ) { SDL_@@ Event event ; event . type = SDL_@@ U@@ SER@@ EVENT ; event . user . code = code ; event . user . data1 = data1 ; event . user . data2 = data2 ; SDL_@@ Push@@ Event ( & event ) ; }
void g@@ SD@@ LD@@ C :: exec ( const g@@ Opcode * o ) { switch ( o -> opcode ) { case g@@ Opcode :: flush : push@@ Event ( EV@@ _F@@ LI@@ P ) ; eDebug ( " [ g@@ SD@@ LD@@ C ] ▁ FL@@ US@@ H " ) ; break ; default : g@@ DC :: exec ( o ) ; break ; } }
void g@@ SD@@ LD@@ C :: set@@ Res@@ o@@ lution ( int x@@ res , int y@@ res ) { push@@ Event ( EV@@ _SET_@@ VIDE@@ O_@@ MODE , ( void * ) x@@ res , ( void * ) y@@ res ) ; }
void g@@ SD@@ LD@@ C :: ev@@ Set@@ Video@@ Mode ( unsigned long x@@ res , unsigned long y@@ res ) { m_@@ screen = SDL_@@ Set@@ Video@@ Mode ( x@@ res , y@@ res , 32 , SDL_@@ H@@ W@@ SURFACE ) ; if ( ! m_@@ screen ) { e@@ F@@ at@@ al ( " [ g@@ SD@@ LD@@ C ] ▁ Could ▁ not ▁ create ▁ SDL ▁ surface : ▁ % s " , SDL_GetError ( ) ) ; return ; } m_@@ surface . x = m_@@ screen -> w ; m_@@ surface . y = m_@@ screen -> h ; m_@@ surface . b@@ pp = m_@@ screen -> format -> BitsPerPixel ; m_@@ surface . b@@ yp@@ p = m_@@ screen -> format -> BytesPerPixel ; m_@@ surface . st@@ ride = m_@@ screen -> pitch ; m_@@ surface . data = m_@@ screen -> pixels ; SDL_@@ Enable@@ UNICODE ( 1 ) ; }
void g@@ SD@@ LD@@ C :: ev@@ Flip ( ) { SDL_Flip ( m_@@ screen ) ; }
void g@@ SD@@ LD@@ C :: thread ( ) { has@@ Started ( ) ; bool stop = false ; while ( ! stop ) { SDL_@@ Event event ; if ( SDL_@@ Wait@@ Event ( & event ) ) { switch ( event . type ) { case SDL_@@ KE@@ Y@@ DOWN : case SDL_@@ KE@@ Y@@ UP : case SDL_@@ QU@@ IT : m_p@@ ump . send ( event ) ; break ; case SDL_@@ U@@ SER@@ EVENT : switch ( event . user . code ) { case EV@@ _SET_@@ VIDE@@ O_@@ MODE : ev@@ Set@@ Video@@ Mode ( ( unsigned long ) event . user . data1 , ( unsigned long ) event . user . data2 ) ; break ; case EV@@ _F@@ LI@@ P : ev@@ Flip ( ) ; break ; case EV@@ _@@ QU@@ IT : stop = true ; break ; } break ; } } } }
DWORD Mat@@ eri@@ al@@ Def :: Get@@ View@@ Data ( const char * view@@ Name ) { DWORD * value = NULL ; view@@ Data . Get ( view@@ Name , & value ) ; return * value ; }
void Mat@@ eri@@ al@@ Def :: Set@@ View@@ Data ( const char * view@@ Name , DWORD value ) { view@@ Data . Set ( view@@ Name , value ) ; }
void Mat@@ eri@@ al@@ Def@@ Manager :: Initialize@@ Mat@@ eri@@ al@@ Def@@ Lists ( ) { char * buffer ; int length = file@@ System -> Read@@ File ( MAT@@ ERI@@ AL_@@ DEF@@ _F@@ IL@@ E , ( void * * ) & buffer ) ; if ( length == - 1 ) { common -> Error ( " Couldn ' t ▁ load ▁ mat@@ eri@@ al ▁ editor ▁ definition : ▁ % s " , MAT@@ ERI@@ AL_@@ DEF@@ _F@@ IL@@ E ) ; return ; } id@@ Lex@@ er src ; if ( ! src . Load@@ Memory ( buffer , length , MAT@@ ERI@@ AL_@@ DEF@@ _F@@ IL@@ E ) ) { common -> Error ( " Couldn ' t ▁ parse ▁ % s " , MAT@@ ERI@@ AL_@@ DEF@@ _F@@ IL@@ E ) ; file@@ System -> Free@@ File ( buffer ) ; } Initialize@@ Mat@@ eri@@ al@@ Def@@ List ( & src , " mat@@ eri@@ al@@ props " , & mat@@ eri@@ al@@ Defs [ MAT@@ ERI@@ AL_@@ DEF@@ _@@ MAT@@ ERI@@ AL ] ) ; Initialize@@ Mat@@ eri@@ al@@ Def@@ List ( & src , " st@@ age@@ props " , & mat@@ eri@@ al@@ Defs [ MAT@@ ERI@@ AL_@@ DEF@@ _ST@@ AGE ] ) ; Initialize@@ Mat@@ eri@@ al@@ Def@@ List ( & src , " speci@@ al@@ map@@ st@@ age@@ props " , & mat@@ eri@@ al@@ Defs [ MAT@@ ERI@@ AL_@@ DEF@@ _SP@@ ECI@@ AL_@@ ST@@ AGE ] ) ; file@@ System -> Free@@ File ( buffer ) ; }
void Mat@@ eri@@ al@@ Def@@ Manager :: Initialize@@ Mat@@ eri@@ al@@ Def@@ List ( id@@ Lex@@ er * src , const char * typeName , Mat@@ eri@@ al@@ Def@@ List * list ) { id@@ Token token ; src -> Reset ( ) ; src -> Skip@@ Un@@ ti@@ l@@ String ( typeName ) ; src -> Skip@@ Un@@ ti@@ l@@ String ( " { " ) ; while ( 1 ) { if ( ! src -> Exp@@ ect@@ Any@@ Token ( & token ) ) { return ; } if ( token == " } " ) { break ; } Mat@@ eri@@ al@@ Def * new@@ Prop = new Mat@@ eri@@ al@@ Def ( ) ; if ( ! token . I@@ cmp ( " TYPE _ GROUP " ) ) { new@@ Prop -> type = Mat@@ eri@@ al@@ Def :: MAT@@ ERI@@ AL_@@ DEF@@ _TYPE_@@ GROUP ; } else if ( ! token . I@@ cmp ( " TYPE _ BOOL " ) ) { new@@ Prop -> type = Mat@@ eri@@ al@@ Def :: MAT@@ ERI@@ AL_@@ DEF@@ _TYPE_@@ BOOL ; } else if ( ! token . I@@ cmp ( " TYPE _ STRING " ) ) { new@@ Prop -> type = Mat@@ eri@@ al@@ Def :: MAT@@ ERI@@ AL_@@ DEF@@ _TYPE_@@ STRING ; } else if ( ! token . I@@ cmp ( " TYPE _ FLOAT " ) ) { new@@ Prop -> type = Mat@@ eri@@ al@@ Def :: MAT@@ ERI@@ AL_@@ DEF@@ _TYPE_@@ FLOAT ; } else if ( ! token . I@@ cmp ( " TYPE _ INT " ) ) { new@@ Prop -> type = Mat@@ eri@@ al@@ Def :: MAT@@ ERI@@ AL_@@ DEF@@ _TYPE_@@ INT ; } src -> Read@@ Token ( & token ) ; src -> Read@@ Token ( & token ) ; new@@ Prop -> dict@@ Name = token ; src -> Read@@ Token ( & token ) ; src -> Read@@ Token ( & token ) ; new@@ Prop -> displayName = token ; src -> Read@@ Token ( & token ) ; src -> Read@@ Token ( & token ) ; new@@ Prop -> display@@ Info = token ; if ( new@@ Prop -> type == Mat@@ eri@@ al@@ Def :: MAT@@ ERI@@ AL_@@ DEF@@ _TYPE_@@ STRING ) { new@@ Prop -> qu@@ o@@ tes = false ; src -> Read@@ Token ( & token ) ; src -> Read@@ Token ( & token ) ; if ( token == "1" ) { new@@ Prop -> qu@@ o@@ tes = true ; } } src -> Skip@@ Re@@ st@@ Of@@ Line ( ) ; list -> Append ( new@@ Prop ) ; } }
void Mat@@ eri@@ al@@ Def@@ Manager :: Destroy@@ Mat@@ eri@@ al@@ Def@@ Lists ( ) { for ( int i = 0 ; i < MAT@@ ERI@@ AL_@@ DEF@@ _@@ NUM ; i ++ ) { for ( int j = 0 ; j < mat@@ eri@@ al@@ Defs [ i ] . Num ( ) ; j ++ ) { delete mat@@ eri@@ al@@ Defs [ i ] [ j ] ; } mat@@ eri@@ al@@ Defs [ i ] . Clear ( ) ; } }
Mat@@ eri@@ al@@ Def@@ List * Mat@@ eri@@ al@@ Def@@ Manager :: Get@@ Mat@@ eri@@ al@@ Defs ( int type ) { if ( type >= 0 && type < MAT@@ ERI@@ AL_@@ DEF@@ _@@ NUM ) { return & mat@@ eri@@ al@@ Defs [ type ] ; } return NULL ; }
High@@ li@@ gh@@ ter :: High@@ li@@ gh@@ ter ( Edit@@ or * text , Dictionary * dictionary ) : Q@@ Syntax@@ High@@ li@@ gh@@ ter ( text -> document ( ) ) , m_@@ dictionary ( dictionary ) , m_text ( text ) , m_en@@ abled ( true ) , m_@@ mis@@ sp@@ el@@ led ( " # ff@@ 0000" ) { connect ( m_text , SIGNAL ( cursor@@ Position@@ Changed ( ) ) , this , SLOT ( cursor@@ Position@@ Changed ( ) ) ) ; m_text -> view@@ port ( ) -> installEventFilter ( this ) ; m_@@ add_@@ action = new QAction ( tr ( " Add " ) , this ) ; m_@@ check_@@ action = new QAction ( tr ( " Check ▁ Spelling . . . " ) , this ) ; }
void High@@ li@@ gh@@ ter :: setEnabled ( bool enabled ) { m_en@@ abled = enabled ; re@@ high@@ light ( ) ; }
void High@@ li@@ gh@@ ter :: set@@ Misspelled@@ Color ( const QColor & color ) { m_@@ mis@@ sp@@ el@@ led = color ; re@@ high@@ light ( ) ; }
bool High@@ li@@ gh@@ ter :: eventFilter ( QObject * w@@ atch@@ ed , QEvent * event ) { if ( w@@ atch@@ ed != m_text -> view@@ port ( ) || event -> type ( ) != QEvent :: ContextMenu || ! m_en@@ abled ) { return Q@@ Syntax@@ High@@ li@@ gh@@ ter :: eventFilter ( w@@ atch@@ ed , event ) ; } else { QContextMenuEvent * contex@@ t_@@ event = static_cast < QContextMenuEvent * > ( event ) ; m_@@ start_@@ cursor = m_text -> cursor@@ For@@ Position ( contex@@ t_@@ event -> pos ( ) ) ; QText@@ Block block = m_@@ start_@@ cursor . block ( ) ; int cursor = m_@@ start_@@ cursor . position ( ) - block . position ( ) ; bool und@@ er_@@ mo@@ use = false ; QString@@ Ref word ; QVector < QString@@ Ref > words = static_cast < Block@@ Stats * > ( block . userData ( ) ) -> mis@@ sp@@ el@@ led ( ) ; for ( int i = 0 ; i < words . count ( ) ; ++ i ) { word = words . at ( i ) ; int delta = cursor - word . position ( ) ; if ( delta >= 0 && delta <= word . length ( ) ) { und@@ er_@@ mo@@ use = true ; break ; } } if ( ! und@@ er_@@ mo@@ use ) { return false ; } else { m_cursor = m_@@ start_@@ cursor ; m_cursor . set@@ Position ( word . position ( ) + block . position ( ) ) ; m_cursor . set@@ Position ( m_cursor . position ( ) + word . length ( ) , QText@@ Cursor :: Keep@@ An@@ ch@@ or ) ; m_@@ word = m_cursor . selected@@ Text ( ) ; m_text -> setText@@ Cursor ( m_cursor ) ; QMenu * menu = new QMenu ; QStringList gu@@ ess@@ es = m_@@ dictionary -> sug@@ gest@@ ion@@ s ( m_@@ word ) ; if ( ! gu@@ ess@@ es . isEmpty ( ) ) { foreach ( const QString & gu@@ es@@ s , gu@@ ess@@ es ) { menu -> add@@ Action ( gu@@ es@@ s ) ; } } else { QAction * non@@ e_@@ action = menu -> add@@ Action ( tr ( " ( No ▁ sug@@ gest@@ ion@@ s ▁ found ) " ) ) ; non@@ e_@@ action -> setEnabled ( false ) ; } menu -> add@@ Separator ( ) ; menu -> add@@ Action ( m_@@ add_@@ action ) ; menu -> add@@ Separator ( ) ; menu -> add@@ Action ( m_@@ check_@@ action ) ; connect ( menu , SIGNAL ( triggered ( QAction * ) ) , this , SLOT ( sug@@ gest@@ ion ( QAction * ) ) ) ; menu -> exec ( contex@@ t_@@ event -> globalPos ( ) ) ; delete menu ; return true ; } } }
void High@@ li@@ gh@@ ter :: high@@ light@@ Block ( const QString & text ) { QText@@ Char@@ Format h@@ format ; QText@@ Block@@ Format block@@ format = current@@ Block ( ) . block@@ Format ( ) ; if ( block@@ format . hasProperty ( QText@@ Format :: User@@ Property ) ) { h@@ format . setProperty ( QText@@ Format :: Font@@ Weight , block@@ format . property ( QText@@ Format :: Font@@ Weight ) ) ; h@@ format . setProperty ( QText@@ Format :: Font@@ I@@ tal@@ ic , block@@ format . property ( QText@@ Format :: Font@@ I@@ tal@@ ic ) ) ; h@@ format . setProperty ( QText@@ Format :: Font@@ Size@@ Adjust@@ ment , block@@ format . property ( QText@@ Format :: Font@@ Size@@ Adjust@@ ment ) ) ; setFormat ( 0 , text . length ( ) , h@@ format ) ; } if ( ! m_en@@ abled ) { return ; } int cursor = m_text -> text@@ Cursor ( ) . position ( ) - current@@ Block ( ) . position ( ) ; Block@@ Stats * stats = static_cast < Block@@ Stats * > ( current@@ Block@@ UserData ( ) ) ; if ( ! stats ) { stats = new Block@@ Stats ( text , m_@@ dictionary ) ; setCurrent@@ Block@@ UserData ( stats ) ; } QText@@ Char@@ Format error ; error . set@@ Un@@ der@@ line@@ Color ( m_@@ mis@@ sp@@ el@@ led ) ; error . set@@ Un@@ der@@ line@@ Style ( QText@@ Char@@ Format :: SpellCheck@@ Un@@ der@@ line ) ; error . merge ( h@@ format ) ; QVector < QString@@ Ref > words = stats -> mis@@ sp@@ el@@ led ( ) ; for ( int i = 0 ; i < words . count ( ) ; ++ i ) { const QString@@ Ref & word = words . at ( i ) ; int delta = cursor - word . position ( ) ; if ( delta < 0 || delta > word . length ( ) ) { setFormat ( word . position ( ) , word . length ( ) , error ) ; } } }
void High@@ li@@ gh@@ ter :: cursor@@ Position@@ Changed ( ) { QText@@ Block current = m_text -> text@@ Cursor ( ) . block ( ) ; if ( m_@@ current != current ) { if ( m_@@ current . isValid ( ) && m_text -> document ( ) -> block@@ Count ( ) > m_@@ current . block@@ Number ( ) ) { re@@ high@@ light@@ Block ( m_@@ current ) ; } m_@@ current = current ; } re@@ high@@ light@@ Block ( m_@@ current ) ; }
void High@@ li@@ gh@@ ter :: sug@@ gest@@ ion ( QAction * action ) { if ( action == m_@@ add_@@ action ) { m_text -> setText@@ Cursor ( m_@@ start_@@ cursor ) ; m_@@ dictionary -> add ( m_@@ word ) ; } else if ( action == m_@@ check_@@ action ) { m_text -> setText@@ Cursor ( m_@@ start_@@ cursor ) ; Spell@@ Checker :: check@@ Document ( m_text ) ; } else { m_cursor . insert@@ Text ( action -> text ( ) ) ; } }
Function@@ Hint@@ Pro@@ pos@@ al@@ Widget@@ Private :: Function@@ Hint@@ Pro@@ pos@@ al@@ Widget@@ Private ( ) : m_@@ under@@ ly@@ ing@@ Widget ( 0 ) , m_@@ as@@ si@@ stan@@ t ( 0 ) , m_@@ model ( 0 ) , m_po@@ p@@ up@@ Frame ( new Utils :: Fa@@ ke@@ Tool@@ T@@ ip ) , m_@@ number@@ Label ( new QLabel ) , m_h@@ int@@ Label ( new QLabel ) , m_p@@ ager ( new QWidget ) , m_current@@ Hint ( - 1 ) , m_total@@ H@@ ints ( 0 ) , m_current@@ Argument ( - 1 ) , m_@@ escap@@ e@@ Pressed ( false ) { m_h@@ int@@ Label -> setText@@ Format ( Qt :: R@@ ich@@ Text ) ; }
Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: Function@@ Hint@@ Pro@@ pos@@ al@@ Widget ( ) : m_d ( new Function@@ Hint@@ Pro@@ pos@@ al@@ Widget@@ Private ) { Q@@ Tool@@ Button * down@@ Arrow = new Q@@ Tool@@ Button ; down@@ Arrow -> set@@ Arrow@@ Type ( Qt :: Down@@ Arrow ) ; down@@ Arrow -> set@@ Fix@@ edSize ( 16 , 16 ) ; down@@ Arrow -> setAuto@@ Raise ( true ) ; Q@@ Tool@@ Button * up@@ Arrow = new Q@@ Tool@@ Button ; up@@ Arrow -> set@@ Arrow@@ Type ( Qt :: Up@@ Arrow ) ; up@@ Arrow -> set@@ Fix@@ edSize ( 16 , 16 ) ; up@@ Arrow -> setAuto@@ Raise ( true ) ; QHBoxLayout * p@@ ager@@ Layout = new QHBoxLayout ( m_d -> m_p@@ ager ) ; p@@ ager@@ Layout -> setMargin ( 0 ) ; p@@ ager@@ Layout -> set@@ Sp@@ acing ( 0 ) ; p@@ ager@@ Layout -> addWidget ( up@@ Arrow ) ; p@@ ager@@ Layout -> addWidget ( m_d -> m_@@ number@@ Label ) ; p@@ ager@@ Layout -> addWidget ( down@@ Arrow ) ; QHBoxLayout * pop@@ up@@ Layout = new QHBoxLayout ( m_d -> m_po@@ p@@ up@@ Frame ) ; pop@@ up@@ Layout -> setMargin ( 0 ) ; pop@@ up@@ Layout -> set@@ Sp@@ acing ( 0 ) ; pop@@ up@@ Layout -> addWidget ( m_d -> m_p@@ ager ) ; pop@@ up@@ Layout -> addWidget ( m_d -> m_h@@ int@@ Label ) ; connect ( up@@ Arrow , SIGNAL ( clicked ( ) ) , SLOT ( previo@@ us@@ Page ( ) ) ) ; connect ( down@@ Arrow , SIGNAL ( clicked ( ) ) , SLOT ( next@@ Page ( ) ) ) ; qApp -> installEventFilter ( this ) ; setFocusPolicy ( Qt :: No@@ Focus ) ; }
Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: ~ Function@@ Hint@@ Pro@@ pos@@ al@@ Widget ( ) { delete m_d -> m_@@ model ; }
void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: set@@ As@@ si@@ stan@@ t ( Code@@ As@@ si@@ stan@@ t * as@@ si@@ stan@@ t ) { m_d -> m_@@ as@@ si@@ stan@@ t = as@@ si@@ stan@@ t ; }
void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: set@@ Reason ( As@@ sist@@ Reason reason ) { Q_UNUSED ( reason ) ; }
void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: set@@ Un@@ der@@ ly@@ ing@@ Widget ( const QWidget * under@@ ly@@ ing@@ Widget ) { m_d -> m_@@ under@@ ly@@ ing@@ Widget = under@@ ly@@ ing@@ Widget ; }
void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: setModel ( I@@ As@@ sist@@ Pro@@ pos@@ al@@ Model * model ) { m_d -> m_@@ model = static_cast < I@@ Function@@ Hint@@ Pro@@ pos@@ al@@ Model * > ( model ) ; }
void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: set@@ Display@@ Rect ( const QRect & rect ) { m_d -> m_display@@ Rect = rect ; }
void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: show@@ Pro@@ pos@@ al ( const QString & prefix ) { m_d -> m_total@@ H@@ ints = m_d -> m_@@ model -> size ( ) ; if ( m_d -> m_total@@ H@@ ints == 0 ) { abort ( ) ; return ; } m_d -> m_p@@ ager -> setVisible ( m_d -> m_total@@ H@@ ints > 1 ) ; m_d -> m_current@@ Hint = 0 ; if ( ! update@@ AndCheck ( prefix ) ) { abort ( ) ; return ; } m_d -> m_po@@ p@@ up@@ Frame -> show ( ) ; }
void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: update@@ Pro@@ pos@@ al ( const QString & prefix ) { update@@ AndCheck ( prefix ) ; }
void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: close@@ Pro@@ pos@@ al ( ) { abort ( ) ; }
void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: abort ( ) { if ( m_d -> m_po@@ p@@ up@@ Frame -> isVisible ( ) ) m_d -> m_po@@ p@@ up@@ Frame -> close ( ) ; delete@@ Lat@@ er ( ) ; }
bool Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: eventFilter ( QObject * obj , QEvent * e ) { switch ( e -> type ( ) ) { case QEvent :: Shortcut@@ Override : if ( static_cast < QKeyEvent * > ( e ) -> key ( ) == Qt :: Key_@@ E@@ scape ) { m_d -> m_@@ escap@@ e@@ Pressed = true ; } break ; case QEvent :: Key@@ Press : if ( static_cast < QKeyEvent * > ( e ) -> key ( ) == Qt :: Key_@@ E@@ scape ) { m_d -> m_@@ escap@@ e@@ Pressed = true ; } if ( m_d -> m_@@ model -> size ( ) > 1 ) { QKeyEvent * ke = static_cast < QKeyEvent * > ( e ) ; if ( ke -> key ( ) == Qt :: Key_@@ Up ) { previo@@ us@@ Page ( ) ; return true ; } else if ( ke -> key ( ) == Qt :: Key_@@ Down ) { next@@ Page ( ) ; return true ; } return false ; } break ; case QEvent :: KeyRelease : if ( static_cast < QKeyEvent * > ( e ) -> key ( ) == Qt :: Key_@@ E@@ scape && m_d -> m_@@ escap@@ e@@ Pressed ) { abort ( ) ; return false ; } m_d -> m_@@ as@@ si@@ stan@@ t -> notify@@ Change ( ) ; break ; case QEvent :: Window@@ De@@ activate : case QEvent :: Focus@@ Out : if ( obj != m_d -> m_@@ under@@ ly@@ ing@@ Widget ) { break ; } abort ( ) ; break ; case QEvent :: Mouse@@ ButtonPress : case QEvent :: Mouse@@ ButtonRelease : case QEvent :: Mouse@@ Button@@ D@@ bl@@ Click : case QEvent :: Wheel : { QWidget * widget = q@@ object@@ _cast < QWidget * > ( obj ) ; if ( ! ( widget == this || is@@ An@@ ce@@ stor@@ Of ( widget ) ) ) { abort ( ) ; } } break ; default : break ; } return false ; }
void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: next@@ Page ( ) { m_d -> m_current@@ Hint = ( m_d -> m_current@@ Hint + 1 ) % m_d -> m_total@@ H@@ ints ; update@@ Content ( ) ; }
void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: previo@@ us@@ Page ( ) { if ( m_d -> m_current@@ Hint == 0 ) m_d -> m_current@@ Hint = m_d -> m_total@@ H@@ ints - 1 ; else -- m_d -> m_current@@ Hint ; update@@ Content ( ) ; }
bool Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: update@@ AndCheck ( const QString & prefix ) { const int active@@ Argument = m_d -> m_@@ model -> active@@ Argument ( prefix ) ; if ( active@@ Argument == - 1 ) { abort ( ) ; return false ; } else if ( active@@ Argument != m_d -> m_current@@ Argument ) { m_d -> m_current@@ Argument = active@@ Argument ; update@@ Content ( ) ; } return true ; }
void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: update@@ Content ( ) { m_d -> m_h@@ int@@ Label -> setText ( m_d -> m_@@ model -> text ( m_d -> m_current@@ Hint ) ) ; m_d -> m_@@ number@@ Label -> setText ( tr ( " % 1 ▁ of ▁ % 2" ) . arg ( m_d -> m_current@@ Hint + 1 ) . arg ( m_d -> m_total@@ H@@ ints ) ) ; update@@ Position ( ) ; }
void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: update@@ Position ( ) { const Q@@ Des@@ ktop@@ Widget * desk@@ top = QApplication :: desk@@ top ( ) ; const QRect & screen = desk@@ top -> available@@ Geometry ( desk@@ top -> screen@@ Number ( m_d -> m_@@ under@@ ly@@ ing@@ Widget ) ) ; const QRect & screen = desk@@ top -> screen@@ Geometry ( desk@@ top -> screen@@ Number ( m_d -> m_@@ under@@ ly@@ ing@@ Widget ) ) ; m_d -> m_p@@ ager -> setFixed@@ Width ( m_d -> m_p@@ ager -> min@@ imum@@ Size@@ Hint ( ) . width ( ) ) ; m_d -> m_h@@ int@@ Label -> setWord@@ Wrap ( false ) ; const int max@@ Desired@@ Width = screen . width ( ) - 10 ; const QSize & min@@ Hint = m_d -> m_po@@ p@@ up@@ Frame -> min@@ imum@@ Size@@ Hint ( ) ; if ( min@@ Hint . width ( ) > max@@ Desired@@ Width ) { m_d -> m_h@@ int@@ Label -> setWord@@ Wrap ( true ) ; m_d -> m_po@@ p@@ up@@ Frame -> setFixed@@ Width ( max@@ Desired@@ Width ) ; const int extra = m_d -> m_po@@ p@@ up@@ Frame -> content@@ sMargins ( ) . bottom ( ) + m_d -> m_po@@ p@@ up@@ Frame -> content@@ sMargins ( ) . top ( ) ; m_d -> m_po@@ p@@ up@@ Frame -> setFixedHeight ( m_d -> m_h@@ int@@ Label -> height@@ For@@ Width ( max@@ Desired@@ Width - m_d -> m_p@@ ager -> width ( ) ) + extra ) ; } else { m_d -> m_po@@ p@@ up@@ Frame -> set@@ Fix@@ edSize ( min@@ Hint ) ; } const QSize & sz = m_d -> m_po@@ p@@ up@@ Frame -> size ( ) ; QPoint pos = m_d -> m_display@@ Rect . top@@ Left ( ) ; pos . set@@ Y ( pos . y ( ) - sz . height ( ) - 1 ) ; if ( pos . x ( ) + sz . width ( ) > screen . right ( ) ) pos . setX ( screen . right ( ) - sz . width ( ) ) ; m_d -> m_po@@ p@@ up@@ Frame -> move ( pos ) ; }
Game@@ Lo@@ b@@ by@@ St@@ age :: Game@@ Lo@@ b@@ by@@ St@@ age ( ) { net@@ work@@ connection = nullptr ; current@@ info = new Game@@ Info ( true ) ; selection = 0 ; selection@@ team@@ is@@ blue = true ; }
Game@@ Lo@@ b@@ by@@ St@@ age :: Game@@ Lo@@ b@@ by@@ St@@ age ( Net@@ work * Connection ) { selection = 0 ; net@@ work@@ connection = Connection ; current@@ info = new Game@@ Info ( Connection -> Is@@ Server ( ) ) ; if ( ! Connection -> Is@@ Server ( ) ) { } }
void Game@@ Lo@@ b@@ by@@ St@@ age :: Begin ( ) { option@@ font = Font@@ Cache :: Load@@ Font ( " resources / arm@@ al@@ ite . ttf " , 32 ) ; hel@@ p@@ font = Font@@ Cache :: Load@@ Font ( " resources / arm@@ al@@ ite . ttf " , 16 ) ; }
void Game@@ Lo@@ b@@ by@@ St@@ age :: Finish ( ) { A@@ UDI@@ O -> Stop@@ M@@ usi@@ c ( ) ; if ( net@@ work@@ connection != nullptr ) { delete net@@ work@@ connection ; net@@ work@@ connection = nullptr ; } }
void Game@@ Lo@@ b@@ by@@ St@@ age :: Event@@ Occur@@ red ( Event * e ) { Input@@ Items :: Item@@ Set in@@ p@@ ute@@ vent = Input@@ Items :: NONE ; if ( e -> Type == EVENT_@@ KEY_@@ DOWN ) { if ( e -> Data . Key@@ board . Key@@ Code == AL@@ LEG@@ RO@@ _@@ KEY_@@ ESCAPE ) { delete FRAM@@ EWOR@@ K -> Program@@ St@@ ages -> Pop ( ) ; return ; } in@@ p@@ ute@@ vent = Input :: GetItem@@ From@@ Event ( e ) ; } if ( e -> Type == EVENT_@@ JO@@ Y@@ S@@ TIC@@ K_@@ BUTT@@ ON_@@ DOWN && in@@ p@@ ute@@ vent == Input@@ Items :: NONE ) { in@@ p@@ ute@@ vent = Input :: GetItem@@ From@@ Event ( e ) ; } if ( in@@ p@@ ute@@ vent != Input@@ Items :: NONE ) { Input@@ Event ( in@@ p@@ ute@@ vent ) ; } Network@@ Event ( e ) ; }
void Game@@ Lo@@ b@@ by@@ St@@ age :: Input@@ Event ( Input@@ Items :: Item@@ Set in@@ p@@ ute@@ vent ) { switch ( in@@ p@@ ute@@ vent ) { case Input@@ Items :: UP : if ( selection > 0 ) { selection -- ; } break ; case Input@@ Items :: DOWN : if ( selection < 2 ) { selection ++ ; } break ; case Input@@ Items :: LEFT : selection@@ team@@ is@@ blue = true ; break ; case Input@@ Items :: RIGHT : selection@@ team@@ is@@ blue = false ; break ; case Input@@ Items :: SEL@@ ECT : delete FRAM@@ EWOR@@ K -> Program@@ St@@ ages -> Pop ( ) ; return ; break ; case Input@@ Items :: X : if ( net@@ work@@ connection == nullptr ) { Player@@ Info * p = nullptr ; if ( selection@@ team@@ is@@ blue ) { if ( current@@ info -> Blue@@ Team [ selection ] == nullptr ) { current@@ info -> Blue@@ Team [ selection ] = new Player@@ Info ( " " , true , false ) ; } p = current@@ info -> Blue@@ Team [ selection ] ; } else { if ( current@@ info -> Red@@ Team [ selection ] == nullptr ) { current@@ info -> Red@@ Team [ selection ] = new Player@@ Info ( " " , true , false ) ; } p = current@@ info -> Red@@ Team [ selection ] ; } p -> Blue@@ Team = selection@@ team@@ is@@ blue ; p -> Team@@ Index = selection ; p -> Game@@ Data = current@@ info ; FRAM@@ EWOR@@ K -> Program@@ St@@ ages -> Push ( new Game@@ Lo@@ b@@ by@@ Add@@ Local@@ St@@ age ( p ) ) ; } break ; case Input@@ Items :: B : if ( net@@ work@@ connection == nullptr ) { Player@@ Info * p = nullptr ; if ( selection@@ team@@ is@@ blue ) { if ( current@@ info -> Blue@@ Team [ selection ] == nullptr ) { p = new Player@@ Info ( " CPU " , true , true ) ; current@@ info -> Blue@@ Team [ selection ] = p ; } } else { if ( current@@ info -> Red@@ Team [ selection ] == nullptr ) { p = new Player@@ Info ( " CPU " , true , true ) ; current@@ info -> Red@@ Team [ selection ] = p ; } } if ( p != nullptr ) { p -> Blue@@ Team = selection@@ team@@ is@@ blue ; p -> Team@@ Index = selection ; p -> Game@@ Data = current@@ info ; } } break ; case Input@@ Items :: Y : if ( net@@ work@@ connection == nullptr || net@@ work@@ connection -> Is@@ Server ( ) ) { Player@@ Info * p = nullptr ; if ( selection@@ team@@ is@@ blue ) { p = current@@ info -> Blue@@ Team [ selection ] ; current@@ info -> Blue@@ Team [ selection ] = nullptr ; } else { p = current@@ info -> Red@@ Team [ selection ] ; current@@ info -> Red@@ Team [ selection ] = nullptr ; } if ( p != nullptr ) { if ( ! p -> Local ) { } delete p ; } } break ; case Input@@ Items :: START : if ( net@@ work@@ connection == nullptr || net@@ work@@ connection -> Is@@ Server ( ) ) { Game@@ St@@ age * g = new Game@@ St@@ age ( current@@ info ) ; delete FRAM@@ EWOR@@ K -> Program@@ St@@ ages -> Pop ( ) ; FRAM@@ EWOR@@ K -> Program@@ St@@ ages -> Push ( g ) ; } break ; } }
void Game@@ Lo@@ b@@ by@@ St@@ age :: Network@@ Event ( Event * e ) { if ( e -> Type == EVENT_@@ NE@@ TWOR@@ K@@ _CONN@@ ECTION_@@ REQUEST ) { bool fre@@ es@@ lot = false ; for ( int i = 0 ; i < 3 ; i ++ ) { fre@@ es@@ lot = ( current@@ info -> Blue@@ Team [ i ] == nullptr ? true : fre@@ es@@ lot ) ; fre@@ es@@ lot = ( current@@ info -> Red@@ Team [ i ] == nullptr ? true : fre@@ es@@ lot ) ; } if ( fre@@ es@@ lot ) { } } if ( e -> Type == EVENT_@@ NE@@ TWOR@@ K@@ _CONN@@ ECTED ) { } if ( e -> Type == EVENT_@@ NE@@ TWOR@@ K_@@ DIS@@ CONNEC@@ TED ) { } if ( e -> Type == EVENT_@@ NE@@ TWOR@@ K_@@ PAC@@ KE@@ T_@@ RECE@@ IVED ) { } }
void Game@@ Lo@@ b@@ by@@ St@@ age :: R@@ ender ( ) { al_@@ clear@@ _to_@@ color ( al_@@ map_@@ r@@ gb ( 255 , 220 , 128 ) ) ; option@@ font -> Draw@@ String ( ( DISP@@ LAY -> Get@@ Width ( ) / 2 ) + 2 , 12 , " Lo@@ b@@ by " , Font@@ H@@ Align :: CENTR@@ E , al_@@ map_@@ r@@ gb ( 0 , 0 , 0 ) ) ; option@@ font -> Draw@@ String ( ( DISP@@ LAY -> Get@@ Width ( ) / 2 ) , 10 , " Lo@@ b@@ by " , Font@@ H@@ Align :: CENTR@@ E , al_@@ map_@@ r@@ gb ( 255 , 255 , 0 ) ) ; Game@@ Resources :: Draw@@ Pan@@ el ( Game@@ Resources :: Blue@@ Pan@@ el , 5 , 80 , 13 , 8 , 8 ) ; option@@ font -> Draw@@ String ( 15 , 8@@ 5 , " Bl@@ ue ▁ Team " , Font@@ H@@ Align :: LEFT , al_@@ map_@@ r@@ gb ( 255 , 255 , 255 ) ) ; Render@@ Player@@ Slot ( true , 0 , 15 , 14@@ 0 ) ; Render@@ Player@@ Slot ( true , 1 , 15 , 192 ) ; Render@@ Player@@ Slot ( true , 2 , 15 , 244 ) ; Game@@ Resources :: Draw@@ Pan@@ el ( Game@@ Resources :: Red@@ Pan@@ el , 40@@ 5 , 80 , 13 , 8 , 8 ) ; option@@ font -> Draw@@ String ( 4@@ 15 , 8@@ 5 , " Re@@ d ▁ Team " , Font@@ H@@ Align :: LEFT , al_@@ map_@@ r@@ gb ( 255 , 255 , 255 ) ) ; Render@@ Player@@ Slot ( false , 0 , 4@@ 15 , 14@@ 0 ) ; Render@@ Player@@ Slot ( false , 1 , 4@@ 15 , 192 ) ; Render@@ Player@@ Slot ( false , 2 , 4@@ 15 , 244 ) ; int tex@@ to@@ ff = ( 50 - hel@@ p@@ font -> Get@@ Font@@ Height ( ) ) / 2 ; if ( net@@ work@@ connection == nullptr ) { al_@@ draw_bitmap ( Input :: Get@@ Icon ( Input@@ Items :: X ) , 10 , 32@@ 0 , 0 ) ; hel@@ p@@ font -> Draw@@ String ( 64 , 32@@ 0 + tex@@ to@@ ff , " Add ▁ Local ▁ Player " , Font@@ H@@ Align :: LEFT , al_@@ map_@@ r@@ gb ( 0 , 0 , 0 ) ) ; al_@@ draw_bitmap ( Input :: Get@@ Icon ( Input@@ Items :: B ) , 10 , 37@@ 0 , 0 ) ; hel@@ p@@ font -> Draw@@ String ( 64 , 37@@ 0 + tex@@ to@@ ff , " Add ▁ CPU ▁ Player " , Font@@ H@@ Align :: LEFT , al_@@ map_@@ r@@ gb ( 0 , 0 , 0 ) ) ; } if ( net@@ work@@ connection == nullptr || net@@ work@@ connection -> Is@@ Server ( ) ) { al_@@ draw_bitmap ( Input :: Get@@ Icon ( Input@@ Items :: Y ) , 10 , 4@@ 20 , 0 ) ; hel@@ p@@ font -> Draw@@ String ( 64 , 4@@ 20 + tex@@ to@@ ff , " K@@ ick ▁ Player " , Font@@ H@@ Align :: LEFT , al_@@ map_@@ r@@ gb ( 0 , 0 , 0 ) ) ; al_@@ draw_bitmap ( Input :: Get@@ Icon ( Input@@ Items :: START ) , 500 , 37@@ 0 , 0 ) ; hel@@ p@@ font -> Draw@@ String ( 55@@ 4 , 37@@ 0 + tex@@ to@@ ff , " Start " , Font@@ H@@ Align :: LEFT , al_@@ map_@@ r@@ gb ( 0 , 0 , 0 ) ) ; } al_@@ draw_bitmap ( Input :: Get@@ Icon ( Input@@ Items :: SEL@@ ECT ) , 500 , 4@@ 20 , 0 ) ; hel@@ p@@ font -> Draw@@ String ( 55@@ 4 , 4@@ 20 + tex@@ to@@ ff , " Quit " , Font@@ H@@ Align :: LEFT , al_@@ map_@@ r@@ gb ( 0 , 0 , 0 ) ) ; }
bool Game@@ Lo@@ b@@ by@@ St@@ age :: Is@@ Transition ( ) { return false ; }
void Game@@ Lo@@ b@@ by@@ St@@ age :: Render@@ Player@@ Slot ( bool Blue@@ Team , int Index , int X , int Y ) { Button@@ Colo@@ ur@@ s :: Colo@@ ur@@ s co@@ lo@@ ur = Button@@ Colo@@ ur@@ s :: WHIT@@ E ; bool bt@@ n@@ up = false ; Player@@ Info * p = ( Blue@@ Team ? current@@ info -> Blue@@ Team [ Index ] : current@@ info -> Red@@ Team [ Index ] ) ; if ( p != nullptr ) { co@@ lo@@ ur = ( Blue@@ Team ? Button@@ Colo@@ ur@@ s :: BL@@ UE : Button@@ Colo@@ ur@@ s :: RE@@ D ) ; } if ( net@@ work@@ connection == nullptr || net@@ work@@ connection -> Is@@ Server ( ) ) { if ( selection == Index && selection@@ team@@ is@@ blue == Blue@@ Team ) { co@@ lo@@ ur = Button@@ Colo@@ ur@@ s :: Y@@ EL@@ LOW ; bt@@ n@@ up = true ; } } Game@@ Resources :: Draw@@ Button ( co@@ lo@@ ur , bt@@ n@@ up , X , Y , 23 , 3 ) ; if ( p != nullptr ) { hel@@ p@@ font -> Draw@@ String ( X + 184 , Y + 24 - ( hel@@ p@@ font -> Get@@ Font@@ Height ( ) / 2 ) + ( ! bt@@ n@@ up ? 4 : 0 ) , p -> Name , Font@@ H@@ Align :: CENTR@@ E , al_@@ map_@@ r@@ gb ( 0 , 0 , 0 ) ) ; } }
Machine@@ S@@ SA@@ Upd@@ ater :: Machine@@ S@@ SA@@ Upd@@ ater ( MachineFunction & MF , Small@@ Vector@@ Impl < MachineInstr * > * New@@ PH@@ I ) : A@@ V ( nullptr ) , In@@ ser@@ ted@@ P@@ HI@@ s ( New@@ PH@@ I ) { TII = MF . getSubtarget ( ) . getInstrInfo ( ) ; MRI = & MF . getRegInfo ( ) ; }
Machine@@ S@@ SA@@ Upd@@ ater :: ~ Machine@@ S@@ SA@@ Upd@@ ater ( ) { delete static_cast < A@@ vai@@ lable@@ V@@ al@@ s@@ Ty * > ( A@@ V ) ; }
void Machine@@ S@@ SA@@ Upd@@ ater :: Initialize ( unsigned V ) { if ( ! A@@ V ) A@@ V = new A@@ vai@@ lable@@ V@@ al@@ s@@ Ty ( ) ; else get@@ A@@ vai@@ lable@@ V@@ als ( A@@ V ) . clear ( ) ; VR = V ; V@@ RC = MRI -> get@@ RegClass ( VR ) ; }
void Machine@@ S@@ SA@@ Upd@@ ater :: Add@@ A@@ vai@@ lable@@ Value ( MachineBasicBlock * BB , unsigned V ) { get@@ A@@ vai@@ lable@@ V@@ als ( A@@ V ) [ BB ] = V ; }
unsigned Machine@@ S@@ SA@@ Upd@@ ater :: GetValue@@ At@@ End@@ OfBlock ( MachineBasicBlock * BB ) { return GetValue@@ At@@ End@@ Of@@ Block@@ Internal ( BB ) ; }
unsigned Machine@@ S@@ SA@@ Upd@@ ater :: GetValue@@ In@@ Midd@@ le@@ OfBlock ( MachineBasicBlock * BB ) { if ( ! Has@@ Value@@ For@@ Block ( BB ) ) return GetValue@@ At@@ End@@ Of@@ Block@@ Internal ( BB ) ; if ( BB -> pre@@ d_@@ empty ( ) ) { MachineInstr * New@@ Def = Insert@@ New@@ Def ( TargetOpcode :: IMPLICIT_@@ DEF , BB , BB -> getFirst@@ Ter@@ minator ( ) , V@@ RC , MRI , TII ) ; return New@@ Def -> getOperand ( 0 ) . getReg ( ) ; } SmallVector < std :: pair < MachineBasicBlock * , unsigned > , 8 > Pre@@ d@@ Values ; unsigned Sing@@ ular@@ Value = 0 ; bool is@@ First@@ Pre@@ d = true ; for ( MachineBasicBlock :: pre@@ d_iterator PI = BB -> pre@@ d_@@ begin ( ) , E = BB -> pre@@ d_@@ end ( ) ; PI != E ; ++ PI ) { MachineBasicBlock * Pre@@ d@@ BB = * PI ; unsigned Pre@@ d@@ Val = GetValue@@ At@@ End@@ Of@@ Block@@ Internal ( Pre@@ d@@ BB ) ; Pre@@ d@@ Values . push_back ( std :: make_pair ( Pre@@ d@@ BB , Pre@@ d@@ Val ) ) ; if ( is@@ First@@ Pre@@ d ) { Sing@@ ular@@ Value = Pre@@ d@@ Val ; is@@ First@@ Pre@@ d = false ; } else if ( Pre@@ d@@ Val != Sing@@ ular@@ Value ) Sing@@ ular@@ Value = 0 ; } if ( Sing@@ ular@@ Value != 0 ) return Sing@@ ular@@ Value ; unsigned Dup@@ PH@@ I = Lo@@ ok@@ For@@ Identical@@ PH@@ I ( BB , Pre@@ d@@ Values ) ; if ( Dup@@ PH@@ I ) return Dup@@ PH@@ I ; MachineBasicBlock :: iterator Loc = BB -> empty ( ) ? BB -> end ( ) : BB -> begin ( ) ; MachineInstr@@ Builder In@@ ser@@ ted@@ PH@@ I = Insert@@ New@@ Def ( TargetOpcode :: PH@@ I , BB , Loc , V@@ RC , MRI , TII ) ; for ( unsigned i = 0 , e = Pre@@ d@@ Values . size ( ) ; i != e ; ++ i ) In@@ ser@@ ted@@ PH@@ I . addReg ( Pre@@ d@@ Values [ i ] . second ) . add@@ MBB ( Pre@@ d@@ Values [ i ] . first ) ; if ( unsigned Con@@ st@@ Val = In@@ ser@@ ted@@ PH@@ I -> is@@ Constant@@ Value@@ PH@@ I ( ) ) { In@@ ser@@ ted@@ PH@@ I -> eraseFromParent ( ) ; return Con@@ st@@ Val ; } if ( In@@ ser@@ ted@@ P@@ HI@@ s ) In@@ ser@@ ted@@ P@@ HI@@ s -> push_back ( In@@ ser@@ ted@@ PH@@ I ) ; DEBUG ( dbgs ( ) << " ▁ ▁ In@@ ser@@ ted ▁ PH@@ I : ▁ " << * In@@ ser@@ ted@@ PH@@ I << " \n " ) ; return In@@ ser@@ ted@@ PH@@ I -> getOperand ( 0 ) . getReg ( ) ; }
void Machine@@ S@@ SA@@ Upd@@ ater :: Re@@ write@@ Use ( Machine@@ Operand & U ) { MachineInstr * Use@@ MI = U . getParent ( ) ; unsigned New@@ VR = 0 ; if ( Use@@ MI -> is@@ PH@@ I ( ) ) { MachineBasicBlock * Source@@ BB = find@@ Cor@@ respon@@ d@@ ing@@ Pre@@ d ( Use@@ MI , & U ) ; New@@ VR = GetValue@@ At@@ End@@ Of@@ Block@@ Internal ( Source@@ BB ) ; } else { New@@ VR = GetValue@@ In@@ Midd@@ le@@ OfBlock ( Use@@ MI -> getParent ( ) ) ; } U . set@@ Reg ( New@@ VR ) ; }
unsigned Machine@@ S@@ SA@@ Upd@@ ater :: GetValue@@ At@@ End@@ Of@@ Block@@ Internal ( MachineBasicBlock * BB ) { A@@ vai@@ lable@@ V@@ al@@ s@@ Ty & A@@ vai@@ lable@@ V@@ als = get@@ A@@ vai@@ lable@@ V@@ als ( A@@ V ) ; if ( unsigned V = A@@ vai@@ lable@@ V@@ als [ BB ] ) return V ; S@@ SA@@ Upd@@ ater@@ Impl < Machine@@ S@@ SA@@ Upd@@ ater > Impl ( this , & A@@ vai@@ lable@@ V@@ als , In@@ ser@@ ted@@ P@@ HI@@ s ) ; return Impl . GetValue ( BB ) ; }
std :: string Help@@ Re@@ qu@@ ir@@ ing@@ P@@ as@@ sp@@ hr@@ ase ( ) { return pw@@ all@@ et@@ Main && pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) ? " \n requires ▁ wallet ▁ pas@@ sp@@ hr@@ ase ▁ to ▁ be ▁ set ▁ with ▁ wall@@ et@@ pas@@ sp@@ hr@@ ase ▁ first " : " " ; }
Eigen :: Matrix@@ 4@@ d d@@ qu@@ at@@ Con@@ j@@ ugate ( ) { Matrix@@ 4@@ d d@@ q@@ _@@ con@@ j = Matrix@@ 4@@ d :: Identity ( ) ; d@@ q@@ _@@ con@@ j ( 1 , 1 ) = - 1.0 ; d@@ q@@ _@@ con@@ j ( 2 , 2 ) = - 1.0 ; d@@ q@@ _@@ con@@ j ( 3 , 3 ) = - 1.0 ; return d@@ q@@ _@@ con@@ j ; }
Eigen :: Vector@@ 4@@ d qu@@ at@@ Product ( const Eigen :: Vector@@ 4@@ d & q1 , const Eigen :: Vector@@ 4@@ d & q2 ) { double w@@ 1 = q1 ( 0 ) ; double w2 = q2 ( 0 ) ; const auto & v1 = q1 . tail < 3 > ( ) ; const auto & v2 = q2 . tail < 3 > ( ) ; Vector@@ 4@@ d r ; r << w@@ 1 * w2 - v1 . dot ( v2 ) , v1 . cross ( v2 ) + w@@ 1 * v2 + w2 * v1 ; return r ; }
Eigen :: Matrix < double , 4 , 8 > d@@ qu@@ at@@ Product ( const Eigen :: Vector@@ 4@@ d & q1 , const Eigen :: Vector@@ 4@@ d & q2 ) { double w@@ 1 = q1 ( 0 ) ; double w2 = q2 ( 0 ) ; const auto & v1 = q1 . tail < 3 > ( ) ; const auto & v2 = q2 . tail < 3 > ( ) ; Matrix < double , 4 , 8 > d@@ r ; d@@ r . row ( 0 ) << w2 , - v2 . transpose ( ) , w@@ 1 , - v1 . transpose ( ) ; d@@ r . row ( 1 ) << q2 ( 1 ) , q2 ( 0 ) , q2 ( 3 ) , - q2 ( 2 ) , q1 ( 1 ) , q1 ( 0 ) , - q1 ( 3 ) , q1 ( 2 ) ; d@@ r . row ( 2 ) << q2 ( 2 ) , - q2 ( 3 ) , q2 ( 0 ) , q2 ( 1 ) , q1 ( 2 ) , q1 ( 3 ) , q1 ( 0 ) , - q1 ( 1 ) ; d@@ r . row ( 3 ) << q2 ( 3 ) , q2 ( 2 ) , - q2 ( 1 ) , q2 ( 0 ) , q1 ( 3 ) , - q1 ( 2 ) , q1 ( 1 ) , q1 ( 0 ) ; return d@@ r ; }
Eigen :: Vector@@ 3d qu@@ at@@ Rot@@ ate@@ Vec ( const Eigen :: Vector@@ 4@@ d & q , const Eigen :: Vector@@ 3d & v ) { Vector@@ 4@@ d v_@@ quat ; v_@@ quat << 0 , v ; Vector@@ 4@@ d q@@ _@@ tim@@ es@@ _v = qu@@ at@@ Product ( q , v_@@ quat ) ; Vector@@ 4@@ d q@@ _@@ con@@ j = qu@@ at@@ Con@@ j@@ ugate ( q ) ; Vector@@ 4@@ d v_@@ rot = qu@@ at@@ Product ( q@@ _@@ tim@@ es@@ _v , q@@ _@@ con@@ j ) ; Vector@@ 3d r = v_@@ rot . botto@@ m@@ Rows < 3 > ( ) ; return r ; }
Eigen :: Matrix < double , 3 , 7 > d@@ qu@@ at@@ Rot@@ ate@@ Vec ( const Eigen :: Vector@@ 4@@ d & q , const Eigen :: Vector@@ 3d & v ) { Matrix < double , 4 , 7 > d@@ q ; d@@ q << Matrix@@ 4@@ d :: Identity ( ) , MatrixXd :: Zero ( 4 , 3 ) ; Matrix < double , 4 , 7 > dv = Matrix < double , 4 , 7 > :: Zero ( ) ; dv . botto@@ m@@ Right@@ Cor@@ ner < 3 , 3 > ( ) = Matrix@@ 3d :: Identity ( ) ; Matrix < double , 8 , 7 > d@@ q@@ dv ; d@@ q@@ dv << d@@ q , dv ; Vector@@ 4@@ d v_@@ quat ; v_@@ quat << 0 , v ; Vector@@ 4@@ d q@@ _@@ tim@@ es@@ _v = qu@@ at@@ Product ( q , v_@@ quat ) ; Matrix < double , 4 , 8 > d@@ q@@ _@@ tim@@ es@@ _@@ v_@@ tmp = d@@ qu@@ at@@ Product ( q , v_@@ quat ) ; Matrix < double , 4 , 7 > d@@ q@@ _@@ tim@@ es@@ _v = d@@ q@@ _@@ tim@@ es@@ _@@ v_@@ tmp * d@@ q@@ dv ; Matrix < double , 4 , 7 > d@@ q@@ _@@ con@@ j = d@@ qu@@ at@@ Con@@ j@@ ugate ( ) * d@@ q ; Matrix < double , 8 , 7 > d@@ q@@ _@@ tim@@ es@@ _@@ v_@@ d@@ q@@ _@@ con@@ j ; d@@ q@@ _@@ tim@@ es@@ _@@ v_@@ d@@ q@@ _@@ con@@ j << d@@ q@@ _@@ tim@@ es@@ _v , d@@ q@@ _@@ con@@ j ; Matrix < double , 4 , 8 > d@@ v_@@ rot_@@ tmp = d@@ qu@@ at@@ Product ( q@@ _@@ tim@@ es@@ _v , qu@@ at@@ Con@@ j@@ ugate ( q ) ) ; Matrix < double , 4 , 7 > d@@ v_@@ rot = d@@ v_@@ rot_@@ tmp * d@@ q@@ _@@ tim@@ es@@ _@@ v_@@ d@@ q@@ _@@ con@@ j ; Eigen :: Matrix < double , 3 , 7 > d@@ r = d@@ v_@@ rot . botto@@ m@@ Rows ( 3 ) ; return d@@ r ; }
Eigen :: Vector@@ 4@@ d qu@@ at@@ Di@@ ff ( const Eigen :: Vector@@ 4@@ d & q1 , const Eigen :: Vector@@ 4@@ d & q2 ) { return qu@@ at@@ Product ( qu@@ at@@ Con@@ j@@ ugate ( q1 ) , q2 ) ; }
Eigen :: Matrix < double , 4 , 8 > d@@ qu@@ at@@ Di@@ ff ( const Eigen :: Vector@@ 4@@ d & q1 , const Eigen :: Vector@@ 4@@ d & q2 ) { auto d@@ r = d@@ qu@@ at@@ Product ( qu@@ at@@ Con@@ j@@ ugate ( q1 ) , q2 ) ; d@@ r . block < 4 , 3 > ( 0 , 1 ) = - d@@ r . block < 4 , 3 > ( 0 , 1 ) ; return d@@ r ; }
Eigen :: Matrix < double , 1 , 11 > d@@ qu@@ at@@ Di@@ ff@@ Axis@@ In@@ var ( const Eigen :: Vector@@ 4@@ d & q1 , const Eigen :: Vector@@ 4@@ d & q2 , const Eigen :: Vector@@ 3d & u ) { Vector@@ 4@@ d r = qu@@ at@@ Di@@ ff ( q1 , q2 ) ; Matrix < double , 4 , 8 > d@@ r = d@@ qu@@ at@@ Di@@ ff ( q1 , q2 ) ; Matrix < double , 1 , 11 > de ; const auto & r@@ vec = r . tail < 3 > ( ) ; de << 4.@@ 0 * r ( 0 ) * d@@ r . row ( 0 ) + 4.@@ 0 * u . transpose ( ) * r@@ vec * u . transpose ( ) * d@@ r . block < 3 , 8 > ( 1 , 0 ) , 4.@@ 0 * u . transpose ( ) * r@@ vec * r@@ vec . transpose ( ) ; return de ; }
Eigen :: Vector@@ 4@@ d slerp ( const Eigen :: Vector@@ 4@@ d & q1 , const Eigen :: Vector@@ 4@@ d & q2 , double inter@@ po@@ l@@ ation_@@ parameter ) { double lam@@ b@@ da = ( q1 . transpose ( ) * q2 ) . value ( ) ; int q@@ 2_@@ sign ; if ( lam@@ b@@ da < 0.0 ) { lam@@ b@@ da = - lam@@ b@@ da ; q@@ 2_@@ sign = - 1 ; } else { q@@ 2_@@ sign = 1 ; } double r , s ; if ( std :: abs ( 1.0 - lam@@ b@@ da ) < std :: numer@@ ic@@ _@@ limits < double > :: epsilon ( ) ) { r = 1.0 - inter@@ po@@ l@@ ation_@@ parameter ; s = inter@@ po@@ l@@ ation_@@ parameter ; } else { double alpha = std :: ac@@ os ( lam@@ b@@ da ) ; double gamma = 1.0 / std :: sin ( alpha ) ; r = std :: sin ( ( 1.0 - inter@@ po@@ l@@ ation_@@ parameter ) * alpha ) * gamma ; s = std :: sin ( inter@@ po@@ l@@ ation_@@ parameter * alpha ) * gamma ; } Vector@@ 4@@ d ret = q1 * r ; ret += q@@ 2_@@ sign * q2 * s ; return ret ; }
Eigen :: Matrix@@ 3d uni@@ for@@ ml@@ y@@ Random@@ Rot@@ mat ( std :: default_@@ random_@@ engine & generator ) { return axis@@ 2@@ rot@@ mat ( uni@@ for@@ ml@@ y@@ Random@@ Axis@@ Angle ( generator ) ) ; }
Eigen :: Vector@@ 3d uni@@ for@@ ml@@ y@@ Random@@ RP@@ Y ( std :: default_@@ random_@@ engine & generator ) { return axis@@ 2@@ r@@ py ( uni@@ for@@ ml@@ y@@ Random@@ Axis@@ Angle ( generator ) ) ; }
template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 1 > qu@@ at@@ 2@@ r@@ py ( const Eigen :: Matrix@@ Base < Deri@@ ved > & q ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 4 ) ; auto q@@ _@@ normalized = q . normalized ( ) ; auto w = q@@ _@@ normalized ( 0 ) ; auto x = q@@ _@@ normalized ( 1 ) ; auto y = q@@ _@@ normalized ( 2 ) ; auto z = q@@ _@@ normalized ( 3 ) ; Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 1 > ret ; ret << std :: atan@@ 2 ( 2.0 * ( w * x + y * z ) , w * w + z * z - ( x * x + y * y ) ) , std :: asin ( 2.0 * ( w * y - z * x ) ) , std :: atan@@ 2 ( 2.0 * ( w * z + x * y ) , w * w + x * x - ( y * y + z * z ) ) ; return ret ; }
template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 3 > qu@@ at@@ 2@@ rot@@ mat ( const Eigen :: Matrix@@ Base < Deri@@ ved > & q ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 4 ) ; auto q@@ _@@ normalized = q . normalized ( ) ; auto w = q@@ _@@ normalized ( 0 ) ; auto x = q@@ _@@ normalized ( 1 ) ; auto y = q@@ _@@ normalized ( 2 ) ; auto z = q@@ _@@ normalized ( 3 ) ; Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 3 > M ; M . row ( 0 ) << w * w + x * x - y * y - z * z , 2.0 * x * y - 2.0 * w * z , 2.0 * x * z + 2.0 * w * y ; M . row ( 1 ) << 2.0 * x * y + 2.0 * w * z , w * w + y * y - x * x - z * z , 2.0 * y * z - 2.0 * w * x ; M . row ( 2 ) << 2.0 * x * z - 2.0 * w * y , 2.0 * y * z + 2.0 * w * x , w * w + z * z - x * x - y * y ; return M ; }
template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 4 , 1 > qu@@ at@@ 2@@ axis ( const Eigen :: Matrix@@ Base < Deri@@ ved > & q ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 4 ) ; auto q@@ _@@ normalized = q . normalized ( ) ; auto s = std :: sqrt ( 1.0 - q@@ _@@ normalized ( 0 ) * q@@ _@@ normalized ( 0 ) ) + std :: numer@@ ic@@ _@@ limits < typename Deri@@ ved :: Scalar > :: epsilon ( ) ; Eigen :: Matrix < typename Deri@@ ved :: Scalar , 4 , 1 > a ; a << q@@ _@@ normalized . template tail < 3 > ( ) / s , 2.0 * std :: ac@@ os ( q@@ _@@ normalized ( 0 ) ) ; return a ; }
template < typename Deri@@ ved > Eigen :: Vector@@ 4@@ d axis@@ 2@@ quat ( const Eigen :: Matrix@@ Base < Deri@@ ved > & a ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 4 ) ; auto axis = a . template head < 3 > ( ) ; auto angle = a ( 3 ) ; auto arg = 0.5 * angle ; auto c = std :: cos ( arg ) ; auto s = std :: sin ( arg ) ; Eigen :: Vector@@ 4@@ d ret ; ret << c , s * axis ; return ret ; }
template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 3 > axis@@ 2@@ rot@@ mat ( const Eigen :: Matrix@@ Base < Deri@@ ved > & a ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 4 ) ; const auto & axis = ( a . template head < 3 > ( ) ) / ( a . template head < 3 > ( ) ) . norm ( ) ; const auto & theta = a ( 3 ) ; auto x = axis ( 0 ) ; auto y = axis ( 1 ) ; auto z = axis ( 2 ) ; auto c@@ theta = std :: cos ( theta ) ; auto sth@@ et@@ a = std :: sin ( theta ) ; auto c = 1 - c@@ theta ; Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 3 > R ; R << c@@ theta + x * x * c , x * y * c - z * sth@@ et@@ a , x * z * c + y * sth@@ et@@ a , y * x * c + z * sth@@ et@@ a , c@@ theta + y * y * c , y * z * c - x * sth@@ et@@ a , z * x * c - y * sth@@ et@@ a , z * y * c + x * sth@@ et@@ a , c@@ theta + z * z * c ; return R ; }
template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 1 > axis@@ 2@@ r@@ py ( const Eigen :: Matrix@@ Base < Deri@@ ved > & a ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 4 ) ; return qu@@ at@@ 2@@ r@@ py ( axis@@ 2@@ quat ( a ) ) ; }
template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 4 , 1 > rot@@ mat@@ 2@@ axis ( const Eigen :: Matrix@@ Base < Deri@@ ved > & R ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ MAT@@ RI@@ X@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 3 , 3 ) ; typename Deri@@ ved :: Scalar theta = std :: ac@@ os ( ( R . trace ( ) - 1.0 ) / 2.0 ) ; Vector@@ 4@@ d a ; if ( theta > std :: numer@@ ic@@ _@@ limits < typename Deri@@ ved :: Scalar > :: epsilon ( ) ) { a << R ( 2 , 1 ) - R ( 1 , 2 ) , R ( 0 , 2 ) - R ( 2 , 0 ) , R ( 1 , 0 ) - R ( 0 , 1 ) , theta ; a . head < 3 > ( ) *= 1.0 / ( 2.0 * std :: sin ( theta ) ) ; } else { a << 1.0 , 0.0 , 0.0 , 0.0 ; } return a ; }
template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 4 , 1 > rot@@ mat@@ 2@@ quat ( const Eigen :: Matrix@@ Base < Deri@@ ved > & M ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ MAT@@ RI@@ X@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 3 , 3 ) ; using namespace std ; Matrix < typename Deri@@ ved :: Scalar , 4 , 3 > A ; A . row ( 0 ) << 1.0 , 1.0 , 1.0 ; A . row ( 1 ) << 1.0 , - 1.0 , - 1.0 ; A . row ( 2 ) << - 1.0 , 1.0 , - 1.0 ; A . row ( 3 ) << - 1.0 , - 1.0 , 1.0 ; Matrix < typename Deri@@ ved :: Scalar , 4 , 1 > B = A * M . diag@@ on@@ al ( ) ; typename Matrix < typename Deri@@ ved :: Scalar , 4 , 1 > :: Index ind , max_@@ col ; typename Deri@@ ved :: Scalar val = B . max@@ Coe@@ ff ( & ind , & max_@@ col ) ; typename Deri@@ ved :: Scalar w , x , y , z ; switch ( ind ) { case 0 : { w = sqrt ( 1.0 + val ) / 2.0 ; typename Deri@@ ved :: Scalar w@@ 4 = w * 4.@@ 0 ; x = ( M ( 2 , 1 ) - M ( 1 , 2 ) ) / w@@ 4 ; y = ( M ( 0 , 2 ) - M ( 2 , 0 ) ) / w@@ 4 ; z = ( M ( 1 , 0 ) - M ( 0 , 1 ) ) / w@@ 4 ; break ; } case 1 : { double s = 2.0 * sqrt ( 1.0 + val ) ; w = ( M ( 2 , 1 ) - M ( 1 , 2 ) ) / s ; x = 0.25 * s ; y = ( M ( 0 , 1 ) + M ( 1 , 0 ) ) / s ; z = ( M ( 0 , 2 ) + M ( 2 , 0 ) ) / s ; break ; } case 2 : { double s = 2.0 * ( sqrt ( 1.0 + val ) ) ; w = ( M ( 0 , 2 ) - M ( 2 , 0 ) ) / s ; x = ( M ( 0 , 1 ) + M ( 1 , 0 ) ) / s ; y = 0.25 * s ; z = ( M ( 1 , 2 ) + M ( 2 , 1 ) ) / s ; break ; } default : { double s = 2.0 * ( sqrt ( 1.0 + val ) ) ; w = ( M ( 1 , 0 ) - M ( 0 , 1 ) ) / s ; x = ( M ( 0 , 2 ) + M ( 2 , 0 ) ) / s ; y = ( M ( 1 , 2 ) + M ( 2 , 1 ) ) / s ; z = 0.25 * s ; break ; } } Eigen :: Matrix < typename Deri@@ ved :: Scalar , 4 , 1 > q ; q << w , x , y , z ; return q ; }
template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 1 > rot@@ mat@@ 2@@ r@@ py ( const Eigen :: Matrix@@ Base < Deri@@ ved > & R ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ MAT@@ RI@@ X@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 3 , 3 ) ; using namespace std ; Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 1 > r@@ py ; r@@ py << atan@@ 2 ( R ( 2 , 1 ) , R ( 2 , 2 ) ) , atan@@ 2 ( - R ( 2 , 0 ) , sqrt ( pow ( R ( 2 , 1 ) , 2.0 ) + pow ( R ( 2 , 2 ) , 2.0 ) ) ) , atan@@ 2 ( R ( 1 , 0 ) , R ( 0 , 0 ) ) ; return r@@ py ; }
template < typename Deri@@ ved > DL@@ LEXPORT Eigen :: Matrix < typename Deri@@ ved :: Scalar , Eigen :: Dynamic , 1 > rot@@ mat@@ 2@@ Re@@ presentation ( const Eigen :: Matrix@@ Base < Deri@@ ved > & R , int rot@@ ation@@ _type ) { typedef typename Deri@@ ved :: Scalar Scalar ; Eigen :: Matrix < Scalar , Eigen :: Dynamic , 1 > ret ; switch ( rot@@ ation@@ _type ) { case 0 : return Eigen :: Matrix < Scalar , Eigen :: Dynamic , 1 > ( 0 , 1 ) ; case 1 : return rot@@ mat@@ 2@@ r@@ py ( R ) ; case 2 : return rot@@ mat@@ 2@@ quat ( R ) ; default : throw std :: runtime_error ( " rotation ▁ re@@ presentation ▁ type ▁ not ▁ reco@@ gnized " ) ; } }
template < typename Scalar > DL@@ LEXPORT Gradient@@ Var < Scalar , Eigen :: Dynamic , 1 > rot@@ mat@@ 2@@ Re@@ presentation ( const Gradient@@ Var < Scalar , SP@@ ACE_@@ DIMEN@@ SION , SP@@ ACE_@@ DIMEN@@ SION > & R , int rot@@ ation@@ _type ) { Gradient@@ Var < Scalar , Eigen :: Dynamic , 1 > ret ( rot@@ ation@@ Re@@ present@@ ation@@ Size ( rot@@ ation@@ _type ) , 1 , R . getNum@@ Variables ( ) , R . max@@ Order ( ) ) ; switch ( rot@@ ation@@ _type ) { case 0 : break ; case 1 : ret . value ( ) = rot@@ mat@@ 2@@ r@@ py ( R . value ( ) ) ; if ( R . has@@ Gradi@@ ent ( ) ) { ret . gradi@@ ent ( ) . value ( ) = d@@ rot@@ mat@@ 2@@ r@@ py ( R . value ( ) , R . gradi@@ ent ( ) . value ( ) ) ; } break ; case 2 : ret . value ( ) = rot@@ mat@@ 2@@ quat ( R . value ( ) ) ; if ( R . has@@ Gradi@@ ent ( ) ) { ret . gradi@@ ent ( ) . value ( ) = d@@ rot@@ mat@@ 2@@ quat ( R . value ( ) , R . gradi@@ ent ( ) . value ( ) ) ; } break ; default : throw std :: runtime_error ( " rotation ▁ re@@ presentation ▁ type ▁ not ▁ reco@@ gnized " ) ; } return ret ; }
template < typename Deri@@ ved > Gradient@@ Var < typename Deri@@ ved :: Scalar , QU@@ AT_@@ SIZE , 1 > exp@@ map@@ 2@@ quat ( const Eigen :: Matrix@@ Base < Deri@@ ved > & v , const int gradi@@ ent_@@ order ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 3 ) ; Gradient@@ Var < typename Deri@@ ved :: Scalar , QU@@ AT_@@ SIZE , 1 > ret ( QU@@ AT_@@ SIZE , 1 , EXP@@ MAP@@ _SIZE , gradi@@ ent_@@ order ) ; auto theta = v . norm ( ) ; if ( theta < pow ( std :: numer@@ ic@@ _@@ limits < typename Deri@@ ved :: Scalar > :: epsilon ( ) , 0.25 ) ) { ret . value ( ) = exp@@ map@@ 2@@ qu@@ at@@ De@@ generate ( v , theta ) ; if ( gradi@@ ent_@@ order > 0 ) { ret . gradi@@ ent ( ) . value ( ) = dex@@ pmap@@ 2@@ qu@@ at@@ De@@ generate ( v , theta ) ; if ( gradi@@ ent_@@ order > 1 ) { ret . gradi@@ ent ( ) . gradi@@ ent ( ) . value ( ) = d@@ dex@@ pmap@@ 2@@ qu@@ at@@ De@@ generate ( v , theta ) ; if ( gradi@@ ent_@@ order > 2 ) { throw std :: runtime_error ( " exp@@ map@@ 2@@ quat ▁ does ▁ not ▁ support ▁ gradi@@ ent ▁ order ▁ larger ▁ than ▁ 2" ) ; } } } } else { ret . value ( ) = exp@@ map@@ 2@@ qu@@ at@@ Non@@ De@@ generate ( v , theta ) ; if ( gradi@@ ent_@@ order > 0 ) { ret . gradi@@ ent ( ) . value ( ) = dex@@ pmap@@ 2@@ qu@@ at@@ Non@@ De@@ generate ( v , theta ) ; if ( gradi@@ ent_@@ order > 1 ) { ret . gradi@@ ent ( ) . gradi@@ ent ( ) . value ( ) = d@@ dex@@ pmap@@ 2@@ qu@@ at@@ Non@@ De@@ generate ( v , theta ) ; if ( gradi@@ ent_@@ order > 2 ) { throw std :: runtime_error ( " exp@@ map@@ 2@@ quat ▁ does ▁ not ▁ support ▁ gradi@@ ent ▁ order ▁ larger ▁ than ▁ 2" ) ; } } } } return ret ; }
template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 4 , 1 > r@@ py@@ 2@@ axis ( const Eigen :: Matrix@@ Base < Deri@@ ved > & r@@ py ) { return qu@@ at@@ 2@@ axis ( r@@ py@@ 2@@ quat ( r@@ py ) ) ; }
template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 4 , 1 > r@@ py@@ 2@@ quat ( const Eigen :: Matrix@@ Base < Deri@@ ved > & r@@ py ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 3 ) ; auto rp@@ y_@@ 2 = ( r@@ py / 2.0 ) . array ( ) ; auto s = rp@@ y_@@ 2 . sin ( ) ; auto c = rp@@ y_@@ 2 . cos ( ) ; Vector@@ 4@@ d q ; q << c ( 0 ) * c ( 1 ) * c ( 2 ) + s ( 0 ) * s ( 1 ) * s ( 2 ) , s ( 0 ) * c ( 1 ) * c ( 2 ) - c ( 0 ) * s ( 1 ) * s ( 2 ) , c ( 0 ) * s ( 1 ) * c ( 2 ) + s ( 0 ) * c ( 1 ) * s ( 2 ) , c ( 0 ) * c ( 1 ) * s ( 2 ) - s ( 0 ) * s ( 1 ) * c ( 2 ) ; q /= q . norm ( ) + std :: numer@@ ic@@ _@@ limits < typename Deri@@ ved :: Scalar > :: epsilon ( ) ; return q ; }
template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 3 > r@@ py@@ 2@@ rot@@ mat ( const Eigen :: Matrix@@ Base < Deri@@ ved > & r@@ py ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 3 ) ; auto rp@@ y_@@ array = r@@ py . array ( ) ; auto s = rp@@ y_@@ array . sin ( ) ; auto c = rp@@ y_@@ array . cos ( ) ; Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 3 > R ; R . row ( 0 ) << c ( 2 ) * c ( 1 ) , c ( 2 ) * s ( 1 ) * s ( 0 ) - s ( 2 ) * c ( 0 ) , c ( 2 ) * s ( 1 ) * c ( 0 ) + s ( 2 ) * s ( 0 ) ; R . row ( 1 ) << s ( 2 ) * c ( 1 ) , s ( 2 ) * s ( 1 ) * s ( 0 ) + c ( 2 ) * c ( 0 ) , s ( 2 ) * s ( 1 ) * c ( 0 ) - c ( 2 ) * s ( 0 ) ; R . row ( 2 ) << - s ( 1 ) , c ( 1 ) * s ( 0 ) , c ( 1 ) * c ( 0 ) ; return R ; }
template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 9 , 3 > dr@@ py@@ 2@@ rot@@ mat ( const Eigen :: Matrix@@ Base < Deri@@ ved > & r@@ py ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 3 ) ; auto rp@@ y_@@ array = r@@ py . array ( ) ; auto s = rp@@ y_@@ array . sin ( ) ; auto c = rp@@ y_@@ array . cos ( ) ; Eigen :: Matrix < typename Deri@@ ved :: Scalar , 9 , 3 > d@@ R ; d@@ R . row ( 0 ) << 0 , c ( 2 ) * - s ( 1 ) , c ( 1 ) * - s ( 2 ) ; d@@ R . row ( 1 ) << 0 , - s ( 1 ) * s ( 2 ) , c ( 2 ) * c ( 1 ) ; d@@ R . row ( 2 ) << 0 , - c ( 1 ) , 0 ; d@@ R . row ( 3 ) << c ( 2 ) * s ( 1 ) * c ( 0 ) - s ( 2 ) * - s ( 0 ) , c ( 2 ) * c ( 1 ) * s ( 0 ) , - s ( 2 ) * s ( 1 ) * s ( 0 ) - c ( 2 ) * c ( 0 ) ; d@@ R . row ( 4 ) << s ( 2 ) * s ( 1 ) * c ( 0 ) + c ( 2 ) * - s ( 0 ) , s ( 2 ) * c ( 1 ) * s ( 0 ) , c ( 2 ) * s ( 1 ) * s ( 0 ) - s ( 2 ) * c ( 0 ) ; d@@ R . row ( 5 ) << c ( 1 ) * c ( 0 ) , - s ( 1 ) * s ( 0 ) , 0 ; d@@ R . row ( 6 ) << c ( 2 ) * s ( 1 ) * - s ( 0 ) + s ( 2 ) * c ( 0 ) , c ( 2 ) * c ( 1 ) * c ( 0 ) , - s ( 2 ) * s ( 1 ) * c ( 0 ) + c ( 2 ) * s ( 0 ) ; d@@ R . row ( 7 ) << s ( 2 ) * s ( 1 ) * - s ( 0 ) - c ( 2 ) * c ( 0 ) , s ( 2 ) * c ( 1 ) * c ( 0 ) , c ( 2 ) * s ( 1 ) * c ( 0 ) + s ( 2 ) * s ( 0 ) ; d@@ R . row ( 8 ) << c ( 1 ) * - s ( 0 ) , - s ( 1 ) * c ( 0 ) , 0 ; return d@@ R ; }
template < typename Deri@@ ved > typename Gradi@@ ent < Matrix < typename Deri@@ ved :: Scalar , 3 , 3 > , QU@@ AT_@@ SIZE > :: type d@@ qu@@ at@@ 2@@ rot@@ mat ( const Eigen :: Matrix@@ Base < Deri@@ ved > & q ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , QU@@ AT_@@ SIZE ) ; typename Gradi@@ ent < Matrix < typename Deri@@ ved :: Scalar , 3 , 3 > , QU@@ AT_@@ SIZE > :: type ret ; typename Eigen :: Matrix@@ Base < Deri@@ ved > :: Pla@@ in@@ Object q@@ ti@@ l@@ de ; typename Gradi@@ ent < Deri@@ ved , QU@@ AT_@@ SIZE > :: type d@@ q@@ ti@@ l@@ de ; normalize@@ Vec ( q , q@@ ti@@ l@@ de , & d@@ q@@ ti@@ l@@ de ) ; typedef typename Deri@@ ved :: Scalar Scalar ; Scalar w = q@@ ti@@ l@@ de ( 0 ) ; Scalar x = q@@ ti@@ l@@ de ( 1 ) ; Scalar y = q@@ ti@@ l@@ de ( 2 ) ; Scalar z = q@@ ti@@ l@@ de ( 3 ) ; ret << w , x , - y , - z , z , y , x , w , - y , z , - w , x , - z , y , x , - w , w , - x , y , - z , x , w , z , y , y , z , w , x , - x , - w , z , y , w , - x , - y , z ; ret *= 2.0 ; ret *= d@@ q@@ ti@@ l@@ de ; return ret ; }
template < typename Deri@@ ved@@ R , typename Deri@@ ved@@ DR > typename Gradi@@ ent < Eigen :: Matrix < typename Deri@@ ved@@ R :: Scalar , RP@@ Y_SIZE , 1 > , Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > :: type d@@ rot@@ mat@@ 2@@ r@@ py ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ R > & R , const Eigen :: Matrix@@ Base < Deri@@ ved@@ DR > & d@@ R ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ MAT@@ RI@@ X@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved@@ R > , SP@@ ACE_@@ DIMEN@@ SION , SP@@ ACE_@@ DIMEN@@ SION ) ; EIG@@ EN@@ _STAT@@ IC_@@ ASSERT ( Eigen :: Matrix@@ Base < Deri@@ ved@@ DR > :: Row@@ s@@ At@@ Compile@@ Time == Ro@@ tmat@@ Size , TH@@ IS_@@ METHO@@ D_@@ IS_@@ ONLY_@@ FOR_@@ MAT@@ R@@ IC@@ ES_@@ OF@@ _A@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ) ; typename Deri@@ ved@@ DR :: Index n@@ q = d@@ R . cols ( ) ; typedef typename Deri@@ ved@@ R :: Scalar Scalar ; typedef typename Gradi@@ ent < Eigen :: Matrix < Scalar , RP@@ Y_SIZE , 1 > , Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > :: type Return@@ Type ; Return@@ Type dr@@ py ( RP@@ Y_SIZE , n@@ q ) ; auto d@@ R@@ 11@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 0 , 0 , R . rows ( ) ) ; auto d@@ R@@ 21@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 1 , 0 , R . rows ( ) ) ; auto d@@ R@@ 3@@ 1@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 2 , 0 , R . rows ( ) ) ; auto d@@ R@@ 32@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 2 , 1 , R . rows ( ) ) ; auto d@@ R@@ 33@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 2 , 2 , R . rows ( ) ) ; Scalar sq@@ term = R ( 2 , 1 ) * R ( 2 , 1 ) + R ( 2 , 2 ) * R ( 2 , 2 ) ; using namespace std ; dr@@ py . row ( 0 ) = ( R ( 2 , 2 ) * d@@ R@@ 32@@ _d@@ q - R ( 2 , 1 ) * d@@ R@@ 33@@ _d@@ q ) / sq@@ term ; Scalar sq@@ rt_@@ sq@@ term = sqrt ( sq@@ term ) ; dr@@ py . row ( 1 ) = ( - sq@@ rt_@@ sq@@ term * d@@ R@@ 3@@ 1@@ _d@@ q + R ( 2 , 0 ) / sq@@ rt_@@ sq@@ term * ( R ( 2 , 1 ) * d@@ R@@ 32@@ _d@@ q + R ( 2 , 2 ) * d@@ R@@ 33@@ _d@@ q ) ) / ( R ( 2 , 0 ) * R ( 2 , 0 ) + R ( 2 , 1 ) * R ( 2 , 1 ) + R ( 2 , 2 ) * R ( 2 , 2 ) ) ; sq@@ term = R ( 0 , 0 ) * R ( 0 , 0 ) + R ( 1 , 0 ) * R ( 1 , 0 ) ; dr@@ py . row ( 2 ) = ( R ( 0 , 0 ) * d@@ R@@ 21@@ _d@@ q - R ( 1 , 0 ) * d@@ R@@ 11@@ _d@@ q ) / sq@@ term ; return dr@@ py ; }
template < typename Deri@@ ved@@ R , typename Deri@@ ved@@ DR > typename Gradi@@ ent < Eigen :: Matrix < typename Deri@@ ved@@ R :: Scalar , QU@@ AT_@@ SIZE , 1 > , Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > :: type d@@ rot@@ mat@@ 2@@ quat ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ R > & R , const Eigen :: Matrix@@ Base < Deri@@ ved@@ DR > & d@@ R ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ MAT@@ RI@@ X@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved@@ R > , SP@@ ACE_@@ DIMEN@@ SION , SP@@ ACE_@@ DIMEN@@ SION ) ; EIG@@ EN@@ _STAT@@ IC_@@ ASSERT ( Eigen :: Matrix@@ Base < Deri@@ ved@@ DR > :: Row@@ s@@ At@@ Compile@@ Time == Ro@@ tmat@@ Size , TH@@ IS_@@ METHO@@ D_@@ IS_@@ ONLY_@@ FOR_@@ MAT@@ R@@ IC@@ ES_@@ OF@@ _A@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ) ; typedef typename Deri@@ ved@@ R :: Scalar Scalar ; typedef typename Gradi@@ ent < Eigen :: Matrix < Scalar , QU@@ AT_@@ SIZE , 1 > , Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > :: type Return@@ Type ; typename Deri@@ ved@@ DR :: Index n@@ q = d@@ R . cols ( ) ; auto d@@ R@@ 11@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 0 , 0 , R . rows ( ) ) ; auto d@@ R@@ 12@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 0 , 1 , R . rows ( ) ) ; auto d@@ R@@ 13@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 0 , 2 , R . rows ( ) ) ; auto d@@ R@@ 21@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 1 , 0 , R . rows ( ) ) ; auto d@@ R@@ 2@@ 2_@@ d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 1 , 1 , R . rows ( ) ) ; auto d@@ R@@ 23@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 1 , 2 , R . rows ( ) ) ; auto d@@ R@@ 3@@ 1@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 2 , 0 , R . rows ( ) ) ; auto d@@ R@@ 32@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 2 , 1 , R . rows ( ) ) ; auto d@@ R@@ 33@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 2 , 2 , R . rows ( ) ) ; Matrix < Scalar , 4 , 3 > A ; A . row ( 0 ) << 1.0 , 1.0 , 1.0 ; A . row ( 1 ) << 1.0 , - 1.0 , - 1.0 ; A . row ( 2 ) << - 1.0 , 1.0 , - 1.0 ; A . row ( 3 ) << - 1.0 , - 1.0 , 1.0 ; Matrix < Scalar , 4 , 1 > B = A * R . diag@@ on@@ al ( ) ; typename Matrix < Scalar , 4 , 1 > :: Index ind , max_@@ col ; Scalar val = B . max@@ Coe@@ ff ( & ind , & max_@@ col ) ; Return@@ Type d@@ q ( QU@@ AT_@@ SIZE , n@@ q ) ; using namespace std ; switch ( ind ) { case 0 : { auto d@@ val@@ d@@ q = d@@ R@@ 11@@ _d@@ q + d@@ R@@ 2@@ 2_@@ d@@ q + d@@ R@@ 33@@ _d@@ q ; auto dw@@ d@@ q = d@@ val@@ d@@ q / ( 4.@@ 0 * sqrt ( 1.0 + val ) ) ; auto w = sqrt ( 1.0 + val ) / 2.0 ; auto w@@ squ@@ are@@ 4 = 4.@@ 0 * w * w ; d@@ q . row ( 0 ) = dw@@ d@@ q ; d@@ q . row ( 1 ) = ( ( d@@ R@@ 32@@ _d@@ q - d@@ R@@ 23@@ _d@@ q ) * w - ( R ( 2 , 1 ) - R ( 1 , 2 ) ) * dw@@ d@@ q ) / w@@ squ@@ are@@ 4 ; d@@ q . row ( 2 ) = ( ( d@@ R@@ 13@@ _d@@ q - d@@ R@@ 3@@ 1@@ _d@@ q ) * w - ( R ( 0 , 2 ) - R ( 2 , 0 ) ) * dw@@ d@@ q ) / w@@ squ@@ are@@ 4 ; d@@ q . row ( 3 ) = ( ( d@@ R@@ 21@@ _d@@ q - d@@ R@@ 12@@ _d@@ q ) * w - ( R ( 1 , 0 ) - R ( 0 , 1 ) ) * dw@@ d@@ q ) / w@@ squ@@ are@@ 4 ; break ; } case 1 : { auto d@@ val@@ d@@ q = d@@ R@@ 11@@ _d@@ q - d@@ R@@ 2@@ 2_@@ d@@ q - d@@ R@@ 33@@ _d@@ q ; auto s = 2.0 * sqrt ( 1.0 + val ) ; auto ss@@ qu@@ are = s * s ; auto dsd@@ q = d@@ val@@ d@@ q / sqrt ( 1.0 + val ) ; d@@ q . row ( 0 ) = ( ( d@@ R@@ 32@@ _d@@ q - d@@ R@@ 23@@ _d@@ q ) * s - ( R ( 2 , 1 ) - R ( 1 , 2 ) ) * dsd@@ q ) / ss@@ qu@@ are ; d@@ q . row ( 1 ) = .@@ 25 * dsd@@ q ; d@@ q . row ( 2 ) = ( ( d@@ R@@ 12@@ _d@@ q + d@@ R@@ 21@@ _d@@ q ) * s - ( R ( 0 , 1 ) + R ( 1 , 0 ) ) * dsd@@ q ) / ss@@ qu@@ are ; d@@ q . row ( 3 ) = ( ( d@@ R@@ 13@@ _d@@ q + d@@ R@@ 3@@ 1@@ _d@@ q ) * s - ( R ( 0 , 2 ) + R ( 2 , 0 ) ) * dsd@@ q ) / ss@@ qu@@ are ; break ; } case 2 : { auto d@@ val@@ d@@ q = - d@@ R@@ 11@@ _d@@ q + d@@ R@@ 2@@ 2_@@ d@@ q - d@@ R@@ 33@@ _d@@ q ; auto s = 2.0 * ( sqrt ( 1.0 + val ) ) ; auto ss@@ qu@@ are = s * s ; auto dsd@@ q = d@@ val@@ d@@ q / sqrt ( 1.0 + val ) ; d@@ q . row ( 0 ) = ( ( d@@ R@@ 13@@ _d@@ q - d@@ R@@ 3@@ 1@@ _d@@ q ) * s - ( R ( 0 , 2 ) - R ( 2 , 0 ) ) * dsd@@ q ) / ss@@ qu@@ are ; d@@ q . row ( 1 ) = ( ( d@@ R@@ 12@@ _d@@ q + d@@ R@@ 21@@ _d@@ q ) * s - ( R ( 0 , 1 ) + R ( 1 , 0 ) ) * dsd@@ q ) / ss@@ qu@@ are ; d@@ q . row ( 2 ) = .@@ 25 * dsd@@ q ; d@@ q . row ( 3 ) = ( ( d@@ R@@ 23@@ _d@@ q + d@@ R@@ 32@@ _d@@ q ) * s - ( R ( 1 , 2 ) + R ( 2 , 1 ) ) * dsd@@ q ) / ss@@ qu@@ are ; break ; } default : { auto d@@ val@@ d@@ q = - d@@ R@@ 11@@ _d@@ q - d@@ R@@ 2@@ 2_@@ d@@ q + d@@ R@@ 33@@ _d@@ q ; auto s = 2.0 * ( sqrt ( 1.0 + val ) ) ; auto ss@@ qu@@ are = s * s ; auto dsd@@ q = d@@ val@@ d@@ q / sqrt ( 1.0 + val ) ; d@@ q . row ( 0 ) = ( ( d@@ R@@ 21@@ _d@@ q - d@@ R@@ 12@@ _d@@ q ) * s - ( R ( 1 , 0 ) - R ( 0 , 1 ) ) * dsd@@ q ) / ss@@ qu@@ are ; d@@ q . row ( 1 ) = ( ( d@@ R@@ 13@@ _d@@ q + d@@ R@@ 3@@ 1@@ _d@@ q ) * s - ( R ( 0 , 2 ) + R ( 2 , 0 ) ) * dsd@@ q ) / ss@@ qu@@ are ; d@@ q . row ( 2 ) = ( ( d@@ R@@ 23@@ _d@@ q + d@@ R@@ 32@@ _d@@ q ) * s - ( R ( 1 , 2 ) + R ( 2 , 1 ) ) * dsd@@ q ) / ss@@ qu@@ are ; d@@ q . row ( 3 ) = .@@ 25 * dsd@@ q ; break ; } } return d@@ q ; }
template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 3 > vector@@ To@@ S@@ ke@@ w@@ Sy@@ mm@@ et@@ ric ( const Eigen :: Matrix@@ Base < Deri@@ ved > & p ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , SP@@ ACE_@@ DIMEN@@ SION ) ; Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 3 > ret ; ret << 0.0 , - p ( 2 ) , p ( 1 ) , p ( 2 ) , 0.0 , - p ( 0 ) , - p ( 1 ) , p ( 0 ) , 0.0 ; return ret ; }
template < typename Deri@@ ved@@ A , typename Deri@@ ved@@ B > Eigen :: Matrix < typename Deri@@ ved@@ A :: Scalar , 3 , Eigen :: Dynamic > d@@ cro@@ ss@@ Product ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ A > & a , const Eigen :: Matrix@@ Base < Deri@@ ved@@ B > & b , const typename Gradi@@ ent < Deri@@ ved@@ A , Eigen :: Dynamic > :: type & da , const typename Gradi@@ ent < Deri@@ ved@@ B , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename Deri@@ ved@@ A :: Scalar , 3 , Eigen :: Dynamic > ret ( 3 , da . cols ( ) ) ; ret . no@@ al@@ ias ( ) = da . col@@ w@@ ise ( ) . cross ( b ) ; ret . no@@ al@@ ias ( ) -= db . col@@ w@@ ise ( ) . cross ( a ) ; return ret ; }
template < typename Deri@@ ved > DL@@ LEXPORT Gradient@@ Var < typename Deri@@ ved :: Scalar , Eigen :: Dynamic , SP@@ ACE_@@ DIMEN@@ SION > ang@@ ular@@ vel@@ 2@@ Re@@ present@@ ation@@ Dot@@ Matrix ( int rot@@ ation@@ _type , const Eigen :: Matrix@@ Base < Deri@@ ved > & q@@ rot , int gradi@@ ent_@@ order ) { Gradient@@ Var < typename Deri@@ ved :: Scalar , Eigen :: Dynamic , SP@@ ACE_@@ DIMEN@@ SION > ret ( q@@ rot . rows ( ) , SP@@ ACE_@@ DIMEN@@ SION , q@@ rot . rows ( ) , gradi@@ ent_@@ order ) ; switch ( rot@@ ation@@ _type ) { case 0 : break ; case 1 : { if ( gradi@@ ent_@@ order > 1 ) { ang@@ ular@@ vel@@ 2@@ r@@ py@@ do@@ t@@ Matrix ( q@@ rot , ret . value ( ) , & ret . gradi@@ ent ( ) . value ( ) , & ret . gradi@@ ent ( ) . gradi@@ ent ( ) . value ( ) ) ; } else if ( gradi@@ ent_@@ order > 0 ) { ang@@ ular@@ vel@@ 2@@ r@@ py@@ do@@ t@@ Matrix ( q@@ rot , ret . value ( ) , & ret . gradi@@ ent ( ) . value ( ) , ( MatrixXd * ) nullptr ) ; } else { ang@@ ular@@ vel@@ 2@@ r@@ py@@ do@@ t@@ Matrix ( q@@ rot , ret . value ( ) , ( MatrixXd * ) nullptr , ( MatrixXd * ) nullptr ) ; } break ; } case 2 : { if ( gradi@@ ent_@@ order > 1 ) { ret . gradi@@ ent ( ) . gradi@@ ent ( ) . value ( ) . setZero ( ) ; } if ( gradi@@ ent_@@ order > 0 ) { ang@@ ular@@ vel@@ 2@@ qu@@ at@@ do@@ t@@ Matrix ( q@@ rot , ret . value ( ) , & ret . gradi@@ ent ( ) . value ( ) ) ; } else { ang@@ ular@@ vel@@ 2@@ qu@@ at@@ do@@ t@@ Matrix ( q@@ rot , ret . value ( ) , ( MatrixXd * ) nullptr ) ; } break ; } default : throw std :: runtime_error ( " rotation ▁ re@@ presentation ▁ type ▁ not ▁ reco@@ gnized " ) ; } return ret ; }
template < typename Deri@@ ved@@ M > typename Transform@@ Sp@@ ati@@ al < Deri@@ ved@@ M > :: type transform@@ Sp@@ ati@@ al@@ Mo@@ tion ( const Eigen :: Transform < typename Deri@@ ved@@ M :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: Matrix@@ Base < Deri@@ ved@@ M > & M ) { Eigen :: Matrix < typename Deri@@ ved@@ M :: Scalar , TW@@ IS@@ T_@@ SIZE , Deri@@ ved@@ M :: Col@@ s@@ At@@ Compile@@ Time > ret ( TW@@ IS@@ T_@@ SIZE , M . cols ( ) ) ; ret . template top@@ Rows < 3 > ( ) . no@@ al@@ ias ( ) = T . linear ( ) * M . template top@@ Rows < 3 > ( ) ; ret . template botto@@ m@@ Rows < 3 > ( ) . no@@ al@@ ias ( ) = - ret . template top@@ Rows < 3 > ( ) . col@@ w@@ ise ( ) . cross ( T . translation ( ) ) ; ret . template botto@@ m@@ Rows < 3 > ( ) . no@@ al@@ ias ( ) += T . linear ( ) * M . template botto@@ m@@ Rows < 3 > ( ) ; return ret ; }
template < typename Deri@@ ved@@ F > typename Transform@@ Sp@@ ati@@ al < Deri@@ ved@@ F > :: type transform@@ Sp@@ ati@@ al@@ For@@ ce ( const Eigen :: Transform < typename Deri@@ ved@@ F :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: Matrix@@ Base < Deri@@ ved@@ F > & F ) { Eigen :: Matrix < typename Deri@@ ved@@ F :: Scalar , TW@@ IS@@ T_@@ SIZE , Deri@@ ved@@ F :: Col@@ s@@ At@@ Compile@@ Time > ret ( TW@@ IS@@ T_@@ SIZE , F . cols ( ) ) ; ret . template botto@@ m@@ Rows < 3 > ( ) . no@@ al@@ ias ( ) = T . linear ( ) * F . template botto@@ m@@ Rows < 3 > ( ) . eval ( ) ; ret . template top@@ Rows < 3 > ( ) = - ret . template botto@@ m@@ Rows < 3 > ( ) . col@@ w@@ ise ( ) . cross ( T . translation ( ) ) ; ret . template top@@ Rows < 3 > ( ) . no@@ al@@ ias ( ) += T . linear ( ) * F . template top@@ Rows < 3 > ( ) ; return ret ; }
template < typename Deri@@ ved@@ I > Gradient@@ Var < typename Deri@@ ved@@ I :: Scalar , TW@@ IS@@ T_@@ SIZE , TW@@ IS@@ T_@@ SIZE > transform@@ Sp@@ ati@@ al@@ Inerti@@ a ( const Eigen :: Transform < typename Deri@@ ved@@ I :: Scalar , SP@@ ACE_@@ DIMEN@@ SION , Eigen :: Isometry > & T_@@ current_@@ to_@@ new , const typename Gradi@@ ent < typename Eigen :: Transform < typename Deri@@ ved@@ I :: Scalar , SP@@ ACE_@@ DIMEN@@ SION , Eigen :: Isometry > :: MatrixType , Eigen :: Dynamic > :: type * d@@ T_@@ current_@@ to_@@ new , const Eigen :: Matrix@@ Base < Deri@@ ved@@ I > & I ) { int gradi@@ ent_@@ order ; typename Deri@@ ved@@ I :: Index n@@ q ; if ( d@@ T_@@ current_@@ to_@@ new ) { gradi@@ ent_@@ order = 1 ; n@@ q = d@@ T_@@ current_@@ to_@@ new -> cols ( ) ; } else { n@@ q = 0 ; gradi@@ ent_@@ order = 0 ; } Gradient@@ Var < typename Deri@@ ved@@ I :: Scalar , TW@@ IS@@ T_@@ SIZE , TW@@ IS@@ T_@@ SIZE > ret ( TW@@ IS@@ T_@@ SIZE , TW@@ IS@@ T_@@ SIZE , n@@ q , gradi@@ ent_@@ order ) ; auto I@@ _h@@ al@@ f_@@ transform@@ ed = transform@@ Sp@@ ati@@ al@@ For@@ ce ( T_@@ current_@@ to_@@ new , I ) ; ret . value ( ) = transform@@ Sp@@ ati@@ al@@ For@@ ce ( T_@@ current_@@ to_@@ new , I@@ _h@@ al@@ f_@@ transform@@ ed . transpose ( ) ) ; if ( gradi@@ ent_@@ order > 0 ) { auto d@@ I = Eigen :: Matrix < typename Deri@@ ved@@ I :: Scalar , Deri@@ ved@@ I :: Size@@ At@@ Compile@@ Time , Eigen :: Dynamic > :: Zero ( I . size ( ) , n@@ q ) . eval ( ) ; auto d@@ I@@ _h@@ al@@ f_@@ transform@@ ed = d@@ Transform@@ Sp@@ ati@@ al@@ For@@ ce ( T_@@ current_@@ to_@@ new , I , * d@@ T_@@ current_@@ to_@@ new , d@@ I ) ; auto d@@ I@@ _h@@ al@@ f_@@ transform@@ ed_@@ transpose = transpose@@ Gra@@ d ( d@@ I@@ _h@@ al@@ f_@@ transform@@ ed , I@@ _h@@ al@@ f_@@ transform@@ ed . rows ( ) ) ; ret . gradi@@ ent ( ) . value ( ) = d@@ Transform@@ Sp@@ ati@@ al@@ For@@ ce ( T_@@ current_@@ to_@@ new , I@@ _h@@ al@@ f_@@ transform@@ ed . transpose ( ) , * d@@ T_@@ current_@@ to_@@ new , d@@ I@@ _h@@ al@@ f_@@ transform@@ ed_@@ transpose ) ; } return ret ; }
template < typename Deri@@ ved@@ A , typename Deri@@ ved@@ B > typename Transform@@ Sp@@ ati@@ al < Deri@@ ved@@ B > :: type cro@@ ss@@ Sp@@ ati@@ al@@ Mo@@ tion ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ A > & a , const Eigen :: Matrix@@ Base < Deri@@ ved@@ B > & b ) { typename Transform@@ Sp@@ ati@@ al < Deri@@ ved@@ B > :: type ret ( TW@@ IS@@ T_@@ SIZE , b . cols ( ) ) ; ret . template top@@ Rows < 3 > ( ) = - b . template top@@ Rows < 3 > ( ) . col@@ w@@ ise ( ) . cross ( a . template top@@ Rows < 3 > ( ) ) ; ret . template botto@@ m@@ Rows < 3 > ( ) = - b . template top@@ Rows < 3 > ( ) . col@@ w@@ ise ( ) . cross ( a . template botto@@ m@@ Rows < 3 > ( ) ) ; ret . template botto@@ m@@ Rows < 3 > ( ) -= b . template botto@@ m@@ Rows < 3 > ( ) . col@@ w@@ ise ( ) . cross ( a . template top@@ Rows < 3 > ( ) ) ; return ret ; }
template < typename Deri@@ ved@@ A , typename Deri@@ ved@@ B > typename Transform@@ Sp@@ ati@@ al < Deri@@ ved@@ B > :: type cro@@ ss@@ Sp@@ ati@@ al@@ For@@ ce ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ A > & a , const Eigen :: Matrix@@ Base < Deri@@ ved@@ B > & b ) { typename Transform@@ Sp@@ ati@@ al < Deri@@ ved@@ B > :: type ret ( TW@@ IS@@ T_@@ SIZE , b . cols ( ) ) ; ret . template top@@ Rows < 3 > ( ) = - b . template top@@ Rows < 3 > ( ) . col@@ w@@ ise ( ) . cross ( a . template top@@ Rows < 3 > ( ) ) ; ret . template top@@ Rows < 3 > ( ) -= b . template botto@@ m@@ Rows < 3 > ( ) . col@@ w@@ ise ( ) . cross ( a . template botto@@ m@@ Rows < 3 > ( ) ) ; ret . template botto@@ m@@ Rows < 3 > ( ) = - b . template botto@@ m@@ Rows < 3 > ( ) . col@@ w@@ ise ( ) . cross ( a . template top@@ Rows < 3 > ( ) ) ; return ret ; }
template < typename Deri@@ ved@@ A , typename Deri@@ ved@@ B > Eigen :: Matrix < typename Deri@@ ved@@ A :: Scalar , TW@@ IS@@ T_@@ SIZE , Eigen :: Dynamic > d@@ Cross@@ Sp@@ ati@@ al@@ Mo@@ tion ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ A > & a , const Eigen :: Matrix@@ Base < Deri@@ ved@@ B > & b , const typename Gradi@@ ent < Deri@@ ved@@ A , Eigen :: Dynamic > :: type & da , const typename Gradi@@ ent < Deri@@ ved@@ B , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename Deri@@ ved@@ A :: Scalar , TW@@ IS@@ T_@@ SIZE , Eigen :: Dynamic > ret ( TW@@ IS@@ T_@@ SIZE , da . cols ( ) ) ; ret . row ( 0 ) = - da . row ( 2 ) * b [ 1 ] + da . row ( 1 ) * b [ 2 ] - a [ 2 ] * db . row ( 1 ) + a [ 1 ] * db . row ( 2 ) ; ret . row ( 1 ) = da . row ( 2 ) * b [ 0 ] - da . row ( 0 ) * b [ 2 ] + a [ 2 ] * db . row ( 0 ) - a [ 0 ] * db . row ( 2 ) ; ret . row ( 2 ) = - da . row ( 1 ) * b [ 0 ] + da . row ( 0 ) * b [ 1 ] - a [ 1 ] * db . row ( 0 ) + a [ 0 ] * db . row ( 1 ) ; ret . row ( 3 ) = - da . row ( 5 ) * b [ 1 ] + da . row ( 4 ) * b [ 2 ] - da . row ( 2 ) * b [ 4 ] + da . row ( 1 ) * b [ 5 ] - a [ 5 ] * db . row ( 1 ) + a [ 4 ] * db . row ( 2 ) - a [ 2 ] * db . row ( 4 ) + a [ 1 ] * db . row ( 5 ) ; ret . row ( 4 ) = da . row ( 5 ) * b [ 0 ] - da . row ( 3 ) * b [ 2 ] + da . row ( 2 ) * b [ 3 ] - da . row ( 0 ) * b [ 5 ] + a [ 5 ] * db . row ( 0 ) - a [ 3 ] * db . row ( 2 ) + a [ 2 ] * db . row ( 3 ) - a [ 0 ] * db . row ( 5 ) ; ret . row ( 5 ) = - da . row ( 4 ) * b [ 0 ] + da . row ( 3 ) * b [ 1 ] - da . row ( 1 ) * b [ 3 ] + da . row ( 0 ) * b [ 4 ] - a [ 4 ] * db . row ( 0 ) + a [ 3 ] * db . row ( 1 ) - a [ 1 ] * db . row ( 3 ) + a [ 0 ] * db . row ( 4 ) ; return ret ; }
template < typename Deri@@ ved@@ A , typename Deri@@ ved@@ B > Eigen :: Matrix < typename Deri@@ ved@@ A :: Scalar , TW@@ IS@@ T_@@ SIZE , Eigen :: Dynamic > d@@ Cross@@ Sp@@ ati@@ al@@ For@@ ce ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ A > & a , const Eigen :: Matrix@@ Base < Deri@@ ved@@ B > & b , const typename Gradi@@ ent < Deri@@ ved@@ A , Eigen :: Dynamic > :: type & da , const typename Gradi@@ ent < Deri@@ ved@@ B , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename Deri@@ ved@@ A :: Scalar , TW@@ IS@@ T_@@ SIZE , Eigen :: Dynamic > ret ( TW@@ IS@@ T_@@ SIZE , da . cols ( ) ) ; ret . row ( 0 ) = da . row ( 2 ) * b [ 1 ] - da . row ( 1 ) * b [ 2 ] + da . row ( 5 ) * b [ 4 ] - da . row ( 4 ) * b [ 5 ] + a [ 2 ] * db . row ( 1 ) - a [ 1 ] * db . row ( 2 ) + a [ 5 ] * db . row ( 4 ) - a [ 4 ] * db . row ( 5 ) ; ret . row ( 1 ) = - da . row ( 2 ) * b [ 0 ] + da . row ( 0 ) * b [ 2 ] - da . row ( 5 ) * b [ 3 ] + da . row ( 3 ) * b [ 5 ] - a [ 2 ] * db . row ( 0 ) + a [ 0 ] * db . row ( 2 ) - a [ 5 ] * db . row ( 3 ) + a [ 3 ] * db . row ( 5 ) ; ret . row ( 2 ) = da . row ( 1 ) * b [ 0 ] - da . row ( 0 ) * b [ 1 ] + da . row ( 4 ) * b [ 3 ] - da . row ( 3 ) * b [ 4 ] + a [ 1 ] * db . row ( 0 ) - a [ 0 ] * db . row ( 1 ) + a [ 4 ] * db . row ( 3 ) - a [ 3 ] * db . row ( 4 ) ; ret . row ( 3 ) = da . row ( 2 ) * b [ 4 ] - da . row ( 1 ) * b [ 5 ] + a [ 2 ] * db . row ( 4 ) - a [ 1 ] * db . row ( 5 ) ; ret . row ( 4 ) = - da . row ( 2 ) * b [ 3 ] + da . row ( 0 ) * b [ 5 ] - a [ 2 ] * db . row ( 3 ) + a [ 0 ] * db . row ( 5 ) ; ret . row ( 5 ) = da . row ( 1 ) * b [ 3 ] - da . row ( 0 ) * b [ 4 ] + a [ 1 ] * db . row ( 3 ) - a [ 0 ] * db . row ( 4 ) ; ret = - ret ; return ret ; }
template < typename Deri@@ ved@@ S , typename Deri@@ ved@@ Q@@ do@@ t@@ To@@ V > typename D@@ Ho@@ mo@@ g@@ Tran@@ s < Deri@@ ved@@ Q@@ do@@ t@@ To@@ V > :: type d@@ Ho@@ mo@@ g@@ Tran@@ s ( const Eigen :: Transform < typename Deri@@ ved@@ Q@@ do@@ t@@ To@@ V :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: Matrix@@ Base < Deri@@ ved@@ S > & S , const Eigen :: Matrix@@ Base < Deri@@ ved@@ Q@@ do@@ t@@ To@@ V > & q@@ do@@ t_@@ to_@@ v ) { const int n@@ q@@ _@@ at@@ _@@ compile_@@ time = Deri@@ ved@@ Q@@ do@@ t@@ To@@ V :: Col@@ s@@ At@@ Compile@@ Time ; typename Deri@@ ved@@ Q@@ do@@ t@@ To@@ V :: Index n@@ q = q@@ do@@ t_@@ to_@@ v . cols ( ) ; auto q@@ do@@ t_@@ to_@@ tw@@ ist = ( S * q@@ do@@ t_@@ to_@@ v ) . eval ( ) ; const int num@@ el = HO@@ MO@@ G@@ EN@@ E@@ O@@ US_@@ TRANS@@ FOR@@ M@@ _SIZE ; Eigen :: Matrix < typename Deri@@ ved@@ Q@@ do@@ t@@ To@@ V :: Scalar , num@@ el , n@@ q@@ _@@ at@@ _@@ compile_@@ time > ret ( num@@ el , n@@ q ) ; const auto & R@@ x = T . linear ( ) . col ( 0 ) ; const auto & R@@ y = T . linear ( ) . col ( 1 ) ; const auto & R@@ z = T . linear ( ) . col ( 2 ) ; const auto & q@@ do@@ t_@@ to_@@ om@@ eg@@ a_@@ x = q@@ do@@ t_@@ to_@@ tw@@ ist . row ( 0 ) ; const auto & q@@ do@@ t_@@ to_@@ om@@ eg@@ a_@@ y = q@@ do@@ t_@@ to_@@ tw@@ ist . row ( 1 ) ; const auto & q@@ do@@ t_@@ to_@@ om@@ eg@@ a_@@ z = q@@ do@@ t_@@ to_@@ tw@@ ist . row ( 2 ) ; ret . template m@@ idd@@ le@@ Rows < 3 > ( 0 ) = - R@@ z * q@@ do@@ t_@@ to_@@ om@@ eg@@ a_@@ y + R@@ y * q@@ do@@ t_@@ to_@@ om@@ eg@@ a_@@ z ; ret . row ( 3 ) . setZero ( ) ; ret . template m@@ idd@@ le@@ Rows < 3 > ( 4 ) = R@@ z * q@@ do@@ t_@@ to_@@ om@@ eg@@ a_@@ x - R@@ x * q@@ do@@ t_@@ to_@@ om@@ eg@@ a_@@ z ; ret . row ( 7 ) . setZero ( ) ; ret . template m@@ idd@@ le@@ Rows < 3 > ( 8 ) = - R@@ y * q@@ do@@ t_@@ to_@@ om@@ eg@@ a_@@ x + R@@ x * q@@ do@@ t_@@ to_@@ om@@ eg@@ a_@@ y ; ret . row ( 11 ) . setZero ( ) ; ret . template m@@ idd@@ le@@ Rows < 3 > ( 12 ) = T . linear ( ) * q@@ do@@ t_@@ to_@@ tw@@ ist . botto@@ m@@ Rows ( 3 ) ; ret . row ( 15 ) . setZero ( ) ; return ret ; }
template < typename Deri@@ ved@@ DT > typename D@@ Ho@@ mo@@ g@@ Tran@@ s < Deri@@ ved@@ DT > :: type d@@ Ho@@ mo@@ g@@ Trans@@ In@@ v ( const Eigen :: Transform < typename Deri@@ ved@@ DT :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: Matrix@@ Base < Deri@@ ved@@ DT > & d@@ T ) { typename Deri@@ ved@@ DT :: Index n@@ q = d@@ T . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_@@ cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_@@ cols = { 3 } ; auto d@@ R = getSub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( d@@ T , rows , R_@@ cols , T . Rows ) ; auto dp = getSub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( d@@ T , rows , p_@@ cols , T . Rows ) ; auto d@@ inv@@ T_@@ R = transpose@@ Gra@@ d ( d@@ R , R . rows ( ) ) ; auto d@@ inv@@ T_@@ p = ( - R . transpose ( ) * dp - mat@@ Gr@@ ad@@ M@@ ult ( d@@ inv@@ T_@@ R , p ) ) . eval ( ) ; const int num@@ el = HO@@ MO@@ G@@ EN@@ E@@ O@@ US_@@ TRANS@@ FOR@@ M@@ _SIZE ; Eigen :: Matrix < typename Deri@@ ved@@ DT :: Scalar , num@@ el , Deri@@ ved@@ DT :: Col@@ s@@ At@@ Compile@@ Time > ret ( num@@ el , n@@ q ) ; set@@ Sub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( ret , d@@ inv@@ T_@@ R , rows , R_@@ cols , T . Rows ) ; set@@ Sub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( ret , d@@ inv@@ T_@@ p , rows , p_@@ cols , T . Rows ) ; const int last_@@ row = 3 ; for ( int col = 0 ; col < T . H@@ Dim ; col ++ ) { ret . row ( last_@@ row + col * T . Rows ) . setZero ( ) ; } return ret ; }
template < typename Scalar , typename Deri@@ ved@@ X , typename Deri@@ ved@@ DT , typename Deri@@ ved@@ D@@ X > typename Gradi@@ ent < Deri@@ ved@@ X , Deri@@ ved@@ D@@ X :: Col@@ s@@ At@@ Compile@@ Time , 1 > :: type d@@ Transform@@ Sp@@ ati@@ al@@ Mo@@ tion ( const Eigen :: Transform < Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: Matrix@@ Base < Deri@@ ved@@ X > & X , const Eigen :: Matrix@@ Base < Deri@@ ved@@ DT > & d@@ T , const Eigen :: Matrix@@ Base < Deri@@ ved@@ D@@ X > & d@@ X ) { assert ( d@@ T . cols ( ) == d@@ X . cols ( ) ) ; typename Deri@@ ved@@ DT :: Index n@@ q = d@@ T . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_@@ cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_@@ cols = { 3 } ; auto d@@ R = getSub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( d@@ T , rows , R_@@ cols , T . Rows ) ; auto dp = getSub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( d@@ T , rows , p_@@ cols , T . Rows ) ; typename Gradi@@ ent < Deri@@ ved@@ X , Deri@@ ved@@ D@@ X :: Col@@ s@@ At@@ Compile@@ Time , 1 > :: type ret ( X . size ( ) , n@@ q ) ; std :: array < int , 3 > X@@ om@@ eg@@ a_@@ rows = { 0 , 1 , 2 } ; std :: array < int , 3 > X@@ v_@@ rows = { 3 , 4 , 5 } ; for ( int col = 0 ; col < X . cols ( ) ; col ++ ) { auto X@@ om@@ eg@@ a_@@ col = X . template block < 3 , 1 > ( 0 , col ) ; auto X@@ v_@@ col = X . template block < 3 , 1 > ( 3 , col ) ; auto R@@ X@@ om@@ eg@@ a_@@ col = ( R * X@@ om@@ eg@@ a_@@ col ) . eval ( ) ; std :: array < int , 1 > col@@ _@@ array = { col } ; auto d@@ X@@ om@@ eg@@ a_@@ col = getSub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( d@@ X , X@@ om@@ eg@@ a_@@ rows , col@@ _@@ array , X . rows ( ) ) ; auto d@@ X@@ v_@@ col = getSub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( d@@ X , X@@ v_@@ rows , col@@ _@@ array , X . rows ( ) ) ; auto do@@ me@@ g@@ a_@@ part_@@ col = ( R * d@@ X@@ om@@ eg@@ a_@@ col + mat@@ Gr@@ ad@@ M@@ ult ( d@@ R , X@@ om@@ eg@@ a_@@ col ) ) . eval ( ) ; auto d@@ v_@@ part_@@ col = ( R * d@@ X@@ v_@@ col + mat@@ Gr@@ ad@@ M@@ ult ( d@@ R , X@@ v_@@ col ) ) . eval ( ) ; d@@ v_@@ part_@@ col += dp . col@@ w@@ ise ( ) . cross ( R@@ X@@ om@@ eg@@ a_@@ col ) ; d@@ v_@@ part_@@ col -= do@@ me@@ g@@ a_@@ part_@@ col . col@@ w@@ ise ( ) . cross ( p ) ; set@@ Sub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( ret , do@@ me@@ g@@ a_@@ part_@@ col , X@@ om@@ eg@@ a_@@ rows , col@@ _@@ array , X . rows ( ) ) ; set@@ Sub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( ret , d@@ v_@@ part_@@ col , X@@ v_@@ rows , col@@ _@@ array , X . rows ( ) ) ; } return ret ; }
template < typename Scalar , typename Deri@@ ved@@ X , typename Deri@@ ved@@ DT , typename Deri@@ ved@@ D@@ X > typename Gradi@@ ent < Deri@@ ved@@ X , Deri@@ ved@@ D@@ X :: Col@@ s@@ At@@ Compile@@ Time > :: type d@@ Transform@@ Sp@@ ati@@ al@@ For@@ ce ( const Eigen :: Transform < Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: Matrix@@ Base < Deri@@ ved@@ X > & X , const Eigen :: Matrix@@ Base < Deri@@ ved@@ DT > & d@@ T , const Eigen :: Matrix@@ Base < Deri@@ ved@@ D@@ X > & d@@ X ) { assert ( d@@ T . cols ( ) == d@@ X . cols ( ) ) ; typename Deri@@ ved@@ DT :: Index n@@ q = d@@ T . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_@@ cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_@@ cols = { 3 } ; auto d@@ R = getSub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( d@@ T , rows , R_@@ cols , T . Rows ) ; auto dp = getSub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( d@@ T , rows , p_@@ cols , T . Rows ) ; typename Gradi@@ ent < Deri@@ ved@@ X , Deri@@ ved@@ D@@ X :: Col@@ s@@ At@@ Compile@@ Time > :: type ret ( X . size ( ) , n@@ q ) ; std :: array < int , 3 > X@@ om@@ eg@@ a_@@ rows = { 0 , 1 , 2 } ; std :: array < int , 3 > X@@ v_@@ rows = { 3 , 4 , 5 } ; for ( int col = 0 ; col < X . cols ( ) ; col ++ ) { auto X@@ om@@ eg@@ a_@@ col = X . template block < 3 , 1 > ( 0 , col ) ; auto X@@ v_@@ col = X . template block < 3 , 1 > ( 3 , col ) ; auto R@@ X@@ v_@@ col = ( R * X@@ v_@@ col ) . eval ( ) ; std :: array < int , 1 > col@@ _@@ array = { col } ; auto d@@ X@@ om@@ eg@@ a_@@ col = getSub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( d@@ X , X@@ om@@ eg@@ a_@@ rows , col@@ _@@ array , X . rows ( ) ) ; auto d@@ X@@ v_@@ col = getSub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( d@@ X , X@@ v_@@ rows , col@@ _@@ array , X . rows ( ) ) ; auto do@@ me@@ g@@ a_@@ part_@@ col = ( R * d@@ X@@ om@@ eg@@ a_@@ col ) . eval ( ) ; do@@ me@@ g@@ a_@@ part_@@ col += mat@@ Gr@@ ad@@ M@@ ult ( d@@ R , X@@ om@@ eg@@ a_@@ col ) ; auto d@@ v_@@ part_@@ col = ( R * d@@ X@@ v_@@ col ) . eval ( ) ; d@@ v_@@ part_@@ col += mat@@ Gr@@ ad@@ M@@ ult ( d@@ R , X@@ v_@@ col ) ; do@@ me@@ g@@ a_@@ part_@@ col += dp . col@@ w@@ ise ( ) . cross ( R@@ X@@ v_@@ col ) ; do@@ me@@ g@@ a_@@ part_@@ col -= d@@ v_@@ part_@@ col . col@@ w@@ ise ( ) . cross ( p ) ; set@@ Sub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( ret , do@@ me@@ g@@ a_@@ part_@@ col , X@@ om@@ eg@@ a_@@ rows , col@@ _@@ array , X . rows ( ) ) ; set@@ Sub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( ret , d@@ v_@@ part_@@ col , X@@ v_@@ rows , col@@ _@@ array , X . rows ( ) ) ; } return ret ; }
