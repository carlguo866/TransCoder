void QmitkDIAppConnectomicsPerspective :: CreateInitial@@ Layout ( berry :: IPageLayout :: Pointer layout ) { std :: string editorArea = layout -> GetEditorArea ( ) ; layout -> AddStandaloneView ( " org . mitk . views . datamanager " , false , berry :: IPageLayout :: LEFT , 0.3f , editorArea ) ; layout -> AddStandaloneView ( " org . mitk . views . controlvisualizationpropertiesview " , false , berry :: IPageLayout :: BOTTOM , .15f , " org . mitk . views . datamanager " ) ; berry :: IFolder@@ Layout :: Pointer left = layout -> CreateFolder ( " org . mbi . diffusionimaginginternal . leftcontrols " , berry :: IPageLayout :: BOTTOM , 0.1f , " org . mitk . views . controlvisualizationpropertiesview " ) ; layout -> AddStandaloneViewPlace@@ holder ( " org . mitk . views . imagenavig@@ ator " , berry :: IPageLayout :: BOTTOM , .4f , " org . mbi . diffusionimaginginternal . leftcontrols " , false ) ; left -> AddView ( " org . mitk . views . connectomicsstatistics " ) ; berry :: IViewLayout :: Pointer lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsstatistics " ) ; lo -> SetCloseable ( false ) ; left -> AddView ( " org . mitk . views . connectomicsnetworkoperations " ) ; lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsnetworkoperations " ) ; lo -> SetCloseable ( false ) ; left -> AddView ( " org . mitk . views . connectomicsdata " ) ; lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsdata " ) ; lo -> SetCloseable ( false ) ; }
std :: vector < std :: string > readFile ( std :: string filename ) { std :: vector < std :: string > lines ; std :: ifstream read ; std :: string line ; read . open ( filename . c_str ( ) ) ; if ( ! read . good ( ) ) { read . close ( ) ; std :: ofstream create ; create . open ( filename . c_str ( ) ) ; return lines ; } while ( ! read . eof ( ) ) { getline ( read , line ) ; if ( line != " " ) { lines . push_back ( line ) ; } } read . close ( ) ; return lines ; }
infosHasher :: infosHasher ( long cle , string cleTxt , vector < int > valueVecInt ) { m_hashKey = cle ; m_key = cleTxt ; m_value = valueVecInt ; }
long infosHasher :: getHashKey ( ) { return m_hashKey ; }
string infosHasher :: getKey ( ) { return m_key ; }
vector < int > infosHasher :: getValue ( ) { return m_value ; }
void infosHasher :: setValue ( vector < int > value ) { m_value = value ; }
string infosHasher :: toString ( ) { stringstream to_return ; to_return << m_hashKey << " \t " << m_key << " \t " << vectorToString ( m_value , " \t " ) << endl ; return to_return . str ( ) ; }
void CCustomData :: Copy ( CCustomData * pCustomData ) { std :: map < std :: string , SCustomData > :: const_iterator iter = pCustomData -> IterBegin ( ) ; for ( ; iter != pCustomData -> IterEnd ( ) ; iter ++ ) { Set ( iter -> first . c_str ( ) , iter -> second . Variable ) ; } }
SCustomData * CCustomData :: Get ( const char * szName ) { assert ( szName ) ; std :: map < std :: string , SCustomData > :: iterator it = m_Data . find ( szName ) ; if ( it != m_Data . end ( ) ) return & it -> second ; return NULL ; }
void CCustomData :: Set ( const char * szName , const CLuaArgument & Variable , bool bSynchronized ) { assert ( szName ) ; SCustomData * pData = Get ( szName ) ; if ( pData ) { pData -> Variable = Variable ; pData -> bSynchronized = bSynchronized ; } else { SCustomData newData ; newData . Variable = Variable ; newData . bSynchronized = bSynchronized ; m_Data [ szName ] = newData ; } }
bool CCustomData :: Delete ( const char * szName ) { std :: map < std :: string , SCustomData > :: iterator it = m_Data . find ( szName ) ; if ( it != m_Data . end ( ) ) { m_Data . erase ( it ) ; return true ; } return false ; }
String PseudoElement :: pseudoElementNameFor@@ Events ( PseudoId pseudoId ) { DEFINE_STATIC_LOCAL ( const String , after , ( " : : after " ) ) ; DEFINE_STATIC_LOCAL ( const String , before , ( " : : before " ) ) ; switch ( pseudoId ) { case AFTER : return after ; case BEFORE : return before ; default : return emptyString ( ) ; } }
PseudoElement :: PseudoElement ( Element * parent , PseudoId pseudoId ) : Element ( pseudoElementTagName ( pseudoId ) , & parent -> document ( ) , CreateElement ) , m_pseudoId ( pseudoId ) { ASSERT ( pseudoId != NOPSEUD@@ O ) ; setParentOrShadowHostNode ( parent ) ; setHasCustomStyleCallbacks ( ) ; }
PassRefPtr < RenderStyle > PseudoElement :: customStyleFor@@ Renderer ( ) { return parentOrShadowHostElement ( ) -> renderer ( ) -> getCachedPseudoStyle ( m_pseudoId ) ; }
void PseudoElement :: dispose ( ) { ASSERT ( parentOrShadowHostElement ( ) ) ; InspectorInstrumentation :: pseudoElementDestroyed ( this ) ; ASSERT ( ! nextSibling ( ) ) ; ASSERT ( ! previousSibling ( ) ) ; detach ( ) ; RefPtrWillBeRawPtr < Element > parent = parentOrShadowHostElement ( ) ; setParentOrShadowHostNode ( 0 ) ; removedFrom ( parent . get ( ) ) ; }
void PseudoElement :: attach ( const AttachContext & context ) { ASSERT ( ! renderer ( ) ) ; Element :: attach ( context ) ; RenderObject * renderer = this -> renderer ( ) ; if ( ! renderer ) return ; RenderStyle * style = renderer -> style ( ) ; if ( style -> styleType ( ) != BEFORE && style -> styleType ( ) != AFTER ) return ; ASSERT ( style -> contentData ( ) ) ; for ( const ContentData * content = style -> contentData ( ) ; content ; content = content -> next ( ) ) { RenderObject * child = content -> createRenderer ( document ( ) , style ) ; if ( renderer -> isChildAllow@@ ed ( child , style ) ) { renderer -> addChild ( child ) ; if ( child -> isQuote ( ) ) toRenderQuote ( child ) -> attachQuote ( ) ; } else child -> destroy ( ) ; } }
bool PseudoElement :: rendererIsNeeded ( const RenderStyle & style ) { return pseudoElementRendererIsNeeded ( & style ) ; }
void PseudoElement :: didRecalcStyle ( StyleRecalcChange ) { if ( ! renderer ( ) ) return ; RenderObject * renderer = this -> renderer ( ) ; for ( RenderObject * child = renderer -> nextInPreOrder ( renderer ) ; child ; child = child -> nextInPreOrder ( renderer ) ) { if ( ! child -> isText ( ) && ! child -> isQuote ( ) && ! child -> isImage ( ) ) continue ; if ( child -> style ( ) -> styleType ( ) == FIRST_LET@@ TER ) continue ; child -> setPseudoStyle ( renderer -> style ( ) ) ; } }
int GetOptLong :: getoption ( void ) { const char * oli ; if ( ! * place ) { if ( optind >= argc ) { place = " " ; return - 1 ; } place = argv [ optind ] ; if ( place [ 0 ] != ' - ' ) { place = " " ; return - 1 ; } place ++ ; if ( place [ 0 ] && place [ 0 ] == ' - ' && place [ 1 ] == ' \0' ) { ++ optind ; place = " " ; return - 1 ; } if ( place [ 0 ] && place [ 0 ] == ' - ' && place [ 1 ] ) { size_t namelen ; int i ; place ++ ; namelen = strcspn ( place , " = " ) ; for ( i = 0 ; longopts [ i ] . name != NULL ; i ++ ) { if ( strlen ( longopts [ i ] . name ) == namelen && strncmp ( place , longopts [ i ] . name , namelen ) == 0 ) { if ( longopts [ i ] . has_arg ) { if ( place [ namelen ] == ' = ' ) optarg = place + namelen + 1 ; else if ( optind < argc - 1 ) { optind ++ ; optarg = argv [ optind ] ; } else { if ( optstring [ 0 ] == ' : ' ) return BADARG ; if ( opterr ) fprintf ( stderr , " % s : ▁ option ▁ requires ▁ an ▁ argument ▁ - - ▁ % s \n " , argv [ 0 ] , place ) ; place = " " ; optind ++ ; return BADCH ; } } else { optarg = NULL ; if ( place [ namelen ] != 0 ) { } } optind ++ ; longindex = i ; place = " " ; if ( longopts [ i ] . flag == NULL ) return longopts [ i ] . val ; else { * longopts [ i ] . flag = longopts [ i ] . val ; return 0 ; } } } if ( opterr && optstring [ 0 ] != ' : ' ) fprintf ( stderr , " % s : ▁ illegal ▁ option ▁ - - ▁ % s \n " , argv [ 0 ] , place ) ; place = " " ; optind ++ ; return BADCH ; } } optopt = ( int ) * place ++ ; oli = strchr ( optstring , optopt ) ; if ( ! oli ) { if ( ! * place ) ++ optind ; if ( opterr && * optstring != ' : ' ) fprintf ( stderr , " % s : ▁ illegal ▁ option ▁ - - ▁ % c \n " , argv [ 0 ] , optopt ) ; return BADCH ; } if ( oli [ 1 ] != ' : ' ) { optarg = NULL ; if ( ! * place ) ++ optind ; } else { if ( * place ) optarg = place ; else if ( argc <= ++ optind ) { place = " " ; if ( * optstring == ' : ' ) return BADARG ; if ( opterr ) fprintf ( stderr , " % s : ▁ option ▁ requires ▁ an ▁ argument ▁ - - ▁ % c \n " , argv [ 0 ] , optopt ) ; return BADCH ; } else optarg = argv [ optind ] ; place = " " ; ++ optind ; } return optopt ; }
RDListLogs :: RDListLogs ( QString * logname , RDLogFilter :: FilterMode mode , QWidget * parent ) : RDDialog ( parent ) { list_logname = logname ; setMinimumSize ( sizeHint ( ) ) ; setWindowTitle ( tr ( " Select ▁ Log " ) ) ; list_filter_widget = new RDLogFilter ( mode , this ) ; connect ( list_filter_widget , SIGNAL ( filterChanged ( const QString & ) ) , this , SLOT ( filterChangedData ( const QString & ) ) ) ; list_log_list = new Q3ListView ( this ) ; list_log_list -> setAllColumnsShow@@ Focus ( true ) ; list_log_list -> setItemMargin ( 5 ) ; list_log_list -> setSelectionMode ( Q3ListView :: Single ) ; connect ( list_log_list , SIGNAL ( doubleClicked ( Q3ListViewItem * , const QPoint & , int ) ) , this , SLOT ( doubleClickedData ( Q3ListViewItem * , const QPoint & , int ) ) ) ; list_log_list -> addColumn ( tr ( " Name " ) ) ; list_log_list -> setColumnAlignment ( 0 , Qt :: AlignLeft ) ; list_log_list -> addColumn ( tr ( " Description " ) ) ; list_log_list -> setColumnAlignment ( 1 , Qt :: AlignLeft ) ; list_log_list -> addColumn ( tr ( " Service " ) ) ; list_log_list -> setColumnAlignment ( 2 , Qt :: AlignLeft ) ; list_ok_button = new QPushButton ( this ) ; list_ok_button -> setFont ( buttonFont ( ) ) ; list_ok_button -> setText ( tr ( " OK " ) ) ; connect ( list_ok_button , SIGNAL ( clicked ( ) ) , this , SLOT ( okButtonData ( ) ) ) ; list_cancel_button = new QPushButton ( this ) ; list_cancel_button -> setFont ( buttonFont ( ) ) ; list_cancel_button -> setText ( tr ( " Cancel " ) ) ; list_cancel_button -> setDefault ( true ) ; connect ( list_cancel_button , SIGNAL ( clicked ( ) ) , this , SLOT ( cancelButtonData ( ) ) ) ; RefreshList ( ) ; }
void RDListLogs :: closeEvent ( QCloseEvent * e ) { done ( 1 ) ; }
void RDListLogs :: filterChangedData ( const QString & where_sql ) { RefreshList ( ) ; }
void RDListLogs :: doubleClickedData ( Q3ListViewItem * , const QPoint & , int ) { okButtonData ( ) ; }
void RDListLogs :: okButtonData ( ) { Q3ListViewItem * item = list_log_list -> selectedItem ( ) ; if ( item == NULL ) { return ; } * list_logname = item -> text ( 0 ) ; done ( 0 ) ; }
void RDListLogs :: cancelButtonData ( ) { done ( 1 ) ; }
void RDListLogs :: resizeEvent ( QResizeEvent * e ) { list_filter_widget -> setGeometry ( 10 , 10 , size ( ) . width ( ) - 10 , list_filter_widget -> sizeHint ( ) . height ( ) ) ; list_log_list -> setGeometry ( 10 , list_filter_widget -> sizeHint ( ) . height ( ) , size ( ) . width ( ) - 20 , size ( ) . height ( ) - list_filter_widget -> sizeHint ( ) . height ( ) - 70 ) ; list_ok_button -> setGeometry ( size ( ) . width ( ) - 190 , size ( ) . height ( ) - 60 , 80 , 50 ) ; list_cancel_button -> setGeometry ( size ( ) . width ( ) - 90 , size ( ) . height ( ) - 60 , 80 , 50 ) ; }
void RDListLogs :: RefreshList ( ) { RDSqlQuery * q ; QString sql ; Q3ListViewItem * l ; Q3ListViewItem * view_item = NULL ; QDate current_date = QDate :: currentDate ( ) ; list_log_list -> clear ( ) ; sql = QString ( " select ▁ NAME , DESCRIP@@ TION , SERVICE ▁ from ▁ LOGS ▁ " ) + " where ▁ ( TYPE = 0 ) & & ( LOG _ EXISTS = \ " Y \ " ) & & " + " ( ( START _ DATE < = \ " " + current_date . toString ( " yyyy - MM - dd " ) + " \ " ) | | " + " ( START _ DATE = \ " 0000 - 00 - 00 \ " ) | | " + " ( START _ DATE ▁ is ▁ null ) ) & & " + " ( ( END _ DATE > = \ " " + current_date . toString ( " yyyy - MM - dd " ) + " \ " ) | | " + " ( END _ DATE = \ " 0000 - 00 - 00 \ " ) | | " + " ( END _ DATE ▁ is ▁ null ) ) " + list_filter_widget -> whereSql ( ) ; q = new RDSqlQuery ( sql ) ; while ( q -> next ( ) ) { l = new Q3ListViewItem ( list_log_list ) ; l -> setText ( 0 , q -> value ( 0 ) . toString ( ) ) ; l -> setText ( 1 , q -> value ( 1 ) . toString ( ) ) ; l -> setText ( 2 , q -> value ( 2 ) . toString ( ) ) ; if ( l -> text ( 0 ) == * list_logname ) { view_item = l ; } } delete q ; if ( view_item != NULL ) { list_log_list -> setCurrentItem ( view_item ) ; list_log_list -> ensureItemVisible ( view_item ) ; } }
void ImagePreviewComponent :: selectedFileChanged ( const File & file ) { if ( fileToLoad != file ) { fileToLoad = file ; startTimer ( 100 ) ; } }
void ImagePreviewComponent :: timerCallback ( ) { stopTimer ( ) ; currentThumbnail = Image ( ) ; currentDetails . clear ( ) ; repaint ( ) ; ScopedPointer < FileInputStream > in ( fileToLoad . createInputStream ( ) ) ; if ( in != nullptr ) { if ( ImageFileFormat * const format = ImageFileFormat :: findImageFormatForStream ( * in ) ) { currentThumbnail = format -> decodeImage ( * in ) ; if ( currentThumbnail . isValid ( ) ) { int w = currentThumbnail . getWidth ( ) ; int h = currentThumbnail . getHeight ( ) ; currentDetails << fileToLoad . getFileName ( ) << " \n " << format -> getFormatName ( ) << " \n " << w << " ▁ x ▁ " << h << " ▁ pixels \n " << File :: descriptionOfSizeInBytes ( fileToLoad . getSize ( ) ) ; getThumbSize ( w , h ) ; currentThumbnail = currentThumbnail . rescaled ( w , h ) ; } } } }
void ImagePreviewComponent :: paint ( Graphics & g ) { if ( currentThumbnail . isValid ( ) ) { g . setFont ( 13.0f ) ; int w = currentThumbnail . getWidth ( ) ; int h = currentThumbnail . getHeight ( ) ; getThumbSize ( w , h ) ; const int numLines = 4 ; const int totalH = 13 * numLines + h + 4 ; const int y = ( getHeight ( ) - totalH ) / 2 ; g . drawImageWith@@ in ( currentThumbnail , ( getWidth ( ) - w ) / 2 , y , w , h , RectanglePlacement :: centred | RectanglePlacement :: onlyReduceInSize , false ) ; g . drawFit@@ tedText ( currentDetails , 0 , y + h + 4 , getWidth ( ) , 100 , Justification :: centredTop , numLines ) ; } }
std :: string System_GetProperty ( SystemProperty prop ) { return " " ; }
void CDVDSubtitleTagMicro@@ DVD :: ConvertLine ( CDVDOverlayText * pOverlay , const char * line , int len ) { CStdString strUTF8 ; strUTF8 . assign ( line , len ) ; m_flag [ FLAG_BOLD ] = 0 ; m_flag [ FLAG_ITALIC ] = 0 ; m_flag [ FLAG_COLOR ] = 0 ; int machine_status = 1 ; size_t pos = 0 ; while ( machine_status > 0 ) { if ( machine_status == 1 ) { if ( strUTF8 [ pos ] == ' { ' ) { size_t pos2 , pos3 ; if ( ( ( pos2 = strUTF8 . find ( ' : ' , pos ) ) != CStdString :: npos ) && ( ( pos3 = strUTF8 . find ( ' } ' , pos2 ) ) != CStdString :: npos ) ) { CStdString tagName = strUTF8 . substr ( pos + 1 , pos2 - pos - 1 ) ; CStdString tagValue = strUTF8 . substr ( pos2 + 1 , pos3 - pos2 - 1 ) ; StringUtils :: ToLower ( tagValue ) ; strUTF8 . erase ( pos , pos3 - pos + 1 ) ; if ( ( tagName == " Y " ) || ( tagName == " y " ) ) { if ( ( tagValue == " b " ) && ( m_flag [ FLAG_BOLD ] == 0 ) ) { m_flag [ FLAG_BOLD ] = ( tagName == " Y " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , " [ B ] " ) ; pos += 3 ; } else if ( ( tagValue == " i " ) && ( m_flag [ FLAG_ITALIC ] == 0 ) ) { m_flag [ FLAG_ITALIC ] = ( tagName == " Y " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , " [ I ] " ) ; pos += 3 ; } } else if ( ( tagName == " C " ) || ( tagName == " c " ) ) { if ( ( tagValue [ 0 ] == ' $ ' ) && ( tagValue . size ( ) == 7 ) ) { bool bHex = true ; for ( int i = 1 ; i < 7 ; i ++ ) { char temp = tagValue [ i ] ; if ( ! ( ( '0' <= temp && temp <= '9' ) || ( ' a ' <= temp && temp <= ' f ' ) || ( ' A ' <= temp && temp <= ' F ' ) ) ) { bHex = false ; break ; } } if ( bHex && ( m_flag [ FLAG_COLOR ] == 0 ) ) { CStdString tempColorTag = " [ COLOR ▁ " ; tempColorTag += " FF " ; tempColorTag += tagValue . substr ( 1 , 6 ) ; tempColorTag += " ] " ; m_flag [ FLAG_COLOR ] = ( tagName == " C " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , tempColorTag ) ; pos += tempColorTag . length ( ) ; } } } } else machine_status = 2 ; } else if ( strUTF8 [ pos ] == ' / ' ) { if ( m_flag [ FLAG_ITALIC ] == 0 ) { m_flag [ FLAG_ITALIC ] = TAG_ONE_LINE ; strUTF8 . replace ( pos , 1 , " [ I ] " ) ; pos += 3 ; } else strUTF8 . erase ( pos , 1 ) ; } else machine_status = 2 ; } else if ( machine_status == 2 ) { size_t pos4 ; if ( ( pos4 = strUTF8 . find ( ' | ' , pos ) ) != CStdString :: npos ) { pos = pos4 ; if ( m_flag [ FLAG_BOLD ] == TAG_ONE_LINE ) { m_flag [ FLAG_BOLD ] = 0 ; strUTF8 . insert ( pos , " [ / B ] " ) ; pos += 4 ; } if ( m_flag [ FLAG_ITALIC ] == TAG_ONE_LINE ) { m_flag [ FLAG_ITALIC ] = 0 ; strUTF8 . insert ( pos , " [ / I ] " ) ; pos += 4 ; } if ( m_flag [ FLAG_COLOR ] == TAG_ONE_LINE ) { m_flag [ FLAG_COLOR ] = 0 ; strUTF8 . insert ( pos , " [ / COLOR ] " ) ; pos += 8 ; } strUTF8 . replace ( pos , 1 , " [ CR ] " ) ; pos += 4 ; machine_status = 1 ; } else { if ( m_flag [ FLAG_BOLD ] != 0 ) strUTF8 . append ( " [ / B ] " ) ; if ( m_flag [ FLAG_ITALIC ] != 0 ) strUTF8 . append ( " [ / I ] " ) ; if ( m_flag [ FLAG_COLOR ] != 0 ) strUTF8 . append ( " [ / COLOR ] " ) ; machine_status = 0 ; } } } if ( strUTF8 . empty ( ) ) return ; if ( strUTF8 [ strUTF8 . size ( ) - 1 ] == ' \n ' ) strUTF8 . erase ( strUTF8 . size ( ) - 1 ) ; pOverlay -> AddElement ( new CDVDOverlayText :: CElementText ( strUTF8 . c_str ( ) ) ) ; }
void WorldSession :: HandleGMTicketCreateOpcode ( WorldPacket & recvData ) { if ( sTicketMgr -> GetStatus ( ) == GMTICKET_QUEUE_STATUS_DISABLED ) return ; if ( GetPlayer ( ) -> getLevel ( ) < sWorld -> getIntConfig ( CONFIG_TICKET_LEVEL_REQ ) ) { SendNotification ( GetTrinityString ( LANG_TICKET_@@ REQ ) , sWorld -> getIntConfig ( CONFIG_TICKET_LEVEL_REQ ) ) ; return ; } GMTicketResponse response = GMTICKET_RESPONSE_CREATE_ERROR ; GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ; if ( ticket && ticket -> IsCompleted ( ) ) sTicketMgr -> CloseTicket ( ticket -> GetId ( ) , GetPlayer ( ) -> GetGUID ( ) ) ; ; if ( ! ticket || ticket -> IsClosed ( ) ) { ticket = new GmTicket ( GetPlayer ( ) , recvData ) ; uint32 count ; std :: list < uint32 > times ; uint32 decompressedSize ; std :: string chatLog ; recvData >> count ; for ( uint32 i = 0 ; i < count ; i ++ ) { uint32 time ; recvData >> time ; times . push_back ( time ) ; } recvData >> decompressedSize ; if ( count && decompressedSize && decompressedSize < 0xFFFF ) { uint32 pos = recvData . rpos ( ) ; ByteBuffer dest ; dest . resize ( decompressedSize ) ; uLongf realSize = decompressedSize ; if ( uncompress ( dest . contents ( ) , & realSize , recvData . contents ( ) + pos , recvData . size ( ) - pos ) == Z_OK ) { dest >> chatLog ; ticket -> SetChatLog ( times , chatLog ) ; } else { TC_LOG_ERROR ( " network " , " CMSG _ GMTICKET _ CREATE ▁ possibly ▁ corrupt . ▁ Uncompression ▁ failed . " ) ; recvData . rfinish ( ) ; delete ticket ; return ; } recvData . rfinish ( ) ; } sTicketMgr -> AddTicket ( ticket ) ; sTicketMgr -> UpdateLast@@ Change ( ) ; sWorld -> SendGMText ( LANG_COMMAND_TICKETNEW , GetPlayer ( ) -> GetName ( ) . c_str ( ) , ticket -> GetId ( ) ) ; response = GMTICKET_RESPONSE_CREATE_SUCCESS ; } WorldPacket data ( SMSG_GMTICKET_CREATE , 4 ) ; data << uint32 ( response ) ; SendPacket ( & data ) ; }
void WorldSession :: HandleGMTicketUpdateOpcode ( WorldPacket & recvData ) { std :: string message ; recvData >> message ; GMTicketResponse response = GMTICKET_RESPONSE_UPDATE_ERROR ; if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { SQLTransaction trans = SQLTransaction ( NULL ) ; ticket -> SetMessage ( message ) ; ticket -> SaveToDB ( trans ) ; sWorld -> SendGMText ( LANG_COMMAND_TICKETUPDATED , GetPlayer ( ) -> GetName ( ) . c_str ( ) , ticket -> GetId ( ) ) ; response = GMTICKET_RESPONSE_UPDATE_SUCCESS ; } WorldPacket data ( SMSG_GMTICKET_UPDATETEXT , 4 ) ; data << uint32 ( response ) ; SendPacket ( & data ) ; }
void WorldSession :: HandleGMTicketDeleteOpcode ( WorldPacket & ) { if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { WorldPacket data ( SMSG_GMTICKET_DELETETICKET , 4 ) ; data << uint32 ( GMTICKET_RESPONSE_TICKET_DELETED ) ; SendPacket ( & data ) ; sWorld -> SendGMText ( LANG_COMMAND_TICKETPLAYERABANDO@@ N , GetPlayer ( ) -> GetName ( ) . c_str ( ) , ticket -> GetId ( ) ) ; sTicketMgr -> CloseTicket ( ticket -> GetId ( ) , GetPlayer ( ) -> GetGUID ( ) ) ; sTicketMgr -> SendTicket ( this , NULL ) ; } }
void WorldSession :: HandleGMTicketGetTicketOpcode ( WorldPacket & ) { SendQueryTimeResponse ( ) ; if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { if ( ticket -> IsCompleted ( ) ) ticket -> SendResponse ( this ) ; else sTicketMgr -> SendTicket ( this , ticket ) ; } else sTicketMgr -> SendTicket ( this , NULL ) ; }
void WorldSession :: HandleGMTicketSystemStatus@@ Opcode ( WorldPacket & ) { WorldPacket data ( SMSG_GMTICKET_SYSTEM@@ STATUS , 4 ) ; data << uint32 ( sTicketMgr -> GetStatus ( ) ? GMTICKET_QUEUE_STATUS_ENABLED : GMTICKET_QUEUE_STATUS_DISABLED ) ; SendPacket ( & data ) ; }
void WorldSession :: HandleGMS@@ urveySubmit ( WorldPacket & recvData ) { uint32 nextSurveyID = sTicketMgr -> GetNextSurveyID ( ) ; uint32 mainSurvey ; recvData >> mainSurvey ; for ( uint8 i = 0 ; i < 15 ; i ++ ) { uint32 subSurveyId ; recvData >> subSurveyId ; if ( ! subSurveyId ) break ; uint8 rank ; recvData >> rank ; std :: string comment ; recvData >> comment ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_GM_SUBS@@ URVEY ) ; stmt -> setUInt32 ( 0 , nextSurveyID ) ; stmt -> setUInt32 ( 1 , subSurveyId ) ; stmt -> setUInt32 ( 2 , rank ) ; stmt -> setString ( 3 , comment ) ; CharacterDatabase . Execute ( stmt ) ; } std :: string comment ; recvData >> comment ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_GM_SURVEY ) ; stmt -> setUInt32 ( 0 , GUID_LOPART ( GetPlayer ( ) -> GetGUID ( ) ) ) ; stmt -> setUInt32 ( 1 , nextSurveyID ) ; stmt -> setUInt32 ( 2 , mainSurvey ) ; stmt -> setString ( 3 , comment ) ; CharacterDatabase . Execute ( stmt ) ; }
void WorldSession :: HandleReport@@ Lag ( WorldPacket & recvData ) { uint32 lagType , mapId ; recvData >> lagType ; recvData >> mapId ; float x , y , z ; recvData >> x ; recvData >> y ; recvData >> z ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_LAG_REPORT ) ; stmt -> setUInt32 ( 0 , GUID_LOPART ( GetPlayer ( ) -> GetGUID ( ) ) ) ; stmt -> setUInt8 ( 1 , lagType ) ; stmt -> setUInt16 ( 2 , mapId ) ; stmt -> setFloat ( 3 , x ) ; stmt -> setFloat ( 4 , y ) ; stmt -> setFloat ( 5 , z ) ; stmt -> setUInt32 ( 6 , GetLatency ( ) ) ; stmt -> setUInt32 ( 7 , time ( NULL ) ) ; CharacterDatabase . Execute ( stmt ) ; }
void WorldSession :: HandleGM@@ ResponseResolve ( WorldPacket & ) { if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { uint8 getSurvey = 0 ; if ( float ( rand_chance ( ) ) < sWorld -> getFloatConfig ( CONFIG_CHANCE_@@ OF_GM_SURVEY ) ) getSurvey = 1 ; WorldPacket data ( SMSG_GMRESPONSE_@@ STATUS_UPDATE , 4 ) ; data << uint8 ( getSurvey ) ; SendPacket ( & data ) ; WorldPacket data2 ( SMSG_GMTICKET_DELETETICKET , 4 ) ; data2 << uint32 ( GMTICKET_RESPONSE_TICKET_DELETED ) ; SendPacket ( & data2 ) ; sTicketMgr -> CloseTicket ( ticket -> GetId ( ) , GetPlayer ( ) -> GetGUID ( ) ) ; sTicketMgr -> SendTicket ( this , NULL ) ; } }
CApplicationPlayer :: CApplicationPlayer ( ) { m_iPlayerOPSeq = 0 ; m_eCurrentPlayer = EPC_NONE ; }
void CApplicationPlayer :: ClosePlayer ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { CloseFile ( ) ; CSingleLock lock ( m_player_lock ) ; m_pPlayer . reset ( ) ; } }
void CApplicationPlayer :: CloseFile ( bool reopen ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { ++ m_iPlayerOPSeq ; player -> CloseFile ( reopen ) ; } }
void CApplicationPlayer :: ClosePlayerGap@@ less ( PLAYERCOREID newCore ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( ! player ) return ; bool gaplessSupported = ( m_eCurrentPlayer == EPC_DVDPLAYER || m_eCurrentPlayer == EPC_PAP@@ LAYER ) ; gaplessSupported = gaplessSupported && ( m_eCurrentPlayer == newCore ) ; if ( ! gaplessSupported ) { ClosePlayer ( ) ; } else { CloseFile ( true ) ; } }
void CApplicationPlayer :: CreatePlayer ( PLAYERCOREID newCore , IPlayer@@ Callback & callback ) { CSingleLock lock ( m_player_lock ) ; if ( ! m_pPlayer ) { m_eCurrentPlayer = newCore ; m_pPlayer . reset ( CPlayerCoreFactory :: Get ( ) . CreatePlayer ( newCore , callback ) ) ; } }
PlayBackRet CApplicationPlayer :: OpenFile ( const CFileItem & item , const CPlayerOptions & options ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; PlayBackRet iResult = PLAYBACK_FAIL ; if ( player ) { unsigned int startingSeq = ++ m_iPlayerOPSeq ; iResult = player -> OpenFile ( item , options ) ? PLAYBACK_@@ OK : PLAYBACK_FAIL ; if ( m_iPlayerOPSeq != startingSeq ) iResult = PLAYBACK@@ _CANC@@ ELED ; } return iResult ; }
int CApplicationPlayer :: GetChapter ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetChapter ( ) ; else return - 1 ; }
int CApplicationPlayer :: GetChapterCount ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetChapterCount ( ) ; else return 0 ; }
void CApplicationPlayer :: GetChapterName ( std :: string & strChapterName , int chapterIdx ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetChapterName ( strChapterName , chapterIdx ) ; }
int64_t CApplicationPlayer :: GetChapterPos ( int chapterIdx ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetChapterPos ( chapterIdx ) ; return - 1 ; }
void CApplicationPlayer :: Pause ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> Pause ( ) ; }
void CApplicationPlayer :: SetMute ( bool bOnOff ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetMute ( bOnOff ) ; }
void CApplicationPlayer :: SetVolume ( float volume ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetVolume ( volume ) ; }
void CApplicationPlayer :: Seek ( bool bPlus , bool bLargeStep , bool bChapterOverride ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> Seek ( bPlus , bLargeStep , bChapterOverride ) ; }
void CApplicationPlayer :: SeekPercentage ( float fPercent ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SeekPercentage ( fPercent ) ; }
bool CApplicationPlayer :: CanSeek ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> CanSeek ( ) ) ; }
bool CApplicationPlayer :: SeekScene ( bool bPlus ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> SeekScene ( bPlus ) ) ; }
void CApplicationPlayer :: SeekTime ( int64_t iTime ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SeekTime ( iTime ) ; }
void CApplicationPlayer :: SeekTimeRelative ( int64_t iTime ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { if ( ! player -> SeekTimeRelative ( iTime ) ) { int64_t abstime = player -> GetTime ( ) + iTime ; player -> SeekTime ( abstime ) ; } } }
std :: string CApplicationPlayer :: GetPlayingTitle ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetPlayingTitle ( ) ; else return " " ; }
int CApplicationPlayer :: GetSubtitleCount ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetSubtitleCount ( ) ; else return 0 ; }
int CApplicationPlayer :: GetAudioStream ( ) { if ( ! m_audioStreamUpdate . IsTimePast ( ) ) return m_iAudioStream ; std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { m_iAudioStream = player -> GetAudioStream ( ) ; m_audioStreamUpdate . Set ( 1000 ) ; return m_iAudioStream ; } else return 0 ; }
int CApplicationPlayer :: GetSubtitle ( ) { if ( ! m_subtitleStreamUpdate . IsTimePast ( ) ) return m_iSubtitleStream ; std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { m_iSubtitleStream = player -> GetSubtitle ( ) ; m_subtitleStreamUpdate . Set ( 1000 ) ; return m_iSubtitleStream ; } else return 0 ; }
bool CApplicationPlayer :: GetSubtitleVisible ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> GetSubtitleVisible ( ) ) ; }
bool CApplicationPlayer :: CanRecord ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> CanRecord ( ) ) ; }
bool CApplicationPlayer :: CanPause ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> CanPause ( ) ) ; }
TextCache@@ Struct_t * CApplicationPlayer :: GetTeletextCache ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetTeletextCache ( ) ; else return NULL ; }
void CApplicationPlayer :: ToFFRW ( int iSpeed ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> ToFFRW ( iSpeed ) ; }
void CApplicationPlayer :: DoAudioWork ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> DoAudioWork ( ) ; }
std :: string CApplicationPlayer :: GetPlayerState ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetPlayerState ( ) ; else return " " ; }
bool CApplicationPlayer :: QueueNextFile ( const CFileItem & file ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> QueueNextFile ( file ) ) ; }
bool CApplicationPlayer :: GetStreamDetails ( CStreamDetails & details ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> GetStreamDetails ( details ) ) ; }
bool CApplicationPlayer :: SetPlayerState ( const std :: string & state ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> SetPlayerState ( state ) ) ; }
void CApplicationPlayer :: OnNothingToQueueNotify ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OnNothingToQueueNotify ( ) ; }
void CApplicationPlayer :: GetVideoStreamInfo ( SPlayerVideoStreamInfo & info ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetVideoStreamInfo ( info ) ; }
void CApplicationPlayer :: GetAudioStreamInfo ( int index , SPlayerAudioStreamInfo & info ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetAudioStreamInfo ( index , info ) ; }
bool CApplicationPlayer :: OnAction ( const CAction & action ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> OnAction ( action ) ) ; }
bool CApplicationPlayer :: Record ( bool bOnOff ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> Record ( bOnOff ) ) ; }
int CApplicationPlayer :: GetAudioStreamCount ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetAudioStreamCount ( ) ; else return 0 ; }
void CApplicationPlayer :: SetAudioStream ( int iStream ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { player -> SetAudioStream ( iStream ) ; m_iAudioStream = iStream ; m_audioStreamUpdate . Set ( 1000 ) ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_AudioStream = iStream ; } }
void CApplicationPlayer :: GetSubtitleStreamInfo ( int index , SPlayerSubtitleStreamInfo & info ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetSubtitleStreamInfo ( index , info ) ; }
void CApplicationPlayer :: SetSubtitle ( int iStream ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { player -> SetSubtitle ( iStream ) ; m_iSubtitleStream = iStream ; m_subtitleStreamUpdate . Set ( 1000 ) ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_SubtitleStream = iStream ; } }
void CApplicationPlayer :: SetSubtitleVisible ( bool bVisible ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { player -> SetSubtitleVisible ( bVisible ) ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_SubtitleOn = bVisible ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_SubtitleStream = player -> GetSubtitle ( ) ; } }
void CApplicationPlayer :: AddSubtitle ( const std :: string & strSubPath ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> AddSubtitle ( strSubPath ) ; }
void CApplicationPlayer :: SetSubTitleDelay ( float fValue ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetSubTitleDelay ( fValue ) ; }
void CApplicationPlayer :: SetAVDelay ( float fValue ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetAVDelay ( fValue ) ; }
void CApplicationPlayer :: SetDynamicRangeCompression ( long drc ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetDynamicRangeCompression ( drc ) ; }
bool CApplicationPlayer :: SwitchChannel ( const PVR :: CPVRChannel@@ Ptr & channel ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> SwitchChannel ( channel ) ) ; }
void CApplicationPlayer :: LoadPage ( int p , int sp , unsigned char * buffer ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> LoadPage ( p , sp , buffer ) ; }
void CApplicationPlayer :: GetAudioCapabilities ( std :: vector < int > & audioCaps ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetAudioCapabilities ( audioCaps ) ; }
void CApplicationPlayer :: GetSubtitleCapabilities ( std :: vector < int > & subCaps ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetSubtitleCapabilities ( subCaps ) ; }
void CApplicationPlayer :: GetAudioInfo ( std :: string & strAudioInfo ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetAudioInfo ( strAudioInfo ) ; }
void CApplicationPlayer :: GetVideoInfo ( std :: string & strVideoInfo ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetVideoInfo ( strVideoInfo ) ; }
void CApplicationPlayer :: GetGeneralInfo ( std :: string & strVideoInfo ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetGeneralInfo ( strVideoInfo ) ; }
int CApplicationPlayer :: SeekChapter ( int iChapter ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> SeekChapter ( iChapter ) ; else return 0 ; }
void CApplicationPlayer :: GetRenderFeatures ( std :: vector < int > & renderFeatures ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGetRenderFeatures ( renderFeatures ) ; }
void CApplicationPlayer :: GetDeinterlaceMethods ( std :: vector < int > & deinterlaceMethods ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGetDeinterlaceMethods ( deinterlaceMethods ) ; }
void CApplicationPlayer :: GetDeinterlaceModes ( std :: vector < int > & deinterlaceModes ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGetDeinterlaceModes ( deinterlaceModes ) ; }
void CApplicationPlayer :: GetScalingMethods ( std :: vector < int > & scalingMethods ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGetScalingMethods ( scalingMethods ) ; }
void CApplicationPlayer :: SetPlaySpeed ( int iSpeed , bool bApplicationMuted ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( ! player ) return ; if ( ! IsPlayingAudio ( ) && ! IsPlayingVideo ( ) ) return ; if ( m_iPlaySpeed == iSpeed ) return ; if ( ! CanSeek ( ) ) return ; if ( IsPaused ( ) ) { if ( ( ( m_iPlaySpeed > 1 ) && ( iSpeed > m_iPlaySpeed ) ) || ( ( m_iPlaySpeed < - 1 ) && ( iSpeed < m_iPlaySpeed ) ) ) { iSpeed = m_iPlaySpeed ; } Pause ( ) ; } m_iPlaySpeed = iSpeed ; ToFFRW ( m_iPlaySpeed ) ; if ( ControlsVolume ( ) ) { if ( m_iPlaySpeed == 1 ) { player -> SetVolume ( g_application . GetVolume ( false ) ) ; } else { player -> SetVolume ( VOLUME_MIN@@ IMUM ) ; } player -> SetMute ( bApplicationMuted ) ; } }
void ACE_Stream_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Stream _ Node : : apply " ) ; const ACE_Service_Type * sst = this -> node_ -> record ( config ) ; if ( sst == 0 ) const_cast < ACE_Static_Node * > ( this -> node_ ) -> apply ( config , yyerrno ) ; if ( yyerrno != 0 ) return ; sst = this -> node_ -> record ( config ) ; ACE_Stream_Type * st = dynamic_cast < ACE_Stream_Type * > ( const_cast < ACE_Service_Type_Impl * > ( sst -> type ( ) ) ) ; std :: list < const ACE_Static_Node * > mod_list ; const ACE_Static_Node * module ; for ( module = dynamic_cast < const ACE_Static_Node * > ( this -> mods_ ) ; module != 0 ; module = dynamic_cast < ACE_Static_Node * > ( module -> link ( ) ) ) mod_list . push_front ( module ) ; std :: list < const ACE_Static_Node * > :: const_iterator iter ; for ( iter = mod_list . begin ( ) ; iter != mod_list . end ( ) ; ++ iter ) { module = * iter ; ACE_ARGV args ( module -> parameters ( ) ) ; const ACE_Service_Type * mst = module -> record ( config ) ; if ( mst == 0 ) const_cast < ACE_Static_Node * > ( module ) -> apply ( config , yyerrno ) ; if ( yyerrno != 0 ) { if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " dynamic ▁ initialization ▁ failed ▁ for ▁ Module ▁ % s \n " ) , module -> name ( ) ) ) ; } ++ yyerrno ; continue ; } ACE_Module_Type const * const mt1 = static_cast < ACE_Module_Type const * > ( module -> record ( config ) -> type ( ) ) ; ACE_Module_Type * mt = const_cast < ACE_Module_Type * > ( mt1 ) ; if ( st -> push ( mt ) == - 1 ) { if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " dynamic ▁ initialization ▁ failed ▁ for ▁ Stream ▁ % s \n " ) , this -> node_ -> name ( ) ) ) ; } ++ yyerrno ; } } if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ( % P | % t ) ▁ Did ▁ stream ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> node_ -> name ( ) , yyerrno ) ) ; }
void ACE_Parse_Node :: link ( ACE_Parse_Node * n ) { ACE_TRACE ( " ACE _ Parse _ Node : : link " ) ; ACE_Parse_Node * t = this ; while ( t -> next_ != 0 ) t = t -> next_ ; t -> next_ = n ; }
ACE_Stream_Node :: ACE_Stream_Node ( const ACE_Static_Node * str_ops , const ACE_Parse_Node * str_mods ) : ACE_Parse_Node ( ( str_ops == 0 ? ACE_TEXT ( " < unknown > " ) : str_ops -> name ( ) ) ) , node_ ( str_ops ) , mods_ ( str_mods ) { ACE_TRACE ( " ACE _ Stream _ Node : : ACE _ Stream _ Node " ) ; }
ACE_Stream_Node :: ~ ACE_Stream_Node ( void ) { ACE_TRACE ( " ACE _ Stream _ Node : : ~ ACE _ Stream _ Node " ) ; ACE_Static_Node * n = const_cast < ACE_Static_Node * > ( this -> node_ ) ; delete n ; ACE_Parse_Node * m = const_cast < ACE_Parse_Node * > ( this -> mods_ ) ; delete m ; }
ACE_Parse_Node :: ACE_Parse_Node ( void ) : name_ ( 0 ) , next_ ( 0 ) { ACE_TRACE ( " ACE _ Parse _ Node : : ACE _ Parse _ Node " ) ; }
ACE_Parse_Node :: ACE_Parse_Node ( const ACE_TCHAR * nm ) : name_ ( ACE :: strnew ( nm ) ) , next_ ( 0 ) { ACE_TRACE ( " ACE _ Parse _ Node : : ACE _ Parse _ Node " ) ; }
ACE_Parse_Node :: ~ ACE_Parse_Node ( void ) { ACE_TRACE ( " ACE _ Parse _ Node : : ~ ACE _ Parse _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> name_ ) ; delete this -> next_ ; }
ACE_Suspend_Node :: ACE_Suspend_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Suspend _ Node : : ACE _ Suspend _ Node " ) ; }
ACE_Resume_Node :: ACE_Resume_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Resume _ Node : : ACE _ Resume _ Node " ) ; }
void ACE_Suspend_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Suspend _ Node : : apply " ) ; if ( config -> suspend ( this -> name ( ) ) == - 1 ) ++ yyerrno ; if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ suspend ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; }
void ACE_Resume_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Resume _ Node : : apply " ) ; if ( config -> resume ( this -> name ( ) ) == - 1 ) ++ yyerrno ; if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ resume ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; }
ACE_Remove_Node :: ACE_Remove_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Remove _ Node : : ACE _ Remove _ Node " ) ; }
void ACE_Remove_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Remove _ Node : : apply " ) ; if ( config -> remove ( this -> name ( ) ) == - 1 ) ++ yyerrno ; if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Remove _ Node : : apply " ) ACE_TEXT ( " ▁ - ▁ did ▁ remove ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; }
ACE_Dynamic_Node :: ACE_Dynamic_Node ( ACE_Service_Type_Factory const * stf , ACE_TCHAR * parms ) : ACE_Static_Node ( stf -> name ( ) , parms ) , factory_ ( stf ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : ACE _ Dynamic _ Node " ) ; }
void ACE_Dynamic_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : apply " ) ; if ( config -> initialize ( this -> factory_ . get ( ) , this -> parameters ( ) ) == - 1 ) ++ yyerrno ; if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Dynamic _ Node : : apply " ) ACE_TEXT ( " ▁ - ▁ Did ▁ dynamic ▁ on ▁ % s ▁ ( yyerrno = % d ) \n " ) , this -> name ( ) , yyerrno ) ) ; }
ACE_Dynamic_Node :: ~ ACE_Dynamic_Node ( void ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : ~ ACE _ Dynamic _ Node " ) ; }
ACE_Static_Node :: ACE_Static_Node ( const ACE_TCHAR * nm , ACE_TCHAR * params ) : ACE_Parse_Node ( nm ) , parameters_ ( ACE :: strnew ( params ) ) { ACE_TRACE ( " ACE _ Static _ Node : : ACE _ Static _ Node " ) ; }
void ACE_Static_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Static _ Node : : apply " ) ; if ( config -> initialize ( this -> name ( ) , this -> parameters ( ) ) == - 1 ) ++ yyerrno ; if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Static _ Node : : apply ▁ - " ) ACE_TEXT ( " ▁ Did ▁ static ▁ on ▁ % s ▁ ( yyerrno = % d ) \n " ) , this -> name ( ) , yyerrno ) ) ; }
ACE_Static_Node :: ~ ACE_Static_Node ( void ) { ACE_TRACE ( " ACE _ Static _ Node : : ~ ACE _ Static _ Node " ) ; delete [ ] this -> parameters_ ; }
ACE_Location_Node :: ACE_Location_Node ( void ) : pathname_ ( 0 ) , dll_ ( ) , symbol_ ( 0 ) { ACE_TRACE ( " ACE _ Location _ Node : : ACE _ Location _ Node " ) ; }
ACE_Location_Node :: ~ ACE_Location_Node ( void ) { ACE_TRACE ( " ACE _ Location _ Node : : ~ ACE _ Location _ Node " ) ; }
const ACE_DLL & ACE_Location_Node :: dll ( void ) { return this -> dll_ ; }
void ACE_Location_Node :: pathname ( const ACE_TCHAR * p ) { ACE_TRACE ( " ACE _ Location _ Node : : pathname " ) ; this -> pathname_ = p ; }
int ACE_Location_Node :: open_dll ( int & yyerrno ) { ACE_TRACE ( " ACE _ Location _ Node : : open _ dll " ) ; if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ LN : : open _ dll ▁ - ▁ path = % s \n " ) , this -> pathname ( ) ) ) ; if ( - 1 == this -> dll_ . open ( this -> pathname ( ) ) ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_TCHAR * errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ LN : : open _ dll ▁ - ▁ Failed ▁ to ▁ open ▁ % s : ▁ % s \n " ) , this -> pathname ( ) , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } return - 1 ; } return 0 ; }
void ACE_Location_Node :: set_symbol ( void * s ) { ACE_TRACE ( " ACE _ Location _ Node : : set _ symbol " ) ; this -> symbol_ = s ; }
ACE_Object_Node :: ACE_Object_Node ( const ACE_TCHAR * path , const ACE_TCHAR * obj_name ) : object_name_ ( ACE :: strnew ( obj_name ) ) { ACE_TRACE ( " ACE _ Object _ Node : : ACE _ Object _ Node " ) ; this -> pathname ( ACE :: strnew ( path ) ) ; this -> must_delete_ = 0 ; }
void * ACE_Object_Node :: symbol ( ACE_Service_Gestalt * , int & yyerrno , ACE_Service_Object_Exterminator * ) { ACE_TRACE ( " ACE _ Object _ Node : : symbol " ) ; if ( this -> open_dll ( yyerrno ) == 0 ) { ACE_TCHAR * object_name = const_cast < ACE_TCHAR * > ( this -> object_name_ ) ; this -> symbol_ = this -> dll_ . symbol ( object_name ) ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_TCHAR * errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ DLL : : symbol ▁ - " ) ACE_TEXT ( " ▁ Failed ▁ for ▁ object ▁ % s : ▁ % s \n " ) , object_name , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } return 0 ; } return this -> symbol_ ; } return 0 ; }
ACE_Object_Node :: ~ ACE_Object_Node ( void ) { ACE_TRACE ( " ACE _ Object _ Node : : ~ ACE _ Object _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> object_name_ ) ; }
ACE_Function_Node :: ACE_Function_Node ( const ACE_TCHAR * path , const ACE_TCHAR * func_name ) : function_name_ ( make_func_name ( func_name ) ) { ACE_TRACE ( " ACE _ Function _ Node : : ACE _ Function _ Node " ) ; this -> pathname ( ACE :: strnew ( path ) ) ; this -> must_delete_ = 1 ; }
ACE_TCHAR * ACE_Function_Node :: make_func_name ( ACE_TCHAR const * func_name ) { && ACE_HAS_VERSIONED_NAMESPACE == 1 ; }
void Interpreter :: Helper_UpdateCR0 ( u32 value ) { s64 sign_extended = ( s64 ) ( s32 ) value ; u64 cr_val = ( u64 ) sign_extended ; cr_val = ( cr_val & ~ ( 1ull << 61 ) ) | ( ( u64 ) GetXER_SO ( ) << 61 ) ; PowerPC :: ppcState . cr_val [ 0 ] = cr_val ; }
void Interpreter :: Helper_UpdateCRx ( int idx , u32 value ) { s64 sign_extended = ( s64 ) ( s32 ) value ; u64 cr_val = ( u64 ) sign_extended ; cr_val = ( cr_val & ~ ( 1ull << 61 ) ) | ( ( u64 ) GetXER_SO ( ) << 61 ) ; PowerPC :: ppcState . cr_val [ idx ] = cr_val ; }
u32 Interpreter :: Helper_Carry ( u32 _uValue1 , u32 _uValue2 ) { return _uValue2 > ( ~ _uValue1 ) ; }
u32 Interpreter :: Helper_Mask ( int mb , int me ) { u32 begin = 0xFFFFFFFF >> mb ; u32 end = me < 31 ? ( 0xFFFFFFFF >> ( me + 1 ) ) : 0 ; u32 mask = begin ^ end ; if ( me < mb ) return ~ mask ; else return mask ; }
void Interpreter :: addi ( UGeckoInstruction _inst ) { if ( _inst . RA ) rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + _inst . SIMM_16 ; else rGPR [ _inst . RD ] = _inst . SIMM_16 ; }
void Interpreter :: addic ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 imm = ( u32 ) ( s32 ) _inst . SIMM_16 ; rGPR [ _inst . RD ] = a + imm ; SetCarry ( Helper_Carry ( a , imm ) ) ; }
void Interpreter :: addic_rc ( UGeckoInstruction _inst ) { addic ( _inst ) ; Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: addis ( UGeckoInstruction _inst ) { if ( _inst . RA ) rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + ( _inst . SIMM_16 << 16 ) ; else rGPR [ _inst . RD ] = ( _inst . SIMM_16 << 16 ) ; }
void Interpreter :: andi_rc ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & _inst . UIMM ; Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: andis_rc ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & ( ( u32 ) _inst . UIMM << 16 ) ; Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: cmpi ( UGeckoInstruction _inst ) { Helper_UpdateCRx ( _inst . CRFD , rGPR [ _inst . RA ] - _inst . SIMM_16 ) ; }
void Interpreter :: cmpli ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = _inst . UIMM ; int f ; if ( a < b ) f = 0x8 ; else if ( a > b ) f = 0x4 ; else f = 0x2 ; if ( GetXER_SO ( ) ) f |= 0x1 ; SetCRField ( _inst . CRFD , f ) ; }
void Interpreter :: mulli ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = ( s32 ) rGPR [ _inst . RA ] * _inst . SIMM_16 ; }
void Interpreter :: ori ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | _inst . UIMM ; }
void Interpreter :: oris ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | ( _inst . UIMM << 16 ) ; }
void Interpreter :: subfic ( UGeckoInstruction _inst ) { s32 immediate = _inst . SIMM_16 ; rGPR [ _inst . RD ] = immediate - ( int ) rGPR [ _inst . RA ] ; SetCarry ( ( rGPR [ _inst . RA ] == 0 ) || ( Helper_Carry ( 0 - rGPR [ _inst . RA ] , immediate ) ) ) ; }
void Interpreter :: twi ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = _inst . SIMM_16 ; s32 TO = _inst . TO ; DEBUG_LOG ( POWERPC , " twi ▁ rA ▁ % x ▁ SIMM ▁ % x ▁ TO ▁ % 0x " , a , b , TO ) ; if ( ( ( a < b ) && ( TO & 0x10 ) ) || ( ( a > b ) && ( TO & 0x08 ) ) || ( ( a == b ) && ( TO & 0x04 ) ) || ( ( ( u32 ) a < ( u32 ) b ) && ( TO & 0x02 ) ) || ( ( ( u32 ) a > ( u32 ) b ) && ( TO & 0x01 ) ) ) { PowerPC :: ppcState . Exceptions |= EXCEPTION_PROGRAM ; PowerPC :: CheckExceptions ( ) ; m_EndBlock = true ; } }
void Interpreter :: xori ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ _inst . UIMM ; }
void Interpreter :: xoris ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ ( _inst . UIMM << 16 ) ; }
void Interpreter :: rlwim@@ ix ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = ( rGPR [ _inst . RA ] & ~ mask ) | ( _rotl ( rGPR [ _inst . RS ] , _inst . SH ) & mask ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: rlwinmx ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = _rotl ( rGPR [ _inst . RS ] , _inst . SH ) & mask ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: rlwnmx ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = _rotl ( rGPR [ _inst . RS ] , rGPR [ _inst . RB ] & 0x1F ) & mask ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: andx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: andcx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & ~ rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: cmp ( UGeckoInstruction _inst ) { s32 a = ( s32 ) rGPR [ _inst . RA ] ; s32 b = ( s32 ) rGPR [ _inst . RB ] ; int fTemp ; if ( a < b ) fTemp = 0x8 ; else if ( a > b ) fTemp = 0x4 ; else fTemp = 0x2 ; if ( GetXER_SO ( ) ) fTemp |= 0x1 ; SetCRField ( _inst . CRFD , fTemp ) ; }
void Interpreter :: cmpl ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 fTemp ; if ( a < b ) fTemp = 0x8 ; else if ( a > b ) fTemp = 0x4 ; else fTemp = 0x2 ; if ( GetXER_SO ( ) ) fTemp |= 0x1 ; SetCRField ( _inst . CRFD , fTemp ) ; }
void Interpreter :: cntlz@@ wx ( UGeckoInstruction _inst ) { u32 val = rGPR [ _inst . RS ] ; u32 mask = 0x80000000 ; int i = 0 ; for ( ; i < 32 ; i ++ , mask >>= 1 ) { if ( val & mask ) break ; } rGPR [ _inst . RA ] = i ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: eqvx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] ^ rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: extsb@@ x ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ( u32 ) ( s32 ) ( s8 ) rGPR [ _inst . RS ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: extshx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ( u32 ) ( s32 ) ( s16 ) rGPR [ _inst . RS ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: nandx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] & rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: norx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] | rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: orx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: orcx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | ( ~ rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: slwx ( UGeckoInstruction _inst ) { u32 amount = rGPR [ _inst . RB ] ; rGPR [ _inst . RA ] = ( amount & 0x20 ) ? 0 : rGPR [ _inst . RS ] << ( amount & 0x1f ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: srawx ( UGeckoInstruction _inst ) { int rb = rGPR [ _inst . RB ] ; if ( rb & 0x20 ) { if ( rGPR [ _inst . RS ] & 0x80000000 ) { rGPR [ _inst . RA ] = 0xFFFFFFFF ; SetCarry ( 1 ) ; } else { rGPR [ _inst . RA ] = 0x00000000 ; SetCarry ( 0 ) ; } } else { int amount = rb & 0x1f ; if ( amount == 0 ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ; SetCarry ( 0 ) ; } else { s32 rrs = rGPR [ _inst . RS ] ; rGPR [ _inst . RA ] = rrs >> amount ; if ( ( rrs < 0 ) && ( rrs << ( 32 - amount ) ) ) SetCarry ( 1 ) ; else SetCarry ( 0 ) ; } } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: srawix ( UGeckoInstruction _inst ) { int amount = _inst . SH ; if ( amount != 0 ) { s32 rrs = rGPR [ _inst . RS ] ; rGPR [ _inst . RA ] = rrs >> amount ; if ( ( rrs < 0 ) && ( rrs << ( 32 - amount ) ) ) SetCarry ( 1 ) ; else SetCarry ( 0 ) ; } else { SetCarry ( 0 ) ; rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: srwx ( UGeckoInstruction _inst ) { u32 amount = rGPR [ _inst . RB ] ; rGPR [ _inst . RA ] = ( amount & 0x20 ) ? 0 : ( rGPR [ _inst . RS ] >> ( amount & 0x1f ) ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: tw ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = rGPR [ _inst . RB ] ; s32 TO = _inst . TO ; DEBUG_LOG ( POWERPC , " tw ▁ rA ▁ % 0x ▁ rB ▁ % 0x ▁ TO ▁ % 0x " , a , b , TO ) ; if ( ( ( a < b ) && ( TO & 0x10 ) ) || ( ( a > b ) && ( TO & 0x08 ) ) || ( ( a == b ) && ( TO & 0x04 ) ) || ( ( ( u32 ) a < ( u32 ) b ) && ( TO & 0x02 ) ) || ( ( ( u32 ) a > ( u32 ) b ) && ( TO & 0x01 ) ) ) { PowerPC :: ppcState . Exceptions |= EXCEPTION_PROGRAM ; PowerPC :: CheckExceptions ( ) ; m_EndBlock = true ; } }
void Interpreter :: xorx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: addx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + rGPR [ _inst . RB ] ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: addcx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = a + b ; SetCarry ( Helper_Carry ( a , b ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addcx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: addex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; int b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = a + b + carry ; SetCarry ( Helper_Carry ( a , b ) || ( carry != 0 && Helper_Carry ( a + b , carry ) ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: addmex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; rGPR [ _inst . RD ] = a + carry - 1 ; SetCarry ( Helper_Carry ( a , carry - 1 ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addmex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: addzex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; rGPR [ _inst . RD ] = a + carry ; SetCarry ( Helper_Carry ( a , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addzex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: divwx ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = rGPR [ _inst . RB ] ; if ( b == 0 || ( ( u32 ) a == 0x80000000 && b == - 1 ) ) { if ( _inst . OE ) { PanicAlert ( " OE : ▁ divwx " ) ; } if ( ( ( u32 ) a & 0x80000000 ) && b == 0 ) rGPR [ _inst . RD ] = - 1 ; else rGPR [ _inst . RD ] = 0 ; } else { rGPR [ _inst . RD ] = ( u32 ) ( a / b ) ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: divwux ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; if ( b == 0 ) { if ( _inst . OE ) { PanicAlert ( " OE : ▁ divwux " ) ; } rGPR [ _inst . RD ] = 0 ; } else { rGPR [ _inst . RD ] = a / b ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: mulhwx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( u64 ) ( ( ( s64 ) ( s32 ) a * ( s64 ) ( s32 ) b ) ) >> 32 ) ; rGPR [ _inst . RD ] = d ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: mulhwux ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( ( u64 ) a * ( u64 ) b ) >> 32 ) ; rGPR [ _inst . RD ] = d ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: mullwx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( s32 ) a * ( s32 ) b ) ; rGPR [ _inst . RD ] = d ; if ( _inst . OE ) PanicAlert ( " OE : ▁ mullwx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: negx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = ( ~ rGPR [ _inst . RA ] ) + 1 ; if ( rGPR [ _inst . RD ] == 0x80000000 ) { if ( _inst . OE ) PanicAlert ( " OE : ▁ negx " ) ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: subfx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = rGPR [ _inst . RB ] - rGPR [ _inst . RA ] ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: subfcx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = b - a ; SetCarry ( a == 0 || Helper_Carry ( b , 0 - a ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfcx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: subfex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + b + carry ; SetCarry ( Helper_Carry ( ~ a , b ) || Helper_Carry ( ( ~ a ) + b , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: subfmex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + carry - 1 ; SetCarry ( Helper_Carry ( ~ a , carry - 1 ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfmex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: subfzex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + carry ; SetCarry ( Helper_Carry ( ~ a , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfzex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
CDB :: CDB ( const char * pszFile , const char * pszMode ) : pdb ( NULL ) { int ret ; if ( pszFile == NULL ) return ; fReadOnly = ( ! strchr ( pszMode , ' + ' ) && ! strchr ( pszMode , ' w ' ) ) ; bool fCreate = strchr ( pszMode , ' c ' ) ; unsigned int nFlags = DB_THREAD ; if ( fCreate ) nFlags |= DB_CREATE ; CRITICAL_BLOCK ( cs_db ) { if ( ! fDbEnvInit ) { if ( fShutdown ) return ; string strDataDir = GetDataDir ( ) ; string strLogDir = strDataDir + " / database " ; filesystem :: create_di@@ rectory ( strLogDir . c_str ( ) ) ; string strErrorFile = strDataDir + " / db . log " ; printf ( " dbenv . open ▁ strLogDir = % s ▁ strErrorFile = % s \n " , strLogDir . c_str ( ) , strErrorFile . c_str ( ) ) ; dbenv . set_lg_dir ( strLogDir . c_str ( ) ) ; dbenv . set_lg_max ( 10000000 ) ; dbenv . set_lk_max_locks ( 10000 ) ; dbenv . set_lk_max_objects ( 10000 ) ; dbenv . set_errfile ( fopen ( strErrorFile . c_str ( ) , " a " ) ) ; dbenv . set_flags ( DB_AUTO@@ _COMMIT , 1 ) ; ret = dbenv . open ( strDataDir . c_str ( ) , DB_CREATE | DB_INIT_LOCK | DB_INIT_LOG | DB_INIT_MPOO@@ L | DB_INIT_TXN | DB_THREAD | DB_REC@@ OVER , S_IRUSR | S_IWUSR ) ; if ( ret > 0 ) throw runtime_error ( strprintf ( " CDB ( ) ▁ : ▁ error ▁ % d ▁ opening ▁ database ▁ environment " , ret ) ) ; fDbEnvInit = true ; } strFile = pszFile ; ++ mapFileUseCount [ strFile ] ; pdb = mapDb [ strFile ] ; if ( pdb == NULL ) { pdb = new Db ( & dbenv , 0 ) ; ret = pdb -> open ( NULL , pszFile , " main " , DB_BTRE@@ E , nFlags , 0 ) ; if ( ret > 0 ) { delete pdb ; pdb = NULL ; CRITICAL_BLOCK ( cs_db ) -- mapFileUseCount [ strFile ] ; strFile = " " ; throw runtime_error ( strprintf ( " CDB ( ) ▁ : ▁ can ' t ▁ open ▁ database ▁ file ▁ % s , ▁ error ▁ % d " , pszFile , ret ) ) ; } if ( fCreate && ! Exists ( string ( " version " ) ) ) { bool fTmp = fReadOnly ; fReadOnly = false ; WriteVersion ( VERSION ) ; fReadOnly = fTmp ; } mapDb [ strFile ] = pdb ; } } }
void CDB :: Close ( ) { if ( ! pdb ) return ; if ( ! vTxn . empty ( ) ) vTxn . front ( ) -> abort ( ) ; vTxn . clear ( ) ; pdb = NULL ; unsigned int nMinutes = 0 ; if ( fReadOnly ) nMinutes = 1 ; if ( strFile == " addr . dat " ) nMinutes = 2 ; if ( strFile == " blkindex . dat " && IsInitial@@ BlockDown@@ load ( ) && nBestHeight % 500 != 0 ) nMinutes = 1 ; dbenv . txn_checkpoint ( 0 , nMinutes , 0 ) ; CRITICAL_BLOCK ( cs_db ) -- mapFileUseCount [ strFile ] ; }
bool CTxDB :: ReadTxIndex ( uint256 hash , CTxIndex & txindex ) { assert ( ! fClient ) ; txindex . SetNull ( ) ; return Read ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; }
bool CTxDB :: UpdateTxIndex ( uint256 hash , const CTxIndex & txindex ) { assert ( ! fClient ) ; return Write ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; }
bool CTxDB :: AddTxIndex ( const CTransaction & tx , const CDiskTxPos & pos , int nHeight ) { assert ( ! fClient ) ; uint256 hash = tx . GetHash ( ) ; CTxIndex txindex ( pos , tx . vout . size ( ) ) ; return Write ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; }
bool CTxDB :: EraseTxIndex ( const CTransaction & tx ) { assert ( ! fClient ) ; uint256 hash = tx . GetHash ( ) ; return Erase ( make_pair ( string ( " tx " ) , hash ) ) ; }
bool CTxDB :: ContainsTx ( uint256 hash ) { assert ( ! fClient ) ; return Exists ( make_pair ( string ( " tx " ) , hash ) ) ; }
bool CTxDB :: ReadOwner@@ Txes ( uint160 hash160 , int nMinHeight , vector < CTransaction > & vtx ) { assert ( ! fClient ) ; vtx . clear ( ) ; Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; unsigned int fFlags = DB_SET_RANGE ; loop { CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << string ( " owner " ) << hash160 << CDiskTxPos ( 0 , 0 , 0 ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) { pcursor -> close ( ) ; return false ; } string strType ; uint160 hashItem ; CDiskTxPos pos ; ssKey >> strType >> hashItem >> pos ; int nItemHeight ; ssValue >> nItemHeight ; if ( strType != " owner " || hashItem != hash160 ) break ; if ( nItemHeight >= nMinHeight ) { vtx . resize ( vtx . size ( ) + 1 ) ; if ( ! vtx . back ( ) . ReadFromDisk ( pos ) ) { pcursor -> close ( ) ; return false ; } } } pcursor -> close ( ) ; return true ; }
bool CTxDB :: ReadDiskTx ( uint256 hash , CTransaction & tx , CTxIndex & txindex ) { assert ( ! fClient ) ; tx . SetNull ( ) ; if ( ! ReadTxIndex ( hash , txindex ) ) return false ; return ( tx . ReadFromDisk ( txindex . pos ) ) ; }
bool CTxDB :: ReadDiskTx ( uint256 hash , CTransaction & tx ) { CTxIndex txindex ; return ReadDiskTx ( hash , tx , txindex ) ; }
bool CTxDB :: ReadDiskTx ( COutPoint outpoint , CTransaction & tx , CTxIndex & txindex ) { return ReadDiskTx ( outpoint . hash , tx , txindex ) ; }
bool CTxDB :: ReadDiskTx ( COutPoint outpoint , CTransaction & tx ) { CTxIndex txindex ; return ReadDiskTx ( outpoint . hash , tx , txindex ) ; }
bool CTxDB :: WriteBlockIndex ( const CDiskBlockIndex & blockindex ) { return Write ( make_pair ( string ( " blockindex " ) , blockindex . GetBlockHash ( ) ) , blockindex ) ; }
bool CTxDB :: EraseBlockIndex ( uint256 hash ) { return Erase ( make_pair ( string ( " blockindex " ) , hash ) ) ; }
bool CTxDB :: ReadHashBestChain ( uint256 & hashBestChain ) { return Read ( string ( " hashBestChain " ) , hashBestChain ) ; }
bool CTxDB :: WriteHashBestChain ( uint256 hashBestChain ) { return Write ( string ( " hashBestChain " ) , hashBestChain ) ; }
bool CTxDB :: ReadBestInvalidWork ( CBigNum & bnBestInvalidWork ) { return Read ( string ( " bnBestInvalidWork " ) , bnBestInvalidWork ) ; }
bool CTxDB :: WriteBestInvalidWork ( CBigNum bnBestInvalidWork ) { return Write ( string ( " bnBestInvalidWork " ) , bnBestInvalidWork ) ; }
bool CTxDB :: LoadBlockIndex ( ) { Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; unsigned int fFlags = DB_SET_RANGE ; loop { CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << make_pair ( string ( " blockindex " ) , uint256 ( 0 ) ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; string strType ; ssKey >> strType ; if ( strType == " blockindex " ) { CDiskBlockIndex diskindex ; ssValue >> diskindex ; CBlockIndex * pindexNew = InsertBlockIndex ( diskindex . GetBlockHash ( ) ) ; pindexNew -> pprev = InsertBlockIndex ( diskindex . hashPrev ) ; pindexNew -> pnext = InsertBlockIndex ( diskindex . hashNext ) ; pindexNew -> nFile = diskindex . nFile ; pindexNew -> nBlockPos = diskindex . nBlockPos ; pindexNew -> nHeight = diskindex . nHeight ; pindexNew -> nVersion = diskindex . nVersion ; pindexNew -> hashMerkleRoot = diskindex . hashMerkleRoot ; pindexNew -> nTime = diskindex . nTime ; pindexNew -> nBits = diskindex . nBits ; pindexNew -> nNonce = diskindex . nNonce ; pindexNew -> auxpow = diskindex . auxpow ; if ( pindexGenesisBlock == NULL && diskindex . GetBlockHash ( ) == hashGenesisBlock ) pindexGenesisBlock = pindexNew ; if ( ! pindexNew -> CheckIndex ( ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ CheckIndex ▁ failed ▁ at ▁ % d " , pindexNew -> nHeight ) ; } else { break ; } } pcursor -> close ( ) ; vector < pair < int , CBlockIndex * > > vSortedByHeight ; vSortedByHeight . reserve ( mapBlockIndex . size ( ) ) ; BOOST_FOREACH ( const PAIRTYPE ( uint256 , CBlockIndex * ) & item , mapBlockIndex ) { CBlockIndex * pindex = item . second ; vSortedByHeight . push_back ( make_pair ( pindex -> nHeight , pindex ) ) ; } sort ( vSortedByHeight . begin ( ) , vSortedByHeight . end ( ) ) ; BOOST_FOREACH ( const PAIRTYPE ( int , CBlockIndex * ) & item , vSortedByHeight ) { CBlockIndex * pindex = item . second ; pindex -> bnChainWork = ( pindex -> pprev ? pindex -> pprev -> bnChainWork : 0 ) + pindex -> GetBlockWork ( ) ; } if ( ! ReadHashBestChain ( hashBestChain ) ) { if ( pindexGenesisBlock == NULL ) return true ; return error ( " CTxDB : : LoadBlockIndex ( ) ▁ : ▁ hashBestChain ▁ not ▁ loaded " ) ; } if ( ! mapBlockIndex . count ( hashBestChain ) ) return error ( " CTxDB : : LoadBlockIndex ( ) ▁ : ▁ hashBestChain ▁ not ▁ found ▁ in ▁ the ▁ block ▁ index " ) ; pindexBest = mapBlockIndex [ hashBestChain ] ; nBestHeight = pindexBest -> nHeight ; bnBestChainWork = pindexBest -> bnChainWork ; printf ( " LoadBlockIndex ( ) : ▁ hashBestChain = % s ▁ ▁ height = % d \n " , hashBestChain . ToString ( ) . substr ( 0 , 20 ) . c_str ( ) , nBestHeight ) ; ReadBestInvalidWork ( bnBestInvalidWork ) ; CBlockIndex * pindexFork = NULL ; for ( CBlockIndex * pindex = pindexBest ; pindex && pindex -> pprev ; pindex = pindex -> pprev ) { if ( pindex -> nHeight < nBestHeight - 2500 && ! mapArgs . count ( " - checkblock@@ s " ) ) break ; CBlock block ; if ( ! block . ReadFromDisk ( pindex ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ block . ReadFromDisk ▁ failed " ) ; if ( ! block . CheckBlock ( pindex -> nHeight ) ) { printf ( " LoadBlockIndex ( ) ▁ : ▁ * * * ▁ found ▁ bad ▁ block ▁ at ▁ % d , ▁ hash = % s \n " , pindex -> nHeight , pindex -> GetBlockHash ( ) . ToString ( ) . c_str ( ) ) ; pindexFork = pindex -> pprev ; } } if ( pindexFork ) { printf ( " LoadBlockIndex ( ) ▁ : ▁ * * * ▁ moving ▁ best ▁ chain ▁ pointer ▁ back ▁ to ▁ block ▁ % d \n " , pindexFork -> nHeight ) ; CBlock block ; if ( ! block . ReadFromDisk ( pindexFork ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ block . ReadFromDisk ▁ failed " ) ; CTxDB txdb ; block . SetBestChain ( txdb , pindexFork ) ; } return true ; }
bool CAddrDB :: WriteAddress ( const CAddress & addr ) { return Write ( make_pair ( string ( " addr " ) , addr . GetKey ( ) ) , addr ) ; }
bool CAddrDB :: EraseAddress ( const CAddress & addr ) { return Erase ( make_pair ( string ( " addr " ) , addr . GetKey ( ) ) ) ; }
bool CAddrDB :: LoadAddresses ( ) { CRITICAL_BLOCK ( cs_mapAddresses ) { CAutoFile filein = fopen ( ( GetDataDir ( ) + " / addr . txt " ) . c_str ( ) , " rt " ) ; if ( filein ) { try { char psz [ 1000 ] ; while ( fgets ( psz , sizeof ( psz ) , filein ) ) { CAddress addr ( psz , NODE_NETWORK ) ; addr . nTime = 0 ; if ( addr . IsValid ( ) ) AddAddress ( addr ) ; } } catch ( ... ) { } } Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; loop { CDataStream ssKey ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue ) ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; string strType ; ssKey >> strType ; if ( strType == " addr " ) { CAddress addr ; ssValue >> addr ; mapAddresses . insert ( make_pair ( addr . GetKey ( ) , addr ) ) ; } } pcursor -> close ( ) ; printf ( " Loaded ▁ % d ▁ addresses \n " , mapAddresses . size ( ) ) ; } return true ; }
bool CWalletDB :: WriteName ( const string & strAddress , const string & strName ) { nWalletDBUpdated ++ ; return Write ( make_pair ( string ( " name " ) , strAddress ) , strName ) ; }
bool CWalletDB :: EraseName ( const string & strAddress ) { nWalletDBUpdated ++ ; return Erase ( make_pair ( string ( " name " ) , strAddress ) ) ; }
bool CWalletDB :: ReadAccount ( const string & strAccount , CAccount & account ) { account . SetNull ( ) ; return Read ( make_pair ( string ( " acc " ) , strAccount ) , account ) ; }
bool CWalletDB :: WriteAccount ( const string & strAccount , const CAccount & account ) { return Write ( make_pair ( string ( " acc " ) , strAccount ) , account ) ; }
bool CWalletDB :: WriteAccountingEntry ( const CAccountingEntry & acentry ) { return Write ( make_tuple ( string ( " acentry " ) , acentry . strAccount , ++ nAccountingEntryNumber ) , acentry ) ; }
int64 CWalletDB :: GetAccountCreditDebit ( const string & strAccount ) { list < CAccountingEntry > entries ; ListAccountCreditDebit ( strAccount , entries ) ; int64 nCreditDebit = 0 ; BOOST_FOREACH ( const CAccountingEntry & entry , entries ) nCreditDebit += entry . nCreditDebit ; return nCreditDebit ; }
void CWalletDB :: ListAccountCreditDebit ( const string & strAccount , list < CAccountingEntry > & entries ) { int64 nCreditDebit = 0 ; bool fAllAccounts = ( strAccount == " * " ) ; Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) throw runtime_error ( " CWalletDB : : ListAccountCreditDebit ( ) ▁ : ▁ cannot ▁ create ▁ DB ▁ cursor " ) ; unsigned int fFlags = DB_SET_RANGE ; loop { CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << make_tuple ( string ( " acentry " ) , ( fAllAccounts ? string ( " " ) : strAccount ) , uint64 ( 0 ) ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) { pcursor -> close ( ) ; throw runtime_error ( " CWalletDB : : ListAccountCreditDebit ( ) ▁ : ▁ error ▁ scanning ▁ DB " ) ; } string strType ; ssKey >> strType ; if ( strType != " acentry " ) break ; CAccountingEntry acentry ; ssKey >> acentry . strAccount ; if ( ! fAllAccounts && acentry . strAccount != strAccount ) break ; ssValue >> acentry ; entries . push_back ( acentry ) ; } pcursor -> close ( ) ; }
bool CWalletDB :: LoadWallet ( CWallet * pwallet ) { pwallet -> vchDefaultKey . clear ( ) ; int nFileVersion = 0 ; vector < uint256 > vWalletUpgrade ; fMinimizeToTray = false ; fMinimizeOnClose = false ; CRITICAL_BLOCK ( pwallet -> cs_mapWallet ) CRITICAL_BLOCK ( pwallet -> cs_mapKeys ) { Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; loop { CDataStream ssKey ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue ) ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; string strType ; ssKey >> strType ; if ( strType == " name " ) { string strAddress ; ssKey >> strAddress ; ssValue >> pwallet -> mapAddress@@ Book [ strAddress ] ; } else if ( strType == " tx " ) { uint256 hash ; ssKey >> hash ; CWalletTx & wtx = pwallet -> mapWallet [ hash ] ; ssValue >> wtx ; wtx . pwallet = pwallet ; if ( wtx . GetHash ( ) != hash ) printf ( " Error ▁ in ▁ wallet . dat , ▁ hash ▁ mismatch \n " ) ; if ( 31404 <= wtx . fTimeReceivedIsTxTime && wtx . fTimeReceivedIsTxTime <= 31703 ) { if ( ! ssValue . empty ( ) ) { char fTmp ; char fUnused ; ssValue >> fTmp >> fUnused >> wtx . strFromAccount ; printf ( " LoadWallet ( ) ▁ upgrading ▁ tx ▁ ver = % d ▁ % d ▁ ' % s ' ▁ % s \n " , wtx . fTimeReceivedIsTxTime , fTmp , wtx . strFromAccount . c_str ( ) , hash . ToString ( ) . c_str ( ) ) ; wtx . fTimeReceivedIsTxTime = fTmp ; } else { printf ( " LoadWallet ( ) ▁ repairing ▁ tx ▁ ver = % d ▁ % s \n " , wtx . fTimeReceivedIsTxTime , hash . ToString ( ) . c_str ( ) ) ; wtx . fTimeReceivedIsTxTime = 0 ; } vWalletUpgrade . push_back ( hash ) ; } } else if ( strType == " acentry " ) { string strAccount ; ssKey >> strAccount ; uint64 nNumber ; ssKey >> nNumber ; if ( nNumber > nAccountingEntryNumber ) nAccountingEntryNumber = nNumber ; } else if ( strType == " key " || strType == " wkey " ) { vector < unsigned char > vchPubKey ; ssKey >> vchPubKey ; CWalletKey wkey ; if ( strType == " key " ) ssValue >> wkey . vchPrivKey ; else ssValue >> wkey ; pwallet -> mapKeys [ vchPubKey ] = wkey . vchPrivKey ; mapPubKeys [ Hash160 ( vchPubKey ) ] = vchPubKey ; } else if ( strType == " defaultkey " ) { ssValue >> pwallet -> vchDefaultKey ; } else if ( strType == " pool " ) { int64 nIndex ; ssKey >> nIndex ; pwallet -> setKeyPool . insert ( nIndex ) ; } else if ( strType == " version " ) { ssValue >> nFileVersion ; if ( nFileVersion == 10300 ) nFileVersion = 300 ; } else if ( strType == " setting " ) { string strKey ; ssKey >> strKey ; if ( strKey == " fGenerateBitcoins " ) ssValue >> fGenerateBitcoins ; if ( strKey == " nTransactionFee " ) ssValue >> nTransactionFee ; if ( strKey == " addrIncoming " ) ssValue >> addrIncoming ; if ( strKey == " fLimitProcessors " ) ssValue >> fLimitProcessors ; if ( strKey == " nLimitProcessors " ) ssValue >> nLimitProcessors ; if ( strKey == " fMinimizeToTray " ) ssValue >> fMinimizeToTray ; if ( strKey == " fMinimizeOnClose " ) ssValue >> fMinimizeOnClose ; if ( strKey == " fUseProxy " ) ssValue >> fUseProxy ; if ( strKey == " addrProxy " ) ssValue >> addrProxy ; if ( fHaveUPnP && strKey == " fUseUPnP " ) ssValue >> fUseUPnP ; } } pcursor -> close ( ) ; } BOOST_FOREACH ( uint256 hash , vWalletUpgrade ) WriteTx ( hash , pwallet -> mapWallet [ hash ] ) ; printf ( " nFileVersion ▁ = ▁ % d \n " , nFileVersion ) ; printf ( " fGenerateBitcoins ▁ = ▁ % d \n " , fGenerateBitcoins ) ; printf ( " nTransactionFee ▁ = ▁ % " PRI64d " \n " , nTransactionFee ) ; printf ( " addrIncoming ▁ = ▁ % s \n " , addrIncoming . ToString ( ) . c_str ( ) ) ; printf ( " fMinimizeToTray ▁ = ▁ % d \n " , fMinimizeToTray ) ; printf ( " fMinimizeOnClose ▁ = ▁ % d \n " , fMinimizeOnClose ) ; printf ( " fUseProxy ▁ = ▁ % d \n " , fUseProxy ) ; printf ( " addrProxy ▁ = ▁ % s \n " , addrProxy . ToString ( ) . c_str ( ) ) ; if ( fHaveUPnP ) printf ( " fUseUPnP ▁ = ▁ % d \n " , fUseUPnP ) ; if ( nFileVersion < VERSION ) { if ( nFileVersion <= 105 && ! pszSetDataDir [ 0 ] ) unlink ( " debug . log " ) ; WriteVersion ( VERSION ) ; } return true ; }
RuleBasedTimeZone :: RuleBasedTimeZone ( const RuleBasedTimeZone & source ) : BasicTimeZone ( source ) , fInitialRule ( source . fInitialRule -> clone ( ) ) , fHistoricTransitions ( NULL ) , fUpToDate ( FALSE ) { fHistoricRules = copyRules ( source . fHistoricRules ) ; fFinalRules = copyRules ( source . fFinalRules ) ; if ( source . fUpToDate ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; } }
RuleBasedTimeZone :: ~ RuleBasedTimeZone ( ) { deleteTransitions ( ) ; deleteRules ( ) ; }
void RuleBasedTimeZone :: addTransitionRule ( TimeZoneRule * rule , UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } AnnualTimeZoneRule * atzrule = dynamic_cast < AnnualTimeZoneRule * > ( rule ) ; if ( atzrule != NULL && atzrule -> getEndYear ( ) == AnnualTimeZoneRule :: MAX_YEAR ) { if ( fFinalRules == NULL ) { fFinalRules = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { return ; } } else if ( fFinalRules -> size ( ) >= 2 ) { status = U_INVALID_STATE_ERROR ; return ; } fFinalRules -> addElement ( ( void * ) rule , status ) ; } else { if ( fHistoricRules == NULL ) { fHistoricRules = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { return ; } } fHistoricRules -> addElement ( ( void * ) rule , status ) ; } fUpToDate = FALSE ; }
void RuleBasedTimeZone :: complete ( UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } if ( fUpToDate ) { return ; } if ( fFinalRules != NULL && fFinalRules -> size ( ) != 2 ) { status = U_INVALID_STATE_ERROR ; return ; } UBool * done = NULL ; if ( fHistoricRules != NULL || fFinalRules != NULL ) { TimeZoneRule * curRule = fInitialRule ; UDate lastTransitionTime = MIN_MILLIS ; if ( fHistoricRules != NULL && fHistoricRules -> size ( ) > 0 ) { int32_t i ; int32_t historicCount = fHistoricRules -> size ( ) ; done = ( UBool * ) uprv_malloc ( sizeof ( UBool ) * historicCount ) ; if ( done == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } for ( i = 0 ; i < historicCount ; i ++ ) { done [ i ] = FALSE ; } while ( TRUE ) { int32_t curStdOffset = curRule -> getRawOffset ( ) ; int32_t curDstSavings = curRule -> getDSTSavings ( ) ; UDate nextTransitionTime = MAX_MILLIS ; TimeZoneRule * nextRule = NULL ; TimeZoneRule * r = NULL ; UBool avail ; UDate tt ; UnicodeString curName , name ; curRule -> getName ( curName ) ; for ( i = 0 ; i < historicCount ; i ++ ) { if ( done [ i ] ) { continue ; } r = ( TimeZoneRule * ) fHistoricRules -> elementAt ( i ) ; avail = r -> getNextStart ( lastTransitionTime , curStdOffset , curDstSavings , false , tt ) ; if ( ! avail ) { done [ i ] = TRUE ; } else { r -> getName ( name ) ; if ( * r == * curRule || ( name == curName && r -> getRawOffset ( ) == curRule -> getRawOffset ( ) && r -> getDSTSavings ( ) == curRule -> getDSTSavings ( ) ) ) { continue ; } if ( tt < nextTransitionTime ) { nextTransitionTime = tt ; nextRule = r ; } } } if ( nextRule == NULL ) { UBool bDoneAll = TRUE ; for ( int32_t j = 0 ; j < historicCount ; j ++ ) { if ( ! done [ j ] ) { bDoneAll = FALSE ; break ; } } if ( bDoneAll ) { break ; } } if ( fFinalRules != NULL ) { for ( i = 0 ; i < 2 ; i ++ ) { TimeZoneRule * fr = ( TimeZoneRule * ) fFinalRules -> elementAt ( i ) ; if ( * fr == * curRule ) { continue ; } r = ( TimeZoneRule * ) fFinalRules -> elementAt ( i ) ; avail = r -> getNextStart ( lastTransitionTime , curStdOffset , curDstSavings , false , tt ) ; if ( avail ) { if ( tt < nextTransitionTime ) { nextTransitionTime = tt ; nextRule = r ; } } } } if ( nextRule == NULL ) { break ; } if ( fHistoricTransitions == NULL ) { fHistoricTransitions = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } Transition * trst = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( trst == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } trst -> time = nextTransitionTime ; trst -> from = curRule ; trst -> to = nextRule ; fHistoricTransitions -> addElement ( trst , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } lastTransitionTime = nextTransitionTime ; curRule = nextRule ; } } if ( fFinalRules != NULL ) { if ( fHistoricTransitions == NULL ) { fHistoricTransitions = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } TimeZoneRule * rule0 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; TimeZoneRule * rule1 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; UDate tt0 , tt1 ; UBool avail0 = rule0 -> getNextStart ( lastTransitionTime , curRule -> getRawOffset ( ) , curRule -> getDSTSavings ( ) , false , tt0 ) ; UBool avail1 = rule1 -> getNextStart ( lastTransitionTime , curRule -> getRawOffset ( ) , curRule -> getDSTSavings ( ) , false , tt1 ) ; if ( ! avail0 || ! avail1 ) { status = U_INVALID_STATE_ERROR ; goto cleanup ; } Transition * final0 = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( final0 == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } Transition * final1 = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( final1 == NULL ) { uprv_free ( final0 ) ; status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } if ( tt0 < tt1 ) { final0 -> time = tt0 ; final0 -> from = curRule ; final0 -> to = rule0 ; rule1 -> getNextStart ( tt0 , rule0 -> getRawOffset ( ) , rule0 -> getDSTSavings ( ) , false , final1 -> time ) ; final1 -> from = rule0 ; final1 -> to = rule1 ; } else { final0 -> time = tt1 ; final0 -> from = curRule ; final0 -> to = rule1 ; rule0 -> getNextStart ( tt1 , rule1 -> getRawOffset ( ) , rule1 -> getDSTSavings ( ) , false , final1 -> time ) ; final1 -> from = rule1 ; final1 -> to = rule0 ; } fHistoricTransitions -> addElement ( final0 , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } fHistoricTransitions -> addElement ( final1 , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } } fUpToDate = TRUE ; if ( done != NULL ) { uprv_free ( done ) ; } return ; cleanup : deleteTransitions ( ) ; if ( done != NULL ) { uprv_free ( done ) ; } fUpToDate = FALSE ; }
void RuleBasedTimeZone :: getOffsetFromLocal ( UDate date , int32_t nonExistingTimeOpt , int32_t duplicatedTimeOpt , int32_t & rawOffset , int32_t & dstOffset , UErrorCode & status ) { getOffsetInternal ( date , TRUE , nonExistingTimeOpt , duplicatedTimeOpt , rawOffset , dstOffset , status ) ; }
UBool RuleBasedTimeZone :: getNextTransition ( UDate base , UBool inclusive , TimeZoneTransition & result ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; if ( U_FAILURE ( status ) ) { return FALSE ; } UDate transitionTime ; TimeZoneRule * fromRule , * toRule ; UBool found = findNext ( base , inclusive , transitionTime , fromRule , toRule ) ; if ( found ) { result . setTime ( transitionTime ) ; result . setFrom ( ( const TimeZoneRule & ) * fromRule ) ; result . setTo ( ( const TimeZoneRule & ) * toRule ) ; return TRUE ; } return FALSE ; }
UBool RuleBasedTimeZone :: getPreviousTransition ( UDate base , UBool inclusive , TimeZoneTransition & result ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; if ( U_FAILURE ( status ) ) { return FALSE ; } UDate transitionTime ; TimeZoneRule * fromRule , * toRule ; UBool found = findPrev ( base , inclusive , transitionTime , fromRule , toRule ) ; if ( found ) { result . setTime ( transitionTime ) ; result . setFrom ( ( const TimeZoneRule & ) * fromRule ) ; result . setTo ( ( const TimeZoneRule & ) * toRule ) ; return TRUE ; } return FALSE ; }
int32_t RuleBasedTimeZone :: countTransitionRules ( UErrorCode & ) { int32_t count = 0 ; if ( fHistoricRules != NULL ) { count += fHistoricRules -> size ( ) ; } if ( fFinalRules != NULL ) { count += fFinalRules -> size ( ) ; } return count ; }
void RuleBasedTimeZone :: getTimeZoneRules ( const InitialTimeZoneRule * & initial , const TimeZoneRule * trsrules [ ] , int32_t & trscount , UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } initial = fInitialRule ; int32_t cnt = 0 ; int32_t idx ; if ( fHistoricRules != NULL && cnt < trscount ) { int32_t historicCount = fHistoricRules -> size ( ) ; idx = 0 ; while ( cnt < trscount && idx < historicCount ) { trsrules [ cnt ++ ] = ( const TimeZoneRule * ) fHistoricRules -> elementAt ( idx ++ ) ; } } if ( fFinalRules != NULL && cnt < trscount ) { int32_t finalCount = fFinalRules -> size ( ) ; idx = 0 ; while ( cnt < trscount && idx < finalCount ) { trsrules [ cnt ++ ] = ( const TimeZoneRule * ) fFinalRules -> elementAt ( idx ++ ) ; } } trscount = cnt ; }
void RuleBasedTimeZone :: deleteRules ( void ) { delete fInitialRule ; fInitialRule = NULL ; if ( fHistoricRules != NULL ) { while ( ! fHistoricRules -> isEmpty ( ) ) { delete ( TimeZoneRule * ) ( fHistoricRules -> orphanElementAt ( 0 ) ) ; } delete fHistoricRules ; fHistoricRules = NULL ; } if ( fFinalRules != NULL ) { while ( ! fFinalRules -> isEmpty ( ) ) { delete ( AnnualTimeZoneRule * ) ( fFinalRules -> orphanElementAt ( 0 ) ) ; } delete fFinalRules ; fFinalRules = NULL ; } }
void RuleBasedTimeZone :: deleteTransitions ( void ) { if ( fHistoricTransitions != NULL ) { while ( ! fHistoricTransitions -> isEmpty ( ) ) { Transition * trs = ( Transition * ) fHistoricTransitions -> orphanElementAt ( 0 ) ; uprv_free ( trs ) ; } delete fHistoricTransitions ; } fHistoricTransitions = NULL ; }
UVector * RuleBasedTimeZone :: copyRules ( UVector * source ) { if ( source == NULL ) { return NULL ; } UErrorCode ec = U_ZERO_ERROR ; int32_t size = source -> size ( ) ; UVector * rules = new UVector ( size , ec ) ; if ( U_FAILURE ( ec ) ) { return NULL ; } int32_t i ; for ( i = 0 ; i < size ; i ++ ) { rules -> addElement ( ( ( TimeZoneRule * ) source -> elementAt ( i ) ) -> clone ( ) , ec ) ; if ( U_FAILURE ( ec ) ) { break ; } } if ( U_FAILURE ( ec ) ) { for ( i = 0 ; i < rules -> size ( ) ; i ++ ) { TimeZoneRule * rule = ( TimeZoneRule * ) rules -> orphanElementAt ( i ) ; delete rule ; } delete rules ; return NULL ; } return rules ; }
