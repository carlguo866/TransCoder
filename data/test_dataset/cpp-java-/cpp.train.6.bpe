<DOCUMENT_ID="Rizta@@ zz/tr@@ initycore-m@@ 4a/tree/master/src/server/scripts/EasternKingdoms/Strathol@@ me/boss_nerubenkan.cpp"> # include " stdafx . hpp " # include " ScriptMgr . h " # include " ScriptedCreature . h " # include " stratholme . h " enum Spells { SPELL_ENCASINGWEBS = 4962 , SPELL_PIERCEARMOR = 6016 , SPELL_CRYPT_SCARABS = 31602 , SPELL_RAISE@@ UNDEAD@@ SCARAB = 17235 } ; class boss_nerubenkan : public CreatureScript { public : boss_nerubenkan ( ) : CreatureScript ( " boss _ nerubenkan " ) { } CreatureAI * GetAI ( Creature * creature ) const { return new boss_nerubenkanAI ( creature ) ; } struct boss_nerubenkanAI : public ScriptedAI { boss_nerubenkanAI ( Creature * creature ) : ScriptedAI ( creature ) { instance = me -> GetInstanceScript ( ) ; } InstanceScript * instance ; uint32 EncasingWebs_Timer ; uint32 PierceArmor_Timer ; uint32 CryptScarabs_Timer ; uint32 RaiseUndeadScarab_Timer ; void Reset ( ) { CryptScarabs_Timer = 3000 ; EncasingWebs_Timer = 7000 ; PierceArmor_Timer = 19000 ; RaiseUndeadScarab_Timer = 3000 ; } void EnterCombat ( Unit * ) { } void JustDied ( Unit * ) { if ( instance ) instance -> SetData ( TYPE_NERUB , IN_PROGRESS ) ; } void RaiseUndeadScarab ( Unit * victim ) { if ( Creature * pUndeadScarab = DoSpawn@@ Creature ( 10876 , float ( irand ( - 9 , 9 ) ) , float ( irand ( - 9 , 9 ) ) , 0 , 0 , TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN , 180000 ) ) if ( pUndeadScarab -> AI ( ) ) pUndeadScarab -> AI ( ) -> AttackStart ( victim ) ; } void UpdateAI ( const uint32 diff ) { if ( ! UpdateVictim ( ) ) return ; if ( EncasingWebs_Timer <= diff ) { DoCast ( me -> getVictim ( ) , SPELL_ENCASINGWEBS ) ; EncasingWebs_Timer = 30000 ; } else EncasingWebs_Timer -= diff ; if ( PierceArmor_Timer <= diff ) { if ( urand ( 0 , 3 ) < 2 ) DoCast ( me -> getVictim ( ) , SPELL_PIERCEARMOR ) ; PierceArmor_Timer = 35000 ; } else PierceArmor_Timer -= diff ; if ( CryptScarabs_Timer <= diff ) { DoCast ( me -> getVictim ( ) , SPELL_CRYPT_SCARABS ) ; CryptScarabs_Timer = 20000 ; } else CryptScarabs_Timer -= diff ; if ( RaiseUndeadScarab_Timer <= diff ) { RaiseUndeadScarab ( me -> getVictim ( ) ) ; RaiseUndeadScarab_Timer = 16000 ; } else RaiseUndeadScarab_Timer -= diff ; DoMeleeAttackIfReady ( ) ; } } ; } ; void AddSC_boss_nerubenkan ( ) { new boss_nerubenkan ( ) ; } </DOCUMENT>
<DOCUMENT_ID="Ashamane@@ Project/Ashamane@@ Core/tree/master/dep/@@ CascLib/src/CascDecomp@@ ress.cpp"> # define __CASCLIB@@ _SELF__ # include " CascLib . h " # include " CascCommon . h " DWORD CascDecompress ( LPBYTE pbOutBuffer , PDWORD pcbOutBuffer , LPBYTE pbInBuffer , DWORD cbInBuffer ) { z_stream z ; DWORD dwErrCode = ERROR_FILE_CORRUP@@ T ; uInt cbOutBuffer = * pcbOutBuffer ; int nResult ; z . next_in = pbInBuffer ; z . avail_in = cbInBuffer ; z . total_in = cbInBuffer ; z . next_out = pbOutBuffer ; z . avail_out = cbOutBuffer ; z . total_out = 0 ; z . zalloc = NULL ; z . zfree = NULL ; cbOutBuffer = 0 ; if ( ( nResult = inflateInit ( & z ) ) == Z_OK ) { nResult = inflate ( & z , Z_NO_F@@ LUSH ) ; if ( nResult == Z_OK || nResult == Z_STREAM_END ) { cbOutBuffer = z . total_out ; dwErrCode = ERROR_SUCCESS ; } inflateEnd ( & z ) ; } pcbOutBuffer [ 0 ] = cbOutBuffer ; return dwErrCode ; } </DOCUMENT>
<DOCUMENT_ID="arangodb@@ /arangodb/tree/master/3rdParty/boost/1.71.0/libs/@@ hana/@@ example/chain@@ .cpp"> # include < boost / hana / assert . hpp > # include < boost / hana / chain . hpp > # include < boost / hana / config . hpp > # include < boost / hana / equal . hpp > # include < boost / hana / optional . hpp > namespace hana = boost :: hana ; BOOST_HANA_CONSTEXPR_LAMBDA auto deref = [ ] ( auto x ) -> decltype ( * x ) { return * x ; } ; BOOST_HANA_CONSTEXPR_LAMBDA auto age = [ ] ( auto x ) -> decltype ( x . age ) { return x . age ; } ; BOOST_HANA_CONSTEXPR_LAMBDA auto f = [ ] ( auto x ) { return hana :: chain ( hana :: sfinae ( deref ) ( x ) , hana :: sfinae ( age ) ) ; } ; struct Person { unsigned int age ; } ; int main ( ) { constexpr Person john { 30 } ; BOOST_HANA_CONSTANT_CHECK ( f ( john ) == hana :: nothing ) ; BOOST_HANA_CONSTANT_CHECK ( f ( 1 ) == hana :: nothing ) ; BOOST_HANA_CONSTEXPR_CHECK ( f ( & john ) == hana :: just ( 30u ) ) ; } </DOCUMENT>
<DOCUMENT_ID="MazZz@@ inatus/storm/tree/master/src/test/@@ storm-@@ pars/utility/ModelInstantiator@@ Test.cpp"> # include " gtest / gtest . h " # include " storm - config . h " # ifdef STORM_HAVE_@@ CARL # include " storm / adapters / RationalFunctionAdapter . h " # include < carl / numbers / numbers . h > # include < carl / core / VariablePool . h > # include " storm / settings / SettingsManager . h " # include " storm / settings / modules / GeneralSettings . h " # include " storm - pars / utility / ModelInstantiator . h " # include " storm / api / storm . h " # include " storm / models / sparse / Model . h " # include " storm / models / sparse / Dtmc . h " # include " storm / models / sparse / Mdp . h " TEST ( ModelInstantiatorTest , BrpProb ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pdtmc / brp16_2 . pm " ; std :: string formulaAsString = " P = ? ▁ [ F ▁ s = 5 ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> dtmc = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Dtmc < storm :: RationalFunction > , storm :: models :: sparse :: Dtmc < double >> modelInstantiator ( * dtmc ) ; EXPECT_FALSE ( dtmc -> hasRewardModel ( ) ) ; { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.8 ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.29892@@ 7894@@ 1 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_EQ ( 0.0 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] ) ; } { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.015880@@ 55832 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } } TEST ( ModelInstantiatorTest , Brp_Rew ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pdtmc / brp16_2 . pm " ; std :: string formulaAsString = " R = ? ▁ [ F ▁ ( ( s = 5 ) ▁ | ▁ ( s = 0 & srep = 3 ) ) ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> dtmc = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Dtmc < storm :: RationalFunction > , storm :: models :: sparse :: Dtmc < double >> modelInstantiator ( * dtmc ) ; { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & TOMsg = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " TOMsg " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & TOAck = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " TOAck " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.3 ) ) ) ; valuation . insert ( std :: make_pair ( TOMsg , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.3 ) ) ) ; valuation . insert ( std :: make_pair ( TOAck , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.5 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } ASSERT_TRUE ( instantiated . hasUniqueRewardModel ( ) ) ; EXPECT_FALSE ( instantiated . getUniqueRewardModel ( ) . hasStateRewards ( ) ) ; EXPECT_FALSE ( instantiated . getUniqueRewardModel ( ) . hasTransition@@ Rewards ( ) ) ; EXPECT_TRUE ( instantiated . getUniqueRewardModel ( ) . hasStateActionRewards ( ) ) ; ASSERT_TRUE ( dtmc -> getUniqueRewardModel ( ) . hasStateActionRewards ( ) ) ; std :: size_t stateActionEntries = dtmc -> getUniqueRewardModel ( ) . getStateActionRewardVector ( ) . size ( ) ; ASSERT_EQ ( stateActionEntries , instantiated . getUniqueRewardModel ( ) . getStateActionRewardVector ( ) . size ( ) ) ; for ( std :: size_t i = 0 ; i < stateActionEntries ; ++ i ) { double evaluatedValue = carl :: toDouble ( dtmc -> getUniqueRewardModel ( ) . getStateActionRewardVector ( ) [ i ] . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiated . getUniqueRewardModel ( ) . getStateActionRewardVector ( ) [ i ] ) ; } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 1.308@@ 324495 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } } TEST ( ModelInstantiatorTest , Consensus ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pmdp / coin2_2 . nm " ; std :: string formulaAsString = " Pmin = ? ▁ [ F ▁ \ " finished\ " & \ " all _ coins _ equal _ 1\ " ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Mdp < storm :: RationalFunction >> mdp = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Mdp < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Mdp < storm :: RationalFunction > , storm :: models :: sparse :: Mdp < double >> modelInstantiator ( * mdp ) ; std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & p1 = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " p1" ) ; ASSERT_NE ( p1 , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & p2 = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " p2" ) ; ASSERT_NE ( p2 , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( p1 , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.51 ) ) ) ; valuation . insert ( std :: make_pair ( p2 , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.49 ) ) ) ; storm :: models :: sparse :: Mdp < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < mdp -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : mdp -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( mdp -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( mdp -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseMdp@@ PrctlModelChecker < storm :: models :: sparse :: Mdp < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.35265@@ 77219 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } # endif </DOCUMENT>
<DOCUMENT_ID="very@@ badsoldier/@@ xbmc/tree/master/xbmc/visualization@@ s/Vor@@ tex/angelscript/angelscript/source/as_scriptengine@@ .cpp"> # include < stdlib . h > # include " as _ config . h " # include " as _ scriptengine . h " # include " as _ builder . h " # include " as _ context . h " # include " as _ string _ util . h " # include " as _ tokenizer . h " # include " as _ texts . h " # include " as _ module . h " # include " as _ callfunc . h " # include " as _ arrayobject . h " # include " as _ generic . h " # include " as _ scriptobject . h " # include " as _ compiler . h " BEGIN_AS_NAMESPACE extern " C " { AS_API const char * asGetLibraryVersion ( ) { # ifdef _DEBUG return ANGELSCRIPT_VERSION_STRING " ▁ DEBUG " ; # else return ANGELSCRIPT_VERSION_STRING ; # endif } AS_API const char * asGetLibraryOptions ( ) { const char * string = " ▁ " # ifdef AS_MAX_PORTABILITY " AS _ MAX _ PORTABILITY ▁ " # endif # ifdef AS_DEBUG " AS _ DEBUG ▁ " # endif # ifdef AS_NO_CLASS_METHODS " AS _ NO _ CLASS _ METHODS ▁ " # endif # ifdef AS_USE_@@ DOUBLE_AS_FLOAT " AS _ USE _ DOUBLE _ AS _ FLOAT ▁ " # endif # ifdef AS_64BIT_@@ PTR " AS _ 64BIT _ PTR ▁ " # endif # ifdef AS_NO_@@ THREADS " AS _ NO _ THREADS ▁ " # endif # ifdef AS_NO_AT@@ OMIC " AS _ NO _ ATOMIC ▁ " # endif # ifdef AS_WIN " AS _ WIN ▁ " # endif # ifdef AS_LINUX " AS _ LINUX ▁ " # endif # ifdef AS_MAC " AS _ MAC ▁ " # endif # ifdef AS_BSD " AS _ BSD ▁ " # endif # ifdef AS_XBOX " AS _ XBOX ▁ " # endif # ifdef AS_XBOX360 " AS _ XBOX360 ▁ " # endif # ifdef AS_PSP " AS _ PSP ▁ " # endif # ifdef AS_PS2 " AS _ PS2 ▁ " # endif # ifdef AS_PS3 " AS _ PS3 ▁ " # endif # ifdef AS_DC " AS _ DC ▁ " # endif # ifdef AS_GC " AS _ GC ▁ " # endif # ifdef AS_WII " AS _ WII ▁ " # endif # ifdef AS_IPHONE " AS _ IPHONE ▁ " # endif # ifdef AS_ANDROID " AS _ ANDROID ▁ " # endif # ifdef AS_PPC " AS _ PPC ▁ " # endif # ifdef AS_PPC_@@ 64 " AS _ PPC _ 64 ▁ " # endif # ifdef AS_X86 " AS _ X86 ▁ " # endif # ifdef AS_MIPS " AS _ MIPS ▁ " # endif # ifdef AS_SH4 " AS _ SH4 ▁ " # endif # ifdef AS_XENON " AS _ XENON ▁ " # endif # ifdef AS_ARM " AS _ ARM ▁ " # endif ; return string ; } AS_API asIScriptEngine * asCreateScriptEngine ( asDWORD version ) { if ( ( version / 10000 ) != ( ANGELSCRIPT_VERSION / 10000 ) ) return 0 ; if ( ( version / 100 ) % 100 != ( ANGELSCRIPT_VERSION / 100 ) % 100 ) return 0 ; if ( ( version % 100 ) > ( ANGELSCRIPT_VERSION % 100 ) ) return 0 ; asASSERT ( sizeof ( asBYTE ) == 1 ) ; asASSERT ( sizeof ( asWORD ) == 2 ) ; asASSERT ( sizeof ( asDWORD ) == 4 ) ; asASSERT ( sizeof ( asQWORD ) == 8 ) ; asASSERT ( sizeof ( asPWORD ) == sizeof ( void * ) ) ; asASSERT ( sizeof ( bool ) == AS_SIZEOF_BOOL ) ; asASSERT ( true == VALUE_OF_BOO@@ LEAN_@@ TRUE ) ; # ifdef AS_BIG_@@ ENDIAN asASSERT ( * ( asDWORD * ) " \x00\x01\x02\x03" == 0x00010203 ) ; asASSERT ( * ( asQWORD * ) " \x00\x01\x02\x03\x04\x05\x06\x07" == I64 ( 0x00010203040@@ 50607 ) ) ; # else asASSERT ( * ( asDWORD * ) " \x00\x01\x02\x03" == 0x03020100 ) ; asASSERT ( * ( asQWORD * ) " \x00\x01\x02\x03\x04\x05\x06\x07" == I64 ( 0x070605040@@ 3020100 ) ) ; # endif return asNEW ( asCScriptEngine ) ( ) ; } int asCScriptEngine :: SetEngineProperty ( asEEngineProp property , asPWORD value ) { switch ( property ) { case asEP_ALLOW_UNSAFE_REFERENCES : ep . allowUnsafeReferences = value ? true : false ; break ; case asEP_OPTIMIZE_BYTECODE : ep . optimizeByteCode = value ? true : false ; break ; case asEP_COPY_SCRIPT_SECTIONS : ep . copyScriptSections = value ? true : false ; break ; case asEP_MAX_STACK_SIZE : ep . maximumContextStackSize = ( int ) value / 4 ; if ( initialContextStackSize > ep . maximumContextStackSize ) initialContextStackSize = ep . maximumContextStackSize ; break ; case asEP_USE_CHARACTER_LITERALS : ep . useCharacterLiterals = value ? true : false ; break ; case asEP_ALLOW_MULTILINE_STRINGS : ep . allowMultilineStrings = value ? true : false ; break ; case asEP_ALLOW_IMPLICIT_HANDLE_TYPES : ep . allowImplicitHandleTypes = value ? true : false ; break ; case asEP_BUILD_WITHOUT_LINE_CUES : ep . buildWithoutLineCues = value ? true : false ; break ; case asEP_INIT_GLOBAL_VARS_AFTER_BUILD : ep . initGlobalVarsAfterBuild = value ? true : false ; break ; case asEP_REQUIRE_ENUM_SCOPE : ep . requireEnumScope = value ? true : false ; break ; case asEP_SCRIPT_SCANNER : if ( value <= 1 ) ep . scanner = ( int ) value ; else return asINVALID_ARG ; break ; case asEP_INCLUDE_JIT_INSTRUCTIONS : ep . includeJitInstructions = value ? true : false ; break ; case asEP_STRING_ENCODING : if ( value <= 1 ) ep . stringEncoding = ( int ) value ; else return asINVALID_ARG ; break ; default : return asINVALID_ARG ; } return asSUCCESS ; } asPWORD asCScriptEngine :: GetEngineProperty ( asEEngineProp property ) { switch ( property ) { case asEP_ALLOW_UNSAFE_REFERENCES : return ep . allowUnsafeReferences ; case asEP_OPTIMIZE_BYTECODE : return ep . optimizeByteCode ; case asEP_COPY_SCRIPT_SECTIONS : return ep . copyScriptSections ; case asEP_MAX_STACK_SIZE : return ep . maximumContextStackSize * 4 ; case asEP_USE_CHARACTER_LITERALS : return ep . useCharacterLiterals ; case asEP_ALLOW_MULTILINE_STRINGS : return ep . allowMultilineStrings ; case asEP_ALLOW_IMPLICIT_HANDLE_TYPES : return ep . allowImplicitHandleTypes ; case asEP_BUILD_WITHOUT_LINE_CUES : return ep . buildWithoutLineCues ; case asEP_INIT_GLOBAL_VARS_AFTER_BUILD : return ep . initGlobalVarsAfterBuild ; case asEP_REQUIRE_ENUM_SCOPE : return ep . requireEnumScope ; case asEP_SCRIPT_SCANNER : return ep . scanner ; case asEP_INCLUDE_JIT_INSTRUCTIONS : return ep . includeJitInstructions ; case asEP_STRING_ENCODING : return ep . stringEncoding ; } return 0 ; } } asCScriptEngine :: asCScriptEngine ( ) { if ( threadManager == 0 ) threadManager = asNEW ( asCThread@@ Manager ) ; else threadManager -> AddRef ( ) ; ep . allowUnsafeReferences = false ; ep . optimizeByteCode = true ; ep . copyScriptSections = true ; ep . maximumContextStackSize = 0 ; ep . useCharacterLiterals = false ; ep . allowMultilineStrings = false ; ep . allowImplicitHandleTypes = false ; ep . buildWithoutLineCues = false ; ep . initGlobalVarsAfterBuild = true ; ep . requireEnumScope = false ; ep . scanner = 1 ; ep . includeJitInstructions = false ; ep . stringEncoding = 0 ; gc . engine = this ; refCount . set ( 1 ) ; stringFactory = 0 ; configFailed = false ; isPrepared = false ; isBuilding = false ; lastModule = 0 ; userData = 0 ; initialContextStackSize = 1024 ; typeIdSeqNbr = 0 ; currentGroup = & defaultGroup ; msgCallback = 0 ; jitCompiler = 0 ; scriptFunctions . PushLast ( 0 ) ; int id ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttVoid , false ) ) ; asASSERT ( id == asTYPEID_VOID ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttBool , false ) ) ; asASSERT ( id == asTYPEID_BOOL ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt8 , false ) ) ; asASSERT ( id == asTYPEID_INT8 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt16 , false ) ) ; asASSERT ( id == asTYPEID_INT16 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt , false ) ) ; asASSERT ( id == asTYPEID_INT32 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt64 , false ) ) ; asASSERT ( id == asTYPEID_INT64 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt8 , false ) ) ; asASSERT ( id == asTYPEID_UINT8 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt16 , false ) ) ; asASSERT ( id == asTYPEID_UINT16 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt , false ) ) ; asASSERT ( id == asTYPEID_UINT32 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt64 , false ) ) ; asASSERT ( id == asTYPEID_UINT64 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttFloat , false ) ) ; asASSERT ( id == asTYPEID_FLOAT ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttDouble , false ) ) ; asASSERT ( id == asTYPEID_DOUBLE ) ; defaultArrayObjectType = 0 ; RegisterArrayObject ( this ) ; RegisterScriptObject ( this ) ; RegisterScriptFunction ( this ) ; RegisterObjectTypeGC@@ Behaviours ( this ) ; } asCScriptEngine :: ~ asCScriptEngine ( ) { asASSERT ( refCount . get ( ) == 0 ) ; asUINT n ; for ( n = ( asUINT ) scriptModules . GetLength ( ) ; n -- > 0 ; ) { if ( scriptModules [ n ] ) { asDELETE ( scriptModules [ n ] , asCModule ) ; } } scriptModules . SetLength ( 0 ) ; GarbageCollect ( asGC_FULL_CYCLE ) ; for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] ) { asUINT f ; for ( f = 0 ; f < templateTypes [ n ] -> beh . factories . GetLength ( ) ; f ++ ) { scriptFunctions [ templateTypes [ n ] -> beh . factories [ f ] ] -> Release ( ) ; } templateTypes [ n ] -> beh . factories . Allocate ( 0 , false ) ; for ( f = 1 ; f < templateTypes [ n ] -> beh . operators . GetLength ( ) ; f += 2 ) { if ( scriptFunctions [ templateTypes [ n ] -> beh . operators [ f ] ] -> objectType == templateTypes [ n ] ) { scriptFunctions [ templateTypes [ n ] -> beh . operators [ f ] ] -> Release ( ) ; templateTypes [ n ] -> beh . operators [ f ] = 0 ; } } } } GarbageCollect ( asGC_FULL_CYCLE ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; for ( n = 0 ; n < classTypes . GetLength ( ) ; n ++ ) { if ( classTypes [ n ] ) classTypes [ n ] -> ReleaseAllFunctions ( ) ; if ( classTypes [ n ] -> derivedFrom ) { classTypes [ n ] -> derivedFrom -> Release ( ) ; classTypes [ n ] -> derivedFrom = 0 ; } } GarbageCollect ( asGC_FULL_CYCLE ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; asSMapNode < int , asCDataType * > * cursor = 0 ; while ( mapTypeIdToDataType . MoveFirst ( & cursor ) ) { asDELETE ( mapTypeIdToDataType . GetValue ( cursor ) , asCDataType ) ; mapTypeIdToDataType . Erase ( cursor ) ; } defaultGroup . RemoveConfiguration ( this ) ; while ( configGroups . GetLength ( ) ) { asCConfigGroup * grp = configGroups . PopLast ( ) ; if ( grp ) { asDELETE ( grp , asCConfigGroup ) ; } } for ( n = 0 ; n < registeredGlobalProps . GetLength ( ) ; n ++ ) { if ( registeredGlobalProps [ n ] ) { asDELETE ( registeredGlobalProps [ n ] , asCGlobalProperty ) ; } } registeredGlobalProps . SetLength ( 0 ) ; FreeUnusedGlobalProperties ( ) ; for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] ) { templateTypes [ n ] -> templateSubType = asCDataType :: CreateNullHandle ( ) ; asDELETE ( templateTypes [ n ] , asCObjectType ) ; } } templateTypes . SetLength ( 0 ) ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] ) { objectTypes [ n ] -> templateSubType = asCDataType :: CreateNullHandle ( ) ; asDELETE ( objectTypes [ n ] , asCObjectType ) ; } } objectTypes . SetLength ( 0 ) ; for ( n = 0 ; n < templateSubTypes . GetLength ( ) ; n ++ ) { if ( templateSubTypes [ n ] ) { asDELETE ( templateSubTypes [ n ] , asCObjectType ) ; } } templateSubTypes . SetLength ( 0 ) ; registeredTypeDefs . SetLength ( 0 ) ; registeredEnums . SetLength ( 0 ) ; registeredObjTypes . SetLength ( 0 ) ; for ( n = 0 ; n < registeredGlobalFuncs . GetLength ( ) ; n ++ ) { if ( registeredGlobalFuncs [ n ] ) registeredGlobalFuncs [ n ] -> Release ( ) ; } registeredGlobalFuncs . SetLength ( 0 ) ; scriptTypeBehaviours . ReleaseAllFunctions ( ) ; functionBehaviours . ReleaseAllFunctions ( ) ; objectTypeBehaviours . ReleaseAllFunctions ( ) ; for ( n = 0 ; n < stringConstants . GetLength ( ) ; n ++ ) { asDELETE ( stringConstants [ n ] , asCString ) ; } stringConstants . SetLength ( 0 ) ; for ( n = 0 ; n < scriptSectionNames . GetLength ( ) ; n ++ ) { asDELETE ( scriptSectionNames [ n ] , asCString ) ; } scriptSectionNames . SetLength ( 0 ) ; threadManager -> Release ( ) ; } int asCScriptEngine :: AddRef ( ) { return refCount . atomicInc ( ) ; } int asCScriptEngine :: Release ( ) { int r = refCount . atomicDec ( ) ; if ( r == 0 ) { asDELETE ( this , asCScriptEngine ) ; return 0 ; } return r ; } void * asCScriptEngine :: SetUserData ( void * data ) { void * old = userData ; userData = data ; return old ; } void * asCScriptEngine :: GetUserData ( ) { return userData ; } int asCScriptEngine :: SetMessageCallback ( const asSFuncPtr & callback , void * obj , asDWORD callConv ) { msgCallback = true ; msgCallbackObj = obj ; bool isObj = false ; if ( ( unsigned ) callConv == asCALL_GENERIC ) { msgCallback = false ; return asNOT_SUPPORTED ; } if ( ( unsigned ) callConv >= asCALL_THISCALL ) { isObj = true ; if ( obj == 0 ) { msgCallback = false ; return asINVALID_ARG ; } } int r = DetectCallingConvention ( isObj , callback , callConv , & msgCallbackFunc ) ; if ( r < 0 ) msgCallback = false ; return r ; } int asCScriptEngine :: ClearMessageCallback ( ) { msgCallback = false ; return 0 ; } int asCScriptEngine :: WriteMessage ( const char * section , int row , int col , asEMsg@@ Type type , const char * message ) { if ( section == 0 || message == 0 ) return asINVALID_ARG ; if ( ! msgCallback ) return 0 ; asSMessageInfo msg ; msg . section = section ; msg . row = row ; msg . col = col ; msg . type = type ; msg . message = message ; if ( msgCallbackFunc . callConv < ICC_THISCALL ) CallGlobalFunction ( & msg , msgCallbackObj , & msgCallbackFunc , 0 ) ; else CallObjectMethod ( msgCallbackObj , & msg , & msgCallbackFunc , 0 ) ; return 0 ; } int asCScriptEngine :: SetJITCompiler ( asIJITCompiler * compiler ) { jitCompiler = compiler ; return asSUCCESS ; } asIJITCompiler * asCScriptEngine :: GetJITCompiler ( ) { return jitCompiler ; } asETokenClass asCScriptEngine :: ParseToken ( const char * string , size_t stringLength , int * tokenLength ) { if ( stringLength == 0 ) stringLength = strlen ( string ) ; size_t len ; asCTokenizer t ; asETokenClass tc ; t . GetToken ( string , stringLength , & len , & tc ) ; if ( tokenLength ) * tokenLength = ( int ) len ; return tc ; } asIScriptModule * asCScriptEngine :: GetModule ( const char * module , asEGMFlags flag ) { asCModule * mod = GetModule ( module , false ) ; if ( flag == asGM_ALWAY@@ S_CREATE ) { if ( mod != 0 ) { asDELETE ( mod , asCModule ) ; } return GetModule ( module , true ) ; } if ( mod == 0 && flag == asGM_CREATE_IF_NOT_@@ EXISTS ) { return GetModule ( module , true ) ; } return mod ; } int asCScriptEngine :: Discard@@ Module ( const char * module ) { asCModule * mod = GetModule ( module , false ) ; if ( mod == 0 ) return asNO_MODULE ; asDELETE ( mod , asCModule ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; return 0 ; } void asCScriptEngine :: ClearUnusedTypes ( ) { asCArray < asCObjectType * > types ; types = classTypes ; types . Concatenate ( templateInstanceTypes ) ; asUINT n ; for ( n = 0 ; n < scriptModules . GetLength ( ) && types . GetLength ( ) ; n ++ ) { asCModule * mod = scriptModules [ n ] ; if ( mod ) { asUINT m ; for ( m = 0 ; m < mod -> classTypes . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> classTypes [ m ] ) ; for ( m = 0 ; m < mod -> enumTypes . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> enumTypes [ m ] ) ; for ( m = 0 ; m < mod -> typeDefs . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> typeDefs [ m ] ) ; } } for ( n = 0 ; n < scriptFunctions . GetLength ( ) && types . GetLength ( ) ; n ++ ) { asCScriptFunction * func = scriptFunctions [ n ] ; if ( func ) { if ( func -> name == " factstub " ) continue ; asCObjectType * ot = func -> returnType . GetObjectType ( ) ; if ( ot != 0 && ot != func -> objectType ) if ( func -> name != ot -> name ) RemoveTypeAndRelatedFromList ( types , ot ) ; for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { ot = func -> parameterTypes [ p ] . GetObjectType ( ) ; if ( ot != 0 && ot != func -> objectType ) if ( func -> name != ot -> name ) RemoveTypeAndRelatedFromList ( types , ot ) ; } } } for ( n = 0 ; n < globalProperties . GetLength ( ) && types . GetLength ( ) ; n ++ ) { if ( globalProperties [ n ] && globalProperties [ n ] -> type . GetObjectType ( ) ) RemoveTypeAndRelatedFromList ( types , globalProperties [ n ] -> type . GetObjectType ( ) ) ; } for ( ; ; ) { bool didClearTemplateInstanceType = false ; for ( n = 0 ; n < types . GetLength ( ) ; n ++ ) { int refCount = ( ( types [ n ] -> flags & asOBJ_TEMPLATE ) || ( types [ n ] -> flags & asOBJ_SCRIPT_OBJECT ) ) ? 2 * ( int ) types [ n ] -> beh . factories . GetLength ( ) : 0 ; if ( types [ n ] -> GetRefCount ( ) == refCount ) { if ( types [ n ] -> flags & asOBJ_TEMPLATE ) { didClearTemplateInstanceType = true ; RemoveTemplateInstanceType ( types [ n ] ) ; } else { RemoveFromTypeIdMap ( types [ n ] ) ; asDELETE ( types [ n ] , asCObjectType ) ; int i = classTypes . IndexOf ( types [ n ] ) ; if ( i == ( signed ) classTypes . GetLength ( ) - 1 ) classTypes . PopLast ( ) ; else classTypes [ i ] = classTypes . PopLast ( ) ; } if ( n < types . GetLength ( ) - 1 ) types [ n ] = types . PopLast ( ) ; else types . PopLast ( ) ; n -- ; } } if ( didClearTemplateInstanceType == false ) break ; } } void asCScriptEngine :: RemoveTypeAndRelatedFromList ( asCArray < asCObjectType * > & types , asCObjectType * ot ) { int i = types . IndexOf ( ot ) ; if ( i == - 1 ) return ; if ( i == ( signed ) types . GetLength ( ) - 1 ) types . PopLast ( ) ; else types [ i ] = types . PopLast ( ) ; if ( ot -> templateSubType . GetObjectType ( ) ) { while ( ot -> templateSubType . GetObjectType ( ) ) { ot = ot -> templateSubType . GetObjectType ( ) ; RemoveTypeAndRelatedFromList ( types , ot ) ; } return ; } if ( ot -> properties . GetLength ( ) ) { for ( asUINT n = 0 ; n < ot -> properties . GetLength ( ) ; n ++ ) RemoveTypeAndRelatedFromList ( types , ot -> properties [ n ] -> type . GetObjectType ( ) ) ; } } int asCScriptEngine :: GetFactoryIdByDecl ( const asCObjectType * ot , const char * decl ) { asCModule * mod = 0 ; if ( ot -> flags & asOBJ_SCRIPT_OBJECT && ot -> size > 0 ) mod = scriptFunctions [ ot -> beh . factory ] -> module ; asCBuilder bld ( this , mod ) ; asCScriptFunction func ( this , mod , - 1 ) ; int r = bld . ParseFunctionDeclaration ( 0 , decl , & func , false ) ; if ( r < 0 ) return asINVALID_DECLARATION ; int id = - 1 ; for ( size_t n = 0 ; n < ot -> beh . factories . GetLength ( ) ; n ++ ) { asCScriptFunction * f = scriptFunctions [ ot -> beh . factories [ n ] ] ; if ( f -> IsSignatureEqual ( & func ) ) { id = ot -> beh . factories [ n ] ; break ; } } if ( id == - 1 ) return asNO_FUNCTION ; return id ; } int asCScriptEngine :: GetMethodIdByDecl ( const asCObjectType * ot , const char * decl , asCModule * mod ) { asCBuilder bld ( this , mod ) ; asCScriptFunction func ( this , mod , - 1 ) ; int r = bld . ParseFunctionDeclaration ( 0 , decl , & func , false ) ; if ( r < 0 ) return asINVALID_DECLARATION ; func . objectType = const_cast < asCObjectType * > ( ot ) ; int id = - 1 ; for ( size_t n = 0 ; n < ot -> methods . GetLength ( ) ; ++ n ) { if ( func . IsSignatureEqual ( scriptFunctions [ ot -> methods [ n ] ] ) ) { if ( id == - 1 ) id = ot -> methods [ n ] ; else return asMULTIPLE_FUNCTIONS ; } } if ( id == - 1 ) return asNO_FUNCTION ; return id ; } asCString asCScriptEngine :: GetFunctionDeclaration ( int funcID ) { asCString str ; asCScriptFunction * func = GetScriptFunction ( funcID ) ; if ( func ) str = func -> GetDeclarationStr ( ) ; return str ; } asCScriptFunction * asCScriptEngine :: GetScriptFunction ( int funcId ) { if ( funcId < 0 || funcId >= ( int ) scriptFunctions . GetLength ( ) ) return 0 ; return scriptFunctions [ funcId ] ; } asIScriptContext * asCScriptEngine :: CreateContext ( ) { asIScriptContext * ctx = 0 ; CreateContext ( & ctx , false ) ; return ctx ; } int asCScriptEngine :: CreateContext ( asIScriptContext * * context , bool isInternal ) { * context = asNEW ( asCContext ) ( this , ! isInternal ) ; PrepareEngine ( ) ; return 0 ; } int asCScriptEngine :: RegisterObjectProperty ( const char * obj , const char * declaration , int byteOffset ) { int r ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; r = bld . ParseDataType ( obj , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( currentGroup -> FindType ( dt . GetObjectType ( ) -> name . AddressOf ( ) ) == 0 ) return ConfigError ( asWRONG_CONFIG_GROUP ) ; asCDataType type ; asCString name ; if ( ( r = bld . VerifyProperty ( & dt , declaration , name , type ) ) < 0 ) return ConfigError ( r ) ; if ( dt . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_OBJECT ) ; asCObjectProperty * prop = asNEW ( asCObjectProperty ) ; prop -> name = name ; prop -> type = type ; prop -> byteOffset = byteOffset ; dt . GetObjectType ( ) -> properties . PushLast ( prop ) ; currentGroup -> RefConfigGroup ( FindConfigGroupForObjectType ( type . GetObjectType ( ) ) ) ; return asSUCCESS ; } int asCScriptEngine :: RegisterInterface ( const char * name ) { if ( name == 0 ) return ConfigError ( asINVALID_NAME ) ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) return asALREADY_REGISTERED ; } asCDataType dt ; asCBuilder bld ( this , 0 ) ; bool oldMsgCallback = msgCallback ; msgCallback = false ; int r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; if ( r >= 0 ) return ConfigError ( asERROR ) ; asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , strlen ( name ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( name ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * st = asNEW ( asCObjectType ) ( this ) ; st -> flags = asOBJ_REF | asOBJ_SCRIPT_OBJECT ; st -> size = 0 ; st -> name = name ; st -> beh . factory = 0 ; st -> beh . addref = scriptTypeBehaviours . beh . addref ; scriptFunctions [ st -> beh . addref ] -> AddRef ( ) ; st -> beh . release = scriptTypeBehaviours . beh . release ; scriptFunctions [ st -> beh . release ] -> AddRef ( ) ; st -> beh . copy = 0 ; objectTypes . PushLast ( st ) ; registeredObjTypes . PushLast ( st ) ; currentGroup -> objTypes . PushLast ( st ) ; return asSUCCESS ; } int asCScriptEngine :: RegisterInterface@@ Method ( const char * intf , const char * declaration ) { if ( currentGroup -> FindType ( intf ) == 0 ) return ConfigError ( asWRONG_CONFIG_GROUP ) ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( intf , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_INTERFACE ) ; func -> objectType = dt . GetObjectType ( ) ; r = bld . ParseFunctionDeclaration ( func -> objectType , declaration , func , false ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } r = bld . CheckNameConflictMember ( dt , func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; func -> objectType -> methods . PushLast ( func -> id ) ; func -> ComputeSignature@@ Id ( ) ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } return func -> id ; } int asCScriptEngine :: RegisterObjectType ( const char * name , int byteSize , asDWORD flags ) { int r ; isPrepared = false ; if ( flags & asOBJ_REF ) { if ( flags & ~ ( asOBJ_REF | asOBJ_GC | asOBJ_NOHANDLE | asOBJ_SCOPED | asOBJ_TEMPLATE ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_GC ) && ( flags & ( asOBJ_NOHANDLE | asOBJ_SCOPED ) ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_NOHANDLE ) && ( flags & ( asOBJ_GC | asOBJ_SCOPED ) ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_SCOPED ) && ( flags & ( asOBJ_GC | asOBJ_NOHANDLE ) ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_VALUE ) { if ( flags & ( asOBJ_REF | asOBJ_GC | asOBJ_SCOPED ) ) return ConfigError ( asINVALID_ARG ) ; if ( flags & asOBJ_APP_CLASS ) { if ( flags & ( asOBJ_APP_PRIMITIVE | asOBJ_APP_FLOAT ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_APP_PRIMITIVE ) { if ( flags & ( asOBJ_APP_CLASS | asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT | asOBJ_APP_FLOAT ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_APP_FLOAT ) { if ( flags & ( asOBJ_APP_CLASS | asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT | asOBJ_APP_PRIMITIVE ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & ( asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT ) ) { return ConfigError ( asINVALID_ARG ) ; } } else return ConfigError ( asINVALID_ARG ) ; if ( flags - ( flags & asOBJ_MAS@@ K_VAL@@ ID_FLAGS ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_VALUE ) && byteSize == 0 ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_VALUE_@@ TYPE_MUS@@ T_HAVE_SIZE ) ; return ConfigError ( asINVALID_ARG ) ; } if ( name == 0 ) return ConfigError ( asINVALID_NAME ) ; asCString typeName ; asCBuilder bld ( this , 0 ) ; if ( flags & asOBJ_TEMPLATE ) { asCString subtypeName ; r = bld . ParseTemplate@@ Decl ( name , & typeName , & subtypeName ) ; if ( r < 0 ) return r ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = typeName ; type -> size = byteSize ; type -> flags = flags ; objectTypes . PushLast ( type ) ; asCObjectType * subtype = 0 ; for ( n = 0 ; n < templateSubTypes . GetLength ( ) ; n ++ ) { if ( templateSubTypes [ n ] -> name == subtypeName ) { subtype = templateSubTypes [ n ] ; break ; } } if ( subtype == 0 ) { subtype = asNEW ( asCObjectType ) ( this ) ; subtype -> name = subtypeName ; subtype -> size = 0 ; subtype -> flags = asOBJ_TEMPLATE_SUB@@ TYPE ; templateSubTypes . PushLast ( subtype ) ; subtype -> AddRef ( ) ; } type -> templateSubType = asCDataType :: CreateObject ( subtype , false ) ; subtype -> AddRef ( ) ; currentGroup -> objTypes . PushLast ( type ) ; if ( defaultArrayObjectType == 0 ) { defaultArrayObjectType = type ; type -> AddRef ( ) ; } else { registeredObjTypes . PushLast ( type ) ; } } else { typeName = name ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] && templateTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } asCObjectType * mostRecentTemplateInstanceType = 0 ; if ( templateInstanceTypes . GetLength ( ) ) mostRecentTemplateInstanceType = templateInstanceTypes [ templateInstanceTypes . GetLength ( ) - 1 ] ; asCDataType dt ; bool oldMsgCallback = msgCallback ; msgCallback = false ; r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; if ( r < 0 ) { asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , typeName . GetLength ( ) , & tokenLen ) ; if ( token != ttIdentifier || typeName . GetLength ( ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; int r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = typeName ; type -> size = byteSize ; type -> flags = flags ; objectTypes . PushLast ( type ) ; registeredObjTypes . PushLast ( type ) ; currentGroup -> objTypes . PushLast ( type ) ; } else { if ( dt . GetSubType ( ) . IsTemplate ( ) ) return ConfigError ( asLOWER_ARRAY_@@ DIMEN@@ SION_NOT_REGISTERED ) ; if ( dt . IsReadOnly ( ) || dt . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; if ( templateInstanceTypes [ templateInstanceTypes . GetLength ( ) - 1 ] == mostRecentTemplateInstanceType || mostRecentTemplateInstanceType == dt . GetObjectType ( ) ) return ConfigError ( asNOT_SUPPORTED ) ; asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = dt . GetObjectType ( ) -> name ; type -> templateSubType = dt . GetSubType ( ) ; if ( type -> templateSubType . GetObjectType ( ) ) type -> templateSubType . GetObjectType ( ) -> AddRef ( ) ; type -> size = byteSize ; type -> flags = flags ; templateTypes . PushLast ( type ) ; currentGroup -> objTypes . PushLast ( type ) ; RemoveTemplateInstanceType ( dt . GetObjectType ( ) ) ; } } return asSUCCESS ; } int asCScriptEngine :: RegisterObjectBehaviour ( const char * datatype , asEBehaviours behaviour , const char * decl , const asSFuncPtr & funcPointer , asDWORD callConv ) { if ( datatype == 0 ) return ConfigError ( asINVALID_ARG ) ; asCBuilder bld ( this , 0 ) ; asCDataType type ; int r = bld . ParseDataType ( datatype , & type ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( type . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_TYPE ) ; if ( type . IsReadOnly ( ) || type . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; return RegisterBehaviourToObjectType ( type . GetObjectType ( ) , behaviour , decl , funcPointer , callConv ) ; } int asCScriptEngine :: RegisterBehaviourToObjectType ( asCObjectType * objectType , asEBehaviours behaviour , const char * decl , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; if ( behaviour == asBEHAVE_FACTORY || behaviour == asBEHAVE_TEMPLATE_CALLBACK ) { # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; } else { # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # else if ( callConv != asCALL_THISCALL && callConv != asCALL_CDECL_OBJLAST && callConv != asCALL_CDECL_OBJFIRST && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif int r = DetectCallingConvention ( true , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; } isPrepared = false ; asSTypeBehaviour * beh = & objectType -> beh ; asCScriptFunction func ( this , 0 , - 1 ) ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseFunctionDeclaration ( objectType , decl , & func , true , & internal . paramAutoHandles , & internal . returnAutoHandle ) ; if ( r < 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . name . Format ( " _ beh _ % d _ " , behaviour ) ; if ( behaviour != asBEHAVE_FACTORY ) func . objectType = objectType ; if ( objectType -> flags & asOBJ_TEMPLATE ) { if ( func . returnType . GetObjectType ( ) == objectType -> templateSubType . GetObjectType ( ) ) { if ( func . returnType . IsObjectHandle ( ) ) objectType -> acceptValueSubType = false ; else if ( ! func . returnType . IsReference ( ) ) objectType -> acceptRefSubType = false ; } for ( asUINT n = 0 ; n < func . parameterTypes . GetLength ( ) ; n ++ ) { if ( func . parameterTypes [ n ] . GetObjectType ( ) == objectType -> templateSubType . GetObjectType ( ) ) { if ( func . parameterTypes [ n ] . IsObjectHandle ( ) || ( func . parameterTypes [ n ] . IsReference ( ) && func . inOutFlags [ n ] == asTM_INOUTREF ) ) objectType -> acceptValueSubType = false ; else if ( ! func . parameterTypes [ n ] . IsReference ( ) ) objectType -> acceptRefSubType = false ; } } } if ( behaviour == asBEHAVE_CONSTR@@ UCT ) { if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( objectType -> flags & asOBJ_SCRIPT_OBJECT ) { asASSERT ( func . parameterTypes . GetLength ( ) == 1 ) ; beh -> construct = AddBehaviourFunction ( func , internal ) ; beh -> factory = beh -> construct ; scriptFunctions [ beh -> factory ] -> AddRef ( ) ; beh -> constructors . PushLast ( beh -> construct ) ; beh -> factories . PushLast ( beh -> factory ) ; func . id = beh -> construct ; } else { if ( ! ( func . objectType -> flags & asOBJ_VALUE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( func . parameterTypes . GetLength ( ) == 0 ) { func . id = beh -> construct = AddBehaviourFunction ( func , internal ) ; beh -> constructors . PushLast ( beh -> construct ) ; } else { func . id = AddBehaviourFunction ( func , internal ) ; beh -> constructors . PushLast ( func . id ) ; } } } else if ( behaviour == asBEHAVE_DESTR@@ UCT ) { if ( ! ( func . objectType -> flags & asOBJ_VALUE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> destruct ) return ConfigError ( asALREADY_REGISTERED ) ; if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> destruct = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_FACTORY ) { if ( ! ( objectType -> flags & asOBJ_REF ) || ( objectType -> flags & asOBJ_NOHANDLE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( func . returnType != asCDataType :: CreateObjectHandle ( objectType , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ( objectType -> flags & asOBJ_TEMPLATE ) && ( func . parameterTypes . GetLength ( ) == 0 || ! func . parameterTypes [ 0 ] . IsReference ( ) ) ) { return ConfigError ( asINVALID_DECLARATION ) ; } if ( ( func . parameterTypes . GetLength ( ) == 0 ) || ( func . parameterTypes . GetLength ( ) == 1 && ( objectType -> flags & asOBJ_TEMPLATE ) ) ) { func . id = beh -> factory = AddBehaviourFunction ( func , internal ) ; beh -> factories . PushLast ( beh -> factory ) ; } else { func . id = AddBehaviourFunction ( func , internal ) ; beh -> factories . PushLast ( func . id ) ; } } else if ( behaviour == asBEHAVE_ADDREF ) { if ( ! ( func . objectType -> flags & asOBJ_REF ) || ( func . objectType -> flags & asOBJ_NOHANDLE ) || ( func . objectType -> flags & asOBJ_SCOPED ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> addref ) return ConfigError ( asALREADY_REGISTERED ) ; if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> addref = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_RELEASE ) { if ( ! ( func . objectType -> flags & asOBJ_REF ) || ( func . objectType -> flags & asOBJ_NOHANDLE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> release ) return ConfigError ( asALREADY_REGISTERED ) ; if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> release = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_TEMPLATE_CALLBACK ) { if ( ! ( func . objectType -> flags & asOBJ_TEMPLATE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> templateCallback ) return ConfigError ( asALREADY_REGISTERED ) ; if ( func . returnType != asCDataType :: CreatePrimitive ( ttBool , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> templateCallback = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_INDEX ) { if ( VerifyVarTypeNotInFunction ( & func ) < 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . returnType . GetTokenType ( ) == ttVoid ) return ConfigError ( asINVALID_DECLARATION ) ; beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else if ( behaviour >= asBEHAVE_FIRST_@@ GC && behaviour <= asBEHAVE_LAST_GC ) { if ( ! ( func . objectType -> flags & asOBJ_GC ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( ( behaviour == asBEHAVE_GETREFCOUNT || behaviour == asBEHAVE_SETGCFLAG || behaviour == asBEHAVE_GETGCFLAG ) && func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ( behaviour == asBEHAVE_ENUMREFS || behaviour == asBEHAVE_RELEASEREFS ) && func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( behaviour == asBEHAVE_GETREFCOUNT && func . returnType != asCDataType :: CreatePrimitive ( ttInt , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( behaviour == asBEHAVE_GETGCFLAG && func . returnType != asCDataType :: CreatePrimitive ( ttBool , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ( behaviour == asBEHAVE_SETGCFLAG || behaviour == asBEHAVE_ENUMREFS || behaviour == asBEHAVE_RELEASEREFS ) && func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( behaviour == asBEHAVE_GETREFCOUNT ) func . id = beh -> gcGetRefCount = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_SETGCFLAG ) func . id = beh -> gcSetFlag = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_GETGCFLAG ) func . id = beh -> gcGetFlag = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_ENUMREFS ) func . id = beh -> gcEnumReferences = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_RELEASEREFS ) func . id = beh -> gcReleaseAllReferences = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_IMPLICIT_VALUE_CAST || behaviour == asBEHAVE_VALUE_CAST ) { if ( func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . returnType . IsEqualExceptRefAndConst ( asCDataType :: CreatePrimitive ( ttBool , false ) ) ) return ConfigError ( asNOT_SUPPORTED ) ; if ( func . returnType . IsEqualExceptRefAndConst ( asCDataType :: CreatePrimitive ( ttVoid , false ) ) ) return ConfigError ( asINVALID_DECLARATION ) ; beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else if ( behaviour == asBEHAVE_REF_CAST || behaviour == asBEHAVE_IMPLICIT_REF_CAST ) { if ( func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ! func . returnType . IsObjectHandle ( ) ) return ConfigError ( asINVALID_DECLARATION ) ; beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else { asASSERT ( false ) ; return ConfigError ( asINVALID_ARG ) ; } return func . id ; } int asCScriptEngine :: VerifyVarTypeNotInFunction ( asCScriptFunction * func ) { if ( func -> returnType . GetTokenType ( ) == ttQuestion ) return asINVALID_DECLARATION ; for ( unsigned int n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) if ( func -> parameterTypes [ n ] . GetTokenType ( ) == ttQuestion ) return asINVALID_DECLARATION ; return 0 ; } int asCScriptEngine :: AddBehaviourFunction ( asCScriptFunction & func , asSSystemFunctionInterface & internal ) { asUINT n ; int id = GetNextScriptFunctionId ( ) ; asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ; newInterface -> func = internal . func ; newInterface -> baseOffset = internal . baseOffset ; newInterface -> callConv = internal . callConv ; newInterface -> scriptReturnSize = internal . scriptReturnSize ; newInterface -> hostReturnInMemory = internal . hostReturnInMemory ; newInterface -> hostReturnFloat = internal . hostReturnFloat ; newInterface -> hostReturnSize = internal . hostReturnSize ; newInterface -> paramSize = internal . paramSize ; newInterface -> takesObjByVal = internal . takesObjByVal ; newInterface -> paramAutoHandles = internal . paramAutoHandles ; newInterface -> returnAutoHandle = internal . returnAutoHandle ; newInterface -> hasAutoHandles = internal . hasAutoHandles ; asCScriptFunction * f = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; asASSERT ( func . name != " " && func . name != " f " ) ; f -> name = func . name ; f -> sysFuncIntf = newInterface ; f -> returnType = func . returnType ; f -> objectType = func . objectType ; f -> id = id ; f -> isReadOnly = func . isReadOnly ; for ( n = 0 ; n < func . parameterTypes . GetLength ( ) ; n ++ ) { f -> parameterTypes . PushLast ( func . parameterTypes [ n ] ) ; f -> inOutFlags . PushLast ( func . inOutFlags [ n ] ) ; } SetScriptFunction ( f ) ; if ( f -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( f -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( n = 0 ; n < f -> parameterTypes . GetLength ( ) ; n ++ ) { if ( f -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( f -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } return id ; } int asCScriptEngine :: RegisterGlobalProperty ( const char * declaration , void * pointer ) { asCDataType type ; asCString name ; int r ; asCBuilder bld ( this , 0 ) ; if ( ( r = bld . VerifyProperty ( 0 , declaration , name , type ) ) < 0 ) return ConfigError ( r ) ; if ( type . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; asCGlobalProperty * prop = AllocateGlobalProperty ( ) ; prop -> name = name ; prop -> type = type ; prop -> SetRegisteredAddress ( pointer ) ; registeredGlobalProps . PushLast ( prop ) ; currentGroup -> globalProps . PushLast ( prop ) ; if ( type . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( type . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } return asSUCCESS ; } asCGlobalProperty * asCScriptEngine :: AllocateGlobalProperty ( ) { asCGlobalProperty * prop = asNEW ( asCGlobalProperty ) ; if ( freeGlobalPropertyIds . GetLength ( ) ) { prop -> id = freeGlobalPropertyIds . PopLast ( ) ; globalProperties [ prop -> id ] = prop ; return prop ; } prop -> id = ( asUINT ) globalProperties . GetLength ( ) ; globalProperties . PushLast ( prop ) ; return prop ; } void asCScriptEngine :: FreeUnusedGlobalProperties ( ) { for ( asUINT n = 0 ; n < globalProperties . GetLength ( ) ; n ++ ) { if ( globalProperties [ n ] && globalProperties [ n ] -> refCount . get ( ) == 0 ) { freeGlobalPropertyIds . PushLast ( n ) ; asDELETE ( globalProperties [ n ] , asCGlobalProperty ) ; globalProperties [ n ] = 0 ; } } } int asCScriptEngine :: GetGlobalPropertyCount ( ) { return ( int ) registeredGlobalProps . GetLength ( ) ; } int asCScriptEngine :: GetGlobalPropertyByIndex ( asUINT index , const char * * name , int * typeId , bool * isConst , const char * * configGroup , void * * pointer ) { if ( index >= registeredGlobalProps . GetLength ( ) ) return asINVALID_ARG ; if ( name ) * name = registeredGlobalProps [ index ] -> name . AddressOf ( ) ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForGlobalVar ( index ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } if ( typeId ) * typeId = GetTypeIdFromDataType ( registeredGlobalProps [ index ] -> type ) ; if ( isConst ) * isConst = registeredGlobalProps [ index ] -> type . IsReadOnly ( ) ; if ( pointer ) * pointer = registeredGlobalProps [ index ] -> realAddress ; return asSUCCESS ; } int asCScriptEngine :: RegisterObjectMethod ( const char * obj , const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { if ( obj == 0 ) return ConfigError ( asINVALID_ARG ) ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( obj , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( dt . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_ARG ) ; return RegisterMethodToObjectType ( dt . GetObjectType ( ) , declaration , funcPointer , callConv ) ; } int asCScriptEngine :: RegisterMethodToObjectType ( asCObjectType * objectType , const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( true , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # else if ( callConv != asCALL_THISCALL && callConv != asCALL_CDECL_OBJLAST && callConv != asCALL_CDECL_OBJFIRST && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif isPrepared = false ; asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> sysFuncIntf = newInterface ; func -> objectType = objectType ; asCBuilder bld ( this , 0 ) ; r = bld . ParseFunctionDeclaration ( func -> objectType , declaration , func , true , & newInterface -> paramAutoHandles , & newInterface -> returnAutoHandle ) ; if ( r < 0 ) { func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } asCDataType x = asCDataType :: CreateObject ( objectType , false ) ; r = bld . CheckNameConflictMember ( x , func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; func -> objectType -> methods . PushLast ( func -> id ) ; SetScriptFunction ( func ) ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } if ( func -> objectType -> flags & asOBJ_TEMPLATE ) { if ( func -> returnType . GetObjectType ( ) == func -> objectType -> templateSubType . GetObjectType ( ) ) { if ( func -> returnType . IsObjectHandle ( ) ) func -> objectType -> acceptValueSubType = false ; else if ( ! func -> returnType . IsReference ( ) ) func -> objectType -> acceptRefSubType = false ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) == func -> objectType -> templateSubType . GetObjectType ( ) ) { if ( func -> parameterTypes [ n ] . IsObjectHandle ( ) || ( func -> parameterTypes [ n ] . IsReference ( ) && func -> inOutFlags [ n ] == asTM_INOUTREF ) ) func -> objectType -> acceptValueSubType = false ; else if ( ! func -> parameterTypes [ n ] . IsReference ( ) ) func -> objectType -> acceptRefSubType = false ; } } } if ( func -> name == " opAssign " && func -> parameterTypes . GetLength ( ) == 1 && func -> isReadOnly == false && ( objectType -> flags & asOBJ_SCRIPT_OBJECT || func -> parameterTypes [ 0 ] . IsEqualExceptRefAndConst ( asCDataType :: CreateObject ( func -> objectType , false ) ) ) ) { func -> objectType -> beh . copy = func -> id ; func -> AddRef ( ) ; } return func -> id ; } int asCScriptEngine :: RegisterGlobalFunction ( const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # else if ( callConv != asCALL_CDECL && callConv != asCALL_STDCALL && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif isPrepared = false ; asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> sysFuncIntf = newInterface ; asCBuilder bld ( this , 0 ) ; r = bld . ParseFunctionDeclaration ( 0 , declaration , func , true , & newInterface -> paramAutoHandles , & newInterface -> returnAutoHandle ) ; if ( r < 0 ) { func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } r = bld . CheckNameConflict ( func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; currentGroup -> scriptFunctions . PushLast ( func ) ; registeredGlobalFuncs . PushLast ( func ) ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } return func -> id ; } int asCScriptEngine :: GetGlobalFunctionCount ( ) { return ( int ) registeredGlobalFuncs . GetLength ( ) ; } int asCScriptEngine :: GetGlobalFunctionIdByIndex ( asUINT index ) { if ( index >= registeredGlobalFuncs . GetLength ( ) ) return asINVALID_ARG ; return registeredGlobalFuncs [ index ] -> id ; } asCObjectType * asCScriptEngine :: GetObjectType ( const char * type ) { for ( asUINT n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) if ( objectTypes [ n ] && objectTypes [ n ] -> name == type ) return objectTypes [ n ] ; return 0 ; } void asCScriptEngine :: PrepareEngine ( ) { if ( isPrepared ) return ; if ( configFailed ) return ; asUINT n ; for ( n = 0 ; n < scriptFunctions . GetLength ( ) ; n ++ ) { if ( scriptFunctions [ n ] && scriptFunctions [ n ] -> funcType == asFUNC_SYSTEM ) { if ( scriptFunctions [ n ] -> sysFuncIntf -> callConv == ICC_GENERIC_FUNC || scriptFunctions [ n ] -> sysFuncIntf -> callConv == ICC_GENERIC_METHOD ) PrepareSystemFunctionGeneric ( scriptFunctions [ n ] , scriptFunctions [ n ] -> sysFuncIntf , this ) ; else PrepareSystemFunction ( scriptFunctions [ n ] , scriptFunctions [ n ] -> sysFuncIntf , this ) ; } } for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && ! ( objectTypes [ n ] -> flags & asOBJ_SCRIPT_OBJECT ) ) { bool missingBehaviour = false ; const char * infoMsg = 0 ; if ( objectTypes [ n ] -> flags & asOBJ_GC ) { if ( objectTypes [ n ] -> beh . addref == 0 || objectTypes [ n ] -> beh . release == 0 || objectTypes [ n ] -> beh . gcGetRefCount == 0 || objectTypes [ n ] -> beh . gcSetFlag == 0 || objectTypes [ n ] -> beh . gcGetFlag == 0 || objectTypes [ n ] -> beh . gcEnumReferences == 0 || objectTypes [ n ] -> beh . gcReleaseAllReferences == 0 ) { infoMsg = TXT_GC_@@ REQUIRE_ADD_REL_GC_@@ BEHAVIOUR ; missingBehaviour = true ; } } else if ( objectTypes [ n ] -> flags & asOBJ_SCOPED ) { if ( objectTypes [ n ] -> beh . release == 0 ) { infoMsg = TXT_SCOP@@ E_REQUIR@@ E_REL_BEHAVIOUR ; missingBehaviour = true ; } } else if ( ( objectTypes [ n ] -> flags & asOBJ_REF ) && ! ( objectTypes [ n ] -> flags & asOBJ_NOHANDLE ) ) { if ( objectTypes [ n ] -> beh . addref == 0 || objectTypes [ n ] -> beh . release == 0 ) { infoMsg = TXT_REF_@@ REQUIRE_ADD_REL_BEHAVIOUR ; missingBehaviour = true ; } } else if ( ( objectTypes [ n ] -> flags & asOBJ_VALUE ) && ! ( objectTypes [ n ] -> flags & asOBJ_POD ) ) { if ( objectTypes [ n ] -> beh . construct == 0 || objectTypes [ n ] -> beh . destruct == 0 ) { infoMsg = TXT_NON_@@ POD_RE@@ QUIRE_@@ CONSTR_DESTR@@ _BEHAVIOUR ; missingBehaviour = true ; } } if ( missingBehaviour ) { asCString str ; str . Format ( TXT_TYPE_s_IS_@@ MISSING_@@ BEHAVIOURS , objectTypes [ n ] -> name . AddressOf ( ) ) ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , str . AddressOf ( ) ) ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_INFOR@@ MATION , infoMsg ) ; ConfigError ( asINVALID_CONFIGURATION ) ; } } } isPrepared = true ; } int asCScriptEngine :: ConfigError ( int err ) { configFailed = true ; return err ; } int asCScriptEngine :: RegisterStringFactory ( const char * datatype , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # else if ( callConv != asCALL_CDECL && callConv != asCALL_STDCALL && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> name = " _ string _ factory _ " ; func -> sysFuncIntf = newInterface ; asCBuilder bld ( this , 0 ) ; asCDataType dt ; r = bld . ParseDataType ( datatype , & dt ) ; if ( r < 0 ) { func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_TYPE ) ; } func -> returnType = dt ; func -> parameterTypes . PushLast ( asCDataType :: CreatePrimitive ( ttInt , true ) ) ; asCDataType parm1 = asCDataType :: CreatePrimitive ( ttUInt8 , true ) ; parm1 . MakeReference ( true ) ; func -> parameterTypes . PushLast ( parm1 ) ; func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; stringFactory = func ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; if ( group == 0 ) group = & defaultGroup ; group -> scriptFunctions . PushLast ( func ) ; } return func -> id ; } int asCScriptEngine :: GetStringFactory@@ ReturnTypeId ( ) { if ( stringFactory == 0 ) return asNO_FUNCTION ; return GetTypeIdFromDataType ( stringFactory -> returnType ) ; } asCModule * asCScriptEngine :: GetModule ( const char * _name , bool create ) { const char * name = " " ; if ( _name != 0 ) name = _name ; if ( lastModule && lastModule -> name == name ) return lastModule ; for ( asUINT n = 0 ; n < scriptModules . GetLength ( ) ; ++ n ) if ( scriptModules [ n ] && scriptModules [ n ] -> name == name ) { lastModule = scriptModules [ n ] ; return lastModule ; } if ( create ) { asCModule * module = asNEW ( asCModule ) ( name , this ) ; scriptModules . PushLast ( module ) ; lastModule = module ; return lastModule ; } return 0 ; } asCModule * asCScriptEngine :: GetModuleFromFuncId ( int id ) { if ( id < 0 ) return 0 ; if ( id >= ( int ) scriptFunctions . GetLength ( ) ) return 0 ; asCScriptFunction * func = scriptFunctions [ id ] ; if ( func == 0 ) return 0 ; return func -> module ; } int asCScriptEngine :: RequestBuild ( ) { ENTERCRI@@ TICALSECTION ( engineCritical ) ; if ( isBuilding ) { LEAVECRITICALSECTION ( engineCritical ) ; return asBUILD_IN_PROGRESS ; } isBuilding = true ; LEAVECRITICALSECTION ( engineCritical ) ; return 0 ; } void asCScriptEngine :: BuildCompleted ( ) { memoryMgr . FreeUnusedMemory ( ) ; isBuilding = false ; } # ifdef AS_DEPRECATED int asCScriptEngine :: ExecuteString ( const char * module , const char * script , asIScriptContext * * ctx , asDWORD flags ) { int r ; if ( ( r = RequestBuild ( ) ) < 0 ) return r ; PrepareEngine ( ) ; if ( configFailed ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) * ctx = 0 ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_INVALID_CONFIGURATION ) ; isBuilding = false ; return asINVALID_CONFIGURATION ; } asIScriptContext * exec = 0 ; if ( ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { int r = CreateContext ( & exec , false ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) * ctx = 0 ; isBuilding = false ; return r ; } if ( ctx ) { * ctx = exec ; exec -> AddRef ( ) ; } } else { if ( * ctx == 0 ) { isBuilding = false ; return asINVALID_ARG ; } exec = * ctx ; exec -> AddRef ( ) ; } exec -> Unprepare ( ) ; asCModule * mod = GetModule ( module , true ) ; asCBuilder builder ( this , mod ) ; asCString str = script ; str = " void ▁ ExecuteString ( ) { \n " + str + " \n ; } " ; r = builder . BuildString ( str . AddressOf ( ) , ( asCContext * ) exec ) ; BuildCompleted ( ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { ( * ctx ) -> Release ( ) ; * ctx = 0 ; } exec -> Release ( ) ; return asERROR ; } r = ( ( asCContext * ) exec ) -> Prepare ( ( ( asCContext * ) exec ) -> stringFunction -> id ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { ( * ctx ) -> Release ( ) ; * ctx = 0 ; } exec -> Release ( ) ; return r ; } if ( flags & asEXECSTRING_ONLY_@@ PREPARE ) r = asEXECUTION_@@ PREPARED ; else r = exec -> Execute ( ) ; exec -> Release ( ) ; return r ; } # endif void asCScriptEngine :: RemoveTemplateInstanceType ( asCObjectType * t ) { int n ; for ( n = 0 ; n < ( int ) t -> beh . factories . GetLength ( ) ; n ++ ) { scriptFunctions [ t -> beh . factories [ n ] ] -> ReleaseAllHandles ( this ) ; scriptFunctions [ t -> beh . factories [ n ] ] -> Release ( ) ; } t -> beh . factories . SetLength ( 0 ) ; for ( n = 1 ; n < ( int ) t -> beh . operators . GetLength ( ) ; n += 2 ) { if ( t -> beh . operators [ n ] && scriptFunctions [ t -> beh . operators [ n ] ] -> objectType == t ) { scriptFunctions [ t -> beh . operators [ n ] ] -> Release ( ) ; } } t -> beh . operators . SetLength ( 0 ) ; for ( n = ( int ) templateTypes . GetLength ( ) - 1 ; n >= 0 ; n -- ) { if ( templateTypes [ n ] == t ) { if ( n == ( signed ) templateTypes . GetLength ( ) - 1 ) templateTypes . PopLast ( ) ; else templateTypes [ n ] = templateTypes . PopLast ( ) ; } } for ( n = ( int ) templateInstanceTypes . GetLength ( ) - 1 ; n >= 0 ; n -- ) { if ( templateInstanceTypes [ n ] == t ) { if ( n == ( signed ) templateInstanceTypes . GetLength ( ) - 1 ) templateInstanceTypes . PopLast ( ) ; else templateInstanceTypes [ n ] = templateInstanceTypes . PopLast ( ) ; } } asDELETE ( t , asCObjectType ) ; } asCObjectType * asCScriptEngine :: GetTemplateInstanceType ( asCObjectType * templateType , asCDataType & subType ) { asUINT n ; for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] && templateTypes [ n ] -> name == templateType -> name && templateTypes [ n ] -> templateSubType == subType ) return templateTypes [ n ] ; } if ( ! templateType -> acceptValueSubType && ( subType . IsPrimitive ( ) || ( subType . GetObjectType ( ) -> flags & asOBJ_VALUE ) ) ) return 0 ; if ( ! templateType -> acceptRefSubType && ( subType . IsObject ( ) && ( subType . GetObjectType ( ) -> flags & asOBJ_REF ) ) ) return 0 ; asCObjectType * ot = asNEW ( asCObjectType ) ( this ) ; ot -> templateSubType = subType ; ot -> flags = templateType -> flags ; ot -> size = templateType -> size ; ot -> name = templateType -> name ; if ( templateType -> beh . templateCallback ) { asCScriptFunction * callback = scriptFunctions [ templateType -> beh . templateCallback ] ; if ( ! CallGlobalFunctionRetBool ( ot , 0 , callback -> sysFuncIntf , callback ) ) { ot -> templateSubType = asCDataType ( ) ; asDELETE ( ot , asCObjectType ) ; return 0 ; } } ot -> methods = templateType -> methods ; for ( n = 0 ; n < ot -> methods . GetLength ( ) ; n ++ ) scriptFunctions [ ot -> methods [ n ] ] -> AddRef ( ) ; ot -> beh . construct = templateType -> beh . factory ; ot -> beh . constructors = templateType -> beh . factories ; for ( n = 0 ; n < ot -> beh . constructors . GetLength ( ) ; n ++ ) scriptFunctions [ ot -> beh . constructors [ n ] ] -> AddRef ( ) ; for ( n = 0 ; n < templateType -> beh . factories . GetLength ( ) ; n ++ ) { int factoryId = templateType -> beh . factories [ n ] ; asCScriptFunction * factory = scriptFunctions [ factoryId ] ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SCRIP@@ T ) ; func -> name = " factstub " ; func -> id = GetNextScriptFunctionId ( ) ; func -> returnType = asCDataType :: CreateObjectHandle ( ot , false ) ; for ( asUINT p = 1 ; p < factory -> parameterTypes . GetLength ( ) ; p ++ ) { func -> parameterTypes . PushLast ( factory -> parameterTypes [ p ] ) ; func -> inOutFlags . PushLast ( factory -> inOutFlags [ p ] ) ; } SetScriptFunction ( func ) ; asCBuilder builder ( this , 0 ) ; asCCompiler compiler ( this ) ; compiler . CompileTemplateFactory@@ Stub ( & builder , factoryId , ot , func ) ; ot -> beh . factories . PushLast ( func -> id ) ; } if ( ot -> beh . factories . GetLength ( ) ) ot -> beh . factory = ot -> beh . factories [ 0 ] ; else { asASSERT ( false ) ; ot -> beh . factory = templateType -> beh . factory ; } ot -> beh . addref = templateType -> beh . addref ; if ( scriptFunctions [ ot -> beh . addref ] ) scriptFunctions [ ot -> beh . addref ] -> AddRef ( ) ; ot -> beh . release = templateType -> beh . release ; if ( scriptFunctions [ ot -> beh . release ] ) scriptFunctions [ ot -> beh . release ] -> AddRef ( ) ; ot -> beh . copy = templateType -> beh . copy ; if ( scriptFunctions [ ot -> beh . copy ] ) scriptFunctions [ ot -> beh . copy ] -> AddRef ( ) ; ot -> beh . operators = templateType -> beh . operators ; for ( n = 1 ; n < ot -> beh . operators . GetLength ( ) ; n += 2 ) { scriptFunctions [ ot -> beh . operators [ n ] ] -> AddRef ( ) ; } ot -> beh . gcGetRefCount = templateType -> beh . gcGetRefCount ; if ( scriptFunctions [ ot -> beh . gcGetRefCount ] ) scriptFunctions [ ot -> beh . gcGetRefCount ] -> AddRef ( ) ; ot -> beh . gcSetFlag = templateType -> beh . gcSetFlag ; if ( scriptFunctions [ ot -> beh . gcSetFlag ] ) scriptFunctions [ ot -> beh . gcSetFlag ] -> AddRef ( ) ; ot -> beh . gcGetFlag = templateType -> beh . gcGetFlag ; if ( scriptFunctions [ ot -> beh . gcGetFlag ] ) scriptFunctions [ ot -> beh . gcGetFlag ] -> AddRef ( ) ; ot -> beh . gcEnumReferences = templateType -> beh . gcEnumReferences ; if ( scriptFunctions [ ot -> beh . gcEnumReferences ] ) scriptFunctions [ ot -> beh . gcEnumReferences ] -> AddRef ( ) ; ot -> beh . gcReleaseAllReferences = templateType -> beh . gcReleaseAllReferences ; if ( scriptFunctions [ ot -> beh . gcReleaseAllReferences ] ) scriptFunctions [ ot -> beh . gcReleaseAllReferences ] -> AddRef ( ) ; for ( n = 1 ; n < ot -> beh . operators . GetLength ( ) ; n += 2 ) { int funcId = ot -> beh . operators [ n ] ; asCScriptFunction * func = scriptFunctions [ funcId ] ; if ( GenerateNewTemplateFunction ( templateType , ot , subType , func , & func ) ) { scriptFunctions [ ot -> beh . operators [ n ] ] -> Release ( ) ; ot -> beh . operators [ n ] = func -> id ; } } for ( n = 0 ; n < ot -> methods . GetLength ( ) ; n ++ ) { int funcId = ot -> methods [ n ] ; asCScriptFunction * func = scriptFunctions [ funcId ] ; if ( GenerateNewTemplateFunction ( templateType , ot , subType , func , & func ) ) { scriptFunctions [ ot -> methods [ n ] ] -> Release ( ) ; ot -> methods [ n ] = func -> id ; } } if ( ot -> templateSubType . GetObjectType ( ) ) ot -> templateSubType . GetObjectType ( ) -> AddRef ( ) ; if ( ot -> templateSubType . GetObjectType ( ) && ( ot -> templateSubType . GetObjectType ( ) -> flags & asOBJ_GC ) ) ot -> flags |= asOBJ_GC ; else if ( ot -> name == defaultArrayObjectType -> name ) ot -> flags &= ~ asOBJ_GC ; templateTypes . PushLast ( ot ) ; templateInstanceTypes . PushLast ( ot ) ; return ot ; } bool asCScriptEngine :: GenerateNewTemplateFunction ( asCObjectType * templateType , asCObjectType * ot , asCDataType & subType , asCScriptFunction * func , asCScriptFunction * * newFunc ) { bool needNewFunc = false ; if ( func -> returnType . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) || func -> returnType . GetObjectType ( ) == templateType ) needNewFunc = true ; else { for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) || func -> parameterTypes [ p ] . GetObjectType ( ) == templateType ) { needNewFunc = true ; break ; } } } if ( needNewFunc ) { asCScriptFunction * func2 = asNEW ( asCScriptFunction ) ( this , 0 , func -> funcType ) ; func2 -> name = func -> name ; func2 -> id = GetNextScriptFunctionId ( ) ; if ( func -> returnType . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) ) { func2 -> returnType = subType ; if ( func -> returnType . IsObjectHandle ( ) ) func2 -> returnType . MakeHandle ( true , true ) ; func2 -> returnType . MakeReference ( func -> returnType . IsReference ( ) ) ; func2 -> returnType . MakeReadOnly ( func -> returnType . IsReadOnly ( ) ) ; } else if ( func -> returnType . GetObjectType ( ) == templateType ) { if ( func2 -> returnType . IsObjectHandle ( ) ) func2 -> returnType = asCDataType :: CreateObjectHandle ( ot , false ) ; else func2 -> returnType = asCDataType :: CreateObject ( ot , false ) ; func2 -> returnType . MakeReference ( func -> returnType . IsReference ( ) ) ; func2 -> returnType . MakeReadOnly ( func -> returnType . IsReadOnly ( ) ) ; } else func2 -> returnType = func -> returnType ; func2 -> parameterTypes . SetLength ( func -> parameterTypes . GetLength ( ) ) ; for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) ) { func2 -> parameterTypes [ p ] = subType ; if ( func -> parameterTypes [ p ] . IsObjectHandle ( ) ) func2 -> parameterTypes [ p ] . MakeHandle ( true ) ; func2 -> parameterTypes [ p ] . MakeReference ( func -> parameterTypes [ p ] . IsReference ( ) ) ; func2 -> parameterTypes [ p ] . MakeReadOnly ( func -> parameterTypes [ p ] . IsReference ( ) ) ; } else if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType ) { if ( func2 -> parameterTypes [ p ] . IsObjectHandle ( ) ) func2 -> parameterTypes [ p ] = asCDataType :: CreateObjectHandle ( ot , false ) ; else func2 -> parameterTypes [ p ] = asCDataType :: CreateObject ( ot , false ) ; func2 -> parameterTypes [ p ] . MakeReference ( func -> parameterTypes [ p ] . IsReference ( ) ) ; func2 -> parameterTypes [ p ] . MakeReadOnly ( func -> parameterTypes [ p ] . IsReadOnly ( ) ) ; } else func2 -> parameterTypes [ p ] = func -> parameterTypes [ p ] ; } func2 -> inOutFlags = func -> inOutFlags ; func2 -> isReadOnly = func -> isReadOnly ; func2 -> objectType = ot ; func2 -> stackNeeded = func -> stackNeeded ; func2 -> sysFuncIntf = asNEW ( asSSystemFunctionInterface ) ( * func -> sysFuncIntf ) ; SetScriptFunction ( func2 ) ; * newFunc = func2 ; } return needNewFunc ; } void asCScriptEngine :: CallObjectMethod ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; CallObjectMethod ( obj , s -> sysFuncIntf , s ) ; } void asCScriptEngine :: CallObjectMethod ( void * obj , asSSystemFunctionInterface * i , asCScriptFunction * s ) { # ifdef __GNUC__ if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asPWORD baseOffset ; } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = asPWORD ( i -> baseOffset ) ; void ( asCSimpleDummy :: * f ) ( ) = p . mthd ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else { void ( * f ) ( void * ) = ( void ( * ) ( void * ) ) ( i -> func ) ; f ( obj ) ; } # else # ifndef AS_NO_CLASS_METHODS if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; void ( asCSimpleDummy :: * f ) ( ) = p . mthd ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else # endif if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else { void ( * f ) ( void * ) = ( void ( * ) ( void * ) ) ( i -> func ) ; f ( obj ) ; } # endif } bool asCScriptEngine :: CallObjectMethodRetBool ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; asSSystemFunctionInterface * i = s -> sysFuncIntf ; # ifdef __GNUC__ if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asDWORD baseOffset ; } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = i -> baseOffset ; bool ( asCSimpleDummy :: * f ) ( ) = ( bool ( asCSimpleDummy :: * ) ( ) ) ( p . mthd ) ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else { bool ( * f ) ( void * ) = ( bool ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } # else # ifndef AS_NO_CLASS_METHODS if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; bool ( asCSimpleDummy :: * f ) ( ) = ( bool ( asCSimpleDummy :: * ) ( ) ) p . mthd ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else # endif if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } else { bool ( * f ) ( void * ) = ( bool ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } # endif } int asCScriptEngine :: CallObjectMethodRetInt ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; asSSystemFunctionInterface * i = s -> sysFuncIntf ; # ifdef __GNUC__ if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( int * ) gen . GetReturnPointer ( ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asDWORD baseOffset ; } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = i -> baseOffset ; int ( asCSimpleDummy :: * f ) ( ) = ( int ( asCSimpleDummy :: * ) ( ) ) ( p . mthd ) ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else { int ( * f ) ( void * ) = ( int ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } # else # ifndef AS_NO_CLASS_METHODS if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; int ( asCSimpleDummy :: * f ) ( ) = ( int ( asCSimpleDummy :: * ) ( ) ) p . mthd ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else # endif if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( int * ) gen . GetReturnPointer ( ) ; } else { int ( * f ) ( void * ) = ( int ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } # endif } void * asCScriptEngine :: CallGlobalFunctionRetPtr ( int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; return CallGlobalFunctionRetPtr ( s -> sysFuncIntf , s ) ; } void * asCScriptEngine :: CallGlobalFunctionRetPtr ( int func , void * param1 ) { asCScriptFunction * s = scriptFunctions [ func ] ; return CallGlobalFunctionRetPtr ( s -> sysFuncIntf , s , param1 ) ; } void * asCScriptEngine :: CallGlobalFunctionRetPtr ( asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { void * ( * f ) ( ) = ( void * ( * ) ( ) ) ( i -> func ) ; return f ( ) ; } else if ( i -> callConv == ICC_STDCALL ) { void * ( STDCALL * f ) ( ) = ( void * ( STDCALL * ) ( ) ) ( i -> func ) ; return f ( ) ; } else { asCGeneric gen ( this , s , 0 , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( void * * ) gen . GetReturnPointer ( ) ; } } void * asCScriptEngine :: CallGlobalFunctionRetPtr ( asSSystemFunctionInterface * i , asCScriptFunction * s , void * param1 ) { if ( i -> callConv == ICC_CDECL ) { void * ( * f ) ( void * ) = ( void * ( * ) ( void * ) ) ( i -> func ) ; return f ( param1 ) ; } else if ( i -> callConv == ICC_STDCALL ) { void * ( STDCALL * f ) ( void * ) = ( void * ( STDCALL * ) ( void * ) ) ( i -> func ) ; return f ( param1 ) ; } else { asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( void * * ) gen . GetReturnPointer ( ) ; } } void asCScriptEngine :: CallObjectMethod ( void * obj , void * param , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; CallObjectMethod ( obj , param , s -> sysFuncIntf , s ) ; } void asCScriptEngine :: CallObjectMethod ( void * obj , void * param , asSSystemFunctionInterface * i , asCScriptFunction * s ) { # ifdef __GNUC__ if ( i -> callConv == ICC_CDECL_OBJLAST ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param , obj ) ; } else if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , ( asDWORD * ) & param ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( obj , param ) ; } # else # ifndef AS_NO_CLASS_METHODS if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; void ( asCSimpleDummy :: * f ) ( void * ) = ( void ( asCSimpleDummy :: * ) ( void * ) ) ( p . mthd ) ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( param ) ; } else # endif if ( i -> callConv == ICC_CDECL_OBJLAST ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param , obj ) ; } else if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , ( asDWORD * ) & param ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( obj , param ) ; } # endif } void asCScriptEngine :: CallGlobalFunction ( void * param1 , void * param2 , asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param1 , param2 ) ; } else if ( i -> callConv == ICC_STDCALL ) { void ( STDCALL * f ) ( void * , void * ) = ( void ( STDCALL * ) ( void * , void * ) ) ( i -> func ) ; f ( param1 , param2 ) ; } else { asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } } bool asCScriptEngine :: CallGlobalFunctionRetBool ( void * param1 , void * param2 , asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { bool ( * f ) ( void * , void * ) = ( bool ( * ) ( void * , void * ) ) ( i -> func ) ; return f ( param1 , param2 ) ; } else if ( i -> callConv == ICC_STDCALL ) { bool ( STDCALL * f ) ( void * , void * ) = ( bool ( STDCALL * ) ( void * , void * ) ) ( i -> func ) ; return f ( param1 , param2 ) ; } else { asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } } void * asCScriptEngine :: CallAlloc ( asCObjectType * type ) { # if defined ( AS_DEBUG ) return ( ( asALLOCFUNC@@ DEBUG_t ) ( userAlloc ) ) ( type -> size < 4 ? 4 : type -> size , __FILE__ , __LINE__ ) ; # else return userAlloc ( type -> size < 4 ? 4 : type -> size ) ; # endif } void asCScriptEngine :: CallFree ( void * obj ) { userFree ( obj ) ; } void asCScriptEngine :: NotifyGarbageCollect@@ orOfNewObject ( void * obj , int typeId ) { asCObjectType * objType = GetObjectTypeFromTypeId ( typeId ) ; gc . AddScriptObject@@ ToGC ( obj , objType ) ; } int asCScriptEngine :: GarbageCollect ( asDWORD flags ) { return gc . GarbageCollect ( flags ) ; } void asCScriptEngine :: GetGCStatistics ( asUINT * currentSize , asUINT * totalDestroyed , asUINT * totalDetected ) { gc . GetStatistics ( currentSize , totalDestroyed , totalDetected ) ; } void asCScriptEngine :: GCEnumCallback ( void * reference ) { gc . GCEnumCallback ( reference ) ; } int asCScriptEngine :: GetTypeIdFromDataType ( const asCDataType & dt ) { if ( dt . IsNullHandle ( ) ) return 0 ; asSMapNode < int , asCDataType * > * cursor = 0 ; mapTypeIdToDataType . MoveFirst ( & cursor ) ; while ( cursor ) { if ( mapTypeIdToDataType . GetValue ( cursor ) -> IsEqualExceptRefAndConst ( dt ) ) return mapTypeIdToDataType . GetKey ( cursor ) ; mapTypeIdToDataType . MoveNext ( & cursor , cursor ) ; } int typeId = typeIdSeqNbr ++ ; if ( dt . GetObjectType ( ) ) { if ( dt . GetObjectType ( ) -> flags & asOBJ_SCRIPT_OBJECT ) typeId |= asTYPEID_SCRIPTOBJECT ; else if ( dt . GetObjectType ( ) -> flags & asOBJ_TEMPLATE ) typeId |= asTYPEID_SCRIPTARRAY ; else if ( dt . GetObjectType ( ) -> flags & asOBJ_ENUM ) ; else typeId |= asTYPEID_AP@@ POBJECT ; } asCDataType * newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( false ) ; mapTypeIdToDataType . Insert ( typeId , newDt ) ; if ( dt . IsObject ( ) && dt . GetObjectType ( ) -> beh . release ) { newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( true ) ; newDt -> MakeHandleToConst ( false ) ; mapTypeIdToDataType . Insert ( typeId | asTYPEID_OBJHANDLE , newDt ) ; newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( true ) ; newDt -> MakeHandleToConst ( true ) ; mapTypeIdToDataType . Insert ( typeId | asTYPEID_OBJHANDLE | asTYPEID_HAND@@ LETO@@ CONST , newDt ) ; } return GetTypeIdFromDataType ( dt ) ; } const asCDataType * asCScriptEngine :: GetDataTypeFromTypeId ( int typeId ) { asSMapNode < int , asCDataType * > * cursor = 0 ; if ( mapTypeIdToDataType . MoveTo ( & cursor , typeId ) ) return mapTypeIdToDataType . GetValue ( cursor ) ; return 0 ; } asCObjectType * asCScriptEngine :: GetObjectTypeFromTypeId ( int typeId ) { asSMapNode < int , asCDataType * > * cursor = 0 ; if ( mapTypeIdToDataType . MoveTo ( & cursor , typeId ) ) return mapTypeIdToDataType . GetValue ( cursor ) -> GetObjectType ( ) ; return 0 ; } void asCScriptEngine :: RemoveFromTypeIdMap ( asCObjectType * type ) { asSMapNode < int , asCDataType * > * cursor = 0 ; mapTypeIdToDataType . MoveFirst ( & cursor ) ; while ( cursor ) { asCDataType * dt = mapTypeIdToDataType . GetValue ( cursor ) ; asSMapNode < int , asCDataType * > * old = cursor ; mapTypeIdToDataType . MoveNext ( & cursor , cursor ) ; if ( dt -> GetObjectType ( ) == type ) { asDELETE ( dt , asCDataType ) ; mapTypeIdToDataType . Erase ( old ) ; } } } int asCScriptEngine :: GetTypeIdByDecl ( const char * decl ) { asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( decl , & dt ) ; if ( r < 0 ) return asINVALID_TYPE ; return GetTypeIdFromDataType ( dt ) ; } const char * asCScriptEngine :: GetTypeDeclaration ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( dt == 0 ) return 0 ; asASSERT ( threadManager ) ; asCString * tempString = & threadManager -> GetLocalData ( ) -> string ; * tempString = dt -> Format ( ) ; return tempString -> AddressOf ( ) ; } int asCScriptEngine :: GetSizeOfPrimiti@@ veType ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( dt == 0 ) return 0 ; if ( ! dt -> IsPrimitive ( ) ) return 0 ; return dt -> GetSizeInMemoryBytes ( ) ; } void * asCScriptEngine :: CreateScriptObject ( int typeId ) { if ( ( typeId & ( asTYPEID_MASK_OBJECT | asTYPEID_MASK_SEQNBR ) ) != typeId ) return 0 ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return 0 ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return 0 ; asCObjectType * objType = dt -> GetObjectType ( ) ; void * ptr = 0 ; if ( objType -> flags & asOBJ_SCRIPT_OBJECT ) ptr = ScriptObjectFactory ( objType , this ) ; else if ( objType -> flags & asOBJ_TEMPLATE ) ptr = CallGlobalFunctionRetPtr ( objType -> beh . construct , objType ) ; else if ( objType -> flags & asOBJ_REF ) ptr = CallGlobalFunctionRetPtr ( objType -> beh . factory ) ; else { ptr = CallAlloc ( objType ) ; int funcIndex = objType -> beh . construct ; if ( funcIndex ) CallObjectMethod ( ptr , funcIndex ) ; } return ptr ; } void * asCScriptEngine :: CreateScriptObject@@ Copy ( void * origObj , int typeId ) { void * newObj = CreateScriptObject ( typeId ) ; if ( newObj == 0 ) return 0 ; CopyScriptObject ( newObj , origObj , typeId ) ; return newObj ; } void asCScriptEngine :: CopyScriptObject ( void * dstObj , void * srcObj , int typeId ) { if ( ( typeId & ( asTYPEID_MASK_OBJECT | asTYPEID_MASK_SEQNBR ) ) != typeId ) return ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; if ( objType -> beh . copy ) { CallObjectMethod ( dstObj , srcObj , objType -> beh . copy ) ; } else if ( objType -> size ) { memcpy ( dstObj , srcObj , objType -> size ) ; } } void asCScriptEngine :: AddRef@@ ScriptObject ( void * obj , int typeId ) { if ( obj == 0 ) return ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; if ( objType -> beh . addref ) { CallObjectMethod ( obj , objType -> beh . addref ) ; } } void asCScriptEngine :: ReleaseScriptObject ( void * obj , int typeId ) { if ( obj == 0 ) return ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; if ( objType -> beh . release ) { CallObjectMethod ( obj , objType -> beh . release ) ; } else { if ( objType -> beh . destruct ) CallObjectMethod ( obj , objType -> beh . destruct ) ; CallFree ( obj ) ; } } bool asCScriptEngine :: IsHandle@@ Compatible@@ WithObject ( void * obj , int objTypeId , int handleTypeId ) { if ( objTypeId == handleTypeId ) return true ; const asCDataType * objDt = GetDataTypeFromTypeId ( objTypeId ) ; const asCDataType * hdlDt = GetDataTypeFromTypeId ( handleTypeId ) ; if ( objDt -> IsHandleToConst ( ) && ! hdlDt -> IsHandleToConst ( ) ) return false ; if ( objDt -> GetObjectType ( ) == hdlDt -> GetObjectType ( ) ) { return true ; } else if ( objDt -> IsScriptObject ( ) && obj ) { asCObjectType * objType = ( ( asCScriptObject * ) obj ) -> objType ; if ( objType -> Implements ( hdlDt -> GetObjectType ( ) ) ) return true ; } return false ; } int asCScriptEngine :: BeginConfigGroup ( const char * groupName ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) return asNAME_TAKEN ; } if ( currentGroup != & defaultGroup ) return asNOT_SUPPORTED ; asCConfigGroup * group = asNEW ( asCConfigGroup ) ( ) ; group -> groupName = groupName ; configGroups . PushLast ( group ) ; currentGroup = group ; return 0 ; } int asCScriptEngine :: EndConfigGroup ( ) { if ( currentGroup == & defaultGroup ) return asNOT_SUPPORTED ; currentGroup = & defaultGroup ; return 0 ; } int asCScriptEngine :: RemoveConfigGroup ( const char * groupName ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) { asCConfigGroup * group = configGroups [ n ] ; if ( group -> refCount > 0 ) return asCONFIG_GROUP_IS_IN_USE ; if ( group -> HasLive@@ Objects ( ) ) return asCONFIG_GROUP_IS_IN_USE ; if ( n == configGroups . GetLength ( ) - 1 ) configGroups . PopLast ( ) ; else configGroups [ n ] = configGroups . PopLast ( ) ; group -> RemoveConfiguration ( this ) ; asDELETE ( group , asCConfigGroup ) ; } } return 0 ; } asCConfigGroup * asCScriptEngine :: FindConfigGroupForFunction ( int funcId ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { asUINT m ; for ( m = 0 ; m < configGroups [ n ] -> scriptFunctions . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> scriptFunctions [ m ] -> id == funcId ) return configGroups [ n ] ; } } return 0 ; } asCConfigGroup * asCScriptEngine :: FindConfigGroupForGlobalVar ( int gvarId ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { for ( asUINT m = 0 ; m < configGroups [ n ] -> globalProps . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> globalProps [ m ] -> id == gvarId ) return configGroups [ n ] ; } } return 0 ; } asCConfigGroup * asCScriptEngine :: FindConfigGroupForObjectType ( const asCObjectType * objType ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { for ( asUINT m = 0 ; m < configGroups [ n ] -> objTypes . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> objTypes [ m ] == objType ) return configGroups [ n ] ; } } return 0 ; } int asCScriptEngine :: SetConfigGroupModuleAccess ( const char * groupName , const char * module , bool hasAccess ) { asCConfigGroup * group = 0 ; for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) { group = configGroups [ n ] ; break ; } } if ( group == 0 ) return asWRONG_CONFIG_GROUP ; return group -> SetModuleAccess ( module , hasAccess ) ; } int asCScriptEngine :: GetNextScriptFunctionId ( ) { if ( freeScriptFunctionIds . GetLength ( ) ) return freeScriptFunctionIds . PopLast ( ) ; int id = ( int ) scriptFunctions . GetLength ( ) ; scriptFunctions . PushLast ( 0 ) ; return id ; } void asCScriptEngine :: SetScriptFunction ( asCScriptFunction * func ) { scriptFunctions [ func -> id ] = func ; } void asCScriptEngine :: FreeScriptFunctionId ( int id ) { if ( id < 0 ) return ; id &= 0xFFFF ; if ( id >= ( int ) scriptFunctions . GetLength ( ) ) return ; if ( scriptFunctions [ id ] ) { asCScriptFunction * func = scriptFunctions [ id ] ; if ( id == ( int ) scriptFunctions . GetLength ( ) - 1 ) { scriptFunctions . PopLast ( ) ; } else { scriptFunctions [ id ] = 0 ; freeScriptFunctionIds . PushLast ( id ) ; } if ( func -> signatureId == id ) { signatureIds . RemoveValue ( func ) ; int newSigId = 0 ; for ( asUINT n = 0 ; n < scriptFunctions . GetLength ( ) ; n ++ ) { if ( scriptFunctions [ n ] && scriptFunctions [ n ] -> signatureId == id ) { if ( newSigId == 0 ) { newSigId = scriptFunctions [ n ] -> id ; signatureIds . PushLast ( scriptFunctions [ n ] ) ; } scriptFunctions [ n ] -> signatureId = newSigId ; } } } } } int asCScriptEngine :: RegisterTypedef ( const char * type , const char * decl ) { if ( type == 0 ) return ConfigError ( asINVALID_NAME ) ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == type ) return asALREADY_REGISTERED ; } asCTokenizer t ; size_t tokenLen ; eTokenType token ; asCDataType dataType ; token = t . GetToken ( decl , strlen ( decl ) , & tokenLen ) ; switch ( token ) { case ttBool : case ttInt : case ttInt8 : case ttInt16 : case ttInt64 : case ttUInt : case ttUInt8 : case ttUInt16 : case ttUInt64 : case ttFloat : case ttDouble : if ( strlen ( decl ) != tokenLen ) { return ConfigError ( asINVALID_TYPE ) ; } break ; default : return ConfigError ( asINVALID_TYPE ) ; } dataType = asCDataType :: CreatePrimitive ( token , false ) ; token = t . GetToken ( type , strlen ( type ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( type ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; asCBuilder bld ( this , 0 ) ; int r = bld . CheckNameConflict ( type , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * object = asNEW ( asCObjectType ) ( this ) ; object -> flags = asOBJ_TYPE@@ DEF ; object -> size = dataType . GetSizeInMemoryBytes ( ) ; object -> name = type ; object -> templateSubType = dataType ; objectTypes . PushLast ( object ) ; registeredTypeDefs . PushLast ( object ) ; currentGroup -> objTypes . PushLast ( object ) ; return asSUCCESS ; } int asCScriptEngine :: GetTypedefCount ( ) { return ( int ) registeredTypeDefs . GetLength ( ) ; } const char * asCScriptEngine :: GetTypedefByIndex ( asUINT index , int * typeId , const char * * configGroup ) { if ( index >= registeredTypeDefs . GetLength ( ) ) return 0 ; if ( typeId ) * typeId = GetTypeIdByDecl ( registeredTypeDefs [ index ] -> name . AddressOf ( ) ) ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForObjectType ( registeredTypeDefs [ index ] ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } return registeredTypeDefs [ index ] -> name . AddressOf ( ) ; } int asCScriptEngine :: RegisterEnum ( const char * name ) { if ( NULL == name ) return ConfigError ( asINVALID_NAME ) ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) return asALREADY_REGISTERED ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; bool oldMsgCallback = msgCallback ; msgCallback = false ; int r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; if ( r >= 0 ) return ConfigError ( asERROR ) ; asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , strlen ( name ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( name ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * st = asNEW ( asCObjectType ) ( this ) ; asCDataType dataType ; dataType . CreatePrimitive ( ttInt , false ) ; st -> flags = asOBJ_ENUM ; st -> size = dataType . GetSizeInMemoryBytes ( ) ; st -> name = name ; objectTypes . PushLast ( st ) ; registeredEnums . PushLast ( st ) ; currentGroup -> objTypes . PushLast ( st ) ; return asSUCCESS ; } int asCScriptEngine :: RegisterEnumValue ( const char * typeName , const char * valueName , int value ) { if ( currentGroup -> FindType ( typeName ) == 0 ) return asWRONG_CONFIG_GROUP ; asCDataType dt ; int r ; asCBuilder bld ( this , 0 ) ; r = bld . ParseDataType ( typeName , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; asCObjectType * ot = dt . GetObjectType ( ) ; if ( ot == 0 || ! ( ot -> flags & asOBJ_ENUM ) ) return ConfigError ( asINVALID_TYPE ) ; if ( NULL == valueName ) return ConfigError ( asINVALID_NAME ) ; for ( unsigned int n = 0 ; n < ot -> enumValues . GetLength ( ) ; n ++ ) { if ( ot -> enumValues [ n ] -> name == valueName ) return ConfigError ( asALREADY_REGISTERED ) ; } asSEnumValue * e = asNEW ( asSEnumValue ) ; e -> name = valueName ; e -> value = value ; ot -> enumValues . PushLast ( e ) ; return asSUCCESS ; } int asCScriptEngine :: GetEnumCount ( ) { return ( int ) registeredEnums . GetLength ( ) ; } const char * asCScriptEngine :: GetEnumByIndex ( asUINT index , int * enumTypeId , const char * * configGroup ) { if ( index >= registeredEnums . GetLength ( ) ) return 0 ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForObjectType ( registeredEnums [ index ] ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } if ( enumTypeId ) * enumTypeId = GetTypeIdByDecl ( registeredEnums [ index ] -> name . AddressOf ( ) ) ; return registeredEnums [ index ] -> name . AddressOf ( ) ; } int asCScriptEngine :: GetEnumValueCount ( int enumTypeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( enumTypeId ) ; asCObjectType * t = dt -> GetObjectType ( ) ; if ( t == 0 || ! ( t -> GetFlags ( ) & asOBJ_ENUM ) ) return asINVALID_TYPE ; return ( int ) t -> enumValues . GetLength ( ) ; } const char * asCScriptEngine :: GetEnumValueByIndex ( int enumTypeId , asUINT index , int * outValue ) { const asCDataType * dt = GetDataTypeFromTypeId ( enumTypeId ) ; asCObjectType * t = dt -> GetObjectType ( ) ; if ( t == 0 || ! ( t -> GetFlags ( ) & asOBJ_ENUM ) ) return 0 ; if ( index >= t -> enumValues . GetLength ( ) ) return 0 ; if ( outValue ) * outValue = t -> enumValues [ index ] -> value ; return t -> enumValues [ index ] -> name . AddressOf ( ) ; } int asCScriptEngine :: GetObjectTypeCount ( ) { return ( int ) registeredObjTypes . GetLength ( ) ; } asIObjectType * asCScriptEngine :: GetObjectTypeByIndex ( asUINT index ) { if ( index >= registeredObjTypes . GetLength ( ) ) return 0 ; return registeredObjTypes [ index ] ; } asIObjectType * asCScriptEngine :: GetObjectTypeById ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return 0 ; if ( dt -> GetObjectType ( ) && dt -> GetObjectType ( ) -> GetFlags ( ) & asOBJ_ENUM ) return 0 ; return dt -> GetObjectType ( ) ; } asIScriptFunction * asCScriptEngine :: GetFunctionDescriptorById ( int funcId ) { return GetScriptFunction ( funcId ) ; } bool asCScriptEngine :: IsTemplate@@ Type ( const char * name ) { for ( unsigned int n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) { return objectTypes [ n ] -> flags & asOBJ_TEMPLATE ? true : false ; } } return false ; } int asCScriptEngine :: AddConstantString ( const char * str , size_t len ) { for ( size_t n = 0 ; n < stringConstants . GetLength ( ) ; n ++ ) { if ( stringConstants [ n ] -> Compare ( str , len ) == 0 ) { return ( int ) n ; } } asCString * cstr = asNEW ( asCString ) ( str , len ) ; stringConstants . PushLast ( cstr ) ; asASSERT ( stringConstants . GetLength ( ) <= 65536 ) ; return ( int ) stringConstants . GetLength ( ) - 1 ; } const asCString & asCScriptEngine :: GetConstantString ( int id ) { return * stringConstants [ id ] ; } int asCScriptEngine :: GetScriptSectionNameIndex ( const char * name ) { for ( asUINT n = 0 ; n < scriptSectionNames . GetLength ( ) ; n ++ ) { if ( scriptSectionNames [ n ] -> Compare ( name ) == 0 ) return n ; } scriptSectionNames . PushLast ( asNEW ( asCString ) ( name ) ) ; return int ( scriptSectionNames . GetLength ( ) - 1 ) ; } END_AS_NAMESPACE </DOCUMENT>
<DOCUMENT_ID="boiled-sug@@ ar/mkvtool@@ nix/tree/master/src/output@@ /p_mpeg4_p2.cpp"> # include " common / common _ pch . h " # include " avilib . h " # include " common / codec . h " # include " common / endian . h " # include " common / hacks . h " # include " common / math . h " # include " common / strings / formatting . h " # include " merge / generic _ reader . h " # include " merge / output _ control . h " # include " output / p _ mpeg4 _ p2 . h " mpeg4_p2_video_packetizer_c :: mpeg4_p2_video_packetizer_c ( generic_rea@@ der_c * p_reader , track_info@@ _c & p_ti , double fps , int width , int height , bool input_is_native ) : video_for_windows_packetizer_c ( p_reader , p_ti , fps , width , height ) , m_timecodes_generated ( 0 ) , m_previous_timecode ( 0 ) , m_aspect_ratio_extracted ( false ) , m_input_is_native ( input_is_native ) , m_output_is_native ( hack_eng@@ aged ( ENGAGE_@@ NATIVE_MPEG4 ) || input_is_native ) , m_size_extracted ( false ) { if ( ! m_output_is_native ) m_timestamp_factory_application_mode = TFA_SHOR@@ T_QUEUEING ; else { set_codec_id ( MKV_V_@@ MPEG4_ASP ) ; if ( ! m_input_is_native ) m_ti . m_private_data . reset ( ) ; if ( m_ti . m_ext_timecodes . empty ( ) ) m_timestamp_factory . reset ( ) ; if ( m_default_duration_forced ) m_fps = 1000000000.0 / m_htrack_default_duration ; else if ( 0.0 != m_fps ) m_htrack_default_duration = static_cast < int64_t > ( 1000000000ll / m_fps ) ; m_timestamp_factory_application_mode = TFA_FULL_QUEUEING ; } } mpeg4_p2_video_packetizer_c :: ~ mpeg4_p2_video_packetizer_c ( ) { if ( ! debugging_@@ c :: requested ( " mpeg4 _ p2 _ statistics " ) ) return ; mxinfo ( boost :: format ( " mpeg4 _ p2 _ video _ packetiz@@ er _ c ▁ statistics : \n " " ▁ ▁ # ▁ I ▁ frames : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 1 % \n " " ▁ ▁ # ▁ P ▁ frames : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 2 % \n " " ▁ ▁ # ▁ B ▁ frames : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 3 % \n " " ▁ ▁ # ▁ NVOPs : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 4 % \n " " ▁ ▁ # ▁ generated ▁ timecodes : ▁ % 5 % \n " " ▁ ▁ # ▁ dropped ▁ timecodes : ▁ ▁ ▁ % 6 % \n " ) % m_statistics . m_num_i_frames % m_statistics . m_num_p_frames % m_statistics . m_num_b_frames % m_statistics . m_num_n_vops % m_statistics . m_num_generated_timecodes % m_statistics . m_num_dropped_timecodes ) ; } int mpeg4_p2_video_packetizer_c :: process ( packet_cptr packet ) { extract_size ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) ) ; extract_aspect_ratio ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) ) ; int result = m_input_is_native == m_output_is_native ? video_for_windows_packetizer_c :: process ( packet ) : m_input_is_native ? process_native ( packet ) : process_non_native ( packet ) ; ++ m_frames_output ; return result ; } int mpeg4_p2_video_packetizer_c :: process_non_native ( packet_cptr packet ) { extract_config_data ( packet ) ; if ( - 1 != packet -> timecode ) { if ( ! m_default_duration_forced ) m_available_timecodes . push_back ( timecode_duration_t ( packet -> timecode , packet -> duration ) ) ; else { m_available_timecodes . push_back ( timecode_duration_t ( m_timecodes_generated * m_htrack_default_duration , m_htrack_default_duration ) ) ; ++ m_timecodes_generated ; } } else if ( 0.0 == m_fps ) mxerror_tid ( m_ti . m_fname , m_ti . m_id , Y ( " Cannot ▁ convert ▁ non - native ▁ MPEG4 ▁ video ▁ frames ▁ into ▁ native ▁ ones ▁ if ▁ the ▁ source ▁ container ▁ " " provides ▁ neither ▁ timecodes ▁ nor ▁ a ▁ number ▁ of ▁ frames ▁ per ▁ second . \n " ) ) ; std :: vector < video_frame_t > frames ; mpeg4 :: p2 :: find_frame_@@ types ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) , frames , m_config_data ) ; for ( auto & frame : frames ) { if ( ! frame . is_coded ) { ++ m_statistics . m_num_n_vops ; int num_surplus_timecodes = static_cast < int > ( m_available_timecodes . size ( ) ) - static_cast < int > ( m_ref_frames . size ( ) + m_b_frames . size ( ) ) ; if ( 0 < num_surplus_timecodes ) { std :: deque < timecode_duration_t > :: iterator start = m_available_timecodes . begin ( ) + m_ref_frames . size ( ) + m_b_frames . size ( ) ; std :: deque < timecode_duration_t > :: iterator end = start + num_surplus_timecodes ; if ( 0 != ( m_ref_frames . size ( ) + m_b_frames . size ( ) ) ) { std :: deque < timecode_duration_t > :: iterator last = m_available_timecodes . begin ( ) + m_ref_frames . size ( ) + m_b_frames . size ( ) - 1 ; std :: deque < timecode_duration_t > :: iterator cur = start ; while ( cur != end ) { last -> m_duration = std :: max ( last -> m_duration , static_cast < int64_t > ( 0 ) ) + std :: max ( cur -> m_duration , static_cast < int64_t > ( 0 ) ) ; ++ cur ; } } m_available_timecodes . erase ( start , end ) ; m_statistics . m_num_dropped_timecodes += num_surplus_timecodes ; } continue ; } if ( FRAME_TYPE_I == frame . type ) ++ m_statistics . m_num_i_frames ; else if ( FRAME_TYPE_P == frame . type ) ++ m_statistics . m_num_p_frames ; else ++ m_statistics . m_num_b_frames ; if ( FRAME_TYPE_B != frame . type ) flush_frames ( false ) ; frame . data = ( unsigned char * ) safemem@@ dup ( packet -> data -> get_buffer ( ) + frame . pos , frame . size ) ; frame . timecode = - 1 ; if ( FRAME_TYPE_B == frame . type ) m_b_frames . push_back ( frame ) ; else m_ref_frames . push_back ( frame ) ; } m_previous_timecode = m_available_timecodes . back ( ) . m_timecode ; return FILE_STATUS_MOREDATA ; } void mpeg4_p2_video_packetizer_c :: extract_config_data ( packet_cptr & packet ) { if ( m_ti . m_private_data ) return ; m_ti . m_private_data = memory_cptr { mpeg4 :: p2 :: parse_config_data ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) , m_config_data ) } ; if ( ! m_ti . m_private_data ) mxerror_tid ( m_ti . m_fname , m_ti . m_id , Y ( " Could ▁ not ▁ find ▁ the ▁ codec ▁ configuration ▁ data ▁ in ▁ the ▁ first ▁ MPEG - 4 ▁ part ▁ 2 ▁ video ▁ frame . ▁ This ▁ track ▁ cannot ▁ be ▁ stored ▁ in ▁ native ▁ mode . \n " ) ) ; fix_codec_string ( ) ; set_codec_private ( m_ti . m_private_data ) ; rerender_track_headers ( ) ; } void mpeg4_p2_video_packetizer_c :: fix_codec_string ( ) { static const unsigned char start_code [ 4 ] = { 0x00 , 0x00 , 0x01 , 0xb2 } ; if ( ! m_ti . m_private_data || ( 0 == m_ti . m_private_data -> get_size ( ) ) ) return ; auto private_data = m_ti . m_private_data -> get_buffer ( ) ; int size = m_ti . m_private_data -> get_size ( ) ; int i ; for ( i = 0 ; 9 < size ; ) { if ( memcmp ( & private_data [ i ] , start_code , 4 ) != 0 ) { ++ i ; -- size ; continue ; } i += 8 ; size -= 8 ; if ( strncasecmp ( ( const char * ) & private_data [ i - 4 ] , " divx " , 4 ) != 0 ) continue ; unsigned char * end_pos = ( unsigned char * ) memchr ( & private_data [ i ] , 0 , size ) ; if ( ! end_pos ) end_pos = & private_data [ i + size ] ; -- end_pos ; if ( ' p ' == * end_pos ) * end_pos = ' n ' ; return ; } } int mpeg4_p2_video_packetizer_c :: process_native ( packet_cptr ) { return FILE_STATUS_MOREDATA ; } void mpeg4_p2_video_packetizer_c :: generate_timecode_and_duration ( ) { if ( 0.0 >= m_fps ) { mxexit ( 1 ) ; } if ( m_available_timecodes . empty ( ) ) { m_previous_timecode = ( int64_t ) ( m_previous_timecode + 1000000000.0 / m_fps ) ; m_available_timecodes . push_back ( timecode_duration_t ( m_previous_timecode , ( int64_t ) ( 1000000000.0 / m_fps ) ) ) ; mxverb ( 3 , boost :: format ( " mpeg4 _ p2 : : flush _ frames ( ) : ▁ Needed ▁ new ▁ timecode ▁ % 1 % \n " ) % m_previous_timecode ) ; ++ m_statistics . m_num_generated_timecodes ; } } void mpeg4_p2_video_packetizer_c :: get_next_timecode_and_duration ( int64_t & timecode , int64_t & duration ) { if ( m_available_timecodes . empty ( ) ) generate_timecode_and_duration ( ) ; timecode = m_available_timecodes . front ( ) . m_timecode ; duration = m_available_timecodes . front ( ) . m_duration ; m_available_timecodes . pop_front ( ) ; } void mpeg4_p2_video_packetizer_c :: flush_frames ( bool end_of_file ) { if ( m_ref_frames . empty ( ) ) return ; if ( m_ref_frames . size ( ) == 1 ) { video_frame_t & frame = m_ref_frames . front ( ) ; if ( - 1 == frame . timecode ) { get_next_timecode_and_duration ( frame . timecode , frame . duration ) ; add_packet ( new packet_t ( new memory_c ( frame . data , frame . size , true ) , frame . timecode , frame . duration ) ) ; } return ; } video_frame_t & bref_frame = m_ref_frames . front ( ) ; video_frame_t & fref_frame = m_ref_frames . back ( ) ; for ( auto & frame : m_b_frames ) get_next_timecode_and_duration ( frame . timecode , frame . duration ) ; get_next_timecode_and_duration ( fref_frame . timecode , fref_frame . duration ) ; add_packet ( new packet_t ( new memory_c ( fref_frame . data , fref_frame . size , true ) , fref_frame . timecode , fref_frame . duration , FRAME_TYPE_P == fref_frame . type ? bref_frame . timecode : VFT_IFRAME ) ) ; for ( auto & frame : m_b_frames ) add_packet ( new packet_t ( new memory_c ( frame . data , frame . size , true ) , frame . timecode , frame . duration , bref_frame . timecode , fref_frame . timecode ) ) ; m_ref_frames . pop_front ( ) ; m_b_frames . clear ( ) ; if ( end_of_file ) m_ref_frames . clear ( ) ; } void mpeg4_p2_video_packetizer_c :: flush_impl ( ) { flush_frames ( true ) ; } void mpeg4_p2_video_packetizer_c :: extract_aspect_ratio ( const unsigned char * buffer , int size ) { if ( m_aspect_ratio_extracted ) return ; if ( ( 0 != m_connected_to ) || display_dimen@@ sions_or_@@ aspect_ratio_set ( ) ) { m_aspect_ratio_extracted = true ; return ; } uint32_t num , den ; if ( mpeg4 :: p2 :: extract_par ( buffer , size , num , den ) ) { m_aspect_ratio_extracted = true ; set_video_@@ aspect_ratio ( ( double ) m_hvideo_pixel_width / ( double ) m_hvideo_pixel_height * ( double ) num / ( double ) den , false , OPTION@@ _SOURCE_BITSTREAM ) ; generic_packetizer_c :: set_headers ( ) ; rerender_track_headers ( ) ; mxinfo_tid ( m_ti . m_fname , m_ti . m_id , boost :: format ( Y ( " Extracted ▁ the ▁ aspect ▁ ratio ▁ information ▁ from ▁ the ▁ MPEG4 ▁ layer ▁ 2 ▁ video ▁ data ▁ and ▁ set ▁ the ▁ display ▁ dimensions ▁ to ▁ % 1 % / %2 % . \n " ) ) % m_hvideo_display_width % m_hvideo_display_height ) ; } else if ( 50 <= m_frames_output ) m_aspect_ratio_extracted = true ; } void mpeg4_p2_video_packetizer_c :: extract_size ( const unsigned char * buffer , int size ) { if ( m_size_extracted ) return ; if ( 0 != m_connected_to ) { m_size_extracted = true ; return ; } uint32_t xtr_width , xtr_height ; if ( mpeg4 :: p2 :: extract_size ( buffer , size , xtr_width , xtr_height ) ) { m_size_extracted = true ; if ( ! m_reader -> m_appending && ( ( xtr_width != static_cast < uint32_t > ( m_hvideo_pixel_width ) ) || ( xtr_height != static_cast < uint32_t > ( m_hvideo_pixel_height ) ) ) ) { set_video_pixel_width ( xtr_width ) ; set_video_pixel_height ( xtr_height ) ; if ( ! m_output_is_native && m_ti . m_private_data && ( sizeof ( alBITMAPINFOHEADER ) <= m_ti . m_private_data -> get_size ( ) ) ) { auto bih = reinterpret_cast < alBITMAPINFOHEADER * > ( m_ti . m_private_data -> get_buffer ( ) ) ; put_uint32_le ( & bih -> bi_width , xtr_width ) ; put_uint32_le ( & bih -> bi_height , xtr_height ) ; set_codec_private ( m_ti . m_private_data ) ; } m_hvideo_display_width = - 1 ; m_hvideo_display_height = - 1 ; generic_packetizer_c :: set_headers ( ) ; rerender_track_headers ( ) ; mxinfo_tid ( m_ti . m_fname , m_ti . m_id , boost :: format ( Y ( " The ▁ extracted ▁ values ▁ for ▁ video ▁ width ▁ and ▁ height ▁ from ▁ the ▁ MPEG4 ▁ layer ▁ 2 ▁ video ▁ data ▁ bitstream ▁ differ ▁ from ▁ what ▁ the ▁ values ▁ " " in ▁ the ▁ source ▁ container . ▁ The ▁ ones ▁ from ▁ the ▁ video ▁ data ▁ bitstream ▁ ( %1 % x % 2 % ) ▁ will ▁ be ▁ used . \n " ) ) % xtr_width % xtr_height ) ; } } else if ( 50 <= m_frames_output ) m_aspect_ratio_extracted = true ; } </DOCUMENT>
<DOCUMENT_ID="Ste@@ venBlack/phantomjs/tree/master/src/qt/qtwebkit/Source/WebCore/platform/@@ audio/AudioFIFO.cpp"> # include " config . h " # if ENABLE ( WEB_AUDIO ) # include " AudioFIFO . h " namespace WebCore { AudioFIFO :: AudioFIFO ( unsigned numberOfChannels , size_t fifoLength ) : m_fifoAudioBus ( AudioBus :: create ( numberOfChannels , fifoLength ) ) , m_fifoLength ( fifoLength ) , m_framesInFifo ( 0 ) , m_readIndex ( 0 ) , m_writeIndex ( 0 ) { } void AudioFIFO :: consume ( AudioBus * destination , size_t framesToConsume ) { bool isGood = destination && ( framesToConsume <= m_fifoLength ) && ( framesToConsume <= m_framesInFifo ) && ( destination -> length ( ) >= framesToConsume ) ; ASSERT ( isGood ) ; if ( ! isGood ) return ; size_t part1Length ; size_t part2Length ; findWrapLengths ( m_readIndex , framesToConsume , part1Length , part2Length ) ; size_t numberOfChannels = m_fifoAudioBus -> numberOfChannels ( ) ; for ( size_t channelIndex = 0 ; channelIndex < numberOfChannels ; ++ channelIndex ) { float * destinationData = destination -> channel ( channelIndex ) -> mutableData ( ) ; const float * sourceData = m_fifoAudioBus -> channel ( channelIndex ) -> data ( ) ; bool isCopyGood = ( ( m_readIndex < m_fifoLength ) && ( m_readIndex + part1Length ) <= m_fifoLength && ( part1Length <= destination -> length ( ) ) && ( part1Length + part2Length ) <= destination -> length ( ) ) ; ASSERT ( isCopyGood ) ; if ( ! isCopyGood ) return ; memcpy ( destinationData , sourceData + m_readIndex , part1Length * sizeof ( * sourceData ) ) ; if ( part2Length ) memcpy ( destinationData + part1Length , sourceData , part2Length * sizeof ( * sourceData ) ) ; } m_readIndex = updateIndex ( m_readIndex , framesToConsume ) ; ASSERT ( m_framesInFifo >= framesToConsume ) ; m_framesInFifo -= framesToConsume ; } void AudioFIFO :: push ( const AudioBus * sourceBus ) { bool isGood = sourceBus && ( m_framesInFifo + sourceBus -> length ( ) <= m_fifoLength ) ; if ( ! isGood ) return ; size_t sourceLength = sourceBus -> length ( ) ; size_t part1Length ; size_t part2Length ; findWrapLengths ( m_writeIndex , sourceLength , part1Length , part2Length ) ; size_t numberOfChannels = m_fifoAudioBus -> numberOfChannels ( ) ; for ( size_t channelIndex = 0 ; channelIndex < numberOfChannels ; ++ channelIndex ) { float * destination = m_fifoAudioBus -> channel ( channelIndex ) -> mutableData ( ) ; const float * source = sourceBus -> channel ( channelIndex ) -> data ( ) ; bool isCopyGood = ( ( m_writeIndex < m_fifoLength ) && ( m_writeIndex + part1Length ) <= m_fifoLength && part2Length < m_fifoLength && part1Length + part2Length <= sourceLength ) ; ASSERT ( isCopyGood ) ; if ( ! isCopyGood ) return ; memcpy ( destination + m_writeIndex , source , part1Length * sizeof ( * destination ) ) ; if ( part2Length ) memcpy ( destination , source + part1Length , part2Length * sizeof ( * destination ) ) ; } m_framesInFifo += sourceLength ; ASSERT ( m_framesInFifo <= m_fifoLength ) ; m_writeIndex = updateIndex ( m_writeIndex , sourceLength ) ; } void AudioFIFO :: findWrapLengths ( size_t index , size_t size , size_t & part1Length , size_t & part2Length ) { ASSERT_WI@@ TH_SEC@@ URITY_@@ IMPLICATION ( index < m_fifoLength && size <= m_fifoLength ) ; if ( index < m_fifoLength && size <= m_fifoLength ) { if ( index + size > m_fifoLength ) { part1Length = m_fifoLength - index ; part2Length = size - part1Length ; } else { part1Length = size ; part2Length = 0 ; } } else { part1Length = 0 ; part2Length = 0 ; } } } # endif </DOCUMENT>
<DOCUMENT_ID="Gre@@ ymane/SkyFire@@ EMU/tree/master/dep/acelite/ace/@@ OS_NS_@@ errno.cpp"> # include " ace / OS _ NS _ errno . h " # if ! defined ( ACE_HAS_INLIN@@ ED_OSCALL@@ S ) # include " ace / OS _ NS _ errno . inl " # endif </DOCUMENT>
<DOCUMENT_ID="jbrains/@@ trivia/tree/master/C++/@@ GameRunner@@ .cpp"> # include < stdlib . h > # include " Game . h " static bool notAWinner ; int main ( ) { Game aGame ; aGame . add ( " Chet " ) ; aGame . add ( " Pat " ) ; aGame . add ( " Sue " ) ; do { aGame . roll ( rand ( ) % 5 + 1 ) ; if ( rand ( ) % 9 == 7 ) { notAWinner = aGame . wrongAnsw@@ er ( ) ; } else { notAWinner = aGame . wasCorrect@@ lyAnsw@@ ered ( ) ; } } while ( notAWinner ) ; } </DOCUMENT>
<DOCUMENT_ID="pokowak@@ a/xbmc/tree/master/xbmc/@@ filesystem@@ /MusicDatabaseDirectory/Directory@@ NodeAlbumCompilations.cpp"> # include " DirectoryNodeAlbumCompilations . h " # include " QueryParams . h " # include " music / MusicDatabase . h " using namespace XFILE :: MUSICDATABASEDI@@ RECTORY ; CDirectoryNodeAlbumCompilations :: CDirectoryNodeAlbumCompilations ( const std :: string & strName , CDirectoryNode * pParent ) : CDirectoryNode ( NODE_TYPE_ALBUM_COMPILATIONS , strName , pParent ) { } NODE_TYPE CDirectoryNodeAlbumCompilations :: GetChildType ( ) const { if ( GetName ( ) == " - 1" ) return NODE_TYPE_ALBUM_COMPILATIONS_SONGS ; return NODE_TYPE_SONG ; } std :: string CDirectoryNodeAlbumCompilations :: GetLocalizedName ( ) const { if ( GetID ( ) == - 1 ) return g_localizeStrings . Get ( 15102 ) ; CMusicDatabase db ; if ( db . Open ( ) ) return db . GetAlbumById ( GetID ( ) ) ; return " " ; } bool CDirectoryNodeAlbumCompilations :: GetContent ( CFileItemList & items ) const { CMusicDatabase musicdatabase ; if ( ! musicdatabase . Open ( ) ) return false ; CQueryParams params ; CollectQueryParams ( params ) ; bool bSuccess = musicdatabase . GetCompilationAlbum@@ s ( BuildPath ( ) , items ) ; musicdatabase . Close ( ) ; return bSuccess ; } </DOCUMENT>
<DOCUMENT_ID="cel@@ eron55/clementine/tree/master/3rd@@ party/libproject@@ m/Ren@@ derer/Pipel@@ ine.cpp"> # include " Pipeline . hpp " # include " wipemalloc . h " Pipeline :: Pipeline ( ) : staticPerPixel ( false ) , gx ( 0 ) , gy ( 0 ) , blur1n ( 1 ) , blur2n ( 1 ) , blur3n ( 1 ) , blur1x ( 1 ) , blur2x ( 1 ) , blur3x ( 1 ) , blur1ed ( 1 ) { } void Pipeline :: setStaticPerPixel ( int gx , int gy ) { staticPerPixel = true ; this -> gx = gx ; this -> gy = gy ; this -> x_mesh = ( float * * ) wipemalloc ( gx * sizeof ( float * ) ) ; for ( int x = 0 ; x < gx ; x ++ ) { this -> x_mesh [ x ] = ( float * ) wipemalloc ( gy * sizeof ( float ) ) ; } this -> y_mesh = ( float * * ) wipemalloc ( gx * sizeof ( float * ) ) ; for ( int x = 0 ; x < gx ; x ++ ) { this -> y_mesh [ x ] = ( float * ) wipemalloc ( gy * sizeof ( float ) ) ; } } Pipeline :: ~ Pipeline ( ) { if ( staticPerPixel ) { for ( int x = 0 ; x < this -> gx ; x ++ ) { free ( this -> x_mesh [ x ] ) ; free ( this -> y_mesh [ x ] ) ; } free ( x_mesh ) ; free ( y_mesh ) ; } } PixelPoint Pipeline :: PerPixel ( PixelPoint p , const PerPixelContext context ) { return p ; } </DOCUMENT>
<DOCUMENT_ID="Rudi97@@ 19/cur@@ ly-octo-@@ barnacle/tree/master/TrinityCore@@ /src/server/@@ scripts/Northrend/@@ Nexus/Nexus/@@ boss_ormorok.cpp"> # include " ScriptMgr . h " # include " ScriptedCreature . h " # include " nexus . h " # include " SpellScript . h " enum Spells { SPELL_SPELL_REFLECTION = 47981 , SPELL_TRAMPLE = 48016 , SPELL_FRENZY = 48017 , SPELL_SUMMON_CRYSTALLINE_TANGLER = 61564 , SPELL_CRYSTAL_SPIKES = 47958 , } ; enum Yells { SAY_AGGRO = 1 , SAY_DEATH = 2 , SAY_REFLECT = 3 , SAY_CRYSTAL_SPIKES = 4 , SAY_KILL = 5 , SAY_FRENZY = 6 } ; enum Events { EVENT_CRYSTAL_SPIKES = 1 , EVENT_TRAMPLE = 2 , EVENT_SPELL_REFLECTION = 3 , EVENT_CRYSTALLINE_TANGLER = 4 , } ; class OrmorokTanglerPredicate { public : OrmorokTanglerPredicate ( Unit * unit ) : me ( unit ) { } bool operator ( ) ( WorldObject * object ) const { return object -> GetDistance2d ( me ) >= 5.0f ; } private : Unit * me ; } ; class boss_ormorok : public CreatureScript { public : boss_ormorok ( ) : CreatureScript ( " boss _ ormorok " ) { } struct boss_ormorokAI : public BossAI { boss_ormorokAI ( Creature * creature ) : BossAI ( creature , DATA_ORMO@@ ROK ) { Initialize ( ) ; } void Initialize ( ) { frenzy = false ; } void Reset ( ) override { BossAI :: Reset ( ) ; Initialize ( ) ; } void EnterCombat ( Unit * ) override { _EnterCombat ( ) ; events . ScheduleEvent ( EVENT_CRYSTAL_SPIKES , 12000 ) ; events . ScheduleEvent ( EVENT_TRAMPLE , 10000 ) ; events . ScheduleEvent ( EVENT_SPELL_REFLECTION , 30000 ) ; if ( IsHer@@ oic ( ) ) events . ScheduleEvent ( EVENT_CRYSTALLINE_TANGLER , 17000 ) ; Talk ( SAY_AGGRO ) ; } void DamageTaken ( Unit * , uint32 & ) override { if ( ! frenzy && HealthBelow@@ Pct ( 25 ) ) { Talk ( SAY_FRENZY ) ; DoCast ( me , SPELL_FRENZY ) ; frenzy = true ; } } void JustDied ( Unit * ) override { _JustDied ( ) ; Talk ( SAY_DEATH ) ; } void KilledUnit ( Unit * who ) override { if ( who -> GetTypeId ( ) == TYPEID_PLAYER ) Talk ( SAY_KILL ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; while ( uint32 eventId = events . ExecuteEvent ( ) ) { switch ( eventId ) { case EVENT_TRAMPLE : DoCast ( me , SPELL_TRAMPLE ) ; events . ScheduleEvent ( EVENT_TRAMPLE , 10000 ) ; break ; case EVENT_SPELL_REFLECTION : Talk ( SAY_REFLECT ) ; DoCast ( me , SPELL_SPELL_REFLECTION ) ; events . ScheduleEvent ( EVENT_SPELL_REFLECTION , 30000 ) ; break ; case EVENT_CRYSTAL_SPIKES : Talk ( SAY_CRYSTAL_SPIKES ) ; DoCast ( SPELL_CRYSTAL_SPIKES ) ; events . ScheduleEvent ( EVENT_CRYSTAL_SPIKES , 12000 ) ; break ; case EVENT_CRYSTALLINE_TANGLER : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , OrmorokTanglerPredicate ( me ) ) ) DoCast ( target , SPELL_SUMMON_CRYSTALLINE_TANGLER ) ; events . ScheduleEvent ( EVENT_CRYSTALLINE_TANGLER , 17000 ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } private : bool frenzy ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetInstanceAI < boss_ormorokAI > ( creature ) ; } } ; enum CrystalSpik@@ es { NPC_CRYSTAL_SPIKE_INITIAL = 27101 , NPC_CRYSTAL_SPIKE_TRIGGER = 27079 , DATA_COUNT = 1 , MAX_COUNT = 5 , SPELL_CR@@ YSTAL_SPIKE_DAMAGE = 47944 , GO_CRYSTAL_SPIKE_TRAP = 188537 , } ; uint32 const crystalSpikeSummon [ 3 ] = { 47936 , 47942 , 47943 } ; class npc_crystal_spike_trigger : public CreatureScript { public : npc_crystal_spike_trigger ( ) : CreatureScript ( " npc _ crystal _ spike _ trigger " ) { } struct npc_crystal_spike_triggerAI : public ScriptedAI { npc_crystal_spike_triggerAI ( Creature * creature ) : ScriptedAI ( creature ) { _count = 0 ; _despawntimer = 0 ; } void IsSummonedBy ( Unit * owner ) override { switch ( me -> GetEntry ( ) ) { case NPC_CRYSTAL_SPIKE_INITIAL : _count = 0 ; me -> SetFacingToObject ( owner ) ; break ; case NPC_CRYSTAL_SPIKE_TRIGGER : if ( Creature * trigger = owner -> ToCreature ( ) ) _count = trigger -> AI ( ) -> GetData ( DATA_COUNT ) + 1 ; break ; default : _count = MAX_COUNT ; break ; } if ( me -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_TRIGGER ) if ( GameObject * trap = me -> FindNearestGameObject ( GO_CRYSTAL_SPIKE_TRAP , 1.0f ) ) trap -> Use ( me ) ; _despawntimer = 2000 ; } uint32 GetData ( uint32 type ) const override { return type == DATA_COUNT ? _count : 0 ; } void UpdateAI ( uint32 diff ) override { if ( _despawntimer <= diff ) { if ( me -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_TRIGGER ) if ( GameObject * trap = me -> FindNearestGameObject ( GO_CRYSTAL_SPIKE_TRAP , 1.0f ) ) trap -> Delete ( ) ; me -> DespawnOrUnsummon ( ) ; } else _despawntimer -= diff ; } private : uint32 _count ; uint32 _despawntimer ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return new npc_crystal_spike_triggerAI ( creature ) ; } } ; class spell_crystal_spike : public SpellScriptLoader { public : spell_crystal_spike ( ) : SpellScriptLoader ( " spell _ crystal _ spike " ) { } class spell_crystal_spike_AuraScript : public AuraScript { PrepareAuraScript ( spell_crystal_spike_AuraScript ) ; void HandlePeriodic ( AuraEffect const * ) { Unit * target = GetTarget ( ) ; if ( target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_INITIAL || target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_TRIGGER ) if ( Creature * trigger = target -> ToCreature ( ) ) { uint32 spell = target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_INITIAL ? crystalSpikeSummon [ 0 ] : crystalSpikeSummon [ urand ( 0 , 2 ) ] ; if ( trigger -> AI ( ) -> GetData ( DATA_COUNT ) < MAX_COUNT ) trigger -> CastSpell ( trigger , spell , true ) ; } } void Register ( ) override { OnEffectPeriodic += AuraEffectPeriodicFn ( spell_crystal_spike_AuraScript :: HandlePeriodic , EFFECT_0 , SPELL_AURA_PERIODIC_DUMMY ) ; } } ; AuraScript * GetAuraScript ( ) const override { return new spell_crystal_spike_AuraScript ( ) ; } } ; void AddSC_boss_ormorok ( ) { new boss_ormorok ( ) ; new npc_crystal_spike_trigger ( ) ; new spell_crystal_spike ( ) ; } </DOCUMENT>
<DOCUMENT_ID="hbwh@@ lklive@@ /color-emoji.skia/tree/master/src/ports/SkGlobal@@ Initialization@@ _chromium.cpp"> # include " SkBitmapProcShader . h " # include " SkBlurImageFilter . h " # include " SkBlurMaskFilter . h " # include " SkColorFilter . h " # include " SkCornerPathEffect . h " # include " SkDashPathEffect . h " # include " SkGradientShader . h " # include " SkLayerDrawLooper . h " # include " SkMallocPixelRef . h " # include " SkXfermode . h " # include " SkMagnifierImageFilter . h " void SkFlatt@@ enable :: InitializeFlattenables ( ) { SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkBitmapProcShader ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkBlurImageFilter ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkCornerPathEffect ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkDashPathEffect ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkLayerDrawLooper ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkMallocPixelRef ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkMagnifierImageFilter ) SkBlurMaskFilter :: InitializeFlattenables ( ) ; SkColorFilter :: InitializeFlattenables ( ) ; SkGradientShader :: InitializeFlattenables ( ) ; SkXfermode :: InitializeFlattenables ( ) ; } </DOCUMENT>
<DOCUMENT_ID="krf/@@ kdevelop/tree/master/debugger@@ s/gdb@@ /printers/@@ tests/qmap@@ int.cpp"> # include < QMap > int main ( ) { QMap < int , int > m ; m [ 10 ] = 100 ; m [ 20 ] = 200 ; m [ 30 ] = 300 ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="Residenti@@ k/TestingRepo@@ /tree/master/src/server/scripts/EasternKingdoms/Blackrock@@ Mountain/Blackrock@@ Depths/boss_high_interrogator_gerstahn@@ .cpp"> # include " ScriptMgr . h " # include " ScriptedCreature . h " enum Spells { SPELL_SHADOWWORDPAIN = 10894 , SPELL_MANABURN = 10876 , SPELL_PSYCHICSCREAM = 8122 , SPELL_SHADOWSHIELD = 22417 } ; class boss_high_interrogator_gerstahn : public CreatureScript { public : boss_high_interrogator_gerstahn ( ) : CreatureScript ( " boss _ high _ interrogator _ gerstahn " ) { } CreatureAI * GetAI ( Creature * creature ) const OVERRIDE { return new boss_high_interrogator_gerstahnAI ( creature ) ; } struct boss_high_interrogator_gerstahnAI : public ScriptedAI { boss_high_interrogator_gerstahnAI ( Creature * creature ) : ScriptedAI ( creature ) { } uint32 ShadowWordPain_Timer ; uint32 ManaBurn_Timer ; uint32 PsychicScream_Timer ; uint32 ShadowShield_Timer ; void Reset ( ) OVERRIDE { ShadowWordPain_Timer = 4000 ; ManaBurn_Timer = 14000 ; PsychicScream_Timer = 32000 ; ShadowShield_Timer = 8000 ; } void EnterCombat ( Unit * ) OVERRIDE { } void UpdateAI ( uint32 diff ) OVERRIDE { if ( ! UpdateVictim ( ) ) return ; if ( ShadowWordPain_Timer <= diff ) { if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 100 , true ) ) DoCast ( target , SPELL_SHADOWWORDPAIN ) ; ShadowWordPain_Timer = 7000 ; } else ShadowWordPain_Timer -= diff ; if ( ManaBurn_Timer <= diff ) { if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 100 , true ) ) DoCast ( target , SPELL_MANABURN ) ; ManaBurn_Timer = 10000 ; } else ManaBurn_Timer -= diff ; if ( PsychicScream_Timer <= diff ) { DoCastVictim ( SPELL_PSYCHICSCREAM ) ; PsychicScream_Timer = 30000 ; } else PsychicScream_Timer -= diff ; if ( ShadowShield_Timer <= diff ) { DoCast ( me , SPELL_SHADOWSHIELD ) ; ShadowShield_Timer = 25000 ; } else ShadowShield_Timer -= diff ; DoMeleeAttackIfReady ( ) ; } } ; } ; void AddSC_boss_high_interrogator_gerstahn ( ) { new boss_high_interrogator_gerstahn ( ) ; } </DOCUMENT>
<DOCUMENT_ID="root@@ -mirror/root@@ /tree/master/interpre@@ ter/llvm/src/tools/@@ llvm-pdbutil/@@ PrettyExternalSymbolDumper.cpp"> # include " PrettyExternalSymbolDumper . h " # include " LinePrinter . h " # include " llvm / DebugInfo / PDB / PDBSymbolExe . h " # include " llvm / DebugInfo / PDB / PDBSymbolPublicSymbol . h " # include " llvm / Support / Format . h " using namespace llvm ; using namespace llvm :: pdb ; ExternalSymbolDumper :: ExternalSymbolDumper ( LinePrinter & P ) : PDBSymDump@@ er ( true ) , Printer ( P ) { } void ExternalSymbolDumper :: start ( const PDBSymbolExe & Symbol ) { auto Vars = Symbol . findAllChildren < PDBSymbolPublicSymbol > ( ) ; while ( auto Var = Vars -> getNext ( ) ) Var -> dump ( * this ) ; } void ExternalSymbolDumper :: dump ( const PDBSymbolPublicSymbol & Symbol ) { std :: string LinkageName = Symbol . getName ( ) ; if ( Printer . IsSymbol@@ Excluded ( LinkageName ) ) return ; Printer . NewLine ( ) ; uint64_t Addr = Symbol . getVirtualAddress ( ) ; Printer << " [ " ; WithColor ( Printer , PDB_ColorItem :: Address ) . get ( ) << format_he@@ x ( Addr , 10 ) ; Printer << " ] ▁ " ; WithColor ( Printer , PDB_ColorItem :: Identifier ) . get ( ) << LinkageName ; } </DOCUMENT>
<DOCUMENT_ID="eriser/@@ Obxd/tree/master/@@ JuceLibraryCode/modules/juce_box2d/box2d/@@ Common/b2StackAllocator.cpp"> # include " b2StackAllocator . h " # include " b2Math . h " b2StackAllocator :: b2StackAllocator ( ) { m_index = 0 ; m_allocation = 0 ; m_maxAllocation = 0 ; m_entryCount = 0 ; } b2StackAllocator :: ~ b2StackAllocator ( ) { b2Assert ( m_index == 0 ) ; b2Assert ( m_entryCount == 0 ) ; } void * b2StackAllocator :: Allocate ( int32 size ) { b2Assert ( m_entryCount < b2_maxStack@@ Entries ) ; b2StackEntry * entry = m_entries + m_entryCount ; entry -> size = size ; if ( m_index + size > b2_stackSize ) { entry -> data = ( char * ) b2Alloc ( size ) ; entry -> usedMalloc = true ; } else { entry -> data = m_data + m_index ; entry -> usedMalloc = false ; m_index += size ; } m_allocation += size ; m_maxAllocation = b2Max ( m_maxAllocation , m_allocation ) ; ++ m_entryCount ; return entry -> data ; } void b2StackAllocator :: Free ( void * p ) { b2Assert ( m_entryCount > 0 ) ; b2StackEntry * entry = m_entries + m_entryCount - 1 ; b2Assert ( p == entry -> data ) ; if ( entry -> usedMalloc ) { b2Free ( p ) ; } else { m_index -= entry -> size ; } m_allocation -= entry -> size ; -- m_entryCount ; p = NULL ; } int32 b2StackAllocator :: GetMaxAllocation ( ) const { return m_maxAllocation ; } </DOCUMENT>
<DOCUMENT_ID="murrayme@@ ehan/mar@@ syas/tree/master/src/@@ otherlibs/@@ ANN/kd_@@ pr_search@@ .cpp"> # include " kd _ pr _ search . h " double ANNprEps ; int ANNprDim ; ANNpoint ANNprQ ; double ANNprMaxErr ; ANNpointArray ANNprPts ; ANNpr_queue * ANNprBoxPQ ; ANNmin_k * ANNprPointMK ; void ANNkd_tree :: annkPri@@ Search ( ANNpoint q , int k , ANNidx@@ Array nn_idx , ANNdist@@ Array dd , double eps ) { ANNprMaxErr = ANN_POW ( 1.0 + eps ) ; ANN_FLOP ( 2 ) ANNprDim = dim ; ANNprQ = q ; ANNprPts = pts ; ANNptsVisited = 0 ; ANNprPointMK = new ANNmin_k ( k ) ; ANNdist box_dist = annBox@@ Distance ( q , bnd_box_lo , bnd_box_hi , dim ) ; ANNprBoxPQ = new ANNpr_queue ( n_pts ) ; ANNprBoxPQ -> insert ( box_dist , root ) ; while ( ANNprBoxPQ -> non_empty ( ) && ( ! ( ANNmaxPtsVisited != 0 && ANNptsVisited > ANNmaxPtsVisited ) ) ) { ANNkd_ptr np ; ANNprBoxPQ -> extr_min ( box_dist , ( void * & ) np ) ; ANN_FLOP ( 2 ) if ( box_dist * ANNprMaxErr >= ANNprPointMK -> max_key ( ) ) break ; np -> ann_pri_search ( box_dist ) ; } for ( int i = 0 ; i < k ; i ++ ) { dd [ i ] = ANNprPointMK -> ith_smallest_key ( i ) ; nn_idx [ i ] = ANNprPointMK -> ith_smallest_info ( i ) ; } delete ANNprPointMK ; delete ANNprBoxPQ ; } void ANNkd_split :: ann_pri_search ( ANNdist box_dist ) { ANNdist new_dist ; ANNcoord cut_diff = ANNprQ [ cut_dim ] - cut_val ; if ( cut_diff < 0 ) { ANNcoord box_diff = cd_bnds [ ANN_LO ] - ANNprQ [ cut_dim ] ; if ( box_diff < 0 ) box_diff = 0 ; new_dist = ( ANNdist ) ANN_SUM ( box_dist , ANN_DIFF ( ANN_POW ( box_diff ) , ANN_POW ( cut_diff ) ) ) ; if ( child [ ANN_HI ] != KD_TRIVIAL ) ANNprBoxPQ -> insert ( new_dist , child [ ANN_HI ] ) ; child [ ANN_LO ] -> ann_pri_search ( box_dist ) ; } else { ANNcoord box_diff = ANNprQ [ cut_dim ] - cd_bnds [ ANN_HI ] ; if ( box_diff < 0 ) box_diff = 0 ; new_dist = ( ANNdist ) ANN_SUM ( box_dist , ANN_DIFF ( ANN_POW ( box_diff ) , ANN_POW ( cut_diff ) ) ) ; if ( child [ ANN_LO ] != KD_TRIVIAL ) ANNprBoxPQ -> insert ( new_dist , child [ ANN_LO ] ) ; child [ ANN_HI ] -> ann_pri_search ( box_dist ) ; } ANN_SP@@ L ( 1 ) ANN_FLOP ( 8 ) } void ANNkd_leaf :: ann_pri_search ( ANNdist box_dist ) { register ANNdist dist ; register ANNcoord * pp ; register ANNcoord * qq ; register ANNdist min_dist ; register ANNcoord t ; register int d ; min_dist = ANNprPointMK -> max_key ( ) ; for ( int i = 0 ; i < n_pts ; i ++ ) { pp = ANNprPts [ bkt [ i ] ] ; qq = ANNprQ ; dist = 0 ; for ( d = 0 ; d < ANNprDim ; d ++ ) { ANN_CO@@ ORD ( 1 ) ANN_FLOP ( 4 ) t = * ( qq ++ ) - * ( pp ++ ) ; if ( ( dist = ANN_SUM ( dist , ANN_POW ( t ) ) ) > min_dist ) { break ; } } if ( d >= ANNprDim && ( ANN_ALLOW_S@@ ELF_MATCH || dist != 0 ) ) { ANNprPointMK -> insert ( dist , bkt [ i ] ) ; min_dist = ANNprPointMK -> max_key ( ) ; } } ANN_LEA@@ F ( 1 ) ANN_PTS ( n_pts ) ANNptsVisited += n_pts ; } </DOCUMENT>
<DOCUMENT_ID="attack@@ jz/Cocos2d-x_C@@ ustomSliderList@@ /tree/master/Custom@@ SliderList/cocos2d/cocos/@@ platform/winrt/CCFreeType@@ Font.cpp"> # include " CCFreeTypeFont . h " # include " base / CCDirector . h " # include " platform / CCFileUtils . h " # if ( CC_TARGET_PLATFORM != CC_PLATFORM_WP8 ) # include < dwrite . h > # endif # include < map > # include < string > # include < sstream > # include < vector > # include < memory > # include < algorithm > using namespace std ; NS_CC_BEGIN static map < std :: string , FontBufferInfo > s_fontsNames ; static FT_Library s_FreeTypeLibrary = nullptr ; CCFreeTypeFont :: CCFreeTypeFont ( ) : m_space ( " ▁ " ) , m_face ( nullptr ) { } CCFreeTypeFont :: ~ CCFreeTypeFont ( ) { reset ( ) ; } void CCFreeTypeFont :: reset ( ) { for ( auto line : m_lines ) { line -> glyphs . clear ( ) ; delete line ; } m_lines . clear ( ) ; if ( m_face ) { FT_Done_Face ( m_face ) ; m_face = nullptr ; } } unsigned char * CCFreeTypeFont :: initWithString ( const char * text , const FontDefinition & textDefinition , Device :: TextAlign align , int & width , int & height , ssize_t & dataLength ) { FT_Error error = 0 ; ssize_t size = 0 ; unsigned char * pBuffer = nullptr ; unsigned char * data = nullptr ; Size winSize = Director :: getInstance ( ) -> getWinSizeInPixels ( ) ; m_windowWidth = ( int ) winSize . width ; m_inWidth = textDefinition . _dimensions . width ; m_inHeight = textDefinition . _dimensions . height ; m_fontFillColorR = textDefinition . _fontFillColor . r ; m_fontFillColorG = textDefinition . _fontFillColor . g ; m_fontFillColorB = textDefinition . _fontFillColor . b ; # if 0 auto ittFontNames = s_fontsNames . find ( textDefinition . _fontName ) ; if ( ittFontNames != s_fontsNames . end ( ) ) { pBuffer = ittFontNames -> second . pBuffer ; size = ittFontNames -> second . size ; } # endif if ( ! pBuffer ) { pBuffer = loadFont ( textDefinition . _fontName . c_str ( ) , & size ) ; if ( ! pBuffer ) { pBuffer = loadSystemFont ( textDefinition . _fontName . c_str ( ) , & size ) ; } if ( ! pBuffer ) { pBuffer = loadFont ( " Arial " , & size ) ; } if ( ! pBuffer ) { pBuffer = loadSystemFont ( " Arial " , & size ) ; } if ( ! pBuffer ) { return false ; } # if 0 FontBufferInfo info ; info . pBuffer = pBuffer ; info . size = size ; s_fontsNames [ textDefinition . _fontName ] = info ; # endif } m_fontName = textDefinition . _fontName ; m_text = text ; if ( ! s_FreeTypeLibrary ) { error = FT_Init@@ _FreeType ( & s_FreeTypeLibrary ) ; } if ( ! error && ! m_face ) { error = FT_New_Memory@@ _Face ( s_FreeTypeLibrary , pBuffer , size , 0 , & m_face ) ; } if ( ! error ) { error = FT_Select@@ _Charmap ( m_face , FT_ENCO@@ DING_UNICODE ) ; } if ( ! error ) { error = FT_Set_Char@@ _Size ( m_face , textDefinition . _fontSize << 6 , textDefinition . _fontSize << 6 , 72 , 72 ) ; } if ( ! error ) { error = initGlyphs ( text ) ; } if ( ! error ) { data = getBitmap ( align , width , height , dataLength ) ; } delete [ ] pBuffer ; reset ( ) ; return data ; } unsigned char * CCFreeTypeFont :: getBitmap ( Device :: TextAlign eAlignMask , int & width , int & height , ssize_t & dataLength ) { int lineNumber = 0 ; int totalLines = m_lines . size ( ) ; m_width = m_inWidth ? m_inWidth : m_textWidth ; m_height = m_inHeight ? m_inHeight : m_textHeight ; unsigned int size = m_width * m_height * 4 ; unsigned char * pBuffer = new unsigned char [ size ] ; dataLength = size ; if ( ! pBuffer ) { dataLength = 0 ; return nullptr ; } memset ( pBuffer , 0 , size ) ; for ( auto line = m_lines . begin ( ) ; line != m_lines . end ( ) ; ++ line ) { FT_Vector pen = getPenForAlignment ( * line , eAlignMask , lineNumber , totalLines ) ; drawText ( * line , pBuffer , & pen ) ; lineNumber ++ ; } width = m_width ; height = m_height ; return pBuffer ; } FT_Vector CCFreeTypeFont :: getPenForAlignment ( FTLineInfo * pInfo , Device :: TextAlign eAlignMask , int lineNumber , int totalLines ) { FT_Error error = 0 ; FT_Vector pen ; int top ; int stringWidth = pInfo -> bbox . xMax - pInfo -> bbox . xMin ; int maxLineNumber = totalLines - 1 ; pen . x = 0 ; pen . y = 0 ; switch ( eAlignMask ) { case Device :: TextAlign :: TOP : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: TOP_LEFT : pen . x -= pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: TOP_RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM_RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM_LEFT : pen . x -= pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: CENTER : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; case Device :: TextAlign :: RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; case Device :: TextAlign :: LEFT : default : pen . x -= pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; } return pen ; } void CCFreeTypeFont :: drawText ( FTLineInfo * pInfo , unsigned char * pBuffer , FT_Vector * pen ) { auto glyphs = pInfo -> glyphs ; for ( auto glyph = glyphs . begin ( ) ; glyph != glyphs . end ( ) ; ++ glyph ) { FT_Glyph image = glyph -> image ; FT_Error error = FT_Glyph_To_Bitmap ( & image , FT_RENDER_@@ MODE_NORMAL , 0 , 1 ) ; if ( ! error ) { FT_BitmapGlyph bit = ( FT_BitmapGlyph ) image ; draw_bitmap ( pBuffer , & bit -> bitmap , pen -> x + glyph -> pos . x + bit -> left , pen -> y - bit -> top ) ; FT_Done_Glyph ( image ) ; } } } void CCFreeTypeFont :: draw_bitmap ( unsigned char * pBuffer , FT_Bitmap * bitmap , FT_Int x , FT_Int y ) { FT_Int i , j , p , q ; FT_Int x_max = x + bitmap -> width ; FT_Int y_max = y + bitmap -> rows ; for ( i = x , p = 0 ; i < x_max ; i ++ , p ++ ) { for ( j = y , q = 0 ; j < y_max ; j ++ , q ++ ) { if ( i < 0 || j < 0 || i >= m_width || j >= m_height ) continue ; unsigned char value = bitmap -> buffer [ q * bitmap -> width + p ] ; if ( value > 0 ) { FT_Int index = ( j * m_width * 4 ) + ( i * 4 ) ; pBuffer [ index ++ ] = m_fontFillColorR ; pBuffer [ index ++ ] = m_fontFillColorG ; pBuffer [ index ++ ] = m_fontFillColorB ; pBuffer [ index ++ ] = value ; } } } } void CCFreeTypeFont :: endLine ( ) { if ( m_currentLine ) { m_lines . push_back ( m_currentLine ) ; m_textWidth = std :: max ( ( long ) m_textWidth , m_currentLine -> bbox . xMax - m_currentLine -> bbox . xMin ) ; m_textHeight += m_lineHeight ; } } void CCFreeTypeFont :: newLine ( ) { m_currentLine = new FTLineInfo ( ) ; m_currentLine -> width = 0 ; m_currentLine -> pen . x = 0 ; m_currentLine -> pen . y = 0 ; } FT_Error CCFreeTypeFont :: addWord ( const std :: string & word ) { std :: vector < TGlyph > glyphs ; FT_BBox bbox ; int maxWidth = m_inWidth ? m_inWidth : m_windowWidth ; std :: string newWord ; if ( m_currentLine -> width > 0 ) { newWord = ' ▁ ' + word ; } else { newWord = word ; } FT_Error error = initWordGlyphs ( glyphs , newWord , m_currentLine -> pen ) ; if ( ! error ) { compute_bbox ( glyphs , & bbox ) ; if ( m_currentLine -> width == 0 || bbox . xMax <= maxWidth ) { m_currentLine -> glyphs . insert ( m_currentLine -> glyphs . end ( ) , glyphs . begin ( ) , glyphs . end ( ) ) ; if ( m_currentLine -> width == 0 ) { m_currentLine -> bbox = bbox ; } else { m_currentLine -> bbox . xMax = bbox . xMax ; } m_currentLine -> width = m_currentLine -> bbox . xMax - m_currentLine -> bbox . xMin ; } else { endLine ( ) ; newLine ( ) ; addWord ( word ) ; } } return error ; } FT_Error CCFreeTypeFont :: initGlyphs ( const char * text ) { FT_Error error = 0 ; std :: stringstream stringStream ( text ) ; std :: string line ; vector < std :: string > lines ; vector < std :: string > words ; m_textWidth = 0 ; m_textHeight = 0 ; m_lineHeight = ( ( m_face -> size -> metrics . ascender ) >> 6 ) - ( ( m_face -> size -> metrics . descender ) >> 6 ) ; m_lines . clear ( ) ; while ( std :: getline ( stringStream , line ) && ! error ) { newLine ( ) ; std :: size_t prev = 0 , pos ; while ( ( pos = line . find_first_of ( " ▁ " , prev ) ) != std :: string :: npos ) { if ( pos > prev ) { addWord ( line . substr ( prev , pos - prev ) ) ; } prev = pos + 1 ; } if ( prev < line . length ( ) ) { addWord ( line . substr ( prev , std :: string :: npos ) ) ; } endLine ( ) ; } return error ; } void CCFreeTypeFont :: initWords ( const char * text ) { std :: stringstream stringStream ( text ) ; std :: string line ; vector < std :: string > lines ; vector < std :: string > words ; while ( std :: getline ( stringStream , line ) ) { lines . push_back ( line ) ; } for ( auto it = lines . begin ( ) ; it != lines . end ( ) ; ++ it ) { std :: size_t prev = 0 , pos ; while ( ( pos = it -> find_first_of ( " ▁ ' ; " , prev ) ) != std :: string :: npos ) { if ( pos > prev ) words . push_back ( it -> substr ( prev , pos - prev ) ) ; prev = pos + 1 ; } if ( prev < it -> length ( ) ) words . push_back ( it -> substr ( prev , std :: string :: npos ) ) ; } for ( auto it = words . begin ( ) ; it != words . end ( ) ; ++ it ) { std :: string foo ( * it ) ; } } FT_Error CCFreeTypeFont :: initWordGlyphs ( std :: vector < TGlyph > & glyphs , const std :: string & text , FT_Vector & pen ) { FT_GlyphSlot slot = m_face -> glyph ; FT_UInt glyph_index ; FT_UInt previous = 0 ; FT_Error error = 0 ; PGlyph glyph ; unsigned int numGlyphs = 0 ; wchar_t * pwszBuffer = nullptr ; int num_chars = text . size ( ) ; int nBufLen = num_chars + 1 ; pwszBuffer = new wchar_t [ nBufLen ] ; if ( ! pwszBuffer ) { return - 1 ; } memset ( pwszBuffer , 0 , nBufLen ) ; num_chars = MultiByteToW@@ ideChar ( CP_UTF8 , 0 , text . c_str ( ) , num_chars , pwszBuffer , nBufLen ) ; pwszBuffer [ num_chars ] = ' \0' ; glyphs . clear ( ) ; glyphs . resize ( num_chars ) ; FT_Bool useKerning = FT_HAS_@@ KERNING ( m_face ) ; for ( int n = 0 ; n < num_chars ; n ++ ) { glyph = & glyphs [ numGlyphs ] ; FT_ULong c = pwszBuffer [ n ] ; glyph_index = FT_Get_Char_Index ( m_face , c ) ; if ( useKerning && previous && glyph_index ) { FT_Vector delta ; FT_Get_Kerning ( m_face , previous , glyph_index , FT_KERN@@ ING_DEFAULT , & delta ) ; pen . x += delta . x >> 6 ; } glyph -> pos = pen ; glyph -> index = glyph_index ; error = FT_Load@@ _Glyph ( m_face , glyph_index , FT_LOAD_@@ DEFAULT ) ; if ( error ) continue ; error = FT_Get_Glyph ( m_face -> glyph , & glyph -> image ) ; if ( error ) continue ; FT_Glyph_Transform ( glyph -> image , 0 , & glyph -> pos ) ; pen . x += slot -> advance . x >> 6 ; previous = glyph_index ; numGlyphs ++ ; } CC_SAF@@ E_DELETE_ARRAY ( pwszBuffer ) ; return error ; } void CCFreeTypeFont :: compute_bbox ( std :: vector < TGlyph > & glyphs , FT_BBox * abbox ) { FT_BBox bbox ; FT_BBox glyph_bbox ; bbox . xMin = 32000 ; bbox . xMax = - 32000 ; bbox . yMin = ( m_face -> size -> metrics . descender ) >> 6 ; bbox . yMax = ( m_face -> size -> metrics . ascender ) >> 6 ; for ( auto glyph = glyphs . begin ( ) ; glyph != glyphs . end ( ) ; ++ glyph ) { FT_Glyph_Get@@ _CBox ( glyph -> image , ft_glyph_bbox@@ _pixels , & glyph_bbox ) ; glyph_bbox . xMin += glyph -> pos . x ; glyph_bbox . xMax += glyph -> pos . x ; glyph_bbox . yMin += glyph -> pos . y ; glyph_bbox . yMax += glyph -> pos . y ; if ( glyph_bbox . xMin < bbox . xMin ) bbox . xMin = glyph_bbox . xMin ; if ( glyph_bbox . yMin < bbox . yMin ) bbox . yMin = glyph_bbox . yMin ; if ( glyph_bbox . xMax > bbox . xMax ) bbox . xMax = glyph_bbox . xMax ; if ( glyph_bbox . yMax > bbox . yMax ) bbox . yMax = glyph_bbox . yMax ; } if ( bbox . xMin > bbox . xMax ) { bbox . xMin = 0 ; bbox . yMin = 0 ; bbox . xMax = 0 ; bbox . yMax = 0 ; } * abbox = bbox ; } unsigned char * CCFreeTypeFont :: loadFont ( const char * pFontName , ssize_t * size ) { std :: string lowerCase ( pFontName ) ; std :: string path ( pFontName ) ; for ( unsigned int i = 0 ; i < lowerCase . length ( ) ; ++ i ) { lowerCase [ i ] = tolower ( lowerCase [ i ] ) ; } if ( std :: string :: npos == lowerCase . find ( " fonts / " ) ) { path = " fonts / " ; path += pFontName ; } if ( std :: string :: npos == lowerCase . find ( " . ttf " ) ) { path += " . ttf " ; } std :: string fullpath = FileUtils :: getInstance ( ) -> fullPathForFilename ( path . c_str ( ) ) ; return FileUtils :: sharedFileUtils ( ) -> getFileData ( fullpath . c_str ( ) , " rb " , size ) ; } unsigned char * CCFreeTypeFont :: loadSystemFont ( const char * pFontName , ssize_t * size ) { # if ( CC_TARGET_PLATFORM == CC_PLATFORM_WP8 ) return nullptr ; # else std :: string aName ( pFontName ) ; unsigned char * pBuffer = nullptr ; HRESULT hr = S_OK ; IDWriteFactory * writeFactory = nullptr ; IDWriteFontCollection * fontCollection = nullptr ; IDWriteFontFamily * fontFamily = nullptr ; IDWriteFont * matchingFont = nullptr ; IDWriteFontFace * fontFace = nullptr ; IDWriteFontFile * fontFile = nullptr ; IDWriteFontFileLoader * fontFileLoader = nullptr ; IDWriteFontFileStream * fontFileStream = nullptr ; UINT32 index ; BOOL exists ; std :: wstring fontNameW ; const void * fontFileReferenceKey = nullptr ; UINT32 fontFileReferenceKeySize ; void * fragmentContext = nullptr ; for ( unsigned int i = 0 ; i < aName . length ( ) ; ++ i ) { aName [ i ] = tolower ( aName [ i ] ) ; } fontNameW . assign ( aName . begin ( ) , aName . end ( ) ) ; hr = DWriteCreateFactory ( DWRITE_FACTORY_TYPE_@@ SHARED , __uuidof ( IDWriteFactory ) , reinterpret_cast < IUnknown * * > ( & writeFactory ) ) ; if ( SUCCEEDED ( hr ) ) { hr = writeFactory -> GetSystemFontCollection ( & fontCollection , TRUE ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontCollection -> FindFamil@@ yName ( fontNameW . c_str ( ) , & index , & exists ) ; if ( SUCCEEDED ( hr ) && exists ) { hr = fontCollection -> GetFontFamily ( index , & fontFamily ) ; if ( SUCCEEDED ( hr ) ) { hr = fontFamily -> GetFirstMatchingFont ( DWRITE_FONT_WEIG@@ HT_REGUL@@ AR , DWRITE_FONT_STRETCH_@@ NORMAL , DWRITE_FONT_STYLE_@@ NORMAL , & matchingFont ) ; } if ( SUCCEEDED ( hr ) ) { hr = matchingFont -> CreateFontFace ( & fontFace ) ; } if ( SUCCEEDED ( hr ) ) { UINT32 numberOfFiles = 1 ; hr = fontFace -> GetFiles ( & numberOfFiles , & fontFile ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFile -> GetReferenceKey ( & fontFileReferenceKey , & fontFileReferenceKeySize ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFile -> GetLoader ( & fontFileLoader ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFileLoader -> CreateStream@@ FromKey ( fontFileReferenceKey , fontFileReferenceKeySize , & fontFileStream ) ; } if ( SUCCEEDED ( hr ) ) { UINT64 fileSize ; const void * fragmentStart = nullptr ; hr = fontFileStream -> GetFileSize ( & fileSize ) ; if ( SUCCEEDED ( hr ) ) { hr = fontFileStream -> ReadFileFragment ( & fragmentStart , 0 , fileSize , & fragmentContext ) ; } if ( SUCCEEDED ( hr ) ) { pBuffer = ( unsigned char * ) malloc ( ( size_t ) fileSize ) ; memcpy ( pBuffer , fragmentStart , ( size_t ) fileSize ) ; * size = ( unsigned long ) fileSize ; } } } } if ( fontFileStream ) { fontFileStream -> ReleaseFileFragment ( fragmentContext ) ; fontFileStream -> Release ( ) ; } if ( fontFileLoader ) { fontFileLoader -> Release ( ) ; } if ( fontFile ) { fontFile -> Release ( ) ; } if ( fontFace ) { fontFace -> Release ( ) ; } if ( matchingFont ) { matchingFont -> Release ( ) ; } if ( fontFamily ) { fontFamily -> Release ( ) ; } if ( fontCollection ) { fontCollection -> Release ( ) ; } if ( writeFactory ) { writeFactory -> Release ( ) ; } return pBuffer ; # endif } NS_CC_END </DOCUMENT>
<DOCUMENT_ID="eric@@ zhou2008/WinObjC/tree/master/deps/3rdparty/ic@@ ulegacy/source/common/parsepos@@ .cpp"> # include " unicode / parsepos . h " U_NAMESPACE_BEGIN UOBJECT_DEFINE_RTTI_IMPLEMENTATION ( ParsePosition ) ParsePosition :: ~ ParsePosition ( ) { } ParsePosition * ParsePosition :: clone ( ) const { return new ParsePosition ( * this ) ; } U_NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="Open@@ DSA/OpenDSA@@ -stable/tree/master/@@ SourceCode/@@ C++/Sorting/Heap@@ sort.cpp"> # include " Maxheap . cpp " void heapsort ( Comparable * A [ ] , int n ) { std :: cout << " Getting ▁ started ▁ with ▁ array : " << std :: endl ; for ( int j = 0 ; j < n ; j ++ ) std :: cout << * A [ j ] << " ▁ " ; std :: cout << std :: endl ; MaxHeap H ( A , n , n ) ; std :: cout << " Now , ▁ ready ▁ to ▁ unpack ▁ the ▁ heap " << std :: endl ; for ( int i = 0 ; i < n ; i ++ ) H . removemax ( ) ; } bool sorttest ( int array [ ] , int n , int threshold ) { Comparable * A [ n ] ; int i ; cout << " We ▁ came ▁ in ▁ with ▁ array : " << endl ; for ( i = 0 ; i < n ; i ++ ) std :: cout << array [ i ] << " ▁ " ; std :: cout << std :: endl ; for ( i = 0 ; i < n ; ++ i ) { A [ i ] = new Int ( array [ i ] ) ; } cout << " We ▁ are ▁ going ▁ to ▁ call ▁ Heapsort ▁ with ▁ this ▁ array : " << endl ; for ( i = 0 ; i < n ; i ++ ) std :: cout << A [ i ] << " ▁ " ; std :: cout << std :: endl ; heapsort ( A , n ) ; if ( ! checkorder ( A , n ) ) return false ; for ( i = 0 ; i < n ; ++ i ) { delete A [ i ] ; } for ( i = 0 ; i < n ; ++ i ) { A [ i ] = new KVPair ( array [ i ] , & array [ i ] ) ; } if ( ! checkorder ( A , n ) ) return false ; for ( i = 0 ; i < n ; ++ i ) { delete A [ i ] ; } delete [ ] array ; return true ; } # include " SortTest . cpp " </DOCUMENT>
<DOCUMENT_ID="basic@@ 60/AR@@ CUS/tree/master/source/kernel/@@ interruption/idt@@ .cpp"> # include " types . h " # include " idt . h " # include " string . h " # include " print _ charmode . h " # include " port . h " # include " keyboard . h " idtEntry idtEntries [ 256 ] ; interruptHandler_t interruptHandler [ 256 ] ; idtPtr iptr ; extern " C " void idtFlush ( uint64 addr ) ; void initIDT ( ) { memset ( ( uint8 * ) idtEntries , 0 , sizeof ( idtEntries ) ) ; iptr . limit = sizeof ( idtEntries ) - 1 ; iptr . base = ( uint64 ) & idtEntries ; writePort ( 0x20 , 0x11 ) ; writePort ( 0xA0 , 0x11 ) ; writePort ( 0x21 , 0x20 ) ; writePort ( 0xA1 , 0x28 ) ; writePort ( 0x21 , 0x01 ) ; writePort ( 0xA1 , 0x01 ) ; writePort ( 0x21 , 0x00 ) ; writePort ( 0xA1 , 0x00 ) ; idtSetEntity ( 0 , ( uint64 ) isr0 , 0x08 , 0x8E ) ; idtSetEntity ( 1 , ( uint64 ) isr1 , 0x08 , 0x8E ) ; idtSetEntity ( 2 , ( uint64 ) isr2 , 0x08 , 0x8E ) ; idtSetEntity ( 3 , ( uint64 ) isr3 , 0x08 , 0x8E ) ; idtSetEntity ( 4 , ( uint64 ) isr4 , 0x08 , 0x8E ) ; idtSetEntity ( 5 , ( uint64 ) isr5 , 0x08 , 0x8E ) ; idtSetEntity ( 6 , ( uint64 ) isr6 , 0x08 , 0x8E ) ; idtSetEntity ( 7 , ( uint64 ) isr7 , 0x08 , 0x8E ) ; idtSetEntity ( 8 , ( uint64 ) isr8 , 0x08 , 0x8E ) ; idtSetEntity ( 9 , ( uint64 ) isr9 , 0x08 , 0x8E ) ; idtSetEntity ( 10 , ( uint64 ) isr10 , 0x08 , 0x8E ) ; idtSetEntity ( 11 , ( uint64 ) isr11 , 0x08 , 0x8E ) ; idtSetEntity ( 12 , ( uint64 ) isr12 , 0x08 , 0x8E ) ; idtSetEntity ( 13 , ( uint64 ) isr13 , 0x08 , 0x8E ) ; idtSetEntity ( 14 , ( uint64 ) isr14 , 0x08 , 0x8E ) ; idtSetEntity ( 15 , ( uint64 ) isr15 , 0x08 , 0x8E ) ; idtSetEntity ( 16 , ( uint64 ) isr16 , 0x08 , 0x8E ) ; idtSetEntity ( 17 , ( uint64 ) isr17 , 0x08 , 0x8E ) ; idtSetEntity ( 18 , ( uint64 ) isr18 , 0x08 , 0x8E ) ; idtSetEntity ( 19 , ( uint64 ) isr19 , 0x08 , 0x8E ) ; idtSetEntity ( 20 , ( uint64 ) isr20 , 0x08 , 0x8E ) ; idtSetEntity ( 21 , ( uint64 ) isr21 , 0x08 , 0x8E ) ; idtSetEntity ( 22 , ( uint64 ) isr22 , 0x08 , 0x8E ) ; idtSetEntity ( 23 , ( uint64 ) isr23 , 0x08 , 0x8E ) ; idtSetEntity ( 24 , ( uint64 ) isr24 , 0x08 , 0x8E ) ; idtSetEntity ( 25 , ( uint64 ) isr25 , 0x08 , 0x8E ) ; idtSetEntity ( 26 , ( uint64 ) isr26 , 0x08 , 0x8E ) ; idtSetEntity ( 27 , ( uint64 ) isr27 , 0x08 , 0x8E ) ; idtSetEntity ( 28 , ( uint64 ) isr27 , 0x08 , 0x8E ) ; idtSetEntity ( 29 , ( uint64 ) isr29 , 0x08 , 0x8E ) ; idtSetEntity ( 30 , ( uint64 ) isr30 , 0x08 , 0x8E ) ; idtSetEntity ( 31 , ( uint64 ) isr31 , 0x08 , 0x8E ) ; idtSetEntity ( 32 , ( uint64 ) irq0 , 0x08 , 0x8E ) ; idtSetEntity ( 33 , ( uint64 ) irq1 , 0x08 , 0x8E ) ; idtSetEntity ( 34 , ( uint64 ) irq2 , 0x08 , 0x8E ) ; idtSetEntity ( 35 , ( uint64 ) irq3 , 0x08 , 0x8E ) ; idtSetEntity ( 36 , ( uint64 ) irq4 , 0x08 , 0x8E ) ; idtSetEntity ( 37 , ( uint64 ) irq5 , 0x08 , 0x8E ) ; idtSetEntity ( 38 , ( uint64 ) irq6 , 0x08 , 0x8E ) ; idtSetEntity ( 39 , ( uint64 ) irq7 , 0x08 , 0x8E ) ; idtSetEntity ( 40 , ( uint64 ) irq8 , 0x08 , 0x8E ) ; idtSetEntity ( 41 , ( uint64 ) irq9 , 0x08 , 0x8E ) ; idtSetEntity ( 42 , ( uint64 ) irq10 , 0x08 , 0x8E ) ; idtSetEntity ( 43 , ( uint64 ) irq11 , 0x08 , 0x8E ) ; idtSetEntity ( 44 , ( uint64 ) irq12 , 0x08 , 0x8E ) ; idtSetEntity ( 45 , ( uint64 ) irq13 , 0x08 , 0x8E ) ; idtSetEntity ( 46 , ( uint64 ) irq14 , 0x08 , 0x8E ) ; idtSetEntity ( 47 , ( uint64 ) irq15 , 0x08 , 0x8E ) ; idtFlush ( ( uint64 ) & iptr ) ; printStr ( " Initializing ▁ interruption ▁ finished . \n " , color_white ) ; } void isrHandler ( ptRegs * regs ) { if ( interruptHandler [ regs -> intNum ] ) interruptHandler [ regs -> intNum ] ( regs ) ; else { } } void irqHandler ( ptRegs * regs ) { if ( regs -> intNum > 40 ) { writePort ( 0xA0 , 0x20 ) ; } writePort ( 0x20 , 0x20 ) ; if ( interruptHandler [ regs -> intNum ] ) { interruptHandler [ regs -> intNum ] ( regs ) ; } } void registerInterrupt@@ Handler ( uint8 n , interruptHandler_t h ) { interruptHandler [ n ] = h ; } void idtSetEntity ( uint8 num , uint64 base , uint16 selector , uint8 flags ) { idtEntries [ num ] . offset1 = base & 0xffff ; idtEntries [ num ] . offset2 = ( base >> 16 ) & 0xffff ; idtEntries [ num ] . offset3 = ( base >> 32 ) & 0xffffffff ; idtEntries [ num ] . selector = selector ; idtEntries [ num ] . typeAttr = flags ; } </DOCUMENT>
<DOCUMENT_ID="dead@@ coda/arg3db@@ /tree/master/src/sqlite@@ /resultset.cpp"> # include " resultset . h " # include " . . / exception . h " # include " row . h " # include " session . h " using namespace std ; namespace coda { namespace db { namespace sqlite { resultset :: resultset ( const std :: shared_ptr < sqlite :: session > & sess , const shared_ptr < sqlite3_stmt > & stmt ) : stmt_ ( stmt ) , sess_ ( sess ) , status_ ( - 1 ) { if ( sess_ == nullptr ) { throw database_exception ( " No ▁ database ▁ provided ▁ to ▁ sqlite3 ▁ resultset " ) ; } if ( stmt_ == nullptr ) { throw database_exception ( " no ▁ statement ▁ provided ▁ to ▁ sqlite3 ▁ resultset " ) ; } } resultset :: resultset ( resultset && other ) : stmt_ ( std :: move ( other . stmt_ ) ) , sess_ ( std :: move ( other . sess_ ) ) , status_ ( other . status_ ) { other . sess_ = nullptr ; other . stmt_ = nullptr ; } resultset :: ~ resultset ( ) { } resultset & resultset :: operator = ( resultset && other ) { stmt_ = std :: move ( other . stmt_ ) ; sess_ = std :: move ( other . sess_ ) ; status_ = other . status_ ; other . sess_ = nullptr ; other . stmt_ = nullptr ; return * this ; } bool resultset :: is_valid ( ) const noexcept { return stmt_ != nullptr && stmt_ ; } bool resultset :: next ( ) { if ( ! is_valid ( ) ) { return false ; } if ( status_ == SQLITE_DONE ) { return false ; } status_ = sqlite3_step ( stmt_ . get ( ) ) ; return status_ == SQLITE_ROW ; } void resultset :: reset ( ) { if ( ! is_valid ( ) ) { return ; } if ( sqlite3_reset ( stmt_ . get ( ) ) != SQLITE_OK ) { throw database_exception ( sess_ -> last_error ( ) ) ; } status_ = - 1 ; } resultset :: row_type resultset :: current_row ( ) { return row_type ( make_shared < row > ( sess_ , stmt_ ) ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="keich@@ an100yen/ode-ext@@ /tree/master/boost/libs/config/test/@@ no_std_allocator_fail.cpp"> # ifdef BOOST_ASSERT_CONFIG # undef BOOST_ASSERT_CONFIG # endif # include < boost / config . hpp > # include " test . hpp " # ifdef BOOST_NO_STD_ALLOCATOR # include " boost _ no _ std _ allocator . ipp " # else # error " this ▁ file ▁ should ▁ not ▁ compile " # endif int main ( int , char * [ ] ) { return boost_no_std_@@ allocator :: test ( ) ; } </DOCUMENT>
<DOCUMENT_ID="chiri@@ lo/phantomjs/tree/master/src/qt/qtbase/src/gui/doc/snippets/code/src_@@ gui_paint@@ ing_qpainter@@ .cpp"> void SimpleExample@@ Widget :: paintEvent ( QPaintEvent * ) { QPainter painter ( this ) ; painter . setPen ( Qt :: blue ) ; painter . setFont ( QFont ( " Arial " , 30 ) ) ; painter . drawText ( rect ( ) , Qt :: AlignCenter , " Qt " ) ; } void MyWidget :: paintEvent ( QPaintEvent * ) { QPainter p ; p . begin ( this ) ; p . drawLine ( ... ) ; p . end ( ) ; } void MyWidget :: paintEvent ( QPaintEvent * ) { QPainter p ( this ) ; p . drawLine ( ... ) ; } painter -> begin ( 0 ) ; QPixmap image ( 0 , 0 ) ; painter -> begin ( & image ) ; painter -> begin ( myWidget ) ; painter2 -> begin ( myWidget ) ; void QPainter :: rotate ( qreal angle ) { QMatrix matrix ; matrix . rotate ( angle ) ; setWorldMatrix ( matrix , true ) ; } QPainterPath path ; path . moveTo ( 20 , 80 ) ; path . lineTo ( 20 , 30 ) ; path . cubicTo ( 80 , 0 , 50 , 50 , 80 , 80 ) ; QPainter painter ( this ) ; painter . drawPath ( path ) ; QLineF line ( 10.0 , 80.0 , 90.0 , 20.0 ) ; QPainter ( this ) ; painter . drawLine ( line ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QPainter painter ( this ) ; painter . drawRect ( rectangle ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QPainter painter ( this ) ; painter . drawRounded@@ Rect ( rectangle , 20.0 , 15.0 ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QPainter painter ( this ) ; painter . drawEllipse ( rectangle ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; int startAngle = 30 * 16 ; int spanAngle = 120 * 16 ; QPainter painter ( this ) ; painter . drawArc ( rectangle , startAngle , spanAngle ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; int startAngle = 30 * 16 ; int spanAngle = 120 * 16 ; QPainter painter ( this ) ; painter . drawPi@@ e ( rectangle , startAngle , spanAngle ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; int startAngle = 30 * 16 ; int spanAngle = 120 * 16 ; QPainter painter ( this ) ; painter . drawChord ( rect , startAngle , spanAngle ) ; static const QPointF points [ 3 ] = { QPointF ( 10.0 , 80.0 ) , QPointF ( 20.0 , 10.0 ) , QPointF ( 80.0 , 30.0 ) , } ; QPainter painter ( this ) ; painter . drawPolyline ( points , 3 ) ; static const QPointF points [ 4 ] = { QPointF ( 10.0 , 80.0 ) , QPointF ( 20.0 , 10.0 ) , QPointF ( 80.0 , 30.0 ) , QPointF ( 90.0 , 70.0 ) } ; QPainter painter ( this ) ; painter . drawPolygon ( points , 4 ) ; static const QPointF points [ 4 ] = { QPointF ( 10.0 , 80.0 ) , QPointF ( 20.0 , 10.0 ) , QPointF ( 80.0 , 30.0 ) , QPointF ( 90.0 , 70.0 ) } ; QPainter painter ( this ) ; painter . drawConv@@ exPolygon ( points , 4 ) ; QRectF target ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QRectF source ( 0.0 , 0.0 , 70.0 , 40.0 ) ; QPixmap pixmap ( " : myPixmap . png " ) ; QPainter ( this ) ; painter . drawPixmap ( target , pixmap , source ) ; QPainter painter ( this ) ; painter . drawText ( rect , Qt :: AlignCenter , tr ( " Qt \n Project " ) ) ; QPicture picture ; QPointF point ( 10.0 , 20.0 ) picture . load ( " drawing . pic " ) ; QPainter painter ( this ) ; painter . drawPicture ( 0 , 0 , picture ) ; fillRect ( rectangle , background ( ) ) . QRectF target ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QRectF source ( 0.0 , 0.0 , 70.0 , 40.0 ) ; QImage image ( " : / images / myImage . png " ) ; QPainter painter ( this ) ; painter . drawImage ( target , image , source ) ; QPainter painter ( this ) ; painter . fillRect ( 0 , 0 , 128 , 128 , Qt :: green ) ; painter . beginNativePainting ( ) ; glEnable ( GL_SCISSOR_TEST ) ; glScissor ( 0 , 0 , 64 , 64 ) ; glClearColor ( 1 , 0 , 0 , 1 ) ; glClear ( GL_COLOR_BUFFER_BIT ) ; glDisable ( GL_SCISSOR_TEST ) ; painter . endNativePainting ( ) ; </DOCUMENT>
<DOCUMENT_ID="liuch@@ uo/LeetCode@@ -practice/tree/master/C++/079. Word Search.cpp"> 79. Word Search Given a 2D board and a word , find if the word exists in the grid . The word can be constructed from letters of sequentially adjacent cell , where " adjacent " cells are those horizont@@ ally or vertically neighboring . The same letter cell may not be used more than once . For example , Given board = [ [ ' A ' , ' B ' , ' C ' , ' E ' ] , [ ' S ' , ' F ' , ' C ' , ' S ' ] , [ ' A ' , ' D ' , ' E ' , ' E ' ] ] word = " ABCC@@ ED " , -> returns true , word = " SEE " , -> returns true , word = " ABCB " , -> returns false . 题目大意@@ ：给一个char型二维数组@@ 和一个word字符串，寻找网格@@ 中是否含有@@ word字符串，只能通@@ 过相邻（垂@@ 直或者水@@ 平）的格子连@@ 接～ 分析：对@@ 于二维数组中的每@@ 一个点都@@ 开始遍历@@ ，如果当前点的字@@ 母正好等于word [ 0 ] 就进入dfs@@ ，设立flag标记是否@@ 找到，设立@@ visit标记是否@@ 访问： 首先令起@@ 始节点visit [ j ] [ k ] 标记为已@@ 经访问过，接着dfs@@ ，如果flag为true@@ 直接return，如果当前@@ index正好@@ 为word的最后一个字符@@ 下标就标记flag为true@@ ，return 。 从四个方向开始@@ 对结点进@@ 行深度优@@ 先搜索，首先要保@@ 证搜索的结点满足@@ ：1 . 是合法的@@ 在网格之内@@ 的 2 . 未被访问过 3 . 当前字符与要找的word [ index + 1 ] 相同 。 满足则标记@@ visit [ tx ] [ ty ] = true , 且dfs tx和ty@@ 以及index + 1 ， 两个dfs后要把他@@ 重新置为false ～ 这样最后返回@@ flag的值@@ 即为是否能找到@@ 的结果～ class Solution { private : bool flag = false ; vector < vector < bool >> visit ; vector < vector < char >> board ; string word = " " ; int dir [ 4 ] [ 2 ] = { { 0 , 1 } , { 1 , 0 } , { 0 , - 1 } , { - 1 , 0 } } ; int m , n ; public : bool exist ( vector < vector < char >> & board , string word ) { if ( board . size ( ) == 0 ) return word == " " ; m = board . size ( ) , n = board [ 0 ] . size ( ) ; this -> word = word ; this -> board = board ; visit . resize ( m , vector < bool > ( n ) ) ; for ( int j = 0 ; j < m ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( board [ j ] [ k ] == word [ 0 ] ) { visit [ j ] [ k ] = true ; dfs ( j , k , 0 ) ; visit [ j ] [ k ] = false ; } } } return flag ; } void dfs ( int x , int y , int index ) { if ( flag == true ) return ; if ( index == word . length ( ) - 1 ) { flag = true ; return ; } for ( int i = 0 ; i < 4 ; i ++ ) { int tx = x + dir [ i ] [ 0 ] , ty = y + dir [ i ] [ 1 ] ; if ( tx >= 0 && tx < m && ty >= 0 && ty < n && board [ tx ] [ ty ] == word [ index + 1 ] && visit [ tx ] [ ty ] == false ) { visit [ tx ] [ ty ] = true ; dfs ( tx , ty , index + 1 ) ; visit [ tx ] [ ty ] = false ; } } } } ; </DOCUMENT>
<DOCUMENT_ID="dd@@ ark/ec@@ l/tree/master/src/server/scripts/Northrend/zone_wintergrasp.cpp"> # include " BattlefieldMgr . h " # include " BattlefieldWG . h " # include " Battlefield . h " # include " ScriptSystem . h " # include " WorldSession . h " # include " ObjectMgr . h " # include " Vehicle . h " # include " GameObjectAI . h " # include " ScriptedCreature . h " # include " ScriptedGossip . h " # include " SpellScript . h " # include " Player . h " # define GOSSIP_HELLO_DEMO1 " Build ▁ catapult . " # define GOSSIP_HELLO_DEMO2 " Build ▁ demolisher . " # define GOSSIP_HELLO_DEMO3 " Build ▁ siege ▁ engine . " # define GOSSIP_HELLO_DEMO4 " I ▁ cannot ▁ build ▁ more ! " enum WGqueuenpc@@ text { WG_NPCQUEUE_TEXT_H_NOWAR = 14775 , WG_NPCQUEUE_TEXT_H_QUEUE = 14790 , WG_NPCQUEUE_TEXT_H_WAR = 14777 , WG_NPCQUEUE_TEXT_A_NOWAR = 14782 , WG_NPCQUEUE_TEXT_A_QUEUE = 14791 , WG_NPCQUEUE_TEXT_A_WAR = 14781 , WG_NPCQUEUE_TEXTOPTION_JOIN = 20077 , } ; enum Spells { SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE = 61409 , SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE = 56662 , SPELL_BUILD_CATAPULT_FORCE = 56664 , SPELL_BUILD_DEMOLISHER_FORCE = 56659 , SPELL_ACTIVATE_CONTROL_ARMS = 49899 , SPELL_RIDE_WG_VEHICLE = 6096@@ 8 , SPELL_VEHICLE_TELEPORT = 49759 , SPELL_CHANNEL_SPIRIT_HEAL = 22011 , } ; enum CreatureIds { NPC_GOBLIN_MECHANIC = 30400 , NPC_GNOMISH_ENGINEER = 30499 , NPC_WINTERGRASP_CONTROL_ARMS = 27852 , NPC_WORLD_TRIGGER_LARGE_AOI_NOT_IMMUNE_PC_NPC = 23472 , } ; enum QuestIds { QUEST_BONES_AND_ARROWS_HORDE_ATT = 13193 , QUEST_JINXING_THE_WALLS_HORDE_ATT = 13202 , QUEST_SLAY_THEM_ALL_HORDE_ATT = 13180 , QUEST_FUELING_THE_DEMOLISHERS_HORDE_ATT = 13200 , QUEST_HEALING_WITH_ROSES_HORDE_ATT = 13201 , QUEST_DEFEND_THE_SIEGE_HORDE_ATT = 13223 , QUEST_BONES_AND_ARROWS_HORDE_DEF = 13199 , QUEST_WARDING_THE_WALLS_HORDE_DEF = 13192 , QUEST_SLAY_THEM_ALL_HORDE_DEF = 13178 , QUEST_FUELING_THE_DEMOLISHERS_HORDE_DEF = 13191 , QUEST_HEALING_WITH_ROSES_HORDE_DEF = 13194 , QUEST_TOPPLING_THE_TOWERS_HORDE_DEF = 13539 , QUEST_STOP_THE_SIEGE_HORDE_DEF = 13185 , QUEST_BONES_AND_ARROWS_ALLIANCE_ATT = 13196 , QUEST_WARDING_THE_WARRIORS_ALLIANCE_ATT = 13198 , QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_ATT = 13179 , QUEST_DEFEND_THE_SIEGE_ALLIANCE_ATT = 13222 , QUEST_A_RARE_HERB_ALLIANCE_ATT = 13195 , QUEST_BONES_AND_ARROWS_ALLIANCE_DEF = 13154 , QUEST_WARDING_THE_WARRIORS_ALLIANCE_DEF = 13153 , QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_DEF = 13177 , QUEST_SHOUTHERN_SABOTAGE_ALLIANCE_DEF = 13538 , QUEST_STOP_THE_SIEGE_ALLIANCE_DEF = 13186 , QUEST_A_RARE_HERB_ALLIANCE_DEF = 13156 , } ; uint8 const MAX_WINTERGRASP_VEHICLES = 4 ; uint32 const vehiclesList [ MAX_WINTERGRASP_VEHICLES ] = { NPC_WINTERGRASP_CATAP@@ ULT , NPC_WINTERGRASP_DEMOLISHER , NPC_WINTERGRASP_SIEGE_ENGINE_ALLIANCE , NPC_WINTERGRASP_SIEGE_ENGINE_HORDE } ; class npc_wg_demolisher_engineer : public CreatureScript { public : npc_wg_demolisher_engineer ( ) : CreatureScript ( " npc _ wg _ demolisher _ engineer " ) { } bool OnGossipHello ( Player * player , Creature * creature ) OVERRIDE { if ( creature -> IsQuestGiver ( ) ) player -> PrepareQuestMenu ( creature -> GetGUID ( ) ) ; if ( CanBuild ( creature ) ) { if ( player -> HasAura ( SPELL_COR@@ PORAL ) ) player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO1 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF ) ; else if ( player -> HasAura ( SPELL_LIEUT@@ ENANT ) ) { player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO1 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF ) ; player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO2 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF + 1 ) ; player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO3 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF + 2 ) ; } } else player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO4 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF + 9 ) ; player -> SEND_GOSSIP_MENU ( player -> GetGossipTextId ( creature ) , creature -> GetGUID ( ) ) ; return true ; } bool OnGossipSelect ( Player * player , Creature * creature , uint32 , uint32 action ) OVERRIDE { player -> CLOSE_GOSSIP_MENU ( ) ; if ( CanBuild ( creature ) ) { switch ( action - GOSSIP_ACTION_INFO_DEF ) { case 0 : creature -> CastSpell ( player , SPELL_BUILD_CATAPULT_FORCE , true ) ; break ; case 1 : creature -> CastSpell ( player , SPELL_BUILD_DEMOLISHER_FORCE , true ) ; break ; case 2 : creature -> CastSpell ( player , player -> GetTeamId ( ) == TEAM_ALLIANCE ? SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE : SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE , true ) ; break ; } if ( Creature * controlArms = creature -> FindNearestCreature ( NPC_WINTERGRASP_CONTROL_ARMS , 30.0f , true ) ) creature -> CastSpell ( controlArms , SPELL_ACTIVATE_CONTROL_ARMS , true ) ; } return true ; } private : bool CanBuild ( Creature * creature ) { Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return false ; switch ( creature -> GetEntry ( ) ) { case NPC_GOBLIN_MECHANIC : return ( wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_MAX_VEHICLE_H ) > wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_VEHICLE_H ) ) ; case NPC_GNOMISH_ENGINEER : return ( wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_MAX_VEHICLE_A ) > wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_VEHICLE_A ) ) ; default : return false ; } } } ; class npc_wg_spirit_guide : public CreatureScript { public : npc_wg_spirit_guide ( ) : CreatureScript ( " npc _ wg _ spirit _ guide " ) { } bool OnGossipHello ( Player * player , Creature * creature ) OVERRIDE { if ( creature -> IsQuestGiver ( ) ) player -> PrepareQuestMenu ( creature -> GetGUID ( ) ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return true ; GraveyardVect graveyard = wintergrasp -> GetGraveyardVector ( ) ; for ( uint8 i = 0 ; i < graveyard . size ( ) ; i ++ ) if ( graveyard [ i ] -> GetControlTeamId ( ) == player -> GetTeamId ( ) ) player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , sObjectMgr -> GetTrinityStringForDBCLocale ( ( ( BfGraveyardWG * ) graveyard [ i ] ) -> GetTextId ( ) ) , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF + i ) ; player -> SEND_GOSSIP_MENU ( player -> GetGossipTextId ( creature ) , creature -> GetGUID ( ) ) ; return true ; } bool OnGossipSelect ( Player * player , Creature * , uint32 , uint32 action ) OVERRIDE { player -> CLOSE_GOSSIP_MENU ( ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( wintergrasp ) { GraveyardVect gy = wintergrasp -> GetGraveyardVector ( ) ; for ( uint8 i = 0 ; i < gy . size ( ) ; i ++ ) if ( action - GOSSIP_ACTION_INFO_DEF == i && gy [ i ] -> GetControlTeamId ( ) == player -> GetTeamId ( ) ) if ( WorldSafeLocsEntry const * safeLoc = sWorldSafeLocsStore . LookupEntry ( gy [ i ] -> GetGraveyardId ( ) ) ) player -> TeleportTo ( safeLoc -> map_id , safeLoc -> x , safeLoc -> y , safeLoc -> z , 0 ) ; } return true ; } struct npc_wg_spirit_guideAI : public ScriptedAI { npc_wg_spirit_guideAI ( Creature * creature ) : ScriptedAI ( creature ) { } void UpdateAI ( uint32 ) OVERRIDE { if ( ! me -> HasUnitState ( UNIT_STATE_CASTING ) ) DoCast ( me , SPELL_CHANNEL_SPIRIT_HEAL ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const OVERRIDE { return new npc_wg_spirit_guideAI ( creature ) ; } } ; class npc_wg_queue : public CreatureScript { public : npc_wg_queue ( ) : CreatureScript ( " npc _ wg _ queue " ) { } bool OnGossipHello ( Player * player , Creature * creature ) OVERRIDE { if ( creature -> IsQuestGiver ( ) ) player -> PrepareQuestMenu ( creature -> GetGUID ( ) ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return true ; if ( wintergrasp -> IsWarTime ( ) ) { player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , sObjectMgr -> GetTrinityStringForDBCLocale ( WG_NPCQUEUE_TEXTOPTION_JOIN ) , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF ) ; player -> SEND_GOSSIP_MENU ( wintergrasp -> GetDefenderTeam ( ) ? WG_NPCQUEUE_TEXT_H_WAR : WG_NPCQUEUE_TEXT_A_WAR , creature -> GetGUID ( ) ) ; } else { uint32 timer = wintergrasp -> GetTimer ( ) / 1000 ; player -> SendUpdateWorldState ( 4354 , time ( NULL ) + timer ) ; if ( timer < 15 * MINUTE ) { player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , sObjectMgr -> GetTrinityStringForDBCLocale ( WG_NPCQUEUE_TEXTOPTION_JOIN ) , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF ) ; player -> SEND_GOSSIP_MENU ( wintergrasp -> GetDefenderTeam ( ) ? WG_NPCQUEUE_TEXT_H_QUEUE : WG_NPCQUEUE_TEXT_A_QUEUE , creature -> GetGUID ( ) ) ; } else player -> SEND_GOSSIP_MENU ( wintergrasp -> GetDefenderTeam ( ) ? WG_NPCQUEUE_TEXT_H_NOWAR : WG_NPCQUEUE_TEXT_A_NOWAR , creature -> GetGUID ( ) ) ; } return true ; } bool OnGossipSelect ( Player * player , Creature * , uint32 , uint32 ) OVERRIDE { player -> CLOSE_GOSSIP_MENU ( ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return true ; if ( wintergrasp -> IsWarTime ( ) ) wintergrasp -> InvitePlayerToWar ( player ) ; else { uint32 timer = wintergrasp -> GetTimer ( ) / 1000 ; if ( timer < 15 * MINUTE ) wintergrasp -> InvitePlayerToQueue ( player ) ; } return true ; } } ; class go_wg_vehicle_teleporter : public GameObjectScript { public : go_wg_vehicle_teleporter ( ) : GameObjectScript ( " go _ wg _ vehicle _ teleporter " ) { } struct go_wg_vehicle_teleporterAI : public GameObjectAI { go_wg_vehicle_teleporterAI ( GameObject * gameObject ) : GameObjectAI ( gameObject ) , _checkTimer ( 1000 ) { } void UpdateAI ( uint32 diff ) OVERRIDE { if ( _checkTimer <= diff ) { if ( Battlefield * wg = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ) for ( uint8 i = 0 ; i < MAX_WINTERGRASP_VEHICLES ; i ++ ) if ( Creature * vehicleCreature = go -> FindNearestCreature ( vehiclesList [ i ] , 3.0f , true ) ) if ( ! vehicleCreature -> HasAura ( SPELL_VEHICLE_TELEPORT ) && vehicleCreature -> getFaction ( ) == WintergraspFaction [ wg -> GetDefenderTeam ( ) ] ) if ( Creature * teleportTrigger = vehicleCreature -> FindNearestCreature ( NPC_WORLD_TRIGGER_LARGE_AOI_NOT_IMMUNE_PC_NPC , 100.0f , true ) ) teleportTrigger -> CastSpell ( vehicleCreature , SPELL_VEHICLE_TELEPORT , true ) ; _checkTimer = 1000 ; } else _checkTimer -= diff ; } private : uint32 _checkTimer ; } ; GameObjectAI * GetAI ( GameObject * go ) const OVERRIDE { return new go_wg_vehicle_teleporterAI ( go ) ; } } ; class npc_wg_quest_giver : public CreatureScript { public : npc_wg_quest_giver ( ) : CreatureScript ( " npc _ wg _ quest _ giver " ) { } bool OnGossipHello ( Player * player , Creature * creature ) OVERRIDE { if ( creature -> IsQuestGiver ( ) ) player -> PrepareQuestMenu ( creature -> GetGUID ( ) ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return true ; if ( creature -> IsQuestGiver ( ) ) { QuestRelationBounds objectQR = sObjectMgr -> GetCreatureQuestRelationBounds ( creature -> GetEntry ( ) ) ; QuestRelationBounds objectQIR = sObjectMgr -> GetCreatureQuestInvol@@ vedRelationBounds ( creature -> GetEntry ( ) ) ; QuestMenu & qm = player -> PlayerTalkClass -> GetQuestMenu ( ) ; qm . ClearMenu ( ) ; for ( QuestRelations :: const_iterator i = objectQIR . first ; i != objectQIR . second ; ++ i ) { uint32 questId = i -> second ; QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( status == QUEST_STATUS_COMPLETE ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_INCOMPLETE ) qm . AddMenuItem ( questId , 4 ) ; } for ( QuestRelations :: const_iterator i = objectQR . first ; i != objectQR . second ; ++ i ) { uint32 questId = i -> second ; Quest const * quest = sObjectMgr -> GetQuestTemplate ( questId ) ; if ( ! quest ) continue ; switch ( questId ) { case QUEST_BONES_AND_ARROWS_HORDE_ATT : case QUEST_JINXING_THE_WALLS_HORDE_ATT : case QUEST_SLAY_THEM_ALL_HORDE_ATT : case QUEST_FUELING_THE_DEMOLISHERS_HORDE_ATT : case QUEST_HEALING_WITH_ROSES_HORDE_ATT : case QUEST_DEFEND_THE_SIEGE_HORDE_ATT : if ( wintergrasp -> GetAttackerTeam ( ) == TEAM_HORDE ) { QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; } break ; case QUEST_BONES_AND_ARROWS_HORDE_DEF : case QUEST_WARDING_THE_WALLS_HORDE_DEF : case QUEST_SLAY_THEM_ALL_HORDE_DEF : case QUEST_FUELING_THE_DEMOLISHERS_HORDE_DEF : case QUEST_HEALING_WITH_ROSES_HORDE_DEF : case QUEST_TOPPLING_THE_TOWERS_HORDE_DEF : case QUEST_STOP_THE_SIEGE_HORDE_DEF : if ( wintergrasp -> GetDefenderTeam ( ) == TEAM_HORDE ) { QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; } break ; case QUEST_BONES_AND_ARROWS_ALLIANCE_ATT : case QUEST_WARDING_THE_WARRIORS_ALLIANCE_ATT : case QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_ATT : case QUEST_DEFEND_THE_SIEGE_ALLIANCE_ATT : case QUEST_A_RARE_HERB_ALLIANCE_ATT : if ( wintergrasp -> GetAttackerTeam ( ) == TEAM_ALLIANCE ) { QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; } break ; case QUEST_BONES_AND_ARROWS_ALLIANCE_DEF : case QUEST_WARDING_THE_WARRIORS_ALLIANCE_DEF : case QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_DEF : case QUEST_SHOUTHERN_SABOTAGE_ALLIANCE_DEF : case QUEST_STOP_THE_SIEGE_ALLIANCE_DEF : case QUEST_A_RARE_HERB_ALLIANCE_DEF : if ( wintergrasp -> GetDefenderTeam ( ) == TEAM_ALLIANCE ) { QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; } break ; default : QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; break ; } } } player -> SEND_GOSSIP_MENU ( player -> GetGossipTextId ( creature ) , creature -> GetGUID ( ) ) ; return true ; } } ; class spell_wintergrasp_force_building : public SpellScriptLoader { public : spell_wintergrasp_force_building ( ) : SpellScriptLoader ( " spell _ wintergrasp _ force _ building " ) { } class spell_wintergrasp_force_building_SpellScript : public SpellScript { PrepareSpellScript ( spell_wintergrasp_force_building_SpellScript ) ; bool Validate ( SpellInfo const * ) OVERRIDE { if ( ! sSpellMgr -> GetSpellInfo ( SPELL_BUILD_CATAPULT_FORCE ) || ! sSpellMgr -> GetSpellInfo ( SPELL_BUILD_DEMOLISHER_FORCE ) || ! sSpellMgr -> GetSpellInfo ( SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE ) || ! sSpellMgr -> GetSpellInfo ( SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE ) ) return false ; return true ; } void HandleScript ( SpellEffIndex effIndex ) { PreventHitDefaultEffect ( effIndex ) ; GetHitUnit ( ) -> CastSpell ( GetHitUnit ( ) , GetEffectValue ( ) , false ) ; } void Register ( ) OVERRIDE { OnEffectHitTarget += SpellEffectFn ( spell_wintergrasp_force_building_SpellScript :: HandleScript , EFFECT_0 , SPELL_EFFECT_SCRIPT_EFFECT ) ; } } ; SpellScript * GetSpellScript ( ) const OVERRIDE { return new spell_wintergrasp_force_building_SpellScript ( ) ; } } ; class spell_wintergrasp_grab_passenger : public SpellScriptLoader { public : spell_wintergrasp_grab_passenger ( ) : SpellScriptLoader ( " spell _ wintergrasp _ grab _ passenger " ) { } class spell_wintergrasp_grab_passenger_SpellScript : public SpellScript { PrepareSpellScript ( spell_wintergrasp_grab_passenger_SpellScript ) ; void HandleScript ( SpellEffIndex ) { if ( Player * target = GetHitPlayer ( ) ) target -> CastSpell ( GetCaster ( ) , SPELL_RIDE_WG_VEHICLE , false ) ; } void Register ( ) OVERRIDE { OnEffectHitTarget += SpellEffectFn ( spell_wintergrasp_grab_passenger_SpellScript :: HandleScript , EFFECT_0 , SPELL_EFFECT_SCRIPT_EFFECT ) ; } } ; SpellScript * GetSpellScript ( ) const OVERRIDE { return new spell_wintergrasp_grab_passenger_SpellScript ( ) ; } } ; class achievement_wg_didnt_stand_a_chance : public AchievementCriteriaScript { public : achievement_wg_didnt_stand_a_chance ( ) : AchievementCriteriaScript ( " achievement _ wg _ didnt _ stand _ a _ chance " ) { } bool OnCheck ( Player * source , Unit * target ) OVERRIDE { if ( ! target ) return false ; if ( Player * victim = target -> ToPlayer ( ) ) { if ( ! victim -> IsMounted ( ) ) return false ; if ( Vehicle * vehicle = source -> GetVehicle ( ) ) if ( vehicle -> GetVehicleInfo ( ) -> m_ID == 244 ) return true ; } return false ; } } ; enum WgTeleport { SPELL_WINTERGRASP_TELEPORT_TRIGGER = 54643 , } ; class spell_wintergrasp_defender_teleport : public SpellScriptLoader { public : spell_wintergrasp_defender_teleport ( ) : SpellScriptLoader ( " spell _ wintergrasp _ defender _ teleport " ) { } class spell_wintergrasp_defender_teleport_SpellScript : public SpellScript { PrepareSpellScript ( spell_wintergrasp_defender_teleport_SpellScript ) ; SpellCast@@ Result CheckCast ( ) { if ( Battlefield * wg = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ) if ( Player * target = GetExplTargetUnit ( ) -> ToPlayer ( ) ) if ( ( target -> GetZoneId ( ) == 4197 && target -> GetTeamId ( ) != wg -> GetDefenderTeam ( ) ) || target -> HasAura ( SPELL_WINTERGRASP_TELEPORT_TRIGGER ) ) return SPELL_FAIL@@ ED_BAD_@@ TARGETS ; return SPELL_CAST_OK ; } void Register ( ) OVERRIDE { OnCheckCast += SpellCheckCastFn ( spell_wintergrasp_defender_teleport_SpellScript :: CheckCast ) ; } } ; SpellScript * GetSpellScript ( ) const OVERRIDE { return new spell_wintergrasp_defender_teleport_SpellScript ( ) ; } } ; class spell_wintergrasp_defender_teleport_trigger : public SpellScriptLoader { public : spell_wintergrasp_defender_teleport_trigger ( ) : SpellScriptLoader ( " spell _ wintergrasp _ defender _ teleport _ trigger " ) { } class spell_wintergrasp_defender_teleport_trigger_SpellScript : public SpellScript { PrepareSpellScript ( spell_wintergrasp_defender_teleport_trigger_SpellScript ) ; void HandleDummy ( SpellEffIndex ) { if ( Unit * target = GetHitUnit ( ) ) { WorldLocation loc ; target -> GetPosition ( & loc ) ; SetExplTargetDest ( loc ) ; } } void Register ( ) OVERRIDE { OnEffectHitTarget += SpellEffectFn ( spell_wintergrasp_defender_teleport_trigger_SpellScript :: HandleDummy , EFFECT_0 , SPELL_EFFECT_DUMMY ) ; } } ; SpellScript * GetSpellScript ( ) const OVERRIDE { return new spell_wintergrasp_defender_teleport_trigger_SpellScript ( ) ; } } ; void AddSC_wintergrasp ( ) { new npc_wg_queue ( ) ; new npc_wg_spirit_guide ( ) ; new npc_wg_demolisher_engineer ( ) ; new go_wg_vehicle_teleporter ( ) ; new npc_wg_quest_giver ( ) ; new spell_wintergrasp_force_building ( ) ; new spell_wintergrasp_grab_passenger ( ) ; new achievement_wg_didnt_stand_a_chance ( ) ; new spell_wintergrasp_defender_teleport ( ) ; new spell_wintergrasp_defender_teleport_trigger ( ) ; } </DOCUMENT>
<DOCUMENT_ID="dolphin@@ -emu/dolphin/tree/master/Source/Core/@@ VideoCommon/@@ OnScreenDisplay.cpp"> # include " VideoCommon / OnScreenDisplay . h " # include < algorithm > # include < map > # include < mutex > # include < string > # include < fmt / format . h > # include < imgui . h > # include " Common / CommonTypes . h " # include " Common / Timer . h " # include " Core / ConfigManager . h " namespace OSD { constexpr float LEFT_MARGIN = 10.0f ; constexpr float TOP_MARGIN = 10.0f ; constexpr float WINDOW_PADDING = 4.0f ; struct Message { Message ( ) = default ; Message ( std :: string text_ , u32 timestamp_ , u32 color_ ) : text ( std :: move ( text_ ) ) , timestamp ( timestamp_ ) , color ( color_ ) { } std :: string text ; u32 timestamp = 0 ; u32 color = 0 ; } ; static std :: multimap < MessageType , Message > s_messages ; static std :: mutex s_messages_mutex ; static ImVec4 RGBAToImVec4 ( const u32 rgba ) { return ImVec4 ( static_cast < float > ( ( rgba >> 16 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 8 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 0 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 24 ) & 0xFF ) / 255.0f ) ; } static float DrawMessage ( int index , const Message & msg , const ImVec2 & position , int time_left ) { const std :: string window_name = fmt :: format ( " osd _ { } " , index ) ; ImGui :: SetNextWindowPos ( position ) ; ImGui :: SetNextWindowSize ( ImVec2 ( 0.0f , 0.0f ) ) ; const float alpha = std :: min ( 1.0f , std :: max ( 0.0f , time_left / 1024.0f ) ) ; ImGui :: PushStyleVar ( ImGuiStyleVar_Al@@ pha , alpha ) ; float window_height = 0.0f ; if ( ImGui :: Begin ( window_name . c_str ( ) , nullptr , ImGuiWindowFlags_NoTitle@@ Bar | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_Al@@ waysAutoResize | ImGuiWindowFlags_NoFocusOnApp@@ earing ) ) { ImGui :: TextColo@@ red ( RGBAToImVec4 ( msg . color ) , " % s " , msg . text . c_str ( ) ) ; window_height = ImGui :: GetWindowSize ( ) . y + ( WINDOW_PADDING * ImGui :: GetIO ( ) . DisplayFramebufferScale . y ) ; } ImGui :: End ( ) ; ImGui :: PopStyleVar ( ) ; return window_height ; } void AddTyped@@ Message ( MessageType type , std :: string message , u32 ms , u32 rgba ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . erase ( type ) ; s_messages . emplace ( type , Message ( std :: move ( message ) , Common :: Timer :: GetTimeMs ( ) + ms , rgba ) ) ; } void AddMessage ( std :: string message , u32 ms , u32 rgba ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . emplace ( MessageType :: Typeless , Message ( std :: move ( message ) , Common :: Timer :: GetTimeMs ( ) + ms , rgba ) ) ; } void DrawMessages ( ) { if ( ! SConfig :: GetInstance ( ) . bOnScreenDisplayMessages ) return ; { std :: lock_guard lock { s_messages_mutex } ; const u32 now = Common :: Timer :: GetTimeMs ( ) ; float current_x = LEFT_MARGIN * ImGui :: GetIO ( ) . DisplayFramebufferScale . x ; float current_y = TOP_MARGIN * ImGui :: GetIO ( ) . DisplayFramebufferScale . y ; int index = 0 ; auto it = s_messages . begin ( ) ; while ( it != s_messages . end ( ) ) { const Message & msg = it -> second ; const int time_left = static_cast < int > ( msg . timestamp - now ) ; current_y += DrawMessage ( index ++ , msg , ImVec2 ( current_x , current_y ) , time_left ) ; if ( time_left <= 0 ) it = s_messages . erase ( it ) ; else ++ it ; } } } void ClearMessages ( ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . clear ( ) ; } } </DOCUMENT>
