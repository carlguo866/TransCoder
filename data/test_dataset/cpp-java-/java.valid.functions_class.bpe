public B@@ ri@@ ck@@ Can@@ vas@@ Converter ( ) { }
public boolean can@@ Convert ( Class type ) { return ( type == B@@ ri@@ ck@@ Can@@ vas . class ) ; }
public void mar@@ sh@@ al ( Object source , Hierarch@@ ical@@ Stream@@ Writer writer , Mar@@ sh@@ all@@ ingContext context ) { B@@ ri@@ ck@@ Can@@ vas canvas = ( B@@ ri@@ ck@@ Can@@ vas ) source ; writer . start@@ Node ( " can@@ vas@@ Background@@ Image " ) ; context . convert@@ Another ( canvas . get@@ Background@@ Image ( ) ) ; writer . end@@ Node ( ) ; writer . start@@ Node ( " b@@ ri@@ ck@@ sOn@@ Can@@ vas " ) ; for ( Object obj : canvas . getB@@ ri@@ ck@@ s ( ) ) { if ( obj instanceof B@@ ri@@ c@@ k ) { writer . start@@ Node ( obj . getClass ( ) . getName ( ) ) ; context . convert@@ Another ( obj ) ; writer . end@@ Node ( ) ; } } writer . end@@ Node ( ) ; }
public Object un@@ mar@@ sh@@ al ( Hierarch@@ ical@@ Stream@@ Reader reader , Un@@ mar@@ sh@@ all@@ ingContext context ) { B@@ ri@@ ck@@ Can@@ vas canvas = B@@ ri@@ ck@@ Can@@ vas . getInstance ( ) ; while ( reader . hasMore@@ Children ( ) ) { reader . move@@ Down ( ) ; if ( reader . getNodeName ( ) . equals ( " can@@ vas@@ Background@@ Image " ) ) { canvas . set@@ Background@@ Image ( ( Background@@ Image ) context . convert@@ Another ( reader , Background@@ Image . class ) ) ; } if ( reader . getNodeName ( ) . equals ( " b@@ ri@@ ck@@ sOn@@ Can@@ vas " ) ) { while ( reader . hasMore@@ Children ( ) ) { reader . move@@ Down ( ) ; if ( reader . getNodeName ( ) . equals ( B@@ ri@@ c@@ k . class . getName ( ) ) ) { canvas . get@@ Layer ( ) . addChild ( ( B@@ ri@@ c@@ k ) context . convert@@ Another ( reader , B@@ ri@@ c@@ k . class ) ) ; } reader . move@@ Up ( ) ; } } reader . move@@ Up ( ) ; } return canvas ; }
public Sh@@ ard@@ Nodes ( UUID sh@@ ard@@ U@@ uid , Set < String > node@@ Identi@@ fiers ) { this . sh@@ ard@@ U@@ uid = check@@ NotNull ( sh@@ ard@@ U@@ uid , " sh@@ ard@@ U@@ uid ▁ is ▁ null " ) ; this . node@@ Identi@@ fiers = Immutable@@ Set . copy@@ Of ( check@@ NotNull ( node@@ Identi@@ fiers , " node@@ Identi@@ fiers ▁ is ▁ null " ) ) ; }
public UUID get@@ Sh@@ ard@@ U@@ uid ( ) { return sh@@ ard@@ U@@ uid ; }
public Set < String > getNode@@ Identi@@ fiers ( ) { return node@@ Identi@@ fiers ; }
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } Sh@@ ard@@ Nodes other = ( Sh@@ ard@@ Nodes ) obj ; return Objects . equals ( this . sh@@ ard@@ U@@ uid , other . sh@@ ard@@ U@@ uid ) && Objects . equals ( this . node@@ Identi@@ fiers , other . node@@ Identi@@ fiers ) ; }
public int hashCode ( ) { return Objects . hash ( sh@@ ard@@ U@@ uid , node@@ Identi@@ fiers ) ; }
public String toString ( ) { return toString@@ Helper ( this ) . add ( " sh@@ ard@@ U@@ uid " , sh@@ ard@@ U@@ uid ) . add ( " node@@ Identi@@ fiers " , node@@ Identi@@ fiers ) . toString ( ) ; }
public Option@@ Builder ( ) { default@@ Values = new ArrayList < String > ( ) ; }
public Option@@ Builder short@@ Name ( char n ) { short@@ Name = n ; return this ; }
public Option@@ Builder name ( String name ) { this . name = name ; return this ; }
public Option@@ Builder description ( String description ) { this . description = description ; return this ; }
public Option@@ Builder argument ( String argument ) { this . argument = argument ; return this ; }
public Option@@ Builder type ( Class < ? > type ) { this . type = type ; return this ; }
public Option@@ Builder required ( boolean required ) { this . required = required ; return this ; }
public Option@@ Builder fieldName ( String fieldName ) { this . fieldName = fieldName ; return this ; }
public Option@@ Builder has@@ Value ( boolean has@@ Value ) { this . has@@ Value = has@@ Value ; return this ; }
public Option@@ Builder is@@ Property ( boolean is@@ Property ) { this . is@@ Property = is@@ Property ; return this ; }
public Option@@ Builder has@@ Multiple@@ Values ( boolean has@@ Multiple@@ Values ) { this . has@@ Multiple@@ Values = has@@ Multiple@@ Values ; return this ; }
public Option@@ Builder add@@ Default@@ Value ( String defaultValue ) { this . default@@ Values . add ( defaultValue ) ; return this ; }
public Option@@ Builder value@@ Separator ( char value@@ Separator ) { this . value@@ Separator = value@@ Separator ; return this ; }
public Option@@ Builder option@@ Type ( Option@@ Type option@@ Type ) { this . option@@ Type = option@@ Type ; return this ; }
public Option@@ Builder converter ( Class < ? extends CL@@ Converter > converter ) { this . converter = converter ; return this ; }
public Option@@ Builder compl@@ eter ( Option@@ Compl@@ eter compl@@ eter ) { this . compl@@ eter = compl@@ eter ; return this ; }
public Option@@ Int create ( ) throws Option@@ Parser@@ Exception { if ( option@@ Type == null ) { if ( ! has@@ Value ) option@@ Type = Option@@ Type . BOO@@ LEA@@ N ; else if ( is@@ Property ) option@@ Type = Option@@ Type . GROUP ; else if ( has@@ Multiple@@ Values ) option@@ Type = Option@@ Type . LIST ; else option@@ Type = Option@@ Type . NORMAL ; } if ( name == null || ( name . length ( ) < 1 && option@@ Type != Option@@ Type . ARG@@ UM@@ ENT ) ) { if ( fieldName == null || fieldName . length ( ) < 1 ) throw new Option@@ Parser@@ Exception ( " Name ▁ must ▁ be ▁ defined ▁ to ▁ create ▁ an ▁ Option " ) ; else name = fieldName ; } return new Option@@ Int ( short@@ Name , name , description , argument , required , value@@ Separator , default@@ Values , type , fieldName , option@@ Type , converter , compl@@ eter ) ; }
protected Props ( ) { init ( ) ; }
protected Props ( int t ) { type = t ; filename = getFilename ( ) ; init ( ) ; }
protected void init ( ) { create@@ Log@@ Channel ( ) ; properties = new Properties ( ) ; plugin@@ History = new ArrayList < Object@@ Us@@ age@@ Count > ( ) ; load@@ Props ( ) ; add@@ Default@@ Entries ( ) ; load@@ Plugin@@ History ( ) ; }
protected Props ( String filename ) { properties = new Properties ( ) ; this . type = TYPE_@@ PROPER@@ TI@@ ES_@@ EMP@@ TY ; this . filename = filename ; init ( ) ; }
public String toString ( ) { return STRING_@@ USER_@@ PRE@@ FEREN@@ CES ; }
protected void create@@ Log@@ Channel ( ) { log = new Log@@ Channel ( STRING_@@ USER_@@ PRE@@ FEREN@@ CES ) ; }
public String getFilename ( ) { String filename = " " ; String directory = Const . get@@ K@@ et@@ tle@@ Directory ( ) ; switch ( type ) { case TYPE_@@ PROPER@@ TI@@ ES@@ _S@@ PO@@ ON : case TYPE_@@ PROPER@@ TI@@ ES_@@ PAN : filename = directory + Const . FILE_@@ SEPAR@@ ATOR + " . s@@ po@@ on@@ rc " ; break ; case TYPE_@@ PROPER@@ TI@@ ES_@@ CH@@ E@@ F : case TYPE_@@ PROPER@@ TI@@ ES_@@ K@@ IT@@ CH@@ EN : filename = directory + Const . FILE_@@ SEPAR@@ ATOR + " . ch@@ e@@ fr@@ c " ; break ; case TYPE_@@ PROPER@@ TI@@ ES_@@ MEN@@ U : filename = directory + Const . FILE_@@ SEPAR@@ ATOR + " . men@@ ur@@ c " ; break ; case TYPE_@@ PROPER@@ TI@@ ES_@@ PL@@ ATE : filename = directory + Const . FILE_@@ SEPAR@@ ATOR + " . pl@@ ater@@ c " ; break ; default : break ; } return filename ; }
public String get@@ L@@ ic@@ en@@ se@@ Filename ( ) { String directory = Const . get@@ K@@ et@@ tle@@ Directory ( ) ; String filename = directory + Const . FILE_@@ SEPAR@@ ATOR + " . lic@@ ence " ; File dir = new File ( directory ) ; if ( ! dir . exists ( ) ) { try { dir . mkdirs ( ) ; } catch ( Exception e ) { } } return filename ; }
public boolean file@@ Exists ( ) { File f = new File ( filename ) ; return f . exists ( ) ; }
public void setType ( int t ) { type = t ; }
public int getType ( ) { return type ; }
public boolean load@@ Props ( ) { try { FileInputStream fi@@ s = new FileInputStream ( filename ) ; try { properties . load ( fi@@ s ) ; } finally { try { fi@@ s . close ( ) ; } catch ( IOException ignored ) { } } } catch ( Exception e ) { return false ; } return true ; }
protected void add@@ Default@@ Entries ( ) { if ( ! properties . containsKey ( " Job@@ Dialog@@ Style " ) ) { properties . setProperty ( " Job@@ Dialog@@ Style " , " RESI@@ ZE , MAX , MIN " ) ; } }
public void save@@ Props ( ) { File s@@ po@@ on@@ Rc = new File ( filename ) ; try { Sor@@ ted@@ FileOutputStream fo@@ s = new Sor@@ ted@@ FileOutputStream ( s@@ po@@ on@@ Rc ) ; fo@@ s . set@@ Logger ( log ) ; properties . store ( fo@@ s , " K@@ et@@ t@@ le ▁ Properties ▁ file " ) ; fo@@ s . close ( ) ; log . log@@ Det@@ a@@ iled ( Base@@ Messages . get@@ String ( P@@ K@@ G , " S@@ po@@ on . Log . Save@@ Properties " ) ) ; } catch ( IOException e ) { if ( s@@ po@@ on@@ Rc . isH@@ id@@ den ( ) && filename . indexOf ( ' \\ ' ) != - 1 ) { log . logError ( Base@@ Messages . get@@ String ( P@@ K@@ G , " S@@ po@@ on . Log . Save@@ Properties@@ Failed@@ Window@@ s@@ Bu@@ g@@ Attr " , filename ) ) ; } else { log . logError ( Base@@ Messages . get@@ String ( P@@ K@@ G , " S@@ po@@ on . Log . Save@@ Properties@@ Failed " ) + e . getMessage ( ) ) ; } } }
public void set@@ LogLevel ( String level ) { properties . setProperty ( STRING_@@ LOG_@@ LEVEL , level ) ; }
public String getLogLevel ( ) { String level = properties . getProperty ( STRING_@@ LOG_@@ LEVEL , " Basic " ) ; return level ; }
public void set@@ LogFilter ( String filter ) { properties . setProperty ( STRING_@@ LOG_@@ FIL@@ TER , Const . NV@@ L ( filter , " " ) ) ; }
public String getLog@@ Filter ( ) { String level = properties . getProperty ( STRING_@@ LOG_@@ FIL@@ TER , " " ) ; return level ; }
public void set@@ Use@@ DB@@ Cache ( boolean use ) { properties . setProperty ( STRING_@@ USE_@@ DB@@ _C@@ ACH@@ E , use ? " Y " : " N " ) ; }
public boolean use@@ DB@@ Cache ( ) { String use = properties . getProperty ( STRING_@@ USE_@@ DB@@ _C@@ ACH@@ E ) ; return ! " N " . equalsIgnoreCase ( use ) ; }
public void set@@ Last@@ Repository ( String rep@@ name ) { properties . setProperty ( STRING_@@ LAS@@ T_@@ RE@@ POSI@@ TORY , rep@@ name ) ; }
public String getLast@@ Repository ( ) { return properties . getProperty ( STRING_@@ LAS@@ T_@@ RE@@ POSI@@ TORY ) ; }
public void set@@ Last@@ Re@@ posi@@ t@@ ory@@ Login ( String lo@@ gin ) { properties . setProperty ( STRING_@@ LAS@@ T_@@ RE@@ POSI@@ TOR@@ Y_@@ LOG@@ IN , lo@@ gin ) ; }
public String getLast@@ Re@@ posi@@ t@@ ory@@ Login ( ) { return properties . getProperty ( STRING_@@ LAS@@ T_@@ RE@@ POSI@@ TOR@@ Y_@@ LOG@@ IN ) ; }
public void setOn@@ ly@@ Active@@ Steps ( boolean only ) { properties . setProperty ( STRING_@@ ONLY_@@ AC@@ TIVE_@@ STE@@ P@@ S , only ? " Y " : " N " ) ; }
public boolean get@@ Only@@ Active@@ Steps ( ) { String only = properties . getProperty ( STRING_@@ ONLY_@@ AC@@ TIVE_@@ STE@@ P@@ S , " N " ) ; return " Y " . equalsIgnoreCase ( only ) ; }
public boolean ask@@ About@@ Replac@@ ing@@ Database@@ Connec@@ tions ( ) { String ask = properties . getProperty ( STRING_@@ AS@@ K@@ _A@@ BO@@ UT_@@ RE@@ PL@@ AC@@ ING_@@ DAT@@ AB@@ AS@@ ES , " N " ) ; return " Y " . equalsIgnoreCase ( ask ) ; }
public void setProperty ( String propertyName , String value ) { properties . setProperty ( propertyName , value ) ; }
public String getProperty ( String propertyName ) { return properties . getProperty ( propertyName ) ; }
public void set@@ As@@ k@@ About@@ Replac@@ ing@@ Database@@ Connec@@ tions ( boolean ask ) { properties . setProperty ( STRING_@@ AS@@ K@@ _A@@ BO@@ UT_@@ RE@@ PL@@ AC@@ ING_@@ DAT@@ AB@@ AS@@ ES , ask ? " Y " : " N " ) ; }
public String get@@ Custom@@ Parameter ( String parameter@@ Name , String defaultValue ) { return properties . getProperty ( STRING_@@ CUSTO@@ M_@@ PARAME@@ TER + parameter@@ Name , defaultValue ) ; }
public void set@@ Custom@@ Parameter ( String parameter@@ Name , String value ) { properties . setProperty ( STRING_@@ CUSTO@@ M_@@ PARAME@@ TER + parameter@@ Name , value ) ; }
public void clear@@ Custom@@ Parameters ( ) { Enum@@ er@@ ation < Object > keys = properties . keys ( ) ; while ( keys . hasMore@@ Elements ( ) ) { String key = ( String ) keys . next@@ Element ( ) ; if ( key . startsWith ( STRING_@@ CUSTO@@ M_@@ PARAME@@ TER ) ) { properties . remove ( key ) ; } } }
public void set@@ Last@@ Arguments ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { if ( args [ i ] != null ) { properties . setProperty ( STRING_@@ LAS@@ T_@@ ARG@@ UM@@ ENT + " _ " + i , args [ i ] ) ; } } }
public String [ ] getLast@@ Arguments ( ) { String [ ] args = new String [ 10 ] ; for ( int i = 0 ; i < args . length ; i ++ ) { args [ i ] = properties . getProperty ( STRING_@@ LAS@@ T_@@ ARG@@ UM@@ ENT + " _ " + i ) ; } return args ; }
public List < Object@@ Us@@ age@@ Count > get@@ Plugin@@ History ( ) { return plugin@@ History ; }
public int incre@@ ase@@ Plugin@@ History ( String plugin@@ ID ) { for ( int i = 0 ; i < plugin@@ History . size ( ) ; i ++ ) { Object@@ Us@@ age@@ Count usage = plugin@@ History . get ( i ) ; if ( usage . getObject@@ Name ( ) . equalsIgnoreCase ( plugin@@ ID ) ) { int uses = usage . increment ( ) ; Collections . sort ( plugin@@ History ) ; save@@ Plugin@@ History ( ) ; return uses ; } } add@@ Plugin@@ History ( plugin@@ ID , 1 ) ; Collections . sort ( plugin@@ History ) ; save@@ Plugin@@ History ( ) ; return 1 ; }
public void add@@ Plugin@@ History ( String plugin@@ ID , int uses ) { plugin@@ History . add ( new Object@@ Us@@ age@@ Count ( plugin@@ ID , uses ) ) ; }
protected void load@@ Plugin@@ History ( ) { plugin@@ History = new ArrayList < Object@@ Us@@ age@@ Count > ( ) ; int i = 0 ; String string = properties . getProperty ( STRING_@@ PLUGIN_@@ HI@@ ST@@ OR@@ Y + " _ " + i ) ; while ( string != null ) { plugin@@ History . add ( Object@@ Us@@ age@@ Count . fromString ( string ) ) ; i ++ ; string = properties . getProperty ( STRING_@@ PLUGIN_@@ HI@@ ST@@ OR@@ Y + " _ " + i ) ; } Collections . sort ( plugin@@ History ) ; }
private void save@@ Plugin@@ History ( ) { for ( int i = 0 ; i < plugin@@ History . size ( ) ; i ++ ) { Object@@ Us@@ age@@ Count usage = plugin@@ History . get ( i ) ; properties . setProperty ( STRING_@@ PLUGIN_@@ HI@@ ST@@ OR@@ Y + " _ " + i , usage . toString ( ) ) ; } }
public boolean are@@ Only@@ U@@ sed@@ Connection@@ s@@ Saved@@ To@@ XML ( ) { String show = properties . getProperty ( STRING_@@ ONLY_@@ USE@@ D_@@ DB_@@ TO_@@ XML , " Y " ) ; return " Y " . equalsIgnoreCase ( show ) ; }
public void setOn@@ ly@@ U@@ sed@@ Connection@@ s@@ Saved@@ To@@ XML ( boolean only@@ U@@ sed@@ Connec@@ tions ) { properties . setProperty ( STRING_@@ ONLY_@@ USE@@ D_@@ DB_@@ TO_@@ XML , only@@ U@@ sed@@ Connec@@ tions ? " Y " : " N " ) ; }
public boolean replace@@ Existing@@ Database@@ Connec@@ tions ( ) { String replace = properties . getProperty ( STRING_@@ RE@@ PL@@ ACE_@@ DAT@@ AB@@ AS@@ ES , " Y " ) ; return " Y " . equalsIgnoreCase ( replace ) ; }
public void set@@ Repl@@ ace@@ Database@@ Connec@@ tions ( boolean replace ) { properties . setProperty ( STRING_@@ RE@@ PL@@ ACE_@@ DAT@@ AB@@ AS@@ ES , replace ? " Y " : " N " ) ; }
public boolean show@@ New@@ Sub@@ trans@@ Popup ( ) { String show = properties . getProperty ( STRING@@ _SH@@ O@@ W_@@ NE@@ W@@ _SUB@@ TRAN@@ S_@@ P@@ OP@@ UP , " Y " ) ; return " Y " . equalsIgnoreCase ( show ) ; }
public void set@@ Show@@ New@@ Sub@@ trans@@ Popup ( boolean show ) { properties . setProperty ( STRING@@ _SH@@ O@@ W_@@ NE@@ W@@ _SUB@@ TRAN@@ S_@@ P@@ OP@@ UP , show ? " Y " : " N " ) ; }
public int getMax@@ N@@ r@@ Lin@@ es@@ In@@ Log ( ) { String lines = properties . getProperty ( STRING_@@ MAX_@@ N@@ R_@@ LIN@@ ES_@@ IN_@@ LOG ) ; return Const . toInt ( lines , Const . MAX_@@ N@@ R_@@ LOG_@@ LINES ) ; }
public void setMax@@ N@@ r@@ Lin@@ es@@ In@@ Log ( int max@@ N@@ r@@ Lin@@ es@@ In@@ Log ) { properties . setProperty ( STRING_@@ MAX_@@ N@@ R_@@ LIN@@ ES_@@ IN_@@ LOG , Integer . toString ( max@@ N@@ r@@ Lin@@ es@@ In@@ Log ) ) ; }
public int getMax@@ N@@ r@@ Lin@@ es@@ In@@ History ( ) { String lines = properties . getProperty ( STRING_@@ MAX_@@ N@@ R_@@ LIN@@ ES_@@ IN_@@ HI@@ ST@@ OR@@ Y ) ; return Const . toInt ( lines , Const . MAX_@@ N@@ R_@@ HI@@ ST@@ OR@@ Y_@@ LINES ) ; }
public int get@@ Lin@@ es@@ In@@ History@@ Fet@@ ch@@ Size ( ) { String fet@@ ch@@ Size = properties . getProperty ( STRING_@@ LIN@@ ES_@@ IN_@@ HI@@ ST@@ OR@@ Y_@@ FE@@ T@@ CH_SIZE ) ; return Const . toInt ( fet@@ ch@@ Size , Const . HI@@ ST@@ OR@@ Y_@@ LIN@@ ES@@ _FE@@ T@@ CH_SIZE ) ; }
public boolean dis@@ able@@ Initial@@ Exec@@ ution@@ History ( ) { String disable = properties . getProperty ( STRING_@@ DISAB@@ LE_@@ INITI@@ AL_@@ EXEC@@ UTION_@@ HI@@ ST@@ OR@@ Y , " N " ) ; return " Y " . equalsIgnoreCase ( disable ) ; }
public void setMax@@ N@@ r@@ Lin@@ es@@ In@@ History ( int max@@ N@@ r@@ Lin@@ es@@ In@@ History ) { properties . setProperty ( STRING_@@ MAX_@@ N@@ R_@@ LIN@@ ES_@@ IN_@@ HI@@ ST@@ OR@@ Y , Integer . toString ( max@@ N@@ r@@ Lin@@ es@@ In@@ History ) ) ; }
public void set@@ Lin@@ es@@ In@@ History@@ Fet@@ ch@@ Size ( int lines@@ In@@ History@@ Fet@@ ch@@ Size ) { properties . setProperty ( STRING_@@ LIN@@ ES_@@ IN_@@ HI@@ ST@@ OR@@ Y_@@ FE@@ T@@ CH_SIZE , Integer . toString ( lines@@ In@@ History@@ Fet@@ ch@@ Size ) ) ; }
public void set@@ Disable@@ Initial@@ Exec@@ ution@@ History ( boolean disable ) { properties . setProperty ( STRING_@@ DISAB@@ LE_@@ INITI@@ AL_@@ EXEC@@ UTION_@@ HI@@ ST@@ OR@@ Y , disable ? " Y " : " N " ) ; }
public int getMax@@ Log@@ Line@@ Time@@ out@@ Min@@ utes ( ) { String min@@ utes = properties . getProperty ( STRING_@@ MAX_@@ LOG_@@ LINE_@@ TIME@@ OUT_@@ MINUTES ) ; return Const . toInt ( min@@ utes , Const . MAX_@@ LOG_@@ LINE_@@ TIME@@ OUT_@@ MINUTES ) ; }
public void setMax@@ Log@@ Line@@ Time@@ out@@ Min@@ utes ( int max@@ Log@@ Line@@ Time@@ out@@ Min@@ utes ) { properties . setProperty ( STRING_@@ MAX_@@ LOG_@@ LINE_@@ TIME@@ OUT_@@ MINUTES , Integer . toString ( max@@ Log@@ Line@@ Time@@ out@@ Min@@ utes ) ) ; }
public void reset ( ) { props = null ; properties . clear ( ) ; plugin@@ History . clear ( ) ; }
public React@@ Mod@@ al@@ Host@@ View ( Context context ) { super ( context ) ; ( ( React@@ Context ) context ) . add@@ Li@@ f@@ ec@@ y@@ cle@@ EventListener ( this ) ; m@@ Host@@ View = new Dialog@@ Root@@ ViewGroup ( context ) ; }
protected void on@@ Layout ( boolean changed , int l , int t , int r , int b ) { }
public void addView ( View child , int index ) { m@@ Host@@ View . addView ( child , index ) ; }
public int getChild@@ Count ( ) { return m@@ Host@@ View . getChild@@ Count ( ) ; }
public View getChild@@ At ( int index ) { return m@@ Host@@ View . getChild@@ At ( index ) ; }
public void remove@@ View ( View child ) { m@@ Host@@ View . remove@@ View ( child ) ; }
public void remove@@ View@@ At ( int index ) { View child = getChild@@ At ( index ) ; m@@ Host@@ View . remove@@ View ( child ) ; }
public void add@@ Children@@ For@@ Acces@@ si@@ b@@ ility ( ArrayList < View > out@@ Children ) { }
public boolean dispatch@@ Populate@@ Acces@@ si@@ b@@ ili@@ ty@@ Event ( Acces@@ si@@ b@@ ili@@ ty@@ Event event ) { return false ; }
public void on@@ Dro@@ p@@ Instance ( ) { ( ( React@@ Context ) getContext ( ) ) . remove@@ Li@@ f@@ ec@@ y@@ cle@@ EventListener ( this ) ; dis@@ mis@@ s ( ) ; }
private void dis@@ mis@@ s ( ) { if ( m@@ Dialog != null ) { m@@ Dialog . dis@@ mis@@ s ( ) ; m@@ Dialog = null ; ViewGroup parent = ( ViewGroup ) m@@ Host@@ View . getParent ( ) ; parent . remove@@ View@@ At ( 0 ) ; } }
protected void setOn@@ Request@@ Close@@ Listener ( On@@ Request@@ Close@@ Listener listener ) { mOn@@ Request@@ Close@@ Listener = listener ; }
protected void setOn@@ Show@@ Listener ( DialogInterface . On@@ Show@@ Listener listener ) { mOn@@ Show@@ Listener = listener ; }
protected void set@@ Trans@@ parent ( boolean transparent ) { m@@ Trans@@ parent = transparent ; }
protected void set@@ Animation@@ Type ( String animation@@ Type ) { m@@ Animation@@ Type = animation@@ Type ; m@@ Property@@ Requi@@ res@@ New@@ Dialog = true ; }
public void on@@ Host@@ Resume ( ) { show@@ Or@@ Update ( ) ; }
public void on@@ Host@@ Pause ( ) { dis@@ mis@@ s ( ) ; }
public void on@@ Host@@ Destroy ( ) { on@@ Dro@@ p@@ Instance ( ) ; }
@ Visible@@ ForTesting public @ Nullable Dialog get@@ Dialog ( ) { return m@@ Dialog ; }
protected void show@@ Or@@ Update ( ) { if ( m@@ Dialog != null ) { if ( m@@ Property@@ Requi@@ res@@ New@@ Dialog ) { dis@@ mis@@ s ( ) ; } else { update@@ Properties ( ) ; return ; } } m@@ Property@@ Requi@@ res@@ New@@ Dialog = false ; int the@@ me = R . style . Them@@ e_@@ Full@@ Screen@@ Dialog ; if ( m@@ Animation@@ Type . equals ( " fade " ) ) { the@@ me = R . style . Them@@ e_@@ Full@@ Screen@@ Dialog@@ Anim@@ ated@@ Fade ; } else if ( m@@ Animation@@ Type . equals ( " sli@@ de " ) ) { the@@ me = R . style . Them@@ e_@@ Full@@ Screen@@ Dialog@@ Anim@@ ated@@ Sli@@ de ; } m@@ Dialog = new Dialog ( getContext ( ) , the@@ me ) ; m@@ Dialog . setContentView ( get@@ Content@@ View ( ) ) ; update@@ Properties ( ) ; m@@ Dialog . setOn@@ Show@@ Listener ( mOn@@ Show@@ Listener ) ; m@@ Dialog . setOn@@ Key@@ Listener ( new DialogInterface . On@@ Key@@ Listener ( ) { @ Override public boolean on@@ Key ( DialogInterface dialog , int keyCode , KeyEvent event ) { if ( event . getAction ( ) == KeyEvent . ACTION_@@ UP ) { if ( keyCode == KeyEvent . KEYCODE_@@ BACK ) { As@@ ser@@ tions . assertNotNull ( mOn@@ Request@@ Close@@ Listener , " setOn@@ Request@@ Close@@ Listener ▁ must ▁ be ▁ called ▁ by ▁ the ▁ manager " ) ; mOn@@ Request@@ Close@@ Listener . on@@ Request@@ Close ( dialog ) ; return true ; } else { Activity current@@ Activity = ( ( React@@ Context ) getContext ( ) ) . getCurrent@@ Activity ( ) ; if ( current@@ Activity != null ) { return current@@ Activity . onKey@@ Up ( keyCode , event ) ; } } } return false ; } } ) ; m@@ Dialog . get@@ Window ( ) . set@@ So@@ ft@@ Input@@ Mode ( WindowManager . Layout@@ Params . SOF@@ T_@@ IN@@ PU@@ T_@@ ADJUS@@ T_@@ RESI@@ ZE ) ; m@@ Dialog . show ( ) ; }
private View get@@ Content@@ View ( ) { FrameLayout frame@@ Layout = new FrameLayout ( getContext ( ) ) ; frame@@ Layout . addView ( m@@ Host@@ View ) ; frame@@ Layout . set@@ Fit@@ s@@ System@@ Windows ( true ) ; return frame@@ Layout ; }
private void update@@ Properties ( ) { As@@ ser@@ tions . assertNotNull ( m@@ Dialog , " m@@ Dialog ▁ must ▁ exist ▁ when ▁ w@@ e ▁ call ▁ update@@ Properties " ) ; if ( m@@ Trans@@ parent ) { m@@ Dialog . get@@ Window ( ) . clear@@ Flags ( WindowManager . Layout@@ Params . FLAG_@@ DI@@ M_@@ BEH@@ IN@@ D ) ; } else { m@@ Dialog . get@@ Window ( ) . set@@ Dim@@ Amount ( 0.5f ) ; m@@ Dialog . get@@ Window ( ) . set@@ Flags ( WindowManager . Layout@@ Params . FLAG_@@ DI@@ M_@@ BEH@@ IN@@ D , WindowManager . Layout@@ Params . FLAG_@@ DI@@ M_@@ BEH@@ IN@@ D ) ; } }
public Dialog@@ Root@@ ViewGroup ( Context context ) { super ( context ) ; }
protected void on@@ Size@@ Changed ( final int w , final int h , int old@@ w , int old@@ h ) { super . on@@ Size@@ Changed ( w , h , old@@ w , old@@ h ) ; if ( getChild@@ Count ( ) > 0 ) { ( ( React@@ Context ) getContext ( ) ) . run@@ On@@ Native@@ Module@@ s@@ Queue@@ Thread ( new Runnable ( ) { @ Override public void run ( ) { ( ( React@@ Context ) getContext ( ) ) . get@@ Native@@ Module ( UIM@@ anag@@ er@@ Module . class ) . update@@ Node@@ Size ( getChild@@ At ( 0 ) . getId ( ) , w , h ) ; } } ) ; } }
public boolean on@@ Inter@@ cept@@ Touch@@ Event ( Mo@@ tion@@ Event event ) { m@@ JS@@ Touch@@ Disp@@ atch@@ er . handle@@ Touch@@ Event ( event , getEvent@@ Disp@@ atch@@ er ( ) ) ; return super . on@@ Inter@@ cept@@ Touch@@ Event ( event ) ; }
public boolean on@@ Touch@@ Event ( Mo@@ tion@@ Event event ) { m@@ JS@@ Touch@@ Disp@@ atch@@ er . handle@@ Touch@@ Event ( event , getEvent@@ Disp@@ atch@@ er ( ) ) ; super . on@@ Touch@@ Event ( event ) ; return true ; }
public void on@@ Child@@ Star@@ ted@@ Native@@ G@@ est@@ ure ( Mo@@ tion@@ Event android@@ Event ) { m@@ JS@@ Touch@@ Disp@@ atch@@ er . on@@ Child@@ Star@@ ted@@ Native@@ G@@ est@@ ure ( android@@ Event , getEvent@@ Disp@@ atch@@ er ( ) ) ; }
public void request@@ Disallow@@ Inter@@ cept@@ Touch@@ Event ( boolean dis@@ allow@@ Inter@@ cept ) { }
private Event@@ Disp@@ atch@@ er getEvent@@ Disp@@ atch@@ er ( ) { React@@ Context re@@ act@@ Context = ( React@@ Context ) getContext ( ) ; return re@@ act@@ Context . get@@ Native@@ Module ( UIM@@ anag@@ er@@ Module . class ) . getEvent@@ Disp@@ atch@@ er ( ) ; }
protected void before@@ Test@@ s@@ Started ( ) throws Exception { System . setProperty ( " IGN@@ IT@@ E _ SK@@ IP _ CON@@ FIGUR@@ ATION _ CON@@ SI@@ ST@@ EN@@ C@@ Y _ CHECK " , " true " ) ; }
protected void after@@ Test@@ s@@ Stopped ( ) throws Exception { System . clearProperty ( " IGN@@ IT@@ E _ SK@@ IP _ CON@@ FIGUR@@ ATION _ CON@@ SI@@ ST@@ EN@@ C@@ Y _ CHECK " ) ; }
protected void after@@ Test ( ) throws Exception { stop@@ All@@ G@@ ri@@ ds ( ) ; }
protected void before@@ Test ( ) throws Exception { client@@ Rec@@ on@@ n@@ ect@@ Disabled = false ; }
protected Ig@@ n@@ ite@@ Configuration get@@ Configuration ( String grid@@ Name ) throws Exception { Ig@@ n@@ ite@@ Configuration cfg = super . get@@ Configuration ( grid@@ Name ) ; if ( grid@@ Name . contains ( " client " ) ) { cfg . set@@ Comm@@ un@@ ic@@ ation@@ Sp@@ i ( new T@@ cp@@ Comm@@ un@@ ic@@ ation@@ Sp@@ i ( ) ) ; T@@ cp@@ Dis@@ cover@@ y@@ Sp@@ i sp@@ i = ( T@@ cp@@ Dis@@ cover@@ y@@ Sp@@ i ) cfg . get@@ Dis@@ cover@@ y@@ Sp@@ i ( ) ; Dis@@ cover@@ y@@ Sp@@ i d@@ sp@@ i = new Dis@@ cover@@ y@@ Sp@@ i ( ) ; d@@ sp@@ i . set@@ I@@ p@@ Finder ( sp@@ i . get@@ I@@ p@@ Finder ( ) ) ; cfg . set@@ Dis@@ cover@@ y@@ Sp@@ i ( d@@ sp@@ i ) ; d@@ sp@@ i . setJoin@@ Timeout ( 60@@ _@@ 000 ) ; d@@ sp@@ i . set@@ Client@@ Rec@@ on@@ n@@ ect@@ Disabled ( client@@ Rec@@ on@@ n@@ ect@@ Disabled ) ; cfg . set@@ Client@@ Mode ( true ) ; } cfg . set@@ Pe@@ er@@ Class@@ Load@@ ingEnabled ( false ) ; return cfg ; }
@ Test public void test@@ Client@@ s@@ Rec@@ on@@ n@@ ect@@ After@@ Start ( ) throws Exception { Ig@@ n@@ ite sr@@ v1 = start@@ Grid ( " server@@ 1" ) ; cr@@ d = ( ( Ig@@ n@@ ite@@ Ker@@ nal ) sr@@ v1 ) . localNode ( ) ; Ig@@ n@@ ite sr@@ v2 = start@@ Grid ( " server@@ 2" ) ; final Count@@ Down@@ L@@ atch l@@ atch = new Count@@ Down@@ L@@ atch ( 1 ) ; List < Ig@@ n@@ ite > client@@ Nodes = new ArrayList < > ( ) ; final int CLI@@ ENT@@ S_@@ NUM = 5 ; for ( int i = 0 ; i < CLI@@ ENT@@ S_@@ NUM ; i ++ ) client@@ Nodes . add ( start@@ Grid ( " client " + i ) ) ; block@@ All = true ; Grid@@ Test@@ Utils . run@@ A@@ sync ( new Cal@@ lable < Object > ( ) { @ Override public Object call ( ) throws Exception { U . sleep ( 5@@ _@@ 000 ) ; block = true ; block@@ All = false ; System . out . println ( " > > > ▁ Al@@ low ▁ with ▁ block@@ ed ▁ coord@@ in@@ ator . " ) ; l@@ atch . count@@ Down ( ) ; return null ; } } ) ; Ig@@ n@@ ite@@ Internal@@ F@@ u@@ ture < Object > f@@ ut = Grid@@ Test@@ Utils . run@@ A@@ sync ( new Cal@@ lable < Object > ( ) { @ Override public Object call ( ) throws Exception { l@@ atch . a@@ wait ( ) ; U . sleep ( ( new Random ( ) . nextInt ( 15 ) + 30 ) * 1000 ) ; block = false ; System . out . println ( " > > > ▁ Al@@ low ▁ coord@@ in@@ ator . " ) ; return null ; } } ) ; f@@ ut . get ( ) ; for ( Ig@@ n@@ ite client : client@@ Nodes ) { while ( true ) { try { Ig@@ n@@ ite@@ Cache < Integer , Integer > cache = client . get@@ Or@@ Create@@ Cache ( " some " ) ; for ( int i = 0 ; i < 100 ; i ++ ) cache . put ( i , i ) ; for ( int i = 0 ; i < 100 ; i ++ ) assertEquals ( ( Integer ) i , cache . get ( i ) ) ; cache . clear ( ) ; break ; } catch ( Ig@@ n@@ ite@@ Client@@ Disconnec@@ tedException e ) { e . re@@ connect@@ F@@ u@@ ture ( ) . get ( ) ; } } } assertEquals ( CLI@@ ENT@@ S_@@ NUM , sr@@ v1 . cluster ( ) . for@@ Cli@@ ents ( ) . nodes ( ) . size ( ) ) ; assertEquals ( CLI@@ ENT@@ S_@@ NUM , sr@@ v2 . cluster ( ) . for@@ Cli@@ ents ( ) . nodes ( ) . size ( ) ) ; }
@ Test public void test@@ Client@@ s@@ Rec@@ on@@ n@@ ect ( ) throws Exception { Ig@@ n@@ ite sr@@ v1 = start@@ Grid ( " server@@ 1" ) ; cr@@ d = ( ( Ig@@ n@@ ite@@ Ker@@ nal ) sr@@ v1 ) . localNode ( ) ; Ig@@ n@@ ite sr@@ v2 = start@@ Grid ( " server@@ 2" ) ; block = true ; List < Ig@@ n@@ ite@@ Internal@@ F@@ u@@ ture < Ig@@ n@@ ite > > f@@ ut@@ s = new ArrayList < > ( ) ; final Count@@ Down@@ L@@ atch l@@ atch = new Count@@ Down@@ L@@ atch ( 1 ) ; final int CLI@@ ENT@@ S_@@ NUM = 5 ; for ( int i = 0 ; i < CLI@@ ENT@@ S_@@ NUM ; i ++ ) { final int idx = i ; Ig@@ n@@ ite@@ Internal@@ F@@ u@@ ture < Ig@@ n@@ ite > f@@ ut = Grid@@ Test@@ Utils . run@@ A@@ sync ( new Cal@@ lable < Ig@@ n@@ ite > ( ) { @ Override public Ig@@ n@@ ite call ( ) throws Exception { l@@ atch . a@@ wait ( ) ; String node@@ Name = " client " + idx ; Ig@@ n@@ ite@@ Configuration cfg = get@@ Configuration ( node@@ Name ) . set@@ Fa@@ ilu@@ re@@ Handler ( new Abstract@@ Fa@@ ilu@@ re@@ Handler ( ) { @ Override protected boolean handle ( Ig@@ n@@ ite ig@@ n@@ ite , Fa@@ ilu@@ re@@ Context failu@@ re@@ C@@ tx ) { Runtime . get@@ Runtime ( ) . halt ( Ig@@ ni@@ tion . K@@ ILL_@@ EXIT_@@ CODE ) ; return false ; } } ) ; return start@@ Grid ( node@@ Name , optimize ( cfg ) , null ) ; } } ) ; f@@ ut@@ s . add ( f@@ ut ) ; } Grid@@ Test@@ Utils . run@@ A@@ sync ( new Cal@@ lable < Boolean > ( ) { @ Override public Boolean call ( ) throws Exception { l@@ atch . count@@ Down ( ) ; Random rn@@ d = new Random ( ) ; U . sleep ( ( rn@@ d . nextInt ( 15 ) + 15 ) * 1000 ) ; block = false ; System . out . println ( " > > > ▁ ALLO@@ W ▁ connection ▁ to ▁ coord@@ in@@ ator . " ) ; return true ; } } ) ; for ( Ig@@ n@@ ite@@ Internal@@ F@@ u@@ ture < Ig@@ n@@ ite > client@@ F@@ ut : f@@ ut@@ s ) { Ig@@ n@@ ite client = client@@ F@@ ut . get ( ) ; Ig@@ n@@ ite@@ Cache < Integer , Integer > cache = client . get@@ Or@@ Create@@ Cache ( client . name ( ) ) ; for ( int i = 0 ; i < 100 ; i ++ ) cache . put ( i , i ) ; for ( int i = 0 ; i < 100 ; i ++ ) assert i == cache . get ( i ) ; } assertEquals ( CLI@@ ENT@@ S_@@ NUM , sr@@ v1 . cluster ( ) . for@@ Cli@@ ents ( ) . nodes ( ) . size ( ) ) ; assertEquals ( CLI@@ ENT@@ S_@@ NUM , sr@@ v2 . cluster ( ) . for@@ Cli@@ ents ( ) . nodes ( ) . size ( ) ) ; }
@ Test public void test@@ Client@@ s@@ Rec@@ on@@ n@@ ect@@ Disabled ( ) throws Exception { client@@ Rec@@ on@@ n@@ ect@@ Disabled = true ; Ig@@ n@@ ite sr@@ v1 = start@@ Grid ( " server@@ 1" ) ; if ( ! t@@ cp@@ Discovery ( ) ) return ; cr@@ d = ( ( Ig@@ n@@ ite@@ Ker@@ nal ) sr@@ v1 ) . localNode ( ) ; Ig@@ n@@ ite sr@@ v2 = start@@ Grid ( " server@@ 2" ) ; block = true ; List < Ig@@ n@@ ite@@ Internal@@ F@@ u@@ ture < Ig@@ n@@ ite > > f@@ ut@@ s = new ArrayList < > ( ) ; final Count@@ Down@@ L@@ atch l@@ atch = new Count@@ Down@@ L@@ atch ( 1 ) ; final int CLI@@ ENT@@ S_@@ NUM = 5 ; final Count@@ Down@@ L@@ atch failu@@ re@@ H@@ nd@@ L@@ atch = new Count@@ Down@@ L@@ atch ( CLI@@ ENT@@ S_@@ NUM ) ; for ( int i = 0 ; i < CLI@@ ENT@@ S_@@ NUM ; i ++ ) { final int idx = i ; Ig@@ n@@ ite@@ Internal@@ F@@ u@@ ture < Ig@@ n@@ ite > f@@ ut = Grid@@ Test@@ Utils . run@@ A@@ sync ( new Cal@@ lable < Ig@@ n@@ ite > ( ) { @ Override public Ig@@ n@@ ite call ( ) throws Exception { l@@ atch . a@@ wait ( ) ; String ig@@ n@@ ite@@ Instance@@ Name = " client " + idx ; return start@@ Grid ( ig@@ n@@ ite@@ Instance@@ Name , get@@ Configuration ( ig@@ n@@ ite@@ Instance@@ Name ) . set@@ Fa@@ ilu@@ re@@ Handler ( new Test@@ Fa@@ ilu@@ re@@ Handler ( true , failu@@ re@@ H@@ nd@@ L@@ atch ) ) ) ; } } ) ; f@@ ut@@ s . add ( f@@ ut ) ; } l@@ atch . count@@ Down ( ) ; for ( final Ig@@ n@@ ite@@ Internal@@ F@@ u@@ ture < Ig@@ n@@ ite > client@@ F@@ ut : f@@ ut@@ s ) { Grid@@ Test@@ Utils . assert@@ Throws ( log , new Cal@@ lable < Object > ( ) { @ Override public Object call ( ) throws Exception { client@@ F@@ ut . get ( ) ; return null ; } } , Ig@@ n@@ ite@@ Check@@ ed@@ Exception . class , null ) ; } assertTrue ( failu@@ re@@ H@@ nd@@ L@@ atch . a@@ wait ( 1000 , Time@@ Unit . MILLI@@ SECONDS ) ) ; assertEquals ( 0 , sr@@ v1 . cluster ( ) . for@@ Cli@@ ents ( ) . nodes ( ) . size ( ) ) ; assertEquals ( 0 , sr@@ v2 . cluster ( ) . for@@ Cli@@ ents ( ) . nodes ( ) . size ( ) ) ; }
protected long getTest@@ Timeout ( ) { return 3 * 60@@ _@@ 000 ; }
public void send@@ Message ( Cluster@@ Node node , Message msg ) throws Ig@@ n@@ ite@@ Spi@@ Exception { if ( block@@ All || block && node . id ( ) . equals ( cr@@ d . id ( ) ) ) throw new Ig@@ n@@ ite@@ Spi@@ Exception ( new Socket@@ Exception ( " Test ▁ communic@@ ation ▁ exception " ) ) ; super . send@@ Message ( node , msg ) ; }
public void send@@ Message ( Cluster@@ Node node , Message msg , Ig@@ n@@ ite@@ In@@ Clo@@ sure < Ig@@ n@@ ite@@ Exception > ack@@ C ) throws Ig@@ n@@ ite@@ Spi@@ Exception { if ( block@@ All || block && node . id ( ) . equals ( cr@@ d . id ( ) ) ) throw new Ig@@ n@@ ite@@ Spi@@ Exception ( new Socket@@ Exception ( " Test ▁ communic@@ ation ▁ exception " ) ) ; super . send@@ Message ( node , msg , ack@@ C ) ; }
protected void writeTo@@ Socket ( Socket soc@@ k , T@@ cp@@ Dis@@ cover@@ y@@ Abstract@@ Message msg , byte [ ] data , long timeout ) throws IOException { if ( block@@ All || block && soc@@ k . getPort ( ) == 475@@ 00 ) throw new Socket@@ Exception ( " Test ▁ discovery ▁ exception " ) ; super . writeTo@@ Socket ( soc@@ k , msg , data , timeout ) ; }
protected void writeTo@@ Socket ( T@@ cp@@ Dis@@ cover@@ y@@ Abstract@@ Message msg , Socket soc@@ k , int res , long timeout ) throws IOException { if ( block@@ All || block && soc@@ k . getPort ( ) == 475@@ 00 ) throw new Socket@@ Exception ( " Test ▁ discovery ▁ exception " ) ; super . writeTo@@ Socket ( msg , soc@@ k , res , timeout ) ; }
for ( DateFormat format : DAT@@ E_@@ FOR@@ MAT@@ S ) { format . set@@ Len@@ i@@ ent ( false ) ; }
private int map@@ Index@@ To@@ Action ( int index ) { if ( index < button@@ Count ) { int count = - 1 ; for ( int x = 0 ; x < MAX_@@ BUTT@@ ON@@ _COUNT ; x ++ ) { if ( fields [ x ] ) { count ++ ; } if ( count == index ) { return x ; } } } return - 1 ; }
public Address@@ Book@@ Result@@ Handler ( Activity activ@@ ity , Par@@ sed@@ Result result ) { super ( activ@@ ity , result ) ; Address@@ Book@@ Par@@ sed@@ Result address@@ Result = ( Address@@ Book@@ Par@@ sed@@ Result ) result ; String [ ] addresses = address@@ Result . get@@ Addresses ( ) ; boolean has@@ Address = addresses != null && addresses . length > 0 && addresses [ 0 ] != null && ! addresses [ 0 ] . isEmpty ( ) ; String [ ] ph@@ one@@ Numbers = address@@ Result . get@@ Ph@@ one@@ Numbers ( ) ; boolean has@@ Ph@@ one@@ Number = ph@@ one@@ Numbers != null && ph@@ one@@ Numbers . length > 0 ; String [ ] email@@ s = address@@ Result . get@@ Ema@@ il@@ s ( ) ; boolean has@@ Ema@@ il@@ Address = email@@ s != null && email@@ s . length > 0 ; fields = new boolean [ MAX_@@ BUTT@@ ON@@ _COUNT ] ; fields [ 0 ] = true ; fields [ 1 ] = has@@ Address ; fields [ 2 ] = has@@ Ph@@ one@@ Number ; fields [ 3 ] = has@@ Ema@@ il@@ Address ; button@@ Count = 0 ; for ( int x = 0 ; x < MAX_@@ BUTT@@ ON@@ _COUNT ; x ++ ) { if ( fields [ x ] ) { button@@ Count ++ ; } } }
public int get@@ Button@@ Count ( ) { return button@@ Count ; }
public int get@@ Button@@ Text ( int index ) { return BUTT@@ ON_@@ TEXTS [ map@@ Index@@ To@@ Action ( index ) ] ; }
public void handle@@ ButtonPress ( int index ) { Address@@ Book@@ Par@@ sed@@ Result address@@ Result = ( Address@@ Book@@ Par@@ sed@@ Result ) get@@ Result ( ) ; String [ ] addresses = address@@ Result . get@@ Addresses ( ) ; String address1 = addresses == null || addresses . length < 1 ? null : addresses [ 0 ] ; String [ ] address@@ Types = address@@ Result . get@@ Address@@ Types ( ) ; String address@@ 1@@ Type = address@@ Types == null || address@@ Types . length < 1 ? null : address@@ Types [ 0 ] ; int action = map@@ Index@@ To@@ Action ( index ) ; switch ( action ) { case 0 : addContact ( address@@ Result . get@@ Names ( ) , address@@ Result . get@@ Nick@@ names ( ) , address@@ Result . getP@@ ron@@ un@@ ci@@ ation ( ) , address@@ Result . get@@ Ph@@ one@@ Numbers ( ) , address@@ Result . get@@ Ph@@ one@@ Types ( ) , address@@ Result . get@@ Ema@@ il@@ s ( ) , address@@ Result . get@@ Ema@@ il@@ Types ( ) , address@@ Result . get@@ Note ( ) , address@@ Result . getIn@@ stan@@ t@@ Mess@@ enger ( ) , address1 , address@@ 1@@ Type , address@@ Result . get@@ Or@@ g ( ) , address@@ Result . get@@ Title ( ) , address@@ Result . get@@ URL@@ s ( ) , address@@ Result . getB@@ ir@@ th@@ day ( ) , address@@ Result . get@@ Ge@@ o ( ) ) ; break ; case 1 : search@@ Map ( address1 ) ; break ; case 2 : dial@@ Ph@@ one ( address@@ Result . get@@ Ph@@ one@@ Numbers ( ) [ 0 ] ) ; break ; case 3 : send@@ Email ( address@@ Result . get@@ Ema@@ il@@ s ( ) , null , null , null , null ) ; break ; default : break ; } }
public CharSequence getDisplay@@ Contents ( ) { Address@@ Book@@ Par@@ sed@@ Result result = ( Address@@ Book@@ Par@@ sed@@ Result ) get@@ Result ( ) ; StringBuilder contents = new StringBuilder ( 100 ) ; Par@@ sed@@ Result . may@@ be@@ Append ( result . get@@ Names ( ) , contents ) ; int nam@@ es@@ Length = contents . length ( ) ; String pr@@ on@@ un@@ ci@@ ation = result . getP@@ ron@@ un@@ ci@@ ation ( ) ; if ( pr@@ on@@ un@@ ci@@ ation != null && ! pr@@ on@@ un@@ ci@@ ation . isEmpty ( ) ) { contents . append ( " \n ( " ) ; contents . append ( pr@@ on@@ un@@ ci@@ ation ) ; contents . append ( ' ) ' ) ; } Par@@ sed@@ Result . may@@ be@@ Append ( result . get@@ Title ( ) , contents ) ; Par@@ sed@@ Result . may@@ be@@ Append ( result . get@@ Or@@ g ( ) , contents ) ; Par@@ sed@@ Result . may@@ be@@ Append ( result . get@@ Addresses ( ) , contents ) ; String [ ] numbers = result . get@@ Ph@@ one@@ Numbers ( ) ; if ( numbers != null ) { for ( String number : numbers ) { if ( number != null ) { Par@@ sed@@ Result . may@@ be@@ Append ( Ph@@ one@@ Number@@ Utils . format@@ Number ( number ) , contents ) ; } } } Par@@ sed@@ Result . may@@ be@@ Append ( result . get@@ Ema@@ il@@ s ( ) , contents ) ; Par@@ sed@@ Result . may@@ be@@ Append ( result . get@@ URL@@ s ( ) , contents ) ; String b@@ ir@@ th@@ day = result . getB@@ ir@@ th@@ day ( ) ; if ( b@@ ir@@ th@@ day != null && ! b@@ ir@@ th@@ day . isEmpty ( ) ) { Date date = parse@@ Date ( b@@ ir@@ th@@ day ) ; if ( date != null ) { Par@@ sed@@ Result . may@@ be@@ Append ( DateFormat . getDate@@ Instance ( DateFormat . MEDI@@ UM ) . format ( date . getTime ( ) ) , contents ) ; } } Par@@ sed@@ Result . may@@ be@@ Append ( result . get@@ Note ( ) , contents ) ; if ( nam@@ es@@ Length > 0 ) { Sp@@ ann@@ able style@@ d = new Sp@@ ann@@ able@@ String ( contents . toString ( ) ) ; style@@ d . set@@ Spa@@ n ( new Style@@ Spa@@ n ( android . graphics . Type@@ face . BOL@@ D ) , 0 , nam@@ es@@ Length , 0 ) ; return style@@ d ; } else { return contents . toString ( ) ; } }
public int getDisplay@@ Title ( ) { return R . string . result_@@ add@@ res@@ s_@@ book ; }
public Converter ( J@@ BD@@ C@@ Database from , J@@ BD@@ C@@ Database to ) { this . from = from ; this . to = to ; insert@@ BB = to . prepare ( " IN@@ SER@@ T ▁ INT@@ O ▁ ` sc@@ 2 _ b@@ b ` ▁ ( ` c@@ la@@ n ` , ▁ ` text ` ▁ ) ▁ VAL@@ UES ▁ ( ▁ ? , ▁ ? ▁ ) ; " ) ; update@@ C@@ la@@ n = to . prepare ( " UPDATE ▁ ` sc@@ 2 _ cl@@ ans ` ▁ SET ▁ al@@ li@@ es ▁ = ▁ ? , ▁ riv@@ als ▁ = ▁ ? , ▁ war@@ ring ▁ = ▁ ? ▁ WHER@@ E ▁ id ▁ = ▁ ? ; " ) ; insert@@ Kill = to . prepare ( " IN@@ SER@@ T ▁ INT@@ O ▁ ` sc@@ 2 _ kil@@ ls ` ▁ ( ▁ ` attacker ` , ▁ ` attacker _ c@@ la@@ n ` , ▁ ` victim ` , ▁ ` victim _ c@@ la@@ n ` , ▁ ` w@@ ar ` , ▁ ` type ` , ▁ ` date ` ▁ ) ▁ VAL@@ UES ▁ ( ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? ▁ ) ; " ) ; prepare@@ C@@ la@@ n ( ) ; prepare@@ C@@ lan@@ Player ( ) ; }
private void prepare@@ C@@ la@@ n ( ) { if ( insert@@ C@@ la@@ n != null ) { try { insert@@ C@@ la@@ n . close ( ) ; } catch ( SQ@@ L@@ Exception e ) { Logging . debug ( e , false ) ; } } insert@@ C@@ la@@ n = to . prepare ( " IN@@ SER@@ T ▁ INT@@ O ▁ ` sc@@ 2 _ cl@@ ans ` ▁ ( ` name ` , ▁ ` tag ` , ▁ ` ver@@ ified ` , ▁ ` fo@@ unded ` , ▁ ` last _ action ` , ▁ ` flags ` , ▁ ` bal@@ ance ` ▁ ) ▁ VAL@@ UES ▁ ( ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? ▁ ) ; " ) ; }
private void prepare@@ C@@ lan@@ Player ( ) { if ( insert@@ C@@ lan@@ Player != null ) { try { insert@@ C@@ lan@@ Player . close ( ) ; } catch ( SQ@@ L@@ Exception e ) { Logging . debug ( e , false ) ; } } insert@@ C@@ lan@@ Player = to . prepare ( " IN@@ SER@@ T ▁ INT@@ O ▁ ` sc@@ 2 _ play@@ ers ` ▁ ( ▁ ` name ` , ▁ ` leader ` , ▁ ` tr@@ ust@@ ed ` , ▁ ` join _ date ` , ▁ ` last _ se@@ en ` , ▁ ` c@@ la@@ n ` , ▁ ` neutral _ kil@@ ls ` , ▁ ` riv@@ al _ Kil@@ ls ` , ▁ ` ci@@ vi@@ li@@ an _ Kil@@ ls ` , ▁ ` de@@ ath@@ s ` , ▁ ` flags ` ▁ ) ▁ VAL@@ UES ▁ ( ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? ▁ ) " ) ; }
public void convert@@ All ( ) { try { convert@@ C@@ l@@ ans ( ) ; convert@@ Play@@ ers ( ) ; convert@@ Kil@@ ls ( ) ; } catch ( SQ@@ L@@ Exception e ) { e . printStackTrace ( ) ; } cl@@ ans = null ; play@@ ers = null ; }
public void run ( ) { convert@@ All ( ) ; }
public void convert@@ Play@@ ers ( ) throws SQ@@ L@@ Exception { ResultSet result = from . query ( " SEL@@ ECT ▁ * ▁ FRO@@ M ▁ ` sc _ play@@ ers ` ; " ) ; while ( result . next ( ) ) { JS@@ ON@@ Object flags = new JS@@ ON@@ Object ( ) ; try { JS@@ ON@@ Parser parser = new JS@@ ON@@ Parser ( ) ; String flag@@ s@@ String = result . get@@ String ( " flags " ) ; JS@@ ON@@ Object object = ( JS@@ ON@@ Object ) parser . parse ( flag@@ s@@ String ) ; boolean fri@@ end@@ ly@@ Fir@@ e = result . get@@ Boolean ( " fri@@ end@@ ly _ fire " ) ; boolean b@@ b = ( Boolean ) object . get ( " b@@ b - enabled " ) ; boolean cap@@ e = ( Boolean ) object . get ( " cap@@ e - enabled " ) ; if ( fri@@ end@@ ly@@ Fir@@ e ) { flags . put ( " ff " , fri@@ end@@ ly@@ Fir@@ e ) ; } if ( b@@ b ) { flags . put ( " b@@ b " , b@@ b ) ; } if ( cap@@ e ) { flags . put ( " cap@@ e " , cap@@ e ) ; } } catch ( Parse@@ Exception e ) { e . printStackTrace ( ) ; continue ; } String name = result . get@@ String ( " name " ) ; insert@@ Player ( name , result . get@@ Boolean ( " leader " ) , result . get@@ Boolean ( " tr@@ ust@@ ed " ) , result . get@@ Long ( " join _ date " ) , result . get@@ Long ( " last _ se@@ en " ) , get@@ ID@@ By@@ Tag ( result . get@@ String ( " tag " ) ) , result . get@@ Int ( " neutral _ kil@@ ls " ) , result . get@@ Int ( " riv@@ al _ kil@@ ls " ) , result . get@@ Int ( " ci@@ vi@@ li@@ an _ kil@@ ls " ) , result . get@@ Int ( " de@@ ath@@ s " ) , flags . to@@ JS@@ ON@@ String ( ) ) ; ResultSet id@@ Result = to . query ( " SEL@@ ECT ▁ id ▁ FRO@@ M ▁ ` sc@@ 2 _ play@@ ers ` ▁ WHER@@ E ▁ name ▁ = ▁ ' " + name + " ' ; " ) ; id@@ Result . next ( ) ; play@@ ers . add ( new Conver@@ ted@@ C@@ lan@@ Player ( id@@ Result . get@@ Long ( " id " ) , name ) ) ; } }
public void insert@@ Player ( String name , boolean leader , boolean tr@@ ust@@ ed , long join@@ Date , long last@@ Seen , long c@@ la@@ n , int ne@@ utr@@ al@@ Kil@@ ls , int riv@@ al@@ Kil@@ ls , int ci@@ vi@@ li@@ an@@ Kil@@ ls , int de@@ ath@@ s , String flags ) throws SQ@@ L@@ Exception { insert@@ C@@ lan@@ Player . setString ( 1 , name ) ; insert@@ C@@ lan@@ Player . set@@ Boolean ( 2 , leader ) ; insert@@ C@@ lan@@ Player . set@@ Boolean ( 3 , tr@@ ust@@ ed ) ; insert@@ C@@ lan@@ Player . set@@ Timestamp ( 4 , new Timestamp ( join@@ Date ) ) ; insert@@ C@@ lan@@ Player . set@@ Timestamp ( 5 , new Timestamp ( last@@ Seen ) ) ; insert@@ C@@ lan@@ Player . set@@ Long ( 6 , c@@ la@@ n ) ; insert@@ C@@ lan@@ Player . set@@ Int ( 7 , ne@@ utr@@ al@@ Kil@@ ls ) ; insert@@ C@@ lan@@ Player . set@@ Int ( 8 , riv@@ al@@ Kil@@ ls ) ; insert@@ C@@ lan@@ Player . set@@ Int ( 9 , ci@@ vi@@ li@@ an@@ Kil@@ ls ) ; insert@@ C@@ lan@@ Player . set@@ Int ( 10 , de@@ ath@@ s ) ; if ( flags != null ) { insert@@ C@@ lan@@ Player . setString ( 11 , flags ) ; } else { insert@@ C@@ lan@@ Player . setNull ( 11 , Types . VAR@@ CHAR ) ; } try { insert@@ C@@ lan@@ Player . execute@@ Update ( ) ; } catch ( SQ@@ L@@ Exception e ) { if ( e . getMessage ( ) . startsWith ( " Dup@@ licate ▁ entry " ) || e . getMessage ( ) . contains ( " Abort ▁ due ▁ to ▁ constraint ▁ vi@@ ol@@ ation " ) ) { Logging . debug ( " Found ▁ duplicate ▁ c@@ lan@@ Player ▁ % s ! ▁ Sk@@ i@@ pping ! " , name ) ; } else { Logging . debug ( e , " Error " , false ) ; } prepare@@ C@@ lan@@ Player ( ) ; } }
public long getC@@ lan@@ Player@@ ID@@ by@@ Name ( String tag ) { for ( Conver@@ ted@@ C@@ lan@@ Player c@@ p : play@@ ers ) { if ( c@@ p . getName ( ) . equals ( tag ) ) { return c@@ p . getId ( ) ; } } return - 1 ; }
public void convert@@ C@@ l@@ ans ( ) throws SQ@@ L@@ Exception { ResultSet result = from . query ( " SEL@@ ECT ▁ * ▁ FRO@@ M ▁ ` sc _ cl@@ ans ` ; " ) ; while ( result . next ( ) ) { JS@@ ON@@ Object flags = new JS@@ ON@@ Object ( ) ; String name = result . get@@ String ( " name " ) ; String tag = result . get@@ String ( " tag " ) ; boolean ver@@ ified = result . get@@ Boolean ( " ver@@ ified " ) ; boolean fri@@ end@@ ly_@@ fire = result . get@@ Boolean ( " fri@@ end@@ ly _ fire " ) ; long fo@@ unded = result . get@@ Long ( " fo@@ unded " ) ; long last_@@ used = result . get@@ Long ( " last _ used " ) ; String flag@@ s@@ String = result . get@@ String ( " flags " ) ; String cap@@ e = result . get@@ String ( " cap@@ e _ url " ) ; Conver@@ ted@@ C@@ la@@ n c@@ la@@ n = new Conver@@ ted@@ C@@ la@@ n ( tag ) ; c@@ la@@ n . set@@ Pack@@ ed@@ Al@@ li@@ es ( result . get@@ String ( " pack@@ ed _ al@@ li@@ es " ) ) ; c@@ la@@ n . ser@@ Pack@@ ed@@ R@@ i@@ vals ( result . get@@ String ( " pack@@ ed _ riv@@ als " ) ) ; if ( fri@@ end@@ ly_@@ fire ) { flags . put ( " ff " , fri@@ end@@ ly_@@ fire ) ; } if ( cap@@ e != null && ! cap@@ e . isEmpty ( ) ) { flags . put ( " cap@@ e - url " , cap@@ e ) ; } JS@@ ON@@ Parser parser = new JS@@ ON@@ Parser ( ) ; try { JS@@ ON@@ Object object = ( JS@@ ON@@ Object ) parser . parse ( flag@@ s@@ String ) ; String world = object . get ( " home@@ World " ) . toString ( ) ; if ( ! world . isEmpty ( ) ) { int x = ( ( Long ) object . get ( " home@@ X " ) ) . intValue ( ) ; int y = ( ( Long ) object . get ( " home@@ Y " ) ) . intValue ( ) ; int z = ( ( Long ) object . get ( " home@@ Z " ) ) . intValue ( ) ; flags . put ( " home " , x + " : " + y + " : " + z + " : " + world + " : 0@@ :@@ 0" ) ; } c@@ la@@ n . setRaw@@ War@@ ring ( ( JS@@ ON@@ Array ) object . get ( " war@@ ring " ) ) ; } catch ( Parse@@ Exception e ) { Logging . debug ( e , true ) ; continue ; } insert@@ C@@ la@@ n ( name , tag , ver@@ ified , fo@@ unded , last_@@ used , flags . isEmpty ( ) ? null : flags . to@@ JS@@ ON@@ String ( ) , result . getDouble ( " bal@@ ance " ) ) ; String select@@ Last@@ Query = " SEL@@ ECT ▁ ` id ` ▁ FRO@@ M ▁ ` sc@@ 2 _ cl@@ ans ` ▁ ORDER ▁ B@@ Y ▁ ID ▁ DESC ▁ LIMIT ▁ 1 ; " ; ResultSet select@@ Last = to . query ( select@@ Last@@ Query ) ; select@@ Last . next ( ) ; c@@ la@@ n . setId ( select@@ Last . get@@ Long ( " id " ) ) ; select@@ Last . close ( ) ; insert@@ BB ( Arrays . asList ( result . get@@ String ( " pack@@ ed _ b@@ b " ) . split ( " \\@@ s * ( \\ | | $ ) " ) ) , c@@ la@@ n . getId ( ) ) ; cl@@ ans . add ( c@@ la@@ n ) ; } for ( Conver@@ ted@@ C@@ la@@ n c@@ la@@ n : cl@@ ans ) { JS@@ ON@@ Array al@@ li@@ es = new JS@@ ON@@ Array ( ) ; JS@@ ON@@ Array riv@@ als = new JS@@ ON@@ Array ( ) ; JS@@ ON@@ Array war@@ ring = new JS@@ ON@@ Array ( ) ; for ( String ally@@ Tag : c@@ la@@ n . getRaw@@ Al@@ li@@ es ( ) ) { long ally@@ ID = get@@ ID@@ By@@ Tag ( ally@@ Tag ) ; if ( ally@@ ID != - 1 ) { al@@ li@@ es . add ( ally@@ ID ) ; } } for ( String riv@@ al@@ Tag : c@@ la@@ n . getRaw@@ Al@@ li@@ es ( ) ) { long riv@@ al@@ ID = get@@ ID@@ By@@ Tag ( riv@@ al@@ Tag ) ; if ( riv@@ al@@ ID != - 1 ) { riv@@ als . add ( riv@@ al@@ ID ) ; } } for ( String war@@ ring@@ Tag : c@@ la@@ n . getRaw@@ War@@ ring ( ) ) { long war@@ ring@@ ID = get@@ ID@@ By@@ Tag ( war@@ ring@@ Tag ) ; if ( war@@ ring@@ ID != - 1 ) { war@@ ring . add ( war@@ ring@@ ID ) ; } } if ( ! al@@ li@@ es . isEmpty ( ) ) { update@@ C@@ la@@ n . setString ( 1 , al@@ li@@ es . to@@ JS@@ ON@@ String ( ) ) ; } else { update@@ C@@ la@@ n . setNull ( 1 , Types . VAR@@ CHAR ) ; } if ( ! riv@@ als . isEmpty ( ) ) { update@@ C@@ la@@ n . setString ( 2 , riv@@ als . to@@ JS@@ ON@@ String ( ) ) ; } else { update@@ C@@ la@@ n . setNull ( 2 , Types . VAR@@ CHAR ) ; } if ( ! war@@ ring . isEmpty ( ) ) { update@@ C@@ la@@ n . setString ( 3 , war@@ ring . to@@ JS@@ ON@@ String ( ) ) ; } else { update@@ C@@ la@@ n . setNull ( 3 , Types . VAR@@ CHAR ) ; } update@@ C@@ la@@ n . set@@ Long ( 4 , c@@ la@@ n . getId ( ) ) ; update@@ C@@ la@@ n . execute@@ Update ( ) ; } }
public long get@@ ID@@ By@@ Tag ( String tag ) { for ( Conver@@ ted@@ C@@ la@@ n c@@ la@@ n : cl@@ ans ) { if ( c@@ la@@ n . get@@ Tag ( ) . equals ( tag ) ) { return c@@ la@@ n . getId ( ) ; } } return - 1 ; }
public void insert@@ BB ( List < String > b@@ b , long c@@ la@@ n ) throws SQ@@ L@@ Exception { for ( String text : b@@ b ) { insert@@ BB . set@@ Long ( 1 , c@@ la@@ n ) ; insert@@ BB . setString ( 2 , text ) ; insert@@ BB . execute@@ Update ( ) ; } }
public void insert@@ C@@ la@@ n ( String name , String tag , boolean ver@@ ified , long fo@@ unded , long last_@@ action , String flags , double bal@@ ance ) throws SQ@@ L@@ Exception { insert@@ C@@ la@@ n . setString ( 1 , name ) ; insert@@ C@@ la@@ n . setString ( 2 , tag ) ; insert@@ C@@ la@@ n . set@@ Boolean ( 3 , ver@@ ified ) ; insert@@ C@@ la@@ n . set@@ Timestamp ( 4 , new Timestamp ( fo@@ unded ) ) ; insert@@ C@@ la@@ n . set@@ Timestamp ( 5 , new Timestamp ( last_@@ action ) ) ; if ( flags != null ) { insert@@ C@@ la@@ n . setString ( 6 , flags ) ; } else { insert@@ C@@ la@@ n . setNull ( 6 , Types . VAR@@ CHAR ) ; } insert@@ C@@ la@@ n . set@@ Double ( 7 , bal@@ ance ) ; try { insert@@ C@@ la@@ n . execute@@ Update ( ) ; } catch ( SQ@@ L@@ Exception e ) { if ( e . getMessage ( ) . startsWith ( " Dup@@ licate ▁ entry " ) || e . getMessage ( ) . contains ( " Abort ▁ due ▁ to ▁ constraint ▁ vi@@ ol@@ ation " ) ) { Logging . debug ( " Found ▁ duplicate ▁ c@@ la@@ n ▁ % s ! ▁ Sk@@ i@@ pping ! " , name ) ; } else { Logging . debug ( e , " Error " , false ) ; } prepare@@ C@@ la@@ n ( ) ; } }
public void convert@@ Kil@@ ls ( ) throws SQ@@ L@@ Exception { ResultSet result = from . query ( " SEL@@ ECT ▁ * ▁ FRO@@ M ▁ ` sc _ kil@@ ls ` ; " ) ; while ( result . next ( ) ) { Timestamp date ; try { date = result . get@@ Timestamp ( " date " ) ; } catch ( Exception e ) { date = new Timestamp ( System . currentTimeMillis ( ) ) ; } insert@@ Kill ( result . get@@ String ( " attacker " ) , result . get@@ String ( " attacker _ tag " ) , result . get@@ String ( " victim " ) , result . get@@ String ( " victim _ tag " ) , result . get@@ String ( " k@@ ill _ type " ) , result . get@@ Boolean ( " w@@ ar " ) , date ) ; } }
public void insert@@ Kill ( String attacker , String attack@@ er@@ _c@@ la@@ n , String victim , String vic@@ ti@@ m_c@@ la@@ n , String type , boolean w@@ ar , Timestamp date ) throws SQ@@ L@@ Exception { long attack@@ er@@ ID = getC@@ lan@@ Player@@ ID@@ by@@ Name ( attacker ) ; if ( attack@@ er@@ ID == - 1 ) { return ; } long vic@@ tim@@ ID = getC@@ lan@@ Player@@ ID@@ by@@ Name ( victim ) ; if ( vic@@ tim@@ ID == - 1 ) { return ; } insert@@ Kill . set@@ Long ( 1 , attack@@ er@@ ID ) ; insert@@ Kill . set@@ Long ( 2 , get@@ ID@@ By@@ Tag ( attack@@ er@@ _c@@ la@@ n ) ) ; insert@@ Kill . set@@ Long ( 3 , vic@@ tim@@ ID ) ; insert@@ Kill . set@@ Long ( 4 , get@@ ID@@ By@@ Tag ( vic@@ ti@@ m_c@@ la@@ n ) ) ; Kill@@ Type real@@ Type ; switch ( type . charAt ( 0 ) ) { case ' c ' : real@@ Type = Kill@@ Type . CI@@ VI@@ LI@@ AN ; break ; case ' n ' : real@@ Type = Kill@@ Type . NEUTRAL ; break ; case ' r ' : real@@ Type = Kill@@ Type . RI@@ VAL ; break ; default : throw new Unsup@@ ported@@ Operation@@ Exception ( " Failed ▁ at ▁ inserting ▁ k@@ ill ! ▁ Type ▁ not ▁ found : ▁ " + type ) ; } insert@@ Kill . set@@ Byte ( 5 , real@@ Type . getType ( ) ) ; insert@@ Kill . set@@ Boolean ( 6 , w@@ ar ) ; insert@@ Kill . set@@ Timestamp ( 7 , date ) ; insert@@ Kill . execute@@ Update ( ) ; }
