AP4_Result AP4 :: Initialize ( ) { AP4_Result result = AP4_SUCCESS ; if ( ! AP4_DefaultAtomFactory :: Instance . m_Initialized ) { result = AP4_DefaultAtomFactory :: Instance . Initialize ( ) ; if ( AP4_FAILED ( result ) ) return result ; } if ( ! AP4_DefaultBlockCipherFactory :: Instance . m_Initialized ) { result = AP4_DefaultBlockCipherFactory :: Instance . Initialize ( ) ; if ( AP4_FAILED ( result ) ) return result ; } if ( ! AP4_MetaData :: Initialized ( ) ) { AP4_MetaData :: Initialize ( ) ; } return result ; }
AP4_Result AP4 :: Terminate ( ) { if ( ! AP4_LoaderCheck . m_ConstructedByLoader ) { if ( AP4_DefaultAtomFactory :: Instance . m_Initialized ) { AP4_DefaultAtomFactory :: Instance . ~ AP4_DefaultAtomFactory ( ) ; } if ( AP4_DefaultBlockCipherFactory :: Instance . m_Initialized ) { AP4_DefaultBlockCipherFactory :: Instance . ~ AP4_DefaultBlockCipherFactory ( ) ; } if ( AP4_MetaData :: Initialized ( ) ) { AP4_MetaData :: UnInitialize ( ) ; } } return AP4_SUCCESS ; }
void CIconNavReceive :: save ( SimpleFile * file , int indent ) { file -> writeNumber@@ Line ( 1 , indent ) ; CPetGraphic :: save ( file , indent ) ; }
void CIconNavReceive :: load ( SimpleFile * file ) { file -> readNumber ( ) ; CPetGraphic :: load ( file ) ; }
void ctkPluginGeneratorUiPlugin :: start ( ctkPluginContext * context ) { mainExtension = new ctkPluginGeneratorMainExtension ( ) ; ctkDictionary props ; props . insert ( ctkPluginConstants :: SERVICE_RANKING , 0 ) ; context -> registerService ( QStringList ( " ctkPluginGeneratorAbstractUi@@ Extension " ) , mainExtension , props ) ; qDebug ( ) << " Registered ▁ Main ▁ Extension " ; }
void ctkPluginGeneratorUiPlugin :: stop ( ctkPluginContext * context ) { Q_UNUSED ( context ) delete mainExtension ; }
void QgsProxyProgressTask :: finalize ( bool result ) { mResult = result ; mNotFinishedWaitCondition . wakeAll ( ) ; }
bool QgsProxyProgressTask :: run ( ) { mNotFinishedMutex . lock ( ) ; mNotFinishedWaitCondition . wait ( & mNotFinishedMutex ) ; mNotFinishedMutex . unlock ( ) ; return mResult ; }
void QgsProxyProgressTask :: setProxyProgress ( double progress ) { QMetaObject :: invokeMethod ( this , " setProgress " , Qt :: AutoConnection , Q_ARG ( double , progress ) ) ; }
QgsScopedProxyProgressTask :: QgsScopedProxyProgressTask ( const QString & description ) : mTask ( new QgsProxyProgressTask ( description ) ) { QgsApplication :: taskManager ( ) -> addTask ( mTask ) ; }
QgsScopedProxyProgressTask :: ~ QgsScopedProxyProgressTask ( ) { mTask -> finalize ( true ) ; }
void QgsScopedProxyProgressTask :: setProgress ( double progress ) { mTask -> setProxyProgress ( progress ) ; }
eInputContentString :: eInputContentString ( ) { m_string = " bla " ; m_cursor = 0 ; m_input = 0 ; m_len = m_string . size ( ) ; }
void eInputContentString :: getDisplay ( std :: string & res , int & cursor ) { res = m_string ; cursor = m_cursor ; }
void eInputContentString :: moveCursor ( int dir ) { int old_cursor = m_cursor ; switch ( dir ) { case dirLeft : -- m_cursor ; break ; case dirRight : ++ m_cursor ; break ; case dirHome : m_cursor = 0 ; break ; case dirEnd : m_cursor = m_len ; break ; } if ( m_cursor < 0 ) m_cursor = 0 ; if ( m_cursor > m_len ) m_cursor = m_len ; if ( m_cursor != old_cursor ) if ( m_input ) m_input -> invalidate ( ) ; }
int eInputContentString :: haveKey ( int code , int overwrite ) { int have_char = - 1 ; if ( code >= 0x8020 ) have_char = code & ~ 0x8000 ; if ( have_char != - 1 ) { if ( overwrite && m_cursor < m_len ) m_string [ m_cursor ] = have_char ; else { m_string . insert ( m_cursor , 1 , have_char ) ; ++ m_len ; } m_cursor ++ ; ASSERT ( m_cursor <= m_len ) ; if ( m_input ) m_input -> invalidate ( ) ; return 1 ; } return 0 ; }
void eInputContentString :: deleteChar ( int dir ) { if ( dir == deleteForward ) { eDebug ( " forward " ) ; if ( m_cursor != m_len ) ++ m_cursor ; else return ; } if ( ! m_cursor ) return ; if ( ! m_len ) return ; m_string . erase ( m_cursor - 1 , m_cursor ) ; m_len -- ; m_cursor -- ; if ( m_input ) m_input -> invalidate ( ) ; }
int eInputContentString :: isValid ( ) { return 1 ; }
void eInputContentString :: setText ( const std :: string & str ) { m_string = str ; m_len = m_string . size ( ) ; if ( m_cursor > m_len ) m_cursor = m_len ; if ( m_input ) m_input -> invalidate ( ) ; }
std :: string eInputContentString :: getText ( ) { return m_string ; }
void TreeParser :: reportError ( const Recogni@@ tionException & ex ) { ANTLR_USE_NAMESPACE ( std ) cerr << ex . toString ( ) . c_str ( ) << ANTLR_USE_NAMESPACE ( std ) endl ; }
void TreeParser :: reportError ( const ANTLR_USE_NAMESPACE ( std ) string & s ) { ANTLR_USE_NAMESPACE ( std ) cerr << " error : ▁ " << s . c_str ( ) << ANTLR_USE_NAMESPACE ( std ) endl ; }
void TreeParser :: reportWarning ( const ANTLR_USE_NAMESPACE ( std ) string & s ) { ANTLR_USE_NAMESPACE ( std ) cerr << " warning : ▁ " << s . c_str ( ) << ANTLR_USE_NAMESPACE ( std ) endl ; }
void TreeParser :: traceIndent ( ) { for ( int i = 0 ; i < traceDepth ; i ++ ) ANTLR_USE_NAMESPACE ( std ) cout << " ▁ " ; }
void TreeParser :: traceIn ( const char * rname , RefAST t ) { traceDepth ++ ; traceIndent ( ) ; ANTLR_USE_NAMESPACE ( std ) cout << " > ▁ " << rname << " ( " << ( t ? t -> toString ( ) . c_str ( ) : " null " ) << " ) " << ( ( inputState -> guessing > 0 ) ? " ▁ [ guessing ] " : " " ) << ANTLR_USE_NAMESPACE ( std ) endl ; }
void TreeParser :: traceOut ( const char * rname , RefAST t ) { traceIndent ( ) ; ANTLR_USE_NAMESPACE ( std ) cout << " < ▁ " << rname << " ( " << ( t ? t -> toString ( ) . c_str ( ) : " null " ) << " ) " << ( ( inputState -> guessing > 0 ) ? " ▁ [ guessing ] " : " " ) << ANTLR_USE_NAMESPACE ( std ) endl ; traceDepth -- ; }
std :: set < int > const build_set ( ) { typedef std :: set < int > int_set ; typedef std :: vector < int > int_vector ; int_set result ; int_vector const data = build_vector ( ) ; int_vector :: const_iterator it = data . begin ( ) ; int_vector :: const_iterator const end = data . end ( ) ; result . insert ( it , end ) ; return result ; }
std :: multiset < int > const build_multiset ( ) { typedef std :: set < int > int_set ; typedef std :: multiset < int > int_multiset ; int_set const data = build_set ( ) ; return int_multiset ( data . begin ( ) , data . end ( ) ) ; }
std :: vector < int > const init_vector ( ) { typedef std :: vector < int > int_vector ; int const data [ ] = { - 4 , - 3 , - 2 , - 1 , 0 } ; int_vector :: size_type const data_size = sizeof ( data ) / sizeof ( data [ 0 ] ) ; return int_vector ( data , data + data_size ) ; }
std :: vector < int > const build_vector ( ) { typedef std :: vector < int > int_vector ; static int_vector data = init_vector ( ) ; int_vector :: size_type const size = data . size ( ) ; int_vector :: iterator it = data . begin ( ) ; int_vector :: iterator const end = data . end ( ) ; for ( ; it != end ; ++ it ) * it += size ; return data ; }
void ParameterFileDataTest :: testAccess ( ) { ParameterFileData d ; d . ImplementationAttributes ( ) . description = L " d " ; d . ImplementationAttributes ( ) . executableFileName = L " e " ; d . ImplementationAttributes ( ) . name = L " n " ; d . ImplementationAttributes ( ) . version = L " v " ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . description == L " d " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . executableFileName == L " e " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . name == L " n " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . version == L " v " ) ; d . ParameterFileAttributes ( ) . company = L " c " ; d . ParameterFileAttributes ( ) . userName = L " u " ; d . ParameterFileAttributes ( ) . contentVersion = L " cv " ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . company == L " c " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . userName == L " u " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . contentVersion == L " cv " ) ; ParameterType p ; p . name = L " n " ; p . index = L " i " ; p . displayName = L " d " ; p . category = L " c " ; p . isEditable = L " is " ; p . type = L " t " ; p . currentValue = L " cv " ; p . minValue = L " mv " ; p . maxValue = L " xv " ; p . defaultValue = L " dv " ; p . precision = L " p " ; p . maxLength = L " l " ; p . description = L " de " ; CPPUNIT_ASSERT ( p . name == L " n " ) ; CPPUNIT_ASSERT ( p . index == L " i " ) ; CPPUNIT_ASSERT ( p . displayName == L " d " ) ; CPPUNIT_ASSERT ( p . category == L " c " ) ; CPPUNIT_ASSERT ( p . isEditable == L " is " ) ; CPPUNIT_ASSERT ( p . type == L " t " ) ; CPPUNIT_ASSERT ( p . currentValue == L " cv " ) ; CPPUNIT_ASSERT ( p . minValue == L " mv " ) ; CPPUNIT_ASSERT ( p . maxValue == L " xv " ) ; CPPUNIT_ASSERT ( p . defaultValue == L " dv " ) ; CPPUNIT_ASSERT ( p . precision == L " p " ) ; CPPUNIT_ASSERT ( p . maxLength == L " l " ) ; CPPUNIT_ASSERT ( p . description == L " de " ) ; d . Parameters ( ) . push_back ( p ) ; p . name . clear ( ) ; p . index . clear ( ) ; CPPUNIT_ASSERT ( d . Parameters ( ) . size ( ) == 1 ) ; d . Clear ( ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . description == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . executableFileName == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . name == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . version == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . company == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . userName == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . contentVersion == L " " ) ; CPPUNIT_ASSERT ( d . Parameters ( ) . size ( ) == 0 ) ; }
QQuickAnimatorController :: ~ QQuickAnimatorController ( ) { foreach ( QAbstractAnimationJob * job , m_deleting ) { m_starting . take ( job ) ; m_stopping . take ( job ) ; m_animatorRoots . take ( job ) ; delete job ; } foreach ( QQuickAnimatorProxyJob * proxy , m_animatorRoots ) proxy -> controllerWasDeleted ( ) ; qDeleteAll ( m_animatorRoots . keys ( ) ) ; foreach ( QAbstractAnimationJob * job , m_starting . keys ( ) ) { if ( ! m_animatorRoots . contains ( job ) ) delete job ; } }
void QQuickAnimatorController :: itemDestroyed ( QObject * o ) { m_deletedSinceLastFrame << ( QQuickItem * ) o ; }
void QQuickAnimatorController :: advance ( ) { bool running = false ; for ( QHash < QAbstractAnimationJob * , QQuickAnimatorProxyJob * > :: const_iterator it = m_animatorRoots . constBegin ( ) ; ! running && it != m_animatorRoots . constEnd ( ) ; ++ it ) { if ( it . key ( ) -> isRunning ( ) ) running = true ; } lock ( ) ; for ( QHash < QQuickItem * , QQuickTransformAnimatorJob :: Helper * > :: const_iterator it = m_transforms . constBegin ( ) ; it != m_transforms . constEnd ( ) ; ++ it ) { QQuickTransformAnimatorJob :: Helper * xform = * it ; if ( ! xform -> item ) continue ; ( * it ) -> apply ( ) ; } unlock ( ) ; if ( running ) m_window -> update ( ) ; }
void QQuickAnimatorController :: beforeNodeSync ( ) { foreach ( QAbstractAnimationJob * job , m_deleting ) { m_starting . take ( job ) ; m_stopping . take ( job ) ; m_animatorRoots . take ( job ) ; job -> stop ( ) ; delete job ; } m_deleting . clear ( ) ; if ( m_starting . size ( ) ) m_window -> update ( ) ; foreach ( QQuickAnimatorProxyJob * proxy , m_starting ) { QAbstractAnimationJob * job = proxy -> job ( ) ; job -> addAnimationChangeListener ( this , QAbstractAnimationJob :: Completion ) ; qquick_initialize_helper ( job , this ) ; m_animatorRoots [ job ] = proxy ; job -> start ( ) ; proxy -> startedBy@@ Controller ( ) ; } m_starting . clear ( ) ; foreach ( QQuickAnimatorProxyJob * proxy , m_stopping ) { QAbstractAnimationJob * job = proxy -> job ( ) ; job -> stop ( ) ; } m_stopping . clear ( ) ; foreach ( QQuickAnimatorJob * job , m_activeLeafAnimations ) { if ( ! job -> target ( ) ) continue ; else if ( m_deletedSinceLastFrame . contains ( job -> target ( ) ) ) job -> targetWasDeleted ( ) ; else if ( job -> isTransform ( ) ) { QQuickTransformAnimatorJob * xform = static_cast < QQuickTransformAnimatorJob * > ( job ) ; xform -> transformHelper ( ) -> sync ( ) ; } } foreach ( QQuickItem * wiped , m_deletedSinceLastFrame ) { QQuickTransformAnimatorJob :: Helper * helper = m_transforms . value ( wiped ) ; if ( helper ) helper -> item = 0 ; } m_deletedSinceLastFrame . clear ( ) ; }
void QQuickAnimatorController :: afterNodeSync ( ) { foreach ( QQuickAnimatorJob * job , m_activeLeafAnimations ) { if ( job -> isUniform ( ) && job -> target ( ) ) static_cast < QQuickUniform@@ AnimatorJob * > ( job ) -> afterNodeSync ( ) ; } }
void QQuickAnimatorController :: animationFinished ( QAbstractAnimationJob * job ) { if ( ! m_deleting . contains ( job ) ) { QQuickAnimatorProxyJob * proxy = m_animatorRoots [ job ] ; if ( proxy ) QCoreApplication :: postEvent ( proxy , new QEvent ( QEvent :: User ) ) ; } }
void QQuickAnimatorController :: animationStateChanged ( QAbstractAnimationJob * job , QAbstractAnimationJob :: State newState , QAbstractAnimationJob :: State oldState ) { Q_ASSERT ( job -> isRenderThreadJob ( ) ) ; QQuickAnimatorJob * animator = static_cast < QQuickAnimatorJob * > ( job ) ; if ( newState == QAbstractAnimationJob :: Running ) { m_activeLeafAnimations << animator ; animator -> setHasBeen@@ Running ( true ) ; } else if ( oldState == QAbstractAnimationJob :: Running ) { m_activeLeafAnimations . remove ( animator ) ; } }
void QQuickAnimatorController :: requestSync ( ) { m_window -> maybeUpdate ( ) ; }
void QQuickAnimatorController :: startJob ( QQuickAnimatorProxyJob * proxy , QAbstractAnimationJob * job ) { m_starting [ job ] = proxy ; requestSync ( ) ; }
void QQuickAnimatorController :: stopJob ( QQuickAnimatorProxyJob * proxy , QAbstractAnimationJob * job ) { m_stopping [ job ] = proxy ; requestSync ( ) ; }
void QQuickAnimatorController :: deleteJob ( QAbstractAnimationJob * job ) { lock ( ) ; m_deleting << job ; requestSync ( ) ; unlock ( ) ; }
TestTracker :: TestTracker ( ) { if ( ! _created ) { initialize ( ) ; setListener ( 0 ) ; _created = true ; } }
TestTracker & TestTracker :: tracker ( ) { static TestTracker theTracker ; return theTracker ; }
void TestTracker :: initialize ( ) { _warnings = 0 ; _skippedTests = 0 ; _testSkipped = false ; _failedTests = 0 ; _testFailedAsserts = 0 ; _suiteFailedTests = 0 ; _failedSuites = 0 ; _world = 0 ; _suite = 0 ; _test = 0 ; }
void TestTracker :: setListener ( TestListener * l ) { _l = l ? l : & _dummyListener ; }
void TestTracker :: enterWorld ( const WorldDescription & wd ) { setWorld ( & wd ) ; _warnings = _skippedTests = _failedTests = _testFailedAsserts = _suiteFailedTests = _failedSuites = 0 ; _testSkipped = false ; _l -> enterWorld ( wd ) ; }
void TestTracker :: enterSuite ( const SuiteDescription & sd ) { setSuite ( & sd ) ; _testFailedAsserts = _suiteFailedTests = 0 ; _testSkipped = false ; _l -> enterSuite ( sd ) ; }
void TestTracker :: enterTest ( const TestDescription & td ) { setTest ( & td ) ; _testFailedAsserts = false ; _testSkipped = false ; _l -> enterTest ( td ) ; }
void TestTracker :: leaveTest ( const TestDescription & td ) { _l -> leaveTest ( td ) ; setTest ( 0 ) ; }
void TestTracker :: leaveSuite ( const SuiteDescription & sd ) { _l -> leaveSuite ( sd ) ; setSuite ( 0 ) ; }
void TestTracker :: leaveWorld ( const WorldDescription & wd ) { _l -> leaveWorld ( wd ) ; setWorld ( 0 ) ; }
void TestTracker :: trace ( const char * file , int line , const char * expression ) { _l -> trace ( file , line , expression ) ; }
void TestTracker :: warning ( const char * file , int line , const char * expression ) { countWarning ( ) ; _l -> warning ( file , line , expression ) ; }
void TestTracker :: skippedTest ( const char * file , int line , const char * expression ) { countSkipped ( ) ; _testSkipped = true ; _l -> skippedTest ( file , line , expression ) ; }
void TestTracker :: failedTest ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedTest ( file , line , expression ) ; }
void TestTracker :: failedAssert ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedAssert ( file , line , expression ) ; }
void TestTracker :: failedAssertEquals ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertEquals ( file , line , xStr , yStr , x , y ) ; }
void TestTracker :: failedAssertSameData ( const char * file , int line , const char * xStr , const char * yStr , const char * sizeStr , const void * x , const void * y , unsigned size ) { countFailure ( ) ; _l -> failedAssertSameData ( file , line , xStr , yStr , sizeStr , x , y , size ) ; }
void TestTracker :: failedAssertDelta ( const char * file , int line , const char * xStr , const char * yStr , const char * dStr , const char * x , const char * y , const char * d ) { countFailure ( ) ; _l -> failedAssertDelta ( file , line , xStr , yStr , dStr , x , y , d ) ; }
void TestTracker :: failedAssertDiffers ( const char * file , int line , const char * xStr , const char * yStr , const char * value ) { countFailure ( ) ; _l -> failedAssertDiffers ( file , line , xStr , yStr , value ) ; }
void TestTracker :: failedAssertLessThan ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertLessThan ( file , line , xStr , yStr , x , y ) ; }
void TestTracker :: failedAssertLessThanEquals ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertLessThanEquals ( file , line , xStr , yStr , x , y ) ; }
void TestTracker :: failedAssertPredicate ( const char * file , int line , const char * predicate , const char * xStr , const char * x ) { countFailure ( ) ; _l -> failedAssertPredicate ( file , line , predicate , xStr , x ) ; }
void TestTracker :: failedAssertRelation ( const char * file , int line , const char * relation , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertRelation ( file , line , relation , xStr , yStr , x , y ) ; }
void TestTracker :: failedAssertThrows ( const char * file , int line , const char * expression , const char * type , bool otherThrown ) { countFailure ( ) ; _l -> failedAssertThrows ( file , line , expression , type , otherThrown ) ; }
void TestTracker :: failedAssertThrowsNot ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedAssertThrowsNot ( file , line , expression ) ; }
void TestTracker :: failedAssertSameFiles ( const char * file , int line , const char * file1 , const char * file2 , const char * explanation ) { countFailure ( ) ; _l -> failedAssertSameFiles ( file , line , file1 , file2 , explanation ) ; }
void TestTracker :: setWorld ( const WorldDescription * w ) { _world = fixWorld ( w ) ; setSuite ( 0 ) ; }
void TestTracker :: setSuite ( const SuiteDescription * s ) { _suite = fixSuite ( s ) ; setTest ( 0 ) ; }
void TestTracker :: setTest ( const TestDescription * t ) { _test = fixTest ( t ) ; }
void TestTracker :: countWarning ( ) { ++ _warnings ; }
void TestTracker :: countSkipped ( ) { ++ _skippedTests ; }
void TestTracker :: countFailure ( ) { if ( ++ _testFailedAsserts == 1 ) { ++ _failedTests ; if ( ++ _suiteFailedTests == 1 ) { ++ _failedSuites ; } } }
void MarginalCovarianceCholesky :: setCholeskyFactor ( int n , int * Lp , int * Li , double * Lx , int * permInv ) { _n = n ; _Ap = Lp ; _Ai = Li ; _Ax = Lx ; _perm = permInv ; _diag . resize ( n ) ; for ( int r = 0 ; r < n ; ++ r ) { const int & sc = _Ap [ r ] ; assert ( r == _Ai [ sc ] && " Error ▁ in ▁ CCS ▁ storage ▁ of ▁ L " ) ; _diag [ r ] = 1.0 / _Ax [ sc ] ; } }
double MarginalCovarianceCholesky :: computeEntry ( int r , int c ) { assert ( r <= c ) ; int idx = computeIndex ( r , c ) ; LookupMap :: const_iterator foundIt = _map . find ( idx ) ; if ( foundIt != _map . end ( ) ) { return foundIt -> second ; } double s = 0. ; const int & sc = _Ap [ r ] ; const int & ec = _Ap [ r + 1 ] ; for ( int j = sc + 1 ; j < ec ; ++ j ) { const int & rr = _Ai [ j ] ; double val = rr < c ? computeEntry ( rr , c ) : computeEntry ( c , rr ) ; s += val * _Ax [ j ] ; } double result ; if ( r == c ) { const double & diagElem = _diag [ r ] ; result = diagElem * ( diagElem - s ) ; } else { result = - s * _diag [ r ] ; } _map [ idx ] = result ; return result ; }
void MarginalCovarianceCholesky :: computeCovariance ( double * * covBlocks , const std :: vector < int > & blockIndices ) { _map . clear ( ) ; int base = 0 ; vector < MatrixElem > elemsToCompute ; for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int nbase = blockIndices [ i ] ; int vdim = nbase - base ; for ( int rr = 0 ; rr < vdim ; ++ rr ) for ( int cc = rr ; cc < vdim ; ++ cc ) { int r = _perm ? _perm [ rr + base ] : rr + base ; int c = _perm ? _perm [ cc + base ] : cc + base ; if ( r > c ) swap ( r , c ) ; elemsToCompute . push_back ( MatrixElem ( r , c ) ) ; } base = nbase ; } sort ( elemsToCompute . begin ( ) , elemsToCompute . end ( ) ) ; for ( size_t i = 0 ; i < elemsToCompute . size ( ) ; ++ i ) { const MatrixElem & me = elemsToCompute [ i ] ; computeEntry ( me . r , me . c ) ; } base = 0 ; for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int nbase = blockIndices [ i ] ; int vdim = nbase - base ; double * cov = covBlocks [ i ] ; for ( int rr = 0 ; rr < vdim ; ++ rr ) for ( int cc = rr ; cc < vdim ; ++ cc ) { int r = _perm ? _perm [ rr + base ] : rr + base ; int c = _perm ? _perm [ cc + base ] : cc + base ; if ( r > c ) swap ( r , c ) ; int idx = computeIndex ( r , c ) ; LookupMap :: const_iterator foundIt = _map . find ( idx ) ; assert ( foundIt != _map . end ( ) ) ; cov [ rr * vdim + cc ] = foundIt -> second ; if ( rr != cc ) cov [ cc * vdim + rr ] = foundIt -> second ; } base = nbase ; } }
void MarginalCovarianceCholesky :: computeCovariance ( SparseBlockMatrix < MatrixXd > & spinv , const std :: vector < int > & rowBlockIndices , const std :: vector < std :: pair < int , int > > & blockIndices ) { spinv = SparseBlockMatrix < MatrixXd > ( & rowBlockIndices [ 0 ] , & rowBlockIndices [ 0 ] , rowBlockIndices . size ( ) , rowBlockIndices . size ( ) , true ) ; _map . clear ( ) ; vector < MatrixElem > elemsToCompute ; for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int blockRow = blockIndices [ i ] . first ; int blockCol = blockIndices [ i ] . second ; assert ( blockRow >= 0 ) ; assert ( blockRow < ( int ) rowBlockIndices . size ( ) ) ; assert ( blockCol >= 0 ) ; assert ( blockCol < ( int ) rowBlockIndices . size ( ) ) ; int rowBase = spinv . rowBaseOfBlock ( blockRow ) ; int colBase = spinv . colBaseOfBlock ( blockCol ) ; MatrixXd * block = spinv . block ( blockRow , blockCol , true ) ; assert ( block ) ; for ( int iRow = 0 ; iRow < block -> rows ( ) ; ++ iRow ) for ( int iCol = 0 ; iCol < block -> cols ( ) ; ++ iCol ) { int rr = rowBase + iRow ; int cc = colBase + iCol ; int r = _perm ? _perm [ rr ] : rr ; int c = _perm ? _perm [ cc ] : cc ; if ( r > c ) swap ( r , c ) ; elemsToCompute . push_back ( MatrixElem ( r , c ) ) ; } } sort ( elemsToCompute . begin ( ) , elemsToCompute . end ( ) ) ; for ( size_t i = 0 ; i < elemsToCompute . size ( ) ; ++ i ) { const MatrixElem & me = elemsToCompute [ i ] ; computeEntry ( me . r , me . c ) ; } for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int blockRow = blockIndices [ i ] . first ; int blockCol = blockIndices [ i ] . second ; int rowBase = spinv . rowBaseOfBlock ( blockRow ) ; int colBase = spinv . colBaseOfBlock ( blockCol ) ; MatrixXd * block = spinv . block ( blockRow , blockCol ) ; assert ( block ) ; for ( int iRow = 0 ; iRow < block -> rows ( ) ; ++ iRow ) for ( int iCol = 0 ; iCol < block -> cols ( ) ; ++ iCol ) { int rr = rowBase + iRow ; int cc = colBase + iCol ; int r = _perm ? _perm [ rr ] : rr ; int c = _perm ? _perm [ cc ] : cc ; if ( r > c ) swap ( r , c ) ; int idx = computeIndex ( r , c ) ; LookupMap :: const_iterator foundIt = _map . find ( idx ) ; assert ( foundIt != _map . end ( ) ) ; ( * block ) ( iRow , iCol ) = foundIt -> second ; } } }
void AP_Frsky_Telem :: init ( const AP_SerialManager & serial_manager , const uint8_t mav_type , const uint32_t * ap_valuep ) { if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_D , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_D ; } else if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_SPort , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_SPort ; } else if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough ; gcs ( ) . register_frsk@@ y_telem@@ etry_callback ( this ) ; if ( _frame_string == nullptr ) { queue_message ( MAV_SEVERITY_INFO , AP :: fwversion ( ) . fw_string ) ; } else { char firmware_buf [ MAVLINK_@@ MSG_ST@@ ATUSTEXT_FIELD_@@ TEXT_LEN + 1 ] ; snprintf ( firmware_buf , sizeof ( firmware_buf ) , " % s ▁ % s " , AP :: fwversion ( ) . fw_string , _frame_string ) ; queue_message ( MAV_SEVERITY_INFO , firmware_buf ) ; } _params . mav_type = mav_type ; if ( ap_valuep == nullptr ) { _ap . value = 0x2000 ; _ap . valuep = & _ap . value ; } else { _ap . valuep = ap_valuep ; } } if ( _port != nullptr ) { hal . scheduler -> register_io_pro@@ cess ( FUNCTOR_@@ BIND_MEMBER ( & AP_Frsky_Telem :: tick , void ) ) ; _port -> set_flow_control ( AP_HAL :: UARTDriver :: FLOW_CON@@ TROL_DISABLE ) ; } }
void AP_Frsky_Telem :: send_SPort_Passthrough ( void ) { int16_t numc ; numc = _port -> available ( ) ; if ( numc < 0 ) { return ; } if ( _port -> txspace ( ) < 19 ) { return ; } uint8_t prev_byte = 0 ; for ( int16_t i = 0 ; i < numc ; i ++ ) { prev_byte = _passthrough . new_byte ; _passthrough . new_byte = _port -> read ( ) ; } if ( ( prev_byte == START_STOP_SPORT ) && ( _passthrough . new_byte == SENSOR_ID_28 ) ) { if ( _passthrough . send_attiandrng ) { _passthrough . send_attiandrng = false ; } else { _passthrough . send_attiandrng = true ; uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - _passthrough . params_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 7 , calc_param ( ) ) ; _passthrough . params_timer = AP_HAL :: millis ( ) ; return ; } check_sensor_status_flags ( ) ; check_ekf_status ( ) ; if ( get_next_msg_chunk ( ) ) { send_uint32 ( DIY_FIRST_ID , _msg_chunk . chunk ) ; return ; } if ( ( now - _passthrough . ap_status_timer ) >= 500 ) { if ( ( ( * _ap . valuep ) & AP_INITI@@ ALIZE@@ D_FLAG ) > 0 ) { send_uint32 ( DIY_FIRST_ID + 1 , calc_ap_status ( ) ) ; _passthrough . ap_status_timer = AP_HAL :: millis ( ) ; } return ; } if ( ( now - _passthrough . batt_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 3 , calc_batt ( 0 ) ) ; _passthrough . batt_timer = AP_HAL :: millis ( ) ; return ; } if ( _battery . num_instances ( ) > 1 ) { if ( ( now - _passthrough . batt_timer2 ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 8 , calc_batt ( 1 ) ) ; _passthrough . batt_timer2 = AP_HAL :: millis ( ) ; return ; } } if ( ( now - _passthrough . gps_status_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 2 , calc_gps_status ( ) ) ; _passthrough . gps_status_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . home_timer ) >= 500 ) { send_uint32 ( DIY_FIRST_ID + 4 , calc_home ( ) ) ; _passthrough . home_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . velandyaw_timer ) >= 500 ) { send_uint32 ( DIY_FIRST_ID + 5 , calc_velandyaw ( ) ) ; _passthrough . velandyaw_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . gps_latlng_timer ) >= 1000 ) { send_uint32 ( GPS_LONG_LATI@@ _FIRST_ID , calc_gps_latlng ( & _passthrough . send_latitude ) ) ; if ( ! _passthrough . send_latitude ) { _passthrough . gps_latlng_timer = AP_HAL :: millis ( ) ; } return ; } } send_uint32 ( DIY_FIRST_ID + 6 , calc_attiandrng ( ) ) ; } }
void AP_Frsky_Telem :: send_SPort ( void ) { int16_t numc ; numc = _port -> available ( ) ; if ( numc < 0 ) { return ; } if ( _port -> txspace ( ) < 19 ) { return ; } for ( int16_t i = 0 ; i < numc ; i ++ ) { int16_t readbyte = _port -> read ( ) ; if ( _SPort . sport_status == false ) { if ( readbyte == START_STOP_SPORT ) { _SPort . sport_status = true ; } } else { switch ( readbyte ) { case SENSOR_ID_F@@ AS : switch ( _SPort . fas_call ) { case 0 : send_uint32 ( DATA_ID_FUEL , ( uint16_t ) roundf ( _battery . capacity_remaining_pct ( ) ) ) ; break ; case 1 : send_uint32 ( DATA_ID_VFAS , ( uint16_t ) roundf ( _battery . voltage ( ) * 10.0f ) ) ; break ; case 2 : send_uint32 ( DATA_ID_CURRENT , ( uint16_t ) roundf ( _battery . current_amps ( ) * 10.0f ) ) ; break ; } if ( _SPort . fas_call ++ > 2 ) _SPort . fas_call = 0 ; break ; case SENSOR_ID_GPS : switch ( _SPort . gps_call ) { case 0 : calc_gps_position ( ) ; send_uint32 ( DATA_ID_GPS_LAT_BP , _gps . latdddmm ) ; break ; case 1 : send_uint32 ( DATA_ID_GPS_LAT_AP , _gps . latmmmm ) ; break ; case 2 : send_uint32 ( DATA_ID_GPS_LAT_NS , _gps . lat_ns ) ; break ; case 3 : send_uint32 ( DATA_ID_GPS_LONG_BP , _gps . londddmm ) ; break ; case 4 : send_uint32 ( DATA_ID_GPS_LONG_AP , _gps . lonmmmm ) ; break ; case 5 : send_uint32 ( DATA_ID_GPS_LONG_EW , _gps . lon_ew ) ; break ; case 6 : send_uint32 ( DATA_ID_GPS_SPEED_BP , _gps . speed_in_meter ) ; break ; case 7 : send_uint32 ( DATA_ID_GPS_SPEED_AP , _gps . speed_in_centimeter ) ; break ; case 8 : send_uint32 ( DATA_ID_GPS_ALT_BP , _gps . alt_gps_meters ) ; break ; case 9 : send_uint32 ( DATA_ID_GPS_ALT_AP , _gps . alt_gps_cm ) ; break ; case 10 : send_uint32 ( DATA_ID_GPS_COURS_BP , ( uint16_t ) ( ( _ahrs . yaw_sensor / 100 ) % 360 ) ) ; break ; } if ( _SPort . gps_call ++ > 10 ) _SPort . gps_call = 0 ; break ; case SENSOR_ID_VARIO : switch ( _SPort . vario_call ) { case 0 : calc_nav_alt ( ) ; send_uint32 ( DATA_ID_BARO_ALT_BP , _gps . alt_nav_meters ) ; break ; case 1 : send_uint32 ( DATA_ID_BARO_ALT_AP , _gps . alt_nav_cm ) ; break ; } if ( _SPort . vario_call ++ > 1 ) _SPort . vario_call = 0 ; break ; case SENSOR_ID_SP@@ 2UR : switch ( _SPort . various_call ) { case 0 : send_uint32 ( DATA_ID_TEMP2 , ( uint16_t ) ( AP :: gps ( ) . num_sats ( ) * 10 + AP :: gps ( ) . status ( ) ) ) ; break ; case 1 : send_uint32 ( DATA_ID_TEMP1 , _ap . control_mode ) ; break ; } if ( _SPort . various_call ++ > 1 ) _SPort . various_call = 0 ; break ; } _SPort . sport_status = false ; } } }
void AP_Frsky_Telem :: send_D ( void ) { uint32_t now = AP_HAL :: millis ( ) ; if ( now - _D . last_200ms_frame >= 200 ) { _D . last_200ms_frame = now ; send_uint16 ( DATA_ID_TEMP2 , ( uint16_t ) ( AP :: gps ( ) . num_sats ( ) * 10 + AP :: gps ( ) . status ( ) ) ) ; send_uint16 ( DATA_ID_TEMP1 , _ap . control_mode ) ; send_uint16 ( DATA_ID_FUEL , ( uint16_t ) roundf ( _battery . capacity_remaining_pct ( ) ) ) ; send_uint16 ( DATA_ID_VFAS , ( uint16_t ) roundf ( _battery . voltage ( ) * 10.0f ) ) ; send_uint16 ( DATA_ID_CURRENT , ( uint16_t ) roundf ( _battery . current_amps ( ) * 10.0f ) ) ; calc_nav_alt ( ) ; send_uint16 ( DATA_ID_BARO_ALT_BP , _gps . alt_nav_meters ) ; send_uint16 ( DATA_ID_BARO_ALT_AP , _gps . alt_nav_cm ) ; } if ( now - _D . last_1000ms_frame >= 1000 ) { _D . last_1000ms_frame = now ; send_uint16 ( DATA_ID_GPS_COURS_BP , ( uint16_t ) ( ( _ahrs . yaw_sensor / 100 ) % 360 ) ) ; calc_gps_position ( ) ; if ( AP :: gps ( ) . status ( ) >= 3 ) { send_uint16 ( DATA_ID_GPS_LAT_BP , _gps . latdddmm ) ; send_uint16 ( DATA_ID_GPS_LAT_AP , _gps . latmmmm ) ; send_uint16 ( DATA_ID_GPS_LAT_NS , _gps . lat_ns ) ; send_uint16 ( DATA_ID_GPS_LONG_BP , _gps . londddmm ) ; send_uint16 ( DATA_ID_GPS_LONG_AP , _gps . lonmmmm ) ; send_uint16 ( DATA_ID_GPS_LONG_EW , _gps . lon_ew ) ; send_uint16 ( DATA_ID_GPS_SPEED_BP , _gps . speed_in_meter ) ; send_uint16 ( DATA_ID_GPS_SPEED_AP , _gps . speed_in_centimeter ) ; send_uint16 ( DATA_ID_GPS_ALT_BP , _gps . alt_gps_meters ) ; send_uint16 ( DATA_ID_GPS_ALT_AP , _gps . alt_gps_cm ) ; } } }
void AP_Frsky_Telem :: tick ( void ) { if ( ! _initialised_uart ) { if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { _port -> begin ( AP_SERIALMANAGER_FRSKY_D_BAUD , AP_SERIALMANAGER_FRSKY_BUFSIZE_RX , AP_SERIALMANAGER_FRSKY_BUFSIZE_TX ) ; } else { _port -> begin ( AP_SERIALMANAGER_FRSKY_SP@@ ORT_BAUD , AP_SERIALMANAGER_FRSKY_BUFSIZE_RX , AP_SERIALMANAGER_FRSKY_BUFSIZE_TX ) ; } _initialised_uart = true ; } if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { send_D ( ) ; } else if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_SPort ) { send_SPort ( ) ; } else if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough ) { send_SPort_Passthrough ( ) ; } }
void AP_Frsky_Telem :: calc_crc ( uint8_t byte ) { _crc += byte ; _crc += _crc >> 8 ; _crc &= 0xFF ; }
void AP_Frsky_Telem :: send_crc ( void ) { send_byte ( 0xFF - _crc ) ; _crc = 0 ; }
void AP_Frsky_Telem :: send_byte ( uint8_t byte ) { if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { if ( byte == START_STOP_D ) { _port -> write ( 0x5D ) ; _port -> write ( 0x3E ) ; } else if ( byte == BYTESTUFF_D ) { _port -> write ( 0x5D ) ; _port -> write ( 0x3D ) ; } else { _port -> write ( byte ) ; } } else { if ( byte == START_STOP_SPORT ) { _port -> write ( 0x7D ) ; _port -> write ( 0x5E ) ; } else if ( byte == BYTESTUFF_SPORT ) { _port -> write ( 0x7D ) ; _port -> write ( 0x5D ) ; } else { _port -> write ( byte ) ; } calc_crc ( byte ) ; } }
void AP_Frsky_Telem :: send_uint32 ( uint16_t id , uint32_t data ) { send_byte ( 0x10 ) ; uint8_t * bytes = ( uint8_t * ) & id ; send_byte ( bytes [ 0 ] ) ; send_byte ( bytes [ 1 ] ) ; bytes = ( uint8_t * ) & data ; send_byte ( bytes [ 0 ] ) ; send_byte ( bytes [ 1 ] ) ; send_byte ( bytes [ 2 ] ) ; send_byte ( bytes [ 3 ] ) ; send_crc ( ) ; }
void AP_Frsky_Telem :: send_uint16 ( uint16_t id , uint16_t data ) { _port -> write ( START_STOP_D ) ; uint8_t * bytes = ( uint8_t * ) & id ; send_byte ( bytes [ 0 ] ) ; bytes = ( uint8_t * ) & data ; send_byte ( bytes [ 0 ] ) ; send_byte ( bytes [ 1 ] ) ; }
bool AP_Frsky_Telem :: get_next_msg_chunk ( void ) { if ( _statustext_queue . empty ( ) ) { return false ; } if ( _msg_chunk . repeats == 0 ) { uint8_t character = 0 ; _msg_chunk . chunk = 0 ; for ( int i = 3 ; i > - 1 && _msg_chunk . char_index < sizeof ( _statustext_queue [ 0 ] -> text ) ; i -- ) { character = _statustext_queue [ 0 ] -> text [ _msg_chunk . char_index ++ ] ; if ( ! character ) { break ; } _msg_chunk . chunk |= character << i * 8 ; } if ( ! character || ( _msg_chunk . char_index == sizeof ( _statustext_queue [ 0 ] -> text ) ) ) { _msg_chunk . char_index = 0 ; _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x4 ) << 21 ; _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x2 ) << 14 ; _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x1 ) << 7 ; } } if ( _msg_chunk . repeats ++ > 2 ) { _msg_chunk . repeats = 0 ; if ( _msg_chunk . char_index == 0 ) { _statustext_queue . remove ( 0 ) ; } } return true ; }
void AP_Frsky_Telem :: queue_message ( MAV_SEVERITY severity , const char * text ) { mavlink_statustext_t statustext { } ; statustext . severity = severity ; strncpy ( statustext . text , text , sizeof ( statustext . text ) ) ; _statustext_queue . push_force ( statustext ) ; }
void AP_Frsky_Telem :: check_sensor_status_flags ( void ) { uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - check_sensor_status_timer ) >= 5000 ) { if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_GPS ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ GPS ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_GY@@ RO ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Gyro ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_ACCEL ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Accel ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_MAG ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Compass ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_ABS@@ OLUTE_PRESSURE ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Baro ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_LASER_POSITION ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ LiDAR ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_OPTIC@@ AL_FLO@@ W ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ OptFlow ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_TERRAIN ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ or ▁ No ▁ Terrain ▁ Data " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_GEOF@@ ENCE ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Geofence ▁ Breach " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_AHRS ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ AHRS " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_RC_@@ RECEIVER ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " No ▁ RC ▁ Receiver " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_LOGGING ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Logging " ) ; check_sensor_status_timer = now ; } } }
void AP_Frsky_Telem :: check_ekf_status ( void ) { float velVar , posVar , hgtVar , tasVar ; Vector3f magVar ; Vector2f offset ; if ( _ahrs . get_varian@@ ces ( velVar , posVar , hgtVar , magVar , tasVar , offset ) ) { uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - check_ekf_status_timer ) >= 10000 ) { if ( velVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ velocity ▁ variance " ) ; check_ekf_status_timer = now ; } if ( posVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ pos ▁ horiz ▁ variance " ) ; check_ekf_status_timer = now ; } if ( hgtVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ pos ▁ vert ▁ variance " ) ; check_ekf_status_timer = now ; } if ( magVar . length ( ) >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ compass ▁ variance " ) ; check_ekf_status_timer = now ; } if ( tasVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ terrain ▁ alt ▁ variance " ) ; check_ekf_status_timer = now ; } } } }
uint32_t AP_Frsky_Telem :: calc_param ( void ) { uint32_t param = 0 ; if ( _paramID >= 5 ) { _paramID = 0 ; } _paramID ++ ; switch ( _paramID ) { case 1 : param = _params . mav_type ; break ; case 2 : case 3 : break ; case 4 : param = ( uint32_t ) roundf ( _battery . pack_capacity_mah ( 0 ) ) ; break ; case 5 : param = ( uint32_t ) roundf ( _battery . pack_capacity_mah ( 1 ) ) ; break ; } param = ( _paramID << PARAM_ID_OFFSET ) | ( param & PARAM_VALUE_@@ LIMIT ) ; return param ; }
uint32_t AP_Frsky_Telem :: calc_gps_latlng ( bool * send_latitude ) { uint32_t latlng ; const Location & loc = AP :: gps ( ) . location ( 0 ) ; if ( ( * send_latitude ) == true ) { if ( loc . lat < 0 ) { latlng = ( ( labs ( loc . lat ) / 100 ) * 6 ) | 0x40000000 ; } else { latlng = ( ( labs ( loc . lat ) / 100 ) * 6 ) ; } ( * send_latitude ) = false ; } else { if ( loc . lng < 0 ) { latlng = ( ( labs ( loc . lng ) / 100 ) * 6 ) | 0xC0000000 ; } else { latlng = ( ( labs ( loc . lng ) / 100 ) * 6 ) | 0x80000000 ; } ( * send_latitude ) = true ; } return latlng ; }
uint32_t AP_Frsky_Telem :: calc_gps_status ( void ) { const AP_GPS & gps = AP :: gps ( ) ; uint32_t gps_status ; gps_status = ( gps . num_sats ( ) < GPS_SATS_LIMIT ) ? gps . num_sats ( ) : GPS_SATS_LIMIT ; gps_status |= ( ( gps . status ( ) < GPS_STATUS_LIMIT ) ? gps . status ( ) : GPS_STATUS_LIMIT ) << GPS_STATUS_OFFSET ; gps_status |= prep_number ( roundf ( gps . get_hdop ( ) * 0.1f ) , 2 , 1 ) << GPS_HDO@@ P_OFFSET ; gps_status |= ( ( gps . status ( ) > GPS_STATUS_LIMIT ) ? gps . status ( ) - GPS_STATUS_LIMIT : 0 ) << GPS_ADV@@ STATUS_OFFSET ; const Location & loc = gps . location ( ) ; gps_status |= prep_number ( roundf ( loc . alt * 0.1f ) , 2 , 2 ) << GPS_AL@@ TMSL_OFFSET ; return gps_status ; }
uint32_t AP_Frsky_Telem :: calc_batt ( uint8_t instance ) { uint32_t batt ; batt = ( ( ( uint16_t ) roundf ( _battery . voltage ( instance ) * 10.0f ) ) & BATT_VOL@@ TAGE_LIMIT ) ; batt |= prep_number ( roundf ( _battery . current_amps ( instance ) * 10.0f ) , 2 , 1 ) << BATT_CURRENT_@@ OFFSET ; batt |= ( ( _battery . consumed_mah ( instance ) < BATT_TOTALMAH_LIMIT ) ? ( ( uint16_t ) roundf ( _battery . consumed_mah ( instance ) ) & BATT_TOTALMAH_LIMIT ) : BATT_TOTALMAH_LIMIT ) << BATT_TOTALMAH_OFFSET ; return batt ; }
uint32_t AP_Frsky_Telem :: calc_ap_status ( void ) { uint32_t ap_status ; uint8_t imu_temp = ( uint8_t ) roundf ( constrain_float ( AP :: ins ( ) . get_temperature ( 0 ) , AP_IMU_TEMP_MIN , AP_IMU_TEMP_MAX ) - AP_IMU_TEMP_MIN ) ; ap_status = ( uint8_t ) ( ( _ap . control_mode + 1 ) & AP_CONTROL_@@ MODE_LIMIT ) ; ap_status |= ( uint8_t ) ( ( * _ap . valuep ) & AP_SSIMPLE_FLAGS ) << AP_SSIMPLE_OFFSET ; ap_status |= ( uint8_t ) ( ( ( * _ap . valuep ) & AP_LANDCOMPLETE_FLAG ) ^ AP_LANDCOMPLETE_FLAG ) ; ap_status |= ( uint8_t ) ( AP_Notify :: flags . armed ) << AP_AR@@ MED_OFFSET ; ap_status |= ( uint8_t ) ( AP_Notify :: flags . failsafe_@@ battery ) << AP_BATT_@@ FS_OFFSET ; ap_status |= ( uint8_t ) ( AP_Notify :: flags . ekf_b@@ ad ) << AP_EK@@ F_FS_OFFSET ; ap_status |= imu_temp << AP_IMU_TEMP_OFFSET ; return ap_status ; }
uint32_t AP_Frsky_Telem :: calc_home ( void ) { uint32_t home = 0 ; Location loc ; float _relative_home_altitude = 0 ; if ( _ahrs . get_position ( loc ) ) { const Location & home_loc = _ahrs . get_home ( ) ; if ( home_loc . lat != 0 || home_loc . lng != 0 ) { home = prep_number ( roundf ( get_distance ( home_loc , loc ) ) , 3 , 2 ) ; home |= ( ( ( uint8_t ) roundf ( get_bearing@@ _cd ( loc , home_loc ) * 0.00333f ) ) & HOME_BEARING_LIMIT ) << HOME_BEARING_OFFSET ; } _relative_home_altitude = loc . alt ; if ( ! loc . flags . relative_alt ) { _relative_home_altitude -= _ahrs . get_home ( ) . alt ; } } home |= prep_number ( roundf ( _relative_home_altitude * 0.1f ) , 3 , 2 ) << HOME_ALT_OFFSET ; return home ; }
uint32_t AP_Frsky_Telem :: calc_velandyaw ( void ) { uint32_t velandyaw ; Vector3f velNED { } ; _ahrs . get_veloc@@ ity_NED ( velNED ) ; velandyaw = prep_number ( roundf ( - velNED . z * 10 ) , 2 , 1 ) ; const AP_Airspeed * aspeed = _ahrs . get_airspeed ( ) ; if ( aspeed && aspeed -> enabled ( ) ) { velandyaw |= prep_number ( roundf ( aspeed -> get_airspeed ( ) * 10 ) , 2 , 1 ) << VELANDYAW_XYVEL_OFFSET ; } else { velandyaw |= prep_number ( roundf ( _ahrs . groundspeed ( ) * 10 ) , 2 , 1 ) << VELANDYAW_XYVEL_OFFSET ; } velandyaw |= ( ( uint16_t ) roundf ( _ahrs . yaw_sensor * 0.05f ) & VELANDYAW_YAW_LIMIT ) << VELANDYAW_YAW_OFFSET ; return velandyaw ; }
uint32_t AP_Frsky_Telem :: calc_attiandrng ( void ) { uint32_t attiandrng ; attiandrng = ( ( uint16_t ) roundf ( ( _ahrs . roll_sensor + 18000 ) * 0.05f ) & ATTIANDRNG_ROLL_@@ LIMIT ) ; attiandrng |= ( ( uint16_t ) roundf ( ( _ahrs . pitch_sensor + 9000 ) * 0.05f ) & ATTIANDRNG_PITCH_LIMIT ) << ATTIANDRNG_PITCH_OFFSET ; attiandrng |= prep_number ( _rng . distance_cm_ori@@ ent ( ROTATION_PITCH_@@ 270 ) , 3 , 1 ) << ATTIANDRNG_RNG@@ FND_OFFSET ; return attiandrng ; }
uint16_t AP_Frsky_Telem :: prep_number ( int32_t number , uint8_t digits , uint8_t power ) { uint16_t res = 0 ; uint32_t abs_number = abs ( number ) ; if ( ( digits == 2 ) && ( power == 1 ) ) { if ( abs_number < 100 ) { res = abs_number << 1 ; } else if ( abs_number < 1270 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.1f ) << 1 ) | 0x1 ; } else { res = 0xFF ; } if ( number < 0 ) { res |= 0x1 << 8 ; } } else if ( ( digits == 2 ) && ( power == 2 ) ) { if ( abs_number < 100 ) { res = abs_number << 2 ; } else if ( abs_number < 1000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.1f ) << 2 ) | 0x1 ; } else if ( abs_number < 10000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.01f ) << 2 ) | 0x2 ; } else if ( abs_number < 127000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.001f ) << 2 ) | 0x3 ; } else { res = 0x1FF ; } if ( number < 0 ) { res |= 0x1 << 9 ; } } else if ( ( digits == 3 ) && ( power == 1 ) ) { if ( abs_number < 1000 ) { res = abs_number << 1 ; } else if ( abs_number < 10240 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.1f ) << 1 ) | 0x1 ; } else { res = 0x7FF ; } if ( number < 0 ) { res |= 0x1 << 11 ; } } else if ( ( digits == 3 ) && ( power == 2 ) ) { if ( abs_number < 1000 ) { res = abs_number << 2 ; } else if ( abs_number < 10000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.1f ) << 2 ) | 0x1 ; } else if ( abs_number < 100000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.01f ) << 2 ) | 0x2 ; } else if ( abs_number < 1024000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.001f ) << 2 ) | 0x3 ; } else { res = 0xFFF ; } if ( number < 0 ) { res |= 0x1 << 12 ; } } return res ; }
void AP_Frsky_Telem :: calc_nav_alt ( void ) { Location loc ; float current_height = 0 ; if ( _ahrs . get_position ( loc ) ) { current_height = loc . alt * 0.01f ; if ( ! loc . flags . relative_alt ) { current_height -= _ahrs . get_home ( ) . alt * 0.01f ; } } _gps . alt_nav_meters = ( int16_t ) current_height ; _gps . alt_nav_cm = ( current_height - _gps . alt_nav_meters ) * 100 ; }
float AP_Frsky_Telem :: format_gps ( float dec ) { uint8_t dm_deg = ( uint8_t ) dec ; return ( dm_deg * 100.0f ) + ( dec - dm_deg ) * 60 ; }
void AP_Frsky_Telem :: calc_gps_position ( void ) { float lat ; float lon ; float alt ; float speed ; if ( AP :: gps ( ) . status ( ) >= 3 ) { const Location & loc = AP :: gps ( ) . location ( ) ; lat = format_gps ( fabsf ( loc . lat / 10000000.0f ) ) ; _gps . latdddmm = lat ; _gps . latmmmm = ( lat - _gps . latdddmm ) * 10000 ; _gps . lat_ns = ( loc . lat < 0 ) ? ' S ' : ' N ' ; lon = format_gps ( fabsf ( loc . lng / 10000000.0f ) ) ; _gps . londddmm = lon ; _gps . lonmmmm = ( lon - _gps . londddmm ) * 10000 ; _gps . lon_ew = ( loc . lng < 0 ) ? ' W ' : ' E ' ; alt = loc . alt * 0.01f ; _gps . alt_gps_meters = ( int16_t ) alt ; _gps . alt_gps_cm = ( alt - _gps . alt_gps_meters ) * 100 ; speed = AP :: gps ( ) . ground_speed ( ) ; _gps . speed_in_meter = speed ; _gps . speed_in_centimeter = ( speed - _gps . speed_in_meter ) * 100 ; } else { _gps . latdddmm = 0 ; _gps . latmmmm = 0 ; _gps . lat_ns = 0 ; _gps . londddmm = 0 ; _gps . lonmmmm = 0 ; _gps . alt_gps_meters = 0 ; _gps . alt_gps_cm = 0 ; _gps . speed_in_meter = 0 ; _gps . speed_in_centimeter = 0 ; } }
ProximityGrid :: ~ ProximityGrid ( ) { dtFree ( m_buckets ) ; dtFree ( m_pool ) ; }
bool ProximityGrid :: init ( const int maxItems , const float cellSize ) { dtAssert ( maxItems > 0 ) ; dtAssert ( cellSize > 0.0f ) ; m_cellSize = cellSize ; m_invCellSize = 1.0f / m_cellSize ; m_bucketsSize = dtNext@@ Pow2 ( maxItems ) ; m_buckets = ( unsigned short * ) dtAlloc ( sizeof ( unsigned short ) * m_bucketsSize , DT_ALLOC_PERM ) ; if ( ! m_buckets ) return false ; m_poolSize = maxItems * 4 ; m_poolHead = 0 ; m_pool = ( Item * ) dtAlloc ( sizeof ( Item ) * m_poolSize , DT_ALLOC_PERM ) ; if ( ! m_pool ) return false ; clear ( ) ; return true ; }
void ProximityGrid :: clear ( ) { memset ( m_buckets , 0xff , sizeof ( unsigned short ) * m_bucketsSize ) ; m_poolHead = 0 ; m_bounds [ 0 ] = 0xffff ; m_bounds [ 1 ] = 0xffff ; m_bounds [ 2 ] = - 0xffff ; m_bounds [ 3 ] = - 0xffff ; }
void ProximityGrid :: addItem ( const unsigned short id , const float minx , const float miny , const float maxx , const float maxy ) { const int iminx = ( int ) floorf ( minx * m_invCellSize ) ; const int iminy = ( int ) floorf ( miny * m_invCellSize ) ; const int imaxx = ( int ) floorf ( maxx * m_invCellSize ) ; const int imaxy = ( int ) floorf ( maxy * m_invCellSize ) ; m_bounds [ 0 ] = dtMin ( m_bounds [ 0 ] , iminx ) ; m_bounds [ 1 ] = dtMin ( m_bounds [ 1 ] , iminy ) ; m_bounds [ 2 ] = dtMax ( m_bounds [ 2 ] , imaxx ) ; m_bounds [ 3 ] = dtMax ( m_bounds [ 3 ] , imaxy ) ; for ( int y = iminy ; y <= imaxy ; ++ y ) { for ( int x = iminx ; x <= imaxx ; ++ x ) { if ( m_poolHead < m_poolSize ) { const int h = hashPos2 ( x , y , m_bucketsSize ) ; const unsigned short idx = ( unsigned short ) m_poolHead ; m_poolHead ++ ; Item & item = m_pool [ idx ] ; item . x = ( short ) x ; item . y = ( short ) y ; item . id = id ; item . next = m_buckets [ h ] ; m_buckets [ h ] = idx ; } } } }
