int main ( ) { QMap < int , int > m ; m [ 10 ] = 100 ; m [ 20 ] = 200 ; m [ 30 ] = 300 ; return 0 ; }
int main ( ) { Game aGame ; aGame . add ( " Chet " ) ; aGame . add ( " Pat " ) ; aGame . add ( " Sue " ) ; do { aGame . roll ( rand ( ) % 5 + 1 ) ; if ( rand ( ) % 9 == 7 ) { notAWinner = aGame . wrongAnsw@@ er ( ) ; } else { notAWinner = aGame . wasCorrect@@ lyAnsw@@ ered ( ) ; } } while ( notAWinner ) ; }
DWORD CascDecompress ( LPBYTE pbOutBuffer , PDWORD pcbOutBuffer , LPBYTE pbInBuffer , DWORD cbInBuffer ) { z_stream z ; DWORD dwErrCode = ERROR_FILE_CORRUP@@ T ; uInt cbOutBuffer = * pcbOutBuffer ; int nResult ; z . next_in = pbInBuffer ; z . avail_in = cbInBuffer ; z . total_in = cbInBuffer ; z . next_out = pbOutBuffer ; z . avail_out = cbOutBuffer ; z . total_out = 0 ; z . zalloc = NULL ; z . zfree = NULL ; cbOutBuffer = 0 ; if ( ( nResult = inflateInit ( & z ) ) == Z_OK ) { nResult = inflate ( & z , Z_NO_F@@ LUSH ) ; if ( nResult == Z_OK || nResult == Z_STREAM_END ) { cbOutBuffer = z . total_out ; dwErrCode = ERROR_SUCCESS ; } inflateEnd ( & z ) ; } pcbOutBuffer [ 0 ] = cbOutBuffer ; return dwErrCode ; }
int main ( ) { constexpr Person john { 30 } ; BOOST_HANA_CONSTANT_CHECK ( f ( john ) == hana :: nothing ) ; BOOST_HANA_CONSTANT_CHECK ( f ( 1 ) == hana :: nothing ) ; BOOST_HANA_CONSTEXPR_CHECK ( f ( & john ) == hana :: just ( 30u ) ) ; }
void AddSC_boss_high_interrogator_gerstahn ( ) { new boss_high_interrogator_gerstahn ( ) ; }
void heapsort ( Comparable * A [ ] , int n ) { std :: cout << " Getting ▁ started ▁ with ▁ array : " << std :: endl ; for ( int j = 0 ; j < n ; j ++ ) std :: cout << * A [ j ] << " ▁ " ; std :: cout << std :: endl ; MaxHeap H ( A , n , n ) ; std :: cout << " Now , ▁ ready ▁ to ▁ unpack ▁ the ▁ heap " << std :: endl ; for ( int i = 0 ; i < n ; i ++ ) H . removemax ( ) ; }
bool sorttest ( int array [ ] , int n , int threshold ) { Comparable * A [ n ] ; int i ; cout << " We ▁ came ▁ in ▁ with ▁ array : " << endl ; for ( i = 0 ; i < n ; i ++ ) std :: cout << array [ i ] << " ▁ " ; std :: cout << std :: endl ; for ( i = 0 ; i < n ; ++ i ) { A [ i ] = new Int ( array [ i ] ) ; } cout << " We ▁ are ▁ going ▁ to ▁ call ▁ Heapsort ▁ with ▁ this ▁ array : " << endl ; for ( i = 0 ; i < n ; i ++ ) std :: cout << A [ i ] << " ▁ " ; std :: cout << std :: endl ; heapsort ( A , n ) ; if ( ! checkorder ( A , n ) ) return false ; for ( i = 0 ; i < n ; ++ i ) { delete A [ i ] ; } for ( i = 0 ; i < n ; ++ i ) { A [ i ] = new KVPair ( array [ i ] , & array [ i ] ) ; } if ( ! checkorder ( A , n ) ) return false ; for ( i = 0 ; i < n ; ++ i ) { delete A [ i ] ; } delete [ ] array ; return true ; }
boss_nerubenkanAI ( Creature * creature ) : ScriptedAI ( creature ) { instance = me -> GetInstanceScript ( ) ; }
void Reset ( ) { CryptScarabs_Timer = 3000 ; EncasingWebs_Timer = 7000 ; PierceArmor_Timer = 19000 ; RaiseUndeadScarab_Timer = 3000 ; }
void JustDied ( Unit * ) { if ( instance ) instance -> SetData ( TYPE_NERUB , IN_PROGRESS ) ; }
void RaiseUndeadScarab ( Unit * victim ) { if ( Creature * pUndeadScarab = DoSpawn@@ Creature ( 10876 , float ( irand ( - 9 , 9 ) ) , float ( irand ( - 9 , 9 ) ) , 0 , 0 , TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN , 180000 ) ) if ( pUndeadScarab -> AI ( ) ) pUndeadScarab -> AI ( ) -> AttackStart ( victim ) ; }
void UpdateAI ( const uint32 diff ) { if ( ! UpdateVictim ( ) ) return ; if ( EncasingWebs_Timer <= diff ) { DoCast ( me -> getVictim ( ) , SPELL_ENCASINGWEBS ) ; EncasingWebs_Timer = 30000 ; } else EncasingWebs_Timer -= diff ; if ( PierceArmor_Timer <= diff ) { if ( urand ( 0 , 3 ) < 2 ) DoCast ( me -> getVictim ( ) , SPELL_PIERCEARMOR ) ; PierceArmor_Timer = 35000 ; } else PierceArmor_Timer -= diff ; if ( CryptScarabs_Timer <= diff ) { DoCast ( me -> getVictim ( ) , SPELL_CRYPT_SCARABS ) ; CryptScarabs_Timer = 20000 ; } else CryptScarabs_Timer -= diff ; if ( RaiseUndeadScarab_Timer <= diff ) { RaiseUndeadScarab ( me -> getVictim ( ) ) ; RaiseUndeadScarab_Timer = 16000 ; } else RaiseUndeadScarab_Timer -= diff ; DoMeleeAttackIfReady ( ) ; }
void AddSC_boss_nerubenkan ( ) { new boss_nerubenkan ( ) ; }
public : bool exist ( vector < vector < char >> & board , string word ) { if ( board . size ( ) == 0 ) return word == " " ; m = board . size ( ) , n = board [ 0 ] . size ( ) ; this -> word = word ; this -> board = board ; visit . resize ( m , vector < bool > ( n ) ) ; for ( int j = 0 ; j < m ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( board [ j ] [ k ] == word [ 0 ] ) { visit [ j ] [ k ] = true ; dfs ( j , k , 0 ) ; visit [ j ] [ k ] = false ; } } } return flag ; }
void dfs ( int x , int y , int index ) { if ( flag == true ) return ; if ( index == word . length ( ) - 1 ) { flag = true ; return ; } for ( int i = 0 ; i < 4 ; i ++ ) { int tx = x + dir [ i ] [ 0 ] , ty = y + dir [ i ] [ 1 ] ; if ( tx >= 0 && tx < m && ty >= 0 && ty < n && board [ tx ] [ ty ] == word [ index + 1 ] && visit [ tx ] [ ty ] == false ) { visit [ tx ] [ ty ] = true ; dfs ( tx , ty , index + 1 ) ; visit [ tx ] [ ty ] = false ; } } }
static ImVec4 RGBAToImVec4 ( const u32 rgba ) { return ImVec4 ( static_cast < float > ( ( rgba >> 16 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 8 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 0 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 24 ) & 0xFF ) / 255.0f ) ; }
static float DrawMessage ( int index , const Message & msg , const ImVec2 & position , int time_left ) { const std :: string window_name = fmt :: format ( " osd _ { } " , index ) ; ImGui :: SetNextWindowPos ( position ) ; ImGui :: SetNextWindowSize ( ImVec2 ( 0.0f , 0.0f ) ) ; const float alpha = std :: min ( 1.0f , std :: max ( 0.0f , time_left / 1024.0f ) ) ; ImGui :: PushStyleVar ( ImGuiStyleVar_Al@@ pha , alpha ) ; float window_height = 0.0f ; if ( ImGui :: Begin ( window_name . c_str ( ) , nullptr , ImGuiWindowFlags_NoTitle@@ Bar | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_Al@@ waysAutoResize | ImGuiWindowFlags_NoFocusOnApp@@ earing ) ) { ImGui :: TextColo@@ red ( RGBAToImVec4 ( msg . color ) , " % s " , msg . text . c_str ( ) ) ; window_height = ImGui :: GetWindowSize ( ) . y + ( WINDOW_PADDING * ImGui :: GetIO ( ) . DisplayFramebufferScale . y ) ; } ImGui :: End ( ) ; ImGui :: PopStyleVar ( ) ; return window_height ; }
void AddTyped@@ Message ( MessageType type , std :: string message , u32 ms , u32 rgba ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . erase ( type ) ; s_messages . emplace ( type , Message ( std :: move ( message ) , Common :: Timer :: GetTimeMs ( ) + ms , rgba ) ) ; }
void AddMessage ( std :: string message , u32 ms , u32 rgba ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . emplace ( MessageType :: Typeless , Message ( std :: move ( message ) , Common :: Timer :: GetTimeMs ( ) + ms , rgba ) ) ; }
void DrawMessages ( ) { if ( ! SConfig :: GetInstance ( ) . bOnScreenDisplayMessages ) return ; { std :: lock_guard lock { s_messages_mutex } ; const u32 now = Common :: Timer :: GetTimeMs ( ) ; float current_x = LEFT_MARGIN * ImGui :: GetIO ( ) . DisplayFramebufferScale . x ; float current_y = TOP_MARGIN * ImGui :: GetIO ( ) . DisplayFramebufferScale . y ; int index = 0 ; auto it = s_messages . begin ( ) ; while ( it != s_messages . end ( ) ) { const Message & msg = it -> second ; const int time_left = static_cast < int > ( msg . timestamp - now ) ; current_y += DrawMessage ( index ++ , msg , ImVec2 ( current_x , current_y ) , time_left ) ; if ( time_left <= 0 ) it = s_messages . erase ( it ) ; else ++ it ; } } }
void ClearMessages ( ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . clear ( ) ; }
boss_ormorokAI ( Creature * creature ) : BossAI ( creature , DATA_ORMO@@ ROK ) { Initialize ( ) ; }
void Initialize ( ) { frenzy = false ; }
npc_crystal_spike_triggerAI ( Creature * creature ) : ScriptedAI ( creature ) { _count = 0 ; _despawntimer = 0 ; }
void HandlePeriodic ( AuraEffect const * ) { Unit * target = GetTarget ( ) ; if ( target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_INITIAL || target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_TRIGGER ) if ( Creature * trigger = target -> ToCreature ( ) ) { uint32 spell = target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_INITIAL ? crystalSpikeSummon [ 0 ] : crystalSpikeSummon [ urand ( 0 , 2 ) ] ; if ( trigger -> AI ( ) -> GetData ( DATA_COUNT ) < MAX_COUNT ) trigger -> CastSpell ( trigger , spell , true ) ; } }
void AddSC_boss_ormorok ( ) { new boss_ormorok ( ) ; new npc_crystal_spike_trigger ( ) ; new spell_crystal_spike ( ) ; }
void initIDT ( ) { memset ( ( uint8 * ) idtEntries , 0 , sizeof ( idtEntries ) ) ; iptr . limit = sizeof ( idtEntries ) - 1 ; iptr . base = ( uint64 ) & idtEntries ; writePort ( 0x20 , 0x11 ) ; writePort ( 0xA0 , 0x11 ) ; writePort ( 0x21 , 0x20 ) ; writePort ( 0xA1 , 0x28 ) ; writePort ( 0x21 , 0x01 ) ; writePort ( 0xA1 , 0x01 ) ; writePort ( 0x21 , 0x00 ) ; writePort ( 0xA1 , 0x00 ) ; idtSetEntity ( 0 , ( uint64 ) isr0 , 0x08 , 0x8E ) ; idtSetEntity ( 1 , ( uint64 ) isr1 , 0x08 , 0x8E ) ; idtSetEntity ( 2 , ( uint64 ) isr2 , 0x08 , 0x8E ) ; idtSetEntity ( 3 , ( uint64 ) isr3 , 0x08 , 0x8E ) ; idtSetEntity ( 4 , ( uint64 ) isr4 , 0x08 , 0x8E ) ; idtSetEntity ( 5 , ( uint64 ) isr5 , 0x08 , 0x8E ) ; idtSetEntity ( 6 , ( uint64 ) isr6 , 0x08 , 0x8E ) ; idtSetEntity ( 7 , ( uint64 ) isr7 , 0x08 , 0x8E ) ; idtSetEntity ( 8 , ( uint64 ) isr8 , 0x08 , 0x8E ) ; idtSetEntity ( 9 , ( uint64 ) isr9 , 0x08 , 0x8E ) ; idtSetEntity ( 10 , ( uint64 ) isr10 , 0x08 , 0x8E ) ; idtSetEntity ( 11 , ( uint64 ) isr11 , 0x08 , 0x8E ) ; idtSetEntity ( 12 , ( uint64 ) isr12 , 0x08 , 0x8E ) ; idtSetEntity ( 13 , ( uint64 ) isr13 , 0x08 , 0x8E ) ; idtSetEntity ( 14 , ( uint64 ) isr14 , 0x08 , 0x8E ) ; idtSetEntity ( 15 , ( uint64 ) isr15 , 0x08 , 0x8E ) ; idtSetEntity ( 16 , ( uint64 ) isr16 , 0x08 , 0x8E ) ; idtSetEntity ( 17 , ( uint64 ) isr17 , 0x08 , 0x8E ) ; idtSetEntity ( 18 , ( uint64 ) isr18 , 0x08 , 0x8E ) ; idtSetEntity ( 19 , ( uint64 ) isr19 , 0x08 , 0x8E ) ; idtSetEntity ( 20 , ( uint64 ) isr20 , 0x08 , 0x8E ) ; idtSetEntity ( 21 , ( uint64 ) isr21 , 0x08 , 0x8E ) ; idtSetEntity ( 22 , ( uint64 ) isr22 , 0x08 , 0x8E ) ; idtSetEntity ( 23 , ( uint64 ) isr23 , 0x08 , 0x8E ) ; idtSetEntity ( 24 , ( uint64 ) isr24 , 0x08 , 0x8E ) ; idtSetEntity ( 25 , ( uint64 ) isr25 , 0x08 , 0x8E ) ; idtSetEntity ( 26 , ( uint64 ) isr26 , 0x08 , 0x8E ) ; idtSetEntity ( 27 , ( uint64 ) isr27 , 0x08 , 0x8E ) ; idtSetEntity ( 28 , ( uint64 ) isr27 , 0x08 , 0x8E ) ; idtSetEntity ( 29 , ( uint64 ) isr29 , 0x08 , 0x8E ) ; idtSetEntity ( 30 , ( uint64 ) isr30 , 0x08 , 0x8E ) ; idtSetEntity ( 31 , ( uint64 ) isr31 , 0x08 , 0x8E ) ; idtSetEntity ( 32 , ( uint64 ) irq0 , 0x08 , 0x8E ) ; idtSetEntity ( 33 , ( uint64 ) irq1 , 0x08 , 0x8E ) ; idtSetEntity ( 34 , ( uint64 ) irq2 , 0x08 , 0x8E ) ; idtSetEntity ( 35 , ( uint64 ) irq3 , 0x08 , 0x8E ) ; idtSetEntity ( 36 , ( uint64 ) irq4 , 0x08 , 0x8E ) ; idtSetEntity ( 37 , ( uint64 ) irq5 , 0x08 , 0x8E ) ; idtSetEntity ( 38 , ( uint64 ) irq6 , 0x08 , 0x8E ) ; idtSetEntity ( 39 , ( uint64 ) irq7 , 0x08 , 0x8E ) ; idtSetEntity ( 40 , ( uint64 ) irq8 , 0x08 , 0x8E ) ; idtSetEntity ( 41 , ( uint64 ) irq9 , 0x08 , 0x8E ) ; idtSetEntity ( 42 , ( uint64 ) irq10 , 0x08 , 0x8E ) ; idtSetEntity ( 43 , ( uint64 ) irq11 , 0x08 , 0x8E ) ; idtSetEntity ( 44 , ( uint64 ) irq12 , 0x08 , 0x8E ) ; idtSetEntity ( 45 , ( uint64 ) irq13 , 0x08 , 0x8E ) ; idtSetEntity ( 46 , ( uint64 ) irq14 , 0x08 , 0x8E ) ; idtSetEntity ( 47 , ( uint64 ) irq15 , 0x08 , 0x8E ) ; idtFlush ( ( uint64 ) & iptr ) ; printStr ( " Initializing ▁ interruption ▁ finished . \n " , color_white ) ; }
void isrHandler ( ptRegs * regs ) { if ( interruptHandler [ regs -> intNum ] ) interruptHandler [ regs -> intNum ] ( regs ) ; else { } }
void irqHandler ( ptRegs * regs ) { if ( regs -> intNum > 40 ) { writePort ( 0xA0 , 0x20 ) ; } writePort ( 0x20 , 0x20 ) ; if ( interruptHandler [ regs -> intNum ] ) { interruptHandler [ regs -> intNum ] ( regs ) ; } }
void registerInterrupt@@ Handler ( uint8 n , interruptHandler_t h ) { interruptHandler [ n ] = h ; }
void idtSetEntity ( uint8 num , uint64 base , uint16 selector , uint8 flags ) { idtEntries [ num ] . offset1 = base & 0xffff ; idtEntries [ num ] . offset2 = ( base >> 16 ) & 0xffff ; idtEntries [ num ] . offset3 = ( base >> 32 ) & 0xffffffff ; idtEntries [ num ] . selector = selector ; idtEntries [ num ] . typeAttr = flags ; }
private : bool CanBuild ( Creature * creature ) { Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return false ; switch ( creature -> GetEntry ( ) ) { case NPC_GOBLIN_MECHANIC : return ( wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_MAX_VEHICLE_H ) > wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_VEHICLE_H ) ) ; case NPC_GNOMISH_ENGINEER : return ( wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_MAX_VEHICLE_A ) > wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_VEHICLE_A ) ) ; default : return false ; } }
TEST ( ModelInstantiatorTest , BrpProb ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pdtmc / brp16_2 . pm " ; std :: string formulaAsString = " P = ? ▁ [ F ▁ s = 5 ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> dtmc = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Dtmc < storm :: RationalFunction > , storm :: models :: sparse :: Dtmc < double >> modelInstantiator ( * dtmc ) ; EXPECT_FALSE ( dtmc -> hasRewardModel ( ) ) ; { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.8 ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.29892@@ 7894@@ 1 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_EQ ( 0.0 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] ) ; } { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.015880@@ 55832 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } }
TEST ( ModelInstantiatorTest , Brp_Rew ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pdtmc / brp16_2 . pm " ; std :: string formulaAsString = " R = ? ▁ [ F ▁ ( ( s = 5 ) ▁ | ▁ ( s = 0 & srep = 3 ) ) ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> dtmc = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Dtmc < storm :: RationalFunction > , storm :: models :: sparse :: Dtmc < double >> modelInstantiator ( * dtmc ) ; { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & TOMsg = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " TOMsg " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & TOAck = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " TOAck " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.3 ) ) ) ; valuation . insert ( std :: make_pair ( TOMsg , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.3 ) ) ) ; valuation . insert ( std :: make_pair ( TOAck , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.5 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } ASSERT_TRUE ( instantiated . hasUniqueRewardModel ( ) ) ; EXPECT_FALSE ( instantiated . getUniqueRewardModel ( ) . hasStateRewards ( ) ) ; EXPECT_FALSE ( instantiated . getUniqueRewardModel ( ) . hasTransition@@ Rewards ( ) ) ; EXPECT_TRUE ( instantiated . getUniqueRewardModel ( ) . hasStateActionRewards ( ) ) ; ASSERT_TRUE ( dtmc -> getUniqueRewardModel ( ) . hasStateActionRewards ( ) ) ; std :: size_t stateActionEntries = dtmc -> getUniqueRewardModel ( ) . getStateActionRewardVector ( ) . size ( ) ; ASSERT_EQ ( stateActionEntries , instantiated . getUniqueRewardModel ( ) . getStateActionRewardVector ( ) . size ( ) ) ; for ( std :: size_t i = 0 ; i < stateActionEntries ; ++ i ) { double evaluatedValue = carl :: toDouble ( dtmc -> getUniqueRewardModel ( ) . getStateActionRewardVector ( ) [ i ] . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiated . getUniqueRewardModel ( ) . getStateActionRewardVector ( ) [ i ] ) ; } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 1.308@@ 324495 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } }
TEST ( ModelInstantiatorTest , Consensus ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pmdp / coin2_2 . nm " ; std :: string formulaAsString = " Pmin = ? ▁ [ F ▁ \ " finished \ " & \ " all _ coins _ equal _ 1 \ " ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Mdp < storm :: RationalFunction >> mdp = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Mdp < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Mdp < storm :: RationalFunction > , storm :: models :: sparse :: Mdp < double >> modelInstantiator ( * mdp ) ; std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & p1 = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " p1" ) ; ASSERT_NE ( p1 , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & p2 = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " p2" ) ; ASSERT_NE ( p2 , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( p1 , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.51 ) ) ) ; valuation . insert ( std :: make_pair ( p2 , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.49 ) ) ) ; storm :: models :: sparse :: Mdp < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < mdp -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : mdp -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( mdp -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( mdp -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseMdp@@ PrctlModelChecker < storm :: models :: sparse :: Mdp < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.35265@@ 77219 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; }
AS_API const char * asGetLibraryVersion ( ) { return ANGELSCRIPT_VERSION_STRING " ▁ DEBUG " ; return ANGELSCRIPT_VERSION_STRING ; }
AS_API const char * asGetLibraryOptions ( ) { const char * string = " ▁ " " AS _ MAX _ PORTABILITY ▁ " " AS _ DEBUG ▁ " " AS _ NO _ CLASS _ METHODS ▁ " " AS _ USE _ DOUBLE _ AS _ FLOAT ▁ " " AS _ 64BIT _ PTR ▁ " " AS _ NO _ THREADS ▁ " " AS _ NO _ ATOMIC ▁ " " AS _ WIN ▁ " " AS _ LINUX ▁ " " AS _ MAC ▁ " " AS _ BSD ▁ " " AS _ XBOX ▁ " " AS _ XBOX360 ▁ " " AS _ PSP ▁ " " AS _ PS2 ▁ " " AS _ PS3 ▁ " " AS _ DC ▁ " " AS _ GC ▁ " " AS _ WII ▁ " " AS _ IPHONE ▁ " " AS _ ANDROID ▁ " " AS _ PPC ▁ " " AS _ PPC _ 64 ▁ " " AS _ X86 ▁ " " AS _ MIPS ▁ " " AS _ SH4 ▁ " " AS _ XENON ▁ " " AS _ ARM ▁ " ; return string ; }
AS_API asIScriptEngine * asCreateScriptEngine ( asDWORD version ) { if ( ( version / 10000 ) != ( ANGELSCRIPT_VERSION / 10000 ) ) return 0 ; if ( ( version / 100 ) % 100 != ( ANGELSCRIPT_VERSION / 100 ) % 100 ) return 0 ; if ( ( version % 100 ) > ( ANGELSCRIPT_VERSION % 100 ) ) return 0 ; asASSERT ( sizeof ( asBYTE ) == 1 ) ; asASSERT ( sizeof ( asWORD ) == 2 ) ; asASSERT ( sizeof ( asDWORD ) == 4 ) ; asASSERT ( sizeof ( asQWORD ) == 8 ) ; asASSERT ( sizeof ( asPWORD ) == sizeof ( void * ) ) ; asASSERT ( sizeof ( bool ) == AS_SIZEOF_BOOL ) ; asASSERT ( true == VALUE_OF_BOO@@ LEAN_@@ TRUE ) ; asASSERT ( * ( asDWORD * ) " \x00\x01\x02\x03" == 0x00010203 ) ; asASSERT ( * ( asQWORD * ) " \x00\x01\x02\x03\x04\x05\x06\x07" == I64 ( 0x00010203040@@ 50607 ) ) ; asASSERT ( * ( asDWORD * ) " \x00\x01\x02\x03" == 0x03020100 ) ; asASSERT ( * ( asQWORD * ) " \x00\x01\x02\x03\x04\x05\x06\x07" == I64 ( 0x070605040@@ 3020100 ) ) ; return asNEW ( asCScriptEngine ) ( ) ; }
