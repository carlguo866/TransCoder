<DOCUMENT_ID="quang-@@ ha/lammp@@ s/tree/master/lib/kokkos/core@@ /src/eti/@@ OpenMP/Kokkos_@@ OpenMP_@@ ViewCopy@@ ETIInst_@@ int64_t_double_@@ LayoutStride_Ran@@ k3.cpp"> # define KOKKOS_IMPL_COMPILING_LIBRAR@@ Y true # include < Kokkos_Core . hpp > namespace Kokkos { namespace Impl { KOKKOS_IMPL_VIEWCOPY_ETI_INST ( double * * * , LayoutStride , LayoutRight , OpenMP , int64_t ) KOKKOS_IMPL_VIEWCOPY_ETI_INST ( double * * * , LayoutStride , LayoutLeft , OpenMP , int64_t ) KOKKOS_IMPL_VIEWCOPY_ETI_INST ( double * * * , LayoutStride , LayoutStride , OpenMP , int64_t ) KOKKOS_IMPL_VIEWFILL_ETI_INST ( double * * * , LayoutStride , OpenMP , int64_t ) } } </DOCUMENT>
<DOCUMENT_ID="sys@@ lover33/ct@@ ank/tree/master/java/android-sdk-@@ linux_r@@ 24.4.1_@@ src/nd@@ k-bundle_r11@@ c/sources/cxx@@ -stl/llvm-@@ libc++@@ /libcxx/test/localization@@ /locales/locale@@ .convenience@@ /conversions/conversion@@ s.buffer/p@@ backfail@@ .pass.cpp"> # include < locale > # include < codecvt > # include < fstream > # include < cassert > struct test_buf : public std :: wbuffer_convert < std :: codecvt_utf8 < wchar_t > > { typedef std :: wbuffer_convert < std :: codecvt_utf8 < wchar_t > > base ; typedef base :: char_type char_type ; typedef base :: int_type int_type ; typedef base :: traits_type traits_type ; explicit test_buf ( std :: streambuf * sb ) : base ( sb ) { } char_type * eback ( ) const { return base :: eback ( ) ; } char_type * gptr ( ) const { return base :: gptr ( ) ; } char_type * egptr ( ) const { return base :: egptr ( ) ; } void gbump ( int n ) { base :: gbump ( n ) ; } virtual int_type pbackfail ( int_type c = traits_type :: eof ( ) ) { return base :: pbackfail ( c ) ; } } ; int main ( ) { { std :: ifstream bs ( " underflow . dat " ) ; test_buf f ( bs . rdbuf ( ) ) ; assert ( f . sbumpc ( ) == L ' 1' ) ; assert ( f . sgetc ( ) == L ' 2' ) ; assert ( f . pbackfail ( L ' a ' ) == test_buf :: traits_type :: eof ( ) ) ; } { std :: fstream bs ( " underflow . dat " ) ; test_buf f ( bs . rdbuf ( ) ) ; assert ( f . sbumpc ( ) == L ' 1' ) ; assert ( f . sgetc ( ) == L ' 2' ) ; assert ( f . pbackfail ( L ' a ' ) == test_buf :: traits_type :: eof ( ) ) ; assert ( f . sbumpc ( ) == L ' 2' ) ; assert ( f . sgetc ( ) == L ' 3' ) ; } } </DOCUMENT>
<DOCUMENT_ID="sacarlson@@ /MultiCoin-exp@@ /tree/master/src/db.cpp"> # include " headers . h " # include " db . h " # include " net . h " # include " auxpow . h " # include < boost / filesystem . hpp > # include < boost / filesystem / fstream . hpp > using namespace std ; using namespace boost ; unsigned int nWalletDBUpdated ; uint64 nAccountingEntryNumber = 0 ; static CCritic@@ alSection cs_db ; static bool fDbEnvInit = false ; DbEnv dbenv ( 0 ) ; static map < string , int > mapFileUseCount ; static map < string , Db * > mapDb ; class CDBInit { public : CDBInit ( ) { } ~ CDBInit ( ) { if ( fDbEnvInit ) { dbenv . close ( 0 ) ; fDbEnvInit = false ; } } } instance_of@@ _cdbinit ; CDB :: CDB ( const char * pszFile , const char * pszMode ) : pdb ( NULL ) { int ret ; if ( pszFile == NULL ) return ; fReadOnly = ( ! strchr ( pszMode , ' + ' ) && ! strchr ( pszMode , ' w ' ) ) ; bool fCreate = strchr ( pszMode , ' c ' ) ; unsigned int nFlags = DB_THREAD ; if ( fCreate ) nFlags |= DB_CREATE ; CRITICAL_BLOCK ( cs_db ) { if ( ! fDbEnvInit ) { if ( fShutdown ) return ; string strDataDir = GetDataDir ( ) ; string strLogDir = strDataDir + " / database " ; filesystem :: create_di@@ rectory ( strLogDir . c_str ( ) ) ; string strErrorFile = strDataDir + " / db . log " ; printf ( " dbenv . open ▁ strLogDir = % s ▁ strErrorFile = % s \n " , strLogDir . c_str ( ) , strErrorFile . c_str ( ) ) ; dbenv . set_lg_dir ( strLogDir . c_str ( ) ) ; dbenv . set_lg_max ( 10000000 ) ; dbenv . set_lk_max_locks ( 10000 ) ; dbenv . set_lk_max_objects ( 10000 ) ; dbenv . set_errfile ( fopen ( strErrorFile . c_str ( ) , " a " ) ) ; dbenv . set_flags ( DB_AUTO@@ _COMMIT , 1 ) ; ret = dbenv . open ( strDataDir . c_str ( ) , DB_CREATE | DB_INIT_LOCK | DB_INIT_LOG | DB_INIT_MPOO@@ L | DB_INIT_TXN | DB_THREAD | DB_REC@@ OVER , S_IRUSR | S_IWUSR ) ; if ( ret > 0 ) throw runtime_error ( strprintf ( " CDB ( ) ▁ : ▁ error ▁ % d ▁ opening ▁ database ▁ environment " , ret ) ) ; fDbEnvInit = true ; } strFile = pszFile ; ++ mapFileUseCount [ strFile ] ; pdb = mapDb [ strFile ] ; if ( pdb == NULL ) { pdb = new Db ( & dbenv , 0 ) ; ret = pdb -> open ( NULL , pszFile , " main " , DB_BTRE@@ E , nFlags , 0 ) ; if ( ret > 0 ) { delete pdb ; pdb = NULL ; CRITICAL_BLOCK ( cs_db ) -- mapFileUseCount [ strFile ] ; strFile = " " ; throw runtime_error ( strprintf ( " CDB ( ) ▁ : ▁ can ' t ▁ open ▁ database ▁ file ▁ % s , ▁ error ▁ % d " , pszFile , ret ) ) ; } if ( fCreate && ! Exists ( string ( " version " ) ) ) { bool fTmp = fReadOnly ; fReadOnly = false ; WriteVersion ( VERSION ) ; fReadOnly = fTmp ; } mapDb [ strFile ] = pdb ; } } } void CDB :: Close ( ) { if ( ! pdb ) return ; if ( ! vTxn . empty ( ) ) vTxn . front ( ) -> abort ( ) ; vTxn . clear ( ) ; pdb = NULL ; unsigned int nMinutes = 0 ; if ( fReadOnly ) nMinutes = 1 ; if ( strFile == " addr . dat " ) nMinutes = 2 ; if ( strFile == " blkindex . dat " && IsInitial@@ BlockDown@@ load ( ) && nBestHeight % 500 != 0 ) nMinutes = 1 ; dbenv . txn_checkpoint ( 0 , nMinutes , 0 ) ; CRITICAL_BLOCK ( cs_db ) -- mapFileUseCount [ strFile ] ; } void static CloseDb ( const string & strFile ) { CRITICAL_BLOCK ( cs_db ) { if ( mapDb [ strFile ] != NULL ) { Db * pdb = mapDb [ strFile ] ; pdb -> close ( 0 ) ; delete pdb ; mapDb [ strFile ] = NULL ; } } } void DBFlush ( bool fShutdown ) { printf ( " DBFlush ( % s ) % s \n " , fShutdown ? " true " : " false " , fDbEnvInit ? " " : " ▁ db ▁ not ▁ started " ) ; if ( ! fDbEnvInit ) return ; CRITICAL_BLOCK ( cs_db ) { map < string , int > :: iterator mi = mapFileUseCount . begin ( ) ; while ( mi != mapFileUseCount . end ( ) ) { string strFile = ( * mi ) . first ; int nRefCount = ( * mi ) . second ; printf ( " % s ▁ refcount = % d \n " , strFile . c_str ( ) , nRefCount ) ; if ( nRefCount == 0 ) { CloseDb ( strFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; printf ( " % s ▁ flush \n " , strFile . c_str ( ) ) ; dbenv . lsn_reset ( strFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( mi ++ ) ; } else mi ++ ; } if ( fShutdown ) { char * * listp ; if ( mapFileUseCount . empty ( ) ) dbenv . log_arch@@ ive ( & listp , DB_AR@@ CH_REMOVE ) ; dbenv . close ( 0 ) ; fDbEnvInit = false ; } } } bool CTxDB :: ReadTxIndex ( uint256 hash , CTxIndex & txindex ) { assert ( ! fClient ) ; txindex . SetNull ( ) ; return Read ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; } bool CTxDB :: UpdateTxIndex ( uint256 hash , const CTxIndex & txindex ) { assert ( ! fClient ) ; return Write ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; } bool CTxDB :: AddTxIndex ( const CTransaction & tx , const CDiskTxPos & pos , int nHeight ) { assert ( ! fClient ) ; uint256 hash = tx . GetHash ( ) ; CTxIndex txindex ( pos , tx . vout . size ( ) ) ; return Write ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; } bool CTxDB :: EraseTxIndex ( const CTransaction & tx ) { assert ( ! fClient ) ; uint256 hash = tx . GetHash ( ) ; return Erase ( make_pair ( string ( " tx " ) , hash ) ) ; } bool CTxDB :: ContainsTx ( uint256 hash ) { assert ( ! fClient ) ; return Exists ( make_pair ( string ( " tx " ) , hash ) ) ; } bool CTxDB :: ReadOwner@@ Txes ( uint160 hash160 , int nMinHeight , vector < CTransaction > & vtx ) { assert ( ! fClient ) ; vtx . clear ( ) ; Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; unsigned int fFlags = DB_SET_RANGE ; loop { CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << string ( " owner " ) << hash160 << CDiskTxPos ( 0 , 0 , 0 ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) { pcursor -> close ( ) ; return false ; } string strType ; uint160 hashItem ; CDiskTxPos pos ; ssKey >> strType >> hashItem >> pos ; int nItemHeight ; ssValue >> nItemHeight ; if ( strType != " owner " || hashItem != hash160 ) break ; if ( nItemHeight >= nMinHeight ) { vtx . resize ( vtx . size ( ) + 1 ) ; if ( ! vtx . back ( ) . ReadFromDisk ( pos ) ) { pcursor -> close ( ) ; return false ; } } } pcursor -> close ( ) ; return true ; } bool CTxDB :: ReadDiskTx ( uint256 hash , CTransaction & tx , CTxIndex & txindex ) { assert ( ! fClient ) ; tx . SetNull ( ) ; if ( ! ReadTxIndex ( hash , txindex ) ) return false ; return ( tx . ReadFromDisk ( txindex . pos ) ) ; } bool CTxDB :: ReadDiskTx ( uint256 hash , CTransaction & tx ) { CTxIndex txindex ; return ReadDiskTx ( hash , tx , txindex ) ; } bool CTxDB :: ReadDiskTx ( COutPoint outpoint , CTransaction & tx , CTxIndex & txindex ) { return ReadDiskTx ( outpoint . hash , tx , txindex ) ; } bool CTxDB :: ReadDiskTx ( COutPoint outpoint , CTransaction & tx ) { CTxIndex txindex ; return ReadDiskTx ( outpoint . hash , tx , txindex ) ; } bool CTxDB :: WriteBlockIndex ( const CDiskBlockIndex & blockindex ) { return Write ( make_pair ( string ( " blockindex " ) , blockindex . GetBlockHash ( ) ) , blockindex ) ; } bool CTxDB :: EraseBlockIndex ( uint256 hash ) { return Erase ( make_pair ( string ( " blockindex " ) , hash ) ) ; } bool CTxDB :: ReadHashBestChain ( uint256 & hashBestChain ) { return Read ( string ( " hashBestChain " ) , hashBestChain ) ; } bool CTxDB :: WriteHashBestChain ( uint256 hashBestChain ) { return Write ( string ( " hashBestChain " ) , hashBestChain ) ; } bool CTxDB :: ReadBestInvalidWork ( CBigNum & bnBestInvalidWork ) { return Read ( string ( " bnBestInvalidWork " ) , bnBestInvalidWork ) ; } bool CTxDB :: WriteBestInvalidWork ( CBigNum bnBestInvalidWork ) { return Write ( string ( " bnBestInvalidWork " ) , bnBestInvalidWork ) ; } CBlockIndex static * InsertBlockIndex ( uint256 hash ) { if ( hash == 0 ) return NULL ; map < uint256 , CBlockIndex * > :: iterator mi = mapBlockIndex . find ( hash ) ; if ( mi != mapBlockIndex . end ( ) ) return ( * mi ) . second ; CBlockIndex * pindexNew = new CBlockIndex ( ) ; if ( ! pindexNew ) throw runtime_error ( " LoadBlockIndex ( ) ▁ : ▁ new ▁ CBlockIndex ▁ failed " ) ; mi = mapBlockIndex . insert ( make_pair ( hash , pindexNew ) ) . first ; pindexNew -> phashBlock = & ( ( * mi ) . first ) ; return pindexNew ; } bool CTxDB :: LoadBlockIndex ( ) { Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; unsigned int fFlags = DB_SET_RANGE ; loop { CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << make_pair ( string ( " blockindex " ) , uint256 ( 0 ) ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; string strType ; ssKey >> strType ; if ( strType == " blockindex " ) { CDiskBlockIndex diskindex ; ssValue >> diskindex ; CBlockIndex * pindexNew = InsertBlockIndex ( diskindex . GetBlockHash ( ) ) ; pindexNew -> pprev = InsertBlockIndex ( diskindex . hashPrev ) ; pindexNew -> pnext = InsertBlockIndex ( diskindex . hashNext ) ; pindexNew -> nFile = diskindex . nFile ; pindexNew -> nBlockPos = diskindex . nBlockPos ; pindexNew -> nHeight = diskindex . nHeight ; pindexNew -> nVersion = diskindex . nVersion ; pindexNew -> hashMerkleRoot = diskindex . hashMerkleRoot ; pindexNew -> nTime = diskindex . nTime ; pindexNew -> nBits = diskindex . nBits ; pindexNew -> nNonce = diskindex . nNonce ; pindexNew -> auxpow = diskindex . auxpow ; if ( pindexGenesisBlock == NULL && diskindex . GetBlockHash ( ) == hashGenesisBlock ) pindexGenesisBlock = pindexNew ; if ( ! pindexNew -> CheckIndex ( ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ CheckIndex ▁ failed ▁ at ▁ % d " , pindexNew -> nHeight ) ; } else { break ; } } pcursor -> close ( ) ; vector < pair < int , CBlockIndex * > > vSortedByHeight ; vSortedByHeight . reserve ( mapBlockIndex . size ( ) ) ; BOOST_FOREACH ( const PAIRTYPE ( uint256 , CBlockIndex * ) & item , mapBlockIndex ) { CBlockIndex * pindex = item . second ; vSortedByHeight . push_back ( make_pair ( pindex -> nHeight , pindex ) ) ; } sort ( vSortedByHeight . begin ( ) , vSortedByHeight . end ( ) ) ; BOOST_FOREACH ( const PAIRTYPE ( int , CBlockIndex * ) & item , vSortedByHeight ) { CBlockIndex * pindex = item . second ; pindex -> bnChainWork = ( pindex -> pprev ? pindex -> pprev -> bnChainWork : 0 ) + pindex -> GetBlockWork ( ) ; } if ( ! ReadHashBestChain ( hashBestChain ) ) { if ( pindexGenesisBlock == NULL ) return true ; return error ( " CTxDB : : LoadBlockIndex ( ) ▁ : ▁ hashBestChain ▁ not ▁ loaded " ) ; } if ( ! mapBlockIndex . count ( hashBestChain ) ) return error ( " CTxDB : : LoadBlockIndex ( ) ▁ : ▁ hashBestChain ▁ not ▁ found ▁ in ▁ the ▁ block ▁ index " ) ; pindexBest = mapBlockIndex [ hashBestChain ] ; nBestHeight = pindexBest -> nHeight ; bnBestChainWork = pindexBest -> bnChainWork ; printf ( " LoadBlockIndex ( ) : ▁ hashBestChain = % s ▁ ▁ height = % d \n " , hashBestChain . ToString ( ) . substr ( 0 , 20 ) . c_str ( ) , nBestHeight ) ; ReadBestInvalidWork ( bnBestInvalidWork ) ; CBlockIndex * pindexFork = NULL ; for ( CBlockIndex * pindex = pindexBest ; pindex && pindex -> pprev ; pindex = pindex -> pprev ) { if ( pindex -> nHeight < nBestHeight - 2500 && ! mapArgs . count ( " - checkblock@@ s " ) ) break ; CBlock block ; if ( ! block . ReadFromDisk ( pindex ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ block . ReadFromDisk ▁ failed " ) ; if ( ! block . CheckBlock ( pindex -> nHeight ) ) { printf ( " LoadBlockIndex ( ) ▁ : ▁ * * * ▁ found ▁ bad ▁ block ▁ at ▁ % d , ▁ hash = % s \n " , pindex -> nHeight , pindex -> GetBlockHash ( ) . ToString ( ) . c_str ( ) ) ; pindexFork = pindex -> pprev ; } } if ( pindexFork ) { printf ( " LoadBlockIndex ( ) ▁ : ▁ * * * ▁ moving ▁ best ▁ chain ▁ pointer ▁ back ▁ to ▁ block ▁ % d \n " , pindexFork -> nHeight ) ; CBlock block ; if ( ! block . ReadFromDisk ( pindexFork ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ block . ReadFromDisk ▁ failed " ) ; CTxDB txdb ; block . SetBestChain ( txdb , pindexFork ) ; } return true ; } bool CAddrDB :: WriteAddress ( const CAddress & addr ) { return Write ( make_pair ( string ( " addr " ) , addr . GetKey ( ) ) , addr ) ; } bool CAddrDB :: EraseAddress ( const CAddress & addr ) { return Erase ( make_pair ( string ( " addr " ) , addr . GetKey ( ) ) ) ; } bool CAddrDB :: LoadAddresses ( ) { CRITICAL_BLOCK ( cs_mapAddresses ) { CAutoFile filein = fopen ( ( GetDataDir ( ) + " / addr . txt " ) . c_str ( ) , " rt " ) ; if ( filein ) { try { char psz [ 1000 ] ; while ( fgets ( psz , sizeof ( psz ) , filein ) ) { CAddress addr ( psz , NODE_NETWORK ) ; addr . nTime = 0 ; if ( addr . IsValid ( ) ) AddAddress ( addr ) ; } } catch ( ... ) { } } Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; loop { CDataStream ssKey ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue ) ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; string strType ; ssKey >> strType ; if ( strType == " addr " ) { CAddress addr ; ssValue >> addr ; mapAddresses . insert ( make_pair ( addr . GetKey ( ) , addr ) ) ; } } pcursor -> close ( ) ; printf ( " Loaded ▁ % d ▁ addresses \n " , mapAddresses . size ( ) ) ; } return true ; } bool LoadAddresses ( ) { return CAddrDB ( " cr + " ) . LoadAddresses ( ) ; } bool CWalletDB :: WriteName ( const string & strAddress , const string & strName ) { nWalletDBUpdated ++ ; return Write ( make_pair ( string ( " name " ) , strAddress ) , strName ) ; } bool CWalletDB :: EraseName ( const string & strAddress ) { nWalletDBUpdated ++ ; return Erase ( make_pair ( string ( " name " ) , strAddress ) ) ; } bool CWalletDB :: ReadAccount ( const string & strAccount , CAccount & account ) { account . SetNull ( ) ; return Read ( make_pair ( string ( " acc " ) , strAccount ) , account ) ; } bool CWalletDB :: WriteAccount ( const string & strAccount , const CAccount & account ) { return Write ( make_pair ( string ( " acc " ) , strAccount ) , account ) ; } bool CWalletDB :: WriteAccountingEntry ( const CAccountingEntry & acentry ) { return Write ( make_tuple ( string ( " acentry " ) , acentry . strAccount , ++ nAccountingEntryNumber ) , acentry ) ; } int64 CWalletDB :: GetAccountCreditDebit ( const string & strAccount ) { list < CAccountingEntry > entries ; ListAccountCreditDebit ( strAccount , entries ) ; int64 nCreditDebit = 0 ; BOOST_FOREACH ( const CAccountingEntry & entry , entries ) nCreditDebit += entry . nCreditDebit ; return nCreditDebit ; } void CWalletDB :: ListAccountCreditDebit ( const string & strAccount , list < CAccountingEntry > & entries ) { int64 nCreditDebit = 0 ; bool fAllAccounts = ( strAccount == " * " ) ; Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) throw runtime_error ( " CWalletDB : : ListAccountCreditDebit ( ) ▁ : ▁ cannot ▁ create ▁ DB ▁ cursor " ) ; unsigned int fFlags = DB_SET_RANGE ; loop { CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << make_tuple ( string ( " acentry " ) , ( fAllAccounts ? string ( " " ) : strAccount ) , uint64 ( 0 ) ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) { pcursor -> close ( ) ; throw runtime_error ( " CWalletDB : : ListAccountCreditDebit ( ) ▁ : ▁ error ▁ scanning ▁ DB " ) ; } string strType ; ssKey >> strType ; if ( strType != " acentry " ) break ; CAccountingEntry acentry ; ssKey >> acentry . strAccount ; if ( ! fAllAccounts && acentry . strAccount != strAccount ) break ; ssValue >> acentry ; entries . push_back ( acentry ) ; } pcursor -> close ( ) ; } bool CWalletDB :: LoadWallet ( CWallet * pwallet ) { pwallet -> vchDefaultKey . clear ( ) ; int nFileVersion = 0 ; vector < uint256 > vWalletUpgrade ; # ifndef __WXMSW__ fMinimizeToTray = false ; fMinimizeOnClose = false ; # endif CRITICAL_BLOCK ( pwallet -> cs_mapWallet ) CRITICAL_BLOCK ( pwallet -> cs_mapKeys ) { Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; loop { CDataStream ssKey ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue ) ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; string strType ; ssKey >> strType ; if ( strType == " name " ) { string strAddress ; ssKey >> strAddress ; ssValue >> pwallet -> mapAddress@@ Book [ strAddress ] ; } else if ( strType == " tx " ) { uint256 hash ; ssKey >> hash ; CWalletTx & wtx = pwallet -> mapWallet [ hash ] ; ssValue >> wtx ; wtx . pwallet = pwallet ; if ( wtx . GetHash ( ) != hash ) printf ( " Error ▁ in ▁ wallet . dat , ▁ hash ▁ mismatch \n " ) ; if ( 31404 <= wtx . fTimeReceivedIsTxTime && wtx . fTimeReceivedIsTxTime <= 31703 ) { if ( ! ssValue . empty ( ) ) { char fTmp ; char fUnused ; ssValue >> fTmp >> fUnused >> wtx . strFromAccount ; printf ( " LoadWallet ( ) ▁ upgrading ▁ tx ▁ ver = % d ▁ % d ▁ ' % s ' ▁ % s \n " , wtx . fTimeReceivedIsTxTime , fTmp , wtx . strFromAccount . c_str ( ) , hash . ToString ( ) . c_str ( ) ) ; wtx . fTimeReceivedIsTxTime = fTmp ; } else { printf ( " LoadWallet ( ) ▁ repairing ▁ tx ▁ ver = % d ▁ % s \n " , wtx . fTimeReceivedIsTxTime , hash . ToString ( ) . c_str ( ) ) ; wtx . fTimeReceivedIsTxTime = 0 ; } vWalletUpgrade . push_back ( hash ) ; } } else if ( strType == " acentry " ) { string strAccount ; ssKey >> strAccount ; uint64 nNumber ; ssKey >> nNumber ; if ( nNumber > nAccountingEntryNumber ) nAccountingEntryNumber = nNumber ; } else if ( strType == " key " || strType == " wkey " ) { vector < unsigned char > vchPubKey ; ssKey >> vchPubKey ; CWalletKey wkey ; if ( strType == " key " ) ssValue >> wkey . vchPrivKey ; else ssValue >> wkey ; pwallet -> mapKeys [ vchPubKey ] = wkey . vchPrivKey ; mapPubKeys [ Hash160 ( vchPubKey ) ] = vchPubKey ; } else if ( strType == " defaultkey " ) { ssValue >> pwallet -> vchDefaultKey ; } else if ( strType == " pool " ) { int64 nIndex ; ssKey >> nIndex ; pwallet -> setKeyPool . insert ( nIndex ) ; } else if ( strType == " version " ) { ssValue >> nFileVersion ; if ( nFileVersion == 10300 ) nFileVersion = 300 ; } else if ( strType == " setting " ) { string strKey ; ssKey >> strKey ; # ifndef GUI if ( strKey == " fGenerateBitcoins " ) ssValue >> fGenerateBitcoins ; # endif if ( strKey == " nTransactionFee " ) ssValue >> nTransactionFee ; if ( strKey == " addrIncoming " ) ssValue >> addrIncoming ; if ( strKey == " fLimitProcessors " ) ssValue >> fLimitProcessors ; if ( strKey == " nLimitProcessors " ) ssValue >> nLimitProcessors ; if ( strKey == " fMinimizeToTray " ) ssValue >> fMinimizeToTray ; if ( strKey == " fMinimizeOnClose " ) ssValue >> fMinimizeOnClose ; if ( strKey == " fUseProxy " ) ssValue >> fUseProxy ; if ( strKey == " addrProxy " ) ssValue >> addrProxy ; if ( fHaveUPnP && strKey == " fUseUPnP " ) ssValue >> fUseUPnP ; } } pcursor -> close ( ) ; } BOOST_FOREACH ( uint256 hash , vWalletUpgrade ) WriteTx ( hash , pwallet -> mapWallet [ hash ] ) ; printf ( " nFileVersion ▁ = ▁ % d \n " , nFileVersion ) ; printf ( " fGenerateBitcoins ▁ = ▁ % d \n " , fGenerateBitcoins ) ; printf ( " nTransactionFee ▁ = ▁ % " PRI64d " \n " , nTransactionFee ) ; printf ( " addrIncoming ▁ = ▁ % s \n " , addrIncoming . ToString ( ) . c_str ( ) ) ; printf ( " fMinimizeToTray ▁ = ▁ % d \n " , fMinimizeToTray ) ; printf ( " fMinimizeOnClose ▁ = ▁ % d \n " , fMinimizeOnClose ) ; printf ( " fUseProxy ▁ = ▁ % d \n " , fUseProxy ) ; printf ( " addrProxy ▁ = ▁ % s \n " , addrProxy . ToString ( ) . c_str ( ) ) ; if ( fHaveUPnP ) printf ( " fUseUPnP ▁ = ▁ % d \n " , fUseUPnP ) ; if ( nFileVersion < VERSION ) { if ( nFileVersion <= 105 && ! pszSetDataDir [ 0 ] ) unlink ( " debug . log " ) ; WriteVersion ( VERSION ) ; } return true ; } void ThreadFlush@@ WalletDB ( void * parg ) { const string & strFile = ( ( const string * ) parg ) [ 0 ] ; static bool fOneThread ; if ( fOneThread ) return ; fOneThread = true ; if ( mapArgs . count ( " - noflushwallet " ) ) return ; unsigned int nLastSeen = nWalletDBUpdated ; unsigned int nLastFlushed = nWalletDBUpdated ; int64 nLastWalletUpdate = GetTime ( ) ; while ( ! fShutdown ) { Sleep ( 500 ) ; if ( nLastSeen != nWalletDBUpdated ) { nLastSeen = nWalletDBUpdated ; nLastWalletUpdate = GetTime ( ) ; } if ( nLastFlushed != nWalletDBUpdated && GetTime ( ) - nLastWalletUpdate >= 2 ) { TRY_CRITICAL_BLOCK ( cs_db ) { int nRefCount = 0 ; map < string , int > :: iterator mi = mapFileUseCount . begin ( ) ; while ( mi != mapFileUseCount . end ( ) ) { nRefCount += ( * mi ) . second ; mi ++ ; } if ( nRefCount == 0 && ! fShutdown ) { map < string , int > :: iterator mi = mapFileUseCount . find ( strFile ) ; if ( mi != mapFileUseCount . end ( ) ) { printf ( " % s ▁ " , DateTimeStrFormat ( " % x ▁ % H : % M : % S " , GetTime ( ) ) . c_str ( ) ) ; printf ( " Flushing ▁ wallet . dat \n " ) ; nLastFlushed = nWalletDBUpdated ; int64 nStart = GetTimeMillis ( ) ; CloseDb ( strFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; dbenv . lsn_reset ( strFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( mi ++ ) ; printf ( " Flushed ▁ wallet . dat ▁ % " PRI64d " ms \n " , GetTimeMillis ( ) - nStart ) ; } } } } } } bool BackupWallet ( const CWallet & wallet , const string & strDest ) { if ( ! wallet . fFileBacked ) return false ; while ( ! fShutdown ) { CRITICAL_BLOCK ( cs_db ) { if ( ! mapFileUseCount . count ( wallet . strWalletFile ) || mapFileUseCount [ wallet . strWalletFile ] == 0 ) { CloseDb ( wallet . strWalletFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; dbenv . lsn_reset ( wallet . strWalletFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( wallet . strWalletFile ) ; filesystem :: path pathSrc ( GetDataDir ( ) + " / " + wallet . strWalletFile ) ; filesystem :: path pathDest ( strDest ) ; if ( filesystem :: is_directory ( pathDest ) ) pathDest = pathDest / wallet . strWalletFile ; # if BOOST_VERSION >= 104000 filesystem :: copy_file ( pathSrc , pathDest , filesystem :: copy_option :: overwrite_@@ if_exists ) ; # else filesystem :: copy_file ( pathSrc , pathDest ) ; # endif printf ( " copied ▁ wallet . dat ▁ to ▁ % s \n " , pathDest . string ( ) . c_str ( ) ) ; return true ; } } Sleep ( 100 ) ; } return false ; } </DOCUMENT>
<DOCUMENT_ID="android@@ -ia/platform_external_@@ chromium_@@ org_third_part@@ y_WebK@@ it/tree/master/Source/core/dom/@@ PseudoElement.cpp"> # include " config . h " # include " core / dom / PseudoElement . h " # include " core / inspector / InspectorInstrumentation . h " # include " core / rendering / RenderObject . h " # include " core / rendering / RenderQuote . h " # include " core / rendering / style / ContentData . h " namespace blink { const QualifiedName & pseudoElementTagName ( PseudoId pseudoId ) { switch ( pseudoId ) { case AFTER : { DEFINE_STATIC_LOCAL ( QualifiedName , after , ( nullAtom , " < pseudo : after > " , nullAtom ) ) ; return after ; } case BEFORE : { DEFINE_STATIC_LOCAL ( QualifiedName , before , ( nullAtom , " < pseudo : before > " , nullAtom ) ) ; return before ; } case BACKDROP : { DEFINE_STATIC_LOCAL ( QualifiedName , backdrop , ( nullAtom , " < pseudo : backdrop > " , nullAtom ) ) ; return backdrop ; } default : { ASSERT_NOT_REACHED ( ) ; } } DEFINE_STATIC_LOCAL ( QualifiedName , name , ( nullAtom , " < pseudo > " , nullAtom ) ) ; return name ; } String PseudoElement :: pseudoElementNameFor@@ Events ( PseudoId pseudoId ) { DEFINE_STATIC_LOCAL ( const String , after , ( " : : after " ) ) ; DEFINE_STATIC_LOCAL ( const String , before , ( " : : before " ) ) ; switch ( pseudoId ) { case AFTER : return after ; case BEFORE : return before ; default : return emptyString ( ) ; } } PseudoElement :: PseudoElement ( Element * parent , PseudoId pseudoId ) : Element ( pseudoElementTagName ( pseudoId ) , & parent -> document ( ) , CreateElement ) , m_pseudoId ( pseudoId ) { ASSERT ( pseudoId != NOPSEUD@@ O ) ; setParentOrShadowHostNode ( parent ) ; setHasCustomStyleCallbacks ( ) ; } PassRefPtr < RenderStyle > PseudoElement :: customStyleFor@@ Renderer ( ) { return parentOrShadowHostElement ( ) -> renderer ( ) -> getCachedPseudoStyle ( m_pseudoId ) ; } void PseudoElement :: dispose ( ) { ASSERT ( parentOrShadowHostElement ( ) ) ; InspectorInstrumentation :: pseudoElementDestroyed ( this ) ; ASSERT ( ! nextSibling ( ) ) ; ASSERT ( ! previousSibling ( ) ) ; detach ( ) ; RefPtrWillBeRawPtr < Element > parent = parentOrShadowHostElement ( ) ; setParentOrShadowHostNode ( 0 ) ; removedFrom ( parent . get ( ) ) ; } void PseudoElement :: attach ( const AttachContext & context ) { ASSERT ( ! renderer ( ) ) ; Element :: attach ( context ) ; RenderObject * renderer = this -> renderer ( ) ; if ( ! renderer ) return ; RenderStyle * style = renderer -> style ( ) ; if ( style -> styleType ( ) != BEFORE && style -> styleType ( ) != AFTER ) return ; ASSERT ( style -> contentData ( ) ) ; for ( const ContentData * content = style -> contentData ( ) ; content ; content = content -> next ( ) ) { RenderObject * child = content -> createRenderer ( document ( ) , style ) ; if ( renderer -> isChildAllow@@ ed ( child , style ) ) { renderer -> addChild ( child ) ; if ( child -> isQuote ( ) ) toRenderQuote ( child ) -> attachQuote ( ) ; } else child -> destroy ( ) ; } } bool PseudoElement :: rendererIsNeeded ( const RenderStyle & style ) { return pseudoElementRendererIsNeeded ( & style ) ; } void PseudoElement :: didRecalcStyle ( StyleRecalcChange ) { if ( ! renderer ( ) ) return ; RenderObject * renderer = this -> renderer ( ) ; for ( RenderObject * child = renderer -> nextInPreOrder ( renderer ) ; child ; child = child -> nextInPreOrder ( renderer ) ) { if ( ! child -> isText ( ) && ! child -> isQuote ( ) && ! child -> isImage ( ) ) continue ; if ( child -> style ( ) -> styleType ( ) == FIRST_LET@@ TER ) continue ; child -> setPseudoStyle ( renderer -> style ( ) ) ; } } } </DOCUMENT>
<DOCUMENT_ID="Char@@ lieMarshall/@@ xbmc/tree/master/xbmc/cores/d@@ vdplay@@ er/DVD@@ Subtitles/DVDSubtitleTagMicro@@ DVD.cpp"> # include " DVDSubtitleTagMicroDVD . h " # include " DVDCodecs / Overlay / DVDOverlayText . h " # include " utils / StdString . h " # include " utils / StringUtils . h " void CDVDSubtitleTagMicro@@ DVD :: ConvertLine ( CDVDOverlayText * pOverlay , const char * line , int len ) { CStdString strUTF8 ; strUTF8 . assign ( line , len ) ; m_flag [ FLAG_BOLD ] = 0 ; m_flag [ FLAG_ITALIC ] = 0 ; m_flag [ FLAG_COLOR ] = 0 ; int machine_status = 1 ; size_t pos = 0 ; while ( machine_status > 0 ) { if ( machine_status == 1 ) { if ( strUTF8 [ pos ] == ' { ' ) { size_t pos2 , pos3 ; if ( ( ( pos2 = strUTF8 . find ( ' : ' , pos ) ) != CStdString :: npos ) && ( ( pos3 = strUTF8 . find ( ' } ' , pos2 ) ) != CStdString :: npos ) ) { CStdString tagName = strUTF8 . substr ( pos + 1 , pos2 - pos - 1 ) ; CStdString tagValue = strUTF8 . substr ( pos2 + 1 , pos3 - pos2 - 1 ) ; StringUtils :: ToLower ( tagValue ) ; strUTF8 . erase ( pos , pos3 - pos + 1 ) ; if ( ( tagName == " Y " ) || ( tagName == " y " ) ) { if ( ( tagValue == " b " ) && ( m_flag [ FLAG_BOLD ] == 0 ) ) { m_flag [ FLAG_BOLD ] = ( tagName == " Y " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , " [ B ] " ) ; pos += 3 ; } else if ( ( tagValue == " i " ) && ( m_flag [ FLAG_ITALIC ] == 0 ) ) { m_flag [ FLAG_ITALIC ] = ( tagName == " Y " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , " [ I ] " ) ; pos += 3 ; } } else if ( ( tagName == " C " ) || ( tagName == " c " ) ) { if ( ( tagValue [ 0 ] == ' $ ' ) && ( tagValue . size ( ) == 7 ) ) { bool bHex = true ; for ( int i = 1 ; i < 7 ; i ++ ) { char temp = tagValue [ i ] ; if ( ! ( ( '0' <= temp && temp <= '9' ) || ( ' a ' <= temp && temp <= ' f ' ) || ( ' A ' <= temp && temp <= ' F ' ) ) ) { bHex = false ; break ; } } if ( bHex && ( m_flag [ FLAG_COLOR ] == 0 ) ) { CStdString tempColorTag = " [ COLOR ▁ " ; tempColorTag += " FF " ; tempColorTag += tagValue . substr ( 1 , 6 ) ; tempColorTag += " ] " ; m_flag [ FLAG_COLOR ] = ( tagName == " C " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , tempColorTag ) ; pos += tempColorTag . length ( ) ; } } } } else machine_status = 2 ; } else if ( strUTF8 [ pos ] == ' / ' ) { if ( m_flag [ FLAG_ITALIC ] == 0 ) { m_flag [ FLAG_ITALIC ] = TAG_ONE_LINE ; strUTF8 . replace ( pos , 1 , " [ I ] " ) ; pos += 3 ; } else strUTF8 . erase ( pos , 1 ) ; } else machine_status = 2 ; } else if ( machine_status == 2 ) { size_t pos4 ; if ( ( pos4 = strUTF8 . find ( ' | ' , pos ) ) != CStdString :: npos ) { pos = pos4 ; if ( m_flag [ FLAG_BOLD ] == TAG_ONE_LINE ) { m_flag [ FLAG_BOLD ] = 0 ; strUTF8 . insert ( pos , " [ / B ] " ) ; pos += 4 ; } if ( m_flag [ FLAG_ITALIC ] == TAG_ONE_LINE ) { m_flag [ FLAG_ITALIC ] = 0 ; strUTF8 . insert ( pos , " [ / I ] " ) ; pos += 4 ; } if ( m_flag [ FLAG_COLOR ] == TAG_ONE_LINE ) { m_flag [ FLAG_COLOR ] = 0 ; strUTF8 . insert ( pos , " [ / COLOR ] " ) ; pos += 8 ; } strUTF8 . replace ( pos , 1 , " [ CR ] " ) ; pos += 4 ; machine_status = 1 ; } else { if ( m_flag [ FLAG_BOLD ] != 0 ) strUTF8 . append ( " [ / B ] " ) ; if ( m_flag [ FLAG_ITALIC ] != 0 ) strUTF8 . append ( " [ / I ] " ) ; if ( m_flag [ FLAG_COLOR ] != 0 ) strUTF8 . append ( " [ / COLOR ] " ) ; machine_status = 0 ; } } } if ( strUTF8 . empty ( ) ) return ; if ( strUTF8 [ strUTF8 . size ( ) - 1 ] == ' \n ' ) strUTF8 . erase ( strUTF8 . size ( ) - 1 ) ; pOverlay -> AddElement ( new CDVDOverlayText :: CElementText ( strUTF8 . c_str ( ) ) ) ; } </DOCUMENT>
<DOCUMENT_ID="Si@@ ja/swift/tree/master/Tests/@@ Source/TestValue@@ Bool.cpp"> # include " stdafx . h " # include < cppunit / extensions / HelperMacros . h > # include " . . / . . / Source / stdafx . h " # include " . . / . . / Source / values / Bool . h " using namespace Swift ; class TestValueBool : public CPPUNIT_NS :: TestFixture { public : CPPUNIT_TEST_SUITE ( TestValueBool ) ; CPPUNIT_TEST ( testInit ) ; CPPUNIT_TEST ( testAssign ) ; CPPUNIT_TEST ( testGet ) ; CPPUNIT_TEST ( testSetClear ) ; CPPUNIT_TEST ( testOperators ) ; CPPUNIT_TEST_SUITE_END ( ) ; public : void setUp ( ) { } void tearDown ( ) { } protected : void testInit ( ) { CPPUNIT_ASSERT ( iValue :: hasTypeString ( Values :: Bool :: id ) ) ; } void testAssign ( ) { oValue b ( true ) ; CPPUNIT_ASSERT ( b -> getID ( ) == Values :: Bool :: id ) ; } void testGet ( ) { CPPUNIT_ASSERT ( oValue ( true ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ! ( ( Values :: Bool * ) oValue ( false ) . get ( ) ) -> output ( ) ) ; } void testSetClear ( ) { oValue v ( true ) ; v -> clear ( ) ; CPPUNIT_ASSERT ( ! ( v >> bool ( ) ) ) ; Values :: Bool * b = ( Values :: Bool * ) v . get ( ) ; b -> set ( true ) ; CPPUNIT_ASSERT ( v >> bool ( ) ) ; } void testOperators ( ) { CPPUNIT_ASSERT ( ( oValue ( true ) == oValue ( true ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( true ) != oValue ( false ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( true ) && oValue ( true ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( false ) || oValue ( true ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( ! oValue ( true ) == oValue ( false ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( ) << true ) -> getID ( ) == Values :: Bool :: id ) ; CPPUNIT_ASSERT ( ( oValue ( false ) >> bool ( ) ) == false ) ; } } ; CPPUNIT_TEST_SUITE_REGISTRATION ( TestValueBool ) ; </DOCUMENT>
<DOCUMENT_ID="rfloc@@ a/MIT@@ K/tree/master/Plugins/org.mitk.gui@@ .qt.diffusionimaging@@ app/src/internal/Perspectives/@@ QmitkDIAppConnectomicsPerspective.cpp"> # include " QmitkDIAppConnectomicsPerspective . h " # include " berryIViewLayout . h " void QmitkDIAppConnectomicsPerspective :: CreateInitial@@ Layout ( berry :: IPageLayout :: Pointer layout ) { std :: string editorArea = layout -> GetEditorArea ( ) ; layout -> AddStandaloneView ( " org . mitk . views . datamanager " , false , berry :: IPageLayout :: LEFT , 0.3f , editorArea ) ; layout -> AddStandaloneView ( " org . mitk . views . controlvisualizationpropertiesview " , false , berry :: IPageLayout :: BOTTOM , .15f , " org . mitk . views . datamanager " ) ; berry :: IFolder@@ Layout :: Pointer left = layout -> CreateFolder ( " org . mbi . diffusionimaginginternal . leftcontrols " , berry :: IPageLayout :: BOTTOM , 0.1f , " org . mitk . views . controlvisualizationpropertiesview " ) ; layout -> AddStandaloneViewPlace@@ holder ( " org . mitk . views . imagenavig@@ ator " , berry :: IPageLayout :: BOTTOM , .4f , " org . mbi . diffusionimaginginternal . leftcontrols " , false ) ; left -> AddView ( " org . mitk . views . connectomicsstatistics " ) ; berry :: IViewLayout :: Pointer lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsstatistics " ) ; lo -> SetCloseable ( false ) ; left -> AddView ( " org . mitk . views . connectomicsnetworkoperations " ) ; lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsnetworkoperations " ) ; lo -> SetCloseable ( false ) ; left -> AddView ( " org . mitk . views . connectomicsdata " ) ; lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsdata " ) ; lo -> SetCloseable ( false ) ; } </DOCUMENT>
<DOCUMENT_ID="asurad@@ aimao/@@ dolphin/tree/master/Source/Core/Core/PowerPC/Interpreter/Interpreter@@ _Integer.cpp"> # include " Core / PowerPC / Interpreter / Interpreter . h " void Interpreter :: Helper_UpdateCR0 ( u32 value ) { s64 sign_extended = ( s64 ) ( s32 ) value ; u64 cr_val = ( u64 ) sign_extended ; cr_val = ( cr_val & ~ ( 1ull << 61 ) ) | ( ( u64 ) GetXER_SO ( ) << 61 ) ; PowerPC :: ppcState . cr_val [ 0 ] = cr_val ; } void Interpreter :: Helper_UpdateCRx ( int idx , u32 value ) { s64 sign_extended = ( s64 ) ( s32 ) value ; u64 cr_val = ( u64 ) sign_extended ; cr_val = ( cr_val & ~ ( 1ull << 61 ) ) | ( ( u64 ) GetXER_SO ( ) << 61 ) ; PowerPC :: ppcState . cr_val [ idx ] = cr_val ; } u32 Interpreter :: Helper_Carry ( u32 _uValue1 , u32 _uValue2 ) { return _uValue2 > ( ~ _uValue1 ) ; } u32 Interpreter :: Helper_Mask ( int mb , int me ) { u32 begin = 0xFFFFFFFF >> mb ; u32 end = me < 31 ? ( 0xFFFFFFFF >> ( me + 1 ) ) : 0 ; u32 mask = begin ^ end ; if ( me < mb ) return ~ mask ; else return mask ; } void Interpreter :: addi ( UGeckoInstruction _inst ) { if ( _inst . RA ) rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + _inst . SIMM_16 ; else rGPR [ _inst . RD ] = _inst . SIMM_16 ; } void Interpreter :: addic ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 imm = ( u32 ) ( s32 ) _inst . SIMM_16 ; rGPR [ _inst . RD ] = a + imm ; SetCarry ( Helper_Carry ( a , imm ) ) ; } void Interpreter :: addic_rc ( UGeckoInstruction _inst ) { addic ( _inst ) ; Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addis ( UGeckoInstruction _inst ) { if ( _inst . RA ) rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + ( _inst . SIMM_16 << 16 ) ; else rGPR [ _inst . RD ] = ( _inst . SIMM_16 << 16 ) ; } void Interpreter :: andi_rc ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & _inst . UIMM ; Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: andis_rc ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & ( ( u32 ) _inst . UIMM << 16 ) ; Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: cmpi ( UGeckoInstruction _inst ) { Helper_UpdateCRx ( _inst . CRFD , rGPR [ _inst . RA ] - _inst . SIMM_16 ) ; } void Interpreter :: cmpli ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = _inst . UIMM ; int f ; if ( a < b ) f = 0x8 ; else if ( a > b ) f = 0x4 ; else f = 0x2 ; if ( GetXER_SO ( ) ) f |= 0x1 ; SetCRField ( _inst . CRFD , f ) ; } void Interpreter :: mulli ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = ( s32 ) rGPR [ _inst . RA ] * _inst . SIMM_16 ; } void Interpreter :: ori ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | _inst . UIMM ; } void Interpreter :: oris ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | ( _inst . UIMM << 16 ) ; } void Interpreter :: subfic ( UGeckoInstruction _inst ) { s32 immediate = _inst . SIMM_16 ; rGPR [ _inst . RD ] = immediate - ( int ) rGPR [ _inst . RA ] ; SetCarry ( ( rGPR [ _inst . RA ] == 0 ) || ( Helper_Carry ( 0 - rGPR [ _inst . RA ] , immediate ) ) ) ; } void Interpreter :: twi ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = _inst . SIMM_16 ; s32 TO = _inst . TO ; DEBUG_LOG ( POWERPC , " twi ▁ rA ▁ % x ▁ SIMM ▁ % x ▁ TO ▁ % 0x " , a , b , TO ) ; if ( ( ( a < b ) && ( TO & 0x10 ) ) || ( ( a > b ) && ( TO & 0x08 ) ) || ( ( a == b ) && ( TO & 0x04 ) ) || ( ( ( u32 ) a < ( u32 ) b ) && ( TO & 0x02 ) ) || ( ( ( u32 ) a > ( u32 ) b ) && ( TO & 0x01 ) ) ) { PowerPC :: ppcState . Exceptions |= EXCEPTION_PROGRAM ; PowerPC :: CheckExceptions ( ) ; m_EndBlock = true ; } } void Interpreter :: xori ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ _inst . UIMM ; } void Interpreter :: xoris ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ ( _inst . UIMM << 16 ) ; } void Interpreter :: rlwim@@ ix ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = ( rGPR [ _inst . RA ] & ~ mask ) | ( _rotl ( rGPR [ _inst . RS ] , _inst . SH ) & mask ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: rlwinmx ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = _rotl ( rGPR [ _inst . RS ] , _inst . SH ) & mask ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: rlwnmx ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = _rotl ( rGPR [ _inst . RS ] , rGPR [ _inst . RB ] & 0x1F ) & mask ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: andx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: andcx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & ~ rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: cmp ( UGeckoInstruction _inst ) { s32 a = ( s32 ) rGPR [ _inst . RA ] ; s32 b = ( s32 ) rGPR [ _inst . RB ] ; int fTemp ; if ( a < b ) fTemp = 0x8 ; else if ( a > b ) fTemp = 0x4 ; else fTemp = 0x2 ; if ( GetXER_SO ( ) ) fTemp |= 0x1 ; SetCRField ( _inst . CRFD , fTemp ) ; } void Interpreter :: cmpl ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 fTemp ; if ( a < b ) fTemp = 0x8 ; else if ( a > b ) fTemp = 0x4 ; else fTemp = 0x2 ; if ( GetXER_SO ( ) ) fTemp |= 0x1 ; SetCRField ( _inst . CRFD , fTemp ) ; } void Interpreter :: cntlz@@ wx ( UGeckoInstruction _inst ) { u32 val = rGPR [ _inst . RS ] ; u32 mask = 0x80000000 ; int i = 0 ; for ( ; i < 32 ; i ++ , mask >>= 1 ) { if ( val & mask ) break ; } rGPR [ _inst . RA ] = i ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: eqvx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] ^ rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: extsb@@ x ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ( u32 ) ( s32 ) ( s8 ) rGPR [ _inst . RS ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: extshx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ( u32 ) ( s32 ) ( s16 ) rGPR [ _inst . RS ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: nandx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] & rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: norx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] | rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: orx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: orcx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | ( ~ rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: slwx ( UGeckoInstruction _inst ) { u32 amount = rGPR [ _inst . RB ] ; rGPR [ _inst . RA ] = ( amount & 0x20 ) ? 0 : rGPR [ _inst . RS ] << ( amount & 0x1f ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: srawx ( UGeckoInstruction _inst ) { int rb = rGPR [ _inst . RB ] ; if ( rb & 0x20 ) { if ( rGPR [ _inst . RS ] & 0x80000000 ) { rGPR [ _inst . RA ] = 0xFFFFFFFF ; SetCarry ( 1 ) ; } else { rGPR [ _inst . RA ] = 0x00000000 ; SetCarry ( 0 ) ; } } else { int amount = rb & 0x1f ; if ( amount == 0 ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ; SetCarry ( 0 ) ; } else { s32 rrs = rGPR [ _inst . RS ] ; rGPR [ _inst . RA ] = rrs >> amount ; if ( ( rrs < 0 ) && ( rrs << ( 32 - amount ) ) ) SetCarry ( 1 ) ; else SetCarry ( 0 ) ; } } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: srawix ( UGeckoInstruction _inst ) { int amount = _inst . SH ; if ( amount != 0 ) { s32 rrs = rGPR [ _inst . RS ] ; rGPR [ _inst . RA ] = rrs >> amount ; if ( ( rrs < 0 ) && ( rrs << ( 32 - amount ) ) ) SetCarry ( 1 ) ; else SetCarry ( 0 ) ; } else { SetCarry ( 0 ) ; rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: srwx ( UGeckoInstruction _inst ) { u32 amount = rGPR [ _inst . RB ] ; rGPR [ _inst . RA ] = ( amount & 0x20 ) ? 0 : ( rGPR [ _inst . RS ] >> ( amount & 0x1f ) ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: tw ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = rGPR [ _inst . RB ] ; s32 TO = _inst . TO ; DEBUG_LOG ( POWERPC , " tw ▁ rA ▁ % 0x ▁ rB ▁ % 0x ▁ TO ▁ % 0x " , a , b , TO ) ; if ( ( ( a < b ) && ( TO & 0x10 ) ) || ( ( a > b ) && ( TO & 0x08 ) ) || ( ( a == b ) && ( TO & 0x04 ) ) || ( ( ( u32 ) a < ( u32 ) b ) && ( TO & 0x02 ) ) || ( ( ( u32 ) a > ( u32 ) b ) && ( TO & 0x01 ) ) ) { PowerPC :: ppcState . Exceptions |= EXCEPTION_PROGRAM ; PowerPC :: CheckExceptions ( ) ; m_EndBlock = true ; } } void Interpreter :: xorx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: addx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + rGPR [ _inst . RB ] ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addcx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = a + b ; SetCarry ( Helper_Carry ( a , b ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addcx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; int b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = a + b + carry ; SetCarry ( Helper_Carry ( a , b ) || ( carry != 0 && Helper_Carry ( a + b , carry ) ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addmex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; rGPR [ _inst . RD ] = a + carry - 1 ; SetCarry ( Helper_Carry ( a , carry - 1 ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addmex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addzex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; rGPR [ _inst . RD ] = a + carry ; SetCarry ( Helper_Carry ( a , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addzex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: divwx ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = rGPR [ _inst . RB ] ; if ( b == 0 || ( ( u32 ) a == 0x80000000 && b == - 1 ) ) { if ( _inst . OE ) { PanicAlert ( " OE : ▁ divwx " ) ; } if ( ( ( u32 ) a & 0x80000000 ) && b == 0 ) rGPR [ _inst . RD ] = - 1 ; else rGPR [ _inst . RD ] = 0 ; } else { rGPR [ _inst . RD ] = ( u32 ) ( a / b ) ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: divwux ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; if ( b == 0 ) { if ( _inst . OE ) { PanicAlert ( " OE : ▁ divwux " ) ; } rGPR [ _inst . RD ] = 0 ; } else { rGPR [ _inst . RD ] = a / b ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: mulhwx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( u64 ) ( ( ( s64 ) ( s32 ) a * ( s64 ) ( s32 ) b ) ) >> 32 ) ; rGPR [ _inst . RD ] = d ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: mulhwux ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( ( u64 ) a * ( u64 ) b ) >> 32 ) ; rGPR [ _inst . RD ] = d ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: mullwx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( s32 ) a * ( s32 ) b ) ; rGPR [ _inst . RD ] = d ; if ( _inst . OE ) PanicAlert ( " OE : ▁ mullwx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: negx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = ( ~ rGPR [ _inst . RA ] ) + 1 ; if ( rGPR [ _inst . RD ] == 0x80000000 ) { if ( _inst . OE ) PanicAlert ( " OE : ▁ negx " ) ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = rGPR [ _inst . RB ] - rGPR [ _inst . RA ] ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfcx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = b - a ; SetCarry ( a == 0 || Helper_Carry ( b , 0 - a ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfcx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + b + carry ; SetCarry ( Helper_Carry ( ~ a , b ) || Helper_Carry ( ( ~ a ) + b , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfmex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + carry - 1 ; SetCarry ( Helper_Carry ( ~ a , carry - 1 ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfmex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfzex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + carry ; SetCarry ( Helper_Carry ( ~ a , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfzex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } </DOCUMENT>
<DOCUMENT_ID="gr@@ zegorz2047@@ /HotelReservation/tree/master/@@ fileio@@ .cpp"> # include < stdio . h > # include < string > # include < stdlib . h > # include < time . h > # include < sstream > # include < fstream > # include < vector > # include < iostream > std :: vector < std :: string > readFile ( std :: string filename ) { std :: vector < std :: string > lines ; std :: ifstream read ; std :: string line ; read . open ( filename . c_str ( ) ) ; if ( ! read . good ( ) ) { read . close ( ) ; std :: ofstream create ; create . open ( filename . c_str ( ) ) ; return lines ; } while ( ! read . eof ( ) ) { getline ( read , line ) ; if ( line != " " ) { lines . push_back ( line ) ; } } read . close ( ) ; return lines ; } void saveFile ( std :: string filename , std :: vector < std :: string > lines ) { std :: ofstream save ; save . open ( filename . c_str ( ) ) ; for ( int i = 0 ; i < lines . size ( ) ; i ++ ) { save << lines [ i ] << std :: endl ; } save . close ( ) ; } </DOCUMENT>
<DOCUMENT_ID="atti@@ lahorvath/phantomjs/tree/master/src/qt/qtwebkit/Source/JavaScriptCore/llint/LLIntEntrypo@@ ints.cpp"> # include " config . h " # include " LLIntEntrypoints . h " # if ENABLE ( LLINT ) # include " JITCode . h " # include " VM . h " # include " JSObject . h " # include " LLIntThunk@@ s . h " # include " LowLevelInterpreter . h " namespace JSC { namespace LLInt { void getFunctionEntrypoint ( VM & vm , CodeSpec@@ ializationKind kind , JITCode & jitCode , MacroAssemblerCodePtr & arityCheck ) { if ( ! vm . canUseJIT ( ) ) { if ( kind == CodeForCall ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_function_for_call_prologue ) , JITCode :: InterpreterThunk ) ; arityCheck = MacroAssemblerCodePtr :: createLLIntCodePtr ( llint_function_for_call_arity_check ) ; return ; } ASSERT ( kind == CodeForConstruct ) ; jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_function_for_construct_prologue ) , JITCode :: InterpreterThunk ) ; arityCheck = MacroAssemblerCodePtr :: createLLIntCodePtr ( llint_function_for_construct_arity_check ) ; return ; } # if ENABLE ( JIT ) if ( kind == CodeForCall ) { jitCode = JITCode ( vm . getCTIStub ( functionForCallEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; arityCheck = vm . getCTIStub ( functionForCallArityCheckThunkGenerator ) . code ( ) ; return ; } ASSERT ( kind == CodeForConstruct ) ; jitCode = JITCode ( vm . getCTIStub ( functionForConstructEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; arityCheck = vm . getCTIStub ( functionForConstructArityCheckThunkGenerator ) . code ( ) ; # endif } void getEvalEntrypoint ( VM & vm , JITCode & jitCode ) { if ( ! vm . canUseJIT ( ) ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_eval_@@ prologue ) , JITCode :: InterpreterThunk ) ; return ; } # if ENABLE ( JIT ) jitCode = JITCode ( vm . getCTIStub ( evalEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; # endif } void getProgramEntrypoint ( VM & vm , JITCode & jitCode ) { if ( ! vm . canUseJIT ( ) ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_program_prologue ) , JITCode :: InterpreterThunk ) ; return ; } # if ENABLE ( JIT ) jitCode = JITCode ( vm . getCTIStub ( programEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; # endif } } } # endif </DOCUMENT>
<DOCUMENT_ID="Hankuo/color-emoji.skia/tree/master/src/@@ gpu/@@ gl/unix@@ /GrGLCreateNativeInterface_@@ unix.cpp"> # include " gl / GrGLExtensions . h " # include " gl / GrGLInterface . h " # include " . . / GrGLUtil . h " # include < GL / glx . h > # include < GL / gl . h > # include < GL / glext . h > # include < GL / glu . h > # define GR_GL_GET_PROC ( F ) interface -> f ## F = ( GrGL ## F ## Proc ) glXGetProcAddress ( reinterpret_cast < const GLubyte * > ( " gl " # F ) ) ; # define GR_GL_GET_PROC_SUFFIX ( F , S ) interface -> f ## F = ( GrGL ## F ## Proc ) glXGetProcAddress ( reinterpret_cast < const GLubyte * > ( " gl " # F # S ) ) ; const GrGLInterface * GrGLCreateNativeInterface ( ) { if ( NULL != glXGetCurrent@@ Context ( ) ) { const char * versionString = ( const char * ) glGetString ( GL_VERSION ) ; GrGLVersion glVer = GrGLGetVersion@@ FromString ( versionString ) ; GrGLGetStringiProc glGetStringi = ( GrGLGetStringiProc ) glXGetProcAddress ( reinterpret_cast < const GLubyte * > ( " glGetStringi " ) ) ; GrGLExtensions extensions ; if ( ! extensions . init ( kDesktop_GrGLBinding , glGetString , glGetStringi , glGetIntegerv ) ) { return NULL ; } if ( glVer < GR_GL_VER ( 1 , 5 ) ) { return NULL ; } GrGLInterface * interface = new GrGLInterface ( ) ; interface -> fActiveTexture = glActiveTexture ; GR_GL_GET_PROC ( AttachShader ) ; GR_GL_GET_PROC ( BindAttrib@@ Location ) ; GR_GL_GET_PROC ( BindBuffer ) ; GR_GL_GET_PROC ( BindFragDataLocation ) ; GR_GL_GET_PROC ( BeginQuery ) ; interface -> fBindTexture = glBindTexture ; interface -> fBlendFunc = glBlendFunc ; if ( glVer >= GR_GL_VER ( 1 , 4 ) || extensions . has ( " GL _ ARB _ imaging " ) || extensions . has ( " GL _ EXT _ blend _ color " ) ) { GR_GL_GET_PROC ( BlendColor ) ; } GR_GL_GET_PROC ( BufferData ) ; GR_GL_GET_PROC ( BufferSubData ) ; interface -> fClear = glClear ; interface -> fClearColor = glClearColor ; interface -> fClearStencil = glClearStencil ; interface -> fColorMask = glColorMask ; GR_GL_GET_PROC ( CompileShader ) ; interface -> fCompressedTexImage2D = glCompressedTexImage2D ; interface -> fCopyTexSubImage2D = glCopyTexSubImage2D ; GR_GL_GET_PROC ( CreateProgram ) ; GR_GL_GET_PROC ( CreateShader ) ; interface -> fCullFace = glCullFace ; GR_GL_GET_PROC ( DeleteBuffers ) ; GR_GL_GET_PROC ( DeleteProgram ) ; GR_GL_GET_PROC ( DeleteQueries ) ; GR_GL_GET_PROC ( DeleteShader ) ; interface -> fDeleteTextures = glDeleteTextures ; interface -> fDepthMask = glDepthMask ; interface -> fDisable = glDisable ; GR_GL_GET_PROC ( DisableVertexAttribArray ) ; interface -> fDrawArrays = glDrawArrays ; interface -> fDrawBuffer = glDrawBuffer ; GR_GL_GET_PROC ( DrawBuffers ) ; interface -> fDrawElements = glDrawElements ; interface -> fEnable = glEnable ; GR_GL_GET_PROC ( EnableVertexAttribArray ) ; GR_GL_GET_PROC ( EndQuery ) ; interface -> fFinish = glFinish ; interface -> fFlush = glFlush ; interface -> fFrontFace = glFrontFace ; GR_GL_GET_PROC ( GenBuffers ) ; GR_GL_GET_PROC ( GetBufferParameteriv ) ; interface -> fGetError = glGetError ; interface -> fGetIntegerv = glGetIntegerv ; GR_GL_GET_PROC ( GetQueryObjectiv ) ; GR_GL_GET_PROC ( GetQueryObjectuiv ) ; if ( glVer >= GR_GL_VER ( 3 , 3 ) || extensions . has ( " GL _ ARB _ timer _ query " ) ) { GR_GL_GET_PROC ( GetQueryObjecti64v ) ; GR_GL_GET_PROC ( GetQueryObjectui64v ) ; GR_GL_GET_PROC ( QueryCounter ) ; } else if ( extensions . has ( " GL _ EXT _ timer _ query " ) ) { GR_GL_GET_PROC_SUFFIX ( GetQueryObjecti64v , EXT ) ; GR_GL_GET_PROC_SUFFIX ( GetQueryObjectui64v , EXT ) ; } GR_GL_GET_PROC ( GetQueryiv ) ; GR_GL_GET_PROC ( GetProgramInfoLog ) ; GR_GL_GET_PROC ( GetProgramiv ) ; GR_GL_GET_PROC ( GetShaderInfoLog ) ; GR_GL_GET_PROC ( GetShaderiv ) ; interface -> fGetString = glGetString ; GR_GL_GET_PROC ( GetStringi ) ; interface -> fGetTexLevelParameteriv = glGetTexLevelParameteriv ; GR_GL_GET_PROC ( GenQueries ) ; interface -> fGenTextures = glGenTextures ; GR_GL_GET_PROC ( GetUniformLocation ) ; interface -> fLineWidth = glLineWidth ; GR_GL_GET_PROC ( LinkProgram ) ; GR_GL_GET_PROC ( MapBuffer ) ; interface -> fPixelStorei = glPixelStorei ; interface -> fReadBuffer = glReadBuffer ; interface -> fReadPixels = glReadPixels ; if ( extensions . has ( " GL _ NV _ framebuffer _ multisample _ coverage " ) ) { GR_GL_GET_PROC_SUFFIX ( RenderbufferStorageMultisampleCoverage , NV ) ; } interface -> fScissor = glScissor ; GR_GL_GET_PROC ( ShaderSource ) ; interface -> fStencilFunc = glStencilFunc ; GR_GL_GET_PROC ( StencilFuncSeparate ) ; interface -> fStencilMask = glStencilMask ; GR_GL_GET_PROC ( StencilMask@@ Separate ) ; interface -> fStencilOp = glStencilOp ; GR_GL_GET_PROC ( StencilOpSeparate ) ; interface -> fTexImage2D = glTexImage2D ; interface -> fTexParameteri = glTexParameteri ; interface -> fTexParameteriv = glTexParameteriv ; if ( glVer >= GR_GL_VER ( 4 , 2 ) || extensions . has ( " GL _ ARB _ texture _ storage " ) ) { GR_GL_GET_PROC ( TexStorage2D ) ; } else if ( extensions . has ( " GL _ EXT _ texture _ storage " ) ) { GR_GL_GET_PROC_SUFFIX ( TexStorage2D , EXT ) ; } interface -> fTexSubImage2D = glTexSubImage2D ; GR_GL_GET_PROC ( Uniform1f ) ; GR_GL_GET_PROC ( Uniform1i ) ; GR_GL_GET_PROC ( Uniform1fv ) ; GR_GL_GET_PROC ( Uniform1iv ) ; GR_GL_GET_PROC ( Uniform2f ) ; GR_GL_GET_PROC ( Uniform2i ) ; GR_GL_GET_PROC ( Uniform2fv ) ; GR_GL_GET_PROC ( Uniform2iv ) ; GR_GL_GET_PROC ( Uniform3f ) ; GR_GL_GET_PROC ( Uniform3i ) ; GR_GL_GET_PROC ( Uniform3fv ) ; GR_GL_GET_PROC ( Uniform3iv ) ; GR_GL_GET_PROC ( Uniform4f ) ; GR_GL_GET_PROC ( Uniform4i ) ; GR_GL_GET_PROC ( Uniform4fv ) ; GR_GL_GET_PROC ( Uniform4iv ) ; GR_GL_GET_PROC ( UniformMatrix2fv ) ; GR_GL_GET_PROC ( UniformMatrix3fv ) ; GR_GL_GET_PROC ( UniformMatrix4fv ) ; GR_GL_GET_PROC ( UnmapBuffer ) ; GR_GL_GET_PROC ( UseProgram ) ; GR_GL_GET_PROC ( VertexAttrib4fv ) ; GR_GL_GET_PROC ( VertexAttribPointer ) ; interface -> fViewport = glViewport ; GR_GL_GET_PROC ( BindFragDataLocationIndexed ) ; if ( glVer >= GR_GL_VER ( 3 , 0 ) || extensions . has ( " GL _ ARB _ vertex _ array _ object " ) ) { GR_GL_GET_PROC ( BindVertex@@ Array ) ; GR_GL_GET_PROC ( GenVertexArrays ) ; GR_GL_GET_PROC ( DeleteVertexArrays ) ; } if ( glVer >= GR_GL_VER ( 3 , 0 ) || extensions . has ( " GL _ ARB _ framebuffer _ object " ) ) { GR_GL_GET_PROC ( GenFramebuffers ) ; GR_GL_GET_PROC ( GetFramebufferAttachmentParameteriv ) ; GR_GL_GET_PROC ( GetRenderbufferParameteriv ) ; GR_GL_GET_PROC ( BindFramebuffer ) ; GR_GL_GET_PROC ( FramebufferTexture2D ) ; GR_GL_GET_PROC ( CheckFramebufferStatus ) ; GR_GL_GET_PROC ( DeleteFramebuffers ) ; GR_GL_GET_PROC ( RenderbufferStorage ) ; GR_GL_GET_PROC ( GenRenderbuffers ) ; GR_GL_GET_PROC ( DeleteRenderbuffers ) ; GR_GL_GET_PROC ( FramebufferRenderbuffer ) ; GR_GL_GET_PROC ( BindRenderbuffer ) ; GR_GL_GET_PROC ( RenderbufferStorageMultisample ) ; GR_GL_GET_PROC ( BlitFramebuffer ) ; } else if ( extensions . has ( " GL _ EXT _ framebuffer _ object " ) ) { GR_GL_GET_PROC_SUFFIX ( GenFramebuffers , EXT ) ; GR_GL_GET_PROC_SUFFIX ( GetFramebufferAttachmentParameteriv , EXT ) ; GR_GL_GET_PROC_SUFFIX ( GetRenderbufferParameteriv , EXT ) ; GR_GL_GET_PROC_SUFFIX ( BindFramebuffer , EXT ) ; GR_GL_GET_PROC_SUFFIX ( FramebufferTexture2D , EXT ) ; GR_GL_GET_PROC_SUFFIX ( CheckFramebufferStatus , EXT ) ; GR_GL_GET_PROC_SUFFIX ( DeleteFramebuffers , EXT ) ; GR_GL_GET_PROC_SUFFIX ( RenderbufferStorage , EXT ) ; GR_GL_GET_PROC_SUFFIX ( GenRenderbuffers , EXT ) ; GR_GL_GET_PROC_SUFFIX ( DeleteRenderbuffers , EXT ) ; GR_GL_GET_PROC_SUFFIX ( FramebufferRenderbuffer , EXT ) ; GR_GL_GET_PROC_SUFFIX ( BindRenderbuffer , EXT ) ; if ( extensions . has ( " GL _ EXT _ framebuffer _ multisample " ) ) { GR_GL_GET_PROC_SUFFIX ( RenderbufferStorageMultisample , EXT ) ; } if ( extensions . has ( " GL _ EXT _ framebuffer _ blit " ) ) { GR_GL_GET_PROC_SUFFIX ( BlitFramebuffer , EXT ) ; } } else { delete interface ; return NULL ; } interface -> fBindingsExported = kDesktop_GrGLBinding ; return interface ; } else { return NULL ; } } </DOCUMENT>
<DOCUMENT_ID="Roxted@@ y/SkyFire@@ _6xx/tree/master/src/server/game/@@ Handlers/TicketHandler.cpp"> # include " zlib . h " # include " Common . h " # include " Language . h " # include " ObjectMgr . h " # include " Opcodes . h " # include " Player . h " # include " TicketMgr . h " # include " Util . h " # include " World . h " # include " WorldPacket . h " # include " WorldSession . h " void WorldSession :: HandleGMTicketCreateOpcode ( WorldPacket & recvData ) { if ( sTicketMgr -> GetStatus ( ) == GMTICKET_QUEUE_STATUS_DISABLED ) return ; if ( GetPlayer ( ) -> getLevel ( ) < sWorld -> getIntConfig ( CONFIG_TICKET_LEVEL_REQ ) ) { SendNotification ( GetTrinityString ( LANG_TICKET_@@ REQ ) , sWorld -> getIntConfig ( CONFIG_TICKET_LEVEL_REQ ) ) ; return ; } GMTicketResponse response = GMTICKET_RESPONSE_CREATE_ERROR ; GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ; if ( ticket && ticket -> IsCompleted ( ) ) sTicketMgr -> CloseTicket ( ticket -> GetId ( ) , GetPlayer ( ) -> GetGUID ( ) ) ; ; if ( ! ticket || ticket -> IsClosed ( ) ) { ticket = new GmTicket ( GetPlayer ( ) , recvData ) ; uint32 count ; std :: list < uint32 > times ; uint32 decompressedSize ; std :: string chatLog ; recvData >> count ; for ( uint32 i = 0 ; i < count ; i ++ ) { uint32 time ; recvData >> time ; times . push_back ( time ) ; } recvData >> decompressedSize ; if ( count && decompressedSize && decompressedSize < 0xFFFF ) { uint32 pos = recvData . rpos ( ) ; ByteBuffer dest ; dest . resize ( decompressedSize ) ; uLongf realSize = decompressedSize ; if ( uncompress ( dest . contents ( ) , & realSize , recvData . contents ( ) + pos , recvData . size ( ) - pos ) == Z_OK ) { dest >> chatLog ; ticket -> SetChatLog ( times , chatLog ) ; } else { TC_LOG_ERROR ( " network " , " CMSG _ GMTICKET _ CREATE ▁ possibly ▁ corrupt . ▁ Uncompression ▁ failed . " ) ; recvData . rfinish ( ) ; delete ticket ; return ; } recvData . rfinish ( ) ; } sTicketMgr -> AddTicket ( ticket ) ; sTicketMgr -> UpdateLast@@ Change ( ) ; sWorld -> SendGMText ( LANG_COMMAND_TICKETNEW , GetPlayer ( ) -> GetName ( ) . c_str ( ) , ticket -> GetId ( ) ) ; response = GMTICKET_RESPONSE_CREATE_SUCCESS ; } WorldPacket data ( SMSG_GMTICKET_CREATE , 4 ) ; data << uint32 ( response ) ; SendPacket ( & data ) ; } void WorldSession :: HandleGMTicketUpdateOpcode ( WorldPacket & recvData ) { std :: string message ; recvData >> message ; GMTicketResponse response = GMTICKET_RESPONSE_UPDATE_ERROR ; if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { SQLTransaction trans = SQLTransaction ( NULL ) ; ticket -> SetMessage ( message ) ; ticket -> SaveToDB ( trans ) ; sWorld -> SendGMText ( LANG_COMMAND_TICKETUPDATED , GetPlayer ( ) -> GetName ( ) . c_str ( ) , ticket -> GetId ( ) ) ; response = GMTICKET_RESPONSE_UPDATE_SUCCESS ; } WorldPacket data ( SMSG_GMTICKET_UPDATETEXT , 4 ) ; data << uint32 ( response ) ; SendPacket ( & data ) ; } void WorldSession :: HandleGMTicketDeleteOpcode ( WorldPacket & ) { if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { WorldPacket data ( SMSG_GMTICKET_DELETETICKET , 4 ) ; data << uint32 ( GMTICKET_RESPONSE_TICKET_DELETED ) ; SendPacket ( & data ) ; sWorld -> SendGMText ( LANG_COMMAND_TICKETPLAYERABANDO@@ N , GetPlayer ( ) -> GetName ( ) . c_str ( ) , ticket -> GetId ( ) ) ; sTicketMgr -> CloseTicket ( ticket -> GetId ( ) , GetPlayer ( ) -> GetGUID ( ) ) ; sTicketMgr -> SendTicket ( this , NULL ) ; } } void WorldSession :: HandleGMTicketGetTicketOpcode ( WorldPacket & ) { SendQueryTimeResponse ( ) ; if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { if ( ticket -> IsCompleted ( ) ) ticket -> SendResponse ( this ) ; else sTicketMgr -> SendTicket ( this , ticket ) ; } else sTicketMgr -> SendTicket ( this , NULL ) ; } void WorldSession :: HandleGMTicketSystemStatus@@ Opcode ( WorldPacket & ) { WorldPacket data ( SMSG_GMTICKET_SYSTEM@@ STATUS , 4 ) ; data << uint32 ( sTicketMgr -> GetStatus ( ) ? GMTICKET_QUEUE_STATUS_ENABLED : GMTICKET_QUEUE_STATUS_DISABLED ) ; SendPacket ( & data ) ; } void WorldSession :: HandleGMS@@ urveySubmit ( WorldPacket & recvData ) { uint32 nextSurveyID = sTicketMgr -> GetNextSurveyID ( ) ; uint32 mainSurvey ; recvData >> mainSurvey ; for ( uint8 i = 0 ; i < 15 ; i ++ ) { uint32 subSurveyId ; recvData >> subSurveyId ; if ( ! subSurveyId ) break ; uint8 rank ; recvData >> rank ; std :: string comment ; recvData >> comment ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_GM_SUBS@@ URVEY ) ; stmt -> setUInt32 ( 0 , nextSurveyID ) ; stmt -> setUInt32 ( 1 , subSurveyId ) ; stmt -> setUInt32 ( 2 , rank ) ; stmt -> setString ( 3 , comment ) ; CharacterDatabase . Execute ( stmt ) ; } std :: string comment ; recvData >> comment ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_GM_SURVEY ) ; stmt -> setUInt32 ( 0 , GUID_LOPART ( GetPlayer ( ) -> GetGUID ( ) ) ) ; stmt -> setUInt32 ( 1 , nextSurveyID ) ; stmt -> setUInt32 ( 2 , mainSurvey ) ; stmt -> setString ( 3 , comment ) ; CharacterDatabase . Execute ( stmt ) ; } void WorldSession :: HandleReport@@ Lag ( WorldPacket & recvData ) { uint32 lagType , mapId ; recvData >> lagType ; recvData >> mapId ; float x , y , z ; recvData >> x ; recvData >> y ; recvData >> z ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_LAG_REPORT ) ; stmt -> setUInt32 ( 0 , GUID_LOPART ( GetPlayer ( ) -> GetGUID ( ) ) ) ; stmt -> setUInt8 ( 1 , lagType ) ; stmt -> setUInt16 ( 2 , mapId ) ; stmt -> setFloat ( 3 , x ) ; stmt -> setFloat ( 4 , y ) ; stmt -> setFloat ( 5 , z ) ; stmt -> setUInt32 ( 6 , GetLatency ( ) ) ; stmt -> setUInt32 ( 7 , time ( NULL ) ) ; CharacterDatabase . Execute ( stmt ) ; } void WorldSession :: HandleGM@@ ResponseResolve ( WorldPacket & ) { if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { uint8 getSurvey = 0 ; if ( float ( rand_chance ( ) ) < sWorld -> getFloatConfig ( CONFIG_CHANCE_@@ OF_GM_SURVEY ) ) getSurvey = 1 ; WorldPacket data ( SMSG_GMRESPONSE_@@ STATUS_UPDATE , 4 ) ; data << uint8 ( getSurvey ) ; SendPacket ( & data ) ; WorldPacket data2 ( SMSG_GMTICKET_DELETETICKET , 4 ) ; data2 << uint32 ( GMTICKET_RESPONSE_TICKET_DELETED ) ; SendPacket ( & data2 ) ; sTicketMgr -> CloseTicket ( ticket -> GetId ( ) , GetPlayer ( ) -> GetGUID ( ) ) ; sTicketMgr -> SendTicket ( this , NULL ) ; } } </DOCUMENT>
<DOCUMENT_ID="Admir@@ alCurtiss/@@ ppsspp/tree/master/unittest/Unit@@ Test.cpp"> # include < cstdio > # include < cstdlib > # include < cmath > # include < string > # include < sstream > # include " base / NativeApp . h " # include " base / logging . h " # include " Common / CPUDetect . h " # include " Common / ArmEmitter . h " # include " ext / disarm . h " # include " math / math _ util . h " # include " util / text / parsers . h " # include " Core / Config . h " # include " Core / MIPS / MIPSVFP@@ UUtils . h " # include " Core / FileSystem@@ s / ISOFileSystem . h " # include " unittest / JitHar@@ ness . h " # include " unittest / TestVertexJit . h " # include " unittest / UnitTest . h " std :: string System_GetProperty ( SystemProperty prop ) { return " " ; } int System_GetPropertyInt ( SystemProperty prop ) { return - 1 ; } void NativeMessageReceived ( const char * message , const char * value ) { } void GL_Swap@@ Interval ( int ) { } # ifndef M_PI_2 # define M_PI_2 1.57079632@@ 679489661923 # endif float fastasin ( double x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; float sqrtthing = sqrt ( 1.0f - x * x ) ; float y = - .357214@@ 2480f + .10870634@@ 63f * x ; y = y * x + 1.062519@@ 236f ; y = y * x + - 2.5112@@ 7850@@ 6f ; y = y * x + .191900116f ; y = y * x + 1.807607311f ; y /= ( 1.807607311f - 1.615@@ 1950@@ 94 * x ) ; return sign * ( y - sqrtthing ) ; } double atan_66s ( double x ) { const double c1 = 1.6867629106 ; const double c2 = 0.4378497304 ; const double c3 = 1.6867633134 ; double x2 ; x2 = x * x ; return ( x * ( c1 + x2 * c2 ) / ( c3 + x2 ) ) ; } double fastasin2 ( double x ) { return atan_66s ( x / sqrt ( 1 - x * x ) ) ; } float fastasin3 ( float x ) { return x + x * x * x * x * x * 0.4971 ; } float fastasin4 ( float x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; x = M_PI / 2 - sqrtf ( 1.0f - x ) * ( 1.5707288 + - 0.212114@@ 4 * x + 0.074@@ 2610 * x * x + - 0.0187293 * x * x * x ) ; return sign * x ; } float fastasin5 ( float x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; float fRoot = sqrtf ( 1.0f - x ) ; float fResult = 0.0742@@ 610f + - 0.0187293f * x ; fResult = - 0.21211@@ 44f + fResult * x ; fResult = 1.5707288f + fResult * x ; fResult = M_PI / 2 - fRoot * fResult ; return sign * fResult ; } # define C 0.70710678118654752440f # define BITSPERQUARTER ( 20 ) void fcs ( float angle , float & sinout , float & cosout ) { int phasein = angle * ( 1 << BITSPERQUARTER ) ; float modphase = ( phasein & ( ( 1 << BITSPERQUARTER ) - 1 ) ) * ( 1.0f / ( 1 << BITSPERQUARTER ) ) ; int quarter = phasein >> BITSPERQUARTER ; if ( ! quarter ) { float x = modphase - 0.5f ; float temp = ( 2 - 4 * C ) * x * x + C ; sinout = temp + x ; cosout = temp - x ; } else if ( quarter == 1 ) { float x = 0.5f - modphase ; float temp = ( 2 - 4 * C ) * x * x + C ; sinout = x + temp ; cosout = x - temp ; } else if ( quarter == 2 ) { float x = modphase - 0.5f ; float temp = ( 4 * C - 2 ) * x * x - C ; sinout = temp - x ; cosout = temp + x ; } else if ( quarter == 3 ) { float x = modphase - 0.5f ; float temp = ( 2 - 4 * C ) * x * x + C ; sinout = x - temp ; cosout = x + temp ; } } # undef C const float PI_SQR = 9.8696@@ 0440@@ 1089358@@ 618834490@@ 9998@@ 7615114@@ f ; void fcs2 ( float theta , float & outsine , float & outcosine ) { float gamma = theta + 1 ; gamma += 2 ; gamma /= 4 ; theta += 2 ; theta /= 4 ; theta -= floorf ( theta ) ; gamma -= floorf ( gamma ) ; theta *= 4 ; theta -= 2 ; gamma *= 4 ; gamma -= 2 ; float x = 2 * gamma - gamma * fabs ( gamma ) ; float y = 2 * theta - theta * fabs ( theta ) ; const float P = 0.225 ; outsine = P * ( y * fabsf ( y ) - y ) + y ; outcosine = P * ( x * fabsf ( x ) - x ) + x ; } void fastsincos ( float x , float & sine , float & cosine ) { fcs2 ( x , sine , cosine ) ; } bool TestSinCos ( ) { for ( int i = - 100 ; i <= 100 ; i ++ ) { float f = i / 30.0f ; float slowsin = sinf ( f * M_PI_2 ) , slowcos = cosf ( f * M_PI_2 ) ; float fastsin , fastcos ; fastsincos ( f , fastsin , fastcos ) ; printf ( " % f : ▁ slow : ▁ % 0.8f , ▁ % 0.8f ▁ fast : ▁ % 0.8f , ▁ % 0.8f \n " , f , slowsin , slowcos , fastsin , fastcos ) ; } return true ; } bool TestAsin ( ) { for ( int i = - 100 ; i <= 100 ; i ++ ) { float f = i / 100.0f ; float slowval = asinf ( f ) / M_PI_2 ; float fastval = fastasin5 ( f ) / M_PI_2 ; printf ( " slow : ▁ % 0.16f ▁ fast : ▁ % 0.16f \n " , slowval , fastval ) ; float diff = fabsf ( slowval - fastval ) ; } return true ; } bool TestMathUtil ( ) { EXPECT_FALSE ( my_isinf ( 1.0 ) ) ; volatile float zero = 0.0f ; EXPECT_TRUE ( my_isinf ( 1.0f / zero ) ) ; EXPECT_FALSE ( my_isnan ( 1.0f / zero ) ) ; return true ; } bool TestParsers ( ) { const char * macstr = "01:@@ 02:0@@ 3 : ff : fe : fd " ; uint8_t mac [ 6 ] ; ParseMacAddress ( macstr , mac ) ; EXPECT_TRUE ( mac [ 0 ] == 1 ) ; EXPECT_TRUE ( mac [ 1 ] == 2 ) ; EXPECT_TRUE ( mac [ 2 ] == 3 ) ; EXPECT_TRUE ( mac [ 3 ] == 255 ) ; EXPECT_TRUE ( mac [ 4 ] == 254 ) ; EXPECT_TRUE ( mac [ 5 ] == 253 ) ; return true ; } bool TestVFPUSinCos ( ) { float sine , cosine ; vfpu_sincos ( 0.0f , sine , cosine ) ; EXPECT_EQ_FLOAT ( sine , 0.0f ) ; EXPECT_EQ_FLOAT ( cosine , 1.0f ) ; vfpu_sincos ( 1.0f , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , 1.0f ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , 0.0f ) ; vfpu_sincos ( 2.0f , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , 0.0f ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , - 1.0f ) ; vfpu_sincos ( 3.0f , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , - 1.0f ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , 0.0f ) ; vfpu_sincos ( 4.0f , sine , cosine ) ; EXPECT_EQ_FLOAT ( sine , 0.0f ) ; EXPECT_EQ_FLOAT ( cosine , 1.0f ) ; vfpu_sincos ( 5.0f , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , 1.0f ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , 0.0f ) ; for ( float angle = - 10.0f ; angle < 10.0f ; angle ++ ) { vfpu_sincos ( angle , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , sinf ( angle * M_PI_2 ) ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , cosf ( angle * M_PI_2 ) ) ; } return true ; } bool TestMatrixTranspose ( ) { MatrixSize sz = M_4x4 ; int matrix = 0 ; u8 cols [ 4 ] ; u8 rows [ 4 ] ; GetMatrixColumns ( matrix , sz , cols ) ; GetMatrixRows ( matrix , sz , rows ) ; int transposed = Xpose ( matrix ) ; u8 x_cols [ 4 ] ; u8 x_rows [ 4 ] ; GetMatrixColumns ( transposed , sz , x_cols ) ; GetMatrixRows ( transposed , sz , x_rows ) ; for ( int i = 0 ; i < GetMatrixSide ( sz ) ; i ++ ) { EXPECT_EQ_INT ( cols [ i ] , x_rows [ i ] ) ; EXPECT_EQ_INT ( x_cols [ i ] , rows [ i ] ) ; } return true ; } void TestGetMatrix ( int matrix , MatrixSize sz ) { ILOG ( " Testing ▁ matrix ▁ % s " , GetMatrixNotation ( matrix , sz ) ) ; u8 fullMatrix [ 16 ] ; u8 cols [ 4 ] ; u8 rows [ 4 ] ; GetMatrixColumns ( matrix , sz , cols ) ; GetMatrixRows ( matrix , sz , rows ) ; GetMatrixRegs ( fullMatrix , sz , matrix ) ; int n = GetMatrixSide ( sz ) ; VectorSize vsz = GetVectorSize ( sz ) ; for ( int i = 0 ; i < n ; i ++ ) { int colName = cols [ i ] ; int rowName = rows [ i ] ; ILOG ( " Column ▁ % i : ▁ % s " , i , GetVectorNotation ( colName , vsz ) ) ; ILOG ( " Row ▁ % i : ▁ % s " , i , GetVectorNotation ( rowName , vsz ) ) ; u8 colRegs [ 4 ] ; u8 rowRegs [ 4 ] ; GetVectorRegs ( colRegs , vsz , colName ) ; GetVectorRegs ( rowRegs , vsz , rowName ) ; std :: stringstream a , b , c , d ; for ( int j = 0 ; j < n ; j ++ ) { a . clear ( ) ; b . clear ( ) ; a << ( int ) fullMatrix [ i * 4 + j ] << " ▁ " ; b << ( int ) colRegs [ j ] << " ▁ " ; c . clear ( ) ; d . clear ( ) ; c << ( int ) fullMatrix [ j * 4 + i ] << " ▁ " ; d << ( int ) rowRegs [ j ] << " ▁ " ; } ILOG ( " Col : ▁ % s ▁ vs ▁ % s " , a . str ( ) . c_str ( ) , b . str ( ) . c_str ( ) ) ; if ( a . str ( ) != b . str ( ) ) ILOG ( " WRONG ! " ) ; ILOG ( " Row : ▁ % s ▁ vs ▁ % s " , c . str ( ) . c_str ( ) , d . str ( ) . c_str ( ) ) ; if ( c . str ( ) != d . str ( ) ) ILOG ( " WRONG ! " ) ; } } bool TestParseLBN ( ) { const char * validStrings [ ] = { " / sce _ lbn0x5fa0 _ size0x1428" , " / sce _ lbn7050 _ sizeee@@ 850" , " / sce _ lbn0x5ee@@ eh _ size0x2@@ 34x " , " / sce _ lbneee _ _ size434 . " , } ; int expectedResults [ ] [ 2 ] = { { 0x5fa0 , 0x1428 } , { 0x7050 , 0xee8@@ 50 } , { 0x5eee , 0x234 } , { 0xeee , 0x434 } , } ; const char * invalidStrings [ ] = { " / sce _ lbn0x5fa0 _ sze0x1428" , " " , " // " , } ; for ( int i = 0 ; i < ARRAY_SIZE ( validStrings ) ; i ++ ) { u32 startSector = 0 , readSize = 0 ; EXPECT_TRUE ( parseLBN ( validStrings [ i ] , & startSector , & readSize ) ) ; EXPECT_EQ_INT ( startSector , expectedResults [ i ] [ 0 ] ) ; EXPECT_EQ_INT ( readSize , expectedResults [ i ] [ 1 ] ) ; } for ( int i = 0 ; i < ARRAY_SIZE ( invalidStrings ) ; i ++ ) { u32 startSector , readSize ; EXPECT_FALSE ( parseLBN ( invalidStrings [ i ] , & startSector , & readSize ) ) ; } return true ; } typedef bool ( * TestFunc ) ( ) ; struct TestItem { const char * name ; TestFunc func ; } ; # define TEST_ITEM ( name ) { # name , & Test ## name , } bool TestArmEmitter ( ) ; bool TestArm64Emitter ( ) ; bool TestX64Emitter ( ) ; TestItem availableTests [ ] = { # if defined ( ARM64 ) || defined ( _M_X64 ) || defined ( _M_IX86 ) TEST_ITEM ( Arm64Emitter ) , # endif # if defined ( ARM ) || defined ( _M_X64 ) || defined ( _M_IX86 ) TEST_ITEM ( ArmEmitter ) , # endif # if defined ( _M_X64 ) || defined ( _M_IX86 ) TEST_ITEM ( X64Emitter ) , # endif TEST_ITEM ( VertexJit ) , TEST_ITEM ( Asin ) , TEST_ITEM ( SinCos ) , TEST_ITEM ( VFPUSinCos ) , TEST_ITEM ( MathUtil ) , TEST_ITEM ( Parsers ) , TEST_ITEM ( Jit ) , TEST_ITEM ( MatrixTranspose ) , TEST_ITEM ( ParseLBN ) , } ; int main ( int argc , const char * argv [ ] ) { cpu_info . bNEON = true ; cpu_info . bVFP = true ; cpu_info . bVFPv3 = true ; cpu_info . bVFPv4 = true ; g_Config . bEnableLogging = true ; bool allTests = false ; TestFunc testFunc = nullptr ; if ( argc >= 2 ) { if ( ! strcasecmp ( argv [ 1 ] , " all " ) ) { allTests = true ; } for ( auto f : availableTests ) { if ( ! strcasecmp ( argv [ 1 ] , f . name ) ) { testFunc = f . func ; break ; } } } if ( allTests ) { int passes = 0 ; int fails = 0 ; for ( auto f : availableTests ) { if ( f . func ( ) ) { ++ passes ; } else { printf ( " % s : ▁ FAILED \n " , f . name ) ; ++ fails ; } } if ( passes > 0 ) { printf ( " % d ▁ tests ▁ passed . \n " , passes ) ; } if ( fails > 0 ) { return 2 ; } } else if ( testFunc == nullptr ) { fprintf ( stderr , " You ▁ may ▁ select ▁ a ▁ test ▁ to ▁ run ▁ by ▁ passing ▁ an ▁ argument . \n " ) ; fprintf ( stderr , " \n " ) ; fprintf ( stderr , " Available ▁ tests : \n " ) ; for ( auto f : availableTests ) { fprintf ( stderr , " ▁ ▁ * ▁ % s \n " , f . name ) ; } return 1 ; } else { if ( ! testFunc ( ) ) { return 2 ; } } return 0 ; } </DOCUMENT>
<DOCUMENT_ID="dklann/rivendel@@ l/tree/master/lib/rdlist_logs.cpp"> # include " rdapplication . h " # include " rddb . h " # include " rdescape _ string . h " # include " rdlist _ logs . h " RDListLogs :: RDListLogs ( QString * logname , RDLogFilter :: FilterMode mode , QWidget * parent ) : RDDialog ( parent ) { list_logname = logname ; setMinimumSize ( sizeHint ( ) ) ; setWindowTitle ( tr ( " Select ▁ Log " ) ) ; list_filter_widget = new RDLogFilter ( mode , this ) ; connect ( list_filter_widget , SIGNAL ( filterChanged ( const QString & ) ) , this , SLOT ( filterChangedData ( const QString & ) ) ) ; list_log_list = new Q3ListView ( this ) ; list_log_list -> setAllColumnsShow@@ Focus ( true ) ; list_log_list -> setItemMargin ( 5 ) ; list_log_list -> setSelectionMode ( Q3ListView :: Single ) ; connect ( list_log_list , SIGNAL ( doubleClicked ( Q3ListViewItem * , const QPoint & , int ) ) , this , SLOT ( doubleClickedData ( Q3ListViewItem * , const QPoint & , int ) ) ) ; list_log_list -> addColumn ( tr ( " Name " ) ) ; list_log_list -> setColumnAlignment ( 0 , Qt :: AlignLeft ) ; list_log_list -> addColumn ( tr ( " Description " ) ) ; list_log_list -> setColumnAlignment ( 1 , Qt :: AlignLeft ) ; list_log_list -> addColumn ( tr ( " Service " ) ) ; list_log_list -> setColumnAlignment ( 2 , Qt :: AlignLeft ) ; list_ok_button = new QPushButton ( this ) ; list_ok_button -> setFont ( buttonFont ( ) ) ; list_ok_button -> setText ( tr ( " OK " ) ) ; connect ( list_ok_button , SIGNAL ( clicked ( ) ) , this , SLOT ( okButtonData ( ) ) ) ; list_cancel_button = new QPushButton ( this ) ; list_cancel_button -> setFont ( buttonFont ( ) ) ; list_cancel_button -> setText ( tr ( " Cancel " ) ) ; list_cancel_button -> setDefault ( true ) ; connect ( list_cancel_button , SIGNAL ( clicked ( ) ) , this , SLOT ( cancelButtonData ( ) ) ) ; RefreshList ( ) ; } QSize RDListLogs :: sizeHint ( ) const { return QSize ( 500 , 300 ) ; } QSizePolicy RDListLogs :: sizePolicy ( ) const { return QSizePolicy ( QSizePolicy :: Fixed , QSizePolicy :: Fixed ) ; } void RDListLogs :: closeEvent ( QCloseEvent * e ) { done ( 1 ) ; } void RDListLogs :: filterChangedData ( const QString & where_sql ) { RefreshList ( ) ; } void RDListLogs :: doubleClickedData ( Q3ListViewItem * , const QPoint & , int ) { okButtonData ( ) ; } void RDListLogs :: okButtonData ( ) { Q3ListViewItem * item = list_log_list -> selectedItem ( ) ; if ( item == NULL ) { return ; } * list_logname = item -> text ( 0 ) ; done ( 0 ) ; } void RDListLogs :: cancelButtonData ( ) { done ( 1 ) ; } void RDListLogs :: resizeEvent ( QResizeEvent * e ) { list_filter_widget -> setGeometry ( 10 , 10 , size ( ) . width ( ) - 10 , list_filter_widget -> sizeHint ( ) . height ( ) ) ; list_log_list -> setGeometry ( 10 , list_filter_widget -> sizeHint ( ) . height ( ) , size ( ) . width ( ) - 20 , size ( ) . height ( ) - list_filter_widget -> sizeHint ( ) . height ( ) - 70 ) ; list_ok_button -> setGeometry ( size ( ) . width ( ) - 190 , size ( ) . height ( ) - 60 , 80 , 50 ) ; list_cancel_button -> setGeometry ( size ( ) . width ( ) - 90 , size ( ) . height ( ) - 60 , 80 , 50 ) ; } void RDListLogs :: RefreshList ( ) { RDSqlQuery * q ; QString sql ; Q3ListViewItem * l ; Q3ListViewItem * view_item = NULL ; QDate current_date = QDate :: currentDate ( ) ; list_log_list -> clear ( ) ; sql = QString ( " select ▁ NAME , DESCRIP@@ TION , SERVICE ▁ from ▁ LOGS ▁ " ) + " where ▁ ( TYPE = 0 ) & & ( LOG _ EXISTS = \ " Y\ " ) & & " + " ( ( START _ DATE < = \ " " + current_date . toString ( " yyyy - MM - dd " ) + " \ " ) | | " + " ( START _ DATE = \ " 0000-00-00\ " ) | | " + " ( START _ DATE ▁ is ▁ null ) ) & & " + " ( ( END _ DATE > = \ " " + current_date . toString ( " yyyy - MM - dd " ) + " \ " ) | | " + " ( END _ DATE = \ " 0000-00-00\ " ) | | " + " ( END _ DATE ▁ is ▁ null ) ) " + list_filter_widget -> whereSql ( ) ; q = new RDSqlQuery ( sql ) ; while ( q -> next ( ) ) { l = new Q3ListViewItem ( list_log_list ) ; l -> setText ( 0 , q -> value ( 0 ) . toString ( ) ) ; l -> setText ( 1 , q -> value ( 1 ) . toString ( ) ) ; l -> setText ( 2 , q -> value ( 2 ) . toString ( ) ) ; if ( l -> text ( 0 ) == * list_logname ) { view_item = l ; } } delete q ; if ( view_item != NULL ) { list_log_list -> setCurrentItem ( view_item ) ; list_log_list -> ensureItemVisible ( view_item ) ; } } </DOCUMENT>
<DOCUMENT_ID="sneiil@@ er/ardupilot/tree/master/libraries/AP_@@ HAL/uti@@ lity/getopt_cpp.cpp"> # include " getopt _ cpp . h " # include < stdio . h > # include < string . h > GetOptLong :: GetOptLong ( int _argc , char * const _argv [ ] , const char * _optstring , const GetOptLong :: option * _longopts ) : opterr ( 0 ) , optind ( 1 ) , optopt ( 0 ) , longindex ( - 1 ) , optarg ( NULL ) , argc ( _argc ) , argv ( _argv ) , optstring ( _optstring ) , longopts ( _longopts ) , place ( " " ) { } int GetOptLong :: getoption ( void ) { const char * oli ; if ( ! * place ) { if ( optind >= argc ) { place = " " ; return - 1 ; } place = argv [ optind ] ; if ( place [ 0 ] != ' - ' ) { place = " " ; return - 1 ; } place ++ ; if ( place [ 0 ] && place [ 0 ] == ' - ' && place [ 1 ] == ' \0' ) { ++ optind ; place = " " ; return - 1 ; } if ( place [ 0 ] && place [ 0 ] == ' - ' && place [ 1 ] ) { size_t namelen ; int i ; place ++ ; namelen = strcspn ( place , " = " ) ; for ( i = 0 ; longopts [ i ] . name != NULL ; i ++ ) { if ( strlen ( longopts [ i ] . name ) == namelen && strncmp ( place , longopts [ i ] . name , namelen ) == 0 ) { if ( longopts [ i ] . has_arg ) { if ( place [ namelen ] == ' = ' ) optarg = place + namelen + 1 ; else if ( optind < argc - 1 ) { optind ++ ; optarg = argv [ optind ] ; } else { if ( optstring [ 0 ] == ' : ' ) return BADARG ; if ( opterr ) fprintf ( stderr , " % s : ▁ option ▁ requires ▁ an ▁ argument ▁ - - ▁ % s \n " , argv [ 0 ] , place ) ; place = " " ; optind ++ ; return BADCH ; } } else { optarg = NULL ; if ( place [ namelen ] != 0 ) { } } optind ++ ; longindex = i ; place = " " ; if ( longopts [ i ] . flag == NULL ) return longopts [ i ] . val ; else { * longopts [ i ] . flag = longopts [ i ] . val ; return 0 ; } } } if ( opterr && optstring [ 0 ] != ' : ' ) fprintf ( stderr , " % s : ▁ illegal ▁ option ▁ - - ▁ % s \n " , argv [ 0 ] , place ) ; place = " " ; optind ++ ; return BADCH ; } } optopt = ( int ) * place ++ ; oli = strchr ( optstring , optopt ) ; if ( ! oli ) { if ( ! * place ) ++ optind ; if ( opterr && * optstring != ' : ' ) fprintf ( stderr , " % s : ▁ illegal ▁ option ▁ - - ▁ % c \n " , argv [ 0 ] , optopt ) ; return BADCH ; } if ( oli [ 1 ] != ' : ' ) { optarg = NULL ; if ( ! * place ) ++ optind ; } else { if ( * place ) optarg = place ; else if ( argc <= ++ optind ) { place = " " ; if ( * optstring == ' : ' ) return BADARG ; if ( opterr ) fprintf ( stderr , " % s : ▁ option ▁ requires ▁ an ▁ argument ▁ - - ▁ % c \n " , argv [ 0 ] , optopt ) ; return BADCH ; } else optarg = argv [ optind ] ; place = " " ; ++ optind ; } return optopt ; } </DOCUMENT>
<DOCUMENT_ID="dominik-th@@ /xbmc/tree/master/xbmc/ApplicationPlayer@@ .cpp"> # include " ApplicationPlayer . h " # include " cores / IPlayer . h " # include " Application . h " # include " settings / MediaSettings . h " CApplicationPlayer :: CApplicationPlayer ( ) { m_iPlayerOPSeq = 0 ; m_eCurrentPlayer = EPC_NONE ; } std :: shared_ptr < IPlayer > CApplicationPlayer :: GetInternal ( ) const { CSingleLock lock ( m_player_lock ) ; return m_pPlayer ; } void CApplicationPlayer :: ClosePlayer ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { CloseFile ( ) ; CSingleLock lock ( m_player_lock ) ; m_pPlayer . reset ( ) ; } } void CApplicationPlayer :: CloseFile ( bool reopen ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { ++ m_iPlayerOPSeq ; player -> CloseFile ( reopen ) ; } } void CApplicationPlayer :: ClosePlayerGap@@ less ( PLAYERCOREID newCore ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( ! player ) return ; bool gaplessSupported = ( m_eCurrentPlayer == EPC_DVDPLAYER || m_eCurrentPlayer == EPC_PAP@@ LAYER ) ; gaplessSupported = gaplessSupported && ( m_eCurrentPlayer == newCore ) ; if ( ! gaplessSupported ) { ClosePlayer ( ) ; } else { CloseFile ( true ) ; } } void CApplicationPlayer :: CreatePlayer ( PLAYERCOREID newCore , IPlayer@@ Callback & callback ) { CSingleLock lock ( m_player_lock ) ; if ( ! m_pPlayer ) { m_eCurrentPlayer = newCore ; m_pPlayer . reset ( CPlayerCoreFactory :: Get ( ) . CreatePlayer ( newCore , callback ) ) ; } } PlayBackRet CApplicationPlayer :: OpenFile ( const CFileItem & item , const CPlayerOptions & options ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; PlayBackRet iResult = PLAYBACK_FAIL ; if ( player ) { unsigned int startingSeq = ++ m_iPlayerOPSeq ; iResult = player -> OpenFile ( item , options ) ? PLAYBACK_@@ OK : PLAYBACK_FAIL ; if ( m_iPlayerOPSeq != startingSeq ) iResult = PLAYBACK@@ _CANC@@ ELED ; } return iResult ; } bool CApplicationPlayer :: HasPlayer ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return player != NULL ; } int CApplicationPlayer :: GetChapter ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetChapter ( ) ; else return - 1 ; } int CApplicationPlayer :: GetChapterCount ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetChapterCount ( ) ; else return 0 ; } void CApplicationPlayer :: GetChapterName ( std :: string & strChapterName , int chapterIdx ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetChapterName ( strChapterName , chapterIdx ) ; } int64_t CApplicationPlayer :: GetChapterPos ( int chapterIdx ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetChapterPos ( chapterIdx ) ; return - 1 ; } bool CApplicationPlayer :: HasAudio ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> HasAudio ( ) ) ; } bool CApplicationPlayer :: HasVideo ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> HasVideo ( ) ) ; } int CApplicationPlayer :: GetPreferred@@ Playlist ( ) const { if ( IsPlayingVideo ( ) ) return PLAYLIST_VIDEO ; if ( IsPlayingAudio ( ) ) return PLAYLIST_MUSIC ; return PLAYLIST_NONE ; } bool CApplicationPlayer :: IsPaused ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsPaused ( ) ) ; } bool CApplicationPlayer :: IsPlaying ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsPlaying ( ) ) ; } bool CApplicationPlayer :: IsPausedPlayback ( ) const { return ( IsPlaying ( ) && IsPaused ( ) ) ; } bool CApplicationPlayer :: IsPlayingAudio ( ) const { return ( IsPlaying ( ) && ! HasVideo ( ) && HasAudio ( ) ) ; } bool CApplicationPlayer :: IsPlayingVideo ( ) const { return ( IsPlaying ( ) && HasVideo ( ) ) ; } void CApplicationPlayer :: Pause ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> Pause ( ) ; } bool CApplicationPlayer :: ControlsVolume ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> ControlsVolume ( ) ) ; } void CApplicationPlayer :: SetMute ( bool bOnOff ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetMute ( bOnOff ) ; } void CApplicationPlayer :: SetVolume ( float volume ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetVolume ( volume ) ; } void CApplicationPlayer :: Seek ( bool bPlus , bool bLargeStep , bool bChapterOverride ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> Seek ( bPlus , bLargeStep , bChapterOverride ) ; } void CApplicationPlayer :: SeekPercentage ( float fPercent ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SeekPercentage ( fPercent ) ; } bool CApplicationPlayer :: IsPassthrough ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsPassthrough ( ) ) ; } bool CApplicationPlayer :: CanSeek ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> CanSeek ( ) ) ; } bool CApplicationPlayer :: SeekScene ( bool bPlus ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> SeekScene ( bPlus ) ) ; } void CApplicationPlayer :: SeekTime ( int64_t iTime ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SeekTime ( iTime ) ; } void CApplicationPlayer :: SeekTimeRelative ( int64_t iTime ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { if ( ! player -> SeekTimeRelative ( iTime ) ) { int64_t abstime = player -> GetTime ( ) + iTime ; player -> SeekTime ( abstime ) ; } } } std :: string CApplicationPlayer :: GetPlayingTitle ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetPlayingTitle ( ) ; else return " " ; } int64_t CApplicationPlayer :: GetTime ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetTime ( ) ; else return 0 ; } int64_t CApplicationPlayer :: GetDisplayTime ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetDisplayTime ( ) ; else return 0 ; } bool CApplicationPlayer :: IsCaching ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsCaching ( ) ) ; } bool CApplicationPlayer :: IsInMenu ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsInMenu ( ) ) ; } bool CApplicationPlayer :: HasMenu ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> HasMenu ( ) ) ; } int CApplicationPlayer :: GetCacheLevel ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetCacheLevel ( ) ; else return 0 ; } int CApplicationPlayer :: GetSubtitleCount ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetSubtitleCount ( ) ; else return 0 ; } int CApplicationPlayer :: GetAudioStream ( ) { if ( ! m_audioStreamUpdate . IsTimePast ( ) ) return m_iAudioStream ; std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { m_iAudioStream = player -> GetAudioStream ( ) ; m_audioStreamUpdate . Set ( 1000 ) ; return m_iAudioStream ; } else return 0 ; } int CApplicationPlayer :: GetSubtitle ( ) { if ( ! m_subtitleStreamUpdate . IsTimePast ( ) ) return m_iSubtitleStream ; std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { m_iSubtitleStream = player -> GetSubtitle ( ) ; m_subtitleStreamUpdate . Set ( 1000 ) ; return m_iSubtitleStream ; } else return 0 ; } bool CApplicationPlayer :: GetSubtitleVisible ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> GetSubtitleVisible ( ) ) ; } bool CApplicationPlayer :: CanRecord ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> CanRecord ( ) ) ; } bool CApplicationPlayer :: CanPause ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> CanPause ( ) ) ; } bool CApplicationPlayer :: IsRecording ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsRecording ( ) ) ; } TextCache@@ Struct_t * CApplicationPlayer :: GetTeletextCache ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetTeletextCache ( ) ; else return NULL ; } int64_t CApplicationPlayer :: GetTotalTime ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetTotalTime ( ) ; else return 0 ; } float CApplicationPlayer :: GetPercentage ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetPercentage ( ) ; else return 0.0 ; } float CApplicationPlayer :: GetCachePercentage ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetCachePercentage ( ) ; else return 0.0 ; } void CApplicationPlayer :: ToFFRW ( int iSpeed ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> ToFFRW ( iSpeed ) ; } void CApplicationPlayer :: DoAudioWork ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> DoAudioWork ( ) ; } std :: string CApplicationPlayer :: GetPlayerState ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetPlayerState ( ) ; else return " " ; } bool CApplicationPlayer :: QueueNextFile ( const CFileItem & file ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> QueueNextFile ( file ) ) ; } bool CApplicationPlayer :: GetStreamDetails ( CStreamDetails & details ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> GetStreamDetails ( details ) ) ; } bool CApplicationPlayer :: SetPlayerState ( const std :: string & state ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> SetPlayerState ( state ) ) ; } void CApplicationPlayer :: OnNothingToQueueNotify ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OnNothingToQueueNotify ( ) ; } void CApplicationPlayer :: GetVideoStreamInfo ( SPlayerVideoStreamInfo & info ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetVideoStreamInfo ( info ) ; } void CApplicationPlayer :: GetAudioStreamInfo ( int index , SPlayerAudioStreamInfo & info ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetAudioStreamInfo ( index , info ) ; } bool CApplicationPlayer :: OnAction ( const CAction & action ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> OnAction ( action ) ) ; } bool CApplicationPlayer :: Record ( bool bOnOff ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> Record ( bOnOff ) ) ; } int CApplicationPlayer :: GetAudioStreamCount ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetAudioStreamCount ( ) ; else return 0 ; } void CApplicationPlayer :: SetAudioStream ( int iStream ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { player -> SetAudioStream ( iStream ) ; m_iAudioStream = iStream ; m_audioStreamUpdate . Set ( 1000 ) ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_AudioStream = iStream ; } } void CApplicationPlayer :: GetSubtitleStreamInfo ( int index , SPlayerSubtitleStreamInfo & info ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetSubtitleStreamInfo ( index , info ) ; } void CApplicationPlayer :: SetSubtitle ( int iStream ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { player -> SetSubtitle ( iStream ) ; m_iSubtitleStream = iStream ; m_subtitleStreamUpdate . Set ( 1000 ) ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_SubtitleStream = iStream ; } } void CApplicationPlayer :: SetSubtitleVisible ( bool bVisible ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { player -> SetSubtitleVisible ( bVisible ) ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_SubtitleOn = bVisible ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_SubtitleStream = player -> GetSubtitle ( ) ; } } void CApplicationPlayer :: AddSubtitle ( const std :: string & strSubPath ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> AddSubtitle ( strSubPath ) ; } void CApplicationPlayer :: SetSubTitleDelay ( float fValue ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetSubTitleDelay ( fValue ) ; } void CApplicationPlayer :: SetAVDelay ( float fValue ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetAVDelay ( fValue ) ; } void CApplicationPlayer :: SetDynamicRangeCompression ( long drc ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetDynamicRangeCompression ( drc ) ; } bool CApplicationPlayer :: SwitchChannel ( const PVR :: CPVRChannel@@ Ptr & channel ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> SwitchChannel ( channel ) ) ; } void CApplicationPlayer :: LoadPage ( int p , int sp , unsigned char * buffer ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> LoadPage ( p , sp , buffer ) ; } void CApplicationPlayer :: GetAudioCapabilities ( std :: vector < int > & audioCaps ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetAudioCapabilities ( audioCaps ) ; } void CApplicationPlayer :: GetSubtitleCapabilities ( std :: vector < int > & subCaps ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetSubtitleCapabilities ( subCaps ) ; } void CApplicationPlayer :: GetAudioInfo ( std :: string & strAudioInfo ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetAudioInfo ( strAudioInfo ) ; } void CApplicationPlayer :: GetVideoInfo ( std :: string & strVideoInfo ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetVideoInfo ( strVideoInfo ) ; } void CApplicationPlayer :: GetGeneralInfo ( std :: string & strVideoInfo ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetGeneralInfo ( strVideoInfo ) ; } int CApplicationPlayer :: SeekChapter ( int iChapter ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> SeekChapter ( iChapter ) ; else return 0 ; } void CApplicationPlayer :: GetRenderFeatures ( std :: vector < int > & renderFeatures ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGetRenderFeatures ( renderFeatures ) ; } void CApplicationPlayer :: GetDeinterlaceMethods ( std :: vector < int > & deinterlaceMethods ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGetDeinterlaceMethods ( deinterlaceMethods ) ; } void CApplicationPlayer :: GetDeinterlaceModes ( std :: vector < int > & deinterlaceModes ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGetDeinterlaceModes ( deinterlaceModes ) ; } void CApplicationPlayer :: GetScalingMethods ( std :: vector < int > & scalingMethods ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGetScalingMethods ( scalingMethods ) ; } void CApplicationPlayer :: SetPlaySpeed ( int iSpeed , bool bApplicationMuted ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( ! player ) return ; if ( ! IsPlayingAudio ( ) && ! IsPlayingVideo ( ) ) return ; if ( m_iPlaySpeed == iSpeed ) return ; if ( ! CanSeek ( ) ) return ; if ( IsPaused ( ) ) { if ( ( ( m_iPlaySpeed > 1 ) && ( iSpeed > m_iPlaySpeed ) ) || ( ( m_iPlaySpeed < - 1 ) && ( iSpeed < m_iPlaySpeed ) ) ) { iSpeed = m_iPlaySpeed ; } Pause ( ) ; } m_iPlaySpeed = iSpeed ; ToFFRW ( m_iPlaySpeed ) ; if ( ControlsVolume ( ) ) { if ( m_iPlaySpeed == 1 ) { player -> SetVolume ( g_application . GetVolume ( false ) ) ; } else { player -> SetVolume ( VOLUME_MIN@@ IMUM ) ; } player -> SetMute ( bApplicationMuted ) ; } } int CApplicationPlayer :: GetPlaySpeed ( ) const { return m_iPlaySpeed ; } </DOCUMENT>
<DOCUMENT_ID="gro@@ kys/coreclr/tree/master/src/@@ vm/common.cpp"> # include " common . h " </DOCUMENT>
<DOCUMENT_ID="lope@@ zloo/mt@@ asa-blue/tree/master/Client/mod@@ s/deathmatch@@ /logic/CCustom@@ Data.cpp"> # include " StdInc . h " # define DECLARE_PROFIL@@ ER_SECTION@@ _CCustomData # include " profiler / SharedUtil . Profiler . h " void CCustomData :: Copy ( CCustomData * pCustomData ) { std :: map < std :: string , SCustomData > :: const_iterator iter = pCustomData -> IterBegin ( ) ; for ( ; iter != pCustomData -> IterEnd ( ) ; iter ++ ) { Set ( iter -> first . c_str ( ) , iter -> second . Variable ) ; } } SCustomData * CCustomData :: Get ( const char * szName ) { assert ( szName ) ; std :: map < std :: string , SCustomData > :: iterator it = m_Data . find ( szName ) ; if ( it != m_Data . end ( ) ) return & it -> second ; return NULL ; } void CCustomData :: Set ( const char * szName , const CLuaArgument & Variable , bool bSynchronized ) { assert ( szName ) ; SCustomData * pData = Get ( szName ) ; if ( pData ) { pData -> Variable = Variable ; pData -> bSynchronized = bSynchronized ; } else { SCustomData newData ; newData . Variable = Variable ; newData . bSynchronized = bSynchronized ; m_Data [ szName ] = newData ; } } bool CCustomData :: Delete ( const char * szName ) { std :: map < std :: string , SCustomData > :: iterator it = m_Data . find ( szName ) ; if ( it != m_Data . end ( ) ) { m_Data . erase ( it ) ; return true ; } return false ; } </DOCUMENT>
<DOCUMENT_ID="tony--/WinObjC/tree/master/deps/3rdparty/ic@@ ulegacy/source/i18n/r@@ btz.cpp"> # include < typeinfo > # include " unicode / utypes . h " # if ! UCONFIG_NO_FORMATTING # include " unicode / rbtz . h " # include " unicode / gregocal . h " # include " uvector . h " # include " gregoimp . h " # include " cmemory . h " U_NAMESPACE_BEGIN struct Transition { UDate time ; TimeZoneRule * from ; TimeZoneRule * to ; } ; static UBool compareRules ( UVector * rules1 , UVector * rules2 ) { if ( rules1 == NULL && rules2 == NULL ) { return TRUE ; } else if ( rules1 == NULL || rules2 == NULL ) { return FALSE ; } int32_t size = rules1 -> size ( ) ; if ( size != rules2 -> size ( ) ) { return FALSE ; } for ( int32_t i = 0 ; i < size ; i ++ ) { TimeZoneRule * r1 = ( TimeZoneRule * ) rules1 -> elementAt ( i ) ; TimeZoneRule * r2 = ( TimeZoneRule * ) rules2 -> elementAt ( i ) ; if ( * r1 != * r2 ) { return FALSE ; } } return TRUE ; } UOBJECT_DEFINE_RTTI_IMPLEMENTATION ( RuleBasedTimeZone ) RuleBasedTimeZone :: RuleBasedTimeZone ( const UnicodeString & id , InitialTimeZoneRule * initialRule ) : BasicTimeZone ( id ) , fInitialRule ( initialRule ) , fHistoricRules ( NULL ) , fFinalRules ( NULL ) , fHistoricTransitions ( NULL ) , fUpToDate ( FALSE ) { } RuleBasedTimeZone :: RuleBasedTimeZone ( const RuleBasedTimeZone & source ) : BasicTimeZone ( source ) , fInitialRule ( source . fInitialRule -> clone ( ) ) , fHistoricTransitions ( NULL ) , fUpToDate ( FALSE ) { fHistoricRules = copyRules ( source . fHistoricRules ) ; fFinalRules = copyRules ( source . fFinalRules ) ; if ( source . fUpToDate ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; } } RuleBasedTimeZone :: ~ RuleBasedTimeZone ( ) { deleteTransitions ( ) ; deleteRules ( ) ; } RuleBasedTimeZone & RuleBasedTimeZone :: operator = ( const RuleBasedTimeZone & right ) { if ( * this != right ) { BasicTimeZone :: operator = ( right ) ; deleteRules ( ) ; fInitialRule = right . fInitialRule -> clone ( ) ; fHistoricRules = copyRules ( right . fHistoricRules ) ; fFinalRules = copyRules ( right . fFinalRules ) ; deleteTransitions ( ) ; fUpToDate = FALSE ; } return * this ; } UBool RuleBasedTimeZone :: operator == ( const TimeZone & that ) const { if ( this == & that ) { return TRUE ; } if ( typeid ( * this ) != typeid ( that ) || BasicTimeZone :: operator == ( that ) == FALSE ) { return FALSE ; } RuleBasedTimeZone * rbtz = ( RuleBasedTimeZone * ) & that ; if ( * fInitialRule != * ( rbtz -> fInitialRule ) ) { return FALSE ; } if ( compareRules ( fHistoricRules , rbtz -> fHistoricRules ) && compareRules ( fFinalRules , rbtz -> fFinalRules ) ) { return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: operator != ( const TimeZone & that ) const { return ! operator == ( that ) ; } void RuleBasedTimeZone :: addTransitionRule ( TimeZoneRule * rule , UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } AnnualTimeZoneRule * atzrule = dynamic_cast < AnnualTimeZoneRule * > ( rule ) ; if ( atzrule != NULL && atzrule -> getEndYear ( ) == AnnualTimeZoneRule :: MAX_YEAR ) { if ( fFinalRules == NULL ) { fFinalRules = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { return ; } } else if ( fFinalRules -> size ( ) >= 2 ) { status = U_INVALID_STATE_ERROR ; return ; } fFinalRules -> addElement ( ( void * ) rule , status ) ; } else { if ( fHistoricRules == NULL ) { fHistoricRules = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { return ; } } fHistoricRules -> addElement ( ( void * ) rule , status ) ; } fUpToDate = FALSE ; } void RuleBasedTimeZone :: complete ( UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } if ( fUpToDate ) { return ; } if ( fFinalRules != NULL && fFinalRules -> size ( ) != 2 ) { status = U_INVALID_STATE_ERROR ; return ; } UBool * done = NULL ; if ( fHistoricRules != NULL || fFinalRules != NULL ) { TimeZoneRule * curRule = fInitialRule ; UDate lastTransitionTime = MIN_MILLIS ; if ( fHistoricRules != NULL && fHistoricRules -> size ( ) > 0 ) { int32_t i ; int32_t historicCount = fHistoricRules -> size ( ) ; done = ( UBool * ) uprv_malloc ( sizeof ( UBool ) * historicCount ) ; if ( done == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } for ( i = 0 ; i < historicCount ; i ++ ) { done [ i ] = FALSE ; } while ( TRUE ) { int32_t curStdOffset = curRule -> getRawOffset ( ) ; int32_t curDstSavings = curRule -> getDSTSavings ( ) ; UDate nextTransitionTime = MAX_MILLIS ; TimeZoneRule * nextRule = NULL ; TimeZoneRule * r = NULL ; UBool avail ; UDate tt ; UnicodeString curName , name ; curRule -> getName ( curName ) ; for ( i = 0 ; i < historicCount ; i ++ ) { if ( done [ i ] ) { continue ; } r = ( TimeZoneRule * ) fHistoricRules -> elementAt ( i ) ; avail = r -> getNextStart ( lastTransitionTime , curStdOffset , curDstSavings , false , tt ) ; if ( ! avail ) { done [ i ] = TRUE ; } else { r -> getName ( name ) ; if ( * r == * curRule || ( name == curName && r -> getRawOffset ( ) == curRule -> getRawOffset ( ) && r -> getDSTSavings ( ) == curRule -> getDSTSavings ( ) ) ) { continue ; } if ( tt < nextTransitionTime ) { nextTransitionTime = tt ; nextRule = r ; } } } if ( nextRule == NULL ) { UBool bDoneAll = TRUE ; for ( int32_t j = 0 ; j < historicCount ; j ++ ) { if ( ! done [ j ] ) { bDoneAll = FALSE ; break ; } } if ( bDoneAll ) { break ; } } if ( fFinalRules != NULL ) { for ( i = 0 ; i < 2 ; i ++ ) { TimeZoneRule * fr = ( TimeZoneRule * ) fFinalRules -> elementAt ( i ) ; if ( * fr == * curRule ) { continue ; } r = ( TimeZoneRule * ) fFinalRules -> elementAt ( i ) ; avail = r -> getNextStart ( lastTransitionTime , curStdOffset , curDstSavings , false , tt ) ; if ( avail ) { if ( tt < nextTransitionTime ) { nextTransitionTime = tt ; nextRule = r ; } } } } if ( nextRule == NULL ) { break ; } if ( fHistoricTransitions == NULL ) { fHistoricTransitions = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } Transition * trst = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( trst == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } trst -> time = nextTransitionTime ; trst -> from = curRule ; trst -> to = nextRule ; fHistoricTransitions -> addElement ( trst , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } lastTransitionTime = nextTransitionTime ; curRule = nextRule ; } } if ( fFinalRules != NULL ) { if ( fHistoricTransitions == NULL ) { fHistoricTransitions = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } TimeZoneRule * rule0 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; TimeZoneRule * rule1 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; UDate tt0 , tt1 ; UBool avail0 = rule0 -> getNextStart ( lastTransitionTime , curRule -> getRawOffset ( ) , curRule -> getDSTSavings ( ) , false , tt0 ) ; UBool avail1 = rule1 -> getNextStart ( lastTransitionTime , curRule -> getRawOffset ( ) , curRule -> getDSTSavings ( ) , false , tt1 ) ; if ( ! avail0 || ! avail1 ) { status = U_INVALID_STATE_ERROR ; goto cleanup ; } Transition * final0 = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( final0 == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } Transition * final1 = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( final1 == NULL ) { uprv_free ( final0 ) ; status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } if ( tt0 < tt1 ) { final0 -> time = tt0 ; final0 -> from = curRule ; final0 -> to = rule0 ; rule1 -> getNextStart ( tt0 , rule0 -> getRawOffset ( ) , rule0 -> getDSTSavings ( ) , false , final1 -> time ) ; final1 -> from = rule0 ; final1 -> to = rule1 ; } else { final0 -> time = tt1 ; final0 -> from = curRule ; final0 -> to = rule1 ; rule0 -> getNextStart ( tt1 , rule1 -> getRawOffset ( ) , rule1 -> getDSTSavings ( ) , false , final1 -> time ) ; final1 -> from = rule1 ; final1 -> to = rule0 ; } fHistoricTransitions -> addElement ( final0 , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } fHistoricTransitions -> addElement ( final1 , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } } fUpToDate = TRUE ; if ( done != NULL ) { uprv_free ( done ) ; } return ; cleanup : deleteTransitions ( ) ; if ( done != NULL ) { uprv_free ( done ) ; } fUpToDate = FALSE ; } TimeZone * RuleBasedTimeZone :: clone ( void ) const { return new RuleBasedTimeZone ( * this ) ; } int32_t RuleBasedTimeZone :: getOffset ( uint8_t era , int32_t year , int32_t month , int32_t day , uint8_t dayOfWeek , int32_t millis , UErrorCode & status ) const { if ( U_FAILURE ( status ) ) { return 0 ; } if ( month < UCAL_JAN@@ UARY || month > UCAL_DECEMB@@ ER ) { status = U_ILLEGAL_ARGUMENT_ERROR ; return 0 ; } else { return getOffset ( era , year , month , day , dayOfWeek , millis , Grego :: monthLength ( year , month ) , status ) ; } } int32_t RuleBasedTimeZone :: getOffset ( uint8_t era , int32_t year , int32_t month , int32_t day , uint8_t , int32_t millis , int32_t , UErrorCode & status ) const { if ( U_FAILURE ( status ) ) { return 0 ; } if ( era == GregorianCalendar :: BC ) { year = 1 - year ; } int32_t rawOffset , dstOffset ; UDate time = ( UDate ) Grego :: fieldsTo@@ Day ( year , month , day ) * U_MILLIS_PER_DAY + millis ; getOffsetInternal ( time , TRUE , kDaylight , kStandard , rawOffset , dstOffset , status ) ; if ( U_FAILURE ( status ) ) { return 0 ; } return ( rawOffset + dstOffset ) ; } void RuleBasedTimeZone :: getOffset ( UDate date , UBool local , int32_t & rawOffset , int32_t & dstOffset , UErrorCode & status ) const { getOffsetInternal ( date , local , kFormer , kLatter , rawOffset , dstOffset , status ) ; } void RuleBasedTimeZone :: getOffsetFromLocal ( UDate date , int32_t nonExistingTimeOpt , int32_t duplicatedTimeOpt , int32_t & rawOffset , int32_t & dstOffset , UErrorCode & status ) { getOffsetInternal ( date , TRUE , nonExistingTimeOpt , duplicatedTimeOpt , rawOffset , dstOffset , status ) ; } void RuleBasedTimeZone :: getOffsetInternal ( UDate date , UBool local , int32_t NonExistingTimeOpt , int32_t DuplicatedTimeOpt , int32_t & rawOffset , int32_t & dstOffset , UErrorCode & status ) const { rawOffset = 0 ; dstOffset = 0 ; if ( U_FAILURE ( status ) ) { return ; } if ( ! fUpToDate ) { status = U_INVALID_STATE_ERROR ; return ; } const TimeZoneRule * rule = NULL ; if ( fHistoricTransitions == NULL ) { rule = fInitialRule ; } else { UDate tstart = getTransitionTime ( ( Transition * ) fHistoricTransitions -> elementAt ( 0 ) , local , NonExistingTimeOpt , DuplicatedTimeOpt ) ; if ( date < tstart ) { rule = fInitialRule ; } else { int32_t idx = fHistoricTransitions -> size ( ) - 1 ; UDate tend = getTransitionTime ( ( Transition * ) fHistoricTransitions -> elementAt ( idx ) , local , NonExistingTimeOpt , DuplicatedTimeOpt ) ; if ( date > tend ) { if ( fFinalRules != NULL ) { rule = findRuleInFinal ( date , local , NonExistingTimeOpt , DuplicatedTimeOpt ) ; } else { rule = ( ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ) -> to ; } } else { while ( idx >= 0 ) { if ( date >= getTransitionTime ( ( Transition * ) fHistoricTransitions -> elementAt ( idx ) , local , NonExistingTimeOpt , DuplicatedTimeOpt ) ) { break ; } idx -- ; } rule = ( ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ) -> to ; } } } if ( rule != NULL ) { rawOffset = rule -> getRawOffset ( ) ; dstOffset = rule -> getDSTSavings ( ) ; } } void RuleBasedTimeZone :: setRawOffset ( int32_t ) { } int32_t RuleBasedTimeZone :: getRawOffset ( void ) const { UErrorCode status = U_ZERO_ERROR ; int32_t raw , dst ; getOffset ( uprv_getUTCtime ( ) * U_MILLIS_PER_SECOND , FALSE , raw , dst , status ) ; return raw ; } UBool RuleBasedTimeZone :: useDaylightTime ( void ) const { UErrorCode status = U_ZERO_ERROR ; UDate now = uprv_getUTCtime ( ) * U_MILLIS_PER_SECOND ; int32_t raw , dst ; getOffset ( now , FALSE , raw , dst , status ) ; if ( dst != 0 ) { return TRUE ; } UDate time ; TimeZoneRule * from , * to ; UBool avail = findNext ( now , FALSE , time , from , to ) ; if ( avail && to -> getDSTSavings ( ) != 0 ) { return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: inDaylightTime ( UDate date , UErrorCode & status ) const { if ( U_FAILURE ( status ) ) { return FALSE ; } int32_t raw , dst ; getOffset ( date , FALSE , raw , dst , status ) ; if ( dst != 0 ) { return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: hasSame@@ Rules ( const TimeZone & other ) const { if ( this == & other ) { return TRUE ; } if ( typeid ( * this ) != typeid ( other ) ) { return FALSE ; } const RuleBasedTimeZone & that = ( const RuleBasedTimeZone & ) other ; if ( * fInitialRule != * ( that . fInitialRule ) ) { return FALSE ; } if ( compareRules ( fHistoricRules , that . fHistoricRules ) && compareRules ( fFinalRules , that . fFinalRules ) ) { return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: getNextTransition ( UDate base , UBool inclusive , TimeZoneTransition & result ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; if ( U_FAILURE ( status ) ) { return FALSE ; } UDate transitionTime ; TimeZoneRule * fromRule , * toRule ; UBool found = findNext ( base , inclusive , transitionTime , fromRule , toRule ) ; if ( found ) { result . setTime ( transitionTime ) ; result . setFrom ( ( const TimeZoneRule & ) * fromRule ) ; result . setTo ( ( const TimeZoneRule & ) * toRule ) ; return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: getPreviousTransition ( UDate base , UBool inclusive , TimeZoneTransition & result ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; if ( U_FAILURE ( status ) ) { return FALSE ; } UDate transitionTime ; TimeZoneRule * fromRule , * toRule ; UBool found = findPrev ( base , inclusive , transitionTime , fromRule , toRule ) ; if ( found ) { result . setTime ( transitionTime ) ; result . setFrom ( ( const TimeZoneRule & ) * fromRule ) ; result . setTo ( ( const TimeZoneRule & ) * toRule ) ; return TRUE ; } return FALSE ; } int32_t RuleBasedTimeZone :: countTransitionRules ( UErrorCode & ) { int32_t count = 0 ; if ( fHistoricRules != NULL ) { count += fHistoricRules -> size ( ) ; } if ( fFinalRules != NULL ) { count += fFinalRules -> size ( ) ; } return count ; } void RuleBasedTimeZone :: getTimeZoneRules ( const InitialTimeZoneRule * & initial , const TimeZoneRule * trsrules [ ] , int32_t & trscount , UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } initial = fInitialRule ; int32_t cnt = 0 ; int32_t idx ; if ( fHistoricRules != NULL && cnt < trscount ) { int32_t historicCount = fHistoricRules -> size ( ) ; idx = 0 ; while ( cnt < trscount && idx < historicCount ) { trsrules [ cnt ++ ] = ( const TimeZoneRule * ) fHistoricRules -> elementAt ( idx ++ ) ; } } if ( fFinalRules != NULL && cnt < trscount ) { int32_t finalCount = fFinalRules -> size ( ) ; idx = 0 ; while ( cnt < trscount && idx < finalCount ) { trsrules [ cnt ++ ] = ( const TimeZoneRule * ) fFinalRules -> elementAt ( idx ++ ) ; } } trscount = cnt ; } void RuleBasedTimeZone :: deleteRules ( void ) { delete fInitialRule ; fInitialRule = NULL ; if ( fHistoricRules != NULL ) { while ( ! fHistoricRules -> isEmpty ( ) ) { delete ( TimeZoneRule * ) ( fHistoricRules -> orphanElementAt ( 0 ) ) ; } delete fHistoricRules ; fHistoricRules = NULL ; } if ( fFinalRules != NULL ) { while ( ! fFinalRules -> isEmpty ( ) ) { delete ( AnnualTimeZoneRule * ) ( fFinalRules -> orphanElementAt ( 0 ) ) ; } delete fFinalRules ; fFinalRules = NULL ; } } void RuleBasedTimeZone :: deleteTransitions ( void ) { if ( fHistoricTransitions != NULL ) { while ( ! fHistoricTransitions -> isEmpty ( ) ) { Transition * trs = ( Transition * ) fHistoricTransitions -> orphanElementAt ( 0 ) ; uprv_free ( trs ) ; } delete fHistoricTransitions ; } fHistoricTransitions = NULL ; } UVector * RuleBasedTimeZone :: copyRules ( UVector * source ) { if ( source == NULL ) { return NULL ; } UErrorCode ec = U_ZERO_ERROR ; int32_t size = source -> size ( ) ; UVector * rules = new UVector ( size , ec ) ; if ( U_FAILURE ( ec ) ) { return NULL ; } int32_t i ; for ( i = 0 ; i < size ; i ++ ) { rules -> addElement ( ( ( TimeZoneRule * ) source -> elementAt ( i ) ) -> clone ( ) , ec ) ; if ( U_FAILURE ( ec ) ) { break ; } } if ( U_FAILURE ( ec ) ) { for ( i = 0 ; i < rules -> size ( ) ; i ++ ) { TimeZoneRule * rule = ( TimeZoneRule * ) rules -> orphanElementAt ( i ) ; delete rule ; } delete rules ; return NULL ; } return rules ; } TimeZoneRule * RuleBasedTimeZone :: findRuleInFinal ( UDate date , UBool local , int32_t NonExistingTimeOpt , int32_t DuplicatedTimeOpt ) const { if ( fFinalRules == NULL ) { return NULL ; } AnnualTimeZoneRule * fr0 = ( AnnualTimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; AnnualTimeZoneRule * fr1 = ( AnnualTimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; if ( fr0 == NULL || fr1 == NULL ) { return NULL ; } UDate start0 , start1 ; UDate base ; int32_t localDelta ; base = date ; if ( local ) { localDelta = getLocalDelta ( fr1 -> getRawOffset ( ) , fr1 -> getDSTSavings ( ) , fr0 -> getRawOffset ( ) , fr0 -> getDSTSavings ( ) , NonExistingTimeOpt , DuplicatedTimeOpt ) ; base -= localDelta ; } UBool avail0 = fr0 -> getPreviousStart ( base , fr1 -> getRawOffset ( ) , fr1 -> getDSTSavings ( ) , TRUE , start0 ) ; base = date ; if ( local ) { localDelta = getLocalDelta ( fr0 -> getRawOffset ( ) , fr0 -> getDSTSavings ( ) , fr1 -> getRawOffset ( ) , fr1 -> getDSTSavings ( ) , NonExistingTimeOpt , DuplicatedTimeOpt ) ; base -= localDelta ; } UBool avail1 = fr1 -> getPreviousStart ( base , fr0 -> getRawOffset ( ) , fr0 -> getDSTSavings ( ) , TRUE , start1 ) ; if ( avail0 && ( ! avail1 || start0 > start1 ) ) { return fr0 ; } else if ( avail1 ) { return fr1 ; } return NULL ; } UBool RuleBasedTimeZone :: findNext ( UDate base , UBool inclusive , UDate & transitionTime , TimeZoneRule * & fromRule , TimeZoneRule * & toRule ) const { if ( fHistoricTransitions == NULL ) { return FALSE ; } UBool isFinal = FALSE ; UBool found = FALSE ; Transition result ; Transition * tzt = ( Transition * ) fHistoricTransitions -> elementAt ( 0 ) ; UDate tt = tzt -> time ; if ( tt > base || ( inclusive && tt == base ) ) { result = * tzt ; found = TRUE ; } else { int32_t idx = fHistoricTransitions -> size ( ) - 1 ; tzt = ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ; tt = tzt -> time ; if ( inclusive && tt == base ) { result = * tzt ; found = TRUE ; } else if ( tt <= base ) { if ( fFinalRules != NULL ) { TimeZoneRule * r0 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; TimeZoneRule * r1 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; UDate start0 , start1 ; UBool avail0 = r0 -> getNextStart ( base , r1 -> getRawOffset ( ) , r1 -> getDSTSavings ( ) , inclusive , start0 ) ; UBool avail1 = r1 -> getNextStart ( base , r0 -> getRawOffset ( ) , r0 -> getDSTSavings ( ) , inclusive , start1 ) ; if ( ! avail0 && ! avail1 ) { return FALSE ; } if ( ! avail1 || start0 < start1 ) { result . time = start0 ; result . from = r1 ; result . to = r0 ; } else { result . time = start1 ; result . from = r0 ; result . to = r1 ; } isFinal = TRUE ; found = TRUE ; } } else { idx -- ; Transition * prev = tzt ; while ( idx > 0 ) { tzt = ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ; tt = tzt -> time ; if ( tt < base || ( ! inclusive && tt == base ) ) { break ; } idx -- ; prev = tzt ; } result . time = prev -> time ; result . from = prev -> from ; result . to = prev -> to ; found = TRUE ; } } if ( found ) { if ( result . from -> getRawOffset ( ) == result . to -> getRawOffset ( ) && result . from -> getDSTSavings ( ) == result . to -> getDSTSavings ( ) ) { if ( isFinal ) { return FALSE ; } else { return findNext ( result . time , FALSE , transitionTime , fromRule , toRule ) ; } } transitionTime = result . time ; fromRule = result . from ; toRule = result . to ; return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: findPrev ( UDate base , UBool inclusive , UDate & transitionTime , TimeZoneRule * & fromRule , TimeZoneRule * & toRule ) const { if ( fHistoricTransitions == NULL ) { return FALSE ; } UBool found = FALSE ; Transition result ; Transition * tzt = ( Transition * ) fHistoricTransitions -> elementAt ( 0 ) ; UDate tt = tzt -> time ; if ( inclusive && tt == base ) { result = * tzt ; found = TRUE ; } else if ( tt < base ) { int32_t idx = fHistoricTransitions -> size ( ) - 1 ; tzt = ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ; tt = tzt -> time ; if ( inclusive && tt == base ) { result = * tzt ; found = TRUE ; } else if ( tt < base ) { if ( fFinalRules != NULL ) { TimeZoneRule * r0 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; TimeZoneRule * r1 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; UDate start0 , start1 ; UBool avail0 = r0 -> getPreviousStart ( base , r1 -> getRawOffset ( ) , r1 -> getDSTSavings ( ) , inclusive , start0 ) ; UBool avail1 = r1 -> getPreviousStart ( base , r0 -> getRawOffset ( ) , r0 -> getDSTSavings ( ) , inclusive , start1 ) ; if ( ! avail0 && ! avail1 ) { return FALSE ; } if ( ! avail1 || start0 > start1 ) { result . time = start0 ; result . from = r1 ; result . to = r0 ; } else { result . time = start1 ; result . from = r0 ; result . to = r1 ; } } else { result = * tzt ; } found = TRUE ; } else { idx -- ; while ( idx >= 0 ) { tzt = ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ; tt = tzt -> time ; if ( tt < base || ( inclusive && tt == base ) ) { break ; } idx -- ; } result = * tzt ; found = TRUE ; } } if ( found ) { if ( result . from -> getRawOffset ( ) == result . to -> getRawOffset ( ) && result . from -> getDSTSavings ( ) == result . to -> getDSTSavings ( ) ) { return findPrev ( result . time , FALSE , transitionTime , fromRule , toRule ) ; } transitionTime = result . time ; fromRule = result . from ; toRule = result . to ; return TRUE ; } return FALSE ; } UDate RuleBasedTimeZone :: getTransitionTime ( Transition * transition , UBool local , int32_t NonExistingTimeOpt , int32_t DuplicatedTimeOpt ) const { UDate time = transition -> time ; if ( local ) { time += getLocalDelta ( transition -> from -> getRawOffset ( ) , transition -> from -> getDSTSavings ( ) , transition -> to -> getRawOffset ( ) , transition -> to -> getDSTSavings ( ) , NonExistingTimeOpt , DuplicatedTimeOpt ) ; } return time ; } int32_t RuleBasedTimeZone :: getLocalDelta ( int32_t rawBefore , int32_t dstBefore , int32_t rawAfter , int32_t dstAfter , int32_t NonExistingTimeOpt , int32_t DuplicatedTimeOpt ) const { int32_t delta = 0 ; int32_t offsetBefore = rawBefore + dstBefore ; int32_t offsetAfter = rawAfter + dstAfter ; UBool dstToStd = ( dstBefore != 0 ) && ( dstAfter == 0 ) ; UBool stdToDst = ( dstBefore == 0 ) && ( dstAfter != 0 ) ; if ( offsetAfter - offsetBefore >= 0 ) { if ( ( ( NonExistingTimeOpt & kStdDstMask ) == kStandard && dstToStd ) || ( ( NonExistingTimeOpt & kStdDstMask ) == kDaylight && stdToDst ) ) { delta = offsetBefore ; } else if ( ( ( NonExistingTimeOpt & kStdDstMask ) == kStandard && stdToDst ) || ( ( NonExistingTimeOpt & kStdDstMask ) == kDaylight && dstToStd ) ) { delta = offsetAfter ; } else if ( ( NonExistingTimeOpt & kFormerLatterMask ) == kLatter ) { delta = offsetBefore ; } else { delta = offsetAfter ; } } else { if ( ( ( DuplicatedTimeOpt & kStdDstMask ) == kStandard && dstToStd ) || ( ( DuplicatedTimeOpt & kStdDstMask ) == kDaylight && stdToDst ) ) { delta = offsetAfter ; } else if ( ( ( DuplicatedTimeOpt & kStdDstMask ) == kStandard && stdToDst ) || ( ( DuplicatedTimeOpt & kStdDstMask ) == kDaylight && dstToStd ) ) { delta = offsetBefore ; } else if ( ( DuplicatedTimeOpt & kFormerLatterMask ) == kFormer ) { delta = offsetBefore ; } else { delta = offsetAfter ; } } return delta ; } U_NAMESPACE_END # endif </DOCUMENT>
<DOCUMENT_ID="BenKey@@ FSI/poedit/tree/master/deps/boost/libs/wave/test/testwave@@ /testfiles/@@ t_6_@@ 044.cpp"> # define CON ## name CON </DOCUMENT>
<DOCUMENT_ID="Su@@ mahitha/samples/tree/master/@@ AllJoyn/Samples/BACnet@@ Adapter/Head@@ lessAdapterApp/p@@ ch.cpp"> # include " pch . h " </DOCUMENT>
<DOCUMENT_ID="MobW@@ iMetro/gba@@ 10/tree/master/GB@@ A10/VBAM@@ /gba/gbafilter@@ .cpp"> # include " gbafilter . h " # include < math . h > extern int systemColorDepth ; extern int systemRedShift ; extern int systemGreenShift ; extern int systemBlueShift ; extern u16 systemColorMap16 [ 0x10000 ] ; extern u32 systemColorMap32 [ 0x10000 ] ; static const unsigned char curve [ 32 ] = { 0x08 , 0x09 , 0x0a , 0x0b , 0x0c , 0x0e , 0x10 , 0x12 , 0x14 , 0x16 , 0x18 , 0x1c , 0x20 , 0x28 , 0x30 , 0x38 , 0x40 , 0x48 , 0x50 , 0x58 , 0x60 , 0x68 , 0x70 , 0x80 , 0x88 , 0x90 , 0xa0 , 0xb0 , 0xc0 , 0xd0 , 0xe0 , 0xf0 } ; static const unsigned char influence [ 3 * 3 ] = { 16 , 4 , 4 , 8 , 16 , 8 , 0 , 8 , 16 } ; inline void swap ( short & a , short & b ) { short temp = a ; a = b ; b = temp ; } void gbafilter_pal ( u16 * buf , int count ) { short temp [ 3 * 3 ] , s ; unsigned pix ; u8 red , green , blue ; while ( count -- ) { pix = * buf ; s = curve [ ( pix >> systemGreenShift ) & 0x1f ] ; temp [ 3 ] = s * influence [ 3 ] ; temp [ 4 ] = s * influence [ 4 ] ; temp [ 5 ] = s * influence [ 5 ] ; s = curve [ ( pix >> systemRedShift ) & 0x1f ] ; temp [ 0 ] = s * influence [ 0 ] ; temp [ 1 ] = s * influence [ 1 ] ; temp [ 2 ] = s * influence [ 2 ] ; s = curve [ ( pix >> systemBlueShift ) & 0x1f ] ; temp [ 6 ] = s * influence [ 6 ] ; temp [ 7 ] = s * influence [ 7 ] ; temp [ 8 ] = s * influence [ 8 ] ; if ( temp [ 0 ] < temp [ 3 ] ) swap ( temp [ 0 ] , temp [ 3 ] ) ; if ( temp [ 0 ] < temp [ 6 ] ) swap ( temp [ 0 ] , temp [ 6 ] ) ; if ( temp [ 3 ] < temp [ 6 ] ) swap ( temp [ 3 ] , temp [ 6 ] ) ; temp [ 3 ] <<= 1 ; temp [ 0 ] <<= 2 ; temp [ 0 ] += temp [ 3 ] + temp [ 6 ] ; red = ( ( int ( temp [ 0 ] ) * 160 ) >> 17 ) + 4 ; if ( red > 31 ) red = 31 ; if ( temp [ 2 ] < temp [ 5 ] ) swap ( temp [ 2 ] , temp [ 5 ] ) ; if ( temp [ 2 ] < temp [ 8 ] ) swap ( temp [ 2 ] , temp [ 8 ] ) ; if ( temp [ 5 ] < temp [ 8 ] ) swap ( temp [ 5 ] , temp [ 8 ] ) ; temp [ 5 ] <<= 1 ; temp [ 2 ] <<= 2 ; temp [ 2 ] += temp [ 5 ] + temp [ 8 ] ; blue = ( ( int ( temp [ 2 ] ) * 160 ) >> 17 ) + 4 ; if ( blue > 31 ) blue = 31 ; if ( temp [ 1 ] < temp [ 4 ] ) swap ( temp [ 1 ] , temp [ 4 ] ) ; if ( temp [ 1 ] < temp [ 7 ] ) swap ( temp [ 1 ] , temp [ 7 ] ) ; if ( temp [ 4 ] < temp [ 7 ] ) swap ( temp [ 4 ] , temp [ 7 ] ) ; temp [ 4 ] <<= 1 ; temp [ 1 ] <<= 2 ; temp [ 1 ] += temp [ 4 ] + temp [ 7 ] ; green = ( ( int ( temp [ 1 ] ) * 160 ) >> 17 ) + 4 ; if ( green > 31 ) green = 31 ; pix = red << systemRedShift ; pix += green << systemGreenShift ; pix += blue << systemBlueShift ; * buf ++ = pix ; } } void gbafilter_pal32 ( u32 * buf , int count ) { short temp [ 3 * 3 ] , s ; unsigned pix ; u8 red , green , blue ; while ( count -- ) { pix = * buf ; s = curve [ ( pix >> systemGreenShift ) & 0x1f ] ; temp [ 3 ] = s * influence [ 3 ] ; temp [ 4 ] = s * influence [ 4 ] ; temp [ 5 ] = s * influence [ 5 ] ; s = curve [ ( pix >> systemRedShift ) & 0x1f ] ; temp [ 0 ] = s * influence [ 0 ] ; temp [ 1 ] = s * influence [ 1 ] ; temp [ 2 ] = s * influence [ 2 ] ; s = curve [ ( pix >> systemBlueShift ) & 0x1f ] ; temp [ 6 ] = s * influence [ 6 ] ; temp [ 7 ] = s * influence [ 7 ] ; temp [ 8 ] = s * influence [ 8 ] ; if ( temp [ 0 ] < temp [ 3 ] ) swap ( temp [ 0 ] , temp [ 3 ] ) ; if ( temp [ 0 ] < temp [ 6 ] ) swap ( temp [ 0 ] , temp [ 6 ] ) ; if ( temp [ 3 ] < temp [ 6 ] ) swap ( temp [ 3 ] , temp [ 6 ] ) ; temp [ 3 ] <<= 1 ; temp [ 0 ] <<= 2 ; temp [ 0 ] += temp [ 3 ] + temp [ 6 ] ; red = ( ( int ( temp [ 0 ] ) * 160 ) >> 14 ) + 32 ; if ( temp [ 2 ] < temp [ 5 ] ) swap ( temp [ 2 ] , temp [ 5 ] ) ; if ( temp [ 2 ] < temp [ 8 ] ) swap ( temp [ 2 ] , temp [ 8 ] ) ; if ( temp [ 5 ] < temp [ 8 ] ) swap ( temp [ 5 ] , temp [ 8 ] ) ; temp [ 5 ] <<= 1 ; temp [ 2 ] <<= 2 ; temp [ 2 ] += temp [ 5 ] + temp [ 8 ] ; blue = ( ( int ( temp [ 2 ] ) * 160 ) >> 14 ) + 32 ; if ( temp [ 1 ] < temp [ 4 ] ) swap ( temp [ 1 ] , temp [ 4 ] ) ; if ( temp [ 1 ] < temp [ 7 ] ) swap ( temp [ 1 ] , temp [ 7 ] ) ; if ( temp [ 4 ] < temp [ 7 ] ) swap ( temp [ 4 ] , temp [ 7 ] ) ; temp [ 4 ] <<= 1 ; temp [ 1 ] <<= 2 ; temp [ 1 ] += temp [ 4 ] + temp [ 7 ] ; green = ( ( int ( temp [ 1 ] ) * 160 ) >> 14 ) + 32 ; pix = red << ( systemRedShift - 3 ) ; pix += green << ( systemGreenShift - 3 ) ; pix += blue << ( systemBlueShift - 3 ) ; * buf ++ = pix ; } } void gbafilter_pad ( u8 * buf , int count ) { union { struct { u8 r ; u8 g ; u8 b ; u8 a ; } part ; unsigned whole ; } mask ; mask . whole = 0x1f << systemRedShift ; mask . whole += 0x1f << systemGreenShift ; mask . whole += 0x1f << systemBlueShift ; switch ( systemColorDepth ) { case 24 : while ( count -- ) { * buf ++ &= mask . part . r ; * buf ++ &= mask . part . g ; * buf ++ &= mask . part . b ; } break ; case 32 : while ( count -- ) { * ( ( u32 * ) buf ) &= mask . whole ; buf += 4 ; } } } </DOCUMENT>
<DOCUMENT_ID="ci@@ rca-one@@ /OpenJK@@ -Alt/tree/master/code/c@@ game/cg_marks.cpp"> # include " cg _ headers . h " # include " cg _ media . h " markPoly_t cg_activeMarkPolys ; markPoly_t * cg_freeMarkPolys ; markPoly_t cg_markPolys [ MAX_MARK_POLYS ] ; void CG_InitMarkPolys ( void ) { int i ; memset ( cg_markPolys , 0 , sizeof ( cg_markPolys ) ) ; cg_activeMarkPolys . nextMark = & cg_activeMarkPolys ; cg_activeMarkPolys . prevMark = & cg_activeMarkPolys ; cg_freeMarkPolys = cg_markPolys ; for ( i = 0 ; i < MAX_MARK_POLYS - 1 ; i ++ ) { cg_markPolys [ i ] . nextMark = & cg_markPolys [ i + 1 ] ; } } void CG_FreeMarkPoly ( markPoly_t * le ) { if ( ! le -> prevMark ) { CG_Error ( " CG _ FreeLocalEntity : ▁ not ▁ active " ) ; } le -> prevMark -> nextMark = le -> nextMark ; le -> nextMark -> prevMark = le -> prevMark ; le -> nextMark = cg_freeMarkPolys ; cg_freeMarkPolys = le ; } markPoly_t * CG_AllocMark ( void ) { markPoly_t * le ; int time ; if ( ! cg_freeMarkPolys ) { time = cg_activeMarkPolys . prevMark -> time ; while ( cg_activeMarkPolys . prevMark && time == cg_activeMarkPolys . prevMark -> time ) { CG_FreeMarkPoly ( cg_activeMarkPolys . prevMark ) ; } } le = cg_freeMarkPolys ; cg_freeMarkPolys = cg_freeMarkPolys -> nextMark ; memset ( le , 0 , sizeof ( * le ) ) ; le -> nextMark = cg_activeMarkPolys . nextMark ; le -> prevMark = & cg_activeMarkPolys ; cg_activeMarkPolys . nextMark -> prevMark = le ; cg_activeMarkPolys . nextMark = le ; return le ; } # define MAX_MARK_FRAGMENTS 128 # define MAX_MARK_POINTS 384 void CG_ImpactMark ( qhandle_t markShader , const vec3_t origin , const vec3_t dir , float orientation , float red , float green , float blue , float alpha , qboolean alphaFade , float radius , qboolean temporary ) { vec3_t axis [ 3 ] ; float texCoordScale ; vec3_t originalPoints [ 4 ] ; byte colors [ 4 ] ; int i , j ; int numFragments ; markFragment@@ _t markFragments [ MAX_MARK_FRAGMENTS ] , * mf ; vec3_t markPoints [ MAX_MARK_POINTS ] ; vec3_t projection ; if ( ! cg_addMarks . integer ) { return ; } if ( radius <= 0 ) { CG_Error ( " CG _ ImpactMark ▁ called ▁ with ▁ < = ▁ 0 ▁ radius " ) ; } VectorNor@@ malize2 ( dir , axis [ 0 ] ) ; Perpen@@ dicular@@ Vector ( axis [ 1 ] , axis [ 0 ] ) ; RotatePoint@@ AroundVector ( axis [ 2 ] , axis [ 0 ] , axis [ 1 ] , orientation ) ; CrossProduct ( axis [ 0 ] , axis [ 2 ] , axis [ 1 ] ) ; texCoordScale = 0.5 * 1.0 / radius ; for ( i = 0 ; i < 3 ; i ++ ) { originalPoints [ 0 ] [ i ] = origin [ i ] - radius * axis [ 1 ] [ i ] - radius * axis [ 2 ] [ i ] ; originalPoints [ 1 ] [ i ] = origin [ i ] + radius * axis [ 1 ] [ i ] - radius * axis [ 2 ] [ i ] ; originalPoints [ 2 ] [ i ] = origin [ i ] + radius * axis [ 1 ] [ i ] + radius * axis [ 2 ] [ i ] ; originalPoints [ 3 ] [ i ] = origin [ i ] - radius * axis [ 1 ] [ i ] + radius * axis [ 2 ] [ i ] ; } VectorScale ( dir , - 20 , projection ) ; numFragments = cgi_C@@ M_Mark@@ Fragments ( 4 , ( const float ( * ) [ 3 ] ) originalPoints , projection , MAX_MARK_POINTS , markPoints [ 0 ] , MAX_MARK_FRAGMENTS , markFragments ) ; colors [ 0 ] = red * 255 ; colors [ 1 ] = green * 255 ; colors [ 2 ] = blue * 255 ; colors [ 3 ] = alpha * 255 ; for ( i = 0 , mf = markFragments ; i < numFragments ; i ++ , mf ++ ) { polyVert_t * v ; polyVert_t verts [ MAX_VERTS_ON_POLY ] ; markPoly_t * mark ; if ( mf -> numPoints > MAX_VERTS_ON_POLY ) { mf -> numPoints = MAX_VERTS_ON_POLY ; } for ( j = 0 , v = verts ; j < mf -> numPoints ; j ++ , v ++ ) { vec3_t delta ; VectorCopy ( markPoints [ mf -> firstPoint + j ] , v -> xyz ) ; VectorSubtract ( v -> xyz , origin , delta ) ; v -> st [ 0 ] = 0.5f + DotProduct ( delta , axis [ 1 ] ) * texCoordScale ; v -> st [ 1 ] = 0.5f + DotProduct ( delta , axis [ 2 ] ) * texCoordScale ; for ( int k = 0 ; k < 4 ; k ++ ) { v -> modulate [ k ] = colors [ k ] ; } } if ( temporary ) { cgi_R_AddPolyToScene ( markShader , mf -> numPoints , verts ) ; continue ; } mark = CG_AllocMark ( ) ; mark -> time = cg . time ; mark -> alphaFade = alphaFade ; mark -> markShader = markShader ; mark -> poly . numVerts = mf -> numPoints ; mark -> color [ 0 ] = colors [ 0 ] ; mark -> color [ 1 ] = colors [ 1 ] ; mark -> color [ 2 ] = colors [ 2 ] ; mark -> color [ 3 ] = colors [ 3 ] ; memcpy ( mark -> verts , verts , mf -> numPoints * sizeof ( verts [ 0 ] ) ) ; } } # define MARK_TOTAL_TIME 10000 # define MARK_FADE_TIME 1000 void CG_AddMarks ( void ) { int j ; markPoly_t * mp , * next ; int t ; int fade ; if ( ! cg_addMarks . integer ) { return ; } mp = cg_activeMarkPolys . nextMark ; for ( ; mp != & cg_activeMarkPolys ; mp = next ) { next = mp -> nextMark ; if ( cg . time > mp -> time + MARK_TOTAL_TIME ) { CG_FreeMarkPoly ( mp ) ; continue ; } t = mp -> time + MARK_TOTAL_TIME - cg . time ; if ( t < MARK_FADE_TIME ) { fade = 255 * t / MARK_FADE_TIME ; if ( mp -> alphaFade ) { for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 3 ] = fade ; } } else { float f = ( float ) t / MARK_FADE_TIME ; for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 0 ] = mp -> color [ 0 ] * f ; mp -> verts [ j ] . modulate [ 1 ] = mp -> color [ 1 ] * f ; mp -> verts [ j ] . modulate [ 2 ] = mp -> color [ 2 ] * f ; } } } else { for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 0 ] = mp -> color [ 0 ] ; mp -> verts [ j ] . modulate [ 1 ] = mp -> color [ 1 ] ; mp -> verts [ j ] . modulate [ 2 ] = mp -> color [ 2 ] ; } } cgi_R_AddPolyToScene ( mp -> markShader , mp -> poly . numVerts , mp -> verts ) ; } } </DOCUMENT>
<DOCUMENT_ID="native@@ -m/slmath/tree/master/source/@@ intersect_util.cpp"> # include < slm / intersect_util . h > SLMATH_BEGIN ( ) intersectLineBox_Line :: intersectLineBox_Line ( const vec3 & origin , const vec3 & direction ) : o ( origin ) , d ( direction ) , inv_d ( fabsf ( direction . x ) > FLT_MIN ? 1 . f / direction . x : FLT_MAX , fabsf ( direction . y ) > FLT_MIN ? 1 . f / direction . y : FLT_MAX , fabsf ( direction . z ) > FLT_MIN ? 1 . f / direction . z : FLT_MAX ) , signx ( direction . x < 0 . f ) , signy ( direction . y < 0 . f ) , signz ( direction . z < 0 . f ) { } bool intersectLineTri ( const vec3 & o , const vec3 & d , const vec3 & v0 , const vec3 & v1 , const vec3 & v2 , float * t ) { const vec3 e1 = v1 - v0 ; const vec3 e2 = v2 - v0 ; const vec3 pvec = cross ( d , e2 ) ; const float det = dot ( e1 , pvec ) ; if ( fabsf ( det ) <= FLT_MIN ) return false ; const float invdet = 1 . f / det ; const vec3 tvec = o - v0 ; const float u = dot ( tvec , pvec ) * invdet ; if ( 0 . f > u || 1 . f < u ) return false ; const vec3 qvec = cross ( tvec , e1 ) ; const float v = dot ( d , qvec ) * invdet ; if ( 0 . f > v || 1 . f < u + v ) return false ; const float s = dot ( e2 , qvec ) * invdet ; if ( s < 0 . f || s >= 1 . f ) return false ; if ( t ) * t = s ; assert ( s >= 0 . f && s <= 1 . f ) ; return true ; } bool intersectLineBox ( const intersectLineBox_Line & r , const vec3 * boxminmax ) { const float t0 = 0.0f ; const float t1 = 1.0f ; const int * const sign = & r . signx ; register float tmin , tmax , tymin , tymax , tzmin , tzmax ; tmin = ( boxminmax [ sign [ 0 ] ] . x - r . o . x ) * r . inv_d . x ; tmax = ( boxminmax [ 1 - sign [ 0 ] ] . x - r . o . x ) * r . inv_d . x ; tymin = ( boxminmax [ sign [ 1 ] ] . y - r . o . y ) * r . inv_d . y ; tymax = ( boxminmax [ 1 - sign [ 1 ] ] . y - r . o . y ) * r . inv_d . y ; if ( ( tmin > tymax ) || ( tymin > tmax ) ) return false ; if ( tymin > tmin ) tmin = tymin ; if ( tymax < tmax ) tmax = tymax ; tzmin = ( boxminmax [ sign [ 2 ] ] . z - r . o . z ) * r . inv_d . z ; tzmax = ( boxminmax [ 1 - sign [ 2 ] ] . z - r . o . z ) * r . inv_d . z ; if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false ; if ( tzmin > tmin ) tmin = tzmin ; if ( tzmax < tmax ) tmax = tzmax ; return ( ( tmin < t1 ) && ( tmax > t0 ) ) ; } bool intersectLineBox ( const vec3 & o , const vec3 & d , const vec3 & boxmin , const vec3 & boxmax ) { intersectLineBox_Line line ( o , d ) ; const vec3 boxminmax [ 2 ] = { boxmin , boxmax } ; return intersectLineBox ( line , boxminmax ) ; } SLMATH_END ( ) </DOCUMENT>
<DOCUMENT_ID="cri@@ stal/Patch/tree/master/dep/acelite/ace/@@ Parse_Node@@ .cpp"> # include " ace / Parse _ Node . h " # if ( ACE_USES_CLAS@@ SIC_SVC_CON@@ F == 1 ) # include " ace / Service _ Config . h " # include " ace / Service _ Repository . h " # include " ace / Service _ Types . h " # include " ace / Task . h " # include " ace / DLL . h " # include " ace / ACE . h " # include " ace / OS _ NS _ string . h " # include " ace / ARGV . h " # include < list > ACE_BEGIN_VERSIONED_NAMESPACE_DECL ACE_ALLOC_HOOK_DEFINE ( ACE_Stream_Node ) void ACE_Stream_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Stream _ Node : : dump " ) ; # endif } void ACE_Stream_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Stream _ Node : : apply " ) ; const ACE_Service_Type * sst = this -> node_ -> record ( config ) ; if ( sst == 0 ) const_cast < ACE_Static_Node * > ( this -> node_ ) -> apply ( config , yyerrno ) ; if ( yyerrno != 0 ) return ; sst = this -> node_ -> record ( config ) ; ACE_Stream_Type * st = dynamic_cast < ACE_Stream_Type * > ( const_cast < ACE_Service_Type_Impl * > ( sst -> type ( ) ) ) ; std :: list < const ACE_Static_Node * > mod_list ; const ACE_Static_Node * module ; for ( module = dynamic_cast < const ACE_Static_Node * > ( this -> mods_ ) ; module != 0 ; module = dynamic_cast < ACE_Static_Node * > ( module -> link ( ) ) ) mod_list . push_front ( module ) ; std :: list < const ACE_Static_Node * > :: const_iterator iter ; for ( iter = mod_list . begin ( ) ; iter != mod_list . end ( ) ; ++ iter ) { module = * iter ; ACE_ARGV args ( module -> parameters ( ) ) ; const ACE_Service_Type * mst = module -> record ( config ) ; if ( mst == 0 ) const_cast < ACE_Static_Node * > ( module ) -> apply ( config , yyerrno ) ; if ( yyerrno != 0 ) { if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " dynamic ▁ initialization ▁ failed ▁ for ▁ Module ▁ % s \n " ) , module -> name ( ) ) ) ; } ++ yyerrno ; continue ; } ACE_Module_Type const * const mt1 = static_cast < ACE_Module_Type const * > ( module -> record ( config ) -> type ( ) ) ; ACE_Module_Type * mt = const_cast < ACE_Module_Type * > ( mt1 ) ; if ( st -> push ( mt ) == - 1 ) { if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " dynamic ▁ initialization ▁ failed ▁ for ▁ Stream ▁ % s \n " ) , this -> node_ -> name ( ) ) ) ; } ++ yyerrno ; } } # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ( % P | % t ) ▁ Did ▁ stream ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> node_ -> name ( ) , yyerrno ) ) ; # endif } ACE_ALLOC_HOOK_DEFINE ( ACE_Parse_Node ) void ACE_Parse_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Parse _ Node : : dump " ) ; # endif } const ACE_TCHAR * ACE_Parse_Node :: name ( void ) const { ACE_TRACE ( " ACE _ Parse _ Node : : name " ) ; return this -> name_ ; } ACE_Parse_Node * ACE_Parse_Node :: link ( void ) const { ACE_TRACE ( " ACE _ Parse _ Node : : link " ) ; return this -> next_ ; } void ACE_Parse_Node :: link ( ACE_Parse_Node * n ) { ACE_TRACE ( " ACE _ Parse _ Node : : link " ) ; ACE_Parse_Node * t = this ; while ( t -> next_ != 0 ) t = t -> next_ ; t -> next_ = n ; } ACE_Stream_Node :: ACE_Stream_Node ( const ACE_Static_Node * str_ops , const ACE_Parse_Node * str_mods ) : ACE_Parse_Node ( ( str_ops == 0 ? ACE_TEXT ( " < unknown > " ) : str_ops -> name ( ) ) ) , node_ ( str_ops ) , mods_ ( str_mods ) { ACE_TRACE ( " ACE _ Stream _ Node : : ACE _ Stream _ Node " ) ; } ACE_Stream_Node :: ~ ACE_Stream_Node ( void ) { ACE_TRACE ( " ACE _ Stream _ Node : : ~ ACE _ Stream _ Node " ) ; ACE_Static_Node * n = const_cast < ACE_Static_Node * > ( this -> node_ ) ; delete n ; ACE_Parse_Node * m = const_cast < ACE_Parse_Node * > ( this -> mods_ ) ; delete m ; } ACE_Parse_Node :: ACE_Parse_Node ( void ) : name_ ( 0 ) , next_ ( 0 ) { ACE_TRACE ( " ACE _ Parse _ Node : : ACE _ Parse _ Node " ) ; } ACE_Parse_Node :: ACE_Parse_Node ( const ACE_TCHAR * nm ) : name_ ( ACE :: strnew ( nm ) ) , next_ ( 0 ) { ACE_TRACE ( " ACE _ Parse _ Node : : ACE _ Parse _ Node " ) ; } void ACE_Parse_Node :: print ( void ) const { ACE_TRACE ( " ACE _ Parse _ Node : : print " ) ; ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " svc ▁ = ▁ % s \n " ) , this -> name ( ) ) ) ; if ( this -> next_ ) this -> next_ -> print ( ) ; } ACE_Parse_Node :: ~ ACE_Parse_Node ( void ) { ACE_TRACE ( " ACE _ Parse _ Node : : ~ ACE _ Parse _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> name_ ) ; delete this -> next_ ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Suspend_Node ) void ACE_Suspend_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Suspend _ Node : : dump " ) ; # endif } ACE_Suspend_Node :: ACE_Suspend_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Suspend _ Node : : ACE _ Suspend _ Node " ) ; } ACE_Suspend_Node :: ~ ACE_Suspend_Node ( void ) { } ACE_ALLOC_HOOK_DEFINE ( ACE_Resume_Node ) void ACE_Resume_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Resume _ Node : : dump " ) ; # endif } ACE_Resume_Node :: ACE_Resume_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Resume _ Node : : ACE _ Resume _ Node " ) ; } ACE_Resume_Node :: ~ ACE_Resume_Node ( void ) { } void ACE_Suspend_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Suspend _ Node : : apply " ) ; if ( config -> suspend ( this -> name ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ suspend ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; # endif } void ACE_Resume_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Resume _ Node : : apply " ) ; if ( config -> resume ( this -> name ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ resume ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; # endif } ACE_ALLOC_HOOK_DEFINE ( ACE_Remove_Node ) void ACE_Remove_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Remove _ Node : : dump " ) ; # endif } ACE_Remove_Node :: ACE_Remove_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Remove _ Node : : ACE _ Remove _ Node " ) ; } ACE_Remove_Node :: ~ ACE_Remove_Node ( void ) { } void ACE_Remove_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Remove _ Node : : apply " ) ; if ( config -> remove ( this -> name ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Remove _ Node : : apply " ) ACE_TEXT ( " ▁ - ▁ did ▁ remove ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; # endif } ACE_Dynamic_Node :: ACE_Dynamic_Node ( ACE_Service_Type_Factory const * stf , ACE_TCHAR * parms ) : ACE_Static_Node ( stf -> name ( ) , parms ) , factory_ ( stf ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : ACE _ Dynamic _ Node " ) ; } void ACE_Dynamic_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : apply " ) ; if ( config -> initialize ( this -> factory_ . get ( ) , this -> parameters ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Dynamic _ Node : : apply " ) ACE_TEXT ( " ▁ - ▁ Did ▁ dynamic ▁ on ▁ % s ▁ ( yyerrno = % d ) \n " ) , this -> name ( ) , yyerrno ) ) ; # endif } ACE_ALLOC_HOOK_DEFINE ( ACE_Dynamic_Node ) void ACE_Dynamic_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Dynamic _ Node : : dump " ) ; # endif } ACE_Dynamic_Node :: ~ ACE_Dynamic_Node ( void ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : ~ ACE _ Dynamic _ Node " ) ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Static_Node ) void ACE_Static_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Static _ Node : : dump " ) ; # endif } ACE_Static_Node :: ACE_Static_Node ( const ACE_TCHAR * nm , ACE_TCHAR * params ) : ACE_Parse_Node ( nm ) , parameters_ ( ACE :: strnew ( params ) ) { ACE_TRACE ( " ACE _ Static _ Node : : ACE _ Static _ Node " ) ; } const ACE_Service_Type * ACE_Static_Node :: record ( const ACE_Service_Gestalt * config ) const { ACE_TRACE ( " ACE _ Static _ Node : : record " ) ; ACE_Service_Type * sr = 0 ; if ( config -> find ( this -> name ( ) , ( const ACE_Service_Type * * ) & sr ) == - 1 ) return 0 ; return sr ; } ACE_TCHAR * ACE_Static_Node :: parameters ( void ) const { ACE_TRACE ( " ACE _ Static _ Node : : parameters " ) ; return this -> parameters_ ; } void ACE_Static_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Static _ Node : : apply " ) ; if ( config -> initialize ( this -> name ( ) , this -> parameters ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Static _ Node : : apply ▁ - " ) ACE_TEXT ( " ▁ Did ▁ static ▁ on ▁ % s ▁ ( yyerrno = % d ) \n " ) , this -> name ( ) , yyerrno ) ) ; # endif } ACE_Static_Node :: ~ ACE_Static_Node ( void ) { ACE_TRACE ( " ACE _ Static _ Node : : ~ ACE _ Static _ Node " ) ; delete [ ] this -> parameters_ ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Location_Node ) void ACE_Location_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Location _ Node : : dump " ) ; # endif } ACE_Location_Node :: ACE_Location_Node ( void ) : pathname_ ( 0 ) , dll_ ( ) , symbol_ ( 0 ) { ACE_TRACE ( " ACE _ Location _ Node : : ACE _ Location _ Node " ) ; } ACE_Location_Node :: ~ ACE_Location_Node ( void ) { ACE_TRACE ( " ACE _ Location _ Node : : ~ ACE _ Location _ Node " ) ; } const ACE_DLL & ACE_Location_Node :: dll ( void ) { return this -> dll_ ; } const ACE_TCHAR * ACE_Location_Node :: pathname ( void ) const { ACE_TRACE ( " ACE _ Location _ Node : : pathname " ) ; return this -> pathname_ ; } void ACE_Location_Node :: pathname ( const ACE_TCHAR * p ) { ACE_TRACE ( " ACE _ Location _ Node : : pathname " ) ; this -> pathname_ = p ; } int ACE_Location_Node :: dispose ( void ) const { ACE_TRACE ( " ACE _ Location _ Node : : dispose " ) ; return this -> must_delete_ ; } int ACE_Location_Node :: open_dll ( int & yyerrno ) { ACE_TRACE ( " ACE _ Location _ Node : : open _ dll " ) ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ LN : : open _ dll ▁ - ▁ path = % s \n " ) , this -> pathname ( ) ) ) ; # endif if ( - 1 == this -> dll_ . open ( this -> pathname ( ) ) ) { ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) { ACE_TCHAR * errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ LN : : open _ dll ▁ - ▁ Failed ▁ to ▁ open ▁ % s : ▁ % s \n " ) , this -> pathname ( ) , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } # endif return - 1 ; } return 0 ; } void ACE_Location_Node :: set_symbol ( void * s ) { ACE_TRACE ( " ACE _ Location _ Node : : set _ symbol " ) ; this -> symbol_ = s ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Object_Node ) void ACE_Object_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Object _ Node : : dump " ) ; # endif } ACE_Object_Node :: ACE_Object_Node ( const ACE_TCHAR * path , const ACE_TCHAR * obj_name ) : object_name_ ( ACE :: strnew ( obj_name ) ) { ACE_TRACE ( " ACE _ Object _ Node : : ACE _ Object _ Node " ) ; this -> pathname ( ACE :: strnew ( path ) ) ; this -> must_delete_ = 0 ; } void * ACE_Object_Node :: symbol ( ACE_Service_Gestalt * , int & yyerrno , ACE_Service_Object_Exterminator * ) { ACE_TRACE ( " ACE _ Object _ Node : : symbol " ) ; if ( this -> open_dll ( yyerrno ) == 0 ) { ACE_TCHAR * object_name = const_cast < ACE_TCHAR * > ( this -> object_name_ ) ; this -> symbol_ = this -> dll_ . symbol ( object_name ) ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) { ACE_TCHAR * errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ DLL : : symbol ▁ - " ) ACE_TEXT ( " ▁ Failed ▁ for ▁ object ▁ % s : ▁ % s \n " ) , object_name , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } # endif return 0 ; } return this -> symbol_ ; } return 0 ; } ACE_Object_Node :: ~ ACE_Object_Node ( void ) { ACE_TRACE ( " ACE _ Object _ Node : : ~ ACE _ Object _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> object_name_ ) ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Function_Node ) void ACE_Function_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Function _ Node : : dump " ) ; # endif } ACE_Function_Node :: ACE_Function_Node ( const ACE_TCHAR * path , const ACE_TCHAR * func_name ) : function_name_ ( make_func_name ( func_name ) ) { ACE_TRACE ( " ACE _ Function _ Node : : ACE _ Function _ Node " ) ; this -> pathname ( ACE :: strnew ( path ) ) ; this -> must_delete_ = 1 ; } ACE_TCHAR * ACE_Function_Node :: make_func_name ( ACE_TCHAR const * func_name ) { # if defined ( ACE_HAS_VERSIONED_NAMESPACE ) && ACE_HAS_VERSIONED_NAMESPACE == 1 # define ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING_IMPL ( NAME ) # NAME # define ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING ( NAME ) ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING_IMPL ( NAME ) # define ACE_VERSIONED_NAMESPACE_NAME_STRING ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING ( ACE_VERSIONED_NAMESPACE_@@ NAME ) static ACE_TCHAR const make_prefix [ ] = ACE_TEXT ( " _ make _ " ) ; static size_t const make_prefix_len = sizeof ( make_prefix ) / sizeof ( make_prefix [ 0 ] ) - 1 ; if ( ACE_OS :: strncmp ( make_prefix , func_name , make_prefix_len ) == 0 ) { static ACE_TCHAR const versioned_namespace_name [ ] = ACE_TEXT ( ACE_VERSIONED_NAMESPACE_NAME_STRING ) ACE_TEXT ( " _ " ) ; static size_t const versioned_namespace_name_len = sizeof ( versioned_namespace_name ) / sizeof ( versioned_namespace_name [ 0 ] ) ; size_t const len = ACE_OS :: strlen ( func_name ) + versioned_namespace_name_len ; ACE_TCHAR * mangled_func_name ; ACE_NEW_RETURN ( mangled_func_name , ACE_TCHAR [ len ] , 0 ) ; ACE_Auto_Basic_Arra@@ y_Ptr < ACE_TCHAR > safe ( mangled_func_name ) ; ACE_OS :: snprintf ( mangled_func_name , len , ACE_TEXT ( " % s % s % s " ) , make_prefix , versioned_namespace_name , func_name + make_prefix_len ) ; return safe . release ( ) ; } # endif return ACE :: strnew ( func_name ) ; } void * ACE_Function_Node :: symbol ( ACE_Service_Gestalt * , int & yyerrno , ACE_Service_Object_Exterminator * gobbler ) { typedef ACE_Service_Object * ( * ACE_Service_Factory_Ptr ) ( ACE_Service_Object_Exterminator * ) ; ACE_TRACE ( " ACE _ Function _ Node : : symbol " ) ; if ( this -> open_dll ( yyerrno ) == 0 ) { this -> symbol_ = 0 ; ACE_TCHAR * const function_name = const_cast < ACE_TCHAR * > ( this -> function_name_ ) ; void * const func_p = this -> dll_ . symbol ( function_name ) ; if ( func_p == 0 ) { ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) { ACE_TCHAR * const errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " DLL : : symbol ▁ failed ▁ for ▁ function ▁ % s : ▁ " ) ACE_TEXT ( " % s \n " ) , function_name , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } # endif return 0 ; } # if defined ( ACE_OPEN@@ VMS ) && ( ! defined ( __INITIAL_POINTER_SIZE ) || ( __INITIAL_POINTER_SIZE < 64 ) ) int const temp_p = reinterpret_cast < int > ( func_p ) ; # else intptr_t const temp_p = reinterpret_cast < intptr_t > ( func_p ) ; # endif ACE_Service_Factory_Ptr func = reinterpret_cast < ACE_Service_Factory_Ptr > ( temp_p ) ; this -> symbol_ = ( * func ) ( gobbler ) ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " % p \n " ) , this -> function_name_ ) ) ; } return 0 ; } } return this -> symbol_ ; } ACE_Function_Node :: ~ ACE_Function_Node ( void ) { ACE_TRACE ( " ACE _ Function _ Node : : ~ ACE _ Function _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( function_name_ ) ; delete [ ] const_cast < ACE_TCHAR * > ( pathname_ ) ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Dummy_Node ) void ACE_Dummy_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Dummy _ Node : : dump " ) ; # endif } ACE_Dummy_Node :: ACE_Dummy_Node ( const ACE_Static_Node * static_node , const ACE_Parse_Node * str_mods ) : ACE_Parse_Node ( static_node -> name ( ) ) , node_ ( static_node ) , mods_ ( str_mods ) { ACE_TRACE ( " ACE _ Dummy _ Node : : ACE _ Dummy _ Node " ) ; } void ACE_Dummy_Node :: apply ( ACE_Service_Gestalt * , int & yyerrno ) { ACE_TRACE ( " ACE _ Dummy _ Node : : apply " ) ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ operations ▁ on ▁ stream ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; # else ACE_UNUSE@@ D_ARG ( yyerrno ) ; # endif } ACE_Dummy_Node :: ~ ACE_Dummy_Node ( void ) { ACE_TRACE ( " ACE _ Dummy _ Node : : ~ ACE _ Dummy _ Node " ) ; ACE_Static_Node * n = const_cast < ACE_Static_Node * > ( this -> node_ ) ; delete n ; ACE_Parse_Node * m = const_cast < ACE_Parse_Node * > ( this -> mods_ ) ; delete m ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Static_Function_Node ) void ACE_Static_Function_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Static _ Function _ Node : : dump " ) ; # endif } ACE_Static_Function_Node :: ACE_Static_Function_Node ( const ACE_TCHAR * func_name ) : function_name_ ( ACE :: strnew ( func_name ) ) { ACE_TRACE ( " ACE _ Static _ Function _ Node : : ACE _ Static _ Function _ Node " ) ; this -> must_delete_ = 1 ; } void * ACE_Static_Function_Node :: symbol ( ACE_Service_Gestalt * config , int & yyerrno , ACE_Service_Object_Exterminator * gobbler ) { ACE_TRACE ( " ACE _ Static _ Function _ Node : : symbol " ) ; this -> symbol_ = 0 ; ACE_Static_Svc_Descriptor * ssd = 0 ; if ( config -> find_static_sv@@ c_descriptor ( this -> function_name_ , & ssd ) == - 1 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ( % P | % t ) ▁ No ▁ static ▁ service ▁ " ) ACE_TEXT ( " registered ▁ for ▁ function ▁ % s \n " ) , this -> function_name_ ) ) ; } return 0 ; } if ( ssd -> alloc_ == 0 ) { ++ yyerrno ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ( % P | % t ) ▁ No ▁ static ▁ service ▁ factory ▁ " ) ACE_TEXT ( " function ▁ registered ▁ for ▁ function ▁ % s \n " ) , this -> function_name_ ) ) ; } return 0 ; } } this -> symbol_ = ( * ssd -> alloc_ ) ( gobbler ) ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " % p \n " ) , this -> function_name_ ) ) ; } return 0 ; } return this -> symbol_ ; } ACE_Static_Function_Node :: ~ ACE_Static_Function_Node ( void ) { ACE_TRACE ( " ACE _ Static _ Function _ Node : : ~ ACE _ Static _ Function _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> function_name_ ) ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Service_Type_Factory ) ACE_Service_Type_Factory :: ACE_Service_Type_Factory ( ACE_TCHAR const * name , int type , ACE_Location_Node * location , int active ) : name_ ( name ) , type_ ( type ) , location_ ( location ) , is_active_ ( active ) { } ACE_Service_Type_Factory :: ~ ACE_Service_Type_Factory ( void ) { } ACE_Service_Type * ACE_Service_Type_Factory :: make_service@@ _type ( ACE_Service_Gestalt * cfg ) const { ACE_TRACE ( " ACE _ Service _ Type _ Factory : : make _ service _ type " ) ; u_int const flags = ACE_Service_Type :: DELETE_THI@@ S | ( this -> location_ -> dispose ( ) == 0 ? 0 : ACE_Service_Type :: DELETE_OBJ ) ; int yyerrno = 0 ; ACE_Service_Object_Exterminator gobbler = 0 ; void * sym = this -> location_ -> symbol ( cfg , yyerrno , & gobbler ) ; if ( sym != 0 ) { ACE_Service_Type_Impl * stp = ACE_Service_Config :: create_service@@ _type_impl ( this -> name ( ) , this -> type_ , sym , flags , gobbler ) ; if ( stp == 0 ) ++ yyerrno ; ACE_Service_Type * tmp = 0 ; ACE_NEW_RETURN ( tmp , ACE_Service_Type ( this -> name ( ) , stp , this -> location_ -> dll ( ) , this -> is_active_ ) , 0 ) ; return tmp ; } # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Unable ▁ to ▁ create ▁ " ) ACE_TEXT ( " service ▁ object ▁ for ▁ % s \n " ) , this -> name ( ) ) ) ; } # endif ++ yyerrno ; return 0 ; } ACE_TCHAR const * ACE_Service_Type_Factory :: name ( void ) const { return name_ . c_str ( ) ; } ACE_END_VERSIONED_NAMESPACE_DECL # endif </DOCUMENT>
<DOCUMENT_ID="kstripp/Litt@@ leBudget/tree/master/src/@@ core/main.cpp"> # include < iostream > # include " lb . h " using std :: cout ; using std :: endl ; using std :: cerr ; # ifndef VERSION # define VERSION "1.0.1" # endif int main ( int argc , const char * argv [ ] ) { try { lb app ( argc , argv ) ; return app . run ( ) ; } catch ( lb_error e ) { cerr << e . what ( ) << endl ; return EXIT_FAILURE ; } catch ( runtime_error e ) { cerr << e . what ( ) << endl ; return EXIT_FAILURE ; } catch ( ... ) { cerr << " Unhandled ▁ exception ▁ in ▁ lb . " << endl ; return EXIT_FAILURE ; } } </DOCUMENT>
<DOCUMENT_ID="KonceptGe@@ ek/mo@@ sesdecoder@@ /tree/master/mer@@ t/TER/infosHash@@ er.cpp"> # include " infosHasher . h " using namespace std ; using namespace TERCPPNS_Tools ; namespace TERCPPNS_HashMap@@ Space { infosHasher :: infosHasher ( long cle , string cleTxt , vector < int > valueVecInt ) { m_hashKey = cle ; m_key = cleTxt ; m_value = valueVecInt ; } long infosHasher :: getHashKey ( ) { return m_hashKey ; } string infosHasher :: getKey ( ) { return m_key ; } vector < int > infosHasher :: getValue ( ) { return m_value ; } void infosHasher :: setValue ( vector < int > value ) { m_value = value ; } string infosHasher :: toString ( ) { stringstream to_return ; to_return << m_hashKey << " \t " << m_key << " \t " << vectorToString ( m_value , " \t " ) << endl ; return to_return . str ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="hkarim/@@ JUCE-Graph-Component@@ /tree/master/JuceLibraryCode/modules/juce_@@ gui_bas@@ ics/filebrowser@@ /juce_ImagePreviewComponent@@ .cpp"> ImagePreviewComponent :: ImagePreviewComponent ( ) { } ImagePreviewComponent :: ~ ImagePreviewComponent ( ) { } void ImagePreviewComponent :: getThumbSize ( int & w , int & h ) const { const int availableW = proportionOfWidth ( 0.97f ) ; const int availableH = getHeight ( ) - 13 * 4 ; const double scale = jmin ( 1.0 , availableW / ( double ) w , availableH / ( double ) h ) ; w = roundToInt ( scale * w ) ; h = roundToInt ( scale * h ) ; } void ImagePreviewComponent :: selectedFileChanged ( const File & file ) { if ( fileToLoad != file ) { fileToLoad = file ; startTimer ( 100 ) ; } } void ImagePreviewComponent :: timerCallback ( ) { stopTimer ( ) ; currentThumbnail = Image ( ) ; currentDetails . clear ( ) ; repaint ( ) ; ScopedPointer < FileInputStream > in ( fileToLoad . createInputStream ( ) ) ; if ( in != nullptr ) { if ( ImageFileFormat * const format = ImageFileFormat :: findImageFormatForStream ( * in ) ) { currentThumbnail = format -> decodeImage ( * in ) ; if ( currentThumbnail . isValid ( ) ) { int w = currentThumbnail . getWidth ( ) ; int h = currentThumbnail . getHeight ( ) ; currentDetails << fileToLoad . getFileName ( ) << " \n " << format -> getFormatName ( ) << " \n " << w << " ▁ x ▁ " << h << " ▁ pixels \n " << File :: descriptionOfSizeInBytes ( fileToLoad . getSize ( ) ) ; getThumbSize ( w , h ) ; currentThumbnail = currentThumbnail . rescaled ( w , h ) ; } } } } void ImagePreviewComponent :: paint ( Graphics & g ) { if ( currentThumbnail . isValid ( ) ) { g . setFont ( 13.0f ) ; int w = currentThumbnail . getWidth ( ) ; int h = currentThumbnail . getHeight ( ) ; getThumbSize ( w , h ) ; const int numLines = 4 ; const int totalH = 13 * numLines + h + 4 ; const int y = ( getHeight ( ) - totalH ) / 2 ; g . drawImageWith@@ in ( currentThumbnail , ( getWidth ( ) - w ) / 2 , y , w , h , RectanglePlacement :: centred | RectanglePlacement :: onlyReduceInSize , false ) ; g . drawFit@@ tedText ( currentDetails , 0 , y + h + 4 , getWidth ( ) , 100 , Justification :: centredTop , numLines ) ; } } </DOCUMENT>
