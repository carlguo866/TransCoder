public synchronized static Map < String , String > convert@@ File@@ sTo@@ Map ( Common@@ s@@ Multi@@ part@@ File [ ] file@@ Input@@ List ) { Map < String , String > file@@ Map = new Link@@ ed@@ HashMap < String , String > ( ) ; Common@@ s@@ Multi@@ part@@ File tmp@@ Multi@@ File ; String tmp@@ Charset ; file@@ Name@@ Coun@@ ter@@ Map . clear ( ) ; for ( int i = 0 ; i < file@@ Input@@ List . length ; i ++ ) { tmp@@ Multi@@ File = file@@ Input@@ List [ i ] ; try { if ( tmp@@ Multi@@ File != null && ! tmp@@ Multi@@ File . isEmpty ( ) && tmp@@ Multi@@ File . getInputStream ( ) != null ) { tmp@@ Charset = C@@ raw@@ l@@ Utils . extract@@ Charset ( tmp@@ Multi@@ File . getInputStream ( ) ) ; file@@ Map . put ( getFileName ( tmp@@ Multi@@ File . get@@ Origin@@ al@@ Filename ( ) ) , tmp@@ Multi@@ File . getFile@@ Item ( ) . get@@ String ( tmp@@ Charset ) ) ; } } catch ( IOException e ) { } } return file@@ Map ; }
private static String getFileName ( String original@@ FileName ) { StringBuilder fileName = new StringBuilder ( ) ; fileName . append ( ' / ' ) ; if ( file@@ Name@@ Coun@@ ter@@ Map . containsKey ( original@@ FileName ) ) { file@@ Name@@ Coun@@ ter@@ Map . put ( original@@ FileName , Integer . valueOf ( file@@ Name@@ Coun@@ ter@@ Map . get ( original@@ FileName ) + 1 ) ) ; fileName . append ( original@@ FileName ) ; fileName . append ( ' _ ' ) ; fileName . append ( file@@ Name@@ Coun@@ ter@@ Map . get ( original@@ FileName ) ) ; return fileName . toString ( ) ; } else { file@@ Name@@ Coun@@ ter@@ Map . put ( original@@ FileName , Integer . valueOf ( 1 ) ) ; fileName . append ( original@@ FileName ) ; return fileName . toString ( ) ; } }
public static final void init ( int t ) { if ( props == null ) { props = new Props ( t ) ; } else { throw new RuntimeException ( " The ▁ Properties ▁ systems ▁ settings ▁ are ▁ already ▁ initial@@ is@@ ed ! " ) ; } }
public static final void init ( String filename ) { if ( props == null ) { props = new Props ( filename ) ; } else { throw new RuntimeException ( " The ▁ properties ▁ systems ▁ settings ▁ are ▁ already ▁ initial@@ is@@ ed ! " ) ; } }
public static boolean is@@ Initialized ( ) { return props != null ; }
public static Props getInstance ( ) { if ( props != null ) { return props ; } throw new RuntimeException ( " Properties , ▁ K@@ et@@ t@@ le ▁ systems ▁ settings , ▁ not ▁ initial@@ is@@ ed ! " ) ; }
public static final int get@@ Argument@@ Number ( Value@@ Meta@@ Interface value ) { if ( value != null && value . getName ( ) . startsWith ( Props . STR@@ ING_A@@ RG@@ UM@@ ENT_@@ NAME_@@ PREFIX ) ) { return Const . toInt ( value . getName ( ) . substring ( Props . STR@@ ING_A@@ RG@@ UM@@ ENT_@@ NAME_@@ PREFIX . length ( ) ) , - 1 ) ; } return - 1 ; }
public static final String [ ] convert@@ Arguments ( Row@@ Meta@@ AndData row ) { String [ ] args = new String [ 10 ] ; for ( int i = 0 ; i < row . size ( ) ; i ++ ) { Value@@ Meta@@ Interface value@@ Meta = row . getValue@@ Meta ( i ) ; int arg@@ N@@ r = get@@ Argument@@ Number ( value@@ Meta ) ; if ( arg@@ N@@ r >= 0 && arg@@ N@@ r < 10 ) { try { args [ arg@@ N@@ r ] = row . get@@ String ( i , " " ) ; } catch ( K@@ et@@ tle@@ Value@@ Exception e ) { args [ arg@@ N@@ r ] = " " ; } } } return args ; }
private static Date parse@@ Date ( String s ) { for ( DateFormat current@@ Format : DAT@@ E_@@ FOR@@ MAT@@ S ) { try { return current@@ Format . parse ( s ) ; } catch ( Parse@@ Exception e ) { } } return null ; }
