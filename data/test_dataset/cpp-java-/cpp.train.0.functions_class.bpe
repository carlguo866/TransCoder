void Driver_Document :: SetFile ( const std :: string & theFileName ) { myFile = theFileName ; }
void Driver_Document :: SetDocument ( SMESHDS_Document * theDocument ) { myDocument = theDocument ; }
void MaximizeWindowCommandHandler :: ExecuteInternal ( const IECommandExecutor & executor , const ParametersMap & command_@@ parameters , Response * response ) { int status_code = WD_SUCCESS ; BrowserHandle browser_wrapper ; status_code = executor . GetCurrentBrowser ( & browser_wrapper ) ; if ( status_code != WD_SUCCESS ) { response -> SetErrorResponse ( ERROR_NO_SU@@ CH_WINDO@@ W , " Error ▁ retrieving ▁ window " ) ; return ; } HWND window_handle = browser_wrapper -> GetTopLevelWindowHandle ( ) ; if ( ! :: IsZoom@@ ed ( window_handle ) ) { browser_wrapper -> Restore ( ) ; :: ShowWindow ( window_handle , SW_MAXIMI@@ ZE ) ; } RECT window_rect ; :: GetWindowRect ( window_handle , & window_rect ) ; Json :: Value response_value ; response_value [ " width " ] = window_rect . right - window_rect . left ; response_value [ " height " ] = window_rect . bottom - window_rect . top ; response_value [ " x " ] = window_rect . left ; response_value [ " y " ] = window_rect . top ; response -> SetSuccessResponse ( response_value ) ; }
DlgEditUser :: DlgEditUser ( QWidget * parent , QString email , int gender , QString country , QString realName ) : QDialog ( parent ) { emailLabel = new QLabel ( tr ( " Email : " ) ) ; emailEdit = new QLineEdit ( ) ; emailLabel -> setBuddy ( emailEdit ) ; emailEdit -> setText ( email ) ; genderLabel = new QLabel ( tr ( " Pronouns : " ) ) ; genderEdit = new QComboBox ( ) ; genderLabel -> setBuddy ( genderEdit ) ; genderEdit -> insertItem ( 0 , QIcon ( " : / resources / genders / unknown . svg " ) , tr ( " Neutral " ) ) ; genderEdit -> insertItem ( 1 , QIcon ( " : / resources / genders / male . svg " ) , tr ( " Masculine " ) ) ; genderEdit -> insertItem ( 2 , QIcon ( " : / resources / genders / female . svg " ) , tr ( " Feminine " ) ) ; genderEdit -> setCurrentIndex ( gender + 1 ) ; countryLabel = new QLabel ( tr ( " Country : " ) ) ; countryEdit = new QComboBox ( ) ; countryLabel -> setBuddy ( countryEdit ) ; countryEdit -> insertItem ( 0 , tr ( " Undefined " ) ) ; countryEdit -> setCurrentIndex ( 0 ) ; QStringList countries = settingsCache -> getCountries ( ) ; int i = 1 ; foreach ( QString c , countries ) { countryEdit -> addItem ( QPixmap ( " : / resources / countries / " + c + " . svg " ) , c ) ; if ( c == country ) countryEdit -> setCurrentIndex ( i ) ; ++ i ; } realnameLabel = new QLabel ( tr ( " Real ▁ name : " ) ) ; realnameEdit = new QLineEdit ( ) ; realnameLabel -> setBuddy ( realnameEdit ) ; realnameEdit -> setText ( realName ) ; QGridLayout * grid = new QGridLayout ; grid -> addWidget ( emailLabel , 0 , 0 ) ; grid -> addWidget ( emailEdit , 0 , 1 ) ; grid -> addWidget ( genderLabel , 1 , 0 ) ; grid -> addWidget ( genderEdit , 1 , 1 ) ; grid -> addWidget ( countryLabel , 2 , 0 ) ; grid -> addWidget ( countryEdit , 2 , 1 ) ; grid -> addWidget ( realnameLabel , 3 , 0 ) ; grid -> addWidget ( realnameEdit , 3 , 1 ) ; QDialogButtonBox * buttonBox = new QDialogButtonBox ( QDialogButtonBox :: Ok | QDialogButtonBox :: Cancel ) ; connect ( buttonBox , SIGNAL ( accepted ( ) ) , this , SLOT ( actOk ( ) ) ) ; connect ( buttonBox , SIGNAL ( rejected ( ) ) , this , SLOT ( actCancel ( ) ) ) ; QVBoxLayout * mainLayout = new QVBoxLayout ; mainLayout -> addLayout ( grid ) ; mainLayout -> addWidget ( buttonBox ) ; setLayout ( mainLayout ) ; setWindowTitle ( tr ( " Edit ▁ user ▁ profile " ) ) ; setFixedHeight ( sizeHint ( ) . height ( ) ) ; setMinimumWidth ( 300 ) ; }
void DlgEditUser :: actOk ( ) { accept ( ) ; }
void DlgEditUser :: actCancel ( ) { reject ( ) ; }
Delete :: Delete ( const XmlNode & xmlNode ) : m_objectsHasBeenSet ( false ) , m_quiet ( false ) , m_quietHasBeenSet ( false ) { * this = xmlNode ; }
RCInterval :: RCInterval ( RCInterval :: RCReserved@@ Interval special ) : RCBase ( ) { switch ( special ) { case RCInterval :: now : interval = PR_Interval@@ Now ( ) ; break ; case RCInterval :: no_timeout : interval = PR_INTERVAL_NO_TIME@@ OUT ; break ; case RCInterval :: no_wait : interval = PR_INTERVAL_NO_WAIT ; break ; default : break ; } }
DataFieldManager :: DataFieldManager ( uint32_t dataSize , uint32_t averagerSize ) { m_dataSize = dataSize ; m_averagerSize = averagerSize ; m_fieldCount = 0 ; m_dataCount = 0 ; uint8_t i = 0 ; for ( i = 0 ; i < MAX_FIELDS ; i ++ ) { m_fields [ i ] = NULL ; } }
uint8_t DataFieldManager :: fieldCount ( ) { return m_fieldCount ; }
bool DataFieldManager :: addField ( NumericDataField * field ) { if ( ! field ) { return false ; } if ( m_fieldCount == MAX_FIELDS ) { return false ; } PLATFORM_specialField@@ Setup ( field ) ; field -> setDataSiz@@ es ( m_dataSize , m_averagerSize ) ; m_fields [ m_fieldCount ] = field ; m_channelNumbers [ m_fieldCount ] = field -> getChannelNumber ( ) ; m_fieldCount ++ ; return true ; }
bool DataFieldManager :: addField ( StringDataField * field ) { if ( ! field ) { return false ; } if ( m_fieldCount == MAX_FIELDS ) { return false ; } m_fields [ m_fieldCount ] = field ; m_channelNumbers [ m_fieldCount ] = field -> getChannelNumber ( ) ; m_fieldCount ++ ; return true ; }
void DataFieldManager :: storeDataArray ( int32_t * data ) { uint16_t field = 0 ; uint16_t dataIndex ; bool newAverageStored = false ; for ( field = 0 ; field < m_fieldCount ; field ++ ) { NumericDataField * pField = ( NumericDataField * ) m_fields [ field ] ; if ( pField ) { dataIndex = m_channelNumbers [ field ] - 1 ; newAverageStored |= pField -> storeData ( data [ dataIndex ] ) ; } } if ( newAverageStored ) { m_dataCount ++ ; } }
void DataFieldManager :: getDataArray ( float * buffer , bool converted , bool alsoRemove ) { uint16_t field ; for ( field = 0 ; field < m_fieldCount ; ++ field ) { if ( converted ) { buffer [ field ] = ( ( NumericDataField * ) m_fields [ field ] ) -> getConvData ( alsoRemove ) ; } else { buffer [ field ] = ( ( NumericDataField * ) m_fields [ field ] ) -> getRawData ( alsoRemove ) ; } } if ( alsoRemove ) { m_dataCount -- ; } }
DataField * DataFieldManager :: getChannel ( uint8_t channel ) { int32_t actualIndex = indexOf ( m_channelNumbers , ( uint32_t ) channel , m_fieldCount ) ; return actualIndex >= 0 ? m_fields [ actualIndex ] : NULL ; }
DataField * DataFieldManager :: getField ( uint8_t index ) { return m_fields [ index ] ; }
DataField * * DataFieldManager :: getFields ( void ) { return m_fields ; }
uint32_t DataFieldManager :: writeHeader@@ sToBuffer ( char * buffer , uint8_t bufferLength ) { if ( ! buffer ) { return 0 ; } uint8_t i ; FixedLengthAccumulator headerAccumulator ( buffer , bufferLength ) ; for ( i = 0 ; i < m_fieldCount ; ++ i ) { headerAccumulator . writeString ( m_fields [ i ] -> getTypeString ( ) ) ; if ( ! lastinloop ( i , m_fieldCount ) ) { headerAccumulator . writeString ( " , ▁ " ) ; } } headerAccumulator . writeString ( " \n " ) ; return headerAccumulator . length ( ) ; }
void DataFieldManager :: setupAllValidChannels ( void ) { uint8_t ch ; NumericDataField * field ; FIELD_TYPE type ; void * data ; uint32_t maxChannels = Settings_GetMax@@ Channels ( ) ; for ( ch = 1 ; ch < maxChannels ; ch ++ ) { if ( Settings_ChannelSettingIsValid ( ch ) ) { type = Settings_GetChannel@@ Type ( ch ) ; data = Settings_GetData ( ch ) ; switch ( type ) { case VOLTAGE : case CURRENT : case TEMPERATURE_C : case TEMPERATURE_K : case TEMPERATURE_F : field = new NumericDataField ( type , data , ch ) ; std :: cout << " Adding ▁ channel ▁ " << ( int ) ch << " , ▁ type ▁ " << field -> getTypeString ( ) << std :: endl ; addField ( field ) ; break ; default : break ; } } } }
bool DataFieldManager :: hasData ( void ) { uint8_t i = 0 ; bool atLeastOneFieldHasData = false ; for ( i = 0 ; i < m_fieldCount ; i ++ ) { atLeastOneFieldHasData |= m_fields [ i ] -> hasData ( ) ; } return atLeastOneFieldHasData ; }
uint32_t DataFieldManager :: count ( void ) { return m_dataCount ; }
uint32_t * DataFieldManager :: getChannelNumbers ( void ) { return m_channelNumbers ; }
unit_test :: test_suite * init_unit_test_suite ( int , char * [ ] ) { unit_test :: test_suite * suite = BOOST_TEST_SUITE ( " lexical _ cast . ▁ Testing ▁ conversions ▁ using ▁ iterator _ range < > " ) ; suite -> add ( BOOST_TEST_CASE ( & test_char_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_unsigned_char_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_signed_char_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_wchar_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_char16_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_char32_iterator_ranges ) ) ; return suite ; }
UserCode :: UserCode ( uint32 const _homeId , uint8 const _nodeId ) : CommandClass ( _homeId , _nodeId ) , m_queryAll ( false ) , m_currentCode ( 0 ) , m_userCodeCount ( 0 ) , m_refreshUserCodes ( false ) { SetStaticRequest ( StaticRequest_Values ) ; memset ( m_userCodesStatus , 0xff , sizeof ( m_userCodesStatus ) ) ; Options :: Get ( ) -> GetOptionAsBool ( " RefreshAllUserCodes " , & m_refreshUserCodes ) ; }
void UserCode :: ReadXML ( TiXmlElement const * _ccElement ) { int32 intVal ; CommandClass :: ReadXML ( _ccElement ) ; if ( TIXML_SUCCESS == _ccElement -> QueryIntAttribute ( " codes " , & intVal ) ) { m_userCodeCount = intVal ; } }
void UserCode :: WriteXML ( TiXmlElement * _ccElement ) { char str [ 32 ] ; CommandClass :: WriteXML ( _ccElement ) ; snprintf ( str , sizeof ( str ) , " % d " , m_userCodeCount ) ; _ccElement -> SetAttribute ( " codes " , str ) ; }
bool UserCode :: RequestState ( uint32 const _requestFlags , uint8 const _instance , Driver :: MsgQueue const _queue ) { bool requests = false ; if ( ( _requestFlags & RequestFla@@ g_Static ) && HasStaticRequest ( StaticRequest_Values ) ) { requests |= RequestValue ( _requestFlags , UserCodeIndex_Count , _instance , _queue ) ; } if ( _requestFlags & RequestFlag@@ _Session ) { if ( m_userCodeCount > 0 ) { m_queryAll = true ; m_currentCode = 1 ; requests |= RequestValue ( _requestFlags , m_currentCode , _instance , _queue ) ; } } return requests ; }
bool UserCode :: RequestValue ( uint32 const _requestFlags , uint8 const _userCodeIdx , uint8 const _instance , Driver :: MsgQueue const _queue ) { if ( _instance != 1 ) { return false ; } if ( ! IsGetSupported ( ) ) { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " UserNumberCmd _ Get ▁ Not ▁ Supported ▁ on ▁ this ▁ node " ) ; return false ; } if ( _userCodeIdx == UserCodeIndex_Count ) { Msg * msg = new Msg ( " UserNumberCmd _ Get " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true , true , FUNC_ID_APPLICATION_COMMAND_HANDLER , GetCommandClassId ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 2 ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserNumberCmd_Get ) ; msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , _queue ) ; return true ; } if ( _userCodeIdx == 0 ) { Log :: Write ( LogLevel_Warning , GetNodeId ( ) , " UserCodeCmd _ Get ▁ with ▁ Index ▁ 0 ▁ not ▁ Supported " ) ; return false ; } Msg * msg = new Msg ( " UserCodeCmd _ Get " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true , true , FUNC_ID_APPLICATION_COMMAND_HANDLER , GetCommandClassId ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 3 ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserCodeCmd_Get ) ; msg -> Append ( _userCodeIdx ) ; msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , _queue ) ; return true ; }
bool UserCode :: HandleMsg ( uint8 const * _data , uint32 const _length , uint32 const _instance ) { if ( UserNumberCmd_Report == ( UserCodeCmd ) _data [ 0 ] ) { m_userCodeCount = _data [ 1 ] ; if ( m_userCodeCount > 254 ) { m_userCodeCount = 254 ; } ClearStaticRequest ( StaticRequest_Values ) ; if ( m_userCodeCount == 0 ) { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Number ▁ report ▁ from ▁ node ▁ % d : ▁ Not ▁ supported " , GetNodeId ( ) ) ; } else { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Number ▁ report ▁ from ▁ node ▁ % d : ▁ Supported ▁ Codes ▁ % d ▁ ( % d ) " , GetNodeId ( ) , m_userCodeCount , _data [ 1 ] ) ; } if ( ValueByte * value = static_cast < ValueByte * > ( GetValue ( _instance , UserCodeIndex_Count ) ) ) { value -> OnValueRefreshed ( m_userCodeCount ) ; value -> Release ( ) ; } if ( Node * node = GetNodeUnsafe ( ) ) { uint8 data [ UserCodeLength ] ; memset ( data , 0 , UserCodeLength ) ; for ( uint8 i = 0 ; i <= m_userCodeCount ; i ++ ) { char str [ 16 ] ; if ( i == 0 ) { snprintf ( str , sizeof ( str ) , " Enrollment ▁ Code " ) ; node -> CreateValueRaw ( ValueID :: ValueGenre_User , GetCommandClassId ( ) , _instance , i , str , " " , true , false , data , UserCodeLength , 0 ) ; } else { snprintf ( str , sizeof ( str ) , " Code ▁ % d : " , i ) ; node -> CreateValueRaw ( ValueID :: ValueGenre_User , GetCommandClassId ( ) , _instance , i , str , " " , false , false , data , UserCodeLength , 0 ) ; } } } return true ; } else if ( UserCodeCmd_Report == ( UserCodeCmd ) _data [ 0 ] ) { int i = _data [ 1 ] ; if ( ValueRaw * value = static_cast < ValueRaw * > ( GetValue ( _instance , i ) ) ) { uint8 data [ UserCodeLength ] ; uint8 size = _length - 4 ; if ( size > UserCodeLength ) { Log :: Write ( LogLevel_Warning , GetNodeId ( ) , " User ▁ Code ▁ length ▁ % d ▁ is ▁ larger ▁ then ▁ maximum ▁ % d " , size , UserCodeLength ) ; size = UserCodeLength ; } m_userCodesStatus [ i ] = _data [ 2 ] ; memcpy ( data , & _data [ 3 ] , size ) ; value -> OnValueRefreshed ( data , size ) ; value -> Release ( ) ; } Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Code ▁ Report ▁ from ▁ node ▁ % d ▁ for ▁ User ▁ Code ▁ % d ▁ ( % s ) " , GetNodeId ( ) , i , CodeStatus ( _data [ 2 ] ) . c_str ( ) ) ; if ( m_queryAll && i == m_currentCode ) { if ( m_refreshUserCodes || ( _data [ 2 ] != UserCode_Available ) ) { if ( ++ i <= m_userCodeCount ) { m_currentCode = i ; RequestValue ( 0 , m_currentCode , _instance , Driver :: MsgQueue_Query ) ; } else { m_queryAll = false ; Options :: Get ( ) -> GetOptionAsBool ( " RefreshAllUserCodes " , & m_refreshUserCodes ) ; } } else { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Not ▁ Requesting ▁ additional ▁ UserCode ▁ Slots ▁ as ▁ RefreshAllUserCodes ▁ is ▁ false , ▁ and ▁ slot ▁ % d ▁ is ▁ available " , i ) ; m_queryAll = false ; } } return true ; } return false ; }
bool UserCode :: SetValue ( Value const & _value ) { if ( ( ValueID :: ValueType_Raw == _value . GetID ( ) . GetType ( ) ) && ( _value . GetID ( ) . GetIndex ( ) < UserCodeIndex_Refresh ) ) { ValueRaw const * value = static_cast < ValueRaw const * > ( & _value ) ; uint8 * s = value -> GetValue ( ) ; uint8 len = value -> GetLength ( ) ; if ( len > UserCodeLength ) { return false ; } m_userCodesStatus [ value -> GetID ( ) . GetIndex ( ) ] = UserCode_Occupied ; Msg * msg = new Msg ( " UserCodeCmd _ Set " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true ) ; msg -> SetInstance ( this , _value . GetID ( ) . GetInstance ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 4 + len ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserCodeCmd_Set ) ; msg -> Append ( value -> GetID ( ) . GetIndex ( ) ) ; msg -> Append ( UserCode_Occupied ) ; for ( uint8 i = 0 ; i < len ; i ++ ) { msg -> Append ( s [ i ] ) ; } msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , Driver :: MsgQueue@@ _Send ) ; return true ; } if ( ( ValueID :: ValueType_Button == _value . GetID ( ) . GetType ( ) ) && ( _value . GetID ( ) . GetIndex ( ) == UserCodeIndex_Refresh ) ) { m_refreshUserCodes = true ; m_currentCode = 1 ; m_queryAll = true ; RequestValue ( 0 , m_currentCode , _value . GetID ( ) . GetInstance ( ) , Driver :: MsgQueue_Query ) ; return true ; } return false ; }
void UserCode :: CreateVars ( uint8 const _instance ) { if ( Node * node = GetNodeUnsafe ( ) ) { node -> CreateValueByte ( ValueID :: ValueGenre_System , GetCommandClassId ( ) , _instance , UserCodeIndex_Count , " Code ▁ Count " , " " , true , false , 0 , 0 ) ; node -> CreateValue@@ Button ( ValueID :: ValueGenre_System , GetCommandClassId ( ) , _instance , UserCodeIndex_Refresh , " Refresh ▁ All ▁ UserCodes " , 0 ) ; } }
const TibetanClassTable * TibetanClassTable :: getTibetanClassTable ( ) { return & tibetanClassTable ; }
void LocalCapture :: createAPC@@ Directory ( char * target_path ) { gSessionData -> mAPCDir = createUniqueDirectory ( target_path , " . apc " ) ; if ( ( removeDirAndAllContents ( gSessionData -> mAPCDir ) != 0 || mkdir ( gSessionData -> mAPCDir , S_IRWXU | S_IRWXG | S_IROTH | S_IX@@ OTH ) != 0 ) ) { logg -> logError ( __FILE__ , __LINE__ , " Unable ▁ to ▁ create ▁ directory ▁ % s " , gSessionData -> mAPCDir ) ; handleException ( ) ; } }
void LocalCapture :: write ( char * string ) { char file [ PATH_MAX ] ; snprintf ( file , PATH_MAX , " % s / session . xml " , gSessionData -> mAPCDir ) ; if ( util -> writeToDisk ( file , string ) < 0 ) { logg -> logError ( __FILE__ , __LINE__ , " Error ▁ writing ▁ % s \n Please ▁ verify ▁ the ▁ path . " , file ) ; handleException ( ) ; } EventsXML eventsXML ; eventsXML . write ( gSessionData -> mAPCDir ) ; }
char * LocalCapture :: createUniqueDirectory ( const char * initialPath , const char * ending ) { char * output ; char path [ PATH_MAX ] ; if ( initialPath == 0 || strlen ( initialPath ) == 0 ) { logg -> logError ( __FILE__ , __LINE__ , " Missing ▁ - o ▁ command ▁ line ▁ option ▁ required ▁ for ▁ a ▁ local ▁ capture . " ) ; handleException ( ) ; } else if ( initialPath [ 0 ] != ' / ' ) { if ( getcwd ( path , PATH_MAX ) == 0 ) { logg -> logMessage ( " Unable ▁ to ▁ retrieve ▁ the ▁ current ▁ working ▁ directory " ) ; } strncat ( path , " / " , PATH_MAX - strlen ( path ) - 1 ) ; strncat ( path , initialPath , PATH_MAX - strlen ( path ) - 1 ) ; } else { strncpy ( path , initialPath , PATH_MAX ) ; path [ PATH_MAX - 1 ] = 0 ; } if ( strcmp ( & path [ strlen ( path ) - strlen ( ending ) ] , ending ) != 0 ) { strncat ( path , ending , PATH_MAX - strlen ( path ) - 1 ) ; } output = strdup ( path ) ; return output ; }
int LocalCapture :: removeDirAndAllContents ( char * path ) { int error = 0 ; struct stat mFileInfo ; if ( stat ( path , & mFileInfo ) == 0 ) { if ( mFileInfo . st_mode & S_IF@@ DIR ) { DIR * dir = opendir ( path ) ; dirent * entry = readdir ( dir ) ; while ( entry ) { if ( strcmp ( entry -> d_name , " . " ) != 0 && strcmp ( entry -> d_name , " . . " ) != 0 ) { char * newpath = ( char * ) malloc ( strlen ( path ) + strlen ( entry -> d_name ) + 2 ) ; sprintf ( newpath , " % s / % s " , path , entry -> d_name ) ; error = removeDirAndAllContents ( newpath ) ; free ( newpath ) ; if ( error ) { break ; } } entry = readdir ( dir ) ; } closedi@@ r ( dir ) ; if ( error == 0 ) { error = rmdir ( path ) ; } } else { error = remove ( path ) ; } } return error ; }
void LocalCapture :: copyImages ( ImageLink@@ List * ptr ) { char dstfilename [ PATH_MAX ] ; while ( ptr ) { strncpy ( dstfilename , gSessionData -> mAPCDir , PATH_MAX ) ; dstfilename [ PATH_MAX - 1 ] = 0 ; if ( gSessionData -> mAPCDir [ strlen ( gSessionData -> mAPCDir ) - 1 ] != ' / ' ) { strncat ( dstfilename , " / " , PATH_MAX - strlen ( dstfilename ) - 1 ) ; } strncat ( dstfilename , util -> getFilePart ( ptr -> path ) , PATH_MAX - strlen ( dstfilename ) - 1 ) ; if ( util -> copyFile ( ptr -> path , dstfilename ) ) { logg -> logMessage ( " copied ▁ file ▁ % s ▁ to ▁ % s " , ptr -> path , dstfilename ) ; } else { logg -> logMessage ( " copy ▁ of ▁ file ▁ % s ▁ to ▁ % s ▁ failed " , ptr -> path , dstfilename ) ; } ptr = ptr -> next ; } }
bool CBOINCGUIApp :: OnInit ( ) { g_use_sandbox = true ; g_use_sandbox = false ; s_bSkipExitConfirmation = false ; m_bFilterEvents = false ; m_pLocale = NULL ; m_pSkinManager = NULL ; m_pFrame = NULL ; m_pDocument = NULL ; m_pTaskBarIcon = NULL ; m_pEventLog = NULL ; m_pMacSystemMenu = NULL ; m_strBOINCMGRExecutableName = wxEmptyString ; m_strBOINCMGRRootDirectory = wxEmptyString ; m_strBOINCMGRDataDirectory = wxEmptyString ; m_strHostNameArg = wxEmptyString ; m_strPasswordArg = wxEmptyString ; m_iRPCPortArg = GUI_RPC_PORT ; m_strBOINCArguments = wxEmptyString ; m_bGUIVisible = true ; m_bDebugSkins = false ; m_bMultipleInstancesOK = false ; m_bBOINCMGRAutoStarted = false ; m_iBOINCMGRDisableAutoStart = 0 ; m_iShutdownCoreClient = 0 ; m_iDisplayExitDialog = 1 ; m_iGUISelected = BOINC_SIMPLEGUI ; m_bSafeMessageBoxDisplayed = 0 ; m_hClient@@ LibraryDll = NULL ; int iErrorCode = 0 ; int iSelectedLanguage = 0 ; bool bOpenEventLog = false ; wxString strDesiredSkinName = wxEmptyString ; wxString strDialogMessage = wxEmptyString ; bool success = false ; wxSystemOptions :: SetOption ( wxT ( " msw . staticbox . optimized - paint " ) , 0 ) ; wxSystemOptions :: SetOption ( wxT ( " mac . listctr@@ l . always _ use _ generic " ) , 1 ) ; AEInstallEventHandler ( kCoreEventClass , kAEQuitApplication , NewAE@@ EventHandlerUPP ( ( AEEventHandler@@ ProcPtr ) QuitAppleEventHandler ) , 0 , false ) ; GetCurrentProcess ( & m_psnCurrentProcess ) ; if ( ! wxApp :: OnInit ( ) ) { return false ; } if ( g_use_sandbox ) { wxCHANGE_UMASK ( 2 ) ; } SetAppName ( wxT ( " BOINC ▁ Manager " ) ) ; SetVendorName ( wxT ( " Space ▁ Sciences ▁ Laboratory , ▁ U . C . ▁ Berkeley " ) ) ; m_pConfig = new wxConfig ( GetAppName ( ) ) ; wxConfigBase :: Set ( m_pConfig ) ; wxASSERT ( m_pConfig ) ; m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Read ( wxT ( " AutomaticallyShutdownClient " ) , & m_iShutdownCoreClient , 0L ) ; m_pConfig -> Read ( wxT ( " DisplayShutdownClientDialog " ) , & m_iDisplayExitDialog , 1L ) ; m_pConfig -> Read ( wxT ( " DisableAutoStart " ) , & m_iBOINCMGRDisableAutoStart , 0L ) ; m_pConfig -> Read ( wxT ( " Language " ) , & iSelectedLanguage , 0L ) ; m_pConfig -> Read ( wxT ( " GUISelection " ) , & m_iGUISelected , BOINC_SIMPLEGUI ) ; m_pConfig -> Read ( wxT ( " EventLogOpen " ) , & bOpenEventLog ) ; if ( m_bBOINCMGRAutoStarted && m_iBOINCMGRDisableAutoStart ) { return false ; } DetectExecutableName ( ) ; DetectRootDirectory ( ) ; DetectDataDirectory ( ) ; if ( ! GetDataDirectory ( ) . IsEmpty ( ) ) { success = wxSetWorkingDirectory ( GetDataDirectory ( ) ) ; if ( ! success ) { if ( ! g_use_sandbox ) { if ( ! wxDirExists ( GetDataDirectory ( ) ) ) { success = wxMkdir ( GetDataDirectory ( ) , 0777 ) ; } } } } if ( ! success ) iErrorCode = - 1016 ; int dwDiagnosticsFlags = BOINC_DIAG_DUM@@ PCALLSTACKENABLED | BOINC_DIAG_HEAP@@ CHECKENABLED | BOINC_DIAG_MEMORY@@ LEAKCHECKENABLED | || defined ( __WXMAC__ ) BOINC_DIAG_REDIRECTSTDERR | BOINC_DIAG_REDIRECTSTDOUT | BOINC_DIAG_TRACETOS@@ TDOUT ; diagnostics_init ( dwDiagnosticsFlags , " stdoutgui " , " stderrgui " ) ; m_pLog = new wxLogBOINC ( ) ; wxLog :: SetActiveTarget ( m_pLog ) ; m_pLog -> AddTraceMask ( wxT ( " Function ▁ Start / End " ) ) ; m_pLog -> AddTraceMask ( wxT ( " Function ▁ Status " ) ) ; _configthreadlocale ( _ENABLE_PER_THREAD_LOCAL@@ E ) ; m_pLocale = new wxLocale ( ) ; wxASSERT ( m_pLocale ) ; m_pLocale -> Init ( iSelectedLanguage ) ; if ( ! m_strBOINCMGRRootDirectory . IsEmpty ( ) ) { m_pLocale -> AddCatalogLookupPathPrefix ( wxString ( m_strBOINCMGRRootDirectory + wxT ( " locale " ) ) ) ; } m_pLocale -> AddCatalogLookupPathPrefix ( wxT ( " locale " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Manager " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Client " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Web " ) ) ; InitSupportedLanguages ( ) ; wxHelpProvider :: Set ( new wxHelpControllerHelp@@ Provider ( ) ) ; wxInitAllImage@@ Handlers ( ) ; wxFileSystem :: AddHandler ( new wxMemoryFSHandler ) ; m_pInternetFSHandler = new CBOINCInternetFSHandler ; wxFileSystem :: AddHandler ( m_pInternetFSHandler ) ; m_pSkinManager = new CSkinManager ( m_bDebugSkins ) ; wxASSERT ( m_pSkinManager ) ; m_pConfig -> Read ( wxT ( " Skin " ) , & strDesiredSkinName , m_pSkinManager -> GetDefaultSkinName ( ) ) ; m_pSkinManager -> ReloadSkin ( strDesiredSkinName ) ; char path_to_error [ MAXPATH@@ LEN ] ; path_to_error [ 0 ] = ' \0' ; if ( ! iErrorCode ) { defined ( __WXMAC__ ) && defined ( _DEBUG ) ) if ( check_security ( g_use_sandbox , true ) ) { CreateBOINC@@ UsersAnd@@ Groups ( ) ; SetBOINCDataOwnersGroupsAndPermissions ( ) ; SetBOINCAppOwnersGroupsAndPermissions ( NULL ) ; } iErrorCode = check_security ( g_use_sandbox , true , path_to_error ) ; } if ( iErrorCode ) { ShowApplication ( true ) ; if ( iErrorCode == - 1099 ) { strDialogMessage . Printf ( _ ( " You ▁ currently ▁ are ▁ not ▁ author@@ ized ▁ to ▁ manage ▁ the ▁ client . \n \n To ▁ run ▁ % s ▁ as ▁ this ▁ user , ▁ please : \n ▁ ▁ - ▁ reinstall ▁ % s ▁ answering ▁ \ " Y@@ es \ " ▁ to ▁ the ▁ question ▁ about \n ▁ ▁ ▁ ▁ ▁ non - administrative ▁ users \n ▁ or \n ▁ ▁ - ▁ contact ▁ your ▁ administrator ▁ to ▁ add ▁ you ▁ to ▁ the ▁ ' boinc _ master ' \n ▁ ▁ ▁ ▁ ▁ user ▁ group . " ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) ) ; } else { strDialogMessage . Printf ( _ ( " % s ▁ ownership ▁ or ▁ permissions ▁ are ▁ not ▁ set ▁ properly ; ▁ please ▁ reinstall ▁ % s . \n ( Error ▁ code ▁ % d " ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , iErrorCode ) ; if ( path_to_error [ 0 ] ) { strDialogMessage += _ ( " ▁ at ▁ " ) ; strDialogMessage += wxString :: FromUTF8 ( path_to_error ) ; } strDialogMessage += _ ( " ) " ) ; fprintf ( stderr , " % ls ▁ ownership ▁ or ▁ permissions ▁ are ▁ not ▁ set ▁ properly ; ▁ please ▁ reinstall ▁ % ls . \n ( Error ▁ code ▁ % d ▁ at ▁ % s ) " , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , iErrorCode , path_to_error ) ; } wxMessageDialog * pDlg = new wxMessageDialog ( NULL , strDialogMessage , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , wxOK ) ; pDlg -> ShowModal ( ) ; if ( pDlg ) pDlg -> Destroy ( ) ; return false ; } wxString strRebootPendingFile = GetRootDirectory ( ) + wxFileName :: GetPathSeparator ( ) + wxT ( " RebootPending . txt " ) ; if ( wxFile :: Exists ( strRebootPendingFile ) ) { wxMessageDialog dialog ( NULL , _ ( " A ▁ reboot ▁ is ▁ required ▁ in ▁ order ▁ for ▁ BOINC ▁ to ▁ run ▁ properly . \n Please ▁ reboot ▁ your ▁ computer ▁ and ▁ try ▁ again . " ) , _ ( " BOINC ▁ Manager " ) , wxOK | wxICON_ERROR ) ; dialog . ShowModal ( ) ; return false ; } if ( ! m_bMultipleInstancesOK ) { if ( DetectDuplicateInstance ( ) ) { return false ; } } m_pDocument = new CMainDocument ( ) ; wxASSERT ( m_pDocument ) ; m_pDocument -> OnInit ( ) ; if ( BOINC_SIMPLEGUI == m_iGUISelected ) { if ( wxGetDisplaySize ( ) . GetHeight ( ) < 600 ) { m_iGUISelected = BOINC_ADVANCEDGUI ; } } m_pTaskBarIcon = new CTaskBarIcon ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationDisconnectedIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationSnoozeIcon ( ) ) ; wxASSERT ( m_pTaskBarIcon ) ; m_pMacSystemMenu = new CMacSystemMenu ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationDisconnectedIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationSnoozeIcon ( ) ) ; wxASSERT ( m_pMacSystemMenu ) ; IdleTrackerAttach ( ) ; ProcessSerialNumber psn ; ProcessInfoRec pInfo ; OSStatus err ; memset ( & pInfo , 0 , sizeof ( pInfo ) ) ; pInfo . processInfoLength = sizeof ( ProcessInfoRec ) ; err = GetProcessInformation ( & m_psnCurrentProcess , & pInfo ) ; if ( ! err ) { psn = pInfo . processLauncher ; memset ( & pInfo , 0 , sizeof ( pInfo ) ) ; pInfo . processInfoLength = sizeof ( ProcessInfoRec ) ; err = GetProcessInformation ( & psn , & pInfo ) ; } if ( pInfo . processSignature == ' lgnw ' ) { m_bGUIVisible = false ; sleep ( 10 ) ; } SetActiveGUI ( m_iGUISelected , false ) ; if ( m_bGUIVisible ) { SetActiveGUI ( m_iGUISelected ) ; } else { ShowApplication ( false ) ; } if ( bOpenEventLog ) { DisplayEventLog ( m_bGUIVisible ) ; m_pFrame -> Raise ( ) ; } return true ; }
int CBOINCGUIApp :: OnExit ( ) { IdleTrackerDetach ( ) ; if ( m_pDocument ) { m_pDocument -> OnExit ( ) ; delete m_pDocument ; m_pDocument = NULL ; } m_pConfig -> SetPath ( wxT ( " / " ) ) ; if ( m_pSkinManager ) { m_pConfig -> Write ( wxT ( " Skin " ) , m_pSkinManager -> GetSelectedSkin ( ) ) ; delete m_pSkinManager ; } if ( m_pLocale ) { delete m_pLocale ; m_pLocale = NULL ; } if ( m_pEventLog ) { m_pEventLog -> Destroy ( ) ; m_pEventLog = NULL ; } m_pConfig -> Write ( wxT ( " AutomaticallyShutdownClient " ) , m_iShutdownCoreClient ) ; m_pConfig -> Write ( wxT ( " DisplayShutdownClientDialog " ) , m_iDisplayExitDialog ) ; m_pConfig -> Write ( wxT ( " DisableAutoStart " ) , m_iBOINCMGRDisableAutoStart ) ; diagnostics_@@ finish ( ) ; return wxApp :: OnExit ( ) ; }
void CBOINCGUIApp :: OnInitCmdLine ( wxCmdLineParser & parser ) { wxApp :: OnInitCmdLine ( parser ) ; static const wxCmdLineEntryDesc cmdLineDesc [ ] = { { wxCMD_LINE_SWITCH , wxT ( " a " ) , wxT ( " autostart " ) , _ ( " BOINC ▁ Manager ▁ was ▁ started ▁ by ▁ the ▁ operating ▁ system ▁ automati@@ cally " ) } , || defined ( __WXMAC__ ) { wxCMD_LINE_SWITCH , wxT ( " s " ) , wxT ( " systray " ) , _ ( " Startup ▁ BOINC ▁ so ▁ only ▁ the ▁ system ▁ tray ▁ icon ▁ is ▁ visible " ) } , { wxCMD_LINE_OPTION , wxT ( " e " ) , wxT ( " clientdir " ) , _ ( " Directory ▁ containing ▁ the ▁ BOINC ▁ Client ▁ executable " ) } , { wxCMD_LINE_OPTION , wxT ( " d " ) , wxT ( " datadir " ) , _ ( " BOINC ▁ data ▁ directory " ) } , { wxCMD_LINE_OPTION , wxT ( " n " ) , wxT ( " namehost " ) , _ ( " Host ▁ name ▁ or ▁ IP ▁ address " ) } , { wxCMD_LINE_OPTION , wxT ( " g " ) , wxT ( " gui _ rpc _ port " ) , _ ( " GUI ▁ RPC ▁ port ▁ number " ) } , { wxCMD_LINE_OPTION , wxT ( " p " ) , wxT ( " password " ) , _ ( " Password " ) } , { wxCMD_LINE_OPTION , wxT ( " b " ) , wxT ( " boincargs " ) , _ ( " Startup ▁ BOINC ▁ with ▁ these ▁ optional ▁ arguments " ) } , { wxCMD_LINE_SWITCH , wxT ( " i " ) , wxT ( " insecure " ) , _ ( " disable ▁ BOINC ▁ security ▁ users ▁ and ▁ permissions " ) } , { wxCMD_LINE_SWITCH , wxT ( " c " ) , wxT ( " checkskins " ) , _ ( " set ▁ skin ▁ debugging ▁ mode ▁ to ▁ enable ▁ skin ▁ manager ▁ error ▁ messages " ) } , { wxCMD_LINE_SWITCH , wxT ( " m " ) , wxT ( " multiple " ) , _ ( " multiple ▁ instances ▁ of ▁ BOINC ▁ Manager ▁ allowed " ) } , defined ( __WXMAC__ ) && defined ( _DEBUG ) ) { wxCMD_LINE_OPTION , wxT ( " NSDocumentRevi@@ sionsDebug@@ Mode " ) , NULL , _ ( " Not ▁ used : ▁ workaround ▁ for ▁ bug ▁ in ▁ XCode ▁ 4.2" ) } , { wxCMD_LINE_NONE } } ; parser . SetDesc ( cmdLineDesc ) ; }
bool CBOINCGUIApp :: OnCmdLineParsed ( wxCmdLineParser & parser ) { wxApp :: OnCmdLineParsed ( parser ) ; wxString portNum = wxEmptyString ; long longPort ; bool hostNameSpecified = false ; bool passwordSpecified = false ; parser . Found ( wxT ( " boincargs " ) , & m_strBOINCArguments ) ; if ( parser . Found ( wxT ( " autostart " ) ) ) { m_bBOINCMGRAutoStarted = true ; } || defined ( __WXMAC__ ) if ( parser . Found ( wxT ( " systray " ) ) ) { m_bGUIVisible = false ; } if ( parser . Found ( wxT ( " insecure " ) ) ) { g_use_sandbox = false ; } if ( parser . Found ( wxT ( " checkskins " ) ) ) { m_bDebugSkins = true ; } if ( parser . Found ( wxT ( " multiple " ) ) ) { m_bMultipleInstancesOK = true ; } ( defined ( __WXMSW__ ) || defined ( __WXMAC__ ) ) if ( ! parser . Found ( wxT ( " clientdir " ) , & m_strBOINCMGRRootDirectory ) ) { m_strBOINCMGRRootDirectory = :: wxGetCwd ( ) ; } if ( m_strBOINCMGRRootDirectory . Last ( ) != ' / ' ) { m_strBOINCMGRRootDirectory . Append ( ' / ' ) ; } if ( ! parser . Found ( wxT ( " datadir " ) , & m_strBOINCMGRDataDirectory ) ) { m_strBOINCMGRDataDirectory = m_strBOINCMGRRootDirectory ; } if ( m_strBOINCMGRDataDirectory . Last ( ) != ' / ' ) { m_strBOINCMGRDataDirectory . Append ( ' / ' ) ; } if ( parser . Found ( wxT ( " namehost " ) , & m_strHostNameArg ) ) { hostNameSpecified = true ; } else { m_strHostNameArg = wxT ( " localhost " ) ; } if ( parser . Found ( wxT ( " gui _ rpc _ port " ) , & portNum ) ) { if ( portNum . ToLong ( & longPort ) ) { m_iRPCPortArg = longPort ; } else { m_iRPCPortArg = GUI_RPC_PORT ; } } else { m_iRPCPortArg = GUI_RPC_PORT ; } if ( parser . Found ( wxT ( " password " ) , & m_strPasswordArg ) ) { passwordSpecified = true ; } else { m_strPasswordArg = wxEmptyString ; } if ( hostNameSpecified && passwordSpecified ) { m_bMultipleInstancesOK = true ; } return true ; }
bool CBOINCGUIApp :: DetectDuplicateInstance ( ) { if ( CTaskBarIcon :: FireAppRestore ( ) ) { return true ; } ProcessSerialNumber PSN ; int iInstanceID = wxGetApp ( ) . IsAnotherInstanceRunning ( ) ; if ( iInstanceID ) { OSStatus err = GetProcessForPID ( iInstanceID , & PSN ) ; if ( ! err ) SetFrontProcess ( & PSN ) ; return true ; } return false ; }
void CBOINCGUIApp :: DetectExecutableName ( ) { TCHAR szPath [ MAX_PATH - 1 ] ; GetModuleFileName ( NULL , szPath , ( sizeof ( szPath ) / sizeof ( TCHAR ) ) ) ; TCHAR * pszProg = _tcsrchr ( szPath , ' \\ ' ) ; if ( pszProg ) { pszProg ++ ; } m_strBOINCMGRExecutableName = pszProg ; }
void CBOINCGUIApp :: DetectRootDirectory ( ) { TCHAR szPath [ MAX_PATH - 1 ] ; GetModuleFileName ( NULL , szPath , ( sizeof ( szPath ) / sizeof ( TCHAR ) ) ) ; TCHAR * pszProg = _tcsrchr ( szPath , ' \\ ' ) ; if ( pszProg ) { szPath [ pszProg - szPath + 1 ] = 0 ; } m_strBOINCMGRRootDirectory = szPath ; }
void CBOINCGUIApp :: DetectDataDirectory ( ) { LONG lReturnValue ; HKEY hkSetupHive ; LPTSTR lpszRegistryValue = NULL ; DWORD dwSize = 0 ; lReturnValue = RegOpen@@ KeyEx ( HKEY_LOCAL_MACH@@ INE , _T ( " SOFTWARE\\@@ Space ▁ Sciences ▁ Laboratory , ▁ U . C . ▁ Berkeley\\@@ BOINC ▁ Setup " ) , 0 , KEY_READ , & hkSetupHive ) ; if ( lReturnValue == ERROR_SUCCESS ) { lReturnValue = RegQueryValueEx ( hkSetupHive , _T ( " DATADIR " ) , NULL , NULL , NULL , & dwSize ) ; if ( lReturnValue != ERROR_FILE_NOT_FOUND ) { lpszRegistryValue = ( LPTSTR ) malloc ( dwSize ) ; ( * lpszRegistryValue ) = NULL ; lReturnValue = RegQueryValueEx ( hkSetupHive , _T ( " DATADIR " ) , NULL , NULL , ( LPBYTE ) lpszRegistryValue , & dwSize ) ; m_strBOINCMGRDataDirectory = lpszRegistryValue ; } } if ( hkSetupHive ) RegClose@@ Key ( hkSetupHive ) ; if ( lpszRegistryValue ) free ( lpszRegistryValue ) ; m_strBOINCMGRDataDirectory = wxT ( " / Library / Application ▁ Support / BOINC ▁ Data " ) ; }
void CBOINCGUIApp :: InitSupportedLanguages ( ) { wxInt32 iIndex = 0 ; const wxLanguageInfo * liLanguage = NULL ; m_astrLanguages . Insert ( wxEmptyString , 0 , wxLANGUAGE_USER_DEFINED + 1 ) ; m_astrLanguages [ wxLANGUAGE_DEFAULT ] = _ ( " ( Automatic ▁ Detection ) " ) ; m_astrLanguages [ wxLANGUAGE_UNKNOWN ] = _ ( " ( Unknown ) " ) ; m_astrLanguages [ wxLANGUAGE_USER_DEFINED ] = _ ( " ( User ▁ Defined ) " ) ; for ( iIndex = 0 ; iIndex <= wxLANGUAGE_USER_DEFINED ; iIndex ++ ) { liLanguage = wxLocale :: GetLanguageInfo ( iIndex ) ; if ( liLanguage ) { m_astrLanguages [ iIndex ] = liLanguage -> Description ; } } }
int CBOINCGUIApp :: IdleTrackerAttach ( ) { :: attach_idle_monitor ( ) ; return 0 ; }
int CBOINCGUIApp :: IdleTrackerDetach ( ) { :: detach_idle_monitor ( ) ; return 0 ; }
void CBOINCGUIApp :: OnActivateApp ( wxActivateEvent & event ) { if ( IsModalDialogDisplayed ( ) ) { event . Skip ( ) ; return ; } if ( event . GetActive ( ) ) { if ( m_pEventLog && ! m_pEventLog -> IsIconized ( ) ) { m_pEventLog -> Raise ( ) ; } if ( m_pFrame ) m_pFrame -> Raise ( ) ; } event . Skip ( ) ; }
void CBOINCGUIApp :: OnRPCFinished ( CRPC@@ FinishedEvent & event ) { CMainDocument * pDoc = wxGetApp ( ) . GetDocument ( ) ; wxASSERT ( pDoc ) ; wxASSERT ( wxDynamicCast ( pDoc , CMainDocument ) ) ; pDoc -> OnRPCComplete ( event ) ; }
int CBOINCGUIApp :: UpdateSystem@@ IdleDetection ( ) { return get_idle_@@ tick_count ( ) ; return TRUE ; }
int CBOINCGUIApp :: StartBOINCScreensaverTest ( ) { wxString strExecute = wxEmptyString ; wxChar szExecutableDirectory [ 4096 ] ; memset ( szExecutableDirectory , 0 , sizeof ( szExecutableDirectory ) ) ; GetWindowsDirectory ( szExecutableDirectory , ( sizeof ( szExecutableDirectory ) / sizeof ( wxChar ) ) ) ; strExecute = wxT ( " \ " " ) + wxString ( szExecutableDirectory ) + wxT ( " \ \ boinc . scr \ " ▁ / t " ) ; :: wxExecute ( strExecute ) ; return 0 ; }
int CBOINCGUIApp :: StartBOINCDefaultScreensaverTest ( ) { wxString strExecute = wxEmptyString ; strExecute = wxT ( " \ " " ) + m_strBOINCMGRRootDirectory + wxT ( " \ \ boinc@@ scr . exe \ " ▁ - - test " ) ; :: wxExecute ( strExecute ) ; return 0 ; }
void CBOINCGUIApp :: DisplayEventLog ( bool bShowWindow ) { if ( m_pEventLog ) { if ( bShowWindow ) { if ( m_pEventLog -> IsIconized ( ) ) { m_pEventLog -> Iconize ( false ) ; } m_pEventLog -> Raise ( ) ; } } else { m_pEventLog = new CDlgEventLog ( ) ; if ( m_pEventLog ) { m_pEventLog -> Show ( bShowWindow ) ; if ( bShowWindow ) { m_pEventLog -> Raise ( ) ; } if ( m_pFrame ) { m_pFrame -> UpdateRefreshTimerInterval ( ) ; } } } }
void CBOINCGUIApp :: OnEventLog@@ Close ( ) { m_pEventLog = NULL ; if ( m_pFrame ) { m_pFrame -> UpdateRefreshTimerInterval ( ) ; } }
void CBOINCGUIApp :: FireReloadSkin ( ) { if ( m_pFrame ) { m_pFrame -> FireReloadSkin ( ) ; } if ( m_pTaskBarIcon ) { m_pTaskBarIcon -> FireReloadSkin ( ) ; } }
bool CBOINCGUIApp :: SetActiveGUI ( int iGUISelection , bool bShowWindow ) { wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ Function ▁ Begin " ) ) ; wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ GUI ▁ Selection : ▁ ' % d ' , ▁ Show : ▁ % d ' " ) , iGUISelection , ( int ) bShowWindow ) ; CBOINCBaseFrame * pNewFrame = NULL ; CBOINCBaseFrame * pOldFrame = m_pFrame ; wxInt32 iTop = 0 ; wxInt32 iLeft = 0 ; wxInt32 iHeight = 0 ; wxInt32 iWidth = 0 ; if ( ( iGUISelection != m_iGUISelected ) || ! m_pFrame ) { if ( BOINC_ADVANCEDGUI == iGUISelection ) { m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Read ( wxT ( " YPos " ) , & iTop , 30 ) ; m_pConfig -> Read ( wxT ( " XPos " ) , & iLeft , 30 ) ; m_pConfig -> Read ( wxT ( " Width " ) , & iWidth , 800 ) ; m_pConfig -> Read ( wxT ( " Height " ) , & iHeight , 600 ) ; } else { m_pConfig -> SetPath ( wxT ( " / Simple " ) ) ; m_pConfig -> Read ( wxT ( " YPos " ) , & iTop , 30 ) ; m_pConfig -> Read ( wxT ( " XPos " ) , & iLeft , 30 ) ; iWidth = 409 ; iHeight = 561 ; iWidth = 416 ; iHeight = 570 ; } if ( ! IsWindow@@ OnScreen ( iLeft , iTop , iWidth , iHeight ) ) { iTop = iLeft = 30 ; } if ( iLeft < 0 ) iLeft = 30 ; if ( iTop < 0 ) iTop = 30 ; wxInt32 iMaxWidth = wxSystemSettings :: GetMetric ( wxSYS_SCREEN_X ) ; wxInt32 iMaxHeight = wxSystemSettings :: GetMetric ( wxSYS_SCREEN_Y ) ; if ( iLeft + iWidth > iMaxWidth ) iLeft = iMaxWidth - iWidth ; if ( iTop + iHeight > iMaxHeight ) iTop = iMaxHeight - iHeight ; if ( BOINC_ADVANCEDGUI == iGUISelection ) { pNewFrame = new CAdvancedFrame ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon32 ( ) , wxPoint ( iLeft , iTop ) , wxSize ( iWidth , iHeight ) ) ; } else { pNewFrame = new CSimpleFrame ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon32 ( ) , wxPoint ( iLeft , iTop ) , wxSize ( iWidth , iHeight ) ) ; } wxASSERT ( pNewFrame ) ; if ( pNewFrame ) { SetTopWindow ( pNewFrame ) ; m_pFrame = pNewFrame ; if ( pOldFrame ) pOldFrame -> Hide ( ) ; if ( pOldFrame ) pOldFrame -> Destroy ( ) ; } } if ( m_pFrame && bShowWindow ) { if ( m_pEventLog ) { m_pEventLog -> Show ( ) ; m_pEventLog -> Raise ( ) ; :: SetForegroundWindow ( ( HWND ) m_pEventLog -> GetHWND ( ) ) ; } if ( ! m_pFrame -> IsShown ( ) ) { m_pFrame -> Show ( ) ; } if ( m_pFrame -> IsIconized ( ) ) { m_pFrame -> Maximize ( false ) ; } m_pFrame -> Raise ( ) ; :: SetForegroundWindow ( ( HWND ) m_pFrame -> GetHWND ( ) ) ; } m_iGUISelected = iGUISelection ; m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Write ( wxT ( " GUISelection " ) , iGUISelection ) ; wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ Function ▁ End " ) ) ; return true ; }
int CBOINCGUIApp :: ConfirmExit ( ) { CSkinAdvanced * pSkinAdvanced = wxGetApp ( ) . GetSkinManager ( ) -> GetAdvanced ( ) ; CMainDocument * pDoc = wxGetApp ( ) . GetDocument ( ) ; wxString strConnectedCompter = wxEmptyString ; bool bWasVisible ; int retval = 0 ; wxASSERT ( pDoc ) ; wxASSERT ( pSkinAdvanced ) ; wxASSERT ( wxDynamicCast ( pDoc , CMainDocument ) ) ; wxASSERT ( wxDynamicCast ( pSkinAdvanced , CSkinAdvanced ) ) ; pDoc -> GetConnectedComputerName ( strConnectedCompter ) ; if ( ! pDoc -> IsComput@@ erNameLocal ( strConnectedCompter ) ) { return 1 ; } if ( s_bSkipExitConfirmation ) return 1 ; if ( IsMgrMultiple@@ Instance ( ) ) return 1 ; if ( ! m_iDisplayExitDialog ) { return 1 ; } bWasVisible = IsApplicationVisible ( ) ; ShowApplication ( true ) ; CDlgExitMessage dlg ( NULL ) ; if ( ! pSkinAdvanced -> GetExitMessage ( ) . IsEmpty ( ) ) { dlg . m_DialogExitMessage -> SetLabel ( pSkinAdvanced -> GetExitMessage ( ) ) ; } if ( m_iShutdownCoreClient ) { dlg . m_DialogShutdownCoreClient -> SetValue ( TRUE ) ; } if ( m_iDisplayExitDialog ) { dlg . m_DialogDisplay -> SetValue ( FALSE ) ; } dlg . Fit ( ) ; dlg . Centre ( ) ; if ( wxID_OK == dlg . ShowModal ( ) ) { s_bSkipExitConfirmation = true ; m_iShutdownCoreClient = dlg . m_DialogShutdownCoreClient -> GetValue ( ) ; m_iDisplayExitDialog = ! dlg . m_DialogDisplay -> GetValue ( ) ; retval = true ; } if ( ! bWasVisible ) { ShowApplication ( false ) ; } return retval ; }
int CBOINCGUIApp :: SafeMessageBox ( const wxString & message , const wxString & caption , long style , wxWindow * parent , int x , int y ) { int retval ; m_bSafeMessageBoxDisplayed ++ ; retval = wxMessageBox ( message , caption , style , parent , x , y ) ; m_bSafeMessageBoxDisplayed -- ; return retval ; }
int CBOINCGUIApp :: IsAnotherInstanceRunning ( ) { PROC_MAP pm ; int retval ; char myName [ 256 ] ; int otherInstanceID = 0 ; int myPid ; retval = procinfo_setup ( pm ) ; if ( retval ) return false ; myPid = ( int ) GetCurrentProcessId ( ) ; myPid = getpid ( ) ; myName [ 0 ] = 0 ; PROC_MAP :: iterator i ; for ( i = pm . begin ( ) ; i != pm . end ( ) ; i ++ ) { PROCINFO & pi = i -> second ; if ( pi . id == myPid ) { strncpy ( myName , pi . command , sizeof ( myName ) ) ; break ; } } if ( myName [ 0 ] == 0 ) { return false ; } for ( i = pm . begin ( ) ; i != pm . end ( ) ; i ++ ) { PROCINFO & pi = i -> second ; if ( pi . id == myPid ) continue ; if ( ! strcmp ( pi . command , myName ) ) { otherInstanceID = pi . id ; break ; } } return otherInstanceID ; }
bool CBOINCGUIApp :: IsApplicationVisible ( ) { if ( IsProcess@@ Visible ( & m_psnCurrentProcess ) ) { return true ; } return false ; }
void CBOINCGUIApp :: ShowApplication ( bool bShow ) { if ( bShow ) { SetFrontProcess ( & m_psnCurrentProcess ) ; } else { ShowHide@@ Process ( & m_psnCurrentProcess , false ) ; } }
bool CBOINCGUIApp :: ShowInterface ( ) { return SetActiveGUI ( m_iGUISelected , true ) ; }
bool CBOINCGUIApp :: ShowNoti@@ fications ( ) { bool retval = false ; retval = SetActiveGUI ( m_iGUISelected , true ) ; if ( retval ) { GetFrame ( ) -> FireNotification ( ) ; GetDocument ( ) -> UpdateUnread@@ NoticeState ( ) ; } return retval ; }
bool CBOINCGUIApp :: IsModalDialogDisplayed ( ) { if ( m_bSafeMessageBoxDisplayed ) return true ; if ( wxDynamicCast ( wxWindow :: FindWindowById ( ID_ANYDIALOG ) , wxDialog ) ) { return true ; } if ( m_pDocument ) { if ( m_pDocument -> WaitingForRPC ( ) ) { return true ; } } return false ; }
void CBOINCGUIApp :: DeleteTaskBarIcon ( ) { if ( m_pTaskBarIcon ) { delete m_pTaskBarIcon ; } m_pTaskBarIcon = NULL ; }
void CBOINCGUIApp :: DeleteMacSystemMenu ( ) { if ( m_pMacSystemMenu ) { delete m_pMacSystemMenu ; } m_pMacSystemMenu = NULL ; }
int CBOINCGUIApp :: FilterEvent ( wxEvent & event ) { int theEventType ; wxDialog * theRPCWaitDialog ; wxObject * theObject ; if ( ! m_pDocument ) return - 1 ; theEventType = event . GetEventType ( ) ; if ( m_pDocument -> WaitingForRPC ( ) ) { if ( ( theEventType == wxEVT_COMMAND_@@ MENU_SEL@@ ECTED ) && ( event . GetId ( ) == wxID_OPEN ) ) { return - 1 ; } theRPCWaitDialog = m_pDocument -> GetRPCWaitDialog ( ) ; theObject = event . GetEventObject ( ) ; while ( theObject ) { if ( ! theObject -> IsKind@@ Of ( CLASSINFO ( wxWindow ) ) ) break ; if ( theObject == theRPCWaitDialog ) return - 1 ; theObject = ( ( wxWindow * ) theObject ) -> GetParent ( ) ; } } else { if ( ! m_bFilterEvents ) return - 1 ; } if ( event . IsCommandEvent ( ) ) { return false ; } if ( theEventType == wxEVT_TIMER ) { return false ; } if ( theEventType == wxEVT_TAS@@ KBAR_MOVE ) { return false ; } return - 1 ; }
Items :: Items ( ) { items . reserve ( 20000 ) ; }
Items :: ~ Items ( ) { clear ( ) ; }
void Items :: clear ( ) { items . clear ( ) ; }
bool Items :: reload ( ) { clear ( ) ; loadFromOtb ( " data / items / items . otb " ) ; if ( ! loadFromXml ( ) ) { return false ; } g_moveEvents -> reload ( ) ; g_weapons -> reload ( ) ; g_weapons -> loadDefault@@ s ( ) ; return true ; }
FILELO@@ ADER_ERRORS Items :: loadFromOtb ( const std :: string & file ) { FileLoader f ; if ( ! f . openFile ( file . c_str ( ) , " OTBI " ) ) { return f . getError ( ) ; } uint32_t type ; NODE node = f . getChildNode ( NO_NODE , type ) ; PropStream props ; if ( f . getProps ( node , props ) ) { uint32_t flags ; if ( ! props . read < uint32_t > ( flags ) ) { return ERROR_INVALID_FORMAT ; } uint8_t attr ; if ( ! props . read < uint8_t > ( attr ) ) { return ERROR_INVALID_FORMAT ; } if ( attr == ROOT_ATTR@@ _VERSION ) { uint16_t datalen ; if ( ! props . read < uint16_t > ( datalen ) ) { return ERROR_INVALID_FORMAT ; } if ( datalen != sizeof ( VERSIONINFO ) ) { return ERROR_INVALID_FORMAT ; } VERSIONINFO vi ; if ( ! props . read ( vi ) ) { return ERROR_INVALID_FORMAT ; } Items :: dwMajorVersion = vi . dwMajorVersion ; Items :: dwMinorVersion = vi . dwMinorVersion ; Items :: dwBuildNumber = vi . dwBuildNumber ; } } if ( Items :: dwMajorVersion == 0xFFFFFFFF ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromOtb ] ▁ items . otb ▁ using ▁ generic ▁ client ▁ version . " << std :: endl ; } else if ( Items :: dwMajorVersion > 2 ) { std :: cout << " New ▁ version ▁ detected , ▁ an ▁ older ▁ version ▁ of ▁ items . otb ▁ is ▁ required . " << std :: endl ; return ERROR_INVALID_FORMAT ; } else if ( Items :: dwMinorVersion < CLIENT_VERSION_@@ 740 ) { std :: cout << " A ▁ newer ▁ version ▁ of ▁ items . otb ▁ is ▁ required . " << std :: endl ; return ERROR_INVALID_FORMAT ; } node = f . getChildNode ( node , type ) ; while ( node != NO_NODE ) { PropStream stream ; if ( ! f . getProps ( node , stream ) ) { return f . getError ( ) ; } uint32_t flags ; if ( ! stream . read < uint32_t > ( flags ) ) { return ERROR_INVALID_FORMAT ; } uint16_t serverId = 0 ; uint16_t clientId = 0 ; uint16_t speed = 0 ; uint16_t wareId = 0 ; uint8_t lightLevel = 0 ; uint8_t lightColor = 0 ; uint8_t alwaysOnTopOrder = 0 ; uint8_t attrib ; while ( stream . read < uint8_t > ( attrib ) ) { uint16_t datalen ; if ( ! stream . read < uint16_t > ( datalen ) ) { return ERROR_INVALID_FORMAT ; } switch ( attrib ) { case ITEM_ATTR_SERVERID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( serverId ) ) { return ERROR_INVALID_FORMAT ; } if ( serverId > 20000 && serverId < 20100 ) { serverId -= 20000 ; } break ; } case ITEM_ATTR_CLIENTID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( clientId ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_SPEED : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( speed ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_LIGHT2 : { if ( datalen != sizeof ( lightBlock2 ) ) { return ERROR_INVALID_FORMAT ; } lightBlock2 lb2 ; if ( ! stream . read ( lb2 ) ) { return ERROR_INVALID_FORMAT ; } lightLevel = static_cast < uint8_t > ( lb2 . lightLevel ) ; lightColor = static_cast < uint8_t > ( lb2 . lightColor ) ; break ; } case ITEM_ATTR_TOPORDER : { if ( datalen != sizeof ( uint8_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint8_t > ( alwaysOnTopOrder ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_WAREID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( wareId ) ) { return ERROR_INVALID_FORMAT ; } break ; } default : { if ( ! stream . skip ( datalen ) ) { return ERROR_INVALID_FORMAT ; } break ; } } } reverseItemMap . emplace ( clientId , serverId ) ; if ( serverId >= items . size ( ) ) { items . resize ( serverId + 1 ) ; } ItemType & iType = items [ serverId ] ; iType . group = static_cast < itemgroup_t > ( type ) ; switch ( type ) { case ITEM_GROUP_CONTAINER : iType . type = ITEM_TYPE_CONTAINER ; break ; case ITEM_GROUP_DOOR : iType . type = ITEM_TYPE_DOOR ; break ; case ITEM_GROUP_MAGICFIELD : iType . type = ITEM_TYPE_MAGICFIELD ; break ; case ITEM_GROUP_TELEPORT : iType . type = ITEM_TYPE_TELEPORT ; break ; case ITEM_GROUP_NONE : case ITEM_GROUP_GROUND : case ITEM_GROUP@@ _SPLASH : case ITEM_GROUP_FLUID : case ITEM_GROUP_CHARGES : case ITEM_GROUP_DEPRECATED : break ; default : return ERROR_INVALID_FORMAT ; } iType . blockSolid = hasBitSet ( FLAG_BLOCK_SOLID , flags ) ; iType . blockProjectile = hasBitSet ( FLAG_BLOCK_PROJECTI@@ LE , flags ) ; iType . blockPathFind = hasBitSet ( FLAG_BLOCK_PATHFIN@@ D , flags ) ; iType . hasHeight = hasBitSet ( FLAG_HAS_@@ HEIGHT , flags ) ; iType . useable = hasBitSet ( FLAG_USE@@ ABLE , flags ) ; iType . pickupable = hasBitSet ( FLAG_PIC@@ KUPABLE , flags ) ; iType . moveable = hasBitSet ( FLAG_MOVEABLE , flags ) ; iType . stackable = hasBitSet ( FLAG_STACK@@ ABLE , flags ) ; iType . alwaysOnTop = hasBitSet ( FLAG_ALWAYSON@@ TOP , flags ) ; iType . isVertical = hasBitSet ( FLAG_VERTICAL , flags ) ; iType . isHorizontal = hasBitSet ( FLAG_HORIZON@@ TAL , flags ) ; iType . isHangable = hasBitSet ( FLAG_HANGABLE , flags ) ; iType . allowDistRead = hasBitSet ( FLAG_ALLO@@ WDISTREAD , flags ) ; iType . rotatable = hasBitSet ( FLAG_ROTAT@@ ABLE , flags ) ; iType . canReadText = hasBitSet ( FLAG_READ@@ ABLE , flags ) ; iType . lookThrough = hasBitSet ( FLAG_LOOK@@ THROUGH , flags ) ; iType . forceUse = hasBitSet ( FLAG_FORCE@@ USE , flags ) ; iType . id = serverId ; iType . clientId = clientId ; iType . speed = speed ; iType . lightLevel = lightLevel ; iType . lightColor = lightColor ; iType . wareId = wareId ; iType . alwaysOnTopOrder = alwaysOnTopOrder ; node = f . getNextNode ( node , type ) ; } items . shrink_to_@@ fit ( ) ; return ERROR_NONE ; }
bool Items :: loadFromXml ( ) { pugi :: xml_d@@ ocument doc ; pugi :: xml_parse@@ _result result = doc . load_file ( " data / items / items . xml " ) ; if ( ! result ) { printXML@@ Error ( " Error ▁ - ▁ Items : : loadFromXml " , " data / items / items . xml " , result ) ; return false ; } for ( auto itemNode : doc . child ( " items " ) . children ( ) ) { pugi :: xml_attribute idAttribute = itemNode . attribute ( " id " ) ; if ( idAttribute ) { parseItemNode ( itemNode , pugi :: cast < uint16_t > ( idAttribute . value ( ) ) ) ; continue ; } pugi :: xml_attribute fromIdAttribute = itemNode . attribute ( " fromid " ) ; if ( ! fromIdAttribute ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromXml ] ▁ No ▁ item ▁ id ▁ found " << std :: endl ; continue ; } pugi :: xml_attribute toIdAttribute = itemNode . attribute ( " toid " ) ; if ( ! toIdAttribute ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromXml ] ▁ fromid ▁ ( " << fromIdAttribute . value ( ) << " ) ▁ without ▁ toid " << std :: endl ; continue ; } uint16_t id = pugi :: cast < uint16_t > ( fromIdAttribute . value ( ) ) ; uint16_t toId = pugi :: cast < uint16_t > ( toIdAttribute . value ( ) ) ; while ( id <= toId ) { parseItemNode ( itemNode , id ++ ) ; } } return true ; }
void Items :: parseItemNode ( const pugi :: xml_node & itemNode , uint16_t id ) { if ( id > 20000 && id < 20100 ) { id -= 20000 ; if ( id >= items . size ( ) ) { items . resize ( id + 1 ) ; } ItemType & iType = items [ id ] ; iType . id = id ; } ItemType & it = getItemType ( id ) ; if ( it . id == 0 ) { return ; } it . name = itemNode . attribute ( " name " ) . as_string ( ) ; pugi :: xml_attribute articleAttribute = itemNode . attribute ( " article " ) ; if ( articleAttribute ) { it . article = articleAttribute . as_string ( ) ; } pugi :: xml_attribute pluralAttribute = itemNode . attribute ( " plural " ) ; if ( pluralAttribute ) { it . pluralName = pluralAttribute . as_string ( ) ; } for ( auto attributeNode : itemNode . children ( ) ) { pugi :: xml_attribute keyAttribute = attributeNode . attribute ( " key " ) ; if ( ! keyAttribute ) { continue ; } pugi :: xml_attribute valueAttribute = attributeNode . attribute ( " value " ) ; if ( ! valueAttribute ) { continue ; } std :: string tmpStrValue = asLowerCaseString ( keyAttribute . as_string ( ) ) ; if ( tmpStrValue == " type " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " key " ) { it . type = ITEM_TYPE_KEY ; } else if ( tmpStrValue == " magicfield " ) { it . type = ITEM_TYPE_MAGICFIELD ; } else if ( tmpStrValue == " container " ) { it . group = ITEM_GROUP_CONTAINER ; it . type = ITEM_TYPE_CONTAINER ; } else if ( tmpStrValue == " depot " ) { it . type = ITEM_TYPE_DEPO@@ T ; } else if ( tmpStrValue == " mailbox " ) { it . type = ITEM_TYPE_MAIL@@ BOX ; } else if ( tmpStrValue == " trashholder " ) { it . type = ITEM_TYPE_TRAS@@ HHOLDER ; } else if ( tmpStrValue == " teleport " ) { it . type = ITEM_TYPE_TELEPORT ; } else if ( tmpStrValue == " door " ) { it . type = ITEM_TYPE_DOOR ; } else if ( tmpStrValue == " bed " ) { it . type = ITEM_TYPE_BED ; } else if ( tmpStrValue == " rune " ) { it . type = ITEM_TYPE_RUN@@ E ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ type : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " description " ) { it . description = valueAttribute . as_string ( ) ; } else if ( tmpStrValue == " runespellname " ) { it . runeSpellName = valueAttribute . as_string ( ) ; } else if ( tmpStrValue == " weight " ) { it . weight = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showcount " ) { it . showCount = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " armor " ) { it . armor = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " defense " ) { it . defense = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " extradef " ) { it . extraDefense = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " attack " ) { it . attack = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " rotateto " ) { it . rotateTo = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " moveable " || tmpStrValue == " movable " ) { it . moveable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " blockproj@@ ectile " ) { it . blockProjectile = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " allowpickupable " || tmpStrValue == " pickupable " ) { it . allowPickupable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " floorchange " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " down " ) { it . floorChange = TILESTATE_FLOORCHANGE_DOWN ; } else if ( tmpStrValue == " north " ) { it . floorChange = TILESTATE_FLOORCHANGE_NORTH ; } else if ( tmpStrValue == " south " ) { it . floorChange = TILESTATE_FLOORCHANGE_SOUTH ; } else if ( tmpStrValue == " southalt " ) { it . floorChange = TILESTATE_FLOORCHANGE_SOUTH@@ _ALT ; } else if ( tmpStrValue == " west " ) { it . floorChange = TILESTATE_FLOORCHANGE_WEST ; } else if ( tmpStrValue == " east " ) { it . floorChange = TILESTATE_FLOORCHANGE_EAST ; } else if ( tmpStrValue == " eastalt " ) { it . floorChange = TILESTATE_FLOORCHANGE_EAST_ALT ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ floorChange : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " corpsetype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " venom " ) { it . corpseType = RACE_VENOM ; } else if ( tmpStrValue == " blood " ) { it . corpseType = RACE_BLOOD ; } else if ( tmpStrValue == " undead " ) { it . corpseType = RACE_UNDEAD ; } else if ( tmpStrValue == " fire " ) { it . corpseType = RACE_FIR@@ E ; } else if ( tmpStrValue == " energy " ) { it . corpseType = RACE_ENERGY ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ corpseType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " containersize " ) { it . maxItems = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fluidsource " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " water " ) { it . fluidSource = FLUID_WATER ; } else if ( tmpStrValue == " blood " ) { it . fluidSource = FLUID_BLOOD ; } else if ( tmpStrValue == " beer " ) { it . fluidSource = FLUID_BE@@ ER ; } else if ( tmpStrValue == " slime " ) { it . fluidSource = FLUID_SLIME ; } else if ( tmpStrValue == " lemonade " ) { it . fluidSource = FLUID_LEM@@ ONADE ; } else if ( tmpStrValue == " milk " ) { it . fluidSource = FLUID_MILK ; } else if ( tmpStrValue == " mana " ) { it . fluidSource = FLUID_MANA ; } else if ( tmpStrValue == " life " ) { it . fluidSource = FLUID_LIF@@ E ; } else if ( tmpStrValue == " oil " ) { it . fluidSource = FLUID_OIL ; } else if ( tmpStrValue == " urine " ) { it . fluidSource = FLUID_URINE ; } else if ( tmpStrValue == " coconut " ) { it . fluidSource = FLUID_CO@@ CONUT@@ MILK ; } else if ( tmpStrValue == " wine " ) { it . fluidSource = FLUID_WINE ; } else if ( tmpStrValue == " mud " ) { it . fluidSource = FLUID_MUD ; } else if ( tmpStrValue == " fruit@@ juice " ) { it . fluidSource = FLUID_F@@ RUITJU@@ ICE ; } else if ( tmpStrValue == " lava " ) { it . fluidSource = FLUID_LAV@@ A ; } else if ( tmpStrValue == " rum " ) { it . fluidSource = FLUID_RUM ; } else if ( tmpStrValue == " swamp " ) { it . fluidSource = FLUID_SWAM@@ P ; } else if ( tmpStrValue == " tea " ) { it . fluidSource = FLUID_TEA ; } else if ( tmpStrValue == " mead " ) { it . fluidSource = FLUID_MEAD ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ fluidSource : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " readable " ) { it . canReadText = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " writeable " ) { it . canWriteText = valueAttribute . as_bool ( ) ; it . canReadText = it . canWriteText ; } else if ( tmpStrValue == " maxtext@@ len " ) { it . maxTextLen = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " writeonce@@ itemid " ) { it . writeOnceItemId = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " weapontype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " sword " ) { it . weaponType = WEAPON_SWORD ; } else if ( tmpStrValue == " club " ) { it . weaponType = WEAPON_CLUB ; } else if ( tmpStrValue == " axe " ) { it . weaponType = WEAPON_AXE ; } else if ( tmpStrValue == " shield " ) { it . weaponType = WEAPON_SHIELD ; } else if ( tmpStrValue == " distance " ) { it . weaponType = WEAPON_DISTANCE ; } else if ( tmpStrValue == " wand " ) { it . weaponType = WEAPON_WAND ; } else if ( tmpStrValue == " ammunition " ) { it . weaponType = WEAPON_AMMO ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ weaponType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " slottype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " head " ) { it . slotPosition |= SLOTP_HEAD ; } else if ( tmpStrValue == " body " ) { it . slotPosition |= SLOTP_ARMOR ; } else if ( tmpStrValue == " legs " ) { it . slotPosition |= SLOTP_LEGS ; } else if ( tmpStrValue == " feet " ) { it . slotPosition |= SLOTP_FEE@@ T ; } else if ( tmpStrValue == " backpack " ) { it . slotPosition |= SLOTP_BACK@@ PACK ; } else if ( tmpStrValue == " two - handed " ) { it . slotPosition |= SLOTP_TWO_@@ HAND ; } else if ( tmpStrValue == " right - hand " ) { it . slotPosition &= ~ SLOTP_LEFT ; } else if ( tmpStrValue == " left - hand " ) { it . slotPosition &= ~ SLOTP_RIGHT ; } else if ( tmpStrValue == " necklace " ) { it . slotPosition |= SLOTP_NEC@@ KLACE ; } else if ( tmpStrValue == " ring " ) { it . slotPosition |= SLOTP_RING ; } else if ( tmpStrValue == " ammo " ) { it . slotPosition |= SLOTP_AMMO ; } else if ( tmpStrValue == " hand " ) { it . slotPosition |= SLOTP_HAND ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ slotType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " ammotype " ) { it . ammoType = getAmmoType ( valueAttribute . as_string ( ) ) ; if ( it . ammoType == AMMO_NONE ) { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ ammoType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " shoottype " ) { ShootType_t shoot = getShootType ( valueAttribute . as_string ( ) ) ; if ( shoot != CONST_ANI_NONE ) { it . shootType = shoot ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ shootType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " effect " ) { MagicEffectClasses effect = getMagicEffect ( valueAttribute . as_string ( ) ) ; if ( effect != CONST_ME_NONE ) { it . magicEffect = effect ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ effect : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " range " ) { it . shootRange = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " stopduration " ) { it . stopTime = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " decayto " ) { it . decayTo = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " transformequipto " ) { it . transformEquipTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " transformdeequipto " ) { it . transformDeEquipTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " duration " ) { it . decayTime = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showduration " ) { it . showDuration = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " charges " ) { it . charges = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showcharges " ) { it . showCharges = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " showattributes " ) { it . showAttributes = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " hitchance " ) { it . hitChance = std :: min < int8_t > ( 100 , std :: max < int8_t > ( - 100 , pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ) ) ; } else if ( tmpStrValue == " maxhitchance " ) { it . maxHitChance = std :: min < uint32_t > ( 100 , pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " invisible " ) { it . getAbilities ( ) . invisible = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " speed " ) { it . getAbilities ( ) . speed = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " healthgain " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . healthGain = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " healthticks " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . healthTicks = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " managain " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . manaGain = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " manatick@@ s " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . manaTicks = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " manashield " ) { it . getAbilities ( ) . manaShield = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " skillsword " ) { it . getAbilities ( ) . skills [ SKILL_SWORD ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillaxe " ) { it . getAbilities ( ) . skills [ SKILL_AX@@ E ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillclub " ) { it . getAbilities ( ) . skills [ SKILL_CLUB ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skilldist " ) { it . getAbilities ( ) . skills [ SKILL_DISTANCE ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillfish " ) { it . getAbilities ( ) . skills [ SKILL_FISHING ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillshield " ) { it . getAbilities ( ) . skills [ SKILL_SHIELD ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillfist " ) { it . getAbilities ( ) . skills [ SKILL_FIST ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxhitpoints " ) { it . getAbilities ( ) . stats [ STAT_MAXHITPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxhitpointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAXHITPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxmanapoints " ) { it . getAbilities ( ) . stats [ STAT_MAXMANAPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxmanapointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAXMANAPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " magicpoints " || tmpStrValue == " magiclevel@@ points " ) { it . getAbilities ( ) . stats [ STAT_MAGICPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " magicpointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAGICPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercentenergy " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercentfire " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercentpoison " || tmpStrValue == " fieldabsor@@ percentearth " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentall " || tmpStrValue == " absorbpercentallelements " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; for ( size_t i = 0 ; i < COMBAT_COUNT ; ++ i ) { abilities . absorbPercent [ i ] += value ; } } else if ( tmpStrValue == " absorbpercente@@ lements " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += value ; } else if ( tmpStrValue == " absorbpercentmagic " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += value ; } else if ( tmpStrValue == " absorbpercentenergy " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentfire " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentpoison " || tmpStrValue == " absorbpercentearth " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentlifed@@ rain " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_LIF@@ EDRAIN ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentmanadrain " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_MAN@@ ADRAIN ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentphysical " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_PHYSICALDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercenthe@@ aling " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_HEAL@@ ING ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentundefined " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_UNDEFIN@@ EDDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " suppressdrunk " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_DRUNK ; } } else if ( tmpStrValue == " suppressenergy " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_ENERGY ; } } else if ( tmpStrValue == " suppressfire " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_FIRE ; } } else if ( tmpStrValue == " suppresspoison " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_POISON ; } } else if ( tmpStrValue == " suppressphysical " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_BLEEDING ; } } else if ( tmpStrValue == " field " ) { it . group = ITEM_GROUP_MAGICFIELD ; it . type = ITEM_TYPE_MAGICFIELD ; CombatType_t combatType = COMBAT_NONE ; ConditionDamage * conditionDamage = nullptr ; tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " fire " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_FIRE ) ; combatType = COMBAT_FIREDAMAGE ; } else if ( tmpStrValue == " energy " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_ENERGY ) ; combatType = COMBAT_ENERGYDAMAGE ; } else if ( tmpStrValue == " poison " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_POISON ) ; combatType = COMBAT_EARTHDAMAGE ; } else if ( tmpStrValue == " physical " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_BLEEDING ) ; combatType = COMBAT_PHYSICALDAMAGE ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ field ▁ value : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } if ( combatType != COMBAT_NONE ) { it . combatType = combatType ; it . conditionDamage . reset ( conditionDamage ) ; uint32_t ticks = 0 ; int32_t damage = 0 ; int32_t start = 0 ; int32_t count = 1 ; for ( auto subAttributeNode : attributeNode . children ( ) ) { pugi :: xml_attribute subKeyAttribute = subAttributeNode . attribute ( " key " ) ; if ( ! subKeyAttribute ) { continue ; } pugi :: xml_attribute subValueAttribute = subAttributeNode . attribute ( " value " ) ; if ( ! subValueAttribute ) { continue ; } tmpStrValue = asLowerCaseString ( subKeyAttribute . as_string ( ) ) ; if ( tmpStrValue == " ticks " ) { ticks = pugi :: cast < uint32_t > ( subValueAttribute . value ( ) ) ; } else if ( tmpStrValue == " count " ) { count = std :: max < int32_t > ( 1 , pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " start " ) { start = std :: max < int32_t > ( 0 , pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " damage " ) { damage = - pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ; if ( start > 0 ) { std :: list < int32_t > damageList ; ConditionDamage :: generateDamage@@ List ( damage , start , damageList ) ; for ( int32_t damageValue : damageList ) { conditionDamage -> addDamage ( 1 , ticks , - damageValue ) ; } start = 0 ; } else { conditionDamage -> addDamage ( count , ticks , damage ) ; } } } conditionDamage -> setParam ( CONDITION_PARAM_FIELD , 1 ) ; if ( conditionDamage -> getTotalDamage ( ) > 0 ) { conditionDamage -> setParam ( CONDITION_PARAM_FORCE@@ UPDATE , 1 ) ; } } } else if ( tmpStrValue == " replaceable " ) { it . replaceable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " partnerdirection " ) { it . bedPartnerDir = getDirection ( valueAttribute . as_string ( ) ) ; } else if ( tmpStrValue == " leveldoor " ) { it . levelDoor = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " sleeper " ) { uint16_t value = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; it . transformToOnUse = value ; ItemType & other = getItemType ( value ) ; if ( other . transformToFree == 0 ) { other . transformToFree = it . id ; } if ( it . transformToOnUse == 0 ) { it . transformToOnUse = value ; } } else if ( tmpStrValue == " transformto " ) { it . transformToFree = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " destroyto " ) { it . destroyTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " elementearth " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_EARTHDAMAGE ; } else if ( tmpStrValue == " elementfire " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_FIREDAMAGE ; } else if ( tmpStrValue == " elementenergy " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_ENERGYDAMAGE ; } else if ( tmpStrValue == " walkstack " ) { it . walkStack = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " blocking " ) { it . blockSolid = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " allowdist@@ read " ) { it . allowDistRead = booleanString ( valueAttribute . as_string ( ) ) ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ key ▁ value : ▁ " << keyAttribute . as_string ( ) << std :: endl ; } } if ( ( it . transformToFree != 0 || it . transformToOnUse != 0 || it . transformToOnUse != 0 ) && it . type != ITEM_TYPE_BED ) { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Item ▁ " << it . id << " ▁ is ▁ not ▁ set ▁ as ▁ a ▁ bed - type " << std :: endl ; } }
ItemType & Items :: getItemType ( size_t id ) { if ( id < items . size ( ) ) { return items [ id ] ; } return items . front ( ) ; }
uint16_t Items :: getItemIdByName ( const std :: string & name ) { if ( name . empty ( ) ) { return 0 ; } const char * itemName = name . c_str ( ) ; for ( size_t i = 100 , size = items . size ( ) ; i < size ; ++ i ) { if ( strcasecmp ( itemName , items [ i ] . name . c_str ( ) ) == 0 ) { return i ; } } return 0 ; }
LIBSEDML_CPP_NAMESPACE_BEGIN SedDocument :: SedDocument ( unsigned int level , unsigned int version ) : SedBase ( level , version ) , mLevel ( SEDML_INT_MAX ) , mIsSetLevel ( false ) , mVersion ( SEDML_INT_MAX ) , mIsSetVersion ( false ) , mDataDescriptions ( level , version ) , mSimulations ( level , version ) , mModels ( level , version ) , mTasks ( level , version ) , mDataGenerators ( level , version ) , mOutputs ( level , version ) { mLevel = level ; mIsSetLevel = true ; mVersion = version ; mIsSetVersion = true ; setSedDocument ( this ) ; setSedNamespacesAndOwn ( new SedNamespaces ( level , version ) ) ; connectToChild ( ) ; }
SedDocument :: SedDocument ( SedNamespaces * sedns ) : SedBase ( sedns ) , mLevel ( SEDML_INT_MAX ) , mIsSetLevel ( false ) , mVersion ( SEDML_INT_MAX ) , mIsSetVersion ( false ) , mDataDescriptions ( sedns ) , mSimulations ( sedns ) , mModels ( sedns ) , mTasks ( sedns ) , mDataGenerators ( sedns ) , mOutputs ( sedns ) { mLevel = sedns -> getLevel ( ) ; mIsSetLevel = true ; mVersion = sedns -> getVersion ( ) ; mIsSetVersion = true ; setSedDocument ( this ) ; setElementNamespace ( sedns -> getURI ( ) ) ; connectToChild ( ) ; }
SedDocument :: SedDocument ( const SedDocument & orig ) : SedBase ( orig ) { setSedDocument ( this ) ; mLevel = orig . mLevel ; mIsSetLevel = orig . mIsSetLevel ; mVersion = orig . mVersion ; mIsSetVersion = orig . mIsSetVersion ; mDataDescriptions = orig . mDataDescriptions ; mSimulations = orig . mSimulations ; mModels = orig . mModels ; mTasks = orig . mTasks ; mDataGenerators = orig . mDataGenerators ; mOutputs = orig . mOutputs ; connectToChild ( ) ; }
int SedDocument :: setLevel ( int level ) { mLevel = level ; mIsSetLevel = true ; return LIBSEDML_OPERATION_SUCCESS ; }
int SedDocument :: setVersion ( int version ) { mVersion = version ; mIsSetVersion = true ; return LIBSEDML_OPERATION_SUCCESS ; }
int SedDocument :: unsetLevel ( ) { mLevel = SEDML_INT_MAX ; mIsSetLevel = false ; if ( isSetLevel ( ) == false ) { return LIBSEDML_OPERATION_SUCCESS ; } else { return LIBSEDML_OPERATION_FAILED ; } }
int SedDocument :: unsetVersion ( ) { mVersion = SEDML_INT_MAX ; mIsSetVersion = false ; if ( isSetVersion ( ) == false ) { return LIBSEDML_OPERATION_SUCCESS ; } else { return LIBSEDML_OPERATION_FAILED ; } }
SedDataDescription * SedDocument :: removeDataDescription ( unsigned int n ) { return mDataDescriptions . remove ( n ) ; }
SedDataDescription * SedDocument :: removeDataDescription ( const std :: string & sid ) { return mDataDescriptions . remove ( sid ) ; }
SedDataDescription * SedDocument :: getDataDescription ( unsigned int n ) { return mDataDescriptions . get ( n ) ; }
SedDataDescription * SedDocument :: getDataDescription ( const std :: string & sid ) { return mDataDescriptions . get ( sid ) ; }
int SedDocument :: addDataDescription ( const SedDataDescription * sdd ) { if ( sdd == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mDataDescriptions . append ( sdd ) ; return LIBSEDML_OPERATION_SUCCESS ; }
SedDataDescription * SedDocument :: createDataDescription ( ) { SedDataDescription * temp = new SedDataDescription ( ) ; if ( temp != NULL ) mDataDescriptions . appendAndOwn ( temp ) ; return temp ; }
SedSimulation * SedDocument :: removeSimulation ( unsigned int n ) { return mSimulations . remove ( n ) ; }
SedSimulation * SedDocument :: removeSimulation ( const std :: string & sid ) { return mSimulations . remove ( sid ) ; }
SedSimulation * SedDocument :: getSimulation ( unsigned int n ) { return mSimulations . get ( n ) ; }
SedSimulation * SedDocument :: getSimulation ( const std :: string & sid ) { return mSimulations . get ( sid ) ; }
int SedDocument :: addSimulation ( const SedSimulation * ss ) { if ( ss == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mSimulations . append ( ss ) ; return LIBSEDML_OPERATION_SUCCESS ; }
SedUniformTimeCourse * SedDocument :: createUniformTimeCourse ( ) { SedUniformTimeCourse * temp = new SedUniformTimeCourse ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; }
SedOneStep * SedDocument :: createOneStep ( ) { SedOneStep * temp = new SedOneStep ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; }
SedSteadyState * SedDocument :: createSteadyState ( ) { SedSteadyState * temp = new SedSteadyState ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; }
SedModel * SedDocument :: removeModel ( unsigned int n ) { return mModels . remove ( n ) ; }
SedModel * SedDocument :: removeModel ( const std :: string & sid ) { return mModels . remove ( sid ) ; }
SedModel * SedDocument :: getModel ( unsigned int n ) { return mModels . get ( n ) ; }
SedModel * SedDocument :: getModel ( const std :: string & sid ) { return mModels . get ( sid ) ; }
int SedDocument :: addModel ( const SedModel * sm ) { if ( sm == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mModels . append ( sm ) ; return LIBSEDML_OPERATION_SUCCESS ; }
SedModel * SedDocument :: createModel ( ) { SedModel * temp = new SedModel ( ) ; if ( temp != NULL ) mModels . appendAndOwn ( temp ) ; return temp ; }
SedTask * SedDocument :: removeTask ( unsigned int n ) { return mTasks . remove ( n ) ; }
SedTask * SedDocument :: removeTask ( const std :: string & sid ) { return mTasks . remove ( sid ) ; }
SedTask * SedDocument :: getTask ( unsigned int n ) { return mTasks . get ( n ) ; }
SedTask * SedDocument :: getTask ( const std :: string & sid ) { return mTasks . get ( sid ) ; }
int SedDocument :: addTask ( const SedTask * st ) { if ( st == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mTasks . append ( st ) ; return LIBSEDML_OPERATION_SUCCESS ; }
SedTask * SedDocument :: createTask ( ) { SedTask * temp = new SedTask ( ) ; if ( temp != NULL ) mTasks . appendAndOwn ( temp ) ; return temp ; }
SedRepeatedTask * SedDocument :: createRepeatedTask ( ) { SedRepeatedTask * temp = new SedRepeatedTask ( ) ; if ( temp != NULL ) mTasks . appendAndOwn ( temp ) ; return temp ; }
SedDataGenerator * SedDocument :: removeDataGenerator ( unsigned int n ) { return mDataGenerators . remove ( n ) ; }
SedDataGenerator * SedDocument :: removeDataGenerator ( const std :: string & sid ) { return mDataGenerators . remove ( sid ) ; }
SedDataGenerator * SedDocument :: getDataGenerator ( unsigned int n ) { return mDataGenerators . get ( n ) ; }
SedDataGenerator * SedDocument :: getDataGenerator ( const std :: string & sid ) { return mDataGenerators . get ( sid ) ; }
int SedDocument :: addDataGenerator ( const SedDataGenerator * sdg ) { if ( sdg == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mDataGenerators . append ( sdg ) ; return LIBSEDML_OPERATION_SUCCESS ; }
SedDataGenerator * SedDocument :: createDataGenerator ( ) { SedDataGenerator * temp = new SedDataGenerator ( ) ; if ( temp != NULL ) mDataGenerators . appendAndOwn ( temp ) ; return temp ; }
SedOutput * SedDocument :: removeOutput ( unsigned int n ) { return mOutputs . remove ( n ) ; }
SedOutput * SedDocument :: removeOutput ( const std :: string & sid ) { return mOutputs . remove ( sid ) ; }
SedOutput * SedDocument :: getOutput ( unsigned int n ) { return mOutputs . get ( n ) ; }
SedOutput * SedDocument :: getOutput ( const std :: string & sid ) { return mOutputs . get ( sid ) ; }
int SedDocument :: addOutput ( const SedOutput * so ) { if ( so == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mOutputs . append ( so ) ; return LIBSEDML_OPERATION_SUCCESS ; }
SedReport * SedDocument :: createReport ( ) { SedReport * temp = new SedReport ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; }
SedPlot2D * SedDocument :: createPlot2D ( ) { SedPlot2D * temp = new SedPlot2D ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; }
SedPlot3D * SedDocument :: createPlot3D ( ) { SedPlot3D * temp = new SedPlot3D ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; }
SedBase * SedDocument :: createObject ( XMLInputStream & stream ) { SedBase * object = NULL ; const string & name = stream . peek ( ) . getName ( ) ; if ( name == " listOfDataDescriptions " ) { object = & mDataDescriptions ; } if ( name == " listOfSimulations " ) { object = & mSimulations ; } if ( name == " listOfModels " ) { object = & mModels ; } if ( name == " listOfTasks " ) { object = & mTasks ; } if ( name == " listOfDataGenerators " ) { object = & mDataGenerators ; } if ( name == " listOfOutputs " ) { object = & mOutputs ; } connectToChild ( ) ; return object ; }
void SedDocument :: connectToChild ( ) { SedBase :: connectToChild ( ) ; mDataDescriptions . connectToParent ( this ) ; mSimulations . connectToParent ( this ) ; mModels . connectToParent ( this ) ; mTasks . connectToParent ( this ) ; mDataGenerators . connectToParent ( this ) ; mOutputs . connectToParent ( this ) ; }
void SedDocument :: setSedDocument ( SedDocument * d ) { SedBase :: setSedDocument ( d ) ; mDataDescriptions . setSedDocument ( d ) ; mSimulations . setSedDocument ( d ) ; mModels . setSedDocument ( d ) ; mTasks . setSedDocument ( d ) ; mDataGenerators . setSedDocument ( d ) ; mOutputs . setSedDocument ( d ) ; }
void SedDocument :: addExpectedAttributes ( ExpectedAttributes & attributes ) { SedBase :: addExpectedAttributes ( attributes ) ; attributes . add ( " level " ) ; attributes . add ( " version " ) ; }
void SedDocument :: readAttributes ( const XMLAttributes & attributes , const ExpectedAttributes & expectedAttributes ) { SedBase :: readAttributes ( attributes , expectedAttributes ) ; bool assigned = false ; mIsSetLevel = attributes . readInto ( " level " , mLevel , getErrorLog ( ) , true ) ; mIsSetVersion = attributes . readInto ( " version " , mVersion , getErrorLog ( ) , true ) ; }
SedErrorLog * SedDocument :: getErrorLog ( ) { return & mErrorLog ; }
CFormDialog :: CFormDialog ( ) : CBaseDialog ( IDR_MAINF@@ RAME ) { View = NULL ; WidgetIndexCount = 0 ; WidgetFocused = 0xffffffff ; }
CFormDialog :: ~ CFormDialog ( ) { clear ( ) ; }
void CFormDialog :: clear ( ) { unRegisterLastControl ( ) ; for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) delete Widgets [ i ] ; Widgets . clear ( ) ; WidgetFocused = 0xffffffff ; WidgetIndexCount = 0 ; }
void CFormDialog :: DoDataExchange ( CDataExchange * pDX ) { CDialog :: DoDataExchange ( pDX ) ; }
BOOL CFormDialog :: OnInitDialog ( ) { CBaseDialog :: OnInitDialog ( ) ; SetDefID ( 0xffffffff ) ; UpdateData ( FALSE ) ; return TRUE ; }
void CFormDialog :: OnOK ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateData ( ) ; if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onOk ( ) ; } } }
void CFormDialog :: OnCancel ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateData ( ) ; if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onCancel ( ) ; return ; } } CBaseDialog :: OnCancel ( ) ; }
CWnd * CFormDialog :: addTypeWidget ( const NLGEORGES :: CType & type , uint elmIndex , const char * title , const char * atomName , const char * typeFilename , RECT & currentPos , CForm & form , IFormWidget :: TTypeSrc typeWidget , const char * filenameExt , uint slot ) { switch ( type . UIType ) { case CType :: FileBrowser : case CType :: Edit : case CType :: EditSpin : { CFormMemCombo * memCombo = new CFormMemCombo ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; string tfn = typeFilename ; string key = GEORGES_EDIT_BASE_REG_KEY " \\ " + strlwr ( typeFilename ) + " ▁ MemCombo " ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title , key . c_str ( ) , type . UIType == CType :: EditSpin , type . UIType == CType :: FileBrowser , filenameExt ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Combo ; } break ; case CType :: NonEditableCombo : { CFormCombo * memCombo = new CFormCombo ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Combo ; } break ; case CType :: BigEdit : { CFormBigEdit * memCombo = new CFormBigEdit ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Edit ; } break ; case CType :: ColorEdit : { CColorEdit * memCombo = new CColorEdit ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Color ; } break ; } return NULL ; }
void CFormDialog :: getVirtualDfnFromDocument ( const NLGEORGES :: CFormDfn * _dfn , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; CFormMemCombo * memCombo = new CFormMemCombo ( this , 0xffffffff , structName , IFormWidget :: TypeVirtualDfn , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Dfn : " , GEORGES_EDIT_BASE_REG_KEY " \\Vir@@ tual ▁ Dfn ▁ MemCombo " , false , true , " * . dfn " ) ; memCombo -> getFromDocument ( * doc -> getFormPtr ( ) ) ; if ( _dfn ) { std :: vector < const CFormDfn * > arrayDfn ; arrayDfn . reserve ( _dfn -> countParentDfn ( ) ) ; _dfn -> getParentDfn ( arrayDfn ) ; uint elmIndex = 0 ; for ( uint dfnIndex = 0 ; dfnIndex < arrayDfn . size ( ) ; dfnIndex ++ ) { nlassert ( arrayDfn [ dfnIndex ] ) ; const CFormDfn & dfn = * arrayDfn [ dfnIndex ] ; for ( uint i = 0 ; i < dfn . getNumEntry ( ) ; i ++ ) { const CFormDfn :: CEntry & entry = dfn . getEntry ( i ) ; if ( entry . getType ( ) == UFormDfn :: EntryType && ! entry . getArrayFlag ( ) ) { string title = entry . getName ( ) + " : " ; string atomName = string ( structName ) + " . " + entry . getName ( ) ; addTypeWidget ( * entry . getTypePtr ( ) , elmIndex , title . c_str ( ) , atomName . c_str ( ) , entry . getFilename ( ) . c_str ( ) , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeForm , entry . getFilenameExt ( ) . c_str ( ) , slot ) ; } elmIndex ++ ; } } } registerLastControl ( ) ; } } }
void CFormDialog :: getDfnFromDocument ( const NLGEORGES :: CFormDfn & _dfn , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; std :: vector < const CFormDfn * > arrayDfn ; arrayDfn . reserve ( _dfn . countParentDfn ( ) ) ; _dfn . getParentDfn ( arrayDfn ) ; if ( strcmp ( structName , " " ) == 0 ) { CListWidget * listWidget = new CListWidget ( this , 0xffffffff , " " , IFormWidget :: TypeFormParent , slot ) ; Widgets . push_back ( listWidget ) ; listWidget -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Parent ▁ Form : " , GEORGES_EDIT_BASE_REG_KEY " \\Parent ▁ Form ▁ MemCombo " , 1 ) ; listWidget -> addColumn ( " Parent ▁ filename " ) ; listWidget -> getFromDocument ( * doc -> getFormPtr ( ) ) ; } CWnd * pWnd = NULL ; CWnd * pWndIcon = NULL ; CWnd * pWndIconColor = NULL ; CWnd * pWndIconBack = NULL ; CWnd * pWndIconBackColor = NULL ; CWnd * pWndIconOver = NULL ; CWnd * pWndIconOverColor = NULL ; CWnd * pWndIconOver2 = NULL ; CWnd * pWndIconOver2Color = NULL ; uint elmIndex = 0 ; for ( uint dfnIndex = 0 ; dfnIndex < arrayDfn . size ( ) ; dfnIndex ++ ) { nlassert ( arrayDfn [ dfnIndex ] ) ; const CFormDfn & dfn = * arrayDfn [ dfnIndex ] ; for ( uint i = 0 ; i < dfn . getNumEntry ( ) ; i ++ ) { const CFormDfn :: CEntry & entry = dfn . getEntry ( i ) ; if ( entry . getType ( ) == UFormDfn :: EntryType && ! entry . getArrayFlag ( ) ) { string title = entry . getName ( ) + " : " ; string atomName = string ( structName ) + " . " + entry . getName ( ) ; pWnd = addTypeWidget ( * entry . getTypePtr ( ) , elmIndex , title . c_str ( ) , atomName . c_str ( ) , entry . getFilename ( ) . c_str ( ) , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeForm , entry . getFilenameExt ( ) . c_str ( ) , slot ) ; if ( entry . getName ( ) == " Icon " || entry . getName ( ) == " icon " ) pWndIcon = pWnd ; else if ( entry . getName ( ) == " IconColor " ) pWndIconColor = pWnd ; else if ( entry . getName ( ) == " IconBack " || entry . getName ( ) == " icon ▁ background " ) pWndIconBack = pWnd ; else if ( entry . getName ( ) == " IconBackColor " ) pWndIconBackColor = pWnd ; else if ( entry . getName ( ) == " IconOver " || entry . getName ( ) == " icon ▁ overlay " ) pWndIconOver = pWnd ; else if ( entry . getName ( ) == " IconOverColor " ) pWndIconOverColor = pWnd ; else if ( entry . getName ( ) == " IconOver2" || entry . getName ( ) == " icon ▁ overlay2" ) pWndIconOver2 = pWnd ; else if ( entry . getName ( ) == " IconOver2Color " ) pWndIconOver2Color = pWnd ; } elmIndex ++ ; } } if ( ( string ( structName ) == " . Client " ) || ( string ( structName ) == " . 3d " ) ) { string title = " Icon ▁ bitmap : " ; CIconWidget * w = new CIconWidget ( this , elmIndex , " " , IFormWidget :: TypeFormParent , slot ) ; Widgets . push_back ( w ) ; w -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title . c_str ( ) ) ; w -> Icon . pWndIcon = pWndIcon ; w -> Icon . pWndIconColor = pWndIconColor ; w -> Icon . pWndIconBack = pWndIconBack ; w -> Icon . pWndIconBackColor = pWndIconBackColor ; w -> Icon . pWndIconOver = pWndIconOver ; w -> Icon . pWndIconOverColor = pWndIconOverColor ; w -> Icon . pWndIconOver2 = pWndIconOver2 ; w -> Icon . pWndIconOver2Color = pWndIconOver2Color ; } registerLastControl ( ) ; } } }
void CFormDialog :: getArrayFromDocument ( const char * structName , uint structId , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; CFormMemCombo * memCombo = new CFormMemCombo ( this , structId , structName , IFormWidget :: TypeArray , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Array ▁ size : " , GEORGES_EDIT_BASE_REG_KEY " \\Array ▁ Size ▁ MemCombo " , true , false , NULL ) ; memCombo -> getFromDocument ( * doc -> getFormPtr ( ) ) ; registerLastControl ( ) ; } } }
void CFormDialog :: getTypeFromDocument ( const NLGEORGES :: CType & _type , const char * name , const char * typeFilename , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; addTypeWidget ( _type , 0xffffffff , name , structName , typeFilename , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeType , NULL , slot ) ; registerLastControl ( ) ; } } }
void CFormDialog :: updateLabels ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateLabel ( ) ; } }
void CFormDialog :: updateValues ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateLabel ( ) ; Widgets [ i ] -> getFromDocument ( * ( View -> GetDocument ( ) -> getFormPtr ( ) ) ) ; } }
void CFormDialog :: setToDocument ( uint widget ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { CIconWidget * iconWidget = dynamic_cast < CIconWidget * > ( Widgets [ widget ] ) ; if ( iconWidget ) return ; if ( Widgets [ widget ] -> getFormName ( ) != " NULL " ) { const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( Widgets [ widget ] -> getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( Widgets [ widget ] -> getFormName ( ) . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; if ( parentVDfnArray ) { if ( ! theApp . yesNo ( " Warning , ▁ this ▁ action ▁ will ▁ create ▁ an ▁ array / virtual ▁ dfn ▁ over ▁ an ▁ inherited ▁ array / virtual ▁ dfn . \n Do ▁ you ▁ want ▁ to ▁ continue ▁ ? " ) ) return ; } } IFormWidget :: TTypeSrc typeSrc = Widgets [ widget ] -> getSrcType ( ) ; if ( typeSrc == IFormWidget :: TypeForm ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionString ( IAction :: FormValue , result . c_str ( ) , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeFormParent ) { CForm * form = doc -> getFormPtr ( ) ; uint count = Widgets [ widget ] -> getNumValue ( ) ; vector < string > stringVector ( count ) ; for ( uint value = 0 ; value < count ; value ++ ) { Widgets [ widget ] -> getValue ( stringVector [ value ] , value ) ; } doc -> modify ( new CActionStringVector ( IAction :: FormParent@@ s , stringVector , * doc , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeArray ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionBuffer ( IAction :: FormArraySize , NULL , 0 , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , result . c_str ( ) , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeType ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionString ( IAction :: FormType@@ Value , result . c_str ( ) , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeVirtualDfn ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionBuffer ( IAction :: FormVirtual@@ DfnName , NULL , 0 , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , result . c_str ( ) , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } } if ( ! Widgets [ widget ] -> getFormName ( ) . empty ( ) ) doc -> notifyPlugins ( Widgets [ widget ] -> getFormName ( ) . c_str ( ) ) ; }
LRESULT CFormDialog :: WindowProc ( UINT message , WPARAM wParam , LPARAM lParam ) { switch ( message ) { case CL_CHANGED : { uint widgetId = getWidget ( wParam ) ; CColorEdit * colorEdit = safe_cast < CColorEdit * > ( Widgets [ widgetId ] ) ; colorEdit -> Empty = false ; setToDocument ( getWidget ( wParam ) ) ; } break ; case MC_STRING@@ CHANGE : { setToDocument ( getWidget ( wParam ) ) ; } break ; case CBN_CHANGED : { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { CIconWidget * iconWidget = dynamic_cast < CIconWidget * > ( Widgets [ i ] ) ; if ( iconWidget ) iconWidget -> Icon . Invalidate ( ) ; } } break ; } return CDialog :: WindowProc ( message , wParam , lParam ) ; }
void CFormDialog :: onOpenSelected ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onOpenSelected ( ) ; } } }
void CFormDialog :: onFirstFocus ( ) { View -> SetFocus ( ) ; WidgetFocused = 0xffffffff ; }
void CFormDialog :: onLastFocus ( ) { View -> setFocusLeftView ( ) ; WidgetFocused = 0xffffffff ; }
