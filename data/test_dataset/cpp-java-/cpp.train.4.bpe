<DOCUMENT_ID="Neur@@ oRobotic@@ Tech/AnimatLabPublic@@ Source/tree/master/Libraries/@@ AnimatCarlSimCU@@ DA/Cs@@ ClassFactory@@ .cpp"> # include " StdAf@@ x . h " # include " CsNeuralModule . h " # include " CsNeuronGroup . h " # include " CsSpikeGeneratorGroup . h " # include " CsSynapseGroup . h " # include " CsSynapseOneToOne . h " # include " CsSynapseFull . h " # include " CsSynapseRandom . h " # include " CsSynapseIndividual . h " # include " CsSpikingCurrentSynapse . h " # include " CsFiringRateStimulus . h " # include " CsNeuronDataColumn . h " # include " CsAdapter . h " # include " CsClassFactory . h " namespace AnimatCarlSim { CsClassFactory :: CsClassFactory ( ) { } CsClassFactory :: ~ CsClassFactory ( ) { } Node * CsClassFactory :: CreateNeuron ( std :: string strType , bool bThrowError ) { Node * lpNeuron = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NEURONGROUP " ) lpNeuron = new CsNeuronGroup ; else if ( strType == " SPIKEGENER@@ ATORGROUP " ) lpNeuron = new CsSpikeGeneratorGroup ; else { lpNeuron = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Cs_Err_lInvalidNeuronType , Cs_Err_strInvalidNeuronType , " NeuronType " , strType ) ; } return lpNeuron ; } catch ( CStdErrorInfo oError ) { if ( lpNeuron ) delete lpNeuron ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpNeuron ) delete lpNeuron ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } AnimatSim :: Link * CsClassFactory :: CreateSynapse ( std :: string strType , bool bThrowError ) { AnimatSim :: Link * lpSynapse = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " ONETOONESYNAPSE " ) lpSynapse = new CsSynapseOneToOne ; else if ( strType == " FULLSYNAPSE " ) lpSynapse = new CsSynapseFull ; else if ( strType == " RANDOMSYNAPSE " ) lpSynapse = new CsSynapseRandom ; else if ( strType == " INDIVIDUAL@@ SYNAPSE " ) lpSynapse = new CsSynapseIndividual ; else if ( strType == " SPIKINGC@@ URRENT@@ SYNAPSE " ) lpSynapse = new CsSpikingCurrentSynapse ; else { lpSynapse = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Cs_Err_lInvalidSynapseType , Cs_Err_strInvalidSynapseType , " SynapseType " , strType ) ; } return lpSynapse ; } catch ( CStdErrorInfo oError ) { if ( lpSynapse ) delete lpSynapse ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpSynapse ) delete lpSynapse ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } NeuralModule * CsClassFactory :: CreateNeuralModule ( std :: string strType , bool bThrowError ) { NeuralModule * lpModule = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " CARLSI@@ MNEURALMODULE " ) lpModule = new CsNeuralModule ; else { lpModule = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalidNeuralModuleType , Al_Err_strInvalidNeuralModuleType , " NeuralModule " , strType ) ; } return lpModule ; } catch ( CStdErrorInfo oError ) { if ( lpModule ) delete lpModule ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpModule ) delete lpModule ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } ExternalStimulus * CsClassFactory :: CreateExternalStimulus ( std :: string strType , bool bThrowError ) { ExternalStimulus * lpStimulus = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " FIRINGR@@ ATE " ) lpStimulus = new CsFiringRateStimulus ; else { lpStimulus = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalidExternalStimulusType , Al_Err_strInvalidExternalStimulusType , " ExternalStimulusType " , strType ) ; } return lpStimulus ; } catch ( CStdErrorInfo oError ) { if ( lpStimulus ) delete lpStimulus ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpStimulus ) delete lpStimulus ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } DataColumn * CsClassFactory :: CreateDataColumn ( std :: string strType , bool bThrowError ) { DataColumn * lpColumn = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NEURONDATACOLUMN " ) lpColumn = new CsNeuronDataColumn ; else { lpColumn = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalidDataColumnType , Al_Err_strInvalidDataColumnType , " DataColumnType " , strType ) ; } return lpColumn ; } catch ( CStdErrorInfo oError ) { if ( lpColumn ) delete lpColumn ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpColumn ) delete lpColumn ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } Adapter * CsClassFactory :: CreateAdapter ( std :: string strType , bool bThrowError ) { Adapter * lpAdapter = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NODETONODE " ) lpAdapter = new CsAdapter ; else if ( strType == " PHYSICALTONODE " ) lpAdapter = new CsAdapter ; else { lpAdapter = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalidAdapterType , Al_Err_strInvalidAdapterType , " AdapterType " , strType ) ; } return lpAdapter ; } catch ( CStdErrorInfo oError ) { if ( lpAdapter ) delete lpAdapter ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpAdapter ) delete lpAdapter ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } CStdSerialize * CsClassFactory :: CreateObject ( std :: string strClassType , std :: string strObjectType , bool bThrowError ) { CStdSerialize * lpObject = NULL ; strClassType = Std_ToUpper ( Std_Trim ( strClassType ) ) ; if ( strClassType == " NEURON " ) lpObject = CreateNeuron ( strObjectType , bThrowError ) ; else if ( strClassType == " SYNAPSE " ) lpObject = CreateSynapse ( strObjectType , bThrowError ) ; else if ( strClassType == " NEURALMODULE " ) lpObject = CreateNeuralModule ( strObjectType , bThrowError ) ; else if ( strClassType == " EXTERNAL@@ STIMULUS " ) lpObject = CreateExternalStimulus ( strObjectType , bThrowError ) ; else if ( strClassType == " DATACOLUMN " ) lpObject = CreateDataColumn ( strObjectType , bThrowError ) ; else if ( strClassType == " ADAPTER " ) lpObject = CreateAdapter ( strObjectType , bThrowError ) ; else { lpObject = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Std_Err_lInvalid@@ ClassType , Std_Err_strInvalid@@ ClassType , " ClassType " , strClassType ) ; } return lpObject ; } } # ifdef WIN32 extern " C " __decl@@ spec ( dllexport ) IStdClassFactory * __cdecl GetStdClassFactory ( ) # else extern " C " IStdClassFactory * GetStdClassFactory ( ) # endif { IStdClassFactory * lpFactory = new CsClassFactory ; return lpFactory ; } </DOCUMENT>
<DOCUMENT_ID="Hual/SA@@ -MP-Plu@@ s/tree/master/Common/@@ RakNet/VariableDelta@@ Serializer.cpp"> # include " VariableDeltaSerializer . h " using namespace RakNet ; VariableDeltaSerializer :: VariableDeltaSerializer ( ) { didComparisonThisTick = false ; } VariableDeltaSerializer :: ~ VariableDeltaSerializer ( ) { RemoveRemoteSystemVariableHistory ( ) ; } VariableDeltaSerializer :: SerializationContext :: SerializationContext ( ) { variableHistoryIdentical = 0 ; variableHistoryUnique = 0 ; } VariableDeltaSerializer :: SerializationContext :: ~ SerializationContext ( ) { } void VariableDeltaSerializer :: OnMessage@@ Receipt ( RakNetGUID guid , uint32_t receiptId , bool messageArrived ) { if ( messageArrived ) FreeVarsAssociatedWithReceipt ( guid , receiptId ) ; else DirtyAndFreeVarsAssociatedWithReceipt ( guid , receiptId ) ; } void VariableDeltaSerializer :: BeginUnreli@@ ableAc@@ kedSerialize ( SerializationContext * context , RakNetGUID _guid , BitStream * _bitStream , uint32_t _sendReceipt ) { RakAssert ( _guid != UNASSIGNED_RAKNET_GUID ) ; context -> anyVariablesWritten = false ; context -> guid = _guid ; context -> bitStream = _bitStream ; if ( context -> variableHistoryUnique == 0 ) context -> variableHistoryUnique = StartVariableHistoryWrite ( _guid ) ; context -> variableHistory = context -> variableHistoryUnique ; context -> sendReceipt = _sendReceipt ; context -> changedVariables = AllocChangedVariablesList ( ) ; context -> newSystemSend = false ; context -> serializationMode = UNRELIABLE_WITH_ACK_RECEIPT ; } void VariableDeltaSerializer :: BeginUniqueSerialize ( SerializationContext * context , RakNetGUID _guid , BitStream * _bitStream ) { RakAssert ( _guid != UNASSIGNED_RAKNET_GUID ) ; context -> anyVariablesWritten = false ; context -> guid = _guid ; context -> bitStream = _bitStream ; if ( context -> variableHistoryUnique == 0 ) context -> variableHistoryUnique = StartVariableHistoryWrite ( _guid ) ; context -> variableHistory = context -> variableHistoryUnique ; context -> newSystemSend = false ; context -> serializationMode = RELIABLE ; } void VariableDeltaSerializer :: BeginIdentical@@ Serialize ( SerializationContext * context , bool _isFirstSendToRemoteSystem , BitStream * _bitStream ) { context -> anyVariablesWritten = false ; context -> guid = UNASSIGNED_RAKNET_GUID ; context -> bitStream = _bitStream ; context -> serializationMode = RELIABLE ; if ( context -> variableHistoryIdentical == 0 ) context -> variableHistoryIdentical = StartVariableHistoryWrite ( UNASSIGNED_RAKNET_GUID ) ; context -> variableHistory = context -> variableHistoryIdentical ; context -> newSystemSend = _isFirstSendToRemoteSystem ; } void VariableDeltaSerializer :: EndSerialize ( SerializationContext * context ) { if ( context -> serializationMode == UNRELIABLE_WITH_ACK_RECEIPT ) { if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; FreeChangedVariablesList ( context -> changedVariables ) ; return ; } StoreChangedVariablesList ( context -> variableHistory , context -> changedVariables , context -> sendReceipt ) ; } else { if ( context -> variableHistoryIdentical ) { if ( didComparisonThisTick == false ) { didComparisonThisTick = true ; identicalSerializationBs . Reset ( ) ; if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; return ; } identicalSerializationBs . Write ( context -> bitStream ) ; context -> bitStream -> ResetReadPointer ( ) ; } else { context -> bitStream -> Write ( & identicalSerializationBs ) ; identicalSerializationBs . ResetReadPointer ( ) ; } } else if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; return ; } } } void VariableDeltaSerializer :: BeginDeserialize ( DeserializationContext * context , BitStream * _bitStream ) { context -> bitStream = _bitStream ; } void VariableDeltaSerializer :: EndDeserialize ( DeserializationContext * context ) { ( void ) context ; } void VariableDeltaSerializer :: AddRemoteSystemVariableHistory ( RakNetGUID guid ) { ( void ) guid ; } void VariableDeltaSerializer :: RemoveRemoteSystemVariableHistory ( RakNetGUID guid ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) { for ( idx2 = 0 ; idx2 < remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory . Size ( ) ; idx2 ++ ) { FreeChangedVariablesList ( remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory [ idx2 ] ) ; } delete remoteSystemVariableHistoryList [ idx ] ; remoteSystemVariableHistoryList . RemoveAtIndex@@ Fast ( idx ) ; return ; } } int RakNet :: VariableDeltaSerializer :: UpdatedVariables@@ ListPtr@@ Comp ( const uint32_t & key , ChangedVariablesList * const & data ) { if ( key < data -> sendReceipt ) return - 1 ; if ( key == data -> sendReceipt ) return 0 ; return 1 ; } void VariableDeltaSerializer :: FreeVarsAssociatedWithReceipt ( RakNetGUID guid , uint32_t receiptId ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; RemoteSystemVariableHistory * vprs = remoteSystemVariableHistoryList [ idx ] ; bool objectExists ; idx2 = vprs -> updatedVariablesHistory . GetIndexFromKey ( receiptId , & objectExists ) ; if ( objectExists ) { FreeChangedVariablesList ( vprs -> updatedVariablesHistory [ idx2 ] ) ; vprs -> updatedVariablesHistory . RemoveAtIndex ( idx2 ) ; } } void VariableDeltaSerializer :: DirtyAndFreeVarsAssociatedWithReceipt ( RakNetGUID guid , uint32_t receiptId ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; RemoteSystemVariableHistory * vprs = remoteSystemVariableHistoryList [ idx ] ; bool objectExists ; idx2 = vprs -> updatedVariablesHistory . GetIndexFromKey ( receiptId , & objectExists ) ; if ( objectExists ) { vprs -> variableListDeltaTracker . FlagDirty@@ FromBitArray ( vprs -> updatedVariablesHistory [ idx2 ] -> bitField ) ; FreeChangedVariablesList ( vprs -> updatedVariablesHistory [ idx2 ] ) ; vprs -> updatedVariablesHistory . RemoveAtIndex ( idx2 ) ; } } unsigned int VariableDeltaSerializer :: GetVarsWrittenPerRemoteSystemListIndex ( RakNetGUID guid ) { unsigned int idx ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) return idx ; } return ( unsigned int ) - 1 ; } void VariableDeltaSerializer :: RemoveRemoteSystemVariableHistory ( void ) { unsigned int idx , idx2 ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { for ( idx2 = 0 ; idx2 < remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory . Size ( ) ; idx2 ++ ) { FreeChangedVariablesList ( remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory [ idx2 ] ) ; } delete remoteSystemVariableHistoryList [ idx ] ; } remoteSystemVariableHistoryList . Clear ( false , _FILE_AND_LINE_ ) ; } VariableDeltaSerializer :: RemoteSystemVariableHistory * VariableDeltaSerializer :: GetRemoteSystemVariableHistory ( RakNetGUID guid ) { unsigned int rshli = GetRemoteSystemHistoryListIndex ( guid ) ; return remoteSystemVariableHistoryList [ rshli ] ; } VariableDeltaSerializer :: ChangedVariablesList * VariableDeltaSerializer :: AllocChangedVariablesList ( void ) { VariableDeltaSerializer :: ChangedVariablesList * p = updatedVariablesMemoryPool . Allocate ( _FILE_AND_LINE_ ) ; p -> bitWriteIndex = 0 ; p -> bitField [ 0 ] = 0 ; return p ; } void VariableDeltaSerializer :: FreeChangedVariablesList ( ChangedVariablesList * changedVariables ) { updatedVariablesMemoryPool . Release ( changedVariables , _FILE_AND_LINE_ ) ; } void VariableDeltaSerializer :: StoreChangedVariablesList ( RemoteSystemVariableHistory * variableHistory , ChangedVariablesList * changedVariables , uint32_t sendReceipt ) { changedVariables -> sendReceipt = sendReceipt ; variableHistory -> updatedVariablesHistory . Insert ( changedVariables -> sendReceipt , changedVariables , true , _FILE_AND_LINE_ ) ; } VariableDeltaSerializer :: RemoteSystemVariableHistory * VariableDeltaSerializer :: StartVariableHistoryWrite ( RakNetGUID guid ) { RemoteSystemVariableHistory * variableHistory ; unsigned int rshli = GetRemoteSystemHistoryListIndex ( guid ) ; if ( rshli == ( unsigned int ) - 1 ) { variableHistory = new RemoteSystemVariableHistory ; variableHistory -> guid = guid ; remoteSystemVariableHistoryList . Push ( variableHistory , _FILE_AND_LINE_ ) ; } else { variableHistory = remoteSystemVariableHistoryList [ rshli ] ; } variableHistory -> variableListDeltaTracker . StartWrite ( ) ; return variableHistory ; } unsigned int VariableDeltaSerializer :: GetRemoteSystemHistoryListIndex ( RakNetGUID guid ) { unsigned int idx ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) { return idx ; } } return ( unsigned int ) - 1 ; } void VariableDeltaSerializer :: OnPre@@ SerializeTick ( void ) { didComparisonThisTick = false ; } </DOCUMENT>
<DOCUMENT_ID="fe@@ dech/ldpc_sim@@ /tree/master/src/Simulation@@ .cpp"> # include < iostream > # include < fstream > # include < string > # include < boost / numeric / ublas / matrix . hpp > # include < boost / random . hpp > # include < boost / random / normal_distribution . hpp > # include " LDPCEncoder . h " # include " LDPCDecoder . h " int main ( ) { int n = 648 ; int k = 432 ; int p = n - k ; std :: string file = " n648r23" ; int passes = 50 ; bool qam = true ; int symbols = 4 ; double step = 0.25 ; int minsnr = 0 ; double maxsnr = 4.1 ; int maxPackets = 1E6 ; int minErrors = 100 ; int printInterval = maxPackets / 1000 ; std :: string matrixFolder = " . / matrices / " ; std :: string extIn = " . csv " ; std :: string resultsFolder = " . / results / " ; std :: string extOut = " . dat " ; std :: string encoding = matrixFolder + " enc " + file + extIn ; std :: string decoding = matrixFolder + " dec " + file + extIn ; std :: stringstream ss ; if ( qam ) { ss << " qam " << symbols ; } ss << " _ " << passes ; std :: string output = resultsFolder + file + ss . str ( ) + extOut ; std :: ifstream enc ; enc . open ( encoding . c_str ( ) ) ; std :: ifstream dec ; dec . open ( decoding . c_str ( ) ) ; std :: ofstream out ; out . open ( output . c_str ( ) ) ; out << " # LDPC , ▁ n ▁ = ▁ " << n << " , ▁ k ▁ = ▁ " << k << " \n " ; out << " # SNR ▁ ( dB ) ▁ - ▁ BER ▁ - ▁ PER \n " ; std :: vector < double > snrdb ; std :: vector < int > errors ; std :: vector < int > pktErrors ; std :: vector < int > packets ; boost :: numeric :: ublas :: matrix < int > parityMatrix ( p , n ) ; boost :: numeric :: ublas :: matrix < int > encodingMatrix ( n , k ) ; for ( int i = 0 ; i < p ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dec >> parityMatrix ( i , j ) ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < k ; j ++ ) { enc >> encodingMatrix ( i , j ) ; } } for ( double snr = minsnr ; snr < maxsnr ; snr += step ) { snrdb . push_back ( snr ) ; errors . push_back ( 0 ) ; pktErrors . push_back ( 0 ) ; packets . push_back ( 0 ) ; } boost :: mt19937 rng = boost :: mt19937 ( time ( 0 ) ) ; boost :: variate_generator < boost :: mt19937 & , boost :: normal_distribution < > > generator ( rng , boost :: normal_distribution < > ( ) ) ; LDPCEncoder * encoder = new LDPCEncoder ( k , n , encodingMatrix , symbols ) ; LDPCDecoder * decoder = new LDPCDecoder ( k , n , parityMatrix , passes , symbols ) ; std :: cout << std :: time ( NULL ) << " Created ! \n " ; boost :: numeric :: ublas :: matrix < double > results ( snrdb . size ( ) , 26 ) ; for ( int i = 0 ; i < snrdb . size ( ) ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { results ( i , j ) = 0 ; } } for ( int packet = 0 ; packet < maxPackets ; packet ++ ) { if ( packet % printInterval == 0 ) { std :: cout << packet << " ▁ " << std :: time ( NULL ) << " \n " ; } std :: vector < int > uncoded ; std :: vector < double > w ; std :: vector < double > w_q ; for ( int i = 0 ; i < n ; i ++ ) { w . push_back ( generator ( ) ) ; if ( qam ) { w_q . push_back ( generator ( ) ) ; } } for ( int i = 0 ; i < k ; i ++ ) { uncoded . push_back ( rand ( ) % 2 ) ; } std :: vector < int > coded = encoder -> encode ( uncoded ) ; int counter = 0 ; for ( double snr = minsnr ; snr < maxsnr ; snr += step ) { if ( packets . at ( counter ) == 0 ) { double n0 = 1 / pow ( 10 , snr / 10 ) / log2 ( symbols ) / 2 ; std :: vector < double > received ; std :: vector < LDPCEncoder :: symbol > modulated ; if ( ! qam ) { for ( int i = 0 ; i < n ; i ++ ) { double rec = 2 * coded . at ( i ) - 1 + w . at ( i ) * sqrt ( n0 ) ; received . push_back ( rec ) ; } for ( int i = 0 ; i < n ; i ++ ) { double llr = - 2 * received . at ( i ) / n0 ; received . at ( i ) = llr ; } } else { modulated = encoder -> modulate ( coded ) ; std :: vector < double > phase ; std :: vector < double > quad ; for ( int i = 0 ; i < modulated . size ( ) ; i ++ ) { phase . push_back ( modulated . at ( i ) . phase + w . at ( i ) * sqrt ( n0 ) ) ; quad . push_back ( modulated . at ( i ) . quad + w_q . at ( i ) * sqrt ( n0 ) ) ; } received = decoder -> deModLlr ( phase , quad , n0 ) ; } while ( received . size ( ) > n ) { received . pop_back ( ) ; } std :: vector < int > decoded = decoder -> decode ( received ) ; int error = 0 ; bool correct = true ; for ( int i = 0 ; i < k ; i ++ ) { if ( decoded . at ( i ) != coded . at ( i ) ) { if ( correct ) { correct = false ; pktErrors . at ( counter ) ++ ; } error ++ ; } } errors . at ( counter ) += error ; if ( pktErrors . at ( counter ) > minErrors ) { packets . at ( counter ) = packet + 1 ; } } counter ++ ; } } std :: cout << std :: time ( NULL ) << " Finished ! \n " ; int counter = 0 ; for ( double snr = minsnr ; snr < maxsnr ; snr += step ) { double nPackets = maxPackets ; if ( packets . at ( counter ) != 0 ) { nPackets = packets . at ( counter ) ; } double per = pktErrors . at ( counter ) / nPackets ; double ber = errors . at ( counter ) / ( nPackets * k ) ; out << snr << " ▁ " << ber << " ▁ " << per << " \n " ; counter ++ ; } enc . close ( ) ; dec . close ( ) ; out . close ( ) ; delete encoder ; delete decoder ; } </DOCUMENT>
<DOCUMENT_ID="Dist@@ rotech/xbmc/tree/master/xbmc/android/jni@@ /BaseColumns.cpp"> # include " BaseColumns . h " # include " jutils / jutils - details . hpp " using namespace jni ; std :: string CJNIBaseColumns :: _ID ; std :: string CJNIBaseColumns :: _COUNT ; void CJNIBaseColumns :: Populate@@ StaticFields ( ) { jhclass clazz = find_class ( " android / provider / BaseColumns " ) ; _ID = ( jcast < std :: string > ( get_static_field < jhstring > ( clazz , " _ ID " ) ) ) ; _COUNT = ( jcast < std :: string > ( get_static_field < jhstring > ( clazz , " _ COUNT " ) ) ) ; } </DOCUMENT>
<DOCUMENT_ID="jepp@@ eter/mysq@@ l56/tree/master/storage/ndb/src/cw@@ /cpcd/@@ Monitor@@ .cpp"> # include < ndb_global . h > # include < NdbThread . h > # include < NdbOut . hpp > # include < NdbSleep . h > # include " CPCD . hpp " # include " common . hpp " static void * monitor_thread_create_wrapper ( void * arg ) { CPCD :: Monitor * mon = ( CPCD :: Monitor * ) arg ; mon -> run ( ) ; return NULL ; } CPCD :: Monitor :: Monitor ( CPCD * cpcd , int poll ) { m_cpcd = cpcd ; m_pollingInterval = poll ; m_changeCondition = NdbCondition_Create ( ) ; m_changeMutex = NdbMutex_Create ( ) ; m_monitorThread = NdbThread_Create ( monitor_thread_create_wrapper , ( NDB_THREAD_ARG * ) this , 0 , " ndb _ cpcd _ monitor " , NDB_THREAD_PR@@ IO_MEAN ) ; m_monitorThreadQuit@@ Flag = false ; } CPCD :: Monitor :: ~ Monitor ( ) { NdbThread_Destroy ( & m_monitorThread ) ; NdbCondition_Destroy ( m_changeCondition ) ; NdbMutex_Destroy ( m_changeMutex ) ; } void CPCD :: Monitor :: run ( ) { while ( 1 ) { NdbMutex_Lock ( m_changeMutex ) ; NdbCondition_WaitTimeout ( m_changeCondition , m_changeMutex , m_pollingInterval * 1000 ) ; MutexVector < CPCD :: Process * > & proc = * m_cpcd -> getProcessList ( ) ; proc . lock ( ) ; for ( size_t i = 0 ; i < proc . size ( ) ; i ++ ) { proc [ i ] -> monitor ( ) ; } proc . unlock ( ) ; NdbMutex_Unlock ( m_changeMutex ) ; } } void CPCD :: Monitor :: signal ( ) { NdbCondition_Sig@@ nal ( m_changeCondition ) ; } template class MutexVector < CPCD :: Process * > ; </DOCUMENT>
<DOCUMENT_ID="pcolby@@ /libqta@@ ws/tree/master/src/ssm/@@ describeinstancepatchstatesresponse.cpp"> # include " describeinstancepatchstatesresponse . h " # include " describeinstancepatchstatesresponse _ p . h " # include < QDebug > # include < QNetworkReply > # include < QXmlStreamReader > namespace QtAws { namespace SSM { DescribeInstancePatchStatesResponse :: DescribeInstancePatchStatesResponse ( const DescribeInstancePatchStatesRequest & request , QNetworkReply * const reply , QObject * const parent ) : SsmResponse ( new DescribeInstancePatchStatesResponsePrivate ( this ) , parent ) { setRequest ( new DescribeInstancePatchStatesRequest ( request ) ) ; setReply ( reply ) ; } const DescribeInstancePatchStatesRequest * DescribeInstancePatchStatesResponse :: request ( ) const { Q_D ( const DescribeInstancePatchStatesResponse ) ; return static_cast < const DescribeInstancePatchStatesRequest * > ( d -> request ) ; } void DescribeInstancePatchStatesResponse :: parseSuccess ( QIODevice & response ) { QXmlStreamReader xml ( & response ) ; } DescribeInstancePatchStatesResponsePrivate :: DescribeInstancePatchStatesResponsePrivate ( DescribeInstancePatchStatesResponse * const q ) : SsmResponsePrivate ( q ) { } void DescribeInstancePatchStatesResponsePrivate :: parseDescribeInstancePatchStatesResponse ( QXmlStreamReader & xml ) { Q_ASSERT ( xml . name ( ) == QLatin1String ( " DescribeInstancePatchStatesResponse " ) ) ; Q_UNUSED ( xml ) } } } </DOCUMENT>
<DOCUMENT_ID="job@@ ermayr/pcsx2@@ /tree/master/3rdparty/@@ wxwidgets3.0/src/@@ common/filectr@@ lcmn.cpp"> # include " wx / wxprec . h " # ifdef __BORLANDC__ # pragma hdrstop # endif # if wxUSE_FILECTRL # include " wx / filectrl . h " # ifndef WX_PRECOMP # include " wx / debug . h " # endif const char wxFileCtrlNameStr [ ] = " wxfilectrl " ; wxDEFINE_EVENT ( wxEVT_FILECTRL_SELECTIONCHANGED , wxFileCtrlEvent ) ; wxDEFINE_EVENT ( wxEVT_FILECTRL_FILEACTIVATED , wxFileCtrlEvent ) ; wxDEFINE_EVENT ( wxEVT_FILECTRL_FOLDERCHANGED , wxFileCtrlEvent ) ; wxDEFINE_EVENT ( wxEVT_FILECTRL_FILTERCHANGED , wxFileCtrlEvent ) ; IMPLEMENT_DYNAMIC_CLASS ( wxFileCtrlEvent , wxCommandEvent ) void GenerateFilter@@ ChangedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_FILTERCHANGED , wnd , wnd -> GetId ( ) ) ; event . SetFilterIndex ( fileCtrl -> GetFilterIndex ( ) ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } void GenerateFol@@ derChangedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_FOLDERCHANGED , wnd , wnd -> GetId ( ) ) ; event . SetDirectory ( fileCtrl -> GetDirectory ( ) ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } void GenerateSelectionChangedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_SELECTIONCHANGED , wnd , wnd -> GetId ( ) ) ; event . SetDirectory ( fileCtrl -> GetDirectory ( ) ) ; wxArrayString filenames ; fileCtrl -> GetFilenames ( filenames ) ; event . SetFiles ( filenames ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } void GenerateFileActiv@@ atedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd , const wxString filename ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_FILEACTIVATED , wnd , wnd -> GetId ( ) ) ; event . SetDirectory ( fileCtrl -> GetDirectory ( ) ) ; wxArrayString filenames ; if ( filename . empty ( ) ) { fileCtrl -> GetFilenames ( filenames ) ; } else { filenames . Add ( filename ) ; } event . SetFiles ( filenames ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } wxString wxFileCtrlEvent :: GetFile ( ) const { wxASSERT_MSG ( ! wxDynamicCast ( GetEventObject ( ) , wxFileCtrl ) -> HasMultiple@@ FileSelection ( ) , wxT ( " Please ▁ use ▁ GetFiles ( ) ▁ to ▁ get ▁ all ▁ files ▁ instead ▁ of ▁ this ▁ function " ) ) ; wxString string ; if ( m_files . Count ( ) != 0 ) string = m_files [ 0 ] ; return string ; } # endif </DOCUMENT>
<DOCUMENT_ID="Shift@@ MediaProject@@ /game-music@@ -emu/tree/master/g@@ me/Ay_Apu.cpp"> # include " Ay _ Apu . h " # include " blargg _ source . h " unsigned const inaudible_freq = 16384 ; int const period_factor = 16 ; static byte const amp_table [ 16 ] = { # define ENTRY ( n ) byte ( n * Ay_Apu :: amp_range + 0.5 ) ENTRY ( 0.000000 ) , ENTRY ( 0.007813 ) , ENTRY ( 0.011049 ) , ENTRY ( 0.015625 ) , ENTRY ( 0.0220@@ 97 ) , ENTRY ( 0.031250 ) , ENTRY ( 0.044194 ) , ENTRY ( 0.062500 ) , ENTRY ( 0.088@@ 388 ) , ENTRY ( 0.125000 ) , ENTRY ( 0.176777 ) , ENTRY ( 0.250000 ) , ENTRY ( 0.353553 ) , ENTRY ( 0.500000 ) , ENTRY ( 0.707107 ) , ENTRY ( 1.000000 ) , # undef ENTRY } ; static byte const modes [ 8 ] = { # define MODE ( a0 , a1 , b0 , b1 , c0 , c1 ) ( a0 | a1 << 1 | b0 << 2 | b1 << 3 | c0 << 4 | c1 << 5 ) MODE ( 1 , 0 , 1 , 0 , 1 , 0 ) , MODE ( 1 , 0 , 0 , 0 , 0 , 0 ) , MODE ( 1 , 0 , 0 , 1 , 1 , 0 ) , MODE ( 1 , 0 , 1 , 1 , 1 , 1 ) , MODE ( 0 , 1 , 0 , 1 , 0 , 1 ) , MODE ( 0 , 1 , 1 , 1 , 1 , 1 ) , MODE ( 0 , 1 , 1 , 0 , 0 , 1 ) , MODE ( 0 , 1 , 0 , 0 , 0 , 0 ) , } ; Ay_Apu :: Ay_Apu ( ) { for ( int m = 8 ; m -- ; ) { byte * out = env . modes [ m ] ; int flags = modes [ m ] ; for ( int x = 3 ; -- x >= 0 ; ) { int amp = flags & 1 ; int end = flags >> 1 & 1 ; int step = end - amp ; amp *= 15 ; for ( int y = 16 ; -- y >= 0 ; ) { * out ++ = amp_table [ amp ] ; amp += step ; } flags >>= 2 ; } } output ( 0 ) ; volume ( 1.0 ) ; reset ( ) ; } void Ay_Apu :: reset ( ) { last_time = 0 ; noise . delay = 0 ; noise . lfsr = 1 ; osc_t * osc = & oscs [ osc_count ] ; do { osc -- ; osc -> period = period_factor ; osc -> delay = 0 ; osc -> last_amp = 0 ; osc -> phase = 0 ; } while ( osc != oscs ) ; for ( int i = sizeof regs ; -- i >= 0 ; ) regs [ i ] = 0 ; regs [ 7 ] = 0xFF ; write_data_ ( 13 , 0 ) ; } void Ay_Apu :: write_data_ ( int addr , int data ) { assert ( ( unsigned ) addr < reg_count ) ; if ( ( unsigned ) addr >= 14 ) { # ifdef debug_printf debug_printf ( " Wrote ▁ to ▁ I / O ▁ port ▁ % 02X \n " , ( int ) addr ) ; # endif } if ( addr == 13 ) { if ( ! ( data & 8 ) ) data = ( data & 4 ) ? 15 : 9 ; env . wave = env . modes [ data - 7 ] ; env . pos = - 48 ; env . delay = 0 ; } regs [ addr ] = data ; int i = addr >> 1 ; if ( i < osc_count ) { blip_time_t period = ( regs [ i * 2 + 1 ] & 0x0F ) * ( 0x100L * period_factor ) + regs [ i * 2 ] * period_factor ; if ( ! period ) period = period_factor ; osc_t & osc = oscs [ i ] ; if ( ( osc . delay += period - osc . period ) < 0 ) osc . delay = 0 ; osc . period = period ; } } int const noise_off = 0x08 ; int const tone_off = 0x01 ; void Ay_Apu :: run_un@@ til ( blip_time_t final_end_time ) { require ( final_end_time >= last_time ) ; blip_time_t const noise_period_factor = period_factor * 2 ; blip_time_t noise_period = ( regs [ 6 ] & 0x1F ) * noise_period_factor ; if ( ! noise_period ) noise_period = noise_period_factor ; blip_time_t const old_noise_delay = noise . delay ; blargg_ulong const old_noise_lfsr = noise . lfsr ; blip_time_t const env_period_factor = period_factor * 2 ; blip_time_t env_period = ( regs [ 12 ] * 0x100L + regs [ 11 ] ) * env_period_factor ; if ( ! env_period ) env_period = env_period_factor ; if ( ! env . delay ) env . delay = env_period ; for ( int index = 0 ; index < osc_count ; index ++ ) { osc_t * const osc = & oscs [ index ] ; int osc_mode = regs [ 7 ] >> index ; Blip_Buffer * const osc_output = osc -> output ; if ( ! osc_output ) continue ; osc_output -> set_modi@@ fied ( ) ; int half_vol = 0 ; blip_time_t inaudible_period = ( blargg_ulong ) ( osc_output -> clock_rate ( ) + inaudible_freq ) / ( inaudible_freq * 2 ) ; if ( osc -> period <= inaudible_period && ! ( osc_mode & tone_off ) ) { half_vol = 1 ; osc_mode |= tone_off ; } blip_time_t start_time = last_time ; blip_time_t end_time = final_end_time ; int const vol_mode = regs [ 0x08 + index ] ; int volume = amp_table [ vol_mode & 0x0F ] >> half_vol ; int osc_env_pos = env . pos ; if ( vol_mode & 0x10 ) { volume = env . wave [ osc_env_pos ] >> half_vol ; if ( ! ( regs [ 13 ] & 1 ) || osc_env_pos < - 32 ) { end_time = start_time + env . delay ; if ( end_time >= final_end_time ) end_time = final_end_time ; } else if ( ! volume ) { osc_mode = noise_off | tone_off ; } } else if ( ! volume ) { osc_mode = noise_off | tone_off ; } blip_time_t const period = osc -> period ; blip_time_t time = start_time + osc -> delay ; if ( osc_mode & tone_off ) { blargg_long count = ( final_end_time - time + period - 1 ) / period ; time += count * period ; osc -> phase ^= count & 1 ; } blip_time_t ntime = final_end_time ; blargg_ulong noise_lfsr = 1 ; if ( ! ( osc_mode & noise_off ) ) { ntime = start_time + old_noise_delay ; noise_lfsr = old_noise_lfsr ; } while ( 1 ) { int amp = 0 ; if ( ( osc_mode | osc -> phase ) & 1 & ( osc_mode >> 3 | noise_lfsr ) ) amp = volume ; { int delta = amp - osc -> last_amp ; if ( delta ) { osc -> last_amp = amp ; synth_ . offset ( start_time , delta , osc_output ) ; } } if ( ntime < end_time || time < end_time ) { int delta = amp * 2 - volume ; int delta_non_zero = delta != 0 ; int phase = osc -> phase | ( osc_mode & tone_off ) ; assert ( tone_off == 0x01 ) ; do { blip_time_t end = end_time ; if ( end_time > time ) end = time ; if ( phase & delta_non_zero ) { while ( ntime <= end ) { int changed = noise_lfsr + 1 ; noise_lfsr = ( - ( noise_lfsr & 1 ) & 0x12000 ) ^ ( noise_lfsr >> 1 ) ; if ( changed & 2 ) { delta = - delta ; synth_ . offset ( ntime , delta , osc_output ) ; } ntime += noise_period ; } } else { blargg_long remain = end - ntime ; blargg_long count = remain / noise_period ; if ( remain >= 0 ) ntime += noise_period + count * noise_period ; } end = end_time ; if ( end_time > ntime ) end = ntime ; if ( noise_lfsr & delta_non_zero ) { while ( time < end ) { delta = - delta ; synth_ . offset ( time , delta , osc_output ) ; time += period ; } phase = unsigned ( - delta ) >> ( CHAR_BIT * sizeof ( unsigned ) - 1 ) ; } else { while ( time < end ) { time += period ; phase ^= 1 ; } } } while ( time < end_time || ntime < end_time ) ; osc -> last_amp = ( delta + volume ) >> 1 ; if ( ! ( osc_mode & tone_off ) ) osc -> phase = phase ; } if ( end_time >= final_end_time ) break ; if ( ++ osc_env_pos >= 0 ) osc_env_pos -= 32 ; volume = env . wave [ osc_env_pos ] >> half_vol ; start_time = end_time ; end_time += env_period ; if ( end_time > final_end_time ) end_time = final_end_time ; } osc -> delay = time - final_end_time ; if ( ! ( osc_mode & noise_off ) ) { noise . delay = ntime - final_end_time ; noise . lfsr = noise_lfsr ; } } blip_time_t remain = final_end_time - last_time - env . delay ; if ( remain >= 0 ) { blargg_long count = ( remain + env_period ) / env_period ; env . pos += count ; if ( env . pos >= 0 ) env . pos = ( env . pos & 31 ) - 32 ; remain -= count * env_period ; assert ( - remain <= env_period ) ; } env . delay = - remain ; assert ( env . delay > 0 ) ; assert ( env . pos < 0 ) ; last_time = final_end_time ; } </DOCUMENT>
<DOCUMENT_ID="dodam@@ n/pkg-@@ dosbox/tree/master/src/@@ hardware/mix@@ er.cpp"> # include < string . h > # include < sys / types . h > # include < math . h > # if defined ( WIN32 ) # ifndef WIN32_LEAN_AND_MEAN # define WIN32_LEAN_AND_MEAN # endif # include < windows . h > # include < mmsystem . h > # endif # include " SDL . h " # include " mem . h " # include " pic . h " # include " dosbox . h " # include " mixer . h " # include " timer . h " # include " setup . h " # include " cross . h " # include " support . h " # include " mapper . h " # include " hardware . h " # include " programs . h " # define MIXER_SSIZE 4 # define MIXER_SHIFT 14 # define MIXER_REMAIN ( ( 1 << MIXER_SHIFT ) - 1 ) # define MIXER_VOLSHIFT 13 static INLINE Bit16s MIXER_CLIP ( Bits SAMP ) { if ( SAMP < MAX_AUDIO ) { if ( SAMP > MIN_AUDIO ) return SAMP ; else return MIN_AUDIO ; } else return MAX_AUDIO ; } static struct { Bit32s work [ MIXER_BUFSIZE ] [ 2 ] ; Bitu pos , done ; Bitu needed , min_needed , max_needed ; Bit32u tick_add , tick_remain ; float mastervol [ 2 ] ; MixerChannel * channels ; bool nosound ; Bit32u freq ; Bit32u blocksize ; } mixer ; Bit8u MixTemp [ MIXER_BUFSIZE ] ; MixerChannel * MIXER_AddChannel ( MIXER_Handler handler , Bitu freq , const char * name ) { MixerChannel * chan = new MixerChannel ( ) ; chan -> scale = 1.0 ; chan -> handler = handler ; chan -> name = name ; chan -> SetFreq ( freq ) ; chan -> next = mixer . channels ; chan -> SetVolume ( 1 , 1 ) ; chan -> enabled = false ; mixer . channels = chan ; return chan ; } MixerChannel * MIXER_FindChannel ( const char * name ) { MixerChannel * chan = mixer . channels ; while ( chan ) { if ( ! strcasecmp ( chan -> name , name ) ) break ; chan = chan -> next ; } return chan ; } void MIXER_DelChannel ( MixerChannel * delchan ) { MixerChannel * chan = mixer . channels ; MixerChannel * * where = & mixer . channels ; while ( chan ) { if ( chan == delchan ) { * where = chan -> next ; delete delchan ; return ; } where = & chan -> next ; chan = chan -> next ; } } void MixerChannel :: UpdateVolume ( void ) { volmul [ 0 ] = ( Bits ) ( ( 1 << MIXER_VOLSHIFT ) * scale * volmain [ 0 ] * mixer . mastervol [ 0 ] ) ; volmul [ 1 ] = ( Bits ) ( ( 1 << MIXER_VOLSHIFT ) * scale * volmain [ 1 ] * mixer . mastervol [ 1 ] ) ; } void MixerChannel :: SetVolume ( float _left , float _right ) { volmain [ 0 ] = _left ; volmain [ 1 ] = _right ; UpdateVolume ( ) ; } void MixerChannel :: SetScale ( float f ) { scale = f ; UpdateVolume ( ) ; } void MixerChannel :: Enable ( bool _yesno ) { if ( _yesno == enabled ) return ; enabled = _yesno ; if ( enabled ) { freq_index = MIXER_REMAIN ; SDL_LockAudio ( ) ; if ( done < mixer . done ) done = mixer . done ; SDL_UnlockAudio ( ) ; } } void MixerChannel :: SetFreq ( Bitu _freq ) { freq_add = ( _freq << MIXER_SHIFT ) / mixer . freq ; } void MixerChannel :: Mix ( Bitu _needed ) { needed = _needed ; while ( enabled && needed > done ) { Bitu todo = needed - done ; todo *= freq_add ; if ( todo & MIXER_REMAIN ) { todo = ( todo >> MIXER_SHIFT ) + 1 ; } else { todo = ( todo >> MIXER_SHIFT ) ; } handler ( todo ) ; } } void MixerChannel :: AddSilence ( void ) { if ( done < needed ) { done = needed ; last [ 0 ] = last [ 1 ] = 0 ; freq_index = MIXER_REMAIN ; } } template < class Type , bool stereo , bool signeddata , bool nativeorder > inline void MixerChannel :: AddSamples ( Bitu len , const Type * data ) { Bits diff [ 2 ] ; Bitu mixpos = mixer . pos + done ; freq_index &= MIXER_REMAIN ; Bitu pos = 0 ; Bitu new_pos ; goto thestart ; for ( ; ; ) { new_pos = freq_index >> MIXER_SHIFT ; if ( pos < new_pos ) { last [ 0 ] += diff [ 0 ] ; if ( stereo ) last [ 1 ] += diff [ 1 ] ; pos = new_pos ; thestart : if ( pos >= len ) return ; if ( sizeof ( Type ) == 1 ) { if ( ! signeddata ) { if ( stereo ) { diff [ 0 ] = ( ( ( Bit8s ) ( data [ pos * 2 + 0 ] ^ 0x80 ) ) << 8 ) - last [ 0 ] ; diff [ 1 ] = ( ( ( Bit8s ) ( data [ pos * 2 + 1 ] ^ 0x80 ) ) << 8 ) - last [ 1 ] ; } else { diff [ 0 ] = ( ( ( Bit8s ) ( data [ pos ] ^ 0x80 ) ) << 8 ) - last [ 0 ] ; } } else { if ( stereo ) { diff [ 0 ] = ( data [ pos * 2 + 0 ] << 8 ) - last [ 0 ] ; diff [ 1 ] = ( data [ pos * 2 + 1 ] << 8 ) - last [ 1 ] ; } else { diff [ 0 ] = ( data [ pos ] << 8 ) - last [ 0 ] ; } } } else { if ( signeddata ) { if ( stereo ) { if ( nativeorder ) { diff [ 0 ] = data [ pos * 2 + 0 ] - last [ 0 ] ; diff [ 1 ] = data [ pos * 2 + 1 ] - last [ 1 ] ; } else { if ( sizeof ( Type ) == 2 ) { diff [ 0 ] = ( Bit16s ) host_readw ( ( HostPt ) & data [ pos * 2 + 0 ] ) - last [ 0 ] ; diff [ 1 ] = ( Bit16s ) host_readw ( ( HostPt ) & data [ pos * 2 + 1 ] ) - last [ 1 ] ; } else { diff [ 0 ] = ( Bit32s ) host_readd ( ( HostPt ) & data [ pos * 2 + 0 ] ) - last [ 0 ] ; diff [ 1 ] = ( Bit32s ) host_readd ( ( HostPt ) & data [ pos * 2 + 1 ] ) - last [ 1 ] ; } } } else { if ( nativeorder ) { diff [ 0 ] = data [ pos ] - last [ 0 ] ; } else { if ( sizeof ( Type ) == 2 ) { diff [ 0 ] = ( Bit16s ) host_readw ( ( HostPt ) & data [ pos ] ) - last [ 0 ] ; } else { diff [ 0 ] = ( Bit32s ) host_readd ( ( HostPt ) & data [ pos ] ) - last [ 0 ] ; } } } } else { if ( stereo ) { if ( nativeorder ) { diff [ 0 ] = ( Bits ) data [ pos * 2 + 0 ] - 32768 - last [ 0 ] ; diff [ 1 ] = ( Bits ) data [ pos * 2 + 1 ] - 32768 - last [ 1 ] ; } else { if ( sizeof ( Type ) == 2 ) { diff [ 0 ] = ( Bits ) host_readw ( ( HostPt ) & data [ pos * 2 + 0 ] ) - 32768 - last [ 0 ] ; diff [ 1 ] = ( Bits ) host_readw ( ( HostPt ) & data [ pos * 2 + 1 ] ) - 32768 - last [ 1 ] ; } else { diff [ 0 ] = ( Bits ) host_readd ( ( HostPt ) & data [ pos * 2 + 0 ] ) - 32768 - last [ 0 ] ; diff [ 1 ] = ( Bits ) host_readd ( ( HostPt ) & data [ pos * 2 + 1 ] ) - 32768 - last [ 1 ] ; } } } else { if ( nativeorder ) { diff [ 0 ] = ( Bits ) data [ pos ] - 32768 - last [ 0 ] ; } else { if ( sizeof ( Type ) == 2 ) { diff [ 0 ] = ( Bits ) host_readw ( ( HostPt ) & data [ pos ] ) - 32768 - last [ 0 ] ; } else { diff [ 0 ] = ( Bits ) host_readd ( ( HostPt ) & data [ pos ] ) - 32768 - last [ 0 ] ; } } } } } } Bits diff_mul = freq_index & MIXER_REMAIN ; freq_index += freq_add ; mixpos &= MIXER_BUFMASK ; Bits sample = last [ 0 ] + ( ( diff [ 0 ] * diff_mul ) >> MIXER_SHIFT ) ; mixer . work [ mixpos ] [ 0 ] += sample * volmul [ 0 ] ; if ( stereo ) sample = last [ 1 ] + ( ( diff [ 1 ] * diff_mul ) >> MIXER_SHIFT ) ; mixer . work [ mixpos ] [ 1 ] += sample * volmul [ 1 ] ; mixpos ++ ; done ++ ; } } void MixerChannel :: AddStretch@@ ed ( Bitu len , Bit16s * data ) { if ( done >= needed ) { LOG_MSG ( " Can ' t ▁ add , ▁ buffer ▁ full " ) ; return ; } Bitu outlen = needed - done ; Bits diff ; freq_index = 0 ; Bitu temp_add = ( len << MIXER_SHIFT ) / outlen ; Bitu mixpos = mixer . pos + done ; done = needed ; Bitu pos = 0 ; diff = data [ 0 ] - last [ 0 ] ; while ( outlen -- ) { Bitu new_pos = freq_index >> MIXER_SHIFT ; if ( pos < new_pos ) { pos = new_pos ; last [ 0 ] += diff ; diff = data [ pos ] - last [ 0 ] ; } Bits diff_mul = freq_index & MIXER_REMAIN ; freq_index += temp_add ; mixpos &= MIXER_BUFMASK ; Bits sample = last [ 0 ] + ( ( diff * diff_mul ) >> MIXER_SHIFT ) ; mixer . work [ mixpos ] [ 0 ] += sample * volmul [ 0 ] ; mixer . work [ mixpos ] [ 1 ] += sample * volmul [ 1 ] ; mixpos ++ ; } } void MixerChannel :: AddSamples_m8 ( Bitu len , const Bit8u * data ) { AddSamples < Bit8u , false , false , true > ( len , data ) ; } void MixerChannel :: AddSamples_s8 ( Bitu len , const Bit8u * data ) { AddSamples < Bit8u , true , false , true > ( len , data ) ; } void MixerChannel :: AddSamples_m8s ( Bitu len , const Bit8s * data ) { AddSamples < Bit8s , false , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_s8s ( Bitu len , const Bit8s * data ) { AddSamples < Bit8s , true , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_m16 ( Bitu len , const Bit16s * data ) { AddSamples < Bit16s , false , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_s16 ( Bitu len , const Bit16s * data ) { AddSamples < Bit16s , true , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_m16u ( Bitu len , const Bit16u * data ) { AddSamples < Bit16u , false , false , true > ( len , data ) ; } void MixerChannel :: AddSamples_s16u ( Bitu len , const Bit16u * data ) { AddSamples < Bit16u , true , false , true > ( len , data ) ; } void MixerChannel :: AddSamples_m32 ( Bitu len , const Bit32s * data ) { AddSamples < Bit32s , false , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_s32 ( Bitu len , const Bit32s * data ) { AddSamples < Bit32s , true , true , true > ( len , data ) ; } void MixerChannel :: AddSamples_m16_nonnative ( Bitu len , const Bit16s * data ) { AddSamples < Bit16s , false , true , false > ( len , data ) ; } void MixerChannel :: AddSamples_s16_nonnative ( Bitu len , const Bit16s * data ) { AddSamples < Bit16s , true , true , false > ( len , data ) ; } void MixerChannel :: AddSamples_m16u_nonnative ( Bitu len , const Bit16u * data ) { AddSamples < Bit16u , false , false , false > ( len , data ) ; } void MixerChannel :: AddSamples_s16u_nonnative ( Bitu len , const Bit16u * data ) { AddSamples < Bit16u , true , false , false > ( len , data ) ; } void MixerChannel :: AddSamples_m32_nonnative ( Bitu len , const Bit32s * data ) { AddSamples < Bit32s , false , true , false > ( len , data ) ; } void MixerChannel :: AddSamples_s32_nonnative ( Bitu len , const Bit32s * data ) { AddSamples < Bit32s , true , true , false > ( len , data ) ; } void MixerChannel :: FillUp ( void ) { SDL_LockAudio ( ) ; if ( ! enabled || done < mixer . done ) { SDL_UnlockAudio ( ) ; return ; } float index = PIC_TickIndex ( ) ; Mix ( ( Bitu ) ( index * mixer . needed ) ) ; SDL_UnlockAudio ( ) ; } extern bool ticksLocked ; static inline bool Mixer_irq_important ( void ) { return ( ticksLocked || ( CaptureState & ( CAPTURE_WAVE | CAPTURE_VIDEO ) ) ) ; } static void MIXER_MixData ( Bitu needed ) { MixerChannel * chan = mixer . channels ; while ( chan ) { chan -> Mix ( needed ) ; chan = chan -> next ; } if ( CaptureState & ( CAPTURE_WAVE | CAPTURE_VIDEO ) ) { Bit16s convert [ 1024 ] [ 2 ] ; Bitu added = needed - mixer . done ; if ( added > 1024 ) added = 1024 ; Bitu readpos = ( mixer . pos + mixer . done ) & MIXER_BUFMASK ; for ( Bitu i = 0 ; i < added ; i ++ ) { Bits sample = mixer . work [ readpos ] [ 0 ] >> MIXER_VOLSHIFT ; convert [ i ] [ 0 ] = MIXER_CLIP ( sample ) ; sample = mixer . work [ readpos ] [ 1 ] >> MIXER_VOLSHIFT ; convert [ i ] [ 1 ] = MIXER_CLIP ( sample ) ; readpos = ( readpos + 1 ) & MIXER_BUFMASK ; } CAPTURE_AddWave ( mixer . freq , added , ( Bit16s * ) convert ) ; } if ( Mixer_irq_important ( ) ) mixer . tick_add = ( ( mixer . freq ) << MIXER_SHIFT ) / 1000 ; mixer . done = needed ; } static void MIXER_Mix ( void ) { SDL_LockAudio ( ) ; MIXER_MixData ( mixer . needed ) ; mixer . tick_remain += mixer . tick_add ; mixer . needed += ( mixer . tick_remain >> MIXER_SHIFT ) ; mixer . tick_remain &= MIXER_REMAIN ; SDL_UnlockAudio ( ) ; } static void MIXER_Mix_NoSound ( void ) { MIXER_MixData ( mixer . needed ) ; for ( Bitu i = 0 ; i < mixer . needed ; i ++ ) { mixer . work [ mixer . pos ] [ 0 ] = 0 ; mixer . work [ mixer . pos ] [ 1 ] = 0 ; mixer . pos = ( mixer . pos + 1 ) & MIXER_BUFMASK ; } for ( MixerChannel * chan = mixer . channels ; chan ; chan = chan -> next ) { if ( chan -> done > mixer . needed ) chan -> done -= mixer . needed ; else chan -> done = 0 ; } mixer . tick_remain += mixer . tick_add ; mixer . needed = mixer . tick_remain >> MIXER_SHIFT ; mixer . tick_remain &= MIXER_REMAIN ; mixer . done = 0 ; } static void MIXER_CallBack ( void * userdata , Uint8 * stream , int len ) { Bitu need = ( Bitu ) len / MIXER_SSIZE ; Bit16s * output = ( Bit16s * ) stream ; Bitu reduce ; Bitu pos , index , index_add ; Bits sample ; if ( mixer . done < need ) { if ( ( need - mixer . done ) > ( need >> 7 ) ) return ; reduce = mixer . done ; index_add = ( reduce << MIXER_SHIFT ) / need ; mixer . tick_add = ( ( mixer . freq + mixer . min_needed ) << MIXER_SHIFT ) / 1000 ; } else if ( mixer . done < mixer . max_needed ) { Bitu left = mixer . done - need ; if ( left < mixer . min_needed ) { if ( ! Mixer_irq_important ( ) ) { Bitu needed = mixer . needed - need ; Bitu diff = ( mixer . min_needed > needed ? mixer . min_needed : needed ) - left ; mixer . tick_add = ( ( mixer . freq + ( diff * 3 ) ) << MIXER_SHIFT ) / 1000 ; left = 0 ; } else { left = ( mixer . min_needed - left ) ; left = 1 + ( 2 * left ) / mixer . min_needed ; } reduce = need - left ; index_add = ( reduce << MIXER_SHIFT ) / need ; } else { reduce = need ; index_add = ( 1 << MIXER_SHIFT ) ; Bitu diff = left - mixer . min_needed ; if ( diff > ( mixer . min_needed << 1 ) ) diff = mixer . min_needed << 1 ; if ( diff > ( mixer . min_needed >> 1 ) ) mixer . tick_add = ( ( mixer . freq - ( diff / 5 ) ) << MIXER_SHIFT ) / 1000 ; else if ( diff > ( mixer . min_needed >> 4 ) ) mixer . tick_add = ( ( mixer . freq - ( diff >> 3 ) ) << MIXER_SHIFT ) / 1000 ; else mixer . tick_add = ( mixer . freq << MIXER_SHIFT ) / 1000 ; } } else { if ( mixer . done > MIXER_BUFSIZE ) index_add = MIXER_BUFSIZE - 2 * mixer . min_needed ; else index_add = mixer . done - 2 * mixer . min_needed ; index_add = ( index_add << MIXER_SHIFT ) / need ; reduce = mixer . done - 2 * mixer . min_needed ; mixer . tick_add = ( ( mixer . freq - ( mixer . min_needed / 5 ) ) << MIXER_SHIFT ) / 1000 ; } for ( MixerChannel * chan = mixer . channels ; chan ; chan = chan -> next ) { if ( chan -> done > reduce ) chan -> done -= reduce ; else chan -> done = 0 ; } if ( Mixer_irq_important ( ) ) mixer . tick_add = ( mixer . freq << MIXER_SHIFT ) / 1000 ; mixer . done -= reduce ; mixer . needed -= reduce ; pos = mixer . pos ; mixer . pos = ( mixer . pos + reduce ) & MIXER_BUFMASK ; index = 0 ; if ( need != reduce ) { while ( need -- ) { Bitu i = ( pos + ( index >> MIXER_SHIFT ) ) & MIXER_BUFMASK ; index += index_add ; sample = mixer . work [ i ] [ 0 ] >> MIXER_VOLSHIFT ; * output ++ = MIXER_CLIP ( sample ) ; sample = mixer . work [ i ] [ 1 ] >> MIXER_VOLSHIFT ; * output ++ = MIXER_CLIP ( sample ) ; } while ( reduce -- ) { pos &= MIXER_BUFMASK ; mixer . work [ pos ] [ 0 ] = 0 ; mixer . work [ pos ] [ 1 ] = 0 ; pos ++ ; } } else { while ( reduce -- ) { pos &= MIXER_BUFMASK ; sample = mixer . work [ pos ] [ 0 ] >> MIXER_VOLSHIFT ; * output ++ = MIXER_CLIP ( sample ) ; sample = mixer . work [ pos ] [ 1 ] >> MIXER_VOLSHIFT ; * output ++ = MIXER_CLIP ( sample ) ; mixer . work [ pos ] [ 0 ] = 0 ; mixer . work [ pos ] [ 1 ] = 0 ; pos ++ ; } } } static void MIXER_Stop ( Section * sec ) { } class MIXER : public Program { public : void MakeVolume ( char * scan , float & vol0 , float & vol1 ) { Bitu w = 0 ; bool db = ( toupper ( * scan ) == ' D ' ) ; if ( db ) scan ++ ; while ( * scan ) { if ( * scan == ' : ' ) { ++ scan ; w = 1 ; } char * before = scan ; float val = ( float ) strtod ( scan , & scan ) ; if ( before == scan ) { ++ scan ; continue ; } if ( ! db ) val /= 100 ; else val = powf ( 10.0f , ( float ) val / 20.0f ) ; if ( val < 0 ) val = 1.0f ; if ( ! w ) { vol0 = val ; } else { vol1 = val ; } } if ( ! w ) vol1 = vol0 ; } void Run ( void ) { if ( cmd -> FindExist ( " / LIST@@ MIDI " ) ) { ListMidi ( ) ; return ; } if ( cmd -> FindString ( " MASTER " , temp_line , false ) ) { MakeVolume ( ( char * ) temp_line . c_str ( ) , mixer . mastervol [ 0 ] , mixer . mastervol [ 1 ] ) ; } MixerChannel * chan = mixer . channels ; while ( chan ) { if ( cmd -> FindString ( chan -> name , temp_line , false ) ) { MakeVolume ( ( char * ) temp_line . c_str ( ) , chan -> volmain [ 0 ] , chan -> volmain [ 1 ] ) ; } chan -> UpdateVolume ( ) ; chan = chan -> next ; } if ( cmd -> FindExist ( " / NOSHO@@ W " ) ) return ; chan = mixer . channels ; WriteOut ( " Channel ▁ ▁ Main ▁ ▁ ▁ ▁ Main ( dB ) \n " ) ; ShowVolume ( " MASTER " , mixer . mastervol [ 0 ] , mixer . mastervol [ 1 ] ) ; for ( chan = mixer . channels ; chan ; chan = chan -> next ) ShowVolume ( chan -> name , chan -> volmain [ 0 ] , chan -> volmain [ 1 ] ) ; } private : void ShowVolume ( const char * name , float vol0 , float vol1 ) { WriteOut ( " % -8s ▁ % 3.0f : % - 3.0f ▁ ▁ % + 3.2f : % - + 3.2f ▁ \n " , name , vol0 * 100 , vol1 * 100 , 20 * log ( vol0 ) / log ( 10.0f ) , 20 * log ( vol1 ) / log ( 10.0f ) ) ; } void ListMidi ( ) { # if defined ( WIN32 ) unsigned int total = midiOutGetNumDev@@ s ( ) ; for ( unsigned int i = 0 ; i < total ; i ++ ) { MIDIOUTCAPS mididev ; midiOutGetDevCaps ( i , & mididev , sizeof ( MIDIOUTCAPS ) ) ; WriteOut ( " % 2d\t ▁ \ " % s\ " \n " , i , mididev . szPname ) ; } # endif return ; } ; } ; static void MIXER_ProgramStart ( Program * * make ) { * make = new MIXER ; } MixerChannel * MixerObject :: Install ( MIXER_Handler handler , Bitu freq , const char * name ) { if ( ! installed ) { if ( strlen ( name ) > 31 ) E_Exit ( " Too ▁ long ▁ mixer ▁ channel ▁ name " ) ; safe_strncpy ( m_name , name , 32 ) ; installed = true ; return MIXER_AddChannel ( handler , freq , name ) ; } else { E_Exit ( " allready ▁ added ▁ mixer ▁ channel . " ) ; return 0 ; } } MixerObject :: ~ MixerObject ( ) { if ( ! installed ) return ; MIXER_DelChannel ( MIXER_FindChannel ( m_name ) ) ; } void MIXER_Init ( Section * sec ) { sec -> AddDestroy@@ Function ( & MIXER_Stop ) ; Section_prop * section = static_cast < Section_prop * > ( sec ) ; mixer . freq = section -> Get_int ( " rate " ) ; mixer . nosound = section -> Get_bool ( " nosound " ) ; mixer . blocksize = section -> Get_int ( " blocksize " ) ; mixer . channels = 0 ; mixer . pos = 0 ; mixer . done = 0 ; memset ( mixer . work , 0 , sizeof ( mixer . work ) ) ; mixer . mastervol [ 0 ] = 1.0f ; mixer . mastervol [ 1 ] = 1.0f ; SDL_AudioSpec spec ; SDL_AudioSpec obtained ; spec . freq = mixer . freq ; spec . format = AUDIO_S16@@ SYS ; spec . channels = 2 ; spec . callback = MIXER_CallBack ; spec . userdata = NULL ; spec . samples = ( Uint16 ) mixer . blocksize ; mixer . tick_remain = 0 ; if ( mixer . nosound ) { LOG_MSG ( " MIXER : No ▁ Sound ▁ Mode ▁ Selected . " ) ; mixer . tick_add = ( ( mixer . freq ) << MIXER_SHIFT ) / 1000 ; TIMER_AddTickHandler ( MIXER_Mix_NoSound ) ; } else if ( SDL_Open@@ Audio ( & spec , & obtained ) < 0 ) { mixer . nosound = true ; LOG_MSG ( " MIXER : Can ' t ▁ open ▁ audio : ▁ % s ▁ , ▁ running ▁ in ▁ nosound ▁ mode . " , SDL_GetError ( ) ) ; mixer . tick_add = ( ( mixer . freq ) << MIXER_SHIFT ) / 1000 ; TIMER_AddTickHandler ( MIXER_Mix_NoSound ) ; } else { mixer . freq = obtained . freq ; mixer . blocksize = obtained . samples ; mixer . tick_add = ( mixer . freq << MIXER_SHIFT ) / 1000 ; TIMER_AddTickHandler ( MIXER_Mix ) ; SDL_PauseAudio ( 0 ) ; } mixer . min_needed = section -> Get_int ( " prebuffer " ) ; if ( mixer . min_needed > 100 ) mixer . min_needed = 100 ; mixer . min_needed = ( mixer . freq * mixer . min_needed ) / 1000 ; mixer . max_needed = mixer . blocksize * 2 + 2 * mixer . min_needed ; mixer . needed = mixer . min_needed + 1 ; PROGRAMS_@@ MakeFile ( " MIXER . COM " , MIXER_ProgramStart ) ; } </DOCUMENT>
<DOCUMENT_ID="wak@@ ashige/@@ TrinityCore/tree/master/src/server/scripts/EasternKingdoms/@@ zone_arathi_highl@@ ands.cpp"> # include " ScriptMgr . h " # include " ScriptedCreature . h " # include " ScriptedEsc@@ ortAI . h " # include " Player . h " enum ProfessorPhizzlethorpe { SAY_PROGRESS_1 = 0 , SAY_PROGRESS_2 = 1 , SAY_PROGRESS_3 = 2 , EMOTE_PROGRESS_4 = 3 , SAY_AGGRO = 4 , SAY_PROGRESS_5 = 5 , SAY_PROGRESS_6 = 6 , SAY_PROGRESS_7 = 7 , EMOTE_PROGRESS_8 = 8 , SAY_PROGRESS_9 = 9 , EVENT_SAY_3 = 1 , EVENT_SAY_6 = 2 , EVENT_SAY_8 = 3 , QUEST_SUNKEN_TREASURE = 665 , QUEST_GOGGLE_BOGGLE = 26050 , NPC_VENGEFUL_SURGE = 2776 , FACTION_SUNKEN_TREASURE = 113 } ; class npc_professor_phizzlethorpe : public CreatureScript { public : npc_professor_phizzlethorpe ( ) : CreatureScript ( " npc _ professor _ phizzlethorpe " ) { } struct npc_professor_phizzlethorpeAI : public npc_escortAI { npc_professor_phizzlethorpeAI ( Creature * creature ) : npc_escortAI ( creature ) { } void Waypoint@@ Reached ( uint32 waypointId ) override { Player * player = GetPlayerForEscort ( ) ; if ( ! player ) return ; switch ( waypointId ) { case 6 : Talk ( SAY_PROGRESS_2 , player ) ; events . ScheduleEvent ( EVENT_SAY_3 , 3000 ) ; break ; case 8 : Talk ( EMOTE_PROGRESS_4 ) ; me -> SummonCreature ( NPC_VENGEFUL_SURGE , - 2065@@ .505f , - 2136.88f , 22.20362f , 1.0f , TEMPSUMMON_CORPSE_DESPAWN , 0 ) ; me -> SummonCreature ( NPC_VENGEFUL_SURGE , - 2059.24@@ 9f , - 2134.88f , 21.51582f , 1.0f , TEMPSUMMON_CORPSE_DESPAWN , 0 ) ; break ; case 11 : Talk ( SAY_PROGRESS_5 , player ) ; events . ScheduleEvent ( EVENT_SAY_6 , 11000 ) ; break ; case 17 : Talk ( SAY_PROGRESS_7 , player ) ; events . ScheduleEvent ( EVENT_SAY_8 , 6000 ) ; break ; } } void JustSummoned ( Creature * summoned ) override { summoned -> AI ( ) -> AttackStart ( me ) ; } void EnterCombat ( Unit * ) override { Talk ( SAY_AGGRO ) ; } void sQuestAccept ( Player * player , Quest const * quest ) override { if ( quest -> GetQuestId ( ) == QUEST_SUNKEN_TREASURE ) { Talk ( SAY_PROGRESS_1 , player ) ; npc_escortAI :: Start ( false , false , player -> GetGUID ( ) , quest ) ; me -> setFaction ( FACTION_SUNKEN_TREASURE ) ; } } void UpdateAI ( uint32 diff ) override { Player * player = GetPlayerForEscort ( ) ; if ( ! player ) return ; events . Update ( diff ) ; while ( uint32 event = events . ExecuteEvent ( ) ) { switch ( event ) { case EVENT_SAY_3 : Talk ( SAY_PROGRESS_3 , player ) ; break ; case EVENT_SAY_6 : Talk ( SAY_PROGRESS_6 , player ) ; SetRun ( ) ; break ; case EVENT_SAY_8 : Talk ( EMOTE_PROGRESS_8 ) ; Talk ( SAY_PROGRESS_9 , player ) ; player -> GroupEventHapp@@ ens ( QUEST_GOGGLE_BOGGLE , me ) ; break ; } } npc_escortAI :: UpdateAI ( diff ) ; } EventMap events ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return new npc_professor_phizzlethorpeAI ( creature ) ; } } ; void AddSC_arathi_highl@@ ands ( ) { new npc_professor_phizzlethorpe ( ) ; } </DOCUMENT>
<DOCUMENT_ID="plexinc@@ /plex-home@@ -theater-publi@@ c/tree/master/plex@@ /Update-Installer/external/@@ win32cpp@@ /tutorial@@ s/Tutorial@@ 8/View.cpp"> # include " view . h " # include " GDI . h " # include " file . h " # include " resource . h " using namespace std ; CView :: CView ( ) : m_PenColor ( RGB ( 0 , 0 , 0 ) ) { m_Brush . CreateSo@@ lidBrush ( RGB ( 255 , 255 , 230 ) ) ; } CView :: ~ CView ( ) { } void CView :: ClearPoints ( ) { m_points . clear ( ) ; Invalidate ( ) ; } void CView :: DrawLine ( int x , int y ) { CClientDC dcClient ( this ) ; dcClient . CreatePen ( PS_SOLID , 1 , m_points . back ( ) . color ) ; dcClient . MoveTo ( m_points . back ( ) . x , m_points . back ( ) . y ) ; dcClient . LineTo ( x , y ) ; } void CView :: OnDraw ( CDC * pDC ) { if ( m_points . size ( ) > 0 ) { bool bDraw = false ; for ( unsigned int i = 0 ; i < m_points . size ( ) ; i ++ ) { pDC -> CreatePen ( PS_SOLID , 1 , m_points [ i ] . color ) ; if ( bDraw ) pDC -> LineTo ( m_points [ i ] . x , m_points [ i ] . y ) ; else pDC -> MoveTo ( m_points [ i ] . x , m_points [ i ] . y ) ; bDraw = m_points [ i ] . PenDown ; } } } void CView :: PreCreate ( CREATESTR@@ UCT & cs ) { cs . dwExStyle = WS_EX_CLIENTEDGE ; } void CView :: PreRegisterClass ( WNDCLASS & wc ) { wc . hbrBackground = m_Brush ; wc . lpszClassName = _T ( " Scribble ▁ Window " ) ; wc . hCursor = :: LoadCursor ( GetApp ( ) -> GetInstanceHandle ( ) , MAKE@@ INTRESOURC@@ E ( IDC_CURSOR1 ) ) ; } BOOL CView :: FileOpen ( LPCTSTR szFilename ) { m_points . clear ( ) ; DWORD nBytesRead ; BOOL bResult = FALSE ; CFile File ; if ( File . Open ( szFilename , OPEN_EXIST@@ ING ) ) { do { PlotPoint pp ; nBytesRead = File . Read ( & pp , sizeof ( PlotPoint ) ) ; if ( nBytesRead == sizeof ( PlotPoint ) ) m_points . push_back ( pp ) ; } while ( nBytesRead == sizeof ( PlotPoint ) ) ; if ( ( 0 != nBytesRead ) || ( m_points . empty ( ) ) ) { m_points . clear ( ) ; :: MessageBox ( 0 , _T ( " Invalid ▁ data ▁ in ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; } else bResult = TRUE ; } else { tString tsErrMsg = _T ( " Failed ▁ to ▁ open ▁ file ▁ " ) ; tsErrMsg += szFilename ; :: MessageBox ( 0 , tsErrMsg . c_str ( ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; } Invalidate ( ) ; return bResult ; } BOOL CView :: FileSave ( LPCTSTR szFilename ) { BOOL bResult = TRUE ; CFile hFile ; if ( ! hFile . Open ( szFilename , CREATE_ALWA@@ YS ) ) { :: MessageBox ( 0 , _T ( " Failed ▁ to ▁ open ▁ file ▁ for ▁ writing " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; } if ( bResult ) { for ( size_t i = 0 ; i < m_points . size ( ) ; ++ i ) { if ( ! hFile . Write ( & m_points [ i ] , sizeof ( PlotPoint ) ) ) { :: MessageBox ( 0 , _T ( " Error ▁ while ▁ writing ▁ to ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; break ; } } if ( hFile . GetLength ( ) != m_points . size ( ) * sizeof ( PlotPoint ) ) { :: MessageBox ( 0 , _T ( " Error ▁ while ▁ writing ▁ to ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; } } return bResult ; } void CView :: SetPen ( COLORREF color ) { m_PenColor = color ; } void CView :: StorePoint ( int x , int y , bool PenDown ) { PlotPoint P1 ; P1 . x = x ; P1 . y = y ; P1 . PenDown = PenDown ; P1 . color = m_PenColor ; m_points . push_back ( P1 ) ; } void CView :: OnLButtonDown ( LPARAM lParam ) { SetCapture ( ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , true ) ; } void CView :: OnLButtonUp ( LPARAM lParam ) { { ReleaseCapture ( ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , false ) ; } } void CView :: OnMouseMove ( WPARAM wParam , LPARAM lParam ) { if ( ( wParam & MK_LBUTTON ) && ( GetCapture ( ) == this ) ) { DrawLine ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , true ) ; } } LRESULT CView :: WndProc ( UINT uMsg , WPARAM wParam , LPARAM lParam ) { switch ( uMsg ) { case WM_LBUTTONDOWN : OnLButtonDown ( lParam ) ; break ; case WM_MOUSE@@ MOVE : OnMouseMove ( wParam , lParam ) ; break ; case WM_LBUTTONUP : OnLButtonUp ( lParam ) ; break ; } return WndProc@@ Default ( uMsg , wParam , lParam ) ; } </DOCUMENT>
<DOCUMENT_ID="Baha/@@ z3/tree/master/src/qe/@@ qe_arith_plu@@ gin.cpp"> # include " qe . h " # include " ast _ pp . h " # include " expr _ safe _ replace . h " # include " bool _ rewriter . h " # include " bv _ decl _ plugin . h " # include " arith _ decl _ plugin . h " # include " arith _ eq _ solver . h " # include " arith _ rewriter . h " # include " th _ rewriter . h " # include " factor _ rewriter . h " # include " obj _ pair _ hashtable . h " # include " nlarith _ util . h " # include " model _ evaluator . h " # include " smt _ kernel . h " namespace qe { class bound { rational m_coeff ; expr_ref m_term ; bool m_is_strict ; public : bound ( ast_manager & m , rational const & n , expr * t , bool is_strict ) : m_coeff ( n ) , m_term ( t , m ) , m_is_strict ( is_strict ) { } bool is_strict ( ) const { return m_is_strict ; } expr * term ( ) const { return m_term . get ( ) ; } rational const & coeff ( ) const { return m_coeff ; } void update ( rational const & k , expr * t ) { m_coeff = k ; m_term = t ; } void pp ( std :: ostream & out , app * x ) { ast_manager & m = m_term . get_manager ( ) ; out << " ( < = ▁ ( + ▁ ( * ▁ " << coeff ( ) << " ▁ " << mk_pp ( x , m ) << " ) ▁ " << mk_pp ( term ( ) , m ) << " ) ▁ 0 ) " ; } } ; typedef rational numeral ; class div_constraint { numeral m_k ; numeral m_a ; expr * m_term ; public : div_constraint ( numeral const & k , numeral const & a , expr * t ) : m_k ( k ) , m_a ( a ) , m_term ( t ) { } numeral const & a ( ) const { return m_a ; } numeral const & k ( ) const { return m_k ; } expr * t ( ) const { return m_term ; } numeral & a_ref ( ) { return m_a ; } numeral & k_ref ( ) { return m_k ; } expr * & t_ref ( ) { return m_term ; } } ; typedef vector < div_constraint > div_constraints ; class arith_qe_util { ast_manager & m ; i_solver_context & m_ctx ; public : arith_util m_arith ; th_rewriter simplify ; private : arith_eq_solver m_arith_solver ; bv_util m_bv ; expr_ref m_zero_i ; expr_ref m_one_i ; expr_ref m_minus_one_i ; expr_ref m_zero_r ; expr_ref m_one_r ; expr_ref m_tmp ; public : expr_safe_replace m_replace ; bool_rewriter m_bool_rewriter ; arith_rewriter m_arith_rewriter ; arith_qe_util ( ast_manager & m , smt_params & p , i_solver_context & ctx ) : m ( m ) , m_ctx ( ctx ) , m_arith ( m ) , simplify ( m ) , m_arith_solver ( m ) , m_bv ( m ) , m_zero_i ( m_arith . mk_numeral ( numeral ( 0 ) , true ) , m ) , m_one_i ( m_arith . mk_numeral ( numeral ( 1 ) , true ) , m ) , m_minus_one_i ( m_arith . mk_numeral ( numeral ( - 1 ) , true ) , m ) , m_zero_r ( m_arith . mk_numeral ( numeral ( 0 ) , false ) , m ) , m_one_r ( m_arith . mk_numeral ( numeral ( 1 ) , false ) , m ) , m_tmp ( m ) , m_replace ( m ) , m_bool_rewriter ( m ) , m_arith_rewriter ( m ) { } ast_manager & get_manager ( ) { return m ; } bool get_coeff ( contains_app & contains_x , expr * p , rational & k , expr_ref & rest ) { app * x = contains_x . x ( ) ; ptr_vector < expr > restl , todo ; todo . push_back ( p ) ; bool found = false ; expr * e1 , * e2 ; while ( ! todo . empty ( ) ) { expr * e = todo . back ( ) ; todo . pop_back ( ) ; if ( m_arith . is_add ( e ) ) { for ( unsigned i = 0 ; i < to_app ( e ) -> get_num_args ( ) ; ++ i ) { todo . push_back ( to_app ( e ) -> get_arg ( i ) ) ; } } else if ( e == x ) { k = numeral ( 1 ) ; found = true ; break ; } else if ( m_arith . is_mul ( e , e1 , e2 ) && e1 == x && m_arith . is_numeral ( e2 , k ) ) { found = true ; break ; } else if ( m_arith . is_mul ( e , e1 , e2 ) && e2 == x && m_arith . is_numeral ( e1 , k ) ) { found = true ; break ; } else { restl . push_back ( e ) ; } } if ( ! found ) { TRACE ( " qe _ verbose " , tout << " Did ▁ not ▁ find : ▁ " << mk_pp ( x , m ) << " ▁ in ▁ " << mk_pp ( p , m ) << " \n " ; ) ; return false ; } while ( ! todo . empty ( ) ) { restl . push_back ( todo . back ( ) ) ; todo . pop_back ( ) ; } if ( restl . empty ( ) ) { rest = mk_zero ( x ) ; } else { rest = m_arith . mk_add ( restl . size ( ) , restl . c_ptr ( ) ) ; } if ( contains_x ( rest ) ) { return false ; } TRACE ( " qe _ verbose " , tout << mk_pp ( p , m ) << " ▁ = ▁ " << " ( + ▁ ( * ▁ " << k << " ▁ " << mk_pp ( x , m ) << " ) ▁ " << mk_pp ( rest , m ) << " ) \n " ; ) ; return true ; } void get_const ( expr * p , rational & k , expr_ref & rest ) { ptr_vector < expr > todo , restl ; todo . push_back ( p ) ; k = numeral ( 0 ) ; while ( ! todo . empty ( ) ) { p = todo . back ( ) ; todo . pop_back ( ) ; if ( m_arith . is_add ( p ) ) { for ( unsigned i = 0 ; i < to_app ( p ) -> get_num_args ( ) ; ++ i ) { todo . push_back ( to_app ( p ) -> get_arg ( i ) ) ; } } else if ( m_arith . is_numeral ( p , k ) ) { break ; } else { restl . push_back ( p ) ; } } while ( ! todo . empty ( ) ) { restl . push_back ( todo . back ( ) ) ; todo . pop_back ( ) ; } if ( restl . empty ( ) ) { rest = mk_zero ( p ) ; } else { rest = m_arith . mk_add ( restl . size ( ) , restl . c_ptr ( ) ) ; } } bool is_neg ( app * e , expr_ref & ne ) { if ( m . is_not ( e ) ) { ne = to_app ( e ) -> get_arg ( 0 ) ; return true ; } return false ; } bool is_le ( app * e , expr_ref & p ) { return is_le_ge_core < 1 > ( e , p ) ; } bool is_ge ( app * e , expr_ref & p ) { return is_le_ge_core < 0 > ( e , p ) ; } bool is_lt ( app * e , expr_ref & p ) { numeral k ; expr * a1 , * a2 ; if ( m_arith . is_lt ( e , a1 , a2 ) || m_arith . is_gt ( e , a2 , a1 ) ) { p = a1 ; if ( m_arith . is_numeral ( a2 , k ) && k . is_zero ( ) ) { return true ; } } else { return false ; } p = mk_sub ( p , a2 ) ; simplify ( p ) ; return true ; } bool is_divides ( app * e , numeral & k , expr_ref & p ) { expr * e1 , * e2 ; if ( ! m . is_eq ( e , e1 , e2 ) ) { return false ; } return is_divides ( e1 , e2 , k , p ) || is_divides ( e2 , e1 , k , p ) ; } bool is_divides ( expr * e1 , expr * e2 , numeral & k , expr_ref & p ) { if ( m_arith . is_mod ( e2 ) && m_arith . is_numeral ( e1 , k ) && k . is_zero ( ) && m_arith . is_numeral ( to_app ( e2 ) -> get_arg ( 1 ) , k ) ) { p = to_app ( e2 ) -> get_arg ( 0 ) ; return true ; } return false ; } bool is_not_divides ( app * e , app_ref & n , numeral & k , expr_ref & p ) { if ( ! m . is_not ( e ) ) { return false ; } if ( ! is_app ( to_app ( e ) -> get_arg ( 0 ) ) ) { return false ; } n = to_app ( to_app ( e ) -> get_arg ( 0 ) ) ; return is_divides ( n , k , p ) ; } bool is_real ( app * x ) const { return m_arith . is_real ( x ) ; } template < bool is_strict > void mk_bound_aux ( rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { SASSERT ( a . is_neg ( ) == b . is_neg ( ) ) ; expr_ref tt ( t , m ) , ss ( s , m ) , e ( m ) ; rational abs_a ( a ) ; rational abs_b ( b ) ; if ( abs_a . is_neg ( ) ) abs_a . neg ( ) ; if ( abs_b . is_neg ( ) ) abs_b . neg ( ) ; ss = mk_mul ( abs_a , ss ) ; tt = mk_mul ( abs_b , tt ) ; if ( a . is_neg ( ) ) { e = mk_sub ( tt , ss ) ; if ( is_strict ) { if ( m_arith . is_int ( e ) ) { e = mk_add ( e , m_one_i ) ; mk_le ( e , result ) ; } else { mk_lt ( e , result ) ; } } else { mk_le ( e , result ) ; } } else { e = mk_sub ( ss , tt ) ; if ( is_strict ) { if ( m_arith . is_int ( e ) ) { e = mk_add ( e , m_one_i ) ; mk_le ( e , result ) ; } else { mk_lt ( e , result ) ; } } else { mk_le ( e , result ) ; } } } void mk_bound ( rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { mk_bound_aux < false > ( a , t , b , s , result ) ; } void mk_strict_bound ( rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { mk_bound_aux < true > ( a , t , b , s , result ) ; } void mk_divides ( numeral n , expr * e , expr_ref & result ) { SASSERT ( n . is_int ( ) ) ; expr_ref tmp1 ( e , m ) , tmp2 ( m ) ; simplify ( tmp1 ) ; m_arith_rewriter . mk_mod ( tmp1 , mk_numeral ( n ) , tmp2 ) ; m_bool_rewriter . mk_eq ( m_zero_i , tmp2 , result ) ; } void mk_div ( expr * a , numeral const & k , expr_ref & result ) { result = m_arith . mk_div ( a , m_arith . mk_numeral ( k , false ) ) ; simplify ( result ) ; } expr * mk_numeral ( numeral const & k , bool is_int = true ) { return m_arith . mk_numeral ( k , is_int ) ; } expr * mk_numeral ( int k , bool is_int ) { return mk_numeral ( numeral ( k ) , is_int ) ; } expr * mk_uminus ( expr * e ) { return m_arith . mk_uminus ( e ) ; } expr * mk_abs ( expr * e ) { rational val ; if ( m_arith . is_numeral ( e , val ) ) { if ( val . is_neg ( ) ) { return m_arith . mk_uminus ( e ) ; } else { return e ; } } else { return m . mk_ite ( m_arith . mk_le ( mk_zero ( e ) , e ) , e , m_arith . mk_uminus ( e ) ) ; } } template < bool is_max > expr_ref mk_min_max ( unsigned num_args , expr * const * args ) { SASSERT ( num_args > 0 ) ; if ( num_args == 1 ) { return expr_ref ( args [ 0 ] , m ) ; } else { expr_ref e2 = mk_min_max < is_max > ( num_args - 1 , args + 1 ) ; expr * e1 = args [ 0 ] ; expr * cmp = is_max ? m_arith . mk_le ( e1 , e2 ) : m_arith . mk_le ( e2 , e1 ) ; return expr_ref ( m . mk_ite ( cmp , e2 , e1 ) , m ) ; } } expr_ref mk_max ( unsigned num_args , expr * const * args ) { return mk_min_max < true > ( num_args , args ) ; } expr_ref mk_min ( unsigned num_args , expr * const * args ) { return mk_min_max < false > ( num_args , args ) ; } expr * mk_mul ( expr * a , expr * b ) { return m_arith . mk_mul ( a , b ) ; } expr * mk_add ( expr * a , expr * b ) { return m_arith . mk_add ( a , b ) ; } expr * mk_sub ( expr * a , expr * b ) { return m_arith . mk_sub ( a , b ) ; } expr * mk_mul ( numeral const & a , expr * b ) { if ( a . is_one ( ) ) return b ; return m_arith . mk_mul ( mk_numeral ( a , m_arith . is_int ( b ) ) , b ) ; } expr * mk_zero ( sort * s ) { return m_arith . is_int ( s ) ? m_zero_i : m_zero_r ; } expr * mk_zero ( expr * e ) { return m_arith . is_int ( e ) ? m_zero_i : m_zero_r ; } expr * mk_one ( sort * s ) { return m_arith . is_int ( s ) ? m_one_i : m_one_r ; } expr * mk_one ( expr * e ) { return m_arith . is_int ( e ) ? m_one_i : m_one_r ; } void mk_le ( expr * e , expr_ref & result ) { expr_ref tmp ( e , m ) ; simplify ( tmp ) ; m_arith_rewriter . mk_le ( tmp , mk_zero ( e ) , result ) ; } void mk_lt ( expr * e , expr_ref & result ) { rational r ; if ( m_arith . is_numeral ( e , r ) ) { if ( r . is_neg ( ) ) { result = m . mk_true ( ) ; } else { result = m . mk_false ( ) ; } } else if ( m_arith . is_int ( e ) ) { result = m_arith . mk_le ( e , m_minus_one_i ) ; } else { result = m . mk_not ( m_arith . mk_le ( mk_zero ( e ) , e ) ) ; } simplify ( result ) ; TRACE ( " qe _ verbose " , tout << " mk _ lt ▁ " << mk_pp ( result , m ) << " \n " ; ) ; } void mk_eq ( rational const & a , app * x , expr * t , expr_ref & result ) { result = m_arith . mk_eq ( mk_add ( mk_mul ( a , x ) , t ) , mk_zero ( x ) ) ; } void mk_and ( unsigned sz , expr * const * args , expr_ref & result ) { m_bool_rewriter . mk_and ( sz , args , result ) ; } void mk_and ( expr * e1 , expr * e2 , expr_ref & result ) { m_bool_rewriter . mk_and ( e1 , e2 , result ) ; } void add_and ( expr * e , ptr_vector < expr > & conjs ) { if ( m . is_and ( e ) ) { conjs . append ( to_app ( e ) -> get_num_args ( ) , to_app ( e ) -> get_args ( ) ) ; } else { conjs . push_back ( e ) ; } } void mk_flat_and ( expr * e1 , expr * e2 , expr_ref & result ) { ptr_vector < expr > conjs ; add_and ( e1 , conjs ) ; add_and ( e2 , conjs ) ; m_bool_rewriter . mk_and ( conjs . size ( ) , conjs . c_ptr ( ) , result ) ; } void mk_or ( unsigned sz , expr * const * args , expr_ref & result ) { m_bool_rewriter . mk_or ( sz , args , result ) ; } void mk_or ( expr * e1 , expr * e2 , expr_ref & result ) { m_bool_rewriter . mk_or ( e1 , e2 , result ) ; } void mk_resolve ( app * x , bool is_strict , rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { rational abs_a ( abs ( a ) ) , abs_b ( abs ( b ) ) ; SASSERT ( a . is_neg ( ) == b . is_pos ( ) ) ; SASSERT ( ! is_strict || ( abs_a . is_one ( ) && abs_b . is_one ( ) ) ) ; expr_ref bt ( mk_mul ( abs_b , t ) , m ) ; expr_ref as ( mk_mul ( abs_a , s ) , m ) ; expr_ref as_bt ( mk_add ( as , bt ) , m ) ; if ( is_strict ) { mk_lt ( as_bt , result ) ; } else { mk_le ( as_bt , result ) ; } if ( ! abs_a . is_one ( ) && ! abs_b . is_one ( ) ) { SASSERT ( ! is_strict ) ; SASSERT ( abs_a > rational :: one ( ) && abs_b > rational :: one ( ) ) ; expr_ref slack ( mk_numeral ( ( abs_a - numeral ( 1 ) ) * ( abs_b - numeral ( 1 ) ) , true ) , m ) ; expr_ref result1 ( m ) , result2 ( m ) ; expr_ref as_bt_le_0 ( result , m ) , tmp2 ( m ) , asz_bt_le_0 ( m ) , tmp3 ( m ) , tmp4 ( m ) ; expr_ref b_divides_sz ( m ) ; tmp2 = m_arith . mk_add ( as_bt , slack ) ; mk_le ( tmp2 , result1 ) ; rational a1 = a , b1 = b ; if ( abs_a < abs_b ) { std :: swap ( abs_a , abs_b ) ; std :: swap ( a1 , b1 ) ; std :: swap ( s , t ) ; std :: swap ( as , bt ) ; } SASSERT ( abs_a >= abs_b ) ; expr_ref sz ( mk_add ( s , x ) , m ) ; if ( b1 . is_pos ( ) ) { sz = m_arith . mk_uminus ( sz ) ; } tmp4 = mk_add ( mk_mul ( a1 , sz ) , bt ) ; mk_le ( tmp4 , asz_bt_le_0 ) ; if ( to_app ( asz_bt_le_0 ) -> get_arg ( 0 ) == x && m_arith . is_zero ( to_app ( asz_bt_le_0 ) -> get_arg ( 1 ) ) ) { mk_divides ( abs_b , s , tmp2 ) ; } else { mk_divides ( abs_b , sz , b_divides_sz ) ; mk_and ( b_divides_sz , asz_bt_le_0 , tmp4 ) ; mk_big_or ( abs_b - numeral ( 2 ) , x , tmp4 , tmp2 ) ; TRACE ( " qe " , tout << " b ▁ | ▁ s ▁ + ▁ z : ▁ " << mk_pp ( b_divides_sz , m ) << " \n " ; tout << " a ( s + z ) ▁ + ▁ bt ▁ < = ▁ 0 : ▁ " << mk_pp ( asz_bt_le_0 , m ) << " \n " ; ) ; } mk_flat_and ( as_bt_le_0 , tmp2 , result2 ) ; mk_or ( result1 , result2 , result ) ; simplify ( result ) ; } TRACE ( " qe " , { tout << ( is_strict ? " strict " : " non - strict " ) << " \n " ; bound ( m , a , t , false ) . pp ( tout , x ) ; tout << " \n " ; bound ( m , b , s , false ) . pp ( tout , x ) ; tout << " \n " ; tout << mk_pp ( result , m ) << " \n " ; } ) ; } struct mul_lt { arith_util & u ; mul_lt ( arith_qe_util & u ) : u ( u . m_arith ) { } bool operator ( ) ( expr * n1 , expr * n2 ) const { expr * x , * y ; if ( u . is_mul ( n1 , x , y ) && u . is_numeral ( x ) ) { n1 = y ; } if ( u . is_mul ( n2 , x , y ) && u . is_numeral ( x ) ) { n2 = y ; } return n1 -> get_id ( ) < n2 -> get_id ( ) ; } } ; void normalize_sum ( expr_ref & p ) { simplify ( p ) ; if ( ! m_arith . is_add ( p ) ) { return ; } unsigned sz = to_app ( p ) -> get_num_args ( ) ; ptr_buffer < expr > args ; for ( unsigned i = 0 ; i < sz ; ++ i ) { args . push_back ( to_app ( p ) -> get_arg ( i ) ) ; } std :: sort ( args . begin ( ) , args . end ( ) , mul_lt ( * this ) ) ; p = m_arith . mk_add ( args . size ( ) , args . c_ptr ( ) ) ; } void pp_div ( std :: ostream & out , app * x , div_constraint const & div ) { out << div . k ( ) << " ▁ | ▁ ( " << div . a ( ) << " * " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( div . t ( ) , m ) << " ) ▁ " ; } void pp_divs ( std :: ostream & out , app * x , div_constraints const & divs ) { for ( unsigned i = 0 ; i < divs . size ( ) ; ++ i ) { pp_div ( out , x , divs [ i ] ) ; out << " ▁ " ; } } bool mk_atom ( expr * e , bool p , expr_ref & result ) { if ( ! is_app ( e ) ) { return false ; } app * a = to_app ( e ) ; expr_ref t1 ( m ) , t2 ( m ) ; expr_ref tmp1 ( m ) , tmp2 ( m ) ; rational k ; expr * a0 , * a1 ; if ( p && is_divides ( a , k , tmp1 ) ) { result = e ; } else if ( ! p && is_divides ( a , k , tmp1 ) ) { m_bool_rewriter . mk_not ( e , result ) ; } else if ( p && m . is_eq ( e , a0 , a1 ) && is_arith ( a0 ) ) { t1 = mk_sub ( a0 , a1 ) ; simplify ( t1 ) ; t2 = mk_sub ( a1 , a0 ) ; simplify ( t2 ) ; mk_le ( t1 , tmp1 ) ; mk_le ( t2 , tmp2 ) ; mk_and ( tmp1 , tmp2 , result ) ; } else if ( ! p && m . is_eq ( e , a0 , a1 ) && m_arith . is_int ( a0 ) ) { tmp1 = mk_sub ( a0 , a1 ) ; t1 = mk_add ( mk_one ( a0 ) , tmp1 ) ; simplify ( t1 ) ; t2 = mk_sub ( mk_one ( a0 ) , tmp1 ) ; simplify ( t2 ) ; mk_le ( t1 , tmp1 ) ; mk_le ( t2 , tmp2 ) ; mk_or ( tmp1 , tmp2 , result ) ; } else if ( ! p && m . is_eq ( e , a0 , a1 ) && m_arith . is_real ( a0 ) ) { t1 = mk_sub ( a0 , a1 ) ; simplify ( t1 ) ; t2 = mk_sub ( a1 , a0 ) ; simplify ( t2 ) ; mk_lt ( t1 , tmp1 ) ; mk_lt ( t2 , tmp2 ) ; mk_or ( tmp1 , tmp2 , result ) ; } else if ( ! p && ( m_arith . is_le ( e , a0 , a1 ) || m_arith . is_ge ( e , a1 , a0 ) ) ) { tmp1 = mk_sub ( a1 , a0 ) ; mk_lt ( tmp1 , result ) ; } else if ( p && ( m_arith . is_le ( e ) || m_arith . is_ge ( e ) ) ) { result = e ; } else if ( p && ( m_arith . is_lt ( e , a0 , a1 ) || m_arith . is_gt ( e , a1 , a0 ) ) ) { tmp1 = mk_sub ( a0 , a1 ) ; mk_lt ( tmp1 , result ) ; } else if ( ! p && ( m_arith . is_lt ( e , a0 , a1 ) || m_arith . is_gt ( e , a1 , a0 ) ) ) { tmp1 = mk_sub ( a1 , a0 ) ; mk_le ( tmp1 , result ) ; } else { return false ; } TRACE ( " qe _ verbose " , tout << " Atom : ▁ " << mk_pp ( result , m ) << " \n " ; ) ; return true ; } void mk_bounded_var ( rational const & n , app_ref & z_bv , app_ref & z ) { rational two ( 2 ) , b ( n ) ; unsigned sz = 0 ; do { ++ sz ; b = div ( b , two ) ; } while ( b . is_pos ( ) ) ; sort * s = m_bv . mk_sort ( sz ) ; z_bv = m . mk_fresh_const ( " z " , s ) ; expr_ref tmp ( m ) ; z = m_bv . mk_bv@@ 2int ( z_bv ) ; } bool solve ( conj_enum & conjs , expr * fml ) { expr_ref_vector eqs ( m ) ; extract_equalities ( conjs , eqs ) ; return reduce_equations ( eqs . size ( ) , eqs . c_ptr ( ) , fml ) ; } void extract_equalities ( conj_enum & conjs , expr_ref_vector & eqs ) { obj_hashtable < expr > leqs ; expr_ref_vector trail ( m ) ; expr_ref tmp1 ( m ) , tmp2 ( m ) ; expr * a0 , * a1 ; eqs . reset ( ) ; conj_enum :: iterator it = conjs . begin ( ) , end = conjs . end ( ) ; for ( ; it != end ; ++ it ) { expr * e = * it ; bool is_leq = false ; if ( m . is_eq ( e , a0 , a1 ) && is_arith ( a0 ) ) { m_arith_rewriter . mk_sub ( a0 , a1 , tmp1 ) ; simplify ( tmp1 ) ; eqs . push_back ( tmp1 ) ; } else if ( m_arith . is_le ( e , a0 , a1 ) || m_arith . is_ge ( e , a1 , a0 ) ) { m_arith_rewriter . mk_sub ( a0 , a1 , tmp1 ) ; is_leq = true ; } else { } if ( is_leq ) { normalize_sum ( tmp1 ) ; tmp2 = m_arith . mk_uminus ( tmp1 ) ; normalize_sum ( tmp2 ) ; if ( leqs . contains ( tmp2 ) ) { eqs . push_back ( tmp1 ) ; TRACE ( " qe " , tout << " found : ▁ ▁ " << mk_pp ( tmp1 , m ) << " \n " ; ) ; } else { trail . push_back ( tmp1 ) ; leqs . insert ( tmp1 ) ; TRACE ( " qe _ verbose " , tout << " insert : ▁ " << mk_pp ( tmp1 , m ) << " \n " ; ) ; } } } } private : template < unsigned IS_LE > bool is_le_ge_core ( app * e , expr_ref & p ) { numeral k ; expr_ref tmp ( m ) ; expr * a2 ; if ( m_arith . is_le ( e ) ) { p = e -> get_arg ( 1 - IS_LE ) ; a2 = e -> get_arg ( IS_LE ) ; if ( m_arith . is_numeral ( a2 , k ) && k . is_zero ( ) ) { return true ; } } else if ( m_arith . is_ge ( e ) ) { p = e -> get_arg ( IS_LE ) ; a2 = e -> get_arg ( 1 - IS_LE ) ; if ( m_arith . is_numeral ( a2 , k ) && k . is_zero ( ) ) { return true ; } } else { return false ; } p = mk_sub ( p , a2 ) ; simplify ( p ) ; return true ; } bool is_arith ( expr * e ) { return m_arith . is_int ( e ) || m_arith . is_real ( e ) ; } void mk_big_or ( numeral up , app * x , expr * body , expr_ref & result ) { TRACE ( " qe " , tout << mk_pp ( x , m ) << " ▁ " << mk_pp ( body , m ) << " \n " ; ) ; if ( numeral ( 1 ) >= up ) { mk_big_or_blast ( up , x , body , result ) ; } else { mk_big_or_symbolic_blast ( up , x , body , result ) ; } } void mk_big_or_blast ( numeral up , app * x , expr * body , expr_ref & result ) { expr_ref_vector ors ( m ) ; numeral index ( 0 ) ; while ( index <= up ) { expr * n = mk_numeral ( index ) ; result = body ; m_replace . apply_substitution ( x , n , result ) ; ors . push_back ( result ) ; ++ index ; } mk_or ( ors . size ( ) , ors . c_ptr ( ) , result ) ; TRACE ( " qe " , tout << " [ 0 ▁ " << up << " ] ▁ " << mk_pp ( x , m ) << " \n " << mk_pp ( body , m ) << " \n " << mk_pp ( result , m ) << " \n " ; ) ; } void mk_big_or_symbolic ( numeral up , app * x , expr * body , expr_ref & result ) { app_ref z_bv ( m ) ; mk_big_or_symbolic ( up , x , body , z_bv , result ) ; m_ctx . add_var ( z_bv ) ; } void mk_big_or_symbolic_blast ( numeral up , app * x , expr * body , expr_ref & result ) { app_ref z_bv ( m ) ; mk_big_or_symbolic ( up , x , body , z_bv , result ) ; m_ctx . blast_or ( z_bv , result ) ; } void mk_big_or_symbolic ( numeral up , app * x , expr * body , app_ref & z_bv , expr_ref & result ) { expr * e1 = m_arith . mk_le ( x , m_arith . mk_numeral ( up , true ) ) ; mk_flat_and ( e1 , body , result ) ; app_ref z ( m ) ; mk_bounded_var ( up , z_bv , z ) ; m_replace . apply_substitution ( x , z , result ) ; } bool isolate_x ( expr * p , app * x , contains_app & contains_x , numeral & coeff ) { numeral k ; while ( m_arith . is_add ( p ) ) { bool found_x = false ; expr * next_p = 0 ; for ( unsigned i = 0 ; i < to_app ( p ) -> get_num_args ( ) ; ++ i ) { expr * arg = to_app ( p ) -> get_arg ( i ) ; if ( contains_x ( arg ) ) { if ( found_x ) { return false ; } found_x = true ; next_p = arg ; } } if ( ! next_p ) { return false ; } p = next_p ; } expr * e1 , * e2 ; if ( p == x ) { coeff = numeral ( 1 ) ; return true ; } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e1 , k ) && e2 == x ) { coeff = k ; return true ; } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e2 , k ) && e1 == x ) { coeff = k ; return true ; } return false ; } bool reduce_equations ( unsigned num_eqs , expr * const * eqs , expr * fml ) { for ( unsigned i = 0 ; i < num_eqs ; ++ i ) { if ( reduce_equation ( eqs [ i ] , fml ) ) { return true ; } } return false ; } bool solve_singular ( unsigned var_idx , expr * p , expr * fml ) { rational k ; expr_ref e ( m ) , tmp ( m ) ; app * x = m_ctx . get_var ( var_idx ) ; if ( ! isolate_x ( p , x , m_ctx . contains ( var_idx ) , k ) ) { return false ; } if ( m_arith . is_int ( x ) && ! ( abs ( k ) . is_one ( ) ) ) { return false ; } if ( abs ( k ) . is_one ( ) ) { if ( k . is_neg ( ) ) { e = m_arith . mk_add ( p , x ) ; } else { e = m_arith . mk_sub ( x , p ) ; } } else { SASSERT ( ! m_arith . is_int ( x ) ) ; expr * ke = m_arith . mk_numeral ( - k , false ) ; tmp = m_arith . mk_mul ( ke , x ) ; tmp = m_arith . mk_add ( p , tmp ) ; e = m_arith . mk_div ( tmp , ke ) ; } TRACE ( " qe " , tout << " is ▁ singular : \n " << mk_pp ( p , m ) << " \n " << mk_pp ( fml , m ) << " \n " << mk_pp ( x , m ) << " ▁ = ▁ " << mk_pp ( e , m ) << " \n " ; ) ; expr_ref result ( fml , m ) ; m_replace . apply_substitution ( x , e , result ) ; simplify ( result ) ; TRACE ( " qe " , tout << " singular ▁ solved : \n " << mk_pp ( result , m ) << " \n " ; ) ; m_ctx . elim_var ( var_idx , result , e ) ; return true ; } bool solve_singular ( expr * p , expr * fml ) { unsigned num_vars = m_ctx . get_num_vars ( ) ; for ( unsigned i = 0 ; i < num_vars ; ++ i ) { if ( solve_singular ( i , p , fml ) ) { return true ; } } return false ; } bool solve_linear ( expr * p , expr * fml ) { vector < numeral > values ; unsigned num_vars = m_ctx . get_num_vars ( ) ; app * const * vars_ptr = m_ctx . get_vars ( ) ; if ( ! is_linear ( p , num_vars , vars_ptr , values ) ) { return false ; } TRACE ( " qe " , tout << " is ▁ linear : ▁ " << mk_pp ( p , m ) << " \n " ; ) ; SASSERT ( values . size ( ) == num_vars + 1 ) ; SASSERT ( num_vars > 0 ) ; unsigned index ; bool is_aux ; VERIFY ( m_arith_solver . solve_integer_@@ equation ( values , index , is_aux ) ) ; SASSERT ( 1 <= index && index <= num_vars ) ; app_ref x ( m_ctx . get_var ( index - 1 ) , m ) ; app_ref z ( m ) ; expr_ref p1 ( m ) ; if ( is_aux ) { SASSERT ( values [ index ] >= rational ( 3 ) ) ; z = m . mk_fresh_const ( " x " , m_arith . mk_int ( ) ) ; m_ctx . add_var ( z ) ; p1 = m_arith . mk_mul ( m_arith . mk_numeral ( values [ index ] , true ) , z ) ; } else { p1 = m_arith . mk_numeral ( numeral ( 0 ) , true ) ; } for ( unsigned i = 1 ; i <= num_vars ; ++ i ) { numeral k = values [ i ] ; if ( ! k . is_zero ( ) && i != index ) { p1 = m_arith . mk_add ( p1 , m_arith . mk_mul ( m_arith . mk_numeral ( k , true ) , m_ctx . get_var ( i - 1 ) ) ) ; } } p1 = m_arith . mk_add ( p1 , m_arith . mk_numeral ( values [ 0 ] , true ) ) ; TRACE ( " qe " , tout << " is ▁ linear : \n " << mk_pp ( fml , m ) << " \n " << mk_pp ( p , m ) << " \n " << mk_pp ( x , m ) << " ▁ = ▁ " << mk_pp ( p1 , m ) << " \n " ; tout << values [ 0 ] << " ▁ + ▁ " ; for ( unsigned i = 0 ; i < num_vars ; ++ i ) { tout << " ▁ + ▁ " << values [ i + 1 ] << " ▁ * ▁ " << mk_pp ( m_ctx . get_var ( i ) , m ) << " ▁ " ; } tout << " ▁ = ▁ 0 \n " ; ) ; expr_ref result ( fml , m ) ; m_replace . apply_substitution ( x , p1 , result ) ; simplify ( result ) ; m_ctx . elim_var ( index - 1 , result , p1 ) ; TRACE ( " qe " , tout << " Reduced : ▁ " << mk_pp ( result , m ) << " \n " ; ) ; return true ; } bool reduce_equation ( expr * p , expr * fml ) { numeral k ; if ( m_arith . is_numeral ( p , k ) && k . is_zero ( ) ) { return false ; } return solve_singular ( p , fml ) || solve_linear ( p , fml ) ; } bool find_variable ( expr * p , unsigned num_vars , app * const * vars , numeral * values , numeral const & k ) { if ( ! is_app ( p ) || to_app ( p ) -> get_num_args ( ) > 0 ) { return false ; } for ( unsigned i = 0 ; i < num_vars ; ++ i ) { if ( p == vars [ i ] ) { values [ i ] += k ; return true ; } } return false ; } bool is_linear ( expr * p , unsigned num_vars , app * const * vars , vector < numeral > & values ) { if ( num_vars == 0 ) { return false ; } values . reset ( ) ; for ( unsigned i = 0 ; i <= num_vars ; ++ i ) { values . push_back ( numeral ( 0 ) ) ; } numeral * vars_ptr = values . c_ptr ( ) + 1 ; ptr_vector < expr > todo ; numeral k ; expr * e1 , * e2 ; todo . push_back ( p ) ; while ( ! todo . empty ( ) ) { p = todo . back ( ) ; todo . pop_back ( ) ; if ( m_arith . is_add ( p ) ) { for ( unsigned i = 0 ; i < to_app ( p ) -> get_num_args ( ) ; ++ i ) { todo . push_back ( to_app ( p ) -> get_arg ( i ) ) ; } } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e1 , k ) && find_variable ( e2 , num_vars , vars , vars_ptr , k ) ) { } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e2 , k ) && find_variable ( e1 , num_vars , vars , vars_ptr , k ) ) { } else if ( find_variable ( p , num_vars , vars , vars_ptr , k ) ) { } else if ( m_arith . is_numeral ( p , k ) ) { values [ 0 ] += k ; } else { TRACE ( " qe _ verbose " , tout << " non - linear ▁ " << mk_pp ( p , m ) << " \n " ; ) ; return false ; } } return true ; } } ; class bounds_proc { arith_qe_util & m_util ; ast_mark m_mark ; expr_ref_vector m_le_terms , m_ge_terms , m_lt_terms , m_gt_terms ; vector < rational > m_le_coeffs , m_ge_coeffs , m_lt_coeffs , m_gt_coeffs ; app_ref_vector m_le_atoms , m_ge_atoms , m_lt_atoms , m_gt_atoms ; expr_ref_vector m_div_terms ; vector < rational > m_div_coeffs , m_div_divisors ; app_ref_vector m_div_atoms ; app_ref m_div_z ; expr_ref_vector m_nested_div_terms ; vector < rational > m_nested_div_coeffs , m_nested_div_divisors ; app_ref_vector m_nested_div_atoms ; app_ref_vector m_nested_div_z ; rational m_d ; public : bounds_proc ( arith_qe_util & u ) : m_util ( u ) , m_le_terms ( u . get_manager ( ) ) , m_ge_terms ( u . get_manager ( ) ) , m_lt_terms ( u . get_manager ( ) ) , m_gt_terms ( u . get_manager ( ) ) , m_le_atoms ( u . get_manager ( ) ) , m_ge_atoms ( u . get_manager ( ) ) , m_lt_atoms ( u . get_manager ( ) ) , m_gt_atoms ( u . get_manager ( ) ) , m_div_terms ( u . get_manager ( ) ) , m_div_atoms ( u . get_manager ( ) ) , m_div_z ( u . get_manager ( ) ) , m_nested_div_terms ( u . get_manager ( ) ) , m_nested_div_atoms ( u . get_manager ( ) ) , m_nested_div_z ( u . get_manager ( ) ) { reset ( ) ; } bool get_bound ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; app * x = contains_x . x ( ) ; if ( m_mark . is_marked ( a ) || get_le_bound ( contains_x , a ) || get_lt_bound ( contains_x , a ) || get_divides ( contains_x , a ) || get_nested_divs ( contains_x , a ) ) { TRACE ( " qe _ verbose " , tout << " Bound ▁ for ▁ " << mk_pp ( x , m ) << " ▁ within ▁ " << mk_pp ( a , m ) << " \n " ; ) ; m_mark . mark ( a , true ) ; return true ; } else { TRACE ( " qe " , tout << " No ▁ bound ▁ for ▁ " << mk_pp ( x , m ) << " ▁ within ▁ " << mk_pp ( a , m ) << " \n " ; ) ; return false ; } } unsigned lt_size ( ) { return m_lt_terms . size ( ) ; } unsigned le_size ( ) { return m_le_terms . size ( ) ; } unsigned gt_size ( ) { return m_gt_terms . size ( ) ; } unsigned ge_size ( ) { return m_ge_terms . size ( ) ; } unsigned t_size ( bool is_l ) { return is_l ? lt_size ( ) : gt_size ( ) ; } unsigned e_size ( bool is_l ) { return is_l ? le_size ( ) : ge_size ( ) ; } unsigned size ( bool is_strict , bool is_l ) { return is_strict ? t_size ( is_l ) : e_size ( is_l ) ; } expr * const * lt ( ) { return m_lt_terms . c_ptr ( ) ; } expr * const * le ( ) { return m_le_terms . c_ptr ( ) ; } expr * const * gt ( ) { return m_gt_terms . c_ptr ( ) ; } expr * const * ge ( ) { return m_ge_terms . c_ptr ( ) ; } expr * const * t ( bool is_l ) { return is_l ? lt ( ) : gt ( ) ; } expr * const * e ( bool is_l ) { return is_l ? le ( ) : ge ( ) ; } expr * const * exprs ( bool is_strict , bool is_l ) { return is_strict ? t ( is_l ) : e ( is_l ) ; } rational const * lt_coeffs ( ) { return m_lt_coeffs . c_ptr ( ) ; } rational const * le_coeffs ( ) { return m_le_coeffs . c_ptr ( ) ; } rational const * gt_coeffs ( ) { return m_gt_coeffs . c_ptr ( ) ; } rational const * ge_coeffs ( ) { return m_ge_coeffs . c_ptr ( ) ; } rational const * t_coeffs ( bool is_l ) { return is_l ? lt_coeffs ( ) : gt_coeffs ( ) ; } rational const * e_coeffs ( bool is_l ) { return is_l ? le_coeffs ( ) : ge_coeffs ( ) ; } rational const * coeffs ( bool is_strict , bool is_l ) { return is_strict ? t_coeffs ( is_l ) : e_coeffs ( is_l ) ; } app * const * lt_atoms ( ) { return m_lt_atoms . c_ptr ( ) ; } app * const * le_atoms ( ) { return m_le_atoms . c_ptr ( ) ; } app * const * gt_atoms ( ) { return m_gt_atoms . c_ptr ( ) ; } app * const * ge_atoms ( ) { return m_ge_atoms . c_ptr ( ) ; } app * const * t_atoms ( bool is_l ) { return is_l ? lt_atoms ( ) : gt_atoms ( ) ; } app * const * e_atoms ( bool is_l ) { return is_l ? le_atoms ( ) : ge_atoms ( ) ; } app * const * atoms ( bool is_strict , bool is_l ) { return is_strict ? t_atoms ( is_l ) : e_atoms ( is_l ) ; } unsigned div_size ( ) const { return m_div_terms . size ( ) ; } app * const * div_atoms ( ) { return m_div_atoms . c_ptr ( ) ; } rational const * div_coeffs ( ) { return m_div_coeffs . c_ptr ( ) ; } expr * const * div_terms ( ) { return m_div_terms . c_ptr ( ) ; } rational const * divisors ( ) { return m_div_divisors . c_ptr ( ) ; } bool div_z ( rational & d , app_ref & z_bv , app_ref & z ) { if ( m_div_z . get ( ) ) { z = m_div_z ; z_bv = to_app ( z -> get_arg ( 0 ) ) ; d = m_d ; return true ; } if ( m_div_terms . empty ( ) && m_nested_div_terms . empty ( ) ) { return false ; } m_d = rational ( 1 ) ; for ( unsigned i = 0 ; i < m_div_divisors . size ( ) ; ++ i ) { m_d = lcm ( m_div_divisors [ i ] , m_d ) ; } for ( unsigned i = 0 ; i < m_nested_div_divisors . size ( ) ; ++ i ) { m_d = lcm ( m_nested_div_divisors [ i ] , m_d ) ; } if ( abs ( m_d ) . is_one ( ) ) { return false ; } m_util . mk_bounded_var ( m_d , z_bv , m_div_z ) ; z = m_div_z ; d = m_d ; return true ; } unsigned nested_div_size ( ) const { return m_nested_div_terms . size ( ) ; } app * nested_div_atom ( unsigned idx ) { return m_nested_div_atoms [ idx ] . get ( ) ; } rational const & nested_div_coeff ( unsigned idx ) { return m_nested_div_coeffs [ idx ] ; } expr * nested_div_term ( unsigned idx ) { return m_nested_div_terms [ idx ] . get ( ) ; } rational const & nested_divisor ( unsigned idx ) { return m_nested_div_divisors [ idx ] ; } app * nested_div_z ( unsigned idx ) { return m_nested_div_z [ idx ] . get ( ) ; } app * nested_div_z_bv ( unsigned idx ) { return to_app ( m_nested_div_z [ idx ] -> get_arg ( 0 ) ) ; } void reset ( ) { m_lt_terms . reset ( ) ; m_gt_terms . reset ( ) ; m_ge_terms . reset ( ) ; m_le_terms . reset ( ) ; m_gt_coeffs . reset ( ) ; m_lt_coeffs . reset ( ) ; m_ge_coeffs . reset ( ) ; m_le_coeffs . reset ( ) ; m_lt_atoms . reset ( ) ; m_gt_atoms . reset ( ) ; m_le_atoms . reset ( ) ; m_ge_atoms . reset ( ) ; m_div_terms . reset ( ) ; m_div_coeffs . reset ( ) ; m_div_divisors . reset ( ) ; m_div_atoms . reset ( ) ; m_div_z = 0 ; m_nested_div_terms . reset ( ) ; m_nested_div_coeffs . reset ( ) ; m_nested_div_divisors . reset ( ) ; m_nested_div_atoms . reset ( ) ; m_nested_div_z . reset ( ) ; } private : bool get_nested_divs ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; ptr_vector < expr > todo ; todo . push_back ( a ) ; rational k1 , k2 ; expr_ref rest ( m ) ; while ( ! todo . empty ( ) ) { expr * e = todo . back ( ) ; todo . pop_back ( ) ; if ( m_mark . is_marked ( e ) ) { continue ; } m_mark . mark ( e , true ) ; if ( ! contains_x ( e ) ) { continue ; } if ( contains_x . x ( ) == e ) { return false ; } if ( ! is_app ( e ) ) { return false ; } a = to_app ( e ) ; if ( m_util . m_arith . is_mod ( e ) && m_util . m_arith . is_numeral ( to_app ( e ) -> get_arg ( 1 ) , k1 ) && m_util . get_coeff ( contains_x , to_app ( e ) -> get_arg ( 0 ) , k2 , rest ) ) { app_ref z ( m ) , z_bv ( m ) ; m_util . mk_bounded_var ( k1 , z_bv , z ) ; m_nested_div_terms . push_back ( rest ) ; m_nested_div_divisors . push_back ( k1 ) ; m_nested_div_coeffs . push_back ( k2 ) ; m_nested_div_atoms . push_back ( a ) ; m_nested_div_z . push_back ( z ) ; continue ; } unsigned num_args = a -> get_num_args ( ) ; for ( unsigned i = 0 ; i < num_args ; ++ i ) { todo . push_back ( a -> get_arg ( i ) ) ; } } return true ; } bool get_le_bound ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; expr_ref p ( m ) , rest ( m ) ; rational k ; if ( m_util . is_le ( a , p ) && m_util . get_coeff ( contains_x , p , k , rest ) ) { if ( m_util . is_real ( contains_x . x ( ) ) ) { m_util . mk_div ( rest , abs ( k ) , rest ) ; k = k . is_pos ( ) ? rational :: one ( ) : rational :: minus_one ( ) ; } if ( k . is_neg ( ) ) { m_le_terms . push_back ( rest ) ; m_le_coeffs . push_back ( k ) ; m_le_atoms . push_back ( a ) ; } else { m_ge_terms . push_back ( rest ) ; m_ge_coeffs . push_back ( k ) ; m_ge_atoms . push_back ( a ) ; } return true ; } return false ; } bool get_lt_bound ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; expr_ref p ( m ) , rest ( m ) , na ( m ) ; rational k ; if ( m_util . is_lt ( a , p ) && m_util . get_coeff ( contains_x , p , k , rest ) ) { } else if ( m_util . is_neg ( a , na ) && is_app ( na ) && m_util . is_ge ( to_app ( na ) , p ) && m_util . get_coeff ( contains_x , p , k , rest ) ) { } else { return false ; } SASSERT ( m_util . is_real ( contains_x . x ( ) ) ) ; m_util . mk_div ( rest , abs ( k ) , rest ) ; if ( k . is_neg ( ) ) { m_lt_terms . push_back ( rest ) ; m_lt_coeffs . push_back ( rational :: minus_one ( ) ) ; m_lt_atoms . push_back ( a ) ; } else { m_gt_terms . push_back ( rest ) ; m_gt_coeffs . push_back ( rational :: one ( ) ) ; m_gt_atoms . push_back ( a ) ; } return true ; } bool get_divides ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; expr_ref p ( m ) , rest ( m ) ; app_ref a2 ( m ) ; numeral k , k2 ; if ( m_util . is_divides ( a , k , p ) && m_util . get_coeff ( contains_x , p , k2 , rest ) ) { m_div_terms . push_back ( rest ) ; m_div_divisors . push_back ( k ) ; m_div_coeffs . push_back ( k2 ) ; m_div_atoms . push_back ( a ) ; return true ; } if ( m_util . is_not_divides ( a , a2 , k , p ) && m_util . get_coeff ( contains_x , p , k2 , rest ) ) { m_div_terms . push_back ( rest ) ; m_div_divisors . push_back ( k ) ; m_div_coeffs . push_back ( k2 ) ; m_div_atoms . push_back ( a2 ) ; return true ; } return false ; } public : void display ( std :: ostream & out ) { ast_manager & m = m_util . get_manager ( ) ; for ( unsigned i = 0 ; i < lt_size ( ) ; ++ i ) { out << mk_pp ( lt ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } for ( unsigned i = 0 ; i < le_size ( ) ; ++ i ) { out << mk_pp ( le ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } for ( unsigned i = 0 ; i < gt_size ( ) ; ++ i ) { out << mk_pp ( gt ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } for ( unsigned i = 0 ; i < ge_size ( ) ; ++ i ) { out << mk_pp ( ge ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } } } ; class x_subst { arith_qe_util & m_super ; expr_ref m_t ; rational m_coeff ; public : x_subst ( arith_qe_util & s ) : m_super ( s ) , m_t ( s . get_manager ( ) ) , m_coeff ( rational :: one ( ) ) { } void set_term ( expr * t ) { m_t = t ; } void set_coeff ( rational const & k ) { m_coeff = k ; } expr * get_term ( ) const { return m_t ; } rational get_coeff ( ) const { return m_coeff ; } expr_ref mk_term ( rational const & c , expr * t ) { ast_manager & m = m_super . get_manager ( ) ; if ( m_t . get ( ) ) { return expr_ref ( m_super . mk_add ( m_super . mk_mul ( c , m_t ) , t ) , m ) ; } else { return expr_ref ( t , m ) ; } } rational mk_coeff ( rational const & k ) { return k * m_coeff ; } } ; struct branch_formula { expr * m_fml ; app * m_var ; unsigned m_branch ; expr * m_result ; rational m_coeff ; expr * m_term ; branch_formula ( ) : m_fml ( 0 ) , m_var ( 0 ) , m_branch ( 0 ) , m_result ( 0 ) , m_term ( 0 ) { } branch_formula ( expr * fml , app * var , unsigned b , expr * r , rational coeff , expr * term ) : m_fml ( fml ) , m_var ( var ) , m_branch ( b ) , m_result ( r ) , m_coeff ( coeff ) , m_term ( term ) { } unsigned mk_hash ( ) const { return mk_mix ( m_fml ? m_fml -> hash ( ) : 0 , m_var ? m_var -> hash ( ) : 0 , m_branch ) ; } bool mk_eq ( branch_formula const & other ) const { return m_fml == other . m_fml && m_var == other . m_var && m_branch == other . m_branch ; } struct hash { typedef branch_formula data ; unsigned operator ( ) ( data const & d ) const { return d . mk_hash ( ) ; } } ; struct eq { typedef branch_formula data ; bool operator ( ) ( data const & x , data const & y ) const { return x . mk_eq ( y ) ; } } ; } ; class arith_plugin : public qe_solver_plugin { typedef obj_pair_map < app , expr , bounds_proc * > bounds_cache ; typedef obj_pair_map < expr , expr , expr * > resolve_cache ; typedef hashtable < branch_formula , branch_formula :: hash , branch_formula :: eq > subst_cache ; arith_qe_util m_util ; expr_ref_vector m_trail ; bounds_cache m_bounds_cache ; subst_cache m_subst ; public : arith_plugin ( i_solver_context & ctx , ast_manager & m , smt_params & p ) : qe_solver_plugin ( m , m . mk_family_id ( " arith " ) , ctx ) , m_util ( m , p , ctx ) , m_trail ( m ) { } ~ arith_plugin ( ) { bounds_cache :: iterator it = m_bounds_cache . begin ( ) , end = m_bounds_cache . end ( ) ; for ( ; it != end ; ++ it ) { dealloc ( it -> get_value ( ) ) ; } } virtual void assign ( contains_app & contains_x , expr * fml , rational const & vl ) { SASSERT ( vl . is_unsigned ( ) ) ; app * x = contains_x . x ( ) ; unsigned v = vl . get_unsigned ( ) ; expr_ref result ( fml , m ) ; unsigned t_size , e_size ; x_subst x_t ( m_util ) ; if ( get_cache ( x , fml , v , result ) ) { return ; } bounds_proc & bounds = get_bounds ( x , fml ) ; bool is_lower = get_bound_sizes ( bounds , x , t_size , e_size ) ; assign_nested_divs ( contains_x , bounds , result ) ; assign_divs ( contains_x , bounds , x_t , result ) ; if ( v == 0 ) { mk_non_bounds ( bounds , true , is_lower , result ) ; mk_non_bounds ( bounds , false , is_lower , result ) ; mk_non_resolve ( bounds , true , is_lower , result ) ; mk_non_resolve ( bounds , false , is_lower , result ) ; m_util . simplify ( result ) ; add_cache ( x , fml , v , result , x_t . get_coeff ( ) , x_t . get_term ( ) ) ; TRACE ( " qe " , tout << vl << " ▁ " << mk_pp ( x , m ) << " ▁ infinite ▁ case \n " ; tout << mk_pp ( fml , m ) << " \n " ; tout << mk_pp ( result , m ) << " \n " ; ) ; return ; } unsigned index = v - 1 ; bool is_strict = e_size <= index ; bool is_eq = false ; SASSERT ( index < t_size + e_size ) ; if ( is_strict ) { index -= e_size ; TRACE ( " qe _ verbose " , bounds . display ( tout ) ; ) ; } else if ( m_util . is_real ( x ) ) { SASSERT ( 0 == ( e_size & 0x1 ) ) ; is_eq = ( 0 == ( index & 0x1 ) ) ; index /= 2 ; e_size /= 2 ; } SASSERT ( is_strict || index < e_size ) ; SASSERT ( ! is_strict || index < t_size ) ; SASSERT ( index < bounds . size ( is_strict , is_lower ) ) ; expr_ref t ( bounds . exprs ( is_strict , is_lower ) [ index ] , m ) ; rational a = bounds . coeffs ( is_strict , is_lower ) [ index ] ; mk_bounds ( bounds , x , true , is_eq , is_strict , is_lower , index , a , t , result ) ; mk_bounds ( bounds , x , false , is_eq , is_strict , is_lower , index , a , t , result ) ; t = x_t . mk_term ( a , t ) ; a = x_t . mk_coeff ( a ) ; mk_resolve ( bounds , x , x_t , true , is_eq , is_strict , is_lower , index , a , t , result ) ; mk_resolve ( bounds , x , x_t , false , is_eq , is_strict , is_lower , index , a , t , result ) ; m_util . simplify ( result ) ; add_cache ( x , fml , v , result , x_t . get_coeff ( ) , x_t . get_term ( ) ) ; TRACE ( " qe " , { tout << vl << " ▁ " << mk_pp ( bounds . atoms ( is_strict , is_lower ) [ index ] , m ) << " \n " ; tout << mk_pp ( fml , m ) << " \n " ; tout << mk_pp ( result , m ) << " \n " ; } ) ; } virtual bool get_num_branches ( contains_app & contains_x , expr * fml , rational & nb ) { app * x = contains_x . x ( ) ; if ( ! update_bounds ( contains_x , fml ) ) { return false ; } bounds_proc & bounds = get_bounds ( x , fml ) ; unsigned t_size , e_size ; get_bound_sizes ( bounds , x , t_size , e_size ) ; nb = rational ( t_size + e_size + 1 ) ; return true ; } virtual void subst ( contains_app & contains_x , rational const & vl , expr_ref & fml , expr_ref * def ) { SASSERT ( vl . is_unsigned ( ) ) ; if ( def ) { get_def ( contains_x , vl . get_unsigned ( ) , fml , * def ) ; } VERIFY ( get_cache ( contains_x . x ( ) , fml , vl . get_unsigned ( ) , fml ) ) ; TRACE ( " qe " , tout << mk_pp ( contains_x . x ( ) , m ) << " ▁ " << vl << " \n " << mk_pp ( fml , m ) << " \n " ; ) ; } virtual bool project ( contains_app & x , model_ref & model , expr_ref & fml ) { if ( ! update_bounds ( x , fml ) ) { TRACE ( " qe " , tout << mk_pp ( x . x ( ) , m ) << " ▁ failed ▁ to ▁ update ▁ bounds \n " ; ) ; return false ; } if ( m_util . m_arith . is_real ( x . x ( ) ) ) { return project_real ( x , model , fml ) ; } else { return project_int ( x , model , fml ) ; } } virtual unsigned get_weight ( contains_app & contains_x , expr * fml ) { return 2 ; } virtual bool solve ( conj_enum & conjs , expr * fml ) { return m_util . solve ( conjs , fml ) ; } virtual bool mk_atom ( expr * e , bool p , expr_ref & result ) { return m_util . mk_atom ( e , p , result ) ; } virtual bool is_uninterpreted ( app * f ) { switch ( f -> get_decl_kind ( ) ) { case OP_NUM : case OP_LE : case OP_LT : case OP_GE : case OP_GT : case OP_ADD : case OP_SUB : case OP_UMINUS : return false ; case OP_MOD : if ( m_util . m_arith . is_numeral ( f -> get_arg ( 1 ) ) ) { return false ; } return true ; case OP_MUL : { arith_util & a = m_util . m_arith ; expr * m , * n ; if ( a . is_mul ( f , m , n ) && ( a . is_numeral ( m ) || a . is_numeral ( n ) ) ) { return false ; } return true ; } default : return true ; } } private : expr_ref mk_idiv ( expr * e , numeral k ) { SASSERT ( ! k . is_zero ( ) ) ; arith_util & a = m_util . m_arith ; if ( k . is_one ( ) ) { return expr_ref ( e , m ) ; } if ( k . is_minus_one ( ) ) { return expr_ref ( a . mk_uminus ( e ) , m ) ; } SASSERT ( a . is_int ( e ) ) ; return expr_ref ( a . mk_idiv ( e , a . mk_numeral ( k , true ) ) , m ) ; } void get_def ( contains_app & contains_x , unsigned v , expr * fml , expr_ref & def ) { app * x = contains_x . x ( ) ; x_subst x_t ( m_util ) ; bounds_proc & bounds = get_bounds ( x , fml ) ; branch_formula bf ; VERIFY ( m_subst . find ( branch_formula ( fml , x , v , 0 , rational :: zero ( ) , 0 ) , bf ) ) ; x_t . set_term ( bf . m_term ) ; x_t . set_coeff ( bf . m_coeff ) ; CTRACE ( " qe " , x_t . get_term ( ) , tout << x_t . get_coeff ( ) << " ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; unsigned t_size , e_size , sz ; bool is_lower = get_bound_sizes ( bounds , x , t_size , e_size ) ; bool is_strict ; if ( v == 0 ) { is_strict = false ; sz = bounds . size ( is_strict , ! is_lower ) ; expr_ref_vector terms ( m ) ; if ( sz == 0 ) { terms . push_back ( m_util . mk_zero ( x ) ) ; } for ( unsigned i = 0 ; i < sz ; ++ i ) { expr_ref term ( bounds . exprs ( is_strict , ! is_lower ) [ i ] , m ) ; rational a = bounds . coeffs ( is_strict , ! is_lower ) [ i ] ; if ( x_t . get_term ( ) ) { TRACE ( " qe " , tout << x_t . get_coeff ( ) << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; SASSERT ( x_t . get_coeff ( ) . is_pos ( ) ) ; term = m_util . mk_add ( term , m_util . mk_mul ( a , x_t . get_term ( ) ) ) ; a = a * x_t . get_coeff ( ) ; } TRACE ( " qe " , tout << a << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( term , m ) << " ▁ < = ▁ 0 \n " ; ) ; SASSERT ( a . is_int ( ) ) ; SASSERT ( is_lower == a . is_pos ( ) ) ; term = m_util . mk_uminus ( term ) ; term = mk_idiv ( term , a ) ; terms . push_back ( term ) ; TRACE ( " qe " , tout << " a : ▁ " << a << " ▁ term : ▁ " << mk_pp ( term , m ) << " \n " ; ) ; } is_strict = true ; sz = bounds . size ( is_strict , ! is_lower ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { expr_ref term ( bounds . exprs ( is_strict , ! is_lower ) [ i ] , m ) ; SASSERT ( abs ( bounds . coeffs ( is_strict , ! is_lower ) [ i ] ) . is_one ( ) ) ; if ( is_lower ) { term = m_util . mk_uminus ( m_util . mk_add ( term , m_util . mk_one ( x ) ) ) ; } else { term = m_util . mk_add ( term , m_util . mk_one ( x ) ) ; } terms . push_back ( term ) ; } if ( is_lower ) { def = m_util . mk_min ( terms . size ( ) , terms . c_ptr ( ) ) ; } else { def = m_util . mk_max ( terms . size ( ) , terms . c_ptr ( ) ) ; } if ( x_t . get_term ( ) ) { TRACE ( " qe " , tout << x_t . get_coeff ( ) << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; def = m_util . mk_add ( m_util . mk_mul ( x_t . get_coeff ( ) , def ) , x_t . get_term ( ) ) ; } m_util . simplify ( def ) ; return ; } -- v ; is_strict = e_size <= v ; SASSERT ( v < t_size + e_size ) ; if ( is_strict ) { v -= e_size ; TRACE ( " qe _ verbose " , bounds . display ( tout ) ; ) ; } else if ( m_util . is_real ( x ) ) { SASSERT ( 0 == ( e_size & 0x1 ) ) ; v /= 2 ; e_size /= 2 ; } SASSERT ( is_strict || v < e_size ) ; SASSERT ( ! is_strict || v < t_size ) ; SASSERT ( v < bounds . size ( is_strict , is_lower ) ) ; def = bounds . exprs ( is_strict , is_lower ) [ v ] ; rational a = bounds . coeffs ( is_strict , is_lower ) [ v ] ; if ( x_t . get_term ( ) ) { TRACE ( " qe " , tout << x_t . get_coeff ( ) << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; SASSERT ( x_t . get_coeff ( ) . is_pos ( ) ) ; def = m_util . mk_add ( def , m_util . mk_mul ( a , x_t . get_term ( ) ) ) ; a = a * x_t . get_coeff ( ) ; } SASSERT ( a . is_int ( ) ) ; SASSERT ( is_lower != a . is_pos ( ) ) ; def = m_util . mk_uminus ( def ) ; def = mk_idiv ( def , a ) ; if ( x_t . get_term ( ) ) { def = m_util . mk_add ( m_util . mk_mul ( x_t . get_coeff ( ) , def ) , x_t . get_term ( ) ) ; } if ( is_strict ) { SASSERT ( m_util . m_arith . is_real ( x ) ) ; def = m_util . mk_sub ( def , m_util . mk_one ( x ) ) ; } m_util . simplify ( def ) ; TRACE ( " qe " , tout << " TBD ▁ ( for ▁ Real ) : ▁ " << a << " ▁ " << mk_pp ( def , m ) << " \n " ; ) ; } expr_ref mk_not ( expr * e ) { expr * r ; if ( m . is_not ( e , r ) ) { return expr_ref ( r , m ) ; } return expr_ref ( m . mk_not ( e ) , m ) ; } bool project_real ( contains_app & x , model_ref & model , expr_ref & fml ) { SASSERT ( m_util . m_arith . is_real ( x . x ( ) ) ) ; model_evaluator model_eval ( * model ) ; bounds_proc & bounds = get_bounds ( x . x ( ) , fml ) ; bool is_lower = bounds . le_size ( ) + bounds . lt_size ( ) < bounds . ge_size ( ) + bounds . gt_size ( ) ; unsigned e_size = bounds . e_size ( is_lower ) ; numeral bound1 , bound2 , vl , x_val ; unsigned idx1 , idx2 ; bool found1 = find_min_max ( is_lower , false , bounds , model_eval , bound1 , idx1 ) ; bool found2 = find_min_max ( is_lower , true , bounds , model_eval , bound2 , idx2 ) ; if ( ! found1 && ! found2 ) { vl = numeral ( 0 ) ; } else if ( found2 && ( ! found1 || bound2 <= bound1 ) ) { vl = numeral ( 1 + 2 * e_size + idx2 ) ; } else if ( found1 && ( ! found2 || bound1 < bound2 ) ) { expr_ref val_x ( m ) ; model_eval ( x . x ( ) , val_x ) ; VERIFY ( m_util . m_arith . is_numeral ( val_x , x_val ) ) ; if ( x_val == bound1 ) { vl = numeral ( 1 + 2 * idx1 ) ; } else { vl = numeral ( 1 + 2 * idx1 + 1 ) ; } } assign ( x , fml , vl ) ; subst ( x , vl , fml , 0 ) ; TRACE ( " qe " , tout << mk_pp ( fml , m ) << " \n " ; ) ; return true ; } bool project_int ( contains_app & x , model_ref & model , expr_ref & fml ) { model_evaluator model_eval ( * model ) ; bounds_proc & bounds = get_bounds ( x . x ( ) , fml ) ; SASSERT ( m_util . m_arith . is_int ( x . x ( ) ) ) ; SASSERT ( bounds . lt_size ( ) == 0 && bounds . gt_size ( ) == 0 ) ; bool is_lower = bounds . le_size ( ) < bounds . ge_size ( ) ; numeral bound , vl , x_val ; unsigned idx = bounds . le_size ( ) + bounds . ge_size ( ) ; bool found = find_min_max ( is_lower , false , bounds , model_eval , bound , idx ) ; if ( found ) { SASSERT ( idx < bounds . size ( false , is_lower ) ) ; vl = numeral ( 1 + idx ) ; } else { vl = numeral ( 0 ) ; } assign ( x , fml , vl ) ; subst ( x , vl , fml , 0 ) ; TRACE ( " qe " , tout << mk_pp ( fml , m ) << " \n " ; ) ; return true ; } bool find_min_max ( bool is_lower , bool is_strict , bounds_proc & bounds , model_evaluator & eval , rational & bound , unsigned & idx ) { bool found = false ; unsigned num_bounds = bounds . size ( is_strict , is_lower ) ; rational num ; for ( unsigned i = 0 ; i < num_bounds ; ++ i ) { expr_ref vl ( m ) ; eval ( bounds . atoms ( is_strict , is_lower ) [ i ] , vl ) ; if ( ! m . is_true ( vl ) ) { continue ; } eval ( bounds . exprs ( is_strict , is_lower ) [ i ] , vl ) ; VERIFY ( m_util . m_arith . is_numeral ( vl , num ) ) ; num /= abs ( bounds . coeffs ( is_strict , is_lower ) [ i ] ) ; if ( found ) { if ( is_lower ? ( num < bound ) : ( num > bound ) ) { bound = num ; idx = i ; } } else { found = true ; idx = i ; bound = num ; } } return found ; } bool get_bound_sizes ( bounds_proc & bounds , app * x , unsigned & t_size , unsigned & e_size ) { unsigned le_size = bounds . le_size ( ) ; unsigned ge_size = bounds . ge_size ( ) ; if ( m_util . is_real ( x ) ) { le_size *= 2 ; ge_size *= 2 ; } if ( le_size + bounds . lt_size ( ) < ge_size + bounds . gt_size ( ) ) { e_size = le_size ; t_size = bounds . lt_size ( ) ; return true ; } else { e_size = ge_size ; t_size = bounds . gt_size ( ) ; return false ; } } void add_cache ( app * x , expr * fml , unsigned v , expr * result , rational coeff , expr * term ) { m_trail . push_back ( x ) ; m_trail . push_back ( fml ) ; m_trail . push_back ( result ) ; if ( term ) m_trail . push_back ( term ) ; m_subst . insert ( branch_formula ( fml , x , v , result , coeff , term ) ) ; } bool get_cache ( app * x , expr * fml , unsigned v , expr_ref & result ) { branch_formula bf ; if ( ! m_subst . find ( branch_formula ( fml , x , v , 0 , rational :: zero ( ) , 0 ) , bf ) ) { return false ; } SASSERT ( bf . m_result ) ; result = bf . m_result ; return true ; } void assign_divs ( contains_app & contains_x , bounds_proc & bounds , x_subst & x_t , expr_ref & result ) { app * x = contains_x . x ( ) ; app_ref z ( m ) , z_bv ( m ) ; rational d ; if ( ! bounds . div_z ( d , z_bv , z ) ) { return ; } m_ctx . add_var ( z_bv ) ; expr * z_lt_d = m_util . m_arith . mk_le ( z , m_util . m_arith . mk_numeral ( d - rational ( 1 ) , true ) ) ; m_ctx . add_constraint ( false , z_lt_d ) ; SASSERT ( ! abs ( d ) . is_one ( ) ) ; rational d1 = d - rational ( 1 ) ; expr_ref tmp ( m ) ; m_util . m_arith_rewriter . mk_le ( z , m_util . m_arith . mk_numeral ( d1 , true ) , tmp ) ; m_util . m_bool_rewriter . mk_and ( result , tmp , result ) ; expr_ref t1 ( m ) , new_atom ( m ) ; t1 = m_util . mk_sub ( x , z ) ; m_util . mk_divides ( d , t1 , new_atom ) ; m_ctx . add_constraint ( false , new_atom ) ; mk_div_equivs ( bounds , z , result ) ; x_t . set_term ( z ) ; x_t . set_coeff ( d ) ; } void mk_div_equivs ( bounds_proc & bounds , expr * z , expr_ref & result ) { unsigned sz = bounds . div_size ( ) ; app * const * atoms = bounds . div_atoms ( ) ; rational const * coeffs = bounds . div_coeffs ( ) ; expr * const * terms = bounds . div_terms ( ) ; rational const * divisors = bounds . divisors ( ) ; expr_ref new_atom ( m ) , t1 ( m ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * atm = atoms [ i ] ; t1 = m_util . mk_add ( m_util . mk_mul ( coeffs [ i ] , z ) , terms [ i ] ) ; m_util . mk_divides ( divisors [ i ] , t1 , new_atom ) ; m_util . m_replace . apply_substitution ( atm , new_atom . get ( ) , result ) ; m_ctx . add_constraint ( false , mk_not ( atm ) , new_atom ) ; m_ctx . add_constraint ( false , mk_not ( new_atom ) , atm ) ; } } void assign_nested_divs ( contains_app & contains_x , bounds_proc & bounds , expr_ref & result ) { unsigned num_nested_divs = bounds . nested_div_size ( ) ; if ( num_nested_divs == 0 ) { return ; } app_ref z ( m ) , z_bv ( m ) ; rational d ; VERIFY ( bounds . div_z ( d , z_bv , z ) ) ; for ( unsigned i = 0 ; i < num_nested_divs ; ++ i ) { app * atm = bounds . nested_div_atom ( i ) ; rational const & k = bounds . nested_divisor ( i ) ; app * z1_bv = bounds . nested_div_z_bv ( i ) ; app * z1 = bounds . nested_div_z ( i ) ; m_ctx . add_var ( z1_bv ) ; expr * z_lt_k = m_util . m_arith . mk_le ( z1 , m_util . m_arith . mk_numeral ( k - rational ( 1 ) , true ) ) ; m_ctx . add_constraint ( false , z_lt_k ) ; expr * e1 = m_util . m_arith . mk_sub ( atm -> get_arg ( 0 ) , z1 ) ; expr * e2 = atm -> get_arg ( 1 ) ; expr_ref mod_term2 ( m_util . m_arith . mk_mod ( e1 , e2 ) , m ) ; m_util . simplify ( mod_term2 ) ; m_ctx . add_constraint ( false , m . mk_eq ( mod_term2 , m_util . mk_zero ( mod_term2 ) ) ) ; m_util . m_replace . apply_substitution ( atm , z1 , result ) ; expr_ref mod_eq ( m ) , tmp1 ( m ) , tmp2 ( m ) ; tmp2 = m_util . mk_numeral ( bounds . nested_div_coeff ( i ) , true ) ; tmp1 = m_util . m_arith . mk_mul ( tmp2 , z1 ) ; tmp2 = m_util . m_arith . mk_sub ( bounds . nested_div_term ( i ) , z ) ; tmp2 = m_util . m_arith . mk_add ( tmp1 , tmp2 ) ; tmp1 = m_util . m_arith . mk_mod ( tmp2 , bounds . nested_div_atom ( i ) -> get_arg ( 1 ) ) ; mod_eq = m . mk_eq ( tmp1 , m_util . mk_zero ( z ) ) ; m_util . simplify ( mod_eq ) ; result = m . mk_and ( result , mod_eq ) ; TRACE ( " qe " , tout << mk_pp ( mod_eq , m ) << " \n " ; ) ; } } bounds_proc & get_bounds ( app * x , expr * fml ) { bounds_proc * result = 0 ; VERIFY ( m_bounds_cache . find ( x , fml , result ) ) ; return * result ; } void mk_non_bounds ( bounds_proc & bounds , bool is_strict , bool is_lower , expr_ref & result ) { unsigned sz = bounds . size ( is_strict , is_lower ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , is_lower ) [ i ] ; m_ctx . add_constraint ( true , mk_not ( e ) ) ; m_util . m_replace . apply_substitution ( e , m . mk_false ( ) , result ) ; } } void mk_non_resolve ( bounds_proc & bounds , bool is_strict , bool is_lower , expr_ref & result ) { unsigned sz = bounds . size ( is_strict , ! is_lower ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , ! is_lower ) [ i ] ; m_ctx . add_constraint ( true , e ) ; m_util . m_replace . apply_substitution ( e , m . mk_true ( ) , result ) ; } } void mk_bound ( bool is_strict , bool is_lower , rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { if ( is_strict ) { if ( is_lower ) { m_util . mk_strict_bound ( b , s , a , t , result ) ; } else { m_util . mk_strict_bound ( a , t , b , s , result ) ; } } else { if ( is_lower ) { m_util . mk_bound ( b , s , a , t , result ) ; } else { m_util . mk_bound ( a , t , b , s , result ) ; } } m_util . simplify ( result ) ; TRACE ( " qe " , tout << ( is_strict ? " strict " : " non - strict " ) << " \n " ; tout << ( is_lower ? " is - lower " : " is - upper " ) << " \n " ; tout << " a : ▁ " << a << " ▁ " << mk_pp ( t , m ) << " \n " ; tout << " b : ▁ " << b << " ▁ " << mk_pp ( s , m ) << " \n " ; tout << mk_pp ( result , m ) << " \n " ; ) ; } void mk_bounds ( bounds_proc & bounds , app * x , bool is_strict , bool is_eq_ctx , bool is_strict_ctx , bool is_lower , unsigned index , rational const & a , expr * t , expr_ref & result ) { TRACE ( " qe " , tout << mk_pp ( t , m ) << " \n " ; ) ; SASSERT ( ! is_eq_ctx || ! is_strict_ctx ) ; unsigned sz = bounds . size ( is_strict , is_lower ) ; expr_ref tmp ( m ) , eq ( m ) ; bool same_strict = ( is_strict == is_strict_ctx ) ; bool non_strict_real = m_util . is_real ( x ) && ! is_strict_ctx ; app * atm = bounds . atoms ( is_strict_ctx , is_lower ) [ index ] ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , is_lower ) [ i ] ; expr_ref s ( bounds . exprs ( is_strict , is_lower ) [ i ] , m ) ; rational b = bounds . coeffs ( is_strict , is_lower ) [ i ] ; if ( same_strict && i == index ) { if ( non_strict_real ) { m_util . mk_eq ( a , x , t , eq ) ; TRACE ( " qe " , tout << " a : " << a << " ▁ x : ▁ " << mk_pp ( x , m ) << " t : ▁ " << mk_pp ( t , m ) << " ▁ eq : ▁ " << mk_pp ( eq , m ) << " \n " ; ) ; if ( is_eq_ctx ) { m_ctx . add_constraint ( true , eq ) ; } else { m_ctx . add_constraint ( true , mk_not ( eq ) ) ; m_ctx . add_constraint ( true , e ) ; } } else { m_ctx . add_constraint ( true , e ) ; } m_util . m_replace . apply_substitution ( atm , m . mk_true ( ) , result ) ; continue ; } bool result_is_strict = ( non_strict_real && is_eq_ctx && is_strict ) || ( same_strict && i < index ) ; mk_bound ( result_is_strict , is_lower , a , t , b , s , tmp ) ; m_util . m_replace . apply_substitution ( e , tmp . get ( ) , result ) ; TRACE ( " qe " , tout << ( result_is_strict ? " strict ▁ result " : " non - strict ▁ result " ) << " \n " ; tout << ( is_strict ? " strict " : " non - strict " ) << " \n " ; tout << mk_pp ( atm , m ) << " ▁ & ▁ " ; tout << mk_pp ( e , m ) << " ▁ - - > ▁ " ; tout << mk_pp ( tmp . get ( ) , m ) << " \n " ; ) ; m_ctx . add_constraint ( true , mk_not ( e ) , tmp ) ; } } void mk_resolve ( bounds_proc & bounds , app * x , x_subst & x_t , bool is_strict , bool is_eq_ctx , bool is_strict_ctx , bool is_lower , unsigned index , rational const & a , expr * t , expr_ref & result ) { expr_ref tmp ( m ) ; unsigned sz = bounds . size ( is_strict , ! is_lower ) ; bool is_strict_real = ! is_eq_ctx && m_util . is_real ( x ) && ! is_strict_ctx ; bool strict_resolve = is_strict || is_strict_ctx || is_strict_real ; app * atm = bounds . atoms ( is_strict_ctx , is_lower ) [ index ] ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , ! is_lower ) [ i ] ; expr_ref s ( bounds . exprs ( is_strict , ! is_lower ) [ i ] , m ) ; rational b = bounds . coeffs ( is_strict , ! is_lower ) [ i ] ; SASSERT ( ! b . is_zero ( ) ) ; SASSERT ( b . is_pos ( ) != a . is_pos ( ) ) ; s = x_t . mk_term ( b , s ) ; b = x_t . mk_coeff ( b ) ; m_util . mk_resolve ( x , strict_resolve , a , t , b , s , tmp ) ; expr_ref save_result ( result ) ; m_util . m_replace . apply_substitution ( e , tmp . get ( ) , result ) ; m_ctx . add_constraint ( true , mk_not ( e ) , tmp ) ; TRACE ( " qe _ verbose " , tout << mk_pp ( atm , m ) << " ▁ " ; tout << mk_pp ( e , m ) << " ▁ = = > \n " ; tout << mk_pp ( tmp , m ) << " \n " ; tout << " old ▁ fml : ▁ " << mk_pp ( save_result , m ) << " \n " ; tout << " new ▁ fml : ▁ " << mk_pp ( result , m ) << " \n " ; ) ; } } bool update_bounds ( bounds_proc & bounds , contains_app & contains_x , expr * fml , atom_set const & tbl , bool is_pos ) { app_ref tmp ( m ) ; atom_set :: iterator it = tbl . begin ( ) , end = tbl . end ( ) ; for ( ; it != end ; ++ it ) { app * e = * it ; if ( ! contains_x ( e ) ) { continue ; } if ( ! is_pos ) { SASSERT ( ! m . is_not ( e ) ) ; tmp = m . mk_not ( e ) ; e = tmp ; } if ( ! bounds . get_bound ( contains_x , e ) ) { return false ; } } return true ; } bool update_bounds ( contains_app & contains_x , expr * fml ) { bounds_proc * bounds = 0 ; if ( m_bounds_cache . find ( contains_x . x ( ) , fml , bounds ) ) { return true ; } bounds = alloc ( bounds_proc , m_util ) ; if ( ! update_bounds ( * bounds , contains_x , fml , m_ctx . pos_atoms ( ) , true ) ) { dealloc ( bounds ) ; return false ; } if ( ! update_bounds ( * bounds , contains_x , fml , m_ctx . neg_atoms ( ) , false ) ) { dealloc ( bounds ) ; return false ; } m_trail . push_back ( contains_x . x ( ) ) ; m_trail . push_back ( fml ) ; m_bounds_cache . insert ( contains_x . x ( ) , fml , bounds ) ; return true ; } } ; class nlarith_plugin : public qe_solver_plugin { typedef obj_map < app , unsigned > weight_m ; typedef obj_pair_map < expr , expr , nlarith :: branch_conditions * > bcs_t ; typedef obj_map < expr , weight_m * > weights_t ; bcs_t m_cache ; weights_t m_weights ; th_rewriter m_rewriter ; nlarith :: util m_util ; expr_safe_replace m_replace ; expr_ref_vector m_trail ; factor_re@@ writer_st@@ ar m_factor_rw ; bool m_produce_models ; public : nlarith_plugin ( i_solver_context & ctx , ast_manager & m , bool produce_models ) : qe_solver_plugin ( m , m . mk_family_id ( " arith " ) , ctx ) , m_rewriter ( m ) , m_util ( m ) , m_replace ( m ) , m_trail ( m ) , m_factor_rw ( m ) , m_produce_models ( produce_models ) { TRACE ( " qe " , tout << " produce ▁ models : ▁ " << produce_models << " \n " ; ) ; m_util . set_enable@@ _linear ( true ) ; } virtual ~ nlarith_plugin ( ) { bcs_t :: iterator it = m_cache . begin ( ) , end = m_cache . end ( ) ; for ( ; it != end ; ++ it ) { dealloc ( it -> get_value ( ) ) ; } weights_t :: iterator it2 = m_weights . begin ( ) , e2 = m_weights . end ( ) ; for ( ; it2 != e2 ; ++ it2 ) { dealloc ( it2 -> get_value ( ) ) ; } } virtual bool simplify ( expr_ref & fml ) { expr_ref tmp ( m ) , tmp2 ( m ) ; m_factor_rw ( fml , tmp ) ; m_rewriter ( tmp , tmp2 ) ; if ( fml . get ( ) != tmp2 . get ( ) ) { fml = tmp2 ; return true ; } return false ; } virtual void assign ( contains_app & x , expr * fml , rational const & vl ) { nlarith :: branch_conditions * brs ; VERIFY ( m_cache . find ( x . x ( ) , fml , brs ) ) ; SASSERT ( vl . is_unsigned ( ) ) ; SASSERT ( vl . get_unsigned ( ) < brs -> size ( ) ) ; expr * branch_fml = brs -> branches ( vl . get_unsigned ( ) ) ; expr_ref result ( m ) , tmp ( m ) ; m_factor_rw ( branch_fml , tmp ) ; m_rewriter ( tmp , result ) ; TRACE ( " qe " , tout << vl << " ▁ " << mk_pp ( result . get ( ) , m ) << " \n " ; ) ; m_ctx . add_constraint ( true , result ) ; } virtual bool get_num_branches ( contains_app & x , expr * fml , rational & num_branches ) { nlarith :: branch_conditions * brs ; if ( m_cache . find ( x . x ( ) , fml , brs ) ) { num_branches = rational ( brs -> size ( ) ) ; return true ; } expr_ref_vector lits ( m ) ; update_bounds ( lits , m_ctx . pos_atoms ( ) , true ) ; update_bounds ( lits , m_ctx . neg_atoms ( ) , false ) ; brs = alloc ( nlarith :: branch_conditions , m ) ; TRACE ( " nlarith " , tout << mk_pp ( fml , m ) << " \n " ; ) ; if ( ! m_util . create_branch@@ es ( x . x ( ) , lits . size ( ) , lits . c_ptr ( ) , * brs ) ) { TRACE ( " nlarith " , tout << " no ▁ branches ▁ for ▁ " << mk_pp ( x . x ( ) , m ) << " \n " ; ) ; dealloc ( brs ) ; return false ; } num_branches = rational ( brs -> size ( ) ) ; insert_cache ( x . x ( ) , fml , brs ) ; return true ; } virtual void subst ( contains_app & x , rational const & vl , expr_ref & fml , expr_ref * def ) { nlarith :: branch_conditions * brs ; VERIFY ( m_cache . find ( x . x ( ) , fml , brs ) ) ; SASSERT ( vl . is_unsigned ( ) ) ; SASSERT ( vl . get_unsigned ( ) < brs -> size ( ) ) ; unsigned j = vl . get_unsigned ( ) ; m_replace . reset ( ) ; for ( unsigned i = 0 ; i < brs -> preds ( ) . size ( ) ; ++ i ) { m_replace . insert ( brs -> preds ( i ) , brs -> subst ( j ) [ i ] ) ; } m_replace ( fml ) ; expr_ref tmp ( m . mk_and ( brs -> constraints ( j ) , fml ) , m ) ; m_factor_rw ( tmp , fml ) ; if ( def ) { m_factor_rw ( brs -> def ( j ) , * def ) ; } } virtual unsigned get_weight ( contains_app & x , expr * fml ) { obj_map < app , unsigned > * weights = 0 ; unsigned weight = 0 ; if ( ! m_weights . find ( fml , weights ) ) { weights = alloc ( weight_m ) ; m_weights . insert ( fml , weights ) ; m_trail . push_back ( fml ) ; ptr_vector < app > nl_vars ; m_util . extract_non_linear ( to_app ( fml ) , nl_vars ) ; for ( unsigned i = 0 ; i < nl_vars . size ( ) ; ++ i ) { weights -> insert ( nl_vars [ i ] , 100 ) ; } } if ( weights -> find ( x . x ( ) , weight ) ) { return weight ; } return UINT_MAX ; } virtual bool solve ( conj_enum & conjs , expr * fml ) { return false ; } virtual bool mk_atom ( expr * e , bool p , expr_ref & result ) { return false ; } virtual bool is_uninterpreted ( app * f ) { if ( m_produce_models ) { return true ; } switch ( f -> get_decl_kind ( ) ) { case OP_NUM : case OP_LE : case OP_LT : case OP_GE : case OP_GT : case OP_ADD : case OP_SUB : case OP_UMINUS : return false ; case OP_MUL : { arith_util a ( m ) ; expr * m , * n ; if ( a . is_mul ( f , m , n ) && ( a . is_numeral ( m ) || a . is_numeral ( n ) ) ) { return false ; } return true ; } default : return true ; } return true ; } private : void insert_cache ( app * x , expr * e , nlarith :: branch_conditions * brs ) { m_trail . push_back ( x ) ; m_trail . push_back ( e ) ; m_cache . insert ( x , e , brs ) ; } void update_bounds ( expr_ref_vector & lits , atom_set const & tbl , bool is_pos ) { atom_set :: iterator it = tbl . begin ( ) , end = tbl . end ( ) ; for ( ; it != end ; ++ it ) { app * e = * it ; lits . push_back ( is_pos ? e : m . mk_not ( e ) ) ; } } } ; qe_solver_plugin * mk_arith_plugin ( i_solver_context & ctx , bool produce_models , smt_params & p ) { if ( p . m_nlquant_@@ elim ) { return alloc ( nlarith_plugin , ctx , ctx . get_manager ( ) , produce_models ) ; } else { return alloc ( arith_plugin , ctx , ctx . get_manager ( ) , p ) ; } } } </DOCUMENT>
<DOCUMENT_ID="Jo@@ seBarrales/mlnc@@ /tree/master/src/test/rpc_@@ tests.cpp"> # include < boost / test / unit_test . hpp > # include < boost / foreach . hpp > # include " base58 . h " # include " util . h " # include " bitcoin@@ rpc . h " using namespace std ; using namespace json_spirit ; BOOST_AUTO_TEST_SUITE ( rpc_tests ) static Array createArgs ( int nRequired , const char * address1 = NULL , const char * address2 = NULL ) { Array result ; result . push_back ( nRequired ) ; Array addresses ; if ( address1 ) addresses . push_back ( address1 ) ; if ( address2 ) addresses . push_back ( address1 ) ; result . push_back ( addresses ) ; return result ; } struct TestNetFixture { TestNetFixture ( ) { fTestNet = true ; } ~ TestNetFixture ( ) { fTestNet = false ; } } ; BOOST_FIXTURE_TEST_CASE ( rpc_addmultisig , TestNetFixture ) { rpcfn_type addmultisig = tableRPC [ " addmultisigaddress " ] -> actor ; const char * address1Hex = "0434e3@@ e09f4@@ 9ea168c5@@ bbf53@@ f877ff420@@ 6923858aab@@ 7c7e1@@ df25bc@@ 263978@@ 107c@@ 95e3@@ 5065a27@@ ef6f1b27222@@ db0ec97@@ e0e8@@ 95eac@@ a603d3ee0@@ d4c0@@ 60ce3d@@ 8a0028@@ 6c8" ; const char * address2Hex = "0388@@ c2037017c6@@ 2240b6@@ b72ac1a2@@ a5f94@@ da790@@ 596ebd061@@ 77c85@@ 72752922165@@ cb4" ; Value v ; CBitcoinAddress address ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 1 , address1Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 1 , address1Hex , address2Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 2 , address1Hex , address2Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 0 ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , address1Hex ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 , " " ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 , " NotAValid@@ Pubkey " ) , false ) , runtime_error ) ; string short1 ( address1Hex , address1Hex + sizeof ( address1Hex ) - 2 ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , short1 . c_str ( ) ) , false ) , runtime_error ) ; string short2 ( address1Hex + 2 , address1Hex + sizeof ( address1Hex ) ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , short2 . c_str ( ) ) , false ) , runtime_error ) ; } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
<DOCUMENT_ID="Poxle@@ it/s-core/tree/master/src/scriptdev@@ 2/scripts/@@ eastern_@@ kingdoms/shadowfang_keep@@ /instance_shadowfang_keep@@ .cpp"> # include " precompiled . h " # include " shadowfang _ keep . h " instance_shadowfang_keep :: instance_shadowfang_keep ( Map * pMap ) : ScriptedInstance ( pMap ) { Initialize ( ) ; } void instance_shadowfang_keep :: Initialize ( ) { memset ( & m_auiEncounter , 0 , sizeof ( m_auiEncounter ) ) ; } void instance_shadowfang_keep :: OnCreature@@ Create ( Creature * pCreature ) { switch ( pCreature -> GetEntry ( ) ) { case NPC_ASH : case NPC_ADA : case NPC_FENRUS : break ; case NPC_VIN@@ CENT : if ( m_auiEncounter [ 4 ] == DONE ) pCreature -> SetStandState ( UNIT_STAND_STATE_DEAD ) ; break ; default : return ; } m_mNpcEntryGuidStore [ pCreature -> GetEntry ( ) ] = pCreature -> GetObjectGuid ( ) ; } void instance_shadowfang_keep :: OnObjectCreate ( GameObject * pGo ) { switch ( pGo -> GetEntry ( ) ) { case GO_COURTYARD_DOOR : if ( m_auiEncounter [ 0 ] == DONE ) pGo -> SetGoState ( GO_STATE_ACTIVE ) ; break ; case GO_SORCERER_DOOR : if ( m_auiEncounter [ 2 ] == DONE ) pGo -> SetGoState ( GO_STATE_ACTIVE ) ; break ; case GO_ARUGAL_DOOR : if ( m_auiEncounter [ 3 ] == DONE ) pGo -> SetGoState ( GO_STATE_ACTIVE ) ; break ; case GO_ARUGAL_FOCUS : break ; default : return ; } m_mGoEntryGuidStore [ pGo -> GetEntry ( ) ] = pGo -> GetObjectGuid ( ) ; } void instance_shadowfang_keep :: DoSpeech ( ) { Creature * pAda = GetSingleCreatureFromStorage ( NPC_ADA ) ; Creature * pAsh = GetSingleCreatureFromStorage ( NPC_ASH ) ; if ( pAda && pAda -> isAlive ( ) && pAsh && pAsh -> isAlive ( ) ) { DoScriptText ( SAY_BOSS_DIE_AD , pAda ) ; DoScriptText ( SAY_BOSS_DIE_AS , pAsh ) ; } } void instance_shadowfang_keep :: SetData ( uint32 uiType , uint32 uiData ) { switch ( uiType ) { case TYPE_FREE_NPC : if ( uiData == DONE ) DoUseDoorOrButton ( GO_COURTYARD_DOOR ) ; m_auiEncounter [ 0 ] = uiData ; break ; case TYPE_RETHILGORE : if ( uiData == DONE ) DoSpeech ( ) ; m_auiEncounter [ 1 ] = uiData ; break ; case TYPE_FENRUS : if ( uiData == DONE ) { if ( Creature * pFenrus = GetSingleCreatureFromStorage ( NPC_FENRUS ) ) pFenrus -> SummonCreature ( NPC_ARCHMA@@ GE_ARUG@@ AL , - 136.89f , 2169.17f , 136.58f , 2.79@@ 4f , TEMPSUMMON_TIMED_DESPAWN , 30000 ) ; } m_auiEncounter [ 2 ] = uiData ; break ; case TYPE_NANDOS : if ( uiData == DONE ) DoUseDoorOrButton ( GO_ARUGAL_DOOR ) ; m_auiEncounter [ 3 ] = uiData ; break ; case TYPE_INTRO : m_auiEncounter [ 4 ] = uiData ; break ; case TYPE_VO@@ IDWALKER : if ( uiData == DONE ) { m_auiEncounter [ 5 ] ++ ; if ( m_auiEncounter [ 5 ] > 3 ) DoUseDoorOrButton ( GO_SORCERER_DOOR ) ; } break ; } if ( uiData == DONE ) { OUT_SAVE_INST_DATA ; std :: ostringstream saveStream ; saveStream << m_auiEncounter [ 0 ] << " ▁ " << m_auiEncounter [ 1 ] << " ▁ " << m_auiEncounter [ 2 ] << " ▁ " << m_auiEncounter [ 3 ] << " ▁ " << m_auiEncounter [ 4 ] << " ▁ " << m_auiEncounter [ 5 ] ; m_strInst@@ Data = saveStream . str ( ) ; SaveToDB ( ) ; OUT_SAVE_INST_DATA_COMPLETE ; } } uint32 instance_shadowfang_keep :: GetData ( uint32 uiType ) const { switch ( uiType ) { case TYPE_FREE_NPC : return m_auiEncounter [ 0 ] ; case TYPE_RETHILGORE : return m_auiEncounter [ 1 ] ; case TYPE_FENRUS : return m_auiEncounter [ 2 ] ; case TYPE_NANDOS : return m_auiEncounter [ 3 ] ; case TYPE_INTRO : return m_auiEncounter [ 4 ] ; default : return 0 ; } } void instance_shadowfang_keep :: Load ( const char * chrIn ) { if ( ! chrIn ) { OUT_LOAD_INST_DATA_FAIL ; return ; } OUT_LOAD_INST_DATA ( chrIn ) ; std :: istringstream loadStream ( chrIn ) ; loadStream >> m_auiEncounter [ 0 ] >> m_auiEncounter [ 1 ] >> m_auiEncounter [ 2 ] >> m_auiEncounter [ 3 ] >> m_auiEncounter [ 4 ] >> m_auiEncounter [ 5 ] ; for ( uint8 i = 0 ; i < MAX_ENCO@@ UNTER ; ++ i ) { if ( m_auiEncounter [ i ] == IN_PROGRESS ) m_auiEncounter [ i ] = NOT_STARTED ; } OUT_LOAD_INST_DATA_COMPLETE ; } InstanceData * GetInstanceData_instance_shadowfang_keep ( Map * pMap ) { return new instance_shadowfang_keep ( pMap ) ; } void AddSC@@ _instance_shadowfang_keep ( ) { Script * pNewScript ; pNewScript = new Script ; pNewScript -> Name = " instance _ shadowfang _ keep " ; pNewScript -> GetInstanceData = & GetInstanceData_instance_shadowfang_keep ; pNewScript -> RegisterSelf ( ) ; } </DOCUMENT>
<DOCUMENT_ID="geodynamics/gal@@ e/tree/master/boost/libs/regex/per@@ formance/time_@@ greta.cpp"> # include " regex _ comparison . hpp " # if defined ( BOOST_HAS_GRETA ) # include < cassert > # include < boost / timer . hpp > # include " regexpr2 . h " namespace g { double time_match ( const std :: string & re , const std :: string & text , bool icase ) { regex :: rpattern e ( re , ( icase ? regex :: MULTILINE | regex :: NORMALIZE | regex :: NOCASE : regex :: MULTILINE | regex :: NORMALIZE ) ) ; regex :: match_results what ; boost :: timer tim ; int iter = 1 ; int counter , repeats ; double result = 0 ; double run ; assert ( e . match ( text , what ) ) ; do { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text , what ) ; } result = tim . elapsed ( ) ; iter *= 2 ; } while ( result < 0.5 ) ; iter /= 2 ; for ( repeats = 0 ; repeats < REPEAT_COUNT ; ++ repeats ) { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text , what ) ; } run = tim . elapsed ( ) ; result = ( std :: min ) ( run , result ) ; } return result / iter ; } double time_find_all ( const std :: string & re , const std :: string & text , bool icase ) { regex :: rpattern e ( re , ( icase ? regex :: MULTILINE | regex :: NORMALIZE | regex :: NOCASE : regex :: MULTILINE | regex :: NORMALIZE ) ) ; regex :: match_results what ; boost :: timer tim ; int iter = 1 ; int counter , repeats ; double result = 0 ; double run ; do { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text . begin ( ) , text . end ( ) , what ) ; while ( what . backref ( 0 ) . matched ) { e . match ( what . backref ( 0 ) . end ( ) , text . end ( ) , what ) ; } } result = tim . elapsed ( ) ; iter *= 2 ; } while ( result < 0.5 ) ; iter /= 2 ; if ( result > 10 ) return result / iter ; for ( repeats = 0 ; repeats < REPEAT_COUNT ; ++ repeats ) { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text . begin ( ) , text . end ( ) , what ) ; while ( what . backref ( 0 ) . matched ) { e . match ( what . backref ( 0 ) . end ( ) , text . end ( ) , what ) ; } } run = tim . elapsed ( ) ; result = ( std :: min ) ( run , result ) ; } return result / iter ; } } # else namespace g { double time_match ( const std :: string & re , const std :: string & text , bool icase ) { return - 1 ; } double time_find_all ( const std :: string & re , const std :: string & text , bool icase ) { return - 1 ; } } # endif </DOCUMENT>
<DOCUMENT_ID="DL@@ R-SC/ti@@ gl/tree/master/src/@@ generated/CPACSFarField.cpp"> # include " CPACSFarField . h " # include " CTiglError . h " # include " CTiglLogging . h " # include " TixiHelper . h " namespace tigl { namespace generated { CPACSFarField :: CPACSFarField ( ) : m_referenceLength ( 0 ) , m_multiplier ( 0 ) { } CPACSFarField :: ~ CPACSFarField ( ) { } void CPACSFarField :: ReadCPACS ( const TixiDocumentHandle & tixiHandle , const std :: string & xpath ) { if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / type " ) ) { m_type = stringToTiglFarFieldType ( tixi :: TixiGetElement < std :: string > ( tixiHandle , xpath + " / type " ) ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ type ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / referenceLength " ) ) { m_referenceLength = tixi :: TixiGetElement < double > ( tixiHandle , xpath + " / referenceLength " ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ referenceLength ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / multiplier " ) ) { m_multiplier = tixi :: TixiGetElement < double > ( tixiHandle , xpath + " / multiplier " ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ multiplier ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } } void CPACSFarField :: WriteCPACS ( const TixiDocumentHandle & tixiHandle , const std :: string & xpath ) const { tixi :: TixiCreateElementIfNotExists ( tixiHandle , xpath + " / type " ) ; tixi :: TixiSaveElement ( tixiHandle , xpath + " / type " , TiglFarFieldTypeToString ( m_type ) ) ; tixi :: TixiCreateElementIfNotExists ( tixiHandle , xpath + " / referenceLength " ) ; tixi :: TixiSaveElement ( tixiHandle , xpath + " / referenceLength " , m_referenceLength ) ; tixi :: TixiCreateElementIfNotExists ( tixiHandle , xpath + " / multiplier " ) ; tixi :: TixiSaveElement ( tixiHandle , xpath + " / multiplier " , m_multiplier ) ; } const TiglFarFieldType & CPACSFarField :: GetType ( ) const { return m_type ; } void CPACSFarField :: SetType ( const TiglFarFieldType & value ) { m_type = value ; } const double & CPACSFarField :: GetReferenceLength ( ) const { return m_referenceLength ; } void CPACSFarField :: SetReferenceLength ( const double & value ) { m_referenceLength = value ; } const double & CPACSFarField :: GetMultiplier ( ) const { return m_multiplier ; } void CPACSFarField :: SetMultiplier ( const double & value ) { m_multiplier = value ; } } } </DOCUMENT>
<DOCUMENT_ID="Ear@@ lz/do@@ bbscoin@@ -source/tree/master/src/test/transaction@@ _tests.cpp"> # include " data / tx _ invalid . json . h " # include " data / tx _ valid . json . h " # include " clientversion . h " # include " key . h " # include " keystore . h " # include " main . h " # include " script / script . h " # include " script / script _ error . h " # include " core _ io . h " # include < map > # include < string > # include < boost / algorithm / string / classification . hpp > # include < boost / algorithm / string / split . hpp > # include < boost / test / unit_test . hpp > # include < boost / assign / list_of . hpp > # include " json / json _ spirit _ writer _ template . h " using namespace std ; using namespace json_spirit ; using namespace boost :: algorithm ; extern Array read_json ( const std :: string & jsondata ) ; static std :: map < string , unsigned int > mapFlagNames = boost :: assign :: map_list_of ( string ( " NONE " ) , ( unsigned int ) SCRIPT_VERIFY_NONE ) ( string ( " P2SH " ) , ( unsigned int ) SCRIPT_VERIFY_P2SH ) ( string ( " STRICTENC " ) , ( unsigned int ) SCRIPT_VERIFY_STRICTENC ) ( string ( " DERSIG " ) , ( unsigned int ) SCRIPT_VERIFY_DERSIG ) ( string ( " LOW _ S " ) , ( unsigned int ) SCRIPT_VERIFY_LOW_S ) ( string ( " SIGPUSHONLY " ) , ( unsigned int ) SCRIPT_VERIFY_SI@@ GPUSHONLY ) ( string ( " MINIMALDATA " ) , ( unsigned int ) SCRIPT_VERIFY_MINIMALDATA ) ( string ( " NULLDUMMY " ) , ( unsigned int ) SCRIPT_VERIFY_NULLDUMMY ) ( string ( " DISCOURAGE _ UPGRADABLE _ NOPS " ) , ( unsigned int ) SCRIPT_VERIFY_DISCOUR@@ AGE_UPGRAD@@ ABLE_NOPS ) ; unsigned int ParseScriptFlags ( string strFlags ) { if ( strFlags . empty ( ) ) { return 0 ; } unsigned int flags = 0 ; vector < string > words ; split ( words , strFlags , is_any_@@ of ( " , " ) ) ; BOOST_FOREACH ( string word , words ) { if ( ! mapFlagNames . count ( word ) ) BOOST_ERROR ( " Bad ▁ test : ▁ unknown ▁ verification ▁ flag ▁ ' " << word << " ' " ) ; flags |= mapFlagNames [ word ] ; } return flags ; } string FormatScriptFlags ( unsigned int flags ) { if ( flags == 0 ) { return " " ; } string ret ; std :: map < string , unsigned int > :: const_iterator it = mapFlagNames . begin ( ) ; while ( it != mapFlagNames . end ( ) ) { if ( flags & it -> second ) { ret += it -> first + " , " ; } it ++ ; } return ret . substr ( 0 , ret . size ( ) - 1 ) ; } BOOST_AUTO_TEST_SUITE ( transaction_tests ) BOOST_AUTO_TEST_CASE ( tx_valid ) { Array tests = read_json ( std :: string ( json_tests :: tx_valid , json_tests :: tx_valid + sizeof ( json_tests :: tx_valid ) ) ) ; ScriptError err ; BOOST_FOREACH ( Value & tv , tests ) { Array test = tv . get_array ( ) ; string strTest = write_string ( tv , false ) ; if ( test [ 0 ] . type ( ) == array_type ) { if ( test . size ( ) != 3 || test [ 1 ] . type ( ) != str_type || test [ 2 ] . type ( ) != str_type ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } map < COutPoint , CScript > mapprevOutScriptPubKeys ; Array inputs = test [ 0 ] . get_array ( ) ; bool fValid = true ; BOOST_FOREACH ( Value & input , inputs ) { if ( input . type ( ) != array_type ) { fValid = false ; break ; } Array vinput = input . get_array ( ) ; if ( vinput . size ( ) != 3 ) { fValid = false ; break ; } mapprevOutScriptPubKeys [ COutPoint ( uint256 ( vinput [ 0 ] . get_str ( ) ) , vinput [ 1 ] . get_int ( ) ) ] = ParseScript ( vinput [ 2 ] . get_str ( ) ) ; } if ( ! fValid ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } string transaction = test [ 1 ] . get_str ( ) ; CDataStream stream ( ParseHex ( transaction ) , SER_NETWORK , PROTOCOL_VERSION ) ; CTransaction tx ; stream >> tx ; CValidationState state ; BOOST_CHECK_MESSAGE ( CheckTransaction ( tx , state ) , strTest ) ; BOOST_CHECK ( state . IsValid ( ) ) ; for ( unsigned int i = 0 ; i < tx . vin . size ( ) ; i ++ ) { if ( ! mapprevOutScriptPubKeys . count ( tx . vin [ i ] . prevout ) ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; break ; } unsigned int verify_flags = ParseScriptFlags ( test [ 2 ] . get_str ( ) ) ; BOOST_CHECK_MESSAGE ( VerifyScript ( tx . vin [ i ] . scriptSig , mapprevOutScriptPubKeys [ tx . vin [ i ] . prevout ] , verify_flags , TransactionSignatureChecker ( & tx , i ) , & err ) , strTest ) ; BOOST_CHECK_MESSAGE ( err == SCRIPT_ERR_OK , ScriptErrorString ( err ) ) ; } } } } BOOST_AUTO_TEST_CASE ( tx_invalid ) { Array tests = read_json ( std :: string ( json_tests :: tx_invalid , json_tests :: tx_invalid + sizeof ( json_tests :: tx_invalid ) ) ) ; ScriptError err ; BOOST_FOREACH ( Value & tv , tests ) { Array test = tv . get_array ( ) ; string strTest = write_string ( tv , false ) ; if ( test [ 0 ] . type ( ) == array_type ) { if ( test . size ( ) != 3 || test [ 1 ] . type ( ) != str_type || test [ 2 ] . type ( ) != str_type ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } map < COutPoint , CScript > mapprevOutScriptPubKeys ; Array inputs = test [ 0 ] . get_array ( ) ; bool fValid = true ; BOOST_FOREACH ( Value & input , inputs ) { if ( input . type ( ) != array_type ) { fValid = false ; break ; } Array vinput = input . get_array ( ) ; if ( vinput . size ( ) != 3 ) { fValid = false ; break ; } mapprevOutScriptPubKeys [ COutPoint ( uint256 ( vinput [ 0 ] . get_str ( ) ) , vinput [ 1 ] . get_int ( ) ) ] = ParseScript ( vinput [ 2 ] . get_str ( ) ) ; } if ( ! fValid ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } string transaction = test [ 1 ] . get_str ( ) ; CDataStream stream ( ParseHex ( transaction ) , SER_NETWORK , PROTOCOL_VERSION ) ; CTransaction tx ; stream >> tx ; CValidationState state ; fValid = CheckTransaction ( tx , state ) && state . IsValid ( ) ; for ( unsigned int i = 0 ; i < tx . vin . size ( ) && fValid ; i ++ ) { if ( ! mapprevOutScriptPubKeys . count ( tx . vin [ i ] . prevout ) ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; break ; } unsigned int verify_flags = ParseScriptFlags ( test [ 2 ] . get_str ( ) ) ; fValid = VerifyScript ( tx . vin [ i ] . scriptSig , mapprevOutScriptPubKeys [ tx . vin [ i ] . prevout ] , verify_flags , TransactionSignatureChecker ( & tx , i ) , & err ) ; } BOOST_CHECK_MESSAGE ( ! fValid , strTest ) ; BOOST_CHECK_MESSAGE ( err != SCRIPT_ERR_OK , ScriptErrorString ( err ) ) ; } } } BOOST_AUTO_TEST_CASE ( basic_transaction_tests ) { unsigned char ch [ ] = { 0x01 , 0x00 , 0x00 , 0x00 , 0x01 , 0x6b , 0xff , 0x7f , 0xcd , 0x4f , 0x85 , 0x65 , 0xef , 0x40 , 0x6d , 0xd5 , 0xd6 , 0x3d , 0x4f , 0xf9 , 0x4f , 0x31 , 0x8f , 0xe8 , 0x20 , 0x27 , 0xfd , 0x4d , 0xc4 , 0x51 , 0xb0 , 0x44 , 0x74 , 0x01 , 0x9f , 0x74 , 0xb4 , 0x00 , 0x00 , 0x00 , 0x00 , 0x8c , 0x49 , 0x30 , 0x46 , 0x02 , 0x21 , 0x00 , 0xda , 0x0d , 0xc6 , 0xae , 0xce , 0xfe , 0x1e , 0x06 , 0xef , 0xdf , 0x05 , 0x77 , 0x37 , 0x57 , 0xde , 0xb1 , 0x68 , 0x82 , 0x09 , 0x30 , 0xe3 , 0xb0 , 0xd0 , 0x3f , 0x46 , 0xf5 , 0xfc , 0xf1 , 0x50 , 0xbf , 0x99 , 0x0c , 0x02 , 0x21 , 0x00 , 0xd2 , 0x5b , 0x5c , 0x87 , 0x04 , 0x00 , 0x76 , 0xe4 , 0xf2 , 0x53 , 0xf8 , 0x26 , 0x2e , 0x76 , 0x3e , 0x2d , 0xd5 , 0x1e , 0x7f , 0xf0 , 0xbe , 0x15 , 0x77 , 0x27 , 0xc4 , 0xbc , 0x42 , 0x80 , 0x7f , 0x17 , 0xbd , 0x39 , 0x01 , 0x41 , 0x04 , 0xe6 , 0xc2 , 0x6e , 0xf6 , 0x7d , 0xc6 , 0x10 , 0xd2 , 0xcd , 0x19 , 0x24 , 0x84 , 0x78 , 0x9a , 0x6c , 0xf9 , 0xae , 0xa9 , 0x93 , 0x0b , 0x94 , 0x4b , 0x7e , 0x2d , 0xb5 , 0x34 , 0x2b , 0x9d , 0x9e , 0x5b , 0x9f , 0xf7 , 0x9a , 0xff , 0x9a , 0x2e , 0xe1 , 0x97 , 0x8d , 0xd7 , 0xfd , 0x01 , 0xdf , 0xc5 , 0x22 , 0xee , 0x02 , 0x28 , 0x3d , 0x3b , 0x06 , 0xa9 , 0xd0 , 0x3a , 0xcf , 0x80 , 0x96 , 0x96 , 0x8d , 0x7d , 0xbb , 0x0f , 0x91 , 0x78 , 0xff , 0xff , 0xff , 0xff , 0x02 , 0x8b , 0xa7 , 0x94 , 0x0e , 0x00 , 0x00 , 0x00 , 0x00 , 0x19 , 0x76 , 0xa9 , 0x14 , 0xba , 0xde , 0xec , 0xfd , 0xef , 0x05 , 0x07 , 0x24 , 0x7f , 0xc8 , 0xf7 , 0x42 , 0x41 , 0xd7 , 0x3b , 0xc0 , 0x39 , 0x97 , 0x2d , 0x7b , 0x88 , 0xac , 0x40 , 0x94 , 0xa8 , 0x02 , 0x00 , 0x00 , 0x00 , 0x00 , 0x19 , 0x76 , 0xa9 , 0x14 , 0xc1 , 0x09 , 0x32 , 0x48 , 0x3f , 0xec , 0x93 , 0xed , 0x51 , 0xf5 , 0xfe , 0x95 , 0xe7 , 0x25 , 0x59 , 0xf2 , 0xcc , 0x70 , 0x43 , 0xf9 , 0x88 , 0xac , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 } ; vector < unsigned char > vch ( ch , ch + sizeof ( ch ) - 1 ) ; CDataStream stream ( vch , SER_DIS@@ K , CLIENT_VERSION ) ; CMutableTransaction tx ; stream >> tx ; CValidationState state ; BOOST_CHECK_MESSAGE ( CheckTransaction ( tx , state ) && state . IsValid ( ) , " Simple ▁ deserialized ▁ transaction ▁ should ▁ be ▁ valid . " ) ; tx . vin . push_back ( tx . vin [ 0 ] ) ; BOOST_CHECK_MESSAGE ( ! CheckTransaction ( tx , state ) || ! state . IsValid ( ) , " Transaction ▁ with ▁ duplicate ▁ txins ▁ should ▁ be ▁ invalid . " ) ; } static std :: vector < CMutableTransaction > SetupDummyInputs ( CBasicKeyStore & keystoreRet , CCoinsViewCache & coinsRet ) { std :: vector < CMutableTransaction > dummyTransactions ; dummyTransactions . resize ( 2 ) ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { key [ i ] . MakeNewKey ( i % 2 ) ; keystoreRet . AddKey ( key [ i ] ) ; } dummyTransactions [ 0 ] . vout . resize ( 2 ) ; dummyTransactions [ 0 ] . vout [ 0 ] . nValue = 11 * CENT ; dummyTransactions [ 0 ] . vout [ 0 ] . scriptPubKey << ToByteVector ( key [ 0 ] . GetPubKey ( ) ) << OP_CHECKSIG ; dummyTransactions [ 0 ] . vout [ 1 ] . nValue = 50 * CENT ; dummyTransactions [ 0 ] . vout [ 1 ] . scriptPubKey << ToByteVector ( key [ 1 ] . GetPubKey ( ) ) << OP_CHECKSIG ; coinsRet . ModifyCoins ( dummyTransactions [ 0 ] . GetHash ( ) ) -> FromTx ( dummyTransactions [ 0 ] , 0 ) ; dummyTransactions [ 1 ] . vout . resize ( 2 ) ; dummyTransactions [ 1 ] . vout [ 0 ] . nValue = 21 * CENT ; dummyTransactions [ 1 ] . vout [ 0 ] . scriptPubKey = GetScriptForDestination ( key [ 2 ] . GetPubKey ( ) . GetID ( ) ) ; dummyTransactions [ 1 ] . vout [ 1 ] . nValue = 22 * CENT ; dummyTransactions [ 1 ] . vout [ 1 ] . scriptPubKey = GetScriptForDestination ( key [ 3 ] . GetPubKey ( ) . GetID ( ) ) ; coinsRet . ModifyCoins ( dummyTransactions [ 1 ] . GetHash ( ) ) -> FromTx ( dummyTransactions [ 1 ] , 0 ) ; return dummyTransactions ; } BOOST_AUTO_TEST_CASE ( test_Get ) { CBasicKeyStore keystore ; CCoinsView coinsDummy ; CCoinsViewCache coins ( & coinsDummy ) ; std :: vector < CMutableTransaction > dummyTransactions = SetupDummyInputs ( keystore , coins ) ; CMutableTransaction t1 ; t1 . vin . resize ( 3 ) ; t1 . vin [ 0 ] . prevout . hash = dummyTransactions [ 0 ] . GetHash ( ) ; t1 . vin [ 0 ] . prevout . n = 1 ; t1 . vin [ 0 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) ; t1 . vin [ 1 ] . prevout . hash = dummyTransactions [ 1 ] . GetHash ( ) ; t1 . vin [ 1 ] . prevout . n = 0 ; t1 . vin [ 1 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) << std :: vector < unsigned char > ( 33 , 4 ) ; t1 . vin [ 2 ] . prevout . hash = dummyTransactions [ 1 ] . GetHash ( ) ; t1 . vin [ 2 ] . prevout . n = 1 ; t1 . vin [ 2 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) << std :: vector < unsigned char > ( 33 , 4 ) ; t1 . vout . resize ( 2 ) ; t1 . vout [ 0 ] . nValue = 90 * CENT ; t1 . vout [ 0 ] . scriptPubKey << OP_1 ; BOOST_CHECK ( AreInputsStandard ( t1 , coins ) ) ; BOOST_CHECK_EQUAL ( coins . GetValueIn ( t1 ) , ( 50 + 21 + 22 ) * CENT ) ; t1 . vin [ 0 ] . scriptSig << OP_11 ; BOOST_CHECK ( ! AreInputsStandard ( t1 , coins ) ) ; t1 . vin [ 0 ] . scriptSig = CScript ( ) ; BOOST_CHECK ( ! AreInputsStandard ( t1 , coins ) ) ; } BOOST_AUTO_TEST_CASE ( test_IsStandard ) { LOCK ( cs_main ) ; CBasicKeyStore keystore ; CCoinsView coinsDummy ; CCoinsViewCache coins ( & coinsDummy ) ; std :: vector < CMutableTransaction > dummyTransactions = SetupDummyInputs ( keystore , coins ) ; CMutableTransaction t ; t . vin . resize ( 1 ) ; t . vin [ 0 ] . prevout . hash = dummyTransactions [ 0 ] . GetHash ( ) ; t . vin [ 0 ] . prevout . n = 1 ; t . vin [ 0 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) ; t . vout . resize ( 1 ) ; t . vout [ 0 ] . nValue = 90 * CENT ; CKey key ; key . MakeNewKey ( true ) ; t . vout [ 0 ] . scriptPubKey = GetScriptForDestination ( key . GetPubKey ( ) . GetID ( ) ) ; string reason ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . nValue = 501 ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . nValue = 601 ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_1 ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3800" ) ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout . resize ( 1 ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout . resize ( 2 ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; t . vout [ 1 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; t . vout [ 1 ] . scriptPubKey = CScript ( ) << OP_RETURN ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN ; t . vout [ 1 ] . scriptPubKey = CScript ( ) << OP_RETURN ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
<DOCUMENT_ID="atido@@ t3/Ori@@ zon-5@@ 10/tree/master/src/server/@@ authserver/Main.cpp"> # include < ace / Dev_Poll_Reactor . h > # include < ace / TP_Reactor . h > # include < ace / ACE . h > # include < ace / Sig_Handler . h > # include < openssl / opensslv . h > # include < openssl / crypto . h > # include " Common . h " # include " Database / DatabaseEnv . h " # include " Configuration / Config . h " # include " Log . h " # include " SystemConfig . h " # include " Util . h " # include " SignalHandler . h " # include " RealmList . h " # include " RealmAcceptor . h " # ifndef _TRINITY_REALM_CONFIG # define _TRINITY_REALM_CONFIG " authserver . conf " # endif bool StartDB ( ) ; void StopDB ( ) ; bool stopEvent = false ; LoginDatabaseWorkerPool LoginDatabase ; class AuthServerSignalHandler : public Trinity :: SignalHandler { public : virtual void HandleSig@@ nal ( int SigNum ) { switch ( SigNum ) { case SIGINT : case SIGTERM : stopEvent = true ; break ; } } } ; void usage ( const char * prog ) { sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Usage : ▁ \n ▁ % s ▁ [ < options > ] \n " " ▁ ▁ ▁ ▁ - c ▁ config _ file ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ use ▁ config _ file ▁ as ▁ configuration ▁ file \n " , prog ) ; } extern int main ( int argc , char * * argv ) { char const * cfg_file = _TRINITY_REALM_CONFIG ; int c = 1 ; while ( c < argc ) { if ( strcmp ( argv [ c ] , " - c " ) == 0 ) { if ( ++ c >= argc ) { printf ( " Runtime - Error : ▁ - c ▁ option ▁ requires ▁ an ▁ input ▁ argument \n " ) ; usage ( argv [ 0 ] ) ; return 1 ; } else cfg_file = argv [ c ] ; } ++ c ; } if ( ! ConfigMgr :: Load ( cfg_file ) ) { printf ( " Invalid ▁ or ▁ missing ▁ configuration ▁ file ▁ : ▁ % s \n " , cfg_file ) ; printf ( " Verify ▁ that ▁ the ▁ file ▁ exists ▁ and ▁ has ▁ \ ' [ authserver ] \ ' ▁ written ▁ in ▁ the ▁ top ▁ of ▁ the ▁ file ! \n " ) ; return 1 ; } sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " % s ▁ ( authserver ) " , _FULLVERSION ) ; sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " < Ctrl - C > ▁ to ▁ stop . \n " ) ; sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Using ▁ configuration ▁ file ▁ % s . " , cfg_file ) ; sLog -> outWar@@ n ( LOG_FILTER_AUTHSERVER , " % s ▁ ( Library : ▁ % s ) " , OPENS@@ SL_VERSION_TEXT , SSLeay_@@ version ( SSLEAY_@@ VERSION ) ) ; # if defined ( ACE_HAS_EVENT_POLL ) || defined ( ACE_HAS_DEV_POLL ) ACE_Reactor :: instance ( new ACE_Reactor ( new ACE_Dev_Poll_Reactor ( ACE :: max_handles ( ) , 1 ) , 1 ) , true ) ; # else ACE_Reactor :: instance ( new ACE_Reactor ( new ACE_TP_Reactor ( ) , true ) , true ) ; # endif sLog -> outDebug ( LOG_FILTER_AUTHSERVER , " Max ▁ allowed ▁ open ▁ files ▁ is ▁ % d " , ACE :: max_handles ( ) ) ; std :: string pidfile = ConfigMgr :: GetStringDefault ( " PidFile " , " " ) ; if ( ! pidfile . empty ( ) ) { uint32 pid = CreatePID@@ File ( pidfile ) ; if ( ! pid ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Cannot ▁ create ▁ PID ▁ file ▁ % s . \n " , pidfile . c_str ( ) ) ; return 1 ; } sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Daemon ▁ PID : ▁ % u \n " , pid ) ; } if ( ! StartDB ( ) ) return 1 ; sLog -> SetRealmID ( 0 ) ; sRealmList -> Initialize ( ConfigMgr :: GetIntDefault ( " RealmsState@@ UpdateDelay " , 20 ) ) ; if ( sRealmList -> size ( ) == 0 ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " No ▁ valid ▁ realms ▁ specified . " ) ; return 1 ; } RealmAcceptor acceptor ; int32 rmport = ConfigMgr :: GetIntDefault ( " RealmServerPort " , 3724 ) ; if ( rmport < 0 || rmport > 0xFFFF ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Specified ▁ port ▁ out ▁ of ▁ allowed ▁ range ▁ ( 1-65535 ) " ) ; return 1 ; } std :: string bind_ip = ConfigMgr :: GetStringDefault ( " BindIP " , "0.0.0.0" ) ; ACE_INET_@@ Addr bind_addr ( uint16 ( rmport ) , bind_ip . c_str ( ) ) ; if ( acceptor . open ( bind_addr , ACE_Reactor :: instance ( ) , ACE_NONBLOCK ) == - 1 ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Auth ▁ server ▁ can ▁ not ▁ bind ▁ to ▁ % s : % d " , bind_ip . c_str ( ) , rmport ) ; return 1 ; } AuthServerSignalHandler SignalINT , SignalTERM ; ACE_Sig_Handler Handler ; Handler . register_handler ( SIGINT , & SignalINT ) ; Handler . register_handler ( SIGTERM , & SignalTERM ) ; # ifdef _WIN32 { HANDLE hProcess = GetCurrentProcess ( ) ; uint32 Aff = ConfigMgr :: GetIntDefault ( " UseProcessors " , 0 ) ; if ( Aff > 0 ) { ULONG_PTR appAff ; ULONG_PTR sysAff ; if ( GetProcessAffinityMask ( hProcess , & appAff , & sysAff ) ) { ULONG_PTR curAff = Aff & appAff ; if ( ! curAff ) sLog -> outError ( LOG_FILTER_AUTHSERVER , " Processors ▁ marked ▁ in ▁ UseProcessors ▁ bitmask ▁ ( hex ) ▁ % x ▁ not ▁ accessi@@ ble ▁ for ▁ authserver . ▁ Acces@@ sible ▁ processors ▁ bitmask ▁ ( hex ) : ▁ % x " , Aff , appAff ) ; else if ( SetProcessAffinityMask ( hProcess , curAff ) ) sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Using ▁ processors ▁ ( bitmask , ▁ hex ) : ▁ % x " , curAff ) ; else sLog -> outError ( LOG_FILTER_AUTHSERVER , " Can ' t ▁ set ▁ used ▁ processors ▁ ( hex ) : ▁ % x " , curAff ) ; } } bool Prio = ConfigMgr :: GetBoolDefault ( " ProcessPriority " , false ) ; if ( Prio ) { if ( SetPriorityClass ( hProcess , HIGH_PRIOR@@ ITY_CLASS ) ) sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " The ▁ auth ▁ server ▁ process ▁ priority ▁ class ▁ has ▁ been ▁ set ▁ to ▁ HIGH " ) ; else sLog -> outError ( LOG_FILTER_AUTHSERVER , " Can ' t ▁ set ▁ auth ▁ server ▁ process ▁ priority ▁ class . " ) ; } } # endif uint32 numLoops = ( ConfigMgr :: GetIntDefault ( " MaxPingTime " , 30 ) * ( MINUTE * 1000000 / 100000 ) ) ; uint32 loopCounter = 0 ; while ( ! stopEvent ) { ACE_Time_@@ Value interval ( 0 , 100000 ) ; if ( ACE_Reactor :: instance ( ) -> run_reactor_ev@@ ent_loop ( interval ) == - 1 ) break ; if ( ( ++ loopCounter ) == numLoops ) { loopCounter = 0 ; sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Ping ▁ MySQL ▁ to ▁ keep ▁ connection ▁ alive " ) ; LoginDatabase . KeepAlive ( ) ; } } StopDB ( ) ; sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Halting ▁ process . . . " ) ; return 0 ; } bool StartDB ( ) { MySQL :: Library_Init ( ) ; std :: string dbstring = ConfigMgr :: GetStringDefault ( " LoginDatabaseInfo " , " " ) ; if ( dbstring . empty ( ) ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Database ▁ not ▁ specified " ) ; return false ; } int32 worker_threads = ConfigMgr :: GetIntDefault ( " LoginDatabase . WorkerThreads " , 1 ) ; if ( worker_threads < 1 || worker_threads > 32 ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Improper ▁ value ▁ specified ▁ for ▁ LoginDatabase . WorkerThreads , ▁ defaulting ▁ to ▁ 1 . " ) ; worker_threads = 1 ; } int32 synch_threads = ConfigMgr :: GetIntDefault ( " LoginDatabase . SynchThreads " , 1 ) ; if ( synch_threads < 1 || synch_threads > 32 ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Improper ▁ value ▁ specified ▁ for ▁ LoginDatabase . SynchThreads , ▁ defaulting ▁ to ▁ 1 . " ) ; synch_threads = 1 ; } if ( ! LoginDatabase . Open ( dbstring . c_str ( ) , uint8 ( worker_threads ) , uint8 ( synch_threads ) ) ) { sLog -> outError ( LOG_FILTER_AUTHSERVER , " Cannot ▁ connect ▁ to ▁ database " ) ; return false ; } sLog -> outInfo ( LOG_FILTER_AUTHSERVER , " Started ▁ auth ▁ database ▁ connection ▁ pool . " ) ; sLog -> EnableDBAppenders ( ) ; return true ; } void StopDB ( ) { LoginDatabase . Close ( ) ; MySQL :: Library_End ( ) ; } </DOCUMENT>
<DOCUMENT_ID="So@@ verance/EtherealLegend@@ s/tree/master/Ethereal@@ /Private/Ge@@ ar/Weapons/Rang@@ ed/Annihilator.cpp"> # include " Ethereal . h " # include " Annihilator . h " # define LOCTEXT_NAMESPACE " EtherealText " AAnnihilator :: AAnnihilator ( const FObjectInitializer & ObjectInitializer ) : Super ( ObjectInitializer ) { static ConstructorHelpers :: FObjectFinder < USkeletalMesh > SkeletalMeshObject ( TEXT ( " SkeletalMesh ' / Game / VFX / sphere _ skeletal . sphere _ skeletal ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UStaticMesh > StaticMeshObject ( TEXT ( " StaticMesh ' / Game / Weapons / Ranged / Anni . Anni ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UStaticMesh > OffhandMeshObject ( TEXT ( " StaticMesh ' / Game / VFX / sphere . sphere ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UTexture2D > LargeIconObject ( TEXT ( " Texture2D ' / Game / Blueprints / Widgets / UI - Images / Icons _ Gear / WeaponIcon _ Annihilator . WeaponIcon _ Annihilator ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UTexture2D > SmallIconObject ( TEXT ( " Texture2D ' / Game / Blueprints / Widgets / UI - Images / Icons _ Gear / WeaponIcon _ Annihilator - small . WeaponIcon _ Annihilator - small ' " ) ) ; Name = EMasterGearList :: GL_Annihilator ; NameText = LOCTEXT ( " AnnihilatorName " , " Annihilator " ) ; Type = EMasterGearTypes :: GT_Ranged ; TypeText = LOCTEXT ( " AnnihilatorType " , " Ranged " ) ; Description = " An ▁ embodi@@ ment ▁ of ▁ the ▁ Ethereal ▁ Virtue : ▁ Wrath . " ; Price = 40000 ; MPCost = 0.0f ; ATK = 50.0f ; DEF = 40.0f ; SPD = 20.0f ; HP = 500.0f ; MP = 250.0f ; LargeIcon = LargeIconObject . Object ; SmallIcon = SmallIconObject . Object ; SK_WeaponSkeletalMesh = SkeletalMeshObject . Object ; SM_WeaponStaticMesh = StaticMeshObject . Object ; SM_WeaponOffhandMesh = StaticMeshObject . Object ; WeaponSkeletalMesh -> SetSkeletalMesh ( SK_WeaponSkeletalMesh ) ; WeaponSkeletalMesh -> SetHiddenInGame ( true ) ; WeaponStaticMesh -> SetStaticMesh ( SM_WeaponStaticMesh ) ; WeaponStaticMesh -> SetWorldScale3D ( FVector ( 0.15f , 0.15f , 0.15f ) ) ; WeaponStaticMesh -> SetRelativeLocation ( FVector ( 20 , - 2 , - 2 ) ) ; WeaponStaticMesh -> SetRelativeRotation ( FRotator ( - 12 , - 90 , - 75 ) ) ; WeaponOffhandMesh -> SetStaticMesh ( SM_WeaponOffhandMesh ) ; WeaponOffhandMesh -> SetHiddenInGame ( true ) ; } void AAnnihilator :: BeginPlay ( ) { Super :: BeginPlay ( ) ; OnBind@@ Gear . AddDynamic ( this , & AAnnihilator :: BindWeapon ) ; } void AAnnihilator :: BindWeapon ( ) { if ( IsShown ) { ShowWeapon ( false , true , false ) ; } } # undef LOCTEXT_NAMESPACE </DOCUMENT>
<DOCUMENT_ID="ThomasXBM@@ C/XCSoar/tree/master/src/@@ Engine/Task@@ /Computer/DistanceStat@@ Computer.cpp"> # include " DistanceStatComputer . hpp " # include " Task / Stats / DistanceStat . hpp " void DistanceStatComputer :: CalcSpeed ( DistanceStat & data , fixed time ) { if ( positive ( time ) && data . IsDefined ( ) ) data . speed = data . GetDistance ( ) / time ; else data . speed = fixed ( 0 ) ; } </DOCUMENT>
<DOCUMENT_ID="cpp@@ isfun/GameEngine/tree/master/fore@@ ign/boost/libs/multi_@@ array/example/@@ subview@@ 2.cpp"> # include " boost / multi _ array . hpp " # include " boost / cstdlib . hpp " int main ( ) { using boost :: extents ; using boost :: indices ; typedef boost :: multi_array < int , 3 > array ; int data [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 } ; const int data_size = 24 ; array myarray ( extents [ 2 ] [ 3 ] [ 4 ] ) ; myarray . assign ( data , data + data_size ) ; typedef boost :: multi_array_@@ types :: index_range range ; array :: array_view < 3 > :: type myview = myarray [ indices [ range ( 0 , 2 ) ] [ range ( 1 , 3 ) ] [ range ( 0 , 4 , 2 ) ] ] ; for ( array :: index i = 0 ; i != 2 ; ++ i ) for ( array :: index j = 0 ; j != 2 ; ++ j ) for ( array :: index k = 0 ; k != 2 ; ++ k ) assert ( myview [ i ] [ j ] [ k ] == myarray [ i ] [ j + 1 ] [ k * 2 ] ) ; return boost :: exit_success ; } </DOCUMENT>
<DOCUMENT_ID="hack@@ lab-tur@@ ku/luum@@ uhillo/tree/master/source@@ /main.cpp"> # include " game . hpp " # include " server . hpp " # ifdef _WIN32 # include < Windows . h > # endif int main ( int argc , char * * argv ) { if ( game . start ( ) != 0 ) return - 1 ; int retcode = game . getServer ( ) -> start ( ) ; if ( retcode == 0 ) { # ifdef _WIN32 TerminateProcess ( GetCurrentProcess ( ) , EXIT_SUCCESS ) ; # endif return 0 ; } else return retcode ; } </DOCUMENT>
<DOCUMENT_ID="leighleigh@@ leigh/smo@@ l-pong@@ /tree/master/smo@@ l_pong/@@ DNSServer.cpp"> # include " . / DNSServer . h " # include < lwip / def . h > # include < Arduino . h > # define DEBUG # define DEBUG_OUTPUT Serial DNSServer :: DNSServer ( ) { _ttl = htonl ( 60 ) ; _errorReplyCode = DNSReplyCode :: NonExist@@ entDomain ; } bool DNSServer :: start ( const uint16_t & port , const String & domainName , const IPAddress & resolvedIP ) { _port = port ; _domainName = domainName ; _resolvedIP [ 0 ] = resolvedIP [ 0 ] ; _resolvedIP [ 1 ] = resolvedIP [ 1 ] ; _resolvedIP [ 2 ] = resolvedIP [ 2 ] ; _resolvedIP [ 3 ] = resolvedIP [ 3 ] ; downcaseAndRemoveWwwPrefix ( _domainName ) ; return _udp . begin ( _port ) == 1 ; } void DNSServer :: setErrorReplyCode ( const DNSReplyCode & replyCode ) { _errorReplyCode = replyCode ; } void DNSServer :: setTTL ( const uint32_t & ttl ) { _ttl = htonl ( ttl ) ; } void DNSServer :: stop ( ) { _udp . stop ( ) ; } void DNSServer :: downcaseAndRemoveWwwPrefix ( String & domainName ) { domainName . toLowerCase ( ) ; domainName . replace ( " www . " , " " ) ; } void DNSServer :: processNextRequest ( ) { _currentPacketSize = _udp . parsePacket ( ) ; if ( _currentPacketSize ) { _buffer = ( unsigned char * ) malloc ( _currentPacketSize * sizeof ( char ) ) ; _udp . read ( _buffer , _currentPacketSize ) ; _dnsHeader = ( DNSHeader * ) _buffer ; if ( _dnsHeader -> QR == DNS_QR_QUERY && _dnsHeader -> OPCode == DNS_OP@@ CODE_QUERY && requestIncludesOnlyOneQuestion ( ) && ( _domainName == " * " || getDomainNameWithoutWwwPrefix ( ) == _domainName ) ) { replyWithIP ( ) ; } else if ( _dnsHeader -> QR == DNS_QR_QUERY ) { replyWithCustomCode ( ) ; } free ( _buffer ) ; } } bool DNSServer :: requestIncludesOnlyOneQuestion ( ) { return ntohs ( _dnsHeader -> QDCount ) == 1 && _dnsHeader -> ANCount == 0 && _dnsHeader -> NSCount == 0 && _dnsHeader -> ARCount == 0 ; } String DNSServer :: getDomainNameWithoutWwwPrefix ( ) { String parsedDomainName = " " ; unsigned char * start = _buffer + 12 ; if ( * start == 0 ) { return parsedDomainName ; } int pos = 0 ; while ( true ) { unsigned char labelLength = * ( start + pos ) ; for ( int i = 0 ; i < labelLength ; i ++ ) { pos ++ ; parsedDomainName += ( char ) * ( start + pos ) ; } pos ++ ; if ( * ( start + pos ) == 0 ) { downcaseAndRemoveWwwPrefix ( parsedDomainName ) ; return parsedDomainName ; } else { parsedDomainName += " . " ; } } } void DNSServer :: replyWithIP ( ) { _dnsHeader -> QR = DNS_QR_RESPONSE ; _dnsHeader -> ANCount = _dnsHeader -> QDCount ; _dnsHeader -> QDCount = _dnsHeader -> QDCount ; _udp . beginPacket ( _udp . remoteIP ( ) , _udp . remotePort ( ) ) ; _udp . write ( _buffer , _currentPacketSize ) ; _udp . write ( ( uint8_t ) 192 ) ; _udp . write ( ( uint8_t ) 12 ) ; _udp . write ( ( uint8_t ) 0 ) ; _udp . write ( ( uint8_t ) 1 ) ; _udp . write ( ( uint8_t ) 0 ) ; _udp . write ( ( uint8_t ) 1 ) ; _udp . write ( ( unsigned char * ) & _ttl , 4 ) ; _udp . write ( ( uint8_t ) 0 ) ; _udp . write ( ( uint8_t ) 4 ) ; _udp . write ( _resolvedIP , sizeof ( _resolvedIP ) ) ; _udp . endPacket ( ) ; # ifdef DEBUG DEBUG_OUTPUT . print ( " DNS ▁ responds : ▁ " ) ; DEBUG_OUTPUT . print ( _resolvedIP [ 0 ] ) ; DEBUG_OUTPUT . print ( " . " ) ; DEBUG_OUTPUT . print ( _resolvedIP [ 1 ] ) ; DEBUG_OUTPUT . print ( " . " ) ; DEBUG_OUTPUT . print ( _resolvedIP [ 2 ] ) ; DEBUG_OUTPUT . print ( " . " ) ; DEBUG_OUTPUT . print ( _resolvedIP [ 3 ] ) ; DEBUG_OUTPUT . print ( " ▁ for ▁ " ) ; DEBUG_OUTPUT . println ( getDomainNameWithoutWwwPrefix ( ) ) ; # endif } void DNSServer :: replyWithCustomCode ( ) { _dnsHeader -> QR = DNS_QR_RESPONSE ; _dnsHeader -> RCode = ( unsigned char ) _errorReplyCode ; _dnsHeader -> QDCount = 0 ; _udp . beginPacket ( _udp . remoteIP ( ) , _udp . remotePort ( ) ) ; _udp . write ( _buffer , sizeof ( DNSHeader ) ) ; _udp . endPacket ( ) ; } </DOCUMENT>
<DOCUMENT_ID="alessonren@@ ato/TrinityCore/tree/master/src/server/game/@@ Battlegrounds/Zon@@ es/BattlegroundAB@@ .cpp"> # include " BattlegroundAB . h " # include " WorldPacket . h " # include " BattlegroundMgr . h " # include " Creature . h " # include " Language . h " # include " Player . h " # include " Util . h " # include " WorldSession . h " BattlegroundAB :: BattlegroundAB ( ) { m_IsInformedNearVictory = false ; m_BuffChange = true ; BgObjects . resize ( BG_AB_OBJECT_MAX ) ; BgCreatures . resize ( BG_AB_ALL_NODES_COUNT + 5 ) ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { m_Nodes [ i ] = 0 ; m_prevNodes [ i ] = 0 ; m_NodeTimers [ i ] = 0 ; m_BannerTimers [ i ] . timer = 0 ; m_BannerTimers [ i ] . type = 0 ; m_BannerTimers [ i ] . teamIndex = 0 ; } for ( uint8 i = 0 ; i < BG_TEAMS_COUNT ; ++ i ) { m_lastTick [ i ] = 0 ; m_HonorScoreTics [ i ] = 0 ; m_ReputationScoreTics [ i ] = 0 ; m_TeamScores500Disadvantage [ i ] = false ; } m_HonorTics = 0 ; m_ReputationTics = 0 ; StartMessageIds [ BG_STARTING_EVENT_FIRST ] = LANG_BG_AB_START_TWO_MINUTES ; StartMessageIds [ BG_STARTING_EVENT_SECOND ] = LANG_BG_AB_START_ONE_MINUTE ; StartMessageIds [ BG_STARTING_EVENT_THI@@ RD ] = LANG_BG_AB_START_HALF_MINUTE ; StartMessageIds [ BG_STARTING_EVENT_FOURTH ] = LANG_BG_AB_HAS_BE@@ GUN ; } BattlegroundAB :: ~ BattlegroundAB ( ) { } void BattlegroundAB :: PostUpdateImpl ( uint32 diff ) { if ( GetStatus ( ) == STATUS_IN_PROGRESS ) { int team_points [ BG_TEAMS_COUNT ] = { 0 , 0 } ; for ( int node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) { if ( m_BannerTimers [ node ] . timer ) { if ( m_BannerTimers [ node ] . timer > diff ) m_BannerTimers [ node ] . timer -= diff ; else { m_BannerTimers [ node ] . timer = 0 ; _CreateBanner ( node , m_BannerTimers [ node ] . type , m_BannerTimers [ node ] . teamIndex , false ) ; } } if ( m_NodeTimers [ node ] ) { if ( m_NodeTimers [ node ] > diff ) m_NodeTimers [ node ] -= diff ; else { m_NodeTimers [ node ] = 0 ; uint8 teamIndex = m_Nodes [ node ] - 1 ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] += 2 ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; _NodeOccupied ( node , ( teamIndex == 0 ) ? ALLIANCE : HORDE ) ; if ( teamIndex == 0 ) { SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_ALLIANCE , NULL , LANG_BG_AB_ALLY , _GetNodeNameId ( node ) ) ; PlaySoundToAll ( BG_AB_SOUND_NODE_CAPTURED_ALLIANCE ) ; } else { SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_HORDE , NULL , LANG_BG_AB_HORDE , _GetNodeNameId ( node ) ) ; PlaySoundToAll ( BG_AB_SOUND_NODE_CAPTURED_HORDE ) ; } } } for ( int team = 0 ; team < BG_TEAMS_COUNT ; ++ team ) if ( m_Nodes [ node ] == team + BG_AB_NODE_TYPE_OCCUPIED ) ++ team_points [ team ] ; } for ( int team = 0 ; team < BG_TEAMS_COUNT ; ++ team ) { int points = team_points [ team ] ; if ( ! points ) continue ; m_lastTick [ team ] += diff ; if ( m_lastTick [ team ] > BG_AB_TickIntervals [ points ] ) { m_lastTick [ team ] -= BG_AB_TickIntervals [ points ] ; m_TeamScores [ team ] += BG_AB_TickPoints [ points ] ; m_HonorScoreTics [ team ] += BG_AB_TickPoints [ points ] ; m_ReputationScoreTics [ team ] += BG_AB_TickPoints [ points ] ; if ( m_ReputationScoreTics [ team ] >= m_ReputationTics ) { ( team == TEAM_ALLIANCE ) ? RewardReputationToTeam ( 509 , 10 , ALLIANCE ) : RewardReputationToTeam ( 510 , 10 , HORDE ) ; m_ReputationScoreTics [ team ] -= m_ReputationTics ; } if ( m_HonorScoreTics [ team ] >= m_HonorTics ) { RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ( team == TEAM_ALLIANCE ) ? ALLIANCE : HORDE ) ; m_HonorScoreTics [ team ] -= m_HonorTics ; } if ( ! m_IsInformedNearVictory && m_TeamScores [ team ] > BG_AB_WARNING_NEAR_VICTORY_SCORE ) { if ( team == TEAM_ALLIANCE ) SendMessageToAll ( LANG_BG_AB_A_NEAR_VICTORY , CHAT_MSG_BG_SYSTEM_NEUTRAL ) ; else SendMessageToAll ( LANG_BG_AB_H_NEAR_VICTORY , CHAT_MSG_BG_SYSTEM_NEUTRAL ) ; PlaySoundToAll ( BG_AB_SOUND_NEAR_VICTORY ) ; m_IsInformedNearVictory = true ; } if ( m_TeamScores [ team ] > BG_AB_MAX_TEAM_SCORE ) m_TeamScores [ team ] = BG_AB_MAX_TEAM_SCORE ; if ( team == TEAM_ALLIANCE ) UpdateWorldState ( BG_AB_OP_RESOURCES_ALLY , m_TeamScores [ team ] ) ; else if ( team == TEAM_HORDE ) UpdateWorldState ( BG_AB_OP_RESOURCES_HORDE , m_TeamScores [ team ] ) ; uint8 otherTeam = ( team + 1 ) % BG_TEAMS_COUNT ; if ( m_TeamScores [ team ] > m_TeamScores [ otherTeam ] + 500 ) m_TeamScores500Disadvantage [ otherTeam ] = true ; } } if ( m_TeamScores [ TEAM_ALLIANCE ] >= BG_AB_MAX_TEAM_SCORE ) EndBattleground ( ALLIANCE ) ; else if ( m_TeamScores [ TEAM_HORDE ] >= BG_AB_MAX_TEAM_SCORE ) EndBattleground ( HORDE ) ; } } void BattlegroundAB :: StartingEventCloseDoors ( ) { for ( int obj = BG_AB_OBJECT_BANNER_NEUTRAL ; obj < BG_AB_DYNAMIC_NODES_COUNT * 8 ; ++ obj ) SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT * 3 ; ++ i ) SpawnBGObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + i , RESPAWN_ONE_DAY ) ; DoorClose ( BG_AB_OBJECT_GATE_A ) ; DoorClose ( BG_AB_OBJECT_GATE_H ) ; SpawnBGObject ( BG_AB_OBJECT_GATE_A , RESPAWN_IMMEDIATELY ) ; SpawnBGObject ( BG_AB_OBJECT_GATE_H , RESPAWN_IMMEDIATELY ) ; _NodeOccupied ( BG_AB_SPIRIT_ALIANCE , ALLIANCE ) ; _NodeOccupied ( BG_AB_SPIRIT_HORDE , HORDE ) ; } void BattlegroundAB :: StartingEventOpenDoors ( ) { for ( int banner = BG_AB_OBJECT_BANNER_NEUTRAL , i = 0 ; i < 5 ; banner += 8 , ++ i ) SpawnBGObject ( banner , RESPAWN_IMMEDIATELY ) ; for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { uint8 buff = urand ( 0 , 2 ) ; SpawnBGObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + buff + i * 3 , RESPAWN_IMMEDIATELY ) ; } DoorOpen ( BG_AB_OBJECT_GATE_A ) ; DoorOpen ( BG_AB_OBJECT_GATE_H ) ; StartTimedAchievement ( ACHIEVEMENT_TIMED_TYPE_EVENT , AB_EVENT_START_@@ BATTLE ) ; } void BattlegroundAB :: AddPlayer ( Player * player ) { Battleground :: AddPlayer ( player ) ; PlayerSco@@ res [ player -> GetGUID ( ) ] = new BattlegroundABScore ( player -> GetGUID ( ) , player -> GetBGTeam ( ) ) ; } void BattlegroundAB :: RemovePlayer ( Player * , ObjectGuid , uint32 ) { } void BattlegroundAB :: HandleAreaTrigger ( Player * player , uint32 trigger , bool entered ) { if ( GetStatus ( ) != STATUS_IN_PROGRESS ) return ; switch ( trigger ) { case 3948 : if ( player -> GetTeam ( ) != ALLIANCE ) player -> GetSession ( ) -> SendNotification ( " Only ▁ The ▁ Alliance ▁ can ▁ use ▁ that ▁ portal " ) ; else player -> LeaveBattleground ( ) ; break ; case 3949 : if ( player -> GetTeam ( ) != HORDE ) player -> GetSession ( ) -> SendNotification ( " Only ▁ The ▁ Horde ▁ can ▁ use ▁ that ▁ portal " ) ; else player -> LeaveBattleground ( ) ; break ; case 3866 : case 3869 : case 3867 : case 3868 : case 3870 : case 4020 : case 4021 : case 4674 : default : Battleground :: HandleAreaTrigger ( player , trigger , entered ) ; break ; } } void BattlegroundAB :: _CreateBanner ( uint8 node , uint8 type , uint8 teamIndex , bool delay ) { if ( delay ) { m_BannerTimers [ node ] . timer = 2000 ; m_BannerTimers [ node ] . type = type ; m_BannerTimers [ node ] . teamIndex = teamIndex ; return ; } uint8 obj = node * 8 + type + teamIndex ; SpawnBGObject ( obj , RESPAWN_IMMEDIATELY ) ; if ( ! type ) return ; obj = node * 8 + ( ( type == BG_AB_NODE_TYPE_OCCUPIED ) ? ( 5 + teamIndex ) : 7 ) ; SpawnBGObject ( obj , RESPAWN_IMMEDIATELY ) ; } void BattlegroundAB :: _DelBanner ( uint8 node , uint8 type , uint8 teamIndex ) { uint8 obj = node * 8 + type + teamIndex ; SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; if ( ! type ) return ; obj = node * 8 + ( ( type == BG_AB_NODE_TYPE_OCCUPIED ) ? ( 5 + teamIndex ) : 7 ) ; SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; } int32 BattlegroundAB :: _GetNodeNameId ( uint8 node ) { switch ( node ) { case BG_AB_NODE_STABLES : return LANG_BG_AB_NODE_STABLES ; case BG_AB_NODE_BLACKSMITH : return LANG_BG_AB_NODE_BLACKSMITH ; case BG_AB_NODE_FARM : return LANG_BG_AB_NODE_FARM ; case BG_AB_NODE_LUMBER_MILL : return LANG_BG_AB_NODE_LUMBER_MILL ; case BG_AB_NODE_GOLD_MINE : return LANG_BG_AB_NODE_GOLD_MINE ; default : ABORT ( ) ; } return 0 ; } void BattlegroundAB :: FillInitialWorldStates ( WorldPackets :: WorldState :: InitWorldStates & packet ) { const uint8 plusArray [ ] = { 0 , 2 , 3 , 0 , 1 } ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_NODEICONS [ node ] ) , int32 ( ( m_Nodes [ node ] == 0 ) ? 1 : 0 ) ) ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) for ( uint8 i = 1 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_NODESTATES [ node ] + plusArray [ i ] ) , int32 ( ( m_Nodes [ node ] == i ) ? 1 : 0 ) ) ; uint8 ally = 0 , horde = 0 ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) if ( m_Nodes [ node ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ node ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_OCCUPIED_BASES_ALLY ) , int32 ( ally ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_OCCUPIED_BASES_HORDE ) , int32 ( horde ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_MAX ) , int32 ( BG_AB_MAX_TEAM_SCORE ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_WARNING ) , int32 ( BG_AB_WARNING_NEAR_VICTORY_SCORE ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_ALLY ) , int32 ( m_TeamScores [ TEAM_ALLIANCE ] ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_HORDE ) , int32 ( m_TeamScores [ TEAM_HORDE ] ) ) ; packet . Worldstates . emplace_back ( uint32 ( 0x745 ) , 0x2 ) ; } void BattlegroundAB :: _SendNodeUpdate ( uint8 node ) { const uint8 plusArray [ ] = { 0 , 2 , 3 , 0 , 1 } ; if ( m_prevNodes [ node ] ) UpdateWorldState ( BG_AB_OP_NODESTATES [ node ] + plusArray [ m_prevNodes [ node ] ] , 0 ) ; else UpdateWorldState ( BG_AB_OP_NODEICONS [ node ] , 0 ) ; UpdateWorldState ( BG_AB_OP_NODESTATES [ node ] + plusArray [ m_Nodes [ node ] ] , 1 ) ; uint8 ally = 0 , horde = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; UpdateWorldState ( BG_AB_OP_OCCUPIED_BASES_ALLY , ally ) ; UpdateWorldState ( BG_AB_OP_OCCUPIED_BASES_HORDE , horde ) ; } void BattlegroundAB :: _NodeOccupied ( uint8 node , Team team ) { if ( ! AddSpi@@ ritGuide ( node , BG_AB_SpiritGui@@ dePos [ node ] , GetTeamIndexByTeamId ( team ) ) ) TC_LOG_ERROR ( " bg . battleground " , " Failed ▁ to ▁ spawn ▁ spirit ▁ guide ! ▁ point : ▁ % u , ▁ team : ▁ % u , ▁ " , node , team ) ; if ( node >= BG_AB_DYNAMIC_NODES_COUNT ) return ; uint8 capturedNodes = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == GetTeamIndexByTeamId ( team ) + BG_AB_NODE_TYPE_OCCUPIED && ! m_NodeTimers [ i ] ) ++ capturedNodes ; if ( capturedNodes >= 5 ) CastSpellOnTeam ( SPELL_AB_QUEST_REWARD_5_BASES , team ) ; if ( capturedNodes >= 4 ) CastSpellOnTeam ( SPELL_AB_QUEST_REWARD_4_BASES , team ) ; Creature * trigger = ! BgCreatures [ node + 7 ] ? GetBGCreature ( node + 7 ) : NULL ; if ( ! trigger ) trigger = AddCreature ( WORLD_TRIGGER , node + 7 , BG_AB_NodePositions [ node ] , GetTeamIndexByTeamId ( team ) ) ; if ( trigger ) { trigger -> setFaction ( team == ALLIANCE ? 84 : 83 ) ; trigger -> CastSpell ( trigger , SPELL_HON@@ ORABLE_DEFENDER_@@ 25Y , false ) ; } } void BattlegroundAB :: _NodeDeOccupied ( uint8 node ) { if ( node >= BG_AB_DYNAMIC_NODES_COUNT ) return ; if ( node < BG_AB_DYNAMIC_NODES_COUNT ) DelCreature ( node + 7 ) ; RelocateDe@@ adPlayers ( BgCreatures [ node ] ) ; DelCreature ( node ) ; } void BattlegroundAB :: EventPlayer@@ ClickedOnFlag ( Player * source , GameObject * ) { if ( GetStatus ( ) != STATUS_IN_PROGRESS ) return ; uint8 node = BG_AB_NODE_STABLES ; GameObject * obj = GetBgMap ( ) -> GetGameObject ( BgObjects [ node * 8 + 7 ] ) ; while ( ( node < BG_AB_DYNAMIC_NODES_COUNT ) && ( ( ! obj ) || ( ! source -> IsWith@@ inDistInMap ( obj , 10 ) ) ) ) { ++ node ; obj = GetBgMap ( ) -> GetGameObject ( BgObjects [ node * 8 + BG_AB_OBJECT_AURA_CONTESTED ] ) ; } if ( node == BG_AB_DYNAMIC_NODES_COUNT ) { return ; } TeamId teamIndex = GetTeamIndexByTeamId ( source -> GetTeam ( ) ) ; if ( ! ( m_Nodes [ node ] == 0 || teamIndex == m_Nodes [ node ] % 2 ) ) return ; source -> RemoveAurasWithInterrupt@@ Flags ( AURA_INTERRUP@@ T_FLAG_ENTER_@@ PVP_COMB@@ AT ) ; uint32 sound = 0 ; if ( m_Nodes [ node ] == BG_AB_NODE_TYPE_NEUTRAL ) { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + 1 ; _DelBanner ( node , BG_AB_NODE_TYPE_NEUTRAL , 0 ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == 0 ) SendMessage2ToAll ( LANG_BG_AB_NODE_CLAIMED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) , LANG_BG_AB_ALLY ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_CLAIMED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) , LANG_BG_AB_HORDE ) ; sound = BG_AB_SOUND_NODE_CLAIMED ; } else if ( ( m_Nodes [ node ] == BG_AB_NODE_STATUS_ALLY_CONTESTED ) || ( m_Nodes [ node ] == BG_AB_NODE_STATUS_HORDE_CONTESTED ) ) { if ( m_prevNodes [ node ] < BG_AB_NODE_TYPE_OCCUPIED ) { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_CONTESTED ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; } else { UpdatePlayerScore ( source , SCORE_BASES_DEFENDED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_OCCUPIED ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = 0 ; _NodeOccupied ( node , ( teamIndex == TEAM_ALLIANCE ) ? ALLIANCE : HORDE ) ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_DEFENDED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_DEFENDED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; } sound = ( teamIndex == TEAM_ALLIANCE ) ? BG_AB_SOUND_NODE_ASSAULTED_ALLIANCE : BG_AB_SOUND_NODE_ASSAULTED_HORDE ; } else { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_CONTESTED ; _DelBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; _NodeDeOccupied ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; sound = ( teamIndex == TEAM_ALLIANCE ) ? BG_AB_SOUND_NODE_ASSAULTED_ALLIANCE : BG_AB_SOUND_NODE_ASSAULTED_HORDE ; } if ( m_Nodes [ node ] >= BG_AB_NODE_TYPE_OCCUPIED ) { if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_ALLIANCE , NULL , LANG_BG_AB_ALLY , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_HORDE , NULL , LANG_BG_AB_HORDE , _GetNodeNameId ( node ) ) ; } PlaySoundToAll ( sound ) ; } uint32 BattlegroundAB :: GetPrematureWinner ( ) { uint8 ally = 0 , horde = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; if ( ally > horde ) return ALLIANCE ; else if ( horde > ally ) return HORDE ; return Battleground :: GetPrematureWinner ( ) ; } bool BattlegroundAB :: SetupBattleground ( ) { for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { if ( ! AddObject ( BG_AB_OBJECT_BANNER_NEUTRAL + 8 * i , BG_AB_OBJECTID_NODE_BANN@@ ER_0 + i , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_CONT_A + 8 * i , BG_AB_OBJECTID_BANNER_CONT_A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_CONT_H + 8 * i , BG_AB_OBJECTID_BANNER_CONT_H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_ALLY + 8 * i , BG_AB_OBJECTID_BANNER_A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_HORDE + 8 * i , BG_AB_OBJECTID_BANNER_H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_ALLY + 8 * i , BG_AB_OBJECTID_AURA_A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_@@ HORDE + 8 * i , BG_AB_OBJECTID_AURA_H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_CONTESTED + 8 * i , BG_AB_OBJECTID_AURA_C , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) ) { TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ some ▁ object ▁ Battleground ▁ not ▁ created ! " ) ; return false ; } } if ( ! AddObject ( BG_AB_OBJECT_GATE_A , BG_AB_OBJECTID_GATE_A , BG_AB_DoorPositions [ 0 ] [ 0 ] , BG_AB_DoorPositions [ 0 ] [ 1 ] , BG_AB_DoorPositions [ 0 ] [ 2 ] , BG_AB_DoorPositions [ 0 ] [ 3 ] , BG_AB_DoorPositions [ 0 ] [ 4 ] , BG_AB_DoorPositions [ 0 ] [ 5 ] , BG_AB_DoorPositions [ 0 ] [ 6 ] , BG_AB_DoorPositions [ 0 ] [ 7 ] , RESPAWN_IMMEDIATELY ) || ! AddObject ( BG_AB_OBJECT_GATE_H , BG_AB_OBJECTID_GATE_H , BG_AB_DoorPositions [ 1 ] [ 0 ] , BG_AB_DoorPositions [ 1 ] [ 1 ] , BG_AB_DoorPositions [ 1 ] [ 2 ] , BG_AB_DoorPositions [ 1 ] [ 3 ] , BG_AB_DoorPositions [ 1 ] [ 4 ] , BG_AB_DoorPositions [ 1 ] [ 5 ] , BG_AB_DoorPositions [ 1 ] [ 6 ] , BG_AB_DoorPositions [ 1 ] [ 7 ] , RESPAWN_IMMEDIATELY ) ) { TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ door ▁ object ▁ Battleground ▁ not ▁ created ! " ) ; return false ; } for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { if ( ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i , Buff_Entries [ 0 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i + 1 , Buff_Entries [ 1 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i + 2 , Buff_Entries [ 2 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) ) TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ buff ▁ object ! " ) ; } return true ; } void BattlegroundAB :: Reset ( ) { Battleground :: Reset ( ) ; m_TeamScores [ TEAM_ALLIANCE ] = 0 ; m_TeamScores [ TEAM_HORDE ] = 0 ; m_lastTick [ TEAM_ALLIANCE ] = 0 ; m_lastTick [ TEAM_HORDE ] = 0 ; m_HonorScoreTics [ TEAM_ALLIANCE ] = 0 ; m_HonorScoreTics [ TEAM_HORDE ] = 0 ; m_ReputationScoreTics [ TEAM_ALLIANCE ] = 0 ; m_ReputationScoreTics [ TEAM_HORDE ] = 0 ; m_IsInformedNearVictory = false ; bool isBGWeekend = sBattlegroundMgr -> IsBGWeekend ( GetTypeID ( ) ) ; m_HonorTics = ( isBGWeekend ) ? BG_AB_ABBGWeekendHonorTicks : BG_AB_NotABBGWeekendHonorTicks ; m_ReputationTics = ( isBGWeekend ) ? BG_AB_ABBGWeekendReputationTicks : BG_AB_NotABBGWeekendReputationTicks ; m_TeamScores500Disadvantage [ TEAM_ALLIANCE ] = false ; m_TeamScores500Disadvantage [ TEAM_HORDE ] = false ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { m_Nodes [ i ] = 0 ; m_prevNodes [ i ] = 0 ; m_NodeTimers [ i ] = 0 ; m_BannerTimers [ i ] . timer = 0 ; } for ( uint8 i = 0 ; i < BG_AB_ALL_NODES_COUNT + 5 ; ++ i ) if ( ! BgCreatures [ i ] . IsEmpty ( ) ) DelCreature ( i ) ; } void BattlegroundAB :: EndBattleground ( uint32 winner ) { if ( winner == ALLIANCE ) RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ALLIANCE ) ; if ( winner == HORDE ) RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , HORDE ) ; RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , HORDE ) ; RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ALLIANCE ) ; Battleground :: EndBattleground ( winner ) ; } WorldSafeLocsEntry const * BattlegroundAB :: GetClosestGraveYard ( Player * player ) { TeamId teamIndex = GetTeamIndexByTeamId ( player -> GetTeam ( ) ) ; std :: vector < uint8 > nodes ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == teamIndex + 3 ) nodes . push_back ( i ) ; WorldSafeLocsEntry const * good_entry = NULL ; if ( ! nodes . empty ( ) ) { float plr_x = player -> GetPositionX ( ) ; float plr_y = player -> GetPositionY ( ) ; float mindist = 999999.0f ; for ( uint8 i = 0 ; i < nodes . size ( ) ; ++ i ) { WorldSafeLocsEntry const * entry = sWorldSafeLocsStore . LookupEntry ( BG_AB_GraveyardIds [ nodes [ i ] ] ) ; if ( ! entry ) continue ; float dist = ( entry -> Loc . X - plr_x ) * ( entry -> Loc . X - plr_x ) + ( entry -> Loc . Y - plr_y ) * ( entry -> Loc . Y - plr_y ) ; if ( mindist > dist ) { mindist = dist ; good_entry = entry ; } } nodes . clear ( ) ; } if ( ! good_entry ) good_entry = sWorldSafeLocsStore . LookupEntry ( BG_AB_GraveyardIds [ teamIndex + 5 ] ) ; return good_entry ; } bool BattlegroundAB :: UpdatePlayerScore ( Player * player , uint32 type , uint32 value , bool doAddHonor ) { if ( ! Battleground :: UpdatePlayerScore ( player , type , value , doAddHonor ) ) return false ; switch ( type ) { case SCORE_BASES_ASSAULTED : player -> UpdateAchievementCriteria ( ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE , AB_OBJECTIVE_ASSAULT_BASE ) ; break ; case SCORE_BASES_DEFENDED : player -> UpdateAchievementCriteria ( ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE , AB_OBJECTIVE_DEFEND_BASE ) ; break ; default : break ; } return true ; } bool BattlegroundAB :: IsAll@@ NodesControlled@@ ByTeam ( uint32 team ) const { uint32 count = 0 ; for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( ( team == ALLIANCE && m_Nodes [ i ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) || ( team == HORDE && m_Nodes [ i ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ) ++ count ; return count == BG_AB_DYNAMIC_NODES_COUNT ; } bool BattlegroundAB :: CheckAchievementCriteriaMeet ( uint32 criteriaId , Player const * player , Unit const * target , uint32 miscvalue ) { switch ( criteriaId ) { case BG_CRITERIA_@@ CHECK_RESILIENT_VIC@@ TORY : return m_TeamScores500Disadvantage [ GetTeamIndexByTeamId ( player -> GetTeam ( ) ) ] ; } return Battleground :: CheckAchievementCriteriaMeet ( criteriaId , player , target , miscvalue ) ; } </DOCUMENT>
<DOCUMENT_ID="lassoan/CTK/tree/master/Libs/Core/ctkWorkflowStep.cpp"> # include < QDebug > # include < QMetaType > # include < QObject > # include < QState > # include " ctkWorkflowStep . h " # include " ctkWorkflowStep _ p . h " # include " ctkWorkflow . h " # include " ctkLogger . h " # include < iostream > static ctkLogger logger ( " org . commontk . core . ctkWorkflowStep " ) ; ctkWorkflowStepPrivate :: ctkWorkflowStepPrivate ( ctkWorkflowStep & object ) : q_ptr ( & object ) { qRegisterMetaType < ctkWorkflowStep * > ( " ctkWorkflowStep * " ) ; this -> Workflow = 0 ; this -> WidgetType = false ; this -> HasValidateCommand = false ; this -> HasOnEntryCommand = false ; this -> HasOnExitCommand = false ; this -> ProcessingState = new QState ( ) ; this -> ValidationState = new QState ( ) ; this -> ValidationTransition = new ctkWorkflowIntrastepTransition ( ctkWorkflowIntrastepTransition :: ValidationTransition ) ; this -> ValidationTransition -> setTargetState ( this -> ValidationState ) ; this -> ProcessingState -> addTransition ( this -> ValidationTransition ) ; this -> ValidationFailedTransition = 0 ; this -> ValidationFailedTransition = new ctkWorkflowIntrastepTransition ( ctkWorkflowIntrastepTransition :: ValidationFailedTransition ) ; this -> ValidationFailedTransition -> setTargetState ( this -> ProcessingState ) ; this -> ValidationState -> addTransition ( this -> ValidationFailedTransition ) ; } ctkWorkflowStepPrivate :: ~ ctkWorkflowStepPrivate ( ) { if ( ! this -> ValidationState . isNull ( ) ) { delete this -> ValidationState ; } if ( ! this -> ProcessingState . isNull ( ) ) { delete this -> ProcessingState ; } } void ctkWorkflowStepPrivate :: validationCompleteInternal ( bool validationResults , const QString & branchId ) const { emit validationComplete ( validationResults , branchId ) ; } void ctkWorkflowStepPrivate :: onEntryCompleteInternal ( ) const { emit onEntryComplete ( ) ; } void ctkWorkflowStepPrivate :: onExitCompleteInternal ( ) const { emit onExitComplete ( ) ; } void ctkWorkflowStepPrivate :: invokeValidateCommandInternal ( const QString & desiredBranchId ) const { emit invokeValidateCommand ( desiredBranchId ) ; } void ctkWorkflowStepPrivate :: invokeOnEntryCommandInternal ( const ctkWorkflowStep * comingFrom , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) const { emit invokeOnEntryCommand ( comingFrom , transitionType ) ; } void ctkWorkflowStepPrivate :: invokeOnExitCommandInternal ( const ctkWorkflowStep * goingTo , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) const { emit invokeOnExitCommand ( goingTo , transitionType ) ; } ctkWorkflowStep :: ctkWorkflowStep ( ) : d_ptr ( new ctkWorkflowStepPrivate ( * this ) ) { } ctkWorkflowStep :: ctkWorkflowStep ( const QString & newId ) : d_ptr ( new ctkWorkflowStepPrivate ( * this ) ) { Q_D ( ctkWorkflowStep ) ; d -> Id = newId ; } ctkWorkflowStep :: ctkWorkflowStep ( ctkWorkflowStepPrivate * pimpl , const QString & newId ) : d_ptr ( pimpl ) { Q_D ( ctkWorkflowStep ) ; d -> Id = newId ; } ctkWorkflowStep :: ~ ctkWorkflowStep ( ) { } CTK_GET_CPP ( ctkWorkflowStep , ctkWorkflow * , workflow , Workflow ) ; CTK_SET_CPP ( ctkWorkflowStep , ctkWorkflow * , setWorkflow , Workflow ) ; CTK_GET_CPP ( ctkWorkflowStep , QString , id , Id ) ; void ctkWorkflowStep :: setId ( const QString & newId ) { Q_D ( ctkWorkflowStep ) ; if ( d -> Workflow && d -> Workflow -> hasStep ( newId ) && ! this -> id ( ) . isEmpty ( ) ) { logger . error ( QString ( " ctkWorkflowStep ▁ - ▁ Failed ▁ to ▁ change ▁ id ▁ from ▁ ' %1 ' ▁ to ▁ ' %2 ' ▁ - ▁ " " Step ▁ already ▁ added ▁ to ▁ a ▁ workflow ▁ ! " ) . arg ( this -> id ( ) ) . arg ( newId ) ) ; return ; } d -> Id = newId ; } CTK_GET_CPP ( ctkWorkflowStep , QString , name , Name ) ; CTK_SET_CPP ( ctkWorkflowStep , const QString & , setName , Name ) ; CTK_GET_CPP ( ctkWorkflowStep , QString , description , Description ) ; CTK_SET_CPP ( ctkWorkflowStep , const QString & , setDescription , Description ) ; CTK_GET_CPP ( ctkWorkflowStep , QString , statusText , StatusText ) ; CTK_SET_CPP ( ctkWorkflowStep , const QString & , setStatusText , StatusText ) ; CTK_GET_CPP ( ctkWorkflowStep , bool , hasValidateCommand , HasValidateCommand ) ; CTK_SET_CPP ( ctkWorkflowStep , bool , setHasValidateCommand , HasValidateCommand ) ; CTK_GET_CPP ( ctkWorkflowStep , bool , hasOnEntryCommand , HasOnEntryCommand ) ; CTK_SET_CPP ( ctkWorkflowStep , bool , setHasOnEntryCommand , HasOnEntryCommand ) ; CTK_GET_CPP ( ctkWorkflowStep , bool , hasOnExitCommand , HasOnExitCommand ) ; CTK_SET_CPP ( ctkWorkflowStep , bool , setHasOnExitCommand , HasOnExitCommand ) ; CTK_GET_CPP ( ctkWorkflowStep , QState * , processingState , ProcessingState ) ; CTK_GET_CPP ( ctkWorkflowStep , QState * , validationState , ValidationState ) ; CTK_GET_CPP ( ctkWorkflowStep , ctkWorkflowIntrastepTransition * , validationTransition , ValidationTransition ) ; CTK_GET_CPP ( ctkWorkflowStep , ctkWorkflowIntrastepTransition * , validationFailedTransition , ValidationFailedTransition ) ; CTK_GET_CPP ( ctkWorkflowStep , bool , isWidgetType , WidgetType ) ; QObject * ctkWorkflowStep :: ctkWorkflowStepQObject ( ) { Q_D ( ctkWorkflowStep ) ; return d ; } void ctkWorkflowStep :: validationComplete ( bool validationResults , const QString & branchId ) const { Q_D ( const ctkWorkflowStep ) ; d -> validationCompleteInternal ( validationResults , branchId ) ; } void ctkWorkflowStep :: onEntryComplete ( ) const { Q_D ( const ctkWorkflowStep ) ; d -> onEntryCompleteInternal ( ) ; } void ctkWorkflowStep :: onExitComplete ( ) const { Q_D ( const ctkWorkflowStep ) ; d -> onExitCompleteInternal ( ) ; } void ctkWorkflowStep :: invokeValidateCommand ( const QString & desiredBranchId ) const { Q_D ( const ctkWorkflowStep ) ; d -> invokeValidateCommandInternal ( desiredBranchId ) ; } void ctkWorkflowStep :: invokeOnEntryCommand ( const ctkWorkflowStep * comingFrom , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) const { Q_D ( const ctkWorkflowStep ) ; d -> invokeOnEntryCommandInternal ( comingFrom , transitionType ) ; } void ctkWorkflowStep :: invokeOnExitCommand ( const ctkWorkflowStep * goingTo , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) const { Q_D ( const ctkWorkflowStep ) ; d -> invokeOnExitCommandInternal ( goingTo , transitionType ) ; } void ctkWorkflowStep :: validate ( const QString & desiredBranchId ) { Q_D ( ctkWorkflowStep ) ; logger . info ( QString ( " validate ▁ - ▁ validating ▁ the ▁ input ▁ from ▁ % 1" ) . arg ( d -> Name ) ) ; this -> validationComplete ( true , desiredBranchId ) ; } void ctkWorkflowStep :: onEntry ( const ctkWorkflowStep * comingFrom , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) { Q_UNUSED ( comingFrom ) ; Q_UNUSED ( transitionType ) ; this -> onEntryComplete ( ) ; } void ctkWorkflowStep :: onExit ( const ctkWorkflowStep * goingTo , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) { Q_UNUSED ( goingTo ) ; Q_UNUSED ( transitionType ) ; this -> onExitComplete ( ) ; } </DOCUMENT>
<DOCUMENT_ID="Suslik@@ V/obs-@@ studio/tree/master/plugins/win-capture@@ /graphics-@@ hook/d3d9@@ -capture.cpp"> # define _CRT_SEC@@ URE_NO_WARN@@ INGS # include < d3d9 . h > # include < d3d11 . h > # include < dxgi . h > # include " graphics - hook . h " # include " . . / funchook . h " # include " d3d9 - patches . hpp " typedef HRESULT ( STDMETHODCALLTYPE * present_t ) ( IDirect3DDevice9 * , CONST RECT * , CONST RECT * , HWND , CONST RGNDATA * ) ; typedef HRESULT ( STDMETHODCALLTYPE * present_ex_t ) ( IDirect3DDevice9 * , CONST RECT * , CONST RECT * , HWND , CONST RGNDATA * , DWORD ) ; typedef HRESULT ( STDMETHODCALLTYPE * present_swap_t ) ( IDirect3DSwapChain9 * , CONST RECT * , CONST RECT * , HWND , CONST RGNDATA * , DWORD ) ; typedef HRESULT ( STDMETHODCALLTYPE * reset_t ) ( IDirect3DDevice9 * , D3DPRESENT_PARAMETERS * ) ; typedef HRESULT ( STDMETHODCALLTYPE * reset_ex_t ) ( IDirect3DDevice9 * , D3DPRESENT_PARAMETERS * , D3DDISPLAYMODEEX * ) ; typedef HRESULT ( WINAPI * createfactory1_t ) ( REFI@@ ID , void * * ) ; static struct func_hook present ; static struct func_hook present_ex ; static struct func_hook present_swap ; static struct func_hook reset ; static struct func_hook reset_ex ; struct d3d9_data { HMODULE d3d9 ; IDirect3DDevice9 * device ; uint32_t cx ; uint32_t cy ; D3DFORMAT d3d9_format ; DXGI_FORMAT dxgi_format ; bool using_shtex : 1 ; bool using_scale : 1 ; volatile bool issued_queries [ NUM_BUFFERS ] ; union { struct { IDirect3DSurface9 * d3d9_copytex ; ID3D11Device * d3d11_device ; ID3D11DeviceContext * d3d11_context ; ID3D11Resource * d3d11_tex ; struct shtex_data * shtex_info ; HANDLE handle ; int patch ; } ; struct { IDirect3DSurface9 * copy_surfaces [ NUM_BUFFERS ] ; IDirect3DSurface9 * render_targets [ NUM_BUFFERS ] ; IDirect3DQuery9 * queries [ NUM_BUFFERS ] ; struct shmem_data * shmem_info ; bool texture_mapped [ NUM_BUFFERS ] ; uint32_t pitch ; int cur_tex ; int copy_wait ; } ; } ; } ; static struct d3d9_data data = { } ; static void d3d9_free ( ) { capture_free ( ) ; if ( data . using_shtex ) { if ( data . d3d11_tex ) data . d3d11_tex -> Release ( ) ; if ( data . d3d11_context ) data . d3d11_context -> Release ( ) ; if ( data . d3d11_device ) data . d3d11_device -> Release ( ) ; if ( data . d3d9_copytex ) data . d3d9_copytex -> Release ( ) ; } else { for ( size_t i = 0 ; i < NUM_BUFFERS ; i ++ ) { if ( data . copy_surfaces [ i ] ) { if ( data . texture_mapped [ i ] ) data . copy_surfaces [ i ] -> UnlockRect ( ) ; data . copy_surfaces [ i ] -> Release ( ) ; } if ( data . render_targets [ i ] ) data . render_targets [ i ] -> Release ( ) ; if ( data . queries [ i ] ) data . queries [ i ] -> Release ( ) ; } } memset ( & data , 0 , sizeof ( data ) ) ; hlog ( " - - - - - - - - - - - - - - - - - ▁ d3d9 ▁ capture ▁ freed ▁ - - - - - - - - - - - - - - - - - " ) ; } static DXGI_FORMAT d3d9_to_dxgi_format ( D3DFORMAT format ) { switch ( ( unsigned long ) format ) { case D3DFMT_A2B10@@ G10R10 : return DXGI_FORMAT_R10@@ G10B10A2_@@ UNORM ; case D3DFMT_A8R8G8B8 : return DXGI_FORMAT_B8G8R8A8_UNORM ; case D3DFMT_X8@@ R8G8B8 : return DXGI_FORMAT_B8G8R8X8_UNORM ; } return DXGI_FORMAT_UNKNOWN ; } const static D3D_FEATURE_LEVEL feature_levels [ ] = { D3D_FEATURE_LEVEL_11_0 , D3D_FEATURE_LEVEL_10_1 , D3D_FEATURE_LEVEL_10_0 , D3D_FEATURE_LEVEL_9_3 , } ; static inline bool shex_init_d3d11 ( ) { PFN_D3D11_CREATE_DEVICE create_device ; createfactory1_t create_factory ; D3D_FEATURE_LEVEL level_used ; IDXGIFactory * factory ; IDXGIAdapter * adapter ; HMODULE d3d11 ; HMODULE dxgi ; HRESULT hr ; d3d11 = load_system_library ( " d3d11 . dll " ) ; if ( ! d3d11 ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ load ▁ D3D11" ) ; return false ; } dxgi = load_system_library ( " dxgi . dll " ) ; if ( ! dxgi ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ load ▁ DXGI " ) ; return false ; } create_factory = ( createfactory1_t ) GetProcAddress ( dxgi , " CreateDXGIFactory1" ) ; if ( ! create_factory ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ get ▁ CreateDXGIFactory1 ▁ address " ) ; return false ; } create_device = ( PFN_D3D11_CREATE_DEVICE ) GetProcAddress ( d3d11 , " D3D11CreateDevice " ) ; if ( ! create_device ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ get ▁ D3D11CreateDevice ▁ address " ) ; return false ; } hr = create_factory ( __uuidof ( IDXGIFactory1 ) , ( void * * ) & factory ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init : ▁ Failed ▁ to ▁ create ▁ factory ▁ object " , hr ) ; return false ; } hr = factory -> EnumAdapters ( 0 , & adapter ) ; factory -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init : ▁ Failed ▁ to ▁ get ▁ adapter " , hr ) ; return false ; } hr = create_device ( adapter , D3D_DRIVER_TYPE_@@ UNKNOWN , nullptr , 0 , feature_levels , sizeof ( feature_levels ) / sizeof ( D3D_FEATURE_LEVEL ) , D3D11_SDK_VERSION , & data . d3d11_device , & level_used , & data . d3d11_context ) ; adapter -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init : ▁ Failed ▁ to ▁ create ▁ D3D11 ▁ device " , hr ) ; return false ; } return true ; } static inline bool d3d9_shtex_init_shtex ( ) { IDXGIResource * res ; HRESULT hr ; D3D11_TEXTURE@@ 2D_DESC desc = { } ; desc . Width = data . cx ; desc . Height = data . cy ; desc . Format = data . dxgi_format ; desc . MipLev@@ els = 1 ; desc . ArraySize = 1 ; desc . SampleDesc . Count = 1 ; desc . Usage = D3D11_USAGE_@@ DEFAULT ; desc . MiscFlags = D3D11_RESOURCE_MIS@@ C_SHARED ; desc . BindFlags = D3D11_BIND_RENDER_@@ TARGET | D3D11_BIND_SH@@ ADER_RESOURCE ; hr = data . d3d11_device -> CreateTexture2D ( & desc , nullptr , ( ID3D11Texture2D * * ) & data . d3d11_tex ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ shtex : ▁ Failed ▁ to ▁ create ▁ D3D11 ▁ texture " , hr ) ; return false ; } hr = data . d3d11_tex -> QueryInterface ( __uuidof ( IDXGIResource ) , ( void * * ) & res ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ shtex : ▁ Failed ▁ to ▁ query ▁ IDXGIResource " , hr ) ; return false ; } hr = res -> GetSharedHandle ( & data . handle ) ; res -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ shtex : ▁ Failed ▁ to ▁ get ▁ shared ▁ handle " , hr ) ; return false ; } return true ; } static inline bool d3d9_shtex_init_copytex ( ) { uint8_t * patch_addr = get_d3d9_patch_addr ( data . d3d9 , data . patch ) ; uint8_t saved_data [ MAX_PAT@@ CH_SIZE ] ; size_t patch_size = 0 ; IDirect3DTexture@@ 9 * tex ; DWORD protect_val ; HRESULT hr ; if ( patch_addr ) { patch_size = patch [ data . patch ] . size ; VirtualProtect ( patch_addr , patch_size , PAGE_@@ EXECUTE_RE@@ ADWRITE , & protect_val ) ; memcpy ( saved_data , patch_addr , patch_size ) ; memcpy ( patch_addr , patch [ data . patch ] . data , patch_size ) ; } hr = data . device -> CreateTexture ( data . cx , data . cy , 1 , D3DUSAGE_@@ RENDERTARGET , data . d3d9_format , D3DPOOL_DEFAULT , & tex , & data . handle ) ; if ( patch_addr && patch_size ) { memcpy ( patch_addr , saved_data , patch_size ) ; VirtualProtect ( patch_addr , patch_size , protect_val , & protect_val ) ; } if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ copytex : ▁ Failed ▁ to ▁ create ▁ shared ▁ texture " , hr ) ; return false ; } hr = tex -> GetSurfaceLevel ( 0 , & data . d3d9_copytex ) ; tex -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ copytex : ▁ Failed ▁ to ▁ get ▁ surface ▁ level " , hr ) ; return false ; } return true ; } static bool d3d9_shtex_init ( uint32_t cx , uint32_t cy , HWND window ) { data . using_shtex = true ; if ( ! shex_init_d3d11 ( ) ) { return false ; } if ( ! d3d9_shtex_init_shtex ( ) ) { return false ; } if ( ! d3d9_shtex_init_copytex ( ) ) { return false ; } if ( ! capture_init_shtex ( & data . shtex_info , window , cx , cy , data . cx , data . cy , data . dxgi_format , false , ( uintptr_t ) data . handle ) ) { return false ; } hlog ( " d3d9 ▁ shared ▁ texture ▁ capture ▁ successful " ) ; return true ; } static bool d3d9_shmem_init_buffers ( size_t buffer ) { HRESULT hr ; hr = data . device -> CreateOff@@ screenPla@@ inSurface ( data . cx , data . cy , data . d3d9_format , D3DPOOL_SYSTEM@@ MEM , & data . copy_surfaces [ buffer ] , nullptr ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ create ▁ surface " , hr ) ; return false ; } if ( buffer == 0 ) { D3DLOCKED_RECT rect ; hr = data . copy_surfaces [ buffer ] -> LockRect ( & rect , nullptr , D3DLOCK_READONLY ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ lock ▁ " " buffer " , hr ) ; return false ; } data . pitch = rect . Pitch ; data . copy_surfaces [ buffer ] -> UnlockRect ( ) ; } hr = data . device -> CreateRender@@ Target ( data . cx , data . cy , data . d3d9_format , D3DMULTI@@ SAMPLE_NONE , 0 , false , & data . render_targets [ buffer ] , nullptr ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ create ▁ render ▁ " " target " , hr ) ; return false ; } hr = data . device -> CreateQuery ( D3DQUER@@ YTYPE_EVENT , & data . queries [ buffer ] ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ create ▁ query " , hr ) ; return false ; } return true ; } static bool d3d9_shmem_init ( uint32_t cx , uint32_t cy , HWND window ) { data . using_shtex = false ; for ( size_t i = 0 ; i < NUM_BUFFERS ; i ++ ) { if ( ! d3d9_shmem_init_buffers ( i ) ) { return false ; } } if ( ! capture_init_shmem ( & data . shmem_info , window , cx , cy , data . cx , data . cy , data . pitch , data . dxgi_format , false ) ) { return false ; } hlog ( " d3d9 ▁ memory ▁ capture ▁ successful " ) ; return true ; } static bool d3d9_get_swap_desc ( D3DPRESENT_PARAMETERS & pp ) { IDirect3DSwapChain9 * swap = nullptr ; HRESULT hr ; hr = data . device -> GetSwapChain ( 0 , & swap ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ get _ swap _ desc : ▁ Failed ▁ to ▁ get ▁ swap ▁ chain " , hr ) ; return false ; } hr = swap -> GetPresentParameters ( & pp ) ; swap -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ get _ swap _ desc : ▁ Failed ▁ to ▁ get ▁ " " presentation ▁ parameters " , hr ) ; return false ; } return true ; } static bool d3d9_init_format_backbuffer ( uint32_t & cx , uint32_t & cy , HWND & window ) { IDirect3DSurface9 * back_buffer = nullptr ; D3DPRESENT_PARAMETERS pp ; D3DSURFACE_@@ DESC desc ; HRESULT hr ; if ( ! d3d9_get_swap_desc ( pp ) ) { return false ; } hr = data . device -> GetRenderTarget ( 0 , & back_buffer ) ; if ( FAILED ( hr ) ) { return false ; } hr = back_buffer -> GetDesc ( & desc ) ; back_buffer -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init _ format _ backbuffer : ▁ Failed ▁ to ▁ get ▁ " " backbuffer ▁ descriptor " , hr ) ; return false ; } data . d3d9_format = desc . Format ; data . dxgi_format = d3d9_to_dxgi_format ( desc . Format ) ; data . using_scale = global_hook_info -> use_scale ; window = pp . hDeviceWindow ; cx = desc . Width ; cy = desc . Height ; if ( data . using_scale ) { data . cx = global_hook_info -> cx ; data . cy = global_hook_info -> cy ; } else { data . cx = desc . Width ; data . cy = desc . Height ; } return true ; } static bool d3d9_init_format_swapchain ( uint32_t & cx , uint32_t & cy , HWND & window ) { D3DPRESENT_PARAMETERS pp ; if ( ! d3d9_get_swap_desc ( pp ) ) { return false ; } data . dxgi_format = d3d9_to_dxgi_format ( pp . BackBufferFormat ) ; data . d3d9_format = pp . BackBufferFormat ; data . using_scale = global_hook_info -> use_scale ; window = pp . hDeviceWindow ; cx = pp . BackBufferWidth ; cy = pp . BackBufferHeight ; if ( data . using_scale ) { data . cx = global_hook_info -> cx ; data . cy = global_hook_info -> cy ; } else { data . cx = pp . BackBufferWidth ; data . cy = pp . BackBufferHeight ; } return true ; } static void d3d9_init ( IDirect3DDevice9 * device ) { IDirect3DDevice9Ex * d3d9ex = nullptr ; bool success ; uint32_t cx = 0 ; uint32_t cy = 0 ; HWND window = nullptr ; HRESULT hr ; data . d3d9 = get_system_module ( " d3d9 . dll " ) ; data . device = device ; hr = device -> QueryInterface ( __uuidof ( IDirect3DDevice9Ex ) , ( void * * ) & d3d9ex ) ; if ( SUCCEEDED ( hr ) ) { d3d9ex -> Release ( ) ; data . patch = - 1 ; } else { data . patch = get_d3d9_patch ( data . d3d9 ) ; } if ( ! d3d9_init_format_backbuffer ( cx , cy , window ) ) { if ( ! d3d9_init_format_swapchain ( cx , cy , window ) ) { return ; } } if ( global_hook_info -> force_shmem || ( ! d3d9ex && data . patch == - 1 ) ) { success = d3d9_shmem_init ( cx , cy , window ) ; } else { success = d3d9_shtex_init ( cx , cy , window ) ; } if ( ! success ) d3d9_free ( ) ; } static inline HRESULT get_backbuffer ( IDirect3DDevice9 * device , IDirect3DSurface9 * * surface ) { static bool use_backbuffer = false ; static bool checked_exceptions = false ; if ( ! checked_exceptions ) { if ( _strcmpi ( get_process_@@ name ( ) , " hotd _ ng . exe " ) == 0 ) use_backbuffer = true ; checked_exceptions = true ; } if ( use_backbuffer ) { return device -> GetBackBuffer ( 0 , 0 , D3DBACK@@ BUFFER_TYPE_MON@@ O , surface ) ; } else { return device -> GetRenderTarget ( 0 , surface ) ; } } static inline void d3d9_shtex_capture ( IDirect3DSurface9 * backbuffer ) { D3DTEXTUREFILTERTYPE filter ; HRESULT hr ; filter = data . using_scale ? D3DTEXF_LINEAR : D3DTEXF_NONE ; hr = data . device -> StretchRect ( backbuffer , nullptr , data . d3d9_copytex , nullptr , filter ) ; if ( FAILED ( hr ) ) hlog_hr ( " d3d9 _ shtex _ capture : ▁ StretchRect ▁ failed " , hr ) ; } static inline void d3d9_shmem_capture_queue_copy ( ) { for ( int i = 0 ; i < NUM_BUFFERS ; i ++ ) { IDirect3DSurface9 * target = data . copy_surfaces [ i ] ; D3DLOCKED_RECT rect ; HRESULT hr ; if ( ! data . issued_queries [ i ] ) { continue ; } if ( data . queries [ i ] -> GetData ( 0 , 0 , 0 ) != S_OK ) { continue ; } data . issued_queries [ i ] = false ; hr = target -> LockRect ( & rect , nullptr , D3DLOCK_READONLY ) ; if ( SUCCEEDED ( hr ) ) { data . texture_mapped [ i ] = true ; shmem_copy_data ( i , rect . pBits ) ; } break ; } } static inline void d3d9_shmem_capture ( IDirect3DSurface9 * backbuffer ) { D3DTEXTUREFILTERTYPE filter ; IDirect3DSurface9 * copy ; int next_tex ; HRESULT hr ; d3d9_shmem_capture_queue_copy ( ) ; next_tex = ( data . cur_tex == NUM_BUFFERS - 1 ) ? 0 : data . cur_tex + 1 ; filter = data . using_scale ? D3DTEXF_LINEAR : D3DTEXF_NONE ; copy = data . render_targets [ data . cur_tex ] ; hr = data . device -> StretchRect ( backbuffer , nullptr , copy , nullptr , filter ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ capture : ▁ StretchRect ▁ failed " , hr ) ; return ; } if ( data . copy_wait < NUM_BUFFERS - 1 ) { data . copy_wait ++ ; } else { IDirect3DSurface9 * src = data . render_targets [ next_tex ] ; IDirect3DSurface9 * dst = data . copy_surfaces [ next_tex ] ; if ( shmem_texture_data_lock ( next_tex ) ) { dst -> UnlockRect ( ) ; data . texture_mapped [ next_tex ] = false ; shmem_texture_data_unlock ( next_tex ) ; } hr = data . device -> GetRenderTargetData ( src , dst ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ capture : ▁ GetRenderTargetData ▁ " " failed " , hr ) ; } data . queries [ next_tex ] -> Issue ( D3DISSU@@ E_END ) ; data . issued_queries [ next_tex ] = true ; } data . cur_tex = next_tex ; } static void d3d9_capture ( IDirect3DDevice9 * device , IDirect3DSurface9 * backbuffer ) { if ( capture_should_stop ( ) ) { d3d9_free ( ) ; } if ( capture_should_init ( ) ) { d3d9_init ( device ) ; } if ( capture_ready ( ) ) { if ( data . using_shtex ) d3d9_shtex_capture ( backbuffer ) ; else d3d9_shmem_capture ( backbuffer ) ; } } static int present_recurse = 0 ; static inline void present_begin ( IDirect3DDevice9 * device , IDirect3DSurface9 * & backbuffer ) { HRESULT hr ; if ( ! present_recurse ) { hr = get_backbuffer ( device , & backbuffer ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ capture : ▁ Failed ▁ to ▁ get ▁ " " backbuffer " , hr ) ; } if ( ! global_hook_info -> capture_overlay ) { d3d9_capture ( device , backbuffer ) ; } } present_recurse ++ ; } static inline void present_end ( IDirect3DDevice9 * device , IDirect3DSurface9 * backbuffer ) { present_recurse -- ; if ( ! present_recurse ) { if ( global_hook_info -> capture_overlay ) { if ( ! present_recurse ) d3d9_capture ( device , backbuffer ) ; } if ( backbuffer ) backbuffer -> Release ( ) ; } } static bool hooked_reset = false ; static void setup_reset_hooks ( IDirect3DDevice9 * device ) ; static HRESULT STDMETHODCALLTYPE hook_present ( IDirect3DDevice9 * device , CONST RECT * src_rect , CONST RECT * dst_rect , HWND override_window , CONST RGNDATA * dirty_region ) { IDirect3DSurface9 * backbuffer = nullptr ; HRESULT hr ; if ( ! hooked_reset ) setup_reset_hooks ( device ) ; present_begin ( device , backbuffer ) ; unhook ( & present ) ; present_t call = ( present_t ) present . call_addr ; hr = call ( device , src_rect , dst_rect , override_window , dirty_region ) ; rehook ( & present ) ; present_end ( device , backbuffer ) ; return hr ; } static HRESULT STDMETHODCALLTYPE hook_present_ex ( IDirect3DDevice9 * device , CONST RECT * src_rect , CONST RECT * dst_rect , HWND override_window , CONST RGNDATA * dirty_region , DWORD flags ) { IDirect3DSurface9 * backbuffer = nullptr ; HRESULT hr ; if ( ! hooked_reset ) setup_reset_hooks ( device ) ; present_begin ( device , backbuffer ) ; unhook ( & present_ex ) ; present_ex_t call = ( present_ex_t ) present_ex . call_addr ; hr = call ( device , src_rect , dst_rect , override_window , dirty_region , flags ) ; rehook ( & present_ex ) ; present_end ( device , backbuffer ) ; return hr ; } static HRESULT STDMETHODCALLTYPE hook_present_swap ( IDirect3DSwapChain9 * swap , CONST RECT * src_rect , CONST RECT * dst_rect , HWND override_window , CONST RGNDATA * dirty_region , DWORD flags ) { IDirect3DSurface9 * backbuffer = nullptr ; IDirect3DDevice9 * device = nullptr ; HRESULT hr ; if ( ! present_recurse ) { hr = swap -> GetDevice ( & device ) ; if ( SUCCEEDED ( hr ) ) { device -> Release ( ) ; } } if ( device ) { if ( ! hooked_reset ) setup_reset_hooks ( device ) ; present_begin ( device , backbuffer ) ; } unhook ( & present_swap ) ; present_swap_t call = ( present_swap_t ) present_swap . call_addr ; hr = call ( swap , src_rect , dst_rect , override_window , dirty_region , flags ) ; rehook ( & present_swap ) ; if ( device ) present_end ( device , backbuffer ) ; return hr ; } static HRESULT STDMETHODCALLTYPE hook_reset ( IDirect3DDevice9 * device , D3DPRESENT_PARAMETERS * params ) { HRESULT hr ; if ( capture_active ( ) ) d3d9_free ( ) ; unhook ( & reset ) ; reset_t call = ( reset_t ) reset . call_addr ; hr = call ( device , params ) ; rehook ( & reset ) ; return hr ; } static HRESULT STDMETHODCALLTYPE hook_reset_ex ( IDirect3DDevice9 * device , D3DPRESENT_PARAMETERS * params , D3DDISPLAYMODEEX * dmex ) { HRESULT hr ; if ( capture_active ( ) ) d3d9_free ( ) ; unhook ( & reset_ex ) ; reset_ex_t call = ( reset_ex_t ) reset_ex . call_addr ; hr = call ( device , params , dmex ) ; rehook ( & reset_ex ) ; return hr ; } static void setup_reset_hooks ( IDirect3DDevice9 * device ) { IDirect3DDevice9Ex * d3d9ex = nullptr ; uintptr_t * vtable = * ( uintptr_t * * ) device ; HRESULT hr ; hook_init ( & reset , ( void * ) vtable [ 16 ] , ( void * ) hook_reset , " IDirect3DDevice9 : : Reset " ) ; rehook ( & reset ) ; hr = device -> QueryInterface ( __uuidof ( IDirect3DDevice9Ex ) , ( void * * ) & d3d9ex ) ; if ( SUCCEEDED ( hr ) ) { hook_init ( & reset_ex , ( void * ) vtable [ 132 ] , ( void * ) hook_reset_ex , " IDirect3DDevice9Ex : : ResetEx " ) ; rehook ( & reset_ex ) ; d3d9ex -> Release ( ) ; } hooked_reset = true ; } typedef HRESULT ( WINAPI * d3d9create_ex_t ) ( UINT , IDirect3D9Ex * * ) ; static bool manually_get_d3d9_addrs ( HMODULE d3d9_module , void * * present_addr , void * * present_ex_addr , void * * present_swap_addr ) { d3d9create_ex_t create_ex ; D3DPRESENT_PARAMETERS pp ; HRESULT hr ; IDirect3DDevice9Ex * device ; IDirect3D9Ex * d3d9ex ; hlog ( " D3D9 ▁ values ▁ invalid , ▁ manually ▁ obtaining " ) ; create_ex = ( d3d9create_ex_t ) GetProcAddress ( d3d9_module , " Direct3DCreate9Ex " ) ; if ( ! create_ex ) { hlog ( " Failed ▁ to ▁ load ▁ Direct3DCreate9Ex " ) ; return false ; } if ( FAILED ( create_ex ( D3D_SDK_VERSION , & d3d9ex ) ) ) { hlog ( " Failed ▁ to ▁ create ▁ D3D9 ▁ context " ) ; return false ; } memset ( & pp , 0 , sizeof ( pp ) ) ; pp . Windowed = 1 ; pp . SwapEffect = D3DSW@@ APEFFECT_@@ FLIP ; pp . BackBufferFormat = D3DFMT_A8R8G8B8 ; pp . BackBufferCount = 1 ; pp . hDeviceWindow = ( HWND ) dummy_window ; pp . PresentationInterval = D3DPRESENT_INTERVAL_@@ IMMEDIATE ; hr = d3d9ex -> CreateDevice@@ Ex ( D3DADAP@@ TER_DEFAULT , D3DDEV@@ TYPE_HAL , dummy_window , D3DCREATE_HARDWARE_VERTEX@@ PROCESSING | D3DCREATE_NOWINDOW@@ CHANGES , & pp , NULL , & device ) ; d3d9ex -> Release ( ) ; if ( SUCCEEDED ( hr ) ) { uintptr_t * vtable = * ( uintptr_t * * ) device ; IDirect3DSwapChain9 * swap ; * present_addr = ( void * ) vtable [ 17 ] ; * present_ex_addr = ( void * ) vtable [ 121 ] ; hr = device -> GetSwapChain ( 0 , & swap ) ; if ( SUCCEEDED ( hr ) ) { vtable = * ( uintptr_t * * ) swap ; * present_swap_addr = ( void * ) vtable [ 3 ] ; swap -> Release ( ) ; } device -> Release ( ) ; } else { hlog ( " Failed ▁ to ▁ create ▁ D3D9 ▁ device " ) ; return false ; } return true ; } bool hook_d3d9 ( void ) { HMODULE d3d9_module = get_system_module ( " d3d9 . dll " ) ; uint32_t d3d9_size ; void * present_addr = nullptr ; void * present_ex_addr = nullptr ; void * present_swap_addr = nullptr ; if ( ! d3d9_module ) { return false ; } d3d9_size = module_size ( d3d9_module ) ; if ( global_hook_info -> offsets . d3d9 . present < d3d9_size && global_hook_info -> offsets . d3d9 . present_ex < d3d9_size && global_hook_info -> offsets . d3d9 . present_swap < d3d9_size ) { present_addr = get_offset_addr ( d3d9_module , global_hook_info -> offsets . d3d9 . present ) ; present_ex_addr = get_offset_addr ( d3d9_module , global_hook_info -> offsets . d3d9 . present_ex ) ; present_swap_addr = get_offset_addr ( d3d9_module , global_hook_info -> offsets . d3d9 . present_swap ) ; } else { if ( ! dummy_window ) { return false ; } if ( ! manually_get_d3d9_addrs ( d3d9_module , & present_addr , & present_ex_addr , & present_swap_addr ) ) { hlog ( " Failed ▁ to ▁ get ▁ D3D9 ▁ values " ) ; return true ; } } if ( ! present_addr && ! present_ex_addr && ! present_swap_addr ) { hlog ( " Invalid ▁ D3D9 ▁ values " ) ; return true ; } if ( present_swap_addr ) { hook_init ( & present_swap , present_swap_addr , ( void * ) hook_present_swap , " IDirect3DSwapChain9 : : Present " ) ; rehook ( & present_swap ) ; } if ( present_ex_addr ) { hook_init ( & present_ex , present_ex_addr , ( void * ) hook_present_ex , " IDirect3DDevice9Ex : : PresentEx " ) ; rehook ( & present_ex ) ; } if ( present_addr ) { hook_init ( & present , present_addr , ( void * ) hook_present , " IDirect3DDevice9 : : Present " ) ; rehook ( & present ) ; } hlog ( " Hooked ▁ D3D9" ) ; return true ; } </DOCUMENT>
<DOCUMENT_ID="uwa@@ fsl/ardupilot/tree/master/libraries/AP_HAL_Linux/@@ Util.cpp"> # include < AP_HAL / AP_HAL . h > # if CONFIG_HAL_BOARD == HAL_BOARD_@@ LINUX # include < stdio . h > # include < stdarg . h > # include < sys / stat . h > # include < unistd . h > # include < stdlib . h > # include < errno . h > # include < time . h > # include < fcntl . h > extern const AP_HAL :: HAL & hal ; # include " ToneAlarm _ Raspilot . h " # include " Util . h " # include " Heat _ Pwm . h " using namespace Linux ; static int state ; # if CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_RASPILOT ToneAlarm_Raspilot Util :: _toneAlarm ; # else ToneAlarm Util :: _toneAlarm ; # endif void Util :: init ( int argc , char * const * argv ) { saved_argc = argc ; saved_argv = argv ; # ifdef HAL_UTILS_HEAT # if HAL_UTILS_HEAT == HAL_LINUX_HEAT_PWM _heat = new Linux :: HeatPwm ( HAL_LINUX_HEAT_PWM_NUM , HAL_LINUX_HEAT_KP , HAL_LINUX_HEAT_KI , HAL_LINUX_HEAT_PERIO@@ D_NS , HAL_LINUX_HEAT_TARGET_TEMP ) ; # else # error Unrecognized Heat # endif # else _heat = new Linux :: Heat ( ) ; # endif } void Util :: set_imu_temp ( float current ) { _heat -> set_imu_temp ( current ) ; } void Util :: commandline_arguments ( uint8_t & argc , char * const * & argv ) { argc = saved_argc ; argv = saved_argv ; } bool Util :: toneAlarm_init ( ) { return _toneAlarm . init ( ) ; } void Util :: toneAlarm_set_tune ( uint8_t tone ) { _toneAlarm . set_tune ( tone ) ; } void Util :: _toneAlar@@ m_timer_tick ( ) { if ( state == 0 ) { state = state + _toneAlarm . init_t@@ une ( ) ; } else if ( state == 1 ) { state = state + _toneAlarm . set_note ( ) ; } if ( state == 2 ) { state = state + _toneAlarm . play ( ) ; } else if ( state == 3 ) { state = 1 ; } if ( _toneAlarm . is_tun@@ e_comp ( ) ) { state = 0 ; } } void Util :: set_system_@@ clock ( uint64_t time_utc_usec ) { # if CONFIG_HAL_BOARD_SUBTYPE != HAL_BOARD_SUBTYPE_LINUX_NONE timesp@@ ec ts ; ts . tv_sec = time_utc_usec / 1.0e6 ; ts . tv_nsec = ( time_utc_usec % 1000000 ) * 1000 ; clock_settime ( CLOCK_REAL@@ TIME , & ts ) ; # endif } bool Util :: is_char@@ dev_node ( const char * path ) { struct stat st ; if ( ! path || lstat ( path , & st ) < 0 ) return false ; return S_IS@@ CHR ( st . st_mode ) ; } uint32_t Util :: available_memory ( void ) { return 256 * 1024 ; } int Util :: write_file ( const char * path , const char * fmt , ... ) { errno = 0 ; int fd = :: open ( path , O_WRO@@ NLY | O_CLOEXEC ) ; if ( fd == - 1 ) { return - errno ; } va_list args ; va_start ( args , fmt ) ; int ret = :: vdprintf ( fd , fmt , args ) ; int errno_bkp = errno ; :: close ( fd ) ; va_end ( args ) ; if ( ret < 1 ) { return - errno_bkp ; } return ret ; } int Util :: read_file ( const char * path , const char * fmt , ... ) { errno = 0 ; FILE * file = :: fopen ( path , " re " ) ; if ( ! file ) return - errno ; va_list args ; va_start ( args , fmt ) ; int ret = :: vfscanf ( file , fmt , args ) ; int errno_bkp = errno ; :: fclose ( file ) ; va_end ( args ) ; if ( ret < 1 ) return - errno_bkp ; return ret ; } const char * Linux :: Util :: _hw_names [ UTIL_NUM_HARDWARES ] = { [ UTIL_HARDWARE_RPI1 ] = " BCM2708" , [ UTIL_HARDWARE_RPI2 ] = " BCM2709" , [ UTIL_HARDWARE_BEBOP ] = " Mykon@@ os3 ▁ board " , [ UTIL_HARDWARE_BEBOP2 ] = " Milos ▁ board " , } ; # define MAX_SIZE_LINE 50 int Util :: get_hw_arm@@ 32 ( ) { int ret = - ENOENT ; char buffer [ MAX_SIZE_LINE ] ; const char * hardware_description_entry = " Hardware " ; char * flag ; FILE * f ; f = fopen ( " / proc / cpuinfo " , " r " ) ; if ( f == NULL ) { ret = - errno ; goto end ; } while ( fgets ( buffer , MAX_SIZE_LINE , f ) != NULL ) { flag = strstr ( buffer , hardware_description_entry ) ; if ( flag != NULL ) { for ( uint8_t i = 0 ; i < UTIL_NUM_HARDWARES ; i ++ ) { if ( strstr ( buffer , _hw_names [ i ] ) != 0 ) { ret = i ; goto close_end ; } } } } close_end : fclose ( f ) ; end : return ret ; } # endif </DOCUMENT>
<DOCUMENT_ID="geocool/libtmx@@ -parser/tree/master/src@@ /tmx@@ parser.cpp"> # include " tmxparser . h " # include " base64 . h " # if ( defined ( _WIN32 ) ) # include < string . h > # endif # if ( ( defined ( ANDROID ) ) ) # include < android / log . h > # include < string . h > # else # include < cstdlib > # include < cstdio > # endif # include < algorithm > # include < string > # include < sstream > # ifndef LOG_TAG # define LOG_TAG " libtmxparser " # endif # if defined ( WIN32 ) || defined ( _WIN32 ) # define PATH_SEPARATOR " \\ " # define PATH_SEPARATOR_ALT " / " # else # define PATH_SEPARATOR " / " # define PATH_SEPARATOR_ALT " / " # endif # define QUOTEME_ ( x ) # x # define QUOTEME ( x ) QUOTEME_ ( x ) # define WHERESTR " [ file ▁ % s , ▁ line ▁ % d ] : ▁ " # define WHEREARG __FILE__ , __LINE__ # if ( ( defined ( ANDROID ) ) ) # ifdef DEBUG # define LOGD ( ... ) __android_log_print ( ANDROID_LOG_DEBUG , LOG_TAG , " ▁ ( " __FILE__ " : " QUOTEME ( __LINE__ ) " ) ▁ " __VA_ARGS__ ) # else # define LOGD ( ... ) # endif # define LOGI ( ... ) __android_log_print ( ANDROID_LOG_INFO , LOG_TAG , " " __VA_ARGS__ ) # define LOGE ( ... ) __android_log_print ( ANDROID_LOG_ERROR , LOG_TAG , __VA_ARGS__ ) # define LOGW ( ... ) __android_log_print ( ANDROID_LOG_WARN , LOG_TAG , __VA_ARGS__ ) # else # ifdef DEBUG # define LOGD ( ... ) fprintf ( stderr , " D / " LOG_TAG " ▁ ( " __FILE__ " : " QUOTEME ( __LINE__ ) " ) : ▁ " __VA_ARGS__ ) ; fprintf ( stderr , " \n " ) ; # else # define LOGD ( ... ) # endif # define LOGI ( ... ) fprintf ( stdout , " I / " QUOTEME ( LOG_TAG ) " ( " " ) " __VA_ARGS__ ) ; fprintf ( stdout , " \n " ) ; # define LOGE ( ... ) fprintf ( stderr , " E / " QUOTEME ( LOG_TAG ) " ( " " ) " __VA_ARGS__ ) ; fprintf ( stderr , " \n " ) ; # define LOGW ( ... ) fprintf ( stderr , " W / " QUOTEME ( LOG_TAG ) " ( " " ) " __VA_ARGS__ ) ; fprintf ( stderr , " \n " ) ; # endif namespace tmxparser { # define CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( XMLELEMENT , ATTRIBNAME , LHS ) if ( XMLELEMENT -> Attribute ( ATTRIBNAME ) != NULL ) { LHS = XMLELEMENT -> Attribute ( ATTRIBNAME ) ; } else { LHS = ' \0' ; } # define CHECK_AND_RETRIEVE_REQ_ATTRIBUTE_STRING ( XMLELEMENT , ATTRIBNAME , LHS ) LHS = XMLELEMENT -> Attribute ( ATTRIBNAME ) ; if ( LHS . size ( ) == 0 ) { LOGE ( " Missing ▁ required ▁ attribute ▁ [ % s ] " , ATTRIBNAME ) ; return TmxReturn :: kMissingRequiredAttribute ; } # define CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( FUNC , ATTRIBNAME , OUT ) if ( FUNC ( ATTRIBNAME , OUT ) == tinyxml2 :: XML_NO_ATTRIBUTE ) { LOGE ( " Missing ▁ required ▁ attribute ▁ [ % s ] " , ATTRIBNAME ) ; return kMissingRequiredAttribute ; } TmxReturn _parseStart ( tinyxml2 :: XMLElement * element , TmxMap * outMap , const std :: string & tilesetPath ) ; TmxReturn _parseEnd ( TmxMap * outMap , const std :: string & tilesetPath ) ; void _parseEndHelper ( TmxImage & image , const std :: string & tilesetPath ) ; TmxReturn _parseMapNode ( tinyxml2 :: XMLElement * element , TmxMap * outMap ) ; TmxReturn _parsePropertyNode ( tinyxml2 :: XMLElement * element , TmxPropertyMap_t * outPropertyMap ) ; TmxReturn _parseImageNode ( tinyxml2 :: XMLElement * element , TmxImage * outImage ) ; TmxReturn _parseTilesetNode ( tinyxml2 :: XMLElement * element , TmxTileset * outTileset ) ; TmxReturn _parseTileDefinitionNode ( tinyxml2 :: XMLElement * element , TmxTileDefinition * outTileDefinition ) ; TmxReturn _parseTileAnimationNode ( tinyxml2 :: XMLElement * element , TmxAnimationFrameCollection_t * outAnimationCollection ) ; TmxReturn _parseLayerNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayer * outLayer ) ; TmxReturn _parseLayerDataNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayerTileCollection_t * outTileCollection ) ; TmxReturn _parseLayerXmlTileNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayerTile * outTile ) ; TmxReturn _calculateTileIndices ( const TmxTilesetCollection_t & tilesets , TmxLayerTile * outTile ) ; TmxReturn _parseObjectGroupNode ( tinyxml2 :: XMLElement * element , TmxObjectGroup * outObjectGroup ) ; TmxReturn _parseObjectNode ( tinyxml2 :: XMLElement * element , TmxObject * outObj ) ; TmxReturn _parseOffsetNode ( tinyxml2 :: XMLElement * element , TmxOffset * offset ) ; TmxReturn _parseImageLayerNode ( tinyxml2 :: XMLElement * element , TmxImageLayer * outImageLayer ) ; TmxReturn parseFromFile ( const std :: string & fileName , TmxMap * outMap , const std :: string & tilesetPath ) { tinyxml2 :: XMLDocument doc ; if ( doc . LoadFile ( fileName . c_str ( ) ) != tinyxml2 :: XML_SUCCESS ) { LOGE ( " Cannot ▁ read ▁ xml ▁ file " ) ; return TmxReturn :: kErrorParsing ; } return _parseStart ( doc . FirstChildElement ( " map " ) , outMap , tilesetPath ) ; } TmxReturn parseFromMemory ( void * data , size_t length , TmxMap * outMap , const std :: string & tilesetPath ) { tinyxml2 :: XMLDocument doc ; if ( doc . Parse ( ( char * ) data , length ) ) { LOGE ( " Cannot ▁ parse ▁ xml ▁ memory ▁ file . . . " ) ; return TmxReturn :: kErrorParsing ; } return _parseStart ( doc . FirstChildElement ( " map " ) , outMap , tilesetPath ) ; } TmxReturn _parseStart ( tinyxml2 :: XMLElement * element , TmxMap * outMap , const std :: string & tilesetPath ) { TmxReturn retVal = _parseMapNode ( element , outMap ) ; return ( retVal == TmxReturn :: kSuccess ) ? _parseEnd ( outMap , tilesetPath ) : retVal ; } TmxReturn _parseEnd ( TmxMap * outMap , const std :: string & tilesetPath ) { for ( auto tileIt = outMap -> tilesetCollection . begin ( ) ; tileIt != outMap -> tilesetCollection . end ( ) ; ++ tileIt ) _parseEndHelper ( tileIt -> image , tilesetPath ) ; for ( auto tileIt = outMap -> imageLayerCollection . begin ( ) ; tileIt != outMap -> imageLayerCollection . end ( ) ; ++ tileIt ) _parseEndHelper ( tileIt -> image , tilesetPath ) ; return TmxReturn :: kSuccess ; } void _parseEndHelper ( TmxImage & image , const std :: string & tilesetPath ) { auto pathSeperatorMissing = ( image . source . find ( PATH_SEPARATOR ) == std :: string :: npos ) ; auto pathSeperatorAltMissing = ( image . source . find ( PATH_SEPARATOR_ALT ) == std :: string :: npos ) ; if ( pathSeperatorMissing && pathSeperatorAltMissing ) { std :: string baseFilename = image . source . substr ( image . source . find_last_@@ of ( PATH_SEPARATOR ) + 1 ) ; auto seperatorThere = ( tilesetPath . find ( PATH_SEPARATOR ) != std :: string :: npos ) ; auto seperatorAltThere = ( tilesetPath . find ( PATH_SEPARATOR_ALT ) != std :: string :: npos ) ; auto tileSetPathSeparator = PATH_SEPARATOR ; if ( ! seperatorThere && seperatorAltThere ) tileSetPathSeparator = PATH_SEPARATOR_ALT ; image . source = tilesetPath + tileSetPathSeparator + baseFilename ; } } TmxReturn _parseMapNode ( tinyxml2 :: XMLElement * element , TmxMap * outMap ) { if ( element == NULL ) { return TmxReturn :: kMissingMapNode ; } outMap -> version = element -> Attribute ( " version " ) ; const char * orientation = element -> Attribute ( " orientation " ) ; if ( orientation != NULL ) { if ( strcmp ( orientation , " orthogonal " ) == 0 ) { outMap -> orientation = TmxOrientation :: kOrthogonal ; } else if ( strcmp ( orientation , " isometric " ) == 0 ) { outMap -> orientation = TmxOrientation :: kIsometric ; } else if ( strcmp ( orientation , " staggered " ) == 0 ) { outMap -> orientation = TmxOrientation :: kStaggered ; } } else { LOGW ( " Missing ▁ orientation ▁ attribute " ) ; } CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " width " , & outMap -> width ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " height " , & outMap -> height ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " tilewidth " , & outMap -> tileWidth ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " tileheight " , & outMap -> tileHeight ) ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " backgroundcolor " , outMap -> backgroundColor ) ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " renderorder " , outMap -> renderOrder ) ; TmxReturn error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outMap -> propertyMap ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ map ▁ properties . . . " ) ; return error ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " tileset " ) ; child != NULL ; child = child -> NextSiblingElement ( " tileset " ) ) { TmxTileset set ; error = _parseTilesetNode ( child , & set ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ tileset ▁ node . . . " ) ; return error ; } outMap -> tilesetCollection . push_back ( set ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " layer " ) ; child != NULL ; child = child -> NextSiblingElement ( " layer " ) ) { TmxLayer layer ; error = _parseLayerNode ( child , outMap -> tilesetCollection , & layer ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ layer ▁ node . . . " ) ; return error ; } outMap -> layerCollection . push_back ( layer ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " objectgroup " ) ; child != NULL ; child = child -> NextSiblingElement ( " objectgroup " ) ) { TmxObjectGroup group ; error = _parseObjectGroupNode ( child , & group ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ objectgroup ▁ node . . . " ) ; return error ; } outMap -> objectGroupCollection . push_back ( group ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " imagelayer " ) ; child != NULL ; child = child -> NextSiblingElement ( " imagelayer " ) ) { TmxImageLayer imageLayer ; error = _parseImageLayerNode ( child , & imageLayer ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ imagelayer ▁ node . . . " ) ; return error ; } outMap -> imageLayerCollection . push_back ( imageLayer ) ; } return error ; } TmxReturn _parsePropertyNode ( tinyxml2 :: XMLElement * element , TmxPropertyMap_t * outPropertyMap ) { if ( element == NULL ) { return TmxReturn :: kSuccess ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " property " ) ; child != NULL ; child = child -> NextSiblingElement ( " property " ) ) { if ( strcmp ( child -> Name ( ) , " property " ) == 0 ) { if ( child -> Attribute ( " name " ) != NULL && child -> Attribute ( " value " ) != NULL ) { ( * outPropertyMap ) [ child -> Attribute ( " name " ) ] = child -> Attribute ( " value " ) ; } else { return TmxReturn :: kMalformedPropertyNode ; } } } return TmxReturn :: kSuccess ; } TmxReturn _parseImageNode ( tinyxml2 :: XMLElement * element , TmxImage * outImage ) { CHECK_AND_RETRIEVE_REQ_ATTRIBUTE_STRING ( element , " source " , outImage -> source ) ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " format " , outImage -> format ) ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " trans " , outImage -> transparent@@ Color ) ; outImage -> width = element -> UnsignedAttribute ( " width " ) ; outImage -> height = element -> UnsignedAttribute ( " height " ) ; return TmxReturn :: kSuccess ; } TmxReturn _parseTilesetNode ( tinyxml2 :: XMLElement * element , TmxTileset * outTileset ) { if ( strcmp ( element -> Name ( ) , " tileset " ) == 0 ) { CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " firstgid " , & outTileset -> firstgid ) ; outTileset -> name = element -> Attribute ( " name " ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " tilewidth " , & outTileset -> tileWidth ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " tileheight " , & outTileset -> tileHeight ) ; outTileset -> tileSpacingInImage = element -> UnsignedAttribute ( " spacing " ) ; outTileset -> tileMarginInImage = element -> UnsignedAttribute ( " margin " ) ; if ( element -> FirstChildElement ( " image " ) == NULL ) { LOGE ( " We ▁ do ▁ not ▁ support ▁ maps ▁ with ▁ tilesets ▁ that ▁ have ▁ no ▁ image ▁ associated ▁ currently . . . " ) ; return kErrorParsing ; } TmxImage image ; TmxReturn error = _parseImageNode ( element -> FirstChildElement ( " image " ) , & outTileset -> image ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ image ▁ node . . . " ) ; return error ; } outTileset -> offset . x = 0 ; outTileset -> offset . y = 0 ; if ( element -> FirstChildElement ( " tileoffset " ) != NULL ) { error = _parseOffsetNode ( element -> FirstChildElement ( " tileoffset " ) , & outTileset -> offset ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " tile " ) ; child != NULL ; child = child -> NextSiblingElement ( " tile " ) ) { TmxTileDefinition tileDef ; tileDef . id = 0 ; error = _parseTileDefinitionNode ( child , & tileDef ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ tile ▁ definition " ) ; return error ; } outTileset -> tileDefinitions [ tileDef . id ] = tileDef ; } outTileset -> colCount = ( outTileset -> image . width - outTileset -> tileMarginInImage ) / ( outTileset -> tileWidth + outTileset -> tileSpacingInImage ) ; outTileset -> rowCount = ( outTileset -> image . height - outTileset -> tileMarginInImage ) / ( outTileset -> tileHeight + outTileset -> tileSpacingInImage ) ; } return TmxReturn :: kSuccess ; } TmxReturn _parseTileDefinitionNode ( tinyxml2 :: XMLElement * element , TmxTileDefinition * outTileDefinition ) { TmxReturn error = TmxReturn :: kSuccess ; outTileDefinition -> id = element -> UnsignedAttribute ( " id " ) ; error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outTileDefinition -> propertyMap ) ; if ( error ) { return error ; } if ( element -> FirstChildElement ( " animation " ) != NULL ) { error = _parseTileAnimationNode ( element -> FirstChildElement ( " animation " ) , & outTileDefinition -> animations ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " objectgroup " ) ; child != NULL ; child = child -> NextSiblingElement ( " objectgroup " ) ) { TmxObjectGroup group ; error = _parseObjectGroupNode ( child , & group ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ objectgroup ▁ node . . . " ) ; return error ; } outTileDefinition -> objectgroups . push_back ( group ) ; } return error ; } TmxReturn _parseTileAnimationNode ( tinyxml2 :: XMLElement * element , TmxAnimationFrameCollection_t * outAnimationCollection ) { for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " frame " ) ; child != NULL ; child = child -> NextSiblingElement ( " frame " ) ) { TmxAnimationFrame frame ; frame . duration = child -> FloatAttribute ( " duration " ) ; frame . tileId = child -> UnsignedAttribute ( " tileid " ) ; outAnimationCollection -> push_back ( frame ) ; } return kSuccess ; } TmxReturn _parseLayerNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayer * outLayer ) { TmxReturn error = TmxReturn :: kSuccess ; outLayer -> name = element -> Attribute ( " name " ) ; if ( element -> Attribute ( " opacity " ) ) outLayer -> opacity = element -> FloatAttribute ( " opacity " ) ; else outLayer -> opacity = 1 . f ; if ( element -> Attribute ( " visible " ) ) outLayer -> visible = ( element -> IntAttribute ( " visible " ) == 1 ? true : false ) ; else outLayer -> visible = true ; outLayer -> width = element -> UnsignedAttribute ( " width " ) ; outLayer -> height = element -> UnsignedAttribute ( " height " ) ; error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outLayer -> propertyMap ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ layer ▁ property ▁ node . . . " ) ; return error ; } tinyxml2 :: XMLElement * dataElement = element -> FirstChildElement ( " data " ) ; if ( dataElement != NULL ) { error = _parseLayerDataNode ( dataElement , tilesets , & outLayer -> tiles ) ; } else { LOGE ( " Layer ▁ missing ▁ data ▁ node . . . " ) ; return TmxReturn :: kMissingDataNode ; } return error ; } TmxReturn _parseLayerDataNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayerTileCollection_t * outTileCollection ) { TmxReturn error = TmxReturn :: kSuccess ; const char * encoding = element -> Attribute ( " encoding " ) ; const char * compression = element -> Attribute ( " compression " ) ; if ( compression != NULL ) { LOGE ( " Does ▁ not ▁ support ▁ compression ▁ yet . . . " ) ; return TmxReturn :: kErrorParsing ; } if ( encoding == NULL ) { for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " tile " ) ; child != NULL ; child = child -> NextSiblingElement ( " tile " ) ) { TmxLayerTile tile ; error = _parseLayerXmlTileNode ( child , tilesets , & tile ) ; outTileCollection -> push_back ( tile ) ; } } else if ( strcmp ( encoding , " csv " ) == 0 ) { std :: stringstream csvss ( element -> FirstChild ( ) -> Value ( ) ) ; unsigned int gid = 0 ; while ( csvss >> gid ) { if ( csvss . peek ( ) == ' , ' || csvss . peek ( ) == ' \n ' ) { csvss . ignore ( ) ; } TmxLayerTile tile ; tile . gid = gid ; error = _calculateTileIndices ( tilesets , & tile ) ; if ( error == TmxReturn :: kErrorParsing ) { return error ; } outTileCollection -> push_back ( tile ) ; } } else if ( strcmp ( encoding , " base64" ) == 0 ) { std :: string csvbase64 = element -> FirstChild ( ) -> Value ( ) ; csvbase64 . erase ( std :: remove ( csvbase64 . begin ( ) , csvbase64 . end ( ) , ' \n ' ) , csvbase64 . end ( ) ) ; csvbase64 . erase ( std :: remove ( csvbase64 . begin ( ) , csvbase64 . end ( ) , '' ) , csvbase64 . end ( ) ) ; csvbase64 . erase ( std :: remove ( csvbase64 . begin ( ) , csvbase64 . end ( ) , ' ▁ ' ) , csvbase64 . end ( ) ) ; std :: string csv = base64_@@ decode ( csvbase64 ) ; unsigned int length = csv . size ( ) / sizeof ( unsigned int ) ; unsigned int * p = ( unsigned int * ) csv . c_str ( ) ; for ( unsigned int i = 0 ; i < length ; i ++ ) { TmxLayerTile tile ; tile . gid = p [ i ] ; error = _calculateTileIndices ( tilesets , & tile ) ; if ( error == TmxReturn :: kErrorParsing ) { return error ; } outTileCollection -> push_back ( tile ) ; } } else { LOGE ( " Unsupported ▁ layer ▁ compression ▁ [ % s ] . . . ▁ coming ▁ soon . . . " , encoding ) ; return TmxReturn :: kErrorParsing ; } return error ; } TmxReturn _parseLayerXmlTileNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayerTile * outTile ) { TmxReturn error = TmxReturn :: kSuccess ; unsigned int gid = element -> UnsignedAttribute ( " gid " ) ; unsigned int flipXFlag = 0x80000000 ; unsigned int flipYFlag = 0x40000000 ; unsigned int flipDiagonalFlag = 0x20000000 ; outTile -> flipX = ( gid & flipXFlag ? true : false ) ; outTile -> flipY = ( gid & flipYFlag ? true : false ) ; outTile -> flipDiagonal = ( gid & flipDiagonalFlag ? true : false ) ; outTile -> gid = ( gid & ~ ( flipXFlag | flipYFlag | flipDiagonalFlag ) ) ; return _calculateTileIndices ( tilesets , outTile ) ; } TmxReturn _calculateTileIndices ( const TmxTilesetCollection_t & tilesets , TmxLayerTile * outTile ) { outTile -> tilesetIndex = 0 ; outTile -> tileFlatIndex = 0 ; if ( outTile -> gid == 0 ) { return TmxReturn :: kSuccess ; } unsigned int index = 0 ; unsigned int lastEndIndex = 1 ; for ( auto it = tilesets . begin ( ) ; it != tilesets . end ( ) ; ++ it ) { unsigned int colCount = it -> colCount ; unsigned int rowCount = it -> rowCount ; unsigned int startIndex = it -> firstgid ; unsigned int endIndex = it -> firstgid + ( colCount * rowCount ) ; if ( outTile -> gid >= startIndex && outTile -> gid < endIndex ) { outTile -> tilesetIndex = index ; outTile -> tileFlatIndex = ( outTile -> gid ) - lastEndIndex ; return TmxReturn :: kSuccess ; } lastEndIndex = endIndex ; index ++ ; } return TmxReturn :: kUnknownTileIndices ; } TmxReturn _parseObjectGroupNode ( tinyxml2 :: XMLElement * element , TmxObjectGroup * outObjectGroup ) { TmxReturn error = TmxReturn :: kSuccess ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " name " , outObjectGroup -> name ) ; if ( element -> Attribute ( " opacity " ) != NULL ) { outObjectGroup -> opacity = element -> FloatAttribute ( " opacity " ) ; } else { outObjectGroup -> opacity = 1.0f ; } if ( element -> Attribute ( " visible " ) != NULL ) { outObjectGroup -> visible = element -> BoolAttribute ( " visible " ) ; } else { outObjectGroup -> visible = true ; } error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outObjectGroup -> propertyMap ) ; if ( error ) { return error ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " object " ) ; child != NULL ; child = child -> NextSiblingElement ( " object " ) ) { TmxObject obj ; error = _parseObjectNode ( child , & obj ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ object ▁ node . . . " ) ; return TmxReturn :: kErrorParsing ; } outObjectGroup -> objects . push_back ( obj ) ; } return error ; } TmxReturn _parseObjectNode ( tinyxml2 :: XMLElement * element , TmxObject * outObj ) { TmxReturn error = TmxReturn :: kSuccess ; if ( element -> Attribute ( " name " ) ) { outObj -> name = element -> Attribute ( " name " ) ; } if ( element -> Attribute ( " type " ) ) { outObj -> type = element -> Attribute ( " type " ) ; } outObj -> x = element -> FloatAttribute ( " x " ) ; outObj -> y = element -> FloatAttribute ( " y " ) ; outObj -> width = element -> FloatAttribute ( " width " ) ; outObj -> height = element -> FloatAttribute ( " height " ) ; outObj -> rotation = element -> FloatAttribute ( " rotation " ) ; outObj -> referenceGid = element -> UnsignedAttribute ( " gid " ) ; outObj -> visible = element -> BoolAttribute ( " visible " ) ; error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outObj -> propertyMap ) ; if ( error ) { return error ; } tinyxml2 :: XMLElement * shapeElement = NULL ; if ( ( shapeElement = element -> FirstChildElement ( " ellipse " ) ) != NULL ) { outObj -> shapeType = kEllipse ; } else if ( ( shapeElement = element -> FirstChildElement ( " polygon " ) ) != NULL ) { outObj -> shapeType = kPolygon ; } else if ( ( shapeElement = element -> FirstChildElement ( " polyline " ) ) != NULL ) { outObj -> shapeType = kPolyline ; } else { outObj -> shapeType = kSquare ; } if ( ( outObj -> shapeType == kPolygon || outObj -> shapeType == kPolyline ) && shapeElement != NULL ) { if ( shapeElement -> Attribute ( " points " ) == NULL ) { LOGE ( " Missing ▁ points ▁ attribute ▁ for ▁ shape ▁ requiring ▁ one . . . " ) ; return TmxReturn :: kErrorParsing ; } std :: string pointString = shapeElement -> Attribute ( " points " ) ; std :: istringstream pairStringStream ( pointString ) ; std :: string pairToken ; while ( std :: getline ( pairStringStream , pairToken , ' ▁ ' ) ) { TmxShape@@ Point pair ; std :: istringstream pointStringString ( pairToken ) ; std :: string pointToken ; std :: getline ( pointStringString , pointToken , ' , ' ) ; pair . first = ( float ) atof ( pointToken . c_str ( ) ) ; std :: getline ( pointStringString , pointToken , ' , ' ) ; pair . second = ( float ) atof ( pointToken . c_str ( ) ) ; outObj -> shapePoints . push_back ( pair ) ; } } return error ; } TmxReturn calculateTileCoord@@ inatesUV ( const TmxTileset & tileset , unsigned int tileFlatIndex , float pixelCorrection , bool flipY , TmxRect & outRect ) { if ( tileFlatIndex >= tileset . colCount * tileset . rowCount ) { return TmxReturn :: kInvalidTileIndex ; } TileId_t xIndex = tileFlatIndex % tileset . colCount ; TileId_t yIndex = tileFlatIndex / tileset . colCount ; unsigned int widthDelta = tileset . tileSpacingInImage + tileset . tileMarginInImage * xIndex ; unsigned int heightDelta = tileset . tileSpacingInImage + tileset . tileMarginInImage * yIndex ; float u = ( float ) ( ( xIndex * tileset . tileWidth ) + widthDelta + pixelCorrection ) / ( float ) tileset . image . width ; float v = ( float ) ( ( yIndex * tileset . tileHeight ) + heightDelta + pixelCorrection ) / ( float ) tileset . image . height ; float u2 = ( float ) ( ( ( ( xIndex + 1 ) * tileset . tileWidth ) + widthDelta ) - pixelCorrection ) / ( float ) tileset . image . width ; float v2 = ( float ) ( ( ( ( yIndex + 1 ) * tileset . tileHeight ) + heightDelta ) - pixelCorrection ) / ( float ) tileset . image . height ; if ( flipY ) { float tmpV = v ; v = 1 . f - v2 ; v2 = 1 . f - tmpV ; } outRect . u = u ; outRect . v = v ; outRect . u2 = u2 ; outRect . v2 = v2 ; return kSuccess ; } tmxparser :: TmxReturn _parseOffsetNode ( tinyxml2 :: XMLElement * element , TmxOffset * offset ) { TmxReturn error = TmxReturn :: kSuccess ; offset -> x = 0 ; offset -> y = 0 ; if ( element -> Attribute ( " x " ) ) { offset -> x = element -> IntAttribute ( " x " ) ; } if ( element -> Attribute ( " y " ) ) { offset -> y = element -> IntAttribute ( " y " ) ; } return error ; } tmxparser :: TmxReturn _parseImageLayerNode ( tinyxml2 :: XMLElement * element , TmxImageLayer * outImageLayer ) { TmxReturn error = TmxReturn :: kSuccess ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE_STRING ( element , " name " , outImageLayer -> name ) ; if ( element -> QueryUnsignedAttribute ( " x " , & outImageLayer -> x ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> x = 0U ; if ( element -> QueryUnsignedAttribute ( " y " , & outImageLayer -> y ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> y = 0U ; if ( element -> QueryUnsignedAttribute ( " width " , & outImageLayer -> widthInTiles ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> widthInTiles = 0U ; if ( element -> QueryUnsignedAttribute ( " height " , & outImageLayer -> heightInTiles ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> heightInTiles = 0U ; if ( element -> QueryFloatAttribute ( " opacity " , & outImageLayer -> opacity ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> opacity = 1 . f ; if ( element -> QueryBoolAttribute ( " visible " , & outImageLayer -> visible ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> visible = true ; if ( element -> FirstChildElement ( " properties " ) != NULL ) { error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outImageLayer -> propertyMap ) ; if ( error != kSuccess ) { LOGE ( " Error ▁ parsing ▁ image ▁ layer ▁ property ▁ node . . . " ) ; return error ; } } if ( element -> FirstChildElement ( " image " ) != NULL ) { error = _parseImageNode ( element -> FirstChildElement ( " image " ) , & outImageLayer -> image ) ; if ( error != kSuccess ) return error ; } return error ; } } </DOCUMENT>
