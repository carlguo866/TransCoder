<DOCUMENT_ID="@@ ar@@ un@@ mk@@ /@@ Core@@ NL@@ P@@ /tree/master/@@ test@@ /src/@@ ed@@ u/@@ stan@@ for@@ d/@@ n@@ lp@@ /util/@@ Iter@@ able@@ s@@ Test.java"> package edu . stan@@ for@@ d . nl@@ p . util ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; import java . util . Random ; import java . util . function . Function ; import junit . framework . Assert ; import junit . framework . TestCase ; public class Iter@@ able@@ s@@ Test extends TestCase { public void test@@ Zip ( ) { String [ ] s1 = new String [ ] { " a " , " b " , " c " } ; Integer [ ] s2 = new Integer [ ] { 1 , 2 , 3 , 4 } ; int count = 0 ; for ( Pair < String , Integer > pair : Iter@@ able@@ s . zip ( s1 , s2 ) ) { assertEquals ( pair . first , s1 [ count ] ) ; assertEquals ( pair . second , s2 [ count ] ) ; count ++ ; } assertEquals ( s1 . length < s2 . length ? s1 . length : s2 . length , count ) ; } @ SuppressWarnings ( " un@@ check@@ ed " ) public void test@@ Chain ( ) { List < String > s1 = Arrays . asList ( new String [ ] { " hi " , " th@@ ere " } ) ; List < String > s2 = Arrays . asList ( new String [ ] { } ) ; List < String > s3 = Arrays . asList ( new String [ ] { " y@@ o@@ o " } ) ; List < String > s@@ 4 = Arrays . asList ( new String [ ] { } ) ; List < String > answ@@ er = Arrays . asList ( new String [ ] { " y@@ o@@ o " , " hi " , " th@@ ere " , " y@@ o@@ o " } ) ; List < String > chain@@ ed = new ArrayList < String > ( ) ; for ( String s : Iter@@ able@@ s . chain ( s3 , s1 , s2 , s3 , s@@ 4 ) ) { chain@@ ed . add ( s ) ; } assertEquals ( answ@@ er , chain@@ ed ) ; } public void test@@ Filter ( ) { List < String > values = Arrays . asList ( " a " , " HI " , " t@@ Here " , " Y@@ O " ) ; Iterator < String > iterator = Iter@@ able@@ s . filter ( values , new Function < String , Boolean > ( ) { public Boolean apply ( String in ) { return in . equals ( in . toUpperCase ( ) ) ; } } ) . iterator ( ) ; assertTrue ( iterator . hasNext ( ) ) ; assertEquals ( iterator . next ( ) , " HI " ) ; assertEquals ( iterator . next ( ) , " Y@@ O " ) ; assertFalse ( iterator . hasNext ( ) ) ; } public void test@@ Transform ( ) { List < Integer > values = Arrays . asList ( 1 , 2 , 3 , 4 ) ; List < Integer > squ@@ are@@ s = Arrays . asList ( 1 , 4 , 9 , 16 ) ; Function < Integer , Integer > squ@@ are@@ r = new Function < Integer , Integer > ( ) { public Integer apply ( Integer in ) { return in * in ; } } ; for ( Pair < Integer , Integer > pair : Iter@@ able@@ s . zip ( Iter@@ able@@ s . transform ( values , squ@@ are@@ r ) , squ@@ are@@ s ) ) { assertEquals ( pair . first , pair . second ) ; } } public void test@@ Mer@@ ge ( ) { List < String > a = Arrays . asList ( " a " , " b " , " d " , " e " ) ; List < String > b = Arrays . asList ( " b " , " c " , " d " , " e " ) ; Comparator < String > comp@@ ar@@ ator = new Comparator < String > ( ) { public int compare ( String o@@ 1 , String o@@ 2 ) { return o@@ 1 . compareTo ( o@@ 2 ) ; } } ; Iterator < Pair < String , String > > iter = Iter@@ able@@ s . merge ( a , b , comp@@ ar@@ ator ) . iterator ( ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " b " , " b " ) ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " d " , " d " ) ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " e " , " e " ) ) ; assertTrue ( ! iter . hasNext ( ) ) ; } public void test@@ Merge@@ 3 ( ) { List < String > a = Arrays . asList ( " a " , " b " , " d " , " e " ) ; List < String > b = Arrays . asList ( " b " , " c " , " d " , " e " ) ; List < String > c = Arrays . asList ( " a " , " b " , " c " , " e " , " f " ) ; Comparator < String > comp@@ ar@@ ator = new Comparator < String > ( ) { public int compare ( String o@@ 1 , String o@@ 2 ) { return o@@ 1 . compareTo ( o@@ 2 ) ; } } ; Iterator < Triple < String , String , String > > iter = Iter@@ able@@ s . merge ( a , b , c , comp@@ ar@@ ator ) . iterator ( ) ; assertEquals ( iter . next ( ) , new Triple < String , String , String > ( " b " , " b " , " b " ) ) ; assertEquals ( iter . next ( ) , new Triple < String , String , String > ( " e " , " e " , " e " ) ) ; assertTrue ( ! iter . hasNext ( ) ) ; } public void test@@ Group ( ) { String [ ] input = new String [ ] { "0 ▁ ab " , "0 ▁ b@@ b " , "0 ▁ cc " , "1 ▁ dd " , "2 ▁ dd " , "2 ▁ k@@ j " , "3 ▁ k@@ j " , "3 ▁ k@@ k " } ; int [ ] coun@@ ts = new int [ ] { 3 , 1 , 2 , 2 } ; Comparator < String > field@@ One = new Comparator < String > ( ) { public int compare ( String o@@ 1 , String o@@ 2 ) { return o@@ 1 . split ( " ▁ " ) [ 0 ] . compareTo ( o@@ 2 . split ( " ▁ " ) [ 0 ] ) ; } } ; int index = 0 ; int group = 0 ; for ( Iter@@ able < String > set : Iter@@ able@@ s . group ( Arrays . asList ( input ) , field@@ One ) ) { String shared@@ Key = null ; int this@@ Count = 0 ; for ( String line : set ) { String this@@ Key = line . split ( " ▁ " ) [ 0 ] ; if ( shared@@ Key == null ) { shared@@ Key = this@@ Key ; } else { assertEquals ( " W@@ ron@@ g ▁ key " , shared@@ Key , this@@ Key ) ; } assertEquals ( " W@@ ron@@ g ▁ input ▁ line " , line , input [ index ++ ] ) ; this@@ Count ++ ; } assertEquals ( " W@@ ron@@ g ▁ number ▁ of ▁ items ▁ in ▁ this ▁ iterator " , coun@@ ts [ group ++ ] , this@@ Count ) ; } assertEquals ( " Did@@ n ' t ▁ get ▁ all ▁ inputs " , input . length , index ) ; assertEquals ( " W@@ ron@@ g ▁ number ▁ of ▁ groups " , coun@@ ts . length , group ) ; } public void test@@ S@@ ample ( ) { Iter@@ able < Integer > items = Arrays . asList ( 5 , 4 , 3 , 2 , 1 ) ; int count = 0 ; for ( Integer item : Iter@@ able@@ s . sample ( items , 5 , 2 , new Random ( ) ) ) { ++ count ; Assert . assertTrue ( item <= 5 ) ; Assert . assertTrue ( item >= 1 ) ; } Assert . assertEquals ( 2 , count ) ; } } </DOCUMENT>
<DOCUMENT_ID="@@ ak@@ sh@@ ay@@ ab@@ d/@@ j@@ enk@@ in@@ s/tree/master/@@ core@@ /src/main/java/@@ h@@ ud@@ son@@ /@@ model/@@ ListView@@ .java"> package h@@ ud@@ son . model ; import h@@ ud@@ son . Extension ; import h@@ ud@@ son . Util ; import h@@ ud@@ son . diag@@ no@@ sis . Old@@ Data@@ Monitor ; import h@@ ud@@ son . model . Descriptor . Form@@ Exception ; import h@@ ud@@ son . model . listeners . Item@@ Listener ; import h@@ ud@@ son . security . AC@@ L ; import h@@ ud@@ son . util . Case@@ Insen@@ sitive@@ Comparator ; import h@@ ud@@ son . util . Descri@@ b@@ able@@ List ; import h@@ ud@@ son . util . Form@@ Valid@@ ation ; import h@@ ud@@ son . util . Http@@ Respon@@ s@@ es ; import h@@ ud@@ son . views . ListView@@ Column ; import h@@ ud@@ son . views . View@@ Job@@ Filter ; import java . io . IOException ; import java . util . * ; import java . util . logging . Level ; import java . util . logging . Logger ; import java . util . regex . Pattern ; import java . util . regex . Pattern@@ Syntax@@ Exception ; import javax . annotation . con@@ current . G@@ u@@ ar@@ ded@@ By ; import javax . ser@@ v@@ let . Ser@@ v@@ let@@ Exception ; import j@@ enk@@ ins . model . J@@ enk@@ ins ; import net . s@@ f . json . JS@@ ON@@ Object ; import org . ko@@ h@@ su@@ ke . ac@@ c@@ mod . Re@@ stri@@ cted ; import org . ko@@ h@@ su@@ ke . ac@@ c@@ mod . re@@ stri@@ c@@ tions . No@@ External@@ Use ; import org . ko@@ h@@ su@@ ke . st@@ ap@@ ler . Data@@ Bound@@ Constructor ; import org . ko@@ h@@ su@@ ke . st@@ ap@@ ler . Http@@ Response ; import org . ko@@ h@@ su@@ ke . st@@ ap@@ ler . Query@@ Parameter ; import org . ko@@ h@@ su@@ ke . st@@ ap@@ ler . St@@ ap@@ ler@@ Request ; import org . ko@@ h@@ su@@ ke . st@@ ap@@ ler . St@@ ap@@ ler@@ Response ; import org . ko@@ h@@ su@@ ke . st@@ ap@@ ler . intercept@@ or . Re@@ quire@@ POS@@ T ; public class ListView extends View implements Direct@@ ly@@ Modi@@ fiable@@ View { @ G@@ u@@ ar@@ ded@@ By ( " this " ) Sor@@ ted@@ Set < String > job@@ Names = new Tree@@ Set < String > ( Case@@ Insen@@ sitive@@ Comparator . INSTANCE ) ; private Descri@@ b@@ able@@ List < View@@ Job@@ Filter , Descriptor < View@@ Job@@ Filter > > job@@ Fil@@ ters ; private Descri@@ b@@ able@@ List < ListView@@ Column , Descriptor < ListView@@ Column > > columns ; private String include@@ Reg@@ ex ; private boolean re@@ curse ; private tran@@ si@@ ent Pattern include@@ Pattern ; private Boolean statu@@ s@@ Filter ; @ Data@@ Bound@@ Constructor public ListView ( String name ) { super ( name ) ; init@@ Columns ( ) ; init@@ Job@@ Fil@@ ters ( ) ; } public ListView ( String name , ViewGroup owner ) { this ( name ) ; this . owner = owner ; } private Object read@@ Resolve ( ) { if ( include@@ Reg@@ ex != null ) { try { include@@ Pattern = Pattern . compile ( include@@ Reg@@ ex ) ; } catch ( Pattern@@ Syntax@@ Exception x ) { include@@ Reg@@ ex = null ; Old@@ Data@@ Monitor . report ( this , Collections . < Throwable > singleton ( x ) ) ; } } if ( job@@ Names == null ) { job@@ Names = new Tree@@ Set < String > ( Case@@ Insen@@ sitive@@ Comparator . INSTANCE ) ; } init@@ Columns ( ) ; init@@ Job@@ Fil@@ ters ( ) ; return this ; } protected void init@@ Columns ( ) { if ( columns == null ) columns = new Descri@@ b@@ able@@ List < ListView@@ Column , Descriptor < ListView@@ Column > > ( this , ListView@@ Column . create@@ Default@@ Initial@@ Column@@ List ( ) ) ; } protected void init@@ Job@@ Fil@@ ters ( ) { if ( job@@ Fil@@ ters == null ) job@@ Fil@@ ters = new Descri@@ b@@ able@@ List < View@@ Job@@ Filter , Descriptor < View@@ Job@@ Filter > > ( this ) ; } public boolean has@@ Job@@ Filter@@ Extensions ( ) { return ! View@@ Job@@ Filter . all ( ) . isEmpty ( ) ; } public Descri@@ b@@ able@@ List < View@@ Job@@ Filter , Descriptor < View@@ Job@@ Filter > > getJob@@ Fil@@ ters ( ) { return job@@ Fil@@ ters ; } @ Override public Descri@@ b@@ able@@ List < ListView@@ Column , Descriptor < ListView@@ Column > > get@@ Columns ( ) { return columns ; } @ Override public List < TopLevel@@ Item > get@@ Items ( ) { Sor@@ ted@@ Set < String > names ; List < TopLevel@@ Item > items = new ArrayList < TopLevel@@ Item > ( ) ; synchronized ( this ) { names = new Tree@@ Set < String > ( job@@ Names ) ; } Item@@ Group < ? extends TopLevel@@ Item > parent = get@@ Owner@@ Item@@ Group ( ) ; List < TopLevel@@ Item > parent@@ Items = new ArrayList < TopLevel@@ Item > ( parent . get@@ Items ( ) ) ; include@@ Items ( parent , parent@@ Items , names ) ; Boolean statu@@ s@@ Filter = this . statu@@ s@@ Filter ; Iter@@ able < ? extends TopLevel@@ Item > cand@@ id@@ ates ; if ( re@@ curse ) { cand@@ id@@ ates = Items . getAll@@ Items ( parent , TopLevel@@ Item . class ) ; } else { cand@@ id@@ ates = parent . get@@ Items ( ) ; } for ( TopLevel@@ Item item : cand@@ id@@ ates ) { if ( ! names . contains ( item . getRelative@@ Name@@ From ( get@@ Owner@@ Item@@ Group ( ) ) ) ) continue ; if ( statu@@ s@@ Filter == null || ! ( item instanceof Abstract@@ Project ) || ( ( Abstract@@ Project ) item ) . is@@ Disabled ( ) ^ statu@@ s@@ Filter ) items . add ( item ) ; } Iter@@ able < View@@ Job@@ Filter > job@@ Fil@@ ters = getJob@@ Fil@@ ters ( ) ; List < TopLevel@@ Item > all@@ Items = new ArrayList < TopLevel@@ Item > ( parent@@ Items ) ; if ( re@@ curse ) all@@ Items = expand ( all@@ Items , new ArrayList < TopLevel@@ Item > ( ) ) ; for ( View@@ Job@@ Filter job@@ Filter : job@@ Fil@@ ters ) { items = job@@ Filter . filter ( items , all@@ Items , this ) ; } items = new ArrayList < TopLevel@@ Item > ( new Link@@ ed@@ Hash@@ Set < TopLevel@@ Item > ( items ) ) ; return items ; } private List < TopLevel@@ Item > expand ( Collection < TopLevel@@ Item > items , List < TopLevel@@ Item > all@@ Items ) { for ( TopLevel@@ Item item : items ) { if ( item instanceof Item@@ Group ) { Item@@ Group < ? extends Item > i@@ g = ( Item@@ Group < ? extends Item > ) item ; expand ( Util . filter ( i@@ g . get@@ Items ( ) , TopLevel@@ Item . class ) , all@@ Items ) ; } all@@ Items . add ( item ) ; } return all@@ Items ; } @ Override public boolean contains ( TopLevel@@ Item item ) { return get@@ Items ( ) . contains ( item ) ; } private void include@@ Items ( Item@@ Group < ? extends TopLevel@@ Item > root , Collection < ? extends Item > parent@@ Items , Sor@@ ted@@ Set < String > names ) { if ( include@@ Pattern != null ) { for ( Item item : parent@@ Items ) { if ( re@@ curse && item instanceof Item@@ Group ) { Item@@ Group < ? > i@@ g = ( Item@@ Group < ? > ) item ; include@@ Items ( root , i@@ g . get@@ Items ( ) , names ) ; } if ( item instanceof TopLevel@@ Item ) { String itemName = item . getRelative@@ Name@@ From ( root ) ; if ( include@@ Pattern . match@@ er ( itemName ) . matches ( ) ) { names . add ( itemName ) ; } } } } } public synchronized boolean job@@ N@@ ames@@ Contain@@ s ( TopLevel@@ Item item ) { if ( item == null ) return false ; return job@@ Names . contains ( item . getRelative@@ Name@@ From ( get@@ Owner@@ Item@@ Group ( ) ) ) ; } @ Override public void add ( TopLevel@@ Item item ) throws IOException { synchronized ( this ) { job@@ Names . add ( item . getRelative@@ Name@@ From ( get@@ Owner@@ Item@@ Group ( ) ) ) ; } save ( ) ; } @ Override public boolean remove ( TopLevel@@ Item item ) throws IOException { synchronized ( this ) { String name = item . getRelative@@ Name@@ From ( get@@ Owner@@ Item@@ Group ( ) ) ; if ( ! job@@ Names . remove ( name ) ) return false ; } save ( ) ; return true ; } public String getIn@@ clude@@ Reg@@ ex ( ) { return include@@ Reg@@ ex ; } public boolean is@@ Rec@@ ur@@ se ( ) { return re@@ curse ; } public void set@@ Rec@@ ur@@ se ( boolean re@@ curse ) { this . re@@ curse = re@@ curse ; } public Boolean get@@ Status@@ Filter ( ) { return statu@@ s@@ Filter ; } @ Override @ Re@@ quire@@ POS@@ T public Item do@@ Create@@ Item ( St@@ ap@@ ler@@ Request req , St@@ ap@@ ler@@ Response r@@ sp ) throws IOException , Ser@@ v@@ let@@ Exception { Item@@ Group < ? extends TopLevel@@ Item > i@@ g = get@@ Owner@@ Item@@ Group ( ) ; if ( i@@ g instanceof Modi@@ fiable@@ Item@@ Group ) { TopLevel@@ Item item = ( ( Modi@@ fiable@@ Item@@ Group < ? extends TopLevel@@ Item > ) i@@ g ) . do@@ Create@@ Item ( req , r@@ sp ) ; if ( item != null ) { synchronized ( this ) { job@@ Names . add ( item . getRelative@@ Name@@ From ( get@@ Owner@@ Item@@ Group ( ) ) ) ; } owner . save ( ) ; } return item ; } return null ; } @ Override @ Re@@ quire@@ POS@@ T public Http@@ Response doAdd@@ Job@@ To@@ View ( @ Query@@ Parameter String name ) throws IOException , Ser@@ v@@ let@@ Exception { checkPermission ( View . CON@@ FI@@ G@@ URE ) ; if ( name == null ) throw new Failure ( " Query ▁ parameter ▁ ' name ' ▁ is ▁ required " ) ; TopLevel@@ Item item = resolve@@ Name ( name ) ; if ( item == null ) throw new Failure ( " Query ▁ parameter ▁ ' name ' ▁ does ▁ not ▁ cor@@ respon@@ d ▁ to ▁ a ▁ known ▁ item " ) ; if ( contains ( item ) ) return Http@@ Respon@@ s@@ es . ok ( ) ; add ( item ) ; owner . save ( ) ; return Http@@ Respon@@ s@@ es . ok ( ) ; } @ Override @ Re@@ quire@@ POS@@ T public Http@@ Response do@@ Remove@@ Job@@ From@@ View ( @ Query@@ Parameter String name ) throws IOException , Ser@@ v@@ let@@ Exception { checkPermission ( View . CON@@ FI@@ G@@ URE ) ; if ( name == null ) throw new Failure ( " Query ▁ parameter ▁ ' name ' ▁ is ▁ required " ) ; TopLevel@@ Item item = resolve@@ Name ( name ) ; if ( remove ( item ) ) owner . save ( ) ; return Http@@ Respon@@ s@@ es . ok ( ) ; } private TopLevel@@ Item resolve@@ Name ( String name ) { TopLevel@@ Item item = get@@ Owner@@ Item@@ Group ( ) . getItem ( name ) ; if ( item == null ) { name = Items . getCanonicalName ( get@@ Owner@@ Item@@ Group ( ) , name ) ; item = J@@ enk@@ ins . getInstance ( ) . getItem@@ By@@ Full@@ Name ( name , TopLevel@@ Item . class ) ; } return item ; } @ Override protected void sub@@ mit ( St@@ ap@@ ler@@ Request req ) throws Ser@@ v@@ let@@ Exception , Form@@ Exception , IOException { JS@@ ON@@ Object json = req . getSub@@ mit@@ ted@@ Form ( ) ; synchronized ( this ) { re@@ curse = json . opt@@ Boolean ( " re@@ curse " , true ) ; job@@ Names . clear ( ) ; Iter@@ able < ? extends TopLevel@@ Item > items ; if ( re@@ curse ) { items = Items . getAll@@ Items ( get@@ Owner@@ Item@@ Group ( ) , TopLevel@@ Item . class ) ; } else { items = get@@ Owner@@ Item@@ Group ( ) . get@@ Items ( ) ; } for ( TopLevel@@ Item item : items ) { String relative@@ Name@@ From = item . getRelative@@ Name@@ From ( get@@ Owner@@ Item@@ Group ( ) ) ; if ( req . getParam@@ eter ( relative@@ Name@@ From ) != null ) { job@@ Names . add ( relative@@ Name@@ From ) ; } } } set@@ Include@@ Reg@@ ex ( req . getParam@@ eter ( " use@@ include@@ regex " ) != null ? req . getParam@@ eter ( " include@@ Reg@@ ex " ) : null ) ; if ( columns == null ) { columns = new Descri@@ b@@ able@@ List < ListView@@ Column , Descriptor < ListView@@ Column > > ( this ) ; } columns . rebuild@@ H@@ eter@@ o ( req , json , ListView@@ Column . all ( ) , " columns " ) ; if ( job@@ Fil@@ ters == null ) { job@@ Fil@@ ters = new Descri@@ b@@ able@@ List < View@@ Job@@ Filter , Descriptor < View@@ Job@@ Filter > > ( this ) ; } job@@ Fil@@ ters . rebuild@@ H@@ eter@@ o ( req , json , View@@ Job@@ Filter . all ( ) , " job@@ Fil@@ ters " ) ; String filter = Util . fix@@ Empty ( req . getParam@@ eter ( " statu@@ s@@ Filter " ) ) ; statu@@ s@@ Filter = filter != null ? "1" . equals ( filter ) : null ; } public void set@@ Include@@ Reg@@ ex ( String include@@ Reg@@ ex ) { this . include@@ Reg@@ ex = Util . nul@@ lify ( include@@ Reg@@ ex ) ; if ( this . include@@ Reg@@ ex == null ) this . include@@ Pattern = null ; else this . include@@ Pattern = Pattern . compile ( include@@ Reg@@ ex ) ; } @ Extension public static class Descriptor@@ Impl extends View@@ Descriptor { @ Override public String getDisplayName ( ) { return Messages . ListView@@ _@@ DisplayName ( ) ; } public Form@@ Valid@@ ation do@@ Check@@ Include@@ Reg@@ ex ( @ Query@@ Parameter String value ) throws IOException , Ser@@ v@@ let@@ Exception , InterruptedException { String v = Util . fix@@ Empty ( value ) ; if ( v != null ) { try { Pattern . compile ( v ) ; } catch ( Pattern@@ Syntax@@ Exception p@@ se ) { return Form@@ Valid@@ ation . error ( p@@ se . getMessage ( ) ) ; } } return Form@@ Valid@@ ation . ok ( ) ; } } @ Deprecated public static List < ListView@@ Column > getDefault@@ Columns ( ) { return ListView@@ Column . create@@ Default@@ Initial@@ Column@@ List ( ) ; } @ Re@@ stri@@ cted ( No@@ External@@ Use . class ) @ Extension public static final class Listener extends Item@@ Listener { @ Override public void on@@ Location@@ Changed ( final Item item , final String old@@ Full@@ Name , final String new@@ Full@@ Name ) { AC@@ L . imp@@ er@@ son@@ ate ( AC@@ L . SYSTE@@ M , new Runnable ( ) { @ Override public void run ( ) { location@@ Changed ( item , old@@ Full@@ Name , new@@ Full@@ Name ) ; } } ) ; } private void location@@ Changed ( Item item , String old@@ Full@@ Name , String new@@ Full@@ Name ) { final J@@ enk@@ ins j@@ enk@@ ins = J@@ enk@@ ins . getInstance ( ) ; for ( View view : j@@ enk@@ ins . getView@@ s ( ) ) { if ( view instanceof ListView ) { ren@@ ame@@ View@@ Item ( old@@ Full@@ Name , new@@ Full@@ Name , j@@ enk@@ ins , ( ListView ) view ) ; } } for ( Item g : j@@ enk@@ ins . getAll@@ Items ( ) ) { if ( g instanceof ViewGroup ) { ViewGroup v@@ g = ( ViewGroup ) g ; for ( View v : v@@ g . getView@@ s ( ) ) { if ( v instanceof ListView ) { ren@@ ame@@ View@@ Item ( old@@ Full@@ Name , new@@ Full@@ Name , v@@ g , ( ListView ) v ) ; } } } } } private void ren@@ ame@@ View@@ Item ( String old@@ Full@@ Name , String new@@ Full@@ Name , ViewGroup v@@ g , ListView lv ) { boolean need@@ s@@ Save ; synchronized ( lv ) { Set < String > old@@ Job@@ Names = new Hash@@ Set < String > ( lv . job@@ Names ) ; lv . job@@ Names . clear ( ) ; for ( String old@@ Name : old@@ Job@@ Names ) { lv . job@@ Names . add ( Items . compute@@ Relative@@ N@@ ames@@ After@@ Ren@@ am@@ ing ( old@@ Full@@ Name , new@@ Full@@ Name , old@@ Name , v@@ g . getItem@@ Group ( ) ) ) ; } need@@ s@@ Save = ! old@@ Job@@ Names . equals ( lv . job@@ Names ) ; } if ( need@@ s@@ Save ) { try { lv . save ( ) ; } catch ( IOException x ) { Logger . getLogger ( ListView . class . getName ( ) ) . log ( Level . WARNING , null , x ) ; } } } @ Override public void on@@ Deleted ( final Item item ) { AC@@ L . imp@@ er@@ son@@ ate ( AC@@ L . SYSTE@@ M , new Runnable ( ) { @ Override public void run ( ) { del@@ eted ( item ) ; } } ) ; } private void del@@ eted ( Item item ) { final J@@ enk@@ ins j@@ enk@@ ins = J@@ enk@@ ins . getInstance ( ) ; for ( View view : j@@ enk@@ ins . getView@@ s ( ) ) { if ( view instanceof ListView ) { delete@@ View@@ Item ( item , j@@ enk@@ ins , ( ListView ) view ) ; } } for ( Item g : j@@ enk@@ ins . getAll@@ Items ( ) ) { if ( g instanceof ViewGroup ) { ViewGroup v@@ g = ( ViewGroup ) g ; for ( View v : v@@ g . getView@@ s ( ) ) { if ( v instanceof ListView ) { delete@@ View@@ Item ( item , v@@ g , ( ListView ) v ) ; } } } } } private void delete@@ View@@ Item ( Item item , ViewGroup v@@ g , ListView lv ) { boolean need@@ s@@ Save ; synchronized ( lv ) { need@@ s@@ Save = lv . job@@ Names . remove ( item . getRelative@@ Name@@ From ( v@@ g . getItem@@ Group ( ) ) ) ; } if ( need@@ s@@ Save ) { try { lv . save ( ) ; } catch ( IOException x ) { Logger . getLogger ( ListView . class . getName ( ) ) . log ( Level . WARNING , null , x ) ; } } } } } </DOCUMENT>
<DOCUMENT_ID="@@ J@@ et@@ B@@ ra@@ ins/@@ intellij-community@@ /tree/master/java/java-@@ tests/testData@@ /@@ codeInsight/da@@ emonCodeAnaly@@ zer/quick@@ Fix@@ /@@ lam@@ b@@ da@@ 2@@ metho@@ d@@ Reference@@ /@@ after@@ A@@ mb@@ ig@@ u@@ ity@@ Without@@ Super@@ Method@@ Non@@ Static@@ .java"> interface I { String foo ( Fo@@ o i ) ; } class Fo@@ o { public String foo ( ) { return null ; } String foo ( int i ) { return null ; } String foo ( Fo@@ o foo ) { return null ; } public static void main ( String [ ] args ) { I i = Fo@@ o :: foo ; } } </DOCUMENT>
<DOCUMENT_ID="@@ ch@@ ri@@ ster@@ 15@@ 5@@ /@@ Inte@@ gr@@ ating@@ F@@ ace@@ book@@ Tutorial@@ /tree/master/@@ Inte@@ gr@@ ating@@ F@@ ace@@ book@@ Tutorial@@ -@@ Un@@ ity@@ /@@ As@@ set@@ s/@@ Plugin@@ s/@@ And@@ ro@@ id@@ /@@ facebook@@ /src/com/@@ facebook@@ /internal/ImageResponseCache.java"> package com . facebook . internal ; import android . content . Context ; import android . util . Log ; import com . facebook . LoggingBehavior ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . HttpURLConnection ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; class ImageResponseCache { static final String TAG = ImageResponseCache . class . getSimpleName ( ) ; private volatile static FileLruCache imageCache ; synchronized static FileLruCache getCache ( Context context ) throws IOException { if ( imageCache == null ) { imageCache = new FileLruCache ( context . getApplicationContext ( ) , TAG , new FileLruCache . Limits ( ) ) ; } return imageCache ; } static InputStream getCachedImageStream ( URI url , Context context ) { InputStream imageStream = null ; if ( url != null ) { if ( isCDNURL ( url ) ) { try { FileLruCache cache = getCache ( context ) ; imageStream = cache . get ( url . toString ( ) ) ; } catch ( IOException e ) { Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , e . toString ( ) ) ; } } } return imageStream ; } static InputStream interceptAndCacheImageStream ( Context context , HttpURLConnection connection ) throws IOException { InputStream stream = null ; if ( connection . getResponseCode ( ) == HttpURLConnection . HTTP_OK ) { URL url = connection . getURL ( ) ; stream = connection . getInputStream ( ) ; try { if ( isCDNURL ( url . toURI ( ) ) ) { FileLruCache cache = getCache ( context ) ; stream = cache . interceptAndPut ( url . toString ( ) , new BufferedHttpInputStream ( stream , connection ) ) ; } } catch ( IOException e ) { } catch ( URISyntaxException e ) { } } return stream ; } private static boolean isCDNURL ( URI url ) { if ( url != null ) { String uriHost = url . getHost ( ) ; if ( uriHost . endsWith ( " fbcdn . net " ) ) { return true ; } if ( uriHost . startsWith ( " fbcdn " ) && uriHost . endsWith ( " akamaih@@ d . net " ) ) { return true ; } } return false ; } static void clearCache ( Context context ) { try { getCache ( context ) . clearCache ( ) ; } catch ( IOException e ) { Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , " clearCache ▁ failed ▁ " + e . getMessage ( ) ) ; } } private static class BufferedHttpInputStream extends BufferedInputStream { HttpURLConnection connection ; BufferedHttpInputStream ( InputStream stream , HttpURLConnection connection ) { super ( stream , Utility . DEFAULT_STRE@@ AM_BUFFER_SIZE ) ; this . connection = connection ; } @ Override public void close ( ) throws IOException { super . close ( ) ; Utility . disconnect@@ Quietly ( connection ) ; } } } </DOCUMENT>
<DOCUMENT_ID="s@@ lb@@ ur@@ son@@ /@@ fast@@ -@@ serialization@@ /tree/master/src/main/java/org/@@ nu@@ st@@ a@@ q@@ /@@ serialization@@ /@@ seri@@ aliz@@ er@@ s/@@ F@@ ST@@ CP@@ Enum@@ Set@@ Serializ@@ er.java"> package org . nu@@ st@@ a@@ q . seri@@ alization . seri@@ aliz@@ ers ; import org . nu@@ st@@ a@@ q . seri@@ alization . F@@ ST@@ Basic@@ Object@@ Serializer ; import org . nu@@ st@@ a@@ q . seri@@ alization . F@@ ST@@ C@@ la@@ zz@@ Info ; import org . nu@@ st@@ a@@ q . seri@@ alization . F@@ ST@@ Object@@ Input ; import org . nu@@ st@@ a@@ q . seri@@ alization . F@@ ST@@ Object@@ Output ; import java . io . IOException ; import java . lang . reflect . Field ; import java . util . EnumSet ; public class F@@ ST@@ CP@@ Enum@@ Set@@ Serializer extends F@@ ST@@ Basic@@ Object@@ Serializer { Field elem@@ Type ; @ Override public void write@@ Object ( F@@ ST@@ Object@@ Output out , Object to@@ Write , F@@ ST@@ C@@ la@@ zz@@ Info cl@@ z@@ Info , F@@ ST@@ C@@ la@@ zz@@ Info . F@@ ST@@ Field@@ Info referenced@@ By , int stream@@ Position ) throws IOException { EnumSet en@@ set = ( EnumSet ) to@@ Write ; int count = 0 ; out . write@@ Int ( en@@ set . size ( ) ) ; if ( en@@ set . isEmpty ( ) ) { EnumSet comp@@ l = EnumSet . comp@@ lement@@ Of ( en@@ set ) ; out . write@@ Class@@ Tag ( comp@@ l . iterator ( ) . next ( ) . getClass ( ) ) ; } else { for ( Object element : en@@ set ) { if ( count == 0 ) { out . write@@ String@@ UTF ( element . getClass ( ) . getName ( ) ) ; } out . write@@ String@@ UTF ( element . toString ( ) ) ; count ++ ; } } } @ Override public boolean alway@@ s@@ Copy ( ) { return false ; } @ Override public Object instantiate ( Class object@@ Class , F@@ ST@@ Object@@ Input in , F@@ ST@@ C@@ la@@ zz@@ Info serialization@@ Info , F@@ ST@@ C@@ la@@ zz@@ Info . F@@ ST@@ Field@@ Info referen@@ ce@@ e , int stream@@ Position ) throws Exception { int len = in . read@@ Int ( ) ; Class elem@@ C@@ l = in . get@@ Class@@ For@@ Name ( in . read@@ String@@ UTF ( ) ) ; EnumSet en@@ Set = EnumSet . n@@ one@@ Of ( elem@@ C@@ l ) ; in . register@@ Object ( en@@ Set , stream@@ Position , serialization@@ Info , referen@@ ce@@ e ) ; for ( int i = 0 ; i < len ; i ++ ) { String val = in . read@@ String@@ UTF ( ) ; en@@ Set . add ( Enum . valueOf ( elem@@ C@@ l , val ) ) ; } return en@@ Set ; } } </DOCUMENT>
<DOCUMENT_ID="sk@@ l@@ int@@ y@@ g/@@ infra@@ /tree/master/@@ s@@ ju@@ k@@ fal@@ l/@@ engine@@ /src/test/java/@@ se/@@ in@@ era@@ /@@ int@@ y@@ g/@@ infra@@ /@@ s@@ ju@@ k@@ fal@@ l/@@ engine@@ /@@ S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ gEn@@ h@@ et@@ Cre@@ ator@@ Test.java"> package se . in@@ era . int@@ y@@ g . infra . s@@ ju@@ k@@ fal@@ l . engine ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNull ; import static org . junit . Assert . assertTrue ; import java . io . IOException ; import java . time . Local@@ Date ; import java . util . List ; import java . util . Map ; import org . junit . Before ; import org . junit . Before@@ Class ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . m@@ oc@@ k@@ it@@ o . junit . M@@ oc@@ k@@ it@@ o@@ JUnit@@ Runner ; import se . in@@ era . int@@ y@@ g . infra . s@@ ju@@ k@@ fal@@ l . d@@ to . In@@ ty@@ g@@ Data ; import se . in@@ era . int@@ y@@ g . infra . s@@ ju@@ k@@ fal@@ l . d@@ to . In@@ ty@@ g@@ Param@@ etr@@ ar ; import se . in@@ era . int@@ y@@ g . infra . s@@ ju@@ k@@ fal@@ l . d@@ to . S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g ; import se . in@@ era . int@@ y@@ g . infra . s@@ ju@@ k@@ fal@@ l . test@@ data . S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g@@ Generator ; @ RunWith ( M@@ oc@@ k@@ it@@ o@@ JUnit@@ Runner . class ) public class S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ gEn@@ h@@ et@@ Cre@@ ator@@ Test { private static final String LOC@@ ATION_@@ INT@@ Y@@ GS@@ DATA = " classpath : S@@ ju@@ k@@ fal@@ l / En@@ h@@ et / int@@ y@@ g@@ s@@ data - cre@@ ator . csv " ; private static List < In@@ ty@@ g@@ Data > int@@ y@@ g@@ Data@@ List ; private S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ gEn@@ h@@ et@@ Cre@@ ator cre@@ ator ; private In@@ ty@@ g@@ Param@@ etr@@ ar parameters ; @ Before@@ Class public static void init@@ TestData ( ) throws IOException { S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g@@ Generator generator = new S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g@@ Generator ( LOC@@ ATION_@@ INT@@ Y@@ GS@@ DATA ) ; int@@ y@@ g@@ Data@@ List = generator . generate ( ) . get ( ) ; assertTrue ( " Expected ▁ 16 ▁ bu@@ t ▁ was ▁ " + int@@ y@@ g@@ Data@@ List . size ( ) , int@@ y@@ g@@ Data@@ List . size ( ) == 16 ) ; } @ Before public void setup ( ) { cre@@ ator = new S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ gEn@@ h@@ et@@ Cre@@ ator ( ) ; parameters = new In@@ ty@@ g@@ Param@@ etr@@ ar ( 5 , Local@@ Date . parse ( "20@@ 16@@ -@@ 02@@ -@@ 16" ) ) ; } @ Test public void test@@ Cre@@ ating@@ Map ( ) { Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create@@ Map ( int@@ y@@ g@@ Data@@ List , parameters ) ; assertTrue ( " Expected ▁ 7 ▁ bu@@ t ▁ was ▁ " + map . size ( ) , map . size ( ) == 7 ) ; } @ Test public void test@@ Reduce@@ d@@ Map ( ) { Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create@@ Map ( int@@ y@@ g@@ Data@@ List , parameters ) ; Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > redu@@ ced@@ Map = cre@@ ator . redu@@ ce@@ Map ( map ) ; assertTrue ( " Expected ▁ 6 ▁ bu@@ t ▁ was ▁ " + redu@@ ced@@ Map . size ( ) , redu@@ ced@@ Map . size ( ) == 6 ) ; } @ Test public void test@@ Sor@@ ted@@ Map ( ) { Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create@@ Map ( int@@ y@@ g@@ Data@@ List , parameters ) ; Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > sor@@ ted@@ Map = cre@@ ator . sort@@ Values ( map ) ; for ( Map . Entry < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > entry : sor@@ ted@@ Map . entrySet ( ) ) { if ( entry . getValue ( ) . size ( ) > 1 ) { S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g [ ] ar@@ r = entry . getValue ( ) . toArray ( new S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g [ entry . getValue ( ) . size ( ) ] ) ; for ( int i = 0 ; i < ar@@ r . length - 1 ; i ++ ) { assertTrue ( ar@@ r [ i ] . get@@ S@@ l@@ ut@@ D@@ atu@@ m ( ) . is@@ Before ( ar@@ r [ i + 1 ] . get@@ S@@ l@@ ut@@ D@@ atu@@ m ( ) ) ) ; } } } } @ Test public void test@@ SetActive@@ C@@ erti@@ fic@@ ate ( ) { Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create@@ Map ( int@@ y@@ g@@ Data@@ List , parameters ) ; Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > active@@ Map = cre@@ ator . setActive ( map ) ; assertTrue ( active@@ Map . entrySet ( ) . stream ( ) . all@@ Match ( e -> e . getValue ( ) . stream ( ) . filter ( o -> o . is@@ A@@ k@@ tiv@@ t@@ In@@ ty@@ g ( ) ) . count ( ) < 2 ) ) ; } @ Test public void test@@ F@@ all@@ 1 ( ) { String key = "@@ 19@@ 79@@ 11@@ 10@@ -@@ 92@@ 9@@ 1" ; Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create ( int@@ y@@ g@@ Data@@ List , parameters ) ; List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ bu@@ t ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assert@@ Start@@ Date ( list . get ( 0 ) , "20@@ 16@@ -@@ 02@@ -0@@ 1" ) ; assert@@ End@@ Date ( list . get ( 1 ) , "20@@ 16@@ -@@ 02@@ -@@ 20@@ " ) ; assertTrue ( list . get ( 1 ) . is@@ A@@ k@@ tiv@@ t@@ In@@ ty@@ g ( ) ) ; } @ Test public void test@@ F@@ all@@ 2 ( ) { String key = "@@ 19@@ 79@@ 112@@ 3@@ -@@ 92@@ 62@@ " ; Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create ( int@@ y@@ g@@ Data@@ List , parameters ) ; List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ bu@@ t ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assert@@ Start@@ Date ( list . get ( 0 ) , "20@@ 16@@ -@@ 02@@ -0@@ 1" ) ; assert@@ End@@ Date ( list . get ( 1 ) , "20@@ 16@@ -@@ 02@@ -@@ 20@@ " ) ; assertTrue ( list . get ( 1 ) . is@@ A@@ k@@ tiv@@ t@@ In@@ ty@@ g ( ) ) ; } @ Test public void test@@ F@@ all@@ 3 ( ) { String key = "@@ 19@@ 79@@ 12@@ 12@@ -@@ 92@@ 80@@ " ; Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create ( int@@ y@@ g@@ Data@@ List , parameters ) ; List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > list = map . get ( key ) ; assertTrue ( " Expected ▁ 3 ▁ bu@@ t ▁ was ▁ " + list . size ( ) , list . size ( ) == 3 ) ; assert@@ Start@@ Date ( list . get ( 0 ) , "20@@ 16@@ -@@ 02@@ -0@@ 1" ) ; assert@@ End@@ Date ( list . get ( 2 ) , "20@@ 16@@ -@@ 02@@ -@@ 25" ) ; assertTrue ( list . get ( 1 ) . is@@ A@@ k@@ tiv@@ t@@ In@@ ty@@ g ( ) ) ; } @ Test public void test@@ F@@ all@@ 4 ( ) { String key = "@@ 198@@ 00@@ 11@@ 3@@ -@@ 92@@ 97@@ " ; Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create ( int@@ y@@ g@@ Data@@ List , parameters ) ; List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > list = map . get ( key ) ; assertTrue ( " Expected ▁ 3 ▁ bu@@ t ▁ was ▁ " + list . size ( ) , list . size ( ) == 3 ) ; assert@@ Start@@ Date ( list . get ( 0 ) , "20@@ 16@@ -@@ 02@@ -0@@ 1" ) ; assert@@ End@@ Date ( list . get ( 2 ) , "20@@ 16@@ -@@ 02@@ -@@ 25" ) ; assertTrue ( list . get ( 1 ) . is@@ A@@ k@@ tiv@@ t@@ In@@ ty@@ g ( ) ) ; } @ Test public void test@@ F@@ all@@ 5 ( ) { String key = "@@ 198@@ 00@@ 12@@ 4@@ -@@ 9@@ 28@@ 6" ; Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create ( int@@ y@@ g@@ Data@@ List , parameters ) ; List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ bu@@ t ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assert@@ Start@@ Date ( list . get ( 0 ) , "20@@ 16@@ -@@ 02@@ -@@ 12" ) ; assert@@ End@@ Date ( list . get ( 1 ) , "20@@ 16@@ -@@ 02@@ -@@ 25" ) ; assertTrue ( list . get ( 0 ) . is@@ A@@ k@@ tiv@@ t@@ In@@ ty@@ g ( ) ) ; assertFalse ( list . get ( 1 ) . is@@ A@@ k@@ tiv@@ t@@ In@@ ty@@ g ( ) ) ; } @ Test public void test@@ F@@ all@@ 6 ( ) { String key = "@@ 198@@ 00@@ 20@@ 7@@ -@@ 92@@ 94@@ " ; Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create ( int@@ y@@ g@@ Data@@ List , parameters ) ; List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ bu@@ t ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assert@@ Start@@ Date ( list . get ( 0 ) , "20@@ 16@@ -@@ 02@@ -@@ 12" ) ; assert@@ End@@ Date ( list . get ( 1 ) , "20@@ 16@@ -@@ 02@@ -@@ 25" ) ; assertFalse ( list . get ( 0 ) . is@@ A@@ k@@ tiv@@ t@@ In@@ ty@@ g ( ) ) ; assertTrue ( list . get ( 1 ) . is@@ A@@ k@@ tiv@@ t@@ In@@ ty@@ g ( ) ) ; } @ Test public void test@@ F@@ all@@ 7 ( ) { String key = "@@ 198@@ 00@@ 22@@ 8-@@ 9@@ 22@@ 4" ; Map < String , List < S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g > > map = cre@@ ator . create ( int@@ y@@ g@@ Data@@ List , parameters ) ; assertNull ( map . get ( key ) ) ; } private static void assert@@ Start@@ Date ( S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g int@@ y@@ g@@ s@@ Data , String d@@ atu@@ m ) { assertTrue ( int@@ y@@ g@@ s@@ Data . getStart@@ D@@ atu@@ m ( ) . equals ( Local@@ Date . parse ( d@@ atu@@ m ) ) ) ; } private static void assert@@ End@@ Date ( S@@ ju@@ k@@ fal@@ l@@ In@@ ty@@ g int@@ y@@ g@@ s@@ Data , String d@@ atu@@ m ) { assertTrue ( int@@ y@@ g@@ s@@ Data . get@@ S@@ l@@ ut@@ D@@ atu@@ m ( ) . equals ( Local@@ Date . parse ( d@@ atu@@ m ) ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="mur@@ ad@@ or@@ /@@ ig@@ n@@ ite@@ /tree/master/modules/@@ core@@ /src/main/java/@@ org/apache/@@ ig@@ n@@ ite/@@ internal/@@ Grid@@ Job@@ Sib@@ ling@@ s@@ Response@@ .java"> package org . apache . ig@@ n@@ ite . internal ; import java . io . Exter@@ n@@ aliz@@ able ; import java . nio . ByteBuffer ; import java . util . Collection ; import org . apache . ig@@ n@@ ite . Ig@@ n@@ ite@@ Check@@ ed@@ Exception ; import org . apache . ig@@ n@@ ite . compute . Compute@@ Job@@ Sibling ; import org . apache . ig@@ n@@ ite . internal . util . typedef . internal . S ; import org . apache . ig@@ n@@ ite . mar@@ sh@@ al@@ ler . Mar@@ sh@@ al@@ ler ; import org . apache . ig@@ n@@ ite . plugin . extensions . communic@@ ation . Message ; import org . apache . ig@@ n@@ ite . plugin . extensions . communic@@ ation . Message@@ Reader ; import org . apache . ig@@ n@@ ite . plugin . extensions . communic@@ ation . Message@@ Writer ; import org . jetbrains . annotations . Nullable ; public class Grid@@ Job@@ Sib@@ ling@@ s@@ Response implements Message { private static final long serialVersionUID = 0L ; @ Grid@@ Direct@@ Tran@@ si@@ ent private Collection < Compute@@ Job@@ Sibling > si@@ bl@@ ings ; private byte [ ] si@@ bl@@ ing@@ s@@ Bytes ; public Grid@@ Job@@ Sib@@ ling@@ s@@ Response ( ) { } public Grid@@ Job@@ Sib@@ ling@@ s@@ Response ( @ Nullable Collection < Compute@@ Job@@ Sibling > si@@ bl@@ ings , @ Nullable byte [ ] si@@ bl@@ ing@@ s@@ Bytes ) { this . si@@ bl@@ ings = si@@ bl@@ ings ; this . si@@ bl@@ ing@@ s@@ Bytes = si@@ bl@@ ing@@ s@@ Bytes ; } public Collection < Compute@@ Job@@ Sibling > job@@ Sib@@ l@@ ings ( ) { return si@@ bl@@ ings ; } public void un@@ mar@@ sh@@ al@@ Sib@@ l@@ ings ( Mar@@ sh@@ al@@ ler mar@@ sh ) throws Ig@@ n@@ ite@@ Check@@ ed@@ Exception { assert mar@@ sh != null ; if ( si@@ bl@@ ing@@ s@@ Bytes != null ) si@@ bl@@ ings = mar@@ sh . un@@ mar@@ sh@@ al ( si@@ bl@@ ing@@ s@@ Bytes , null ) ; } @ Override public void on@@ Ac@@ k@@ Received ( ) { } @ Override public boolean write@@ To ( ByteBuffer buf , Message@@ Writer writer ) { writer . set@@ Buffer ( buf ) ; if ( ! writer . is@@ Header@@ Written ( ) ) { if ( ! writer . write@@ Header ( di@@ rect@@ Type ( ) , field@@ sCount ( ) ) ) return false ; writer . onHeader@@ Written ( ) ; } switch ( writer . state ( ) ) { case 0 : if ( ! writer . write@@ Byte@@ Array ( " si@@ bl@@ ing@@ s@@ Bytes " , si@@ bl@@ ing@@ s@@ Bytes ) ) return false ; writer . incre@@ ment@@ State ( ) ; } return true ; } @ Override public boolean read@@ From ( ByteBuffer buf , Message@@ Reader reader ) { reader . set@@ Buffer ( buf ) ; if ( ! reader . before@@ Message@@ Read ( ) ) return false ; switch ( reader . state ( ) ) { case 0 : si@@ bl@@ ing@@ s@@ Bytes = reader . read@@ Byte@@ Array ( " si@@ bl@@ ing@@ s@@ Bytes " ) ; if ( ! reader . is@@ Last@@ Read ( ) ) return false ; reader . incre@@ ment@@ State ( ) ; } return reader . after@@ Message@@ Read ( Grid@@ Job@@ Sib@@ ling@@ s@@ Response . class ) ; } @ Override public byte di@@ rect@@ Type ( ) { return 4 ; } @ Override public byte field@@ sCount ( ) { return 1 ; } @ Override public String toString ( ) { return S . toString ( Grid@@ Job@@ Sib@@ ling@@ s@@ Response . class , this ) ; } } </DOCUMENT>
<DOCUMENT_ID="@@ sh@@ le@@ e@@ 89@@ /@@ ath@@ en@@ a/tree/master/@@ web@@ /@@ gui@@ /src/main/java/org/@@ on@@ os@@ project@@ /ui/@@ impl/@@ T@@ un@@ n@@ el@@ View@@ Message@@ Handler@@ .java"> package org . on@@ os@@ project . ui . impl ; import com . fasterxml . jackson . databind . node . Object@@ Node ; import com . google . common . collect . Immutable@@ Set ; import org . on@@ os@@ project . incub@@ ator . net . tun@@ nel . T@@ un@@ nel ; import org . on@@ os@@ project . incub@@ ator . net . tun@@ nel . T@@ un@@ n@@ el@@ End@@ Point@@ Formatter ; import org . on@@ os@@ project . incub@@ ator . net . tun@@ nel . T@@ un@@ n@@ el@@ Service ; import org . on@@ os@@ project . ui . Request@@ Handler ; import org . on@@ os@@ project . ui . Ui@@ MessageHandler ; import org . on@@ os@@ project . ui . table . Table@@ Model ; import org . on@@ os@@ project . ui . table . Table@@ Request@@ Handler ; import org . on@@ os@@ project . ui . table . cell . Enum@@ Formatter ; import java . util . Collection ; public class T@@ un@@ n@@ el@@ View@@ MessageHandler extends Ui@@ MessageHandler { private static final String T@@ UN@@ N@@ EL_@@ DATA_@@ REQ = " tun@@ n@@ el@@ Data@@ Request " ; private static final String T@@ UN@@ N@@ EL_@@ DATA_@@ RES@@ P = " tun@@ n@@ el@@ Data@@ Response " ; private static final String T@@ UN@@ N@@ EL@@ S = " tun@@ n@@ els " ; private static final String ID = " id " ; private static final String NAME = " name " ; private static final String ONE = " one " ; private static final String TW@@ O = " two " ; private static final String TYPE = " type " ; private static final String GROUP_@@ ID = " group _ id " ; private static final String B@@ AND@@ WID@@ TH = " b@@ and@@ width " ; private static final String PATH = " path " ; private static final String [ ] COL_@@ ID@@ S = { ID , NAME , ONE , TW@@ O , TYPE , GROUP_@@ ID , B@@ AND@@ WID@@ TH , PATH } ; @ Override protected Collection < Request@@ Handler > create@@ Request@@ Handlers ( ) { return Immutable@@ Set . of ( new T@@ un@@ n@@ el@@ Data@@ Request@@ Handler ( ) ) ; } private final class T@@ un@@ n@@ el@@ Data@@ Request@@ Handler extends Table@@ Request@@ Handler { private static final String NO_@@ RO@@ WS_@@ MESSA@@ GE = " No ▁ tun@@ n@@ els ▁ found " ; public T@@ un@@ n@@ el@@ Data@@ Request@@ Handler ( ) { super ( T@@ UN@@ N@@ EL_@@ DATA_@@ REQ , T@@ UN@@ N@@ EL_@@ DATA_@@ RES@@ P , T@@ UN@@ N@@ EL@@ S ) ; } @ Override protected String [ ] get@@ Column@@ Ids ( ) { return COL_@@ ID@@ S ; } @ Override protected String no@@ Row@@ s@@ Message ( Object@@ Node payload ) { return NO_@@ RO@@ WS_@@ MESSA@@ GE ; } @ Override protected Table@@ Model create@@ Table@@ Model ( ) { Table@@ Model tm = super . create@@ Table@@ Model ( ) ; tm . set@@ Formatter ( ONE , T@@ un@@ n@@ el@@ End@@ Point@@ Formatter . INSTANCE ) ; tm . set@@ Formatter ( TW@@ O , T@@ un@@ n@@ el@@ End@@ Point@@ Formatter . INSTANCE ) ; tm . set@@ Formatter ( TYPE , Enum@@ Formatter . INSTANCE ) ; return tm ; } @ Override protected void pop@@ ulate@@ Table ( Table@@ Model tm , Object@@ Node payload ) { T@@ un@@ n@@ el@@ Service ts = get ( T@@ un@@ n@@ el@@ Service . class ) ; ts . query@@ All@@ T@@ un@@ n@@ els ( ) . for@@ E@@ ach ( tun@@ nel -> pop@@ ulate@@ Row ( tm . add@@ Row ( ) , tun@@ nel ) ) ; } } private void pop@@ ulate@@ Row ( Table@@ Model . Row row , T@@ un@@ nel tun@@ nel ) { row . cell ( ID , tun@@ nel . tun@@ n@@ el@@ Id ( ) . id ( ) ) . cell ( NAME , tun@@ nel . tun@@ n@@ el@@ Name ( ) . value ( ) ) . cell ( ONE , tun@@ nel . src ( ) ) . cell ( TW@@ O , tun@@ nel . dst ( ) ) . cell ( TYPE , tun@@ nel . type ( ) ) . cell ( GROUP_@@ ID , tun@@ nel . group@@ Id ( ) . id ( ) ) . cell ( B@@ AND@@ WID@@ TH , tun@@ nel . annotations ( ) . value ( B@@ AND@@ WID@@ TH ) ) . cell ( PATH , tun@@ nel . path ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="@@ Lo@@ t@@ us@@ un@@ /@@ Of@@ fi@@ ce@@ Helper@@ /tree/master/src/main/java/@@ com/@@ char@@ le@@ sd@@ ream@@ /@@ of@@ fi@@ ce@@ /@@ word@@ /@@ object@@ s/@@ Style@@ .java"> package com . char@@ le@@ sd@@ ream . of@@ fi@@ ce . word . objects ; import com . char@@ le@@ sd@@ ream . of@@ fi@@ ce . Base@@ Object ; import com . jac@@ o@@ b . com . Disp@@ atch ; public class Style extends Base@@ Object { public Style ( Disp@@ atch disp@@ atch ) { super ( disp@@ atch ) ; } } </DOCUMENT>
<DOCUMENT_ID="b@@ or@@ c@@ so@@ k@@ j@@ /camel/tree/master/components/@@ camel@@ -ap@@ n@@ s/@@ src/test/@@ java/org/apache/@@ camel/@@ component@@ /@@ ap@@ n@@ s/@@ Ap@@ ns@@ Produc@@ er@@ Test.java"> package org . apache . camel . component . ap@@ ns ; import com . not@@ no@@ op . ap@@ ns . AP@@ NS ; import com . not@@ no@@ op . ap@@ ns . Ap@@ ns@@ Service ; import com . not@@ no@@ op . ap@@ ns . En@@ h@@ ance@@ d@@ Ap@@ ns@@ Notification ; import com . not@@ no@@ op . ap@@ ns . utils . Ap@@ ns@@ Server@@ Stub ; import org . apache . camel . Cam@@ elContext ; import org . apache . camel . builder . Route@@ Builder ; import org . apache . camel . component . ap@@ ns . factory . Ap@@ ns@@ Service@@ Factory ; import org . apache . camel . component . ap@@ ns . model . Ap@@ ns@@ Constants ; import org . apache . camel . component . ap@@ ns . model . MessageType ; import org . apache . camel . component . ap@@ ns . util . Ap@@ ns@@ Utils ; import org . apache . camel . component . ap@@ ns . util . Test@@ Constants ; import org . apache . camel . test . junit4 . Cam@@ el@@ Test@@ Support ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; public class Ap@@ ns@@ Produc@@ er@@ Test extends Cam@@ el@@ Test@@ Support { private static final String F@@ A@@ KE_@@ TO@@ KEN = "@@ 19@@ 30@@ 83@@ 14@@ 8@@ 34@@ 70@@ 1@@ AC@@ D@@ 83@@ 13@@ AE@@ BD@@ 92@@ AE@@ F@@ DE@@ 192@@ 12@@ 03@@ 7@@ 1@@ FE@@ 13@@ 9@@ 82@@ 39@@ 28@@ 3170@@ 1318@@ B@@ 9@@ 43@@ " ; private Ap@@ ns@@ Server@@ Stub server ; @ Before public void start@@ up ( ) { server = Ap@@ ns@@ Utils . prepare@@ And@@ Start@@ Server ( Test@@ Constants . TEST_@@ G@@ AT@@ E@@ WA@@ Y_@@ PORT , Test@@ Constants . TEST_@@ FEE@@ DB@@ ACK_@@ PORT ) ; } @ After public void stop ( ) { server . stop ( ) ; } @ Test ( timeout = 5000 ) public void test@@ Produc@@ er ( ) throws Exception { String message = " Hello ▁ World " ; String message@@ Payload = AP@@ NS . new@@ Payload ( ) . al@@ er@@ t@@ Bo@@ dy ( message ) . build ( ) ; En@@ h@@ ance@@ d@@ Ap@@ ns@@ Notification ap@@ ns@@ Notification = new En@@ h@@ ance@@ d@@ Ap@@ ns@@ Notification ( 1 , En@@ h@@ ance@@ d@@ Ap@@ ns@@ Notification . MAX@@ IM@@ UM@@ _@@ EXP@@ IR@@ Y , F@@ A@@ KE_@@ TO@@ KEN , message@@ Payload ) ; server . stop@@ At ( ap@@ ns@@ Notification . length ( ) ) ; template . send@@ Bo@@ dy ( " di@@ rect : test " , message ) ; server . get@@ Messages ( ) . ac@@ qu@@ ir@@ e ( ) ; assert@@ Array@@ Equals ( ap@@ ns@@ Notification . mar@@ sh@@ all ( ) , server . get@@ Received ( ) . to@@ Byte@@ Array ( ) ) ; } @ Test ( timeout = 5000 ) public void test@@ Produc@@ erWith@@ Ap@@ ns@@ Notification ( ) throws InterruptedException { String message = " Hello ▁ World " ; String message@@ Payload = AP@@ NS . new@@ Payload ( ) . al@@ er@@ t@@ Bo@@ dy ( message ) . build ( ) ; final En@@ h@@ ance@@ d@@ Ap@@ ns@@ Notification ap@@ ns@@ Notification = new En@@ h@@ ance@@ d@@ Ap@@ ns@@ Notification ( 14 , En@@ h@@ ance@@ d@@ Ap@@ ns@@ Notification . MAX@@ IM@@ UM@@ _@@ EXP@@ IR@@ Y , F@@ A@@ KE_@@ TO@@ KEN , message@@ Payload ) ; server . stop@@ At ( ap@@ ns@@ Notification . length ( ) ) ; template . send@@ Bo@@ dy ( " di@@ rect : test@@ With@@ Ap@@ ns@@ Notification " , ap@@ ns@@ Notification ) ; server . get@@ Messages ( ) . ac@@ qu@@ ir@@ e ( ) ; assert@@ Array@@ Equals ( ap@@ ns@@ Notification . mar@@ sh@@ all ( ) , server . get@@ Received ( ) . to@@ Byte@@ Array ( ) ) ; } protected Cam@@ elContext create@@ Cam@@ elContext ( ) throws Exception { Cam@@ elContext camel@@ Context = super . create@@ Cam@@ elContext ( ) ; Ap@@ ns@@ Service@@ Factory ap@@ ns@@ Service@@ Factory = Ap@@ ns@@ Utils . create@@ Default@@ Test@@ Configuration ( camel@@ Context ) ; Ap@@ ns@@ Service ap@@ ns@@ Service = ap@@ ns@@ Service@@ Factory . get@@ Ap@@ ns@@ Service ( ) ; Ap@@ ns@@ Component ap@@ ns@@ Component = new Ap@@ ns@@ Component ( ap@@ ns@@ Service ) ; camel@@ Context . add@@ Component ( " ap@@ ns " , ap@@ ns@@ Component ) ; return camel@@ Context ; } protected Route@@ Builder create@@ Route@@ Builder ( ) throws Exception { return new Route@@ Builder ( ) { public void configure ( ) throws Exception { from ( " di@@ rect : test " ) . set@@ Header ( Ap@@ ns@@ Constants . HE@@ ADER_@@ TO@@ K@@ EN@@ S , constant ( F@@ A@@ KE_@@ TO@@ KEN ) ) . to ( " ap@@ ns : notify " ) ; from ( " di@@ rect : test@@ With@@ Ap@@ ns@@ Notification " ) . set@@ Header ( Ap@@ ns@@ Constants . HE@@ ADER_@@ MESSA@@ GE_@@ TYPE , constant ( MessageType . AP@@ NS_@@ NO@@ TI@@ F@@ IC@@ ATION . name ( ) ) ) . to ( " ap@@ ns : notify " ) ; } } ; } } </DOCUMENT>
