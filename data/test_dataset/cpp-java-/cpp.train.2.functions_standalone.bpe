protected : void testInit ( ) { CPPUNIT_ASSERT ( iValue :: hasTypeString ( Values :: Bool :: id ) ) ; }
void testAssign ( ) { oValue b ( true ) ; CPPUNIT_ASSERT ( b -> getID ( ) == Values :: Bool :: id ) ; }
void testGet ( ) { CPPUNIT_ASSERT ( oValue ( true ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ! ( ( Values :: Bool * ) oValue ( false ) . get ( ) ) -> output ( ) ) ; }
void testSetClear ( ) { oValue v ( true ) ; v -> clear ( ) ; CPPUNIT_ASSERT ( ! ( v >> bool ( ) ) ) ; Values :: Bool * b = ( Values :: Bool * ) v . get ( ) ; b -> set ( true ) ; CPPUNIT_ASSERT ( v >> bool ( ) ) ; }
void testOperators ( ) { CPPUNIT_ASSERT ( ( oValue ( true ) == oValue ( true ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( true ) != oValue ( false ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( true ) && oValue ( true ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( false ) || oValue ( true ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( ! oValue ( true ) == oValue ( false ) ) >> bool ( ) ) ; CPPUNIT_ASSERT ( ( oValue ( ) << true ) -> getID ( ) == Values :: Bool :: id ) ; CPPUNIT_ASSERT ( ( oValue ( false ) >> bool ( ) ) == false ) ; }
void gbump ( int n ) { base :: gbump ( n ) ; }
virtual int_type pbackfail ( int_type c = traits_type :: eof ( ) ) { return base :: pbackfail ( c ) ; }
int main ( ) { { std :: ifstream bs ( " underflow . dat " ) ; test_buf f ( bs . rdbuf ( ) ) ; assert ( f . sbumpc ( ) == L ' 1' ) ; assert ( f . sgetc ( ) == L ' 2' ) ; assert ( f . pbackfail ( L ' a ' ) == test_buf :: traits_type :: eof ( ) ) ; } { std :: fstream bs ( " underflow . dat " ) ; test_buf f ( bs . rdbuf ( ) ) ; assert ( f . sbumpc ( ) == L ' 1' ) ; assert ( f . sgetc ( ) == L ' 2' ) ; assert ( f . pbackfail ( L ' a ' ) == test_buf :: traits_type :: eof ( ) ) ; assert ( f . sbumpc ( ) == L ' 2' ) ; assert ( f . sgetc ( ) == L ' 3' ) ; } }
int main ( int argc , const char * argv [ ] ) { try { lb app ( argc , argv ) ; return app . run ( ) ; } catch ( lb_error e ) { cerr << e . what ( ) << endl ; return EXIT_FAILURE ; } catch ( runtime_error e ) { cerr << e . what ( ) << endl ; return EXIT_FAILURE ; } catch ( ... ) { cerr << " Unhandled ▁ exception ▁ in ▁ lb . " << endl ; return EXIT_FAILURE ; } }
void saveFile ( std :: string filename , std :: vector < std :: string > lines ) { std :: ofstream save ; save . open ( filename . c_str ( ) ) ; for ( int i = 0 ; i < lines . size ( ) ; i ++ ) { save << lines [ i ] << std :: endl ; } save . close ( ) ; }
void getFunctionEntrypoint ( VM & vm , CodeSpec@@ ializationKind kind , JITCode & jitCode , MacroAssemblerCodePtr & arityCheck ) { if ( ! vm . canUseJIT ( ) ) { if ( kind == CodeForCall ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_function_for_call_prologue ) , JITCode :: InterpreterThunk ) ; arityCheck = MacroAssemblerCodePtr :: createLLIntCodePtr ( llint_function_for_call_arity_check ) ; return ; } ASSERT ( kind == CodeForConstruct ) ; jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_function_for_construct_prologue ) , JITCode :: InterpreterThunk ) ; arityCheck = MacroAssemblerCodePtr :: createLLIntCodePtr ( llint_function_for_construct_arity_check ) ; return ; } ( JIT ) if ( kind == CodeForCall ) { jitCode = JITCode ( vm . getCTIStub ( functionForCallEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; arityCheck = vm . getCTIStub ( functionForCallArityCheckThunkGenerator ) . code ( ) ; return ; } ASSERT ( kind == CodeForConstruct ) ; jitCode = JITCode ( vm . getCTIStub ( functionForConstructEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; arityCheck = vm . getCTIStub ( functionForConstructArityCheckThunkGenerator ) . code ( ) ; }
void getEvalEntrypoint ( VM & vm , JITCode & jitCode ) { if ( ! vm . canUseJIT ( ) ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_eval_@@ prologue ) , JITCode :: InterpreterThunk ) ; return ; } ( JIT ) jitCode = JITCode ( vm . getCTIStub ( evalEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; }
void getProgramEntrypoint ( VM & vm , JITCode & jitCode ) { if ( ! vm . canUseJIT ( ) ) { jitCode = JITCode ( MacroAssemblerCodeRef :: createLLIntCodeRef ( llint_program_prologue ) , JITCode :: InterpreterThunk ) ; return ; } ( JIT ) jitCode = JITCode ( vm . getCTIStub ( programEntryThunkGenerator ) , JITCode :: InterpreterThunk ) ; }
const QualifiedName & pseudoElementTagName ( PseudoId pseudoId ) { switch ( pseudoId ) { case AFTER : { DEFINE_STATIC_LOCAL ( QualifiedName , after , ( nullAtom , " < pseudo : after > " , nullAtom ) ) ; return after ; } case BEFORE : { DEFINE_STATIC_LOCAL ( QualifiedName , before , ( nullAtom , " < pseudo : before > " , nullAtom ) ) ; return before ; } case BACKDROP : { DEFINE_STATIC_LOCAL ( QualifiedName , backdrop , ( nullAtom , " < pseudo : backdrop > " , nullAtom ) ) ; return backdrop ; } default : { ASSERT_NOT_REACHED ( ) ; } } DEFINE_STATIC_LOCAL ( QualifiedName , name , ( nullAtom , " < pseudo > " , nullAtom ) ) ; return name ; }
int System_GetPropertyInt ( SystemProperty prop ) { return - 1 ; }
float fastasin ( double x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; float sqrtthing = sqrt ( 1.0f - x * x ) ; float y = - .357214@@ 2480f + .10870634@@ 63f * x ; y = y * x + 1.062519@@ 236f ; y = y * x + - 2.5112@@ 7850@@ 6f ; y = y * x + .191900116f ; y = y * x + 1.807607311f ; y /= ( 1.807607311f - 1.615@@ 1950@@ 94 * x ) ; return sign * ( y - sqrtthing ) ; }
double atan_66s ( double x ) { const double c1 = 1.6867629106 ; const double c2 = 0.4378497304 ; const double c3 = 1.6867633134 ; double x2 ; x2 = x * x ; return ( x * ( c1 + x2 * c2 ) / ( c3 + x2 ) ) ; }
double fastasin2 ( double x ) { return atan_66s ( x / sqrt ( 1 - x * x ) ) ; }
float fastasin3 ( float x ) { return x + x * x * x * x * x * 0.4971 ; }
float fastasin4 ( float x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; x = M_PI / 2 - sqrtf ( 1.0f - x ) * ( 1.5707288 + - 0.212114@@ 4 * x + 0.074@@ 2610 * x * x + - 0.0187293 * x * x * x ) ; return sign * x ; }
float fastasin5 ( float x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; float fRoot = sqrtf ( 1.0f - x ) ; float fResult = 0.0742@@ 610f + - 0.0187293f * x ; fResult = - 0.21211@@ 44f + fResult * x ; fResult = 1.5707288f + fResult * x ; fResult = M_PI / 2 - fRoot * fResult ; return sign * fResult ; }
bool intersectLineTri ( const vec3 & o , const vec3 & d , const vec3 & v0 , const vec3 & v1 , const vec3 & v2 , float * t ) { const vec3 e1 = v1 - v0 ; const vec3 e2 = v2 - v0 ; const vec3 pvec = cross ( d , e2 ) ; const float det = dot ( e1 , pvec ) ; if ( fabsf ( det ) <= FLT_MIN ) return false ; const float invdet = 1 . f / det ; const vec3 tvec = o - v0 ; const float u = dot ( tvec , pvec ) * invdet ; if ( 0 . f > u || 1 . f < u ) return false ; const vec3 qvec = cross ( tvec , e1 ) ; const float v = dot ( d , qvec ) * invdet ; if ( 0 . f > v || 1 . f < u + v ) return false ; const float s = dot ( e2 , qvec ) * invdet ; if ( s < 0 . f || s >= 1 . f ) return false ; if ( t ) * t = s ; assert ( s >= 0 . f && s <= 1 . f ) ; return true ; }
bool intersectLineBox ( const intersectLineBox_Line & r , const vec3 * boxminmax ) { const float t0 = 0.0f ; const float t1 = 1.0f ; const int * const sign = & r . signx ; register float tmin , tmax , tymin , tymax , tzmin , tzmax ; tmin = ( boxminmax [ sign [ 0 ] ] . x - r . o . x ) * r . inv_d . x ; tmax = ( boxminmax [ 1 - sign [ 0 ] ] . x - r . o . x ) * r . inv_d . x ; tymin = ( boxminmax [ sign [ 1 ] ] . y - r . o . y ) * r . inv_d . y ; tymax = ( boxminmax [ 1 - sign [ 1 ] ] . y - r . o . y ) * r . inv_d . y ; if ( ( tmin > tymax ) || ( tymin > tmax ) ) return false ; if ( tymin > tmin ) tmin = tymin ; if ( tymax < tmax ) tmax = tymax ; tzmin = ( boxminmax [ sign [ 2 ] ] . z - r . o . z ) * r . inv_d . z ; tzmax = ( boxminmax [ 1 - sign [ 2 ] ] . z - r . o . z ) * r . inv_d . z ; if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false ; if ( tzmin > tmin ) tmin = tzmin ; if ( tzmax < tmax ) tmax = tzmax ; return ( ( tmin < t1 ) && ( tmax > t0 ) ) ; }
bool intersectLineBox ( const vec3 & o , const vec3 & d , const vec3 & boxmin , const vec3 & boxmax ) { intersectLineBox_Line line ( o , d ) ; const vec3 boxminmax [ 2 ] = { boxmin , boxmax } ; return intersectLineBox ( line , boxminmax ) ; }
void CG_InitMarkPolys ( void ) { int i ; memset ( cg_markPolys , 0 , sizeof ( cg_markPolys ) ) ; cg_activeMarkPolys . nextMark = & cg_activeMarkPolys ; cg_activeMarkPolys . prevMark = & cg_activeMarkPolys ; cg_freeMarkPolys = cg_markPolys ; for ( i = 0 ; i < MAX_MARK_POLYS - 1 ; i ++ ) { cg_markPolys [ i ] . nextMark = & cg_markPolys [ i + 1 ] ; } }
void CG_FreeMarkPoly ( markPoly_t * le ) { if ( ! le -> prevMark ) { CG_Error ( " CG _ FreeLocalEntity : ▁ not ▁ active " ) ; } le -> prevMark -> nextMark = le -> nextMark ; le -> nextMark -> prevMark = le -> prevMark ; le -> nextMark = cg_freeMarkPolys ; cg_freeMarkPolys = le ; }
markPoly_t * CG_AllocMark ( void ) { markPoly_t * le ; int time ; if ( ! cg_freeMarkPolys ) { time = cg_activeMarkPolys . prevMark -> time ; while ( cg_activeMarkPolys . prevMark && time == cg_activeMarkPolys . prevMark -> time ) { CG_FreeMarkPoly ( cg_activeMarkPolys . prevMark ) ; } } le = cg_freeMarkPolys ; cg_freeMarkPolys = cg_freeMarkPolys -> nextMark ; memset ( le , 0 , sizeof ( * le ) ) ; le -> nextMark = cg_activeMarkPolys . nextMark ; le -> prevMark = & cg_activeMarkPolys ; cg_activeMarkPolys . nextMark -> prevMark = le ; cg_activeMarkPolys . nextMark = le ; return le ; }
void CG_ImpactMark ( qhandle_t markShader , const vec3_t origin , const vec3_t dir , float orientation , float red , float green , float blue , float alpha , qboolean alphaFade , float radius , qboolean temporary ) { vec3_t axis [ 3 ] ; float texCoordScale ; vec3_t originalPoints [ 4 ] ; byte colors [ 4 ] ; int i , j ; int numFragments ; markFragment@@ _t markFragments [ MAX_MARK_FRAGMENTS ] , * mf ; vec3_t markPoints [ MAX_MARK_POINTS ] ; vec3_t projection ; if ( ! cg_addMarks . integer ) { return ; } if ( radius <= 0 ) { CG_Error ( " CG _ ImpactMark ▁ called ▁ with ▁ < = ▁ 0 ▁ radius " ) ; } VectorNor@@ malize2 ( dir , axis [ 0 ] ) ; Perpen@@ dicular@@ Vector ( axis [ 1 ] , axis [ 0 ] ) ; RotatePoint@@ AroundVector ( axis [ 2 ] , axis [ 0 ] , axis [ 1 ] , orientation ) ; CrossProduct ( axis [ 0 ] , axis [ 2 ] , axis [ 1 ] ) ; texCoordScale = 0.5 * 1.0 / radius ; for ( i = 0 ; i < 3 ; i ++ ) { originalPoints [ 0 ] [ i ] = origin [ i ] - radius * axis [ 1 ] [ i ] - radius * axis [ 2 ] [ i ] ; originalPoints [ 1 ] [ i ] = origin [ i ] + radius * axis [ 1 ] [ i ] - radius * axis [ 2 ] [ i ] ; originalPoints [ 2 ] [ i ] = origin [ i ] + radius * axis [ 1 ] [ i ] + radius * axis [ 2 ] [ i ] ; originalPoints [ 3 ] [ i ] = origin [ i ] - radius * axis [ 1 ] [ i ] + radius * axis [ 2 ] [ i ] ; } VectorScale ( dir , - 20 , projection ) ; numFragments = cgi_C@@ M_Mark@@ Fragments ( 4 , ( const float ( * ) [ 3 ] ) originalPoints , projection , MAX_MARK_POINTS , markPoints [ 0 ] , MAX_MARK_FRAGMENTS , markFragments ) ; colors [ 0 ] = red * 255 ; colors [ 1 ] = green * 255 ; colors [ 2 ] = blue * 255 ; colors [ 3 ] = alpha * 255 ; for ( i = 0 , mf = markFragments ; i < numFragments ; i ++ , mf ++ ) { polyVert_t * v ; polyVert_t verts [ MAX_VERTS_ON_POLY ] ; markPoly_t * mark ; if ( mf -> numPoints > MAX_VERTS_ON_POLY ) { mf -> numPoints = MAX_VERTS_ON_POLY ; } for ( j = 0 , v = verts ; j < mf -> numPoints ; j ++ , v ++ ) { vec3_t delta ; VectorCopy ( markPoints [ mf -> firstPoint + j ] , v -> xyz ) ; VectorSubtract ( v -> xyz , origin , delta ) ; v -> st [ 0 ] = 0.5f + DotProduct ( delta , axis [ 1 ] ) * texCoordScale ; v -> st [ 1 ] = 0.5f + DotProduct ( delta , axis [ 2 ] ) * texCoordScale ; for ( int k = 0 ; k < 4 ; k ++ ) { v -> modulate [ k ] = colors [ k ] ; } } if ( temporary ) { cgi_R_AddPolyToScene ( markShader , mf -> numPoints , verts ) ; continue ; } mark = CG_AllocMark ( ) ; mark -> time = cg . time ; mark -> alphaFade = alphaFade ; mark -> markShader = markShader ; mark -> poly . numVerts = mf -> numPoints ; mark -> color [ 0 ] = colors [ 0 ] ; mark -> color [ 1 ] = colors [ 1 ] ; mark -> color [ 2 ] = colors [ 2 ] ; mark -> color [ 3 ] = colors [ 3 ] ; memcpy ( mark -> verts , verts , mf -> numPoints * sizeof ( verts [ 0 ] ) ) ; } }
void CG_AddMarks ( void ) { int j ; markPoly_t * mp , * next ; int t ; int fade ; if ( ! cg_addMarks . integer ) { return ; } mp = cg_activeMarkPolys . nextMark ; for ( ; mp != & cg_activeMarkPolys ; mp = next ) { next = mp -> nextMark ; if ( cg . time > mp -> time + MARK_TOTAL_TIME ) { CG_FreeMarkPoly ( mp ) ; continue ; } t = mp -> time + MARK_TOTAL_TIME - cg . time ; if ( t < MARK_FADE_TIME ) { fade = 255 * t / MARK_FADE_TIME ; if ( mp -> alphaFade ) { for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 3 ] = fade ; } } else { float f = ( float ) t / MARK_FADE_TIME ; for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 0 ] = mp -> color [ 0 ] * f ; mp -> verts [ j ] . modulate [ 1 ] = mp -> color [ 1 ] * f ; mp -> verts [ j ] . modulate [ 2 ] = mp -> color [ 2 ] * f ; } } } else { for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 0 ] = mp -> color [ 0 ] ; mp -> verts [ j ] . modulate [ 1 ] = mp -> color [ 1 ] ; mp -> verts [ j ] . modulate [ 2 ] = mp -> color [ 2 ] ; } } cgi_R_AddPolyToScene ( mp -> markShader , mp -> poly . numVerts , mp -> verts ) ; } }
inline void swap ( short & a , short & b ) { short temp = a ; a = b ; b = temp ; }
void gbafilter_pal ( u16 * buf , int count ) { short temp [ 3 * 3 ] , s ; unsigned pix ; u8 red , green , blue ; while ( count -- ) { pix = * buf ; s = curve [ ( pix >> systemGreenShift ) & 0x1f ] ; temp [ 3 ] = s * influence [ 3 ] ; temp [ 4 ] = s * influence [ 4 ] ; temp [ 5 ] = s * influence [ 5 ] ; s = curve [ ( pix >> systemRedShift ) & 0x1f ] ; temp [ 0 ] = s * influence [ 0 ] ; temp [ 1 ] = s * influence [ 1 ] ; temp [ 2 ] = s * influence [ 2 ] ; s = curve [ ( pix >> systemBlueShift ) & 0x1f ] ; temp [ 6 ] = s * influence [ 6 ] ; temp [ 7 ] = s * influence [ 7 ] ; temp [ 8 ] = s * influence [ 8 ] ; if ( temp [ 0 ] < temp [ 3 ] ) swap ( temp [ 0 ] , temp [ 3 ] ) ; if ( temp [ 0 ] < temp [ 6 ] ) swap ( temp [ 0 ] , temp [ 6 ] ) ; if ( temp [ 3 ] < temp [ 6 ] ) swap ( temp [ 3 ] , temp [ 6 ] ) ; temp [ 3 ] <<= 1 ; temp [ 0 ] <<= 2 ; temp [ 0 ] += temp [ 3 ] + temp [ 6 ] ; red = ( ( int ( temp [ 0 ] ) * 160 ) >> 17 ) + 4 ; if ( red > 31 ) red = 31 ; if ( temp [ 2 ] < temp [ 5 ] ) swap ( temp [ 2 ] , temp [ 5 ] ) ; if ( temp [ 2 ] < temp [ 8 ] ) swap ( temp [ 2 ] , temp [ 8 ] ) ; if ( temp [ 5 ] < temp [ 8 ] ) swap ( temp [ 5 ] , temp [ 8 ] ) ; temp [ 5 ] <<= 1 ; temp [ 2 ] <<= 2 ; temp [ 2 ] += temp [ 5 ] + temp [ 8 ] ; blue = ( ( int ( temp [ 2 ] ) * 160 ) >> 17 ) + 4 ; if ( blue > 31 ) blue = 31 ; if ( temp [ 1 ] < temp [ 4 ] ) swap ( temp [ 1 ] , temp [ 4 ] ) ; if ( temp [ 1 ] < temp [ 7 ] ) swap ( temp [ 1 ] , temp [ 7 ] ) ; if ( temp [ 4 ] < temp [ 7 ] ) swap ( temp [ 4 ] , temp [ 7 ] ) ; temp [ 4 ] <<= 1 ; temp [ 1 ] <<= 2 ; temp [ 1 ] += temp [ 4 ] + temp [ 7 ] ; green = ( ( int ( temp [ 1 ] ) * 160 ) >> 17 ) + 4 ; if ( green > 31 ) green = 31 ; pix = red << systemRedShift ; pix += green << systemGreenShift ; pix += blue << systemBlueShift ; * buf ++ = pix ; } }
void gbafilter_pal32 ( u32 * buf , int count ) { short temp [ 3 * 3 ] , s ; unsigned pix ; u8 red , green , blue ; while ( count -- ) { pix = * buf ; s = curve [ ( pix >> systemGreenShift ) & 0x1f ] ; temp [ 3 ] = s * influence [ 3 ] ; temp [ 4 ] = s * influence [ 4 ] ; temp [ 5 ] = s * influence [ 5 ] ; s = curve [ ( pix >> systemRedShift ) & 0x1f ] ; temp [ 0 ] = s * influence [ 0 ] ; temp [ 1 ] = s * influence [ 1 ] ; temp [ 2 ] = s * influence [ 2 ] ; s = curve [ ( pix >> systemBlueShift ) & 0x1f ] ; temp [ 6 ] = s * influence [ 6 ] ; temp [ 7 ] = s * influence [ 7 ] ; temp [ 8 ] = s * influence [ 8 ] ; if ( temp [ 0 ] < temp [ 3 ] ) swap ( temp [ 0 ] , temp [ 3 ] ) ; if ( temp [ 0 ] < temp [ 6 ] ) swap ( temp [ 0 ] , temp [ 6 ] ) ; if ( temp [ 3 ] < temp [ 6 ] ) swap ( temp [ 3 ] , temp [ 6 ] ) ; temp [ 3 ] <<= 1 ; temp [ 0 ] <<= 2 ; temp [ 0 ] += temp [ 3 ] + temp [ 6 ] ; red = ( ( int ( temp [ 0 ] ) * 160 ) >> 14 ) + 32 ; if ( temp [ 2 ] < temp [ 5 ] ) swap ( temp [ 2 ] , temp [ 5 ] ) ; if ( temp [ 2 ] < temp [ 8 ] ) swap ( temp [ 2 ] , temp [ 8 ] ) ; if ( temp [ 5 ] < temp [ 8 ] ) swap ( temp [ 5 ] , temp [ 8 ] ) ; temp [ 5 ] <<= 1 ; temp [ 2 ] <<= 2 ; temp [ 2 ] += temp [ 5 ] + temp [ 8 ] ; blue = ( ( int ( temp [ 2 ] ) * 160 ) >> 14 ) + 32 ; if ( temp [ 1 ] < temp [ 4 ] ) swap ( temp [ 1 ] , temp [ 4 ] ) ; if ( temp [ 1 ] < temp [ 7 ] ) swap ( temp [ 1 ] , temp [ 7 ] ) ; if ( temp [ 4 ] < temp [ 7 ] ) swap ( temp [ 4 ] , temp [ 7 ] ) ; temp [ 4 ] <<= 1 ; temp [ 1 ] <<= 2 ; temp [ 1 ] += temp [ 4 ] + temp [ 7 ] ; green = ( ( int ( temp [ 1 ] ) * 160 ) >> 14 ) + 32 ; pix = red << ( systemRedShift - 3 ) ; pix += green << ( systemGreenShift - 3 ) ; pix += blue << ( systemBlueShift - 3 ) ; * buf ++ = pix ; } }
void gbafilter_pad ( u8 * buf , int count ) { union { struct { u8 r ; u8 g ; u8 b ; u8 a ; } part ; unsigned whole ; } mask ; mask . whole = 0x1f << systemRedShift ; mask . whole += 0x1f << systemGreenShift ; mask . whole += 0x1f << systemBlueShift ; switch ( systemColorDepth ) { case 24 : while ( count -- ) { * buf ++ &= mask . part . r ; * buf ++ &= mask . part . g ; * buf ++ &= mask . part . b ; } break ; case 32 : while ( count -- ) { * ( ( u32 * ) buf ) &= mask . whole ; buf += 4 ; } } }
~ CDBInit ( ) { if ( fDbEnvInit ) { dbenv . close ( 0 ) ; fDbEnvInit = false ; } }
void static CloseDb ( const string & strFile ) { CRITICAL_BLOCK ( cs_db ) { if ( mapDb [ strFile ] != NULL ) { Db * pdb = mapDb [ strFile ] ; pdb -> close ( 0 ) ; delete pdb ; mapDb [ strFile ] = NULL ; } } }
void DBFlush ( bool fShutdown ) { printf ( " DBFlush ( % s ) % s \n " , fShutdown ? " true " : " false " , fDbEnvInit ? " " : " ▁ db ▁ not ▁ started " ) ; if ( ! fDbEnvInit ) return ; CRITICAL_BLOCK ( cs_db ) { map < string , int > :: iterator mi = mapFileUseCount . begin ( ) ; while ( mi != mapFileUseCount . end ( ) ) { string strFile = ( * mi ) . first ; int nRefCount = ( * mi ) . second ; printf ( " % s ▁ refcount = % d \n " , strFile . c_str ( ) , nRefCount ) ; if ( nRefCount == 0 ) { CloseDb ( strFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; printf ( " % s ▁ flush \n " , strFile . c_str ( ) ) ; dbenv . lsn_reset ( strFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( mi ++ ) ; } else mi ++ ; } if ( fShutdown ) { char * * listp ; if ( mapFileUseCount . empty ( ) ) dbenv . log_arch@@ ive ( & listp , DB_AR@@ CH_REMOVE ) ; dbenv . close ( 0 ) ; fDbEnvInit = false ; } } }
CBlockIndex static * InsertBlockIndex ( uint256 hash ) { if ( hash == 0 ) return NULL ; map < uint256 , CBlockIndex * > :: iterator mi = mapBlockIndex . find ( hash ) ; if ( mi != mapBlockIndex . end ( ) ) return ( * mi ) . second ; CBlockIndex * pindexNew = new CBlockIndex ( ) ; if ( ! pindexNew ) throw runtime_error ( " LoadBlockIndex ( ) ▁ : ▁ new ▁ CBlockIndex ▁ failed " ) ; mi = mapBlockIndex . insert ( make_pair ( hash , pindexNew ) ) . first ; pindexNew -> phashBlock = & ( ( * mi ) . first ) ; return pindexNew ; }
bool LoadAddresses ( ) { return CAddrDB ( " cr + " ) . LoadAddresses ( ) ; }
void ThreadFlush@@ WalletDB ( void * parg ) { const string & strFile = ( ( const string * ) parg ) [ 0 ] ; static bool fOneThread ; if ( fOneThread ) return ; fOneThread = true ; if ( mapArgs . count ( " - noflushwallet " ) ) return ; unsigned int nLastSeen = nWalletDBUpdated ; unsigned int nLastFlushed = nWalletDBUpdated ; int64 nLastWalletUpdate = GetTime ( ) ; while ( ! fShutdown ) { Sleep ( 500 ) ; if ( nLastSeen != nWalletDBUpdated ) { nLastSeen = nWalletDBUpdated ; nLastWalletUpdate = GetTime ( ) ; } if ( nLastFlushed != nWalletDBUpdated && GetTime ( ) - nLastWalletUpdate >= 2 ) { TRY_CRITICAL_BLOCK ( cs_db ) { int nRefCount = 0 ; map < string , int > :: iterator mi = mapFileUseCount . begin ( ) ; while ( mi != mapFileUseCount . end ( ) ) { nRefCount += ( * mi ) . second ; mi ++ ; } if ( nRefCount == 0 && ! fShutdown ) { map < string , int > :: iterator mi = mapFileUseCount . find ( strFile ) ; if ( mi != mapFileUseCount . end ( ) ) { printf ( " % s ▁ " , DateTimeStrFormat ( " % x ▁ % H : % M : % S " , GetTime ( ) ) . c_str ( ) ) ; printf ( " Flushing ▁ wallet . dat \n " ) ; nLastFlushed = nWalletDBUpdated ; int64 nStart = GetTimeMillis ( ) ; CloseDb ( strFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; dbenv . lsn_reset ( strFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( mi ++ ) ; printf ( " Flushed ▁ wallet . dat ▁ % " PRI64d " ms \n " , GetTimeMillis ( ) - nStart ) ; } } } } } }
bool BackupWallet ( const CWallet & wallet , const string & strDest ) { if ( ! wallet . fFileBacked ) return false ; while ( ! fShutdown ) { CRITICAL_BLOCK ( cs_db ) { if ( ! mapFileUseCount . count ( wallet . strWalletFile ) || mapFileUseCount [ wallet . strWalletFile ] == 0 ) { CloseDb ( wallet . strWalletFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; dbenv . lsn_reset ( wallet . strWalletFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( wallet . strWalletFile ) ; filesystem :: path pathSrc ( GetDataDir ( ) + " / " + wallet . strWalletFile ) ; filesystem :: path pathDest ( strDest ) ; if ( filesystem :: is_directory ( pathDest ) ) pathDest = pathDest / wallet . strWalletFile ; >= 104000 filesystem :: copy_file ( pathSrc , pathDest , filesystem :: copy_option :: overwrite_@@ if_exists ) ; filesystem :: copy_file ( pathSrc , pathDest ) ; printf ( " copied ▁ wallet . dat ▁ to ▁ % s \n " , pathDest . string ( ) . c_str ( ) ) ; return true ; } } Sleep ( 100 ) ; } return false ; }
static UBool compareRules ( UVector * rules1 , UVector * rules2 ) { if ( rules1 == NULL && rules2 == NULL ) { return TRUE ; } else if ( rules1 == NULL || rules2 == NULL ) { return FALSE ; } int32_t size = rules1 -> size ( ) ; if ( size != rules2 -> size ( ) ) { return FALSE ; } for ( int32_t i = 0 ; i < size ; i ++ ) { TimeZoneRule * r1 = ( TimeZoneRule * ) rules1 -> elementAt ( i ) ; TimeZoneRule * r2 = ( TimeZoneRule * ) rules2 -> elementAt ( i ) ; if ( * r1 != * r2 ) { return FALSE ; } } return TRUE ; }
