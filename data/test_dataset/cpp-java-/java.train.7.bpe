<DOCUMENT_ID="Atwo@@ oTM/cassandra/tree/master/src/java/org/apache/@@ cassandra/cql3@@ /UTName.java"> package org . apache . cassandra . cql3 ; import java . nio . ByteBuffer ; public class UTName { private String ksName ; private final ColumnIdentifier utName ; public UTName ( ColumnIdentifier ksName , ColumnIdentifier utName ) { this . ksName = ksName == null ? null : ksName . toString ( ) ; this . utName = utName ; } public boolean hasKeyspace ( ) { return ksName != null ; } public void setKeyspace ( String keyspace ) { this . ksName = keyspace ; } public String getKeyspace ( ) { return ksName ; } public ByteBuffer getUserTypeName ( ) { return utName . bytes ; } public String getStringTypeName ( ) { return utName . toString ( ) ; } @ Override public String toString ( ) { return ( hasKeyspace ( ) ? ( ksName + " . " ) : " " ) + utName ; } } </DOCUMENT>
<DOCUMENT_ID="Wel@@ comeHUME/svn-@@ caucho-com@@ -resin/tree/master/modules/@@ jca/src/javax/@@ resource/cci/ResourceAdapter@@ MetaData.java"> package javax . resource . cci ; public interface ResourceAdapterMetaData { public String getAdapterVersion ( ) ; public String getAdapterVendorName ( ) ; public String getAdapterName ( ) ; public String getAdapterShortDescription ( ) ; public String getSpecVersion ( ) ; public String [ ] getInteractionSpecsSupported ( ) ; public boolean supportsExecuteWithInputAndOutput@@ Record ( ) ; public boolean supportsExecuteWithInputRecordOnly ( ) ; public boolean supportsLocalTransaction@@ Demarcation ( ) ; } </DOCUMENT>
<DOCUMENT_ID="tharind@@ um/opennms_dash@@ board/tree/master/openn@@ ms-web@@ app/src/main/java/org/openn@@ ms/web/report@@ /database/ReportParameters@@ Validator.java"> package org . opennms . web . report . database ; import java . util . Iterator ; import java . util . List ; import org . opennms . api . reporting . parameter . ReportDoubleParm ; import org . opennms . api . reporting . parameter . ReportFloatParm ; import org . opennms . api . reporting . parameter . ReportParameters ; import org . opennms . api . reporting . parameter . ReportDateParm ; import org . opennms . api . reporting . parameter . ReportIntParm ; import org . opennms . api . reporting . parameter . ReportStringParm ; import org . springframework . binding . message . MessageBuilder ; import org . springframework . binding . message . MessageContext ; import org . springframework . binding . validation . ValidationContext ; public class ReportParametersValidator { public void validateReportParameters ( ReportParameters reportCriteria , ValidationContext context ) { MessageContext messages = context . getMessageContext ( ) ; List < ReportDateParm > dateParms = reportCriteria . getDateParms ( ) ; for ( Iterator < ReportDateParm > dateParmIter = dateParms . iterator ( ) ; dateParmIter . hasNext ( ) ; ) { ReportDateParm dateParm = dateParmIter . next ( ) ; if ( dateParm . getDate ( ) == null ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " date ▁ parms " ) . defaultText ( " cannot ▁ have ▁ null ▁ date ▁ field " + dateParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportStringParm > stringParms = reportCriteria . getStringParms ( ) ; for ( Iterator < ReportStringParm > stringParmIter = stringParms . iterator ( ) ; stringParmIter . hasNext ( ) ; ) { ReportStringParm stringParm = stringParmIter . next ( ) ; if ( stringParm . getValue ( ) == " " ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " string ▁ parms " ) . defaultText ( " cannot ▁ have ▁ empty ▁ string ▁ field " + stringParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportIntParm > intParms = reportCriteria . getIntParms ( ) ; for ( Iterator < ReportIntParm > intParmIter = intParms . iterator ( ) ; intParmIter . hasNext ( ) ; ) { ReportIntParm intParm = intParmIter . next ( ) ; if ( intParm . getValue ( ) == 0 ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " int ▁ parms " ) . defaultText ( " cannot ▁ have ▁ zero ▁ integer ▁ field " + intParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportFloatParm > floatParms = reportCriteria . getFloatParms ( ) ; for ( Iterator < ReportFloatParm > floatParmIter = floatParms . iterator ( ) ; floatParmIter . hasNext ( ) ; ) { ReportFloatParm floatParm = floatParmIter . next ( ) ; if ( floatParm . getValue ( ) == null ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " float ▁ parms " ) . defaultText ( " cannot ▁ have ▁ null ▁ float ▁ field " + floatParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportDoubleParm > doubleParms = reportCriteria . getDoubleParms ( ) ; for ( Iterator < ReportDoubleParm > doubleParmIter = doubleParms . iterator ( ) ; doubleParmIter . hasNext ( ) ; ) { ReportDoubleParm doubleParm = doubleParmIter . next ( ) ; if ( doubleParm . getValue ( ) == null ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " double ▁ parms " ) . defaultText ( " cannot ▁ have ▁ null ▁ double ▁ field " + doubleParm . getDisplayName ( ) ) . build ( ) ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="tuxil@@ lo/aarch64-dr@@ agonfly-gcc/tree/master/@@ libjava/classp@@ ath/g@@ nu/java/@@ net/protocol/@@ jar/Handler@@ .java"> package gnu . java . net . protocol . jar ; import gnu . java . lang . CPStringBuilder ; import gnu . java . net . URLParseError ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLConnection ; import java . net . URLStreamHandler ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . StringTokenizer ; public class Handler extends URLStreamHandler { public Handler ( ) { } protected URLConnection openConnection ( URL url ) throws IOException { return new Connection ( url ) ; } protected void parseURL ( URL url , String url_string , int start , int end ) { String file = url . getFile ( ) ; if ( ! file . equals ( " " ) ) { url_string = url_string . substring ( start , end ) ; if ( url_string . startsWith ( " / " ) ) { int idx = file . lastIndexOf ( " ! / " ) ; if ( idx < 0 ) throw new URLParseError ( " no ▁ ! / ▁ in ▁ spec " ) ; file = file . substring ( 0 , idx + 1 ) + url_string ; } else if ( url_string . length ( ) > 0 ) { int idx = file . lastIndexOf ( " / " ) ; if ( idx == - 1 ) file = " / " + url_string ; else if ( idx == ( file . length ( ) - 1 ) ) file = file + url_string ; else file = file . substring ( 0 , idx + 1 ) + url_string ; } setURL ( url , " jar " , url . getHost ( ) , url . getPort ( ) , flat ( file ) , null ) ; return ; } if ( end < start ) return ; if ( end - start < 2 ) return ; if ( start > url_string . length ( ) ) return ; url_string = url_string . substring ( start , end ) ; int jar_stop ; if ( ( jar_stop = url_string . indexOf ( " ! / " ) ) < 0 ) throw new URLParseError ( " no ▁ ! / ▁ in ▁ spec " ) ; try { new URL ( url_string . substring ( 0 , jar_stop ) ) ; } catch ( MalformedURLException e ) { throw new URLParseError ( " invalid ▁ inner ▁ URL : ▁ " + e . getMessage ( ) ) ; } if ( ! url . getProtocol ( ) . equals ( " jar " ) ) throw new URLParseError ( " unexpected ▁ protocol ▁ " + url . getProtocol ( ) ) ; setURL ( url , " jar " , url . getHost ( ) , url . getPort ( ) , url_string , null ) ; } private static String flat ( String url_string ) { int jar_stop = url_string . indexOf ( " ! / " ) ; String jar_path = url_string . substring ( jar_stop + 1 , url_string . length ( ) ) ; if ( jar_path . indexOf ( " / . " ) < 0 ) return url_string ; ArrayList < String > tokens = new ArrayList < String > ( ) ; StringTokenizer st = new StringTokenizer ( jar_path , " / " ) ; while ( st . hasMore@@ Tokens ( ) ) { String token = st . nextToken ( ) ; if ( token . equals ( " . " ) ) continue ; else if ( token . equals ( " . . " ) ) { if ( ! tokens . isEmpty ( ) ) tokens . remove ( tokens . size ( ) - 1 ) ; } else tokens . add ( token ) ; } CPStringBuilder path = new CPStringBuilder ( url_string . length ( ) ) ; path . append ( url_string . substring ( 0 , jar_stop + 1 ) ) ; Iterator < String > it = tokens . iterator ( ) ; while ( it . hasNext ( ) ) path . append ( ' / ' ) . append ( it . next ( ) ) ; return path . toString ( ) ; } protected String toExternalForm ( URL url ) { String file = url . getFile ( ) ; String ref = url . getRef ( ) ; CPStringBuilder sb = new CPStringBuilder ( file . length ( ) + 5 ) ; sb . append ( " jar : " ) ; sb . append ( file ) ; if ( ref != null ) sb . append ( ' # ' ) . append ( ref ) ; return sb . toString ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="ili@@ at/gatk-@@ tools-java/tree/master/src/main/java/@@ com/google@@ /cloud/genom@@ ics/gat@@ k/common/GenomicsConverter@@ Base.java"> package com . google . cloud . genomics . gatk . common ; import htsjdk . samtools . SAMFileHeader ; import htsjdk . samtools . SAMRecord ; import java . util . List ; public abstract class GenomicsConverterBase < Read , ReadGroupSet , Reference > implements GenomicsConverter < Read , ReadGroupSet , Reference > { @ Override public SAMRecord makeSAMRecord ( Read read , ReadGroupSet readGroupSet , List < Reference > references , boolean forceSetMatePositionToThisPosition ) { return makeSAMRecord ( read , makeSAMFileHeader ( readGroupSet , references ) ) ; } @ Override public SAMRecord makeSAMRecord ( Read read , boolean forceSetMatePositionToThisPosition ) { return makeSAMRecord ( read , new SAMFileHeader ( ) ) ; } @ Override public abstract SAMFileHeader makeSAMFileHeader ( ReadGroupSet readGroupSet , List < Reference > references ) ; @ Override public abstract SAMRecord makeSAMRecord ( Read read , SAMFileHeader header ) ; } </DOCUMENT>
<DOCUMENT_ID="skyHAL@@ ud/cod@@ enameone/tree/master/Port@@ s/iOS@@ Port/xml@@ vm/apache-@@ harmony-@@ 6.0-src-@@ r991881/classlib/@@ modules/luni@@ /src/test/api/@@ common/org/apache/harmon@@ y/luni@@ /tests/java/lang@@ /ThreadTest.java"> package org . apache . harmony . luni . tests . java . lang ; import java . lang . Thread . UncaughtExceptionHandler ; import java . security . Permission ; import java . util . Map ; public class ThreadTest extends junit . framework . TestCase { static class SimpleThread implements Runnable { int delay ; public void run ( ) { try { synchronized ( this ) { this . notify ( ) ; this . wait ( delay ) ; } } catch ( InterruptedException e ) { return ; } } public SimpleThread ( int d ) { if ( d >= 0 ) delay = d ; } } static class YieldThread implements Runnable { volatile int delay ; public void run ( ) { int x = 0 ; while ( true ) { ++ x ; } } public YieldThread ( int d ) { if ( d >= 0 ) delay = d ; } } static class ResSupThread implements Runnable { Thread parent ; volatile int checkVal = - 1 ; public void run ( ) { try { synchronized ( this ) { this . notify ( ) ; } while ( true ) { checkVal ++ ; zz ( ) ; Thread . sleep ( 100 ) ; } } catch ( InterruptedException e ) { return ; } catch ( BogusException e ) { try { Thread . sleep ( 500 ) ; } catch ( InterruptedException x ) { } parent . interrupt ( ) ; while ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { try { Thread . sleep ( 50 ) ; } catch ( InterruptedException x ) { break ; } } } } public void zz ( ) throws BogusException { } public ResSupThread ( Thread t ) { parent = t ; } public synchronized int getCheckVal ( ) { return checkVal ; } } static class BogusException extends Throwable { private static final long serialVersionUID = 1L ; public BogusException ( String s ) { super ( s ) ; } } Thread st , ct , spinner ; static boolean calledMySecurityManager = false ; public void test_Constructor ( ) { Thread t ; SecurityManager m = new SecurityManager ( ) { @ Override public ThreadGroup getThreadGroup ( ) { calledMySecurityManager = true ; return Thread . currentThread ( ) . getThreadGroup ( ) ; } @ Override public void checkPermission ( Permission permission ) { if ( permission . getName ( ) . equals ( " setSecurityManager " ) ) { return ; } super . checkPermission ( permission ) ; } } ; try { System . setSecurityManager ( m ) ; t = new Thread ( ) ; } finally { System . setSecurityManager ( null ) ; } assertTrue ( " Did ▁ not ▁ call ▁ SecurityManager . getThreadGroup ▁ ( ) " , calledMySecurityManager ) ; t . start ( ) ; } public void test_ConstructorLjava_lang_Runnable ( ) { ct = new Thread ( new SimpleThread ( 10 ) ) ; ct . start ( ) ; } public void test_ConstructorLjava_lang_RunnableLjava_lang_String ( ) { Thread st1 = new Thread ( new SimpleThread ( 1 ) , " SimpleThread1" ) ; assertEquals ( " Constructed ▁ thread ▁ with ▁ incorrect ▁ thread ▁ name " , " SimpleThread1" , st1 . getName ( ) ) ; st1 . start ( ) ; } public void test_ConstructorLjava_lang_String ( ) { Thread t = new Thread ( " Testing " ) ; assertEquals ( " Created ▁ tread ▁ with ▁ incorrect ▁ name " , " Testing " , t . getName ( ) ) ; t . start ( ) ; } public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_Runnable ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group1" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread2" ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ group " , st . getThreadGroup ( ) == tg ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; } public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_RunnableLjava_lang_String ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group2" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread3" ) ; assertTrue ( " Constructed ▁ incorrect ▁ thread " , ( st . getThreadGroup ( ) == tg ) && st . getName ( ) . equals ( " SimpleThread3" ) ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; Runnable r = new Runnable ( ) { public void run ( ) { } } ; ThreadGroup foo = null ; try { new Thread ( foo = new ThreadGroup ( " foo " ) , r , null ) ; fail ( " Null ▁ cannot ▁ be ▁ accepted ▁ as ▁ Thread ▁ name " ) ; } catch ( NullPointerException npe ) { assertTrue ( " Null ▁ cannot ▁ be ▁ accepted ▁ as ▁ Thread ▁ name " , true ) ; foo . destroy ( ) ; } } public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_String ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread4" ) ; assertEquals ( " Returned ▁ incorrect ▁ thread ▁ name " , " SimpleThread4" , st . getName ( ) ) ; st . start ( ) ; } public void test_activeCount ( ) { Thread t = new Thread ( new SimpleThread ( 10 ) ) ; int active = 0 ; synchronized ( t ) { t . start ( ) ; active = Thread . activeCount ( ) ; } assertTrue ( " Incorrect ▁ activeCount ▁ for ▁ current ▁ group : ▁ " + active , active > 1 ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { } } public void test_checkAccess ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group3" ) ; try { st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread5" ) ; st . checkAccess ( ) ; assertTrue ( " CheckAccess ▁ passed " , true ) ; } catch ( SecurityException e ) { fail ( " CheckAccess ▁ failed ▁ : ▁ " + e . getMessage ( ) ) ; } st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; } @ SuppressWarnings ( " deprecation " ) public void test_countStackFrames ( ) { Thread . currentThread ( ) . countStackFrames ( ) ; } public void test_currentThread ( ) { assertNotNull ( Thread . currentThread ( ) ) ; } @ SuppressWarnings ( " deprecation " ) public void test_destroy ( ) { try { new Thread ( ) . destroy ( ) ; } catch ( NoSu@@ chMethodError e ) { } } public void test_enumer@@ ate$Ljava_lang_Thread ( ) { class MyThread extends Thread { MyThread ( ThreadGroup tg , String name ) { super ( tg , name ) ; } boolean failed = false ; String failMessage = null ; public void run ( ) { SimpleThread st1 = null ; SimpleThread st2 = null ; ThreadGroup mytg = null ; Thread firstOne = null ; Thread secondOne = null ; try { int arrayLength = 10 ; Thread [ ] tarray = new Thread [ arrayLength ] ; st1 = new SimpleThread ( - 1 ) ; st2 = new SimpleThread ( - 1 ) ; mytg = new ThreadGroup ( " jp " ) ; firstOne = new Thread ( mytg , st1 , " firstOne2" ) ; secondOne = new Thread ( mytg , st2 , " secondOne1" ) ; int count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned1" , 1 , count ) ; synchronized ( st1 ) { firstOne . start ( ) ; try { st1 . wait ( ) ; } catch ( InterruptedException e ) { } } count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned2" , 2 , count ) ; synchronized ( st2 ) { secondOne . start ( ) ; try { st2 . wait ( ) ; } catch ( InterruptedException e ) { } } count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned3" , 3 , count ) ; } catch ( junit . framework . Assertion@@ FailedError e ) { failed = true ; failMessage = e . getMessage ( ) ; } finally { synchronized ( st1 ) { firstOne . interrupt ( ) ; } synchronized ( st2 ) { secondOne . interrupt ( ) ; } try { firstOne . join ( ) ; secondOne . join ( ) ; } catch ( InterruptedException e ) { } mytg . destroy ( ) ; } } } ; ThreadGroup tg = new ThreadGroup ( " tg " ) ; MyThread t = new MyThread ( tg , " top " ) ; t . start ( ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt " ) ; } finally { tg . destroy ( ) ; } assertFalse ( t . failMessage , t . failed ) ; } public void test_getContextClassLoader ( ) { Thread t = new Thread ( ) ; assertTrue ( " Incorrect ▁ class ▁ loader ▁ returned " , t . getContextClassLoader ( ) == Thread . currentThread ( ) . getContextClassLoader ( ) ) ; t . start ( ) ; } public void test_getName ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread6" ) ; assertEquals ( " Returned ▁ incorrect ▁ thread ▁ name " , " SimpleThread6" , st . getName ( ) ) ; st . start ( ) ; } public void test_getPriority ( ) { st = new Thread ( new SimpleThread ( 1 ) ) ; st . setPriority ( Thread . MAX_PRIORITY ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ priority " , st . getPriority ( ) == Thread . MAX_PRIORITY ) ; st . start ( ) ; } public void test_getThreadGroup ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group4" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread8" ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ group " , st . getThreadGroup ( ) == tg ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } assertNull ( " group ▁ should ▁ be ▁ null " , st . getThreadGroup ( ) ) ; assertNotNull ( " toString ( ) ▁ should ▁ not ▁ be ▁ null " , st . toString ( ) ) ; tg . destroy ( ) ; final Object lock = new Object ( ) ; Thread t = new Thread ( ) { @ Override public void run ( ) { synchronized ( lock ) { lock . notifyAll ( ) ; } } } ; synchronized ( lock ) { t . start ( ) ; try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } int running = 0 ; while ( t . isAlive ( ) ) running ++ ; ThreadGroup group = t . getThreadGroup ( ) ; assertNull ( " ThreadGroup ▁ is ▁ not ▁ null " , group ) ; } public void test_interrupt ( ) { final Object lock = new Object ( ) ; class ChildThread1 extends Thread { Thread parent ; boolean sync ; @ Override public void run ( ) { if ( sync ) { synchronized ( lock ) { lock . notify ( ) ; try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } } parent . interrupt ( ) ; } public ChildThread1 ( Thread p , String name , boolean sync ) { super ( name ) ; parent = p ; this . sync = sync ; } } boolean interrupted = false ; try { ct = new ChildThread1 ( Thread . currentThread ( ) , " Interrupt ▁ Test1" , false ) ; synchronized ( lock ) { ct . start ( ) ; lock . wait ( ) ; } } catch ( InterruptedException e ) { interrupted = true ; } assertTrue ( " Failed ▁ to ▁ Interrupt ▁ thread1" , interrupted ) ; interrupted = false ; try { ct = new ChildThread1 ( Thread . currentThread ( ) , " Interrupt ▁ Test2" , true ) ; synchronized ( lock ) { ct . start ( ) ; lock . wait ( ) ; lock . notify ( ) ; } Thread . sleep ( 20000 ) ; } catch ( InterruptedException e ) { interrupted = true ; } assertTrue ( " Failed ▁ to ▁ Interrupt ▁ thread2" , interrupted ) ; } public void test_interrupted ( ) { assertFalse ( " Interrupted ▁ returned ▁ true ▁ for ▁ non - interrupted ▁ thread " , Thread . interrupted ( ) ) ; Thread . currentThread ( ) . interrupt ( ) ; assertTrue ( " Interrupted ▁ returned ▁ true ▁ for ▁ non - interrupted ▁ thread " , Thread . interrupted ( ) ) ; assertFalse ( " Failed ▁ to ▁ clear ▁ interrupted ▁ flag " , Thread . interrupted ( ) ) ; } public void test_isAlive ( ) { SimpleThread simple ; st = new Thread ( simple = new SimpleThread ( 500 ) ) ; assertFalse ( " A ▁ thread ▁ that ▁ wasn ' t ▁ started ▁ is ▁ alive . " , st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; try { simple . wait ( ) ; } catch ( InterruptedException e ) { } } assertTrue ( " Started ▁ thread ▁ returned ▁ false " , st . isAlive ( ) ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { fail ( " Thread ▁ did ▁ not ▁ die " ) ; } assertTrue ( " Stopped ▁ thread ▁ returned ▁ true " , ! st . isAlive ( ) ) ; } public void test_isDaemon ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread10" ) ; assertTrue ( " Non - Daemon ▁ thread ▁ returned ▁ true " , ! st . isDaemon ( ) ) ; st . setDaemon ( true ) ; assertTrue ( " Daemon ▁ thread ▁ returned ▁ false " , st . isDaemon ( ) ) ; st . start ( ) ; } public void test_isInterrupted ( ) { class SpinThread implements Runnable { public volatile boolean done = false ; public void run ( ) { while ( ! Thread . currentThread ( ) . isInterrupted ( ) ) ; while ( ! done ) ; } } SpinThread spin = new SpinThread ( ) ; spinner = new Thread ( spin ) ; spinner . start ( ) ; Thread . yield ( ) ; try { assertTrue ( " Non - Interrupted ▁ thread ▁ returned ▁ true " , ! spinner . isInterrupted ( ) ) ; spinner . interrupt ( ) ; assertTrue ( " Interrupted ▁ thread ▁ returned ▁ false " , spinner . isInterrupted ( ) ) ; spin . done = true ; } finally { spinner . interrupt ( ) ; spin . done = true ; } } public void test_join ( ) { SimpleThread simple ; try { st = new Thread ( simple = new SimpleThread ( 100 ) ) ; assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ " ) ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! st . isAlive ( ) ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { th . join ( ) ; } catch ( InterruptedException e ) { result = false ; } assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; } public void test_joinJ ( ) { SimpleThread simple ; try { st = new Thread ( simple = new SimpleThread ( 1000 ) , " SimpleThread12" ) ; assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( 10 ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ " ) ; } assertTrue ( " Join ▁ failed ▁ to ▁ timeout " , st . isAlive ( ) ) ; st . interrupt ( ) ; try { st = new Thread ( simple = new SimpleThread ( 100 ) , " SimpleThread13" ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( 1000 ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ : ▁ " + e . getMessage ( ) ) ; return ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! st . isAlive ( ) ) ; final Object lock = new Object ( ) ; final Thread main = Thread . currentThread ( ) ; Thread killer = new Thread ( new Runnable ( ) { public void run ( ) { try { synchronized ( lock ) { lock . notify ( ) ; } Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { return ; } main . interrupt ( ) ; } } ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { synchronized ( lock ) { killer . start ( ) ; lock . wait ( ) ; } th . join ( 200 ) ; } catch ( InterruptedException e ) { result = false ; } killer . interrupt ( ) ; assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; } public void test_joinJI ( ) throws Exception { SimpleThread simple ; st = new Thread ( simple = new SimpleThread ( 1000 ) , " Squawk1" ) ; assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } long firstRead = System . currentTimeMillis ( ) ; st . join ( 100 , 999999 ) ; long secondRead = System . currentTimeMillis ( ) ; assertTrue ( " Did ▁ not ▁ join ▁ by ▁ appropriate ▁ time : ▁ " + secondRead + " - " + firstRead + " = " + ( secondRead - firstRead ) , secondRead - firstRead <= 300 ) ; assertTrue ( " Joined ▁ thread ▁ is ▁ not ▁ alive " , st . isAlive ( ) ) ; st . interrupt ( ) ; final Object lock = new Object ( ) ; final Thread main = Thread . currentThread ( ) ; Thread killer = new Thread ( new Runnable ( ) { public void run ( ) { try { synchronized ( lock ) { lock . notify ( ) ; } Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { return ; } main . interrupt ( ) ; } } ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { synchronized ( lock ) { killer . start ( ) ; lock . wait ( ) ; } th . join ( 200 , 20 ) ; } catch ( InterruptedException e ) { result = false ; } killer . interrupt ( ) ; assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; } @ SuppressWarnings ( " deprecation " ) public void test_resume ( ) { int orgval ; ResSupThread t ; try { t = new ResSupThread ( Thread . currentThread ( ) ) ; synchronized ( t ) { ct = new Thread ( t , " Interrupt ▁ Test2" ) ; ct . start ( ) ; t . wait ( ) ; } ct . suspend ( ) ; Thread . sleep ( 500 ) ; orgval = t . getCheckVal ( ) ; Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ suspend ▁ thread " , orgval == t . getCheckVal ( ) ) ; ct . resume ( ) ; Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ resume ▁ thread " , orgval != t . getCheckVal ( ) ) ; ct . interrupt ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ occurred ▁ : ▁ " + e . getMessage ( ) ) ; } } public void test_run ( ) { class RunThread implements Runnable { boolean didThreadRun = false ; public void run ( ) { didThreadRun = true ; } } RunThread rt = new RunThread ( ) ; Thread t = new Thread ( rt ) ; try { t . start ( ) ; int count = 0 ; while ( ! rt . didThreadRun && count < 20 ) { Thread . sleep ( 100 ) ; count ++ ; } assertTrue ( " Thread ▁ did ▁ not ▁ run " , rt . didThreadRun ) ; t . join ( ) ; } catch ( InterruptedException e ) { assertTrue ( " Joined ▁ thread ▁ was ▁ interrupted " , true ) ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! t . isAlive ( ) ) ; } public void test_setDaemon@@ Z ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread14" ) ; st . setDaemon ( true ) ; assertTrue ( " Failed ▁ to ▁ set ▁ thread ▁ as ▁ daemon ▁ thread " , st . isDaemon ( ) ) ; st . start ( ) ; } public void test_setNameLjava_lang_String ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread15" ) ; st . setName ( " Bogus ▁ Name " ) ; assertEquals ( " Failed ▁ to ▁ set ▁ thread ▁ name " , " Bogus ▁ Name " , st . getName ( ) ) ; try { st . setName ( null ) ; fail ( " Null ▁ should ▁ not ▁ be ▁ accepted ▁ as ▁ a ▁ valid ▁ name " ) ; } catch ( NullPointerException e ) { assertTrue ( " Null ▁ should ▁ not ▁ be ▁ accepted ▁ as ▁ a ▁ valid ▁ name " , true ) ; } st . start ( ) ; } public void test_setPriority@@ I ( ) { st = new Thread ( new SimpleThread ( 1 ) ) ; st . setPriority ( Thread . MAX_PRIORITY ) ; assertTrue ( " Failed ▁ to ▁ set ▁ priority " , st . getPriority ( ) == Thread . MAX_PRIORITY ) ; st . start ( ) ; } public void test_sleepJ ( ) { long stime = 0 , ftime = 0 ; try { stime = System . currentTimeMillis ( ) ; Thread . sleep ( 1000 ) ; ftime = System . currentTimeMillis ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ received " ) ; } assertTrue ( " Failed ▁ to ▁ sleep ▁ long ▁ enough " , ( ftime - stime ) >= 800 ) ; } public void test_sleepJI ( ) { long stime = 0 , ftime = 0 ; try { stime = System . currentTimeMillis ( ) ; Thread . sleep ( 1000 , 999999 ) ; ftime = System . currentTimeMillis ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ received " ) ; } long result = ftime - stime ; assertTrue ( " Failed ▁ to ▁ sleep ▁ long ▁ enough : ▁ " + result , result >= 900 && result <= 1100 ) ; } public void test_start ( ) { try { ResSupThread t = new ResSupThread ( Thread . currentThread ( ) ) ; synchronized ( t ) { ct = new Thread ( t , " Interrupt ▁ Test4" ) ; ct . start ( ) ; t . wait ( ) ; } assertTrue ( " Thread ▁ is ▁ not ▁ running1" , ct . isAlive ( ) ) ; int orgval = t . getCheckVal ( ) ; Thread . sleep ( 150 ) ; assertTrue ( " Thread ▁ is ▁ not ▁ running2" , orgval != t . getCheckVal ( ) ) ; ct . interrupt ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ occurred " ) ; } } @ SuppressWarnings ( " deprecation " ) public void test_stop ( ) { try { Runnable r = new ResSupThread ( null ) ; synchronized ( r ) { st = new Thread ( r , " Interupt ▁ Test5" ) ; st . start ( ) ; r . wait ( ) ; } } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ received " ) ; } st . stop ( ) ; try { st . join ( 10000 ) ; } catch ( InterruptedException e1 ) { st . interrupt ( ) ; fail ( " Failed ▁ to ▁ stopThread ▁ before ▁ 10000 ▁ timeout " ) ; } assertTrue ( " Failed ▁ to ▁ stopThread " , ! st . isAlive ( ) ) ; } @ SuppressWarnings ( " deprecation " ) public void test_stop_subtest0 ( ) { Thread t = new Thread ( " t " ) ; class MySecurityManager extends SecurityManager { public boolean intest = false ; @ Override public void checkAccess ( Thread t ) { if ( intest ) { fail ( " checkAccess ▁ called " ) ; } } @ Override public void checkPermission ( Permission permission ) { if ( permission . getName ( ) . equals ( " setSecurityManager " ) ) { return ; } super . checkPermission ( permission ) ; } } MySecurityManager sm = new MySecurityManager ( ) ; System . setSecurityManager ( sm ) ; try { sm . intest = true ; try { t . stop ( ) ; } catch ( SecurityException e ) { } sm . intest = false ; t . start ( ) ; try { t . join ( 2000 ) ; } catch ( InterruptedException e ) { } sm . intest = true ; try { t . stop ( ) ; } catch ( SecurityException e ) { } sm . intest = false ; } finally { System . setSecurityManager ( null ) ; } } @ SuppressWarnings ( " deprecation " ) public void test_stopLjava_lang_Throwable_subtest0 ( ) { Thread t = new Thread ( " t " ) ; class MySecurityManager extends SecurityManager { public boolean intest = false ; public boolean checkAccess = false ; @ Override public void checkAccess ( Thread t ) { if ( intest ) { checkAccess = true ; } } @ Override public void checkPermission ( Permission permission ) { if ( permission . getName ( ) . equals ( " setSecurityManager " ) ) { return ; } super . checkPermission ( permission ) ; } } MySecurityManager sm = new MySecurityManager ( ) ; System . setSecurityManager ( sm ) ; try { sm . intest = true ; try { t . stop ( new ThreadDeath ( ) ) ; } catch ( SecurityException e ) { } sm . intest = false ; assertTrue ( " no ▁ checkAccess ▁ 1" , sm . checkAccess ) ; t . start ( ) ; try { t . join ( 2000 ) ; } catch ( InterruptedException e ) { } sm . intest = true ; sm . checkAccess = false ; try { t . stop ( new ThreadDeath ( ) ) ; } catch ( SecurityException e ) { } assertTrue ( " no ▁ checkAccess ▁ 2" , sm . checkAccess ) ; sm . intest = false ; } finally { System . setSecurityManager ( null ) ; } } @ SuppressWarnings ( " deprecation " ) public void test_stopLjava_lang_Throwable ( ) { ResSupThread t = new ResSupThread ( Thread . currentThread ( ) ) ; synchronized ( t ) { st = new Thread ( t , " StopThread " ) ; st . setPriority ( Thread . MAX_PRIORITY ) ; st . start ( ) ; try { t . wait ( ) ; } catch ( InterruptedException e ) { } } try { st . stop ( new BogusException ( " Bogus " ) ) ; Thread . sleep ( 20000 ) ; } catch ( InterruptedException e ) { assertTrue ( " Stopped ▁ child ▁ with ▁ exception ▁ not ▁ alive " , st . isAlive ( ) ) ; st . interrupt ( ) ; return ; } st . interrupt ( ) ; fail ( " Stopped ▁ child ▁ did ▁ not ▁ throw ▁ exception " ) ; } @ SuppressWarnings ( " deprecation " ) public void test_suspend ( ) { int orgval ; ResSupThread t = new ResSupThread ( Thread . currentThread ( ) ) ; try { synchronized ( t ) { ct = new Thread ( t , " Interupt ▁ Test6" ) ; ct . start ( ) ; t . wait ( ) ; } ct . suspend ( ) ; Thread . sleep ( 500 ) ; orgval = t . getCheckVal ( ) ; Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ suspend ▁ thread " , orgval == t . getCheckVal ( ) ) ; ct . resume ( ) ; Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ resume ▁ thread " , orgval != t . getCheckVal ( ) ) ; ct . interrupt ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ occurred " ) ; } final Object notify = new Object ( ) ; Thread t1 = new Thread ( new Runnable ( ) { public void run ( ) { synchronized ( notify ) { notify . notify ( ) ; } Thread . currentThread ( ) . suspend ( ) ; } } ) ; try { synchronized ( notify ) { t1 . start ( ) ; notify . wait ( ) ; } Thread . sleep ( 500 ) ; assertTrue ( " Thread ▁ should ▁ be ▁ alive " , t1 . isAlive ( ) ) ; t1 . resume ( ) ; t1 . join ( ) ; } catch ( InterruptedException e ) { } } public void test_toString ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group5" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread17" ) ; final String stString = st . toString ( ) ; final String expected = " Thread [ SimpleThread17,5 , Test ▁ Group5 ] " ; assertTrue ( " Returned ▁ incorrect ▁ string : ▁ " + stString + " \t ( expecting ▁ : " + expected + " ) " , stString . equals ( expected ) ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; } public void test_getAllStackTraces ( ) { Map < Thread , StackTraceElement [ ] > stMap = Thread . getAllStackTraces ( ) ; assertNotNull ( stMap ) ; } public void test_get_setDefaultUncaughtExceptionHandler ( ) { class Handler implements UncaughtExceptionHandler { public void uncaughtException ( Thread thread , Throwable ex ) { } } final Handler handler = new Handler ( ) ; Thread . setDefaultUncaughtExceptionHandler ( handler ) ; assertSame ( handler , Thread . getDefaultUncaughtExceptionHandler ( ) ) ; Thread . setDefaultUncaughtExceptionHandler ( null ) ; assertNull ( Thread . getDefaultUncaughtExceptionHandler ( ) ) ; } public void test_getStackTrace ( ) { StackTraceElement [ ] stackTrace = Thread . currentThread ( ) . getStackTrace ( ) ; assertNotNull ( stackTrace ) ; stack_trace_loop : { for ( int i = 0 ; i < stackTrace . length ; i ++ ) { StackTraceElement e = stackTrace [ i ] ; if ( getClass ( ) . getName ( ) . equals ( e . getClassName ( ) ) ) { if ( " test _ getStackTrace " . equals ( e . getMethodName ( ) ) ) { break stack_trace_loop ; } } } fail ( " class ▁ and ▁ method ▁ not ▁ found ▁ in ▁ stack ▁ trace " ) ; } } public void test_getState ( ) { Thread . State state = Thread . currentThread ( ) . getState ( ) ; assertNotNull ( state ) ; assertEquals ( Thread . State . RUNNABLE , state ) ; } public void test_get_setUncaughtExceptionHandler ( ) { class Handler implements UncaughtExceptionHandler { public void uncaughtException ( Thread thread , Throwable ex ) { } } final Handler handler = new Handler ( ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( handler ) ; assertSame ( handler , Thread . currentThread ( ) . getUncaughtExceptionHandler ( ) ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( null ) ; } public void test_getId ( ) { assertTrue ( " current ▁ thread ' s ▁ ID ▁ is ▁ not ▁ positive " , Thread . currentThread ( ) . getId ( ) > 0 ) ; Map < Thread , StackTraceElement [ ] > stMap = Thread . getAllStackTraces ( ) ; for ( Thread thread : stMap . keySet ( ) ) { assertTrue ( " thread ' s ▁ ID ▁ is ▁ not ▁ positive : ▁ " + thread . getName ( ) , thread . getId ( ) > 0 ) ; } } @ Override protected void tearDown ( ) { try { if ( st != null ) st . interrupt ( ) ; } catch ( Exception e ) { } try { if ( spinner != null ) spinner . interrupt ( ) ; } catch ( Exception e ) { } try { if ( ct != null ) ct . interrupt ( ) ; } catch ( Exception e ) { } try { spinner = null ; st = null ; ct = null ; System . runFinalization ( ) ; } catch ( Exception e ) { } } } </DOCUMENT>
<DOCUMENT_ID="mstine@@ /polyglot-os@@ gi/tree/master/lib/osgi/@@ felix/org.apache.@@ felix.framework@@ -1.8.1/src/main/java/@@ org/apache/felix/@@ framework/util/@@ JarFileX.java"> package org . apache . felix . framework . util ; import java . io . File ; import java . io . IOException ; import java . util . jar . JarEntry ; import java . util . jar . JarFile ; import java . util . zip . ZipEntry ; public class JarFileX extends JarFile { public JarFileX ( File file ) throws IOException { super ( file ) ; } public JarFileX ( File file , boolean verify ) throws IOException { super ( file , verify ) ; } public JarFileX ( File file , boolean verify , int mode ) throws IOException { super ( file , verify , mode ) ; } public JarFileX ( String name ) throws IOException { super ( name ) ; } public JarFileX ( String name , boolean verify ) throws IOException { super ( name , verify ) ; } public ZipEntry getEntry ( String name ) { ZipEntry entry = super . getEntry ( name ) ; if ( ( entry != null ) && ( entry . getSize ( ) == 0 ) && ! entry . isDirectory ( ) ) { ZipEntry dirEntry = super . getEntry ( name + ' / ' ) ; if ( dirEntry != null ) { entry = dirEntry ; } } return entry ; } public JarEntry getJarEntry ( String name ) { JarEntry entry = super . getJarEntry ( name ) ; if ( ( entry != null ) && ( entry . getSize ( ) == 0 ) && ! entry . isDirectory ( ) ) { JarEntry dirEntry = super . getJarEntry ( name + ' / ' ) ; if ( dirEntry != null ) { entry = dirEntry ; } } return entry ; } } </DOCUMENT>
<DOCUMENT_ID="moos@@ busch/xbLID@@ O/tree/master/src/net/opengis/g@@ ml/GridCoverageDocument@@ .java"> package net . opengis . gml ; public interface GridCoverageDocument extends net . opengis . gml . DiscreteCover@@ ageDocument { public static final org . apache . xmlbeans . SchemaType type = ( org . apache . xmlbeans . SchemaType ) org . apache . xmlbeans . XmlBeans . typeSystem@@ ForClassLoader ( GridCoverageDocument . class . getClassLoader ( ) , " schemaorg _ apache _ xmlbeans . system . s6E28D279B6@@ C224D74@@ 769DB8B98@@ AF1665@@ " ) . resolveHandle ( " gridcover@@ agea6@@ fddoctype " ) ; net . opengis . gml . GridCoverageType getGridCoverage ( ) ; void setGridCoverage ( net . opengis . gml . GridCoverageType gridCoverage ) ; net . opengis . gml . GridCoverageType addNewGridCoverage ( ) ; public static final class Factory { public static net . opengis . gml . GridCoverageDocument newInstance ( ) { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . newInstance ( type , null ) ; } public static net . opengis . gml . GridCoverageDocument newInstance ( org . apache . xmlbeans . XmlOptions options ) { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . newInstance ( type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . lang . String xmlAsString ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( xmlAsString , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . lang . String xmlAsString , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( xmlAsString , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . File file ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( file , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . File file , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( file , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . net . URL u ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( u , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . net . URL u , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( u , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . InputStream is ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( is , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . InputStream is , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( is , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . Reader r ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( r , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . Reader r , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( r , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( javax . xml . stream . XMLStreamReader sr ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( sr , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( javax . xml . stream . XMLStreamReader sr , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( sr , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( org . w3c . dom . Node node ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( node , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( org . w3c . dom . Node node , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( node , type , options ) ; } @ Deprecated public static net . opengis . gml . GridCoverageDocument parse ( org . apache . xmlbeans . xml . stream . XMLInputStream xis ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( xis , type , null ) ; } @ Deprecated public static net . opengis . gml . GridCoverageDocument parse ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( xis , type , options ) ; } @ Deprecated public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , null ) ; } @ Deprecated public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , options ) ; } private Factory ( ) { } } } </DOCUMENT>
<DOCUMENT_ID="inner@@ verse/libj@@ itsi/tree/master/src/org/jit@@ si/util/xml/DOMElement@@ Writer.java"> package org . jitsi . util . xml ; import java . io . * ; import org . w3c . dom . * ; public class DOMElementWriter { private static final String lSep = System . getProperty ( " line . separator " ) ; public static String decodeName ( String name ) { int length = name . length ( ) ; StringBuilder value = new StringBuilder ( length ) ; for ( int i = 0 ; i < length ; ) { int start = name . indexOf ( ' _ ' , i ) ; if ( start == - 1 ) { value . append ( name , i , length ) ; break ; } if ( i != start ) value . append ( name , i , start ) ; int end = start + 6 ; if ( ( end < length ) && ( name . charAt ( start + 1 ) == ' x ' ) && ( name . charAt ( end ) == ' _ ' ) && isHexDigit ( name . charAt ( start + 2 ) ) && isHexDigit ( name . charAt ( start + 3 ) ) && isHexDigit ( name . charAt ( start + 4 ) ) && isHexDigit ( name . charAt ( start + 5 ) ) ) { char c = ( char ) Integer . parseInt ( name . substring ( start + 2 , end ) , 16 ) ; if ( ( start == 0 ) ? ! isNameStartChar ( c ) : ! isNameChar ( c ) ) { value . append ( c ) ; i = end + 1 ; continue ; } } value . append ( name . charAt ( start ) ) ; i = start + 1 ; } return value . toString ( ) ; } public static String encodeName ( String value ) { int length = value . length ( ) ; StringBuilder name = new StringBuilder ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char c = value . charAt ( i ) ; if ( i == 0 ) { if ( isNameStartChar ( c ) ) { name . append ( c ) ; continue ; } } else if ( isNameChar ( c ) ) { name . append ( c ) ; continue ; } name . append ( " _ x " ) ; if ( c <= 0x000F ) name . append ( "000" ) ; else if ( c <= 0x00FF ) name . append ( "00" ) ; else if ( c <= 0x0FFF ) name . append ( '0' ) ; name . append ( Integer . toHexString ( c ) . toUpperCase ( ) ) ; name . append ( ' _ ' ) ; } return name . toString ( ) ; } private static boolean isHexDigit ( char c ) { return ( ( '0' <= c ) && ( c <= '9' ) ) || ( ( ' A ' <= c ) && ( c <= ' F ' ) ) || ( ( ' a ' <= c ) && ( c <= ' f ' ) ) ; } private static boolean isNameChar ( char c ) { if ( isNameStartChar ( c ) ) return true ; else if ( ( c == ' - ' ) || ( c == ' . ' ) ) return true ; else if ( ( '0' <= c ) && ( c <= '9' ) ) return true ; else if ( c == 0xB7 ) return true ; else if ( c < 0x0300 ) return false ; else if ( c <= 0x036F ) return true ; else if ( c < 0x203F ) return false ; else if ( c <= 0x2040 ) return true ; else return false ; } private static boolean isNameStartChar ( char c ) { if ( ( c == ' : ' ) || ( c == ' _ ' ) ) return true ; else if ( ( ' A ' <= c ) && ( c <= ' Z ' ) ) return true ; else if ( ( ' a ' <= c ) && ( c <= ' z ' ) ) return true ; else if ( c < 0xC0 ) return false ; else if ( c <= 0xD6 ) return true ; else if ( c < 0xD8 ) return false ; else if ( c <= 0xF6 ) return true ; else if ( c < 0xF8 ) return false ; else if ( c <= 0x2FF ) return true ; else if ( c < 0x370 ) return false ; else if ( c <= 0x37D ) return true ; else if ( c < 0x37F ) return false ; else if ( c <= 0x1FFF ) return true ; else if ( c < 0x200C ) return false ; else if ( c <= 0x200D ) return true ; else if ( c < 0x2070 ) return false ; else if ( c <= 0x218F ) return true ; else if ( c < 0x2C00 ) return false ; else if ( c <= 0x2FE@@ F ) return true ; else if ( c < 0x3001 ) return false ; else if ( c <= 0xD7FF ) return true ; else if ( c < 0xF900 ) return false ; else if ( c <= 0xFDCF ) return true ; else if ( c < 0xFDF0 ) return false ; else if ( c <= 0xFFFD ) return true ; else return false ; } protected String [ ] knownEntities = { " gt " , " amp " , " lt " , " apos " , " quot " } ; public void write ( Element root , OutputStream out ) throws IOException { Writer wri = new OutputStream@@ Writer ( out , " UTF - 8" ) ; wri . write ( " < ? xml ▁ version = \ " 1.0\ " ▁ encoding = \ " UTF - 8\ " ? > " + lSep ) ; write ( root , wri , 0 , " ▁ ▁ " ) ; wri . flush ( ) ; } public void write ( Node element , Writer out , int indent , String indentWith ) throws IOException { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } if ( element . getNodeType ( ) == Node . COMMENT_NODE ) { out . write ( " < ! - - " ) ; out . write ( encode ( element . getNodeValue ( ) ) ) ; out . write ( " - - > " ) ; } else { out . write ( " < " ) ; out . write ( ( ( Element ) element ) . getTagName ( ) ) ; NamedNode@@ Map attrs = element . getAttributes ( ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; out . write ( " ▁ " ) ; out . write ( attr . getName ( ) ) ; out . write ( " = \ " " ) ; out . write ( encode ( attr . getValue ( ) ) ) ; out . write ( " \ " " ) ; } out . write ( " > " ) ; } boolean hasChildren = false ; NodeList children = element . getChildNodes ( ) ; for ( int i = 0 ; element . hasChild@@ Nodes ( ) && i < children . getLength ( ) ; i ++ ) { Node child = children . item ( i ) ; switch ( child . getNodeType ( ) ) { case Node . ELEMENT_NODE : case Node . COMMENT_NODE : if ( ! hasChildren ) { out . write ( lSep ) ; hasChildren = true ; } write ( child , out , indent + 1 , indentWith ) ; break ; case Node . TEXT_NODE : if ( child . getNodeValue ( ) != null && ( child . getNodeValue ( ) . indexOf ( " \n " ) == - 1 || child . getNodeValue ( ) . trim ( ) . length ( ) != 0 ) ) out . write ( encode ( child . getNodeValue ( ) ) ) ; break ; case Node . CDATA_SECTION_NODE : out . write ( " < ! [ CDATA [ " ) ; out . write ( encodedata ( ( ( Text ) child ) . getData ( ) ) ) ; out . write ( " ] ] > " ) ; break ; case Node . ENTITY_@@ REFERENCE_@@ NODE : out . write ( ' & ' ) ; out . write ( child . getNodeName ( ) ) ; out . write ( ' ; ' ) ; break ; case Node . PROCESSING_INSTRUC@@ TION_NODE : out . write ( " < ? " ) ; out . write ( child . getNodeName ( ) ) ; String data = child . getNodeValue ( ) ; if ( data != null && data . length ( ) > 0 ) { out . write ( ' ▁ ' ) ; out . write ( data ) ; } out . write ( " ? > " ) ; break ; } } if ( hasChildren ) { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } } if ( element . getNodeType ( ) == Node . ELEMENT_NODE ) { out . write ( " < / " ) ; out . write ( ( ( Element ) element ) . getTagName ( ) ) ; out . write ( " > " ) ; } out . write ( lSep ) ; out . flush ( ) ; } public String encode ( String value ) { StringBuffer sb = new StringBuffer ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = value . charAt ( i ) ; switch ( c ) { case ' < ' : sb . append ( " & lt ; " ) ; break ; case ' > ' : sb . append ( " & gt ; " ) ; break ; case ' \ ' ' : sb . append ( " & apos ; " ) ; break ; case ' \ " ' : sb . append ( " & quot ; " ) ; break ; case ' & ' : int nextSemi = value . indexOf ( " ; " , i ) ; if ( ( nextSemi < 0 ) || ! isReference ( value . substring ( i , nextSemi + 1 ) ) ) sb . append ( " & amp ; " ) ; else sb . append ( ' & ' ) ; break ; default : if ( isLegalCharacter ( c ) ) sb . append ( c ) ; break ; } } return sb . substring ( 0 ) ; } public String encodedata ( final String value ) { StringBuffer sb = new StringBuffer ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; ++ i ) { char c = value . charAt ( i ) ; if ( isLegalCharacter ( c ) ) { sb . append ( c ) ; } } String result = sb . substring ( 0 ) ; int cdEnd = result . indexOf ( " ] ] > " ) ; while ( cdEnd != - 1 ) { sb . setLength ( cdEnd ) ; sb . append ( " & # x5d ; & # x5d ; & gt ; " ) . append ( result . substring ( cdEnd + 3 ) ) ; result = sb . substring ( 0 ) ; cdEnd = result . indexOf ( " ] ] > " ) ; } return result ; } public boolean isReference ( String ent ) { if ( ! ( ent . charAt ( 0 ) == ' & ' ) || ! ent . endsWith ( " ; " ) ) return false ; if ( ent . charAt ( 1 ) == ' # ' ) { if ( ent . charAt ( 2 ) == ' x ' ) { try { Integer . parseInt ( ent . substring ( 3 , ent . length ( ) - 1 ) , 16 ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } else { try { Integer . parseInt ( ent . substring ( 2 , ent . length ( ) - 1 ) ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } } String name = ent . substring ( 1 , ent . length ( ) - 1 ) ; for ( int i = 0 ; i < knownEntities . length ; i ++ ) { if ( name . equals ( knownEntities [ i ] ) ) { return true ; } } return false ; } public boolean isLegalCharacter ( char c ) { if ( c == 0x9 || c == 0xA || c == 0xD ) { return true ; } else if ( c < 0x20 ) { return false ; } else if ( c <= 0xD7FF ) { return true ; } else if ( c < 0xE000 ) { return false ; } else if ( c <= 0xFFFD ) { return true ; } return false ; } } </DOCUMENT>
