<DOCUMENT_ID="os@@ gcc/r@@ yzom/tree/master/ryzom@@ /tools/leveldesign@@ /georges_dll/form_@@ dialog.cpp"> # include " stdafx . h " # include " georges _ edit . h " # include " georges _ edit _ view . h " # include " georges _ edit _ doc . h " # include " form _ dialog . h " # include " action . h " # include " left _ view . h " # include " nel / misc / path . h " # include " nel / georges / type . h " # include " nel / georges / form _ elm . h " using namespace std ; using namespace NLMIS@@ C ; using namespace NLGEORGES ; CFormDialog :: CFormDialog ( ) : CBaseDialog ( IDR_MAINF@@ RAME ) { View = NULL ; WidgetIndexCount = 0 ; WidgetFocused = 0xffffffff ; } CFormDialog :: ~ CFormDialog ( ) { clear ( ) ; } void CFormDialog :: clear ( ) { unRegisterLastControl ( ) ; for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) delete Widgets [ i ] ; Widgets . clear ( ) ; WidgetFocused = 0xffffffff ; WidgetIndexCount = 0 ; } void CFormDialog :: DoDataExchange ( CDataExchange * pDX ) { CDialog :: DoDataExchange ( pDX ) ; } BEGIN_MESSAGE_MAP ( CFormDialog , CDialog ) ON_WM_SIZE ( ) ON_WM_LBUTTONDOWN ( ) ON_WM_SETFOCUS ( ) ON_WM_@@ KILLFOCUS ( ) END_MESSAGE_MAP ( ) void CFormDialog :: OnSize ( UINT nType , int cx , int cy ) { CBaseDialog :: OnSize ( nType , cx , cy ) ; } BOOL CFormDialog :: OnInitDialog ( ) { CBaseDialog :: OnInitDialog ( ) ; SetDefID ( 0xffffffff ) ; UpdateData ( FALSE ) ; return TRUE ; } void CFormDialog :: OnOK ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateData ( ) ; if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onOk ( ) ; } } } void CFormDialog :: OnCancel ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateData ( ) ; if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onCancel ( ) ; return ; } } CBaseDialog :: OnCancel ( ) ; } CWnd * CFormDialog :: addTypeWidget ( const NLGEORGES :: CType & type , uint elmIndex , const char * title , const char * atomName , const char * typeFilename , RECT & currentPos , CForm & form , IFormWidget :: TTypeSrc typeWidget , const char * filenameExt , uint slot ) { switch ( type . UIType ) { case CType :: FileBrowser : case CType :: Edit : case CType :: EditSpin : { CFormMemCombo * memCombo = new CFormMemCombo ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; string tfn = typeFilename ; string key = GEORGES_EDIT_BASE_REG_KEY " \\ " + strlwr ( typeFilename ) + " ▁ MemCombo " ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title , key . c_str ( ) , type . UIType == CType :: EditSpin , type . UIType == CType :: FileBrowser , filenameExt ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Combo ; } break ; case CType :: NonEditableCombo : { CFormCombo * memCombo = new CFormCombo ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Combo ; } break ; case CType :: BigEdit : { CFormBigEdit * memCombo = new CFormBigEdit ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Edit ; } break ; case CType :: ColorEdit : { CColorEdit * memCombo = new CColorEdit ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Color ; } break ; } return NULL ; } void CFormDialog :: getVirtualDfnFromDocument ( const NLGEORGES :: CFormDfn * _dfn , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; CFormMemCombo * memCombo = new CFormMemCombo ( this , 0xffffffff , structName , IFormWidget :: TypeVirtualDfn , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Dfn : " , GEORGES_EDIT_BASE_REG_KEY " \\Vir@@ tual ▁ Dfn ▁ MemCombo " , false , true , " * . dfn " ) ; memCombo -> getFromDocument ( * doc -> getFormPtr ( ) ) ; if ( _dfn ) { std :: vector < const CFormDfn * > arrayDfn ; arrayDfn . reserve ( _dfn -> countParentDfn ( ) ) ; _dfn -> getParentDfn ( arrayDfn ) ; uint elmIndex = 0 ; for ( uint dfnIndex = 0 ; dfnIndex < arrayDfn . size ( ) ; dfnIndex ++ ) { nlassert ( arrayDfn [ dfnIndex ] ) ; const CFormDfn & dfn = * arrayDfn [ dfnIndex ] ; for ( uint i = 0 ; i < dfn . getNumEntry ( ) ; i ++ ) { const CFormDfn :: CEntry & entry = dfn . getEntry ( i ) ; if ( entry . getType ( ) == UFormDfn :: EntryType && ! entry . getArrayFlag ( ) ) { string title = entry . getName ( ) + " : " ; string atomName = string ( structName ) + " . " + entry . getName ( ) ; addTypeWidget ( * entry . getTypePtr ( ) , elmIndex , title . c_str ( ) , atomName . c_str ( ) , entry . getFilename ( ) . c_str ( ) , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeForm , entry . getFilenameExt ( ) . c_str ( ) , slot ) ; } elmIndex ++ ; } } } registerLastControl ( ) ; } } } void CFormDialog :: getDfnFromDocument ( const NLGEORGES :: CFormDfn & _dfn , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; std :: vector < const CFormDfn * > arrayDfn ; arrayDfn . reserve ( _dfn . countParentDfn ( ) ) ; _dfn . getParentDfn ( arrayDfn ) ; if ( strcmp ( structName , " " ) == 0 ) { CListWidget * listWidget = new CListWidget ( this , 0xffffffff , " " , IFormWidget :: TypeFormParent , slot ) ; Widgets . push_back ( listWidget ) ; listWidget -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Parent ▁ Form : " , GEORGES_EDIT_BASE_REG_KEY " \\Parent ▁ Form ▁ MemCombo " , 1 ) ; listWidget -> addColumn ( " Parent ▁ filename " ) ; listWidget -> getFromDocument ( * doc -> getFormPtr ( ) ) ; } CWnd * pWnd = NULL ; CWnd * pWndIcon = NULL ; CWnd * pWndIconColor = NULL ; CWnd * pWndIconBack = NULL ; CWnd * pWndIconBackColor = NULL ; CWnd * pWndIconOver = NULL ; CWnd * pWndIconOverColor = NULL ; CWnd * pWndIconOver2 = NULL ; CWnd * pWndIconOver2Color = NULL ; uint elmIndex = 0 ; for ( uint dfnIndex = 0 ; dfnIndex < arrayDfn . size ( ) ; dfnIndex ++ ) { nlassert ( arrayDfn [ dfnIndex ] ) ; const CFormDfn & dfn = * arrayDfn [ dfnIndex ] ; for ( uint i = 0 ; i < dfn . getNumEntry ( ) ; i ++ ) { const CFormDfn :: CEntry & entry = dfn . getEntry ( i ) ; if ( entry . getType ( ) == UFormDfn :: EntryType && ! entry . getArrayFlag ( ) ) { string title = entry . getName ( ) + " : " ; string atomName = string ( structName ) + " . " + entry . getName ( ) ; pWnd = addTypeWidget ( * entry . getTypePtr ( ) , elmIndex , title . c_str ( ) , atomName . c_str ( ) , entry . getFilename ( ) . c_str ( ) , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeForm , entry . getFilenameExt ( ) . c_str ( ) , slot ) ; if ( entry . getName ( ) == " Icon " || entry . getName ( ) == " icon " ) pWndIcon = pWnd ; else if ( entry . getName ( ) == " IconColor " ) pWndIconColor = pWnd ; else if ( entry . getName ( ) == " IconBack " || entry . getName ( ) == " icon ▁ background " ) pWndIconBack = pWnd ; else if ( entry . getName ( ) == " IconBackColor " ) pWndIconBackColor = pWnd ; else if ( entry . getName ( ) == " IconOver " || entry . getName ( ) == " icon ▁ overlay " ) pWndIconOver = pWnd ; else if ( entry . getName ( ) == " IconOverColor " ) pWndIconOverColor = pWnd ; else if ( entry . getName ( ) == " IconOver2" || entry . getName ( ) == " icon ▁ overlay2" ) pWndIconOver2 = pWnd ; else if ( entry . getName ( ) == " IconOver2Color " ) pWndIconOver2Color = pWnd ; } elmIndex ++ ; } } if ( ( string ( structName ) == " . Client " ) || ( string ( structName ) == " . 3d " ) ) { string title = " Icon ▁ bitmap : " ; CIconWidget * w = new CIconWidget ( this , elmIndex , " " , IFormWidget :: TypeFormParent , slot ) ; Widgets . push_back ( w ) ; w -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title . c_str ( ) ) ; w -> Icon . pWndIcon = pWndIcon ; w -> Icon . pWndIconColor = pWndIconColor ; w -> Icon . pWndIconBack = pWndIconBack ; w -> Icon . pWndIconBackColor = pWndIconBackColor ; w -> Icon . pWndIconOver = pWndIconOver ; w -> Icon . pWndIconOverColor = pWndIconOverColor ; w -> Icon . pWndIconOver2 = pWndIconOver2 ; w -> Icon . pWndIconOver2Color = pWndIconOver2Color ; } registerLastControl ( ) ; } } } void CFormDialog :: getArrayFromDocument ( const char * structName , uint structId , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; CFormMemCombo * memCombo = new CFormMemCombo ( this , structId , structName , IFormWidget :: TypeArray , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Array ▁ size : " , GEORGES_EDIT_BASE_REG_KEY " \\Array ▁ Size ▁ MemCombo " , true , false , NULL ) ; memCombo -> getFromDocument ( * doc -> getFormPtr ( ) ) ; registerLastControl ( ) ; } } } void CFormDialog :: getTypeFromDocument ( const NLGEORGES :: CType & _type , const char * name , const char * typeFilename , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; addTypeWidget ( _type , 0xffffffff , name , structName , typeFilename , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeType , NULL , slot ) ; registerLastControl ( ) ; } } } void CFormDialog :: updateLabels ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateLabel ( ) ; } } void CFormDialog :: updateValues ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateLabel ( ) ; Widgets [ i ] -> getFromDocument ( * ( View -> GetDocument ( ) -> getFormPtr ( ) ) ) ; } } void CFormDialog :: setToDocument ( uint widget ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { CIconWidget * iconWidget = dynamic_cast < CIconWidget * > ( Widgets [ widget ] ) ; if ( iconWidget ) return ; if ( Widgets [ widget ] -> getFormName ( ) != " NULL " ) { const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( Widgets [ widget ] -> getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( Widgets [ widget ] -> getFormName ( ) . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; if ( parentVDfnArray ) { if ( ! theApp . yesNo ( " Warning , ▁ this ▁ action ▁ will ▁ create ▁ an ▁ array / virtual ▁ dfn ▁ over ▁ an ▁ inherited ▁ array / virtual ▁ dfn . \n Do ▁ you ▁ want ▁ to ▁ continue ▁ ? " ) ) return ; } } IFormWidget :: TTypeSrc typeSrc = Widgets [ widget ] -> getSrcType ( ) ; if ( typeSrc == IFormWidget :: TypeForm ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionString ( IAction :: FormValue , result . c_str ( ) , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeFormParent ) { CForm * form = doc -> getFormPtr ( ) ; uint count = Widgets [ widget ] -> getNumValue ( ) ; vector < string > stringVector ( count ) ; for ( uint value = 0 ; value < count ; value ++ ) { Widgets [ widget ] -> getValue ( stringVector [ value ] , value ) ; } doc -> modify ( new CActionStringVector ( IAction :: FormParent@@ s , stringVector , * doc , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeArray ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionBuffer ( IAction :: FormArraySize , NULL , 0 , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , result . c_str ( ) , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeType ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionString ( IAction :: FormType@@ Value , result . c_str ( ) , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeVirtualDfn ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionBuffer ( IAction :: FormVirtual@@ DfnName , NULL , 0 , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , result . c_str ( ) , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } } if ( ! Widgets [ widget ] -> getFormName ( ) . empty ( ) ) doc -> notifyPlugins ( Widgets [ widget ] -> getFormName ( ) . c_str ( ) ) ; } LRESULT CFormDialog :: WindowProc ( UINT message , WPARAM wParam , LPARAM lParam ) { switch ( message ) { case CL_CHANGED : { uint widgetId = getWidget ( wParam ) ; CColorEdit * colorEdit = safe_cast < CColorEdit * > ( Widgets [ widgetId ] ) ; colorEdit -> Empty = false ; setToDocument ( getWidget ( wParam ) ) ; } break ; case MC_STRING@@ CHANGE : { setToDocument ( getWidget ( wParam ) ) ; } break ; case CBN_CHANGED : { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { CIconWidget * iconWidget = dynamic_cast < CIconWidget * > ( Widgets [ i ] ) ; if ( iconWidget ) iconWidget -> Icon . Invalidate ( ) ; } } break ; } return CDialog :: WindowProc ( message , wParam , lParam ) ; } void CFormDialog :: onOpenSelected ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onOpenSelected ( ) ; } } } CWnd * CFormDialog :: GetNextDlg@@ TabItem ( CWnd * pWndCtl , BOOL bPrevious ) const { return NULL ; } void CFormDialog :: onFirstFocus ( ) { View -> SetFocus ( ) ; WidgetFocused = 0xffffffff ; } void CFormDialog :: onLastFocus ( ) { View -> setFocusLeftView ( ) ; WidgetFocused = 0xffffffff ; } int CFormDialog :: getWidget ( uint dialogId ) const { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { if ( Widgets [ i ] -> isDialog ( dialogId ) ) return i ; } return - 1 ; } BOOL CFormDialog :: OnCommand ( WPARAM wParam , LPARAM lParam ) { switch ( HIWORD ( wParam ) ) { case CBN_SETFOCUS : { onGetSubFocus ( LOWORD ( wParam ) ) ; } return TRUE ; case EN_SETFOCUS : { onGetSubFocus ( LOWORD ( wParam ) ) ; } return TRUE ; case CBN_SELCHANGE : { int widgetId = getWidget ( LOWORD ( wParam ) ) ; if ( widgetId != - 1 ) setToDocument ( widgetId ) ; } return TRUE ; case EN_CHANGE : { int widgetId = getWidget ( LOWORD ( wParam ) ) ; if ( widgetId != - 1 ) { CColorEdit * colorEdit = dynamic_cast < CColorEdit * > ( Widgets [ widgetId ] ) ; if ( colorEdit ) { CString str ; colorEdit -> Edit . GetWindowText ( str ) ; sint r , g , b ; if ( sscanf ( str , " % d , % d , % d " , & r , & g , & b ) == 3 ) { clamp ( r , 0 , 255 ) ; clamp ( g , 0 , 255 ) ; clamp ( b , 0 , 255 ) ; CRGBA color ( r , g , b ) ; colorEdit -> Color . setColor ( color ) ; if ( r != 255 && g != 255 && b != 255 ) colorEdit -> Empty = false ; } } } } return TRUE ; case BN_CLICKED : { int widgetId = getWidget ( LOWORD ( wParam ) ) ; if ( widgetId != - 1 ) { if ( ( Widgets [ widgetId ] -> getSrcType ( ) == IFormWidget :: TypeForm ) || ( Widgets [ widgetId ] -> getSrcType ( ) == IFormWidget :: TypeType ) ) { CFormMemCombo * combo = dynamic_cast < CFormMemCombo * > ( Widgets [ widgetId ] ) ; if ( combo && IsWindow ( combo -> Browse ) ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( Widgets [ widgetId ] -> getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( Widgets [ widgetId ] -> getFormName ( ) . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; nlassert ( parentDfn ) ; string ext = parentDfn -> getEntry ( indexDfn ) . getFilenameExt ( ) ; char typeName [ 512 ] ; smprintf ( typeName , 512 , " % s " , strlwr ( ext ) . c_str ( ) ) ; uint i = 0 ; while ( ( typeName [ i ] == ' . ' ) || ( typeName [ i ] == ' * ' ) ) i ++ ; if ( typeName [ i ] ) typeName [ i ] = toupper ( typeName [ i ] ) ; char filter [ 512 ] ; smprintf ( filter , 512 , " % s ▁ Files ▁ ( % s ) | % s | All ▁ Files ( * . * ) | * . * | " , typeName + i , ext . c_str ( ) , ext . c_str ( ) ) ; CFileDialog dlgFile ( TRUE , ext . c_str ( ) , ext . c_str ( ) , OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT , filter , theApp . m_pMainWnd ) ; if ( dlgFile . DoModal ( ) == IDOK ) { combo -> Combo . UpdateData ( ) ; combo -> Combo . SetWindowText ( dlgFile . GetFileName ( ) ) ; combo -> Combo . UpdateData ( FALSE ) ; setToDocument ( widgetId ) ; PostMessage ( CBN_CHANGED , 0 , 0 ) ; } } } else { CColorEdit * colorEdit = dynamic_cast < CColorEdit * > ( Widgets [ widgetId ] ) ; if ( colorEdit && IsWindow ( colorEdit -> Color ) ) { colorEdit -> Empty = true ; colorEdit -> Edit . SetWindowText ( " " ) ; setToDocument ( getWidget ( wParam ) ) ; updateValues ( ) ; } } } else if ( Widgets [ widgetId ] -> getSrcType ( ) == IFormWidget :: TypeVirtualDfn ) { CFormMemCombo * combo = dynamic_cast < CFormMemCombo * > ( Widgets [ widgetId ] ) ; if ( combo && IsWindow ( combo -> Browse ) ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { char filter [ 512 ] ; smprintf ( filter , 512 , " Dfn ▁ Files ▁ ( * . dfn ) | * . dfn | All ▁ Files ( * . * ) | * . * | " ) ; CFileDialog dlgFile ( TRUE , " * . dfn " , " * . dfn " , OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT , filter , theApp . m_pMainWnd ) ; if ( dlgFile . DoModal ( ) == IDOK ) { combo -> Combo . UpdateData ( ) ; combo -> Combo . SetWindowText ( dlgFile . GetFileName ( ) ) ; combo -> Combo . UpdateData ( FALSE ) ; setToDocument ( widgetId ) ; } } } } else if ( Widgets [ widgetId ] -> getSrcType ( ) == IFormWidget :: TypeFormParent ) { setToDocument ( widgetId ) ; } } } return TRUE ; } return CWnd :: OnCommand ( wParam , lParam ) ; } BOOL CFormDialog :: OnNotify ( WPARAM wParam , LPARAM lParam , LRESULT * pResult ) { LPNMHDR pnmh = ( LPNMHDR ) lParam ; int idCtrl = ( int ) wParam ; switch ( pnmh -> code ) { case NM_SETFOCUS : { onGetSubFocus ( idCtrl ) ; } break ; case UDN_DEL@@ TAPOS : { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { if ( Widgets [ i ] -> isDialog ( idCtrl ) ) { Widgets [ i ] -> getFormName ( ) ; LPNMUPDOWN lpnmud = ( LPNMUPDOWN ) lParam ; CFormMemCombo * combo = ( CFormMemCombo * ) Widgets [ i ] ; float value ; CString str ; combo -> Combo . UpdateData ( ) ; combo -> Combo . GetWindowText ( str ) ; if ( sscanf ( str , " % f " , & value ) == 1 ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { const CFormDfn * parentDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; uint lastElement ; bool array ; bool parentVDfnArray ; UFormDfn :: TEntryType type ; nlverify ( ( const CFormElm * ) ( doc -> getRootNode ( Widgets [ i ] -> getSlot ( ) ) ) -> getNodeByName ( Widgets [ i ] -> getFormName ( ) . c_str ( ) , & parentDfn , lastElement , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; float increment = 1 ; if ( nodeType ) sscanf ( nodeType -> Increment . c_str ( ) , " % f " , & increment ) ; value -= ( float ) ( lpnmud -> iDelta ) * increment ; char result [ 512 ] ; sprintf ( result , " % g " , value ) ; combo -> Combo . SetWindowText ( result ) ; combo -> Combo . UpdateData ( FALSE ) ; setToDocument ( i ) ; } } break ; } } } break ; } return CDialog :: OnNotify ( wParam , lParam , pResult ) ; } void CFormDialog :: resizeWidgets ( ) { if ( Widgets . size ( ) ) { RECT viewRect ; View -> GetClientRect ( & viewRect ) ; uint virtualWidth = std :: max ( ( uint ) MinViewWidth , ( uint ) ( viewRect . right - viewRect . left ) ) ; CBaseDialog :: resizeWidgets ( virtualWidth , 0 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; uint bigWidgetCount [ 2 ] = { 0 , 0 } ; uint i ; uint biggestBottom [ 2 ] = { 0 , 0 } ; uint nextSplit = Widgets . size ( ) / 2 ; for ( i = 0 ; i < Widgets . size ( ) ; i ++ ) { uint column = ( i > nextSplit ) ? 1 : 0 ; Widgets [ i ] -> resizeScan ( currentPos , bigWidgetCount [ column ] , 0 , false ) ; if ( currentPos . bottom > ( int ) biggestBottom [ column ] ) { biggestBottom [ column ] = currentPos . bottom ; } if ( nextSplit == i ) { getNextColumn ( currentPos ) ; currentPos . top = 0 ; } } uint adjust [ 2 ] ; CBaseDialog :: resizeWidgets ( virtualWidth , biggestBottom [ 0 ] ) ; adjust [ 0 ] = AdjusteHeight ; CBaseDialog :: resizeWidgets ( virtualWidth , biggestBottom [ 1 ] ) ; adjust [ 1 ] = AdjusteHeight ; currentPos ; getFirstItemPos ( currentPos ) ; uint adjustSum [ 2 ] = { bigWidgetCount [ 0 ] ? adjust [ 0 ] / bigWidgetCount [ 0 ] : 0 , bigWidgetCount [ 1 ] ? adjust [ 1 ] / bigWidgetCount [ 1 ] : 0 } ; biggestBottom [ 0 ] = 0 ; biggestBottom [ 1 ] = 0 ; for ( i = 0 ; i < Widgets . size ( ) - 1 ; i ++ ) { uint column = ( i > nextSplit ) ? 1 : 0 ; if ( Widgets [ i ] -> extendableHeight ( ) ) { Widgets [ i ] -> resizeScan ( currentPos , bigWidgetCount [ column ] , adjustSum [ column ] , true ) ; adjust [ column ] -= adjustSum [ column ] ; } else Widgets [ i ] -> resizeScan ( currentPos , bigWidgetCount [ column ] , 0 , true ) ; if ( currentPos . bottom > ( int ) biggestBottom [ column ] ) { biggestBottom [ column ] = currentPos . bottom ; } if ( nextSplit == i ) { getNextColumn ( currentPos ) ; currentPos . top = 0 ; } } uint column = ( i > nextSplit ) ? 1 : 0 ; Widgets [ i ] -> resizeScan ( currentPos , bigWidgetCount [ column ] , adjust [ column ] , true ) ; if ( currentPos . bottom > ( int ) biggestBottom [ column ] ) { biggestBottom [ column ] = currentPos . bottom ; } View -> setViewSize ( virtualWidth , std :: max ( biggestBottom [ 0 ] , biggestBottom [ 1 ] ) + CGeorgesEditView :: WidgetTop@@ Margin + CGeorgesEditView :: WidgetBotto@@ mMargin ) ; } } void CFormDialog :: getFromDocument ( ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { uint widgetFocus ; for ( widgetFocus = 0 ; widgetFocus < Widgets . size ( ) ; widgetFocus ++ ) { if ( Widgets [ widgetFocus ] -> haveFocus ( ) ) break ; } CGeorgesEditDoc@@ Sub * subObject = doc -> getSelectedObject ( ) ; const CFormDfn * parentDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; uint lastElement ; bool array ; bool parentVDfnArray ; UFormDfn :: TEntryType type ; nlverify ( ( ( const CFormElm * ) ( doc -> getRootNode ( subObject -> getSlot ( ) ) ) ) -> getNodeByName ( subObject -> getFormName ( ) . c_str ( ) , & parentDfn , lastElement , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; if ( parentDfn ) { if ( array ) { nlassert ( ( type == UFormDfn :: EntryDfn ) || ( type == UFormDfn :: EntryType ) ) ; getArrayFromDocument ( subObject -> getFormName ( ) . c_str ( ) , lastElement , subObject -> getSlot ( ) ) ; } else { switch ( parentDfn -> getEntry ( lastElement ) . getType ( ) ) { case UFormDfn :: EntryType : nlassert ( ! array ) ; nlassert ( nodeType ) ; nlassert ( parentDfn ) ; nlassert ( type == UFormDfn :: EntryType ) ; getTypeFromDocument ( * nodeType , ( parentDfn -> getEntry ( lastElement ) . getName ( ) + " : " ) . c_str ( ) , parentDfn -> getEntry ( lastElement ) . getFilename ( ) . c_str ( ) , subObject -> getFormName ( ) . c_str ( ) , subObject -> getSlot ( ) ) ; break ; case UFormDfn :: EntryDfn : nlassert ( ! array ) ; nlassert ( ( nodeDfn ) && ( type == UFormDfn :: EntryDfn ) ) ; getDfnFromDocument ( * nodeDfn , subObject -> getFormName ( ) . c_str ( ) , subObject -> getSlot ( ) ) ; break ; case UFormDfn :: EntryVirtualDfn : nlassert ( ! array ) ; getVirtualDfnFromDocument ( nodeDfn , subObject -> getFormName ( ) . c_str ( ) , subObject -> getSlot ( ) ) ; break ; } } } else { nlassert ( ! array ) ; nlassert ( ( nodeDfn ) && ( type == UFormDfn :: EntryDfn ) ) ; getDfnFromDocument ( * nodeDfn , subObject -> getFormName ( ) . c_str ( ) , subObject -> getSlot ( ) ) ; } for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateLabel ( ) ; } if ( widgetFocus < Widgets . size ( ) ) { Widgets [ widgetFocus ] -> setFocus ( ) ; } resizeWidgets ( ) ; } } void CFormDialog :: getDfnName ( string & result ) const { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { CString str = doc -> GetPathName ( ) ; char extension [ 512 ] ; _splitpath ( str , NULL , NULL , NULL , extension ) ; result = ( * extension == ' . ' ) ? extension + 1 : extension ; } else result = " " ; } void CFormDialog :: OnLButtonDown ( UINT nFlags , CPoint point ) { View -> TabCtrl . SetFocus ( ) ; CDialog :: OnLButtonDown ( nFlags , point ) ; } void CFormDialog :: onGetSubFocus ( uint id ) { int widget = getWidget ( id ) ; WidgetFocused = widget ; RECT widgetRect ; if ( Widgets [ widget ] -> getWindowRect ( widgetRect ) ) { View -> ScreenToClient ( & widgetRect ) ; RECT viewRect ; View -> GetClientRect ( & viewRect ) ; int bottom = viewRect . bottom - viewRect . top ; if ( widgetRect . bottom > bottom ) { CPoint pt = View -> GetScrollPosition ( ) ; View -> ScrollToPosition ( CPoint ( pt . x , pt . y + widgetRect . bottom - bottom + 10 ) ) ; } if ( widgetRect . top < 0 ) { CPoint pt = View -> GetScrollPosition ( ) ; View -> ScrollToPosition ( CPoint ( pt . x , pt . y + widgetRect . top - 10 ) ) ; } } } void CFormDialog :: OnSetFocus ( CWnd * pNewWnd ) { CDialog :: OnSetFocus ( pNewWnd ) ; if ( WidgetFocused != 0xffffffff ) Widgets [ WidgetFocused ] -> setFocus ( ) ; } void CFormDialog :: OnKillFocus ( CWnd * pNewWnd ) { CDialog :: OnKillFocus ( pNewWnd ) ; } IFormWidget :: IFormWidget ( CFormDialog * dialog , uint structId , const char * atomName , TTypeSrc typeSrc , uint slot ) { FormName = atomName ; Dialog = dialog ; StructId = structId ; SrcType = typeSrc ; Slot = slot ; } bool IFormWidget :: isDialog ( uint id ) const { return ( id >= FirstId ) && ( id <= LastId ) ; } ; uint IFormWidget :: getSlot ( ) const { return Slot ; } ; uint IFormWidget :: getStructId ( ) const { return StructId ; } void IFormWidget :: updateLabel ( ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; if ( doc ) { if ( IsWindow ( Label ) ) { if ( SrcType != TypeFormParent ) { if ( ( SrcType == TypeForm ) || ( SrcType == TypeType ) ) { std :: string result ; UFormElm :: TWhere@@ IsValue where ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; nlverify ( elm -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , & where ) ) ; std :: string resultEvaluated ; # ifdef TEST_EVAL_@@ FORMULA bool error = ! elm -> getValueByName ( resultEvaluated , FormName . c_str ( ) , UFormElm :: Formula , & where ) ; # else bool error = ! elm -> getValueByName ( resultEvaluated , FormName . c_str ( ) , UFormElm :: Eval , & where ) ; # endif string comp ; if ( error ) comp = " ▁ ( Value ▁ = ▁ Error ) " ; else { if ( resultEvaluated != result ) comp = " ▁ ( Value ▁ = ▁ \ " " + resultEvaluated + " \ " ) " ; } switch ( where ) { case UFormElm :: ValueForm : Label . SetWindowText ( ( SavedLabel + comp ) . c_str ( ) ) ; break ; case UFormElm :: ValueParent@@ Form : Label . SetWindowText ( ( SavedLabel + " ▁ ( in ▁ parent ▁ form ) " + comp ) . c_str ( ) ) ; break ; case UFormElm :: ValueDefaultDfn : Label . SetWindowText ( ( SavedLabel + " ▁ ( default ▁ DFN ▁ value ) " + comp ) . c_str ( ) ) ; break ; case UFormElm :: ValueDefaultType : Label . SetWindowText ( ( SavedLabel + " ▁ ( default ▁ TYPE ▁ value ) " + comp ) . c_str ( ) ) ; break ; } } else { const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( FormName . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; if ( node ) { if ( node -> getForm ( ) == doc -> getFormPtr ( ) ) { Label . SetWindowText ( SavedLabel . c_str ( ) ) ; } else { Label . SetWindowText ( ( SavedLabel + " ▁ ( in ▁ parent ▁ form ) " ) . c_str ( ) ) ; } } else { Label . SetWindowText ( ( SavedLabel + " ▁ ( undefined ) " ) . c_str ( ) ) ; } } Label . UpdateData ( FALSE ) ; } } } } IFormWidget :: TTypeSrc IFormWidget :: getSrcType ( ) const { return SrcType ; } bool IFormWidget :: extendableHeight ( ) const { return false ; } bool IFormWidget :: getNode ( const CFormDfn * * parentDfn , uint & lastElement , const CFormDfn * * nodeDfn , const CType * * nodeType , CFormElm * * node , UFormDfn :: TEntryType & type , bool & array ) const { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; if ( doc ) { bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; return ( elm -> getNodeByName ( FormName . c_str ( ) , parentDfn , lastElement , nodeDfn , nodeType , node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; } return false ; } CFormElm * IFormWidget :: getFormElmNode ( ) const { const CFormDfn * parentDfn ; uint parentDfnIndex ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; if ( getNode ( & parentDfn , parentDfnIndex , & nodeDfn , & nodeType , & node , type , array ) ) { return node ; } return NULL ; } CFormElmStruct * IFormWidget :: getFormElmStructNode ( ) const { CFormElm * elm = getFormElmNode ( ) ; return elm ? safe_cast < CFormElmStruct * > ( elm ) : NULL ; } CFormElmVirtualStruct * IFormWidget :: getFormElmVirtualStructNode ( ) const { CFormElm * elm = getFormElmNode ( ) ; return elm ? safe_cast < CFormElmVirtualStruct * > ( elm ) : NULL ; } CFormElmArray * IFormWidget :: getFormElmArrayNode ( ) const { CFormElm * elm = getFormElmNode ( ) ; return elm ? safe_cast < CFormElmArray * > ( elm ) : NULL ; } CFormElmAtom * IFormWidget :: getFormElmAtomNode ( ) const { CFormElm * elm = getFormElmNode ( ) ; return elm ? safe_cast < CFormElmAtom * > ( elm ) : NULL ; } const string & IFormWidget :: getFormName ( ) const { return FormName ; } uint IFormWidget :: getNumValue ( ) { nlstop ; return 0 ; } void IFormWidget :: getValue ( std :: string & result ) { nlstop ; } void IFormWidget :: getValue ( std :: string & result , uint value ) { nlstop ; } bool IFormWidget :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Label ) ) { Label . GetWindowRect ( & rect ) ; return true ; } else return false ; } void IFormWidget :: onOpenSelected ( ) { string str ; getValue ( str ) ; std :: string str2 = CPath :: lookup ( str . c_str ( ) , false , false ) ; if ( str2 . empty ( ) ) str2 = str . c_str ( ) ; theApp . OpenDocumentFile ( str2 . c_str ( ) ) ; } CFormMemCombo :: CFormMemCombo ( CFormDialog * dialog , uint structId , const char * atomName , TTypeSrc typeSrc , uint slot ) : IFormWidget ( dialog , structId , atomName , typeSrc , slot ) { UseSpinner = false ; FileBrowser = false ; } CFormMemCombo :: ~ CFormMemCombo ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( Combo ) ) Combo . DestroyWindow ( ) ; if ( IsWindow ( Spin ) ) Spin . DestroyWindow ( ) ; if ( IsWindow ( Browse ) ) Browse . DestroyWindow ( ) ; } void CFormMemCombo :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label , const char * reg , bool useSpinner , bool fileBrowser , const char * filenameExt ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType = NULL ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( FormName . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; FirstId = dialog_index ; LastId = FirstId + 1 ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; UseSpinner = useSpinner ; FileBrowser = fileBrowser ; if ( useSpinner ) { parent -> setComboSpinSize ( currentPos ) ; Combo . create ( WS_CHILD | WS_TABSTOP , currentPos , parent , dialog_index , reg , theApp . RememberListSize ) ; parent -> initWidget ( Combo ) ; RECT spinPos = currentPos ; parent -> getNextSpinPos ( spinPos ) ; parent -> setSpinSize ( spinPos ) ; Spin . Create ( WS_CHILD | WS_VISIBLE , spinPos , parent , dialog_index + 1 ) ; parent -> getNextPos ( currentPos ) ; } else if ( fileBrowser ) { parent -> setComboBrowseSize ( currentPos ) ; Combo . create ( WS_CHILD | WS_TABSTOP , currentPos , parent , dialog_index , reg , theApp . RememberListSize ) ; parent -> initWidget ( Combo ) ; RECT spinPos = currentPos ; parent -> getNextBrowsePos ( spinPos ) ; parent -> setBrowseSize ( spinPos ) ; Browse . Create ( " . . . " , WS_CHILD | WS_VISIBLE | WS_TABSTOP , spinPos , parent , dialog_index + 1 ) ; parent -> initWidget ( Browse ) ; parent -> getNextPos ( currentPos ) ; if ( filenameExt ) { if ( strcmp ( filenameExt , " * . * " ) != 0 ) Combo . enableAutoComplete@@ Extension ( true , filenameExt ) ; } } else { parent -> setComboSize ( currentPos , parent -> SmallWidget ) ; Combo . create ( WS_CHILD | WS_TABSTOP , currentPos , parent , dialog_index , reg , theApp . RememberListSize ) ; parent -> initWidget ( Combo ) ; parent -> getNextPos ( currentPos ) ; } if ( nodeType ) { for ( uint predef = 0 ; predef < nodeType -> Definitions . size ( ) ; predef ++ ) { Combo . addStaticStrings ( nodeType -> Definitions [ predef ] . Label . c_str ( ) ) ; } } dialog_index += 2 ; } void CFormMemCombo :: updateData ( bool update ) { Combo . UpdateData ( update ? TRUE : FALSE ) ; } bool CFormMemCombo :: haveFocus ( ) { return ( Combo . haveFocus ( ) ) ; } void CFormMemCombo :: setFocus ( ) { Combo . SetFocus ( ) ; } void CFormMemCombo :: onOk ( ) { Combo . onOK ( ) ; } void CFormMemCombo :: getValue ( std :: string & result ) { Combo . UpdateData ( ) ; CString str ; Combo . GetWindowText ( str ) ; Combo . UpdateData ( FALSE ) ; result = ( const char * ) str ; } void CFormMemCombo :: getFromDocument ( CForm & form ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; if ( ( SrcType == TypeForm ) || ( SrcType == TypeType ) ) { string result ; if ( doc -> getRootNode ( getSlot ( ) ) -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , NULL ) ) { Combo . UpdateData ( ) ; Combo . SetWindowText ( result . c_str ( ) ) ; Combo . UpdateData ( FALSE ) ; updateLabel ( ) ; } else { nlstop ; } } else if ( SrcType == TypeArray ) { const CFormDfn * parentDfn ; uint lastElement ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; nlverify ( ( ( const CFormElm * ) doc -> getRootNode ( getSlot ( ) ) ) -> getNodeByName ( FormName . c_str ( ) , & parentDfn , lastElement , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; nlassert ( array ) ; Combo . UpdateData ( ) ; if ( node ) { CFormElmArray * arrayNode = safe_cast < CFormElmArray * > ( node ) ; char label [ 512 ] ; smprintf ( label , 512 , " % d " , arrayNode -> Elements . size ( ) ) ; Combo . SetWindowText ( label ) ; if ( arrayNode -> getForm ( ) == & form ) Label . SetWindowText ( " Array ▁ size : " ) ; else Label . SetWindowText ( " Array ▁ size : ▁ ( in ▁ parent ▁ form ) " ) ; } else { Combo . SetWindowText ( "0" ) ; } Combo . UpdateData ( FALSE ) ; } else if ( SrcType == TypeVirtualDfn ) { const CFormDfn * parentDfn ; uint lastElement ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; nlverify ( ( ( const CFormElm * ) doc -> getRootNode ( getSlot ( ) ) ) -> getNodeByName ( FormName . c_str ( ) , & parentDfn , lastElement , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; nlassert ( ! array ) ; Combo . UpdateData ( ) ; if ( node ) { CFormElmVirtualStruct * virtualNode = safe_cast < CFormElmVirtualStruct * > ( node ) ; Combo . SetWindowText ( virtualNode -> DfnFilename . c_str ( ) ) ; } else { Combo . SetWindowText ( " " ) ; } Combo . UpdateData ( FALSE ) ; } } bool CFormMemCombo :: isWnd ( const CWnd * wnd ) const { return Combo . isWnd ( wnd ) ; } void CFormMemCombo :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; if ( UseSpinner ) { Dialog -> setComboSpinSize ( currentPos ) ; if ( resize ) { Combo . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } RECT spinPos = currentPos ; Dialog -> getNextSpinPos ( spinPos ) ; Dialog -> setSpinSize ( spinPos ) ; if ( resize ) { Spin . SetWindowPos ( NULL , spinPos . left , spinPos . top , spinPos . right - spinPos . left , spinPos . bottom - spinPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } } else if ( FileBrowser ) { Dialog -> setComboBrowseSize ( currentPos ) ; if ( resize ) { Combo . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } RECT spinPos = currentPos ; Dialog -> getNextBrowsePos ( spinPos ) ; Dialog -> setBrowseSize ( spinPos ) ; if ( resize ) { Browse . SetWindowPos ( NULL , spinPos . left , spinPos . top , spinPos . right - spinPos . left , spinPos . bottom - spinPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } } else { Dialog -> setComboSize ( currentPos , Dialog -> SmallWidget ) ; if ( resize ) { Combo . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } } Dialog -> getNextPos ( currentPos ) ; } bool CFormMemCombo :: getWindowRect ( RECT & rect ) const { if ( Combo ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; Combo . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } CFormCombo :: CFormCombo ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { } CFormCombo :: ~ CFormCombo ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( Combo ) ) Combo . DestroyWindow ( ) ; } void CFormCombo :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; FirstId = dialog_index ; LastId = FirstId ; const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( FormName . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setComboSize ( currentPos , parent -> SmallWidget ) ; RECT comboPos = currentPos ; parent -> adjusteComboSize ( comboPos ) ; Combo . Create ( WS_CHILD | WS_VSCROLL | WS_VISIBLE | CBS_DROPDO@@ WNLIST | CBS_HASSTRINGS | WS_CHILD | WS_TABSTOP , comboPos , parent , dialog_index ) ; parent -> initWidget ( Combo ) ; parent -> getNextPos ( currentPos ) ; if ( nodeType ) { Combo . InsertString ( 0 , " " ) ; for ( uint predef = 0 ; predef < nodeType -> Definitions . size ( ) ; predef ++ ) { Combo . InsertString ( predef + 1 , nodeType -> Definitions [ predef ] . Label . c_str ( ) ) ; } } dialog_index += 1 ; } void CFormCombo :: updateData ( bool update ) { Combo . UpdateData ( update ? TRUE : FALSE ) ; } bool CFormCombo :: haveFocus ( ) { CWnd * focus = CWnd :: GetFocus ( ) ; if ( focus ) { return ( focus == & Combo ) ; } return false ; } void CFormCombo :: setFocus ( ) { Combo . SetFocus ( ) ; } void CFormCombo :: onOk ( ) { } void CFormCombo :: getValue ( std :: string & result ) { Combo . UpdateData ( ) ; CString str ; Combo . GetWindowText ( str ) ; Combo . UpdateData ( FALSE ) ; result = ( const char * ) str ; } void CFormCombo :: getFromDocument ( CForm & form ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; string result ; if ( doc -> getRootNode ( getSlot ( ) ) -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , NULL ) ) { Combo . UpdateData ( ) ; uint itemCount = Combo . GetCount ( ) ; for ( uint i = 0 ; i < itemCount ; i ++ ) { CString item ; Combo . GetLBText ( i , item ) ; if ( item == result . c_str ( ) ) { Combo . SetCurSel ( i ) ; break ; } } Combo . UpdateData ( FALSE ) ; updateLabel ( ) ; } else { nlstop ; } } bool CFormCombo :: isWnd ( const CWnd * wnd ) const { return & Combo == ( const CWnd * ) wnd ; } void CFormCombo :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setComboSize ( currentPos , Dialog -> SmallWidget ) ; if ( resize ) { RECT comboPos = currentPos ; Dialog -> adjusteComboSize ( comboPos ) ; Combo . SetWindowPos ( NULL , comboPos . left , comboPos . top , comboPos . right - comboPos . left , comboPos . bottom - comboPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CFormCombo :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Combo ) ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; Combo . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } CFormBigEdit :: CFormBigEdit ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { } CFormBigEdit :: ~ CFormBigEdit ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( Edit ) ) Edit . DestroyWindow ( ) ; } void CFormBigEdit :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label ) { FirstId = dialog_index ; LastId = FirstId ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setBigEditSize ( currentPos , parent -> SmallWidget ) ; Edit . CreateEx ( WS_EX_CLIENTEDGE , _T ( " EDIT " ) , " " , WS_VSCROLL | ES_OEMCONVERT | ES_MULTILINE | ES_WANTRETURN | WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_AUTOHSCROLL | ES_AUTOVSCROLL , currentPos , parent , dialog_index ) ; parent -> initWidget ( Edit ) ; parent -> getNextPos ( currentPos ) ; dialog_index += 1 ; } void CFormBigEdit :: updateData ( bool update ) { Edit . UpdateData ( update ? TRUE : FALSE ) ; } bool CFormBigEdit :: haveFocus ( ) { CWnd * focus = CWnd :: GetFocus ( ) ; if ( focus ) { return ( focus == & Edit ) ; } return false ; } void CFormBigEdit :: setFocus ( ) { Edit . SetFocus ( ) ; } void CFormBigEdit :: onOk ( ) { } void CFormBigEdit :: getValue ( std :: string & result ) { Edit . UpdateData ( ) ; CString str ; Edit . GetWindowText ( str ) ; Edit . UpdateData ( FALSE ) ; result = ( const char * ) str ; } void CFormBigEdit :: getFromDocument ( CForm & form ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; string result ; if ( doc -> getRootNode ( getSlot ( ) ) -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , NULL ) ) { Edit . UpdateData ( ) ; Dialog -> setEditTextMultiLine ( Edit , result . c_str ( ) ) ; Edit . UpdateData ( FALSE ) ; updateLabel ( ) ; } else { nlstop ; } } bool CFormBigEdit :: isWnd ( const CWnd * wnd ) const { return & Edit == wnd ; } void CFormBigEdit :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { if ( ! resize ) widgetCount ++ ; Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setBigEditSize ( currentPos , Dialog -> SmallWidgetNotLimited , Dialog -> BigEditHeight + adjust ) ; if ( resize ) { Edit . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CFormBigEdit :: extendableHeight ( ) const { return true ; } bool CFormBigEdit :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Edit ) ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; Edit . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } CColorEdit :: CColorEdit ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { Empty = true ; } CColorEdit :: ~ CColorEdit ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( Color ) ) Color . DestroyWindow ( ) ; if ( IsWindow ( Edit ) ) Edit . DestroyWindow ( ) ; } void CColorEdit :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label ) { FirstId = dialog_index ; LastId = FirstId + 2 ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setColorSize ( currentPos , parent -> SmallWidget ) ; Color . create ( WS_CHILD | WS_VISIBLE | WS_TABSTOP , currentPos , parent , dialog_index ) ; parent -> initWidget ( Color ) ; RECT resetPos = currentPos ; parent -> getNextColorPos ( resetPos ) ; parent -> setResetColorSize ( resetPos ) ; Reset . Create ( " Reset " , WS_CHILD | WS_VISIBLE | WS_TABSTOP , resetPos , parent , dialog_index + 1 ) ; parent -> initWidget ( Reset ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setBigEditSize ( currentPos , parent -> SmallWidget ) ; Edit . CreateEx ( WS_EX_CLIENTEDGE , _T ( " EDIT " ) , " " , ES_OEMCONVERT | ES_WANTRETURN | WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_AUTOHSCROLL , currentPos , parent , dialog_index + 2 ) ; parent -> initWidget ( Edit ) ; parent -> getNextPos ( currentPos ) ; Color . setEdit ( & Edit ) ; dialog_index += 3 ; } void CColorEdit :: updateData ( bool update ) { Color . UpdateData ( update ? TRUE : FALSE ) ; Edit . UpdateData ( update ? TRUE : FALSE ) ; } bool CColorEdit :: haveFocus ( ) { CWnd * focus = CWnd :: GetFocus ( ) ; if ( focus ) { return ( focus == & Color ) ; } return false ; } void CColorEdit :: setFocus ( ) { Color . SetFocus ( ) ; } void CColorEdit :: onOk ( ) { } void CColorEdit :: getValue ( std :: string & result ) { if ( ! Empty ) { Color . UpdateData ( ) ; CRGBA color = Color . getColor ( ) ; char colorName [ 512 ] ; smprintf ( colorName , 512 , " % d , % d , % d " , color . R , color . G , color . B ) ; result = colorName ; } else { result = " " ; } } void CColorEdit :: getFromDocument ( CForm & form ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; string result ; if ( doc -> getRootNode ( getSlot ( ) ) -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , NULL ) ) { Color . UpdateData ( ) ; sint r , g , b ; if ( sscanf ( result . c_str ( ) , " % d , % d , % d " , & r , & g , & b ) == 3 ) { clamp ( r , 0 , 255 ) ; clamp ( g , 0 , 255 ) ; clamp ( b , 0 , 255 ) ; CRGBA color ( r , g , b ) ; Color . setColor ( color ) ; if ( r != 255 && g != 255 && b != 255 ) Color . updateEdit ( ) ; } else { Color . setColor ( CRGBA :: Black ) ; Color . updateEdit ( ) ; } Color . UpdateData ( FALSE ) ; updateLabel ( ) ; } else { nlstop ; } } bool CColorEdit :: isWnd ( const CWnd * wnd ) const { return & Color == wnd ; } void CColorEdit :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setColorSize ( currentPos , Dialog -> SmallWidget ) ; if ( resize ) { Color . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } RECT resetPos = currentPos ; Dialog -> getNextColorPos ( resetPos ) ; Dialog -> setResetColorSize ( resetPos ) ; if ( resize ) { Reset . SetWindowPos ( NULL , resetPos . left , resetPos . top , resetPos . right - resetPos . left , resetPos . bottom - resetPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setEditSize ( currentPos , Dialog -> SmallWidget , Dialog -> EditHeight ) ; if ( resize ) { Edit . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CColorEdit :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Color ) ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; Color . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } CListWidget :: CListWidget ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { ListCtrl . Ctrl = this ; } CListWidget :: ~ CListWidget ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( ListCtrl ) ) ListCtrl . DestroyWindow ( ) ; if ( IsWindow ( Button ) ) Button . DestroyWindow ( ) ; } void CListWidget :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label , const char * reg , uint divid ) { FirstId = dialog_index ; LastId = FirstId + 1 ; Divid = divid ; RegAdr = reg ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setListSize ( currentPos , parent -> SmallWidget ) ; ListCtrl . create ( WS_CHILD | WS_VISIBLE | WS_TABSTOP , currentPos , parent , dialog_index ) ; parent -> initWidget ( ListCtrl ) ; parent -> getNextPos ( currentPos ) ; parent -> setButtonSize ( currentPos , parent -> SmallWidget ) ; Button . Create ( " Assign ▁ parents " , WS_CHILD | WS_VISIBLE | WS_TABSTOP , currentPos , parent , dialog_index + 1 ) ; parent -> initWidget ( Button ) ; parent -> getNextPos ( currentPos ) ; dialog_index += 2 ; } void CListWidget :: addColumn ( const char * name ) { ListCtrl . insertColumn ( 0 , name ) ; ListCtrl . recalcColumn ( ) ; } void CListWidget :: onOk ( ) { ListCtrl . onOK ( ) ; } void CListWidget :: updateData ( bool update ) { ListCtrl . UpdateData ( update ) ; } bool CListWidget :: haveFocus ( ) { CWnd * wnd = Dialog -> GetFocus ( ) ; if ( wnd ) { return ( wnd -> GetParent ( ) == & ListCtrl ) ; } return false ; } void CListWidget :: setFocus ( ) { ListCtrl . SetFocus ( ) ; } void CListWidget :: getFromDocument ( NLGEORGES :: CForm & form ) { ListCtrl . ListCtrl . DeleteAllItems ( ) ; for ( uint parent = 0 ; parent < form . getParentCount ( ) ; parent ++ ) { string filename = form . getParentFilename ( parent ) ; ListCtrl . ListCtrl . InsertItem ( parent , filename . c_str ( ) ) ; ListCtrl . ListCtrl . UpdateData ( FALSE ) ; updateLabel ( ) ; } } uint CListWidget :: getNumValue ( ) { return ListCtrl . ListCtrl . GetItemCount ( ) ; } void CListWidget :: getValue ( std :: string & result , uint value ) { CString str = ListCtrl . ListCtrl . GetItemText ( value , 0 ) ; result = str ; } bool CListWidget :: isWnd ( const CWnd * wnd ) const { return ( ( ( & ListCtrl ) == wnd ) || ( ( & ListCtrl . ListCtrl ) == wnd ) ) ; } void CListWidget :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { if ( ! resize ) widgetCount ++ ; Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setListSize ( currentPos , Dialog -> SmallWidgetNotLimited / Divid , Dialog -> ListHeight + adjust ) ; if ( resize ) { ListCtrl . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; ListCtrl . recalcColumn ( ) ; } Dialog -> getNextPos ( currentPos ) ; Dialog -> setButtonSize ( currentPos , Dialog -> SmallWidget ) ; if ( resize ) { Button . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CListWidget :: extendableHeight ( ) const { return true ; } CEditListCtrl :: TItemEdit CListWidget :: CMyEditListCtrl :: getItemEditMode ( uint item , uint subItem ) { return CEditListCtrl :: EditMemCombo ; } void CListWidget :: CMyEditListCtrl :: getMemComboBoxProp ( uint item , uint subItem , std :: string & regAdr , bool & browse ) { regAdr = Ctrl -> RegAdr ; browse = true ; } void CListWidget :: CMyEditListCtrl :: getNewItemText ( uint item , uint subItem , std :: string & ret ) { Ctrl -> Dialog -> getDfnName ( ret ) ; ret = " default . " + ret ; } void CListWidget :: CMyEditListCtrl :: getBrowseInfo ( uint item , uint subItem , std :: string & defExt , std :: string & defFilename , std :: string & defDir , std :: string & filter ) { string ret ; Ctrl -> Dialog -> getDfnName ( ret ) ; defExt = " * . " + ret ; defFilename = defExt ; filter = " Form ▁ Files ▁ ( * . " + ret + " ) | * . " + ret + " | All ▁ Files ▁ ( * . * ) | * . * | | " ; defDir = theApp . RootSearch@@ Path ; } bool CListWidget :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( ListCtrl ) ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; ListCtrl . ListCtrl . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } void CListWidget :: onOpenSelected ( ) { POSITION pos = ListCtrl . ListCtrl . GetFirstSelectedItemPosition ( ) ; while ( pos ) { int nItem = ListCtrl . ListCtrl . GetNextSelectedItem ( pos ) ; CString str = ListCtrl . ListCtrl . GetItemText ( nItem , 0 ) ; if ( str != " " ) { string name = CPath :: lookup ( ( const char * ) str , false , false ) ; if ( name . empty ( ) ) name = str ; theApp . OpenDocumentFile ( name . c_str ( ) ) ; } } } CIconWidget :: CIconWidget ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { } CIconWidget :: ~ CIconWidget ( ) { if ( IsWindow ( Icon ) ) Icon . DestroyWindow ( ) ; } void CIconWidget :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label ) { FirstId = dialog_index ; LastId = FirstId ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setEditSize ( currentPos , parent -> IconHeight , parent -> IconHeight ) ; Icon . create ( WS_CHILD | WS_VISIBLE | WS_TABSTOP , currentPos , parent , dialog_index ) ; parent -> initWidget ( Icon ) ; parent -> getNextPos ( currentPos ) ; dialog_index += 1 ; } void CIconWidget :: updateData ( bool update ) { Icon . UpdateData ( update ? TRUE : FALSE ) ; } bool CIconWidget :: haveFocus ( ) { CWnd * focus = CWnd :: GetFocus ( ) ; if ( focus ) { return ( focus == & Icon ) ; } return false ; } void CIconWidget :: setFocus ( ) { Icon . SetFocus ( ) ; } void CIconWidget :: onOk ( ) { } void CIconWidget :: getValue ( std :: string & result ) { result = " " ; } void CIconWidget :: getFromDocument ( CForm & form ) { } bool CIconWidget :: isWnd ( const CWnd * wnd ) const { return & Icon == wnd ; } void CIconWidget :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setEditSize ( currentPos , Dialog -> IconHeight , Dialog -> IconHeight ) ; if ( resize ) { Icon . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CIconWidget :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Icon ) ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; Icon . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } </DOCUMENT>
<DOCUMENT_ID="reg@@ neq/TrinityCore/tree/master/src/server/game/Miscellane@@ ous/CommonPredicates.cpp"> # include " CommonPredicates . h " # include " Common . h " # include " Unit . h " # include " SharedDefines . h " Trinity :: Predicates :: IsVictimOf :: IsVictimOf ( Unit const * attacker ) : _victim ( attacker ? attacker -> GetVictim ( ) : nullptr ) { } </DOCUMENT>
<DOCUMENT_ID="Maximus-/WinObjC/tree/master/deps/3rdparty/icu/icu/source/layout/TibetanReordering@@ .cpp"> # include " LETypes . h " # include " OpenTypeTables . h " # include " TibetanReordering . h " # include " LEGlyphStorage . h " U_NAMESPACE_BEGIN enum { C_DOTTED_CIRCLE = 0x25CC , C_PRE_NUMBER_MARK = 0x0F3F } ; enum { _xx = TibetanClassTable :: CC_RESERVED , _ba = TibetanClassTable :: CC_BASE , _sj = TibetanClassTable :: CC_SUB@@ JOINED | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _tp = TibetanClassTable :: CC_TSA@@ _PHRU | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _ac = TibetanClassTable :: CC_A_CH@@ UNG | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _cs = TibetanClassTable :: CC_COMP@@ _SANSKRIT | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _ha = TibetanClassTable :: CC_HALANTA | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _bv = TibetanClassTable :: CC_BELOW_VOWEL | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _av = TibetanClassTable :: CC_ABOVE_VOWEL | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _an = TibetanClassTable :: CC_AN@@ USVARA | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _cb = TibetanClassTable :: CC_CANDR@@ ABINDU | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _vs = TibetanClassTable :: CC_VIS@@ ARGA | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_AFTER , _as = TibetanClassTable :: CC_ABOVE_S_MARK | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _bs = TibetanClassTable :: CC_BELOW_S_MARK | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _di = TibetanClassTable :: CC_DIGIT | TibetanClassTable :: CF_DIGIT , _pd = TibetanClassTable :: CC_PRE_@@ DIGIT_MARK | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_PREDIGIT | TibetanClassTable :: CF_POS_BEFORE , _bd = TibetanClassTable :: CC_POST_@@ BELOW_DIGIT_@@ M | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_AFTER } ; static const TibetanClassTable :: CharClass tibetanCharClasses [ ] = { _xx , _ba , _xx , _xx , _ba , _ba , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _bd , _bd , _xx , _xx , _xx , _xx , _xx , _xx , _di , _di , _di , _di , _di , _di , _di , _di , _di , _di , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _bs , _xx , _bs , _xx , _tp , _xx , _xx , _xx , _xx , _bd , _pd , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _xx , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _xx , _xx , _xx , _xx , _xx , _xx , _ac , _av , _cs , _bv , _bv , _cs , _cs , _cs , _cs , _av , _av , _av , _av , _an , _vs , _av , _cs , _cb , _cb , _ha , _xx , _as , _as , _ba , _ba , _ba , _ba , _xx , _xx , _xx , _xx , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _xx , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _xx , _sj , _sj , _xx , _xx , _xx , _xx , _xx , _xx , _bs , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , } ; static const TibetanClassTable tibetanClassTable = { 0x0F00 , 0x0FFF , tibetanCharClasses } ; TibetanClassTable :: CharClass TibetanClassTable :: getCharClass ( LEUnicode ch ) const { if ( ch < firstChar || ch > lastChar ) { return CC_RESERVED ; } return classTable [ ch - firstChar ] ; } const TibetanClassTable * TibetanClassTable :: getTibetanClassTable ( ) { return & tibetanClassTable ; } class TibetanReorderingOutput : public UMemory { private : le_int32 fSyllableCount ; le_int32 fOutIndex ; LEUnicode * fOutChars ; LEGlyphStorage & fGlyphStorage ; public : TibetanReorderingOutput ( LEUnicode * outChars , LEGlyphStorage & glyphStorage ) : fSyllableCount ( 0 ) , fOutIndex ( 0 ) , fOutChars ( outChars ) , fGlyphStorage ( glyphStorage ) { } ~ TibetanReorderingOutput ( ) { } void reset ( ) { fSyllableCount += 1 ; } void writeChar ( LEUnicode ch , le_uint32 charIndex , FeatureMask featureMask ) { LEErrorCode success = LE_NO_ERROR ; fOutChars [ fOutIndex ] = ch ; fGlyphStorage . setCharIndex ( fOutIndex , charIndex , success ) ; fGlyphStorage . setAuxData ( fOutIndex , featureMask , success ) ; fOutIndex += 1 ; } le_int32 getOutputIndex ( ) { return fOutIndex ; } } ; # define ccmpFeatureTag LE_CCMP_@@ FEATURE_TAG # define blwfFeatureTag LE_BLWF_FEATURE_TAG # define pstfFeatureTag LE_PSTF_FEATURE_TAG # define presFeatureTag LE_PRES@@ _FEATURE_TAG # define blwsFeatureTag LE_BLWS_FEATURE_TAG # define abvsFeatureTag LE_ABVS_FEATURE_TAG # define pstsFeatureTag LE_PSTS_FEATURE_TAG # define blwmFeatureTag LE_BLWM_FEATURE_TAG # define abvmFeatureTag LE_ABVM_FEATURE_TAG # define distFeatureTag LE_DIS@@ T_FEATURE_TAG # define prefFeatureTag LE_PRE@@ F_FEATURE_TAG # define abvfFeatureTag LE_ABVF_FEATURE_TAG # define cligFeatureTag LE_CLI@@ G_FEATURE_TAG # define mkmkFeatureTag LE_MK@@ MK_FEATURE_TAG # define prefFeatureMask 0x80000000UL # define blwfFeatureMask 0x40000000UL # define abvfFeatureMask 0x20000000UL # define pstfFeatureMask 0x10000000UL # define presFeatureMask 0x080000@@ 00UL # define blwsFeatureMask 0x04000000UL # define abvsFeatureMask 0x02000000UL # define pstsFeatureMask 0x01000000@@ UL # define cligFeatureMask 0x0080000@@ 0UL # define ccmpFeatureMask 0x0004@@ 0000UL # define distFeatureMask 0x00400000UL # define blwmFeatureMask 0x00200000UL # define abvmFeatureMask 0x0010000@@ 0UL # define mkmkFeatureMask 0x00080000@@ UL # define tagPref ( ccmpFeatureMask | prefFeatureMask | presFeatureMask | cligFeatureMask | distFeatureMask ) # define tagAbvf ( ccmpFeatureMask | abvfFeatureMask | abvsFeatureMask | cligFeatureMask | distFeatureMask | abvmFeatureMask | mkmkFeatureMask ) # define tagPstf ( ccmpFeatureMask | blwfFeatureMask | blwsFeatureMask | prefFeatureMask | presFeatureMask | pstfFeatureMask | pstsFeatureMask | cligFeatureMask | distFeatureMask | blwmFeatureMask ) # define tagBlwf ( ccmpFeatureMask | blwfFeatureMask | blwsFeatureMask | cligFeatureMask | distFeatureMask | blwmFeatureMask | mkmkFeatureMask ) # define tagDefault ( ccmpFeatureMask | prefFeatureMask | blwfFeatureMask | presFeatureMask | blwsFeatureMask | cligFeatureMask | distFeatureMask | abvmFeatureMask | blwmFeatureMask | mkmkFeatureMask ) static const FeatureMap featureMap [ ] = { { ccmpFeatureTag , ccmpFeatureMask } , { prefFeatureTag , prefFeatureMask } , { blwfFeatureTag , blwfFeatureMask } , { abvfFeatureTag , abvfFeatureMask } , { pstfFeatureTag , pstfFeatureMask } , { presFeatureTag , presFeatureMask } , { blwsFeatureTag , blwsFeatureMask } , { abvsFeatureTag , abvsFeatureMask } , { pstsFeatureTag , pstsFeatureMask } , { cligFeatureTag , cligFeatureMask } , { distFeatureTag , distFeatureMask } , { blwmFeatureTag , blwmFeatureMask } , { abvmFeatureTag , abvmFeatureMask } , { mkmkFeatureTag , mkmkFeatureMask } , } ; static const le_int32 featureMapCount = LE_ARRAY_SIZE ( featureMap ) ; static const le_int8 tibetanStateTable [ ] [ TibetanClassTable :: CC_COUNT ] = { { 1 , 2 , 4 , 3 , 8 , 7 , 9 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , 20 , 21 , 21 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , 4 , 3 , 8 , 7 , 9 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , 5 , - 1 , 8 , 7 , - 1 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , 4 , 6 , 8 , 7 , 9 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , 5 , - 1 , 8 , 7 , - 1 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , 8 , 7 , - 1 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 14 , 13 , 17 , - 1 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 11 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 12 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 14 , 17 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 15 , 17 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 16 , 17 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 17 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 21 , 21 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , } , } ; const FeatureMap * TibetanReordering :: getFeatureMap ( le_int32 & count ) { count = featureMapCount ; return featureMap ; } le_int32 TibetanReordering :: findSyllable ( const TibetanClassTable * classTable , const LEUnicode * chars , le_int32 prev , le_int32 charCount ) { le_int32 cursor = prev ; le_int8 state = 0 ; while ( cursor < charCount ) { TibetanClassTable :: CharClass charClass = ( classTable -> getCharClass ( chars [ cursor ] ) & TibetanClassTable :: CF_CLASS_@@ MASK ) ; state = tibetanStateTable [ state ] [ charClass ] ; if ( state < 0 ) { break ; } cursor += 1 ; } return cursor ; } le_int32 TibetanReordering :: reorder ( const LEUnicode * chars , le_int32 charCount , le_int32 , LEUnicode * outChars , LEGlyphStorage & glyphStorage ) { const TibetanClassTable * classTable = TibetanClassTable :: getTibetanClassTable ( ) ; TibetanReorderingOutput output ( outChars , glyphStorage ) ; TibetanClassTable :: CharClass charClass ; le_int32 i , prev = 0 ; while ( prev < charCount ) { le_int32 syllable = findSyllable ( classTable , chars , prev , charCount ) ; output . reset ( ) ; if ( classTable -> getCharClass ( chars [ prev ] ) & TibetanClassTable :: CF_DOTTED_CIRCLE ) { output . writeChar ( C_DOTTED_CIRCLE , prev , tagDefault ) ; } for ( i = prev ; i < syllable ; i += 1 ) { charClass = classTable -> getCharClass ( chars [ i ] ) ; if ( ( TibetanClassTable :: CF_DIGIT & charClass ) && ( classTable -> getCharClass ( chars [ i + 1 ] ) & TibetanClassTable :: CF_PREDIGIT ) ) { output . writeChar ( C_PRE_NUMBER_MARK , i , tagPref ) ; output . writeChar ( chars [ i ] , i + 1 , tagPref ) ; i += 1 ; } else { switch ( charClass & TibetanClassTable :: CF_POS_MASK ) { case TibetanClassTable :: CF_POS_ABOVE : output . writeChar ( chars [ i ] , i , tagAbvf ) ; break ; case TibetanClassTable :: CF_POS_AFTER : output . writeChar ( chars [ i ] , i , tagPstf ) ; break ; case TibetanClassTable :: CF_POS_BELOW : output . writeChar ( chars [ i ] , i , tagBlwf ) ; break ; default : output . writeChar ( chars [ i ] , i , tagDefault ) ; break ; } } } prev = syllable ; } return output . getOutputIndex ( ) ; } U_NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="yantrab@@ uddhi/@@ FreeCAD@@ /tree/master/src/3rd@@ Party/salo@@ mesmes@@ h/src/Driver/@@ Driver_Document.cpp"> # include " Driver _ Document . h " Driver_Document :: Driver_Document ( ) : myDocument ( NULL ) { } void Driver_Document :: SetFile ( const std :: string & theFileName ) { myFile = theFileName ; } void Driver_Document :: SetDocument ( SMESHDS_Document * theDocument ) { myDocument = theDocument ; } </DOCUMENT>
<DOCUMENT_ID="fbergm@@ ann/lib@@ SEDML@@ /tree/master/sedml@@ /SedDocument.cpp"> # include < sedml / SedDocument . h > # include < sedml / SedTypes . h > # include < sbml / xml / XMLInputStream . h > using namespace std ; LIBSEDML_CPP_NAMESPACE_BEGIN SedDocument :: SedDocument ( unsigned int level , unsigned int version ) : SedBase ( level , version ) , mLevel ( SEDML_INT_MAX ) , mIsSetLevel ( false ) , mVersion ( SEDML_INT_MAX ) , mIsSetVersion ( false ) , mDataDescriptions ( level , version ) , mSimulations ( level , version ) , mModels ( level , version ) , mTasks ( level , version ) , mDataGenerators ( level , version ) , mOutputs ( level , version ) { mLevel = level ; mIsSetLevel = true ; mVersion = version ; mIsSetVersion = true ; setSedDocument ( this ) ; setSedNamespacesAndOwn ( new SedNamespaces ( level , version ) ) ; connectToChild ( ) ; } SedDocument :: SedDocument ( SedNamespaces * sedns ) : SedBase ( sedns ) , mLevel ( SEDML_INT_MAX ) , mIsSetLevel ( false ) , mVersion ( SEDML_INT_MAX ) , mIsSetVersion ( false ) , mDataDescriptions ( sedns ) , mSimulations ( sedns ) , mModels ( sedns ) , mTasks ( sedns ) , mDataGenerators ( sedns ) , mOutputs ( sedns ) { mLevel = sedns -> getLevel ( ) ; mIsSetLevel = true ; mVersion = sedns -> getVersion ( ) ; mIsSetVersion = true ; setSedDocument ( this ) ; setElementNamespace ( sedns -> getURI ( ) ) ; connectToChild ( ) ; } SedDocument :: SedDocument ( const SedDocument & orig ) : SedBase ( orig ) { setSedDocument ( this ) ; mLevel = orig . mLevel ; mIsSetLevel = orig . mIsSetLevel ; mVersion = orig . mVersion ; mIsSetVersion = orig . mIsSetVersion ; mDataDescriptions = orig . mDataDescriptions ; mSimulations = orig . mSimulations ; mModels = orig . mModels ; mTasks = orig . mTasks ; mDataGenerators = orig . mDataGenerators ; mOutputs = orig . mOutputs ; connectToChild ( ) ; } SedDocument & SedDocument :: operator = ( const SedDocument & rhs ) { if ( & rhs != this ) { SedBase :: operator = ( rhs ) ; setSedDocument ( this ) ; mLevel = rhs . mLevel ; mIsSetLevel = rhs . mIsSetLevel ; mVersion = rhs . mVersion ; mIsSetVersion = rhs . mIsSetVersion ; mDataDescriptions = rhs . mDataDescriptions ; mSimulations = rhs . mSimulations ; mModels = rhs . mModels ; mTasks = rhs . mTasks ; mDataGenerators = rhs . mDataGenerators ; mOutputs = rhs . mOutputs ; connectToChild ( ) ; } return * this ; } SedDocument * SedDocument :: clone ( ) const { return new SedDocument ( * this ) ; } SedDocument :: ~ SedDocument ( ) { } const int SedDocument :: getLevel ( ) const { return mLevel ; } const int SedDocument :: getVersion ( ) const { return mVersion ; } bool SedDocument :: isSetLevel ( ) const { return mIsSetLevel ; } bool SedDocument :: isSetVersion ( ) const { return mIsSetVersion ; } int SedDocument :: setLevel ( int level ) { mLevel = level ; mIsSetLevel = true ; return LIBSEDML_OPERATION_SUCCESS ; } int SedDocument :: setVersion ( int version ) { mVersion = version ; mIsSetVersion = true ; return LIBSEDML_OPERATION_SUCCESS ; } int SedDocument :: unsetLevel ( ) { mLevel = SEDML_INT_MAX ; mIsSetLevel = false ; if ( isSetLevel ( ) == false ) { return LIBSEDML_OPERATION_SUCCESS ; } else { return LIBSEDML_OPERATION_FAILED ; } } int SedDocument :: unsetVersion ( ) { mVersion = SEDML_INT_MAX ; mIsSetVersion = false ; if ( isSetVersion ( ) == false ) { return LIBSEDML_OPERATION_SUCCESS ; } else { return LIBSEDML_OPERATION_FAILED ; } } const SedListOfDataDescriptions * SedDocument :: getListOfDataDescriptions ( ) const { return & mDataDescriptions ; } SedDataDescription * SedDocument :: removeDataDescription ( unsigned int n ) { return mDataDescriptions . remove ( n ) ; } SedDataDescription * SedDocument :: removeDataDescription ( const std :: string & sid ) { return mDataDescriptions . remove ( sid ) ; } SedDataDescription * SedDocument :: getDataDescription ( unsigned int n ) { return mDataDescriptions . get ( n ) ; } const SedDataDescription * SedDocument :: getDataDescription ( unsigned int n ) const { return mDataDescriptions . get ( n ) ; } SedDataDescription * SedDocument :: getDataDescription ( const std :: string & sid ) { return mDataDescriptions . get ( sid ) ; } const SedDataDescription * SedDocument :: getDataDescription ( const std :: string & sid ) const { return mDataDescriptions . get ( sid ) ; } int SedDocument :: addDataDescription ( const SedDataDescription * sdd ) { if ( sdd == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mDataDescriptions . append ( sdd ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumDataDescriptions ( ) const { return mDataDescriptions . size ( ) ; } SedDataDescription * SedDocument :: createDataDescription ( ) { SedDataDescription * temp = new SedDataDescription ( ) ; if ( temp != NULL ) mDataDescriptions . appendAndOwn ( temp ) ; return temp ; } const SedListOfSimulations * SedDocument :: getListOfSimulations ( ) const { return & mSimulations ; } SedSimulation * SedDocument :: removeSimulation ( unsigned int n ) { return mSimulations . remove ( n ) ; } SedSimulation * SedDocument :: removeSimulation ( const std :: string & sid ) { return mSimulations . remove ( sid ) ; } SedSimulation * SedDocument :: getSimulation ( unsigned int n ) { return mSimulations . get ( n ) ; } const SedSimulation * SedDocument :: getSimulation ( unsigned int n ) const { return mSimulations . get ( n ) ; } SedSimulation * SedDocument :: getSimulation ( const std :: string & sid ) { return mSimulations . get ( sid ) ; } const SedSimulation * SedDocument :: getSimulation ( const std :: string & sid ) const { return mSimulations . get ( sid ) ; } int SedDocument :: addSimulation ( const SedSimulation * ss ) { if ( ss == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mSimulations . append ( ss ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumSimulations ( ) const { return mSimulations . size ( ) ; } SedUniformTimeCourse * SedDocument :: createUniformTimeCourse ( ) { SedUniformTimeCourse * temp = new SedUniformTimeCourse ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; } SedOneStep * SedDocument :: createOneStep ( ) { SedOneStep * temp = new SedOneStep ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; } SedSteadyState * SedDocument :: createSteadyState ( ) { SedSteadyState * temp = new SedSteadyState ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; } const SedListOfModels * SedDocument :: getListOfModels ( ) const { return & mModels ; } SedModel * SedDocument :: removeModel ( unsigned int n ) { return mModels . remove ( n ) ; } SedModel * SedDocument :: removeModel ( const std :: string & sid ) { return mModels . remove ( sid ) ; } SedModel * SedDocument :: getModel ( unsigned int n ) { return mModels . get ( n ) ; } const SedModel * SedDocument :: getModel ( unsigned int n ) const { return mModels . get ( n ) ; } SedModel * SedDocument :: getModel ( const std :: string & sid ) { return mModels . get ( sid ) ; } const SedModel * SedDocument :: getModel ( const std :: string & sid ) const { return mModels . get ( sid ) ; } int SedDocument :: addModel ( const SedModel * sm ) { if ( sm == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mModels . append ( sm ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumModels ( ) const { return mModels . size ( ) ; } SedModel * SedDocument :: createModel ( ) { SedModel * temp = new SedModel ( ) ; if ( temp != NULL ) mModels . appendAndOwn ( temp ) ; return temp ; } const SedListOfTasks * SedDocument :: getListOfTasks ( ) const { return & mTasks ; } SedTask * SedDocument :: removeTask ( unsigned int n ) { return mTasks . remove ( n ) ; } SedTask * SedDocument :: removeTask ( const std :: string & sid ) { return mTasks . remove ( sid ) ; } SedTask * SedDocument :: getTask ( unsigned int n ) { return mTasks . get ( n ) ; } const SedTask * SedDocument :: getTask ( unsigned int n ) const { return mTasks . get ( n ) ; } SedTask * SedDocument :: getTask ( const std :: string & sid ) { return mTasks . get ( sid ) ; } const SedTask * SedDocument :: getTask ( const std :: string & sid ) const { return mTasks . get ( sid ) ; } int SedDocument :: addTask ( const SedTask * st ) { if ( st == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mTasks . append ( st ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumTasks ( ) const { return mTasks . size ( ) ; } SedTask * SedDocument :: createTask ( ) { SedTask * temp = new SedTask ( ) ; if ( temp != NULL ) mTasks . appendAndOwn ( temp ) ; return temp ; } SedRepeatedTask * SedDocument :: createRepeatedTask ( ) { SedRepeatedTask * temp = new SedRepeatedTask ( ) ; if ( temp != NULL ) mTasks . appendAndOwn ( temp ) ; return temp ; } const SedListOfDataGenerators * SedDocument :: getListOfDataGenerators ( ) const { return & mDataGenerators ; } SedDataGenerator * SedDocument :: removeDataGenerator ( unsigned int n ) { return mDataGenerators . remove ( n ) ; } SedDataGenerator * SedDocument :: removeDataGenerator ( const std :: string & sid ) { return mDataGenerators . remove ( sid ) ; } SedDataGenerator * SedDocument :: getDataGenerator ( unsigned int n ) { return mDataGenerators . get ( n ) ; } const SedDataGenerator * SedDocument :: getDataGenerator ( unsigned int n ) const { return mDataGenerators . get ( n ) ; } SedDataGenerator * SedDocument :: getDataGenerator ( const std :: string & sid ) { return mDataGenerators . get ( sid ) ; } const SedDataGenerator * SedDocument :: getDataGenerator ( const std :: string & sid ) const { return mDataGenerators . get ( sid ) ; } int SedDocument :: addDataGenerator ( const SedDataGenerator * sdg ) { if ( sdg == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mDataGenerators . append ( sdg ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumDataGenerators ( ) const { return mDataGenerators . size ( ) ; } SedDataGenerator * SedDocument :: createDataGenerator ( ) { SedDataGenerator * temp = new SedDataGenerator ( ) ; if ( temp != NULL ) mDataGenerators . appendAndOwn ( temp ) ; return temp ; } const SedListOfOutputs * SedDocument :: getListOfOutputs ( ) const { return & mOutputs ; } SedOutput * SedDocument :: removeOutput ( unsigned int n ) { return mOutputs . remove ( n ) ; } SedOutput * SedDocument :: removeOutput ( const std :: string & sid ) { return mOutputs . remove ( sid ) ; } SedOutput * SedDocument :: getOutput ( unsigned int n ) { return mOutputs . get ( n ) ; } const SedOutput * SedDocument :: getOutput ( unsigned int n ) const { return mOutputs . get ( n ) ; } SedOutput * SedDocument :: getOutput ( const std :: string & sid ) { return mOutputs . get ( sid ) ; } const SedOutput * SedDocument :: getOutput ( const std :: string & sid ) const { return mOutputs . get ( sid ) ; } int SedDocument :: addOutput ( const SedOutput * so ) { if ( so == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mOutputs . append ( so ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumOutputs ( ) const { return mOutputs . size ( ) ; } SedReport * SedDocument :: createReport ( ) { SedReport * temp = new SedReport ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; } SedPlot2D * SedDocument :: createPlot2D ( ) { SedPlot2D * temp = new SedPlot2D ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; } SedPlot3D * SedDocument :: createPlot3D ( ) { SedPlot3D * temp = new SedPlot3D ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; } const std :: string & SedDocument :: getElementName ( ) const { static const string name = " sedML " ; return name ; } SedBase * SedDocument :: createObject ( XMLInputStream & stream ) { SedBase * object = NULL ; const string & name = stream . peek ( ) . getName ( ) ; if ( name == " listOfDataDescriptions " ) { object = & mDataDescriptions ; } if ( name == " listOfSimulations " ) { object = & mSimulations ; } if ( name == " listOfModels " ) { object = & mModels ; } if ( name == " listOfTasks " ) { object = & mTasks ; } if ( name == " listOfDataGenerators " ) { object = & mDataGenerators ; } if ( name == " listOfOutputs " ) { object = & mOutputs ; } connectToChild ( ) ; return object ; } void SedDocument :: connectToChild ( ) { SedBase :: connectToChild ( ) ; mDataDescriptions . connectToParent ( this ) ; mSimulations . connectToParent ( this ) ; mModels . connectToParent ( this ) ; mTasks . connectToParent ( this ) ; mDataGenerators . connectToParent ( this ) ; mOutputs . connectToParent ( this ) ; } int SedDocument :: getTypeCode ( ) const { return SEDML_DOCUMENT ; } bool SedDocument :: hasRequiredAttributes ( ) const { bool allPresent = true ; if ( isSetLevel ( ) == false ) allPresent = false ; if ( isSetVersion ( ) == false ) allPresent = false ; return allPresent ; } bool SedDocument :: hasRequiredElements ( ) const { bool allPresent = true ; return allPresent ; } void SedDocument :: writeElements ( XMLOutputStream & stream ) const { SedBase :: writeElements ( stream ) ; if ( getNumDataDescriptions ( ) > 0 ) { mDataDescriptions . write ( stream ) ; } if ( getNumSimulations ( ) > 0 ) { mSimulations . write ( stream ) ; } if ( getNumModels ( ) > 0 ) { mModels . write ( stream ) ; } if ( getNumTasks ( ) > 0 ) { mTasks . write ( stream ) ; } if ( getNumDataGenerators ( ) > 0 ) { mDataGenerators . write ( stream ) ; } if ( getNumOutputs ( ) > 0 ) { mOutputs . write ( stream ) ; } } bool SedDocument :: accept ( SedVisitor & v ) const { return false ; } void SedDocument :: setSedDocument ( SedDocument * d ) { SedBase :: setSedDocument ( d ) ; mDataDescriptions . setSedDocument ( d ) ; mSimulations . setSedDocument ( d ) ; mModels . setSedDocument ( d ) ; mTasks . setSedDocument ( d ) ; mDataGenerators . setSedDocument ( d ) ; mOutputs . setSedDocument ( d ) ; } void SedDocument :: addExpectedAttributes ( ExpectedAttributes & attributes ) { SedBase :: addExpectedAttributes ( attributes ) ; attributes . add ( " level " ) ; attributes . add ( " version " ) ; } void SedDocument :: readAttributes ( const XMLAttributes & attributes , const ExpectedAttributes & expectedAttributes ) { SedBase :: readAttributes ( attributes , expectedAttributes ) ; bool assigned = false ; mIsSetLevel = attributes . readInto ( " level " , mLevel , getErrorLog ( ) , true ) ; mIsSetVersion = attributes . readInto ( " version " , mVersion , getErrorLog ( ) , true ) ; } void SedDocument :: writeAttributes ( XMLOutputStream & stream ) const { SedBase :: writeAttributes ( stream ) ; if ( isSetLevel ( ) == true ) stream . writeAttribute ( " level " , getPrefix ( ) , mLevel ) ; if ( isSetVersion ( ) == true ) stream . writeAttribute ( " version " , getPrefix ( ) , mVersion ) ; } const SedError * SedDocument :: getError ( unsigned int n ) const { return mErrorLog . getError ( n ) ; } unsigned int SedDocument :: getNumErrors ( ) const { return mErrorLog . getNumErrors ( ) ; } unsigned int SedDocument :: getNumErrors ( unsigned int severity ) const { return getErrorLog ( ) -> getNumFail@@ sWithSeverity ( severity ) ; } SedErrorLog * SedDocument :: getErrorLog ( ) { return & mErrorLog ; } const SedErrorLog * SedDocument :: getErrorLog ( ) const { return & mErrorLog ; } void SedDocument :: writeXML@@ NS ( XMLOutputStream & stream ) const { XMLNamespaces * thisNs = this -> getNamespaces ( ) ; if ( thisNs == NULL ) { XMLNamespaces xmlns ; if ( getVersion ( ) == 1 ) xmlns . add ( SEDML_XMLNS_L1V1 ) ; else xmlns . add ( SEDML_XMLNS_L1V2 ) ; mSedNamespaces -> setNamespaces ( & xmlns ) ; thisNs = getNamespaces ( ) ; } else if ( thisNs -> getLength ( ) == 0 ) { if ( getVersion ( ) == 1 ) thisNs -> add ( SEDML_XMLNS_L1V1 ) ; else if ( getVersion ( ) == 2 ) thisNs -> add ( SEDML_XMLNS_L1V2 ) ; else thisNs -> add ( SEDML_XMLNS_L1V3 ) ; } else { std :: string sedmlURI = SedNamespaces :: getSedNamespaceURI ( getLevel ( ) , getVersion ( ) ) ; std :: string sedmlPrefix = thisNs -> getPrefix ( sedmlURI ) ; if ( thisNs -> hasNS ( sedmlURI , sedmlPrefix ) == false ) { std :: string other = thisNs -> getURI ( sedmlPrefix ) ; if ( other . empty ( ) == false ) { thisNs -> remove ( sedmlPrefix ) ; thisNs -> add ( sedmlURI , sedmlPrefix ) ; thisNs -> add ( other , " addedPrefix " ) ; } else { thisNs -> add ( sedmlURI , sedmlPrefix ) ; } } } XMLNamespaces * xmlns = thisNs -> clone ( ) ; if ( xmlns != NULL ) { stream << * ( xmlns ) ; delete xmlns ; } } XMLNamespaces * SedDocument :: getNamespaces ( ) const { return mSedNamespaces -> getNamespaces ( ) ; } LIBSEDML_EXTERN SedDocument_t * SedDocument_create ( unsigned int level , unsigned int version ) { return new SedDocument ( level , version ) ; } LIBSEDML_EXTERN void SedDocument_free ( SedDocument_t * sd ) { if ( sd != NULL ) delete sd ; } LIBSEDML_EXTERN SedDocument_t * SedDocument_clone ( SedDocument_t * sd ) { if ( sd != NULL ) { return static_cast < SedDocument_t * > ( sd -> clone ( ) ) ; } else { return NULL ; } } LIBSEDML_EXTERN int SedDocument_getLevel ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getLevel ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN int SedDocument_getVersion ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getVersion ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN int SedDocument_isSetLevel ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> isSetLevel ( ) ) : 0 ; } LIBSEDML_EXTERN int SedDocument_isSetVersion ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> isSetVersion ( ) ) : 0 ; } LIBSEDML_EXTERN int SedDocument_setLevel ( SedDocument_t * sd , int level ) { return ( sd != NULL ) ? sd -> setLevel ( level ) : LIBSEDML_INVALID_OBJECT ; } LIBSEDML_EXTERN int SedDocument_setVersion ( SedDocument_t * sd , int version ) { return ( sd != NULL ) ? sd -> setVersion ( version ) : LIBSEDML_INVALID_OBJECT ; } LIBSEDML_EXTERN int SedDocument_unsetLevel ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> unsetLevel ( ) : LIBSEDML_INVALID_OBJECT ; } LIBSEDML_EXTERN int SedDocument_unsetVersion ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> unsetVersion ( ) : LIBSEDML_INVALID_OBJECT ; } LIBSEDML_EXTERN int SedDocument_addDataDescription ( SedDocument_t * sd , SedDataDescription_t * sdd ) { return ( sd != NULL ) ? sd -> addDataDescription ( sdd ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_createDataDescription ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createDataDescription ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfDataDescriptions ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfDataDescriptions ( ) : NULL ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_getDataDescription ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getDataDescription ( n ) : NULL ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_getDataDescriptionById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getDataDescription ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumDataDescriptions ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumDataDescriptions ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_removeDataDescription ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeDataDescription ( n ) : NULL ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_removeDataDescriptionById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeDataDescription ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_addSimulation ( SedDocument_t * sd , SedSimulation_t * ss ) { return ( sd != NULL ) ? sd -> addSimulation ( ss ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedUniformTimeCour@@ se_t * SedDocument_createUniformTimeCourse ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createUniformTimeCourse ( ) : NULL ; } LIBSEDML_EXTERN SedOne@@ Step_t * SedDocument_createOneStep ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createOneStep ( ) : NULL ; } LIBSEDML_EXTERN SedSteady@@ State_t * SedDocument_createSteadyState ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createSteadyState ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfSimulations ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfSimulations ( ) : NULL ; } LIBSEDML_EXTERN SedSimulation_t * SedDocument_getSimulation ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getSimulation ( n ) : NULL ; } LIBSEDML_EXTERN SedSimulation_t * SedDocument_getSimulationById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getSimulation ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumSimulations ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumSimulations ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedSimulation_t * SedDocument_removeSimulation ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeSimulation ( n ) : NULL ; } LIBSEDML_EXTERN SedSimulation_t * SedDocument_removeSimulationById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeSimulation ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_addModel ( SedDocument_t * sd , SedModel_t * sm ) { return ( sd != NULL ) ? sd -> addModel ( sm ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedModel_t * SedDocument_createModel ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createModel ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfModels ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfModels ( ) : NULL ; } LIBSEDML_EXTERN SedModel_t * SedDocument_getModel ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getModel ( n ) : NULL ; } LIBSEDML_EXTERN SedModel_t * SedDocument_getModelById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getModel ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumModels ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumModels ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedModel_t * SedDocument_removeModel ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeModel ( n ) : NULL ; } LIBSEDML_EXTERN SedModel_t * SedDocument_removeModelById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeModel ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_addTask ( SedDocument_t * sd , SedTask_t * st ) { return ( sd != NULL ) ? sd -> addTask ( st ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedTask_t * SedDocument_createTask ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createTask ( ) : NULL ; } LIBSEDML_EXTERN SedRepeated@@ Task_t * SedDocument_createRepeatedTask ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createRepeatedTask ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfTasks ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfTasks ( ) : NULL ; } LIBSEDML_EXTERN SedTask_t * SedDocument_getTask ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getTask ( n ) : NULL ; } LIBSEDML_EXTERN SedTask_t * SedDocument_getTaskById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getTask ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumTasks ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumTasks ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedTask_t * SedDocument_removeTask ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeTask ( n ) : NULL ; } LIBSEDML_EXTERN SedTask_t * SedDocument_removeTaskById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeTask ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_addDataGenerator ( SedDocument_t * sd , SedDataGenerator_t * sdg ) { return ( sd != NULL ) ? sd -> addDataGenerator ( sdg ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_createDataGenerator ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createDataGenerator ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfDataGenerators ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfDataGenerators ( ) : NULL ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_getDataGenerator ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getDataGenerator ( n ) : NULL ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_getDataGeneratorById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getDataGenerator ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumDataGenerators ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumDataGenerators ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_removeDataGenerator ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeDataGenerator ( n ) : NULL ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_removeDataGeneratorById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeDataGenerator ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_addOutput ( SedDocument_t * sd , SedOutput_t * so ) { return ( sd != NULL ) ? sd -> addOutput ( so ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedReport@@ _t * SedDocument_createReport ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createReport ( ) : NULL ; } LIBSEDML_EXTERN SedPlot2D_t * SedDocument_createPlot2D ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createPlot2D ( ) : NULL ; } LIBSEDML_EXTERN SedPlot3D_t * SedDocument_createPlot3D ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createPlot3D ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOfOutputs ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfOutputs ( ) : NULL ; } LIBSEDML_EXTERN SedOutput_t * SedDocument_getOutput ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getOutput ( n ) : NULL ; } LIBSEDML_EXTERN SedOutput_t * SedDocument_getOutputById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getOutput ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNumOutputs ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumOutputs ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedOutput_t * SedDocument_removeOutput ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeOutput ( n ) : NULL ; } LIBSEDML_EXTERN SedOutput_t * SedDocument_removeOutputById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeOutput ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_hasRequiredAttributes ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> hasRequiredAttributes ( ) ) : 0 ; } LIBSEDML_EXTERN int SedDocument_hasRequiredElements ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> hasRequiredElements ( ) ) : 0 ; } LIBSEDML_CPP_NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="wilton@@ lazary/arangodb/tree/master/3rdParty/boost/1.61.0/libs/@@ math/test/compile_@@ test/sf_@@ hypot_incl@@ _test.cpp"> # include < boost / math / special_functions / hypot . hpp > # include " test _ compile _ result . hpp " void compile_and_link_@@ test ( ) { check_result < float > ( boost :: math :: hypot < float > ( f , f ) ) ; check_result < double > ( boost :: math :: hypot < double > ( d , d ) ) ; # ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS check_result < long double > ( boost :: math :: hypot < long double > ( l , l ) ) ; # endif } </DOCUMENT>
<DOCUMENT_ID="pd@@ uuubs/@@ render3D/tree/master/lib@@ s/eig@@ en/test/geo_transformations.cpp"> # include " main . h " # include < Eigen / Geometry > # include < Eigen / LU > # include < Eigen / SVD > template < typename T > Matrix < T , 2 , 1 > angleToVec ( T a ) { return Matrix < T , 2 , 1 > ( std :: cos ( a ) , std :: sin ( a ) ) ; } template < typename T > EIGEN_DON@@ T_INLINE void dont_over_optimize ( T & x ) { volatile typename T :: Scalar tmp = x ( 0 ) ; x ( 0 ) = tmp ; } template < typename Scalar , int Mode , int Options > void non_projective_only ( ) { typedef Matrix < Scalar , 3 , 1 > Vector3 ; typedef Quaternion < Scalar > Quaternionx ; typedef AngleAxis < Scalar > AngleAxisx ; typedef Transform < Scalar , 3 , Mode , Options > Transform3 ; typedef DiagonalMatrix < Scalar , 3 > AlignedScaling3 ; typedef Translation < Scalar , 3 > Translation3 ; Vector3 v0 = Vector3 :: Random ( ) , v1 = Vector3 :: Random ( ) ; Transform3 t0 , t1 , t2 ; Scalar a = internal :: random < Scalar > ( - Scalar ( EIGEN_PI ) , Scalar ( EIGEN_PI ) ) ; Quaternionx q1 , q2 ; q1 = AngleAxisx ( a , v0 . normalized ( ) ) ; t0 = Transform3 :: Identity ( ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , Transform3 :: MatrixType :: Identity ( ) ) ; t0 . linear ( ) = q1 . toRotationMatrix ( ) ; v0 << 50 , 2 , 1 ; t0 . scale ( v0 ) ; VERIFY_IS_APPROX ( ( t0 * Vector3 ( 1 , 0 , 0 ) ) . template head < 3 > ( ) . norm ( ) , v0 . x ( ) ) ; t0 . setIdentity ( ) ; t1 . setIdentity ( ) ; v1 << 1 , 2 , 3 ; t0 . linear ( ) = q1 . toRotationMatrix ( ) ; t0 . pretranslate ( v0 ) ; t0 . scale ( v1 ) ; t1 . linear ( ) = q1 . conjugate ( ) . toRotationMatrix ( ) ; t1 . prescale ( v1 . cwiseInverse ( ) ) ; t1 . translate ( - v0 ) ; VERIFY ( ( t0 * t1 ) . matrix ( ) . isIdentity ( test_precision < Scalar > ( ) ) ) ; t1 . fromPositionOrientationScale ( v0 , q1 , v1 ) ; VERIFY_IS_APPROX ( t1 . matrix ( ) , t0 . matrix ( ) ) ; VERIFY_IS_APPROX ( t1 * v1 , t0 * v1 ) ; t0 . setIdentity ( ) ; t0 . translate ( v0 ) ; VERIFY_IS_APPROX ( ( t0 * v1 ) . template head < 3 > ( ) , Translation3 ( v0 ) * v1 ) ; t0 . setIdentity ( ) ; t0 . scale ( v0 ) ; VERIFY_IS_APPROX ( ( t0 * v1 ) . template head < 3 > ( ) , AlignedScaling3 ( v0 ) * v1 ) ; } template < typename Scalar , int Mode , int Options > void transformations ( ) { using std :: cos ; using std :: abs ; typedef Matrix < Scalar , 3 , 3 > Matrix3 ; typedef Matrix < Scalar , 4 , 4 > Matrix4 ; typedef Matrix < Scalar , 2 , 1 > Vector2 ; typedef Matrix < Scalar , 3 , 1 > Vector3 ; typedef Matrix < Scalar , 4 , 1 > Vector4 ; typedef Quaternion < Scalar > Quaternionx ; typedef AngleAxis < Scalar > AngleAxisx ; typedef Transform < Scalar , 2 , Mode , Options > Transform2 ; typedef Transform < Scalar , 3 , Mode , Options > Transform3 ; typedef typename Transform3 :: MatrixType MatrixType ; typedef DiagonalMatrix < Scalar , 3 > AlignedScaling3 ; typedef Translation < Scalar , 2 > Translation2 ; typedef Translation < Scalar , 3 > Translation3 ; Vector3 v0 = Vector3 :: Random ( ) , v1 = Vector3 :: Random ( ) ; Matrix3 matrot1 , m ; Scalar a = internal :: random < Scalar > ( - Scalar ( EIGEN_PI ) , Scalar ( EIGEN_PI ) ) ; Scalar s0 = internal :: random < Scalar > ( ) , s1 = internal :: random < Scalar > ( ) ; while ( v0 . norm ( ) < test_precision < Scalar > ( ) ) v0 = Vector3 :: Random ( ) ; while ( v1 . norm ( ) < test_precision < Scalar > ( ) ) v1 = Vector3 :: Random ( ) ; VERIFY_IS_APPROX ( v0 , AngleAxisx ( a , v0 . normalized ( ) ) * v0 ) ; VERIFY_IS_APPROX ( - v0 , AngleAxisx ( Scalar ( EIGEN_PI ) , v0 . unitOrthogonal ( ) ) * v0 ) ; if ( abs ( cos ( a ) ) > test_precision < Scalar > ( ) ) { VERIFY_IS_APPROX ( cos ( a ) * v0 . squaredNor@@ m ( ) , v0 . dot ( AngleAxisx ( a , v0 . unitOrthogonal ( ) ) * v0 ) ) ; } m = AngleAxisx ( a , v0 . normalized ( ) ) . toRotationMatrix ( ) . adjoint ( ) ; VERIFY_IS_APPROX ( Matrix3 :: Identity ( ) , m * AngleAxisx ( a , v0 . normalized ( ) ) ) ; VERIFY_IS_APPROX ( Matrix3 :: Identity ( ) , AngleAxisx ( a , v0 . normalized ( ) ) * m ) ; Quaternionx q1 , q2 ; q1 = AngleAxisx ( a , v0 . normalized ( ) ) ; q2 = AngleAxisx ( a , v1 . normalized ( ) ) ; matrot1 = AngleAxisx ( Scalar ( 0.1 ) , Vector3 :: UnitX ( ) ) * AngleAxisx ( Scalar ( 0.2 ) , Vector3 :: UnitY ( ) ) * AngleAxisx ( Scalar ( 0.3 ) , Vector3 :: UnitZ ( ) ) ; VERIFY_IS_APPROX ( matrot1 * v1 , AngleAxisx ( Scalar ( 0.1 ) , Vector3 ( 1 , 0 , 0 ) ) . toRotationMatrix ( ) * ( AngleAxisx ( Scalar ( 0.2 ) , Vector3 ( 0 , 1 , 0 ) ) . toRotationMatrix ( ) * ( AngleAxisx ( Scalar ( 0.3 ) , Vector3 ( 0 , 0 , 1 ) ) . toRotationMatrix ( ) * v1 ) ) ) ; AngleAxisx aa = AngleAxisx ( q1 ) ; VERIFY_IS_APPROX ( q1 * v1 , Quaternionx ( aa ) * v1 ) ; if ( ( abs ( aa . angle ( ) ) > test_precision < Scalar > ( ) ) && ( abs ( aa . axis ( ) . dot ( v1 . normalized ( ) ) ) < ( Scalar ( 1 ) - Scalar ( 4 ) * test_precision < Scalar > ( ) ) ) ) { VERIFY ( ! ( q1 * v1 ) . isApprox ( Quaternionx ( AngleAxisx ( aa . angle ( ) * 2 , aa . axis ( ) ) ) * v1 ) ) ; } aa . fromRotationMatrix ( aa . toRotationMatrix ( ) ) ; VERIFY_IS_APPROX ( q1 * v1 , Quaternionx ( aa ) * v1 ) ; if ( ( abs ( aa . angle ( ) ) > test_precision < Scalar > ( ) ) && ( abs ( aa . axis ( ) . dot ( v1 . normalized ( ) ) ) < ( Scalar ( 1 ) - Scalar ( 4 ) * test_precision < Scalar > ( ) ) ) ) { VERIFY ( ! ( q1 * v1 ) . isApprox ( Quaternionx ( AngleAxisx ( aa . angle ( ) * 2 , aa . axis ( ) ) ) * v1 ) ) ; } VERIFY_IS_APPROX ( AngleAxisx ( a , v1 . normalized ( ) ) . toRotationMatrix ( ) , Quaternionx ( AngleAxisx ( a , v1 . normalized ( ) ) ) . toRotationMatrix ( ) ) ; AngleAxisx aa1 ; m = q1 . toRotationMatrix ( ) ; aa1 = m ; VERIFY_IS_APPROX ( AngleAxisx ( m ) . toRotationMatrix ( ) , Quaternionx ( m ) . toRotationMatrix ( ) ) ; a = 0 ; while ( abs ( a ) < Scalar ( 0.1 ) ) a = internal :: random < Scalar > ( - Scalar ( 0.4 ) * Scalar ( EIGEN_PI ) , Scalar ( 0.4 ) * Scalar ( EIGEN_PI ) ) ; q1 = AngleAxisx ( a , v0 . normalized ( ) ) ; Transform3 t0 , t1 , t2 ; t0 . setIdentity ( ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , Transform3 :: MatrixType :: Identity ( ) ) ; t0 . matrix ( ) . setZero ( ) ; t0 = Transform3 :: Identity ( ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , Transform3 :: MatrixType :: Identity ( ) ) ; t0 . setIdentity ( ) ; t1 . setIdentity ( ) ; v1 << 1 , 2 , 3 ; t0 . linear ( ) = q1 . toRotationMatrix ( ) ; t0 . pretranslate ( v0 ) ; t0 . scale ( v1 ) ; t1 . linear ( ) = q1 . conjugate ( ) . toRotationMatrix ( ) ; t1 . prescale ( v1 . cwiseInverse ( ) ) ; t1 . translate ( - v0 ) ; VERIFY ( ( t0 * t1 ) . matrix ( ) . isIdentity ( test_precision < Scalar > ( ) ) ) ; t1 . fromPositionOrientationScale ( v0 , q1 , v1 ) ; VERIFY_IS_APPROX ( t1 . matrix ( ) , t0 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . scale ( v0 ) . rotate ( q1 . toRotationMatrix ( ) ) ; t1 . setIdentity ( ) ; t1 . scale ( v0 ) . rotate ( q1 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . scale ( v0 ) . rotate ( AngleAxisx ( q1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; VERIFY_IS_APPROX ( t0 . scale ( a ) . matrix ( ) , t1 . scale ( Vector3 :: Constant ( a ) ) . matrix ( ) ) ; VERIFY_IS_APPROX ( t0 . prescale ( a ) . matrix ( ) , t1 . prescale ( Vector3 :: Constant ( a ) ) . matrix ( ) ) ; Matrix3 mat3 = Matrix3 :: Random ( ) ; Matrix4 mat4 ; mat4 << mat3 , Vector3 :: Zero ( ) , Vector4 :: Zero ( ) . transpose ( ) ; Transform3 tmat3 ( mat3 ) , tmat4 ( mat4 ) ; if ( Mode != int ( AffineCompact ) ) tmat4 . matrix ( ) ( 3 , 3 ) = Scalar ( 1 ) ; VERIFY_IS_APPROX ( tmat3 . matrix ( ) , tmat4 . matrix ( ) ) ; Scalar a3 = internal :: random < Scalar > ( - Scalar ( EIGEN_PI ) , Scalar ( EIGEN_PI ) ) ; Vector3 v3 = Vector3 :: Random ( ) . normalized ( ) ; AngleAxisx aa3 ( a3 , v3 ) ; Transform3 t3 ( aa3 ) ; Transform3 t4 ; t4 = aa3 ; VERIFY_IS_APPROX ( t3 . matrix ( ) , t4 . matrix ( ) ) ; t4 . rotate ( AngleAxisx ( - a3 , v3 ) ) ; VERIFY_IS_APPROX ( t4 . matrix ( ) , MatrixType :: Identity ( ) ) ; t4 *= aa3 ; VERIFY_IS_APPROX ( t3 . matrix ( ) , t4 . matrix ( ) ) ; do { v3 = Vector3 :: Random ( ) ; dont_over_optimize ( v3 ) ; } while ( v3 . cwiseAbs ( ) . minCoe@@ ff ( ) < NumTraits < Scalar > :: epsilon ( ) ) ; Translation3 tv3 ( v3 ) ; Transform3 t5 ( tv3 ) ; t4 = tv3 ; VERIFY_IS_APPROX ( t5 . matrix ( ) , t4 . matrix ( ) ) ; t4 . translate ( ( - v3 ) . eval ( ) ) ; VERIFY_IS_APPROX ( t4 . matrix ( ) , MatrixType :: Identity ( ) ) ; t4 *= tv3 ; VERIFY_IS_APPROX ( t5 . matrix ( ) , t4 . matrix ( ) ) ; AlignedScaling3 sv3 ( v3 ) ; Transform3 t6 ( sv3 ) ; t4 = sv3 ; VERIFY_IS_APPROX ( t6 . matrix ( ) , t4 . matrix ( ) ) ; t4 . scale ( v3 . cwiseInverse ( ) ) ; VERIFY_IS_APPROX ( t4 . matrix ( ) , MatrixType :: Identity ( ) ) ; t4 *= sv3 ; VERIFY_IS_APPROX ( t6 . matrix ( ) , t4 . matrix ( ) ) ; VERIFY_IS_APPROX ( ( t3 . matrix ( ) * t4 ) . matrix ( ) , ( t3 * t4 ) . matrix ( ) ) ; VERIFY_IS_APPROX ( ( ( t3 * t4 ) * t5 ) . matrix ( ) , ( t3 * ( t4 * t5 ) ) . matrix ( ) ) ; t5 = t4 ; t5 = t5 * t5 ; VERIFY_IS_APPROX ( t5 , t4 * t4 ) ; Transform2 t20 , t21 ; Vector2 v20 = Vector2 :: Random ( ) ; Vector2 v21 = Vector2 :: Random ( ) ; for ( int k = 0 ; k < 2 ; ++ k ) if ( abs ( v21 [ k ] ) < Scalar ( 1e - 3 ) ) v21 [ k ] = Scalar ( 1e - 3 ) ; t21 . setIdentity ( ) ; t21 . linear ( ) = Rotation2D < Scalar > ( a ) . toRotationMatrix ( ) ; VERIFY_IS_APPROX ( t20 . fromPositionOrientationScale ( v20 , a , v21 ) . matrix ( ) , t21 . pretranslate ( v20 ) . scale ( v21 ) . matrix ( ) ) ; t21 . setIdentity ( ) ; t21 . linear ( ) = Rotation2D < Scalar > ( - a ) . toRotationMatrix ( ) ; VERIFY ( ( t20 . fromPositionOrientationScale ( v20 , a , v21 ) * ( t21 . prescale ( v21 . cwiseInverse ( ) ) . translate ( - v20 ) ) ) . matrix ( ) . isIdentity ( test_precision < Scalar > ( ) ) ) ; t0 . setIdentity ( ) ; t0 . rotate ( q1 ) . scale ( v0 ) . translate ( v0 ) ; t1 = ( Matrix3 ( q1 ) * AlignedScaling3 ( v0 ) ) * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = ( Matrix3 ( q1 ) * Eigen :: Scaling ( v0 ) ) * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = ( q1 * Eigen :: Scaling ( v0 ) ) * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = Matrix3 ( q1 ) * ( AlignedScaling3 ( v0 ) * Translation3 ( v0 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . scale ( s0 ) . translate ( v0 ) ; t1 = Eigen :: Scaling ( s0 ) * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . prescale ( s0 ) ; t1 = Eigen :: Scaling ( s0 ) * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 = t3 ; t0 . scale ( s0 ) ; t1 = t3 * Eigen :: Scaling ( s0 , s0 , s0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . prescale ( s0 ) ; t1 = Eigen :: Scaling ( s0 , s0 , s0 ) * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 = t3 ; t0 . scale ( s0 ) ; t1 = t3 * Eigen :: Scaling ( s0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . prescale ( s0 ) ; t1 = Eigen :: Scaling ( s0 ) * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . prerotate ( q1 ) . prescale ( v0 ) . pretranslate ( v0 ) ; t1 = ( Translation3 ( v0 ) * AlignedScaling3 ( v0 ) ) * Transform3 ( q1 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = Translation3 ( v0 ) * ( AlignedScaling3 ( v0 ) * Transform3 ( q1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . scale ( v0 ) . translate ( v0 ) . rotate ( q1 ) ; t1 = AlignedScaling3 ( v0 ) * ( Translation3 ( v0 ) * Transform3 ( q1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . scale ( v0 ) ; t1 *= AlignedScaling3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t1 = AlignedScaling3 ( v0 ) * ( Translation3 ( v0 ) * Transform3 ( q1 ) ) ; t1 = t1 * v0 . asDiagonal ( ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . translate ( v0 ) ; t1 = t1 * Translation3 ( v0 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . pretranslate ( v0 ) ; t1 = Translation3 ( v0 ) * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . rotate ( q1 ) ; t1 = t1 * q1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . translate ( v1 ) . rotate ( q1 ) ; t1 = t1 * ( Translation3 ( v1 ) * q1 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . scale ( v1 ) . rotate ( q1 ) ; t1 = t1 * ( AlignedScaling3 ( v1 ) * q1 ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . prerotate ( q1 ) ; t1 = q1 * t1 ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . rotate ( q1 ) . translate ( v1 ) ; t1 = t1 * ( q1 * Translation3 ( v1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . rotate ( q1 ) . scale ( v1 ) ; t1 = t1 * ( q1 * AlignedScaling3 ( v1 ) ) ; VERIFY_IS_APPROX ( t0 . matrix ( ) , t1 . matrix ( ) ) ; t0 . setIdentity ( ) ; t0 . translate ( v0 ) ; do { t0 . linear ( ) . setRandom ( ) ; } while ( t0 . linear ( ) . jacobiSv@@ d ( ) . singular@@ Values ( ) ( 2 ) < test_precision < Scalar > ( ) ) ; Matrix4 t044 = Matrix4 :: Zero ( ) ; t044 ( 3 , 3 ) = 1 ; t044 . block ( 0 , 0 , t0 . matrix ( ) . rows ( ) , 4 ) = t0 . matrix ( ) ; VERIFY_IS_APPROX ( t0 . inverse ( Affine ) . matrix ( ) , t044 . inverse ( ) . block ( 0 , 0 , t0 . matrix ( ) . rows ( ) , 4 ) ) ; t0 . setIdentity ( ) ; t0 . translate ( v0 ) . rotate ( q1 ) ; t044 = Matrix4 :: Zero ( ) ; t044 ( 3 , 3 ) = 1 ; t044 . block ( 0 , 0 , t0 . matrix ( ) . rows ( ) , 4 ) = t0 . matrix ( ) ; VERIFY_IS_APPROX ( t0 . inverse ( Isometry ) . matrix ( ) , t044 . inverse ( ) . block ( 0 , 0 , t0 . matrix ( ) . rows ( ) , 4 ) ) ; Matrix3 mat_rotation , mat_scaling ; t0 . setIdentity ( ) ; t0 . translate ( v0 ) . rotate ( q1 ) . scale ( v1 ) ; t0 . computeRotationScaling ( & mat_rotation , & mat_scaling ) ; VERIFY_IS_APPROX ( t0 . linear ( ) , mat_rotation * mat_scaling ) ; VERIFY_IS_APPROX ( mat_rotation * mat_rotation . adjoint ( ) , Matrix3 :: Identity ( ) ) ; VERIFY_IS_APPROX ( mat_rotation . determinant ( ) , Scalar ( 1 ) ) ; t0 . computeScaling@@ Rotation ( & mat_scaling , & mat_rotation ) ; VERIFY_IS_APPROX ( t0 . linear ( ) , mat_scaling * mat_rotation ) ; VERIFY_IS_APPROX ( mat_rotation * mat_rotation . adjoint ( ) , Matrix3 :: Identity ( ) ) ; VERIFY_IS_APPROX ( mat_rotation . determinant ( ) , Scalar ( 1 ) ) ; Transform < float , 3 , Mode > t1f = t1 . template cast < float > ( ) ; VERIFY_IS_APPROX ( t1f . template cast < Scalar > ( ) , t1 ) ; Transform < double , 3 , Mode > t1d = t1 . template cast < double > ( ) ; VERIFY_IS_APPROX ( t1d . template cast < Scalar > ( ) , t1 ) ; Translation3 tr1 ( v0 ) ; Translation < float , 3 > tr1f = tr1 . template cast < float > ( ) ; VERIFY_IS_APPROX ( tr1f . template cast < Scalar > ( ) , tr1 ) ; Translation < double , 3 > tr1d = tr1 . template cast < double > ( ) ; VERIFY_IS_APPROX ( tr1d . template cast < Scalar > ( ) , tr1 ) ; AngleAxis < float > aa1f = aa1 . template cast < float > ( ) ; VERIFY_IS_APPROX ( aa1f . template cast < Scalar > ( ) , aa1 ) ; AngleAxis < double > aa1d = aa1 . template cast < double > ( ) ; VERIFY_IS_APPROX ( aa1d . template cast < Scalar > ( ) , aa1 ) ; Rotation2D < Scalar > r2d1 ( internal :: random < Scalar > ( ) ) ; Rotation2D < float > r2d1f = r2d1 . template cast < float > ( ) ; VERIFY_IS_APPROX ( r2d1f . template cast < Scalar > ( ) , r2d1 ) ; Rotation2D < double > r2d1d = r2d1 . template cast < double > ( ) ; VERIFY_IS_APPROX ( r2d1d . template cast < Scalar > ( ) , r2d1 ) ; for ( int k = 0 ; k < 100 ; ++ k ) { Scalar angle = internal :: random < Scalar > ( - 100 , 100 ) ; Rotation2D < Scalar > rot2 ( angle ) ; VERIFY ( rot2 . smallestPositiveAngle ( ) >= 0 ) ; VERIFY ( rot2 . smallestPositiveAngle ( ) <= Scalar ( 2 ) * Scalar ( EIGEN_PI ) ) ; VERIFY_IS_APPROX ( angleToVec ( rot2 . smallestPositiveAngle ( ) ) , angleToVec ( rot2 . angle ( ) ) ) ; VERIFY ( rot2 . smallestAngle ( ) >= - Scalar ( EIGEN_PI ) ) ; VERIFY ( rot2 . smallestAngle ( ) <= Scalar ( EIGEN_PI ) ) ; VERIFY_IS_APPROX ( angleToVec ( rot2 . smallestAngle ( ) ) , angleToVec ( rot2 . angle ( ) ) ) ; Matrix < Scalar , 2 , 2 > rot2_as_mat ( rot2 ) ; Rotation2D < Scalar > rot3 ( rot2_as_mat ) ; VERIFY_IS_APPROX ( angleToVec ( rot2 . smallestAngle ( ) ) , angleToVec ( rot3 . angle ( ) ) ) ; } s0 = internal :: random < Scalar > ( - 100 , 100 ) ; s1 = internal :: random < Scalar > ( - 100 , 100 ) ; Rotation2D < Scalar > R0 ( s0 ) , R1 ( s1 ) ; t20 = Translation2 ( v20 ) * ( R0 * Eigen :: Scaling ( s0 ) ) ; t21 = Translation2 ( v20 ) * R0 * Eigen :: Scaling ( s0 ) ; VERIFY_IS_APPROX ( t20 , t21 ) ; t20 = Translation2 ( v20 ) * ( R0 * R0 . inverse ( ) * Eigen :: Scaling ( s0 ) ) ; t21 = Translation2 ( v20 ) * Eigen :: Scaling ( s0 ) ; VERIFY_IS_APPROX ( t20 , t21 ) ; VERIFY_IS_APPROX ( s0 , ( R0 . slerp ( 0 , R1 ) ) . angle ( ) ) ; VERIFY_IS_APPROX ( angleToVec ( R1 . smallestPositiveAngle ( ) ) , angleToVec ( ( R0 . slerp ( 1 , R1 ) ) . smallestPositiveAngle ( ) ) ) ; VERIFY_IS_APPROX ( R0 . smallestPositiveAngle ( ) , ( R0 . slerp ( 0.5 , R0 ) ) . smallestPositiveAngle ( ) ) ; if ( std :: cos ( s0 ) > 0 ) VERIFY_IS_@@ MUCH_SMALL@@ ER_THAN ( ( R0 . slerp ( 0.5 , R0 . inverse ( ) ) ) . smallestAngle ( ) , Scalar ( 1 ) ) ; else VERIFY_IS_APPROX ( Scalar ( EIGEN_PI ) , ( R0 . slerp ( 0.5 , R0 . inverse ( ) ) ) . smallestPositiveAngle ( ) ) ; Scalar l = 0 ; int path_steps = 100 ; for ( int k = 0 ; k < path_steps ; ++ k ) { Scalar a1 = R0 . slerp ( Scalar ( k ) / Scalar ( path_steps ) , R1 ) . angle ( ) ; Scalar a2 = R0 . slerp ( Scalar ( k + 1 ) / Scalar ( path_steps ) , R1 ) . angle ( ) ; l += std :: abs ( a2 - a1 ) ; } VERIFY ( l <= Scalar ( EIGEN_PI ) * ( Scalar ( 1 ) + NumTraits < Scalar > :: epsilon ( ) * Scalar ( path_steps / 2 ) ) ) ; { Rotation2D < Scalar > r1 ; r1 = Rotation2D < Scalar > ( s0 ) ; VERIFY_IS_APPROX ( r1 . angle ( ) , s0 ) ; Rotation2D < Scalar > r2 ( r1 ) ; VERIFY_IS_APPROX ( r2 . angle ( ) , s0 ) ; } { Transform3 t32 ( Matrix4 :: Random ( ) ) , t33 , t34 ; t34 = t33 = t32 ; t32 . scale ( v0 ) ; t33 *= AlignedScaling3 ( v0 ) ; VERIFY_IS_APPROX ( t32 . matrix ( ) , t33 . matrix ( ) ) ; t33 = t34 * AlignedScaling3 ( v0 ) ; VERIFY_IS_APPROX ( t32 . matrix ( ) , t33 . matrix ( ) ) ; } } template < typename A1 , typename A2 , typename P , typename Q , typename V , typename H > void transform_associativity_left ( const A1 & a1 , const A2 & a2 , const P & p , const Q & q , const V & v , const H & h ) { VERIFY_IS_APPROX ( q * ( a1 * v ) , ( q * a1 ) * v ) ; VERIFY_IS_APPROX ( q * ( a2 * v ) , ( q * a2 ) * v ) ; VERIFY_IS_APPROX ( q * ( p * h ) . hnormalized ( ) , ( ( q * p ) * h ) . hnormalized ( ) ) ; } template < typename A1 , typename A2 , typename P , typename Q , typename V , typename H > void transform_associativity2 ( const A1 & a1 , const A2 & a2 , const P & p , const Q & q , const V & v , const H & h ) { VERIFY_IS_APPROX ( a1 * ( q * v ) , ( a1 * q ) * v ) ; VERIFY_IS_APPROX ( a2 * ( q * v ) , ( a2 * q ) * v ) ; VERIFY_IS_APPROX ( p * ( q * v ) . homogeneous ( ) , ( p * q ) * v . homogeneous ( ) ) ; transform_associativity_left ( a1 , a2 , p , q , v , h ) ; } template < typename Scalar , int Dim , int Options , typename RotationType > void transform_associativity ( const RotationType & R ) { typedef Matrix < Scalar , Dim , 1 > VectorType ; typedef Matrix < Scalar , Dim + 1 , 1 > HVectorType ; typedef Matrix < Scalar , Dim , Dim > LinearType ; typedef Matrix < Scalar , Dim + 1 , Dim + 1 > MatrixType ; typedef Transform < Scalar , Dim , AffineCompact , Options > AffineCompactType ; typedef Transform < Scalar , Dim , Affine , Options > AffineType ; typedef Transform < Scalar , Dim , Projective , Options > ProjectiveType ; typedef DiagonalMatrix < Scalar , Dim > ScalingType ; typedef Translation < Scalar , Dim > TranslationType ; AffineCompactType A1c ; A1c . matrix ( ) . setRandom ( ) ; AffineCompactType A2c ; A2c . matrix ( ) . setRandom ( ) ; AffineType A1 ( A1c ) ; AffineType A2 ( A2c ) ; ProjectiveType P1 ; P1 . matrix ( ) . setRandom ( ) ; VectorType v1 = VectorType :: Random ( ) ; VectorType v2 = VectorType :: Random ( ) ; HVectorType h1 = HVectorType :: Random ( ) ; Scalar s1 = internal :: random < Scalar > ( ) ; LinearType L = LinearType :: Random ( ) ; MatrixType M = MatrixType :: Random ( ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , A2 , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , A2c , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , v1 . asDiagonal ( ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , ScalingType ( v1 ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , Scaling ( v1 ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , Scaling ( s1 ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , TranslationType ( v1 ) , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity_left ( A1c , A1 , P1 , L , v2 , h1 ) ) ; CALL_SUBTEST ( transform_associativity2 ( A1c , A1 , P1 , R , v2 , h1 ) ) ; VERIFY_IS_APPROX ( A1 * ( M * h1 ) , ( A1 * M ) * h1 ) ; VERIFY_IS_APPROX ( A1c * ( M * h1 ) , ( A1c * M ) * h1 ) ; VERIFY_IS_APPROX ( P1 * ( M * h1 ) , ( P1 * M ) * h1 ) ; VERIFY_IS_APPROX ( M * ( A1 * h1 ) , ( M * A1 ) * h1 ) ; VERIFY_IS_APPROX ( M * ( A1c * h1 ) , ( M * A1c ) * h1 ) ; VERIFY_IS_APPROX ( M * ( P1 * h1 ) , ( ( M * P1 ) * h1 ) ) ; } template < typename Scalar > void transform_alignment ( ) { typedef Transform < Scalar , 3 , Projective , AutoAlign > Projective3a ; typedef Transform < Scalar , 3 , Projective , DontAlign > Projective3u ; EIGEN_ALIGN_MAX Scalar array1 [ 16 ] ; EIGEN_ALIGN_MAX Scalar array2 [ 16 ] ; EIGEN_ALIGN_MAX Scalar array3 [ 16 + 1 ] ; Scalar * array3u = array3 + 1 ; Projective3a * p1 = :: new ( reinterpret_cast < void * > ( array1 ) ) Projective3a ; Projective3u * p2 = :: new ( reinterpret_cast < void * > ( array2 ) ) Projective3u ; Projective3u * p3 = :: new ( reinterpret_cast < void * > ( array3u ) ) Projective3u ; p1 -> matrix ( ) . setRandom ( ) ; * p2 = * p1 ; * p3 = * p1 ; VERIFY_IS_APPROX ( p1 -> matrix ( ) , p2 -> matrix ( ) ) ; VERIFY_IS_APPROX ( p1 -> matrix ( ) , p3 -> matrix ( ) ) ; VERIFY_IS_APPROX ( ( * p1 ) * ( * p1 ) , ( * p2 ) * ( * p3 ) ) ; # if defined ( EIGEN_VEC@@ TORIZE ) && EIGEN_MAX_STAT@@ IC_ALIGN@@ _BYTES > 0 if ( internal :: packet_traits < Scalar > :: Vectorizable ) VERIFY_RA@@ ISES_@@ ASSERT ( ( :: new ( reinterpret_cast < void * > ( array3u ) ) Projective3a ) ) ; # endif } template < typename Scalar , int Dim , int Options > void transform_products ( ) { typedef Matrix < Scalar , Dim + 1 , Dim + 1 > Mat ; typedef Transform < Scalar , Dim , Projective , Options > Proj ; typedef Transform < Scalar , Dim , Affine , Options > Aff ; typedef Transform < Scalar , Dim , AffineCompact , Options > AffC ; Proj p ; p . matrix ( ) . setRandom ( ) ; Aff a ; a . linear ( ) . setRandom ( ) ; a . translation ( ) . setRandom ( ) ; AffC ac = a ; Mat p_m ( p . matrix ( ) ) , a_m ( a . matrix ( ) ) ; VERIFY_IS_APPROX ( ( p * p ) . matrix ( ) , p_m * p_m ) ; VERIFY_IS_APPROX ( ( a * a ) . matrix ( ) , a_m * a_m ) ; VERIFY_IS_APPROX ( ( p * a ) . matrix ( ) , p_m * a_m ) ; VERIFY_IS_APPROX ( ( a * p ) . matrix ( ) , a_m * p_m ) ; VERIFY_IS_APPROX ( ( ac * a ) . matrix ( ) , a_m * a_m ) ; VERIFY_IS_APPROX ( ( a * ac ) . matrix ( ) , a_m * a_m ) ; VERIFY_IS_APPROX ( ( p * ac ) . matrix ( ) , p_m * a_m ) ; VERIFY_IS_APPROX ( ( ac * p ) . matrix ( ) , a_m * p_m ) ; } void test_geo_@@ transformations ( ) { for ( int i = 0 ; i < g_repeat ; i ++ ) { CALL_SUBTEST_1 ( ( transformations < double , Affine , AutoAlign > ( ) ) ) ; CALL_SUBTEST_1 ( ( non_projective_only < double , Affine , AutoAlign > ( ) ) ) ; CALL_SUBTEST_2 ( ( transformations < float , AffineCompact , AutoAlign > ( ) ) ) ; CALL_SUBTEST_2 ( ( non_projective_only < float , AffineCompact , AutoAlign > ( ) ) ) ; CALL_SUBTEST_2 ( ( transform_alignment < float > ( ) ) ) ; CALL_SUBTEST_3 ( ( transformations < double , Projective , AutoAlign > ( ) ) ) ; CALL_SUBTEST_3 ( ( transformations < double , Projective , DontAlign > ( ) ) ) ; CALL_SUBTEST_3 ( ( transform_alignment < double > ( ) ) ) ; CALL_SUBTEST_4 ( ( transformations < float , Affine , RowMajor | AutoAlign > ( ) ) ) ; CALL_SUBTEST_4 ( ( non_projective_only < float , Affine , RowMajor > ( ) ) ) ; CALL_SUBTEST_5 ( ( transformations < double , AffineCompact , RowMajor | AutoAlign > ( ) ) ) ; CALL_SUBTEST_5 ( ( non_projective_only < double , AffineCompact , RowMajor > ( ) ) ) ; CALL_SUBTEST_6 ( ( transformations < double , Projective , RowMajor | AutoAlign > ( ) ) ) ; CALL_SUBTEST_6 ( ( transformations < double , Projective , RowMajor | DontAlign > ( ) ) ) ; CALL_SUBTEST_7 ( ( transform_products < double , 3 , RowMajor | AutoAlign > ( ) ) ) ; CALL_SUBTEST_7 ( ( transform_products < float , 2 , AutoAlign > ( ) ) ) ; CALL_SUBTEST_8 ( ( transform_associativity < double , 2 , ColMajor > ( Rotation2D < double > ( internal :: random < double > ( ) * double ( EIGEN_PI ) ) ) ) ) ; CALL_SUBTEST_8 ( ( transform_associativity < double , 3 , ColMajor > ( Quaterniond :: UnitRandom ( ) ) ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="tw@@ alpole/sel@@ enium/tree/master/cpp@@ /iedriver/@@ CommandHandlers/@@ MaximizeWindowCommandHandler.cpp"> # include " MaximizeWindowCommandHandler . h " # include " errorcodes . h " # include " . . / Browser . h " # include " . . / IECommandExecutor . h " namespace webdriver { MaximizeWindowCommandHandler :: MaximizeWindowCommandHandler ( void ) { } MaximizeWindowCommandHandler :: ~ MaximizeWindowCommandHandler ( void ) { } void MaximizeWindowCommandHandler :: ExecuteInternal ( const IECommandExecutor & executor , const ParametersMap & command_@@ parameters , Response * response ) { int status_code = WD_SUCCESS ; BrowserHandle browser_wrapper ; status_code = executor . GetCurrentBrowser ( & browser_wrapper ) ; if ( status_code != WD_SUCCESS ) { response -> SetErrorResponse ( ERROR_NO_SU@@ CH_WINDO@@ W , " Error ▁ retrieving ▁ window " ) ; return ; } HWND window_handle = browser_wrapper -> GetTopLevelWindowHandle ( ) ; if ( ! :: IsZoom@@ ed ( window_handle ) ) { browser_wrapper -> Restore ( ) ; :: ShowWindow ( window_handle , SW_MAXIMI@@ ZE ) ; } RECT window_rect ; :: GetWindowRect ( window_handle , & window_rect ) ; Json :: Value response_value ; response_value [ " width " ] = window_rect . right - window_rect . left ; response_value [ " height " ] = window_rect . bottom - window_rect . top ; response_value [ " x " ] = window_rect . left ; response_value [ " y " ] = window_rect . top ; response -> SetSuccessResponse ( response_value ) ; } } </DOCUMENT>
<DOCUMENT_ID="ta@@ iki-okano/@@ Algorithm/tree/master/AOJ@@ /AOJ0554@@ .cpp"> # include < cstdio > int main ( ) { int sum = 0 ; for ( int i = 0 ; i < 4 ; ++ i ) { int in ; scanf ( " % d " , & in ) ; sum += in ; } printf ( " % d \n " , sum / 60 ) ; printf ( " % d \n " , sum % 60 ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="Mest@@ reLion/boinc@@ -debian/tree/master/client@@ gui/BOINCGUI@@ App.cpp"> # if defined ( __GNUG__ ) && ! defined ( __APPLE__ ) # pragma implementation " BOINCGUIApp . h " # endif # ifdef __WXMAC__ # include < Carbon / Carbon . h > # include " filesys . h " # include " util . h " # if ( defined ( SANDBOX ) && defined ( _DEBUG ) ) # include " SetupSecurity . h " # endif # include " sandbox . h " # endif # include " stdwx . h " # include " diagnostics . h " # include " network . h " # include " util . h " # include " mfile . h " # include " miofile . h " # include " parse . h " # include " idlemon . h " # include " Events . h " # include " common / wxFlatNotebook . h " # include " BOINCInternetFSHandler . h " # include " LogBOINC . h " # include " BOINCGUIApp . h " # include " SkinManager . h " # include " MainDocument . h " # include " BOINCClient@@ Manager . h " # include " BOINCTask@@ Bar . h " # include " BOINCBaseFrame . h " # include " AdvancedFrame . h " # include " DlgExitMessage . h " # include " DlgEventLog . h " # include " procinfo . h " # include " sg _ Boinc@@ SimpleFrame . h " DEFINE_EVENT_TYPE ( wxEVT_RPC_FINISHED ) IMPLEMENT_APP ( CBOINCGUIApp ) IMPLEMENT_DYNAMIC_CLASS ( CBOINCGUIApp , wxApp ) BEGIN_EVENT_TABLE ( CBOINCGUIApp , wxApp ) EVT_ACTIVATE_@@ APP ( CBOINCGUIApp :: OnActivateApp ) EVT_RPC_FINISHED ( CBOINCGUIApp :: OnRPCFinished ) END_EVENT_TABLE ( ) bool s_bSkipExitConfirmation = false ; # ifdef __WXMAC__ OSErr QuitAppleEventHandler ( const AppleEvent * appleEvt , AppleEvent * reply , UInt32 refcon ) { DescType senderType ; Size actualSize ; ProcessSerialNumber SenderPSN ; ProcessInfoRec pInfo ; FSSpec fileSpec ; OSStatus anErr ; if ( wxGetApp ( ) . IsModalDialogDisplayed ( ) ) { SysBeep ( 4 ) ; return userCance@@ ledErr ; } anErr = AEGetAttribute@@ Ptr ( appleEvt , keyAddress@@ Attr , typeProcessSerialNumber , & senderType , & SenderPSN , sizeof ( SenderPSN ) , & actualSize ) ; if ( anErr == noErr ) { pInfo . processInfoLength = sizeof ( ProcessInfoRec ) ; pInfo . processName = NULL ; pInfo . processAppSpec = & fileSpec ; anErr = GetProcessInformation ( & SenderPSN , & pInfo ) ; if ( ( pInfo . processSignature != ' dock ' ) && ( pInfo . processSignature != ' BNC ! ' ) ) { s_bSkipExitConfirmation = true ; wxGetApp ( ) . ExitMainLoop ( ) ; } } return wxGetApp ( ) . MacHandle@@ AEQuit ( ( AppleEvent * ) appleEvt , reply ) ; } # endif bool CBOINCGUIApp :: OnInit ( ) { # ifdef SANDBOX g_use_sandbox = true ; # else g_use_sandbox = false ; # endif s_bSkipExitConfirmation = false ; m_bFilterEvents = false ; m_pLocale = NULL ; m_pSkinManager = NULL ; m_pFrame = NULL ; m_pDocument = NULL ; m_pTaskBarIcon = NULL ; m_pEventLog = NULL ; # ifdef __WXMAC__ m_pMacSystemMenu = NULL ; # endif m_strBOINCMGRExecutableName = wxEmptyString ; m_strBOINCMGRRootDirectory = wxEmptyString ; m_strBOINCMGRDataDirectory = wxEmptyString ; m_strHostNameArg = wxEmptyString ; m_strPasswordArg = wxEmptyString ; m_iRPCPortArg = GUI_RPC_PORT ; m_strBOINCArguments = wxEmptyString ; m_bGUIVisible = true ; m_bDebugSkins = false ; m_bMultipleInstancesOK = false ; m_bBOINCMGRAutoStarted = false ; m_iBOINCMGRDisableAutoStart = 0 ; m_iShutdownCoreClient = 0 ; m_iDisplayExitDialog = 1 ; m_iGUISelected = BOINC_SIMPLEGUI ; m_bSafeMessageBoxDisplayed = 0 ; # ifdef __WXMSW__ m_hClient@@ LibraryDll = NULL ; # endif int iErrorCode = 0 ; int iSelectedLanguage = 0 ; bool bOpenEventLog = false ; wxString strDesiredSkinName = wxEmptyString ; wxString strDialogMessage = wxEmptyString ; bool success = false ; # ifdef __WXMSW__ wxSystemOptions :: SetOption ( wxT ( " msw . staticbox . optimized - paint " ) , 0 ) ; # endif # ifdef __WXMAC__ wxSystemOptions :: SetOption ( wxT ( " mac . listctr@@ l . always _ use _ generic " ) , 1 ) ; AEInstallEventHandler ( kCoreEventClass , kAEQuitApplication , NewAE@@ EventHandlerUPP ( ( AEEventHandler@@ ProcPtr ) QuitAppleEventHandler ) , 0 , false ) ; GetCurrentProcess ( & m_psnCurrentProcess ) ; # endif if ( ! wxApp :: OnInit ( ) ) { return false ; } if ( g_use_sandbox ) { wxCHANGE_UMASK ( 2 ) ; } SetAppName ( wxT ( " BOINC ▁ Manager " ) ) ; SetVendorName ( wxT ( " Space ▁ Sciences ▁ Laboratory , ▁ U . C . ▁ Berkeley " ) ) ; m_pConfig = new wxConfig ( GetAppName ( ) ) ; wxConfigBase :: Set ( m_pConfig ) ; wxASSERT ( m_pConfig ) ; m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Read ( wxT ( " AutomaticallyShutdownClient " ) , & m_iShutdownCoreClient , 0L ) ; m_pConfig -> Read ( wxT ( " DisplayShutdownClientDialog " ) , & m_iDisplayExitDialog , 1L ) ; m_pConfig -> Read ( wxT ( " DisableAutoStart " ) , & m_iBOINCMGRDisableAutoStart , 0L ) ; m_pConfig -> Read ( wxT ( " Language " ) , & iSelectedLanguage , 0L ) ; m_pConfig -> Read ( wxT ( " GUISelection " ) , & m_iGUISelected , BOINC_SIMPLEGUI ) ; m_pConfig -> Read ( wxT ( " EventLogOpen " ) , & bOpenEventLog ) ; if ( m_bBOINCMGRAutoStarted && m_iBOINCMGRDisableAutoStart ) { return false ; } DetectExecutableName ( ) ; DetectRootDirectory ( ) ; DetectDataDirectory ( ) ; if ( ! GetDataDirectory ( ) . IsEmpty ( ) ) { success = wxSetWorkingDirectory ( GetDataDirectory ( ) ) ; if ( ! success ) { if ( ! g_use_sandbox ) { if ( ! wxDirExists ( GetDataDirectory ( ) ) ) { success = wxMkdir ( GetDataDirectory ( ) , 0777 ) ; } } } } if ( ! success ) iErrorCode = - 1016 ; int dwDiagnosticsFlags = BOINC_DIAG_DUM@@ PCALLSTACKENABLED | BOINC_DIAG_HEAP@@ CHECKENABLED | BOINC_DIAG_MEMORY@@ LEAKCHECKENABLED | # if defined ( __WXMSW__ ) || defined ( __WXMAC__ ) BOINC_DIAG_REDIRECTSTDERR | BOINC_DIAG_REDIRECTSTDOUT | # endif BOINC_DIAG_TRACETOS@@ TDOUT ; diagnostics_init ( dwDiagnosticsFlags , " stdoutgui " , " stderrgui " ) ; m_pLog = new wxLogBOINC ( ) ; wxLog :: SetActiveTarget ( m_pLog ) ; m_pLog -> AddTraceMask ( wxT ( " Function ▁ Start / End " ) ) ; m_pLog -> AddTraceMask ( wxT ( " Function ▁ Status " ) ) ; # ifdef __WXMSW__ _configthreadlocale ( _ENABLE_PER_THREAD_LOCAL@@ E ) ; # endif m_pLocale = new wxLocale ( ) ; wxASSERT ( m_pLocale ) ; m_pLocale -> Init ( iSelectedLanguage ) ; if ( ! m_strBOINCMGRRootDirectory . IsEmpty ( ) ) { m_pLocale -> AddCatalogLookupPathPrefix ( wxString ( m_strBOINCMGRRootDirectory + wxT ( " locale " ) ) ) ; } m_pLocale -> AddCatalogLookupPathPrefix ( wxT ( " locale " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Manager " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Client " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Web " ) ) ; InitSupportedLanguages ( ) ; wxHelpProvider :: Set ( new wxHelpControllerHelp@@ Provider ( ) ) ; wxInitAllImage@@ Handlers ( ) ; wxFileSystem :: AddHandler ( new wxMemoryFSHandler ) ; m_pInternetFSHandler = new CBOINCInternetFSHandler ; wxFileSystem :: AddHandler ( m_pInternetFSHandler ) ; m_pSkinManager = new CSkinManager ( m_bDebugSkins ) ; wxASSERT ( m_pSkinManager ) ; m_pConfig -> Read ( wxT ( " Skin " ) , & strDesiredSkinName , m_pSkinManager -> GetDefaultSkinName ( ) ) ; m_pSkinManager -> ReloadSkin ( strDesiredSkinName ) ; # ifdef SANDBOX char path_to_error [ MAXPATH@@ LEN ] ; path_to_error [ 0 ] = ' \0' ; if ( ! iErrorCode ) { # if ( defined ( __WXMAC__ ) && defined ( _DEBUG ) ) if ( check_security ( g_use_sandbox , true ) ) { CreateBOINC@@ UsersAnd@@ Groups ( ) ; SetBOINCDataOwnersGroupsAndPermissions ( ) ; SetBOINCAppOwnersGroupsAndPermissions ( NULL ) ; } # endif iErrorCode = check_security ( g_use_sandbox , true , path_to_error ) ; } if ( iErrorCode ) { ShowApplication ( true ) ; if ( iErrorCode == - 1099 ) { strDialogMessage . Printf ( _ ( " You ▁ currently ▁ are ▁ not ▁ author@@ ized ▁ to ▁ manage ▁ the ▁ client . \n \n To ▁ run ▁ % s ▁ as ▁ this ▁ user , ▁ please : \n ▁ ▁ - ▁ reinstall ▁ % s ▁ answering ▁ \ " Yes\ " ▁ to ▁ the ▁ question ▁ about \n ▁ ▁ ▁ ▁ ▁ non - administrative ▁ users \n ▁ or \n ▁ ▁ - ▁ contact ▁ your ▁ administrator ▁ to ▁ add ▁ you ▁ to ▁ the ▁ ' boinc _ master ' \n ▁ ▁ ▁ ▁ ▁ user ▁ group . " ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) ) ; } else { strDialogMessage . Printf ( _ ( " % s ▁ ownership ▁ or ▁ permissions ▁ are ▁ not ▁ set ▁ properly ; ▁ please ▁ reinstall ▁ % s . \n ( Error ▁ code ▁ % d " ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , iErrorCode ) ; if ( path_to_error [ 0 ] ) { strDialogMessage += _ ( " ▁ at ▁ " ) ; strDialogMessage += wxString :: FromUTF8 ( path_to_error ) ; } strDialogMessage += _ ( " ) " ) ; fprintf ( stderr , " % ls ▁ ownership ▁ or ▁ permissions ▁ are ▁ not ▁ set ▁ properly ; ▁ please ▁ reinstall ▁ % ls . \n ( Error ▁ code ▁ % d ▁ at ▁ % s ) " , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , iErrorCode , path_to_error ) ; } wxMessageDialog * pDlg = new wxMessageDialog ( NULL , strDialogMessage , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , wxOK ) ; pDlg -> ShowModal ( ) ; if ( pDlg ) pDlg -> Destroy ( ) ; return false ; } # endif # ifdef __WXMSW__ wxString strRebootPendingFile = GetRootDirectory ( ) + wxFileName :: GetPathSeparator ( ) + wxT ( " RebootPending . txt " ) ; if ( wxFile :: Exists ( strRebootPendingFile ) ) { wxMessageDialog dialog ( NULL , _ ( " A ▁ reboot ▁ is ▁ required ▁ in ▁ order ▁ for ▁ BOINC ▁ to ▁ run ▁ properly . \n Please ▁ reboot ▁ your ▁ computer ▁ and ▁ try ▁ again . " ) , _ ( " BOINC ▁ Manager " ) , wxOK | wxICON_ERROR ) ; dialog . ShowModal ( ) ; return false ; } # endif if ( ! m_bMultipleInstancesOK ) { if ( DetectDuplicateInstance ( ) ) { return false ; } } m_pDocument = new CMainDocument ( ) ; wxASSERT ( m_pDocument ) ; m_pDocument -> OnInit ( ) ; if ( BOINC_SIMPLEGUI == m_iGUISelected ) { if ( wxGetDisplaySize ( ) . GetHeight ( ) < 600 ) { m_iGUISelected = BOINC_ADVANCEDGUI ; } } m_pTaskBarIcon = new CTaskBarIcon ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationDisconnectedIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationSnoozeIcon ( ) ) ; wxASSERT ( m_pTaskBarIcon ) ; # ifdef __WXMAC__ m_pMacSystemMenu = new CMacSystemMenu ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationDisconnectedIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationSnoozeIcon ( ) ) ; wxASSERT ( m_pMacSystemMenu ) ; # endif IdleTrackerAttach ( ) ; # ifdef __WXMAC__ ProcessSerialNumber psn ; ProcessInfoRec pInfo ; OSStatus err ; memset ( & pInfo , 0 , sizeof ( pInfo ) ) ; pInfo . processInfoLength = sizeof ( ProcessInfoRec ) ; err = GetProcessInformation ( & m_psnCurrentProcess , & pInfo ) ; if ( ! err ) { psn = pInfo . processLauncher ; memset ( & pInfo , 0 , sizeof ( pInfo ) ) ; pInfo . processInfoLength = sizeof ( ProcessInfoRec ) ; err = GetProcessInformation ( & psn , & pInfo ) ; } if ( pInfo . processSignature == ' lgnw ' ) { m_bGUIVisible = false ; sleep ( 10 ) ; } # endif SetActiveGUI ( m_iGUISelected , false ) ; if ( m_bGUIVisible ) { SetActiveGUI ( m_iGUISelected ) ; } else { ShowApplication ( false ) ; } if ( bOpenEventLog ) { DisplayEventLog ( m_bGUIVisible ) ; m_pFrame -> Raise ( ) ; } return true ; } int CBOINCGUIApp :: OnExit ( ) { IdleTrackerDetach ( ) ; if ( m_pDocument ) { m_pDocument -> OnExit ( ) ; delete m_pDocument ; m_pDocument = NULL ; } m_pConfig -> SetPath ( wxT ( " / " ) ) ; if ( m_pSkinManager ) { m_pConfig -> Write ( wxT ( " Skin " ) , m_pSkinManager -> GetSelectedSkin ( ) ) ; delete m_pSkinManager ; } if ( m_pLocale ) { delete m_pLocale ; m_pLocale = NULL ; } if ( m_pEventLog ) { m_pEventLog -> Destroy ( ) ; m_pEventLog = NULL ; } m_pConfig -> Write ( wxT ( " AutomaticallyShutdownClient " ) , m_iShutdownCoreClient ) ; m_pConfig -> Write ( wxT ( " DisplayShutdownClientDialog " ) , m_iDisplayExitDialog ) ; m_pConfig -> Write ( wxT ( " DisableAutoStart " ) , m_iBOINCMGRDisableAutoStart ) ; diagnostics_@@ finish ( ) ; return wxApp :: OnExit ( ) ; } void CBOINCGUIApp :: OnInitCmdLine ( wxCmdLineParser & parser ) { wxApp :: OnInitCmdLine ( parser ) ; static const wxCmdLineEntryDesc cmdLineDesc [ ] = { { wxCMD_LINE_SWITCH , wxT ( " a " ) , wxT ( " autostart " ) , _ ( " BOINC ▁ Manager ▁ was ▁ started ▁ by ▁ the ▁ operating ▁ system ▁ automati@@ cally " ) } , # if defined ( __WXMSW__ ) || defined ( __WXMAC__ ) { wxCMD_LINE_SWITCH , wxT ( " s " ) , wxT ( " systray " ) , _ ( " Startup ▁ BOINC ▁ so ▁ only ▁ the ▁ system ▁ tray ▁ icon ▁ is ▁ visible " ) } , # else { wxCMD_LINE_OPTION , wxT ( " e " ) , wxT ( " clientdir " ) , _ ( " Directory ▁ containing ▁ the ▁ BOINC ▁ Client ▁ executable " ) } , { wxCMD_LINE_OPTION , wxT ( " d " ) , wxT ( " datadir " ) , _ ( " BOINC ▁ data ▁ directory " ) } , # endif { wxCMD_LINE_OPTION , wxT ( " n " ) , wxT ( " namehost " ) , _ ( " Host ▁ name ▁ or ▁ IP ▁ address " ) } , { wxCMD_LINE_OPTION , wxT ( " g " ) , wxT ( " gui _ rpc _ port " ) , _ ( " GUI ▁ RPC ▁ port ▁ number " ) } , { wxCMD_LINE_OPTION , wxT ( " p " ) , wxT ( " password " ) , _ ( " Password " ) } , { wxCMD_LINE_OPTION , wxT ( " b " ) , wxT ( " boincargs " ) , _ ( " Startup ▁ BOINC ▁ with ▁ these ▁ optional ▁ arguments " ) } , { wxCMD_LINE_SWITCH , wxT ( " i " ) , wxT ( " insecure " ) , _ ( " disable ▁ BOINC ▁ security ▁ users ▁ and ▁ permissions " ) } , { wxCMD_LINE_SWITCH , wxT ( " c " ) , wxT ( " checkskins " ) , _ ( " set ▁ skin ▁ debugging ▁ mode ▁ to ▁ enable ▁ skin ▁ manager ▁ error ▁ messages " ) } , { wxCMD_LINE_SWITCH , wxT ( " m " ) , wxT ( " multiple " ) , _ ( " multiple ▁ instances ▁ of ▁ BOINC ▁ Manager ▁ allowed " ) } , # if ( defined ( __WXMAC__ ) && defined ( _DEBUG ) ) { wxCMD_LINE_OPTION , wxT ( " NSDocumentRevi@@ sionsDebug@@ Mode " ) , NULL , _ ( " Not ▁ used : ▁ workaround ▁ for ▁ bug ▁ in ▁ XCode ▁ 4.2" ) } , # endif { wxCMD_LINE_NONE } } ; parser . SetDesc ( cmdLineDesc ) ; } bool CBOINCGUIApp :: OnCmdLineParsed ( wxCmdLineParser & parser ) { wxApp :: OnCmdLineParsed ( parser ) ; wxString portNum = wxEmptyString ; long longPort ; bool hostNameSpecified = false ; bool passwordSpecified = false ; parser . Found ( wxT ( " boincargs " ) , & m_strBOINCArguments ) ; if ( parser . Found ( wxT ( " autostart " ) ) ) { m_bBOINCMGRAutoStarted = true ; } # if defined ( __WXMSW__ ) || defined ( __WXMAC__ ) if ( parser . Found ( wxT ( " systray " ) ) ) { m_bGUIVisible = false ; } # endif if ( parser . Found ( wxT ( " insecure " ) ) ) { g_use_sandbox = false ; } if ( parser . Found ( wxT ( " checkskins " ) ) ) { m_bDebugSkins = true ; } if ( parser . Found ( wxT ( " multiple " ) ) ) { m_bMultipleInstancesOK = true ; } # if ! ( defined ( __WXMSW__ ) || defined ( __WXMAC__ ) ) if ( ! parser . Found ( wxT ( " clientdir " ) , & m_strBOINCMGRRootDirectory ) ) { m_strBOINCMGRRootDirectory = :: wxGetCwd ( ) ; } if ( m_strBOINCMGRRootDirectory . Last ( ) != ' / ' ) { m_strBOINCMGRRootDirectory . Append ( ' / ' ) ; } if ( ! parser . Found ( wxT ( " datadir " ) , & m_strBOINCMGRDataDirectory ) ) { m_strBOINCMGRDataDirectory = m_strBOINCMGRRootDirectory ; } if ( m_strBOINCMGRDataDirectory . Last ( ) != ' / ' ) { m_strBOINCMGRDataDirectory . Append ( ' / ' ) ; } # endif if ( parser . Found ( wxT ( " namehost " ) , & m_strHostNameArg ) ) { hostNameSpecified = true ; } else { m_strHostNameArg = wxT ( " localhost " ) ; } if ( parser . Found ( wxT ( " gui _ rpc _ port " ) , & portNum ) ) { if ( portNum . ToLong ( & longPort ) ) { m_iRPCPortArg = longPort ; } else { m_iRPCPortArg = GUI_RPC_PORT ; } } else { m_iRPCPortArg = GUI_RPC_PORT ; } if ( parser . Found ( wxT ( " password " ) , & m_strPasswordArg ) ) { passwordSpecified = true ; } else { m_strPasswordArg = wxEmptyString ; } if ( hostNameSpecified && passwordSpecified ) { m_bMultipleInstancesOK = true ; } return true ; } bool CBOINCGUIApp :: DetectDuplicateInstance ( ) { # ifdef __WXMSW__ if ( CTaskBarIcon :: FireAppRestore ( ) ) { return true ; } # endif # ifdef __WXMAC__ ProcessSerialNumber PSN ; int iInstanceID = wxGetApp ( ) . IsAnotherInstanceRunning ( ) ; if ( iInstanceID ) { OSStatus err = GetProcessForPID ( iInstanceID , & PSN ) ; if ( ! err ) SetFrontProcess ( & PSN ) ; return true ; } # endif return false ; } void CBOINCGUIApp :: DetectExecutableName ( ) { # ifdef __WXMSW__ TCHAR szPath [ MAX_PATH - 1 ] ; GetModuleFileName ( NULL , szPath , ( sizeof ( szPath ) / sizeof ( TCHAR ) ) ) ; TCHAR * pszProg = _tcsrchr ( szPath , ' \\ ' ) ; if ( pszProg ) { pszProg ++ ; } m_strBOINCMGRExecutableName = pszProg ; # endif } void CBOINCGUIApp :: DetectRootDirectory ( ) { # ifdef __WXMSW__ TCHAR szPath [ MAX_PATH - 1 ] ; GetModuleFileName ( NULL , szPath , ( sizeof ( szPath ) / sizeof ( TCHAR ) ) ) ; TCHAR * pszProg = _tcsrchr ( szPath , ' \\ ' ) ; if ( pszProg ) { szPath [ pszProg - szPath + 1 ] = 0 ; } m_strBOINCMGRRootDirectory = szPath ; # endif } void CBOINCGUIApp :: DetectDataDirectory ( ) { # ifdef __WXMSW__ LONG lReturnValue ; HKEY hkSetupHive ; LPTSTR lpszRegistryValue = NULL ; DWORD dwSize = 0 ; lReturnValue = RegOpen@@ KeyEx ( HKEY_LOCAL_MACH@@ INE , _T ( " SOFTWARE\\@@ Space ▁ Sciences ▁ Laboratory , ▁ U . C . ▁ Berkeley\\@@ BOINC ▁ Setup " ) , 0 , KEY_READ , & hkSetupHive ) ; if ( lReturnValue == ERROR_SUCCESS ) { lReturnValue = RegQueryValueEx ( hkSetupHive , _T ( " DATADIR " ) , NULL , NULL , NULL , & dwSize ) ; if ( lReturnValue != ERROR_FILE_NOT_FOUND ) { lpszRegistryValue = ( LPTSTR ) malloc ( dwSize ) ; ( * lpszRegistryValue ) = NULL ; lReturnValue = RegQueryValueEx ( hkSetupHive , _T ( " DATADIR " ) , NULL , NULL , ( LPBYTE ) lpszRegistryValue , & dwSize ) ; m_strBOINCMGRDataDirectory = lpszRegistryValue ; } } if ( hkSetupHive ) RegClose@@ Key ( hkSetupHive ) ; if ( lpszRegistryValue ) free ( lpszRegistryValue ) ; # endif # ifdef __WXMAC__ m_strBOINCMGRDataDirectory = wxT ( " / Library / Application ▁ Support / BOINC ▁ Data " ) ; # endif } void CBOINCGUIApp :: InitSupportedLanguages ( ) { wxInt32 iIndex = 0 ; const wxLanguageInfo * liLanguage = NULL ; m_astrLanguages . Insert ( wxEmptyString , 0 , wxLANGUAGE_USER_DEFINED + 1 ) ; m_astrLanguages [ wxLANGUAGE_DEFAULT ] = _ ( " ( Automatic ▁ Detection ) " ) ; m_astrLanguages [ wxLANGUAGE_UNKNOWN ] = _ ( " ( Unknown ) " ) ; m_astrLanguages [ wxLANGUAGE_USER_DEFINED ] = _ ( " ( User ▁ Defined ) " ) ; for ( iIndex = 0 ; iIndex <= wxLANGUAGE_USER_DEFINED ; iIndex ++ ) { liLanguage = wxLocale :: GetLanguageInfo ( iIndex ) ; if ( liLanguage ) { m_astrLanguages [ iIndex ] = liLanguage -> Description ; } } } int CBOINCGUIApp :: IdleTrackerAttach ( ) { # ifdef __WXMSW__ :: attach_idle_monitor ( ) ; # endif return 0 ; } int CBOINCGUIApp :: IdleTrackerDetach ( ) { # ifdef __WXMSW__ :: detach_idle_monitor ( ) ; # endif return 0 ; } void CBOINCGUIApp :: OnActivateApp ( wxActivateEvent & event ) { # ifdef __WXMAC__ if ( IsModalDialogDisplayed ( ) ) { event . Skip ( ) ; return ; } # endif if ( event . GetActive ( ) ) { if ( m_pEventLog && ! m_pEventLog -> IsIconized ( ) ) { m_pEventLog -> Raise ( ) ; } if ( m_pFrame ) m_pFrame -> Raise ( ) ; } event . Skip ( ) ; } void CBOINCGUIApp :: OnRPCFinished ( CRPC@@ FinishedEvent & event ) { CMainDocument * pDoc = wxGetApp ( ) . GetDocument ( ) ; wxASSERT ( pDoc ) ; wxASSERT ( wxDynamicCast ( pDoc , CMainDocument ) ) ; pDoc -> OnRPCComplete ( event ) ; } int CBOINCGUIApp :: UpdateSystem@@ IdleDetection ( ) { # ifdef __WXMSW__ return get_idle_@@ tick_count ( ) ; # else return TRUE ; # endif } int CBOINCGUIApp :: StartBOINCScreensaverTest ( ) { # ifdef __WXMSW__ wxString strExecute = wxEmptyString ; wxChar szExecutableDirectory [ 4096 ] ; memset ( szExecutableDirectory , 0 , sizeof ( szExecutableDirectory ) ) ; GetWindowsDirectory ( szExecutableDirectory , ( sizeof ( szExecutableDirectory ) / sizeof ( wxChar ) ) ) ; strExecute = wxT ( " \ " " ) + wxString ( szExecutableDirectory ) + wxT ( " \\boinc . scr\ " ▁ / t " ) ; :: wxExecute ( strExecute ) ; # endif return 0 ; } int CBOINCGUIApp :: StartBOINCDefaultScreensaverTest ( ) { # ifdef __WXMSW__ wxString strExecute = wxEmptyString ; strExecute = wxT ( " \ " " ) + m_strBOINCMGRRootDirectory + wxT ( " \\boinc@@ scr . exe\ " ▁ - - test " ) ; :: wxExecute ( strExecute ) ; # endif return 0 ; } void CBOINCGUIApp :: DisplayEventLog ( bool bShowWindow ) { if ( m_pEventLog ) { if ( bShowWindow ) { if ( m_pEventLog -> IsIconized ( ) ) { m_pEventLog -> Iconize ( false ) ; } m_pEventLog -> Raise ( ) ; } } else { m_pEventLog = new CDlgEventLog ( ) ; if ( m_pEventLog ) { m_pEventLog -> Show ( bShowWindow ) ; if ( bShowWindow ) { m_pEventLog -> Raise ( ) ; } if ( m_pFrame ) { m_pFrame -> UpdateRefreshTimerInterval ( ) ; } } } } void CBOINCGUIApp :: OnEventLog@@ Close ( ) { m_pEventLog = NULL ; if ( m_pFrame ) { m_pFrame -> UpdateRefreshTimerInterval ( ) ; } } void CBOINCGUIApp :: FireReloadSkin ( ) { if ( m_pFrame ) { m_pFrame -> FireReloadSkin ( ) ; } if ( m_pTaskBarIcon ) { m_pTaskBarIcon -> FireReloadSkin ( ) ; } } bool CBOINCGUIApp :: SetActiveGUI ( int iGUISelection , bool bShowWindow ) { wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ Function ▁ Begin " ) ) ; wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ GUI ▁ Selection : ▁ ' % d ' , ▁ Show : ▁ % d ' " ) , iGUISelection , ( int ) bShowWindow ) ; CBOINCBaseFrame * pNewFrame = NULL ; CBOINCBaseFrame * pOldFrame = m_pFrame ; wxInt32 iTop = 0 ; wxInt32 iLeft = 0 ; wxInt32 iHeight = 0 ; wxInt32 iWidth = 0 ; if ( ( iGUISelection != m_iGUISelected ) || ! m_pFrame ) { if ( BOINC_ADVANCEDGUI == iGUISelection ) { m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Read ( wxT ( " YPos " ) , & iTop , 30 ) ; m_pConfig -> Read ( wxT ( " XPos " ) , & iLeft , 30 ) ; m_pConfig -> Read ( wxT ( " Width " ) , & iWidth , 800 ) ; m_pConfig -> Read ( wxT ( " Height " ) , & iHeight , 600 ) ; } else { m_pConfig -> SetPath ( wxT ( " / Simple " ) ) ; m_pConfig -> Read ( wxT ( " YPos " ) , & iTop , 30 ) ; m_pConfig -> Read ( wxT ( " XPos " ) , & iLeft , 30 ) ; # ifdef __WXMAC__ iWidth = 409 ; iHeight = 561 ; # else iWidth = 416 ; iHeight = 570 ; # endif } # ifdef __WXMAC__ if ( ! IsWindow@@ OnScreen ( iLeft , iTop , iWidth , iHeight ) ) { iTop = iLeft = 30 ; } # else if ( iLeft < 0 ) iLeft = 30 ; if ( iTop < 0 ) iTop = 30 ; wxInt32 iMaxWidth = wxSystemSettings :: GetMetric ( wxSYS_SCREEN_X ) ; wxInt32 iMaxHeight = wxSystemSettings :: GetMetric ( wxSYS_SCREEN_Y ) ; if ( iLeft + iWidth > iMaxWidth ) iLeft = iMaxWidth - iWidth ; if ( iTop + iHeight > iMaxHeight ) iTop = iMaxHeight - iHeight ; # endif if ( BOINC_ADVANCEDGUI == iGUISelection ) { pNewFrame = new CAdvancedFrame ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon32 ( ) , wxPoint ( iLeft , iTop ) , wxSize ( iWidth , iHeight ) ) ; } else { pNewFrame = new CSimpleFrame ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon32 ( ) , wxPoint ( iLeft , iTop ) , wxSize ( iWidth , iHeight ) ) ; } wxASSERT ( pNewFrame ) ; if ( pNewFrame ) { SetTopWindow ( pNewFrame ) ; m_pFrame = pNewFrame ; if ( pOldFrame ) pOldFrame -> Hide ( ) ; if ( pOldFrame ) pOldFrame -> Destroy ( ) ; } } if ( m_pFrame && bShowWindow ) { if ( m_pEventLog ) { m_pEventLog -> Show ( ) ; m_pEventLog -> Raise ( ) ; # ifdef __WXMSW__ :: SetForegroundWindow ( ( HWND ) m_pEventLog -> GetHWND ( ) ) ; # endif } if ( ! m_pFrame -> IsShown ( ) ) { m_pFrame -> Show ( ) ; } if ( m_pFrame -> IsIconized ( ) ) { m_pFrame -> Maximize ( false ) ; } m_pFrame -> Raise ( ) ; # ifdef __WXMSW__ :: SetForegroundWindow ( ( HWND ) m_pFrame -> GetHWND ( ) ) ; # endif } m_iGUISelected = iGUISelection ; m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Write ( wxT ( " GUISelection " ) , iGUISelection ) ; wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ Function ▁ End " ) ) ; return true ; } int CBOINCGUIApp :: ConfirmExit ( ) { CSkinAdvanced * pSkinAdvanced = wxGetApp ( ) . GetSkinManager ( ) -> GetAdvanced ( ) ; CMainDocument * pDoc = wxGetApp ( ) . GetDocument ( ) ; wxString strConnectedCompter = wxEmptyString ; bool bWasVisible ; int retval = 0 ; wxASSERT ( pDoc ) ; wxASSERT ( pSkinAdvanced ) ; wxASSERT ( wxDynamicCast ( pDoc , CMainDocument ) ) ; wxASSERT ( wxDynamicCast ( pSkinAdvanced , CSkinAdvanced ) ) ; pDoc -> GetConnectedComputerName ( strConnectedCompter ) ; if ( ! pDoc -> IsComput@@ erNameLocal ( strConnectedCompter ) ) { return 1 ; } if ( s_bSkipExitConfirmation ) return 1 ; if ( IsMgrMultiple@@ Instance ( ) ) return 1 ; if ( ! m_iDisplayExitDialog ) { return 1 ; } bWasVisible = IsApplicationVisible ( ) ; ShowApplication ( true ) ; CDlgExitMessage dlg ( NULL ) ; if ( ! pSkinAdvanced -> GetExitMessage ( ) . IsEmpty ( ) ) { dlg . m_DialogExitMessage -> SetLabel ( pSkinAdvanced -> GetExitMessage ( ) ) ; } # ifdef __WXMSW__ if ( m_iShutdownCoreClient ) { dlg . m_DialogShutdownCoreClient -> SetValue ( TRUE ) ; } # endif if ( m_iDisplayExitDialog ) { dlg . m_DialogDisplay -> SetValue ( FALSE ) ; } dlg . Fit ( ) ; dlg . Centre ( ) ; if ( wxID_OK == dlg . ShowModal ( ) ) { # ifdef __WXMAC__ s_bSkipExitConfirmation = true ; # else m_iShutdownCoreClient = dlg . m_DialogShutdownCoreClient -> GetValue ( ) ; # endif m_iDisplayExitDialog = ! dlg . m_DialogDisplay -> GetValue ( ) ; retval = true ; } if ( ! bWasVisible ) { ShowApplication ( false ) ; } return retval ; } int CBOINCGUIApp :: SafeMessageBox ( const wxString & message , const wxString & caption , long style , wxWindow * parent , int x , int y ) { int retval ; m_bSafeMessageBoxDisplayed ++ ; retval = wxMessageBox ( message , caption , style , parent , x , y ) ; m_bSafeMessageBoxDisplayed -- ; return retval ; } int CBOINCGUIApp :: IsAnotherInstanceRunning ( ) { PROC_MAP pm ; int retval ; char myName [ 256 ] ; int otherInstanceID = 0 ; int myPid ; retval = procinfo_setup ( pm ) ; if ( retval ) return false ; # ifdef _WIN32 myPid = ( int ) GetCurrentProcessId ( ) ; # else myPid = getpid ( ) ; # endif myName [ 0 ] = 0 ; PROC_MAP :: iterator i ; for ( i = pm . begin ( ) ; i != pm . end ( ) ; i ++ ) { PROCINFO & pi = i -> second ; if ( pi . id == myPid ) { strncpy ( myName , pi . command , sizeof ( myName ) ) ; break ; } } if ( myName [ 0 ] == 0 ) { return false ; } for ( i = pm . begin ( ) ; i != pm . end ( ) ; i ++ ) { PROCINFO & pi = i -> second ; if ( pi . id == myPid ) continue ; if ( ! strcmp ( pi . command , myName ) ) { otherInstanceID = pi . id ; break ; } } return otherInstanceID ; } bool CBOINCGUIApp :: IsApplicationVisible ( ) { # ifdef __WXMAC__ if ( IsProcess@@ Visible ( & m_psnCurrentProcess ) ) { return true ; } # endif return false ; } # ifdef __WXMAC__ void CBOINCGUIApp :: ShowApplication ( bool bShow ) { if ( bShow ) { SetFrontProcess ( & m_psnCurrentProcess ) ; } else { ShowHide@@ Process ( & m_psnCurrentProcess , false ) ; } } # else void CBOINCGUIApp :: ShowApplication ( bool ) { } # endif bool CBOINCGUIApp :: ShowInterface ( ) { return SetActiveGUI ( m_iGUISelected , true ) ; } bool CBOINCGUIApp :: ShowNoti@@ fications ( ) { bool retval = false ; retval = SetActiveGUI ( m_iGUISelected , true ) ; if ( retval ) { GetFrame ( ) -> FireNotification ( ) ; GetDocument ( ) -> UpdateUnread@@ NoticeState ( ) ; } return retval ; } bool CBOINCGUIApp :: IsModalDialogDisplayed ( ) { if ( m_bSafeMessageBoxDisplayed ) return true ; if ( wxDynamicCast ( wxWindow :: FindWindowById ( ID_ANYDIALOG ) , wxDialog ) ) { return true ; } if ( m_pDocument ) { if ( m_pDocument -> WaitingForRPC ( ) ) { return true ; } } return false ; } void CBOINCGUIApp :: DeleteTaskBarIcon ( ) { if ( m_pTaskBarIcon ) { delete m_pTaskBarIcon ; } m_pTaskBarIcon = NULL ; } # ifdef __WXMAC__ void CBOINCGUIApp :: DeleteMacSystemMenu ( ) { if ( m_pMacSystemMenu ) { delete m_pMacSystemMenu ; } m_pMacSystemMenu = NULL ; } # endif int CBOINCGUIApp :: FilterEvent ( wxEvent & event ) { int theEventType ; wxDialog * theRPCWaitDialog ; wxObject * theObject ; if ( ! m_pDocument ) return - 1 ; theEventType = event . GetEventType ( ) ; if ( m_pDocument -> WaitingForRPC ( ) ) { if ( ( theEventType == wxEVT_COMMAND_@@ MENU_SEL@@ ECTED ) && ( event . GetId ( ) == wxID_OPEN ) ) { return - 1 ; } theRPCWaitDialog = m_pDocument -> GetRPCWaitDialog ( ) ; theObject = event . GetEventObject ( ) ; while ( theObject ) { if ( ! theObject -> IsKind@@ Of ( CLASSINFO ( wxWindow ) ) ) break ; if ( theObject == theRPCWaitDialog ) return - 1 ; theObject = ( ( wxWindow * ) theObject ) -> GetParent ( ) ; } } else { if ( ! m_bFilterEvents ) return - 1 ; } if ( event . IsCommandEvent ( ) ) { return false ; } if ( theEventType == wxEVT_TIMER ) { return false ; } # ifdef __WXMSW__ if ( theEventType == wxEVT_TAS@@ KBAR_MOVE ) { return false ; } # endif return - 1 ; } </DOCUMENT>
<DOCUMENT_ID="eugene1g/phantomjs/tree/master/src/qt/qtwebkit/Source/WebCore@@ /css/@@ CSSSupportsRule@@ .cpp"> # include " config . h " # include " CSSSupportsRule . h " # include " CSSParser . h " # include " CSSRule . h " # include " CSSRuleList . h " # include " CSSStyleSheet . h " # include " ExceptionCode . h " # include " StyleRule . h " # include < wtf / text / StringBuilder . h > # if ENABLE ( CSS3_CONDI@@ TIONAL_RULES ) namespace WebCore { CSSSupportsRule :: CSSSupportsRule ( StyleRuleSupports * supportsRule , CSSStyleSheet * parent ) : CSSGroupingRule ( supportsRule , parent ) { } String CSSSupportsRule :: cssText ( ) const { StringBuilder result ; result . append ( " @ supports ▁ " ) ; result . append ( conditionText ( ) ) ; result . append ( " ▁ { \n " ) ; appendCss@@ TextForItems ( result ) ; result . append ( ' } ' ) ; return result . toString ( ) ; } String CSSSupportsRule :: conditionText ( ) const { return toStyleRuleSupports ( m_groupRule . get ( ) ) -> conditionText ( ) ; } } # endif </DOCUMENT>
<DOCUMENT_ID="poixen/@@ Cockatrice/tree/master/cockatri@@ ce/src/dlg_edit_@@ user.cpp"> # include < QSettings > # include < QLabel > # include < QGridLayout > # include < QHBoxLayout > # include < QDialogButtonBox > # include < QDebug > # include " dlg _ edit _ user . h " # include " settingscache . h " DlgEditUser :: DlgEditUser ( QWidget * parent , QString email , int gender , QString country , QString realName ) : QDialog ( parent ) { emailLabel = new QLabel ( tr ( " Email : " ) ) ; emailEdit = new QLineEdit ( ) ; emailLabel -> setBuddy ( emailEdit ) ; emailEdit -> setText ( email ) ; genderLabel = new QLabel ( tr ( " Pronouns : " ) ) ; genderEdit = new QComboBox ( ) ; genderLabel -> setBuddy ( genderEdit ) ; genderEdit -> insertItem ( 0 , QIcon ( " : / resources / genders / unknown . svg " ) , tr ( " Neutral " ) ) ; genderEdit -> insertItem ( 1 , QIcon ( " : / resources / genders / male . svg " ) , tr ( " Masculine " ) ) ; genderEdit -> insertItem ( 2 , QIcon ( " : / resources / genders / female . svg " ) , tr ( " Feminine " ) ) ; genderEdit -> setCurrentIndex ( gender + 1 ) ; countryLabel = new QLabel ( tr ( " Country : " ) ) ; countryEdit = new QComboBox ( ) ; countryLabel -> setBuddy ( countryEdit ) ; countryEdit -> insertItem ( 0 , tr ( " Undefined " ) ) ; countryEdit -> setCurrentIndex ( 0 ) ; QStringList countries = settingsCache -> getCountries ( ) ; int i = 1 ; foreach ( QString c , countries ) { countryEdit -> addItem ( QPixmap ( " : / resources / countries / " + c + " . svg " ) , c ) ; if ( c == country ) countryEdit -> setCurrentIndex ( i ) ; ++ i ; } realnameLabel = new QLabel ( tr ( " Real ▁ name : " ) ) ; realnameEdit = new QLineEdit ( ) ; realnameLabel -> setBuddy ( realnameEdit ) ; realnameEdit -> setText ( realName ) ; QGridLayout * grid = new QGridLayout ; grid -> addWidget ( emailLabel , 0 , 0 ) ; grid -> addWidget ( emailEdit , 0 , 1 ) ; grid -> addWidget ( genderLabel , 1 , 0 ) ; grid -> addWidget ( genderEdit , 1 , 1 ) ; grid -> addWidget ( countryLabel , 2 , 0 ) ; grid -> addWidget ( countryEdit , 2 , 1 ) ; grid -> addWidget ( realnameLabel , 3 , 0 ) ; grid -> addWidget ( realnameEdit , 3 , 1 ) ; QDialogButtonBox * buttonBox = new QDialogButtonBox ( QDialogButtonBox :: Ok | QDialogButtonBox :: Cancel ) ; connect ( buttonBox , SIGNAL ( accepted ( ) ) , this , SLOT ( actOk ( ) ) ) ; connect ( buttonBox , SIGNAL ( rejected ( ) ) , this , SLOT ( actCancel ( ) ) ) ; QVBoxLayout * mainLayout = new QVBoxLayout ; mainLayout -> addLayout ( grid ) ; mainLayout -> addWidget ( buttonBox ) ; setLayout ( mainLayout ) ; setWindowTitle ( tr ( " Edit ▁ user ▁ profile " ) ) ; setFixedHeight ( sizeHint ( ) . height ( ) ) ; setMinimumWidth ( 300 ) ; } void DlgEditUser :: actOk ( ) { accept ( ) ; } void DlgEditUser :: actCancel ( ) { reject ( ) ; } </DOCUMENT>
<DOCUMENT_ID="imAArti@@ st/sim@@ Ir/tree/master/Data/single@@ File/code@@ _721.cpp"> int candy ( vector < int > & ratings ) { int size = ratings . size ( ) ; if ( size <= 1 ) return size ; vector < int > num ( size , 1 ) ; for ( int i = 1 ; i < size ; i ++ ) { if ( ratings [ i ] > ratings [ i - 1 ] ) num [ i ] = num [ i - 1 ] + 1 ; } for ( int i = size - 1 ; i > 0 ; i -- ) { if ( ratings [ i - 1 ] > ratings [ i ] ) num [ i - 1 ] = max ( num [ i ] + 1 , num [ i - 1 ] ) ; } int result = 0 ; for ( int i = 0 ; i < size ; i ++ ) { result += num [ i ] ; } return result ; } 1 , 3 , 3 , 3 , 21 , 2 , 1 , 2 , 1public int candy ( int [ ] ratings ) { int len = ratings . length ; int [ ] candy = new int [ len ] ; candy [ 0 ] = 1 ; for ( int i = 1 ; i < len ; ++ i ) { if ( ratings [ i ] > ratings [ i - 1 ] ) { candy [ i ] = candy [ i - 1 ] + 1 ; } else { candy [ i ] = 1 ; } } int total = candy [ len - 1 ] ; for ( int i = len - 2 ; i >= 0 ; -- i ) { if ( ratings [ i ] > ratings [ i + 1 ] && candy [ i ] <= candy [ i + 1 ] ) { candy [ i ] = candy [ i + 1 ] + 1 ; } total += candy [ i ] ; } return total ; } </DOCUMENT>
<DOCUMENT_ID="tjaff@@ ri/msiot-samples/tree/master/AllJoyn/Samples/@@ ZWaveAdapter/open@@ -zwave/cpp/src/@@ command_classes/@@ UserCode.cpp"> # include " tinyxml . h " # include " command _ classes / CommandClasses . h " # include " command _ classes / UserCode . h " # include " Node . h " # include " Options . h " # include " platform / Log . h " # include " value _ classes / ValueByte . h " # include " value _ classes / ValueRaw . h " using namespace OpenZWave ; enum UserCodeCmd { UserCodeCmd_Set = 0x01 , UserCodeCmd_Get = 0x02 , UserCodeCmd_Report = 0x03 , UserNumberCmd_Get = 0x04 , UserNumberCmd_Report = 0x05 } ; enum { UserCodeIndex_Refresh = 254 , UserCodeIndex_Count = 255 } ; const uint8 UserCodeLength = 10 ; UserCode :: UserCode ( uint32 const _homeId , uint8 const _nodeId ) : CommandClass ( _homeId , _nodeId ) , m_queryAll ( false ) , m_currentCode ( 0 ) , m_userCodeCount ( 0 ) , m_refreshUserCodes ( false ) { SetStaticRequest ( StaticRequest_Values ) ; memset ( m_userCodesStatus , 0xff , sizeof ( m_userCodesStatus ) ) ; Options :: Get ( ) -> GetOptionAsBool ( " RefreshAllUserCodes " , & m_refreshUserCodes ) ; } void UserCode :: ReadXML ( TiXmlElement const * _ccElement ) { int32 intVal ; CommandClass :: ReadXML ( _ccElement ) ; if ( TIXML_SUCCESS == _ccElement -> QueryIntAttribute ( " codes " , & intVal ) ) { m_userCodeCount = intVal ; } } void UserCode :: WriteXML ( TiXmlElement * _ccElement ) { char str [ 32 ] ; CommandClass :: WriteXML ( _ccElement ) ; snprintf ( str , sizeof ( str ) , " % d " , m_userCodeCount ) ; _ccElement -> SetAttribute ( " codes " , str ) ; } bool UserCode :: RequestState ( uint32 const _requestFlags , uint8 const _instance , Driver :: MsgQueue const _queue ) { bool requests = false ; if ( ( _requestFlags & RequestFla@@ g_Static ) && HasStaticRequest ( StaticRequest_Values ) ) { requests |= RequestValue ( _requestFlags , UserCodeIndex_Count , _instance , _queue ) ; } if ( _requestFlags & RequestFlag@@ _Session ) { if ( m_userCodeCount > 0 ) { m_queryAll = true ; m_currentCode = 1 ; requests |= RequestValue ( _requestFlags , m_currentCode , _instance , _queue ) ; } } return requests ; } bool UserCode :: RequestValue ( uint32 const _requestFlags , uint8 const _userCodeIdx , uint8 const _instance , Driver :: MsgQueue const _queue ) { if ( _instance != 1 ) { return false ; } if ( ! IsGetSupported ( ) ) { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " UserNumberCmd _ Get ▁ Not ▁ Supported ▁ on ▁ this ▁ node " ) ; return false ; } if ( _userCodeIdx == UserCodeIndex_Count ) { Msg * msg = new Msg ( " UserNumberCmd _ Get " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true , true , FUNC_ID_APPLICATION_COMMAND_HANDLER , GetCommandClassId ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 2 ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserNumberCmd_Get ) ; msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , _queue ) ; return true ; } if ( _userCodeIdx == 0 ) { Log :: Write ( LogLevel_Warning , GetNodeId ( ) , " UserCodeCmd _ Get ▁ with ▁ Index ▁ 0 ▁ not ▁ Supported " ) ; return false ; } Msg * msg = new Msg ( " UserCodeCmd _ Get " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true , true , FUNC_ID_APPLICATION_COMMAND_HANDLER , GetCommandClassId ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 3 ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserCodeCmd_Get ) ; msg -> Append ( _userCodeIdx ) ; msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , _queue ) ; return true ; } bool UserCode :: HandleMsg ( uint8 const * _data , uint32 const _length , uint32 const _instance ) { if ( UserNumberCmd_Report == ( UserCodeCmd ) _data [ 0 ] ) { m_userCodeCount = _data [ 1 ] ; if ( m_userCodeCount > 254 ) { m_userCodeCount = 254 ; } ClearStaticRequest ( StaticRequest_Values ) ; if ( m_userCodeCount == 0 ) { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Number ▁ report ▁ from ▁ node ▁ % d : ▁ Not ▁ supported " , GetNodeId ( ) ) ; } else { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Number ▁ report ▁ from ▁ node ▁ % d : ▁ Supported ▁ Codes ▁ % d ▁ ( % d ) " , GetNodeId ( ) , m_userCodeCount , _data [ 1 ] ) ; } if ( ValueByte * value = static_cast < ValueByte * > ( GetValue ( _instance , UserCodeIndex_Count ) ) ) { value -> OnValueRefreshed ( m_userCodeCount ) ; value -> Release ( ) ; } if ( Node * node = GetNodeUnsafe ( ) ) { uint8 data [ UserCodeLength ] ; memset ( data , 0 , UserCodeLength ) ; for ( uint8 i = 0 ; i <= m_userCodeCount ; i ++ ) { char str [ 16 ] ; if ( i == 0 ) { snprintf ( str , sizeof ( str ) , " Enrollment ▁ Code " ) ; node -> CreateValueRaw ( ValueID :: ValueGenre_User , GetCommandClassId ( ) , _instance , i , str , " " , true , false , data , UserCodeLength , 0 ) ; } else { snprintf ( str , sizeof ( str ) , " Code ▁ % d : " , i ) ; node -> CreateValueRaw ( ValueID :: ValueGenre_User , GetCommandClassId ( ) , _instance , i , str , " " , false , false , data , UserCodeLength , 0 ) ; } } } return true ; } else if ( UserCodeCmd_Report == ( UserCodeCmd ) _data [ 0 ] ) { int i = _data [ 1 ] ; if ( ValueRaw * value = static_cast < ValueRaw * > ( GetValue ( _instance , i ) ) ) { uint8 data [ UserCodeLength ] ; uint8 size = _length - 4 ; if ( size > UserCodeLength ) { Log :: Write ( LogLevel_Warning , GetNodeId ( ) , " User ▁ Code ▁ length ▁ % d ▁ is ▁ larger ▁ then ▁ maximum ▁ % d " , size , UserCodeLength ) ; size = UserCodeLength ; } m_userCodesStatus [ i ] = _data [ 2 ] ; memcpy ( data , & _data [ 3 ] , size ) ; value -> OnValueRefreshed ( data , size ) ; value -> Release ( ) ; } Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Code ▁ Report ▁ from ▁ node ▁ % d ▁ for ▁ User ▁ Code ▁ % d ▁ ( % s ) " , GetNodeId ( ) , i , CodeStatus ( _data [ 2 ] ) . c_str ( ) ) ; if ( m_queryAll && i == m_currentCode ) { if ( m_refreshUserCodes || ( _data [ 2 ] != UserCode_Available ) ) { if ( ++ i <= m_userCodeCount ) { m_currentCode = i ; RequestValue ( 0 , m_currentCode , _instance , Driver :: MsgQueue_Query ) ; } else { m_queryAll = false ; Options :: Get ( ) -> GetOptionAsBool ( " RefreshAllUserCodes " , & m_refreshUserCodes ) ; } } else { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Not ▁ Requesting ▁ additional ▁ UserCode ▁ Slots ▁ as ▁ RefreshAllUserCodes ▁ is ▁ false , ▁ and ▁ slot ▁ % d ▁ is ▁ available " , i ) ; m_queryAll = false ; } } return true ; } return false ; } bool UserCode :: SetValue ( Value const & _value ) { if ( ( ValueID :: ValueType_Raw == _value . GetID ( ) . GetType ( ) ) && ( _value . GetID ( ) . GetIndex ( ) < UserCodeIndex_Refresh ) ) { ValueRaw const * value = static_cast < ValueRaw const * > ( & _value ) ; uint8 * s = value -> GetValue ( ) ; uint8 len = value -> GetLength ( ) ; if ( len > UserCodeLength ) { return false ; } m_userCodesStatus [ value -> GetID ( ) . GetIndex ( ) ] = UserCode_Occupied ; Msg * msg = new Msg ( " UserCodeCmd _ Set " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true ) ; msg -> SetInstance ( this , _value . GetID ( ) . GetInstance ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 4 + len ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserCodeCmd_Set ) ; msg -> Append ( value -> GetID ( ) . GetIndex ( ) ) ; msg -> Append ( UserCode_Occupied ) ; for ( uint8 i = 0 ; i < len ; i ++ ) { msg -> Append ( s [ i ] ) ; } msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , Driver :: MsgQueue@@ _Send ) ; return true ; } if ( ( ValueID :: ValueType_Button == _value . GetID ( ) . GetType ( ) ) && ( _value . GetID ( ) . GetIndex ( ) == UserCodeIndex_Refresh ) ) { m_refreshUserCodes = true ; m_currentCode = 1 ; m_queryAll = true ; RequestValue ( 0 , m_currentCode , _value . GetID ( ) . GetInstance ( ) , Driver :: MsgQueue_Query ) ; return true ; } return false ; } void UserCode :: CreateVars ( uint8 const _instance ) { if ( Node * node = GetNodeUnsafe ( ) ) { node -> CreateValueByte ( ValueID :: ValueGenre_System , GetCommandClassId ( ) , _instance , UserCodeIndex_Count , " Code ▁ Count " , " " , true , false , 0 , 0 ) ; node -> CreateValue@@ Button ( ValueID :: ValueGenre_System , GetCommandClassId ( ) , _instance , UserCodeIndex_Refresh , " Refresh ▁ All ▁ UserCodes " , 0 ) ; } } </DOCUMENT>
<DOCUMENT_ID="dgrat/ANNet@@ GPGP@@ U/tree/master/examples/de@@ signer/ANNet@@ Designer@@ .cpp"> # include < QApplication > # include " gui / QMainWindow . h " int main ( int argc , char * argv [ ] ) { QApplication a ( argc , argv ) ; MainWindow w ; w . show ( ) ; return a . exec ( ) ; } </DOCUMENT>
<DOCUMENT_ID="hyuk-@@ kim-tmax/OF@@ ASM-test/tree/master/@@ Mtest/UNKNOWN/MVI@@ 01/main.cpp"> # include < stdlib . h > # include < string . h > extern int MVI01 ( char * p_0 , char * p_1 , char * p_2 ) ; int main ( ) { char * p_0 = ( char * ) malloc ( sizeof ( char ) * 7 ) ; char * p_1_0 = ( char * ) malloc ( sizeof ( char ) * 7 ) ; char * p_1 = ( char * ) & p_1_0 ; char * p_2 = ( char * ) malloc ( sizeof ( char ) * 3 ) ; strcpy ( p_0 , " HELLO ▁ " ) ; strcpy ( p_1_0 , " WORLD ▁ " ) ; strcpy ( p_2 , " ! ! " ) ; MVI01 ( p_0 , p_1 , p_2 ) ; MVI01 ( p_0 , p_1 , p_2 ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="kyoun@@ gchinse@@ o/aws-sdk-cpp/tree/master/aws-cpp-sdk-@@ s3/source/model/@@ Delete.cpp"> # include < aws / s3 / model / Delete . h > # include < aws / core / utils / xml / XmlSerializer . h > # include < aws / core / utils / StringUtils . h > # include < aws / core / utils / memory / stl / AWSStringStream . h > # include < utility > using namespace Aws :: S3 :: Model ; using namespace Aws :: Utils :: Xml ; using namespace Aws :: Utils ; Delete :: Delete ( ) : m_objectsHasBeenSet ( false ) , m_quiet ( false ) , m_quietHasBeenSet ( false ) { } Delete :: Delete ( const XmlNode & xmlNode ) : m_objectsHasBeenSet ( false ) , m_quiet ( false ) , m_quietHasBeenSet ( false ) { * this = xmlNode ; } Delete & Delete :: operator = ( const XmlNode & xmlNode ) { XmlNode resultNode = xmlNode ; if ( ! resultNode . IsNull ( ) ) { XmlNode objectsNode = resultNode . FirstChild ( " Objects " ) ; if ( ! objectsNode . IsNull ( ) ) { XmlNode objectsMember = objectsNode ; while ( ! objectsMember . IsNull ( ) ) { m_objects . push_back ( objectsMember ) ; objectsMember = objectsMember . NextNode ( " Object " ) ; } m_objectsHasBeenSet = true ; } XmlNode quietNode = resultNode . FirstChild ( " Quiet " ) ; if ( quietNode . IsNull ( ) ) { quietNode = resultNode ; } if ( ! quietNode . IsNull ( ) ) { m_quiet = StringUtils :: ConvertToBool ( StringUtils :: Trim ( quietNode . GetText ( ) . c_str ( ) ) . c_str ( ) ) ; m_quietHasBeenSet = true ; } } return * this ; } void Delete :: AddToNode ( XmlNode & parentNode ) const { Aws :: StringStream ss ; if ( m_objectsHasBeenSet ) { for ( const auto & item : m_objects ) { XmlNode objectsNode = parentNode . CreateChildElement ( " Object " ) ; item . AddToNode ( objectsNode ) ; } } if ( m_quietHasBeenSet ) { XmlNode quietNode = parentNode . CreateChildElement ( " Object " ) ; ss << m_quiet ; quietNode . SetText ( ss . str ( ) ) ; ss . str ( " " ) ; } } </DOCUMENT>
<DOCUMENT_ID="babym@@ annen/@@ theforgottenserver@@ -7.4/tree/master/src/items.cpp"> # include " otpch . h " # include " items . h " # include " spells . h " # include " movement . h " # include " weapons . h " # include " pugicast . h " uint32_t Items :: dwMajorVersion = 0 ; uint32_t Items :: dwMinorVersion = 0 ; uint32_t Items :: dwBuildNumber = 0 ; extern MoveEvents * g_moveEvents ; extern Weapons * g_weapons ; ItemType :: ItemType ( ) : group ( ITEM_GROUP_NONE ) , type ( ITEM_TYPE_NONE ) , id ( 0 ) , clientId ( 0 ) , stackable ( false ) , isAnimation ( false ) , weight ( 0 ) , levelDoor ( 0 ) , decayTime ( 0 ) , wieldInfo ( 0 ) , minReqLevel ( 0 ) , minReqMagicLevel ( 0 ) , charges ( 0 ) , maxHitChance ( - 1 ) , decayTo ( - 1 ) , attack ( 0 ) , defense ( 0 ) , extraDefense ( 0 ) , armor ( 0 ) , rotateTo ( 0 ) , runeMagLevel ( 0 ) , runeLevel ( 0 ) , combatType ( COMBAT_NONE ) , transformToOnUse ( 0 ) , transformToFree ( 0 ) , destroyTo ( 0 ) , maxTextLen ( 0 ) , writeOnceItemId ( 0 ) , transformEquipTo ( 0 ) , transformDeEquipTo ( 0 ) , maxItems ( 8 ) , slotPosition ( SLOTP_HAND ) , speed ( 0 ) , wareId ( 0 ) , magicEffect ( CONST_ME_NONE ) , bedPartnerDir ( DIRECTION_NONE ) , weaponType ( WEAPON_NONE ) , ammoType ( AMMO_NONE ) , shootType ( CONST_ANI_NONE ) , corpseType ( RACE_NONE ) , fluidSource ( FLUID_NONE ) , floorChange ( 0 ) , alwaysOnTopOrder ( 0 ) , lightLevel ( 0 ) , lightColor ( 0 ) , shootRange ( 1 ) , hitChance ( 0 ) , forceUse ( false ) , hasHeight ( false ) , walkStack ( true ) , blockSolid ( false ) , blockPickupable ( false ) , blockProjectile ( false ) , blockPathFind ( false ) , allowPickupable ( false ) , showDuration ( false ) , showCharges ( false ) , showAttributes ( false ) , replaceable ( true ) , pickupable ( false ) , rotatable ( false ) , useable ( false ) , moveable ( false ) , alwaysOnTop ( false ) , canReadText ( false ) , canWriteText ( false ) , isVertical ( false ) , isHorizontal ( false ) , isHangable ( false ) , allowDistRead ( false ) , lookThrough ( false ) , stopTime ( false ) , showCount ( true ) { } Items :: Items ( ) { items . reserve ( 20000 ) ; } Items :: ~ Items ( ) { clear ( ) ; } void Items :: clear ( ) { items . clear ( ) ; } bool Items :: reload ( ) { clear ( ) ; loadFromOtb ( " data / items / items . otb " ) ; if ( ! loadFromXml ( ) ) { return false ; } g_moveEvents -> reload ( ) ; g_weapons -> reload ( ) ; g_weapons -> loadDefault@@ s ( ) ; return true ; } FILELO@@ ADER_ERRORS Items :: loadFromOtb ( const std :: string & file ) { FileLoader f ; if ( ! f . openFile ( file . c_str ( ) , " OTBI " ) ) { return f . getError ( ) ; } uint32_t type ; NODE node = f . getChildNode ( NO_NODE , type ) ; PropStream props ; if ( f . getProps ( node , props ) ) { uint32_t flags ; if ( ! props . read < uint32_t > ( flags ) ) { return ERROR_INVALID_FORMAT ; } uint8_t attr ; if ( ! props . read < uint8_t > ( attr ) ) { return ERROR_INVALID_FORMAT ; } if ( attr == ROOT_ATTR@@ _VERSION ) { uint16_t datalen ; if ( ! props . read < uint16_t > ( datalen ) ) { return ERROR_INVALID_FORMAT ; } if ( datalen != sizeof ( VERSIONINFO ) ) { return ERROR_INVALID_FORMAT ; } VERSIONINFO vi ; if ( ! props . read ( vi ) ) { return ERROR_INVALID_FORMAT ; } Items :: dwMajorVersion = vi . dwMajorVersion ; Items :: dwMinorVersion = vi . dwMinorVersion ; Items :: dwBuildNumber = vi . dwBuildNumber ; } } if ( Items :: dwMajorVersion == 0xFFFFFFFF ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromOtb ] ▁ items . otb ▁ using ▁ generic ▁ client ▁ version . " << std :: endl ; } else if ( Items :: dwMajorVersion > 2 ) { std :: cout << " New ▁ version ▁ detected , ▁ an ▁ older ▁ version ▁ of ▁ items . otb ▁ is ▁ required . " << std :: endl ; return ERROR_INVALID_FORMAT ; } else if ( Items :: dwMinorVersion < CLIENT_VERSION_@@ 740 ) { std :: cout << " A ▁ newer ▁ version ▁ of ▁ items . otb ▁ is ▁ required . " << std :: endl ; return ERROR_INVALID_FORMAT ; } node = f . getChildNode ( node , type ) ; while ( node != NO_NODE ) { PropStream stream ; if ( ! f . getProps ( node , stream ) ) { return f . getError ( ) ; } uint32_t flags ; if ( ! stream . read < uint32_t > ( flags ) ) { return ERROR_INVALID_FORMAT ; } uint16_t serverId = 0 ; uint16_t clientId = 0 ; uint16_t speed = 0 ; uint16_t wareId = 0 ; uint8_t lightLevel = 0 ; uint8_t lightColor = 0 ; uint8_t alwaysOnTopOrder = 0 ; uint8_t attrib ; while ( stream . read < uint8_t > ( attrib ) ) { uint16_t datalen ; if ( ! stream . read < uint16_t > ( datalen ) ) { return ERROR_INVALID_FORMAT ; } switch ( attrib ) { case ITEM_ATTR_SERVERID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( serverId ) ) { return ERROR_INVALID_FORMAT ; } if ( serverId > 20000 && serverId < 20100 ) { serverId -= 20000 ; } break ; } case ITEM_ATTR_CLIENTID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( clientId ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_SPEED : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( speed ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_LIGHT2 : { if ( datalen != sizeof ( lightBlock2 ) ) { return ERROR_INVALID_FORMAT ; } lightBlock2 lb2 ; if ( ! stream . read ( lb2 ) ) { return ERROR_INVALID_FORMAT ; } lightLevel = static_cast < uint8_t > ( lb2 . lightLevel ) ; lightColor = static_cast < uint8_t > ( lb2 . lightColor ) ; break ; } case ITEM_ATTR_TOPORDER : { if ( datalen != sizeof ( uint8_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint8_t > ( alwaysOnTopOrder ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_WAREID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( wareId ) ) { return ERROR_INVALID_FORMAT ; } break ; } default : { if ( ! stream . skip ( datalen ) ) { return ERROR_INVALID_FORMAT ; } break ; } } } reverseItemMap . emplace ( clientId , serverId ) ; if ( serverId >= items . size ( ) ) { items . resize ( serverId + 1 ) ; } ItemType & iType = items [ serverId ] ; iType . group = static_cast < itemgroup_t > ( type ) ; switch ( type ) { case ITEM_GROUP_CONTAINER : iType . type = ITEM_TYPE_CONTAINER ; break ; case ITEM_GROUP_DOOR : iType . type = ITEM_TYPE_DOOR ; break ; case ITEM_GROUP_MAGICFIELD : iType . type = ITEM_TYPE_MAGICFIELD ; break ; case ITEM_GROUP_TELEPORT : iType . type = ITEM_TYPE_TELEPORT ; break ; case ITEM_GROUP_NONE : case ITEM_GROUP_GROUND : case ITEM_GROUP@@ _SPLASH : case ITEM_GROUP_FLUID : case ITEM_GROUP_CHARGES : case ITEM_GROUP_DEPRECATED : break ; default : return ERROR_INVALID_FORMAT ; } iType . blockSolid = hasBitSet ( FLAG_BLOCK_SOLID , flags ) ; iType . blockProjectile = hasBitSet ( FLAG_BLOCK_PROJECTI@@ LE , flags ) ; iType . blockPathFind = hasBitSet ( FLAG_BLOCK_PATHFIN@@ D , flags ) ; iType . hasHeight = hasBitSet ( FLAG_HAS_@@ HEIGHT , flags ) ; iType . useable = hasBitSet ( FLAG_USE@@ ABLE , flags ) ; iType . pickupable = hasBitSet ( FLAG_PIC@@ KUPABLE , flags ) ; iType . moveable = hasBitSet ( FLAG_MOVEABLE , flags ) ; iType . stackable = hasBitSet ( FLAG_STACK@@ ABLE , flags ) ; iType . alwaysOnTop = hasBitSet ( FLAG_ALWAYSON@@ TOP , flags ) ; iType . isVertical = hasBitSet ( FLAG_VERTICAL , flags ) ; iType . isHorizontal = hasBitSet ( FLAG_HORIZON@@ TAL , flags ) ; iType . isHangable = hasBitSet ( FLAG_HANGABLE , flags ) ; iType . allowDistRead = hasBitSet ( FLAG_ALLO@@ WDISTREAD , flags ) ; iType . rotatable = hasBitSet ( FLAG_ROTAT@@ ABLE , flags ) ; iType . canReadText = hasBitSet ( FLAG_READ@@ ABLE , flags ) ; iType . lookThrough = hasBitSet ( FLAG_LOOK@@ THROUGH , flags ) ; iType . forceUse = hasBitSet ( FLAG_FORCE@@ USE , flags ) ; iType . id = serverId ; iType . clientId = clientId ; iType . speed = speed ; iType . lightLevel = lightLevel ; iType . lightColor = lightColor ; iType . wareId = wareId ; iType . alwaysOnTopOrder = alwaysOnTopOrder ; node = f . getNextNode ( node , type ) ; } items . shrink_to_@@ fit ( ) ; return ERROR_NONE ; } bool Items :: loadFromXml ( ) { pugi :: xml_d@@ ocument doc ; pugi :: xml_parse@@ _result result = doc . load_file ( " data / items / items . xml " ) ; if ( ! result ) { printXML@@ Error ( " Error ▁ - ▁ Items : : loadFromXml " , " data / items / items . xml " , result ) ; return false ; } for ( auto itemNode : doc . child ( " items " ) . children ( ) ) { pugi :: xml_attribute idAttribute = itemNode . attribute ( " id " ) ; if ( idAttribute ) { parseItemNode ( itemNode , pugi :: cast < uint16_t > ( idAttribute . value ( ) ) ) ; continue ; } pugi :: xml_attribute fromIdAttribute = itemNode . attribute ( " fromid " ) ; if ( ! fromIdAttribute ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromXml ] ▁ No ▁ item ▁ id ▁ found " << std :: endl ; continue ; } pugi :: xml_attribute toIdAttribute = itemNode . attribute ( " toid " ) ; if ( ! toIdAttribute ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromXml ] ▁ fromid ▁ ( " << fromIdAttribute . value ( ) << " ) ▁ without ▁ toid " << std :: endl ; continue ; } uint16_t id = pugi :: cast < uint16_t > ( fromIdAttribute . value ( ) ) ; uint16_t toId = pugi :: cast < uint16_t > ( toIdAttribute . value ( ) ) ; while ( id <= toId ) { parseItemNode ( itemNode , id ++ ) ; } } return true ; } void Items :: parseItemNode ( const pugi :: xml_node & itemNode , uint16_t id ) { if ( id > 20000 && id < 20100 ) { id -= 20000 ; if ( id >= items . size ( ) ) { items . resize ( id + 1 ) ; } ItemType & iType = items [ id ] ; iType . id = id ; } ItemType & it = getItemType ( id ) ; if ( it . id == 0 ) { return ; } it . name = itemNode . attribute ( " name " ) . as_string ( ) ; pugi :: xml_attribute articleAttribute = itemNode . attribute ( " article " ) ; if ( articleAttribute ) { it . article = articleAttribute . as_string ( ) ; } pugi :: xml_attribute pluralAttribute = itemNode . attribute ( " plural " ) ; if ( pluralAttribute ) { it . pluralName = pluralAttribute . as_string ( ) ; } for ( auto attributeNode : itemNode . children ( ) ) { pugi :: xml_attribute keyAttribute = attributeNode . attribute ( " key " ) ; if ( ! keyAttribute ) { continue ; } pugi :: xml_attribute valueAttribute = attributeNode . attribute ( " value " ) ; if ( ! valueAttribute ) { continue ; } std :: string tmpStrValue = asLowerCaseString ( keyAttribute . as_string ( ) ) ; if ( tmpStrValue == " type " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " key " ) { it . type = ITEM_TYPE_KEY ; } else if ( tmpStrValue == " magicfield " ) { it . type = ITEM_TYPE_MAGICFIELD ; } else if ( tmpStrValue == " container " ) { it . group = ITEM_GROUP_CONTAINER ; it . type = ITEM_TYPE_CONTAINER ; } else if ( tmpStrValue == " depot " ) { it . type = ITEM_TYPE_DEPO@@ T ; } else if ( tmpStrValue == " mailbox " ) { it . type = ITEM_TYPE_MAIL@@ BOX ; } else if ( tmpStrValue == " trashholder " ) { it . type = ITEM_TYPE_TRAS@@ HHOLDER ; } else if ( tmpStrValue == " teleport " ) { it . type = ITEM_TYPE_TELEPORT ; } else if ( tmpStrValue == " door " ) { it . type = ITEM_TYPE_DOOR ; } else if ( tmpStrValue == " bed " ) { it . type = ITEM_TYPE_BED ; } else if ( tmpStrValue == " rune " ) { it . type = ITEM_TYPE_RUN@@ E ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ type : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " description " ) { it . description = valueAttribute . as_string ( ) ; } else if ( tmpStrValue == " runespellname " ) { it . runeSpellName = valueAttribute . as_string ( ) ; } else if ( tmpStrValue == " weight " ) { it . weight = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showcount " ) { it . showCount = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " armor " ) { it . armor = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " defense " ) { it . defense = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " extradef " ) { it . extraDefense = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " attack " ) { it . attack = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " rotateto " ) { it . rotateTo = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " moveable " || tmpStrValue == " movable " ) { it . moveable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " blockproj@@ ectile " ) { it . blockProjectile = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " allowpickupable " || tmpStrValue == " pickupable " ) { it . allowPickupable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " floorchange " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " down " ) { it . floorChange = TILESTATE_FLOORCHANGE_DOWN ; } else if ( tmpStrValue == " north " ) { it . floorChange = TILESTATE_FLOORCHANGE_NORTH ; } else if ( tmpStrValue == " south " ) { it . floorChange = TILESTATE_FLOORCHANGE_SOUTH ; } else if ( tmpStrValue == " southalt " ) { it . floorChange = TILESTATE_FLOORCHANGE_SOUTH@@ _ALT ; } else if ( tmpStrValue == " west " ) { it . floorChange = TILESTATE_FLOORCHANGE_WEST ; } else if ( tmpStrValue == " east " ) { it . floorChange = TILESTATE_FLOORCHANGE_EAST ; } else if ( tmpStrValue == " eastalt " ) { it . floorChange = TILESTATE_FLOORCHANGE_EAST_ALT ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ floorChange : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " corpsetype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " venom " ) { it . corpseType = RACE_VENOM ; } else if ( tmpStrValue == " blood " ) { it . corpseType = RACE_BLOOD ; } else if ( tmpStrValue == " undead " ) { it . corpseType = RACE_UNDEAD ; } else if ( tmpStrValue == " fire " ) { it . corpseType = RACE_FIR@@ E ; } else if ( tmpStrValue == " energy " ) { it . corpseType = RACE_ENERGY ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ corpseType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " containersize " ) { it . maxItems = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fluidsource " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " water " ) { it . fluidSource = FLUID_WATER ; } else if ( tmpStrValue == " blood " ) { it . fluidSource = FLUID_BLOOD ; } else if ( tmpStrValue == " beer " ) { it . fluidSource = FLUID_BE@@ ER ; } else if ( tmpStrValue == " slime " ) { it . fluidSource = FLUID_SLIME ; } else if ( tmpStrValue == " lemonade " ) { it . fluidSource = FLUID_LEM@@ ONADE ; } else if ( tmpStrValue == " milk " ) { it . fluidSource = FLUID_MILK ; } else if ( tmpStrValue == " mana " ) { it . fluidSource = FLUID_MANA ; } else if ( tmpStrValue == " life " ) { it . fluidSource = FLUID_LIF@@ E ; } else if ( tmpStrValue == " oil " ) { it . fluidSource = FLUID_OIL ; } else if ( tmpStrValue == " urine " ) { it . fluidSource = FLUID_URINE ; } else if ( tmpStrValue == " coconut " ) { it . fluidSource = FLUID_CO@@ CONUT@@ MILK ; } else if ( tmpStrValue == " wine " ) { it . fluidSource = FLUID_WINE ; } else if ( tmpStrValue == " mud " ) { it . fluidSource = FLUID_MUD ; } else if ( tmpStrValue == " fruit@@ juice " ) { it . fluidSource = FLUID_F@@ RUITJU@@ ICE ; } else if ( tmpStrValue == " lava " ) { it . fluidSource = FLUID_LAV@@ A ; } else if ( tmpStrValue == " rum " ) { it . fluidSource = FLUID_RUM ; } else if ( tmpStrValue == " swamp " ) { it . fluidSource = FLUID_SWAM@@ P ; } else if ( tmpStrValue == " tea " ) { it . fluidSource = FLUID_TEA ; } else if ( tmpStrValue == " mead " ) { it . fluidSource = FLUID_MEAD ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ fluidSource : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " readable " ) { it . canReadText = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " writeable " ) { it . canWriteText = valueAttribute . as_bool ( ) ; it . canReadText = it . canWriteText ; } else if ( tmpStrValue == " maxtext@@ len " ) { it . maxTextLen = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " writeonce@@ itemid " ) { it . writeOnceItemId = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " weapontype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " sword " ) { it . weaponType = WEAPON_SWORD ; } else if ( tmpStrValue == " club " ) { it . weaponType = WEAPON_CLUB ; } else if ( tmpStrValue == " axe " ) { it . weaponType = WEAPON_AXE ; } else if ( tmpStrValue == " shield " ) { it . weaponType = WEAPON_SHIELD ; } else if ( tmpStrValue == " distance " ) { it . weaponType = WEAPON_DISTANCE ; } else if ( tmpStrValue == " wand " ) { it . weaponType = WEAPON_WAND ; } else if ( tmpStrValue == " ammunition " ) { it . weaponType = WEAPON_AMMO ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ weaponType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " slottype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " head " ) { it . slotPosition |= SLOTP_HEAD ; } else if ( tmpStrValue == " body " ) { it . slotPosition |= SLOTP_ARMOR ; } else if ( tmpStrValue == " legs " ) { it . slotPosition |= SLOTP_LEGS ; } else if ( tmpStrValue == " feet " ) { it . slotPosition |= SLOTP_FEE@@ T ; } else if ( tmpStrValue == " backpack " ) { it . slotPosition |= SLOTP_BACK@@ PACK ; } else if ( tmpStrValue == " two - handed " ) { it . slotPosition |= SLOTP_TWO_@@ HAND ; } else if ( tmpStrValue == " right - hand " ) { it . slotPosition &= ~ SLOTP_LEFT ; } else if ( tmpStrValue == " left - hand " ) { it . slotPosition &= ~ SLOTP_RIGHT ; } else if ( tmpStrValue == " necklace " ) { it . slotPosition |= SLOTP_NEC@@ KLACE ; } else if ( tmpStrValue == " ring " ) { it . slotPosition |= SLOTP_RING ; } else if ( tmpStrValue == " ammo " ) { it . slotPosition |= SLOTP_AMMO ; } else if ( tmpStrValue == " hand " ) { it . slotPosition |= SLOTP_HAND ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ slotType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " ammotype " ) { it . ammoType = getAmmoType ( valueAttribute . as_string ( ) ) ; if ( it . ammoType == AMMO_NONE ) { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ ammoType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " shoottype " ) { ShootType_t shoot = getShootType ( valueAttribute . as_string ( ) ) ; if ( shoot != CONST_ANI_NONE ) { it . shootType = shoot ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ shootType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " effect " ) { MagicEffectClasses effect = getMagicEffect ( valueAttribute . as_string ( ) ) ; if ( effect != CONST_ME_NONE ) { it . magicEffect = effect ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ effect : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " range " ) { it . shootRange = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " stopduration " ) { it . stopTime = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " decayto " ) { it . decayTo = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " transformequipto " ) { it . transformEquipTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " transformdeequipto " ) { it . transformDeEquipTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " duration " ) { it . decayTime = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showduration " ) { it . showDuration = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " charges " ) { it . charges = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showcharges " ) { it . showCharges = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " showattributes " ) { it . showAttributes = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " hitchance " ) { it . hitChance = std :: min < int8_t > ( 100 , std :: max < int8_t > ( - 100 , pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ) ) ; } else if ( tmpStrValue == " maxhitchance " ) { it . maxHitChance = std :: min < uint32_t > ( 100 , pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " invisible " ) { it . getAbilities ( ) . invisible = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " speed " ) { it . getAbilities ( ) . speed = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " healthgain " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . healthGain = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " healthticks " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . healthTicks = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " managain " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . manaGain = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " manatick@@ s " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . manaTicks = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " manashield " ) { it . getAbilities ( ) . manaShield = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " skillsword " ) { it . getAbilities ( ) . skills [ SKILL_SWORD ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillaxe " ) { it . getAbilities ( ) . skills [ SKILL_AX@@ E ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillclub " ) { it . getAbilities ( ) . skills [ SKILL_CLUB ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skilldist " ) { it . getAbilities ( ) . skills [ SKILL_DISTANCE ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillfish " ) { it . getAbilities ( ) . skills [ SKILL_FISHING ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillshield " ) { it . getAbilities ( ) . skills [ SKILL_SHIELD ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillfist " ) { it . getAbilities ( ) . skills [ SKILL_FIST ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxhitpoints " ) { it . getAbilities ( ) . stats [ STAT_MAXHITPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxhitpointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAXHITPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxmanapoints " ) { it . getAbilities ( ) . stats [ STAT_MAXMANAPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxmanapointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAXMANAPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " magicpoints " || tmpStrValue == " magiclevel@@ points " ) { it . getAbilities ( ) . stats [ STAT_MAGICPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " magicpointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAGICPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercentenergy " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercentfire " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercentpoison " || tmpStrValue == " fieldabsor@@ percentearth " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentall " || tmpStrValue == " absorbpercentallelements " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; for ( size_t i = 0 ; i < COMBAT_COUNT ; ++ i ) { abilities . absorbPercent [ i ] += value ; } } else if ( tmpStrValue == " absorbpercente@@ lements " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += value ; } else if ( tmpStrValue == " absorbpercentmagic " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += value ; } else if ( tmpStrValue == " absorbpercentenergy " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentfire " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentpoison " || tmpStrValue == " absorbpercentearth " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentlifed@@ rain " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_LIF@@ EDRAIN ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentmanadrain " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_MAN@@ ADRAIN ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentphysical " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_PHYSICALDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercenthe@@ aling " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_HEAL@@ ING ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentundefined " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_UNDEFIN@@ EDDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " suppressdrunk " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_DRUNK ; } } else if ( tmpStrValue == " suppressenergy " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_ENERGY ; } } else if ( tmpStrValue == " suppressfire " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_FIRE ; } } else if ( tmpStrValue == " suppresspoison " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_POISON ; } } else if ( tmpStrValue == " suppressphysical " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_BLEEDING ; } } else if ( tmpStrValue == " field " ) { it . group = ITEM_GROUP_MAGICFIELD ; it . type = ITEM_TYPE_MAGICFIELD ; CombatType_t combatType = COMBAT_NONE ; ConditionDamage * conditionDamage = nullptr ; tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " fire " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_FIRE ) ; combatType = COMBAT_FIREDAMAGE ; } else if ( tmpStrValue == " energy " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_ENERGY ) ; combatType = COMBAT_ENERGYDAMAGE ; } else if ( tmpStrValue == " poison " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_POISON ) ; combatType = COMBAT_EARTHDAMAGE ; } else if ( tmpStrValue == " physical " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_BLEEDING ) ; combatType = COMBAT_PHYSICALDAMAGE ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ field ▁ value : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } if ( combatType != COMBAT_NONE ) { it . combatType = combatType ; it . conditionDamage . reset ( conditionDamage ) ; uint32_t ticks = 0 ; int32_t damage = 0 ; int32_t start = 0 ; int32_t count = 1 ; for ( auto subAttributeNode : attributeNode . children ( ) ) { pugi :: xml_attribute subKeyAttribute = subAttributeNode . attribute ( " key " ) ; if ( ! subKeyAttribute ) { continue ; } pugi :: xml_attribute subValueAttribute = subAttributeNode . attribute ( " value " ) ; if ( ! subValueAttribute ) { continue ; } tmpStrValue = asLowerCaseString ( subKeyAttribute . as_string ( ) ) ; if ( tmpStrValue == " ticks " ) { ticks = pugi :: cast < uint32_t > ( subValueAttribute . value ( ) ) ; } else if ( tmpStrValue == " count " ) { count = std :: max < int32_t > ( 1 , pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " start " ) { start = std :: max < int32_t > ( 0 , pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " damage " ) { damage = - pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ; if ( start > 0 ) { std :: list < int32_t > damageList ; ConditionDamage :: generateDamage@@ List ( damage , start , damageList ) ; for ( int32_t damageValue : damageList ) { conditionDamage -> addDamage ( 1 , ticks , - damageValue ) ; } start = 0 ; } else { conditionDamage -> addDamage ( count , ticks , damage ) ; } } } conditionDamage -> setParam ( CONDITION_PARAM_FIELD , 1 ) ; if ( conditionDamage -> getTotalDamage ( ) > 0 ) { conditionDamage -> setParam ( CONDITION_PARAM_FORCE@@ UPDATE , 1 ) ; } } } else if ( tmpStrValue == " replaceable " ) { it . replaceable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " partnerdirection " ) { it . bedPartnerDir = getDirection ( valueAttribute . as_string ( ) ) ; } else if ( tmpStrValue == " leveldoor " ) { it . levelDoor = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " sleeper " ) { uint16_t value = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; it . transformToOnUse = value ; ItemType & other = getItemType ( value ) ; if ( other . transformToFree == 0 ) { other . transformToFree = it . id ; } if ( it . transformToOnUse == 0 ) { it . transformToOnUse = value ; } } else if ( tmpStrValue == " transformto " ) { it . transformToFree = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " destroyto " ) { it . destroyTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " elementearth " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_EARTHDAMAGE ; } else if ( tmpStrValue == " elementfire " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_FIREDAMAGE ; } else if ( tmpStrValue == " elementenergy " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_ENERGYDAMAGE ; } else if ( tmpStrValue == " walkstack " ) { it . walkStack = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " blocking " ) { it . blockSolid = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " allowdist@@ read " ) { it . allowDistRead = booleanString ( valueAttribute . as_string ( ) ) ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ key ▁ value : ▁ " << keyAttribute . as_string ( ) << std :: endl ; } } if ( ( it . transformToFree != 0 || it . transformToOnUse != 0 || it . transformToOnUse != 0 ) && it . type != ITEM_TYPE_BED ) { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Item ▁ " << it . id << " ▁ is ▁ not ▁ set ▁ as ▁ a ▁ bed - type " << std :: endl ; } } ItemType & Items :: getItemType ( size_t id ) { if ( id < items . size ( ) ) { return items [ id ] ; } return items . front ( ) ; } const ItemType & Items :: getItemType ( size_t id ) const { if ( id < items . size ( ) ) { return items [ id ] ; } return items . front ( ) ; } const ItemType & Items :: getItemIdByClient@@ Id ( uint16_t spriteId ) const { auto it = reverseItemMap . find ( spriteId ) ; if ( it != reverseItemMap . end ( ) ) { return getItemType ( it -> second ) ; } return items . front ( ) ; } uint16_t Items :: getItemIdByName ( const std :: string & name ) { if ( name . empty ( ) ) { return 0 ; } const char * itemName = name . c_str ( ) ; for ( size_t i = 100 , size = items . size ( ) ; i < size ; ++ i ) { if ( strcasecmp ( itemName , items [ i ] . name . c_str ( ) ) == 0 ) { return i ; } } return 0 ; } </DOCUMENT>
<DOCUMENT_ID="Horiz@@ on-Blue/play@@ ground/tree/master/So@@ lutions-to-@@ OJs/USACO/@@ Chapter1/1.1/@@ 02_your-ride@@ -is-here.cpp"> # include < iostream > # include < fstream > # include < string > using namespace std ; int main ( ) { ofstream fout ( " ride . out " ) ; ifstream fin ( " ride . in " ) ; string a , b ; fin >> a >> b ; int anum = 1 , bnum = 1 ; for ( char c : a ) anum *= c - ' A ' + 1 ; for ( char c : b ) bnum *= c - ' A ' + 1 ; if ( anum % 47 == bnum % 47 ) fout << " GO " << endl ; else fout << " STAY " << endl ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="Chil@@ ledheart/v@@ box/tree/master/src/libs/xp@@ com18a4/@@ nsprpub/pr@@ /src/cplu@@ s/rcinr@@ val.cpp"> # include " rcinrval . h " RCInterval :: ~ RCInterval ( ) { } RCInterval :: RCInterval ( RCInterval :: RCReserved@@ Interval special ) : RCBase ( ) { switch ( special ) { case RCInterval :: now : interval = PR_Interval@@ Now ( ) ; break ; case RCInterval :: no_timeout : interval = PR_INTERVAL_NO_TIME@@ OUT ; break ; case RCInterval :: no_wait : interval = PR_INTERVAL_NO_WAIT ; break ; default : break ; } } </DOCUMENT>
<DOCUMENT_ID="gavo@@ ski/@@ audacity@@ /tree/master/lib-src@@ /taglib/tests/test_map@@ .cpp"> # include < cppunit / extensions / HelperMacros . h > # include < tstring . h > # include < tmap . h > using namespace std ; using namespace TagLib ; class TestMap : public CppUnit :: TestFixture { CPPUNIT_TEST_SUITE ( TestMap ) ; CPPUNIT_TEST ( testInsert ) ; CPPUNIT_TEST_SUITE_END ( ) ; public : void testInsert ( ) { Map < String , int > m ; m . insert ( " foo " , 3 ) ; CPPUNIT_ASSERT_EQUAL ( 3 , m [ " foo " ] ) ; m . insert ( " foo " , 7 ) ; CPPUNIT_ASSERT_EQUAL ( 7 , m [ " foo " ] ) ; } } ; CPPUNIT_TEST_SUITE_REGISTRATION ( TestMap ) ; </DOCUMENT>
<DOCUMENT_ID="dandan94@@ /OpenGLTest/tree/master/@@ finalOpenGL@@ /HelloGLFW@@ /lib/boost_1_@@ 59_0/libs/@@ lexical_cast@@ /test/lexical_ca@@ st_iterator_@@ range_test.cpp"> # include < boost / config . hpp > # if defined ( __INTEL_COMPILER ) # pragma warning ( disable : 193 383 488 981 1418 1419 ) # elif defined ( BOOST_MSV@@ C ) # pragma warning ( disable : 4097 4100 4121 4127 4146 4244 4245 4511 4512 4701 4800 ) # endif # include < boost / lexical_cast . hpp > # include < boost / test / unit_test . hpp > # include < boost / range / iterator_range . hpp > using namespace boost ; # if defined ( BOOST_NO_STRING@@ STREAM ) || defined ( BOOST_NO_STD_WSTRING ) # define BOOST_LCAST_NO_WCHAR_T # endif # if ! defined ( BOOST_NO_CXX11_CHAR16_T ) && ! defined ( BOOST_NO_CXX11_UNICODE_LITERALS ) && ! defined ( _LIBCPP_VERSION ) # define BOOST_LC_RUNU16 # endif # if ! defined ( BOOST_NO_CXX11_CHAR32_T ) && ! defined ( BOOST_NO_CXX11_UNICODE_LITERALS ) && ! defined ( _LIBCPP_VERSION ) # define BOOST_LC_RUNU32 # endif struct class_with_user_defined_sream_operators { int i ; operator int ( ) const { return i ; } } ; template < class CharT > inline std :: basic_istream < CharT > & operator >> ( std :: basic_istream < CharT > & istr , class_with_user_defined_sream_operators & rhs ) { return istr >> rhs . i ; } template < class RngT > void do_test_iterator_range_impl ( const RngT & rng ) { BOOST_CHECK_EQUAL ( lexical_cast < int > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < int > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned int > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned int > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < short > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < short > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned short > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned short > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < long int > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < long int > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned long int > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned long int > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; # ifdef BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng . begin ( ) , rng . size ( ) ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng ) , 1.0 ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng . begin ( ) , rng . size ( ) ) , 1.0 ) ; # ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng ) , 1.0L ) ; BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng . begin ( ) , rng . size ( ) ) , 1.0L ) ; # endif BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( rng ) , 1 ) ; # endif # if defined ( BOOST_HAS_LONG_LONG ) BOOST_CHECK_EQUAL ( lexical_cast < boost :: ulong_long_type > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: ulong_long_type > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: long_long_type > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: long_long_type > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; # elif defined ( BOOST_HAS_MS_INT64 ) BOOST_CHECK_EQUAL ( lexical_cast < unsigned __int64 > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned __int64 > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < __int64 > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < __int64 > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; # endif } template < class CharT > void test_it_range_using_any_chars ( CharT * one , CharT * eleven ) { typedef CharT test_char_type ; iterator_range < test_char_type * > rng1 ( one , one + 1 ) ; do_test_iterator_range_impl ( rng1 ) ; iterator_range < const test_char_type * > crng1 ( one , one + 1 ) ; do_test_iterator_range_impl ( crng1 ) ; iterator_range < test_char_type * > rng2 ( eleven , eleven + 1 ) ; do_test_iterator_range_impl ( rng2 ) ; iterator_range < const test_char_type * > crng2 ( eleven , eleven + 1 ) ; do_test_iterator_range_impl ( crng2 ) ; } template < class CharT > void test_it_range_using_char ( CharT * one , CharT * eleven ) { typedef CharT test_char_type ; iterator_range < test_char_type * > rng1 ( one , one + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( rng1 ) , "1" ) ; iterator_range < const test_char_type * > crng1 ( one , one + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( crng1 ) , "1" ) ; iterator_range < test_char_type * > rng2 ( eleven , eleven + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( rng2 ) , "1" ) ; iterator_range < const test_char_type * > crng2 ( eleven , eleven + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( crng2 ) , "1" ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng1 ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng1 ) , 1.0 ) ; # ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng1 ) , 1.0L ) ; # endif BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( rng1 ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( crng2 ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( crng2 ) , 1.0 ) ; # ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS BOOST_CHECK_EQUAL ( lexical_cast < long double > ( crng2 ) , 1.0L ) ; # endif BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( crng2 ) , 1 ) ; # ifndef BOOST_LCAST_NO_WCHAR_T BOOST_CHECK ( lexical_cast < std :: wstring > ( rng1 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( crng1 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( rng2 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( crng2 ) == L " 1" ) ; # endif # if defined ( BOOST_LC_RUNU16 ) && defined ( BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES ) typedef std :: basic_string < char16_t > my_char16_string ; BOOST_CHECK ( lexical_cast < my_char16_string > ( rng1 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( crng1 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( rng2 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( crng2 ) == u " 1" ) ; # endif # if defined ( BOOST_LC_RUNU32 ) && defined ( BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES ) typedef std :: basic_string < char32_t > my_char32_string ; BOOST_CHECK ( lexical_cast < my_char32_string > ( rng1 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( crng1 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( rng2 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( crng2 ) == U " 1" ) ; # endif } void test_char_iterator_ranges ( ) { typedef char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; } void test_unsigned_char_iterator_ranges ( ) { typedef unsigned char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; } void test_signed_char_iterator_ranges ( ) { typedef signed char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; } void test_wchar_iterator_ranges ( ) { # ifndef BOOST_LCAST_NO_WCHAR_T typedef wchar_t test_char_type ; test_char_type data1 [ ] = L " 1" ; test_char_type data2 [ ] = L " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; # endif BOOST_CHECK ( true ) ; } void test_char16_iterator_ranges ( ) { # if defined ( BOOST_LC_RUNU16 ) typedef char16_t test_char_type ; test_char_type data1 [ ] = u " 1" ; test_char_type data2 [ ] = u " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; # endif BOOST_CHECK ( true ) ; } void test_char32_iterator_ranges ( ) { # if defined ( BOOST_LC_RUNU32 ) typedef char32_t test_char_type ; test_char_type data1 [ ] = U " 1" ; test_char_type data2 [ ] = U " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; # endif BOOST_CHECK ( true ) ; } unit_test :: test_suite * init_unit_test_suite ( int , char * [ ] ) { unit_test :: test_suite * suite = BOOST_TEST_SUITE ( " lexical _ cast . ▁ Testing ▁ conversions ▁ using ▁ iterator _ range < > " ) ; suite -> add ( BOOST_TEST_CASE ( & test_char_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_unsigned_char_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_signed_char_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_wchar_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_char16_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_char32_iterator_ranges ) ) ; return suite ; } </DOCUMENT>
<DOCUMENT_ID="Nick@@ elMedia/phantomjs/tree/master/src/qt/qt@@ base/config.tests/@@ unix/evdev@@ /evdev.cpp"> # include < linux / input . h > # include < linux / kd . h > enum { e1 = ABS_PRESSURE , e2 = ABS_X , e3 = REL_X , e4 = SYN_@@ REPORT , } ; int main ( ) { :: input_event buf [ 32 ] ; ( void ) buf ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="zaclim@@ on/android_@@ kernel_s@@ amsung_kylepro/tree/master/@@ tools/gator@@ /daemon/@@ LocalCapture@@ .cpp"> # include < sys / stat . h > # include < sys / types . h > # include < dirent . h > # include < string . h > # include < stdlib . h > # include < unistd . h > # include " LocalCapture . h " # include " SessionData . h " # include " Logging . h " # include " OlyUtility . h " # include " EventsXML . h " LocalCapture :: LocalCapture ( ) { } LocalCapture :: ~ LocalCapture ( ) { } void LocalCapture :: createAPC@@ Directory ( char * target_path ) { gSessionData -> mAPCDir = createUniqueDirectory ( target_path , " . apc " ) ; if ( ( removeDirAndAllContents ( gSessionData -> mAPCDir ) != 0 || mkdir ( gSessionData -> mAPCDir , S_IRWXU | S_IRWXG | S_IROTH | S_IX@@ OTH ) != 0 ) ) { logg -> logError ( __FILE__ , __LINE__ , " Unable ▁ to ▁ create ▁ directory ▁ % s " , gSessionData -> mAPCDir ) ; handleException ( ) ; } } void LocalCapture :: write ( char * string ) { char file [ PATH_MAX ] ; snprintf ( file , PATH_MAX , " % s / session . xml " , gSessionData -> mAPCDir ) ; if ( util -> writeToDisk ( file , string ) < 0 ) { logg -> logError ( __FILE__ , __LINE__ , " Error ▁ writing ▁ % s \n Please ▁ verify ▁ the ▁ path . " , file ) ; handleException ( ) ; } EventsXML eventsXML ; eventsXML . write ( gSessionData -> mAPCDir ) ; } char * LocalCapture :: createUniqueDirectory ( const char * initialPath , const char * ending ) { char * output ; char path [ PATH_MAX ] ; if ( initialPath == 0 || strlen ( initialPath ) == 0 ) { logg -> logError ( __FILE__ , __LINE__ , " Missing ▁ - o ▁ command ▁ line ▁ option ▁ required ▁ for ▁ a ▁ local ▁ capture . " ) ; handleException ( ) ; } else if ( initialPath [ 0 ] != ' / ' ) { if ( getcwd ( path , PATH_MAX ) == 0 ) { logg -> logMessage ( " Unable ▁ to ▁ retrieve ▁ the ▁ current ▁ working ▁ directory " ) ; } strncat ( path , " / " , PATH_MAX - strlen ( path ) - 1 ) ; strncat ( path , initialPath , PATH_MAX - strlen ( path ) - 1 ) ; } else { strncpy ( path , initialPath , PATH_MAX ) ; path [ PATH_MAX - 1 ] = 0 ; } if ( strcmp ( & path [ strlen ( path ) - strlen ( ending ) ] , ending ) != 0 ) { strncat ( path , ending , PATH_MAX - strlen ( path ) - 1 ) ; } output = strdup ( path ) ; return output ; } int LocalCapture :: removeDirAndAllContents ( char * path ) { int error = 0 ; struct stat mFileInfo ; if ( stat ( path , & mFileInfo ) == 0 ) { if ( mFileInfo . st_mode & S_IF@@ DIR ) { DIR * dir = opendir ( path ) ; dirent * entry = readdir ( dir ) ; while ( entry ) { if ( strcmp ( entry -> d_name , " . " ) != 0 && strcmp ( entry -> d_name , " . . " ) != 0 ) { char * newpath = ( char * ) malloc ( strlen ( path ) + strlen ( entry -> d_name ) + 2 ) ; sprintf ( newpath , " % s / % s " , path , entry -> d_name ) ; error = removeDirAndAllContents ( newpath ) ; free ( newpath ) ; if ( error ) { break ; } } entry = readdir ( dir ) ; } closedi@@ r ( dir ) ; if ( error == 0 ) { error = rmdir ( path ) ; } } else { error = remove ( path ) ; } } return error ; } void LocalCapture :: copyImages ( ImageLink@@ List * ptr ) { char dstfilename [ PATH_MAX ] ; while ( ptr ) { strncpy ( dstfilename , gSessionData -> mAPCDir , PATH_MAX ) ; dstfilename [ PATH_MAX - 1 ] = 0 ; if ( gSessionData -> mAPCDir [ strlen ( gSessionData -> mAPCDir ) - 1 ] != ' / ' ) { strncat ( dstfilename , " / " , PATH_MAX - strlen ( dstfilename ) - 1 ) ; } strncat ( dstfilename , util -> getFilePart ( ptr -> path ) , PATH_MAX - strlen ( dstfilename ) - 1 ) ; if ( util -> copyFile ( ptr -> path , dstfilename ) ) { logg -> logMessage ( " copied ▁ file ▁ % s ▁ to ▁ % s " , ptr -> path , dstfilename ) ; } else { logg -> logMessage ( " copy ▁ of ▁ file ▁ % s ▁ to ▁ % s ▁ failed " , ptr -> path , dstfilename ) ; } ptr = ptr -> next ; } } </DOCUMENT>
<DOCUMENT_ID="jamesfowk@@ es/DataLogger@@ /tree/master/libraries/DLDataField@@ /DLDataField.Manager.cpp"> # ifdef ARDUIN@@ O # include < Arduino . h > # else # include < stdint . h > # include < stdio . h > # include < string . h > # endif # ifdef TEST # include < iostream > # endif # include " DLUtility . Averager . h " # include " DLDataField . Types . h " # include " DLDataField . h " # include " DLDataField . Manager . h " # include " DLSettings . Reader . Errors . h " # include " DLSettings . DataChannels . h " # include " DLUtility . h " # include " DLUtility . ArrayFunctions . h " # include " DLPlatform . h " DataFieldManager :: DataFieldManager ( uint32_t dataSize , uint32_t averagerSize ) { m_dataSize = dataSize ; m_averagerSize = averagerSize ; m_fieldCount = 0 ; m_dataCount = 0 ; uint8_t i = 0 ; for ( i = 0 ; i < MAX_FIELDS ; i ++ ) { m_fields [ i ] = NULL ; } } uint8_t DataFieldManager :: fieldCount ( ) { return m_fieldCount ; } bool DataFieldManager :: addField ( NumericDataField * field ) { if ( ! field ) { return false ; } if ( m_fieldCount == MAX_FIELDS ) { return false ; } PLATFORM_specialField@@ Setup ( field ) ; field -> setDataSiz@@ es ( m_dataSize , m_averagerSize ) ; m_fields [ m_fieldCount ] = field ; m_channelNumbers [ m_fieldCount ] = field -> getChannelNumber ( ) ; m_fieldCount ++ ; return true ; } bool DataFieldManager :: addField ( StringDataField * field ) { if ( ! field ) { return false ; } if ( m_fieldCount == MAX_FIELDS ) { return false ; } m_fields [ m_fieldCount ] = field ; m_channelNumbers [ m_fieldCount ] = field -> getChannelNumber ( ) ; m_fieldCount ++ ; return true ; } void DataFieldManager :: storeDataArray ( int32_t * data ) { uint16_t field = 0 ; uint16_t dataIndex ; bool newAverageStored = false ; for ( field = 0 ; field < m_fieldCount ; field ++ ) { NumericDataField * pField = ( NumericDataField * ) m_fields [ field ] ; if ( pField ) { dataIndex = m_channelNumbers [ field ] - 1 ; newAverageStored |= pField -> storeData ( data [ dataIndex ] ) ; } } if ( newAverageStored ) { m_dataCount ++ ; } } void DataFieldManager :: getDataArray ( float * buffer , bool converted , bool alsoRemove ) { uint16_t field ; for ( field = 0 ; field < m_fieldCount ; ++ field ) { if ( converted ) { buffer [ field ] = ( ( NumericDataField * ) m_fields [ field ] ) -> getConvData ( alsoRemove ) ; } else { buffer [ field ] = ( ( NumericDataField * ) m_fields [ field ] ) -> getRawData ( alsoRemove ) ; } } if ( alsoRemove ) { m_dataCount -- ; } } DataField * DataFieldManager :: getChannel ( uint8_t channel ) { int32_t actualIndex = indexOf ( m_channelNumbers , ( uint32_t ) channel , m_fieldCount ) ; return actualIndex >= 0 ? m_fields [ actualIndex ] : NULL ; } DataField * DataFieldManager :: getField ( uint8_t index ) { return m_fields [ index ] ; } DataField * * DataFieldManager :: getFields ( void ) { return m_fields ; } uint32_t DataFieldManager :: writeHeader@@ sToBuffer ( char * buffer , uint8_t bufferLength ) { if ( ! buffer ) { return 0 ; } uint8_t i ; FixedLengthAccumulator headerAccumulator ( buffer , bufferLength ) ; for ( i = 0 ; i < m_fieldCount ; ++ i ) { headerAccumulator . writeString ( m_fields [ i ] -> getTypeString ( ) ) ; if ( ! lastinloop ( i , m_fieldCount ) ) { headerAccumulator . writeString ( " , ▁ " ) ; } } headerAccumulator . writeString ( " \n " ) ; return headerAccumulator . length ( ) ; } void DataFieldManager :: setupAllValidChannels ( void ) { uint8_t ch ; NumericDataField * field ; FIELD_TYPE type ; void * data ; uint32_t maxChannels = Settings_GetMax@@ Channels ( ) ; for ( ch = 1 ; ch < maxChannels ; ch ++ ) { if ( Settings_ChannelSettingIsValid ( ch ) ) { type = Settings_GetChannel@@ Type ( ch ) ; data = Settings_GetData ( ch ) ; switch ( type ) { case VOLTAGE : case CURRENT : case TEMPERATURE_C : case TEMPERATURE_K : case TEMPERATURE_F : field = new NumericDataField ( type , data , ch ) ; # ifdef TEST std :: cout << " Adding ▁ channel ▁ " << ( int ) ch << " , ▁ type ▁ " << field -> getTypeString ( ) << std :: endl ; # endif addField ( field ) ; break ; default : break ; } } } } bool DataFieldManager :: hasData ( void ) { uint8_t i = 0 ; bool atLeastOneFieldHasData = false ; for ( i = 0 ; i < m_fieldCount ; i ++ ) { atLeastOneFieldHasData |= m_fields [ i ] -> hasData ( ) ; } return atLeastOneFieldHasData ; } uint32_t DataFieldManager :: count ( void ) { return m_dataCount ; } uint32_t * DataFieldManager :: getChannelNumbers ( void ) { return m_channelNumbers ; } </DOCUMENT>
<DOCUMENT_ID="llvm@@ -mirror/clang@@ /tree/master/unit@@ tests/Frontend@@ /CodeGenActionTest.cpp"> # include " clang / CodeGen / CodeGenAction . h " # include " clang / Basic / LangStandard . h " # include " clang / CodeGen / BackendUtil . h " # include " clang / Frontend / CompilerInstance . h " # include " clang / Lex / PreprocessorOptions . h " # include " gtest / gtest . h " using namespace llvm ; using namespace clang ; using namespace clang :: front@@ end ; namespace { class NullCodeGenAction : public CodeGenAction { public : NullCodeGenAction ( llvm :: LLVMContext * _VMContext = nullptr ) : CodeGenAction ( Backend_Emit@@ MCNull , _VMContext ) { } void ExecuteAction ( ) override { CompilerInstance & CI = getCompilerInstance ( ) ; if ( ! CI . hasPreprocess@@ or ( ) ) return ; if ( ! CI . hasSema ( ) ) CI . createSema ( getTranslationUnitKind ( ) , nullptr ) ; } } ; TEST ( CodeGenTest , TestNull@@ CodeGen ) { auto Invocation = std :: make_shared < CompilerInvocation > ( ) ; Invocation -> getPreprocessorOpts ( ) . addRemapped@@ File ( " test . cc " , MemoryBuffer :: getMemBuffer ( " " ) . release ( ) ) ; Invocation -> getFrontendOpts ( ) . Inputs . push_back ( FrontendInputFile ( " test . cc " , Language :: CXX ) ) ; Invocation -> getFrontendOpts ( ) . ProgramAction = EmitLLVM ; Invocation -> getTargetOpts ( ) . Triple = " i386 - unknown - linux - gnu " ; CompilerInstance Compiler ; Compiler . setInvocation ( std :: move ( Invocation ) ) ; Compiler . createDiagnostics ( ) ; EXPECT_TRUE ( Compiler . hasDiagnostics ( ) ) ; std :: unique_ptr < FrontendAction > Act ( new NullCodeGenAction ) ; bool Success = Compiler . ExecuteAction ( * Act ) ; EXPECT_TRUE ( Success ) ; } } </DOCUMENT>
<DOCUMENT_ID="patmari@@ on/PCL/tree/master/@@ sample_consensus/src/@@ ransac.cpp"> # include < pcl / impl / instantiate . hpp > # include < pcl / point_types . h > # include < pcl / sample_consensus / ransac . h > # include < pcl / sample_consensus / impl / ransac . hpp > # ifdef PCL_ONLY_@@ CORE_POINT_TYPES PCL_INSTANTIATE ( RandomSampleConsensus , ( pcl :: PointXYZ ) ( pcl :: PointXYZI ) ( pcl :: PointXYZRGBA ) ( pcl :: PointXYZRGB ) ) # else PCL_INSTANTIATE ( RandomSampleConsensus , PCL_XYZ_POINT_TYPES ) # endif </DOCUMENT>
<DOCUMENT_ID="m039@@ /Void/tree/master/third-party/@@ void-boost/libs/config/test/@@ has_part_@@ alloc_fail.cpp"> # ifdef BOOST_ASSERT_CONFIG # undef BOOST_ASSERT_CONFIG # endif # include < boost / config . hpp > # include " test . hpp " # ifndef BOOST_HAS_PARTIAL_@@ STD_ALLOCATOR # include " boost _ has _ part _ alloc . ipp " # else # error " this ▁ file ▁ should ▁ not ▁ compile " # endif int main ( int , char * [ ] ) { return boost_has_partial_std_@@ allocator :: test ( ) ; } </DOCUMENT>
