<DOCUMENT_ID="@@ ren@@ ato@@ fil@@ ho@@ /@@ Qt@@ Cre@@ ator@@ /tree/master/src/plugins/@@ tex@@ ted@@ itor@@ /code@@ as@@ sist@@ /@@ function@@ h@@ int@@ pro@@ pos@@ al@@ widget@@ .cpp"> # include " function@@ h@@ int@@ pro@@ pos@@ al@@ widget . h " # include " i@@ function@@ h@@ int@@ pro@@ pos@@ al@@ model . h " # include " code@@ as@@ si@@ stan@@ t . h " # include < utils / fa@@ k@@ eto@@ ol@@ tip . h > # include < QtCore / QDebug > # include < QtGui / QApplication > # include < QtGui / QLabel > # include < QtGui / Q@@ Tool@@ Button > # include < QtGui / QHBoxLayout > # include < QtGui / QVBoxLayout > # include < QtGui / Q@@ Des@@ ktop@@ Widget > # include < QtGui / QKeyEvent > # include < QtGui / Q@@ Shortcut@@ Event > namespace Text@@ Edit@@ or { struct Function@@ Hint@@ Pro@@ pos@@ al@@ Widget@@ Private { Function@@ Hint@@ Pro@@ pos@@ al@@ Widget@@ Private ( ) ; const QWidget * m_@@ under@@ ly@@ ing@@ Widget ; Code@@ As@@ si@@ stan@@ t * m_@@ as@@ si@@ stan@@ t ; I@@ Function@@ Hint@@ Pro@@ pos@@ al@@ Model * m_@@ model ; Utils :: Fa@@ ke@@ Tool@@ T@@ ip * m_po@@ p@@ up@@ Frame ; QLabel * m_@@ number@@ Label ; QLabel * m_h@@ int@@ Label ; QWidget * m_p@@ ager ; QRect m_display@@ Rect ; int m_current@@ Hint ; int m_total@@ H@@ ints ; int m_current@@ Argument ; bool m_@@ escap@@ e@@ Pressed ; } ; Function@@ Hint@@ Pro@@ pos@@ al@@ Widget@@ Private :: Function@@ Hint@@ Pro@@ pos@@ al@@ Widget@@ Private ( ) : m_@@ under@@ ly@@ ing@@ Widget ( 0 ) , m_@@ as@@ si@@ stan@@ t ( 0 ) , m_@@ model ( 0 ) , m_po@@ p@@ up@@ Frame ( new Utils :: Fa@@ ke@@ Tool@@ T@@ ip ) , m_@@ number@@ Label ( new QLabel ) , m_h@@ int@@ Label ( new QLabel ) , m_p@@ ager ( new QWidget ) , m_current@@ Hint ( - 1 ) , m_total@@ H@@ ints ( 0 ) , m_current@@ Argument ( - 1 ) , m_@@ escap@@ e@@ Pressed ( false ) { m_h@@ int@@ Label -> setText@@ Format ( Qt :: R@@ ich@@ Text ) ; } Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: Function@@ Hint@@ Pro@@ pos@@ al@@ Widget ( ) : m_d ( new Function@@ Hint@@ Pro@@ pos@@ al@@ Widget@@ Private ) { Q@@ Tool@@ Button * down@@ Arrow = new Q@@ Tool@@ Button ; down@@ Arrow -> set@@ Arrow@@ Type ( Qt :: Down@@ Arrow ) ; down@@ Arrow -> set@@ Fix@@ edSize ( 16 , 16 ) ; down@@ Arrow -> setAuto@@ Raise ( true ) ; Q@@ Tool@@ Button * up@@ Arrow = new Q@@ Tool@@ Button ; up@@ Arrow -> set@@ Arrow@@ Type ( Qt :: Up@@ Arrow ) ; up@@ Arrow -> set@@ Fix@@ edSize ( 16 , 16 ) ; up@@ Arrow -> setAuto@@ Raise ( true ) ; QHBoxLayout * p@@ ager@@ Layout = new QHBoxLayout ( m_d -> m_p@@ ager ) ; p@@ ager@@ Layout -> setMargin ( 0 ) ; p@@ ager@@ Layout -> set@@ Sp@@ acing ( 0 ) ; p@@ ager@@ Layout -> addWidget ( up@@ Arrow ) ; p@@ ager@@ Layout -> addWidget ( m_d -> m_@@ number@@ Label ) ; p@@ ager@@ Layout -> addWidget ( down@@ Arrow ) ; QHBoxLayout * pop@@ up@@ Layout = new QHBoxLayout ( m_d -> m_po@@ p@@ up@@ Frame ) ; pop@@ up@@ Layout -> setMargin ( 0 ) ; pop@@ up@@ Layout -> set@@ Sp@@ acing ( 0 ) ; pop@@ up@@ Layout -> addWidget ( m_d -> m_p@@ ager ) ; pop@@ up@@ Layout -> addWidget ( m_d -> m_h@@ int@@ Label ) ; connect ( up@@ Arrow , SIGNAL ( clicked ( ) ) , SLOT ( previo@@ us@@ Page ( ) ) ) ; connect ( down@@ Arrow , SIGNAL ( clicked ( ) ) , SLOT ( next@@ Page ( ) ) ) ; qApp -> installEventFilter ( this ) ; setFocusPolicy ( Qt :: No@@ Focus ) ; } Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: ~ Function@@ Hint@@ Pro@@ pos@@ al@@ Widget ( ) { delete m_d -> m_@@ model ; } void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: set@@ As@@ si@@ stan@@ t ( Code@@ As@@ si@@ stan@@ t * as@@ si@@ stan@@ t ) { m_d -> m_@@ as@@ si@@ stan@@ t = as@@ si@@ stan@@ t ; } void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: set@@ Reason ( As@@ sist@@ Reason reason ) { Q_UNUSED ( reason ) ; } void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: set@@ Un@@ der@@ ly@@ ing@@ Widget ( const QWidget * under@@ ly@@ ing@@ Widget ) { m_d -> m_@@ under@@ ly@@ ing@@ Widget = under@@ ly@@ ing@@ Widget ; } void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: setModel ( I@@ As@@ sist@@ Pro@@ pos@@ al@@ Model * model ) { m_d -> m_@@ model = static_cast < I@@ Function@@ Hint@@ Pro@@ pos@@ al@@ Model * > ( model ) ; } void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: set@@ Display@@ Rect ( const QRect & rect ) { m_d -> m_display@@ Rect = rect ; } void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: setIs@@ Syn@@ chronized ( bool ) { } void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: show@@ Pro@@ pos@@ al ( const QString & prefix ) { m_d -> m_total@@ H@@ ints = m_d -> m_@@ model -> size ( ) ; if ( m_d -> m_total@@ H@@ ints == 0 ) { abort ( ) ; return ; } m_d -> m_p@@ ager -> setVisible ( m_d -> m_total@@ H@@ ints > 1 ) ; m_d -> m_current@@ Hint = 0 ; if ( ! update@@ AndCheck ( prefix ) ) { abort ( ) ; return ; } m_d -> m_po@@ p@@ up@@ Frame -> show ( ) ; } void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: update@@ Pro@@ pos@@ al ( const QString & prefix ) { update@@ AndCheck ( prefix ) ; } void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: close@@ Pro@@ pos@@ al ( ) { abort ( ) ; } void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: abort ( ) { if ( m_d -> m_po@@ p@@ up@@ Frame -> isVisible ( ) ) m_d -> m_po@@ p@@ up@@ Frame -> close ( ) ; delete@@ Lat@@ er ( ) ; } bool Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: eventFilter ( QObject * obj , QEvent * e ) { switch ( e -> type ( ) ) { case QEvent :: Shortcut@@ Override : if ( static_cast < QKeyEvent * > ( e ) -> key ( ) == Qt :: Key_@@ E@@ scape ) { m_d -> m_@@ escap@@ e@@ Pressed = true ; } break ; case QEvent :: Key@@ Press : if ( static_cast < QKeyEvent * > ( e ) -> key ( ) == Qt :: Key_@@ E@@ scape ) { m_d -> m_@@ escap@@ e@@ Pressed = true ; } if ( m_d -> m_@@ model -> size ( ) > 1 ) { QKeyEvent * ke = static_cast < QKeyEvent * > ( e ) ; if ( ke -> key ( ) == Qt :: Key_@@ Up ) { previo@@ us@@ Page ( ) ; return true ; } else if ( ke -> key ( ) == Qt :: Key_@@ Down ) { next@@ Page ( ) ; return true ; } return false ; } break ; case QEvent :: KeyRelease : if ( static_cast < QKeyEvent * > ( e ) -> key ( ) == Qt :: Key_@@ E@@ scape && m_d -> m_@@ escap@@ e@@ Pressed ) { abort ( ) ; return false ; } m_d -> m_@@ as@@ si@@ stan@@ t -> notify@@ Change ( ) ; break ; case QEvent :: Window@@ De@@ activate : case QEvent :: Focus@@ Out : if ( obj != m_d -> m_@@ under@@ ly@@ ing@@ Widget ) { break ; } abort ( ) ; break ; case QEvent :: Mouse@@ ButtonPress : case QEvent :: Mouse@@ ButtonRelease : case QEvent :: Mouse@@ Button@@ D@@ bl@@ Click : case QEvent :: Wheel : { QWidget * widget = q@@ object@@ _cast < QWidget * > ( obj ) ; if ( ! ( widget == this || is@@ An@@ ce@@ stor@@ Of ( widget ) ) ) { abort ( ) ; } } break ; default : break ; } return false ; } void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: next@@ Page ( ) { m_d -> m_current@@ Hint = ( m_d -> m_current@@ Hint + 1 ) % m_d -> m_total@@ H@@ ints ; update@@ Content ( ) ; } void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: previo@@ us@@ Page ( ) { if ( m_d -> m_current@@ Hint == 0 ) m_d -> m_current@@ Hint = m_d -> m_total@@ H@@ ints - 1 ; else -- m_d -> m_current@@ Hint ; update@@ Content ( ) ; } bool Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: update@@ AndCheck ( const QString & prefix ) { const int active@@ Argument = m_d -> m_@@ model -> active@@ Argument ( prefix ) ; if ( active@@ Argument == - 1 ) { abort ( ) ; return false ; } else if ( active@@ Argument != m_d -> m_current@@ Argument ) { m_d -> m_current@@ Argument = active@@ Argument ; update@@ Content ( ) ; } return true ; } void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: update@@ Content ( ) { m_d -> m_h@@ int@@ Label -> setText ( m_d -> m_@@ model -> text ( m_d -> m_current@@ Hint ) ) ; m_d -> m_@@ number@@ Label -> setText ( tr ( " % 1 ▁ of ▁ % 2" ) . arg ( m_d -> m_current@@ Hint + 1 ) . arg ( m_d -> m_total@@ H@@ ints ) ) ; update@@ Position ( ) ; } void Function@@ Hint@@ Pro@@ pos@@ al@@ Widget :: update@@ Position ( ) { const Q@@ Des@@ ktop@@ Widget * desk@@ top = QApplication :: desk@@ top ( ) ; # ifdef Q_@@ WS_@@ MAC const QRect & screen = desk@@ top -> available@@ Geometry ( desk@@ top -> screen@@ Number ( m_d -> m_@@ under@@ ly@@ ing@@ Widget ) ) ; # else const QRect & screen = desk@@ top -> screen@@ Geometry ( desk@@ top -> screen@@ Number ( m_d -> m_@@ under@@ ly@@ ing@@ Widget ) ) ; # endif m_d -> m_p@@ ager -> setFixed@@ Width ( m_d -> m_p@@ ager -> min@@ imum@@ Size@@ Hint ( ) . width ( ) ) ; m_d -> m_h@@ int@@ Label -> setWord@@ Wrap ( false ) ; const int max@@ Desired@@ Width = screen . width ( ) - 10 ; const QSize & min@@ Hint = m_d -> m_po@@ p@@ up@@ Frame -> min@@ imum@@ Size@@ Hint ( ) ; if ( min@@ Hint . width ( ) > max@@ Desired@@ Width ) { m_d -> m_h@@ int@@ Label -> setWord@@ Wrap ( true ) ; m_d -> m_po@@ p@@ up@@ Frame -> setFixed@@ Width ( max@@ Desired@@ Width ) ; const int extra = m_d -> m_po@@ p@@ up@@ Frame -> content@@ sMargins ( ) . bottom ( ) + m_d -> m_po@@ p@@ up@@ Frame -> content@@ sMargins ( ) . top ( ) ; m_d -> m_po@@ p@@ up@@ Frame -> setFixedHeight ( m_d -> m_h@@ int@@ Label -> height@@ For@@ Width ( max@@ Desired@@ Width - m_d -> m_p@@ ager -> width ( ) ) + extra ) ; } else { m_d -> m_po@@ p@@ up@@ Frame -> set@@ Fix@@ edSize ( min@@ Hint ) ; } const QSize & sz = m_d -> m_po@@ p@@ up@@ Frame -> size ( ) ; QPoint pos = m_d -> m_display@@ Rect . top@@ Left ( ) ; pos . set@@ Y ( pos . y ( ) - sz . height ( ) - 1 ) ; if ( pos . x ( ) + sz . width ( ) > screen . right ( ) ) pos . setX ( screen . right ( ) - sz . width ( ) ) ; m_d -> m_po@@ p@@ up@@ Frame -> move ( pos ) ; } } </DOCUMENT>
<DOCUMENT_ID="@@ o@@ ma@@ z@@ ap@@ a/@@ root@@ -@@ old@@ /tree/master/interpre@@ ter/llvm@@ /src/@@ lib/@@ CodeGen@@ /@@ Machine@@ S@@ SA@@ Upd@@ ater@@ .cpp"> # include " llvm / CodeGen / Machine@@ S@@ SA@@ Upd@@ ater . h " # include " llvm / ADT / D@@ en@@ se@@ Map . h " # include " llvm / ADT / SmallVector . h " # include " llvm / CodeGen / MachineInstr . h " # include " llvm / CodeGen / MachineInstr@@ Builder . h " # include " llvm / CodeGen / MachineRegisterInfo . h " # include " llvm / Support / Align@@ Of . h " # include " llvm / Support / Allocator . h " # include " llvm / Support / Debug . h " # include " llvm / Support / Error@@ Hand@@ ling . h " # include " llvm / Support / raw _ ostream . h " # include " llvm / Target / TargetInstrInfo . h " # include " llvm / Target / TargetRegisterInfo . h " # include " llvm / Target / Target@@ Sub@@ target@@ Info . h " # include " llvm / Transforms / Utils / S@@ SA@@ Upd@@ ater@@ Impl . h " using namespace llvm ; # define DEBUG_TYPE " mach@@ ine - ss@@ a@@ upd@@ ater " typedef D@@ en@@ se@@ Map < MachineBasicBlock * , unsigned > A@@ vai@@ lable@@ V@@ al@@ s@@ Ty ; static A@@ vai@@ lable@@ V@@ al@@ s@@ Ty & get@@ A@@ vai@@ lable@@ V@@ als ( void * A@@ V ) { return * static_cast < A@@ vai@@ lable@@ V@@ al@@ s@@ Ty * > ( A@@ V ) ; } Machine@@ S@@ SA@@ Upd@@ ater :: Machine@@ S@@ SA@@ Upd@@ ater ( MachineFunction & MF , Small@@ Vector@@ Impl < MachineInstr * > * New@@ PH@@ I ) : A@@ V ( nullptr ) , In@@ ser@@ ted@@ P@@ HI@@ s ( New@@ PH@@ I ) { TII = MF . getSubtarget ( ) . getInstrInfo ( ) ; MRI = & MF . getRegInfo ( ) ; } Machine@@ S@@ SA@@ Upd@@ ater :: ~ Machine@@ S@@ SA@@ Upd@@ ater ( ) { delete static_cast < A@@ vai@@ lable@@ V@@ al@@ s@@ Ty * > ( A@@ V ) ; } void Machine@@ S@@ SA@@ Upd@@ ater :: Initialize ( unsigned V ) { if ( ! A@@ V ) A@@ V = new A@@ vai@@ lable@@ V@@ al@@ s@@ Ty ( ) ; else get@@ A@@ vai@@ lable@@ V@@ als ( A@@ V ) . clear ( ) ; VR = V ; V@@ RC = MRI -> get@@ RegClass ( VR ) ; } bool Machine@@ S@@ SA@@ Upd@@ ater :: Has@@ Value@@ For@@ Block ( MachineBasicBlock * BB ) const { return get@@ A@@ vai@@ lable@@ V@@ als ( A@@ V ) . count ( BB ) ; } void Machine@@ S@@ SA@@ Upd@@ ater :: Add@@ A@@ vai@@ lable@@ Value ( MachineBasicBlock * BB , unsigned V ) { get@@ A@@ vai@@ lable@@ V@@ als ( A@@ V ) [ BB ] = V ; } unsigned Machine@@ S@@ SA@@ Upd@@ ater :: GetValue@@ At@@ End@@ OfBlock ( MachineBasicBlock * BB ) { return GetValue@@ At@@ End@@ Of@@ Block@@ Internal ( BB ) ; } static unsigned Lo@@ ok@@ For@@ Identical@@ PH@@ I ( MachineBasicBlock * BB , Small@@ Vector@@ Impl < std :: pair < MachineBasicBlock * , unsigned > > & Pre@@ d@@ Values ) { if ( BB -> empty ( ) ) return 0 ; MachineBasicBlock :: iterator I = BB -> begin ( ) ; if ( ! I -> is@@ PH@@ I ( ) ) return 0 ; A@@ vai@@ lable@@ V@@ al@@ s@@ Ty AV@@ als ; for ( unsigned i = 0 , e = Pre@@ d@@ Values . size ( ) ; i != e ; ++ i ) AV@@ als [ Pre@@ d@@ Values [ i ] . first ] = Pre@@ d@@ Values [ i ] . second ; while ( I != BB -> end ( ) && I -> is@@ PH@@ I ( ) ) { bool Same = true ; for ( unsigned i = 1 , e = I -> getNum@@ Oper@@ ands ( ) ; i != e ; i += 2 ) { unsigned SrcReg = I -> getOperand ( i ) . getReg ( ) ; MachineBasicBlock * Src@@ BB = I -> getOperand ( i + 1 ) . get@@ MBB ( ) ; if ( AV@@ als [ Src@@ BB ] != SrcReg ) { Same = false ; break ; } } if ( Same ) return I -> getOperand ( 0 ) . getReg ( ) ; ++ I ; } return 0 ; } static MachineInstr@@ Builder Insert@@ New@@ Def ( unsigned Opcode , MachineBasicBlock * BB , MachineBasicBlock :: iterator I , const TargetRegisterClass * RC , MachineRegisterInfo * MRI , const TargetInstrInfo * TII ) { unsigned New@@ VR = MRI -> createVirtualRegister ( RC ) ; return BuildMI ( * BB , I , DebugLoc ( ) , TII -> get ( Opcode ) , New@@ VR ) ; } unsigned Machine@@ S@@ SA@@ Upd@@ ater :: GetValue@@ In@@ Midd@@ le@@ OfBlock ( MachineBasicBlock * BB ) { if ( ! Has@@ Value@@ For@@ Block ( BB ) ) return GetValue@@ At@@ End@@ Of@@ Block@@ Internal ( BB ) ; if ( BB -> pre@@ d_@@ empty ( ) ) { MachineInstr * New@@ Def = Insert@@ New@@ Def ( TargetOpcode :: IMPLICIT_@@ DEF , BB , BB -> getFirst@@ Ter@@ minator ( ) , V@@ RC , MRI , TII ) ; return New@@ Def -> getOperand ( 0 ) . getReg ( ) ; } SmallVector < std :: pair < MachineBasicBlock * , unsigned > , 8 > Pre@@ d@@ Values ; unsigned Sing@@ ular@@ Value = 0 ; bool is@@ First@@ Pre@@ d = true ; for ( MachineBasicBlock :: pre@@ d_iterator PI = BB -> pre@@ d_@@ begin ( ) , E = BB -> pre@@ d_@@ end ( ) ; PI != E ; ++ PI ) { MachineBasicBlock * Pre@@ d@@ BB = * PI ; unsigned Pre@@ d@@ Val = GetValue@@ At@@ End@@ Of@@ Block@@ Internal ( Pre@@ d@@ BB ) ; Pre@@ d@@ Values . push_back ( std :: make_pair ( Pre@@ d@@ BB , Pre@@ d@@ Val ) ) ; if ( is@@ First@@ Pre@@ d ) { Sing@@ ular@@ Value = Pre@@ d@@ Val ; is@@ First@@ Pre@@ d = false ; } else if ( Pre@@ d@@ Val != Sing@@ ular@@ Value ) Sing@@ ular@@ Value = 0 ; } if ( Sing@@ ular@@ Value != 0 ) return Sing@@ ular@@ Value ; unsigned Dup@@ PH@@ I = Lo@@ ok@@ For@@ Identical@@ PH@@ I ( BB , Pre@@ d@@ Values ) ; if ( Dup@@ PH@@ I ) return Dup@@ PH@@ I ; MachineBasicBlock :: iterator Loc = BB -> empty ( ) ? BB -> end ( ) : BB -> begin ( ) ; MachineInstr@@ Builder In@@ ser@@ ted@@ PH@@ I = Insert@@ New@@ Def ( TargetOpcode :: PH@@ I , BB , Loc , V@@ RC , MRI , TII ) ; for ( unsigned i = 0 , e = Pre@@ d@@ Values . size ( ) ; i != e ; ++ i ) In@@ ser@@ ted@@ PH@@ I . addReg ( Pre@@ d@@ Values [ i ] . second ) . add@@ MBB ( Pre@@ d@@ Values [ i ] . first ) ; if ( unsigned Con@@ st@@ Val = In@@ ser@@ ted@@ PH@@ I -> is@@ Constant@@ Value@@ PH@@ I ( ) ) { In@@ ser@@ ted@@ PH@@ I -> eraseFromParent ( ) ; return Con@@ st@@ Val ; } if ( In@@ ser@@ ted@@ P@@ HI@@ s ) In@@ ser@@ ted@@ P@@ HI@@ s -> push_back ( In@@ ser@@ ted@@ PH@@ I ) ; DEBUG ( dbgs ( ) << " ▁ ▁ In@@ ser@@ ted ▁ PH@@ I : ▁ " << * In@@ ser@@ ted@@ PH@@ I << " \n " ) ; return In@@ ser@@ ted@@ PH@@ I -> getOperand ( 0 ) . getReg ( ) ; } static MachineBasicBlock * find@@ Cor@@ respon@@ d@@ ing@@ Pre@@ d ( const MachineInstr * MI , Machine@@ Operand * U ) { for ( unsigned i = 1 , e = MI -> getNum@@ Oper@@ ands ( ) ; i != e ; i += 2 ) { if ( & MI -> getOperand ( i ) == U ) return MI -> getOperand ( i + 1 ) . get@@ MBB ( ) ; } ll@@ v@@ m_@@ un@@ reachable ( " Machine@@ Operand : : getParent ( ) ▁ fail@@ ure ? " ) ; } void Machine@@ S@@ SA@@ Upd@@ ater :: Re@@ write@@ Use ( Machine@@ Operand & U ) { MachineInstr * Use@@ MI = U . getParent ( ) ; unsigned New@@ VR = 0 ; if ( Use@@ MI -> is@@ PH@@ I ( ) ) { MachineBasicBlock * Source@@ BB = find@@ Cor@@ respon@@ d@@ ing@@ Pre@@ d ( Use@@ MI , & U ) ; New@@ VR = GetValue@@ At@@ End@@ Of@@ Block@@ Internal ( Source@@ BB ) ; } else { New@@ VR = GetValue@@ In@@ Midd@@ le@@ OfBlock ( Use@@ MI -> getParent ( ) ) ; } U . set@@ Reg ( New@@ VR ) ; } namespace llvm { template < > class S@@ SA@@ Upd@@ ater@@ Traits < Machine@@ S@@ SA@@ Upd@@ ater > { public : typedef MachineBasicBlock Bl@@ k@@ T ; typedef unsigned V@@ al@@ T ; typedef MachineInstr Ph@@ i@@ T ; typedef MachineBasicBlock :: suc@@ c_@@ iterator Bl@@ k@@ Suc@@ c_@@ iterator ; static Bl@@ k@@ Suc@@ c_@@ iterator Bl@@ k@@ Suc@@ c_@@ begin ( Bl@@ k@@ T * BB ) { return BB -> suc@@ c_@@ begin ( ) ; } static Bl@@ k@@ Suc@@ c_@@ iterator Bl@@ k@@ Suc@@ c_@@ end ( Bl@@ k@@ T * BB ) { return BB -> suc@@ c_@@ end ( ) ; } class P@@ HI@@ _iterator { private : MachineInstr * PH@@ I ; unsigned idx ; public : explicit P@@ HI@@ _iterator ( MachineInstr * P ) : PH@@ I ( P ) , idx ( 1 ) { } P@@ HI@@ _iterator ( MachineInstr * P , bool ) : PH@@ I ( P ) , idx ( PH@@ I -> getNum@@ Oper@@ ands ( ) ) { } P@@ HI@@ _iterator & operator ++ ( ) { idx += 2 ; return * this ; } bool operator == ( const P@@ HI@@ _iterator & x ) const { return idx == x . idx ; } bool operator != ( const P@@ HI@@ _iterator & x ) const { return ! operator == ( x ) ; } unsigned getIn@@ coming@@ Value ( ) { return PH@@ I -> getOperand ( idx ) . getReg ( ) ; } MachineBasicBlock * getIn@@ coming@@ Block ( ) { return PH@@ I -> getOperand ( idx + 1 ) . get@@ MBB ( ) ; } } ; static inline P@@ HI@@ _iterator P@@ HI@@ _begin ( Ph@@ i@@ T * PH@@ I ) { return P@@ HI@@ _iterator ( PH@@ I ) ; } static inline P@@ HI@@ _iterator P@@ HI@@ _end ( Ph@@ i@@ T * PH@@ I ) { return P@@ HI@@ _iterator ( PH@@ I , true ) ; } static void Find@@ Pre@@ de@@ cess@@ or@@ Blocks ( MachineBasicBlock * BB , Small@@ Vector@@ Impl < MachineBasicBlock * > * Pre@@ ds ) { for ( MachineBasicBlock :: pre@@ d_iterator PI = BB -> pre@@ d_@@ begin ( ) , E = BB -> pre@@ d_@@ end ( ) ; PI != E ; ++ PI ) Pre@@ ds -> push_back ( * PI ) ; } static unsigned Get@@ Un@@ def@@ Val ( MachineBasicBlock * BB , Machine@@ S@@ SA@@ Upd@@ ater * Upd@@ ater ) { MachineInstr * New@@ Def = Insert@@ New@@ Def ( TargetOpcode :: IMPLICIT_@@ DEF , BB , BB -> getFirst@@ Ter@@ minator ( ) , Upd@@ ater -> V@@ RC , Upd@@ ater -> MRI , Upd@@ ater -> TII ) ; return New@@ Def -> getOperand ( 0 ) . getReg ( ) ; } static unsigned Create@@ Empty@@ PH@@ I ( MachineBasicBlock * BB , unsigned Num@@ Pre@@ ds , Machine@@ S@@ SA@@ Upd@@ ater * Upd@@ ater ) { MachineBasicBlock :: iterator Loc = BB -> empty ( ) ? BB -> end ( ) : BB -> begin ( ) ; MachineInstr * PH@@ I = Insert@@ New@@ Def ( TargetOpcode :: PH@@ I , BB , Loc , Upd@@ ater -> V@@ RC , Upd@@ ater -> MRI , Upd@@ ater -> TII ) ; return PH@@ I -> getOperand ( 0 ) . getReg ( ) ; } static void Add@@ PH@@ IO@@ per@@ and ( MachineInstr * PH@@ I , unsigned Val , MachineBasicBlock * Pre@@ d ) { MachineInstr@@ Builder ( * Pre@@ d -> getParent ( ) , PH@@ I ) . addReg ( Val ) . add@@ MBB ( Pre@@ d ) ; } static MachineInstr * Instr@@ Is@@ PH@@ I ( MachineInstr * I ) { if ( I && I -> is@@ PH@@ I ( ) ) return I ; return nullptr ; } static MachineInstr * Value@@ Is@@ PH@@ I ( unsigned Val , Machine@@ S@@ SA@@ Upd@@ ater * Upd@@ ater ) { return Instr@@ Is@@ PH@@ I ( Upd@@ ater -> MRI -> get@@ V@@ Reg@@ Def ( Val ) ) ; } static MachineInstr * Value@@ Is@@ New@@ PH@@ I ( unsigned Val , Machine@@ S@@ SA@@ Upd@@ ater * Upd@@ ater ) { MachineInstr * PH@@ I = Value@@ Is@@ PH@@ I ( Val , Upd@@ ater ) ; if ( PH@@ I && PH@@ I -> getNum@@ Oper@@ ands ( ) <= 1 ) return PH@@ I ; return nullptr ; } static unsigned Get@@ P@@ HI@@ Value ( MachineInstr * PH@@ I ) { return PH@@ I -> getOperand ( 0 ) . getReg ( ) ; } } ; } unsigned Machine@@ S@@ SA@@ Upd@@ ater :: GetValue@@ At@@ End@@ Of@@ Block@@ Internal ( MachineBasicBlock * BB ) { A@@ vai@@ lable@@ V@@ al@@ s@@ Ty & A@@ vai@@ lable@@ V@@ als = get@@ A@@ vai@@ lable@@ V@@ als ( A@@ V ) ; if ( unsigned V = A@@ vai@@ lable@@ V@@ als [ BB ] ) return V ; S@@ SA@@ Upd@@ ater@@ Impl < Machine@@ S@@ SA@@ Upd@@ ater > Impl ( this , & A@@ vai@@ lable@@ V@@ als , In@@ ser@@ ted@@ P@@ HI@@ s ) ; return Impl . GetValue ( BB ) ; } </DOCUMENT>
<DOCUMENT_ID="@@ c@@ yp@@ sun@@ /@@ FreeCAD@@ /tree/master/src/@@ Mod@@ /@@ Robot@@ /@@ Gui@@ /@@ View@@ Provid@@ er@@ Tr@@ aj@@ ect@@ ory@@ .cpp"> # include " Pre@@ Comp@@ iled . h " # ifndef _@@ Pre@@ Comp@@ _ # include < In@@ vent@@ or / So@@ DB . h > # include < In@@ vent@@ or / So@@ Input . h > # include < In@@ vent@@ or / S@@ b@@ Vec@@ 3f . h > # include < In@@ vent@@ or / nodes / So@@ Separator . h > # include < In@@ vent@@ or / nodes / So@@ Transform . h > # include < In@@ vent@@ or / nodes / So@@ Sphere . h > # include < In@@ vent@@ or / nodes / So@@ Rotation . h > # include < In@@ vent@@ or / actions / So@@ Search@@ Action . h > # include < In@@ vent@@ or / dr@@ ag@@ g@@ ers / So@@ Jack@@ Drag@@ ger . h > # include < In@@ vent@@ or / V@@ R@@ ML@@ nodes / So@@ V@@ R@@ ML@@ Transform . h > # include < In@@ vent@@ or / nodes / So@@ Base@@ Color . h > # include < In@@ vent@@ or / nodes / So@@ Coord@@ inate@@ 3 . h > # include < In@@ vent@@ or / nodes / So@@ Draw@@ Style . h > # include < In@@ vent@@ or / nodes / So@@ F@@ ace@@ Set . h > # include < In@@ vent@@ or / nodes / So@@ Line@@ Set . h > # include < In@@ vent@@ or / nodes / So@@ Mark@@ er@@ Set . h > # include < In@@ vent@@ or / nodes / So@@ Shape@@ H@@ ints . h > # include < QFile > # endif # include " View@@ Provid@@ er@@ Tr@@ aj@@ ect@@ ory . h " # include < Mod / Ro@@ bo@@ t / App / Tr@@ aj@@ ect@@ ory@@ Object . h > # include < Mod / Ro@@ bo@@ t / App / Tr@@ aj@@ ect@@ ory . h > # include < App / Document . h > # include < Base / FileInfo . h > # include < Base / Stream . h > # include < Base / Conso@@ le . h > # include < sstream > using namespace Gui ; using namespace Robot@@ Gui ; using namespace Ro@@ bo@@ t ; PROPER@@ TY@@ _SOURCE ( Robot@@ Gui :: View@@ Provid@@ er@@ Tr@@ aj@@ ect@@ ory , Gui :: View@@ Provid@@ er@@ Ge@@ ometr@@ y@@ Object ) View@@ Provid@@ er@@ Tr@@ aj@@ ect@@ ory :: View@@ Provid@@ er@@ Tr@@ aj@@ ect@@ ory ( ) { pc@@ Tr@@ aj@@ ect@@ ory@@ Root = new Gui :: So@@ FC@@ Selection ( ) ; pc@@ Tr@@ aj@@ ect@@ ory@@ Root -> high@@ light@@ Mode = Gui :: So@@ FC@@ Selection :: OFF ; pc@@ Tr@@ aj@@ ect@@ ory@@ Root -> selection@@ Mode = Gui :: So@@ FC@@ Selection :: SE@@ L_@@ OFF ; pc@@ Tr@@ aj@@ ect@@ ory@@ Root -> ref ( ) ; pc@@ Co@@ ords = new So@@ Coord@@ inate@@ 3 ( ) ; pc@@ Co@@ ords -> ref ( ) ; pc@@ Draw@@ Style = new So@@ Draw@@ Style ( ) ; pc@@ Draw@@ Style -> ref ( ) ; pc@@ Draw@@ Style -> style = So@@ Draw@@ Style :: LINES ; pc@@ Draw@@ Style -> lineWidth = 2 ; pc@@ Lines = new So@@ Line@@ Set ; pc@@ Lines -> ref ( ) ; } View@@ Provid@@ er@@ Tr@@ aj@@ ect@@ ory :: ~ View@@ Provid@@ er@@ Tr@@ aj@@ ect@@ ory ( ) { pc@@ Tr@@ aj@@ ect@@ ory@@ Root -> un@@ ref ( ) ; pc@@ Co@@ ords -> un@@ ref ( ) ; pc@@ Draw@@ Style -> un@@ ref ( ) ; pc@@ Lines -> un@@ ref ( ) ; } void View@@ Provid@@ er@@ Tr@@ aj@@ ect@@ ory :: attach ( App :: Document@@ Object * pc@@ Obj ) { View@@ Provid@@ er@@ Document@@ Object :: attach ( pc@@ Obj ) ; So@@ Separator * lines@@ ep = new So@@ Separator ; So@@ Base@@ Color * bas@@ ec@@ ol = new So@@ Base@@ Color ; bas@@ ec@@ ol -> r@@ gb . setValue ( 1.0f , 0.5f , 0.0f ) ; lines@@ ep -> addChild ( bas@@ ec@@ ol ) ; lines@@ ep -> addChild ( pc@@ Co@@ ords ) ; lines@@ ep -> addChild ( pc@@ Lines ) ; So@@ Base@@ Color * mark@@ col = new So@@ Base@@ Color ; mark@@ col -> r@@ gb . setValue ( 1.0f , 1.0f , 0.0f ) ; So@@ Mark@@ er@@ Set * marker = new So@@ Mark@@ er@@ Set ; marker -> mark@@ er@@ Index = So@@ Mark@@ er@@ Set :: CRO@@ SS_@@ 5@@ _@@ 5 ; lines@@ ep -> addChild ( mark@@ col ) ; lines@@ ep -> addChild ( marker ) ; pc@@ Tr@@ aj@@ ect@@ ory@@ Root -> addChild ( lines@@ ep ) ; add@@ Display@@ Mask@@ Mode ( pc@@ Tr@@ aj@@ ect@@ ory@@ Root , " Wa@@ ypo@@ ints " ) ; pc@@ Tr@@ aj@@ ect@@ ory@@ Root -> object@@ Name = pc@@ Obj -> getName@@ In@@ Document ( ) ; pc@@ Tr@@ aj@@ ect@@ ory@@ Root -> d@@ ocum@@ ent@@ Name = pc@@ Obj -> getDocument ( ) -> getName ( ) ; pc@@ Tr@@ aj@@ ect@@ ory@@ Root -> sub@@ Element@@ Name = " Main " ; } void View@@ Provid@@ er@@ Tr@@ aj@@ ect@@ ory :: set@@ DisplayMode ( const char * Mode@@ Name ) { if ( strcmp ( " Wa@@ ypo@@ ints " , Mode@@ Name ) == 0 ) set@@ Display@@ Mask@@ Mode ( " Wa@@ ypo@@ ints " ) ; View@@ Provid@@ er@@ Ge@@ ometr@@ y@@ Object :: set@@ DisplayMode ( Mode@@ Name ) ; } std :: vector < std :: string > View@@ Provid@@ er@@ Tr@@ aj@@ ect@@ ory :: getDisplay@@ Modes ( void ) const { std :: vector < std :: string > Str@@ List ; Str@@ List . push_back ( " Wa@@ ypo@@ ints " ) ; return Str@@ List ; } void View@@ Provid@@ er@@ Tr@@ aj@@ ect@@ ory :: updateData ( const App :: Property * prop ) { Ro@@ bo@@ t :: Tr@@ aj@@ ect@@ ory@@ Object * pc@@ Tr@@ ac@@ Obj = static_cast < Ro@@ bo@@ t :: Tr@@ aj@@ ect@@ ory@@ Object * > ( pc@@ Object ) ; if ( prop == & pc@@ Tr@@ ac@@ Obj -> Tr@@ aj@@ ect@@ ory ) { const Tr@@ aj@@ ect@@ ory & tra@@ k = pc@@ Tr@@ ac@@ Obj -> Tr@@ aj@@ ect@@ ory . getValue ( ) ; pc@@ Co@@ ords -> point . delete@@ Values ( 0 ) ; pc@@ Co@@ ords -> point . setNum ( tra@@ k . getSize ( ) ) ; for ( unsigned int i = 0 ; i < tra@@ k . getSize ( ) ; ++ i ) { Base :: Vector@@ 3d pos = tra@@ k . get@@ Wa@@ ypo@@ int ( i ) . End@@ Pos . getPosition ( ) ; pc@@ Co@@ ords -> point . set@@ 1@@ Value ( i , pos . x , pos . y , pos . z ) ; } pc@@ Lines -> num@@ Ver@@ tices . set@@ 1@@ Value ( 0 , tra@@ k . getSize ( ) ) ; } else if ( prop == & pc@@ Tr@@ ac@@ Obj -> Base ) { Base :: Pl@@ acement loc = * ( & pc@@ Tr@@ ac@@ Obj -> Base . getValue ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="@@ dev@@ -@@ il@@ y/@@ I@@ Lo@@ ve@@ You@@ Co@@ ins@@ /tree/master/src/@@ rpc@@ wall@@ et@@ .cpp"> # include < boost / assign / list_of . hpp > # include " wallet . h " # include " wall@@ et@@ db . h " # include " bitcoin@@ rpc . h " # include " init . h " # include " base58 . h " using namespace std ; using namespace boost ; using namespace boost :: assign ; using namespace json_spirit ; int64 nWallet@@ Unlock@@ Time ; static CCritic@@ alSection cs_@@ nWallet@@ Unlock@@ Time ; std :: string Help@@ Re@@ qu@@ ir@@ ing@@ P@@ as@@ sp@@ hr@@ ase ( ) { return pw@@ all@@ et@@ Main && pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) ? " \n requires ▁ wallet ▁ pas@@ sp@@ hr@@ ase ▁ to ▁ be ▁ set ▁ with ▁ wall@@ et@@ pas@@ sp@@ hr@@ ase ▁ first " : " " ; } void En@@ sure@@ Wallet@@ Is@@ Unlock@@ ed ( ) { if ( pw@@ all@@ et@@ Main -> Is@@ Locked ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ UN@@ LOC@@ K_@@ NE@@ E@@ DED , " Error : ▁ Please ▁ enter ▁ the ▁ wallet ▁ pas@@ sp@@ hr@@ ase ▁ with ▁ wall@@ et@@ pas@@ sp@@ hr@@ ase ▁ first . " ) ; if ( f@@ Wallet@@ Unlock@@ St@@ ak@@ ing@@ Only ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ AL@@ READ@@ Y_@@ UN@@ LOC@@ KE@@ D@@ _ST@@ A@@ KING_@@ ONLY , " Error : ▁ Wallet ▁ is ▁ un@@ lock@@ ed ▁ for ▁ st@@ ak@@ ing ▁ only . " ) ; } void Wallet@@ Tx@@ To@@ JS@@ ON ( const CWalletTx & wtx , Object & entry ) { int confi@@ r@@ ms = wtx . Get@@ Depth@@ In@@ Main@@ Chain ( ) ; entry . push_back ( Pair ( " confirm@@ ations " , confi@@ r@@ ms ) ) ; if ( wtx . Is@@ Co@@ in@@ Base ( ) || wtx . Is@@ Co@@ in@@ St@@ a@@ ke ( ) ) entry . push_back ( Pair ( " generated " , true ) ) ; if ( confi@@ r@@ ms > 0 ) { entry . push_back ( Pair ( " block@@ hash " , wtx . hash@@ Block . Get@@ Hex ( ) ) ) ; entry . push_back ( Pair ( " blockindex " , wtx . nIndex ) ) ; entry . push_back ( Pair ( " block@@ time " , ( boost :: int64_t ) ( mapBlockIndex [ wtx . hash@@ Block ] -> nTime ) ) ) ; } entry . push_back ( Pair ( " tx@@ id " , wtx . GetHash ( ) . Get@@ Hex ( ) ) ) ; entry . push_back ( Pair ( " norm@@ tx@@ id " , wtx . Get@@ Nor@@ m@@ alized@@ Hash ( ) . Get@@ Hex ( ) ) ) ; entry . push_back ( Pair ( " time " , ( boost :: int64_t ) wtx . Get@@ Tx@@ Time ( ) ) ) ; entry . push_back ( Pair ( " time@@ received " , ( boost :: int64_t ) wtx . n@@ Time@@ Received ) ) ; BOOST_FOREACH ( const PAIRTYPE ( string , string ) & item , wtx . map@@ Value ) entry . push_back ( Pair ( item . first , item . second ) ) ; } string Account@@ From@@ Value ( const Value & value ) { string strAccount = value . get_str ( ) ; if ( strAccount == " * " ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ INVALID_@@ AC@@ CO@@ UN@@ T_@@ NAME , " Invalid ▁ account ▁ name " ) ; return strAccount ; } Value get@@ info ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) != 0 ) throw runtime_error ( " get@@ info \n " " Retur@@ ns ▁ an ▁ object ▁ containing ▁ vario@@ us ▁ state ▁ info . " ) ; pro@@ xy@@ Type proxy ; Get@@ Proxy ( NE@@ T_@@ IPV4 , proxy ) ; Object obj ; obj . push_back ( Pair ( " version " , ( int ) CLIENT_VERSION ) ) ; obj . push_back ( Pair ( " proto@@ col@@ version " , ( int ) PROTOCOL_VERSION ) ) ; if ( pw@@ all@@ et@@ Main ) { obj . push_back ( Pair ( " wall@@ et@@ version " , pw@@ all@@ et@@ Main -> Get@@ Version ( ) ) ) ; obj . push_back ( Pair ( " bal@@ ance " , Value@@ From@@ Amount ( pw@@ all@@ et@@ Main -> GetB@@ al@@ ance ( ) ) ) ) ; obj . push_back ( Pair ( " un@@ confirm@@ ed@@ bal@@ ance " , Value@@ From@@ Amount ( pw@@ all@@ et@@ Main -> Get@@ Un@@ confirm@@ ed@@ B@@ al@@ ance ( ) ) ) ) ; obj . push_back ( Pair ( " st@@ a@@ ke " , Value@@ From@@ Amount ( pw@@ all@@ et@@ Main -> Get@@ St@@ a@@ ke ( ) ) ) ) ; obj . push_back ( Pair ( " lock@@ ed " , pw@@ all@@ et@@ Main -> Is@@ Locked ( ) ) ) ; obj . push_back ( Pair ( " encryp@@ ted " , pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) ) ) ; } obj . push_back ( Pair ( " block@@ s " , ( int ) nBestHeight ) ) ; obj . push_back ( Pair ( " time@@ offset " , ( boost :: int64_t ) GetTime@@ Offset ( ) ) ) ; obj . push_back ( Pair ( " m@@ one@@ y@@ sup@@ pl@@ y " , Value@@ From@@ Amount ( pindexBest -> n@@ M@@ one@@ y@@ Sup@@ pl@@ y ) ) ) ; obj . push_back ( Pair ( " connections " , ( int ) v@@ Nodes . size ( ) ) ) ; obj . push_back ( Pair ( " proxy " , ( proxy . first . IsValid ( ) ? proxy . first . ToString@@ IP@@ Port ( ) : string ( ) ) ) ) ; obj . push_back ( Pair ( " di@@ ffi@@ c@@ ul@@ ty " , ( double ) Get@@ Di@@ ffi@@ c@@ ul@@ ty ( ) ) ) ; obj . push_back ( Pair ( " test@@ net " , fTestNet ) ) ; if ( pw@@ all@@ et@@ Main ) { obj . push_back ( Pair ( " ke@@ ypo@@ o@@ lo@@ l@@ dest " , ( boost :: int64_t ) pw@@ all@@ et@@ Main -> Get@@ O@@ l@@ dest@@ Key@@ Pool@@ Time ( ) ) ) ; obj . push_back ( Pair ( " ke@@ ypo@@ ol@@ size " , ( int ) pw@@ all@@ et@@ Main -> GetKey@@ Pool@@ Size ( ) ) ) ; } obj . push_back ( Pair ( " pay@@ tx@@ fe@@ e " , Value@@ From@@ Amount ( nTransactionFee ) ) ) ; obj . push_back ( Pair ( " min@@ input " , Value@@ From@@ Amount ( nMin@@ imum@@ Input@@ Value ) ) ) ; if ( pw@@ all@@ et@@ Main && pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) ) obj . push_back ( Pair ( " un@@ lock@@ ed _ un@@ til " , ( boost :: int64_t ) nWallet@@ Unlock@@ Time ) ) ; obj . push_back ( Pair ( " errors " , Get@@ Warnings ( " statu@@ sb@@ ar " ) ) ) ; return obj ; } Value get@@ new@@ address ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 1 ) throw runtime_error ( " get@@ new@@ address ▁ [ account ] \n " " Retur@@ ns ▁ a ▁ new ▁ I@@ Lo@@ ve@@ You@@ Co@@ ins ▁ address ▁ for ▁ receiving ▁ pay@@ ments . ▁ ▁ " " If ▁ [ account ] ▁ is ▁ specified ▁ ( re@@ comm@@ en@@ ded ) , ▁ it ▁ is ▁ added ▁ to ▁ the ▁ address ▁ book ▁ " " so ▁ pay@@ ments ▁ received ▁ with ▁ the ▁ address ▁ will ▁ be ▁ cre@@ di@@ ted ▁ to ▁ [ account ] . " ) ; string strAccount ; if ( params . size ( ) > 0 ) strAccount = Account@@ From@@ Value ( params [ 0 ] ) ; if ( ! pw@@ all@@ et@@ Main -> Is@@ Locked ( ) ) pw@@ all@@ et@@ Main -> Top@@ Up@@ Key@@ Pool ( ) ; CP@@ ub@@ Key new@@ Key ; if ( ! pw@@ all@@ et@@ Main -> GetKey@@ From@@ Pool ( new@@ Key , false ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ KE@@ Y@@ POOL_@@ RAN@@ _@@ OUT , " Error : ▁ Ke@@ ypo@@ ol ▁ ra@@ n ▁ out , ▁ please ▁ call ▁ ke@@ ypo@@ ol@@ re@@ fill ▁ first " ) ; C@@ Key@@ ID key@@ ID = new@@ Key . GetID ( ) ; pw@@ all@@ et@@ Main -> Set@@ Address@@ Book@@ Name ( key@@ ID , strAccount ) ; return CBitcoinAddress ( key@@ ID ) . ToString ( ) ; } CBitcoinAddress Get@@ Account@@ Address ( string strAccount , bool b@@ Force@@ New = false ) { CWalletDB wall@@ et@@ db ( pw@@ all@@ et@@ Main -> strWalletFile ) ; CAccount account ; wall@@ et@@ db . ReadAccount ( strAccount , account ) ; bool b@@ Key@@ Used = false ; if ( account . vchPubKey . IsValid ( ) ) { CScript scriptPubKey ; scriptPubKey . Set@@ Destination ( account . vchPubKey . GetID ( ) ) ; for ( map < uint256 , CWalletTx > :: iterator it = pw@@ all@@ et@@ Main -> mapWallet . begin ( ) ; it != pw@@ all@@ et@@ Main -> mapWallet . end ( ) && account . vchPubKey . IsValid ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; BOOST_FOREACH ( const CTx@@ Out & tx@@ out , wtx . vout ) if ( tx@@ out . scriptPubKey == scriptPubKey ) b@@ Key@@ Used = true ; } } if ( ! account . vchPubKey . IsValid ( ) || b@@ Force@@ New || b@@ Key@@ Used ) { if ( ! pw@@ all@@ et@@ Main -> GetKey@@ From@@ Pool ( account . vchPubKey , false ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ KE@@ Y@@ POOL_@@ RAN@@ _@@ OUT , " Error : ▁ Ke@@ ypo@@ ol ▁ ra@@ n ▁ out , ▁ please ▁ call ▁ ke@@ ypo@@ ol@@ re@@ fill ▁ first " ) ; pw@@ all@@ et@@ Main -> Set@@ Address@@ Book@@ Name ( account . vchPubKey . GetID ( ) , strAccount ) ; wall@@ et@@ db . WriteAccount ( strAccount , account ) ; } return CBitcoinAddress ( account . vchPubKey . GetID ( ) ) ; } Value get@@ ac@@ count@@ address ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) != 1 ) throw runtime_error ( " get@@ ac@@ count@@ address ▁ < account > \n " " Retur@@ ns ▁ the ▁ current ▁ I@@ Lo@@ ve@@ You@@ Co@@ ins ▁ address ▁ for ▁ receiving ▁ pay@@ ments ▁ to ▁ this ▁ account . " ) ; string strAccount = Account@@ From@@ Value ( params [ 0 ] ) ; Value ret ; ret = Get@@ Account@@ Address ( strAccount ) . ToString ( ) ; return ret ; } Value set@@ account ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " set@@ account ▁ < ilo@@ vey@@ ou@@ coin@@ s@@ address > ▁ < account > \n " " Set@@ s ▁ the ▁ account ▁ associated ▁ with ▁ the ▁ gi@@ ven ▁ address . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID@@ _ADD@@ RESS_@@ OR_@@ KEY , " Invalid ▁ I@@ Lo@@ ve@@ You@@ Co@@ ins ▁ address " ) ; string strAccount ; if ( params . size ( ) > 1 ) strAccount = Account@@ From@@ Value ( params [ 1 ] ) ; if ( pw@@ all@@ et@@ Main -> mapAddress@@ Book . count ( address . Get ( ) ) ) { string str@@ Old@@ Account = pw@@ all@@ et@@ Main -> mapAddress@@ Book [ address . Get ( ) ] ; if ( address == Get@@ Account@@ Address ( str@@ Old@@ Account ) ) Get@@ Account@@ Address ( str@@ Old@@ Account , true ) ; } pw@@ all@@ et@@ Main -> Set@@ Address@@ Book@@ Name ( address . Get ( ) , strAccount ) ; return Value :: null ; } Value get@@ account ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) != 1 ) throw runtime_error ( " get@@ account ▁ < ilo@@ vey@@ ou@@ coin@@ s@@ address > \n " " Retur@@ ns ▁ the ▁ account ▁ associated ▁ with ▁ the ▁ gi@@ ven ▁ address . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID@@ _ADD@@ RESS_@@ OR_@@ KEY , " Invalid ▁ I@@ Lo@@ ve@@ You@@ Co@@ ins ▁ address " ) ; string strAccount ; map < CTxDestination , string > :: iterator mi = pw@@ all@@ et@@ Main -> mapAddress@@ Book . find ( address . Get ( ) ) ; if ( mi != pw@@ all@@ et@@ Main -> mapAddress@@ Book . end ( ) && ! ( * mi ) . second . empty ( ) ) strAccount = ( * mi ) . second ; return strAccount ; } Value get@@ address@@ es@@ by@@ account ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) != 1 ) throw runtime_error ( " get@@ address@@ es@@ by@@ account ▁ < account > \n " " Retur@@ ns ▁ the ▁ list ▁ of ▁ addresses ▁ for ▁ the ▁ gi@@ ven ▁ account . " ) ; string strAccount = Account@@ From@@ Value ( params [ 0 ] ) ; Array ret ; BOOST_FOREACH ( const PAIRTYPE ( CBitcoinAddress , string ) & item , pw@@ all@@ et@@ Main -> mapAddress@@ Book ) { const CBitcoinAddress & address = item . first ; const string & strName = item . second ; if ( strName == strAccount ) ret . push_back ( address . ToString ( ) ) ; } return ret ; } Value set@@ min@@ input ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 1 || params . size ( ) > 1 ) throw runtime_error ( " set@@ min@@ input ▁ < amount > \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ ro@@ unded ▁ to ▁ the ▁ nearest ▁ 0.@@ 0000000@@ 1" ) ; int64 n@@ Amount = 0 ; if ( params [ 0 ] . get_@@ real ( ) != 0.0 ) n@@ Amount = Amo@@ unt@@ From@@ Value ( params [ 0 ] ) ; nMin@@ imum@@ Input@@ Value = n@@ Amount ; return true ; } Value send@@ to@@ address ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 2 || params . size ( ) > 4 ) throw runtime_error ( " send@@ to@@ address ▁ < ilo@@ vey@@ ou@@ coin@@ s@@ address > ▁ < amount > ▁ [ comment ] ▁ [ comment - to ] \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ ro@@ unded ▁ to ▁ the ▁ nearest ▁ 0.@@ 0000000@@ 1" + Help@@ Re@@ qu@@ ir@@ ing@@ P@@ as@@ sp@@ hr@@ ase ( ) ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID@@ _ADD@@ RESS_@@ OR_@@ KEY , " Invalid ▁ I@@ Lo@@ ve@@ You@@ Co@@ ins ▁ address " ) ; int64 n@@ Amount = Amo@@ unt@@ From@@ Value ( params [ 1 ] ) ; CWalletTx wtx ; if ( params . size ( ) > 2 && params [ 2 ] . type ( ) != null@@ _type && ! params [ 2 ] . get_str ( ) . empty ( ) ) wtx . map@@ Value [ " comment " ] = params [ 2 ] . get_str ( ) ; if ( params . size ( ) > 3 && params [ 3 ] . type ( ) != null@@ _type && ! params [ 3 ] . get_str ( ) . empty ( ) ) wtx . map@@ Value [ " to " ] = params [ 3 ] . get_str ( ) ; En@@ sure@@ Wallet@@ Is@@ Unlock@@ ed ( ) ; string str@@ Error = pw@@ all@@ et@@ Main -> Send@@ M@@ one@@ yTo@@ Destination ( address . Get ( ) , n@@ Amount , wtx ) ; if ( str@@ Error != " " ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ ERROR , str@@ Error ) ; return wtx . GetHash ( ) . Get@@ Hex ( ) ; } Value list@@ address@@ group@@ ings ( const Array & params , bool f@@ Help ) { if ( f@@ Help ) throw runtime_error ( " list@@ address@@ group@@ ings \n " " Lists ▁ groups ▁ of ▁ addresses ▁ wh@@ ic@@ h ▁ have ▁ ha@@ d ▁ the@@ ir ▁ common ▁ ownership \n " " ma@@ de ▁ public ▁ by ▁ common ▁ use ▁ as ▁ inputs ▁ or ▁ as ▁ the ▁ result@@ ing ▁ change \n " " in ▁ p@@ ast ▁ trans@@ actions " ) ; Array json@@ Group@@ ings ; map < CTxDestination , int64 > bal@@ an@@ ces = pw@@ all@@ et@@ Main -> Get@@ Address@@ B@@ al@@ an@@ ces ( ) ; BOOST_FOREACH ( set < CTxDestination > group@@ ing , pw@@ all@@ et@@ Main -> Get@@ Address@@ Group@@ ings ( ) ) { Array json@@ Group@@ ing ; BOOST_FOREACH ( CTxDestination address , group@@ ing ) { Array address@@ Info ; address@@ Info . push_back ( CBitcoinAddress ( address ) . ToString ( ) ) ; address@@ Info . push_back ( Value@@ From@@ Amount ( bal@@ an@@ ces [ address ] ) ) ; { LOCK ( pw@@ all@@ et@@ Main -> cs_@@ wallet ) ; if ( pw@@ all@@ et@@ Main -> mapAddress@@ Book . find ( CBitcoinAddress ( address ) . Get ( ) ) != pw@@ all@@ et@@ Main -> mapAddress@@ Book . end ( ) ) address@@ Info . push_back ( pw@@ all@@ et@@ Main -> mapAddress@@ Book . find ( CBitcoinAddress ( address ) . Get ( ) ) -> second ) ; } json@@ Group@@ ing . push_back ( address@@ Info ) ; } json@@ Group@@ ings . push_back ( json@@ Group@@ ing ) ; } return json@@ Group@@ ings ; } Value sign@@ message ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) != 2 ) throw runtime_error ( " sign@@ message ▁ < ilo@@ vey@@ ou@@ coin@@ s@@ address > ▁ < message > \n " " Sign ▁ a ▁ message ▁ with ▁ the ▁ private ▁ key ▁ of ▁ an ▁ address " ) ; En@@ sure@@ Wallet@@ Is@@ Unlock@@ ed ( ) ; string strAddress = params [ 0 ] . get_str ( ) ; string str@@ Message = params [ 1 ] . get_str ( ) ; CBitcoinAddress addr ( strAddress ) ; if ( ! addr . IsValid ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ TYPE_@@ ERROR , " Invalid ▁ address " ) ; C@@ Key@@ ID key@@ ID ; if ( ! addr . GetKey@@ ID ( key@@ ID ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ TYPE_@@ ERROR , " Address ▁ does ▁ not ▁ ref@@ er ▁ to ▁ key " ) ; CKey key ; if ( ! pw@@ all@@ et@@ Main -> GetKey ( key@@ ID , key ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ ERROR , " Private ▁ key ▁ not ▁ available " ) ; CH@@ ash@@ Writer ss ( SER_@@ GE@@ TH@@ ASH , 0 ) ; ss << str@@ Message@@ Mag@@ ic ; ss << str@@ Message ; vector < unsigned char > vchSig ; if ( ! key . Sign@@ Comp@@ act ( ss . GetHash ( ) , vchSig ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID@@ _ADD@@ RESS_@@ OR_@@ KEY , " Sign ▁ failed " ) ; return Encode@@ Base@@ 64 ( & vchSig [ 0 ] , vchSig . size ( ) ) ; } Value verify@@ message ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) != 3 ) throw runtime_error ( " verify@@ message ▁ < ilo@@ vey@@ ou@@ coin@@ s@@ address > ▁ < sign@@ ature > ▁ < message > \n " " Verify ▁ a ▁ signed ▁ message " ) ; string strAddress = params [ 0 ] . get_str ( ) ; string str@@ Sign = params [ 1 ] . get_str ( ) ; string str@@ Message = params [ 2 ] . get_str ( ) ; CBitcoinAddress addr ( strAddress ) ; if ( ! addr . IsValid ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ TYPE_@@ ERROR , " Invalid ▁ address " ) ; C@@ Key@@ ID key@@ ID ; if ( ! addr . GetKey@@ ID ( key@@ ID ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ TYPE_@@ ERROR , " Address ▁ does ▁ not ▁ ref@@ er ▁ to ▁ key " ) ; bool f@@ Invalid = false ; vector < unsigned char > vchSig = Deco@@ de@@ Base@@ 64 ( str@@ Sign . c_str ( ) , & f@@ Invalid ) ; if ( f@@ Invalid ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID@@ _ADD@@ RESS_@@ OR_@@ KEY , " Malform@@ ed ▁ base64 ▁ encoding " ) ; CH@@ ash@@ Writer ss ( SER_@@ GE@@ TH@@ ASH , 0 ) ; ss << str@@ Message@@ Mag@@ ic ; ss << str@@ Message ; CP@@ ub@@ Key p@@ ub@@ key ; if ( ! p@@ ub@@ key . Rec@@ over@@ Comp@@ act ( ss . GetHash ( ) , vchSig ) ) return false ; return ( p@@ ub@@ key . GetID ( ) == key@@ ID ) ; } Value get@@ recei@@ ved@@ by@@ address ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " get@@ recei@@ ved@@ by@@ address ▁ < ilo@@ vey@@ ou@@ coin@@ s@@ address > ▁ [ min@@ conf = 1 ] \n " " Retur@@ ns ▁ the ▁ total ▁ amount ▁ received ▁ by ▁ < ilo@@ vey@@ ou@@ coin@@ s@@ address > ▁ in ▁ trans@@ actions ▁ with ▁ at ▁ le@@ ast ▁ [ min@@ conf ] ▁ confirm@@ ations . " ) ; CBitcoinAddress address = CBitcoinAddress ( params [ 0 ] . get_str ( ) ) ; CScript scriptPubKey ; if ( ! address . IsValid ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID@@ _ADD@@ RESS_@@ OR_@@ KEY , " Invalid ▁ I@@ Lo@@ ve@@ You@@ Co@@ ins ▁ address " ) ; scriptPubKey . Set@@ Destination ( address . Get ( ) ) ; if ( ! IsMine ( * pw@@ all@@ et@@ Main , scriptPubKey ) ) return ( double ) 0.0 ; int nMin@@ Depth = 1 ; if ( params . size ( ) > 1 ) nMin@@ Depth = params [ 1 ] . get_int ( ) ; int64 n@@ Amount = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pw@@ all@@ et@@ Main -> mapWallet . begin ( ) ; it != pw@@ all@@ et@@ Main -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . Is@@ Co@@ in@@ Base ( ) || wtx . Is@@ Co@@ in@@ St@@ a@@ ke ( ) || ! wtx . Is@@ Final ( ) ) continue ; BOOST_FOREACH ( const CTx@@ Out & tx@@ out , wtx . vout ) if ( tx@@ out . scriptPubKey == scriptPubKey ) if ( wtx . Get@@ Depth@@ In@@ Main@@ Chain ( ) >= nMin@@ Depth ) n@@ Amount += tx@@ out . nValue ; } return Value@@ From@@ Amount ( n@@ Amount ) ; } void Get@@ Account@@ Addresses ( string strAccount , set < CTxDestination > & setAddress ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , string ) & item , pw@@ all@@ et@@ Main -> mapAddress@@ Book ) { const CTxDestination & address = item . first ; const string & strName = item . second ; if ( strName == strAccount ) setAddress . insert ( address ) ; } } Value get@@ recei@@ ved@@ by@@ account ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " get@@ recei@@ ved@@ by@@ account ▁ < account > ▁ [ min@@ conf = 1 ] \n " " Retur@@ ns ▁ the ▁ total ▁ amount ▁ received ▁ by ▁ addresses ▁ with ▁ < account > ▁ in ▁ trans@@ actions ▁ with ▁ at ▁ le@@ ast ▁ [ min@@ conf ] ▁ confirm@@ ations . " ) ; int nMin@@ Depth = 1 ; if ( params . size ( ) > 1 ) nMin@@ Depth = params [ 1 ] . get_int ( ) ; string strAccount = Account@@ From@@ Value ( params [ 0 ] ) ; set < CTxDestination > setAddress ; Get@@ Account@@ Addresses ( strAccount , setAddress ) ; int64 n@@ Amount = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pw@@ all@@ et@@ Main -> mapWallet . begin ( ) ; it != pw@@ all@@ et@@ Main -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . Is@@ Co@@ in@@ Base ( ) || wtx . Is@@ Co@@ in@@ St@@ a@@ ke ( ) || ! wtx . Is@@ Final ( ) ) continue ; BOOST_FOREACH ( const CTx@@ Out & tx@@ out , wtx . vout ) { CTxDestination address ; if ( ExtractDestination ( tx@@ out . scriptPubKey , address ) && IsMine ( * pw@@ all@@ et@@ Main , address ) && setAddress . count ( address ) ) if ( wtx . Get@@ Depth@@ In@@ Main@@ Chain ( ) >= nMin@@ Depth ) n@@ Amount += tx@@ out . nValue ; } } return ( double ) n@@ Amount / ( double ) CO@@ IN ; } int64 Get@@ Account@@ B@@ al@@ ance ( CWalletDB & wall@@ et@@ db , const string & strAccount , int nMin@@ Depth ) { int64 n@@ B@@ al@@ ance = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pw@@ all@@ et@@ Main -> mapWallet . begin ( ) ; it != pw@@ all@@ et@@ Main -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . Is@@ Final ( ) ) continue ; int64 n@@ Received , n@@ Sent , n@@ Fee ; wtx . Get@@ Account@@ Amo@@ un@@ ts ( strAccount , n@@ Received , n@@ Sent , n@@ Fee ) ; if ( n@@ Received != 0 && wtx . Get@@ Depth@@ In@@ Main@@ Chain ( ) >= nMin@@ Depth ) n@@ B@@ al@@ ance += n@@ Received ; n@@ B@@ al@@ ance -= n@@ Sent + n@@ Fee ; } n@@ B@@ al@@ ance += wall@@ et@@ db . GetAccountCreditDebit ( strAccount ) ; return n@@ B@@ al@@ ance ; } int64 Get@@ Account@@ B@@ al@@ ance ( const string & strAccount , int nMin@@ Depth ) { CWalletDB wall@@ et@@ db ( pw@@ all@@ et@@ Main -> strWalletFile ) ; return Get@@ Account@@ B@@ al@@ ance ( wall@@ et@@ db , strAccount , nMin@@ Depth ) ; } Value get@@ bal@@ ance ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 2 ) throw runtime_error ( " get@@ bal@@ ance ▁ [ account ] ▁ [ min@@ conf = 1 ] \n " " If ▁ [ account ] ▁ is ▁ not ▁ specified , ▁ returns ▁ the ▁ server ' s ▁ total ▁ available ▁ bal@@ ance . \n " " If ▁ [ account ] ▁ is ▁ specified , ▁ returns ▁ the ▁ bal@@ ance ▁ in ▁ the ▁ account . " ) ; if ( params . size ( ) == 0 ) return Value@@ From@@ Amount ( pw@@ all@@ et@@ Main -> GetB@@ al@@ ance ( ) ) ; int nMin@@ Depth = 1 ; if ( params . size ( ) > 1 ) nMin@@ Depth = params [ 1 ] . get_int ( ) ; if ( params [ 0 ] . get_str ( ) == " * " ) { int64 n@@ B@@ al@@ ance = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pw@@ all@@ et@@ Main -> mapWallet . begin ( ) ; it != pw@@ all@@ et@@ Main -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . IsConfirm@@ ed ( ) ) continue ; int64 all@@ Fee ; string str@@ S@@ ent@@ Account ; list < pair < CTxDestination , int64 > > list@@ Received ; list < pair < CTxDestination , int64 > > list@@ Sent ; wtx . Get@@ Amo@@ un@@ ts ( list@@ Received , list@@ Sent , all@@ Fee , str@@ S@@ ent@@ Account ) ; if ( wtx . Get@@ Depth@@ In@@ Main@@ Chain ( ) >= nMin@@ Depth ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , list@@ Received ) n@@ B@@ al@@ ance += r . second ; } BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , list@@ Sent ) n@@ B@@ al@@ ance -= r . second ; n@@ B@@ al@@ ance -= all@@ Fee ; } return Value@@ From@@ Amount ( n@@ B@@ al@@ ance ) ; } string strAccount = Account@@ From@@ Value ( params [ 0 ] ) ; int64 n@@ B@@ al@@ ance = Get@@ Account@@ B@@ al@@ ance ( strAccount , nMin@@ Depth ) ; return Value@@ From@@ Amount ( n@@ B@@ al@@ ance ) ; } Value get@@ un@@ confirm@@ ed@@ bal@@ ance ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 0 ) throw runtime_error ( " get@@ un@@ confirm@@ ed@@ bal@@ ance \n " " Retur@@ ns ▁ the ▁ server ' s ▁ total ▁ un@@ confirmed ▁ bal@@ ance \n " ) ; return Value@@ From@@ Amount ( pw@@ all@@ et@@ Main -> Get@@ Un@@ confirm@@ ed@@ B@@ al@@ ance ( ) ) ; } Value movec@@ md ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 3 || params . size ( ) > 5 ) throw runtime_error ( " move ▁ < from@@ account > ▁ < to@@ account > ▁ < amount > ▁ [ min@@ conf = 1 ] ▁ [ comment ] \n " " Move ▁ from ▁ one ▁ account ▁ in ▁ your ▁ wallet ▁ to ▁ an@@ other . " ) ; string str@@ From = Account@@ From@@ Value ( params [ 0 ] ) ; string str@@ To = Account@@ From@@ Value ( params [ 1 ] ) ; int64 n@@ Amount = Amo@@ unt@@ From@@ Value ( params [ 2 ] ) ; if ( params . size ( ) > 3 ) ( void ) params [ 3 ] . get_int ( ) ; string str@@ Comm@@ ent ; if ( params . size ( ) > 4 ) str@@ Comm@@ ent = params [ 4 ] . get_str ( ) ; CWalletDB wall@@ et@@ db ( pw@@ all@@ et@@ Main -> strWalletFile ) ; if ( ! wall@@ et@@ db . Tx@@ n@@ Begin ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ DAT@@ AB@@ AS@@ E_@@ ERROR , " database ▁ error " ) ; int64 n@@ Now = Get@@ Adjust@@ ed@@ Time ( ) ; CAccountingEntry de@@ bit ; de@@ bit . n@@ Or@@ der@@ Pos = pw@@ all@@ et@@ Main -> In@@ c@@ Or@@ der@@ Pos@@ Next ( & wall@@ et@@ db ) ; de@@ bit . strAccount = str@@ From ; de@@ bit . nCreditDebit = - n@@ Amount ; de@@ bit . nTime = n@@ Now ; de@@ bit . str@@ Other@@ Account = str@@ To ; de@@ bit . str@@ Comm@@ ent = str@@ Comm@@ ent ; wall@@ et@@ db . WriteAccountingEntry ( de@@ bit ) ; CAccountingEntry cre@@ di@@ t ; cre@@ di@@ t . n@@ Or@@ der@@ Pos = pw@@ all@@ et@@ Main -> In@@ c@@ Or@@ der@@ Pos@@ Next ( & wall@@ et@@ db ) ; cre@@ di@@ t . strAccount = str@@ To ; cre@@ di@@ t . nCreditDebit = n@@ Amount ; cre@@ di@@ t . nTime = n@@ Now ; cre@@ di@@ t . str@@ Other@@ Account = str@@ From ; cre@@ di@@ t . str@@ Comm@@ ent = str@@ Comm@@ ent ; wall@@ et@@ db . WriteAccountingEntry ( cre@@ di@@ t ) ; if ( ! wall@@ et@@ db . Tx@@ n@@ Commit ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ DAT@@ AB@@ AS@@ E_@@ ERROR , " database ▁ error " ) ; return true ; } Value send@@ from ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 3 || params . size ( ) > 6 ) throw runtime_error ( " send@@ from ▁ < from@@ account > ▁ < to@@ ilo@@ vey@@ ou@@ coin@@ s@@ address > ▁ < amount > ▁ [ min@@ conf = 1 ] ▁ [ comment ] ▁ [ comment - to ] \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ ro@@ unded ▁ to ▁ the ▁ nearest ▁ 0.@@ 0000000@@ 1" + Help@@ Re@@ qu@@ ir@@ ing@@ P@@ as@@ sp@@ hr@@ ase ( ) ) ; string strAccount = Account@@ From@@ Value ( params [ 0 ] ) ; CBitcoinAddress address ( params [ 1 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID@@ _ADD@@ RESS_@@ OR_@@ KEY , " Invalid ▁ I@@ Lo@@ ve@@ You@@ Co@@ ins ▁ address " ) ; int64 n@@ Amount = Amo@@ unt@@ From@@ Value ( params [ 2 ] ) ; int nMin@@ Depth = 1 ; if ( params . size ( ) > 3 ) nMin@@ Depth = params [ 3 ] . get_int ( ) ; CWalletTx wtx ; wtx . strFromAccount = strAccount ; if ( params . size ( ) > 4 && params [ 4 ] . type ( ) != null@@ _type && ! params [ 4 ] . get_str ( ) . empty ( ) ) wtx . map@@ Value [ " comment " ] = params [ 4 ] . get_str ( ) ; if ( params . size ( ) > 5 && params [ 5 ] . type ( ) != null@@ _type && ! params [ 5 ] . get_str ( ) . empty ( ) ) wtx . map@@ Value [ " to " ] = params [ 5 ] . get_str ( ) ; En@@ sure@@ Wallet@@ Is@@ Unlock@@ ed ( ) ; int64 n@@ B@@ al@@ ance = Get@@ Account@@ B@@ al@@ ance ( strAccount , nMin@@ Depth ) ; if ( n@@ Amount > n@@ B@@ al@@ ance ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ IN@@ SU@@ FF@@ IC@@ I@@ ENT_@@ FUN@@ DS , " Account ▁ has ▁ in@@ su@@ ffi@@ ci@@ ent ▁ fun@@ ds " ) ; string str@@ Error = pw@@ all@@ et@@ Main -> Send@@ M@@ one@@ yTo@@ Destination ( address . Get ( ) , n@@ Amount , wtx ) ; if ( str@@ Error != " " ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ ERROR , str@@ Error ) ; return wtx . GetHash ( ) . Get@@ Hex ( ) ; } Value send@@ m@@ any ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 2 || params . size ( ) > 4 ) throw runtime_error ( " send@@ m@@ any ▁ < from@@ account > ▁ { address : amount , . . . } ▁ [ min@@ conf = 1 ] ▁ [ comment ] \n " " am@@ oun@@ ts ▁ are ▁ double - precision ▁ float@@ ing ▁ point ▁ numbers " + Help@@ Re@@ qu@@ ir@@ ing@@ P@@ as@@ sp@@ hr@@ ase ( ) ) ; string strAccount = Account@@ From@@ Value ( params [ 0 ] ) ; Object send@@ To = params [ 1 ] . get_@@ obj ( ) ; int nMin@@ Depth = 1 ; if ( params . size ( ) > 2 ) nMin@@ Depth = params [ 2 ] . get_int ( ) ; CWalletTx wtx ; wtx . strFromAccount = strAccount ; if ( params . size ( ) > 3 && params [ 3 ] . type ( ) != null@@ _type && ! params [ 3 ] . get_str ( ) . empty ( ) ) wtx . map@@ Value [ " comment " ] = params [ 3 ] . get_str ( ) ; set < CBitcoinAddress > setAddress ; vector < pair < CScript , int64 > > vec@@ Send ; int64 total@@ Amount = 0 ; BOOST_FOREACH ( const Pair & s , send@@ To ) { CBitcoinAddress address ( s . name_ ) ; if ( ! address . IsValid ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID@@ _ADD@@ RESS_@@ OR_@@ KEY , string ( " Invalid ▁ I@@ Lo@@ ve@@ You@@ Co@@ ins ▁ address : ▁ " ) + s . name_ ) ; if ( setAddress . count ( address ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID_@@ PARAME@@ TER , string ( " Invalid ▁ parameter , ▁ dup@@ lic@@ ated ▁ address : ▁ " ) + s . name_ ) ; setAddress . insert ( address ) ; CScript scriptPubKey ; scriptPubKey . Set@@ Destination ( address . Get ( ) ) ; int64 n@@ Amount = Amo@@ unt@@ From@@ Value ( s . value@@ _ ) ; total@@ Amount += n@@ Amount ; vec@@ Send . push_back ( make_pair ( scriptPubKey , n@@ Amount ) ) ; } En@@ sure@@ Wallet@@ Is@@ Unlock@@ ed ( ) ; int64 n@@ B@@ al@@ ance = Get@@ Account@@ B@@ al@@ ance ( strAccount , nMin@@ Depth ) ; if ( total@@ Amount > n@@ B@@ al@@ ance ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ IN@@ SU@@ FF@@ IC@@ I@@ ENT_@@ FUN@@ DS , " Account ▁ has ▁ in@@ su@@ ffi@@ ci@@ ent ▁ fun@@ ds " ) ; C@@ Reser@@ ve@@ Key key@@ Change ( pw@@ all@@ et@@ Main ) ; int64 n@@ Fe@@ e@@ Required = 0 ; string str@@ Fail@@ Reason ; bool f@@ Created = pw@@ all@@ et@@ Main -> Create@@ Transaction ( vec@@ Send , wtx , key@@ Change , n@@ Fe@@ e@@ Required , str@@ Fail@@ Reason ) ; if ( ! f@@ Created ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ IN@@ SU@@ FF@@ IC@@ I@@ ENT_@@ FUN@@ DS , str@@ Fail@@ Reason ) ; if ( ! pw@@ all@@ et@@ Main -> Comm@@ it@@ Transaction ( wtx , key@@ Change ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ ERROR , " Transaction ▁ comm@@ it ▁ failed " ) ; return wtx . GetHash ( ) . Get@@ Hex ( ) ; } static CScript _@@ create@@ multisig ( const Array & params ) { int nRequired = params [ 0 ] . get_int ( ) ; const Array & keys = params [ 1 ] . get_array ( ) ; if ( nRequired < 1 ) throw runtime_error ( " a ▁ multi@@ sign@@ ature ▁ address ▁ must ▁ require ▁ at ▁ le@@ ast ▁ one ▁ key ▁ to ▁ re@@ de@@ em " ) ; if ( ( int ) keys . size ( ) < nRequired ) throw runtime_error ( strprintf ( " not ▁ enough ▁ keys ▁ sup@@ p@@ lied ▁ " " ( got ▁ % " PR@@ Is@@ zu " ▁ keys , ▁ bu@@ t ▁ need ▁ at ▁ le@@ ast ▁ % d ▁ to ▁ re@@ de@@ em ) " , keys . size ( ) , nRequired ) ) ; std :: vector < CP@@ ub@@ Key > p@@ ub@@ keys ; p@@ ub@@ keys . resize ( keys . size ( ) ) ; for ( unsigned int i = 0 ; i < keys . size ( ) ; i ++ ) { const std :: string & ks = keys [ i ] . get_str ( ) ; CBitcoinAddress address ( ks ) ; if ( pw@@ all@@ et@@ Main && address . IsValid ( ) ) { C@@ Key@@ ID key@@ ID ; if ( ! address . GetKey@@ ID ( key@@ ID ) ) throw runtime_error ( strprintf ( " % s ▁ does ▁ not ▁ ref@@ er ▁ to ▁ a ▁ key " , ks . c_str ( ) ) ) ; CP@@ ub@@ Key vchPubKey ; if ( ! pw@@ all@@ et@@ Main -> GetPubKey ( key@@ ID , vchPubKey ) ) throw runtime_error ( strprintf ( " no ▁ full ▁ public ▁ key ▁ for ▁ address ▁ % s " , ks . c_str ( ) ) ) ; if ( ! vchPubKey . Is@@ Ful@@ ly@@ Valid ( ) ) throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; p@@ ub@@ keys [ i ] = vchPubKey ; } else if ( Is@@ Hex ( ks ) ) { CP@@ ub@@ Key vchPubKey ( ParseHex ( ks ) ) ; if ( ! vchPubKey . Is@@ Ful@@ ly@@ Valid ( ) ) throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; p@@ ub@@ keys [ i ] = vchPubKey ; } else { throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; } } CScript result ; result . Set@@ Multi@@ sig ( nRequired , p@@ ub@@ keys ) ; return result ; } Value addmultisigaddress ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 2 || params . size ( ) > 3 ) { string msg = " addmultisigaddress ▁ < n@@ required > ▁ < ' [ \ " key@@ \ " , \ " key@@ \ " ] ' > ▁ [ account ] \n " " Add ▁ a ▁ n@@ required - to - sign ▁ multi@@ sign@@ ature ▁ address ▁ to ▁ the ▁ wall@@ et@@ \ " \n " " each ▁ key ▁ is ▁ a ▁ I@@ Lo@@ ve@@ You@@ Co@@ ins ▁ address ▁ or ▁ hex - en@@ coded ▁ public ▁ key \n " " If ▁ [ account ] ▁ is ▁ specified , ▁ assign ▁ address ▁ to ▁ [ account ] . " ; throw runtime_error ( msg ) ; } string strAccount ; if ( params . size ( ) > 2 ) strAccount = Account@@ From@@ Value ( params [ 2 ] ) ; CScript inner = _@@ create@@ multisig ( params ) ; C@@ Script@@ ID inner@@ ID = inner . GetID ( ) ; pw@@ all@@ et@@ Main -> Add@@ CScript ( inner ) ; pw@@ all@@ et@@ Main -> Set@@ Address@@ Book@@ Name ( inner@@ ID , strAccount ) ; return CBitcoinAddress ( inner@@ ID ) . ToString ( ) ; } Value create@@ multisig ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 2 || params . size ( ) > 2 ) { string msg = " create@@ multisig ▁ < n@@ required > ▁ < ' [ \ " key@@ \ " , \ " key@@ \ " ] ' > \n " " Cre@@ ates ▁ a ▁ multi - sign@@ ature ▁ address ▁ and ▁ returns ▁ a ▁ json ▁ object \n " " with ▁ keys : \n " " address ▁ : ▁ ilo@@ vey@@ ou@@ coins ▁ address \n " " re@@ de@@ em@@ Script ▁ : ▁ hex - en@@ coded ▁ re@@ de@@ mp@@ tion ▁ script " ; throw runtime_error ( msg ) ; } CScript inner = _@@ create@@ multisig ( params ) ; C@@ Script@@ ID inner@@ ID = inner . GetID ( ) ; CBitcoinAddress address ( inner@@ ID ) ; Object result ; result . push_back ( Pair ( " address " , address . ToString ( ) ) ) ; result . push_back ( Pair ( " re@@ de@@ em@@ Script " , Hex@@ Str ( inner . begin ( ) , inner . end ( ) ) ) ) ; return result ; } struct t@@ ally@@ item { int64 n@@ Amount ; int n@@ Conf ; vector < uint256 > tx@@ ids ; t@@ ally@@ item ( ) { n@@ Amount = 0 ; n@@ Conf = std :: numer@@ ic@@ _@@ limits < int > :: max ( ) ; } } ; Value List@@ Received ( const Array & params , bool f@@ By@@ Accounts ) { int nMin@@ Depth = 1 ; if ( params . size ( ) > 0 ) nMin@@ Depth = params [ 0 ] . get_int ( ) ; bool fIn@@ clude@@ Empty = false ; if ( params . size ( ) > 1 ) fIn@@ clude@@ Empty = params [ 1 ] . get_@@ bool ( ) ; map < CBitcoinAddress , t@@ ally@@ item > map@@ T@@ ally ; for ( map < uint256 , CWalletTx > :: iterator it = pw@@ all@@ et@@ Main -> mapWallet . begin ( ) ; it != pw@@ all@@ et@@ Main -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . Is@@ Co@@ in@@ Base ( ) || wtx . Is@@ Co@@ in@@ St@@ a@@ ke ( ) || ! wtx . Is@@ Final ( ) ) continue ; int n@@ Depth = wtx . Get@@ Depth@@ In@@ Main@@ Chain ( ) ; if ( n@@ Depth < nMin@@ Depth ) continue ; BOOST_FOREACH ( const CTx@@ Out & tx@@ out , wtx . vout ) { CTxDestination address ; if ( ! ExtractDestination ( tx@@ out . scriptPubKey , address ) || ! IsMine ( * pw@@ all@@ et@@ Main , address ) ) continue ; t@@ ally@@ item & item = map@@ T@@ ally [ address ] ; item . n@@ Amount += tx@@ out . nValue ; item . n@@ Conf = min ( item . n@@ Conf , n@@ Depth ) ; item . tx@@ ids . push_back ( wtx . GetHash ( ) ) ; } } Array ret ; map < string , t@@ ally@@ item > map@@ Account@@ T@@ ally ; BOOST_FOREACH ( const PAIRTYPE ( CBitcoinAddress , string ) & item , pw@@ all@@ et@@ Main -> mapAddress@@ Book ) { const CBitcoinAddress & address = item . first ; const string & strAccount = item . second ; map < CBitcoinAddress , t@@ ally@@ item > :: iterator it = map@@ T@@ ally . find ( address ) ; if ( it == map@@ T@@ ally . end ( ) && ! fIn@@ clude@@ Empty ) continue ; int64 n@@ Amount = 0 ; int n@@ Conf = std :: numer@@ ic@@ _@@ limits < int > :: max ( ) ; if ( it != map@@ T@@ ally . end ( ) ) { n@@ Amount = ( * it ) . second . n@@ Amount ; n@@ Conf = ( * it ) . second . n@@ Conf ; } if ( f@@ By@@ Accounts ) { t@@ ally@@ item & item = map@@ Account@@ T@@ ally [ strAccount ] ; item . n@@ Amount += n@@ Amount ; item . n@@ Conf = min ( item . n@@ Conf , n@@ Conf ) ; } else { Object obj ; obj . push_back ( Pair ( " address " , address . ToString ( ) ) ) ; obj . push_back ( Pair ( " account " , strAccount ) ) ; obj . push_back ( Pair ( " amount " , Value@@ From@@ Amount ( n@@ Amount ) ) ) ; obj . push_back ( Pair ( " confirm@@ ations " , ( n@@ Conf == std :: numer@@ ic@@ _@@ limits < int > :: max ( ) ? 0 : n@@ Conf ) ) ) ; Array trans@@ actions ; if ( it != map@@ T@@ ally . end ( ) ) { BOOST_FOREACH ( const uint256 & item , ( * it ) . second . tx@@ ids ) { trans@@ actions . push_back ( item . Get@@ Hex ( ) ) ; } } obj . push_back ( Pair ( " tx@@ ids " , trans@@ actions ) ) ; ret . push_back ( obj ) ; } } if ( f@@ By@@ Accounts ) { for ( map < string , t@@ ally@@ item > :: iterator it = map@@ Account@@ T@@ ally . begin ( ) ; it != map@@ Account@@ T@@ ally . end ( ) ; ++ it ) { int64 n@@ Amount = ( * it ) . second . n@@ Amount ; int n@@ Conf = ( * it ) . second . n@@ Conf ; Object obj ; obj . push_back ( Pair ( " account " , ( * it ) . first ) ) ; obj . push_back ( Pair ( " amount " , Value@@ From@@ Amount ( n@@ Amount ) ) ) ; obj . push_back ( Pair ( " confirm@@ ations " , ( n@@ Conf == std :: numer@@ ic@@ _@@ limits < int > :: max ( ) ? 0 : n@@ Conf ) ) ) ; ret . push_back ( obj ) ; } } return ret ; } Value list@@ recei@@ ved@@ by@@ address ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 2 ) throw runtime_error ( " list@@ recei@@ ved@@ by@@ address ▁ [ min@@ conf = 1 ] ▁ [ include@@ empty = false ] \n " " [ min@@ conf ] ▁ is ▁ the ▁ min@@ im@@ um ▁ number ▁ of ▁ confirm@@ ations ▁ before ▁ pay@@ ments ▁ are ▁ inclu@@ ded . \n " " [ include@@ empty ] ▁ wh@@ et@@ h@@ er ▁ to ▁ include ▁ addresses ▁ that ▁ have@@ n ' t ▁ received ▁ any ▁ pay@@ ments . \n " " Retur@@ ns ▁ an ▁ array ▁ of ▁ objects ▁ containing : \n " " ▁ ▁ \ " address@@ \ " ▁ : ▁ receiving ▁ address \n " " ▁ ▁ \ " ac@@ count@@ \ " ▁ : ▁ the ▁ account ▁ of ▁ the ▁ receiving ▁ address \n " " ▁ ▁ \ " am@@ o@@ unt@@ \ " ▁ : ▁ total ▁ amount ▁ received ▁ by ▁ the ▁ address \n " " ▁ ▁ \ " confirm@@ ation@@ s\ " ▁ : ▁ number ▁ of ▁ confirm@@ ations ▁ of ▁ the ▁ mo@@ st ▁ rec@@ ent ▁ transaction ▁ inclu@@ ded \n " " ▁ ▁ \ " tx@@ id@@ s\ " ▁ : ▁ list ▁ of ▁ trans@@ actions ▁ with ▁ output@@ s ▁ to ▁ the ▁ address \n " ) ; return List@@ Received ( params , false ) ; } Value list@@ recei@@ ved@@ by@@ account ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 2 ) throw runtime_error ( " list@@ recei@@ ved@@ by@@ account ▁ [ min@@ conf = 1 ] ▁ [ include@@ empty = false ] \n " " [ min@@ conf ] ▁ is ▁ the ▁ min@@ im@@ um ▁ number ▁ of ▁ confirm@@ ations ▁ before ▁ pay@@ ments ▁ are ▁ inclu@@ ded . \n " " [ include@@ empty ] ▁ wh@@ et@@ h@@ er ▁ to ▁ include ▁ ac@@ coun@@ ts ▁ that ▁ have@@ n ' t ▁ received ▁ any ▁ pay@@ ments . \n " " Retur@@ ns ▁ an ▁ array ▁ of ▁ objects ▁ containing : \n " " ▁ ▁ \ " ac@@ count@@ \ " ▁ : ▁ the ▁ account ▁ of ▁ the ▁ receiving ▁ addresses \n " " ▁ ▁ \ " am@@ o@@ unt@@ \ " ▁ : ▁ total ▁ amount ▁ received ▁ by ▁ addresses ▁ with ▁ this ▁ account \n " " ▁ ▁ \ " confirm@@ ation@@ s\ " ▁ : ▁ number ▁ of ▁ confirm@@ ations ▁ of ▁ the ▁ mo@@ st ▁ rec@@ ent ▁ transaction ▁ inclu@@ ded " ) ; return List@@ Received ( params , true ) ; } static void Ma@@ y@@ be@@ Push@@ Address ( Object & entry , const CTxDestination & dest ) { CBitcoinAddress addr ; if ( addr . Set ( dest ) ) entry . push_back ( Pair ( " address " , addr . ToString ( ) ) ) ; } void List@@ Transac@@ tions ( const CWalletTx & wtx , const string & strAccount , int nMin@@ Depth , bool f@@ Long , Array & ret ) { int64 n@@ Fee ; string str@@ S@@ ent@@ Account ; list < pair < CTxDestination , int64 > > list@@ Received ; list < pair < CTxDestination , int64 > > list@@ Sent ; wtx . Get@@ Amo@@ un@@ ts ( list@@ Received , list@@ Sent , n@@ Fee , str@@ S@@ ent@@ Account ) ; bool fAllAccounts = ( strAccount == string ( " * " ) ) ; if ( ! wtx . Is@@ Co@@ in@@ St@@ a@@ ke ( ) && ( ! list@@ Sent . empty ( ) || n@@ Fee != 0 ) && ( fAllAccounts || strAccount == str@@ S@@ ent@@ Account ) ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & s , list@@ Sent ) { Object entry ; entry . push_back ( Pair ( " account " , str@@ S@@ ent@@ Account ) ) ; Ma@@ y@@ be@@ Push@@ Address ( entry , s . first ) ; entry . push_back ( Pair ( " category " , " send " ) ) ; entry . push_back ( Pair ( " amount " , Value@@ From@@ Amount ( - s . second ) ) ) ; entry . push_back ( Pair ( " fe@@ e " , Value@@ From@@ Amount ( - n@@ Fee ) ) ) ; if ( f@@ Long ) Wallet@@ Tx@@ To@@ JS@@ ON ( wtx , entry ) ; ret . push_back ( entry ) ; } } if ( list@@ Received . size ( ) > 0 && wtx . Get@@ Depth@@ In@@ Main@@ Chain ( ) >= nMin@@ Depth ) { bool stop = false ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , list@@ Received ) { string account ; if ( pw@@ all@@ et@@ Main -> mapAddress@@ Book . count ( r . first ) ) account = pw@@ all@@ et@@ Main -> mapAddress@@ Book [ r . first ] ; if ( fAllAccounts || ( account == strAccount ) ) { Object entry ; entry . push_back ( Pair ( " account " , account ) ) ; Ma@@ y@@ be@@ Push@@ Address ( entry , r . first ) ; if ( wtx . Is@@ Co@@ in@@ Base ( ) || wtx . Is@@ Co@@ in@@ St@@ a@@ ke ( ) ) { if ( wtx . Get@@ Depth@@ In@@ Main@@ Chain ( ) < 1 ) entry . push_back ( Pair ( " category " , " orph@@ an " ) ) ; else if ( wtx . GetBlock@@ sTo@@ Mat@@ urity ( ) > 0 ) entry . push_back ( Pair ( " category " , " im@@ m@@ ature " ) ) ; else if ( wtx . Is@@ Co@@ in@@ St@@ a@@ ke ( ) ) entry . push_back ( Pair ( " category " , " st@@ a@@ ke " ) ) ; else entry . push_back ( Pair ( " category " , " generate " ) ) ; } else { entry . push_back ( Pair ( " category " , " receive " ) ) ; } if ( ! wtx . Is@@ Co@@ in@@ St@@ a@@ ke ( ) ) entry . push_back ( Pair ( " amount " , Value@@ From@@ Amount ( r . second ) ) ) ; else { entry . push_back ( Pair ( " amount " , Value@@ From@@ Amount ( - n@@ Fee ) ) ) ; stop = true ; } if ( f@@ Long ) Wallet@@ Tx@@ To@@ JS@@ ON ( wtx , entry ) ; ret . push_back ( entry ) ; } if ( stop ) break ; } } } void Ac@@ entry@@ To@@ JS@@ ON ( const CAccountingEntry & acentry , const string & strAccount , Array & ret ) { bool fAllAccounts = ( strAccount == string ( " * " ) ) ; if ( fAllAccounts || acentry . strAccount == strAccount ) { Object entry ; entry . push_back ( Pair ( " account " , acentry . strAccount ) ) ; entry . push_back ( Pair ( " category " , " move " ) ) ; entry . push_back ( Pair ( " time " , ( boost :: int64_t ) acentry . nTime ) ) ; entry . push_back ( Pair ( " amount " , Value@@ From@@ Amount ( acentry . nCreditDebit ) ) ) ; entry . push_back ( Pair ( " other@@ account " , acentry . str@@ Other@@ Account ) ) ; entry . push_back ( Pair ( " comment " , acentry . str@@ Comm@@ ent ) ) ; ret . push_back ( entry ) ; } } Value list@@ trans@@ actions ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 3 ) throw runtime_error ( " list@@ trans@@ actions ▁ [ account ] ▁ [ count = 10 ] ▁ [ from = 0 ] \n " " Retur@@ ns ▁ up ▁ to ▁ [ count ] ▁ mo@@ st ▁ rec@@ ent ▁ trans@@ actions ▁ ski@@ pping ▁ the ▁ first ▁ [ from ] ▁ trans@@ actions ▁ for ▁ account ▁ [ account ] . " ) ; string strAccount = " * " ; if ( params . size ( ) > 0 ) strAccount = params [ 0 ] . get_str ( ) ; int n@@ Count = 10 ; if ( params . size ( ) > 1 ) n@@ Count = params [ 1 ] . get_int ( ) ; int n@@ From = 0 ; if ( params . size ( ) > 2 ) n@@ From = params [ 2 ] . get_int ( ) ; if ( n@@ Count < 0 ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID_@@ PARAME@@ TER , " Neg@@ ative ▁ count " ) ; if ( n@@ From < 0 ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID_@@ PARAME@@ TER , " Neg@@ ative ▁ from " ) ; Array ret ; std :: list < CAccountingEntry > ac@@ entries ; CWallet :: Tx@@ Items tx@@ Or@@ de@@ red = pw@@ all@@ et@@ Main -> Or@@ de@@ red@@ Tx@@ Items ( ac@@ entries , strAccount ) ; for ( CWallet :: Tx@@ Items :: reverse@@ _iterator it = tx@@ Or@@ de@@ red . r@@ begin ( ) ; it != tx@@ Or@@ de@@ red . ren@@ d ( ) ; ++ it ) { CWalletTx * const pw@@ tx = ( * it ) . second . first ; if ( pw@@ tx != 0 ) List@@ Transac@@ tions ( * pw@@ tx , strAccount , 0 , true , ret ) ; CAccountingEntry * const p@@ acentry = ( * it ) . second . second ; if ( p@@ acentry != 0 ) Ac@@ entry@@ To@@ JS@@ ON ( * p@@ acentry , strAccount , ret ) ; if ( ( int ) ret . size ( ) >= ( n@@ Count + n@@ From ) ) break ; } if ( n@@ From > ( int ) ret . size ( ) ) n@@ From = ret . size ( ) ; if ( ( n@@ From + n@@ Count ) > ( int ) ret . size ( ) ) n@@ Count = ret . size ( ) - n@@ From ; Array :: iterator first = ret . begin ( ) ; std :: advance ( first , n@@ From ) ; Array :: iterator last = ret . begin ( ) ; std :: advance ( last , n@@ From + n@@ Count ) ; if ( last != ret . end ( ) ) ret . erase ( last , ret . end ( ) ) ; if ( first != ret . begin ( ) ) ret . erase ( ret . begin ( ) , first ) ; std :: re@@ verse ( ret . begin ( ) , ret . end ( ) ) ; return ret ; } Value list@@ ac@@ coun@@ ts ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 1 ) throw runtime_error ( " list@@ ac@@ coun@@ ts ▁ [ min@@ conf = 1 ] \n " " Retur@@ ns ▁ Object ▁ that ▁ has ▁ account ▁ names ▁ as ▁ keys , ▁ account ▁ bal@@ an@@ ces ▁ as ▁ values . " ) ; int nMin@@ Depth = 1 ; if ( params . size ( ) > 0 ) nMin@@ Depth = params [ 0 ] . get_int ( ) ; map < string , int64 > map@@ Account@@ B@@ al@@ an@@ ces ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , string ) & entry , pw@@ all@@ et@@ Main -> mapAddress@@ Book ) { if ( IsMine ( * pw@@ all@@ et@@ Main , entry . first ) ) map@@ Account@@ B@@ al@@ an@@ ces [ entry . second ] = 0 ; } for ( map < uint256 , CWalletTx > :: iterator it = pw@@ all@@ et@@ Main -> mapWallet . begin ( ) ; it != pw@@ all@@ et@@ Main -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; int64 n@@ Fee ; string str@@ S@@ ent@@ Account ; list < pair < CTxDestination , int64 > > list@@ Received ; list < pair < CTxDestination , int64 > > list@@ Sent ; wtx . Get@@ Amo@@ un@@ ts ( list@@ Received , list@@ Sent , n@@ Fee , str@@ S@@ ent@@ Account ) ; map@@ Account@@ B@@ al@@ an@@ ces [ str@@ S@@ ent@@ Account ] -= n@@ Fee ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & s , list@@ Sent ) map@@ Account@@ B@@ al@@ an@@ ces [ str@@ S@@ ent@@ Account ] -= s . second ; if ( wtx . Get@@ Depth@@ In@@ Main@@ Chain ( ) >= nMin@@ Depth ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , list@@ Received ) if ( pw@@ all@@ et@@ Main -> mapAddress@@ Book . count ( r . first ) ) map@@ Account@@ B@@ al@@ an@@ ces [ pw@@ all@@ et@@ Main -> mapAddress@@ Book [ r . first ] ] += r . second ; else map@@ Account@@ B@@ al@@ an@@ ces [ " " ] += r . second ; } } list < CAccountingEntry > ac@@ entries ; CWalletDB ( pw@@ all@@ et@@ Main -> strWalletFile ) . ListAccountCreditDebit ( " * " , ac@@ entries ) ; BOOST_FOREACH ( const CAccountingEntry & entry , ac@@ entries ) map@@ Account@@ B@@ al@@ an@@ ces [ entry . strAccount ] += entry . nCreditDebit ; Object ret ; BOOST_FOREACH ( const PAIRTYPE ( string , int64 ) & ac@@ count@@ B@@ al@@ ance , map@@ Account@@ B@@ al@@ an@@ ces ) { ret . push_back ( Pair ( ac@@ count@@ B@@ al@@ ance . first , Value@@ From@@ Amount ( ac@@ count@@ B@@ al@@ ance . second ) ) ) ; } return ret ; } Value list@@ sin@@ ce@@ block ( const Array & params , bool f@@ Help ) { if ( f@@ Help ) throw runtime_error ( " list@@ sin@@ ce@@ block ▁ [ block@@ hash ] ▁ [ target - confirm@@ ations ] \n " " Get ▁ all ▁ trans@@ actions ▁ in ▁ block@@ s ▁ sin@@ ce ▁ block ▁ [ block@@ hash ] , ▁ or ▁ all ▁ trans@@ actions ▁ if ▁ om@@ it@@ ted " ) ; CBlockIndex * pindex = NULL ; int tar@@ get_@@ confi@@ r@@ ms = 1 ; if ( params . size ( ) > 0 ) { uint256 block@@ Id = 0 ; block@@ Id . Set@@ Hex ( params [ 0 ] . get_str ( ) ) ; pindex = C@@ Block@@ Loc@@ ator ( block@@ Id ) . Get@@ BlockIndex ( ) ; } if ( params . size ( ) > 1 ) { tar@@ get_@@ confi@@ r@@ ms = params [ 1 ] . get_int ( ) ; if ( tar@@ get_@@ confi@@ r@@ ms < 1 ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID_@@ PARAME@@ TER , " Invalid ▁ parameter " ) ; } int depth = pindex ? ( 1 + nBestHeight - pindex -> nHeight ) : - 1 ; Array trans@@ actions ; for ( map < uint256 , CWalletTx > :: iterator it = pw@@ all@@ et@@ Main -> mapWallet . begin ( ) ; it != pw@@ all@@ et@@ Main -> mapWallet . end ( ) ; it ++ ) { CWalletTx tx = ( * it ) . second ; if ( depth == - 1 || tx . Get@@ Depth@@ In@@ Main@@ Chain ( ) < depth ) List@@ Transac@@ tions ( tx , " * " , 0 , true , trans@@ actions ) ; } uint256 last@@ block ; if ( tar@@ get_@@ confi@@ r@@ ms == 1 ) { last@@ block = hashBestChain ; } else { int tar@@ get_@@ height = pindexBest -> nHeight + 1 - tar@@ get_@@ confi@@ r@@ ms ; CBlockIndex * block ; for ( block = pindexBest ; block && block -> nHeight > tar@@ get_@@ height ; block = block -> pprev ) { } last@@ block = block ? block -> GetBlockHash ( ) : 0 ; } Object ret ; ret . push_back ( Pair ( " trans@@ actions " , trans@@ actions ) ) ; ret . push_back ( Pair ( " last@@ block " , last@@ block . Get@@ Hex ( ) ) ) ; return ret ; } Value get@@ transaction ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) != 1 ) throw runtime_error ( " get@@ transaction ▁ < tx@@ id > \n " " Get ▁ det@@ a@@ iled ▁ information ▁ about ▁ in - wallet ▁ transaction ▁ < tx@@ id > " ) ; uint256 hash ; hash . Set@@ Hex ( params [ 0 ] . get_str ( ) ) ; Object entry ; if ( ! pw@@ all@@ et@@ Main -> mapWallet . count ( hash ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID@@ _ADD@@ RESS_@@ OR_@@ KEY , " Invalid ▁ or ▁ non - wallet ▁ transaction ▁ id " ) ; const CWalletTx & wtx = pw@@ all@@ et@@ Main -> mapWallet [ hash ] ; int64 n@@ Cre@@ di@@ t = wtx . Get@@ Cre@@ di@@ t ( ) ; int64 n@@ De@@ bit = wtx . Get@@ De@@ bit ( ) ; int64 n@@ Net = n@@ Cre@@ di@@ t - n@@ De@@ bit ; int64 n@@ Fee = ( wtx . Is@@ From@@ M@@ e ( ) ? wtx . GetValue@@ Out ( ) - n@@ De@@ bit : 0 ) ; entry . push_back ( Pair ( " amount " , Value@@ From@@ Amount ( n@@ Net - n@@ Fee ) ) ) ; if ( wtx . Is@@ From@@ M@@ e ( ) ) entry . push_back ( Pair ( " fe@@ e " , Value@@ From@@ Amount ( n@@ Fee ) ) ) ; Wallet@@ Tx@@ To@@ JS@@ ON ( wtx , entry ) ; Array details ; List@@ Transac@@ tions ( wtx , " * " , 0 , false , details ) ; entry . push_back ( Pair ( " details " , details ) ) ; return entry ; } Value back@@ up@@ wallet ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) != 1 ) throw runtime_error ( " back@@ up@@ wallet ▁ < destination > \n " " S@@ af@@ el@@ y ▁ cop@@ ies ▁ wallet . dat ▁ to ▁ destination , ▁ wh@@ ic@@ h ▁ can ▁ be ▁ a ▁ directory ▁ or ▁ a ▁ path ▁ with ▁ filename . " ) ; string strDest = params [ 0 ] . get_str ( ) ; if ( ! BackupWallet ( * pw@@ all@@ et@@ Main , strDest ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ ERROR , " Error : ▁ Wallet ▁ back@@ up ▁ failed ! " ) ; return Value :: null ; } Value ke@@ ypo@@ ol@@ re@@ fill ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 0 ) throw runtime_error ( " ke@@ ypo@@ ol@@ re@@ fill \n " " Fil@@ ls ▁ the ▁ ke@@ ypo@@ ol . " + Help@@ Re@@ qu@@ ir@@ ing@@ P@@ as@@ sp@@ hr@@ ase ( ) ) ; En@@ sure@@ Wallet@@ Is@@ Unlock@@ ed ( ) ; pw@@ all@@ et@@ Main -> Top@@ Up@@ Key@@ Pool ( ) ; if ( pw@@ all@@ et@@ Main -> GetKey@@ Pool@@ Size ( ) < Get@@ Arg ( " - ke@@ ypo@@ ol " , 100 ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ ERROR , " Error ▁ refresh@@ ing ▁ ke@@ ypo@@ ol . " ) ; return Value :: null ; } void Thread@@ Top@@ Up@@ Key@@ Pool ( void * parg ) { Rename@@ Thread ( " ilo@@ vey@@ ou@@ coins - key - top " ) ; pw@@ all@@ et@@ Main -> Top@@ Up@@ Key@@ Pool ( ) ; } void Thread@@ Cle@@ an@@ Wallet@@ P@@ as@@ sp@@ hr@@ ase ( void * parg ) { Rename@@ Thread ( " ilo@@ vey@@ ou@@ coins - lock - w@@ a " ) ; int64 n@@ My@@ Wa@@ ke@@ Time = GetTimeMillis ( ) + * ( ( int64 * ) parg ) * 1000 ; ENT@@ ER@@ _C@@ RI@@ TIC@@ AL_@@ SECTION ( cs_@@ nWallet@@ Unlock@@ Time ) ; if ( nWallet@@ Unlock@@ Time == 0 ) { nWallet@@ Unlock@@ Time = n@@ My@@ Wa@@ ke@@ Time ; do { if ( nWallet@@ Unlock@@ Time == 0 ) break ; int64 n@@ To@@ Sleep = nWallet@@ Unlock@@ Time - GetTimeMillis ( ) ; if ( n@@ To@@ Sleep <= 0 ) break ; LEAV@@ E_@@ CRITIC@@ AL_@@ SECTION ( cs_@@ nWallet@@ Unlock@@ Time ) ; Milli@@ Sleep ( n@@ To@@ Sleep ) ; ENT@@ ER@@ _C@@ RI@@ TIC@@ AL_@@ SECTION ( cs_@@ nWallet@@ Unlock@@ Time ) ; } while ( 1 ) ; if ( nWallet@@ Unlock@@ Time ) { nWallet@@ Unlock@@ Time = 0 ; pw@@ all@@ et@@ Main -> Lock ( ) ; } } else { if ( nWallet@@ Unlock@@ Time < n@@ My@@ Wa@@ ke@@ Time ) nWallet@@ Unlock@@ Time = n@@ My@@ Wa@@ ke@@ Time ; } LEAV@@ E_@@ CRITIC@@ AL_@@ SECTION ( cs_@@ nWallet@@ Unlock@@ Time ) ; delete ( int64 * ) parg ; } Value wall@@ et@@ pas@@ sp@@ hr@@ ase ( const Array & params , bool f@@ Help ) { if ( pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) && ( f@@ Help || params . size ( ) < 2 || params . size ( ) > 3 ) ) throw runtime_error ( " wall@@ et@@ pas@@ sp@@ hr@@ ase ▁ < pas@@ sp@@ hr@@ ase > ▁ < timeout > ▁ [ st@@ ak@@ ing@@ only ] \n " " St@@ o@@ res ▁ the ▁ wallet ▁ decryp@@ tion ▁ key ▁ in ▁ memory ▁ for ▁ < timeout > ▁ seconds . \n " " if ▁ [ st@@ ak@@ ing@@ only ] ▁ is ▁ true ▁ sending ▁ functions ▁ are ▁ dis@@ abled . " ) ; if ( f@@ Help ) return true ; if ( ! pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ WRO@@ NG_@@ EN@@ C@@ _STATE , " Error : ▁ running ▁ with ▁ an ▁ un@@ encryp@@ ted ▁ wallet , ▁ bu@@ t ▁ wall@@ et@@ pas@@ sp@@ hr@@ ase ▁ was ▁ called . " ) ; if ( ! pw@@ all@@ et@@ Main -> Is@@ Locked ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ AL@@ READ@@ Y_@@ UN@@ LOC@@ KED , " Error : ▁ Wallet ▁ is ▁ already ▁ un@@ lock@@ ed . " ) ; Sec@@ ure@@ String strWallet@@ Pass ; strWallet@@ Pass . reserve ( 100 ) ; strWallet@@ Pass = params [ 0 ] . get_str ( ) . c_str ( ) ; if ( strWallet@@ Pass . length ( ) > 0 ) { if ( ! pw@@ all@@ et@@ Main -> Unlock ( strWallet@@ Pass ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ PAS@@ SP@@ H@@ RAS@@ E_@@ IN@@ COR@@ RECT , " Error : ▁ The ▁ wallet ▁ pas@@ sp@@ hr@@ ase ▁ entered ▁ was ▁ incorrect . " ) ; } else throw runtime_error ( " wall@@ et@@ pas@@ sp@@ hr@@ ase ▁ < pas@@ sp@@ hr@@ ase > ▁ < timeout > \n " " St@@ o@@ res ▁ the ▁ wallet ▁ decryp@@ tion ▁ key ▁ in ▁ memory ▁ for ▁ < timeout > ▁ seconds . " ) ; New@@ Thread ( Thread@@ Top@@ Up@@ Key@@ Pool , NULL ) ; int64 * p@@ n@@ Sle@@ ep@@ Time = new int64 ( params [ 1 ] . get_@@ int64 ( ) ) ; New@@ Thread ( Thread@@ Cle@@ an@@ Wallet@@ P@@ as@@ sp@@ hr@@ ase , p@@ n@@ Sle@@ ep@@ Time ) ; if ( params . size ( ) > 2 ) f@@ Wallet@@ Unlock@@ St@@ ak@@ ing@@ Only = params [ 2 ] . get_@@ bool ( ) ; else f@@ Wallet@@ Unlock@@ St@@ ak@@ ing@@ Only = false ; return Value :: null ; } Value wall@@ et@@ pas@@ sp@@ hr@@ as@@ ec@@ h@@ ange ( const Array & params , bool f@@ Help ) { if ( pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) && ( f@@ Help || params . size ( ) != 2 ) ) throw runtime_error ( " wall@@ et@@ pas@@ sp@@ hr@@ as@@ ec@@ h@@ ange ▁ < old@@ pas@@ sp@@ hr@@ ase > ▁ < new@@ pas@@ sp@@ hr@@ ase > \n " " Chang@@ es ▁ the ▁ wallet ▁ pas@@ sp@@ hr@@ ase ▁ from ▁ < old@@ pas@@ sp@@ hr@@ ase > ▁ to ▁ < new@@ pas@@ sp@@ hr@@ ase > . " ) ; if ( f@@ Help ) return true ; if ( ! pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ WRO@@ NG_@@ EN@@ C@@ _STATE , " Error : ▁ running ▁ with ▁ an ▁ un@@ encryp@@ ted ▁ wallet , ▁ bu@@ t ▁ wall@@ et@@ pas@@ sp@@ hr@@ as@@ ec@@ h@@ ange ▁ was ▁ called . " ) ; Sec@@ ure@@ String str@@ Old@@ Wallet@@ Pass ; str@@ Old@@ Wallet@@ Pass . reserve ( 100 ) ; str@@ Old@@ Wallet@@ Pass = params [ 0 ] . get_str ( ) . c_str ( ) ; Sec@@ ure@@ String str@@ New@@ Wallet@@ Pass ; str@@ New@@ Wallet@@ Pass . reserve ( 100 ) ; str@@ New@@ Wallet@@ Pass = params [ 1 ] . get_str ( ) . c_str ( ) ; if ( str@@ Old@@ Wallet@@ Pass . length ( ) < 1 || str@@ New@@ Wallet@@ Pass . length ( ) < 1 ) throw runtime_error ( " wall@@ et@@ pas@@ sp@@ hr@@ as@@ ec@@ h@@ ange ▁ < old@@ pas@@ sp@@ hr@@ ase > ▁ < new@@ pas@@ sp@@ hr@@ ase > \n " " Chang@@ es ▁ the ▁ wallet ▁ pas@@ sp@@ hr@@ ase ▁ from ▁ < old@@ pas@@ sp@@ hr@@ ase > ▁ to ▁ < new@@ pas@@ sp@@ hr@@ ase > . " ) ; if ( ! pw@@ all@@ et@@ Main -> Change@@ Wallet@@ P@@ as@@ sp@@ hr@@ ase ( str@@ Old@@ Wallet@@ Pass , str@@ New@@ Wallet@@ Pass ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ PAS@@ SP@@ H@@ RAS@@ E_@@ IN@@ COR@@ RECT , " Error : ▁ The ▁ wallet ▁ pas@@ sp@@ hr@@ ase ▁ entered ▁ was ▁ incorrect . " ) ; return Value :: null ; } Value wall@@ et@@ lock ( const Array & params , bool f@@ Help ) { if ( pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) && ( f@@ Help || params . size ( ) != 0 ) ) throw runtime_error ( " wall@@ et@@ lock \n " " Remov@@ es ▁ the ▁ wallet ▁ encryp@@ tion ▁ key ▁ from ▁ memory , ▁ lock@@ ing ▁ the ▁ wallet . \n " " After ▁ call@@ ing ▁ this ▁ method , ▁ you ▁ will ▁ need ▁ to ▁ call ▁ wall@@ et@@ pas@@ sp@@ hr@@ ase ▁ again \n " " before ▁ be@@ ing ▁ able ▁ to ▁ call ▁ any ▁ methods ▁ wh@@ ic@@ h ▁ require ▁ the ▁ wallet ▁ to ▁ be ▁ un@@ lock@@ ed . " ) ; if ( f@@ Help ) return true ; if ( ! pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ WRO@@ NG_@@ EN@@ C@@ _STATE , " Error : ▁ running ▁ with ▁ an ▁ un@@ encryp@@ ted ▁ wallet , ▁ bu@@ t ▁ wall@@ et@@ lock ▁ was ▁ called . " ) ; { LOCK ( cs_@@ nWallet@@ Unlock@@ Time ) ; pw@@ all@@ et@@ Main -> Lock ( ) ; nWallet@@ Unlock@@ Time = 0 ; } return Value :: null ; } Value encryp@@ t@@ wallet ( const Array & params , bool f@@ Help ) { if ( ! pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) && ( f@@ Help || params . size ( ) != 1 ) ) throw runtime_error ( " encryp@@ t@@ wallet ▁ < pas@@ sp@@ hr@@ ase > \n " " En@@ cryp@@ ts ▁ the ▁ wallet ▁ with ▁ < pas@@ sp@@ hr@@ ase > . " ) ; if ( f@@ Help ) return true ; if ( pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ WRO@@ NG_@@ EN@@ C@@ _STATE , " Error : ▁ running ▁ with ▁ an ▁ encryp@@ ted ▁ wallet , ▁ bu@@ t ▁ encryp@@ t@@ wallet ▁ was ▁ called . " ) ; Sec@@ ure@@ String strWallet@@ Pass ; strWallet@@ Pass . reserve ( 100 ) ; strWallet@@ Pass = params [ 0 ] . get_str ( ) . c_str ( ) ; if ( strWallet@@ Pass . length ( ) < 1 ) throw runtime_error ( " encryp@@ t@@ wallet ▁ < pas@@ sp@@ hr@@ ase > \n " " En@@ cryp@@ ts ▁ the ▁ wallet ▁ with ▁ < pas@@ sp@@ hr@@ ase > . " ) ; if ( ! pw@@ all@@ et@@ Main -> En@@ cryp@@ t@@ Wallet ( strWallet@@ Pass ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ EN@@ CRY@@ P@@ TION@@ _FAILED , " Error : ▁ Failed ▁ to ▁ encrypt ▁ the ▁ wallet . " ) ; Start@@ Shutdo@@ wn ( ) ; return " wallet ▁ encryp@@ ted ; ▁ I@@ Lo@@ ve@@ You@@ Co@@ ins ▁ server ▁ st@@ opping , ▁ restart ▁ to ▁ run ▁ with ▁ encryp@@ ted ▁ wallet . ▁ The ▁ ke@@ ypo@@ ol ▁ has ▁ been ▁ flush@@ ed , ▁ you ▁ need ▁ to ▁ make ▁ a ▁ new ▁ back@@ up . " ; } class Descri@@ be@@ Address@@ Visitor : public boost :: static_@@ visitor < Object > { public : Object operator ( ) ( const C@@ No@@ Destination & dest ) const { return Object ( ) ; } Object operator ( ) ( const C@@ Key@@ ID & key@@ ID ) const { Object obj ; CP@@ ub@@ Key vchPubKey ; pw@@ all@@ et@@ Main -> GetPubKey ( key@@ ID , vchPubKey ) ; obj . push_back ( Pair ( " is@@ script " , false ) ) ; obj . push_back ( Pair ( " p@@ ub@@ key " , Hex@@ Str ( vchPubKey ) ) ) ; obj . push_back ( Pair ( " is@@ comp@@ ressed " , vchPubKey . Is@@ Compressed ( ) ) ) ; return obj ; } Object operator ( ) ( const C@@ Script@@ ID & script@@ ID ) const { Object obj ; obj . push_back ( Pair ( " is@@ script " , true ) ) ; CScript sub@@ script ; pw@@ all@@ et@@ Main -> Get@@ CScript ( script@@ ID , sub@@ script ) ; std :: vector < CTxDestination > addresses ; txnouttype whichType ; int nRequired ; ExtractDestinations ( sub@@ script , whichType , addresses , nRequired ) ; obj . push_back ( Pair ( " script " , Get@@ Tx@@ n@@ Output@@ Type ( whichType ) ) ) ; Array a ; BOOST_FOREACH ( const CTxDestination & addr , addresses ) a . push_back ( CBitcoinAddress ( addr ) . ToString ( ) ) ; obj . push_back ( Pair ( " addresses " , a ) ) ; if ( whichType == TX@@ _@@ MULTISIG ) obj . push_back ( Pair ( " sig@@ s@@ required " , nRequired ) ) ; return obj ; } } ; Value validate@@ address ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) != 1 ) throw runtime_error ( " validate@@ address ▁ < ilo@@ vey@@ ou@@ coin@@ s@@ address > \n " " Return ▁ information ▁ about ▁ < ilo@@ vey@@ ou@@ coin@@ s@@ address > . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; bool isValid = address . IsValid ( ) ; Object ret ; ret . push_back ( Pair ( " is@@ valid " , isValid ) ) ; if ( isValid ) { CTxDestination dest = address . Get ( ) ; string current@@ Address = address . ToString ( ) ; ret . push_back ( Pair ( " address " , current@@ Address ) ) ; bool f@@ M@@ ine = pw@@ all@@ et@@ Main ? IsMine ( * pw@@ all@@ et@@ Main , dest ) : false ; ret . push_back ( Pair ( " is@@ m@@ ine " , f@@ M@@ ine ) ) ; if ( f@@ M@@ ine ) { Object detail = boost :: apply_@@ visitor ( Descri@@ be@@ Address@@ Visitor ( ) , dest ) ; ret . insert ( ret . end ( ) , detail . begin ( ) , detail . end ( ) ) ; } if ( pw@@ all@@ et@@ Main && pw@@ all@@ et@@ Main -> mapAddress@@ Book . count ( dest ) ) ret . push_back ( Pair ( " account " , pw@@ all@@ et@@ Main -> mapAddress@@ Book [ dest ] ) ) ; } return ret ; } Value reser@@ ve@@ bal@@ ance ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 2 ) throw runtime_error ( " reser@@ ve@@ bal@@ ance ▁ [ < reserve > ▁ [ amount ] ] \n " " < reserve > ▁ is ▁ true ▁ or ▁ false ▁ to ▁ tur@@ n ▁ bal@@ ance ▁ reserve ▁ on ▁ or ▁ off . \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ ro@@ unded ▁ to ▁ c@@ ent . \n " " Set ▁ reserve ▁ amount ▁ not ▁ particip@@ ating ▁ in ▁ network ▁ prote@@ c@@ tion . \n " " If ▁ no ▁ parameters ▁ provided ▁ current ▁ setting ▁ is ▁ pr@@ in@@ ted . \n " ) ; if ( params . size ( ) > 0 ) { bool f@@ Reser@@ ve = params [ 0 ] . get_@@ bool ( ) ; if ( f@@ Reser@@ ve ) { if ( params . size ( ) == 1 ) throw runtime_error ( " must ▁ provi@@ de ▁ amount ▁ to ▁ reserve ▁ bal@@ ance . \n " ) ; int64 n@@ Amount = Amo@@ unt@@ From@@ Value ( params [ 1 ] ) ; n@@ Amount = ( n@@ Amount / CENT ) * CENT ; if ( n@@ Amount < 0 ) throw runtime_error ( " amount ▁ cannot ▁ be ▁ negative . \n " ) ; n@@ Reser@@ ve@@ B@@ al@@ ance = n@@ Amount ; } else { if ( params . size ( ) > 1 ) throw runtime_error ( " cannot ▁ spec@@ if@@ y ▁ amount ▁ to ▁ tur@@ n ▁ off ▁ reserve . \n " ) ; n@@ Reser@@ ve@@ B@@ al@@ ance = 0 ; } } Object result ; result . push_back ( Pair ( " reserve " , ( n@@ Reser@@ ve@@ B@@ al@@ ance > 0 ) ) ) ; result . push_back ( Pair ( " amount " , Value@@ From@@ Amount ( n@@ Reser@@ ve@@ B@@ al@@ ance ) ) ) ; return result ; } Value get@@ inte@@ rest ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 2 ) throw runtime_error ( " get@@ inte@@ rest ▁ [ start ] ▁ [ end ] \n " " Both ▁ [ start ] ▁ and ▁ [ end ] ▁ are ▁ inclusive ▁ and ▁ in ▁ the ▁ form ▁ of ▁ UN@@ IX ▁ timest@@ amps . " ) ; unsigned int n@@ Time@@ Start = 0 ; unsigned int n@@ Time@@ End = - 1 ; if ( params . size ( ) >= 1 ) n@@ Time@@ Start = ( unsigned int ) ( params [ 0 ] . get_int ( ) ) ; if ( params . size ( ) == 2 ) n@@ Time@@ End = ( unsigned int ) ( params [ 1 ] . get_int ( ) ) ; int64 n@@ Inte@@ rest = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pw@@ all@@ et@@ Main -> mapWallet . begin ( ) ; it != pw@@ all@@ et@@ Main -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . Is@@ Co@@ in@@ St@@ a@@ ke ( ) || wtx . nTime < n@@ Time@@ Start || wtx . nTime > n@@ Time@@ End ) continue ; int64 n@@ De@@ bit = wtx . Get@@ De@@ bit ( ) ; int64 n@@ Cre@@ di@@ t = wtx . Get@@ Cre@@ di@@ t ( ) ; if ( n@@ De@@ bit <= 0 || n@@ Cre@@ di@@ t <= 0 || n@@ De@@ bit >= n@@ Cre@@ di@@ t ) continue ; else n@@ Inte@@ rest += n@@ Cre@@ di@@ t - n@@ De@@ bit ; } return Value@@ From@@ Amount ( n@@ Inte@@ rest ) ; } Value lock@@ un@@ spent ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " lock@@ un@@ spent ▁ unlock ? ▁ [ array - of - Objects ] \n " " Upd@@ ates ▁ list ▁ of ▁ temp@@ or@@ ar@@ il@@ y ▁ un@@ sp@@ end@@ able ▁ output@@ s . " ) ; if ( params . size ( ) == 1 ) RPC@@ TypeCheck ( params , list_of ( bool@@ _type ) ) ; else RPC@@ TypeCheck ( params , list_of ( bool@@ _type ) ( array_type ) ) ; bool f@@ Unlock = params [ 0 ] . get_@@ bool ( ) ; if ( params . size ( ) == 1 ) { if ( f@@ Unlock ) pw@@ all@@ et@@ Main -> Unlock@@ All@@ Co@@ ins ( ) ; return true ; } Array output@@ s = params [ 1 ] . get_array ( ) ; BOOST_FOREACH ( Value & output , output@@ s ) { if ( output . type ( ) != obj@@ _type ) throw JS@@ ON@@ RPC@@ Error ( - 8 , " Invalid ▁ parameter , ▁ expected ▁ object " ) ; const Object & o = output . get_@@ obj ( ) ; RPC@@ TypeCheck ( o , map_list_of ( " tx@@ id " , str_type ) ( " vout " , int_type ) ) ; string tx@@ id = find_@@ value ( o , " tx@@ id " ) . get_str ( ) ; if ( ! Is@@ Hex ( tx@@ id ) ) throw JS@@ ON@@ RPC@@ Error ( - 8 , " Invalid ▁ parameter , ▁ expected ▁ hex ▁ tx@@ id " ) ; int n@@ Output = find_@@ value ( o , " vout " ) . get_int ( ) ; if ( n@@ Output < 0 ) throw JS@@ ON@@ RPC@@ Error ( - 8 , " Invalid ▁ parameter , ▁ vout ▁ must ▁ be ▁ positive " ) ; COutPoint out@@ pt ( uint256 ( tx@@ id ) , n@@ Output ) ; if ( f@@ Unlock ) pw@@ all@@ et@@ Main -> Unlock@@ Co@@ in ( out@@ pt ) ; else pw@@ all@@ et@@ Main -> Lock@@ Co@@ in ( out@@ pt ) ; } return true ; } Value list@@ lock@@ un@@ spent ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 0 ) throw runtime_error ( " list@@ lock@@ un@@ spent \n " " Retur@@ ns ▁ list ▁ of ▁ temp@@ or@@ ar@@ il@@ y ▁ un@@ sp@@ end@@ able ▁ output@@ s . " ) ; vector < COutPoint > vOut@@ pts ; pw@@ all@@ et@@ Main -> List@@ Lock@@ ed@@ Co@@ ins ( vOut@@ pts ) ; Array ret ; BOOST_FOREACH ( COutPoint & out@@ pt , vOut@@ pts ) { Object o ; o . push_back ( Pair ( " tx@@ id " , out@@ pt . hash . Get@@ Hex ( ) ) ) ; o . push_back ( Pair ( " vout " , ( int ) out@@ pt . n ) ) ; ret . push_back ( o ) ; } return ret ; } </DOCUMENT>
<DOCUMENT_ID="@@ quick@@ hand@@ /@@ Pro@@ si@@ t@@ /tree/master/src/@@ high@@ li@@ gh@@ ter@@ .cpp"> # include " high@@ li@@ gh@@ ter . h " # include " block _ stats . h " # include " dictionary . h " # include " spell _ checker . h " # include " editor . h " # include < QAction > # include < QContextMenuEvent > # include < QEvent > # include < QMenu > # include < QText@@ Edit > # include < iostream > # include < QAbstract@@ Text@@ Document@@ Layout > # include < QText@@ Layout > High@@ li@@ gh@@ ter :: High@@ li@@ gh@@ ter ( Edit@@ or * text , Dictionary * dictionary ) : Q@@ Syntax@@ High@@ li@@ gh@@ ter ( text -> document ( ) ) , m_@@ dictionary ( dictionary ) , m_text ( text ) , m_en@@ abled ( true ) , m_@@ mis@@ sp@@ el@@ led ( " # ff@@ 0000" ) { connect ( m_text , SIGNAL ( cursor@@ Position@@ Changed ( ) ) , this , SLOT ( cursor@@ Position@@ Changed ( ) ) ) ; m_text -> view@@ port ( ) -> installEventFilter ( this ) ; m_@@ add_@@ action = new QAction ( tr ( " Add " ) , this ) ; m_@@ check_@@ action = new QAction ( tr ( " Check ▁ Spelling . . . " ) , this ) ; } bool High@@ li@@ gh@@ ter :: enabled ( ) const { return m_en@@ abled ; } QColor High@@ li@@ gh@@ ter :: mis@@ spelled@@ Color ( ) const { return m_@@ mis@@ sp@@ el@@ led ; } void High@@ li@@ gh@@ ter :: setEnabled ( bool enabled ) { m_en@@ abled = enabled ; re@@ high@@ light ( ) ; } void High@@ li@@ gh@@ ter :: set@@ Misspelled@@ Color ( const QColor & color ) { m_@@ mis@@ sp@@ el@@ led = color ; re@@ high@@ light ( ) ; } bool High@@ li@@ gh@@ ter :: eventFilter ( QObject * w@@ atch@@ ed , QEvent * event ) { if ( w@@ atch@@ ed != m_text -> view@@ port ( ) || event -> type ( ) != QEvent :: ContextMenu || ! m_en@@ abled ) { return Q@@ Syntax@@ High@@ li@@ gh@@ ter :: eventFilter ( w@@ atch@@ ed , event ) ; } else { QContextMenuEvent * contex@@ t_@@ event = static_cast < QContextMenuEvent * > ( event ) ; m_@@ start_@@ cursor = m_text -> cursor@@ For@@ Position ( contex@@ t_@@ event -> pos ( ) ) ; QText@@ Block block = m_@@ start_@@ cursor . block ( ) ; int cursor = m_@@ start_@@ cursor . position ( ) - block . position ( ) ; bool und@@ er_@@ mo@@ use = false ; QString@@ Ref word ; QVector < QString@@ Ref > words = static_cast < Block@@ Stats * > ( block . userData ( ) ) -> mis@@ sp@@ el@@ led ( ) ; for ( int i = 0 ; i < words . count ( ) ; ++ i ) { word = words . at ( i ) ; int delta = cursor - word . position ( ) ; if ( delta >= 0 && delta <= word . length ( ) ) { und@@ er_@@ mo@@ use = true ; break ; } } if ( ! und@@ er_@@ mo@@ use ) { return false ; } else { m_cursor = m_@@ start_@@ cursor ; m_cursor . set@@ Position ( word . position ( ) + block . position ( ) ) ; m_cursor . set@@ Position ( m_cursor . position ( ) + word . length ( ) , QText@@ Cursor :: Keep@@ An@@ ch@@ or ) ; m_@@ word = m_cursor . selected@@ Text ( ) ; m_text -> setText@@ Cursor ( m_cursor ) ; QMenu * menu = new QMenu ; QStringList gu@@ ess@@ es = m_@@ dictionary -> sug@@ gest@@ ion@@ s ( m_@@ word ) ; if ( ! gu@@ ess@@ es . isEmpty ( ) ) { foreach ( const QString & gu@@ es@@ s , gu@@ ess@@ es ) { menu -> add@@ Action ( gu@@ es@@ s ) ; } } else { QAction * non@@ e_@@ action = menu -> add@@ Action ( tr ( " ( No ▁ sug@@ gest@@ ion@@ s ▁ found ) " ) ) ; non@@ e_@@ action -> setEnabled ( false ) ; } menu -> add@@ Separator ( ) ; menu -> add@@ Action ( m_@@ add_@@ action ) ; menu -> add@@ Separator ( ) ; menu -> add@@ Action ( m_@@ check_@@ action ) ; connect ( menu , SIGNAL ( triggered ( QAction * ) ) , this , SLOT ( sug@@ gest@@ ion ( QAction * ) ) ) ; menu -> exec ( contex@@ t_@@ event -> globalPos ( ) ) ; delete menu ; return true ; } } } void High@@ li@@ gh@@ ter :: high@@ light@@ Block ( const QString & text ) { QText@@ Char@@ Format h@@ format ; QText@@ Block@@ Format block@@ format = current@@ Block ( ) . block@@ Format ( ) ; if ( block@@ format . hasProperty ( QText@@ Format :: User@@ Property ) ) { h@@ format . setProperty ( QText@@ Format :: Font@@ Weight , block@@ format . property ( QText@@ Format :: Font@@ Weight ) ) ; h@@ format . setProperty ( QText@@ Format :: Font@@ I@@ tal@@ ic , block@@ format . property ( QText@@ Format :: Font@@ I@@ tal@@ ic ) ) ; h@@ format . setProperty ( QText@@ Format :: Font@@ Size@@ Adjust@@ ment , block@@ format . property ( QText@@ Format :: Font@@ Size@@ Adjust@@ ment ) ) ; setFormat ( 0 , text . length ( ) , h@@ format ) ; } if ( ! m_en@@ abled ) { return ; } int cursor = m_text -> text@@ Cursor ( ) . position ( ) - current@@ Block ( ) . position ( ) ; Block@@ Stats * stats = static_cast < Block@@ Stats * > ( current@@ Block@@ UserData ( ) ) ; if ( ! stats ) { stats = new Block@@ Stats ( text , m_@@ dictionary ) ; setCurrent@@ Block@@ UserData ( stats ) ; } QText@@ Char@@ Format error ; error . set@@ Un@@ der@@ line@@ Color ( m_@@ mis@@ sp@@ el@@ led ) ; error . set@@ Un@@ der@@ line@@ Style ( QText@@ Char@@ Format :: SpellCheck@@ Un@@ der@@ line ) ; error . merge ( h@@ format ) ; QVector < QString@@ Ref > words = stats -> mis@@ sp@@ el@@ led ( ) ; for ( int i = 0 ; i < words . count ( ) ; ++ i ) { const QString@@ Ref & word = words . at ( i ) ; int delta = cursor - word . position ( ) ; if ( delta < 0 || delta > word . length ( ) ) { setFormat ( word . position ( ) , word . length ( ) , error ) ; } } } void High@@ li@@ gh@@ ter :: cursor@@ Position@@ Changed ( ) { QText@@ Block current = m_text -> text@@ Cursor ( ) . block ( ) ; if ( m_@@ current != current ) { if ( m_@@ current . isValid ( ) && m_text -> document ( ) -> block@@ Count ( ) > m_@@ current . block@@ Number ( ) ) { re@@ high@@ light@@ Block ( m_@@ current ) ; } m_@@ current = current ; } re@@ high@@ light@@ Block ( m_@@ current ) ; } void High@@ li@@ gh@@ ter :: sug@@ gest@@ ion ( QAction * action ) { if ( action == m_@@ add_@@ action ) { m_text -> setText@@ Cursor ( m_@@ start_@@ cursor ) ; m_@@ dictionary -> add ( m_@@ word ) ; } else if ( action == m_@@ check_@@ action ) { m_text -> setText@@ Cursor ( m_@@ start_@@ cursor ) ; Spell@@ Checker :: check@@ Document ( m_text ) ; } else { m_cursor . insert@@ Text ( action -> text ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="p@@ mp@@ rog@@ /@@ T@@ ug@@ Of@@ War@@ /tree/master/@@ Game@@ /g@@ ame@@ lob@@ by@@ st@@ age@@ .cpp"> # include " game@@ lob@@ by@@ st@@ age . h " # include " menu . h " # include " input . h " # include " game@@ lob@@ by _ add@@ local . h " # include " game@@ st@@ age . h " Game@@ Lo@@ b@@ by@@ St@@ age :: Game@@ Lo@@ b@@ by@@ St@@ age ( ) { net@@ work@@ connection = nullptr ; current@@ info = new Game@@ Info ( true ) ; selection = 0 ; selection@@ team@@ is@@ blue = true ; } Game@@ Lo@@ b@@ by@@ St@@ age :: Game@@ Lo@@ b@@ by@@ St@@ age ( Net@@ work * Connection ) { selection = 0 ; net@@ work@@ connection = Connection ; current@@ info = new Game@@ Info ( Connection -> Is@@ Server ( ) ) ; if ( ! Connection -> Is@@ Server ( ) ) { } } void Game@@ Lo@@ b@@ by@@ St@@ age :: Begin ( ) { option@@ font = Font@@ Cache :: Load@@ Font ( " resources / arm@@ al@@ ite . ttf " , 32 ) ; hel@@ p@@ font = Font@@ Cache :: Load@@ Font ( " resources / arm@@ al@@ ite . ttf " , 16 ) ; } void Game@@ Lo@@ b@@ by@@ St@@ age :: Pause ( ) { } void Game@@ Lo@@ b@@ by@@ St@@ age :: Resume ( ) { } void Game@@ Lo@@ b@@ by@@ St@@ age :: Finish ( ) { A@@ UDI@@ O -> Stop@@ M@@ usi@@ c ( ) ; if ( net@@ work@@ connection != nullptr ) { delete net@@ work@@ connection ; net@@ work@@ connection = nullptr ; } } void Game@@ Lo@@ b@@ by@@ St@@ age :: Event@@ Occur@@ red ( Event * e ) { Input@@ Items :: Item@@ Set in@@ p@@ ute@@ vent = Input@@ Items :: NONE ; if ( e -> Type == EVENT_@@ KEY_@@ DOWN ) { if ( e -> Data . Key@@ board . Key@@ Code == AL@@ LEG@@ RO@@ _@@ KEY_@@ ESCAPE ) { delete FRAM@@ EWOR@@ K -> Program@@ St@@ ages -> Pop ( ) ; return ; } in@@ p@@ ute@@ vent = Input :: GetItem@@ From@@ Event ( e ) ; } if ( e -> Type == EVENT_@@ JO@@ Y@@ S@@ TIC@@ K_@@ BUTT@@ ON_@@ DOWN && in@@ p@@ ute@@ vent == Input@@ Items :: NONE ) { in@@ p@@ ute@@ vent = Input :: GetItem@@ From@@ Event ( e ) ; } if ( in@@ p@@ ute@@ vent != Input@@ Items :: NONE ) { Input@@ Event ( in@@ p@@ ute@@ vent ) ; } Network@@ Event ( e ) ; } void Game@@ Lo@@ b@@ by@@ St@@ age :: Input@@ Event ( Input@@ Items :: Item@@ Set in@@ p@@ ute@@ vent ) { switch ( in@@ p@@ ute@@ vent ) { case Input@@ Items :: UP : if ( selection > 0 ) { selection -- ; } break ; case Input@@ Items :: DOWN : if ( selection < 2 ) { selection ++ ; } break ; case Input@@ Items :: LEFT : selection@@ team@@ is@@ blue = true ; break ; case Input@@ Items :: RIGHT : selection@@ team@@ is@@ blue = false ; break ; case Input@@ Items :: SEL@@ ECT : delete FRAM@@ EWOR@@ K -> Program@@ St@@ ages -> Pop ( ) ; return ; break ; case Input@@ Items :: X : if ( net@@ work@@ connection == nullptr ) { Player@@ Info * p = nullptr ; if ( selection@@ team@@ is@@ blue ) { if ( current@@ info -> Blue@@ Team [ selection ] == nullptr ) { current@@ info -> Blue@@ Team [ selection ] = new Player@@ Info ( " " , true , false ) ; } p = current@@ info -> Blue@@ Team [ selection ] ; } else { if ( current@@ info -> Red@@ Team [ selection ] == nullptr ) { current@@ info -> Red@@ Team [ selection ] = new Player@@ Info ( " " , true , false ) ; } p = current@@ info -> Red@@ Team [ selection ] ; } p -> Blue@@ Team = selection@@ team@@ is@@ blue ; p -> Team@@ Index = selection ; p -> Game@@ Data = current@@ info ; FRAM@@ EWOR@@ K -> Program@@ St@@ ages -> Push ( new Game@@ Lo@@ b@@ by@@ Add@@ Local@@ St@@ age ( p ) ) ; } break ; case Input@@ Items :: B : if ( net@@ work@@ connection == nullptr ) { Player@@ Info * p = nullptr ; if ( selection@@ team@@ is@@ blue ) { if ( current@@ info -> Blue@@ Team [ selection ] == nullptr ) { p = new Player@@ Info ( " CPU " , true , true ) ; current@@ info -> Blue@@ Team [ selection ] = p ; } } else { if ( current@@ info -> Red@@ Team [ selection ] == nullptr ) { p = new Player@@ Info ( " CPU " , true , true ) ; current@@ info -> Red@@ Team [ selection ] = p ; } } if ( p != nullptr ) { p -> Blue@@ Team = selection@@ team@@ is@@ blue ; p -> Team@@ Index = selection ; p -> Game@@ Data = current@@ info ; } } break ; case Input@@ Items :: Y : if ( net@@ work@@ connection == nullptr || net@@ work@@ connection -> Is@@ Server ( ) ) { Player@@ Info * p = nullptr ; if ( selection@@ team@@ is@@ blue ) { p = current@@ info -> Blue@@ Team [ selection ] ; current@@ info -> Blue@@ Team [ selection ] = nullptr ; } else { p = current@@ info -> Red@@ Team [ selection ] ; current@@ info -> Red@@ Team [ selection ] = nullptr ; } if ( p != nullptr ) { if ( ! p -> Local ) { } delete p ; } } break ; case Input@@ Items :: START : if ( net@@ work@@ connection == nullptr || net@@ work@@ connection -> Is@@ Server ( ) ) { Game@@ St@@ age * g = new Game@@ St@@ age ( current@@ info ) ; delete FRAM@@ EWOR@@ K -> Program@@ St@@ ages -> Pop ( ) ; FRAM@@ EWOR@@ K -> Program@@ St@@ ages -> Push ( g ) ; } break ; } } void Game@@ Lo@@ b@@ by@@ St@@ age :: Network@@ Event ( Event * e ) { if ( e -> Type == EVENT_@@ NE@@ TWOR@@ K@@ _CONN@@ ECTION_@@ REQUEST ) { bool fre@@ es@@ lot = false ; for ( int i = 0 ; i < 3 ; i ++ ) { fre@@ es@@ lot = ( current@@ info -> Blue@@ Team [ i ] == nullptr ? true : fre@@ es@@ lot ) ; fre@@ es@@ lot = ( current@@ info -> Red@@ Team [ i ] == nullptr ? true : fre@@ es@@ lot ) ; } if ( fre@@ es@@ lot ) { } } if ( e -> Type == EVENT_@@ NE@@ TWOR@@ K@@ _CONN@@ ECTED ) { } if ( e -> Type == EVENT_@@ NE@@ TWOR@@ K_@@ DIS@@ CONNEC@@ TED ) { } if ( e -> Type == EVENT_@@ NE@@ TWOR@@ K_@@ PAC@@ KE@@ T_@@ RECE@@ IVED ) { } } void Game@@ Lo@@ b@@ by@@ St@@ age :: Update ( ) { } void Game@@ Lo@@ b@@ by@@ St@@ age :: R@@ ender ( ) { al_@@ clear@@ _to_@@ color ( al_@@ map_@@ r@@ gb ( 255 , 220 , 128 ) ) ; option@@ font -> Draw@@ String ( ( DISP@@ LAY -> Get@@ Width ( ) / 2 ) + 2 , 12 , " Lo@@ b@@ by " , Font@@ H@@ Align :: CENTR@@ E , al_@@ map_@@ r@@ gb ( 0 , 0 , 0 ) ) ; option@@ font -> Draw@@ String ( ( DISP@@ LAY -> Get@@ Width ( ) / 2 ) , 10 , " Lo@@ b@@ by " , Font@@ H@@ Align :: CENTR@@ E , al_@@ map_@@ r@@ gb ( 255 , 255 , 0 ) ) ; Game@@ Resources :: Draw@@ Pan@@ el ( Game@@ Resources :: Blue@@ Pan@@ el , 5 , 80 , 13 , 8 , 8 ) ; option@@ font -> Draw@@ String ( 15 , 8@@ 5 , " Bl@@ ue ▁ Team " , Font@@ H@@ Align :: LEFT , al_@@ map_@@ r@@ gb ( 255 , 255 , 255 ) ) ; Render@@ Player@@ Slot ( true , 0 , 15 , 14@@ 0 ) ; Render@@ Player@@ Slot ( true , 1 , 15 , 192 ) ; Render@@ Player@@ Slot ( true , 2 , 15 , 244 ) ; Game@@ Resources :: Draw@@ Pan@@ el ( Game@@ Resources :: Red@@ Pan@@ el , 40@@ 5 , 80 , 13 , 8 , 8 ) ; option@@ font -> Draw@@ String ( 4@@ 15 , 8@@ 5 , " Re@@ d ▁ Team " , Font@@ H@@ Align :: LEFT , al_@@ map_@@ r@@ gb ( 255 , 255 , 255 ) ) ; Render@@ Player@@ Slot ( false , 0 , 4@@ 15 , 14@@ 0 ) ; Render@@ Player@@ Slot ( false , 1 , 4@@ 15 , 192 ) ; Render@@ Player@@ Slot ( false , 2 , 4@@ 15 , 244 ) ; int tex@@ to@@ ff = ( 50 - hel@@ p@@ font -> Get@@ Font@@ Height ( ) ) / 2 ; if ( net@@ work@@ connection == nullptr ) { al_@@ draw_bitmap ( Input :: Get@@ Icon ( Input@@ Items :: X ) , 10 , 32@@ 0 , 0 ) ; hel@@ p@@ font -> Draw@@ String ( 64 , 32@@ 0 + tex@@ to@@ ff , " Add ▁ Local ▁ Player " , Font@@ H@@ Align :: LEFT , al_@@ map_@@ r@@ gb ( 0 , 0 , 0 ) ) ; al_@@ draw_bitmap ( Input :: Get@@ Icon ( Input@@ Items :: B ) , 10 , 37@@ 0 , 0 ) ; hel@@ p@@ font -> Draw@@ String ( 64 , 37@@ 0 + tex@@ to@@ ff , " Add ▁ CPU ▁ Player " , Font@@ H@@ Align :: LEFT , al_@@ map_@@ r@@ gb ( 0 , 0 , 0 ) ) ; } if ( net@@ work@@ connection == nullptr || net@@ work@@ connection -> Is@@ Server ( ) ) { al_@@ draw_bitmap ( Input :: Get@@ Icon ( Input@@ Items :: Y ) , 10 , 4@@ 20 , 0 ) ; hel@@ p@@ font -> Draw@@ String ( 64 , 4@@ 20 + tex@@ to@@ ff , " K@@ ick ▁ Player " , Font@@ H@@ Align :: LEFT , al_@@ map_@@ r@@ gb ( 0 , 0 , 0 ) ) ; al_@@ draw_bitmap ( Input :: Get@@ Icon ( Input@@ Items :: START ) , 500 , 37@@ 0 , 0 ) ; hel@@ p@@ font -> Draw@@ String ( 55@@ 4 , 37@@ 0 + tex@@ to@@ ff , " Start " , Font@@ H@@ Align :: LEFT , al_@@ map_@@ r@@ gb ( 0 , 0 , 0 ) ) ; } al_@@ draw_bitmap ( Input :: Get@@ Icon ( Input@@ Items :: SEL@@ ECT ) , 500 , 4@@ 20 , 0 ) ; hel@@ p@@ font -> Draw@@ String ( 55@@ 4 , 4@@ 20 + tex@@ to@@ ff , " Quit " , Font@@ H@@ Align :: LEFT , al_@@ map_@@ r@@ gb ( 0 , 0 , 0 ) ) ; } bool Game@@ Lo@@ b@@ by@@ St@@ age :: Is@@ Transition ( ) { return false ; } void Game@@ Lo@@ b@@ by@@ St@@ age :: Render@@ Player@@ Slot ( bool Blue@@ Team , int Index , int X , int Y ) { Button@@ Colo@@ ur@@ s :: Colo@@ ur@@ s co@@ lo@@ ur = Button@@ Colo@@ ur@@ s :: WHIT@@ E ; bool bt@@ n@@ up = false ; Player@@ Info * p = ( Blue@@ Team ? current@@ info -> Blue@@ Team [ Index ] : current@@ info -> Red@@ Team [ Index ] ) ; if ( p != nullptr ) { co@@ lo@@ ur = ( Blue@@ Team ? Button@@ Colo@@ ur@@ s :: BL@@ UE : Button@@ Colo@@ ur@@ s :: RE@@ D ) ; } if ( net@@ work@@ connection == nullptr || net@@ work@@ connection -> Is@@ Server ( ) ) { if ( selection == Index && selection@@ team@@ is@@ blue == Blue@@ Team ) { co@@ lo@@ ur = Button@@ Colo@@ ur@@ s :: Y@@ EL@@ LOW ; bt@@ n@@ up = true ; } } Game@@ Resources :: Draw@@ Button ( co@@ lo@@ ur , bt@@ n@@ up , X , Y , 23 , 3 ) ; if ( p != nullptr ) { hel@@ p@@ font -> Draw@@ String ( X + 184 , Y + 24 - ( hel@@ p@@ font -> Get@@ Font@@ Height ( ) / 2 ) + ( ! bt@@ n@@ up ? 4 : 0 ) , p -> Name , Font@@ H@@ Align :: CENTR@@ E , al_@@ map_@@ r@@ gb ( 0 , 0 , 0 ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="@@ mat@@ 12@@ /@@ my@@ test@@ /tree/master/lib@@ /g@@ di@@ /@@ sd@@ l.cpp"> # include < lib / g@@ di / sd@@ l . h > # include < lib / actions / action . h > # include < lib / base / init . h > # include < lib / base / init_@@ num . h > # include < lib / driver / input_@@ fa@@ ke . h > # include < lib / driver / rc@@ sd@@ l . h > # include < SDL . h > g@@ SD@@ LD@@ C :: g@@ SD@@ LD@@ C ( ) : m_p@@ ump ( e@@ App , 1 ) { if ( SDL_@@ Init ( SDL_@@ INIT_@@ VIDEO ) < 0 ) { e@@ Warning ( " [ g@@ SD@@ LD@@ C ] ▁ Could ▁ not ▁ initialize ▁ SDL : ▁ % s " , SDL_GetError ( ) ) ; return ; } set@@ Res@@ o@@ lution ( 72@@ 0 , 5@@ 76 ) ; CONN@@ ECT ( m_p@@ ump . rec@@ v_@@ msg , g@@ SD@@ LD@@ C :: p@@ ump@@ Event ) ; m_@@ surface . type = 0 ; m_@@ surface . clu@@ t . colors = 256 ; m_@@ surface . clu@@ t . data = new g@@ RGB [ m_@@ surface . clu@@ t . colors ] ; m_p@@ ix@@ map = new g@@ Pixmap ( & m_@@ surface ) ; memset ( m_@@ surface . clu@@ t . data , 0 , sizeof ( * m_@@ surface . clu@@ t . data ) * m_@@ surface . clu@@ t . colors ) ; run ( ) ; } g@@ SD@@ LD@@ C :: ~ g@@ SD@@ LD@@ C ( ) { push@@ Event ( EV@@ _@@ QU@@ IT ) ; k@@ ill ( ) ; SDL_@@ Quit ( ) ; } void g@@ SD@@ LD@@ C :: key@@ Event ( const SDL_@@ Event & event ) { e@@ SD@@ L@@ Input@@ Driver * driver = e@@ SD@@ L@@ Input@@ Driver :: getInstance ( ) ; eDebug ( " [ g@@ SD@@ LD@@ C ] ▁ Key ▁ % s : ▁ key = % d " , ( event . type == SDL_@@ KE@@ Y@@ DOWN ) ? " Down " : " Up " , event . key . key@@ sym . sym ) ; if ( driver ) driver -> keyPressed ( & event . key ) ; } void g@@ SD@@ LD@@ C :: p@@ ump@@ Event ( const SDL_@@ Event & event ) { switch ( event . type ) { case SDL_@@ KE@@ Y@@ DOWN : case SDL_@@ KE@@ Y@@ UP : key@@ Event ( event ) ; break ; case SDL_@@ QU@@ IT : eDebug ( " [ g@@ SD@@ LD@@ C ] ▁ Quit " ) ; extern void qu@@ it@@ Main@@ loop ( int exit_@@ code ) ; qu@@ it@@ Main@@ loop ( 0 ) ; break ; } } void g@@ SD@@ LD@@ C :: push@@ Event ( enum event code , void * data1 , void * data2 ) { SDL_@@ Event event ; event . type = SDL_@@ U@@ SER@@ EVENT ; event . user . code = code ; event . user . data1 = data1 ; event . user . data2 = data2 ; SDL_@@ Push@@ Event ( & event ) ; } void g@@ SD@@ LD@@ C :: exec ( const g@@ Opcode * o ) { switch ( o -> opcode ) { case g@@ Opcode :: flush : push@@ Event ( EV@@ _F@@ LI@@ P ) ; eDebug ( " [ g@@ SD@@ LD@@ C ] ▁ FL@@ US@@ H " ) ; break ; default : g@@ DC :: exec ( o ) ; break ; } } void g@@ SD@@ LD@@ C :: set@@ Res@@ o@@ lution ( int x@@ res , int y@@ res ) { push@@ Event ( EV@@ _SET_@@ VIDE@@ O_@@ MODE , ( void * ) x@@ res , ( void * ) y@@ res ) ; } void g@@ SD@@ LD@@ C :: ev@@ Set@@ Video@@ Mode ( unsigned long x@@ res , unsigned long y@@ res ) { m_@@ screen = SDL_@@ Set@@ Video@@ Mode ( x@@ res , y@@ res , 32 , SDL_@@ H@@ W@@ SURFACE ) ; if ( ! m_@@ screen ) { e@@ F@@ at@@ al ( " [ g@@ SD@@ LD@@ C ] ▁ Could ▁ not ▁ create ▁ SDL ▁ surface : ▁ % s " , SDL_GetError ( ) ) ; return ; } m_@@ surface . x = m_@@ screen -> w ; m_@@ surface . y = m_@@ screen -> h ; m_@@ surface . b@@ pp = m_@@ screen -> format -> BitsPerPixel ; m_@@ surface . b@@ yp@@ p = m_@@ screen -> format -> BytesPerPixel ; m_@@ surface . st@@ ride = m_@@ screen -> pitch ; m_@@ surface . data = m_@@ screen -> pixels ; SDL_@@ Enable@@ UNICODE ( 1 ) ; } void g@@ SD@@ LD@@ C :: ev@@ Flip ( ) { SDL_Flip ( m_@@ screen ) ; } void g@@ SD@@ LD@@ C :: thread ( ) { has@@ Started ( ) ; bool stop = false ; while ( ! stop ) { SDL_@@ Event event ; if ( SDL_@@ Wait@@ Event ( & event ) ) { switch ( event . type ) { case SDL_@@ KE@@ Y@@ DOWN : case SDL_@@ KE@@ Y@@ UP : case SDL_@@ QU@@ IT : m_p@@ ump . send ( event ) ; break ; case SDL_@@ U@@ SER@@ EVENT : switch ( event . user . code ) { case EV@@ _SET_@@ VIDE@@ O_@@ MODE : ev@@ Set@@ Video@@ Mode ( ( unsigned long ) event . user . data1 , ( unsigned long ) event . user . data2 ) ; break ; case EV@@ _F@@ LI@@ P : ev@@ Flip ( ) ; break ; case EV@@ _@@ QU@@ IT : stop = true ; break ; } break ; } } } } e@@ Auto@@ Init@@ Ptr < g@@ SD@@ LD@@ C > init@@ _g@@ SD@@ LD@@ C ( e@@ Auto@@ Init@@ Numbers :: graph@@ ic - 1 , " g@@ SD@@ LD@@ C " ) ; </DOCUMENT>
<DOCUMENT_ID="th@@ i@@ ent@@ u/@@ d@@ ra@@ ke@@ /tree/master/@@ uti@@ l/@@ d@@ ra@@ ke@@ Ge@@ ometr@@ y@@ Util.cpp"> # include " d@@ ra@@ ke@@ Ge@@ ometr@@ y@@ Util . h " # include < iostream > # include < cmath > # include < limits > # include < stdexcept > # include < Eigen / S@@ parse > # include " exp@@ map@@ 2@@ quat . h " using namespace Eigen ; double angle@@ Di@@ ff ( double ph@@ i1 , double ph@@ i2 ) { double d = ph@@ i2 - ph@@ i1 ; if ( d > 0.0 ) { d = fmod ( d + M_PI , 2 * M_PI ) - M_PI ; } else { d = fmod ( d - M_PI , 2 * M_PI ) + M_PI ; } return d ; } Vector@@ 4@@ d qu@@ at@@ Con@@ j@@ ugate ( const Eigen :: Vector@@ 4@@ d & q ) { Vector@@ 4@@ d q@@ _@@ con@@ j ; q@@ _@@ con@@ j << q ( 0 ) , - q ( 1 ) , - q ( 2 ) , - q ( 3 ) ; return q@@ _@@ con@@ j ; } Eigen :: Matrix@@ 4@@ d d@@ qu@@ at@@ Con@@ j@@ ugate ( ) { Matrix@@ 4@@ d d@@ q@@ _@@ con@@ j = Matrix@@ 4@@ d :: Identity ( ) ; d@@ q@@ _@@ con@@ j ( 1 , 1 ) = - 1.0 ; d@@ q@@ _@@ con@@ j ( 2 , 2 ) = - 1.0 ; d@@ q@@ _@@ con@@ j ( 3 , 3 ) = - 1.0 ; return d@@ q@@ _@@ con@@ j ; } Eigen :: Vector@@ 4@@ d qu@@ at@@ Product ( const Eigen :: Vector@@ 4@@ d & q1 , const Eigen :: Vector@@ 4@@ d & q2 ) { double w@@ 1 = q1 ( 0 ) ; double w2 = q2 ( 0 ) ; const auto & v1 = q1 . tail < 3 > ( ) ; const auto & v2 = q2 . tail < 3 > ( ) ; Vector@@ 4@@ d r ; r << w@@ 1 * w2 - v1 . dot ( v2 ) , v1 . cross ( v2 ) + w@@ 1 * v2 + w2 * v1 ; return r ; } Eigen :: Matrix < double , 4 , 8 > d@@ qu@@ at@@ Product ( const Eigen :: Vector@@ 4@@ d & q1 , const Eigen :: Vector@@ 4@@ d & q2 ) { double w@@ 1 = q1 ( 0 ) ; double w2 = q2 ( 0 ) ; const auto & v1 = q1 . tail < 3 > ( ) ; const auto & v2 = q2 . tail < 3 > ( ) ; Matrix < double , 4 , 8 > d@@ r ; d@@ r . row ( 0 ) << w2 , - v2 . transpose ( ) , w@@ 1 , - v1 . transpose ( ) ; d@@ r . row ( 1 ) << q2 ( 1 ) , q2 ( 0 ) , q2 ( 3 ) , - q2 ( 2 ) , q1 ( 1 ) , q1 ( 0 ) , - q1 ( 3 ) , q1 ( 2 ) ; d@@ r . row ( 2 ) << q2 ( 2 ) , - q2 ( 3 ) , q2 ( 0 ) , q2 ( 1 ) , q1 ( 2 ) , q1 ( 3 ) , q1 ( 0 ) , - q1 ( 1 ) ; d@@ r . row ( 3 ) << q2 ( 3 ) , q2 ( 2 ) , - q2 ( 1 ) , q2 ( 0 ) , q1 ( 3 ) , - q1 ( 2 ) , q1 ( 1 ) , q1 ( 0 ) ; return d@@ r ; } Eigen :: Vector@@ 3d qu@@ at@@ Rot@@ ate@@ Vec ( const Eigen :: Vector@@ 4@@ d & q , const Eigen :: Vector@@ 3d & v ) { Vector@@ 4@@ d v_@@ quat ; v_@@ quat << 0 , v ; Vector@@ 4@@ d q@@ _@@ tim@@ es@@ _v = qu@@ at@@ Product ( q , v_@@ quat ) ; Vector@@ 4@@ d q@@ _@@ con@@ j = qu@@ at@@ Con@@ j@@ ugate ( q ) ; Vector@@ 4@@ d v_@@ rot = qu@@ at@@ Product ( q@@ _@@ tim@@ es@@ _v , q@@ _@@ con@@ j ) ; Vector@@ 3d r = v_@@ rot . botto@@ m@@ Rows < 3 > ( ) ; return r ; } Eigen :: Matrix < double , 3 , 7 > d@@ qu@@ at@@ Rot@@ ate@@ Vec ( const Eigen :: Vector@@ 4@@ d & q , const Eigen :: Vector@@ 3d & v ) { Matrix < double , 4 , 7 > d@@ q ; d@@ q << Matrix@@ 4@@ d :: Identity ( ) , MatrixXd :: Zero ( 4 , 3 ) ; Matrix < double , 4 , 7 > dv = Matrix < double , 4 , 7 > :: Zero ( ) ; dv . botto@@ m@@ Right@@ Cor@@ ner < 3 , 3 > ( ) = Matrix@@ 3d :: Identity ( ) ; Matrix < double , 8 , 7 > d@@ q@@ dv ; d@@ q@@ dv << d@@ q , dv ; Vector@@ 4@@ d v_@@ quat ; v_@@ quat << 0 , v ; Vector@@ 4@@ d q@@ _@@ tim@@ es@@ _v = qu@@ at@@ Product ( q , v_@@ quat ) ; Matrix < double , 4 , 8 > d@@ q@@ _@@ tim@@ es@@ _@@ v_@@ tmp = d@@ qu@@ at@@ Product ( q , v_@@ quat ) ; Matrix < double , 4 , 7 > d@@ q@@ _@@ tim@@ es@@ _v = d@@ q@@ _@@ tim@@ es@@ _@@ v_@@ tmp * d@@ q@@ dv ; Matrix < double , 4 , 7 > d@@ q@@ _@@ con@@ j = d@@ qu@@ at@@ Con@@ j@@ ugate ( ) * d@@ q ; Matrix < double , 8 , 7 > d@@ q@@ _@@ tim@@ es@@ _@@ v_@@ d@@ q@@ _@@ con@@ j ; d@@ q@@ _@@ tim@@ es@@ _@@ v_@@ d@@ q@@ _@@ con@@ j << d@@ q@@ _@@ tim@@ es@@ _v , d@@ q@@ _@@ con@@ j ; Matrix < double , 4 , 8 > d@@ v_@@ rot_@@ tmp = d@@ qu@@ at@@ Product ( q@@ _@@ tim@@ es@@ _v , qu@@ at@@ Con@@ j@@ ugate ( q ) ) ; Matrix < double , 4 , 7 > d@@ v_@@ rot = d@@ v_@@ rot_@@ tmp * d@@ q@@ _@@ tim@@ es@@ _@@ v_@@ d@@ q@@ _@@ con@@ j ; Eigen :: Matrix < double , 3 , 7 > d@@ r = d@@ v_@@ rot . botto@@ m@@ Rows ( 3 ) ; return d@@ r ; } Eigen :: Vector@@ 4@@ d qu@@ at@@ Di@@ ff ( const Eigen :: Vector@@ 4@@ d & q1 , const Eigen :: Vector@@ 4@@ d & q2 ) { return qu@@ at@@ Product ( qu@@ at@@ Con@@ j@@ ugate ( q1 ) , q2 ) ; } Eigen :: Matrix < double , 4 , 8 > d@@ qu@@ at@@ Di@@ ff ( const Eigen :: Vector@@ 4@@ d & q1 , const Eigen :: Vector@@ 4@@ d & q2 ) { auto d@@ r = d@@ qu@@ at@@ Product ( qu@@ at@@ Con@@ j@@ ugate ( q1 ) , q2 ) ; d@@ r . block < 4 , 3 > ( 0 , 1 ) = - d@@ r . block < 4 , 3 > ( 0 , 1 ) ; return d@@ r ; } double qu@@ at@@ Di@@ ff@@ Axis@@ In@@ var ( const Eigen :: Vector@@ 4@@ d & q1 , const Eigen :: Vector@@ 4@@ d & q2 , const Eigen :: Vector@@ 3d & u ) { Vector@@ 4@@ d r = qu@@ at@@ Di@@ ff ( q1 , q2 ) ; double e = - 2.0 + 2 * r ( 0 ) * r ( 0 ) + 2 * pow ( u ( 0 ) * r ( 1 ) + u ( 1 ) * r ( 2 ) + u ( 2 ) * r ( 3 ) , 2 ) ; return e ; } Eigen :: Matrix < double , 1 , 11 > d@@ qu@@ at@@ Di@@ ff@@ Axis@@ In@@ var ( const Eigen :: Vector@@ 4@@ d & q1 , const Eigen :: Vector@@ 4@@ d & q2 , const Eigen :: Vector@@ 3d & u ) { Vector@@ 4@@ d r = qu@@ at@@ Di@@ ff ( q1 , q2 ) ; Matrix < double , 4 , 8 > d@@ r = d@@ qu@@ at@@ Di@@ ff ( q1 , q2 ) ; Matrix < double , 1 , 11 > de ; const auto & r@@ vec = r . tail < 3 > ( ) ; de << 4.@@ 0 * r ( 0 ) * d@@ r . row ( 0 ) + 4.@@ 0 * u . transpose ( ) * r@@ vec * u . transpose ( ) * d@@ r . block < 3 , 8 > ( 1 , 0 ) , 4.@@ 0 * u . transpose ( ) * r@@ vec * r@@ vec . transpose ( ) ; return de ; } double qu@@ at@@ Nor@@ m ( const Eigen :: Vector@@ 4@@ d & q ) { return std :: ac@@ os ( q ( 0 ) ) ; } Eigen :: Vector@@ 4@@ d slerp ( const Eigen :: Vector@@ 4@@ d & q1 , const Eigen :: Vector@@ 4@@ d & q2 , double inter@@ po@@ l@@ ation_@@ parameter ) { double lam@@ b@@ da = ( q1 . transpose ( ) * q2 ) . value ( ) ; int q@@ 2_@@ sign ; if ( lam@@ b@@ da < 0.0 ) { lam@@ b@@ da = - lam@@ b@@ da ; q@@ 2_@@ sign = - 1 ; } else { q@@ 2_@@ sign = 1 ; } double r , s ; if ( std :: abs ( 1.0 - lam@@ b@@ da ) < std :: numer@@ ic@@ _@@ limits < double > :: epsilon ( ) ) { r = 1.0 - inter@@ po@@ l@@ ation_@@ parameter ; s = inter@@ po@@ l@@ ation_@@ parameter ; } else { double alpha = std :: ac@@ os ( lam@@ b@@ da ) ; double gamma = 1.0 / std :: sin ( alpha ) ; r = std :: sin ( ( 1.0 - inter@@ po@@ l@@ ation_@@ parameter ) * alpha ) * gamma ; s = std :: sin ( inter@@ po@@ l@@ ation_@@ parameter * alpha ) * gamma ; } Vector@@ 4@@ d ret = q1 * r ; ret += q@@ 2_@@ sign * q2 * s ; return ret ; } Vector@@ 4@@ d uni@@ for@@ ml@@ y@@ Random@@ Axis@@ Angle ( std :: default_@@ random_@@ engine & generator ) { std :: normal_distribution < double > normal ; std :: uni@@ for@@ m_re@@ al_distribu@@ tion < double > uni@@ form ( - M_PI , M_PI ) ; double angle = uni@@ form ( generator ) ; Vector@@ 3d axis = Vector@@ 3d ( normal ( generator ) , normal ( generator ) , normal ( generator ) ) ; axis . norm@@ alize ( ) ; Vector@@ 4@@ d a ; a << axis , angle ; return a ; } Vector@@ 4@@ d uni@@ for@@ ml@@ y@@ Random@@ Qu@@ at ( std :: default_@@ random_@@ engine & generator ) { return axis@@ 2@@ quat ( uni@@ for@@ ml@@ y@@ Random@@ Axis@@ Angle ( generator ) ) ; } Eigen :: Matrix@@ 3d uni@@ for@@ ml@@ y@@ Random@@ Rot@@ mat ( std :: default_@@ random_@@ engine & generator ) { return axis@@ 2@@ rot@@ mat ( uni@@ for@@ ml@@ y@@ Random@@ Axis@@ Angle ( generator ) ) ; } Eigen :: Vector@@ 3d uni@@ for@@ ml@@ y@@ Random@@ RP@@ Y ( std :: default_@@ random_@@ engine & generator ) { return axis@@ 2@@ r@@ py ( uni@@ for@@ ml@@ y@@ Random@@ Axis@@ Angle ( generator ) ) ; } template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 1 > qu@@ at@@ 2@@ r@@ py ( const Eigen :: Matrix@@ Base < Deri@@ ved > & q ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 4 ) ; auto q@@ _@@ normalized = q . normalized ( ) ; auto w = q@@ _@@ normalized ( 0 ) ; auto x = q@@ _@@ normalized ( 1 ) ; auto y = q@@ _@@ normalized ( 2 ) ; auto z = q@@ _@@ normalized ( 3 ) ; Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 1 > ret ; ret << std :: atan@@ 2 ( 2.0 * ( w * x + y * z ) , w * w + z * z - ( x * x + y * y ) ) , std :: asin ( 2.0 * ( w * y - z * x ) ) , std :: atan@@ 2 ( 2.0 * ( w * z + x * y ) , w * w + x * x - ( y * y + z * z ) ) ; return ret ; } template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 3 > qu@@ at@@ 2@@ rot@@ mat ( const Eigen :: Matrix@@ Base < Deri@@ ved > & q ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 4 ) ; auto q@@ _@@ normalized = q . normalized ( ) ; auto w = q@@ _@@ normalized ( 0 ) ; auto x = q@@ _@@ normalized ( 1 ) ; auto y = q@@ _@@ normalized ( 2 ) ; auto z = q@@ _@@ normalized ( 3 ) ; Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 3 > M ; M . row ( 0 ) << w * w + x * x - y * y - z * z , 2.0 * x * y - 2.0 * w * z , 2.0 * x * z + 2.0 * w * y ; M . row ( 1 ) << 2.0 * x * y + 2.0 * w * z , w * w + y * y - x * x - z * z , 2.0 * y * z - 2.0 * w * x ; M . row ( 2 ) << 2.0 * x * z - 2.0 * w * y , 2.0 * y * z + 2.0 * w * x , w * w + z * z - x * x - y * y ; return M ; } template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 4 , 1 > qu@@ at@@ 2@@ axis ( const Eigen :: Matrix@@ Base < Deri@@ ved > & q ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 4 ) ; auto q@@ _@@ normalized = q . normalized ( ) ; auto s = std :: sqrt ( 1.0 - q@@ _@@ normalized ( 0 ) * q@@ _@@ normalized ( 0 ) ) + std :: numer@@ ic@@ _@@ limits < typename Deri@@ ved :: Scalar > :: epsilon ( ) ; Eigen :: Matrix < typename Deri@@ ved :: Scalar , 4 , 1 > a ; a << q@@ _@@ normalized . template tail < 3 > ( ) / s , 2.0 * std :: ac@@ os ( q@@ _@@ normalized ( 0 ) ) ; return a ; } template < typename Deri@@ ved > Eigen :: Vector@@ 4@@ d axis@@ 2@@ quat ( const Eigen :: Matrix@@ Base < Deri@@ ved > & a ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 4 ) ; auto axis = a . template head < 3 > ( ) ; auto angle = a ( 3 ) ; auto arg = 0.5 * angle ; auto c = std :: cos ( arg ) ; auto s = std :: sin ( arg ) ; Eigen :: Vector@@ 4@@ d ret ; ret << c , s * axis ; return ret ; } template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 3 > axis@@ 2@@ rot@@ mat ( const Eigen :: Matrix@@ Base < Deri@@ ved > & a ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 4 ) ; const auto & axis = ( a . template head < 3 > ( ) ) / ( a . template head < 3 > ( ) ) . norm ( ) ; const auto & theta = a ( 3 ) ; auto x = axis ( 0 ) ; auto y = axis ( 1 ) ; auto z = axis ( 2 ) ; auto c@@ theta = std :: cos ( theta ) ; auto sth@@ et@@ a = std :: sin ( theta ) ; auto c = 1 - c@@ theta ; Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 3 > R ; R << c@@ theta + x * x * c , x * y * c - z * sth@@ et@@ a , x * z * c + y * sth@@ et@@ a , y * x * c + z * sth@@ et@@ a , c@@ theta + y * y * c , y * z * c - x * sth@@ et@@ a , z * x * c - y * sth@@ et@@ a , z * y * c + x * sth@@ et@@ a , c@@ theta + z * z * c ; return R ; } template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 1 > axis@@ 2@@ r@@ py ( const Eigen :: Matrix@@ Base < Deri@@ ved > & a ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 4 ) ; return qu@@ at@@ 2@@ r@@ py ( axis@@ 2@@ quat ( a ) ) ; } template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 4 , 1 > rot@@ mat@@ 2@@ axis ( const Eigen :: Matrix@@ Base < Deri@@ ved > & R ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ MAT@@ RI@@ X@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 3 , 3 ) ; typename Deri@@ ved :: Scalar theta = std :: ac@@ os ( ( R . trace ( ) - 1.0 ) / 2.0 ) ; Vector@@ 4@@ d a ; if ( theta > std :: numer@@ ic@@ _@@ limits < typename Deri@@ ved :: Scalar > :: epsilon ( ) ) { a << R ( 2 , 1 ) - R ( 1 , 2 ) , R ( 0 , 2 ) - R ( 2 , 0 ) , R ( 1 , 0 ) - R ( 0 , 1 ) , theta ; a . head < 3 > ( ) *= 1.0 / ( 2.0 * std :: sin ( theta ) ) ; } else { a << 1.0 , 0.0 , 0.0 , 0.0 ; } return a ; } template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 4 , 1 > rot@@ mat@@ 2@@ quat ( const Eigen :: Matrix@@ Base < Deri@@ ved > & M ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ MAT@@ RI@@ X@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 3 , 3 ) ; using namespace std ; Matrix < typename Deri@@ ved :: Scalar , 4 , 3 > A ; A . row ( 0 ) << 1.0 , 1.0 , 1.0 ; A . row ( 1 ) << 1.0 , - 1.0 , - 1.0 ; A . row ( 2 ) << - 1.0 , 1.0 , - 1.0 ; A . row ( 3 ) << - 1.0 , - 1.0 , 1.0 ; Matrix < typename Deri@@ ved :: Scalar , 4 , 1 > B = A * M . diag@@ on@@ al ( ) ; typename Matrix < typename Deri@@ ved :: Scalar , 4 , 1 > :: Index ind , max_@@ col ; typename Deri@@ ved :: Scalar val = B . max@@ Coe@@ ff ( & ind , & max_@@ col ) ; typename Deri@@ ved :: Scalar w , x , y , z ; switch ( ind ) { case 0 : { w = sqrt ( 1.0 + val ) / 2.0 ; typename Deri@@ ved :: Scalar w@@ 4 = w * 4.@@ 0 ; x = ( M ( 2 , 1 ) - M ( 1 , 2 ) ) / w@@ 4 ; y = ( M ( 0 , 2 ) - M ( 2 , 0 ) ) / w@@ 4 ; z = ( M ( 1 , 0 ) - M ( 0 , 1 ) ) / w@@ 4 ; break ; } case 1 : { double s = 2.0 * sqrt ( 1.0 + val ) ; w = ( M ( 2 , 1 ) - M ( 1 , 2 ) ) / s ; x = 0.25 * s ; y = ( M ( 0 , 1 ) + M ( 1 , 0 ) ) / s ; z = ( M ( 0 , 2 ) + M ( 2 , 0 ) ) / s ; break ; } case 2 : { double s = 2.0 * ( sqrt ( 1.0 + val ) ) ; w = ( M ( 0 , 2 ) - M ( 2 , 0 ) ) / s ; x = ( M ( 0 , 1 ) + M ( 1 , 0 ) ) / s ; y = 0.25 * s ; z = ( M ( 1 , 2 ) + M ( 2 , 1 ) ) / s ; break ; } default : { double s = 2.0 * ( sqrt ( 1.0 + val ) ) ; w = ( M ( 1 , 0 ) - M ( 0 , 1 ) ) / s ; x = ( M ( 0 , 2 ) + M ( 2 , 0 ) ) / s ; y = ( M ( 1 , 2 ) + M ( 2 , 1 ) ) / s ; z = 0.25 * s ; break ; } } Eigen :: Matrix < typename Deri@@ ved :: Scalar , 4 , 1 > q ; q << w , x , y , z ; return q ; } template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 1 > rot@@ mat@@ 2@@ r@@ py ( const Eigen :: Matrix@@ Base < Deri@@ ved > & R ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ MAT@@ RI@@ X@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 3 , 3 ) ; using namespace std ; Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 1 > r@@ py ; r@@ py << atan@@ 2 ( R ( 2 , 1 ) , R ( 2 , 2 ) ) , atan@@ 2 ( - R ( 2 , 0 ) , sqrt ( pow ( R ( 2 , 1 ) , 2.0 ) + pow ( R ( 2 , 2 ) , 2.0 ) ) ) , atan@@ 2 ( R ( 1 , 0 ) , R ( 0 , 0 ) ) ; return r@@ py ; } template < typename Deri@@ ved > DL@@ LEXPORT Eigen :: Matrix < typename Deri@@ ved :: Scalar , Eigen :: Dynamic , 1 > rot@@ mat@@ 2@@ Re@@ presentation ( const Eigen :: Matrix@@ Base < Deri@@ ved > & R , int rot@@ ation@@ _type ) { typedef typename Deri@@ ved :: Scalar Scalar ; Eigen :: Matrix < Scalar , Eigen :: Dynamic , 1 > ret ; switch ( rot@@ ation@@ _type ) { case 0 : return Eigen :: Matrix < Scalar , Eigen :: Dynamic , 1 > ( 0 , 1 ) ; case 1 : return rot@@ mat@@ 2@@ r@@ py ( R ) ; case 2 : return rot@@ mat@@ 2@@ quat ( R ) ; default : throw std :: runtime_error ( " rotation ▁ re@@ presentation ▁ type ▁ not ▁ reco@@ gnized " ) ; } } template < typename Scalar > DL@@ LEXPORT Gradient@@ Var < Scalar , Eigen :: Dynamic , 1 > rot@@ mat@@ 2@@ Re@@ presentation ( const Gradient@@ Var < Scalar , SP@@ ACE_@@ DIMEN@@ SION , SP@@ ACE_@@ DIMEN@@ SION > & R , int rot@@ ation@@ _type ) { Gradient@@ Var < Scalar , Eigen :: Dynamic , 1 > ret ( rot@@ ation@@ Re@@ present@@ ation@@ Size ( rot@@ ation@@ _type ) , 1 , R . getNum@@ Variables ( ) , R . max@@ Order ( ) ) ; switch ( rot@@ ation@@ _type ) { case 0 : break ; case 1 : ret . value ( ) = rot@@ mat@@ 2@@ r@@ py ( R . value ( ) ) ; if ( R . has@@ Gradi@@ ent ( ) ) { ret . gradi@@ ent ( ) . value ( ) = d@@ rot@@ mat@@ 2@@ r@@ py ( R . value ( ) , R . gradi@@ ent ( ) . value ( ) ) ; } break ; case 2 : ret . value ( ) = rot@@ mat@@ 2@@ quat ( R . value ( ) ) ; if ( R . has@@ Gradi@@ ent ( ) ) { ret . gradi@@ ent ( ) . value ( ) = d@@ rot@@ mat@@ 2@@ quat ( R . value ( ) , R . gradi@@ ent ( ) . value ( ) ) ; } break ; default : throw std :: runtime_error ( " rotation ▁ re@@ presentation ▁ type ▁ not ▁ reco@@ gnized " ) ; } return ret ; } template < typename Deri@@ ved > Gradient@@ Var < typename Deri@@ ved :: Scalar , QU@@ AT_@@ SIZE , 1 > exp@@ map@@ 2@@ quat ( const Eigen :: Matrix@@ Base < Deri@@ ved > & v , const int gradi@@ ent_@@ order ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 3 ) ; Gradient@@ Var < typename Deri@@ ved :: Scalar , QU@@ AT_@@ SIZE , 1 > ret ( QU@@ AT_@@ SIZE , 1 , EXP@@ MAP@@ _SIZE , gradi@@ ent_@@ order ) ; auto theta = v . norm ( ) ; if ( theta < pow ( std :: numer@@ ic@@ _@@ limits < typename Deri@@ ved :: Scalar > :: epsilon ( ) , 0.25 ) ) { ret . value ( ) = exp@@ map@@ 2@@ qu@@ at@@ De@@ generate ( v , theta ) ; if ( gradi@@ ent_@@ order > 0 ) { ret . gradi@@ ent ( ) . value ( ) = dex@@ pmap@@ 2@@ qu@@ at@@ De@@ generate ( v , theta ) ; if ( gradi@@ ent_@@ order > 1 ) { ret . gradi@@ ent ( ) . gradi@@ ent ( ) . value ( ) = d@@ dex@@ pmap@@ 2@@ qu@@ at@@ De@@ generate ( v , theta ) ; if ( gradi@@ ent_@@ order > 2 ) { throw std :: runtime_error ( " exp@@ map@@ 2@@ quat ▁ does ▁ not ▁ support ▁ gradi@@ ent ▁ order ▁ larger ▁ than ▁ 2" ) ; } } } } else { ret . value ( ) = exp@@ map@@ 2@@ qu@@ at@@ Non@@ De@@ generate ( v , theta ) ; if ( gradi@@ ent_@@ order > 0 ) { ret . gradi@@ ent ( ) . value ( ) = dex@@ pmap@@ 2@@ qu@@ at@@ Non@@ De@@ generate ( v , theta ) ; if ( gradi@@ ent_@@ order > 1 ) { ret . gradi@@ ent ( ) . gradi@@ ent ( ) . value ( ) = d@@ dex@@ pmap@@ 2@@ qu@@ at@@ Non@@ De@@ generate ( v , theta ) ; if ( gradi@@ ent_@@ order > 2 ) { throw std :: runtime_error ( " exp@@ map@@ 2@@ quat ▁ does ▁ not ▁ support ▁ gradi@@ ent ▁ order ▁ larger ▁ than ▁ 2" ) ; } } } } return ret ; } DL@@ LEXPORT int rot@@ ation@@ Re@@ present@@ ation@@ Size ( int rot@@ ation@@ _type ) { switch ( rot@@ ation@@ _type ) { case 0 : return 0 ; break ; case 1 : return 3 ; break ; case 2 : return 4 ; break ; default : throw std :: runtime_error ( " rotation ▁ re@@ presentation ▁ type ▁ not ▁ reco@@ gnized " ) ; } } template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 4 , 1 > r@@ py@@ 2@@ axis ( const Eigen :: Matrix@@ Base < Deri@@ ved > & r@@ py ) { return qu@@ at@@ 2@@ axis ( r@@ py@@ 2@@ quat ( r@@ py ) ) ; } template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 4 , 1 > r@@ py@@ 2@@ quat ( const Eigen :: Matrix@@ Base < Deri@@ ved > & r@@ py ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 3 ) ; auto rp@@ y_@@ 2 = ( r@@ py / 2.0 ) . array ( ) ; auto s = rp@@ y_@@ 2 . sin ( ) ; auto c = rp@@ y_@@ 2 . cos ( ) ; Vector@@ 4@@ d q ; q << c ( 0 ) * c ( 1 ) * c ( 2 ) + s ( 0 ) * s ( 1 ) * s ( 2 ) , s ( 0 ) * c ( 1 ) * c ( 2 ) - c ( 0 ) * s ( 1 ) * s ( 2 ) , c ( 0 ) * s ( 1 ) * c ( 2 ) + s ( 0 ) * c ( 1 ) * s ( 2 ) , c ( 0 ) * c ( 1 ) * s ( 2 ) - s ( 0 ) * s ( 1 ) * c ( 2 ) ; q /= q . norm ( ) + std :: numer@@ ic@@ _@@ limits < typename Deri@@ ved :: Scalar > :: epsilon ( ) ; return q ; } template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 3 > r@@ py@@ 2@@ rot@@ mat ( const Eigen :: Matrix@@ Base < Deri@@ ved > & r@@ py ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 3 ) ; auto rp@@ y_@@ array = r@@ py . array ( ) ; auto s = rp@@ y_@@ array . sin ( ) ; auto c = rp@@ y_@@ array . cos ( ) ; Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 3 > R ; R . row ( 0 ) << c ( 2 ) * c ( 1 ) , c ( 2 ) * s ( 1 ) * s ( 0 ) - s ( 2 ) * c ( 0 ) , c ( 2 ) * s ( 1 ) * c ( 0 ) + s ( 2 ) * s ( 0 ) ; R . row ( 1 ) << s ( 2 ) * c ( 1 ) , s ( 2 ) * s ( 1 ) * s ( 0 ) + c ( 2 ) * c ( 0 ) , s ( 2 ) * s ( 1 ) * c ( 0 ) - c ( 2 ) * s ( 0 ) ; R . row ( 2 ) << - s ( 1 ) , c ( 1 ) * s ( 0 ) , c ( 1 ) * c ( 0 ) ; return R ; } Matrix@@ 3d rot@@ z ( double theta ) { Matrix@@ 3d M ; double c = cos ( theta ) ; double s = sin ( theta ) ; M << c , - s , 0 , s , c , 0 , 0 , 0 , 1 ; return M ; } void rot@@ z ( double theta , Matrix@@ 3d & M , Matrix@@ 3d & d@@ M , Matrix@@ 3d & dd@@ M ) { double c = cos ( theta ) , s = sin ( theta ) ; M << c , - s , 0 , s , c , 0 , 0 , 0 , 1 ; d@@ M << - s , - c , 0 , c , - s , 0 , 0 , 0 , 0 ; dd@@ M << - c , s , 0 , - s , - c , 0 , 0 , 0 , 0 ; } template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 9 , 3 > dr@@ py@@ 2@@ rot@@ mat ( const Eigen :: Matrix@@ Base < Deri@@ ved > & r@@ py ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , 3 ) ; auto rp@@ y_@@ array = r@@ py . array ( ) ; auto s = rp@@ y_@@ array . sin ( ) ; auto c = rp@@ y_@@ array . cos ( ) ; Eigen :: Matrix < typename Deri@@ ved :: Scalar , 9 , 3 > d@@ R ; d@@ R . row ( 0 ) << 0 , c ( 2 ) * - s ( 1 ) , c ( 1 ) * - s ( 2 ) ; d@@ R . row ( 1 ) << 0 , - s ( 1 ) * s ( 2 ) , c ( 2 ) * c ( 1 ) ; d@@ R . row ( 2 ) << 0 , - c ( 1 ) , 0 ; d@@ R . row ( 3 ) << c ( 2 ) * s ( 1 ) * c ( 0 ) - s ( 2 ) * - s ( 0 ) , c ( 2 ) * c ( 1 ) * s ( 0 ) , - s ( 2 ) * s ( 1 ) * s ( 0 ) - c ( 2 ) * c ( 0 ) ; d@@ R . row ( 4 ) << s ( 2 ) * s ( 1 ) * c ( 0 ) + c ( 2 ) * - s ( 0 ) , s ( 2 ) * c ( 1 ) * s ( 0 ) , c ( 2 ) * s ( 1 ) * s ( 0 ) - s ( 2 ) * c ( 0 ) ; d@@ R . row ( 5 ) << c ( 1 ) * c ( 0 ) , - s ( 1 ) * s ( 0 ) , 0 ; d@@ R . row ( 6 ) << c ( 2 ) * s ( 1 ) * - s ( 0 ) + s ( 2 ) * c ( 0 ) , c ( 2 ) * c ( 1 ) * c ( 0 ) , - s ( 2 ) * s ( 1 ) * c ( 0 ) + c ( 2 ) * s ( 0 ) ; d@@ R . row ( 7 ) << s ( 2 ) * s ( 1 ) * - s ( 0 ) - c ( 2 ) * c ( 0 ) , s ( 2 ) * c ( 1 ) * c ( 0 ) , c ( 2 ) * s ( 1 ) * c ( 0 ) + s ( 2 ) * s ( 0 ) ; d@@ R . row ( 8 ) << c ( 1 ) * - s ( 0 ) , - s ( 1 ) * c ( 0 ) , 0 ; return d@@ R ; } template < typename Deri@@ ved > void normalize@@ Vec ( const Eigen :: Matrix@@ Base < Deri@@ ved > & x , typename Deri@@ ved :: Pla@@ in@@ Object & x_@@ norm , typename Gradi@@ ent < Deri@@ ved , Deri@@ ved :: Row@@ s@@ At@@ Compile@@ Time , 1 > :: type * dx_@@ norm , typename Gradi@@ ent < Deri@@ ved , Deri@@ ved :: Row@@ s@@ At@@ Compile@@ Time , 2 > :: type * dd@@ x_@@ norm ) { typename Deri@@ ved :: Scalar x@@ do@@ tx = x . squaredNor@@ m ( ) ; typename Deri@@ ved :: Scalar nor@@ m_@@ x = std :: sqrt ( x@@ do@@ tx ) ; x_@@ norm = x / nor@@ m_@@ x ; if ( dx_@@ norm ) { dx_@@ norm -> setIdentity ( x . rows ( ) , x . rows ( ) ) ; ( * dx_@@ norm ) -= x * x . transpose ( ) / x@@ do@@ tx ; ( * dx_@@ norm ) /= nor@@ m_@@ x ; if ( dd@@ x_@@ norm ) { auto dx_@@ nor@@ m_trans@@ pose = transpose@@ Gra@@ d ( * dx_@@ norm , x . rows ( ) ) ; auto dd@@ x_@@ nor@@ m_tim@@ es@@ _@@ norm = - mat@@ Gr@@ ad@@ M@@ ult@@ Mat ( x_@@ norm , x_@@ norm . transpose ( ) , ( * dx_@@ norm ) , dx_@@ nor@@ m_trans@@ pose ) ; auto d@@ nor@@ m_in@@ v = - x . transpose ( ) / ( x@@ do@@ tx * nor@@ m_@@ x ) ; ( * dd@@ x_@@ norm ) = dd@@ x_@@ nor@@ m_tim@@ es@@ _@@ norm / nor@@ m_@@ x ; auto temp = ( * dx_@@ norm ) * nor@@ m_@@ x ; typename Deri@@ ved :: Index n = x . rows ( ) ; for ( int col = 0 ; col < n ; col ++ ) { auto colum@@ n_@@ as_@@ matrix = ( d@@ nor@@ m_in@@ v ( 0 , col ) * temp ) ; for ( int row@@ _b@@ lock = 0 ; row@@ _b@@ lock < n ; row@@ _b@@ lock ++ ) { dd@@ x_@@ norm -> block ( row@@ _b@@ lock * n , col , n , 1 ) += colum@@ n_@@ as_@@ matrix . col ( row@@ _b@@ lock ) ; } } } } } template < typename Deri@@ ved > typename Gradi@@ ent < Matrix < typename Deri@@ ved :: Scalar , 3 , 3 > , QU@@ AT_@@ SIZE > :: type d@@ qu@@ at@@ 2@@ rot@@ mat ( const Eigen :: Matrix@@ Base < Deri@@ ved > & q ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , QU@@ AT_@@ SIZE ) ; typename Gradi@@ ent < Matrix < typename Deri@@ ved :: Scalar , 3 , 3 > , QU@@ AT_@@ SIZE > :: type ret ; typename Eigen :: Matrix@@ Base < Deri@@ ved > :: Pla@@ in@@ Object q@@ ti@@ l@@ de ; typename Gradi@@ ent < Deri@@ ved , QU@@ AT_@@ SIZE > :: type d@@ q@@ ti@@ l@@ de ; normalize@@ Vec ( q , q@@ ti@@ l@@ de , & d@@ q@@ ti@@ l@@ de ) ; typedef typename Deri@@ ved :: Scalar Scalar ; Scalar w = q@@ ti@@ l@@ de ( 0 ) ; Scalar x = q@@ ti@@ l@@ de ( 1 ) ; Scalar y = q@@ ti@@ l@@ de ( 2 ) ; Scalar z = q@@ ti@@ l@@ de ( 3 ) ; ret << w , x , - y , - z , z , y , x , w , - y , z , - w , x , - z , y , x , - w , w , - x , y , - z , x , w , z , y , y , z , w , x , - x , - w , z , y , w , - x , - y , z ; ret *= 2.0 ; ret *= d@@ q@@ ti@@ l@@ de ; return ret ; } template < typename Deri@@ ved@@ R , typename Deri@@ ved@@ DR > typename Gradi@@ ent < Eigen :: Matrix < typename Deri@@ ved@@ R :: Scalar , RP@@ Y_SIZE , 1 > , Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > :: type d@@ rot@@ mat@@ 2@@ r@@ py ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ R > & R , const Eigen :: Matrix@@ Base < Deri@@ ved@@ DR > & d@@ R ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ MAT@@ RI@@ X@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved@@ R > , SP@@ ACE_@@ DIMEN@@ SION , SP@@ ACE_@@ DIMEN@@ SION ) ; EIG@@ EN@@ _STAT@@ IC_@@ ASSERT ( Eigen :: Matrix@@ Base < Deri@@ ved@@ DR > :: Row@@ s@@ At@@ Compile@@ Time == Ro@@ tmat@@ Size , TH@@ IS_@@ METHO@@ D_@@ IS_@@ ONLY_@@ FOR_@@ MAT@@ R@@ IC@@ ES_@@ OF@@ _A@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ) ; typename Deri@@ ved@@ DR :: Index n@@ q = d@@ R . cols ( ) ; typedef typename Deri@@ ved@@ R :: Scalar Scalar ; typedef typename Gradi@@ ent < Eigen :: Matrix < Scalar , RP@@ Y_SIZE , 1 > , Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > :: type Return@@ Type ; Return@@ Type dr@@ py ( RP@@ Y_SIZE , n@@ q ) ; auto d@@ R@@ 11@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 0 , 0 , R . rows ( ) ) ; auto d@@ R@@ 21@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 1 , 0 , R . rows ( ) ) ; auto d@@ R@@ 3@@ 1@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 2 , 0 , R . rows ( ) ) ; auto d@@ R@@ 32@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 2 , 1 , R . rows ( ) ) ; auto d@@ R@@ 33@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 2 , 2 , R . rows ( ) ) ; Scalar sq@@ term = R ( 2 , 1 ) * R ( 2 , 1 ) + R ( 2 , 2 ) * R ( 2 , 2 ) ; using namespace std ; dr@@ py . row ( 0 ) = ( R ( 2 , 2 ) * d@@ R@@ 32@@ _d@@ q - R ( 2 , 1 ) * d@@ R@@ 33@@ _d@@ q ) / sq@@ term ; Scalar sq@@ rt_@@ sq@@ term = sqrt ( sq@@ term ) ; dr@@ py . row ( 1 ) = ( - sq@@ rt_@@ sq@@ term * d@@ R@@ 3@@ 1@@ _d@@ q + R ( 2 , 0 ) / sq@@ rt_@@ sq@@ term * ( R ( 2 , 1 ) * d@@ R@@ 32@@ _d@@ q + R ( 2 , 2 ) * d@@ R@@ 33@@ _d@@ q ) ) / ( R ( 2 , 0 ) * R ( 2 , 0 ) + R ( 2 , 1 ) * R ( 2 , 1 ) + R ( 2 , 2 ) * R ( 2 , 2 ) ) ; sq@@ term = R ( 0 , 0 ) * R ( 0 , 0 ) + R ( 1 , 0 ) * R ( 1 , 0 ) ; dr@@ py . row ( 2 ) = ( R ( 0 , 0 ) * d@@ R@@ 21@@ _d@@ q - R ( 1 , 0 ) * d@@ R@@ 11@@ _d@@ q ) / sq@@ term ; return dr@@ py ; } template < typename Deri@@ ved@@ R , typename Deri@@ ved@@ DR > typename Gradi@@ ent < Eigen :: Matrix < typename Deri@@ ved@@ R :: Scalar , QU@@ AT_@@ SIZE , 1 > , Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > :: type d@@ rot@@ mat@@ 2@@ quat ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ R > & R , const Eigen :: Matrix@@ Base < Deri@@ ved@@ DR > & d@@ R ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ MAT@@ RI@@ X@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved@@ R > , SP@@ ACE_@@ DIMEN@@ SION , SP@@ ACE_@@ DIMEN@@ SION ) ; EIG@@ EN@@ _STAT@@ IC_@@ ASSERT ( Eigen :: Matrix@@ Base < Deri@@ ved@@ DR > :: Row@@ s@@ At@@ Compile@@ Time == Ro@@ tmat@@ Size , TH@@ IS_@@ METHO@@ D_@@ IS_@@ ONLY_@@ FOR_@@ MAT@@ R@@ IC@@ ES_@@ OF@@ _A@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ) ; typedef typename Deri@@ ved@@ R :: Scalar Scalar ; typedef typename Gradi@@ ent < Eigen :: Matrix < Scalar , QU@@ AT_@@ SIZE , 1 > , Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > :: type Return@@ Type ; typename Deri@@ ved@@ DR :: Index n@@ q = d@@ R . cols ( ) ; auto d@@ R@@ 11@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 0 , 0 , R . rows ( ) ) ; auto d@@ R@@ 12@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 0 , 1 , R . rows ( ) ) ; auto d@@ R@@ 13@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 0 , 2 , R . rows ( ) ) ; auto d@@ R@@ 21@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 1 , 0 , R . rows ( ) ) ; auto d@@ R@@ 2@@ 2_@@ d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 1 , 1 , R . rows ( ) ) ; auto d@@ R@@ 23@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 1 , 2 , R . rows ( ) ) ; auto d@@ R@@ 3@@ 1@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 2 , 0 , R . rows ( ) ) ; auto d@@ R@@ 32@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 2 , 1 , R . rows ( ) ) ; auto d@@ R@@ 33@@ _d@@ q = getSub@@ Matrix@@ Gradi@@ ent < Deri@@ ved@@ DR :: Col@@ s@@ At@@ Compile@@ Time > ( d@@ R , 2 , 2 , R . rows ( ) ) ; Matrix < Scalar , 4 , 3 > A ; A . row ( 0 ) << 1.0 , 1.0 , 1.0 ; A . row ( 1 ) << 1.0 , - 1.0 , - 1.0 ; A . row ( 2 ) << - 1.0 , 1.0 , - 1.0 ; A . row ( 3 ) << - 1.0 , - 1.0 , 1.0 ; Matrix < Scalar , 4 , 1 > B = A * R . diag@@ on@@ al ( ) ; typename Matrix < Scalar , 4 , 1 > :: Index ind , max_@@ col ; Scalar val = B . max@@ Coe@@ ff ( & ind , & max_@@ col ) ; Return@@ Type d@@ q ( QU@@ AT_@@ SIZE , n@@ q ) ; using namespace std ; switch ( ind ) { case 0 : { auto d@@ val@@ d@@ q = d@@ R@@ 11@@ _d@@ q + d@@ R@@ 2@@ 2_@@ d@@ q + d@@ R@@ 33@@ _d@@ q ; auto dw@@ d@@ q = d@@ val@@ d@@ q / ( 4.@@ 0 * sqrt ( 1.0 + val ) ) ; auto w = sqrt ( 1.0 + val ) / 2.0 ; auto w@@ squ@@ are@@ 4 = 4.@@ 0 * w * w ; d@@ q . row ( 0 ) = dw@@ d@@ q ; d@@ q . row ( 1 ) = ( ( d@@ R@@ 32@@ _d@@ q - d@@ R@@ 23@@ _d@@ q ) * w - ( R ( 2 , 1 ) - R ( 1 , 2 ) ) * dw@@ d@@ q ) / w@@ squ@@ are@@ 4 ; d@@ q . row ( 2 ) = ( ( d@@ R@@ 13@@ _d@@ q - d@@ R@@ 3@@ 1@@ _d@@ q ) * w - ( R ( 0 , 2 ) - R ( 2 , 0 ) ) * dw@@ d@@ q ) / w@@ squ@@ are@@ 4 ; d@@ q . row ( 3 ) = ( ( d@@ R@@ 21@@ _d@@ q - d@@ R@@ 12@@ _d@@ q ) * w - ( R ( 1 , 0 ) - R ( 0 , 1 ) ) * dw@@ d@@ q ) / w@@ squ@@ are@@ 4 ; break ; } case 1 : { auto d@@ val@@ d@@ q = d@@ R@@ 11@@ _d@@ q - d@@ R@@ 2@@ 2_@@ d@@ q - d@@ R@@ 33@@ _d@@ q ; auto s = 2.0 * sqrt ( 1.0 + val ) ; auto ss@@ qu@@ are = s * s ; auto dsd@@ q = d@@ val@@ d@@ q / sqrt ( 1.0 + val ) ; d@@ q . row ( 0 ) = ( ( d@@ R@@ 32@@ _d@@ q - d@@ R@@ 23@@ _d@@ q ) * s - ( R ( 2 , 1 ) - R ( 1 , 2 ) ) * dsd@@ q ) / ss@@ qu@@ are ; d@@ q . row ( 1 ) = .@@ 25 * dsd@@ q ; d@@ q . row ( 2 ) = ( ( d@@ R@@ 12@@ _d@@ q + d@@ R@@ 21@@ _d@@ q ) * s - ( R ( 0 , 1 ) + R ( 1 , 0 ) ) * dsd@@ q ) / ss@@ qu@@ are ; d@@ q . row ( 3 ) = ( ( d@@ R@@ 13@@ _d@@ q + d@@ R@@ 3@@ 1@@ _d@@ q ) * s - ( R ( 0 , 2 ) + R ( 2 , 0 ) ) * dsd@@ q ) / ss@@ qu@@ are ; break ; } case 2 : { auto d@@ val@@ d@@ q = - d@@ R@@ 11@@ _d@@ q + d@@ R@@ 2@@ 2_@@ d@@ q - d@@ R@@ 33@@ _d@@ q ; auto s = 2.0 * ( sqrt ( 1.0 + val ) ) ; auto ss@@ qu@@ are = s * s ; auto dsd@@ q = d@@ val@@ d@@ q / sqrt ( 1.0 + val ) ; d@@ q . row ( 0 ) = ( ( d@@ R@@ 13@@ _d@@ q - d@@ R@@ 3@@ 1@@ _d@@ q ) * s - ( R ( 0 , 2 ) - R ( 2 , 0 ) ) * dsd@@ q ) / ss@@ qu@@ are ; d@@ q . row ( 1 ) = ( ( d@@ R@@ 12@@ _d@@ q + d@@ R@@ 21@@ _d@@ q ) * s - ( R ( 0 , 1 ) + R ( 1 , 0 ) ) * dsd@@ q ) / ss@@ qu@@ are ; d@@ q . row ( 2 ) = .@@ 25 * dsd@@ q ; d@@ q . row ( 3 ) = ( ( d@@ R@@ 23@@ _d@@ q + d@@ R@@ 32@@ _d@@ q ) * s - ( R ( 1 , 2 ) + R ( 2 , 1 ) ) * dsd@@ q ) / ss@@ qu@@ are ; break ; } default : { auto d@@ val@@ d@@ q = - d@@ R@@ 11@@ _d@@ q - d@@ R@@ 2@@ 2_@@ d@@ q + d@@ R@@ 33@@ _d@@ q ; auto s = 2.0 * ( sqrt ( 1.0 + val ) ) ; auto ss@@ qu@@ are = s * s ; auto dsd@@ q = d@@ val@@ d@@ q / sqrt ( 1.0 + val ) ; d@@ q . row ( 0 ) = ( ( d@@ R@@ 21@@ _d@@ q - d@@ R@@ 12@@ _d@@ q ) * s - ( R ( 1 , 0 ) - R ( 0 , 1 ) ) * dsd@@ q ) / ss@@ qu@@ are ; d@@ q . row ( 1 ) = ( ( d@@ R@@ 13@@ _d@@ q + d@@ R@@ 3@@ 1@@ _d@@ q ) * s - ( R ( 0 , 2 ) + R ( 2 , 0 ) ) * dsd@@ q ) / ss@@ qu@@ are ; d@@ q . row ( 2 ) = ( ( d@@ R@@ 23@@ _d@@ q + d@@ R@@ 32@@ _d@@ q ) * s - ( R ( 1 , 2 ) + R ( 2 , 1 ) ) * dsd@@ q ) / ss@@ qu@@ are ; d@@ q . row ( 3 ) = .@@ 25 * dsd@@ q ; break ; } } return d@@ q ; } template < typename Deri@@ ved > Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 3 > vector@@ To@@ S@@ ke@@ w@@ Sy@@ mm@@ et@@ ric ( const Eigen :: Matrix@@ Base < Deri@@ ved > & p ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved > , SP@@ ACE_@@ DIMEN@@ SION ) ; Eigen :: Matrix < typename Deri@@ ved :: Scalar , 3 , 3 > ret ; ret << 0.0 , - p ( 2 ) , p ( 1 ) , p ( 2 ) , 0.0 , - p ( 0 ) , - p ( 1 ) , p ( 0 ) , 0.0 ; return ret ; } template < typename Deri@@ ved@@ A , typename Deri@@ ved@@ B > Eigen :: Matrix < typename Deri@@ ved@@ A :: Scalar , 3 , Eigen :: Dynamic > d@@ cro@@ ss@@ Product ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ A > & a , const Eigen :: Matrix@@ Base < Deri@@ ved@@ B > & b , const typename Gradi@@ ent < Deri@@ ved@@ A , Eigen :: Dynamic > :: type & da , const typename Gradi@@ ent < Deri@@ ved@@ B , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename Deri@@ ved@@ A :: Scalar , 3 , Eigen :: Dynamic > ret ( 3 , da . cols ( ) ) ; ret . no@@ al@@ ias ( ) = da . col@@ w@@ ise ( ) . cross ( b ) ; ret . no@@ al@@ ias ( ) -= db . col@@ w@@ ise ( ) . cross ( a ) ; return ret ; } template < typename Deri@@ ved@@ Q , typename Deri@@ ved@@ M , typename Deri@@ ved@@ DM > void ang@@ ular@@ vel@@ 2@@ qu@@ at@@ do@@ t@@ Matrix ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ Q > & q , Eigen :: Matrix@@ Base < Deri@@ ved@@ M > & M , Eigen :: Matrix@@ Base < Deri@@ ved@@ DM > * d@@ M ) { M . resize ( QU@@ AT_@@ SIZE , SP@@ ACE_@@ DIMEN@@ SION ) ; M . row ( 0 ) << - q ( 1 ) , - q ( 2 ) , - q ( 3 ) ; M . row ( 1 ) << q ( 0 ) , q ( 3 ) , - q ( 2 ) ; M . row ( 2 ) << - q ( 3 ) , q ( 0 ) , q ( 1 ) ; M . row ( 3 ) << q ( 2 ) , - q ( 1 ) , q ( 0 ) ; M *= 0.5 ; if ( d@@ M ) { ( * d@@ M ) << 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.5 , 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 ; } } template < typename Deri@@ ved@@ Q , typename Deri@@ ved@@ M > void qu@@ at@@ do@@ t2@@ ang@@ ular@@ vel@@ Matrix ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ Q > & q , Eigen :: Matrix@@ Base < Deri@@ ved@@ M > & M , typename Gradi@@ ent < Deri@@ ved@@ M , QU@@ AT_@@ SIZE , 1 > :: type * d@@ M ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved@@ Q > , QU@@ AT_@@ SIZE ) ; EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ MAT@@ RI@@ X@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved@@ M > , SP@@ ACE_@@ DIMEN@@ SION , QU@@ AT_@@ SIZE ) ; typename Deri@@ ved@@ Q :: Pla@@ in@@ Object q@@ ti@@ l@@ de ; if ( d@@ M ) { typename Gradi@@ ent < Deri@@ ved@@ Q , QU@@ AT_@@ SIZE > :: type d@@ q@@ ti@@ l@@ de ; normalize@@ Vec ( q , q@@ ti@@ l@@ de , & d@@ q@@ ti@@ l@@ de ) ; ( * d@@ M ) << 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , 0.0 ; ( * d@@ M ) *= d@@ q@@ ti@@ l@@ de ; } else { normalize@@ Vec ( q , q@@ ti@@ l@@ de ) ; } M << - q@@ ti@@ l@@ de ( 1 ) , q@@ ti@@ l@@ de ( 0 ) , - q@@ ti@@ l@@ de ( 3 ) , q@@ ti@@ l@@ de ( 2 ) , - q@@ ti@@ l@@ de ( 2 ) , q@@ ti@@ l@@ de ( 3 ) , q@@ ti@@ l@@ de ( 0 ) , - q@@ ti@@ l@@ de ( 1 ) , - q@@ ti@@ l@@ de ( 3 ) , - q@@ ti@@ l@@ de ( 2 ) , q@@ ti@@ l@@ de ( 1 ) , q@@ ti@@ l@@ de ( 0 ) ; M *= 2.0 ; } template < typename Deri@@ ved@@ RP@@ Y , typename Deri@@ ved@@ Phi , typename Deri@@ ved@@ D@@ Phi , typename Deri@@ ved@@ DD@@ Phi > void ang@@ ular@@ vel@@ 2@@ r@@ py@@ do@@ t@@ Matrix ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ RP@@ Y > & r@@ py , typename Eigen :: Matrix@@ Base < Deri@@ ved@@ Phi > & ph@@ i , typename Eigen :: Matrix@@ Base < Deri@@ ved@@ D@@ Phi > * d@@ ph@@ i , typename Eigen :: Matrix@@ Base < Deri@@ ved@@ DD@@ Phi > * dd@@ ph@@ i ) { ph@@ i . resize ( RP@@ Y_SIZE , SP@@ ACE_@@ DIMEN@@ SION ) ; typedef typename Deri@@ ved@@ RP@@ Y :: Scalar Scalar ; Scalar p = r@@ py ( 1 ) ; Scalar y = r@@ py ( 2 ) ; using namespace std ; Scalar sy = sin ( y ) ; Scalar cy = cos ( y ) ; Scalar sp = sin ( p ) ; Scalar c@@ p = cos ( p ) ; Scalar t@@ p = sp / c@@ p ; ph@@ i << cy / c@@ p , sy / c@@ p , 0.0 , - sy , cy , 0.0 , cy * t@@ p , t@@ p * sy , 1.0 ; if ( d@@ ph@@ i ) { d@@ ph@@ i -> resize ( ph@@ i . size ( ) , RP@@ Y_SIZE ) ; Scalar sp@@ 2 = sp * sp ; Scalar c@@ p2 = c@@ p * c@@ p ; ( * d@@ ph@@ i ) << 0.0 , ( cy * sp ) / c@@ p2 , - sy / c@@ p , 0.0 , 0.0 , - cy , 0.0 , cy + ( cy * sp@@ 2 ) / c@@ p2 , - ( sp * sy ) / c@@ p , 0.0 , ( sp * sy ) / c@@ p2 , cy / c@@ p , 0.0 , 0.0 , - sy , 0.0 , sy + ( sp@@ 2 * sy ) / c@@ p2 , ( cy * sp ) / c@@ p , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; if ( dd@@ ph@@ i ) { dd@@ ph@@ i -> resize ( d@@ ph@@ i -> size ( ) , RP@@ Y_SIZE ) ; Scalar cp@@ 3 = c@@ p2 * c@@ p ; ( * dd@@ ph@@ i ) << 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - ( cy * ( c@@ p2 - 2.0 ) ) / cp@@ 3 , ( sp * sy ) / ( sp@@ 2 - 1.0 ) , 0.0 , 0.0 , 0.0 , 0.0 , ( 2.0 * cy * sp ) / cp@@ 3 , sy / ( sp@@ 2 - 1.0 ) , 0.0 , ( 2.0 * sy - c@@ p2 * sy ) / cp@@ 3 , ( cy * sp ) / c@@ p2 , 0.0 , 0.0 , 0.0 , 0.0 , ( 2.0 * sp * sy ) / cp@@ 3 , cy / c@@ p2 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , ( sp * sy ) / ( sp@@ 2 - 1.0 ) , - cy / c@@ p , 0.0 , 0.0 , sy , 0.0 , sy / ( sp@@ 2 - 1.0 ) , - ( cy * sp ) / c@@ p , 0.0 , ( cy * sp ) / c@@ p2 , - sy / c@@ p , 0.0 , 0.0 , - cy , 0.0 , cy / c@@ p2 , - ( sp * sy ) / c@@ p , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; } } } template < typename Deri@@ ved > DL@@ LEXPORT Gradient@@ Var < typename Deri@@ ved :: Scalar , Eigen :: Dynamic , SP@@ ACE_@@ DIMEN@@ SION > ang@@ ular@@ vel@@ 2@@ Re@@ present@@ ation@@ Dot@@ Matrix ( int rot@@ ation@@ _type , const Eigen :: Matrix@@ Base < Deri@@ ved > & q@@ rot , int gradi@@ ent_@@ order ) { Gradient@@ Var < typename Deri@@ ved :: Scalar , Eigen :: Dynamic , SP@@ ACE_@@ DIMEN@@ SION > ret ( q@@ rot . rows ( ) , SP@@ ACE_@@ DIMEN@@ SION , q@@ rot . rows ( ) , gradi@@ ent_@@ order ) ; switch ( rot@@ ation@@ _type ) { case 0 : break ; case 1 : { if ( gradi@@ ent_@@ order > 1 ) { ang@@ ular@@ vel@@ 2@@ r@@ py@@ do@@ t@@ Matrix ( q@@ rot , ret . value ( ) , & ret . gradi@@ ent ( ) . value ( ) , & ret . gradi@@ ent ( ) . gradi@@ ent ( ) . value ( ) ) ; } else if ( gradi@@ ent_@@ order > 0 ) { ang@@ ular@@ vel@@ 2@@ r@@ py@@ do@@ t@@ Matrix ( q@@ rot , ret . value ( ) , & ret . gradi@@ ent ( ) . value ( ) , ( MatrixXd * ) nullptr ) ; } else { ang@@ ular@@ vel@@ 2@@ r@@ py@@ do@@ t@@ Matrix ( q@@ rot , ret . value ( ) , ( MatrixXd * ) nullptr , ( MatrixXd * ) nullptr ) ; } break ; } case 2 : { if ( gradi@@ ent_@@ order > 1 ) { ret . gradi@@ ent ( ) . gradi@@ ent ( ) . value ( ) . setZero ( ) ; } if ( gradi@@ ent_@@ order > 0 ) { ang@@ ular@@ vel@@ 2@@ qu@@ at@@ do@@ t@@ Matrix ( q@@ rot , ret . value ( ) , & ret . gradi@@ ent ( ) . value ( ) ) ; } else { ang@@ ular@@ vel@@ 2@@ qu@@ at@@ do@@ t@@ Matrix ( q@@ rot , ret . value ( ) , ( MatrixXd * ) nullptr ) ; } break ; } default : throw std :: runtime_error ( " rotation ▁ re@@ presentation ▁ type ▁ not ▁ reco@@ gnized " ) ; } return ret ; } template < typename Deri@@ ved@@ RP@@ Y , typename Deri@@ ved@@ E > void r@@ py@@ do@@ t2@@ ang@@ ular@@ vel@@ Matrix ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ RP@@ Y > & r@@ py , Eigen :: Matrix@@ Base < Deri@@ ved@@ E > & E , typename Gradi@@ ent < Deri@@ ved@@ E , RP@@ Y_SIZE , 1 > :: type * d@@ E ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved@@ RP@@ Y > , RP@@ Y_SIZE ) ; EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ MAT@@ RI@@ X@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved@@ E > , SP@@ ACE_@@ DIMEN@@ SION , RP@@ Y_SIZE ) ; typedef typename Deri@@ ved@@ RP@@ Y :: Scalar Scalar ; Scalar p = r@@ py ( 1 ) ; Scalar y = r@@ py ( 2 ) ; Scalar sp = sin ( p ) ; Scalar c@@ p = cos ( p ) ; Scalar sy = sin ( y ) ; Scalar cy = cos ( y ) ; using namespace std ; E << c@@ p * cy , - sy , 0.0 , c@@ p * sy , cy , 0.0 , - sp , 0.0 , 1.0 ; if ( d@@ E ) { ( * d@@ E ) << 0.0 , - sp * cy , - c@@ p * sy , 0.0 , - sp * sy , c@@ p * cy , 0.0 , - c@@ p , 0.0 , 0.0 , 0.0 , - cy , 0.0 , 0.0 , - sy , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; } } template < typename Deri@@ ved@@ M > typename Transform@@ Sp@@ ati@@ al < Deri@@ ved@@ M > :: type transform@@ Sp@@ ati@@ al@@ Mo@@ tion ( const Eigen :: Transform < typename Deri@@ ved@@ M :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: Matrix@@ Base < Deri@@ ved@@ M > & M ) { Eigen :: Matrix < typename Deri@@ ved@@ M :: Scalar , TW@@ IS@@ T_@@ SIZE , Deri@@ ved@@ M :: Col@@ s@@ At@@ Compile@@ Time > ret ( TW@@ IS@@ T_@@ SIZE , M . cols ( ) ) ; ret . template top@@ Rows < 3 > ( ) . no@@ al@@ ias ( ) = T . linear ( ) * M . template top@@ Rows < 3 > ( ) ; ret . template botto@@ m@@ Rows < 3 > ( ) . no@@ al@@ ias ( ) = - ret . template top@@ Rows < 3 > ( ) . col@@ w@@ ise ( ) . cross ( T . translation ( ) ) ; ret . template botto@@ m@@ Rows < 3 > ( ) . no@@ al@@ ias ( ) += T . linear ( ) * M . template botto@@ m@@ Rows < 3 > ( ) ; return ret ; } template < typename Deri@@ ved@@ F > typename Transform@@ Sp@@ ati@@ al < Deri@@ ved@@ F > :: type transform@@ Sp@@ ati@@ al@@ For@@ ce ( const Eigen :: Transform < typename Deri@@ ved@@ F :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: Matrix@@ Base < Deri@@ ved@@ F > & F ) { Eigen :: Matrix < typename Deri@@ ved@@ F :: Scalar , TW@@ IS@@ T_@@ SIZE , Deri@@ ved@@ F :: Col@@ s@@ At@@ Compile@@ Time > ret ( TW@@ IS@@ T_@@ SIZE , F . cols ( ) ) ; ret . template botto@@ m@@ Rows < 3 > ( ) . no@@ al@@ ias ( ) = T . linear ( ) * F . template botto@@ m@@ Rows < 3 > ( ) . eval ( ) ; ret . template top@@ Rows < 3 > ( ) = - ret . template botto@@ m@@ Rows < 3 > ( ) . col@@ w@@ ise ( ) . cross ( T . translation ( ) ) ; ret . template top@@ Rows < 3 > ( ) . no@@ al@@ ias ( ) += T . linear ( ) * F . template top@@ Rows < 3 > ( ) ; return ret ; } template < typename Deri@@ ved@@ I > Gradient@@ Var < typename Deri@@ ved@@ I :: Scalar , TW@@ IS@@ T_@@ SIZE , TW@@ IS@@ T_@@ SIZE > transform@@ Sp@@ ati@@ al@@ Inerti@@ a ( const Eigen :: Transform < typename Deri@@ ved@@ I :: Scalar , SP@@ ACE_@@ DIMEN@@ SION , Eigen :: Isometry > & T_@@ current_@@ to_@@ new , const typename Gradi@@ ent < typename Eigen :: Transform < typename Deri@@ ved@@ I :: Scalar , SP@@ ACE_@@ DIMEN@@ SION , Eigen :: Isometry > :: MatrixType , Eigen :: Dynamic > :: type * d@@ T_@@ current_@@ to_@@ new , const Eigen :: Matrix@@ Base < Deri@@ ved@@ I > & I ) { int gradi@@ ent_@@ order ; typename Deri@@ ved@@ I :: Index n@@ q ; if ( d@@ T_@@ current_@@ to_@@ new ) { gradi@@ ent_@@ order = 1 ; n@@ q = d@@ T_@@ current_@@ to_@@ new -> cols ( ) ; } else { n@@ q = 0 ; gradi@@ ent_@@ order = 0 ; } Gradient@@ Var < typename Deri@@ ved@@ I :: Scalar , TW@@ IS@@ T_@@ SIZE , TW@@ IS@@ T_@@ SIZE > ret ( TW@@ IS@@ T_@@ SIZE , TW@@ IS@@ T_@@ SIZE , n@@ q , gradi@@ ent_@@ order ) ; auto I@@ _h@@ al@@ f_@@ transform@@ ed = transform@@ Sp@@ ati@@ al@@ For@@ ce ( T_@@ current_@@ to_@@ new , I ) ; ret . value ( ) = transform@@ Sp@@ ati@@ al@@ For@@ ce ( T_@@ current_@@ to_@@ new , I@@ _h@@ al@@ f_@@ transform@@ ed . transpose ( ) ) ; if ( gradi@@ ent_@@ order > 0 ) { auto d@@ I = Eigen :: Matrix < typename Deri@@ ved@@ I :: Scalar , Deri@@ ved@@ I :: Size@@ At@@ Compile@@ Time , Eigen :: Dynamic > :: Zero ( I . size ( ) , n@@ q ) . eval ( ) ; auto d@@ I@@ _h@@ al@@ f_@@ transform@@ ed = d@@ Transform@@ Sp@@ ati@@ al@@ For@@ ce ( T_@@ current_@@ to_@@ new , I , * d@@ T_@@ current_@@ to_@@ new , d@@ I ) ; auto d@@ I@@ _h@@ al@@ f_@@ transform@@ ed_@@ transpose = transpose@@ Gra@@ d ( d@@ I@@ _h@@ al@@ f_@@ transform@@ ed , I@@ _h@@ al@@ f_@@ transform@@ ed . rows ( ) ) ; ret . gradi@@ ent ( ) . value ( ) = d@@ Transform@@ Sp@@ ati@@ al@@ For@@ ce ( T_@@ current_@@ to_@@ new , I@@ _h@@ al@@ f_@@ transform@@ ed . transpose ( ) , * d@@ T_@@ current_@@ to_@@ new , d@@ I@@ _h@@ al@@ f_@@ transform@@ ed_@@ transpose ) ; } return ret ; } template < typename Deri@@ ved@@ A , typename Deri@@ ved@@ B > typename Transform@@ Sp@@ ati@@ al < Deri@@ ved@@ B > :: type cro@@ ss@@ Sp@@ ati@@ al@@ Mo@@ tion ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ A > & a , const Eigen :: Matrix@@ Base < Deri@@ ved@@ B > & b ) { typename Transform@@ Sp@@ ati@@ al < Deri@@ ved@@ B > :: type ret ( TW@@ IS@@ T_@@ SIZE , b . cols ( ) ) ; ret . template top@@ Rows < 3 > ( ) = - b . template top@@ Rows < 3 > ( ) . col@@ w@@ ise ( ) . cross ( a . template top@@ Rows < 3 > ( ) ) ; ret . template botto@@ m@@ Rows < 3 > ( ) = - b . template top@@ Rows < 3 > ( ) . col@@ w@@ ise ( ) . cross ( a . template botto@@ m@@ Rows < 3 > ( ) ) ; ret . template botto@@ m@@ Rows < 3 > ( ) -= b . template botto@@ m@@ Rows < 3 > ( ) . col@@ w@@ ise ( ) . cross ( a . template top@@ Rows < 3 > ( ) ) ; return ret ; } template < typename Deri@@ ved@@ A , typename Deri@@ ved@@ B > typename Transform@@ Sp@@ ati@@ al < Deri@@ ved@@ B > :: type cro@@ ss@@ Sp@@ ati@@ al@@ For@@ ce ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ A > & a , const Eigen :: Matrix@@ Base < Deri@@ ved@@ B > & b ) { typename Transform@@ Sp@@ ati@@ al < Deri@@ ved@@ B > :: type ret ( TW@@ IS@@ T_@@ SIZE , b . cols ( ) ) ; ret . template top@@ Rows < 3 > ( ) = - b . template top@@ Rows < 3 > ( ) . col@@ w@@ ise ( ) . cross ( a . template top@@ Rows < 3 > ( ) ) ; ret . template top@@ Rows < 3 > ( ) -= b . template botto@@ m@@ Rows < 3 > ( ) . col@@ w@@ ise ( ) . cross ( a . template botto@@ m@@ Rows < 3 > ( ) ) ; ret . template botto@@ m@@ Rows < 3 > ( ) = - b . template botto@@ m@@ Rows < 3 > ( ) . col@@ w@@ ise ( ) . cross ( a . template top@@ Rows < 3 > ( ) ) ; return ret ; } template < typename Deri@@ ved@@ A , typename Deri@@ ved@@ B > Eigen :: Matrix < typename Deri@@ ved@@ A :: Scalar , TW@@ IS@@ T_@@ SIZE , Eigen :: Dynamic > d@@ Cross@@ Sp@@ ati@@ al@@ Mo@@ tion ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ A > & a , const Eigen :: Matrix@@ Base < Deri@@ ved@@ B > & b , const typename Gradi@@ ent < Deri@@ ved@@ A , Eigen :: Dynamic > :: type & da , const typename Gradi@@ ent < Deri@@ ved@@ B , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename Deri@@ ved@@ A :: Scalar , TW@@ IS@@ T_@@ SIZE , Eigen :: Dynamic > ret ( TW@@ IS@@ T_@@ SIZE , da . cols ( ) ) ; ret . row ( 0 ) = - da . row ( 2 ) * b [ 1 ] + da . row ( 1 ) * b [ 2 ] - a [ 2 ] * db . row ( 1 ) + a [ 1 ] * db . row ( 2 ) ; ret . row ( 1 ) = da . row ( 2 ) * b [ 0 ] - da . row ( 0 ) * b [ 2 ] + a [ 2 ] * db . row ( 0 ) - a [ 0 ] * db . row ( 2 ) ; ret . row ( 2 ) = - da . row ( 1 ) * b [ 0 ] + da . row ( 0 ) * b [ 1 ] - a [ 1 ] * db . row ( 0 ) + a [ 0 ] * db . row ( 1 ) ; ret . row ( 3 ) = - da . row ( 5 ) * b [ 1 ] + da . row ( 4 ) * b [ 2 ] - da . row ( 2 ) * b [ 4 ] + da . row ( 1 ) * b [ 5 ] - a [ 5 ] * db . row ( 1 ) + a [ 4 ] * db . row ( 2 ) - a [ 2 ] * db . row ( 4 ) + a [ 1 ] * db . row ( 5 ) ; ret . row ( 4 ) = da . row ( 5 ) * b [ 0 ] - da . row ( 3 ) * b [ 2 ] + da . row ( 2 ) * b [ 3 ] - da . row ( 0 ) * b [ 5 ] + a [ 5 ] * db . row ( 0 ) - a [ 3 ] * db . row ( 2 ) + a [ 2 ] * db . row ( 3 ) - a [ 0 ] * db . row ( 5 ) ; ret . row ( 5 ) = - da . row ( 4 ) * b [ 0 ] + da . row ( 3 ) * b [ 1 ] - da . row ( 1 ) * b [ 3 ] + da . row ( 0 ) * b [ 4 ] - a [ 4 ] * db . row ( 0 ) + a [ 3 ] * db . row ( 1 ) - a [ 1 ] * db . row ( 3 ) + a [ 0 ] * db . row ( 4 ) ; return ret ; } template < typename Deri@@ ved@@ A , typename Deri@@ ved@@ B > Eigen :: Matrix < typename Deri@@ ved@@ A :: Scalar , TW@@ IS@@ T_@@ SIZE , Eigen :: Dynamic > d@@ Cross@@ Sp@@ ati@@ al@@ For@@ ce ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ A > & a , const Eigen :: Matrix@@ Base < Deri@@ ved@@ B > & b , const typename Gradi@@ ent < Deri@@ ved@@ A , Eigen :: Dynamic > :: type & da , const typename Gradi@@ ent < Deri@@ ved@@ B , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename Deri@@ ved@@ A :: Scalar , TW@@ IS@@ T_@@ SIZE , Eigen :: Dynamic > ret ( TW@@ IS@@ T_@@ SIZE , da . cols ( ) ) ; ret . row ( 0 ) = da . row ( 2 ) * b [ 1 ] - da . row ( 1 ) * b [ 2 ] + da . row ( 5 ) * b [ 4 ] - da . row ( 4 ) * b [ 5 ] + a [ 2 ] * db . row ( 1 ) - a [ 1 ] * db . row ( 2 ) + a [ 5 ] * db . row ( 4 ) - a [ 4 ] * db . row ( 5 ) ; ret . row ( 1 ) = - da . row ( 2 ) * b [ 0 ] + da . row ( 0 ) * b [ 2 ] - da . row ( 5 ) * b [ 3 ] + da . row ( 3 ) * b [ 5 ] - a [ 2 ] * db . row ( 0 ) + a [ 0 ] * db . row ( 2 ) - a [ 5 ] * db . row ( 3 ) + a [ 3 ] * db . row ( 5 ) ; ret . row ( 2 ) = da . row ( 1 ) * b [ 0 ] - da . row ( 0 ) * b [ 1 ] + da . row ( 4 ) * b [ 3 ] - da . row ( 3 ) * b [ 4 ] + a [ 1 ] * db . row ( 0 ) - a [ 0 ] * db . row ( 1 ) + a [ 4 ] * db . row ( 3 ) - a [ 3 ] * db . row ( 4 ) ; ret . row ( 3 ) = da . row ( 2 ) * b [ 4 ] - da . row ( 1 ) * b [ 5 ] + a [ 2 ] * db . row ( 4 ) - a [ 1 ] * db . row ( 5 ) ; ret . row ( 4 ) = - da . row ( 2 ) * b [ 3 ] + da . row ( 0 ) * b [ 5 ] - a [ 2 ] * db . row ( 3 ) + a [ 0 ] * db . row ( 5 ) ; ret . row ( 5 ) = da . row ( 1 ) * b [ 3 ] - da . row ( 0 ) * b [ 4 ] + a [ 1 ] * db . row ( 3 ) - a [ 0 ] * db . row ( 4 ) ; ret = - ret ; return ret ; } template < typename Deri@@ ved@@ S , typename Deri@@ ved@@ Q@@ do@@ t@@ To@@ V > typename D@@ Ho@@ mo@@ g@@ Tran@@ s < Deri@@ ved@@ Q@@ do@@ t@@ To@@ V > :: type d@@ Ho@@ mo@@ g@@ Tran@@ s ( const Eigen :: Transform < typename Deri@@ ved@@ Q@@ do@@ t@@ To@@ V :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: Matrix@@ Base < Deri@@ ved@@ S > & S , const Eigen :: Matrix@@ Base < Deri@@ ved@@ Q@@ do@@ t@@ To@@ V > & q@@ do@@ t_@@ to_@@ v ) { const int n@@ q@@ _@@ at@@ _@@ compile_@@ time = Deri@@ ved@@ Q@@ do@@ t@@ To@@ V :: Col@@ s@@ At@@ Compile@@ Time ; typename Deri@@ ved@@ Q@@ do@@ t@@ To@@ V :: Index n@@ q = q@@ do@@ t_@@ to_@@ v . cols ( ) ; auto q@@ do@@ t_@@ to_@@ tw@@ ist = ( S * q@@ do@@ t_@@ to_@@ v ) . eval ( ) ; const int num@@ el = HO@@ MO@@ G@@ EN@@ E@@ O@@ US_@@ TRANS@@ FOR@@ M@@ _SIZE ; Eigen :: Matrix < typename Deri@@ ved@@ Q@@ do@@ t@@ To@@ V :: Scalar , num@@ el , n@@ q@@ _@@ at@@ _@@ compile_@@ time > ret ( num@@ el , n@@ q ) ; const auto & R@@ x = T . linear ( ) . col ( 0 ) ; const auto & R@@ y = T . linear ( ) . col ( 1 ) ; const auto & R@@ z = T . linear ( ) . col ( 2 ) ; const auto & q@@ do@@ t_@@ to_@@ om@@ eg@@ a_@@ x = q@@ do@@ t_@@ to_@@ tw@@ ist . row ( 0 ) ; const auto & q@@ do@@ t_@@ to_@@ om@@ eg@@ a_@@ y = q@@ do@@ t_@@ to_@@ tw@@ ist . row ( 1 ) ; const auto & q@@ do@@ t_@@ to_@@ om@@ eg@@ a_@@ z = q@@ do@@ t_@@ to_@@ tw@@ ist . row ( 2 ) ; ret . template m@@ idd@@ le@@ Rows < 3 > ( 0 ) = - R@@ z * q@@ do@@ t_@@ to_@@ om@@ eg@@ a_@@ y + R@@ y * q@@ do@@ t_@@ to_@@ om@@ eg@@ a_@@ z ; ret . row ( 3 ) . setZero ( ) ; ret . template m@@ idd@@ le@@ Rows < 3 > ( 4 ) = R@@ z * q@@ do@@ t_@@ to_@@ om@@ eg@@ a_@@ x - R@@ x * q@@ do@@ t_@@ to_@@ om@@ eg@@ a_@@ z ; ret . row ( 7 ) . setZero ( ) ; ret . template m@@ idd@@ le@@ Rows < 3 > ( 8 ) = - R@@ y * q@@ do@@ t_@@ to_@@ om@@ eg@@ a_@@ x + R@@ x * q@@ do@@ t_@@ to_@@ om@@ eg@@ a_@@ y ; ret . row ( 11 ) . setZero ( ) ; ret . template m@@ idd@@ le@@ Rows < 3 > ( 12 ) = T . linear ( ) * q@@ do@@ t_@@ to_@@ tw@@ ist . botto@@ m@@ Rows ( 3 ) ; ret . row ( 15 ) . setZero ( ) ; return ret ; } template < typename Deri@@ ved@@ DT > typename D@@ Ho@@ mo@@ g@@ Tran@@ s < Deri@@ ved@@ DT > :: type d@@ Ho@@ mo@@ g@@ Trans@@ In@@ v ( const Eigen :: Transform < typename Deri@@ ved@@ DT :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: Matrix@@ Base < Deri@@ ved@@ DT > & d@@ T ) { typename Deri@@ ved@@ DT :: Index n@@ q = d@@ T . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_@@ cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_@@ cols = { 3 } ; auto d@@ R = getSub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( d@@ T , rows , R_@@ cols , T . Rows ) ; auto dp = getSub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( d@@ T , rows , p_@@ cols , T . Rows ) ; auto d@@ inv@@ T_@@ R = transpose@@ Gra@@ d ( d@@ R , R . rows ( ) ) ; auto d@@ inv@@ T_@@ p = ( - R . transpose ( ) * dp - mat@@ Gr@@ ad@@ M@@ ult ( d@@ inv@@ T_@@ R , p ) ) . eval ( ) ; const int num@@ el = HO@@ MO@@ G@@ EN@@ E@@ O@@ US_@@ TRANS@@ FOR@@ M@@ _SIZE ; Eigen :: Matrix < typename Deri@@ ved@@ DT :: Scalar , num@@ el , Deri@@ ved@@ DT :: Col@@ s@@ At@@ Compile@@ Time > ret ( num@@ el , n@@ q ) ; set@@ Sub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( ret , d@@ inv@@ T_@@ R , rows , R_@@ cols , T . Rows ) ; set@@ Sub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( ret , d@@ inv@@ T_@@ p , rows , p_@@ cols , T . Rows ) ; const int last_@@ row = 3 ; for ( int col = 0 ; col < T . H@@ Dim ; col ++ ) { ret . row ( last_@@ row + col * T . Rows ) . setZero ( ) ; } return ret ; } template < typename Scalar , typename Deri@@ ved@@ X , typename Deri@@ ved@@ DT , typename Deri@@ ved@@ D@@ X > typename Gradi@@ ent < Deri@@ ved@@ X , Deri@@ ved@@ D@@ X :: Col@@ s@@ At@@ Compile@@ Time , 1 > :: type d@@ Transform@@ Sp@@ ati@@ al@@ Mo@@ tion ( const Eigen :: Transform < Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: Matrix@@ Base < Deri@@ ved@@ X > & X , const Eigen :: Matrix@@ Base < Deri@@ ved@@ DT > & d@@ T , const Eigen :: Matrix@@ Base < Deri@@ ved@@ D@@ X > & d@@ X ) { assert ( d@@ T . cols ( ) == d@@ X . cols ( ) ) ; typename Deri@@ ved@@ DT :: Index n@@ q = d@@ T . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_@@ cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_@@ cols = { 3 } ; auto d@@ R = getSub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( d@@ T , rows , R_@@ cols , T . Rows ) ; auto dp = getSub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( d@@ T , rows , p_@@ cols , T . Rows ) ; typename Gradi@@ ent < Deri@@ ved@@ X , Deri@@ ved@@ D@@ X :: Col@@ s@@ At@@ Compile@@ Time , 1 > :: type ret ( X . size ( ) , n@@ q ) ; std :: array < int , 3 > X@@ om@@ eg@@ a_@@ rows = { 0 , 1 , 2 } ; std :: array < int , 3 > X@@ v_@@ rows = { 3 , 4 , 5 } ; for ( int col = 0 ; col < X . cols ( ) ; col ++ ) { auto X@@ om@@ eg@@ a_@@ col = X . template block < 3 , 1 > ( 0 , col ) ; auto X@@ v_@@ col = X . template block < 3 , 1 > ( 3 , col ) ; auto R@@ X@@ om@@ eg@@ a_@@ col = ( R * X@@ om@@ eg@@ a_@@ col ) . eval ( ) ; std :: array < int , 1 > col@@ _@@ array = { col } ; auto d@@ X@@ om@@ eg@@ a_@@ col = getSub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( d@@ X , X@@ om@@ eg@@ a_@@ rows , col@@ _@@ array , X . rows ( ) ) ; auto d@@ X@@ v_@@ col = getSub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( d@@ X , X@@ v_@@ rows , col@@ _@@ array , X . rows ( ) ) ; auto do@@ me@@ g@@ a_@@ part_@@ col = ( R * d@@ X@@ om@@ eg@@ a_@@ col + mat@@ Gr@@ ad@@ M@@ ult ( d@@ R , X@@ om@@ eg@@ a_@@ col ) ) . eval ( ) ; auto d@@ v_@@ part_@@ col = ( R * d@@ X@@ v_@@ col + mat@@ Gr@@ ad@@ M@@ ult ( d@@ R , X@@ v_@@ col ) ) . eval ( ) ; d@@ v_@@ part_@@ col += dp . col@@ w@@ ise ( ) . cross ( R@@ X@@ om@@ eg@@ a_@@ col ) ; d@@ v_@@ part_@@ col -= do@@ me@@ g@@ a_@@ part_@@ col . col@@ w@@ ise ( ) . cross ( p ) ; set@@ Sub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( ret , do@@ me@@ g@@ a_@@ part_@@ col , X@@ om@@ eg@@ a_@@ rows , col@@ _@@ array , X . rows ( ) ) ; set@@ Sub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( ret , d@@ v_@@ part_@@ col , X@@ v_@@ rows , col@@ _@@ array , X . rows ( ) ) ; } return ret ; } template < typename Scalar , typename Deri@@ ved@@ X , typename Deri@@ ved@@ DT , typename Deri@@ ved@@ D@@ X > typename Gradi@@ ent < Deri@@ ved@@ X , Deri@@ ved@@ D@@ X :: Col@@ s@@ At@@ Compile@@ Time > :: type d@@ Transform@@ Sp@@ ati@@ al@@ For@@ ce ( const Eigen :: Transform < Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: Matrix@@ Base < Deri@@ ved@@ X > & X , const Eigen :: Matrix@@ Base < Deri@@ ved@@ DT > & d@@ T , const Eigen :: Matrix@@ Base < Deri@@ ved@@ D@@ X > & d@@ X ) { assert ( d@@ T . cols ( ) == d@@ X . cols ( ) ) ; typename Deri@@ ved@@ DT :: Index n@@ q = d@@ T . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_@@ cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_@@ cols = { 3 } ; auto d@@ R = getSub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( d@@ T , rows , R_@@ cols , T . Rows ) ; auto dp = getSub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( d@@ T , rows , p_@@ cols , T . Rows ) ; typename Gradi@@ ent < Deri@@ ved@@ X , Deri@@ ved@@ D@@ X :: Col@@ s@@ At@@ Compile@@ Time > :: type ret ( X . size ( ) , n@@ q ) ; std :: array < int , 3 > X@@ om@@ eg@@ a_@@ rows = { 0 , 1 , 2 } ; std :: array < int , 3 > X@@ v_@@ rows = { 3 , 4 , 5 } ; for ( int col = 0 ; col < X . cols ( ) ; col ++ ) { auto X@@ om@@ eg@@ a_@@ col = X . template block < 3 , 1 > ( 0 , col ) ; auto X@@ v_@@ col = X . template block < 3 , 1 > ( 3 , col ) ; auto R@@ X@@ v_@@ col = ( R * X@@ v_@@ col ) . eval ( ) ; std :: array < int , 1 > col@@ _@@ array = { col } ; auto d@@ X@@ om@@ eg@@ a_@@ col = getSub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( d@@ X , X@@ om@@ eg@@ a_@@ rows , col@@ _@@ array , X . rows ( ) ) ; auto d@@ X@@ v_@@ col = getSub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( d@@ X , X@@ v_@@ rows , col@@ _@@ array , X . rows ( ) ) ; auto do@@ me@@ g@@ a_@@ part_@@ col = ( R * d@@ X@@ om@@ eg@@ a_@@ col ) . eval ( ) ; do@@ me@@ g@@ a_@@ part_@@ col += mat@@ Gr@@ ad@@ M@@ ult ( d@@ R , X@@ om@@ eg@@ a_@@ col ) ; auto d@@ v_@@ part_@@ col = ( R * d@@ X@@ v_@@ col ) . eval ( ) ; d@@ v_@@ part_@@ col += mat@@ Gr@@ ad@@ M@@ ult ( d@@ R , X@@ v_@@ col ) ; do@@ me@@ g@@ a_@@ part_@@ col += dp . col@@ w@@ ise ( ) . cross ( R@@ X@@ v_@@ col ) ; do@@ me@@ g@@ a_@@ part_@@ col -= d@@ v_@@ part_@@ col . col@@ w@@ ise ( ) . cross ( p ) ; set@@ Sub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( ret , do@@ me@@ g@@ a_@@ part_@@ col , X@@ om@@ eg@@ a_@@ rows , col@@ _@@ array , X . rows ( ) ) ; set@@ Sub@@ Matrix@@ Gradi@@ ent < Eigen :: Dynamic > ( ret , d@@ v_@@ part_@@ col , X@@ v_@@ rows , col@@ _@@ array , X . rows ( ) ) ; } return ret ; } template < typename Scalar > DL@@ LEXPORT void cy@@ lin@@ dri@@ cal@@ 2@@ car@@ te@@ si@@ an ( const Matrix < Scalar , 3 , 1 > & m_@@ cylinder@@ _@@ axis , const Matrix < Scalar , 3 , 1 > & m_@@ cylinder@@ _x@@ _dir , const Matrix < Scalar , 3 , 1 > & cylinder@@ _origin , const Matrix < Scalar , 6 , 1 > & x@@ _c@@ y@@ linder , const Matrix < Scalar , 6 , 1 > & v_@@ cy@@ linder , Matrix < Scalar , 6 , 1 > & x@@ _c@@ ar@@ te@@ si@@ an , Matrix < Scalar , 6 , 1 > & v_@@ car@@ te@@ si@@ an , Matrix < Scalar , 6 , 6 > & J , Matrix < Scalar , 6 , 1 > & J@@ do@@ tv ) { Matrix < Scalar , 3 , 1 > cylinder@@ _@@ axis = m_@@ cylinder@@ _@@ axis / m_@@ cylinder@@ _@@ axis . norm ( ) ; Matrix < Scalar , 3 , 1 > cylinder@@ _x@@ _dir = m_@@ cylinder@@ _x@@ _dir / m_@@ cylinder@@ _x@@ _dir . norm ( ) ; Matrix < Scalar , 3 , 3 > R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an ; R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an . col ( 0 ) = cylinder@@ _x@@ _dir ; R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an . col ( 1 ) = cylinder@@ _@@ axis . cross ( cylinder@@ _x@@ _dir ) ; R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an . col ( 2 ) = cylinder@@ _@@ axis ; double radius = x@@ _c@@ y@@ linder ( 0 ) ; double theta = x@@ _c@@ y@@ linder ( 1 ) ; double c_@@ theta = cos ( theta ) ; double s_@@ theta = sin ( theta ) ; double height = x@@ _c@@ y@@ linder ( 2 ) ; double r@@ adi@@ us_@@ dot = v_@@ cy@@ linder ( 0 ) ; double thet@@ a_@@ dot = v_@@ cy@@ linder ( 1 ) ; double he@@ igh@@ t_@@ dot = v_@@ cy@@ linder ( 2 ) ; Matrix < Scalar , 3 , 1 > x_@@ pos_@@ car@@ te@@ si@@ an ; x_@@ pos_@@ car@@ te@@ si@@ an << radius * c_@@ theta , radius * s_@@ theta , height ; x_@@ pos_@@ car@@ te@@ si@@ an = R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an * x_@@ pos_@@ car@@ te@@ si@@ an + cylinder@@ _origin ; Matrix < Scalar , 3 , 1 > v_@@ pos_@@ car@@ te@@ si@@ an ; v_@@ pos_@@ car@@ te@@ si@@ an << radius * - s_@@ theta * thet@@ a_@@ dot + r@@ adi@@ us_@@ dot * c_@@ theta , radius * c_@@ theta * thet@@ a_@@ dot + r@@ adi@@ us_@@ dot * s_@@ theta , he@@ igh@@ t_@@ dot ; v_@@ pos_@@ car@@ te@@ si@@ an = R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an * v_@@ pos_@@ car@@ te@@ si@@ an ; Vector@@ 3d x_r@@ p@@ y_@@ cy@@ linder = x@@ _c@@ y@@ linder . block ( 3 , 0 , 3 , 1 ) ; Matrix < Scalar , 3 , 3 > R_@@ t@@ ang@@ ent = r@@ py@@ 2@@ rot@@ mat ( x_r@@ p@@ y_@@ cy@@ linder ) ; Matrix < Scalar , 3 , 3 > R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder ; Matrix < Scalar , 3 , 3 > d@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder ; Matrix < Scalar , 3 , 3 > dd@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder ; rot@@ z ( theta - M_PI / 2 , R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder , d@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder , dd@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder ) ; Matrix < Scalar , 3 , 3 > d@@ R_@@ t@@ ang@@ ent@@ 2@@ cylinder@@ _d@@ theta = d@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder ; Matrix < Scalar , 3 , 3 > R@@ _c@@ y@@ linder = R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder * R_@@ t@@ ang@@ ent ; Matrix < Scalar , 3 , 3 > R@@ _c@@ ar@@ te@@ si@@ an = R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an * R@@ _c@@ y@@ linder ; Matrix < Scalar , 3 , 1 > x_r@@ p@@ y_@@ car@@ te@@ si@@ an = rot@@ mat@@ 2@@ r@@ py ( R@@ _c@@ ar@@ te@@ si@@ an ) ; x@@ _c@@ ar@@ te@@ si@@ an . block ( 0 , 0 , 3 , 1 ) = x_@@ pos_@@ car@@ te@@ si@@ an ; x@@ _c@@ ar@@ te@@ si@@ an . block ( 3 , 0 , 3 , 1 ) = x_r@@ p@@ y_@@ car@@ te@@ si@@ an ; v_@@ car@@ te@@ si@@ an . block ( 0 , 0 , 3 , 1 ) = v_@@ pos_@@ car@@ te@@ si@@ an ; v_@@ car@@ te@@ si@@ an . block ( 3 , 0 , 3 , 1 ) = thet@@ a_@@ dot * R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an . col ( 2 ) + R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an * R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder * v_@@ cy@@ linder . block ( 3 , 0 , 3 , 1 ) ; J = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; J . block ( 0 , 0 , 3 , 1 ) << c_@@ theta , s_@@ theta , 0 ; J . block ( 0 , 1 , 3 , 1 ) << radius * - s_@@ theta , radius * c_@@ theta , 0 ; J . block ( 0 , 2 , 3 , 1 ) << 0 , 0 , 1 ; J . block ( 0 , 0 , 3 , 3 ) = R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an * J . block ( 0 , 0 , 3 , 3 ) ; J . block ( 3 , 1 , 3 , 1 ) = R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an . col ( 2 ) ; J . block ( 3 , 3 , 3 , 3 ) = R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an * R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder ; Matrix < Scalar , 3 , 3 > d@@ J@@ 1@@ _d@@ radius = Matrix < Scalar , 3 , 3 > :: Zero ( ) ; d@@ J@@ 1@@ _d@@ radius ( 0 , 1 ) = - s_@@ theta ; d@@ J@@ 1@@ _d@@ radius ( 1 , 1 ) = c_@@ theta ; Matrix < Scalar , 3 , 3 > d@@ J@@ 1@@ _d@@ theta = Matrix < Scalar , 3 , 3 > :: Zero ( ) ; d@@ J@@ 1@@ _d@@ theta ( 0 , 0 ) = - s_@@ theta ; d@@ J@@ 1@@ _d@@ theta ( 0 , 1 ) = - radius * c_@@ theta ; d@@ J@@ 1@@ _d@@ theta ( 1 , 0 ) = c_@@ theta ; d@@ J@@ 1@@ _d@@ theta ( 1 , 1 ) = - radius * s_@@ theta ; J@@ do@@ tv . block ( 0 , 0 , 3 , 1 ) = R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an * ( d@@ J@@ 1@@ _d@@ radius * r@@ adi@@ us_@@ dot + d@@ J@@ 1@@ _d@@ theta * thet@@ a_@@ dot ) * v_@@ cy@@ linder . block ( 0 , 0 , 3 , 1 ) ; J@@ do@@ tv . block ( 3 , 0 , 3 , 1 ) = R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an * d@@ R_@@ t@@ ang@@ ent@@ 2@@ cylinder@@ _d@@ theta * thet@@ a_@@ dot * v_@@ cy@@ linder . block ( 3 , 0 , 3 , 1 ) ; } template < typename Scalar > DL@@ LEXPORT void car@@ te@@ si@@ an@@ 2@@ cy@@ lin@@ dri@@ cal ( const Eigen :: Matrix < Scalar , 3 , 1 > & m_@@ cylinder@@ _@@ axis , const Eigen :: Matrix < Scalar , 3 , 1 > & m_@@ cylinder@@ _x@@ _dir , const Eigen :: Matrix < Scalar , 3 , 1 > & cylinder@@ _origin , const Eigen :: Matrix < Scalar , 6 , 1 > & x@@ _c@@ ar@@ te@@ si@@ an , const Eigen :: Matrix < Scalar , 6 , 1 > & v_@@ car@@ te@@ si@@ an , Eigen :: Matrix < Scalar , 6 , 1 > & x@@ _c@@ y@@ linder , Eigen :: Matrix < Scalar , 6 , 1 > & v_@@ cy@@ linder , Eigen :: Matrix < Scalar , 6 , 6 > & J , Eigen :: Matrix < Scalar , 6 , 1 > & J@@ do@@ tv ) { Matrix < Scalar , 3 , 1 > cylinder@@ _@@ axis = m_@@ cylinder@@ _@@ axis / m_@@ cylinder@@ _@@ axis . norm ( ) ; Matrix < Scalar , 3 , 1 > cylinder@@ _x@@ _dir = m_@@ cylinder@@ _x@@ _dir / m_@@ cylinder@@ _x@@ _dir . norm ( ) ; Matrix < Scalar , 3 , 3 > R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an ; R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an . col ( 0 ) = cylinder@@ _x@@ _dir ; R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an . col ( 1 ) = cylinder@@ _@@ axis . cross ( cylinder@@ _x@@ _dir ) ; R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an . col ( 2 ) = cylinder@@ _@@ axis ; Matrix < Scalar , 3 , 3 > R@@ _c@@ ar@@ te@@ si@@ an@@ 2@@ cy@@ linder = R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an . transpose ( ) ; Matrix < Scalar , 3 , 1 > x_@@ pos_@@ cy@@ linder = R@@ _c@@ ar@@ te@@ si@@ an@@ 2@@ cy@@ linder * ( x@@ _c@@ ar@@ te@@ si@@ an . block ( 0 , 0 , 3 , 1 ) - cylinder@@ _origin ) ; Matrix < Scalar , 3 , 1 > v_@@ pos_@@ cy@@ linder = R@@ _c@@ ar@@ te@@ si@@ an@@ 2@@ cy@@ linder * v_@@ car@@ te@@ si@@ an . block ( 0 , 0 , 3 , 1 ) ; double radius = sqrt ( pow ( x_@@ pos_@@ cy@@ linder ( 0 ) , 2 ) + pow ( x_@@ pos_@@ cy@@ linder ( 1 ) , 2 ) ) ; double r@@ adi@@ us_@@ dot = ( x_@@ pos_@@ cy@@ linder ( 0 ) * v_@@ pos_@@ cy@@ linder ( 0 ) + x_@@ pos_@@ cy@@ linder ( 1 ) * v_@@ pos_@@ cy@@ linder ( 1 ) ) / radius ; double theta = atan@@ 2 ( x_@@ pos_@@ cy@@ linder ( 1 ) , x_@@ pos_@@ cy@@ linder ( 0 ) ) ; double r@@ adi@@ us_@@ squ@@ are = pow ( radius , 2 ) ; double r@@ adi@@ us_@@ cubic = pow ( radius , 3 ) ; double r@@ adi@@ us_@@ quad = pow ( radius , 4 ) ; double thet@@ a_@@ dot = ( - x_@@ pos_@@ cy@@ linder ( 1 ) * v_@@ pos_@@ cy@@ linder ( 0 ) + x_@@ pos_@@ cy@@ linder ( 0 ) * v_@@ pos_@@ cy@@ linder ( 1 ) ) / r@@ adi@@ us_@@ squ@@ are ; double height = x_@@ pos_@@ cy@@ linder ( 2 ) ; double he@@ igh@@ t_@@ dot = v_@@ pos_@@ cy@@ linder ( 2 ) ; x@@ _c@@ y@@ linder ( 0 ) = radius ; x@@ _c@@ y@@ linder ( 1 ) = theta ; x@@ _c@@ y@@ linder ( 2 ) = height ; v_@@ cy@@ linder ( 0 ) = r@@ adi@@ us_@@ dot ; v_@@ cy@@ linder ( 1 ) = thet@@ a_@@ dot ; v_@@ cy@@ linder ( 2 ) = he@@ igh@@ t_@@ dot ; Matrix < Scalar , 3 , 3 > R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder ; Matrix < Scalar , 3 , 3 > d@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder ; Matrix < Scalar , 3 , 3 > dd@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder ; rot@@ z ( theta - M_PI / 2 , R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder , d@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder , dd@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder ) ; Matrix < Scalar , 3 , 3 > R@@ _c@@ y@@ linder@@ 2@@ t@@ ang@@ ent = R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder . transpose ( ) ; Vector@@ 3d x_r@@ p@@ y_@@ car@@ te@@ si@@ an = x@@ _c@@ ar@@ te@@ si@@ an . block ( 3 , 0 , 3 , 1 ) ; Matrix < Scalar , 3 , 3 > R@@ _c@@ ar@@ te@@ si@@ an = r@@ py@@ 2@@ rot@@ mat ( x_r@@ p@@ y_@@ car@@ te@@ si@@ an ) ; x@@ _c@@ y@@ linder . block ( 3 , 0 , 3 , 1 ) = rot@@ mat@@ 2@@ r@@ py ( R@@ _c@@ y@@ linder@@ 2@@ t@@ ang@@ ent * R@@ _c@@ ar@@ te@@ si@@ an@@ 2@@ cy@@ linder * R@@ _c@@ ar@@ te@@ si@@ an ) ; J = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; Matrix < Scalar , 6 , 6 > J@@ dot = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; J ( 0 , 0 ) = x_@@ pos_@@ cy@@ linder ( 0 ) / radius ; J ( 0 , 1 ) = x_@@ pos_@@ cy@@ linder ( 1 ) / radius ; J ( 1 , 0 ) = - x_@@ pos_@@ cy@@ linder ( 1 ) / r@@ adi@@ us_@@ squ@@ are ; J ( 1 , 1 ) = x_@@ pos_@@ cy@@ linder ( 0 ) / r@@ adi@@ us_@@ squ@@ are ; J ( 2 , 2 ) = 1.0 ; J . block ( 0 , 0 , 3 , 3 ) = J . block ( 0 , 0 , 3 , 3 ) * R@@ _c@@ ar@@ te@@ si@@ an@@ 2@@ cy@@ linder ; J@@ dot ( 0 , 0 ) = pow ( x_@@ pos_@@ cy@@ linder ( 1 ) , 2 ) / r@@ adi@@ us_@@ cubic * v_@@ pos_@@ cy@@ linder ( 0 ) - x_@@ pos_@@ cy@@ linder ( 0 ) * x_@@ pos_@@ cy@@ linder ( 1 ) / r@@ adi@@ us_@@ cubic * v_@@ pos_@@ cy@@ linder ( 1 ) ; J@@ dot ( 0 , 1 ) = - x_@@ pos_@@ cy@@ linder ( 0 ) * x_@@ pos_@@ cy@@ linder ( 1 ) / r@@ adi@@ us_@@ cubic * v_@@ pos_@@ cy@@ linder ( 0 ) + pow ( x_@@ pos_@@ cy@@ linder ( 0 ) , 2 ) / r@@ adi@@ us_@@ cubic * v_@@ pos_@@ cy@@ linder ( 1 ) ; J@@ dot ( 1 , 0 ) = 2 * x_@@ pos_@@ cy@@ linder ( 0 ) * x_@@ pos_@@ cy@@ linder ( 1 ) / r@@ adi@@ us_@@ quad * v_@@ pos_@@ cy@@ linder ( 0 ) + ( pow ( x_@@ pos_@@ cy@@ linder ( 1 ) , 2 ) - pow ( x_@@ pos_@@ cy@@ linder ( 0 ) , 2 ) ) / r@@ adi@@ us_@@ quad * v_@@ pos_@@ cy@@ linder ( 1 ) ; J@@ dot ( 1 , 1 ) = ( pow ( x_@@ pos_@@ cy@@ linder ( 1 ) , 2 ) - pow ( x_@@ pos_@@ cy@@ linder ( 0 ) , 2 ) ) / r@@ adi@@ us_@@ quad * v_@@ pos_@@ cy@@ linder ( 0 ) - 2 * x_@@ pos_@@ cy@@ linder ( 0 ) * x_@@ pos_@@ cy@@ linder ( 1 ) / r@@ adi@@ us_@@ quad * v_@@ pos_@@ cy@@ linder ( 1 ) ; J@@ dot . block ( 0 , 0 , 3 , 3 ) = J@@ dot . block ( 0 , 0 , 3 , 3 ) * R@@ _c@@ ar@@ te@@ si@@ an@@ 2@@ cy@@ linder ; v_@@ cy@@ linder . block ( 3 , 0 , 3 , 1 ) = R@@ _c@@ y@@ linder@@ 2@@ t@@ ang@@ ent * R@@ _c@@ ar@@ te@@ si@@ an@@ 2@@ cy@@ linder * v_@@ car@@ te@@ si@@ an . block ( 3 , 0 , 3 , 1 ) - thet@@ a_@@ dot * R@@ _c@@ y@@ linder@@ 2@@ t@@ ang@@ ent . col ( 2 ) ; J . block ( 3 , 0 , 3 , 3 ) = R@@ _c@@ y@@ linder@@ 2@@ t@@ ang@@ ent . col ( 2 ) * - J . block ( 1 , 0 , 1 , 3 ) ; J . block ( 3 , 3 , 3 , 3 ) = R@@ _c@@ y@@ linder@@ 2@@ t@@ ang@@ ent * R@@ _c@@ ar@@ te@@ si@@ an@@ 2@@ cy@@ linder ; J@@ dot . block ( 3 , 0 , 3 , 3 ) = d@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder . row ( 2 ) . transpose ( ) * - J . block ( 1 , 0 , 1 , 3 ) * thet@@ a_@@ dot + R@@ _c@@ y@@ linder@@ 2@@ t@@ ang@@ ent . col ( 2 ) * - J@@ dot . block ( 1 , 0 , 1 , 3 ) ; J@@ dot . block ( 3 , 3 , 3 , 3 ) = d@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder . transpose ( ) * thet@@ a_@@ dot * R@@ _c@@ ar@@ te@@ si@@ an@@ 2@@ cy@@ linder ; J@@ do@@ tv = J@@ dot * v_@@ car@@ te@@ si@@ an ; } DL@@ LEXPORT Gradient@@ Var < double , 3 , 1 > qu@@ at@@ 2@@ exp@@ map ( const Ref < const Vector@@ 4@@ d > & q , int gradi@@ ent_@@ order ) { double t = sqrt ( 1 - q ( 0 ) * q ( 0 ) ) ; bool is_@@ de@@ generate = ( t * t < std :: numer@@ ic@@ _@@ limits < double > :: epsilon ( ) ) ; double s = is_@@ de@@ generate ? 2.0 : 2.0 * ac@@ os ( q ( 0 ) ) / t ; Gradient@@ Var < double , 3 , 1 > ret ( 3 , 1 , 4 , gradi@@ ent_@@ order ) ; ret . value ( ) = s * q . tail ( 3 ) ; if ( gradi@@ ent_@@ order > 0 ) { ret . gradi@@ ent ( ) . value ( ) = Matrix < double , 3 , 4 > :: Zero ( ) ; double dsd@@ q1 = is_@@ de@@ generate ? 0.0 : ( - 2 * t + 2 * ac@@ os ( q ( 0 ) ) * q ( 0 ) ) / pow ( t , 3 ) ; ret . gradi@@ ent ( ) . value ( ) . col ( 0 ) = q . tail ( 3 ) * dsd@@ q1 ; ret . gradi@@ ent ( ) . value ( ) . block ( 0 , 1 , 3 , 3 ) = Matrix@@ 3d :: Identity ( ) * s ; } else if ( gradi@@ ent_@@ order > 1 ) { throw std :: runtime_error ( " gradi@@ ent _ order > 1 ▁ is ▁ not ▁ supported ▁ in ▁ qu@@ at@@ 2@@ exp@@ map " ) ; } return ret ; } DL@@ LEXPORT Gradient@@ Var < double , 3 , 1 > flip@@ Exp@@ map ( const Ref < const Vector@@ 3d > & exp@@ map , int gradi@@ ent_@@ order ) { if ( gradi@@ ent_@@ order > 1 ) { throw std :: runtime_error ( " gradi@@ ent _ order > 1 ▁ is ▁ not ▁ supported ▁ in ▁ flip@@ Exp@@ map " ) ; } double exp@@ map_@@ norm = exp@@ map . norm ( ) ; bool is_@@ de@@ generate = ( exp@@ map_@@ norm < std :: numer@@ ic@@ _@@ limits < double > :: epsilon ( ) ) ; Gradient@@ Var < double , 3 , 1 > ret ( 3 , 1 , 3 , gradi@@ ent_@@ order ) ; Matrix@@ 3d e@@ ye@@ 3 = Matrix@@ 3d :: Identity ( ) ; if ( is_@@ de@@ generate ) { ret . value ( ) = exp@@ map ; if ( gradi@@ ent_@@ order > 0 ) { ret . gradi@@ ent ( ) . value ( ) = e@@ ye@@ 3 ; } } else { ret . value ( ) = exp@@ map - exp@@ map / exp@@ map_@@ norm * 2 * M_PI ; if ( gradi@@ ent_@@ order > 0 ) { ret . gradi@@ ent ( ) . value ( ) = e@@ ye@@ 3 - ( exp@@ map_@@ norm * exp@@ map_@@ norm * e@@ ye@@ 3 - exp@@ map * exp@@ map . transpose ( ) ) / pow ( exp@@ map_@@ norm , 3 ) * 2 * M_PI ; } } return ret ; } DL@@ LEXPORT Gradient@@ Var < double , 3 , 1 > un@@ w@@ rap@@ Exp@@ map ( const Ref < const Vector@@ 3d > & exp@@ map@@ 1 , const Ref < const Vector@@ 3d > & exp@@ map@@ 2 , int gradi@@ ent_@@ order ) { auto exp@@ map@@ 2_@@ f@@ lip = flip@@ Exp@@ map ( exp@@ map@@ 2 , gradi@@ ent_@@ order ) ; double distance@@ 1 = ( exp@@ map@@ 1 - exp@@ map@@ 2 ) . squaredNor@@ m ( ) ; double distance@@ 2 = ( exp@@ map@@ 1 - exp@@ map@@ 2_@@ f@@ lip . value ( ) ) . squaredNor@@ m ( ) ; if ( distance@@ 1 > distance@@ 2 ) { return exp@@ map@@ 2_@@ f@@ lip ; } else { Gradient@@ Var < double , 3 , 1 > ret ( 3 , 1 , 3 , gradi@@ ent_@@ order ) ; ret . value ( ) = exp@@ map@@ 2 ; if ( gradi@@ ent_@@ order > 0 ) { ret . gradi@@ ent ( ) . value ( ) = Matrix@@ 3d :: Identity ( ) ; } return ret ; } } void qu@@ at@@ 2@@ exp@@ map@@ Sequence ( const Ref < const Matrix < double , 4 , Dynamic >> & quat , const Ref < const Matrix < double , 4 , Dynamic >> & qu@@ at@@ _@@ dot , Ref < Matrix < double , 3 , Dynamic >> exp@@ map , Ref < Matrix < double , 3 , Dynamic >> exp@@ map_@@ dot ) { D@@ en@@ se@@ Index N = quat . cols ( ) ; if ( qu@@ at@@ _@@ dot . cols ( ) != N ) { throw std :: runtime_error ( " quat _ dot ▁ must ▁ have ▁ the ▁ same ▁ number ▁ of ▁ columns ▁ as ▁ quat ▁ in ▁ qu@@ at@@ 2@@ exp@@ map@@ Sequence " ) ; } exp@@ map . resize ( 3 , N ) ; exp@@ map_@@ dot . resize ( 3 , N ) ; for ( int i = 0 ; i < N ; i ++ ) { auto exp@@ map_@@ gra@@ d = qu@@ at@@ 2@@ exp@@ map ( quat . col ( i ) , 1 ) ; exp@@ map . col ( i ) = exp@@ map_@@ gra@@ d . value ( ) ; exp@@ map_@@ dot . col ( i ) = exp@@ map_@@ gra@@ d . gradi@@ ent ( ) . value ( ) * qu@@ at@@ _@@ dot . col ( i ) ; if ( i >= 1 ) { auto close@@ st_@@ gra@@ d = close@@ st@@ Exp@@ map ( exp@@ map . col ( i - 1 ) , exp@@ map . col ( i ) , 1 ) ; exp@@ map . col ( i ) = close@@ st_@@ gra@@ d . value ( ) ; exp@@ map_@@ dot . col ( i ) = close@@ st_@@ gra@@ d . gradi@@ ent ( ) . value ( ) * exp@@ map_@@ dot . col ( i ) ; } } } DL@@ LEXPORT Gradient@@ Var < double , 3 , 1 > close@@ st@@ Exp@@ map ( const Ref < const Vector@@ 3d > & exp@@ map@@ 1 , const Ref < const Vector@@ 3d > & exp@@ map@@ 2 , int gradi@@ ent_@@ order ) { if ( gradi@@ ent_@@ order > 1 ) { throw std :: runtime_error ( " close@@ st@@ Exp@@ map ▁ only ▁ supports ▁ first ▁ order ▁ gradi@@ ent " ) ; } double exp@@ map@@ 1_@@ norm = exp@@ map@@ 1 . norm ( ) ; double exp@@ map@@ 2_@@ norm = exp@@ map@@ 2 . norm ( ) ; Gradient@@ Var < double , 3 , 1 > ret ( 3 , 1 , 3 , gradi@@ ent_@@ order ) ; if ( exp@@ map@@ 2_@@ norm < std :: numer@@ ic@@ _@@ limits < double > :: epsilon ( ) ) { if ( exp@@ map@@ 1_@@ norm > std :: numer@@ ic@@ _@@ limits < double > :: epsilon ( ) ) { Vector@@ 3d exp@@ map@@ 1_@@ axis = exp@@ map@@ 1 / exp@@ map@@ 1_@@ norm ; int exp@@ map@@ 1_@@ round = static_cast < int > ( exp@@ map@@ 1_@@ norm / ( 2 * M_PI ) + 0.5 ) ; ret . value ( ) = exp@@ map@@ 1_@@ axis * exp@@ map@@ 1_@@ round * 2 * M_PI ; if ( ret . has@@ Gradi@@ ent ( ) ) { ret . gradi@@ ent ( ) . value ( ) = Matrix@@ 3d :: Zero ( ) ; } return ret ; } else { ret . value ( ) = exp@@ map@@ 2 ; if ( ret . has@@ Gradi@@ ent ( ) ) { ret . gradi@@ ent ( ) . value ( ) = Matrix@@ 3d :: Identity ( ) ; } } } else { Vector@@ 3d exp@@ map@@ 2_@@ axis = exp@@ map@@ 2 / exp@@ map@@ 2_@@ norm ; Matrix@@ 3d dex@@ pmap@@ 2_@@ ax@@ is_@@ dex@@ pmap@@ 2 = ( exp@@ map@@ 2_@@ norm * Matrix@@ 3d :: Identity ( ) - exp@@ map@@ 2 * exp@@ map@@ 2 . transpose ( ) / exp@@ map@@ 2_@@ norm ) / pow ( exp@@ map@@ 2_@@ norm , 2 ) ; double exp@@ map@@ 2_@@ close@@ st_@@ k = ( exp@@ map@@ 2_@@ axis . transpose ( ) * exp@@ map@@ 1 - exp@@ map@@ 2_@@ norm ) / ( 2 * M_PI ) ; int exp@@ map@@ 2_@@ close@@ st_@@ k1 ; int exp@@ map@@ 2_@@ close@@ st_@@ k2 ; if ( exp@@ map@@ 2_@@ close@@ st_@@ k > 0 ) { exp@@ map@@ 2_@@ close@@ st_@@ k1 = ( int ) exp@@ map@@ 2_@@ close@@ st_@@ k ; } else { exp@@ map@@ 2_@@ close@@ st_@@ k1 = ( int ) exp@@ map@@ 2_@@ close@@ st_@@ k - 1 ; } exp@@ map@@ 2_@@ close@@ st_@@ k2 = exp@@ map@@ 2_@@ close@@ st_@@ k1 + 1 ; Vector@@ 3d exp@@ map@@ 2_@@ close@@ st1 = exp@@ map@@ 2 + 2 * exp@@ map@@ 2_@@ close@@ st_@@ k1 * M_PI * exp@@ map@@ 2_@@ axis ; Vector@@ 3d exp@@ map@@ 2_@@ close@@ st2 = exp@@ map@@ 2 + 2 * exp@@ map@@ 2_@@ close@@ st_@@ k2 * M_PI * exp@@ map@@ 2_@@ axis ; if ( ( exp@@ map@@ 2_@@ close@@ st1 - exp@@ map@@ 1 ) . norm ( ) < ( exp@@ map@@ 2_@@ close@@ st2 - exp@@ map@@ 1 ) . norm ( ) ) { ret . value ( ) = exp@@ map@@ 2_@@ close@@ st1 ; if ( ret . has@@ Gradi@@ ent ( ) ) { ret . gradi@@ ent ( ) . value ( ) = Matrix@@ 3d :: Identity ( ) + 2 * dex@@ pmap@@ 2_@@ ax@@ is_@@ dex@@ pmap@@ 2 * ( double ) exp@@ map@@ 2_@@ close@@ st_@@ k1 * M_PI ; } return ret ; } else { ret . value ( ) = exp@@ map@@ 2_@@ close@@ st2 ; if ( ret . has@@ Gradi@@ ent ( ) ) { ret . gradi@@ ent ( ) . value ( ) = Matrix@@ 3d :: Identity ( ) + 2 * dex@@ pmap@@ 2_@@ ax@@ is_@@ dex@@ pmap@@ 2 * ( double ) exp@@ map@@ 2_@@ close@@ st_@@ k2 * M_PI ; } return ret ; } } return ret ; } template DL@@ LEXPORT void normalize@@ Vec ( const Matrix@@ Base < Vector@@ 3d > & x , Vector@@ 3d & x_@@ norm , Gradi@@ ent < Vector@@ 3d , 3 , 1 > :: type * , Gradi@@ ent < Vector@@ 3d , 3 , 2 > :: type * ) ; template DL@@ LEXPORT void normalize@@ Vec ( const Matrix@@ Base < Vector@@ 4@@ d > & x , Vector@@ 4@@ d & x_@@ norm , Gradi@@ ent < Vector@@ 4@@ d , 4 , 1 > :: type * , Gradi@@ ent < Vector@@ 4@@ d , 4 , 2 > :: type * ) ; template DL@@ LEXPORT void normalize@@ Vec ( const Matrix@@ Base < Map < Vector@@ 4@@ d > > & x , Vector@@ 4@@ d & x_@@ norm , Gradi@@ ent < Vector@@ 4@@ d , 4 , 1 > :: type * , Gradi@@ ent < Vector@@ 4@@ d , 4 , 2 > :: type * ) ; template DL@@ LEXPORT void normalize@@ Vec ( const Matrix@@ Base < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: In@@ ner@@ Str@@ ide < 1 > > const , 4 , 1 , false > > & x , Vector@@ 4@@ d & x_@@ norm , Gradi@@ ent < Vector@@ 4@@ d , 4 , 1 > :: type * , Gradi@@ ent < Vector@@ 4@@ d , 4 , 2 > :: type * ) ; template DL@@ LEXPORT Vector@@ 4@@ d qu@@ at@@ 2@@ axis ( const Matrix@@ Base < Vector@@ 4@@ d > & ) ; template DL@@ LEXPORT Matrix@@ 3d qu@@ at@@ 2@@ rot@@ mat ( const Matrix@@ Base < Vector@@ 4@@ d > & q ) ; template DL@@ LEXPORT Matrix@@ 3d qu@@ at@@ 2@@ rot@@ mat ( const Matrix@@ Base < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: In@@ ner@@ Str@@ ide < 1 > > const , 4 , 1 , false > > & q ) ; template DL@@ LEXPORT Matrix < Map < Matrix < double , 4 , 1 , 0 , 4 , 1 > const , 0 , Str@@ ide < 0 , 0 > > :: Scalar , 3 , 3 , 0 , 3 , 3 > qu@@ at@@ 2@@ rot@@ mat < Map < Matrix < double , 4 , 1 , 0 , 4 , 1 > const , 0 , Str@@ ide < 0 , 0 > > > ( Matrix@@ Base < Map < Matrix < double , 4 , 1 , 0 , 4 , 1 > const , 0 , Str@@ ide < 0 , 0 > > > const & ) ; template DL@@ LEXPORT Vector@@ 3d qu@@ at@@ 2@@ r@@ py ( const Matrix@@ Base < Vector@@ 4@@ d > & ) ; template DL@@ LEXPORT Vector@@ 4@@ d axis@@ 2@@ quat ( const Matrix@@ Base < Vector@@ 4@@ d > & ) ; template DL@@ LEXPORT Matrix@@ 3d axis@@ 2@@ rot@@ mat ( const Matrix@@ Base < Vector@@ 4@@ d > & ) ; template DL@@ LEXPORT Vector@@ 3d axis@@ 2@@ r@@ py ( const Matrix@@ Base < Vector@@ 4@@ d > & ) ; template DL@@ LEXPORT Vector@@ 4@@ d rot@@ mat@@ 2@@ axis ( const Matrix@@ Base < Matrix@@ 3d > & ) ; template DL@@ LEXPORT Vector@@ 4@@ d rot@@ mat@@ 2@@ quat ( const Matrix@@ Base < Matrix@@ 3d > & ) ; template DL@@ LEXPORT Vector@@ 3d rot@@ mat@@ 2@@ r@@ py ( const Matrix@@ Base < Matrix@@ 3d > & ) ; template DL@@ LEXPORT Eigen :: Matrix < Eigen :: Block < Eigen :: Matrix < double , 4 , 4 , 0 , 4 , 4 > , 3 , 3 , false > :: Scalar , - 1 , 1 , 0 , - 1 , 1 > rot@@ mat@@ 2@@ Re@@ presentation < Eigen :: Block < Eigen :: Matrix < double , 4 , 4 , 0 , 4 , 4 > , 3 , 3 , false > > ( Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , 4 , 4 , 0 , 4 , 4 > , 3 , 3 , false > > const & , int ) ; template DL@@ LEXPORT Gradient@@ Var < double , Eigen :: Dynamic , 1 > rot@@ mat@@ 2@@ Re@@ presentation ( const Gradient@@ Var < double , SP@@ ACE_@@ DIMEN@@ SION , SP@@ ACE_@@ DIMEN@@ SION > & R , int rot@@ ation@@ _type ) ; template DL@@ LEXPORT Gradient@@ Var < double , QU@@ AT_@@ SIZE , 1 > exp@@ map@@ 2@@ quat ( const Matrix@@ Base < Vector@@ 3d > & v , const int gradi@@ ent_@@ order ) ; template DL@@ LEXPORT Gradient@@ Var < double , QU@@ AT_@@ SIZE , 1 > exp@@ map@@ 2@@ quat ( const Matrix@@ Base < Map < Vector@@ 3d >> & v , const int gradi@@ ent_@@ order ) ; template DL@@ LEXPORT Gradient@@ Var < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > :: Scalar , 4 , 1 > exp@@ map@@ 2@@ quat < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > > ( Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > > const & , int ) ; template DL@@ LEXPORT Vector@@ 4@@ d r@@ py@@ 2@@ axis ( const Eigen :: Matrix@@ Base < Vector@@ 3d > & ) ; template DL@@ LEXPORT Vector@@ 4@@ d r@@ py@@ 2@@ quat ( const Eigen :: Matrix@@ Base < Vector@@ 3d > & ) ; template DL@@ LEXPORT Matrix@@ 3d r@@ py@@ 2@@ rot@@ mat ( const Eigen :: Matrix@@ Base < Vector@@ 3d > & ) ; template DL@@ LEXPORT Matrix@@ 3d r@@ py@@ 2@@ rot@@ mat ( const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: In@@ ner@@ Str@@ ide < 1 > > const , 3 , 1 , false >> & ) ; template DL@@ LEXPORT Matrix < double , 9 , 3 > dr@@ py@@ 2@@ rot@@ mat ( const Eigen :: Matrix@@ Base < Vector@@ 3d > & ) ; template DL@@ LEXPORT Matrix < double , 9 , 3 > dr@@ py@@ 2@@ rot@@ mat ( const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: In@@ ner@@ Str@@ ide < 1 > > const , 3 , 1 , false >> & ) ; template DL@@ LEXPORT Vector@@ 4@@ d qu@@ at@@ 2@@ axis ( const Matrix@@ Base < Map < Vector@@ 4@@ d > > & ) ; template DL@@ LEXPORT Matrix@@ 3d qu@@ at@@ 2@@ rot@@ mat ( const Matrix@@ Base < Map < Vector@@ 4@@ d > > & q ) ; template DL@@ LEXPORT Vector@@ 3d qu@@ at@@ 2@@ r@@ py ( const Matrix@@ Base < Map < Vector@@ 4@@ d > > & ) ; template DL@@ LEXPORT Vector@@ 4@@ d axis@@ 2@@ quat ( const Matrix@@ Base < Map < Vector@@ 4@@ d > > & ) ; template DL@@ LEXPORT Matrix@@ 3d axis@@ 2@@ rot@@ mat ( const Matrix@@ Base < Map < Vector@@ 4@@ d > > & ) ; template DL@@ LEXPORT Vector@@ 3d axis@@ 2@@ r@@ py ( const Matrix@@ Base < Map < Vector@@ 4@@ d > > & ) ; template DL@@ LEXPORT Vector@@ 4@@ d rot@@ mat@@ 2@@ axis ( const Matrix@@ Base < Map < Matrix@@ 3d > > & ) ; template DL@@ LEXPORT Vector@@ 4@@ d rot@@ mat@@ 2@@ quat ( const Matrix@@ Base < Map < Matrix@@ 3d > > & ) ; template DL@@ LEXPORT Vector@@ 3d rot@@ mat@@ 2@@ r@@ py ( const Matrix@@ Base < Map < Matrix@@ 3d > > & ) ; template DL@@ LEXPORT Vector@@ 4@@ d r@@ py@@ 2@@ axis ( const Eigen :: Matrix@@ Base < Map < Vector@@ 3d > > & ) ; template DL@@ LEXPORT Vector@@ 4@@ d r@@ py@@ 2@@ quat ( const Eigen :: Matrix@@ Base < Map < Vector@@ 3d > > & ) ; template DL@@ LEXPORT Matrix@@ 3d r@@ py@@ 2@@ rot@@ mat ( const Eigen :: Matrix@@ Base < Map < Vector@@ 3d > > & ) ; template DL@@ LEXPORT Matrix < double , 9 , 3 > dr@@ py@@ 2@@ rot@@ mat ( const Eigen :: Matrix@@ Base < Map < Vector@@ 3d > > & ) ; template DL@@ LEXPORT Matrix < Block < Matrix@@ 4@@ d const , 3 , 3 , false > :: Scalar , 4 , 1 , 0 , 4 , 1 > rot@@ mat@@ 2@@ quat < Block < Matrix@@ 4@@ d const , 3 , 3 , false > > ( Matrix@@ Base < Block < Matrix@@ 4@@ d const , 3 , 3 , false > > const & ) ; template DL@@ LEXPORT Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , Eigen :: Dynamic > transform@@ Sp@@ ati@@ al@@ Mo@@ tion ( const Eigen :: Is@@ ometr@@ y@@ 3d & , const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , Eigen :: Dynamic > > & ) ; template DL@@ LEXPORT Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , 1 > transform@@ Sp@@ ati@@ al@@ Mo@@ tion ( const Eigen :: Is@@ ometr@@ y@@ 3d & , const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , 1 > > & ) ; template DL@@ LEXPORT Transform@@ Sp@@ ati@@ al < MatrixXd > :: type transform@@ Sp@@ ati@@ al@@ Mo@@ tion < MatrixXd > ( const Eigen :: Is@@ ometr@@ y@@ 3d & , const Eigen :: Matrix@@ Base < MatrixXd > & ) ; template DL@@ LEXPORT Transform@@ Sp@@ ati@@ al < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 6 , - 1 , false > > :: type transform@@ Sp@@ ati@@ al@@ Mo@@ tion ( const Eigen :: Is@@ ometr@@ y@@ 3d & T , const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 6 , - 1 , false > > & M ) ; template DL@@ LEXPORT Transform@@ Sp@@ ati@@ al < Matrix < double , TW@@ IS@@ T_@@ SIZE , Eigen :: Dynamic > > :: type transform@@ Sp@@ ati@@ al@@ For@@ ce < Matrix < double , TW@@ IS@@ T_@@ SIZE , Eigen :: Dynamic >> ( const Eigen :: Is@@ ometr@@ y@@ 3d & , const Eigen :: Matrix@@ Base < Matrix < double , TW@@ IS@@ T_@@ SIZE , Eigen :: Dynamic > > & ) ; template DL@@ LEXPORT Transform@@ Sp@@ ati@@ al < MatrixXd > :: type transform@@ Sp@@ ati@@ al@@ For@@ ce < MatrixXd > ( const Eigen :: Is@@ ometr@@ y@@ 3d & , const Eigen :: Matrix@@ Base < MatrixXd > & ) ; template DL@@ LEXPORT Transform@@ Sp@@ ati@@ al < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 6 , - 1 , true >> :: type transform@@ Sp@@ ati@@ al@@ For@@ ce ( const Eigen :: Is@@ ometr@@ y@@ 3d & , const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 6 , - 1 , true > > & ) ; template DL@@ LEXPORT Transform@@ Sp@@ ati@@ al < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > :: type transform@@ Sp@@ ati@@ al@@ For@@ ce ( const Eigen :: Is@@ ometr@@ y@@ 3d & , const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & ) ; template DL@@ LEXPORT Transform@@ Sp@@ ati@@ al < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > const , 6 , 1 , true > > :: type transform@@ Sp@@ ati@@ al@@ For@@ ce ( const Eigen :: Transform < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > const , 6 , 1 , true > :: Scalar , 3 , 1 , 0 > & , const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > const , 6 , 1 , true > > & ) ; template DL@@ LEXPORT Transform@@ Sp@@ ati@@ al < Map < Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 0 , Str@@ ide < 0 , 0 > > > :: type transform@@ Sp@@ ati@@ al@@ For@@ ce < Map < Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 0 , Str@@ ide < 0 , 0 > >> ( const Eigen :: Is@@ ometr@@ y@@ 3d & , const Eigen :: Matrix@@ Base < Map < Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 0 , Str@@ ide < 0 , 0 > > > & ) ; template DL@@ LEXPORT Gradient@@ Var < double , TW@@ IS@@ T_@@ SIZE , TW@@ IS@@ T_@@ SIZE > transform@@ Sp@@ ati@@ al@@ Inerti@@ a ( const Eigen :: Transform < double , SP@@ ACE_@@ DIMEN@@ SION , Eigen :: Isometry > & T_@@ current_@@ to_@@ new , const Gradi@@ ent < Eigen :: Transform < double , SP@@ ACE_@@ DIMEN@@ SION , Eigen :: Isometry > :: MatrixType , Eigen :: Dynamic > :: type * d@@ T_@@ current_@@ to_@@ new , const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , TW@@ IS@@ T_@@ SIZE > > & I ) ; template DL@@ LEXPORT Gradient@@ Var < double , TW@@ IS@@ T_@@ SIZE , TW@@ IS@@ T_@@ SIZE > transform@@ Sp@@ ati@@ al@@ Inerti@@ a ( const Eigen :: Transform < double , SP@@ ACE_@@ DIMEN@@ SION , Eigen :: Isometry > & T_@@ current_@@ to_@@ new , const Gradi@@ ent < Eigen :: Transform < double , SP@@ ACE_@@ DIMEN@@ SION , Eigen :: Isometry > :: MatrixType , Eigen :: Dynamic > :: type * d@@ T_@@ current_@@ to_@@ new , const Eigen :: Matrix@@ Base < Eigen :: MatrixXd > & I ) ; template DL@@ LEXPORT Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , Eigen :: Dynamic > d@@ Cross@@ Sp@@ ati@@ al@@ Mo@@ tion ( const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & a , const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & b , const Gradi@@ ent < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Dynamic > :: type & da , const Gradi@@ ent < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Dynamic > :: type & db ) ; template DL@@ LEXPORT Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , Eigen :: Dynamic > d@@ Cross@@ Sp@@ ati@@ al@@ For@@ ce ( const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & a , const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & b , const Gradi@@ ent < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Dynamic > :: type & da , const Gradi@@ ent < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Dynamic > :: type & db ) ; template DL@@ LEXPORT Gradi@@ ent < Matrix@@ 3d , QU@@ AT_@@ SIZE > :: type d@@ qu@@ at@@ 2@@ rot@@ mat ( const Eigen :: Matrix@@ Base < Vector@@ 4@@ d > & ) ; template DL@@ LEXPORT Gradi@@ ent < Matrix@@ 3d , QU@@ AT_@@ SIZE > :: type d@@ qu@@ at@@ 2@@ rot@@ mat ( const Eigen :: Matrix@@ Base < Map < Vector@@ 4@@ d > > & ) ; template DL@@ LEXPORT Gradi@@ ent < Matrix@@ 3d , QU@@ AT_@@ SIZE > :: type d@@ qu@@ at@@ 2@@ rot@@ mat ( const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: In@@ ner@@ Str@@ ide < 1 > > const , 4 , 1 , false > > & ) ; template DL@@ LEXPORT Gradi@@ ent < Vector@@ 3d , Dynamic > :: type d@@ rot@@ mat@@ 2@@ r@@ py ( const Eigen :: Matrix@@ Base < Matrix@@ 3d > & , const Eigen :: Matrix@@ Base < Matrix < double , Ro@@ tmat@@ Size , Dynamic > > & ) ; template DL@@ LEXPORT Gradi@@ ent < Vector@@ 3d , 6 > :: type d@@ rot@@ mat@@ 2@@ r@@ py ( const Eigen :: Matrix@@ Base < Matrix@@ 3d > & , const Eigen :: Matrix@@ Base < Matrix < double , Ro@@ tmat@@ Size , 6 > > & ) ; template DL@@ LEXPORT Gradi@@ ent < Vector@@ 4@@ d , Dynamic > :: type d@@ rot@@ mat@@ 2@@ quat ( const Eigen :: Matrix@@ Base < Matrix@@ 3d > & , const Eigen :: Matrix@@ Base < Matrix < double , Ro@@ tmat@@ Size , Dynamic > > & ) ; template DL@@ LEXPORT Eigen :: Matrix < double , 3 , 3 > vector@@ To@@ S@@ ke@@ w@@ Sy@@ mm@@ et@@ ric ( const Eigen :: Matrix@@ Base < Eigen :: Vector@@ 3d > & ) ; template DL@@ LEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > d@@ cro@@ ss@@ Product ( const Eigen :: Matrix@@ Base < Vector@@ 3d > & a , const Eigen :: Matrix@@ Base < Vector@@ 3d > & b , const Gradi@@ ent < Vector@@ 3d , Eigen :: Dynamic > :: type & da , const Gradi@@ ent < Vector@@ 3d , Eigen :: Dynamic > :: type & db ) ; template DL@@ LEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > d@@ cro@@ ss@@ Product ( const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true >> & a , const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 3 , 1 , false >> & b , const Gradi@@ ent < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true > , Eigen :: Dynamic > :: type & da , const Gradi@@ ent < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 3 , 1 , false > , Eigen :: Dynamic > :: type & db ) ; template DL@@ LEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > d@@ cro@@ ss@@ Product ( const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true > > & a , const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , 3 , 1 , false > > & b , const Gradi@@ ent < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true > , Eigen :: Dynamic > :: type & da , const Gradi@@ ent < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , 3 , 1 , false > , Eigen :: Dynamic > :: type & db ) ; template DL@@ LEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > d@@ cro@@ ss@@ Product ( const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false >> & a , const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 3 , - 1 , false > , 3 , 1 , true >> & b , const Gradi@@ ent < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , Eigen :: Dynamic > :: type & da , const Gradi@@ ent < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Dynamic > :: type & db ) ; template DL@@ LEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > d@@ cro@@ ss@@ Product ( const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false >> & a , const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true >> & b , const Gradi@@ ent < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , Eigen :: Dynamic > :: type & da , const Gradi@@ ent < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true > , Eigen :: Dynamic > :: type & db ) ; template DL@@ LEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > d@@ cro@@ ss@@ Product ( const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true >> & a , const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 >> & b , const Gradi@@ ent < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Dynamic > :: type & da , const Gradi@@ ent < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 > , Eigen :: Dynamic > :: type & db ) ; template DL@@ LEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > d@@ cro@@ ss@@ Product ( const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , 3 , 1 , false >> & a , const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 >> & b , const Gradi@@ ent < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , 3 , 1 , false > , Eigen :: Dynamic > :: type & da , const Gradi@@ ent < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 > , Eigen :: Dynamic > :: type & db ) ; template DL@@ LEXPORT Eigen :: Matrix < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > :: Scalar , 3 , - 1 , 0 , 3 , - 1 > d@@ cro@@ ss@@ Product < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 3 , 1 , false > > ( Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > > const & , Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 3 , 1 , false > > const & , Gradi@@ ent < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , - 1 , 1 > :: type const & , Gradi@@ ent < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 3 , 1 , false > , - 1 , 1 > :: type const & ) ; template DL@@ LEXPORT Eigen :: Matrix < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > :: Scalar , 3 , - 1 , 0 , 3 , - 1 > d@@ cro@@ ss@@ Product < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , 3 , 1 , false > > ( Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > > const & , Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , 3 , 1 , false > > const & , Gradi@@ ent < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , - 1 , 1 > :: type const & , Gradi@@ ent < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , 3 , 1 , false > , - 1 , 1 > :: type const & ) ; template DL@@ LEXPORT Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > d@@ cro@@ ss@@ Product < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > , 3 , 1 , true > > ( Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > > const & , Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > , 3 , 1 , true > > const & , Gradi@@ ent < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , - 1 , 1 > :: type const & , Gradi@@ ent < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > , 3 , 1 , true > , - 1 , 1 > :: type const & ) ; template DL@@ LEXPORT Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > d@@ cro@@ ss@@ Product < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , Eigen :: Block < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 > , 3 , 1 , true > > ( Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > > const & , Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 > , 3 , 1 , true > > const & , Gradi@@ ent < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , - 1 , 1 > :: type const & , Gradi@@ ent < Eigen :: Block < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 > , 3 , 1 , true > , - 1 , 1 > :: type const & ) ; template DL@@ LEXPORT Eigen :: Matrix < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > :: Scalar , 3 , - 1 , 0 , 3 , - 1 > d@@ cro@@ ss@@ Product < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > > ( Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > > const & , Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > > const & , Gradi@@ ent < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , - 1 , 1 > :: type const & , Gradi@@ ent < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > , - 1 , 1 > :: type const & ) ; template DL@@ LEXPORT Eigen :: Matrix < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > :: Scalar , 3 , - 1 , 0 , 3 , - 1 > d@@ cro@@ ss@@ Product < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 3 , 1 , false > > ( Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > > const & , Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 3 , 1 , false > > const & , Gradi@@ ent < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , - 1 , 1 > :: type const & , Gradi@@ ent < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 3 , 1 , false > , - 1 , 1 > :: type const & ) ; template DL@@ LEXPORT D@@ Ho@@ mo@@ g@@ Tran@@ s < MatrixXd > :: type d@@ Ho@@ mo@@ g@@ Tran@@ s ( const Is@@ ometr@@ y@@ 3d & , const Matrix@@ Base < Matrix < double , TW@@ IS@@ T_@@ SIZE , Dynamic > > & , const Matrix@@ Base < MatrixXd > & ) ; template DL@@ LEXPORT D@@ Ho@@ mo@@ g@@ Tran@@ s < Matrix < double , HO@@ MO@@ G@@ EN@@ E@@ O@@ US_@@ TRANS@@ FOR@@ M@@ _SIZE , Dynamic >> :: type d@@ Ho@@ mo@@ g@@ Trans@@ In@@ v ( const Is@@ ometr@@ y@@ 3d & , const Matrix@@ Base < Matrix < double , HO@@ MO@@ G@@ EN@@ E@@ O@@ US_@@ TRANS@@ FOR@@ M@@ _SIZE , Dynamic > > & ) ; template DL@@ LEXPORT Gradi@@ ent < Matrix < double , TW@@ IS@@ T_@@ SIZE , Dynamic > , Dynamic , 1 > :: type d@@ Transform@@ Sp@@ ati@@ al@@ Mo@@ tion ( const Is@@ ometr@@ y@@ 3d & , const Matrix@@ Base < Matrix < double , TW@@ IS@@ T_@@ SIZE , Dynamic > > & , const Matrix@@ Base < Matrix < double , HO@@ MO@@ G@@ EN@@ E@@ O@@ US_@@ TRANS@@ FOR@@ M@@ _SIZE , Dynamic > > & , const Matrix@@ Base < MatrixXd > & ) ; template DL@@ LEXPORT Gradi@@ ent < Matrix < double , TW@@ IS@@ T_@@ SIZE , 1 > , Dynamic , 1 > :: type d@@ Transform@@ Sp@@ ati@@ al@@ Mo@@ tion ( const Is@@ ometr@@ y@@ 3d & , const Matrix@@ Base < Matrix < double , TW@@ IS@@ T_@@ SIZE , 1 > > & , const Matrix@@ Base < Matrix < double , HO@@ MO@@ G@@ EN@@ E@@ O@@ US_@@ TRANS@@ FOR@@ M@@ _SIZE , Dynamic > > & , const Matrix@@ Base < Matrix < double , TW@@ IS@@ T_@@ SIZE , Eigen :: Dynamic > > & ) ; template DL@@ LEXPORT Transform@@ Sp@@ ati@@ al < Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , 1 >> :: type cro@@ ss@@ Sp@@ ati@@ al@@ Mo@@ tion ( const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , 1 > > & a , const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , 1 > > & b ) ; template DL@@ LEXPORT Transform@@ Sp@@ ati@@ al < Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , TW@@ IS@@ T_@@ SIZE >> :: type cro@@ ss@@ Sp@@ ati@@ al@@ Mo@@ tion ( const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , 1 > > & a , const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , TW@@ IS@@ T_@@ SIZE > > & b ) ; template DL@@ LEXPORT Transform@@ Sp@@ ati@@ al < Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , Eigen :: Dynamic >> :: type cro@@ ss@@ Sp@@ ati@@ al@@ Mo@@ tion ( const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , 1 > > & a , const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , Eigen :: Dynamic > > & b ) ; template DL@@ LEXPORT Transform@@ Sp@@ ati@@ al < Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , 1 >> :: type cro@@ ss@@ Sp@@ ati@@ al@@ For@@ ce ( const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , 1 > > & a , const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , 1 > > & b ) ; template DL@@ LEXPORT Transform@@ Sp@@ ati@@ al < Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , TW@@ IS@@ T_@@ SIZE >> :: type cro@@ ss@@ Sp@@ ati@@ al@@ For@@ ce ( const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , 1 > > & a , const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , TW@@ IS@@ T_@@ SIZE , TW@@ IS@@ T_@@ SIZE > > & b ) ; template DL@@ LEXPORT Gradi@@ ent < Matrix < double , TW@@ IS@@ T_@@ SIZE , Dynamic > , Dynamic , 1 > :: type d@@ Transform@@ Sp@@ ati@@ al@@ For@@ ce ( const Is@@ ometr@@ y@@ 3d & , const Matrix@@ Base < Matrix < double , TW@@ IS@@ T_@@ SIZE , Dynamic > > & , const Matrix@@ Base < Matrix < double , HO@@ MO@@ G@@ EN@@ E@@ O@@ US_@@ TRANS@@ FOR@@ M@@ _SIZE , Dynamic > > & , const Matrix@@ Base < MatrixXd > & ) ; template DL@@ LEXPORT Gradi@@ ent < Matrix < double , TW@@ IS@@ T_@@ SIZE , Dynamic > , Dynamic , 1 > :: type d@@ Transform@@ Sp@@ ati@@ al@@ For@@ ce ( const Is@@ ometr@@ y@@ 3d & , const Matrix@@ Base < Matrix < double , TW@@ IS@@ T_@@ SIZE , Dynamic > > & , const Matrix@@ Base < MatrixXd > & , const Matrix@@ Base < MatrixXd > & ) ; template DL@@ LEXPORT Gradi@@ ent < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 6 , - 1 , true > :: Col@@ s@@ At@@ Compile@@ Time > :: type d@@ Transform@@ Sp@@ ati@@ al@@ For@@ ce ( const Is@@ ometr@@ y@@ 3d & T , const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & X , const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , 16 , - 1 , 0 , 16 , - 1 > > & d@@ T , const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 6 , - 1 , true > > & d@@ X ) ; template DL@@ LEXPORT Gradi@@ ent < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > :: Col@@ s@@ At@@ Compile@@ Time > :: type d@@ Transform@@ Sp@@ ati@@ al@@ For@@ ce ( const Is@@ ometr@@ y@@ 3d & T , const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 >> & X , const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , 16 , - 1 , 0 , 16 , - 1 >> & d@@ T , const Eigen :: Matrix@@ Base < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 >> & d@@ X ) ; template DL@@ LEXPORT void cy@@ lin@@ dri@@ cal@@ 2@@ car@@ te@@ si@@ an ( const Matrix < double , 3 , 1 > & cylinder@@ _@@ axis , const Matrix < double , 3 , 1 > & cylinder@@ _x@@ _dir , const Matrix < double , 3 , 1 > & cylinder@@ _origin , const Matrix < double , 6 , 1 > & x@@ _c@@ y@@ linder , const Matrix < double , 6 , 1 > & v_@@ cy@@ linder , Matrix < double , 6 , 1 > & x@@ _c@@ ar@@ te@@ si@@ an , Matrix < double , 6 , 1 > & v_@@ car@@ te@@ si@@ an , Matrix < double , 6 , 6 > & J , Matrix < double , 6 , 1 > & J@@ do@@ tv ) ; template DL@@ LEXPORT void car@@ te@@ si@@ an@@ 2@@ cy@@ lin@@ dri@@ cal ( const Matrix < double , 3 , 1 > & cylinder@@ _@@ axis , const Matrix < double , 3 , 1 > & cylinder@@ _x@@ _dir , const Matrix < double , 3 , 1 > & cylinder@@ _origin , const Matrix < double , 6 , 1 > & x@@ _c@@ ar@@ te@@ si@@ an , const Matrix < double , 6 , 1 > & v_@@ car@@ te@@ si@@ an , Matrix < double , 6 , 1 > & x@@ _c@@ y@@ linder , Matrix < double , 6 , 1 > & v_@@ cy@@ linder , Matrix < double , 6 , 6 > & J , Matrix < double , 6 , 1 > & J@@ do@@ tv ) ; template DL@@ LEXPORT void ang@@ ular@@ vel@@ 2@@ qu@@ at@@ do@@ t@@ Matrix ( const Eigen :: Matrix@@ Base < Vector@@ 4@@ d > & q , Eigen :: Matrix@@ Base < Matrix < double , QU@@ AT_@@ SIZE , SP@@ ACE_@@ DIMEN@@ SION > > & M , Eigen :: Matrix@@ Base < Gradi@@ ent < Matrix < double , QU@@ AT_@@ SIZE , SP@@ ACE_@@ DIMEN@@ SION > , QU@@ AT_@@ SIZE , 1 > :: type > * d@@ M ) ; template DL@@ LEXPORT void ang@@ ular@@ vel@@ 2@@ qu@@ at@@ do@@ t@@ Matrix ( const Eigen :: Matrix@@ Base < Map < Vector@@ 4@@ d >> & q , Eigen :: Matrix@@ Base < Matrix < double , QU@@ AT_@@ SIZE , SP@@ ACE_@@ DIMEN@@ SION > > & M , Eigen :: Matrix@@ Base < Gradi@@ ent < Matrix < double , QU@@ AT_@@ SIZE , SP@@ ACE_@@ DIMEN@@ SION > , QU@@ AT_@@ SIZE , 1 > :: type > * d@@ M ) ; template DL@@ LEXPORT void ang@@ ular@@ vel@@ 2@@ qu@@ at@@ do@@ t@@ Matrix ( const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: In@@ ner@@ Str@@ ide < 1 > > const , 4 , 1 , false > > & q , Eigen :: Matrix@@ Base < Matrix < double , QU@@ AT_@@ SIZE , SP@@ ACE_@@ DIMEN@@ SION > > & M , Eigen :: Matrix@@ Base < Gradi@@ ent < Matrix < double , QU@@ AT_@@ SIZE , SP@@ ACE_@@ DIMEN@@ SION > , QU@@ AT_@@ SIZE , 1 > :: type > * d@@ M ) ; template DL@@ LEXPORT void ang@@ ular@@ vel@@ 2@@ r@@ py@@ do@@ t@@ Matrix ( const Eigen :: Matrix@@ Base < Vector@@ 3d > & r@@ py , Eigen :: Matrix@@ Base < Matrix < double , RP@@ Y_SIZE , SP@@ ACE_@@ DIMEN@@ SION > > & ph@@ i , Eigen :: Matrix@@ Base < Gradi@@ ent < Matrix < double , RP@@ Y_SIZE , SP@@ ACE_@@ DIMEN@@ SION > , RP@@ Y_SIZE , 1 > :: type > * d@@ ph@@ i , Eigen :: Matrix@@ Base < Gradi@@ ent < Matrix < double , RP@@ Y_SIZE , SP@@ ACE_@@ DIMEN@@ SION > , RP@@ Y_SIZE , 2 > :: type > * dd@@ ph@@ i ) ; template DL@@ LEXPORT void ang@@ ular@@ vel@@ 2@@ r@@ py@@ do@@ t@@ Matrix ( const Eigen :: Matrix@@ Base < Vector@@ 3d > & r@@ py , Eigen :: Matrix@@ Base < Matrix < double , RP@@ Y_SIZE , SP@@ ACE_@@ DIMEN@@ SION > > & ph@@ i , Eigen :: Matrix@@ Base < Matrix < double , Eigen :: Dynamic , Eigen :: Dynamic > > * d@@ ph@@ i , Eigen :: Matrix@@ Base < Matrix < double , Eigen :: Dynamic , Eigen :: Dynamic > > * dd@@ ph@@ i ) ; template DL@@ LEXPORT void r@@ py@@ do@@ t2@@ ang@@ ular@@ vel@@ Matrix ( const Eigen :: Matrix@@ Base < Vector@@ 3d > & r@@ py , Eigen :: Matrix@@ Base < Eigen :: Matrix < double , SP@@ ACE_@@ DIMEN@@ SION , RP@@ Y_SIZE > > & E , Gradi@@ ent < Matrix < double , SP@@ ACE_@@ DIMEN@@ SION , RP@@ Y_SIZE > , RP@@ Y_SIZE , 1 > :: type * d@@ E ) ; template DL@@ LEXPORT void r@@ py@@ do@@ t2@@ ang@@ ular@@ vel@@ Matrix ( const Eigen :: Matrix@@ Base < Map < Vector@@ 3d >> & r@@ py , Eigen :: Matrix@@ Base < Eigen :: Matrix < double , SP@@ ACE_@@ DIMEN@@ SION , RP@@ Y_SIZE > > & E , Gradi@@ ent < Matrix < double , SP@@ ACE_@@ DIMEN@@ SION , RP@@ Y_SIZE > , RP@@ Y_SIZE , 1 > :: type * d@@ E ) ; template DL@@ LEXPORT void r@@ py@@ do@@ t2@@ ang@@ ular@@ vel@@ Matrix ( const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: In@@ ner@@ Str@@ ide < 1 > > const , 3 , 1 , false > > & r@@ py , Eigen :: Matrix@@ Base < Eigen :: Matrix < double , SP@@ ACE_@@ DIMEN@@ SION , RP@@ Y_SIZE > > & E , Gradi@@ ent < Matrix < double , SP@@ ACE_@@ DIMEN@@ SION , RP@@ Y_SIZE > , RP@@ Y_SIZE , 1 > :: type * d@@ E ) ; template DL@@ LEXPORT Gradient@@ Var < double , Eigen :: Dynamic , SP@@ ACE_@@ DIMEN@@ SION > ang@@ ular@@ vel@@ 2@@ Re@@ present@@ ation@@ Dot@@ Matrix ( int rot@@ ation@@ _type , const Eigen :: Matrix@@ Base < Vector@@ Xd > & q@@ rot , int gradi@@ ent_@@ order ) ; template DL@@ LEXPORT Gradient@@ Var < double , Eigen :: Dynamic , SP@@ ACE_@@ DIMEN@@ SION > ang@@ ular@@ vel@@ 2@@ Re@@ present@@ ation@@ Dot@@ Matrix ( int rot@@ ation@@ _type , const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , - 1 , 1 , false > > & q@@ rot , int gradi@@ ent_@@ order ) ; template DL@@ LEXPORT Gradient@@ Var < double , - 1 , 3 > ang@@ ular@@ vel@@ 2@@ Re@@ present@@ ation@@ Dot@@ Matrix < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , - 1 , 1 , false > > ( int , Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , - 1 , 1 , false > > const & , int ) ; template DL@@ LEXPORT Gradient@@ Var < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , - 1 , 1 , false > :: Scalar , - 1 , 3 > ang@@ ular@@ vel@@ 2@@ Re@@ present@@ ation@@ Dot@@ Matrix < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , - 1 , 1 , false > > ( int , Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , - 1 , 1 , false > > const & , int ) ; template DL@@ LEXPORT Gradient@@ Var < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , - 1 , 1 , false > :: Scalar , - 1 , 3 > ang@@ ular@@ vel@@ 2@@ Re@@ present@@ ation@@ Dot@@ Matrix < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , - 1 , 1 , false > > ( int , Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , - 1 , 1 , false > > const & , int ) ; template DL@@ LEXPORT void qu@@ at@@ do@@ t2@@ ang@@ ular@@ vel@@ Matrix ( const Eigen :: Matrix@@ Base < Vector@@ 4@@ d > & q , Eigen :: Matrix@@ Base < Matrix < double , SP@@ ACE_@@ DIMEN@@ SION , QU@@ AT_@@ SIZE > > & M , Gradi@@ ent < Matrix < double , SP@@ ACE_@@ DIMEN@@ SION , QU@@ AT_@@ SIZE > , QU@@ AT_@@ SIZE , 1 > :: type * d@@ M ) ; template DL@@ LEXPORT void qu@@ at@@ do@@ t2@@ ang@@ ular@@ vel@@ Matrix ( const Eigen :: Matrix@@ Base < Map < Vector@@ 4@@ d >> & q , Eigen :: Matrix@@ Base < Matrix < double , SP@@ ACE_@@ DIMEN@@ SION , QU@@ AT_@@ SIZE > > & M , Gradi@@ ent < Matrix < double , SP@@ ACE_@@ DIMEN@@ SION , QU@@ AT_@@ SIZE > , QU@@ AT_@@ SIZE , 1 > :: type * d@@ M ) ; template DL@@ LEXPORT void qu@@ at@@ do@@ t2@@ ang@@ ular@@ vel@@ Matrix ( const Eigen :: Matrix@@ Base < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: In@@ ner@@ Str@@ ide < 1 > > const , 4 , 1 , false > > & q , Eigen :: Matrix@@ Base < Matrix < double , SP@@ ACE_@@ DIMEN@@ SION , QU@@ AT_@@ SIZE > > & M , Gradi@@ ent < Matrix < double , SP@@ ACE_@@ DIMEN@@ SION , QU@@ AT_@@ SIZE > , QU@@ AT_@@ SIZE , 1 > :: type * d@@ M ) ; </DOCUMENT>
<DOCUMENT_ID="@@ TT@@ i@@ mo@@ /do@@ om@@ 3.@@ gp@@ l/tree/master/@@ ne@@ o/@@ tools/@@ mat@@ eri@@ al@@ edit@@ or@@ /@@ Mat@@ eri@@ al@@ Def@@ .cpp"> # include " . . / . . / id@@ lib / precompiled . h " # pragma hdrstop # include " Mat@@ eri@@ al@@ Def . h " Mat@@ eri@@ al@@ Def :: Mat@@ eri@@ al@@ Def ( void ) { type = 0 ; qu@@ o@@ tes = false ; } Mat@@ eri@@ al@@ Def :: ~ Mat@@ eri@@ al@@ Def ( void ) { } DWORD Mat@@ eri@@ al@@ Def :: Get@@ View@@ Data ( const char * view@@ Name ) { DWORD * value = NULL ; view@@ Data . Get ( view@@ Name , & value ) ; return * value ; } void Mat@@ eri@@ al@@ Def :: Set@@ View@@ Data ( const char * view@@ Name , DWORD value ) { view@@ Data . Set ( view@@ Name , value ) ; } # define MAT@@ ERI@@ AL_@@ DEF@@ _F@@ IL@@ E " Mat@@ eri@@ al@@ Edit@@ or@@ Defs . med " Mat@@ eri@@ al@@ Def@@ List Mat@@ eri@@ al@@ Def@@ Manager :: mat@@ eri@@ al@@ Defs [ Mat@@ eri@@ al@@ Def@@ Manager :: MAT@@ ERI@@ AL_@@ DEF@@ _@@ NUM ] ; void Mat@@ eri@@ al@@ Def@@ Manager :: Initialize@@ Mat@@ eri@@ al@@ Def@@ Lists ( ) { char * buffer ; int length = file@@ System -> Read@@ File ( MAT@@ ERI@@ AL_@@ DEF@@ _F@@ IL@@ E , ( void * * ) & buffer ) ; if ( length == - 1 ) { common -> Error ( " Couldn ' t ▁ load ▁ mat@@ eri@@ al ▁ editor ▁ definition : ▁ % s " , MAT@@ ERI@@ AL_@@ DEF@@ _F@@ IL@@ E ) ; return ; } id@@ Lex@@ er src ; if ( ! src . Load@@ Memory ( buffer , length , MAT@@ ERI@@ AL_@@ DEF@@ _F@@ IL@@ E ) ) { common -> Error ( " Couldn ' t ▁ parse ▁ % s " , MAT@@ ERI@@ AL_@@ DEF@@ _F@@ IL@@ E ) ; file@@ System -> Free@@ File ( buffer ) ; } Initialize@@ Mat@@ eri@@ al@@ Def@@ List ( & src , " mat@@ eri@@ al@@ props " , & mat@@ eri@@ al@@ Defs [ MAT@@ ERI@@ AL_@@ DEF@@ _@@ MAT@@ ERI@@ AL ] ) ; Initialize@@ Mat@@ eri@@ al@@ Def@@ List ( & src , " st@@ age@@ props " , & mat@@ eri@@ al@@ Defs [ MAT@@ ERI@@ AL_@@ DEF@@ _ST@@ AGE ] ) ; Initialize@@ Mat@@ eri@@ al@@ Def@@ List ( & src , " speci@@ al@@ map@@ st@@ age@@ props " , & mat@@ eri@@ al@@ Defs [ MAT@@ ERI@@ AL_@@ DEF@@ _SP@@ ECI@@ AL_@@ ST@@ AGE ] ) ; file@@ System -> Free@@ File ( buffer ) ; } void Mat@@ eri@@ al@@ Def@@ Manager :: Initialize@@ Mat@@ eri@@ al@@ Def@@ List ( id@@ Lex@@ er * src , const char * typeName , Mat@@ eri@@ al@@ Def@@ List * list ) { id@@ Token token ; src -> Reset ( ) ; src -> Skip@@ Un@@ ti@@ l@@ String ( typeName ) ; src -> Skip@@ Un@@ ti@@ l@@ String ( " { " ) ; while ( 1 ) { if ( ! src -> Exp@@ ect@@ Any@@ Token ( & token ) ) { return ; } if ( token == " } " ) { break ; } Mat@@ eri@@ al@@ Def * new@@ Prop = new Mat@@ eri@@ al@@ Def ( ) ; if ( ! token . I@@ cmp ( " TYPE _ GROUP " ) ) { new@@ Prop -> type = Mat@@ eri@@ al@@ Def :: MAT@@ ERI@@ AL_@@ DEF@@ _TYPE_@@ GROUP ; } else if ( ! token . I@@ cmp ( " TYPE _ BOOL " ) ) { new@@ Prop -> type = Mat@@ eri@@ al@@ Def :: MAT@@ ERI@@ AL_@@ DEF@@ _TYPE_@@ BOOL ; } else if ( ! token . I@@ cmp ( " TYPE _ STRING " ) ) { new@@ Prop -> type = Mat@@ eri@@ al@@ Def :: MAT@@ ERI@@ AL_@@ DEF@@ _TYPE_@@ STRING ; } else if ( ! token . I@@ cmp ( " TYPE _ FLOAT " ) ) { new@@ Prop -> type = Mat@@ eri@@ al@@ Def :: MAT@@ ERI@@ AL_@@ DEF@@ _TYPE_@@ FLOAT ; } else if ( ! token . I@@ cmp ( " TYPE _ INT " ) ) { new@@ Prop -> type = Mat@@ eri@@ al@@ Def :: MAT@@ ERI@@ AL_@@ DEF@@ _TYPE_@@ INT ; } src -> Read@@ Token ( & token ) ; src -> Read@@ Token ( & token ) ; new@@ Prop -> dict@@ Name = token ; src -> Read@@ Token ( & token ) ; src -> Read@@ Token ( & token ) ; new@@ Prop -> displayName = token ; src -> Read@@ Token ( & token ) ; src -> Read@@ Token ( & token ) ; new@@ Prop -> display@@ Info = token ; if ( new@@ Prop -> type == Mat@@ eri@@ al@@ Def :: MAT@@ ERI@@ AL_@@ DEF@@ _TYPE_@@ STRING ) { new@@ Prop -> qu@@ o@@ tes = false ; src -> Read@@ Token ( & token ) ; src -> Read@@ Token ( & token ) ; if ( token == "1" ) { new@@ Prop -> qu@@ o@@ tes = true ; } } src -> Skip@@ Re@@ st@@ Of@@ Line ( ) ; list -> Append ( new@@ Prop ) ; } } void Mat@@ eri@@ al@@ Def@@ Manager :: Destroy@@ Mat@@ eri@@ al@@ Def@@ Lists ( ) { for ( int i = 0 ; i < MAT@@ ERI@@ AL_@@ DEF@@ _@@ NUM ; i ++ ) { for ( int j = 0 ; j < mat@@ eri@@ al@@ Defs [ i ] . Num ( ) ; j ++ ) { delete mat@@ eri@@ al@@ Defs [ i ] [ j ] ; } mat@@ eri@@ al@@ Defs [ i ] . Clear ( ) ; } } Mat@@ eri@@ al@@ Def@@ List * Mat@@ eri@@ al@@ Def@@ Manager :: Get@@ Mat@@ eri@@ al@@ Defs ( int type ) { if ( type >= 0 && type < MAT@@ ERI@@ AL_@@ DEF@@ _@@ NUM ) { return & mat@@ eri@@ al@@ Defs [ type ] ; } return NULL ; } </DOCUMENT>
<DOCUMENT_ID="@@ ces@@ ar@@ mar@@ in@@ hor@@ j@@ /phantomjs/tree/master/src/qt/qt@@ webkit/Source/@@ WTF@@ /@@ wt@@ f/@@ text@@ /Base@@ 64@@ .cpp"> # include " config . h " # include " Base@@ 64 . h " # include < limits . h > # include < wtf / String@@ Extr@@ as . h > # include < wtf / text / WTF@@ String . h > namespace WTF { static const char base@@ 64@@ En@@ c@@ Map [ 64 ] = { 0x41 , 0x42 , 0x43 , 0x44 , 0x4@@ 5 , 0x46 , 0x4@@ 7 , 0x48 , 0x49 , 0x4@@ A , 0x4@@ B , 0x4@@ C , 0x4@@ D , 0x4@@ E , 0x4@@ F , 0x50 , 0x51 , 0x5@@ 2 , 0x53 , 0x5@@ 4 , 0x55 , 0x5@@ 6 , 0x57 , 0x58 , 0x59 , 0x5@@ A , 0x61 , 0x@@ 62 , 0x6@@ 3 , 0x64 , 0x65 , 0x6@@ 6 , 0x6@@ 7 , 0x68 , 0x6@@ 9 , 0x6@@ A , 0x6@@ B , 0x6@@ C , 0x6@@ D , 0x6@@ E , 0x6@@ F , 0x70 , 0x7@@ 1 , 0x7@@ 2 , 0x7@@ 3 , 0x74 , 0x7@@ 5 , 0x76 , 0x77 , 0x78 , 0x7@@ 9 , 0x7@@ A , 0x30 , 0x31 , 0x32 , 0x3@@ 3 , 0x34 , 0x3@@ 5 , 0x3@@ 6 , 0x37 , 0x38 , 0x39 , 0x2@@ B , 0x2@@ F } ; static const char base@@ 64@@ Dec@@ Map [ 128 ] = { 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x3E , 0x00 , 0x00 , 0x00 , 0x3F , 0x34 , 0x3@@ 5 , 0x3@@ 6 , 0x37 , 0x38 , 0x39 , 0x3@@ A , 0x3@@ B , 0x3@@ C , 0x3D , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 , 0x08 , 0x09 , 0x0A , 0x0@@ B , 0x0@@ C , 0x0@@ D , 0x0@@ E , 0x0F , 0x10 , 0x11 , 0x12 , 0x@@ 13 , 0x14 , 0x15 , 0x16 , 0x17 , 0x18 , 0x19 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x1A , 0x1@@ B , 0x1@@ C , 0x1@@ D , 0x1@@ E , 0x1F , 0x20 , 0x21 , 0x22 , 0x23 , 0x24 , 0x25 , 0x26 , 0x27 , 0x28 , 0x2@@ 9 , 0x2@@ A , 0x2@@ B , 0x2@@ C , 0x@@ 2D , 0x2@@ E , 0x2@@ F , 0x30 , 0x31 , 0x32 , 0x3@@ 3 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 } ; String base@@ 64Encode ( const char * data , unsigned length , Base@@ 64@@ Encode@@ Policy po@@ lic@@ y ) { Vector < char > result ; base@@ 64Encode ( data , length , result , po@@ lic@@ y ) ; return String ( result . data ( ) , result . size ( ) ) ; } void base@@ 64Encode ( const char * data , unsigned len , Vector < char > & out , Base@@ 64@@ Encode@@ Policy po@@ lic@@ y ) { out . clear ( ) ; if ( ! len ) return ; const unsigned max@@ Input@@ Buffer@@ Size = UINT_MAX / 77 * 76 / 4 * 3 - 2 ; if ( len > max@@ Input@@ Buffer@@ Size ) return ; unsigned si@@ dx = 0 ; unsigned d@@ idx = 0 ; unsigned out@@ Length = ( ( len + 2 ) / 3 ) * 4 ; bool insert@@ L@@ F@@ s = ( po@@ lic@@ y == Base@@ 64@@ Insert@@ L@@ F@@ s && out@@ Length > 76 ) ; if ( insert@@ L@@ F@@ s ) out@@ Length += ( ( out@@ Length - 1 ) / 76 ) ; int count = 0 ; out . gro@@ w ( out@@ Length ) ; if ( len > 1 ) { while ( si@@ dx < len - 2 ) { if ( insert@@ L@@ F@@ s ) { if ( count && ! ( count % 76 ) ) out [ d@@ idx ++ ] = ' \n ' ; count += 4 ; } out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( data [ si@@ dx ] >> 2 ) & 0@@ 77 ] ; out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( ( data [ si@@ dx + 1 ] >> 4 ) & 0@@ 17 ) | ( ( data [ si@@ dx ] << 4 ) & 0@@ 77 ) ] ; out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( ( data [ si@@ dx + 2 ] >> 6 ) & 00@@ 3 ) | ( ( data [ si@@ dx + 1 ] << 2 ) & 0@@ 77 ) ] ; out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ data [ si@@ dx + 2 ] & 0@@ 77 ] ; si@@ dx += 3 ; } } if ( si@@ dx < len ) { if ( insert@@ L@@ F@@ s && ( count > 0 ) && ! ( count % 76 ) ) out [ d@@ idx ++ ] = ' \n ' ; out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( data [ si@@ dx ] >> 2 ) & 0@@ 77 ] ; if ( si@@ dx < len - 1 ) { out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( ( data [ si@@ dx + 1 ] >> 4 ) & 0@@ 17 ) | ( ( data [ si@@ dx ] << 4 ) & 0@@ 77 ) ] ; out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( data [ si@@ dx + 1 ] << 2 ) & 0@@ 77 ] ; } else out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( data [ si@@ dx ] << 4 ) & 0@@ 77 ] ; } while ( d@@ idx < out . size ( ) ) { out [ d@@ idx ] = ' = ' ; ++ d@@ idx ; } } bool base@@ 64@@ Dec@@ ode ( const Vector < char > & in , Vector < char > & out , Base@@ 64@@ Deco@@ de@@ Policy po@@ lic@@ y ) { out . clear ( ) ; if ( in . size ( ) > UINT_MAX ) return false ; return base@@ 64@@ Dec@@ ode ( in . data ( ) , in . size ( ) , out , po@@ lic@@ y ) ; } template < typename T > static inline bool base@@ 64@@ Deco@@ de@@ Internal ( const T * data , unsigned len , Vector < char > & out , Base@@ 64@@ Deco@@ de@@ Policy po@@ lic@@ y ) { out . clear ( ) ; if ( ! len ) return true ; out . gro@@ w ( len ) ; bool s@@ aw@@ Equal@@ s@@ Sign = false ; unsigned out@@ Length = 0 ; for ( unsigned idx = 0 ; idx < len ; ++ idx ) { unsigned ch = data [ idx ] ; if ( ch == ' = ' ) s@@ aw@@ Equal@@ s@@ Sign = true ; else if ( ( '0' <= ch && ch <= '9' ) || ( ' A ' <= ch && ch <= ' Z ' ) || ( ' a ' <= ch && ch <= ' z ' ) || ch == ' + ' || ch == ' / ' ) { if ( s@@ aw@@ Equal@@ s@@ Sign ) return false ; out [ out@@ Length ] = base@@ 64@@ Dec@@ Map [ ch ] ; ++ out@@ Length ; } else if ( po@@ lic@@ y == Base@@ 64@@ Fail@@ On@@ Invalid@@ Character || ( po@@ lic@@ y == Base@@ 64@@ Ignore@@ Wh@@ ite@@ space && ! is@@ Space@@ Or@@ New@@ line ( ch ) ) ) return false ; } if ( ! out@@ Length ) return ! s@@ aw@@ Equal@@ s@@ Sign ; if ( ( out@@ Length % 4 ) == 1 ) return false ; out@@ Length -= ( out@@ Length + 3 ) / 4 ; if ( ! out@@ Length ) return false ; unsigned si@@ dx = 0 ; unsigned d@@ idx = 0 ; if ( out@@ Length > 1 ) { while ( d@@ idx < out@@ Length - 2 ) { out [ d@@ idx ] = ( ( ( out [ si@@ dx ] << 2 ) & 255 ) | ( ( out [ si@@ dx + 1 ] >> 4 ) & 00@@ 3 ) ) ; out [ d@@ idx + 1 ] = ( ( ( out [ si@@ dx + 1 ] << 4 ) & 255 ) | ( ( out [ si@@ dx + 2 ] >> 2 ) & 0@@ 17 ) ) ; out [ d@@ idx + 2 ] = ( ( ( out [ si@@ dx + 2 ] << 6 ) & 255 ) | ( out [ si@@ dx + 3 ] & 0@@ 77 ) ) ; si@@ dx += 4 ; d@@ idx += 3 ; } } if ( d@@ idx < out@@ Length ) out [ d@@ idx ] = ( ( ( out [ si@@ dx ] << 2 ) & 255 ) | ( ( out [ si@@ dx + 1 ] >> 4 ) & 00@@ 3 ) ) ; if ( ++ d@@ idx < out@@ Length ) out [ d@@ idx ] = ( ( ( out [ si@@ dx + 1 ] << 4 ) & 255 ) | ( ( out [ si@@ dx + 2 ] >> 2 ) & 0@@ 17 ) ) ; if ( out@@ Length < out . size ( ) ) out . shrin@@ k ( out@@ Length ) ; return true ; } bool base@@ 64@@ Dec@@ ode ( const char * data , unsigned len , Vector < char > & out , Base@@ 64@@ Deco@@ de@@ Policy po@@ lic@@ y ) { return base@@ 64@@ Deco@@ de@@ Internal < char > ( data , len , out , po@@ lic@@ y ) ; } bool base@@ 64@@ Dec@@ ode ( const String & in , Vector < char > & out , Base@@ 64@@ Deco@@ de@@ Policy po@@ lic@@ y ) { return base@@ 64@@ Deco@@ de@@ Internal < UChar > ( in . characters ( ) , in . length ( ) , out , po@@ lic@@ y ) ; } } </DOCUMENT>
