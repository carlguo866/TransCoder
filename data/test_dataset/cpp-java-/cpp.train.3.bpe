<DOCUMENT_ID="PKRo@@ ma/poedit/tree/master/deps/boost/libs/phoenix/test/container/@@ container_@@ tests8a.cpp"> # include " container _ tests . hpp " # include < boost / static_assert . hpp > std :: set < int > const build_set ( ) { typedef std :: set < int > int_set ; typedef std :: vector < int > int_vector ; int_set result ; int_vector const data = build_vector ( ) ; int_vector :: const_iterator it = data . begin ( ) ; int_vector :: const_iterator const end = data . end ( ) ; result . insert ( it , end ) ; return result ; } std :: multiset < int > const build_multiset ( ) { typedef std :: set < int > int_set ; typedef std :: multiset < int > int_multiset ; int_set const data = build_set ( ) ; return int_multiset ( data . begin ( ) , data . end ( ) ) ; } std :: vector < int > const init_vector ( ) { typedef std :: vector < int > int_vector ; int const data [ ] = { - 4 , - 3 , - 2 , - 1 , 0 } ; int_vector :: size_type const data_size = sizeof ( data ) / sizeof ( data [ 0 ] ) ; return int_vector ( data , data + data_size ) ; } std :: vector < int > const build_vector ( ) { typedef std :: vector < int > int_vector ; static int_vector data = init_vector ( ) ; int_vector :: size_type const size = data . size ( ) ; int_vector :: iterator it = data . begin ( ) ; int_vector :: iterator const end = data . end ( ) ; for ( ; it != end ; ++ it ) * it += size ; return data ; } int main ( ) { BOOST_STATIC_ASSERT ( ( ! phx :: stl :: has_mapped@@ _type < std :: multiset < int > > :: value ) ) ; BOOST_STATIC_ASSERT ( ( phx :: stl :: has_key_type < std :: multiset < int > > :: value ) ) ; std :: multiset < int > const data = build_multiset ( ) ; test_begin ( data ) ; test_clear ( data ) ; test_empty ( data ) ; test_end ( data ) ; test_set_@@ erase ( data ) ; test_get_allocator ( data ) ; return boost :: report_errors ( ) ; } </DOCUMENT>
<DOCUMENT_ID="alej@@ ocb/rgbdtam/tree/master/@@ ThirdParty/g2o/g2o/@@ core/marg@@ inal_covarian@@ ce_cholesk@@ y.cpp"> # include " marginal _ covariance _ cholesky . h " # include < algorithm > # include < cassert > using namespace std ; namespace g2o { struct MatrixElem { int r , c ; MatrixElem ( int r_ , int c_ ) : r ( r_ ) , c ( c_ ) { } bool operator < ( const MatrixElem & other ) const { return c > other . c || ( c == other . c && r > other . r ) ; } } ; MarginalCovarianceCholesky :: MarginalCovarianceCholesky ( ) : _n ( 0 ) , _Ap ( 0 ) , _Ai ( 0 ) , _Ax ( 0 ) , _perm ( 0 ) { } MarginalCovarianceCholesky :: ~ MarginalCovarianceCholesky ( ) { } void MarginalCovarianceCholesky :: setCholeskyFactor ( int n , int * Lp , int * Li , double * Lx , int * permInv ) { _n = n ; _Ap = Lp ; _Ai = Li ; _Ax = Lx ; _perm = permInv ; _diag . resize ( n ) ; for ( int r = 0 ; r < n ; ++ r ) { const int & sc = _Ap [ r ] ; assert ( r == _Ai [ sc ] && " Error ▁ in ▁ CCS ▁ storage ▁ of ▁ L " ) ; _diag [ r ] = 1.0 / _Ax [ sc ] ; } } double MarginalCovarianceCholesky :: computeEntry ( int r , int c ) { assert ( r <= c ) ; int idx = computeIndex ( r , c ) ; LookupMap :: const_iterator foundIt = _map . find ( idx ) ; if ( foundIt != _map . end ( ) ) { return foundIt -> second ; } double s = 0. ; const int & sc = _Ap [ r ] ; const int & ec = _Ap [ r + 1 ] ; for ( int j = sc + 1 ; j < ec ; ++ j ) { const int & rr = _Ai [ j ] ; double val = rr < c ? computeEntry ( rr , c ) : computeEntry ( c , rr ) ; s += val * _Ax [ j ] ; } double result ; if ( r == c ) { const double & diagElem = _diag [ r ] ; result = diagElem * ( diagElem - s ) ; } else { result = - s * _diag [ r ] ; } _map [ idx ] = result ; return result ; } void MarginalCovarianceCholesky :: computeCovariance ( double * * covBlocks , const std :: vector < int > & blockIndices ) { _map . clear ( ) ; int base = 0 ; vector < MatrixElem > elemsToCompute ; for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int nbase = blockIndices [ i ] ; int vdim = nbase - base ; for ( int rr = 0 ; rr < vdim ; ++ rr ) for ( int cc = rr ; cc < vdim ; ++ cc ) { int r = _perm ? _perm [ rr + base ] : rr + base ; int c = _perm ? _perm [ cc + base ] : cc + base ; if ( r > c ) swap ( r , c ) ; elemsToCompute . push_back ( MatrixElem ( r , c ) ) ; } base = nbase ; } sort ( elemsToCompute . begin ( ) , elemsToCompute . end ( ) ) ; for ( size_t i = 0 ; i < elemsToCompute . size ( ) ; ++ i ) { const MatrixElem & me = elemsToCompute [ i ] ; computeEntry ( me . r , me . c ) ; } base = 0 ; for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int nbase = blockIndices [ i ] ; int vdim = nbase - base ; double * cov = covBlocks [ i ] ; for ( int rr = 0 ; rr < vdim ; ++ rr ) for ( int cc = rr ; cc < vdim ; ++ cc ) { int r = _perm ? _perm [ rr + base ] : rr + base ; int c = _perm ? _perm [ cc + base ] : cc + base ; if ( r > c ) swap ( r , c ) ; int idx = computeIndex ( r , c ) ; LookupMap :: const_iterator foundIt = _map . find ( idx ) ; assert ( foundIt != _map . end ( ) ) ; cov [ rr * vdim + cc ] = foundIt -> second ; if ( rr != cc ) cov [ cc * vdim + rr ] = foundIt -> second ; } base = nbase ; } } void MarginalCovarianceCholesky :: computeCovariance ( SparseBlockMatrix < MatrixXd > & spinv , const std :: vector < int > & rowBlockIndices , const std :: vector < std :: pair < int , int > > & blockIndices ) { spinv = SparseBlockMatrix < MatrixXd > ( & rowBlockIndices [ 0 ] , & rowBlockIndices [ 0 ] , rowBlockIndices . size ( ) , rowBlockIndices . size ( ) , true ) ; _map . clear ( ) ; vector < MatrixElem > elemsToCompute ; for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int blockRow = blockIndices [ i ] . first ; int blockCol = blockIndices [ i ] . second ; assert ( blockRow >= 0 ) ; assert ( blockRow < ( int ) rowBlockIndices . size ( ) ) ; assert ( blockCol >= 0 ) ; assert ( blockCol < ( int ) rowBlockIndices . size ( ) ) ; int rowBase = spinv . rowBaseOfBlock ( blockRow ) ; int colBase = spinv . colBaseOfBlock ( blockCol ) ; MatrixXd * block = spinv . block ( blockRow , blockCol , true ) ; assert ( block ) ; for ( int iRow = 0 ; iRow < block -> rows ( ) ; ++ iRow ) for ( int iCol = 0 ; iCol < block -> cols ( ) ; ++ iCol ) { int rr = rowBase + iRow ; int cc = colBase + iCol ; int r = _perm ? _perm [ rr ] : rr ; int c = _perm ? _perm [ cc ] : cc ; if ( r > c ) swap ( r , c ) ; elemsToCompute . push_back ( MatrixElem ( r , c ) ) ; } } sort ( elemsToCompute . begin ( ) , elemsToCompute . end ( ) ) ; for ( size_t i = 0 ; i < elemsToCompute . size ( ) ; ++ i ) { const MatrixElem & me = elemsToCompute [ i ] ; computeEntry ( me . r , me . c ) ; } for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int blockRow = blockIndices [ i ] . first ; int blockCol = blockIndices [ i ] . second ; int rowBase = spinv . rowBaseOfBlock ( blockRow ) ; int colBase = spinv . colBaseOfBlock ( blockCol ) ; MatrixXd * block = spinv . block ( blockRow , blockCol ) ; assert ( block ) ; for ( int iRow = 0 ; iRow < block -> rows ( ) ; ++ iRow ) for ( int iCol = 0 ; iCol < block -> cols ( ) ; ++ iCol ) { int rr = rowBase + iRow ; int cc = colBase + iCol ; int r = _perm ? _perm [ rr ] : rr ; int c = _perm ? _perm [ cc ] : cc ; if ( r > c ) swap ( r , c ) ; int idx = computeIndex ( r , c ) ; LookupMap :: const_iterator foundIt = _map . find ( idx ) ; assert ( foundIt != _map . end ( ) ) ; ( * block ) ( iRow , iCol ) = foundIt -> second ; } } } } </DOCUMENT>
<DOCUMENT_ID="sjsinju@@ /coreclr/tree/master/src/pal/tests/@@ palsuite/@@ c_runtime/fmod/test1/test1.cpp"> # include < palsuite . h > # define PAL_EPSILON 8.881784@@ 19700@@ 12523e - 16 # define PAL_NAN sqrt ( - 1.0 ) # define PAL_POSINF - log ( 0.0 ) # define PAL_NEGINF log ( 0.0 ) struct test { double numerator ; double denominator ; double expected ; double variance ; } ; void __cdecl validate ( double numerator , double denominator , double expected , double variance ) { double result = fmod ( numerator , denominator ) ; double delta = fabs ( result - expected ) ; if ( delta > variance ) { Fail ( " fmod ( % g , ▁ % g ) ▁ returned ▁ % 20.17g ▁ when ▁ it ▁ should ▁ have ▁ returned ▁ % 20.17g " , numerator , denominator , result , expected ) ; } } void __cdecl validate_isnan ( double numerator , double denominator ) { double result = fmod ( numerator , denominator ) ; if ( ! _isnan ( result ) ) { Fail ( " fmod ( % g , ▁ % g ) ▁ returned ▁ % 20.17g ▁ when ▁ it ▁ should ▁ have ▁ returned ▁ % 20.17g " , numerator , denominator , result , PAL_NAN ) ; } } INT __cdecl main ( INT argc , CHAR * * argv ) { struct test tests [ ] = { { 0 , PAL_POSINF , 0 , PAL_EPSILON } , { 0.31296179620778659 , 0.949765715@@ 381638@@ 66 , 0.31296179620778658 , PAL_EPSILON } , { 0.42077048331375735 , 0.90716712@@ 92390@@ 9839 , 0.42077048331375733 , PAL_EPSILON } , { 0.59448076852482208 , 0.804109@@ 82822879@@ 171 , 0.594480768524822@@ 12 , PAL_EPSILON } , { 0.63896127631363480 , 0.769238@@ 901363@@ 97213 , 0.63896127631363475 , PAL_EPSILON } , { 0.64963693908006244 , 0.76024459@@ 70756@@ 3015 , 0.64963693908006248 , PAL_EPSILON } , { 0.70710678118654752 , 0.70710678118654752 , 0 , PAL_EPSILON } , { 1 , 1 , 0 , PAL_EPSILON } , { 0.8414@@ 7098@@ 48078965@@ 1 , 0.54030230@@ 5868@@ 1397@@ 2 , 0.301168678939756@@ 74 , PAL_EPSILON } , { 0.903719@@ 45743@@ 5846@@ 30 , 0.428125@@ 14788535@@ 792 , 0.047469161665@@ 1303@@ 77 , PAL_EPSILON / 10 } , { 0.987765@@ 94599@@ 273553 , 0.15594369476@@ 53744@@ 7 , 0.052@@ 10377@@ 74004@@ 8860@@ 5 , PAL_EPSILON / 10 } , { 0.991806244393@@ 6637@@ 2 , 0.1277512@@ 1753523991 , 0.0975@@ 477216@@ 46984359 , PAL_EPSILON / 10 } , { 0.74398@@ 03369@@ 5749319 , - 0.66820151019@@ 031295 , 0.075@@ 77882676@@ 7180285 , PAL_EPSILON / 10 } , { 0.41078129050290870 , - 0.911733@@ 914786965@@ 10 , 0.41078129050290868 , PAL_EPSILON } , { 0 , - 1 , 0 , PAL_EPSILON } , { 1 , PAL_POSINF , 1 , PAL_EPSILON * 10 } , } ; if ( PAL_Initialize ( argc , argv ) != 0 ) { return FAIL ; } for ( int i = 0 ; i < ( sizeof ( tests ) / sizeof ( struct test ) ) ; i ++ ) { validate ( tests [ i ] . numerator , tests [ i ] . denominator , tests [ i ] . expected , tests [ i ] . variance ) ; validate ( - tests [ i ] . numerator , tests [ i ] . denominator , - tests [ i ] . expected , tests [ i ] . variance ) ; validate ( tests [ i ] . numerator , - tests [ i ] . denominator , tests [ i ] . expected , tests [ i ] . variance ) ; validate ( - tests [ i ] . numerator , - tests [ i ] . denominator , - tests [ i ] . expected , tests [ i ] . variance ) ; } validate_isnan ( 0 , 0 ) ; validate_isnan ( - 0.0 , 0 ) ; validate_isnan ( 0 , - 0.0 ) ; validate_isnan ( - 0.0 , - 0.0 ) ; validate_isnan ( 1 , 0 ) ; validate_isnan ( - 1.0 , 0 ) ; validate_isnan ( 1 , - 0.0 ) ; validate_isnan ( - 1.0 , - 0.0 ) ; validate_isnan ( PAL_POSINF , PAL_POSINF ) ; validate_isnan ( PAL_NEGINF , PAL_POSINF ) ; validate_isnan ( PAL_POSINF , PAL_NEGINF ) ; validate_isnan ( PAL_NEGINF , PAL_NEGINF ) ; validate_isnan ( PAL_POSINF , 0 ) ; validate_isnan ( PAL_NEGINF , 0 ) ; validate_isnan ( PAL_POSINF , - 0.0 ) ; validate_isnan ( PAL_NEGINF , - 0.0 ) ; validate_isnan ( PAL_POSINF , 1 ) ; validate_isnan ( PAL_NEGINF , 1 ) ; validate_isnan ( PAL_POSINF , - 1.0 ) ; validate_isnan ( PAL_NEGINF , - 1.0 ) ; PAL_Terminate ( ) ; return PASS ; } </DOCUMENT>
<DOCUMENT_ID="xlmb@@ n/trscoin/tree/master/src/test/@@ multisig_tests.cpp"> # include < boost / assert . hpp > # include < boost / assign / list_of . hpp > # include < boost / assign / list_inserter . hpp > # include < boost / assign / std / vector . hpp > # include < boost / test / unit_test . hpp > # include < boost / foreach . hpp > # include < boost / tuple / tuple . hpp > # include < openssl / ec . h > # include < openssl / err . h > # include " keystore . h " # include " main . h " # include " script . h " # include " wallet . h " using namespace std ; using namespace boost :: assign ; typedef vector < unsigned char > valtype ; extern uint256 SignatureHash ( CScript scriptCode , const CTransaction & txTo , unsigned int nIn , int nHashType ) ; BOOST_AUTO_TEST_SUITE ( multisig_tests ) CScript sign_multisig ( CScript scriptPubKey , vector < CKey > keys , CTransaction transaction , int whichIn ) { uint256 hash = SignatureHash ( scriptPubKey , transaction , whichIn , SIGHASH_ALL ) ; CScript result ; result << OP_0 ; BOOST_FOREACH ( const CKey & key , keys ) { vector < unsigned char > vchSig ; BOOST_CHECK ( key . Sign ( hash , vchSig ) ) ; vchSig . push_back ( ( unsigned char ) SIGHASH_ALL ) ; result << vchSig ; } return result ; } BOOST_AUTO_TEST_CASE ( multisig_verify ) { unsigned int flags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) key [ i ] . MakeNewKey ( true ) ; CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; CTransaction txFrom ; txFrom . vout . resize ( 3 ) ; txFrom . vout [ 0 ] . scriptPubKey = a_and_b ; txFrom . vout [ 1 ] . scriptPubKey = a_or_b ; txFrom . vout [ 2 ] . scriptPubKey = escrow ; CTransaction txTo [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { txTo [ i ] . vin . resize ( 1 ) ; txTo [ i ] . vout . resize ( 1 ) ; txTo [ i ] . vin [ 0 ] . prevout . n = i ; txTo [ i ] . vin [ 0 ] . prevout . hash = txFrom . GetHash ( ) ; txTo [ i ] . vout [ 0 ] . nValue = 1 ; } vector < CKey > keys ; CScript s ; keys . clear ( ) ; keys += key [ 0 ] , key [ 1 ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK ( VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) { keys . clear ( ) ; keys += key [ i ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) , strprintf ( " a & b ▁ 1 : ▁ % d " , i ) ) ; keys . clear ( ) ; keys += key [ 1 ] , key [ i ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) , strprintf ( " a & b ▁ 2 : ▁ % d " , i ) ) ; } for ( int i = 0 ; i < 4 ; i ++ ) { keys . clear ( ) ; keys += key [ i ] ; s = sign_multisig ( a_or_b , keys , txTo [ 1 ] , 0 ) ; if ( i == 0 || i == 1 ) BOOST_CHECK_MESSAGE ( VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) , strprintf ( " a | b : ▁ % d " , i ) ) ; else BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) , strprintf ( " a | b : ▁ % d " , i ) ) ; } s . clear ( ) ; s << OP_0 << OP_0 ; BOOST_CHECK ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) ) ; s . clear ( ) ; s << OP_0 << OP_1 ; BOOST_CHECK ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) { keys . clear ( ) ; keys += key [ i ] , key [ j ] ; s = sign_multisig ( escrow , keys , txTo [ 2 ] , 0 ) ; if ( i < j && i < 3 && j < 3 ) BOOST_CHECK_MESSAGE ( VerifyScript ( s , escrow , txTo [ 2 ] , 0 , flags , 0 ) , strprintf ( " escrow ▁ 1 : ▁ % d ▁ % d " , i , j ) ) ; else BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , escrow , txTo [ 2 ] , 0 , flags , 0 ) , strprintf ( " escrow ▁ 2 : ▁ % d ▁ % d " , i , j ) ) ; } } BOOST_AUTO_TEST_CASE ( multisig_IsStandard ) { CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) key [ i ] . MakeNewKey ( true ) ; CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( a_and_b ) ) ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( a_or_b ) ) ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( escrow ) ) ; CScript one_of_four ; one_of_four << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << key [ 3 ] . GetPubKey ( ) << OP_4 << OP_CHECKMULTISIG ; BOOST_CHECK ( ! :: IsStandard ( one_of_four ) ) ; CScript malformed [ 6 ] ; malformed [ 0 ] << OP_3 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; malformed [ 1 ] << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; malformed [ 2 ] << OP_0 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; malformed [ 3 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_0 << OP_CHECKMULTISIG ; malformed [ 4 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_CHECKMULTISIG ; malformed [ 5 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) ; for ( int i = 0 ; i < 6 ; i ++ ) BOOST_CHECK ( ! :: IsStandard ( malformed [ i ] ) ) ; } BOOST_AUTO_TEST_CASE ( multisig_Sol@@ ver1 ) { CBasicKeyStore keystore , emptykeystore , partialkeystore ; CKey key [ 3 ] ; CTxDestination keyaddr [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { key [ i ] . MakeNewKey ( true ) ; keystore . AddKey ( key [ i ] ) ; keyaddr [ i ] = key [ i ] . GetPubKey ( ) . GetID ( ) ; } partialkeystore . AddKey ( key [ 0 ] ) ; { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << key [ 0 ] . GetPubKey ( ) << OP_CHECKSIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 1 ) ; CTxDestination addr ; BOOST_CHECK ( ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( addr == keyaddr [ 0 ] ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_DUP << OP_HASH@@ 160 << key [ 0 ] . GetPubKey ( ) . GetID ( ) << OP_EQUALVERIFY << OP_CHECKSIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 1 ) ; CTxDestination addr ; BOOST_CHECK ( ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( addr == keyaddr [ 0 ] ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK_EQUAL ( solutions . size ( ) , 4U ) ; CTxDestination addr ; BOOST_CHECK ( ! ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; BOOST_CHECK ( ! IsMine ( partialkeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK_EQUAL ( solutions . size ( ) , 4U ) ; vector < CTxDestination > addrs ; int nRequired ; BOOST_CHECK ( ExtractDestinations ( s , whichType , addrs , nRequired ) ) ; BOOST_CHECK ( addrs [ 0 ] == keyaddr [ 0 ] ) ; BOOST_CHECK ( addrs [ 1 ] == keyaddr [ 1 ] ) ; BOOST_CHECK ( nRequired == 1 ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; BOOST_CHECK ( ! IsMine ( partialkeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 5 ) ; } } BOOST_AUTO_TEST_CASE ( multisig_Sig@@ n ) { CBasicKeyStore keystore ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { key [ i ] . MakeNewKey ( true ) ; keystore . AddKey ( key [ i ] ) ; } CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; CTransaction txFrom ; txFrom . vout . resize ( 3 ) ; txFrom . vout [ 0 ] . scriptPubKey = a_and_b ; txFrom . vout [ 1 ] . scriptPubKey = a_or_b ; txFrom . vout [ 2 ] . scriptPubKey = escrow ; CTransaction txTo [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { txTo [ i ] . vin . resize ( 1 ) ; txTo [ i ] . vout . resize ( 1 ) ; txTo [ i ] . vin [ 0 ] . prevout . n = i ; txTo [ i ] . vin [ 0 ] . prevout . hash = txFrom . GetHash ( ) ; txTo [ i ] . vout [ 0 ] . nValue = 1 ; } for ( int i = 0 ; i < 3 ; i ++ ) { BOOST_CHECK_MESSAGE ( SignSignature ( keystore , txFrom , txTo [ i ] , 0 ) , strprintf ( " SignSignature ▁ % d " , i ) ) ; } } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
<DOCUMENT_ID="goldcoin/@@ gldcoin@@ /tree/master/Build@@ Deps/de@@ ps/boost/libs/polyg@@ on/example/@@ voronoi_visualizer.cpp"> # include < iostream > # include < vector > # include < QtOpen@@ GL / QGLWidget > # include < QtGui / QtGui > # include < boost / polygon / polygon . hpp > # include < boost / polygon / voronoi . hpp > using namespace boost :: polygon ; # include " voronoi _ visual _ utils . hpp " class GLWidget : public QGLWidget { Q_OBJECT public : explicit GLWidget ( QMainWindow * parent = NULL ) : QGLWidget ( QGLFormat ( QGL :: SampleBuffers ) , parent ) , primary_edges_only_ ( false ) , internal_edges_only_ ( false ) { startTimer ( 40 ) ; } QSize sizeHint ( ) const { return QSize ( 600 , 600 ) ; } void build ( const QString & file_path ) { clear ( ) ; read_data ( file_path ) ; if ( ! brect_initialized_ ) { return ; } construct_brect ( ) ; construct_voronoi ( point_data_ . begin ( ) , point_data_ . end ( ) , segment_data_ . begin ( ) , segment_data_ . end ( ) , & vd_ ) ; for ( const_edge_iterator it = vd_ . edges ( ) . begin ( ) ; it != vd_ . edges ( ) . end ( ) ; ++ it ) { if ( ! it -> is_finite ( ) ) { color_exterior ( & ( * it ) ) ; } } update_view_port ( ) ; } void show_primary_edges_only ( ) { primary_edges_only_ ^= true ; } void show_internal_edges_only ( ) { internal_edges_only_ ^= true ; } protected : void initialize@@ GL ( ) { glHint ( GL_POINT_SMOOTH_@@ HINT , GL_NIC@@ EST ) ; glBlendFunc ( GL_SRC@@ _ALPHA , GL_ONE_MINUS_S@@ RC_ALPHA ) ; glEnable ( GL_BL@@ END ) ; glEnable ( GL_POINT_SMOOTH ) ; } void paintGL ( ) { qglClearColor ( QColor :: fromRgb ( 255 , 255 , 255 ) ) ; glClear ( GL_COLOR_BUFFER_BIT | GL_DEP@@ TH_BUFFER_BIT ) ; draw_points ( ) ; draw_segments ( ) ; draw_vertices ( ) ; draw_edges ( ) ; } void resizeGL ( int width , int height ) { int side = qMin ( width , height ) ; glViewport ( ( width - side ) / 2 , ( height - side ) / 2 , side , side ) ; } void timerEvent ( QTimerEvent * e ) { update ( ) ; } private : typedef double coordinate_type ; typedef point_data < coordinate_type > point_type ; typedef segment_data < coordinate_type > segment_type ; typedef rectangle_@@ data < coordinate_type > rect_type ; typedef voronoi_builder < int > VB ; typedef voronoi_di@@ agram < coordinate_type > VD ; typedef VD :: cell_type cell_type ; typedef VD :: cell_type :: source_index_type source_index_type ; typedef VD :: cell_type :: source_category_type source_category_type ; typedef VD :: edge_type edge_type ; typedef VD :: cell_container_type cell_container_type ; typedef VD :: cell_container_type vertex_container_type ; typedef VD :: edge_container_type edge_container_type ; typedef VD :: const_cell_iterator const_cell_iterator ; typedef VD :: const_vertex_iterator const_vertex_iterator ; typedef VD :: const_edge_iterator const_edge_iterator ; static const std :: size_t EXTERNAL_COLOR = 1 ; void clear ( ) { brect_initialized_ = false ; point_data_ . clear ( ) ; segment_data_ . clear ( ) ; vd_ . clear ( ) ; } void read_data ( const QString & file_path ) { QFile data ( file_path ) ; if ( ! data . open ( QFile :: ReadOnly ) ) { QMessageBox :: warning ( this , tr ( " Voronoi ▁ Visualizer " ) , tr ( " Disable ▁ to ▁ open ▁ file ▁ " ) + file_path ) ; } QTextStream in_stream ( & data ) ; std :: size_t num_points , num_segments ; int x1 , y1 , x2 , y2 ; in_stream >> num_points ; for ( std :: size_t i = 0 ; i < num_points ; ++ i ) { in_stream >> x1 >> y1 ; point_type p ( x1 , y1 ) ; update_brect ( p ) ; point_data_ . push_back ( p ) ; } in_stream >> num_segments ; for ( std :: size_t i = 0 ; i < num_segments ; ++ i ) { in_stream >> x1 >> y1 >> x2 >> y2 ; point_type lp ( x1 , y1 ) ; point_type hp ( x2 , y2 ) ; update_brect ( lp ) ; update_brect ( hp ) ; segment_data_ . push_back ( segment_type ( lp , hp ) ) ; } in_stream . flush ( ) ; } void update_brect ( const point_type & point ) { if ( brect_initialized_ ) { encompass ( brect_ , point ) ; } else { set_points ( brect_ , point , point ) ; brect_initialized_ = true ; } } void construct_brect ( ) { double side = ( std :: max ) ( xh ( brect_ ) - xl ( brect_ ) , yh ( brect_ ) - yl ( brect_ ) ) ; center ( shift_ , brect_ ) ; set_points ( brect_ , shift_ , shift_ ) ; bloat ( brect_ , side * 1.2 ) ; } void color_exterior ( const VD :: edge_type * edge ) { if ( edge -> color ( ) == EXTERNAL_COLOR ) { return ; } edge -> color ( EXTERNAL_COLOR ) ; edge -> twin ( ) -> color ( EXTERNAL_COLOR ) ; const VD :: vertex_type * v = edge -> vertex1 ( ) ; if ( v == NULL || ! edge -> is_primary ( ) ) { return ; } v -> color ( EXTERNAL_COLOR ) ; const VD :: edge_type * e = v -> incident_edge ( ) ; do { color_exterior ( e ) ; e = e -> rot_next ( ) ; } while ( e != v -> incident_edge ( ) ) ; } void update_view_port ( ) { glMatrixMode ( GL_PROJ@@ ECTION ) ; glLoad@@ Identity ( ) ; rect_type view_rect = brect_ ; deconvolve ( view_rect , shift_ ) ; glOr@@ tho ( xl ( view_rect ) , xh ( view_rect ) , yl ( view_rect ) , yh ( view_rect ) , - 1.0 , 1.0 ) ; glMatrixMode ( GL_MODEL@@ VIEW ) ; } void draw_points ( ) { glColor3f ( 0.0f , 0.5f , 1.0f ) ; glPointSize ( 9 ) ; glBegin ( GL_POINTS ) ; for ( std :: size_t i = 0 ; i < point_data_ . size ( ) ; ++ i ) { point_type point = point_data_ [ i ] ; deconvolve ( point , shift_ ) ; glVertex2f ( point . x ( ) , point . y ( ) ) ; } for ( std :: size_t i = 0 ; i < segment_data_ . size ( ) ; ++ i ) { point_type lp = low ( segment_data_ [ i ] ) ; lp = deconvolve ( lp , shift_ ) ; glVertex2f ( lp . x ( ) , lp . y ( ) ) ; point_type hp = high ( segment_data_ [ i ] ) ; hp = deconvolve ( hp , shift_ ) ; glVertex2f ( hp . x ( ) , hp . y ( ) ) ; } glEnd ( ) ; } void draw_segments ( ) { glColor3f ( 0.0f , 0.5f , 1.0f ) ; glLineWidth ( 2.7f ) ; glBegin ( GL_LINES ) ; for ( std :: size_t i = 0 ; i < segment_data_ . size ( ) ; ++ i ) { point_type lp = low ( segment_data_ [ i ] ) ; lp = deconvolve ( lp , shift_ ) ; glVertex2f ( lp . x ( ) , lp . y ( ) ) ; point_type hp = high ( segment_data_ [ i ] ) ; hp = deconvolve ( hp , shift_ ) ; glVertex2f ( hp . x ( ) , hp . y ( ) ) ; } glEnd ( ) ; } void draw_vertices ( ) { glColor3f ( 0.0f , 0.0f , 0.0f ) ; glPointSize ( 6 ) ; glBegin ( GL_POINTS ) ; for ( const_vertex_iterator it = vd_ . vertices ( ) . begin ( ) ; it != vd_ . vertices ( ) . end ( ) ; ++ it ) { if ( internal_edges_only_ && ( it -> color ( ) == EXTERNAL_COLOR ) ) { continue ; } point_type vertex ( it -> x ( ) , it -> y ( ) ) ; vertex = deconvolve ( vertex , shift_ ) ; glVertex2f ( vertex . x ( ) , vertex . y ( ) ) ; } glEnd ( ) ; } void draw_edges ( ) { glColor3f ( 0.0f , 0.0f , 0.0f ) ; glLineWidth ( 1.7f ) ; for ( const_edge_iterator it = vd_ . edges ( ) . begin ( ) ; it != vd_ . edges ( ) . end ( ) ; ++ it ) { if ( primary_edges_only_ && ! it -> is_primary ( ) ) { continue ; } if ( internal_edges_only_ && ( it -> color ( ) == EXTERNAL_COLOR ) ) { continue ; } std :: vector < point_type > samples ; if ( ! it -> is_finite ( ) ) { clip_infinite_edge ( * it , & samples ) ; } else { point_type vertex0 ( it -> vertex0 ( ) -> x ( ) , it -> vertex0 ( ) -> y ( ) ) ; samples . push_back ( vertex0 ) ; point_type vertex1 ( it -> vertex1 ( ) -> x ( ) , it -> vertex1 ( ) -> y ( ) ) ; samples . push_back ( vertex1 ) ; if ( it -> is_curved ( ) ) { sample_curved_edge ( * it , & samples ) ; } } glBegin ( GL_LINE_STRI@@ P ) ; for ( std :: size_t i = 0 ; i < samples . size ( ) ; ++ i ) { point_type vertex = deconvolve ( samples [ i ] , shift_ ) ; glVertex2f ( vertex . x ( ) , vertex . y ( ) ) ; } glEnd ( ) ; } } void clip_infinite_edge ( const edge_type & edge , std :: vector < point_type > * clipped_edge ) { const cell_type & cell1 = * edge . cell ( ) ; const cell_type & cell2 = * edge . twin ( ) -> cell ( ) ; point_type origin , direction ; if ( cell1 . contains_point ( ) && cell2 . contains_point ( ) ) { point_type p1 = retrieve_point ( cell1 ) ; point_type p2 = retrieve_point ( cell2 ) ; origin . x ( ( p1 . x ( ) + p2 . x ( ) ) * 0.5 ) ; origin . y ( ( p1 . y ( ) + p2 . y ( ) ) * 0.5 ) ; direction . x ( p1 . y ( ) - p2 . y ( ) ) ; direction . y ( p2 . x ( ) - p1 . x ( ) ) ; } else { origin = cell1 . contains_segment ( ) ? retrieve_point ( cell2 ) : retrieve_point ( cell1 ) ; segment_type segment = cell1 . contains_segment ( ) ? retrieve_segment ( cell1 ) : retrieve_segment ( cell2 ) ; coordinate_type dx = high ( segment ) . x ( ) - low ( segment ) . x ( ) ; coordinate_type dy = high ( segment ) . y ( ) - low ( segment ) . y ( ) ; if ( ( low ( segment ) == origin ) ^ cell1 . contains_point ( ) ) { direction . x ( dy ) ; direction . y ( - dx ) ; } else { direction . x ( - dy ) ; direction . y ( dx ) ; } } coordinate_type side = xh ( brect_ ) - xl ( brect_ ) ; coordinate_type koef = side / ( std :: max ) ( fabs ( direction . x ( ) ) , fabs ( direction . y ( ) ) ) ; if ( edge . vertex0 ( ) == NULL ) { clipped_edge -> push_back ( point_type ( origin . x ( ) - direction . x ( ) * koef , origin . y ( ) - direction . y ( ) * koef ) ) ; } else { clipped_edge -> push_back ( point_type ( edge . vertex0 ( ) -> x ( ) , edge . vertex0 ( ) -> y ( ) ) ) ; } if ( edge . vertex1 ( ) == NULL ) { clipped_edge -> push_back ( point_type ( origin . x ( ) + direction . x ( ) * koef , origin . y ( ) + direction . y ( ) * koef ) ) ; } else { clipped_edge -> push_back ( point_type ( edge . vertex1 ( ) -> x ( ) , edge . vertex1 ( ) -> y ( ) ) ) ; } } void sample_curved_edge ( const edge_type & edge , std :: vector < point_type > * sampled_edge ) { coordinate_type max_dist = 1E - 3 * ( xh ( brect_ ) - xl ( brect_ ) ) ; point_type point = edge . cell ( ) -> contains_point ( ) ? retrieve_point ( * edge . cell ( ) ) : retrieve_point ( * edge . twin ( ) -> cell ( ) ) ; segment_type segment = edge . cell ( ) -> contains_point ( ) ? retrieve_segment ( * edge . twin ( ) -> cell ( ) ) : retrieve_segment ( * edge . cell ( ) ) ; voronoi_visual_utils < coordinate_type > :: discretize ( point , segment , max_dist , sampled_edge ) ; } point_type retrieve_point ( const cell_type & cell ) { source_index_type index = cell . source_index ( ) ; source_category_type category = cell . source_category ( ) ; if ( category == SOURCE_CATEGORY_SINGLE_POINT ) { return point_data_ [ index ] ; } index -= point_data_ . size ( ) ; if ( category == SOURCE_CATEGORY_SEGMENT_@@ START_POINT ) { return low ( segment_data_ [ index ] ) ; } else { return high ( segment_data_ [ index ] ) ; } } segment_type retrieve_segment ( const cell_type & cell ) { source_index_type index = cell . source_index ( ) - point_data_ . size ( ) ; return segment_data_ [ index ] ; } point_type shift_ ; std :: vector < point_type > point_data_ ; std :: vector < segment_type > segment_data_ ; rect_type brect_ ; VB vb_ ; VD vd_ ; bool brect_initialized_ ; bool primary_edges_only_ ; bool internal_edges_only_ ; } ; class MainWindow : public QWidget { Q_OBJECT public : MainWindow ( ) { glWidget_ = new GLWidget ( ) ; file_dir_ = QDir ( QDir :: currentPath ( ) , tr ( " * . txt " ) ) ; file_name_ = tr ( " " ) ; QHBoxLayout * centralLayout = new QHBoxLayout ; centralLayout -> addWidget ( glWidget_ ) ; centralLayout -> addLayout ( create_file_layout ( ) ) ; setLayout ( centralLayout ) ; update_file_list ( ) ; setWindowTitle ( tr ( " Voronoi ▁ Visualizer " ) ) ; layout ( ) -> setSizeConstraint ( QLayout :: SetFixedSize ) ; } private slots : void primary_edges_only ( ) { glWidget_ -> show_primary_edges_only ( ) ; } void internal_edges_only ( ) { glWidget_ -> show_internal_edges_only ( ) ; } void browse ( ) { QString new_path = QFileDialog :: getExistingDirectory ( 0 , tr ( " Choose ▁ Directory " ) , file_dir_ . absolutePath ( ) ) ; if ( new_path . isEmpty ( ) ) { return ; } file_dir_ . setPath ( new_path ) ; update_file_list ( ) ; } void build ( ) { file_name_ = file_list_ -> currentItem ( ) -> text ( ) ; QString file_path = file_dir_ . filePath ( file_name_ ) ; message_label_ -> setText ( " Building . . . " ) ; glWidget_ -> build ( file_path ) ; message_label_ -> setText ( " Double ▁ click ▁ the ▁ item ▁ to ▁ build ▁ voronoi ▁ diagram : " ) ; setWindowTitle ( tr ( " Voronoi ▁ Visualizer ▁ - ▁ " ) + file_path ) ; } void print_scr ( ) { if ( ! file_name_ . isEmpty ( ) ) { QImage screenshot = glWidget_ -> grabFrameBuffer ( true ) ; QString output_file = file_dir_ . absolutePath ( ) + tr ( " / " ) + file_name_ . left ( file_name_ . indexOf ( ' . ' ) ) + tr ( " . png " ) ; screenshot . save ( output_file , 0 , - 1 ) ; } } private : QGridLayout * create_file_layout ( ) { QGridLayout * file_layout = new QGridLayout ; message_label_ = new QLabel ( " Double ▁ click ▁ item ▁ to ▁ build ▁ voronoi ▁ diagram : " ) ; file_list_ = new QListWidget ( ) ; file_list_ -> connect ( file_list_ , SIGNAL ( itemDoubleClicked ( QListWidgetItem * ) ) , this , SLOT ( build ( ) ) ) ; QCheckBox * primary_checkbox = new QCheckBox ( " Show ▁ primary ▁ edges ▁ only . " ) ; connect ( primary_checkbox , SIGNAL ( clicked ( ) ) , this , SLOT ( primary_edges_only ( ) ) ) ; QCheckBox * internal_checkbox = new QCheckBox ( " Show ▁ internal ▁ edges ▁ only . " ) ; connect ( internal_checkbox , SIGNAL ( clicked ( ) ) , this , SLOT ( internal_edges_only ( ) ) ) ; QPushButton * browse_button = new QPushButton ( tr ( " Browse ▁ Input ▁ Directory " ) ) ; connect ( browse_button , SIGNAL ( clicked ( ) ) , this , SLOT ( browse ( ) ) ) ; browse_button -> setMinimumHeight ( 50 ) ; QPushButton * print_scr_button = new QPushButton ( tr ( " Make ▁ Screenshot " ) ) ; connect ( print_scr_button , SIGNAL ( clicked ( ) ) , this , SLOT ( print_scr ( ) ) ) ; print_scr_button -> setMinimumHeight ( 50 ) ; file_layout -> addWidget ( message_label_ , 0 , 0 ) ; file_layout -> addWidget ( file_list_ , 1 , 0 ) ; file_layout -> addWidget ( primary_checkbox , 2 , 0 ) ; file_layout -> addWidget ( internal_checkbox , 3 , 0 ) ; file_layout -> addWidget ( browse_button , 4 , 0 ) ; file_layout -> addWidget ( print_scr_button , 5 , 0 ) ; return file_layout ; } void update_file_list ( ) { QFileInfoList list = file_dir_ . entryInfoList ( ) ; file_list_ -> clear ( ) ; if ( file_dir_ . count ( ) == 0 ) { return ; } QFileInfoList :: const_iterator it ; for ( it = list . begin ( ) ; it != list . end ( ) ; it ++ ) { file_list_ -> addItem ( it -> fileName ( ) ) ; } file_list_ -> setCurrentRow ( 0 ) ; } QDir file_dir_ ; QString file_name_ ; GLWidget * glWidget_ ; QListWidget * file_list_ ; QLabel * message_label_ ; } ; int main ( int argc , char * argv [ ] ) { QApplication app ( argc , argv ) ; MainWindow window ; window . show ( ) ; return app . exec ( ) ; } # include " voronoi _ visualizer . moc " </DOCUMENT>
<DOCUMENT_ID="Ra@@ zZziel/@@ sc_pong/tree/master/src/scfont@@ .cpp"> # include < stdlib . h > # include < string . h > # include " SDL / SDL . h " # include " SDL / SDL _ image . h " # include " scfont . h " ScFont * ScLoadFont ( const char * filename ) { ScFont * font = ( ScFont * ) malloc ( sizeof ( ScFont ) ) ; FILE * file = fopen ( filename , " r " ) ; fread ( ( void * ) & font -> header , sizeof ( ScFontHeader ) , 1 , file ) ; int n_offsets = font -> header . highIndex - font -> header . lowIndex ; Uint32 * offsets = ( Uint32 * ) malloc ( sizeof ( Uint32 ) * ( n_offsets + 1 ) ) ; fseek ( file , sizeof ( ScFontHeader ) , SEEK_SET ) ; fread ( ( void * ) offsets , sizeof ( Uint32 ) , n_offsets , file ) ; fseek ( file , 0 , SEEK_@@ END ) ; offsets [ n_offsets ] = ftell ( file ) ; font -> letters = ( ScLetter * ) malloc ( sizeof ( ScLetter ) * ( n_offsets + 1 ) ) ; for ( int i = 1 ; i <= n_offsets ; i ++ ) { if ( offsets [ i - 1 ] ) { fseek ( file , offsets [ i - 1 ] , SEEK_SET ) ; fread ( ( void * ) & font -> letters [ i ] . header , sizeof ( ScLetterHeader ) , 1 , file ) ; int next_offset = offsets [ i ] ; for ( int o = 0 ; ! next_offset ; o ++ ) { next_offset = offsets [ i + o ] ; } font -> letters [ i ] . n_pixels = next_offset - ( offsets [ i - 1 ] + sizeof ( ScLetterHeader ) ) - 1 ; font -> letters [ i ] . pixels = ( Uint8 * ) malloc ( sizeof ( Uint8 ) * font -> letters [ i ] . n_pixels ) ; fseek ( file , ( offsets [ i - 1 ] + sizeof ( ScLetterHeader ) ) , SEEK_SET ) ; fread ( ( void * ) font -> letters [ i ] . pixels , sizeof ( Uint8 ) , font -> letters [ i ] . n_pixels , file ) ; } else font -> letters [ i ] . n_pixels = - 1 ; } font -> letters [ 0 ] . n_pixels = 0 ; font -> letters [ 0 ] . header . x = 0 ; font -> letters [ 0 ] . header . y = 0 ; font -> letters [ 0 ] . header . h = 0 ; font -> letters [ 0 ] . header . w = font -> header . maxWidth / 2 ; free ( offsets ) ; fclose ( file ) ; return font ; } ScPalette * ScLoadPalette ( const char * filename ) { ScPalette * palette = ( ScPalette * ) malloc ( sizeof ( ScPalette ) ) ; SDL_Surface * s_palette ; if ( ( s_palette = SDL_Display@@ Format ( IMG_Load ( filename ) ) ) == NULL ) { fprintf ( stderr , " ERROR : ▁ Cannot ▁ load ▁ palette ▁ ' % s ' " , filename ) ; exit ( 1 ) ; } memcpy ( * palette , s_palette -> pixels , s_palette -> format -> BytesPerPixel * s_palette -> w ) ; SDL_FreeSurface ( s_palette ) ; return palette ; } SDL_Surface * ScRenderChar ( unsigned const char car , ScFont * font , ScColor * color ) { SDL_Surface * screen = SDL_GetVideoSurface ( ) ; int index = car - font -> header . lowIndex ; if ( ( car < font -> header . lowIndex ) || ( car > font -> header . highIndex ) || ( font -> letters [ index ] . n_pixels < 0 ) ) { fprintf ( stderr , " ERROR ▁ ( ScRenderChar ) : ▁ Invalid ▁ character ▁ index ▁ % d \n " , car ) ; return NULL ; } SDL_Surface * letter = SDL_CreateRGBSurface ( SDL_SWSURFACE , font -> letters [ index ] . header . w , font -> letters [ index ] . header . h , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; if ( font -> letters [ index ] . header . h > 0 ) { char * pixels = ( char * ) letter -> pixels - letter -> format -> BytesPerPixel ; for ( int p = 0 ; p < font -> letters [ index ] . n_pixels ; p ++ ) { Uint8 skip = font -> letters [ index ] . pixels [ p ] >> 3 ; Uint8 gamma = font -> letters [ index ] . pixels [ p ] & 7 ; pixels += skip * letter -> format -> BytesPerPixel + letter -> format -> BytesPerPixel ; memcpy ( pixels , * color + gamma , letter -> format -> BytesPerPixel ) ; } SDL_SetColorKey ( letter , SDL_SRCCOLORKEY | SDL_RLEACCEL , 0 ) ; } SDL_Surface * final_letter = SDL_CreateRGBSurface ( SDL_SWSURFACE , font -> letters [ index ] . header . w , font -> header . maxHeight , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; SDL_Rect offset = { font -> letters [ index ] . header . x , font -> letters [ index ] . header . y , 0 , 0 } ; SDL_BlitSurface ( letter , NULL , final_letter , & offset ) ; SDL_FreeSurface ( letter ) ; SDL_SetColorKey ( final_letter , SDL_SRCCOLORKEY | SDL_RLEACCEL , 0 ) ; return final_letter ; } int calculateWidth ( const unsigned char * text , ScFont * font , char delim ) { int width = 0 ; while ( * text ) { if ( * text != delim ) width += font -> letters [ * text - font -> header . lowIndex ] . header . w + 1 ; text ++ ; } return width - 1 ; } SDL_Surface * ScRenderText ( const char * text , ScFont * font , ScColor * color , ScColor * color_hi , char delim ) { SDL_Surface * screen = SDL_GetVideoSurface ( ) ; SDL_Surface * s_text = SDL_CreateRGBSurface ( SDL_SWSURFACE , calculateWidth ( ( unsigned char * ) text , font , delim ) , font -> header . maxHeight , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; SDL_SetColorKey ( s_text , SDL_SRCCOLORKEY | SDL_RLEACCEL , 0 ) ; SDL_Surface * s_char ; SDL_Rect offset = { 0 , 0 , 0 , 0 } ; if ( color_hi ) { ScColor * actual_color = color ; while ( * text ) { if ( * text == delim ) { if ( actual_color == color ) actual_color = color_hi ; else actual_color = color ; } else { if ( ( s_char = ScRenderChar ( * text , font , actual_color ) ) ) { SDL_BlitSurface ( s_char , NULL , s_text , & offset ) ; offset . x += s_char -> w + 1 ; SDL_FreeSurface ( s_char ) ; } } text ++ ; } } else { while ( * text ) { if ( * text != delim ) { if ( ( s_char = ScRenderChar ( * text , font , color ) ) ) { SDL_BlitSurface ( s_char , NULL , s_text , & offset ) ; offset . x += s_char -> w + 1 ; SDL_FreeSurface ( s_char ) ; } } text ++ ; } } return s_text ; } ScColor * ScGetColor ( const ScPalette * palette , int index ) { ScColor * color = ( ScColor * ) malloc ( sizeof ( ScColor ) ) ; memcpy ( * color , * palette + ( index * MAX_GAMMA ) , sizeof ( ScColor ) ) ; return color ; } void ScTestFont ( ScFont * font , ScPalette * palette ) { # define TEST_SDL SDL_Surface * screen = SDL_GetVideoSurface ( ) ; SDL_Fill@@ Rect ( screen , NULL , SDL_Map@@ RGB ( SDL_GetVideoSurface ( ) -> format , 255 , 255 , 255 ) ) ; SDL_Flip ( screen ) ; # ifdef TEST_SDL SDL_Rect offset = { 10 , 10 , 0 , 0 } ; SDL_BlitSurface ( ScRenderText ( " El ▁ veloz ▁ murci � ago ▁ hind " , font , ScGetColor ( palette , 1 ) ) , NULL , screen , & offset ) ; offset . y += font -> header . maxHeight + 2 ; SDL_BlitSurface ( ScRenderText ( " Juiporent@@ enderlas " , font , ScGetColor ( palette , 5 ) ) , NULL , screen , & offset ) ; offset . y += font -> header . maxHeight + 2 ; SDL_BlitSurface ( ScRenderText ( " _ S _ ingle ▁ Player " , font , ScGetColor ( palette , 1 ) , ScGetColor ( palette , 2 ) , ' _ ' ) , NULL , screen , & offset ) ; offset . y += font -> header . maxHeight + 2 ; # endif for ( int i = font -> header . lowIndex ; i <= font -> header . highIndex ; i ++ ) { # ifdef TEST_SDL SDL_Surface * s_char = ScRenderChar ( i , font , ScGetColor ( palette , 2 ) ) ; if ( s_char ) { SDL_BlitSurface ( s_char , NULL , screen , & offset ) ; SDL_FreeSurface ( s_char ) ; } if ( ( offset . x += font -> header . maxWidth + 2 ) > ( screen -> w - font -> header . maxWidth - 10 ) ) { offset . x = 10 ; offset . y += font -> header . maxHeight + 2 ; } # else int index = i - font -> header . lowIndex ; int x = 1 ; for ( int p = 0 ; p < font -> letters [ index ] . n_pixels ; p ++ ) printf ( " % d ▁ " , ( font -> letters [ i ] . pixels [ p ] >> 3 ) ) ; printf ( " \n " ) ; for ( int p = 0 ; p < font -> letters [ index ] . n_pixels ; p ++ ) { Uint8 skip = font -> letters [ index ] . pixels [ p ] >> 3 ; Uint8 color = font -> letters [ index ] . pixels [ p ] & 7 ; for ( int j = 0 ; j < skip ; j ++ ) { printf ( " ▁ " ) ; if ( x ++ == font -> letters [ index ] . header . w ) { printf ( " \n " ) ; x = 1 ; } } printf ( " % d " , color ) ; if ( x ++ == font -> letters [ index ] . header . w ) { printf ( " \n " ) ; x = 1 ; } } printf ( " \n test ▁ end \n " ) ; getchar ( ) ; # endif } SDL_Flip ( screen ) ; * screen = * SDL_CreateRGBSurface ( SDL_SWSURFACE , screen -> w , screen -> h , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; getchar ( ) ; } </DOCUMENT>
<DOCUMENT_ID="ph@@ amelin/ardupilot/tree/master/libraries/@@ AP_Frsky_Telem/AP_Frsky_Telem@@ .cpp"> # include " AP _ Frsky _ Telem . h " # include < AP_InertialSensor / AP_InertialSensor . h > # include < GCS_MAV@@ Link / GCS . h > # include < stdio . h > extern const AP_HAL :: HAL & hal ; ObjectArray < mavlink_statustext_t > AP_Frsky_Telem :: _statustext_queue ( FRSKY_TELE@@ M_PA@@ YLOAD_STATUS_CAPACITY ) ; AP_Frsky_Telem :: AP_Frsky_Telem ( AP_AHRS & ahrs , const AP_BattMonitor & battery , const RangeFinder & rng ) : _ahrs ( ahrs ) , _battery ( battery ) , _rng ( rng ) { } void AP_Frsky_Telem :: init ( const AP_SerialManager & serial_manager , const uint8_t mav_type , const uint32_t * ap_valuep ) { if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_D , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_D ; } else if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_SPort , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_SPort ; } else if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough ; gcs ( ) . register_frsk@@ y_telem@@ etry_callback ( this ) ; if ( _frame_string == nullptr ) { queue_message ( MAV_SEVERITY_INFO , AP :: fwversion ( ) . fw_string ) ; } else { char firmware_buf [ MAVLINK_@@ MSG_ST@@ ATUSTEXT_FIELD_@@ TEXT_LEN + 1 ] ; snprintf ( firmware_buf , sizeof ( firmware_buf ) , " % s ▁ % s " , AP :: fwversion ( ) . fw_string , _frame_string ) ; queue_message ( MAV_SEVERITY_INFO , firmware_buf ) ; } _params . mav_type = mav_type ; if ( ap_valuep == nullptr ) { _ap . value = 0x2000 ; _ap . valuep = & _ap . value ; } else { _ap . valuep = ap_valuep ; } } if ( _port != nullptr ) { hal . scheduler -> register_io_pro@@ cess ( FUNCTOR_@@ BIND_MEMBER ( & AP_Frsky_Telem :: tick , void ) ) ; _port -> set_flow_control ( AP_HAL :: UARTDriver :: FLOW_CON@@ TROL_DISABLE ) ; } } void AP_Frsky_Telem :: send_SPort_Passthrough ( void ) { int16_t numc ; numc = _port -> available ( ) ; if ( numc < 0 ) { return ; } if ( _port -> txspace ( ) < 19 ) { return ; } uint8_t prev_byte = 0 ; for ( int16_t i = 0 ; i < numc ; i ++ ) { prev_byte = _passthrough . new_byte ; _passthrough . new_byte = _port -> read ( ) ; } if ( ( prev_byte == START_STOP_SPORT ) && ( _passthrough . new_byte == SENSOR_ID_28 ) ) { if ( _passthrough . send_attiandrng ) { _passthrough . send_attiandrng = false ; } else { _passthrough . send_attiandrng = true ; uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - _passthrough . params_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 7 , calc_param ( ) ) ; _passthrough . params_timer = AP_HAL :: millis ( ) ; return ; } check_sensor_status_flags ( ) ; check_ekf_status ( ) ; if ( get_next_msg_chunk ( ) ) { send_uint32 ( DIY_FIRST_ID , _msg_chunk . chunk ) ; return ; } if ( ( now - _passthrough . ap_status_timer ) >= 500 ) { if ( ( ( * _ap . valuep ) & AP_INITI@@ ALIZE@@ D_FLAG ) > 0 ) { send_uint32 ( DIY_FIRST_ID + 1 , calc_ap_status ( ) ) ; _passthrough . ap_status_timer = AP_HAL :: millis ( ) ; } return ; } if ( ( now - _passthrough . batt_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 3 , calc_batt ( 0 ) ) ; _passthrough . batt_timer = AP_HAL :: millis ( ) ; return ; } if ( _battery . num_instances ( ) > 1 ) { if ( ( now - _passthrough . batt_timer2 ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 8 , calc_batt ( 1 ) ) ; _passthrough . batt_timer2 = AP_HAL :: millis ( ) ; return ; } } if ( ( now - _passthrough . gps_status_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 2 , calc_gps_status ( ) ) ; _passthrough . gps_status_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . home_timer ) >= 500 ) { send_uint32 ( DIY_FIRST_ID + 4 , calc_home ( ) ) ; _passthrough . home_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . velandyaw_timer ) >= 500 ) { send_uint32 ( DIY_FIRST_ID + 5 , calc_velandyaw ( ) ) ; _passthrough . velandyaw_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . gps_latlng_timer ) >= 1000 ) { send_uint32 ( GPS_LONG_LATI@@ _FIRST_ID , calc_gps_latlng ( & _passthrough . send_latitude ) ) ; if ( ! _passthrough . send_latitude ) { _passthrough . gps_latlng_timer = AP_HAL :: millis ( ) ; } return ; } } send_uint32 ( DIY_FIRST_ID + 6 , calc_attiandrng ( ) ) ; } } void AP_Frsky_Telem :: send_SPort ( void ) { int16_t numc ; numc = _port -> available ( ) ; if ( numc < 0 ) { return ; } if ( _port -> txspace ( ) < 19 ) { return ; } for ( int16_t i = 0 ; i < numc ; i ++ ) { int16_t readbyte = _port -> read ( ) ; if ( _SPort . sport_status == false ) { if ( readbyte == START_STOP_SPORT ) { _SPort . sport_status = true ; } } else { switch ( readbyte ) { case SENSOR_ID_F@@ AS : switch ( _SPort . fas_call ) { case 0 : send_uint32 ( DATA_ID_FUEL , ( uint16_t ) roundf ( _battery . capacity_remaining_pct ( ) ) ) ; break ; case 1 : send_uint32 ( DATA_ID_VFAS , ( uint16_t ) roundf ( _battery . voltage ( ) * 10.0f ) ) ; break ; case 2 : send_uint32 ( DATA_ID_CURRENT , ( uint16_t ) roundf ( _battery . current_amps ( ) * 10.0f ) ) ; break ; } if ( _SPort . fas_call ++ > 2 ) _SPort . fas_call = 0 ; break ; case SENSOR_ID_GPS : switch ( _SPort . gps_call ) { case 0 : calc_gps_position ( ) ; send_uint32 ( DATA_ID_GPS_LAT_BP , _gps . latdddmm ) ; break ; case 1 : send_uint32 ( DATA_ID_GPS_LAT_AP , _gps . latmmmm ) ; break ; case 2 : send_uint32 ( DATA_ID_GPS_LAT_NS , _gps . lat_ns ) ; break ; case 3 : send_uint32 ( DATA_ID_GPS_LONG_BP , _gps . londddmm ) ; break ; case 4 : send_uint32 ( DATA_ID_GPS_LONG_AP , _gps . lonmmmm ) ; break ; case 5 : send_uint32 ( DATA_ID_GPS_LONG_EW , _gps . lon_ew ) ; break ; case 6 : send_uint32 ( DATA_ID_GPS_SPEED_BP , _gps . speed_in_meter ) ; break ; case 7 : send_uint32 ( DATA_ID_GPS_SPEED_AP , _gps . speed_in_centimeter ) ; break ; case 8 : send_uint32 ( DATA_ID_GPS_ALT_BP , _gps . alt_gps_meters ) ; break ; case 9 : send_uint32 ( DATA_ID_GPS_ALT_AP , _gps . alt_gps_cm ) ; break ; case 10 : send_uint32 ( DATA_ID_GPS_COURS_BP , ( uint16_t ) ( ( _ahrs . yaw_sensor / 100 ) % 360 ) ) ; break ; } if ( _SPort . gps_call ++ > 10 ) _SPort . gps_call = 0 ; break ; case SENSOR_ID_VARIO : switch ( _SPort . vario_call ) { case 0 : calc_nav_alt ( ) ; send_uint32 ( DATA_ID_BARO_ALT_BP , _gps . alt_nav_meters ) ; break ; case 1 : send_uint32 ( DATA_ID_BARO_ALT_AP , _gps . alt_nav_cm ) ; break ; } if ( _SPort . vario_call ++ > 1 ) _SPort . vario_call = 0 ; break ; case SENSOR_ID_SP@@ 2UR : switch ( _SPort . various_call ) { case 0 : send_uint32 ( DATA_ID_TEMP2 , ( uint16_t ) ( AP :: gps ( ) . num_sats ( ) * 10 + AP :: gps ( ) . status ( ) ) ) ; break ; case 1 : send_uint32 ( DATA_ID_TEMP1 , _ap . control_mode ) ; break ; } if ( _SPort . various_call ++ > 1 ) _SPort . various_call = 0 ; break ; } _SPort . sport_status = false ; } } } void AP_Frsky_Telem :: send_D ( void ) { uint32_t now = AP_HAL :: millis ( ) ; if ( now - _D . last_200ms_frame >= 200 ) { _D . last_200ms_frame = now ; send_uint16 ( DATA_ID_TEMP2 , ( uint16_t ) ( AP :: gps ( ) . num_sats ( ) * 10 + AP :: gps ( ) . status ( ) ) ) ; send_uint16 ( DATA_ID_TEMP1 , _ap . control_mode ) ; send_uint16 ( DATA_ID_FUEL , ( uint16_t ) roundf ( _battery . capacity_remaining_pct ( ) ) ) ; send_uint16 ( DATA_ID_VFAS , ( uint16_t ) roundf ( _battery . voltage ( ) * 10.0f ) ) ; send_uint16 ( DATA_ID_CURRENT , ( uint16_t ) roundf ( _battery . current_amps ( ) * 10.0f ) ) ; calc_nav_alt ( ) ; send_uint16 ( DATA_ID_BARO_ALT_BP , _gps . alt_nav_meters ) ; send_uint16 ( DATA_ID_BARO_ALT_AP , _gps . alt_nav_cm ) ; } if ( now - _D . last_1000ms_frame >= 1000 ) { _D . last_1000ms_frame = now ; send_uint16 ( DATA_ID_GPS_COURS_BP , ( uint16_t ) ( ( _ahrs . yaw_sensor / 100 ) % 360 ) ) ; calc_gps_position ( ) ; if ( AP :: gps ( ) . status ( ) >= 3 ) { send_uint16 ( DATA_ID_GPS_LAT_BP , _gps . latdddmm ) ; send_uint16 ( DATA_ID_GPS_LAT_AP , _gps . latmmmm ) ; send_uint16 ( DATA_ID_GPS_LAT_NS , _gps . lat_ns ) ; send_uint16 ( DATA_ID_GPS_LONG_BP , _gps . londddmm ) ; send_uint16 ( DATA_ID_GPS_LONG_AP , _gps . lonmmmm ) ; send_uint16 ( DATA_ID_GPS_LONG_EW , _gps . lon_ew ) ; send_uint16 ( DATA_ID_GPS_SPEED_BP , _gps . speed_in_meter ) ; send_uint16 ( DATA_ID_GPS_SPEED_AP , _gps . speed_in_centimeter ) ; send_uint16 ( DATA_ID_GPS_ALT_BP , _gps . alt_gps_meters ) ; send_uint16 ( DATA_ID_GPS_ALT_AP , _gps . alt_gps_cm ) ; } } } void AP_Frsky_Telem :: tick ( void ) { if ( ! _initialised_uart ) { if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { _port -> begin ( AP_SERIALMANAGER_FRSKY_D_BAUD , AP_SERIALMANAGER_FRSKY_BUFSIZE_RX , AP_SERIALMANAGER_FRSKY_BUFSIZE_TX ) ; } else { _port -> begin ( AP_SERIALMANAGER_FRSKY_SP@@ ORT_BAUD , AP_SERIALMANAGER_FRSKY_BUFSIZE_RX , AP_SERIALMANAGER_FRSKY_BUFSIZE_TX ) ; } _initialised_uart = true ; } if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { send_D ( ) ; } else if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_SPort ) { send_SPort ( ) ; } else if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough ) { send_SPort_Passthrough ( ) ; } } void AP_Frsky_Telem :: calc_crc ( uint8_t byte ) { _crc += byte ; _crc += _crc >> 8 ; _crc &= 0xFF ; } void AP_Frsky_Telem :: send_crc ( void ) { send_byte ( 0xFF - _crc ) ; _crc = 0 ; } void AP_Frsky_Telem :: send_byte ( uint8_t byte ) { if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { if ( byte == START_STOP_D ) { _port -> write ( 0x5D ) ; _port -> write ( 0x3E ) ; } else if ( byte == BYTESTUFF_D ) { _port -> write ( 0x5D ) ; _port -> write ( 0x3D ) ; } else { _port -> write ( byte ) ; } } else { if ( byte == START_STOP_SPORT ) { _port -> write ( 0x7D ) ; _port -> write ( 0x5E ) ; } else if ( byte == BYTESTUFF_SPORT ) { _port -> write ( 0x7D ) ; _port -> write ( 0x5D ) ; } else { _port -> write ( byte ) ; } calc_crc ( byte ) ; } } void AP_Frsky_Telem :: send_uint32 ( uint16_t id , uint32_t data ) { send_byte ( 0x10 ) ; uint8_t * bytes = ( uint8_t * ) & id ; send_byte ( bytes [ 0 ] ) ; send_byte ( bytes [ 1 ] ) ; bytes = ( uint8_t * ) & data ; send_byte ( bytes [ 0 ] ) ; send_byte ( bytes [ 1 ] ) ; send_byte ( bytes [ 2 ] ) ; send_byte ( bytes [ 3 ] ) ; send_crc ( ) ; } void AP_Frsky_Telem :: send_uint16 ( uint16_t id , uint16_t data ) { _port -> write ( START_STOP_D ) ; uint8_t * bytes = ( uint8_t * ) & id ; send_byte ( bytes [ 0 ] ) ; bytes = ( uint8_t * ) & data ; send_byte ( bytes [ 0 ] ) ; send_byte ( bytes [ 1 ] ) ; } bool AP_Frsky_Telem :: get_next_msg_chunk ( void ) { if ( _statustext_queue . empty ( ) ) { return false ; } if ( _msg_chunk . repeats == 0 ) { uint8_t character = 0 ; _msg_chunk . chunk = 0 ; for ( int i = 3 ; i > - 1 && _msg_chunk . char_index < sizeof ( _statustext_queue [ 0 ] -> text ) ; i -- ) { character = _statustext_queue [ 0 ] -> text [ _msg_chunk . char_index ++ ] ; if ( ! character ) { break ; } _msg_chunk . chunk |= character << i * 8 ; } if ( ! character || ( _msg_chunk . char_index == sizeof ( _statustext_queue [ 0 ] -> text ) ) ) { _msg_chunk . char_index = 0 ; _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x4 ) << 21 ; _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x2 ) << 14 ; _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x1 ) << 7 ; } } if ( _msg_chunk . repeats ++ > 2 ) { _msg_chunk . repeats = 0 ; if ( _msg_chunk . char_index == 0 ) { _statustext_queue . remove ( 0 ) ; } } return true ; } void AP_Frsky_Telem :: queue_message ( MAV_SEVERITY severity , const char * text ) { mavlink_statustext_t statustext { } ; statustext . severity = severity ; strncpy ( statustext . text , text , sizeof ( statustext . text ) ) ; _statustext_queue . push_force ( statustext ) ; } void AP_Frsky_Telem :: check_sensor_status_flags ( void ) { uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - check_sensor_status_timer ) >= 5000 ) { if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_GPS ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ GPS ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_GY@@ RO ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Gyro ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_ACCEL ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Accel ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_MAG ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Compass ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_ABS@@ OLUTE_PRESSURE ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Baro ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_LASER_POSITION ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ LiDAR ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_OPTIC@@ AL_FLO@@ W ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ OptFlow ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_TERRAIN ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ or ▁ No ▁ Terrain ▁ Data " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_GEOF@@ ENCE ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Geofence ▁ Breach " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_AHRS ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ AHRS " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_RC_@@ RECEIVER ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " No ▁ RC ▁ Receiver " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_LOGGING ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Logging " ) ; check_sensor_status_timer = now ; } } } void AP_Frsky_Telem :: check_ekf_status ( void ) { float velVar , posVar , hgtVar , tasVar ; Vector3f magVar ; Vector2f offset ; if ( _ahrs . get_varian@@ ces ( velVar , posVar , hgtVar , magVar , tasVar , offset ) ) { uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - check_ekf_status_timer ) >= 10000 ) { if ( velVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ velocity ▁ variance " ) ; check_ekf_status_timer = now ; } if ( posVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ pos ▁ horiz ▁ variance " ) ; check_ekf_status_timer = now ; } if ( hgtVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ pos ▁ vert ▁ variance " ) ; check_ekf_status_timer = now ; } if ( magVar . length ( ) >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ compass ▁ variance " ) ; check_ekf_status_timer = now ; } if ( tasVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ terrain ▁ alt ▁ variance " ) ; check_ekf_status_timer = now ; } } } } uint32_t AP_Frsky_Telem :: calc_param ( void ) { uint32_t param = 0 ; if ( _paramID >= 5 ) { _paramID = 0 ; } _paramID ++ ; switch ( _paramID ) { case 1 : param = _params . mav_type ; break ; case 2 : case 3 : break ; case 4 : param = ( uint32_t ) roundf ( _battery . pack_capacity_mah ( 0 ) ) ; break ; case 5 : param = ( uint32_t ) roundf ( _battery . pack_capacity_mah ( 1 ) ) ; break ; } param = ( _paramID << PARAM_ID_OFFSET ) | ( param & PARAM_VALUE_@@ LIMIT ) ; return param ; } uint32_t AP_Frsky_Telem :: calc_gps_latlng ( bool * send_latitude ) { uint32_t latlng ; const Location & loc = AP :: gps ( ) . location ( 0 ) ; if ( ( * send_latitude ) == true ) { if ( loc . lat < 0 ) { latlng = ( ( labs ( loc . lat ) / 100 ) * 6 ) | 0x40000000 ; } else { latlng = ( ( labs ( loc . lat ) / 100 ) * 6 ) ; } ( * send_latitude ) = false ; } else { if ( loc . lng < 0 ) { latlng = ( ( labs ( loc . lng ) / 100 ) * 6 ) | 0xC0000000 ; } else { latlng = ( ( labs ( loc . lng ) / 100 ) * 6 ) | 0x80000000 ; } ( * send_latitude ) = true ; } return latlng ; } uint32_t AP_Frsky_Telem :: calc_gps_status ( void ) { const AP_GPS & gps = AP :: gps ( ) ; uint32_t gps_status ; gps_status = ( gps . num_sats ( ) < GPS_SATS_LIMIT ) ? gps . num_sats ( ) : GPS_SATS_LIMIT ; gps_status |= ( ( gps . status ( ) < GPS_STATUS_LIMIT ) ? gps . status ( ) : GPS_STATUS_LIMIT ) << GPS_STATUS_OFFSET ; gps_status |= prep_number ( roundf ( gps . get_hdop ( ) * 0.1f ) , 2 , 1 ) << GPS_HDO@@ P_OFFSET ; gps_status |= ( ( gps . status ( ) > GPS_STATUS_LIMIT ) ? gps . status ( ) - GPS_STATUS_LIMIT : 0 ) << GPS_ADV@@ STATUS_OFFSET ; const Location & loc = gps . location ( ) ; gps_status |= prep_number ( roundf ( loc . alt * 0.1f ) , 2 , 2 ) << GPS_AL@@ TMSL_OFFSET ; return gps_status ; } uint32_t AP_Frsky_Telem :: calc_batt ( uint8_t instance ) { uint32_t batt ; batt = ( ( ( uint16_t ) roundf ( _battery . voltage ( instance ) * 10.0f ) ) & BATT_VOL@@ TAGE_LIMIT ) ; batt |= prep_number ( roundf ( _battery . current_amps ( instance ) * 10.0f ) , 2 , 1 ) << BATT_CURRENT_@@ OFFSET ; batt |= ( ( _battery . consumed_mah ( instance ) < BATT_TOTALMAH_LIMIT ) ? ( ( uint16_t ) roundf ( _battery . consumed_mah ( instance ) ) & BATT_TOTALMAH_LIMIT ) : BATT_TOTALMAH_LIMIT ) << BATT_TOTALMAH_OFFSET ; return batt ; } uint32_t AP_Frsky_Telem :: calc_ap_status ( void ) { uint32_t ap_status ; uint8_t imu_temp = ( uint8_t ) roundf ( constrain_float ( AP :: ins ( ) . get_temperature ( 0 ) , AP_IMU_TEMP_MIN , AP_IMU_TEMP_MAX ) - AP_IMU_TEMP_MIN ) ; ap_status = ( uint8_t ) ( ( _ap . control_mode + 1 ) & AP_CONTROL_@@ MODE_LIMIT ) ; ap_status |= ( uint8_t ) ( ( * _ap . valuep ) & AP_SSIMPLE_FLAGS ) << AP_SSIMPLE_OFFSET ; ap_status |= ( uint8_t ) ( ( ( * _ap . valuep ) & AP_LANDCOMPLETE_FLAG ) ^ AP_LANDCOMPLETE_FLAG ) ; ap_status |= ( uint8_t ) ( AP_Notify :: flags . armed ) << AP_AR@@ MED_OFFSET ; ap_status |= ( uint8_t ) ( AP_Notify :: flags . failsafe_@@ battery ) << AP_BATT_@@ FS_OFFSET ; ap_status |= ( uint8_t ) ( AP_Notify :: flags . ekf_b@@ ad ) << AP_EK@@ F_FS_OFFSET ; ap_status |= imu_temp << AP_IMU_TEMP_OFFSET ; return ap_status ; } uint32_t AP_Frsky_Telem :: calc_home ( void ) { uint32_t home = 0 ; Location loc ; float _relative_home_altitude = 0 ; if ( _ahrs . get_position ( loc ) ) { const Location & home_loc = _ahrs . get_home ( ) ; if ( home_loc . lat != 0 || home_loc . lng != 0 ) { home = prep_number ( roundf ( get_distance ( home_loc , loc ) ) , 3 , 2 ) ; home |= ( ( ( uint8_t ) roundf ( get_bearing@@ _cd ( loc , home_loc ) * 0.00333f ) ) & HOME_BEARING_LIMIT ) << HOME_BEARING_OFFSET ; } _relative_home_altitude = loc . alt ; if ( ! loc . flags . relative_alt ) { _relative_home_altitude -= _ahrs . get_home ( ) . alt ; } } home |= prep_number ( roundf ( _relative_home_altitude * 0.1f ) , 3 , 2 ) << HOME_ALT_OFFSET ; return home ; } uint32_t AP_Frsky_Telem :: calc_velandyaw ( void ) { uint32_t velandyaw ; Vector3f velNED { } ; _ahrs . get_veloc@@ ity_NED ( velNED ) ; velandyaw = prep_number ( roundf ( - velNED . z * 10 ) , 2 , 1 ) ; const AP_Airspeed * aspeed = _ahrs . get_airspeed ( ) ; if ( aspeed && aspeed -> enabled ( ) ) { velandyaw |= prep_number ( roundf ( aspeed -> get_airspeed ( ) * 10 ) , 2 , 1 ) << VELANDYAW_XYVEL_OFFSET ; } else { velandyaw |= prep_number ( roundf ( _ahrs . groundspeed ( ) * 10 ) , 2 , 1 ) << VELANDYAW_XYVEL_OFFSET ; } velandyaw |= ( ( uint16_t ) roundf ( _ahrs . yaw_sensor * 0.05f ) & VELANDYAW_YAW_LIMIT ) << VELANDYAW_YAW_OFFSET ; return velandyaw ; } uint32_t AP_Frsky_Telem :: calc_attiandrng ( void ) { uint32_t attiandrng ; attiandrng = ( ( uint16_t ) roundf ( ( _ahrs . roll_sensor + 18000 ) * 0.05f ) & ATTIANDRNG_ROLL_@@ LIMIT ) ; attiandrng |= ( ( uint16_t ) roundf ( ( _ahrs . pitch_sensor + 9000 ) * 0.05f ) & ATTIANDRNG_PITCH_LIMIT ) << ATTIANDRNG_PITCH_OFFSET ; attiandrng |= prep_number ( _rng . distance_cm_ori@@ ent ( ROTATION_PITCH_@@ 270 ) , 3 , 1 ) << ATTIANDRNG_RNG@@ FND_OFFSET ; return attiandrng ; } uint16_t AP_Frsky_Telem :: prep_number ( int32_t number , uint8_t digits , uint8_t power ) { uint16_t res = 0 ; uint32_t abs_number = abs ( number ) ; if ( ( digits == 2 ) && ( power == 1 ) ) { if ( abs_number < 100 ) { res = abs_number << 1 ; } else if ( abs_number < 1270 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.1f ) << 1 ) | 0x1 ; } else { res = 0xFF ; } if ( number < 0 ) { res |= 0x1 << 8 ; } } else if ( ( digits == 2 ) && ( power == 2 ) ) { if ( abs_number < 100 ) { res = abs_number << 2 ; } else if ( abs_number < 1000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.1f ) << 2 ) | 0x1 ; } else if ( abs_number < 10000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.01f ) << 2 ) | 0x2 ; } else if ( abs_number < 127000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.001f ) << 2 ) | 0x3 ; } else { res = 0x1FF ; } if ( number < 0 ) { res |= 0x1 << 9 ; } } else if ( ( digits == 3 ) && ( power == 1 ) ) { if ( abs_number < 1000 ) { res = abs_number << 1 ; } else if ( abs_number < 10240 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.1f ) << 1 ) | 0x1 ; } else { res = 0x7FF ; } if ( number < 0 ) { res |= 0x1 << 11 ; } } else if ( ( digits == 3 ) && ( power == 2 ) ) { if ( abs_number < 1000 ) { res = abs_number << 2 ; } else if ( abs_number < 10000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.1f ) << 2 ) | 0x1 ; } else if ( abs_number < 100000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.01f ) << 2 ) | 0x2 ; } else if ( abs_number < 1024000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.001f ) << 2 ) | 0x3 ; } else { res = 0xFFF ; } if ( number < 0 ) { res |= 0x1 << 12 ; } } return res ; } void AP_Frsky_Telem :: calc_nav_alt ( void ) { Location loc ; float current_height = 0 ; if ( _ahrs . get_position ( loc ) ) { current_height = loc . alt * 0.01f ; if ( ! loc . flags . relative_alt ) { current_height -= _ahrs . get_home ( ) . alt * 0.01f ; } } _gps . alt_nav_meters = ( int16_t ) current_height ; _gps . alt_nav_cm = ( current_height - _gps . alt_nav_meters ) * 100 ; } float AP_Frsky_Telem :: format_gps ( float dec ) { uint8_t dm_deg = ( uint8_t ) dec ; return ( dm_deg * 100.0f ) + ( dec - dm_deg ) * 60 ; } void AP_Frsky_Telem :: calc_gps_position ( void ) { float lat ; float lon ; float alt ; float speed ; if ( AP :: gps ( ) . status ( ) >= 3 ) { const Location & loc = AP :: gps ( ) . location ( ) ; lat = format_gps ( fabsf ( loc . lat / 10000000.0f ) ) ; _gps . latdddmm = lat ; _gps . latmmmm = ( lat - _gps . latdddmm ) * 10000 ; _gps . lat_ns = ( loc . lat < 0 ) ? ' S ' : ' N ' ; lon = format_gps ( fabsf ( loc . lng / 10000000.0f ) ) ; _gps . londddmm = lon ; _gps . lonmmmm = ( lon - _gps . londddmm ) * 10000 ; _gps . lon_ew = ( loc . lng < 0 ) ? ' W ' : ' E ' ; alt = loc . alt * 0.01f ; _gps . alt_gps_meters = ( int16_t ) alt ; _gps . alt_gps_cm = ( alt - _gps . alt_gps_meters ) * 100 ; speed = AP :: gps ( ) . ground_speed ( ) ; _gps . speed_in_meter = speed ; _gps . speed_in_centimeter = ( speed - _gps . speed_in_meter ) * 100 ; } else { _gps . latdddmm = 0 ; _gps . latmmmm = 0 ; _gps . lat_ns = 0 ; _gps . londddmm = 0 ; _gps . lonmmmm = 0 ; _gps . alt_gps_meters = 0 ; _gps . alt_gps_cm = 0 ; _gps . speed_in_meter = 0 ; _gps . speed_in_centimeter = 0 ; } } </DOCUMENT>
<DOCUMENT_ID="Eag@@ le-X/folly/tree/master/folly@@ /test/IPAddress@@ Benchmark.cpp"> # include < folly / IPAddress . h > # include < glog / logging . h > # include < folly / Benchmark . h > using namespace folly ; using std :: string ; BENCHMARK ( ipv4_to_string_inet_ntop , iters ) { folly :: IPAddressV4 ipv4Addr ( "127.0.0.1" ) ; in_addr ip = ipv4Addr . toAddr ( ) ; char outputString [ INET_ADDRSTRLEN ] = { 0 } ; while ( iters -- ) { const char * val = inet_ntop ( AF_INET , & ip , outputString , sizeof ( outputString ) ) ; } } BENCHMARK_RELATIVE ( ipv4_to_fully_qualified , iters ) { IPAddressV4 ip ( "127.0.0.1" ) ; while ( iters -- ) { string outputString = ip . toFullyQualified ( ) ; } } BENCHMARK_DRAW_@@ LINE ( ) BENCHMARK ( ipv6_to_string_inet_ntop , iters ) { IPAddressV6 ipv6Addr ( " F1E0:0ACE : FB94:7ADF : 22E8:6DE6:9672:3725" ) ; in6_addr ip = ipv6Addr . toAddr ( ) ; char outputString [ INET6_ADD@@ RSTRLEN ] = { 0 } ; bool checkResult = ( iters == 1 ) ; while ( iters -- ) { const char * val = inet_ntop ( AF_INET@@ 6 , & ip , outputString , sizeof ( outputString ) ) ; } } BENCHMARK_RELATIVE ( ipv6_to_fully_qualified , iters ) { IPAddressV6 ip ( " F1E0:0ACE : FB94:7ADF : 22E8:6DE6:9672:3725" ) ; string outputString ; while ( iters -- ) { outputString = ip . toFullyQualified ( ) ; } } int main ( int argc , char * argv [ ] ) { gflags :: ParseCommandLine@@ Flags ( & argc , & argv , true ) ; runBenchmark@@ s ( ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="eugene1g/phantomjs/tree/master/src/qt/qtbase/src/corelib/@@ doc/snippets/code/src_corelib_io@@ _qfile.cpp"> QFile file ; QDir :: setCurrent ( " / tmp " ) ; file . setFileName ( " readme . txt " ) ; QDir :: setCurrent ( " / home " ) ; file . open ( QIODevice :: ReadOnly ) ; QByteArray myEncoder@@ Func ( const QString & fileName ) ; QString myDecoder@@ Func ( const QByteArray & localFileName ) ; # include < stdio . h > void printError ( const char * msg ) { QFile file ; file . open ( stderr , QIODevice :: WriteOnly ) ; file . write ( msg , qstrlen ( msg ) ) ; file . close ( ) ; } CONFIG += console </DOCUMENT>
<DOCUMENT_ID="man@@ tidproject/cxx@@ test/tree/master/cxxtest/TestTrack@@ er.cpp"> # ifndef __cxxtest__TestTracker_cpp__ # define __cxxtest__TestTracker_cpp__ # include < cxxtest / TestTracker . h > namespace CxxTest { bool TestTracker :: _created = false ; bool TestTracker :: print_tr@@ acing = false ; TestTracker :: TestTracker ( ) { if ( ! _created ) { initialize ( ) ; setListener ( 0 ) ; _created = true ; } } TestTracker :: ~ TestTracker ( ) { } TestTracker & TestTracker :: tracker ( ) { static TestTracker theTracker ; return theTracker ; } void TestTracker :: initialize ( ) { _warnings = 0 ; _skippedTests = 0 ; _testSkipped = false ; _failedTests = 0 ; _testFailedAsserts = 0 ; _suiteFailedTests = 0 ; _failedSuites = 0 ; _world = 0 ; _suite = 0 ; _test = 0 ; } const TestDescription * TestTracker :: fixTest ( const TestDescription * d ) const { return d ? d : & dummyTest ( ) ; } const SuiteDescription * TestTracker :: fixSuite ( const SuiteDescription * d ) const { return d ? d : & dummySuite ( ) ; } const WorldDescription * TestTracker :: fixWorld ( const WorldDescription * d ) const { return d ? d : & dummyWorld ( ) ; } const TestDescription & TestTracker :: dummyTest ( ) const { return dummySuite ( ) . testDescription ( 0 ) ; } const SuiteDescription & TestTracker :: dummySuite ( ) const { return dummyWorld ( ) . suiteDescription ( 0 ) ; } const WorldDescription & TestTracker :: dummyWorld ( ) const { return _dummyWorld ; } void TestTracker :: setListener ( TestListener * l ) { _l = l ? l : & _dummyListener ; } void TestTracker :: enterWorld ( const WorldDescription & wd ) { setWorld ( & wd ) ; _warnings = _skippedTests = _failedTests = _testFailedAsserts = _suiteFailedTests = _failedSuites = 0 ; _testSkipped = false ; _l -> enterWorld ( wd ) ; } void TestTracker :: enterSuite ( const SuiteDescription & sd ) { setSuite ( & sd ) ; _testFailedAsserts = _suiteFailedTests = 0 ; _testSkipped = false ; _l -> enterSuite ( sd ) ; } void TestTracker :: enterTest ( const TestDescription & td ) { setTest ( & td ) ; _testFailedAsserts = false ; _testSkipped = false ; _l -> enterTest ( td ) ; } void TestTracker :: leaveTest ( const TestDescription & td ) { _l -> leaveTest ( td ) ; setTest ( 0 ) ; } void TestTracker :: leaveSuite ( const SuiteDescription & sd ) { _l -> leaveSuite ( sd ) ; setSuite ( 0 ) ; } void TestTracker :: leaveWorld ( const WorldDescription & wd ) { _l -> leaveWorld ( wd ) ; setWorld ( 0 ) ; } void TestTracker :: trace ( const char * file , int line , const char * expression ) { _l -> trace ( file , line , expression ) ; } void TestTracker :: warning ( const char * file , int line , const char * expression ) { countWarning ( ) ; _l -> warning ( file , line , expression ) ; } void TestTracker :: skippedTest ( const char * file , int line , const char * expression ) { countSkipped ( ) ; _testSkipped = true ; _l -> skippedTest ( file , line , expression ) ; } void TestTracker :: failedTest ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedTest ( file , line , expression ) ; } void TestTracker :: failedAssert ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedAssert ( file , line , expression ) ; } void TestTracker :: failedAssertEquals ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertEquals ( file , line , xStr , yStr , x , y ) ; } void TestTracker :: failedAssertSameData ( const char * file , int line , const char * xStr , const char * yStr , const char * sizeStr , const void * x , const void * y , unsigned size ) { countFailure ( ) ; _l -> failedAssertSameData ( file , line , xStr , yStr , sizeStr , x , y , size ) ; } void TestTracker :: failedAssertDelta ( const char * file , int line , const char * xStr , const char * yStr , const char * dStr , const char * x , const char * y , const char * d ) { countFailure ( ) ; _l -> failedAssertDelta ( file , line , xStr , yStr , dStr , x , y , d ) ; } void TestTracker :: failedAssertDiffers ( const char * file , int line , const char * xStr , const char * yStr , const char * value ) { countFailure ( ) ; _l -> failedAssertDiffers ( file , line , xStr , yStr , value ) ; } void TestTracker :: failedAssertLessThan ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertLessThan ( file , line , xStr , yStr , x , y ) ; } void TestTracker :: failedAssertLessThanEquals ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertLessThanEquals ( file , line , xStr , yStr , x , y ) ; } void TestTracker :: failedAssertPredicate ( const char * file , int line , const char * predicate , const char * xStr , const char * x ) { countFailure ( ) ; _l -> failedAssertPredicate ( file , line , predicate , xStr , x ) ; } void TestTracker :: failedAssertRelation ( const char * file , int line , const char * relation , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertRelation ( file , line , relation , xStr , yStr , x , y ) ; } void TestTracker :: failedAssertThrows ( const char * file , int line , const char * expression , const char * type , bool otherThrown ) { countFailure ( ) ; _l -> failedAssertThrows ( file , line , expression , type , otherThrown ) ; } void TestTracker :: failedAssertThrowsNot ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedAssertThrowsNot ( file , line , expression ) ; } void TestTracker :: failedAssertSameFiles ( const char * file , int line , const char * file1 , const char * file2 , const char * explanation ) { countFailure ( ) ; _l -> failedAssertSameFiles ( file , line , file1 , file2 , explanation ) ; } void TestTracker :: setWorld ( const WorldDescription * w ) { _world = fixWorld ( w ) ; setSuite ( 0 ) ; } void TestTracker :: setSuite ( const SuiteDescription * s ) { _suite = fixSuite ( s ) ; setTest ( 0 ) ; } void TestTracker :: setTest ( const TestDescription * t ) { _test = fixTest ( t ) ; } void TestTracker :: countWarning ( ) { ++ _warnings ; } void TestTracker :: countSkipped ( ) { ++ _skippedTests ; } void TestTracker :: countFailure ( ) { if ( ++ _testFailedAsserts == 1 ) { ++ _failedTests ; if ( ++ _suiteFailedTests == 1 ) { ++ _failedSuites ; } } } } # endif </DOCUMENT>
<DOCUMENT_ID="domin1101/@@ malmo-ch@@ allenge/tree/master/cpp/src/ma@@ in.cpp"> # include " LightBulbApp / App . hpp " # include < wx / wxprec . h > # include " PigChase / PigChaseEvolution . hpp " # include " PigChase / TensorflowExporter . hpp " int main ( int argc , char * * argv ) { LightBulb :: App * app = new LightBulb :: App ( ) ; app -> addTrainingPlan ( new PigChaseEvolution ( ) ) ; app -> addExporter ( new TensorflowExporter ( ) ) ; wxApp :: SetInstance ( app ) ; wxEntry ( argc , argv ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="Super@@ Hex/psychic@@ -aero/tree/master/base/HAL.cpp"> # ifndef __HAL__ # define __HAL__ # include . . / config / config . h # include < avr / io . h > namespace base { template < class init_traits , class rw_traits > struct hal { typedef init_traits I ; typedef rw_traits RW ; public : hal ( ) { I :: init ( ) ; } virtual ~ hal ( ) ; virtual void write ( const unsigned char data ) { RW :: write ( data ) ; } virtual unsigned char read ( ) { return RW :: read ( ) ; } } ; struct skip_init { static void init ( ) { } } ; struct USART_default_init { static void init ( const long baudRate ) { long ubrr = F_CPU / 16 / baudRate - 1 ; UBRR0H = ubrr >> 8 ; UBRR0L = ubrr ; UCSR0B = ( 1 << RXEN0 ) | ( 1 << TXEN0 ) ; UCSR0C = ( 3 << UCSZ00 ) ; } } ; struct USART_8N1_RW { public : static void write ( const unsigned char data ) { while ( ! ( UCSR0A & ( 1 << UDRE0 ) ) ) ; UDR0 = data ; } static unsigned char read ( ) { while ( ! ( UCSR0A & ( 1 << RXC0 ) ) ) ; return UDR0 ; } } ; struct SPI_RW { static void write ( unsigned char data ) { SPDR = data ; while ( ! ( SPSR & ( 1 << SPIF ) ) ) ; } static unsigned char read ( ) { while ( ! ( SPSR & ( 1 << SPIF ) ) ) ; return SPDR ; } } ; struct SPI_master_init { static void init ( ) { DDRB |= ( 1 << PB3 ) | ( 1 << PB5 ) | ( 1 << PB2 ) ; SPCR = ( 1 << SPE ) | ( 1 << MSTR ) | ( 1 << SPR0 ) ; } } ; struct SPI_slave_init { static void init ( ) { DDRB |= ( 1 << PB4 ) ; SPCR = ( 1 << SPE ) ; } } ; template < class T = USART_default_init > struct USART : public hal < skip_init , USART_8N1_RW > { public : USART ( const long Rate ) { T :: init ( Rate ) ; } virtual ~ USART ( ) ; } ; typedef USART < > Serial ; template < class T > struct SPI : public hal < T , SPI_RW > { } ; typedef SPI < SPI_master_init > SPIMaster ; typedef SPI < SPI_slave_init > SPIS@@ lave ; } # endif </DOCUMENT>
<DOCUMENT_ID="pe@@ ak3d/input@@ stream.adap@@ tive/tree/master/lib@@ /libbent@@ o4/Core/Ap@@ 4.cpp"> # include " Ap4 . h " static AP4 AP4_LoaderCheck ; AP4 :: AP4 ( ) : m_ConstructedByLoader ( true ) { } AP4_Result AP4 :: Initialize ( ) { AP4_Result result = AP4_SUCCESS ; # if defined ( AP4_CONFIG_CONSTRUCT_STATICS_ON_@@ INITIALIZE ) if ( ! AP4_DefaultAtomFactory :: Instance . m_Initialized ) { result = AP4_DefaultAtomFactory :: Instance . Initialize ( ) ; if ( AP4_FAILED ( result ) ) return result ; } if ( ! AP4_DefaultBlockCipherFactory :: Instance . m_Initialized ) { result = AP4_DefaultBlockCipherFactory :: Instance . Initialize ( ) ; if ( AP4_FAILED ( result ) ) return result ; } if ( ! AP4_MetaData :: Initialized ( ) ) { AP4_MetaData :: Initialize ( ) ; } # endif return result ; } AP4_Result AP4 :: Terminate ( ) { # if defined ( AP4_CONFIG_DESTRUCT_STATICS_ON_@@ TERMIN@@ ATE ) if ( ! AP4_LoaderCheck . m_ConstructedByLoader ) { if ( AP4_DefaultAtomFactory :: Instance . m_Initialized ) { AP4_DefaultAtomFactory :: Instance . ~ AP4_DefaultAtomFactory ( ) ; } if ( AP4_DefaultBlockCipherFactory :: Instance . m_Initialized ) { AP4_DefaultBlockCipherFactory :: Instance . ~ AP4_DefaultBlockCipherFactory ( ) ; } if ( AP4_MetaData :: Initialized ( ) ) { AP4_MetaData :: UnInitialize ( ) ; } } # endif return AP4_SUCCESS ; } </DOCUMENT>
<DOCUMENT_ID="xhochy/@@ arrow/tree/master/ruby/@@ red-ar@@ row/ext/ar@@ row/raw-record@@ s.cpp"> # include " converters . hpp " namespace red_arrow { namespace { class RawRecordsBuilder : private Converter , public arrow :: ArrayVisitor { public : explicit RawRecordsBuilder ( VALUE records , int n_columns ) : Converter ( ) , records_ ( records ) , n_columns_ ( n_columns ) { } void build ( const arrow :: RecordBatch & record_batch ) { rb :: protect ( [ & ] { const auto n_rows = record_batch . num_rows ( ) ; for ( int64_t i = 0 ; i < n_rows ; ++ i ) { auto record = rb_ary_new_capa ( n_columns_ ) ; rb_ary_push ( records_ , record ) ; } row_offset_ = 0 ; for ( int i = 0 ; i < n_columns_ ; ++ i ) { const auto array = record_batch . column ( i ) . get ( ) ; column_index_ = i ; check_status ( array -> Accept ( this ) , " [ record - batch ] [ raw - records ] " ) ; } return Qnil ; } ) ; } void build ( const arrow :: Table & table ) { rb :: protect ( [ & ] { const auto n_rows = table . num_rows ( ) ; for ( int64_t i = 0 ; i < n_rows ; ++ i ) { auto record = rb_ary_new_capa ( n_columns_ ) ; rb_ary_push ( records_ , record ) ; } for ( int i = 0 ; i < n_columns_ ; ++ i ) { const auto & chunked_array = table . column ( i ) . get ( ) ; column_index_ = i ; row_offset_ = 0 ; for ( const auto array : chunked_array -> chunks ( ) ) { check_status ( array -> Accept ( this ) , " [ table ] [ raw - records ] " ) ; row_offset_ += array -> length ( ) ; } } return Qnil ; } ) ; } # define VISIT ( TYPE ) arrow :: Status Visit ( const arrow :: TYPE ## Array & array ) override { convert ( array ) ; return arrow :: Status :: OK ( ) ; } VISIT ( Null ) VISIT ( Boolean ) VISIT ( Int8 ) VISIT ( Int16 ) VISIT ( Int32 ) VISIT ( Int64 ) VISIT ( UInt8 ) VISIT ( UInt16 ) VISIT ( UInt32 ) VISIT ( UInt64 ) VISIT ( Float ) VISIT ( Double ) VISIT ( Binary ) VISIT ( String ) VISIT ( FixedSizeBinary ) VISIT ( Date32 ) VISIT ( Date64 ) VISIT ( Time32 ) VISIT ( Time64 ) VISIT ( Timestamp ) VISIT ( List ) VISIT ( Struct ) VISIT ( Union ) VISIT ( Dictionary ) VISIT ( Decimal@@ 128 ) # undef VISIT private : template < typename ArrayType > void convert ( const ArrayType & array ) { const auto n = array . length ( ) ; if ( array . null_count ( ) > 0 ) { for ( int64_t i = 0 , ii = row_offset_ ; i < n ; ++ i , ++ ii ) { auto value = Qnil ; if ( ! array . IsNull ( i ) ) { value = convert_value ( array , i ) ; } auto record = rb_ary_entry ( records_ , ii ) ; rb_ary_store ( record , column_index_ , value ) ; } } else { for ( int64_t i = 0 , ii = row_offset_ ; i < n ; ++ i , ++ ii ) { auto record = rb_ary_entry ( records_ , ii ) ; rb_ary_store ( record , column_index_ , convert_value ( array , i ) ) ; } } } VALUE records_ ; int column_index_ ; int64_t row_offset_ ; const int n_columns_ ; } ; } VALUE record_batch_raw_records ( VALUE rb_record_batch ) { auto garrow_record_batch = GARROW_RECORD_@@ BATCH ( RVAL2GOBJ ( rb_record_batch ) ) ; auto record_batch = garrow_record_batch_@@ get_raw ( garrow_record_batch ) . get ( ) ; const auto n_rows = record_batch -> num_rows ( ) ; const auto n_columns = record_batch -> num_columns ( ) ; auto records = rb_ary_new_capa ( n_rows ) ; try { RawRecordsBuilder builder ( records , n_columns ) ; builder . build ( * record_batch ) ; } catch ( rb :: State & state ) { state . jump ( ) ; } return records ; } VALUE table_raw_records ( VALUE rb_table ) { auto garrow_table = GARROW_TABLE ( RVAL2GOBJ ( rb_table ) ) ; auto table = garrow_t@@ able_get_raw ( garrow_table ) . get ( ) ; const auto n_rows = table -> num_rows ( ) ; const auto n_columns = table -> num_columns ( ) ; auto records = rb_ary_new_capa ( n_rows ) ; try { RawRecordsBuilder builder ( records , n_columns ) ; builder . build ( * table ) ; } catch ( rb :: State & state ) { state . jump ( ) ; } return records ; } } </DOCUMENT>
<DOCUMENT_ID="BillHall@@ y/boo/tree/master/lib/@@ antlr@@ -2.7.5@@ /lib/cpp/src/@@ TreeParser@@ .cpp"> # include < iostream > # include " antlr / TreeParser . hpp " # include " antlr / ASTNULLType . hpp " # ifdef ANTLR_CXX_SUPPORTS_NAMESPACE namespace antlr { # endif RefAST TreeParser :: ASTNULL ( new ASTNULLType ) ; void TreeParser :: reportError ( const Recogni@@ tionException & ex ) { ANTLR_USE_NAMESPACE ( std ) cerr << ex . toString ( ) . c_str ( ) << ANTLR_USE_NAMESPACE ( std ) endl ; } void TreeParser :: reportError ( const ANTLR_USE_NAMESPACE ( std ) string & s ) { ANTLR_USE_NAMESPACE ( std ) cerr << " error : ▁ " << s . c_str ( ) << ANTLR_USE_NAMESPACE ( std ) endl ; } void TreeParser :: reportWarning ( const ANTLR_USE_NAMESPACE ( std ) string & s ) { ANTLR_USE_NAMESPACE ( std ) cerr << " warning : ▁ " << s . c_str ( ) << ANTLR_USE_NAMESPACE ( std ) endl ; } void TreeParser :: traceIndent ( ) { for ( int i = 0 ; i < traceDepth ; i ++ ) ANTLR_USE_NAMESPACE ( std ) cout << " ▁ " ; } void TreeParser :: traceIn ( const char * rname , RefAST t ) { traceDepth ++ ; traceIndent ( ) ; ANTLR_USE_NAMESPACE ( std ) cout << " > ▁ " << rname << " ( " << ( t ? t -> toString ( ) . c_str ( ) : " null " ) << " ) " << ( ( inputState -> guessing > 0 ) ? " ▁ [ guessing ] " : " " ) << ANTLR_USE_NAMESPACE ( std ) endl ; } void TreeParser :: traceOut ( const char * rname , RefAST t ) { traceIndent ( ) ; ANTLR_USE_NAMESPACE ( std ) cout << " < ▁ " << rname << " ( " << ( t ? t -> toString ( ) . c_str ( ) : " null " ) << " ) " << ( ( inputState -> guessing > 0 ) ? " ▁ [ guessing ] " : " " ) << ANTLR_USE_NAMESPACE ( std ) endl ; traceDepth -- ; } # ifdef ANTLR_CXX_SUPPORTS_NAMESPACE } # endif </DOCUMENT>
<DOCUMENT_ID="ricar@@ dogsilv@@ a/QGIS@@ /tree/master/src/core/@@ qgsproxyprogresstask.cpp"> # include " qgsproxyprogresstask . h " QgsProxyProgressTask :: QgsProxyProgressTask ( const QString & description ) : QgsTask ( description , QgsTask :: Flags ( ) ) { } void QgsProxyProgressTask :: finalize ( bool result ) { mResult = result ; mNotFinishedWaitCondition . wakeAll ( ) ; } bool QgsProxyProgressTask :: run ( ) { mNotFinishedMutex . lock ( ) ; mNotFinishedWaitCondition . wait ( & mNotFinishedMutex ) ; mNotFinishedMutex . unlock ( ) ; return mResult ; } void QgsProxyProgressTask :: setProxyProgress ( double progress ) { QMetaObject :: invokeMethod ( this , " setProgress " , Qt :: AutoConnection , Q_ARG ( double , progress ) ) ; } QgsScopedProxyProgressTask :: QgsScopedProxyProgressTask ( const QString & description ) : mTask ( new QgsProxyProgressTask ( description ) ) { QgsApplication :: taskManager ( ) -> addTask ( mTask ) ; } QgsScopedProxyProgressTask :: ~ QgsScopedProxyProgressTask ( ) { mTask -> finalize ( true ) ; } void QgsScopedProxyProgressTask :: setProgress ( double progress ) { mTask -> setProxyProgress ( progress ) ; } </DOCUMENT>
<DOCUMENT_ID="braindx/@@ scummvm/tree/master/engines/@@ titanic@@ /gfx/@@ icon_nav@@ _recei@@ ve.cpp"> # include " titanic / gfx / icon _ nav _ receive . h " namespace Titanic { EMPTY_MESSAGE_MAP ( CIconNavReceive , CPetGraphic ) ; void CIconNavReceive :: save ( SimpleFile * file , int indent ) { file -> writeNumber@@ Line ( 1 , indent ) ; CPetGraphic :: save ( file , indent ) ; } void CIconNavReceive :: load ( SimpleFile * file ) { file -> readNumber ( ) ; CPetGraphic :: load ( file ) ; } } </DOCUMENT>
<DOCUMENT_ID="kingvup@@ lus/enigma2/tree/master/lib/@@ gui/einput@@ string.cpp"> # include < lib / gui / einputstring . h > DEFINE_RE@@ F ( eInputContentString ) ; eInputContentString :: eInputContentString ( ) { m_string = " bla " ; m_cursor = 0 ; m_input = 0 ; m_len = m_string . size ( ) ; } void eInputContentString :: getDisplay ( std :: string & res , int & cursor ) { res = m_string ; cursor = m_cursor ; } void eInputContentString :: moveCursor ( int dir ) { int old_cursor = m_cursor ; switch ( dir ) { case dirLeft : -- m_cursor ; break ; case dirRight : ++ m_cursor ; break ; case dirHome : m_cursor = 0 ; break ; case dirEnd : m_cursor = m_len ; break ; } if ( m_cursor < 0 ) m_cursor = 0 ; if ( m_cursor > m_len ) m_cursor = m_len ; if ( m_cursor != old_cursor ) if ( m_input ) m_input -> invalidate ( ) ; } int eInputContentString :: haveKey ( int code , int overwrite ) { int have_char = - 1 ; if ( code >= 0x8020 ) have_char = code & ~ 0x8000 ; if ( have_char != - 1 ) { if ( overwrite && m_cursor < m_len ) m_string [ m_cursor ] = have_char ; else { m_string . insert ( m_cursor , 1 , have_char ) ; ++ m_len ; } m_cursor ++ ; ASSERT ( m_cursor <= m_len ) ; if ( m_input ) m_input -> invalidate ( ) ; return 1 ; } return 0 ; } void eInputContentString :: deleteChar ( int dir ) { if ( dir == deleteForward ) { eDebug ( " forward " ) ; if ( m_cursor != m_len ) ++ m_cursor ; else return ; } if ( ! m_cursor ) return ; if ( ! m_len ) return ; m_string . erase ( m_cursor - 1 , m_cursor ) ; m_len -- ; m_cursor -- ; if ( m_input ) m_input -> invalidate ( ) ; } int eInputContentString :: isValid ( ) { return 1 ; } void eInputContentString :: validate ( ) { } void eInputContentString :: setText ( const std :: string & str ) { m_string = str ; m_len = m_string . size ( ) ; if ( m_cursor > m_len ) m_cursor = m_len ; if ( m_input ) m_input -> invalidate ( ) ; } std :: string eInputContentString :: getText ( ) { return m_string ; } </DOCUMENT>
<DOCUMENT_ID="ich@@ u501/WinObjC/tree/master/deps/3rdparty/ic@@ u/icu/source/test/intl@@ test/tsmthred.cpp"> # if defined ( hpux ) # ifndef _INCLUDE_POSIX_SOURCE # define _INCLUDE_POSIX_SOURCE # endif # endif # include " simplethread . h " # include " unicode / utypes . h " # include " unicode / ustring . h " # include " umutex . h " # include " cmemory . h " # include " cstring . h " # include " uparse . h " # include " unicode / localpointer . h " # include " unicode / resbund . h " # include " unicode / udata . h " # include " unicode / uloc . h " # include " unicode / locid . h " # include " putilimp . h " # include " intltest . h " # include " tsmthred . h " # include " unicode / ushape . h " # include " unicode / translit . h " # include " sharedobject . h " # include " unifiedcache . h " # include " uassert . h " # if U_PLATFORM_USES_@@ ONLY_WIN32_API # undef POSIX # elif U_PLATFORM_IMPLEMENT@@ S_POSIX # define POSIX # else # undef POSIX # endif # if U_PLATFORM == U_PF_OS390 # define __DOT@@ 1 1 # define __UU # ifndef _XPG4_2 # define _XPG4_2 # endif # include < unistd . h > # endif # if defined ( POSIX ) # define HAVE_IMP # if ( ICU_USE_THREADS == 1 ) # include < pthread . h > # endif # if defined ( __hpux ) && defined ( HPUX_C@@ MA ) # if defined ( read ) # undef read # endif # endif # ifndef __EXTENSIONS__ # define __EXTENSIONS__ # endif # if U_PLATFORM == U_PF_OS390 # include < sys / types . h > # endif # if U_PLATFORM != U_PF_OS390 # include < signal . h > # endif # ifndef _XPG4_2 # define _XPG4_2 # endif # ifndef __USE_XOPEN_EXTENDED # define __USE_XOPEN_EXTENDED # endif # ifndef _INCLUDE_XOPEN_SOURCE_EXTENDED # define _INCLUDE_XOPEN_SOURCE_EXTENDED # endif # include < unistd . h > # endif # ifdef sleep # undef sleep # endif # define TSMTHREAD_FAIL ( msg ) errln ( " % s ▁ at ▁ file ▁ % s , ▁ line ▁ % d " , msg , __FILE__ , __LINE__ ) # define TSMTHREAD_ASSERT ( expr ) { if ( ! ( expr ) ) { TSMTHREAD_FAIL ( " Fail " ) ; } } MultithreadTest :: MultithreadTest ( ) { } MultithreadTest :: ~ MultithreadTest ( ) { } # if ( ICU_USE_THREADS == 0 ) void MultithreadTest :: runIndexedTest ( int32_t index , UBool exec , const char * & name , char * ) { if ( exec ) logln ( " TestSuite ▁ MultithreadTest : ▁ " ) ; if ( index == 0 ) name = " NO _ THREADED _ TESTS " ; else name = " " ; if ( exec ) { logln ( " MultithreadTest ▁ - ▁ test ▁ DISABLED . ▁ ▁ ICU _ USE _ THREADS ▁ set ▁ to ▁ 0 , ▁ check ▁ your ▁ configuration ▁ if ▁ this ▁ is ▁ a ▁ problem . . " ) ; } } # else # include < stdio . h > # include < string . h > # include < ctype . h > # include " unicode / putil . h " # include " unicode / numfmt . h " # include " unicode / choicfmt . h " # include " unicode / msgfmt . h " # include " unicode / locid . h " # include " unicode / coll . h " # include " unicode / calendar . h " # include " ucaconf . h " void SimpleThread :: errorFunc ( ) { } void MultithreadTest :: runIndexedTest ( int32_t index , UBool exec , const char * & name , char * ) { if ( exec ) logln ( " TestSuite ▁ MultithreadTest : ▁ " ) ; switch ( index ) { case 0 : name = " TestThreads " ; if ( exec ) TestThreads ( ) ; break ; case 1 : name = " TestMutex " ; if ( exec ) TestMutex ( ) ; break ; case 2 : name = " TestThreadedIntl " ; # if ! UCONFIG_NO_FORMATTING if ( exec ) { TestThreadedIntl ( ) ; } # endif break ; case 3 : name = " TestCollators " ; # if ! UCONFIG_NO_COLLATION if ( exec ) { TestCollators ( ) ; } # endif break ; case 4 : name = " TestString " ; if ( exec ) { TestString ( ) ; } break ; case 5 : name = " TestArabicShapingThreads " ; if ( exec ) { TestArabicShapingThreads ( ) ; } break ; case 6 : name = " TestAnyTranslit " ; if ( exec ) { TestAnyTranslit ( ) ; } break ; case 7 : name = " TestConditionVariables " ; if ( exec ) { TestConditionVariables ( ) ; } break ; case 8 : name = " TestUnifiedCache " ; if ( exec ) { TestUnifiedCache ( ) ; } break ; default : name = " " ; break ; } } # define THREADTEST_NRTHREADS 8 # define ARABICSHAPE_THREADTEST 30 class TestThreadsThread : public SimpleThread { public : TestThreadsThread ( char * whatToChange ) { fWhatToChange = whatToChange ; } virtual void run ( ) { SimpleThread :: sleep ( 1000 ) ; Mutex m ; * fWhatToChange = ' * ' ; } private : char * fWhatToChange ; } ; class TestArabicShapeThreads : public SimpleThread { public : TestArabicShapeThreads ( char * whatToChange ) { fWhatToChange = whatToChange ; } virtual void run ( ) { if ( doTailTest ( ) == TRUE ) * fWhatToChange = ' * ' ; } private : char * fWhatToChange ; UBool doTailTest ( void ) { static const UChar src [ ] = { 0x0020 , 0x0633 , 0 } ; static const UChar dst_old [ ] = { 0xFEB1 , 0x200B , 0 } ; static const UChar dst_new [ ] = { 0xFEB1 , 0xFE73 , 0 } ; UChar dst [ 3 ] = { 0x0000 , 0x0000 , 0 } ; int32_t length ; UErrorCode status ; IntlTest inteltst = IntlTest ( ) ; status = U_ZERO_ERROR ; length = u_shapeArabic ( src , - 1 , dst , UPRV_LENGTHOF ( dst ) , U_SHAPE_LETTERS_SHAPE | U_SHAPE_SEEN_TWOCELL_NEAR , & status ) ; if ( U_FAILURE ( status ) ) { inteltst . errln ( " Fail : ▁ status ▁ % s \n " , u_errorName ( status ) ) ; return FALSE ; } else if ( length != 2 ) { inteltst . errln ( " Fail : ▁ len ▁ % d ▁ expected ▁ 3 \n " , length ) ; return FALSE ; } else if ( u_strncmp ( dst , dst_old , UPRV_LENGTHOF ( dst ) ) ) { inteltst . errln ( " Fail : ▁ got ▁ U + % 04X ▁ U + % 04X ▁ expected ▁ U + % 04X ▁ U + % 04X \n " , dst [ 0 ] , dst [ 1 ] , dst_old [ 0 ] , dst_old [ 1 ] ) ; return FALSE ; } status = U_ZERO_ERROR ; length = u_shapeArabic ( src , - 1 , dst , UPRV_LENGTHOF ( dst ) , U_SHAPE_LETTERS_SHAPE | U_SHAPE_SEEN_TWOCELL_NEAR | U_SHAPE_TAIL_@@ NEW_UNICODE , & status ) ; if ( U_FAILURE ( status ) ) { inteltst . errln ( " Fail : ▁ status ▁ % s \n " , u_errorName ( status ) ) ; return FALSE ; } else if ( length != 2 ) { inteltst . errln ( " Fail : ▁ len ▁ % d ▁ expected ▁ 3 \n " , length ) ; return FALSE ; } else if ( u_strncmp ( dst , dst_new , UPRV_LENGTHOF ( dst ) ) ) { inteltst . errln ( " Fail : ▁ got ▁ U + % 04X ▁ U + % 04X ▁ expected ▁ U + % 04X ▁ U + % 04X \n " , dst [ 0 ] , dst [ 1 ] , dst_new [ 0 ] , dst_new [ 1 ] ) ; return FALSE ; } return TRUE ; } } ; void MultithreadTest :: TestThreads ( ) { char threadTestChars [ THREADTEST_NRTHREADS + 1 ] ; SimpleThread * threads [ THREADTEST_NRTHREADS ] ; int32_t numThreadsStarted = 0 ; int32_t i ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { threadTestChars [ i ] = ' ▁ ' ; threads [ i ] = new TestThreadsThread ( & threadTestChars [ i ] ) ; } threadTestChars [ THREADTEST_NRTHREADS ] = ' \0' ; logln ( " - > " + UnicodeString ( threadTestChars ) + " < - ▁ Firing ▁ off ▁ threads . . ▁ " ) ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { if ( threads [ i ] -> start ( ) != 0 ) { errln ( " Error ▁ starting ▁ thread ▁ % d " , i ) ; } else { numThreadsStarted ++ ; } SimpleThread :: sleep ( 100 ) ; logln ( " ▁ Subthread ▁ started . " ) ; } logln ( " Waiting ▁ for ▁ threads ▁ to ▁ be ▁ set . . " ) ; if ( numThreadsStarted == 0 ) { errln ( " No ▁ threads ▁ could ▁ be ▁ started ▁ for ▁ testing ! " ) ; return ; } int32_t patience = 40 ; while ( patience -- ) { int32_t count = 0 ; umtx_lock ( NULL ) ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { if ( threadTestChars [ i ] == ' * ' ) { count ++ ; } } umtx_unlock ( NULL ) ; if ( count == THREADTEST_NRTHREADS ) { logln ( " - > " + UnicodeString ( threadTestChars ) + " < - ▁ Got ▁ all ▁ threads ! ▁ cya " ) ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { delete threads [ i ] ; } return ; } logln ( " - > " + UnicodeString ( threadTestChars ) + " < - ▁ Waiting . . " ) ; SimpleThread :: sleep ( 500 ) ; } errln ( " - > " + UnicodeString ( threadTestChars ) + " < - ▁ PATIENCE ▁ EXCEEDED ! ! ▁ Still ▁ missing ▁ some . " ) ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { delete threads [ i ] ; } } void MultithreadTest :: TestArabicShapingThreads ( ) { char threadTestChars [ ARABICSHAPE_THREADTEST + 1 ] ; SimpleThread * threads [ ARABICSHAPE_THREADTEST ] ; int32_t numThreadsStarted = 0 ; int32_t i ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { threadTestChars [ i ] = ' ▁ ' ; threads [ i ] = new TestArabicShapeThreads ( & threadTestChars [ i ] ) ; } threadTestChars [ ARABICSHAPE_THREADTEST ] = ' \0' ; logln ( " - > ▁ do ▁ TestArabicShapingThreads ▁ < - ▁ Firing ▁ off ▁ threads . . ▁ " ) ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { if ( threads [ i ] -> start ( ) != 0 ) { errln ( " Error ▁ starting ▁ thread ▁ % d " , i ) ; } else { numThreadsStarted ++ ; } logln ( " ▁ Subthread ▁ started . " ) ; } logln ( " Waiting ▁ for ▁ threads ▁ to ▁ be ▁ set . . " ) ; if ( numThreadsStarted == 0 ) { errln ( " No ▁ threads ▁ could ▁ be ▁ started ▁ for ▁ testing ! " ) ; return ; } int32_t patience = 100 ; while ( patience -- ) { int32_t count = 0 ; umtx_lock ( NULL ) ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { if ( threadTestChars [ i ] == ' * ' ) { count ++ ; } } umtx_unlock ( NULL ) ; if ( count == ARABICSHAPE_THREADTEST ) { logln ( " - > TestArabicShapingThreads ▁ < - ▁ Got ▁ all ▁ threads ! ▁ cya " ) ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { delete threads [ i ] ; } return ; } logln ( " - > ▁ TestArabicShapingThreads ▁ < - ▁ Waiting . . " ) ; SimpleThread :: sleep ( 500 ) ; } errln ( " - > ▁ TestArabicShapingThreads ▁ < - ▁ PATIENCE ▁ EXCEEDED ! ! ▁ Still ▁ missing ▁ some . " ) ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { delete threads [ i ] ; } } static UMutex gTestMutexA = U_MUTEX_INITIALIZER ; static UMutex gTestMutexB = U_MUTEX_INITIALIZER ; static int gThreadsStarted = 0 ; static int gThreadsInMiddle = 0 ; static int gThreadsDone = 0 ; static const int TESTMUTEX_THREAD_COUNT = 4 ; static int safeIncr ( int & var , int amt ) { Mutex m ; var += amt ; return var ; } class TestMutexThread : public SimpleThread { public : virtual void run ( ) { safeIncr ( gThreadsStarted , 1 ) ; umtx_lock ( & gTestMutexA ) ; umtx_unlock ( & gTestMutexA ) ; safeIncr ( gThreadsInMiddle , 1 ) ; umtx_lock ( & gTestMutexB ) ; umtx_unlock ( & gTestMutexB ) ; safeIncr ( gThreadsDone , 1 ) ; } } ; void MultithreadTest :: TestMutex ( ) { gThreadsStarted = 0 ; gThreadsInMiddle = 0 ; gThreadsDone = 0 ; umtx_lock ( & gTestMutexA ) ; TestMutexThread * threads [ TESTMUTEX_THREAD_COUNT ] ; int i ; int32_t numThreadsStarted = 0 ; for ( i = 0 ; i < TESTMUTEX_THREAD_COUNT ; i ++ ) { threads [ i ] = new TestMutexThread ; if ( threads [ i ] -> start ( ) != 0 ) { errln ( " Error ▁ starting ▁ thread ▁ % d " , i ) ; } else { numThreadsStarted ++ ; } } if ( numThreadsStarted == 0 ) { errln ( " No ▁ threads ▁ could ▁ be ▁ started ▁ for ▁ testing ! " ) ; return ; } int patience = 0 ; while ( safeIncr ( gThreadsStarted , 0 ) != TESTMUTEX_THREAD_COUNT ) { if ( patience ++ > 24 ) { TSMTHREAD_FAIL ( " Patience ▁ Exceeded " ) ; return ; } SimpleThread :: sleep ( 500 ) ; } TSMTHREAD_ASSERT ( gThreadsInMiddle == 0 ) ; TSMTHREAD_ASSERT ( gThreadsDone == 0 ) ; umtx_lock ( & gTestMutexB ) ; umtx_unlock ( & gTestMutexA ) ; patience = 0 ; while ( safeIncr ( gThreadsInMiddle , 0 ) != TESTMUTEX_THREAD_COUNT ) { if ( patience ++ > 24 ) { TSMTHREAD_FAIL ( " Patience ▁ Exceeded " ) ; return ; } SimpleThread :: sleep ( 500 ) ; } TSMTHREAD_ASSERT ( gThreadsDone == 0 ) ; umtx_unlock ( & gTestMutexB ) ; patience = 0 ; while ( safeIncr ( gThreadsDone , 0 ) != TESTMUTEX_THREAD_COUNT ) { if ( patience ++ > 24 ) { TSMTHREAD_FAIL ( " Patience ▁ Exceeded " ) ; return ; } SimpleThread :: sleep ( 500 ) ; } for ( i = 0 ; i < TESTMUTEX_THREAD_COUNT ; i ++ ) { delete threads [ i ] ; } } class ThreadWithStatus : public SimpleThread { public : UBool getError ( ) { return ( fErrors > 0 ) ; } UBool getError ( UnicodeString & fillinError ) { fillinError = fErrorString ; return ( fErrors > 0 ) ; } virtual ~ ThreadWithStatus ( ) { } protected : ThreadWithStatus ( ) : fErrors ( 0 ) { } void error ( const UnicodeString & error ) { fErrors ++ ; fErrorString = error ; SimpleThread :: errorFunc ( ) ; } void error ( ) { error ( " An ▁ error ▁ occured . " ) ; } private : int32_t fErrors ; UnicodeString fErrorString ; } ; UnicodeString showDifference ( const UnicodeString & expected , const UnicodeString & result ) { UnicodeString res ; res = expected + " < Expected \n " ; if ( expected . length ( ) != result . length ( ) ) res += " ▁ [ ▁ Different ▁ lengths ▁ ] ▁ \n " ; else { for ( int32_t i = 0 ; i < expected . length ( ) ; i ++ ) { if ( expected [ i ] == result [ i ] ) { res += " ▁ " ; } else { res += " | " ; } } res += " < Differences " ; res += " \n " ; } res += result + " < Result \n " ; return res ; } const int kFormatThreadIterations = 100 ; const int kFormatThreadThreads = 10 ; # if ! UCONFIG_NO_FORMATTING struct FormatThreadTestData { double number ; UnicodeString string ; FormatThreadTestData ( double a , const UnicodeString & b ) : number ( a ) , string ( b ) { } } ; static void formatErrorMessage ( UErrorCode & realStatus , const UnicodeString & pattern , const Locale & theLocale , UErrorCode inStatus0 , const Locale & inCountry2 , double currency3 , UnicodeString & result ) { if ( U_FAILURE ( realStatus ) ) return ; UnicodeString errString1 ( u_errorName ( inStatus0 ) ) ; UnicodeString countryName2 ; inCountry2 . getDisplayCountry ( theLocale , countryName2 ) ; Formattable myArgs [ ] = { Formattable ( ( int32_t ) inStatus0 ) , Formattable ( errString1 ) , Formattable ( countryName2 ) , Formattable ( currency3 ) } ; MessageFormat * fmt = new MessageFormat ( " MessageFormat ' s ▁ API ▁ is ▁ broken ! ! ! ! ! ! ! ! ! ! ! " , realStatus ) ; fmt -> setLocale ( theLocale ) ; fmt -> applyPattern ( pattern , realStatus ) ; if ( U_FAILURE ( realStatus ) ) { delete fmt ; return ; } FieldPosition ignore = 0 ; fmt -> format ( myArgs , 4 , result , ignore , realStatus ) ; delete fmt ; } class ThreadSafeFormatSharedData { public : ThreadSafeFormatSharedData ( UErrorCode & status ) ; ~ ThreadSafeFormatSharedData ( ) ; LocalPointer < NumberFormat > fFormat ; Formattable fYDDThing ; Formattable fBBDThing ; UnicodeString fYDDStr ; UnicodeString fBBDStr ; } ; const ThreadSafeFormatSharedData * gSharedData = NULL ; ThreadSafeFormatSharedData :: ThreadSafeFormatSharedData ( UErrorCode & status ) { fFormat . adoptInstead ( NumberFormat :: createCurrencyInstance ( Locale :: getUS ( ) , status ) ) ; static const UChar kYDD [ ] = { 0x59 , 0x44 , 0x44 , 0x00 } ; static const UChar kBBD [ ] = { 0x42 , 0x42 , 0x44 , 0x00 } ; fYDDThing . adoptObject ( new CurrencyAmount ( 123.@@ 456 , kYDD , status ) ) ; fBBDThing . adoptObject ( new CurrencyAmount ( 987.65@@ 4 , kBBD , status ) ) ; if ( U_FAILURE ( status ) ) { return ; } fFormat -> format ( fYDDThing , fYDDStr , NULL , status ) ; fFormat -> format ( fBBDThing , fBBDStr , NULL , status ) ; gSharedData = this ; } ThreadSafeFormatSharedData :: ~ ThreadSafeFormatSharedData ( ) { gSharedData = NULL ; } class ThreadSafeFormat { public : ThreadSafeFormat ( UErrorCode & status ) ; UBool doStuff ( int32_t offset , UnicodeString & appendErr , UErrorCode & status ) const ; private : LocalPointer < NumberFormat > fFormat ; } ; ThreadSafeFormat :: ThreadSafeFormat ( UErrorCode & status ) { fFormat . adoptInstead ( NumberFormat :: createCurrencyInstance ( Locale :: getUS ( ) , status ) ) ; } static const UChar kUSD [ ] = { 0x55 , 0x53 , 0x44 , 0x00 } ; UBool ThreadSafeFormat :: doStuff ( int32_t offset , UnicodeString & appendErr , UErrorCode & status ) const { UBool okay = TRUE ; if ( u_strcmp ( fFormat -> getCurrency ( ) , kUSD ) ) { appendErr . append ( " fFormat ▁ currency ▁ ! = ▁ " ) . append ( kUSD ) . append ( " , ▁ = " ) . append ( fFormat -> getCurrency ( ) ) . append ( " ! ▁ " ) ; okay = FALSE ; } if ( u_strcmp ( gSharedData -> fFormat -> getCurrency ( ) , kUSD ) ) { appendErr . append ( " gFormat ▁ currency ▁ ! = ▁ " ) . append ( kUSD ) . append ( " , ▁ = " ) . append ( gSharedData -> fFormat -> getCurrency ( ) ) . append ( " ! ▁ " ) ; okay = FALSE ; } UnicodeString str ; const UnicodeString * o = NULL ; Formattable f ; const NumberFormat * nf = NULL ; switch ( offset % 4 ) { case 0 : f = gSharedData -> fYDDThing ; o = & gSharedData -> fYDDStr ; nf = gSharedData -> fFormat . getAlias ( ) ; break ; case 1 : f = gSharedData -> fBBDThing ; o = & gSharedData -> fBBDStr ; nf = gSharedData -> fFormat . getAlias ( ) ; break ; case 2 : f = gSharedData -> fYDDThing ; o = & gSharedData -> fYDDStr ; nf = fFormat . getAlias ( ) ; break ; case 3 : f = gSharedData -> fBBDThing ; o = & gSharedData -> fBBDStr ; nf = fFormat . getAlias ( ) ; break ; } nf -> format ( f , str , NULL , status ) ; if ( * o != str ) { appendErr . append ( showDifference ( * o , str ) ) ; okay = FALSE ; } return okay ; } UBool U_CALLCONV isAcceptable ( void * , const char * , const char * , const UDataInfo * ) { return TRUE ; } class FormatThreadTest : public ThreadWithStatus { public : int fNum ; int fTraceInfo ; LocalPointer < ThreadSafeFormat > fTSF ; FormatThreadTest ( ) : ThreadWithStatus ( ) , fNum ( 0 ) , fTraceInfo ( 0 ) , fTSF ( NULL ) , fOffset ( 0 ) { UErrorCode status = U_ZERO_ERROR ; fTSF . adoptInstead ( new ThreadSafeFormat ( status ) ) ; static int32_t fgOffset = 0 ; fgOffset += 3 ; fOffset = fgOffset ; } virtual void run ( ) { fTraceInfo = 1 ; LocalPointer < NumberFormat > percentFormatter ; UErrorCode status = U_ZERO_ERROR ; # if 0 for ( int i = 0 ; i < 4000 ; i ++ ) { status = U_ZERO_ERROR ; UDataMemory * data1 = udata_openChoice ( 0 , " res " , " en _ US " , isAcceptable , 0 , & status ) ; UDataMemory * data2 = udata_openChoice ( 0 , " res " , " fr " , isAcceptable , 0 , & status ) ; udata_close ( data1 ) ; udata_close ( data2 ) ; if ( U_FAILURE ( status ) ) { error ( " udata _ openChoice ▁ failed . \n " ) ; break ; } } return ; # endif # if 0 int m ; for ( m = 0 ; m < 4000 ; m ++ ) { status = U_ZERO_ERROR ; UResourceBundle * res = NULL ; const char * localeName = NULL ; Locale loc = Locale :: getEnglish ( ) ; localeName = loc . getName ( ) ; res = ures_open ( NULL , localeName , & status ) ; ures_close ( res ) ; if ( U_FAILURE ( status ) ) { error ( " Resource ▁ bundle ▁ construction ▁ failed . \n " ) ; break ; } } return ; # endif FormatThreadTestData kNumberFormatTestData [ ] = { FormatThreadTestData ( ( double ) 5.0 , UnicodeString ( "5" , " " ) ) , FormatThreadTestData ( 6.0 , UnicodeString ( "6" , " " ) ) , FormatThreadTestData ( 20.0 , UnicodeString ( "20" , " " ) ) , FormatThreadTestData ( 8.0 , UnicodeString ( "8" , " " ) ) , FormatThreadTestData ( 8.3 , UnicodeString ( "8.3" , " " ) ) , FormatThreadTestData ( 12345 , UnicodeString ( "12,34@@ 5" , " " ) ) , FormatThreadTestData ( 81890.23 , UnicodeString ( "81,@@ 890.23@@ " , " " ) ) , } ; int32_t kNumberFormatTestDataLength = UPRV_LENGTHOF ( kNumberFormatTestData ) ; FormatThreadTestData kPercentFormatTestData [ ] = { FormatThreadTestData ( ( double ) 5.0 , CharsToUnicodeString ( "500\\u00a0 % " ) ) , FormatThreadTestData ( 1.0 , CharsToUnicodeString ( "100\\u00a0 % " ) ) , FormatThreadTestData ( 0.26 , CharsToUnicodeString ( "26\\u00a0 % " ) ) , FormatThreadTestData ( 16384.99 , CharsToUnicodeString ( "1\\u00a0638\\u00a@@ 0499\\u00a0 % " ) ) , FormatThreadTestData ( 81890.23 , CharsToUnicodeString ( "8\\u00a0189@@ \\u00a0023@@ \\u00a0 % " ) ) , } ; int32_t kPercentFormatTestDataLength = UPRV_LENGTHOF ( kPercentFormatTestData ) ; int32_t iteration ; status = U_ZERO_ERROR ; LocalPointer < NumberFormat > formatter ( NumberFormat :: createInstance ( Locale :: getEnglish ( ) , status ) ) ; if ( U_FAILURE ( status ) ) { error ( " Error ▁ on ▁ NumberFormat : : createInstance ( ) . " ) ; goto cleanupAndReturn ; } percentFormatter . adoptInstead ( NumberFormat :: createPercentInstance ( Locale :: getFrench ( ) , status ) ) ; if ( U_FAILURE ( status ) ) { error ( " Error ▁ on ▁ NumberFormat : : createPercentInstance ( ) . " ) ; goto cleanupAndReturn ; } for ( iteration = 0 ; ! getError ( ) && iteration < kFormatThreadIterations ; iteration ++ ) { int32_t whichLine = ( iteration + fOffset ) % kNumberFormatTestDataLength ; UnicodeString output ; formatter -> format ( kNumberFormatTestData [ whichLine ] . number , output ) ; if ( 0 != output . compare ( kNumberFormatTestData [ whichLine ] . string ) ) { error ( " format ( ) . . ▁ expected ▁ " + kNumberFormatTestData [ whichLine ] . string + " ▁ got ▁ " + output ) ; goto cleanupAndReturn ; } output . remove ( ) ; whichLine = ( iteration + fOffset ) % kPercentFormatTestDataLength ; percentFormatter -> format ( kPercentFormatTestData [ whichLine ] . number , output ) ; if ( 0 != output . compare ( kPercentFormatTestData [ whichLine ] . string ) ) { error ( " percent ▁ format ( ) . . ▁ \n " + showDifference ( kPercentFormatTestData [ whichLine ] . string , output ) ) ; goto cleanupAndReturn ; } const int kNumberOfMessageTests = 3 ; UErrorCode statusToCheck ; UnicodeString patternToCheck ; Locale messageLocale ; Locale countryToCheck ; double currencyToCheck ; UnicodeString expected ; switch ( ( iteration + fOffset ) % kNumberOfMessageTests ) { default : case 0 : statusToCheck = U_FILE_ACCESS_ERROR ; patternToCheck = "0 : Someone ▁ from ▁ { 2 } ▁ is ▁ receiving ▁ a ▁ # {0 } " " ▁ error ▁ - ▁ { 1 } . ▁ Their ▁ telephone ▁ call ▁ is ▁ costing ▁ " " { 3 , number , currency } . " ; messageLocale = Locale ( " en " , " US " ) ; countryToCheck = Locale ( " " , " HR " ) ; currencyToCheck = 8192.77 ; expected = "0 : Someone ▁ from ▁ Croatia ▁ is ▁ receiving ▁ a ▁ # 4 ▁ error ▁ - ▁ " " U _ FILE _ ACCESS _ ERROR . ▁ Their ▁ telephone ▁ call ▁ is ▁ costing ▁ $ 8,192.77 . " ; break ; case 1 : statusToCheck = U_INDEX_@@ OUTOFBOUNDS_ERROR ; patternToCheck = "1 : A ▁ customer ▁ in ▁ { 2 } ▁ is ▁ receiving ▁ a ▁ # {0 } ▁ error ▁ - ▁ { 1 } . ▁ " " Their ▁ telephone ▁ call ▁ is ▁ costing ▁ { 3 , number , currency } . " ; messageLocale = Locale ( " de " , " DE @ currency = DEM " ) ; countryToCheck = Locale ( " " , " BF " ) ; currencyToCheck = 2.32 ; expected = CharsToUnicodeString ( "1 : A ▁ customer ▁ in ▁ Burkina ▁ Faso ▁ is ▁ receiving ▁ a ▁ # 8 ▁ error ▁ - ▁ U _ INDEX _ OUTOFBOUNDS _ ERROR . ▁ " " Their ▁ telephone ▁ call ▁ is ▁ costing ▁ 2,32\\u00@@ A0DM . " ) ; break ; case 2 : statusToCheck = U_MEMORY_ALLOCATION_ERROR ; patternToCheck = "2 : user ▁ in ▁ { 2 } ▁ is ▁ receiving ▁ a ▁ # {0 } ▁ error ▁ - ▁ { 1 } . ▁ " " They ▁ insist ▁ they ▁ just ▁ spent ▁ { 3 , number , currency } ▁ " " on ▁ memory . " ; messageLocale = Locale ( " de " , " AT @ currency = ATS " ) ; countryToCheck = Locale ( " " , " US " ) ; currencyToCheck = 40193.@@ 12 ; expected = CharsToUnicodeString ( "2 : user ▁ in ▁ Vereinig@@ te ▁ Staaten ▁ is ▁ receiving ▁ a ▁ # 7 ▁ error " " ▁ - ▁ U _ MEMORY _ ALLOCATION _ ERROR . ▁ They ▁ insist ▁ they ▁ just ▁ spent " " ▁ \\u00f6@@ S\\u00A040.193@@ ,12 ▁ on ▁ memory . " ) ; break ; } UnicodeString result ; UErrorCode status = U_ZERO_ERROR ; formatErrorMessage ( status , patternToCheck , messageLocale , statusToCheck , countryToCheck , currencyToCheck , result ) ; if ( U_FAILURE ( status ) ) { UnicodeString tmp ( u_errorName ( status ) ) ; error ( " Failure ▁ on ▁ message ▁ format , ▁ pattern = " + patternToCheck + " , ▁ error ▁ = ▁ " + tmp ) ; goto cleanupAndReturn ; } if ( result != expected ) { error ( " PatternFormat : ▁ \n " + showDifference ( expected , result ) ) ; goto cleanupAndReturn ; } UnicodeString appendErr ; if ( ! fTSF -> doStuff ( fNum , appendErr , status ) ) { error ( appendErr ) ; goto cleanupAndReturn ; } } cleanupAndReturn : fTraceInfo = 2 ; } private : int32_t fOffset ; } ; void MultithreadTest :: TestThreadedIntl ( ) { int i ; UnicodeString theErr ; UBool haveDisplayedInfo [ kFormatThreadThreads ] ; static const int32_t PATIENCE_SECONDS = 45 ; UErrorCode threadSafeErr = U_ZERO_ERROR ; ThreadSafeFormatSharedData sharedData ( threadSafeErr ) ; assertSuccess ( " initializing ▁ ThreadSafeFormat " , threadSafeErr , TRUE ) ; logln ( " Spawning : ▁ % d ▁ threads ▁ * ▁ % d ▁ iterations ▁ each . " , kFormatThreadThreads , kFormatThreadIterations ) ; LocalArray < FormatThreadTest > tests ( new FormatThreadTest [ kFormatThreadThreads ] ) ; for ( int32_t j = 0 ; j < kFormatThreadThreads ; j ++ ) { tests [ j ] . fNum = j ; int32_t threadStatus = tests [ j ] . start ( ) ; if ( threadStatus != 0 ) { errln ( " System ▁ Error ▁ % d ▁ starting ▁ thread ▁ number ▁ % d . " , threadStatus , j ) ; SimpleThread :: errorFunc ( ) ; return ; } haveDisplayedInfo [ j ] = FALSE ; } UBool stillRunning ; UDate startTime , endTime ; startTime = Calendar :: getNow ( ) ; double lastComplaint = 0 ; do { stillRunning = FALSE ; endTime = Calendar :: getNow ( ) ; double elapsedSeconds = ( ( int32_t ) ( endTime - startTime ) / U_MILLIS_PER_SECOND ) ; if ( elapsedSeconds > PATIENCE_SECONDS ) { errln ( " Patience ▁ exceeded . ▁ Test ▁ is ▁ taking ▁ too ▁ long . " ) ; return ; } else if ( ( elapsedSeconds - lastComplaint ) > 2.0 ) { infoln ( " % .1f ▁ seconds ▁ elapsed ▁ ( still ▁ waiting . . ) " , elapsedSeconds ) ; lastComplaint = elapsedSeconds ; } SimpleThread :: sleep ( 1 ) ; for ( i = 0 ; i < kFormatThreadThreads ; i ++ ) { if ( tests [ i ] . isRunning ( ) ) { stillRunning = TRUE ; } else if ( haveDisplayedInfo [ i ] == FALSE ) { logln ( " Thread ▁ # ▁ % d ▁ is ▁ complete . . " , i ) ; if ( tests [ i ] . getError ( theErr ) ) { dataerrln ( UnicodeString ( " # " ) + i + " : ▁ " + theErr ) ; SimpleThread :: errorFunc ( ) ; } haveDisplayedInfo [ i ] = TRUE ; } } } while ( stillRunning ) ; assertSuccess ( " finalizing ▁ ThreadSafeFormat " , threadSafeErr , TRUE ) ; } # endif # if ! UCONFIG_NO_COLLATION # define kCollatorThreadThreads 10 # define kCollatorThreadPatience kCollatorThreadThreads * 30 struct Line { UChar buff [ 25 ] ; int32_t buflen ; } ; static UBool skipLineBecauseOfBug ( const UChar * s , int32_t length ) { if ( length >= 3 && ( s [ 0 ] == 0xfb2 || s [ 0 ] == 0xfb3 ) && s [ 1 ] == 0x334 && ( s [ 2 ] == 0xf73 || s [ 2 ] == 0xf75 || s [ 2 ] == 0xf81 ) ) { return TRUE ; } return FALSE ; } static UCollationResult normalizeResult ( int32_t result ) { return result < 0 ? UCOL_LESS : result == 0 ? UCOL_EQUAL : UCOL_GRE@@ ATER ; } class CollatorThreadTest : public ThreadWithStatus { private : const Collator * coll ; const Line * lines ; int32_t noLines ; UBool isAtLeastUCA62 ; public : CollatorThreadTest ( ) : ThreadWithStatus ( ) , coll ( NULL ) , lines ( NULL ) , noLines ( 0 ) , isAtLeastUCA62 ( TRUE ) { } ; void setCollator ( Collator * c , Line * l , int32_t nl , UBool atLeastUCA62 ) { coll = c ; lines = l ; noLines = nl ; isAtLeastUCA62 = atLeastUCA62 ; } virtual void run ( ) { uint8_t sk1 [ 1024 ] , sk2 [ 1024 ] ; uint8_t * oldSk = NULL , * newSk = sk1 ; int32_t oldLen = 0 ; int32_t prev = 0 ; int32_t i = 0 ; for ( i = 0 ; i < noLines ; i ++ ) { if ( lines [ i ] . buflen == 0 ) { continue ; } if ( skipLineBecauseOfBug ( lines [ i ] . buff , lines [ i ] . buflen ) ) { continue ; } int32_t resLen = coll -> getSortKey ( lines [ i ] . buff , lines [ i ] . buflen , newSk , 1024 ) ; if ( oldSk != NULL ) { int32_t skres = strcmp ( ( char * ) oldSk , ( char * ) newSk ) ; int32_t cmpres = coll -> compare ( lines [ prev ] . buff , lines [ prev ] . buflen , lines [ i ] . buff , lines [ i ] . buflen ) ; int32_t cmpres2 = coll -> compare ( lines [ i ] . buff , lines [ i ] . buflen , lines [ prev ] . buff , lines [ prev ] . buflen ) ; if ( cmpres != - cmpres2 ) { error ( UnicodeString ( " Compare ▁ result ▁ not ▁ symmetri@@ cal ▁ on ▁ line ▁ " ) + ( i + 1 ) ) ; break ; } if ( cmpres != normalizeResult ( skres ) ) { error ( UnicodeString ( " Difference ▁ between ▁ coll - > compare ▁ and ▁ sortkey ▁ compare ▁ on ▁ line ▁ " ) + ( i + 1 ) ) ; break ; } int32_t res = cmpres ; if ( res == 0 && ! isAtLeastUCA62 ) { res = u_strcmp@@ CodePoint@@ Order ( lines [ prev ] . buff , lines [ i ] . buff ) ; } if ( res > 0 ) { error ( UnicodeString ( " Line ▁ is ▁ not ▁ greater ▁ or ▁ equal ▁ than ▁ previous ▁ line , ▁ for ▁ line ▁ " ) + ( i + 1 ) ) ; break ; } } oldSk = newSk ; oldLen = resLen ; ( void ) oldLen ; prev = i ; newSk = ( newSk == sk1 ) ? sk2 : sk1 ; } } } ; void MultithreadTest :: TestCollators ( ) { UErrorCode status = U_ZERO_ERROR ; FILE * testFile = NULL ; char testDataPath [ 1024 ] ; strcpy ( testDataPath , IntlTest :: getSourceTestData ( status ) ) ; if ( U_FAILURE ( status ) ) { errln ( " ERROR : ▁ could ▁ not ▁ open ▁ test ▁ data ▁ % s " , u_errorName ( status ) ) ; return ; } strcat ( testDataPath , " CollationTest _ " ) ; const char * type = " NON _ IGNORABLE " ; const char * ext = " . txt " ; if ( testFile ) { fclose ( testFile ) ; } char buffer [ 1024 ] ; strcpy ( buffer , testDataPath ) ; strcat ( buffer , type ) ; size_t bufLen = strlen ( buffer ) ; strcpy ( buffer + bufLen , ext ) ; testFile = fopen ( buffer , " rb " ) ; if ( testFile == 0 ) { strcpy ( buffer + bufLen , " _ SHORT " ) ; strcat ( buffer , ext ) ; testFile = fopen ( buffer , " rb " ) ; if ( testFile == 0 ) { strcpy ( buffer + bufLen , " _ STUB " ) ; strcat ( buffer , ext ) ; testFile = fopen ( buffer , " rb " ) ; if ( testFile == 0 ) { * ( buffer + bufLen ) = 0 ; dataerrln ( " could ▁ not ▁ open ▁ any ▁ of ▁ the ▁ conformance ▁ test ▁ files , ▁ tried ▁ opening ▁ base ▁ % s " , buffer ) ; return ; } else { infoln ( " INFO : ▁ Working ▁ with ▁ the ▁ stub ▁ file . \n " " If ▁ you ▁ need ▁ the ▁ full ▁ conformance ▁ test , ▁ please \n " " download ▁ the ▁ appropriate ▁ data ▁ files ▁ from : \n " " http : // source . icu - project . org / repos / icu / tools / trunk / unicod@@ etools / com / ibm / text / data / " ) ; } } } LocalArray < Line > lines ( new Line [ 200000 ] ) ; memset ( lines . getAlias ( ) , 0 , sizeof ( Line ) * 200000 ) ; int32_t lineNum = 0 ; UChar bufferU [ 1024 ] ; uint32_t first = 0 ; while ( fgets ( buffer , 1024 , testFile ) != NULL ) { if ( * buffer == 0 || buffer [ 0 ] == ' # ' ) { lines [ lineNum ] . buflen = 0 ; lines [ lineNum ] . buff [ 0 ] = 0 ; } else { int32_t buflen = u_parseString ( buffer , bufferU , 1024 , & first , & status ) ; lines [ lineNum ] . buflen = buflen ; u_memcpy ( lines [ lineNum ] . buff , bufferU , buflen ) ; lines [ lineNum ] . buff [ buflen ] = 0 ; } lineNum ++ ; } fclose ( testFile ) ; if ( U_FAILURE ( status ) ) { dataerrln ( " Couldn ' t ▁ read ▁ the ▁ test ▁ file ! " ) ; return ; } UVersionInfo uniVersion ; static const UVersionInfo v62 = { 6 , 2 , 0 , 0 } ; u_getUnicode@@ Version ( uniVersion ) ; UBool isAtLeastUCA62 = uprv_memcmp ( uniVersion , v62 , 4 ) >= 0 ; LocalPointer < Collator > coll ( Collator :: createInstance ( Locale :: getRoot ( ) , status ) ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " Couldn ' t ▁ open ▁ UCA ▁ collator " ) ; return ; } coll -> setAttribute ( UCOL_NORM@@ ALIZATION_MODE , UCOL_ON , status ) ; coll -> setAttribute ( UCOL_CASE_FIRST , UCOL_OFF , status ) ; coll -> setAttribute ( UCOL_CASE_LEVEL , UCOL_OFF , status ) ; coll -> setAttribute ( UCOL_STRENG@@ TH , isAtLeastUCA62 ? UCOL_IDENTICAL : UCOL_TERTIARY , status ) ; coll -> setAttribute ( UCOL_ALTER@@ NATE_HANDLING , UCOL_NON_@@ IGNORABLE , status ) ; int32_t noSpawned = 0 ; int32_t spawnResult = 0 ; LocalArray < CollatorThreadTest > tests ( new CollatorThreadTest [ kCollatorThreadThreads ] ) ; logln ( UnicodeString ( " Spawning : ▁ " ) + kCollatorThreadThreads + " ▁ threads ▁ * ▁ " + kFormatThreadIterations + " ▁ iterations ▁ each . " ) ; int32_t j = 0 ; for ( j = 0 ; j < kCollatorThreadThreads ; j ++ ) { tests [ j ] . setCollator ( coll . getAlias ( ) , lines . getAlias ( ) , lineNum , isAtLeastUCA62 ) ; } for ( j = 0 ; j < kCollatorThreadThreads ; j ++ ) { log ( " % i ▁ " , j ) ; spawnResult = tests [ j ] . start ( ) ; if ( spawnResult != 0 ) { infoln ( " THREAD ▁ INFO : ▁ Couldn ' t ▁ spawn ▁ more ▁ than ▁ % i ▁ threads " , noSpawned ) ; break ; } noSpawned ++ ; } logln ( " Spawned ▁ all " ) ; if ( noSpawned == 0 ) { errln ( " No ▁ threads ▁ could ▁ be ▁ spawned . " ) ; return ; } for ( int32_t patience = kCollatorThreadPatience ; patience > 0 ; patience -- ) { logln ( " Waiting . . . " ) ; int32_t i ; int32_t terrs = 0 ; int32_t completed = 0 ; for ( i = 0 ; i < kCollatorThreadThreads ; i ++ ) { if ( tests [ i ] . isRunning ( ) == FALSE ) { completed ++ ; UnicodeString theErr ; if ( tests [ i ] . getError ( theErr ) ) { terrs ++ ; errln ( UnicodeString ( " # " ) + i + " : ▁ " + theErr ) ; } } } logln ( " Completed ▁ % i ▁ tests " , completed ) ; if ( completed == noSpawned ) { logln ( " Done ! ▁ All ▁ % i ▁ tests ▁ are ▁ finished " , noSpawned ) ; if ( terrs ) { errln ( " There ▁ were ▁ errors . " ) ; SimpleThread :: errorFunc ( ) ; } return ; } SimpleThread :: sleep ( 900 ) ; } errln ( " patience ▁ exceeded . ▁ " ) ; SimpleThread :: errorFunc ( ) ; } # endif const int kStringThreadIterations = 2500 ; const int kStringThreadThreads = 10 ; const int kStringThreadPatience = 120 ; class StringThreadTest2 : public ThreadWithStatus { public : int fNum ; int fTraceInfo ; const UnicodeString * fSharedString ; StringThreadTest2 ( const UnicodeString * sharedString , int num ) : ThreadWithStatus ( ) , fNum ( num ) , fTraceInfo ( 0 ) , fSharedString ( sharedString ) { } ; virtual void run ( ) { fTraceInfo = 1 ; int loopCount = 0 ; for ( loopCount = 0 ; loopCount < kStringThreadIterations ; loopCount ++ ) { if ( * fSharedString != " This ▁ is ▁ the ▁ original ▁ test ▁ string . " ) { error ( " Original ▁ string ▁ is ▁ corrupt . " ) ; break ; } UnicodeString s1 = * fSharedString ; s1 += " cat ▁ this " ; UnicodeString s2 ( s1 ) ; UnicodeString s3 = * fSharedString ; s2 = s3 ; s3 . truncate ( 12 ) ; s2 . truncate ( 0 ) ; } fTraceInfo = 2 ; } } ; void MultithreadTest :: TestString ( ) { int patience ; int terrs = 0 ; int j ; UnicodeString * testString = new UnicodeString ( " This ▁ is ▁ the ▁ original ▁ test ▁ string . " ) ; StringThreadTest2 * tests [ kStringThreadThreads ] ; for ( j = 0 ; j < kStringThreadThreads ; j ++ ) { tests [ j ] = new StringThreadTest2 ( testString , j ) ; } logln ( UnicodeString ( " Spawning : ▁ " ) + kStringThreadThreads + " ▁ threads ▁ * ▁ " + kStringThreadIterations + " ▁ iterations ▁ each . " ) ; for ( j = 0 ; j < kStringThreadThreads ; j ++ ) { int32_t threadStatus = tests [ j ] -> start ( ) ; if ( threadStatus != 0 ) { errln ( " System ▁ Error ▁ % d ▁ starting ▁ thread ▁ number ▁ % d . " , threadStatus , j ) ; SimpleThread :: errorFunc ( ) ; goto cleanupAndReturn ; } } for ( patience = kStringThreadPatience ; patience > 0 ; patience -- ) { logln ( " Waiting . . . " ) ; int32_t i ; terrs = 0 ; int32_t completed = 0 ; for ( i = 0 ; i < kStringThreadThreads ; i ++ ) { if ( tests [ i ] -> isRunning ( ) == FALSE ) { completed ++ ; logln ( UnicodeString ( " Test ▁ # " ) + i + " ▁ is ▁ complete . . ▁ " ) ; UnicodeString theErr ; if ( tests [ i ] -> getError ( theErr ) ) { terrs ++ ; errln ( UnicodeString ( " # " ) + i + " : ▁ " + theErr ) ; } } } if ( completed == kStringThreadThreads ) { logln ( " Done ! " ) ; if ( terrs ) { errln ( " There ▁ were ▁ errors . " ) ; } break ; } SimpleThread :: sleep ( 900 ) ; } if ( patience <= 0 ) { errln ( " patience ▁ exceeded . ▁ " ) ; terrs ++ ; } if ( terrs > 0 ) { SimpleThread :: errorFunc ( ) ; } cleanupAndReturn : if ( terrs == 0 ) { for ( j = 0 ; j < kStringThreadThreads ; j ++ ) { delete tests [ j ] ; } delete testString ; } } # if ! UCONFIG_NO_TRANSLITERATION class TxThread : public SimpleThread { private : Transliterator * fSharedTranslit ; public : UBool fSuccess ; TxThread ( Transliterator * tx ) : fSharedTranslit ( tx ) , fSuccess ( FALSE ) { } ; ~ TxThread ( ) ; void run ( ) ; } ; TxThread :: ~ TxThread ( ) { } void TxThread :: run ( ) { UnicodeString greekString ( " \\u03B4\\u03B9@@ \\u03B1\\u03C@@ 6\\u03BF\\u03C1\\u03B@@ 5\\u03C4\\u03B9@@ \\u03BA@@ \\u03BF\\u03CD\\u03C@@ 2" ) ; greekString = greekString . unescape ( ) ; fSharedTranslit -> transliterate ( greekString ) ; fSuccess = greekString [ 0 ] == 0x64 ; } # endif void MultithreadTest :: TestAnyTranslit ( ) { # if ! UCONFIG_NO_TRANSLITERATION UErrorCode status = U_ZERO_ERROR ; LocalPointer < Transliterator > tx ( Transliterator :: createInstance ( " Any - Latin " , UTRANS_FORWAR@@ D , status ) ) ; if ( U_FAILURE ( status ) ) { dataerrln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ status ▁ = ▁ % s " , __FILE__ , __LINE__ , u_errorName ( status ) ) ; return ; } TxThread * threads [ 4 ] ; int32_t i ; for ( i = 0 ; i < 4 ; i ++ ) { threads [ i ] = new TxThread ( tx . getAlias ( ) ) ; } for ( i = 0 ; i < 4 ; i ++ ) { threads [ i ] -> start ( ) ; } int32_t patience = 100 ; UBool success ; UBool someThreadRunning ; do { someThreadRunning = FALSE ; success = TRUE ; for ( i = 0 ; i < 4 ; i ++ ) { if ( threads [ i ] -> isRunning ( ) ) { someThreadRunning = TRUE ; SimpleThread :: sleep ( 10 ) ; break ; } else { if ( threads [ i ] -> fSuccess == FALSE ) { success = FALSE ; } } } } while ( someThreadRunning && -- patience > 0 ) ; if ( patience <= 0 ) { errln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ one ▁ or ▁ more ▁ threads ▁ did ▁ not ▁ complete . " , __FILE__ , __LINE__ ) ; } if ( success == FALSE ) { errln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ transliteration ▁ result ▁ incorrect . " , __FILE__ , __LINE__ ) ; } for ( i = 0 ; i < 4 ; i ++ ) { delete threads [ i ] ; } # endif } class CondThread : public SimpleThread { public : CondThread ( ) : fFinished ( false ) { } ; ~ CondThread ( ) { } ; void run ( ) ; bool fFinished ; } ; static UMutex gCTMutex = U_MUTEX_INITIALIZER ; static UConditionVar gCTConditionVar = U_CONDITION_INITIALIZER ; int gConditionTestOne = 1 ; int gStartedThreads ; int gFinishedThreads ; static const int NUMTHREADS = 10 ; static MultithreadTest * gThisTest = NULL ; void CondThread :: run ( ) { umtx_lock ( & gCTMutex ) ; gStartedThreads += gConditionTestOne ; umtx_condBroadcast ( & gCTConditionVar ) ; while ( gStartedThreads < NUMTHREADS ) { if ( gFinishedThreads != 0 ) { gThisTest -> errln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ gStartedThreads ▁ = ▁ % d , ▁ gFinishedThreads ▁ = ▁ % d " , __FILE__ , __LINE__ , gStartedThreads , gFinishedThreads ) ; } umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } gFinishedThreads += gConditionTestOne ; fFinished = true ; umtx_condBroadcast ( & gCTConditionVar ) ; while ( gFinishedThreads < NUMTHREADS ) { umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } umtx_unlock ( & gCTMutex ) ; } void MultithreadTest :: TestConditionVariables ( ) { gThisTest = this ; gStartedThreads = 0 ; gFinishedThreads = 0 ; int i ; umtx_lock ( & gCTMutex ) ; CondThread * threads [ NUMTHREADS ] ; for ( i = 0 ; i < NUMTHREADS ; ++ i ) { threads [ i ] = new CondThread ; threads [ i ] -> start ( ) ; } while ( gStartedThreads < NUMTHREADS ) { umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } while ( gFinishedThreads < NUMTHREADS ) { umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } umtx_unlock ( & gCTMutex ) ; for ( i = 0 ; i < NUMTHREADS ; ++ i ) { if ( ! threads [ i ] -> fFinished ) { errln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ threads [ % d ] - > fFinished ▁ = = ▁ false " , __FILE__ , __LINE__ , i ) ; } delete threads [ i ] ; } } static const char * gCacheLocales [ ] = { " en _ US " , " en _ GB " , " fr _ FR " , " fr " } ; static int32_t gObjectsCreated = 0 ; static const int32_t CACHE_LOAD = 3 ; class UCTMultiThreadItem : public SharedObject { public : char * value ; UCTMultiThreadItem ( const char * x ) : value ( NULL ) { value = uprv_strdup ( x ) ; } virtual ~ UCTMultiThreadItem ( ) { uprv_free ( value ) ; } } ; U_NAMESPACE_BEGIN template < > U_EXPORT const UCTMultiThreadItem * LocaleCacheKey < UCTMultiThreadItem > :: createObject ( const void * , UErrorCode & ) const { umtx_lock ( & gCTMutex ) ; if ( gObjectsCreated != 0 ) { gThisTest -> errln ( " Expected ▁ no ▁ objects ▁ to ▁ be ▁ created ▁ yet . " ) ; } umtx_unlock ( & gCTMutex ) ; SimpleThread :: sleep ( 1000 ) ; umtx_lock ( & gCTMutex ) ; ++ gObjectsCreated ; umtx_unlock ( & gCTMutex ) ; UCTMultiThreadItem * result = new UCTMultiThreadItem ( fLoc . getName ( ) ) ; result -> addRef ( ) ; return result ; } U_NAMESPACE_END class UnifiedCacheThread : public SimpleThread { public : UnifiedCacheThread ( const char * loc ) : fLoc ( loc ) { } ; ~ UnifiedCacheThread ( ) { } ; void run ( ) ; const char * fLoc ; } ; void UnifiedCacheThread :: run ( ) { UErrorCode status = U_ZERO_ERROR ; const UnifiedCache * cache = UnifiedCache :: getInstance ( status ) ; U_ASSERT ( status == U_ZERO_ERROR ) ; const UCTMultiThreadItem * item = NULL ; cache -> get ( LocaleCacheKey < UCTMultiThreadItem > ( fLoc ) , item , status ) ; U_ASSERT ( item != NULL ) ; if ( uprv_strcmp ( fLoc , item -> value ) ) { gThisTest -> errln ( " Expected ▁ % s , ▁ got ▁ % s " , fLoc , item -> value ) ; } item -> removeRef ( ) ; umtx_lock ( & gCTMutex ) ; ++ gFinishedThreads ; umtx_condBroadcast ( & gCTConditionVar ) ; umtx_unlock ( & gCTMutex ) ; } void MultithreadTest :: TestUnifiedCache ( ) { UErrorCode status = U_ZERO_ERROR ; const UnifiedCache * cache = UnifiedCache :: getInstance ( status ) ; U_ASSERT ( cache != NULL ) ; cache -> flush ( ) ; gThisTest = this ; gFinishedThreads = 0 ; gObjectsCreated = 0 ; UnifiedCacheThread * threads [ CACHE_LOAD ] [ UPRV_LENGTHOF ( gCacheLocales ) ] ; for ( int32_t i = 0 ; i < CACHE_LOAD ; ++ i ) { for ( int32_t j = 0 ; j < UPRV_LENGTHOF ( gCacheLocales ) ; ++ j ) { threads [ i ] [ j ] = new UnifiedCacheThread ( gCacheLocales [ j ] ) ; threads [ i ] [ j ] -> start ( ) ; } } umtx_lock ( & gCTMutex ) ; while ( gFinishedThreads < CACHE_LOAD * UPRV_LENGTHOF ( gCacheLocales ) ) { umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } assertEquals ( " Objects ▁ created " , UPRV_LENGTHOF ( gCacheLocales ) , gObjectsCreated ) ; umtx_unlock ( & gCTMutex ) ; for ( int32_t i = 0 ; i < CACHE_LOAD ; ++ i ) { for ( int32_t j = 0 ; j < UPRV_LENGTHOF ( gCacheLocales ) ; ++ j ) { delete threads [ i ] [ j ] ; } } } # endif </DOCUMENT>
<DOCUMENT_ID="didouthe@@ one/Mang@@ osOne@@ Didou@@ /tree/master/dep/recast@@ navigation/@@ Recast@@ Demo/Source/@@ CrowdManager.cpp"> # define _USE_MATH_DEFINES # include < math . h > # include < stdio . h > # include < stdlib . h > # include < string . h > # include < float . h > # include " DetourNavMesh . h " # include " DetourNavMeshQuery . h " # include " DetourObstacleAvoid@@ ance . h " # include " DetourCommon . h " # include " CrowdManager . h " # include " SampleInterfaces . h " # include " DetourAssert . h " # include " DetourAlloc . h " static const int VO_ADAPTIVE_DIVS = 7 ; static const int VO_ADAPTIVE_RINGS = 2 ; static const int VO_ADAPTIVE_DEPTH = 5 ; static const int VO_GRID_SIZE = 33 ; inline int hashPos2 ( int x , int y , int n ) { return ( ( x * 73856093 ) ^ ( y * 19349@@ 663 ) ) & ( n - 1 ) ; } ProximityGrid :: ProximityGrid ( ) : m_maxItems ( 0 ) , m_cellSize ( 0 ) , m_pool ( 0 ) , m_poolHead ( 0 ) , m_poolSize ( 0 ) , m_buckets ( 0 ) , m_bucketsSize ( 0 ) { } ProximityGrid :: ~ ProximityGrid ( ) { dtFree ( m_buckets ) ; dtFree ( m_pool ) ; } bool ProximityGrid :: init ( const int maxItems , const float cellSize ) { dtAssert ( maxItems > 0 ) ; dtAssert ( cellSize > 0.0f ) ; m_cellSize = cellSize ; m_invCellSize = 1.0f / m_cellSize ; m_bucketsSize = dtNext@@ Pow2 ( maxItems ) ; m_buckets = ( unsigned short * ) dtAlloc ( sizeof ( unsigned short ) * m_bucketsSize , DT_ALLOC_PERM ) ; if ( ! m_buckets ) return false ; m_poolSize = maxItems * 4 ; m_poolHead = 0 ; m_pool = ( Item * ) dtAlloc ( sizeof ( Item ) * m_poolSize , DT_ALLOC_PERM ) ; if ( ! m_pool ) return false ; clear ( ) ; return true ; } void ProximityGrid :: clear ( ) { memset ( m_buckets , 0xff , sizeof ( unsigned short ) * m_bucketsSize ) ; m_poolHead = 0 ; m_bounds [ 0 ] = 0xffff ; m_bounds [ 1 ] = 0xffff ; m_bounds [ 2 ] = - 0xffff ; m_bounds [ 3 ] = - 0xffff ; } void ProximityGrid :: addItem ( const unsigned short id , const float minx , const float miny , const float maxx , const float maxy ) { const int iminx = ( int ) floorf ( minx * m_invCellSize ) ; const int iminy = ( int ) floorf ( miny * m_invCellSize ) ; const int imaxx = ( int ) floorf ( maxx * m_invCellSize ) ; const int imaxy = ( int ) floorf ( maxy * m_invCellSize ) ; m_bounds [ 0 ] = dtMin ( m_bounds [ 0 ] , iminx ) ; m_bounds [ 1 ] = dtMin ( m_bounds [ 1 ] , iminy ) ; m_bounds [ 2 ] = dtMax ( m_bounds [ 2 ] , imaxx ) ; m_bounds [ 3 ] = dtMax ( m_bounds [ 3 ] , imaxy ) ; for ( int y = iminy ; y <= imaxy ; ++ y ) { for ( int x = iminx ; x <= imaxx ; ++ x ) { if ( m_poolHead < m_poolSize ) { const int h = hashPos2 ( x , y , m_bucketsSize ) ; const unsigned short idx = ( unsigned short ) m_poolHead ; m_poolHead ++ ; Item & item = m_pool [ idx ] ; item . x = ( short ) x ; item . y = ( short ) y ; item . id = id ; item . next = m_buckets [ h ] ; m_buckets [ h ] = idx ; } } } } int ProximityGrid :: queryItems ( const float minx , const float miny , const float maxx , const float maxy , unsigned short * ids , const int maxIds ) const { const int iminx = ( int ) floorf ( minx * m_invCellSize ) ; const int iminy = ( int ) floorf ( miny * m_invCellSize ) ; const int imaxx = ( int ) floorf ( maxx * m_invCellSize ) ; const int imaxy = ( int ) floorf ( maxy * m_invCellSize ) ; int n = 0 ; for ( int y = iminy ; y <= imaxy ; ++ y ) { for ( int x = iminx ; x <= imaxx ; ++ x ) { const int h = hashPos2 ( x , y , m_bucketsSize ) ; unsigned short idx = m_buckets [ h ] ; while ( idx != 0xffff ) { Item & item = m_pool [ idx ] ; if ( ( int ) item . x == x && ( int ) item . y == y ) { const unsigned short * end = ids + n ; unsigned short * i = ids ; while ( i != end && * i != item . id ) ++ i ; if ( i == end ) { if ( n >= maxIds ) return n ; ids [ n ++ ] = item . id ; } } idx = item . next ; } } } return n ; } int ProximityGrid :: getItemCountAt ( const int x , const int y ) const { int n = 0 ; const int h = hashPos2 ( x , y , m_bucketsSize ) ; unsigned short idx = m_buckets [ h ] ; while ( idx != 0xffff ) { Item & item = m_pool [ idx ] ; if ( ( int ) item . x == x && ( int ) item . y == y ) n ++ ; idx = item . next ; } return n ; } PathQueue :: PathQueue ( ) : m_nextHandle ( 1 ) , m_delay ( 0 ) { for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) m_queue [ i ] . ref = PATHQ_INVALID ; } PathQueue :: ~ PathQueue ( ) { } void PathQueue :: update ( dtNavMeshQuery * navquery ) { m_delay ++ ; if ( ( m_delay % 4 ) == 0 ) { for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { PathQuery & q = m_queue [ i ] ; if ( q . ref == PATHQ_INVALID ) continue ; navquery -> findPath ( q . startRef , q . endRef , q . startPos , q . endPos , q . filter , q . path , & q . npath , PQ_MAX_PATH ) ; q . ready = true ; break ; } } for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { PathQuery & q = m_queue [ i ] ; if ( q . ref != PATHQ_INVALID && q . ready ) { q . keepalive ++ ; if ( q . keepalive > 2 ) q . ref = PATHQ_INVALID ; } } } PathQueueRef PathQueue :: request ( dtPolyRef startRef , dtPolyRef endRef , const float * startPos , const float * endPos , const dtQueryFilter * filter ) { int slot = - 1 ; for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { if ( m_queue [ i ] . ref == PATHQ_INVALID ) { slot = i ; break ; } } if ( slot == - 1 ) return PATHQ_INVALID ; PathQueueRef ref = m_nextHandle ++ ; if ( m_nextHandle == PATHQ_INVALID ) m_nextHandle ++ ; PathQuery & q = m_queue [ slot ] ; q . ref = ref ; dtVcopy ( q . startPos , startPos ) ; q . startRef = startRef ; dtVcopy ( q . endPos , endPos ) ; q . endRef = endRef ; q . ready = false ; q . npath = 0 ; q . filter = filter ; q . keepalive = 0 ; return ref ; } int PathQueue :: getRequestState ( PathQueueRef ref ) { for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { if ( m_queue [ i ] . ref == ref ) return m_queue [ i ] . ready ? PATHQ_STATE_READY : PATHQ_STATE_WORKING ; } return PATHQ_STATE_INVALID ; } int PathQueue :: getPathResult ( PathQueueRef ref , dtPolyRef * path , const int maxPath ) { for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { if ( m_queue [ i ] . ref == ref ) { PathQuery & q = m_queue [ i ] ; q . ref = PATHQ_INVALID ; int n = 0 ; for ( int j = 0 ; j < q . npath && j < maxPath ; ++ j ) path [ n ++ ] = q . path [ j ] ; return n ; } } return 0 ; } static int fixupCorridor ( dtPolyRef * path , const int npath , const int maxPath , const dtPolyRef * visited , const int nvisited ) { int furthestPath = - 1 ; int furthestVisited = - 1 ; for ( int i = npath - 1 ; i >= 0 ; -- i ) { bool found = false ; for ( int j = nvisited - 1 ; j >= 0 ; -- j ) { if ( path [ i ] == visited [ j ] ) { furthestPath = i ; furthestVisited = j ; found = true ; } } if ( found ) break ; } if ( furthestPath == - 1 || furthestVisited == - 1 ) return npath ; const int req = nvisited - furthestVisited ; const int orig = dtMin ( furthestPath + 1 , npath ) ; int size = dtMax ( 0 , npath - orig ) ; if ( req + size > maxPath ) size = maxPath - req ; if ( size ) memmove ( path + req , path + orig , size * sizeof ( dtPolyRef ) ) ; for ( int i = 0 ; i < req ; ++ i ) path [ i ] = visited [ ( nvisited - 1 ) - i ] ; return req + size ; } static int fixupCorridorEnd ( dtPolyRef * path , const int npath , const int maxPath , const dtPolyRef * visited , const int nvisited ) { int furthestPath = - 1 ; int furthestVisited = - 1 ; for ( int i = 0 ; i < npath ; ++ i ) { bool found = false ; for ( int j = nvisited - 1 ; j >= 0 ; -- j ) { if ( path [ i ] == visited [ j ] ) { furthestPath = i ; furthestVisited = j ; found = true ; } } if ( found ) break ; } if ( furthestPath == - 1 || furthestVisited == - 1 ) return npath ; const int ppos = furthestPath + 1 ; const int vpos = furthestVisited + 1 ; const int count = dtMin ( nvisited - vpos , maxPath - ppos ) ; dtAssert ( ppos + count <= maxPath ) ; if ( count ) memcpy ( path + ppos , visited + vpos , sizeof ( dtPolyRef ) * count ) ; return ppos + count ; } static int mergeCorridor ( dtPolyRef * path , const int npath , const int maxPath , const dtPolyRef * visited , const int nvisited ) { int furthestPath = - 1 ; int furthestVisited = - 1 ; for ( int i = npath - 1 ; i >= 0 ; -- i ) { bool found = false ; for ( int j = nvisited - 1 ; j >= 0 ; -- j ) { if ( path [ i ] == visited [ j ] ) { furthestPath = i ; furthestVisited = j ; found = true ; } } if ( found ) break ; } if ( furthestPath == - 1 || furthestVisited == - 1 ) return npath ; const int req = furthestVisited ; if ( req <= 0 ) return npath ; const int orig = furthestPath ; int size = dtMax ( 0 , npath - orig ) ; if ( req + size > maxPath ) size = maxPath - req ; if ( size ) memmove ( path + req , path + orig , size * sizeof ( dtPolyRef ) ) ; for ( int i = 0 ; i < req ; ++ i ) path [ i ] = visited [ i ] ; return req + size ; } PathCorridor :: PathCorridor ( ) : m_path ( 0 ) , m_npath ( 0 ) , m_maxPath ( 0 ) { } PathCorridor :: ~ PathCorridor ( ) { dtFree ( m_path ) ; } bool PathCorridor :: init ( const int maxPath ) { dtAssert ( ! m_path ) ; m_path = ( dtPolyRef * ) dtAlloc ( sizeof ( dtPolyRef ) * maxPath , DT_ALLOC_PERM ) ; if ( ! m_path ) return false ; m_npath = 0 ; m_maxPath = maxPath ; return true ; } void PathCorridor :: reset ( dtPolyRef ref , const float * pos ) { dtAssert ( m_path ) ; dtVcopy ( m_pos , pos ) ; dtVcopy ( m_target , pos ) ; m_path [ 0 ] = ref ; m_npath = 1 ; } int PathCorridor :: findCorners ( float * cornerVerts , unsigned char * cornerFlags , dtPolyRef * cornerPolys , const int maxCorners , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; dtAssert ( m_npath ) ; static const float MIN_TARGET_DIST = 0.01f ; int ncorners = 0 ; navquery -> findStraight@@ Path ( m_pos , m_target , m_path , m_npath , cornerVerts , cornerFlags , cornerPolys , & ncorners , maxCorners ) ; while ( ncorners ) { if ( ( cornerFlags [ 0 ] & DT_STRAIGHTPATH_OFFMESH_CONNECTION ) || dtVdist2DSqr ( & cornerVerts [ 0 ] , m_pos ) > dtSqr ( MIN_TARGET_DIST ) ) break ; ncorners -- ; if ( ncorners ) { memmove ( cornerFlags , cornerFlags + 1 , sizeof ( unsigned char ) * ncorners ) ; memmove ( cornerPolys , cornerPolys + 1 , sizeof ( dtPolyRef ) * ncorners ) ; memmove ( cornerVerts , cornerVerts + 3 , sizeof ( float ) * 3 * ncorners ) ; } } for ( int i = 0 ; i < ncorners ; ++ i ) { if ( cornerFlags [ i ] & DT_STRAIGHTPATH_OFFMESH_CONNECTION ) { ncorners = i + 1 ; break ; } } return ncorners ; } void PathCorridor :: optimizePathVisibility ( const float * next , const float pathOptimizationRange , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; float goal [ 3 ] ; dtVcopy ( goal , next ) ; float dist = dtVdist2D ( m_pos , goal ) ; if ( dist < 0.01f ) return ; dist = dtMin ( dist + 0.01f , pathOptimizationRange ) ; float delta [ 3 ] ; dtVsub ( delta , goal , m_pos ) ; dtVmad ( goal , m_pos , delta , pathOptimizationRange / dist ) ; static const int MAX_RES = 32 ; dtPolyRef res [ MAX_RES ] ; float t , norm [ 3 ] ; int nres = 0 ; navquery -> raycast ( m_path [ 0 ] , m_pos , goal , filter , & t , norm , res , & nres , MAX_RES ) ; if ( nres > 1 && t > 0.99f ) { m_npath = mergeCorridor ( m_path , m_npath , m_maxPath , res , nres ) ; } } bool PathCorridor :: optimizePathTopology ( dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; if ( m_npath < 3 ) return false ; static const int MAX_ITER = 32 ; static const int MAX_RES = 32 ; dtPolyRef res [ MAX_RES ] ; int nres = 0 ; navquery -> initSlicedFindPath ( m_path [ 0 ] , m_path [ m_npath - 1 ] , m_pos , m_target , filter ) ; navquery -> updateSlicedFindPath ( MAX_ITER ) ; dtStatus status = navquery -> finalizeSlicedFindPathPartial ( m_path , m_npath , res , & nres , MAX_RES ) ; if ( status == DT_SUCCESS && nres > 0 ) { m_npath = mergeCorridor ( m_path , m_npath , m_maxPath , res , nres ) ; return true ; } return false ; } void PathCorridor :: movePosition ( const float * npos , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; dtAssert ( m_npath ) ; float result [ 3 ] ; static const int MAX_VISITED = 16 ; dtPolyRef visited [ MAX_VISITED ] ; int nvisited = 0 ; navquery -> moveAlongSurface ( m_path [ 0 ] , m_pos , npos , filter , result , visited , & nvisited , MAX_VISITED ) ; m_npath = fixupCorridor ( m_path , m_npath , m_maxPath , visited , nvisited ) ; float h = m_pos [ 1 ] ; navquery -> getPolyHeight ( m_path [ 0 ] , result , & h ) ; result [ 1 ] = h ; dtVcopy ( m_pos , result ) ; } void PathCorridor :: moveTargetPosition ( const float * npos , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; dtAssert ( m_npath ) ; float result [ 3 ] ; static const int MAX_VISITED = 16 ; dtPolyRef visited [ MAX_VISITED ] ; int nvisited = 0 ; navquery -> moveAlongSurface ( m_path [ m_npath - 1 ] , m_target , npos , filter , result , visited , & nvisited , MAX_VISITED ) ; m_npath = fixupCorridorEnd ( m_path , m_npath , m_maxPath , visited , nvisited ) ; dtVcopy ( m_target , result ) ; } void PathCorridor :: setCorridor ( const float * target , const dtPolyRef * path , const int npath ) { dtAssert ( m_path ) ; dtAssert ( npath > 0 ) ; dtAssert ( npath < m_maxPath ) ; dtVcopy ( m_target , target ) ; memcpy ( m_path , path , sizeof ( dtPolyRef ) * npath ) ; m_npath = npath ; } void Agent :: integrate ( const float maxAcc , const float dt ) { const float maxDelta = maxAcc * dt ; float dv [ 3 ] ; dtVsub ( dv , nvel , vel ) ; float ds = dtVlen ( dv ) ; if ( ds > maxDelta ) dtVscale ( dv , dv , maxDelta / ds ) ; dtVadd ( vel , vel , dv ) ; if ( dtVlen ( vel ) > 0.0001f ) dtVmad ( npos , npos , vel , dt ) ; else dtVset ( vel , 0 , 0 , 0 ) ; } float Agent :: getDistanceToGoal ( const float range ) const { if ( ! ncorners ) return range ; const bool endOfPath = ( cornerFlags [ ncorners - 1 ] & DT_STRAIGHTPATH_END ) ? true : false ; const bool offMeshConnection = ( cornerFlags [ ncorners - 1 ] & DT_STRAIGHTPATH_OFFMESH_CONNECTION ) ? true : false ; if ( endOfPath || offMeshConnection ) return dtMin ( dtVdist2D ( npos , & cornerVerts [ ( ncorners - 1 ) * 3 ] ) , range ) ; return range ; } void Agent :: calcSmoothSteerDirection ( float * dir ) { if ( ! ncorners ) { dtVset ( dir , 0 , 0 , 0 ) ; return ; } const int ip0 = 0 ; const int ip1 = dtMin ( 1 , ncorners - 1 ) ; const float * p0 = & cornerVerts [ ip0 * 3 ] ; const float * p1 = & cornerVerts [ ip1 * 3 ] ; float dir0 [ 3 ] , dir1 [ 3 ] ; dtVsub ( dir0 , p0 , npos ) ; dtVsub ( dir1 , p1 , npos ) ; dir0 [ 1 ] = 0 ; dir1 [ 1 ] = 0 ; float len0 = dtVlen ( dir0 ) ; float len1 = dtVlen ( dir1 ) ; if ( len1 > 0.001f ) dtVscale ( dir1 , dir1 , 1.0f / len1 ) ; dir [ 0 ] = dir0 [ 0 ] - dir1 [ 0 ] * len0 * 0.5f ; dir [ 1 ] = 0 ; dir [ 2 ] = dir0 [ 2 ] - dir1 [ 2 ] * len0 * 0.5f ; dtVnormalize ( dir ) ; } void Agent :: calcStraightSteerDirection ( float * dir ) { if ( ! ncorners ) { dtVset ( dir , 0 , 0 , 0 ) ; return ; } dtVsub ( dir , & cornerVerts [ 0 ] , npos ) ; dir [ 1 ] = 0 ; dtVnormalize ( dir ) ; } LocalBoundary :: LocalBoundary ( ) : m_nsegs ( 0 ) { dtVset ( m_center , FLT_MAX , FLT_MAX , FLT_MAX ) ; } LocalBoundary :: ~ LocalBoundary ( ) { } void LocalBoundary :: reset ( ) { dtVset ( m_center , FLT_MAX , FLT_MAX , FLT_MAX ) ; m_nsegs = 0 ; } void LocalBoundary :: addSegment ( const float dist , const float * s ) { Segment * seg = 0 ; if ( ! m_nsegs ) { seg = & m_segs [ 0 ] ; } else if ( dist >= m_segs [ m_nsegs - 1 ] . d ) { if ( m_nsegs >= MAX_SEGS ) return ; seg = & m_segs [ m_nsegs ] ; } else { int i ; for ( i = 0 ; i < m_nsegs ; ++ i ) if ( dist <= m_segs [ i ] . d ) break ; const int tgt = i + 1 ; const int n = dtMin ( m_nsegs - i , MAX_SEGS - tgt ) ; dtAssert ( tgt + n <= MAX_SEGS ) ; if ( n > 0 ) memmove ( & m_segs [ tgt ] , & m_segs [ i ] , sizeof ( Segment ) * n ) ; seg = & m_segs [ i ] ; } seg -> d = dist ; memcpy ( seg -> s , s , sizeof ( float ) * 6 ) ; if ( m_nsegs < MAX_SEGS ) m_nsegs ++ ; } void LocalBoundary :: update ( dtPolyRef ref , const float * pos , const float collisionQueryRange , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { static const int MAX_LOCAL_POLYS = 16 ; static const int MAX_SEGS_PER_POLY = DT_VERTS_@@ PER_POLYGON * 2 ; if ( ! ref ) { dtVset ( m_center , FLT_MAX , FLT_MAX , FLT_MAX ) ; m_nsegs = 0 ; return ; } dtVcopy ( m_center , pos ) ; dtPolyRef locals [ MAX_LOCAL_POLYS ] ; int nlocals = 0 ; navquery -> findLocalNeighbour@@ hood ( ref , pos , collisionQueryRange , filter , locals , 0 , & nlocals , MAX_LOCAL_POLYS ) ; m_nsegs = 0 ; float segs [ MAX_SEGS_PER_POLY * 6 ] ; int nsegs = 0 ; for ( int j = 0 ; j < nlocals ; ++ j ) { navquery -> getPolyWallSegments ( locals [ j ] , filter , segs , & nsegs , MAX_SEGS_PER_POLY ) ; for ( int k = 0 ; k < nsegs ; ++ k ) { const float * s = & segs [ k * 6 ] ; float tseg ; const float distSqr = dtDistance@@ PtSegSqr2D ( pos , s , s + 3 , tseg ) ; if ( distSqr > dtSqr ( collisionQueryRange ) ) continue ; addSegment ( distSqr , s ) ; } } } CrowdManager :: CrowdManager ( ) : m_obstacleQuery ( 0 ) , m_pathResult ( 0 ) , m_maxPathResult ( 0 ) , m_totalTime ( 0 ) , m_rvoTime ( 0 ) , m_sampleCount ( 0 ) , m_moveRequestCount ( 0 ) { dtVset ( m_ext , 2 , 4 , 2 ) ; m_obstacleQuery = dtAllocObstacleAvoidanceQuery ( ) ; m_obstacleQuery -> init ( 6 , 8 ) ; m_obstacleQuery -> setDesiredVelocityWeight ( 2.0f ) ; m_obstacleQuery -> setCurrentVelocityWeight ( 0.75f ) ; m_obstacleQuery -> setPreferred@@ SideWeight ( 0.75f ) ; m_obstacleQuery -> setCollisionTimeWeight ( 2.5f ) ; m_obstacleQuery -> setTimeHorizon ( 2.5f ) ; m_obstacleQuery -> setVelocitySelectionBias ( 0.4f ) ; memset ( m_vodebug , 0 , sizeof ( m_vodebug ) ) ; const int maxAdaptiveSamples = ( VO_ADAPTIVE_DIVS * VO_ADAPTIVE_RINGS + 1 ) * VO_ADAPTIVE_DEPTH ; const int maxGridSamples = VO_GRID_SIZE * VO_GRID_SIZE ; const int sampleCount = dtMax ( maxAdaptiveSamples , maxGridSamples ) ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) { m_vodebug [ i ] = dtAllocObstacleAvoidanceDebugData ( ) ; m_vodebug [ i ] -> init ( sampleCount ) ; } m_maxPathResult = 256 ; m_pathResult = ( dtPolyRef * ) dtAlloc ( sizeof ( dtPolyRef ) * m_maxPathResult , DT_ALLOC_PERM ) ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) { m_agents [ i ] . corridor . init ( m_maxPathResult ) ; } m_grid . init ( 100 , 1.0f ) ; reset ( ) ; } CrowdManager :: ~ CrowdManager ( ) { delete [ ] m_pathResult ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) dtFreeObstacleAvoidanceDebugData ( m_vodebug [ i ] ) ; dtFreeObstacleAvoidanceQuery ( m_obstacleQuery ) ; } void CrowdManager :: reset ( ) { for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) m_agents [ i ] . active = 0 ; } const int CrowdManager :: getAgentCount ( ) const { return MAX_AGENTS ; } const Agent * CrowdManager :: getAgent ( const int idx ) { return & m_agents [ idx ] ; } int CrowdManager :: addAgent ( const float * pos , const float radius , const float height , dtNavMeshQuery * navquery ) { int idx = - 1 ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) { if ( ! m_agents [ i ] . active ) { idx = i ; break ; } } if ( idx == - 1 ) return - 1 ; Agent * ag = & m_agents [ idx ] ; float nearest [ 3 ] ; dtPolyRef ref ; navquery -> findNearest@@ Poly ( pos , m_ext , & m_filter , & ref , nearest ) ; if ( ! ref ) { return - 1 ; } ag -> corridor . reset ( ref , nearest ) ; ag -> boundary . reset ( ) ; ag -> radius = radius ; ag -> height = height ; ag -> collisionQueryRange = radius * 8 ; ag -> pathOptimizationRange = radius * 30 ; ag -> topologyOptTime = 0 ; ag -> nneis = 0 ; dtVset ( ag -> dvel , 0 , 0 , 0 ) ; dtVset ( ag -> nvel , 0 , 0 , 0 ) ; dtVset ( ag -> vel , 0 , 0 , 0 ) ; dtVcopy ( ag -> npos , nearest ) ; ag -> maxspeed = 0 ; ag -> t = 0 ; dtVset ( ag -> opts , 0 , 0 , 0 ) ; dtVset ( ag -> opte , 0 , 0 , 0 ) ; ag -> active = 1 ; ag -> var = ( rand ( ) % 10 ) / 9.0f ; for ( int i = 0 ; i < AGENT_MAX_TRAIL ; ++ i ) dtVcopy ( & ag -> trail [ i * 3 ] , ag -> corridor . getPos ( ) ) ; ag -> htrail = 0 ; return idx ; } void CrowdManager :: removeAgent ( const int idx ) { if ( idx >= 0 && idx < MAX_AGENTS ) { m_agents [ idx ] . active = 0 ; } } bool CrowdManager :: requestMoveTarget ( const int idx , dtPolyRef ref , const float * pos ) { if ( idx < 0 || idx > MAX_AGENTS ) return false ; if ( ! ref ) return false ; MoveRequest * req = 0 ; for ( int i = 0 ; i < m_moveRequestCount ; ++ i ) { if ( m_moveRequests [ i ] . idx == idx ) { req = & m_moveRequests [ i ] ; break ; } } if ( ! req ) { if ( m_moveRequestCount >= MAX_AGENTS ) return false ; req = & m_moveRequests [ m_moveRequestCount ++ ] ; memset ( req , 0 , sizeof ( MoveRequest ) ) ; } req -> idx = idx ; req -> ref = ref ; dtVcopy ( req -> pos , pos ) ; req -> pathqRef = PATHQ_INVALID ; req -> state = MR_TARGET_REQUESTING ; req -> temp [ 0 ] = ref ; req -> ntemp = 1 ; return true ; } bool CrowdManager :: adjustMoveTarget ( const int idx , dtPolyRef ref , const float * pos ) { if ( idx < 0 || idx > MAX_AGENTS ) return false ; if ( ! ref ) return false ; MoveRequest * req = 0 ; for ( int i = 0 ; i < m_moveRequestCount ; ++ i ) { if ( m_moveRequests [ i ] . idx == idx ) { req = & m_moveRequests [ i ] ; break ; } } if ( ! req ) { if ( m_moveRequestCount >= MAX_AGENTS ) return false ; req = & m_moveRequests [ m_moveRequestCount ++ ] ; memset ( req , 0 , sizeof ( MoveRequest ) ) ; req -> state = MR_TARGET_ADJUST ; req -> idx = idx ; } req -> aref = ref ; dtVcopy ( req -> apos , pos ) ; return true ; } int CrowdManager :: getActiveAgents ( Agent * * agents , const int maxAgents ) { int n = 0 ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) { if ( ! m_agents [ i ] . active ) continue ; if ( n < maxAgents ) agents [ n ++ ] = & m_agents [ i ] ; } return n ; } static int addNeighbour ( const int idx , const float dist , Neighbour * neis , const int nneis , const int maxNeis ) { Neighbour * nei = 0 ; if ( ! nneis ) { nei = & neis [ nneis ] ; } else if ( dist >= neis [ nneis - 1 ] . dist ) { if ( nneis >= maxNeis ) return nneis ; nei = & neis [ nneis ] ; } else { int i ; for ( i = 0 ; i < nneis ; ++ i ) if ( dist <= neis [ i ] . dist ) break ; const int tgt = i + 1 ; const int n = dtMin ( nneis - i , maxNeis - tgt ) ; dtAssert ( tgt + n <= maxNeis ) ; if ( n > 0 ) memmove ( & neis [ tgt ] , & neis [ i ] , sizeof ( Neighbour ) * n ) ; nei = & neis [ i ] ; } memset ( nei , 0 , sizeof ( Neighbour ) ) ; nei -> idx = idx ; nei -> dist = dist ; return dtMin ( nneis + 1 , maxNeis ) ; } int CrowdManager :: getNeighbours ( const float * pos , const float height , const float range , const Agent * skip , Neighbour * result , const int maxResult ) { int n = 0 ; unsigned short ids [ MAX_AGENTS ] ; int nids = m_grid . queryItems ( pos [ 0 ] - range , pos [ 2 ] - range , pos [ 0 ] + range , pos [ 2 ] + range , ids , MAX_AGENTS ) ; for ( int i = 0 ; i < nids ; ++ i ) { Agent * ag = & m_agents [ ids [ i ] ] ; if ( ag == skip ) continue ; float diff [ 3 ] ; dtVsub ( diff , pos , ag -> npos ) ; if ( fabsf ( diff [ 1 ] ) >= ( height + ag -> height ) / 2.0f ) continue ; diff [ 1 ] = 0 ; const float distSqr = dtVlenSqr ( diff ) ; if ( distSqr > dtSqr ( range ) ) continue ; n = addNeighbour ( ids [ i ] , distSqr , result , n , maxResult ) ; } return n ; } void CrowdManager :: updateMoveRequest ( const float dt , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { for ( int i = 0 ; i < m_moveRequestCount ; ++ i ) { MoveRequest * req = & m_moveRequests [ i ] ; Agent * ag = & m_agents [ req -> idx ] ; if ( ! ag -> active ) req -> state = MR_TARGET_FAILED ; if ( req -> aref ) { if ( req -> state == MR_TARGET_ADJUST ) { ag -> corridor . moveTargetPosition ( req -> apos , navquery , filter ) ; req -> state = MR_TARGET_VALID ; } else { float result [ 3 ] ; static const int MAX_VISITED = 16 ; dtPolyRef visited [ MAX_VISITED ] ; int nvisited = 0 ; navquery -> moveAlongSurface ( req -> temp [ req -> ntemp - 1 ] , req -> pos , req -> apos , filter , result , visited , & nvisited , MAX_VISITED ) ; req -> ntemp = fixupCorridorEnd ( req -> temp , req -> ntemp , MAX_TEMP_@@ PATH , visited , nvisited ) ; dtVcopy ( req -> pos , result ) ; dtVset ( req -> apos , 0 , 0 , 0 ) ; req -> aref = 0 ; } } if ( req -> state == MR_TARGET_REQUESTING ) { const dtPolyRef * path = ag -> corridor . getPath ( ) ; const int npath = ag -> corridor . getPathCount ( ) ; dtAssert ( npath ) ; float reqPos [ 3 ] ; dtVcopy ( reqPos , ag -> corridor . getPos ( ) ) ; dtPolyRef reqPath [ 8 ] ; reqPath [ 0 ] = path [ 0 ] ; int reqPathCount = 1 ; req -> pathqRef = m_pathq . request ( reqPath [ reqPathCount - 1 ] , req -> ref , reqPos , req -> pos , & m_filter ) ; if ( req -> pathqRef != PATHQ_INVALID ) { ag -> corridor . setCorridor ( reqPos , reqPath , reqPathCount ) ; req -> state = MR_TARGET_WAITING_FOR_PATH ; } } } m_pathq . update ( navquery ) ; for ( int i = 0 ; i < m_moveRequestCount ; ++ i ) { MoveRequest * req = & m_moveRequests [ i ] ; Agent * ag = & m_agents [ req -> idx ] ; if ( req -> state == MR_TARGET_WAITING_FOR_PATH ) { int state = m_pathq . getRequestState ( req -> pathqRef ) ; if ( state == PATHQ_STATE_INVALID ) { req -> pathqRef = PATHQ_INVALID ; req -> state = MR_TARGET_FAILED ; } else if ( state == PATHQ_STATE_READY ) { const dtPolyRef * path = ag -> corridor . getPath ( ) ; const int npath = ag -> corridor . getPathCount ( ) ; dtAssert ( npath ) ; float targetPos [ 3 ] ; dtVcopy ( targetPos , req -> pos ) ; dtPolyRef * res = m_pathResult ; bool valid = true ; int nres = m_pathq . getPathResult ( req -> pathqRef , res , m_maxPathResult ) ; if ( ! nres ) valid = false ; if ( req -> ntemp > 1 ) { nres = fixupCorridorEnd ( res , nres , m_maxPathResult , req -> temp , req -> ntemp ) ; } if ( valid && path [ npath - 1 ] != res [ 0 ] ) valid = false ; if ( valid ) { if ( npath > 1 ) { if ( ( npath - 1 ) + nres > m_maxPathResult ) nres = m_maxPathResult - ( npath - 1 ) ; memmove ( res + npath - 1 , res , sizeof ( dtPolyRef ) * nres ) ; memcpy ( res , path , sizeof ( dtPolyRef ) * ( npath - 1 ) ) ; nres += npath - 1 ; } if ( res [ nres - 1 ] != req -> ref ) { float nearest [ 3 ] ; if ( navquery -> closestPoint@@ OnPoly ( res [ nres - 1 ] , targetPos , nearest ) == DT_SUCCESS ) dtVcopy ( targetPos , nearest ) ; else valid = false ; } } if ( valid ) { ag -> corridor . setCorridor ( targetPos , res , nres ) ; req -> state = MR_TARGET_VALID ; } else { req -> state = MR_TARGET_FAILED ; } } } if ( req -> state == MR_TARGET_VALID || req -> state == MR_TARGET_FAILED ) { m_moveRequestCount -- ; if ( i != m_moveRequestCount ) memcpy ( & m_moveRequests [ i ] , & m_moveRequests [ m_moveRequestCount ] , sizeof ( MoveRequest ) ) ; -- i ; } } } static int addToOptQueue ( Agent * newag , Agent * * agents , const int nagents , const int maxAgents ) { int slot = 0 ; if ( ! nagents ) { slot = nagents ; } else if ( newag -> topologyOptTime <= agents [ nagents - 1 ] -> topologyOptTime ) { if ( nagents >= maxAgents ) return nagents ; slot = nagents ; } else { int i ; for ( i = 0 ; i < nagents ; ++ i ) if ( newag -> topologyOptTime >= agents [ i ] -> topologyOptTime ) break ; const int tgt = i + 1 ; const int n = dtMin ( nagents - i , maxAgents - tgt ) ; dtAssert ( tgt + n <= maxAgents ) ; if ( n > 0 ) memmove ( & agents [ tgt ] , & agents [ i ] , sizeof ( Agent * ) * n ) ; slot = i ; } agents [ slot ] = newag ; return dtMin ( nagents + 1 , maxAgents ) ; } void CrowdManager :: updateTopologyOptimization ( const float dt , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { Agent * agents [ MAX_AGENTS ] ; int nagents = getActiveAgents ( agents , MAX_AGENTS ) ; if ( ! nagents ) return ; const float OPT_TIME_THR = 0.5f ; const int OPT_MAX_AGENTS = 1 ; Agent * queue [ OPT_MAX_AGENTS ] ; int nqueue = 0 ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; ag -> topologyOptTime += dt ; if ( ag -> topologyOptTime >= OPT_TIME_THR ) { nqueue = addToOptQueue ( ag , queue , nqueue , OPT_MAX_AGENTS ) ; } } for ( int i = 0 ; i < nqueue ; ++ i ) { Agent * ag = queue [ i ] ; ag -> corridor . optimizePathTopology ( navquery , filter ) ; ag -> topologyOptTime = 0 ; } } void CrowdManager :: update ( const float dt , unsigned int flags , dtNavMeshQuery * navquery ) { m_sampleCount = 0 ; m_totalTime = 0 ; m_rvoTime = 0 ; if ( ! navquery ) return ; TimeVal startTime = getPerfTime ( ) ; Agent * agents [ MAX_AGENTS ] ; int nagents = getActiveAgents ( agents , MAX_AGENTS ) ; static const float MAX_ACC = 8.0f ; static const float MAX_SPEED = 3.5f ; updateMoveRequest ( dt , navquery , & m_filter ) ; if ( flags & CROWDMAN_OPTIMIZE_TOPO ) updateTopologyOptimization ( dt , navquery , & m_filter ) ; m_grid . clear ( ) ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; const float * p = ag -> npos ; const float r = ag -> radius ; m_grid . addItem ( ( unsigned short ) i , p [ 0 ] - r , p [ 2 ] - r , p [ 0 ] + r , p [ 2 ] + r ) ; } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; if ( dtVdist2DSqr ( ag -> npos , ag -> boundary . getCenter ( ) ) > dtSqr ( ag -> collisionQueryRange * 0.25f ) ) ag -> boundary . update ( ag -> corridor . getFirstPoly ( ) , ag -> npos , ag -> collisionQueryRange , navquery , & m_filter ) ; ag -> nneis = getNeighbours ( ag -> npos , ag -> height , ag -> collisionQueryRange , ag , ag -> neis , AGENT_MAX_NEIGH@@ BOURS ) ; } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; ag -> ncorners = ag -> corridor . findCorners ( ag -> cornerVerts , ag -> cornerFlags , ag -> cornerPolys , AGENT_MAX_COR@@ NERS , navquery , & m_filter ) ; if ( ( flags & CROWDMAN_OPTIMIZE_VIS ) && ag -> ncorners > 0 ) { const float * target = & ag -> cornerVerts [ dtMin ( 1 , ag -> ncorners - 1 ) * 3 ] ; dtVcopy ( ag -> opts , ag -> corridor . getPos ( ) ) ; dtVcopy ( ag -> opte , target ) ; ag -> corridor . optimizePathVisibility ( target , ag -> pathOptimizationRange , navquery , & m_filter ) ; } else { dtVset ( ag -> opts , 0 , 0 , 0 ) ; dtVset ( ag -> opte , 0 , 0 , 0 ) ; } } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; float dvel [ 3 ] = { 0 , 0 , 0 } ; if ( flags & CROWDMAN_AN@@ TICI@@ PATE_TURNS ) ag -> calcSmoothSteerDirection ( dvel ) ; else ag -> calcStraightSteerDirection ( dvel ) ; const float slowDownRadius = ag -> radius * 2 ; const float speedScale = ag -> getDistanceToGoal ( slowDownRadius ) / slowDownRadius ; if ( flags & CROWDMAN_DRUNK ) { ag -> t += dt * ( 1.0f - ag -> var * 0.25f ) ; ag -> maxspeed = MAX_SPEED * ( 1 + dtSqr ( cosf ( ag -> t * 2.0f ) ) * 0.3f ) ; dtVscale ( dvel , dvel , ag -> maxspeed * speedScale ) ; const float amp = cosf ( ag -> var * 13.69f + ag -> t * 3.123f ) * 0.2f ; const float nx = - dvel [ 2 ] ; const float nz = dvel [ 0 ] ; dvel [ 0 ] += nx * amp ; dvel [ 2 ] += nz * amp ; } else { ag -> maxspeed = MAX_SPEED ; dtVscale ( dvel , dvel , ag -> maxspeed * speedScale ) ; } dtVcopy ( ag -> dvel , dvel ) ; } TimeVal rvoStartTime = getPerfTime ( ) ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; if ( flags & CROWDMAN_USE_VO ) { m_obstacleQuery -> reset ( ) ; for ( int j = 0 ; j < ag -> nneis ; ++ j ) { const Agent * nei = & m_agents [ ag -> neis [ j ] . idx ] ; m_obstacleQuery -> addCircle ( nei -> npos , nei -> radius , nei -> vel , nei -> dvel ) ; } for ( int j = 0 ; j < ag -> boundary . getSegmentCount ( ) ; ++ j ) { const float * s = ag -> boundary . getSegment ( j ) ; if ( dtTri@@ Area2D ( ag -> npos , s , s + 3 ) < 0.0f ) continue ; m_obstacleQuery -> addSegment ( s , s + 3 ) ; } bool adaptive = true ; if ( adaptive ) { m_obstacleQuery -> sampleVelocity@@ Adaptive ( ag -> npos , ag -> radius , ag -> maxspeed , ag -> vel , ag -> dvel , ag -> nvel , VO_ADAPTIVE_DIVS , VO_ADAPTIVE_RINGS , VO_ADAPTIVE_DEPTH , m_vodebug [ i ] ) ; } else { m_obstacleQuery -> sampleVeloc@@ ityGrid ( ag -> npos , ag -> radius , ag -> maxspeed , ag -> vel , ag -> dvel , ag -> nvel , VO_GRID_SIZE , m_vodebug [ i ] ) ; } } else { dtVcopy ( ag -> nvel , ag -> dvel ) ; } } TimeVal rvoEndTime = getPerfTime ( ) ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; ag -> integrate ( MAX_ACC , dt ) ; } for ( int iter = 0 ; iter < 4 ; ++ iter ) { for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; dtVset ( ag -> disp , 0 , 0 , 0 ) ; float w = 0 ; for ( int j = 0 ; j < ag -> nneis ; ++ j ) { const Agent * nei = & m_agents [ ag -> neis [ j ] . idx ] ; float diff [ 3 ] ; dtVsub ( diff , ag -> npos , nei -> npos ) ; if ( fabsf ( diff [ 1 ] ) >= ( ag -> height + nei -> height ) / 2.0f ) continue ; diff [ 1 ] = 0 ; float dist = dtVlenSqr ( diff ) ; if ( dist > dtSqr ( ag -> radius + nei -> radius ) ) continue ; dist = sqrtf ( dist ) ; float pen = ( ag -> radius + nei -> radius ) - dist ; if ( dist > 0.0001f ) pen = ( 1.0f / dist ) * ( pen * 0.5f ) * 0.7f ; dtVmad ( ag -> disp , ag -> disp , diff , pen ) ; w += 1.0f ; } if ( w > 0.0001f ) { const float iw = 1.0f / w ; dtVscale ( ag -> disp , ag -> disp , iw ) ; } } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; dtVadd ( ag -> npos , ag -> npos , ag -> disp ) ; } } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; ag -> corridor . movePosition ( ag -> npos , navquery , & m_filter ) ; dtVcopy ( ag -> npos , ag -> corridor . getPos ( ) ) ; } TimeVal endTime = getPerfTime ( ) ; int ns = 0 ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; if ( flags & CROWDMAN_USE_VO ) { m_vodebug [ i ] -> normalizeSamples ( ) ; ns += m_vodebug [ i ] -> getSampleCount ( ) ; } ag -> htrail = ( ag -> htrail + 1 ) % AGENT_MAX_TRAIL ; dtVcopy ( & ag -> trail [ ag -> htrail * 3 ] , ag -> npos ) ; } m_sampleCount = ns ; m_rvoTime = getPerfDeltaTimeUsec ( rvoStartTime , rvoEndTime ) ; m_totalTime = getPerfDeltaTimeUsec ( startTime , endTime ) ; } </DOCUMENT>
<DOCUMENT_ID="einon/@@ affymetrix-power@@ -tools/tree/master/sdk/@@ calvin_@@ files/parameter/test/@@ ParameterFileDataTest.cpp"> # include " calvin _ files / parameter / src / ParameterFileData . h " # include < cppunit / extensions / HelperMacros . h > using namespace affymetrix_calvin_@@ parameter ; class ParameterFileDataTest : public CPPUNIT_NS :: TestFixture { CPPUNIT_TEST_SUITE ( ParameterFileDataTest ) ; CPPUNIT_TEST ( testAccess ) ; CPPUNIT_TEST_SUITE_END ( ) ; public : void setUp ( ) ; void tearDown ( ) ; void testAccess ( ) ; } ; CPPUNIT_TEST_SUITE_REGISTRATION ( ParameterFileDataTest ) ; void ParameterFileDataTest :: setUp ( ) { } void ParameterFileDataTest :: tearDown ( ) { } void ParameterFileDataTest :: testAccess ( ) { ParameterFileData d ; d . ImplementationAttributes ( ) . description = L " d " ; d . ImplementationAttributes ( ) . executableFileName = L " e " ; d . ImplementationAttributes ( ) . name = L " n " ; d . ImplementationAttributes ( ) . version = L " v " ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . description == L " d " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . executableFileName == L " e " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . name == L " n " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . version == L " v " ) ; d . ParameterFileAttributes ( ) . company = L " c " ; d . ParameterFileAttributes ( ) . userName = L " u " ; d . ParameterFileAttributes ( ) . contentVersion = L " cv " ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . company == L " c " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . userName == L " u " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . contentVersion == L " cv " ) ; ParameterType p ; p . name = L " n " ; p . index = L " i " ; p . displayName = L " d " ; p . category = L " c " ; p . isEditable = L " is " ; p . type = L " t " ; p . currentValue = L " cv " ; p . minValue = L " mv " ; p . maxValue = L " xv " ; p . defaultValue = L " dv " ; p . precision = L " p " ; p . maxLength = L " l " ; p . description = L " de " ; CPPUNIT_ASSERT ( p . name == L " n " ) ; CPPUNIT_ASSERT ( p . index == L " i " ) ; CPPUNIT_ASSERT ( p . displayName == L " d " ) ; CPPUNIT_ASSERT ( p . category == L " c " ) ; CPPUNIT_ASSERT ( p . isEditable == L " is " ) ; CPPUNIT_ASSERT ( p . type == L " t " ) ; CPPUNIT_ASSERT ( p . currentValue == L " cv " ) ; CPPUNIT_ASSERT ( p . minValue == L " mv " ) ; CPPUNIT_ASSERT ( p . maxValue == L " xv " ) ; CPPUNIT_ASSERT ( p . defaultValue == L " dv " ) ; CPPUNIT_ASSERT ( p . precision == L " p " ) ; CPPUNIT_ASSERT ( p . maxLength == L " l " ) ; CPPUNIT_ASSERT ( p . description == L " de " ) ; d . Parameters ( ) . push_back ( p ) ; p . name . clear ( ) ; p . index . clear ( ) ; CPPUNIT_ASSERT ( d . Parameters ( ) . size ( ) == 1 ) ; d . Clear ( ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . description == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . executableFileName == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . name == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . version == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . company == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . userName == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . contentVersion == L " " ) ; CPPUNIT_ASSERT ( d . Parameters ( ) . size ( ) == 0 ) ; } </DOCUMENT>
<DOCUMENT_ID="Morco@@ FreeCode/@@ 2015__MorcoEngine@@ 3D/tree/master/MorcoEngine@@ 3D v0.13/Source/@@ Libraries/glm/@@ Include/detail/glm.cpp"> # include < glm / glm . hpp > # include < glm / gtc / quaternion . hpp > # include < glm / gtx / dual_quaternion . hpp > namespace glm { namespace detail { template struct tvec2 < uint8 , lowp > ; template struct tvec2 < uint16 , lowp > ; template struct tvec2 < uint32 , lowp > ; template struct tvec2 < uint64 , lowp > ; template struct tvec2 < int8 , lowp > ; template struct tvec2 < int16 , lowp > ; template struct tvec2 < int32 , lowp > ; template struct tvec2 < int64 , lowp > ; template struct tvec2 < float32 , lowp > ; template struct tvec2 < float64 , lowp > ; template struct tvec2 < uint8 , mediump > ; template struct tvec2 < uint16 , mediump > ; template struct tvec2 < uint32 , mediump > ; template struct tvec2 < uint64 , mediump > ; template struct tvec2 < int8 , mediump > ; template struct tvec2 < int16 , mediump > ; template struct tvec2 < int32 , mediump > ; template struct tvec2 < int64 , mediump > ; template struct tvec2 < float32 , mediump > ; template struct tvec2 < float64 , mediump > ; template struct tvec2 < uint8 , highp > ; template struct tvec2 < uint16 , highp > ; template struct tvec2 < uint32 , highp > ; template struct tvec2 < uint64 , highp > ; template struct tvec2 < int8 , highp > ; template struct tvec2 < int16 , highp > ; template struct tvec2 < int32 , highp > ; template struct tvec2 < int64 , highp > ; template struct tvec2 < float32 , highp > ; template struct tvec2 < float64 , highp > ; template struct tvec3 < uint8 , lowp > ; template struct tvec3 < uint16 , lowp > ; template struct tvec3 < uint32 , lowp > ; template struct tvec3 < uint64 , lowp > ; template struct tvec3 < int8 , lowp > ; template struct tvec3 < int16 , lowp > ; template struct tvec3 < int32 , lowp > ; template struct tvec3 < int64 , lowp > ; template struct tvec3 < float32 , lowp > ; template struct tvec3 < float64 , lowp > ; template struct tvec3 < uint8 , mediump > ; template struct tvec3 < uint16 , mediump > ; template struct tvec3 < uint32 , mediump > ; template struct tvec3 < uint64 , mediump > ; template struct tvec3 < int8 , mediump > ; template struct tvec3 < int16 , mediump > ; template struct tvec3 < int32 , mediump > ; template struct tvec3 < int64 , mediump > ; template struct tvec3 < float32 , mediump > ; template struct tvec3 < float64 , mediump > ; template struct tvec3 < uint8 , highp > ; template struct tvec3 < uint16 , highp > ; template struct tvec3 < uint32 , highp > ; template struct tvec3 < uint64 , highp > ; template struct tvec3 < int8 , highp > ; template struct tvec3 < int16 , highp > ; template struct tvec3 < int32 , highp > ; template struct tvec3 < int64 , highp > ; template struct tvec3 < float32 , highp > ; template struct tvec3 < float64 , highp > ; template struct tvec4 < uint8 , lowp > ; template struct tvec4 < uint16 , lowp > ; template struct tvec4 < uint32 , lowp > ; template struct tvec4 < uint64 , lowp > ; template struct tvec4 < int8 , lowp > ; template struct tvec4 < int16 , lowp > ; template struct tvec4 < int32 , lowp > ; template struct tvec4 < int64 , lowp > ; template struct tvec4 < float32 , lowp > ; template struct tvec4 < float64 , lowp > ; template struct tvec4 < uint8 , mediump > ; template struct tvec4 < uint16 , mediump > ; template struct tvec4 < uint32 , mediump > ; template struct tvec4 < uint64 , mediump > ; template struct tvec4 < int8 , mediump > ; template struct tvec4 < int16 , mediump > ; template struct tvec4 < int32 , mediump > ; template struct tvec4 < int64 , mediump > ; template struct tvec4 < float32 , mediump > ; template struct tvec4 < float64 , mediump > ; template struct tvec4 < uint8 , highp > ; template struct tvec4 < uint16 , highp > ; template struct tvec4 < uint32 , highp > ; template struct tvec4 < uint64 , highp > ; template struct tvec4 < int8 , highp > ; template struct tvec4 < int16 , highp > ; template struct tvec4 < int32 , highp > ; template struct tvec4 < int64 , highp > ; template struct tvec4 < float32 , highp > ; template struct tvec4 < float64 , highp > ; template struct tmat2x2 < float32 , lowp > ; template struct tmat2x2 < float64 , lowp > ; template struct tmat2x2 < float32 , mediump > ; template struct tmat2x2 < float64 , mediump > ; template struct tmat2x2 < float32 , highp > ; template struct tmat2x2 < float64 , highp > ; template struct tmat2x3 < float32 , lowp > ; template struct tmat2x3 < float64 , lowp > ; template struct tmat2x3 < float32 , mediump > ; template struct tmat2x3 < float64 , mediump > ; template struct tmat2x3 < float32 , highp > ; template struct tmat2x3 < float64 , highp > ; template struct tmat2x4 < float32 , lowp > ; template struct tmat2x4 < float64 , lowp > ; template struct tmat2x4 < float32 , mediump > ; template struct tmat2x4 < float64 , mediump > ; template struct tmat2x4 < float32 , highp > ; template struct tmat2x4 < float64 , highp > ; template struct tmat3x2 < float32 , lowp > ; template struct tmat3x2 < float64 , lowp > ; template struct tmat3x2 < float32 , mediump > ; template struct tmat3x2 < float64 , mediump > ; template struct tmat3x2 < float32 , highp > ; template struct tmat3x2 < float64 , highp > ; template struct tmat3x3 < float32 , lowp > ; template struct tmat3x3 < float64 , lowp > ; template struct tmat3x3 < float32 , mediump > ; template struct tmat3x3 < float64 , mediump > ; template struct tmat3x3 < float32 , highp > ; template struct tmat3x3 < float64 , highp > ; template struct tmat3x4 < float32 , lowp > ; template struct tmat3x4 < float64 , lowp > ; template struct tmat3x4 < float32 , mediump > ; template struct tmat3x4 < float64 , mediump > ; template struct tmat3x4 < float32 , highp > ; template struct tmat3x4 < float64 , highp > ; template struct tmat4x2 < float32 , lowp > ; template struct tmat4x2 < float64 , lowp > ; template struct tmat4x2 < float32 , mediump > ; template struct tmat4x2 < float64 , mediump > ; template struct tmat4x2 < float32 , highp > ; template struct tmat4x2 < float64 , highp > ; template struct tmat4x3 < float32 , lowp > ; template struct tmat4x3 < float64 , lowp > ; template struct tmat4x3 < float32 , mediump > ; template struct tmat4x3 < float64 , mediump > ; template struct tmat4x3 < float32 , highp > ; template struct tmat4x3 < float64 , highp > ; template struct tmat4x4 < float32 , lowp > ; template struct tmat4x4 < float64 , lowp > ; template struct tmat4x4 < float32 , mediump > ; template struct tmat4x4 < float64 , mediump > ; template struct tmat4x4 < float32 , highp > ; template struct tmat4x4 < float64 , highp > ; template struct tquat < float32 , lowp > ; template struct tquat < float64 , lowp > ; template struct tquat < float32 , mediump > ; template struct tquat < float64 , mediump > ; template struct tquat < float32 , highp > ; template struct tquat < float64 , highp > ; template struct tdualquat < float32 , lowp > ; template struct tdualquat < float64 , lowp > ; template struct tdualquat < float32 , mediump > ; template struct tdualquat < float64 , mediump > ; template struct tdualquat < float32 , highp > ; template struct tdualquat < float64 , highp > ; } } </DOCUMENT>
<DOCUMENT_ID="fstudi@@ o/Phoen@@ ix/tree/master/test/@@ Experimental/libcxx/test/@@ std/string@@ s/char.traits/char.traits.specialization@@ s/char.traits.specializations.char16_t@@ /eof.pass.cpp"> # include < string > # include < cassert > int main ( ) { # ifndef _LIBCPP_HAS_NO_UNICODE_@@ CHARS std :: char_traits < char16_t > :: int_type i = std :: char_traits < char16_t > :: eof ( ) ; # endif } </DOCUMENT>
<DOCUMENT_ID="Code@@ DJ/qt5-hid@@ pi/tree/master/qt@@ /qtdeclar@@ ative/src/@@ quick/util/@@ qquickanimatorcontroller.cpp"> # include " qquickanimatorcontroller _ p . h " # include < private / qquickwindow_p . h > # include < private / qsgrenderloop_p . h > # include < private / qanimationgroupjob@@ _p . h > # include < QtGui / qscreen . h > # include < QtCore / qcoreapp@@ lication . h > QT_BEGIN_NAMESPACE QQuickAnimatorController :: QQuickAnimatorController ( ) : m_window ( 0 ) { } QQuickAnimatorController :: ~ QQuickAnimatorController ( ) { foreach ( QAbstractAnimationJob * job , m_deleting ) { m_starting . take ( job ) ; m_stopping . take ( job ) ; m_animatorRoots . take ( job ) ; delete job ; } foreach ( QQuickAnimatorProxyJob * proxy , m_animatorRoots ) proxy -> controllerWasDeleted ( ) ; qDeleteAll ( m_animatorRoots . keys ( ) ) ; foreach ( QAbstractAnimationJob * job , m_starting . keys ( ) ) { if ( ! m_animatorRoots . contains ( job ) ) delete job ; } } void QQuickAnimatorController :: itemDestroyed ( QObject * o ) { m_deletedSinceLastFrame << ( QQuickItem * ) o ; } void QQuickAnimatorController :: advance ( ) { bool running = false ; for ( QHash < QAbstractAnimationJob * , QQuickAnimatorProxyJob * > :: const_iterator it = m_animatorRoots . constBegin ( ) ; ! running && it != m_animatorRoots . constEnd ( ) ; ++ it ) { if ( it . key ( ) -> isRunning ( ) ) running = true ; } lock ( ) ; for ( QHash < QQuickItem * , QQuickTransformAnimatorJob :: Helper * > :: const_iterator it = m_transforms . constBegin ( ) ; it != m_transforms . constEnd ( ) ; ++ it ) { QQuickTransformAnimatorJob :: Helper * xform = * it ; if ( ! xform -> item ) continue ; ( * it ) -> apply ( ) ; } unlock ( ) ; if ( running ) m_window -> update ( ) ; } static void qquick_initialize_helper ( QAbstractAnimationJob * job , QQuickAnimatorController * c ) { if ( job -> isRenderThreadJob ( ) ) { QQuickAnimatorJob * j = static_cast < QQuickAnimatorJob * > ( job ) ; if ( ! j -> target ( ) ) { return ; } else if ( c -> m_deletedSinceLastFrame . contains ( j -> target ( ) ) ) { j -> targetWasDeleted ( ) ; } else { j -> addAnimationChangeListener ( c , QAbstractAnimationJob :: StateChange ) ; j -> initialize ( c ) ; } } else if ( job -> isGroup ( ) ) { QAnimationGroupJob * g = static_cast < QAnimationGroupJob * > ( job ) ; for ( QAbstractAnimationJob * a = g -> firstChild ( ) ; a ; a = a -> nextSibling ( ) ) qquick_initialize_helper ( a , c ) ; } } void QQuickAnimatorController :: beforeNodeSync ( ) { foreach ( QAbstractAnimationJob * job , m_deleting ) { m_starting . take ( job ) ; m_stopping . take ( job ) ; m_animatorRoots . take ( job ) ; job -> stop ( ) ; delete job ; } m_deleting . clear ( ) ; if ( m_starting . size ( ) ) m_window -> update ( ) ; foreach ( QQuickAnimatorProxyJob * proxy , m_starting ) { QAbstractAnimationJob * job = proxy -> job ( ) ; job -> addAnimationChangeListener ( this , QAbstractAnimationJob :: Completion ) ; qquick_initialize_helper ( job , this ) ; m_animatorRoots [ job ] = proxy ; job -> start ( ) ; proxy -> startedBy@@ Controller ( ) ; } m_starting . clear ( ) ; foreach ( QQuickAnimatorProxyJob * proxy , m_stopping ) { QAbstractAnimationJob * job = proxy -> job ( ) ; job -> stop ( ) ; } m_stopping . clear ( ) ; foreach ( QQuickAnimatorJob * job , m_activeLeafAnimations ) { if ( ! job -> target ( ) ) continue ; else if ( m_deletedSinceLastFrame . contains ( job -> target ( ) ) ) job -> targetWasDeleted ( ) ; else if ( job -> isTransform ( ) ) { QQuickTransformAnimatorJob * xform = static_cast < QQuickTransformAnimatorJob * > ( job ) ; xform -> transformHelper ( ) -> sync ( ) ; } } foreach ( QQuickItem * wiped , m_deletedSinceLastFrame ) { QQuickTransformAnimatorJob :: Helper * helper = m_transforms . value ( wiped ) ; if ( helper ) helper -> item = 0 ; } m_deletedSinceLastFrame . clear ( ) ; } void QQuickAnimatorController :: afterNodeSync ( ) { foreach ( QQuickAnimatorJob * job , m_activeLeafAnimations ) { if ( job -> isUniform ( ) && job -> target ( ) ) static_cast < QQuickUniform@@ AnimatorJob * > ( job ) -> afterNodeSync ( ) ; } } void QQuickAnimatorController :: animationFinished ( QAbstractAnimationJob * job ) { if ( ! m_deleting . contains ( job ) ) { QQuickAnimatorProxyJob * proxy = m_animatorRoots [ job ] ; if ( proxy ) QCoreApplication :: postEvent ( proxy , new QEvent ( QEvent :: User ) ) ; } } void QQuickAnimatorController :: animationStateChanged ( QAbstractAnimationJob * job , QAbstractAnimationJob :: State newState , QAbstractAnimationJob :: State oldState ) { Q_ASSERT ( job -> isRenderThreadJob ( ) ) ; QQuickAnimatorJob * animator = static_cast < QQuickAnimatorJob * > ( job ) ; if ( newState == QAbstractAnimationJob :: Running ) { m_activeLeafAnimations << animator ; animator -> setHasBeen@@ Running ( true ) ; } else if ( oldState == QAbstractAnimationJob :: Running ) { m_activeLeafAnimations . remove ( animator ) ; } } void QQuickAnimatorController :: requestSync ( ) { m_window -> maybeUpdate ( ) ; } void QQuickAnimatorController :: startJob ( QQuickAnimatorProxyJob * proxy , QAbstractAnimationJob * job ) { m_starting [ job ] = proxy ; requestSync ( ) ; } void QQuickAnimatorController :: stopJob ( QQuickAnimatorProxyJob * proxy , QAbstractAnimationJob * job ) { m_stopping [ job ] = proxy ; requestSync ( ) ; } void QQuickAnimatorController :: deleteJob ( QAbstractAnimationJob * job ) { lock ( ) ; m_deleting << job ; requestSync ( ) ; unlock ( ) ; } QT_END_NAMESPACE </DOCUMENT>
<DOCUMENT_ID="bredel@@ ings/BAli@@ -Phy/tree/master/external/range-@@ v3/0.@@ 4.0/test/algorithm/@@ minmax.cpp"> # include < range / v3 / algorithm / minmax . hpp > # include < memory > # include < numeric > # include < random > # include < algorithm > # include " . . / simple _ test . hpp " # include " . . / test _ utils . hpp " # include " . . / test _ iterators . hpp " RANGES_DIAG@@ NOSTI@@ C_IGNORE_@@ GLOBAL_CONSTRUCTORS namespace { std :: mt19937 gen ; template < class Iter , class Sent = Iter > void test_iter ( Iter first , Sent last ) { RANGES_ENSURE ( first != last ) ; auto rng = ranges :: make_iterator_range ( first , last ) ; auto res = ranges :: minmax ( rng ) ; for ( Iter i = first ; i != last ; ++ i ) { CHECK ( ! ( * i < res . first ) ) ; CHECK ( ! ( res . second < * i ) ) ; } } template < class Iter , class Sent = Iter > void test_iter ( unsigned N ) { RANGES_ENSURE ( N > 0 ) ; std :: unique_ptr < int [ ] > a { new int [ N ] } ; std :: iota ( a . get ( ) , a . get ( ) + N , 0 ) ; std :: shuffle ( a . get ( ) , a . get ( ) + N , gen ) ; test_iter ( Iter ( a . get ( ) ) , Sent ( a . get ( ) + N ) ) ; } template < class Iter , class Sent = Iter > void test_iter ( ) { test_iter < Iter , Sent > ( 1 ) ; test_iter < Iter , Sent > ( 2 ) ; test_iter < Iter , Sent > ( 3 ) ; test_iter < Iter , Sent > ( 10 ) ; test_iter < Iter , Sent > ( 1000 ) ; } template < class Iter , class Sent = Iter > void test_iter_comp ( Iter first , Sent last ) { RANGES_ENSURE ( first != last ) ; typedef std :: greater < int > Compare ; Compare comp ; auto rng = ranges :: make_iterator_range ( first , last ) ; auto res = ranges :: minmax ( rng , comp ) ; for ( Iter i = first ; i != last ; ++ i ) { CHECK ( ! comp ( * i , res . first ) ) ; CHECK ( ! comp ( res . second , * i ) ) ; } } template < class Iter , class Sent = Iter > void test_iter_comp ( unsigned N ) { RANGES_ENSURE ( N > 0 ) ; std :: unique_ptr < int [ ] > a { new int [ N ] } ; std :: iota ( a . get ( ) , a . get ( ) + N , 0 ) ; std :: shuffle ( a . get ( ) , a . get ( ) + N , gen ) ; test_iter_comp ( Iter ( a . get ( ) ) , Sent ( a . get ( ) + N ) ) ; } template < class Iter , class Sent = Iter > void test_iter_comp ( ) { test_iter_comp < Iter , Sent > ( 1 ) ; test_iter_comp < Iter , Sent > ( 2 ) ; test_iter_comp < Iter , Sent > ( 3 ) ; test_iter_comp < Iter , Sent > ( 10 ) ; test_iter_comp < Iter , Sent > ( 1000 ) ; } struct S { int value ; int index ; } ; } int main ( ) { test_iter < input_iterator < const int * > > ( ) ; test_iter < forward_iterator < const int * > > ( ) ; test_iter < bidirectional_iterator < const int * > > ( ) ; test_iter < random_access_iterator < const int * > > ( ) ; test_iter < const int * > ( ) ; test_iter < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < input_iterator < const int * > > ( ) ; test_iter < forward_iterator < const int * > > ( ) ; test_iter < bidirectional_iterator < const int * > > ( ) ; test_iter < random_access_iterator < const int * > > ( ) ; test_iter < const int * > ( ) ; test_iter < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < input_iterator < const int * > > ( ) ; test_iter_comp < forward_iterator < const int * > > ( ) ; test_iter_comp < bidirectional_iterator < const int * > > ( ) ; test_iter_comp < random_access_iterator < const int * > > ( ) ; test_iter_comp < const int * > ( ) ; test_iter_comp < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < input_iterator < const int * > > ( ) ; test_iter_comp < forward_iterator < const int * > > ( ) ; test_iter_comp < bidirectional_iterator < const int * > > ( ) ; test_iter_comp < random_access_iterator < const int * > > ( ) ; test_iter_comp < const int * > ( ) ; test_iter_comp < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; S s [ ] = { S { 1 , 0 } , S { 2 , 1 } , S { 3 , 2 } , S { 4 , 3 } , S { - 4 , 4 } , S { 40 , 5 } , S { - 4 , 6 } , S { 40 , 7 } , S { 7 , 8 } , S { 8 , 9 } , S { 9 , 10 } } ; auto res = ranges :: minmax ( s , std :: less < int > { } , & S :: value ) ; CHECK ( res . first . value == - 4 ) ; CHECK ( res . first . index == 4 ) ; CHECK ( res . second . value == 40 ) ; CHECK ( res . second . index == 7 ) ; return test_result ( ) ; } </DOCUMENT>
<DOCUMENT_ID="sam@@ dnic/Tar@@ antula/tree/master/@@ boost/libs/corout@@ ine/src/@@ detail/standard_stack_allocator_@@ posix.cpp"> # define BOOST_CO@@ ROUTINES_SOURCE # include " boost / coroutine / detail / standard _ stack _ allocator . hpp " extern " C " { # include < fcntl . h > # include < signal . h > # include < sys / mman . h > # include < sys / resource . h > # include < sys / stat . h > # include < sys / time . h > # include < sys / types . h > # include < unistd . h > } # include < algorithm > # include < cmath > # include < cstring > # include < stdexcept > # include < boost / assert . hpp > # include < boost / context / fcontext . hpp > # include < boost / coroutine / stack_context . hpp > # if ! defined ( SIGSTKSZ ) # define SIGSTKSZ ( 8 * 1024 ) # define UDEF_SIGSTKSZ # endif # ifdef BOOST_HAS_ABI_HEADERS # include BOOST_ABI_@@ PREFIX # endif namespace boost { namespace coroutines { namespace detail { std :: size_t pagesize ( ) { static std :: size_t size = :: sysconf ( _SC_PAGESIZE ) ; return size ; } rlimit stacksize_limit_ ( ) { rlimit limit ; # if defined ( BOOST_DISABLE_ASSERTS ) :: getrlimit ( RLIMIT_STACK , & limit ) ; # else const int result = :: getrlimit ( RLIMIT_STACK , & limit ) ; BOOST_ASSERT ( 0 == result ) ; # endif return limit ; } rlimit stacksize_limit ( ) { static rlimit limit = stacksize_limit_ ( ) ; return limit ; } std :: size_t page_count ( std :: size_t stacksize ) { return static_cast < std :: size_t > ( std :: ceil ( static_cast < float > ( stacksize ) / pagesize ( ) ) ) ; } bool standard_stack_allocator :: is_stack_unbound ( ) { return RLIM_INF@@ INITY == detail :: stacksize_limit ( ) . rlim_max ; } std :: size_t standard_stack_allocator :: default_stacksize ( ) { std :: size_t size = 8 * minimum_stacksize ( ) ; if ( is_stack_unbound ( ) ) return size ; BOOST_ASSERT ( maximum_stacksize ( ) >= minimum_stacksize ( ) ) ; return maximum_stacksize ( ) == size ? size : ( std :: min ) ( size , maximum_stacksize ( ) ) ; } std :: size_t standard_stack_allocator :: minimum_stacksize ( ) { return SIGSTKSZ + sizeof ( context :: fcontext_t ) + 15 ; } std :: size_t standard_stack_allocator :: maximum_stacksize ( ) { BOOST_ASSERT ( ! is_stack_unbound ( ) ) ; return static_cast < std :: size_t > ( detail :: stacksize_limit ( ) . rlim_max ) ; } void standard_stack_allocator :: allocate ( stack_context & ctx , std :: size_t size ) { BOOST_ASSERT ( minimum_stacksize ( ) <= size ) ; BOOST_ASSERT ( is_stack_unbound ( ) || ( maximum_stacksize ( ) >= size ) ) ; const std :: size_t pages ( detail :: page_count ( size ) + 1 ) ; const std :: size_t size_ ( pages * detail :: pagesize ( ) ) ; BOOST_ASSERT ( 0 < size && 0 < size_ ) ; const int fd ( :: open ( " / dev / zero " , O_RDO@@ NLY ) ) ; BOOST_ASSERT ( - 1 != fd ) ; void * limit = # if defined ( macintos@@ h ) || defined ( __APPLE__ ) || defined ( __APPLE_CC__ ) :: mmap ( 0 , size_ , PROT_READ | PROT_WRITE , MAP_PRIVATE | MAP_ANON , - 1 , 0 ) ; # else :: mmap ( 0 , size_ , PROT_READ | PROT_WRITE , MAP_PRIVATE , fd , 0 ) ; # endif :: close ( fd ) ; if ( ! limit ) throw std :: bad_alloc ( ) ; std :: memset ( limit , ' \0' , size_ ) ; # if defined ( BOOST_DISABLE_ASSERTS ) :: mprotect ( limit , detail :: pagesize ( ) , PROT_NONE ) ; # else const int result ( :: mprotect ( limit , detail :: pagesize ( ) , PROT_NONE ) ) ; BOOST_ASSERT ( 0 == result ) ; # endif ctx . size = size_ ; ctx . sp = static_cast < char * > ( limit ) + ctx . size ; } void standard_stack_allocator :: deallocate ( stack_context & ctx ) { BOOST_ASSERT ( ctx . sp ) ; BOOST_ASSERT ( minimum_stacksize ( ) <= ctx . size ) ; BOOST_ASSERT ( is_stack_unbound ( ) || ( maximum_stacksize ( ) >= ctx . size ) ) ; void * limit = static_cast < char * > ( ctx . sp ) - ctx . size ; :: munmap ( limit , ctx . size ) ; } } } } # ifdef BOOST_HAS_ABI_HEADERS # include BOOST_ABI@@ _SUFFIX # endif # ifdef UDEF_SIGSTKSZ # undef SIGSTKSZ # endif </DOCUMENT>
<DOCUMENT_ID="cryptomet@@ h/cryptomet@@ h_1/tree/master/src/crypto@@ pp/vmac.cpp"> # include " pch . h " # include " vmac . h " # include " argnames . h " # include " cpu . h " NAMESPACE_BEGIN ( CryptoPP ) # if defined ( _MSC_VER ) && ! CRYPTOPP_BOOL_SLOW_WORD64 # include < intrin . h > # endif # define VMAC_BOOL_WORD128 ( defined ( CRYPTOPP_WORD128_AVAILABLE ) && ! defined ( CRYPTOPP_X64_ASM_AVAILABLE ) ) # ifdef __BORLANDC__ # define const # endif static const word64 p64 = W64LIT ( 0xfffffffffffffeff ) ; static const word64 m62 = W64LIT ( 0x3fffffffffffffff ) ; static const word64 m63 = W64LIT ( 0x7fffffffffffffff ) ; static const word64 m64 = W64LIT ( 0xffffffffffffffff ) ; static const word64 mpoly = W64LIT ( 0x1fffffff1@@ fffffff ) ; # ifdef __BORLANDC__ # undef const # endif # if VMAC_BOOL_WORD128 # ifdef __power@@ pc__ # define m126 ( ( word128 ( m62 ) << 64 ) | m64 ) # else static const word128 m126 = ( word128 ( m62 ) << 64 ) | m64 ; # endif # endif void VMAC_Base :: UncheckedSetKey ( const byte * userKey , unsigned int keylength , const NameValuePair@@ s & params ) { int digestLength = params . GetIntValueWithDefault ( Name :: DigestSize ( ) , DefaultDigestSize ( ) ) ; if ( digestLength != 8 && digestLength != 16 ) throw InvalidArgument ( " VMAC : ▁ DigestSize ▁ must ▁ be ▁ 8 ▁ or ▁ 16" ) ; m_is128 = digestLength == 16 ; m_L1KeyLength = params . GetIntValueWithDefault ( Name :: L1KeyLength ( ) , 128 ) ; if ( m_L1KeyLength <= 0 || m_L1KeyLength % 128 != 0 ) throw InvalidArgument ( " VMAC : ▁ L1KeyLength ▁ must ▁ be ▁ a ▁ positive ▁ multiple ▁ of ▁ 128" ) ; AllocateBlocks ( ) ; BlockCipher & cipher = AccessCipher ( ) ; cipher . SetKey ( userKey , keylength , params ) ; unsigned int blockSize = cipher . BlockSize ( ) ; unsigned int blockSizeInWords = blockSize / sizeof ( word64 ) ; SecBlock < word64 > out ( blockSizeInWords ) ; SecByte@@ Block in ; in . CleanNew ( blockSize ) ; size_t i ; in [ 0 ] = 0x80 ; cipher . AdvancedProcessBlocks ( in , NULL , ( byte * ) m_nhKey ( ) , m_nhKeySize ( ) * sizeof ( word64 ) , cipher . BT_InBlock@@ IsCounter ) ; ConditionalByteReverse < word64 > ( BIG_ENDIAN_ORDER , m_nhKey ( ) , m_nhKey ( ) , m_nhKeySize ( ) * sizeof ( word64 ) ) ; in [ 0 ] = 0xC0 ; in [ 15 ] = 0 ; for ( i = 0 ; i <= ( size_t ) m_is128 ; i ++ ) { cipher . ProcessBlock ( in , out . BytePtr ( ) ) ; m_polyState ( ) [ i * 4 + 2 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) ) & mpoly ; m_polyState ( ) [ i * 4 + 3 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) + 8 ) & mpoly ; in [ 15 ] ++ ; } in [ 0 ] = 0xE0 ; in [ 15 ] = 0 ; word64 * l3Key = m_l3Key ( ) ; for ( i = 0 ; i <= ( size_t ) m_is128 ; i ++ ) do { cipher . ProcessBlock ( in , out . BytePtr ( ) ) ; l3Key [ i * 2 + 0 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) ) ; l3Key [ i * 2 + 1 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) + 8 ) ; in [ 15 ] ++ ; } while ( ( l3Key [ i * 2 + 0 ] >= p64 ) || ( l3Key [ i * 2 + 1 ] >= p64 ) ) ; m_padCached = false ; size_t nonceLength ; const byte * nonce = GetIVAndThrowIf@@ Invalid ( params , nonceLength ) ; Resynchronize ( nonce , ( int ) nonceLength ) ; } void VMAC_Base :: GetNextIV ( RandomNumberGenerator & rng , byte * IV ) { SimpleKeyingInterface :: GetNextIV ( rng , IV ) ; IV [ 0 ] &= 0x7f ; } void VMAC_Base :: Resynchronize ( const byte * nonce , int len ) { size_t length = ThrowIfInvalidIV@@ Length ( len ) ; size_t s = IVSize ( ) ; byte * storedNonce = m_nonce ( ) ; if ( m_is128 ) { memset ( storedNonce , 0 , s - length ) ; memcpy ( storedNonce + s - length , nonce , length ) ; AccessCipher ( ) . ProcessBlock ( storedNonce , m_pad ( ) ) ; } else { if ( m_padCached && ( storedNonce [ s - 1 ] | 1 ) == ( nonce [ length - 1 ] | 1 ) ) { m_padCached = VerifyBuf@@ sEqual ( storedNonce + s - length , nonce , length - 1 ) ; for ( size_t i = 0 ; m_padCached && i < s - length ; i ++ ) m_padCached = ( storedNonce [ i ] == 0 ) ; } if ( ! m_padCached ) { memset ( storedNonce , 0 , s - length ) ; memcpy ( storedNonce + s - length , nonce , length - 1 ) ; storedNonce [ s - 1 ] = nonce [ length - 1 ] & 0xfe ; AccessCipher ( ) . ProcessBlock ( storedNonce , m_pad ( ) ) ; m_padCached = true ; } storedNonce [ s - 1 ] = nonce [ length - 1 ] ; } m_isFirstBlock = true ; Restart ( ) ; } void VMAC_Base :: HashEndianCor@@ rectedBlock ( const word64 * data ) { assert ( false ) ; throw 0 ; } # if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86 # pragma warning ( disable : 4731 ) void # ifdef __GNUC__ __attribute__ ( ( noinline ) ) # endif VMAC_Base :: VHASH_Update_SSE2 ( const word64 * data , size_t blocksRemainingInWord64 , int tagPart ) { const word64 * nhK = m_nhKey ( ) ; word64 * polyS = m_polyState ( ) ; word32 L1KeyLength = m_L1KeyLength ; # ifdef __GNUC__ word32 temp ; __asm_@@ _ __volati@@ le__ ( AS2 ( mov % % ebx , % 0 ) AS2 ( mov % 1 , % % ebx ) " . intel _ syntax ▁ noprefix ; " # else # if _MSC_VER < 1300 || defined ( __INTEL_COMPILER ) char isFirstBlock = m_isFirstBlock ; AS2 ( mov ebx , [ L1KeyLength ] ) AS2 ( mov dl , [ isFirstBlock ] ) # else AS2 ( mov ecx , this ) AS2 ( mov ebx , [ ecx + m_L1KeyLength ] ) AS2 ( mov dl , [ ecx + m_isFirstBlock ] ) # endif AS2 ( mov eax , tagPart ) AS2 ( shl eax , 4 ) AS2 ( mov edi , nhK ) AS2 ( add edi , eax ) AS2 ( add eax , eax ) AS2 ( add eax , polyS ) AS2 ( mov esi , data ) AS2 ( mov ecx , blocksRemainingInWord64 ) # endif AS2 ( shr ebx , 3 ) AS1 ( push ebp ) AS2 ( sub esp , 12 ) ASL ( 4 ) AS2 ( mov ebp , ebx ) AS2 ( cmp ecx , ebx ) AS2 ( cmovl ebp , ecx ) AS2 ( sub ecx , ebp ) AS2 ( lea ebp , [ edi + 8 * ebp ] ) AS2 ( movq mm6 , [ esi ] ) AS2 ( paddq mm6 , [ edi ] ) AS2 ( movq mm5 , [ esi + 8 ] ) AS2 ( paddq mm5 , [ edi + 8 ] ) AS2 ( add esi , 16 ) AS2 ( add edi , 16 ) AS2 ( movq mm4 , mm6 ) ASS ( pshufw mm2 , mm6 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm6 , mm5 ) ASS ( pshufw mm3 , mm5 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm5 , mm2 ) AS2 ( pmuludq mm2 , mm3 ) AS2 ( pmuludq mm3 , mm4 ) AS2 ( pxor mm7 , mm7 ) AS2 ( movd [ esp ] , mm6 ) AS2 ( psrlq mm6 , 32 ) AS2 ( movd [ esp + 4 ] , mm5 ) AS2 ( psrlq mm5 , 32 ) AS2 ( cmp edi , ebp ) ASJ ( je , 1 , f ) ASL ( 0 ) AS2 ( movq mm0 , [ esi ] ) AS2 ( paddq mm0 , [ edi ] ) AS2 ( movq mm1 , [ esi + 8 ] ) AS2 ( paddq mm1 , [ edi + 8 ] ) AS2 ( add esi , 16 ) AS2 ( add edi , 16 ) AS2 ( movq mm4 , mm0 ) AS2 ( paddq mm5 , mm2 ) ASS ( pshufw mm2 , mm0 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm0 , mm1 ) AS2 ( movd [ esp + 8 ] , mm3 ) AS2 ( psrlq mm3 , 32 ) AS2 ( paddq mm5 , mm3 ) ASS ( pshufw mm3 , mm1 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm1 , mm2 ) AS2 ( pmuludq mm2 , mm3 ) AS2 ( pmuludq mm3 , mm4 ) AS2 ( movd mm4 , [ esp ] ) AS2 ( paddq mm7 , mm4 ) AS2 ( movd mm4 , [ esp + 4 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( movd mm4 , [ esp + 8 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( movd [ esp ] , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( paddq mm6 , mm0 ) AS2 ( movd [ esp + 4 ] , mm1 ) AS2 ( psrlq mm1 , 32 ) AS2 ( paddq mm5 , mm1 ) AS2 ( cmp edi , ebp ) ASJ ( jne , 0 , b ) ASL ( 1 ) AS2 ( paddq mm5 , mm2 ) AS2 ( movd [ esp + 8 ] , mm3 ) AS2 ( psrlq mm3 , 32 ) AS2 ( paddq mm5 , mm3 ) AS2 ( movd mm4 , [ esp ] ) AS2 ( paddq mm7 , mm4 ) AS2 ( movd mm4 , [ esp + 4 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( movd mm4 , [ esp + 8 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( lea ebp , [ 8 * ebx ] ) AS2 ( sub edi , ebp ) AS2 ( movd [ esp ] , mm7 ) AS2 ( psrlq mm7 , 32 ) AS2 ( paddq mm6 , mm7 ) AS2 ( movd [ esp + 4 ] , mm6 ) AS2 ( psrlq mm6 , 32 ) AS2 ( paddq mm5 , mm6 ) AS2 ( psllq mm5 , 2 ) AS2 ( psrlq mm5 , 2 ) # define a0 [ eax + 2 * 4 ] # define a1 [ eax + 3 * 4 ] # define a2 [ eax + 0 * 4 ] # define a3 [ eax + 1 * 4 ] # define k0 [ eax + 2 * 8 + 2 * 4 ] # define k1 [ eax + 2 * 8 + 3 * 4 ] # define k2 [ eax + 2 * 8 + 0 * 4 ] # define k3 [ eax + 2 * 8 + 1 * 4 ] AS2 ( test dl , dl ) ASJ ( jz , 2 , f ) AS2 ( movd mm1 , k0 ) AS2 ( movd mm0 , [ esp ] ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd a0 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( movd mm1 , k1 ) AS2 ( movd mm2 , [ esp + 4 ] ) AS2 ( paddq mm1 , mm2 ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd a1 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( paddq mm5 , k2 ) AS2 ( paddq mm0 , mm5 ) AS2 ( movq a2 , mm0 ) AS2 ( xor edx , edx ) ASJ ( jmp , 3 , f ) ASL ( 2 ) AS2 ( movd mm0 , a3 ) AS2 ( movq mm4 , mm0 ) AS2 ( pmuludq mm0 , k3 ) AS2 ( movd mm1 , a0 ) AS2 ( pmuludq mm1 , k2 ) AS2 ( movd mm2 , a1 ) AS2 ( movd mm6 , k1 ) AS2 ( pmuludq mm2 , mm6 ) AS2 ( movd mm3 , a2 ) AS2 ( psllq mm0 , 1 ) AS2 ( paddq mm0 , mm5 ) AS2 ( movq mm5 , mm3 ) AS2 ( movd mm7 , k0 ) AS2 ( pmuludq mm3 , mm7 ) AS2 ( pmuludq mm4 , mm7 ) AS2 ( pmuludq mm5 , mm6 ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd mm1 , a1 ) AS2 ( paddq mm4 , mm5 ) AS2 ( movq mm5 , mm1 ) AS2 ( pmuludq mm1 , k2 ) AS2 ( paddq mm0 , mm2 ) AS2 ( movd mm2 , a0 ) AS2 ( paddq mm0 , mm3 ) AS2 ( movq mm3 , mm2 ) AS2 ( pmuludq mm2 , k3 ) AS2 ( pmuludq mm3 , mm7 ) AS2 ( movd [ esp + 8 ] , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( pmuludq mm7 , mm5 ) AS2 ( pmuludq mm5 , k3 ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd mm1 , a2 ) AS2 ( pmuludq mm1 , k2 ) AS2 ( paddq mm0 , mm2 ) AS2 ( paddq mm0 , mm4 ) AS2 ( movq mm4 , mm0 ) AS2 ( movd mm2 , a3 ) AS2 ( pmuludq mm2 , mm6 ) AS2 ( pmuludq mm6 , a0 ) AS2 ( psrlq mm0 , 31 ) AS2 ( paddq mm0 , mm3 ) AS2 ( movd mm3 , [ esp ] ) AS2 ( paddq mm0 , mm3 ) AS2 ( movd mm3 , a2 ) AS2 ( pmuludq mm3 , k3 ) AS2 ( paddq mm5 , mm1 ) AS2 ( movd mm1 , a3 ) AS2 ( pmuludq mm1 , k2 ) AS2 ( paddq mm5 , mm2 ) AS2 ( movd mm2 , [ esp + 4 ] ) AS2 ( psllq mm5 , 1 ) AS2 ( paddq mm0 , mm5 ) AS2 ( psllq mm4 , 33 ) AS2 ( movd a0 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( paddq mm6 , mm7 ) AS2 ( movd mm7 , [ esp + 8 ] ) AS2 ( paddq mm0 , mm6 ) AS2 ( paddq mm0 , mm2 ) AS2 ( paddq mm3 , mm1 ) AS2 ( psllq mm3 , 1 ) AS2 ( paddq mm0 , mm3 ) AS2 ( psrlq mm4 , 1 ) AS2 ( movd a1 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( por mm4 , mm7 ) AS2 ( paddq mm0 , mm4 ) AS2 ( movq a2 , mm0 ) # undef a0 # undef a1 # undef a2 # undef a3 # undef k0 # undef k1 # undef k2 # undef k3 ASL ( 3 ) AS2 ( test ecx , ecx ) ASJ ( jnz , 4 , b ) AS2 ( add esp , 12 ) AS1 ( pop ebp ) AS1 ( emms ) # ifdef __GNUC__ " . att _ syntax ▁ prefix ; " AS2 ( mov % 0 , % % ebx ) : " = m " ( temp ) : " m " ( L1KeyLength ) , " c " ( blocksRemainingInWord64 ) , " S " ( data ) , " D " ( nhK + tagPart * 2 ) , " d " ( m_isFirstBlock ) , " a " ( polyS + tagPart * 4 ) : " memory " , " cc " ) ; # endif } # endif # if VMAC_BOOL_WORD128 # define DeclareNH ( a ) word128 a = 0 # define MUL64 ( rh , rl , i1 , i2 ) { word128 p = word128 ( i1 ) * ( i2 ) ; rh = word64 ( p >> 64 ) ; rl = word64 ( p ) ; } # define AccumulateNH ( a , b , c ) a += word128 ( b ) * ( c ) # define Multiply128 ( r , i1 , i2 ) r = word128 ( word64 ( i1 ) ) * word64 ( i2 ) # else # if _MSC_VER >= 1400 && ! defined ( __INTEL_COMPILER ) # define MUL32 ( a , b ) __emulu ( word32 ( a ) , word32 ( b ) ) # else # define MUL32 ( a , b ) ( ( word64 ) ( ( word32 ) ( a ) ) * ( word32 ) ( b ) ) # endif # if defined ( CRYPTOPP_X64_ASM_AVAILABLE ) # define DeclareNH ( a ) word64 a ## 0 = 0 , a ## 1 = 0 # define MUL64 ( rh , rl , i1 , i2 ) asm ( " mulq ▁ % 3" : " = a " ( rl ) , " = d " ( rh ) : " a " ( i1 ) , " g " ( i2 ) : " cc " ) ; # define AccumulateNH ( a , b , c ) asm ( " mulq ▁ % 3 ; ▁ addq ▁ % % rax , ▁ % 0 ; ▁ adcq ▁ % % rdx , ▁ % 1" : " + r " ( a ## 0 ) , " + r " ( a ## 1 ) : " a " ( b ) , " g " ( c ) : " % rdx " , " cc " ) ; # define ADD128 ( rh , rl , ih , il ) asm ( " addq ▁ % 3 , ▁ % 1 ; ▁ adcq ▁ % 2 , ▁ % 0" : " + r " ( rh ) , " + r " ( rl ) : " r " ( ih ) , " r " ( il ) : " cc " ) ; # elif defined ( _MSC_VER ) && ! CRYPTOPP_BOOL_SLOW_WORD64 # define DeclareNH ( a ) word64 a ## 0 = 0 , a ## 1 = 0 # define MUL64 ( rh , rl , i1 , i2 ) ( rl ) = _umul128 ( i1 , i2 , & ( rh ) ) ; # define AccumulateNH ( a , b , c ) { word64 ph , pl ; pl = _umul128 ( b , c , & ph ) ; a ## 0 += pl ; a ## 1 += ph + ( a ## 0 < pl ) ; } # else # define VMAC_BOOL_32BIT 1 # define DeclareNH ( a ) word64 a ## 0 = 0 , a ## 1 = 0 , a ## 2 = 0 # define MUL64 ( rh , rl , i1 , i2 ) { word64 _i1 = ( i1 ) , _i2 = ( i2 ) ; word64 m1 = MUL32 ( _i1 , _i2 >> 32 ) ; word64 m2 = MUL32 ( _i1 >> 32 , _i2 ) ; rh = MUL32 ( _i1 >> 32 , _i2 >> 32 ) ; rl = MUL32 ( _i1 , _i2 ) ; ADD128 ( rh , rl , ( m1 >> 32 ) , ( m1 << 32 ) ) ; ADD128 ( rh , rl , ( m2 >> 32 ) , ( m2 << 32 ) ) ; } # define AccumulateNH ( a , b , c ) { word64 p = MUL32 ( b , c ) ; a ## 1 += word32 ( ( p ) >> 32 ) ; a ## 0 += word32 ( p ) ; p = MUL32 ( ( b ) >> 32 , c ) ; a ## 2 += word32 ( ( p ) >> 32 ) ; a ## 1 += word32 ( p ) ; p = MUL32 ( ( b ) >> 32 , ( c ) >> 32 ) ; a ## 2 += p ; p = MUL32 ( b , ( c ) >> 32 ) ; a ## 1 += word32 ( p ) ; a ## 2 += word32 ( p >> 32 ) ; } # endif # endif # ifndef VMAC_BOOL_32BIT # define VMAC_BOOL_32BIT 0 # endif # ifndef ADD128 # define ADD128 ( rh , rl , ih , il ) { word64 _il = ( il ) ; ( rl ) += ( _il ) ; ( rh ) += ( ih ) + ( ( rl ) < ( _il ) ) ; } # endif # if ! ( defined ( _MSC_VER ) && _MSC_VER < 1300 ) template < bool T_128BitTag > # endif void VMAC_Base :: VHASH_Update_Template ( const word64 * data , size_t blocksRemainingInWord64 ) { # define INNER_LOOP_ITERATION ( j ) { word64 d0 = ConditionalByteReverse ( LITTLE_ENDIAN_ORDER , data [ i + 2 * j + 0 ] ) ; word64 d1 = ConditionalByteReverse ( LITTLE_ENDIAN_ORDER , data [ i + 2 * j + 1 ] ) ; AccumulateNH ( nhA , d0 + nhK [ i + 2 * j + 0 ] , d1 + nhK [ i + 2 * j + 1 ] ) ; if ( T_128BitTag ) AccumulateNH ( nhB , d0 + nhK [ i + 2 * j + 2 ] , d1 + nhK [ i + 2 * j + 3 ] ) ; } # if ( defined ( _MSC_VER ) && _MSC_VER < 1300 ) bool T_128BitTag = m_is128 ; # endif size_t L1KeyLengthInWord64 = m_L1KeyLength / 8 ; size_t innerLoopEnd = L1KeyLengthInWord64 ; const word64 * nhK = m_nhKey ( ) ; word64 * polyS = m_polyState ( ) ; bool isFirstBlock = true ; size_t i ; # if ! VMAC_BOOL_32BIT # if VMAC_BOOL_WORD128 word128 a1 , a2 ; # else word64 ah1 , al1 , ah2 , al2 ; # endif word64 kh1 , kl1 , kh2 , kl2 ; kh1 = ( polyS + 0 * 4 + 2 ) [ 0 ] ; kl1 = ( polyS + 0 * 4 + 2 ) [ 1 ] ; if ( T_128BitTag ) { kh2 = ( polyS + 1 * 4 + 2 ) [ 0 ] ; kl2 = ( polyS + 1 * 4 + 2 ) [ 1 ] ; } # endif do { DeclareNH ( nhA ) ; DeclareNH ( nhB ) ; i = 0 ; if ( blocksRemainingInWord64 < L1KeyLengthInWord64 ) { if ( blocksRemainingInWord64 % 8 ) { innerLoopEnd = blocksRemainingInWord64 % 8 ; for ( ; i < innerLoopEnd ; i += 2 ) INNER_LOOP_ITERATION ( 0 ) ; } innerLoopEnd = blocksRemainingInWord64 ; } for ( ; i < innerLoopEnd ; i += 8 ) { INNER_LOOP_ITERATION ( 0 ) ; INNER_LOOP_ITERATION ( 1 ) ; INNER_LOOP_ITERATION ( 2 ) ; INNER_LOOP_ITERATION ( 3 ) ; } blocksRemainingInWord64 -= innerLoopEnd ; data += innerLoopEnd ; # if VMAC_BOOL_32BIT word32 nh0 [ 2 ] , nh1 [ 2 ] ; word64 nh2 [ 2 ] ; nh0 [ 0 ] = word32 ( nhA0 ) ; nhA1 += ( nhA0 >> 32 ) ; nh1 [ 0 ] = word32 ( nhA1 ) ; nh2 [ 0 ] = ( nhA2 + ( nhA1 >> 32 ) ) & m62 ; if ( T_128BitTag ) { nh0 [ 1 ] = word32 ( nhB0 ) ; nhB1 += ( nhB0 >> 32 ) ; nh1 [ 1 ] = word32 ( nhB1 ) ; nh2 [ 1 ] = ( nhB2 + ( nhB1 >> 32 ) ) & m62 ; } # define a0 ( ( ( word32 * ) ( polyS + i * 4 ) ) [ 2 + NativeByteOrder :: ToEnum ( ) ] ) # define a1 ( * ( ( ( word32 * ) ( polyS + i * 4 ) ) + 3 - NativeByteOrder :: ToEnum ( ) ) ) # define a2 ( ( ( word32 * ) ( polyS + i * 4 ) ) [ 0 + NativeByteOrder :: ToEnum ( ) ] ) # define a3 ( * ( ( ( word32 * ) ( polyS + i * 4 ) ) + 1 - NativeByteOrder :: ToEnum ( ) ) ) # define aHi ( ( polyS + i * 4 ) [ 0 ] ) # define k0 ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) [ 2 + NativeByteOrder :: ToEnum ( ) ] ) # define k1 ( * ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) + 3 - NativeByteOrder :: ToEnum ( ) ) ) # define k2 ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) [ 0 + NativeByteOrder :: ToEnum ( ) ] ) # define k3 ( * ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) + 1 - NativeByteOrder :: ToEnum ( ) ) ) # define kHi ( ( polyS + i * 4 + 2 ) [ 0 ] ) if ( isFirstBlock ) { isFirstBlock = false ; if ( m_isFirstBlock ) { m_isFirstBlock = false ; for ( i = 0 ; i <= ( size_t ) T_128BitTag ; i ++ ) { word64 t = ( word64 ) nh0 [ i ] + k0 ; a0 = ( word32 ) t ; t = ( t >> 32 ) + nh1 [ i ] + k1 ; a1 = ( word32 ) t ; aHi = ( t >> 32 ) + nh2 [ i ] + kHi ; } continue ; } } for ( i = 0 ; i <= ( size_t ) T_128BitTag ; i ++ ) { word64 p , t ; word32 t2 ; p = MUL32 ( a3 , 2 * k3 ) ; p += nh2 [ i ] ; p += MUL32 ( a0 , k2 ) ; p += MUL32 ( a1 , k1 ) ; p += MUL32 ( a2 , k0 ) ; t2 = ( word32 ) p ; p >>= 32 ; p += MUL32 ( a0 , k3 ) ; p += MUL32 ( a1 , k2 ) ; p += MUL32 ( a2 , k1 ) ; p += MUL32 ( a3 , k0 ) ; t = ( word64 ( word32 ( p ) & 0x7fffffff ) << 32 ) | t2 ; p >>= 31 ; p += nh0 [ i ] ; p += MUL32 ( a0 , k0 ) ; p += MUL32 ( a1 , 2 * k3 ) ; p += MUL32 ( a2 , 2 * k2 ) ; p += MUL32 ( a3 , 2 * k1 ) ; t2 = ( word32 ) p ; p >>= 32 ; p += nh1 [ i ] ; p += MUL32 ( a0 , k1 ) ; p += MUL32 ( a1 , k0 ) ; p += MUL32 ( a2 , 2 * k3 ) ; p += MUL32 ( a3 , 2 * k2 ) ; a0 = t2 ; a1 = ( word32 ) p ; aHi = ( p >> 32 ) + t ; } # undef a0 # undef a1 # undef a2 # undef a3 # undef aHi # undef k0 # undef k1 # undef k2 # undef k3 # undef kHi # else if ( isFirstBlock ) { isFirstBlock = false ; if ( m_isFirstBlock ) { m_isFirstBlock = false ; # if VMAC_BOOL_WORD128 # define first_poly_step ( a , kh , kl , m ) a = ( m & m126 ) + ( ( word128 ( kh ) << 64 ) | kl ) first_poly_step ( a1 , kh1 , kl1 , nhA ) ; if ( T_128BitTag ) first_poly_step ( a2 , kh2 , kl2 , nhB ) ; # else # define first_poly_step ( ah , al , kh , kl , mh , ml ) { mh &= m62 ; ADD128 ( mh , ml , kh , kl ) ; ah = mh ; al = ml ; } first_poly_step ( ah1 , al1 , kh1 , kl1 , nhA1 , nhA0 ) ; if ( T_128BitTag ) first_poly_step ( ah2 , al2 , kh2 , kl2 , nhB1 , nhB0 ) ; # endif continue ; } else { # if VMAC_BOOL_WORD128 a1 = ( word128 ( ( polyS + 0 * 4 ) [ 0 ] ) << 64 ) | ( polyS + 0 * 4 ) [ 1 ] ; # else ah1 = ( polyS + 0 * 4 ) [ 0 ] ; al1 = ( polyS + 0 * 4 ) [ 1 ] ; # endif if ( T_128BitTag ) { # if VMAC_BOOL_WORD128 a2 = ( word128 ( ( polyS + 1 * 4 ) [ 0 ] ) << 64 ) | ( polyS + 1 * 4 ) [ 1 ] ; # else ah2 = ( polyS + 1 * 4 ) [ 0 ] ; al2 = ( polyS + 1 * 4 ) [ 1 ] ; # endif } } } # if VMAC_BOOL_WORD128 # define poly_step ( a , kh , kl , m ) { word128 t1 , t2 , t3 , t4 ; Multiply128 ( t2 , a >> 64 , kl ) ; Multiply128 ( t3 , a , kh ) ; Multiply128 ( t1 , a , kl ) ; Multiply128 ( t4 , a >> 64 , 2 * kh ) ; t2 += t3 ; t4 += t1 ; t2 += t4 >> 64 ; a = ( word128 ( word64 ( t2 ) & m63 ) << 64 ) | word64 ( t4 ) ; t2 *= 2 ; a += m & m126 ; a += t2 >> 64 ; } poly_step ( a1 , kh1 , kl1 , nhA ) ; if ( T_128BitTag ) poly_step ( a2 , kh2 , kl2 , nhB ) ; # else # define poly_step ( ah , al , kh , kl , mh , ml ) { word64 t1h , t1l , t2h , t2l , t3h , t3l , z = 0 ; MUL64 ( t2h , t2l , ah , kl ) ; MUL64 ( t3h , t3l , al , kh ) ; MUL64 ( t1h , t1l , ah , 2 * kh ) ; MUL64 ( ah , al , al , kl ) ; ADD128 ( t2h , t2l , t3h , t3l ) ; ADD128 ( ah , al , t1h , t1l ) ; ADD128 ( t2h , ah , z , t2l ) ; t2h += t2h + ( ah >> 63 ) ; ah &= m63 ; mh &= m62 ; ADD128 ( ah , al , mh , ml ) ; ADD128 ( ah , al , z , t2h ) ; } poly_step ( ah1 , al1 , kh1 , kl1 , nhA1 , nhA0 ) ; if ( T_128BitTag ) poly_step ( ah2 , al2 , kh2 , kl2 , nhB1 , nhB0 ) ; # endif # endif } while ( blocksRemainingInWord64 ) ; # if VMAC_BOOL_WORD128 ( polyS + 0 * 4 ) [ 0 ] = word64 ( a1 >> 64 ) ; ( polyS + 0 * 4 ) [ 1 ] = word64 ( a1 ) ; if ( T_128BitTag ) { ( polyS + 1 * 4 ) [ 0 ] = word64 ( a2 >> 64 ) ; ( polyS + 1 * 4 ) [ 1 ] = word64 ( a2 ) ; } # elif ! VMAC_BOOL_32BIT ( polyS + 0 * 4 ) [ 0 ] = ah1 ; ( polyS + 0 * 4 ) [ 1 ] = al1 ; if ( T_128BitTag ) { ( polyS + 1 * 4 ) [ 0 ] = ah2 ; ( polyS + 1 * 4 ) [ 1 ] = al2 ; } # endif } inline void VMAC_Base :: VHASH_Update ( const word64 * data , size_t blocksRemainingInWord64 ) { # if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86 if ( HasSSE2 ( ) ) { VHASH_Update_SSE2 ( data , blocksRemainingInWord64 , 0 ) ; if ( m_is128 ) VHASH_Update_SSE2 ( data , blocksRemainingInWord64 , 1 ) ; m_isFirstBlock = false ; } else # endif { # if defined ( _MSC_VER ) && _MSC_VER < 1300 VHASH_Update_Template ( data , blocksRemainingInWord64 ) ; # else if ( m_is128 ) VHASH_Update_Template < true > ( data , blocksRemainingInWord64 ) ; else VHASH_Update_Template < false > ( data , blocksRemainingInWord64 ) ; # endif } } size_t VMAC_Base :: HashMultiple@@ Blocks ( const word64 * data , size_t length ) { size_t remaining = ModPowerOf2 ( length , m_L1KeyLength ) ; VHASH_Update ( data , ( length - remaining ) / 8 ) ; return remaining ; } static word64 L3Hash ( const word64 * input , const word64 * l3Key , size_t len ) { word64 rh , rl , t , z = 0 ; word64 p1 = input [ 0 ] , p2 = input [ 1 ] ; word64 k1 = l3Key [ 0 ] , k2 = l3Key [ 1 ] ; t = p1 >> 63 ; p1 &= m63 ; ADD128 ( p1 , p2 , len , t ) ; t = ( p1 > m63 ) + ( ( p1 == m63 ) & ( p2 == m64 ) ) ; ADD128 ( p1 , p2 , z , t ) ; p1 &= m63 ; t = p1 + ( p2 >> 32 ) ; t += ( t >> 32 ) ; t += ( word32 ) t > 0xfffffffe@@ U ; p1 += ( t >> 32 ) ; p2 += ( p1 << 32 ) ; p1 += k1 ; p1 += ( 0 - ( p1 < k1 ) ) & 257 ; p2 += k2 ; p2 += ( 0 - ( p2 < k2 ) ) & 257 ; MUL64 ( rh , rl , p1 , p2 ) ; t = rh >> 56 ; ADD128 ( t , rl , z , rh ) ; rh <<= 8 ; ADD128 ( t , rl , z , rh ) ; t += t << 8 ; rl += t ; rl += ( 0 - ( rl < t ) ) & 257 ; rl += ( 0 - ( rl > p64 - 1 ) ) & 257 ; return rl ; } void VMAC_Base :: TruncatedFinal ( byte * mac , size_t size ) { size_t len = ModPowerOf2 ( GetBitCountLo ( ) / 8 , m_L1KeyLength ) ; if ( len ) { memset ( m_data ( ) + len , 0 , ( 0 - len ) % 16 ) ; VHASH_Update ( DataBuf ( ) , ( ( len + 15 ) / 16 ) * 2 ) ; len *= 8 ; } else if ( m_isFirstBlock ) { m_polyState ( ) [ 0 ] = m_polyState ( ) [ 2 ] ; m_polyState ( ) [ 1 ] = m_polyState ( ) [ 3 ] ; if ( m_is128 ) { m_polyState ( ) [ 4 ] = m_polyState ( ) [ 6 ] ; m_polyState ( ) [ 5 ] = m_polyState ( ) [ 7 ] ; } } if ( m_is128 ) { word64 t [ 2 ] ; t [ 0 ] = L3Hash ( m_polyState ( ) , m_l3Key ( ) , len ) + GetWord < word64 > ( true , BIG_ENDIAN_ORDER , m_pad ( ) ) ; t [ 1 ] = L3Hash ( m_polyState ( ) + 4 , m_l3Key ( ) + 2 , len ) + GetWord < word64 > ( true , BIG_ENDIAN_ORDER , m_pad ( ) + 8 ) ; if ( size == 16 ) { PutWord ( false , BIG_ENDIAN_ORDER , mac , t [ 0 ] ) ; PutWord ( false , BIG_ENDIAN_ORDER , mac + 8 , t [ 1 ] ) ; } else { t [ 0 ] = ConditionalByteReverse ( BIG_ENDIAN_ORDER , t [ 0 ] ) ; t [ 1 ] = ConditionalByteReverse ( BIG_ENDIAN_ORDER , t [ 1 ] ) ; memcpy ( mac , t , size ) ; } } else { word64 t = L3Hash ( m_polyState ( ) , m_l3Key ( ) , len ) ; t += GetWord < word64 > ( true , BIG_ENDIAN_ORDER , m_pad ( ) + ( m_nonce ( ) [ IVSize ( ) - 1 ] & 1 ) * 8 ) ; if ( size == 8 ) PutWord ( false , BIG_ENDIAN_ORDER , mac , t ) ; else { t = ConditionalByteReverse ( BIG_ENDIAN_ORDER , t ) ; memcpy ( mac , & t , size ) ; } } } NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="lassoan/CTK/tree/master/Plugins/org.@@ commontk.@@ plugingenerator.ui/@@ ctkPluginGeneratorUiPlugin.cpp"> # include " ctkPluginGeneratorUiPlugin _ p . h " # include " ctkPluginGeneratorMainExtension . h " # include < ctkPluginConstants . h > # include < QtPlugin > # include < QDebug > void ctkPluginGeneratorUiPlugin :: start ( ctkPluginContext * context ) { mainExtension = new ctkPluginGeneratorMainExtension ( ) ; ctkDictionary props ; props . insert ( ctkPluginConstants :: SERVICE_RANKING , 0 ) ; context -> registerService ( QStringList ( " ctkPluginGeneratorAbstractUi@@ Extension " ) , mainExtension , props ) ; qDebug ( ) << " Registered ▁ Main ▁ Extension " ; } void ctkPluginGeneratorUiPlugin :: stop ( ctkPluginContext * context ) { Q_UNUSED ( context ) delete mainExtension ; } Q_EXPORT_PLUGIN@@ 2 ( org_commontk_plugingener@@ ator_ui , ctkPluginGeneratorUiPlugin ) </DOCUMENT>
