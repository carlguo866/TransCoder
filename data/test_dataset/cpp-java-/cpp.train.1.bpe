<DOCUMENT_ID="cnd@@ post/cpp@@ idioms/tree/master/bft@@ /bft.cpp"> # include < iostream > # include < vector > # include < queue > using namespace std ; class Tree ; class Tree { public : char data ; bool visited ; std :: vector < Tree * > children ; } ; void bft ( Tree * root ) { if ( root == NULL ) return ; if ( root -> visited ) return ; root -> visited = true ; printf ( " % c ▁ \n " , root -> data ) ; std :: queue < Tree * > * newQue = new std :: queue < Tree * > ( ) ; int Size = root -> children . size ( ) ; for ( int i = 0 ; i < Size ; i ++ ) { Tree * child = root -> children [ i ] ; if ( child != NULL ) newQue -> push ( child ) ; } for ( int i = 0 ; i < Size ; i ++ ) { Tree * child = newQue -> front ( ) ; if ( child != NULL ) bft ( child ) ; newQue -> pop ( ) ; } return ; } ; void insert ( Tree * root , char data ) { Tree * newTree = new Tree ( ) ; newTree -> data = data ; newTree -> visited = false ; root -> children . push_back ( newTree ) ; return ; } ; int main ( ) { Tree * root = new Tree ( ) ; root -> data = ' a ' ; Tree * leftChild = new Tree { } ; leftChild -> data = ' b ' ; Tree * rightChild = new Tree ( ) ; rightChild -> data = ' c ' ; root -> children . push_back ( leftChild ) ; root -> children . push_back ( rightChild ) ; cout << " start ▁ doing ▁ BFT ▁ in ▁ one ▁ way ▁ " << endl ; bft ( root ) ; delete root ; root = new Tree ( ) ; root -> data = ' a ' ; insert ( root , ' d ' ) ; insert ( root , ' e ' ) ; cout << " start ▁ doing ▁ BFT ▁ in ▁ 2nd ▁ way " << endl ; bft ( root ) ; cout << " done ▁ DFT ▁ " << endl ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="tpltn@@ t/uncr@@ ustify/tree/master/@@ tests/output/cpp/@@ 30920@@ -indent-off.cpp"> struct X { void operator - ( int ) ; void operator + ( int ) ; void operator ( ) ( ) ; } ; struct Y { void operator - ( int ) { } void operator + ( int ) { } void operator ( ) ( ) { } void func ( ) { auto x = " TABSYMBOL test\t ▁ TABSYMBOL ▁ TABSYMBOL ▁ TABSYMBOL TABSYMBOL . . . ▁ ▁ ▁ ? ? ? " ; } } ; struct Y { void operator - ( int ) { } void operator + ( int ) { } void operator ( ) ( ) { } void func ( ) { auto x = " TABSYMBOL test\t ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . . . ▁ ▁ ▁ ? ? ? " ; } } ; </DOCUMENT>
<DOCUMENT_ID="Ho@@ fiOne/xbmc/tree/master/xbmc/settings/dialogs/@@ GUIDialogLibExport@@ Settings.cpp"> # include < map > # include < memory > # include < string > # include < utility > # include < vector > # include < limits . h > # include " GUIDialogLibExportSettings . h " # include " dialogs / GUIDialogFileBrowser . h " # include " guilib / GUIComponent . h " # include " guilib / GUIWindowManager . h " # include " guilib / LocalizeStrings . h " # include " messaging / helpers / DialogHelper . h " # include " messaging / helpers / DialogOK@@ Helper . h " # include " ServiceBroker . h " # include " settings / SettingUtils . h " # include " settings / lib / Setting . h " # include " settings / Settings . h " # include " settings / windows / GUIControlSettings . h " # include " storage / MediaManager . h " # include " Util . h " # include " utils / log . h " # include " utils / URIUtils . h " # include " filesystem / Directory . h " using namespace ADDON ; using namespace KODI :: MESSAGING ; using KODI :: MESSAGING :: HELPERS :: DialogResponse ; CGUIDialogLibExportSettings :: CGUIDialogLibExportSettings ( ) : CGUIDialogSettingsManualBase ( WINDOW_DIALOG_LIBEXPORT_SETTINGS , " DialogSettings . xml " ) , m_destinationChecked ( false ) { } bool CGUIDialogLibExportSettings :: Show ( CLibExportSettings & settings ) { CGUIDialogLibExportSettings * dialog = CServiceBroker :: GetGUI ( ) -> GetWindowManager ( ) . GetWindow < CGUIDialogLibExportSettings > ( WINDOW_DIALOG_LIBEXPORT_SETTINGS ) ; if ( ! dialog ) return false ; dialog -> m_settings . SetExportType ( CServiceBroker :: GetSettings ( ) . GetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) ) ; dialog -> m_settings . m_strPath = CServiceBroker :: GetSettings ( ) . GetString ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; dialog -> m_settings . SetItemsToExport ( CServiceBroker :: GetSettings ( ) . GetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS ) ) ; dialog -> m_settings . m_unscraped = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED ) ; dialog -> m_settings . m_artwork = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK ) ; dialog -> m_settings . m_skipnfo = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO ) ; dialog -> m_settings . m_overwrite = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE ) ; dialog -> m_destinationChecked = false ; dialog -> Open ( ) ; bool confirmed = dialog -> IsConfirm@@ ed ( ) ; if ( confirmed ) { settings = dialog -> m_settings ; } return confirmed ; } void CGUIDialogLibExportSettings :: OnInitWindow ( ) { CGUIDialogSettingsManualBase :: OnInitWindow ( ) ; } void CGUIDialogLibExportSettings :: OnSettingChanged ( std :: shared_ptr < const CSetting > setting ) { if ( ! setting ) return ; CGUIDialogSettingsManualBase :: OnSettingChanged ( setting ) ; const std :: string & settingId = setting -> GetId ( ) ; if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) { m_settings . SetExportType ( std :: static_pointer_cast < const CSettingInt > ( setting ) -> GetValue ( ) ) ; SetupView ( ) ; SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) { m_settings . m_strPath = std :: static_pointer_cast < const CSettingString > ( setting ) -> GetValue ( ) ; UpdateButtons ( ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE ) m_settings . m_overwrite = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS ) m_settings . SetItemsToExport ( GetExportItemsFromSetting ( setting ) ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK ) { m_settings . m_artwork = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED ) m_settings . m_unscraped = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO ) m_settings . m_skipnfo = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; } void CGUIDialogLibExportSettings :: OnSettingAction ( std :: shared_ptr < const CSetting > setting ) { if ( setting == NULL ) return ; CGUIDialogSettingsManualBase :: OnSettingAction ( setting ) ; const std :: string & settingId = setting -> GetId ( ) ; if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) { VECSOURCES shares ; g_mediaManager . GetLocalDrives ( shares ) ; g_mediaManager . GetNetworkLocations ( shares ) ; g_mediaManager . GetRemovableDrives ( shares ) ; std :: string strDirectory = m_settings . m_strPath ; if ( ! strDirectory . empty ( ) ) { URIUtils :: AddSlashAt@@ End ( strDirectory ) ; bool bIsSource ; if ( CUtil :: GetMatchingSource ( strDirectory , shares , bIsSource ) < 0 ) { CMediaSource share ; share . strName = g_localizeStrings . Get ( 13278 ) ; share . strPath = strDirectory ; shares . push_back ( share ) ; } } else strDirectory = " default ▁ location " ; if ( CGUIDialogFileBrowser :: ShowAndGetDirectory ( shares , g_localizeStrings . Get ( 661 ) , strDirectory , true ) ) { if ( ! strDirectory . empty ( ) ) { m_destinationChecked = true ; m_settings . m_strPath = strDirectory ; SetLabel2 ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , strDirectory ) ; SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; } } UpdateButtons ( ) ; } } bool CGUIDialogLibExportSettings :: OnMessage ( CGUIMessage & message ) { switch ( message . GetMessage ( ) ) { case GUI_MSG_CLICKED : { int iControl = message . GetSenderId ( ) ; if ( iControl == CONTROL_SETTINGS_OKAY_BUTTON ) { OnOK ( ) ; return true ; } } break ; } return CGUIDialogSettingsManualBase :: OnMessage ( message ) ; } void CGUIDialogLibExportSettings :: OnOK ( ) { if ( m_settings . IsToLib@@ Folders ( ) ) { std :: string path = CServiceBroker :: GetSettings ( ) . GetString ( CSettings :: SETTING_MUSICLIBRARY_ARTISTSFOLDER ) ; if ( path . empty ( ) ) { if ( HELPERS :: ShowYes@@ NoDialogText ( 2022@@ 3 , 38317 , 186 , 10004 ) == DialogResponse :: YES ) { m_confirmed = false ; Close ( ) ; CServiceBroker :: GetGUI ( ) -> GetWindowManager ( ) . ActivateWindow ( WINDOW_SETTINGS_MEDIA , CSettings :: SETTING_MUSICLIBRARY_ARTISTSFOLDER ) ; } return ; } } else if ( ! m_destinationChecked ) { if ( ! XFILE :: CDirectory :: Exists ( m_settings . m_strPath ) ) { HELPERS :: ShowOK@@ DialogText ( CVariant { 38300 } , CVariant { 38318 } ) ; return ; } } m_confirmed = true ; Save ( ) ; Close ( ) ; } void CGUIDialogLibExportSettings :: Save ( ) { CLog :: Log ( LOGINFO , " CGUIDialogMusic@@ ExportSettings : ▁ Save ( ) ▁ called " ) ; CServiceBroker :: GetSettings ( ) . SetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE , m_settings . GetExportType ( ) ) ; CServiceBroker :: GetSettings ( ) . SetString ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , m_settings . m_strPath ) ; CServiceBroker :: GetSettings ( ) . SetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS , m_settings . GetItemsToExport ( ) ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED , m_settings . m_unscraped ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , m_settings . m_overwrite ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , m_settings . m_artwork ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_skipnfo ) ; CServiceBroker :: GetSettings ( ) . Save ( ) ; } void CGUIDialogLibExportSettings :: SetupView ( ) { CGUIDialogSettingsManualBase :: SetupView ( ) ; SetHeading ( 38300 ) ; SET_CONTROL_HID@@ DEN ( CONTROL_SETTINGS_CUSTO@@ M_BUTTON ) ; SET_CONTROL_LABEL ( CONTROL_SETTINGS_OKAY_BUTTON , 38319 ) ; SET_CONTROL_LABEL ( CONTROL_SETTINGS_CANC@@ EL_BUTTON , 222 ) ; SetLabel2 ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , m_settings . m_strPath ) ; if ( m_settings . IsSingleFile ( ) ) { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , false ) ; } else if ( m_settings . IsSeparateFiles ( ) ) { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } else { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } UpdateButtons ( ) ; } void CGUIDialogLibExportSettings :: UpdateButtons ( ) { bool enableExport ( true ) ; if ( m_settings . IsSingleFile ( ) || m_settings . IsSeparateFiles ( ) ) enableExport = ! m_settings . m_strPath . empty ( ) ; CONTROL_ENABLE_@@ ON_CONDITION ( CONTROL_SETTINGS_OKAY_BUTTON , enableExport ) ; if ( ! enableExport ) SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; } void CGUIDialogLibExportSettings :: InitializeSettings ( ) { CGUIDialogSettingsManualBase :: InitializeSettings ( ) ; std :: shared_ptr < CSettingCategory > category = AddCategory ( " exportsettings " , - 1 ) ; if ( ! category ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : ▁ unable ▁ to ▁ setup ▁ settings " ) ; return ; } std :: shared_ptr < CSettingGroup > groupDetails = AddGroup ( category ) ; if ( ! groupDetails ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : ▁ unable ▁ to ▁ setup ▁ settings " ) ; return ; } Translat@@ ableInteger@@ SettingOptions entries ; entries . push_back ( std :: make_pair ( 38301 , ELIBEXPORT_SING@@ LEFILE ) ) ; entries . push_back ( std :: make_pair ( 38302 , ELIBEXPORT_SEPAR@@ ATEFILES ) ) ; entries . push_back ( std :: make_pair ( 38303 , ELIBEXPORT_TOLIBRARYFOLDER ) ) ; AddList ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE , 38304 , SettingLevel :: Basic , m_settings . GetExportType ( ) , entries , 38304 ) ; AddButton ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , 38305 , SettingLevel :: Basic ) ; entries . clear ( ) ; entries . push_back ( std :: make_pair ( 132 , ELIBEXPORT_ALBUMS ) ) ; entries . push_back ( std :: make_pair ( 38043 , ELIBEXPORT_ALBUMARTISTS ) ) ; entries . push_back ( std :: make_pair ( 38312 , ELIBEXPORT_SON@@ GARTISTS ) ) ; entries . push_back ( std :: make_pair ( 38313 , ELIBEXPORT_OTH@@ ERARTISTS ) ) ; AddList ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS , 38306 , SettingLevel :: Basic , m_settings . GetExportItems ( ) , entries , 133 , 1 ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED , 38308 , SettingLevel :: Basic , m_settings . m_unscraped ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , 38307 , SettingLevel :: Basic , m_settings . m_artwork ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , 38309 , SettingLevel :: Basic , m_settings . m_skipnfo ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , 38310 , SettingLevel :: Basic , m_settings . m_overwrite ) ; } void CGUIDialogLibExportSettings :: SetLabel2 ( const std :: string & settingid , const std :: string & label ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) SET_CONTROL_LABEL2 ( settingControl -> GetID ( ) , label ) ; } void CGUIDialogLibExportSettings :: ToggleState ( const std :: string & settingid , bool enabled ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) { if ( enabled ) CONTROL_ENABLE ( settingControl -> GetID ( ) ) ; else CONTROL_DISABLE ( settingControl -> GetID ( ) ) ; } } void CGUIDialogLibExportSettings :: SetFocus ( const std :: string & settingid ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) SET_CONTROL_FOCUS ( settingControl -> GetID ( ) , 0 ) ; } int CGUIDialogLibExportSettings :: GetExportItemsFromSetting ( SettingConstPtr setting ) { std :: shared_ptr < const CSettingList > settingList = std :: static_pointer_cast < const CSettingList > ( setting ) ; if ( settingList -> GetElementType ( ) != SettingType :: Integer ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : : % s ▁ - ▁ wrong ▁ items ▁ element ▁ type " , __FUNCTION__ ) ; return 0 ; } int exportitems = 0 ; std :: vector < CVariant > list = CSettingUtils :: GetList ( settingList ) ; for ( const auto & value : list ) { if ( ! value . isInteger ( ) ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : : % s ▁ - ▁ wrong ▁ items ▁ value ▁ type " , __FUNCTION__ ) ; return 0 ; } exportitems += value . asInteger ( ) ; } return exportitems ; } </DOCUMENT>
<DOCUMENT_ID="punker76@@ /Windows-universal@@ -samples/tree/master/Samples/XamlClo@@ udFontIntegration@@ /cpp/Scenario_Document1.xam@@ l.cpp"> # include " pch . h " # include " Scenario _ Document1 . xaml . h " using namespace SDKTemplate ; using namespace Platform ; using namespace Windows :: Foundation ; using namespace Windows :: Foundation :: Collections ; using namespace Windows :: UI :: Xaml ; using namespace Windows :: UI :: Xaml :: Controls ; using namespace Windows :: UI :: Xaml :: Controls :: Primitives ; using namespace Windows :: UI :: Xaml :: Data ; using namespace Windows :: UI :: Xaml :: Input ; using namespace Windows :: UI :: Xaml :: Media ; using namespace Windows :: UI :: Xaml :: Navigation ; Scenario_Document1 :: Scenario_Document1 ( ) { InitializeComponent ( ) ; } void Scenario_Document1 :: Page_Loaded ( Platform :: Object ^ sender , Windows :: UI :: Xaml :: Routed@@ EventArgs ^ e ) { this -> FontFamily = ref new Windows :: UI :: Xaml :: Media :: FontFamily ( " Neue ▁ Haas ▁ Grotesk ▁ Text ▁ Pro " ) ; } </DOCUMENT>
<DOCUMENT_ID="victorzha@@ o/miniblink49@@ /tree/master/third_party/WebKit/Source/core/@@ html/HTMLContentElement.cpp"> # include " config . h " # include " core / html / HTMLContentElement . h " # include " core / HTMLNames . h " # include " core / css / SelectorChecker . h " # include " core / css / parser / CSSParser . h " # include " core / dom / QualifiedName . h " # include " core / dom / shadow / ElementShadow . h " # include " core / dom / shadow / ShadowRoot . h " # include " platform / RuntimeEnabledFeatures . h " namespace blink { using namespace HTMLNames ; PassRefPtrWillBeRawPtr < HTMLContentElement > HTMLContentElement :: create ( Document & document , PassOwnPtrWillBeRawPtr < HTMLContentSelectFilter > filter ) { return adoptRefWillBe@@ Noop ( new HTMLContentElement ( document , filter ) ) ; } inline HTMLContentElement :: HTMLContentElement ( Document & document , PassOwnPtrWillBeRawPtr < HTMLContentSelectFilter > filter ) : InsertionPoint ( contentTag , document ) , m_shouldParseSelect ( false ) , m_isValidSelector ( true ) , m_filter ( filter ) { } HTMLContentElement :: ~ HTMLContentElement ( ) { } DEFINE_TRACE ( HTMLContentElement ) { visitor -> trace ( m_filter ) ; InsertionPoint :: trace ( visitor ) ; } void HTMLContentElement :: parseSelect ( ) { ASSERT ( m_shouldParseSelect ) ; CSSParser :: parseSelector ( CSSParser@@ Context ( document ( ) , 0 ) , m_select , m_selectorList ) ; m_shouldParseSelect = false ; m_isValidSelector = validateSelect ( ) ; if ( ! m_isValidSelector ) { CSSSelectorList emptyList ; m_selectorList . adopt ( emptyList ) ; } } void HTMLContentElement :: parseAttribute ( const QualifiedName & name , const AtomicString & value ) { if ( name == selectAttr ) { if ( ShadowRoot * root = containingShadowRoot ( ) ) root -> owner ( ) -> willAffectSelector ( ) ; m_shouldParseSelect = true ; m_select = value ; } else { InsertionPoint :: parseAttribute ( name , value ) ; } } static inline bool includesDisallowedPseudoClass ( const CSSSelector & selector ) { if ( selector . pseudoType ( ) == CSSSelector :: PseudoNot ) { const CSSSelector * subSelector = selector . selectorList ( ) -> first ( ) ; return subSelector -> match ( ) == CSSSelector :: PseudoClass ; } return selector . match ( ) == CSSSelector :: PseudoClass ; } bool HTMLContentElement :: validateSelect ( ) const { ASSERT ( ! m_shouldParseSelect ) ; if ( m_select . isNull ( ) || m_select . isEmpty ( ) ) return true ; if ( ! m_selectorList . isValid ( ) ) return false ; for ( const CSSSelector * selector = m_selectorList . first ( ) ; selector ; selector = m_selectorList . next ( * selector ) ) { if ( ! selector -> isCompound ( ) ) return false ; for ( const CSSSelector * subSelector = selector ; subSelector ; subSelector = subSelector -> tagHistory ( ) ) { if ( includesDisallowedPseudoClass ( * subSelector ) ) return false ; } } return true ; } bool HTMLContentElement :: matchSelector ( Element & element ) const { SelectorChecker selectorChecker ( SelectorChecker :: QueryingRules ) ; SelectorChecker :: SelectorCheck@@ ingContext context ( & element , SelectorChecker :: VisitedMatch@@ Disabled ) ; for ( const CSSSelector * selector = selectorList ( ) . first ( ) ; selector ; selector = CSSSelectorList :: next ( * selector ) ) { context . selector = selector ; if ( selectorChecker . match ( context ) ) return true ; } return false ; } } </DOCUMENT>
<DOCUMENT_ID="thivo@@ d/forgottenserver@@ /tree/master/src/trash@@ holder.cpp"> # include " otpch . h " # include " trashholder . h " # include " game . h " extern Game g_game ; TrashHolder :: TrashHolder ( uint16_t _type ) : Item ( _type ) { } TrashHolder :: ~ TrashHolder ( ) { } ReturnValue TrashHolder :: __queryAdd ( int32_t , const Thing * , uint32_t , uint32_t , Creature * ) const { return RET_NOERROR ; } ReturnValue TrashHolder :: __queryMaxCount ( int32_t , const Thing * , uint32_t count , uint32_t & maxQueryCount , uint32_t ) const { maxQueryCount = std :: max < uint32_t > ( 1 , count ) ; return RET_NOERROR ; } ReturnValue TrashHolder :: __queryRemove ( const Thing * , uint32_t , uint32_t ) const { return RET_NOTPOSSI@@ BLE ; } Cylinder * TrashHolder :: __queryDestination ( int32_t & , const Thing * , Item * * , uint32_t & ) { return this ; } void TrashHolder :: __addThing ( Thing * thing ) { return __addThing ( 0 , thing ) ; } void TrashHolder :: __addThing ( int32_t , Thing * thing ) { Item * item = thing -> getItem ( ) ; if ( ! item ) { return ; } if ( item == this || ! item -> hasProperty ( CONST_PROP_MOVEABLE ) ) { return ; } if ( item -> isHangable ( ) && isGroundTile ( ) ) { Tile * tile = dynamic_cast < Tile * > ( getParent ( ) ) ; if ( tile && tile -> hasFlag ( TILESTATE_SUPPORTS_@@ HANGABLE ) ) { return ; } } g_game . internalRemoveItem ( item ) ; const ItemType & it = Item :: items [ getID ( ) ] ; if ( it . magicEffect != CONST_ME_NONE ) { g_game . addMagicEffect ( getPosition ( ) , it . magicEffect ) ; } } void TrashHolder :: __update@@ Thing ( Thing * , uint16_t , uint32_t ) { } void TrashHolder :: __replaceThing ( uint32_t , Thing * ) { } void TrashHolder :: __removeThing ( Thing * , uint32_t ) { } void TrashHolder :: postAddNotification ( Thing * thing , const Cylinder * oldParent , int32_t index , cylinderlink_t ) { getParent ( ) -> postAddNotification ( thing , oldParent , index , LINK_PARENT ) ; } void TrashHolder :: postRemoveNotification ( Thing * thing , const Cylinder * newParent , int32_t index , bool isCompleteRemoval , cylinderlink_t ) { getParent ( ) -> postRemoveNotification ( thing , newParent , index , isCompleteRemoval , LINK_PARENT ) ; } </DOCUMENT>
<DOCUMENT_ID="shliuj@@ ing/TeamTalk@@ /tree/master/server@@ /src/db_pro@@ xy_server/busin@@ ess/User@@ Action.cpp"> # include < list > # include < map > # include " . . / ProxyConn . h " # include " . . / DBPool . h " # include " . . / SyncCenter . h " # include " public _ define . h " # include " UserModel . h " # include " IM . Login . pb . h " # include " IM . Buddy . pb . h " # include " IM . BaseDefine . pb . h " namespace DB_PROXY { void getUserInfo ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMUsersInfoReq msg ; IM :: Buddy :: IMUsersInfoRsp msgResp ; if ( msg . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { CImPdu * pPduRes = new CImPdu ; uint32_t from_user_id = msg . user_id ( ) ; uint32_t userCount = msg . user_id_list_size ( ) ; std :: list < uint32_t > idList ; for ( uint32_t i = 0 ; i < userCount ; ++ i ) { idList . push_back ( msg . user_id_list ( i ) ) ; } std :: list < IM :: BaseDefine :: UserInfo > lsUser ; CUserModel :: getInstance ( ) -> getUsers ( idList , lsUser ) ; msgResp . set_user_id ( from_user_id ) ; for ( list < IM :: BaseDefine :: UserInfo > :: iterator it = lsUser . begin ( ) ; it != lsUser . end ( ) ; ++ it ) { IM :: BaseDefine :: UserInfo * pUser = msgResp . add_user_info@@ _list ( ) ; pUser -> set_user_id ( it -> user_id ( ) ) ; pUser -> set_user_gender ( it -> user_gender ( ) ) ; pUser -> set_user_nick_name ( it -> user_nick_name ( ) ) ; pUser -> set_avatar_url ( it -> avatar_url ( ) ) ; pUser -> set_sign_info ( it -> sign_info ( ) ) ; pUser -> set_department_id ( it -> department_id ( ) ) ; pUser -> set_email ( it -> email ( ) ) ; pUser -> set_user_real_name ( it -> user_real_name ( ) ) ; pUser -> set_user_tel ( it -> user_tel ( ) ) ; pUser -> set_user_domain ( it -> user_domain ( ) ) ; pUser -> set_status ( it -> status ( ) ) ; } log ( " userId = % u , ▁ userCnt = % u " , from_user_id , userCount ) ; msgResp . set_attach_data ( msg . attach_data ( ) ) ; pPduRes -> SetPBMsg ( & msgResp ) ; pPduRes -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pPduRes -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pPduRes -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_USER_INFO_RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pPduRes ) ; } else { log ( " parse ▁ pb ▁ failed " ) ; } } void getChangedUser ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMAllUserReq msg ; IM :: Buddy :: IMAllUserRsp msgResp ; if ( msg . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { CImPdu * pPduRes = new CImPdu ; uint32_t nReqId = msg . user_id ( ) ; uint32_t nLastTime = msg . latest_update_time ( ) ; uint32_t nLastUpdate = CSyncCenter :: getInstance ( ) -> getLastUpdate ( ) ; list < IM :: BaseDefine :: UserInfo > lsUsers ; if ( nLastUpdate > nLastTime ) { list < uint32_t > lsIds ; CUserModel :: getInstance ( ) -> getChangedId ( nLastTime , lsIds ) ; CUserModel :: getInstance ( ) -> getUsers ( lsIds , lsUsers ) ; } msgResp . set_user_id ( nReqId ) ; msgResp . set_latest_update_time ( nLastTime ) ; for ( list < IM :: BaseDefine :: UserInfo > :: iterator it = lsUsers . begin ( ) ; it != lsUsers . end ( ) ; ++ it ) { IM :: BaseDefine :: UserInfo * pUser = msgResp . add_user_list ( ) ; pUser -> set_user_id ( it -> user_id ( ) ) ; pUser -> set_user_gender ( it -> user_gender ( ) ) ; pUser -> set_user_nick_name ( it -> user_nick_name ( ) ) ; pUser -> set_avatar_url ( it -> avatar_url ( ) ) ; pUser -> set_sign_info ( it -> sign_info ( ) ) ; pUser -> set_department_id ( it -> department_id ( ) ) ; pUser -> set_email ( it -> email ( ) ) ; pUser -> set_user_real_name ( it -> user_real_name ( ) ) ; pUser -> set_user_tel ( it -> user_tel ( ) ) ; pUser -> set_user_domain ( it -> user_domain ( ) ) ; pUser -> set_status ( it -> status ( ) ) ; } log ( " userId = % u , nLastUpdate = % u , ▁ last _ time = % u , ▁ userCnt = % u " , nReqId , nLastUpdate , nLastTime , msgResp . user_list_size ( ) ) ; msgResp . set_attach_data ( msg . attach_data ( ) ) ; pPduRes -> SetPBMsg ( & msgResp ) ; pPduRes -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pPduRes -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pPduRes -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_ALL_USER_@@ RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pPduRes ) ; } else { log ( " parse ▁ pb ▁ failed " ) ; } } void changeUserSignInfo ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMChangeSignInfoReq req ; IM :: Buddy :: IMChangeSignInfoRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; const string & sign_info = req . sign_info ( ) ; bool result = CUserModel :: getInstance ( ) -> updateUserSignInfo ( user_id , sign_info ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_sign_info ( sign_info ) ; log ( " changeUserSignInfo ▁ sucess , ▁ user _ id = % u , ▁ sign _ info = % s " , user_id , sign_info . c_str ( ) ) ; } else { log ( " changeUserSignInfo ▁ false , ▁ user _ id = % u , ▁ sign _ info = % s " , user_id , sign_info . c_str ( ) ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " changeUserSignInfo : ▁ IMChangeSignInfoReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } } void doPushShield ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Login :: IMPushShieldReq req ; IM :: Login :: IMPushShieldRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; uint32_t shield_status = req . shield_status ( ) ; bool result = CUserModel :: getInstance ( ) -> updatePushShield ( user_id , shield_status ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_shield_status ( shield_status ) ; log ( " doPushShield ▁ sucess , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } else { log ( " doPushShield ▁ false , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_LOGIN ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_LOGIN_RES_PUSH_SHIELD ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " doPushShield : ▁ IMPushShieldReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } } void doQueryPushShield ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Login :: IMQueryPushShieldReq req ; IM :: Login :: IMQueryPushShieldRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; uint32_t shield_status = 0 ; bool result = CUserModel :: getInstance ( ) -> getPushShield ( user_id , & shield_status ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_shield_status ( shield_status ) ; log ( " doQueryPushShield ▁ sucess , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } else { log ( " doQueryPushShield ▁ false , ▁ user _ id = % u " , user_id ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_LOGIN ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_LOGIN_RES_QUERY_PUSH_SHIELD ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " doQueryPushShield : ▁ IMQueryPushShieldReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } } } ; </DOCUMENT>
<DOCUMENT_ID="PG@@ er/incub@@ ator-hawq/tree/master/src/@@ backend/access/par@@ quet/metadatauti@@ l_c++/Metadatainterface@@ .cpp"> # include < iostream > # include < stdint . h > # include < boost / shared_ptr . hpp > # include < boost / math_fwd . hpp > # include < thrift / protocol / TBinaryProtocol . h > # include < fcntl . h > # include < fstream > # include < stdio . h > # include < bitset > # include " MetadataUtil . h " using namespace hawq ; using namespace std ; using namespace boost ; extern " C " { # include " postgres . h " # include " utils / palloc . h " int readPageMetadata ( uint8_t * buf , uint32_t * len , int compact , struct PageMetadata_4C * * ppageMetdata ) { * ppageMetdata = ( struct PageMetadata_4C * ) palloc0 ( sizeof ( struct PageMetadata_4C ) ) ; bool compactBool = ( compact == 1 ) ? true : false ; int iret = MetadataUtil :: readPageMetadata ( buf , len , compactBool , * ppageMetdata ) ; return iret ; } int writePageMetadata ( uint8_t * * buf , uint32_t * len , struct PageMetadata_4C * ppageMetadata ) { int iret = MetadataUtil :: writePageMetadata ( buf , len , ppageMetadata ) ; return iret ; } int writeColumnChunkMetadata ( uint8_t * * buf , uint32_t * len , struct ColumnChunkMetadata_4C * blockMetadata ) { int iret = MetadataUtil :: writeColumnChunkMetadata ( buf , len , blockMetadata ) ; return iret ; } } </DOCUMENT>
<DOCUMENT_ID="tectronics/mysq@@ l-paralle@@ l-replication/tree/master/@@ extra/yass@@ l/taocryp@@ t/src/hash.cpp"> # include " runtime . hpp " # include < string . h > # include < assert . h > # include " hash . hpp " namespace TaoCryp@@ t { HASHwithTransform :: HASHwithTransform ( word32 digSz , word32 buffSz ) { assert ( digSz <= MaxDigestSz ) ; assert ( buffSz <= MaxBufferSz ) ; } void HASHwithTransform :: AddLength ( word32 len ) { HashLengthType tmp = loLen_ ; if ( ( loLen_ += len ) < tmp ) hiLen_ ++ ; hiLen_ += SafeRightShift < 8 * sizeof ( HashLengthType ) > ( len ) ; } void HASHwithTransform :: Update ( const byte * data , word32 len ) { word32 blockSz = getBlockSize ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; while ( len ) { word32 add = min ( len , blockSz - buffLen_ ) ; memcpy ( & local [ buffLen_ ] , data , add ) ; buffLen_ += add ; data += add ; len -= add ; if ( buffLen_ == blockSz ) { ByteReverseIf ( local , local , blockSz , getByteOrder ( ) ) ; Transform ( ) ; AddLength ( blockSz ) ; buffLen_ = 0 ; } } } void HASHwithTransform :: Final ( byte * hash ) { word32 blockSz = getBlockSize ( ) ; word32 digestSz = getDigestSize ( ) ; word32 padSz = getPadSize ( ) ; ByteOrder order = getByteOrder ( ) ; AddLength ( buffLen_ ) ; HashLengthType preLoLen = GetBitCountLo ( ) ; HashLengthType preHiLen = GetBitCountHi ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; local [ buffLen_ ++ ] = 0x80 ; if ( buffLen_ > padSz ) { memset ( & local [ buffLen_ ] , 0 , blockSz - buffLen_ ) ; buffLen_ += blockSz - buffLen_ ; ByteReverseIf ( local , local , blockSz , order ) ; Transform ( ) ; buffLen_ = 0 ; } memset ( & local [ buffLen_ ] , 0 , padSz - buffLen_ ) ; ByteReverseIf ( local , local , blockSz , order ) ; memcpy ( & local [ padSz ] , order ? & preHiLen : & preLoLen , sizeof ( preLoLen ) ) ; memcpy ( & local [ padSz + 4 ] , order ? & preLoLen : & preHiLen , sizeof ( preLoLen ) ) ; Transform ( ) ; ByteReverseIf ( digest_ , digest_ , digestSz , order ) ; memcpy ( hash , digest_ , digestSz ) ; Init ( ) ; } # ifdef WORD64_AVAILABLE HASH64withTransform :: HASH64withTransform ( word32 digSz , word32 buffSz ) { assert ( digSz <= MaxDigestSz ) ; assert ( buffSz <= MaxBufferSz ) ; } void HASH64withTransform :: AddLength ( word32 len ) { HashLengthType tmp = loLen_ ; if ( ( loLen_ += len ) < tmp ) hiLen_ ++ ; hiLen_ += SafeRightShift < 8 * sizeof ( HashLengthType ) > ( len ) ; } void HASH64withTransform :: Update ( const byte * data , word32 len ) { word32 blockSz = getBlockSize ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; while ( len ) { word32 add = min ( len , blockSz - buffLen_ ) ; memcpy ( & local [ buffLen_ ] , data , add ) ; buffLen_ += add ; data += add ; len -= add ; if ( buffLen_ == blockSz ) { ByteReverseIf ( buffer_ , buffer_ , blockSz , getByteOrder ( ) ) ; Transform ( ) ; AddLength ( blockSz ) ; buffLen_ = 0 ; } } } void HASH64withTransform :: Final ( byte * hash ) { word32 blockSz = getBlockSize ( ) ; word32 digestSz = getDigestSize ( ) ; word32 padSz = getPadSize ( ) ; ByteOrder order = getByteOrder ( ) ; AddLength ( buffLen_ ) ; HashLengthType preLoLen = GetBitCountLo ( ) ; HashLengthType preHiLen = GetBitCountHi ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; local [ buffLen_ ++ ] = 0x80 ; if ( buffLen_ > padSz ) { memset ( & local [ buffLen_ ] , 0 , blockSz - buffLen_ ) ; buffLen_ += blockSz - buffLen_ ; ByteReverseIf ( buffer_ , buffer_ , blockSz , order ) ; Transform ( ) ; buffLen_ = 0 ; } memset ( & local [ buffLen_ ] , 0 , padSz - buffLen_ ) ; ByteReverseIf ( buffer_ , buffer_ , padSz , order ) ; buffer_ [ blockSz / sizeof ( word64 ) - 2 ] = order ? preHiLen : preLoLen ; buffer_ [ blockSz / sizeof ( word64 ) - 1 ] = order ? preLoLen : preHiLen ; Transform ( ) ; ByteReverseIf ( digest_ , digest_ , digestSz , order ) ; memcpy ( hash , digest_ , digestSz ) ; Init ( ) ; } # endif } </DOCUMENT>
<DOCUMENT_ID="brask@@ a/tdesk@@ top/tree/master/Telegram@@ /SourceFiles/@@ gui/twidget@@ .cpp"> # include " stdafx . h " # include " application . h " namespace { void _sendResizeEvents ( QWidget * target ) { QResizeEvent e ( target -> size ( ) , QSize ( ) ) ; QApplication :: sendEvent ( target , & e ) ; const QObjectList children = target -> children ( ) ; for ( int i = 0 ; i < children . size ( ) ; ++ i ) { QWidget * child = static_cast < QWidget * > ( children . at ( i ) ) ; if ( child -> isWidgetType ( ) && ! child -> isWindow ( ) && child -> testAttribute ( Qt :: WA_PendingResizeEvent ) ) { _sendResizeEvents ( child ) ; } } } } void myEnsureResized ( QWidget * target ) { if ( target && ( target -> testAttribute ( Qt :: WA_PendingResizeEvent ) || ! target -> testAttribute ( Qt :: WA_WState@@ _Created ) ) ) { _sendResizeEvents ( target ) ; } } QPixmap myGra@@ b ( QWidget * target , const QRect & rect ) { if ( ! cRetina ( ) ) return target -> grab ( rect ) ; myEnsureResized ( target ) ; qreal dpr = App :: app ( ) -> devicePixelRatio ( ) ; QPixmap result ( rect . size ( ) * dpr ) ; result . setDevicePixelRatio ( dpr ) ; result . fill ( Qt :: transparent ) ; target -> render ( & result , QPoint ( ) , QRegion ( rect ) , QWidget :: DrawWindowBackground | QWidget :: DrawChildren | QWidget :: IgnoreMask ) ; return result ; } </DOCUMENT>
<DOCUMENT_ID="zeliard/@@ aws-sdk-cpp/tree/master/aws-cpp-sdk-iam@@ /source/model/ListGroupsRequest.cpp"> # include < aws / iam / model / ListGroupsRequest . h > # include < aws / core / utils / StringUtils . h > # include < aws / core / utils / memory / stl / AWSStringStream . h > using namespace Aws :: IAM :: Model ; using namespace Aws :: Utils ; ListGroupsRequest :: ListGroupsRequest ( ) : m_pathPrefixHasBeenSet ( false ) , m_markerHasBeenSet ( false ) , m_maxItems ( 0 ) , m_maxItemsHasBeenSet ( false ) { } Aws :: String ListGroupsRequest :: SerializePayload ( ) const { Aws :: StringStream ss ; ss << " Action = ListGroups & " ; if ( m_pathPrefixHasBeenSet ) { ss << " PathPrefix = " << StringUtils :: URLEncode ( m_pathPrefix . c_str ( ) ) << " & " ; } if ( m_markerHasBeenSet ) { ss << " Marker = " << StringUtils :: URLEncode ( m_marker . c_str ( ) ) << " & " ; } if ( m_maxItemsHasBeenSet ) { ss << " MaxItems = " << m_maxItems << " & " ; } ss << " Version = 2010-0@@ 5-08" ; return ss . str ( ) ; } </DOCUMENT>
<DOCUMENT_ID="Ed@@ isonCodeKeeper@@ /hacker-rank/tree/master/@@ practice/math@@ ematics/@@ geometr@@ y/meeting-point@@ /meeting-point.cpp"> # include < iostream > # include < vector > # include < algorithm > using namespace std ; # define M 100 bool pair_compare ( const pair < int , long long > & a , const pair < int , long long > & b ) { return a . second == b . second ? a . first < b . first : a . second < b . second ; } int main ( ) { int N ; cin >> N ; vector < pair < long long , long long > > pos ; long long avg_x = 0 , avg_y = 0 ; for ( int i = 0 ; i < N ; ++ i ) { int x , y ; cin >> x >> y ; pos . push_back ( make_pair ( x , y ) ) ; avg_x += x ; avg_y += y ; } avg_x /= N , avg_y /= N ; vector < pair < int , long long > > ans ; for ( int i = 0 ; i < N ; ++ i ) { long long dis = max ( abs ( pos [ i ] . first - avg_x ) , abs ( pos [ i ] . second - avg_y ) ) ; ans . push_back ( make_pair ( i , dis ) ) ; } sort ( ans . begin ( ) , ans . end ( ) , pair_compare ) ; long long ret = 1e16 ; for ( int i = 0 ; i < min ( M , int ( ans . size ( ) ) ) ; ++ i ) { long long tmp = 0 ; for ( int j = 0 ; j < N ; ++ j ) tmp += max ( abs ( pos [ j ] . first - pos [ ans [ i ] . first ] . first ) , abs ( pos [ j ] . second - pos [ ans [ i ] . first ] . second ) ) ; ret = min ( ret , tmp ) ; } cout << ret << endl ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="dy@@ sonlt@@ d/gts/tree/master/app/src/@@ tools/core/components/@@ FloorPlanning.cpp"> # include " Rooms@@ Collection . h " # include " CamerasCollection . h " # include " CameraPositionsCollection . h " # include " CalibrationSchema . h " # include " ExtrinsicCalibrationSchema . h " # include " CameraPositionSchema . h " # include " RoomLayoutSchema . h " # include " FloorPlanSchema . h " # include " CalibrationAlgorithm . h " # include " WbConfigTools . h " # include " WbConfig . h " # include " GroundPlaneUtility . h " # include " OpenCv@@ Utility . h " # include " Robot@@ Metrics . h " # include " CameraCalibration . h " # include " FileUtilities . h " # include " FileDialogs . h " # include " Message . h " # include " Logging . h " # include < QFileDialog > # include < QtGlobal > # include < opencv / cv . h > # include < opencv / highgui . h > # include < iostream > # include < algorithm > namespace FloorPlanning { bool LoadFile ( WbConfig config , KeyId cameraPosition , IplImage * * camImg , QString fileName , CvPoint2D@@ 32f * offset , bool unWarp ) { bool successful = true ; Collection camerasCollection ( CamerasCollection ( ) ) ; Collection cameraPositionsCollection ( CameraPositionsCollection ( ) ) ; camerasCollection . SetConfig ( config ) ; cameraPositionsCollection . SetConfig ( config ) ; const KeyId camPosId = cameraPosition ; LOG_INFO ( QObject :: tr ( " Camera ▁ position ▁ id : ▁ % 1" ) . arg ( camPosId ) ) ; const WbConfig camPosConfig = cameraPositionsCollection . ElementById ( camPosId ) ; if ( camPosConfig . IsNull ( ) ) successful = false ; CvMat * cameraMtx = cvCreateMat ( 3 , 3 , CV_32F ) ; CvMat * distortionCoeffs = cvCreateMat ( 5 , 1 , CV_32F ) ; CvMat * inverseCoeffs = cvCreateMat ( 5 , 1 , CV_32F ) ; CvMat * rot = cvCreateMat ( 3 , 3 , CV_32F ) ; CvMat * trans = cvCreateMat ( 1 , 3 , CV_32F ) ; if ( successful ) { const KeyId camId = camPosConfig . GetKeyValue ( CameraPositionSchema :: cameraIdKey ) . ToKeyId ( ) ; LOG_INFO ( QObject :: tr ( " Camera ▁ id : ▁ % 1" ) . arg ( camId ) ) ; WbConfig cameraConfig = camerasCollection . ElementById ( camId ) ; if ( cameraConfig . IsNull ( ) ) successful = false ; if ( successful ) { const WbConfig cameraIntrisicConfig ( cameraConfig . GetSubConfig ( CalibrationSchema :: schemaName ) ) ; if ( cameraIntrisicConfig . IsNull ( ) ) successful = false ; if ( successful ) { const bool calibrationWasSuccessful = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: calibrationSuccessf@@ ulKey ) . ToBool ( ) ; const bool cameraMtxValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: cameraMatrixKey ) . ToCvMat ( * cameraMtx ) ; const bool distortionCoeffsValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: distortionCoefficientsKey ) . ToCvMat ( * distortionCoeffs ) ; const bool inverseCoeffsValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: invDistortion@@ CoefficientsKey ) . ToCvMat ( * inverseCoeffs ) ; successful = calibrationWasSuccessful && cameraMtxValid && distortionCoeffsValid && inverseCoeffsValid ; } const WbConfig cameraExtrisicConfig ( camPosConfig . GetSubConfig ( ExtrinsicCalibrationSchema :: schemaName ) ) ; if ( cameraExtrisicConfig . IsNull ( ) ) successful = false ; if ( successful ) { const bool rotMatValid = cameraExtrisicConfig . GetKeyValue ( ExtrinsicCalibrationSchema :: rotationMatrixKey ) . ToCvMat ( * rot ) ; const bool transValid = cameraExtrisicConfig . GetKeyValue ( ExtrinsicCalibrationSchema :: translationKey ) . ToCvMat ( * trans ) ; successful = rotMatValid && transValid ; } } } if ( successful ) { IplImage * imgGrey = cvLoadImage ( fileName . toAscii ( ) , CV_LOAD_@@ IMAGE_GRAY@@ SCALE ) ; if ( unWarp ) { * camImg = GroundPlaneUtility :: unwarpGroundPlane ( imgGrey , cameraMtx , distortionCoeffs , inverseCoeffs , rot , trans , offset ) ; } else { * camImg = cvClone@@ Image ( imgGrey ) ; } cvReleaseImage ( & imgGrey ) ; } cvReleaseMat ( & cameraMtx ) ; cvReleaseMat ( & distortionCoeffs ) ; cvReleaseMat ( & inverseCoeffs ) ; cvReleaseMat ( & rot ) ; cvReleaseMat ( & trans ) ; return successful ; } bool CheckMapping@@ IsComplete ( WbConfig config ) { bool allMapped = true ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; bool found = false ; LOG_INFO ( QObject :: tr ( " Checking ▁ mapping ▁ for ▁ % 1 . " ) . arg ( camPosId ) ) ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( ( camPosId == camera1Id ) || ( camPosId == camera2Id ) ) { found = true ; break ; } } if ( ! found ) { allMapped = false ; break ; } } return allMapped ; } bool IsBase ( WbConfig config , KeyId camId ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; bool base = false ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camId == camera1Id ) { base = true ; break ; } } return base ; } bool IsRef ( WbConfig config , KeyId camId ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; bool ref = false ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camId == camera2Id ) { ref = true ; break ; } } return ref ; } std :: vector < KeyId > FindRoot ( WbConfig config ) { std :: vector < KeyId > rootCamera ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; bool root = true ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camPosId == camera2Id ) { root = false ; break ; } } if ( root && IsBase ( config , camPosId ) ) { rootCamera . push_back ( camPosId ) ; } } return rootCamera ; } std :: vector < KeyId > FindChain ( WbConfig config , KeyId camId , KeyId rootId , std :: vector < KeyId > mappingChain ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; LOG_INFO ( QObject :: tr ( " Camera1 ▁ id ▁ = ▁ % 1 . " ) . arg ( camera1Id ) ) ; LOG_INFO ( QObject :: tr ( " Camera2 ▁ id ▁ = ▁ % 1 . " ) . arg ( camera2Id ) ) ; if ( camId == camera2Id ) { if ( std :: find ( mappingChain . begin ( ) , mappingChain . end ( ) , camera1Id ) == mappingChain . end ( ) ) { mappingChain . push_back ( camera1Id ) ; if ( camera1Id != rootId ) { LOG_INFO ( QObject :: tr ( " Find ▁ chain ▁ for ▁ % 1 ▁ - ▁ % 2 . " ) . arg ( camera1Id ) . arg ( rootId ) ) ; mappingChain = FindChain ( config , camera1Id , rootId , mappingChain ) ; } if ( mappingChain . back ( ) == rootId ) { LOG_INFO ( " Found . " ) ; break ; } else { mappingChain . pop_back ( ) ; } } } } return mappingChain ; } bool CheckRoot@@ Mapping ( WbConfig config , KeyId rootId ) { bool allMapped = true ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; if ( ( camPosId != rootId ) && IsRef ( config , camPosId ) ) { LOG_INFO ( QObject :: tr ( " Find ▁ chain ▁ for ▁ % 1 ▁ - ▁ % 2 . " ) . arg ( camPosId ) . arg ( rootId ) ) ; std :: vector < KeyId > chain = FindChain ( config , camPosId , rootId , std :: vector < KeyId > ( ) ) ; if ( chain . size ( ) == 0 ) { LOG_INFO ( " Not ▁ found . " ) ; allMapped = false ; break ; } } } return allMapped ; } void ComputeTransform ( WbConfig config , KeyId refId , std :: vector < KeyId > chain , CvMat * transform ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( std :: vector < KeyId > :: iterator elt = chain . begin ( ) ; elt != chain . end ( ) ; ++ elt ) { for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( ( camera1Id == * elt ) && ( camera2Id == refId ) ) { CvMat * homography = cvCreateMat ( 3 , 3 , CV_32F ) ; const bool homographyValid = config . GetKeyValue ( FloorPlanSchema :: homographyKey , it -> id ) . ToCvMat ( * homography ) ; Q_UNUSED ( homographyValid ) ; CvMat * tmp = cvCreateMat ( 3 , 3 , CV_32F ) ; cvMatMul ( homography , transform , tmp ) ; cvmSet ( transform , 0 , 0 , cvmGet ( tmp , 0 , 0 ) ) ; cvmSet ( transform , 0 , 1 , cvmGet ( tmp , 0 , 1 ) ) ; cvmSet ( transform , 0 , 2 , cvmGet ( tmp , 0 , 2 ) ) ; cvmSet ( transform , 1 , 0 , cvmGet ( tmp , 1 , 0 ) ) ; cvmSet ( transform , 1 , 1 , cvmGet ( tmp , 1 , 1 ) ) ; cvmSet ( transform , 1 , 2 , cvmGet ( tmp , 1 , 2 ) ) ; cvmSet ( transform , 2 , 0 , cvmGet ( tmp , 2 , 0 ) ) ; cvmSet ( transform , 2 , 1 , cvmGet ( tmp , 2 , 1 ) ) ; cvmSet ( transform , 2 , 2 , cvmGet ( tmp , 2 , 2 ) ) ; cvReleaseMat ( & tmp ) ; cvReleaseMat ( & homography ) ; refId = * elt ; } } } } } </DOCUMENT>
<DOCUMENT_ID="hkernb@@ ach/arangodb/tree/master/3rdParty/boost/1.62.0/libs/phoenix/test/include@@ /core/visit_each@@ .cpp"> # include < boost / phoenix / core / visit_each . hpp > int main ( ) { } </DOCUMENT>
<DOCUMENT_ID="Vo@@ yager1/xbmc/tree/master/xbmc/@@ windowing/r@@ pi/GLContext@@ EGL.cpp"> # include " GLContextEGL . h " # include " guilib / IDirtyRegi@@ onSolver . h " # include " settings / AdvancedSettings . h " # include " utils / log . h " CGLContextEGL :: CGLContextEGL ( ) : m_eglDisplay ( EGL_NO_DISPLAY ) , m_eglSurface ( EGL_NO_SURFACE ) , m_eglContext ( EGL_NO_CONTEXT ) , m_eglConfig ( 0 ) { } CGLContextEGL :: ~ CGLContextEGL ( ) { Destroy ( ) ; } bool CGLContextEGL :: CreateDisplay ( EGLDisplay display , EGLint renderable_type , EGLint rendering_api ) { EGLint neglconfigs = 0 ; int major , minor ; EGLint surface_type = EGL_WINDOW_@@ BIT ; if ( g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION || g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION ) surface_type |= EGL_SWAP_BEHAVIOR_@@ PRESERV@@ ED_BIT ; EGLint attribs [ ] = { EGL_RED@@ _SIZE , 8 , EGL_GRE@@ EN_SIZE , 8 , EGL_BL@@ UE_SIZE , 8 , EGL_ALPH@@ A_SIZE , 8 , EGL_DEP@@ TH_SIZE , 16 , EGL_STENCI@@ L_SIZE , 0 , EGL_SAMPLE_BUFFERS , 0 , EGL_SAMPLES , 0 , EGL_SURFACE_@@ TYPE , surface_type , EGL_RENDER@@ ABLE_TYPE , renderable_type , EGL_NONE } ; if ( m_eglDisplay == EGL_NO_DISPLAY ) { m_eglDisplay = eglGetDisplay ( ( EGLNativeDisplayType ) display ) ; } if ( m_eglDisplay == EGL_NO_DISPLAY ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ get ▁ EGL ▁ display " ) ; return false ; } if ( ! eglInitialize ( m_eglDisplay , & major , & minor ) ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ initialize ▁ EGL ▁ display " ) ; return false ; } eglBindAPI ( rendering_api ) ; if ( ! eglChoo@@ seConfig ( m_eglDisplay , attribs , & m_eglConfig , 1 , & neglconfigs ) ) { CLog :: Log ( LOGERROR , " Failed ▁ to ▁ query ▁ number ▁ of ▁ EGL ▁ configs " ) ; return false ; } if ( neglconfigs <= 0 ) { CLog :: Log ( LOGERROR , " No ▁ suitable ▁ EGL ▁ configs ▁ found " ) ; return false ; } return true ; } bool CGLContextEGL :: CreateContext ( ) { int client_version = 2 ; const EGLint context_attribs [ ] = { EGL_CONTEXT_@@ CLIENT_VERSION , client_version , EGL_NONE } ; if ( m_eglContext == EGL_NO_CONTEXT ) { m_eglContext = eglCreateContext ( m_eglDisplay , m_eglConfig , EGL_NO_CONTEXT , context_attribs ) ; } if ( m_eglContext == EGL_NO_CONTEXT ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ create ▁ EGL ▁ context " ) ; return false ; } return true ; } bool CGLContextEGL :: BindContext ( ) { if ( ! eglMakeCurrent ( m_eglDisplay , m_eglSurface , m_eglSurface , m_eglContext ) ) { CLog :: Log ( LOGERROR , " Failed ▁ to ▁ make ▁ context ▁ current ▁ % p ▁ % p ▁ % p " , m_eglDisplay , m_eglSurface , m_eglContext ) ; return false ; } return true ; } bool CGLContextEGL :: SurfaceAttrib ( ) { if ( g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION || g_advancedSettings . m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION ) { if ( ( m_eglDisplay == EGL_NO_DISPLAY ) || ( m_eglSurface == EGL_NO_SURFACE ) ) { return false ; } if ( ! eglSurfaceAttrib ( m_eglDisplay , m_eglSurface , EGL_SWAP_BEHAVIOR , EGL_BUFFER_@@ PRESERVED ) ) { CLog :: Log ( LOGDEBUG , " % s : ▁ Could ▁ not ▁ set ▁ EGL _ SWAP _ BEHAVIOR " , __FUNCTION__ ) ; } } return true ; } bool CGLContextEGL :: CreateSurface ( EGLNativeWindowType surface ) { m_eglSurface = eglCreateWindow@@ Surface ( m_eglDisplay , m_eglConfig , surface , nullptr ) ; if ( m_eglSurface == EGL_NO_SURFACE ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ create ▁ EGL ▁ window ▁ surface ▁ % d " , eglGetError ( ) ) ; return false ; } return true ; } void CGLContextEGL :: Destroy ( ) { if ( m_eglContext != EGL_NO_CONTEXT ) { eglDestroyContext ( m_eglDisplay , m_eglContext ) ; eglMakeCurrent ( m_eglDisplay , EGL_NO_SURFACE , EGL_NO_SURFACE , EGL_NO_CONTEXT ) ; m_eglContext = EGL_NO_CONTEXT ; } if ( m_eglSurface != EGL_NO_SURFACE ) { eglDestroySurface ( m_eglDisplay , m_eglSurface ) ; m_eglSurface = EGL_NO_SURFACE ; } if ( m_eglDisplay != EGL_NO_DISPLAY ) { eglTerminate ( m_eglDisplay ) ; m_eglDisplay = EGL_NO_DISPLAY ; } } void CGLContextEGL :: Detach ( ) { if ( m_eglContext != EGL_NO_CONTEXT ) { eglMakeCurrent ( m_eglDisplay , EGL_NO_SURFACE , EGL_NO_SURFACE , EGL_NO_CONTEXT ) ; } if ( m_eglSurface != EGL_NO_SURFACE ) { eglDestroySurface ( m_eglDisplay , m_eglSurface ) ; m_eglSurface = EGL_NO_SURFACE ; } } bool CGLContextEGL :: SetVSync ( bool enable ) { if ( ! eglSwapInterval ( m_eglDisplay , enable ) ) { return false ; } return true ; } void CGLContextEGL :: SwapBuffers ( ) { if ( m_eglDisplay == EGL_NO_DISPLAY || m_eglSurface == EGL_NO_SURFACE ) { return ; } eglSwapBuffers ( m_eglDisplay , m_eglSurface ) ; } </DOCUMENT>
<DOCUMENT_ID="rlewis@@ 1988@@ /lean/tree/master/src/library@@ /tactic@@ /smt/util.cpp"> # include " library / annotation . h " # include " library / util . h " # include " library / replace _ visitor . h " # include " library / vm / vm . h " # include " library / tactic / smt / congruence _ closure . h " namespace lean { static name * g_cc_proof_name = nullptr ; static macro_definition * g_cc_proof_macro = nullptr ; class cc_proof_macro_cell : public macro_definition_cell { public : virtual name get_name ( ) const { return * g_cc_proof_name ; } virtual expr check_type ( expr const & e , abstract_type_context & ctx , bool ) const { return mk_eq ( ctx , macro_arg ( e , 0 ) , macro_arg ( e , 1 ) ) ; } virtual optional < expr > expand ( expr const & , abstract_type_context & ) const { lean_unreachable ( ) ; } virtual void write ( serializer & ) const { lean_unreachable ( ) ; } virtual bool operator == ( macro_definition_cell const & other ) const { cc_proof_macro_cell const * other_ptr = dynamic_cast < cc_proof_macro_cell const * > ( & other ) ; return other_ptr ; } virtual unsigned hash ( ) const { return 23 ; } } ; expr mk_delayed_cc_eq_proof ( expr const & e1 , expr const & e2 ) { expr args [ 2 ] = { e1 , e2 } ; return mk_macro ( * g_cc_proof_macro , 2 , args ) ; } bool is_delayed_cc_eq_proof ( expr const & e ) { return is_macro ( e ) && dynamic_cast < cc_proof_macro_cell const * > ( macro_def ( e ) . raw ( ) ) ; } static name * g_theory_proof = nullptr ; expr mark_cc_theory_proof ( expr const & pr ) { return mk_annotation ( * g_theory_proof , pr ) ; } bool is_cc_theory_proof ( expr const & e ) { return is_annotation ( e , * g_theory_proof ) ; } expr get_cc_@@ theory_proof_arg ( expr const & pr ) { lean_assert ( is_cc_theory_proof ( pr ) ) ; return get_annot@@ ation_arg ( pr ) ; } class expand_delayed_cc_proofs_fn : public replace_visitor { congruence_closure const & m_cc ; expr visit_macro ( expr const & e ) { if ( is_delayed_cc_eq_proof ( e ) ) { expr const & lhs = macro_arg ( e , 0 ) ; expr const & rhs = macro_arg ( e , 1 ) ; return * m_cc . get_eq_proof ( lhs , rhs ) ; } else { return replace_visitor :: visit_macro ( e ) ; } } public : expand_delayed_cc_proofs_fn ( congruence_closure const & cc ) : m_cc ( cc ) { } } ; expr expand_delayed_cc_proofs ( congruence_closure const & cc , expr const & e ) { return expand_delayed_cc_proofs_fn ( cc ) ( e ) ; } void initialize_smt_util ( ) { g_cc_proof_name = new name ( " cc _ proof " ) ; g_cc_proof_macro = new macro_definition ( new cc_proof_macro_cell ( ) ) ; g_theory_proof = new name ( " th _ proof " ) ; register_annotation ( * g_theory_proof ) ; } void finalize_smt_util ( ) { delete g_cc_proof_macro ; delete g_cc_proof_name ; delete g_theory_proof ; } } </DOCUMENT>
<DOCUMENT_ID="sunbli@@ the/qt@@ -every@@ where-open@@ source-src-@@ 4.7.1/tree/master/src/gui/@@ kernel/qeventdispatcher_x11@@ .cpp"> # include " qeventdispatcher _ x11 _ p . h " # include " qapplication . h " # include " qx11info _ x11 . h " # include " qt _ x11 _ p . h " # include < private / qeventdispatcher_unix@@ _p . h > QT_BEGIN_NAMESPACE class QEventDispatcherX11Private : public QEventDispatcherUNIXPrivate { Q_DECLARE_@@ PUBLI@@ C ( QEventDispatcherX11 ) public : inline QEventDispatcherX11Private ( ) : xfd ( - 1 ) { } int xfd ; QList < XEvent > queuedUserInputEvents ; } ; QEventDispatcherX11 :: QEventDispatcherX11 ( QObject * parent ) : QEventDispatcherUNIX ( * new QEventDispatcherX11Private , parent ) { } QEventDispatcherX11 :: ~ QEventDispatcherX11 ( ) { } bool QEventDispatcherX11 :: processEvents ( QEventLoop :: ProcessEvents@@ Flags flags ) { Q_D ( QEventDispatcherX11 ) ; d -> interrupt = false ; QApplication :: sendPostedEvents ( ) ; ulong marker = XNextRequest ( X11 -> display ) ; int nevents = 0 ; do { while ( ! d -> interrupt ) { XEvent event ; if ( ! ( flags & QEventLoop :: ExcludeUserInputEvents ) && ! d -> queuedUserInputEvents . isEmpty ( ) ) { event = d -> queuedUserInputEvents . takeFirst ( ) ; } else if ( XEventsQueued ( X11 -> display , QueuedAlready ) ) { XNextEvent ( X11 -> display , & event ) ; if ( flags & QEventLoop :: ExcludeUserInputEvents ) { switch ( event . type ) { case ButtonPress : case ButtonRelease : case MotionNotify : case XKeyPress : case XKeyRelease : case EnterNotify : case LeaveNotify : d -> queuedUserInputEvents . append ( event ) ; continue ; case ClientMessage : if ( event . xclient . format == 32 ) { if ( event . xclient . message_type == ATOM ( WM_PROTO@@ COLS ) && ( Atom ) event . xclient . data . l [ 0 ] == ATOM ( WM_TAKE_@@ FOCUS ) ) { break ; } else if ( event . xclient . message_type == ATOM ( _QT_SCROLL_@@ DONE ) ) { break ; } } d -> queuedUserInputEvents . append ( event ) ; continue ; default : break ; } } } else { break ; } if ( filterEvent ( & event ) ) continue ; nevents ++ ; if ( qApp -> x11ProcessEvent ( & event ) == 1 ) return true ; if ( event . xany . serial >= marker ) { if ( XEventsQueued ( X11 -> display , QueuedAfterFlush ) ) flags &= ~ QEventLoop :: WaitForMoreEvents ; goto out ; } } } while ( ! d -> interrupt && XEventsQueued ( X11 -> display , QueuedAfterFlush ) ) ; out : if ( ! d -> interrupt ) { const uint exclude_all = QEventLoop :: ExcludeSocketNoti@@ fiers | QEventLoop :: X11Exclude@@ Timers | QEventLoop :: WaitForMoreEvents ; if ( nevents > 0 && ( ( uint ) flags & exclude_all ) == exclude_all ) { QApplication :: sendPostedEvents ( ) ; return nevents > 0 ; } return QEventDispatcherUNIX :: processEvents ( flags ) || ( nevents > 0 ) ; } return nevents > 0 ; } bool QEventDispatcherX11 :: hasPending@@ Events ( ) { extern uint qGlobalPostedEventsCount ( ) ; return ( qGlobalPostedEventsCount ( ) || XPending ( X11 -> display ) ) ; } void QEventDispatcherX11 :: flush ( ) { XFlush ( X11 -> display ) ; } void QEventDispatcherX11 :: startingUp ( ) { Q_D ( QEventDispatcherX11 ) ; d -> xfd = XConnectionNumber ( X11 -> display ) ; } void QEventDispatcherX11 :: closingDown ( ) { Q_D ( QEventDispatcherX11 ) ; d -> xfd = - 1 ; } int QEventDispatcherX11 :: select ( int nfds , fd_set * readfds , fd_set * writefds , fd_set * exceptfds , timeval * timeout ) { Q_D ( QEventDispatcherX11 ) ; if ( d -> xfd > 0 ) { nfds = qMax ( nfds - 1 , d -> xfd ) + 1 ; FD_SET ( d -> xfd , readfds ) ; } return QEventDispatcherUNIX :: select ( nfds , readfds , writefds , exceptfds , timeout ) ; } QT_END_NAMESPACE </DOCUMENT>
<DOCUMENT_ID="braingl/@@ braingl/tree/master/src/@@ algos/sd@@ thread.cpp"> # include " sdthread . h " # include " . . / data / datasets / datasetdwi . h " # include " . . / gui / gl / glfunctions . h " SDThread :: SDThread ( DatasetDW@@ I * ds , int id ) : m_dataset ( ds ) , m_id ( id ) { m_dwi = ds -> getData ( ) ; m_bvals = ds -> getBvals ( ) ; m_bvecs = ds -> getBvecs ( ) ; int nx = ds -> properties ( " maingl " ) . get ( Fn :: Property :: D_NX ) . toInt ( ) ; int ny = ds -> properties ( " maingl " ) . get ( Fn :: Property :: D_NY ) . toInt ( ) ; int nz = ds -> properties ( " maingl " ) . get ( Fn :: Property :: D_NZ ) . toInt ( ) ; m_blockSize = nx * ny * nz ; } SDThread :: ~ SDThread ( ) { } void SDThread :: run ( ) { int numThreads = GLFunctions :: idealThread@@ Count ; int progressCounter = 0 ; for ( int i = m_id ; i < m_blockSize ; i += numThreads ) { calcSD ( i ) ; ++ progressCounter ; if ( progressCounter == 100 ) { emit ( progress ( ) ) ; progressCounter = 0 ; } } emit ( finished ( ) ) ; } ColumnVector SDThread :: calcSD ( int id ) { return ColumnVector ( 20 ) ; } </DOCUMENT>
<DOCUMENT_ID="hoangt/g@@ oblin@@ -core/tree/master/risc@@ v/llvm/@@ 3.5/llvm-@@ 3.5.@@ 0.src/lib/Target/Mips/MipsSE@@ FrameLowering.cpp"> # include " MipsSEFrameLowering . h " # include " MCTargetDesc / MipsBase@@ Info . h " # include " MipsAnaly@@ zeImmediate . h " # include " MipsMachineFunction . h " # include " MipsSEInstrInfo . h " # include " MipsSubtarget . h " # include " llvm / CodeGen / MachineFrameInfo . h " # include " llvm / CodeGen / MachineFunction . h " # include " llvm / CodeGen / MachineInstr@@ Builder . h " # include " llvm / CodeGen / MachineModuleInfo . h " # include " llvm / CodeGen / MachineRegisterInfo . h " # include " llvm / CodeGen / RegisterScaveng@@ ing . h " # include " llvm / IR / DataLayout . h " # include " llvm / IR / Function . h " # include " llvm / Support / CommandLine . h " # include " llvm / Target / TargetOptions . h " using namespace llvm ; namespace { typedef MachineBasicBlock :: iterator Iter ; static std :: pair < unsigned , unsigned > getMFHiLoOpc ( unsigned Src ) { if ( Mips :: ACC64RegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: PseudoMFHI , ( unsigned ) Mips :: PseudoMFLO ) ; if ( Mips :: ACC64DSP@@ RegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: MFHI_DSP , ( unsigned ) Mips :: MFLO_DSP ) ; if ( Mips :: ACC128@@ RegClass . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mips :: PseudoMFHI64 , ( unsigned ) Mips :: PseudoMFLO64 ) ; return std :: make_pair ( 0 , 0 ) ; } class ExpandPseudo { public : ExpandPseudo ( MachineFunction & MF ) ; bool expand ( ) ; private : bool expandInstr ( MachineBasicBlock & MBB , Iter I ) ; void expandLoadCCond ( MachineBasicBlock & MBB , Iter I ) ; void expandStoreCCond ( MachineBasicBlock & MBB , Iter I ) ; void expandLoadACC ( MachineBasicBlock & MBB , Iter I , unsigned RegSize ) ; void expandStoreACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc , unsigned RegSize ) ; bool expandCopy ( MachineBasicBlock & MBB , Iter I ) ; bool expandCopyACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc ) ; bool expandBuildPairF64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool FP64 ) const ; bool expandExtractElementF64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool FP64 ) const ; MachineFunction & MF ; MachineRegisterInfo & MRI ; } ; } ExpandPseudo :: ExpandPseudo ( MachineFunction & MF_ ) : MF ( MF_ ) , MRI ( MF . getRegInfo ( ) ) { } bool ExpandPseudo :: expand ( ) { bool Expanded = false ; for ( MachineFunction :: iterator BB = MF . begin ( ) , BBEnd = MF . end ( ) ; BB != BBEnd ; ++ BB ) for ( Iter I = BB -> begin ( ) , End = BB -> end ( ) ; I != End ; ) Expanded |= expandInstr ( * BB , I ++ ) ; return Expanded ; } bool ExpandPseudo :: expandInstr ( MachineBasicBlock & MBB , Iter I ) { switch ( I -> getOpcode ( ) ) { case Mips :: LOAD_CCOND_DSP : expandLoadCCond ( MBB , I ) ; break ; case Mips :: STORE_CCOND_DSP : expandStoreCCond ( MBB , I ) ; break ; case Mips :: LOAD_ACC64 : case Mips :: LOAD_ACC64DSP : expandLoadACC ( MBB , I , 4 ) ; break ; case Mips :: LOAD_ACC128 : expandLoadACC ( MBB , I , 8 ) ; break ; case Mips :: STORE_ACC64 : expandStoreACC ( MBB , I , Mips :: PseudoMFHI , Mips :: PseudoMFLO , 4 ) ; break ; case Mips :: STORE_ACC64DSP : expandStoreACC ( MBB , I , Mips :: MFHI_DSP , Mips :: MFLO_DSP , 4 ) ; break ; case Mips :: STORE_ACC128 : expandStoreACC ( MBB , I , Mips :: PseudoMFHI64 , Mips :: PseudoMFLO64 , 8 ) ; break ; case Mips :: BuildPairF64 : if ( expandBuildPairF64 ( MBB , I , false ) ) MBB . erase ( I ) ; return false ; case Mips :: BuildPairF64_64 : if ( expandBuildPairF64 ( MBB , I , true ) ) MBB . erase ( I ) ; return false ; case Mips :: ExtractElementF64 : if ( expandExtractElementF64 ( MBB , I , false ) ) MBB . erase ( I ) ; return false ; case Mips :: ExtractElementF64_64 : if ( expandExtractElementF64 ( MBB , I , true ) ) MBB . erase ( I ) ; return false ; case TargetOpcode :: COPY : if ( ! expandCopy ( MBB , I ) ) return false ; break ; default : return false ; } MBB . erase ( I ) ; return true ; } void ExpandPseudo :: expandLoadCCond ( MachineBasicBlock & MBB , Iter I ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( 4 ) ; unsigned VR = MRI . createVirtualRegister ( RC ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; TII . loadRegFromStack ( MBB , I , VR , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , I -> getDebugLoc ( ) , TII . get ( TargetOpcode :: COPY ) , Dst ) . addReg ( VR , RegState :: Kill ) ; } void ExpandPseudo :: expandStoreCCond ( MachineBasicBlock & MBB , Iter I ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( 4 ) ; unsigned VR = MRI . createVirtualRegister ( RC ) ; unsigned Src = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; BuildMI ( MBB , I , I -> getDebugLoc ( ) , TII . get ( TargetOpcode :: COPY ) , VR ) . addReg ( Src , getKillRegState ( I -> getOperand ( 0 ) . isKill ( ) ) ) ; TII . storeRegToStack ( MBB , I , VR , true , FI , RC , & RegInfo , 0 ) ; } void ExpandPseudo :: expandLoadACC ( MachineBasicBlock & MBB , Iter I , unsigned RegSize ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( RegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; unsigned Lo = RegInfo . getSubReg ( Dst , Mips :: sub_lo ) ; unsigned Hi = RegInfo . getSubReg ( Dst , Mips :: sub_hi ) ; DebugLoc DL = I -> getDebugLoc ( ) ; const MCInstrDesc & Desc = TII . get ( TargetOpcode :: COPY ) ; TII . loadRegFromStack ( MBB , I , VR0 , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , DL , Desc , Lo ) . addReg ( VR0 , RegState :: Kill ) ; TII . loadRegFromStack ( MBB , I , VR1 , FI , RC , & RegInfo , RegSize ) ; BuildMI ( MBB , I , DL , Desc , Hi ) . addReg ( VR1 , RegState :: Kill ) ; } void ExpandPseudo :: expandStoreACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc , unsigned RegSize ) { assert ( I -> getOperand ( 0 ) . isReg ( ) && I -> getOperand ( 1 ) . isFI ( ) ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; const TargetRegisterClass * RC = RegInfo . intRegClass ( RegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned Src = I -> getOperand ( 0 ) . getReg ( ) , FI = I -> getOperand ( 1 ) . getIndex ( ) ; unsigned SrcKill = getKillRegState ( I -> getOperand ( 0 ) . isKill ( ) ) ; DebugLoc DL = I -> getDebugLoc ( ) ; BuildMI ( MBB , I , DL , TII . get ( MFLoOpc ) , VR0 ) . addReg ( Src ) ; TII . storeRegToStack ( MBB , I , VR0 , true , FI , RC , & RegInfo , 0 ) ; BuildMI ( MBB , I , DL , TII . get ( MFHiOpc ) , VR1 ) . addReg ( Src , SrcKill ) ; TII . storeRegToStack ( MBB , I , VR1 , true , FI , RC , & RegInfo , RegSize ) ; } bool ExpandPseudo :: expandCopy ( MachineBasicBlock & MBB , Iter I ) { unsigned Src = I -> getOperand ( 1 ) . getReg ( ) ; std :: pair < unsigned , unsigned > Opcodes = getMFHiLoOpc ( Src ) ; if ( ! Opcodes . first ) return false ; return expandCopyACC ( MBB , I , Opcodes . first , Opcodes . second ) ; } bool ExpandPseudo :: expandCopyACC ( MachineBasicBlock & MBB , Iter I , unsigned MFHiOpc , unsigned MFLoOpc ) { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , Src = I -> getOperand ( 1 ) . getReg ( ) ; unsigned VRegSize = RegInfo . getMinimalPhysRegClass ( Dst ) -> getSize ( ) / 2 ; const TargetRegisterClass * RC = RegInfo . intRegClass ( VRegSize ) ; unsigned VR0 = MRI . createVirtualRegister ( RC ) ; unsigned VR1 = MRI . createVirtualRegister ( RC ) ; unsigned SrcKill = getKillRegState ( I -> getOperand ( 1 ) . isKill ( ) ) ; unsigned DstLo = RegInfo . getSubReg ( Dst , Mips :: sub_lo ) ; unsigned DstHi = RegInfo . getSubReg ( Dst , Mips :: sub_hi ) ; DebugLoc DL = I -> getDebugLoc ( ) ; BuildMI ( MBB , I , DL , TII . get ( MFLoOpc ) , VR0 ) . addReg ( Src ) ; BuildMI ( MBB , I , DL , TII . get ( TargetOpcode :: COPY ) , DstLo ) . addReg ( VR0 , RegState :: Kill ) ; BuildMI ( MBB , I , DL , TII . get ( MFHiOpc ) , VR1 ) . addReg ( Src , SrcKill ) ; BuildMI ( MBB , I , DL , TII . get ( TargetOpcode :: COPY ) , DstHi ) . addReg ( VR1 , RegState :: Kill ) ; return true ; } bool ExpandPseudo :: expandBuildPairF64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool FP64 ) const { const TargetMachine & TM = MF . getTarget ( ) ; const MipsSubtarget & Subtarget = TM . getSubtarget < MipsSubtarget > ( ) ; if ( ( Subtarget . isABI_FPXX ( ) && ! Subtarget . hasMTHC1 ( ) ) || ( FP64 && ! Subtarget . useOddSPReg ( ) ) ) { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( TM . getInstrInfo ( ) ) ; const MipsRegisterInfo & TRI = * static_cast < const MipsRegisterInfo * > ( TM . getRegisterInfo ( ) ) ; unsigned DstReg = I -> getOperand ( 0 ) . getReg ( ) ; unsigned LoReg = I -> getOperand ( 1 ) . getReg ( ) ; unsigned HiReg = I -> getOperand ( 2 ) . getReg ( ) ; assert ( Subtarget . isGP64bit ( ) || Subtarget . hasMTHC1 ( ) || ! Subtarget . isFP64bit ( ) ) ; const TargetRegisterClass * RC = & Mips :: GPR32RegClass ; const TargetRegisterClass * RC2 = FP64 ? & Mips :: FGR64RegClass : & Mips :: AFGR64RegClass ; int FI = MF . getInfo < MipsFunctionInfo > ( ) -> getMoveF64ViaSpillFI ( RC2 ) ; TII . storeRegToStack ( MBB , I , LoReg , I -> getOperand ( 1 ) . isKill ( ) , FI , RC , & TRI , 0 ) ; TII . storeRegToStack ( MBB , I , HiReg , I -> getOperand ( 2 ) . isKill ( ) , FI , RC , & TRI , 4 ) ; TII . loadRegFromStack ( MBB , I , DstReg , FI , RC2 , & TRI , 0 ) ; return true ; } return false ; } bool ExpandPseudo :: expandExtractElementF64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool FP64 ) const { const TargetMachine & TM = MF . getTarget ( ) ; const MipsSubtarget & Subtarget = TM . getSubtarget < MipsSubtarget > ( ) ; if ( ( Subtarget . isABI_FPXX ( ) && ! Subtarget . hasMTHC1 ( ) ) || ( FP64 && ! Subtarget . useOddSPReg ( ) ) ) { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( TM . getInstrInfo ( ) ) ; const MipsRegisterInfo & TRI = * static_cast < const MipsRegisterInfo * > ( TM . getRegisterInfo ( ) ) ; unsigned DstReg = I -> getOperand ( 0 ) . getReg ( ) ; unsigned SrcReg = I -> getOperand ( 1 ) . getReg ( ) ; unsigned N = I -> getOperand ( 2 ) . getImm ( ) ; assert ( Subtarget . isGP64bit ( ) || Subtarget . hasMTHC1 ( ) || ! Subtarget . isFP64bit ( ) ) ; const TargetRegisterClass * RC = FP64 ? & Mips :: FGR64RegClass : & Mips :: AFGR64RegClass ; const TargetRegisterClass * RC2 = & Mips :: GPR32RegClass ; int FI = MF . getInfo < MipsFunctionInfo > ( ) -> getMoveF64ViaSpillFI ( RC ) ; TII . storeRegToStack ( MBB , I , SrcReg , I -> getOperand ( 1 ) . isKill ( ) , FI , RC , & TRI , 0 ) ; TII . loadRegFromStack ( MBB , I , DstReg , FI , RC2 , & TRI , N * 4 ) ; return true ; } return false ; } MipsSEFrameLowering :: MipsSEFrameLowering ( const MipsSubtarget & STI ) : MipsFrameLowering ( STI , STI . stackAlignment ( ) ) { } unsigned MipsSEFrameLowering :: ehDataReg ( unsigned I ) const { static const unsigned EhDataReg [ ] = { Mips :: A0 , Mips :: A1 , Mips :: A2 , Mips :: A3 } ; static const unsigned EhDataReg64 [ ] = { Mips :: A0_64 , Mips :: A1_64 , Mips :: A2_64 , Mips :: A3_64 } ; return STI . isABI_N64 ( ) ? EhDataReg64 [ I ] : EhDataReg [ I ] ; } void MipsSEFrameLowering :: emitPrologue ( MachineFunction & MF ) const { MachineBasicBlock & MBB = MF . front ( ) ; MachineFrameInfo * MFI = MF . getFrameInfo ( ) ; MipsFunctionInfo * MipsFI = MF . getInfo < MipsFunctionInfo > ( ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; MachineBasicBlock :: iterator MBBI = MBB . begin ( ) ; DebugLoc dl = MBBI != MBB . end ( ) ? MBBI -> getDebugLoc ( ) : DebugLoc ( ) ; unsigned SP = STI . isABI_N64 ( ) ? Mips :: SP_64 : Mips :: SP ; unsigned FP = STI . isABI_N64 ( ) ? Mips :: FP_64 : Mips :: FP ; unsigned ZERO = STI . isABI_N64 ( ) ? Mips :: ZERO_64 : Mips :: ZERO ; unsigned ADDu = STI . isABI_N64 ( ) ? Mips :: DADDu : Mips :: ADDu ; uint64_t StackSize = MFI -> getStackSize ( ) ; if ( StackSize == 0 && ! MFI -> adjustsStack ( ) ) return ; MachineModuleInfo & MMI = MF . getMMI ( ) ; const MCRegisterInfo * MRI = MMI . getContext ( ) . getRegisterInfo ( ) ; MachineLocation DstML , SrcML ; TII . adjustStackPtr ( SP , - StackSize , MBB , MBBI ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createDefCfaOffset ( nullptr , - StackSize ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; const std :: vector < CalleeSavedInfo > & CSI = MFI -> getCalleeSavedInfo ( ) ; if ( CSI . size ( ) ) { for ( unsigned i = 0 ; i < CSI . size ( ) ; ++ i ) ++ MBBI ; for ( std :: vector < CalleeSavedInfo > :: const_iterator I = CSI . begin ( ) , E = CSI . end ( ) ; I != E ; ++ I ) { int64_t Offset = MFI -> getObjectOffset ( I -> getFrameIdx ( ) ) ; unsigned Reg = I -> getReg ( ) ; if ( Mips :: AFGR64RegClass . contains ( Reg ) ) { unsigned Reg0 = MRI -> getDwarfRegNum ( RegInfo . getSubReg ( Reg , Mips :: sub_lo ) , true ) ; unsigned Reg1 = MRI -> getDwarfRegNum ( RegInfo . getSubReg ( Reg , Mips :: sub_hi ) , true ) ; if ( ! STI . isLittle ( ) ) std :: swap ( Reg0 , Reg1 ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg0 , Offset ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg1 , Offset + 4 ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } else if ( Mips :: FGR64RegClass . contains ( Reg ) ) { unsigned Reg0 = MRI -> getDwarfRegNum ( Reg , true ) ; unsigned Reg1 = MRI -> getDwarfRegNum ( Reg , true ) + 1 ; if ( ! STI . isLittle ( ) ) std :: swap ( Reg0 , Reg1 ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg0 , Offset ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg1 , Offset + 4 ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } else { unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , MRI -> getDwarfRegNum ( Reg , 1 ) , Offset ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } } } if ( MipsFI -> callsEhReturn ( ) ) { const TargetRegisterClass * RC = STI . isABI_N64 ( ) ? & Mips :: GPR64RegClass : & Mips :: GPR32RegClass ; for ( int I = 0 ; I < 4 ; ++ I ) { if ( ! MBB . isLiveIn ( ehDataReg ( I ) ) ) MBB . addLiveIn ( ehDataReg ( I ) ) ; TII . storeRegToStackSlot ( MBB , MBBI , ehDataReg ( I ) , false , MipsFI -> getEhDataRegFI ( I ) , RC , & RegInfo ) ; } for ( int I = 0 ; I < 4 ; ++ I ) { int64_t Offset = MFI -> getObjectOffset ( MipsFI -> getEhDataRegFI ( I ) ) ; unsigned Reg = MRI -> getDwarfRegNum ( ehDataReg ( I ) , true ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createOffset ( nullptr , Reg , Offset ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } } if ( hasFP ( MF ) ) { BuildMI ( MBB , MBBI , dl , TII . get ( ADDu ) , FP ) . addReg ( SP ) . addReg ( ZERO ) . setMIFlag ( MachineInstr :: FrameSetup ) ; unsigned CFIIndex = MMI . addFrameInst ( MCCFIInstruction :: createDefCfaRegister ( nullptr , MRI -> getDwarfRegNum ( FP , true ) ) ) ; BuildMI ( MBB , MBBI , dl , TII . get ( TargetOpcode :: CFI_INSTRUCTION ) ) . addCFIIndex ( CFIIndex ) ; } } void MipsSEFrameLowering :: emitEpilogue ( MachineFunction & MF , MachineBasicBlock & MBB ) const { MachineBasicBlock :: iterator MBBI = MBB . getLastNonDebugInstr ( ) ; MachineFrameInfo * MFI = MF . getFrameInfo ( ) ; MipsFunctionInfo * MipsFI = MF . getInfo < MipsFunctionInfo > ( ) ; const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; const MipsRegisterInfo & RegInfo = * static_cast < const MipsRegisterInfo * > ( MF . getTarget ( ) . getRegisterInfo ( ) ) ; DebugLoc dl = MBBI -> getDebugLoc ( ) ; unsigned SP = STI . isABI_N64 ( ) ? Mips :: SP_64 : Mips :: SP ; unsigned FP = STI . isABI_N64 ( ) ? Mips :: FP_64 : Mips :: FP ; unsigned ZERO = STI . isABI_N64 ( ) ? Mips :: ZERO_64 : Mips :: ZERO ; unsigned ADDu = STI . isABI_N64 ( ) ? Mips :: DADDu : Mips :: ADDu ; if ( hasFP ( MF ) ) { MachineBasicBlock :: iterator I = MBBI ; for ( unsigned i = 0 ; i < MFI -> getCalleeSavedInfo ( ) . size ( ) ; ++ i ) -- I ; BuildMI ( MBB , I , dl , TII . get ( ADDu ) , SP ) . addReg ( FP ) . addReg ( ZERO ) ; } if ( MipsFI -> callsEhReturn ( ) ) { const TargetRegisterClass * RC = STI . isABI_N64 ( ) ? & Mips :: GPR64RegClass : & Mips :: GPR32RegClass ; MachineBasicBlock :: iterator I = MBBI ; for ( unsigned i = 0 ; i < MFI -> getCalleeSavedInfo ( ) . size ( ) ; ++ i ) -- I ; for ( int J = 0 ; J < 4 ; ++ J ) { TII . loadRegFromStackSlot ( MBB , I , ehDataReg ( J ) , MipsFI -> getEhDataRegFI ( J ) , RC , & RegInfo ) ; } } uint64_t StackSize = MFI -> getStackSize ( ) ; if ( ! StackSize ) return ; TII . adjustStackPtr ( SP , StackSize , MBB , MBBI ) ; } bool MipsSEFrameLowering :: spill@@ CalleeSavedRegisters ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator MI , const std :: vector < CalleeSavedInfo > & CSI , const TargetRegisterInfo * TRI ) const { MachineFunction * MF = MBB . getParent ( ) ; MachineBasicBlock * EntryBlock = MF -> begin ( ) ; const TargetInstrInfo & TII = * MF -> getTarget ( ) . getInstrInfo ( ) ; for ( unsigned i = 0 , e = CSI . size ( ) ; i != e ; ++ i ) { unsigned Reg = CSI [ i ] . getReg ( ) ; bool IsRAAndRetAddrIsTaken = ( Reg == Mips :: RA || Reg == Mips :: RA_64 ) && MF -> getFrameInfo ( ) -> isReturnAddressTaken ( ) ; if ( ! IsRAAndRetAddrIsTaken ) EntryBlock -> addLiveIn ( Reg ) ; bool IsKill = ! IsRAAndRetAddrIsTaken ; const TargetRegisterClass * RC = TRI -> getMinimalPhysRegClass ( Reg ) ; TII . storeRegToStackSlot ( * EntryBlock , MI , Reg , IsKill , CSI [ i ] . getFrameIdx ( ) , RC , TRI ) ; } return true ; } bool MipsSEFrameLowering :: hasReservedCallFrame ( const MachineFunction & MF ) const { const MachineFrameInfo * MFI = MF . getFrameInfo ( ) ; return isInt < 16 > ( MFI -> getMaxCallFrameSize ( ) + getStackAlignment ( ) ) && ! MFI -> hasVar@@ SizedObjects ( ) ; } void MipsSEFrameLowering :: eliminateCallFrame@@ PseudoInstr ( MachineFunction & MF , MachineBasicBlock & MBB , MachineBasicBlock :: iterator I ) const { const MipsSEInstrInfo & TII = * static_cast < const MipsSEInstrInfo * > ( MF . getTarget ( ) . getInstrInfo ( ) ) ; if ( ! hasReservedCallFrame ( MF ) ) { int64_t Amount = I -> getOperand ( 0 ) . getImm ( ) ; if ( I -> getOpcode ( ) == Mips :: ADJCALLSTACK@@ DOWN ) Amount = - Amount ; unsigned SP = STI . isABI_N64 ( ) ? Mips :: SP_64 : Mips :: SP ; TII . adjustStackPtr ( SP , Amount , MBB , I ) ; } MBB . erase ( I ) ; } void MipsSEFrameLowering :: processFunctionBefore@@ CalleeSavedScan ( MachineFunction & MF , RegScaveng@@ er * RS ) const { MachineRegisterInfo & MRI = MF . getRegInfo ( ) ; MipsFunctionInfo * MipsFI = MF . getInfo < MipsFunctionInfo > ( ) ; unsigned FP = STI . isABI_N64 ( ) ? Mips :: FP_64 : Mips :: FP ; if ( hasFP ( MF ) ) MRI . setPhysRegUsed ( FP ) ; if ( MipsFI -> callsEhReturn ( ) ) MipsFI -> createEhDataReg@@ sFI ( ) ; if ( ExpandPseudo ( MF ) . expand ( ) ) { const TargetRegisterClass * RC = STI . hasMips@@ 64 ( ) ? & Mips :: GPR64RegClass : & Mips :: GPR32RegClass ; int FI = MF . getFrameInfo ( ) -> CreateStackObject ( RC -> getSize ( ) , RC -> getAlignment ( ) , false ) ; RS -> addScavengingFrameIndex ( FI ) ; } uint64_t MaxSPOffset = MF . getInfo < MipsFunctionInfo > ( ) -> getIncomingArgSize ( ) + estimateStackSize ( MF ) ; if ( isInt < 16 > ( MaxSPOffset ) ) return ; const TargetRegisterClass * RC = STI . isABI_N64 ( ) ? & Mips :: GPR64RegClass : & Mips :: GPR32RegClass ; int FI = MF . getFrameInfo ( ) -> CreateStackObject ( RC -> getSize ( ) , RC -> getAlignment ( ) , false ) ; RS -> addScavengingFrameIndex ( FI ) ; } const MipsFrameLowering * llvm :: createMipsSEFrameLowering ( const MipsSubtarget & ST ) { return new MipsSEFrameLowering ( ST ) ; } </DOCUMENT>
<DOCUMENT_ID="Green@@ DamTan/ppsspp/tree/master/Core/MIPS@@ /x86/Asm@@ .cpp"> # include " math / math _ util . h " # include " ABI . h " # include " x64Emitter . h " # include " Core / Core . h " # include " Core / MemMap . h " # include " Core / System . h " # include " Core / MIPS / MIPS . h " # include " Core / CoreTiming . h " # include " Common / MemoryUtil . h " # include " Core / MIPS / JitCommon / JitCommon . h " # include " Core / MIPS / x86 / Asm . h " # include " Core / MIPS / x86 / Jit . h " using namespace Gen ; using namespace X64JitConstants ; static bool enableDebug = false ; extern volatile CoreState coreState ; void ImHere ( ) { DEBUG_LOG ( CPU , " JIT ▁ Here : ▁ % 08x " , currentMIPS -> pc ) ; } void AsmRout@@ ineManager :: Generate ( MIPSState * mips , MIPSComp :: Jit * jit , MIPSComp :: JitOptions * jo ) { enterCode = AlignCode16 ( ) ; ABI_PushAllCalleeSavedRegsAndAdjustStack ( ) ; # ifdef _M_X64 MOV ( 64 , R ( MEMBASEREG ) , ImmPtr ( Memory :: base ) ) ; uintptr_t jitbase = ( uintptr_t ) jit -> GetBasePtr ( ) ; if ( jitbase > 0x7FFFF@@ FFFULL ) { MOV ( 64 , R ( JITBASEREG ) , ImmPtr ( jit -> GetBasePtr ( ) ) ) ; jo -> reserveR15ForAsm = true ; } # endif MOV ( PTRBITS , R ( CTXREG ) , ImmPtr ( & mips -> f [ 0 ] ) ) ; outerLoop = GetCodePtr ( ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_CallFunction ( reinterpret_cast < void * > ( & CoreTiming :: Advance ) ) ; jit -> ApplyRoundingMode ( true , this ) ; FixupBranch skipToRealDispatch = J ( ) ; dispatcherCheckCoreState = GetCodePtr ( ) ; FixupBranch bailCoreState = J_CC ( CC_S , true ) ; CMP ( 32 , M ( & coreState ) , Imm32 ( 0 ) ) ; FixupBranch badCoreState = J_CC ( CC_NZ , true ) ; FixupBranch skipToRealDispatch2 = J ( ) ; dispatcher = GetCodePtr ( ) ; FixupBranch bail = J_CC ( CC_S , true ) ; SetJumpTarget ( skipToRealDispatch ) ; SetJumpTarget ( skipToRealDispatch2 ) ; dispatcherNoCheck = GetCodePtr ( ) ; MOV ( 32 , R ( EAX ) , M ( & mips -> pc ) ) ; dispatcherInEA@@ XNoCheck = GetCodePtr ( ) ; # ifdef _M_IX86 AND ( 32 , R ( EAX ) , Imm32 ( Memory :: MEMVIEW@@ 32_MASK ) ) ; _assert_msg_ ( CPU , Memory :: base != 0 , " Memory ▁ base ▁ bogus " ) ; MOV ( 32 , R ( EAX ) , MDisp ( EAX , ( u32 ) Memory :: base ) ) ; # elif _M_X64 MOV ( 32 , R ( EAX ) , MComplex ( MEMBASEREG , RAX , SCALE_1 , 0 ) ) ; # endif MOV ( 32 , R ( EDX ) , R ( EAX ) ) ; _assert_msg_ ( JIT , MIPS_JITBLOC@@ K_MASK == 0xFF000000 , " Hardcoded ▁ assump@@ tion ▁ of ▁ emuh@@ ack ▁ mask " ) ; SHR ( 32 , R ( EDX ) , Imm8 ( 24 ) ) ; CMP ( 32 , R ( EDX ) , Imm8 ( MIPS_EMUHACK_OPCODE >> 24 ) ) ; FixupBranch notfound = J_CC ( CC_NE ) ; if ( enableDebug ) { ADD ( 32 , M ( & mips -> debugCount ) , Imm8 ( 1 ) ) ; } AND ( 32 , R ( EAX ) , Imm32 ( MIPS_EMUHACK_VALUE_MASK ) ) ; # ifdef _M_IX86 ADD ( 32 , R ( EAX ) , ImmPtr ( jit -> GetBasePtr ( ) ) ) ; # elif _M_X64 if ( jo -> reserveR15ForAsm ) ADD ( 64 , R ( RAX ) , R ( JITBASEREG ) ) ; else ADD ( 64 , R ( EAX ) , Imm32 ( jitbase ) ) ; # endif JMPptr ( R ( EAX ) ) ; SetJumpTarget ( notfound ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_CallFunction ( & MIPSComp :: JitAt ) ; jit -> ApplyRoundingMode ( true , this ) ; JMP ( dispatcherNoCheck , true ) ; SetJumpTarget ( bail ) ; SetJumpTarget ( bailCoreState ) ; CMP ( 32 , M ( & coreState ) , Imm32 ( 0 ) ) ; J_CC ( CC_Z , outerLoop , true ) ; SetJumpTarget ( badCoreState ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_PopAllCalleeSavedRegsAndAdjustStack ( ) ; RET ( ) ; breakpointBailout = GetCodePtr ( ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_PopAllCalleeSavedRegsAndAdjustStack ( ) ; RET ( ) ; } </DOCUMENT>
<DOCUMENT_ID="ost@@ ash/qt@@ -creator-i18n-@@ uk/tree/master/src/plugins/@@ help/@@ xbelsupport.cpp"> # include " xbelsupport . h " # include " bookmarkmanager . h " # include < QCoreApplication > using namespace Help :: Internal ; struct Bookmark { QString title ; QString url ; bool folded ; } ; XbelWriter :: XbelWriter ( BookmarkModel * model ) : QXmlStreamWriter ( ) , treeModel ( model ) { setAutoFormatting ( true ) ; } void XbelWriter :: writeToFile ( QIODevice * device ) { setDevice ( device ) ; writeStart@@ Document ( ) ; writeDT@@ D ( QLatin1String ( " < ! DOCTYPE ▁ xbel > " ) ) ; writeStartElement ( QLatin1String ( " xbel " ) ) ; writeAttribute ( QLatin1String ( " version " ) , QLatin1String ( "1.0" ) ) ; QStandardItem * root = treeModel -> invisibleRootItem ( ) ; for ( int i = 0 ; i < root -> rowCount ( ) ; ++ i ) writeData ( root -> child ( i ) ) ; writeEnd@@ Document ( ) ; } void XbelWriter :: writeData ( QStandardItem * child ) { Bookmark entry ; entry . title = child -> data ( Qt :: DisplayRole ) . toString ( ) ; entry . url = child -> data ( Qt :: UserRole + 10 ) . toString ( ) ; if ( entry . url == QLatin1String ( " Folder " ) ) { writeStartElement ( QLatin1String ( " folder " ) ) ; entry . folded = ! child -> data ( Qt :: UserRole + 11 ) . toBool ( ) ; writeAttribute ( QLatin1String ( " folded " ) , entry . folded ? QLatin1String ( " yes " ) : QLatin1String ( " no " ) ) ; writeTextElement ( QLatin1String ( " title " ) , entry . title ) ; for ( int i = 0 ; i < child -> rowCount ( ) ; ++ i ) writeData ( child -> child ( i ) ) ; writeEndElement ( ) ; } else { writeStartElement ( QLatin1String ( " bookmark " ) ) ; writeAttribute ( QLatin1String ( " href " ) , entry . url ) ; writeTextElement ( QLatin1String ( " title " ) , entry . title ) ; writeEndElement ( ) ; } } XbelReader :: XbelReader ( BookmarkModel * tree , BookmarkModel * list ) : QXmlStreamReader ( ) , treeModel ( tree ) , listModel ( list ) { bookmarkIcon = QIcon ( QLatin1String ( " : / help / images / bookmark . png " ) ) ; folderIcon = QApplication :: style ( ) -> standardIcon ( QStyle :: SP_Dir@@ ClosedIcon ) ; } bool XbelReader :: readFromFile ( QIODevice * device ) { setDevice ( device ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " xbel " ) && attributes ( ) . value ( QLatin1String ( " version " ) ) == QLatin1String ( "1.0" ) ) { readXBEL ( ) ; } else { raiseError ( QCoreApplication :: translate ( " Help : : Internal : : XbelReader " , " The ▁ file ▁ is ▁ not ▁ an ▁ XBEL ▁ version ▁ 1.0 ▁ file . " ) ) ; } } } return ! error ( ) ; } void XbelReader :: readXBEL ( ) { while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " folder " ) ) readFolder ( 0 ) ; else if ( name ( ) == QLatin1String ( " bookmark " ) ) readBookmark ( 0 ) ; else readUnknownElement ( ) ; } } } void XbelReader :: readUnknownElement ( ) { while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) readUnknownElement ( ) ; } } void XbelReader :: readFolder ( QStandardItem * item ) { QStandardItem * folder = createChildItem ( item ) ; folder -> setIcon ( folderIcon ) ; folder -> setData ( QLatin1String ( " Folder " ) , Qt :: UserRole + 10 ) ; bool expanded = ( attributes ( ) . value ( QLatin1String ( " folded " ) ) != QLatin1String ( " no " ) ) ; folder -> setData ( expanded , Qt :: UserRole + 11 ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " title " ) ) folder -> setText ( readElementText ( ) ) ; else if ( name ( ) == QLatin1String ( " folder " ) ) readFolder ( folder ) ; else if ( name ( ) == QLatin1String ( " bookmark " ) ) readBookmark ( folder ) ; else readUnknownElement ( ) ; } } } void XbelReader :: readBookmark ( QStandardItem * item ) { QStandardItem * bookmark = createChildItem ( item ) ; bookmark -> setIcon ( bookmarkIcon ) ; bookmark -> setText ( QCoreApplication :: translate ( " Help : : Internal : : XbelReader " , " Unknown ▁ title " ) ) ; bookmark -> setData ( attributes ( ) . value ( QLatin1String ( " href " ) ) . toString ( ) , Qt :: UserRole + 10 ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " title " ) ) bookmark -> setText ( readElementText ( ) ) ; else readUnknownElement ( ) ; } } listModel -> appendRow ( bookmark -> clone ( ) ) ; } QStandardItem * XbelReader :: createChildItem ( QStandardItem * item ) { QStandardItem * childItem = new QStandardItem ( ) ; childItem -> setEditable ( false ) ; if ( item ) item -> appendRow ( childItem ) ; else treeModel -> appendRow ( childItem ) ; return childItem ; } </DOCUMENT>
<DOCUMENT_ID="slicer4ever/@@ Lightwave/tree/master/Engine@@ /Source/C++@@ 11/LWEProtocol@@ s/LWEProtocolWebSocketSec@@ ure.cpp"> # include " LWEProtocols / LWEProtocolWebSocketSecure . h " # include " LWEProtocols / LWEProtocolHTT@@ P . h " # include < LWNetwork / LWSocket . h > # include < LWNetwork / LWProtocolManager . h > # include < LWCore / LWAllocator . h > # include < LWCore / LWCrypto . h > # include < LWCore / LWText . h > # include < LWCore / LWByteBuffer . h > # include < iostream > bool LWEProtocolWebSocketSecure :: ProcessRead ( LWSocket & Socket , const char * Buffer , uint32_t BufferLen ) { char Buf [ 256 ] ; char BufB [ 256 ] ; LWEWebSocket * WebSocket = ( LWEWebSocket * ) Socket . GetProtocolData ( m_wProtocolID ) ; if ( ! WebSocket ) { LWEHttpRequest Request ; uint32_t Error = 0 ; Error = Request . Deserialize ( Buffer , BufferLen ) ? 0 : 1 ; Error = Error ? Error : ( * Request . m_SecWebSockKey && Request . m_WebSockVersion == LWEWEBSOCKET_SUPPVER && Request . UpgradeConnection ( ) ) ? 0 : 2 ; if ( ! Error && * Request . m_SecWebSockProto ) { bool ValidProtocol = false ; if ( * m_SubProtocol ) { uint32_t ProtocolLen = ( uint32_t ) strlen ( m_SubProtocol ) ; for ( const char * C = Request . m_SecWebSockProto ; C && ! ValidProtocol ; C = LWText :: FirstToken ( C , ' , ' ) ) { C = LWText :: NextWord ( * C == ' , ' ? C + 1 : C , true ) ; ValidProtocol = LWText :: Compare ( C , m_SubProtocol , ProtocolLen ) ; } } if ( ! ValidProtocol ) Error = 3 ; } if ( Error ) { std :: cout << " Buffer : " << std :: endl << Buffer << std :: endl ; if ( Error == 1 ) std :: cout << " Error ▁ deserializing ▁ websocket ▁ request . " << std :: endl ; else if ( Error == 2 ) std :: cout << " Error ▁ Headers ▁ did ▁ not ▁ include ▁ correct ▁ websocket ▁ data . " << std :: endl ; else if ( Error == 3 ) std :: cout << " Error ▁ protocol ▁ asked ▁ for ▁ is ▁ not ▁ supported . " << std :: endl ; Socket . MarkClosable ( ) ; return false ; } WebSocket = m_Allocator . Allocate < LWEWebSocket > ( nullptr , nullptr ) ; WebSocket -> m_Socket = & Socket ; * Buf = ' \0' ; strncat ( Buf , Request . m_SecWebSockKey , sizeof ( Buf ) ) ; strncat ( Buf , LWEWEBSOCKET_GUID , sizeof ( Buf ) ) ; LWCrypto :: HashSHA1 ( Buf , ( uint32_t ) strlen ( Buf ) , BufB ) ; uint32_t * uBuf = ( uint32_t * ) BufB ; for ( uint32_t i = 0 ; i < 5 ; i ++ ) uBuf [ i ] = ( uBuf [ i ] & 0xFF ) << 24 | ( uBuf [ i ] & 0xFF00 ) << 8 | ( uBuf [ i ] & 0xFF0000 ) >> 8 | ( uBuf [ i ] & 0xFF000000 ) >> 24 ; uint32_t Len = LWCrypto :: Base64Encode ( BufB , 20 , WebSocket -> m_SecKey , sizeof ( WebSocket -> m_SecKey ) ) ; WebSocket -> m_SecKey [ Len ] = ' \0' ; WebSocket -> SetSecProtocols ( m_SubProtocol ) ; WebSocket -> SetHost ( Request . m_Host ) ; WebSocket -> SetPath ( Request . m_Path ) ; WebSocket -> SetOrigin ( Request . m_Origin ) ; WebSocket -> m_Flag |= LWEWebSocket :: CONNECTING_SERVER ; Socket . SetProtocolData ( m_wProtocolID , WebSocket ) ; PushOutPacket ( nullptr , 0 , WebSocket , LWEWebPacket :: CONTROL_CONNECT ) ; return true ; } if ( ! WebSocket -> IsConnected ( ) ) { if ( WebSocket -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_CLIENT ) { LWEHttpRequest Request ; uint32_t Error = 0 ; Error = Request . Deserialize ( Buffer , BufferLen ) ? 0 : 1 ; Error = Error ? Error : ( ( * Request . m_SecWebSockKey && Request . m_Status == LWEHttpRequest :: SwitchingProtocols ) ? 0 : 2 ) ; if ( Error ) { std :: cout << " Buffer : " << std :: endl << Buffer << std :: endl ; if ( Error == 1 ) std :: cout << " Error ▁ deserializing ▁ websocket ▁ request . " << std :: endl ; else if ( Error == 2 ) std :: cout << " Error ▁ headers ▁ did ▁ not ▁ include ▁ correct ▁ websocket ▁ data . " << std :: endl ; Socket . MarkClosable ( ) ; return false ; } WebSocket -> m_Flag = ( WebSocket -> m_Flag & ~ LWEWebSocket :: CONNECTING_CLIENT ) | LWEWebSocket :: CONNECTED_CLIENT ; } return true ; } char IPBuf [ 32 ] ; LWSocket :: MakeAddress ( Socket . GetRemoteIP ( ) , IPBuf , sizeof ( IPBuf ) ) ; if ( BufferLen > 100 ) { } LWEWebPacket * OPack ; uint32_t Target ; uint32_t ReservePos ; uint32_t o = 0 ; while ( o != BufferLen ) { uint32_t Res = WebSocket -> m_ActivePacket . Deserialize ( Buffer + o , BufferLen - o , m_Allocator ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ deserializing ▁ data . " << std :: endl ; return false ; } o += Res ; if ( ! WebSocket -> m_ActivePacket . Finished ( ) ) continue ; if ( WebSocket -> m_ActivePacket . m_DataLen != WebSocket -> m_ActivePacket . m_DataPos ) continue ; if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_CLO@@ SED ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; Socket . MarkClosable ( ) ; return true ; } else if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_PING ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; PushOutPacket ( nullptr , 0 , WebSocket , LWEWebPacket :: CONTROL_PONG ) ; continue ; } else if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_PONG ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; continue ; } WebSocket -> m_ActivePacket . m_WebSocket = WebSocket ; if ( ! m_InPackets . PushStart ( & OPack , Target , ReservePos ) ) return false ; * OPack = std :: move ( WebSocket -> m_ActivePacket ) ; m_InPackets . PushFinished ( Target , ReservePos ) ; } return true ; } LWProtocol & LWEProtocolWebSocketSecure :: SocketClosed ( LWSocket & Socket , LWProtocolManager * Manager ) { LWEProtocolTLS :: SocketClosed ( Socket , Manager ) ; LWEWebSocket * WebSock = ( LWEWebSocket * ) Socket . GetProtocolData ( m_wProtocolID ) ; bool Del = true ; if ( m_WebSocketClosedCallback ) Del = m_WebSocketClosedCallback ( Socket , WebSock , Manager ) ; if ( WebSock ) WebSock -> m_Socket = nullptr ; if ( Del ) LWAllocator :: Destroy ( WebSock ) ; return * this ; } LWProtocol & LWEProtocolWebSocketSecure :: SocketChanged ( LWSocket & Prev , LWSocket & New , LWProtocolManager * Manager ) { LWEProtocolTLS :: SocketChanged ( Prev , New , Manager ) ; LWEWebSocket * WebSocket = ( LWEWebSocket * ) Prev . GetProtocolData ( m_wProtocolID ) ; New . SetProtocolData ( m_wProtocolID , Prev . GetProtocolData ( m_wProtocolID ) ) ; if ( WebSocket ) WebSocket -> m_Socket = & New ; if ( m_WebSocketChangedCallback ) m_WebSocketChangedCallback ( Prev , New , WebSocket , Manager ) ; return * this ; } LWProtocol & LWEProtocolWebSocketSecure :: ProcessTLS@@ Data ( LWSocket & Socket , const char * Data , uint32_t DataLen ) { ProcessRead ( Socket , Data , DataLen ) ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: ProcessOutPackets ( void ) { char Buffer [ 1024 * 64 ] ; LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; while ( m_OutPackets . PopStart ( & Pack , Target , ReservePos ) ) { LWEWebPacket RPack = std :: move ( * Pack ) ; m_OutPackets . PopFinshed ( Target , ReservePos ) ; LWEWebSocket * Sock = RPack . m_WebSocket ; if ( ! Sock -> IsConnected ( ) && ( RPack . m_ControlFlag & LWEWebPacket :: CONTROL_CONNECT ) ) { if ( ! Sock -> m_Socket ) return * this ; LWEHttpRequest Request ; Request . SetWebSockKey ( Sock -> m_SecKey ) ; Request . SetWebSockProto ( m_SubProtocol ) ; Request . m_Flag |= LWEHttpRequest :: ConnectionUpgrade | LWEHttpRequest :: UpgradeWebSock ; Request . m_Status = Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_SERVER ? LWEHttpRequest :: SwitchingProtocols : 0 ; if ( Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_CLIENT ) { Request . SetHost ( Sock -> m_Host ) . SetPath ( Sock -> m_Path ) . SetOrigin ( Sock -> m_Origin ) ; Request . m_WebSockVersion = LWEWEBSOCKET_SUPPVER ; } else Sock -> m_Flag = ( Sock -> m_Flag & ~ LWEWebSocket :: CONNECTING_SERVER ) | LWEWebSocket :: CONNECTED_SERVER ; uint32_t Len = Request . Serialize ( Buffer , sizeof ( Buffer ) , Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_CLIENT ? m_UserAgent : m_Server ) ; std :: cout << " Sending ▁ headers ! " << std :: endl ; uint32_t Res = Send ( * Sock -> m_Socket , Buffer , Len ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ sending ▁ data . " << std :: endl ; return * this ; } if ( ! Res ) { if ( Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_SERVER ) Sock -> m_Flag = ( Sock -> m_Flag & ~ LWEWebSocket :: CONNECTING_SERVER ) | LWEWebSocket :: CONNECTING_SERVER ; PushOutPacket ( nullptr , 0 , Sock , LWEWebPacket :: CONTROL_CONNECT ) ; return * this ; } } if ( RPack . m_ControlFlag & LWEWebPacket :: CONTROL_CONNECT ) continue ; if ( ! Sock -> IsConnected ( ) ) { if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) { std :: cout << " Error ▁ re - inserting ▁ packet . " << std :: endl ; return * this ; } * Pack = std :: move ( RPack ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; return * this ; } std :: cout << " Sending ▁ data : ▁ " << RPack . GetOp ( ) << " ▁ Len : ▁ " << RPack . m_DataLen << " ▁ Fin : ▁ " << RPack . m_ControlFlag << std :: endl ; LWSocket * rSock = RPack . m_WebSocket -> m_Socket ; if ( ! rSock ) continue ; uint32_t Len = RPack . Serialize ( Buffer , sizeof ( Buffer ) , Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_CLIENT ) ; std :: cout << " Serialized : ▁ " << Len << std :: endl ; uint32_t Res = Send ( * rSock , Buffer , Len ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ sending ▁ data . " << std :: endl ; return * this ; } if ( ! Res ) { if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) { std :: cout << " Error ▁ re - inserting ▁ packet . " << std :: endl ; return * this ; } * Pack = std :: move ( RPack ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; } } return * this ; } LWEWebSocket * LWEProtocolWebSocketSecure :: OpenSocket ( const char * URI , uint32_t ProtocolID , const char * Origin ) { char Host [ 256 ] ; char Path [ 256 ] ; char Protocol [ 256 ] ; uint16_t Port = LWEHttpRequest :: ParseURI ( URI , Host , sizeof ( Host ) , nullptr , Path , sizeof ( Path ) , nullptr , Protocol , sizeof ( Protocol ) , nullptr ) ; LWSocket Sock ; uint32_t Err = LWSocket :: CreateSocket ( Sock , Host , Port , LWSocket :: Tcp , ProtocolID ) ; if ( Err ) { std :: cout << " Error ▁ creating ▁ socket : ▁ " << Err << std :: endl ; return nullptr ; } LWSocket * S = m_Manager -> PushSocket ( Sock ) ; LWEWebSocket * WebSock = m_Allocator . Allocate < LWEWebSocket > ( URI , Origin ) ; WebSock -> m_Flag |= LWEWebSocket :: CONNECTING_CLIENT ; WebSock -> GenerateKey ( m_KeySeed ++ ) ; S -> SetProtocolData ( m_wProtocolID , WebSock ) ; WebSock -> m_Socket = S ; PushOutPacket ( nullptr , 0 , WebSock , LWEWebPacket :: CONTROL_CONNECT ) ; return WebSock ; } bool LWEProtocolWebSocketSecure :: PushOutPacket ( const char * Buffer , uint32_t BufferLen , LWEWebSocket * Socket , uint32_t ControlFlag ) { LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) return false ; * Pack = LWEWebPacket ( Buffer , BufferLen , m_Allocator , ControlFlag | LWEWebPacket :: CONTROL_FIN@@ ISHED , Socket ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; return true ; } bool LWEProtocolWebSocketSecure :: GetNextPacket ( LWEWebPacket & Packet ) { LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; if ( ! m_InPackets . PopStart ( & Pack , Target , ReservePos ) ) return false ; Packet = std :: move ( * Pack ) ; m_InPackets . PopFinshed ( Target , ReservePos ) ; return true ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetServer ( const char * Server ) { * m_Server = ' \0' ; strncat ( m_Server , Server , sizeof ( m_Server ) ) ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetUserAgent ( const char * Agent ) { * m_UserAgent = ' \0' ; strncat ( m_UserAgent , Agent , sizeof ( m_UserAgent ) ) ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetSubProtocol ( const char * SubProtocol ) { * m_SubProtocol = ' \0' ; strncat ( m_SubProtocol , SubProtocol , sizeof ( m_SubProtocol ) ) ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetWebSocketClosedCallback ( std :: function < bool ( LWSocket & , LWEWebSocket * , LWProtocolManager * ) > WebSocketClosedCallback ) { m_WebSocketClosedCallback = WebSocketClosedCallback ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetWebSocketChangedCallback ( std :: function < void ( LWSocket & , LWSocket & , LWEWebSocket * , LWProtocolManager * ) > WebSocketChangedCallback ) { m_WebSocketChangedCallback = WebSocketChangedCallback ; return * this ; } LWEProtocolWebSocketSecure :: LWEProtocolWebSocketSecure ( uint32_t ProtocolID , uint32_t TLSProtocolID , LWAllocator & Allocator , LWProtocolManager * Manager , const char * CertFile , const char * KeyFile ) : LWEProtocolTLS ( TLSProtocolID , Allocator , CertFile , KeyFile ) , m_wProtocolID ( ProtocolID ) , m_Allocator ( Allocator ) , m_Manager ( Manager ) , m_KeySeed ( 0 ) { * m_Server = * m_UserAgent = * m_SubProtocol = ' \0' ; m_WebSocketClosedCallback = nullptr ; m_WebSocketChangedCallback = nullptr ; } </DOCUMENT>
<DOCUMENT_ID="Chame@@ leonOS/android_external_skia/tree/master/@@ tests/PathOpsAngle@@ Test.cpp"> # include " PathOpsTestCommon . h " # include " SkOpSegment . h " # include " SkTArray . h " # include " Test . h " static const SkPoint cubics [ ] [ 4 ] = { { { 0 , 1 } , { 2 , 6 } , { 4 , 2 } , { 5 , 3 } } , { { 10 , 234 } , { 10 , 229.@@ 58172@@ 6f } , { 13.58@@ 17204f , 226 } , { 18 , 226 } } , { { 132 , 11419 } , { 130.89543151855469f , 11419 } , { 130 , 11418.1044921875f } , { 130 , 11417 } } , { { 130.04275512695312f , 11417.4130859375f } , { 130.23@@ 3078@@ 00292969f , 11418.3193359375f } , { 131.037094@@ 11621094f , 11419 } , { 132 , 11419 } } , { { 0 , 1 } , { 0 , 5 } , { 4 , 1 } , { 6 , 4 } } , { { 1 , 5 } , { 4 , 6 } , { 1 , 0 } , { 4 , 0 } } , { { 0 , 1 } , { 0 , 4 } , { 5 , 1 } , { 6 , 4 } } , { { 0 , 1 } , { 1 , 2 } , { 1 , 0 } , { 6 , 1 } } , { { 0 , 3 } , { 0 , 1 } , { 2 , 0 } , { 1 , 0 } } , { { 189 , 7 } , { 189 , 5.34314@@ 5847@@ 3205566f } , { 190.34@@ 3139648@@ 4375f , 4 } , { 192 , 4 } } , { { 0 , 1 } , { 1 , 3 } , { 1 , 0 } , { 6 , 4 } } , { { 0 , 1 } , { 2 , 3 } , { 2 , 1 } , { 4 , 3 } } , { { 1 , 2 } , { 3 , 4 } , { 1 , 0 } , { 3 , 2 } } , { { 0 , 1 } , { 4 , 6 } , { 4 , 3 } , { 5 , 4 } } , { { 806 , 11419 } , { 806.@@ 962890625f , 11419 } , { 807.766@@ 9067@@ 3828@@ 125f , 11418.3193359375f } , { 807.957275@@ 390625f , 11417.4130859375f } } , { { 808 , 11417 } , { 808 , 11418.1044921875f } , { 807.104553222@@ 65625f , 11419 } , { 806 , 11419 } } , { { 132 , 11419 } , { 130.89543151855469f , 11419 } , { 130 , 11418.1044921875f } , { 130 , 11417 } } , { { 130.04275512695312f , 11417.4130859375f } , { 130.233@@ 12377@@ 929687f , 11418.3193359375f } , { 131.03707885@@ 742187f , 11419 } , { 132 , 11419 } } , { { 1006.69@@ 51293945312f , 291 } , { 1023.@@ 263671875f , 291 } , { 1033.8402099@@ 609375f , 304.43@@ 14575@@ 1953@@ 125f } , { 1030.318359375f , 321 } } , } ; static const SkPoint quads [ ] [ 3 ] = { { { 12.3423@@ 996f , 228.@@ 34240@@ 7f } , { 10 , 230.68@@ 6295f } , { 10 , 234 } } , { { 304.24319458007812f , 591.75677490234@@ 375f } , { 306 , 593.5@@ 147094@@ 7265625f } , { 306 , 596 } } , { { 0 , 0 } , { 3 , 1 } , { 0 , 3 } } , { { 0 , 1 } , { 3 , 1 } , { 0 , 2 } } , } ; static const SkPoint lines [ ] [ 2 ] = { { { 6 , 2 } , { 2 , 4 } } , { { 306 , 617 } , { 306 , 590 } } , { { 306 , 596 } , { 306 , 617 } } , { { 6 , 4 } , { 0 , 1 } } , { { 6 , 1 } , { 0 , 1 } } , { { 1 , 0 } , { 0 , 3 } } , { { 246 , 4 } , { 189 , 4 } } , { { 192 , 4 } , { 243 , 4 } } , { { 4 , 3 } , { 0 , 1 } } , { { 3 , 2 } , { 1 , 2 } } , { { 6 , 4 } , { 3 , 4 } } , { { 979.304870@@ 6054@@ 6875f , 561 } , { 1036.69@@ 5068@@ 359375f , 291 } } , } ; struct SortSet { const SkPoint * ptData ; int ptCount ; double tStart ; double tEnd ; SkPoint endPt ; } ; static const SortSet set1 [ ] = { { cubics [ 0 ] , 4 , 0.66666987081928919 , 0.875 , { 0 , 0 } } , { lines [ 0 ] , 2 , 0.574070336 , 0.388888889 , { 0 , 0 } } , { cubics [ 0 ] , 4 , 0.66666987081928919 , 0.4050371120499@@ 307 , { 0 , 0 } } , { lines [ 0 ] , 2 , 0.574070336 , 0.9140625 , { 0 , 0 } } , } ; static const SortSet set1a [ ] = { { cubics [ 0 ] , 4 , 0.666666667 , 0.405037112 , { 4.58@@ 007812f , 2.83203@@ 125f } } , { lines [ 0 ] , 2 , 0.574074074 , 0.9140625 , { 4.4444@@ 4466f , 2.77777767f } } , } ; static const SortSet set2 [ ] = { { cubics [ 0 ] , 4 , 0.666666667 , 0.875 , { 0 , 0 } } , { lines [ 0 ] , 2 , 0.574074074 , 0.388888889 , { 0 , 0 } } , { cubics [ 0 ] , 4 , 0.666666667 , 0.405037112 , { 0 , 0 } } , { lines [ 0 ] , 2 , 0.574074074 , 0.9140625 , { 0 , 0 } } , } ; static const SortSet set3 [ ] = { { cubics [ 1 ] , 4 , 0 , 1 , { 0 , 0 } } , { quads [ 0 ] , 3 , 1 , 0 , { 0 , 0 } } , } ; static const SortSet set4 [ ] = { { cubics [ 2 ] , 4 , 0.812114@@ 222 , 1 , { 0 , 0 } } , { cubics [ 3 ] , 4 , 0.068@@ 4734759 , 0 , { 0 , 0 } } , } ; static const SortSet set5 [ ] = { { lines [ 1 ] , 2 , 0.777777778 , 1 , { 0 , 0 } } , { quads [ 1 ] , 3 , 1 , 4.34137342e - 06 , { 0 , 0 } } , { lines [ 2 ] , 2 , 0 , 1 , { 0 , 0 } } , } ; static const SortSet set5a [ ] = { { lines [ 1 ] , 2 , 0.777777778 , 1 , { 306 , 590 } } , { quads [ 1 ] , 3 , 1 , 4.34137342e - 06 , { 304.243195f , 591.756775f } } , { lines [ 2 ] , 2 , 0 , 1 , { 306 , 617 } } , } ; static const SortSet set6 [ ] = { { lines [ 3 ] , 2 , 0.407407407 , 0.554627832 , { 0 , 0 } } , { cubics [ 4 ] , 4 , 0.666666667 , 0.548022446 , { 0 , 0 } } , { lines [ 3 ] , 2 , 0.407407407 , 0 , { 0 , 0 } } , { cubics [ 4 ] , 4 , 0.666666667 , 1 , { 0 , 0 } } , } ; static const SortSet set6a [ ] = { { lines [ 3 ] , 2 , 0.407407407 , 0.554627832 , { 2.672233@@ 1f , 2.33@@ 61165@@ 5f } } , { cubics [ 4 ] , 4 , 0.666666667 , 0.548022446 , { 2.6164224@@ 1f , 2.83718514f } } , { lines [ 3 ] , 2 , 0.407407407 , 0 , { 6 , 4 } } , { cubics [ 4 ] , 4 , 0.666666667 , 1 , { 6 , 4 } } , } ; static const SortSet set7 [ ] = { { cubics [ 5 ] , 4 , 0.545233342 , 0.545454545 , { 0 , 0 } } , { cubics [ 6 ] , 4 , 0.484938134 , 0.484805744 , { 0 , 0 } } , { cubics [ 5 ] , 4 , 0.545233342 , 0 , { 0 , 0 } } , { cubics [ 6 ] , 4 , 0.484938134 , 0.545454545 , { 0 , 0 } } , } ; static const SortSet set8 [ ] = { { cubics [ 7 ] , 4 , 0.5 , 0.522986744 , { 0 , 0 } } , { lines [ 4 ] , 2 , 0.75 , 1 , { 0 , 0 } } , { cubics [ 7 ] , 4 , 0.5 , 0 , { 0 , 0 } } , { lines [ 4 ] , 2 , 0.75 , 0.737654321 , { 0 , 0 } } , } ; static const SortSet set8a [ ] = { { cubics [ 7 ] , 4 , 0.5 , 0.522986744 , { 1.60@@ 6683@@ 61f , 0.965592@@ 742f } } , { lines [ 4 ] , 2 , 0.75 , 1 , { 0 , 1 } } , { cubics [ 7 ] , 4 , 0.5 , 0 , { 0 , 1 } } , { lines [ 4 ] , 2 , 0.75 , 0.737654321 , { 1.57407403f , 1 } } , } ; static const SortSet set9 [ ] = { { cubics [ 8 ] , 4 , 0.4 , 1 , { 0 , 0 } } , { lines [ 5 ] , 2 , 0.36 , 0 , { 0 , 0 } } , { cubics [ 8 ] , 4 , 0.4 , 0.394675@@ 838 , { 0 , 0 } } , { lines [ 5 ] , 2 , 0.36 , 0.363@@ 99978@@ 2 , { 0 , 0 } } , } ; static const SortSet set10 [ ] = { { lines [ 6 ] , 2 , 0.947368@@ 421 , 1 , { 0 , 0 } } , { cubics [ 9 ] , 4 , 1 , 0.5000003@@ 57 , { 0 , 0 } } , { lines [ 7 ] , 2 , 0 , 1 , { 0 , 0 } } , } ; static const SortSet set11 [ ] = { { lines [ 3 ] , 2 , 0.75 , 1 , { 0 , 0 } } , { cubics [ 10 ] , 4 , 0.5 , 0.228744@@ 269 , { 0 , 0 } } , { lines [ 3 ] , 2 , 0.75 , 0.627112191 , { 0 , 0 } } , { cubics [ 10 ] , 4 , 0.5 , 0.6339746 , { 0 , 0 } } , } ; static const SortSet set12 [ ] = { { cubics [ 12 ] , 4 , 0.5 , 1 , { 0 , 0 } } , { lines [ 8 ] , 2 , 0.5 , 1 , { 0 , 0 } } , { cubics [ 11 ] , 4 , 0.5 , 0 , { 0 , 0 } } , { lines [ 9 ] , 2 , 0.5 , 1 , { 0 , 0 } } , { cubics [ 12 ] , 4 , 0.5 , 0 , { 0 , 0 } } , { lines [ 8 ] , 2 , 0.5 , 0 , { 0 , 0 } } , { cubics [ 11 ] , 4 , 0.5 , 1 , { 0 , 0 } } , { lines [ 9 ] , 2 , 0.5 , 0 , { 0 , 0 } } , } ; static const SortSet set13 [ ] = { { cubics [ 13 ] , 4 , 0.5 , 0.40063@@ 1046 , { 0 , 0 } } , { lines [ 10 ] , 2 , 0.791666667 , 0.928 , { 0 , 0 } } , { lines [ 10 ] , 2 , 0.791666667 , 0.333333333 , { 0 , 0 } } , { cubics [ 13 ] , 4 , 0.5 , 0.86666@@ 6667 , { 0 , 0 } } , } ; static const SortSet set14 [ ] = { { quads [ 2 ] , 3 , 0.5 , 0.31010@@ 2051 , { 0 , 0 } } , { quads [ 3 ] , 3 , 0.5 , 0.2 , { 0 , 0 } } , { quads [ 3 ] , 3 , 0.5 , 0.77015@@ 6212 , { 0 , 0 } } , { quads [ 2 ] , 3 , 0.5 , 0.7 , { 0 , 0 } } , } ; static const SortSet set15 [ ] = { { cubics [ 14 ] , 4 , 0.93081374 , 1 , { 0 , 0 } } , { cubics [ 15 ] , 4 , 0.188518131 , 0 , { 0 , 0 } } , { cubics [ 14 ] , 4 , 0.93081374 , 0 , { 0 , 0 } } , } ; static const SortSet set16 [ ] = { { cubics [ 17 ] , 4 , 0.0682619216 , 0 , { 130.04275@@ 5f , 11417.4131f } } , { cubics [ 16 ] , 4 , 0.81230@@ 2088 , 1 , { 130 , 11417 } } , { cubics [ 17 ] , 4 , 0.0682619216 , 1 , { 132 , 11419 } } , } ; static const SortSet set17 [ ] = { { lines [ 11 ] , 2 , 0.888889581 , 1 , { 0 , 0 } } , { cubics [ 18 ] , 4 , 0.999996241 , 0 , { 0 , 0 } } , { lines [ 11 ] , 2 , 0.888889581 , 0 , { 0 , 0 } } , { cubics [ 18 ] , 4 , 0.999996241 , 1 , { 0 , 0 } } , } ; struct SortSetTests { const char * name ; const SortSet * set ; size_t count ; SkPoint startPt ; } ; # define TEST_ENTRY ( name ) # name , name , SK_ARRAY_COUNT ( name ) static const SortSetTests tests [ ] = { { TEST_ENTRY ( set17 ) , { 0 , 0 } } , { TEST_ENTRY ( set16 ) , { 130.0@@ 90179@@ f , 11417.5@@ 957f } } , { TEST_ENTRY ( set14 ) , { 0 , 0 } } , { TEST_ENTRY ( set13 ) , { 0 , 0 } } , { TEST_ENTRY ( set12 ) , { 0 , 0 } } , { TEST_ENTRY ( set11 ) , { 0 , 0 } } , { TEST_ENTRY ( set10 ) , { 0 , 0 } } , { TEST_ENTRY ( set9 ) , { 0 , 0 } } , { TEST_ENTRY ( set6a ) , { 3.55555558f , 2.77777767f } } , { TEST_ENTRY ( set8a ) , { 1.5f , 1 } } , { TEST_ENTRY ( set8 ) , { 0 , 0 } } , { TEST_ENTRY ( set7 ) , { 0 , 0 } } , { TEST_ENTRY ( set6a ) , { 3.55555558f , 2.77777767f } } , { TEST_ENTRY ( set6 ) , { 0 , 0 } } , { TEST_ENTRY ( set5a ) , { 306 , 596 } } , { TEST_ENTRY ( set5 ) , { 0 , 0 } } , { TEST_ENTRY ( set3 ) , { 0 , 0 } } , { TEST_ENTRY ( set2 ) , { 0 , 0 } } , { TEST_ENTRY ( set1 ) , { 0 , 0 } } , } ; # undef TEST_ENTRY static void setup ( const SortSet * set , const size_t idx , SkOpSegment * seg , int * ts , const SkPoint & startPt ) { SkPoint start , end ; const SkPoint * data = set [ idx ] . ptData ; bool useIntersectPt = startPt . fX != 0 || startPt . fY != 0 ; if ( useIntersectPt ) { start = startPt ; end = set [ idx ] . endPt ; } switch ( set [ idx ] . ptCount ) { case 2 : { SkASSERT ( ValidPoints ( data , 2 ) ) ; seg -> addLine ( data , false , false ) ; SkDLine dLine ; dLine . set ( set [ idx ] . ptData ) ; SkASSERT ( ValidLine ( dLine ) ) ; if ( useIntersectPt ) { break ; } start = dLine . ptAtT ( set [ idx ] . tStart ) . asSkPoint ( ) ; end = dLine . ptAtT ( set [ idx ] . tEnd ) . asSkPoint ( ) ; } break ; case 3 : { SkASSERT ( ValidPoints ( data , 3 ) ) ; seg -> addQuad ( data , false , false ) ; SkDQuad dQuad ; dQuad . set ( set [ idx ] . ptData ) ; SkASSERT ( ValidQuad ( dQuad ) ) ; if ( useIntersectPt ) { break ; } start = dQuad . ptAtT ( set [ idx ] . tStart ) . asSkPoint ( ) ; end = dQuad . ptAtT ( set [ idx ] . tEnd ) . asSkPoint ( ) ; } break ; case 4 : { SkASSERT ( ValidPoints ( data , 4 ) ) ; seg -> addCubic ( data , false , false ) ; SkDCubic dCubic ; dCubic . set ( set [ idx ] . ptData ) ; SkASSERT ( ValidCubic ( dCubic ) ) ; if ( useIntersectPt ) { break ; } start = dCubic . ptAtT ( set [ idx ] . tStart ) . asSkPoint ( ) ; end = dCubic . ptAtT ( set [ idx ] . tEnd ) . asSkPoint ( ) ; } break ; } double tStart = set [ idx ] . tStart ; double tEnd = set [ idx ] . tEnd ; seg -> addT ( NULL , start , tStart ) ; seg -> addT ( NULL , end , tEnd ) ; if ( tStart != 0 && tEnd != 0 ) { seg -> addT ( NULL , set [ idx ] . ptData [ 0 ] , 0 ) ; } if ( tStart != 1 && tEnd != 1 ) { seg -> addT ( NULL , set [ idx ] . ptData [ set [ idx ] . ptCount - 1 ] , 1 ) ; } int tIndex = 0 ; ts [ 0 ] = 0 ; ts [ 1 ] = 1 ; do { if ( seg -> t ( tIndex ) == set [ idx ] . tStart ) { ts [ 0 ] = tIndex ; } if ( seg -> t ( tIndex ) == set [ idx ] . tEnd ) { ts [ 1 ] = tIndex ; } if ( seg -> t ( tIndex ) >= 1 ) { break ; } } while ( ++ tIndex ) ; } static void testOne ( skiatest :: Reporter * reporter , const SortSetTests & test ) { SkTDArray < SkOpAngle > angles ; bool unsortable = false ; bool unorderable = false ; SkTArray < SkOpSegment > segs ; for ( size_t idx = 0 ; idx < test . count ; ++ idx ) { int ts [ 2 ] ; const SortSet * set = test . set ; SkOpSegment & seg = segs . push_back ( ) ; setup ( set , idx , & seg , ts , test . startPt ) ; SkOpAngle * angle = angles . append ( ) ; angle -> set ( & seg , ts [ 0 ] , ts [ 1 ] ) ; # if DEBUG_ANGLE angle -> setID ( idx ) ; # endif if ( angle -> unsortable ( ) ) { # if DEBUG_ANGLE SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ angle [ % d ] ▁ unsortable \n " , __FUNCTION__ , test . name , idx ) ; # endif unsortable = true ; } if ( angle -> unorderable ( ) ) { # if DEBUG_ANGLE SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ angle [ % d ] ▁ unorderable \n " , __FUNCTION__ , test . name , idx ) ; # endif unorderable = true ; } reporter -> bumpTestCount ( ) ; } if ( unsortable || unorderable ) { return ; } # if DEBUG_ANGLE SkDebugf ( " % s ▁ test [ % s ] \n " , __FUNCTION__ , test . name ) ; # endif for ( size_t idxL = 0 ; idxL < test . count ; ++ idxL ) { const SkOpAngle & first = angles [ idxL ] ; for ( size_t idxG = 0 ; idxG < test . count ; ++ idxG ) { if ( idxL == idxG ) { continue ; } const SkOpAngle & second = angles [ idxG ] ; bool compare = first < second ; if ( idxL < idxG ) { if ( ! compare ) { SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ first [ % d ] ▁ > ▁ second [ % d ] \n " , __FUNCTION__ , test . name , idxL , idxG ) ; compare = first < second ; } REPORTER_ASSERT ( reporter , compare ) ; } else { SkASSERT ( idxL > idxG ) ; if ( compare ) { SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ first [ % d ] ▁ < ▁ second [ % d ] \n " , __FUNCTION__ , test . name , idxL , idxG ) ; compare = first < second ; } REPORTER_ASSERT ( reporter , ! compare ) ; } compare = second < first ; if ( idxL < idxG ) { if ( compare ) { SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ second [ % d ] ▁ < ▁ first [ % d ] \n " , __FUNCTION__ , test . name , idxL , idxG ) ; compare = second < first ; } REPORTER_ASSERT ( reporter , ! compare ) ; } else { SkASSERT ( idxL > idxG ) ; if ( ! compare ) { SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ second [ % d ] ▁ > ▁ first [ % d ] \n " , __FUNCTION__ , test . name , idxL , idxG ) ; compare = second < first ; } REPORTER_ASSERT ( reporter , compare ) ; } } } } static void PathOpsAngleTest ( skiatest :: Reporter * reporter ) { for ( size_t index = 0 ; index < SK_ARRAY_COUNT ( tests ) ; ++ index ) { const SortSetTests & test = tests [ index ] ; testOne ( reporter , test ) ; reporter -> bumpTestCount ( ) ; } } static void PathOpsAngleTestOne ( skiatest :: Reporter * reporter ) { size_t index = 0 ; const SortSetTests & test = tests [ index ] ; testOne ( reporter , test ) ; } # if 0 static int find_slop ( double x , double y , double rx , double ry ) { int slopBits = 0 ; bool less1 , less2 ; double absX = fabs ( x ) ; double absY = fabs ( y ) ; double length = absX < absY ? absX / 2 + absY : absX + absY / 2 ; int exponent ; ( void ) frexp ( length , & exponent ) ; double epsilon = ldexp ( FLT_EPSILON , exponent ) ; do { double xSlop = epsilon * slopBits ; double ySlop = x * y < 0 ? - xSlop : xSlop ; double x1 = x - xSlop ; double y1 = y + ySlop ; double x_ry1 = x1 * ry ; double rx_y1 = rx * y1 ; less1 = x_ry1 < rx_y1 ; double x2 = x + xSlop ; double y2 = y - ySlop ; double x_ry2 = x2 * ry ; double rx_y2 = rx * y2 ; less2 = x_ry2 < rx_y2 ; } while ( less1 == less2 && ++ slopBits ) ; return slopBits ; } static double diamond_angle ( double y , double x ) { if ( y >= 0 ) return ( x >= 0 ? y / ( x + y ) : 1 - x / ( - x + y ) ) ; else return ( x < 0 ? 2 - y / ( - x - y ) : 3 + x / ( x - y ) ) ; } static const double slopTests [ ] [ 4 ] = { { - 0.058@@ 5547564525@@ 93892 , - 0.188045858438@@ 27226 , - 0.0185685@@ 696460@@ 21160 , - 0.0596@@ 1529@@ 4434479@@ 438 } , { - 0.00137174@@ 1294@@ 8608398 , 0.00411@@ 522388@@ 4582519@@ 5 , - 0.000458@@ 379441959@@ 25573 , 0.001375@@ 31757354@@ 78074 } , { - 2.1033@@ 77414@@ 5221198 , - 1.404@@ 601926@@ 1273@@ 715e - 008 , - 0.70062@@ 688352066@@ 704 , - 1.270@@ 632468@@ 3777995@@ e - 008 } , } ; static void PathOpsAngleFindSlop ( skiatest :: Reporter * reporter ) { for ( size_t index = 0 ; index < SK_ARRAY_COUNT ( slopTests ) ; ++ index ) { const double * slopTest = slopTests [ index ] ; double x = slopTest [ 0 ] ; double y = slopTest [ 1 ] ; double rx = slopTest [ 2 ] ; double ry = slopTest [ 3 ] ; SkDebugf ( " % s ▁ ▁ xy ▁ % d = % d \n " , __FUNCTION__ , ( int ) index , find_slop ( x , y , rx , ry ) ) ; SkDebugf ( " % s ▁ rxy ▁ % d = % d \n " , __FUNCTION__ , ( int ) index , find_slop ( rx , ry , x , y ) ) ; double angle = diamond_angle ( y , x ) ; double rAngle = diamond_angle ( ry , rx ) ; double diff = fabs ( angle - rAngle ) ; SkDebugf ( " % s ▁ diamond ▁ xy = % 1.9g ▁ rxy = % 1.9g ▁ diff = % 1.9g ▁ factor = % d \n " , __FUNCTION__ , angle , rAngle , diff , ( int ) ( diff / FLT_EPSILON ) ) ; } } # endif # include " TestClass@@ Def . h " DEFINE_TESTCLASS_SHORT ( PathOpsAngleTest ) DEFINE_TESTCLASS_SHORT ( PathOpsAngleTestOne ) </DOCUMENT>
<DOCUMENT_ID="map@@ mapteam@@ /mapmap@@ /tree/master/src/gui/contri@@ b/qtpropertybrowser@@ /src/qtpropertybrowser@@ utils@@ .cpp"> # include " qtpropertybrowserutils _ p . h " # include < QApplication > # include < QPainter > # include < QHBoxLayout > # include < QMouseEvent > # include < QCheckBox > # include < QLineEdit > # include < QMenu > # include < QStyleOption > # if QT_VERSION >= 0x040400 QT_BEGIN_NAMESPACE # endif QtCursorDatabase :: QtCursorDatabase ( ) { appendCursor ( Qt :: ArrowCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Arrow " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - arrow . png " ) ) ) ; appendCursor ( Qt :: UpArrowCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Up ▁ Arrow " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - uparrow . png " ) ) ) ; appendCursor ( Qt :: CrossCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Cross " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - cross . png " ) ) ) ; appendCursor ( Qt :: WaitCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Wait " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - wait . png " ) ) ) ; appendCursor ( Qt :: IBeamCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " IBeam " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - ibeam . png " ) ) ) ; appendCursor ( Qt :: SizeVerCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Vertical " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizev . png " ) ) ) ; appendCursor ( Qt :: SizeHorCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Horizontal " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeh . png " ) ) ) ; appendCursor ( Qt :: SizeFDiagCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Backslash " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizef . png " ) ) ) ; appendCursor ( Qt :: SizeBDiagCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Slash " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeb . png " ) ) ) ; appendCursor ( Qt :: SizeAllCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ All " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeall . png " ) ) ) ; appendCursor ( Qt :: BlankCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Blank " ) , QIcon ( ) ) ; appendCursor ( Qt :: SplitVCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Split ▁ Vertical " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - vsplit . png " ) ) ) ; appendCursor ( Qt :: SplitHCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Split ▁ Horizontal " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - hsplit . png " ) ) ) ; appendCursor ( Qt :: PointingHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Pointing ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - hand . png " ) ) ) ; appendCursor ( Qt :: ForbiddenCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Forbidden " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - forbidden . png " ) ) ) ; appendCursor ( Qt :: OpenHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Open ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - openhand . png " ) ) ) ; appendCursor ( Qt :: ClosedHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Closed ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - closedhand . png " ) ) ) ; appendCursor ( Qt :: WhatsThis@@ Cursor , QCoreApplication :: translate ( " QtCursorDatabase " , " What ' s ▁ This " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - whatsth@@ is . png " ) ) ) ; appendCursor ( Qt :: BusyCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Busy " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - busy . png " ) ) ) ; } void QtCursorDatabase :: clear ( ) { m_cursorNames . clear ( ) ; m_cursorIcons . clear ( ) ; m_valueToCursorShape . clear ( ) ; m_cursorShapeToValue . clear ( ) ; } void QtCursorDatabase :: appendCursor ( Qt :: CursorShape shape , const QString & name , const QIcon & icon ) { if ( m_cursorShapeToValue . contains ( shape ) ) return ; const int value = m_cursorNames . count ( ) ; m_cursorNames . append ( name ) ; m_cursorIcons . insert ( value , icon ) ; m_valueToCursorShape . insert ( value , shape ) ; m_cursorShapeToValue . insert ( shape , value ) ; } QStringList QtCursorDatabase :: cursorShapeNames ( ) const { return m_cursorNames ; } QMap < int , QIcon > QtCursorDatabase :: cursorShapeIcons ( ) const { return m_cursorIcons ; } QString QtCursorDatabase :: cursorToShapeName ( const QCursor & cursor ) const { int val = cursorToValue ( cursor ) ; if ( val >= 0 ) return m_cursorNames . at ( val ) ; return QString ( ) ; } QIcon QtCursorDatabase :: cursorToShapeIcon ( const QCursor & cursor ) const { int val = cursorToValue ( cursor ) ; return m_cursorIcons . value ( val ) ; } int QtCursorDatabase :: cursorToValue ( const QCursor & cursor ) const { # ifndef QT_NO_CURSOR Qt :: CursorShape shape = cursor . shape ( ) ; if ( m_cursorShapeToValue . contains ( shape ) ) return m_cursorShapeToValue [ shape ] ; # endif return - 1 ; } # ifndef QT_NO_CURSOR QCursor QtCursorDatabase :: valueToCursor ( int value ) const { if ( m_valueToCursorShape . contains ( value ) ) return QCursor ( m_valueToCursorShape [ value ] ) ; return QCursor ( ) ; } # endif QPixmap QtPropertyBrowserUtils :: brushValuePixmap ( const QBrush & b ) { QImage img ( 16 , 16 , QImage :: Format_ARGB32_Premultiplied ) ; img . fill ( 0 ) ; QPainter painter ( & img ) ; painter . setCompositionMode ( QPainter :: CompositionMode@@ _Source ) ; painter . fillRect ( 0 , 0 , img . width ( ) , img . height ( ) , b ) ; QColor color = b . color ( ) ; if ( color . alpha ( ) != 255 ) { QBrush opaqueBrush = b ; color . setAlpha ( 255 ) ; opaqueBrush . setColor ( color ) ; painter . fillRect ( img . width ( ) / 4 , img . height ( ) / 4 , img . width ( ) / 2 , img . height ( ) / 2 , opaqueBrush ) ; } painter . end ( ) ; return QPixmap :: fromImage ( img ) ; } QIcon QtPropertyBrowserUtils :: brushValueIcon ( const QBrush & b ) { return QIcon ( brushValuePixmap ( b ) ) ; } QString QtPropertyBrowserUtils :: colorValueText ( const QColor & c ) { return QCoreApplication :: translate ( " QtPropertyBrowserUtils " , " [ %1 , ▁ % 2 , ▁ % 3 ] ▁ ( %4 ) " ) . arg ( c . red ( ) ) . arg ( c . green ( ) ) . arg ( c . blue ( ) ) . arg ( c . alpha ( ) ) ; } QPixmap QtPropertyBrowserUtils :: fontValuePixmap ( const QFont & font ) { QFont f = font ; QImage img ( 16 , 16 , QImage :: Format_ARGB32_Premultiplied ) ; img . fill ( 0 ) ; QPainter p ( & img ) ; p . setRenderHint ( QPainter :: TextAntialiasing , true ) ; p . setRenderHint ( QPainter :: Antialiasing , true ) ; f . setPointSize ( 13 ) ; p . setFont ( f ) ; QTextOption t ; t . setAlignment ( Qt :: AlignCenter ) ; p . drawText ( QRect ( 0 , 0 , 16 , 16 ) , QString ( QLatin1Char ( ' A ' ) ) , t ) ; return QPixmap :: fromImage ( img ) ; } QIcon QtPropertyBrowserUtils :: fontValueIcon ( const QFont & f ) { return QIcon ( fontValuePixmap ( f ) ) ; } QString QtPropertyBrowserUtils :: fontValueText ( const QFont & f ) { return QCoreApplication :: translate ( " QtPropertyBrowserUtils " , " [ %1 , ▁ % 2 ] " ) . arg ( f . family ( ) ) . arg ( f . pointSize ( ) ) ; } QtBoolEdit :: QtBoolEdit ( QWidget * parent ) : QWidget ( parent ) , m_checkBox ( new QCheckBox ( this ) ) , m_textVisible ( true ) { QHBoxLayout * lt = new QHBoxLayout ; if ( QApplication :: layoutDirection ( ) == Qt :: LeftToRight ) lt -> setContentsMargins ( 4 , 0 , 0 , 0 ) ; else lt -> setContentsMargins ( 0 , 0 , 4 , 0 ) ; lt -> addWidget ( m_checkBox ) ; setLayout ( lt ) ; connect ( m_checkBox , SIGNAL ( toggled ( bool ) ) , this , SIGNAL ( toggled ( bool ) ) ) ; setFocusProxy ( m_checkBox ) ; m_checkBox -> setText ( tr ( " True " ) ) ; } void QtBoolEdit :: setTextVisible ( bool textVisible ) { if ( m_textVisible == textVisible ) return ; m_textVisible = textVisible ; if ( m_textVisible ) m_checkBox -> setText ( isChecked ( ) ? tr ( " True " ) : tr ( " False " ) ) ; else m_checkBox -> setText ( QString ( ) ) ; } Qt :: CheckState QtBoolEdit :: checkState ( ) const { return m_checkBox -> checkState ( ) ; } void QtBoolEdit :: setCheckState ( Qt :: CheckState state ) { m_checkBox -> setCheckState ( state ) ; } bool QtBoolEdit :: isChecked ( ) const { return m_checkBox -> isChecked ( ) ; } void QtBoolEdit :: setChecked ( bool c ) { m_checkBox -> setChecked ( c ) ; if ( ! m_textVisible ) return ; m_checkBox -> setText ( isChecked ( ) ? tr ( " True " ) : tr ( " False " ) ) ; } bool QtBoolEdit :: blockCheckBox@@ Signals ( bool block ) { return m_checkBox -> blockSignals ( block ) ; } void QtBoolEdit :: mousePressEvent ( QMouseEvent * event ) { if ( event -> buttons ( ) == Qt :: LeftButton ) { m_checkBox -> click ( ) ; event -> accept ( ) ; } else { QWidget :: mousePressEvent ( event ) ; } } void QtBoolEdit :: paintEvent ( QPaintEvent * ) { QStyleOption opt ; opt . init ( this ) ; QPainter p ( this ) ; style ( ) -> drawPrimitive ( QStyle :: PE_Widget , & opt , & p , this ) ; } QtKeySequenceEdit :: QtKeySequenceEdit ( QWidget * parent ) : QWidget ( parent ) , m_num ( 0 ) , m_lineEdit ( new QLineEdit ( this ) ) { QHBoxLayout * layout = new QHBoxLayout ( this ) ; layout -> addWidget ( m_lineEdit ) ; layout -> setMargin ( 0 ) ; m_lineEdit -> installEventFilter ( this ) ; m_lineEdit -> setReadOnly ( true ) ; m_lineEdit -> setFocusProxy ( this ) ; setFocusPolicy ( m_lineEdit -> focusPolicy ( ) ) ; setAttribute ( Qt :: WA_InputMethod@@ Enabled ) ; } bool QtKeySequenceEdit :: eventFilter ( QObject * o , QEvent * e ) { if ( o == m_lineEdit && e -> type ( ) == QEvent :: ContextMenu ) { QContextMenuEvent * c = static_cast < QContextMenuEvent * > ( e ) ; QMenu * menu = m_lineEdit -> createStandard@@ ContextMenu ( ) ; const QList < QAction * > actions = menu -> actions ( ) ; QListIterator < QAction * > itAction ( actions ) ; while ( itAction . hasNext ( ) ) { QAction * action = itAction . next ( ) ; action -> setShortcut ( QKeySequence ( ) ) ; QString actionString = action -> text ( ) ; const int pos = actionString . lastIndexOf ( QLatin1Char ( ' \t ' ) ) ; if ( pos > 0 ) actionString . remove ( pos , actionString . length ( ) - pos ) ; action -> setText ( actionString ) ; } QAction * actionBefore = 0 ; if ( actions . count ( ) > 0 ) actionBefore = actions [ 0 ] ; QAction * clearAction = new QAction ( tr ( " Clear ▁ Shortcut " ) , menu ) ; menu -> insertAction ( actionBefore , clearAction ) ; menu -> insertSeparator ( actionBefore ) ; clearAction -> setEnabled ( ! m_keySequence . isEmpty ( ) ) ; connect ( clearAction , SIGNAL ( triggered ( ) ) , this , SLOT ( slotClearShortcut ( ) ) ) ; menu -> exec ( c -> globalPos ( ) ) ; delete menu ; e -> accept ( ) ; return true ; } return QWidget :: eventFilter ( o , e ) ; } void QtKeySequenceEdit :: slotClearShortcut ( ) { if ( m_keySequence . isEmpty ( ) ) return ; setKeySequence ( QKeySequence ( ) ) ; emit keySequenceChanged ( m_keySequence ) ; } void QtKeySequenceEdit :: handleKeyEvent ( QKeyEvent * e ) { int nextKey = e -> key ( ) ; if ( nextKey == Qt :: Key_Control || nextKey == Qt :: Key_Shift || nextKey == Qt :: Key_Meta || nextKey == Qt :: Key_Alt || nextKey == Qt :: Key_Super_@@ L || nextKey == Qt :: Key_AltGr ) return ; nextKey |= translateModifiers ( e -> modifiers ( ) , e -> text ( ) ) ; int k0 = m_keySequence [ 0 ] ; int k1 = m_keySequence [ 1 ] ; int k2 = m_keySequence [ 2 ] ; int k3 = m_keySequence [ 3 ] ; switch ( m_num ) { case 0 : k0 = nextKey ; k1 = 0 ; k2 = 0 ; k3 = 0 ; break ; case 1 : k1 = nextKey ; k2 = 0 ; k3 = 0 ; break ; case 2 : k2 = nextKey ; k3 = 0 ; break ; case 3 : k3 = nextKey ; break ; default : break ; } ++ m_num ; if ( m_num > 3 ) m_num = 0 ; m_keySequence = QKeySequence ( k0 , k1 , k2 , k3 ) ; m_lineEdit -> setText ( m_keySequence . toString ( QKeySequence :: NativeText ) ) ; e -> accept ( ) ; emit keySequenceChanged ( m_keySequence ) ; } void QtKeySequenceEdit :: setKeySequence ( const QKeySequence & sequence ) { if ( sequence == m_keySequence ) return ; m_num = 0 ; m_keySequence = sequence ; m_lineEdit -> setText ( m_keySequence . toString ( QKeySequence :: NativeText ) ) ; } QKeySequence QtKeySequenceEdit :: keySequence ( ) const { return m_keySequence ; } int QtKeySequenceEdit :: translateModifiers ( Qt :: KeyboardModifiers state , const QString & text ) const { int result = 0 ; if ( ( state & Qt :: ShiftModifier ) && ( text . size ( ) == 0 || ! text . at ( 0 ) . isPrint ( ) || text . at ( 0 ) . isLetter ( ) || text . at ( 0 ) . isSpace ( ) ) ) result |= Qt :: SHIFT ; if ( state & Qt :: ControlModifier ) result |= Qt :: CTRL ; if ( state & Qt :: MetaModifier ) result |= Qt :: META ; if ( state & Qt :: AltModifier ) result |= Qt :: ALT ; return result ; } void QtKeySequenceEdit :: focusInEvent ( QFocusEvent * e ) { m_lineEdit -> event ( e ) ; m_lineEdit -> selectAll ( ) ; QWidget :: focusInEvent ( e ) ; } void QtKeySequenceEdit :: focusOutEvent ( QFocusEvent * e ) { m_num = 0 ; m_lineEdit -> event ( e ) ; QWidget :: focusOutEvent ( e ) ; } void QtKeySequenceEdit :: keyPressEvent ( QKeyEvent * e ) { handleKeyEvent ( e ) ; e -> accept ( ) ; } void QtKeySequenceEdit :: keyRelease@@ Event ( QKeyEvent * e ) { m_lineEdit -> event ( e ) ; } void QtKeySequenceEdit :: paintEvent ( QPaintEvent * ) { QStyleOption opt ; opt . init ( this ) ; QPainter p ( this ) ; style ( ) -> drawPrimitive ( QStyle :: PE_Widget , & opt , & p , this ) ; } bool QtKeySequenceEdit :: event ( QEvent * e ) { if ( e -> type ( ) == QEvent :: Shortcut || e -> type ( ) == QEvent :: Shortcut@@ Override || e -> type ( ) == QEvent :: KeyRelease ) { e -> accept ( ) ; return true ; } return QWidget :: event ( e ) ; } # if QT_VERSION >= 0x040400 QT_END_NAMESPACE # endif </DOCUMENT>
<DOCUMENT_ID="jerrys@@ 12311@@ 1/pcsx2@@ /tree/master/plugins/GSdx_@@ legacy/@@ linux@@ _replay@@ .cpp"> # include " stdafx . h " # include < dlfc@@ n . h > static void * handle ; void help ( ) { fprintf ( stderr , " Loader ▁ gs ▁ file \n " ) ; fprintf ( stderr , " ARG1 ▁ GSdx ▁ plugin \n " ) ; fprintf ( stderr , " ARG2 ▁ . gs ▁ file \n " ) ; fprintf ( stderr , " ARG3 ▁ Ini ▁ directory \n " ) ; if ( handle ) { dlclose ( handle ) ; } exit ( 1 ) ; } char * read_env ( const char * var ) { char * v = getenv ( var ) ; if ( ! v ) { fprintf ( stderr , " Failed ▁ to ▁ get ▁ % s \n " , var ) ; help ( ) ; } return v ; } int main ( int argc , char * argv [ ] ) { if ( argc < 1 ) help ( ) ; char * plugin ; char * gs ; if ( argc > 2 ) { plugin = argv [ 1 ] ; gs = argv [ 2 ] ; } else { plugin = read_env ( " GSDUMP _ SO " ) ; gs = argv [ 1 ] ; } handle = dlopen ( plugin , RTLD_LAZY | RTLD_GLOBAL ) ; if ( handle == NULL ) { fprintf ( stderr , " Failed ▁ to ▁ dlopen ▁ plugin ▁ % s \n " , plugin ) ; help ( ) ; } __attribute__ ( ( stdcall ) ) void ( * GSsetSettingsDir_ptr ) ( const char * ) ; __attribute__ ( ( stdcall ) ) void ( * GSReplay_ptr ) ( char * , int ) ; * ( void * * ) ( & GSsetSettingsDir_ptr ) = dlsym ( handle , " GSsetSettingsDir " ) ; * ( void * * ) ( & GSReplay_ptr ) = dlsym ( handle , " GSReplay " ) ; if ( argc == 2 ) { char * ini = read_env ( " GSDUMP _ CONF " ) ; GSsetSettingsDir_ptr ( ini ) ; } else if ( argc == 4 ) { ( void ) GSsetSettingsDir_ptr ( argv [ 3 ] ) ; } else if ( argc == 3 ) { # ifdef XDG_STD char * val = read_env ( " HOME " ) ; std :: string ini_dir ( val ) ; ini_dir += " / . config / pcsx2 / inis " ; GSsetSettingsDir_ptr ( ini_dir . c_str ( ) ) ; # else fprintf ( stderr , " default ▁ ini ▁ dir ▁ only ▁ supported ▁ on ▁ XDG \n " ) ; help ( ) ; # endif } GSReplay_ptr ( gs , 12 ) ; if ( handle ) { dlclose ( handle ) ; } } </DOCUMENT>
<DOCUMENT_ID="Tomcc@@ /dolphin/tree/master/Source/Core/Core/HW/EXI/EX@@ I_Device@@ AGP.cpp"> # include " Core / HW / EXI / EXI _ DeviceAGP . h " # include < algorithm > # include < memory > # include < string > # include < vector > # include " Common / ChunkFile . h " # include " Common / CommonTypes . h " # include " Common / File . h " # include " Common / Logging / Log . h " # include " Common / StringUtil . h " # include " Core / ConfigManager . h " namespace Expansion@@ Interface { CEXIAgp :: CEXIAgp ( int index ) { m_slot = index ; m_rom_size = 0 ; LoadRom ( ) ; m_address = 0 ; } CEXIAgp :: ~ CEXIAgp ( ) { std :: string path ; std :: string filename ; std :: string ext ; std :: string gbapath ; SplitPath ( m_slot == 0 ? SConfig :: GetInstance ( ) . m_strGbaCartA : SConfig :: GetInstance ( ) . m_strGbaCartB , & path , & filename , & ext ) ; gbapath = path + filename ; SaveFileFromEEPROM ( gbapath + " . sav " ) ; } void CEXIAgp :: CRC8 ( const u8 * data , u32 size ) { for ( u32 it = 0 ; it < size ; it ++ ) { u8 crc = 0 ; m_hash = m_hash ^ data [ it ] ; if ( m_hash & 1 ) crc ^= 0x5e ; if ( m_hash & 2 ) crc ^= 0xbc ; if ( m_hash & 4 ) crc ^= 0x61 ; if ( m_hash & 8 ) crc ^= 0xc2 ; if ( m_hash & 0x10 ) crc ^= 0x9d ; if ( m_hash & 0x20 ) crc ^= 0x23 ; if ( m_hash & 0x40 ) crc ^= 0x46 ; if ( m_hash & 0x80 ) crc ^= 0x8c ; m_hash = crc ; } } void CEXIAgp :: LoadRom ( ) { std :: string path ; std :: string filename ; std :: string ext ; std :: string gbapath ; SplitPath ( m_slot == 0 ? SConfig :: GetInstance ( ) . m_strGbaCartA : SConfig :: GetInstance ( ) . m_strGbaCartB , & path , & filename , & ext ) ; gbapath = path + filename ; LoadFileToROM ( gbapath + ext ) ; INFO_LOG ( EXPANSIONINTERFACE , " Loaded ▁ GBA ▁ rom : ▁ % s ▁ card : ▁ % d " , gbapath . c_str ( ) , m_slot ) ; LoadFileToEEPROM ( gbapath + " . sav " ) ; INFO_LOG ( EXPANSIONINTERFACE , " Loaded ▁ GBA ▁ sav : ▁ % s ▁ card : ▁ % d " , gbapath . c_str ( ) , m_slot ) ; } void CEXIAgp :: LoadFileToROM ( const std :: string & filename ) { File :: IOFile pStream ( filename , " rb " ) ; if ( pStream ) { u64 filesize = pStream . GetSize ( ) ; m_rom_size = filesize & 0xFFFFFFFF ; m_rom_mask = ( m_rom_size - 1 ) ; m_rom . resize ( m_rom_size ) ; pStream . ReadBytes ( m_rom . data ( ) , filesize ) ; } else { m_rom . resize ( 0x2000 ) ; } } void CEXIAgp :: LoadFileToEEPROM ( const std :: string & filename ) { File :: IOFile pStream ( filename , " rb " ) ; if ( pStream ) { u64 filesize = pStream . GetSize ( ) ; m_eeprom_size = filesize & 0xFFFFFFFF ; m_eeprom_mask = ( m_eeprom_size - 1 ) ; m_eeprom . resize ( m_eeprom_size ) ; pStream . ReadBytes ( m_eeprom . data ( ) , filesize ) ; if ( ( m_eeprom_size == 512 ) || ( m_eeprom_size == 8192 ) ) { for ( u32 index = 0 ; index < ( m_eeprom_size / 8 ) ; index ++ ) { u64 NewVal = 0 ; for ( u32 indexb = 0 ; indexb < 8 ; indexb ++ ) NewVal = ( NewVal << 0x8 ) | m_eeprom [ index * 8 + indexb ] ; ( ( u64 * ) ( m_eeprom . data ( ) ) ) [ index ] = NewVal ; } m_eeprom_add_end = ( m_eeprom_size == 512 ? ( 2 + 6 ) : ( 2 + 14 ) ) ; m_eeprom_add_mask = ( m_eeprom_size == 512 ? 0x3F : 0x3FF ) ; m_eeprom_read_mask = ( m_eeprom_size == 512 ? 0x80 : 0x8000 ) ; m_eeprom_status_mask = ( m_rom_size == 0x2000000 ? 0x1FFFF@@ 00 : 0x1000000 ) ; } else m_eeprom_status_mask = 0 ; } else { m_eeprom_size = 0 ; m_eeprom . clear ( ) ; } } void CEXIAgp :: SaveFileFromEEPROM ( const std :: string & filename ) { File :: IOFile pStream ( filename , " wb " ) ; if ( pStream ) { if ( ( m_eeprom_size == 512 ) || ( m_eeprom_size == 8192 ) ) { std :: vector < u8 > temp_eeprom ( m_eeprom_size ) ; for ( u32 index = 0 ; index < ( m_eeprom_size / 8 ) ; index ++ ) { u64 NewVal = ( ( u64 * ) ( m_eeprom . data ( ) ) ) [ index ] ; for ( u32 indexb = 0 ; indexb < 8 ; indexb ++ ) temp_eeprom [ index * 8 + ( 7 - indexb ) ] = ( NewVal >> ( indexb * 8 ) ) & 0xFF ; } pStream . WriteBytes ( temp_eeprom . data ( ) , m_eeprom_size ) ; } else { pStream . WriteBytes ( m_eeprom . data ( ) , m_eeprom_size ) ; } } } u32 CEXIAgp :: ImmRead ( u32 _uSize ) { u32 uData = 0 ; u8 RomVal1 , RomVal2 , RomVal3 , RomVal4 ; switch ( m_current_cmd ) { case 0xAE000000 : uData = 0x5AA@@ A5517 ; m_current_cmd = 0 ; break ; case 0xAE010000 : uData = ( m_return_pos == 0 ) ? 0x01020304 : 0xF0020304 ; if ( m_return_pos == 1 ) m_current_cmd = 0 ; else m_return_pos = 1 ; break ; case 0xAE020000 : if ( m_eeprom_write_status && ( ( m_rw_offset & m_eeprom_status_mask ) == m_eeprom_status_mask ) && ( m_eeprom_status_mask != 0 ) ) { RomVal1 = 0x1 ; RomVal2 = 0x0 ; } else { RomVal1 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal2 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; } CRC8 ( & RomVal2 , 1 ) ; CRC8 ( & RomVal1 , 1 ) ; uData = ( RomVal2 << 24 ) | ( RomVal1 << 16 ) | ( m_hash << 8 ) ; m_current_cmd = 0 ; break ; case 0xAE030000 : if ( _uSize == 1 ) { uData = 0xFF000000 ; m_current_cmd = 0 ; } else { RomVal1 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal2 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal3 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal4 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; CRC8 ( & RomVal2 , 1 ) ; CRC8 ( & RomVal1 , 1 ) ; CRC8 ( & RomVal4 , 1 ) ; CRC8 ( & RomVal3 , 1 ) ; uData = ( RomVal2 << 24 ) | ( RomVal1 << 16 ) | ( RomVal4 << 8 ) | ( RomVal3 ) ; } break ; case 0xAE040000 : if ( m_eeprom_size == 0 ) RomVal1 = 0xFF ; else RomVal1 = ( m_eeprom . data ( ) ) [ m_eeprom_pos ] ; CRC8 ( & RomVal1 , 1 ) ; uData = ( RomVal1 << 24 ) | ( m_hash << 16 ) ; m_current_cmd = 0 ; break ; case 0xAE0B0000 : RomVal1 = EE_READ_FALSE ; if ( ( m_eeprom_size != 0 ) && ( m_eeprom_pos >= EE_IGNORE_BITS ) && ( ( ( ( u64 * ) m_eeprom . data ( ) ) [ ( m_eeprom_cmd >> 1 ) & m_eeprom_add_mask ] ) >> ( ( EE_DATA_BITS - 1 ) - ( m_eeprom_pos - EE_IGNORE_BITS ) ) ) & 0x1 ) { RomVal1 = EE_READ_TRUE ; } RomVal2 = 0 ; CRC8 ( & RomVal2 , 1 ) ; CRC8 ( & RomVal1 , 1 ) ; uData = ( RomVal2 << 24 ) | ( RomVal1 << 16 ) | ( m_hash << 8 ) ; m_eeprom_pos ++ ; m_current_cmd = 0 ; break ; case 0xAE070000 : case 0xAE0C0000 : uData = m_hash << 24 ; m_current_cmd = 0 ; break ; default : uData = 0x0 ; m_current_cmd = 0 ; break ; } DEBUG_LOG ( EXPANSIONINTERFACE , " AGP ▁ read ▁ % x " , uData ) ; return uData ; } void CEXIAgp :: ImmWrite ( u32 _uData , u32 _uSize ) { if ( ( _uSize == 1 ) && ( ( _uData & 0xFF000000 ) == 0 ) ) return ; u8 HashCmd ; u64 Mask ; DEBUG_LOG ( EXPANSIONINTERFACE , " AGP ▁ command ▁ % x " , _uData ) ; switch ( m_current_cmd ) { case 0xAE020000 : case 0xAE030000 : m_rw_offset = ( ( _uData & 0xFFFFFF00 ) >> ( 8 - 1 ) ) ; m_return_pos = 0 ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x0000FF00 ) >> 8 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE040000 : m_eeprom_pos = ( ( _uData & 0xFFFF0000 ) >> 0x10 ) & m_eeprom_mask ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE070000 : m_eeprom_pos = ( ( _uData & 0xFFFF0000 ) >> 0x10 ) & m_eeprom_mask ; if ( m_eeprom_size != 0 ) ( ( m_eeprom . data ( ) ) ) [ ( m_eeprom_pos ) ] = ( _uData & 0x0000FF00 ) >> 0x8 ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x0000FF00 ) >> 8 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE0C0000 : if ( ( m_eeprom_pos < m_eeprom_add_end ) || ( m_eeprom_pos == ( ( m_eeprom_cmd & m_eeprom_read_mask ) ? m_eeprom_add_end : m_eeprom_add_end + EE_DATA_BITS ) ) ) { Mask = ( 1ULL << ( m_eeprom_add_end - std :: min ( m_eeprom_pos , m_eeprom_add_end ) ) ) ; if ( ( _uData >> 16 ) & 0x1 ) m_eeprom_cmd |= Mask ; else m_eeprom_cmd &= ~ Mask ; if ( m_eeprom_pos == m_eeprom_add_end + EE_DATA_BITS ) { if ( m_eeprom_size != 0 ) ( ( u64 * ) ( m_eeprom . data ( ) ) ) [ ( m_eeprom_cmd >> 1 ) & m_eeprom_add_mask ] = m_eeprom_data ; m_eeprom_write_status = true ; } } else { Mask = ( 1ULL << ( m_eeprom_add_end + EE_DATA_BITS - 1 - m_eeprom_pos ) ) ; if ( ( _uData >> 16 ) & 0x1 ) m_eeprom_data |= Mask ; else m_eeprom_data &= ~ Mask ; } m_eeprom_pos ++ ; m_return_pos = 0 ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE0B0000 : m_eeprom_write_status = false ; break ; case 0xAE000000 : case 0xAE010000 : case 0xAE090000 : m_eeprom_write_status = false ; case 0xAE0A0000 : m_eeprom_pos = 0 ; default : m_current_cmd = _uData ; m_return_pos = 0 ; m_hash = 0xFF ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; break ; } } void CEXIAgp :: DoState ( PointerWrap & p ) { p . Do ( m_slot ) ; p . Do ( m_address ) ; p . Do ( m_current_cmd ) ; p . Do ( m_eeprom ) ; p . Do ( m_eeprom_cmd ) ; p . Do ( m_eeprom_data ) ; p . Do ( m_eeprom_mask ) ; p . Do ( m_eeprom_pos ) ; p . Do ( m_eeprom_size ) ; p . Do ( m_eeprom_add_end ) ; p . Do ( m_eeprom_add_mask ) ; p . Do ( m_eeprom_read_mask ) ; p . Do ( m_eeprom_status_mask ) ; p . Do ( m_eeprom_write_status ) ; p . Do ( m_hash ) ; p . Do ( m_position ) ; p . Do ( m_return_pos ) ; p . Do ( m_rom ) ; p . Do ( m_rom_mask ) ; p . Do ( m_rom_size ) ; p . Do ( m_rw_offset ) ; } } </DOCUMENT>
<DOCUMENT_ID="kzh@@ ong199@@ 1/Flight@@ -AR.Drone@@ -2/tree/master/src/3rdparty/@@ Qt4.@@ 8.4/src/3rdparty/@@ webkit/Source/WebCore/platform/graphics/@@ mac/GlyphPageTree@@ NodeMac.cpp"> # include " config . h " # include " GlyphPageTreeNode . h " # include " Font . h " # include " SimpleFontData . h " # include " WebCoreSystemInterface . h " # include < ApplicationServices / ApplicationServices . h > namespace WebCore { static bool shouldUseCoreText ( UChar * buffer , unsigned bufferLength , const SimpleFontData * fontData ) { if ( fontData -> platformData ( ) . widthVariant ( ) != Regular@@ Width || fontData -> hasVerticalGlyphs ( ) ) { for ( unsigned i = 0 ; i < bufferLength ; ++ i ) { if ( ! Font :: isCJKIdeograph ( buffer [ i ] ) ) return true ; } } return false ; } bool GlyphPage :: fill ( unsigned offset , unsigned length , UChar * buffer , unsigned bufferLength , const SimpleFontData * fontData ) { bool haveGlyphs = false ; if ( ! shouldUseCoreText ( buffer , bufferLength , fontData ) ) { Vector < CGGlyph , 512 > glyphs ( bufferLength ) ; wkGetGlyphsFor@@ Characters ( fontData -> platformData ( ) . cgFont ( ) , buffer , glyphs . data ( ) , bufferLength ) ; for ( unsigned i = 0 ; i < length ; ++ i ) { if ( ! glyphs [ i ] ) setGlyphDataForIndex ( offset + i , 0 , 0 ) ; else { setGlyphDataForIndex ( offset + i , glyphs [ i ] , fontData ) ; haveGlyphs = true ; } } } else { RetainPtr < CFStringRef > string ( AdoptCF , CFStringCreateWith@@ CharactersNo@@ Copy ( kCFAllocatorDefault , buffer , bufferLength , kCFAllocatorNull ) ) ; RetainPtr < CFAttributedStringRef > attributedString ( AdoptCF , CFAttributedStringCreate ( kCFAllocatorDefault , string . get ( ) , fontData -> getCFStringAttributes ( 0 , fontData -> hasVerticalGlyphs ( ) ? Vertical : Horizontal ) ) ) ; RetainPtr < CTLineRef > line ( AdoptCF , CTLineCreateWith@@ AttributedString ( attributedString . get ( ) ) ) ; CFArrayRef runArray = CTLineGetGlyphRuns ( line . get ( ) ) ; CFIndex runCount = CFArrayGetCount ( runArray ) ; for ( unsigned index = 0 ; index < length ; ++ index ) setGlyphDataForIndex ( offset + index , 0 , 0 ) ; Vector < CGGlyph , 512 > glyphVector ; Vector < CFIndex , 512 > indexVector ; bool done = false ; RetainPtr < CGFontRef > cgFont ( AdoptCF , CTFontCopyGraphicsFont ( fontData -> platformData ( ) . ctFont ( ) , 0 ) ) ; for ( CFIndex r = 0 ; r < runCount && ! done ; ++ r ) { CTRunRef ctRun = static_cast < CTRunRef > ( CFArrayGetValueAtIndex ( runArray , r ) ) ; ASSERT ( CFGetTypeID ( ctRun ) == CTRunGetTypeID ( ) ) ; CFDictionaryRef attributes = CTRunGetAttributes ( ctRun ) ; CTFontRef runFont = static_cast < CTFontRef > ( CFDictionaryGetValue ( attributes , kCTFontAttributeName ) ) ; RetainPtr < CGFontRef > runCGFont ( AdoptCF , CTFontCopyGraphicsFont ( runFont , 0 ) ) ; if ( CFEqual ( cgFont . get ( ) , runCGFont . get ( ) ) ) { CFIndex glyphCount = CTRunGetGlyphCount ( ctRun ) ; const CGGlyph * glyphs = CTRunGetGlyphsPtr ( ctRun ) ; if ( ! glyphs ) { glyphVector . resize ( glyphCount ) ; CTRunGetGlyphs ( ctRun , CFRangeMake ( 0 , 0 ) , glyphVector . data ( ) ) ; glyphs = glyphVector . data ( ) ; } const CFIndex * stringIndices = CTRunGetStringIndices@@ Ptr ( ctRun ) ; if ( ! stringIndices ) { indexVector . resize ( glyphCount ) ; CTRunGetStringIndices ( ctRun , CFRangeMake ( 0 , 0 ) , indexVector . data ( ) ) ; stringIndices = indexVector . data ( ) ; } for ( CFIndex i = 0 ; i < glyphCount ; ++ i ) { if ( stringIndices [ i ] >= static_cast < CFIndex > ( length ) ) { done = true ; break ; } if ( glyphs [ i ] ) { setGlyphDataForIndex ( offset + stringIndices [ i ] , glyphs [ i ] , fontData ) ; haveGlyphs = true ; } } } } } return haveGlyphs ; } } </DOCUMENT>
<DOCUMENT_ID="ond@@ ra-novak/blink@@ /tree/master/Source/core/svg/@@ SVGFontFaceUriElement.cpp"> # include " config . h " # if ENABLE ( SVG_FON@@ TS ) # include " core / svg / SVGFontFaceUriElement . h " # include " core / XLinkNames . h " # include " core / css / CSSFontFaceSrcValue . h " # include " core / dom / Document . h " # include " core / fetch / FetchRequest . h " # include " core / fetch / ResourceFetcher . h " # include " core / svg / SVGFontFaceElement . h " namespace blink { using namespace SVGN@@ ames ; inline SVGFontFaceUriElement :: SVGFontFaceUriElement ( Document & document ) : SVGElement ( font_face_uriTag , document ) { ScriptWrappable :: init ( this ) ; } DEFINE_NODE_FACTORY ( SVGFontFaceUriElement ) SVGFontFaceUriElement :: ~ SVGFontFaceUriElement ( ) { if ( m_resource ) m_resource -> removeClient ( this ) ; } PassRefPtrWillBeRawPtr < CSSFontFaceSrcValue > SVGFontFaceUriElement :: srcValue ( ) const { RefPtrWillBeRawPtr < CSSFontFaceSrcValue > src = CSSFontFaceSrcValue :: create ( getAttribute ( XLinkNames :: hrefAttr ) ) ; AtomicString value ( fastGetAttribute ( formatAttr ) ) ; src -> setFormat ( value . isEmpty ( ) ? " svg " : value ) ; return src . release ( ) ; } void SVGFontFaceUriElement :: parseAttribute ( const QualifiedName & name , const AtomicString & value ) { if ( name . matches ( XLinkNames :: hrefAttr ) ) loadFont ( ) ; else SVGElement :: parseAttribute ( name , value ) ; } void SVGFontFaceUriElement :: childrenChanged ( const ChildrenChange & change ) { SVGElement :: childrenChanged ( change ) ; if ( ! isSVGFontFaceSrcElement ( parentNode ( ) ) ) return ; ContainerNode * grandparent = parentNode ( ) -> parentNode ( ) ; if ( isSVGFontFaceElement ( grandparent ) ) toSVGFontFaceElement ( * grandparent ) . rebuildFontFace ( ) ; } Node :: InsertionNotificationRequest SVGFontFaceUriElement :: insertedInto ( ContainerNode * rootParent ) { loadFont ( ) ; return SVGElement :: insertedInto ( rootParent ) ; } void SVGFontFaceUriElement :: loadFont ( ) { if ( m_resource ) m_resource -> removeClient ( this ) ; const AtomicString & href = getAttribute ( XLinkNames :: hrefAttr ) ; if ( ! href . isNull ( ) ) { ResourceFetcher * fetcher = document ( ) . fetcher ( ) ; FetchRequest request ( ResourceRequest ( document ( ) . completeURL ( href ) ) , localName ( ) ) ; m_resource = fetcher -> fetchFont ( request ) ; if ( m_resource ) { m_resource -> addClient ( this ) ; m_resource -> beginLoadIf@@ Needed ( fetcher ) ; } } else { m_resource = 0 ; } } } # endif </DOCUMENT>
