<DOCUMENT_ID="qt@@ project/qtwebk@@ it/tree/master/Source/WebCore/html/@@ HTMLFrameSetElement.cpp"> # include " config . h " # include " HTMLFrameSetElement . h " # include " CSSPropertyNames . h " # include " Document . h " # include " ElementIterator . h " # include " Event . h " # include " EventNames . h " # include " Frame . h " # include " FrameLoader . h " # include " FrameLoader@@ Client . h " # include " HTMLBodyElement . h " # include " HTMLNames . h " # include " Length . h " # include " MouseEvent . h " # include " RenderFrameSet . h " # include " Text . h " namespace WebCore { using namespace HTMLNames ; HTMLFrameSetElement :: HTMLFrameSetElement ( const QualifiedName & tagName , Document & document ) : HTMLElement ( tagName , document ) , m_totalRows ( 1 ) , m_totalCols ( 1 ) , m_border ( 6 ) , m_borderSet ( false ) , m_borderColorSet ( false ) , m_frameborder ( true ) , m_frameborderSet ( false ) , m_noresize ( false ) { ASSERT ( hasTagName ( framesetTag ) ) ; setHasCustomStyleResolveCallbacks ( ) ; } Ref < HTMLFrameSetElement > HTMLFrameSetElement :: create ( const QualifiedName & tagName , Document & document ) { return adoptRef ( * new HTMLFrameSetElement ( tagName , document ) ) ; } bool HTMLFrameSetElement :: isPresentationAttribute ( const QualifiedName & name ) const { if ( name == bordercolorAttr ) return true ; return HTMLElement :: isPresentationAttribute ( name ) ; } void HTMLFrameSetElement :: collectStyleForPresentationAttribute ( const QualifiedName & name , const AtomicString & value , MutableStyleProperties & style ) { if ( name == bordercolorAttr ) addHTMLColorToStyle ( style , CSSPropertyBorderColor , value ) ; else HTMLElement :: collectStyleForPresentationAttribute ( name , value , style ) ; } void HTMLFrameSetElement :: parseAttribute ( const QualifiedName & name , const AtomicString & value ) { if ( name == rowsAttr ) { if ( ! value . isNull ( ) ) { m_rowLengths = newLengthArray ( value . string ( ) , m_totalRows ) ; setNeedsStyleRecalc ( ) ; } return ; } if ( name == colsAttr ) { if ( ! value . isNull ( ) ) { m_colLengths = newLengthArray ( value . string ( ) , m_totalCols ) ; setNeedsStyleRecalc ( ) ; } return ; } if ( name == frameborderAttr ) { if ( ! value . isNull ( ) ) { if ( equalLettersIgnoringASCIICase ( value , " no " ) || value == "0" ) { m_frameborder = false ; m_frameborderSet = true ; } else if ( equalLettersIgnoringASCIICase ( value , " yes " ) || value == "1" ) { m_frameborderSet = true ; } } else { m_frameborder = false ; m_frameborderSet = false ; } return ; } if ( name == noresizeAttr ) { m_noresize = true ; return ; } if ( name == borderAttr ) { if ( ! value . isNull ( ) ) { m_border = value . toInt ( ) ; m_borderSet = true ; } else m_borderSet = false ; return ; } if ( name == bordercolorAttr ) { m_borderColorSet = ! value . isEmpty ( ) ; return ; } auto & eventName = HTMLBodyElement :: eventNameFor@@ WindowEventHandler@@ Attribute ( name ) ; if ( ! eventName . isNull ( ) ) { document ( ) . setWindowAttributeEventListener ( eventName , name , value ) ; return ; } HTMLElement :: parseAttribute ( name , value ) ; } bool HTMLFrameSetElement :: rendererIsNeeded ( const RenderStyle & style ) { return style . isStyleAvailable ( ) ; } RenderPtr < RenderElement > HTMLFrameSetElement :: createElement@@ Renderer ( Ref < RenderStyle > && style , const RenderTreePosition & ) { if ( style . get ( ) . hasContent ( ) ) return RenderElement :: createFor ( * this , WTFMove ( style ) ) ; return createRenderer < RenderFrameSet > ( * this , WTFMove ( style ) ) ; } HTMLFrameSetElement * HTMLFrameSetElement :: findContaining ( Element * descendant ) { return ancestorsOf@@ Type < HTMLFrameSetElement > ( * descendant ) . first ( ) ; } void HTMLFrameSetElement :: willAttachRendere@@ rs ( ) { const HTMLFrameSetElement * containingFrameSet = findContaining ( this ) ; if ( ! containingFrameSet ) return ; if ( ! m_frameborderSet ) m_frameborder = containingFrameSet -> hasFrame@@ Border ( ) ; if ( m_frameborder ) { if ( ! m_borderSet ) m_border = containingFrameSet -> border ( ) ; if ( ! m_borderColorSet ) m_borderColorSet = containingFrameSet -> hasBorderColor ( ) ; } if ( ! m_noresize ) m_noresize = containingFrameSet -> noResize ( ) ; } void HTMLFrameSetElement :: defaultEventHandler ( Event * event ) { ASSERT ( event ) ; if ( is < MouseEvent > ( * event ) && ! m_noresize && is < RenderFrameSet > ( renderer ( ) ) ) { if ( downcast < RenderFrameSet > ( * renderer ( ) ) . userResize ( downcast < MouseEvent > ( event ) ) ) { event -> setDefaultHandled ( ) ; return ; } } HTMLElement :: defaultEventHandler ( event ) ; } bool HTMLFrameSetElement :: willRecalcStyle ( Style :: Change ) { if ( needsStyleRecalc ( ) && renderer ( ) ) { renderer ( ) -> setNeedsLayout ( ) ; clearNeeds@@ StyleRecalc ( ) ; } return true ; } Node :: InsertionNotificationRequest HTMLFrameSetElement :: insertedInto ( ContainerNode & insertionPoint ) { HTMLElement :: insertedInto ( insertionPoint ) ; if ( insertionPoint . inDocument ( ) ) { if ( Frame * frame = document ( ) . frame ( ) ) frame -> loader ( ) . client ( ) . dispatchDidBecomeFrameset ( document ( ) . isFrameSet ( ) ) ; } return InsertionDone ; } void HTMLFrameSetElement :: removedFrom ( ContainerNode & insertionPoint ) { HTMLElement :: removedFrom ( insertionPoint ) ; if ( insertionPoint . inDocument ( ) ) { if ( Frame * frame = document ( ) . frame ( ) ) frame -> loader ( ) . client ( ) . dispatchDidBecomeFrameset ( document ( ) . isFrameSet ( ) ) ; } } } </DOCUMENT>
<DOCUMENT_ID="SlavaRa@@ /coreclr/tree/master/src/binder/variables@@ .cpp"> # include " variables . hpp " # include " ex . h " namespace BINDER@@ _SPACE { # ifdef FEATURE_VERSIONING_LOG namespace { HRESULT CheckFileExistence ( LPCWSTR pwzFile , LPDWORD pdwAttrib ) { HRESULT hr = S_FALSE ; DWORD dwRet = 0 ; _ASSERTE ( pwzFile && pdwAttrib ) ; * pdwAttrib = 0 ; dwRet = WszGetFileAttributes ( pwzFile ) ; if ( dwRet == INVALID_FILE_@@ ATTRIBUTES ) { hr = HRESULT_FROM_GetLastError ( ) ; if ( ( hr == HRESULT_FROM_WIN32 ( ERROR_FILE_NOT_FOUND ) ) || ( hr == HRESULT_FROM_WIN32 ( ERROR_PATH_@@ NOT_FOUND ) ) ) { GO_WITH_HRESULT ( S_FALSE ) ; } } else { * pdwAttrib = dwRet ; GO_WITH_HRESULT ( S_OK ) ; } Exit : return hr ; } } ; # endif Variables * g_Bin@@ derVariables = NULL ; Variables :: Variables ( ) { } Variables :: ~ Variables ( ) { } HRESULT Variables :: Init ( ) { HRESULT hr = S_OK ; EX_TR@@ Y { httpURL@@ Prefix . SetLiteral ( W ( " http : // " ) ) ; architectureMSIL . SetLiteral ( W ( " MSIL " ) ) ; architectureX86 . SetLiteral ( W ( " x86" ) ) ; architectureAMD@@ 64 . SetLiteral ( W ( " AMD64" ) ) ; architectureARM . SetLiteral ( W ( " ARM " ) ) ; architectureARM64 . SetLiteral ( W ( " ARM64" ) ) ; cultureNeutral . SetLiteral ( W ( " neutral " ) ) ; mscorlib . SetLiteral ( W ( " mscorlib " ) ) ; emptyString . Clear ( ) ; # ifdef FEATURE_VERSIONING_LOG REGUTIL :: CORConfigLevel kCorConfigLevel = static_cast < REGUTIL :: CORConfigLevel > ( REGUTIL :: COR_CONFIG_ENV | REGUTIL :: COR_CONFIG_FUSION ) ; DWORD dwLoggingNeeded = REGUTIL :: GetConfigDWORD_@@ DontUse_ ( CLRConfig :: EXTERNAL_Force@@ Log , 0 , kCorConfigLevel , TRUE ) ; fLoggingNeeded = ( dwLoggingNeeded ? TRUE : FALSE ) ; NewArrayHolder < WCHAR > pwzLogDirectory = REGUTIL :: GetConfigString_DontUse_ ( CLRConfig :: INTERNAL_@@ LogPath , TRUE , kCorConfigLevel , FALSE ) ; if ( pwzLogDirectory == NULL ) { fLoggingNeeded = FALSE ; } else { DWORD dwAttr = 0 ; hr = CheckFileExistence ( pwzLogDirectory , & dwAttr ) ; if ( ( hr == S_OK ) && ( ( dwAttr & FILE_ATTRIBUTE_DIREC@@ TORY ) != 0 ) ) { logPath . Set ( pwzLogDirectory ) ; } else { hr = S_OK ; fLoggingNeeded = FALSE ; } } # endif } EX_C@@ ATCH_HRESULT ( hr ) ; return hr ; } } ; </DOCUMENT>
<DOCUMENT_ID="Yel@@ aSeamless@@ /mysql-server/tree/master/storage/ndb@@ /test/ndb@@ api/testLim@@ its.cpp"> # include < NDBT . hpp > # include < NDBT_Test . hpp > # include < NdbRestarter . hpp > # define CHECKNOTNULL ( p ) if ( ( p ) == NULL ) { ndbout << " Error ▁ at ▁ line ▁ " << __LINE__ << endl ; NDB_ERR ( trans -> getNdbError ( ) ) ; trans -> close ( ) ; return NDBT_FAILED ; } # define CHECKEQUAL ( v , e ) if ( ( e ) != ( v ) ) { ndbout << " Error ▁ at ▁ line ▁ " << __LINE__ << " ▁ expected ▁ " << v << endl ; NDB_ERR ( trans -> getNdbError ( ) ) ; trans -> close ( ) ; return NDBT_FAILED ; } Uint32 setLongVarchar ( char * where , const char * what , Uint32 sz ) { where [ 0 ] = sz & 0xff ; where [ 1 ] = ( sz >> 8 ) & 0xff ; memcpy ( & where [ 2 ] , what , sz ) ; return ( sz + 2 ) ; } int activateErrorInsert ( NdbTransaction * trans , const NdbRecord * record , const NdbDictionary :: Table * tab , const char * buf , NdbRestarter * restarter , Uint32 val ) { if ( restarter -> insertErrorInAllNodes ( val ) != 0 ) { g_err << " error ▁ insert ▁ 1 ▁ ( " << val << " ) ▁ failed " << endl ; return NDBT_FAILED ; } if ( restarter -> insertErrorInAllNodes ( val ) != 0 ) { g_err << " error ▁ insert ▁ 2 ▁ ( " << val << " ) ▁ failed " << endl ; return NDBT_FAILED ; } NdbOperation * insert = trans -> getNdbOperation ( tab ) ; CHECKNOTNULL ( insert ) ; CHECKEQUAL ( 0 , insert -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , insert -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , buf , 0 ) ) ) ; CHECKEQUAL ( 0 , insert -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , buf , 1 ) ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; return NDBT_OK ; } int testSegmentedSectionPk ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " WIDE _ 2COL " ) != 0 ) return NDBT_OK ; const Uint32 maxRowBytes = NDB_MAX_TUPLE_SIZE_IN_WORDS * sizeof ( Uint32 ) ; const Uint32 maxKeyBytes = NDBT_Tables :: MaxVarTypeKeyBytes ; const Uint32 maxAttrBytes = NDBT_Tables :: MaxKeyMaxVarTypeAttrBytes ; const Uint32 srcBuffBytes = MAX ( maxKeyBytes , maxAttrBytes ) ; char smallKey [ 50 ] ; char srcBuff [ srcBuffBytes ] ; char smallRowBuf [ maxRowBytes ] ; char bigKeyRowBuf [ maxRowBytes ] ; char bigAttrRowBuf [ maxRowBytes ] ; Uint32 smallKeySize = setLongVarchar ( & smallKey [ 0 ] , " ShortKey " , 8 ) ; memset ( srcBuff , ' B ' , srcBuffBytes ) ; const NdbRecord * record = ctx -> getTab ( ) -> getDefaultRecord ( ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , smallRowBuf , 0 ) , " ShortKey " , 8 ) ; NdbDictionary :: setNull ( record , smallRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , smallRowBuf , 1 ) , " ShortData " , 9 ) ; NdbDictionary :: setNull ( record , smallRowBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , bigKeyRowBuf , 0 ) , & srcBuff [ 0 ] , maxKeyBytes ) ; NdbDictionary :: setNull ( record , bigKeyRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , bigKeyRowBuf , 1 ) , " ShortData " , 9 ) ; NdbDictionary :: setNull ( record , bigKeyRowBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , bigAttrRowBuf , 0 ) , " ShortKey " , 8 ) ; NdbDictionary :: setNull ( record , bigAttrRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , bigAttrRowBuf , 1 ) , & srcBuff [ 0 ] , maxAttrBytes ) ; NdbDictionary :: setNull ( record , bigAttrRowBuf , 1 , false ) ; NdbRestarter restarter ; Ndb * pNdb = GETNDB ( step ) ; NdbTransaction * trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ; CHECKNOTNULL ( trans ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , record , ctx -> getTab ( ) , smallRowBuf , & restarter , 8065 ) ) ; const NdbOperation * bigInsert = trans -> insertTuple ( record , bigKeyRowBuf ) ; CHECKNOTNULL ( bigInsert ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsert = trans -> insertTuple ( record , bigAttrRowBuf ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsert = trans -> insertTuple ( record , bigAttrRowBuf ) ) ; const NdbOperation * secondOp ; CHECKNOTNULL ( secondOp = trans -> insertTuple ( record , bigAttrRowBuf ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; NdbOperation * bigInsertOldApi ; CHECKNOTNULL ( bigInsertOldApi = trans -> getNdbOperation ( ctx -> getTab ( ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , bigKeyRowBuf , 0 ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , bigKeyRowBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsertOldApi = trans -> getNdbOperation ( ctx -> getTab ( ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , bigAttrRowBuf , 0 ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , bigAttrRowBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; # if 0 restarter . insertErrorInAllNodes ( 8066 ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsertOldApi = trans -> getNdbOperation ( ctx -> getTab ( ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , smallRowBuf , 0 ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; restarter . insertErrorInAllNodes ( 8067 ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsertOldApi = trans -> getNdbOperation ( ctx -> getTab ( ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , smallRowBuf , 0 ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; # endif CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , record , ctx -> getTab ( ) , smallRowBuf , & restarter , 8068 ) ) ; trans -> execute ( NdbTransaction :: Rollback ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; return NDBT_OK ; } int testSegmentedSectionIx ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " WIDE _ 2COL _ IX " ) != 0 ) return NDBT_OK ; const char * indexName = " WIDE _ 2COL _ IX $ NDBT _ IDX0" ; const Uint32 maxRowBytes = NDB_MAX_TUPLE_SIZE_IN_WORDS * sizeof ( Uint32 ) ; const Uint32 srcBuffBytes = NDBT_Tables :: MaxVarTypeKeyBytes ; const Uint32 maxIndexKeyBytes = NDBT_Tables :: MaxKeyMaxVarTypeAttrBytes@@ Index ; const Uint32 mediumPrimaryKeyBytes = ( 6 * 60 * 4 ) - 2 ; char smallKey [ 50 ] ; char srcBuff [ srcBuffBytes ] ; char smallRowBuf [ maxRowBytes ] ; char bigKeyIxBuf [ maxRowBytes ] ; char bigAttrIxBuf [ maxRowBytes ] ; char bigKeyRowBuf [ maxRowBytes ] ; char resultSpace [ maxRowBytes ] ; Uint32 smallKeySize = setLongVarchar ( & smallKey [ 0 ] , " ShortKey " , 8 ) ; memset ( srcBuff , ' B ' , srcBuffBytes ) ; Ndb * pNdb = GETNDB ( step ) ; const NdbRecord * baseRecord = ctx -> getTab ( ) -> getDefaultRecord ( ) ; const NdbRecord * ixRecord = pNdb -> getDictionary ( ) -> getIndex ( indexName , ctx -> getTab ( ) -> getName ( ) ) -> getDefaultRecord ( ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 0 ) , " ShortKey " , 8 ) ; NdbDictionary :: setNull ( baseRecord , smallRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 1 ) , " ShortData " , 9 ) ; NdbDictionary :: setNull ( baseRecord , smallRowBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( ixRecord , bigKeyIxBuf , 1 ) , & srcBuff [ 0 ] , maxIndexKeyBytes ) ; NdbDictionary :: setNull ( ixRecord , bigKeyIxBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 0 ) , " ShortIXKey " , 10 ) ; NdbDictionary :: setNull ( baseRecord , bigAttrIxBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 1 ) , & srcBuff [ 0 ] , maxIndexKeyBytes ) ; NdbDictionary :: setNull ( baseRecord , bigAttrIxBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , bigKeyRowBuf , 0 ) , & srcBuff [ 0 ] , mediumPrimaryKeyBytes ) ; NdbDictionary :: setNull ( baseRecord , bigKeyRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , bigKeyRowBuf , 1 ) , " ShortIXKey " , 10 ) ; NdbDictionary :: setNull ( baseRecord , bigKeyRowBuf , 1 , false ) ; NdbTransaction * trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ; CHECKNOTNULL ( trans -> insertTuple ( baseRecord , bigKeyRowBuf ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: Commit ) ) ; NdbRestarter restarter ; trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ; CHECKNOTNULL ( trans ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , baseRecord , ctx -> getTab ( ) , smallRowBuf , & restarter , 8065 ) ) ; const NdbOperation * bigRead = trans -> readTuple ( ixRecord , bigKeyIxBuf , baseRecord , resultSpace ) ; CHECKNOTNULL ( bigRead ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( trans -> readTuple ( ixRecord , bigKeyIxBuf , baseRecord , resultSpace ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( trans -> readTuple ( ixRecord , bigKeyIxBuf , baseRecord , resultSpace ) ) ; CHECKNOTNULL ( trans -> readTuple ( ixRecord , bigKeyIxBuf , baseRecord , resultSpace ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , baseRecord , ctx -> getTab ( ) , smallRowBuf , & restarter , 8066 ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKNOTNULL ( bigRead = trans -> readTuple ( ixRecord , bigAttrIxBuf , baseRecord , resultSpace ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; # if 0 CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; const NdbDictionary :: Index * index ; CHECKNOTNULL ( index = pNdb -> getDictionary ( ) -> getIndex ( indexName , ctx -> getTab ( ) -> getName ( ) ) ) ; NdbIndexOperation * bigReadOldApi ; CHECKNOTNULL ( bigReadOldApi = trans -> getNdbIndexOperation ( index ) ) ; CHECKEQUAL ( 0 , bigReadOldApi -> readTuple ( ) ) ; CHECKEQUAL ( 0 , bigReadOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( ixRecord , bigKeyIxBuf , 1 ) ) ) ; CHECKNOTNULL ( bigReadOldApi -> getValue ( ( Uint32 ) 1 ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; NdbIndexOperation * bigUpdateOldApi ; CHECKNOTNULL ( bigUpdateOldApi = trans -> getNdbIndexOperation ( index ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> updateTuple ( ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> setValue ( ( Uint32 ) 1 , NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; restarter . insertErrorInAllNodes ( 8066 ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigUpdateOldApi = trans -> getNdbIndexOperation ( index ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> updateTuple ( ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> setValue ( ( Uint32 ) 1 , NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; restarter . insertErrorInAllNodes ( 8067 ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigUpdateOldApi = trans -> getNdbIndexOperation ( index ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> updateTuple ( ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> setValue ( ( Uint32 ) 1 , NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; # endif CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , baseRecord , ctx -> getTab ( ) , smallRowBuf , & restarter , 8068 ) ) ; trans -> execute ( NdbTransaction :: Rollback ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; return NDBT_OK ; } int testSegmentedSectionScan ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " WIDE _ 2COL " ) != 0 ) return NDBT_OK ; const Uint32 maxRowBytes = NDB_MAX_TUPLE_SIZE_IN_WORDS * sizeof ( Uint32 ) ; char smallKey [ 50 ] ; char smallRowBuf [ maxRowBytes ] ; Uint32 smallKeySize = setLongVarchar ( & smallKey [ 0 ] , " ShortKey " , 8 ) ; const NdbRecord * record = ctx -> getTab ( ) -> getDefaultRecord ( ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , smallRowBuf , 0 ) , " ShortKey " , 8 ) ; NdbDictionary :: setNull ( record , smallRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , smallRowBuf , 1 ) , " ShortData " , 9 ) ; NdbDictionary :: setNull ( record , smallRowBuf , 1 , false ) ; NdbRestarter restarter ; Ndb * pNdb = GETNDB ( step ) ; NdbTransaction * trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ; CHECKNOTNULL ( trans ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , record , ctx -> getTab ( ) , smallRowBuf , & restarter , 8066 ) ) ; NdbScanOperation * scan = trans -> getNdbScanOperation ( ctx -> getTab ( ) ) ; CHECKNOTNULL ( scan ) ; CHECKEQUAL ( 0 , scan -> readTuples ( ) ) ; NdbInterpretedCode prog ; for ( Uint32 w = 0 ; w < 2500 ; w ++ ) CHECKEQUAL ( 0 , prog . load_const_null ( 1 ) ) ; CHECKEQUAL ( 0 , prog . interpret_exit_ok ( ) ) ; CHECKEQUAL ( 0 , prog . finalise ( ) ) ; CHECKEQUAL ( 0 , scan -> setInterpretedCode ( & prog ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; CHECKEQUAL ( - 1 , scan -> nextResult ( ) ) ; CHECKEQUAL ( 217 , scan -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , record , ctx -> getTab ( ) , smallRowBuf , & restarter , 8068 ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: Rollback ) ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; return NDBT_OK ; } int testDropSignalFragments ( NDBT_Context * ctx , NDBT_Step * step ) { NdbRestarter restarter ; Ndb * pNdb = GETNDB ( step ) ; const Uint32 PROG_WORDS = 16500 ; struct SubCase { Uint32 errorInsertCode ; int expectedRc ; } ; const Uint32 numSubCases = 5 ; const SubCase cases [ numSubCases ] = { { 0 , 874 } , { 8074 , 217 } , { 8075 , 217 } , { 8076 , 217 } , { 8077 , 217 } } ; const Uint32 numIterations = 50 ; Uint32 buff [ PROG_WORDS + 10 ] ; for ( Uint32 iteration = 0 ; iteration < ( numIterations * numSubCases ) ; iteration ++ ) { NdbTransaction * trans = pNdb -> startTransaction ( ) ; CHECKNOTNULL ( trans ) ; SubCase subcase = cases [ iteration % numSubCases ] ; Uint32 errorInsertVal = subcase . errorInsertCode ; CHECKEQUAL ( 0 , restarter . insertErrorInAllNodes ( errorInsertVal ) ) ; CHECKEQUAL ( 0 , restarter . insertErrorInAllNodes ( errorInsertVal ) ) ; NdbScanOperation * scan = trans -> getNdbScanOperation ( ctx -> getTab ( ) ) ; CHECKNOTNULL ( scan ) ; CHECKEQUAL ( 0 , scan -> readTuples ( ) ) ; NdbInterpretedCode prog ( ctx -> getTab ( ) , buff , PROG_WORDS + 10 ) ; for ( Uint32 w = 0 ; w < PROG_WORDS ; w ++ ) CHECKEQUAL ( 0 , prog . load_const_null ( 1 ) ) ; CHECKEQUAL ( 0 , prog . interpret_exit_ok ( ) ) ; CHECKEQUAL ( 0 , prog . finalise ( ) ) ; CHECKEQUAL ( 0 , scan -> setInterpretedCode ( & prog ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; CHECKEQUAL ( - 1 , scan -> nextResult ( ) ) ; int expectedResult = subcase . expectedRc ; CHECKEQUAL ( expectedResult , scan -> getNdbError ( ) . code ) ; scan -> close ( ) ; trans -> close ( ) ; } restarter . insertErrorInAllNodes ( 0 ) ; return NDBT_OK ; } int create100Tables ( NDBT_Context * ctx , NDBT_Step * step ) { Ndb * pNdb = GETNDB ( step ) ; const NdbDictionary :: Table * pTab = ctx -> getTab ( ) ; if ( strcmp ( pTab -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; for ( Uint32 t = 0 ; t < 100 ; t ++ ) { char tabnameBuff [ 10 ] ; snprintf ( tabnameBuff , sizeof ( tabnameBuff ) , " TAB % u " , t ) ; NdbDictionary :: Table tab ; tab . setName ( tabnameBuff ) ; NdbDictionary :: Column pk ; pk . setName ( " PK " ) ; pk . setType ( NdbDictionary :: Column :: Varchar ) ; pk . setLength ( 20 ) ; pk . setNullable ( false ) ; pk . setPrimaryKey ( true ) ; tab . addColumn ( pk ) ; pNdb -> getDictionary ( ) -> dropTable ( tab . getName ( ) ) ; if ( pNdb -> getDictionary ( ) -> createTable ( tab ) != 0 ) { ndbout << " Create ▁ table ▁ failed ▁ with ▁ error ▁ : ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . code << " ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . message << endl ; return NDBT_FAILED ; } ndbout << " Created ▁ table ▁ " << tabnameBuff << endl ; } return NDBT_OK ; } int drop100Tables ( NDBT_Context * ctx , NDBT_Step * step ) { Ndb * pNdb = GETNDB ( step ) ; const NdbDictionary :: Table * pTab = ctx -> getTab ( ) ; if ( strcmp ( pTab -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; for ( Uint32 t = 0 ; t < 100 ; t ++ ) { char tabnameBuff [ 10 ] ; snprintf ( tabnameBuff , sizeof ( tabnameBuff ) , " TAB % u " , t ) ; if ( pNdb -> getDictionary ( ) -> dropTable ( tabnameBuff ) != 0 ) { ndbout << " Drop ▁ table ▁ failed ▁ with ▁ error ▁ : ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . code << " ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . message << endl ; } else { ndbout << " Dropped ▁ table ▁ " << tabnameBuff << endl ; } } return NDBT_OK ; } int dropTable ( NDBT_Context * ctx , NDBT_Step * step , Uint32 num ) { Ndb * pNdb = GETNDB ( step ) ; const NdbDictionary :: Table * pTab = ctx -> getTab ( ) ; if ( strcmp ( pTab -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; char tabnameBuff [ 10 ] ; snprintf ( tabnameBuff , sizeof ( tabnameBuff ) , " TAB % u " , num ) ; if ( pNdb -> getDictionary ( ) -> dropTable ( tabnameBuff ) != 0 ) { ndbout << " Drop ▁ table ▁ failed ▁ with ▁ error ▁ : ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . code << " ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . message << endl ; } else { ndbout << " Dropped ▁ table ▁ " << tabnameBuff << endl ; } return NDBT_OK ; } enum Scenarios { DROP_TABLE , RESTART_MASTER , RESTART_SLAVE , NUM_SCENARIOS } ; enum Tasks { WAIT = 0 , DROP_TABLE_REQ = 1 , MASTER_RESTART_REQ = 2 , SLAVE_RESTART_REQ = 3 } ; int testWorker ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; while ( ! ctx -> isTestStopped ( ) ) { ndbout_c ( " Worker ▁ : ▁ waiting ▁ for ▁ request . . . " ) ; ctx -> getPropertyWait ( " DIHWritesRequest " , 1 ) ; if ( ! ctx -> isTestStopped ( ) ) { Uint32 req = ctx -> getProperty ( " DIHWritesRequestType " , ( Uint32 ) 0 ) ; switch ( ( Tasks ) req ) { case DROP_TABLE_REQ : { ndbout_c ( " Worker ▁ : ▁ dropping ▁ table " ) ; if ( dropTable ( ctx , step , 2 ) != NDBT_OK ) { return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ table ▁ dropped . " ) ; break ; } case MASTER_RESTART_REQ : { ndbout_c ( " Worker ▁ : ▁ restarting ▁ Master " ) ; NdbRestarter restarter ; int master_nodeid = restarter . getMasterNodeId ( ) ; ndbout_c ( " Worker ▁ : ▁ Restarting ▁ Master ▁ ( % d ) . . . " , master_nodeid ) ; if ( restarter . restartOneDbNode2 ( master_nodeid , NdbRestarter :: NRRF_NOSTART | NdbRestarter :: NRRF_FORCE | NdbRestarter :: NRRF_ABORT ) || restarter . waitNodesNoStart ( & master_nodeid , 1 ) || restarter . startAll ( ) ) { ndbout_c ( " Worker ▁ : ▁ Error ▁ restarting ▁ Master . " ) ; return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ Waiting ▁ for ▁ master ▁ to ▁ recover . . . " ) ; if ( restarter . waitNodesStarted ( & master_nodeid , 1 ) ) { ndbout_c ( " Worker ▁ : ▁ Error ▁ waiting ▁ for ▁ Master ▁ restart " ) ; return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ Master ▁ recovered . " ) ; break ; } case SLAVE_RESTART_REQ : { NdbRestarter restarter ; int slave_nodeid = restarter . getRandomNotMasterNodeId ( rand ( ) ) ; ndbout_c ( " Worker ▁ : ▁ Restarting ▁ non - master ▁ ( % d ) . . . " , slave_nodeid ) ; if ( restarter . restartOneDbNode2 ( slave_nodeid , NdbRestarter :: NRRF_NOSTART | NdbRestarter :: NRRF_FORCE | NdbRestarter :: NRRF_ABORT ) || restarter . waitNodesNoStart ( & slave_nodeid , 1 ) || restarter . startAll ( ) ) { ndbout_c ( " Worker ▁ : ▁ Error ▁ restarting ▁ Slave . " ) ; return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ Waiting ▁ for ▁ slave ▁ to ▁ recover . . . " ) ; if ( restarter . waitNodesStarted ( & slave_nodeid , 1 ) ) { ndbout_c ( " Worker ▁ : ▁ Error ▁ waiting ▁ for ▁ Slave ▁ restart " ) ; return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ Slave ▁ recovered . " ) ; break ; } default : { break ; } } } ctx -> setProperty ( " DIHWritesRequestType " , ( Uint32 ) 0 ) ; ctx -> setProperty ( " DIHWritesRequest " , ( Uint32 ) 2 ) ; } ndbout_c ( " Worker , ▁ done . " ) ; return NDBT_OK ; } int testSlowDihFileWrites ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; NdbRestarter restarter ; for ( Uint32 scenario = 0 ; scenario < NUM_SCENARIOS ; scenario ++ ) { ndbout_c ( " Inserting ▁ error ▁ 7235" ) ; restarter . insertErrorInAllNodes ( 7235 ) ; ndbout_c ( " Triggering ▁ LCP " ) ; int dumpArg = 7099 ; restarter . dumpStateAllNodes ( & dumpArg , 1 ) ; const Uint32 periodSeconds = 10 ; Uint32 waitPeriods = 6 ; dumpArg = 7032 ; for ( Uint32 p = 0 ; p < waitPeriods ; p ++ ) { if ( p == 3 ) { switch ( ( Scenarios ) scenario ) { case DROP_TABLE : { ndbout_c ( " Requesting ▁ DROP ▁ TABLE " ) ; ctx -> setProperty ( " DIHWritesRequestType " , ( Uint32 ) DROP_TABLE_REQ ) ; ctx -> setProperty ( " DIHWritesRequest " , ( Uint32 ) 1 ) ; break ; } case RESTART_MASTER : { ndbout_c ( " Requesting ▁ Master ▁ restart " ) ; ctx -> setProperty ( " DIHWritesRequestType " , ( Uint32 ) MASTER_RESTART_REQ ) ; ctx -> setProperty ( " DIHWritesRequest " , ( Uint32 ) 1 ) ; break ; } case RESTART_SLAVE : { ndbout_c ( " Requesting ▁ Slave ▁ restart " ) ; ctx -> setProperty ( " DIHWritesRequestType " , ( Uint32 ) SLAVE_RESTART_REQ ) ; ctx -> setProperty ( " DIHWritesRequest " , ( Uint32 ) 1 ) ; break ; } default : break ; } } ndbout_c ( " Dumping ▁ DIH ▁ page ▁ info ▁ to ▁ ndbd ▁ stdout " ) ; restarter . dumpStateAllNodes ( & dumpArg , 1 ) ; NdbSleep_MilliSleep ( periodSeconds * 1000 ) ; } ndbout_c ( " Clearing ▁ error ▁ insert . . . " ) ; restarter . insertErrorInAllNodes ( 0 ) ; waitPeriods = 2 ; for ( Uint32 p = 0 ; p < waitPeriods ; p ++ ) { ndbout_c ( " Dumping ▁ DIH ▁ page ▁ info ▁ to ▁ ndbd ▁ stdout " ) ; restarter . dumpStateAllNodes ( & dumpArg , 1 ) ; NdbSleep_MilliSleep ( periodSeconds * 1000 ) ; } ndbout_c ( " Waiting ▁ for ▁ worker ▁ to ▁ finish ▁ task . . . " ) ; ctx -> getPropertyWait ( " DIHWritesRequest " , 2 ) ; if ( ctx -> isTestStopped ( ) ) return NDBT_OK ; ndbout_c ( " Done . " ) ; } ctx -> stopTest ( ) ; return NDBT_OK ; } NDBT_TESTSUITE ( testLimits ) ; TESTCASE ( " ExhaustSegmentedSectionPk " , " Test ▁ behaviour ▁ at ▁ Segmented ▁ Section ▁ exhaustion ▁ for ▁ PK " ) { INITIALIZER ( testSegmentedSectionPk ) ; } TESTCASE ( " ExhaustSegmentedSectionIX " , " Test ▁ behaviour ▁ at ▁ Segmented ▁ Section ▁ exhaustion ▁ for ▁ Unique ▁ index " ) { INITIALIZER ( testSegmentedSectionIx ) ; } TESTCASE ( " ExhaustSegmentedSectionScan " , " Test ▁ behaviour ▁ at ▁ Segmented ▁ Section ▁ exhaustion ▁ for ▁ Scan " ) { INITIALIZER ( testSegmentedSectionScan ) ; } TESTCASE ( " DropSignalFragments " , " Test ▁ behaviour ▁ of ▁ Segmented ▁ Section ▁ exhaustion ▁ with ▁ fragmented ▁ signals " ) { INITIALIZER ( testDropSignalFragments ) ; } TESTCASE ( " SlowDihFileWrites " , " Test ▁ behaviour ▁ of ▁ slow ▁ Dih ▁ table ▁ file ▁ writes " ) { INITIALIZER ( create100Tables ) ; STEP ( testWorker ) ; STEP ( testSlowDihFileWrites ) ; FINALIZER ( drop100Tables ) ; } NDBT_TESTSUITE_END ( testLimits ) ; int main ( int argc , const char * * argv ) { ndb_init ( ) ; NDBT_TESTSUITE_INSTANCE ( testLimits ) ; return testLimits . execute ( argc , argv ) ; } </DOCUMENT>
<DOCUMENT_ID="carvalhomb/tsmells/tree/master/sample/poco/poco/Net/src/ICMP@@ Packet.cpp"> # include " Poco / Net / ICMPPacket . h " # include " Poco / Net / ICMPv4PacketImpl . h " # include " Poco / Net / NetException . h " # include " Poco / Timestamp . h " # include " Poco / Timespan . h " # include " Poco / Process . h " # include " Poco / NumberFormatter . h " # include < sstream > using Poco :: InvalidArgumentException ; using Poco :: NotImplementedException ; using Poco :: Timestamp ; using Poco :: Timespan ; using Poco :: Process ; using Poco :: NumberFormatter ; using Poco :: UInt8 ; using Poco :: UInt16 ; using Poco :: Int32 ; namespace Poco { namespace Net { ICMPPacket :: ICMPPacket ( IPAddress :: Family family , int dataSize ) : _pImpl ( 0 ) { if ( family == IPAddress :: IPv4 ) _pImpl = new ICMPv4PacketImpl ( dataSize ) ; # if POCO_HAVE_@@ IPv6 else if ( family == IPAddress :: IPv6 ) throw NotImplementedException ( " ICMPv6 ▁ packets ▁ not ▁ implemented . " ) ; # endif else throw InvalidArgumentException ( " Invalid ▁ or ▁ unsupported ▁ address ▁ family ▁ passed ▁ to ▁ ICMPPacket " ) ; } ICMPPacket :: ~ ICMPPacket ( ) { delete _pImpl ; } void ICMPPacket :: setDataSize ( int dataSize ) { _pImpl -> setDataSize ( dataSize ) ; } int ICMPPacket :: getDataSize ( ) const { return _pImpl -> getDataSize ( ) ; } int ICMPPacket :: packetSize ( ) const { return _pImpl -> packetSize ( ) ; } int ICMPPacket :: maxPacketSize ( ) const { return _pImpl -> maxPacketSize ( ) ; } const Poco :: UInt8 * ICMPPacket :: packet ( ) { return _pImpl -> packet ( ) ; } struct timeval ICMPPacket :: time ( Poco :: UInt8 * buffer , int length ) const { return _pImpl -> time ( buffer , length ) ; } bool ICMPPacket :: validReplyID ( Poco :: UInt8 * buffer , int length ) const { return _pImpl -> validReplyID ( buffer , length ) ; } std :: string ICMPPacket :: errorDescription ( Poco :: UInt8 * buffer , int length ) { return _pImpl -> errorDescription ( buffer , length ) ; } std :: string ICMPPacket :: typeDescription ( int typeId ) { return _pImpl -> typeDescription ( typeId ) ; } } } </DOCUMENT>
<DOCUMENT_ID="asmaurya@@ 95/My@@ -ACM-ICPC@@ -Handbook/tree/master/Suffix Array/Nai@@ ve Implementation.cpp"> # include < iostream > # include < string > # include < map > # include < algorithm > # include < vector > using namespace std ; int main ( ) { string s ; cin >> s ; map < string , int > m ; vector < string > ar ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { string sstr = s . substr ( i , s . size ( ) - i ) ; m [ sstr ] = i ; ar . push_back ( sstr ) ; } sort ( ar . begin ( ) , ar . end ( ) ) ; for ( int i = 0 ; i < ar . size ( ) ; i ++ ) { cout << m [ ar [ i ] ] << endl ; } return 0 ; } </DOCUMENT>
<DOCUMENT_ID="xdajog/@@ samsung_@@ sources_i92@@ 7/tree/master/external/webkit/Source/WebK@@ it2/Shared/DictionaryPopupInfo.cpp"> # include " config . h " # include " DictionaryPopupInfo . h " # include " WebCoreArgumentCoders . h " # if PLATFORM ( MAC ) # include " ArgumentCoder@@ sCF . h " # endif namespace WebKit { void DictionaryPopupInfo :: encode ( CoreIPC :: ArgumentEncoder * encoder ) const { encoder -> encode ( origin ) ; encoder -> encode ( fontInfo ) ; encoder -> encodeEnum ( type ) ; # if PLATFORM ( MAC ) && ! defined ( BUILDING_ON_SNOW_LEOPARD ) CoreIPC :: encode ( encoder , options . get ( ) ) ; # endif } bool DictionaryPopupInfo :: decode ( CoreIPC :: ArgumentDecoder * decoder , DictionaryPopupInfo & result ) { if ( ! decoder -> decode ( result . origin ) ) return false ; if ( ! decoder -> decode ( result . fontInfo ) ) return false ; if ( ! decoder -> decodeEnum ( result . type ) ) return false ; # if PLATFORM ( MAC ) && ! defined ( BUILDING_ON_SNOW_LEOPARD ) if ( ! CoreIPC :: decode ( decoder , result . options ) ) return false ; # endif return true ; } } </DOCUMENT>
<DOCUMENT_ID="fahh@@ em/mbed@@ -os/tree/master/t@@ argets/TARGET_@@ NUVOTON@@ /TARGET_M451/device@@ /TOOLCHAIN@@ _ARM_STD@@ /sys.cpp"> # ifdef __cplusplus extern " C " { # endif # include < rt_misc . h > # include < stdint . h > extern char Image$$ARM_LIB_STACK@@ $$ZI$$Limit [ ] ; extern char Image$$ARM_LIB_HEAP$$Base [ ] ; extern char Image$$ARM_LIB_HEAP$$ZI$$Limit [ ] ; extern __value@@ _in_regs struct __initial_stackheap __user_@@ setup_stackheap ( uint32_t R0 , uint32_t R1 , uint32_t R2 , uint32_t R3 ) { struct __initial_stackheap r ; r . heap_base = ( uint32_t ) Image$$ARM_LIB_HEAP$$Base ; r . heap_@@ limit = ( uint32_t ) Image$$ARM_LIB_HEAP$$ZI$$Limit ; return r ; } # ifdef __cplusplus } # endif </DOCUMENT>
<DOCUMENT_ID="Maximus-/WinObjC/tree/master/deps/3rdparty/iculegacy/source/test/intl@@ test/testidn@@ a.cpp"> # include " unicode / utypes . h " # if ! UCONFIG_NO_IDNA && ! UCONFIG_NO_TRANSLITERATION # include < time . h > # include < limits . h > # include < stdlib . h > # include < string . h > # include " unicode / localpointer . h " # include " unicode / ustring . h " # include " unicode / usprep . h " # include " unicode / uniset . h " # include " testidna . h " # include " idnaref . h " # include " nptrans . h " # include " unicode / putil . h " # include " idnaconf . h " static const UChar unicodeIn [ ] [ 41 ] = { { 0x0644 , 0x064A , 0x0647 , 0x0645 , 0x0627 , 0x0628 , 0x062A , 0x0643 , 0x0644 , 0x0645 , 0x0648 , 0x0634 , 0x0639 , 0x0631 , 0x0628 , 0x064A , 0x061@@ F , 0x0000 } , { 0x4ED6 , 0x4EE@@ C , 0x4E3A , 0x4EC0 , 0x4E48 , 0x4E0D , 0x8BF4 , 0x4E2D , 0x6587 , 0x0000 } , { 0x0050 , 0x0072 , 0x006F , 0x010D , 0x0070 , 0x0072 , 0x006F , 0x0073 , 0x0074 , 0x011@@ B , 0x006E , 0x0065 , 0x006D , 0x006C , 0x0075 , 0x0076 , 0x00ED , 0x010D , 0x0065 , 0x0073 , 0x006B , 0x0079 , 0x0000 } , { 0x05DC , 0x05DE , 0x05D4 , 0x05D4 , 0x05DD , 0x05E4 , 0x05E9 , 0x05D5 , 0x05D8 , 0x05DC , 0x05D0 , 0x05DE , 0x05D3 , 0x05D1 , 0x05E8 , 0x05D9 , 0x05DD , 0x05E2 , 0x05D1 , 0x05E8 , 0x05D9 , 0x05EA , 0x0000 } , { 0x092F , 0x0939 , 0x0932 , 0x094B , 0x0917 , 0x0939 , 0x093F , 0x0928 , 0x094D , 0x0926 , 0x0940 , 0x0915 , 0x094D , 0x092F , 0x094B , 0x0902 , 0x0928 , 0x0939 , 0x0940 , 0x0902 , 0x092C , 0x094B , 0x0932 , 0x0938 , 0x0915 , 0x0924 , 0x0947 , 0x0939 , 0x0948 , 0x0902 , 0x0000 } , { 0x306A , 0x305C , 0x307F , 0x3093 , 0x306A , 0x65E5 , 0x672C , 0x8A9@@ E , 0x3092 , 0x8A7@@ 1 , 0x3057 , 0x3066 , 0x304F , 0x308C , 0x306A , 0x3044 , 0x306E , 0x304B , 0x0000 } , { 0x043F , 0x043E , 0x0447 , 0x0435 , 0x043C , 0x0443 , 0x0436 , 0x0435 , 0x043E , 0x043D , 0x0438 , 0x043D , 0x0435 , 0x0433 , 0x043E , 0x0432 , 0x043E , 0x0440 , 0x044F , 0x0442 , 0x043F , 0x043E , 0x0440 , 0x0443 , 0x0441 , 0x0441 , 0x043A , 0x0438 , 0x0000 } , { 0x0050 , 0x006F , 0x0072 , 0x0071 , 0x0075 , 0x00E9 , 0x006E , 0x006F , 0x0070 , 0x0075 , 0x0065 , 0x0064 , 0x0065 , 0x006E , 0x0073 , 0x0069 , 0x006D , 0x0070 , 0x006C , 0x0065 , 0x006D , 0x0065 , 0x006E , 0x0074 , 0x0065 , 0x0068 , 0x0061 , 0x0062 , 0x006C , 0x0061 , 0x0072 , 0x0065 , 0x006E , 0x0045 , 0x0073 , 0x0070 , 0x0061 , 0x00F1 , 0x006F , 0x006C , 0x0000 } , { 0x4ED6 , 0x5011 , 0x7232 , 0x4EC0 , 0x9EB@@ D , 0x4E0D , 0x8AA@@ A , 0x4E2D , 0x6587 , 0x0000 } , { 0x0054 , 0x1EA1 , 0x0069 , 0x0073 , 0x0061 , 0x006F , 0x0068 , 0x1ECD , 0x006B , 0x0068 , 0x00F4 , 0x006E , 0x0067 , 0x0074 , 0x0068 , 0x1EC3 , 0x0063 , 0x0068 , 0x1EC9 , 0x006E , 0x00F3 , 0x0069 , 0x0074 , 0x0069 , 0x1EB@@ F , 0x006E , 0x0067 , 0x0056 , 0x0069 , 0x1EC7 , 0x0074 , 0x0000 } , { 0x0033 , 0x5E74 , 0x0042 , 0x7D44 , 0x91D@@ 1 , 0x516B , 0x5148 , 0x751F , 0x0000 } , { 0x5B8@@ 9 , 0x5BA@@ 4 , 0x594@@ 8 , 0x7F8@@ E , 0x6075 , 0x002D , 0x0077 , 0x0069 , 0x0074 , 0x0068 , 0x002D , 0x0053 , 0x0055 , 0x0050 , 0x0045 , 0x0052 , 0x002D , 0x004D , 0x004F , 0x004E , 0x004B , 0x0045 , 0x0059 , 0x0053 , 0x0000 } , { 0x0048 , 0x0065 , 0x006C , 0x006C , 0x006F , 0x002D , 0x0041 , 0x006E , 0x006F , 0x0074 , 0x0068 , 0x0065 , 0x0072 , 0x002D , 0x0057 , 0x0061 , 0x0079 , 0x002D , 0x305D , 0x308C , 0x305E , 0x308C , 0x306E , 0x583@@ 4 , 0x6240 , 0x0000 } , { 0x3072 , 0x3068 , 0x3064 , 0x5C4@@ B , 0x6839 , 0x306E , 0x4E0B , 0x0032 , 0x0000 } , { 0x004D , 0x0061 , 0x006A , 0x0069 , 0x3067 , 0x004B , 0x006F , 0x0069 , 0x3059 , 0x308B , 0x0035 , 0x79D2 , 0x524@@ D , 0x0000 } , { 0x30D1 , 0x30D5 , 0x30A3 , 0x30FC , 0x0064 , 0x0065 , 0x30EB , 0x30F3 , 0x30D0 , 0x0000 } , { 0x305D , 0x306E , 0x30B9 , 0x30D4 , 0x30FC , 0x30C9 , 0x3067 , 0x0000 } , { 0xD800 , 0xDF00 , 0xD800 , 0xDF01 , 0xD800 , 0xDF02 , 0xD800 , 0xDF03 , 0xD800 , 0xDF05 , 0xD800 , 0xDF06 , 0xD800 , 0xDF07 , 0xD800 , 0xDF09 , 0xD800 , 0xDF0A , 0xD800 , 0xDF0B , 0x0000 } , { 0xD800 , 0xDF0D , 0xD800 , 0xDF0C , 0xD800 , 0xDF1E , 0xD800 , 0xDF0F , 0xD800 , 0xDF16 , 0xD800 , 0xDF15 , 0xD800 , 0xDF14 , 0xD800 , 0xDF12 , 0xD800 , 0xDF10 , 0xD800 , 0xDF20 , 0xD800 , 0xDF21 , 0x0000 } , { 0x03b5 , 0x03bb , 0x03bb , 0x03b7 , 0x03bd , 0x03b9 , 0x03ba , 0x03ac } , { 0x0062 , 0x006f , 0x006e , 0x0121 , 0x0075 , 0x0073 , 0x0061 , 0x0127 , 0x0127 , 0x0061 } , { 0x043f , 0x043e , 0x0447 , 0x0435 , 0x043c , 0x0443 , 0x0436 , 0x0435 , 0x043e , 0x043d , 0x0438 , 0x043d , 0x0435 , 0x0433 , 0x043e , 0x0432 , 0x043e , 0x0440 , 0x044f , 0x0442 , 0x043f , 0x043e , 0x0440 , 0x0443 , 0x0441 , 0x0441 , 0x043a , 0x0438 } , { 0xFB00 , 0xFB01 } } ; static const char * asciiIn [ ] = { " xn - - egbpdaj@@ 6bu4bxf@@ gehf@@ vwxn " , " xn - - ihqwcrb4@@ cv8a@@ 8dqg056pqjy@@ e " , " xn - - Proprostnemluves@@ ky - uyb24dma@@ 41a " , " xn - -4dbcag@@ dahymb@@ xekheh6@@ e0a7@@ fei0b " , " xn - - i1baa7@@ eci9glrd@@ 9b2ae1bj@@ 0hfcgg6iy@@ af8o0@@ a1dig0cd " , " xn - - n8jok5@@ ay5dz@@ abd5bym9@@ f0cm5685@@ rrjetr@@ 6pdxa " , " xn - - b1abfaaepdrnnbgefba@@ Dotcwatmq2g4l " , " xn - - Porqun@@ opued@@ ensimplemente@@ hablaren@@ Espaol - fmd56a " , " xn - - ihqwctvz@@ c91f659dr@@ ss3x8@@ bo0yb " , " xn - - Tisao@@ hkhng@@ thchnitingVit - kjcr8268@@ qyxafd2@@ f1b9g " , " xn - -3B - ww4c5@@ e180e575@@ a65lsy@@ 2b " , " xn - - - with - SUPER - MONKEYS - pc58@@ ag80a8qai@@ 00g7n9n " , " xn - - Hello - Another - Way - - fc4qu@@ a05au@@ wb3674vfr@@ 0b " , " xn - -2 - u9tlzr9756@@ bt3uc@@ 0v " , " xn - - MajiK@@ oi5-783gu@@ e6qz0@@ 75az@@ m5e " , " xn - - de - jg4avhby@@ 1noc0d " , " xn - - d9juau@@ 41awcz@@ czp " , " XN - -097CCDEKGH@@ QJK " , " XN - - db8CB@@ HEJL@@ GH4E@@ 0AL " , " xn - - hxargifdar " , " xn - - bonusaa - 5bb1da " , " xn - - b1abfaaepdrnnbgefbadotcwatmq2g4l " , " fffi " } ; static const char * domainNames [ ] = { " slip129-37-118-146 . nc . us . ibm . net " , " saratoga . pe . utexas . edu " , " dial - 120-45 . ots . utexas . edu " , " woo - 085 . dorms . waller . net " , " hd30-049 . hil . compuser@@ ve . com " , " pem203-31 . pe . ttu . edu " , "56K - 227 . MaxTNT@@ 3 . pdq . net " , " dial - 36-2 . ots . utexas . edu " , " slip129-37-23-15@@ 2 . ga . us . ibm . net " , " ts45@@ ip11@@ 9 . cadvision . com " , " sdn - ts - 004txaust@@ P05 . dialsprint . net " , " bar - tnt1s66 . erols . com " , "101 . st - louis - 15 . mo . dial - access . att . net " , " h92-24@@ 5 . Arco . COM " , " dial - 13-2 . ots . utexas . edu " , " net - redynet@@ 29 . datamarkets . com . ar " , " ccs - shiva28 . reacciun . net . ve " , "7 . houst@@ on - 11 . tx . dial - access . att . net " , " ingw129-37-120-26 . mo . us . ibm . net " , " dialup6 . austintx . com " , " dns2 . tpao . gov . tr " , " slip129-37-119-194 . nc . us . ibm . net " , " cs7 . dillons . co . uk . 203.@@ 119.@@ 193 . in - addr . arpa " , " swprd1 . innovplace . saskatoon . sk . ca " , " bikini . bologna . maraut . it " , " node91 . subnet@@ 159-@@ 198-@@ 79 . baxter . com " , " cust19 . max5 . new - york . ny . ms . uu . net " , " balexander . slip . andrew . cmu . edu " , " pool029 . max2 . denver . co . dynip . alter . net " , " cust49 . max9 . new - york . ny . ms . uu . net " , " s61 . abq - dialin2 . hollyberry . com " , " \\u0917\\u09@@ 28\\u0@@ 947\\u0@@ 936 . sanjose . ibm . com " , " www . xn - - vea . com " , " www . \\u00C2\\u00A4 . com " , " www . \\u00C2\\u00A3 . com " , " \\u00C3@@ \\u00BC . com " , } ; typedef struct ErrorCases ErrorCases ; static const struct ErrorCases { UChar unicode [ 100 ] ; const char * ascii ; UErrorCode expected ; UBool useSTD3ASCIIRules ; UBool testToUnicode ; UBool testLabel ; } errorCases [ ] = { { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0xC138 , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0x070F , 0xD55C , 0xAD6D , 0xC5B4 , 0xB97C , 0xC774 , 0xD574 , 0xD55C , 0xB2E4 , 0xBA74 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . XN - -8mb55@@ 95fso@@ a28oruc@@ ya378@@ bqre2tcw@@ op06@@ c5qbw@@ 82a1@@ rffmae03@@ 61dea96@@ b . com " , U_IDNA_PROHIBITED_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0xC138 , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0x0221 , 0x0234 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . XN - -6lA2@@ Bz548Fj@@ 1GuA391Bf1@@ Gb1N59Ab29@@ A7iA . com " , U_IDNA_UNASSIGNED_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0xC138 , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0x0644 , 0x064A , 0x0647 , 0xD55C , 0xAD6D , 0xC5B4 , 0xB97C , 0xC774 , 0xD574 , 0xD55C , 0xB2E4 , 0xBA74 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . xn - - ghBG@@ I4851Oiy@@ A33Vq@@ rD6Az@@ 86C4qF83C@@ tRv93D5xBk15@@ AzfG@@ 0nAgA0578@@ DeA7@@ 1C . com " , U_IDNA_CHECK_BIDI_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x002D , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0x002E , 0xD55C , 0xAD6D , 0xC5B4 , 0xB97C , 0xC774 , 0xD574 , 0xD55C , 0xB2E4 , 0xBA74 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . xn - - - - b95Ew8Sq@@ A315Ao@@ 5FbuMlnNmhA . com " , U_IDNA_STD3_ASCII_RULES_ERROR , TRUE , FALSE , FALSE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x0078 , 0x006e , 0x002d , 0x002d , 0x002D , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0x002D , 0xD55C , 0xAD6D , 0xC5B4 , 0xB97C , 0xC774 , 0xD574 , 0xD55C , 0xB2E4 , 0xBA74 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . XY - - - - - b91I0@@ V65S96C2A355@@ Cw1E5yC@@ eQr19CsnP@@ 1mFf@@ mAE0361@@ DeA96@@ B . com " , U_IDNA_ACE_PREFI@@ X_ERROR , FALSE , FALSE , FALSE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0xC138 , 0xACC4 , 0xC758 , 0xBAA8 , 0xB4E0 , 0xC0AC , 0xB78C , 0xB4E4 , 0xC774 , 0xD55C , 0xAD6D , 0xC5B4 , 0xB97C , 0xC774 , 0xD574 , 0xD55C , 0xB2E4 , 0xBA74 , 0xC5BC , 0xB9C8 , 0xB098 , 0xC88@@ B , 0xC744 , 0xAE4C , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . xn - -989Ao@@ MsVi5E8@@ 3Db1@@ D2A355@@ Cv1E0@@ vAk1DwRv93D5xB@@ h15A0Dt30A5@@ JpSD879Ccm@@ 6FeA98C . com " , U_IDNA_LAB@@ EL_TO@@ O_LONG_@@ ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x0030 , 0x0644 , 0x064A , 0x0647 , 0x0031 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . xn - -01 - tvdmo . com " , U_IDNA_CHECK_BIDI_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x206C , 0x0644 , 0x064A , 0x0647 , 0x206D , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . XN - - ghbgi@@ 278xi@@ a . com " , U_IDNA_PROHIBITED_ERROR , FALSE , FALSE , TRUE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x002D , 0x0041 , 0x0042 , 0x0043 , 0x0044 , 0x0045 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . - abcde . com " , U_IDNA_STD3_ASCII_RULES_ERROR , TRUE , FALSE , FALSE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x0041 , 0x0042 , 0x0043 , 0x0044 , 0x0045 , 0x002D , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . abcde - . com " , U_IDNA_STD3_ASCII_RULES_ERROR , TRUE , FALSE , FALSE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x0041 , 0x0042 , 0x0043 , 0x0044 , 0x0045 , 0x0040 , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . abcde @ . com " , U_IDNA_STD3_ASCII_RULES_ERROR , TRUE , FALSE , FALSE } , { { 0x0077 , 0x0077 , 0x0077 , 0x002e , 0x002e , 0x0063 , 0x006f , 0x006d , 0x0000 } , " www . . com " , U_IDNA_ZERO_LENGTH@@ _LABEL_@@ ERROR , TRUE , FALSE , FALSE } , { { 0 } , NULL , U_ILLEGAL_ARGUMENT_ERROR , TRUE , TRUE , FALSE } } ; # define MAX_DEST_SIZE 300 void TestIDNA :: debug ( const UChar * src , int32_t srcLength , int32_t options ) { UParseError parseError ; UErrorCode transStatus = U_ZERO_ERROR ; UErrorCode prepStatus = U_ZERO_ERROR ; NamePrepTransform * trans = NamePrepTransform :: createInstance ( parseError , transStatus ) ; int32_t prepOptions = ( ( ( options & UIDNA_ALLOW_UNASSIGNED ) != 0 ) ? USPREP_ALLOW_UNASSIGNED : 0 ) ; LocalUString@@ PrepProfile@@ Pointer prep ( usprep_openByType ( USPREP_RFC@@ 3491_NAMEP@@ REP , & prepStatus ) ) ; UChar * transOut = NULL , * prepOut = NULL ; int32_t transOutLength = 0 , prepOutLength = 0 ; transOutLength = trans -> process ( src , srcLength , transOut , 0 , prepOptions > 0 , & parseError , transStatus ) ; if ( transStatus == U_BUFFER_OVERFLOW_ERROR ) { transStatus = U_ZERO_ERROR ; transOut = ( UChar * ) malloc ( U_SIZEOF_UCHAR * transOutLength ) ; transOutLength = trans -> process ( src , srcLength , transOut , transOutLength , prepOptions > 0 , & parseError , transStatus ) ; } prepOutLength = usprep_prepare ( prep . getAlias ( ) , src , srcLength , prepOut , 0 , prepOptions , & parseError , & prepStatus ) ; if ( prepStatus == U_BUFFER_OVERFLOW_ERROR ) { prepStatus = U_ZERO_ERROR ; prepOut = ( UChar * ) malloc ( U_SIZEOF_UCHAR * prepOutLength ) ; prepOutLength = usprep_prepare ( prep . getAlias ( ) , src , srcLength , prepOut , prepOutLength , prepOptions , & parseError , & prepStatus ) ; } if ( UnicodeString ( transOut , transOutLength ) != UnicodeString ( prepOut , prepOutLength ) ) { errln ( " Failed . ▁ Expected : ▁ " + prettify ( UnicodeString ( transOut , transOutLength ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( prepOut , prepOutLength ) ) ) ; } free ( transOut ) ; free ( prepOut ) ; delete trans ; } void TestIDNA :: testAPI ( const UChar * src , const UChar * expected , const char * testName , UBool useSTD3ASCIIRules , UErrorCode expectedStatus , UBool doCompare , UBool testUnassigned , TestFunc func , UBool testSTD3ASCIIRules ) { UErrorCode status = U_ZERO_ERROR ; UChar destStack [ MAX_DEST_SIZE ] ; int32_t destLen = 0 ; UChar * dest = NULL ; int32_t expectedLen = ( expected != NULL ) ? u_strlen ( expected ) : 0 ; int32_t options = ( useSTD3ASCIIRules == TRUE ) ? UIDNA_USE_STD3_RULES : UIDNA_DEFAULT ; UParseError parseError ; int32_t tSrcLen = 0 ; UChar * tSrc = NULL ; if ( src != NULL ) { tSrcLen = u_strlen ( src ) ; tSrc = ( UChar * ) malloc ( U_SIZEOF_UCHAR * tSrcLen ) ; memcpy ( tSrc , src , tSrcLen * U_SIZEOF_UCHAR ) ; } destLen = func ( src , - 1 , NULL , 0 , options , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options , & parseError , & status ) ; if ( U_SUCCESS ( status ) && expectedStatus != U_IDNA_STD3_ASCII_RULES_ERROR && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source . ▁ Expected ▁ : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( dest , destLen ) ) ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus ) { errcheckln ( status , " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; free ( tSrc ) ; return ; } if ( testUnassigned ) { status = U_ZERO_ERROR ; destLen = func ( src , - 1 , NULL , 0 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ " + prettify ( src ) + " ▁ with ▁ both ▁ options ▁ set . ▁ Expected : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) + " Got : ▁ " + prettify ( UnicodeString ( dest , destLen ) ) ) ; debug ( src , - 1 , options | UIDNA_ALLOW_UNASSIGNED ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } status = U_ZERO_ERROR ; destLen = func ( tSrc , tSrcLen , NULL , 0 , options , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } if ( testUnassigned ) { status = U_ZERO_ERROR ; destLen = func ( tSrc , tSrcLen , NULL , 0 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length ▁ and ▁ both ▁ options ▁ set . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } status = U_ZERO_ERROR ; if ( testSTD3ASCIIRules == TRUE ) { destLen = func ( src , - 1 , NULL , 0 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ both ▁ options ▁ set . ▁ Expected : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } status = U_ZERO_ERROR ; destLen = func ( tSrc , tSrcLen , NULL , 0 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length ▁ and ▁ both ▁ options ▁ set . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } free ( tSrc ) ; } void TestIDNA :: testCompare ( const UChar * s1 , int32_t s1Len , const UChar * s2 , int32_t s2Len , const char * testName , CompareFunc func , UBool isEqual ) { UErrorCode status = U_ZERO_ERROR ; int32_t retVal = func ( s1 , - 1 , s2 , - 1 , UIDNA_DEFAULT , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ null ▁ termniated ▁ strings . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , - 1 , s2 , - 1 , UIDNA_ALLOW_UNASSIGNED , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ null ▁ termniated ▁ strings ▁ with ▁ options ▁ set . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ and ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , s1Len , s2 , s2Len , UIDNA_DEFAULT , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ string ▁ length . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ with ▁ string ▁ length . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , s1Len , s2 , s2Len , UIDNA_ALLOW_UNASSIGNED , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ string ▁ length ▁ and ▁ options ▁ set . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ with ▁ string ▁ length ▁ and ▁ options ▁ set . ▁ Error : ▁ % s " , u_errorName ( status ) , testName ) ; } } void TestIDNA :: testToASCII ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testAPI ( unicodeIn [ i ] , buf , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; } } void TestIDNA :: testToUnicode ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( asciiIn ) / sizeof ( asciiIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testAPI ( buf , unicodeIn [ i ] , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; } } void TestIDNA :: testIDNToUnicode ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; UErrorCode status = U_ZERO_ERROR ; int32_t bufLen = 0 ; UParseError parseError ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( domainNames ) / sizeof ( domainNames [ 0 ] ) ) ; i ++ ) { bufLen = ( int32_t ) strlen ( domainNames [ i ] ) ; bufLen = u_unescape ( domainNames [ i ] , buf , bufLen + 1 ) ; func ( buf , bufLen , expected , MAX_DEST_SIZE , UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s " , testName , i , u_errorName ( status ) ) ; break ; } testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s ▁ \n " , testName , i , u_errorName ( status ) ) ; break ; } } } void TestIDNA :: testIDNToASCII ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; UErrorCode status = U_ZERO_ERROR ; int32_t bufLen = 0 ; UParseError parseError ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( domainNames ) / sizeof ( domainNames [ 0 ] ) ) ; i ++ ) { bufLen = ( int32_t ) strlen ( domainNames [ i ] ) ; bufLen = u_unescape ( domainNames [ i ] , buf , bufLen + 1 ) ; func ( buf , bufLen , expected , MAX_DEST_SIZE , UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s " , testName , i , u_errorName ( status ) ) ; break ; } testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , FALSE , TRUE , func ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s ▁ \n " , testName , i , u_errorName ( status ) ) ; break ; } } } void TestIDNA :: testCompare ( const char * testName , CompareFunc func ) { int32_t i ; UChar www [ ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UChar com [ ] = { 0x002E , 0x0043 , 0x004F , 0x004D , 0x0000 } ; UChar buf [ MAX_DEST_SIZE ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UnicodeString source ( www ) , uni0 ( www ) , uni1 ( www ) , ascii0 ( www ) , ascii1 ( www ) ; uni0 . append ( unicodeIn [ 0 ] ) ; uni0 . append ( com ) ; uni0 . append ( ( UChar ) 0x0000 ) ; uni1 . append ( unicodeIn [ 1 ] ) ; uni1 . append ( com ) ; uni1 . append ( ( UChar ) 0x0000 ) ; ascii0 . append ( asciiIn [ 0 ] ) ; ascii0 . append ( com ) ; ascii0 . append ( ( UChar ) 0x0000 ) ; ascii1 . append ( asciiIn [ 1 ] ) ; ascii1 . append ( com ) ; ascii1 . append ( ( UChar ) 0x0000 ) ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf + 4 , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; u_strcat ( buf , com ) ; source . truncate ( 4 ) ; source . append ( unicodeIn [ i ] ) ; source . append ( com ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; int32_t srcLen = u_strlen ( src ) ; testCompare ( src , srcLen , src , srcLen , testName , func , TRUE ) ; testCompare ( src , srcLen , buf , u_strlen ( buf ) , testName , func , TRUE ) ; if ( i == 0 ) { testCompare ( src , srcLen , uni1 . getBuffer ( ) , uni1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , uni0 . getBuffer ( ) , uni0 . length ( ) - 1 , testName , func , FALSE ) ; } if ( i == 0 ) { testCompare ( src , srcLen , ascii1 . getBuffer ( ) , ascii1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , ascii0 . getBuffer ( ) , ascii0 . length ( ) - 1 , testName , func , FALSE ) ; } } } # if 0 static int32_t getNextSeperator ( UChar * src , int32_t srcLength , UChar * * limit ) { if ( srcLength == - 1 ) { int32_t i ; for ( i = 0 ; ; i ++ ) { if ( src [ i ] == 0 ) { * limit = src + i ; return i ; } if ( src [ i ] == 0x002e ) { * limit = src + ( i + 1 ) ; return i ; } } if ( i == srcLength ) { * limit = src + srcLength ; } return i ; } else { int32_t i ; for ( i = 0 ; i < srcLength ; i ++ ) { if ( src [ i ] == 0x002e ) { * limit = src + ( i + 1 ) ; return i ; } } if ( i == srcLength ) { * limit = src + srcLength ; } return i ; } } void printPuny@@ codeOutput ( ) { UChar dest [ MAX_DEST_SIZE ] ; int32_t destCapacity = MAX_DEST_SIZE ; UChar * start ; UChar * limit ; int32_t labelLen = 0 ; UBool caseFlags [ MAX_DEST_SIZE ] ; for ( int32_t i = 0 ; i < sizeof ( errorCases ) / sizeof ( errorCases [ 0 ] ) ; i ++ ) { ErrorCases errorCase = errorCases [ i ] ; UErrorCode status = U_ZERO_ERROR ; start = errorCase . unicode ; int32_t srcLen = u_strlen ( start ) ; labelLen = getNextSeperator ( start , srcLen , & limit ) ; start = limit ; labelLen = getNextSeperator ( start , srcLen - labelLen , & limit ) ; int32_t destLen = u_strToPunycode ( dest , destCapacity , start , labelLen , caseFlags , & status ) ; if ( U_FAILURE ( status ) ) { printf ( " u _ strToPunycode ▁ failed ▁ for ▁ index ▁ % i \n " , i ) ; continue ; } for ( int32_t j = 0 ; j < destLen ; j ++ ) { printf ( " % c " , ( char ) dest [ j ] ) ; } printf ( " \n " ) ; } } # endif void TestIDNA :: testErrorCases ( const char * IDNToASCIIName , TestFunc IDNToASCII , const char * IDNToUnicodeName , TestFunc IDNToUnicode ) { UChar buf [ MAX_DEST_SIZE ] ; int32_t bufLen = 0 ; for ( int32_t i = 0 ; i < ( int32_t ) ( sizeof ( errorCases ) / sizeof ( errorCases [ 0 ] ) ) ; i ++ ) { ErrorCases errorCase = errorCases [ i ] ; UChar * src = NULL ; if ( errorCase . ascii != NULL ) { bufLen = ( int32_t ) strlen ( errorCase . ascii ) ; u_charsToUChars ( errorCase . ascii , buf , bufLen + 1 ) ; } else { bufLen = 1 ; memset ( buf , 0 , U_SIZEOF_UCHAR * MAX_DEST_SIZE ) ; } if ( errorCase . unicode [ 0 ] != 0 ) { src = errorCase . unicode ; } testAPI ( src , buf , IDNToASCIIName , errorCase . useSTD3ASCIIRules , errorCase . expected , TRUE , TRUE , IDNToASCII ) ; if ( errorCase . testLabel == TRUE ) { testAPI ( src , buf , IDNToASCIIName , errorCase . useSTD3ASCIIRules , errorCase . expected , FALSE , TRUE , IDNToASCII ) ; } if ( errorCase . testToUnicode == TRUE ) { testAPI ( ( src == NULL ) ? NULL : buf , src , IDNToUnicodeName , errorCase . useSTD3ASCIIRules , errorCase . expected , TRUE , TRUE , IDNToUnicode ) ; } } } void TestIDNA :: testChaining ( const UChar * src , int32_t numIterations , const char * testName , UBool useSTD3ASCIIRules , UBool caseInsensitive , TestFunc func ) { UChar even [ MAX_DEST_SIZE ] ; UChar odd [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; int32_t i = 0 , evenLen = 0 , oddLen = 0 , expectedLen = 0 ; UErrorCode status = U_ZERO_ERROR ; int32_t srcLen = u_strlen ( src ) ; int32_t options = ( useSTD3ASCIIRules == TRUE ) ? UIDNA_USE_STD3_RULES : UIDNA_DEFAULT ; UParseError parseError ; expectedLen = func ( src , - 1 , expected , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , - 1 , even , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , - 1 , odd , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; } } status = U_ZERO_ERROR ; expectedLen = func ( src , - 1 , expected , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , - 1 , even , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , - 1 , odd , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; } } status = U_ZERO_ERROR ; expectedLen = func ( src , srcLen , expected , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , oddLen , even , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , evenLen , odd , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ source ▁ with ▁ source ▁ length ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ source ▁ with ▁ source ▁ length ▁ failed \n " , testName ) ; } } status = U_ZERO_ERROR ; expectedLen = func ( src , srcLen , expected , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , oddLen , even , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , evenLen , odd , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed \n " , testName ) ; } } } void TestIDNA :: testChaining ( const char * toASCIIName , TestFunc toASCII , const char * toUnicodeName , TestFunc toUnicode ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( asciiIn ) / sizeof ( asciiIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testChaining ( buf , 5 , toUnicodeName , FALSE , FALSE , toUnicode ) ; } for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { testChaining ( unicodeIn [ i ] , 5 , toASCIIName , FALSE , TRUE , toASCII ) ; } } void TestIDNA :: testRootLabelSeparator ( const char * testName , CompareFunc func , const char * IDNToASCIIName , TestFunc IDNToASCII , const char * IDNToUnicodeName , TestFunc IDNToUnicode ) { int32_t i ; UChar www [ ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UChar com [ ] = { 0x002E , 0x0043 , 0x004F , 0x004D , 0x002E , 0x0000 } ; UChar buf [ MAX_DEST_SIZE ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UnicodeString source ( www ) , uni0 ( www ) , uni1 ( www ) , ascii0 ( www ) , ascii1 ( www ) ; uni0 . append ( unicodeIn [ 0 ] ) ; uni0 . append ( com ) ; uni0 . append ( ( UChar ) 0x0000 ) ; uni1 . append ( unicodeIn [ 1 ] ) ; uni1 . append ( com ) ; uni1 . append ( ( UChar ) 0x0000 ) ; ascii0 . append ( asciiIn [ 0 ] ) ; ascii0 . append ( com ) ; ascii0 . append ( ( UChar ) 0x0000 ) ; ascii1 . append ( asciiIn [ 1 ] ) ; ascii1 . append ( com ) ; ascii1 . append ( ( UChar ) 0x0000 ) ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf + 4 , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; u_strcat ( buf , com ) ; source . truncate ( 4 ) ; source . append ( unicodeIn [ i ] ) ; source . append ( com ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; int32_t srcLen = u_strlen ( src ) ; testCompare ( src , srcLen , buf , u_strlen ( buf ) , testName , func , TRUE ) ; testCompare ( src , srcLen , src , srcLen , testName , func , TRUE ) ; testAPI ( src , buf , IDNToASCIIName , FALSE , U_ZERO_ERROR , TRUE , TRUE , IDNToASCII ) ; testAPI ( buf , src , IDNToUnicodeName , FALSE , U_ZERO_ERROR , TRUE , TRUE , IDNToUnicode ) ; if ( i == 0 ) { testCompare ( src , srcLen , uni1 . getBuffer ( ) , uni1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , uni0 . getBuffer ( ) , uni0 . length ( ) - 1 , testName , func , FALSE ) ; } if ( i == 0 ) { testCompare ( src , srcLen , ascii1 . getBuffer ( ) , ascii1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , ascii0 . getBuffer ( ) , ascii0 . length ( ) - 1 , testName , func , FALSE ) ; } } } extern IntlTest * createUTS46Test ( ) ; void TestIDNA :: runIndexedTest ( int32_t index , UBool exec , const char * & name , char * par ) { if ( exec ) logln ( ( UnicodeString ) " TestSuite ▁ IDNA ▁ API ▁ " ) ; switch ( index ) { case 0 : name = " TestToASCII " ; if ( exec ) TestToASCII ( ) ; break ; case 1 : name = " TestToUnicode " ; if ( exec ) TestToUnicode ( ) ; break ; case 2 : name = " TestIDNToASCII " ; if ( exec ) TestIDNToASCII ( ) ; break ; case 3 : name = " TestIDNToUnicode " ; if ( exec ) TestIDNToUnicode ( ) ; break ; case 4 : name = " TestCompare " ; if ( exec ) TestCompare ( ) ; break ; case 5 : name = " TestErrorCases " ; if ( exec ) TestErrorCases ( ) ; break ; case 6 : name = " TestChaining " ; if ( exec ) TestChaining ( ) ; break ; case 7 : name = " TestRootLabelSeparator " ; if ( exec ) TestRootLabelSeparator ( ) ; break ; case 8 : name = " TestCompareReferenceImpl " ; if ( exec ) TestCompareReferenceImpl ( ) ; break ; case 9 : name = " TestDataFile " ; if ( exec ) TestDataFile ( ) ; break ; # if ! UCONFIG_NO_FILE_IO && ! UCONFIG_NO_LEGACY_CON@@ VERSION case 10 : name = " TestRefIDNA " ; if ( exec ) TestRefIDNA ( ) ; break ; case 11 : name = " TestIDNAMonkeyTest " ; if ( exec ) TestIDNAMonkeyTest ( ) ; break ; # else case 10 : case 11 : name = " skip " ; break ; # endif case 12 : { name = " TestConformance@@ TestVector@@ s " ; if ( exec ) { logln ( " TestSuite ▁ IDNA ▁ conf - - - - " ) ; logln ( ) ; Idna@@ ConfTest test ; callTest ( test , par ) ; } break ; } case 13 : name = " UTS46Test " ; if ( exec ) { logln ( " TestSuite ▁ UTS46Test - - - " ) ; logln ( ) ; LocalPointer < IntlTest > test ( createUTS46Test ( ) ) ; callTest ( * test , par ) ; } break ; default : name = " " ; break ; } } void TestIDNA :: TestToASCII ( ) { testToASCII ( " uidna _ toASCII " , uidna_toASCII ) ; } void TestIDNA :: TestToUnicode ( ) { testToUnicode ( " uidna _ toUnicode " , uidna_toUnicode ) ; } void TestIDNA :: TestIDNToASCII ( ) { testIDNToASCII ( " uidna _ IDNToASCII " , uidna_IDNToASCII ) ; } void TestIDNA :: TestIDNToUnicode ( ) { testIDNToUnicode ( " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; } void TestIDNA :: TestCompare ( ) { testCompare ( " uidna _ compare " , uidna_compare ) ; } void TestIDNA :: TestErrorCases ( ) { testErrorCases ( " uidna _ IDNToASCII " , uidna_IDNToASCII , " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; } void TestIDNA :: TestRootLabelSeparator ( ) { testRootLabelSeparator ( " uidna _ compare " , uidna_compare , " uidna _ IDNToASCII " , uidna_IDNToASCII , " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; } void TestIDNA :: TestChaining ( ) { testChaining ( " uidna _ toASCII " , uidna_toASCII , " uidna _ toUnicode " , uidna_toUnicode ) ; } static const int loopCount = 100 ; static const int maxCharCount = 20 ; static const int maxCode@@ Point = 0x10ffff ; static uint32_t randul ( ) { static UBool initialized = FALSE ; if ( ! initialized ) { srand ( ( unsigned ) time ( NULL ) ) ; initialized = TRUE ; } uint32_t l = 0 ; for ( uint32_t i = 0 ; i < sizeof ( l ) ; ++ i ) ( ( char * ) & l ) [ i ] = ( char ) ( ( rand ( ) & 0x0FF0 ) >> 4 ) ; return l ; } static int32_t rand_uni ( ) { int32_t retVal = ( int32_t ) ( randul ( ) & 0x3FFFF ) ; if ( retVal >= 0x30000 ) { retVal += 0xB0000 ; } return retVal ; } static int32_t randi ( int32_t n ) { return ( int32_t ) ( randul ( ) % ( n + 1 ) ) ; } void getTestSource ( UnicodeString & fillIn ) { int32_t i = 0 ; int32_t charCount = ( randi ( maxCharCount ) + 1 ) ; while ( i < charCount ) { int32_t codepoint = rand_uni ( ) ; if ( codepoint == 0x0000 ) { continue ; } fillIn . append ( ( UChar32 ) codepoint ) ; i ++ ; } } UnicodeString TestIDNA :: testCompareReferenceImpl ( UnicodeString & src , TestFunc refIDNA , const char * refIDNAName , TestFunc uIDNA , const char * uIDNAName , int32_t options ) { const UChar * srcUChars = src . getBuffer ( ) ; UChar exp [ MAX_DEST_SIZE ] = { 0 } ; int32_t expCap = MAX_DEST_SIZE , expLen = 0 ; UErrorCode expStatus = U_ZERO_ERROR ; UParseError parseError ; logln ( " Comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ for ▁ input : ▁ " + prettify ( srcUChars ) ) ; expLen = refIDNA ( srcUChars , src . length ( ) - 1 , exp , expCap , options , & parseError , & expStatus ) ; UChar got [ MAX_DEST_SIZE ] = { 0 } ; int32_t gotCap = MAX_DEST_SIZE , gotLen = 0 ; UErrorCode gotStatus = U_ZERO_ERROR ; gotLen = uIDNA ( srcUChars , src . length ( ) - 1 , got , gotCap , options , & parseError , & gotStatus ) ; if ( expStatus != gotStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ status ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( gotStatus ) ) + " ▁ for ▁ Source : ▁ " + prettify ( srcUChars ) + " ▁ Options : ▁ " + options ) ; return UnicodeString ( " " ) ; } if ( U_SUCCESS ( expStatus ) ) { if ( u_strCompare ( exp , expLen , got , gotLen , TRUE ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ output ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ Expected : ▁ " + prettify ( UnicodeString ( exp , expLen ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( got , gotLen ) ) + " ▁ for ▁ Source : ▁ " + prettify ( srcUChars ) + " ▁ Options : ▁ " + options ) ; } return UnicodeString ( exp , expLen ) ; } else { logln ( " Got ▁ the ▁ same ▁ error ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ for ▁ input : ▁ " + prettify ( srcUChars ) ) ; } return UnicodeString ( " " ) ; } void TestIDNA :: testCompareReferenceImpl ( const UChar * src , int32_t srcLen ) { UnicodeString label ( src , srcLen ) ; label . append ( ( UChar ) 0x0000 ) ; UnicodeString asciiLabel = testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_ALLOW_UNASSIGNED ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_DEFAULT ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_USE_STD3_RULES ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_USE_STD3_RULES | UIDNA_ALLOW_UNASSIGNED ) ; if ( asciiLabel . length ( ) != 0 ) { asciiLabel . append ( ( UChar ) 0x0000 ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_ALLOW_UNASSIGNED ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_DEFAULT ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_USE_STD3_RULES ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_USE_STD3_RULES | UIDNA_ALLOW_UNASSIGNED ) ; } } const char * failures [ ] = { " \\uAA@@ 42\\U0001@@ F8DD\\U00019D0@@ 1\\U000149A3@@ \\uD385\\U000@@ EE0F5@@ \\U00018B92@@ \\U000179@@ D1\\U00018624@@ \\U0002227@@ F\\U000E83C@@ 0\\U000E8DCD@@ \\u54@@ 60\\U000@@ 17F34@@ \\U0001570B\\u@@ 43D1\\U0002C9@@ C9\\U00028@@ 1EC\\u210@@ 5\\U000180AE\\uC5@@ D4" , " \\U0002F5A6@@ \\uD638\\u0D0A@@ \\u9E9@@ C\\uFE5B@@ \\U0001FCC@@ B\\u66C4" , } ; void TestIDNA :: TestIDNAMonkeyTest ( ) { UnicodeString source ; UErrorCode status = U_ZERO_ERROR ; int i ; getInstance ( status ) ; if ( U_FAILURE ( status ) ) { dataerrln ( " Test ▁ could ▁ not ▁ initialize . ▁ Got ▁ % s " , u_errorName ( status ) ) ; return ; } for ( i = 0 ; i < loopCount ; i ++ ) { source . truncate ( 0 ) ; getTestSource ( source ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; } for ( i = 0 ; i < ( int ) ( sizeof ( failures ) / sizeof ( failures [ 0 ] ) ) ; i ++ ) { source . truncate ( 0 ) ; source . append ( UnicodeString ( failures [ i ] , - 1 , US_INV ) ) ; source = source . unescape ( ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; } source . truncate ( 0 ) ; source . append ( UNICODE_STRING@@ _SIMPLE ( " \\uCF18@@ \\U00021@@ 161\\U000@@ EEF11@@ \\U0002BB82\\U000@@ 1D63C " ) ) ; debug ( source . getBuffer ( ) , source . length ( ) , UIDNA_ALLOW_UNASSIGNED ) ; { UnicodeString source ( " \\u043f\\u00@@ AD\\u0@@ 34f\\u043e\\u04@@ 47\\u0435\\u043c\\u0443\\u0436\\u0435\\u043e\\u043d\\u0438\\u043d\\u0435\\u0433\\u043e\\u0432\\u043e\\u0440\\u044f\\u0442\\u043f\\u043e\\u0440\\u0443\\u0441\\u0441\\u043a\\u0438\\u0000" , - 1 , US_INV ) ; source = source . unescape ( ) ; UnicodeString expected ( " \\u043f\\u043e\\u0447\\u0435\\u043c\\u0443\\u0436\\u0435\\u043e\\u043d\\u0438\\u043d\\u0435\\u0433\\u043e\\u0432\\u043e\\u0440\\u044f\\u0442\\u043f\\u043e\\u0440\\u0443\\u0441\\u0441\\u043a\\u0438\\u0000" , - 1 , US_INV ) ; expected = expected . unescape ( ) ; UnicodeString ascii ( " xn - - b1abfaaepdrnnbgefbadotcwatmq2g4l " ) ; ascii . append ( ( UChar ) 0x0000 ) ; testAPI ( source . getBuffer ( ) , ascii . getBuffer ( ) , " uidna _ toASCII " , FALSE , U_ZERO_ERROR , TRUE , TRUE , uidna_toASCII ) ; testAPI ( source . getBuffer ( ) , ascii . getBuffer ( ) , " idnaref _ toASCII " , FALSE , U_ZERO_ERROR , TRUE , TRUE , idnaref_toASCII ) ; testCompareReferenceImpl ( source . getBuffer ( ) , source . length ( ) - 1 ) ; } } void TestIDNA :: TestCompareReferenceImpl ( ) { UChar src [ 2 ] = { 0 , 0 } ; int32_t srcLen = 0 ; for ( int32_t i = 0x40000 ; i < 0x10ffff ; i ++ ) { if ( quick == TRUE && i > 0x1FFFF ) { return ; } if ( i >= 0x30000 && i <= 0xF0000 ) { i += 0xB0000 ; } if ( i > 0xFFFF ) { src [ 0 ] = U16_LEAD ( i ) ; src [ 1 ] = U16_TRAIL ( i ) ; srcLen = 2 ; } else { src [ 0 ] = ( UChar ) i ; src [ 1 ] = 0 ; srcLen = 1 ; } testCompareReferenceImpl ( src , srcLen ) ; } } void TestIDNA :: TestRefIDNA ( ) { UErrorCode status = U_ZERO_ERROR ; getInstance ( status ) ; if ( U_FAILURE ( status ) ) { if ( status == U_FILE_ACCESS_ERROR ) { dataerrln ( " Test ▁ could ▁ not ▁ initialize . ▁ Got ▁ % s " , u_errorName ( status ) ) ; } return ; } testToASCII ( " idnaref _ toASCII " , idnaref_toASCII ) ; testToUnicode ( " idnaref _ toUnicode " , idnaref_toUnicode ) ; testIDNToASCII ( " idnaref _ IDNToASCII " , idnaref_IDNToASCII ) ; testIDNToUnicode ( " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testCompare ( " idnaref _ compare " , idnaref_compare ) ; testErrorCases ( " idnaref _ IDNToASCII " , idnaref_IDNToASCII , " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testChaining ( " idnaref _ toASCII " , idnaref_toASCII , " idnaref _ toUnicode " , idnaref_toUnicode ) ; testRootLabelSeparator ( " idnaref _ compare " , idnaref_compare , " idnaref _ IDNToASCII " , idnaref_IDNToASCII , " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testChaining ( " idnaref _ toASCII " , idnaref_toASCII , " idnaref _ toUnicode " , idnaref_toUnicode ) ; } void TestIDNA :: TestDataFile ( ) { testData ( * this ) ; } TestIDNA :: ~ TestIDNA ( ) { if ( gPrep != NULL ) { delete gPrep ; gPrep = NULL ; } } NamePrepTransform * TestIDNA :: gPrep = NULL ; NamePrepTransform * TestIDNA :: getInstance ( UErrorCode & status ) { if ( TestIDNA :: gPrep == NULL ) { UParseError parseError ; TestIDNA :: gPrep = NamePrepTransform :: createInstance ( parseError , status ) ; if ( TestIDNA :: gPrep == NULL ) { return NULL ; } } return TestIDNA :: gPrep ; } # endif </DOCUMENT>
<DOCUMENT_ID="waddlesp@@ lash/DolphinQt/tree/master/External@@ s/wxWidget@@ s3/src/osx/@@ carbon/textctr@@ l.cpp"> # include " wx / wxprec . h " # if wxUSE_TEXT@@ CTRL # include " wx / textctrl . h " # ifndef WX_PRECOMP # include " wx / intl . h " # include " wx / app . h " # include " wx / utils . h " # include " wx / dc . h " # include " wx / button . h " # include " wx / menu . h " # include " wx / settings . h " # include " wx / msgdlg . h " # include " wx / toplevel . h " # endif # ifdef __DAR@@ WIN__ # include < sys / types . h > # include < sys / stat . h > # else # include < stat . h > # endif # if wxUSE_STD_@@ IOSTREAM # if wxUSE_IOSTRE@@ AMH # include < fstream . h > # else # include < fstream > # endif # endif # include " wx / filefn . h " # include " wx / sysopt . h " # include " wx / thread . h " # include " wx / osx / private . h " # include " wx / osx / carbon / private / mactext . h " class wxMacFunctor { public : wxMacFunctor ( ) { } virtual ~ wxMacFunctor ( ) { } virtual void * operator ( ) ( ) = 0 ; static void * CallBackProc ( void * param ) { wxMacFunctor * f = ( wxMacFunctor * ) param ; void * result = ( * f ) ( ) ; return result ; } } ; template < typename classtype , typename param1type > class wxMacObjectFunctor1 : public wxMacFunctor { typedef void ( classtype :: * function ) ( param1type p1 ) ; typedef void ( classtype :: * ref_function ) ( const param1type & p1 ) ; public : wxMacObjectFunctor1 ( classtype * obj , function f , param1type p1 ) : wxMacFunctor ( ) { m_object = obj ; m_function = f ; m_param1 = p1 ; } wxMacObjectFunctor1 ( classtype * obj , ref_function f , param1type p1 ) : wxMacFunctor ( ) { m_object = obj ; m_refFunction = f ; m_param1 = p1 ; } virtual ~ wxMacObjectFunctor1 ( ) { } virtual void * operator ( ) ( ) { ( m_object ->* m_function ) ( m_param1 ) ; return NULL ; } private : classtype * m_object ; param1type m_param1 ; union { function m_function ; ref_function m_refFunction ; } ; } ; template < typename classtype , typename param1type > void * wxMacMPRemoteCall ( classtype * object , void ( classtype :: * function ) ( param1type p1 ) , param1type p1 ) { wxMacObjectFunctor1 < classtype , param1type > params ( object , function , p1 ) ; void * result = MPRemoteCall ( wxMacFunctor :: CallBackProc , & params , kMPOwningProcessRemoteContext ) ; return result ; } template < typename classtype , typename param1type > void * wxMacMPRemoteCall ( classtype * object , void ( classtype :: * function ) ( const param1type & p1 ) , param1type p1 ) { wxMacObjectFunctor1 < classtype , param1type > params ( object , function , p1 ) ; void * result = MPRemoteCall ( wxMacFunctor :: CallBackProc , & params , kMPOwningProcessRemoteContext ) ; return result ; } template < typename classtype , typename param1type > void * wxMacMPRemoteGUICall ( classtype * object , void ( classtype :: * function ) ( param1type p1 ) , param1type p1 ) { wxMutexGuiLeave ( ) ; void * result = wxMacMPRemoteCall ( object , function , p1 ) ; wxMutexGuiEnter ( ) ; return result ; } template < typename classtype , typename param1type > void * wxMacMPRemoteGUICall ( classtype * object , void ( classtype :: * function ) ( const param1type & p1 ) , param1type p1 ) { wxMutexGuiLeave ( ) ; void * result = wxMacMPRemoteCall ( object , function , p1 ) ; wxMutexGuiEnter ( ) ; return result ; } class WXDLLEXPORT wxMacPortSaver { wxDECLARE_NO_COPY_CLASS ( wxMacPortSaver ) ; public : wxMacPortSaver ( GrafPtr port ) ; ~ wxMacPortSaver ( ) ; private : GrafPtr m_port ; } ; class WXDLLEXPORT wxMacWindowClipper : public wxMacPortSaver { wxDECLARE_NO_COPY_CLASS ( wxMacWindowClipper ) ; public : wxMacWindowClipper ( const wxWindow * win ) ; ~ wxMacWindowClipper ( ) ; private : GrafPtr m_newPort ; RgnHandle m_formerClip ; RgnHandle m_newClip ; } ; wxMacPortSaver :: wxMacPortSaver ( GrafPtr port ) { :: GetPort ( & m_port ) ; :: SetPort ( port ) ; } wxMacPortSaver :: ~ wxMacPortSaver ( ) { :: SetPort ( m_port ) ; } wxMacWindowClipper :: wxMacWindowClipper ( const wxWindow * win ) : wxMacPortSaver ( ( GrafPtr ) GetWindowPort ( ( WindowRef ) win -> MacGetTopLevelWindowRef ( ) ) ) { m_newPort = ( GrafPtr ) GetWindowPort ( ( WindowRef ) win -> MacGetTopLevelWindowRef ( ) ) ; m_formerClip = NewRgn ( ) ; m_newClip = NewRgn ( ) ; GetClip ( m_formerClip ) ; if ( win ) { if ( win -> GetPeer ( ) ) { int x = 0 , y = 0 ; win -> MacWindow@@ ToRootWindow ( & x , & y ) ; HIShape@@ GetAsQDRgn ( ( ( wxWindow * ) win ) -> MacGetVisible@@ Region ( true ) . GetWXHRG@@ N ( ) , m_newClip ) ; if ( ! EmptyRgn ( m_newClip ) ) OffsetRgn ( m_newClip , x , y ) ; } SetClip ( m_newClip ) ; } } wxMacWindowClipper :: ~ wxMacWindowClipper ( ) { SetPort ( m_newPort ) ; SetClip ( m_formerClip ) ; DisposeRgn ( m_newClip ) ; DisposeRgn ( m_formerClip ) ; } class wxMacMLTEControl : public wxMacControl , public wxTextWidgetImpl { public : wxMacMLTEControl ( wxTextCtrl * peer ) ; ~ wxMacMLTEControl ( ) { } virtual bool CanFocus ( ) const { return true ; } virtual wxString GetStringValue ( ) const ; virtual void SetStringValue ( const wxString & str ) ; static TXNFrameOptions FrameOptionsFromWXStyle ( long wxStyle ) ; void AdjustCreationAttributes ( const wxColour & background , bool visible ) ; virtual void SetFont ( const wxFont & font , const wxColour & foreground , long windowStyle , bool ignoreBlack ) ; virtual void SetBackgroundColour ( const wxColour & col ) ; virtual void SetStyle ( long start , long end , const wxTextAttr & style ) ; virtual void Copy ( ) ; virtual void Cut ( ) ; virtual void Paste ( ) ; virtual bool CanPaste ( ) const ; virtual void SetEditable ( bool editable ) ; virtual long GetLastPosition ( ) const ; virtual void Replace ( long from , long to , const wxString & str ) ; virtual void Remove ( long from , long to ) ; virtual void GetSelection ( long * from , long * to ) const ; virtual void SetSelection ( long from , long to ) ; virtual void WriteText ( const wxString & str ) ; virtual bool HasOwn@@ ContextMenu ( ) const { TXNCommandEventSupportOptions options ; TXNGetCommandEventSupport ( m_txn , & options ) ; return options & kTXNSupportEditCommandProcessing ; } virtual void CheckSpelling ( bool check ) { TXNSetSpellCheck@@ AsYou@@ Type ( m_txn , ( Boolean ) check ) ; } virtual void Clear ( ) ; virtual bool CanUndo ( ) const ; virtual void Undo ( ) ; virtual bool CanRedo ( ) const ; virtual void Redo ( ) ; virtual int GetNumberOfLines ( ) const ; virtual long XYToPosition ( long x , long y ) const ; virtual bool PositionToXY ( long pos , long * x , long * y ) const ; virtual void ShowPosition ( long pos ) ; virtual int GetLineLength ( long lineNo ) const ; virtual wxString GetLineText ( long lineNo ) const ; void SetTXNData ( const wxString & st , TXNOffset start , TXNOffset end ) ; TXNObject GetTXNObject ( ) { return m_txn ; } protected : void TXNSetAttribute ( const wxTextAttr & style , long from , long to ) ; TXNObject m_txn ; } ; class wxMacMLTEHIViewControl : public wxMacMLTEControl { public : wxMacMLTEHIViewControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) ; virtual ~ wxMacMLTEHIViewControl ( ) ; virtual bool SetFocus ( ) ; virtual bool HasFocus ( ) const ; virtual void SetBackgroundColour ( const wxColour & col ) ; protected : HIViewRef m_scrollView ; HIViewRef m_textView ; } ; class wxMacMLTEClassicControl : public wxMacMLTEControl { public : wxMacMLTEClassicControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) ; virtual ~ wxMacMLTEClassicControl ( ) ; virtual void VisibilityChanged ( bool shown ) ; virtual void SuperChangedPosition ( ) ; virtual void MacControlUserPaneDrawProc ( wxInt16 part ) ; virtual wxInt16 MacControlUserPaneHitTestProc ( wxInt16 x , wxInt16 y ) ; virtual wxInt16 MacControlUserPaneTrackingProc ( wxInt16 x , wxInt16 y , void * actionProc ) ; virtual void MacControlUserPaneIdleProc ( ) ; virtual wxInt16 MacControlUserPaneKeyDown@@ Proc ( wxInt16 keyCode , wxInt16 charCode , wxInt16 modifiers ) ; virtual void MacControlUserPaneActivate@@ Proc ( bool activating ) ; virtual wxInt16 MacControlUserPaneFocusProc ( wxInt16 action ) ; virtual void MacControlUserPaneBackgroundProc ( void * info ) ; virtual bool SetupCursor ( const wxPoint & WXUNUSED ( pt ) ) { MacControlUserPaneIdleProc ( ) ; return true ; } virtual void Move ( int x , int y , int width , int height ) ; protected : OSStatus DoCreate ( ) ; void MacUpdate@@ Position ( ) ; void MacActivate@@ PaneText ( bool setActive ) ; void MacFocus@@ PaneText ( bool setFocus ) ; void MacSetObject@@ Visibility ( bool vis ) ; private : TXNFrameID m_txnFrameID ; GrafPtr m_txnPort ; WindowRef m_txnWindow ; Rect m_txnControlBounds ; Rect m_txnVis@@ Bounds ; static pascal void TXNScrollActionProc ( ControlRef controlRef , ControlPartCode partCode ) ; static pascal void TXNScrollInfoProc ( SInt32 iValue , SInt32 iMaximum@@ Value , TXNScrollBarOrientation iScrollBarOrientation , SInt32 iRefCon ) ; ControlRef m_sbHorizontal ; SInt32 m_lastHorizontalValue ; ControlRef m_sbVertical ; SInt32 m_lastVerticalValue ; } ; wxWidgetImplType * wxWidgetImpl :: CreateText@@ Control ( wxTextCtrl * wxpeer , wxWindowMac * WXUNUSED ( parent ) , wxWindowID WXUNUSED ( id ) , const wxString & str , const wxPoint & pos , const wxSize & size , long style , long WXUNUSED ( extraStyle ) ) { return new wxMacMLTEHIViewControl ( wxpeer , str , pos , size , style ) ; } static const EventTypeSpec unicodeTextControlEventList [ ] = { { kEventClassControl , kEventControlSetFocusPart } , } ; static pascal OSStatus wxMacUnicodeTextControlControlEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; wxMacUnicodeTextControl * focus = ( wxMacUnicodeTextControl * ) data ; wxMacCar@@ bonEvent cEvent ( event ) ; switch ( GetEventKind ( event ) ) { case kEventControlSetFocusPart : { ControlPartCode controlPart = cEvent . GetParameter < ControlPartCode > ( kEventParamControlPart , typeControlPartCode ) ; if ( controlPart == kControlFocusNoPart ) { focus -> GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & focus -> m_selection ) ; } result = CallNextEventHandler ( handler , event ) ; if ( controlPart != kControlFocusNoPart ) { focus -> SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & focus -> m_selection ) ; } break ; } default : break ; } return result ; } static pascal OSStatus wxMacUnicodeTextControlEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; switch ( GetEventClass ( event ) ) { case kEventClassControl : result = wxMacUnicodeTextControlControlEventHandler ( handler , event , data ) ; break ; default : break ; } return result ; } DEFINE_ONE_SHOT_HANDLER_GETTER ( wxMacUnicodeTextControlEventHandler ) wxMacUnicodeTextControl :: wxMacUnicodeTextControl ( wxTextCtrl * wxPeer ) : wxMacControl ( wxPeer ) , wxTextWidgetImpl ( wxPeer ) { } wxMacUnicodeTextControl :: wxMacUnicodeTextControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) : wxMacControl ( wxPeer ) , wxTextWidgetImpl ( wxPeer ) { m_font = wxPeer -> GetFont ( ) ; m_windowStyle = style ; m_selection . selStart = m_selection . selEnd = 0 ; Rect bounds = wxMacGetBoundsForControl ( wxPeer , pos , size ) ; wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; m_valueTag = kControlEditTextCFStringTag ; Boolean isPassword = ( m_windowStyle & wxTE_PASSWORD ) != 0 ; if ( isPassword ) { m_valueTag = kControlEditTextPassword@@ CFStringTag ; } OSStatus err = CreateEdit@@ UnicodeTextControl ( MAC_WXHWND ( wxPeer -> MacGetTopLevelWindowRef ( ) ) , & bounds , cf , isPassword , NULL , & m_controlRef ) ; verify_noerr ( err ) ; if ( ! ( m_windowStyle & wxTE_MULTILINE ) ) SetData < Boolean > ( kControlEditTextPart , kControlEditTextSingleLine@@ Tag , true ) ; InstallEventHandlers ( ) ; } void wxMacUnicodeTextControl :: InstallEventHandlers ( ) { :: InstallControlEventHandler ( m_controlRef , GetwxMacUnicodeTextControlEventHandlerUPP ( ) , GetEventTypeCount ( unicodeTextControlEventList ) , unicodeTextControlEventList , this , ( EventHandlerRef * ) & m_macTextCtrlEventHandler ) ; } wxMacUnicodeTextControl :: ~ wxMacUnicodeTextControl ( ) { :: RemoveEventHandler ( ( EventHandlerRef ) m_macTextCtrlEventHandler ) ; } void wxMacUnicodeTextControl :: VisibilityChanged ( bool shown ) { if ( ! ( m_windowStyle & wxTE_MULTILINE ) && shown ) { ControlEditTextSelectionRec sel ; CFStringRef value = NULL ; verify_noerr ( GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; verify_noerr ( GetData < CFStringRef > ( 0 , m_valueTag , & value ) ) ; verify_noerr ( SetData < CFStringRef > ( 0 , m_valueTag , & value ) ) ; verify_noerr ( SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; CFRelease ( value ) ; } } wxString wxMacUnicodeTextControl :: GetStringValue ( ) const { wxString result ; CFStringRef value = GetData < CFStringRef > ( 0 , m_valueTag ) ; if ( value ) { wxCFStringRef cf ( value ) ; result = cf . AsString ( ) ; } # if ' \n ' == 10 wxMacConvertNewlines13To10 ( & result ) ; # else wxMacConvertNewlines10To13 ( & result ) ; # endif return result ; } void wxMacUnicodeTextControl :: SetStringValue ( const wxString & str ) { wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; verify_noerr ( SetData < CFStringRef > ( 0 , m_valueTag , cf ) ) ; } void wxMacUnicodeTextControl :: Copy ( ) { SendHICommand ( kHICommandCopy ) ; } void wxMacUnicodeTextControl :: Cut ( ) { SendHICommand ( kHICommandCut ) ; } void wxMacUnicodeTextControl :: Paste ( ) { SendHICommand ( kHICommandPaste ) ; } bool wxMacUnicodeTextControl :: CanPaste ( ) const { return true ; } void wxMacUnicodeTextControl :: SetEditable ( bool WXUNUSED ( editable ) ) { # if 0 SetData < Boolean > ( kControlEditTextPart , kControlEditTextLockedTag , ( Boolean ) ! editable ) ; # endif } void wxMacUnicodeTextControl :: GetSelection ( long * from , long * to ) const { ControlEditTextSelectionRec sel ; if ( HasFocus ( ) ) verify_noerr ( GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; else sel = m_selection ; if ( from ) * from = sel . selStart ; if ( to ) * to = sel . selEnd ; } void wxMacUnicodeTextControl :: SetSelection ( long from , long to ) { ControlEditTextSelectionRec sel ; wxString result ; int textLength = 0 ; CFStringRef value = GetData < CFStringRef > ( 0 , m_valueTag ) ; if ( value ) { wxCFStringRef cf ( value ) ; textLength = cf . AsString ( ) . length ( ) ; } if ( ( from == - 1 ) && ( to == - 1 ) ) { from = 0 ; to = textLength ; } else { from = wxMin ( textLength , wxMax ( from , 0 ) ) ; if ( to == - 1 ) to = textLength ; else to = wxMax ( 0 , wxMin ( textLength , to ) ) ; } sel . selStart = from ; sel . selEnd = to ; if ( HasFocus ( ) ) SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ; else m_selection = sel ; } void wxMacUnicodeTextControl :: WriteText ( const wxString & str ) { if ( ! wxIsMainThread ( ) ) { # if wxOSX_USE_CARBON wxMacMPRemoteGUICall < wxTextCtrl , wxString > ( ( wxTextCtrl * ) GetWXPeer ( ) , & wxTextCtrl :: WriteText , str ) ; # endif return ; } wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; if ( HasFocus ( ) ) { wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; CFStringRef value = cf ; SetData < CFStringRef > ( 0 , kControlEditTextInsertCFString@@ RefTag , & value ) ; } else { wxString val = GetStringValue ( ) ; long start , end ; GetSelection ( & start , & end ) ; val . Remove ( start , end - start ) ; val . insert ( start , str ) ; SetStringValue ( val ) ; SetSelection ( start + str . length ( ) , start + str . length ( ) ) ; } } class wxMacEditHelper { public : wxMacEditHelper ( TXNObject txn ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; m_txn = txn ; TXNGetTXNObjectControls ( m_txn , 1 , tag , m_data ) ; if ( m_data [ 0 ] . uValue == kTXNReadOnly ) { TXNControlData data [ ] = { { kTXNReadWrite } } ; TXNSetTXNObjectControls ( m_txn , false , 1 , tag , data ) ; } } ~ wxMacEditHelper ( ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; if ( m_data [ 0 ] . uValue == kTXNReadOnly ) TXNSetTXNObjectControls ( m_txn , false , 1 , tag , m_data ) ; } protected : TXNObject m_txn ; TXNControlData m_data [ 1 ] ; } ; wxMacMLTEControl :: wxMacMLTEControl ( wxTextCtrl * peer ) : wxMacControl ( peer ) , wxTextWidgetImpl ( peer ) { SetNeedsFocusRect ( true ) ; } wxString wxMacMLTEControl :: GetStringValue ( ) const { wxString result ; OSStatus err ; Size actualSize = 0 ; { # if wxUSE_UNICODE Handle theText ; err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNUnicodeTextData ) ; if ( err != noErr ) { actualSize = 0 ; } else { actualSize = GetHandleSize ( theText ) / sizeof ( UniChar ) ; if ( actualSize > 0 ) { wxChar * ptr = NULL ; SetHandleSize ( theText , ( actualSize + 1 ) * sizeof ( UniChar ) ) ; HLock ( theText ) ; ( ( ( UniChar * ) * theText ) [ actualSize ] ) = 0 ; wxMBConvUTF16 converter ; size_t noChars = converter . MB2WC ( NULL , ( const char * ) * theText , 0 ) ; wxASSERT_MSG ( noChars != wxCONV_FAILED , wxT ( " Unable ▁ to ▁ count ▁ the ▁ number ▁ of ▁ characters ▁ in ▁ this ▁ string ! " ) ) ; ptr = new wxChar [ noChars + 1 ] ; noChars = converter . MB2WC ( ptr , ( const char * ) * theText , noChars + 1 ) ; wxASSERT_MSG ( noChars != wxCONV_FAILED , wxT ( " Conversion ▁ of ▁ string ▁ failed ! " ) ) ; ptr [ noChars ] = 0 ; HUnlock ( theText ) ; ptr [ actualSize ] = 0 ; result = wxString ( ptr ) ; delete [ ] ptr ; } DisposeHandle ( theText ) ; } # else Handle theText ; err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNTextData ) ; if ( err != noErr ) { actualSize = 0 ; } else { actualSize = GetHandleSize ( theText ) ; if ( actualSize > 0 ) { HLock ( theText ) ; result = wxString ( * theText , wxConvLocal , actualSize ) ; HUnlock ( theText ) ; } DisposeHandle ( theText ) ; } # endif } # if ' \n ' == 10 wxMacConvertNewlines13To10 ( & result ) ; # else wxMacConvertNewlines10To13 ( & result ) ; # endif return result ; } void wxMacMLTEControl :: SetStringValue ( const wxString & str ) { wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif { wxMacEditHelper help ( m_txn ) ; SetTXNData ( st , kTXNStartOffset , kTXNEndOffset ) ; } TXNSetSelection ( m_txn , 0 , 0 ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; } } TXNFrameOptions wxMacMLTEControl :: FrameOptionsFromWXStyle ( long wxStyle ) { TXNFrameOptions frameOptions = kTXNDontDrawCare@@ tWhenInactiveMask ; frameOptions |= kTXNDoFontSubstitution@@ Mask ; if ( ! ( wxStyle & wxTE_NOHID@@ ESEL ) ) frameOptions |= kTXNDontDrawSelectionWhenInactiveMask ; if ( wxStyle & ( wxHSCROLL | wxTE_DONTWRAP ) ) frameOptions |= kTXNWantHScrollBarMask ; if ( wxStyle & wxTE_MULTILINE ) { if ( ! ( wxStyle & wxTE_DONTWRAP ) ) frameOptions |= kTXNAlways@@ WrapAtView@@ EdgeMask ; if ( ! ( wxStyle & wxTE_NO_VSCROLL ) ) { frameOptions |= kTXNWantVScrollBarMask ; } } else { frameOptions |= kTXNSingleLineOnlyMask ; } return frameOptions ; } void wxMacMLTEControl :: AdjustCreationAttributes ( const wxColour & background , bool WXUNUSED ( visible ) ) { TXNControlTag iControlTags [ ] = { kTXNDoFontSubstitution , kTXNWord@@ WrapStateTag , } ; TXNControlData iControlData [ ] = { { true } , { kTXNNoAutoWrap } , } ; int toptag = WXSIZEOF ( iControlTags ) ; if ( m_windowStyle & wxTE_MULTILINE ) { iControlData [ 1 ] . uValue = ( m_windowStyle & wxTE_DONTWRAP ) ? kTXNNoAutoWrap : kTXNAutoWrap ; } OSStatus err = TXNSetTXNObjectControls ( m_txn , false , toptag , iControlTags , iControlData ) ; verify_noerr ( err ) ; Str255 fontName ; SInt16 fontSize ; Style fontStyle ; GetThemeFont ( kThemeSystemFont , GetApplicationScript ( ) , fontName , & fontSize , & fontStyle ) ; TXNTypeAttributes typeAttr [ ] = { { kTXNQDFontNameAttribute , kTXNQDFontNameAttributeSize , { ( void * ) fontName } } , { kTXNQDFontSizeAttribute , kTXNFont@@ SizeAttributeSize , { ( void * ) ( fontSize << 16 ) } } , { kTXNQDFontStyleAttribute , kTXNQDFontStyleAttributeSize , { ( void * ) normal } } , } ; err = TXNSetTypeAttributes ( m_txn , WXSIZEOF ( typeAttr ) , typeAttr , kTXNStartOffset , kTXNEndOffset ) ; verify_noerr ( err ) ; if ( m_windowStyle & wxTE_PASSWORD ) { UniChar c = 0x00A5 ; err = TXNEcho@@ Mode ( m_txn , c , 0 , true ) ; verify_noerr ( err ) ; } TXNBackground tback ; tback . bgType = kTXNBackgroundTypeRGB ; background . GetRGBColor ( & tback . bg . color ) ; TXNSetBackground ( m_txn , & tback ) ; TXNCommandEventSupportOptions options ; if ( TXNGetCommandEventSupport ( m_txn , & options ) == noErr ) { options |= kTXNSupportEditCommandProcessing | kTXNSupportEditCommandUpdating | kTXNSupportFontCommandProcessing | kTXNSupportFontCommandUpdating ; bool checkSpelling = false ; if ( ! ( m_windowStyle & wxTE_READONLY ) ) { # if wxUSE_SYSTE@@ M_OP@@ TIONS if ( wxSystemOptions :: HasOption ( wxMAC_TEXTCONTROL_USE_SPELL_CHECKER ) && ( wxSystemOptions :: GetOptionInt ( wxMAC_TEXTCONTROL_USE_SPELL_CHECKER ) == 1 ) ) { checkSpelling = true ; } # endif } if ( checkSpelling ) options |= kTXNSupportSpellCheckCommandProcessing | kTXNSupportSpellCheckCommandUpdating ; TXNSetCommandEventSupport ( m_txn , options ) ; } } void wxMacMLTEControl :: SetBackgroundColour ( const wxColour & col ) { TXNBackground tback ; tback . bgType = kTXNBackgroundTypeRGB ; col . GetRGBColor ( & tback . bg . color ) ; TXNSetBackground ( m_txn , & tback ) ; } static inline int wxConvertToTXN ( int x ) { return static_cast < int > ( x / 254.@@ 0 * 72 + 0.5 ) ; } void wxMacMLTEControl :: TXNSetAttribute ( const wxTextAttr & style , long from , long to ) { TXNTypeAttributes typeAttr [ 4 ] ; RGBColor color ; size_t typeAttrCount = 0 ; TXNMargins margins ; TXNControlTag controlTags [ 4 ] ; TXNControlData controlData [ 4 ] ; size_t controlAttrCount = 0 ; TXNTab * tabs = NULL ; bool relayout = false ; wxFont font ; if ( style . HasFont ( ) ) { wxASSERT ( typeAttrCount < WXSIZEOF ( typeAttr ) ) ; font = style . GetFont ( ) ; typeAttr [ typeAttrCount ] . tag = kTXNATSUIStyle ; typeAttr [ typeAttrCount ] . size = kTXNATSUIStyleSize ; typeAttr [ typeAttrCount ] . data . dataPtr = font . MacGetATSU@@ Style ( ) ; typeAttrCount ++ ; } if ( style . HasTextColour ( ) ) { wxASSERT ( typeAttrCount < WXSIZEOF ( typeAttr ) ) ; style . GetTextColour ( ) . GetRGBColor ( & color ) ; typeAttr [ typeAttrCount ] . tag = kTXNQDFontColorAttribute ; typeAttr [ typeAttrCount ] . size = kTXNQDFontColorAttributeSize ; typeAttr [ typeAttrCount ] . data . dataPtr = ( void * ) & color ; typeAttrCount ++ ; } if ( style . HasAlignment ( ) ) { wxASSERT ( controlAttrCount < WXSIZEOF ( controlTags ) ) ; SInt32 align ; switch ( style . GetAlignment ( ) ) { case wxTEXT_ALIGNMENT_LEFT : align = kTXNFlushLeft ; break ; case wxTEXT_ALIGNMENT_CENTR@@ E : align = kTXNCenter ; break ; case wxTEXT_ALIGNMENT_RIGHT : align = kTXNFlushRight ; break ; case wxTEXT_ALIGNMENT_JUS@@ TIFI@@ ED : align = kTXNFull@@ Just ; break ; default : case wxTEXT_ALIGNMENT_DEFAULT : align = kTXNFlushDefault ; break ; } controlTags [ controlAttrCount ] = kTXNJust@@ ificationTag ; controlData [ controlAttrCount ] . sValue = align ; controlAttrCount ++ ; } if ( style . HasLeftIndent ( ) || style . HasRightIndent ( ) ) { wxASSERT ( controlAttrCount < WXSIZEOF ( controlTags ) ) ; controlTags [ controlAttrCount ] = kTXNMarg@@ insTag ; controlData [ controlAttrCount ] . margins@@ Ptr = & margins ; verify_noerr ( TXNGetTXNObjectControls ( m_txn , 1 , & controlTags [ controlAttrCount ] , & controlData [ controlAttrCount ] ) ) ; if ( style . HasLeftIndent ( ) ) { margins . leftMargin = wxConvertToTXN ( style . GetLeftIndent ( ) ) ; } if ( style . HasRightIndent ( ) ) { margins . rightMargin = wxConvertToTXN ( style . GetRightIndent ( ) ) ; } controlAttrCount ++ ; } if ( style . HasTabs ( ) ) { const wxArrayInt & tabarray = style . GetTabs ( ) ; controlTags [ controlAttrCount ] = kTXNTab@@ SettingsTag ; if ( tabarray . size ( ) > 0 ) controlData [ controlAttrCount ] . tabValue . value = wxConvertToTXN ( tabarray [ 0 ] ) ; else controlData [ controlAttrCount ] . tabValue . value = 72 ; controlData [ controlAttrCount ] . tabValue . tabType = kTXNLeft@@ Tab ; controlAttrCount ++ ; } if ( controlAttrCount > 0 ) { verify_noerr ( TXNSetTXNObjectControls ( m_txn , false , controlAttrCount , controlTags , controlData ) ) ; relayout = true ; } if ( typeAttrCount > 0 ) { verify_noerr ( TXNSetTypeAttributes ( m_txn , typeAttrCount , typeAttr , from , to ) ) ; if ( from != to ) relayout = true ; } if ( tabs != NULL ) { delete [ ] tabs ; } if ( relayout ) { TXNRecalc@@ TextLayout ( m_txn ) ; } } void wxMacMLTEControl :: SetFont ( const wxFont & font , const wxColour & foreground , long WXUNUSED ( windowStyle ) , bool WXUNUSED ( ignoreBlack ) ) { wxMacEditHelper help ( m_txn ) ; TXNSetAttribute ( wxTextAttr ( foreground , wxNullColour , font ) , kTXNStartOffset , kTXNEndOffset ) ; } void wxMacMLTEControl :: SetStyle ( long start , long end , const wxTextAttr & style ) { wxMacEditHelper help ( m_txn ) ; TXNSetAttribute ( style , start , end ) ; } void wxMacMLTEControl :: Copy ( ) { TXNCopy ( m_txn ) ; } void wxMacMLTEControl :: Cut ( ) { TXNCut ( m_txn ) ; } void wxMacMLTEControl :: Paste ( ) { TXNPaste ( m_txn ) ; } bool wxMacMLTEControl :: CanPaste ( ) const { return TXNIsScrap@@ Pastable ( ) ; } void wxMacMLTEControl :: SetEditable ( bool editable ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; TXNControlData data [ ] = { { editable ? kTXNReadWrite : kTXNReadOnly } } ; TXNSetTXNObjectControls ( m_txn , false , WXSIZEOF ( tag ) , tag , data ) ; } long wxMacMLTEControl :: GetLastPosition ( ) const { wxTextPos actualsize = 0 ; Handle theText ; # if wxUSE_UNICODE OSErr err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNUnicodeTextData ) ; if ( err == noErr ) { actualsize = GetHandleSize ( theText ) / sizeof ( UniChar ) ; DisposeHandle ( theText ) ; } # else OSErr err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNTextData ) ; if ( err == noErr ) { actualsize = GetHandleSize ( theText ) ; DisposeHandle ( theText ) ; } # endif else { actualsize = 0 ; } return actualsize ; } void wxMacMLTEControl :: Replace ( long from , long to , const wxString & str ) { wxString value = str ; wxMacConvertNewlines10To13 ( & value ) ; wxMacEditHelper help ( m_txn ) ; # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif TXNSetSelection ( m_txn , from , to == - 1 ? kTXNEndOffset : to ) ; TXNClear ( m_txn ) ; SetTXNData ( value , kTXNUseCurrentSelection , kTXNUseCurrentSelection ) ; } void wxMacMLTEControl :: Remove ( long from , long to ) { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif wxMacEditHelper help ( m_txn ) ; TXNSetSelection ( m_txn , from , to ) ; TXNClear ( m_txn ) ; } void wxMacMLTEControl :: GetSelection ( long * from , long * to ) const { TXNOffset f , t ; TXNGetSelection ( m_txn , & f , & t ) ; * from = f ; * to = t ; } void wxMacMLTEControl :: SetSelection ( long from , long to ) { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif if ( ( from == - 1 ) && ( to == - 1 ) ) TXNSelect@@ All ( m_txn ) ; else TXNSetSelection ( m_txn , from , to == - 1 ? kTXNEndOffset : to ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; } void wxMacMLTEControl :: WriteText ( const wxString & str ) { if ( ! wxIsMainThread ( ) ) { # if wxOSX_USE_CARBON wxMacMPRemoteGUICall < wxTextCtrl , wxString > ( ( wxTextCtrl * ) GetWXPeer ( ) , & wxTextCtrl :: WriteText , str ) ; # endif return ; } wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; long start , end , dummy ; GetSelection ( & start , & dummy ) ; # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif { wxMacEditHelper helper ( m_txn ) ; SetTXNData ( st , kTXNUseCurrentSelection , kTXNUseCurrentSelection ) ; } GetSelection ( & dummy , & end ) ; } void wxMacMLTEControl :: Clear ( ) { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif wxMacEditHelper st ( m_txn ) ; TXNSetSelection ( m_txn , kTXNStartOffset , kTXNEndOffset ) ; TXNClear ( m_txn ) ; } bool wxMacMLTEControl :: CanUndo ( ) const { return TXNCanUndo ( m_txn , NULL ) ; } void wxMacMLTEControl :: Undo ( ) { TXNUndo ( m_txn ) ; } bool wxMacMLTEControl :: CanRedo ( ) const { return TXNCanRedo ( m_txn , NULL ) ; } void wxMacMLTEControl :: Redo ( ) { TXNRedo ( m_txn ) ; } int wxMacMLTEControl :: GetNumberOfLines ( ) const { ItemCount lines = 0 ; TXNGetLineCount ( m_txn , & lines ) ; return lines ; } long wxMacMLTEControl :: XYToPosition ( long x , long y ) const { Point curpt ; wxTextPos lastpos ; long xpos = 0 , ypos = 0 ; int lastHeight = 0 ; ItemCount n ; lastpos = GetLastPosition ( ) ; for ( n = 0 ; n <= ( ItemCount ) lastpos ; ++ n ) { if ( y == ypos && x == xpos ) return n ; TXNOffsetToPoint ( m_txn , n , & curpt ) ; if ( curpt . v > lastHeight ) { xpos = 0 ; if ( n > 0 ) ++ ypos ; lastHeight = curpt . v ; } else ++ xpos ; } return 0 ; } bool wxMacMLTEControl :: PositionToXY ( long pos , long * x , long * y ) const { Point curpt ; wxTextPos lastpos ; if ( y ) * y = 0 ; if ( x ) * x = 0 ; lastpos = GetLastPosition ( ) ; if ( pos <= lastpos ) { long xpos = 0 , ypos = 0 ; int lastHeight = 0 ; ItemCount n ; for ( n = 0 ; n <= ( ItemCount ) pos ; ++ n ) { TXNOffsetToPoint ( m_txn , n , & curpt ) ; if ( curpt . v > lastHeight ) { xpos = 0 ; if ( n > 0 ) ++ ypos ; lastHeight = curpt . v ; } else ++ xpos ; } if ( y ) * y = ypos ; if ( x ) * x = xpos ; } return false ; } void wxMacMLTEControl :: ShowPosition ( long pos ) { Point current , desired ; TXNOffset selstart , selend ; TXNGetSelection ( m_txn , & selstart , & selend ) ; TXNOffsetToPoint ( m_txn , selstart , & current ) ; TXNOffsetToPoint ( m_txn , pos , & desired ) ; OSErr theErr = noErr ; long dv = desired . v - current . v ; long dh = desired . h - current . h ; TXNShowSelection ( m_txn , kTXNShowStart ) ; theErr = TXNScroll ( m_txn , kTXNScrollUnitsInPixels , kTXNScrollUnitsInPixels , & dv , & dh ) ; } void wxMacMLTEControl :: SetTXNData ( const wxString & st , TXNOffset start , TXNOffset end ) { # if wxUSE_UNICODE wxMBConvUTF16 converter ; ByteCount byteBufferLen = converter . WC2MB ( NULL , st . wc_str ( ) , 0 ) ; wxASSERT_MSG ( byteBufferLen != wxCONV_FAILED , wxT ( " Conversion ▁ to ▁ UTF - 16 ▁ unexpectedly ▁ failed " ) ) ; UniChar * unibuf = ( UniChar * ) malloc ( byteBufferLen + 2 ) ; converter . WC2MB ( ( char * ) unibuf , st . wc_str ( ) , byteBufferLen + 2 ) ; TXNSetData ( m_txn , kTXNUnicodeTextData , ( void * ) unibuf , byteBufferLen , start , end ) ; free ( unibuf ) ; # else wxCharBuffer text = st . mb_str ( wxConvLocal ) ; TXNSetData ( m_txn , kTXNTextData , ( void * ) text . data ( ) , strlen ( text ) , start , end ) ; # endif } wxString wxMacMLTEControl :: GetLineText ( long lineNo ) const { wxString line ; if ( lineNo < GetNumberOfLines ( ) ) { Point firstPoint ; Fixed lineWidth , lineHeight , currentHeight ; long ypos ; TXNOffsetToPoint ( m_txn , 0 , & firstPoint ) ; ypos = 0 ; currentHeight = 0 ; while ( ypos < lineNo ) { TXNGetLineMetrics ( m_txn , ypos ++ , & lineWidth , & lineHeight ) ; currentHeight += lineHeight ; } Point thePoint = { firstPoint . v + ( currentHeight >> 16 ) , firstPoint . h + ( 0 ) } ; TXNOffset theOffset ; TXNPointToOffset ( m_txn , thePoint , & theOffset ) ; wxString content = GetStringValue ( ) ; Point currentPoint = thePoint ; while ( thePoint . v == currentPoint . v && theOffset < content . length ( ) ) { line += content [ theOffset ] ; TXNOffsetToPoint ( m_txn , ++ theOffset , & currentPoint ) ; } } return line ; } int wxMacMLTEControl :: GetLineLength ( long lineNo ) const { int theLength = 0 ; if ( lineNo < GetNumberOfLines ( ) ) { Point firstPoint ; Fixed lineWidth , lineHeight , currentHeight ; long ypos ; TXNOffsetToPoint ( m_txn , 0 , & firstPoint ) ; ypos = 0 ; currentHeight = 0 ; while ( ypos < lineNo ) { TXNGetLineMetrics ( m_txn , ypos ++ , & lineWidth , & lineHeight ) ; currentHeight += lineHeight ; } Point thePoint = { firstPoint . v + ( currentHeight >> 16 ) , firstPoint . h + ( 0 ) } ; TXNOffset theOffset ; TXNPointToOffset ( m_txn , thePoint , & theOffset ) ; wxString content = GetStringValue ( ) ; Point currentPoint = thePoint ; while ( thePoint . v == currentPoint . v && theOffset < content . length ( ) ) { ++ theLength ; TXNOffsetToPoint ( m_txn , ++ theOffset , & currentPoint ) ; } } return theLength ; } static const EventTypeSpec eventList [ ] = { { kEventClassTextInput , kEventTextInputUnicodeForKeyEvent } , } ; static pascal OSStatus wxMacUnicodeTextEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; wxMacMLTEHIViewControl * focus = ( wxMacMLTEHIViewControl * ) data ; switch ( GetEventKind ( event ) ) { case kEventTextInputUnicodeForKeyEvent : { TXNOffset from , to ; TXNGetSelection ( focus -> GetTXNObject ( ) , & from , & to ) ; if ( from == to ) TXNShowSelection ( focus -> GetTXNObject ( ) , kTXNShowStart ) ; result = CallNextEventHandler ( handler , event ) ; break ; } default : break ; } return result ; } static pascal OSStatus wxMacTextControlEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; switch ( GetEventClass ( event ) ) { case kEventClassTextInput : result = wxMacUnicodeTextEventHandler ( handler , event , data ) ; break ; default : break ; } return result ; } DEFINE_ONE_SHOT_HANDLER_GETTER ( wxMacTextControlEventHandler ) wxMacMLTEHIViewControl :: wxMacMLTEHIViewControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) : wxMacMLTEControl ( wxPeer ) { m_font = wxPeer -> GetFont ( ) ; m_windowStyle = style ; Rect bounds = wxMacGetBoundsForControl ( wxPeer , pos , size ) ; wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; HIRect hr = { { bounds . left , bounds . top } , { bounds . right - bounds . left , bounds . bottom - bounds . top } } ; m_scrollView = NULL ; TXNFrameOptions frameOptions = FrameOptionsFromWXStyle ( style ) ; if ( ( frameOptions & ( kTXNWantVScrollBarMask | kTXNWantHScrollBarMask ) ) || ( frameOptions & kTXNSingleLineOnlyMask ) ) { if ( frameOptions & ( kTXNWantVScrollBarMask | kTXNWantHScrollBarMask ) ) { HIScrollViewCreate ( ( frameOptions & kTXNWantHScrollBarMask ? kHIScrollViewOptionsHorizScroll : 0 ) | ( frameOptions & kTXNWantVScrollBarMask ? kHIScrollViewOptionsVertScroll : 0 ) , & m_scrollView ) ; } else { HIScrollViewCreate ( kHIScrollViewOptionsVertScroll , & m_scrollView ) ; HIScrollViewSetScrollBar@@ AutoHide ( m_scrollView , true ) ; } HIViewSetFrame ( m_scrollView , & hr ) ; HIViewSetVisible ( m_scrollView , true ) ; } m_textView = NULL ; HITextViewCreate ( NULL , 0 , frameOptions , & m_textView ) ; m_txn = HITextViewGetTXNObject ( m_textView ) ; HIViewSetVisible ( m_textView , true ) ; if ( m_scrollView ) { HIViewAddSub@@ view ( m_scrollView , m_textView ) ; m_controlRef = m_scrollView ; InstallEventHandler ( ( WXWidget ) m_textView ) ; } else { HIViewSetFrame ( m_textView , & hr ) ; m_controlRef = m_textView ; } AdjustCreationAttributes ( * wxWHITE , true ) ; # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif SetTXNData ( st , kTXNStartOffset , kTXNEndOffset ) ; TXNSetSelection ( m_txn , 0 , 0 ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; :: InstallControlEventHandler ( m_textView , GetwxMacTextControlEventHandlerUPP ( ) , GetEventTypeCount ( eventList ) , eventList , this , NULL ) ; } wxMacMLTEHIViewControl :: ~ wxMacMLTEHIViewControl ( ) { } bool wxMacMLTEHIViewControl :: SetFocus ( ) { return SetKeyboardFocus ( GetControlOwner ( m_textView ) , m_textView , kControlFocusNextPart ) == noErr ; } bool wxMacMLTEHIViewControl :: HasFocus ( ) const { ControlRef control ; if ( GetUserFocusWindow ( ) == NULL ) return false ; GetKeyboard@@ Focus ( GetUserFocusWindow ( ) , & control ) ; return control == m_textView ; } void wxMacMLTEHIViewControl :: SetBackgroundColour ( const wxColour & col ) { HITextViewSetBackgroundColor ( m_textView , col . GetPixel ( ) ) ; } # endif </DOCUMENT>
<DOCUMENT_ID="pete318@@ /TrinityCore/tree/master/src/server/scripts/Northrend/@@ Frozen@@ Halls/HallsOfRef@@ lection/halls_of_reflection@@ .cpp"> # include " halls _ of _ reflection . h " # include " Creature . h " # include " EventProcess@@ or . h " # include " InstanceScript . h " # include " MotionMaster . h " # include " MoveSpline@@ Init . h " # include " ObjectAccessor . h " # include " ObjectGuid . h " # include " Player . h " # include " ScriptedCreature . h " # include " ScriptedGossip . h " # include " ScriptMgr . h " # include " Spell . h " # include " SpellInfo . h " # include " SpellScript . h " # include " Temporary@@ Summon . h " # include " Transport . h " # include " Unit . h " enum Text { SAY_JAINA_INTRO_1 = 0 , SAY_JAINA_INTRO_2 = 1 , SAY_JAINA_INTRO_3 = 2 , SAY_JAINA_INTRO_4 = 3 , SAY_JAINA_INTRO_5 = 4 , SAY_JAINA_INTRO_6 = 5 , SAY_JAINA_INTRO_7 = 6 , SAY_JAINA_INTRO_8 = 7 , SAY_JAINA_INTRO_9 = 8 , SAY_JAINA_INTRO_10 = 9 , SAY_JAINA_INTRO_11 = 10 , SAY_JAINA_INTRO_END = 11 , SAY_SYLVANAS_INTRO_1 = 0 , SAY_SYLVANAS_INTRO_2 = 1 , SAY_SYLVANAS_INTRO_3 = 2 , SAY_SYLVANAS_INTRO_4 = 3 , SAY_SYLVANAS_INTRO_5 = 4 , SAY_SYLVANAS_INTRO_6 = 5 , SAY_SYLVANAS_INTRO_7 = 6 , SAY_SYLVANAS_INTRO_8 = 7 , SAY_SYLVANAS_INTRO_END = 8 , SAY_UTHER_INTRO_A2_1 = 0 , SAY_UTHER_INTRO_A2_2 = 1 , SAY_UTHER_INTRO_A2_3 = 2 , SAY_UTHER_INTRO_A2_4 = 3 , SAY_UTHER_INTRO_A2_5 = 4 , SAY_UTHER_INTRO_A2_6 = 5 , SAY_UTHER_INTRO_A2_7 = 6 , SAY_UTHER_INTRO_A2_8 = 7 , SAY_UTHER_INTRO_A2_9 = 8 , SAY_UTHER_INTRO_H2_1 = 9 , SAY_UTHER_INTRO_H2_2 = 10 , SAY_UTHER_INTRO_H2_3 = 11 , SAY_UTHER_INTRO_H2_4 = 12 , SAY_UTHER_INTRO_H2_5 = 13 , SAY_UTHER_INTRO_H2_6 = 14 , SAY_UTHER_INTRO_H2_7 = 15 , SAY_LK_INTRO_1 = 0 , SAY_LK_INTRO_2 = 1 , SAY_LK_INTRO_3 = 2 , SAY_LK_JAINA_INTRO_END = 3 , SAY_LK_SYLVANAS_INTRO_END = 4 , SAY_JAINA_SYLVANAS_ESCAPE_1 = 0 , SAY_JAINA_SYLVANAS_ESCAPE_2 = 1 , SAY_JAINA_SYLVANAS_ESCAPE_3 = 2 , SAY_JAINA_SYLVANAS_ESCAPE_4 = 3 , SAY_JAINA_SYLVANAS_ESCAPE_5 = 4 , SAY_JAINA_SYLVANAS_ESCAPE_6 = 5 , SAY_JAINA_SYLVANAS_ESCAPE_7 = 6 , SAY_JAINA_SYLVANAS_ESCAPE_8 = 7 , SAY_JAINA_ESCAPE_9 = 8 , SAY_JAINA_ESCAPE_10 = 9 , SAY_SYLVANAS_ESCAPE_9 = 8 , SAY_LK_ESCAPE_1 = 0 , SAY_LK_ESCAPE_2 = 1 , SAY_LK_ESCAPE_ICEWALL_SUMMONED_1 = 2 , SAY_LK_ESCAPE_ICEWALL_SUMMONED_2 = 3 , SAY_LK_ESCAPE_ICEWALL_SUMMONED_3 = 4 , SAY_LK_ESCAPE_ICEWALL_SUMMONED_4 = 5 , SAY_LK_ESCAPE_GHOULS = 6 , SAY_LK_ESCAPE_ABOMINATION = 7 , SAY_LK_ESCAPE_WINTER = 8 , SAY_LK_ESCAPE_HARVEST_SOUL = 9 , SAY_FALRIC_INTRO_1 = 5 , SAY_FALRIC_INTRO_2 = 6 , SAY_MARWYN_INTRO_1 = 4 } ; enum Events { EVENT_WALK_INTRO1 = 1 , EVENT_WALK_INTRO2 , EVENT_START_INTRO , EVENT_SKIP_INTRO , EVENT_INTRO_A2_1 , EVENT_INTRO_A2_2 , EVENT_INTRO_A2_3 , EVENT_INTRO_A2_4 , EVENT_INTRO_A2_5 , EVENT_INTRO_A2_6 , EVENT_INTRO_A2_7 , EVENT_INTRO_A2_8 , EVENT_INTRO_A2_9 , EVENT_INTRO_A2_10 , EVENT_INTRO_A2_11 , EVENT_INTRO_A2_12 , EVENT_INTRO_A2_13 , EVENT_INTRO_A2_14 , EVENT_INTRO_A2_15 , EVENT_INTRO_A2_16 , EVENT_INTRO_A2_17 , EVENT_INTRO_A2_18 , EVENT_INTRO_A2_19 , EVENT_INTRO_H2_1 , EVENT_INTRO_H2_2 , EVENT_INTRO_H2_3 , EVENT_INTRO_H2_4 , EVENT_INTRO_H2_5 , EVENT_INTRO_H2_6 , EVENT_INTRO_H2_7 , EVENT_INTRO_H2_8 , EVENT_INTRO_H2_9 , EVENT_INTRO_H2_10 , EVENT_INTRO_H2_11 , EVENT_INTRO_H2_12 , EVENT_INTRO_H2_13 , EVENT_INTRO_H2_14 , EVENT_INTRO_H2_15 , EVENT_INTRO_LK_1 , EVENT_INTRO_LK_2 , EVENT_INTRO_LK_3 , EVENT_INTRO_LK_4 , EVENT_INTRO_LK_5 , EVENT_INTRO_LK_6 , EVENT_INTRO_LK_7 , EVENT_INTRO_LK_8 , EVENT_INTRO_LK_9 , EVENT_INTRO_LK_10 , EVENT_INTRO_LK_11 , EVENT_INTRO_END , EVENT_ESCAPE , EVENT_ESCAPE_1 , EVENT_ESCAPE_2 , EVENT_ESCAPE_3 , EVENT_ESCAPE_4 , EVENT_ESCAPE_5 , EVENT_ESCAPE_6 , EVENT_ESCAPE_7 , EVENT_ESCAPE_8 , EVENT_ESCAPE_9 , EVENT_ESCAPE_10 , EVENT_ESCAPE_11 , EVENT_ESCAPE_12 , EVENT_ESCAPE_13 , EVENT_ESCAPE_14 , EVENT_ESCAPE_15 , EVENT_ESCAPE_16 , EVENT_ESCAPE_17 , EVENT_REMORSELESS_WINTER , EVENT_ESCAPE_SUMMON_GHOULS , EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , EVENT_OPEN_IMPENETRABLE_DOOR , EVENT_CLOSE_IMPENETRABLE_DOOR , EVENT_KORELN_LORALEN_DEATH } ; enum Misc { ACTION_START_INTRO , ACTION_SKIP_INTRO , JAINA_SYLVANAS_MAX_HEALTH = 252000 , POINT_SHADOW_THRONE_DOOR = 1 , POINT_ATTACK_ICEWALL = 2 , POINT_TRAP = 3 , SOUND_LK_SLAY_1 = 17214 , SOUND_LK_SLAY_2 = 17215 , SOUND_LK_FURY_OF_FROSTMOURNE = 17224 } ; enum Spells { SPELL_TAKE_FROSTMOURNE = 72729 , SPELL_FROSTMOURNE_DESPAWN = 72726 , SPELL_FROSTMOURNE_VISUAL = 73220 , SPELL_FROSTMOURNE_SOUNDS = 70667 , SPELL_BOSS_SPAWN_AURA = 72712 , SPELL_UTHER_DESPAWN = 70693 , SPELL_CAST_VISUAL = 65633 , SPELL_SUMMON_SOULS = 72711 , SPELL_TAUNT_ARTHAS = 6985@@ 7 , SPELL_JAINA_ICE_BARRIER = 69787 , SPELL_JAINA_ICE_PRISON = 69708 , SPELL_JAINA_DESTROY_ICE_WALL = 69784 , SPELL_SYLVANAS_CLOAK_OF_DARKNESS = 70188 , SPELL_SYLVANAS_DARK_BINDING = 70194 , SPELL_SYLVANAS_DESTROY_ICE_WALL = 70224 , SPELL_SYLVANAS_BLINDING_RETREAT = 70199 , SPELL_REMORSELESS_WINTER = 69780 , SPELL_SOU@@ L_REAPER = 69409 , SPELL_FURY_OF_FROSTMOURNE = 70063 , SPELL_RAISE_DEAD = 69818 , SPELL_SUMMON_RISEN_WITCH_DOCTOR = 69836 , SPELL_SUMMON_LUMBERING_ABOMINATION = 69835 , SPELL_SUMMON_ICE_WALL = 69768 , SPELL_PAIN_AND_SUFFERING = 74115 , SPELL_STUN_BREAK_JAINA = 69764 , SPELL_STUN_BREAK_SYLVANAS = 70200 , SPELL_HARVEST_SOUL = 69866 , SPELL_FEIGN_DEATH = 29266 , SPELL_GHOUL_JUMP = 70150 , SPELL_RAGING_GHOUL_SPAWN = 69636 , SPELL_CURSE_OF_DOOM = 70144 , SPELL_SHADOW_BOLT_VOLLEY = 70145 , SPELL_SHADOW_BOLT = 70080 , SPELL_RISEN_WITCH_DOCTOR_SPAWN = 6963@@ 9 , SPELL_CLEAVE = 4050@@ 5 , SPELL_VOMIT_SPRAY = 70176 } ; enum HorGossipMenu { GOSSIP_MENU_JAINA_FINAL = 10930 , GOSSIP_MENU_SYLVANAS_FINAL = 1093@@ 1 } ; Position const NpcJainaOrSylvanasEscapeRoute [ ] = { { 5601.2@@ 17285f , 2207.65@@ 2832f , 731.54193@@ 1f , 5.223304f } , { 5607.224375f , 2173.91333@@ 0f , 731.1260@@ 38f , 2.608@@ 723f } , { 5583.@@ 427246f , 2138.784@@ 180f , 731.15039@@ 1f , 4.260@@ 901f } , { 5560.@@ 281738f , 2104.02563@@ 5f , 731.410@@ 889f , 4.058383f } , { 5510.9@@ 90723f , 2000.7@@ 72217f , 734.7@@ 16064f , 3.97@@ 3213f } , { 5452.6411@@ 13f , 1905.@@ 76232@@ 9f , 746.@@ 530579@@ f , 4.1188@@ 34f } , { 5338.1269@@ 53f , 1768.42@@ 9810f , 767.23@@ 7244f , 3.855@@ 189f } , { 5259.06f , 1669@@ .27f , 784.3008f , 0.0f } , { 5265.53f , 1681.6f , 784.2947f , 4.13643f } } ; Position const LichKingMoveAwayPos = { 5400.0@@ 69824f , 2102.7@@ 13168@@ 9f , 707.69525f , 0.8438@@ 03f } ; Position const LichKingFirstSummon = { 5600.0@@ 76172@@ f , 2192.270996f , 731.750488f , 4.330@@ 935f } ; Position const JainaSylvanasShadowThrone@@ Door = { 5577.243@@ f , 2235.852f , 733.0128f , 2.20956@@ 2f } ; Position const LichKingFinalPos = { 5283.74218@@ 8f , 1706.335@@ 693f , 783.@@ 293518f , 4.138510f } ; Position const KorelnOrLoralenPos [ ] = { { 5253.06@@ 1f , 1953.616f , 707.6948f , 0.8377581f } , { 5283.226f , 1992.300@@ f , 707.744@@ 5f , 0.8377581f } , { 5360.7@@ 11f , 2064.79@@ 7f , 707.6948f , 0.0f } } ; Position const SylvanasIntroPosition [ ] = { { 0.0f , 0.0f , 0.0f , 0.0f } , { 5263.2f , 1950.96@@ f , 707.6948f , 0.8028514f } , { 5306.82f , 1998.17f , 709.341f , 1.23@@ 9184f } , } ; Position const JainaIntroPosition [ ] = { { 0.0f , 0.0f , 0.0f , 0.0f } , { 5265.89f , 1952.98@@ f , 707.6978f , 0.0f } , { 5306.95f , 1998.49f , 709.3414f , 1.27@@ 7278f } } ; Position const UtherSpawnPos = { 5307.814f , 2003.@@ 168f , 709.42@@ 44f , 4.53@@ 7856@@ f } ; Position const LichKingIntroPosition [ ] = { { 5362.@@ 463f , 2062.@@ 693f , 707.778@@ 1f , 3.94444@@ 4f } , { 5332.83f , 2031.24f , 707.6948f , 0.0f } , { 5312.@@ 93f , 2010.@@ 24f , 709.34f , 0.0f } , { 5319.0@@ 28f , 2016.66@@ 2f , 707.6948f , 0.0f } , { 5332.28@@ 5f , 2030.832f , 707.6948f , 0.0f } , { 5355.@@ 488f , 2055.@@ 149f , 707.6907f , 0.0f } } ; Position const FalricPosition [ ] = { { 5276.58@@ 3f , 2037.4@@ 5f , 709.4025f , 5.532@@ 694f } , { 5283.95f , 2030.53f , 709.3191f , 0.0f } } ; Position const MarwynPosition [ ] = { { 5342.232f , 1975@@ .696f , 709.4025f , 2.39@@ 1101f } , { 5335.01f , 1982.37f , 709.3191f , 0.0f } } ; Position const SylvanasShadowThroneDoorPosition = { 5576@@ .79f , 2235.73f , 733.00@@ 29f , 2.6878@@ 07f } ; Position const IceWallTargetPosition [ ] = { { 5547.833@@ f , 2083.@@ 701f , 731.4332f , 1.029744f } , { 5503@@ .213f , 1969@@ .547f , 737.024@@ 5f , 1.27409f } , { 5439.976@@ f , 1879@@ .005f , 752.7@@ 048f , 1.06465@@ 1f } , { 5318.@@ 289f , 1749.184f , 771.94@@ 23f , 0.872664@@ 6f } } ; class npc_jaina_or_sylvanas_intro_hor : public CreatureScript { public : npc_jaina_or_sylvanas_intro_hor ( ) : CreatureScript ( " npc _ jaina _ or _ sylvanas _ intro _ hor " ) { } struct npc_jaina_or_sylvanas_intro_horAI : public ScriptedAI { npc_jaina_or_sylvanas_intro_horAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; } bool GossipHello ( Player * player ) override { if ( _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) == IN_PROGRESS || _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) == SPECIAL ) { ClearGossipMenuFor ( player ) ; return true ; } return false ; } bool GossipSelect ( Player * player , uint32 , uint32 gossipListId ) override { ClearGossipMenuFor ( player ) ; switch ( gossipListId ) { case 0 : player -> PlayerTalkClass -> SendCloseGossip ( ) ; _events . ScheduleEvent ( EVENT_START_INTRO , 1s ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; case 1 : player -> PlayerTalkClass -> SendCloseGossip ( ) ; _events . ScheduleEvent ( EVENT_SKIP_INTRO , 1s ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; default : break ; } return false ; } void Reset ( ) override { _events . Reset ( ) ; _utherGUID . Clear ( ) ; _lichkingGUID . Clear ( ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; me -> SetStandState ( UNIT_STAND_STATE_STAND ) ; _events . ScheduleEvent ( EVENT_WALK_INTRO1 , 3000 ) ; } void UpdateAI ( uint32 diff ) override { _events . Update ( diff ) ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_WALK_INTRO1 : if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> GetMotionMaster ( ) -> MovePoint ( 0 , KorelnOrLoralenPos [ 0 ] ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) { me -> GetMotionMaster ( ) -> MovePoint ( 0 , JainaIntroPosition [ 1 ] ) ; Talk ( SAY_JAINA_INTRO_1 ) ; _events . ScheduleEvent ( EVENT_WALK_INTRO2 , 7000 ) ; } else { me -> GetMotionMaster ( ) -> MovePoint ( 0 , SylvanasIntroPosition [ 1 ] ) ; Talk ( SAY_SYLVANAS_INTRO_1 ) ; _events . ScheduleEvent ( EVENT_WALK_INTRO2 , 9000 ) ; } break ; case EVENT_WALK_INTRO2 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) Talk ( SAY_JAINA_INTRO_2 ) ; else Talk ( SAY_SYLVANAS_INTRO_2 ) ; me -> SetFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; case EVENT_START_INTRO : if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> GetMotionMaster ( ) -> MovePoint ( 0 , KorelnOrLoralenPos [ 1 ] ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) { me -> GetMotionMaster ( ) -> MovePoint ( 0 , JainaIntroPosition [ 2 ] ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_1 , 0 ) ; } else { me -> GetMotionMaster ( ) -> MovePoint ( 0 , SylvanasIntroPosition [ 2 ] ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_1 , 0 ) ; } break ; case EVENT_INTRO_A2_1 : Talk ( SAY_JAINA_INTRO_3 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_2 , 7000 ) ; break ; case EVENT_INTRO_A2_2 : Talk ( SAY_JAINA_INTRO_4 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_3 , 10000 ) ; break ; case EVENT_INTRO_A2_3 : me -> CastSpell ( me , SPELL_CAST_VISUAL , false ) ; me -> CastSpell ( me , SPELL_FROSTMOURNE_SOUNDS , true ) ; _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_FROSTMOURNE ) , true ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_4 , 10000 ) ; break ; case EVENT_INTRO_A2_4 : if ( Creature * uther = me -> SummonCreature ( NPC_UTHER , UtherSpawnPos , TEMPSUMMON_MANUAL_DESPAWN ) ) _utherGUID = uther -> GetGUID ( ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_5 , 2000 ) ; break ; case EVENT_INTRO_A2_5 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_1 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_6 , 3000 ) ; break ; case EVENT_INTRO_A2_6 : Talk ( SAY_JAINA_INTRO_5 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_7 , 7000 ) ; break ; case EVENT_INTRO_A2_7 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_2 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_8 , 7000 ) ; break ; case EVENT_INTRO_A2_8 : Talk ( SAY_JAINA_INTRO_6 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_9 , 1200 ) ; break ; case EVENT_INTRO_A2_9 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_3 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_10 , 11000 ) ; break ; case EVENT_INTRO_A2_10 : Talk ( SAY_JAINA_INTRO_7 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_11 , 6000 ) ; break ; case EVENT_INTRO_A2_11 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_4 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_12 , 12000 ) ; break ; case EVENT_INTRO_A2_12 : Talk ( SAY_JAINA_INTRO_8 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_13 , 6000 ) ; break ; case EVENT_INTRO_A2_13 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_5 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_14 , 13000 ) ; break ; case EVENT_INTRO_A2_14 : Talk ( SAY_JAINA_INTRO_9 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_15 , 12000 ) ; break ; case EVENT_INTRO_A2_15 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_6 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_16 , 25000 ) ; break ; case EVENT_INTRO_A2_16 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_7 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_17 , 6000 ) ; break ; case EVENT_INTRO_A2_17 : Talk ( SAY_JAINA_INTRO_10 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_18 , 5000 ) ; break ; case EVENT_INTRO_A2_18 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) { uther -> HandleEmoteCommand ( EMOTE_ONESHOT_NO ) ; uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_8 ) ; } _events . ScheduleEvent ( EVENT_INTRO_A2_19 , 12000 ) ; break ; case EVENT_INTRO_A2_19 : Talk ( SAY_JAINA_INTRO_11 ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_1 , 3000 ) ; break ; case EVENT_INTRO_H2_1 : Talk ( SAY_SYLVANAS_INTRO_1 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_2 , 8000 ) ; break ; case EVENT_INTRO_H2_2 : Talk ( SAY_SYLVANAS_INTRO_2 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_3 , 6000 ) ; break ; case EVENT_INTRO_H2_3 : Talk ( SAY_SYLVANAS_INTRO_3 ) ; me -> CastSpell ( me , SPELL_CAST_VISUAL , false ) ; me -> CastSpell ( me , SPELL_FROSTMOURNE_SOUNDS , true ) ; _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_FROSTMOURNE ) , true ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_4 , 6000 ) ; break ; case EVENT_INTRO_H2_4 : if ( Creature * uther = me -> SummonCreature ( NPC_UTHER , UtherSpawnPos , TEMPSUMMON_MANUAL_DESPAWN ) ) _utherGUID = uther -> GetGUID ( ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_5 , 2000 ) ; break ; case EVENT_INTRO_H2_5 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_1 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_6 , 11000 ) ; break ; case EVENT_INTRO_H2_6 : Talk ( SAY_SYLVANAS_INTRO_4 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_7 , 3000 ) ; break ; case EVENT_INTRO_H2_7 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_2 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_8 , 6000 ) ; break ; case EVENT_INTRO_H2_8 : Talk ( SAY_SYLVANAS_INTRO_5 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_9 , 5000 ) ; break ; case EVENT_INTRO_H2_9 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_3 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_10 , 19000 ) ; break ; case EVENT_INTRO_H2_10 : Talk ( SAY_SYLVANAS_INTRO_6 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_11 , 1500 ) ; break ; case EVENT_INTRO_H2_11 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_4 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_12 , 19500 ) ; break ; case EVENT_INTRO_H2_12 : Talk ( SAY_SYLVANAS_INTRO_7 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_13 , 2000 ) ; break ; case EVENT_INTRO_H2_13 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) { uther -> HandleEmoteCommand ( EMOTE_ONESHOT_NO ) ; uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_5 ) ; } _events . ScheduleEvent ( EVENT_INTRO_H2_14 , 12000 ) ; break ; case EVENT_INTRO_H2_14 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_6 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_15 , 8000 ) ; break ; case EVENT_INTRO_H2_15 : Talk ( SAY_SYLVANAS_INTRO_8 ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_1 , 2000 ) ; break ; case EVENT_INTRO_LK_1 : if ( Creature * lichking = me -> SummonCreature ( NPC_THE_LICH_KING_INTRO , LichKingIntroPosition [ 0 ] , TEMPSUMMON_MANUAL_DESPAWN ) ) { lichking -> SetWalk ( true ) ; lichking -> GetMotionMaster ( ) -> MovePoint ( 0 , LichKingIntroPosition [ 2 ] ) ; _lichkingGUID = lichking -> GetGUID ( ) ; _events . ScheduleEvent ( EVENT_OPEN_IMPENETRABLE_DOOR , 0 ) ; _events . ScheduleEvent ( EVENT_CLOSE_IMPENETRABLE_DOOR , 4s ) ; } if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) { uther -> SetUInt32Value ( UNIT_NPC_@@ EMOTESTATE , EMOTE_STATE_COWER ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_9 ) ; else uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_7 ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_2 , 10000 ) ; break ; case EVENT_INTRO_LK_2 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) lichking -> AI ( ) -> Talk ( SAY_LK_INTRO_1 ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_3 , 1000 ) ; break ; case EVENT_INTRO_LK_3 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) { uther -> CastSpell ( uther , SPELL_UTHER_DESPAWN , true ) ; uther -> DespawnOrUnsummon ( 5000 ) ; _utherGUID . Clear ( ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_4 , 9000 ) ; break ; case EVENT_INTRO_LK_4 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) { if ( GameObject * frostmourne = ObjectAccessor :: GetGameObject ( * me , _instance -> GetGuidData ( DATA_FROSTMOURNE ) ) ) frostmourne -> SetPhaseMask ( 2 , true ) ; lichking -> CastSpell ( lichking , SPELL_TAKE_FROSTMOURNE , true ) ; lichking -> CastSpell ( lichking , SPELL_FROSTMOURNE_VISUAL , true ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_5 , 8000 ) ; break ; case EVENT_INTRO_LK_5 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) lichking -> AI ( ) -> Talk ( SAY_LK_INTRO_2 ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_6 , 10000 ) ; break ; case EVENT_INTRO_LK_6 : if ( Creature * falric = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FALRIC ) ) ) { falric -> CastSpell ( falric , SPELL_BOSS_SPAWN_AURA , true ) ; falric -> SetVisible ( true ) ; } if ( Creature * marwyn = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_MARWYN ) ) ) { marwyn -> CastSpell ( marwyn , SPELL_BOSS_SPAWN_AURA , true ) ; marwyn -> SetVisible ( true ) ; } if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) { lichking -> AI ( ) -> Talk ( SAY_LK_INTRO_3 ) ; lichking -> SetWalk ( true ) ; lichking -> GetMotionMaster ( ) -> MovePoint ( 0 , LichKingMoveAwayPos ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_7 , 10000 ) ; _events . ScheduleEvent ( EVENT_OPEN_IMPENETRABLE_DOOR , 5s ) ; break ; case EVENT_INTRO_LK_7 : if ( Creature * marwyn = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_MARWYN ) ) ) { marwyn -> AI ( ) -> Talk ( SAY_MARWYN_INTRO_1 ) ; marwyn -> SetWalk ( true ) ; marwyn -> GetMotionMaster ( ) -> MovePoint ( 0 , MarwynPosition [ 1 ] ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_8 , 1000 ) ; break ; case EVENT_INTRO_LK_8 : if ( Creature * falric = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FALRIC ) ) ) { falric -> AI ( ) -> Talk ( SAY_FALRIC_INTRO_1 ) ; falric -> SetWalk ( true ) ; falric -> GetMotionMaster ( ) -> MovePoint ( 0 , FalricPosition [ 1 ] ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_9 , 5000 ) ; break ; case EVENT_INTRO_LK_9 : if ( Creature * falric = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FALRIC ) ) ) falric -> AI ( ) -> Talk ( SAY_FALRIC_INTRO_2 ) ; _instance -> ProcessEvent ( 0 , EVENT_SPAWN_WAVES ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_10 , 4000 ) ; break ; case EVENT_INTRO_LK_10 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) Talk ( SAY_JAINA_INTRO_END ) ; else Talk ( SAY_SYLVANAS_INTRO_END ) ; me -> GetMotionMaster ( ) -> MovePoint ( 0 , LichKingMoveAwayPos ) ; if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> GetMotionMaster ( ) -> MovePoint ( 1 , KorelnOrLoralenPos [ 2 ] ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_11 , 5000 ) ; break ; case EVENT_INTRO_LK_11 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) { if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) lichking -> AI ( ) -> Talk ( SAY_LK_JAINA_INTRO_END ) ; else lichking -> AI ( ) -> Talk ( SAY_LK_SYLVANAS_INTRO_END ) ; } _events . ScheduleEvent ( EVENT_INTRO_END , 5s ) ; break ; case EVENT_INTRO_END : _instance -> SetData ( DATA_INTRO_EVENT , DONE ) ; _events . ScheduleEvent ( EVENT_KORELN_LORALEN_DEATH , 8s ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) { lichking -> DespawnOrUnsummon ( 5000 ) ; _lichkingGUID . Clear ( ) ; } me -> DespawnOrUnsummon ( 10000 ) ; _events . ScheduleEvent ( EVENT_CLOSE_IMPENETRABLE_DOOR , 7s ) ; break ; case EVENT_SKIP_INTRO : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) me -> GetMotionMaster ( ) -> MovePoint ( 0 , JainaIntroPosition [ 2 ] ) ; else me -> GetMotionMaster ( ) -> MovePoint ( 0 , SylvanasIntroPosition [ 2 ] ) ; if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> GetMotionMaster ( ) -> MovePoint ( 0 , KorelnOrLoralenPos [ 1 ] ) ; if ( Creature * lichking = me -> SummonCreature ( NPC_THE_LICH_KING_INTRO , LichKingIntroPosition [ 0 ] , TEMPSUMMON_MANUAL_DESPAWN ) ) { lichking -> SetWalk ( true ) ; lichking -> GetMotionMaster ( ) -> MovePoint ( 0 , LichKingIntroPosition [ 2 ] ) ; lichking -> SetReactState ( REACT_PASSIVE ) ; _lichkingGUID = lichking -> GetGUID ( ) ; _events . ScheduleEvent ( EVENT_OPEN_IMPENETRABLE_DOOR , 0 ) ; _events . ScheduleEvent ( EVENT_CLOSE_IMPENETRABLE_DOOR , 4s ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_4 , 15000 ) ; break ; case EVENT_OPEN_IMPENETRABLE_DOOR : _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_IMPENETRABLE_DOOR ) , true ) ; break ; case EVENT_CLOSE_IMPENETRABLE_DOOR : _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_IMPENETRABLE_DOOR ) , false ) ; break ; case EVENT_KORELN_LORALEN_DEATH : if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> CastSpell ( korelnOrLoralen , SPELL_FEIGN_DEATH ) ; break ; default : break ; } } private : InstanceScript * _instance ; EventMap _events ; ObjectGuid _utherGUID ; ObjectGuid _lichkingGUID ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_jaina_or_sylvanas_intro_horAI > ( creature ) ; } } ; class HoRGameObjectDeleteDelayEvent : public BasicEvent { public : explicit HoRGameObjectDeleteDelayEvent ( Unit * owner , ObjectGuid gameObjectGUID ) : _owner ( owner ) , _gameObjectGUID ( gameObjectGUID ) { } void DeleteGameObject ( ) { if ( GameObject * go = ObjectAccessor :: GetGameObject ( * _owner , _gameObjectGUID ) ) go -> Delete ( ) ; } bool Execute ( uint64 , uint32 ) override { DeleteGameObject ( ) ; return true ; } void Abort ( uint64 ) override { DeleteGameObject ( ) ; } private : Unit * _owner ; ObjectGuid _gameObjectGUID ; } ; class npc_jaina_or_sylvanas_escape_hor : public CreatureScript { public : npc_jaina_or_sylvanas_escape_hor ( ) : CreatureScript ( " npc _ jaina _ or _ sylvanas _ escape _ hor " ) { } struct npc_jaina_or_sylvanas_escape_horAI : public ScriptedAI { npc_jaina_or_sylvanas_escape_horAI ( Creature * creature ) : ScriptedAI ( creature ) , _instance ( creature -> GetInstanceScript ( ) ) , _icewall ( 0 ) , _prefight ( false ) , _invincibility ( true ) { } void Reset ( ) override { _events . Reset ( ) ; _icewall = 0 ; _events . ScheduleEvent ( EVENT_ESCAPE , 1s ) ; _instance -> DoStop@@ TimedAchievement ( ACHIEVEMENT_TIMED_TYPE_EVENT , ACHIEV_NOT_RETREATING_EVENT ) ; } void JustDied ( Unit * ) override { if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> AI ( ) -> EnterEvadeMode ( ) ; } void DamageTaken ( Unit * , uint32 & damage ) override { if ( damage >= me -> GetHealth ( ) && _invincibility ) damage = me -> GetHealth ( ) - 1 ; } void DoAction ( int32 actionId ) override { switch ( actionId ) { case ACTION_START_PREFIGHT : if ( _prefight ) return ; _prefight = true ; _events . ScheduleEvent ( EVENT_ESCAPE_1 , 1000 ) ; break ; case ACTION_WALL_BROKEN : ++ _icewall ; if ( _icewall < 4 ) _events . ScheduleEvent ( EVENT_ESCAPE_13 , 3000 ) ; else _events . ScheduleEvent ( EVENT_ESCAPE_15 , 3000 ) ; break ; case ACTION_GUNSHIP_ARRIVAL : _events . ScheduleEvent ( EVENT_ESCAPE_16 , 5000 ) ; break ; case ACTION_GUNSHIP_ARRIVAL_2 : _events . ScheduleEvent ( EVENT_ESCAPE_17 , 5000 ) ; break ; default : break ; } } bool GossipHello ( Player * player ) override { if ( _instance -> GetBossState ( DATA_THE_LICH_KING_ESCAPE ) == DONE ) { player -> PrepareGossipMenu ( me , me -> GetEntry ( ) == NPC_JAINA_ESCAPE ? GOSSIP_MENU_JAINA_FINAL : GOSSIP_MENU_SYLVANAS_FINAL , true ) ; player -> SendPrepared@@ Gossip ( me ) ; return true ; } return false ; } bool GossipSelect ( Player * player , uint32 , uint32 gossipListId ) override { ClearGossipMenuFor ( player ) ; switch ( gossipListId ) { case 0 : player -> PlayerTalkClass -> SendCloseGossip ( ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP ) ; _events . ScheduleEvent ( EVENT_ESCAPE_6 , 0 ) ; break ; default : break ; } return false ; } void DestroyIceWall ( ) { if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) me -> RemoveAurasDueToSpell ( SPELL_JAINA_DESTROY_ICE_WALL ) ; else me -> RemoveAurasDueToSpell ( SPELL_SYLVANAS_DESTROY_ICE_WALL ) ; _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_ICEWALL ) , true ) ; me -> m_Events . AddEvent ( new HoRGameObjectDeleteDelayEvent ( me , _instance -> GetGuidData ( DATA_ICEWALL ) ) , me -> m_Events . CalculateTime ( 5000 ) ) ; if ( Creature * wallTarget = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ICEWALL_TARGET ) ) ) wallTarget -> DespawnOrUnsummon ( ) ; } void SummonIceWall ( ) { if ( _icewall < 4 ) { if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> StopMoving ( ) ; if ( Creature * wallTarget = me -> SummonCreature ( NPC_ICE_WAL@@ L_TARGET , IceWallTargetPosition [ _icewall ] , TEMPSUMMON_MANUAL_DESPAWN , 720000 ) ) lichking -> CastSpell ( wallTarget , SPELL_SUMMON_ICE_WALL ) ; lichking -> AI ( ) -> SetData ( DATA_ICEWALL , _icewall ) ; } } } void AttackIceWall ( ) { if ( _icewall < 4 ) Talk ( SAY_JAINA_SYLVANAS_ESCAPE_2 + _icewall ) ; if ( Creature * wallTarget = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ICEWALL_TARGET ) ) ) me -> SetFacingToObject ( wallTarget ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_JAINA_DESTROY_ICE_WALL , true ) ; else DoCast ( me , SPELL_SYLVANAS_DESTROY_ICE_WALL , true ) ; } void MovementInform ( uint32 type , uint32 pointId ) override { if ( type != POINT_MOTION_TYPE ) return ; switch ( pointId ) { case POINT_SHADOW_THRONE_DOOR : if ( me -> GetEntry ( ) == NPC_JAINA_ESCAPE ) me -> RemoveAurasDueToSpell ( SPELL_JAINA_ICE_BARRIER ) ; else me -> RemoveAurasDueToSpell ( SPELL_SYLVANAS_CLOAK_OF_DARKNESS ) ; me -> SetFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP ) ; me -> SetHealth ( JAINA_SYLVANAS_MAX_HEALTH ) ; me -> SetFacingTo ( SylvanasShadowThroneDoorPosition . GetOrientation ( ) ) ; break ; case POINT_ATTACK_ICEWALL : AttackIceWall ( ) ; break ; case POINT_TRAP : Talk ( SAY_JAINA_SYLVANAS_ESCAPE_8 ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) me -> SetFacingToObject ( lichking ) ; break ; default : break ; } } void DeleteAllFromThreatList ( Unit * target , ObjectGuid except ) { for ( ThreatReference * ref : target -> GetThreatManager ( ) . GetModifiable@@ ThreatList ( ) ) if ( ref -> GetVictim ( ) -> GetGUID ( ) != except ) ref -> ClearThreat ( ) ; } void UpdateAI ( uint32 diff ) override { _events . Update ( diff ) ; while ( uint32 event = _events . ExecuteEvent ( ) ) { switch ( event ) { case EVENT_ESCAPE : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_JAINA_ICE_BARRIER ) ; else DoCast ( me , SPELL_SYLVANAS_CLOAK_OF_DARKNESS ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { me -> CastSpell ( lichking , SPELL_TAUNT_ARTHAS , true ) ; lichking -> ApplySpellImmune ( 0 , IMMUNITY@@ _STATE , SPELL_AURA_MOD_TA@@ UNT , true ) ; lichking -> ApplySpellImmune ( 0 , IMMUNITY_EFFECT , SPELL_EFFECT_ATTACK_@@ ME , true ) ; AttackStart ( lichking ) ; lichking -> AI ( ) -> AttackStart ( me ) ; } me -> SetHealth ( JAINA_SYLVANAS_MAX_HEALTH ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; case EVENT_ESCAPE_1 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) lichking -> AI ( ) -> Talk ( SAY_LK_ESCAPE_1 ) ; else lichking -> AI ( ) -> Talk ( SAY_LK_ESCAPE_2 ) ; _events . ScheduleEvent ( EVENT_ESCAPE_2 , 8000 ) ; } break ; case EVENT_ESCAPE_2 : me -> AttackStop ( ) ; me -> StopMoving ( ) ; me -> SetReactState ( REACT_PASSIVE ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_JAINA_ICE_PRISON , false ) ; else DoCast ( me , SPELL_SYLVANAS_BLINDING_RETREAT , true ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> SetReactState ( REACT_PASSIVE ) ; lichking -> SetFlag ( UNIT_FIELD_FLAGS , UNIT_FLAG_PACIFIED ) ; } _events . ScheduleEvent ( EVENT_ESCAPE_3 , 1500 ) ; break ; case EVENT_ESCAPE_3 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == HORDE ) DoCastAOE ( SPELL_SYLVANAS_DARK_BINDING , true ) ; _events . ScheduleEvent ( EVENT_ESCAPE_4 , 1000 ) ; break ; case EVENT_ESCAPE_4 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_CREDIT_FINDING_JAINA ) ; else DoCast ( me , SPELL_CREDIT_FINDING@@ _SYLVANAS ) ; Talk ( SAY_JAINA_SYLVANAS_ESCAPE_1 ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> SetImmuneToPC ( true ) ; lichking -> RemoveAllAttackers ( ) ; DeleteAllFromThreatList ( lichking , me -> GetGUID ( ) ) ; } _events . ScheduleEvent ( EVENT_ESCAPE_5 , 2000 ) ; break ; case EVENT_ESCAPE_5 : me -> GetMotionMaster ( ) -> MovePoint ( POINT_SHADOW_THRONE_DOOR , SylvanasShadowThroneDoorPosition ) ; break ; case EVENT_ESCAPE_6 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> RemoveFlag ( UNIT_FIELD_FLAGS , UNIT_FLAG_PACIFIED ) ; lichking -> SetImmuneToPC ( false ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) { lichking -> CastSpell ( lichking , SPELL_STUN_BREAK_JAINA ) ; lichking -> RemoveAurasDueToSpell ( SPELL_JAINA_ICE_PRISON ) ; } else { lichking -> CastSpell ( lichking , SPELL_STUN_BREAK_SYLVANAS ) ; lichking -> RemoveAurasDueToSpell ( SPELL_SYLVANAS_DARK_BINDING ) ; } } _invincibility = false ; _instance -> DoStartTimedAchievement ( ACHIEVEMENT_TIMED_TYPE_EVENT , ACHIEV_NOT_RETREATING_EVENT ) ; _events . ScheduleEvent ( EVENT_ESCAPE_7 , 1000 ) ; break ; case EVENT_ESCAPE_7 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> HandleEmoteCommand ( TEXT_EMOTE_@@ ROAR ) ; me -> GetMotionMaster ( ) -> MovePoint ( 0 , NpcJainaOrSylvanasEscapeRoute [ 0 ] ) ; _events . ScheduleEvent ( EVENT_ESCAPE_8 , 3000 ) ; break ; case EVENT_ESCAPE_8 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> GetMotionMaster ( ) -> MovePoint ( 0 , NpcJainaOrSylvanasEscapeRoute [ 0 ] ) ; _events . ScheduleEvent ( EVENT_ESCAPE_9 , 1000 ) ; break ; case EVENT_ESCAPE_9 : me -> GetMotionMaster ( ) -> MovePoint ( 0 , NpcJainaOrSylvanasEscapeRoute [ 1 ] ) ; _events . ScheduleEvent ( EVENT_ESCAPE_10 , 5000 ) ; break ; case EVENT_ESCAPE_10 : me -> GetMotionMaster ( ) -> MovePoint ( 0 , NpcJainaOrSylvanasEscapeRoute [ 2 ] ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> GetMotionMaster ( ) -> MovePoint ( 1 , LichKingFirstSummon ) ; _events . ScheduleEvent ( EVENT_ESCAPE_11 , 6000 ) ; break ; case EVENT_ESCAPE_11 : SummonIceWall ( ) ; _events . ScheduleEvent ( EVENT_ESCAPE_12 , 4000 ) ; break ; case EVENT_ESCAPE_12 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> CastSpell ( lichking , SPELL_PAIN_AND_SUFFERING , true ) ; me -> GetMotionMaster ( ) -> MovePoint ( POINT_ATTACK_ICEWALL , NpcJainaOrSylvanasEscapeRoute [ 3 ] ) ; break ; case EVENT_ESCAPE_13 : DestroyIceWall ( ) ; if ( _icewall && _icewall < 4 ) me -> GetMotionMaster ( ) -> MovePoint ( POINT_ATTACK_ICEWALL , NpcJainaOrSylvanasEscapeRoute [ _icewall + 3 ] ) ; _events . ScheduleEvent ( EVENT_ESCAPE_14 , 8000 ) ; break ; case EVENT_ESCAPE_14 : SummonIceWall ( ) ; break ; case EVENT_ESCAPE_15 : DestroyIceWall ( ) ; Talk ( SAY_JAINA_SYLVANAS_ESCAPE_6 ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> GetMotionMaster ( ) -> MovePoint ( 2 , LichKingFinalPos ) ; lichking -> RemoveAurasDueToSpell ( SPELL_REMORSELESS_WINTER ) ; } me -> GetMotionMaster ( ) -> MovePoint ( POINT_TRAP , NpcJainaOrSylvanasEscapeRoute [ 7 ] ) ; break ; case EVENT_ESCAPE_16 : me -> RemoveAurasDueToSpell ( SPELL_HARVEST_SOUL ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) Talk ( SAY_JAINA_ESCAPE_9 ) ; if ( Transport * gunship = ObjectAccessor :: GetTransport ( * me , _instance -> GetGuidData ( DATA_GUNSHIP ) ) ) gunship -> EnableMovement ( true ) ; _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , DONE ) ; break ; case EVENT_ESCAPE_17 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) Talk ( SAY_JAINA_ESCAPE_10 ) ; else Talk ( SAY_SYLVANAS_ESCAPE_9 ) ; DoCast ( me , SPELL_CREDIT_ESCAPING_A@@ RTHAS ) ; me -> SetFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } private : InstanceScript * _instance ; EventMap _events ; uint32 _icewall ; bool _prefight ; bool _invincibility ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_jaina_or_sylvanas_escape_horAI > ( creature ) ; } } ; class npc_the_lich_king_escape_hor : public CreatureScript { public : npc_the_lich_king_escape_hor ( ) : CreatureScript ( " npc _ the _ lich _ king _ escape _ hor " ) { } struct npc_the_lich_king_escape_horAI : public ScriptedAI { npc_the_lich_king_escape_horAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , NOT_STARTED ) ; _summonsCount = 0 ; _icewall = 0 ; _despawn = false ; } void DamageTaken ( Unit * , uint32 & damage ) override { if ( damage >= me -> GetHealth ( ) ) damage = me -> GetHealth ( ) - 1 ; } void MovementInform ( uint32 type , uint32 pointId ) override { if ( type == POINT_MOTION_TYPE ) { switch ( pointId ) { case 1 : if ( Creature * target = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ESCAPE_LEADER ) ) ) me -> GetMotionMaster ( ) -> MoveChase ( target ) ; break ; case 2 : Talk ( SAY_LK_ESCAPE_HARVEST_SOUL ) ; if ( Creature * target = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ESCAPE_LEADER ) ) ) DoCast ( target , SPELL_HARVEST_SOUL ) ; if ( Transport * gunship = ObjectAccessor :: GetTransport ( * me , _instance -> GetGuidData ( DATA_GUNSHIP ) ) ) gunship -> EnableMovement ( true ) ; break ; default : break ; } } } void JustSummoned ( Creature * ) override { ++ _summonsCount ; } void SummonedCreatureDies ( Creature * , Unit * ) override { if ( ! _summonsCount ) return ; -- _summonsCount ; if ( ! _summonsCount && _events . Empty ( ) ) { if ( Creature * jainaOrSylvanas = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ESCAPE_LEADER ) ) ) jainaOrSylvanas -> AI ( ) -> DoAction ( ACTION_WALL_BROKEN ) ; } } void KilledUnit ( Unit * who ) override { if ( who -> GetTypeId ( ) == TYPEID_PLAYER ) DoPlaySoundToSet ( me , RAND ( SOUND_LK_SLAY_1 , SOUND_LK_SLAY_2 ) ) ; } void SetData ( uint32 type , uint32 data ) override { if ( type != DATA_ICEWALL ) return ; _icewall = data ; switch ( _icewall ) { case 0 : DoZoneInCombat ( ) ; _events . ScheduleEvent ( EVENT_REMORSELESS_WINTER , 0 ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 8s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 14s ) ; Talk ( SAY_LK_ESCAPE_ICEWALL_SUMMONED_1 ) ; break ; case 1 : _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 8s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 13s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 15s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 18s ) ; Talk ( SAY_LK_ESCAPE_ICEWALL_SUMMONED_2 ) ; break ; case 2 : _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 9s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 14s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 15s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 19s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 39s ) ; Talk ( SAY_LK_ESCAPE_ICEWALL_SUMMONED_3 ) ; break ; case 3 : _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 9s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 15s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 19s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 40s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 45s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 55s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 62s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 65s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 14s ) ; Talk ( SAY_LK_ESCAPE_ICEWALL_SUMMONED_4 ) ; break ; default : break ; } } void EnterEvadeMode ( EvadeReason ) override { if ( _despawn ) return ; _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , FAIL ) ; me -> StopMoving ( ) ; DoPlaySoundToSet ( me , SOUND_LK_FURY_OF_FROSTMOURNE ) ; DoCastAOE ( SPELL_FURY_OF_FROSTMOURNE ) ; me -> DespawnOrUnsummon ( 12000 ) ; _despawn = true ; } void UpdateAI ( uint32 diff ) override { if ( ! SelectVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; while ( uint32 event = _events . ExecuteEvent ( ) ) { switch ( event ) { case EVENT_REMORSELESS_WINTER : me -> StopMoving ( ) ; Talk ( SAY_LK_ESCAPE_WINTER ) ; DoCast ( me , SPELL_REMORSELESS_WINTER ) ; break ; case EVENT_ESCAPE_SUMMON_GHOULS : me -> StopMoving ( ) ; Talk ( SAY_LK_ESCAPE_GHOULS ) ; DoCast ( me , SPELL_RAISE_DEAD ) ; break ; case EVENT_ESCAPE_SUMMON_WITCH_DOCTOR : DoCast ( me , SPELL_SUMMON_RISEN_WITCH_DOCTOR ) ; break ; case EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION : Talk ( SAY_LK_ESCAPE_ABOMINATION ) ; DoCast ( me , SPELL_SUMMON_LUMBERING_ABOMINATION ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } private : bool SelectVictim ( ) { if ( ! me -> IsInCombat ( ) ) return false ; if ( ! me -> HasReactState ( REACT_PASSIVE ) ) { if ( Unit * victim = me -> SelectVictim ( ) ) if ( ! me -> HasSpell@@ Focus ( ) && victim != me -> GetVictim ( ) ) AttackStart ( victim ) ; return me -> GetVictim ( ) != nullptr ; } else if ( me -> GetCombatManager ( ) . GetPvECombatRefs ( ) . size ( ) < 2 && me -> HasAura ( SPELL_REMORSELESS_WINTER ) ) { EnterEvadeMode ( EVADE_REASON_@@ OTHER ) ; return false ; } return true ; } InstanceScript * _instance ; EventMap _events ; uint8 _icewall ; uint32 _summonsCount ; bool _despawn ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_the_lich_king_escape_horAI > ( creature ) ; } } ; enum TrashSpells { SPELL_SHADOW_WORD_PAIN = 72318 , SPELL_CIRCLE_OF_DESTRUCTION = 72320 , SPELL_COWER_IN_FEAR = 72321 , SPELL_DARK_MENDING = 72322 , SPELL_FIREBALL = 72163 , SPELL_FLAMESTRIKE = 72169 , SPELL_FROSTBOLT = 72166 , SPELL_CHAINS_OF_ICE = 72121 , SPELL_HALLUCINATION = 72342 , AURA_HALLUCINATION = 72343 , SPELL_HALLUCINATION_2 = 72344 , SPELL_SHADOW_STEP = 72326 , SPELL_DEADLY_POISON = 72329 , SPELL_ENVENOMED_DAGGER_THROW = 72333 , SPELL_KIDNEY_SHOT = 72335 , SPELL_SPECTRAL_STRIKE = 72198 , SPELL_SHIELD_BASH = 72194 , SPELL_TORTURED_ENRAGE = 72203 , SPELL_SHOOT = 72208 , SPELL_CURSED_ARROW = 72222 , SPELL_FROST_TRAP = 72215 , SPELL_ICE_SHOT = 7226@@ 8 } ; enum TrashEvents { EVENT_TRASH_NONE , EVENT_SHADOW_WORD_PAIN , EVENT_CIRCLE_OF_DESTRUCTION , EVENT_COWER_IN_FEAR , EVENT_DARK_MENDING , EVENT_FIREBALL , EVENT_FLAMESTRIKE , EVENT_FROSTBOLT , EVENT_CHAINS_OF_ICE , EVENT_HALLUCINATION , EVENT_SHADOW_STEP , EVENT_DEADLY_POISON , EVENT_ENVENOMED_DAGGER_THROW , EVENT_KIDNEY_SHOT , EVENT_SPECTRAL_STRIKE , EVENT_SHIELD_BASH , EVENT_TORTURED_ENRAGE , EVENT_SHOOT , EVENT_CURSED_ARROW , EVENT_FROST_TRAP , EVENT_ICE_SHOT } ; struct npc_gauntlet_trash : public ScriptedAI { npc_gauntlet_trash ( Creature * creature ) : ScriptedAI ( creature ) , _instance ( creature -> GetInstanceScript ( ) ) , InternalWaveId ( 0 ) { } void Reset ( ) override { me -> CastSpell ( me , SPELL_WELL_@@ OF_SOULS , true ) ; _events . Reset ( ) ; } void EnterEvadeMode ( EvadeReason ) override { if ( _instance -> GetData ( DATA_WAVE_COUNT ) != NOT_STARTED ) _instance -> SetData ( DATA_WAVE_COUNT , NOT_STARTED ) ; } void SetData ( uint32 type , uint32 value ) override { if ( type ) return ; InternalWaveId = value ; } uint32 GetData ( uint32 type ) const override { if ( type ) return 0 ; return InternalWaveId ; } protected : EventMap _events ; InstanceScript * _instance ; uint32 InternalWaveId ; } ; class npc_ghostly_priest : public CreatureScript { public : npc_ghostly_priest ( ) : CreatureScript ( " npc _ ghostly _ priest " ) { } struct npc_ghostly_priestAI : public npc_gauntlet_trash { npc_ghostly_priestAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_SHADOW_WORD_PAIN , 6s , 15s ) ; _events . ScheduleEvent ( EVENT_CIRCLE_OF_DESTRUCTION , 12s ) ; _events . ScheduleEvent ( EVENT_COWER_IN_FEAR , 10s ) ; _events . ScheduleEvent ( EVENT_DARK_MENDING , 20s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_SHADOW_WORD_PAIN : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_SHADOW_WORD_PAIN ) ; _events . ScheduleEvent ( EVENT_SHADOW_WORD_PAIN , 6s , 15s ) ; break ; case EVENT_CIRCLE_OF_DESTRUCTION : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 10.0f , true ) ) DoCast ( target , SPELL_CIRCLE_OF_DESTRUCTION ) ; _events . ScheduleEvent ( EVENT_CIRCLE_OF_DESTRUCTION , 12s ) ; break ; case EVENT_COWER_IN_FEAR : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 20.0f , true ) ) DoCast ( target , SPELL_COWER_IN_FEAR ) ; _events . ScheduleEvent ( EVENT_COWER_IN_FEAR , 10s ) ; break ; case EVENT_DARK_MENDING : if ( Unit * target = DoSelect@@ LowestHpF@@ riendly ( 40 , DUNGEON_@@ MODE ( 30000 , 50000 ) ) ) { DoCast ( target , SPELL_DARK_MENDING ) ; _events . ScheduleEvent ( EVENT_DARK_MENDING , 20s ) ; } else { _events . ScheduleEvent ( EVENT_DARK_MENDING , 5s ) ; } break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_ghostly_priestAI > ( creature ) ; } } ; class npc_phantom_mage : public CreatureScript { public : npc_phantom_mage ( ) : CreatureScript ( " npc _ phantom _ mage " ) { } struct npc_phantom_mageAI : public npc_gauntlet_trash { npc_phantom_mageAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void EnterEvadeMode ( EvadeReason why ) override { if ( ! me -> HasAura ( AURA_HALLUCINATION ) ) npc_gauntlet_trash :: EnterEvadeMode ( why ) ; } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_FIREBALL , 3s ) ; _events . ScheduleEvent ( EVENT_FLAMESTRIKE , 6s ) ; _events . ScheduleEvent ( EVENT_FROSTBOLT , 9s ) ; _events . ScheduleEvent ( EVENT_CHAINS_OF_ICE , 12s ) ; _events . ScheduleEvent ( EVENT_HALLUCINATION , 40s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_FIREBALL : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_FIREBALL ) ; _events . ScheduleEvent ( EVENT_FIREBALL , 15s ) ; break ; case EVENT_FLAMESTRIKE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_FLAMESTRIKE ) ; _events . ScheduleEvent ( EVENT_FLAMESTRIKE , 15s ) ; break ; case EVENT_FROSTBOLT : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_FROSTBOLT ) ; _events . ScheduleEvent ( EVENT_FROSTBOLT , 15s ) ; break ; case EVENT_CHAINS_OF_ICE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM ) ) DoCast ( target , SPELL_CHAINS_OF_ICE ) ; _events . ScheduleEvent ( EVENT_CHAINS_OF_ICE , 15s ) ; break ; case EVENT_HALLUCINATION : me -> RemoveAllAuras ( ) ; DoCast ( me , SPELL_HALLUCINATION ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_phantom_mageAI > ( creature ) ; } } ; class npc_phantom_hallucination : public CreatureScript { public : npc_phantom_hallucination ( ) : CreatureScript ( " npc _ phantom _ hallucination " ) { } struct npc_phantom_hallucinationAI : public npc_phantom_mage :: npc_phantom_mageAI { npc_phantom_hallucinationAI ( Creature * creature ) : npc_phantom_mage :: npc_phantom_mageAI ( creature ) { } void Reset ( ) override { DoZoneInCombat ( me ) ; } void EnterEvadeMode ( EvadeReason why ) override { if ( me -> GetOwner ( ) && ! me -> GetOwner ( ) -> HasAura ( AURA_HALLUCINATION ) ) npc_phantom_mage :: npc_phantom_mageAI :: EnterEvadeMode ( why ) ; } void JustDied ( Unit * ) override { DoCastAOE ( SPELL_HALLUCINATION_2 ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_phantom_hallucinationAI > ( creature ) ; } } ; class npc_shadowy_mercenary : public CreatureScript { public : npc_shadowy_mercenary ( ) : CreatureScript ( " npc _ shadowy _ mercenary " ) { } struct npc_shadowy_mercenaryAI : public npc_gauntlet_trash { npc_shadowy_mercenaryAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_SHADOW_STEP , 23s ) ; _events . ScheduleEvent ( EVENT_DEADLY_POISON , 5s ) ; _events . ScheduleEvent ( EVENT_ENVENOMED_DAGGER_THROW , 10s ) ; _events . ScheduleEvent ( EVENT_KIDNEY_SHOT , 12s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_SHADOW_STEP : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 100.0f , true ) ) DoCast ( target , SPELL_SHADOW_STEP ) ; _events . ScheduleEvent ( EVENT_SHADOW_STEP , 8s ) ; break ; case EVENT_DEADLY_POISON : DoCastVictim ( SPELL_DEADLY_POISON ) ; _events . ScheduleEvent ( EVENT_DEADLY_POISON , 10s ) ; break ; case EVENT_ENVENOMED_DAGGER_THROW : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_ENVENOMED_DAGGER_THROW ) ; _events . ScheduleEvent ( EVENT_ENVENOMED_DAGGER_THROW , 10s ) ; break ; case EVENT_KIDNEY_SHOT : DoCastVictim ( SPELL_KIDNEY_SHOT ) ; _events . ScheduleEvent ( EVENT_KIDNEY_SHOT , 10s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_shadowy_mercenaryAI > ( creature ) ; } } ; class npc_spectral_footman : public CreatureScript { public : npc_spectral_footman ( ) : CreatureScript ( " npc _ spectral _ footman " ) { } struct npc_spectral_footmanAI : public npc_gauntlet_trash { npc_spectral_footmanAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_SPECTRAL_STRIKE , 14s ) ; _events . ScheduleEvent ( EVENT_SHIELD_BASH , 10s ) ; _events . ScheduleEvent ( EVENT_TORTURED_ENRAGE , 15s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_SPECTRAL_STRIKE : DoCastVictim ( SPELL_SPECTRAL_STRIKE ) ; _events . ScheduleEvent ( EVENT_SPECTRAL_STRIKE , 5s ) ; break ; case EVENT_SHIELD_BASH : DoCastVictim ( SPELL_SHIELD_BASH ) ; _events . ScheduleEvent ( EVENT_SHIELD_BASH , 5s ) ; break ; case EVENT_TORTURED_ENRAGE : DoCast ( me , SPELL_TORTURED_ENRAGE ) ; _events . ScheduleEvent ( EVENT_TORTURED_ENRAGE , 15s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_spectral_footmanAI > ( creature ) ; } } ; class npc_tortured_rifleman : public CreatureScript { public : npc_tortured_rifleman ( ) : CreatureScript ( " npc _ tortured _ rifleman " ) { } struct npc_tortured_riflemanAI : public npc_gauntlet_trash { npc_tortured_riflemanAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_SHOOT , 1 ) ; _events . ScheduleEvent ( EVENT_CURSED_ARROW , 7s ) ; _events . ScheduleEvent ( EVENT_FROST_TRAP , 10s ) ; _events . ScheduleEvent ( EVENT_ICE_SHOT , 15s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_SHOOT : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_SHOOT ) ; _events . ScheduleEvent ( EVENT_SHOOT , 2s ) ; break ; case EVENT_CURSED_ARROW : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_CURSED_ARROW ) ; _events . ScheduleEvent ( EVENT_CURSED_ARROW , 10s ) ; break ; case EVENT_FROST_TRAP : DoCast ( me , SPELL_FROST_TRAP ) ; _events . ScheduleEvent ( EVENT_FROST_TRAP , 30s ) ; break ; case EVENT_ICE_SHOT : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_ICE_SHOT ) ; _events . ScheduleEvent ( EVENT_ICE_SHOT , 15s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_tortured_riflemanAI > ( creature ) ; } } ; enum FrostswornGener@@ al { EVENT_SHIELD = 1 , EVENT_SPIKE = 2 , EVENT_CLONE = 3 , SAY_AGGRO = 0 , SAY_DEATH = 1 , SPELL_SHIELD_THROWN = 69222 , SPELL_SPIKE = 69184 , SPELL_CLONE = 69828 , SPELL_GHOST_VISUAL = 69861 , EVENT_BALEFUL_STRIKE = 1 , SPELL_BALEFUL_STRIKE = 6993@@ 3 , SPELL_SPIRIT_BURST = 69900 } ; class npc_frostsworn_general : public CreatureScript { public : npc_frostsworn_general ( ) : CreatureScript ( " npc _ frostsworn _ general " ) { } struct npc_frostsworn_generalAI : public ScriptedAI { npc_frostsworn_generalAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = creature -> GetInstanceScript ( ) ; } void Reset ( ) override { _events . Reset ( ) ; _instance -> SetData ( DATA_FROSTSWORN_GENERAL , NOT_STARTED ) ; } void JustDied ( Unit * ) override { Talk ( SAY_DEATH ) ; _events . Reset ( ) ; _instance -> SetData ( DATA_FROSTSWORN_GENERAL , DONE ) ; } void JustEngagedWith ( Unit * ) override { Talk ( SAY_AGGRO ) ; DoZoneInCombat ( ) ; _events . ScheduleEvent ( EVENT_SHIELD , 5s ) ; _events . ScheduleEvent ( EVENT_SPIKE , 14s ) ; _events . ScheduleEvent ( EVENT_CLONE , 22s ) ; _instance -> SetData ( DATA_FROSTSWORN_GENERAL , IN_PROGRESS ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; while ( uint32 event = _events . ExecuteEvent ( ) ) { switch ( event ) { case EVENT_SHIELD : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 45.0f , true ) ) DoCast ( target , SPELL_SHIELD_THROWN ) ; _events . ScheduleEvent ( EVENT_SHIELD , 8s , 12s ) ; break ; case EVENT_SPIKE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 45.0f , true ) ) DoCast ( target , SPELL_SPIKE ) ; _events . ScheduleEvent ( EVENT_SPIKE , 15s , 20s ) ; break ; case EVENT_CLONE : SummonClones ( ) ; _events . ScheduleEvent ( EVENT_CLONE , 1min ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } void SummonClones ( ) { std :: list < Unit * > playerList ; SelectTargetList ( playerList , 5 , SELECT_TARGET_MAXTHREAT , 0 , 0.0f , true ) ; for ( Unit * target : playerList ) { if ( Creature * reflection = me -> SummonCreature ( NPC_REFLECTION , * target , TEMPSUMMON_TIMED_DESPAWN_@@ OUT_OF_CO@@ MBAT , 3000 ) ) { reflection -> SetImmuneToPC ( false ) ; target -> CastSpell ( reflection , SPELL_CLONE , true ) ; target -> CastSpell ( reflection , SPELL_GHOST_VISUAL , true ) ; reflection -> AI ( ) -> AttackStart ( target ) ; } } } private : InstanceScript * _instance ; EventMap _events ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_frostsworn_generalAI > ( creature ) ; } } ; class npc_spiritual_reflection : public CreatureScript { public : npc_spiritual_reflection ( ) : CreatureScript ( " npc _ spiritual _ reflection " ) { } struct npc_spiritual_reflectionAI : public ScriptedAI { npc_spiritual_reflectionAI ( Creature * creature ) : ScriptedAI ( creature ) { } void Reset ( ) override { _events . Reset ( ) ; } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_BALEFUL_STRIKE , 3s ) ; } void JustDied ( Unit * ) override { DoCastAOE ( SPELL_SPIRIT_BURST ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_BALEFUL_STRIKE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 8.0f , true ) ) DoCast ( target , SPELL_BALEFUL_STRIKE ) ; _events . ScheduleEvent ( EVENT_BALEFUL_STRIKE , 3s , 8s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } private : EventMap _events ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_spiritual_reflectionAI > ( creature ) ; } } ; class at_hor_intro_start : public AreaTriggerScript { public : at_hor_intro_start ( ) : AreaTriggerScript ( " at _ hor _ intro _ start " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetData ( DATA_INTRO_EVENT ) == NOT_STARTED ) _instance -> SetData ( DATA_INTRO_EVENT , IN_PROGRESS ) ; if ( player -> HasAura ( SPELL_QUEL_DELAR@@ _COMPULSION ) && ( player -> GetQuestStatus ( QUEST_HALLS_OF_REFL@@ ECTION_ALLIANCE ) == QUEST_STATUS_INCOMPLETE || player -> GetQuestStatus ( QUEST_HALLS_OF_REFLECTION_@@ HORDE ) == QUEST_STATUS_INCOMPLETE ) && _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) == NOT_STARTED ) { _instance -> SetData ( DATA_QUEL_DELAR_EVENT , IN_PROGRESS ) ; _instance -> SetGuidData ( DATA_QUEL_DELAR_INVOKER , player -> GetGUID ( ) ) ; } return true ; } } ; class at_hor_waves_restarter : public AreaTriggerScript { public : at_hor_waves_restarter ( ) : AreaTriggerScript ( " at _ hor _ waves _ restarter " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetData ( DATA_WAVE_COUNT ) ) return true ; if ( _instance -> GetData ( DATA_INTRO_EVENT ) == DONE && _instance -> GetBossState ( DATA_MARWYN ) != DONE ) { _instance -> ProcessEvent ( 0 , EVENT_SPAWN_WAVES ) ; if ( Creature * falric = ObjectAccessor :: GetCreature ( * player , _instance -> GetGuidData ( DATA_FALRIC ) ) ) { falric -> CastSpell ( falric , SPELL_BOSS_SPAWN_AURA , true ) ; falric -> SetVisible ( true ) ; } if ( Creature * marwyn = ObjectAccessor :: GetCreature ( * player , _instance -> GetGuidData ( DATA_MARWYN ) ) ) { marwyn -> CastSpell ( marwyn , SPELL_BOSS_SPAWN_AURA , true ) ; marwyn -> SetVisible ( true ) ; } } return true ; } } ; class at_hor_impenetrable_door : public AreaTriggerScript { public : at_hor_impenetrable_door ( ) : AreaTriggerScript ( " at _ hor _ impenetrable _ door " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetBossState ( DATA_MARWYN ) == DONE ) return true ; return false ; } } ; class at_hor_shadow_throne : public AreaTriggerScript { public : at_hor_shadow_throne ( ) : AreaTriggerScript ( " at _ hor _ shadow _ throne " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetBossState ( DATA_THE_LICH_KING_ESCAPE ) == NOT_STARTED ) _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , IN_PROGRESS ) ; return true ; } } ; enum EscapeEvents { EVENT_RAGING_GHOUL_JUMP = 1 , EVENT_RISEN_WITCH_DOCTOR_CURSE , EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT , EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY , EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY , EVENT_LUMBERING_ABOMINATION_CLEAVE } ; class HoRStartMovementEvent : public BasicEvent { public : explicit HoRStartMovementEvent ( Creature * owner ) : _owner ( owner ) { } bool Execute ( uint64 , uint32 ) override { _owner -> SetReactState ( REACT_AGGRESSIVE ) ; if ( Unit * target = _owner -> AI ( ) -> SelectTarget ( SELECT_TARGET_RANDOM , 0 , 0.0f , true ) ) _owner -> AI ( ) -> AttackStart ( target ) ; return true ; } private : Creature * _owner ; } ; struct npc_escape_event_trash : public ScriptedAI { npc_escape_event_trash ( Creature * creature ) : ScriptedAI ( creature ) , _instance ( creature -> GetInstanceScript ( ) ) { } void Reset ( ) override { _events . Reset ( ) ; } void UpdateAI ( uint32 ) override { if ( _instance -> GetBossState ( DATA_THE_LICH_KING_ESCAPE ) == FAIL || _instance -> GetBossState ( DATA_THE_LICH_KING_ESCAPE ) == NOT_STARTED ) me -> DespawnOrUnsummon ( ) ; } void IsSummonedBy ( WorldObject * ) override { DoZoneInCombat ( me ) ; if ( Creature * leader = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ESCAPE_LEADER ) ) ) { me -> SetImmuneToPC ( false ) ; me -> SetInCombatWith ( leader ) ; leader -> SetInCombatWith ( me ) ; AddThreat ( leader , 0.0f ) ; } } protected : EventMap _events ; InstanceScript * _instance ; } ; class npc_raging_ghoul : public CreatureScript { public : npc_raging_ghoul ( ) : CreatureScript ( " npc _ raging _ ghoul " ) { } struct npc_raging_ghoulAI : public npc_escape_event_trash { npc_raging_ghoulAI ( Creature * creature ) : npc_escape_event_trash ( creature ) { } void Reset ( ) override { npc_escape_event_trash :: Reset ( ) ; _events . ScheduleEvent ( EVENT_RAGING_GHOUL_JUMP , 5s ) ; } void IsSummonedBy ( WorldObject * summoner ) override { me -> CastSpell ( me , SPELL_RAGING_GHOUL_SPAWN , true ) ; me -> SetReactState ( REACT_PASSIVE ) ; me -> HandleEmoteCommand ( EMOTE_ONESHOT_EMERGE ) ; me -> m_Events . AddEvent ( new HoRStartMovementEvent ( me ) , me -> m_Events . CalculateTime ( 5000 ) ) ; npc_escape_event_trash :: IsSummonedBy ( summoner ) ; } void UpdateAI ( uint32 diff ) override { npc_escape_event_trash :: UpdateAI ( diff ) ; if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_RAGING_GHOUL_JUMP : if ( Unit * victim = me -> GetVictim ( ) ) { if ( me -> IsInRange ( victim , 5.0f , 30.0f ) ) { DoCast ( victim , SPELL_GHOUL_JUMP ) ; return ; } } _events . ScheduleEvent ( EVENT_RAGING_GHOUL_JUMP , 500ms ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_raging_ghoulAI > ( creature ) ; } } ; class npc_risen_witch_doctor : public CreatureScript { public : npc_risen_witch_doctor ( ) : CreatureScript ( " npc _ risen _ witch _ doctor " ) { } struct npc_risen_witch_doctorAI : public npc_escape_event_trash { npc_risen_witch_doctorAI ( Creature * creature ) : npc_escape_event_trash ( creature ) { } void Reset ( ) override { npc_escape_event_trash :: Reset ( ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT , 6s ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY , 15s ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_CURSE , 7s ) ; } void IsSummonedBy ( WorldObject * summoner ) override { me -> CastSpell ( me , SPELL_RISEN_WITCH_DOCTOR_SPAWN , true ) ; me -> SetReactState ( REACT_PASSIVE ) ; me -> HandleEmoteCommand ( EMOTE_ONESHOT_EMERGE ) ; me -> m_Events . AddEvent ( new HoRStartMovementEvent ( me ) , me -> m_Events . CalculateTime ( 5000 ) ) ; npc_escape_event_trash :: IsSummonedBy ( summoner ) ; } void UpdateAI ( uint32 diff ) override { npc_escape_event_trash :: UpdateAI ( diff ) ; if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_RISEN_WITCH_DOCTOR_CURSE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 30.0f , true ) ) DoCast ( target , SPELL_CURSE_OF_DOOM ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_CURSE , 10s , 15s ) ; break ; case EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT : if ( Unit * target = SelectTarget ( SELECT_TARGET_MAXTHREAT , 0 , 20.0f , true ) ) DoCast ( target , SPELL_SHADOW_BOLT ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT , 2s , 3s ) ; break ; case EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY : if ( SelectTarget ( SELECT_TARGET_RANDOM , 0 , 30.0f , true ) ) DoCastAOE ( SPELL_SHADOW_BOLT_VOLLEY ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY , 15s , 22s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_risen_witch_doctorAI > ( creature ) ; } } ; class npc_lumbering_abomination : public CreatureScript { public : npc_lumbering_abomination ( ) : CreatureScript ( " npc _ lumbering _ abomination " ) { } struct npc_lumbering_abominationAI : public npc_escape_event_trash { npc_lumbering_abominationAI ( Creature * creature ) : npc_escape_event_trash ( creature ) { } void Reset ( ) override { npc_escape_event_trash :: Reset ( ) ; _events . ScheduleEvent ( EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY , 15s ) ; _events . ScheduleEvent ( EVENT_LUMBERING_ABOMINATION_CLEAVE , 6s ) ; } void UpdateAI ( uint32 diff ) override { npc_escape_event_trash :: UpdateAI ( diff ) ; if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY : DoCastVictim ( SPELL_VOMIT_SPRAY ) ; _events . ScheduleEvent ( EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY , 15s , 20s ) ; break ; case EVENT_LUMBERING_ABOMINATION_CLEAVE : DoCastVictim ( SPELL_CLEAVE ) ; _events . ScheduleEvent ( EVENT_LUMBERING_ABOMINATION_CLEAVE , 7s , 9s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_lumbering_abominationAI > ( creature ) ; } } ; enum QuelDelarUther { ACTION_UTHER_START_SCREAM = 1 , ACTION_UTHER_OUTRO = 2 , EVENT_UTHER_1 = 1 , EVENT_UTHER_2 = 2 , EVENT_UTHER_3 = 3 , EVENT_UTHER_4 = 4 , EVENT_UTHER_5 = 5 , EVENT_UTHER_6 = 6 , EVENT_UTHER_7 = 7 , EVENT_UTHER_8 = 8 , EVENT_UTHER_9 = 9 , EVENT_UTHER_10 = 10 , EVENT_UTHER_11 = 11 , EVENT_UTHER_FACING = 12 , EVENT_UTHER_KNEEL = 13 , SAY_UTHER_QUEL_DELAR_1 = 16 , SAY_UTHER_QUEL_DELAR_2 = 17 , SAY_UTHER_QUEL_DELAR_3 = 18 , SAY_UTHER_QUEL_DELAR_4 = 19 , SAY_UTHER_QUEL_DELAR_5 = 20 , SAY_UTHER_QUEL_DELAR_6 = 21 , SPELL_ESSENCE_OF_CAPTURED_1 = 73036 } ; enum QuelDelarSword { SPELL_WHIRLWIND_VISUAL = 70300 , SPELL_HEROIC_STRIKE = 29426 , SPELL_WHIRLWIND = 67716 , SPELL_BLADESTORM = 67541 , NPC_QUEL_DELAR = 37158 , POINT_TAKE_OFF = 1 , EVENT_QUEL_DELAR_INIT = 1 , EVENT_QUEL_DELAR_FLIGHT_INIT = 2 , EVENT_QUEL_DELAR_FLIGHT = 3 , EVENT_QUEL_DELAR_LAND = 4 , EVENT_QUEL_DELAR_FIGHT = 5 , EVENT_QUEL_DELAR_BLADESTORM = 6 , EVENT_QUEL_DELAR_HEROIC_STRIKE = 7 , EVENT_QUEL_DELAR_WHIRLWIND = 8 , SAY_QUEL_DELAR_SWORD = 0 } ; enum QuelDelarMisc { SAY_FROSTMOURNE_BUNNY = 0 , SPELL_QUEL_DELAR_WILL = 70698 } ; Position const QuelDelarCenterPos = { 5309.259f , 2006.@@ 390f , 718.046f , 0.0f } ; Position const QuelDelarSummonPos = { 5298.@@ 473f , 1994@@ .852f , 709.424@@ f , 3.97935@@ 1f } ; Position const QuelDelarMovement [ ] = { { 5292.8@@ 70f , 1998.950f , 718.046f , 0.0f } , { 5295.819f , 1991.912f , 707.707f , 0.0f } , { 5295.301f , 1989.782f , 708.@@ 696f , 0.0f } } ; Position const UtherQuelDelarMovement [ ] = { { 5336.83@@ 0f , 1981.700@@ f , 709.319f , 0.0f } , { 5314.35@@ 0f , 1993.440f , 707.726f , 0.0f } } ; class npc_uther_quel_delar : public CreatureScript { public : npc_uther_quel_delar ( ) : CreatureScript ( " npc _ uther _ quel _ delar " ) { } struct npc_uther_quel_delarAI : public ScriptedAI { npc_uther_quel_delarAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; } void Reset ( ) override { if ( _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) != IN_PROGRESS && _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) != SPECIAL ) return ; _events . Reset ( ) ; _events . ScheduleEvent ( EVENT_UTHER_1 , 1 ) ; } void DamageTaken ( Unit * , uint32 & damage ) override { if ( damage >= me -> GetHealth ( ) ) damage = me -> GetHealth ( ) - 1 ; } void DoAction ( int32 action ) override { switch ( action ) { case ACTION_UTHER_START_SCREAM : _instance -> SetData ( DATA_QUEL_DELAR_EVENT , SPECIAL ) ; _events . ScheduleEvent ( EVENT_UTHER_2 , 0 ) ; break ; case ACTION_UTHER_OUTRO : _events . ScheduleEvent ( EVENT_UTHER_6 , 0 ) ; break ; default : break ; } } void MovementInform ( uint32 , uint32 pointId ) override { switch ( pointId ) { case 1 : _events . ScheduleEvent ( EVENT_UTHER_FACING , 1s ) ; break ; default : break ; } } void UpdateAI ( uint32 diff ) override { if ( _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) != IN_PROGRESS && _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) != SPECIAL ) return ; _events . Update ( diff ) ; while ( uint32 eventId = _events . ExecuteEvent ( ) ) { switch ( eventId ) { case EVENT_UTHER_1 : Talk ( SAY_UTHER_QUEL_DELAR_1 ) ; break ; case EVENT_UTHER_2 : if ( Creature * bunny = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FROSTMOURNE_ALTAR_BUNNY ) ) ) if ( Unit * target = ObjectAccessor :: GetPlayer ( * me , _instance -> GetGuidData ( DATA_QUEL_DELAR_INVOKER ) ) ) bunny -> CastSpell ( target , SPELL_QUEL_DELAR_WILL , true ) ; _events . ScheduleEvent ( EVENT_UTHER_3 , 2000 ) ; break ; case EVENT_UTHER_3 : me -> SummonCreature ( NPC_QUEL_DELAR , QuelDelarSummonPos ) ; _events . ScheduleEvent ( EVENT_UTHER_4 , 2000 ) ; break ; case EVENT_UTHER_4 : Talk ( SAY_UTHER_QUEL_DELAR_2 ) ; _events . ScheduleEvent ( EVENT_UTHER_5 , 8000 ) ; break ; case EVENT_UTHER_5 : me -> GetMotionMaster ( ) -> MovePoint ( 1 , UtherQuelDelarMovement [ 0 ] ) ; break ; case EVENT_UTHER_6 : me -> SetWalk ( true ) ; me -> GetMotionMaster ( ) -> MovePoint ( 0 , UtherQuelDelarMovement [ 1 ] ) ; _events . ScheduleEvent ( EVENT_UTHER_7 , 5000 ) ; break ; case EVENT_UTHER_7 : Talk ( SAY_UTHER_QUEL_DELAR_3 ) ; _events . ScheduleEvent ( EVENT_UTHER_8 , 12000 ) ; break ; case EVENT_UTHER_8 : Talk ( SAY_UTHER_QUEL_DELAR_4 ) ; _events . ScheduleEvent ( EVENT_UTHER_9 , 7000 ) ; break ; case EVENT_UTHER_9 : Talk ( SAY_UTHER_QUEL_DELAR_5 ) ; _events . ScheduleEvent ( EVENT_UTHER_10 , 10000 ) ; break ; case EVENT_UTHER_10 : Talk ( SAY_UTHER_QUEL_DELAR_6 ) ; _events . ScheduleEvent ( EVENT_UTHER_11 , 5000 ) ; break ; case EVENT_UTHER_11 : DoCast ( me , SPELL_ESSENCE_OF_CAPTURED_1 , true ) ; me -> DespawnOrUnsummon ( 3000 ) ; _instance -> SetData ( DATA_QUEL_DELAR_EVENT , DONE ) ; break ; case EVENT_UTHER_FACING : if ( Creature * bunny = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FROSTMOURNE_ALTAR_BUNNY ) ) ) me -> SetFacingToObject ( bunny ) ; _events . ScheduleEvent ( EVENT_UTHER_KNEEL , 1s ) ; break ; case EVENT_UTHER_KNEEL : me -> HandleEmoteCommand ( EMOTE_STATE_KNEEL ) ; break ; default : break ; } } } private : EventMap _events ; InstanceScript * _instance ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_uther_quel_delarAI > ( creature ) ; } } ; class npc_quel_delar_sword : public CreatureScript { public : npc_quel_delar_sword ( ) : CreatureScript ( " npc _ quel _ delar _ sword " ) { } struct npc_quel_delar_swordAI : public ScriptedAI { npc_quel_delar_swordAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; me -> SetDisplayId ( me -> GetCreatureTemplate ( ) -> Modelid2 ) ; _intro = true ; } void Reset ( ) override { _events . Reset ( ) ; me -> SetSpeedRate ( MOVE_FLI@@ GHT , 4.5f ) ; DoCast ( SPELL_WHIRLWIND_VISUAL ) ; if ( _intro ) _events . ScheduleEvent ( EVENT_QUEL_DELAR_INIT , 0 ) ; else me -> SetImmuneToAll ( false ) ; } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_QUEL_DELAR_HEROIC_STRIKE , 4s ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_BLADESTORM , 6s ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_WHIRLWIND , 6s ) ; } void JustDied ( Unit * ) override { if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_UTHER_QUEL_DELAR ) ) ) uther -> AI ( ) -> DoAction ( ACTION_UTHER_OUTRO ) ; } void MovementInform ( uint32 type , uint32 pointId ) override { if ( type != EFFECT_MOTION_TYPE ) return ; switch ( pointId ) { case POINT_TAKE_OFF : _events . ScheduleEvent ( EVENT_QUEL_DELAR_FLIGHT , 0 ) ; break ; default : break ; } } void UpdateAI ( uint32 diff ) override { _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; if ( ! UpdateVictim ( ) ) { while ( uint32 eventId = _events . ExecuteEvent ( ) ) { switch ( eventId ) { case EVENT_QUEL_DELAR_INIT : if ( Creature * bunny = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FROSTMOURNE_ALTAR_BUNNY ) ) ) bunny -> AI ( ) -> Talk ( SAY_FROSTMOURNE_BUNNY ) ; _intro = false ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_FLIGHT_INIT , 2500ms ) ; break ; case EVENT_QUEL_DELAR_FLIGHT_INIT : me -> GetMotionMaster ( ) -> MoveTake@@ off ( POINT_TAKE_OFF , QuelDelarMovement [ 0 ] ) ; break ; case EVENT_QUEL_DELAR_FLIGHT : { me -> GetMotionMaster ( ) -> MoveCir@@ clePath ( QuelDelarCenterPos . GetPositionX ( ) , QuelDelarCenterPos . GetPositionY ( ) , 718.046f , 18.0f , true , 16 ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_LAND , 15s ) ; break ; } case EVENT_QUEL_DELAR_LAND : me -> StopMoving ( ) ; me -> GetMotionMaster ( ) -> Clear ( ) ; me -> GetMotionMaster ( ) -> MoveLand ( 0 , QuelDelarMovement [ 1 ] ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_FIGHT , 6s ) ; break ; case EVENT_QUEL_DELAR_FIGHT : Talk ( SAY_QUEL_DELAR_SWORD ) ; me -> GetMotionMaster ( ) -> MovePoint ( 0 , QuelDelarMovement [ 2 ] ) ; me -> SetImmuneToAll ( false ) ; break ; default : break ; } } } else { while ( uint32 eventId = _events . ExecuteEvent ( ) ) { switch ( eventId ) { case EVENT_QUEL_DELAR_BLADESTORM : DoCast ( me , SPELL_BLADESTORM ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_BLADESTORM , 10s ) ; break ; case EVENT_QUEL_DELAR_HEROIC_STRIKE : DoCastVictim ( SPELL_HEROIC_STRIKE ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_HEROIC_STRIKE , 6s ) ; break ; case EVENT_QUEL_DELAR_WHIRLWIND : DoCastAOE ( SPELL_WHIRLWIND ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_WHIRLWIND , 1s ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } } private : EventMap _events ; InstanceScript * _instance ; bool _intro ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_quel_delar_swordAI > ( creature ) ; } } ; class at_hor_uther_quel_delar_start : public AreaTriggerScript { public : at_hor_uther_quel_delar_start ( ) : AreaTriggerScript ( " at _ hor _ uther _ quel _ delar _ start " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) == IN_PROGRESS ) if ( Creature * uther = ObjectAccessor :: GetCreature ( * player , _instance -> GetGuidData ( DATA_UTHER_QUEL_DELAR ) ) ) uther -> AI ( ) -> DoAction ( ACTION_UTHER_START_SCREAM ) ; return true ; } } ; class spell_hor_start_halls_of_reflection_quest_ae : public SpellScriptLoader { public : spell_hor_start_halls_of_reflection_quest_ae ( ) : SpellScriptLoader ( " spell _ hor _ start _ halls _ of _ reflection _ quest _ ae " ) { } class spell_hor_start_halls_of_reflection_quest_ae_SpellScript : public SpellScript { PrepareSpellScript ( spell_hor_start_halls_of_reflection_quest_ae_SpellScript ) ; void StartQuests ( SpellEffIndex ) { if ( Player * target = GetHitPlayer ( ) ) { if ( target -> GetTeam ( ) == ALLIANCE ) target -> CastSpell ( target , SPELL_START_HALLS_OF_REFLECTION_QUEST_A , true ) ; else target -> CastSpell ( target , SPELL_START_HALLS_OF_REFLECTION_QUEST_H , true ) ; } } void Register ( ) override { OnEffectHitTarget += SpellEffectFn ( spell_hor_start_halls_of_reflection_quest_ae_SpellScript :: StartQuests , EFFECT_0 , SPELL_EFFECT_SCRIPT_EFFECT ) ; } } ; SpellScript * GetSpellScript ( ) const override { return new spell_hor_start_halls_of_reflection_quest_ae_SpellScript ( ) ; } } ; class spell_hor_evasion : public SpellScriptLoader { public : spell_hor_evasion ( ) : SpellScriptLoader ( " spell _ hor _ evasion " ) { } class spell_hor_evasion_SpellScript : public SpellScript { PrepareSpellScript ( spell_hor_evasion_SpellScript ) ; bool Load ( ) override { return GetCaster ( ) -> GetTypeId ( ) == TYPEID_UNIT ; } void SetDest ( SpellDestination & dest ) { WorldObject * target = GetExplTargetWorldObject ( ) ; Position pos ( * target ) ; Position home = GetCaster ( ) -> ToCreature ( ) -> GetHome@@ Position ( ) ; if ( pos . IsInDist2d ( & home , 15.0f ) ) return ; float angle = pos . GetAbsoluteAngle ( & home ) ; float dist = GetSpellInfo ( ) -> Effects [ EFFECT_0 ] . CalcRadius ( GetCaster ( ) ) ; target -> MovePosition ( pos , dist , angle ) ; dest . Relocate ( pos ) ; } void Register ( ) override { OnDestinationTarget@@ Select += SpellDestinationTarget@@ SelectFn ( spell_hor_evasion_SpellScript :: SetDest , EFFECT_0 , TARGET_DEST_@@ TARGET_RAD@@ IUS ) ; } } ; SpellScript * GetSpellScript ( ) const override { return new spell_hor_evasion_SpellScript ( ) ; } } ; class spell_hor_gunship_cannon_fire : public SpellScriptLoader { public : spell_hor_gunship_cannon_fire ( ) : SpellScriptLoader ( " spell _ hor _ gunship _ cannon _ fire " ) { } class spell_hor_gunship_cannon_fire_AuraScript : public AuraScript { PrepareAuraScript ( spell_hor_gunship_cannon_fire_AuraScript ) ; void HandlePeriodic ( AuraEffect const * ) { if ( ! urand ( 0 , 2 ) ) { if ( GetTarget ( ) -> GetEntry ( ) == NPC_GUNSHIP_CANN@@ ON_HORDE ) GetTarget ( ) -> CastSpell ( nullptr , SPELL_GUNSHIP_CANNON_FIRE_MISSILE_HORDE , true ) ; else GetTarget ( ) -> CastSpell ( nullptr , SPELL_GUNSHIP_CANNON_FIRE_MISSILE_ALLIANCE , true ) ; } } void Register ( ) override { OnEffectPeriodic += AuraEffectPeriodicFn ( spell_hor_gunship_cannon_fire_AuraScript :: HandlePeriodic , EFFECT_0 , SPELL_AURA_PERIODIC_TRIGGER_SPELL ) ; } } ; AuraScript * GetAuraScript ( ) const override { return new spell_hor_gunship_cannon_fire_AuraScript ( ) ; } } ; class spell_hor_quel_delars_will : public SpellScript { PrepareSpellScript ( spell_hor_quel_delars_will ) ; bool Validate ( SpellInfo const * spellInfo ) override { return ValidateSpellInfo ( { spellInfo -> Effects [ EFFECT_0 ] . TriggerSpell } ) ; } void HandleReagent ( SpellEffIndex effIndex ) { PreventHitDefaultEffect ( effIndex ) ; GetHitUnit ( ) -> CastSpell ( GetCaster ( ) , GetSpellInfo ( ) -> Effects [ effIndex ] . TriggerSpell , TriggerCastFlags ( TRIGGERED_FULL_@@ MASK & ~ TRIGGERED_IGNORE_@@ POWER_AND_REAGENT_@@ COST ) ) ; } void Register ( ) override { OnEffectHitTarget += SpellEffectFn ( spell_hor_quel_delars_will :: HandleReagent , EFFECT_0 , SPELL_EFFECT_FORCE_CAST ) ; } } ; void AddSC_halls_of_reflection ( ) { new at_hor_intro_start ( ) ; new at_hor_waves_restarter ( ) ; new at_hor_impenetrable_door ( ) ; new at_hor_shadow_throne ( ) ; new at_hor_uther_quel_delar_start ( ) ; new npc_jaina_or_sylvanas_intro_hor ( ) ; new npc_jaina_or_sylvanas_escape_hor ( ) ; new npc_the_lich_king_escape_hor ( ) ; new npc_ghostly_priest ( ) ; new npc_phantom_mage ( ) ; new npc_phantom_hallucination ( ) ; new npc_shadowy_mercenary ( ) ; new npc_spectral_footman ( ) ; new npc_tortured_rifleman ( ) ; new npc_frostsworn_general ( ) ; new npc_spiritual_reflection ( ) ; new npc_raging_ghoul ( ) ; new npc_risen_witch_doctor ( ) ; new npc_lumbering_abomination ( ) ; new npc_uther_quel_delar ( ) ; new npc_quel_delar_sword ( ) ; new spell_hor_start_halls_of_reflection_quest_ae ( ) ; new spell_hor_evasion ( ) ; new spell_hor_gunship_cannon_fire ( ) ; RegisterSpellScript ( spell_hor_quel_delars_will ) ; } </DOCUMENT>
<DOCUMENT_ID="esqu@@ do/cymrucoin/tree/master/src/qt@@ /aboutdialog.cpp"> # include " aboutdialog . h " # include " ui _ aboutdialog . h " # include " clientmodel . h " # include " clientversion . h " const int ABOUTDIALOG_COPYRIGHT_YEAR = 2014 ; AboutDialog :: AboutDialog ( QWidget * parent ) : QDialog ( parent ) , ui ( new Ui :: AboutDialog ) { ui -> setupUi ( this ) ; ui -> copyright@@ Label -> setText ( tr ( " Copyright " ) + QString ( " ▁ & copy ; ▁ 2009 - % 1 ▁ " ) . arg ( COPYRIGHT_YEAR ) + tr ( " The ▁ Bitcoin ▁ developers " ) + QString ( " < br > " ) + tr ( " Copyright " ) + QString ( " ▁ & copy ; ▁ " ) + tr ( " % 1 ▁ StartJOIN " ) . arg ( ABOUTDIALOG_COPYRIGHT_YEAR ) ) ; } void AboutDialog :: setModel ( ClientModel * model ) { if ( model ) { ui -> versionLabel -> setText ( model -> formatFull@@ Version ( ) ) ; } } AboutDialog :: ~ AboutDialog ( ) { delete ui ; } void AboutDialog :: on_buttonBox_@@ accepted ( ) { close ( ) ; } </DOCUMENT>
<DOCUMENT_ID="Sh@@ utok/OregonCustom@@ /tree/master/dep/g@@ 3dlite/source/@@ Color3.cpp"> # include " G3D / platform . h " # include < stdlib . h > # include " G3D / Color3 . h " # include " G3D / Vector3 . h " # include " G3D / format . h " # include " G3D / BinaryInput . h " # include " G3D / BinaryOutput . h " # include " G3D / Color3uint8 . h " # include " G3D / Any . h " # include " G3D / stringutils . h " namespace G3D { Color3 :: Color3 ( const Any & any ) { * this = Color3 :: zero ( ) ; any . verifyName ( " Color3" ) ; std :: string name = toLower ( any . name ( ) ) ; switch ( any . type ( ) ) { case Any :: TABLE : for ( Any :: AnyTable :: Iterator it = any . table ( ) . begin ( ) ; it . hasMore ( ) ; ++ it ) { const std :: string & key = toLower ( it -> key ) ; if ( key == " r " ) { r = it -> value ; } else if ( key == " g " ) { g = it -> value ; } else if ( key == " b " ) { b = it -> value ; } else { any . verify ( false , " Illegal ▁ key : ▁ " + it -> key ) ; } } break ; case Any :: ARRAY : if ( name == " color3" ) { any . verifySize ( 3 ) ; r = any [ 0 ] ; g = any [ 1 ] ; b = any [ 2 ] ; } else if ( name == " color3 : : one " ) { any . verifySize ( 0 ) ; * this = one ( ) ; } else if ( name == " color3 : : zero " ) { any . verifySize ( 0 ) ; * this = zero ( ) ; } else if ( name == " color3 : : fromargb " ) { * this = Color3 :: fromARGB ( ( int ) any [ 0 ] . number ( ) ) ; } else { any . verify ( false , " Expected ▁ Color3 ▁ constructor " ) ; } break ; default : any . verify ( false , " Bad ▁ Color3 ▁ constructor " ) ; } } Color3 :: operator Any ( ) const { Any a ( Any :: ARRAY , " Color3" ) ; a . append ( r , g , b ) ; return a ; } Color3 Color3 :: ansiMap ( uint32 i ) { static const Color3 map [ ] = { Color3 :: black ( ) , Color3 :: red ( ) * 0.75f , Color3 :: green ( ) * 0.75f , Color3 :: yellow ( ) * 0.75f , Color3 :: blue ( ) * 0.75f , Color3 :: purple ( ) * 0.75f , Color3 :: cyan ( ) * 0.75f , Color3 :: white ( ) * 0.75f , Color3 :: white ( ) * 0.90f , Color3 :: red ( ) , Color3 :: green ( ) , Color3 :: yellow ( ) , Color3 :: blue ( ) , Color3 :: purple ( ) , Color3 :: cyan ( ) , Color3 :: white ( ) } ; return map [ i & 15 ] ; } Color3 Color3 :: pastelMap ( uint32 i ) { uint32 x = Crypto :: crc32 ( & i , sizeof ( uint32 ) ) ; Vector3 v ( ( ( x >> 22 ) & 1023 ) / 1023@@ .0f , ( ( ( x >> 11 ) & 2047 ) / 2047.0f ) * 0.5f + 0.25f , ( ( x & 2047 ) / 2047.0f ) * 0.75f + 0.25f ) ; return Color3 :: fromHSV ( v ) ; } const Color3 & Color3 :: red ( ) { static Color3 c ( 1.0f , 0.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: green ( ) { static Color3 c ( 0.0f , 1.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: blue ( ) { static Color3 c ( 0.0f , 0.0f , 1.0f ) ; return c ; } const Color3 & Color3 :: purple ( ) { static Color3 c ( 0.7f , 0.0f , 1.0f ) ; return c ; } const Color3 & Color3 :: cyan ( ) { static Color3 c ( 0.0f , 0.7f , 1.0f ) ; return c ; } const Color3 & Color3 :: yellow ( ) { static Color3 c ( 1.0f , 1.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: brown ( ) { static Color3 c ( 0.5f , 0.5f , 0.0f ) ; return c ; } const Color3 & Color3 :: orange ( ) { static Color3 c ( 1.0f , 0.5f , 0.0f ) ; return c ; } const Color3 & Color3 :: black ( ) { static Color3 c ( 0.0f , 0.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: zero ( ) { static Color3 c ( 0.0f , 0.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: one ( ) { static Color3 c ( 1.0f , 1.0f , 1.0f ) ; return c ; } const Color3 & Color3 :: gray ( ) { static Color3 c ( 0.7f , 0.7f , 0.7f ) ; return c ; } const Color3 & Color3 :: white ( ) { static Color3 c ( 1 , 1 , 1 ) ; return c ; } bool Color3 :: isFinite ( ) const { return G3D :: isFinite ( r ) && G3D :: isFinite ( g ) && G3D :: isFinite ( b ) ; } Color3 :: Color3 ( BinaryInput & bi ) { deserialize ( bi ) ; } void Color3 :: deserialize ( BinaryInput & bi ) { r = bi . readFloat32 ( ) ; g = bi . readFloat32 ( ) ; b = bi . readFloat32 ( ) ; } void Color3 :: serialize ( BinaryOutput & bo ) const { bo . writeFloat32 ( r ) ; bo . writeFloat32 ( g ) ; bo . writeFloat32 ( b ) ; } const Color3 & Color3 :: wheelRandom ( ) { static const Color3 colorArray [ 8 ] = { Color3 :: blue ( ) , Color3 :: red ( ) , Color3 :: green ( ) , Color3 :: orange ( ) , Color3 :: yellow ( ) , Color3 :: cyan ( ) , Color3 :: purple ( ) , Color3 :: brown ( ) } ; return colorArray [ iRandom ( 0 , 7 ) ] ; } size_t Color3 :: hashCode ( ) const { unsigned int rhash = ( * ( int * ) ( void * ) ( & r ) ) ; unsigned int ghash = ( * ( int * ) ( void * ) ( & g ) ) ; unsigned int bhash = ( * ( int * ) ( void * ) ( & b ) ) ; return rhash + ( ghash * 37 ) + ( bhash * 101 ) ; } Color3 :: Color3 ( const Vector3 & v ) { r = v . x ; g = v . y ; b = v . z ; } Color3 :: Color3 ( const class Color3uint8 & other ) { r = other . r / 255.0f ; g = other . g / 255.0f ; b = other . b / 255.0f ; } Color3 Color3 :: fromARGB ( uint32 x ) { return Color3 ( ( float ) ( ( x >> 16 ) & 0xFF ) , ( float ) ( ( x >> 8 ) & 0xFF ) , ( float ) ( x & 0xFF ) ) / 255.0f ; } Color3 Color3 :: random ( ) { return Color3 ( uniformRandom ( ) , uniformRandom ( ) , uniformRandom ( ) ) . direction ( ) ; } Color3 & Color3 :: operator /= ( float fScalar ) { if ( fScalar != 0.0f ) { float fInvScalar = 1.0f / fScalar ; r *= fInvScalar ; g *= fInvScalar ; b *= fInvScalar ; } else { r = ( float ) G3D :: finf ( ) ; g = ( float ) G3D :: finf ( ) ; b = ( float ) G3D :: finf ( ) ; } return * this ; } float Color3 :: unitize ( float fTolerance ) { float fLength = length ( ) ; if ( fLength > fTolerance ) { float fInvLength = 1.0f / fLength ; r *= fInvLength ; g *= fInvLength ; b *= fInvLength ; } else { fLength = 0.0f ; } return fLength ; } Color3 Color3 :: fromHSV ( const Vector3 & _hsv ) { debugAssertM ( ( _hsv . x <= 1.0f && _hsv . x >= 0.0f ) && ( _hsv . y <= 1.0f && _hsv . y >= 0.0f ) && ( _hsv . z <= 1.0f && _hsv . z >= 0.0f ) , " H , S , V ▁ must ▁ be ▁ between ▁ [ 0,1 ] " ) ; const int i = iMin ( 5 , G3D :: iFloor ( 6.0 * _hsv . x ) ) ; const float f = 6.0f * _hsv . x - i ; const float m = _hsv . z * ( 1.0f - ( _hsv . y ) ) ; const float n = _hsv . z * ( 1.0f - ( _hsv . y * f ) ) ; const float k = _hsv . z * ( 1.0f - ( _hsv . y * ( 1 - f ) ) ) ; switch ( i ) { case 0 : return Color3 ( _hsv . z , k , m ) ; case 1 : return Color3 ( n , _hsv . z , m ) ; case 2 : return Color3 ( m , _hsv . z , k ) ; case 3 : return Color3 ( m , n , _hsv . z ) ; case 4 : return Color3 ( k , m , _hsv . z ) ; case 5 : return Color3 ( _hsv . z , m , n ) ; default : debugAssertM ( false , " fell ▁ through ▁ switch . . " ) ; } return Color3 :: black ( ) ; } Vector3 Color3 :: toHSV ( const Color3 & _rgb ) { debugAssertM ( ( _rgb . r <= 1.0f && _rgb . r >= 0.0f ) && ( _rgb . g <= 1.0f && _rgb . g >= 0.0f ) && ( _rgb . b <= 1.0f && _rgb . b >= 0.0f ) , " R , G , B ▁ must ▁ be ▁ between ▁ [ 0,1 ] " ) ; Vector3 hsv = Vector3 :: zero ( ) ; hsv . z = G3D :: max ( G3D :: max ( _rgb . r , _rgb . g ) , _rgb . b ) ; if ( G3D :: fuzzyEq ( hsv . z , 0.0f ) ) { return hsv ; } const float x = G3D :: min ( G3D :: min ( _rgb . r , _rgb . g ) , _rgb . b ) ; hsv . y = ( hsv . z - x ) / hsv . z ; if ( G3D :: fuzzyEq ( hsv . y , 0.0f ) ) { return hsv ; } Vector3 rgbN ; rgbN . x = ( hsv . z - _rgb . r ) / ( hsv . z - x ) ; rgbN . y = ( hsv . z - _rgb . g ) / ( hsv . z - x ) ; rgbN . z = ( hsv . z - _rgb . b ) / ( hsv . z - x ) ; if ( _rgb . r == hsv . z ) { hsv . x = ( _rgb . g == x ) ? 5.0f + rgbN . z : 1.0f - rgbN . y ; } else if ( _rgb . g == hsv . z ) { hsv . x = ( _rgb . b == x ) ? 1.0f + rgbN . x : 3.0f - rgbN . z ; } else { hsv . x = ( _rgb . r == x ) ? 3.0f + rgbN . y : 5.0f - rgbN . x ; } hsv . x /= 6.0f ; return hsv ; } Color3 Color3 :: jetColorMap ( const float & val ) { debugAssertM ( val <= 1.0f && val >= 0.0f , " value ▁ should ▁ be ▁ in ▁ [ 0,1 ] " ) ; Color3 jet ; jet . r = G3D :: min ( 4.0f * val - 1.5f , - 4.0f * val + 4.5f ) ; jet . g = G3D :: min ( 4.0f * val - 0.5f , - 4.0f * val + 3.5f ) ; jet . b = G3D :: min ( 4.0f * val + 0.5f , - 4.0f * val + 2.5f ) ; jet . r = G3D :: clamp ( jet . r , 0.0f , 1.0f ) ; jet . g = G3D :: clamp ( jet . g , 0.0f , 1.0f ) ; jet . b = G3D :: clamp ( jet . b , 0.0f , 1.0f ) ; return jet ; } std :: string Color3 :: toString ( ) const { return G3D :: format ( " ( % g , ▁ % g , ▁ % g ) " , r , g , b ) ; } Color3 Color3 :: rainbowColorMap ( float hue ) { return fromHSV ( Vector3 ( hue , 1.0f , 1.0f ) ) ; } } ; </DOCUMENT>
<DOCUMENT_ID="erdinc@@ ay/c@@ lamav-de@@ vel/tree/master/lib@@ clamav@@ /c++/@@ llvm/lib/Target/@@ PowerPC/PPC@@ SelectionDAGInfo.cpp"> # define DEBUG_TYPE " powerpc - selectiondag - info " # include " PPCTargetMachine . h " using namespace llvm ; PPCSelectionDAGInfo :: PPCSelectionDAGInfo ( const PPCTargetMachine & TM ) : TargetSelectionDAGInfo ( TM ) { } PPCSelectionDAGInfo :: ~ PPCSelectionDAGInfo ( ) { } </DOCUMENT>
<DOCUMENT_ID="lthall/@@ Leonard_@@ ardupilot/tree/master/libraries/AP_NavEKF/@@ AP_NavEKF_core_@@ common.cpp"> # include " AP _ NavEKF _ core _ common . h " NavEKF_core_common :: Matrix24 NavEKF_core_common :: KH ; NavEKF_core_common :: Matrix24 NavEKF_core_common :: KHP ; NavEKF_core_common :: Matrix24 NavEKF_core_common :: nextP ; NavEKF_core_common :: Vector28 NavEKF_core_common :: Kfusion ; void NavEKF_core_common :: fill_sc@@ ratch_variables ( void ) { # if CONFIG_HAL_BOARD == HAL_BOARD_SIT@@ L fill_nanf ( & KH [ 0 ] [ 0 ] , sizeof ( KH ) / sizeof ( float ) ) ; fill_nanf ( & KHP [ 0 ] [ 0 ] , sizeof ( KHP ) / sizeof ( float ) ) ; fill_nanf ( & nextP [ 0 ] [ 0 ] , sizeof ( nextP ) / sizeof ( float ) ) ; fill_nanf ( & Kfusion [ 0 ] , sizeof ( Kfusion ) / sizeof ( float ) ) ; # endif } </DOCUMENT>
<DOCUMENT_ID="so@@ fa-framework@@ /sofa/tree/master/@@ applications/plugins/SofaPython/@@ PythonScriptController.cpp"> # include " PythonMacros . h " # include " PythonScriptController . h " # include < sofa / core / ObjectFactory . h > # include < sofa / helper / AdvancedTimer . h > using sofa :: helper :: AdvancedTimer ; using sofa :: core :: objectmodel :: Base ; using sofa :: simulation :: Node ; # include " Binding _ PythonScriptController . h " using sofa :: simulation :: PythonEnvironment ; # include " PythonScriptEvent . h " using sofa :: core :: objectmodel :: PythonScriptEvent ; # include < sofa / helper / system / FileMonitor . h > using sofa :: helper :: system :: FileMonitor ; using sofa :: helper :: system :: FileEventListener ; # include < sofa / core / objectmodel / IdleEvent . h > using sofa :: core :: objectmodel :: IdleEvent ; # include " PythonFactory . h " struct ActivableScopedAdvancedTimer { const char * message ; bool m_active ; Base * m_base ; ActivableScopedAdvancedTimer ( bool active , const char * message , Base * base ) : message ( message ) , m_active ( active ) , m_base ( base ) { if ( m_active ) AdvancedTimer :: stepBegin ( message , m_base ) ; } ~ ActivableScopedAdvancedTimer ( ) { if ( m_active ) AdvancedTimer :: stepEnd ( message , m_base ) ; } } ; namespace sofa { namespace component { namespace controller { class MyFileEventListener : public FileEventListener { PythonScriptController * m_controller ; public : MyFileEventListener ( PythonScriptController * psc ) { m_controller = psc ; } ~ MyFileEventListener ( ) override { } virtual void fileHasChanged ( const std :: string & filepath ) override { PythonEnvironment :: gil lock { __func__ } ; if ( ! m_controller -> scriptController@@ Instance ( ) ) { m_controller -> doLoadScript ( ) ; } else { PythonEnvironment :: gil state { __func__ } ; std :: string file = filepath ; SP_CALL_FILE@@ FUNC ( const_cast < char * > ( " onReimpAFile " ) , const_cast < char * > ( " s " ) , const_cast < char * > ( file . data ( ) ) ) ; m_controller -> refreshBinding ( ) ; } } } ; int PythonScriptControllerClass = core :: RegisterObject ( " A ▁ Sofa ▁ controller ▁ scripted ▁ in ▁ python " ) . add < PythonScriptController > ( ) ; PythonScriptController :: PythonScriptController ( ) : ScriptController ( ) , m_filename ( initData ( & m_filename , " filename " , " Python ▁ script ▁ filename " ) ) , m_classname ( initData ( & m_classname , " classname " , " Python ▁ class ▁ implemented ▁ in ▁ the ▁ script ▁ to ▁ instanciate ▁ for ▁ the ▁ controller " ) ) , m_variables ( initData ( & m_variables , " variables " , " Array ▁ of ▁ string ▁ variables ▁ ( equivalent ▁ to ▁ a ▁ c - like ▁ argv ) " ) ) , m_timingEnabled ( initData ( & m_timingEnabled , true , " timingEnabled " , " Set ▁ this ▁ attribute ▁ to ▁ true ▁ or ▁ false ▁ to ▁ activate / deactivate ▁ the ▁ gathering " " ▁ of ▁ timing ▁ statistics ▁ on ▁ the ▁ python ▁ execution ▁ time . ▁ Default ▁ value ▁ is ▁ set " " to ▁ true . " ) ) , m_doAutoReload ( initData ( & m_doAutoReload , false , " autore@@ load " , " Automatically ▁ reload ▁ the ▁ file ▁ when ▁ the ▁ source ▁ code ▁ is ▁ changed . ▁ " " Default ▁ value ▁ is ▁ set ▁ to ▁ false " ) ) , m_ScriptControllerClass ( nullptr ) , m_ScriptControllerInstance ( nullptr ) { m_filelistener = new MyFileEventListener ( this ) ; } PythonScriptController :: ~ PythonScriptController ( ) { if ( m_filelistener ) { FileMonitor :: removeListener ( m_filelistener ) ; delete m_filelistener ; } } void PythonScriptController :: setInstance ( PyObject * instance ) { PythonEnvironment :: gil lock ( __func__ ) ; if ( m_ScriptControllerInstance ) { Py_DECREF ( m_ScriptControllerInstance ) ; } m_ScriptControllerInstance = instance ; m_ScriptControllerClass = ( PyObject * ) instance -> ob_type ; Py_INCRE@@ F ( instance ) ; refreshBinding ( ) ; } void PythonScriptController :: refreshBinding ( ) { BIND_OBJECT_METHOD ( onLoaded ) BIND_OBJECT_METHOD ( createGraph ) BIND_OBJECT_METHOD ( initGraph ) BIND_OBJECT_METHOD ( bwdInitGraph ) BIND_OBJECT_METHOD ( onKeyPressed ) BIND_OBJECT_METHOD ( onKeyReleased ) BIND_OBJECT_METHOD ( onMouseMove ) BIND_OBJECT_METHOD ( onMouseButtonLeft ) BIND_OBJECT_METHOD ( onMouseButtonRight ) BIND_OBJECT_METHOD ( onMouseButtonMiddle ) BIND_OBJECT_METHOD ( onMouseWheel ) BIND_OBJECT_METHOD ( onBeginAnimationStep ) BIND_OBJECT_METHOD ( onEndAnimationStep ) BIND_OBJECT_METHOD ( storeResetState ) BIND_OBJECT_METHOD ( reset ) BIND_OBJECT_METHOD ( cleanup ) BIND_OBJECT_METHOD ( onGUIEvent ) BIND_OBJECT_METHOD ( onScriptEvent ) BIND_OBJECT_METHOD ( draw ) BIND_OBJECT_METHOD ( onIdle ) } bool PythonScriptController :: isDerivedFrom ( const std :: string & name , const std :: string & module ) { PythonEnvironment :: gil lock ( __func__ ) ; PyObject * moduleDict = PyModule_GetDict ( PyImport_AddModule ( module . c_str ( ) ) ) ; PyObject * controllerClass = PyDict_GetItemString ( moduleDict , name . c_str ( ) ) ; return 1 == PyObject_IsInstance ( m_ScriptControllerInstance , controllerClass ) ; } void PythonScriptController :: loadScript ( ) { PythonEnvironment :: gil lock ( __func__ ) ; if ( m_doAutoReload . getValue ( ) ) { FileMonitor :: addFile ( m_filename . getFullPath ( ) , m_filelistener ) ; } if ( m_filename . isSet ( ) && ! m_filename . getRelativePath ( ) . empty ( ) && ! PythonEnvironment :: runFile ( m_filename . getFullPath ( ) . c_str ( ) ) ) { msg_error ( ) << " ▁ load ▁ error ▁ ( file ▁ ' " << m_filename . getFullPath ( ) . c_str ( ) << " ' ▁ not ▁ parsable ) " ; return ; } PyObject * pDict = PyModule_GetDict ( PyImport_AddModule ( " _ _ main _ _ " ) ) ; m_ScriptControllerClass = PyDict_GetItemString ( pDict , m_classname . getValueString ( ) . c_str ( ) ) ; if ( ! m_ScriptControllerClass ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ not ▁ found ) . " ; return ; } if ( 1 != PyObject_IsSubclass ( m_ScriptControllerClass , ( PyObject * ) & SP_SOF@@ APYTYPE@@ OBJECT ( PythonScriptController ) ) ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ does ▁ not ▁ inherit ▁ from ▁ ' Sofa . PythonScriptController ' ) . " ; return ; } m_ScriptControllerInstance = BuildPySPtr < Base > ( this , ( PyTypeObject * ) m_ScriptControllerClass ) ; if ( ! m_ScriptControllerInstance ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ instanciation ▁ error ) . " ; return ; } refreshBinding ( ) ; } void PythonScriptController :: doLoadScript ( ) { loadScript ( ) ; } void PythonScriptController :: script_onIdleEvent ( const IdleEvent * ) { FileMonitor :: updates ( 0 ) ; { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_onIdle ) ; } std :: cout . flush ( ) ; std :: cerr . flush ( ) ; } void PythonScriptController :: script_onLoaded ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onLoaded , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) } void PythonScriptController :: script_createGraph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_createGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) } void PythonScriptController :: script_init@@ Graph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_initGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) } void PythonScriptController :: script_bwdInitGraph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_bwdInitGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) } bool PythonScriptController :: script_onKeyPressed ( const char c ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onKeyPressed " , this ) ; bool b = false ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEBOOLFUNC ( m_Func_onKeyPressed , " ( c ) " , c ) ; return b ; } bool PythonScriptController :: script_onKeyReleased ( const char c ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onKeyReleased " , this ) ; bool b = false ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEBOOLFUNC ( m_Func_onKeyReleased , " ( c ) " , c ) ; return b ; } void PythonScriptController :: script_onMouseMove ( const int posX , const int posY ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseMove " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onMouseMove , " ( ii ) " , posX , posY ) ; } void PythonScriptController :: script_onMouseButtonLeft ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonLeft " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonLeft , " ( iiO ) " , posX , posY , pyPressed ) } void PythonScriptController :: script_onMouseButtonRight ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonRight " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonRight , " ( iiO ) " , posX , posY , pyPressed ) } void PythonScriptController :: script_onMouseButtonMiddle ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonMiddle " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonMiddle , " ( iiO ) " , posX , posY , pyPressed ) } void PythonScriptController :: script_onMouseWheel ( const int posX , const int posY , const int delta ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseWheel " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onMouseWheel , " ( iii ) " , posX , posY , delta ) } void PythonScriptController :: script_onBeginAnimationStep ( const double dt ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onBeginAnimationStep " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onBeginAnimationStep , " ( d ) " , dt ) } void PythonScriptController :: script_onEndAnimationStep ( const double dt ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onEndAnimationStep " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onEndAnimationStep , " ( d ) " , dt ) } void PythonScriptController :: script_storeResetState ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_storeResetState ) } void PythonScriptController :: script_reset ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_reset ) } void PythonScriptController :: script_cleanup ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_cleanup ) } void PythonScriptController :: script_onGUIEvent ( const char * controlID , const char * valueName , const char * value ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onGUIEvent " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onGUIEvent , " ( sss ) " , controlID , valueName , value ) ; } void PythonScriptController :: script_onScriptEvent ( core :: objectmodel :: ScriptEvent * event ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onScriptEvent " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PythonScriptEvent * pyEvent = static_cast < PythonScriptEvent * > ( event ) ; SP_CALL_MODULEFUNC ( m_Func_onScriptEvent , " ( OsO ) " , sofa :: PythonFactory :: toPython ( pyEvent -> getSender ( ) . get ( ) ) , pyEvent -> getEventName ( ) . c_str ( ) , pyEvent -> getUserData ( ) ) ; } void PythonScriptController :: script_d@@ raw ( const core :: visual :: VisualParams * ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ draw " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_draw ) ; } void PythonScriptController :: handleEvent ( core :: objectmodel :: Event * event ) { if ( PythonScriptEvent :: checkEventType ( event ) ) { script_onScriptEvent ( static_cast < PythonScriptEvent * > ( event ) ) ; } else { ScriptController :: handleEvent ( event ) ; } } } } } </DOCUMENT>
<DOCUMENT_ID="thiphariel/@@ navitia/tree/master/@@ source/kra@@ ken/tests/data_manager_@@ test.cpp"> # define BOOST_TEST_DYN_@@ LINK # define BOOST_TEST_MODULE data_manager_test # include < boost / test / unit_test . hpp > # include < boost / optional . hpp > # include " kraken / data _ manager . h " # include < atomic > class Data { public : bool load ( const std :: string & , const boost :: optional < std :: string > & , const std :: vector < std :: string > & ) { return load_status ; } mutable std :: atomic < bool > is_connected_to_rabbitmq ; static bool load_status ; static bool destructor_called ; size_t data_identifier ; Data ( size_t data_identifier = 0 ) : data_identifier ( data_identifier ) { is_connected_to_rabbitmq = false ; } ~ Data ( ) { Data :: destructor_called = true ; } } ; bool Data :: load_status = true ; bool Data :: destructor_called = false ; struct fixture { fixture ( ) { Data :: load_status = true ; Data :: destructor_called = false ; } } ; BOOST_FIXTURE_TEST_SUITE ( s , fixture ) BOOST_AUTO_TEST_CASE ( get_data ) { DataManager < Data > data_manager ; auto data = data_manager . get_data ( ) ; BOOST_REQU@@ IRE ( data ) ; BOOST_CHECK_EQUAL ( Data :: destructor_called , false ) ; } BOOST_AUTO_TEST_CASE ( load_success ) { DataManager < Data > data_manager ; auto first_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , data_manager . get_data ( ) ) ; BOOST_CHECK ( data_manager . load ( " " ) ) ; auto second_data = data_manager . get_data ( ) ; BOOST_CHECK_NE ( first_data , second_data ) ; BOOST_CHECK_EQUAL ( Data :: destructor_called , false ) ; } BOOST_AUTO_TEST_CASE ( load_fail ) { DataManager < Data > data_manager ; auto first_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , data_manager . get_data ( ) ) ; Data :: load_status = false ; BOOST_CHECK ( ! data_manager . load ( " " ) ) ; Data :: load_status = true ; auto second_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , second_data ) ; } BOOST_AUTO_TEST_CASE ( destructor_called ) { DataManager < Data > data_manager ; { auto first_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , data_manager . get_data ( ) ) ; BOOST_CHECK ( data_manager . load ( " " ) ) ; auto second_data = data_manager . get_data ( ) ; BOOST_CHECK_NE ( first_data , second_data ) ; BOOST_CHECK_EQUAL ( Data :: destructor_called , false ) ; first_data = boost :: shared_ptr < Data > ( ) ; } BOOST_CHECK_EQUAL ( Data :: destructor_called , true ) ; BOOST_CHECK ( data_manager . get_data ( ) ) ; } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
<DOCUMENT_ID="way@@ finder/Wa@@ yfinder-S60@@ -Navigator/tree/master/CPP@@ /Shared/GuiProt/GeneralParam@@ Receiver.cpp"> # include " arch . h " # include " GuiProt / GuiParameter@@ Enums . h " # include " GuiProt / GuiProtEnums . h " # include " GuiProt / GuiProtMess . h " # include " GuiProt / GeneralParamReceiver . h " # include " GuiProt / GuiProtMessageHandler . h " # include " GenericSettings@@ Data . h " namespace isab { GeneralParamReceiver :: ~ GeneralParamReceiver ( ) { m_guiProtHandler -> DeregisterReceiver ( this , isab :: GuiProtEnums :: SET_GENERAL_PARAMETER ) ; m_guiProtHandler -> DeregisterReceiver ( this , isab :: GuiProtEnums :: GET_GENERAL_PARAMETER ) ; } void GeneralParamReceiver :: init ( ) { m_guiProtHandler -> RegisterReceiver ( this , isab :: GuiProtEnums :: SET_GENERAL_PARAMETER ) ; m_guiProtHandler -> RegisterReceiver ( this , isab :: GuiProtEnums :: GET_GENERAL_PARAMETER ) ; } bool GeneralParamReceiver :: decodedParamNoValue ( uint32 paramId ) { return false ; } bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const float * data , int32 numEntries ) { return false ; } bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const uint8 * data , int32 numEntries ) { return false ; } bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const char * * data , int32 numEntries ) { return false ; } bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const int32 * data , int32 numEntries ) { switch ( paramId ) { case GuiProtEnums :: paramAutoReroute : { m_settingsData -> m_autoReroute = data [ 0 ] ; } break ; case GuiProtEnums :: paramBack@@ lightStrategy : { m_settingsData -> m_backlightStrategy = data [ 0 ] ; } break ; case GuiProtEnums :: paramAutoTracking : { m_settingsData -> m_autoTracking = data [ 0 ] ; } break ; case GuiProtEnums :: paramDistance@@ Mode : { m_settingsData -> m_distanceMode = data [ 0 ] ; } break ; case GuiProtEnums :: paramFavorite@@ Show : { m_settingsData -> m_favorite@@ ShowInMap = data [ 0 ] ; } break ; case GuiProtEnums :: paramHighways : { m_settingsData -> m_routeHighways = data [ 0 ] ; } break ; case GuiProtEnums :: paramTollRoads : { m_settingsData -> m_routeTollRoads = data [ 0 ] ; } break ; case GuiProtEnums :: paramTimeDi@@ st : { m_settingsData -> m_routeCostType = data [ 0 ] ; } break ; case GuiProtEnums :: paramTrack@@ ingLevel : { m_settingsData -> m_trackingLevel = data [ 0 ] ; } break ; case GuiProtEnums :: paramTransport@@ ationType : { m_settingsData -> m_transportationType = data [ 0 ] ; } break ; case GuiProtEnums :: paramTurn@@ SoundsLevel : { m_settingsData -> m_turnSoundsLevel = data [ 0 ] ; } break ; case GuiProtEnums :: userTraffic@@ UpdatePeriod : { int32 val = data [ 0 ] ; m_settingsData -> m_trafficUpdatePeriod = 0xbfffffff & val ; m_settingsData -> m_trafficOldUpdatePeriod = 0xbfffffff & val ; m_settingsData -> m_trafficUpdate = 0x40000000 & val ? 0 : 1 ; m_settingsData -> m_trafficOldUpdate = 0x40000000 & val ? 0 : 1 ; } break ; case GuiProtEnums :: paramAutomati@@ cRouteOnSMSDest : { m_settingsData -> m_autoRouteOnSMSDest = data [ 0 ] ; } break ; case GuiProtEnums :: paramKeep@@ SMSDestInInbox : { m_settingsData -> m_keepSMSDestInInbox = data [ 0 ] ; } break ; case GuiProtEnums :: paramStore@@ SMSDestInMyDest : { m_settingsData -> m_storeSMSDestIn@@ Favorites = data [ 0 ] ; } break ; case GuiProtEnums :: paramPosition@@ Symbol : { m_settingsData -> m_positionSymbol = data [ 0 ] ; } break ; case GuiProtEnums :: paramCheck@@ ForUpdates : { m_settingsData -> m_checkForUpdates = data [ 0 ] ; } break ; default : return false ; break ; } return true ; } bool GeneralParamReceiver :: GuiProtReceiveMessage ( class GuiProtMess * mess ) { GuiProtEnums :: MessageType type = mess -> getMessageType ( ) ; if ( type == GuiProtEnums :: GET_GENERAL_PARAMETER ) { isab :: GeneralParameterMess * gpm = ( isab :: GeneralParameterMess * ) mess ; return decodedParamNoValue ( gpm -> getParamId ( ) ) ; } else if ( type == GuiProtEnums :: SET_GENERAL_PARAMETER ) { isab :: GeneralParameterMess * gpm = ( isab :: GeneralParameterMess * ) mess ; switch ( gpm -> getParamType ( ) ) { case isab :: GuiProtEnums :: paramTypeInt32 : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getIntegerData ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramTypeFloat : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getFloatData ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramTypeBinary : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getBinaryData ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramTypeString : return decodedParamValue ( gpm -> getParamId ( ) , ( const char * * ) gpm -> getStringData ( ) , gpm -> getNumEntries ( ) ) ; break ; default : case isab :: GuiProtEnums :: paramTypeInvalid : return false ; break ; } } return false ; } } </DOCUMENT>
<DOCUMENT_ID="slitvinov/@@ lammps-sph@@ -multiphase/tree/master/src/ASPH@@ ERE/compute_@@ temp_asphere.cpp"> # include " mpi . h " # include " string . h " # include " compute _ temp _ asphere . h " # include " math _ extra . h " # include " atom . h " # include " atom _ vec _ ellipsoid . h " # include " update . h " # include " force . h " # include " domain . h " # include " modify . h " # include " group . h " # include " memory . h " # include " error . h " using namespace LAMMPS_NS ; enum { ROTATE , ALL } ; # define INERTIA 0.2 ComputeTempAsphere :: ComputeTempAsphere ( LAMMPS * lmp , int narg , char * * arg ) : Compute ( lmp , narg , arg ) { if ( narg < 3 ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; scalar_@@ flag = vector_flag = 1 ; size_vector = 6 ; extscalar = 0 ; extvector = 1 ; tempflag = 1 ; tempbias = 0 ; id_bias = NULL ; mode = ALL ; int iarg = 3 ; while ( iarg < narg ) { if ( strcmp ( arg [ iarg ] , " bias " ) == 0 ) { if ( iarg + 2 > narg ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; tempbias = 1 ; int n = strlen ( arg [ iarg + 1 ] ) + 1 ; id_bias = new char [ n ] ; strcpy ( id_bias , arg [ iarg + 1 ] ) ; iarg += 2 ; } else if ( strcmp ( arg [ iarg ] , " dof " ) == 0 ) { if ( iarg + 2 > narg ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; if ( strcmp ( arg [ iarg + 1 ] , " rotate " ) == 0 ) mode = ROTATE ; else if ( strcmp ( arg [ iarg + 1 ] , " all " ) == 0 ) mode = ALL ; else error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; iarg += 2 ; } else error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; } vector = new double [ 6 ] ; } ComputeTempAsphere :: ~ ComputeTempAsphere ( ) { delete [ ] id_bias ; delete [ ] vector ; } void ComputeTempAsphere :: init ( ) { avec = ( AtomVecEllipsoid * ) atom -> style_match ( " ellipsoid " ) ; if ( ! avec ) error -> all ( FLERR , " Compute ▁ temp / asphere ▁ requires ▁ atom ▁ style ▁ ellipsoid " ) ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) if ( ellipsoid [ i ] < 0 ) error -> one ( FLERR , " Compute ▁ temp / asphere ▁ requires ▁ extended ▁ particles " ) ; if ( tempbias ) { int i = modify -> find_compute ( id_bias ) ; if ( i < 0 ) error -> all ( FLERR , " Could ▁ not ▁ find ▁ compute ▁ ID ▁ for ▁ temperature ▁ bias " ) ; tbias = modify -> compute [ i ] ; if ( tbias -> tempflag == 0 ) error -> all ( FLERR , " Bias ▁ compute ▁ does ▁ not ▁ calculate ▁ temperature " ) ; if ( tbias -> tempbias == 0 ) error -> all ( FLERR , " Bias ▁ compute ▁ does ▁ not ▁ calculate ▁ a ▁ velocity ▁ bias " ) ; if ( tbias -> igroup != igroup ) error -> all ( FLERR , " Bias ▁ compute ▁ group ▁ does ▁ not ▁ match ▁ compute ▁ group " ) ; tbias -> init ( ) ; tbias -> setup ( ) ; if ( strcmp ( tbias -> style , " temp / region " ) == 0 ) tempbias = 2 ; else tempbias = 1 ; } } void ComputeTempAsphere :: setup ( ) { fix_dof = - 1 ; dof_compute ( ) ; } void ComputeTempAsphere :: dof_compute ( ) { if ( fix_dof ) adjust_dof_@@ fix ( ) ; double natoms = group -> count ( igroup ) ; int nper ; if ( domain -> dimension == 3 ) { if ( mode == ALL ) nper = 6 ; else nper = 3 ; } else { if ( mode == ALL ) nper = 3 ; else nper = 1 ; } dof = nper * natoms ; if ( tempbias == 1 ) { if ( mode == ALL ) dof -= tbias -> dof_remove ( - 1 ) * natoms ; } else if ( tempbias == 2 ) { int * mask = atom -> mask ; int nlocal = atom -> nlocal ; tbias -> dof_remove_pre ( ) ; int count = 0 ; for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) if ( tbias -> dof_remove ( i ) ) count ++ ; int count_all ; MPI_Allreduce ( & count , & count_all , 1 , MPI_INT , MPI_SUM , world ) ; dof -= nper * count_all ; } dof -= extra_dof + fix_dof ; if ( dof > 0 ) tfactor = force -> mvv2e / ( dof * force -> boltz ) ; else tfactor = 0.0 ; } double ComputeTempAsphere :: compute_scalar ( ) { invoked_scalar = update -> ntimestep ; if ( tempbias ) { if ( tbias -> invoked_scalar != update -> ntimestep ) tbias -> compute_scalar ( ) ; tbias -> remove_bias_all ( ) ; } AtomVecEllipsoid :: Bonus * bonus = avec -> bonus ; double * * v = atom -> v ; double * * angmom = atom -> angmom ; double * rmass = atom -> rmass ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; double * shape , * quat ; double wbody [ 3 ] , inertia [ 3 ] ; double rot [ 3 ] [ 3 ] ; double t = 0.0 ; if ( mode == ALL ) { for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { t += ( v [ i ] [ 0 ] * v [ i ] [ 0 ] + v [ i ] [ 1 ] * v [ i ] [ 1 ] + v [ i ] [ 2 ] * v [ i ] [ 2 ] ) * rmass [ i ] ; shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * rmass [ i ] * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] + inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] + inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; } } else { for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * rmass [ i ] * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] + inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] + inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; } } if ( tempbias ) tbias -> restore_bias_all ( ) ; MPI_Allreduce ( & t , & scalar , 1 , MPI_DOUBLE , MPI_SUM , world ) ; if ( dynamic || tempbias == 2 ) dof_compute ( ) ; scalar *= tfactor ; return scalar ; } void ComputeTempAsphere :: compute_vector ( ) { int i ; invoked_vector = update -> ntimestep ; if ( tempbias ) { if ( tbias -> invoked_vector != update -> ntimestep ) tbias -> compute_vector ( ) ; tbias -> remove_bias_all ( ) ; } AtomVecEllipsoid :: Bonus * bonus = avec -> bonus ; double * * v = atom -> v ; double * * angmom = atom -> angmom ; double * rmass = atom -> rmass ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; double * shape , * quat ; double wbody [ 3 ] , inertia [ 3 ] , t [ 6 ] ; double rot [ 3 ] [ 3 ] ; double massone ; for ( i = 0 ; i < 6 ; i ++ ) t [ i ] = 0.0 ; if ( mode == ALL ) { for ( i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { massone = rmass [ i ] ; t [ 0 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 0 ] ; t [ 1 ] += massone * v [ i ] [ 1 ] * v [ i ] [ 1 ] ; t [ 2 ] += massone * v [ i ] [ 2 ] * v [ i ] [ 2 ] ; t [ 3 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 1 ] ; t [ 4 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 2 ] ; t [ 5 ] += massone * v [ i ] [ 1 ] * v [ i ] [ 2 ] ; shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * massone * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t [ 0 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] ; t [ 1 ] += inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] ; t [ 2 ] += inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; t [ 3 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 1 ] ; t [ 4 ] += inertia [ 1 ] * wbody [ 0 ] * wbody [ 2 ] ; t [ 5 ] += inertia [ 2 ] * wbody [ 1 ] * wbody [ 2 ] ; } } else { for ( i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; massone = rmass [ i ] ; inertia [ 0 ] = INERTIA * massone * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t [ 0 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] ; t [ 1 ] += inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] ; t [ 2 ] += inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; t [ 3 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 1 ] ; t [ 4 ] += inertia [ 1 ] * wbody [ 0 ] * wbody [ 2 ] ; t [ 5 ] += inertia [ 2 ] * wbody [ 1 ] * wbody [ 2 ] ; } } if ( tempbias ) tbias -> restore_bias_all ( ) ; MPI_Allreduce ( t , vector , 6 , MPI_DOUBLE , MPI_SUM , world ) ; for ( i = 0 ; i < 6 ; i ++ ) vector [ i ] *= force -> mvv2e ; } void ComputeTempAsphere :: remove_bias ( int i , double * v ) { if ( tbias ) tbias -> remove_bias ( i , v ) ; } void ComputeTempAsphere :: restore_bias ( int i , double * v ) { if ( tbias ) tbias -> restore_bias ( i , v ) ; } </DOCUMENT>
<DOCUMENT_ID="Singularity@@ Core/Singularity@@ /tree/master/dep/acelite/ace/Log_Msg_@@ IPC.cpp"> # include " ace / Log _ Msg _ IPC . h " # include " ace / Log _ Record . h " # include " ace / CDR _ Stream . h " # include " ace / Truncate . h " ACE_BEGIN_VERSIONED_NAMESPACE_DECL ACE_Log_Msg_IPC :: ACE_Log_Msg_IPC ( void ) { } ACE_Log_Msg_IPC :: ~ ACE_Log_Msg_IPC ( void ) { ( void ) this -> close ( ) ; } int ACE_Log_Msg_IPC :: open ( const ACE_TCHAR * logger_key ) { ACE_LOG_MSG_IPC_CONNECTOR con ; return con . connect ( this -> message_queue_ , ACE_LOG_MSG_IPC_ADDR ( logger_key ) ) ; } int ACE_Log_Msg_IPC :: reset ( void ) { if ( this -> message_queue_ . get_handle ( ) != ACE_INVALID_@@ HANDLE ) { return this -> close ( ) ; } return 0 ; } int ACE_Log_Msg_IPC :: close ( void ) { return this -> message_queue_ . close ( ) ; } ssize_t ACE_Log_Msg_IPC :: log ( ACE_Log_Record & log_record ) { size_t const max_payload_size = 4 + 4 + 12 + 4 + 4 # if defined ( ACE_USES_WCHAR ) + ( log_record . msg_data_len ( ) * ACE_OutputCDR :: wchar_maxbytes ( ) ) # else + log_record . msg_data_len ( ) # endif + ACE_CDR :: MAX_ALIGNMENT ; ACE_OutputCDR payload ( max_payload_size ) ; if ( ! ( payload << log_record ) ) return - 1 ; ACE_CDR :: ULong const length = ACE_Utils :: truncate_cast < ACE_CDR :: ULong > ( payload . total_length ( ) ) ; ACE_OutputCDR header ( ACE_CDR :: MAX_ALIGNMENT + 8 ) ; if ( ! ( header << ACE_OutputCDR :: from_boolean ( ACE_CD@@ R_BY@@ TE_ORDER ) ) ) return - 1 ; if ( ! ( header << ACE_CDR :: ULong ( length ) ) ) return - 1 ; iovec iov [ 2 ] ; iov [ 0 ] . iov_base = header . begin ( ) -> rd_ptr ( ) ; iov [ 0 ] . iov_len = 8 ; iov [ 1 ] . iov_base = payload . begin ( ) -> rd_ptr ( ) ; iov [ 1 ] . iov_len = length ; # if ( ACE_HAS@@ _STREAM_LOG_MSG_IPC == 1 ) ACE_Str_Buf header_msg ( static_cast < void * > ( header . begin ( ) -> rd_ptr ( ) ) , static_cast < int > ( 8 ) ) ; ACE_Str_Buf payload_msg ( static_cast < void * > ( payload . begin ( ) -> rd_ptr ( ) ) , static_cast < int > ( length ) ) ; return this -> message_queue_ . send ( & header_msg , & payload_msg , static_cast < int > ( log_record . priority ( ) ) , MSG_BAND ) ; # else return this -> message_queue_ . sendv_n ( iov , 2 ) ; # endif } ACE_END_VERSIONED_NAMESPACE_DECL </DOCUMENT>
<DOCUMENT_ID="biojpp@@ m/c4@@ stl/tree/master/bm/list/push@@ _back/flat_fwd_list__p@@ aged__NumByte@@ s_64___int@@ 32_t.cpp"> # include " benchmark / benchmark . h " # include " c4 / log . hpp " # include " c4 / allocator . hpp " # include " . . / list _ types . hpp " namespace bm = benchmark ; namespace c4 { template < class List > void BM_ListPushBack ( bm :: State & st ) { List li ; using T = typename List :: value_type ; T v { } ; size_t count = 0 ; while ( st . KeepRunning ( ) ) { for ( int i = 0 , e = st . range ( 0 ) ; i < e ; ++ i ) { if ( li . size ( ) == li . max_size ( ) ) li . clear ( ) ; li . push_back ( v ) ; ++ count ; } li . clear ( ) ; } st . SetComplexityN ( st . range ( 0 ) ) ; st . SetItemsProcessed ( count ) ; st . SetBytesProcessed ( count * sizeof ( T ) ) ; } BENCHMARK_TEMPLATE ( BM_ListPushBack , flat_fwd_list__paged < NumBytes < 64 > C4_COM@@ MA int32_t > ) -> RangeMultiplier ( 2 ) -> Range ( 4 , 1 << 19 ) -> Complexity ( ) ; } BENCHMARK_MAIN ( ) </DOCUMENT>
<DOCUMENT_ID="ay@@ bassioun@@ y/winc@@ affe-@@ cmake/tree/master/src/caff@@ e/test/test_power_@@ layer.cpp"> # include < algorithm > # include < vector > # include " cuda _ runtime . h " # include " gtest / gtest . h " # include " caffe / blob . hpp " # include " caffe / common . hpp " # include " caffe / filler . hpp " # include " caffe / vision _ layers . hpp " # include " caffe / test / test _ gradi@@ ent _ check _ util . hpp " # include " caffe / test / test _ caffe _ main . hpp " using std :: isnan ; namespace caffe { extern cudaDevice@@ Prop CAFFE_TEST_@@ CUDA_PROP ; template < typename Dtype > class PowerLayerTest : public :: testing :: Test { protected : PowerLayerTest ( ) : blob_bottom_ ( new Blob < Dtype > ( 2 , 3 , 4 , 5 ) ) , blob_top_ ( new Blob < Dtype > ( ) ) { Caffe :: set_random_@@ seed ( 1701 ) ; Filler@@ Parameter filler_param ; GaussianFil@@ ler < Dtype > filler ( filler_param ) ; filler . Fill ( this -> blob_bottom_ ) ; blob_bottom_vec_ . push_back ( blob_bottom_ ) ; blob_top_vec_ . push_back ( blob_top_ ) ; } virtual ~ PowerLayerTest ( ) { delete blob_bottom_ ; delete blob_top_ ; } void TestForward ( Dtype power , Dtype scale , Dtype shift ) { LayerParameter layer_param ; layer_param . mutable_power_param ( ) -> set_power ( power ) ; layer_param . mutable_power_param ( ) -> set_scale ( scale ) ; layer_param . mutable_power_param ( ) -> set_shift ( shift ) ; PowerLayer < Dtype > layer ( layer_param ) ; layer . SetUp ( this -> blob_bottom_vec_ , & ( this -> blob_top_vec_ ) ) ; layer . Forward ( this -> blob_bottom_vec_ , & ( this -> blob_top_vec_ ) ) ; const Dtype * bottom_data = this -> blob_bottom_ -> cpu_data ( ) ; const Dtype * top_data = this -> blob_top_ -> cpu_data ( ) ; const Dtype min_precision = 1e - 5 ; for ( int i = 0 ; i < this -> blob_bottom_ -> count ( ) ; ++ i ) { Dtype expected_value = pow ( shift + scale * bottom_data [ i ] , power ) ; if ( power == Dtype ( 0 ) || power == Dtype ( 1 ) || power == Dtype ( 2 ) ) { EXPECT_FALSE ( isnan ( top_data [ i ] ) ) ; } if ( isnan ( expected_value ) ) { EXPECT_TRUE ( isnan ( top_data [ i ] ) ) ; } else { Dtype precision = max ( Dtype ( abs ( expected_value * 0.0001 ) ) , min_precision ) ; EXPECT_NEAR ( expected_value , top_data [ i ] , precision ) ; } } } void TestBackward ( Dtype power , Dtype scale , Dtype shift ) { LayerParameter layer_param ; layer_param . mutable_power_param ( ) -> set_power ( power ) ; layer_param . mutable_power_param ( ) -> set_scale ( scale ) ; layer_param . mutable_power_param ( ) -> set_shift ( shift ) ; PowerLayer < Dtype > layer ( layer_param ) ; if ( power != Dtype ( 0 ) && power != Dtype ( 1 ) && power != Dtype ( 2 ) ) { Dtype * bottom_data = this -> blob_bottom_ -> mutable_cpu_@@ data ( ) ; Dtype min_value = - shift / scale ; for ( int i = 0 ; i < this -> blob_bottom_ -> count ( ) ; ++ i ) { if ( bottom_data [ i ] < min_value ) { bottom_data [ i ] = min_value + ( min_value - bottom_data [ i ] ) ; } } } GradientChecker < Dtype > checker ( 1e - 2 , 1e - 2 , 1701 , 0. , 0.01 ) ; checker . CheckGradient@@ Eltw@@ ise ( & layer , & ( this -> blob_bottom_vec_ ) , & ( this -> blob_top_vec_ ) ) ; } Blob < Dtype > * const blob_bottom_ ; Blob < Dtype > * const blob_top_ ; vector < Blob < Dtype > * > blob_bottom_vec_ ; vector < Blob < Dtype > * > blob_top_vec_ ; } ; typedef :: testing :: Types < float , double > Dtypes ; TYPED_TEST_CASE ( PowerLayerTest , Dtypes ) ; TYPED_TEST ( PowerLayerTest , TestPowerCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGradientShiftZeroCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = 0.0 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerZeroCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerZeroGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerOneCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerOneGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.34 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoScaleHalfGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.5 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGradientShiftZeroGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = 0.0 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerZeroGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerZeroGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerOneGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerOneGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.34 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoScaleHalfGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.5 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } } </DOCUMENT>
<DOCUMENT_ID="KDE/kof@@ fice/tree/master/kcells/dialogs/StyleManagerDialog.cpp"> # include " StyleManagerDialog . h " # include < QMap > # include < QTreeWidget > # include < QVBoxLayout > # include < kcombobox . h > # include < kdebug . h > # include < klocale . h > # include " KCCell . h " # include " LayoutDialog . h " # include " ui / Selection . h " # include " KCSheet . h " # include " KCStyle . h " # include " KCStyleManager . h " # include " commands / KCStyleCommand . h " StyleManagerDialog :: StyleManagerDialog ( QWidget * parent , Selection * selection , KCStyleManager * manager ) : KDialog ( parent ) , m_selection ( selection ) , m_styleManager ( manager ) { setButtons ( Apply | User1 | User2 | User3 | Close ) ; setButtonText ( User3 , i18n ( " & New . . . " ) ) ; setButtonText ( User2 , i18n ( " & Modify . . . " ) ) ; setButtonText ( User1 , i18n ( " & Delete . . . " ) ) ; setButtonsOrientation ( Qt :: Vertical ) ; setCaption ( i18n ( " Style ▁ Manager " ) ) ; QWidget * widget = new QWidget ( this ) ; setMainWidget ( widget ) ; QVBoxLayout * layout = new QVBoxLayout ( widget ) ; m_styleList = new QTreeWidget ( this ) ; m_styleList -> setHeaderLabel ( i18n ( " Style " ) ) ; layout -> addWidget ( m_styleList ) ; m_displayBox = new KComboBox ( false , this ) ; m_displayBox -> insertItem ( 0 , i18n ( " All ▁ Styles " ) ) ; m_displayBox -> insertItem ( 1 , i18n ( " Custom ▁ Styles " ) ) ; m_displayBox -> insertItem ( 2 , i18n ( " Hierarchical " ) ) ; layout -> addWidget ( m_displayBox ) ; slotDisplayMode ( 0 ) ; enableButton ( KDialog :: User3 , true ) ; enableButton ( KDialog :: User2 , true ) ; enableButton ( KDialog :: User1 , false ) ; connect ( m_displayBox , SIGNAL ( activated ( int ) ) , this , SLOT ( slotDisplayMode ( int ) ) ) ; connect ( this , SIGNAL ( applyClicked ( ) ) , this , SLOT ( slotOk ( ) ) ) ; connect ( this , SIGNAL ( user3Clicked ( ) ) , this , SLOT ( slotNew ( ) ) ) ; connect ( this , SIGNAL ( user2Clicked ( ) ) , this , SLOT ( slotEdit ( ) ) ) ; connect ( this , SIGNAL ( user1Clicked ( ) ) , this , SLOT ( slotRemove ( ) ) ) ; connect ( m_styleList , SIGNAL ( itemDoubleClicked ( QTreeWidgetItem * , int ) ) , this , SLOT ( slotEdit ( ) ) ) ; connect ( m_styleList , SIGNAL ( currentItem@@ Changed ( QTreeWidgetItem * , QTreeWidgetItem * ) ) , this , SLOT ( selectionChanged ( QTreeWidgetItem * ) ) ) ; } StyleManagerDialog :: ~ StyleManagerDialog ( ) { } void StyleManagerDialog :: fillComboBox ( ) { typedef QMap < KCCustomStyle * , QTreeWidgetItem * > KCMap ; KCMap entries ; entries . clear ( ) ; entries [ m_styleManager -> defaultStyle ( ) ] = new QTreeWidgetItem ( m_styleList , QStringList ( i18n ( " Default " ) ) ) ; CustomStyles :: const_iterator iter = m_styleManager -> m_styles . constBegin ( ) ; CustomStyles :: const_iterator end = m_styleManager -> m_styles . constEnd ( ) ; while ( entries . count ( ) != m_styleManager -> m_styles . count ( ) + 1 ) { if ( entries . find ( iter . value ( ) ) == entries . end ( ) ) { if ( iter . value ( ) -> parentName ( ) . isNull ( ) ) entries [ iter . value ( ) ] = new QTreeWidgetItem ( entries [ m_styleManager -> defaultStyle ( ) ] , QStringList ( iter . value ( ) -> name ( ) ) ) ; else { KCCustomStyle * parentStyle = m_styleManager -> style ( iter . value ( ) -> parentName ( ) ) ; if ( parentStyle ) { KCMap :: const_iterator i = entries . constFind ( parentStyle ) ; if ( i != entries . constEnd ( ) ) entries [ iter . value ( ) ] = new QTreeWidgetItem ( i . value ( ) , QStringList ( iter . value ( ) -> name ( ) ) ) ; } } } ++ iter ; if ( iter == end ) iter = m_styleManager -> m_styles . constBegin ( ) ; } entries . clear ( ) ; } void StyleManagerDialog :: slotDisplayMode ( int mode ) { m_styleList -> clear ( ) ; if ( mode != 2 ) m_styleList -> setRootIsDecorated ( false ) ; else { m_styleList -> setRootIsDecorated ( true ) ; fillComboBox ( ) ; return ; } if ( mode != 1 ) new QTreeWidgetItem ( m_styleList , QStringList ( i18n ( " Default " ) ) ) ; CustomStyles :: iterator iter = m_styleManager -> m_styles . begin ( ) ; CustomStyles :: iterator end = m_styleManager -> m_styles . end ( ) ; while ( iter != end ) { KCCustomStyle * styleData = iter . value ( ) ; if ( ! styleData || styleData -> name ( ) . isEmpty ( ) ) { ++ iter ; continue ; } if ( mode == 1 ) { if ( styleData -> type ( ) == KCStyle :: CUSTOM ) new QTreeWidgetItem ( m_styleList , QStringList ( styleData -> name ( ) ) ) ; } else new QTreeWidgetItem ( m_styleList , QStringList ( styleData -> name ( ) ) ) ; ++ iter ; } } void StyleManagerDialog :: slotOk ( ) { kDebug ( ) ; QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) { accept ( ) ; return ; } QString name ( item -> text ( 0 ) ) ; if ( name == i18n ( " Default " ) ) { KCStyleCommand * command = new KCStyleCommand ( ) ; command -> setSheet ( m_selection -> activeSheet ( ) ) ; command -> setDefault ( ) ; command -> add ( * m_selection ) ; command -> execute ( m_selection -> canvas ( ) ) ; } else { KCStyleCommand * command = new KCStyleCommand ( ) ; command -> setSheet ( m_selection -> activeSheet ( ) ) ; command -> setParentName ( name ) ; command -> add ( * m_selection ) ; command -> execute ( m_selection -> canvas ( ) ) ; } accept ( ) ; } void StyleManagerDialog :: slotNew ( ) { KCCustomStyle * parentStyle = 0 ; QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( item ) { const QString name = item -> text ( 0 ) ; if ( name == i18n ( " Default " ) ) parentStyle = m_styleManager -> defaultStyle ( ) ; else parentStyle = m_styleManager -> style ( name ) ; } else parentStyle = m_styleManager -> defaultStyle ( ) ; int i = 1 ; QString newName ( i18n ( " style % 1" , m_styleManager -> count ( ) + i ) ) ; while ( m_styleManager -> style ( newName ) != 0 ) { ++ i ; newName = i18n ( " style % 1" , m_styleManager -> count ( ) + i ) ; } KCCustomStyle * style = new KCCustomStyle ( newName , parentStyle ) ; style -> setType ( KCStyle :: TENTATIVE ) ; QPointer < CellFormatDialog > dialog = new CellFormatDialog ( this , m_selection , style , m_styleManager ) ; dialog -> exec ( ) ; delete dialog ; if ( style -> type ( ) == KCStyle :: TENTATIVE ) { delete style ; return ; } m_styleManager -> m_styles [ style -> name ( ) ] = style ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; } void StyleManagerDialog :: slotEdit ( ) { QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) return ; KCCustomStyle * style = 0 ; QString name ( item -> text ( 0 ) ) ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) return ; QPointer < CellFormatDialog > dialog = new CellFormatDialog ( this , m_selection , style , m_styleManager ) ; dialog -> exec ( ) ; if ( dialog -> result ( ) == Accepted ) m_selection -> emitRefreshSheet@@ Views ( ) ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; delete dialog ; } void StyleManagerDialog :: slotRemove ( ) { QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) return ; const QString name = item -> text ( 0 ) ; KCCustomStyle * style = 0 ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) return ; if ( style -> type ( ) != KCStyle :: CUSTOM ) return ; m_styleManager -> takeStyle ( style ) ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; } void StyleManagerDialog :: selectionChanged ( QTreeWidgetItem * item ) { if ( ! item ) return ; const QString name = item -> text ( 0 ) ; KCCustomStyle * style = 0 ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) { enableButton ( KDialog :: User1 , false ) ; return ; } if ( style -> type ( ) == KCStyle :: BUILTIN ) enableButton ( KDialog :: User1 , false ) ; else enableButton ( KDialog :: User1 , true ) ; } # include " StyleManagerDialog . moc " </DOCUMENT>
<DOCUMENT_ID="nawawi/@@ wkhtmltopd@@ f/tree/master/webkit/Source/WebCore/bindings/@@ js/JSDocument@@ Custom.cpp"> # include " config . h " # include " JSDocument . h " # include " ExceptionCode . h " # include " Frame . h " # include " FrameLoader . h " # include " HTMLDocument . h " # include " JSCan@@ vasRenderingContext@@ 2D . h " # if ENABLE ( WEBGL ) # include " JSWeb@@ GLRenderingContext . h " # endif # include " JSDOMWindowCustom . h " # include " JSHTMLDocument . h " # include " JSLocation . h " # include " JSTouch . h " # include " JSTouchList . h " # include " Location . h " # include " ScriptController . h " # include " TouchList . h " # if ENABLE ( SVG ) # include " JSSVGDocument . h " # include " SVGDocument . h " # endif # include < wtf / GetPtr . h > using namespace JSC ; namespace WebCore { JSValue JSDocument :: location ( ExecState * exec ) const { Frame * frame = static_cast < Document * > ( impl ( ) ) -> frame ( ) ; if ( ! frame ) return jsNull ( ) ; Location * location = frame -> document ( ) -> domWindow ( ) -> location ( ) ; if ( JSDOMWrapper * wrapper = getCachedWrapper ( currentWorld ( exec ) , location ) ) return wrapper ; JSLocation * jsLocation = JSLocation :: create ( getDOMStructure < JSLocation > ( exec , globalObject ( ) ) , globalObject ( ) , location ) ; cacheWrapper ( currentWorld ( exec ) , location , jsLocation ) ; return jsLocation ; } void JSDocument :: setLocation ( ExecState * exec , JSValue value ) { Frame * frame = static_cast < Document * > ( impl ( ) ) -> frame ( ) ; if ( ! frame ) return ; String locationString = value . toString ( exec ) -> value ( exec ) ; if ( exec -> hadException ( ) ) return ; if ( Location * location = frame -> document ( ) -> domWindow ( ) -> location ( ) ) location -> setHref ( locationString , activeDOMWindow ( exec ) , firstDOMWindow ( exec ) ) ; } JSValue toJS ( ExecState * exec , JSDOMGlobalObject * globalObject , Document * document ) { if ( ! document ) return jsNull ( ) ; JSDOMWrapper * wrapper = getCachedWrapper ( currentWorld ( exec ) , document ) ; if ( wrapper ) return wrapper ; if ( DOMWindow * domWindow = document -> domWindow ( ) ) { globalObject = toJSDOMWindow ( toJS ( exec , domWindow ) ) ; wrapper = getCachedWrapper ( currentWorld ( exec ) , document ) ; if ( wrapper ) return wrapper ; } if ( document -> isHTMLDocument ( ) ) wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , HTMLDocument , document ) ; # if ENABLE ( SVG ) else if ( document -> isSVGDocument ( ) ) wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , SVGDocument , document ) ; # endif else wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , Document , document ) ; if ( ! document -> frame ( ) ) { size_t nodeCount = 0 ; for ( Node * n = document ; n ; n = n -> traverse@@ NextNode ( ) ) nodeCount ++ ; exec -> heap ( ) -> reportExtra@@ MemoryCost ( nodeCount * sizeof ( Node ) ) ; } return wrapper ; } # if ENABLE ( TOUCH_@@ EVENTS ) JSValue JSDocument :: createTouchList ( ExecState * exec ) { RefPtr < TouchList > touchList = TouchList :: create ( ) ; for ( size_t i = 0 ; i < exec -> argumentCount ( ) ; i ++ ) touchList -> append ( toTouch ( exec -> argument ( i ) ) ) ; return toJS ( exec , globalObject ( ) , touchList . release ( ) ) ; } # endif } </DOCUMENT>
<DOCUMENT_ID="makh@@ dumi/robo@@ mongo/tree/master/src/thir@@ d-party/mongodb/src/@@ mongo/db@@ /pipel@@ ine/ac@@ cumulator.cpp"> # include " pch . h " # include " db / pipeline / accumulator . h " # include " db / jsobj . h " # include " util / mongoutils / str . h " namespace mongo { using namespace mongoutils ; void Accumulator :: addOperand ( const intrusi@@ ve_ptr < Expression > & pExpression ) { uassert ( 1594@@ 3 , str :: stream ( ) << " group ▁ accumulator ▁ " << getOpName ( ) << " ▁ only ▁ accepts ▁ one ▁ operand " , vpOperand . size ( ) < 1 ) ; ExpressionNary :: addOperand ( pExpression ) ; } Accumulator :: Accumulator ( ) : ExpressionNary ( ) { } void Accumulator :: opToBson ( BSONObjBuilder * pBuilder , StringData opName , StringData fieldName , bool requireExpression ) const { verify ( vpOperand . size ( ) == 1 ) ; BSONObjBuilder builder ; vpOperand [ 0 ] -> addToBsonObj ( & builder , opName , requireExpression ) ; pBuilder -> append ( fieldName , builder . done ( ) ) ; } void Accumulator :: addToBsonObj ( BSONObjBuilder * pBuilder , StringData fieldName , bool requireExpression ) const { opToBson ( pBuilder , getOpName ( ) , fieldName , requireExpression ) ; } void Accumulator :: addToBsonArray ( BSONArrayBuilder * pBuilder ) const { verify ( false ) ; } void agg_framework_reser@@ vedErrors ( ) { uassert ( 16030 , " reserved ▁ error " , false ) ; uassert ( 16031 , " reserved ▁ error " , false ) ; uassert ( 16032 , " reserved ▁ error " , false ) ; uassert ( 16033 , " reserved ▁ error " , false ) ; uassert ( 16036 , " reserved ▁ error " , false ) ; uassert ( 16037 , " reserved ▁ error " , false ) ; uassert ( 16038 , " reserved ▁ error " , false ) ; uassert ( 16039 , " reserved ▁ error " , false ) ; uassert ( 16040 , " reserved ▁ error " , false ) ; uassert ( 16041 , " reserved ▁ error " , false ) ; uassert ( 16042 , " reserved ▁ error " , false ) ; uassert ( 16043 , " reserved ▁ error " , false ) ; uassert ( 16044 , " reserved ▁ error " , false ) ; uassert ( 16045 , " reserved ▁ error " , false ) ; uassert ( 16046 , " reserved ▁ error " , false ) ; uassert ( 16047 , " reserved ▁ error " , false ) ; uassert ( 16048 , " reserved ▁ error " , false ) ; uassert ( 16049 , " reserved ▁ error " , false ) ; } } </DOCUMENT>
<DOCUMENT_ID="doorxp/@@ ccjson@@ /tree/master/cocos2d/cocos/@@ audio/android/AudioResampler.cpp"> # define LOG_TAG " AudioResampler " # include < stdint . h > # include < stdlib . h > # include < sys / types . h > # include < pthread . h > # include < new > # include " audio / android / cutils / log . h " # include " audio / android / utils / Utils . h " # include " audio / android / audio _ utils / include / audio _ utils / primitives . h " # include " audio / android / AudioResampler . h " # include " audio / android / AudioResamplerCubic . h " namespace cocos2d { namespace experimental { class AudioResamplerOrder1 : public AudioResampler { public : AudioResamplerOrder1 ( int inChannelCount , int32_t sampleRate ) : AudioResampler ( inChannelCount , sampleRate , LOW_QUALITY ) , mX0L ( 0 ) , mX0R ( 0 ) { } virtual size_t resample ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) ; private : static const int kNumInterpBits = 15 ; static const int kPreInterpShift = kNumPhaseBits - kNumInterpBits ; void init ( ) { } size_t resampleMono16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) ; size_t resampleStereo16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) ; # ifdef ASM_ARM_RESAMP1 void AsmMono16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) ; void AsmStereo16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) ; # endif static inline int32_t Interp ( int32_t x0 , int32_t x1 , uint32_t f ) { return x0 + ( ( ( x1 - x0 ) * ( int32_t ) ( f >> kPreInterpShift ) ) >> kNumInterpBits ) ; } static inline void Advance ( size_t * index , uint32_t * frac , uint32_t inc ) { * frac += inc ; * index += ( size_t ) ( * frac >> kNumPhaseBits ) ; * frac &= kPhaseMask ; } int mX0L ; int mX0R ; } ; const double AudioResampler :: kPhaseMultiplier = 1L << AudioResampler :: kNumPhaseBits ; bool AudioResampler :: qualityIsSupported ( src_quality quality ) { switch ( quality ) { case DEFAULT_QUALITY : case LOW_QUALITY : case MED_QUALITY : case HIGH_QUALITY : case VERY_HIGH_QUALITY : return true ; default : return false ; } } static pthread_once@@ _t once_control = PTHREAD_ONCE_@@ INIT ; static AudioResampler :: src_quality defaultQuality = AudioResampler :: DEFAULT_QUALITY ; void AudioResampler :: init_routine ( ) { } uint32_t AudioResampler :: qualityMHz ( src_quality quality ) { switch ( quality ) { default : case DEFAULT_QUALITY : case LOW_QUALITY : return 3 ; case MED_QUALITY : return 6 ; case HIGH_QUALITY : return 20 ; case VERY_HIGH_QUALITY : return 34 ; } } static const uint32_t maxMHz = 130 ; static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER ; static uint32_t currentMHz = 0 ; AudioResampler * AudioResampler :: create ( audio_format@@ _t format , int inChannelCount , int32_t sampleRate , src_quality quality ) { bool atFinalQuality ; if ( quality == DEFAULT_QUALITY ) { int ok = pthread_once ( & once_control , init_routine ) ; if ( ok != 0 ) { ALOGE ( " % s ▁ pthread _ once ▁ failed : ▁ % d " , __func__ , ok ) ; } quality = defaultQuality ; atFinalQuality = false ; } else { atFinalQuality = true ; } if ( quality == DEFAULT_QUALITY ) { } pthread_mutex_lock ( & mutex ) ; for ( ; ; ) { uint32_t deltaMHz = qualityMHz ( quality ) ; uint32_t newMHz = currentMHz + deltaMHz ; if ( ( qualityIsSupported ( quality ) && newMHz <= maxMHz ) || atFinalQuality ) { ALOGV ( " resampler ▁ load ▁ % u ▁ - > ▁ % u ▁ MHz ▁ due ▁ to ▁ delta ▁ + % u ▁ MHz ▁ from ▁ quality ▁ % d " , currentMHz , newMHz , deltaMHz , quality ) ; currentMHz = newMHz ; break ; } switch ( quality ) { default : case LOW_QUALITY : atFinalQuality = true ; break ; case MED_QUALITY : quality = LOW_QUALITY ; break ; case HIGH_QUALITY : quality = MED_QUALITY ; break ; case VERY_HIGH_QUALITY : quality = HIGH_QUALITY ; break ; } } pthread_mutex_unlock ( & mutex ) ; AudioResampler * resampler ; switch ( quality ) { default : case LOW_QUALITY : ALOGV ( " Create ▁ linear ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; resampler = new ( std :: nothrow ) AudioResamplerOrder1 ( inChannelCount , sampleRate ) ; break ; case MED_QUALITY : ALOGV ( " Create ▁ cubic ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; resampler = new ( std :: nothrow ) AudioResamplerCubic ( inChannelCount , sampleRate ) ; break ; case HIGH_QUALITY : ALOGV ( " Create ▁ HIGH _ QUALITY ▁ sinc ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; ALOG_ASSERT ( false , " HIGH _ QUALITY ▁ isn ' t ▁ supported " ) ; break ; case VERY_HIGH_QUALITY : ALOGV ( " Create ▁ VERY _ HIGH _ QUALITY ▁ sinc ▁ Resampler ▁ = ▁ % d " , quality ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; ALOG_ASSERT ( false , " VERY _ HIGH _ QUALITY ▁ isn ' t ▁ supported " ) ; break ; } resampler -> init ( ) ; return resampler ; } AudioResampler :: AudioResampler ( int inChannelCount , int32_t sampleRate , src_quality quality ) : mChannelCount ( inChannelCount ) , mSampleRate ( sampleRate ) , mInSampleRate ( sampleRate ) , mInputIndex ( 0 ) , mPhaseFraction ( 0 ) , mLocalTimeFreq ( 0 ) , mPTS ( AudioBufferProvider :: kInvalidPTS ) , mQuality ( quality ) { const int maxChannels = 2 ; if ( inChannelCount < 1 || inChannelCount > maxChannels ) { LOG_ALWAYS_FATAL ( " Unsupported ▁ sample ▁ format ▁ % d ▁ quality ▁ % d ▁ channels " , quality , inChannelCount ) ; } if ( sampleRate <= 0 ) { LOG_ALWAYS_FATAL ( " Unsupported ▁ sample ▁ rate ▁ % d ▁ Hz " , sampleRate ) ; } mVolume [ 0 ] = mVolume [ 1 ] = 0 ; mBuffer . frameCount = 0 ; } AudioResampler :: ~ AudioResampler ( ) { pthread_mutex_lock ( & mutex ) ; src_quality quality = getQuality ( ) ; uint32_t deltaMHz = qualityMHz ( quality ) ; int32_t newMHz = currentMHz - deltaMHz ; ALOGV ( " resampler ▁ load ▁ % u ▁ - > ▁ % d ▁ MHz ▁ due ▁ to ▁ delta ▁ - % u ▁ MHz ▁ from ▁ quality ▁ % d " , currentMHz , newMHz , deltaMHz , quality ) ; LOG_ALWAYS_FATAL_IF ( newMHz < 0 , " negative ▁ resampler ▁ load ▁ % d ▁ MHz " , newMHz ) ; currentMHz = newMHz ; pthread_mutex_unlock ( & mutex ) ; } void AudioResampler :: setSampleRate ( int32_t inSampleRate ) { mInSampleRate = inSampleRate ; mPhaseIncrement = ( uint32_t ) ( ( kPhaseMultiplier * inSampleRate ) / mSampleRate ) ; } void AudioResampler :: setVolume ( float left , float right ) { mVolume [ 0 ] = u4_12_from_float ( clampFloatVol ( left ) ) ; mVolume [ 1 ] = u4_12_from_float ( clampFloatVol ( right ) ) ; } void AudioResampler :: setLocalTimeFreq ( uint64_t freq ) { mLocalTimeFreq = freq ; } void AudioResampler :: setPTS ( int64_t pts ) { mPTS = pts ; } int64_t AudioResampler :: calculateOutputPTS ( int outputFrameIndex ) { if ( mPTS == AudioBufferProvider :: kInvalidPTS ) { return AudioBufferProvider :: kInvalidPTS ; } else { return mPTS + ( ( outputFrameIndex * mLocalTimeFreq ) / mSampleRate ) ; } } void AudioResampler :: reset ( ) { mInputIndex = 0 ; mPhaseFraction = 0 ; mBuffer . frameCount = 0 ; } size_t AudioResamplerOrder1 :: resample ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { switch ( mChannelCount ) { case 1 : return resampleMono16 ( out , outFrameCount , provider ) ; case 2 : return resampleStereo16 ( out , outFrameCount , provider ) ; default : LOG_ALWAYS_FATAL ( " invalid ▁ channel ▁ count : ▁ % d " , mChannelCount ) ; return 0 ; } } size_t AudioResamplerOrder1 :: resampleStereo16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { int32_t vl = mVolume [ 0 ] ; int32_t vr = mVolume [ 1 ] ; size_t inputIndex = mInputIndex ; uint32_t phaseFraction = mPhaseFraction ; uint32_t phaseIncrement = mPhaseIncrement ; size_t outputIndex = 0 ; size_t outputSampleCount = outFrameCount * 2 ; size_t inFrameCount = getInFrameCountRequired ( outFrameCount ) ; while ( outputIndex < outputSampleCount ) { while ( mBuffer . frameCount == 0 ) { mBuffer . frameCount = inFrameCount ; provider -> getNextBuffer ( & mBuffer , calculateOutputPTS ( outputIndex / 2 ) ) ; if ( mBuffer . raw == NULL ) { goto resampleStereo16_exit ; } if ( mBuffer . frameCount > inputIndex ) break ; inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount * 2 - 2 ] ; mX0R = mBuffer . i16 [ mBuffer . frameCount * 2 - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } int16_t * in = mBuffer . i16 ; while ( inputIndex == 0 ) { out [ outputIndex ++ ] += vl * Interp ( mX0L , in [ 0 ] , phaseFraction ) ; out [ outputIndex ++ ] += vr * Interp ( mX0R , in [ 1 ] , phaseFraction ) ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; if ( outputIndex == outputSampleCount ) { break ; } } # ifdef ASM_ARM_RESAMP1 if ( inputIndex + 2 < mBuffer . frameCount ) { int32_t * maxOutPt ; int32_t maxInIdx ; maxOutPt = out + ( outputSampleCount - 2 ) ; maxInIdx = mBuffer . frameCount - 2 ; AsmStereo16Loop ( in , maxOutPt , maxInIdx , outputIndex , out , inputIndex , vl , vr , phaseFraction , phaseIncrement ) ; } # endif while ( outputIndex < outputSampleCount && inputIndex < mBuffer . frameCount ) { out [ outputIndex ++ ] += vl * Interp ( in [ inputIndex * 2 - 2 ] , in [ inputIndex * 2 ] , phaseFraction ) ; out [ outputIndex ++ ] += vr * Interp ( in [ inputIndex * 2 - 1 ] , in [ inputIndex * 2 + 1 ] , phaseFraction ) ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; } if ( inputIndex >= mBuffer . frameCount ) { inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount * 2 - 2 ] ; mX0R = mBuffer . i16 [ mBuffer . frameCount * 2 - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } } resampleStereo16_exit : mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; return outputIndex / 2 ; } size_t AudioResamplerOrder1 :: resampleMono16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { int32_t vl = mVolume [ 0 ] ; int32_t vr = mVolume [ 1 ] ; size_t inputIndex = mInputIndex ; uint32_t phaseFraction = mPhaseFraction ; uint32_t phaseIncrement = mPhaseIncrement ; size_t outputIndex = 0 ; size_t outputSampleCount = outFrameCount * 2 ; size_t inFrameCount = getInFrameCountRequired ( outFrameCount ) ; while ( outputIndex < outputSampleCount ) { while ( mBuffer . frameCount == 0 ) { mBuffer . frameCount = inFrameCount ; provider -> getNextBuffer ( & mBuffer , calculateOutputPTS ( outputIndex / 2 ) ) ; if ( mBuffer . raw == NULL ) { mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; goto resampleMono16_exit ; } if ( mBuffer . frameCount > inputIndex ) break ; inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } int16_t * in = mBuffer . i16 ; while ( inputIndex == 0 ) { int32_t sample = Interp ( mX0L , in [ 0 ] , phaseFraction ) ; out [ outputIndex ++ ] += vl * sample ; out [ outputIndex ++ ] += vr * sample ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; if ( outputIndex == outputSampleCount ) { break ; } } # ifdef ASM_ARM_RESAMP1 if ( inputIndex + 2 < mBuffer . frameCount ) { int32_t * maxOutPt ; int32_t maxInIdx ; maxOutPt = out + ( outputSampleCount - 2 ) ; maxInIdx = ( int32_t ) mBuffer . frameCount - 2 ; AsmMono16Loop ( in , maxOutPt , maxInIdx , outputIndex , out , inputIndex , vl , vr , phaseFraction , phaseIncrement ) ; } # endif while ( outputIndex < outputSampleCount && inputIndex < mBuffer . frameCount ) { int32_t sample = Interp ( in [ inputIndex - 1 ] , in [ inputIndex ] , phaseFraction ) ; out [ outputIndex ++ ] += vl * sample ; out [ outputIndex ++ ] += vr * sample ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; } if ( inputIndex >= mBuffer . frameCount ) { inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } } resampleMono16_exit : mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; return outputIndex ; } # ifdef ASM_ARM_RESAMP1 __attribute__ ( ( noinline ) ) void AudioResamplerOrder1 :: AsmMono16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) { ( void ) maxOutPt ; ( void ) maxInIdx ; ( void ) outputIndex ; ( void ) out ; ( void ) inputIndex ; ( void ) vl ; ( void ) vr ; ( void ) phaseFraction ; ( void ) phaseIncrement ; ( void ) in ; # define MO_PARAM5 "36" asm ( " stmfd ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ lr } \n " " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 20 ] \n " " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ r6 ] \n " " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 8 ] \n " " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ r7 ] \n " " ▁ ▁ ▁ ldr ▁ r8 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 4 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ r0 ] \n " " ▁ ▁ ▁ add ▁ r8 , ▁ r8 , ▁ r0 , ▁ asl ▁ # 2 \n " " ▁ ▁ ▁ ldr ▁ r9 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 24 ] \n " " ▁ ▁ ▁ ldr ▁ r10 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 12 ] \n " " ▁ ▁ ▁ ldr ▁ r11 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 16 ] \n " "1 : \n " " ▁ ▁ ▁ cmp ▁ r8 , ▁ r2 \n " " ▁ ▁ ▁ bcs ▁ 2f \n " # define MO_ONE_FRAME " ▁ ▁ ▁ add ▁ r0 , ▁ r1 , ▁ r7 , ▁ asl ▁ # 1 \n " " ▁ ▁ ▁ ldrsh ▁ r4 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r5 , ▁ [ r8 ] \n " " ▁ ▁ ▁ ldrsh ▁ r0 , ▁ [ r0 , ▁ # -2 ] \n " " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " " ▁ ▁ ▁ sub ▁ r4 , ▁ r4 , ▁ r0 \n " " ▁ ▁ ▁ mov ▁ r4 , ▁ r4 , ▁ lsl ▁ # 2 \n " " ▁ ▁ ▁ smulwt ▁ r4 , ▁ r4 , ▁ r6 \n " " ▁ ▁ ▁ add ▁ r6 , ▁ r6 , ▁ r9 \n " " ▁ ▁ ▁ add ▁ r0 , ▁ r0 , ▁ r4 \n " " ▁ ▁ ▁ mla ▁ r5 , ▁ r0 , ▁ r10 , ▁ r5 \n " " ▁ ▁ ▁ ldr ▁ r4 , ▁ [ r8 , ▁ # 4 ] \n " " ▁ ▁ ▁ str ▁ r5 , ▁ [ r8 ] , ▁ # 4 \n " " ▁ ▁ ▁ mla ▁ r4 , ▁ r0 , ▁ r11 , ▁ r4 \n " " ▁ ▁ ▁ add ▁ r7 , ▁ r7 , ▁ r6 , ▁ lsr ▁ # 30 \n " " ▁ ▁ ▁ str ▁ r4 , ▁ [ r8 ] , ▁ # 4 \n " MO_ONE_FRAME MO_ONE_FRAME " ▁ ▁ ▁ cmp ▁ r7 , ▁ r3 \n " " ▁ ▁ ▁ bcc ▁ 1b \n " "2 : \n " " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 20 ] \n " " ▁ ▁ ▁ str ▁ r6 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 8 ] \n " " ▁ ▁ ▁ str ▁ r7 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 4 ] \n " " ▁ ▁ ▁ sub ▁ r8 , ▁ r0 \n " " ▁ ▁ ▁ asr ▁ r8 , ▁ # 2 \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 0 ] \n " " ▁ ▁ ▁ str ▁ r8 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldmfd ▁ ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ pc } \n " ) ; } __attribute__ ( ( noinline ) ) void AudioResamplerOrder1 :: AsmStereo16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) { ( void ) maxOutPt ; ( void ) maxInIdx ; ( void ) outputIndex ; ( void ) out ; ( void ) inputIndex ; ( void ) vl ; ( void ) vr ; ( void ) phaseFraction ; ( void ) phaseIncrement ; ( void ) in ; # define ST_PARAM5 "40" asm ( " stmfd ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ r12 , ▁ lr } \n " " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 20 ] \n " " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ r6 ] \n " " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 8 ] \n " " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ r7 ] \n " " ▁ ▁ ▁ ldr ▁ r8 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 4 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ r0 ] \n " " ▁ ▁ ▁ add ▁ r8 , ▁ r8 , ▁ r0 , ▁ asl ▁ # 2 \n " " ▁ ▁ ▁ ldr ▁ r9 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 24 ] \n " " ▁ ▁ ▁ ldr ▁ r10 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 12 ] \n " " ▁ ▁ ▁ ldr ▁ r11 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 16 ] \n " "3 : \n " " ▁ ▁ ▁ cmp ▁ r8 , ▁ r2 \n " " ▁ ▁ ▁ bcs ▁ 4f \n " # define ST_ONE_FRAME " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " " ▁ ▁ ▁ add ▁ r0 , ▁ r1 , ▁ r7 , ▁ asl ▁ # 2 \n " " ▁ ▁ ▁ ldrsh ▁ r4 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r5 , ▁ [ r8 ] \n " " ▁ ▁ ▁ ldrsh ▁ r12 , ▁ [ r0 , ▁ # -4 ] \n " " ▁ ▁ ▁ sub ▁ r4 , ▁ r4 , ▁ r12 \n " " ▁ ▁ ▁ mov ▁ r4 , ▁ r4 , ▁ lsl ▁ # 2 \n " " ▁ ▁ ▁ smulwt ▁ r4 , ▁ r4 , ▁ r6 \n " " ▁ ▁ ▁ add ▁ r12 , ▁ r12 , ▁ r4 \n " " ▁ ▁ ▁ mla ▁ r5 , ▁ r12 , ▁ r10 , ▁ r5 \n " " ▁ ▁ ▁ ldr ▁ r4 , ▁ [ r8 , ▁ # 4 ] \n " " ▁ ▁ ▁ str ▁ r5 , ▁ [ r8 ] , ▁ # 4 \n " " ▁ ▁ ▁ ldrsh ▁ r12 , ▁ [ r0 , ▁ # + 2 ] \n " " ▁ ▁ ▁ ldrsh ▁ r0 , ▁ [ r0 , ▁ # -2 ] \n " " ▁ ▁ ▁ sub ▁ r12 , ▁ r12 , ▁ r0 \n " " ▁ ▁ ▁ mov ▁ r12 , ▁ r12 , ▁ lsl ▁ # 2 \n " " ▁ ▁ ▁ smulwt ▁ r12 , ▁ r12 , ▁ r6 \n " " ▁ ▁ ▁ add ▁ r12 , ▁ r0 , ▁ r12 \n " " ▁ ▁ ▁ mla ▁ r4 , ▁ r12 , ▁ r11 , ▁ r4 \n " " ▁ ▁ ▁ str ▁ r4 , ▁ [ r8 ] , ▁ # 4 \n " " ▁ ▁ ▁ add ▁ r6 , ▁ r6 , ▁ r9 \n " " ▁ ▁ ▁ add ▁ r7 , ▁ r7 , ▁ r6 , ▁ lsr ▁ # 30 \n " ST_ONE_FRAME ST_ONE_FRAME " ▁ ▁ ▁ cmp ▁ r7 , ▁ r3 \n " " ▁ ▁ ▁ bcc ▁ 3b \n " "4 : \n " " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 20 ] \n " " ▁ ▁ ▁ str ▁ r6 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 8 ] \n " " ▁ ▁ ▁ str ▁ r7 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 4 ] \n " " ▁ ▁ ▁ sub ▁ r8 , ▁ r0 \n " " ▁ ▁ ▁ asr ▁ r8 , ▁ # 2 \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 0 ] \n " " ▁ ▁ ▁ str ▁ r8 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldmfd ▁ ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ r12 , ▁ pc } \n " ) ; } # endif } } </DOCUMENT>
<DOCUMENT_ID="yxcoin/@@ yxcoin/tree/master/src/boost_1_@@ 55_0/libs/@@ phoenix/test/include/st@@ l/algorithm/@@ querying.cpp"> # include < boost / phoenix / stl / algorithm / querying . hpp > int main ( ) { } </DOCUMENT>
<DOCUMENT_ID="Live@@ Asynchronous@@ VisualizedArchitecture@@ /lava/tree/master/nuklear@@ /unified.cpp"> # define LAVA_INDE@@ XED_VERTS_IMPL # include " IndexedVerts . h " # include " nanogui / src / screen . cpp " # include " main . cpp " </DOCUMENT>
<DOCUMENT_ID="ellip@@ sis14/dol@@ fin/tree/master/test/unit/la/cpp/@@ Vector.cpp"> # include < dolfin . h > # include < dolfin / common / unittest . h > using namespace dolfin ; class TestVector : public CppUnit :: TestFixture { CPPUNIT_TEST_SUITE ( TestVector ) ; CPPUNIT_TEST ( test_backends ) ; CPPUNIT_TEST ( test_init ) ; CPPUNIT_TEST ( test_get_local_empty ) ; CPPUNIT_TEST_SUITE_END ( ) ; public : void test_backends ( ) { parameters [ " linear _ algebra _ backend " ] = " Eigen " ; _test_operators ( MPI_COMM_SELF ) ; # ifdef HAS_PETSC parameters [ " linear _ algebra _ backend " ] = " PETSc " ; _test_operators ( MPI_COMM_WORLD ) ; # endif } void _test_operators ( MPI_Comm comm ) { Vector v ( comm , 10 ) , u ( comm , 10 ) ; v = 0.0 ; u = 0.0 ; CPPUNIT_ASSERT ( v . sum ( ) == 0.0 ) ; v = 1.0 ; CPPUNIT_ASSERT ( v . sum ( ) == v . size ( ) ) ; u = v ; CPPUNIT_ASSERT ( u . sum ( ) == u . size ( ) ) ; u += v ; CPPUNIT_ASSERT ( u . sum ( ) == 2 * u . size ( ) ) ; u -= v ; u -= v ; CPPUNIT_ASSERT ( u . sum ( ) == 0.0 ) ; v *= 5.0 ; CPPUNIT_ASSERT ( v . sum ( ) == v . size ( ) * 5.0 ) ; v /= 2.0 ; CPPUNIT_ASSERT ( v . sum ( ) == 2.5 * v . size ( ) ) ; u = 2.0 ; v *= u ; CPPUNIT_ASSERT ( v . sum ( ) == v . size ( ) * 5.0 ) ; } void test_init ( ) { const std :: vector < std :: size_t > dims ( 1 , 203 ) ; TensorLayout layout_local ( 0 , false ) ; std :: vector < std :: pair < std :: size_t , std :: size_t > > local_range ( 1 , std :: make_pair ( 0 , 203 ) ) ; layout_local . init ( MPI_COMM_SELF , dims , 1 , local_range ) ; TensorLayout layout_distributed ( 0 , false ) ; std :: vector < std :: pair < std :: size_t , std :: size_t > > ownership_range ( 1 , dolfin :: MPI :: local_range ( MPI_COMM_WORLD , 203 ) ) ; layout_distributed . init ( MPI_COMM_WORLD , dims , 1 , ownership_range ) ; # ifdef HAS_PETSC parameters [ " linear _ algebra _ backend " ] = " PETSc " ; { Vector x ; x . init ( layout_local ) ; CPPUNIT_ASSERT ( x . size ( ) == 203 ) ; Vector y ; y . init ( layout_distributed ) ; CPPUNIT_ASSERT ( y . size ( ) == 203 ) ; } # endif { EigenVector x ; x . init ( layout_local ) ; CPPUNIT_ASSERT ( x . size ( ) == 203 ) ; } # ifdef HAS_PETSC { PETScVector x ; x . init ( layout_local ) ; CPPUNIT_ASSERT ( x . size ( ) == 203 ) ; PETScVector y ; y . init ( layout_distributed ) ; CPPUNIT_ASSERT ( y . size ( ) == 203 ) ; } # endif } void test_get_local_empty ( ) { const std :: vector < std :: size_t > dims ( 1 , 203 ) ; TensorLayout layout_local ( 0 , false ) ; std :: vector < std :: pair < std :: size_t , std :: size_t > > local_range ( 1 , std :: make_pair ( 0 , 203 ) ) ; layout_local . init ( MPI_COMM_SELF , dims , 1 , local_range ) ; TensorLayout layout_distributed ( 0 , false ) ; std :: vector < std :: pair < std :: size_t , std :: size_t > > ownership_range ( 1 , dolfin :: MPI :: local_range ( MPI_COMM_WORLD , 203 ) ) ; layout_distributed . init ( MPI_COMM_WORLD , dims , 1 , ownership_range ) ; # ifdef HAS_PETSC parameters [ " linear _ algebra _ backend " ] = " PETSc " ; { Vector x ; x . init ( layout_local ) ; CPPUNIT_ASSERT ( x . size ( ) == 203 ) ; Vector y ; y . init ( layout_distributed ) ; CPPUNIT_ASSERT ( y . size ( ) == 203 ) ; double * block = NULL ; dolfin :: la_index * rows = NULL ; x . get_local ( block , 0 , rows ) ; y . get_local ( block , 0 , rows ) ; } # endif } } ; CPPUNIT_TEST_SUITE_REGISTRATION ( TestVector ) ; int main ( ) { DOLFIN_TEST ; } </DOCUMENT>
