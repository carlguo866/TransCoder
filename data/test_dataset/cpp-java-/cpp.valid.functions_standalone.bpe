PROPER@@ TY@@ _SOURCE ( Robot@@ Gui :: View@@ Provid@@ er@@ Tr@@ aj@@ ect@@ ory , Gui :: View@@ Provid@@ er@@ Ge@@ ometr@@ y@@ Object ) View@@ Provid@@ er@@ Tr@@ aj@@ ect@@ ory :: View@@ Provid@@ er@@ Tr@@ aj@@ ect@@ ory ( ) { pc@@ Tr@@ aj@@ ect@@ ory@@ Root = new Gui :: So@@ FC@@ Selection ( ) ; pc@@ Tr@@ aj@@ ect@@ ory@@ Root -> high@@ light@@ Mode = Gui :: So@@ FC@@ Selection :: OFF ; pc@@ Tr@@ aj@@ ect@@ ory@@ Root -> selection@@ Mode = Gui :: So@@ FC@@ Selection :: SE@@ L_@@ OFF ; pc@@ Tr@@ aj@@ ect@@ ory@@ Root -> ref ( ) ; pc@@ Co@@ ords = new So@@ Coord@@ inate@@ 3 ( ) ; pc@@ Co@@ ords -> ref ( ) ; pc@@ Draw@@ Style = new So@@ Draw@@ Style ( ) ; pc@@ Draw@@ Style -> ref ( ) ; pc@@ Draw@@ Style -> style = So@@ Draw@@ Style :: LINES ; pc@@ Draw@@ Style -> lineWidth = 2 ; pc@@ Lines = new So@@ Line@@ Set ; pc@@ Lines -> ref ( ) ; }
String base@@ 64Encode ( const char * data , unsigned length , Base@@ 64@@ Encode@@ Policy po@@ lic@@ y ) { Vector < char > result ; base@@ 64Encode ( data , length , result , po@@ lic@@ y ) ; return String ( result . data ( ) , result . size ( ) ) ; }
void base@@ 64Encode ( const char * data , unsigned len , Vector < char > & out , Base@@ 64@@ Encode@@ Policy po@@ lic@@ y ) { out . clear ( ) ; if ( ! len ) return ; const unsigned max@@ Input@@ Buffer@@ Size = UINT_MAX / 77 * 76 / 4 * 3 - 2 ; if ( len > max@@ Input@@ Buffer@@ Size ) return ; unsigned si@@ dx = 0 ; unsigned d@@ idx = 0 ; unsigned out@@ Length = ( ( len + 2 ) / 3 ) * 4 ; bool insert@@ L@@ F@@ s = ( po@@ lic@@ y == Base@@ 64@@ Insert@@ L@@ F@@ s && out@@ Length > 76 ) ; if ( insert@@ L@@ F@@ s ) out@@ Length += ( ( out@@ Length - 1 ) / 76 ) ; int count = 0 ; out . gro@@ w ( out@@ Length ) ; if ( len > 1 ) { while ( si@@ dx < len - 2 ) { if ( insert@@ L@@ F@@ s ) { if ( count && ! ( count % 76 ) ) out [ d@@ idx ++ ] = ' \n ' ; count += 4 ; } out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( data [ si@@ dx ] >> 2 ) & 0@@ 77 ] ; out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( ( data [ si@@ dx + 1 ] >> 4 ) & 0@@ 17 ) | ( ( data [ si@@ dx ] << 4 ) & 0@@ 77 ) ] ; out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( ( data [ si@@ dx + 2 ] >> 6 ) & 00@@ 3 ) | ( ( data [ si@@ dx + 1 ] << 2 ) & 0@@ 77 ) ] ; out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ data [ si@@ dx + 2 ] & 0@@ 77 ] ; si@@ dx += 3 ; } } if ( si@@ dx < len ) { if ( insert@@ L@@ F@@ s && ( count > 0 ) && ! ( count % 76 ) ) out [ d@@ idx ++ ] = ' \n ' ; out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( data [ si@@ dx ] >> 2 ) & 0@@ 77 ] ; if ( si@@ dx < len - 1 ) { out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( ( data [ si@@ dx + 1 ] >> 4 ) & 0@@ 17 ) | ( ( data [ si@@ dx ] << 4 ) & 0@@ 77 ) ] ; out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( data [ si@@ dx + 1 ] << 2 ) & 0@@ 77 ] ; } else out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( data [ si@@ dx ] << 4 ) & 0@@ 77 ] ; } while ( d@@ idx < out . size ( ) ) { out [ d@@ idx ] = ' = ' ; ++ d@@ idx ; } }
bool base@@ 64@@ Dec@@ ode ( const Vector < char > & in , Vector < char > & out , Base@@ 64@@ Deco@@ de@@ Policy po@@ lic@@ y ) { out . clear ( ) ; if ( in . size ( ) > UINT_MAX ) return false ; return base@@ 64@@ Dec@@ ode ( in . data ( ) , in . size ( ) , out , po@@ lic@@ y ) ; }
template < typename T > static inline bool base@@ 64@@ Deco@@ de@@ Internal ( const T * data , unsigned len , Vector < char > & out , Base@@ 64@@ Deco@@ de@@ Policy po@@ lic@@ y ) { out . clear ( ) ; if ( ! len ) return true ; out . gro@@ w ( len ) ; bool s@@ aw@@ Equal@@ s@@ Sign = false ; unsigned out@@ Length = 0 ; for ( unsigned idx = 0 ; idx < len ; ++ idx ) { unsigned ch = data [ idx ] ; if ( ch == ' = ' ) s@@ aw@@ Equal@@ s@@ Sign = true ; else if ( ( '0' <= ch && ch <= '9' ) || ( ' A ' <= ch && ch <= ' Z ' ) || ( ' a ' <= ch && ch <= ' z ' ) || ch == ' + ' || ch == ' / ' ) { if ( s@@ aw@@ Equal@@ s@@ Sign ) return false ; out [ out@@ Length ] = base@@ 64@@ Dec@@ Map [ ch ] ; ++ out@@ Length ; } else if ( po@@ lic@@ y == Base@@ 64@@ Fail@@ On@@ Invalid@@ Character || ( po@@ lic@@ y == Base@@ 64@@ Ignore@@ Wh@@ ite@@ space && ! is@@ Space@@ Or@@ New@@ line ( ch ) ) ) return false ; } if ( ! out@@ Length ) return ! s@@ aw@@ Equal@@ s@@ Sign ; if ( ( out@@ Length % 4 ) == 1 ) return false ; out@@ Length -= ( out@@ Length + 3 ) / 4 ; if ( ! out@@ Length ) return false ; unsigned si@@ dx = 0 ; unsigned d@@ idx = 0 ; if ( out@@ Length > 1 ) { while ( d@@ idx < out@@ Length - 2 ) { out [ d@@ idx ] = ( ( ( out [ si@@ dx ] << 2 ) & 255 ) | ( ( out [ si@@ dx + 1 ] >> 4 ) & 00@@ 3 ) ) ; out [ d@@ idx + 1 ] = ( ( ( out [ si@@ dx + 1 ] << 4 ) & 255 ) | ( ( out [ si@@ dx + 2 ] >> 2 ) & 0@@ 17 ) ) ; out [ d@@ idx + 2 ] = ( ( ( out [ si@@ dx + 2 ] << 6 ) & 255 ) | ( out [ si@@ dx + 3 ] & 0@@ 77 ) ) ; si@@ dx += 4 ; d@@ idx += 3 ; } } if ( d@@ idx < out@@ Length ) out [ d@@ idx ] = ( ( ( out [ si@@ dx ] << 2 ) & 255 ) | ( ( out [ si@@ dx + 1 ] >> 4 ) & 00@@ 3 ) ) ; if ( ++ d@@ idx < out@@ Length ) out [ d@@ idx ] = ( ( ( out [ si@@ dx + 1 ] << 4 ) & 255 ) | ( ( out [ si@@ dx + 2 ] >> 2 ) & 0@@ 17 ) ) ; if ( out@@ Length < out . size ( ) ) out . shrin@@ k ( out@@ Length ) ; return true ; }
bool base@@ 64@@ Dec@@ ode ( const char * data , unsigned len , Vector < char > & out , Base@@ 64@@ Deco@@ de@@ Policy po@@ lic@@ y ) { return base@@ 64@@ Deco@@ de@@ Internal < char > ( data , len , out , po@@ lic@@ y ) ; }
bool base@@ 64@@ Dec@@ ode ( const String & in , Vector < char > & out , Base@@ 64@@ Deco@@ de@@ Policy po@@ lic@@ y ) { return base@@ 64@@ Deco@@ de@@ Internal < UChar > ( in . characters ( ) , in . length ( ) , out , po@@ lic@@ y ) ; }
static A@@ vai@@ lable@@ V@@ al@@ s@@ Ty & get@@ A@@ vai@@ lable@@ V@@ als ( void * A@@ V ) { return * static_cast < A@@ vai@@ lable@@ V@@ al@@ s@@ Ty * > ( A@@ V ) ; }
static unsigned Lo@@ ok@@ For@@ Identical@@ PH@@ I ( MachineBasicBlock * BB , Small@@ Vector@@ Impl < std :: pair < MachineBasicBlock * , unsigned > > & Pre@@ d@@ Values ) { if ( BB -> empty ( ) ) return 0 ; MachineBasicBlock :: iterator I = BB -> begin ( ) ; if ( ! I -> is@@ PH@@ I ( ) ) return 0 ; A@@ vai@@ lable@@ V@@ al@@ s@@ Ty AV@@ als ; for ( unsigned i = 0 , e = Pre@@ d@@ Values . size ( ) ; i != e ; ++ i ) AV@@ als [ Pre@@ d@@ Values [ i ] . first ] = Pre@@ d@@ Values [ i ] . second ; while ( I != BB -> end ( ) && I -> is@@ PH@@ I ( ) ) { bool Same = true ; for ( unsigned i = 1 , e = I -> getNum@@ Oper@@ ands ( ) ; i != e ; i += 2 ) { unsigned SrcReg = I -> getOperand ( i ) . getReg ( ) ; MachineBasicBlock * Src@@ BB = I -> getOperand ( i + 1 ) . get@@ MBB ( ) ; if ( AV@@ als [ Src@@ BB ] != SrcReg ) { Same = false ; break ; } } if ( Same ) return I -> getOperand ( 0 ) . getReg ( ) ; ++ I ; } return 0 ; }
static MachineInstr@@ Builder Insert@@ New@@ Def ( unsigned Opcode , MachineBasicBlock * BB , MachineBasicBlock :: iterator I , const TargetRegisterClass * RC , MachineRegisterInfo * MRI , const TargetInstrInfo * TII ) { unsigned New@@ VR = MRI -> createVirtualRegister ( RC ) ; return BuildMI ( * BB , I , DebugLoc ( ) , TII -> get ( Opcode ) , New@@ VR ) ; }
static MachineBasicBlock * find@@ Cor@@ respon@@ d@@ ing@@ Pre@@ d ( const MachineInstr * MI , Machine@@ Operand * U ) { for ( unsigned i = 1 , e = MI -> getNum@@ Oper@@ ands ( ) ; i != e ; i += 2 ) { if ( & MI -> getOperand ( i ) == U ) return MI -> getOperand ( i + 1 ) . get@@ MBB ( ) ; } ll@@ v@@ m_@@ un@@ reachable ( " Machine@@ Operand : : getParent ( ) ▁ fail@@ ure ? " ) ; }
static Bl@@ k@@ Suc@@ c_@@ iterator Bl@@ k@@ Suc@@ c_@@ begin ( Bl@@ k@@ T * BB ) { return BB -> suc@@ c_@@ begin ( ) ; }
static Bl@@ k@@ Suc@@ c_@@ iterator Bl@@ k@@ Suc@@ c_@@ end ( Bl@@ k@@ T * BB ) { return BB -> suc@@ c_@@ end ( ) ; }
unsigned getIn@@ coming@@ Value ( ) { return PH@@ I -> getOperand ( idx ) . getReg ( ) ; }
MachineBasicBlock * getIn@@ coming@@ Block ( ) { return PH@@ I -> getOperand ( idx + 1 ) . get@@ MBB ( ) ; }
static inline P@@ HI@@ _iterator P@@ HI@@ _begin ( Ph@@ i@@ T * PH@@ I ) { return P@@ HI@@ _iterator ( PH@@ I ) ; }
static inline P@@ HI@@ _iterator P@@ HI@@ _end ( Ph@@ i@@ T * PH@@ I ) { return P@@ HI@@ _iterator ( PH@@ I , true ) ; }
static void Find@@ Pre@@ de@@ cess@@ or@@ Blocks ( MachineBasicBlock * BB , Small@@ Vector@@ Impl < MachineBasicBlock * > * Pre@@ ds ) { for ( MachineBasicBlock :: pre@@ d_iterator PI = BB -> pre@@ d_@@ begin ( ) , E = BB -> pre@@ d_@@ end ( ) ; PI != E ; ++ PI ) Pre@@ ds -> push_back ( * PI ) ; }
static unsigned Get@@ Un@@ def@@ Val ( MachineBasicBlock * BB , Machine@@ S@@ SA@@ Upd@@ ater * Upd@@ ater ) { MachineInstr * New@@ Def = Insert@@ New@@ Def ( TargetOpcode :: IMPLICIT_@@ DEF , BB , BB -> getFirst@@ Ter@@ minator ( ) , Upd@@ ater -> V@@ RC , Upd@@ ater -> MRI , Upd@@ ater -> TII ) ; return New@@ Def -> getOperand ( 0 ) . getReg ( ) ; }
static unsigned Create@@ Empty@@ PH@@ I ( MachineBasicBlock * BB , unsigned Num@@ Pre@@ ds , Machine@@ S@@ SA@@ Upd@@ ater * Upd@@ ater ) { MachineBasicBlock :: iterator Loc = BB -> empty ( ) ? BB -> end ( ) : BB -> begin ( ) ; MachineInstr * PH@@ I = Insert@@ New@@ Def ( TargetOpcode :: PH@@ I , BB , Loc , Upd@@ ater -> V@@ RC , Upd@@ ater -> MRI , Upd@@ ater -> TII ) ; return PH@@ I -> getOperand ( 0 ) . getReg ( ) ; }
static void Add@@ PH@@ IO@@ per@@ and ( MachineInstr * PH@@ I , unsigned Val , MachineBasicBlock * Pre@@ d ) { MachineInstr@@ Builder ( * Pre@@ d -> getParent ( ) , PH@@ I ) . addReg ( Val ) . add@@ MBB ( Pre@@ d ) ; }
static MachineInstr * Instr@@ Is@@ PH@@ I ( MachineInstr * I ) { if ( I && I -> is@@ PH@@ I ( ) ) return I ; return nullptr ; }
static MachineInstr * Value@@ Is@@ PH@@ I ( unsigned Val , Machine@@ S@@ SA@@ Upd@@ ater * Upd@@ ater ) { return Instr@@ Is@@ PH@@ I ( Upd@@ ater -> MRI -> get@@ V@@ Reg@@ Def ( Val ) ) ; }
static MachineInstr * Value@@ Is@@ New@@ PH@@ I ( unsigned Val , Machine@@ S@@ SA@@ Upd@@ ater * Upd@@ ater ) { MachineInstr * PH@@ I = Value@@ Is@@ PH@@ I ( Val , Upd@@ ater ) ; if ( PH@@ I && PH@@ I -> getNum@@ Oper@@ ands ( ) <= 1 ) return PH@@ I ; return nullptr ; }
static unsigned Get@@ P@@ HI@@ Value ( MachineInstr * PH@@ I ) { return PH@@ I -> getOperand ( 0 ) . getReg ( ) ; }
void En@@ sure@@ Wallet@@ Is@@ Unlock@@ ed ( ) { if ( pw@@ all@@ et@@ Main -> Is@@ Locked ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ UN@@ LOC@@ K_@@ NE@@ E@@ DED , " Error : ▁ Please ▁ enter ▁ the ▁ wallet ▁ pas@@ sp@@ hr@@ ase ▁ with ▁ wall@@ et@@ pas@@ sp@@ hr@@ ase ▁ first . " ) ; if ( f@@ Wallet@@ Unlock@@ St@@ ak@@ ing@@ Only ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ AL@@ READ@@ Y_@@ UN@@ LOC@@ KE@@ D@@ _ST@@ A@@ KING_@@ ONLY , " Error : ▁ Wallet ▁ is ▁ un@@ lock@@ ed ▁ for ▁ st@@ ak@@ ing ▁ only . " ) ; }
void Wallet@@ Tx@@ To@@ JS@@ ON ( const CWalletTx & wtx , Object & entry ) { int confi@@ r@@ ms = wtx . Get@@ Depth@@ In@@ Main@@ Chain ( ) ; entry . push_back ( Pair ( " confirm@@ ations " , confi@@ r@@ ms ) ) ; if ( wtx . Is@@ Co@@ in@@ Base ( ) || wtx . Is@@ Co@@ in@@ St@@ a@@ ke ( ) ) entry . push_back ( Pair ( " generated " , true ) ) ; if ( confi@@ r@@ ms > 0 ) { entry . push_back ( Pair ( " block@@ hash " , wtx . hash@@ Block . Get@@ Hex ( ) ) ) ; entry . push_back ( Pair ( " blockindex " , wtx . nIndex ) ) ; entry . push_back ( Pair ( " block@@ time " , ( boost :: int64_t ) ( mapBlockIndex [ wtx . hash@@ Block ] -> nTime ) ) ) ; } entry . push_back ( Pair ( " tx@@ id " , wtx . GetHash ( ) . Get@@ Hex ( ) ) ) ; entry . push_back ( Pair ( " norm@@ tx@@ id " , wtx . Get@@ Nor@@ m@@ alized@@ Hash ( ) . Get@@ Hex ( ) ) ) ; entry . push_back ( Pair ( " time " , ( boost :: int64_t ) wtx . Get@@ Tx@@ Time ( ) ) ) ; entry . push_back ( Pair ( " time@@ received " , ( boost :: int64_t ) wtx . n@@ Time@@ Received ) ) ; BOOST_FOREACH ( const PAIRTYPE ( string , string ) & item , wtx . map@@ Value ) entry . push_back ( Pair ( item . first , item . second ) ) ; }
string Account@@ From@@ Value ( const Value & value ) { string strAccount = value . get_str ( ) ; if ( strAccount == " * " ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ INVALID_@@ AC@@ CO@@ UN@@ T_@@ NAME , " Invalid ▁ account ▁ name " ) ; return strAccount ; }
Value get@@ info ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) != 0 ) throw runtime_error ( " get@@ info \n " " Retur@@ ns ▁ an ▁ object ▁ containing ▁ vario@@ us ▁ state ▁ info . " ) ; pro@@ xy@@ Type proxy ; Get@@ Proxy ( NE@@ T_@@ IPV4 , proxy ) ; Object obj ; obj . push_back ( Pair ( " version " , ( int ) CLIENT_VERSION ) ) ; obj . push_back ( Pair ( " proto@@ col@@ version " , ( int ) PROTOCOL_VERSION ) ) ; if ( pw@@ all@@ et@@ Main ) { obj . push_back ( Pair ( " wall@@ et@@ version " , pw@@ all@@ et@@ Main -> Get@@ Version ( ) ) ) ; obj . push_back ( Pair ( " bal@@ ance " , Value@@ From@@ Amount ( pw@@ all@@ et@@ Main -> GetB@@ al@@ ance ( ) ) ) ) ; obj . push_back ( Pair ( " un@@ confirm@@ ed@@ bal@@ ance " , Value@@ From@@ Amount ( pw@@ all@@ et@@ Main -> Get@@ Un@@ confirm@@ ed@@ B@@ al@@ ance ( ) ) ) ) ; obj . push_back ( Pair ( " st@@ a@@ ke " , Value@@ From@@ Amount ( pw@@ all@@ et@@ Main -> Get@@ St@@ a@@ ke ( ) ) ) ) ; obj . push_back ( Pair ( " lock@@ ed " , pw@@ all@@ et@@ Main -> Is@@ Locked ( ) ) ) ; obj . push_back ( Pair ( " encryp@@ ted " , pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) ) ) ; } obj . push_back ( Pair ( " block@@ s " , ( int ) nBestHeight ) ) ; obj . push_back ( Pair ( " time@@ offset " , ( boost :: int64_t ) GetTime@@ Offset ( ) ) ) ; obj . push_back ( Pair ( " m@@ one@@ y@@ sup@@ pl@@ y " , Value@@ From@@ Amount ( pindexBest -> n@@ M@@ one@@ y@@ Sup@@ pl@@ y ) ) ) ; obj . push_back ( Pair ( " connections " , ( int ) v@@ Nodes . size ( ) ) ) ; obj . push_back ( Pair ( " proxy " , ( proxy . first . IsValid ( ) ? proxy . first . ToString@@ IP@@ Port ( ) : string ( ) ) ) ) ; obj . push_back ( Pair ( " di@@ ffi@@ c@@ ul@@ ty " , ( double ) Get@@ Di@@ ffi@@ c@@ ul@@ ty ( ) ) ) ; obj . push_back ( Pair ( " test@@ net " , fTestNet ) ) ; if ( pw@@ all@@ et@@ Main ) { obj . push_back ( Pair ( " ke@@ ypo@@ o@@ lo@@ l@@ dest " , ( boost :: int64_t ) pw@@ all@@ et@@ Main -> Get@@ O@@ l@@ dest@@ Key@@ Pool@@ Time ( ) ) ) ; obj . push_back ( Pair ( " ke@@ ypo@@ ol@@ size " , ( int ) pw@@ all@@ et@@ Main -> GetKey@@ Pool@@ Size ( ) ) ) ; } obj . push_back ( Pair ( " pay@@ tx@@ fe@@ e " , Value@@ From@@ Amount ( nTransactionFee ) ) ) ; obj . push_back ( Pair ( " min@@ input " , Value@@ From@@ Amount ( nMin@@ imum@@ Input@@ Value ) ) ) ; if ( pw@@ all@@ et@@ Main && pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) ) obj . push_back ( Pair ( " un@@ lock@@ ed _ un@@ til " , ( boost :: int64_t ) nWallet@@ Unlock@@ Time ) ) ; obj . push_back ( Pair ( " errors " , Get@@ Warnings ( " statu@@ sb@@ ar " ) ) ) ; return obj ; }
Value get@@ new@@ address ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 1 ) throw runtime_error ( " get@@ new@@ address ▁ [ account ] \n " " Retur@@ ns ▁ a ▁ new ▁ I@@ Lo@@ ve@@ You@@ Co@@ ins ▁ address ▁ for ▁ receiving ▁ pay@@ ments . ▁ ▁ " " If ▁ [ account ] ▁ is ▁ specified ▁ ( re@@ comm@@ en@@ ded ) , ▁ it ▁ is ▁ added ▁ to ▁ the ▁ address ▁ book ▁ " " so ▁ pay@@ ments ▁ received ▁ with ▁ the ▁ address ▁ will ▁ be ▁ cre@@ di@@ ted ▁ to ▁ [ account ] . " ) ; string strAccount ; if ( params . size ( ) > 0 ) strAccount = Account@@ From@@ Value ( params [ 0 ] ) ; if ( ! pw@@ all@@ et@@ Main -> Is@@ Locked ( ) ) pw@@ all@@ et@@ Main -> Top@@ Up@@ Key@@ Pool ( ) ; CP@@ ub@@ Key new@@ Key ; if ( ! pw@@ all@@ et@@ Main -> GetKey@@ From@@ Pool ( new@@ Key , false ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ KE@@ Y@@ POOL_@@ RAN@@ _@@ OUT , " Error : ▁ Ke@@ ypo@@ ol ▁ ra@@ n ▁ out , ▁ please ▁ call ▁ ke@@ ypo@@ ol@@ re@@ fill ▁ first " ) ; C@@ Key@@ ID key@@ ID = new@@ Key . GetID ( ) ; pw@@ all@@ et@@ Main -> Set@@ Address@@ Book@@ Name ( key@@ ID , strAccount ) ; return CBitcoinAddress ( key@@ ID ) . ToString ( ) ; }
CBitcoinAddress Get@@ Account@@ Address ( string strAccount , bool b@@ Force@@ New = false ) { CWalletDB wall@@ et@@ db ( pw@@ all@@ et@@ Main -> strWalletFile ) ; CAccount account ; wall@@ et@@ db . ReadAccount ( strAccount , account ) ; bool b@@ Key@@ Used = false ; if ( account . vchPubKey . IsValid ( ) ) { CScript scriptPubKey ; scriptPubKey . Set@@ Destination ( account . vchPubKey . GetID ( ) ) ; for ( map < uint256 , CWalletTx > :: iterator it = pw@@ all@@ et@@ Main -> mapWallet . begin ( ) ; it != pw@@ all@@ et@@ Main -> mapWallet . end ( ) && account . vchPubKey . IsValid ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; BOOST_FOREACH ( const CTx@@ Out & tx@@ out , wtx . vout ) if ( tx@@ out . scriptPubKey == scriptPubKey ) b@@ Key@@ Used = true ; } } if ( ! account . vchPubKey . IsValid ( ) || b@@ Force@@ New || b@@ Key@@ Used ) { if ( ! pw@@ all@@ et@@ Main -> GetKey@@ From@@ Pool ( account . vchPubKey , false ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ KE@@ Y@@ POOL_@@ RAN@@ _@@ OUT , " Error : ▁ Ke@@ ypo@@ ol ▁ ra@@ n ▁ out , ▁ please ▁ call ▁ ke@@ ypo@@ ol@@ re@@ fill ▁ first " ) ; pw@@ all@@ et@@ Main -> Set@@ Address@@ Book@@ Name ( account . vchPubKey . GetID ( ) , strAccount ) ; wall@@ et@@ db . WriteAccount ( strAccount , account ) ; } return CBitcoinAddress ( account . vchPubKey . GetID ( ) ) ; }
Value get@@ ac@@ count@@ address ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) != 1 ) throw runtime_error ( " get@@ ac@@ count@@ address ▁ < account > \n " " Retur@@ ns ▁ the ▁ current ▁ I@@ Lo@@ ve@@ You@@ Co@@ ins ▁ address ▁ for ▁ receiving ▁ pay@@ ments ▁ to ▁ this ▁ account . " ) ; string strAccount = Account@@ From@@ Value ( params [ 0 ] ) ; Value ret ; ret = Get@@ Account@@ Address ( strAccount ) . ToString ( ) ; return ret ; }
Value set@@ account ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " set@@ account ▁ < ilo@@ vey@@ ou@@ coin@@ s@@ address > ▁ < account > \n " " Set@@ s ▁ the ▁ account ▁ associated ▁ with ▁ the ▁ gi@@ ven ▁ address . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID@@ _ADD@@ RESS_@@ OR_@@ KEY , " Invalid ▁ I@@ Lo@@ ve@@ You@@ Co@@ ins ▁ address " ) ; string strAccount ; if ( params . size ( ) > 1 ) strAccount = Account@@ From@@ Value ( params [ 1 ] ) ; if ( pw@@ all@@ et@@ Main -> mapAddress@@ Book . count ( address . Get ( ) ) ) { string str@@ Old@@ Account = pw@@ all@@ et@@ Main -> mapAddress@@ Book [ address . Get ( ) ] ; if ( address == Get@@ Account@@ Address ( str@@ Old@@ Account ) ) Get@@ Account@@ Address ( str@@ Old@@ Account , true ) ; } pw@@ all@@ et@@ Main -> Set@@ Address@@ Book@@ Name ( address . Get ( ) , strAccount ) ; return Value :: null ; }
Value get@@ account ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) != 1 ) throw runtime_error ( " get@@ account ▁ < ilo@@ vey@@ ou@@ coin@@ s@@ address > \n " " Retur@@ ns ▁ the ▁ account ▁ associated ▁ with ▁ the ▁ gi@@ ven ▁ address . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID@@ _ADD@@ RESS_@@ OR_@@ KEY , " Invalid ▁ I@@ Lo@@ ve@@ You@@ Co@@ ins ▁ address " ) ; string strAccount ; map < CTxDestination , string > :: iterator mi = pw@@ all@@ et@@ Main -> mapAddress@@ Book . find ( address . Get ( ) ) ; if ( mi != pw@@ all@@ et@@ Main -> mapAddress@@ Book . end ( ) && ! ( * mi ) . second . empty ( ) ) strAccount = ( * mi ) . second ; return strAccount ; }
Value get@@ address@@ es@@ by@@ account ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) != 1 ) throw runtime_error ( " get@@ address@@ es@@ by@@ account ▁ < account > \n " " Retur@@ ns ▁ the ▁ list ▁ of ▁ addresses ▁ for ▁ the ▁ gi@@ ven ▁ account . " ) ; string strAccount = Account@@ From@@ Value ( params [ 0 ] ) ; Array ret ; BOOST_FOREACH ( const PAIRTYPE ( CBitcoinAddress , string ) & item , pw@@ all@@ et@@ Main -> mapAddress@@ Book ) { const CBitcoinAddress & address = item . first ; const string & strName = item . second ; if ( strName == strAccount ) ret . push_back ( address . ToString ( ) ) ; } return ret ; }
Value set@@ min@@ input ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 1 || params . size ( ) > 1 ) throw runtime_error ( " set@@ min@@ input ▁ < amount > \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ ro@@ unded ▁ to ▁ the ▁ nearest ▁ 0.@@ 0000000@@ 1" ) ; int64 n@@ Amount = 0 ; if ( params [ 0 ] . get_@@ real ( ) != 0.0 ) n@@ Amount = Amo@@ unt@@ From@@ Value ( params [ 0 ] ) ; nMin@@ imum@@ Input@@ Value = n@@ Amount ; return true ; }
Value send@@ to@@ address ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 2 || params . size ( ) > 4 ) throw runtime_error ( " send@@ to@@ address ▁ < ilo@@ vey@@ ou@@ coin@@ s@@ address > ▁ < amount > ▁ [ comment ] ▁ [ comment - to ] \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ ro@@ unded ▁ to ▁ the ▁ nearest ▁ 0.@@ 0000000@@ 1" + Help@@ Re@@ qu@@ ir@@ ing@@ P@@ as@@ sp@@ hr@@ ase ( ) ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID@@ _ADD@@ RESS_@@ OR_@@ KEY , " Invalid ▁ I@@ Lo@@ ve@@ You@@ Co@@ ins ▁ address " ) ; int64 n@@ Amount = Amo@@ unt@@ From@@ Value ( params [ 1 ] ) ; CWalletTx wtx ; if ( params . size ( ) > 2 && params [ 2 ] . type ( ) != null@@ _type && ! params [ 2 ] . get_str ( ) . empty ( ) ) wtx . map@@ Value [ " comment " ] = params [ 2 ] . get_str ( ) ; if ( params . size ( ) > 3 && params [ 3 ] . type ( ) != null@@ _type && ! params [ 3 ] . get_str ( ) . empty ( ) ) wtx . map@@ Value [ " to " ] = params [ 3 ] . get_str ( ) ; En@@ sure@@ Wallet@@ Is@@ Unlock@@ ed ( ) ; string str@@ Error = pw@@ all@@ et@@ Main -> Send@@ M@@ one@@ yTo@@ Destination ( address . Get ( ) , n@@ Amount , wtx ) ; if ( str@@ Error != " " ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ ERROR , str@@ Error ) ; return wtx . GetHash ( ) . Get@@ Hex ( ) ; }
Value list@@ address@@ group@@ ings ( const Array & params , bool f@@ Help ) { if ( f@@ Help ) throw runtime_error ( " list@@ address@@ group@@ ings \n " " Lists ▁ groups ▁ of ▁ addresses ▁ wh@@ ic@@ h ▁ have ▁ ha@@ d ▁ the@@ ir ▁ common ▁ ownership \n " " ma@@ de ▁ public ▁ by ▁ common ▁ use ▁ as ▁ inputs ▁ or ▁ as ▁ the ▁ result@@ ing ▁ change \n " " in ▁ p@@ ast ▁ trans@@ actions " ) ; Array json@@ Group@@ ings ; map < CTxDestination , int64 > bal@@ an@@ ces = pw@@ all@@ et@@ Main -> Get@@ Address@@ B@@ al@@ an@@ ces ( ) ; BOOST_FOREACH ( set < CTxDestination > group@@ ing , pw@@ all@@ et@@ Main -> Get@@ Address@@ Group@@ ings ( ) ) { Array json@@ Group@@ ing ; BOOST_FOREACH ( CTxDestination address , group@@ ing ) { Array address@@ Info ; address@@ Info . push_back ( CBitcoinAddress ( address ) . ToString ( ) ) ; address@@ Info . push_back ( Value@@ From@@ Amount ( bal@@ an@@ ces [ address ] ) ) ; { LOCK ( pw@@ all@@ et@@ Main -> cs_@@ wallet ) ; if ( pw@@ all@@ et@@ Main -> mapAddress@@ Book . find ( CBitcoinAddress ( address ) . Get ( ) ) != pw@@ all@@ et@@ Main -> mapAddress@@ Book . end ( ) ) address@@ Info . push_back ( pw@@ all@@ et@@ Main -> mapAddress@@ Book . find ( CBitcoinAddress ( address ) . Get ( ) ) -> second ) ; } json@@ Group@@ ing . push_back ( address@@ Info ) ; } json@@ Group@@ ings . push_back ( json@@ Group@@ ing ) ; } return json@@ Group@@ ings ; }
Value sign@@ message ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) != 2 ) throw runtime_error ( " sign@@ message ▁ < ilo@@ vey@@ ou@@ coin@@ s@@ address > ▁ < message > \n " " Sign ▁ a ▁ message ▁ with ▁ the ▁ private ▁ key ▁ of ▁ an ▁ address " ) ; En@@ sure@@ Wallet@@ Is@@ Unlock@@ ed ( ) ; string strAddress = params [ 0 ] . get_str ( ) ; string str@@ Message = params [ 1 ] . get_str ( ) ; CBitcoinAddress addr ( strAddress ) ; if ( ! addr . IsValid ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ TYPE_@@ ERROR , " Invalid ▁ address " ) ; C@@ Key@@ ID key@@ ID ; if ( ! addr . GetKey@@ ID ( key@@ ID ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ TYPE_@@ ERROR , " Address ▁ does ▁ not ▁ ref@@ er ▁ to ▁ key " ) ; CKey key ; if ( ! pw@@ all@@ et@@ Main -> GetKey ( key@@ ID , key ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ ERROR , " Private ▁ key ▁ not ▁ available " ) ; CH@@ ash@@ Writer ss ( SER_@@ GE@@ TH@@ ASH , 0 ) ; ss << str@@ Message@@ Mag@@ ic ; ss << str@@ Message ; vector < unsigned char > vchSig ; if ( ! key . Sign@@ Comp@@ act ( ss . GetHash ( ) , vchSig ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID@@ _ADD@@ RESS_@@ OR_@@ KEY , " Sign ▁ failed " ) ; return Encode@@ Base@@ 64 ( & vchSig [ 0 ] , vchSig . size ( ) ) ; }
Value verify@@ message ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) != 3 ) throw runtime_error ( " verify@@ message ▁ < ilo@@ vey@@ ou@@ coin@@ s@@ address > ▁ < sign@@ ature > ▁ < message > \n " " Verify ▁ a ▁ signed ▁ message " ) ; string strAddress = params [ 0 ] . get_str ( ) ; string str@@ Sign = params [ 1 ] . get_str ( ) ; string str@@ Message = params [ 2 ] . get_str ( ) ; CBitcoinAddress addr ( strAddress ) ; if ( ! addr . IsValid ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ TYPE_@@ ERROR , " Invalid ▁ address " ) ; C@@ Key@@ ID key@@ ID ; if ( ! addr . GetKey@@ ID ( key@@ ID ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ TYPE_@@ ERROR , " Address ▁ does ▁ not ▁ ref@@ er ▁ to ▁ key " ) ; bool f@@ Invalid = false ; vector < unsigned char > vchSig = Deco@@ de@@ Base@@ 64 ( str@@ Sign . c_str ( ) , & f@@ Invalid ) ; if ( f@@ Invalid ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID@@ _ADD@@ RESS_@@ OR_@@ KEY , " Malform@@ ed ▁ base64 ▁ encoding " ) ; CH@@ ash@@ Writer ss ( SER_@@ GE@@ TH@@ ASH , 0 ) ; ss << str@@ Message@@ Mag@@ ic ; ss << str@@ Message ; CP@@ ub@@ Key p@@ ub@@ key ; if ( ! p@@ ub@@ key . Rec@@ over@@ Comp@@ act ( ss . GetHash ( ) , vchSig ) ) return false ; return ( p@@ ub@@ key . GetID ( ) == key@@ ID ) ; }
Value get@@ recei@@ ved@@ by@@ address ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " get@@ recei@@ ved@@ by@@ address ▁ < ilo@@ vey@@ ou@@ coin@@ s@@ address > ▁ [ min@@ conf = 1 ] \n " " Retur@@ ns ▁ the ▁ total ▁ amount ▁ received ▁ by ▁ < ilo@@ vey@@ ou@@ coin@@ s@@ address > ▁ in ▁ trans@@ actions ▁ with ▁ at ▁ le@@ ast ▁ [ min@@ conf ] ▁ confirm@@ ations . " ) ; CBitcoinAddress address = CBitcoinAddress ( params [ 0 ] . get_str ( ) ) ; CScript scriptPubKey ; if ( ! address . IsValid ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID@@ _ADD@@ RESS_@@ OR_@@ KEY , " Invalid ▁ I@@ Lo@@ ve@@ You@@ Co@@ ins ▁ address " ) ; scriptPubKey . Set@@ Destination ( address . Get ( ) ) ; if ( ! IsMine ( * pw@@ all@@ et@@ Main , scriptPubKey ) ) return ( double ) 0.0 ; int nMin@@ Depth = 1 ; if ( params . size ( ) > 1 ) nMin@@ Depth = params [ 1 ] . get_int ( ) ; int64 n@@ Amount = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pw@@ all@@ et@@ Main -> mapWallet . begin ( ) ; it != pw@@ all@@ et@@ Main -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . Is@@ Co@@ in@@ Base ( ) || wtx . Is@@ Co@@ in@@ St@@ a@@ ke ( ) || ! wtx . Is@@ Final ( ) ) continue ; BOOST_FOREACH ( const CTx@@ Out & tx@@ out , wtx . vout ) if ( tx@@ out . scriptPubKey == scriptPubKey ) if ( wtx . Get@@ Depth@@ In@@ Main@@ Chain ( ) >= nMin@@ Depth ) n@@ Amount += tx@@ out . nValue ; } return Value@@ From@@ Amount ( n@@ Amount ) ; }
void Get@@ Account@@ Addresses ( string strAccount , set < CTxDestination > & setAddress ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , string ) & item , pw@@ all@@ et@@ Main -> mapAddress@@ Book ) { const CTxDestination & address = item . first ; const string & strName = item . second ; if ( strName == strAccount ) setAddress . insert ( address ) ; } }
Value get@@ recei@@ ved@@ by@@ account ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " get@@ recei@@ ved@@ by@@ account ▁ < account > ▁ [ min@@ conf = 1 ] \n " " Retur@@ ns ▁ the ▁ total ▁ amount ▁ received ▁ by ▁ addresses ▁ with ▁ < account > ▁ in ▁ trans@@ actions ▁ with ▁ at ▁ le@@ ast ▁ [ min@@ conf ] ▁ confirm@@ ations . " ) ; int nMin@@ Depth = 1 ; if ( params . size ( ) > 1 ) nMin@@ Depth = params [ 1 ] . get_int ( ) ; string strAccount = Account@@ From@@ Value ( params [ 0 ] ) ; set < CTxDestination > setAddress ; Get@@ Account@@ Addresses ( strAccount , setAddress ) ; int64 n@@ Amount = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pw@@ all@@ et@@ Main -> mapWallet . begin ( ) ; it != pw@@ all@@ et@@ Main -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . Is@@ Co@@ in@@ Base ( ) || wtx . Is@@ Co@@ in@@ St@@ a@@ ke ( ) || ! wtx . Is@@ Final ( ) ) continue ; BOOST_FOREACH ( const CTx@@ Out & tx@@ out , wtx . vout ) { CTxDestination address ; if ( ExtractDestination ( tx@@ out . scriptPubKey , address ) && IsMine ( * pw@@ all@@ et@@ Main , address ) && setAddress . count ( address ) ) if ( wtx . Get@@ Depth@@ In@@ Main@@ Chain ( ) >= nMin@@ Depth ) n@@ Amount += tx@@ out . nValue ; } } return ( double ) n@@ Amount / ( double ) CO@@ IN ; }
int64 Get@@ Account@@ B@@ al@@ ance ( CWalletDB & wall@@ et@@ db , const string & strAccount , int nMin@@ Depth ) { int64 n@@ B@@ al@@ ance = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pw@@ all@@ et@@ Main -> mapWallet . begin ( ) ; it != pw@@ all@@ et@@ Main -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . Is@@ Final ( ) ) continue ; int64 n@@ Received , n@@ Sent , n@@ Fee ; wtx . Get@@ Account@@ Amo@@ un@@ ts ( strAccount , n@@ Received , n@@ Sent , n@@ Fee ) ; if ( n@@ Received != 0 && wtx . Get@@ Depth@@ In@@ Main@@ Chain ( ) >= nMin@@ Depth ) n@@ B@@ al@@ ance += n@@ Received ; n@@ B@@ al@@ ance -= n@@ Sent + n@@ Fee ; } n@@ B@@ al@@ ance += wall@@ et@@ db . GetAccountCreditDebit ( strAccount ) ; return n@@ B@@ al@@ ance ; }
int64 Get@@ Account@@ B@@ al@@ ance ( const string & strAccount , int nMin@@ Depth ) { CWalletDB wall@@ et@@ db ( pw@@ all@@ et@@ Main -> strWalletFile ) ; return Get@@ Account@@ B@@ al@@ ance ( wall@@ et@@ db , strAccount , nMin@@ Depth ) ; }
Value get@@ bal@@ ance ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 2 ) throw runtime_error ( " get@@ bal@@ ance ▁ [ account ] ▁ [ min@@ conf = 1 ] \n " " If ▁ [ account ] ▁ is ▁ not ▁ specified , ▁ returns ▁ the ▁ server ' s ▁ total ▁ available ▁ bal@@ ance . \n " " If ▁ [ account ] ▁ is ▁ specified , ▁ returns ▁ the ▁ bal@@ ance ▁ in ▁ the ▁ account . " ) ; if ( params . size ( ) == 0 ) return Value@@ From@@ Amount ( pw@@ all@@ et@@ Main -> GetB@@ al@@ ance ( ) ) ; int nMin@@ Depth = 1 ; if ( params . size ( ) > 1 ) nMin@@ Depth = params [ 1 ] . get_int ( ) ; if ( params [ 0 ] . get_str ( ) == " * " ) { int64 n@@ B@@ al@@ ance = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pw@@ all@@ et@@ Main -> mapWallet . begin ( ) ; it != pw@@ all@@ et@@ Main -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . IsConfirm@@ ed ( ) ) continue ; int64 all@@ Fee ; string str@@ S@@ ent@@ Account ; list < pair < CTxDestination , int64 > > list@@ Received ; list < pair < CTxDestination , int64 > > list@@ Sent ; wtx . Get@@ Amo@@ un@@ ts ( list@@ Received , list@@ Sent , all@@ Fee , str@@ S@@ ent@@ Account ) ; if ( wtx . Get@@ Depth@@ In@@ Main@@ Chain ( ) >= nMin@@ Depth ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , list@@ Received ) n@@ B@@ al@@ ance += r . second ; } BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , list@@ Sent ) n@@ B@@ al@@ ance -= r . second ; n@@ B@@ al@@ ance -= all@@ Fee ; } return Value@@ From@@ Amount ( n@@ B@@ al@@ ance ) ; } string strAccount = Account@@ From@@ Value ( params [ 0 ] ) ; int64 n@@ B@@ al@@ ance = Get@@ Account@@ B@@ al@@ ance ( strAccount , nMin@@ Depth ) ; return Value@@ From@@ Amount ( n@@ B@@ al@@ ance ) ; }
Value get@@ un@@ confirm@@ ed@@ bal@@ ance ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 0 ) throw runtime_error ( " get@@ un@@ confirm@@ ed@@ bal@@ ance \n " " Retur@@ ns ▁ the ▁ server ' s ▁ total ▁ un@@ confirmed ▁ bal@@ ance \n " ) ; return Value@@ From@@ Amount ( pw@@ all@@ et@@ Main -> Get@@ Un@@ confirm@@ ed@@ B@@ al@@ ance ( ) ) ; }
Value movec@@ md ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 3 || params . size ( ) > 5 ) throw runtime_error ( " move ▁ < from@@ account > ▁ < to@@ account > ▁ < amount > ▁ [ min@@ conf = 1 ] ▁ [ comment ] \n " " Move ▁ from ▁ one ▁ account ▁ in ▁ your ▁ wallet ▁ to ▁ an@@ other . " ) ; string str@@ From = Account@@ From@@ Value ( params [ 0 ] ) ; string str@@ To = Account@@ From@@ Value ( params [ 1 ] ) ; int64 n@@ Amount = Amo@@ unt@@ From@@ Value ( params [ 2 ] ) ; if ( params . size ( ) > 3 ) ( void ) params [ 3 ] . get_int ( ) ; string str@@ Comm@@ ent ; if ( params . size ( ) > 4 ) str@@ Comm@@ ent = params [ 4 ] . get_str ( ) ; CWalletDB wall@@ et@@ db ( pw@@ all@@ et@@ Main -> strWalletFile ) ; if ( ! wall@@ et@@ db . Tx@@ n@@ Begin ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ DAT@@ AB@@ AS@@ E_@@ ERROR , " database ▁ error " ) ; int64 n@@ Now = Get@@ Adjust@@ ed@@ Time ( ) ; CAccountingEntry de@@ bit ; de@@ bit . n@@ Or@@ der@@ Pos = pw@@ all@@ et@@ Main -> In@@ c@@ Or@@ der@@ Pos@@ Next ( & wall@@ et@@ db ) ; de@@ bit . strAccount = str@@ From ; de@@ bit . nCreditDebit = - n@@ Amount ; de@@ bit . nTime = n@@ Now ; de@@ bit . str@@ Other@@ Account = str@@ To ; de@@ bit . str@@ Comm@@ ent = str@@ Comm@@ ent ; wall@@ et@@ db . WriteAccountingEntry ( de@@ bit ) ; CAccountingEntry cre@@ di@@ t ; cre@@ di@@ t . n@@ Or@@ der@@ Pos = pw@@ all@@ et@@ Main -> In@@ c@@ Or@@ der@@ Pos@@ Next ( & wall@@ et@@ db ) ; cre@@ di@@ t . strAccount = str@@ To ; cre@@ di@@ t . nCreditDebit = n@@ Amount ; cre@@ di@@ t . nTime = n@@ Now ; cre@@ di@@ t . str@@ Other@@ Account = str@@ From ; cre@@ di@@ t . str@@ Comm@@ ent = str@@ Comm@@ ent ; wall@@ et@@ db . WriteAccountingEntry ( cre@@ di@@ t ) ; if ( ! wall@@ et@@ db . Tx@@ n@@ Commit ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ DAT@@ AB@@ AS@@ E_@@ ERROR , " database ▁ error " ) ; return true ; }
Value send@@ from ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 3 || params . size ( ) > 6 ) throw runtime_error ( " send@@ from ▁ < from@@ account > ▁ < to@@ ilo@@ vey@@ ou@@ coin@@ s@@ address > ▁ < amount > ▁ [ min@@ conf = 1 ] ▁ [ comment ] ▁ [ comment - to ] \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ ro@@ unded ▁ to ▁ the ▁ nearest ▁ 0.@@ 0000000@@ 1" + Help@@ Re@@ qu@@ ir@@ ing@@ P@@ as@@ sp@@ hr@@ ase ( ) ) ; string strAccount = Account@@ From@@ Value ( params [ 0 ] ) ; CBitcoinAddress address ( params [ 1 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID@@ _ADD@@ RESS_@@ OR_@@ KEY , " Invalid ▁ I@@ Lo@@ ve@@ You@@ Co@@ ins ▁ address " ) ; int64 n@@ Amount = Amo@@ unt@@ From@@ Value ( params [ 2 ] ) ; int nMin@@ Depth = 1 ; if ( params . size ( ) > 3 ) nMin@@ Depth = params [ 3 ] . get_int ( ) ; CWalletTx wtx ; wtx . strFromAccount = strAccount ; if ( params . size ( ) > 4 && params [ 4 ] . type ( ) != null@@ _type && ! params [ 4 ] . get_str ( ) . empty ( ) ) wtx . map@@ Value [ " comment " ] = params [ 4 ] . get_str ( ) ; if ( params . size ( ) > 5 && params [ 5 ] . type ( ) != null@@ _type && ! params [ 5 ] . get_str ( ) . empty ( ) ) wtx . map@@ Value [ " to " ] = params [ 5 ] . get_str ( ) ; En@@ sure@@ Wallet@@ Is@@ Unlock@@ ed ( ) ; int64 n@@ B@@ al@@ ance = Get@@ Account@@ B@@ al@@ ance ( strAccount , nMin@@ Depth ) ; if ( n@@ Amount > n@@ B@@ al@@ ance ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ IN@@ SU@@ FF@@ IC@@ I@@ ENT_@@ FUN@@ DS , " Account ▁ has ▁ in@@ su@@ ffi@@ ci@@ ent ▁ fun@@ ds " ) ; string str@@ Error = pw@@ all@@ et@@ Main -> Send@@ M@@ one@@ yTo@@ Destination ( address . Get ( ) , n@@ Amount , wtx ) ; if ( str@@ Error != " " ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ ERROR , str@@ Error ) ; return wtx . GetHash ( ) . Get@@ Hex ( ) ; }
Value send@@ m@@ any ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 2 || params . size ( ) > 4 ) throw runtime_error ( " send@@ m@@ any ▁ < from@@ account > ▁ { address : amount , . . . } ▁ [ min@@ conf = 1 ] ▁ [ comment ] \n " " am@@ oun@@ ts ▁ are ▁ double - precision ▁ float@@ ing ▁ point ▁ numbers " + Help@@ Re@@ qu@@ ir@@ ing@@ P@@ as@@ sp@@ hr@@ ase ( ) ) ; string strAccount = Account@@ From@@ Value ( params [ 0 ] ) ; Object send@@ To = params [ 1 ] . get_@@ obj ( ) ; int nMin@@ Depth = 1 ; if ( params . size ( ) > 2 ) nMin@@ Depth = params [ 2 ] . get_int ( ) ; CWalletTx wtx ; wtx . strFromAccount = strAccount ; if ( params . size ( ) > 3 && params [ 3 ] . type ( ) != null@@ _type && ! params [ 3 ] . get_str ( ) . empty ( ) ) wtx . map@@ Value [ " comment " ] = params [ 3 ] . get_str ( ) ; set < CBitcoinAddress > setAddress ; vector < pair < CScript , int64 > > vec@@ Send ; int64 total@@ Amount = 0 ; BOOST_FOREACH ( const Pair & s , send@@ To ) { CBitcoinAddress address ( s . name_ ) ; if ( ! address . IsValid ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID@@ _ADD@@ RESS_@@ OR_@@ KEY , string ( " Invalid ▁ I@@ Lo@@ ve@@ You@@ Co@@ ins ▁ address : ▁ " ) + s . name_ ) ; if ( setAddress . count ( address ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID_@@ PARAME@@ TER , string ( " Invalid ▁ parameter , ▁ dup@@ lic@@ ated ▁ address : ▁ " ) + s . name_ ) ; setAddress . insert ( address ) ; CScript scriptPubKey ; scriptPubKey . Set@@ Destination ( address . Get ( ) ) ; int64 n@@ Amount = Amo@@ unt@@ From@@ Value ( s . value@@ _ ) ; total@@ Amount += n@@ Amount ; vec@@ Send . push_back ( make_pair ( scriptPubKey , n@@ Amount ) ) ; } En@@ sure@@ Wallet@@ Is@@ Unlock@@ ed ( ) ; int64 n@@ B@@ al@@ ance = Get@@ Account@@ B@@ al@@ ance ( strAccount , nMin@@ Depth ) ; if ( total@@ Amount > n@@ B@@ al@@ ance ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ IN@@ SU@@ FF@@ IC@@ I@@ ENT_@@ FUN@@ DS , " Account ▁ has ▁ in@@ su@@ ffi@@ ci@@ ent ▁ fun@@ ds " ) ; C@@ Reser@@ ve@@ Key key@@ Change ( pw@@ all@@ et@@ Main ) ; int64 n@@ Fe@@ e@@ Required = 0 ; string str@@ Fail@@ Reason ; bool f@@ Created = pw@@ all@@ et@@ Main -> Create@@ Transaction ( vec@@ Send , wtx , key@@ Change , n@@ Fe@@ e@@ Required , str@@ Fail@@ Reason ) ; if ( ! f@@ Created ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ IN@@ SU@@ FF@@ IC@@ I@@ ENT_@@ FUN@@ DS , str@@ Fail@@ Reason ) ; if ( ! pw@@ all@@ et@@ Main -> Comm@@ it@@ Transaction ( wtx , key@@ Change ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ ERROR , " Transaction ▁ comm@@ it ▁ failed " ) ; return wtx . GetHash ( ) . Get@@ Hex ( ) ; }
static CScript _@@ create@@ multisig ( const Array & params ) { int nRequired = params [ 0 ] . get_int ( ) ; const Array & keys = params [ 1 ] . get_array ( ) ; if ( nRequired < 1 ) throw runtime_error ( " a ▁ multi@@ sign@@ ature ▁ address ▁ must ▁ require ▁ at ▁ le@@ ast ▁ one ▁ key ▁ to ▁ re@@ de@@ em " ) ; if ( ( int ) keys . size ( ) < nRequired ) throw runtime_error ( strprintf ( " not ▁ enough ▁ keys ▁ sup@@ p@@ lied ▁ " " ( got ▁ % " PR@@ Is@@ zu " ▁ keys , ▁ bu@@ t ▁ need ▁ at ▁ le@@ ast ▁ % d ▁ to ▁ re@@ de@@ em ) " , keys . size ( ) , nRequired ) ) ; std :: vector < CP@@ ub@@ Key > p@@ ub@@ keys ; p@@ ub@@ keys . resize ( keys . size ( ) ) ; for ( unsigned int i = 0 ; i < keys . size ( ) ; i ++ ) { const std :: string & ks = keys [ i ] . get_str ( ) ; CBitcoinAddress address ( ks ) ; if ( pw@@ all@@ et@@ Main && address . IsValid ( ) ) { C@@ Key@@ ID key@@ ID ; if ( ! address . GetKey@@ ID ( key@@ ID ) ) throw runtime_error ( strprintf ( " % s ▁ does ▁ not ▁ ref@@ er ▁ to ▁ a ▁ key " , ks . c_str ( ) ) ) ; CP@@ ub@@ Key vchPubKey ; if ( ! pw@@ all@@ et@@ Main -> GetPubKey ( key@@ ID , vchPubKey ) ) throw runtime_error ( strprintf ( " no ▁ full ▁ public ▁ key ▁ for ▁ address ▁ % s " , ks . c_str ( ) ) ) ; if ( ! vchPubKey . Is@@ Ful@@ ly@@ Valid ( ) ) throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; p@@ ub@@ keys [ i ] = vchPubKey ; } else if ( Is@@ Hex ( ks ) ) { CP@@ ub@@ Key vchPubKey ( ParseHex ( ks ) ) ; if ( ! vchPubKey . Is@@ Ful@@ ly@@ Valid ( ) ) throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; p@@ ub@@ keys [ i ] = vchPubKey ; } else { throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; } } CScript result ; result . Set@@ Multi@@ sig ( nRequired , p@@ ub@@ keys ) ; return result ; }
Value addmultisigaddress ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 2 || params . size ( ) > 3 ) { string msg = " addmultisigaddress ▁ < n@@ required > ▁ < ' [ \ " key \ " , \ " key \ " ] ' > ▁ [ account ] \n " " Add ▁ a ▁ n@@ required - to - sign ▁ multi@@ sign@@ ature ▁ address ▁ to ▁ the ▁ wall@@ et@@ \ " \ n " " each ▁ key ▁ is ▁ a ▁ I@@ Lo@@ ve@@ You@@ Co@@ ins ▁ address ▁ or ▁ hex - en@@ coded ▁ public ▁ key \ n " " If ▁ [ account ] ▁ is ▁ specified , ▁ assign ▁ address ▁ to ▁ [ account ] . " ; throw runtime_error ( msg ) ; } string strAccount ; if ( params . size ( ) > 2 ) strAccount = Account@@ From@@ Value ( params [ 2 ] ) ; CScript inner = _@@ create@@ multisig ( params ) ; C@@ Script@@ ID inner@@ ID = inner . GetID ( ) ; pw@@ all@@ et@@ Main -> Add@@ CScript ( inner ) ; pw@@ all@@ et@@ Main -> Set@@ Address@@ Book@@ Name ( inner@@ ID , strAccount ) ; return CBitcoinAddress ( inner@@ ID ) . ToString ( ) ; } Value create@@ multisig ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 2 || params . size ( ) > 2 ) { string msg = " create@@ multisig ▁ < n@@ required > ▁ < ' [ \ " key@@ \ " , \ " key@@ \ " ] ' > \ n " " Cre@@ ates ▁ a ▁ multi - sign@@ ature ▁ address ▁ and ▁ returns ▁ a ▁ json ▁ object \ n " " with ▁ keys : \ n " " address ▁ : ▁ ilo@@ vey@@ ou@@ coins ▁ address \ n " " re@@ de@@ em@@ Script ▁ : ▁ hex - en@@ coded ▁ re@@ de@@ mp@@ tion ▁ script " ; throw runtime_error ( msg ) ; } CScript inner = _@@ create@@ multisig ( params ) ; C@@ Script@@ ID inner@@ ID = inner . GetID ( ) ; CBitcoinAddress address ( inner@@ ID ) ; Object result ; result . push_back ( Pair ( " address " , address . ToString ( ) ) ) ; result . push_back ( Pair ( " re@@ de@@ em@@ Script " , Hex@@ Str ( inner . begin ( ) , inner . end ( ) ) ) ) ; return result ; } struct t@@ ally@@ item { int64 n@@ Amount ; int n@@ Conf ; vector < uint256 > tx@@ ids ; t@@ ally@@ item ( ) { n@@ Amount = 0 ; n@@ Conf = std :: numer@@ ic@@ _@@ limits < int > :: max ( ) ; } } ; Value List@@ Received ( const Array & params , bool f@@ By@@ Accounts ) { int nMin@@ Depth = 1 ; if ( params . size ( ) > 0 ) nMin@@ Depth = params [ 0 ] . get_int ( ) ; bool fIn@@ clude@@ Empty = false ; if ( params . size ( ) > 1 ) fIn@@ clude@@ Empty = params [ 1 ] . get_@@ bool ( ) ; map < CBitcoinAddress , t@@ ally@@ item > map@@ T@@ ally ; for ( map < uint256 , CWalletTx > :: iterator it = pw@@ all@@ et@@ Main -> mapWallet . begin ( ) ; it != pw@@ all@@ et@@ Main -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . Is@@ Co@@ in@@ Base ( ) || wtx . Is@@ Co@@ in@@ St@@ a@@ ke ( ) || ! wtx . Is@@ Final ( ) ) continue ; int n@@ Depth = wtx . Get@@ Depth@@ In@@ Main@@ Chain ( ) ; if ( n@@ Depth < nMin@@ Depth ) continue ; BOOST_FOREACH ( const CTx@@ Out & tx@@ out , wtx . vout ) { CTxDestination address ; if ( ! ExtractDestination ( tx@@ out . scriptPubKey , address ) || ! IsMine ( * pw@@ all@@ et@@ Main , address ) ) continue ; t@@ ally@@ item & item = map@@ T@@ ally [ address ] ; item . n@@ Amount += tx@@ out . nValue ; item . n@@ Conf = min ( item . n@@ Conf , n@@ Depth ) ; item . tx@@ ids . push_back ( wtx . GetHash ( ) ) ; } } Array ret ; map < string , t@@ ally@@ item > map@@ Account@@ T@@ ally ; BOOST_FOREACH ( const PAIRTYPE ( CBitcoinAddress , string ) & item , pw@@ all@@ et@@ Main -> mapAddress@@ Book ) { const CBitcoinAddress & address = item . first ; const string & strAccount = item . second ; map < CBitcoinAddress , t@@ ally@@ item > :: iterator it = map@@ T@@ ally . find ( address ) ; if ( it == map@@ T@@ ally . end ( ) && ! fIn@@ clude@@ Empty ) continue ; int64 n@@ Amount = 0 ; int n@@ Conf = std :: numer@@ ic@@ _@@ limits < int > :: max ( ) ; if ( it != map@@ T@@ ally . end ( ) ) { n@@ Amount = ( * it ) . second . n@@ Amount ; n@@ Conf = ( * it ) . second . n@@ Conf ; } if ( f@@ By@@ Accounts ) { t@@ ally@@ item & item = map@@ Account@@ T@@ ally [ strAccount ] ; item . n@@ Amount += n@@ Amount ; item . n@@ Conf = min ( item . n@@ Conf , n@@ Conf ) ; } else { Object obj ; obj . push_back ( Pair ( " address " , address . ToString ( ) ) ) ; obj . push_back ( Pair ( " account " , strAccount ) ) ; obj . push_back ( Pair ( " amount " , Value@@ From@@ Amount ( n@@ Amount ) ) ) ; obj . push_back ( Pair ( " confirm@@ ations " , ( n@@ Conf == std :: numer@@ ic@@ _@@ limits < int > :: max ( ) ? 0 : n@@ Conf ) ) ) ; Array trans@@ actions ; if ( it != map@@ T@@ ally . end ( ) ) { BOOST_FOREACH ( const uint256 & item , ( * it ) . second . tx@@ ids ) { trans@@ actions . push_back ( item . Get@@ Hex ( ) ) ; } } obj . push_back ( Pair ( " tx@@ ids " , trans@@ actions ) ) ; ret . push_back ( obj ) ; } } if ( f@@ By@@ Accounts ) { for ( map < string , t@@ ally@@ item > :: iterator it = map@@ Account@@ T@@ ally . begin ( ) ; it != map@@ Account@@ T@@ ally . end ( ) ; ++ it ) { int64 n@@ Amount = ( * it ) . second . n@@ Amount ; int n@@ Conf = ( * it ) . second . n@@ Conf ; Object obj ; obj . push_back ( Pair ( " account " , ( * it ) . first ) ) ; obj . push_back ( Pair ( " amount " , Value@@ From@@ Amount ( n@@ Amount ) ) ) ; obj . push_back ( Pair ( " confirm@@ ations " , ( n@@ Conf == std :: numer@@ ic@@ _@@ limits < int > :: max ( ) ? 0 : n@@ Conf ) ) ) ; ret . push_back ( obj ) ; } } return ret ; } Value list@@ recei@@ ved@@ by@@ address ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 2 ) throw runtime_error ( " list@@ recei@@ ved@@ by@@ address ▁ [ min@@ conf = 1 ] ▁ [ include@@ empty = false ] \ n " " [ min@@ conf ] ▁ is ▁ the ▁ min@@ im@@ um ▁ number ▁ of ▁ confirm@@ ations ▁ before ▁ pay@@ ments ▁ are ▁ inclu@@ ded . \ n " " [ include@@ empty ] ▁ wh@@ et@@ h@@ er ▁ to ▁ include ▁ addresses ▁ that ▁ have@@ n ' t ▁ received ▁ any ▁ pay@@ ments . \n " " Retur@@ ns ▁ an ▁ array ▁ of ▁ objects ▁ containing : \n " " ▁ ▁ \ " address@@ \ " ▁ : ▁ receiving ▁ address \n " " ▁ ▁ \ " ac@@ count@@ \ " ▁ : ▁ the ▁ account ▁ of ▁ the ▁ receiving ▁ address \n " " ▁ ▁ \ " am@@ o@@ unt@@ \ " ▁ : ▁ total ▁ amount ▁ received ▁ by ▁ the ▁ address \n " " ▁ ▁ \ " confirm@@ ation@@ s\ " ▁ : ▁ number ▁ of ▁ confirm@@ ations ▁ of ▁ the ▁ mo@@ st ▁ rec@@ ent ▁ transaction ▁ inclu@@ ded \n " " ▁ ▁ \ " tx@@ id@@ s\ " ▁ : ▁ list ▁ of ▁ trans@@ actions ▁ with ▁ output@@ s ▁ to ▁ the ▁ address \n " ) ; return List@@ Received ( params , false ) ; } Value list@@ recei@@ ved@@ by@@ account ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 2 ) throw runtime_error ( " list@@ recei@@ ved@@ by@@ account ▁ [ min@@ conf = 1 ] ▁ [ include@@ empty = false ] \n " " [ min@@ conf ] ▁ is ▁ the ▁ min@@ im@@ um ▁ number ▁ of ▁ confirm@@ ations ▁ before ▁ pay@@ ments ▁ are ▁ inclu@@ ded . \n " " [ include@@ empty ] ▁ wh@@ et@@ h@@ er ▁ to ▁ include ▁ ac@@ coun@@ ts ▁ that ▁ have@@ n ' t ▁ received ▁ any ▁ pay@@ ments . \ n " " Retur@@ ns ▁ an ▁ array ▁ of ▁ objects ▁ containing : \ n " " ▁ ▁ \ " ac@@ count@@ \ " ▁ : ▁ the ▁ account ▁ of ▁ the ▁ receiving ▁ addresses \ n " " ▁ ▁ \ " am@@ o@@ unt@@ \ " ▁ : ▁ total ▁ amount ▁ received ▁ by ▁ addresses ▁ with ▁ this ▁ account \ n " " ▁ ▁ \ " confirm@@ ation@@ s\ " ▁ : ▁ number ▁ of ▁ confirm@@ ations ▁ of ▁ the ▁ mo@@ st ▁ rec@@ ent ▁ transaction ▁ inclu@@ ded " ) ; return List@@ Received ( params , true ) ; } static void Ma@@ y@@ be@@ Push@@ Address ( Object & entry , const CTxDestination & dest ) { CBitcoinAddress addr ; if ( addr . Set ( dest ) ) entry . push_back ( Pair ( " address " , addr . ToString ( ) ) ) ; } void List@@ Transac@@ tions ( const CWalletTx & wtx , const string & strAccount , int nMin@@ Depth , bool f@@ Long , Array & ret ) { int64 n@@ Fee ; string str@@ S@@ ent@@ Account ; list < pair < CTxDestination , int64 > > list@@ Received ; list < pair < CTxDestination , int64 > > list@@ Sent ; wtx . Get@@ Amo@@ un@@ ts ( list@@ Received , list@@ Sent , n@@ Fee , str@@ S@@ ent@@ Account ) ; bool fAllAccounts = ( strAccount == string ( " * " ) ) ; if ( ! wtx . Is@@ Co@@ in@@ St@@ a@@ ke ( ) && ( ! list@@ Sent . empty ( ) || n@@ Fee != 0 ) && ( fAllAccounts || strAccount == str@@ S@@ ent@@ Account ) ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & s , list@@ Sent ) { Object entry ; entry . push_back ( Pair ( " account " , str@@ S@@ ent@@ Account ) ) ; Ma@@ y@@ be@@ Push@@ Address ( entry , s . first ) ; entry . push_back ( Pair ( " category " , " send " ) ) ; entry . push_back ( Pair ( " amount " , Value@@ From@@ Amount ( - s . second ) ) ) ; entry . push_back ( Pair ( " fe@@ e " , Value@@ From@@ Amount ( - n@@ Fee ) ) ) ; if ( f@@ Long ) Wallet@@ Tx@@ To@@ JS@@ ON ( wtx , entry ) ; ret . push_back ( entry ) ; } } if ( list@@ Received . size ( ) > 0 && wtx . Get@@ Depth@@ In@@ Main@@ Chain ( ) >= nMin@@ Depth ) { bool stop = false ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , list@@ Received ) { string account ; if ( pw@@ all@@ et@@ Main -> mapAddress@@ Book . count ( r . first ) ) account = pw@@ all@@ et@@ Main -> mapAddress@@ Book [ r . first ] ; if ( fAllAccounts || ( account == strAccount ) ) { Object entry ; entry . push_back ( Pair ( " account " , account ) ) ; Ma@@ y@@ be@@ Push@@ Address ( entry , r . first ) ; if ( wtx . Is@@ Co@@ in@@ Base ( ) || wtx . Is@@ Co@@ in@@ St@@ a@@ ke ( ) ) { if ( wtx . Get@@ Depth@@ In@@ Main@@ Chain ( ) < 1 ) entry . push_back ( Pair ( " category " , " orph@@ an " ) ) ; else if ( wtx . GetBlock@@ sTo@@ Mat@@ urity ( ) > 0 ) entry . push_back ( Pair ( " category " , " im@@ m@@ ature " ) ) ; else if ( wtx . Is@@ Co@@ in@@ St@@ a@@ ke ( ) ) entry . push_back ( Pair ( " category " , " st@@ a@@ ke " ) ) ; else entry . push_back ( Pair ( " category " , " generate " ) ) ; } else { entry . push_back ( Pair ( " category " , " receive " ) ) ; } if ( ! wtx . Is@@ Co@@ in@@ St@@ a@@ ke ( ) ) entry . push_back ( Pair ( " amount " , Value@@ From@@ Amount ( r . second ) ) ) ; else { entry . push_back ( Pair ( " amount " , Value@@ From@@ Amount ( - n@@ Fee ) ) ) ; stop = true ; } if ( f@@ Long ) Wallet@@ Tx@@ To@@ JS@@ ON ( wtx , entry ) ; ret . push_back ( entry ) ; } if ( stop ) break ; } } } void Ac@@ entry@@ To@@ JS@@ ON ( const CAccountingEntry & acentry , const string & strAccount , Array & ret ) { bool fAllAccounts = ( strAccount == string ( " * " ) ) ; if ( fAllAccounts || acentry . strAccount == strAccount ) { Object entry ; entry . push_back ( Pair ( " account " , acentry . strAccount ) ) ; entry . push_back ( Pair ( " category " , " move " ) ) ; entry . push_back ( Pair ( " time " , ( boost :: int64_t ) acentry . nTime ) ) ; entry . push_back ( Pair ( " amount " , Value@@ From@@ Amount ( acentry . nCreditDebit ) ) ) ; entry . push_back ( Pair ( " other@@ account " , acentry . str@@ Other@@ Account ) ) ; entry . push_back ( Pair ( " comment " , acentry . str@@ Comm@@ ent ) ) ; ret . push_back ( entry ) ; } } Value list@@ trans@@ actions ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 3 ) throw runtime_error ( " list@@ trans@@ actions ▁ [ account ] ▁ [ count = 10 ] ▁ [ from = 0 ] \ n " " Retur@@ ns ▁ up ▁ to ▁ [ count ] ▁ mo@@ st ▁ rec@@ ent ▁ trans@@ actions ▁ ski@@ pping ▁ the ▁ first ▁ [ from ] ▁ trans@@ actions ▁ for ▁ account ▁ [ account ] . " ) ; string strAccount = " * " ; if ( params . size ( ) > 0 ) strAccount = params [ 0 ] . get_str ( ) ; int n@@ Count = 10 ; if ( params . size ( ) > 1 ) n@@ Count = params [ 1 ] . get_int ( ) ; int n@@ From = 0 ; if ( params . size ( ) > 2 ) n@@ From = params [ 2 ] . get_int ( ) ; if ( n@@ Count < 0 ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID_@@ PARAME@@ TER , " Neg@@ ative ▁ count " ) ; if ( n@@ From < 0 ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID_@@ PARAME@@ TER , " Neg@@ ative ▁ from " ) ; Array ret ; std :: list < CAccountingEntry > ac@@ entries ; CWallet :: Tx@@ Items tx@@ Or@@ de@@ red = pw@@ all@@ et@@ Main -> Or@@ de@@ red@@ Tx@@ Items ( ac@@ entries , strAccount ) ; for ( CWallet :: Tx@@ Items :: reverse@@ _iterator it = tx@@ Or@@ de@@ red . r@@ begin ( ) ; it != tx@@ Or@@ de@@ red . ren@@ d ( ) ; ++ it ) { CWalletTx * const pw@@ tx = ( * it ) . second . first ; if ( pw@@ tx != 0 ) List@@ Transac@@ tions ( * pw@@ tx , strAccount , 0 , true , ret ) ; CAccountingEntry * const p@@ acentry = ( * it ) . second . second ; if ( p@@ acentry != 0 ) Ac@@ entry@@ To@@ JS@@ ON ( * p@@ acentry , strAccount , ret ) ; if ( ( int ) ret . size ( ) >= ( n@@ Count + n@@ From ) ) break ; } if ( n@@ From > ( int ) ret . size ( ) ) n@@ From = ret . size ( ) ; if ( ( n@@ From + n@@ Count ) > ( int ) ret . size ( ) ) n@@ Count = ret . size ( ) - n@@ From ; Array :: iterator first = ret . begin ( ) ; std :: advance ( first , n@@ From ) ; Array :: iterator last = ret . begin ( ) ; std :: advance ( last , n@@ From + n@@ Count ) ; if ( last != ret . end ( ) ) ret . erase ( last , ret . end ( ) ) ; if ( first != ret . begin ( ) ) ret . erase ( ret . begin ( ) , first ) ; std :: re@@ verse ( ret . begin ( ) , ret . end ( ) ) ; return ret ; } Value list@@ ac@@ coun@@ ts ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 1 ) throw runtime_error ( " list@@ ac@@ coun@@ ts ▁ [ min@@ conf = 1 ] \ n " " Retur@@ ns ▁ Object ▁ that ▁ has ▁ account ▁ names ▁ as ▁ keys , ▁ account ▁ bal@@ an@@ ces ▁ as ▁ values . " ) ; int nMin@@ Depth = 1 ; if ( params . size ( ) > 0 ) nMin@@ Depth = params [ 0 ] . get_int ( ) ; map < string , int64 > map@@ Account@@ B@@ al@@ an@@ ces ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , string ) & entry , pw@@ all@@ et@@ Main -> mapAddress@@ Book ) { if ( IsMine ( * pw@@ all@@ et@@ Main , entry . first ) ) map@@ Account@@ B@@ al@@ an@@ ces [ entry . second ] = 0 ; } for ( map < uint256 , CWalletTx > :: iterator it = pw@@ all@@ et@@ Main -> mapWallet . begin ( ) ; it != pw@@ all@@ et@@ Main -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; int64 n@@ Fee ; string str@@ S@@ ent@@ Account ; list < pair < CTxDestination , int64 > > list@@ Received ; list < pair < CTxDestination , int64 > > list@@ Sent ; wtx . Get@@ Amo@@ un@@ ts ( list@@ Received , list@@ Sent , n@@ Fee , str@@ S@@ ent@@ Account ) ; map@@ Account@@ B@@ al@@ an@@ ces [ str@@ S@@ ent@@ Account ] -= n@@ Fee ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & s , list@@ Sent ) map@@ Account@@ B@@ al@@ an@@ ces [ str@@ S@@ ent@@ Account ] -= s . second ; if ( wtx . Get@@ Depth@@ In@@ Main@@ Chain ( ) >= nMin@@ Depth ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , list@@ Received ) if ( pw@@ all@@ et@@ Main -> mapAddress@@ Book . count ( r . first ) ) map@@ Account@@ B@@ al@@ an@@ ces [ pw@@ all@@ et@@ Main -> mapAddress@@ Book [ r . first ] ] += r . second ; else map@@ Account@@ B@@ al@@ an@@ ces [ " " ] += r . second ; } } list < CAccountingEntry > ac@@ entries ; CWalletDB ( pw@@ all@@ et@@ Main -> strWalletFile ) . ListAccountCreditDebit ( " * " , ac@@ entries ) ; BOOST_FOREACH ( const CAccountingEntry & entry , ac@@ entries ) map@@ Account@@ B@@ al@@ an@@ ces [ entry . strAccount ] += entry . nCreditDebit ; Object ret ; BOOST_FOREACH ( const PAIRTYPE ( string , int64 ) & ac@@ count@@ B@@ al@@ ance , map@@ Account@@ B@@ al@@ an@@ ces ) { ret . push_back ( Pair ( ac@@ count@@ B@@ al@@ ance . first , Value@@ From@@ Amount ( ac@@ count@@ B@@ al@@ ance . second ) ) ) ; } return ret ; } Value list@@ sin@@ ce@@ block ( const Array & params , bool f@@ Help ) { if ( f@@ Help ) throw runtime_error ( " list@@ sin@@ ce@@ block ▁ [ block@@ hash ] ▁ [ target - confirm@@ ations ] \ n " " Get ▁ all ▁ trans@@ actions ▁ in ▁ block@@ s ▁ sin@@ ce ▁ block ▁ [ block@@ hash ] , ▁ or ▁ all ▁ trans@@ actions ▁ if ▁ om@@ it@@ ted " ) ; CBlockIndex * pindex = NULL ; int tar@@ get_@@ confi@@ r@@ ms = 1 ; if ( params . size ( ) > 0 ) { uint256 block@@ Id = 0 ; block@@ Id . Set@@ Hex ( params [ 0 ] . get_str ( ) ) ; pindex = C@@ Block@@ Loc@@ ator ( block@@ Id ) . Get@@ BlockIndex ( ) ; } if ( params . size ( ) > 1 ) { tar@@ get_@@ confi@@ r@@ ms = params [ 1 ] . get_int ( ) ; if ( tar@@ get_@@ confi@@ r@@ ms < 1 ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID_@@ PARAME@@ TER , " Invalid ▁ parameter " ) ; } int depth = pindex ? ( 1 + nBestHeight - pindex -> nHeight ) : - 1 ; Array trans@@ actions ; for ( map < uint256 , CWalletTx > :: iterator it = pw@@ all@@ et@@ Main -> mapWallet . begin ( ) ; it != pw@@ all@@ et@@ Main -> mapWallet . end ( ) ; it ++ ) { CWalletTx tx = ( * it ) . second ; if ( depth == - 1 || tx . Get@@ Depth@@ In@@ Main@@ Chain ( ) < depth ) List@@ Transac@@ tions ( tx , " * " , 0 , true , trans@@ actions ) ; } uint256 last@@ block ; if ( tar@@ get_@@ confi@@ r@@ ms == 1 ) { last@@ block = hashBestChain ; } else { int tar@@ get_@@ height = pindexBest -> nHeight + 1 - tar@@ get_@@ confi@@ r@@ ms ; CBlockIndex * block ; for ( block = pindexBest ; block && block -> nHeight > tar@@ get_@@ height ; block = block -> pprev ) { } last@@ block = block ? block -> GetBlockHash ( ) : 0 ; } Object ret ; ret . push_back ( Pair ( " trans@@ actions " , trans@@ actions ) ) ; ret . push_back ( Pair ( " last@@ block " , last@@ block . Get@@ Hex ( ) ) ) ; return ret ; } Value get@@ transaction ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) != 1 ) throw runtime_error ( " get@@ transaction ▁ < tx@@ id > \ n " " Get ▁ det@@ a@@ iled ▁ information ▁ about ▁ in - wallet ▁ transaction ▁ < tx@@ id > " ) ; uint256 hash ; hash . Set@@ Hex ( params [ 0 ] . get_str ( ) ) ; Object entry ; if ( ! pw@@ all@@ et@@ Main -> mapWallet . count ( hash ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ INVALID@@ _ADD@@ RESS_@@ OR_@@ KEY , " Invalid ▁ or ▁ non - wallet ▁ transaction ▁ id " ) ; const CWalletTx & wtx = pw@@ all@@ et@@ Main -> mapWallet [ hash ] ; int64 n@@ Cre@@ di@@ t = wtx . Get@@ Cre@@ di@@ t ( ) ; int64 n@@ De@@ bit = wtx . Get@@ De@@ bit ( ) ; int64 n@@ Net = n@@ Cre@@ di@@ t - n@@ De@@ bit ; int64 n@@ Fee = ( wtx . Is@@ From@@ M@@ e ( ) ? wtx . GetValue@@ Out ( ) - n@@ De@@ bit : 0 ) ; entry . push_back ( Pair ( " amount " , Value@@ From@@ Amount ( n@@ Net - n@@ Fee ) ) ) ; if ( wtx . Is@@ From@@ M@@ e ( ) ) entry . push_back ( Pair ( " fe@@ e " , Value@@ From@@ Amount ( n@@ Fee ) ) ) ; Wallet@@ Tx@@ To@@ JS@@ ON ( wtx , entry ) ; Array details ; List@@ Transac@@ tions ( wtx , " * " , 0 , false , details ) ; entry . push_back ( Pair ( " details " , details ) ) ; return entry ; } Value back@@ up@@ wallet ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) != 1 ) throw runtime_error ( " back@@ up@@ wallet ▁ < destination > \ n " " S@@ af@@ el@@ y ▁ cop@@ ies ▁ wallet . dat ▁ to ▁ destination , ▁ wh@@ ic@@ h ▁ can ▁ be ▁ a ▁ directory ▁ or ▁ a ▁ path ▁ with ▁ filename . " ) ; string strDest = params [ 0 ] . get_str ( ) ; if ( ! BackupWallet ( * pw@@ all@@ et@@ Main , strDest ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ ERROR , " Error : ▁ Wallet ▁ back@@ up ▁ failed ! " ) ; return Value :: null ; } Value ke@@ ypo@@ ol@@ re@@ fill ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 0 ) throw runtime_error ( " ke@@ ypo@@ ol@@ re@@ fill \ n " " Fil@@ ls ▁ the ▁ ke@@ ypo@@ ol . " + Help@@ Re@@ qu@@ ir@@ ing@@ P@@ as@@ sp@@ hr@@ ase ( ) ) ; En@@ sure@@ Wallet@@ Is@@ Unlock@@ ed ( ) ; pw@@ all@@ et@@ Main -> Top@@ Up@@ Key@@ Pool ( ) ; if ( pw@@ all@@ et@@ Main -> GetKey@@ Pool@@ Size ( ) < Get@@ Arg ( " - ke@@ ypo@@ ol " , 100 ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ ERROR , " Error ▁ refresh@@ ing ▁ ke@@ ypo@@ ol . " ) ; return Value :: null ; } void Thread@@ Top@@ Up@@ Key@@ Pool ( void * parg ) { Rename@@ Thread ( " ilo@@ vey@@ ou@@ coins - key - top " ) ; pw@@ all@@ et@@ Main -> Top@@ Up@@ Key@@ Pool ( ) ; } void Thread@@ Cle@@ an@@ Wallet@@ P@@ as@@ sp@@ hr@@ ase ( void * parg ) { Rename@@ Thread ( " ilo@@ vey@@ ou@@ coins - lock - w@@ a " ) ; int64 n@@ My@@ Wa@@ ke@@ Time = GetTimeMillis ( ) + * ( ( int64 * ) parg ) * 1000 ; ENT@@ ER@@ _C@@ RI@@ TIC@@ AL_@@ SECTION ( cs_@@ nWallet@@ Unlock@@ Time ) ; if ( nWallet@@ Unlock@@ Time == 0 ) { nWallet@@ Unlock@@ Time = n@@ My@@ Wa@@ ke@@ Time ; do { if ( nWallet@@ Unlock@@ Time == 0 ) break ; int64 n@@ To@@ Sleep = nWallet@@ Unlock@@ Time - GetTimeMillis ( ) ; if ( n@@ To@@ Sleep <= 0 ) break ; LEAV@@ E_@@ CRITIC@@ AL_@@ SECTION ( cs_@@ nWallet@@ Unlock@@ Time ) ; Milli@@ Sleep ( n@@ To@@ Sleep ) ; ENT@@ ER@@ _C@@ RI@@ TIC@@ AL_@@ SECTION ( cs_@@ nWallet@@ Unlock@@ Time ) ; } while ( 1 ) ; if ( nWallet@@ Unlock@@ Time ) { nWallet@@ Unlock@@ Time = 0 ; pw@@ all@@ et@@ Main -> Lock ( ) ; } } else { if ( nWallet@@ Unlock@@ Time < n@@ My@@ Wa@@ ke@@ Time ) nWallet@@ Unlock@@ Time = n@@ My@@ Wa@@ ke@@ Time ; } LEAV@@ E_@@ CRITIC@@ AL_@@ SECTION ( cs_@@ nWallet@@ Unlock@@ Time ) ; delete ( int64 * ) parg ; } Value wall@@ et@@ pas@@ sp@@ hr@@ ase ( const Array & params , bool f@@ Help ) { if ( pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) && ( f@@ Help || params . size ( ) < 2 || params . size ( ) > 3 ) ) throw runtime_error ( " wall@@ et@@ pas@@ sp@@ hr@@ ase ▁ < pas@@ sp@@ hr@@ ase > ▁ < timeout > ▁ [ st@@ ak@@ ing@@ only ] \ n " " St@@ o@@ res ▁ the ▁ wallet ▁ decryp@@ tion ▁ key ▁ in ▁ memory ▁ for ▁ < timeout > ▁ seconds . \ n " " if ▁ [ st@@ ak@@ ing@@ only ] ▁ is ▁ true ▁ sending ▁ functions ▁ are ▁ dis@@ abled . " ) ; if ( f@@ Help ) return true ; if ( ! pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ WRO@@ NG_@@ EN@@ C@@ _STATE , " Error : ▁ running ▁ with ▁ an ▁ un@@ encryp@@ ted ▁ wallet , ▁ bu@@ t ▁ wall@@ et@@ pas@@ sp@@ hr@@ ase ▁ was ▁ called . " ) ; if ( ! pw@@ all@@ et@@ Main -> Is@@ Locked ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ AL@@ READ@@ Y_@@ UN@@ LOC@@ KED , " Error : ▁ Wallet ▁ is ▁ already ▁ un@@ lock@@ ed . " ) ; Sec@@ ure@@ String strWallet@@ Pass ; strWallet@@ Pass . reserve ( 100 ) ; strWallet@@ Pass = params [ 0 ] . get_str ( ) . c_str ( ) ; if ( strWallet@@ Pass . length ( ) > 0 ) { if ( ! pw@@ all@@ et@@ Main -> Unlock ( strWallet@@ Pass ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ PAS@@ SP@@ H@@ RAS@@ E_@@ IN@@ COR@@ RECT , " Error : ▁ The ▁ wallet ▁ pas@@ sp@@ hr@@ ase ▁ entered ▁ was ▁ incorrect . " ) ; } else throw runtime_error ( " wall@@ et@@ pas@@ sp@@ hr@@ ase ▁ < pas@@ sp@@ hr@@ ase > ▁ < timeout > \ n " " St@@ o@@ res ▁ the ▁ wallet ▁ decryp@@ tion ▁ key ▁ in ▁ memory ▁ for ▁ < timeout > ▁ seconds . " ) ; New@@ Thread ( Thread@@ Top@@ Up@@ Key@@ Pool , NULL ) ; int64 * p@@ n@@ Sle@@ ep@@ Time = new int64 ( params [ 1 ] . get_@@ int64 ( ) ) ; New@@ Thread ( Thread@@ Cle@@ an@@ Wallet@@ P@@ as@@ sp@@ hr@@ ase , p@@ n@@ Sle@@ ep@@ Time ) ; if ( params . size ( ) > 2 ) f@@ Wallet@@ Unlock@@ St@@ ak@@ ing@@ Only = params [ 2 ] . get_@@ bool ( ) ; else f@@ Wallet@@ Unlock@@ St@@ ak@@ ing@@ Only = false ; return Value :: null ; } Value wall@@ et@@ pas@@ sp@@ hr@@ as@@ ec@@ h@@ ange ( const Array & params , bool f@@ Help ) { if ( pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) && ( f@@ Help || params . size ( ) != 2 ) ) throw runtime_error ( " wall@@ et@@ pas@@ sp@@ hr@@ as@@ ec@@ h@@ ange ▁ < old@@ pas@@ sp@@ hr@@ ase > ▁ < new@@ pas@@ sp@@ hr@@ ase > \ n " " Chang@@ es ▁ the ▁ wallet ▁ pas@@ sp@@ hr@@ ase ▁ from ▁ < old@@ pas@@ sp@@ hr@@ ase > ▁ to ▁ < new@@ pas@@ sp@@ hr@@ ase > . " ) ; if ( f@@ Help ) return true ; if ( ! pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ WRO@@ NG_@@ EN@@ C@@ _STATE , " Error : ▁ running ▁ with ▁ an ▁ un@@ encryp@@ ted ▁ wallet , ▁ bu@@ t ▁ wall@@ et@@ pas@@ sp@@ hr@@ as@@ ec@@ h@@ ange ▁ was ▁ called . " ) ; Sec@@ ure@@ String str@@ Old@@ Wallet@@ Pass ; str@@ Old@@ Wallet@@ Pass . reserve ( 100 ) ; str@@ Old@@ Wallet@@ Pass = params [ 0 ] . get_str ( ) . c_str ( ) ; Sec@@ ure@@ String str@@ New@@ Wallet@@ Pass ; str@@ New@@ Wallet@@ Pass . reserve ( 100 ) ; str@@ New@@ Wallet@@ Pass = params [ 1 ] . get_str ( ) . c_str ( ) ; if ( str@@ Old@@ Wallet@@ Pass . length ( ) < 1 || str@@ New@@ Wallet@@ Pass . length ( ) < 1 ) throw runtime_error ( " wall@@ et@@ pas@@ sp@@ hr@@ as@@ ec@@ h@@ ange ▁ < old@@ pas@@ sp@@ hr@@ ase > ▁ < new@@ pas@@ sp@@ hr@@ ase > \ n " " Chang@@ es ▁ the ▁ wallet ▁ pas@@ sp@@ hr@@ ase ▁ from ▁ < old@@ pas@@ sp@@ hr@@ ase > ▁ to ▁ < new@@ pas@@ sp@@ hr@@ ase > . " ) ; if ( ! pw@@ all@@ et@@ Main -> Change@@ Wallet@@ P@@ as@@ sp@@ hr@@ ase ( str@@ Old@@ Wallet@@ Pass , str@@ New@@ Wallet@@ Pass ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ PAS@@ SP@@ H@@ RAS@@ E_@@ IN@@ COR@@ RECT , " Error : ▁ The ▁ wallet ▁ pas@@ sp@@ hr@@ ase ▁ entered ▁ was ▁ incorrect . " ) ; return Value :: null ; } Value wall@@ et@@ lock ( const Array & params , bool f@@ Help ) { if ( pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) && ( f@@ Help || params . size ( ) != 0 ) ) throw runtime_error ( " wall@@ et@@ lock \ n " " Remov@@ es ▁ the ▁ wallet ▁ encryp@@ tion ▁ key ▁ from ▁ memory , ▁ lock@@ ing ▁ the ▁ wallet . \ n " " After ▁ call@@ ing ▁ this ▁ method , ▁ you ▁ will ▁ need ▁ to ▁ call ▁ wall@@ et@@ pas@@ sp@@ hr@@ ase ▁ again \ n " " before ▁ be@@ ing ▁ able ▁ to ▁ call ▁ any ▁ methods ▁ wh@@ ic@@ h ▁ require ▁ the ▁ wallet ▁ to ▁ be ▁ un@@ lock@@ ed . " ) ; if ( f@@ Help ) return true ; if ( ! pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ WRO@@ NG_@@ EN@@ C@@ _STATE , " Error : ▁ running ▁ with ▁ an ▁ un@@ encryp@@ ted ▁ wallet , ▁ bu@@ t ▁ wall@@ et@@ lock ▁ was ▁ called . " ) ; { LOCK ( cs_@@ nWallet@@ Unlock@@ Time ) ; pw@@ all@@ et@@ Main -> Lock ( ) ; nWallet@@ Unlock@@ Time = 0 ; } return Value :: null ; } Value encryp@@ t@@ wallet ( const Array & params , bool f@@ Help ) { if ( ! pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) && ( f@@ Help || params . size ( ) != 1 ) ) throw runtime_error ( " encryp@@ t@@ wallet ▁ < pas@@ sp@@ hr@@ ase > \ n " " En@@ cryp@@ ts ▁ the ▁ wallet ▁ with ▁ < pas@@ sp@@ hr@@ ase > . " ) ; if ( f@@ Help ) return true ; if ( pw@@ all@@ et@@ Main -> Is@@ Cryp@@ ted ( ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ WRO@@ NG_@@ EN@@ C@@ _STATE , " Error : ▁ running ▁ with ▁ an ▁ encryp@@ ted ▁ wallet , ▁ bu@@ t ▁ encryp@@ t@@ wallet ▁ was ▁ called . " ) ; Sec@@ ure@@ String strWallet@@ Pass ; strWallet@@ Pass . reserve ( 100 ) ; strWallet@@ Pass = params [ 0 ] . get_str ( ) . c_str ( ) ; if ( strWallet@@ Pass . length ( ) < 1 ) throw runtime_error ( " encryp@@ t@@ wallet ▁ < pas@@ sp@@ hr@@ ase > \ n " " En@@ cryp@@ ts ▁ the ▁ wallet ▁ with ▁ < pas@@ sp@@ hr@@ ase > . " ) ; if ( ! pw@@ all@@ et@@ Main -> En@@ cryp@@ t@@ Wallet ( strWallet@@ Pass ) ) throw JS@@ ON@@ RPC@@ Error ( RPC_@@ WAL@@ LE@@ T_@@ EN@@ CRY@@ P@@ TION@@ _FAILED , " Error : ▁ Failed ▁ to ▁ encrypt ▁ the ▁ wallet . " ) ; Start@@ Shutdo@@ wn ( ) ; return " wallet ▁ encryp@@ ted ; ▁ I@@ Lo@@ ve@@ You@@ Co@@ ins ▁ server ▁ st@@ opping , ▁ restart ▁ to ▁ run ▁ with ▁ encryp@@ ted ▁ wallet . ▁ The ▁ ke@@ ypo@@ ol ▁ has ▁ been ▁ flush@@ ed , ▁ you ▁ need ▁ to ▁ make ▁ a ▁ new ▁ back@@ up . " ; } class Descri@@ be@@ Address@@ Visitor : public boost :: static_@@ visitor < Object > { public : Object operator ( ) ( const C@@ No@@ Destination & dest ) const { return Object ( ) ; } Object operator ( ) ( const C@@ Key@@ ID & key@@ ID ) const { Object obj ; CP@@ ub@@ Key vchPubKey ; pw@@ all@@ et@@ Main -> GetPubKey ( key@@ ID , vchPubKey ) ; obj . push_back ( Pair ( " is@@ script " , false ) ) ; obj . push_back ( Pair ( " p@@ ub@@ key " , Hex@@ Str ( vchPubKey ) ) ) ; obj . push_back ( Pair ( " is@@ comp@@ ressed " , vchPubKey . Is@@ Compressed ( ) ) ) ; return obj ; } Object operator ( ) ( const C@@ Script@@ ID & script@@ ID ) const { Object obj ; obj . push_back ( Pair ( " is@@ script " , true ) ) ; CScript sub@@ script ; pw@@ all@@ et@@ Main -> Get@@ CScript ( script@@ ID , sub@@ script ) ; std :: vector < CTxDestination > addresses ; txnouttype whichType ; int nRequired ; ExtractDestinations ( sub@@ script , whichType , addresses , nRequired ) ; obj . push_back ( Pair ( " script " , Get@@ Tx@@ n@@ Output@@ Type ( whichType ) ) ) ; Array a ; BOOST_FOREACH ( const CTxDestination & addr , addresses ) a . push_back ( CBitcoinAddress ( addr ) . ToString ( ) ) ; obj . push_back ( Pair ( " addresses " , a ) ) ; if ( whichType == TX@@ _@@ MULTISIG ) obj . push_back ( Pair ( " sig@@ s@@ required " , nRequired ) ) ; return obj ; } } ; Value validate@@ address ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) != 1 ) throw runtime_error ( " validate@@ address ▁ < ilo@@ vey@@ ou@@ coin@@ s@@ address > \ n " " Return ▁ information ▁ about ▁ < ilo@@ vey@@ ou@@ coin@@ s@@ address > . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; bool isValid = address . IsValid ( ) ; Object ret ; ret . push_back ( Pair ( " is@@ valid " , isValid ) ) ; if ( isValid ) { CTxDestination dest = address . Get ( ) ; string current@@ Address = address . ToString ( ) ; ret . push_back ( Pair ( " address " , current@@ Address ) ) ; bool f@@ M@@ ine = pw@@ all@@ et@@ Main ? IsMine ( * pw@@ all@@ et@@ Main , dest ) : false ; ret . push_back ( Pair ( " is@@ m@@ ine " , f@@ M@@ ine ) ) ; if ( f@@ M@@ ine ) { Object detail = boost :: apply_@@ visitor ( Descri@@ be@@ Address@@ Visitor ( ) , dest ) ; ret . insert ( ret . end ( ) , detail . begin ( ) , detail . end ( ) ) ; } if ( pw@@ all@@ et@@ Main && pw@@ all@@ et@@ Main -> mapAddress@@ Book . count ( dest ) ) ret . push_back ( Pair ( " account " , pw@@ all@@ et@@ Main -> mapAddress@@ Book [ dest ] ) ) ; } return ret ; } Value reser@@ ve@@ bal@@ ance ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 2 ) throw runtime_error ( " reser@@ ve@@ bal@@ ance ▁ [ < reserve > ▁ [ amount ] ] \ n " " < reserve > ▁ is ▁ true ▁ or ▁ false ▁ to ▁ tur@@ n ▁ bal@@ ance ▁ reserve ▁ on ▁ or ▁ off . \ n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ ro@@ unded ▁ to ▁ c@@ ent . \ n " " Set ▁ reserve ▁ amount ▁ not ▁ particip@@ ating ▁ in ▁ network ▁ prote@@ c@@ tion . \ n " " If ▁ no ▁ parameters ▁ provided ▁ current ▁ setting ▁ is ▁ pr@@ in@@ ted . \ n " ) ; if ( params . size ( ) > 0 ) { bool f@@ Reser@@ ve = params [ 0 ] . get_@@ bool ( ) ; if ( f@@ Reser@@ ve ) { if ( params . size ( ) == 1 ) throw runtime_error ( " must ▁ provi@@ de ▁ amount ▁ to ▁ reserve ▁ bal@@ ance . \ n " ) ; int64 n@@ Amount = Amo@@ unt@@ From@@ Value ( params [ 1 ] ) ; n@@ Amount = ( n@@ Amount / CENT ) * CENT ; if ( n@@ Amount < 0 ) throw runtime_error ( " amount ▁ cannot ▁ be ▁ negative . \ n " ) ; n@@ Reser@@ ve@@ B@@ al@@ ance = n@@ Amount ; } else { if ( params . size ( ) > 1 ) throw runtime_error ( " cannot ▁ spec@@ if@@ y ▁ amount ▁ to ▁ tur@@ n ▁ off ▁ reserve . \ n " ) ; n@@ Reser@@ ve@@ B@@ al@@ ance = 0 ; } } Object result ; result . push_back ( Pair ( " reserve " , ( n@@ Reser@@ ve@@ B@@ al@@ ance > 0 ) ) ) ; result . push_back ( Pair ( " amount " , Value@@ From@@ Amount ( n@@ Reser@@ ve@@ B@@ al@@ ance ) ) ) ; return result ; } Value get@@ inte@@ rest ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 2 ) throw runtime_error ( " get@@ inte@@ rest ▁ [ start ] ▁ [ end ] \ n " " Both ▁ [ start ] ▁ and ▁ [ end ] ▁ are ▁ inclusive ▁ and ▁ in ▁ the ▁ form ▁ of ▁ UN@@ IX ▁ timest@@ amps . " ) ; unsigned int n@@ Time@@ Start = 0 ; unsigned int n@@ Time@@ End = - 1 ; if ( params . size ( ) >= 1 ) n@@ Time@@ Start = ( unsigned int ) ( params [ 0 ] . get_int ( ) ) ; if ( params . size ( ) == 2 ) n@@ Time@@ End = ( unsigned int ) ( params [ 1 ] . get_int ( ) ) ; int64 n@@ Inte@@ rest = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pw@@ all@@ et@@ Main -> mapWallet . begin ( ) ; it != pw@@ all@@ et@@ Main -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . Is@@ Co@@ in@@ St@@ a@@ ke ( ) || wtx . nTime < n@@ Time@@ Start || wtx . nTime > n@@ Time@@ End ) continue ; int64 n@@ De@@ bit = wtx . Get@@ De@@ bit ( ) ; int64 n@@ Cre@@ di@@ t = wtx . Get@@ Cre@@ di@@ t ( ) ; if ( n@@ De@@ bit <= 0 || n@@ Cre@@ di@@ t <= 0 || n@@ De@@ bit >= n@@ Cre@@ di@@ t ) continue ; else n@@ Inte@@ rest += n@@ Cre@@ di@@ t - n@@ De@@ bit ; } return Value@@ From@@ Amount ( n@@ Inte@@ rest ) ; } Value lock@@ un@@ spent ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " lock@@ un@@ spent ▁ unlock ? ▁ [ array - of - Objects ] \ n " " Upd@@ ates ▁ list ▁ of ▁ temp@@ or@@ ar@@ il@@ y ▁ un@@ sp@@ end@@ able ▁ output@@ s . " ) ; if ( params . size ( ) == 1 ) RPC@@ TypeCheck ( params , list_of ( bool@@ _type ) ) ; else RPC@@ TypeCheck ( params , list_of ( bool@@ _type ) ( array_type ) ) ; bool f@@ Unlock = params [ 0 ] . get_@@ bool ( ) ; if ( params . size ( ) == 1 ) { if ( f@@ Unlock ) pw@@ all@@ et@@ Main -> Unlock@@ All@@ Co@@ ins ( ) ; return true ; } Array output@@ s = params [ 1 ] . get_array ( ) ; BOOST_FOREACH ( Value & output , output@@ s ) { if ( output . type ( ) != obj@@ _type ) throw JS@@ ON@@ RPC@@ Error ( - 8 , " Invalid ▁ parameter , ▁ expected ▁ object " ) ; const Object & o = output . get_@@ obj ( ) ; RPC@@ TypeCheck ( o , map_list_of ( " tx@@ id " , str_type ) ( " vout " , int_type ) ) ; string tx@@ id = find_@@ value ( o , " tx@@ id " ) . get_str ( ) ; if ( ! Is@@ Hex ( tx@@ id ) ) throw JS@@ ON@@ RPC@@ Error ( - 8 , " Invalid ▁ parameter , ▁ expected ▁ hex ▁ tx@@ id " ) ; int n@@ Output = find_@@ value ( o , " vout " ) . get_int ( ) ; if ( n@@ Output < 0 ) throw JS@@ ON@@ RPC@@ Error ( - 8 , " Invalid ▁ parameter , ▁ vout ▁ must ▁ be ▁ positive " ) ; COutPoint out@@ pt ( uint256 ( tx@@ id ) , n@@ Output ) ; if ( f@@ Unlock ) pw@@ all@@ et@@ Main -> Unlock@@ Co@@ in ( out@@ pt ) ; else pw@@ all@@ et@@ Main -> Lock@@ Co@@ in ( out@@ pt ) ; } return true ; } Value list@@ lock@@ un@@ spent ( const Array & params , bool f@@ Help ) { if ( f@@ Help || params . size ( ) > 0 ) throw runtime_error ( " list@@ lock@@ un@@ spent \ n " " Retur@@ ns ▁ list ▁ of ▁ temp@@ or@@ ar@@ il@@ y ▁ un@@ sp@@ end@@ able ▁ output@@ s . " ) ; vector < COutPoint > vOut@@ pts ; pw@@ all@@ et@@ Main -> List@@ Lock@@ ed@@ Co@@ ins ( vOut@@ pts ) ; Array ret ; BOOST_FOREACH ( COutPoint & out@@ pt , vOut@@ pts ) { Object o ; o . push_back ( Pair ( " tx@@ id " , out@@ pt . hash . Get@@ Hex ( ) ) ) ; o . push_back ( Pair ( " vout " , ( int ) out@@ pt . n ) ) ; ret . push_back ( o ) ; } return ret ; } </DOCUMENT>
double angle@@ Di@@ ff ( double ph@@ i1 , double ph@@ i2 ) { double d = ph@@ i2 - ph@@ i1 ; if ( d > 0.0 ) { d = fmod ( d + M_PI , 2 * M_PI ) - M_PI ; } else { d = fmod ( d - M_PI , 2 * M_PI ) + M_PI ; } return d ; }
Vector@@ 4@@ d qu@@ at@@ Con@@ j@@ ugate ( const Eigen :: Vector@@ 4@@ d & q ) { Vector@@ 4@@ d q@@ _@@ con@@ j ; q@@ _@@ con@@ j << q ( 0 ) , - q ( 1 ) , - q ( 2 ) , - q ( 3 ) ; return q@@ _@@ con@@ j ; }
double qu@@ at@@ Di@@ ff@@ Axis@@ In@@ var ( const Eigen :: Vector@@ 4@@ d & q1 , const Eigen :: Vector@@ 4@@ d & q2 , const Eigen :: Vector@@ 3d & u ) { Vector@@ 4@@ d r = qu@@ at@@ Di@@ ff ( q1 , q2 ) ; double e = - 2.0 + 2 * r ( 0 ) * r ( 0 ) + 2 * pow ( u ( 0 ) * r ( 1 ) + u ( 1 ) * r ( 2 ) + u ( 2 ) * r ( 3 ) , 2 ) ; return e ; }
double qu@@ at@@ Nor@@ m ( const Eigen :: Vector@@ 4@@ d & q ) { return std :: ac@@ os ( q ( 0 ) ) ; }
Vector@@ 4@@ d uni@@ for@@ ml@@ y@@ Random@@ Axis@@ Angle ( std :: default_@@ random_@@ engine & generator ) { std :: normal_distribution < double > normal ; std :: uni@@ for@@ m_re@@ al_distribu@@ tion < double > uni@@ form ( - M_PI , M_PI ) ; double angle = uni@@ form ( generator ) ; Vector@@ 3d axis = Vector@@ 3d ( normal ( generator ) , normal ( generator ) , normal ( generator ) ) ; axis . norm@@ alize ( ) ; Vector@@ 4@@ d a ; a << axis , angle ; return a ; }
Vector@@ 4@@ d uni@@ for@@ ml@@ y@@ Random@@ Qu@@ at ( std :: default_@@ random_@@ engine & generator ) { return axis@@ 2@@ quat ( uni@@ for@@ ml@@ y@@ Random@@ Axis@@ Angle ( generator ) ) ; }
DL@@ LEXPORT int rot@@ ation@@ Re@@ present@@ ation@@ Size ( int rot@@ ation@@ _type ) { switch ( rot@@ ation@@ _type ) { case 0 : return 0 ; break ; case 1 : return 3 ; break ; case 2 : return 4 ; break ; default : throw std :: runtime_error ( " rotation ▁ re@@ presentation ▁ type ▁ not ▁ reco@@ gnized " ) ; } }
Matrix@@ 3d rot@@ z ( double theta ) { Matrix@@ 3d M ; double c = cos ( theta ) ; double s = sin ( theta ) ; M << c , - s , 0 , s , c , 0 , 0 , 0 , 1 ; return M ; }
void rot@@ z ( double theta , Matrix@@ 3d & M , Matrix@@ 3d & d@@ M , Matrix@@ 3d & dd@@ M ) { double c = cos ( theta ) , s = sin ( theta ) ; M << c , - s , 0 , s , c , 0 , 0 , 0 , 1 ; d@@ M << - s , - c , 0 , c , - s , 0 , 0 , 0 , 0 ; dd@@ M << - c , s , 0 , - s , - c , 0 , 0 , 0 , 0 ; }
template < typename Deri@@ ved > void normalize@@ Vec ( const Eigen :: Matrix@@ Base < Deri@@ ved > & x , typename Deri@@ ved :: Pla@@ in@@ Object & x_@@ norm , typename Gradi@@ ent < Deri@@ ved , Deri@@ ved :: Row@@ s@@ At@@ Compile@@ Time , 1 > :: type * dx_@@ norm , typename Gradi@@ ent < Deri@@ ved , Deri@@ ved :: Row@@ s@@ At@@ Compile@@ Time , 2 > :: type * dd@@ x_@@ norm ) { typename Deri@@ ved :: Scalar x@@ do@@ tx = x . squaredNor@@ m ( ) ; typename Deri@@ ved :: Scalar nor@@ m_@@ x = std :: sqrt ( x@@ do@@ tx ) ; x_@@ norm = x / nor@@ m_@@ x ; if ( dx_@@ norm ) { dx_@@ norm -> setIdentity ( x . rows ( ) , x . rows ( ) ) ; ( * dx_@@ norm ) -= x * x . transpose ( ) / x@@ do@@ tx ; ( * dx_@@ norm ) /= nor@@ m_@@ x ; if ( dd@@ x_@@ norm ) { auto dx_@@ nor@@ m_trans@@ pose = transpose@@ Gra@@ d ( * dx_@@ norm , x . rows ( ) ) ; auto dd@@ x_@@ nor@@ m_tim@@ es@@ _@@ norm = - mat@@ Gr@@ ad@@ M@@ ult@@ Mat ( x_@@ norm , x_@@ norm . transpose ( ) , ( * dx_@@ norm ) , dx_@@ nor@@ m_trans@@ pose ) ; auto d@@ nor@@ m_in@@ v = - x . transpose ( ) / ( x@@ do@@ tx * nor@@ m_@@ x ) ; ( * dd@@ x_@@ norm ) = dd@@ x_@@ nor@@ m_tim@@ es@@ _@@ norm / nor@@ m_@@ x ; auto temp = ( * dx_@@ norm ) * nor@@ m_@@ x ; typename Deri@@ ved :: Index n = x . rows ( ) ; for ( int col = 0 ; col < n ; col ++ ) { auto colum@@ n_@@ as_@@ matrix = ( d@@ nor@@ m_in@@ v ( 0 , col ) * temp ) ; for ( int row@@ _b@@ lock = 0 ; row@@ _b@@ lock < n ; row@@ _b@@ lock ++ ) { dd@@ x_@@ norm -> block ( row@@ _b@@ lock * n , col , n , 1 ) += colum@@ n_@@ as_@@ matrix . col ( row@@ _b@@ lock ) ; } } } } }
template < typename Deri@@ ved@@ Q , typename Deri@@ ved@@ M , typename Deri@@ ved@@ DM > void ang@@ ular@@ vel@@ 2@@ qu@@ at@@ do@@ t@@ Matrix ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ Q > & q , Eigen :: Matrix@@ Base < Deri@@ ved@@ M > & M , Eigen :: Matrix@@ Base < Deri@@ ved@@ DM > * d@@ M ) { M . resize ( QU@@ AT_@@ SIZE , SP@@ ACE_@@ DIMEN@@ SION ) ; M . row ( 0 ) << - q ( 1 ) , - q ( 2 ) , - q ( 3 ) ; M . row ( 1 ) << q ( 0 ) , q ( 3 ) , - q ( 2 ) ; M . row ( 2 ) << - q ( 3 ) , q ( 0 ) , q ( 1 ) ; M . row ( 3 ) << q ( 2 ) , - q ( 1 ) , q ( 0 ) ; M *= 0.5 ; if ( d@@ M ) { ( * d@@ M ) << 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.5 , 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 ; } }
template < typename Deri@@ ved@@ Q , typename Deri@@ ved@@ M > void qu@@ at@@ do@@ t2@@ ang@@ ular@@ vel@@ Matrix ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ Q > & q , Eigen :: Matrix@@ Base < Deri@@ ved@@ M > & M , typename Gradi@@ ent < Deri@@ ved@@ M , QU@@ AT_@@ SIZE , 1 > :: type * d@@ M ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved@@ Q > , QU@@ AT_@@ SIZE ) ; EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ MAT@@ RI@@ X@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved@@ M > , SP@@ ACE_@@ DIMEN@@ SION , QU@@ AT_@@ SIZE ) ; typename Deri@@ ved@@ Q :: Pla@@ in@@ Object q@@ ti@@ l@@ de ; if ( d@@ M ) { typename Gradi@@ ent < Deri@@ ved@@ Q , QU@@ AT_@@ SIZE > :: type d@@ q@@ ti@@ l@@ de ; normalize@@ Vec ( q , q@@ ti@@ l@@ de , & d@@ q@@ ti@@ l@@ de ) ; ( * d@@ M ) << 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , 0.0 ; ( * d@@ M ) *= d@@ q@@ ti@@ l@@ de ; } else { normalize@@ Vec ( q , q@@ ti@@ l@@ de ) ; } M << - q@@ ti@@ l@@ de ( 1 ) , q@@ ti@@ l@@ de ( 0 ) , - q@@ ti@@ l@@ de ( 3 ) , q@@ ti@@ l@@ de ( 2 ) , - q@@ ti@@ l@@ de ( 2 ) , q@@ ti@@ l@@ de ( 3 ) , q@@ ti@@ l@@ de ( 0 ) , - q@@ ti@@ l@@ de ( 1 ) , - q@@ ti@@ l@@ de ( 3 ) , - q@@ ti@@ l@@ de ( 2 ) , q@@ ti@@ l@@ de ( 1 ) , q@@ ti@@ l@@ de ( 0 ) ; M *= 2.0 ; }
template < typename Deri@@ ved@@ RP@@ Y , typename Deri@@ ved@@ Phi , typename Deri@@ ved@@ D@@ Phi , typename Deri@@ ved@@ DD@@ Phi > void ang@@ ular@@ vel@@ 2@@ r@@ py@@ do@@ t@@ Matrix ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ RP@@ Y > & r@@ py , typename Eigen :: Matrix@@ Base < Deri@@ ved@@ Phi > & ph@@ i , typename Eigen :: Matrix@@ Base < Deri@@ ved@@ D@@ Phi > * d@@ ph@@ i , typename Eigen :: Matrix@@ Base < Deri@@ ved@@ DD@@ Phi > * dd@@ ph@@ i ) { ph@@ i . resize ( RP@@ Y_SIZE , SP@@ ACE_@@ DIMEN@@ SION ) ; typedef typename Deri@@ ved@@ RP@@ Y :: Scalar Scalar ; Scalar p = r@@ py ( 1 ) ; Scalar y = r@@ py ( 2 ) ; using namespace std ; Scalar sy = sin ( y ) ; Scalar cy = cos ( y ) ; Scalar sp = sin ( p ) ; Scalar c@@ p = cos ( p ) ; Scalar t@@ p = sp / c@@ p ; ph@@ i << cy / c@@ p , sy / c@@ p , 0.0 , - sy , cy , 0.0 , cy * t@@ p , t@@ p * sy , 1.0 ; if ( d@@ ph@@ i ) { d@@ ph@@ i -> resize ( ph@@ i . size ( ) , RP@@ Y_SIZE ) ; Scalar sp@@ 2 = sp * sp ; Scalar c@@ p2 = c@@ p * c@@ p ; ( * d@@ ph@@ i ) << 0.0 , ( cy * sp ) / c@@ p2 , - sy / c@@ p , 0.0 , 0.0 , - cy , 0.0 , cy + ( cy * sp@@ 2 ) / c@@ p2 , - ( sp * sy ) / c@@ p , 0.0 , ( sp * sy ) / c@@ p2 , cy / c@@ p , 0.0 , 0.0 , - sy , 0.0 , sy + ( sp@@ 2 * sy ) / c@@ p2 , ( cy * sp ) / c@@ p , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; if ( dd@@ ph@@ i ) { dd@@ ph@@ i -> resize ( d@@ ph@@ i -> size ( ) , RP@@ Y_SIZE ) ; Scalar cp@@ 3 = c@@ p2 * c@@ p ; ( * dd@@ ph@@ i ) << 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - ( cy * ( c@@ p2 - 2.0 ) ) / cp@@ 3 , ( sp * sy ) / ( sp@@ 2 - 1.0 ) , 0.0 , 0.0 , 0.0 , 0.0 , ( 2.0 * cy * sp ) / cp@@ 3 , sy / ( sp@@ 2 - 1.0 ) , 0.0 , ( 2.0 * sy - c@@ p2 * sy ) / cp@@ 3 , ( cy * sp ) / c@@ p2 , 0.0 , 0.0 , 0.0 , 0.0 , ( 2.0 * sp * sy ) / cp@@ 3 , cy / c@@ p2 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , ( sp * sy ) / ( sp@@ 2 - 1.0 ) , - cy / c@@ p , 0.0 , 0.0 , sy , 0.0 , sy / ( sp@@ 2 - 1.0 ) , - ( cy * sp ) / c@@ p , 0.0 , ( cy * sp ) / c@@ p2 , - sy / c@@ p , 0.0 , 0.0 , - cy , 0.0 , cy / c@@ p2 , - ( sp * sy ) / c@@ p , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; } } }
template < typename Deri@@ ved@@ RP@@ Y , typename Deri@@ ved@@ E > void r@@ py@@ do@@ t2@@ ang@@ ular@@ vel@@ Matrix ( const Eigen :: Matrix@@ Base < Deri@@ ved@@ RP@@ Y > & r@@ py , Eigen :: Matrix@@ Base < Deri@@ ved@@ E > & E , typename Gradi@@ ent < Deri@@ ved@@ E , RP@@ Y_SIZE , 1 > :: type * d@@ E ) { EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ VEC@@ TOR@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved@@ RP@@ Y > , RP@@ Y_SIZE ) ; EIG@@ EN@@ _STAT@@ IC_@@ ASSERT_@@ MAT@@ RI@@ X@@ _SP@@ EC@@ IF@@ IC@@ _SIZE ( Eigen :: Matrix@@ Base < Deri@@ ved@@ E > , SP@@ ACE_@@ DIMEN@@ SION , RP@@ Y_SIZE ) ; typedef typename Deri@@ ved@@ RP@@ Y :: Scalar Scalar ; Scalar p = r@@ py ( 1 ) ; Scalar y = r@@ py ( 2 ) ; Scalar sp = sin ( p ) ; Scalar c@@ p = cos ( p ) ; Scalar sy = sin ( y ) ; Scalar cy = cos ( y ) ; using namespace std ; E << c@@ p * cy , - sy , 0.0 , c@@ p * sy , cy , 0.0 , - sp , 0.0 , 1.0 ; if ( d@@ E ) { ( * d@@ E ) << 0.0 , - sp * cy , - c@@ p * sy , 0.0 , - sp * sy , c@@ p * cy , 0.0 , - c@@ p , 0.0 , 0.0 , 0.0 , - cy , 0.0 , 0.0 , - sy , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; } }
template < typename Scalar > DL@@ LEXPORT void cy@@ lin@@ dri@@ cal@@ 2@@ car@@ te@@ si@@ an ( const Matrix < Scalar , 3 , 1 > & m_@@ cylinder@@ _@@ axis , const Matrix < Scalar , 3 , 1 > & m_@@ cylinder@@ _x@@ _dir , const Matrix < Scalar , 3 , 1 > & cylinder@@ _origin , const Matrix < Scalar , 6 , 1 > & x@@ _c@@ y@@ linder , const Matrix < Scalar , 6 , 1 > & v_@@ cy@@ linder , Matrix < Scalar , 6 , 1 > & x@@ _c@@ ar@@ te@@ si@@ an , Matrix < Scalar , 6 , 1 > & v_@@ car@@ te@@ si@@ an , Matrix < Scalar , 6 , 6 > & J , Matrix < Scalar , 6 , 1 > & J@@ do@@ tv ) { Matrix < Scalar , 3 , 1 > cylinder@@ _@@ axis = m_@@ cylinder@@ _@@ axis / m_@@ cylinder@@ _@@ axis . norm ( ) ; Matrix < Scalar , 3 , 1 > cylinder@@ _x@@ _dir = m_@@ cylinder@@ _x@@ _dir / m_@@ cylinder@@ _x@@ _dir . norm ( ) ; Matrix < Scalar , 3 , 3 > R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an ; R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an . col ( 0 ) = cylinder@@ _x@@ _dir ; R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an . col ( 1 ) = cylinder@@ _@@ axis . cross ( cylinder@@ _x@@ _dir ) ; R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an . col ( 2 ) = cylinder@@ _@@ axis ; double radius = x@@ _c@@ y@@ linder ( 0 ) ; double theta = x@@ _c@@ y@@ linder ( 1 ) ; double c_@@ theta = cos ( theta ) ; double s_@@ theta = sin ( theta ) ; double height = x@@ _c@@ y@@ linder ( 2 ) ; double r@@ adi@@ us_@@ dot = v_@@ cy@@ linder ( 0 ) ; double thet@@ a_@@ dot = v_@@ cy@@ linder ( 1 ) ; double he@@ igh@@ t_@@ dot = v_@@ cy@@ linder ( 2 ) ; Matrix < Scalar , 3 , 1 > x_@@ pos_@@ car@@ te@@ si@@ an ; x_@@ pos_@@ car@@ te@@ si@@ an << radius * c_@@ theta , radius * s_@@ theta , height ; x_@@ pos_@@ car@@ te@@ si@@ an = R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an * x_@@ pos_@@ car@@ te@@ si@@ an + cylinder@@ _origin ; Matrix < Scalar , 3 , 1 > v_@@ pos_@@ car@@ te@@ si@@ an ; v_@@ pos_@@ car@@ te@@ si@@ an << radius * - s_@@ theta * thet@@ a_@@ dot + r@@ adi@@ us_@@ dot * c_@@ theta , radius * c_@@ theta * thet@@ a_@@ dot + r@@ adi@@ us_@@ dot * s_@@ theta , he@@ igh@@ t_@@ dot ; v_@@ pos_@@ car@@ te@@ si@@ an = R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an * v_@@ pos_@@ car@@ te@@ si@@ an ; Vector@@ 3d x_r@@ p@@ y_@@ cy@@ linder = x@@ _c@@ y@@ linder . block ( 3 , 0 , 3 , 1 ) ; Matrix < Scalar , 3 , 3 > R_@@ t@@ ang@@ ent = r@@ py@@ 2@@ rot@@ mat ( x_r@@ p@@ y_@@ cy@@ linder ) ; Matrix < Scalar , 3 , 3 > R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder ; Matrix < Scalar , 3 , 3 > d@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder ; Matrix < Scalar , 3 , 3 > dd@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder ; rot@@ z ( theta - M_PI / 2 , R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder , d@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder , dd@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder ) ; Matrix < Scalar , 3 , 3 > d@@ R_@@ t@@ ang@@ ent@@ 2@@ cylinder@@ _d@@ theta = d@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder ; Matrix < Scalar , 3 , 3 > R@@ _c@@ y@@ linder = R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder * R_@@ t@@ ang@@ ent ; Matrix < Scalar , 3 , 3 > R@@ _c@@ ar@@ te@@ si@@ an = R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an * R@@ _c@@ y@@ linder ; Matrix < Scalar , 3 , 1 > x_r@@ p@@ y_@@ car@@ te@@ si@@ an = rot@@ mat@@ 2@@ r@@ py ( R@@ _c@@ ar@@ te@@ si@@ an ) ; x@@ _c@@ ar@@ te@@ si@@ an . block ( 0 , 0 , 3 , 1 ) = x_@@ pos_@@ car@@ te@@ si@@ an ; x@@ _c@@ ar@@ te@@ si@@ an . block ( 3 , 0 , 3 , 1 ) = x_r@@ p@@ y_@@ car@@ te@@ si@@ an ; v_@@ car@@ te@@ si@@ an . block ( 0 , 0 , 3 , 1 ) = v_@@ pos_@@ car@@ te@@ si@@ an ; v_@@ car@@ te@@ si@@ an . block ( 3 , 0 , 3 , 1 ) = thet@@ a_@@ dot * R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an . col ( 2 ) + R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an * R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder * v_@@ cy@@ linder . block ( 3 , 0 , 3 , 1 ) ; J = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; J . block ( 0 , 0 , 3 , 1 ) << c_@@ theta , s_@@ theta , 0 ; J . block ( 0 , 1 , 3 , 1 ) << radius * - s_@@ theta , radius * c_@@ theta , 0 ; J . block ( 0 , 2 , 3 , 1 ) << 0 , 0 , 1 ; J . block ( 0 , 0 , 3 , 3 ) = R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an * J . block ( 0 , 0 , 3 , 3 ) ; J . block ( 3 , 1 , 3 , 1 ) = R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an . col ( 2 ) ; J . block ( 3 , 3 , 3 , 3 ) = R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an * R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder ; Matrix < Scalar , 3 , 3 > d@@ J@@ 1@@ _d@@ radius = Matrix < Scalar , 3 , 3 > :: Zero ( ) ; d@@ J@@ 1@@ _d@@ radius ( 0 , 1 ) = - s_@@ theta ; d@@ J@@ 1@@ _d@@ radius ( 1 , 1 ) = c_@@ theta ; Matrix < Scalar , 3 , 3 > d@@ J@@ 1@@ _d@@ theta = Matrix < Scalar , 3 , 3 > :: Zero ( ) ; d@@ J@@ 1@@ _d@@ theta ( 0 , 0 ) = - s_@@ theta ; d@@ J@@ 1@@ _d@@ theta ( 0 , 1 ) = - radius * c_@@ theta ; d@@ J@@ 1@@ _d@@ theta ( 1 , 0 ) = c_@@ theta ; d@@ J@@ 1@@ _d@@ theta ( 1 , 1 ) = - radius * s_@@ theta ; J@@ do@@ tv . block ( 0 , 0 , 3 , 1 ) = R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an * ( d@@ J@@ 1@@ _d@@ radius * r@@ adi@@ us_@@ dot + d@@ J@@ 1@@ _d@@ theta * thet@@ a_@@ dot ) * v_@@ cy@@ linder . block ( 0 , 0 , 3 , 1 ) ; J@@ do@@ tv . block ( 3 , 0 , 3 , 1 ) = R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an * d@@ R_@@ t@@ ang@@ ent@@ 2@@ cylinder@@ _d@@ theta * thet@@ a_@@ dot * v_@@ cy@@ linder . block ( 3 , 0 , 3 , 1 ) ; }
template < typename Scalar > DL@@ LEXPORT void car@@ te@@ si@@ an@@ 2@@ cy@@ lin@@ dri@@ cal ( const Eigen :: Matrix < Scalar , 3 , 1 > & m_@@ cylinder@@ _@@ axis , const Eigen :: Matrix < Scalar , 3 , 1 > & m_@@ cylinder@@ _x@@ _dir , const Eigen :: Matrix < Scalar , 3 , 1 > & cylinder@@ _origin , const Eigen :: Matrix < Scalar , 6 , 1 > & x@@ _c@@ ar@@ te@@ si@@ an , const Eigen :: Matrix < Scalar , 6 , 1 > & v_@@ car@@ te@@ si@@ an , Eigen :: Matrix < Scalar , 6 , 1 > & x@@ _c@@ y@@ linder , Eigen :: Matrix < Scalar , 6 , 1 > & v_@@ cy@@ linder , Eigen :: Matrix < Scalar , 6 , 6 > & J , Eigen :: Matrix < Scalar , 6 , 1 > & J@@ do@@ tv ) { Matrix < Scalar , 3 , 1 > cylinder@@ _@@ axis = m_@@ cylinder@@ _@@ axis / m_@@ cylinder@@ _@@ axis . norm ( ) ; Matrix < Scalar , 3 , 1 > cylinder@@ _x@@ _dir = m_@@ cylinder@@ _x@@ _dir / m_@@ cylinder@@ _x@@ _dir . norm ( ) ; Matrix < Scalar , 3 , 3 > R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an ; R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an . col ( 0 ) = cylinder@@ _x@@ _dir ; R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an . col ( 1 ) = cylinder@@ _@@ axis . cross ( cylinder@@ _x@@ _dir ) ; R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an . col ( 2 ) = cylinder@@ _@@ axis ; Matrix < Scalar , 3 , 3 > R@@ _c@@ ar@@ te@@ si@@ an@@ 2@@ cy@@ linder = R@@ _c@@ y@@ linder@@ 2@@ car@@ te@@ si@@ an . transpose ( ) ; Matrix < Scalar , 3 , 1 > x_@@ pos_@@ cy@@ linder = R@@ _c@@ ar@@ te@@ si@@ an@@ 2@@ cy@@ linder * ( x@@ _c@@ ar@@ te@@ si@@ an . block ( 0 , 0 , 3 , 1 ) - cylinder@@ _origin ) ; Matrix < Scalar , 3 , 1 > v_@@ pos_@@ cy@@ linder = R@@ _c@@ ar@@ te@@ si@@ an@@ 2@@ cy@@ linder * v_@@ car@@ te@@ si@@ an . block ( 0 , 0 , 3 , 1 ) ; double radius = sqrt ( pow ( x_@@ pos_@@ cy@@ linder ( 0 ) , 2 ) + pow ( x_@@ pos_@@ cy@@ linder ( 1 ) , 2 ) ) ; double r@@ adi@@ us_@@ dot = ( x_@@ pos_@@ cy@@ linder ( 0 ) * v_@@ pos_@@ cy@@ linder ( 0 ) + x_@@ pos_@@ cy@@ linder ( 1 ) * v_@@ pos_@@ cy@@ linder ( 1 ) ) / radius ; double theta = atan@@ 2 ( x_@@ pos_@@ cy@@ linder ( 1 ) , x_@@ pos_@@ cy@@ linder ( 0 ) ) ; double r@@ adi@@ us_@@ squ@@ are = pow ( radius , 2 ) ; double r@@ adi@@ us_@@ cubic = pow ( radius , 3 ) ; double r@@ adi@@ us_@@ quad = pow ( radius , 4 ) ; double thet@@ a_@@ dot = ( - x_@@ pos_@@ cy@@ linder ( 1 ) * v_@@ pos_@@ cy@@ linder ( 0 ) + x_@@ pos_@@ cy@@ linder ( 0 ) * v_@@ pos_@@ cy@@ linder ( 1 ) ) / r@@ adi@@ us_@@ squ@@ are ; double height = x_@@ pos_@@ cy@@ linder ( 2 ) ; double he@@ igh@@ t_@@ dot = v_@@ pos_@@ cy@@ linder ( 2 ) ; x@@ _c@@ y@@ linder ( 0 ) = radius ; x@@ _c@@ y@@ linder ( 1 ) = theta ; x@@ _c@@ y@@ linder ( 2 ) = height ; v_@@ cy@@ linder ( 0 ) = r@@ adi@@ us_@@ dot ; v_@@ cy@@ linder ( 1 ) = thet@@ a_@@ dot ; v_@@ cy@@ linder ( 2 ) = he@@ igh@@ t_@@ dot ; Matrix < Scalar , 3 , 3 > R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder ; Matrix < Scalar , 3 , 3 > d@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder ; Matrix < Scalar , 3 , 3 > dd@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder ; rot@@ z ( theta - M_PI / 2 , R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder , d@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder , dd@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder ) ; Matrix < Scalar , 3 , 3 > R@@ _c@@ y@@ linder@@ 2@@ t@@ ang@@ ent = R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder . transpose ( ) ; Vector@@ 3d x_r@@ p@@ y_@@ car@@ te@@ si@@ an = x@@ _c@@ ar@@ te@@ si@@ an . block ( 3 , 0 , 3 , 1 ) ; Matrix < Scalar , 3 , 3 > R@@ _c@@ ar@@ te@@ si@@ an = r@@ py@@ 2@@ rot@@ mat ( x_r@@ p@@ y_@@ car@@ te@@ si@@ an ) ; x@@ _c@@ y@@ linder . block ( 3 , 0 , 3 , 1 ) = rot@@ mat@@ 2@@ r@@ py ( R@@ _c@@ y@@ linder@@ 2@@ t@@ ang@@ ent * R@@ _c@@ ar@@ te@@ si@@ an@@ 2@@ cy@@ linder * R@@ _c@@ ar@@ te@@ si@@ an ) ; J = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; Matrix < Scalar , 6 , 6 > J@@ dot = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; J ( 0 , 0 ) = x_@@ pos_@@ cy@@ linder ( 0 ) / radius ; J ( 0 , 1 ) = x_@@ pos_@@ cy@@ linder ( 1 ) / radius ; J ( 1 , 0 ) = - x_@@ pos_@@ cy@@ linder ( 1 ) / r@@ adi@@ us_@@ squ@@ are ; J ( 1 , 1 ) = x_@@ pos_@@ cy@@ linder ( 0 ) / r@@ adi@@ us_@@ squ@@ are ; J ( 2 , 2 ) = 1.0 ; J . block ( 0 , 0 , 3 , 3 ) = J . block ( 0 , 0 , 3 , 3 ) * R@@ _c@@ ar@@ te@@ si@@ an@@ 2@@ cy@@ linder ; J@@ dot ( 0 , 0 ) = pow ( x_@@ pos_@@ cy@@ linder ( 1 ) , 2 ) / r@@ adi@@ us_@@ cubic * v_@@ pos_@@ cy@@ linder ( 0 ) - x_@@ pos_@@ cy@@ linder ( 0 ) * x_@@ pos_@@ cy@@ linder ( 1 ) / r@@ adi@@ us_@@ cubic * v_@@ pos_@@ cy@@ linder ( 1 ) ; J@@ dot ( 0 , 1 ) = - x_@@ pos_@@ cy@@ linder ( 0 ) * x_@@ pos_@@ cy@@ linder ( 1 ) / r@@ adi@@ us_@@ cubic * v_@@ pos_@@ cy@@ linder ( 0 ) + pow ( x_@@ pos_@@ cy@@ linder ( 0 ) , 2 ) / r@@ adi@@ us_@@ cubic * v_@@ pos_@@ cy@@ linder ( 1 ) ; J@@ dot ( 1 , 0 ) = 2 * x_@@ pos_@@ cy@@ linder ( 0 ) * x_@@ pos_@@ cy@@ linder ( 1 ) / r@@ adi@@ us_@@ quad * v_@@ pos_@@ cy@@ linder ( 0 ) + ( pow ( x_@@ pos_@@ cy@@ linder ( 1 ) , 2 ) - pow ( x_@@ pos_@@ cy@@ linder ( 0 ) , 2 ) ) / r@@ adi@@ us_@@ quad * v_@@ pos_@@ cy@@ linder ( 1 ) ; J@@ dot ( 1 , 1 ) = ( pow ( x_@@ pos_@@ cy@@ linder ( 1 ) , 2 ) - pow ( x_@@ pos_@@ cy@@ linder ( 0 ) , 2 ) ) / r@@ adi@@ us_@@ quad * v_@@ pos_@@ cy@@ linder ( 0 ) - 2 * x_@@ pos_@@ cy@@ linder ( 0 ) * x_@@ pos_@@ cy@@ linder ( 1 ) / r@@ adi@@ us_@@ quad * v_@@ pos_@@ cy@@ linder ( 1 ) ; J@@ dot . block ( 0 , 0 , 3 , 3 ) = J@@ dot . block ( 0 , 0 , 3 , 3 ) * R@@ _c@@ ar@@ te@@ si@@ an@@ 2@@ cy@@ linder ; v_@@ cy@@ linder . block ( 3 , 0 , 3 , 1 ) = R@@ _c@@ y@@ linder@@ 2@@ t@@ ang@@ ent * R@@ _c@@ ar@@ te@@ si@@ an@@ 2@@ cy@@ linder * v_@@ car@@ te@@ si@@ an . block ( 3 , 0 , 3 , 1 ) - thet@@ a_@@ dot * R@@ _c@@ y@@ linder@@ 2@@ t@@ ang@@ ent . col ( 2 ) ; J . block ( 3 , 0 , 3 , 3 ) = R@@ _c@@ y@@ linder@@ 2@@ t@@ ang@@ ent . col ( 2 ) * - J . block ( 1 , 0 , 1 , 3 ) ; J . block ( 3 , 3 , 3 , 3 ) = R@@ _c@@ y@@ linder@@ 2@@ t@@ ang@@ ent * R@@ _c@@ ar@@ te@@ si@@ an@@ 2@@ cy@@ linder ; J@@ dot . block ( 3 , 0 , 3 , 3 ) = d@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder . row ( 2 ) . transpose ( ) * - J . block ( 1 , 0 , 1 , 3 ) * thet@@ a_@@ dot + R@@ _c@@ y@@ linder@@ 2@@ t@@ ang@@ ent . col ( 2 ) * - J@@ dot . block ( 1 , 0 , 1 , 3 ) ; J@@ dot . block ( 3 , 3 , 3 , 3 ) = d@@ R_@@ t@@ ang@@ ent@@ 2@@ cy@@ linder . transpose ( ) * thet@@ a_@@ dot * R@@ _c@@ ar@@ te@@ si@@ an@@ 2@@ cy@@ linder ; J@@ do@@ tv = J@@ dot * v_@@ car@@ te@@ si@@ an ; }
DL@@ LEXPORT Gradient@@ Var < double , 3 , 1 > qu@@ at@@ 2@@ exp@@ map ( const Ref < const Vector@@ 4@@ d > & q , int gradi@@ ent_@@ order ) { double t = sqrt ( 1 - q ( 0 ) * q ( 0 ) ) ; bool is_@@ de@@ generate = ( t * t < std :: numer@@ ic@@ _@@ limits < double > :: epsilon ( ) ) ; double s = is_@@ de@@ generate ? 2.0 : 2.0 * ac@@ os ( q ( 0 ) ) / t ; Gradient@@ Var < double , 3 , 1 > ret ( 3 , 1 , 4 , gradi@@ ent_@@ order ) ; ret . value ( ) = s * q . tail ( 3 ) ; if ( gradi@@ ent_@@ order > 0 ) { ret . gradi@@ ent ( ) . value ( ) = Matrix < double , 3 , 4 > :: Zero ( ) ; double dsd@@ q1 = is_@@ de@@ generate ? 0.0 : ( - 2 * t + 2 * ac@@ os ( q ( 0 ) ) * q ( 0 ) ) / pow ( t , 3 ) ; ret . gradi@@ ent ( ) . value ( ) . col ( 0 ) = q . tail ( 3 ) * dsd@@ q1 ; ret . gradi@@ ent ( ) . value ( ) . block ( 0 , 1 , 3 , 3 ) = Matrix@@ 3d :: Identity ( ) * s ; } else if ( gradi@@ ent_@@ order > 1 ) { throw std :: runtime_error ( " gradi@@ ent _ order > 1 ▁ is ▁ not ▁ supported ▁ in ▁ qu@@ at@@ 2@@ exp@@ map " ) ; } return ret ; }
DL@@ LEXPORT Gradient@@ Var < double , 3 , 1 > flip@@ Exp@@ map ( const Ref < const Vector@@ 3d > & exp@@ map , int gradi@@ ent_@@ order ) { if ( gradi@@ ent_@@ order > 1 ) { throw std :: runtime_error ( " gradi@@ ent _ order > 1 ▁ is ▁ not ▁ supported ▁ in ▁ flip@@ Exp@@ map " ) ; } double exp@@ map_@@ norm = exp@@ map . norm ( ) ; bool is_@@ de@@ generate = ( exp@@ map_@@ norm < std :: numer@@ ic@@ _@@ limits < double > :: epsilon ( ) ) ; Gradient@@ Var < double , 3 , 1 > ret ( 3 , 1 , 3 , gradi@@ ent_@@ order ) ; Matrix@@ 3d e@@ ye@@ 3 = Matrix@@ 3d :: Identity ( ) ; if ( is_@@ de@@ generate ) { ret . value ( ) = exp@@ map ; if ( gradi@@ ent_@@ order > 0 ) { ret . gradi@@ ent ( ) . value ( ) = e@@ ye@@ 3 ; } } else { ret . value ( ) = exp@@ map - exp@@ map / exp@@ map_@@ norm * 2 * M_PI ; if ( gradi@@ ent_@@ order > 0 ) { ret . gradi@@ ent ( ) . value ( ) = e@@ ye@@ 3 - ( exp@@ map_@@ norm * exp@@ map_@@ norm * e@@ ye@@ 3 - exp@@ map * exp@@ map . transpose ( ) ) / pow ( exp@@ map_@@ norm , 3 ) * 2 * M_PI ; } } return ret ; }
DL@@ LEXPORT Gradient@@ Var < double , 3 , 1 > un@@ w@@ rap@@ Exp@@ map ( const Ref < const Vector@@ 3d > & exp@@ map@@ 1 , const Ref < const Vector@@ 3d > & exp@@ map@@ 2 , int gradi@@ ent_@@ order ) { auto exp@@ map@@ 2_@@ f@@ lip = flip@@ Exp@@ map ( exp@@ map@@ 2 , gradi@@ ent_@@ order ) ; double distance@@ 1 = ( exp@@ map@@ 1 - exp@@ map@@ 2 ) . squaredNor@@ m ( ) ; double distance@@ 2 = ( exp@@ map@@ 1 - exp@@ map@@ 2_@@ f@@ lip . value ( ) ) . squaredNor@@ m ( ) ; if ( distance@@ 1 > distance@@ 2 ) { return exp@@ map@@ 2_@@ f@@ lip ; } else { Gradient@@ Var < double , 3 , 1 > ret ( 3 , 1 , 3 , gradi@@ ent_@@ order ) ; ret . value ( ) = exp@@ map@@ 2 ; if ( gradi@@ ent_@@ order > 0 ) { ret . gradi@@ ent ( ) . value ( ) = Matrix@@ 3d :: Identity ( ) ; } return ret ; } }
void qu@@ at@@ 2@@ exp@@ map@@ Sequence ( const Ref < const Matrix < double , 4 , Dynamic >> & quat , const Ref < const Matrix < double , 4 , Dynamic >> & qu@@ at@@ _@@ dot , Ref < Matrix < double , 3 , Dynamic >> exp@@ map , Ref < Matrix < double , 3 , Dynamic >> exp@@ map_@@ dot ) { D@@ en@@ se@@ Index N = quat . cols ( ) ; if ( qu@@ at@@ _@@ dot . cols ( ) != N ) { throw std :: runtime_error ( " quat _ dot ▁ must ▁ have ▁ the ▁ same ▁ number ▁ of ▁ columns ▁ as ▁ quat ▁ in ▁ qu@@ at@@ 2@@ exp@@ map@@ Sequence " ) ; } exp@@ map . resize ( 3 , N ) ; exp@@ map_@@ dot . resize ( 3 , N ) ; for ( int i = 0 ; i < N ; i ++ ) { auto exp@@ map_@@ gra@@ d = qu@@ at@@ 2@@ exp@@ map ( quat . col ( i ) , 1 ) ; exp@@ map . col ( i ) = exp@@ map_@@ gra@@ d . value ( ) ; exp@@ map_@@ dot . col ( i ) = exp@@ map_@@ gra@@ d . gradi@@ ent ( ) . value ( ) * qu@@ at@@ _@@ dot . col ( i ) ; if ( i >= 1 ) { auto close@@ st_@@ gra@@ d = close@@ st@@ Exp@@ map ( exp@@ map . col ( i - 1 ) , exp@@ map . col ( i ) , 1 ) ; exp@@ map . col ( i ) = close@@ st_@@ gra@@ d . value ( ) ; exp@@ map_@@ dot . col ( i ) = close@@ st_@@ gra@@ d . gradi@@ ent ( ) . value ( ) * exp@@ map_@@ dot . col ( i ) ; } } }
DL@@ LEXPORT Gradient@@ Var < double , 3 , 1 > close@@ st@@ Exp@@ map ( const Ref < const Vector@@ 3d > & exp@@ map@@ 1 , const Ref < const Vector@@ 3d > & exp@@ map@@ 2 , int gradi@@ ent_@@ order ) { if ( gradi@@ ent_@@ order > 1 ) { throw std :: runtime_error ( " close@@ st@@ Exp@@ map ▁ only ▁ supports ▁ first ▁ order ▁ gradi@@ ent " ) ; } double exp@@ map@@ 1_@@ norm = exp@@ map@@ 1 . norm ( ) ; double exp@@ map@@ 2_@@ norm = exp@@ map@@ 2 . norm ( ) ; Gradient@@ Var < double , 3 , 1 > ret ( 3 , 1 , 3 , gradi@@ ent_@@ order ) ; if ( exp@@ map@@ 2_@@ norm < std :: numer@@ ic@@ _@@ limits < double > :: epsilon ( ) ) { if ( exp@@ map@@ 1_@@ norm > std :: numer@@ ic@@ _@@ limits < double > :: epsilon ( ) ) { Vector@@ 3d exp@@ map@@ 1_@@ axis = exp@@ map@@ 1 / exp@@ map@@ 1_@@ norm ; int exp@@ map@@ 1_@@ round = static_cast < int > ( exp@@ map@@ 1_@@ norm / ( 2 * M_PI ) + 0.5 ) ; ret . value ( ) = exp@@ map@@ 1_@@ axis * exp@@ map@@ 1_@@ round * 2 * M_PI ; if ( ret . has@@ Gradi@@ ent ( ) ) { ret . gradi@@ ent ( ) . value ( ) = Matrix@@ 3d :: Zero ( ) ; } return ret ; } else { ret . value ( ) = exp@@ map@@ 2 ; if ( ret . has@@ Gradi@@ ent ( ) ) { ret . gradi@@ ent ( ) . value ( ) = Matrix@@ 3d :: Identity ( ) ; } } } else { Vector@@ 3d exp@@ map@@ 2_@@ axis = exp@@ map@@ 2 / exp@@ map@@ 2_@@ norm ; Matrix@@ 3d dex@@ pmap@@ 2_@@ ax@@ is_@@ dex@@ pmap@@ 2 = ( exp@@ map@@ 2_@@ norm * Matrix@@ 3d :: Identity ( ) - exp@@ map@@ 2 * exp@@ map@@ 2 . transpose ( ) / exp@@ map@@ 2_@@ norm ) / pow ( exp@@ map@@ 2_@@ norm , 2 ) ; double exp@@ map@@ 2_@@ close@@ st_@@ k = ( exp@@ map@@ 2_@@ axis . transpose ( ) * exp@@ map@@ 1 - exp@@ map@@ 2_@@ norm ) / ( 2 * M_PI ) ; int exp@@ map@@ 2_@@ close@@ st_@@ k1 ; int exp@@ map@@ 2_@@ close@@ st_@@ k2 ; if ( exp@@ map@@ 2_@@ close@@ st_@@ k > 0 ) { exp@@ map@@ 2_@@ close@@ st_@@ k1 = ( int ) exp@@ map@@ 2_@@ close@@ st_@@ k ; } else { exp@@ map@@ 2_@@ close@@ st_@@ k1 = ( int ) exp@@ map@@ 2_@@ close@@ st_@@ k - 1 ; } exp@@ map@@ 2_@@ close@@ st_@@ k2 = exp@@ map@@ 2_@@ close@@ st_@@ k1 + 1 ; Vector@@ 3d exp@@ map@@ 2_@@ close@@ st1 = exp@@ map@@ 2 + 2 * exp@@ map@@ 2_@@ close@@ st_@@ k1 * M_PI * exp@@ map@@ 2_@@ axis ; Vector@@ 3d exp@@ map@@ 2_@@ close@@ st2 = exp@@ map@@ 2 + 2 * exp@@ map@@ 2_@@ close@@ st_@@ k2 * M_PI * exp@@ map@@ 2_@@ axis ; if ( ( exp@@ map@@ 2_@@ close@@ st1 - exp@@ map@@ 1 ) . norm ( ) < ( exp@@ map@@ 2_@@ close@@ st2 - exp@@ map@@ 1 ) . norm ( ) ) { ret . value ( ) = exp@@ map@@ 2_@@ close@@ st1 ; if ( ret . has@@ Gradi@@ ent ( ) ) { ret . gradi@@ ent ( ) . value ( ) = Matrix@@ 3d :: Identity ( ) + 2 * dex@@ pmap@@ 2_@@ ax@@ is_@@ dex@@ pmap@@ 2 * ( double ) exp@@ map@@ 2_@@ close@@ st_@@ k1 * M_PI ; } return ret ; } else { ret . value ( ) = exp@@ map@@ 2_@@ close@@ st2 ; if ( ret . has@@ Gradi@@ ent ( ) ) { ret . gradi@@ ent ( ) . value ( ) = Matrix@@ 3d :: Identity ( ) + 2 * dex@@ pmap@@ 2_@@ ax@@ is_@@ dex@@ pmap@@ 2 * ( double ) exp@@ map@@ 2_@@ close@@ st_@@ k2 * M_PI ; } return ret ; } } return ret ; }
