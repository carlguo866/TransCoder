public synchronized static Map < String , String > convertFilesToMap ( CommonsMultipartFile [ ] fileInputList ) { Map < String , String > fileMap = new LinkedHashMap < String , String > ( ) ; CommonsMultipartFile tmpMultiFile ; String tmpCharset ; fileNameCounterMap . clear ( ) ; for ( int i = 0 ; i < fileInputList . length ; i ++ ) { tmpMultiFile = fileInputList [ i ] ; try { if ( tmpMultiFile != null && ! tmpMultiFile . isEmpty ( ) && tmpMultiFile . getInputStream ( ) != null ) { tmpCharset = CrawlUtils . extractCharset ( tmpMultiFile . getInputStream ( ) ) ; fileMap . put ( getFileName ( tmpMultiFile . getOriginalFilename ( ) ) , tmpMultiFile . getFileItem ( ) . getString ( tmpCharset ) ) ; } } catch ( IOException e ) { } } return fileMap ; }
private static String getFileName ( String originalFileName ) { StringBuilder fileName = new StringBuilder ( ) ; fileName . append ( ' / ' ) ; if ( fileNameCounterMap . containsKey ( originalFileName ) ) { fileNameCounterMap . put ( originalFileName , Integer . valueOf ( fileNameCounterMap . get ( originalFileName ) + 1 ) ) ; fileName . append ( originalFileName ) ; fileName . append ( ' _ ' ) ; fileName . append ( fileNameCounterMap . get ( originalFileName ) ) ; return fileName . toString ( ) ; } else { fileNameCounterMap . put ( originalFileName , Integer . valueOf ( 1 ) ) ; fileName . append ( originalFileName ) ; return fileName . toString ( ) ; } }
public static final void init ( int t ) { if ( props == null ) { props = new Props ( t ) ; } else { throw new RuntimeException ( " The ▁ Properties ▁ systems ▁ settings ▁ are ▁ already ▁ initialised ! " ) ; } }
public static final void init ( String filename ) { if ( props == null ) { props = new Props ( filename ) ; } else { throw new RuntimeException ( " The ▁ properties ▁ systems ▁ settings ▁ are ▁ already ▁ initialised ! " ) ; } }
public static boolean isInitialized ( ) { return props != null ; }
public static Props getInstance ( ) { if ( props != null ) { return props ; } throw new RuntimeException ( " Properties , ▁ Kettle ▁ systems ▁ settings , ▁ not ▁ initialised ! " ) ; }
public static final int getArgumentNumber ( ValueMetaInterface value ) { if ( value != null && value . getName ( ) . startsWith ( Props . STRING_ARGUMENT_NAME_PREFIX ) ) { return Const . toInt ( value . getName ( ) . substring ( Props . STRING_ARGUMENT_NAME_PREFIX . length ( ) ) , - 1 ) ; } return - 1 ; }
public static final String [ ] convertArguments ( RowMetaAndData row ) { String [ ] args = new String [ 10 ] ; for ( int i = 0 ; i < row . size ( ) ; i ++ ) { ValueMetaInterface valueMeta = row . getValueMeta ( i ) ; int argNr = getArgumentNumber ( valueMeta ) ; if ( argNr >= 0 && argNr < 10 ) { try { args [ argNr ] = row . getString ( i , " " ) ; } catch ( KettleValueException e ) { args [ argNr ] = " " ; } } } return args ; }
private static Date parseDate ( String s ) { for ( DateFormat currentFormat : DATE_FORMATS ) { try { return currentFormat . parse ( s ) ; } catch ( ParseException e ) { } } return null ; }
