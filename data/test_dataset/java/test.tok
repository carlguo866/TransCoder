<DOCUMENT_ID="arunmk/CoreNLP/tree/master/test/src/edu/stanford/nlp/util/IterablesTest.java"> package edu . stanford . nlp . util ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; import java . util . Random ; import java . util . function . Function ; import junit . framework . Assert ; import junit . framework . TestCase ; public class IterablesTest extends TestCase { public void testZip ( ) { String [ ] s1 = new String [ ] { " a " , " b " , " c " } ; Integer [ ] s2 = new Integer [ ] { 1 , 2 , 3 , 4 } ; int count = 0 ; for ( Pair < String , Integer > pair : Iterables . zip ( s1 , s2 ) ) { assertEquals ( pair . first , s1 [ count ] ) ; assertEquals ( pair . second , s2 [ count ] ) ; count ++ ; } assertEquals ( s1 . length < s2 . length ? s1 . length : s2 . length , count ) ; } @ SuppressWarnings ( " unchecked " ) public void testChain ( ) { List < String > s1 = Arrays . asList ( new String [ ] { " hi " , " there " } ) ; List < String > s2 = Arrays . asList ( new String [ ] { } ) ; List < String > s3 = Arrays . asList ( new String [ ] { " yoo " } ) ; List < String > s4 = Arrays . asList ( new String [ ] { } ) ; List < String > answer = Arrays . asList ( new String [ ] { " yoo " , " hi " , " there " , " yoo " } ) ; List < String > chained = new ArrayList < String > ( ) ; for ( String s : Iterables . chain ( s3 , s1 , s2 , s3 , s4 ) ) { chained . add ( s ) ; } assertEquals ( answer , chained ) ; } public void testFilter ( ) { List < String > values = Arrays . asList ( " a " , " HI " , " tHere " , " YO " ) ; Iterator < String > iterator = Iterables . filter ( values , new Function < String , Boolean > ( ) { public Boolean apply ( String in ) { return in . equals ( in . toUpperCase ( ) ) ; } } ) . iterator ( ) ; assertTrue ( iterator . hasNext ( ) ) ; assertEquals ( iterator . next ( ) , " HI " ) ; assertEquals ( iterator . next ( ) , " YO " ) ; assertFalse ( iterator . hasNext ( ) ) ; } public void testTransform ( ) { List < Integer > values = Arrays . asList ( 1 , 2 , 3 , 4 ) ; List < Integer > squares = Arrays . asList ( 1 , 4 , 9 , 16 ) ; Function < Integer , Integer > squarer = new Function < Integer , Integer > ( ) { public Integer apply ( Integer in ) { return in * in ; } } ; for ( Pair < Integer , Integer > pair : Iterables . zip ( Iterables . transform ( values , squarer ) , squares ) ) { assertEquals ( pair . first , pair . second ) ; } } public void testMerge ( ) { List < String > a = Arrays . asList ( " a " , " b " , " d " , " e " ) ; List < String > b = Arrays . asList ( " b " , " c " , " d " , " e " ) ; Comparator < String > comparator = new Comparator < String > ( ) { public int compare ( String o1 , String o2 ) { return o1 . compareTo ( o2 ) ; } } ; Iterator < Pair < String , String > > iter = Iterables . merge ( a , b , comparator ) . iterator ( ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " b " , " b " ) ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " d " , " d " ) ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " e " , " e " ) ) ; assertTrue ( ! iter . hasNext ( ) ) ; } public void testMerge3 ( ) { List < String > a = Arrays . asList ( " a " , " b " , " d " , " e " ) ; List < String > b = Arrays . asList ( " b " , " c " , " d " , " e " ) ; List < String > c = Arrays . asList ( " a " , " b " , " c " , " e " , " f " ) ; Comparator < String > comparator = new Comparator < String > ( ) { public int compare ( String o1 , String o2 ) { return o1 . compareTo ( o2 ) ; } } ; Iterator < Triple < String , String , String > > iter = Iterables . merge ( a , b , c , comparator ) . iterator ( ) ; assertEquals ( iter . next ( ) , new Triple < String , String , String > ( " b " , " b " , " b " ) ) ; assertEquals ( iter . next ( ) , new Triple < String , String , String > ( " e " , " e " , " e " ) ) ; assertTrue ( ! iter . hasNext ( ) ) ; } public void testGroup ( ) { String [ ] input = new String [ ] { "0 ▁ ab " , "0 ▁ bb " , "0 ▁ cc " , "1 ▁ dd " , "2 ▁ dd " , "2 ▁ kj " , "3 ▁ kj " , "3 ▁ kk " } ; int [ ] counts = new int [ ] { 3 , 1 , 2 , 2 } ; Comparator < String > fieldOne = new Comparator < String > ( ) { public int compare ( String o1 , String o2 ) { return o1 . split ( " ▁ " ) [ 0 ] . compareTo ( o2 . split ( " ▁ " ) [ 0 ] ) ; } } ; int index = 0 ; int group = 0 ; for ( Iterable < String > set : Iterables . group ( Arrays . asList ( input ) , fieldOne ) ) { String sharedKey = null ; int thisCount = 0 ; for ( String line : set ) { String thisKey = line . split ( " ▁ " ) [ 0 ] ; if ( sharedKey == null ) { sharedKey = thisKey ; } else { assertEquals ( " Wrong ▁ key " , sharedKey , thisKey ) ; } assertEquals ( " Wrong ▁ input ▁ line " , line , input [ index ++ ] ) ; thisCount ++ ; } assertEquals ( " Wrong ▁ number ▁ of ▁ items ▁ in ▁ this ▁ iterator " , counts [ group ++ ] , thisCount ) ; } assertEquals ( " Didn ' t ▁ get ▁ all ▁ inputs " , input . length , index ) ; assertEquals ( " Wrong ▁ number ▁ of ▁ groups " , counts . length , group ) ; } public void testSample ( ) { Iterable < Integer > items = Arrays . asList ( 5 , 4 , 3 , 2 , 1 ) ; int count = 0 ; for ( Integer item : Iterables . sample ( items , 5 , 2 , new Random ( ) ) ) { ++ count ; Assert . assertTrue ( item <= 5 ) ; Assert . assertTrue ( item >= 1 ) ; } Assert . assertEquals ( 2 , count ) ; } } </DOCUMENT>
<DOCUMENT_ID="akshayabd/jenkins/tree/master/core/src/main/java/hudson/model/ListView.java"> package hudson . model ; import hudson . Extension ; import hudson . Util ; import hudson . diagnosis . OldDataMonitor ; import hudson . model . Descriptor . FormException ; import hudson . model . listeners . ItemListener ; import hudson . security . ACL ; import hudson . util . CaseInsensitiveComparator ; import hudson . util . DescribableList ; import hudson . util . FormValidation ; import hudson . util . HttpResponses ; import hudson . views . ListViewColumn ; import hudson . views . ViewJobFilter ; import java . io . IOException ; import java . util . * ; import java . util . logging . Level ; import java . util . logging . Logger ; import java . util . regex . Pattern ; import java . util . regex . PatternSyntaxException ; import javax . annotation . concurrent . GuardedBy ; import javax . servlet . ServletException ; import jenkins . model . Jenkins ; import net . sf . json . JSONObject ; import org . kohsuke . accmod . Restricted ; import org . kohsuke . accmod . restrictions . NoExternalUse ; import org . kohsuke . stapler . DataBoundConstructor ; import org . kohsuke . stapler . HttpResponse ; import org . kohsuke . stapler . QueryParameter ; import org . kohsuke . stapler . StaplerRequest ; import org . kohsuke . stapler . StaplerResponse ; import org . kohsuke . stapler . interceptor . RequirePOST ; public class ListView extends View implements DirectlyModifiableView { @ GuardedBy ( " this " ) SortedSet < String > jobNames = new TreeSet < String > ( CaseInsensitiveComparator . INSTANCE ) ; private DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > jobFilters ; private DescribableList < ListViewColumn , Descriptor < ListViewColumn > > columns ; private String includeRegex ; private boolean recurse ; private transient Pattern includePattern ; private Boolean statusFilter ; @ DataBoundConstructor public ListView ( String name ) { super ( name ) ; initColumns ( ) ; initJobFilters ( ) ; } public ListView ( String name , ViewGroup owner ) { this ( name ) ; this . owner = owner ; } private Object readResolve ( ) { if ( includeRegex != null ) { try { includePattern = Pattern . compile ( includeRegex ) ; } catch ( PatternSyntaxException x ) { includeRegex = null ; OldDataMonitor . report ( this , Collections . < Throwable > singleton ( x ) ) ; } } if ( jobNames == null ) { jobNames = new TreeSet < String > ( CaseInsensitiveComparator . INSTANCE ) ; } initColumns ( ) ; initJobFilters ( ) ; return this ; } protected void initColumns ( ) { if ( columns == null ) columns = new DescribableList < ListViewColumn , Descriptor < ListViewColumn > > ( this , ListViewColumn . createDefaultInitialColumnList ( ) ) ; } protected void initJobFilters ( ) { if ( jobFilters == null ) jobFilters = new DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > ( this ) ; } public boolean hasJobFilterExtensions ( ) { return ! ViewJobFilter . all ( ) . isEmpty ( ) ; } public DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > getJobFilters ( ) { return jobFilters ; } @ Override public DescribableList < ListViewColumn , Descriptor < ListViewColumn > > getColumns ( ) { return columns ; } @ Override public List < TopLevelItem > getItems ( ) { SortedSet < String > names ; List < TopLevelItem > items = new ArrayList < TopLevelItem > ( ) ; synchronized ( this ) { names = new TreeSet < String > ( jobNames ) ; } ItemGroup < ? extends TopLevelItem > parent = getOwnerItemGroup ( ) ; List < TopLevelItem > parentItems = new ArrayList < TopLevelItem > ( parent . getItems ( ) ) ; includeItems ( parent , parentItems , names ) ; Boolean statusFilter = this . statusFilter ; Iterable < ? extends TopLevelItem > candidates ; if ( recurse ) { candidates = Items . getAllItems ( parent , TopLevelItem . class ) ; } else { candidates = parent . getItems ( ) ; } for ( TopLevelItem item : candidates ) { if ( ! names . contains ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ) continue ; if ( statusFilter == null || ! ( item instanceof AbstractProject ) || ( ( AbstractProject ) item ) . isDisabled ( ) ^ statusFilter ) items . add ( item ) ; } Iterable < ViewJobFilter > jobFilters = getJobFilters ( ) ; List < TopLevelItem > allItems = new ArrayList < TopLevelItem > ( parentItems ) ; if ( recurse ) allItems = expand ( allItems , new ArrayList < TopLevelItem > ( ) ) ; for ( ViewJobFilter jobFilter : jobFilters ) { items = jobFilter . filter ( items , allItems , this ) ; } items = new ArrayList < TopLevelItem > ( new LinkedHashSet < TopLevelItem > ( items ) ) ; return items ; } private List < TopLevelItem > expand ( Collection < TopLevelItem > items , List < TopLevelItem > allItems ) { for ( TopLevelItem item : items ) { if ( item instanceof ItemGroup ) { ItemGroup < ? extends Item > ig = ( ItemGroup < ? extends Item > ) item ; expand ( Util . filter ( ig . getItems ( ) , TopLevelItem . class ) , allItems ) ; } allItems . add ( item ) ; } return allItems ; } @ Override public boolean contains ( TopLevelItem item ) { return getItems ( ) . contains ( item ) ; } private void includeItems ( ItemGroup < ? extends TopLevelItem > root , Collection < ? extends Item > parentItems , SortedSet < String > names ) { if ( includePattern != null ) { for ( Item item : parentItems ) { if ( recurse && item instanceof ItemGroup ) { ItemGroup < ? > ig = ( ItemGroup < ? > ) item ; includeItems ( root , ig . getItems ( ) , names ) ; } if ( item instanceof TopLevelItem ) { String itemName = item . getRelativeNameFrom ( root ) ; if ( includePattern . matcher ( itemName ) . matches ( ) ) { names . add ( itemName ) ; } } } } } public synchronized boolean jobNamesContains ( TopLevelItem item ) { if ( item == null ) return false ; return jobNames . contains ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ; } @ Override public void add ( TopLevelItem item ) throws IOException { synchronized ( this ) { jobNames . add ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ; } save ( ) ; } @ Override public boolean remove ( TopLevelItem item ) throws IOException { synchronized ( this ) { String name = item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ; if ( ! jobNames . remove ( name ) ) return false ; } save ( ) ; return true ; } public String getIncludeRegex ( ) { return includeRegex ; } public boolean isRecurse ( ) { return recurse ; } public void setRecurse ( boolean recurse ) { this . recurse = recurse ; } public Boolean getStatusFilter ( ) { return statusFilter ; } @ Override @ RequirePOST public Item doCreateItem ( StaplerRequest req , StaplerResponse rsp ) throws IOException , ServletException { ItemGroup < ? extends TopLevelItem > ig = getOwnerItemGroup ( ) ; if ( ig instanceof ModifiableItemGroup ) { TopLevelItem item = ( ( ModifiableItemGroup < ? extends TopLevelItem > ) ig ) . doCreateItem ( req , rsp ) ; if ( item != null ) { synchronized ( this ) { jobNames . add ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ; } owner . save ( ) ; } return item ; } return null ; } @ Override @ RequirePOST public HttpResponse doAddJobToView ( @ QueryParameter String name ) throws IOException , ServletException { checkPermission ( View . CONFIGURE ) ; if ( name == null ) throw new Failure ( " Query ▁ parameter ▁ ' name ' ▁ is ▁ required " ) ; TopLevelItem item = resolveName ( name ) ; if ( item == null ) throw new Failure ( " Query ▁ parameter ▁ ' name ' ▁ does ▁ not ▁ correspond ▁ to ▁ a ▁ known ▁ item " ) ; if ( contains ( item ) ) return HttpResponses . ok ( ) ; add ( item ) ; owner . save ( ) ; return HttpResponses . ok ( ) ; } @ Override @ RequirePOST public HttpResponse doRemoveJobFromView ( @ QueryParameter String name ) throws IOException , ServletException { checkPermission ( View . CONFIGURE ) ; if ( name == null ) throw new Failure ( " Query ▁ parameter ▁ ' name ' ▁ is ▁ required " ) ; TopLevelItem item = resolveName ( name ) ; if ( remove ( item ) ) owner . save ( ) ; return HttpResponses . ok ( ) ; } private TopLevelItem resolveName ( String name ) { TopLevelItem item = getOwnerItemGroup ( ) . getItem ( name ) ; if ( item == null ) { name = Items . getCanonicalName ( getOwnerItemGroup ( ) , name ) ; item = Jenkins . getInstance ( ) . getItemByFullName ( name , TopLevelItem . class ) ; } return item ; } @ Override protected void submit ( StaplerRequest req ) throws ServletException , FormException , IOException { JSONObject json = req . getSubmittedForm ( ) ; synchronized ( this ) { recurse = json . optBoolean ( " recurse " , true ) ; jobNames . clear ( ) ; Iterable < ? extends TopLevelItem > items ; if ( recurse ) { items = Items . getAllItems ( getOwnerItemGroup ( ) , TopLevelItem . class ) ; } else { items = getOwnerItemGroup ( ) . getItems ( ) ; } for ( TopLevelItem item : items ) { String relativeNameFrom = item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ; if ( req . getParameter ( relativeNameFrom ) != null ) { jobNames . add ( relativeNameFrom ) ; } } } setIncludeRegex ( req . getParameter ( " useincluderegex " ) != null ? req . getParameter ( " includeRegex " ) : null ) ; if ( columns == null ) { columns = new DescribableList < ListViewColumn , Descriptor < ListViewColumn > > ( this ) ; } columns . rebuildHetero ( req , json , ListViewColumn . all ( ) , " columns " ) ; if ( jobFilters == null ) { jobFilters = new DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > ( this ) ; } jobFilters . rebuildHetero ( req , json , ViewJobFilter . all ( ) , " jobFilters " ) ; String filter = Util . fixEmpty ( req . getParameter ( " statusFilter " ) ) ; statusFilter = filter != null ? "1" . equals ( filter ) : null ; } public void setIncludeRegex ( String includeRegex ) { this . includeRegex = Util . nullify ( includeRegex ) ; if ( this . includeRegex == null ) this . includePattern = null ; else this . includePattern = Pattern . compile ( includeRegex ) ; } @ Extension public static class DescriptorImpl extends ViewDescriptor { @ Override public String getDisplayName ( ) { return Messages . ListView_DisplayName ( ) ; } public FormValidation doCheckIncludeRegex ( @ QueryParameter String value ) throws IOException , ServletException , InterruptedException { String v = Util . fixEmpty ( value ) ; if ( v != null ) { try { Pattern . compile ( v ) ; } catch ( PatternSyntaxException pse ) { return FormValidation . error ( pse . getMessage ( ) ) ; } } return FormValidation . ok ( ) ; } } @ Deprecated public static List < ListViewColumn > getDefaultColumns ( ) { return ListViewColumn . createDefaultInitialColumnList ( ) ; } @ Restricted ( NoExternalUse . class ) @ Extension public static final class Listener extends ItemListener { @ Override public void onLocationChanged ( final Item item , final String oldFullName , final String newFullName ) { ACL . impersonate ( ACL . SYSTEM , new Runnable ( ) { @ Override public void run ( ) { locationChanged ( item , oldFullName , newFullName ) ; } } ) ; } private void locationChanged ( Item item , String oldFullName , String newFullName ) { final Jenkins jenkins = Jenkins . getInstance ( ) ; for ( View view : jenkins . getViews ( ) ) { if ( view instanceof ListView ) { renameViewItem ( oldFullName , newFullName , jenkins , ( ListView ) view ) ; } } for ( Item g : jenkins . getAllItems ( ) ) { if ( g instanceof ViewGroup ) { ViewGroup vg = ( ViewGroup ) g ; for ( View v : vg . getViews ( ) ) { if ( v instanceof ListView ) { renameViewItem ( oldFullName , newFullName , vg , ( ListView ) v ) ; } } } } } private void renameViewItem ( String oldFullName , String newFullName , ViewGroup vg , ListView lv ) { boolean needsSave ; synchronized ( lv ) { Set < String > oldJobNames = new HashSet < String > ( lv . jobNames ) ; lv . jobNames . clear ( ) ; for ( String oldName : oldJobNames ) { lv . jobNames . add ( Items . computeRelativeNamesAfterRenaming ( oldFullName , newFullName , oldName , vg . getItemGroup ( ) ) ) ; } needsSave = ! oldJobNames . equals ( lv . jobNames ) ; } if ( needsSave ) { try { lv . save ( ) ; } catch ( IOException x ) { Logger . getLogger ( ListView . class . getName ( ) ) . log ( Level . WARNING , null , x ) ; } } } @ Override public void onDeleted ( final Item item ) { ACL . impersonate ( ACL . SYSTEM , new Runnable ( ) { @ Override public void run ( ) { deleted ( item ) ; } } ) ; } private void deleted ( Item item ) { final Jenkins jenkins = Jenkins . getInstance ( ) ; for ( View view : jenkins . getViews ( ) ) { if ( view instanceof ListView ) { deleteViewItem ( item , jenkins , ( ListView ) view ) ; } } for ( Item g : jenkins . getAllItems ( ) ) { if ( g instanceof ViewGroup ) { ViewGroup vg = ( ViewGroup ) g ; for ( View v : vg . getViews ( ) ) { if ( v instanceof ListView ) { deleteViewItem ( item , vg , ( ListView ) v ) ; } } } } } private void deleteViewItem ( Item item , ViewGroup vg , ListView lv ) { boolean needsSave ; synchronized ( lv ) { needsSave = lv . jobNames . remove ( item . getRelativeNameFrom ( vg . getItemGroup ( ) ) ) ; } if ( needsSave ) { try { lv . save ( ) ; } catch ( IOException x ) { Logger . getLogger ( ListView . class . getName ( ) ) . log ( Level . WARNING , null , x ) ; } } } } } </DOCUMENT>
<DOCUMENT_ID="JetBrains/intellij-community/tree/master/java/java-tests/testData/codeInsight/daemonCodeAnalyzer/quickFix/lambda2methodReference/afterAmbiguityWithoutSuperMethodNonStatic.java"> interface I { String foo ( Foo i ) ; } class Foo { public String foo ( ) { return null ; } String foo ( int i ) { return null ; } String foo ( Foo foo ) { return null ; } public static void main ( String [ ] args ) { I i = Foo :: foo ; } } </DOCUMENT>
<DOCUMENT_ID="christer155/IntegratingFacebookTutorial/tree/master/IntegratingFacebookTutorial-Unity/Assets/Plugins/Android/facebook/src/com/facebook/internal/ImageResponseCache.java"> package com . facebook . internal ; import android . content . Context ; import android . util . Log ; import com . facebook . LoggingBehavior ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . HttpURLConnection ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; class ImageResponseCache { static final String TAG = ImageResponseCache . class . getSimpleName ( ) ; private volatile static FileLruCache imageCache ; synchronized static FileLruCache getCache ( Context context ) throws IOException { if ( imageCache == null ) { imageCache = new FileLruCache ( context . getApplicationContext ( ) , TAG , new FileLruCache . Limits ( ) ) ; } return imageCache ; } static InputStream getCachedImageStream ( URI url , Context context ) { InputStream imageStream = null ; if ( url != null ) { if ( isCDNURL ( url ) ) { try { FileLruCache cache = getCache ( context ) ; imageStream = cache . get ( url . toString ( ) ) ; } catch ( IOException e ) { Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , e . toString ( ) ) ; } } } return imageStream ; } static InputStream interceptAndCacheImageStream ( Context context , HttpURLConnection connection ) throws IOException { InputStream stream = null ; if ( connection . getResponseCode ( ) == HttpURLConnection . HTTP_OK ) { URL url = connection . getURL ( ) ; stream = connection . getInputStream ( ) ; try { if ( isCDNURL ( url . toURI ( ) ) ) { FileLruCache cache = getCache ( context ) ; stream = cache . interceptAndPut ( url . toString ( ) , new BufferedHttpInputStream ( stream , connection ) ) ; } } catch ( IOException e ) { } catch ( URISyntaxException e ) { } } return stream ; } private static boolean isCDNURL ( URI url ) { if ( url != null ) { String uriHost = url . getHost ( ) ; if ( uriHost . endsWith ( " fbcdn . net " ) ) { return true ; } if ( uriHost . startsWith ( " fbcdn " ) && uriHost . endsWith ( " akamaihd . net " ) ) { return true ; } } return false ; } static void clearCache ( Context context ) { try { getCache ( context ) . clearCache ( ) ; } catch ( IOException e ) { Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , " clearCache ▁ failed ▁ " + e . getMessage ( ) ) ; } } private static class BufferedHttpInputStream extends BufferedInputStream { HttpURLConnection connection ; BufferedHttpInputStream ( InputStream stream , HttpURLConnection connection ) { super ( stream , Utility . DEFAULT_STREAM_BUFFER_SIZE ) ; this . connection = connection ; } @ Override public void close ( ) throws IOException { super . close ( ) ; Utility . disconnectQuietly ( connection ) ; } } } </DOCUMENT>
<DOCUMENT_ID="slburson/fast-serialization/tree/master/src/main/java/org/nustaq/serialization/serializers/FSTCPEnumSetSerializer.java"> package org . nustaq . serialization . serializers ; import org . nustaq . serialization . FSTBasicObjectSerializer ; import org . nustaq . serialization . FSTClazzInfo ; import org . nustaq . serialization . FSTObjectInput ; import org . nustaq . serialization . FSTObjectOutput ; import java . io . IOException ; import java . lang . reflect . Field ; import java . util . EnumSet ; public class FSTCPEnumSetSerializer extends FSTBasicObjectSerializer { Field elemType ; @ Override public void writeObject ( FSTObjectOutput out , Object toWrite , FSTClazzInfo clzInfo , FSTClazzInfo . FSTFieldInfo referencedBy , int streamPosition ) throws IOException { EnumSet enset = ( EnumSet ) toWrite ; int count = 0 ; out . writeInt ( enset . size ( ) ) ; if ( enset . isEmpty ( ) ) { EnumSet compl = EnumSet . complementOf ( enset ) ; out . writeClassTag ( compl . iterator ( ) . next ( ) . getClass ( ) ) ; } else { for ( Object element : enset ) { if ( count == 0 ) { out . writeStringUTF ( element . getClass ( ) . getName ( ) ) ; } out . writeStringUTF ( element . toString ( ) ) ; count ++ ; } } } @ Override public boolean alwaysCopy ( ) { return false ; } @ Override public Object instantiate ( Class objectClass , FSTObjectInput in , FSTClazzInfo serializationInfo , FSTClazzInfo . FSTFieldInfo referencee , int streamPosition ) throws Exception { int len = in . readInt ( ) ; Class elemCl = in . getClassForName ( in . readStringUTF ( ) ) ; EnumSet enSet = EnumSet . noneOf ( elemCl ) ; in . registerObject ( enSet , streamPosition , serializationInfo , referencee ) ; for ( int i = 0 ; i < len ; i ++ ) { String val = in . readStringUTF ( ) ; enSet . add ( Enum . valueOf ( elemCl , val ) ) ; } return enSet ; } } </DOCUMENT>
<DOCUMENT_ID="sklintyg/infra/tree/master/sjukfall/engine/src/test/java/se/inera/intyg/infra/sjukfall/engine/SjukfallIntygEnhetCreatorTest.java"> package se . inera . intyg . infra . sjukfall . engine ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNull ; import static org . junit . Assert . assertTrue ; import java . io . IOException ; import java . time . LocalDate ; import java . util . List ; import java . util . Map ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . mockito . junit . MockitoJUnitRunner ; import se . inera . intyg . infra . sjukfall . dto . IntygData ; import se . inera . intyg . infra . sjukfall . dto . IntygParametrar ; import se . inera . intyg . infra . sjukfall . dto . SjukfallIntyg ; import se . inera . intyg . infra . sjukfall . testdata . SjukfallIntygGenerator ; @ RunWith ( MockitoJUnitRunner . class ) public class SjukfallIntygEnhetCreatorTest { private static final String LOCATION_INTYGSDATA = " classpath : Sjukfall / Enhet / intygsdata - creator . csv " ; private static List < IntygData > intygDataList ; private SjukfallIntygEnhetCreator creator ; private IntygParametrar parameters ; @ BeforeClass public static void initTestData ( ) throws IOException { SjukfallIntygGenerator generator = new SjukfallIntygGenerator ( LOCATION_INTYGSDATA ) ; intygDataList = generator . generate ( ) . get ( ) ; assertTrue ( " Expected ▁ 16 ▁ but ▁ was ▁ " + intygDataList . size ( ) , intygDataList . size ( ) == 16 ) ; } @ Before public void setup ( ) { creator = new SjukfallIntygEnhetCreator ( ) ; parameters = new IntygParametrar ( 5 , LocalDate . parse ( "2016-02-16" ) ) ; } @ Test public void testCreatingMap ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; assertTrue ( " Expected ▁ 7 ▁ but ▁ was ▁ " + map . size ( ) , map . size ( ) == 7 ) ; } @ Test public void testReducedMap ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; Map < String , List < SjukfallIntyg > > reducedMap = creator . reduceMap ( map ) ; assertTrue ( " Expected ▁ 6 ▁ but ▁ was ▁ " + reducedMap . size ( ) , reducedMap . size ( ) == 6 ) ; } @ Test public void testSortedMap ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; Map < String , List < SjukfallIntyg > > sortedMap = creator . sortValues ( map ) ; for ( Map . Entry < String , List < SjukfallIntyg > > entry : sortedMap . entrySet ( ) ) { if ( entry . getValue ( ) . size ( ) > 1 ) { SjukfallIntyg [ ] arr = entry . getValue ( ) . toArray ( new SjukfallIntyg [ entry . getValue ( ) . size ( ) ] ) ; for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { assertTrue ( arr [ i ] . getSlutDatum ( ) . isBefore ( arr [ i + 1 ] . getSlutDatum ( ) ) ) ; } } } } @ Test public void testSetActiveCertificate ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; Map < String , List < SjukfallIntyg > > activeMap = creator . setActive ( map ) ; assertTrue ( activeMap . entrySet ( ) . stream ( ) . allMatch ( e -> e . getValue ( ) . stream ( ) . filter ( o -> o . isAktivtIntyg ( ) ) . count ( ) < 2 ) ) ; } @ Test public void testFall1 ( ) { String key = "19791110-9291" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-20" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall2 ( ) { String key = "19791123-9262" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-20" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall3 ( ) { String key = "19791212-9280" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 3 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 3 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 2 ) , "2016-02-25" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall4 ( ) { String key = "19800113-9297" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 3 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 3 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 2 ) , "2016-02-25" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall5 ( ) { String key = "19800124-9286" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-12" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-25" ) ; assertTrue ( list . get ( 0 ) . isAktivtIntyg ( ) ) ; assertFalse ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall6 ( ) { String key = "19800207-9294" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-12" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-25" ) ; assertFalse ( list . get ( 0 ) . isAktivtIntyg ( ) ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall7 ( ) { String key = "19800228-9224" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; assertNull ( map . get ( key ) ) ; } private static void assertStartDate ( SjukfallIntyg intygsData , String datum ) { assertTrue ( intygsData . getStartDatum ( ) . equals ( LocalDate . parse ( datum ) ) ) ; } private static void assertEndDate ( SjukfallIntyg intygsData , String datum ) { assertTrue ( intygsData . getSlutDatum ( ) . equals ( LocalDate . parse ( datum ) ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="murador/ignite/tree/master/modules/core/src/main/java/org/apache/ignite/internal/GridJobSiblingsResponse.java"> package org . apache . ignite . internal ; import java . io . Externalizable ; import java . nio . ByteBuffer ; import java . util . Collection ; import org . apache . ignite . IgniteCheckedException ; import org . apache . ignite . compute . ComputeJobSibling ; import org . apache . ignite . internal . util . typedef . internal . S ; import org . apache . ignite . marshaller . Marshaller ; import org . apache . ignite . plugin . extensions . communication . Message ; import org . apache . ignite . plugin . extensions . communication . MessageReader ; import org . apache . ignite . plugin . extensions . communication . MessageWriter ; import org . jetbrains . annotations . Nullable ; public class GridJobSiblingsResponse implements Message { private static final long serialVersionUID = 0L ; @ GridDirectTransient private Collection < ComputeJobSibling > siblings ; private byte [ ] siblingsBytes ; public GridJobSiblingsResponse ( ) { } public GridJobSiblingsResponse ( @ Nullable Collection < ComputeJobSibling > siblings , @ Nullable byte [ ] siblingsBytes ) { this . siblings = siblings ; this . siblingsBytes = siblingsBytes ; } public Collection < ComputeJobSibling > jobSiblings ( ) { return siblings ; } public void unmarshalSiblings ( Marshaller marsh ) throws IgniteCheckedException { assert marsh != null ; if ( siblingsBytes != null ) siblings = marsh . unmarshal ( siblingsBytes , null ) ; } @ Override public void onAckReceived ( ) { } @ Override public boolean writeTo ( ByteBuffer buf , MessageWriter writer ) { writer . setBuffer ( buf ) ; if ( ! writer . isHeaderWritten ( ) ) { if ( ! writer . writeHeader ( directType ( ) , fieldsCount ( ) ) ) return false ; writer . onHeaderWritten ( ) ; } switch ( writer . state ( ) ) { case 0 : if ( ! writer . writeByteArray ( " siblingsBytes " , siblingsBytes ) ) return false ; writer . incrementState ( ) ; } return true ; } @ Override public boolean readFrom ( ByteBuffer buf , MessageReader reader ) { reader . setBuffer ( buf ) ; if ( ! reader . beforeMessageRead ( ) ) return false ; switch ( reader . state ( ) ) { case 0 : siblingsBytes = reader . readByteArray ( " siblingsBytes " ) ; if ( ! reader . isLastRead ( ) ) return false ; reader . incrementState ( ) ; } return reader . afterMessageRead ( GridJobSiblingsResponse . class ) ; } @ Override public byte directType ( ) { return 4 ; } @ Override public byte fieldsCount ( ) { return 1 ; } @ Override public String toString ( ) { return S . toString ( GridJobSiblingsResponse . class , this ) ; } } </DOCUMENT>
<DOCUMENT_ID="shlee89/athena/tree/master/web/gui/src/main/java/org/onosproject/ui/impl/TunnelViewMessageHandler.java"> package org . onosproject . ui . impl ; import com . fasterxml . jackson . databind . node . ObjectNode ; import com . google . common . collect . ImmutableSet ; import org . onosproject . incubator . net . tunnel . Tunnel ; import org . onosproject . incubator . net . tunnel . TunnelEndPointFormatter ; import org . onosproject . incubator . net . tunnel . TunnelService ; import org . onosproject . ui . RequestHandler ; import org . onosproject . ui . UiMessageHandler ; import org . onosproject . ui . table . TableModel ; import org . onosproject . ui . table . TableRequestHandler ; import org . onosproject . ui . table . cell . EnumFormatter ; import java . util . Collection ; public class TunnelViewMessageHandler extends UiMessageHandler { private static final String TUNNEL_DATA_REQ = " tunnelDataRequest " ; private static final String TUNNEL_DATA_RESP = " tunnelDataResponse " ; private static final String TUNNELS = " tunnels " ; private static final String ID = " id " ; private static final String NAME = " name " ; private static final String ONE = " one " ; private static final String TWO = " two " ; private static final String TYPE = " type " ; private static final String GROUP_ID = " group _ id " ; private static final String BANDWIDTH = " bandwidth " ; private static final String PATH = " path " ; private static final String [ ] COL_IDS = { ID , NAME , ONE , TWO , TYPE , GROUP_ID , BANDWIDTH , PATH } ; @ Override protected Collection < RequestHandler > createRequestHandlers ( ) { return ImmutableSet . of ( new TunnelDataRequestHandler ( ) ) ; } private final class TunnelDataRequestHandler extends TableRequestHandler { private static final String NO_ROWS_MESSAGE = " No ▁ tunnels ▁ found " ; public TunnelDataRequestHandler ( ) { super ( TUNNEL_DATA_REQ , TUNNEL_DATA_RESP , TUNNELS ) ; } @ Override protected String [ ] getColumnIds ( ) { return COL_IDS ; } @ Override protected String noRowsMessage ( ObjectNode payload ) { return NO_ROWS_MESSAGE ; } @ Override protected TableModel createTableModel ( ) { TableModel tm = super . createTableModel ( ) ; tm . setFormatter ( ONE , TunnelEndPointFormatter . INSTANCE ) ; tm . setFormatter ( TWO , TunnelEndPointFormatter . INSTANCE ) ; tm . setFormatter ( TYPE , EnumFormatter . INSTANCE ) ; return tm ; } @ Override protected void populateTable ( TableModel tm , ObjectNode payload ) { TunnelService ts = get ( TunnelService . class ) ; ts . queryAllTunnels ( ) . forEach ( tunnel -> populateRow ( tm . addRow ( ) , tunnel ) ) ; } } private void populateRow ( TableModel . Row row , Tunnel tunnel ) { row . cell ( ID , tunnel . tunnelId ( ) . id ( ) ) . cell ( NAME , tunnel . tunnelName ( ) . value ( ) ) . cell ( ONE , tunnel . src ( ) ) . cell ( TWO , tunnel . dst ( ) ) . cell ( TYPE , tunnel . type ( ) ) . cell ( GROUP_ID , tunnel . groupId ( ) . id ( ) ) . cell ( BANDWIDTH , tunnel . annotations ( ) . value ( BANDWIDTH ) ) . cell ( PATH , tunnel . path ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="Lotusun/OfficeHelper/tree/master/src/main/java/com/charlesdream/office/word/objects/Style.java"> package com . charlesdream . office . word . objects ; import com . charlesdream . office . BaseObject ; import com . jacob . com . Dispatch ; public class Style extends BaseObject { public Style ( Dispatch dispatch ) { super ( dispatch ) ; } } </DOCUMENT>
<DOCUMENT_ID="borcsokj/camel/tree/master/components/camel-apns/src/test/java/org/apache/camel/component/apns/ApnsProducerTest.java"> package org . apache . camel . component . apns ; import com . notnoop . apns . APNS ; import com . notnoop . apns . ApnsService ; import com . notnoop . apns . EnhancedApnsNotification ; import com . notnoop . apns . utils . ApnsServerStub ; import org . apache . camel . CamelContext ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . component . apns . factory . ApnsServiceFactory ; import org . apache . camel . component . apns . model . ApnsConstants ; import org . apache . camel . component . apns . model . MessageType ; import org . apache . camel . component . apns . util . ApnsUtils ; import org . apache . camel . component . apns . util . TestConstants ; import org . apache . camel . test . junit4 . CamelTestSupport ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; public class ApnsProducerTest extends CamelTestSupport { private static final String FAKE_TOKEN = "19308314834701ACD8313AEBD92AEFDE192120371FE13982392831701318B943" ; private ApnsServerStub server ; @ Before public void startup ( ) { server = ApnsUtils . prepareAndStartServer ( TestConstants . TEST_GATEWAY_PORT , TestConstants . TEST_FEEDBACK_PORT ) ; } @ After public void stop ( ) { server . stop ( ) ; } @ Test ( timeout = 5000 ) public void testProducer ( ) throws Exception { String message = " Hello ▁ World " ; String messagePayload = APNS . newPayload ( ) . alertBody ( message ) . build ( ) ; EnhancedApnsNotification apnsNotification = new EnhancedApnsNotification ( 1 , EnhancedApnsNotification . MAXIMUM_EXPIRY , FAKE_TOKEN , messagePayload ) ; server . stopAt ( apnsNotification . length ( ) ) ; template . sendBody ( " direct : test " , message ) ; server . getMessages ( ) . acquire ( ) ; assertArrayEquals ( apnsNotification . marshall ( ) , server . getReceived ( ) . toByteArray ( ) ) ; } @ Test ( timeout = 5000 ) public void testProducerWithApnsNotification ( ) throws InterruptedException { String message = " Hello ▁ World " ; String messagePayload = APNS . newPayload ( ) . alertBody ( message ) . build ( ) ; final EnhancedApnsNotification apnsNotification = new EnhancedApnsNotification ( 14 , EnhancedApnsNotification . MAXIMUM_EXPIRY , FAKE_TOKEN , messagePayload ) ; server . stopAt ( apnsNotification . length ( ) ) ; template . sendBody ( " direct : testWithApnsNotification " , apnsNotification ) ; server . getMessages ( ) . acquire ( ) ; assertArrayEquals ( apnsNotification . marshall ( ) , server . getReceived ( ) . toByteArray ( ) ) ; } protected CamelContext createCamelContext ( ) throws Exception { CamelContext camelContext = super . createCamelContext ( ) ; ApnsServiceFactory apnsServiceFactory = ApnsUtils . createDefaultTestConfiguration ( camelContext ) ; ApnsService apnsService = apnsServiceFactory . getApnsService ( ) ; ApnsComponent apnsComponent = new ApnsComponent ( apnsService ) ; camelContext . addComponent ( " apns " , apnsComponent ) ; return camelContext ; } protected RouteBuilder createRouteBuilder ( ) throws Exception { return new RouteBuilder ( ) { public void configure ( ) throws Exception { from ( " direct : test " ) . setHeader ( ApnsConstants . HEADER_TOKENS , constant ( FAKE_TOKEN ) ) . to ( " apns : notify " ) ; from ( " direct : testWithApnsNotification " ) . setHeader ( ApnsConstants . HEADER_MESSAGE_TYPE , constant ( MessageType . APNS_NOTIFICATION . name ( ) ) ) . to ( " apns : notify " ) ; } } ; } } </DOCUMENT>
